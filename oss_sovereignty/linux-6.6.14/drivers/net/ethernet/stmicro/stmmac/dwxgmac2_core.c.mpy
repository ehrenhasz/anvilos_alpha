{
  "module_name": "dwxgmac2_core.c",
  "hash_id": "2ab830dc514c1f4c152c7802b46aabfa2c07ae0ed84f7e9335e1c0feca72e8ef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_core.c",
  "human_readable_source": "\n \n\n#include <linux/bitrev.h>\n#include <linux/crc32.h>\n#include <linux/iopoll.h>\n#include \"stmmac.h\"\n#include \"stmmac_ptp.h\"\n#include \"dwxlgmac2.h\"\n#include \"dwxgmac2.h\"\n\nstatic void dwxgmac2_core_init(struct mac_device_info *hw,\n\t\t\t       struct net_device *dev)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 tx, rx;\n\n\ttx = readl(ioaddr + XGMAC_TX_CONFIG);\n\trx = readl(ioaddr + XGMAC_RX_CONFIG);\n\n\ttx |= XGMAC_CORE_INIT_TX;\n\trx |= XGMAC_CORE_INIT_RX;\n\n\tif (hw->ps) {\n\t\ttx |= XGMAC_CONFIG_TE;\n\t\ttx &= ~hw->link.speed_mask;\n\n\t\tswitch (hw->ps) {\n\t\tcase SPEED_10000:\n\t\t\ttx |= hw->link.xgmii.speed10000;\n\t\t\tbreak;\n\t\tcase SPEED_2500:\n\t\t\ttx |= hw->link.speed2500;\n\t\t\tbreak;\n\t\tcase SPEED_1000:\n\t\tdefault:\n\t\t\ttx |= hw->link.speed1000;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twritel(tx, ioaddr + XGMAC_TX_CONFIG);\n\twritel(rx, ioaddr + XGMAC_RX_CONFIG);\n\twritel(XGMAC_INT_DEFAULT_EN, ioaddr + XGMAC_INT_EN);\n}\n\nstatic void xgmac_phylink_get_caps(struct stmmac_priv *priv)\n{\n\tpriv->phylink_config.mac_capabilities |= MAC_2500FD | MAC_5000FD |\n\t\t\t\t\t\t MAC_10000FD | MAC_25000FD |\n\t\t\t\t\t\t MAC_40000FD | MAC_50000FD |\n\t\t\t\t\t\t MAC_100000FD;\n}\n\nstatic void dwxgmac2_set_mac(void __iomem *ioaddr, bool enable)\n{\n\tu32 tx = readl(ioaddr + XGMAC_TX_CONFIG);\n\tu32 rx = readl(ioaddr + XGMAC_RX_CONFIG);\n\n\tif (enable) {\n\t\ttx |= XGMAC_CONFIG_TE;\n\t\trx |= XGMAC_CONFIG_RE;\n\t} else {\n\t\ttx &= ~XGMAC_CONFIG_TE;\n\t\trx &= ~XGMAC_CONFIG_RE;\n\t}\n\n\twritel(tx, ioaddr + XGMAC_TX_CONFIG);\n\twritel(rx, ioaddr + XGMAC_RX_CONFIG);\n}\n\nstatic int dwxgmac2_rx_ipc(struct mac_device_info *hw)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\tvalue = readl(ioaddr + XGMAC_RX_CONFIG);\n\tif (hw->rx_csum)\n\t\tvalue |= XGMAC_CONFIG_IPC;\n\telse\n\t\tvalue &= ~XGMAC_CONFIG_IPC;\n\twritel(value, ioaddr + XGMAC_RX_CONFIG);\n\n\treturn !!(readl(ioaddr + XGMAC_RX_CONFIG) & XGMAC_CONFIG_IPC);\n}\n\nstatic void dwxgmac2_rx_queue_enable(struct mac_device_info *hw, u8 mode,\n\t\t\t\t     u32 queue)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\tvalue = readl(ioaddr + XGMAC_RXQ_CTRL0) & ~XGMAC_RXQEN(queue);\n\tif (mode == MTL_QUEUE_AVB)\n\t\tvalue |= 0x1 << XGMAC_RXQEN_SHIFT(queue);\n\telse if (mode == MTL_QUEUE_DCB)\n\t\tvalue |= 0x2 << XGMAC_RXQEN_SHIFT(queue);\n\twritel(value, ioaddr + XGMAC_RXQ_CTRL0);\n}\n\nstatic void dwxgmac2_rx_queue_prio(struct mac_device_info *hw, u32 prio,\n\t\t\t\t   u32 queue)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value, reg;\n\n\treg = (queue < 4) ? XGMAC_RXQ_CTRL2 : XGMAC_RXQ_CTRL3;\n\tif (queue >= 4)\n\t\tqueue -= 4;\n\n\tvalue = readl(ioaddr + reg);\n\tvalue &= ~XGMAC_PSRQ(queue);\n\tvalue |= (prio << XGMAC_PSRQ_SHIFT(queue)) & XGMAC_PSRQ(queue);\n\n\twritel(value, ioaddr + reg);\n}\n\nstatic void dwxgmac2_tx_queue_prio(struct mac_device_info *hw, u32 prio,\n\t\t\t\t   u32 queue)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value, reg;\n\n\treg = (queue < 4) ? XGMAC_TC_PRTY_MAP0 : XGMAC_TC_PRTY_MAP1;\n\tif (queue >= 4)\n\t\tqueue -= 4;\n\n\tvalue = readl(ioaddr + reg);\n\tvalue &= ~XGMAC_PSTC(queue);\n\tvalue |= (prio << XGMAC_PSTC_SHIFT(queue)) & XGMAC_PSTC(queue);\n\n\twritel(value, ioaddr + reg);\n}\n\nstatic void dwxgmac2_rx_queue_routing(struct mac_device_info *hw,\n\t\t\t\t      u8 packet, u32 queue)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\tstatic const struct stmmac_rx_routing dwxgmac2_route_possibilities[] = {\n\t\t{ XGMAC_AVCPQ, XGMAC_AVCPQ_SHIFT },\n\t\t{ XGMAC_PTPQ, XGMAC_PTPQ_SHIFT },\n\t\t{ XGMAC_DCBCPQ, XGMAC_DCBCPQ_SHIFT },\n\t\t{ XGMAC_UPQ, XGMAC_UPQ_SHIFT },\n\t\t{ XGMAC_MCBCQ, XGMAC_MCBCQ_SHIFT },\n\t};\n\n\tvalue = readl(ioaddr + XGMAC_RXQ_CTRL1);\n\n\t \n\tvalue &= ~dwxgmac2_route_possibilities[packet - 1].reg_mask;\n\tvalue |= (queue << dwxgmac2_route_possibilities[packet - 1].reg_shift) &\n\t\t dwxgmac2_route_possibilities[packet - 1].reg_mask;\n\n\t \n\tif (packet == PACKET_AVCPQ)\n\t\tvalue |= FIELD_PREP(XGMAC_TACPQE, 1);\n\telse if (packet == PACKET_MCBCQ)\n\t\tvalue |= FIELD_PREP(XGMAC_MCBCQEN, 1);\n\n\twritel(value, ioaddr + XGMAC_RXQ_CTRL1);\n}\n\nstatic void dwxgmac2_prog_mtl_rx_algorithms(struct mac_device_info *hw,\n\t\t\t\t\t    u32 rx_alg)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\tvalue = readl(ioaddr + XGMAC_MTL_OPMODE);\n\tvalue &= ~XGMAC_RAA;\n\n\tswitch (rx_alg) {\n\tcase MTL_RX_ALGORITHM_SP:\n\t\tbreak;\n\tcase MTL_RX_ALGORITHM_WSP:\n\t\tvalue |= XGMAC_RAA;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\twritel(value, ioaddr + XGMAC_MTL_OPMODE);\n}\n\nstatic void dwxgmac2_prog_mtl_tx_algorithms(struct mac_device_info *hw,\n\t\t\t\t\t    u32 tx_alg)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tbool ets = true;\n\tu32 value;\n\tint i;\n\n\tvalue = readl(ioaddr + XGMAC_MTL_OPMODE);\n\tvalue &= ~XGMAC_ETSALG;\n\n\tswitch (tx_alg) {\n\tcase MTL_TX_ALGORITHM_WRR:\n\t\tvalue |= XGMAC_WRR;\n\t\tbreak;\n\tcase MTL_TX_ALGORITHM_WFQ:\n\t\tvalue |= XGMAC_WFQ;\n\t\tbreak;\n\tcase MTL_TX_ALGORITHM_DWRR:\n\t\tvalue |= XGMAC_DWRR;\n\t\tbreak;\n\tdefault:\n\t\tets = false;\n\t\tbreak;\n\t}\n\n\twritel(value, ioaddr + XGMAC_MTL_OPMODE);\n\n\t \n\tfor (i = 0; i < MTL_MAX_TX_QUEUES; i++) {\n\t\tvalue = readl(ioaddr + XGMAC_MTL_TCx_ETS_CONTROL(i));\n\t\tvalue &= ~XGMAC_TSA;\n\t\tif (ets)\n\t\t\tvalue |= XGMAC_ETS;\n\t\twritel(value, ioaddr + XGMAC_MTL_TCx_ETS_CONTROL(i));\n\t}\n}\n\nstatic void dwxgmac2_set_mtl_tx_queue_weight(struct stmmac_priv *priv,\n\t\t\t\t\t     struct mac_device_info *hw,\n\t\t\t\t\t     u32 weight, u32 queue)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\n\twritel(weight, ioaddr + XGMAC_MTL_TCx_QUANTUM_WEIGHT(queue));\n}\n\nstatic void dwxgmac2_map_mtl_to_dma(struct mac_device_info *hw, u32 queue,\n\t\t\t\t    u32 chan)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value, reg;\n\n\treg = (queue < 4) ? XGMAC_MTL_RXQ_DMA_MAP0 : XGMAC_MTL_RXQ_DMA_MAP1;\n\tif (queue >= 4)\n\t\tqueue -= 4;\n\n\tvalue = readl(ioaddr + reg);\n\tvalue &= ~XGMAC_QxMDMACH(queue);\n\tvalue |= (chan << XGMAC_QxMDMACH_SHIFT(queue)) & XGMAC_QxMDMACH(queue);\n\n\twritel(value, ioaddr + reg);\n}\n\nstatic void dwxgmac2_config_cbs(struct stmmac_priv *priv,\n\t\t\t\tstruct mac_device_info *hw,\n\t\t\t\tu32 send_slope, u32 idle_slope,\n\t\t\t\tu32 high_credit, u32 low_credit, u32 queue)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\twritel(send_slope, ioaddr + XGMAC_MTL_TCx_SENDSLOPE(queue));\n\twritel(idle_slope, ioaddr + XGMAC_MTL_TCx_QUANTUM_WEIGHT(queue));\n\twritel(high_credit, ioaddr + XGMAC_MTL_TCx_HICREDIT(queue));\n\twritel(low_credit, ioaddr + XGMAC_MTL_TCx_LOCREDIT(queue));\n\n\tvalue = readl(ioaddr + XGMAC_MTL_TCx_ETS_CONTROL(queue));\n\tvalue &= ~XGMAC_TSA;\n\tvalue |= XGMAC_CC | XGMAC_CBS;\n\twritel(value, ioaddr + XGMAC_MTL_TCx_ETS_CONTROL(queue));\n}\n\nstatic void dwxgmac2_dump_regs(struct mac_device_info *hw, u32 *reg_space)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tint i;\n\n\tfor (i = 0; i < XGMAC_MAC_REGSIZE; i++)\n\t\treg_space[i] = readl(ioaddr + i * 4);\n}\n\nstatic int dwxgmac2_host_irq_status(struct mac_device_info *hw,\n\t\t\t\t    struct stmmac_extra_stats *x)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 stat, en;\n\tint ret = 0;\n\n\ten = readl(ioaddr + XGMAC_INT_EN);\n\tstat = readl(ioaddr + XGMAC_INT_STATUS);\n\n\tstat &= en;\n\n\tif (stat & XGMAC_PMTIS) {\n\t\tx->irq_receive_pmt_irq_n++;\n\t\treadl(ioaddr + XGMAC_PMT);\n\t}\n\n\tif (stat & XGMAC_LPIIS) {\n\t\tu32 lpi = readl(ioaddr + XGMAC_LPI_CTRL);\n\n\t\tif (lpi & XGMAC_TLPIEN) {\n\t\t\tret |= CORE_IRQ_TX_PATH_IN_LPI_MODE;\n\t\t\tx->irq_tx_path_in_lpi_mode_n++;\n\t\t}\n\t\tif (lpi & XGMAC_TLPIEX) {\n\t\t\tret |= CORE_IRQ_TX_PATH_EXIT_LPI_MODE;\n\t\t\tx->irq_tx_path_exit_lpi_mode_n++;\n\t\t}\n\t\tif (lpi & XGMAC_RLPIEN)\n\t\t\tx->irq_rx_path_in_lpi_mode_n++;\n\t\tif (lpi & XGMAC_RLPIEX)\n\t\t\tx->irq_rx_path_exit_lpi_mode_n++;\n\t}\n\n\treturn ret;\n}\n\nstatic int dwxgmac2_host_mtl_irq_status(struct stmmac_priv *priv,\n\t\t\t\t\tstruct mac_device_info *hw, u32 chan)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tint ret = 0;\n\tu32 status;\n\n\tstatus = readl(ioaddr + XGMAC_MTL_INT_STATUS);\n\tif (status & BIT(chan)) {\n\t\tu32 chan_status = readl(ioaddr + XGMAC_MTL_QINT_STATUS(chan));\n\n\t\tif (chan_status & XGMAC_RXOVFIS)\n\t\t\tret |= CORE_IRQ_MTL_RX_OVERFLOW;\n\n\t\twritel(~0x0, ioaddr + XGMAC_MTL_QINT_STATUS(chan));\n\t}\n\n\treturn ret;\n}\n\nstatic void dwxgmac2_flow_ctrl(struct mac_device_info *hw, unsigned int duplex,\n\t\t\t       unsigned int fc, unsigned int pause_time,\n\t\t\t       u32 tx_cnt)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 i;\n\n\tif (fc & FLOW_RX)\n\t\twritel(XGMAC_RFE, ioaddr + XGMAC_RX_FLOW_CTRL);\n\tif (fc & FLOW_TX) {\n\t\tfor (i = 0; i < tx_cnt; i++) {\n\t\t\tu32 value = XGMAC_TFE;\n\n\t\t\tif (duplex)\n\t\t\t\tvalue |= pause_time << XGMAC_PT_SHIFT;\n\n\t\t\twritel(value, ioaddr + XGMAC_Qx_TX_FLOW_CTRL(i));\n\t\t}\n\t}\n}\n\nstatic void dwxgmac2_pmt(struct mac_device_info *hw, unsigned long mode)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 val = 0x0;\n\n\tif (mode & WAKE_MAGIC)\n\t\tval |= XGMAC_PWRDWN | XGMAC_MGKPKTEN;\n\tif (mode & WAKE_UCAST)\n\t\tval |= XGMAC_PWRDWN | XGMAC_GLBLUCAST | XGMAC_RWKPKTEN;\n\tif (val) {\n\t\tu32 cfg = readl(ioaddr + XGMAC_RX_CONFIG);\n\t\tcfg |= XGMAC_CONFIG_RE;\n\t\twritel(cfg, ioaddr + XGMAC_RX_CONFIG);\n\t}\n\n\twritel(val, ioaddr + XGMAC_PMT);\n}\n\nstatic void dwxgmac2_set_umac_addr(struct mac_device_info *hw,\n\t\t\t\t   const unsigned char *addr,\n\t\t\t\t   unsigned int reg_n)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\tvalue = (addr[5] << 8) | addr[4];\n\twritel(value | XGMAC_AE, ioaddr + XGMAC_ADDRx_HIGH(reg_n));\n\n\tvalue = (addr[3] << 24) | (addr[2] << 16) | (addr[1] << 8) | addr[0];\n\twritel(value, ioaddr + XGMAC_ADDRx_LOW(reg_n));\n}\n\nstatic void dwxgmac2_get_umac_addr(struct mac_device_info *hw,\n\t\t\t\t   unsigned char *addr, unsigned int reg_n)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 hi_addr, lo_addr;\n\n\t \n\thi_addr = readl(ioaddr + XGMAC_ADDRx_HIGH(reg_n));\n\tlo_addr = readl(ioaddr + XGMAC_ADDRx_LOW(reg_n));\n\n\t \n\taddr[0] = lo_addr & 0xff;\n\taddr[1] = (lo_addr >> 8) & 0xff;\n\taddr[2] = (lo_addr >> 16) & 0xff;\n\taddr[3] = (lo_addr >> 24) & 0xff;\n\taddr[4] = hi_addr & 0xff;\n\taddr[5] = (hi_addr >> 8) & 0xff;\n}\n\nstatic void dwxgmac2_set_eee_mode(struct mac_device_info *hw,\n\t\t\t\t  bool en_tx_lpi_clockgating)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\tvalue = readl(ioaddr + XGMAC_LPI_CTRL);\n\n\tvalue |= XGMAC_LPITXEN | XGMAC_LPITXA;\n\tif (en_tx_lpi_clockgating)\n\t\tvalue |= XGMAC_TXCGE;\n\n\twritel(value, ioaddr + XGMAC_LPI_CTRL);\n}\n\nstatic void dwxgmac2_reset_eee_mode(struct mac_device_info *hw)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\tvalue = readl(ioaddr + XGMAC_LPI_CTRL);\n\tvalue &= ~(XGMAC_LPITXEN | XGMAC_LPITXA | XGMAC_TXCGE);\n\twritel(value, ioaddr + XGMAC_LPI_CTRL);\n}\n\nstatic void dwxgmac2_set_eee_pls(struct mac_device_info *hw, int link)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\tvalue = readl(ioaddr + XGMAC_LPI_CTRL);\n\tif (link)\n\t\tvalue |= XGMAC_PLS;\n\telse\n\t\tvalue &= ~XGMAC_PLS;\n\twritel(value, ioaddr + XGMAC_LPI_CTRL);\n}\n\nstatic void dwxgmac2_set_eee_timer(struct mac_device_info *hw, int ls, int tw)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\tvalue = (tw & 0xffff) | ((ls & 0x3ff) << 16);\n\twritel(value, ioaddr + XGMAC_LPI_TIMER_CTRL);\n}\n\nstatic void dwxgmac2_set_mchash(void __iomem *ioaddr, u32 *mcfilterbits,\n\t\t\t\tint mcbitslog2)\n{\n\tint numhashregs, regs;\n\n\tswitch (mcbitslog2) {\n\tcase 6:\n\t\tnumhashregs = 2;\n\t\tbreak;\n\tcase 7:\n\t\tnumhashregs = 4;\n\t\tbreak;\n\tcase 8:\n\t\tnumhashregs = 8;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tfor (regs = 0; regs < numhashregs; regs++)\n\t\twritel(mcfilterbits[regs], ioaddr + XGMAC_HASH_TABLE(regs));\n}\n\nstatic void dwxgmac2_set_filter(struct mac_device_info *hw,\n\t\t\t\tstruct net_device *dev)\n{\n\tvoid __iomem *ioaddr = (void __iomem *)dev->base_addr;\n\tu32 value = readl(ioaddr + XGMAC_PACKET_FILTER);\n\tint mcbitslog2 = hw->mcast_bits_log2;\n\tu32 mc_filter[8];\n\tint i;\n\n\tvalue &= ~(XGMAC_FILTER_PR | XGMAC_FILTER_HMC | XGMAC_FILTER_PM);\n\tvalue |= XGMAC_FILTER_HPF;\n\n\tmemset(mc_filter, 0, sizeof(mc_filter));\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\tvalue |= XGMAC_FILTER_PR;\n\t\tvalue |= XGMAC_FILTER_PCF;\n\t} else if ((dev->flags & IFF_ALLMULTI) ||\n\t\t   (netdev_mc_count(dev) > hw->multicast_filter_bins)) {\n\t\tvalue |= XGMAC_FILTER_PM;\n\n\t\tfor (i = 0; i < XGMAC_MAX_HASH_TABLE; i++)\n\t\t\twritel(~0x0, ioaddr + XGMAC_HASH_TABLE(i));\n\t} else if (!netdev_mc_empty(dev) && (dev->flags & IFF_MULTICAST)) {\n\t\tstruct netdev_hw_addr *ha;\n\n\t\tvalue |= XGMAC_FILTER_HMC;\n\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tu32 nr = (bitrev32(~crc32_le(~0, ha->addr, 6)) >>\n\t\t\t\t\t(32 - mcbitslog2));\n\t\t\tmc_filter[nr >> 5] |= (1 << (nr & 0x1F));\n\t\t}\n\t}\n\n\tdwxgmac2_set_mchash(ioaddr, mc_filter, mcbitslog2);\n\n\t \n\tif (netdev_uc_count(dev) > hw->unicast_filter_entries) {\n\t\tvalue |= XGMAC_FILTER_PR;\n\t} else {\n\t\tstruct netdev_hw_addr *ha;\n\t\tint reg = 1;\n\n\t\tnetdev_for_each_uc_addr(ha, dev) {\n\t\t\tdwxgmac2_set_umac_addr(hw, ha->addr, reg);\n\t\t\treg++;\n\t\t}\n\n\t\tfor ( ; reg < XGMAC_ADDR_MAX; reg++) {\n\t\t\twritel(0, ioaddr + XGMAC_ADDRx_HIGH(reg));\n\t\t\twritel(0, ioaddr + XGMAC_ADDRx_LOW(reg));\n\t\t}\n\t}\n\n\twritel(value, ioaddr + XGMAC_PACKET_FILTER);\n}\n\nstatic void dwxgmac2_set_mac_loopback(void __iomem *ioaddr, bool enable)\n{\n\tu32 value = readl(ioaddr + XGMAC_RX_CONFIG);\n\n\tif (enable)\n\t\tvalue |= XGMAC_CONFIG_LM;\n\telse\n\t\tvalue &= ~XGMAC_CONFIG_LM;\n\n\twritel(value, ioaddr + XGMAC_RX_CONFIG);\n}\n\nstatic int dwxgmac2_rss_write_reg(void __iomem *ioaddr, bool is_key, int idx,\n\t\t\t\t  u32 val)\n{\n\tu32 ctrl = 0;\n\n\twritel(val, ioaddr + XGMAC_RSS_DATA);\n\tctrl |= idx << XGMAC_RSSIA_SHIFT;\n\tctrl |= is_key ? XGMAC_ADDRT : 0x0;\n\tctrl |= XGMAC_OB;\n\twritel(ctrl, ioaddr + XGMAC_RSS_ADDR);\n\n\treturn readl_poll_timeout(ioaddr + XGMAC_RSS_ADDR, ctrl,\n\t\t\t\t  !(ctrl & XGMAC_OB), 100, 10000);\n}\n\nstatic int dwxgmac2_rss_configure(struct mac_device_info *hw,\n\t\t\t\t  struct stmmac_rss *cfg, u32 num_rxq)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value, *key;\n\tint i, ret;\n\n\tvalue = readl(ioaddr + XGMAC_RSS_CTRL);\n\tif (!cfg || !cfg->enable) {\n\t\tvalue &= ~XGMAC_RSSE;\n\t\twritel(value, ioaddr + XGMAC_RSS_CTRL);\n\t\treturn 0;\n\t}\n\n\tkey = (u32 *)cfg->key;\n\tfor (i = 0; i < (ARRAY_SIZE(cfg->key) / sizeof(u32)); i++) {\n\t\tret = dwxgmac2_rss_write_reg(ioaddr, true, i, key[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(cfg->table); i++) {\n\t\tret = dwxgmac2_rss_write_reg(ioaddr, false, i, cfg->table[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < num_rxq; i++)\n\t\tdwxgmac2_map_mtl_to_dma(hw, i, XGMAC_QDDMACH);\n\n\tvalue |= XGMAC_UDP4TE | XGMAC_TCP4TE | XGMAC_IP2TE | XGMAC_RSSE;\n\twritel(value, ioaddr + XGMAC_RSS_CTRL);\n\treturn 0;\n}\n\nstatic void dwxgmac2_update_vlan_hash(struct mac_device_info *hw, u32 hash,\n\t\t\t\t      __le16 perfect_match, bool is_double)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\n\twritel(hash, ioaddr + XGMAC_VLAN_HASH_TABLE);\n\n\tif (hash) {\n\t\tu32 value = readl(ioaddr + XGMAC_PACKET_FILTER);\n\n\t\tvalue |= XGMAC_FILTER_VTFE;\n\n\t\twritel(value, ioaddr + XGMAC_PACKET_FILTER);\n\n\t\tvalue = readl(ioaddr + XGMAC_VLAN_TAG);\n\n\t\tvalue |= XGMAC_VLAN_VTHM | XGMAC_VLAN_ETV;\n\t\tif (is_double) {\n\t\t\tvalue |= XGMAC_VLAN_EDVLP;\n\t\t\tvalue |= XGMAC_VLAN_ESVL;\n\t\t\tvalue |= XGMAC_VLAN_DOVLTC;\n\t\t} else {\n\t\t\tvalue &= ~XGMAC_VLAN_EDVLP;\n\t\t\tvalue &= ~XGMAC_VLAN_ESVL;\n\t\t\tvalue &= ~XGMAC_VLAN_DOVLTC;\n\t\t}\n\n\t\tvalue &= ~XGMAC_VLAN_VID;\n\t\twritel(value, ioaddr + XGMAC_VLAN_TAG);\n\t} else if (perfect_match) {\n\t\tu32 value = readl(ioaddr + XGMAC_PACKET_FILTER);\n\n\t\tvalue |= XGMAC_FILTER_VTFE;\n\n\t\twritel(value, ioaddr + XGMAC_PACKET_FILTER);\n\n\t\tvalue = readl(ioaddr + XGMAC_VLAN_TAG);\n\n\t\tvalue &= ~XGMAC_VLAN_VTHM;\n\t\tvalue |= XGMAC_VLAN_ETV;\n\t\tif (is_double) {\n\t\t\tvalue |= XGMAC_VLAN_EDVLP;\n\t\t\tvalue |= XGMAC_VLAN_ESVL;\n\t\t\tvalue |= XGMAC_VLAN_DOVLTC;\n\t\t} else {\n\t\t\tvalue &= ~XGMAC_VLAN_EDVLP;\n\t\t\tvalue &= ~XGMAC_VLAN_ESVL;\n\t\t\tvalue &= ~XGMAC_VLAN_DOVLTC;\n\t\t}\n\n\t\tvalue &= ~XGMAC_VLAN_VID;\n\t\twritel(value | perfect_match, ioaddr + XGMAC_VLAN_TAG);\n\t} else {\n\t\tu32 value = readl(ioaddr + XGMAC_PACKET_FILTER);\n\n\t\tvalue &= ~XGMAC_FILTER_VTFE;\n\n\t\twritel(value, ioaddr + XGMAC_PACKET_FILTER);\n\n\t\tvalue = readl(ioaddr + XGMAC_VLAN_TAG);\n\n\t\tvalue &= ~(XGMAC_VLAN_VTHM | XGMAC_VLAN_ETV);\n\t\tvalue &= ~(XGMAC_VLAN_EDVLP | XGMAC_VLAN_ESVL);\n\t\tvalue &= ~XGMAC_VLAN_DOVLTC;\n\t\tvalue &= ~XGMAC_VLAN_VID;\n\n\t\twritel(value, ioaddr + XGMAC_VLAN_TAG);\n\t}\n}\n\nstruct dwxgmac3_error_desc {\n\tbool valid;\n\tconst char *desc;\n\tconst char *detailed_desc;\n};\n\n#define STAT_OFF(field)\t\toffsetof(struct stmmac_safety_stats, field)\n\nstatic void dwxgmac3_log_error(struct net_device *ndev, u32 value, bool corr,\n\t\t\t       const char *module_name,\n\t\t\t       const struct dwxgmac3_error_desc *desc,\n\t\t\t       unsigned long field_offset,\n\t\t\t       struct stmmac_safety_stats *stats)\n{\n\tunsigned long loc, mask;\n\tu8 *bptr = (u8 *)stats;\n\tunsigned long *ptr;\n\n\tptr = (unsigned long *)(bptr + field_offset);\n\n\tmask = value;\n\tfor_each_set_bit(loc, &mask, 32) {\n\t\tnetdev_err(ndev, \"Found %s error in %s: '%s: %s'\\n\", corr ?\n\t\t\t\t\"correctable\" : \"uncorrectable\", module_name,\n\t\t\t\tdesc[loc].desc, desc[loc].detailed_desc);\n\n\t\t \n\t\tptr[loc]++;\n\t}\n}\n\nstatic const struct dwxgmac3_error_desc dwxgmac3_mac_errors[32]= {\n\t{ true, \"ATPES\", \"Application Transmit Interface Parity Check Error\" },\n\t{ true, \"DPES\", \"Descriptor Cache Data Path Parity Check Error\" },\n\t{ true, \"TPES\", \"TSO Data Path Parity Check Error\" },\n\t{ true, \"TSOPES\", \"TSO Header Data Path Parity Check Error\" },\n\t{ true, \"MTPES\", \"MTL Data Path Parity Check Error\" },\n\t{ true, \"MTSPES\", \"MTL TX Status Data Path Parity Check Error\" },\n\t{ true, \"MTBUPES\", \"MAC TBU Data Path Parity Check Error\" },\n\t{ true, \"MTFCPES\", \"MAC TFC Data Path Parity Check Error\" },\n\t{ true, \"ARPES\", \"Application Receive Interface Data Path Parity Check Error\" },\n\t{ true, \"MRWCPES\", \"MTL RWC Data Path Parity Check Error\" },\n\t{ true, \"MRRCPES\", \"MTL RCC Data Path Parity Check Error\" },\n\t{ true, \"CWPES\", \"CSR Write Data Path Parity Check Error\" },\n\t{ true, \"ASRPES\", \"AXI Slave Read Data Path Parity Check Error\" },\n\t{ true, \"TTES\", \"TX FSM Timeout Error\" },\n\t{ true, \"RTES\", \"RX FSM Timeout Error\" },\n\t{ true, \"CTES\", \"CSR FSM Timeout Error\" },\n\t{ true, \"ATES\", \"APP FSM Timeout Error\" },\n\t{ true, \"PTES\", \"PTP FSM Timeout Error\" },\n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ true, \"MSTTES\", \"Master Read/Write Timeout Error\" },\n\t{ true, \"SLVTES\", \"Slave Read/Write Timeout Error\" },\n\t{ true, \"ATITES\", \"Application Timeout on ATI Interface Error\" },\n\t{ true, \"ARITES\", \"Application Timeout on ARI Interface Error\" },\n\t{ true, \"FSMPES\", \"FSM State Parity Error\" },\n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ true, \"CPI\", \"Control Register Parity Check Error\" },\n};\n\nstatic void dwxgmac3_handle_mac_err(struct net_device *ndev,\n\t\t\t\t    void __iomem *ioaddr, bool correctable,\n\t\t\t\t    struct stmmac_safety_stats *stats)\n{\n\tu32 value;\n\n\tvalue = readl(ioaddr + XGMAC_MAC_DPP_FSM_INT_STATUS);\n\twritel(value, ioaddr + XGMAC_MAC_DPP_FSM_INT_STATUS);\n\n\tdwxgmac3_log_error(ndev, value, correctable, \"MAC\",\n\t\t\t   dwxgmac3_mac_errors, STAT_OFF(mac_errors), stats);\n}\n\nstatic const struct dwxgmac3_error_desc dwxgmac3_mtl_errors[32]= {\n\t{ true, \"TXCES\", \"MTL TX Memory Error\" },\n\t{ true, \"TXAMS\", \"MTL TX Memory Address Mismatch Error\" },\n\t{ true, \"TXUES\", \"MTL TX Memory Error\" },\n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ true, \"RXCES\", \"MTL RX Memory Error\" },\n\t{ true, \"RXAMS\", \"MTL RX Memory Address Mismatch Error\" },\n\t{ true, \"RXUES\", \"MTL RX Memory Error\" },\n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ true, \"ECES\", \"MTL EST Memory Error\" },\n\t{ true, \"EAMS\", \"MTL EST Memory Address Mismatch Error\" },\n\t{ true, \"EUES\", \"MTL EST Memory Error\" },\n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ true, \"RPCES\", \"MTL RX Parser Memory Error\" },\n\t{ true, \"RPAMS\", \"MTL RX Parser Memory Address Mismatch Error\" },\n\t{ true, \"RPUES\", \"MTL RX Parser Memory Error\" },\n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n};\n\nstatic void dwxgmac3_handle_mtl_err(struct net_device *ndev,\n\t\t\t\t    void __iomem *ioaddr, bool correctable,\n\t\t\t\t    struct stmmac_safety_stats *stats)\n{\n\tu32 value;\n\n\tvalue = readl(ioaddr + XGMAC_MTL_ECC_INT_STATUS);\n\twritel(value, ioaddr + XGMAC_MTL_ECC_INT_STATUS);\n\n\tdwxgmac3_log_error(ndev, value, correctable, \"MTL\",\n\t\t\t   dwxgmac3_mtl_errors, STAT_OFF(mtl_errors), stats);\n}\n\nstatic const struct dwxgmac3_error_desc dwxgmac3_dma_errors[32]= {\n\t{ true, \"TCES\", \"DMA TSO Memory Error\" },\n\t{ true, \"TAMS\", \"DMA TSO Memory Address Mismatch Error\" },\n\t{ true, \"TUES\", \"DMA TSO Memory Error\" },\n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ true, \"DCES\", \"DMA DCACHE Memory Error\" },\n\t{ true, \"DAMS\", \"DMA DCACHE Address Mismatch Error\" },\n\t{ true, \"DUES\", \"DMA DCACHE Memory Error\" },\n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n};\n\nstatic void dwxgmac3_handle_dma_err(struct net_device *ndev,\n\t\t\t\t    void __iomem *ioaddr, bool correctable,\n\t\t\t\t    struct stmmac_safety_stats *stats)\n{\n\tu32 value;\n\n\tvalue = readl(ioaddr + XGMAC_DMA_ECC_INT_STATUS);\n\twritel(value, ioaddr + XGMAC_DMA_ECC_INT_STATUS);\n\n\tdwxgmac3_log_error(ndev, value, correctable, \"DMA\",\n\t\t\t   dwxgmac3_dma_errors, STAT_OFF(dma_errors), stats);\n}\n\nstatic int\ndwxgmac3_safety_feat_config(void __iomem *ioaddr, unsigned int asp,\n\t\t\t    struct stmmac_safety_feature_cfg *safety_cfg)\n{\n\tu32 value;\n\n\tif (!asp)\n\t\treturn -EINVAL;\n\n\t \n\twritel(0x0, ioaddr + XGMAC_MTL_ECC_CONTROL);\n\n\t \n\tvalue = readl(ioaddr + XGMAC_MTL_ECC_INT_ENABLE);\n\tvalue |= XGMAC_RPCEIE;  \n\tvalue |= XGMAC_ECEIE;  \n\tvalue |= XGMAC_RXCEIE;  \n\tvalue |= XGMAC_TXCEIE;  \n\twritel(value, ioaddr + XGMAC_MTL_ECC_INT_ENABLE);\n\n\t \n\tvalue = readl(ioaddr + XGMAC_DMA_ECC_INT_ENABLE);\n\tvalue |= XGMAC_DCEIE;  \n\tvalue |= XGMAC_TCEIE;  \n\twritel(value, ioaddr + XGMAC_DMA_ECC_INT_ENABLE);\n\n\t \n\tif (asp == 0x2 || asp == 0x4)\n\t\treturn 0;\n\n\t \n\tvalue = readl(ioaddr + XGMAC_MAC_FSM_CONTROL);\n\tvalue |= XGMAC_PRTYEN;  \n\tvalue |= XGMAC_TMOUTEN;  \n\twritel(value, ioaddr + XGMAC_MAC_FSM_CONTROL);\n\n\treturn 0;\n}\n\nstatic int dwxgmac3_safety_feat_irq_status(struct net_device *ndev,\n\t\t\t\t\t   void __iomem *ioaddr,\n\t\t\t\t\t   unsigned int asp,\n\t\t\t\t\t   struct stmmac_safety_stats *stats)\n{\n\tbool err, corr;\n\tu32 mtl, dma;\n\tint ret = 0;\n\n\tif (!asp)\n\t\treturn -EINVAL;\n\n\tmtl = readl(ioaddr + XGMAC_MTL_SAFETY_INT_STATUS);\n\tdma = readl(ioaddr + XGMAC_DMA_SAFETY_INT_STATUS);\n\n\terr = (mtl & XGMAC_MCSIS) || (dma & XGMAC_MCSIS);\n\tcorr = false;\n\tif (err) {\n\t\tdwxgmac3_handle_mac_err(ndev, ioaddr, corr, stats);\n\t\tret |= !corr;\n\t}\n\n\terr = (mtl & (XGMAC_MEUIS | XGMAC_MECIS)) ||\n\t      (dma & (XGMAC_MSUIS | XGMAC_MSCIS));\n\tcorr = (mtl & XGMAC_MECIS) || (dma & XGMAC_MSCIS);\n\tif (err) {\n\t\tdwxgmac3_handle_mtl_err(ndev, ioaddr, corr, stats);\n\t\tret |= !corr;\n\t}\n\n\terr = dma & (XGMAC_DEUIS | XGMAC_DECIS);\n\tcorr = dma & XGMAC_DECIS;\n\tif (err) {\n\t\tdwxgmac3_handle_dma_err(ndev, ioaddr, corr, stats);\n\t\tret |= !corr;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct dwxgmac3_error {\n\tconst struct dwxgmac3_error_desc *desc;\n} dwxgmac3_all_errors[] = {\n\t{ dwxgmac3_mac_errors },\n\t{ dwxgmac3_mtl_errors },\n\t{ dwxgmac3_dma_errors },\n};\n\nstatic int dwxgmac3_safety_feat_dump(struct stmmac_safety_stats *stats,\n\t\t\t\t     int index, unsigned long *count,\n\t\t\t\t     const char **desc)\n{\n\tint module = index / 32, offset = index % 32;\n\tunsigned long *ptr = (unsigned long *)stats;\n\n\tif (module >= ARRAY_SIZE(dwxgmac3_all_errors))\n\t\treturn -EINVAL;\n\tif (!dwxgmac3_all_errors[module].desc[offset].valid)\n\t\treturn -EINVAL;\n\tif (count)\n\t\t*count = *(ptr + index);\n\tif (desc)\n\t\t*desc = dwxgmac3_all_errors[module].desc[offset].desc;\n\treturn 0;\n}\n\nstatic int dwxgmac3_rxp_disable(void __iomem *ioaddr)\n{\n\tu32 val = readl(ioaddr + XGMAC_MTL_OPMODE);\n\n\tval &= ~XGMAC_FRPE;\n\twritel(val, ioaddr + XGMAC_MTL_OPMODE);\n\n\treturn 0;\n}\n\nstatic void dwxgmac3_rxp_enable(void __iomem *ioaddr)\n{\n\tu32 val;\n\n\tval = readl(ioaddr + XGMAC_MTL_OPMODE);\n\tval |= XGMAC_FRPE;\n\twritel(val, ioaddr + XGMAC_MTL_OPMODE);\n}\n\nstatic int dwxgmac3_rxp_update_single_entry(void __iomem *ioaddr,\n\t\t\t\t\t    struct stmmac_tc_entry *entry,\n\t\t\t\t\t    int pos)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < (sizeof(entry->val) / sizeof(u32)); i++) {\n\t\tint real_pos = pos * (sizeof(entry->val) / sizeof(u32)) + i;\n\t\tu32 val;\n\n\t\t \n\t\tret = readl_poll_timeout(ioaddr + XGMAC_MTL_RXP_IACC_CTRL_ST,\n\t\t\t\t\t val, !(val & XGMAC_STARTBUSY), 1, 10000);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tval = *((u32 *)&entry->val + i);\n\t\twritel(val, ioaddr + XGMAC_MTL_RXP_IACC_DATA);\n\n\t\t \n\t\tval = real_pos & XGMAC_ADDR;\n\t\twritel(val, ioaddr + XGMAC_MTL_RXP_IACC_CTRL_ST);\n\n\t\t \n\t\tval |= XGMAC_WRRDN;\n\t\twritel(val, ioaddr + XGMAC_MTL_RXP_IACC_CTRL_ST);\n\n\t\t \n\t\tval |= XGMAC_STARTBUSY;\n\t\twritel(val, ioaddr + XGMAC_MTL_RXP_IACC_CTRL_ST);\n\n\t\t \n\t\tret = readl_poll_timeout(ioaddr + XGMAC_MTL_RXP_IACC_CTRL_ST,\n\t\t\t\t\t val, !(val & XGMAC_STARTBUSY), 1, 10000);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct stmmac_tc_entry *\ndwxgmac3_rxp_get_next_entry(struct stmmac_tc_entry *entries,\n\t\t\t    unsigned int count, u32 curr_prio)\n{\n\tstruct stmmac_tc_entry *entry;\n\tu32 min_prio = ~0x0;\n\tint i, min_prio_idx;\n\tbool found = false;\n\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tentry = &entries[i];\n\n\t\t \n\t\tif (!entry->in_use)\n\t\t\tcontinue;\n\t\t \n\t\tif (entry->in_hw)\n\t\t\tcontinue;\n\t\t \n\t\tif (entry->is_last)\n\t\t\tcontinue;\n\t\t \n\t\tif (entry->is_frag)\n\t\t\tcontinue;\n\t\t \n\t\tif (entry->prio < curr_prio)\n\t\t\tcontinue;\n\t\t \n\t\tif (entry->prio < min_prio) {\n\t\t\tmin_prio = entry->prio;\n\t\t\tmin_prio_idx = i;\n\t\t\tfound = true;\n\t\t}\n\t}\n\n\tif (found)\n\t\treturn &entries[min_prio_idx];\n\treturn NULL;\n}\n\nstatic int dwxgmac3_rxp_config(void __iomem *ioaddr,\n\t\t\t       struct stmmac_tc_entry *entries,\n\t\t\t       unsigned int count)\n{\n\tstruct stmmac_tc_entry *entry, *frag;\n\tint i, ret, nve = 0;\n\tu32 curr_prio = 0;\n\tu32 old_val, val;\n\n\t \n\told_val = readl(ioaddr + XGMAC_RX_CONFIG);\n\tval = old_val & ~XGMAC_CONFIG_RE;\n\twritel(val, ioaddr + XGMAC_RX_CONFIG);\n\n\t \n\tret = dwxgmac3_rxp_disable(ioaddr);\n\tif (ret)\n\t\tgoto re_enable;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tentry = &entries[i];\n\t\tentry->in_hw = false;\n\t}\n\n\t \n\twhile (1) {\n\t\tentry = dwxgmac3_rxp_get_next_entry(entries, count, curr_prio);\n\t\tif (!entry)\n\t\t\tbreak;\n\n\t\tcurr_prio = entry->prio;\n\t\tfrag = entry->frag_ptr;\n\n\t\t \n\t\tif (frag) {\n\t\t\tentry->val.af = 0;\n\t\t\tentry->val.rf = 0;\n\t\t\tentry->val.nc = 1;\n\t\t\tentry->val.ok_index = nve + 2;\n\t\t}\n\n\t\tret = dwxgmac3_rxp_update_single_entry(ioaddr, entry, nve);\n\t\tif (ret)\n\t\t\tgoto re_enable;\n\n\t\tentry->table_pos = nve++;\n\t\tentry->in_hw = true;\n\n\t\tif (frag && !frag->in_hw) {\n\t\t\tret = dwxgmac3_rxp_update_single_entry(ioaddr, frag, nve);\n\t\t\tif (ret)\n\t\t\t\tgoto re_enable;\n\t\t\tfrag->table_pos = nve++;\n\t\t\tfrag->in_hw = true;\n\t\t}\n\t}\n\n\tif (!nve)\n\t\tgoto re_enable;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tentry = &entries[i];\n\t\tif (!entry->is_last)\n\t\t\tcontinue;\n\n\t\tret = dwxgmac3_rxp_update_single_entry(ioaddr, entry, nve);\n\t\tif (ret)\n\t\t\tgoto re_enable;\n\n\t\tentry->table_pos = nve++;\n\t}\n\n\t \n\tval = (nve << 16) & XGMAC_NPE;\n\tval |= nve & XGMAC_NVE;\n\twritel(val, ioaddr + XGMAC_MTL_RXP_CONTROL_STATUS);\n\n\t \n\tdwxgmac3_rxp_enable(ioaddr);\n\nre_enable:\n\t \n\twritel(old_val, ioaddr + XGMAC_RX_CONFIG);\n\treturn ret;\n}\n\nstatic int dwxgmac2_get_mac_tx_timestamp(struct mac_device_info *hw, u64 *ts)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\tif (readl_poll_timeout_atomic(ioaddr + XGMAC_TIMESTAMP_STATUS,\n\t\t\t\t      value, value & XGMAC_TXTSC, 100, 10000))\n\t\treturn -EBUSY;\n\n\t*ts = readl(ioaddr + XGMAC_TXTIMESTAMP_NSEC) & XGMAC_TXTSSTSLO;\n\t*ts += readl(ioaddr + XGMAC_TXTIMESTAMP_SEC) * 1000000000ULL;\n\treturn 0;\n}\n\nstatic int dwxgmac2_flex_pps_config(void __iomem *ioaddr, int index,\n\t\t\t\t    struct stmmac_pps_cfg *cfg, bool enable,\n\t\t\t\t    u32 sub_second_inc, u32 systime_flags)\n{\n\tu32 tnsec = readl(ioaddr + XGMAC_PPSx_TARGET_TIME_NSEC(index));\n\tu32 val = readl(ioaddr + XGMAC_PPS_CONTROL);\n\tu64 period;\n\n\tif (!cfg->available)\n\t\treturn -EINVAL;\n\tif (tnsec & XGMAC_TRGTBUSY0)\n\t\treturn -EBUSY;\n\tif (!sub_second_inc || !systime_flags)\n\t\treturn -EINVAL;\n\n\tval &= ~XGMAC_PPSx_MASK(index);\n\n\tif (!enable) {\n\t\tval |= XGMAC_PPSCMDx(index, XGMAC_PPSCMD_STOP);\n\t\twritel(val, ioaddr + XGMAC_PPS_CONTROL);\n\t\treturn 0;\n\t}\n\n\tval |= XGMAC_PPSCMDx(index, XGMAC_PPSCMD_START);\n\tval |= XGMAC_TRGTMODSELx(index, XGMAC_PPSCMD_START);\n\n\t \n\tval |= XGMAC_PPSENx(index);\n\n\twritel(cfg->start.tv_sec, ioaddr + XGMAC_PPSx_TARGET_TIME_SEC(index));\n\n\tif (!(systime_flags & PTP_TCR_TSCTRLSSR))\n\t\tcfg->start.tv_nsec = (cfg->start.tv_nsec * 1000) / 465;\n\twritel(cfg->start.tv_nsec, ioaddr + XGMAC_PPSx_TARGET_TIME_NSEC(index));\n\n\tperiod = cfg->period.tv_sec * 1000000000;\n\tperiod += cfg->period.tv_nsec;\n\n\tdo_div(period, sub_second_inc);\n\n\tif (period <= 1)\n\t\treturn -EINVAL;\n\n\twritel(period - 1, ioaddr + XGMAC_PPSx_INTERVAL(index));\n\n\tperiod >>= 1;\n\tif (period <= 1)\n\t\treturn -EINVAL;\n\n\twritel(period - 1, ioaddr + XGMAC_PPSx_WIDTH(index));\n\n\t \n\twritel(val, ioaddr + XGMAC_PPS_CONTROL);\n\treturn 0;\n}\n\nstatic void dwxgmac2_sarc_configure(void __iomem *ioaddr, int val)\n{\n\tu32 value = readl(ioaddr + XGMAC_TX_CONFIG);\n\n\tvalue &= ~XGMAC_CONFIG_SARC;\n\tvalue |= val << XGMAC_CONFIG_SARC_SHIFT;\n\n\twritel(value, ioaddr + XGMAC_TX_CONFIG);\n}\n\nstatic void dwxgmac2_enable_vlan(struct mac_device_info *hw, u32 type)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\tvalue = readl(ioaddr + XGMAC_VLAN_INCL);\n\tvalue |= XGMAC_VLAN_VLTI;\n\tvalue |= XGMAC_VLAN_CSVL;  \n\tvalue &= ~XGMAC_VLAN_VLC;\n\tvalue |= (type << XGMAC_VLAN_VLC_SHIFT) & XGMAC_VLAN_VLC;\n\twritel(value, ioaddr + XGMAC_VLAN_INCL);\n}\n\nstatic int dwxgmac2_filter_wait(struct mac_device_info *hw)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\tif (readl_poll_timeout(ioaddr + XGMAC_L3L4_ADDR_CTRL, value,\n\t\t\t       !(value & XGMAC_XB), 100, 10000))\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\nstatic int dwxgmac2_filter_read(struct mac_device_info *hw, u32 filter_no,\n\t\t\t\tu8 reg, u32 *data)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\tint ret;\n\n\tret = dwxgmac2_filter_wait(hw);\n\tif (ret)\n\t\treturn ret;\n\n\tvalue = ((filter_no << XGMAC_IDDR_FNUM) | reg) << XGMAC_IDDR_SHIFT;\n\tvalue |= XGMAC_TT | XGMAC_XB;\n\twritel(value, ioaddr + XGMAC_L3L4_ADDR_CTRL);\n\n\tret = dwxgmac2_filter_wait(hw);\n\tif (ret)\n\t\treturn ret;\n\n\t*data = readl(ioaddr + XGMAC_L3L4_DATA);\n\treturn 0;\n}\n\nstatic int dwxgmac2_filter_write(struct mac_device_info *hw, u32 filter_no,\n\t\t\t\t u8 reg, u32 data)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\tint ret;\n\n\tret = dwxgmac2_filter_wait(hw);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(data, ioaddr + XGMAC_L3L4_DATA);\n\n\tvalue = ((filter_no << XGMAC_IDDR_FNUM) | reg) << XGMAC_IDDR_SHIFT;\n\tvalue |= XGMAC_XB;\n\twritel(value, ioaddr + XGMAC_L3L4_ADDR_CTRL);\n\n\treturn dwxgmac2_filter_wait(hw);\n}\n\nstatic int dwxgmac2_config_l3_filter(struct mac_device_info *hw, u32 filter_no,\n\t\t\t\t     bool en, bool ipv6, bool sa, bool inv,\n\t\t\t\t     u32 match)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\tint ret;\n\n\tvalue = readl(ioaddr + XGMAC_PACKET_FILTER);\n\tvalue |= XGMAC_FILTER_IPFE;\n\twritel(value, ioaddr + XGMAC_PACKET_FILTER);\n\n\tret = dwxgmac2_filter_read(hw, filter_no, XGMAC_L3L4_CTRL, &value);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (ipv6) {\n\t\tvalue |= XGMAC_L3PEN0;\n\t\tvalue &= ~(XGMAC_L3SAM0 | XGMAC_L3SAIM0);\n\t\tvalue &= ~(XGMAC_L3DAM0 | XGMAC_L3DAIM0);\n\t\tif (sa) {\n\t\t\tvalue |= XGMAC_L3SAM0;\n\t\t\tif (inv)\n\t\t\t\tvalue |= XGMAC_L3SAIM0;\n\t\t} else {\n\t\t\tvalue |= XGMAC_L3DAM0;\n\t\t\tif (inv)\n\t\t\t\tvalue |= XGMAC_L3DAIM0;\n\t\t}\n\t} else {\n\t\tvalue &= ~XGMAC_L3PEN0;\n\t\tif (sa) {\n\t\t\tvalue |= XGMAC_L3SAM0;\n\t\t\tif (inv)\n\t\t\t\tvalue |= XGMAC_L3SAIM0;\n\t\t} else {\n\t\t\tvalue |= XGMAC_L3DAM0;\n\t\t\tif (inv)\n\t\t\t\tvalue |= XGMAC_L3DAIM0;\n\t\t}\n\t}\n\n\tret = dwxgmac2_filter_write(hw, filter_no, XGMAC_L3L4_CTRL, value);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sa) {\n\t\tret = dwxgmac2_filter_write(hw, filter_no, XGMAC_L3_ADDR0, match);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = dwxgmac2_filter_write(hw, filter_no, XGMAC_L3_ADDR1, match);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!en)\n\t\treturn dwxgmac2_filter_write(hw, filter_no, XGMAC_L3L4_CTRL, 0);\n\n\treturn 0;\n}\n\nstatic int dwxgmac2_config_l4_filter(struct mac_device_info *hw, u32 filter_no,\n\t\t\t\t     bool en, bool udp, bool sa, bool inv,\n\t\t\t\t     u32 match)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\tint ret;\n\n\tvalue = readl(ioaddr + XGMAC_PACKET_FILTER);\n\tvalue |= XGMAC_FILTER_IPFE;\n\twritel(value, ioaddr + XGMAC_PACKET_FILTER);\n\n\tret = dwxgmac2_filter_read(hw, filter_no, XGMAC_L3L4_CTRL, &value);\n\tif (ret)\n\t\treturn ret;\n\n\tif (udp) {\n\t\tvalue |= XGMAC_L4PEN0;\n\t} else {\n\t\tvalue &= ~XGMAC_L4PEN0;\n\t}\n\n\tvalue &= ~(XGMAC_L4SPM0 | XGMAC_L4SPIM0);\n\tvalue &= ~(XGMAC_L4DPM0 | XGMAC_L4DPIM0);\n\tif (sa) {\n\t\tvalue |= XGMAC_L4SPM0;\n\t\tif (inv)\n\t\t\tvalue |= XGMAC_L4SPIM0;\n\t} else {\n\t\tvalue |= XGMAC_L4DPM0;\n\t\tif (inv)\n\t\t\tvalue |= XGMAC_L4DPIM0;\n\t}\n\n\tret = dwxgmac2_filter_write(hw, filter_no, XGMAC_L3L4_CTRL, value);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sa) {\n\t\tvalue = match & XGMAC_L4SP0;\n\n\t\tret = dwxgmac2_filter_write(hw, filter_no, XGMAC_L4_ADDR, value);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tvalue = (match << XGMAC_L4DP0_SHIFT) & XGMAC_L4DP0;\n\n\t\tret = dwxgmac2_filter_write(hw, filter_no, XGMAC_L4_ADDR, value);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!en)\n\t\treturn dwxgmac2_filter_write(hw, filter_no, XGMAC_L3L4_CTRL, 0);\n\n\treturn 0;\n}\n\nstatic void dwxgmac2_set_arp_offload(struct mac_device_info *hw, bool en,\n\t\t\t\t     u32 addr)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\twritel(addr, ioaddr + XGMAC_ARP_ADDR);\n\n\tvalue = readl(ioaddr + XGMAC_RX_CONFIG);\n\tif (en)\n\t\tvalue |= XGMAC_CONFIG_ARPEN;\n\telse\n\t\tvalue &= ~XGMAC_CONFIG_ARPEN;\n\twritel(value, ioaddr + XGMAC_RX_CONFIG);\n}\n\nstatic int dwxgmac3_est_write(void __iomem *ioaddr, u32 reg, u32 val, bool gcl)\n{\n\tu32 ctrl;\n\n\twritel(val, ioaddr + XGMAC_MTL_EST_GCL_DATA);\n\n\tctrl = (reg << XGMAC_ADDR_SHIFT);\n\tctrl |= gcl ? 0 : XGMAC_GCRR;\n\n\twritel(ctrl, ioaddr + XGMAC_MTL_EST_GCL_CONTROL);\n\n\tctrl |= XGMAC_SRWO;\n\twritel(ctrl, ioaddr + XGMAC_MTL_EST_GCL_CONTROL);\n\n\treturn readl_poll_timeout_atomic(ioaddr + XGMAC_MTL_EST_GCL_CONTROL,\n\t\t\t\t\t ctrl, !(ctrl & XGMAC_SRWO), 100, 5000);\n}\n\nstatic int dwxgmac3_est_configure(void __iomem *ioaddr, struct stmmac_est *cfg,\n\t\t\t\t  unsigned int ptp_rate)\n{\n\tint i, ret = 0x0;\n\tu32 ctrl;\n\n\tret |= dwxgmac3_est_write(ioaddr, XGMAC_BTR_LOW, cfg->btr[0], false);\n\tret |= dwxgmac3_est_write(ioaddr, XGMAC_BTR_HIGH, cfg->btr[1], false);\n\tret |= dwxgmac3_est_write(ioaddr, XGMAC_TER, cfg->ter, false);\n\tret |= dwxgmac3_est_write(ioaddr, XGMAC_LLR, cfg->gcl_size, false);\n\tret |= dwxgmac3_est_write(ioaddr, XGMAC_CTR_LOW, cfg->ctr[0], false);\n\tret |= dwxgmac3_est_write(ioaddr, XGMAC_CTR_HIGH, cfg->ctr[1], false);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < cfg->gcl_size; i++) {\n\t\tret = dwxgmac3_est_write(ioaddr, i, cfg->gcl[i], true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tctrl = readl(ioaddr + XGMAC_MTL_EST_CONTROL);\n\tctrl &= ~XGMAC_PTOV;\n\tctrl |= ((1000000000 / ptp_rate) * 9) << XGMAC_PTOV_SHIFT;\n\tif (cfg->enable)\n\t\tctrl |= XGMAC_EEST | XGMAC_SSWL;\n\telse\n\t\tctrl &= ~XGMAC_EEST;\n\n\twritel(ctrl, ioaddr + XGMAC_MTL_EST_CONTROL);\n\treturn 0;\n}\n\nstatic void dwxgmac3_fpe_configure(void __iomem *ioaddr, struct stmmac_fpe_cfg *cfg,\n\t\t\t\t   u32 num_txq,\n\t\t\t\t   u32 num_rxq, bool enable)\n{\n\tu32 value;\n\n\tif (!enable) {\n\t\tvalue = readl(ioaddr + XGMAC_FPE_CTRL_STS);\n\n\t\tvalue &= ~XGMAC_EFPE;\n\n\t\twritel(value, ioaddr + XGMAC_FPE_CTRL_STS);\n\t\treturn;\n\t}\n\n\tvalue = readl(ioaddr + XGMAC_RXQ_CTRL1);\n\tvalue &= ~XGMAC_RQ;\n\tvalue |= (num_rxq - 1) << XGMAC_RQ_SHIFT;\n\twritel(value, ioaddr + XGMAC_RXQ_CTRL1);\n\n\tvalue = readl(ioaddr + XGMAC_FPE_CTRL_STS);\n\tvalue |= XGMAC_EFPE;\n\twritel(value, ioaddr + XGMAC_FPE_CTRL_STS);\n}\n\nconst struct stmmac_ops dwxgmac210_ops = {\n\t.core_init = dwxgmac2_core_init,\n\t.phylink_get_caps = xgmac_phylink_get_caps,\n\t.set_mac = dwxgmac2_set_mac,\n\t.rx_ipc = dwxgmac2_rx_ipc,\n\t.rx_queue_enable = dwxgmac2_rx_queue_enable,\n\t.rx_queue_prio = dwxgmac2_rx_queue_prio,\n\t.tx_queue_prio = dwxgmac2_tx_queue_prio,\n\t.rx_queue_routing = dwxgmac2_rx_queue_routing,\n\t.prog_mtl_rx_algorithms = dwxgmac2_prog_mtl_rx_algorithms,\n\t.prog_mtl_tx_algorithms = dwxgmac2_prog_mtl_tx_algorithms,\n\t.set_mtl_tx_queue_weight = dwxgmac2_set_mtl_tx_queue_weight,\n\t.map_mtl_to_dma = dwxgmac2_map_mtl_to_dma,\n\t.config_cbs = dwxgmac2_config_cbs,\n\t.dump_regs = dwxgmac2_dump_regs,\n\t.host_irq_status = dwxgmac2_host_irq_status,\n\t.host_mtl_irq_status = dwxgmac2_host_mtl_irq_status,\n\t.flow_ctrl = dwxgmac2_flow_ctrl,\n\t.pmt = dwxgmac2_pmt,\n\t.set_umac_addr = dwxgmac2_set_umac_addr,\n\t.get_umac_addr = dwxgmac2_get_umac_addr,\n\t.set_eee_mode = dwxgmac2_set_eee_mode,\n\t.reset_eee_mode = dwxgmac2_reset_eee_mode,\n\t.set_eee_timer = dwxgmac2_set_eee_timer,\n\t.set_eee_pls = dwxgmac2_set_eee_pls,\n\t.pcs_ctrl_ane = NULL,\n\t.pcs_rane = NULL,\n\t.pcs_get_adv_lp = NULL,\n\t.debug = NULL,\n\t.set_filter = dwxgmac2_set_filter,\n\t.safety_feat_config = dwxgmac3_safety_feat_config,\n\t.safety_feat_irq_status = dwxgmac3_safety_feat_irq_status,\n\t.safety_feat_dump = dwxgmac3_safety_feat_dump,\n\t.set_mac_loopback = dwxgmac2_set_mac_loopback,\n\t.rss_configure = dwxgmac2_rss_configure,\n\t.update_vlan_hash = dwxgmac2_update_vlan_hash,\n\t.rxp_config = dwxgmac3_rxp_config,\n\t.get_mac_tx_timestamp = dwxgmac2_get_mac_tx_timestamp,\n\t.flex_pps_config = dwxgmac2_flex_pps_config,\n\t.sarc_configure = dwxgmac2_sarc_configure,\n\t.enable_vlan = dwxgmac2_enable_vlan,\n\t.config_l3_filter = dwxgmac2_config_l3_filter,\n\t.config_l4_filter = dwxgmac2_config_l4_filter,\n\t.set_arp_offload = dwxgmac2_set_arp_offload,\n\t.est_configure = dwxgmac3_est_configure,\n\t.fpe_configure = dwxgmac3_fpe_configure,\n};\n\nstatic void dwxlgmac2_rx_queue_enable(struct mac_device_info *hw, u8 mode,\n\t\t\t\t      u32 queue)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\tvalue = readl(ioaddr + XLGMAC_RXQ_ENABLE_CTRL0) & ~XGMAC_RXQEN(queue);\n\tif (mode == MTL_QUEUE_AVB)\n\t\tvalue |= 0x1 << XGMAC_RXQEN_SHIFT(queue);\n\telse if (mode == MTL_QUEUE_DCB)\n\t\tvalue |= 0x2 << XGMAC_RXQEN_SHIFT(queue);\n\twritel(value, ioaddr + XLGMAC_RXQ_ENABLE_CTRL0);\n}\n\nconst struct stmmac_ops dwxlgmac2_ops = {\n\t.core_init = dwxgmac2_core_init,\n\t.phylink_get_caps = xgmac_phylink_get_caps,\n\t.set_mac = dwxgmac2_set_mac,\n\t.rx_ipc = dwxgmac2_rx_ipc,\n\t.rx_queue_enable = dwxlgmac2_rx_queue_enable,\n\t.rx_queue_prio = dwxgmac2_rx_queue_prio,\n\t.tx_queue_prio = dwxgmac2_tx_queue_prio,\n\t.rx_queue_routing = dwxgmac2_rx_queue_routing,\n\t.prog_mtl_rx_algorithms = dwxgmac2_prog_mtl_rx_algorithms,\n\t.prog_mtl_tx_algorithms = dwxgmac2_prog_mtl_tx_algorithms,\n\t.set_mtl_tx_queue_weight = dwxgmac2_set_mtl_tx_queue_weight,\n\t.map_mtl_to_dma = dwxgmac2_map_mtl_to_dma,\n\t.config_cbs = dwxgmac2_config_cbs,\n\t.dump_regs = dwxgmac2_dump_regs,\n\t.host_irq_status = dwxgmac2_host_irq_status,\n\t.host_mtl_irq_status = dwxgmac2_host_mtl_irq_status,\n\t.flow_ctrl = dwxgmac2_flow_ctrl,\n\t.pmt = dwxgmac2_pmt,\n\t.set_umac_addr = dwxgmac2_set_umac_addr,\n\t.get_umac_addr = dwxgmac2_get_umac_addr,\n\t.set_eee_mode = dwxgmac2_set_eee_mode,\n\t.reset_eee_mode = dwxgmac2_reset_eee_mode,\n\t.set_eee_timer = dwxgmac2_set_eee_timer,\n\t.set_eee_pls = dwxgmac2_set_eee_pls,\n\t.pcs_ctrl_ane = NULL,\n\t.pcs_rane = NULL,\n\t.pcs_get_adv_lp = NULL,\n\t.debug = NULL,\n\t.set_filter = dwxgmac2_set_filter,\n\t.safety_feat_config = dwxgmac3_safety_feat_config,\n\t.safety_feat_irq_status = dwxgmac3_safety_feat_irq_status,\n\t.safety_feat_dump = dwxgmac3_safety_feat_dump,\n\t.set_mac_loopback = dwxgmac2_set_mac_loopback,\n\t.rss_configure = dwxgmac2_rss_configure,\n\t.update_vlan_hash = dwxgmac2_update_vlan_hash,\n\t.rxp_config = dwxgmac3_rxp_config,\n\t.get_mac_tx_timestamp = dwxgmac2_get_mac_tx_timestamp,\n\t.flex_pps_config = dwxgmac2_flex_pps_config,\n\t.sarc_configure = dwxgmac2_sarc_configure,\n\t.enable_vlan = dwxgmac2_enable_vlan,\n\t.config_l3_filter = dwxgmac2_config_l3_filter,\n\t.config_l4_filter = dwxgmac2_config_l4_filter,\n\t.set_arp_offload = dwxgmac2_set_arp_offload,\n\t.est_configure = dwxgmac3_est_configure,\n\t.fpe_configure = dwxgmac3_fpe_configure,\n};\n\nint dwxgmac2_setup(struct stmmac_priv *priv)\n{\n\tstruct mac_device_info *mac = priv->hw;\n\n\tdev_info(priv->device, \"\\tXGMAC2\\n\");\n\n\tpriv->dev->priv_flags |= IFF_UNICAST_FLT;\n\tmac->pcsr = priv->ioaddr;\n\tmac->multicast_filter_bins = priv->plat->multicast_filter_bins;\n\tmac->unicast_filter_entries = priv->plat->unicast_filter_entries;\n\tmac->mcast_bits_log2 = 0;\n\n\tif (mac->multicast_filter_bins)\n\t\tmac->mcast_bits_log2 = ilog2(mac->multicast_filter_bins);\n\n\tmac->link.duplex = 0;\n\tmac->link.speed10 = XGMAC_CONFIG_SS_10_MII;\n\tmac->link.speed100 = XGMAC_CONFIG_SS_100_MII;\n\tmac->link.speed1000 = XGMAC_CONFIG_SS_1000_GMII;\n\tmac->link.speed2500 = XGMAC_CONFIG_SS_2500_GMII;\n\tmac->link.xgmii.speed2500 = XGMAC_CONFIG_SS_2500;\n\tmac->link.xgmii.speed5000 = XGMAC_CONFIG_SS_5000;\n\tmac->link.xgmii.speed10000 = XGMAC_CONFIG_SS_10000;\n\tmac->link.speed_mask = XGMAC_CONFIG_SS_MASK;\n\n\tmac->mii.addr = XGMAC_MDIO_ADDR;\n\tmac->mii.data = XGMAC_MDIO_DATA;\n\tmac->mii.addr_shift = 16;\n\tmac->mii.addr_mask = GENMASK(20, 16);\n\tmac->mii.reg_shift = 0;\n\tmac->mii.reg_mask = GENMASK(15, 0);\n\tmac->mii.clk_csr_shift = 19;\n\tmac->mii.clk_csr_mask = GENMASK(21, 19);\n\n\treturn 0;\n}\n\nint dwxlgmac2_setup(struct stmmac_priv *priv)\n{\n\tstruct mac_device_info *mac = priv->hw;\n\n\tdev_info(priv->device, \"\\tXLGMAC\\n\");\n\n\tpriv->dev->priv_flags |= IFF_UNICAST_FLT;\n\tmac->pcsr = priv->ioaddr;\n\tmac->multicast_filter_bins = priv->plat->multicast_filter_bins;\n\tmac->unicast_filter_entries = priv->plat->unicast_filter_entries;\n\tmac->mcast_bits_log2 = 0;\n\n\tif (mac->multicast_filter_bins)\n\t\tmac->mcast_bits_log2 = ilog2(mac->multicast_filter_bins);\n\n\tmac->link.duplex = 0;\n\tmac->link.speed1000 = XLGMAC_CONFIG_SS_1000;\n\tmac->link.speed2500 = XLGMAC_CONFIG_SS_2500;\n\tmac->link.xgmii.speed10000 = XLGMAC_CONFIG_SS_10G;\n\tmac->link.xlgmii.speed25000 = XLGMAC_CONFIG_SS_25G;\n\tmac->link.xlgmii.speed40000 = XLGMAC_CONFIG_SS_40G;\n\tmac->link.xlgmii.speed50000 = XLGMAC_CONFIG_SS_50G;\n\tmac->link.xlgmii.speed100000 = XLGMAC_CONFIG_SS_100G;\n\tmac->link.speed_mask = XLGMAC_CONFIG_SS;\n\n\tmac->mii.addr = XGMAC_MDIO_ADDR;\n\tmac->mii.data = XGMAC_MDIO_DATA;\n\tmac->mii.addr_shift = 16;\n\tmac->mii.addr_mask = GENMASK(20, 16);\n\tmac->mii.reg_shift = 0;\n\tmac->mii.reg_mask = GENMASK(15, 0);\n\tmac->mii.clk_csr_shift = 19;\n\tmac->mii.clk_csr_mask = GENMASK(21, 19);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}