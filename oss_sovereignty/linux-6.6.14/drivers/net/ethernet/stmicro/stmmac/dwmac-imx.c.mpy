{
  "module_name": "dwmac-imx.c",
  "hash_id": "7387f9cebf3f1123daec5f8fd9edf92115dcd5c66854fc4194069ff904151af6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwmac-imx.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/gpio/consumer.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/stmmac.h>\n\n#include \"stmmac_platform.h\"\n\n#define GPR_ENET_QOS_INTF_MODE_MASK\tGENMASK(21, 16)\n#define GPR_ENET_QOS_INTF_SEL_MII\t(0x0 << 16)\n#define GPR_ENET_QOS_INTF_SEL_RMII\t(0x4 << 16)\n#define GPR_ENET_QOS_INTF_SEL_RGMII\t(0x1 << 16)\n#define GPR_ENET_QOS_CLK_GEN_EN\t\t(0x1 << 19)\n#define GPR_ENET_QOS_CLK_TX_CLK_SEL\t(0x1 << 20)\n#define GPR_ENET_QOS_RGMII_EN\t\t(0x1 << 21)\n\n#define MX93_GPR_ENET_QOS_INTF_MODE_MASK\tGENMASK(3, 0)\n#define MX93_GPR_ENET_QOS_INTF_MASK\t\tGENMASK(3, 1)\n#define MX93_GPR_ENET_QOS_INTF_SEL_MII\t\t(0x0 << 1)\n#define MX93_GPR_ENET_QOS_INTF_SEL_RMII\t\t(0x4 << 1)\n#define MX93_GPR_ENET_QOS_INTF_SEL_RGMII\t(0x1 << 1)\n#define MX93_GPR_ENET_QOS_CLK_GEN_EN\t\t(0x1 << 0)\n\n#define DMA_BUS_MODE\t\t\t0x00001000\n#define DMA_BUS_MODE_SFT_RESET\t\t(0x1 << 0)\n#define RMII_RESET_SPEED\t\t(0x3 << 14)\n#define CTRL_SPEED_MASK\t\t\tGENMASK(15, 14)\n\nstruct imx_dwmac_ops {\n\tu32 addr_width;\n\tu32 flags;\n\tbool mac_rgmii_txclk_auto_adj;\n\n\tint (*fix_soc_reset)(void *priv, void __iomem *ioaddr);\n\tint (*set_intf_mode)(struct plat_stmmacenet_data *plat_dat);\n\tvoid (*fix_mac_speed)(void *priv, unsigned int speed, unsigned int mode);\n};\n\nstruct imx_priv_data {\n\tstruct device *dev;\n\tstruct clk *clk_tx;\n\tstruct clk *clk_mem;\n\tstruct regmap *intf_regmap;\n\tu32 intf_reg_off;\n\tbool rmii_refclk_ext;\n\tvoid __iomem *base_addr;\n\n\tconst struct imx_dwmac_ops *ops;\n\tstruct plat_stmmacenet_data *plat_dat;\n};\n\nstatic int imx8mp_set_intf_mode(struct plat_stmmacenet_data *plat_dat)\n{\n\tstruct imx_priv_data *dwmac = plat_dat->bsp_priv;\n\tint val;\n\n\tswitch (plat_dat->mac_interface) {\n\tcase PHY_INTERFACE_MODE_MII:\n\t\tval = GPR_ENET_QOS_INTF_SEL_MII;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tval = GPR_ENET_QOS_INTF_SEL_RMII;\n\t\tval |= (dwmac->rmii_refclk_ext ? 0 : GPR_ENET_QOS_CLK_TX_CLK_SEL);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tval = GPR_ENET_QOS_INTF_SEL_RGMII |\n\t\t      GPR_ENET_QOS_RGMII_EN;\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"imx dwmac doesn't support %d interface\\n\",\n\t\t\t plat_dat->mac_interface);\n\t\treturn -EINVAL;\n\t}\n\n\tval |= GPR_ENET_QOS_CLK_GEN_EN;\n\treturn regmap_update_bits(dwmac->intf_regmap, dwmac->intf_reg_off,\n\t\t\t\t  GPR_ENET_QOS_INTF_MODE_MASK, val);\n};\n\nstatic int\nimx8dxl_set_intf_mode(struct plat_stmmacenet_data *plat_dat)\n{\n\tint ret = 0;\n\n\t \n\treturn ret;\n}\n\nstatic int imx93_set_intf_mode(struct plat_stmmacenet_data *plat_dat)\n{\n\tstruct imx_priv_data *dwmac = plat_dat->bsp_priv;\n\tint val;\n\n\tswitch (plat_dat->mac_interface) {\n\tcase PHY_INTERFACE_MODE_MII:\n\t\tval = MX93_GPR_ENET_QOS_INTF_SEL_MII;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tval = MX93_GPR_ENET_QOS_INTF_SEL_RMII;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tval = MX93_GPR_ENET_QOS_INTF_SEL_RGMII;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dwmac->dev, \"imx dwmac doesn't support %d interface\\n\",\n\t\t\t plat_dat->mac_interface);\n\t\treturn -EINVAL;\n\t}\n\n\tval |= MX93_GPR_ENET_QOS_CLK_GEN_EN;\n\treturn regmap_update_bits(dwmac->intf_regmap, dwmac->intf_reg_off,\n\t\t\t\t  MX93_GPR_ENET_QOS_INTF_MODE_MASK, val);\n};\n\nstatic int imx_dwmac_clks_config(void *priv, bool enabled)\n{\n\tstruct imx_priv_data *dwmac = priv;\n\tint ret = 0;\n\n\tif (enabled) {\n\t\tret = clk_prepare_enable(dwmac->clk_mem);\n\t\tif (ret) {\n\t\t\tdev_err(dwmac->dev, \"mem clock enable failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = clk_prepare_enable(dwmac->clk_tx);\n\t\tif (ret) {\n\t\t\tdev_err(dwmac->dev, \"tx clock enable failed\\n\");\n\t\t\tclk_disable_unprepare(dwmac->clk_mem);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tclk_disable_unprepare(dwmac->clk_tx);\n\t\tclk_disable_unprepare(dwmac->clk_mem);\n\t}\n\n\treturn ret;\n}\n\nstatic int imx_dwmac_init(struct platform_device *pdev, void *priv)\n{\n\tstruct plat_stmmacenet_data *plat_dat;\n\tstruct imx_priv_data *dwmac = priv;\n\tint ret;\n\n\tplat_dat = dwmac->plat_dat;\n\n\tif (dwmac->ops->set_intf_mode) {\n\t\tret = dwmac->ops->set_intf_mode(plat_dat);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void imx_dwmac_exit(struct platform_device *pdev, void *priv)\n{\n\t \n}\n\nstatic void imx_dwmac_fix_speed(void *priv, unsigned int speed, unsigned int mode)\n{\n\tstruct plat_stmmacenet_data *plat_dat;\n\tstruct imx_priv_data *dwmac = priv;\n\tunsigned long rate;\n\tint err;\n\n\tplat_dat = dwmac->plat_dat;\n\n\tif (dwmac->ops->mac_rgmii_txclk_auto_adj ||\n\t    (plat_dat->mac_interface == PHY_INTERFACE_MODE_RMII) ||\n\t    (plat_dat->mac_interface == PHY_INTERFACE_MODE_MII))\n\t\treturn;\n\n\tswitch (speed) {\n\tcase SPEED_1000:\n\t\trate = 125000000;\n\t\tbreak;\n\tcase SPEED_100:\n\t\trate = 25000000;\n\t\tbreak;\n\tcase SPEED_10:\n\t\trate = 2500000;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dwmac->dev, \"invalid speed %u\\n\", speed);\n\t\treturn;\n\t}\n\n\terr = clk_set_rate(dwmac->clk_tx, rate);\n\tif (err < 0)\n\t\tdev_err(dwmac->dev, \"failed to set tx rate %lu\\n\", rate);\n}\n\nstatic void imx93_dwmac_fix_speed(void *priv, unsigned int speed, unsigned int mode)\n{\n\tstruct imx_priv_data *dwmac = priv;\n\tunsigned int iface;\n\tint ctrl, old_ctrl;\n\n\timx_dwmac_fix_speed(priv, speed, mode);\n\n\tif (!dwmac || mode != MLO_AN_FIXED)\n\t\treturn;\n\n\tif (regmap_read(dwmac->intf_regmap, dwmac->intf_reg_off, &iface))\n\t\treturn;\n\n\tiface &= MX93_GPR_ENET_QOS_INTF_MASK;\n\tif (iface != MX93_GPR_ENET_QOS_INTF_SEL_RGMII)\n\t\treturn;\n\n\told_ctrl = readl(dwmac->base_addr + MAC_CTRL_REG);\n\tctrl = old_ctrl & ~CTRL_SPEED_MASK;\n\tregmap_update_bits(dwmac->intf_regmap, dwmac->intf_reg_off,\n\t\t\t   MX93_GPR_ENET_QOS_INTF_MODE_MASK, 0);\n\twritel(ctrl, dwmac->base_addr + MAC_CTRL_REG);\n\n\t  \n\treadl(dwmac->base_addr + MAC_CTRL_REG);\n\n\tusleep_range(10, 20);\n\tiface |= MX93_GPR_ENET_QOS_CLK_GEN_EN;\n\tregmap_update_bits(dwmac->intf_regmap, dwmac->intf_reg_off,\n\t\t\t   MX93_GPR_ENET_QOS_INTF_MODE_MASK, iface);\n\n\twritel(old_ctrl, dwmac->base_addr + MAC_CTRL_REG);\n}\n\nstatic int imx_dwmac_mx93_reset(void *priv, void __iomem *ioaddr)\n{\n\tstruct plat_stmmacenet_data *plat_dat = priv;\n\tu32 value = readl(ioaddr + DMA_BUS_MODE);\n\n\t \n\tvalue |= DMA_BUS_MODE_SFT_RESET;\n\twritel(value, ioaddr + DMA_BUS_MODE);\n\n\tif (plat_dat->mac_interface == PHY_INTERFACE_MODE_RMII) {\n\t\tusleep_range(100, 200);\n\t\twritel(RMII_RESET_SPEED, ioaddr + MAC_CTRL_REG);\n\t}\n\n\treturn readl_poll_timeout(ioaddr + DMA_BUS_MODE, value,\n\t\t\t\t !(value & DMA_BUS_MODE_SFT_RESET),\n\t\t\t\t 10000, 1000000);\n}\n\nstatic int\nimx_dwmac_parse_dt(struct imx_priv_data *dwmac, struct device *dev)\n{\n\tstruct device_node *np = dev->of_node;\n\tint err = 0;\n\n\tdwmac->rmii_refclk_ext = of_property_read_bool(np, \"snps,rmii_refclk_ext\");\n\n\tdwmac->clk_tx = devm_clk_get(dev, \"tx\");\n\tif (IS_ERR(dwmac->clk_tx)) {\n\t\tdev_err(dev, \"failed to get tx clock\\n\");\n\t\treturn PTR_ERR(dwmac->clk_tx);\n\t}\n\n\tdwmac->clk_mem = NULL;\n\n\tif (of_machine_is_compatible(\"fsl,imx8dxl\") ||\n\t    of_machine_is_compatible(\"fsl,imx93\")) {\n\t\tdwmac->clk_mem = devm_clk_get(dev, \"mem\");\n\t\tif (IS_ERR(dwmac->clk_mem)) {\n\t\t\tdev_err(dev, \"failed to get mem clock\\n\");\n\t\t\treturn PTR_ERR(dwmac->clk_mem);\n\t\t}\n\t}\n\n\tif (of_machine_is_compatible(\"fsl,imx8mp\") ||\n\t    of_machine_is_compatible(\"fsl,imx93\")) {\n\t\t \n\t\tdwmac->intf_regmap = syscon_regmap_lookup_by_phandle(np, \"intf_mode\");\n\t\tif (IS_ERR(dwmac->intf_regmap))\n\t\t\treturn PTR_ERR(dwmac->intf_regmap);\n\n\t\terr = of_property_read_u32_index(np, \"intf_mode\", 1, &dwmac->intf_reg_off);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Can't get intf mode reg offset (%d)\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int imx_dwmac_probe(struct platform_device *pdev)\n{\n\tstruct plat_stmmacenet_data *plat_dat;\n\tstruct stmmac_resources stmmac_res;\n\tstruct imx_priv_data *dwmac;\n\tconst struct imx_dwmac_ops *data;\n\tint ret;\n\n\tret = stmmac_get_platform_resources(pdev, &stmmac_res);\n\tif (ret)\n\t\treturn ret;\n\n\tdwmac = devm_kzalloc(&pdev->dev, sizeof(*dwmac), GFP_KERNEL);\n\tif (!dwmac)\n\t\treturn -ENOMEM;\n\n\tplat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);\n\tif (IS_ERR(plat_dat))\n\t\treturn PTR_ERR(plat_dat);\n\n\tdata = of_device_get_match_data(&pdev->dev);\n\tif (!data) {\n\t\tdev_err(&pdev->dev, \"failed to get match data\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_match_data;\n\t}\n\n\tdwmac->ops = data;\n\tdwmac->dev = &pdev->dev;\n\n\tret = imx_dwmac_parse_dt(dwmac, &pdev->dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to parse OF data\\n\");\n\t\tgoto err_parse_dt;\n\t}\n\n\tif (data->flags & STMMAC_FLAG_HWTSTAMP_CORRECT_LATENCY)\n\t\tplat_dat->flags |= STMMAC_FLAG_HWTSTAMP_CORRECT_LATENCY;\n\n\tplat_dat->host_dma_width = dwmac->ops->addr_width;\n\tplat_dat->init = imx_dwmac_init;\n\tplat_dat->exit = imx_dwmac_exit;\n\tplat_dat->clks_config = imx_dwmac_clks_config;\n\tplat_dat->fix_mac_speed = imx_dwmac_fix_speed;\n\tplat_dat->bsp_priv = dwmac;\n\tdwmac->plat_dat = plat_dat;\n\tdwmac->base_addr = stmmac_res.addr;\n\n\tret = imx_dwmac_clks_config(dwmac, true);\n\tif (ret)\n\t\tgoto err_clks_config;\n\n\tret = imx_dwmac_init(pdev, dwmac);\n\tif (ret)\n\t\tgoto err_dwmac_init;\n\n\tif (dwmac->ops->fix_mac_speed)\n\t\tplat_dat->fix_mac_speed = dwmac->ops->fix_mac_speed;\n\tdwmac->plat_dat->fix_soc_reset = dwmac->ops->fix_soc_reset;\n\n\tret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);\n\tif (ret)\n\t\tgoto err_drv_probe;\n\n\treturn 0;\n\nerr_drv_probe:\n\timx_dwmac_exit(pdev, plat_dat->bsp_priv);\nerr_dwmac_init:\n\timx_dwmac_clks_config(dwmac, false);\nerr_clks_config:\nerr_parse_dt:\nerr_match_data:\n\tstmmac_remove_config_dt(pdev, plat_dat);\n\treturn ret;\n}\n\nstatic struct imx_dwmac_ops imx8mp_dwmac_data = {\n\t.addr_width = 34,\n\t.mac_rgmii_txclk_auto_adj = false,\n\t.set_intf_mode = imx8mp_set_intf_mode,\n\t.flags = STMMAC_FLAG_HWTSTAMP_CORRECT_LATENCY,\n};\n\nstatic struct imx_dwmac_ops imx8dxl_dwmac_data = {\n\t.addr_width = 32,\n\t.mac_rgmii_txclk_auto_adj = true,\n\t.set_intf_mode = imx8dxl_set_intf_mode,\n};\n\nstatic struct imx_dwmac_ops imx93_dwmac_data = {\n\t.addr_width = 32,\n\t.mac_rgmii_txclk_auto_adj = true,\n\t.set_intf_mode = imx93_set_intf_mode,\n\t.fix_soc_reset = imx_dwmac_mx93_reset,\n\t.fix_mac_speed = imx93_dwmac_fix_speed,\n};\n\nstatic const struct of_device_id imx_dwmac_match[] = {\n\t{ .compatible = \"nxp,imx8mp-dwmac-eqos\", .data = &imx8mp_dwmac_data },\n\t{ .compatible = \"nxp,imx8dxl-dwmac-eqos\", .data = &imx8dxl_dwmac_data },\n\t{ .compatible = \"nxp,imx93-dwmac-eqos\", .data = &imx93_dwmac_data },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, imx_dwmac_match);\n\nstatic struct platform_driver imx_dwmac_driver = {\n\t.probe  = imx_dwmac_probe,\n\t.remove_new = stmmac_pltfr_remove,\n\t.driver = {\n\t\t.name           = \"imx-dwmac\",\n\t\t.pm\t\t= &stmmac_pltfr_pm_ops,\n\t\t.of_match_table = imx_dwmac_match,\n\t},\n};\nmodule_platform_driver(imx_dwmac_driver);\n\nMODULE_AUTHOR(\"NXP\");\nMODULE_DESCRIPTION(\"NXP imx8 DWMAC Specific Glue layer\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}