{
  "module_name": "dwmac-sti.c",
  "hash_id": "6558d6c35ec43b23b192de4d2f07af66400027bada01b3f7b61abeaaf11298a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwmac-sti.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/stmmac.h>\n#include <linux/phy.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n\n#include \"stmmac_platform.h\"\n\n#define DWMAC_125MHZ\t125000000\n#define DWMAC_50MHZ\t50000000\n#define DWMAC_25MHZ\t25000000\n#define DWMAC_2_5MHZ\t2500000\n\n#define IS_PHY_IF_MODE_RGMII(iface)\t(iface == PHY_INTERFACE_MODE_RGMII || \\\n\t\t\tiface == PHY_INTERFACE_MODE_RGMII_ID || \\\n\t\t\tiface == PHY_INTERFACE_MODE_RGMII_RXID || \\\n\t\t\tiface == PHY_INTERFACE_MODE_RGMII_TXID)\n\n#define IS_PHY_IF_MODE_GBIT(iface)\t(IS_PHY_IF_MODE_RGMII(iface) || \\\n\t\t\t\t\t iface == PHY_INTERFACE_MODE_GMII)\n\n \n\n#define STIH4XX_RETIME_SRC_MASK\t\t\tGENMASK(8, 6)\n#define STIH4XX_ETH_SEL_TX_RETIME_CLK\t\tBIT(8)\n#define STIH4XX_ETH_SEL_INTERNAL_NOTEXT_PHYCLK\tBIT(7)\n#define STIH4XX_ETH_SEL_TXCLK_NOT_CLK125\tBIT(6)\n\n#define ENMII_MASK\tGENMASK(5, 5)\n#define ENMII\t\tBIT(5)\n#define EN_MASK\t\tGENMASK(1, 1)\n#define EN\t\tBIT(1)\n\n \n#define MII_PHY_SEL_MASK\tGENMASK(4, 2)\n#define ETH_PHY_SEL_RMII\tBIT(4)\n#define ETH_PHY_SEL_SGMII\tBIT(3)\n#define ETH_PHY_SEL_RGMII\tBIT(2)\n#define ETH_PHY_SEL_GMII\t0x0\n#define ETH_PHY_SEL_MII\t\t0x0\n\nstruct sti_dwmac {\n\tphy_interface_t interface;\t \n\tbool ext_phyclk;\t \n\tu32 tx_retime_src;\t \n\tstruct clk *clk;\t \n\tu32 ctrl_reg;\t\t \n\tint clk_sel_reg;\t \n\tstruct regmap *regmap;\n\tbool gmac_en;\n\tu32 speed;\n\tvoid (*fix_retime_src)(void *priv, unsigned int speed, unsigned int mode);\n};\n\nstruct sti_dwmac_of_data {\n\tvoid (*fix_retime_src)(void *priv, unsigned int speed, unsigned int mode);\n};\n\nstatic u32 phy_intf_sels[] = {\n\t[PHY_INTERFACE_MODE_MII] = ETH_PHY_SEL_MII,\n\t[PHY_INTERFACE_MODE_GMII] = ETH_PHY_SEL_GMII,\n\t[PHY_INTERFACE_MODE_RGMII] = ETH_PHY_SEL_RGMII,\n\t[PHY_INTERFACE_MODE_RGMII_ID] = ETH_PHY_SEL_RGMII,\n\t[PHY_INTERFACE_MODE_SGMII] = ETH_PHY_SEL_SGMII,\n\t[PHY_INTERFACE_MODE_RMII] = ETH_PHY_SEL_RMII,\n};\n\nenum {\n\tTX_RETIME_SRC_NA = 0,\n\tTX_RETIME_SRC_TXCLK = 1,\n\tTX_RETIME_SRC_CLK_125,\n\tTX_RETIME_SRC_PHYCLK,\n\tTX_RETIME_SRC_CLKGEN,\n};\n\nstatic u32 stih4xx_tx_retime_val[] = {\n\t[TX_RETIME_SRC_TXCLK] = STIH4XX_ETH_SEL_TXCLK_NOT_CLK125,\n\t[TX_RETIME_SRC_CLK_125] = 0x0,\n\t[TX_RETIME_SRC_PHYCLK] = STIH4XX_ETH_SEL_TX_RETIME_CLK,\n\t[TX_RETIME_SRC_CLKGEN] = STIH4XX_ETH_SEL_TX_RETIME_CLK\n\t\t\t\t | STIH4XX_ETH_SEL_INTERNAL_NOTEXT_PHYCLK,\n};\n\nstatic void stih4xx_fix_retime_src(void *priv, u32 spd, unsigned int mode)\n{\n\tstruct sti_dwmac *dwmac = priv;\n\tu32 src = dwmac->tx_retime_src;\n\tu32 reg = dwmac->ctrl_reg;\n\tu32 freq = 0;\n\n\tif (dwmac->interface == PHY_INTERFACE_MODE_MII) {\n\t\tsrc = TX_RETIME_SRC_TXCLK;\n\t} else if (dwmac->interface == PHY_INTERFACE_MODE_RMII) {\n\t\tif (dwmac->ext_phyclk) {\n\t\t\tsrc = TX_RETIME_SRC_PHYCLK;\n\t\t} else {\n\t\t\tsrc = TX_RETIME_SRC_CLKGEN;\n\t\t\tfreq = DWMAC_50MHZ;\n\t\t}\n\t} else if (IS_PHY_IF_MODE_RGMII(dwmac->interface)) {\n\t\t \n\t\tif (spd == SPEED_1000) {\n\t\t\tfreq = DWMAC_125MHZ;\n\t\t} else {\n\t\t\t \n\t\t\tsrc = TX_RETIME_SRC_CLKGEN;\n\t\t\tif (spd == SPEED_100)\n\t\t\t\tfreq = DWMAC_25MHZ;\n\t\t\telse if (spd == SPEED_10)\n\t\t\t\tfreq = DWMAC_2_5MHZ;\n\t\t}\n\t}\n\n\tif (src == TX_RETIME_SRC_CLKGEN && freq)\n\t\tclk_set_rate(dwmac->clk, freq);\n\n\tregmap_update_bits(dwmac->regmap, reg, STIH4XX_RETIME_SRC_MASK,\n\t\t\t   stih4xx_tx_retime_val[src]);\n}\n\nstatic int sti_dwmac_set_mode(struct sti_dwmac *dwmac)\n{\n\tstruct regmap *regmap = dwmac->regmap;\n\tint iface = dwmac->interface;\n\tu32 reg = dwmac->ctrl_reg;\n\tu32 val;\n\n\tif (dwmac->gmac_en)\n\t\tregmap_update_bits(regmap, reg, EN_MASK, EN);\n\n\tregmap_update_bits(regmap, reg, MII_PHY_SEL_MASK, phy_intf_sels[iface]);\n\n\tval = (iface == PHY_INTERFACE_MODE_REVMII) ? 0 : ENMII;\n\tregmap_update_bits(regmap, reg, ENMII_MASK, val);\n\n\tdwmac->fix_retime_src(dwmac, dwmac->speed, 0);\n\n\treturn 0;\n}\n\nstatic int sti_dwmac_parse_data(struct sti_dwmac *dwmac,\n\t\t\t\tstruct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct regmap *regmap;\n\tint err;\n\n\t \n\tdwmac->clk_sel_reg = -ENXIO;\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"sti-clkconf\");\n\tif (res)\n\t\tdwmac->clk_sel_reg = res->start;\n\n\tregmap = syscon_regmap_lookup_by_phandle(np, \"st,syscon\");\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\terr = of_property_read_u32_index(np, \"st,syscon\", 1, &dwmac->ctrl_reg);\n\tif (err) {\n\t\tdev_err(dev, \"Can't get sysconfig ctrl offset (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = of_get_phy_mode(np, &dwmac->interface);\n\tif (err && err != -ENODEV) {\n\t\tdev_err(dev, \"Can't get phy-mode\\n\");\n\t\treturn err;\n\t}\n\n\tdwmac->regmap = regmap;\n\tdwmac->gmac_en = of_property_read_bool(np, \"st,gmac_en\");\n\tdwmac->ext_phyclk = of_property_read_bool(np, \"st,ext-phyclk\");\n\tdwmac->tx_retime_src = TX_RETIME_SRC_NA;\n\tdwmac->speed = SPEED_100;\n\n\tif (IS_PHY_IF_MODE_GBIT(dwmac->interface)) {\n\t\tconst char *rs;\n\n\t\tdwmac->tx_retime_src = TX_RETIME_SRC_CLKGEN;\n\n\t\terr = of_property_read_string(np, \"st,tx-retime-src\", &rs);\n\t\tif (err < 0) {\n\t\t\tdev_warn(dev, \"Use internal clock source\\n\");\n\t\t} else {\n\t\t\tif (!strcasecmp(rs, \"clk_125\"))\n\t\t\t\tdwmac->tx_retime_src = TX_RETIME_SRC_CLK_125;\n\t\t\telse if (!strcasecmp(rs, \"txclk\"))\n\t\t\t\tdwmac->tx_retime_src = TX_RETIME_SRC_TXCLK;\n\t\t}\n\t\tdwmac->speed = SPEED_1000;\n\t}\n\n\tdwmac->clk = devm_clk_get(dev, \"sti-ethclk\");\n\tif (IS_ERR(dwmac->clk)) {\n\t\tdev_warn(dev, \"No phy clock provided...\\n\");\n\t\tdwmac->clk = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic int sti_dwmac_probe(struct platform_device *pdev)\n{\n\tstruct plat_stmmacenet_data *plat_dat;\n\tconst struct sti_dwmac_of_data *data;\n\tstruct stmmac_resources stmmac_res;\n\tstruct sti_dwmac *dwmac;\n\tint ret;\n\n\tdata = of_device_get_match_data(&pdev->dev);\n\tif (!data) {\n\t\tdev_err(&pdev->dev, \"No OF match data provided\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = stmmac_get_platform_resources(pdev, &stmmac_res);\n\tif (ret)\n\t\treturn ret;\n\n\tplat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);\n\tif (IS_ERR(plat_dat))\n\t\treturn PTR_ERR(plat_dat);\n\n\tdwmac = devm_kzalloc(&pdev->dev, sizeof(*dwmac), GFP_KERNEL);\n\tif (!dwmac) {\n\t\tret = -ENOMEM;\n\t\tgoto err_remove_config_dt;\n\t}\n\n\tret = sti_dwmac_parse_data(dwmac, pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Unable to parse OF data\\n\");\n\t\tgoto err_remove_config_dt;\n\t}\n\n\tdwmac->fix_retime_src = data->fix_retime_src;\n\n\tplat_dat->bsp_priv = dwmac;\n\tplat_dat->fix_mac_speed = data->fix_retime_src;\n\n\tret = clk_prepare_enable(dwmac->clk);\n\tif (ret)\n\t\tgoto err_remove_config_dt;\n\n\tret = sti_dwmac_set_mode(dwmac);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\tret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\treturn 0;\n\ndisable_clk:\n\tclk_disable_unprepare(dwmac->clk);\nerr_remove_config_dt:\n\tstmmac_remove_config_dt(pdev, plat_dat);\n\n\treturn ret;\n}\n\nstatic void sti_dwmac_remove(struct platform_device *pdev)\n{\n\tstruct sti_dwmac *dwmac = get_stmmac_bsp_priv(&pdev->dev);\n\n\tstmmac_dvr_remove(&pdev->dev);\n\n\tclk_disable_unprepare(dwmac->clk);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sti_dwmac_suspend(struct device *dev)\n{\n\tstruct sti_dwmac *dwmac = get_stmmac_bsp_priv(dev);\n\tint ret = stmmac_suspend(dev);\n\n\tclk_disable_unprepare(dwmac->clk);\n\n\treturn ret;\n}\n\nstatic int sti_dwmac_resume(struct device *dev)\n{\n\tstruct sti_dwmac *dwmac = get_stmmac_bsp_priv(dev);\n\n\tclk_prepare_enable(dwmac->clk);\n\tsti_dwmac_set_mode(dwmac);\n\n\treturn stmmac_resume(dev);\n}\n#endif  \n\nstatic SIMPLE_DEV_PM_OPS(sti_dwmac_pm_ops, sti_dwmac_suspend,\n\t\t\t\t\t   sti_dwmac_resume);\n\nstatic const struct sti_dwmac_of_data stih4xx_dwmac_data = {\n\t.fix_retime_src = stih4xx_fix_retime_src,\n};\n\nstatic const struct of_device_id sti_dwmac_match[] = {\n\t{ .compatible = \"st,stih407-dwmac\", .data = &stih4xx_dwmac_data},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sti_dwmac_match);\n\nstatic struct platform_driver sti_dwmac_driver = {\n\t.probe  = sti_dwmac_probe,\n\t.remove_new = sti_dwmac_remove,\n\t.driver = {\n\t\t.name           = \"sti-dwmac\",\n\t\t.pm\t\t= &sti_dwmac_pm_ops,\n\t\t.of_match_table = sti_dwmac_match,\n\t},\n};\nmodule_platform_driver(sti_dwmac_driver);\n\nMODULE_AUTHOR(\"Srinivas Kandagatla <srinivas.kandagatla@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics DWMAC Specific Glue layer\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}