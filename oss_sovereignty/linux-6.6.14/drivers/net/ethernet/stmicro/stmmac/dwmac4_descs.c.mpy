{
  "module_name": "dwmac4_descs.c",
  "hash_id": "d2f23a605a52f33db4d366cd88ee2ee3446b85030bd750806945eb8dab68dee9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwmac4_descs.c",
  "human_readable_source": "\n \n\n#include <linux/stmmac.h>\n#include \"common.h\"\n#include \"dwmac4.h\"\n#include \"dwmac4_descs.h\"\n\nstatic int dwmac4_wrback_get_tx_status(struct stmmac_extra_stats *x,\n\t\t\t\t       struct dma_desc *p,\n\t\t\t\t       void __iomem *ioaddr)\n{\n\tunsigned int tdes3;\n\tint ret = tx_done;\n\n\ttdes3 = le32_to_cpu(p->des3);\n\n\t \n\tif (unlikely(tdes3 & TDES3_OWN))\n\t\treturn tx_dma_own;\n\n\t \n\tif (likely(!(tdes3 & TDES3_LAST_DESCRIPTOR)))\n\t\treturn tx_not_ls;\n\n\tif (unlikely(tdes3 & TDES3_ERROR_SUMMARY)) {\n\t\tret = tx_err;\n\n\t\tif (unlikely(tdes3 & TDES3_JABBER_TIMEOUT))\n\t\t\tx->tx_jabber++;\n\t\tif (unlikely(tdes3 & TDES3_PACKET_FLUSHED))\n\t\t\tx->tx_frame_flushed++;\n\t\tif (unlikely(tdes3 & TDES3_LOSS_CARRIER)) {\n\t\t\tx->tx_losscarrier++;\n\t\t}\n\t\tif (unlikely(tdes3 & TDES3_NO_CARRIER)) {\n\t\t\tx->tx_carrier++;\n\t\t}\n\t\tif (unlikely((tdes3 & TDES3_LATE_COLLISION) ||\n\t\t\t     (tdes3 & TDES3_EXCESSIVE_COLLISION)))\n\t\t\tx->tx_collision +=\n\t\t\t    (tdes3 & TDES3_COLLISION_COUNT_MASK)\n\t\t\t    >> TDES3_COLLISION_COUNT_SHIFT;\n\n\t\tif (unlikely(tdes3 & TDES3_EXCESSIVE_DEFERRAL))\n\t\t\tx->tx_deferred++;\n\n\t\tif (unlikely(tdes3 & TDES3_UNDERFLOW_ERROR)) {\n\t\t\tx->tx_underflow++;\n\t\t\tret |= tx_err_bump_tc;\n\t\t}\n\n\t\tif (unlikely(tdes3 & TDES3_IP_HDR_ERROR))\n\t\t\tx->tx_ip_header_error++;\n\n\t\tif (unlikely(tdes3 & TDES3_PAYLOAD_ERROR))\n\t\t\tx->tx_payload_error++;\n\t}\n\n\tif (unlikely(tdes3 & TDES3_DEFERRED))\n\t\tx->tx_deferred++;\n\n\treturn ret;\n}\n\nstatic int dwmac4_wrback_get_rx_status(struct stmmac_extra_stats *x,\n\t\t\t\t       struct dma_desc *p)\n{\n\tunsigned int rdes1 = le32_to_cpu(p->des1);\n\tunsigned int rdes2 = le32_to_cpu(p->des2);\n\tunsigned int rdes3 = le32_to_cpu(p->des3);\n\tint message_type;\n\tint ret = good_frame;\n\n\tif (unlikely(rdes3 & RDES3_OWN))\n\t\treturn dma_own;\n\n\tif (unlikely(rdes3 & RDES3_CONTEXT_DESCRIPTOR))\n\t\treturn discard_frame;\n\tif (likely(!(rdes3 & RDES3_LAST_DESCRIPTOR)))\n\t\treturn rx_not_ls;\n\n\tif (unlikely(rdes3 & RDES3_ERROR_SUMMARY)) {\n\t\tif (unlikely(rdes3 & RDES3_GIANT_PACKET))\n\t\t\tx->rx_length++;\n\t\tif (unlikely(rdes3 & RDES3_OVERFLOW_ERROR))\n\t\t\tx->rx_gmac_overflow++;\n\n\t\tif (unlikely(rdes3 & RDES3_RECEIVE_WATCHDOG))\n\t\t\tx->rx_watchdog++;\n\n\t\tif (unlikely(rdes3 & RDES3_RECEIVE_ERROR))\n\t\t\tx->rx_mii++;\n\n\t\tif (unlikely(rdes3 & RDES3_CRC_ERROR))\n\t\t\tx->rx_crc_errors++;\n\n\t\tif (unlikely(rdes3 & RDES3_DRIBBLE_ERROR))\n\t\t\tx->dribbling_bit++;\n\n\t\tret = discard_frame;\n\t}\n\n\tmessage_type = (rdes1 & ERDES4_MSG_TYPE_MASK) >> 8;\n\n\tif (rdes1 & RDES1_IP_HDR_ERROR)\n\t\tx->ip_hdr_err++;\n\tif (rdes1 & RDES1_IP_CSUM_BYPASSED)\n\t\tx->ip_csum_bypassed++;\n\tif (rdes1 & RDES1_IPV4_HEADER)\n\t\tx->ipv4_pkt_rcvd++;\n\tif (rdes1 & RDES1_IPV6_HEADER)\n\t\tx->ipv6_pkt_rcvd++;\n\n\tif (message_type == RDES_EXT_NO_PTP)\n\t\tx->no_ptp_rx_msg_type_ext++;\n\telse if (message_type == RDES_EXT_SYNC)\n\t\tx->ptp_rx_msg_type_sync++;\n\telse if (message_type == RDES_EXT_FOLLOW_UP)\n\t\tx->ptp_rx_msg_type_follow_up++;\n\telse if (message_type == RDES_EXT_DELAY_REQ)\n\t\tx->ptp_rx_msg_type_delay_req++;\n\telse if (message_type == RDES_EXT_DELAY_RESP)\n\t\tx->ptp_rx_msg_type_delay_resp++;\n\telse if (message_type == RDES_EXT_PDELAY_REQ)\n\t\tx->ptp_rx_msg_type_pdelay_req++;\n\telse if (message_type == RDES_EXT_PDELAY_RESP)\n\t\tx->ptp_rx_msg_type_pdelay_resp++;\n\telse if (message_type == RDES_EXT_PDELAY_FOLLOW_UP)\n\t\tx->ptp_rx_msg_type_pdelay_follow_up++;\n\telse if (message_type == RDES_PTP_ANNOUNCE)\n\t\tx->ptp_rx_msg_type_announce++;\n\telse if (message_type == RDES_PTP_MANAGEMENT)\n\t\tx->ptp_rx_msg_type_management++;\n\telse if (message_type == RDES_PTP_PKT_RESERVED_TYPE)\n\t\tx->ptp_rx_msg_pkt_reserved_type++;\n\n\tif (rdes1 & RDES1_PTP_PACKET_TYPE)\n\t\tx->ptp_frame_type++;\n\tif (rdes1 & RDES1_PTP_VER)\n\t\tx->ptp_ver++;\n\tif (rdes1 & RDES1_TIMESTAMP_DROPPED)\n\t\tx->timestamp_dropped++;\n\n\tif (unlikely(rdes2 & RDES2_SA_FILTER_FAIL)) {\n\t\tx->sa_rx_filter_fail++;\n\t\tret = discard_frame;\n\t}\n\tif (unlikely(rdes2 & RDES2_DA_FILTER_FAIL)) {\n\t\tx->da_rx_filter_fail++;\n\t\tret = discard_frame;\n\t}\n\n\tif (rdes2 & RDES2_L3_FILTER_MATCH)\n\t\tx->l3_filter_match++;\n\tif (rdes2 & RDES2_L4_FILTER_MATCH)\n\t\tx->l4_filter_match++;\n\tif ((rdes2 & RDES2_L3_L4_FILT_NB_MATCH_MASK)\n\t    >> RDES2_L3_L4_FILT_NB_MATCH_SHIFT)\n\t\tx->l3_l4_filter_no_match++;\n\n\treturn ret;\n}\n\nstatic int dwmac4_rd_get_tx_len(struct dma_desc *p)\n{\n\treturn (le32_to_cpu(p->des2) & TDES2_BUFFER1_SIZE_MASK);\n}\n\nstatic int dwmac4_get_tx_owner(struct dma_desc *p)\n{\n\treturn (le32_to_cpu(p->des3) & TDES3_OWN) >> TDES3_OWN_SHIFT;\n}\n\nstatic void dwmac4_set_tx_owner(struct dma_desc *p)\n{\n\tp->des3 |= cpu_to_le32(TDES3_OWN);\n}\n\nstatic void dwmac4_set_rx_owner(struct dma_desc *p, int disable_rx_ic)\n{\n\tp->des3 |= cpu_to_le32(RDES3_OWN | RDES3_BUFFER1_VALID_ADDR);\n\n\tif (!disable_rx_ic)\n\t\tp->des3 |= cpu_to_le32(RDES3_INT_ON_COMPLETION_EN);\n}\n\nstatic int dwmac4_get_tx_ls(struct dma_desc *p)\n{\n\treturn (le32_to_cpu(p->des3) & TDES3_LAST_DESCRIPTOR)\n\t\t>> TDES3_LAST_DESCRIPTOR_SHIFT;\n}\n\nstatic int dwmac4_wrback_get_rx_frame_len(struct dma_desc *p, int rx_coe)\n{\n\treturn (le32_to_cpu(p->des3) & RDES3_PACKET_SIZE_MASK);\n}\n\nstatic void dwmac4_rd_enable_tx_timestamp(struct dma_desc *p)\n{\n\tp->des2 |= cpu_to_le32(TDES2_TIMESTAMP_ENABLE);\n}\n\nstatic int dwmac4_wrback_get_tx_timestamp_status(struct dma_desc *p)\n{\n\t \n\tif (le32_to_cpu(p->des3) & TDES3_CONTEXT_TYPE)\n\t\treturn 0;\n\n\t \n\tif (le32_to_cpu(p->des3) & TDES3_TIMESTAMP_STATUS)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic inline void dwmac4_get_timestamp(void *desc, u32 ats, u64 *ts)\n{\n\tstruct dma_desc *p = (struct dma_desc *)desc;\n\tu64 ns;\n\n\tns = le32_to_cpu(p->des0);\n\t \n\tns += le32_to_cpu(p->des1) * 1000000000ULL;\n\n\t*ts = ns;\n}\n\nstatic int dwmac4_rx_check_timestamp(void *desc)\n{\n\tstruct dma_desc *p = (struct dma_desc *)desc;\n\tunsigned int rdes0 = le32_to_cpu(p->des0);\n\tunsigned int rdes1 = le32_to_cpu(p->des1);\n\tunsigned int rdes3 = le32_to_cpu(p->des3);\n\tu32 own, ctxt;\n\tint ret = 1;\n\n\town = rdes3 & RDES3_OWN;\n\tctxt = ((rdes3 & RDES3_CONTEXT_DESCRIPTOR)\n\t\t>> RDES3_CONTEXT_DESCRIPTOR_SHIFT);\n\n\tif (likely(!own && ctxt)) {\n\t\tif ((rdes0 == 0xffffffff) && (rdes1 == 0xffffffff))\n\t\t\t \n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\t \n\t\t\tret = 0;\n\t}\n\n\t \n\treturn ret;\n}\n\nstatic int dwmac4_wrback_get_rx_timestamp_status(void *desc, void *next_desc,\n\t\t\t\t\t\t u32 ats)\n{\n\tstruct dma_desc *p = (struct dma_desc *)desc;\n\tint ret = -EINVAL;\n\n\t \n\tif (likely(le32_to_cpu(p->des3) & RDES3_RDES1_VALID)) {\n\t\tif (likely(le32_to_cpu(p->des1) & RDES1_TIMESTAMP_AVAILABLE)) {\n\t\t\tint i = 0;\n\n\t\t\t \n\t\t\tdo {\n\t\t\t\tret = dwmac4_rx_check_timestamp(next_desc);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto exit;\n\t\t\t\ti++;\n\n\t\t\t} while ((ret == 1) && (i < 10));\n\n\t\t\tif (i == 10)\n\t\t\t\tret = -EBUSY;\n\t\t}\n\t}\nexit:\n\tif (likely(ret == 0))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void dwmac4_rd_init_rx_desc(struct dma_desc *p, int disable_rx_ic,\n\t\t\t\t   int mode, int end, int bfsize)\n{\n\tdwmac4_set_rx_owner(p, disable_rx_ic);\n}\n\nstatic void dwmac4_rd_init_tx_desc(struct dma_desc *p, int mode, int end)\n{\n\tp->des0 = 0;\n\tp->des1 = 0;\n\tp->des2 = 0;\n\tp->des3 = 0;\n}\n\nstatic void dwmac4_rd_prepare_tx_desc(struct dma_desc *p, int is_fs, int len,\n\t\t\t\t      bool csum_flag, int mode, bool tx_own,\n\t\t\t\t      bool ls, unsigned int tot_pkt_len)\n{\n\tunsigned int tdes3 = le32_to_cpu(p->des3);\n\n\tp->des2 |= cpu_to_le32(len & TDES2_BUFFER1_SIZE_MASK);\n\n\ttdes3 |= tot_pkt_len & TDES3_PACKET_SIZE_MASK;\n\tif (is_fs)\n\t\ttdes3 |= TDES3_FIRST_DESCRIPTOR;\n\telse\n\t\ttdes3 &= ~TDES3_FIRST_DESCRIPTOR;\n\n\tif (likely(csum_flag))\n\t\ttdes3 |= (TX_CIC_FULL << TDES3_CHECKSUM_INSERTION_SHIFT);\n\telse\n\t\ttdes3 &= ~(TX_CIC_FULL << TDES3_CHECKSUM_INSERTION_SHIFT);\n\n\tif (ls)\n\t\ttdes3 |= TDES3_LAST_DESCRIPTOR;\n\telse\n\t\ttdes3 &= ~TDES3_LAST_DESCRIPTOR;\n\n\t \n\tif (tx_own)\n\t\ttdes3 |= TDES3_OWN;\n\n\tif (is_fs && tx_own)\n\t\t \n\t\tdma_wmb();\n\n\tp->des3 = cpu_to_le32(tdes3);\n}\n\nstatic void dwmac4_rd_prepare_tso_tx_desc(struct dma_desc *p, int is_fs,\n\t\t\t\t\t  int len1, int len2, bool tx_own,\n\t\t\t\t\t  bool ls, unsigned int tcphdrlen,\n\t\t\t\t\t  unsigned int tcppayloadlen)\n{\n\tunsigned int tdes3 = le32_to_cpu(p->des3);\n\n\tif (len1)\n\t\tp->des2 |= cpu_to_le32((len1 & TDES2_BUFFER1_SIZE_MASK));\n\n\tif (len2)\n\t\tp->des2 |= cpu_to_le32((len2 << TDES2_BUFFER2_SIZE_MASK_SHIFT)\n\t\t\t    & TDES2_BUFFER2_SIZE_MASK);\n\n\tif (is_fs) {\n\t\ttdes3 |= TDES3_FIRST_DESCRIPTOR |\n\t\t\t TDES3_TCP_SEGMENTATION_ENABLE |\n\t\t\t ((tcphdrlen << TDES3_HDR_LEN_SHIFT) &\n\t\t\t  TDES3_SLOT_NUMBER_MASK) |\n\t\t\t ((tcppayloadlen & TDES3_TCP_PKT_PAYLOAD_MASK));\n\t} else {\n\t\ttdes3 &= ~TDES3_FIRST_DESCRIPTOR;\n\t}\n\n\tif (ls)\n\t\ttdes3 |= TDES3_LAST_DESCRIPTOR;\n\telse\n\t\ttdes3 &= ~TDES3_LAST_DESCRIPTOR;\n\n\t \n\tif (tx_own)\n\t\ttdes3 |= TDES3_OWN;\n\n\tif (is_fs && tx_own)\n\t\t \n\t\tdma_wmb();\n\n\tp->des3 = cpu_to_le32(tdes3);\n}\n\nstatic void dwmac4_release_tx_desc(struct dma_desc *p, int mode)\n{\n\tp->des0 = 0;\n\tp->des1 = 0;\n\tp->des2 = 0;\n\tp->des3 = 0;\n}\n\nstatic void dwmac4_rd_set_tx_ic(struct dma_desc *p)\n{\n\tp->des2 |= cpu_to_le32(TDES2_INTERRUPT_ON_COMPLETION);\n}\n\nstatic void dwmac4_display_ring(void *head, unsigned int size, bool rx,\n\t\t\t\tdma_addr_t dma_rx_phy, unsigned int desc_size)\n{\n\tdma_addr_t dma_addr;\n\tint i;\n\n\tpr_info(\"%s descriptor ring:\\n\", rx ? \"RX\" : \"TX\");\n\n\tif (desc_size == sizeof(struct dma_desc)) {\n\t\tstruct dma_desc *p = (struct dma_desc *)head;\n\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tdma_addr = dma_rx_phy + i * sizeof(*p);\n\t\t\tpr_info(\"%03d [%pad]: 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t\ti, &dma_addr,\n\t\t\t\tle32_to_cpu(p->des0), le32_to_cpu(p->des1),\n\t\t\t\tle32_to_cpu(p->des2), le32_to_cpu(p->des3));\n\t\t\tp++;\n\t\t}\n\t} else if (desc_size == sizeof(struct dma_extended_desc)) {\n\t\tstruct dma_extended_desc *extp = (struct dma_extended_desc *)head;\n\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tdma_addr = dma_rx_phy + i * sizeof(*extp);\n\t\t\tpr_info(\"%03d [%pad]: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t\ti, &dma_addr,\n\t\t\t\tle32_to_cpu(extp->basic.des0), le32_to_cpu(extp->basic.des1),\n\t\t\t\tle32_to_cpu(extp->basic.des2), le32_to_cpu(extp->basic.des3),\n\t\t\t\tle32_to_cpu(extp->des4), le32_to_cpu(extp->des5),\n\t\t\t\tle32_to_cpu(extp->des6), le32_to_cpu(extp->des7));\n\t\t\textp++;\n\t\t}\n\t} else if (desc_size == sizeof(struct dma_edesc)) {\n\t\tstruct dma_edesc *ep = (struct dma_edesc *)head;\n\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tdma_addr = dma_rx_phy + i * sizeof(*ep);\n\t\t\tpr_info(\"%03d [%pad]: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\t\t\ti, &dma_addr,\n\t\t\t\tle32_to_cpu(ep->des4), le32_to_cpu(ep->des5),\n\t\t\t\tle32_to_cpu(ep->des6), le32_to_cpu(ep->des7),\n\t\t\t\tle32_to_cpu(ep->basic.des0), le32_to_cpu(ep->basic.des1),\n\t\t\t\tle32_to_cpu(ep->basic.des2), le32_to_cpu(ep->basic.des3));\n\t\t\tep++;\n\t\t}\n\t} else {\n\t\tpr_err(\"unsupported descriptor!\");\n\t}\n}\n\nstatic void dwmac4_set_mss_ctxt(struct dma_desc *p, unsigned int mss)\n{\n\tp->des0 = 0;\n\tp->des1 = 0;\n\tp->des2 = cpu_to_le32(mss);\n\tp->des3 = cpu_to_le32(TDES3_CONTEXT_TYPE | TDES3_CTXT_TCMSSV);\n}\n\nstatic void dwmac4_set_addr(struct dma_desc *p, dma_addr_t addr)\n{\n\tp->des0 = cpu_to_le32(lower_32_bits(addr));\n\tp->des1 = cpu_to_le32(upper_32_bits(addr));\n}\n\nstatic void dwmac4_clear(struct dma_desc *p)\n{\n\tp->des0 = 0;\n\tp->des1 = 0;\n\tp->des2 = 0;\n\tp->des3 = 0;\n}\n\nstatic void dwmac4_set_sarc(struct dma_desc *p, u32 sarc_type)\n{\n\tsarc_type <<= TDES3_SA_INSERT_CTRL_SHIFT;\n\n\tp->des3 |= cpu_to_le32(sarc_type & TDES3_SA_INSERT_CTRL_MASK);\n}\n\nstatic int set_16kib_bfsize(int mtu)\n{\n\tint ret = 0;\n\n\tif (unlikely(mtu >= BUF_SIZE_8KiB))\n\t\tret = BUF_SIZE_16KiB;\n\treturn ret;\n}\n\nstatic void dwmac4_set_vlan_tag(struct dma_desc *p, u16 tag, u16 inner_tag,\n\t\t\t\tu32 inner_type)\n{\n\tp->des0 = 0;\n\tp->des1 = 0;\n\tp->des2 = 0;\n\tp->des3 = 0;\n\n\t \n\tif (inner_type) {\n\t\tu32 des = inner_tag << TDES2_IVT_SHIFT;\n\n\t\tdes &= TDES2_IVT_MASK;\n\t\tp->des2 = cpu_to_le32(des);\n\n\t\tdes = inner_type << TDES3_IVTIR_SHIFT;\n\t\tdes &= TDES3_IVTIR_MASK;\n\t\tp->des3 = cpu_to_le32(des | TDES3_IVLTV);\n\t}\n\n\t \n\tp->des3 |= cpu_to_le32(tag & TDES3_VLAN_TAG);\n\tp->des3 |= cpu_to_le32(TDES3_VLTV);\n\n\tp->des3 |= cpu_to_le32(TDES3_CONTEXT_TYPE);\n}\n\nstatic void dwmac4_set_vlan(struct dma_desc *p, u32 type)\n{\n\ttype <<= TDES2_VLAN_TAG_SHIFT;\n\tp->des2 |= cpu_to_le32(type & TDES2_VLAN_TAG_MASK);\n}\n\nstatic void dwmac4_get_rx_header_len(struct dma_desc *p, unsigned int *len)\n{\n\t*len = le32_to_cpu(p->des2) & RDES2_HL;\n}\n\nstatic void dwmac4_set_sec_addr(struct dma_desc *p, dma_addr_t addr, bool buf2_valid)\n{\n\tp->des2 = cpu_to_le32(lower_32_bits(addr));\n\tp->des3 = cpu_to_le32(upper_32_bits(addr));\n\n\tif (buf2_valid)\n\t\tp->des3 |= cpu_to_le32(RDES3_BUFFER2_VALID_ADDR);\n\telse\n\t\tp->des3 &= cpu_to_le32(~RDES3_BUFFER2_VALID_ADDR);\n}\n\nstatic void dwmac4_set_tbs(struct dma_edesc *p, u32 sec, u32 nsec)\n{\n\tp->des4 = cpu_to_le32((sec & TDES4_LT) | TDES4_LTV);\n\tp->des5 = cpu_to_le32(nsec & TDES5_LT);\n\tp->des6 = 0;\n\tp->des7 = 0;\n}\n\nconst struct stmmac_desc_ops dwmac4_desc_ops = {\n\t.tx_status = dwmac4_wrback_get_tx_status,\n\t.rx_status = dwmac4_wrback_get_rx_status,\n\t.get_tx_len = dwmac4_rd_get_tx_len,\n\t.get_tx_owner = dwmac4_get_tx_owner,\n\t.set_tx_owner = dwmac4_set_tx_owner,\n\t.set_rx_owner = dwmac4_set_rx_owner,\n\t.get_tx_ls = dwmac4_get_tx_ls,\n\t.get_rx_frame_len = dwmac4_wrback_get_rx_frame_len,\n\t.enable_tx_timestamp = dwmac4_rd_enable_tx_timestamp,\n\t.get_tx_timestamp_status = dwmac4_wrback_get_tx_timestamp_status,\n\t.get_rx_timestamp_status = dwmac4_wrback_get_rx_timestamp_status,\n\t.get_timestamp = dwmac4_get_timestamp,\n\t.set_tx_ic = dwmac4_rd_set_tx_ic,\n\t.prepare_tx_desc = dwmac4_rd_prepare_tx_desc,\n\t.prepare_tso_tx_desc = dwmac4_rd_prepare_tso_tx_desc,\n\t.release_tx_desc = dwmac4_release_tx_desc,\n\t.init_rx_desc = dwmac4_rd_init_rx_desc,\n\t.init_tx_desc = dwmac4_rd_init_tx_desc,\n\t.display_ring = dwmac4_display_ring,\n\t.set_mss = dwmac4_set_mss_ctxt,\n\t.set_addr = dwmac4_set_addr,\n\t.clear = dwmac4_clear,\n\t.set_sarc = dwmac4_set_sarc,\n\t.set_vlan_tag = dwmac4_set_vlan_tag,\n\t.set_vlan = dwmac4_set_vlan,\n\t.get_rx_header_len = dwmac4_get_rx_header_len,\n\t.set_sec_addr = dwmac4_set_sec_addr,\n\t.set_tbs = dwmac4_set_tbs,\n};\n\nconst struct stmmac_mode_ops dwmac4_ring_mode_ops = {\n\t.set_16kib_bfsize = set_16kib_bfsize,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}