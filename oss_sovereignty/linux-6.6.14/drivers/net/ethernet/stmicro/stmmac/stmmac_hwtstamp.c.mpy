{
  "module_name": "stmmac_hwtstamp.c",
  "hash_id": "125a4e4181d532e45818f2d39c4ad6abfef9fcfb283606510aafc24fb5683e6a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/stmmac_hwtstamp.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/delay.h>\n#include <linux/ptp_clock_kernel.h>\n#include \"common.h\"\n#include \"stmmac_ptp.h\"\n#include \"dwmac4.h\"\n#include \"stmmac.h\"\n\nstatic void config_hw_tstamping(void __iomem *ioaddr, u32 data)\n{\n\twritel(data, ioaddr + PTP_TCR);\n}\n\nstatic void config_sub_second_increment(void __iomem *ioaddr,\n\t\tu32 ptp_clock, int gmac4, u32 *ssinc)\n{\n\tu32 value = readl(ioaddr + PTP_TCR);\n\tunsigned long data;\n\tu32 reg_value;\n\n\t \n\tif (value & PTP_TCR_TSCFUPDT)\n\t\tdata = (2000000000ULL / ptp_clock);\n\telse\n\t\tdata = (1000000000ULL / ptp_clock);\n\n\t \n\tif (!(value & PTP_TCR_TSCTRLSSR))\n\t\tdata = (data * 1000) / 465;\n\n\tif (data > PTP_SSIR_SSINC_MAX)\n\t\tdata = PTP_SSIR_SSINC_MAX;\n\n\treg_value = data;\n\tif (gmac4)\n\t\treg_value <<= GMAC4_PTP_SSIR_SSINC_SHIFT;\n\n\twritel(reg_value, ioaddr + PTP_SSIR);\n\n\tif (ssinc)\n\t\t*ssinc = data;\n}\n\nstatic void hwtstamp_correct_latency(struct stmmac_priv *priv)\n{\n\tvoid __iomem *ioaddr = priv->ptpaddr;\n\tu32 reg_tsic, reg_tsicsns;\n\tu32 reg_tsec, reg_tsecsns;\n\tu64 scaled_ns;\n\tu32 val;\n\n\t \n\tscaled_ns = readl(ioaddr + PTP_TS_INGR_LAT);\n\n\t \n\tval = readl(ioaddr + PTP_TCR);\n\tif (val & PTP_TCR_TSCTRLSSR)\n\t\t \n\t\tscaled_ns = ((u64)NSEC_PER_SEC << 16) - scaled_ns;\n\telse\n\t\t \n\t\tscaled_ns = ((1ULL << 31) << 16) -\n\t\t\tDIV_U64_ROUND_CLOSEST(scaled_ns * PSEC_PER_NSEC, 466U);\n\n\treg_tsic = scaled_ns >> 16;\n\treg_tsicsns = scaled_ns & 0xff00;\n\n\t \n\treg_tsic |= BIT(31);\n\n\twritel(reg_tsic, ioaddr + PTP_TS_INGR_CORR_NS);\n\twritel(reg_tsicsns, ioaddr + PTP_TS_INGR_CORR_SNS);\n\n\t \n\tscaled_ns = readl(ioaddr + PTP_TS_EGR_LAT);\n\n\treg_tsec = scaled_ns >> 16;\n\treg_tsecsns = scaled_ns & 0xff00;\n\n\twritel(reg_tsec, ioaddr + PTP_TS_EGR_CORR_NS);\n\twritel(reg_tsecsns, ioaddr + PTP_TS_EGR_CORR_SNS);\n}\n\nstatic int init_systime(void __iomem *ioaddr, u32 sec, u32 nsec)\n{\n\tu32 value;\n\n\twritel(sec, ioaddr + PTP_STSUR);\n\twritel(nsec, ioaddr + PTP_STNSUR);\n\t \n\tvalue = readl(ioaddr + PTP_TCR);\n\tvalue |= PTP_TCR_TSINIT;\n\twritel(value, ioaddr + PTP_TCR);\n\n\t \n\treturn readl_poll_timeout_atomic(ioaddr + PTP_TCR, value,\n\t\t\t\t !(value & PTP_TCR_TSINIT),\n\t\t\t\t 10, 100000);\n}\n\nstatic int config_addend(void __iomem *ioaddr, u32 addend)\n{\n\tu32 value;\n\tint limit;\n\n\twritel(addend, ioaddr + PTP_TAR);\n\t \n\tvalue = readl(ioaddr + PTP_TCR);\n\tvalue |= PTP_TCR_TSADDREG;\n\twritel(value, ioaddr + PTP_TCR);\n\n\t \n\tlimit = 10;\n\twhile (limit--) {\n\t\tif (!(readl(ioaddr + PTP_TCR) & PTP_TCR_TSADDREG))\n\t\t\tbreak;\n\t\tmdelay(10);\n\t}\n\tif (limit < 0)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic int adjust_systime(void __iomem *ioaddr, u32 sec, u32 nsec,\n\t\tint add_sub, int gmac4)\n{\n\tu32 value;\n\tint limit;\n\n\tif (add_sub) {\n\t\t \n\t\tif (gmac4)\n\t\t\tsec = -sec;\n\n\t\tvalue = readl(ioaddr + PTP_TCR);\n\t\tif (value & PTP_TCR_TSCTRLSSR)\n\t\t\tnsec = (PTP_DIGITAL_ROLLOVER_MODE - nsec);\n\t\telse\n\t\t\tnsec = (PTP_BINARY_ROLLOVER_MODE - nsec);\n\t}\n\n\twritel(sec, ioaddr + PTP_STSUR);\n\tvalue = (add_sub << PTP_STNSUR_ADDSUB_SHIFT) | nsec;\n\twritel(value, ioaddr + PTP_STNSUR);\n\n\t \n\tvalue = readl(ioaddr + PTP_TCR);\n\tvalue |= PTP_TCR_TSUPDT;\n\twritel(value, ioaddr + PTP_TCR);\n\n\t \n\tlimit = 10;\n\twhile (limit--) {\n\t\tif (!(readl(ioaddr + PTP_TCR) & PTP_TCR_TSUPDT))\n\t\t\tbreak;\n\t\tmdelay(10);\n\t}\n\tif (limit < 0)\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic void get_systime(void __iomem *ioaddr, u64 *systime)\n{\n\tu64 ns, sec0, sec1;\n\n\t \n\tsec1 = readl_relaxed(ioaddr + PTP_STSR);\n\tdo {\n\t\tsec0 = sec1;\n\t\t \n\t\tns = readl_relaxed(ioaddr + PTP_STNSR);\n\t\t \n\t\tsec1 = readl_relaxed(ioaddr + PTP_STSR);\n\t} while (sec0 != sec1);\n\n\tif (systime)\n\t\t*systime = ns + (sec1 * 1000000000ULL);\n}\n\nstatic void get_ptptime(void __iomem *ptpaddr, u64 *ptp_time)\n{\n\tu64 ns;\n\n\tns = readl(ptpaddr + PTP_ATNR);\n\tns += readl(ptpaddr + PTP_ATSR) * NSEC_PER_SEC;\n\n\t*ptp_time = ns;\n}\n\nstatic void timestamp_interrupt(struct stmmac_priv *priv)\n{\n\tu32 num_snapshot, ts_status, tsync_int;\n\tstruct ptp_clock_event event;\n\tunsigned long flags;\n\tu64 ptp_time;\n\tint i;\n\n\tif (priv->plat->flags & STMMAC_FLAG_INT_SNAPSHOT_EN) {\n\t\twake_up(&priv->tstamp_busy_wait);\n\t\treturn;\n\t}\n\n\ttsync_int = readl(priv->ioaddr + GMAC_INT_STATUS) & GMAC_INT_TSIE;\n\n\tif (!tsync_int)\n\t\treturn;\n\n\t \n\tts_status = readl(priv->ioaddr + GMAC_TIMESTAMP_STATUS);\n\n\tif (!(priv->plat->flags & STMMAC_FLAG_EXT_SNAPSHOT_EN))\n\t\treturn;\n\n\tnum_snapshot = (ts_status & GMAC_TIMESTAMP_ATSNS_MASK) >>\n\t\t       GMAC_TIMESTAMP_ATSNS_SHIFT;\n\n\tfor (i = 0; i < num_snapshot; i++) {\n\t\tread_lock_irqsave(&priv->ptp_lock, flags);\n\t\tget_ptptime(priv->ptpaddr, &ptp_time);\n\t\tread_unlock_irqrestore(&priv->ptp_lock, flags);\n\t\tevent.type = PTP_CLOCK_EXTTS;\n\t\tevent.index = 0;\n\t\tevent.timestamp = ptp_time;\n\t\tptp_clock_event(priv->ptp_clock, &event);\n\t}\n}\n\nconst struct stmmac_hwtimestamp stmmac_ptp = {\n\t.config_hw_tstamping = config_hw_tstamping,\n\t.init_systime = init_systime,\n\t.config_sub_second_increment = config_sub_second_increment,\n\t.config_addend = config_addend,\n\t.adjust_systime = adjust_systime,\n\t.get_systime = get_systime,\n\t.get_ptptime = get_ptptime,\n\t.timestamp_interrupt = timestamp_interrupt,\n\t.hwtstamp_correct_latency = hwtstamp_correct_latency,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}