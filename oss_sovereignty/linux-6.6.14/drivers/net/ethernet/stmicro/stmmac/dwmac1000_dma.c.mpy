{
  "module_name": "dwmac1000_dma.c",
  "hash_id": "c7977f904d214d935c3ec1b85b46d5058ef174eaaf1126d0957a071bd41072fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwmac1000_dma.c",
  "human_readable_source": "\n \n\n#include <asm/io.h>\n#include \"dwmac1000.h\"\n#include \"dwmac_dma.h\"\n\nstatic void dwmac1000_dma_axi(void __iomem *ioaddr, struct stmmac_axi *axi)\n{\n\tu32 value = readl(ioaddr + DMA_AXI_BUS_MODE);\n\tint i;\n\n\tpr_info(\"dwmac1000: Master AXI performs %s burst length\\n\",\n\t\t!(value & DMA_AXI_UNDEF) ? \"fixed\" : \"any\");\n\n\tif (axi->axi_lpi_en)\n\t\tvalue |= DMA_AXI_EN_LPI;\n\tif (axi->axi_xit_frm)\n\t\tvalue |= DMA_AXI_LPI_XIT_FRM;\n\n\tvalue &= ~DMA_AXI_WR_OSR_LMT;\n\tvalue |= (axi->axi_wr_osr_lmt & DMA_AXI_WR_OSR_LMT_MASK) <<\n\t\t DMA_AXI_WR_OSR_LMT_SHIFT;\n\n\tvalue &= ~DMA_AXI_RD_OSR_LMT;\n\tvalue |= (axi->axi_rd_osr_lmt & DMA_AXI_RD_OSR_LMT_MASK) <<\n\t\t DMA_AXI_RD_OSR_LMT_SHIFT;\n\n\t \n\tfor (i = 0; i < AXI_BLEN; i++) {\n\t\tswitch (axi->axi_blen[i]) {\n\t\tcase 256:\n\t\t\tvalue |= DMA_AXI_BLEN256;\n\t\t\tbreak;\n\t\tcase 128:\n\t\t\tvalue |= DMA_AXI_BLEN128;\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tvalue |= DMA_AXI_BLEN64;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tvalue |= DMA_AXI_BLEN32;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tvalue |= DMA_AXI_BLEN16;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tvalue |= DMA_AXI_BLEN8;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tvalue |= DMA_AXI_BLEN4;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twritel(value, ioaddr + DMA_AXI_BUS_MODE);\n}\n\nstatic void dwmac1000_dma_init(void __iomem *ioaddr,\n\t\t\t       struct stmmac_dma_cfg *dma_cfg, int atds)\n{\n\tu32 value = readl(ioaddr + DMA_BUS_MODE);\n\tint txpbl = dma_cfg->txpbl ?: dma_cfg->pbl;\n\tint rxpbl = dma_cfg->rxpbl ?: dma_cfg->pbl;\n\n\t \n\tif (dma_cfg->pblx8)\n\t\tvalue |= DMA_BUS_MODE_MAXPBL;\n\tvalue |= DMA_BUS_MODE_USP;\n\tvalue &= ~(DMA_BUS_MODE_PBL_MASK | DMA_BUS_MODE_RPBL_MASK);\n\tvalue |= (txpbl << DMA_BUS_MODE_PBL_SHIFT);\n\tvalue |= (rxpbl << DMA_BUS_MODE_RPBL_SHIFT);\n\n\t \n\tif (dma_cfg->fixed_burst)\n\t\tvalue |= DMA_BUS_MODE_FB;\n\n\t \n\tif (dma_cfg->mixed_burst)\n\t\tvalue |= DMA_BUS_MODE_MB;\n\n\tif (atds)\n\t\tvalue |= DMA_BUS_MODE_ATDS;\n\n\tif (dma_cfg->aal)\n\t\tvalue |= DMA_BUS_MODE_AAL;\n\n\twritel(value, ioaddr + DMA_BUS_MODE);\n\n\t \n\twritel(DMA_INTR_DEFAULT_MASK, ioaddr + DMA_INTR_ENA);\n}\n\nstatic void dwmac1000_dma_init_rx(struct stmmac_priv *priv,\n\t\t\t\t  void __iomem *ioaddr,\n\t\t\t\t  struct stmmac_dma_cfg *dma_cfg,\n\t\t\t\t  dma_addr_t dma_rx_phy, u32 chan)\n{\n\t \n\twritel(lower_32_bits(dma_rx_phy), ioaddr + DMA_RCV_BASE_ADDR);\n}\n\nstatic void dwmac1000_dma_init_tx(struct stmmac_priv *priv,\n\t\t\t\t  void __iomem *ioaddr,\n\t\t\t\t  struct stmmac_dma_cfg *dma_cfg,\n\t\t\t\t  dma_addr_t dma_tx_phy, u32 chan)\n{\n\t \n\twritel(lower_32_bits(dma_tx_phy), ioaddr + DMA_TX_BASE_ADDR);\n}\n\nstatic u32 dwmac1000_configure_fc(u32 csr6, int rxfifosz)\n{\n\tcsr6 &= ~DMA_CONTROL_RFA_MASK;\n\tcsr6 &= ~DMA_CONTROL_RFD_MASK;\n\n\t \n\tif (rxfifosz < 4096) {\n\t\tcsr6 &= ~DMA_CONTROL_EFC;\n\t\tpr_debug(\"GMAC: disabling flow control, rxfifo too small(%d)\\n\",\n\t\t\t rxfifosz);\n\t} else {\n\t\tcsr6 |= DMA_CONTROL_EFC;\n\t\tcsr6 |= RFA_FULL_MINUS_1K;\n\t\tcsr6 |= RFD_FULL_MINUS_2K;\n\t}\n\treturn csr6;\n}\n\nstatic void dwmac1000_dma_operation_mode_rx(struct stmmac_priv *priv,\n\t\t\t\t\t    void __iomem *ioaddr, int mode,\n\t\t\t\t\t    u32 channel, int fifosz, u8 qmode)\n{\n\tu32 csr6 = readl(ioaddr + DMA_CONTROL);\n\n\tif (mode == SF_DMA_MODE) {\n\t\tpr_debug(\"GMAC: enable RX store and forward mode\\n\");\n\t\tcsr6 |= DMA_CONTROL_RSF;\n\t} else {\n\t\tpr_debug(\"GMAC: disable RX SF mode (threshold %d)\\n\", mode);\n\t\tcsr6 &= ~DMA_CONTROL_RSF;\n\t\tcsr6 &= DMA_CONTROL_TC_RX_MASK;\n\t\tif (mode <= 32)\n\t\t\tcsr6 |= DMA_CONTROL_RTC_32;\n\t\telse if (mode <= 64)\n\t\t\tcsr6 |= DMA_CONTROL_RTC_64;\n\t\telse if (mode <= 96)\n\t\t\tcsr6 |= DMA_CONTROL_RTC_96;\n\t\telse\n\t\t\tcsr6 |= DMA_CONTROL_RTC_128;\n\t}\n\n\t \n\tcsr6 = dwmac1000_configure_fc(csr6, fifosz);\n\n\twritel(csr6, ioaddr + DMA_CONTROL);\n}\n\nstatic void dwmac1000_dma_operation_mode_tx(struct stmmac_priv *priv,\n\t\t\t\t\t    void __iomem *ioaddr, int mode,\n\t\t\t\t\t    u32 channel, int fifosz, u8 qmode)\n{\n\tu32 csr6 = readl(ioaddr + DMA_CONTROL);\n\n\tif (mode == SF_DMA_MODE) {\n\t\tpr_debug(\"GMAC: enable TX store and forward mode\\n\");\n\t\t \n\t\tcsr6 |= DMA_CONTROL_TSF;\n\t\t \n\t\tcsr6 |= DMA_CONTROL_OSF;\n\t} else {\n\t\tpr_debug(\"GMAC: disabling TX SF (threshold %d)\\n\", mode);\n\t\tcsr6 &= ~DMA_CONTROL_TSF;\n\t\tcsr6 &= DMA_CONTROL_TC_TX_MASK;\n\t\t \n\t\tif (mode <= 32)\n\t\t\tcsr6 |= DMA_CONTROL_TTC_32;\n\t\telse if (mode <= 64)\n\t\t\tcsr6 |= DMA_CONTROL_TTC_64;\n\t\telse if (mode <= 128)\n\t\t\tcsr6 |= DMA_CONTROL_TTC_128;\n\t\telse if (mode <= 192)\n\t\t\tcsr6 |= DMA_CONTROL_TTC_192;\n\t\telse\n\t\t\tcsr6 |= DMA_CONTROL_TTC_256;\n\t}\n\n\twritel(csr6, ioaddr + DMA_CONTROL);\n}\n\nstatic void dwmac1000_dump_dma_regs(struct stmmac_priv *priv,\n\t\t\t\t    void __iomem *ioaddr, u32 *reg_space)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_DWMAC1000_DMA_REGS; i++)\n\t\tif ((i < 12) || (i > 17))\n\t\t\treg_space[DMA_BUS_MODE / 4 + i] =\n\t\t\t\treadl(ioaddr + DMA_BUS_MODE + i * 4);\n}\n\nstatic int dwmac1000_get_hw_feature(void __iomem *ioaddr,\n\t\t\t\t    struct dma_features *dma_cap)\n{\n\tu32 hw_cap = readl(ioaddr + DMA_HW_FEATURE);\n\n\tif (!hw_cap) {\n\t\t \n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdma_cap->mbps_10_100 = (hw_cap & DMA_HW_FEAT_MIISEL);\n\tdma_cap->mbps_1000 = (hw_cap & DMA_HW_FEAT_GMIISEL) >> 1;\n\tdma_cap->half_duplex = (hw_cap & DMA_HW_FEAT_HDSEL) >> 2;\n\tdma_cap->hash_filter = (hw_cap & DMA_HW_FEAT_HASHSEL) >> 4;\n\tdma_cap->multi_addr = (hw_cap & DMA_HW_FEAT_ADDMAC) >> 5;\n\tdma_cap->pcs = (hw_cap & DMA_HW_FEAT_PCSSEL) >> 6;\n\tdma_cap->sma_mdio = (hw_cap & DMA_HW_FEAT_SMASEL) >> 8;\n\tdma_cap->pmt_remote_wake_up = (hw_cap & DMA_HW_FEAT_RWKSEL) >> 9;\n\tdma_cap->pmt_magic_frame = (hw_cap & DMA_HW_FEAT_MGKSEL) >> 10;\n\t \n\tdma_cap->rmon = (hw_cap & DMA_HW_FEAT_MMCSEL) >> 11;\n\t \n\tdma_cap->time_stamp =\n\t    (hw_cap & DMA_HW_FEAT_TSVER1SEL) >> 12;\n\t \n\tdma_cap->atime_stamp = (hw_cap & DMA_HW_FEAT_TSVER2SEL) >> 13;\n\t \n\tdma_cap->eee = (hw_cap & DMA_HW_FEAT_EEESEL) >> 14;\n\tdma_cap->av = (hw_cap & DMA_HW_FEAT_AVSEL) >> 15;\n\t \n\tdma_cap->tx_coe = (hw_cap & DMA_HW_FEAT_TXCOESEL) >> 16;\n\tdma_cap->rx_coe_type1 = (hw_cap & DMA_HW_FEAT_RXTYP1COE) >> 17;\n\tdma_cap->rx_coe_type2 = (hw_cap & DMA_HW_FEAT_RXTYP2COE) >> 18;\n\tdma_cap->rxfifo_over_2048 = (hw_cap & DMA_HW_FEAT_RXFIFOSIZE) >> 19;\n\t \n\tdma_cap->number_rx_channel = (hw_cap & DMA_HW_FEAT_RXCHCNT) >> 20;\n\tdma_cap->number_tx_channel = (hw_cap & DMA_HW_FEAT_TXCHCNT) >> 22;\n\t \n\tdma_cap->enh_desc = (hw_cap & DMA_HW_FEAT_ENHDESSEL) >> 24;\n\n\treturn 0;\n}\n\nstatic void dwmac1000_rx_watchdog(struct stmmac_priv *priv,\n\t\t\t\t  void __iomem *ioaddr, u32 riwt, u32 queue)\n{\n\twritel(riwt, ioaddr + DMA_RX_WATCHDOG);\n}\n\nconst struct stmmac_dma_ops dwmac1000_dma_ops = {\n\t.reset = dwmac_dma_reset,\n\t.init = dwmac1000_dma_init,\n\t.init_rx_chan = dwmac1000_dma_init_rx,\n\t.init_tx_chan = dwmac1000_dma_init_tx,\n\t.axi = dwmac1000_dma_axi,\n\t.dump_regs = dwmac1000_dump_dma_regs,\n\t.dma_rx_mode = dwmac1000_dma_operation_mode_rx,\n\t.dma_tx_mode = dwmac1000_dma_operation_mode_tx,\n\t.enable_dma_transmission = dwmac_enable_dma_transmission,\n\t.enable_dma_irq = dwmac_enable_dma_irq,\n\t.disable_dma_irq = dwmac_disable_dma_irq,\n\t.start_tx = dwmac_dma_start_tx,\n\t.stop_tx = dwmac_dma_stop_tx,\n\t.start_rx = dwmac_dma_start_rx,\n\t.stop_rx = dwmac_dma_stop_rx,\n\t.dma_interrupt = dwmac_dma_interrupt,\n\t.get_hw_feature = dwmac1000_get_hw_feature,\n\t.rx_watchdog = dwmac1000_rx_watchdog,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}