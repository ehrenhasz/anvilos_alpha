{
  "module_name": "stmmac_mdio.c",
  "hash_id": "26352a8e1a4ba8f44de3f40477aa32e92209afe52b0c25a1670a9fb64f0f2335",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/consumer.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/mii.h>\n#include <linux/of_mdio.h>\n#include <linux/pm_runtime.h>\n#include <linux/phy.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n\n#include \"dwxgmac2.h\"\n#include \"stmmac.h\"\n\n#define MII_BUSY 0x00000001\n#define MII_WRITE 0x00000002\n#define MII_DATA_MASK GENMASK(15, 0)\n\n \n#define MII_GMAC4_GOC_SHIFT\t\t2\n#define MII_GMAC4_REG_ADDR_SHIFT\t16\n#define MII_GMAC4_WRITE\t\t\t(1 << MII_GMAC4_GOC_SHIFT)\n#define MII_GMAC4_READ\t\t\t(3 << MII_GMAC4_GOC_SHIFT)\n#define MII_GMAC4_C45E\t\t\tBIT(1)\n\n \n#define MII_XGMAC_SADDR\t\t\tBIT(18)\n#define MII_XGMAC_CMD_SHIFT\t\t16\n#define MII_XGMAC_WRITE\t\t\t(1 << MII_XGMAC_CMD_SHIFT)\n#define MII_XGMAC_READ\t\t\t(3 << MII_XGMAC_CMD_SHIFT)\n#define MII_XGMAC_BUSY\t\t\tBIT(22)\n#define MII_XGMAC_MAX_C22ADDR\t\t3\n#define MII_XGMAC_C22P_MASK\t\tGENMASK(MII_XGMAC_MAX_C22ADDR, 0)\n#define MII_XGMAC_PA_SHIFT\t\t16\n#define MII_XGMAC_DA_SHIFT\t\t21\n\nstatic void stmmac_xgmac2_c45_format(struct stmmac_priv *priv, int phyaddr,\n\t\t\t\t     int devad, int phyreg, u32 *hw_addr)\n{\n\tu32 tmp;\n\n\t \n\ttmp = readl(priv->ioaddr + XGMAC_MDIO_C22P);\n\ttmp &= ~BIT(phyaddr);\n\twritel(tmp, priv->ioaddr + XGMAC_MDIO_C22P);\n\n\t*hw_addr = (phyaddr << MII_XGMAC_PA_SHIFT) | (phyreg & 0xffff);\n\t*hw_addr |= devad << MII_XGMAC_DA_SHIFT;\n}\n\nstatic void stmmac_xgmac2_c22_format(struct stmmac_priv *priv, int phyaddr,\n\t\t\t\t     int phyreg, u32 *hw_addr)\n{\n\tu32 tmp = 0;\n\n\tif (priv->synopsys_id < DWXGMAC_CORE_2_20) {\n\t\t \n\t\ttmp = readl(priv->ioaddr + XGMAC_MDIO_C22P);\n\t\ttmp &= ~MII_XGMAC_C22P_MASK;\n\t}\n\t \n\ttmp |= BIT(phyaddr);\n\twritel(tmp, priv->ioaddr + XGMAC_MDIO_C22P);\n\n\t*hw_addr = (phyaddr << MII_XGMAC_PA_SHIFT) | (phyreg & 0x1f);\n}\n\nstatic int stmmac_xgmac2_mdio_read(struct stmmac_priv *priv, u32 addr,\n\t\t\t\t   u32 value)\n{\n\tunsigned int mii_address = priv->hw->mii.addr;\n\tunsigned int mii_data = priv->hw->mii.data;\n\tu32 tmp;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(priv->device);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (readl_poll_timeout(priv->ioaddr + mii_data, tmp,\n\t\t\t       !(tmp & MII_XGMAC_BUSY), 100, 10000)) {\n\t\tret = -EBUSY;\n\t\tgoto err_disable_clks;\n\t}\n\n\tvalue |= (priv->clk_csr << priv->hw->mii.clk_csr_shift)\n\t\t& priv->hw->mii.clk_csr_mask;\n\tvalue |= MII_XGMAC_READ;\n\n\t \n\tif (readl_poll_timeout(priv->ioaddr + mii_data, tmp,\n\t\t\t       !(tmp & MII_XGMAC_BUSY), 100, 10000)) {\n\t\tret = -EBUSY;\n\t\tgoto err_disable_clks;\n\t}\n\n\t \n\twritel(addr, priv->ioaddr + mii_address);\n\twritel(value, priv->ioaddr + mii_data);\n\n\t \n\tif (readl_poll_timeout(priv->ioaddr + mii_data, tmp,\n\t\t\t       !(tmp & MII_XGMAC_BUSY), 100, 10000)) {\n\t\tret = -EBUSY;\n\t\tgoto err_disable_clks;\n\t}\n\n\t \n\tret = (int)readl(priv->ioaddr + mii_data) & GENMASK(15, 0);\n\nerr_disable_clks:\n\tpm_runtime_put(priv->device);\n\n\treturn ret;\n}\n\nstatic int stmmac_xgmac2_mdio_read_c22(struct mii_bus *bus, int phyaddr,\n\t\t\t\t       int phyreg)\n{\n\tstruct net_device *ndev = bus->priv;\n\tstruct stmmac_priv *priv;\n\tu32 addr;\n\n\tpriv = netdev_priv(ndev);\n\n\t \n\tif (priv->synopsys_id < DWXGMAC_CORE_2_20 &&\n\t    phyaddr > MII_XGMAC_MAX_C22ADDR)\n\t\treturn -ENODEV;\n\n\tstmmac_xgmac2_c22_format(priv, phyaddr, phyreg, &addr);\n\n\treturn stmmac_xgmac2_mdio_read(priv, addr, MII_XGMAC_BUSY);\n}\n\nstatic int stmmac_xgmac2_mdio_read_c45(struct mii_bus *bus, int phyaddr,\n\t\t\t\t       int devad, int phyreg)\n{\n\tstruct net_device *ndev = bus->priv;\n\tstruct stmmac_priv *priv;\n\tu32 addr;\n\n\tpriv = netdev_priv(ndev);\n\n\tstmmac_xgmac2_c45_format(priv, phyaddr, devad, phyreg, &addr);\n\n\treturn stmmac_xgmac2_mdio_read(priv, addr, MII_XGMAC_BUSY);\n}\n\nstatic int stmmac_xgmac2_mdio_write(struct stmmac_priv *priv, u32 addr,\n\t\t\t\t    u32 value, u16 phydata)\n{\n\tunsigned int mii_address = priv->hw->mii.addr;\n\tunsigned int mii_data = priv->hw->mii.data;\n\tu32 tmp;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(priv->device);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (readl_poll_timeout(priv->ioaddr + mii_data, tmp,\n\t\t\t       !(tmp & MII_XGMAC_BUSY), 100, 10000)) {\n\t\tret = -EBUSY;\n\t\tgoto err_disable_clks;\n\t}\n\n\tvalue |= (priv->clk_csr << priv->hw->mii.clk_csr_shift)\n\t\t& priv->hw->mii.clk_csr_mask;\n\tvalue |= phydata;\n\tvalue |= MII_XGMAC_WRITE;\n\n\t \n\tif (readl_poll_timeout(priv->ioaddr + mii_data, tmp,\n\t\t\t       !(tmp & MII_XGMAC_BUSY), 100, 10000)) {\n\t\tret = -EBUSY;\n\t\tgoto err_disable_clks;\n\t}\n\n\t \n\twritel(addr, priv->ioaddr + mii_address);\n\twritel(value, priv->ioaddr + mii_data);\n\n\t \n\tret = readl_poll_timeout(priv->ioaddr + mii_data, tmp,\n\t\t\t\t !(tmp & MII_XGMAC_BUSY), 100, 10000);\n\nerr_disable_clks:\n\tpm_runtime_put(priv->device);\n\n\treturn ret;\n}\n\nstatic int stmmac_xgmac2_mdio_write_c22(struct mii_bus *bus, int phyaddr,\n\t\t\t\t\tint phyreg, u16 phydata)\n{\n\tstruct net_device *ndev = bus->priv;\n\tstruct stmmac_priv *priv;\n\tu32 addr;\n\n\tpriv = netdev_priv(ndev);\n\n\t \n\tif (priv->synopsys_id < DWXGMAC_CORE_2_20 &&\n\t    phyaddr > MII_XGMAC_MAX_C22ADDR)\n\t\treturn -ENODEV;\n\n\tstmmac_xgmac2_c22_format(priv, phyaddr, phyreg, &addr);\n\n\treturn stmmac_xgmac2_mdio_write(priv, addr,\n\t\t\t\t\tMII_XGMAC_BUSY | MII_XGMAC_SADDR, phydata);\n}\n\nstatic int stmmac_xgmac2_mdio_write_c45(struct mii_bus *bus, int phyaddr,\n\t\t\t\t\tint devad, int phyreg, u16 phydata)\n{\n\tstruct net_device *ndev = bus->priv;\n\tstruct stmmac_priv *priv;\n\tu32 addr;\n\n\tpriv = netdev_priv(ndev);\n\n\tstmmac_xgmac2_c45_format(priv, phyaddr, devad, phyreg, &addr);\n\n\treturn stmmac_xgmac2_mdio_write(priv, addr, MII_XGMAC_BUSY,\n\t\t\t\t\tphydata);\n}\n\nstatic int stmmac_mdio_read(struct stmmac_priv *priv, int data, u32 value)\n{\n\tunsigned int mii_address = priv->hw->mii.addr;\n\tunsigned int mii_data = priv->hw->mii.data;\n\tu32 v;\n\n\tif (readl_poll_timeout(priv->ioaddr + mii_address, v, !(v & MII_BUSY),\n\t\t\t       100, 10000))\n\t\treturn -EBUSY;\n\n\twritel(data, priv->ioaddr + mii_data);\n\twritel(value, priv->ioaddr + mii_address);\n\n\tif (readl_poll_timeout(priv->ioaddr + mii_address, v, !(v & MII_BUSY),\n\t\t\t       100, 10000))\n\t\treturn -EBUSY;\n\n\t \n\treturn readl(priv->ioaddr + mii_data) & MII_DATA_MASK;\n}\n\n \nstatic int stmmac_mdio_read_c22(struct mii_bus *bus, int phyaddr, int phyreg)\n{\n\tstruct net_device *ndev = bus->priv;\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\tu32 value = MII_BUSY;\n\tint data = 0;\n\n\tdata = pm_runtime_resume_and_get(priv->device);\n\tif (data < 0)\n\t\treturn data;\n\n\tvalue |= (phyaddr << priv->hw->mii.addr_shift)\n\t\t& priv->hw->mii.addr_mask;\n\tvalue |= (phyreg << priv->hw->mii.reg_shift) & priv->hw->mii.reg_mask;\n\tvalue |= (priv->clk_csr << priv->hw->mii.clk_csr_shift)\n\t\t& priv->hw->mii.clk_csr_mask;\n\tif (priv->plat->has_gmac4)\n\t\tvalue |= MII_GMAC4_READ;\n\n\tdata = stmmac_mdio_read(priv, data, value);\n\n\tpm_runtime_put(priv->device);\n\n\treturn data;\n}\n\n \nstatic int stmmac_mdio_read_c45(struct mii_bus *bus, int phyaddr, int devad,\n\t\t\t\tint phyreg)\n{\n\tstruct net_device *ndev = bus->priv;\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\tu32 value = MII_BUSY;\n\tint data = 0;\n\n\tdata = pm_runtime_get_sync(priv->device);\n\tif (data < 0) {\n\t\tpm_runtime_put_noidle(priv->device);\n\t\treturn data;\n\t}\n\n\tvalue |= (phyaddr << priv->hw->mii.addr_shift)\n\t\t& priv->hw->mii.addr_mask;\n\tvalue |= (phyreg << priv->hw->mii.reg_shift) & priv->hw->mii.reg_mask;\n\tvalue |= (priv->clk_csr << priv->hw->mii.clk_csr_shift)\n\t\t& priv->hw->mii.clk_csr_mask;\n\tvalue |= MII_GMAC4_READ;\n\tvalue |= MII_GMAC4_C45E;\n\tvalue &= ~priv->hw->mii.reg_mask;\n\tvalue |= (devad << priv->hw->mii.reg_shift) & priv->hw->mii.reg_mask;\n\n\tdata |= phyreg << MII_GMAC4_REG_ADDR_SHIFT;\n\n\tdata = stmmac_mdio_read(priv, data, value);\n\n\tpm_runtime_put(priv->device);\n\n\treturn data;\n}\n\nstatic int stmmac_mdio_write(struct stmmac_priv *priv, int data, u32 value)\n{\n\tunsigned int mii_address = priv->hw->mii.addr;\n\tunsigned int mii_data = priv->hw->mii.data;\n\tu32 v;\n\n\t \n\tif (readl_poll_timeout(priv->ioaddr + mii_address, v, !(v & MII_BUSY),\n\t\t\t       100, 10000))\n\t\treturn -EBUSY;\n\n\t \n\twritel(data, priv->ioaddr + mii_data);\n\twritel(value, priv->ioaddr + mii_address);\n\n\t \n\treturn readl_poll_timeout(priv->ioaddr + mii_address, v,\n\t\t\t\t  !(v & MII_BUSY), 100, 10000);\n}\n\n \nstatic int stmmac_mdio_write_c22(struct mii_bus *bus, int phyaddr, int phyreg,\n\t\t\t\t u16 phydata)\n{\n\tstruct net_device *ndev = bus->priv;\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\tint ret, data = phydata;\n\tu32 value = MII_BUSY;\n\n\tret = pm_runtime_resume_and_get(priv->device);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvalue |= (phyaddr << priv->hw->mii.addr_shift)\n\t\t& priv->hw->mii.addr_mask;\n\tvalue |= (phyreg << priv->hw->mii.reg_shift) & priv->hw->mii.reg_mask;\n\n\tvalue |= (priv->clk_csr << priv->hw->mii.clk_csr_shift)\n\t\t& priv->hw->mii.clk_csr_mask;\n\tif (priv->plat->has_gmac4)\n\t\tvalue |= MII_GMAC4_WRITE;\n\telse\n\t\tvalue |= MII_WRITE;\n\n\tret = stmmac_mdio_write(priv, data, value);\n\n\tpm_runtime_put(priv->device);\n\n\treturn ret;\n}\n\n \nstatic int stmmac_mdio_write_c45(struct mii_bus *bus, int phyaddr,\n\t\t\t\t int devad, int phyreg, u16 phydata)\n{\n\tstruct net_device *ndev = bus->priv;\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\tint ret, data = phydata;\n\tu32 value = MII_BUSY;\n\n\tret = pm_runtime_get_sync(priv->device);\n\tif (ret < 0) {\n\t\tpm_runtime_put_noidle(priv->device);\n\t\treturn ret;\n\t}\n\n\tvalue |= (phyaddr << priv->hw->mii.addr_shift)\n\t\t& priv->hw->mii.addr_mask;\n\tvalue |= (phyreg << priv->hw->mii.reg_shift) & priv->hw->mii.reg_mask;\n\n\tvalue |= (priv->clk_csr << priv->hw->mii.clk_csr_shift)\n\t\t& priv->hw->mii.clk_csr_mask;\n\n\tvalue |= MII_GMAC4_WRITE;\n\tvalue |= MII_GMAC4_C45E;\n\tvalue &= ~priv->hw->mii.reg_mask;\n\tvalue |= (devad << priv->hw->mii.reg_shift) & priv->hw->mii.reg_mask;\n\n\tdata |= phyreg << MII_GMAC4_REG_ADDR_SHIFT;\n\n\tret = stmmac_mdio_write(priv, data, value);\n\n\tpm_runtime_put(priv->device);\n\n\treturn ret;\n}\n\n \nint stmmac_mdio_reset(struct mii_bus *bus)\n{\n#if IS_ENABLED(CONFIG_STMMAC_PLATFORM)\n\tstruct net_device *ndev = bus->priv;\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\tunsigned int mii_address = priv->hw->mii.addr;\n\n#ifdef CONFIG_OF\n\tif (priv->device->of_node) {\n\t\tstruct gpio_desc *reset_gpio;\n\t\tu32 delays[3] = { 0, 0, 0 };\n\n\t\treset_gpio = devm_gpiod_get_optional(priv->device,\n\t\t\t\t\t\t     \"snps,reset\",\n\t\t\t\t\t\t     GPIOD_OUT_LOW);\n\t\tif (IS_ERR(reset_gpio))\n\t\t\treturn PTR_ERR(reset_gpio);\n\n\t\tdevice_property_read_u32_array(priv->device,\n\t\t\t\t\t       \"snps,reset-delays-us\",\n\t\t\t\t\t       delays, ARRAY_SIZE(delays));\n\n\t\tif (delays[0])\n\t\t\tmsleep(DIV_ROUND_UP(delays[0], 1000));\n\n\t\tgpiod_set_value_cansleep(reset_gpio, 1);\n\t\tif (delays[1])\n\t\t\tmsleep(DIV_ROUND_UP(delays[1], 1000));\n\n\t\tgpiod_set_value_cansleep(reset_gpio, 0);\n\t\tif (delays[2])\n\t\t\tmsleep(DIV_ROUND_UP(delays[2], 1000));\n\t}\n#endif\n\n\t \n\tif (!priv->plat->has_gmac4)\n\t\twritel(0, priv->ioaddr + mii_address);\n#endif\n\treturn 0;\n}\n\nint stmmac_xpcs_setup(struct mii_bus *bus)\n{\n\tstruct net_device *ndev = bus->priv;\n\tstruct stmmac_priv *priv;\n\tstruct dw_xpcs *xpcs;\n\tint mode, addr;\n\n\tpriv = netdev_priv(ndev);\n\tmode = priv->plat->phy_interface;\n\n\t \n\tfor (addr = 0; addr < PHY_MAX_ADDR; addr++) {\n\t\txpcs = xpcs_create_mdiodev(bus, addr, mode);\n\t\tif (IS_ERR(xpcs))\n\t\t\tcontinue;\n\n\t\tpriv->hw->xpcs = xpcs;\n\t\tbreak;\n\t}\n\n\tif (!priv->hw->xpcs) {\n\t\tdev_warn(priv->device, \"No xPCS found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nint stmmac_mdio_register(struct net_device *ndev)\n{\n\tint err = 0;\n\tstruct mii_bus *new_bus;\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\tstruct stmmac_mdio_bus_data *mdio_bus_data = priv->plat->mdio_bus_data;\n\tstruct device_node *mdio_node = priv->plat->mdio_node;\n\tstruct device *dev = ndev->dev.parent;\n\tstruct fwnode_handle *fixed_node;\n\tstruct fwnode_handle *fwnode;\n\tint addr, found, max_addr;\n\n\tif (!mdio_bus_data)\n\t\treturn 0;\n\n\tnew_bus = mdiobus_alloc();\n\tif (!new_bus)\n\t\treturn -ENOMEM;\n\n\tif (mdio_bus_data->irqs)\n\t\tmemcpy(new_bus->irq, mdio_bus_data->irqs, sizeof(new_bus->irq));\n\n\tnew_bus->name = \"stmmac\";\n\n\tif (priv->plat->has_xgmac) {\n\t\tnew_bus->read = &stmmac_xgmac2_mdio_read_c22;\n\t\tnew_bus->write = &stmmac_xgmac2_mdio_write_c22;\n\t\tnew_bus->read_c45 = &stmmac_xgmac2_mdio_read_c45;\n\t\tnew_bus->write_c45 = &stmmac_xgmac2_mdio_write_c45;\n\n\t\tif (priv->synopsys_id < DWXGMAC_CORE_2_20) {\n\t\t\t \n\t\t\tmax_addr = MII_XGMAC_MAX_C22ADDR + 1;\n\n\t\t\t \n\t\t\tif (priv->plat->phy_addr > MII_XGMAC_MAX_C22ADDR)\n\t\t\t\tdev_err(dev, \"Unsupported phy_addr (max=%d)\\n\",\n\t\t\t\t\tMII_XGMAC_MAX_C22ADDR);\n\t\t} else {\n\t\t\t \n\t\t\tmax_addr = PHY_MAX_ADDR;\n\t\t}\n\t} else {\n\t\tnew_bus->read = &stmmac_mdio_read_c22;\n\t\tnew_bus->write = &stmmac_mdio_write_c22;\n\t\tif (priv->plat->has_gmac4) {\n\t\t\tnew_bus->read_c45 = &stmmac_mdio_read_c45;\n\t\t\tnew_bus->write_c45 = &stmmac_mdio_write_c45;\n\t\t}\n\n\t\tmax_addr = PHY_MAX_ADDR;\n\t}\n\n\tif (mdio_bus_data->needs_reset)\n\t\tnew_bus->reset = &stmmac_mdio_reset;\n\n\tsnprintf(new_bus->id, MII_BUS_ID_SIZE, \"%s-%x\",\n\t\t new_bus->name, priv->plat->bus_id);\n\tnew_bus->priv = ndev;\n\tnew_bus->phy_mask = mdio_bus_data->phy_mask;\n\tnew_bus->parent = priv->device;\n\n\terr = of_mdiobus_register(new_bus, mdio_node);\n\tif (err == -ENODEV) {\n\t\terr = 0;\n\t\tdev_info(dev, \"MDIO bus is disabled\\n\");\n\t\tgoto bus_register_fail;\n\t} else if (err) {\n\t\tdev_err_probe(dev, err, \"Cannot register the MDIO bus\\n\");\n\t\tgoto bus_register_fail;\n\t}\n\n\t \n\tif (priv->plat->has_xgmac)\n\t\tstmmac_xgmac2_mdio_read_c45(new_bus, 0, 0, 0);\n\n\t \n\tfwnode = priv->plat->port_node;\n\tif (!fwnode)\n\t\tfwnode = dev_fwnode(priv->device);\n\n\tif (fwnode) {\n\t\tfixed_node = fwnode_get_named_child_node(fwnode, \"fixed-link\");\n\t\tif (fixed_node) {\n\t\t\tfwnode_handle_put(fixed_node);\n\t\t\tgoto bus_register_done;\n\t\t}\n\t}\n\n\tif (priv->plat->phy_node || mdio_node)\n\t\tgoto bus_register_done;\n\n\tfound = 0;\n\tfor (addr = 0; addr < max_addr; addr++) {\n\t\tstruct phy_device *phydev = mdiobus_get_phy(new_bus, addr);\n\n\t\tif (!phydev)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!mdio_bus_data->irqs &&\n\t\t    (mdio_bus_data->probed_phy_irq > 0)) {\n\t\t\tnew_bus->irq[addr] = mdio_bus_data->probed_phy_irq;\n\t\t\tphydev->irq = mdio_bus_data->probed_phy_irq;\n\t\t}\n\n\t\t \n\t\tif (priv->plat->phy_addr == -1)\n\t\t\tpriv->plat->phy_addr = addr;\n\n\t\tphy_attached_info(phydev);\n\t\tfound = 1;\n\t}\n\n\tif (!found && !mdio_node) {\n\t\tdev_warn(dev, \"No PHY found\\n\");\n\t\terr = -ENODEV;\n\t\tgoto no_phy_found;\n\t}\n\nbus_register_done:\n\tpriv->mii = new_bus;\n\n\treturn 0;\n\nno_phy_found:\n\tmdiobus_unregister(new_bus);\nbus_register_fail:\n\tmdiobus_free(new_bus);\n\treturn err;\n}\n\n \nint stmmac_mdio_unregister(struct net_device *ndev)\n{\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\n\tif (!priv->mii)\n\t\treturn 0;\n\n\tif (priv->hw->xpcs)\n\t\txpcs_destroy(priv->hw->xpcs);\n\n\tmdiobus_unregister(priv->mii);\n\tpriv->mii->priv = NULL;\n\tmdiobus_free(priv->mii);\n\tpriv->mii = NULL;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}