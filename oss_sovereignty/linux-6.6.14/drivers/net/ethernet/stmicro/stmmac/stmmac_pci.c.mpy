{
  "module_name": "stmmac_pci.c",
  "hash_id": "7fc7e1db8b5cce596e893894f6946802cb8387a95759338f4a8b549bfbfb1829",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/pci.h>\n#include <linux/dmi.h>\n\n#include \"stmmac.h\"\n\nstruct stmmac_pci_info {\n\tint (*setup)(struct pci_dev *pdev, struct plat_stmmacenet_data *plat);\n};\n\nstatic void common_default_data(struct plat_stmmacenet_data *plat)\n{\n\tplat->clk_csr = 2;\t \n\tplat->has_gmac = 1;\n\tplat->force_sf_dma_mode = 1;\n\n\tplat->mdio_bus_data->needs_reset = true;\n\n\t \n\tplat->multicast_filter_bins = HASH_TABLE_SIZE;\n\n\t \n\tplat->unicast_filter_entries = 1;\n\n\t \n\tplat->maxmtu = JUMBO_LEN;\n\n\t \n\tplat->tx_queues_to_use = 1;\n\tplat->rx_queues_to_use = 1;\n\n\t \n\tplat->tx_queues_cfg[0].use_prio = false;\n\tplat->rx_queues_cfg[0].use_prio = false;\n\n\t \n\tplat->rx_queues_cfg[0].pkt_route = 0x0;\n}\n\nstatic int stmmac_default_data(struct pci_dev *pdev,\n\t\t\t       struct plat_stmmacenet_data *plat)\n{\n\t \n\tcommon_default_data(plat);\n\n\tplat->bus_id = 1;\n\tplat->phy_addr = 0;\n\tplat->phy_interface = PHY_INTERFACE_MODE_GMII;\n\n\tplat->dma_cfg->pbl = 32;\n\tplat->dma_cfg->pblx8 = true;\n\t \n\n\treturn 0;\n}\n\nstatic const struct stmmac_pci_info stmmac_pci_info = {\n\t.setup = stmmac_default_data,\n};\n\nstatic int snps_gmac5_default_data(struct pci_dev *pdev,\n\t\t\t\t   struct plat_stmmacenet_data *plat)\n{\n\tint i;\n\n\tplat->clk_csr = 5;\n\tplat->has_gmac4 = 1;\n\tplat->force_sf_dma_mode = 1;\n\tplat->flags |= STMMAC_FLAG_TSO_EN;\n\tplat->pmt = 1;\n\n\t \n\tplat->multicast_filter_bins = HASH_TABLE_SIZE;\n\n\t \n\tplat->unicast_filter_entries = 1;\n\n\t \n\tplat->maxmtu = JUMBO_LEN;\n\n\t \n\tplat->tx_queues_to_use = 4;\n\tplat->rx_queues_to_use = 4;\n\n\tplat->tx_sched_algorithm = MTL_TX_ALGORITHM_WRR;\n\tfor (i = 0; i < plat->tx_queues_to_use; i++) {\n\t\tplat->tx_queues_cfg[i].use_prio = false;\n\t\tplat->tx_queues_cfg[i].mode_to_use = MTL_QUEUE_DCB;\n\t\tplat->tx_queues_cfg[i].weight = 25;\n\t\tif (i > 0)\n\t\t\tplat->tx_queues_cfg[i].tbs_en = 1;\n\t}\n\n\tplat->rx_sched_algorithm = MTL_RX_ALGORITHM_SP;\n\tfor (i = 0; i < plat->rx_queues_to_use; i++) {\n\t\tplat->rx_queues_cfg[i].use_prio = false;\n\t\tplat->rx_queues_cfg[i].mode_to_use = MTL_QUEUE_DCB;\n\t\tplat->rx_queues_cfg[i].pkt_route = 0x0;\n\t\tplat->rx_queues_cfg[i].chan = i;\n\t}\n\n\tplat->bus_id = 1;\n\tplat->phy_addr = -1;\n\tplat->phy_interface = PHY_INTERFACE_MODE_GMII;\n\n\tplat->dma_cfg->pbl = 32;\n\tplat->dma_cfg->pblx8 = true;\n\n\t \n\tplat->axi = devm_kzalloc(&pdev->dev, sizeof(*plat->axi), GFP_KERNEL);\n\tif (!plat->axi)\n\t\treturn -ENOMEM;\n\n\tplat->axi->axi_wr_osr_lmt = 31;\n\tplat->axi->axi_rd_osr_lmt = 31;\n\n\tplat->axi->axi_fb = false;\n\tplat->axi->axi_blen[0] = 4;\n\tplat->axi->axi_blen[1] = 8;\n\tplat->axi->axi_blen[2] = 16;\n\tplat->axi->axi_blen[3] = 32;\n\n\treturn 0;\n}\n\nstatic const struct stmmac_pci_info snps_gmac5_pci_info = {\n\t.setup = snps_gmac5_default_data,\n};\n\n \nstatic int stmmac_pci_probe(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *id)\n{\n\tstruct stmmac_pci_info *info = (struct stmmac_pci_info *)id->driver_data;\n\tstruct plat_stmmacenet_data *plat;\n\tstruct stmmac_resources res;\n\tint i;\n\tint ret;\n\n\tplat = devm_kzalloc(&pdev->dev, sizeof(*plat), GFP_KERNEL);\n\tif (!plat)\n\t\treturn -ENOMEM;\n\n\tplat->mdio_bus_data = devm_kzalloc(&pdev->dev,\n\t\t\t\t\t   sizeof(*plat->mdio_bus_data),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!plat->mdio_bus_data)\n\t\treturn -ENOMEM;\n\n\tplat->dma_cfg = devm_kzalloc(&pdev->dev, sizeof(*plat->dma_cfg),\n\t\t\t\t     GFP_KERNEL);\n\tif (!plat->dma_cfg)\n\t\treturn -ENOMEM;\n\n\tplat->safety_feat_cfg = devm_kzalloc(&pdev->dev,\n\t\t\t\t\t     sizeof(*plat->safety_feat_cfg),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!plat->safety_feat_cfg)\n\t\treturn -ENOMEM;\n\n\t \n\tret = pcim_enable_device(pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"%s: ERROR: failed to enable device\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < PCI_STD_NUM_BARS; i++) {\n\t\tif (pci_resource_len(pdev, i) == 0)\n\t\t\tcontinue;\n\t\tret = pcim_iomap_regions(pdev, BIT(i), pci_name(pdev));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\tpci_set_master(pdev);\n\n\tret = info->setup(pdev, plat);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(&res, 0, sizeof(res));\n\tres.addr = pcim_iomap_table(pdev)[i];\n\tres.wol_irq = pdev->irq;\n\tres.irq = pdev->irq;\n\n\tplat->safety_feat_cfg->tsoee = 1;\n\tplat->safety_feat_cfg->mrxpee = 1;\n\tplat->safety_feat_cfg->mestee = 1;\n\tplat->safety_feat_cfg->mrxee = 1;\n\tplat->safety_feat_cfg->mtxee = 1;\n\tplat->safety_feat_cfg->epsi = 1;\n\tplat->safety_feat_cfg->edpp = 1;\n\tplat->safety_feat_cfg->prtyen = 1;\n\tplat->safety_feat_cfg->tmouten = 1;\n\n\treturn stmmac_dvr_probe(&pdev->dev, plat, &res);\n}\n\n \nstatic void stmmac_pci_remove(struct pci_dev *pdev)\n{\n\tint i;\n\n\tstmmac_dvr_remove(&pdev->dev);\n\n\tfor (i = 0; i < PCI_STD_NUM_BARS; i++) {\n\t\tif (pci_resource_len(pdev, i) == 0)\n\t\t\tcontinue;\n\t\tpcim_iounmap_regions(pdev, BIT(i));\n\t\tbreak;\n\t}\n}\n\nstatic int __maybe_unused stmmac_pci_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tint ret;\n\n\tret = stmmac_suspend(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_save_state(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tpci_disable_device(pdev);\n\tpci_wake_from_d3(pdev, true);\n\treturn 0;\n}\n\nstatic int __maybe_unused stmmac_pci_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tint ret;\n\n\tpci_restore_state(pdev);\n\tpci_set_power_state(pdev, PCI_D0);\n\n\tret = pci_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tpci_set_master(pdev);\n\n\treturn stmmac_resume(dev);\n}\n\nstatic SIMPLE_DEV_PM_OPS(stmmac_pm_ops, stmmac_pci_suspend, stmmac_pci_resume);\n\n \n#define PCI_VENDOR_ID_STMMAC\t\t0x0700\n\n#define PCI_DEVICE_ID_STMMAC_STMMAC\t\t0x1108\n#define PCI_DEVICE_ID_SYNOPSYS_GMAC5_ID\t\t0x7102\n\nstatic const struct pci_device_id stmmac_id_table[] = {\n\t{ PCI_DEVICE_DATA(STMMAC, STMMAC, &stmmac_pci_info) },\n\t{ PCI_DEVICE_DATA(STMICRO, MAC, &stmmac_pci_info) },\n\t{ PCI_DEVICE_DATA(SYNOPSYS, GMAC5_ID, &snps_gmac5_pci_info) },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(pci, stmmac_id_table);\n\nstatic struct pci_driver stmmac_pci_driver = {\n\t.name = STMMAC_RESOURCE_NAME,\n\t.id_table = stmmac_id_table,\n\t.probe = stmmac_pci_probe,\n\t.remove = stmmac_pci_remove,\n\t.driver         = {\n\t\t.pm     = &stmmac_pm_ops,\n\t},\n};\n\nmodule_pci_driver(stmmac_pci_driver);\n\nMODULE_DESCRIPTION(\"STMMAC 10/100/1000 Ethernet PCI driver\");\nMODULE_AUTHOR(\"Rayagond Kokatanur <rayagond.kokatanur@vayavyalabs.com>\");\nMODULE_AUTHOR(\"Giuseppe Cavallaro <peppe.cavallaro@st.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}