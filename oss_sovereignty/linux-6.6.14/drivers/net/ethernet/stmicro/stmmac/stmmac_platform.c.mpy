{
  "module_name": "stmmac_platform.c",
  "hash_id": "d0961e8d1ffba39d87499d9a8123ddc0b0827003f2fe37259661965b4f74aad0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n#include <linux/of_mdio.h>\n\n#include \"stmmac.h\"\n#include \"stmmac_platform.h\"\n\n#ifdef CONFIG_OF\n\n \nstatic int dwmac1000_validate_mcast_bins(struct device *dev, int mcast_bins)\n{\n\tint x = mcast_bins;\n\n\tswitch (x) {\n\tcase HASH_TABLE_SIZE:\n\tcase 128:\n\tcase 256:\n\t\tbreak;\n\tdefault:\n\t\tx = 0;\n\t\tdev_info(dev, \"Hash table entries set to unexpected value %d\\n\",\n\t\t\t mcast_bins);\n\t\tbreak;\n\t}\n\treturn x;\n}\n\n \nstatic int dwmac1000_validate_ucast_entries(struct device *dev,\n\t\t\t\t\t    int ucast_entries)\n{\n\tint x = ucast_entries;\n\n\tswitch (x) {\n\tcase 1 ... 32:\n\tcase 64:\n\tcase 128:\n\t\tbreak;\n\tdefault:\n\t\tx = 1;\n\t\tdev_info(dev, \"Unicast table entries set to unexpected value %d\\n\",\n\t\t\t ucast_entries);\n\t\tbreak;\n\t}\n\treturn x;\n}\n\n \nstatic struct stmmac_axi *stmmac_axi_setup(struct platform_device *pdev)\n{\n\tstruct device_node *np;\n\tstruct stmmac_axi *axi;\n\n\tnp = of_parse_phandle(pdev->dev.of_node, \"snps,axi-config\", 0);\n\tif (!np)\n\t\treturn NULL;\n\n\taxi = devm_kzalloc(&pdev->dev, sizeof(*axi), GFP_KERNEL);\n\tif (!axi) {\n\t\tof_node_put(np);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\taxi->axi_lpi_en = of_property_read_bool(np, \"snps,lpi_en\");\n\taxi->axi_xit_frm = of_property_read_bool(np, \"snps,xit_frm\");\n\taxi->axi_kbbe = of_property_read_bool(np, \"snps,kbbe\");\n\taxi->axi_fb = of_property_read_bool(np, \"snps,fb\");\n\taxi->axi_mb = of_property_read_bool(np, \"snps,mb\");\n\taxi->axi_rb =  of_property_read_bool(np, \"snps,rb\");\n\n\tif (of_property_read_u32(np, \"snps,wr_osr_lmt\", &axi->axi_wr_osr_lmt))\n\t\taxi->axi_wr_osr_lmt = 1;\n\tif (of_property_read_u32(np, \"snps,rd_osr_lmt\", &axi->axi_rd_osr_lmt))\n\t\taxi->axi_rd_osr_lmt = 1;\n\tof_property_read_u32_array(np, \"snps,blen\", axi->axi_blen, AXI_BLEN);\n\tof_node_put(np);\n\n\treturn axi;\n}\n\n \nstatic int stmmac_mtl_setup(struct platform_device *pdev,\n\t\t\t    struct plat_stmmacenet_data *plat)\n{\n\tstruct device_node *q_node;\n\tstruct device_node *rx_node;\n\tstruct device_node *tx_node;\n\tu8 queue = 0;\n\tint ret = 0;\n\n\t \n\tplat->rx_queues_to_use = 1;\n\tplat->tx_queues_to_use = 1;\n\n\t \n\tplat->rx_queues_cfg[0].mode_to_use = MTL_QUEUE_DCB;\n\tplat->tx_queues_cfg[0].mode_to_use = MTL_QUEUE_DCB;\n\n\trx_node = of_parse_phandle(pdev->dev.of_node, \"snps,mtl-rx-config\", 0);\n\tif (!rx_node)\n\t\treturn ret;\n\n\ttx_node = of_parse_phandle(pdev->dev.of_node, \"snps,mtl-tx-config\", 0);\n\tif (!tx_node) {\n\t\tof_node_put(rx_node);\n\t\treturn ret;\n\t}\n\n\t \n\tif (of_property_read_u32(rx_node, \"snps,rx-queues-to-use\",\n\t\t\t\t &plat->rx_queues_to_use))\n\t\tplat->rx_queues_to_use = 1;\n\n\tif (of_property_read_bool(rx_node, \"snps,rx-sched-sp\"))\n\t\tplat->rx_sched_algorithm = MTL_RX_ALGORITHM_SP;\n\telse if (of_property_read_bool(rx_node, \"snps,rx-sched-wsp\"))\n\t\tplat->rx_sched_algorithm = MTL_RX_ALGORITHM_WSP;\n\telse\n\t\tplat->rx_sched_algorithm = MTL_RX_ALGORITHM_SP;\n\n\t \n\tfor_each_child_of_node(rx_node, q_node) {\n\t\tif (queue >= plat->rx_queues_to_use)\n\t\t\tbreak;\n\n\t\tif (of_property_read_bool(q_node, \"snps,dcb-algorithm\"))\n\t\t\tplat->rx_queues_cfg[queue].mode_to_use = MTL_QUEUE_DCB;\n\t\telse if (of_property_read_bool(q_node, \"snps,avb-algorithm\"))\n\t\t\tplat->rx_queues_cfg[queue].mode_to_use = MTL_QUEUE_AVB;\n\t\telse\n\t\t\tplat->rx_queues_cfg[queue].mode_to_use = MTL_QUEUE_DCB;\n\n\t\tif (of_property_read_u32(q_node, \"snps,map-to-dma-channel\",\n\t\t\t\t\t &plat->rx_queues_cfg[queue].chan))\n\t\t\tplat->rx_queues_cfg[queue].chan = queue;\n\t\t \n\n\t\tif (of_property_read_u32(q_node, \"snps,priority\",\n\t\t\t\t\t&plat->rx_queues_cfg[queue].prio)) {\n\t\t\tplat->rx_queues_cfg[queue].prio = 0;\n\t\t\tplat->rx_queues_cfg[queue].use_prio = false;\n\t\t} else {\n\t\t\tplat->rx_queues_cfg[queue].use_prio = true;\n\t\t}\n\n\t\t \n\t\tif (of_property_read_bool(q_node, \"snps,route-avcp\"))\n\t\t\tplat->rx_queues_cfg[queue].pkt_route = PACKET_AVCPQ;\n\t\telse if (of_property_read_bool(q_node, \"snps,route-ptp\"))\n\t\t\tplat->rx_queues_cfg[queue].pkt_route = PACKET_PTPQ;\n\t\telse if (of_property_read_bool(q_node, \"snps,route-dcbcp\"))\n\t\t\tplat->rx_queues_cfg[queue].pkt_route = PACKET_DCBCPQ;\n\t\telse if (of_property_read_bool(q_node, \"snps,route-up\"))\n\t\t\tplat->rx_queues_cfg[queue].pkt_route = PACKET_UPQ;\n\t\telse if (of_property_read_bool(q_node, \"snps,route-multi-broad\"))\n\t\t\tplat->rx_queues_cfg[queue].pkt_route = PACKET_MCBCQ;\n\t\telse\n\t\t\tplat->rx_queues_cfg[queue].pkt_route = 0x0;\n\n\t\tqueue++;\n\t}\n\tif (queue != plat->rx_queues_to_use) {\n\t\tret = -EINVAL;\n\t\tdev_err(&pdev->dev, \"Not all RX queues were configured\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (of_property_read_u32(tx_node, \"snps,tx-queues-to-use\",\n\t\t\t\t &plat->tx_queues_to_use))\n\t\tplat->tx_queues_to_use = 1;\n\n\tif (of_property_read_bool(tx_node, \"snps,tx-sched-wrr\"))\n\t\tplat->tx_sched_algorithm = MTL_TX_ALGORITHM_WRR;\n\telse if (of_property_read_bool(tx_node, \"snps,tx-sched-wfq\"))\n\t\tplat->tx_sched_algorithm = MTL_TX_ALGORITHM_WFQ;\n\telse if (of_property_read_bool(tx_node, \"snps,tx-sched-dwrr\"))\n\t\tplat->tx_sched_algorithm = MTL_TX_ALGORITHM_DWRR;\n\telse\n\t\tplat->tx_sched_algorithm = MTL_TX_ALGORITHM_SP;\n\n\tqueue = 0;\n\n\t \n\tfor_each_child_of_node(tx_node, q_node) {\n\t\tif (queue >= plat->tx_queues_to_use)\n\t\t\tbreak;\n\n\t\tif (of_property_read_u32(q_node, \"snps,weight\",\n\t\t\t\t\t &plat->tx_queues_cfg[queue].weight))\n\t\t\tplat->tx_queues_cfg[queue].weight = 0x10 + queue;\n\n\t\tif (of_property_read_bool(q_node, \"snps,dcb-algorithm\")) {\n\t\t\tplat->tx_queues_cfg[queue].mode_to_use = MTL_QUEUE_DCB;\n\t\t} else if (of_property_read_bool(q_node,\n\t\t\t\t\t\t \"snps,avb-algorithm\")) {\n\t\t\tplat->tx_queues_cfg[queue].mode_to_use = MTL_QUEUE_AVB;\n\n\t\t\t \n\t\t\tif (of_property_read_u32(q_node, \"snps,send_slope\",\n\t\t\t\t&plat->tx_queues_cfg[queue].send_slope))\n\t\t\t\tplat->tx_queues_cfg[queue].send_slope = 0x0;\n\t\t\tif (of_property_read_u32(q_node, \"snps,idle_slope\",\n\t\t\t\t&plat->tx_queues_cfg[queue].idle_slope))\n\t\t\t\tplat->tx_queues_cfg[queue].idle_slope = 0x0;\n\t\t\tif (of_property_read_u32(q_node, \"snps,high_credit\",\n\t\t\t\t&plat->tx_queues_cfg[queue].high_credit))\n\t\t\t\tplat->tx_queues_cfg[queue].high_credit = 0x0;\n\t\t\tif (of_property_read_u32(q_node, \"snps,low_credit\",\n\t\t\t\t&plat->tx_queues_cfg[queue].low_credit))\n\t\t\t\tplat->tx_queues_cfg[queue].low_credit = 0x0;\n\t\t} else {\n\t\t\tplat->tx_queues_cfg[queue].mode_to_use = MTL_QUEUE_DCB;\n\t\t}\n\n\t\tif (of_property_read_u32(q_node, \"snps,priority\",\n\t\t\t\t\t&plat->tx_queues_cfg[queue].prio)) {\n\t\t\tplat->tx_queues_cfg[queue].prio = 0;\n\t\t\tplat->tx_queues_cfg[queue].use_prio = false;\n\t\t} else {\n\t\t\tplat->tx_queues_cfg[queue].use_prio = true;\n\t\t}\n\n\t\tqueue++;\n\t}\n\tif (queue != plat->tx_queues_to_use) {\n\t\tret = -EINVAL;\n\t\tdev_err(&pdev->dev, \"Not all TX queues were configured\\n\");\n\t\tgoto out;\n\t}\n\nout:\n\tof_node_put(rx_node);\n\tof_node_put(tx_node);\n\tof_node_put(q_node);\n\n\treturn ret;\n}\n\n \nstatic int stmmac_dt_phy(struct plat_stmmacenet_data *plat,\n\t\t\t struct device_node *np, struct device *dev)\n{\n\tbool mdio = !of_phy_is_fixed_link(np);\n\tstatic const struct of_device_id need_mdio_ids[] = {\n\t\t{ .compatible = \"snps,dwc-qos-ethernet-4.10\" },\n\t\t{},\n\t};\n\n\tif (of_match_node(need_mdio_ids, np)) {\n\t\tplat->mdio_node = of_get_child_by_name(np, \"mdio\");\n\t} else {\n\t\t \n\t\tfor_each_child_of_node(np, plat->mdio_node) {\n\t\t\tif (of_device_is_compatible(plat->mdio_node,\n\t\t\t\t\t\t    \"snps,dwmac-mdio\"))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (plat->mdio_node) {\n\t\tdev_dbg(dev, \"Found MDIO subnode\\n\");\n\t\tmdio = true;\n\t}\n\n\tif (mdio) {\n\t\tplat->mdio_bus_data =\n\t\t\tdevm_kzalloc(dev, sizeof(struct stmmac_mdio_bus_data),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!plat->mdio_bus_data)\n\t\t\treturn -ENOMEM;\n\n\t\tplat->mdio_bus_data->needs_reset = true;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int stmmac_of_get_mac_mode(struct device_node *np)\n{\n\tconst char *pm;\n\tint err, i;\n\n\terr = of_property_read_string(np, \"mac-mode\", &pm);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < PHY_INTERFACE_MODE_MAX; i++) {\n\t\tif (!strcasecmp(pm, phy_modes(i)))\n\t\t\treturn i;\n\t}\n\n\treturn -ENODEV;\n}\n\n \nstruct plat_stmmacenet_data *\nstmmac_probe_config_dt(struct platform_device *pdev, u8 *mac)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct plat_stmmacenet_data *plat;\n\tstruct stmmac_dma_cfg *dma_cfg;\n\tint phy_mode;\n\tvoid *ret;\n\tint rc;\n\n\tplat = devm_kzalloc(&pdev->dev, sizeof(*plat), GFP_KERNEL);\n\tif (!plat)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trc = of_get_mac_address(np, mac);\n\tif (rc) {\n\t\tif (rc == -EPROBE_DEFER)\n\t\t\treturn ERR_PTR(rc);\n\n\t\teth_zero_addr(mac);\n\t}\n\n\tphy_mode = device_get_phy_mode(&pdev->dev);\n\tif (phy_mode < 0)\n\t\treturn ERR_PTR(phy_mode);\n\n\tplat->phy_interface = phy_mode;\n\trc = stmmac_of_get_mac_mode(np);\n\tplat->mac_interface = rc < 0 ? plat->phy_interface : rc;\n\n\t \n\tplat->phy_node = of_parse_phandle(np, \"phy-handle\", 0);\n\n\t \n\tplat->port_node = of_fwnode_handle(np);\n\n\t \n\tof_property_read_u32(np, \"max-speed\", &plat->max_speed);\n\n\tplat->bus_id = of_alias_get_id(np, \"ethernet\");\n\tif (plat->bus_id < 0)\n\t\tplat->bus_id = 0;\n\n\t \n\tplat->phy_addr = -1;\n\n\t \n\tplat->clk_csr = -1;\n\tif (of_property_read_u32(np, \"snps,clk-csr\", &plat->clk_csr))\n\t\tof_property_read_u32(np, \"clk_csr\", &plat->clk_csr);\n\n\t \n\tif (of_property_read_u32(np, \"snps,phy-addr\", &plat->phy_addr) == 0)\n\t\tdev_warn(&pdev->dev, \"snps,phy-addr property is deprecated\\n\");\n\n\t \n\trc = stmmac_dt_phy(plat, np, &pdev->dev);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\n\tof_property_read_u32(np, \"tx-fifo-depth\", &plat->tx_fifo_size);\n\n\tof_property_read_u32(np, \"rx-fifo-depth\", &plat->rx_fifo_size);\n\n\tplat->force_sf_dma_mode =\n\t\tof_property_read_bool(np, \"snps,force_sf_dma_mode\");\n\n\tif (of_property_read_bool(np, \"snps,en-tx-lpi-clockgating\"))\n\t\tplat->flags |= STMMAC_FLAG_EN_TX_LPI_CLOCKGATING;\n\n\t \n\tplat->maxmtu = JUMBO_LEN;\n\n\t \n\tplat->multicast_filter_bins = HASH_TABLE_SIZE;\n\n\t \n\tplat->unicast_filter_entries = 1;\n\n\t \n\tif (of_device_is_compatible(np, \"st,spear600-gmac\") ||\n\t\tof_device_is_compatible(np, \"snps,dwmac-3.50a\") ||\n\t\tof_device_is_compatible(np, \"snps,dwmac-3.70a\") ||\n\t\tof_device_is_compatible(np, \"snps,dwmac\")) {\n\t\t \n\t\tof_property_read_u32(np, \"max-frame-size\", &plat->maxmtu);\n\t\tof_property_read_u32(np, \"snps,multicast-filter-bins\",\n\t\t\t\t     &plat->multicast_filter_bins);\n\t\tof_property_read_u32(np, \"snps,perfect-filter-entries\",\n\t\t\t\t     &plat->unicast_filter_entries);\n\t\tplat->unicast_filter_entries = dwmac1000_validate_ucast_entries(\n\t\t\t\t&pdev->dev, plat->unicast_filter_entries);\n\t\tplat->multicast_filter_bins = dwmac1000_validate_mcast_bins(\n\t\t\t\t&pdev->dev, plat->multicast_filter_bins);\n\t\tplat->has_gmac = 1;\n\t\tplat->pmt = 1;\n\t}\n\n\tif (of_device_is_compatible(np, \"snps,dwmac-3.40a\")) {\n\t\tplat->has_gmac = 1;\n\t\tplat->enh_desc = 1;\n\t\tplat->tx_coe = 1;\n\t\tplat->bugged_jumbo = 1;\n\t\tplat->pmt = 1;\n\t}\n\n\tif (of_device_is_compatible(np, \"snps,dwmac-4.00\") ||\n\t    of_device_is_compatible(np, \"snps,dwmac-4.10a\") ||\n\t    of_device_is_compatible(np, \"snps,dwmac-4.20a\") ||\n\t    of_device_is_compatible(np, \"snps,dwmac-5.10a\") ||\n\t    of_device_is_compatible(np, \"snps,dwmac-5.20\")) {\n\t\tplat->has_gmac4 = 1;\n\t\tplat->has_gmac = 0;\n\t\tplat->pmt = 1;\n\t\tif (of_property_read_bool(np, \"snps,tso\"))\n\t\t\tplat->flags |= STMMAC_FLAG_TSO_EN;\n\t}\n\n\tif (of_device_is_compatible(np, \"snps,dwmac-3.610\") ||\n\t\tof_device_is_compatible(np, \"snps,dwmac-3.710\")) {\n\t\tplat->enh_desc = 1;\n\t\tplat->bugged_jumbo = 1;\n\t\tplat->force_sf_dma_mode = 1;\n\t}\n\n\tif (of_device_is_compatible(np, \"snps,dwxgmac\")) {\n\t\tplat->has_xgmac = 1;\n\t\tplat->pmt = 1;\n\t\tif (of_property_read_bool(np, \"snps,tso\"))\n\t\t\tplat->flags |= STMMAC_FLAG_TSO_EN;\n\t}\n\n\tdma_cfg = devm_kzalloc(&pdev->dev, sizeof(*dma_cfg),\n\t\t\t       GFP_KERNEL);\n\tif (!dma_cfg) {\n\t\tstmmac_remove_config_dt(pdev, plat);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tplat->dma_cfg = dma_cfg;\n\n\tof_property_read_u32(np, \"snps,pbl\", &dma_cfg->pbl);\n\tif (!dma_cfg->pbl)\n\t\tdma_cfg->pbl = DEFAULT_DMA_PBL;\n\tof_property_read_u32(np, \"snps,txpbl\", &dma_cfg->txpbl);\n\tof_property_read_u32(np, \"snps,rxpbl\", &dma_cfg->rxpbl);\n\tdma_cfg->pblx8 = !of_property_read_bool(np, \"snps,no-pbl-x8\");\n\n\tdma_cfg->aal = of_property_read_bool(np, \"snps,aal\");\n\tdma_cfg->fixed_burst = of_property_read_bool(np, \"snps,fixed-burst\");\n\tdma_cfg->mixed_burst = of_property_read_bool(np, \"snps,mixed-burst\");\n\n\tplat->force_thresh_dma_mode = of_property_read_bool(np, \"snps,force_thresh_dma_mode\");\n\tif (plat->force_thresh_dma_mode && plat->force_sf_dma_mode) {\n\t\tplat->force_sf_dma_mode = 0;\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"force_sf_dma_mode is ignored if force_thresh_dma_mode is set.\\n\");\n\t}\n\n\tof_property_read_u32(np, \"snps,ps-speed\", &plat->mac_port_sel_speed);\n\n\tplat->axi = stmmac_axi_setup(pdev);\n\n\trc = stmmac_mtl_setup(pdev, plat);\n\tif (rc) {\n\t\tstmmac_remove_config_dt(pdev, plat);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\t \n\tif (!of_device_is_compatible(np, \"snps,dwc-qos-ethernet-4.10\")) {\n\t\tplat->stmmac_clk = devm_clk_get(&pdev->dev,\n\t\t\t\t\t\tSTMMAC_RESOURCE_NAME);\n\t\tif (IS_ERR(plat->stmmac_clk)) {\n\t\t\tdev_warn(&pdev->dev, \"Cannot get CSR clock\\n\");\n\t\t\tplat->stmmac_clk = NULL;\n\t\t}\n\t\tclk_prepare_enable(plat->stmmac_clk);\n\t}\n\n\tplat->pclk = devm_clk_get_optional(&pdev->dev, \"pclk\");\n\tif (IS_ERR(plat->pclk)) {\n\t\tret = plat->pclk;\n\t\tgoto error_pclk_get;\n\t}\n\tclk_prepare_enable(plat->pclk);\n\n\t \n\tplat->clk_ptp_ref = devm_clk_get(&pdev->dev, \"ptp_ref\");\n\tif (IS_ERR(plat->clk_ptp_ref)) {\n\t\tplat->clk_ptp_rate = clk_get_rate(plat->stmmac_clk);\n\t\tplat->clk_ptp_ref = NULL;\n\t\tdev_info(&pdev->dev, \"PTP uses main clock\\n\");\n\t} else {\n\t\tplat->clk_ptp_rate = clk_get_rate(plat->clk_ptp_ref);\n\t\tdev_dbg(&pdev->dev, \"PTP rate %d\\n\", plat->clk_ptp_rate);\n\t}\n\n\tplat->stmmac_rst = devm_reset_control_get_optional(&pdev->dev,\n\t\t\t\t\t\t\t   STMMAC_RESOURCE_NAME);\n\tif (IS_ERR(plat->stmmac_rst)) {\n\t\tret = plat->stmmac_rst;\n\t\tgoto error_hw_init;\n\t}\n\n\tplat->stmmac_ahb_rst = devm_reset_control_get_optional_shared(\n\t\t\t\t\t\t\t&pdev->dev, \"ahb\");\n\tif (IS_ERR(plat->stmmac_ahb_rst)) {\n\t\tret = plat->stmmac_ahb_rst;\n\t\tgoto error_hw_init;\n\t}\n\n\treturn plat;\n\nerror_hw_init:\n\tclk_disable_unprepare(plat->pclk);\nerror_pclk_get:\n\tclk_disable_unprepare(plat->stmmac_clk);\n\n\treturn ret;\n}\n\nstatic void devm_stmmac_remove_config_dt(void *data)\n{\n\tstruct plat_stmmacenet_data *plat = data;\n\n\t \n\tstmmac_remove_config_dt(NULL, plat);\n}\n\n \nstruct plat_stmmacenet_data *\ndevm_stmmac_probe_config_dt(struct platform_device *pdev, u8 *mac)\n{\n\tstruct plat_stmmacenet_data *plat;\n\tint ret;\n\n\tplat = stmmac_probe_config_dt(pdev, mac);\n\tif (IS_ERR(plat))\n\t\treturn plat;\n\n\tret = devm_add_action_or_reset(&pdev->dev,\n\t\t\t\t       devm_stmmac_remove_config_dt, plat);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn plat;\n}\n\n \nvoid stmmac_remove_config_dt(struct platform_device *pdev,\n\t\t\t     struct plat_stmmacenet_data *plat)\n{\n\tclk_disable_unprepare(plat->stmmac_clk);\n\tclk_disable_unprepare(plat->pclk);\n\tof_node_put(plat->phy_node);\n\tof_node_put(plat->mdio_node);\n}\n#else\nstruct plat_stmmacenet_data *\nstmmac_probe_config_dt(struct platform_device *pdev, u8 *mac)\n{\n\treturn ERR_PTR(-EINVAL);\n}\n\nstruct plat_stmmacenet_data *\ndevm_stmmac_probe_config_dt(struct platform_device *pdev, u8 *mac)\n{\n\treturn ERR_PTR(-EINVAL);\n}\n\nvoid stmmac_remove_config_dt(struct platform_device *pdev,\n\t\t\t     struct plat_stmmacenet_data *plat)\n{\n}\n#endif  \nEXPORT_SYMBOL_GPL(stmmac_probe_config_dt);\nEXPORT_SYMBOL_GPL(devm_stmmac_probe_config_dt);\nEXPORT_SYMBOL_GPL(stmmac_remove_config_dt);\n\nint stmmac_get_platform_resources(struct platform_device *pdev,\n\t\t\t\t  struct stmmac_resources *stmmac_res)\n{\n\tmemset(stmmac_res, 0, sizeof(*stmmac_res));\n\n\t \n\tstmmac_res->irq = platform_get_irq_byname(pdev, \"macirq\");\n\tif (stmmac_res->irq < 0)\n\t\treturn stmmac_res->irq;\n\n\t \n\tstmmac_res->wol_irq =\n\t\tplatform_get_irq_byname_optional(pdev, \"eth_wake_irq\");\n\tif (stmmac_res->wol_irq < 0) {\n\t\tif (stmmac_res->wol_irq == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tdev_info(&pdev->dev, \"IRQ eth_wake_irq not found\\n\");\n\t\tstmmac_res->wol_irq = stmmac_res->irq;\n\t}\n\n\tstmmac_res->lpi_irq =\n\t\tplatform_get_irq_byname_optional(pdev, \"eth_lpi\");\n\tif (stmmac_res->lpi_irq < 0) {\n\t\tif (stmmac_res->lpi_irq == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tdev_info(&pdev->dev, \"IRQ eth_lpi not found\\n\");\n\t}\n\n\tstmmac_res->addr = devm_platform_ioremap_resource(pdev, 0);\n\n\treturn PTR_ERR_OR_ZERO(stmmac_res->addr);\n}\nEXPORT_SYMBOL_GPL(stmmac_get_platform_resources);\n\n \nint stmmac_pltfr_init(struct platform_device *pdev,\n\t\t      struct plat_stmmacenet_data *plat)\n{\n\tint ret = 0;\n\n\tif (plat->init)\n\t\tret = plat->init(pdev, plat->bsp_priv);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(stmmac_pltfr_init);\n\n \nvoid stmmac_pltfr_exit(struct platform_device *pdev,\n\t\t       struct plat_stmmacenet_data *plat)\n{\n\tif (plat->exit)\n\t\tplat->exit(pdev, plat->bsp_priv);\n}\nEXPORT_SYMBOL_GPL(stmmac_pltfr_exit);\n\n \nint stmmac_pltfr_probe(struct platform_device *pdev,\n\t\t       struct plat_stmmacenet_data *plat,\n\t\t       struct stmmac_resources *res)\n{\n\tint ret;\n\n\tret = stmmac_pltfr_init(pdev, plat);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stmmac_dvr_probe(&pdev->dev, plat, res);\n\tif (ret) {\n\t\tstmmac_pltfr_exit(pdev, plat);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(stmmac_pltfr_probe);\n\nstatic void devm_stmmac_pltfr_remove(void *data)\n{\n\tstruct platform_device *pdev = data;\n\n\tstmmac_pltfr_remove_no_dt(pdev);\n}\n\n \nint devm_stmmac_pltfr_probe(struct platform_device *pdev,\n\t\t\t    struct plat_stmmacenet_data *plat,\n\t\t\t    struct stmmac_resources *res)\n{\n\tint ret;\n\n\tret = stmmac_pltfr_probe(pdev, plat, res);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(&pdev->dev, devm_stmmac_pltfr_remove,\n\t\t\t\t\tpdev);\n}\nEXPORT_SYMBOL_GPL(devm_stmmac_pltfr_probe);\n\n \nvoid stmmac_pltfr_remove_no_dt(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\tstruct plat_stmmacenet_data *plat = priv->plat;\n\n\tstmmac_dvr_remove(&pdev->dev);\n\tstmmac_pltfr_exit(pdev, plat);\n}\nEXPORT_SYMBOL_GPL(stmmac_pltfr_remove_no_dt);\n\n \nvoid stmmac_pltfr_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\tstruct plat_stmmacenet_data *plat = priv->plat;\n\n\tstmmac_pltfr_remove_no_dt(pdev);\n\tstmmac_remove_config_dt(pdev, plat);\n}\nEXPORT_SYMBOL_GPL(stmmac_pltfr_remove);\n\n \nstatic int __maybe_unused stmmac_pltfr_suspend(struct device *dev)\n{\n\tint ret;\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\tret = stmmac_suspend(dev);\n\tstmmac_pltfr_exit(pdev, priv->plat);\n\n\treturn ret;\n}\n\n \nstatic int __maybe_unused stmmac_pltfr_resume(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint ret;\n\n\tret = stmmac_pltfr_init(pdev, priv->plat);\n\tif (ret)\n\t\treturn ret;\n\n\treturn stmmac_resume(dev);\n}\n\nstatic int __maybe_unused stmmac_runtime_suspend(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\n\tstmmac_bus_clks_config(priv, false);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused stmmac_runtime_resume(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\n\treturn stmmac_bus_clks_config(priv, true);\n}\n\nstatic int __maybe_unused stmmac_pltfr_noirq_suspend(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\tint ret;\n\n\tif (!netif_running(ndev))\n\t\treturn 0;\n\n\tif (!device_may_wakeup(priv->device) || !priv->plat->pmt) {\n\t\t \n\t\tclk_disable_unprepare(priv->plat->clk_ptp_ref);\n\n\t\tret = pm_runtime_force_suspend(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused stmmac_pltfr_noirq_resume(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\tint ret;\n\n\tif (!netif_running(ndev))\n\t\treturn 0;\n\n\tif (!device_may_wakeup(priv->device) || !priv->plat->pmt) {\n\t\t \n\t\tret = pm_runtime_force_resume(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = clk_prepare_enable(priv->plat->clk_ptp_ref);\n\t\tif (ret < 0) {\n\t\t\tnetdev_warn(priv->dev,\n\t\t\t\t    \"failed to enable PTP reference clock: %pe\\n\",\n\t\t\t\t    ERR_PTR(ret));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nconst struct dev_pm_ops stmmac_pltfr_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(stmmac_pltfr_suspend, stmmac_pltfr_resume)\n\tSET_RUNTIME_PM_OPS(stmmac_runtime_suspend, stmmac_runtime_resume, NULL)\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(stmmac_pltfr_noirq_suspend, stmmac_pltfr_noirq_resume)\n};\nEXPORT_SYMBOL_GPL(stmmac_pltfr_pm_ops);\n\nMODULE_DESCRIPTION(\"STMMAC 10/100/1000 Ethernet platform support\");\nMODULE_AUTHOR(\"Giuseppe Cavallaro <peppe.cavallaro@st.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}