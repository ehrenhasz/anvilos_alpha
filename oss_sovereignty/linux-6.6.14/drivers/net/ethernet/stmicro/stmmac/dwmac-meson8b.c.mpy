{
  "module_name": "dwmac-meson8b.c",
  "hash_id": "102c0a2bd03db074c2bace3a2beaaf7ff16aae65830bc39e25641497b873d01b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwmac-meson8b.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/device.h>\n#include <linux/ethtool.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n#include <linux/mfd/syscon.h>\n#include <linux/platform_device.h>\n#include <linux/stmmac.h>\n\n#include \"stmmac_platform.h\"\n\n#define PRG_ETH0\t\t\t0x0\n\n#define PRG_ETH0_RGMII_MODE\t\tBIT(0)\n\n#define PRG_ETH0_EXT_PHY_MODE_MASK\tGENMASK(2, 0)\n#define PRG_ETH0_EXT_RGMII_MODE\t\t1\n#define PRG_ETH0_EXT_RMII_MODE\t\t4\n\n \n#define PRG_ETH0_CLK_M250_SEL_MASK\tGENMASK(4, 4)\n\n \n#define PRG_ETH0_TXDLY_MASK\t\tGENMASK(6, 5)\n\n \n#define PRG_ETH0_CLK_M250_DIV_SHIFT\t7\n#define PRG_ETH0_CLK_M250_DIV_WIDTH\t3\n\n#define PRG_ETH0_RGMII_TX_CLK_EN\t10\n\n#define PRG_ETH0_INVERTED_RMII_CLK\tBIT(11)\n#define PRG_ETH0_TX_AND_PHY_REF_CLK\tBIT(12)\n\n \n#define PRG_ETH0_ADJ_ENABLE\t\tBIT(13)\n \n#define PRG_ETH0_ADJ_SETUP\t\tBIT(14)\n \n#define PRG_ETH0_ADJ_DELAY\t\tGENMASK(19, 15)\n \n#define PRG_ETH0_ADJ_SKEW\t\tGENMASK(24, 20)\n\n#define PRG_ETH1\t\t\t0x4\n\n \n#define PRG_ETH1_CFG_RXCLK_DLY\t\tGENMASK(19, 16)\n\nstruct meson8b_dwmac;\n\nstruct meson8b_dwmac_data {\n\tint (*set_phy_mode)(struct meson8b_dwmac *dwmac);\n\tbool has_prg_eth1_rgmii_rx_delay;\n};\n\nstruct meson8b_dwmac {\n\tstruct device\t\t\t*dev;\n\tvoid __iomem\t\t\t*regs;\n\n\tconst struct meson8b_dwmac_data\t*data;\n\tphy_interface_t\t\t\tphy_mode;\n\tstruct clk\t\t\t*rgmii_tx_clk;\n\tu32\t\t\t\ttx_delay_ns;\n\tu32\t\t\t\trx_delay_ps;\n\tstruct clk\t\t\t*timing_adj_clk;\n};\n\nstruct meson8b_dwmac_clk_configs {\n\tstruct clk_mux\t\tm250_mux;\n\tstruct clk_divider\tm250_div;\n\tstruct clk_fixed_factor\tfixed_div2;\n\tstruct clk_gate\t\trgmii_tx_en;\n};\n\nstatic void meson8b_dwmac_mask_bits(struct meson8b_dwmac *dwmac, u32 reg,\n\t\t\t\t    u32 mask, u32 value)\n{\n\tu32 data;\n\n\tdata = readl(dwmac->regs + reg);\n\tdata &= ~mask;\n\tdata |= (value & mask);\n\n\twritel(data, dwmac->regs + reg);\n}\n\nstatic struct clk *meson8b_dwmac_register_clk(struct meson8b_dwmac *dwmac,\n\t\t\t\t\t      const char *name_suffix,\n\t\t\t\t\t      const struct clk_parent_data *parents,\n\t\t\t\t\t      int num_parents,\n\t\t\t\t\t      const struct clk_ops *ops,\n\t\t\t\t\t      struct clk_hw *hw)\n{\n\tstruct clk_init_data init = { };\n\tchar clk_name[32];\n\n\tsnprintf(clk_name, sizeof(clk_name), \"%s#%s\", dev_name(dwmac->dev),\n\t\t name_suffix);\n\n\tinit.name = clk_name;\n\tinit.ops = ops;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\tinit.parent_data = parents;\n\tinit.num_parents = num_parents;\n\n\thw->init = &init;\n\n\treturn devm_clk_register(dwmac->dev, hw);\n}\n\nstatic int meson8b_init_rgmii_tx_clk(struct meson8b_dwmac *dwmac)\n{\n\tstruct clk *clk;\n\tstruct device *dev = dwmac->dev;\n\tstatic const struct clk_parent_data mux_parents[] = {\n\t\t{ .fw_name = \"clkin0\", },\n\t\t{ .index = -1, },\n\t};\n\tstatic const struct clk_div_table div_table[] = {\n\t\t{ .div = 2, .val = 2, },\n\t\t{ .div = 3, .val = 3, },\n\t\t{ .div = 4, .val = 4, },\n\t\t{ .div = 5, .val = 5, },\n\t\t{ .div = 6, .val = 6, },\n\t\t{ .div = 7, .val = 7, },\n\t\t{   }\n\t};\n\tstruct meson8b_dwmac_clk_configs *clk_configs;\n\tstruct clk_parent_data parent_data = { };\n\n\tclk_configs = devm_kzalloc(dev, sizeof(*clk_configs), GFP_KERNEL);\n\tif (!clk_configs)\n\t\treturn -ENOMEM;\n\n\tclk_configs->m250_mux.reg = dwmac->regs + PRG_ETH0;\n\tclk_configs->m250_mux.shift = __ffs(PRG_ETH0_CLK_M250_SEL_MASK);\n\tclk_configs->m250_mux.mask = PRG_ETH0_CLK_M250_SEL_MASK >>\n\t\t\t\t     clk_configs->m250_mux.shift;\n\tclk = meson8b_dwmac_register_clk(dwmac, \"m250_sel\", mux_parents,\n\t\t\t\t\t ARRAY_SIZE(mux_parents), &clk_mux_ops,\n\t\t\t\t\t &clk_configs->m250_mux.hw);\n\tif (WARN_ON(IS_ERR(clk)))\n\t\treturn PTR_ERR(clk);\n\n\tparent_data.hw = &clk_configs->m250_mux.hw;\n\tclk_configs->m250_div.reg = dwmac->regs + PRG_ETH0;\n\tclk_configs->m250_div.shift = PRG_ETH0_CLK_M250_DIV_SHIFT;\n\tclk_configs->m250_div.width = PRG_ETH0_CLK_M250_DIV_WIDTH;\n\tclk_configs->m250_div.table = div_table;\n\tclk_configs->m250_div.flags = CLK_DIVIDER_ALLOW_ZERO |\n\t\t\t\t      CLK_DIVIDER_ROUND_CLOSEST;\n\tclk = meson8b_dwmac_register_clk(dwmac, \"m250_div\", &parent_data, 1,\n\t\t\t\t\t &clk_divider_ops,\n\t\t\t\t\t &clk_configs->m250_div.hw);\n\tif (WARN_ON(IS_ERR(clk)))\n\t\treturn PTR_ERR(clk);\n\n\tparent_data.hw = &clk_configs->m250_div.hw;\n\tclk_configs->fixed_div2.mult = 1;\n\tclk_configs->fixed_div2.div = 2;\n\tclk = meson8b_dwmac_register_clk(dwmac, \"fixed_div2\", &parent_data, 1,\n\t\t\t\t\t &clk_fixed_factor_ops,\n\t\t\t\t\t &clk_configs->fixed_div2.hw);\n\tif (WARN_ON(IS_ERR(clk)))\n\t\treturn PTR_ERR(clk);\n\n\tparent_data.hw = &clk_configs->fixed_div2.hw;\n\tclk_configs->rgmii_tx_en.reg = dwmac->regs + PRG_ETH0;\n\tclk_configs->rgmii_tx_en.bit_idx = PRG_ETH0_RGMII_TX_CLK_EN;\n\tclk = meson8b_dwmac_register_clk(dwmac, \"rgmii_tx_en\", &parent_data, 1,\n\t\t\t\t\t &clk_gate_ops,\n\t\t\t\t\t &clk_configs->rgmii_tx_en.hw);\n\tif (WARN_ON(IS_ERR(clk)))\n\t\treturn PTR_ERR(clk);\n\n\tdwmac->rgmii_tx_clk = clk;\n\n\treturn 0;\n}\n\nstatic int meson8b_set_phy_mode(struct meson8b_dwmac *dwmac)\n{\n\tswitch (dwmac->phy_mode) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\t \n\t\tmeson8b_dwmac_mask_bits(dwmac, PRG_ETH0,\n\t\t\t\t\tPRG_ETH0_RGMII_MODE,\n\t\t\t\t\tPRG_ETH0_RGMII_MODE);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\t \n\t\tmeson8b_dwmac_mask_bits(dwmac, PRG_ETH0,\n\t\t\t\t\tPRG_ETH0_RGMII_MODE, 0);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dwmac->dev, \"fail to set phy-mode %s\\n\",\n\t\t\tphy_modes(dwmac->phy_mode));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int meson_axg_set_phy_mode(struct meson8b_dwmac *dwmac)\n{\n\tswitch (dwmac->phy_mode) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\t \n\t\tmeson8b_dwmac_mask_bits(dwmac, PRG_ETH0,\n\t\t\t\t\tPRG_ETH0_EXT_PHY_MODE_MASK,\n\t\t\t\t\tPRG_ETH0_EXT_RGMII_MODE);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\t \n\t\tmeson8b_dwmac_mask_bits(dwmac, PRG_ETH0,\n\t\t\t\t\tPRG_ETH0_EXT_PHY_MODE_MASK,\n\t\t\t\t\tPRG_ETH0_EXT_RMII_MODE);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dwmac->dev, \"fail to set phy-mode %s\\n\",\n\t\t\tphy_modes(dwmac->phy_mode));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void meson8b_clk_disable_unprepare(void *data)\n{\n\tclk_disable_unprepare(data);\n}\n\nstatic int meson8b_devm_clk_prepare_enable(struct meson8b_dwmac *dwmac,\n\t\t\t\t\t   struct clk *clk)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(clk);\n\tif (ret)\n\t\treturn ret;\n\n\treturn devm_add_action_or_reset(dwmac->dev,\n\t\t\t\t\tmeson8b_clk_disable_unprepare, clk);\n}\n\nstatic int meson8b_init_rgmii_delays(struct meson8b_dwmac *dwmac)\n{\n\tu32 tx_dly_config, rx_adj_config, cfg_rxclk_dly, delay_config;\n\tint ret;\n\n\trx_adj_config = 0;\n\tcfg_rxclk_dly = 0;\n\ttx_dly_config = FIELD_PREP(PRG_ETH0_TXDLY_MASK,\n\t\t\t\t   dwmac->tx_delay_ns >> 1);\n\n\tif (dwmac->data->has_prg_eth1_rgmii_rx_delay)\n\t\tcfg_rxclk_dly = FIELD_PREP(PRG_ETH1_CFG_RXCLK_DLY,\n\t\t\t\t\t   dwmac->rx_delay_ps / 200);\n\telse if (dwmac->rx_delay_ps == 2000)\n\t\trx_adj_config = PRG_ETH0_ADJ_ENABLE | PRG_ETH0_ADJ_SETUP;\n\n\tswitch (dwmac->phy_mode) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\t\tdelay_config = tx_dly_config | rx_adj_config;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\tdelay_config = tx_dly_config;\n\t\tcfg_rxclk_dly = 0;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tdelay_config = rx_adj_config;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tdelay_config = 0;\n\t\tcfg_rxclk_dly = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dwmac->dev, \"unsupported phy-mode %s\\n\",\n\t\t\tphy_modes(dwmac->phy_mode));\n\t\treturn -EINVAL;\n\t}\n\n\tif (delay_config & PRG_ETH0_ADJ_ENABLE) {\n\t\tif (!dwmac->timing_adj_clk) {\n\t\t\tdev_err(dwmac->dev,\n\t\t\t\t\"The timing-adjustment clock is mandatory for the RX delay re-timing\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tret = meson8b_devm_clk_prepare_enable(dwmac,\n\t\t\t\t\t\t      dwmac->timing_adj_clk);\n\t\tif (ret) {\n\t\t\tdev_err(dwmac->dev,\n\t\t\t\t\"Failed to enable the timing-adjustment clock\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tmeson8b_dwmac_mask_bits(dwmac, PRG_ETH0, PRG_ETH0_TXDLY_MASK |\n\t\t\t\tPRG_ETH0_ADJ_ENABLE | PRG_ETH0_ADJ_SETUP |\n\t\t\t\tPRG_ETH0_ADJ_DELAY | PRG_ETH0_ADJ_SKEW,\n\t\t\t\tdelay_config);\n\n\tmeson8b_dwmac_mask_bits(dwmac, PRG_ETH1, PRG_ETH1_CFG_RXCLK_DLY,\n\t\t\t\tcfg_rxclk_dly);\n\n\treturn 0;\n}\n\nstatic int meson8b_init_prg_eth(struct meson8b_dwmac *dwmac)\n{\n\tint ret;\n\n\tif (phy_interface_mode_is_rgmii(dwmac->phy_mode)) {\n\t\t \n\t\tmeson8b_dwmac_mask_bits(dwmac, PRG_ETH0,\n\t\t\t\t\tPRG_ETH0_INVERTED_RMII_CLK, 0);\n\n\t\t \n\t\tret = clk_set_rate(dwmac->rgmii_tx_clk, 125 * 1000 * 1000);\n\t\tif (ret) {\n\t\t\tdev_err(dwmac->dev,\n\t\t\t\t\"failed to set RGMII TX clock\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = meson8b_devm_clk_prepare_enable(dwmac,\n\t\t\t\t\t\t      dwmac->rgmii_tx_clk);\n\t\tif (ret) {\n\t\t\tdev_err(dwmac->dev,\n\t\t\t\t\"failed to enable the RGMII TX clock\\n\");\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\t \n\t\tmeson8b_dwmac_mask_bits(dwmac, PRG_ETH0,\n\t\t\t\t\tPRG_ETH0_INVERTED_RMII_CLK,\n\t\t\t\t\tPRG_ETH0_INVERTED_RMII_CLK);\n\t}\n\n\t \n\tmeson8b_dwmac_mask_bits(dwmac, PRG_ETH0, PRG_ETH0_TX_AND_PHY_REF_CLK,\n\t\t\t\tPRG_ETH0_TX_AND_PHY_REF_CLK);\n\n\treturn 0;\n}\n\nstatic int meson8b_dwmac_probe(struct platform_device *pdev)\n{\n\tstruct plat_stmmacenet_data *plat_dat;\n\tstruct stmmac_resources stmmac_res;\n\tstruct meson8b_dwmac *dwmac;\n\tint ret;\n\n\tret = stmmac_get_platform_resources(pdev, &stmmac_res);\n\tif (ret)\n\t\treturn ret;\n\n\tplat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);\n\tif (IS_ERR(plat_dat))\n\t\treturn PTR_ERR(plat_dat);\n\n\tdwmac = devm_kzalloc(&pdev->dev, sizeof(*dwmac), GFP_KERNEL);\n\tif (!dwmac) {\n\t\tret = -ENOMEM;\n\t\tgoto err_remove_config_dt;\n\t}\n\n\tdwmac->data = (const struct meson8b_dwmac_data *)\n\t\tof_device_get_match_data(&pdev->dev);\n\tif (!dwmac->data) {\n\t\tret = -EINVAL;\n\t\tgoto err_remove_config_dt;\n\t}\n\tdwmac->regs = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(dwmac->regs)) {\n\t\tret = PTR_ERR(dwmac->regs);\n\t\tgoto err_remove_config_dt;\n\t}\n\n\tdwmac->dev = &pdev->dev;\n\tret = of_get_phy_mode(pdev->dev.of_node, &dwmac->phy_mode);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"missing phy-mode property\\n\");\n\t\tgoto err_remove_config_dt;\n\t}\n\n\t \n\tif (of_property_read_u32(pdev->dev.of_node, \"amlogic,tx-delay-ns\",\n\t\t\t\t &dwmac->tx_delay_ns))\n\t\tdwmac->tx_delay_ns = 2;\n\n\t \n\tif (of_property_read_u32(pdev->dev.of_node, \"rx-internal-delay-ps\",\n\t\t\t\t &dwmac->rx_delay_ps)) {\n\t\tif (!of_property_read_u32(pdev->dev.of_node,\n\t\t\t\t\t  \"amlogic,rx-delay-ns\",\n\t\t\t\t\t  &dwmac->rx_delay_ps))\n\t\t\t \n\t\t\tdwmac->rx_delay_ps *= 1000;\n\t}\n\n\tif (dwmac->data->has_prg_eth1_rgmii_rx_delay) {\n\t\tif (dwmac->rx_delay_ps > 3000 || dwmac->rx_delay_ps % 200) {\n\t\t\tdev_err(dwmac->dev,\n\t\t\t\t\"The RGMII RX delay range is 0..3000ps in 200ps steps\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_remove_config_dt;\n\t\t}\n\t} else {\n\t\tif (dwmac->rx_delay_ps != 0 && dwmac->rx_delay_ps != 2000) {\n\t\t\tdev_err(dwmac->dev,\n\t\t\t\t\"The only allowed RGMII RX delays values are: 0ps, 2000ps\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_remove_config_dt;\n\t\t}\n\t}\n\n\tdwmac->timing_adj_clk = devm_clk_get_optional(dwmac->dev,\n\t\t\t\t\t\t      \"timing-adjustment\");\n\tif (IS_ERR(dwmac->timing_adj_clk)) {\n\t\tret = PTR_ERR(dwmac->timing_adj_clk);\n\t\tgoto err_remove_config_dt;\n\t}\n\n\tret = meson8b_init_rgmii_delays(dwmac);\n\tif (ret)\n\t\tgoto err_remove_config_dt;\n\n\tret = meson8b_init_rgmii_tx_clk(dwmac);\n\tif (ret)\n\t\tgoto err_remove_config_dt;\n\n\tret = dwmac->data->set_phy_mode(dwmac);\n\tif (ret)\n\t\tgoto err_remove_config_dt;\n\n\tret = meson8b_init_prg_eth(dwmac);\n\tif (ret)\n\t\tgoto err_remove_config_dt;\n\n\tplat_dat->bsp_priv = dwmac;\n\n\tret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);\n\tif (ret)\n\t\tgoto err_remove_config_dt;\n\n\treturn 0;\n\nerr_remove_config_dt:\n\tstmmac_remove_config_dt(pdev, plat_dat);\n\n\treturn ret;\n}\n\nstatic const struct meson8b_dwmac_data meson8b_dwmac_data = {\n\t.set_phy_mode = meson8b_set_phy_mode,\n\t.has_prg_eth1_rgmii_rx_delay = false,\n};\n\nstatic const struct meson8b_dwmac_data meson_axg_dwmac_data = {\n\t.set_phy_mode = meson_axg_set_phy_mode,\n\t.has_prg_eth1_rgmii_rx_delay = false,\n};\n\nstatic const struct meson8b_dwmac_data meson_g12a_dwmac_data = {\n\t.set_phy_mode = meson_axg_set_phy_mode,\n\t.has_prg_eth1_rgmii_rx_delay = true,\n};\n\nstatic const struct of_device_id meson8b_dwmac_match[] = {\n\t{\n\t\t.compatible = \"amlogic,meson8b-dwmac\",\n\t\t.data = &meson8b_dwmac_data,\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson8m2-dwmac\",\n\t\t.data = &meson8b_dwmac_data,\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson-gxbb-dwmac\",\n\t\t.data = &meson8b_dwmac_data,\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson-axg-dwmac\",\n\t\t.data = &meson_axg_dwmac_data,\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson-g12a-dwmac\",\n\t\t.data = &meson_g12a_dwmac_data,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, meson8b_dwmac_match);\n\nstatic struct platform_driver meson8b_dwmac_driver = {\n\t.probe  = meson8b_dwmac_probe,\n\t.remove_new = stmmac_pltfr_remove,\n\t.driver = {\n\t\t.name           = \"meson8b-dwmac\",\n\t\t.pm\t\t= &stmmac_pltfr_pm_ops,\n\t\t.of_match_table = meson8b_dwmac_match,\n\t},\n};\nmodule_platform_driver(meson8b_dwmac_driver);\n\nMODULE_AUTHOR(\"Martin Blumenstingl <martin.blumenstingl@googlemail.com>\");\nMODULE_DESCRIPTION(\"Amlogic Meson8b, Meson8m2 and GXBB DWMAC glue layer\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}