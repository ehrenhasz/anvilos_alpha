{
  "module_name": "dwmac-ipq806x.c",
  "hash_id": "13e1f3cfb471147ece985ef65c2128f26db2cce602ecbbdebcb456f8082c36f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwmac-ipq806x.c",
  "human_readable_source": " \n\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/phy.h>\n#include <linux/regmap.h>\n#include <linux/clk.h>\n#include <linux/reset.h>\n#include <linux/of_net.h>\n#include <linux/mfd/syscon.h>\n#include <linux/stmmac.h>\n#include <linux/of_mdio.h>\n#include <linux/module.h>\n#include <linux/sys_soc.h>\n#include <linux/bitfield.h>\n\n#include \"stmmac_platform.h\"\n\n#define NSS_COMMON_CLK_GATE\t\t\t0x8\n#define NSS_COMMON_CLK_GATE_PTP_EN(x)\t\tBIT(0x10 + x)\n#define NSS_COMMON_CLK_GATE_RGMII_RX_EN(x)\tBIT(0x9 + (x * 2))\n#define NSS_COMMON_CLK_GATE_RGMII_TX_EN(x)\tBIT(0x8 + (x * 2))\n#define NSS_COMMON_CLK_GATE_GMII_RX_EN(x)\tBIT(0x4 + x)\n#define NSS_COMMON_CLK_GATE_GMII_TX_EN(x)\tBIT(0x0 + x)\n\n#define NSS_COMMON_CLK_DIV0\t\t\t0xC\n#define NSS_COMMON_CLK_DIV_OFFSET(x)\t\t(x * 8)\n#define NSS_COMMON_CLK_DIV_MASK\t\t\t0x7f\n\n#define NSS_COMMON_CLK_SRC_CTRL\t\t\t0x14\n#define NSS_COMMON_CLK_SRC_CTRL_OFFSET(x)\t(x)\n \n#define NSS_COMMON_CLK_SRC_CTRL_RGMII(x)\t1\n#define NSS_COMMON_CLK_SRC_CTRL_SGMII(x)\t((x >= 2) ? 1 : 0)\n\n#define NSS_COMMON_GMAC_CTL(x)\t\t\t(0x30 + (x * 4))\n#define NSS_COMMON_GMAC_CTL_CSYS_REQ\t\tBIT(19)\n#define NSS_COMMON_GMAC_CTL_PHY_IFACE_SEL\tBIT(16)\n#define NSS_COMMON_GMAC_CTL_IFG_LIMIT_OFFSET\t8\n#define NSS_COMMON_GMAC_CTL_IFG_OFFSET\t\t0\n\n#define NSS_COMMON_CLK_DIV_RGMII_1000\t\t1\n#define NSS_COMMON_CLK_DIV_RGMII_100\t\t9\n#define NSS_COMMON_CLK_DIV_RGMII_10\t\t99\n#define NSS_COMMON_CLK_DIV_SGMII_1000\t\t0\n#define NSS_COMMON_CLK_DIV_SGMII_100\t\t4\n#define NSS_COMMON_CLK_DIV_SGMII_10\t\t49\n\n#define QSGMII_PCS_ALL_CH_CTL\t\t\t0x80\n#define QSGMII_PCS_CH_SPEED_FORCE\t\tBIT(1)\n#define QSGMII_PCS_CH_SPEED_10\t\t\t0x0\n#define QSGMII_PCS_CH_SPEED_100\t\t\tBIT(2)\n#define QSGMII_PCS_CH_SPEED_1000\t\tBIT(3)\n#define QSGMII_PCS_CH_SPEED_MASK\t\t(QSGMII_PCS_CH_SPEED_FORCE | \\\n\t\t\t\t\t\t QSGMII_PCS_CH_SPEED_10 | \\\n\t\t\t\t\t\t QSGMII_PCS_CH_SPEED_100 | \\\n\t\t\t\t\t\t QSGMII_PCS_CH_SPEED_1000)\n#define QSGMII_PCS_CH_SPEED_SHIFT(x)\t\t((x) * 4)\n\n#define QSGMII_PCS_CAL_LCKDT_CTL\t\t0x120\n#define QSGMII_PCS_CAL_LCKDT_CTL_RST\t\tBIT(19)\n\n \n#define QSGMII_PHY_SGMII_CTL(x)\t\t\t((x == 1) ? 0x134 : \\\n\t\t\t\t\t\t (0x13c + (4 * (x - 2))))\n#define QSGMII_PHY_CDR_EN\t\t\tBIT(0)\n#define QSGMII_PHY_RX_FRONT_EN\t\t\tBIT(1)\n#define QSGMII_PHY_RX_SIGNAL_DETECT_EN\t\tBIT(2)\n#define QSGMII_PHY_TX_DRIVER_EN\t\t\tBIT(3)\n#define QSGMII_PHY_QSGMII_EN\t\t\tBIT(7)\n#define QSGMII_PHY_DEEMPHASIS_LVL_MASK\t\tGENMASK(11, 10)\n#define QSGMII_PHY_DEEMPHASIS_LVL(x)\t\tFIELD_PREP(QSGMII_PHY_DEEMPHASIS_LVL_MASK, (x))\n#define QSGMII_PHY_PHASE_LOOP_GAIN_MASK\t\tGENMASK(14, 12)\n#define QSGMII_PHY_PHASE_LOOP_GAIN(x)\t\tFIELD_PREP(QSGMII_PHY_PHASE_LOOP_GAIN_MASK, (x))\n#define QSGMII_PHY_RX_DC_BIAS_MASK\t\tGENMASK(19, 18)\n#define QSGMII_PHY_RX_DC_BIAS(x)\t\tFIELD_PREP(QSGMII_PHY_RX_DC_BIAS_MASK, (x))\n#define QSGMII_PHY_RX_INPUT_EQU_MASK\t\tGENMASK(21, 20)\n#define QSGMII_PHY_RX_INPUT_EQU(x)\t\tFIELD_PREP(QSGMII_PHY_RX_INPUT_EQU_MASK, (x))\n#define QSGMII_PHY_CDR_PI_SLEW_MASK\t\tGENMASK(23, 22)\n#define QSGMII_PHY_CDR_PI_SLEW(x)\t\tFIELD_PREP(QSGMII_PHY_CDR_PI_SLEW_MASK, (x))\n#define QSGMII_PHY_TX_SLEW_MASK\t\t\tGENMASK(27, 26)\n#define QSGMII_PHY_TX_SLEW(x)\t\t\tFIELD_PREP(QSGMII_PHY_TX_SLEW_MASK, (x))\n#define QSGMII_PHY_TX_DRV_AMP_MASK\t\tGENMASK(31, 28)\n#define QSGMII_PHY_TX_DRV_AMP(x)\t\tFIELD_PREP(QSGMII_PHY_TX_DRV_AMP_MASK, (x))\n\nstruct ipq806x_gmac {\n\tstruct platform_device *pdev;\n\tstruct regmap *nss_common;\n\tstruct regmap *qsgmii_csr;\n\tuint32_t id;\n\tstruct clk *core_clk;\n\tphy_interface_t phy_mode;\n};\n\nstatic int get_clk_div_sgmii(struct ipq806x_gmac *gmac, unsigned int speed)\n{\n\tstruct device *dev = &gmac->pdev->dev;\n\tint div;\n\n\tswitch (speed) {\n\tcase SPEED_1000:\n\t\tdiv = NSS_COMMON_CLK_DIV_SGMII_1000;\n\t\tbreak;\n\n\tcase SPEED_100:\n\t\tdiv = NSS_COMMON_CLK_DIV_SGMII_100;\n\t\tbreak;\n\n\tcase SPEED_10:\n\t\tdiv = NSS_COMMON_CLK_DIV_SGMII_10;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Speed %dMbps not supported in SGMII\\n\", speed);\n\t\treturn -EINVAL;\n\t}\n\n\treturn div;\n}\n\nstatic int get_clk_div_rgmii(struct ipq806x_gmac *gmac, unsigned int speed)\n{\n\tstruct device *dev = &gmac->pdev->dev;\n\tint div;\n\n\tswitch (speed) {\n\tcase SPEED_1000:\n\t\tdiv = NSS_COMMON_CLK_DIV_RGMII_1000;\n\t\tbreak;\n\n\tcase SPEED_100:\n\t\tdiv = NSS_COMMON_CLK_DIV_RGMII_100;\n\t\tbreak;\n\n\tcase SPEED_10:\n\t\tdiv = NSS_COMMON_CLK_DIV_RGMII_10;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"Speed %dMbps not supported in RGMII\\n\", speed);\n\t\treturn -EINVAL;\n\t}\n\n\treturn div;\n}\n\nstatic int ipq806x_gmac_set_speed(struct ipq806x_gmac *gmac, unsigned int speed)\n{\n\tuint32_t clk_bits, val;\n\tint div;\n\n\tswitch (gmac->phy_mode) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\t\tdiv = get_clk_div_rgmii(gmac, speed);\n\t\tclk_bits = NSS_COMMON_CLK_GATE_RGMII_RX_EN(gmac->id) |\n\t\t\t   NSS_COMMON_CLK_GATE_RGMII_TX_EN(gmac->id);\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_SGMII:\n\t\tdiv = get_clk_div_sgmii(gmac, speed);\n\t\tclk_bits = NSS_COMMON_CLK_GATE_GMII_RX_EN(gmac->id) |\n\t\t\t   NSS_COMMON_CLK_GATE_GMII_TX_EN(gmac->id);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&gmac->pdev->dev, \"Unsupported PHY mode: \\\"%s\\\"\\n\",\n\t\t\tphy_modes(gmac->phy_mode));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tregmap_read(gmac->nss_common, NSS_COMMON_CLK_GATE, &val);\n\tval &= ~clk_bits;\n\tregmap_write(gmac->nss_common, NSS_COMMON_CLK_GATE, val);\n\n\t \n\tregmap_read(gmac->nss_common, NSS_COMMON_CLK_DIV0, &val);\n\tval &= ~(NSS_COMMON_CLK_DIV_MASK\n\t\t << NSS_COMMON_CLK_DIV_OFFSET(gmac->id));\n\tval |= div << NSS_COMMON_CLK_DIV_OFFSET(gmac->id);\n\tregmap_write(gmac->nss_common, NSS_COMMON_CLK_DIV0, val);\n\n\t \n\tregmap_read(gmac->nss_common, NSS_COMMON_CLK_GATE, &val);\n\tval |= clk_bits;\n\tregmap_write(gmac->nss_common, NSS_COMMON_CLK_GATE, val);\n\n\treturn 0;\n}\n\nstatic int ipq806x_gmac_of_parse(struct ipq806x_gmac *gmac)\n{\n\tstruct device *dev = &gmac->pdev->dev;\n\tint ret;\n\n\tret = of_get_phy_mode(dev->of_node, &gmac->phy_mode);\n\tif (ret) {\n\t\tdev_err(dev, \"missing phy mode property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_u32(dev->of_node, \"qcom,id\", &gmac->id) < 0) {\n\t\tdev_err(dev, \"missing qcom id property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (gmac->id > 3) {\n\t\tdev_err(dev, \"invalid gmac id\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgmac->core_clk = devm_clk_get(dev, \"stmmaceth\");\n\tif (IS_ERR(gmac->core_clk)) {\n\t\tdev_err(dev, \"missing stmmaceth clk property\\n\");\n\t\treturn PTR_ERR(gmac->core_clk);\n\t}\n\tclk_set_rate(gmac->core_clk, 266000000);\n\n\t \n\tgmac->nss_common = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t\t   \"qcom,nss-common\");\n\tif (IS_ERR(gmac->nss_common)) {\n\t\tdev_err(dev, \"missing nss-common node\\n\");\n\t\treturn PTR_ERR(gmac->nss_common);\n\t}\n\n\t \n\tgmac->qsgmii_csr = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t\t   \"qcom,qsgmii-csr\");\n\tif (IS_ERR(gmac->qsgmii_csr))\n\t\tdev_err(dev, \"missing qsgmii-csr node\\n\");\n\n\treturn PTR_ERR_OR_ZERO(gmac->qsgmii_csr);\n}\n\nstatic void ipq806x_gmac_fix_mac_speed(void *priv, unsigned int speed, unsigned int mode)\n{\n\tstruct ipq806x_gmac *gmac = priv;\n\n\tipq806x_gmac_set_speed(gmac, speed);\n}\n\nstatic int\nipq806x_gmac_configure_qsgmii_pcs_speed(struct ipq806x_gmac *gmac)\n{\n\tstruct platform_device *pdev = gmac->pdev;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *dn;\n\tint link_speed;\n\tint val = 0;\n\tint ret;\n\n\t \n\tif (!of_phy_is_fixed_link(pdev->dev.of_node))\n\t\tgoto write;\n\n\tdn = of_get_child_by_name(pdev->dev.of_node, \"fixed-link\");\n\tret = of_property_read_u32(dn, \"speed\", &link_speed);\n\tof_node_put(dn);\n\tif (ret) {\n\t\tdev_err(dev, \"found fixed-link node with no speed\");\n\t\treturn ret;\n\t}\n\n\tval = QSGMII_PCS_CH_SPEED_FORCE;\n\n\tswitch (link_speed) {\n\tcase SPEED_1000:\n\t\tval |= QSGMII_PCS_CH_SPEED_1000;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tval |= QSGMII_PCS_CH_SPEED_100;\n\t\tbreak;\n\tcase SPEED_10:\n\t\tval |= QSGMII_PCS_CH_SPEED_10;\n\t\tbreak;\n\t}\n\nwrite:\n\tregmap_update_bits(gmac->qsgmii_csr, QSGMII_PCS_ALL_CH_CTL,\n\t\t\t   QSGMII_PCS_CH_SPEED_MASK <<\n\t\t\t   QSGMII_PCS_CH_SPEED_SHIFT(gmac->id),\n\t\t\t   val <<\n\t\t\t   QSGMII_PCS_CH_SPEED_SHIFT(gmac->id));\n\n\treturn 0;\n}\n\nstatic const struct soc_device_attribute ipq806x_gmac_soc_v1[] = {\n\t{\n\t\t.revision = \"1.*\",\n\t},\n\t{\n\t\t \n\t}\n};\n\nstatic int\nipq806x_gmac_configure_qsgmii_params(struct ipq806x_gmac *gmac)\n{\n\tstruct platform_device *pdev = gmac->pdev;\n\tconst struct soc_device_attribute *soc;\n\tstruct device *dev = &pdev->dev;\n\tu32 qsgmii_param;\n\n\tswitch (gmac->id) {\n\tcase 1:\n\t\tsoc = soc_device_match(ipq806x_gmac_soc_v1);\n\n\t\tif (soc)\n\t\t\tqsgmii_param = QSGMII_PHY_TX_DRV_AMP(0xc) |\n\t\t\t\t       QSGMII_PHY_TX_SLEW(0x2) |\n\t\t\t\t       QSGMII_PHY_DEEMPHASIS_LVL(0x2);\n\t\telse\n\t\t\tqsgmii_param = QSGMII_PHY_TX_DRV_AMP(0xd) |\n\t\t\t\t       QSGMII_PHY_TX_SLEW(0x0) |\n\t\t\t\t       QSGMII_PHY_DEEMPHASIS_LVL(0x0);\n\n\t\tqsgmii_param |= QSGMII_PHY_RX_DC_BIAS(0x2);\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\t\tqsgmii_param = QSGMII_PHY_RX_DC_BIAS(0x3) |\n\t\t\t       QSGMII_PHY_TX_DRV_AMP(0xc);\n\t\tbreak;\n\tdefault:  \n\t\tdev_err(dev, \"gmac id %d can't be in SGMII mode\", gmac->id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tqsgmii_param |= QSGMII_PHY_CDR_EN |\n\t\t\tQSGMII_PHY_RX_FRONT_EN |\n\t\t\tQSGMII_PHY_RX_SIGNAL_DETECT_EN |\n\t\t\tQSGMII_PHY_TX_DRIVER_EN |\n\t\t\tQSGMII_PHY_QSGMII_EN |\n\t\t\tQSGMII_PHY_PHASE_LOOP_GAIN(0x4) |\n\t\t\tQSGMII_PHY_RX_INPUT_EQU(0x1) |\n\t\t\tQSGMII_PHY_CDR_PI_SLEW(0x2);\n\n\tregmap_write(gmac->qsgmii_csr, QSGMII_PHY_SGMII_CTL(gmac->id),\n\t\t     qsgmii_param);\n\n\treturn 0;\n}\n\nstatic int ipq806x_gmac_probe(struct platform_device *pdev)\n{\n\tstruct plat_stmmacenet_data *plat_dat;\n\tstruct stmmac_resources stmmac_res;\n\tstruct device *dev = &pdev->dev;\n\tstruct ipq806x_gmac *gmac;\n\tint val;\n\tint err;\n\n\tval = stmmac_get_platform_resources(pdev, &stmmac_res);\n\tif (val)\n\t\treturn val;\n\n\tplat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);\n\tif (IS_ERR(plat_dat))\n\t\treturn PTR_ERR(plat_dat);\n\n\tgmac = devm_kzalloc(dev, sizeof(*gmac), GFP_KERNEL);\n\tif (!gmac) {\n\t\terr = -ENOMEM;\n\t\tgoto err_remove_config_dt;\n\t}\n\n\tgmac->pdev = pdev;\n\n\terr = ipq806x_gmac_of_parse(gmac);\n\tif (err) {\n\t\tdev_err(dev, \"device tree parsing error\\n\");\n\t\tgoto err_remove_config_dt;\n\t}\n\n\tregmap_write(gmac->qsgmii_csr, QSGMII_PCS_CAL_LCKDT_CTL,\n\t\t     QSGMII_PCS_CAL_LCKDT_CTL_RST);\n\n\t \n\tval = 12 << NSS_COMMON_GMAC_CTL_IFG_OFFSET |\n\t      12 << NSS_COMMON_GMAC_CTL_IFG_LIMIT_OFFSET;\n\t \n\tval |= NSS_COMMON_GMAC_CTL_CSYS_REQ;\n\tswitch (gmac->phy_mode) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\t\tval |= NSS_COMMON_GMAC_CTL_PHY_IFACE_SEL;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_SGMII:\n\t\tval &= ~NSS_COMMON_GMAC_CTL_PHY_IFACE_SEL;\n\t\tbreak;\n\tdefault:\n\t\tgoto err_unsupported_phy;\n\t}\n\tregmap_write(gmac->nss_common, NSS_COMMON_GMAC_CTL(gmac->id), val);\n\n\t \n\tregmap_read(gmac->nss_common, NSS_COMMON_CLK_SRC_CTRL, &val);\n\tval &= ~(1 << NSS_COMMON_CLK_SRC_CTRL_OFFSET(gmac->id));\n\tswitch (gmac->phy_mode) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\t\tval |= NSS_COMMON_CLK_SRC_CTRL_RGMII(gmac->id) <<\n\t\t\tNSS_COMMON_CLK_SRC_CTRL_OFFSET(gmac->id);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_SGMII:\n\t\tval |= NSS_COMMON_CLK_SRC_CTRL_SGMII(gmac->id) <<\n\t\t\tNSS_COMMON_CLK_SRC_CTRL_OFFSET(gmac->id);\n\t\tbreak;\n\tdefault:\n\t\tgoto err_unsupported_phy;\n\t}\n\tregmap_write(gmac->nss_common, NSS_COMMON_CLK_SRC_CTRL, val);\n\n\t \n\tregmap_read(gmac->nss_common, NSS_COMMON_CLK_GATE, &val);\n\tval |= NSS_COMMON_CLK_GATE_PTP_EN(gmac->id);\n\tswitch (gmac->phy_mode) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\t\tval |= NSS_COMMON_CLK_GATE_RGMII_RX_EN(gmac->id) |\n\t\t\tNSS_COMMON_CLK_GATE_RGMII_TX_EN(gmac->id);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_SGMII:\n\t\tval |= NSS_COMMON_CLK_GATE_GMII_RX_EN(gmac->id) |\n\t\t\t\tNSS_COMMON_CLK_GATE_GMII_TX_EN(gmac->id);\n\t\tbreak;\n\tdefault:\n\t\tgoto err_unsupported_phy;\n\t}\n\tregmap_write(gmac->nss_common, NSS_COMMON_CLK_GATE, val);\n\n\tif (gmac->phy_mode == PHY_INTERFACE_MODE_SGMII) {\n\t\terr = ipq806x_gmac_configure_qsgmii_params(gmac);\n\t\tif (err)\n\t\t\tgoto err_remove_config_dt;\n\n\t\terr = ipq806x_gmac_configure_qsgmii_pcs_speed(gmac);\n\t\tif (err)\n\t\t\tgoto err_remove_config_dt;\n\t}\n\n\tplat_dat->has_gmac = true;\n\tplat_dat->bsp_priv = gmac;\n\tplat_dat->fix_mac_speed = ipq806x_gmac_fix_mac_speed;\n\tplat_dat->multicast_filter_bins = 0;\n\tplat_dat->tx_fifo_size = 8192;\n\tplat_dat->rx_fifo_size = 8192;\n\n\terr = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);\n\tif (err)\n\t\tgoto err_remove_config_dt;\n\n\treturn 0;\n\nerr_unsupported_phy:\n\tdev_err(&pdev->dev, \"Unsupported PHY mode: \\\"%s\\\"\\n\",\n\t\tphy_modes(gmac->phy_mode));\n\terr = -EINVAL;\n\nerr_remove_config_dt:\n\tstmmac_remove_config_dt(pdev, plat_dat);\n\n\treturn err;\n}\n\nstatic const struct of_device_id ipq806x_gmac_dwmac_match[] = {\n\t{ .compatible = \"qcom,ipq806x-gmac\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ipq806x_gmac_dwmac_match);\n\nstatic struct platform_driver ipq806x_gmac_dwmac_driver = {\n\t.probe = ipq806x_gmac_probe,\n\t.remove_new = stmmac_pltfr_remove,\n\t.driver = {\n\t\t.name\t\t= \"ipq806x-gmac-dwmac\",\n\t\t.pm\t\t= &stmmac_pltfr_pm_ops,\n\t\t.of_match_table\t= ipq806x_gmac_dwmac_match,\n\t},\n};\nmodule_platform_driver(ipq806x_gmac_dwmac_driver);\n\nMODULE_AUTHOR(\"Mathieu Olivari <mathieu@codeaurora.org>\");\nMODULE_DESCRIPTION(\"Qualcomm Atheros IPQ806x DWMAC specific glue layer\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}