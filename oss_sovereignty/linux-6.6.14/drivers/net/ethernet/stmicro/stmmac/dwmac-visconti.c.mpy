{
  "module_name": "dwmac-visconti.c",
  "hash_id": "c66a8b955ea6f1fae672302ef6b7660793ad180c88a6df9f6d719e3819f40217",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwmac-visconti.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/of_net.h>\n#include <linux/stmmac.h>\n\n#include \"stmmac_platform.h\"\n#include \"dwmac4.h\"\n\n#define REG_ETHER_CONTROL\t0x52D4\n#define ETHER_ETH_CONTROL_RESET BIT(17)\n\n#define REG_ETHER_CLOCK_SEL\t0x52D0\n#define ETHER_CLK_SEL_TX_CLK_EN BIT(0)\n#define ETHER_CLK_SEL_RX_CLK_EN BIT(1)\n#define ETHER_CLK_SEL_RMII_CLK_EN BIT(2)\n#define ETHER_CLK_SEL_RMII_CLK_RST BIT(3)\n#define ETHER_CLK_SEL_DIV_SEL_2 BIT(4)\n#define ETHER_CLK_SEL_DIV_SEL_20 0\n#define ETHER_CLK_SEL_FREQ_SEL_125M\t(BIT(9) | BIT(8))\n#define ETHER_CLK_SEL_FREQ_SEL_50M\tBIT(9)\n#define ETHER_CLK_SEL_FREQ_SEL_25M\tBIT(8)\n#define ETHER_CLK_SEL_FREQ_SEL_2P5M\t0\n#define ETHER_CLK_SEL_TX_CLK_EXT_SEL_IN 0\n#define ETHER_CLK_SEL_TX_CLK_EXT_SEL_TXC BIT(10)\n#define ETHER_CLK_SEL_TX_CLK_EXT_SEL_DIV BIT(11)\n#define ETHER_CLK_SEL_RX_CLK_EXT_SEL_IN  0\n#define ETHER_CLK_SEL_RX_CLK_EXT_SEL_RXC BIT(12)\n#define ETHER_CLK_SEL_RX_CLK_EXT_SEL_DIV BIT(13)\n#define ETHER_CLK_SEL_TX_CLK_O_TX_I\t 0\n#define ETHER_CLK_SEL_TX_CLK_O_RMII_I\t BIT(14)\n#define ETHER_CLK_SEL_TX_O_E_N_IN\t BIT(15)\n#define ETHER_CLK_SEL_RMII_CLK_SEL_IN\t 0\n#define ETHER_CLK_SEL_RMII_CLK_SEL_RX_C\t BIT(16)\n\n#define ETHER_CLK_SEL_RX_TX_CLK_EN (ETHER_CLK_SEL_RX_CLK_EN | ETHER_CLK_SEL_TX_CLK_EN)\n\n#define ETHER_CONFIG_INTF_MII 0\n#define ETHER_CONFIG_INTF_RGMII BIT(0)\n#define ETHER_CONFIG_INTF_RMII BIT(2)\n\nstruct visconti_eth {\n\tvoid __iomem *reg;\n\tu32 phy_intf_sel;\n\tstruct clk *phy_ref_clk;\n\tstruct device *dev;\n\tspinlock_t lock;  \n};\n\nstatic void visconti_eth_fix_mac_speed(void *priv, unsigned int speed, unsigned int mode)\n{\n\tstruct visconti_eth *dwmac = priv;\n\tstruct net_device *netdev = dev_get_drvdata(dwmac->dev);\n\tunsigned int val, clk_sel_val = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dwmac->lock, flags);\n\n\t \n\tval = readl(dwmac->reg + MAC_CTRL_REG);\n\tval &= ~(GMAC_CONFIG_PS | GMAC_CONFIG_FES);\n\n\tswitch (speed) {\n\tcase SPEED_1000:\n\t\tif (dwmac->phy_intf_sel == ETHER_CONFIG_INTF_RGMII)\n\t\t\tclk_sel_val = ETHER_CLK_SEL_FREQ_SEL_125M;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tif (dwmac->phy_intf_sel == ETHER_CONFIG_INTF_RGMII)\n\t\t\tclk_sel_val = ETHER_CLK_SEL_FREQ_SEL_25M;\n\t\tif (dwmac->phy_intf_sel == ETHER_CONFIG_INTF_RMII)\n\t\t\tclk_sel_val = ETHER_CLK_SEL_DIV_SEL_2;\n\t\tval |= GMAC_CONFIG_PS | GMAC_CONFIG_FES;\n\t\tbreak;\n\tcase SPEED_10:\n\t\tif (dwmac->phy_intf_sel == ETHER_CONFIG_INTF_RGMII)\n\t\t\tclk_sel_val = ETHER_CLK_SEL_FREQ_SEL_2P5M;\n\t\tif (dwmac->phy_intf_sel == ETHER_CONFIG_INTF_RMII)\n\t\t\tclk_sel_val = ETHER_CLK_SEL_DIV_SEL_20;\n\t\tval |= GMAC_CONFIG_PS;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tnetdev_err(netdev, \"Unsupported speed request (%d)\", speed);\n\t\tspin_unlock_irqrestore(&dwmac->lock, flags);\n\t\treturn;\n\t}\n\n\twritel(val, dwmac->reg + MAC_CTRL_REG);\n\n\t \n\tval = readl(dwmac->reg + REG_ETHER_CLOCK_SEL);\n\tval &= ~(ETHER_CLK_SEL_RMII_CLK_EN | ETHER_CLK_SEL_RX_TX_CLK_EN);\n\tval |= ETHER_CLK_SEL_TX_O_E_N_IN;\n\twritel(val, dwmac->reg + REG_ETHER_CLOCK_SEL);\n\n\t \n\tswitch (dwmac->phy_intf_sel) {\n\tcase ETHER_CONFIG_INTF_RGMII:\n\t\tval = clk_sel_val | ETHER_CLK_SEL_RX_CLK_EXT_SEL_RXC;\n\t\twritel(val, dwmac->reg + REG_ETHER_CLOCK_SEL);\n\n\t\tval |= ETHER_CLK_SEL_RX_TX_CLK_EN;\n\t\twritel(val, dwmac->reg + REG_ETHER_CLOCK_SEL);\n\n\t\tval &= ~ETHER_CLK_SEL_TX_O_E_N_IN;\n\t\twritel(val, dwmac->reg + REG_ETHER_CLOCK_SEL);\n\t\tbreak;\n\tcase ETHER_CONFIG_INTF_RMII:\n\t\tval = clk_sel_val | ETHER_CLK_SEL_RX_CLK_EXT_SEL_DIV |\n\t\t\tETHER_CLK_SEL_TX_CLK_EXT_SEL_DIV | ETHER_CLK_SEL_TX_O_E_N_IN |\n\t\t\tETHER_CLK_SEL_RMII_CLK_SEL_RX_C;\n\t\twritel(val, dwmac->reg + REG_ETHER_CLOCK_SEL);\n\n\t\tval |= ETHER_CLK_SEL_RMII_CLK_RST;\n\t\twritel(val, dwmac->reg + REG_ETHER_CLOCK_SEL);\n\n\t\tval |= ETHER_CLK_SEL_RMII_CLK_EN | ETHER_CLK_SEL_RX_TX_CLK_EN;\n\t\twritel(val, dwmac->reg + REG_ETHER_CLOCK_SEL);\n\t\tbreak;\n\tcase ETHER_CONFIG_INTF_MII:\n\tdefault:\n\t\tval = clk_sel_val | ETHER_CLK_SEL_RX_CLK_EXT_SEL_RXC |\n\t\t\tETHER_CLK_SEL_TX_CLK_EXT_SEL_TXC | ETHER_CLK_SEL_TX_O_E_N_IN;\n\t\twritel(val, dwmac->reg + REG_ETHER_CLOCK_SEL);\n\n\t\tval |= ETHER_CLK_SEL_RX_TX_CLK_EN;\n\t\twritel(val, dwmac->reg + REG_ETHER_CLOCK_SEL);\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&dwmac->lock, flags);\n}\n\nstatic int visconti_eth_init_hw(struct platform_device *pdev, struct plat_stmmacenet_data *plat_dat)\n{\n\tstruct visconti_eth *dwmac = plat_dat->bsp_priv;\n\tunsigned int reg_val, clk_sel_val;\n\n\tswitch (plat_dat->phy_interface) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tdwmac->phy_intf_sel = ETHER_CONFIG_INTF_RGMII;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_MII:\n\t\tdwmac->phy_intf_sel = ETHER_CONFIG_INTF_MII;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tdwmac->phy_intf_sel = ETHER_CONFIG_INTF_RMII;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Unsupported phy-mode (%d)\\n\", plat_dat->phy_interface);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treg_val = dwmac->phy_intf_sel;\n\twritel(reg_val, dwmac->reg + REG_ETHER_CONTROL);\n\n\t \n\tclk_sel_val = ETHER_CLK_SEL_FREQ_SEL_125M;\n\twritel(clk_sel_val, dwmac->reg + REG_ETHER_CLOCK_SEL);\n\n\twritel((clk_sel_val | ETHER_CLK_SEL_RMII_CLK_EN | ETHER_CLK_SEL_RX_TX_CLK_EN),\n\t       dwmac->reg + REG_ETHER_CLOCK_SEL);\n\n\t \n\treg_val |= ETHER_ETH_CONTROL_RESET;\n\twritel(reg_val, dwmac->reg + REG_ETHER_CONTROL);\n\n\treturn 0;\n}\n\nstatic int visconti_eth_clock_probe(struct platform_device *pdev,\n\t\t\t\t    struct plat_stmmacenet_data *plat_dat)\n{\n\tstruct visconti_eth *dwmac = plat_dat->bsp_priv;\n\tint err;\n\n\tdwmac->phy_ref_clk = devm_clk_get(&pdev->dev, \"phy_ref_clk\");\n\tif (IS_ERR(dwmac->phy_ref_clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(dwmac->phy_ref_clk),\n\t\t\t\t     \"phy_ref_clk clock not found.\\n\");\n\n\terr = clk_prepare_enable(dwmac->phy_ref_clk);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to enable phy_ref clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void visconti_eth_clock_remove(struct platform_device *pdev)\n{\n\tstruct visconti_eth *dwmac = get_stmmac_bsp_priv(&pdev->dev);\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\n\tclk_disable_unprepare(dwmac->phy_ref_clk);\n\tclk_disable_unprepare(priv->plat->stmmac_clk);\n}\n\nstatic int visconti_eth_dwmac_probe(struct platform_device *pdev)\n{\n\tstruct plat_stmmacenet_data *plat_dat;\n\tstruct stmmac_resources stmmac_res;\n\tstruct visconti_eth *dwmac;\n\tint ret;\n\n\tret = stmmac_get_platform_resources(pdev, &stmmac_res);\n\tif (ret)\n\t\treturn ret;\n\n\tplat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);\n\tif (IS_ERR(plat_dat))\n\t\treturn PTR_ERR(plat_dat);\n\n\tdwmac = devm_kzalloc(&pdev->dev, sizeof(*dwmac), GFP_KERNEL);\n\tif (!dwmac) {\n\t\tret = -ENOMEM;\n\t\tgoto remove_config;\n\t}\n\n\tspin_lock_init(&dwmac->lock);\n\tdwmac->reg = stmmac_res.addr;\n\tdwmac->dev = &pdev->dev;\n\tplat_dat->bsp_priv = dwmac;\n\tplat_dat->fix_mac_speed = visconti_eth_fix_mac_speed;\n\n\tret = visconti_eth_clock_probe(pdev, plat_dat);\n\tif (ret)\n\t\tgoto remove_config;\n\n\tvisconti_eth_init_hw(pdev, plat_dat);\n\n\tplat_dat->dma_cfg->aal = 1;\n\n\tret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);\n\tif (ret)\n\t\tgoto remove;\n\n\treturn ret;\n\nremove:\n\tvisconti_eth_clock_remove(pdev);\nremove_config:\n\tstmmac_remove_config_dt(pdev, plat_dat);\n\n\treturn ret;\n}\n\nstatic void visconti_eth_dwmac_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\n\tstmmac_pltfr_remove(pdev);\n\n\tvisconti_eth_clock_remove(pdev);\n\n\tstmmac_remove_config_dt(pdev, priv->plat);\n}\n\nstatic const struct of_device_id visconti_eth_dwmac_match[] = {\n\t{ .compatible = \"toshiba,visconti-dwmac\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, visconti_eth_dwmac_match);\n\nstatic struct platform_driver visconti_eth_dwmac_driver = {\n\t.probe  = visconti_eth_dwmac_probe,\n\t.remove_new = visconti_eth_dwmac_remove,\n\t.driver = {\n\t\t.name           = \"visconti-eth-dwmac\",\n\t\t.of_match_table = visconti_eth_dwmac_match,\n\t},\n};\nmodule_platform_driver(visconti_eth_dwmac_driver);\n\nMODULE_AUTHOR(\"Toshiba\");\nMODULE_DESCRIPTION(\"Toshiba Visconti Ethernet DWMAC glue driver\");\nMODULE_AUTHOR(\"Nobuhiro Iwamatsu <nobuhiro1.iwamatsu@toshiba.co.jp\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}