{
  "module_name": "stmmac_tc.c",
  "hash_id": "636d88d3905a921974941abff23b65ca1b7348401c29741f6fe84fd0e0f476bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/stmmac_tc.c",
  "human_readable_source": "\n \n\n#include <net/pkt_cls.h>\n#include <net/tc_act/tc_gact.h>\n#include \"common.h\"\n#include \"dwmac4.h\"\n#include \"dwmac5.h\"\n#include \"stmmac.h\"\n\nstatic void tc_fill_all_pass_entry(struct stmmac_tc_entry *entry)\n{\n\tmemset(entry, 0, sizeof(*entry));\n\tentry->in_use = true;\n\tentry->is_last = true;\n\tentry->is_frag = false;\n\tentry->prio = ~0x0;\n\tentry->handle = 0;\n\tentry->val.match_data = 0x0;\n\tentry->val.match_en = 0x0;\n\tentry->val.af = 1;\n\tentry->val.dma_ch_no = 0x0;\n}\n\nstatic struct stmmac_tc_entry *tc_find_entry(struct stmmac_priv *priv,\n\t\t\t\t\t     struct tc_cls_u32_offload *cls,\n\t\t\t\t\t     bool free)\n{\n\tstruct stmmac_tc_entry *entry, *first = NULL, *dup = NULL;\n\tu32 loc = cls->knode.handle;\n\tint i;\n\n\tfor (i = 0; i < priv->tc_entries_max; i++) {\n\t\tentry = &priv->tc_entries[i];\n\t\tif (!entry->in_use && !first && free)\n\t\t\tfirst = entry;\n\t\tif ((entry->handle == loc) && !free && !entry->is_frag)\n\t\t\tdup = entry;\n\t}\n\n\tif (dup)\n\t\treturn dup;\n\tif (first) {\n\t\tfirst->handle = loc;\n\t\tfirst->in_use = true;\n\n\t\t \n\t\tmemset(&first->val, 0, sizeof(first->val));\n\t}\n\n\treturn first;\n}\n\nstatic int tc_fill_actions(struct stmmac_tc_entry *entry,\n\t\t\t   struct stmmac_tc_entry *frag,\n\t\t\t   struct tc_cls_u32_offload *cls)\n{\n\tstruct stmmac_tc_entry *action_entry = entry;\n\tconst struct tc_action *act;\n\tstruct tcf_exts *exts;\n\tint i;\n\n\texts = cls->knode.exts;\n\tif (!tcf_exts_has_actions(exts))\n\t\treturn -EINVAL;\n\tif (frag)\n\t\taction_entry = frag;\n\n\ttcf_exts_for_each_action(i, act, exts) {\n\t\t \n\t\tif (is_tcf_gact_ok(act)) {\n\t\t\taction_entry->val.af = 1;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (is_tcf_gact_shot(act)) {\n\t\t\taction_entry->val.rf = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int tc_fill_entry(struct stmmac_priv *priv,\n\t\t\t struct tc_cls_u32_offload *cls)\n{\n\tstruct stmmac_tc_entry *entry, *frag = NULL;\n\tstruct tc_u32_sel *sel = cls->knode.sel;\n\tu32 off, data, mask, real_off, rem;\n\tu32 prio = cls->common.prio << 16;\n\tint ret;\n\n\t \n\tif (sel->nkeys <= 0 || sel->nkeys > 1)\n\t\treturn -EINVAL;\n\n\toff = sel->keys[0].off << sel->offshift;\n\tdata = sel->keys[0].val;\n\tmask = sel->keys[0].mask;\n\n\tswitch (ntohs(cls->common.protocol)) {\n\tcase ETH_P_ALL:\n\t\tbreak;\n\tcase ETH_P_IP:\n\t\toff += ETH_HLEN;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (off > priv->tc_off_max)\n\t\treturn -EINVAL;\n\n\treal_off = off / 4;\n\trem = off % 4;\n\n\tentry = tc_find_entry(priv, cls, true);\n\tif (!entry)\n\t\treturn -EINVAL;\n\n\tif (rem) {\n\t\tfrag = tc_find_entry(priv, cls, true);\n\t\tif (!frag) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_unuse;\n\t\t}\n\n\t\tentry->frag_ptr = frag;\n\t\tentry->val.match_en = (mask << (rem * 8)) &\n\t\t\tGENMASK(31, rem * 8);\n\t\tentry->val.match_data = (data << (rem * 8)) &\n\t\t\tGENMASK(31, rem * 8);\n\t\tentry->val.frame_offset = real_off;\n\t\tentry->prio = prio;\n\n\t\tfrag->val.match_en = (mask >> (rem * 8)) &\n\t\t\tGENMASK(rem * 8 - 1, 0);\n\t\tfrag->val.match_data = (data >> (rem * 8)) &\n\t\t\tGENMASK(rem * 8 - 1, 0);\n\t\tfrag->val.frame_offset = real_off + 1;\n\t\tfrag->prio = prio;\n\t\tfrag->is_frag = true;\n\t} else {\n\t\tentry->frag_ptr = NULL;\n\t\tentry->val.match_en = mask;\n\t\tentry->val.match_data = data;\n\t\tentry->val.frame_offset = real_off;\n\t\tentry->prio = prio;\n\t}\n\n\tret = tc_fill_actions(entry, frag, cls);\n\tif (ret)\n\t\tgoto err_unuse;\n\n\treturn 0;\n\nerr_unuse:\n\tif (frag)\n\t\tfrag->in_use = false;\n\tentry->in_use = false;\n\treturn ret;\n}\n\nstatic void tc_unfill_entry(struct stmmac_priv *priv,\n\t\t\t    struct tc_cls_u32_offload *cls)\n{\n\tstruct stmmac_tc_entry *entry;\n\n\tentry = tc_find_entry(priv, cls, false);\n\tif (!entry)\n\t\treturn;\n\n\tentry->in_use = false;\n\tif (entry->frag_ptr) {\n\t\tentry = entry->frag_ptr;\n\t\tentry->is_frag = false;\n\t\tentry->in_use = false;\n\t}\n}\n\nstatic int tc_config_knode(struct stmmac_priv *priv,\n\t\t\t   struct tc_cls_u32_offload *cls)\n{\n\tint ret;\n\n\tret = tc_fill_entry(priv, cls);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stmmac_rxp_config(priv, priv->hw->pcsr, priv->tc_entries,\n\t\t\tpriv->tc_entries_max);\n\tif (ret)\n\t\tgoto err_unfill;\n\n\treturn 0;\n\nerr_unfill:\n\ttc_unfill_entry(priv, cls);\n\treturn ret;\n}\n\nstatic int tc_delete_knode(struct stmmac_priv *priv,\n\t\t\t   struct tc_cls_u32_offload *cls)\n{\n\t \n\ttc_unfill_entry(priv, cls);\n\n\treturn stmmac_rxp_config(priv, priv->hw->pcsr, priv->tc_entries,\n\t\t\t\t priv->tc_entries_max);\n}\n\nstatic int tc_setup_cls_u32(struct stmmac_priv *priv,\n\t\t\t    struct tc_cls_u32_offload *cls)\n{\n\tswitch (cls->command) {\n\tcase TC_CLSU32_REPLACE_KNODE:\n\t\ttc_unfill_entry(priv, cls);\n\t\tfallthrough;\n\tcase TC_CLSU32_NEW_KNODE:\n\t\treturn tc_config_knode(priv, cls);\n\tcase TC_CLSU32_DELETE_KNODE:\n\t\treturn tc_delete_knode(priv, cls);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int tc_rfs_init(struct stmmac_priv *priv)\n{\n\tint i;\n\n\tpriv->rfs_entries_max[STMMAC_RFS_T_VLAN] = 8;\n\tpriv->rfs_entries_max[STMMAC_RFS_T_LLDP] = 1;\n\tpriv->rfs_entries_max[STMMAC_RFS_T_1588] = 1;\n\n\tfor (i = 0; i < STMMAC_RFS_T_MAX; i++)\n\t\tpriv->rfs_entries_total += priv->rfs_entries_max[i];\n\n\tpriv->rfs_entries = devm_kcalloc(priv->device,\n\t\t\t\t\t priv->rfs_entries_total,\n\t\t\t\t\t sizeof(*priv->rfs_entries),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!priv->rfs_entries)\n\t\treturn -ENOMEM;\n\n\tdev_info(priv->device, \"Enabled RFS Flow TC (entries=%d)\\n\",\n\t\t priv->rfs_entries_total);\n\n\treturn 0;\n}\n\nstatic int tc_init(struct stmmac_priv *priv)\n{\n\tstruct dma_features *dma_cap = &priv->dma_cap;\n\tunsigned int count;\n\tint ret, i;\n\n\tif (dma_cap->l3l4fnum) {\n\t\tpriv->flow_entries_max = dma_cap->l3l4fnum;\n\t\tpriv->flow_entries = devm_kcalloc(priv->device,\n\t\t\t\t\t\t  dma_cap->l3l4fnum,\n\t\t\t\t\t\t  sizeof(*priv->flow_entries),\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!priv->flow_entries)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < priv->flow_entries_max; i++)\n\t\t\tpriv->flow_entries[i].idx = i;\n\n\t\tdev_info(priv->device, \"Enabled L3L4 Flow TC (entries=%d)\\n\",\n\t\t\t priv->flow_entries_max);\n\t}\n\n\tret = tc_rfs_init(priv);\n\tif (ret)\n\t\treturn -ENOMEM;\n\n\tif (!priv->plat->fpe_cfg) {\n\t\tpriv->plat->fpe_cfg = devm_kzalloc(priv->device,\n\t\t\t\t\t\t   sizeof(*priv->plat->fpe_cfg),\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!priv->plat->fpe_cfg)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tmemset(priv->plat->fpe_cfg, 0, sizeof(*priv->plat->fpe_cfg));\n\t}\n\n\t \n\tif (!dma_cap->frpsel)\n\t\treturn 0;\n\n\tswitch (dma_cap->frpbs) {\n\tcase 0x0:\n\t\tpriv->tc_off_max = 64;\n\t\tbreak;\n\tcase 0x1:\n\t\tpriv->tc_off_max = 128;\n\t\tbreak;\n\tcase 0x2:\n\t\tpriv->tc_off_max = 256;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (dma_cap->frpes) {\n\tcase 0x0:\n\t\tcount = 64;\n\t\tbreak;\n\tcase 0x1:\n\t\tcount = 128;\n\t\tbreak;\n\tcase 0x2:\n\t\tcount = 256;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpriv->tc_entries_max = count;\n\tpriv->tc_entries = devm_kcalloc(priv->device,\n\t\t\tcount, sizeof(*priv->tc_entries), GFP_KERNEL);\n\tif (!priv->tc_entries)\n\t\treturn -ENOMEM;\n\n\ttc_fill_all_pass_entry(&priv->tc_entries[count - 1]);\n\n\tdev_info(priv->device, \"Enabling HW TC (entries=%d, max_off=%d)\\n\",\n\t\t\tpriv->tc_entries_max, priv->tc_off_max);\n\n\treturn 0;\n}\n\nstatic int tc_setup_cbs(struct stmmac_priv *priv,\n\t\t\tstruct tc_cbs_qopt_offload *qopt)\n{\n\tu32 tx_queues_count = priv->plat->tx_queues_to_use;\n\tu32 queue = qopt->queue;\n\tu32 ptr, speed_div;\n\tu32 mode_to_use;\n\tu64 value;\n\tint ret;\n\n\t \n\tif (queue <= 0 || queue >= tx_queues_count)\n\t\treturn -EINVAL;\n\tif (!priv->dma_cap.av)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tswitch (priv->speed) {\n\tcase SPEED_10000:\n\t\tptr = 32;\n\t\tspeed_div = 10000000;\n\t\tbreak;\n\tcase SPEED_5000:\n\t\tptr = 32;\n\t\tspeed_div = 5000000;\n\t\tbreak;\n\tcase SPEED_2500:\n\t\tptr = 8;\n\t\tspeed_div = 2500000;\n\t\tbreak;\n\tcase SPEED_1000:\n\t\tptr = 8;\n\t\tspeed_div = 1000000;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tptr = 4;\n\t\tspeed_div = 100000;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmode_to_use = priv->plat->tx_queues_cfg[queue].mode_to_use;\n\tif (mode_to_use == MTL_QUEUE_DCB && qopt->enable) {\n\t\tret = stmmac_dma_qmode(priv, priv->ioaddr, queue, MTL_QUEUE_AVB);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpriv->plat->tx_queues_cfg[queue].mode_to_use = MTL_QUEUE_AVB;\n\t} else if (!qopt->enable) {\n\t\tret = stmmac_dma_qmode(priv, priv->ioaddr, queue,\n\t\t\t\t       MTL_QUEUE_DCB);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpriv->plat->tx_queues_cfg[queue].mode_to_use = MTL_QUEUE_DCB;\n\t}\n\n\t \n\tvalue = div_s64(qopt->idleslope * 1024ll * ptr, speed_div);\n\tpriv->plat->tx_queues_cfg[queue].idle_slope = value & GENMASK(31, 0);\n\n\tvalue = div_s64(-qopt->sendslope * 1024ll * ptr, speed_div);\n\tpriv->plat->tx_queues_cfg[queue].send_slope = value & GENMASK(31, 0);\n\n\tvalue = qopt->hicredit * 1024ll * 8;\n\tpriv->plat->tx_queues_cfg[queue].high_credit = value & GENMASK(31, 0);\n\n\tvalue = qopt->locredit * 1024ll * 8;\n\tpriv->plat->tx_queues_cfg[queue].low_credit = value & GENMASK(31, 0);\n\n\tret = stmmac_config_cbs(priv, priv->hw,\n\t\t\t\tpriv->plat->tx_queues_cfg[queue].send_slope,\n\t\t\t\tpriv->plat->tx_queues_cfg[queue].idle_slope,\n\t\t\t\tpriv->plat->tx_queues_cfg[queue].high_credit,\n\t\t\t\tpriv->plat->tx_queues_cfg[queue].low_credit,\n\t\t\t\tqueue);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(priv->device, \"CBS queue %d: send %d, idle %d, hi %d, lo %d\\n\",\n\t\t\tqueue, qopt->sendslope, qopt->idleslope,\n\t\t\tqopt->hicredit, qopt->locredit);\n\treturn 0;\n}\n\nstatic int tc_parse_flow_actions(struct stmmac_priv *priv,\n\t\t\t\t struct flow_action *action,\n\t\t\t\t struct stmmac_flow_entry *entry,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct flow_action_entry *act;\n\tint i;\n\n\tif (!flow_action_has_entries(action))\n\t\treturn -EINVAL;\n\n\tif (!flow_action_basic_hw_stats_check(action, extack))\n\t\treturn -EOPNOTSUPP;\n\n\tflow_action_for_each(i, act, action) {\n\t\tswitch (act->id) {\n\t\tcase FLOW_ACTION_DROP:\n\t\t\tentry->action |= STMMAC_FLOW_ACTION_DROP;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\treturn 0;\n}\n\n#define ETHER_TYPE_FULL_MASK\tcpu_to_be16(~0)\n\nstatic int tc_add_basic_flow(struct stmmac_priv *priv,\n\t\t\t     struct flow_cls_offload *cls,\n\t\t\t     struct stmmac_flow_entry *entry)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(cls);\n\tstruct flow_dissector *dissector = rule->match.dissector;\n\tstruct flow_match_basic match;\n\n\t \n\tif (!dissector_uses_key(dissector, FLOW_DISSECTOR_KEY_BASIC))\n\t\treturn -EINVAL;\n\n\tflow_rule_match_basic(rule, &match);\n\n\tentry->ip_proto = match.key->ip_proto;\n\treturn 0;\n}\n\nstatic int tc_add_ip4_flow(struct stmmac_priv *priv,\n\t\t\t   struct flow_cls_offload *cls,\n\t\t\t   struct stmmac_flow_entry *entry)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(cls);\n\tstruct flow_dissector *dissector = rule->match.dissector;\n\tbool inv = entry->action & STMMAC_FLOW_ACTION_DROP;\n\tstruct flow_match_ipv4_addrs match;\n\tu32 hw_match;\n\tint ret;\n\n\t \n\tif (!dissector_uses_key(dissector, FLOW_DISSECTOR_KEY_IPV4_ADDRS))\n\t\treturn -EINVAL;\n\n\tflow_rule_match_ipv4_addrs(rule, &match);\n\thw_match = ntohl(match.key->src) & ntohl(match.mask->src);\n\tif (hw_match) {\n\t\tret = stmmac_config_l3_filter(priv, priv->hw, entry->idx, true,\n\t\t\t\t\t      false, true, inv, hw_match);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\thw_match = ntohl(match.key->dst) & ntohl(match.mask->dst);\n\tif (hw_match) {\n\t\tret = stmmac_config_l3_filter(priv, priv->hw, entry->idx, true,\n\t\t\t\t\t      false, false, inv, hw_match);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tc_add_ports_flow(struct stmmac_priv *priv,\n\t\t\t     struct flow_cls_offload *cls,\n\t\t\t     struct stmmac_flow_entry *entry)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(cls);\n\tstruct flow_dissector *dissector = rule->match.dissector;\n\tbool inv = entry->action & STMMAC_FLOW_ACTION_DROP;\n\tstruct flow_match_ports match;\n\tu32 hw_match;\n\tbool is_udp;\n\tint ret;\n\n\t \n\tif (!dissector_uses_key(dissector, FLOW_DISSECTOR_KEY_PORTS))\n\t\treturn -EINVAL;\n\n\tswitch (entry->ip_proto) {\n\tcase IPPROTO_TCP:\n\t\tis_udp = false;\n\t\tbreak;\n\tcase IPPROTO_UDP:\n\t\tis_udp = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tflow_rule_match_ports(rule, &match);\n\n\thw_match = ntohs(match.key->src) & ntohs(match.mask->src);\n\tif (hw_match) {\n\t\tret = stmmac_config_l4_filter(priv, priv->hw, entry->idx, true,\n\t\t\t\t\t      is_udp, true, inv, hw_match);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\thw_match = ntohs(match.key->dst) & ntohs(match.mask->dst);\n\tif (hw_match) {\n\t\tret = stmmac_config_l4_filter(priv, priv->hw, entry->idx, true,\n\t\t\t\t\t      is_udp, false, inv, hw_match);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tentry->is_l4 = true;\n\treturn 0;\n}\n\nstatic struct stmmac_flow_entry *tc_find_flow(struct stmmac_priv *priv,\n\t\t\t\t\t      struct flow_cls_offload *cls,\n\t\t\t\t\t      bool get_free)\n{\n\tint i;\n\n\tfor (i = 0; i < priv->flow_entries_max; i++) {\n\t\tstruct stmmac_flow_entry *entry = &priv->flow_entries[i];\n\n\t\tif (entry->cookie == cls->cookie)\n\t\t\treturn entry;\n\t\tif (get_free && (entry->in_use == false))\n\t\t\treturn entry;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct {\n\tint (*fn)(struct stmmac_priv *priv, struct flow_cls_offload *cls,\n\t\t  struct stmmac_flow_entry *entry);\n} tc_flow_parsers[] = {\n\t{ .fn = tc_add_basic_flow },\n\t{ .fn = tc_add_ip4_flow },\n\t{ .fn = tc_add_ports_flow },\n};\n\nstatic int tc_add_flow(struct stmmac_priv *priv,\n\t\t       struct flow_cls_offload *cls)\n{\n\tstruct stmmac_flow_entry *entry = tc_find_flow(priv, cls, false);\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(cls);\n\tint i, ret;\n\n\tif (!entry) {\n\t\tentry = tc_find_flow(priv, cls, true);\n\t\tif (!entry)\n\t\t\treturn -ENOENT;\n\t}\n\n\tret = tc_parse_flow_actions(priv, &rule->action, entry,\n\t\t\t\t    cls->common.extack);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(tc_flow_parsers); i++) {\n\t\tret = tc_flow_parsers[i].fn(priv, cls, entry);\n\t\tif (!ret)\n\t\t\tentry->in_use = true;\n\t}\n\n\tif (!entry->in_use)\n\t\treturn -EINVAL;\n\n\tentry->cookie = cls->cookie;\n\treturn 0;\n}\n\nstatic int tc_del_flow(struct stmmac_priv *priv,\n\t\t       struct flow_cls_offload *cls)\n{\n\tstruct stmmac_flow_entry *entry = tc_find_flow(priv, cls, false);\n\tint ret;\n\n\tif (!entry || !entry->in_use)\n\t\treturn -ENOENT;\n\n\tif (entry->is_l4) {\n\t\tret = stmmac_config_l4_filter(priv, priv->hw, entry->idx, false,\n\t\t\t\t\t      false, false, false, 0);\n\t} else {\n\t\tret = stmmac_config_l3_filter(priv, priv->hw, entry->idx, false,\n\t\t\t\t\t      false, false, false, 0);\n\t}\n\n\tentry->in_use = false;\n\tentry->cookie = 0;\n\tentry->is_l4 = false;\n\treturn ret;\n}\n\nstatic struct stmmac_rfs_entry *tc_find_rfs(struct stmmac_priv *priv,\n\t\t\t\t\t    struct flow_cls_offload *cls,\n\t\t\t\t\t    bool get_free)\n{\n\tint i;\n\n\tfor (i = 0; i < priv->rfs_entries_total; i++) {\n\t\tstruct stmmac_rfs_entry *entry = &priv->rfs_entries[i];\n\n\t\tif (entry->cookie == cls->cookie)\n\t\t\treturn entry;\n\t\tif (get_free && entry->in_use == false)\n\t\t\treturn entry;\n\t}\n\n\treturn NULL;\n}\n\n#define VLAN_PRIO_FULL_MASK (0x07)\n\nstatic int tc_add_vlan_flow(struct stmmac_priv *priv,\n\t\t\t    struct flow_cls_offload *cls)\n{\n\tstruct stmmac_rfs_entry *entry = tc_find_rfs(priv, cls, false);\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(cls);\n\tstruct flow_dissector *dissector = rule->match.dissector;\n\tint tc = tc_classid_to_hwtc(priv->dev, cls->classid);\n\tstruct flow_match_vlan match;\n\n\tif (!entry) {\n\t\tentry = tc_find_rfs(priv, cls, true);\n\t\tif (!entry)\n\t\t\treturn -ENOENT;\n\t}\n\n\tif (priv->rfs_entries_cnt[STMMAC_RFS_T_VLAN] >=\n\t    priv->rfs_entries_max[STMMAC_RFS_T_VLAN])\n\t\treturn -ENOENT;\n\n\t \n\tif (!dissector_uses_key(dissector, FLOW_DISSECTOR_KEY_VLAN))\n\t\treturn -EINVAL;\n\n\tif (tc < 0) {\n\t\tnetdev_err(priv->dev, \"Invalid traffic class\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tflow_rule_match_vlan(rule, &match);\n\n\tif (match.mask->vlan_priority) {\n\t\tu32 prio;\n\n\t\tif (match.mask->vlan_priority != VLAN_PRIO_FULL_MASK) {\n\t\t\tnetdev_err(priv->dev, \"Only full mask is supported for VLAN priority\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tprio = BIT(match.key->vlan_priority);\n\t\tstmmac_rx_queue_prio(priv, priv->hw, prio, tc);\n\n\t\tentry->in_use = true;\n\t\tentry->cookie = cls->cookie;\n\t\tentry->tc = tc;\n\t\tentry->type = STMMAC_RFS_T_VLAN;\n\t\tpriv->rfs_entries_cnt[STMMAC_RFS_T_VLAN]++;\n\t}\n\n\treturn 0;\n}\n\nstatic int tc_del_vlan_flow(struct stmmac_priv *priv,\n\t\t\t    struct flow_cls_offload *cls)\n{\n\tstruct stmmac_rfs_entry *entry = tc_find_rfs(priv, cls, false);\n\n\tif (!entry || !entry->in_use || entry->type != STMMAC_RFS_T_VLAN)\n\t\treturn -ENOENT;\n\n\tstmmac_rx_queue_prio(priv, priv->hw, 0, entry->tc);\n\n\tentry->in_use = false;\n\tentry->cookie = 0;\n\tentry->tc = 0;\n\tentry->type = 0;\n\n\tpriv->rfs_entries_cnt[STMMAC_RFS_T_VLAN]--;\n\n\treturn 0;\n}\n\nstatic int tc_add_ethtype_flow(struct stmmac_priv *priv,\n\t\t\t       struct flow_cls_offload *cls)\n{\n\tstruct stmmac_rfs_entry *entry = tc_find_rfs(priv, cls, false);\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(cls);\n\tstruct flow_dissector *dissector = rule->match.dissector;\n\tint tc = tc_classid_to_hwtc(priv->dev, cls->classid);\n\tstruct flow_match_basic match;\n\n\tif (!entry) {\n\t\tentry = tc_find_rfs(priv, cls, true);\n\t\tif (!entry)\n\t\t\treturn -ENOENT;\n\t}\n\n\t \n\tif (!dissector_uses_key(dissector, FLOW_DISSECTOR_KEY_BASIC))\n\t\treturn -EINVAL;\n\n\tif (tc < 0) {\n\t\tnetdev_err(priv->dev, \"Invalid traffic class\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tflow_rule_match_basic(rule, &match);\n\n\tif (match.mask->n_proto) {\n\t\tu16 etype = ntohs(match.key->n_proto);\n\n\t\tif (match.mask->n_proto != ETHER_TYPE_FULL_MASK) {\n\t\t\tnetdev_err(priv->dev, \"Only full mask is supported for EthType filter\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tswitch (etype) {\n\t\tcase ETH_P_LLDP:\n\t\t\tif (priv->rfs_entries_cnt[STMMAC_RFS_T_LLDP] >=\n\t\t\t    priv->rfs_entries_max[STMMAC_RFS_T_LLDP])\n\t\t\t\treturn -ENOENT;\n\n\t\t\tentry->type = STMMAC_RFS_T_LLDP;\n\t\t\tpriv->rfs_entries_cnt[STMMAC_RFS_T_LLDP]++;\n\n\t\t\tstmmac_rx_queue_routing(priv, priv->hw,\n\t\t\t\t\t\tPACKET_DCBCPQ, tc);\n\t\t\tbreak;\n\t\tcase ETH_P_1588:\n\t\t\tif (priv->rfs_entries_cnt[STMMAC_RFS_T_1588] >=\n\t\t\t    priv->rfs_entries_max[STMMAC_RFS_T_1588])\n\t\t\t\treturn -ENOENT;\n\n\t\t\tentry->type = STMMAC_RFS_T_1588;\n\t\t\tpriv->rfs_entries_cnt[STMMAC_RFS_T_1588]++;\n\n\t\t\tstmmac_rx_queue_routing(priv, priv->hw,\n\t\t\t\t\t\tPACKET_PTPQ, tc);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetdev_err(priv->dev, \"EthType(0x%x) is not supported\", etype);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tentry->in_use = true;\n\t\tentry->cookie = cls->cookie;\n\t\tentry->tc = tc;\n\t\tentry->etype = etype;\n\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int tc_del_ethtype_flow(struct stmmac_priv *priv,\n\t\t\t       struct flow_cls_offload *cls)\n{\n\tstruct stmmac_rfs_entry *entry = tc_find_rfs(priv, cls, false);\n\n\tif (!entry || !entry->in_use ||\n\t    entry->type < STMMAC_RFS_T_LLDP ||\n\t    entry->type > STMMAC_RFS_T_1588)\n\t\treturn -ENOENT;\n\n\tswitch (entry->etype) {\n\tcase ETH_P_LLDP:\n\t\tstmmac_rx_queue_routing(priv, priv->hw,\n\t\t\t\t\tPACKET_DCBCPQ, 0);\n\t\tpriv->rfs_entries_cnt[STMMAC_RFS_T_LLDP]--;\n\t\tbreak;\n\tcase ETH_P_1588:\n\t\tstmmac_rx_queue_routing(priv, priv->hw,\n\t\t\t\t\tPACKET_PTPQ, 0);\n\t\tpriv->rfs_entries_cnt[STMMAC_RFS_T_1588]--;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(priv->dev, \"EthType(0x%x) is not supported\",\n\t\t\t   entry->etype);\n\t\treturn -EINVAL;\n\t}\n\n\tentry->in_use = false;\n\tentry->cookie = 0;\n\tentry->tc = 0;\n\tentry->etype = 0;\n\tentry->type = 0;\n\n\treturn 0;\n}\n\nstatic int tc_add_flow_cls(struct stmmac_priv *priv,\n\t\t\t   struct flow_cls_offload *cls)\n{\n\tint ret;\n\n\tret = tc_add_flow(priv, cls);\n\tif (!ret)\n\t\treturn ret;\n\n\tret = tc_add_ethtype_flow(priv, cls);\n\tif (!ret)\n\t\treturn ret;\n\n\treturn tc_add_vlan_flow(priv, cls);\n}\n\nstatic int tc_del_flow_cls(struct stmmac_priv *priv,\n\t\t\t   struct flow_cls_offload *cls)\n{\n\tint ret;\n\n\tret = tc_del_flow(priv, cls);\n\tif (!ret)\n\t\treturn ret;\n\n\tret = tc_del_ethtype_flow(priv, cls);\n\tif (!ret)\n\t\treturn ret;\n\n\treturn tc_del_vlan_flow(priv, cls);\n}\n\nstatic int tc_setup_cls(struct stmmac_priv *priv,\n\t\t\tstruct flow_cls_offload *cls)\n{\n\tint ret = 0;\n\n\t \n\tif (priv->rss.enable)\n\t\treturn -EBUSY;\n\n\tswitch (cls->command) {\n\tcase FLOW_CLS_REPLACE:\n\t\tret = tc_add_flow_cls(priv, cls);\n\t\tbreak;\n\tcase FLOW_CLS_DESTROY:\n\t\tret = tc_del_flow_cls(priv, cls);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstruct timespec64 stmmac_calc_tas_basetime(ktime_t old_base_time,\n\t\t\t\t\t   ktime_t current_time,\n\t\t\t\t\t   u64 cycle_time)\n{\n\tstruct timespec64 time;\n\n\tif (ktime_after(old_base_time, current_time)) {\n\t\ttime = ktime_to_timespec64(old_base_time);\n\t} else {\n\t\ts64 n;\n\t\tktime_t base_time;\n\n\t\tn = div64_s64(ktime_sub_ns(current_time, old_base_time),\n\t\t\t      cycle_time);\n\t\tbase_time = ktime_add_ns(old_base_time,\n\t\t\t\t\t (n + 1) * cycle_time);\n\n\t\ttime = ktime_to_timespec64(base_time);\n\t}\n\n\treturn time;\n}\n\nstatic int tc_setup_taprio(struct stmmac_priv *priv,\n\t\t\t   struct tc_taprio_qopt_offload *qopt)\n{\n\tu32 size, wid = priv->dma_cap.estwid, dep = priv->dma_cap.estdep;\n\tstruct plat_stmmacenet_data *plat = priv->plat;\n\tstruct timespec64 time, current_time, qopt_time;\n\tktime_t current_time_ns;\n\tbool fpe = false;\n\tint i, ret = 0;\n\tu64 ctr;\n\n\tif (qopt->base_time < 0)\n\t\treturn -ERANGE;\n\n\tif (!priv->dma_cap.estsel)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (wid) {\n\tcase 0x1:\n\t\twid = 16;\n\t\tbreak;\n\tcase 0x2:\n\t\twid = 20;\n\t\tbreak;\n\tcase 0x3:\n\t\twid = 24;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (dep) {\n\tcase 0x1:\n\t\tdep = 64;\n\t\tbreak;\n\tcase 0x2:\n\t\tdep = 128;\n\t\tbreak;\n\tcase 0x3:\n\t\tdep = 256;\n\t\tbreak;\n\tcase 0x4:\n\t\tdep = 512;\n\t\tbreak;\n\tcase 0x5:\n\t\tdep = 1024;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (qopt->cmd == TAPRIO_CMD_DESTROY)\n\t\tgoto disable;\n\telse if (qopt->cmd != TAPRIO_CMD_REPLACE)\n\t\treturn -EOPNOTSUPP;\n\n\tif (qopt->num_entries >= dep)\n\t\treturn -EINVAL;\n\tif (!qopt->cycle_time)\n\t\treturn -ERANGE;\n\n\tif (!plat->est) {\n\t\tplat->est = devm_kzalloc(priv->device, sizeof(*plat->est),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!plat->est)\n\t\t\treturn -ENOMEM;\n\n\t\tmutex_init(&priv->plat->est->lock);\n\t} else {\n\t\tmemset(plat->est, 0, sizeof(*plat->est));\n\t}\n\n\tsize = qopt->num_entries;\n\n\tmutex_lock(&priv->plat->est->lock);\n\tpriv->plat->est->gcl_size = size;\n\tpriv->plat->est->enable = qopt->cmd == TAPRIO_CMD_REPLACE;\n\tmutex_unlock(&priv->plat->est->lock);\n\n\tfor (i = 0; i < size; i++) {\n\t\ts64 delta_ns = qopt->entries[i].interval;\n\t\tu32 gates = qopt->entries[i].gate_mask;\n\n\t\tif (delta_ns > GENMASK(wid, 0))\n\t\t\treturn -ERANGE;\n\t\tif (gates > GENMASK(31 - wid, 0))\n\t\t\treturn -ERANGE;\n\n\t\tswitch (qopt->entries[i].command) {\n\t\tcase TC_TAPRIO_CMD_SET_GATES:\n\t\t\tif (fpe)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase TC_TAPRIO_CMD_SET_AND_HOLD:\n\t\t\tgates |= BIT(0);\n\t\t\tfpe = true;\n\t\t\tbreak;\n\t\tcase TC_TAPRIO_CMD_SET_AND_RELEASE:\n\t\t\tgates &= ~BIT(0);\n\t\t\tfpe = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tpriv->plat->est->gcl[i] = delta_ns | (gates << wid);\n\t}\n\n\tmutex_lock(&priv->plat->est->lock);\n\t \n\tpriv->ptp_clock_ops.gettime64(&priv->ptp_clock_ops, &current_time);\n\tcurrent_time_ns = timespec64_to_ktime(current_time);\n\ttime = stmmac_calc_tas_basetime(qopt->base_time, current_time_ns,\n\t\t\t\t\tqopt->cycle_time);\n\n\tpriv->plat->est->btr[0] = (u32)time.tv_nsec;\n\tpriv->plat->est->btr[1] = (u32)time.tv_sec;\n\n\tqopt_time = ktime_to_timespec64(qopt->base_time);\n\tpriv->plat->est->btr_reserve[0] = (u32)qopt_time.tv_nsec;\n\tpriv->plat->est->btr_reserve[1] = (u32)qopt_time.tv_sec;\n\n\tctr = qopt->cycle_time;\n\tpriv->plat->est->ctr[0] = do_div(ctr, NSEC_PER_SEC);\n\tpriv->plat->est->ctr[1] = (u32)ctr;\n\n\tif (fpe && !priv->dma_cap.fpesel) {\n\t\tmutex_unlock(&priv->plat->est->lock);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tpriv->plat->fpe_cfg->enable = fpe;\n\n\tret = stmmac_est_configure(priv, priv->ioaddr, priv->plat->est,\n\t\t\t\t   priv->plat->clk_ptp_rate);\n\tmutex_unlock(&priv->plat->est->lock);\n\tif (ret) {\n\t\tnetdev_err(priv->dev, \"failed to configure EST\\n\");\n\t\tgoto disable;\n\t}\n\n\tnetdev_info(priv->dev, \"configured EST\\n\");\n\n\tif (fpe) {\n\t\tstmmac_fpe_handshake(priv, true);\n\t\tnetdev_info(priv->dev, \"start FPE handshake\\n\");\n\t}\n\n\treturn 0;\n\ndisable:\n\tif (priv->plat->est) {\n\t\tmutex_lock(&priv->plat->est->lock);\n\t\tpriv->plat->est->enable = false;\n\t\tstmmac_est_configure(priv, priv->ioaddr, priv->plat->est,\n\t\t\t\t     priv->plat->clk_ptp_rate);\n\t\tmutex_unlock(&priv->plat->est->lock);\n\t}\n\n\tpriv->plat->fpe_cfg->enable = false;\n\tstmmac_fpe_configure(priv, priv->ioaddr,\n\t\t\t     priv->plat->fpe_cfg,\n\t\t\t     priv->plat->tx_queues_to_use,\n\t\t\t     priv->plat->rx_queues_to_use,\n\t\t\t     false);\n\tnetdev_info(priv->dev, \"disabled FPE\\n\");\n\n\tstmmac_fpe_handshake(priv, false);\n\tnetdev_info(priv->dev, \"stop FPE handshake\\n\");\n\n\treturn ret;\n}\n\nstatic int tc_setup_etf(struct stmmac_priv *priv,\n\t\t\tstruct tc_etf_qopt_offload *qopt)\n{\n\tif (!priv->dma_cap.tbssel)\n\t\treturn -EOPNOTSUPP;\n\tif (qopt->queue >= priv->plat->tx_queues_to_use)\n\t\treturn -EINVAL;\n\tif (!(priv->dma_conf.tx_queue[qopt->queue].tbs & STMMAC_TBS_AVAIL))\n\t\treturn -EINVAL;\n\n\tif (qopt->enable)\n\t\tpriv->dma_conf.tx_queue[qopt->queue].tbs |= STMMAC_TBS_EN;\n\telse\n\t\tpriv->dma_conf.tx_queue[qopt->queue].tbs &= ~STMMAC_TBS_EN;\n\n\tnetdev_info(priv->dev, \"%s ETF for Queue %d\\n\",\n\t\t    qopt->enable ? \"enabled\" : \"disabled\", qopt->queue);\n\treturn 0;\n}\n\nstatic int tc_query_caps(struct stmmac_priv *priv,\n\t\t\t struct tc_query_caps_base *base)\n{\n\tswitch (base->type) {\n\tcase TC_SETUP_QDISC_TAPRIO: {\n\t\tstruct tc_taprio_caps *caps = base->caps;\n\n\t\tif (!priv->dma_cap.estsel)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tcaps->gate_mask_per_txq = true;\n\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nconst struct stmmac_tc_ops dwmac510_tc_ops = {\n\t.init = tc_init,\n\t.setup_cls_u32 = tc_setup_cls_u32,\n\t.setup_cbs = tc_setup_cbs,\n\t.setup_cls = tc_setup_cls,\n\t.setup_taprio = tc_setup_taprio,\n\t.setup_etf = tc_setup_etf,\n\t.query_caps = tc_query_caps,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}