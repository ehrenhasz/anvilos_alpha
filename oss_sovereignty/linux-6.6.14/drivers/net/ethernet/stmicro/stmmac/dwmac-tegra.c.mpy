{
  "module_name": "dwmac-tegra.c",
  "hash_id": "842d97ff82bd13a39746b449a6c5fc2482d3a7019b6b8cb7406d0c25432c48fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwmac-tegra.c",
  "human_readable_source": "\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/module.h>\n#include <linux/stmmac.h>\n#include <linux/clk.h>\n\n#include \"stmmac_platform.h\"\n\nstatic const char *const mgbe_clks[] = {\n\t\"rx-pcs\", \"tx\", \"tx-pcs\", \"mac-divider\", \"mac\", \"mgbe\", \"ptp-ref\", \"mac\"\n};\n\nstruct tegra_mgbe {\n\tstruct device *dev;\n\n\tstruct clk_bulk_data *clks;\n\n\tstruct reset_control *rst_mac;\n\tstruct reset_control *rst_pcs;\n\n\tvoid __iomem *hv;\n\tvoid __iomem *regs;\n\tvoid __iomem *xpcs;\n\n\tstruct mii_bus *mii;\n};\n\n#define XPCS_WRAP_UPHY_RX_CONTROL 0x801c\n#define XPCS_WRAP_UPHY_RX_CONTROL_RX_SW_OVRD BIT(31)\n#define XPCS_WRAP_UPHY_RX_CONTROL_RX_PCS_PHY_RDY BIT(10)\n#define XPCS_WRAP_UPHY_RX_CONTROL_RX_CDR_RESET BIT(9)\n#define XPCS_WRAP_UPHY_RX_CONTROL_RX_CAL_EN BIT(8)\n#define XPCS_WRAP_UPHY_RX_CONTROL_RX_SLEEP (BIT(7) | BIT(6))\n#define XPCS_WRAP_UPHY_RX_CONTROL_AUX_RX_IDDQ BIT(5)\n#define XPCS_WRAP_UPHY_RX_CONTROL_RX_IDDQ BIT(4)\n#define XPCS_WRAP_UPHY_RX_CONTROL_RX_DATA_EN BIT(0)\n#define XPCS_WRAP_UPHY_HW_INIT_CTRL 0x8020\n#define XPCS_WRAP_UPHY_HW_INIT_CTRL_TX_EN BIT(0)\n#define XPCS_WRAP_UPHY_HW_INIT_CTRL_RX_EN BIT(2)\n#define XPCS_WRAP_UPHY_STATUS 0x8044\n#define XPCS_WRAP_UPHY_STATUS_TX_P_UP BIT(0)\n#define XPCS_WRAP_IRQ_STATUS 0x8050\n#define XPCS_WRAP_IRQ_STATUS_PCS_LINK_STS BIT(6)\n\n#define XPCS_REG_ADDR_SHIFT 10\n#define XPCS_REG_ADDR_MASK 0x1fff\n#define XPCS_ADDR 0x3fc\n\n#define MGBE_WRAP_COMMON_INTR_ENABLE\t0x8704\n#define MAC_SBD_INTR\t\t\tBIT(2)\n#define MGBE_WRAP_AXI_ASID0_CTRL\t0x8400\n#define MGBE_SID\t\t\t0x6\n\nstatic int __maybe_unused tegra_mgbe_suspend(struct device *dev)\n{\n\tstruct tegra_mgbe *mgbe = get_stmmac_bsp_priv(dev);\n\tint err;\n\n\terr = stmmac_suspend(dev);\n\tif (err)\n\t\treturn err;\n\n\tclk_bulk_disable_unprepare(ARRAY_SIZE(mgbe_clks), mgbe->clks);\n\n\treturn reset_control_assert(mgbe->rst_mac);\n}\n\nstatic int __maybe_unused tegra_mgbe_resume(struct device *dev)\n{\n\tstruct tegra_mgbe *mgbe = get_stmmac_bsp_priv(dev);\n\tu32 value;\n\tint err;\n\n\terr = clk_bulk_prepare_enable(ARRAY_SIZE(mgbe_clks), mgbe->clks);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = reset_control_deassert(mgbe->rst_mac);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\twritel(MAC_SBD_INTR, mgbe->regs + MGBE_WRAP_COMMON_INTR_ENABLE);\n\n\t \n\twritel(MGBE_SID, mgbe->hv + MGBE_WRAP_AXI_ASID0_CTRL);\n\n\tvalue = readl(mgbe->xpcs + XPCS_WRAP_UPHY_STATUS);\n\tif ((value & XPCS_WRAP_UPHY_STATUS_TX_P_UP) == 0) {\n\t\tvalue = readl(mgbe->xpcs + XPCS_WRAP_UPHY_HW_INIT_CTRL);\n\t\tvalue |= XPCS_WRAP_UPHY_HW_INIT_CTRL_TX_EN;\n\t\twritel(value, mgbe->xpcs + XPCS_WRAP_UPHY_HW_INIT_CTRL);\n\t}\n\n\terr = readl_poll_timeout(mgbe->xpcs + XPCS_WRAP_UPHY_HW_INIT_CTRL, value,\n\t\t\t\t (value & XPCS_WRAP_UPHY_HW_INIT_CTRL_TX_EN) == 0,\n\t\t\t\t 500, 500 * 2000);\n\tif (err < 0) {\n\t\tdev_err(mgbe->dev, \"timeout waiting for TX lane to become enabled\\n\");\n\t\tclk_bulk_disable_unprepare(ARRAY_SIZE(mgbe_clks), mgbe->clks);\n\t\treturn err;\n\t}\n\n\terr = stmmac_resume(dev);\n\tif (err < 0)\n\t\tclk_bulk_disable_unprepare(ARRAY_SIZE(mgbe_clks), mgbe->clks);\n\n\treturn err;\n}\n\nstatic int mgbe_uphy_lane_bringup_serdes_up(struct net_device *ndev, void *mgbe_data)\n{\n\tstruct tegra_mgbe *mgbe = (struct tegra_mgbe *)mgbe_data;\n\tu32 value;\n\tint err;\n\n\tvalue = readl(mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\tvalue |= XPCS_WRAP_UPHY_RX_CONTROL_RX_SW_OVRD;\n\twritel(value, mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\n\tvalue = readl(mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\tvalue &= ~XPCS_WRAP_UPHY_RX_CONTROL_RX_IDDQ;\n\twritel(value, mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\n\tvalue = readl(mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\tvalue &= ~XPCS_WRAP_UPHY_RX_CONTROL_AUX_RX_IDDQ;\n\twritel(value, mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\n\tvalue = readl(mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\tvalue &= ~XPCS_WRAP_UPHY_RX_CONTROL_RX_SLEEP;\n\twritel(value, mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\n\tvalue = readl(mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\tvalue |= XPCS_WRAP_UPHY_RX_CONTROL_RX_CAL_EN;\n\twritel(value, mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\n\terr = readl_poll_timeout(mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL, value,\n\t\t\t\t (value & XPCS_WRAP_UPHY_RX_CONTROL_RX_CAL_EN) == 0,\n\t\t\t\t 1000, 1000 * 2000);\n\tif (err < 0) {\n\t\tdev_err(mgbe->dev, \"timeout waiting for RX calibration to become enabled\\n\");\n\t\treturn err;\n\t}\n\n\tvalue = readl(mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\tvalue |= XPCS_WRAP_UPHY_RX_CONTROL_RX_DATA_EN;\n\twritel(value, mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\n\tvalue = readl(mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\tvalue |= XPCS_WRAP_UPHY_RX_CONTROL_RX_CDR_RESET;\n\twritel(value, mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\n\tvalue = readl(mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\tvalue &= ~XPCS_WRAP_UPHY_RX_CONTROL_RX_CDR_RESET;\n\twritel(value, mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\n\tvalue = readl(mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\tvalue |= XPCS_WRAP_UPHY_RX_CONTROL_RX_PCS_PHY_RDY;\n\twritel(value, mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\n\terr = readl_poll_timeout(mgbe->xpcs + XPCS_WRAP_IRQ_STATUS, value,\n\t\t\t\t value & XPCS_WRAP_IRQ_STATUS_PCS_LINK_STS,\n\t\t\t\t 500, 500 * 2000);\n\tif (err < 0) {\n\t\tdev_err(mgbe->dev, \"timeout waiting for link to become ready\\n\");\n\t\treturn err;\n\t}\n\n\t \n\twritel(value, mgbe->xpcs + XPCS_WRAP_IRQ_STATUS);\n\n\treturn 0;\n}\n\nstatic void mgbe_uphy_lane_bringup_serdes_down(struct net_device *ndev, void *mgbe_data)\n{\n\tstruct tegra_mgbe *mgbe = (struct tegra_mgbe *)mgbe_data;\n\tu32 value;\n\n\tvalue = readl(mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\tvalue |= XPCS_WRAP_UPHY_RX_CONTROL_RX_SW_OVRD;\n\twritel(value, mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\n\tvalue = readl(mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\tvalue &= ~XPCS_WRAP_UPHY_RX_CONTROL_RX_DATA_EN;\n\twritel(value, mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\n\tvalue = readl(mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\tvalue |= XPCS_WRAP_UPHY_RX_CONTROL_RX_SLEEP;\n\twritel(value, mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\n\tvalue = readl(mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\tvalue |= XPCS_WRAP_UPHY_RX_CONTROL_AUX_RX_IDDQ;\n\twritel(value, mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\n\tvalue = readl(mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n\tvalue |= XPCS_WRAP_UPHY_RX_CONTROL_RX_IDDQ;\n\twritel(value, mgbe->xpcs + XPCS_WRAP_UPHY_RX_CONTROL);\n}\n\nstatic int tegra_mgbe_probe(struct platform_device *pdev)\n{\n\tstruct plat_stmmacenet_data *plat;\n\tstruct stmmac_resources res;\n\tstruct tegra_mgbe *mgbe;\n\tint irq, err, i;\n\tu32 value;\n\n\tmgbe = devm_kzalloc(&pdev->dev, sizeof(*mgbe), GFP_KERNEL);\n\tif (!mgbe)\n\t\treturn -ENOMEM;\n\n\tmgbe->dev = &pdev->dev;\n\n\tmemset(&res, 0, sizeof(res));\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tmgbe->hv = devm_platform_ioremap_resource_byname(pdev, \"hypervisor\");\n\tif (IS_ERR(mgbe->hv))\n\t\treturn PTR_ERR(mgbe->hv);\n\n\tmgbe->regs = devm_platform_ioremap_resource_byname(pdev, \"mac\");\n\tif (IS_ERR(mgbe->regs))\n\t\treturn PTR_ERR(mgbe->regs);\n\n\tmgbe->xpcs = devm_platform_ioremap_resource_byname(pdev, \"xpcs\");\n\tif (IS_ERR(mgbe->xpcs))\n\t\treturn PTR_ERR(mgbe->xpcs);\n\n\tres.addr = mgbe->regs;\n\tres.irq = irq;\n\n\tmgbe->clks = devm_kcalloc(&pdev->dev, ARRAY_SIZE(mgbe_clks),\n\t\t\t\t  sizeof(*mgbe->clks), GFP_KERNEL);\n\tif (!mgbe->clks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i <  ARRAY_SIZE(mgbe_clks); i++)\n\t\tmgbe->clks[i].id = mgbe_clks[i];\n\n\terr = devm_clk_bulk_get(mgbe->dev, ARRAY_SIZE(mgbe_clks), mgbe->clks);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = clk_bulk_prepare_enable(ARRAY_SIZE(mgbe_clks), mgbe->clks);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tmgbe->rst_mac = devm_reset_control_get(&pdev->dev, \"mac\");\n\tif (IS_ERR(mgbe->rst_mac)) {\n\t\terr = PTR_ERR(mgbe->rst_mac);\n\t\tgoto disable_clks;\n\t}\n\n\terr = reset_control_assert(mgbe->rst_mac);\n\tif (err < 0)\n\t\tgoto disable_clks;\n\n\tusleep_range(2000, 4000);\n\n\terr = reset_control_deassert(mgbe->rst_mac);\n\tif (err < 0)\n\t\tgoto disable_clks;\n\n\t \n\tmgbe->rst_pcs = devm_reset_control_get(&pdev->dev, \"pcs\");\n\tif (IS_ERR(mgbe->rst_pcs)) {\n\t\terr = PTR_ERR(mgbe->rst_pcs);\n\t\tgoto disable_clks;\n\t}\n\n\terr = reset_control_assert(mgbe->rst_pcs);\n\tif (err < 0)\n\t\tgoto disable_clks;\n\n\tusleep_range(2000, 4000);\n\n\terr = reset_control_deassert(mgbe->rst_pcs);\n\tif (err < 0)\n\t\tgoto disable_clks;\n\n\tplat = stmmac_probe_config_dt(pdev, res.mac);\n\tif (IS_ERR(plat)) {\n\t\terr = PTR_ERR(plat);\n\t\tgoto disable_clks;\n\t}\n\n\tplat->has_xgmac = 1;\n\tplat->flags |= STMMAC_FLAG_TSO_EN;\n\tplat->pmt = 1;\n\tplat->bsp_priv = mgbe;\n\n\tif (!plat->mdio_node)\n\t\tplat->mdio_node = of_get_child_by_name(pdev->dev.of_node, \"mdio\");\n\n\tif (!plat->mdio_bus_data) {\n\t\tplat->mdio_bus_data = devm_kzalloc(&pdev->dev, sizeof(*plat->mdio_bus_data),\n\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!plat->mdio_bus_data) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto remove;\n\t\t}\n\t}\n\n\tplat->mdio_bus_data->needs_reset = true;\n\n\tvalue = readl(mgbe->xpcs + XPCS_WRAP_UPHY_STATUS);\n\tif ((value & XPCS_WRAP_UPHY_STATUS_TX_P_UP) == 0) {\n\t\tvalue = readl(mgbe->xpcs + XPCS_WRAP_UPHY_HW_INIT_CTRL);\n\t\tvalue |= XPCS_WRAP_UPHY_HW_INIT_CTRL_TX_EN;\n\t\twritel(value, mgbe->xpcs + XPCS_WRAP_UPHY_HW_INIT_CTRL);\n\t}\n\n\terr = readl_poll_timeout(mgbe->xpcs + XPCS_WRAP_UPHY_HW_INIT_CTRL, value,\n\t\t\t\t (value & XPCS_WRAP_UPHY_HW_INIT_CTRL_TX_EN) == 0,\n\t\t\t\t 500, 500 * 2000);\n\tif (err < 0) {\n\t\tdev_err(mgbe->dev, \"timeout waiting for TX lane to become enabled\\n\");\n\t\tgoto remove;\n\t}\n\n\tplat->serdes_powerup = mgbe_uphy_lane_bringup_serdes_up;\n\tplat->serdes_powerdown = mgbe_uphy_lane_bringup_serdes_down;\n\n\t \n\tplat->tx_fifo_size = 131072;\n\t \n\tplat->rx_fifo_size = 196608;\n\n\t \n\twritel(MAC_SBD_INTR, mgbe->regs + MGBE_WRAP_COMMON_INTR_ENABLE);\n\n\t \n\twritel(MGBE_SID, mgbe->hv + MGBE_WRAP_AXI_ASID0_CTRL);\n\n\tplat->flags |= STMMAC_FLAG_SERDES_UP_AFTER_PHY_LINKUP;\n\n\terr = stmmac_dvr_probe(&pdev->dev, plat, &res);\n\tif (err < 0)\n\t\tgoto remove;\n\n\treturn 0;\n\nremove:\n\tstmmac_remove_config_dt(pdev, plat);\ndisable_clks:\n\tclk_bulk_disable_unprepare(ARRAY_SIZE(mgbe_clks), mgbe->clks);\n\n\treturn err;\n}\n\nstatic void tegra_mgbe_remove(struct platform_device *pdev)\n{\n\tstruct tegra_mgbe *mgbe = get_stmmac_bsp_priv(&pdev->dev);\n\n\tclk_bulk_disable_unprepare(ARRAY_SIZE(mgbe_clks), mgbe->clks);\n\n\tstmmac_pltfr_remove(pdev);\n}\n\nstatic const struct of_device_id tegra_mgbe_match[] = {\n\t{ .compatible = \"nvidia,tegra234-mgbe\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tegra_mgbe_match);\n\nstatic SIMPLE_DEV_PM_OPS(tegra_mgbe_pm_ops, tegra_mgbe_suspend, tegra_mgbe_resume);\n\nstatic struct platform_driver tegra_mgbe_driver = {\n\t.probe = tegra_mgbe_probe,\n\t.remove_new = tegra_mgbe_remove,\n\t.driver = {\n\t\t.name = \"tegra-mgbe\",\n\t\t.pm\t\t= &tegra_mgbe_pm_ops,\n\t\t.of_match_table = tegra_mgbe_match,\n\t},\n};\nmodule_platform_driver(tegra_mgbe_driver);\n\nMODULE_AUTHOR(\"Thierry Reding <treding@nvidia.com>\");\nMODULE_DESCRIPTION(\"NVIDIA Tegra MGBE driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}