{
  "module_name": "dwmac1000_core.c",
  "hash_id": "af15a7c44cea6c60096e4ce621ff1e736992522e3e4153dec39f7d0b5783d3de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c",
  "human_readable_source": "\n \n\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/ethtool.h>\n#include <asm/io.h>\n#include \"stmmac.h\"\n#include \"stmmac_pcs.h\"\n#include \"dwmac1000.h\"\n\nstatic void dwmac1000_core_init(struct mac_device_info *hw,\n\t\t\t\tstruct net_device *dev)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value = readl(ioaddr + GMAC_CONTROL);\n\tint mtu = dev->mtu;\n\n\t \n\tvalue |= GMAC_CORE_INIT;\n\n\tif (mtu > 1500)\n\t\tvalue |= GMAC_CONTROL_2K;\n\tif (mtu > 2000)\n\t\tvalue |= GMAC_CONTROL_JE;\n\n\tif (hw->ps) {\n\t\tvalue |= GMAC_CONTROL_TE;\n\n\t\tvalue &= ~hw->link.speed_mask;\n\t\tswitch (hw->ps) {\n\t\tcase SPEED_1000:\n\t\t\tvalue |= hw->link.speed1000;\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tvalue |= hw->link.speed100;\n\t\t\tbreak;\n\t\tcase SPEED_10:\n\t\t\tvalue |= hw->link.speed10;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twritel(value, ioaddr + GMAC_CONTROL);\n\n\t \n\tvalue = GMAC_INT_DEFAULT_MASK;\n\n\tif (hw->pcs)\n\t\tvalue &= ~GMAC_INT_DISABLE_PCS;\n\n\twritel(value, ioaddr + GMAC_INT_MASK);\n\n#ifdef STMMAC_VLAN_TAG_USED\n\t \n\twritel(0x0, ioaddr + GMAC_VLAN_TAG);\n#endif\n}\n\nstatic int dwmac1000_rx_ipc_enable(struct mac_device_info *hw)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value = readl(ioaddr + GMAC_CONTROL);\n\n\tif (hw->rx_csum)\n\t\tvalue |= GMAC_CONTROL_IPC;\n\telse\n\t\tvalue &= ~GMAC_CONTROL_IPC;\n\n\twritel(value, ioaddr + GMAC_CONTROL);\n\n\tvalue = readl(ioaddr + GMAC_CONTROL);\n\n\treturn !!(value & GMAC_CONTROL_IPC);\n}\n\nstatic void dwmac1000_dump_regs(struct mac_device_info *hw, u32 *reg_space)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tint i;\n\n\tfor (i = 0; i < 55; i++)\n\t\treg_space[i] = readl(ioaddr + i * 4);\n}\n\nstatic void dwmac1000_set_umac_addr(struct mac_device_info *hw,\n\t\t\t\t    const unsigned char *addr,\n\t\t\t\t    unsigned int reg_n)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tstmmac_set_mac_addr(ioaddr, addr, GMAC_ADDR_HIGH(reg_n),\n\t\t\t    GMAC_ADDR_LOW(reg_n));\n}\n\nstatic void dwmac1000_get_umac_addr(struct mac_device_info *hw,\n\t\t\t\t    unsigned char *addr,\n\t\t\t\t    unsigned int reg_n)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tstmmac_get_mac_addr(ioaddr, addr, GMAC_ADDR_HIGH(reg_n),\n\t\t\t    GMAC_ADDR_LOW(reg_n));\n}\n\nstatic void dwmac1000_set_mchash(void __iomem *ioaddr, u32 *mcfilterbits,\n\t\t\t\t int mcbitslog2)\n{\n\tint numhashregs, regs;\n\n\tswitch (mcbitslog2) {\n\tcase 6:\n\t\twritel(mcfilterbits[0], ioaddr + GMAC_HASH_LOW);\n\t\twritel(mcfilterbits[1], ioaddr + GMAC_HASH_HIGH);\n\t\treturn;\n\tcase 7:\n\t\tnumhashregs = 4;\n\t\tbreak;\n\tcase 8:\n\t\tnumhashregs = 8;\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"STMMAC: err in setting multicast filter\\n\");\n\t\treturn;\n\t}\n\tfor (regs = 0; regs < numhashregs; regs++)\n\t\twritel(mcfilterbits[regs],\n\t\t       ioaddr + GMAC_EXTHASH_BASE + regs * 4);\n}\n\nstatic void dwmac1000_set_filter(struct mac_device_info *hw,\n\t\t\t\t struct net_device *dev)\n{\n\tvoid __iomem *ioaddr = (void __iomem *)dev->base_addr;\n\tunsigned int value = 0;\n\tunsigned int perfect_addr_number = hw->unicast_filter_entries;\n\tu32 mc_filter[8];\n\tint mcbitslog2 = hw->mcast_bits_log2;\n\n\tpr_debug(\"%s: # mcasts %d, # unicast %d\\n\", __func__,\n\t\t netdev_mc_count(dev), netdev_uc_count(dev));\n\n\tmemset(mc_filter, 0, sizeof(mc_filter));\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\tvalue = GMAC_FRAME_FILTER_PR | GMAC_FRAME_FILTER_PCF;\n\t} else if (dev->flags & IFF_ALLMULTI) {\n\t\tvalue = GMAC_FRAME_FILTER_PM;\t \n\t} else if (!netdev_mc_empty(dev) && (mcbitslog2 == 0)) {\n\t\t \n\t\tvalue = GMAC_FRAME_FILTER_PM;\n\t} else if (!netdev_mc_empty(dev)) {\n\t\tstruct netdev_hw_addr *ha;\n\n\t\t \n\t\tvalue = GMAC_FRAME_FILTER_HMC;\n\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\t \n\t\t\tint bit_nr = bitrev32(~crc32_le(~0, ha->addr,\n\t\t\t\t\t      ETH_ALEN)) >>\n\t\t\t\t\t      (32 - mcbitslog2);\n\t\t\t \n\t\t\tmc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);\n\t\t}\n\t}\n\n\tvalue |= GMAC_FRAME_FILTER_HPF;\n\tdwmac1000_set_mchash(ioaddr, mc_filter, mcbitslog2);\n\n\t \n\tif (netdev_uc_count(dev) > perfect_addr_number)\n\t\t \n\t\tvalue |= GMAC_FRAME_FILTER_PR;\n\telse {\n\t\tint reg = 1;\n\t\tstruct netdev_hw_addr *ha;\n\n\t\tnetdev_for_each_uc_addr(ha, dev) {\n\t\t\tstmmac_set_mac_addr(ioaddr, ha->addr,\n\t\t\t\t\t    GMAC_ADDR_HIGH(reg),\n\t\t\t\t\t    GMAC_ADDR_LOW(reg));\n\t\t\treg++;\n\t\t}\n\n\t\twhile (reg < perfect_addr_number) {\n\t\t\twritel(0, ioaddr + GMAC_ADDR_HIGH(reg));\n\t\t\twritel(0, ioaddr + GMAC_ADDR_LOW(reg));\n\t\t\treg++;\n\t\t}\n\t}\n\n#ifdef FRAME_FILTER_DEBUG\n\t \n\tvalue |= GMAC_FRAME_FILTER_RA;\n#endif\n\twritel(value, ioaddr + GMAC_FRAME_FILTER);\n}\n\n\nstatic void dwmac1000_flow_ctrl(struct mac_device_info *hw, unsigned int duplex,\n\t\t\t\tunsigned int fc, unsigned int pause_time,\n\t\t\t\tu32 tx_cnt)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\t \n\tunsigned int flow = GMAC_FLOW_CTRL_UP;\n\n\tpr_debug(\"GMAC Flow-Control:\\n\");\n\tif (fc & FLOW_RX) {\n\t\tpr_debug(\"\\tReceive Flow-Control ON\\n\");\n\t\tflow |= GMAC_FLOW_CTRL_RFE;\n\t}\n\tif (fc & FLOW_TX) {\n\t\tpr_debug(\"\\tTransmit Flow-Control ON\\n\");\n\t\tflow |= GMAC_FLOW_CTRL_TFE;\n\t}\n\n\tif (duplex) {\n\t\tpr_debug(\"\\tduplex mode: PAUSE %d\\n\", pause_time);\n\t\tflow |= (pause_time << GMAC_FLOW_CTRL_PT_SHIFT);\n\t}\n\n\twritel(flow, ioaddr + GMAC_FLOW_CTRL);\n}\n\nstatic void dwmac1000_pmt(struct mac_device_info *hw, unsigned long mode)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tunsigned int pmt = 0;\n\n\tif (mode & WAKE_MAGIC) {\n\t\tpr_debug(\"GMAC: WOL Magic frame\\n\");\n\t\tpmt |= power_down | magic_pkt_en;\n\t}\n\tif (mode & WAKE_UCAST) {\n\t\tpr_debug(\"GMAC: WOL on global unicast\\n\");\n\t\tpmt |= power_down | global_unicast | wake_up_frame_en;\n\t}\n\n\twritel(pmt, ioaddr + GMAC_PMT);\n}\n\n \nstatic void dwmac1000_rgsmii(void __iomem *ioaddr, struct stmmac_extra_stats *x)\n{\n\tu32 status;\n\n\tstatus = readl(ioaddr + GMAC_RGSMIIIS);\n\tx->irq_rgmii_n++;\n\n\t \n\tif (status & GMAC_RGSMIIIS_LNKSTS) {\n\t\tint speed_value;\n\n\t\tx->pcs_link = 1;\n\n\t\tspeed_value = ((status & GMAC_RGSMIIIS_SPEED) >>\n\t\t\t       GMAC_RGSMIIIS_SPEED_SHIFT);\n\t\tif (speed_value == GMAC_RGSMIIIS_SPEED_125)\n\t\t\tx->pcs_speed = SPEED_1000;\n\t\telse if (speed_value == GMAC_RGSMIIIS_SPEED_25)\n\t\t\tx->pcs_speed = SPEED_100;\n\t\telse\n\t\t\tx->pcs_speed = SPEED_10;\n\n\t\tx->pcs_duplex = (status & GMAC_RGSMIIIS_LNKMOD_MASK);\n\n\t\tpr_info(\"Link is Up - %d/%s\\n\", (int)x->pcs_speed,\n\t\t\tx->pcs_duplex ? \"Full\" : \"Half\");\n\t} else {\n\t\tx->pcs_link = 0;\n\t\tpr_info(\"Link is Down\\n\");\n\t}\n}\n\nstatic int dwmac1000_irq_status(struct mac_device_info *hw,\n\t\t\t\tstruct stmmac_extra_stats *x)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 intr_status = readl(ioaddr + GMAC_INT_STATUS);\n\tu32 intr_mask = readl(ioaddr + GMAC_INT_MASK);\n\tint ret = 0;\n\n\t \n\tintr_status &= ~intr_mask;\n\n\t \n\tif ((intr_status & GMAC_INT_STATUS_MMCTIS))\n\t\tx->mmc_tx_irq_n++;\n\tif (unlikely(intr_status & GMAC_INT_STATUS_MMCRIS))\n\t\tx->mmc_rx_irq_n++;\n\tif (unlikely(intr_status & GMAC_INT_STATUS_MMCCSUM))\n\t\tx->mmc_rx_csum_offload_irq_n++;\n\tif (unlikely(intr_status & GMAC_INT_DISABLE_PMT)) {\n\t\t \n\t\treadl(ioaddr + GMAC_PMT);\n\t\tx->irq_receive_pmt_irq_n++;\n\t}\n\n\t \n\tif (intr_status & GMAC_INT_STATUS_LPIIS) {\n\t\t \n\t\tret = readl(ioaddr + LPI_CTRL_STATUS);\n\n\t\tif (ret & LPI_CTRL_STATUS_TLPIEN)\n\t\t\tx->irq_tx_path_in_lpi_mode_n++;\n\t\tif (ret & LPI_CTRL_STATUS_TLPIEX)\n\t\t\tx->irq_tx_path_exit_lpi_mode_n++;\n\t\tif (ret & LPI_CTRL_STATUS_RLPIEN)\n\t\t\tx->irq_rx_path_in_lpi_mode_n++;\n\t\tif (ret & LPI_CTRL_STATUS_RLPIEX)\n\t\t\tx->irq_rx_path_exit_lpi_mode_n++;\n\t}\n\n\tdwmac_pcs_isr(ioaddr, GMAC_PCS_BASE, intr_status, x);\n\n\tif (intr_status & PCS_RGSMIIIS_IRQ)\n\t\tdwmac1000_rgsmii(ioaddr, x);\n\n\treturn ret;\n}\n\nstatic void dwmac1000_set_eee_mode(struct mac_device_info *hw,\n\t\t\t\t   bool en_tx_lpi_clockgating)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\t \n\n\t \n\tvalue = readl(ioaddr + LPI_CTRL_STATUS);\n\tvalue |= LPI_CTRL_STATUS_LPIEN | LPI_CTRL_STATUS_LPITXA;\n\twritel(value, ioaddr + LPI_CTRL_STATUS);\n}\n\nstatic void dwmac1000_reset_eee_mode(struct mac_device_info *hw)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\tvalue = readl(ioaddr + LPI_CTRL_STATUS);\n\tvalue &= ~(LPI_CTRL_STATUS_LPIEN | LPI_CTRL_STATUS_LPITXA);\n\twritel(value, ioaddr + LPI_CTRL_STATUS);\n}\n\nstatic void dwmac1000_set_eee_pls(struct mac_device_info *hw, int link)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\tvalue = readl(ioaddr + LPI_CTRL_STATUS);\n\n\tif (link)\n\t\tvalue |= LPI_CTRL_STATUS_PLS;\n\telse\n\t\tvalue &= ~LPI_CTRL_STATUS_PLS;\n\n\twritel(value, ioaddr + LPI_CTRL_STATUS);\n}\n\nstatic void dwmac1000_set_eee_timer(struct mac_device_info *hw, int ls, int tw)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tint value = ((tw & 0xffff)) | ((ls & 0x7ff) << 16);\n\n\t \n\twritel(value, ioaddr + LPI_TIMER_CTRL);\n}\n\nstatic void dwmac1000_ctrl_ane(void __iomem *ioaddr, bool ane, bool srgmi_ral,\n\t\t\t       bool loopback)\n{\n\tdwmac_ctrl_ane(ioaddr, GMAC_PCS_BASE, ane, srgmi_ral, loopback);\n}\n\nstatic void dwmac1000_rane(void __iomem *ioaddr, bool restart)\n{\n\tdwmac_rane(ioaddr, GMAC_PCS_BASE, restart);\n}\n\nstatic void dwmac1000_get_adv_lp(void __iomem *ioaddr, struct rgmii_adv *adv)\n{\n\tdwmac_get_adv_lp(ioaddr, GMAC_PCS_BASE, adv);\n}\n\nstatic void dwmac1000_debug(struct stmmac_priv *priv, void __iomem *ioaddr,\n\t\t\t    struct stmmac_extra_stats *x,\n\t\t\t    u32 rx_queues, u32 tx_queues)\n{\n\tu32 value = readl(ioaddr + GMAC_DEBUG);\n\n\tif (value & GMAC_DEBUG_TXSTSFSTS)\n\t\tx->mtl_tx_status_fifo_full++;\n\tif (value & GMAC_DEBUG_TXFSTS)\n\t\tx->mtl_tx_fifo_not_empty++;\n\tif (value & GMAC_DEBUG_TWCSTS)\n\t\tx->mmtl_fifo_ctrl++;\n\tif (value & GMAC_DEBUG_TRCSTS_MASK) {\n\t\tu32 trcsts = (value & GMAC_DEBUG_TRCSTS_MASK)\n\t\t\t     >> GMAC_DEBUG_TRCSTS_SHIFT;\n\t\tif (trcsts == GMAC_DEBUG_TRCSTS_WRITE)\n\t\t\tx->mtl_tx_fifo_read_ctrl_write++;\n\t\telse if (trcsts == GMAC_DEBUG_TRCSTS_TXW)\n\t\t\tx->mtl_tx_fifo_read_ctrl_wait++;\n\t\telse if (trcsts == GMAC_DEBUG_TRCSTS_READ)\n\t\t\tx->mtl_tx_fifo_read_ctrl_read++;\n\t\telse\n\t\t\tx->mtl_tx_fifo_read_ctrl_idle++;\n\t}\n\tif (value & GMAC_DEBUG_TXPAUSED)\n\t\tx->mac_tx_in_pause++;\n\tif (value & GMAC_DEBUG_TFCSTS_MASK) {\n\t\tu32 tfcsts = (value & GMAC_DEBUG_TFCSTS_MASK)\n\t\t\t      >> GMAC_DEBUG_TFCSTS_SHIFT;\n\n\t\tif (tfcsts == GMAC_DEBUG_TFCSTS_XFER)\n\t\t\tx->mac_tx_frame_ctrl_xfer++;\n\t\telse if (tfcsts == GMAC_DEBUG_TFCSTS_GEN_PAUSE)\n\t\t\tx->mac_tx_frame_ctrl_pause++;\n\t\telse if (tfcsts == GMAC_DEBUG_TFCSTS_WAIT)\n\t\t\tx->mac_tx_frame_ctrl_wait++;\n\t\telse\n\t\t\tx->mac_tx_frame_ctrl_idle++;\n\t}\n\tif (value & GMAC_DEBUG_TPESTS)\n\t\tx->mac_gmii_tx_proto_engine++;\n\tif (value & GMAC_DEBUG_RXFSTS_MASK) {\n\t\tu32 rxfsts = (value & GMAC_DEBUG_RXFSTS_MASK)\n\t\t\t     >> GMAC_DEBUG_RRCSTS_SHIFT;\n\n\t\tif (rxfsts == GMAC_DEBUG_RXFSTS_FULL)\n\t\t\tx->mtl_rx_fifo_fill_level_full++;\n\t\telse if (rxfsts == GMAC_DEBUG_RXFSTS_AT)\n\t\t\tx->mtl_rx_fifo_fill_above_thresh++;\n\t\telse if (rxfsts == GMAC_DEBUG_RXFSTS_BT)\n\t\t\tx->mtl_rx_fifo_fill_below_thresh++;\n\t\telse\n\t\t\tx->mtl_rx_fifo_fill_level_empty++;\n\t}\n\tif (value & GMAC_DEBUG_RRCSTS_MASK) {\n\t\tu32 rrcsts = (value & GMAC_DEBUG_RRCSTS_MASK) >>\n\t\t\t     GMAC_DEBUG_RRCSTS_SHIFT;\n\n\t\tif (rrcsts == GMAC_DEBUG_RRCSTS_FLUSH)\n\t\t\tx->mtl_rx_fifo_read_ctrl_flush++;\n\t\telse if (rrcsts == GMAC_DEBUG_RRCSTS_RSTAT)\n\t\t\tx->mtl_rx_fifo_read_ctrl_read_data++;\n\t\telse if (rrcsts == GMAC_DEBUG_RRCSTS_RDATA)\n\t\t\tx->mtl_rx_fifo_read_ctrl_status++;\n\t\telse\n\t\t\tx->mtl_rx_fifo_read_ctrl_idle++;\n\t}\n\tif (value & GMAC_DEBUG_RWCSTS)\n\t\tx->mtl_rx_fifo_ctrl_active++;\n\tif (value & GMAC_DEBUG_RFCFCSTS_MASK)\n\t\tx->mac_rx_frame_ctrl_fifo = (value & GMAC_DEBUG_RFCFCSTS_MASK)\n\t\t\t\t\t    >> GMAC_DEBUG_RFCFCSTS_SHIFT;\n\tif (value & GMAC_DEBUG_RPESTS)\n\t\tx->mac_gmii_rx_proto_engine++;\n}\n\nstatic void dwmac1000_set_mac_loopback(void __iomem *ioaddr, bool enable)\n{\n\tu32 value = readl(ioaddr + GMAC_CONTROL);\n\n\tif (enable)\n\t\tvalue |= GMAC_CONTROL_LM;\n\telse\n\t\tvalue &= ~GMAC_CONTROL_LM;\n\n\twritel(value, ioaddr + GMAC_CONTROL);\n}\n\nconst struct stmmac_ops dwmac1000_ops = {\n\t.core_init = dwmac1000_core_init,\n\t.set_mac = stmmac_set_mac,\n\t.rx_ipc = dwmac1000_rx_ipc_enable,\n\t.dump_regs = dwmac1000_dump_regs,\n\t.host_irq_status = dwmac1000_irq_status,\n\t.set_filter = dwmac1000_set_filter,\n\t.flow_ctrl = dwmac1000_flow_ctrl,\n\t.pmt = dwmac1000_pmt,\n\t.set_umac_addr = dwmac1000_set_umac_addr,\n\t.get_umac_addr = dwmac1000_get_umac_addr,\n\t.set_eee_mode = dwmac1000_set_eee_mode,\n\t.reset_eee_mode = dwmac1000_reset_eee_mode,\n\t.set_eee_timer = dwmac1000_set_eee_timer,\n\t.set_eee_pls = dwmac1000_set_eee_pls,\n\t.debug = dwmac1000_debug,\n\t.pcs_ctrl_ane = dwmac1000_ctrl_ane,\n\t.pcs_rane = dwmac1000_rane,\n\t.pcs_get_adv_lp = dwmac1000_get_adv_lp,\n\t.set_mac_loopback = dwmac1000_set_mac_loopback,\n};\n\nint dwmac1000_setup(struct stmmac_priv *priv)\n{\n\tstruct mac_device_info *mac = priv->hw;\n\n\tdev_info(priv->device, \"\\tDWMAC1000\\n\");\n\n\tpriv->dev->priv_flags |= IFF_UNICAST_FLT;\n\tmac->pcsr = priv->ioaddr;\n\tmac->multicast_filter_bins = priv->plat->multicast_filter_bins;\n\tmac->unicast_filter_entries = priv->plat->unicast_filter_entries;\n\tmac->mcast_bits_log2 = 0;\n\n\tif (mac->multicast_filter_bins)\n\t\tmac->mcast_bits_log2 = ilog2(mac->multicast_filter_bins);\n\n\tmac->link.duplex = GMAC_CONTROL_DM;\n\tmac->link.speed10 = GMAC_CONTROL_PS;\n\tmac->link.speed100 = GMAC_CONTROL_PS | GMAC_CONTROL_FES;\n\tmac->link.speed1000 = 0;\n\tmac->link.speed_mask = GMAC_CONTROL_PS | GMAC_CONTROL_FES;\n\tmac->mii.addr = GMAC_MII_ADDR;\n\tmac->mii.data = GMAC_MII_DATA;\n\tmac->mii.addr_shift = 11;\n\tmac->mii.addr_mask = 0x0000F800;\n\tmac->mii.reg_shift = 6;\n\tmac->mii.reg_mask = 0x000007C0;\n\tmac->mii.clk_csr_shift = 2;\n\tmac->mii.clk_csr_mask = GENMASK(5, 2);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}