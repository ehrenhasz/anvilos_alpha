{
  "module_name": "stmmac_xdp.c",
  "hash_id": "d105184db2578c39caa7dc7f724c583a9c78cc95b59453ad50e5a699c39d6c3c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/stmmac_xdp.c",
  "human_readable_source": "\n \n\n#include <net/xdp_sock_drv.h>\n\n#include \"stmmac.h\"\n#include \"stmmac_xdp.h\"\n\nstatic int stmmac_xdp_enable_pool(struct stmmac_priv *priv,\n\t\t\t\t  struct xsk_buff_pool *pool, u16 queue)\n{\n\tstruct stmmac_channel *ch = &priv->channel[queue];\n\tbool need_update;\n\tu32 frame_size;\n\tint err;\n\n\tif (queue >= priv->plat->rx_queues_to_use ||\n\t    queue >= priv->plat->tx_queues_to_use)\n\t\treturn -EINVAL;\n\n\tframe_size = xsk_pool_get_rx_frame_size(pool);\n\t \n\tif (frame_size < ETH_FRAME_LEN + VLAN_HLEN * 2)\n\t\treturn -EOPNOTSUPP;\n\n\terr = xsk_pool_dma_map(pool, priv->device, STMMAC_RX_DMA_ATTR);\n\tif (err) {\n\t\tnetdev_err(priv->dev, \"Failed to map xsk pool\\n\");\n\t\treturn err;\n\t}\n\n\tneed_update = netif_running(priv->dev) && stmmac_xdp_is_enabled(priv);\n\n\tif (need_update) {\n\t\tnapi_disable(&ch->rx_napi);\n\t\tnapi_disable(&ch->tx_napi);\n\t\tstmmac_disable_rx_queue(priv, queue);\n\t\tstmmac_disable_tx_queue(priv, queue);\n\t}\n\n\tset_bit(queue, priv->af_xdp_zc_qps);\n\n\tif (need_update) {\n\t\tstmmac_enable_rx_queue(priv, queue);\n\t\tstmmac_enable_tx_queue(priv, queue);\n\t\tnapi_enable(&ch->rxtx_napi);\n\n\t\terr = stmmac_xsk_wakeup(priv->dev, queue, XDP_WAKEUP_RX);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int stmmac_xdp_disable_pool(struct stmmac_priv *priv, u16 queue)\n{\n\tstruct stmmac_channel *ch = &priv->channel[queue];\n\tstruct xsk_buff_pool *pool;\n\tbool need_update;\n\n\tif (queue >= priv->plat->rx_queues_to_use ||\n\t    queue >= priv->plat->tx_queues_to_use)\n\t\treturn -EINVAL;\n\n\tpool = xsk_get_pool_from_qid(priv->dev, queue);\n\tif (!pool)\n\t\treturn -EINVAL;\n\n\tneed_update = netif_running(priv->dev) && stmmac_xdp_is_enabled(priv);\n\n\tif (need_update) {\n\t\tnapi_disable(&ch->rxtx_napi);\n\t\tstmmac_disable_rx_queue(priv, queue);\n\t\tstmmac_disable_tx_queue(priv, queue);\n\t\tsynchronize_rcu();\n\t}\n\n\txsk_pool_dma_unmap(pool, STMMAC_RX_DMA_ATTR);\n\n\tclear_bit(queue, priv->af_xdp_zc_qps);\n\n\tif (need_update) {\n\t\tstmmac_enable_rx_queue(priv, queue);\n\t\tstmmac_enable_tx_queue(priv, queue);\n\t\tnapi_enable(&ch->rx_napi);\n\t\tnapi_enable(&ch->tx_napi);\n\t}\n\n\treturn 0;\n}\n\nint stmmac_xdp_setup_pool(struct stmmac_priv *priv, struct xsk_buff_pool *pool,\n\t\t\t  u16 queue)\n{\n\treturn pool ? stmmac_xdp_enable_pool(priv, pool, queue) :\n\t\t      stmmac_xdp_disable_pool(priv, queue);\n}\n\nint stmmac_xdp_set_prog(struct stmmac_priv *priv, struct bpf_prog *prog,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net_device *dev = priv->dev;\n\tstruct bpf_prog *old_prog;\n\tbool need_update;\n\tbool if_running;\n\n\tif_running = netif_running(dev);\n\n\tif (prog && dev->mtu > ETH_DATA_LEN) {\n\t\t \n\t\tNL_SET_ERR_MSG_MOD(extack, \"Jumbo frames not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!prog)\n\t\txdp_features_clear_redirect_target(dev);\n\n\tneed_update = !!priv->xdp_prog != !!prog;\n\tif (if_running && need_update)\n\t\tstmmac_xdp_release(dev);\n\n\told_prog = xchg(&priv->xdp_prog, prog);\n\tif (old_prog)\n\t\tbpf_prog_put(old_prog);\n\n\t \n\tpriv->sph = priv->sph_cap && !stmmac_xdp_is_enabled(priv);\n\n\tif (if_running && need_update)\n\t\tstmmac_xdp_open(dev);\n\n\tif (prog)\n\t\txdp_features_set_redirect_target(dev, false);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}