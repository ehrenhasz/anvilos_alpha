{
  "module_name": "stmmac_selftests.c",
  "hash_id": "fbcb35fbe24cd1edd3870a456629824565f93269364e9ad5c7b2d66dcf5d28f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/stmmac_selftests.c",
  "human_readable_source": "\n \n\n#include <linux/bitrev.h>\n#include <linux/completion.h>\n#include <linux/crc32.h>\n#include <linux/ethtool.h>\n#include <linux/ip.h>\n#include <linux/phy.h>\n#include <linux/udp.h>\n#include <net/pkt_cls.h>\n#include <net/pkt_sched.h>\n#include <net/tcp.h>\n#include <net/udp.h>\n#include <net/tc_act/tc_gact.h>\n#include \"stmmac.h\"\n\nstruct stmmachdr {\n\t__be32 version;\n\t__be64 magic;\n\tu8 id;\n} __packed;\n\n#define STMMAC_TEST_PKT_SIZE (sizeof(struct ethhdr) + sizeof(struct iphdr) + \\\n\t\t\t      sizeof(struct stmmachdr))\n#define STMMAC_TEST_PKT_MAGIC\t0xdeadcafecafedeadULL\n#define STMMAC_LB_TIMEOUT\tmsecs_to_jiffies(200)\n\nstruct stmmac_packet_attrs {\n\tint vlan;\n\tint vlan_id_in;\n\tint vlan_id_out;\n\tunsigned char *src;\n\tconst unsigned char *dst;\n\tu32 ip_src;\n\tu32 ip_dst;\n\tint tcp;\n\tint sport;\n\tint dport;\n\tu32 exp_hash;\n\tint dont_wait;\n\tint timeout;\n\tint size;\n\tint max_size;\n\tint remove_sa;\n\tu8 id;\n\tint sarc;\n\tu16 queue_mapping;\n\tu64 timestamp;\n};\n\nstatic u8 stmmac_test_next_id;\n\nstatic struct sk_buff *stmmac_test_get_udp_skb(struct stmmac_priv *priv,\n\t\t\t\t\t       struct stmmac_packet_attrs *attr)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct udphdr *uhdr = NULL;\n\tstruct tcphdr *thdr = NULL;\n\tstruct stmmachdr *shdr;\n\tstruct ethhdr *ehdr;\n\tstruct iphdr *ihdr;\n\tint iplen, size;\n\n\tsize = attr->size + STMMAC_TEST_PKT_SIZE;\n\tif (attr->vlan) {\n\t\tsize += 4;\n\t\tif (attr->vlan > 1)\n\t\t\tsize += 4;\n\t}\n\n\tif (attr->tcp)\n\t\tsize += sizeof(struct tcphdr);\n\telse\n\t\tsize += sizeof(struct udphdr);\n\n\tif (attr->max_size && (attr->max_size > size))\n\t\tsize = attr->max_size;\n\n\tskb = netdev_alloc_skb(priv->dev, size);\n\tif (!skb)\n\t\treturn NULL;\n\n\tprefetchw(skb->data);\n\n\tif (attr->vlan > 1)\n\t\tehdr = skb_push(skb, ETH_HLEN + 8);\n\telse if (attr->vlan)\n\t\tehdr = skb_push(skb, ETH_HLEN + 4);\n\telse if (attr->remove_sa)\n\t\tehdr = skb_push(skb, ETH_HLEN - 6);\n\telse\n\t\tehdr = skb_push(skb, ETH_HLEN);\n\tskb_reset_mac_header(skb);\n\n\tskb_set_network_header(skb, skb->len);\n\tihdr = skb_put(skb, sizeof(*ihdr));\n\n\tskb_set_transport_header(skb, skb->len);\n\tif (attr->tcp)\n\t\tthdr = skb_put(skb, sizeof(*thdr));\n\telse\n\t\tuhdr = skb_put(skb, sizeof(*uhdr));\n\n\tif (!attr->remove_sa)\n\t\teth_zero_addr(ehdr->h_source);\n\teth_zero_addr(ehdr->h_dest);\n\tif (attr->src && !attr->remove_sa)\n\t\tether_addr_copy(ehdr->h_source, attr->src);\n\tif (attr->dst)\n\t\tether_addr_copy(ehdr->h_dest, attr->dst);\n\n\tif (!attr->remove_sa) {\n\t\tehdr->h_proto = htons(ETH_P_IP);\n\t} else {\n\t\t__be16 *ptr = (__be16 *)ehdr;\n\n\t\t \n\t\tptr[3] = htons(ETH_P_IP);\n\t}\n\n\tif (attr->vlan) {\n\t\t__be16 *tag, *proto;\n\n\t\tif (!attr->remove_sa) {\n\t\t\ttag = (void *)ehdr + ETH_HLEN;\n\t\t\tproto = (void *)ehdr + (2 * ETH_ALEN);\n\t\t} else {\n\t\t\ttag = (void *)ehdr + ETH_HLEN - 6;\n\t\t\tproto = (void *)ehdr + ETH_ALEN;\n\t\t}\n\n\t\tproto[0] = htons(ETH_P_8021Q);\n\t\ttag[0] = htons(attr->vlan_id_out);\n\t\ttag[1] = htons(ETH_P_IP);\n\t\tif (attr->vlan > 1) {\n\t\t\tproto[0] = htons(ETH_P_8021AD);\n\t\t\ttag[1] = htons(ETH_P_8021Q);\n\t\t\ttag[2] = htons(attr->vlan_id_in);\n\t\t\ttag[3] = htons(ETH_P_IP);\n\t\t}\n\t}\n\n\tif (attr->tcp) {\n\t\tthdr->source = htons(attr->sport);\n\t\tthdr->dest = htons(attr->dport);\n\t\tthdr->doff = sizeof(struct tcphdr) / 4;\n\t\tthdr->check = 0;\n\t} else {\n\t\tuhdr->source = htons(attr->sport);\n\t\tuhdr->dest = htons(attr->dport);\n\t\tuhdr->len = htons(sizeof(*shdr) + sizeof(*uhdr) + attr->size);\n\t\tif (attr->max_size)\n\t\t\tuhdr->len = htons(attr->max_size -\n\t\t\t\t\t  (sizeof(*ihdr) + sizeof(*ehdr)));\n\t\tuhdr->check = 0;\n\t}\n\n\tihdr->ihl = 5;\n\tihdr->ttl = 32;\n\tihdr->version = 4;\n\tif (attr->tcp)\n\t\tihdr->protocol = IPPROTO_TCP;\n\telse\n\t\tihdr->protocol = IPPROTO_UDP;\n\tiplen = sizeof(*ihdr) + sizeof(*shdr) + attr->size;\n\tif (attr->tcp)\n\t\tiplen += sizeof(*thdr);\n\telse\n\t\tiplen += sizeof(*uhdr);\n\n\tif (attr->max_size)\n\t\tiplen = attr->max_size - sizeof(*ehdr);\n\n\tihdr->tot_len = htons(iplen);\n\tihdr->frag_off = 0;\n\tihdr->saddr = htonl(attr->ip_src);\n\tihdr->daddr = htonl(attr->ip_dst);\n\tihdr->tos = 0;\n\tihdr->id = 0;\n\tip_send_check(ihdr);\n\n\tshdr = skb_put(skb, sizeof(*shdr));\n\tshdr->version = 0;\n\tshdr->magic = cpu_to_be64(STMMAC_TEST_PKT_MAGIC);\n\tattr->id = stmmac_test_next_id;\n\tshdr->id = stmmac_test_next_id++;\n\n\tif (attr->size)\n\t\tskb_put(skb, attr->size);\n\tif (attr->max_size && (attr->max_size > skb->len))\n\t\tskb_put(skb, attr->max_size - skb->len);\n\n\tskb->csum = 0;\n\tskb->ip_summed = CHECKSUM_PARTIAL;\n\tif (attr->tcp) {\n\t\tthdr->check = ~tcp_v4_check(skb->len, ihdr->saddr, ihdr->daddr, 0);\n\t\tskb->csum_start = skb_transport_header(skb) - skb->head;\n\t\tskb->csum_offset = offsetof(struct tcphdr, check);\n\t} else {\n\t\tudp4_hwcsum(skb, ihdr->saddr, ihdr->daddr);\n\t}\n\n\tskb->protocol = htons(ETH_P_IP);\n\tskb->pkt_type = PACKET_HOST;\n\tskb->dev = priv->dev;\n\n\tif (attr->timestamp)\n\t\tskb->tstamp = ns_to_ktime(attr->timestamp);\n\n\treturn skb;\n}\n\nstatic struct sk_buff *stmmac_test_get_arp_skb(struct stmmac_priv *priv,\n\t\t\t\t\t       struct stmmac_packet_attrs *attr)\n{\n\t__be32 ip_src = htonl(attr->ip_src);\n\t__be32 ip_dst = htonl(attr->ip_dst);\n\tstruct sk_buff *skb = NULL;\n\n\tskb = arp_create(ARPOP_REQUEST, ETH_P_ARP, ip_dst, priv->dev, ip_src,\n\t\t\t NULL, attr->src, attr->dst);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb->pkt_type = PACKET_HOST;\n\tskb->dev = priv->dev;\n\n\treturn skb;\n}\n\nstruct stmmac_test_priv {\n\tstruct stmmac_packet_attrs *packet;\n\tstruct packet_type pt;\n\tstruct completion comp;\n\tint double_vlan;\n\tint vlan_id;\n\tint ok;\n};\n\nstatic int stmmac_test_loopback_validate(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *ndev,\n\t\t\t\t\t struct packet_type *pt,\n\t\t\t\t\t struct net_device *orig_ndev)\n{\n\tstruct stmmac_test_priv *tpriv = pt->af_packet_priv;\n\tconst unsigned char *dst = tpriv->packet->dst;\n\tunsigned char *src = tpriv->packet->src;\n\tstruct stmmachdr *shdr;\n\tstruct ethhdr *ehdr;\n\tstruct udphdr *uhdr;\n\tstruct tcphdr *thdr;\n\tstruct iphdr *ihdr;\n\n\tskb = skb_unshare(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto out;\n\n\tif (skb_linearize(skb))\n\t\tgoto out;\n\tif (skb_headlen(skb) < (STMMAC_TEST_PKT_SIZE - ETH_HLEN))\n\t\tgoto out;\n\n\tehdr = (struct ethhdr *)skb_mac_header(skb);\n\tif (dst) {\n\t\tif (!ether_addr_equal_unaligned(ehdr->h_dest, dst))\n\t\t\tgoto out;\n\t}\n\tif (tpriv->packet->sarc) {\n\t\tif (!ether_addr_equal_unaligned(ehdr->h_source, ehdr->h_dest))\n\t\t\tgoto out;\n\t} else if (src) {\n\t\tif (!ether_addr_equal_unaligned(ehdr->h_source, src))\n\t\t\tgoto out;\n\t}\n\n\tihdr = ip_hdr(skb);\n\tif (tpriv->double_vlan)\n\t\tihdr = (struct iphdr *)(skb_network_header(skb) + 4);\n\n\tif (tpriv->packet->tcp) {\n\t\tif (ihdr->protocol != IPPROTO_TCP)\n\t\t\tgoto out;\n\n\t\tthdr = (struct tcphdr *)((u8 *)ihdr + 4 * ihdr->ihl);\n\t\tif (thdr->dest != htons(tpriv->packet->dport))\n\t\t\tgoto out;\n\n\t\tshdr = (struct stmmachdr *)((u8 *)thdr + sizeof(*thdr));\n\t} else {\n\t\tif (ihdr->protocol != IPPROTO_UDP)\n\t\t\tgoto out;\n\n\t\tuhdr = (struct udphdr *)((u8 *)ihdr + 4 * ihdr->ihl);\n\t\tif (uhdr->dest != htons(tpriv->packet->dport))\n\t\t\tgoto out;\n\n\t\tshdr = (struct stmmachdr *)((u8 *)uhdr + sizeof(*uhdr));\n\t}\n\n\tif (shdr->magic != cpu_to_be64(STMMAC_TEST_PKT_MAGIC))\n\t\tgoto out;\n\tif (tpriv->packet->exp_hash && !skb->hash)\n\t\tgoto out;\n\tif (tpriv->packet->id != shdr->id)\n\t\tgoto out;\n\n\ttpriv->ok = true;\n\tcomplete(&tpriv->comp);\nout:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int __stmmac_test_loopback(struct stmmac_priv *priv,\n\t\t\t\t  struct stmmac_packet_attrs *attr)\n{\n\tstruct stmmac_test_priv *tpriv;\n\tstruct sk_buff *skb = NULL;\n\tint ret = 0;\n\n\ttpriv = kzalloc(sizeof(*tpriv), GFP_KERNEL);\n\tif (!tpriv)\n\t\treturn -ENOMEM;\n\n\ttpriv->ok = false;\n\tinit_completion(&tpriv->comp);\n\n\ttpriv->pt.type = htons(ETH_P_IP);\n\ttpriv->pt.func = stmmac_test_loopback_validate;\n\ttpriv->pt.dev = priv->dev;\n\ttpriv->pt.af_packet_priv = tpriv;\n\ttpriv->packet = attr;\n\n\tif (!attr->dont_wait)\n\t\tdev_add_pack(&tpriv->pt);\n\n\tskb = stmmac_test_get_udp_skb(priv, attr);\n\tif (!skb) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\tret = dev_direct_xmit(skb, attr->queue_mapping);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tif (attr->dont_wait)\n\t\tgoto cleanup;\n\n\tif (!attr->timeout)\n\t\tattr->timeout = STMMAC_LB_TIMEOUT;\n\n\twait_for_completion_timeout(&tpriv->comp, attr->timeout);\n\tret = tpriv->ok ? 0 : -ETIMEDOUT;\n\ncleanup:\n\tif (!attr->dont_wait)\n\t\tdev_remove_pack(&tpriv->pt);\n\tkfree(tpriv);\n\treturn ret;\n}\n\nstatic int stmmac_test_mac_loopback(struct stmmac_priv *priv)\n{\n\tstruct stmmac_packet_attrs attr = { };\n\n\tattr.dst = priv->dev->dev_addr;\n\treturn __stmmac_test_loopback(priv, &attr);\n}\n\nstatic int stmmac_test_phy_loopback(struct stmmac_priv *priv)\n{\n\tstruct stmmac_packet_attrs attr = { };\n\tint ret;\n\n\tif (!priv->dev->phydev)\n\t\treturn -EOPNOTSUPP;\n\n\tret = phy_loopback(priv->dev->phydev, true);\n\tif (ret)\n\t\treturn ret;\n\n\tattr.dst = priv->dev->dev_addr;\n\tret = __stmmac_test_loopback(priv, &attr);\n\n\tphy_loopback(priv->dev->phydev, false);\n\treturn ret;\n}\n\nstatic int stmmac_test_mmc(struct stmmac_priv *priv)\n{\n\tstruct stmmac_counters initial, final;\n\tint ret;\n\n\tmemset(&initial, 0, sizeof(initial));\n\tmemset(&final, 0, sizeof(final));\n\n\tif (!priv->dma_cap.rmon)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tstmmac_mmc_read(priv, priv->mmcaddr, &priv->mmc);\n\n\tret = stmmac_test_mac_loopback(priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tstmmac_mmc_read(priv, priv->mmcaddr, &final);\n\n\t \n\tif (final.mmc_tx_framecount_g <= initial.mmc_tx_framecount_g)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int stmmac_test_eee(struct stmmac_priv *priv)\n{\n\tstruct stmmac_extra_stats *initial, *final;\n\tint retries = 10;\n\tint ret;\n\n\tif (!priv->dma_cap.eee || !priv->eee_active)\n\t\treturn -EOPNOTSUPP;\n\n\tinitial = kzalloc(sizeof(*initial), GFP_KERNEL);\n\tif (!initial)\n\t\treturn -ENOMEM;\n\n\tfinal = kzalloc(sizeof(*final), GFP_KERNEL);\n\tif (!final) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_initial;\n\t}\n\n\tmemcpy(initial, &priv->xstats, sizeof(*initial));\n\n\tret = stmmac_test_mac_loopback(priv);\n\tif (ret)\n\t\tgoto out_free_final;\n\n\t \n\twhile (--retries) {\n\t\tmemcpy(final, &priv->xstats, sizeof(*final));\n\n\t\tif (final->irq_tx_path_in_lpi_mode_n >\n\t\t    initial->irq_tx_path_in_lpi_mode_n)\n\t\t\tbreak;\n\t\tmsleep(100);\n\t}\n\n\tif (!retries) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto out_free_final;\n\t}\n\n\tif (final->irq_tx_path_in_lpi_mode_n <=\n\t    initial->irq_tx_path_in_lpi_mode_n) {\n\t\tret = -EINVAL;\n\t\tgoto out_free_final;\n\t}\n\n\tif (final->irq_tx_path_exit_lpi_mode_n <=\n\t    initial->irq_tx_path_exit_lpi_mode_n) {\n\t\tret = -EINVAL;\n\t\tgoto out_free_final;\n\t}\n\nout_free_final:\n\tkfree(final);\nout_free_initial:\n\tkfree(initial);\n\treturn ret;\n}\n\nstatic int stmmac_filter_check(struct stmmac_priv *priv)\n{\n\tif (!(priv->dev->flags & IFF_PROMISC))\n\t\treturn 0;\n\n\tnetdev_warn(priv->dev, \"Test can't be run in promiscuous mode!\\n\");\n\treturn -EOPNOTSUPP;\n}\n\nstatic bool stmmac_hash_check(struct stmmac_priv *priv, unsigned char *addr)\n{\n\tint mc_offset = 32 - priv->hw->mcast_bits_log2;\n\tstruct netdev_hw_addr *ha;\n\tu32 hash, hash_nr;\n\n\t \n\thash = bitrev32(~crc32_le(~0, addr, 6)) >> mc_offset;\n\thash_nr = hash >> 5;\n\thash = 1 << (hash & 0x1f);\n\n\t \n\tnetdev_for_each_mc_addr(ha, priv->dev) {\n\t\tu32 nr = bitrev32(~crc32_le(~0, ha->addr, ETH_ALEN)) >> mc_offset;\n\t\tif (((nr >> 5) == hash_nr) && ((1 << (nr & 0x1f)) == hash))\n\t\t\treturn false;\n\t}\n\n\t \n\treturn true;\n}\n\nstatic bool stmmac_perfect_check(struct stmmac_priv *priv, unsigned char *addr)\n{\n\tstruct netdev_hw_addr *ha;\n\n\t \n\tnetdev_for_each_uc_addr(ha, priv->dev) {\n\t\tif (!memcmp(ha->addr, addr, ETH_ALEN))\n\t\t\treturn false;\n\t}\n\n\t \n\treturn true;\n}\n\nstatic int stmmac_test_hfilt(struct stmmac_priv *priv)\n{\n\tunsigned char gd_addr[ETH_ALEN] = {0xf1, 0xee, 0xdd, 0xcc, 0xbb, 0xaa};\n\tunsigned char bd_addr[ETH_ALEN] = {0xf1, 0xff, 0xff, 0xff, 0xff, 0xff};\n\tstruct stmmac_packet_attrs attr = { };\n\tint ret, tries = 256;\n\n\tret = stmmac_filter_check(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tif (netdev_mc_count(priv->dev) >= priv->hw->multicast_filter_bins)\n\t\treturn -EOPNOTSUPP;\n\n\twhile (--tries) {\n\t\t \n\t\tbd_addr[ETH_ALEN - 1] = tries;\n\t\tif (stmmac_hash_check(priv, bd_addr))\n\t\t\tbreak;\n\t}\n\n\tif (!tries)\n\t\treturn -EOPNOTSUPP;\n\n\tret = dev_mc_add(priv->dev, gd_addr);\n\tif (ret)\n\t\treturn ret;\n\n\tattr.dst = gd_addr;\n\n\t \n\tret = __stmmac_test_loopback(priv, &attr);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tattr.dst = bd_addr;\n\n\t \n\tret = __stmmac_test_loopback(priv, &attr);\n\tret = ret ? 0 : -EINVAL;\n\ncleanup:\n\tdev_mc_del(priv->dev, gd_addr);\n\treturn ret;\n}\n\nstatic int stmmac_test_pfilt(struct stmmac_priv *priv)\n{\n\tunsigned char gd_addr[ETH_ALEN] = {0xf0, 0x01, 0x44, 0x55, 0x66, 0x77};\n\tunsigned char bd_addr[ETH_ALEN] = {0xf0, 0xff, 0xff, 0xff, 0xff, 0xff};\n\tstruct stmmac_packet_attrs attr = { };\n\tint ret, tries = 256;\n\n\tif (stmmac_filter_check(priv))\n\t\treturn -EOPNOTSUPP;\n\tif (netdev_uc_count(priv->dev) >= priv->hw->unicast_filter_entries)\n\t\treturn -EOPNOTSUPP;\n\n\twhile (--tries) {\n\t\t \n\t\tbd_addr[ETH_ALEN - 1] = tries;\n\t\tif (stmmac_perfect_check(priv, bd_addr))\n\t\t\tbreak;\n\t}\n\n\tif (!tries)\n\t\treturn -EOPNOTSUPP;\n\n\tret = dev_uc_add(priv->dev, gd_addr);\n\tif (ret)\n\t\treturn ret;\n\n\tattr.dst = gd_addr;\n\n\t \n\tret = __stmmac_test_loopback(priv, &attr);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tattr.dst = bd_addr;\n\n\t \n\tret = __stmmac_test_loopback(priv, &attr);\n\tret = ret ? 0 : -EINVAL;\n\ncleanup:\n\tdev_uc_del(priv->dev, gd_addr);\n\treturn ret;\n}\n\nstatic int stmmac_test_mcfilt(struct stmmac_priv *priv)\n{\n\tunsigned char uc_addr[ETH_ALEN] = {0xf0, 0xff, 0xff, 0xff, 0xff, 0xff};\n\tunsigned char mc_addr[ETH_ALEN] = {0xf1, 0xff, 0xff, 0xff, 0xff, 0xff};\n\tstruct stmmac_packet_attrs attr = { };\n\tint ret, tries = 256;\n\n\tif (stmmac_filter_check(priv))\n\t\treturn -EOPNOTSUPP;\n\tif (netdev_uc_count(priv->dev) >= priv->hw->unicast_filter_entries)\n\t\treturn -EOPNOTSUPP;\n\tif (netdev_mc_count(priv->dev) >= priv->hw->multicast_filter_bins)\n\t\treturn -EOPNOTSUPP;\n\n\twhile (--tries) {\n\t\t \n\t\tmc_addr[ETH_ALEN - 1] = tries;\n\t\tif (stmmac_hash_check(priv, mc_addr))\n\t\t\tbreak;\n\t}\n\n\tif (!tries)\n\t\treturn -EOPNOTSUPP;\n\n\tret = dev_uc_add(priv->dev, uc_addr);\n\tif (ret)\n\t\treturn ret;\n\n\tattr.dst = uc_addr;\n\n\t \n\tret = __stmmac_test_loopback(priv, &attr);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tattr.dst = mc_addr;\n\n\t \n\tret = __stmmac_test_loopback(priv, &attr);\n\tret = ret ? 0 : -EINVAL;\n\ncleanup:\n\tdev_uc_del(priv->dev, uc_addr);\n\treturn ret;\n}\n\nstatic int stmmac_test_ucfilt(struct stmmac_priv *priv)\n{\n\tunsigned char uc_addr[ETH_ALEN] = {0xf0, 0xff, 0xff, 0xff, 0xff, 0xff};\n\tunsigned char mc_addr[ETH_ALEN] = {0xf1, 0xff, 0xff, 0xff, 0xff, 0xff};\n\tstruct stmmac_packet_attrs attr = { };\n\tint ret, tries = 256;\n\n\tif (stmmac_filter_check(priv))\n\t\treturn -EOPNOTSUPP;\n\tif (netdev_uc_count(priv->dev) >= priv->hw->unicast_filter_entries)\n\t\treturn -EOPNOTSUPP;\n\tif (netdev_mc_count(priv->dev) >= priv->hw->multicast_filter_bins)\n\t\treturn -EOPNOTSUPP;\n\n\twhile (--tries) {\n\t\t \n\t\tuc_addr[ETH_ALEN - 1] = tries;\n\t\tif (stmmac_perfect_check(priv, uc_addr))\n\t\t\tbreak;\n\t}\n\n\tif (!tries)\n\t\treturn -EOPNOTSUPP;\n\n\tret = dev_mc_add(priv->dev, mc_addr);\n\tif (ret)\n\t\treturn ret;\n\n\tattr.dst = mc_addr;\n\n\t \n\tret = __stmmac_test_loopback(priv, &attr);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tattr.dst = uc_addr;\n\n\t \n\tret = __stmmac_test_loopback(priv, &attr);\n\tret = ret ? 0 : -EINVAL;\n\ncleanup:\n\tdev_mc_del(priv->dev, mc_addr);\n\treturn ret;\n}\n\nstatic int stmmac_test_flowctrl_validate(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *ndev,\n\t\t\t\t\t struct packet_type *pt,\n\t\t\t\t\t struct net_device *orig_ndev)\n{\n\tstruct stmmac_test_priv *tpriv = pt->af_packet_priv;\n\tstruct ethhdr *ehdr;\n\n\tehdr = (struct ethhdr *)skb_mac_header(skb);\n\tif (!ether_addr_equal_unaligned(ehdr->h_source, orig_ndev->dev_addr))\n\t\tgoto out;\n\tif (ehdr->h_proto != htons(ETH_P_PAUSE))\n\t\tgoto out;\n\n\ttpriv->ok = true;\n\tcomplete(&tpriv->comp);\nout:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int stmmac_test_flowctrl(struct stmmac_priv *priv)\n{\n\tunsigned char paddr[ETH_ALEN] = {0x01, 0x80, 0xC2, 0x00, 0x00, 0x01};\n\tstruct phy_device *phydev = priv->dev->phydev;\n\tu32 rx_cnt = priv->plat->rx_queues_to_use;\n\tstruct stmmac_test_priv *tpriv;\n\tunsigned int pkt_count;\n\tint i, ret = 0;\n\n\tif (!phydev || (!phydev->pause && !phydev->asym_pause))\n\t\treturn -EOPNOTSUPP;\n\n\ttpriv = kzalloc(sizeof(*tpriv), GFP_KERNEL);\n\tif (!tpriv)\n\t\treturn -ENOMEM;\n\n\ttpriv->ok = false;\n\tinit_completion(&tpriv->comp);\n\ttpriv->pt.type = htons(ETH_P_PAUSE);\n\ttpriv->pt.func = stmmac_test_flowctrl_validate;\n\ttpriv->pt.dev = priv->dev;\n\ttpriv->pt.af_packet_priv = tpriv;\n\tdev_add_pack(&tpriv->pt);\n\n\t \n\tpkt_count = priv->plat->rx_fifo_size;\n\tif (!pkt_count)\n\t\tpkt_count = priv->dma_cap.rx_fifo_size;\n\tpkt_count /= 1400;\n\tpkt_count *= 2;\n\n\tfor (i = 0; i < rx_cnt; i++)\n\t\tstmmac_stop_rx(priv, priv->ioaddr, i);\n\n\tret = dev_set_promiscuity(priv->dev, 1);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tret = dev_mc_add(priv->dev, paddr);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < pkt_count; i++) {\n\t\tstruct stmmac_packet_attrs attr = { };\n\n\t\tattr.dst = priv->dev->dev_addr;\n\t\tattr.dont_wait = true;\n\t\tattr.size = 1400;\n\n\t\tret = __stmmac_test_loopback(priv, &attr);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t\tif (tpriv->ok)\n\t\t\tbreak;\n\t}\n\n\t \n\tmsleep(200);\n\n\tfor (i = 0; i < rx_cnt; i++) {\n\t\tstruct stmmac_channel *ch = &priv->channel[i];\n\t\tu32 tail;\n\n\t\ttail = priv->dma_conf.rx_queue[i].dma_rx_phy +\n\t\t\t(priv->dma_conf.dma_rx_size * sizeof(struct dma_desc));\n\n\t\tstmmac_set_rx_tail_ptr(priv, priv->ioaddr, tail, i);\n\t\tstmmac_start_rx(priv, priv->ioaddr, i);\n\n\t\tlocal_bh_disable();\n\t\tnapi_reschedule(&ch->rx_napi);\n\t\tlocal_bh_enable();\n\t}\n\n\twait_for_completion_timeout(&tpriv->comp, STMMAC_LB_TIMEOUT);\n\tret = tpriv->ok ? 0 : -ETIMEDOUT;\n\ncleanup:\n\tdev_mc_del(priv->dev, paddr);\n\tdev_set_promiscuity(priv->dev, -1);\n\tdev_remove_pack(&tpriv->pt);\n\tkfree(tpriv);\n\treturn ret;\n}\n\nstatic int stmmac_test_rss(struct stmmac_priv *priv)\n{\n\tstruct stmmac_packet_attrs attr = { };\n\n\tif (!priv->dma_cap.rssen || !priv->rss.enable)\n\t\treturn -EOPNOTSUPP;\n\n\tattr.dst = priv->dev->dev_addr;\n\tattr.exp_hash = true;\n\tattr.sport = 0x321;\n\tattr.dport = 0x123;\n\n\treturn __stmmac_test_loopback(priv, &attr);\n}\n\nstatic int stmmac_test_vlan_validate(struct sk_buff *skb,\n\t\t\t\t     struct net_device *ndev,\n\t\t\t\t     struct packet_type *pt,\n\t\t\t\t     struct net_device *orig_ndev)\n{\n\tstruct stmmac_test_priv *tpriv = pt->af_packet_priv;\n\tstruct stmmachdr *shdr;\n\tstruct ethhdr *ehdr;\n\tstruct udphdr *uhdr;\n\tstruct iphdr *ihdr;\n\tu16 proto;\n\n\tproto = tpriv->double_vlan ? ETH_P_8021AD : ETH_P_8021Q;\n\n\tskb = skb_unshare(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto out;\n\n\tif (skb_linearize(skb))\n\t\tgoto out;\n\tif (skb_headlen(skb) < (STMMAC_TEST_PKT_SIZE - ETH_HLEN))\n\t\tgoto out;\n\tif (tpriv->vlan_id) {\n\t\tif (skb->vlan_proto != htons(proto))\n\t\t\tgoto out;\n\t\tif (skb->vlan_tci != tpriv->vlan_id) {\n\t\t\t \n\t\t\ttpriv->ok = false;\n\t\t\tcomplete(&tpriv->comp);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tehdr = (struct ethhdr *)skb_mac_header(skb);\n\tif (!ether_addr_equal_unaligned(ehdr->h_dest, tpriv->packet->dst))\n\t\tgoto out;\n\n\tihdr = ip_hdr(skb);\n\tif (tpriv->double_vlan)\n\t\tihdr = (struct iphdr *)(skb_network_header(skb) + 4);\n\tif (ihdr->protocol != IPPROTO_UDP)\n\t\tgoto out;\n\n\tuhdr = (struct udphdr *)((u8 *)ihdr + 4 * ihdr->ihl);\n\tif (uhdr->dest != htons(tpriv->packet->dport))\n\t\tgoto out;\n\n\tshdr = (struct stmmachdr *)((u8 *)uhdr + sizeof(*uhdr));\n\tif (shdr->magic != cpu_to_be64(STMMAC_TEST_PKT_MAGIC))\n\t\tgoto out;\n\n\ttpriv->ok = true;\n\tcomplete(&tpriv->comp);\n\nout:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int __stmmac_test_vlanfilt(struct stmmac_priv *priv)\n{\n\tstruct stmmac_packet_attrs attr = { };\n\tstruct stmmac_test_priv *tpriv;\n\tstruct sk_buff *skb = NULL;\n\tint ret = 0, i;\n\n\ttpriv = kzalloc(sizeof(*tpriv), GFP_KERNEL);\n\tif (!tpriv)\n\t\treturn -ENOMEM;\n\n\ttpriv->ok = false;\n\tinit_completion(&tpriv->comp);\n\n\ttpriv->pt.type = htons(ETH_P_IP);\n\ttpriv->pt.func = stmmac_test_vlan_validate;\n\ttpriv->pt.dev = priv->dev;\n\ttpriv->pt.af_packet_priv = tpriv;\n\ttpriv->packet = &attr;\n\n\t \n\ttpriv->vlan_id = 0x123;\n\tdev_add_pack(&tpriv->pt);\n\n\tret = vlan_vid_add(priv->dev, htons(ETH_P_8021Q), tpriv->vlan_id);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tattr.vlan = 1;\n\t\tattr.vlan_id_out = tpriv->vlan_id + i;\n\t\tattr.dst = priv->dev->dev_addr;\n\t\tattr.sport = 9;\n\t\tattr.dport = 9;\n\n\t\tskb = stmmac_test_get_udp_skb(priv, &attr);\n\t\tif (!skb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto vlan_del;\n\t\t}\n\n\t\tret = dev_direct_xmit(skb, 0);\n\t\tif (ret)\n\t\t\tgoto vlan_del;\n\n\t\twait_for_completion_timeout(&tpriv->comp, STMMAC_LB_TIMEOUT);\n\t\tret = tpriv->ok ? 0 : -ETIMEDOUT;\n\t\tif (ret && !i) {\n\t\t\tgoto vlan_del;\n\t\t} else if (!ret && i) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto vlan_del;\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\n\t\ttpriv->ok = false;\n\t}\n\nvlan_del:\n\tvlan_vid_del(priv->dev, htons(ETH_P_8021Q), tpriv->vlan_id);\ncleanup:\n\tdev_remove_pack(&tpriv->pt);\n\tkfree(tpriv);\n\treturn ret;\n}\n\nstatic int stmmac_test_vlanfilt(struct stmmac_priv *priv)\n{\n\tif (!priv->dma_cap.vlhash)\n\t\treturn -EOPNOTSUPP;\n\n\treturn __stmmac_test_vlanfilt(priv);\n}\n\nstatic int stmmac_test_vlanfilt_perfect(struct stmmac_priv *priv)\n{\n\tint ret, prev_cap = priv->dma_cap.vlhash;\n\n\tif (!(priv->dev->features & NETIF_F_HW_VLAN_CTAG_FILTER))\n\t\treturn -EOPNOTSUPP;\n\n\tpriv->dma_cap.vlhash = 0;\n\tret = __stmmac_test_vlanfilt(priv);\n\tpriv->dma_cap.vlhash = prev_cap;\n\n\treturn ret;\n}\n\nstatic int __stmmac_test_dvlanfilt(struct stmmac_priv *priv)\n{\n\tstruct stmmac_packet_attrs attr = { };\n\tstruct stmmac_test_priv *tpriv;\n\tstruct sk_buff *skb = NULL;\n\tint ret = 0, i;\n\n\ttpriv = kzalloc(sizeof(*tpriv), GFP_KERNEL);\n\tif (!tpriv)\n\t\treturn -ENOMEM;\n\n\ttpriv->ok = false;\n\ttpriv->double_vlan = true;\n\tinit_completion(&tpriv->comp);\n\n\ttpriv->pt.type = htons(ETH_P_8021Q);\n\ttpriv->pt.func = stmmac_test_vlan_validate;\n\ttpriv->pt.dev = priv->dev;\n\ttpriv->pt.af_packet_priv = tpriv;\n\ttpriv->packet = &attr;\n\n\t \n\ttpriv->vlan_id = 0x123;\n\tdev_add_pack(&tpriv->pt);\n\n\tret = vlan_vid_add(priv->dev, htons(ETH_P_8021AD), tpriv->vlan_id);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tattr.vlan = 2;\n\t\tattr.vlan_id_out = tpriv->vlan_id + i;\n\t\tattr.dst = priv->dev->dev_addr;\n\t\tattr.sport = 9;\n\t\tattr.dport = 9;\n\n\t\tskb = stmmac_test_get_udp_skb(priv, &attr);\n\t\tif (!skb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto vlan_del;\n\t\t}\n\n\t\tret = dev_direct_xmit(skb, 0);\n\t\tif (ret)\n\t\t\tgoto vlan_del;\n\n\t\twait_for_completion_timeout(&tpriv->comp, STMMAC_LB_TIMEOUT);\n\t\tret = tpriv->ok ? 0 : -ETIMEDOUT;\n\t\tif (ret && !i) {\n\t\t\tgoto vlan_del;\n\t\t} else if (!ret && i) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto vlan_del;\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\n\t\ttpriv->ok = false;\n\t}\n\nvlan_del:\n\tvlan_vid_del(priv->dev, htons(ETH_P_8021AD), tpriv->vlan_id);\ncleanup:\n\tdev_remove_pack(&tpriv->pt);\n\tkfree(tpriv);\n\treturn ret;\n}\n\nstatic int stmmac_test_dvlanfilt(struct stmmac_priv *priv)\n{\n\tif (!priv->dma_cap.vlhash)\n\t\treturn -EOPNOTSUPP;\n\n\treturn __stmmac_test_dvlanfilt(priv);\n}\n\nstatic int stmmac_test_dvlanfilt_perfect(struct stmmac_priv *priv)\n{\n\tint ret, prev_cap = priv->dma_cap.vlhash;\n\n\tif (!(priv->dev->features & NETIF_F_HW_VLAN_STAG_FILTER))\n\t\treturn -EOPNOTSUPP;\n\n\tpriv->dma_cap.vlhash = 0;\n\tret = __stmmac_test_dvlanfilt(priv);\n\tpriv->dma_cap.vlhash = prev_cap;\n\n\treturn ret;\n}\n\n#ifdef CONFIG_NET_CLS_ACT\nstatic int stmmac_test_rxp(struct stmmac_priv *priv)\n{\n\tunsigned char addr[ETH_ALEN] = {0xde, 0xad, 0xbe, 0xef, 0x00, 0x00};\n\tstruct tc_cls_u32_offload cls_u32 = { };\n\tstruct stmmac_packet_attrs attr = { };\n\tstruct tc_action **actions;\n\tstruct tc_u32_sel *sel;\n\tstruct tcf_gact *gact;\n\tstruct tcf_exts *exts;\n\tint ret, i, nk = 1;\n\n\tif (!tc_can_offload(priv->dev))\n\t\treturn -EOPNOTSUPP;\n\tif (!priv->dma_cap.frpsel)\n\t\treturn -EOPNOTSUPP;\n\n\tsel = kzalloc(struct_size(sel, keys, nk), GFP_KERNEL);\n\tif (!sel)\n\t\treturn -ENOMEM;\n\n\texts = kzalloc(sizeof(*exts), GFP_KERNEL);\n\tif (!exts) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup_sel;\n\t}\n\n\tactions = kcalloc(nk, sizeof(*actions), GFP_KERNEL);\n\tif (!actions) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup_exts;\n\t}\n\n\tgact = kcalloc(nk, sizeof(*gact), GFP_KERNEL);\n\tif (!gact) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup_actions;\n\t}\n\n\tcls_u32.command = TC_CLSU32_NEW_KNODE;\n\tcls_u32.common.chain_index = 0;\n\tcls_u32.common.protocol = htons(ETH_P_ALL);\n\tcls_u32.knode.exts = exts;\n\tcls_u32.knode.sel = sel;\n\tcls_u32.knode.handle = 0x123;\n\n\texts->nr_actions = nk;\n\texts->actions = actions;\n\tfor (i = 0; i < nk; i++) {\n\t\tactions[i] = (struct tc_action *)&gact[i];\n\t\tgact->tcf_action = TC_ACT_SHOT;\n\t}\n\n\tsel->nkeys = nk;\n\tsel->offshift = 0;\n\tsel->keys[0].off = 6;\n\tsel->keys[0].val = htonl(0xdeadbeef);\n\tsel->keys[0].mask = ~0x0;\n\n\tret = stmmac_tc_setup_cls_u32(priv, priv, &cls_u32);\n\tif (ret)\n\t\tgoto cleanup_act;\n\n\tattr.dst = priv->dev->dev_addr;\n\tattr.src = addr;\n\n\tret = __stmmac_test_loopback(priv, &attr);\n\tret = ret ? 0 : -EINVAL;  \n\n\tcls_u32.command = TC_CLSU32_DELETE_KNODE;\n\tstmmac_tc_setup_cls_u32(priv, priv, &cls_u32);\n\ncleanup_act:\n\tkfree(gact);\ncleanup_actions:\n\tkfree(actions);\ncleanup_exts:\n\tkfree(exts);\ncleanup_sel:\n\tkfree(sel);\n\treturn ret;\n}\n#else\nstatic int stmmac_test_rxp(struct stmmac_priv *priv)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\nstatic int stmmac_test_desc_sai(struct stmmac_priv *priv)\n{\n\tunsigned char src[ETH_ALEN] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\tstruct stmmac_packet_attrs attr = { };\n\tint ret;\n\n\tif (!priv->dma_cap.vlins)\n\t\treturn -EOPNOTSUPP;\n\n\tattr.remove_sa = true;\n\tattr.sarc = true;\n\tattr.src = src;\n\tattr.dst = priv->dev->dev_addr;\n\n\tpriv->sarc_type = 0x1;\n\n\tret = __stmmac_test_loopback(priv, &attr);\n\n\tpriv->sarc_type = 0x0;\n\treturn ret;\n}\n\nstatic int stmmac_test_desc_sar(struct stmmac_priv *priv)\n{\n\tunsigned char src[ETH_ALEN] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\tstruct stmmac_packet_attrs attr = { };\n\tint ret;\n\n\tif (!priv->dma_cap.vlins)\n\t\treturn -EOPNOTSUPP;\n\n\tattr.sarc = true;\n\tattr.src = src;\n\tattr.dst = priv->dev->dev_addr;\n\n\tpriv->sarc_type = 0x2;\n\n\tret = __stmmac_test_loopback(priv, &attr);\n\n\tpriv->sarc_type = 0x0;\n\treturn ret;\n}\n\nstatic int stmmac_test_reg_sai(struct stmmac_priv *priv)\n{\n\tunsigned char src[ETH_ALEN] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\tstruct stmmac_packet_attrs attr = { };\n\tint ret;\n\n\tif (!priv->dma_cap.vlins)\n\t\treturn -EOPNOTSUPP;\n\n\tattr.remove_sa = true;\n\tattr.sarc = true;\n\tattr.src = src;\n\tattr.dst = priv->dev->dev_addr;\n\n\tif (stmmac_sarc_configure(priv, priv->ioaddr, 0x2))\n\t\treturn -EOPNOTSUPP;\n\n\tret = __stmmac_test_loopback(priv, &attr);\n\n\tstmmac_sarc_configure(priv, priv->ioaddr, 0x0);\n\treturn ret;\n}\n\nstatic int stmmac_test_reg_sar(struct stmmac_priv *priv)\n{\n\tunsigned char src[ETH_ALEN] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\tstruct stmmac_packet_attrs attr = { };\n\tint ret;\n\n\tif (!priv->dma_cap.vlins)\n\t\treturn -EOPNOTSUPP;\n\n\tattr.sarc = true;\n\tattr.src = src;\n\tattr.dst = priv->dev->dev_addr;\n\n\tif (stmmac_sarc_configure(priv, priv->ioaddr, 0x3))\n\t\treturn -EOPNOTSUPP;\n\n\tret = __stmmac_test_loopback(priv, &attr);\n\n\tstmmac_sarc_configure(priv, priv->ioaddr, 0x0);\n\treturn ret;\n}\n\nstatic int stmmac_test_vlanoff_common(struct stmmac_priv *priv, bool svlan)\n{\n\tstruct stmmac_packet_attrs attr = { };\n\tstruct stmmac_test_priv *tpriv;\n\tstruct sk_buff *skb = NULL;\n\tint ret = 0;\n\tu16 proto;\n\n\tif (!priv->dma_cap.vlins)\n\t\treturn -EOPNOTSUPP;\n\n\ttpriv = kzalloc(sizeof(*tpriv), GFP_KERNEL);\n\tif (!tpriv)\n\t\treturn -ENOMEM;\n\n\tproto = svlan ? ETH_P_8021AD : ETH_P_8021Q;\n\n\ttpriv->ok = false;\n\ttpriv->double_vlan = svlan;\n\tinit_completion(&tpriv->comp);\n\n\ttpriv->pt.type = svlan ? htons(ETH_P_8021Q) : htons(ETH_P_IP);\n\ttpriv->pt.func = stmmac_test_vlan_validate;\n\ttpriv->pt.dev = priv->dev;\n\ttpriv->pt.af_packet_priv = tpriv;\n\ttpriv->packet = &attr;\n\ttpriv->vlan_id = 0x123;\n\tdev_add_pack(&tpriv->pt);\n\n\tret = vlan_vid_add(priv->dev, htons(proto), tpriv->vlan_id);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tattr.dst = priv->dev->dev_addr;\n\n\tskb = stmmac_test_get_udp_skb(priv, &attr);\n\tif (!skb) {\n\t\tret = -ENOMEM;\n\t\tgoto vlan_del;\n\t}\n\n\t__vlan_hwaccel_put_tag(skb, htons(proto), tpriv->vlan_id);\n\tskb->protocol = htons(proto);\n\n\tret = dev_direct_xmit(skb, 0);\n\tif (ret)\n\t\tgoto vlan_del;\n\n\twait_for_completion_timeout(&tpriv->comp, STMMAC_LB_TIMEOUT);\n\tret = tpriv->ok ? 0 : -ETIMEDOUT;\n\nvlan_del:\n\tvlan_vid_del(priv->dev, htons(proto), tpriv->vlan_id);\ncleanup:\n\tdev_remove_pack(&tpriv->pt);\n\tkfree(tpriv);\n\treturn ret;\n}\n\nstatic int stmmac_test_vlanoff(struct stmmac_priv *priv)\n{\n\treturn stmmac_test_vlanoff_common(priv, false);\n}\n\nstatic int stmmac_test_svlanoff(struct stmmac_priv *priv)\n{\n\tif (!priv->dma_cap.dvlan)\n\t\treturn -EOPNOTSUPP;\n\treturn stmmac_test_vlanoff_common(priv, true);\n}\n\n#ifdef CONFIG_NET_CLS_ACT\nstatic int __stmmac_test_l3filt(struct stmmac_priv *priv, u32 dst, u32 src,\n\t\t\t\tu32 dst_mask, u32 src_mask)\n{\n\tstruct flow_dissector_key_ipv4_addrs key, mask;\n\tunsigned long dummy_cookie = 0xdeadbeef;\n\tstruct stmmac_packet_attrs attr = { };\n\tstruct flow_dissector *dissector;\n\tstruct flow_cls_offload *cls;\n\tint ret, old_enable = 0;\n\tstruct flow_rule *rule;\n\n\tif (!tc_can_offload(priv->dev))\n\t\treturn -EOPNOTSUPP;\n\tif (!priv->dma_cap.l3l4fnum)\n\t\treturn -EOPNOTSUPP;\n\tif (priv->rss.enable) {\n\t\told_enable = priv->rss.enable;\n\t\tpriv->rss.enable = false;\n\t\tstmmac_rss_configure(priv, priv->hw, NULL,\n\t\t\t\t     priv->plat->rx_queues_to_use);\n\t}\n\n\tdissector = kzalloc(sizeof(*dissector), GFP_KERNEL);\n\tif (!dissector) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup_rss;\n\t}\n\n\tdissector->used_keys |= (1ULL << FLOW_DISSECTOR_KEY_IPV4_ADDRS);\n\tdissector->offset[FLOW_DISSECTOR_KEY_IPV4_ADDRS] = 0;\n\n\tcls = kzalloc(sizeof(*cls), GFP_KERNEL);\n\tif (!cls) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup_dissector;\n\t}\n\n\tcls->common.chain_index = 0;\n\tcls->command = FLOW_CLS_REPLACE;\n\tcls->cookie = dummy_cookie;\n\n\trule = kzalloc(struct_size(rule, action.entries, 1), GFP_KERNEL);\n\tif (!rule) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup_cls;\n\t}\n\n\trule->match.dissector = dissector;\n\trule->match.key = (void *)&key;\n\trule->match.mask = (void *)&mask;\n\n\tkey.src = htonl(src);\n\tkey.dst = htonl(dst);\n\tmask.src = src_mask;\n\tmask.dst = dst_mask;\n\n\tcls->rule = rule;\n\n\trule->action.entries[0].id = FLOW_ACTION_DROP;\n\trule->action.entries[0].hw_stats = FLOW_ACTION_HW_STATS_ANY;\n\trule->action.num_entries = 1;\n\n\tattr.dst = priv->dev->dev_addr;\n\tattr.ip_dst = dst;\n\tattr.ip_src = src;\n\n\t \n\tret = __stmmac_test_loopback(priv, &attr);\n\tif (ret)\n\t\tgoto cleanup_rule;\n\n\tret = stmmac_tc_setup_cls(priv, priv, cls);\n\tif (ret)\n\t\tgoto cleanup_rule;\n\n\t \n\tret = __stmmac_test_loopback(priv, &attr);\n\tret = ret ? 0 : -EINVAL;\n\n\tcls->command = FLOW_CLS_DESTROY;\n\tstmmac_tc_setup_cls(priv, priv, cls);\ncleanup_rule:\n\tkfree(rule);\ncleanup_cls:\n\tkfree(cls);\ncleanup_dissector:\n\tkfree(dissector);\ncleanup_rss:\n\tif (old_enable) {\n\t\tpriv->rss.enable = old_enable;\n\t\tstmmac_rss_configure(priv, priv->hw, &priv->rss,\n\t\t\t\t     priv->plat->rx_queues_to_use);\n\t}\n\n\treturn ret;\n}\n#else\nstatic int __stmmac_test_l3filt(struct stmmac_priv *priv, u32 dst, u32 src,\n\t\t\t\tu32 dst_mask, u32 src_mask)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\nstatic int stmmac_test_l3filt_da(struct stmmac_priv *priv)\n{\n\tu32 addr = 0x10203040;\n\n\treturn __stmmac_test_l3filt(priv, addr, 0, ~0, 0);\n}\n\nstatic int stmmac_test_l3filt_sa(struct stmmac_priv *priv)\n{\n\tu32 addr = 0x10203040;\n\n\treturn __stmmac_test_l3filt(priv, 0, addr, 0, ~0);\n}\n\n#ifdef CONFIG_NET_CLS_ACT\nstatic int __stmmac_test_l4filt(struct stmmac_priv *priv, u32 dst, u32 src,\n\t\t\t\tu32 dst_mask, u32 src_mask, bool udp)\n{\n\tstruct {\n\t\tstruct flow_dissector_key_basic bkey;\n\t\tstruct flow_dissector_key_ports key;\n\t} __aligned(BITS_PER_LONG / 8) keys;\n\tstruct {\n\t\tstruct flow_dissector_key_basic bmask;\n\t\tstruct flow_dissector_key_ports mask;\n\t} __aligned(BITS_PER_LONG / 8) masks;\n\tunsigned long dummy_cookie = 0xdeadbeef;\n\tstruct stmmac_packet_attrs attr = { };\n\tstruct flow_dissector *dissector;\n\tstruct flow_cls_offload *cls;\n\tint ret, old_enable = 0;\n\tstruct flow_rule *rule;\n\n\tif (!tc_can_offload(priv->dev))\n\t\treturn -EOPNOTSUPP;\n\tif (!priv->dma_cap.l3l4fnum)\n\t\treturn -EOPNOTSUPP;\n\tif (priv->rss.enable) {\n\t\told_enable = priv->rss.enable;\n\t\tpriv->rss.enable = false;\n\t\tstmmac_rss_configure(priv, priv->hw, NULL,\n\t\t\t\t     priv->plat->rx_queues_to_use);\n\t}\n\n\tdissector = kzalloc(sizeof(*dissector), GFP_KERNEL);\n\tif (!dissector) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup_rss;\n\t}\n\n\tdissector->used_keys |= (1ULL << FLOW_DISSECTOR_KEY_BASIC);\n\tdissector->used_keys |= (1ULL << FLOW_DISSECTOR_KEY_PORTS);\n\tdissector->offset[FLOW_DISSECTOR_KEY_BASIC] = 0;\n\tdissector->offset[FLOW_DISSECTOR_KEY_PORTS] = offsetof(typeof(keys), key);\n\n\tcls = kzalloc(sizeof(*cls), GFP_KERNEL);\n\tif (!cls) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup_dissector;\n\t}\n\n\tcls->common.chain_index = 0;\n\tcls->command = FLOW_CLS_REPLACE;\n\tcls->cookie = dummy_cookie;\n\n\trule = kzalloc(struct_size(rule, action.entries, 1), GFP_KERNEL);\n\tif (!rule) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup_cls;\n\t}\n\n\trule->match.dissector = dissector;\n\trule->match.key = (void *)&keys;\n\trule->match.mask = (void *)&masks;\n\n\tkeys.bkey.ip_proto = udp ? IPPROTO_UDP : IPPROTO_TCP;\n\tkeys.key.src = htons(src);\n\tkeys.key.dst = htons(dst);\n\tmasks.mask.src = src_mask;\n\tmasks.mask.dst = dst_mask;\n\n\tcls->rule = rule;\n\n\trule->action.entries[0].id = FLOW_ACTION_DROP;\n\trule->action.entries[0].hw_stats = FLOW_ACTION_HW_STATS_ANY;\n\trule->action.num_entries = 1;\n\n\tattr.dst = priv->dev->dev_addr;\n\tattr.tcp = !udp;\n\tattr.sport = src;\n\tattr.dport = dst;\n\tattr.ip_dst = 0;\n\n\t \n\tret = __stmmac_test_loopback(priv, &attr);\n\tif (ret)\n\t\tgoto cleanup_rule;\n\n\tret = stmmac_tc_setup_cls(priv, priv, cls);\n\tif (ret)\n\t\tgoto cleanup_rule;\n\n\t \n\tret = __stmmac_test_loopback(priv, &attr);\n\tret = ret ? 0 : -EINVAL;\n\n\tcls->command = FLOW_CLS_DESTROY;\n\tstmmac_tc_setup_cls(priv, priv, cls);\ncleanup_rule:\n\tkfree(rule);\ncleanup_cls:\n\tkfree(cls);\ncleanup_dissector:\n\tkfree(dissector);\ncleanup_rss:\n\tif (old_enable) {\n\t\tpriv->rss.enable = old_enable;\n\t\tstmmac_rss_configure(priv, priv->hw, &priv->rss,\n\t\t\t\t     priv->plat->rx_queues_to_use);\n\t}\n\n\treturn ret;\n}\n#else\nstatic int __stmmac_test_l4filt(struct stmmac_priv *priv, u32 dst, u32 src,\n\t\t\t\tu32 dst_mask, u32 src_mask, bool udp)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\nstatic int stmmac_test_l4filt_da_tcp(struct stmmac_priv *priv)\n{\n\tu16 dummy_port = 0x123;\n\n\treturn __stmmac_test_l4filt(priv, dummy_port, 0, ~0, 0, false);\n}\n\nstatic int stmmac_test_l4filt_sa_tcp(struct stmmac_priv *priv)\n{\n\tu16 dummy_port = 0x123;\n\n\treturn __stmmac_test_l4filt(priv, 0, dummy_port, 0, ~0, false);\n}\n\nstatic int stmmac_test_l4filt_da_udp(struct stmmac_priv *priv)\n{\n\tu16 dummy_port = 0x123;\n\n\treturn __stmmac_test_l4filt(priv, dummy_port, 0, ~0, 0, true);\n}\n\nstatic int stmmac_test_l4filt_sa_udp(struct stmmac_priv *priv)\n{\n\tu16 dummy_port = 0x123;\n\n\treturn __stmmac_test_l4filt(priv, 0, dummy_port, 0, ~0, true);\n}\n\nstatic int stmmac_test_arp_validate(struct sk_buff *skb,\n\t\t\t\t    struct net_device *ndev,\n\t\t\t\t    struct packet_type *pt,\n\t\t\t\t    struct net_device *orig_ndev)\n{\n\tstruct stmmac_test_priv *tpriv = pt->af_packet_priv;\n\tstruct ethhdr *ehdr;\n\tstruct arphdr *ahdr;\n\n\tehdr = (struct ethhdr *)skb_mac_header(skb);\n\tif (!ether_addr_equal_unaligned(ehdr->h_dest, tpriv->packet->src))\n\t\tgoto out;\n\n\tahdr = arp_hdr(skb);\n\tif (ahdr->ar_op != htons(ARPOP_REPLY))\n\t\tgoto out;\n\n\ttpriv->ok = true;\n\tcomplete(&tpriv->comp);\nout:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int stmmac_test_arpoffload(struct stmmac_priv *priv)\n{\n\tunsigned char src[ETH_ALEN] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06};\n\tunsigned char dst[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\tstruct stmmac_packet_attrs attr = { };\n\tstruct stmmac_test_priv *tpriv;\n\tstruct sk_buff *skb = NULL;\n\tu32 ip_addr = 0xdeadcafe;\n\tu32 ip_src = 0xdeadbeef;\n\tint ret;\n\n\tif (!priv->dma_cap.arpoffsel)\n\t\treturn -EOPNOTSUPP;\n\n\ttpriv = kzalloc(sizeof(*tpriv), GFP_KERNEL);\n\tif (!tpriv)\n\t\treturn -ENOMEM;\n\n\ttpriv->ok = false;\n\tinit_completion(&tpriv->comp);\n\n\ttpriv->pt.type = htons(ETH_P_ARP);\n\ttpriv->pt.func = stmmac_test_arp_validate;\n\ttpriv->pt.dev = priv->dev;\n\ttpriv->pt.af_packet_priv = tpriv;\n\ttpriv->packet = &attr;\n\tdev_add_pack(&tpriv->pt);\n\n\tattr.src = src;\n\tattr.ip_src = ip_src;\n\tattr.dst = dst;\n\tattr.ip_dst = ip_addr;\n\n\tskb = stmmac_test_get_arp_skb(priv, &attr);\n\tif (!skb) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\tret = stmmac_set_arp_offload(priv, priv->hw, true, ip_addr);\n\tif (ret) {\n\t\tkfree_skb(skb);\n\t\tgoto cleanup;\n\t}\n\n\tret = dev_set_promiscuity(priv->dev, 1);\n\tif (ret) {\n\t\tkfree_skb(skb);\n\t\tgoto cleanup;\n\t}\n\n\tret = dev_direct_xmit(skb, 0);\n\tif (ret)\n\t\tgoto cleanup_promisc;\n\n\twait_for_completion_timeout(&tpriv->comp, STMMAC_LB_TIMEOUT);\n\tret = tpriv->ok ? 0 : -ETIMEDOUT;\n\ncleanup_promisc:\n\tdev_set_promiscuity(priv->dev, -1);\ncleanup:\n\tstmmac_set_arp_offload(priv, priv->hw, false, 0x0);\n\tdev_remove_pack(&tpriv->pt);\n\tkfree(tpriv);\n\treturn ret;\n}\n\nstatic int __stmmac_test_jumbo(struct stmmac_priv *priv, u16 queue)\n{\n\tstruct stmmac_packet_attrs attr = { };\n\tint size = priv->dma_conf.dma_buf_sz;\n\n\tattr.dst = priv->dev->dev_addr;\n\tattr.max_size = size - ETH_FCS_LEN;\n\tattr.queue_mapping = queue;\n\n\treturn __stmmac_test_loopback(priv, &attr);\n}\n\nstatic int stmmac_test_jumbo(struct stmmac_priv *priv)\n{\n\treturn __stmmac_test_jumbo(priv, 0);\n}\n\nstatic int stmmac_test_mjumbo(struct stmmac_priv *priv)\n{\n\tu32 chan, tx_cnt = priv->plat->tx_queues_to_use;\n\tint ret;\n\n\tif (tx_cnt <= 1)\n\t\treturn -EOPNOTSUPP;\n\n\tfor (chan = 0; chan < tx_cnt; chan++) {\n\t\tret = __stmmac_test_jumbo(priv, chan);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int stmmac_test_sph(struct stmmac_priv *priv)\n{\n\tunsigned long cnt_end, cnt_start = priv->xstats.rx_split_hdr_pkt_n;\n\tstruct stmmac_packet_attrs attr = { };\n\tint ret;\n\n\tif (!priv->sph)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tattr.dst = priv->dev->dev_addr;\n\tattr.tcp = false;\n\n\tret = __stmmac_test_loopback(priv, &attr);\n\tif (ret)\n\t\treturn ret;\n\n\tcnt_end = priv->xstats.rx_split_hdr_pkt_n;\n\tif (cnt_end <= cnt_start)\n\t\treturn -EINVAL;\n\n\t \n\tcnt_start = cnt_end;\n\n\tattr.dst = priv->dev->dev_addr;\n\tattr.tcp = true;\n\n\tret = __stmmac_test_loopback(priv, &attr);\n\tif (ret)\n\t\treturn ret;\n\n\tcnt_end = priv->xstats.rx_split_hdr_pkt_n;\n\tif (cnt_end <= cnt_start)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int stmmac_test_tbs(struct stmmac_priv *priv)\n{\n#define STMMAC_TBS_LT_OFFSET\t\t(500 * 1000 * 1000)  \n\tstruct stmmac_packet_attrs attr = { };\n\tstruct tc_etf_qopt_offload qopt;\n\tu64 start_time, curr_time = 0;\n\tunsigned long flags;\n\tint ret, i;\n\n\tif (!priv->hwts_tx_en)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tfor (i = 0; i < priv->plat->tx_queues_to_use; i++)\n\t\tif (priv->dma_conf.tx_queue[i].tbs & STMMAC_TBS_AVAIL)\n\t\t\tbreak;\n\n\tif (i >= priv->plat->tx_queues_to_use)\n\t\treturn -EOPNOTSUPP;\n\n\tqopt.enable = true;\n\tqopt.queue = i;\n\n\tret = stmmac_tc_setup_etf(priv, priv, &qopt);\n\tif (ret)\n\t\treturn ret;\n\n\tread_lock_irqsave(&priv->ptp_lock, flags);\n\tstmmac_get_systime(priv, priv->ptpaddr, &curr_time);\n\tread_unlock_irqrestore(&priv->ptp_lock, flags);\n\n\tif (!curr_time) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto fail_disable;\n\t}\n\n\tstart_time = curr_time;\n\tcurr_time += STMMAC_TBS_LT_OFFSET;\n\n\tattr.dst = priv->dev->dev_addr;\n\tattr.timestamp = curr_time;\n\tattr.timeout = nsecs_to_jiffies(2 * STMMAC_TBS_LT_OFFSET);\n\tattr.queue_mapping = i;\n\n\tret = __stmmac_test_loopback(priv, &attr);\n\tif (ret)\n\t\tgoto fail_disable;\n\n\t \n\tread_lock_irqsave(&priv->ptp_lock, flags);\n\tstmmac_get_systime(priv, priv->ptpaddr, &curr_time);\n\tread_unlock_irqrestore(&priv->ptp_lock, flags);\n\n\tif ((curr_time - start_time) < STMMAC_TBS_LT_OFFSET)\n\t\tret = -EINVAL;\n\nfail_disable:\n\tqopt.enable = false;\n\tstmmac_tc_setup_etf(priv, priv, &qopt);\n\treturn ret;\n}\n\n#define STMMAC_LOOPBACK_NONE\t0\n#define STMMAC_LOOPBACK_MAC\t1\n#define STMMAC_LOOPBACK_PHY\t2\n\nstatic const struct stmmac_test {\n\tchar name[ETH_GSTRING_LEN];\n\tint lb;\n\tint (*fn)(struct stmmac_priv *priv);\n} stmmac_selftests[] = {\n\t{\n\t\t.name = \"MAC Loopback               \",\n\t\t.lb = STMMAC_LOOPBACK_MAC,\n\t\t.fn = stmmac_test_mac_loopback,\n\t}, {\n\t\t.name = \"PHY Loopback               \",\n\t\t.lb = STMMAC_LOOPBACK_NONE,  \n\t\t.fn = stmmac_test_phy_loopback,\n\t}, {\n\t\t.name = \"MMC Counters               \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_mmc,\n\t}, {\n\t\t.name = \"EEE                        \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_eee,\n\t}, {\n\t\t.name = \"Hash Filter MC             \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_hfilt,\n\t}, {\n\t\t.name = \"Perfect Filter UC          \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_pfilt,\n\t}, {\n\t\t.name = \"MC Filter                  \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_mcfilt,\n\t}, {\n\t\t.name = \"UC Filter                  \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_ucfilt,\n\t}, {\n\t\t.name = \"Flow Control               \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_flowctrl,\n\t}, {\n\t\t.name = \"RSS                        \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_rss,\n\t}, {\n\t\t.name = \"VLAN Filtering             \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_vlanfilt,\n\t}, {\n\t\t.name = \"VLAN Filtering (perf)      \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_vlanfilt_perfect,\n\t}, {\n\t\t.name = \"Double VLAN Filter         \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_dvlanfilt,\n\t}, {\n\t\t.name = \"Double VLAN Filter (perf)  \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_dvlanfilt_perfect,\n\t}, {\n\t\t.name = \"Flexible RX Parser         \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_rxp,\n\t}, {\n\t\t.name = \"SA Insertion (desc)        \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_desc_sai,\n\t}, {\n\t\t.name = \"SA Replacement (desc)      \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_desc_sar,\n\t}, {\n\t\t.name = \"SA Insertion (reg)         \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_reg_sai,\n\t}, {\n\t\t.name = \"SA Replacement (reg)       \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_reg_sar,\n\t}, {\n\t\t.name = \"VLAN TX Insertion          \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_vlanoff,\n\t}, {\n\t\t.name = \"SVLAN TX Insertion         \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_svlanoff,\n\t}, {\n\t\t.name = \"L3 DA Filtering            \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_l3filt_da,\n\t}, {\n\t\t.name = \"L3 SA Filtering            \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_l3filt_sa,\n\t}, {\n\t\t.name = \"L4 DA TCP Filtering        \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_l4filt_da_tcp,\n\t}, {\n\t\t.name = \"L4 SA TCP Filtering        \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_l4filt_sa_tcp,\n\t}, {\n\t\t.name = \"L4 DA UDP Filtering        \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_l4filt_da_udp,\n\t}, {\n\t\t.name = \"L4 SA UDP Filtering        \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_l4filt_sa_udp,\n\t}, {\n\t\t.name = \"ARP Offload                \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_arpoffload,\n\t}, {\n\t\t.name = \"Jumbo Frame                \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_jumbo,\n\t}, {\n\t\t.name = \"Multichannel Jumbo         \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_mjumbo,\n\t}, {\n\t\t.name = \"Split Header               \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_sph,\n\t}, {\n\t\t.name = \"TBS (ETF Scheduler)        \",\n\t\t.lb = STMMAC_LOOPBACK_PHY,\n\t\t.fn = stmmac_test_tbs,\n\t},\n};\n\nvoid stmmac_selftest_run(struct net_device *dev,\n\t\t\t struct ethtool_test *etest, u64 *buf)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\tint count = stmmac_selftest_get_count(priv);\n\tint i, ret;\n\n\tmemset(buf, 0, sizeof(*buf) * count);\n\tstmmac_test_next_id = 0;\n\n\tif (etest->flags != ETH_TEST_FL_OFFLINE) {\n\t\tnetdev_err(priv->dev, \"Only offline tests are supported\\n\");\n\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\treturn;\n\t} else if (!netif_carrier_ok(dev)) {\n\t\tnetdev_err(priv->dev, \"You need valid Link to execute tests\\n\");\n\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\treturn;\n\t}\n\n\t \n\tmsleep(200);\n\n\tfor (i = 0; i < count; i++) {\n\t\tret = 0;\n\n\t\tswitch (stmmac_selftests[i].lb) {\n\t\tcase STMMAC_LOOPBACK_PHY:\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tif (dev->phydev)\n\t\t\t\tret = phy_loopback(dev->phydev, true);\n\t\t\tif (!ret)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase STMMAC_LOOPBACK_MAC:\n\t\t\tret = stmmac_set_mac_loopback(priv, priv->ioaddr, true);\n\t\t\tbreak;\n\t\tcase STMMAC_LOOPBACK_NONE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (ret) {\n\t\t\tnetdev_err(priv->dev, \"Loopback is not supported\\n\");\n\t\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = stmmac_selftests[i].fn(priv);\n\t\tif (ret && (ret != -EOPNOTSUPP))\n\t\t\tetest->flags |= ETH_TEST_FL_FAILED;\n\t\tbuf[i] = ret;\n\n\t\tswitch (stmmac_selftests[i].lb) {\n\t\tcase STMMAC_LOOPBACK_PHY:\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tif (dev->phydev)\n\t\t\t\tret = phy_loopback(dev->phydev, false);\n\t\t\tif (!ret)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase STMMAC_LOOPBACK_MAC:\n\t\t\tstmmac_set_mac_loopback(priv, priv->ioaddr, false);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid stmmac_selftest_get_strings(struct stmmac_priv *priv, u8 *data)\n{\n\tu8 *p = data;\n\tint i;\n\n\tfor (i = 0; i < stmmac_selftest_get_count(priv); i++) {\n\t\tsnprintf(p, ETH_GSTRING_LEN, \"%2d. %s\", i + 1,\n\t\t\t stmmac_selftests[i].name);\n\t\tp += ETH_GSTRING_LEN;\n\t}\n}\n\nint stmmac_selftest_get_count(struct stmmac_priv *priv)\n{\n\treturn ARRAY_SIZE(stmmac_selftests);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}