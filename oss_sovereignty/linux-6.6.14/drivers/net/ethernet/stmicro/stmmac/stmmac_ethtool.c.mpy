{
  "module_name": "stmmac_ethtool.c",
  "hash_id": "216e5a29fff65e524244d7cf79cd675f7932920e1169ad7e457eeee82c023777",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/interrupt.h>\n#include <linux/mii.h>\n#include <linux/phylink.h>\n#include <linux/net_tstamp.h>\n#include <asm/io.h>\n\n#include \"stmmac.h\"\n#include \"dwmac_dma.h\"\n#include \"dwxgmac2.h\"\n\n#define REG_SPACE_SIZE\t0x1060\n#define GMAC4_REG_SPACE_SIZE\t0x116C\n#define MAC100_ETHTOOL_NAME\t\"st_mac100\"\n#define GMAC_ETHTOOL_NAME\t\"st_gmac\"\n#define XGMAC_ETHTOOL_NAME\t\"st_xgmac\"\n\n \n#define GMAC4_DMA_CHAN_BASE_ADDR  0x00001100\n\n#define ETHTOOL_DMA_OFFSET\t55\n\nstruct stmmac_stats {\n\tchar stat_string[ETH_GSTRING_LEN];\n\tint sizeof_stat;\n\tint stat_offset;\n};\n\n#define STMMAC_STAT(m)\t\\\n\t{ #m, sizeof_field(struct stmmac_extra_stats, m),\t\\\n\toffsetof(struct stmmac_priv, xstats.m)}\n\nstatic const struct stmmac_stats stmmac_gstrings_stats[] = {\n\t \n\tSTMMAC_STAT(tx_underflow),\n\tSTMMAC_STAT(tx_carrier),\n\tSTMMAC_STAT(tx_losscarrier),\n\tSTMMAC_STAT(vlan_tag),\n\tSTMMAC_STAT(tx_deferred),\n\tSTMMAC_STAT(tx_vlan),\n\tSTMMAC_STAT(tx_jabber),\n\tSTMMAC_STAT(tx_frame_flushed),\n\tSTMMAC_STAT(tx_payload_error),\n\tSTMMAC_STAT(tx_ip_header_error),\n\t \n\tSTMMAC_STAT(rx_desc),\n\tSTMMAC_STAT(sa_filter_fail),\n\tSTMMAC_STAT(overflow_error),\n\tSTMMAC_STAT(ipc_csum_error),\n\tSTMMAC_STAT(rx_collision),\n\tSTMMAC_STAT(rx_crc_errors),\n\tSTMMAC_STAT(dribbling_bit),\n\tSTMMAC_STAT(rx_length),\n\tSTMMAC_STAT(rx_mii),\n\tSTMMAC_STAT(rx_multicast),\n\tSTMMAC_STAT(rx_gmac_overflow),\n\tSTMMAC_STAT(rx_watchdog),\n\tSTMMAC_STAT(da_rx_filter_fail),\n\tSTMMAC_STAT(sa_rx_filter_fail),\n\tSTMMAC_STAT(rx_missed_cntr),\n\tSTMMAC_STAT(rx_overflow_cntr),\n\tSTMMAC_STAT(rx_vlan),\n\tSTMMAC_STAT(rx_split_hdr_pkt_n),\n\t \n\tSTMMAC_STAT(tx_undeflow_irq),\n\tSTMMAC_STAT(tx_process_stopped_irq),\n\tSTMMAC_STAT(tx_jabber_irq),\n\tSTMMAC_STAT(rx_overflow_irq),\n\tSTMMAC_STAT(rx_buf_unav_irq),\n\tSTMMAC_STAT(rx_process_stopped_irq),\n\tSTMMAC_STAT(rx_watchdog_irq),\n\tSTMMAC_STAT(tx_early_irq),\n\tSTMMAC_STAT(fatal_bus_error_irq),\n\t \n\tSTMMAC_STAT(rx_early_irq),\n\tSTMMAC_STAT(threshold),\n\tSTMMAC_STAT(irq_receive_pmt_irq_n),\n\t \n\tSTMMAC_STAT(mmc_tx_irq_n),\n\tSTMMAC_STAT(mmc_rx_irq_n),\n\tSTMMAC_STAT(mmc_rx_csum_offload_irq_n),\n\t \n\tSTMMAC_STAT(irq_tx_path_in_lpi_mode_n),\n\tSTMMAC_STAT(irq_tx_path_exit_lpi_mode_n),\n\tSTMMAC_STAT(irq_rx_path_in_lpi_mode_n),\n\tSTMMAC_STAT(irq_rx_path_exit_lpi_mode_n),\n\tSTMMAC_STAT(phy_eee_wakeup_error_n),\n\t \n\tSTMMAC_STAT(ip_hdr_err),\n\tSTMMAC_STAT(ip_payload_err),\n\tSTMMAC_STAT(ip_csum_bypassed),\n\tSTMMAC_STAT(ipv4_pkt_rcvd),\n\tSTMMAC_STAT(ipv6_pkt_rcvd),\n\tSTMMAC_STAT(no_ptp_rx_msg_type_ext),\n\tSTMMAC_STAT(ptp_rx_msg_type_sync),\n\tSTMMAC_STAT(ptp_rx_msg_type_follow_up),\n\tSTMMAC_STAT(ptp_rx_msg_type_delay_req),\n\tSTMMAC_STAT(ptp_rx_msg_type_delay_resp),\n\tSTMMAC_STAT(ptp_rx_msg_type_pdelay_req),\n\tSTMMAC_STAT(ptp_rx_msg_type_pdelay_resp),\n\tSTMMAC_STAT(ptp_rx_msg_type_pdelay_follow_up),\n\tSTMMAC_STAT(ptp_rx_msg_type_announce),\n\tSTMMAC_STAT(ptp_rx_msg_type_management),\n\tSTMMAC_STAT(ptp_rx_msg_pkt_reserved_type),\n\tSTMMAC_STAT(ptp_frame_type),\n\tSTMMAC_STAT(ptp_ver),\n\tSTMMAC_STAT(timestamp_dropped),\n\tSTMMAC_STAT(av_pkt_rcvd),\n\tSTMMAC_STAT(av_tagged_pkt_rcvd),\n\tSTMMAC_STAT(vlan_tag_priority_val),\n\tSTMMAC_STAT(l3_filter_match),\n\tSTMMAC_STAT(l4_filter_match),\n\tSTMMAC_STAT(l3_l4_filter_no_match),\n\t \n\tSTMMAC_STAT(irq_pcs_ane_n),\n\tSTMMAC_STAT(irq_pcs_link_n),\n\tSTMMAC_STAT(irq_rgmii_n),\n\t \n\tSTMMAC_STAT(mtl_tx_status_fifo_full),\n\tSTMMAC_STAT(mtl_tx_fifo_not_empty),\n\tSTMMAC_STAT(mmtl_fifo_ctrl),\n\tSTMMAC_STAT(mtl_tx_fifo_read_ctrl_write),\n\tSTMMAC_STAT(mtl_tx_fifo_read_ctrl_wait),\n\tSTMMAC_STAT(mtl_tx_fifo_read_ctrl_read),\n\tSTMMAC_STAT(mtl_tx_fifo_read_ctrl_idle),\n\tSTMMAC_STAT(mac_tx_in_pause),\n\tSTMMAC_STAT(mac_tx_frame_ctrl_xfer),\n\tSTMMAC_STAT(mac_tx_frame_ctrl_idle),\n\tSTMMAC_STAT(mac_tx_frame_ctrl_wait),\n\tSTMMAC_STAT(mac_tx_frame_ctrl_pause),\n\tSTMMAC_STAT(mac_gmii_tx_proto_engine),\n\tSTMMAC_STAT(mtl_rx_fifo_fill_level_full),\n\tSTMMAC_STAT(mtl_rx_fifo_fill_above_thresh),\n\tSTMMAC_STAT(mtl_rx_fifo_fill_below_thresh),\n\tSTMMAC_STAT(mtl_rx_fifo_fill_level_empty),\n\tSTMMAC_STAT(mtl_rx_fifo_read_ctrl_flush),\n\tSTMMAC_STAT(mtl_rx_fifo_read_ctrl_read_data),\n\tSTMMAC_STAT(mtl_rx_fifo_read_ctrl_status),\n\tSTMMAC_STAT(mtl_rx_fifo_read_ctrl_idle),\n\tSTMMAC_STAT(mtl_rx_fifo_ctrl_active),\n\tSTMMAC_STAT(mac_rx_frame_ctrl_fifo),\n\tSTMMAC_STAT(mac_gmii_rx_proto_engine),\n\t \n\tSTMMAC_STAT(mtl_est_cgce),\n\tSTMMAC_STAT(mtl_est_hlbs),\n\tSTMMAC_STAT(mtl_est_hlbf),\n\tSTMMAC_STAT(mtl_est_btre),\n\tSTMMAC_STAT(mtl_est_btrlm),\n};\n#define STMMAC_STATS_LEN ARRAY_SIZE(stmmac_gstrings_stats)\n\n \nstatic const char stmmac_qstats_string[][ETH_GSTRING_LEN] = {\n\t\"rx_pkt_n\",\n\t\"rx_normal_irq_n\",\n\t\"tx_pkt_n\",\n\t\"tx_normal_irq_n\",\n\t\"tx_clean\",\n\t\"tx_set_ic_bit\",\n\t\"tx_tso_frames\",\n\t\"tx_tso_nfrags\",\n\t\"normal_irq_n\",\n\t\"napi_poll\",\n};\n#define STMMAC_QSTATS ARRAY_SIZE(stmmac_qstats_string)\n\n \n#define STMMAC_MMC_STAT(m)\t\\\n\t{ #m, sizeof_field(struct stmmac_counters, m),\t\\\n\toffsetof(struct stmmac_priv, mmc.m)}\n\nstatic const struct stmmac_stats stmmac_mmc[] = {\n\tSTMMAC_MMC_STAT(mmc_tx_octetcount_gb),\n\tSTMMAC_MMC_STAT(mmc_tx_framecount_gb),\n\tSTMMAC_MMC_STAT(mmc_tx_broadcastframe_g),\n\tSTMMAC_MMC_STAT(mmc_tx_multicastframe_g),\n\tSTMMAC_MMC_STAT(mmc_tx_64_octets_gb),\n\tSTMMAC_MMC_STAT(mmc_tx_65_to_127_octets_gb),\n\tSTMMAC_MMC_STAT(mmc_tx_128_to_255_octets_gb),\n\tSTMMAC_MMC_STAT(mmc_tx_256_to_511_octets_gb),\n\tSTMMAC_MMC_STAT(mmc_tx_512_to_1023_octets_gb),\n\tSTMMAC_MMC_STAT(mmc_tx_1024_to_max_octets_gb),\n\tSTMMAC_MMC_STAT(mmc_tx_unicast_gb),\n\tSTMMAC_MMC_STAT(mmc_tx_multicast_gb),\n\tSTMMAC_MMC_STAT(mmc_tx_broadcast_gb),\n\tSTMMAC_MMC_STAT(mmc_tx_underflow_error),\n\tSTMMAC_MMC_STAT(mmc_tx_singlecol_g),\n\tSTMMAC_MMC_STAT(mmc_tx_multicol_g),\n\tSTMMAC_MMC_STAT(mmc_tx_deferred),\n\tSTMMAC_MMC_STAT(mmc_tx_latecol),\n\tSTMMAC_MMC_STAT(mmc_tx_exesscol),\n\tSTMMAC_MMC_STAT(mmc_tx_carrier_error),\n\tSTMMAC_MMC_STAT(mmc_tx_octetcount_g),\n\tSTMMAC_MMC_STAT(mmc_tx_framecount_g),\n\tSTMMAC_MMC_STAT(mmc_tx_excessdef),\n\tSTMMAC_MMC_STAT(mmc_tx_pause_frame),\n\tSTMMAC_MMC_STAT(mmc_tx_vlan_frame_g),\n\tSTMMAC_MMC_STAT(mmc_rx_framecount_gb),\n\tSTMMAC_MMC_STAT(mmc_rx_octetcount_gb),\n\tSTMMAC_MMC_STAT(mmc_rx_octetcount_g),\n\tSTMMAC_MMC_STAT(mmc_rx_broadcastframe_g),\n\tSTMMAC_MMC_STAT(mmc_rx_multicastframe_g),\n\tSTMMAC_MMC_STAT(mmc_rx_crc_error),\n\tSTMMAC_MMC_STAT(mmc_rx_align_error),\n\tSTMMAC_MMC_STAT(mmc_rx_run_error),\n\tSTMMAC_MMC_STAT(mmc_rx_jabber_error),\n\tSTMMAC_MMC_STAT(mmc_rx_undersize_g),\n\tSTMMAC_MMC_STAT(mmc_rx_oversize_g),\n\tSTMMAC_MMC_STAT(mmc_rx_64_octets_gb),\n\tSTMMAC_MMC_STAT(mmc_rx_65_to_127_octets_gb),\n\tSTMMAC_MMC_STAT(mmc_rx_128_to_255_octets_gb),\n\tSTMMAC_MMC_STAT(mmc_rx_256_to_511_octets_gb),\n\tSTMMAC_MMC_STAT(mmc_rx_512_to_1023_octets_gb),\n\tSTMMAC_MMC_STAT(mmc_rx_1024_to_max_octets_gb),\n\tSTMMAC_MMC_STAT(mmc_rx_unicast_g),\n\tSTMMAC_MMC_STAT(mmc_rx_length_error),\n\tSTMMAC_MMC_STAT(mmc_rx_autofrangetype),\n\tSTMMAC_MMC_STAT(mmc_rx_pause_frames),\n\tSTMMAC_MMC_STAT(mmc_rx_fifo_overflow),\n\tSTMMAC_MMC_STAT(mmc_rx_vlan_frames_gb),\n\tSTMMAC_MMC_STAT(mmc_rx_watchdog_error),\n\tSTMMAC_MMC_STAT(mmc_rx_ipc_intr_mask),\n\tSTMMAC_MMC_STAT(mmc_rx_ipc_intr),\n\tSTMMAC_MMC_STAT(mmc_rx_ipv4_gd),\n\tSTMMAC_MMC_STAT(mmc_rx_ipv4_hderr),\n\tSTMMAC_MMC_STAT(mmc_rx_ipv4_nopay),\n\tSTMMAC_MMC_STAT(mmc_rx_ipv4_frag),\n\tSTMMAC_MMC_STAT(mmc_rx_ipv4_udsbl),\n\tSTMMAC_MMC_STAT(mmc_rx_ipv4_gd_octets),\n\tSTMMAC_MMC_STAT(mmc_rx_ipv4_hderr_octets),\n\tSTMMAC_MMC_STAT(mmc_rx_ipv4_nopay_octets),\n\tSTMMAC_MMC_STAT(mmc_rx_ipv4_frag_octets),\n\tSTMMAC_MMC_STAT(mmc_rx_ipv4_udsbl_octets),\n\tSTMMAC_MMC_STAT(mmc_rx_ipv6_gd_octets),\n\tSTMMAC_MMC_STAT(mmc_rx_ipv6_hderr_octets),\n\tSTMMAC_MMC_STAT(mmc_rx_ipv6_nopay_octets),\n\tSTMMAC_MMC_STAT(mmc_rx_ipv6_gd),\n\tSTMMAC_MMC_STAT(mmc_rx_ipv6_hderr),\n\tSTMMAC_MMC_STAT(mmc_rx_ipv6_nopay),\n\tSTMMAC_MMC_STAT(mmc_rx_udp_gd),\n\tSTMMAC_MMC_STAT(mmc_rx_udp_err),\n\tSTMMAC_MMC_STAT(mmc_rx_tcp_gd),\n\tSTMMAC_MMC_STAT(mmc_rx_tcp_err),\n\tSTMMAC_MMC_STAT(mmc_rx_icmp_gd),\n\tSTMMAC_MMC_STAT(mmc_rx_icmp_err),\n\tSTMMAC_MMC_STAT(mmc_rx_udp_gd_octets),\n\tSTMMAC_MMC_STAT(mmc_rx_udp_err_octets),\n\tSTMMAC_MMC_STAT(mmc_rx_tcp_gd_octets),\n\tSTMMAC_MMC_STAT(mmc_rx_tcp_err_octets),\n\tSTMMAC_MMC_STAT(mmc_rx_icmp_gd_octets),\n\tSTMMAC_MMC_STAT(mmc_rx_icmp_err_octets),\n\tSTMMAC_MMC_STAT(mmc_tx_fpe_fragment_cntr),\n\tSTMMAC_MMC_STAT(mmc_tx_hold_req_cntr),\n\tSTMMAC_MMC_STAT(mmc_rx_packet_assembly_err_cntr),\n\tSTMMAC_MMC_STAT(mmc_rx_packet_smd_err_cntr),\n\tSTMMAC_MMC_STAT(mmc_rx_packet_assembly_ok_cntr),\n\tSTMMAC_MMC_STAT(mmc_rx_fpe_fragment_cntr),\n};\n#define STMMAC_MMC_STATS_LEN ARRAY_SIZE(stmmac_mmc)\n\nstatic const char stmmac_qstats_tx_string[][ETH_GSTRING_LEN] = {\n\t\"tx_pkt_n\",\n\t\"tx_irq_n\",\n#define STMMAC_TXQ_STATS ARRAY_SIZE(stmmac_qstats_tx_string)\n};\n\nstatic const char stmmac_qstats_rx_string[][ETH_GSTRING_LEN] = {\n\t\"rx_pkt_n\",\n\t\"rx_irq_n\",\n#define STMMAC_RXQ_STATS ARRAY_SIZE(stmmac_qstats_rx_string)\n};\n\nstatic void stmmac_ethtool_getdrvinfo(struct net_device *dev,\n\t\t\t\t      struct ethtool_drvinfo *info)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\n\tif (priv->plat->has_gmac || priv->plat->has_gmac4)\n\t\tstrscpy(info->driver, GMAC_ETHTOOL_NAME, sizeof(info->driver));\n\telse if (priv->plat->has_xgmac)\n\t\tstrscpy(info->driver, XGMAC_ETHTOOL_NAME, sizeof(info->driver));\n\telse\n\t\tstrscpy(info->driver, MAC100_ETHTOOL_NAME,\n\t\t\tsizeof(info->driver));\n\n\tif (priv->plat->pdev) {\n\t\tstrscpy(info->bus_info, pci_name(priv->plat->pdev),\n\t\t\tsizeof(info->bus_info));\n\t}\n}\n\nstatic int stmmac_ethtool_get_link_ksettings(struct net_device *dev,\n\t\t\t\t\t     struct ethtool_link_ksettings *cmd)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\n\tif (!(priv->plat->flags & STMMAC_FLAG_HAS_INTEGRATED_PCS) &&\n\t    (priv->hw->pcs & STMMAC_PCS_RGMII ||\n\t     priv->hw->pcs & STMMAC_PCS_SGMII)) {\n\t\tstruct rgmii_adv adv;\n\t\tu32 supported, advertising, lp_advertising;\n\n\t\tif (!priv->xstats.pcs_link) {\n\t\t\tcmd->base.speed = SPEED_UNKNOWN;\n\t\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t\t\treturn 0;\n\t\t}\n\t\tcmd->base.duplex = priv->xstats.pcs_duplex;\n\n\t\tcmd->base.speed = priv->xstats.pcs_speed;\n\n\t\t \n\t\tif (stmmac_pcs_get_adv_lp(priv, priv->ioaddr, &adv))\n\t\t\treturn -EOPNOTSUPP;\t \n\n\t\t \n\n\t\tethtool_convert_link_mode_to_legacy_u32(\n\t\t\t&supported, cmd->link_modes.supported);\n\t\tethtool_convert_link_mode_to_legacy_u32(\n\t\t\t&advertising, cmd->link_modes.advertising);\n\t\tethtool_convert_link_mode_to_legacy_u32(\n\t\t\t&lp_advertising, cmd->link_modes.lp_advertising);\n\n\t\tif (adv.pause & STMMAC_PCS_PAUSE)\n\t\t\tadvertising |= ADVERTISED_Pause;\n\t\tif (adv.pause & STMMAC_PCS_ASYM_PAUSE)\n\t\t\tadvertising |= ADVERTISED_Asym_Pause;\n\t\tif (adv.lp_pause & STMMAC_PCS_PAUSE)\n\t\t\tlp_advertising |= ADVERTISED_Pause;\n\t\tif (adv.lp_pause & STMMAC_PCS_ASYM_PAUSE)\n\t\t\tlp_advertising |= ADVERTISED_Asym_Pause;\n\n\t\t \n\t\tcmd->base.autoneg = ADVERTISED_Autoneg;\n\t\tsupported |= SUPPORTED_Autoneg;\n\t\tadvertising |= ADVERTISED_Autoneg;\n\t\tlp_advertising |= ADVERTISED_Autoneg;\n\n\t\tif (adv.duplex) {\n\t\t\tsupported |= (SUPPORTED_1000baseT_Full |\n\t\t\t\t      SUPPORTED_100baseT_Full |\n\t\t\t\t      SUPPORTED_10baseT_Full);\n\t\t\tadvertising |= (ADVERTISED_1000baseT_Full |\n\t\t\t\t\tADVERTISED_100baseT_Full |\n\t\t\t\t\tADVERTISED_10baseT_Full);\n\t\t} else {\n\t\t\tsupported |= (SUPPORTED_1000baseT_Half |\n\t\t\t\t      SUPPORTED_100baseT_Half |\n\t\t\t\t      SUPPORTED_10baseT_Half);\n\t\t\tadvertising |= (ADVERTISED_1000baseT_Half |\n\t\t\t\t\tADVERTISED_100baseT_Half |\n\t\t\t\t\tADVERTISED_10baseT_Half);\n\t\t}\n\t\tif (adv.lp_duplex)\n\t\t\tlp_advertising |= (ADVERTISED_1000baseT_Full |\n\t\t\t\t\t   ADVERTISED_100baseT_Full |\n\t\t\t\t\t   ADVERTISED_10baseT_Full);\n\t\telse\n\t\t\tlp_advertising |= (ADVERTISED_1000baseT_Half |\n\t\t\t\t\t   ADVERTISED_100baseT_Half |\n\t\t\t\t\t   ADVERTISED_10baseT_Half);\n\t\tcmd->base.port = PORT_OTHER;\n\n\t\tethtool_convert_legacy_u32_to_link_mode(\n\t\t\tcmd->link_modes.supported, supported);\n\t\tethtool_convert_legacy_u32_to_link_mode(\n\t\t\tcmd->link_modes.advertising, advertising);\n\t\tethtool_convert_legacy_u32_to_link_mode(\n\t\t\tcmd->link_modes.lp_advertising, lp_advertising);\n\n\t\treturn 0;\n\t}\n\n\treturn phylink_ethtool_ksettings_get(priv->phylink, cmd);\n}\n\nstatic int\nstmmac_ethtool_set_link_ksettings(struct net_device *dev,\n\t\t\t\t  const struct ethtool_link_ksettings *cmd)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\n\tif (!(priv->plat->flags & STMMAC_FLAG_HAS_INTEGRATED_PCS) &&\n\t    (priv->hw->pcs & STMMAC_PCS_RGMII ||\n\t     priv->hw->pcs & STMMAC_PCS_SGMII)) {\n\t\t \n\t\tif (cmd->base.autoneg != AUTONEG_ENABLE)\n\t\t\treturn -EINVAL;\n\n\t\tmutex_lock(&priv->lock);\n\t\tstmmac_pcs_ctrl_ane(priv, priv->ioaddr, 1, priv->hw->ps, 0);\n\t\tmutex_unlock(&priv->lock);\n\n\t\treturn 0;\n\t}\n\n\treturn phylink_ethtool_ksettings_set(priv->phylink, cmd);\n}\n\nstatic u32 stmmac_ethtool_getmsglevel(struct net_device *dev)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\treturn priv->msg_enable;\n}\n\nstatic void stmmac_ethtool_setmsglevel(struct net_device *dev, u32 level)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\tpriv->msg_enable = level;\n\n}\n\nstatic int stmmac_check_if_running(struct net_device *dev)\n{\n\tif (!netif_running(dev))\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\nstatic int stmmac_ethtool_get_regs_len(struct net_device *dev)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\n\tif (priv->plat->has_xgmac)\n\t\treturn XGMAC_REGSIZE * 4;\n\telse if (priv->plat->has_gmac4)\n\t\treturn GMAC4_REG_SPACE_SIZE;\n\treturn REG_SPACE_SIZE;\n}\n\nstatic void stmmac_ethtool_gregs(struct net_device *dev,\n\t\t\t  struct ethtool_regs *regs, void *space)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\tu32 *reg_space = (u32 *) space;\n\n\tstmmac_dump_mac_regs(priv, priv->hw, reg_space);\n\tstmmac_dump_dma_regs(priv, priv->ioaddr, reg_space);\n\n\t \n\tif (priv->plat->has_gmac4) {\n\t\t \n\t\tmemcpy(&reg_space[ETHTOOL_DMA_OFFSET],\n\t\t       &reg_space[GMAC4_DMA_CHAN_BASE_ADDR / 4],\n\t\t       NUM_DWMAC4_DMA_REGS * 4);\n\t} else if (!priv->plat->has_xgmac) {\n\t\tmemcpy(&reg_space[ETHTOOL_DMA_OFFSET],\n\t\t       &reg_space[DMA_BUS_MODE / 4],\n\t\t       NUM_DWMAC1000_DMA_REGS * 4);\n\t}\n}\n\nstatic int stmmac_nway_reset(struct net_device *dev)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\n\treturn phylink_ethtool_nway_reset(priv->phylink);\n}\n\nstatic void stmmac_get_ringparam(struct net_device *netdev,\n\t\t\t\t struct ethtool_ringparam *ring,\n\t\t\t\t struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct stmmac_priv *priv = netdev_priv(netdev);\n\n\tring->rx_max_pending = DMA_MAX_RX_SIZE;\n\tring->tx_max_pending = DMA_MAX_TX_SIZE;\n\tring->rx_pending = priv->dma_conf.dma_rx_size;\n\tring->tx_pending = priv->dma_conf.dma_tx_size;\n}\n\nstatic int stmmac_set_ringparam(struct net_device *netdev,\n\t\t\t\tstruct ethtool_ringparam *ring,\n\t\t\t\tstruct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tif (ring->rx_mini_pending || ring->rx_jumbo_pending ||\n\t    ring->rx_pending < DMA_MIN_RX_SIZE ||\n\t    ring->rx_pending > DMA_MAX_RX_SIZE ||\n\t    !is_power_of_2(ring->rx_pending) ||\n\t    ring->tx_pending < DMA_MIN_TX_SIZE ||\n\t    ring->tx_pending > DMA_MAX_TX_SIZE ||\n\t    !is_power_of_2(ring->tx_pending))\n\t\treturn -EINVAL;\n\n\treturn stmmac_reinit_ringparam(netdev, ring->rx_pending,\n\t\t\t\t       ring->tx_pending);\n}\n\nstatic void\nstmmac_get_pauseparam(struct net_device *netdev,\n\t\t      struct ethtool_pauseparam *pause)\n{\n\tstruct stmmac_priv *priv = netdev_priv(netdev);\n\tstruct rgmii_adv adv_lp;\n\n\tif (priv->hw->pcs && !stmmac_pcs_get_adv_lp(priv, priv->ioaddr, &adv_lp)) {\n\t\tpause->autoneg = 1;\n\t\tif (!adv_lp.pause)\n\t\t\treturn;\n\t} else {\n\t\tphylink_ethtool_get_pauseparam(priv->phylink, pause);\n\t}\n}\n\nstatic int\nstmmac_set_pauseparam(struct net_device *netdev,\n\t\t      struct ethtool_pauseparam *pause)\n{\n\tstruct stmmac_priv *priv = netdev_priv(netdev);\n\tstruct rgmii_adv adv_lp;\n\n\tif (priv->hw->pcs && !stmmac_pcs_get_adv_lp(priv, priv->ioaddr, &adv_lp)) {\n\t\tpause->autoneg = 1;\n\t\tif (!adv_lp.pause)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn 0;\n\t} else {\n\t\treturn phylink_ethtool_set_pauseparam(priv->phylink, pause);\n\t}\n}\n\nstatic void stmmac_get_per_qstats(struct stmmac_priv *priv, u64 *data)\n{\n\tu32 tx_cnt = priv->plat->tx_queues_to_use;\n\tu32 rx_cnt = priv->plat->rx_queues_to_use;\n\tunsigned int start;\n\tint q, stat;\n\tchar *p;\n\n\tfor (q = 0; q < tx_cnt; q++) {\n\t\tstruct stmmac_txq_stats *txq_stats = &priv->xstats.txq_stats[q];\n\t\tstruct stmmac_txq_stats snapshot;\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&txq_stats->syncp);\n\t\t\tsnapshot = *txq_stats;\n\t\t} while (u64_stats_fetch_retry(&txq_stats->syncp, start));\n\n\t\tp = (char *)&snapshot + offsetof(struct stmmac_txq_stats, tx_pkt_n);\n\t\tfor (stat = 0; stat < STMMAC_TXQ_STATS; stat++) {\n\t\t\t*data++ = (*(u64 *)p);\n\t\t\tp += sizeof(u64);\n\t\t}\n\t}\n\n\tfor (q = 0; q < rx_cnt; q++) {\n\t\tstruct stmmac_rxq_stats *rxq_stats = &priv->xstats.rxq_stats[q];\n\t\tstruct stmmac_rxq_stats snapshot;\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&rxq_stats->syncp);\n\t\t\tsnapshot = *rxq_stats;\n\t\t} while (u64_stats_fetch_retry(&rxq_stats->syncp, start));\n\n\t\tp = (char *)&snapshot + offsetof(struct stmmac_rxq_stats, rx_pkt_n);\n\t\tfor (stat = 0; stat < STMMAC_RXQ_STATS; stat++) {\n\t\t\t*data++ = (*(u64 *)p);\n\t\t\tp += sizeof(u64);\n\t\t}\n\t}\n}\n\nstatic void stmmac_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t struct ethtool_stats *dummy, u64 *data)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\tu32 rx_queues_count = priv->plat->rx_queues_to_use;\n\tu32 tx_queues_count = priv->plat->tx_queues_to_use;\n\tu64 napi_poll = 0, normal_irq_n = 0;\n\tint i, j = 0, pos, ret;\n\tunsigned long count;\n\tunsigned int start;\n\n\tif (priv->dma_cap.asp) {\n\t\tfor (i = 0; i < STMMAC_SAFETY_FEAT_SIZE; i++) {\n\t\t\tif (!stmmac_safety_feat_dump(priv, &priv->sstats, i,\n\t\t\t\t\t\t&count, NULL))\n\t\t\t\tdata[j++] = count;\n\t\t}\n\t}\n\n\t \n\tret = stmmac_dma_diagnostic_fr(priv, &priv->xstats, priv->ioaddr);\n\tif (ret) {\n\t\t \n\t\tif (priv->dma_cap.rmon) {\n\t\t\tstmmac_mmc_read(priv, priv->mmcaddr, &priv->mmc);\n\n\t\t\tfor (i = 0; i < STMMAC_MMC_STATS_LEN; i++) {\n\t\t\t\tchar *p;\n\t\t\t\tp = (char *)priv + stmmac_mmc[i].stat_offset;\n\n\t\t\t\tdata[j++] = (stmmac_mmc[i].sizeof_stat ==\n\t\t\t\t\t     sizeof(u64)) ? (*(u64 *)p) :\n\t\t\t\t\t     (*(u32 *)p);\n\t\t\t}\n\t\t}\n\t\tif (priv->eee_enabled) {\n\t\t\tint val = phylink_get_eee_err(priv->phylink);\n\t\t\tif (val)\n\t\t\t\tpriv->xstats.phy_eee_wakeup_error_n = val;\n\t\t}\n\n\t\tif (priv->synopsys_id >= DWMAC_CORE_3_50)\n\t\t\tstmmac_mac_debug(priv, priv->ioaddr,\n\t\t\t\t\t(void *)&priv->xstats,\n\t\t\t\t\trx_queues_count, tx_queues_count);\n\t}\n\tfor (i = 0; i < STMMAC_STATS_LEN; i++) {\n\t\tchar *p = (char *)priv + stmmac_gstrings_stats[i].stat_offset;\n\t\tdata[j++] = (stmmac_gstrings_stats[i].sizeof_stat ==\n\t\t\t     sizeof(u64)) ? (*(u64 *)p) : (*(u32 *)p);\n\t}\n\n\tpos = j;\n\tfor (i = 0; i < rx_queues_count; i++) {\n\t\tstruct stmmac_rxq_stats *rxq_stats = &priv->xstats.rxq_stats[i];\n\t\tstruct stmmac_rxq_stats snapshot;\n\n\t\tj = pos;\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&rxq_stats->syncp);\n\t\t\tsnapshot = *rxq_stats;\n\t\t} while (u64_stats_fetch_retry(&rxq_stats->syncp, start));\n\n\t\tdata[j++] += snapshot.rx_pkt_n;\n\t\tdata[j++] += snapshot.rx_normal_irq_n;\n\t\tnormal_irq_n += snapshot.rx_normal_irq_n;\n\t\tnapi_poll += snapshot.napi_poll;\n\t}\n\n\tpos = j;\n\tfor (i = 0; i < tx_queues_count; i++) {\n\t\tstruct stmmac_txq_stats *txq_stats = &priv->xstats.txq_stats[i];\n\t\tstruct stmmac_txq_stats snapshot;\n\n\t\tj = pos;\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&txq_stats->syncp);\n\t\t\tsnapshot = *txq_stats;\n\t\t} while (u64_stats_fetch_retry(&txq_stats->syncp, start));\n\n\t\tdata[j++] += snapshot.tx_pkt_n;\n\t\tdata[j++] += snapshot.tx_normal_irq_n;\n\t\tnormal_irq_n += snapshot.tx_normal_irq_n;\n\t\tdata[j++] += snapshot.tx_clean;\n\t\tdata[j++] += snapshot.tx_set_ic_bit;\n\t\tdata[j++] += snapshot.tx_tso_frames;\n\t\tdata[j++] += snapshot.tx_tso_nfrags;\n\t\tnapi_poll += snapshot.napi_poll;\n\t}\n\tnormal_irq_n += priv->xstats.rx_early_irq;\n\tdata[j++] = normal_irq_n;\n\tdata[j++] = napi_poll;\n\n\tstmmac_get_per_qstats(priv, &data[j]);\n}\n\nstatic int stmmac_get_sset_count(struct net_device *netdev, int sset)\n{\n\tstruct stmmac_priv *priv = netdev_priv(netdev);\n\tu32 tx_cnt = priv->plat->tx_queues_to_use;\n\tu32 rx_cnt = priv->plat->rx_queues_to_use;\n\tint i, len, safety_len = 0;\n\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\tlen = STMMAC_STATS_LEN + STMMAC_QSTATS +\n\t\t      STMMAC_TXQ_STATS * tx_cnt +\n\t\t      STMMAC_RXQ_STATS * rx_cnt;\n\n\t\tif (priv->dma_cap.rmon)\n\t\t\tlen += STMMAC_MMC_STATS_LEN;\n\t\tif (priv->dma_cap.asp) {\n\t\t\tfor (i = 0; i < STMMAC_SAFETY_FEAT_SIZE; i++) {\n\t\t\t\tif (!stmmac_safety_feat_dump(priv,\n\t\t\t\t\t\t\t&priv->sstats, i,\n\t\t\t\t\t\t\tNULL, NULL))\n\t\t\t\t\tsafety_len++;\n\t\t\t}\n\n\t\t\tlen += safety_len;\n\t\t}\n\n\t\treturn len;\n\tcase ETH_SS_TEST:\n\t\treturn stmmac_selftest_get_count(priv);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void stmmac_get_qstats_string(struct stmmac_priv *priv, u8 *data)\n{\n\tu32 tx_cnt = priv->plat->tx_queues_to_use;\n\tu32 rx_cnt = priv->plat->rx_queues_to_use;\n\tint q, stat;\n\n\tfor (q = 0; q < tx_cnt; q++) {\n\t\tfor (stat = 0; stat < STMMAC_TXQ_STATS; stat++) {\n\t\t\tsnprintf(data, ETH_GSTRING_LEN, \"q%d_%s\", q,\n\t\t\t\t stmmac_qstats_tx_string[stat]);\n\t\t\tdata += ETH_GSTRING_LEN;\n\t\t}\n\t}\n\tfor (q = 0; q < rx_cnt; q++) {\n\t\tfor (stat = 0; stat < STMMAC_RXQ_STATS; stat++) {\n\t\t\tsnprintf(data, ETH_GSTRING_LEN, \"q%d_%s\", q,\n\t\t\t\t stmmac_qstats_rx_string[stat]);\n\t\t\tdata += ETH_GSTRING_LEN;\n\t\t}\n\t}\n}\n\nstatic void stmmac_get_strings(struct net_device *dev, u32 stringset, u8 *data)\n{\n\tint i;\n\tu8 *p = data;\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tif (priv->dma_cap.asp) {\n\t\t\tfor (i = 0; i < STMMAC_SAFETY_FEAT_SIZE; i++) {\n\t\t\t\tconst char *desc;\n\t\t\t\tif (!stmmac_safety_feat_dump(priv,\n\t\t\t\t\t\t\t&priv->sstats, i,\n\t\t\t\t\t\t\tNULL, &desc)) {\n\t\t\t\t\tmemcpy(p, desc, ETH_GSTRING_LEN);\n\t\t\t\t\tp += ETH_GSTRING_LEN;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (priv->dma_cap.rmon)\n\t\t\tfor (i = 0; i < STMMAC_MMC_STATS_LEN; i++) {\n\t\t\t\tmemcpy(p, stmmac_mmc[i].stat_string,\n\t\t\t\t       ETH_GSTRING_LEN);\n\t\t\t\tp += ETH_GSTRING_LEN;\n\t\t\t}\n\t\tfor (i = 0; i < STMMAC_STATS_LEN; i++) {\n\t\t\tmemcpy(p, stmmac_gstrings_stats[i].stat_string, ETH_GSTRING_LEN);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\t\tfor (i = 0; i < STMMAC_QSTATS; i++) {\n\t\t\tmemcpy(p, stmmac_qstats_string[i], ETH_GSTRING_LEN);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\t\tstmmac_get_qstats_string(priv, p);\n\t\tbreak;\n\tcase ETH_SS_TEST:\n\t\tstmmac_selftest_get_strings(priv, p);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n}\n\n \nstatic void stmmac_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\n\tif (!priv->plat->pmt)\n\t\treturn phylink_ethtool_get_wol(priv->phylink, wol);\n\n\tmutex_lock(&priv->lock);\n\tif (device_can_wakeup(priv->device)) {\n\t\twol->supported = WAKE_MAGIC | WAKE_UCAST;\n\t\tif (priv->hw_cap_support && !priv->dma_cap.pmt_magic_frame)\n\t\t\twol->supported &= ~WAKE_MAGIC;\n\t\twol->wolopts = priv->wolopts;\n\t}\n\tmutex_unlock(&priv->lock);\n}\n\nstatic int stmmac_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\tu32 support = WAKE_MAGIC | WAKE_UCAST;\n\n\tif (!device_can_wakeup(priv->device))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!priv->plat->pmt) {\n\t\tint ret = phylink_ethtool_set_wol(priv->phylink, wol);\n\n\t\tif (!ret)\n\t\t\tdevice_set_wakeup_enable(priv->device, !!wol->wolopts);\n\t\treturn ret;\n\t}\n\n\t \n\tif ((priv->hw_cap_support) && (!priv->dma_cap.pmt_magic_frame))\n\t\twol->wolopts &= ~WAKE_MAGIC;\n\n\tif (wol->wolopts & ~support)\n\t\treturn -EINVAL;\n\n\tif (wol->wolopts) {\n\t\tpr_info(\"stmmac: wakeup enable\\n\");\n\t\tdevice_set_wakeup_enable(priv->device, 1);\n\t\t \n\t\tif (priv->wol_irq_disabled)\n\t\t\tenable_irq_wake(priv->wol_irq);\n\t\tpriv->wol_irq_disabled = false;\n\t} else {\n\t\tdevice_set_wakeup_enable(priv->device, 0);\n\t\t \n\t\tif (!priv->wol_irq_disabled)\n\t\t\tdisable_irq_wake(priv->wol_irq);\n\t\tpriv->wol_irq_disabled = true;\n\t}\n\n\tmutex_lock(&priv->lock);\n\tpriv->wolopts = wol->wolopts;\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic int stmmac_ethtool_op_get_eee(struct net_device *dev,\n\t\t\t\t     struct ethtool_eee *edata)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\n\tif (!priv->dma_cap.eee)\n\t\treturn -EOPNOTSUPP;\n\n\tedata->eee_enabled = priv->eee_enabled;\n\tedata->eee_active = priv->eee_active;\n\tedata->tx_lpi_timer = priv->tx_lpi_timer;\n\tedata->tx_lpi_enabled = priv->tx_lpi_enabled;\n\n\treturn phylink_ethtool_get_eee(priv->phylink, edata);\n}\n\nstatic int stmmac_ethtool_op_set_eee(struct net_device *dev,\n\t\t\t\t     struct ethtool_eee *edata)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\tint ret;\n\n\tif (!priv->dma_cap.eee)\n\t\treturn -EOPNOTSUPP;\n\n\tif (priv->tx_lpi_enabled != edata->tx_lpi_enabled)\n\t\tnetdev_warn(priv->dev,\n\t\t\t    \"Setting EEE tx-lpi is not supported\\n\");\n\n\tif (!edata->eee_enabled)\n\t\tstmmac_disable_eee_mode(priv);\n\n\tret = phylink_ethtool_set_eee(priv->phylink, edata);\n\tif (ret)\n\t\treturn ret;\n\n\tif (edata->eee_enabled &&\n\t    priv->tx_lpi_timer != edata->tx_lpi_timer) {\n\t\tpriv->tx_lpi_timer = edata->tx_lpi_timer;\n\t\tstmmac_eee_init(priv);\n\t}\n\n\treturn 0;\n}\n\nstatic u32 stmmac_usec2riwt(u32 usec, struct stmmac_priv *priv)\n{\n\tunsigned long clk = clk_get_rate(priv->plat->stmmac_clk);\n\n\tif (!clk) {\n\t\tclk = priv->plat->clk_ref_rate;\n\t\tif (!clk)\n\t\t\treturn 0;\n\t}\n\n\treturn (usec * (clk / 1000000)) / 256;\n}\n\nstatic u32 stmmac_riwt2usec(u32 riwt, struct stmmac_priv *priv)\n{\n\tunsigned long clk = clk_get_rate(priv->plat->stmmac_clk);\n\n\tif (!clk) {\n\t\tclk = priv->plat->clk_ref_rate;\n\t\tif (!clk)\n\t\t\treturn 0;\n\t}\n\n\treturn (riwt * 256) / (clk / 1000000);\n}\n\nstatic int __stmmac_get_coalesce(struct net_device *dev,\n\t\t\t\t struct ethtool_coalesce *ec,\n\t\t\t\t int queue)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\tu32 max_cnt;\n\tu32 rx_cnt;\n\tu32 tx_cnt;\n\n\trx_cnt = priv->plat->rx_queues_to_use;\n\ttx_cnt = priv->plat->tx_queues_to_use;\n\tmax_cnt = max(rx_cnt, tx_cnt);\n\n\tif (queue < 0)\n\t\tqueue = 0;\n\telse if (queue >= max_cnt)\n\t\treturn -EINVAL;\n\n\tif (queue < tx_cnt) {\n\t\tec->tx_coalesce_usecs = priv->tx_coal_timer[queue];\n\t\tec->tx_max_coalesced_frames = priv->tx_coal_frames[queue];\n\t} else {\n\t\tec->tx_coalesce_usecs = 0;\n\t\tec->tx_max_coalesced_frames = 0;\n\t}\n\n\tif (priv->use_riwt && queue < rx_cnt) {\n\t\tec->rx_max_coalesced_frames = priv->rx_coal_frames[queue];\n\t\tec->rx_coalesce_usecs = stmmac_riwt2usec(priv->rx_riwt[queue],\n\t\t\t\t\t\t\t priv);\n\t} else {\n\t\tec->rx_max_coalesced_frames = 0;\n\t\tec->rx_coalesce_usecs = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int stmmac_get_coalesce(struct net_device *dev,\n\t\t\t       struct ethtool_coalesce *ec,\n\t\t\t       struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\treturn __stmmac_get_coalesce(dev, ec, -1);\n}\n\nstatic int stmmac_get_per_queue_coalesce(struct net_device *dev, u32 queue,\n\t\t\t\t\t struct ethtool_coalesce *ec)\n{\n\treturn __stmmac_get_coalesce(dev, ec, queue);\n}\n\nstatic int __stmmac_set_coalesce(struct net_device *dev,\n\t\t\t\t struct ethtool_coalesce *ec,\n\t\t\t\t int queue)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\tbool all_queues = false;\n\tunsigned int rx_riwt;\n\tu32 max_cnt;\n\tu32 rx_cnt;\n\tu32 tx_cnt;\n\n\trx_cnt = priv->plat->rx_queues_to_use;\n\ttx_cnt = priv->plat->tx_queues_to_use;\n\tmax_cnt = max(rx_cnt, tx_cnt);\n\n\tif (queue < 0)\n\t\tall_queues = true;\n\telse if (queue >= max_cnt)\n\t\treturn -EINVAL;\n\n\tif (priv->use_riwt && (ec->rx_coalesce_usecs > 0)) {\n\t\trx_riwt = stmmac_usec2riwt(ec->rx_coalesce_usecs, priv);\n\n\t\tif ((rx_riwt > MAX_DMA_RIWT) || (rx_riwt < MIN_DMA_RIWT))\n\t\t\treturn -EINVAL;\n\n\t\tif (all_queues) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < rx_cnt; i++) {\n\t\t\t\tpriv->rx_riwt[i] = rx_riwt;\n\t\t\t\tstmmac_rx_watchdog(priv, priv->ioaddr,\n\t\t\t\t\t\t   rx_riwt, i);\n\t\t\t\tpriv->rx_coal_frames[i] =\n\t\t\t\t\tec->rx_max_coalesced_frames;\n\t\t\t}\n\t\t} else if (queue < rx_cnt) {\n\t\t\tpriv->rx_riwt[queue] = rx_riwt;\n\t\t\tstmmac_rx_watchdog(priv, priv->ioaddr,\n\t\t\t\t\t   rx_riwt, queue);\n\t\t\tpriv->rx_coal_frames[queue] =\n\t\t\t\tec->rx_max_coalesced_frames;\n\t\t}\n\t}\n\n\tif ((ec->tx_coalesce_usecs == 0) &&\n\t    (ec->tx_max_coalesced_frames == 0))\n\t\treturn -EINVAL;\n\n\tif ((ec->tx_coalesce_usecs > STMMAC_MAX_COAL_TX_TICK) ||\n\t    (ec->tx_max_coalesced_frames > STMMAC_TX_MAX_FRAMES))\n\t\treturn -EINVAL;\n\n\tif (all_queues) {\n\t\tint i;\n\n\t\tfor (i = 0; i < tx_cnt; i++) {\n\t\t\tpriv->tx_coal_frames[i] =\n\t\t\t\tec->tx_max_coalesced_frames;\n\t\t\tpriv->tx_coal_timer[i] =\n\t\t\t\tec->tx_coalesce_usecs;\n\t\t}\n\t} else if (queue < tx_cnt) {\n\t\tpriv->tx_coal_frames[queue] =\n\t\t\tec->tx_max_coalesced_frames;\n\t\tpriv->tx_coal_timer[queue] =\n\t\t\tec->tx_coalesce_usecs;\n\t}\n\n\treturn 0;\n}\n\nstatic int stmmac_set_coalesce(struct net_device *dev,\n\t\t\t       struct ethtool_coalesce *ec,\n\t\t\t       struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\treturn __stmmac_set_coalesce(dev, ec, -1);\n}\n\nstatic int stmmac_set_per_queue_coalesce(struct net_device *dev, u32 queue,\n\t\t\t\t\t struct ethtool_coalesce *ec)\n{\n\treturn __stmmac_set_coalesce(dev, ec, queue);\n}\n\nstatic int stmmac_get_rxnfc(struct net_device *dev,\n\t\t\t    struct ethtool_rxnfc *rxnfc, u32 *rule_locs)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\n\tswitch (rxnfc->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\trxnfc->data = priv->plat->rx_queues_to_use;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 stmmac_get_rxfh_key_size(struct net_device *dev)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\n\treturn sizeof(priv->rss.key);\n}\n\nstatic u32 stmmac_get_rxfh_indir_size(struct net_device *dev)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\n\treturn ARRAY_SIZE(priv->rss.table);\n}\n\nstatic int stmmac_get_rxfh(struct net_device *dev, u32 *indir, u8 *key,\n\t\t\t   u8 *hfunc)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\tint i;\n\n\tif (indir) {\n\t\tfor (i = 0; i < ARRAY_SIZE(priv->rss.table); i++)\n\t\t\tindir[i] = priv->rss.table[i];\n\t}\n\n\tif (key)\n\t\tmemcpy(key, priv->rss.key, sizeof(priv->rss.key));\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;\n\n\treturn 0;\n}\n\nstatic int stmmac_set_rxfh(struct net_device *dev, const u32 *indir,\n\t\t\t   const u8 *key, const u8 hfunc)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\tint i;\n\n\tif ((hfunc != ETH_RSS_HASH_NO_CHANGE) && (hfunc != ETH_RSS_HASH_TOP))\n\t\treturn -EOPNOTSUPP;\n\n\tif (indir) {\n\t\tfor (i = 0; i < ARRAY_SIZE(priv->rss.table); i++)\n\t\t\tpriv->rss.table[i] = indir[i];\n\t}\n\n\tif (key)\n\t\tmemcpy(priv->rss.key, key, sizeof(priv->rss.key));\n\n\treturn stmmac_rss_configure(priv, priv->hw, &priv->rss,\n\t\t\t\t    priv->plat->rx_queues_to_use);\n}\n\nstatic void stmmac_get_channels(struct net_device *dev,\n\t\t\t\tstruct ethtool_channels *chan)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\n\tchan->rx_count = priv->plat->rx_queues_to_use;\n\tchan->tx_count = priv->plat->tx_queues_to_use;\n\tchan->max_rx = priv->dma_cap.number_rx_queues;\n\tchan->max_tx = priv->dma_cap.number_tx_queues;\n}\n\nstatic int stmmac_set_channels(struct net_device *dev,\n\t\t\t       struct ethtool_channels *chan)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\n\tif (chan->rx_count > priv->dma_cap.number_rx_queues ||\n\t    chan->tx_count > priv->dma_cap.number_tx_queues ||\n\t    !chan->rx_count || !chan->tx_count)\n\t\treturn -EINVAL;\n\n\treturn stmmac_reinit_queues(dev, chan->rx_count, chan->tx_count);\n}\n\nstatic int stmmac_get_ts_info(struct net_device *dev,\n\t\t\t      struct ethtool_ts_info *info)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\n\tif ((priv->dma_cap.time_stamp || priv->dma_cap.atime_stamp)) {\n\n\t\tinfo->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\t\tSOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\t\tSOF_TIMESTAMPING_SOFTWARE |\n\t\t\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\n\t\tif (priv->ptp_clock)\n\t\t\tinfo->phc_index = ptp_clock_index(priv->ptp_clock);\n\n\t\tinfo->tx_types = (1 << HWTSTAMP_TX_OFF) | (1 << HWTSTAMP_TX_ON);\n\n\t\tinfo->rx_filters = ((1 << HWTSTAMP_FILTER_NONE) |\n\t\t\t\t    (1 << HWTSTAMP_FILTER_PTP_V1_L4_EVENT) |\n\t\t\t\t    (1 << HWTSTAMP_FILTER_PTP_V1_L4_SYNC) |\n\t\t\t\t    (1 << HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ) |\n\t\t\t\t    (1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |\n\t\t\t\t    (1 << HWTSTAMP_FILTER_PTP_V2_L4_SYNC) |\n\t\t\t\t    (1 << HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ) |\n\t\t\t\t    (1 << HWTSTAMP_FILTER_PTP_V2_EVENT) |\n\t\t\t\t    (1 << HWTSTAMP_FILTER_PTP_V2_SYNC) |\n\t\t\t\t    (1 << HWTSTAMP_FILTER_PTP_V2_DELAY_REQ) |\n\t\t\t\t    (1 << HWTSTAMP_FILTER_ALL));\n\t\treturn 0;\n\t} else\n\t\treturn ethtool_op_get_ts_info(dev, info);\n}\n\nstatic int stmmac_get_tunable(struct net_device *dev,\n\t\t\t      const struct ethtool_tunable *tuna, void *data)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\tint ret = 0;\n\n\tswitch (tuna->id) {\n\tcase ETHTOOL_RX_COPYBREAK:\n\t\t*(u32 *)data = priv->rx_copybreak;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int stmmac_set_tunable(struct net_device *dev,\n\t\t\t      const struct ethtool_tunable *tuna,\n\t\t\t      const void *data)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\tint ret = 0;\n\n\tswitch (tuna->id) {\n\tcase ETHTOOL_RX_COPYBREAK:\n\t\tpriv->rx_copybreak = *(u32 *)data;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct ethtool_ops stmmac_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES,\n\t.begin = stmmac_check_if_running,\n\t.get_drvinfo = stmmac_ethtool_getdrvinfo,\n\t.get_msglevel = stmmac_ethtool_getmsglevel,\n\t.set_msglevel = stmmac_ethtool_setmsglevel,\n\t.get_regs = stmmac_ethtool_gregs,\n\t.get_regs_len = stmmac_ethtool_get_regs_len,\n\t.get_link = ethtool_op_get_link,\n\t.nway_reset = stmmac_nway_reset,\n\t.get_ringparam = stmmac_get_ringparam,\n\t.set_ringparam = stmmac_set_ringparam,\n\t.get_pauseparam = stmmac_get_pauseparam,\n\t.set_pauseparam = stmmac_set_pauseparam,\n\t.self_test = stmmac_selftest_run,\n\t.get_ethtool_stats = stmmac_get_ethtool_stats,\n\t.get_strings = stmmac_get_strings,\n\t.get_wol = stmmac_get_wol,\n\t.set_wol = stmmac_set_wol,\n\t.get_eee = stmmac_ethtool_op_get_eee,\n\t.set_eee = stmmac_ethtool_op_set_eee,\n\t.get_sset_count\t= stmmac_get_sset_count,\n\t.get_rxnfc = stmmac_get_rxnfc,\n\t.get_rxfh_key_size = stmmac_get_rxfh_key_size,\n\t.get_rxfh_indir_size = stmmac_get_rxfh_indir_size,\n\t.get_rxfh = stmmac_get_rxfh,\n\t.set_rxfh = stmmac_set_rxfh,\n\t.get_ts_info = stmmac_get_ts_info,\n\t.get_coalesce = stmmac_get_coalesce,\n\t.set_coalesce = stmmac_set_coalesce,\n\t.get_per_queue_coalesce = stmmac_get_per_queue_coalesce,\n\t.set_per_queue_coalesce = stmmac_set_per_queue_coalesce,\n\t.get_channels = stmmac_get_channels,\n\t.set_channels = stmmac_set_channels,\n\t.get_tunable = stmmac_get_tunable,\n\t.set_tunable = stmmac_set_tunable,\n\t.get_link_ksettings = stmmac_ethtool_get_link_ksettings,\n\t.set_link_ksettings = stmmac_ethtool_set_link_ksettings,\n};\n\nvoid stmmac_set_ethtool_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &stmmac_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}