{
  "module_name": "dwmac5.c",
  "hash_id": "9bd528483cb1645594a58d0c1553c6ca4be827b644c96df351b261a5784b3fc4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwmac5.c",
  "human_readable_source": "\n\n\n\n#include <linux/bitops.h>\n#include <linux/iopoll.h>\n#include \"common.h\"\n#include \"dwmac4.h\"\n#include \"dwmac5.h\"\n#include \"stmmac.h\"\n#include \"stmmac_ptp.h\"\n\nstruct dwmac5_error_desc {\n\tbool valid;\n\tconst char *desc;\n\tconst char *detailed_desc;\n};\n\n#define STAT_OFF(field)\t\toffsetof(struct stmmac_safety_stats, field)\n\nstatic void dwmac5_log_error(struct net_device *ndev, u32 value, bool corr,\n\t\tconst char *module_name, const struct dwmac5_error_desc *desc,\n\t\tunsigned long field_offset, struct stmmac_safety_stats *stats)\n{\n\tunsigned long loc, mask;\n\tu8 *bptr = (u8 *)stats;\n\tunsigned long *ptr;\n\n\tptr = (unsigned long *)(bptr + field_offset);\n\n\tmask = value;\n\tfor_each_set_bit(loc, &mask, 32) {\n\t\tnetdev_err(ndev, \"Found %s error in %s: '%s: %s'\\n\", corr ?\n\t\t\t\t\"correctable\" : \"uncorrectable\", module_name,\n\t\t\t\tdesc[loc].desc, desc[loc].detailed_desc);\n\n\t\t \n\t\tptr[loc]++;\n\t}\n}\n\nstatic const struct dwmac5_error_desc dwmac5_mac_errors[32]= {\n\t{ true, \"ATPES\", \"Application Transmit Interface Parity Check Error\" },\n\t{ true, \"TPES\", \"TSO Data Path Parity Check Error\" },\n\t{ true, \"RDPES\", \"Read Descriptor Parity Check Error\" },\n\t{ true, \"MPES\", \"MTL Data Path Parity Check Error\" },\n\t{ true, \"MTSPES\", \"MTL TX Status Data Path Parity Check Error\" },\n\t{ true, \"ARPES\", \"Application Receive Interface Data Path Parity Check Error\" },\n\t{ true, \"CWPES\", \"CSR Write Data Path Parity Check Error\" },\n\t{ true, \"ASRPES\", \"AXI Slave Read Data Path Parity Check Error\" },\n\t{ true, \"TTES\", \"TX FSM Timeout Error\" },\n\t{ true, \"RTES\", \"RX FSM Timeout Error\" },\n\t{ true, \"CTES\", \"CSR FSM Timeout Error\" },\n\t{ true, \"ATES\", \"APP FSM Timeout Error\" },\n\t{ true, \"PTES\", \"PTP FSM Timeout Error\" },\n\t{ true, \"T125ES\", \"TX125 FSM Timeout Error\" },\n\t{ true, \"R125ES\", \"RX125 FSM Timeout Error\" },\n\t{ true, \"RVCTES\", \"REV MDC FSM Timeout Error\" },\n\t{ true, \"MSTTES\", \"Master Read/Write Timeout Error\" },\n\t{ true, \"SLVTES\", \"Slave Read/Write Timeout Error\" },\n\t{ true, \"ATITES\", \"Application Timeout on ATI Interface Error\" },\n\t{ true, \"ARITES\", \"Application Timeout on ARI Interface Error\" },\n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ true, \"FSMPES\", \"FSM State Parity Error\" },\n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n};\n\nstatic void dwmac5_handle_mac_err(struct net_device *ndev,\n\t\tvoid __iomem *ioaddr, bool correctable,\n\t\tstruct stmmac_safety_stats *stats)\n{\n\tu32 value;\n\n\tvalue = readl(ioaddr + MAC_DPP_FSM_INT_STATUS);\n\twritel(value, ioaddr + MAC_DPP_FSM_INT_STATUS);\n\n\tdwmac5_log_error(ndev, value, correctable, \"MAC\", dwmac5_mac_errors,\n\t\t\tSTAT_OFF(mac_errors), stats);\n}\n\nstatic const struct dwmac5_error_desc dwmac5_mtl_errors[32]= {\n\t{ true, \"TXCES\", \"MTL TX Memory Error\" },\n\t{ true, \"TXAMS\", \"MTL TX Memory Address Mismatch Error\" },\n\t{ true, \"TXUES\", \"MTL TX Memory Error\" },\n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ true, \"RXCES\", \"MTL RX Memory Error\" },\n\t{ true, \"RXAMS\", \"MTL RX Memory Address Mismatch Error\" },\n\t{ true, \"RXUES\", \"MTL RX Memory Error\" },\n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ true, \"ECES\", \"MTL EST Memory Error\" },\n\t{ true, \"EAMS\", \"MTL EST Memory Address Mismatch Error\" },\n\t{ true, \"EUES\", \"MTL EST Memory Error\" },\n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ true, \"RPCES\", \"MTL RX Parser Memory Error\" },\n\t{ true, \"RPAMS\", \"MTL RX Parser Memory Address Mismatch Error\" },\n\t{ true, \"RPUES\", \"MTL RX Parser Memory Error\" },\n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n};\n\nstatic void dwmac5_handle_mtl_err(struct net_device *ndev,\n\t\tvoid __iomem *ioaddr, bool correctable,\n\t\tstruct stmmac_safety_stats *stats)\n{\n\tu32 value;\n\n\tvalue = readl(ioaddr + MTL_ECC_INT_STATUS);\n\twritel(value, ioaddr + MTL_ECC_INT_STATUS);\n\n\tdwmac5_log_error(ndev, value, correctable, \"MTL\", dwmac5_mtl_errors,\n\t\t\tSTAT_OFF(mtl_errors), stats);\n}\n\nstatic const struct dwmac5_error_desc dwmac5_dma_errors[32]= {\n\t{ true, \"TCES\", \"DMA TSO Memory Error\" },\n\t{ true, \"TAMS\", \"DMA TSO Memory Address Mismatch Error\" },\n\t{ true, \"TUES\", \"DMA TSO Memory Error\" },\n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n\t{ false, \"UNKNOWN\", \"Unknown Error\" },  \n};\n\nstatic void dwmac5_handle_dma_err(struct net_device *ndev,\n\t\tvoid __iomem *ioaddr, bool correctable,\n\t\tstruct stmmac_safety_stats *stats)\n{\n\tu32 value;\n\n\tvalue = readl(ioaddr + DMA_ECC_INT_STATUS);\n\twritel(value, ioaddr + DMA_ECC_INT_STATUS);\n\n\tdwmac5_log_error(ndev, value, correctable, \"DMA\", dwmac5_dma_errors,\n\t\t\tSTAT_OFF(dma_errors), stats);\n}\n\nint dwmac5_safety_feat_config(void __iomem *ioaddr, unsigned int asp,\n\t\t\t      struct stmmac_safety_feature_cfg *safety_feat_cfg)\n{\n\tstruct stmmac_safety_feature_cfg all_safety_feats = {\n\t\t.tsoee = 1,\n\t\t.mrxpee = 1,\n\t\t.mestee = 1,\n\t\t.mrxee = 1,\n\t\t.mtxee = 1,\n\t\t.epsi = 1,\n\t\t.edpp = 1,\n\t\t.prtyen = 1,\n\t\t.tmouten = 1,\n\t};\n\tu32 value;\n\n\tif (!asp)\n\t\treturn -EINVAL;\n\n\tif (!safety_feat_cfg)\n\t\tsafety_feat_cfg = &all_safety_feats;\n\n\t \n\tvalue = readl(ioaddr + MTL_ECC_CONTROL);\n\tvalue |= MEEAO;  \n\tif (safety_feat_cfg->tsoee)\n\t\tvalue |= TSOEE;  \n\tif (safety_feat_cfg->mrxpee)\n\t\tvalue |= MRXPEE;  \n\tif (safety_feat_cfg->mestee)\n\t\tvalue |= MESTEE;  \n\tif (safety_feat_cfg->mrxee)\n\t\tvalue |= MRXEE;  \n\tif (safety_feat_cfg->mtxee)\n\t\tvalue |= MTXEE;  \n\twritel(value, ioaddr + MTL_ECC_CONTROL);\n\n\t \n\tvalue = readl(ioaddr + MTL_ECC_INT_ENABLE);\n\tvalue |= RPCEIE;  \n\tvalue |= ECEIE;  \n\tvalue |= RXCEIE;  \n\tvalue |= TXCEIE;  \n\twritel(value, ioaddr + MTL_ECC_INT_ENABLE);\n\n\t \n\tvalue = readl(ioaddr + DMA_ECC_INT_ENABLE);\n\tvalue |= TCEIE;  \n\twritel(value, ioaddr + DMA_ECC_INT_ENABLE);\n\n\t \n\tif (asp <= 0x1)\n\t\treturn 0;\n\n\t \n\tvalue = readl(ioaddr + MAC_FSM_CONTROL);\n\tif (safety_feat_cfg->prtyen)\n\t\tvalue |= PRTYEN;  \n\tif (safety_feat_cfg->tmouten)\n\t\tvalue |= TMOUTEN;  \n\twritel(value, ioaddr + MAC_FSM_CONTROL);\n\n\t \n\tvalue = readl(ioaddr + MTL_DPP_CONTROL);\n\tif (safety_feat_cfg->edpp)\n\t\tvalue |= EDPP;\n\twritel(value, ioaddr + MTL_DPP_CONTROL);\n\n\t \n\tif (asp <= 0x2)\n\t\treturn 0;\n\n\tif (safety_feat_cfg->epsi)\n\t\tvalue |= EPSI;\n\twritel(value, ioaddr + MTL_DPP_CONTROL);\n\treturn 0;\n}\n\nint dwmac5_safety_feat_irq_status(struct net_device *ndev,\n\t\tvoid __iomem *ioaddr, unsigned int asp,\n\t\tstruct stmmac_safety_stats *stats)\n{\n\tbool err, corr;\n\tu32 mtl, dma;\n\tint ret = 0;\n\n\tif (!asp)\n\t\treturn -EINVAL;\n\n\tmtl = readl(ioaddr + MTL_SAFETY_INT_STATUS);\n\tdma = readl(ioaddr + DMA_SAFETY_INT_STATUS);\n\n\terr = (mtl & MCSIS) || (dma & MCSIS);\n\tcorr = false;\n\tif (err) {\n\t\tdwmac5_handle_mac_err(ndev, ioaddr, corr, stats);\n\t\tret |= !corr;\n\t}\n\n\terr = (mtl & (MEUIS | MECIS)) || (dma & (MSUIS | MSCIS));\n\tcorr = (mtl & MECIS) || (dma & MSCIS);\n\tif (err) {\n\t\tdwmac5_handle_mtl_err(ndev, ioaddr, corr, stats);\n\t\tret |= !corr;\n\t}\n\n\terr = dma & (DEUIS | DECIS);\n\tcorr = dma & DECIS;\n\tif (err) {\n\t\tdwmac5_handle_dma_err(ndev, ioaddr, corr, stats);\n\t\tret |= !corr;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct dwmac5_error {\n\tconst struct dwmac5_error_desc *desc;\n} dwmac5_all_errors[] = {\n\t{ dwmac5_mac_errors },\n\t{ dwmac5_mtl_errors },\n\t{ dwmac5_dma_errors },\n};\n\nint dwmac5_safety_feat_dump(struct stmmac_safety_stats *stats,\n\t\t\tint index, unsigned long *count, const char **desc)\n{\n\tint module = index / 32, offset = index % 32;\n\tunsigned long *ptr = (unsigned long *)stats;\n\n\tif (module >= ARRAY_SIZE(dwmac5_all_errors))\n\t\treturn -EINVAL;\n\tif (!dwmac5_all_errors[module].desc[offset].valid)\n\t\treturn -EINVAL;\n\tif (count)\n\t\t*count = *(ptr + index);\n\tif (desc)\n\t\t*desc = dwmac5_all_errors[module].desc[offset].desc;\n\treturn 0;\n}\n\nstatic int dwmac5_rxp_disable(void __iomem *ioaddr)\n{\n\tu32 val;\n\n\tval = readl(ioaddr + MTL_OPERATION_MODE);\n\tval &= ~MTL_FRPE;\n\twritel(val, ioaddr + MTL_OPERATION_MODE);\n\n\treturn readl_poll_timeout(ioaddr + MTL_RXP_CONTROL_STATUS, val,\n\t\t\tval & RXPI, 1, 10000);\n}\n\nstatic void dwmac5_rxp_enable(void __iomem *ioaddr)\n{\n\tu32 val;\n\n\tval = readl(ioaddr + MTL_OPERATION_MODE);\n\tval |= MTL_FRPE;\n\twritel(val, ioaddr + MTL_OPERATION_MODE);\n}\n\nstatic int dwmac5_rxp_update_single_entry(void __iomem *ioaddr,\n\t\t\t\t\t  struct stmmac_tc_entry *entry,\n\t\t\t\t\t  int pos)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < (sizeof(entry->val) / sizeof(u32)); i++) {\n\t\tint real_pos = pos * (sizeof(entry->val) / sizeof(u32)) + i;\n\t\tu32 val;\n\n\t\t \n\t\tret = readl_poll_timeout(ioaddr + MTL_RXP_IACC_CTRL_STATUS,\n\t\t\t\tval, !(val & STARTBUSY), 1, 10000);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tval = *((u32 *)&entry->val + i);\n\t\twritel(val, ioaddr + MTL_RXP_IACC_DATA);\n\n\t\t \n\t\tval = real_pos & ADDR;\n\t\twritel(val, ioaddr + MTL_RXP_IACC_CTRL_STATUS);\n\n\t\t \n\t\tval |= WRRDN;\n\t\twritel(val, ioaddr + MTL_RXP_IACC_CTRL_STATUS);\n\n\t\t \n\t\tval |= STARTBUSY;\n\t\twritel(val, ioaddr + MTL_RXP_IACC_CTRL_STATUS);\n\n\t\t \n\t\tret = readl_poll_timeout(ioaddr + MTL_RXP_IACC_CTRL_STATUS,\n\t\t\t\tval, !(val & STARTBUSY), 1, 10000);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct stmmac_tc_entry *\ndwmac5_rxp_get_next_entry(struct stmmac_tc_entry *entries, unsigned int count,\n\t\t\t  u32 curr_prio)\n{\n\tstruct stmmac_tc_entry *entry;\n\tu32 min_prio = ~0x0;\n\tint i, min_prio_idx;\n\tbool found = false;\n\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tentry = &entries[i];\n\n\t\t \n\t\tif (!entry->in_use)\n\t\t\tcontinue;\n\t\t \n\t\tif (entry->in_hw)\n\t\t\tcontinue;\n\t\t \n\t\tif (entry->is_last)\n\t\t\tcontinue;\n\t\t \n\t\tif (entry->is_frag)\n\t\t\tcontinue;\n\t\t \n\t\tif (entry->prio < curr_prio)\n\t\t\tcontinue;\n\t\t \n\t\tif (entry->prio < min_prio) {\n\t\t\tmin_prio = entry->prio;\n\t\t\tmin_prio_idx = i;\n\t\t\tfound = true;\n\t\t}\n\t}\n\n\tif (found)\n\t\treturn &entries[min_prio_idx];\n\treturn NULL;\n}\n\nint dwmac5_rxp_config(void __iomem *ioaddr, struct stmmac_tc_entry *entries,\n\t\t      unsigned int count)\n{\n\tstruct stmmac_tc_entry *entry, *frag;\n\tint i, ret, nve = 0;\n\tu32 curr_prio = 0;\n\tu32 old_val, val;\n\n\t \n\told_val = readl(ioaddr + GMAC_CONFIG);\n\tval = old_val & ~GMAC_CONFIG_RE;\n\twritel(val, ioaddr + GMAC_CONFIG);\n\n\t \n\tret = dwmac5_rxp_disable(ioaddr);\n\tif (ret)\n\t\tgoto re_enable;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tentry = &entries[i];\n\t\tentry->in_hw = false;\n\t}\n\n\t \n\twhile (1) {\n\t\tentry = dwmac5_rxp_get_next_entry(entries, count, curr_prio);\n\t\tif (!entry)\n\t\t\tbreak;\n\n\t\tcurr_prio = entry->prio;\n\t\tfrag = entry->frag_ptr;\n\n\t\t \n\t\tif (frag) {\n\t\t\tentry->val.af = 0;\n\t\t\tentry->val.rf = 0;\n\t\t\tentry->val.nc = 1;\n\t\t\tentry->val.ok_index = nve + 2;\n\t\t}\n\n\t\tret = dwmac5_rxp_update_single_entry(ioaddr, entry, nve);\n\t\tif (ret)\n\t\t\tgoto re_enable;\n\n\t\tentry->table_pos = nve++;\n\t\tentry->in_hw = true;\n\n\t\tif (frag && !frag->in_hw) {\n\t\t\tret = dwmac5_rxp_update_single_entry(ioaddr, frag, nve);\n\t\t\tif (ret)\n\t\t\t\tgoto re_enable;\n\t\t\tfrag->table_pos = nve++;\n\t\t\tfrag->in_hw = true;\n\t\t}\n\t}\n\n\tif (!nve)\n\t\tgoto re_enable;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tentry = &entries[i];\n\t\tif (!entry->is_last)\n\t\t\tcontinue;\n\n\t\tret = dwmac5_rxp_update_single_entry(ioaddr, entry, nve);\n\t\tif (ret)\n\t\t\tgoto re_enable;\n\n\t\tentry->table_pos = nve++;\n\t}\n\n\t \n\tval = (nve << 16) & NPE;\n\tval |= nve & NVE;\n\twritel(val, ioaddr + MTL_RXP_CONTROL_STATUS);\n\n\t \n\tdwmac5_rxp_enable(ioaddr);\n\nre_enable:\n\t \n\twritel(old_val, ioaddr + GMAC_CONFIG);\n\treturn ret;\n}\n\nint dwmac5_flex_pps_config(void __iomem *ioaddr, int index,\n\t\t\t   struct stmmac_pps_cfg *cfg, bool enable,\n\t\t\t   u32 sub_second_inc, u32 systime_flags)\n{\n\tu32 tnsec = readl(ioaddr + MAC_PPSx_TARGET_TIME_NSEC(index));\n\tu32 val = readl(ioaddr + MAC_PPS_CONTROL);\n\tu64 period;\n\n\tif (!cfg->available)\n\t\treturn -EINVAL;\n\tif (tnsec & TRGTBUSY0)\n\t\treturn -EBUSY;\n\tif (!sub_second_inc || !systime_flags)\n\t\treturn -EINVAL;\n\n\tval &= ~PPSx_MASK(index);\n\n\tif (!enable) {\n\t\tval |= PPSCMDx(index, 0x5);\n\t\tval |= PPSEN0;\n\t\twritel(val, ioaddr + MAC_PPS_CONTROL);\n\t\treturn 0;\n\t}\n\n\tval |= TRGTMODSELx(index, 0x2);\n\tval |= PPSEN0;\n\twritel(val, ioaddr + MAC_PPS_CONTROL);\n\n\twritel(cfg->start.tv_sec, ioaddr + MAC_PPSx_TARGET_TIME_SEC(index));\n\n\tif (!(systime_flags & PTP_TCR_TSCTRLSSR))\n\t\tcfg->start.tv_nsec = (cfg->start.tv_nsec * 1000) / 465;\n\twritel(cfg->start.tv_nsec, ioaddr + MAC_PPSx_TARGET_TIME_NSEC(index));\n\n\tperiod = cfg->period.tv_sec * 1000000000;\n\tperiod += cfg->period.tv_nsec;\n\n\tdo_div(period, sub_second_inc);\n\n\tif (period <= 1)\n\t\treturn -EINVAL;\n\n\twritel(period - 1, ioaddr + MAC_PPSx_INTERVAL(index));\n\n\tperiod >>= 1;\n\tif (period <= 1)\n\t\treturn -EINVAL;\n\n\twritel(period - 1, ioaddr + MAC_PPSx_WIDTH(index));\n\n\t \n\tval |= PPSCMDx(index, 0x2);\n\twritel(val, ioaddr + MAC_PPS_CONTROL);\n\treturn 0;\n}\n\nstatic int dwmac5_est_write(void __iomem *ioaddr, u32 reg, u32 val, bool gcl)\n{\n\tu32 ctrl;\n\n\twritel(val, ioaddr + MTL_EST_GCL_DATA);\n\n\tctrl = (reg << ADDR_SHIFT);\n\tctrl |= gcl ? 0 : GCRR;\n\n\twritel(ctrl, ioaddr + MTL_EST_GCL_CONTROL);\n\n\tctrl |= SRWO;\n\twritel(ctrl, ioaddr + MTL_EST_GCL_CONTROL);\n\n\treturn readl_poll_timeout(ioaddr + MTL_EST_GCL_CONTROL,\n\t\t\t\t  ctrl, !(ctrl & SRWO), 100, 5000);\n}\n\nint dwmac5_est_configure(void __iomem *ioaddr, struct stmmac_est *cfg,\n\t\t\t unsigned int ptp_rate)\n{\n\tint i, ret = 0x0;\n\tu32 ctrl;\n\n\tret |= dwmac5_est_write(ioaddr, BTR_LOW, cfg->btr[0], false);\n\tret |= dwmac5_est_write(ioaddr, BTR_HIGH, cfg->btr[1], false);\n\tret |= dwmac5_est_write(ioaddr, TER, cfg->ter, false);\n\tret |= dwmac5_est_write(ioaddr, LLR, cfg->gcl_size, false);\n\tret |= dwmac5_est_write(ioaddr, CTR_LOW, cfg->ctr[0], false);\n\tret |= dwmac5_est_write(ioaddr, CTR_HIGH, cfg->ctr[1], false);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < cfg->gcl_size; i++) {\n\t\tret = dwmac5_est_write(ioaddr, i, cfg->gcl[i], true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tctrl = readl(ioaddr + MTL_EST_CONTROL);\n\tctrl &= ~PTOV;\n\tctrl |= ((1000000000 / ptp_rate) * 6) << PTOV_SHIFT;\n\tif (cfg->enable)\n\t\tctrl |= EEST | SSWL;\n\telse\n\t\tctrl &= ~EEST;\n\n\twritel(ctrl, ioaddr + MTL_EST_CONTROL);\n\n\t \n\tif (cfg->enable)\n\t\tctrl = (IECGCE | IEHS | IEHF | IEBE | IECC);\n\telse\n\t\tctrl = 0;\n\n\twritel(ctrl, ioaddr + MTL_EST_INT_EN);\n\n\treturn 0;\n}\n\nvoid dwmac5_est_irq_status(void __iomem *ioaddr, struct net_device *dev,\n\t\t\t  struct stmmac_extra_stats *x, u32 txqcnt)\n{\n\tu32 status, value, feqn, hbfq, hbfs, btrl;\n\tu32 txqcnt_mask = (1 << txqcnt) - 1;\n\n\tstatus = readl(ioaddr + MTL_EST_STATUS);\n\n\tvalue = (CGCE | HLBS | HLBF | BTRE | SWLC);\n\n\t \n\tif (!(status & value))\n\t\treturn;\n\n\tif (status & CGCE) {\n\t\t \n\t\twritel(CGCE, ioaddr + MTL_EST_STATUS);\n\n\t\tx->mtl_est_cgce++;\n\t}\n\n\tif (status & HLBS) {\n\t\tvalue = readl(ioaddr + MTL_EST_SCH_ERR);\n\t\tvalue &= txqcnt_mask;\n\n\t\tx->mtl_est_hlbs++;\n\n\t\t \n\t\twritel(value, ioaddr + MTL_EST_SCH_ERR);\n\n\t\t \n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(dev, \"EST: HLB(sched) Queue 0x%x\\n\", value);\n\t}\n\n\tif (status & HLBF) {\n\t\tvalue = readl(ioaddr + MTL_EST_FRM_SZ_ERR);\n\t\tfeqn = value & txqcnt_mask;\n\n\t\tvalue = readl(ioaddr + MTL_EST_FRM_SZ_CAP);\n\t\thbfq = (value & SZ_CAP_HBFQ_MASK(txqcnt)) >> SZ_CAP_HBFQ_SHIFT;\n\t\thbfs = value & SZ_CAP_HBFS_MASK;\n\n\t\tx->mtl_est_hlbf++;\n\n\t\t \n\t\twritel(feqn, ioaddr + MTL_EST_FRM_SZ_ERR);\n\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(dev, \"EST: HLB(size) Queue %u Size %u\\n\",\n\t\t\t\t   hbfq, hbfs);\n\t}\n\n\tif (status & BTRE) {\n\t\tif ((status & BTRL) == BTRL_MAX)\n\t\t\tx->mtl_est_btrlm++;\n\t\telse\n\t\t\tx->mtl_est_btre++;\n\n\t\tbtrl = (status & BTRL) >> BTRL_SHIFT;\n\n\t\tif (net_ratelimit())\n\t\t\tnetdev_info(dev, \"EST: BTR Error Loop Count %u\\n\",\n\t\t\t\t    btrl);\n\n\t\twritel(BTRE, ioaddr + MTL_EST_STATUS);\n\t}\n\n\tif (status & SWLC) {\n\t\twritel(SWLC, ioaddr + MTL_EST_STATUS);\n\t\tnetdev_info(dev, \"EST: SWOL has been switched\\n\");\n\t}\n}\n\nvoid dwmac5_fpe_configure(void __iomem *ioaddr, struct stmmac_fpe_cfg *cfg,\n\t\t\t  u32 num_txq, u32 num_rxq,\n\t\t\t  bool enable)\n{\n\tu32 value;\n\n\tif (enable) {\n\t\tcfg->fpe_csr = EFPE;\n\t\tvalue = readl(ioaddr + GMAC_RXQ_CTRL1);\n\t\tvalue &= ~GMAC_RXQCTRL_FPRQ;\n\t\tvalue |= (num_rxq - 1) << GMAC_RXQCTRL_FPRQ_SHIFT;\n\t\twritel(value, ioaddr + GMAC_RXQ_CTRL1);\n\t} else {\n\t\tcfg->fpe_csr = 0;\n\t}\n\twritel(cfg->fpe_csr, ioaddr + MAC_FPE_CTRL_STS);\n}\n\nint dwmac5_fpe_irq_status(void __iomem *ioaddr, struct net_device *dev)\n{\n\tu32 value;\n\tint status;\n\n\tstatus = FPE_EVENT_UNKNOWN;\n\n\t \n\tvalue = readl(ioaddr + MAC_FPE_CTRL_STS);\n\n\tif (value & TRSP) {\n\t\tstatus |= FPE_EVENT_TRSP;\n\t\tnetdev_info(dev, \"FPE: Respond mPacket is transmitted\\n\");\n\t}\n\n\tif (value & TVER) {\n\t\tstatus |= FPE_EVENT_TVER;\n\t\tnetdev_info(dev, \"FPE: Verify mPacket is transmitted\\n\");\n\t}\n\n\tif (value & RRSP) {\n\t\tstatus |= FPE_EVENT_RRSP;\n\t\tnetdev_info(dev, \"FPE: Respond mPacket is received\\n\");\n\t}\n\n\tif (value & RVER) {\n\t\tstatus |= FPE_EVENT_RVER;\n\t\tnetdev_info(dev, \"FPE: Verify mPacket is received\\n\");\n\t}\n\n\treturn status;\n}\n\nvoid dwmac5_fpe_send_mpacket(void __iomem *ioaddr, struct stmmac_fpe_cfg *cfg,\n\t\t\t     enum stmmac_mpacket_type type)\n{\n\tu32 value = cfg->fpe_csr;\n\n\tif (type == MPACKET_VERIFY)\n\t\tvalue |= SVER;\n\telse if (type == MPACKET_RESPONSE)\n\t\tvalue |= SRSP;\n\n\twritel(value, ioaddr + MAC_FPE_CTRL_STS);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}