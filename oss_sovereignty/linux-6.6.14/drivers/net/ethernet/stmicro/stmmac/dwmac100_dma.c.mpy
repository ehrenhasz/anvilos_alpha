{
  "module_name": "dwmac100_dma.c",
  "hash_id": "d43202b015df90624815f9fd533d23c8e7b60b55ea0d5cd3fb8e02f44ef32ee4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwmac100_dma.c",
  "human_readable_source": "\n \n\n#include <asm/io.h>\n#include \"dwmac100.h\"\n#include \"dwmac_dma.h\"\n\nstatic void dwmac100_dma_init(void __iomem *ioaddr,\n\t\t\t      struct stmmac_dma_cfg *dma_cfg, int atds)\n{\n\t \n\twritel(DMA_BUS_MODE_DEFAULT | (dma_cfg->pbl << DMA_BUS_MODE_PBL_SHIFT),\n\t       ioaddr + DMA_BUS_MODE);\n\n\t \n\twritel(DMA_INTR_DEFAULT_MASK, ioaddr + DMA_INTR_ENA);\n}\n\nstatic void dwmac100_dma_init_rx(struct stmmac_priv *priv, void __iomem *ioaddr,\n\t\t\t\t struct stmmac_dma_cfg *dma_cfg,\n\t\t\t\t dma_addr_t dma_rx_phy, u32 chan)\n{\n\t \n\twritel(lower_32_bits(dma_rx_phy), ioaddr + DMA_RCV_BASE_ADDR);\n}\n\nstatic void dwmac100_dma_init_tx(struct stmmac_priv *priv, void __iomem *ioaddr,\n\t\t\t\t struct stmmac_dma_cfg *dma_cfg,\n\t\t\t\t dma_addr_t dma_tx_phy, u32 chan)\n{\n\t \n\twritel(lower_32_bits(dma_tx_phy), ioaddr + DMA_TX_BASE_ADDR);\n}\n\n \nstatic void dwmac100_dma_operation_mode_tx(struct stmmac_priv *priv,\n\t\t\t\t\t   void __iomem *ioaddr, int mode,\n\t\t\t\t\t   u32 channel, int fifosz, u8 qmode)\n{\n\tu32 csr6 = readl(ioaddr + DMA_CONTROL);\n\n\tif (mode <= 32)\n\t\tcsr6 |= DMA_CONTROL_TTC_32;\n\telse if (mode <= 64)\n\t\tcsr6 |= DMA_CONTROL_TTC_64;\n\telse\n\t\tcsr6 |= DMA_CONTROL_TTC_128;\n\n\twritel(csr6, ioaddr + DMA_CONTROL);\n}\n\nstatic void dwmac100_dump_dma_regs(struct stmmac_priv *priv,\n\t\t\t\t   void __iomem *ioaddr, u32 *reg_space)\n{\n\tint i;\n\n\tfor (i = 0; i < NUM_DWMAC100_DMA_REGS; i++)\n\t\treg_space[DMA_BUS_MODE / 4 + i] =\n\t\t\treadl(ioaddr + DMA_BUS_MODE + i * 4);\n\n\treg_space[DMA_CUR_TX_BUF_ADDR / 4] =\n\t\treadl(ioaddr + DMA_CUR_TX_BUF_ADDR);\n\treg_space[DMA_CUR_RX_BUF_ADDR / 4] =\n\t\treadl(ioaddr + DMA_CUR_RX_BUF_ADDR);\n}\n\n \nstatic void dwmac100_dma_diagnostic_fr(struct stmmac_extra_stats *x,\n\t\t\t\t       void __iomem *ioaddr)\n{\n\tu32 csr8 = readl(ioaddr + DMA_MISSED_FRAME_CTR);\n\n\tif (unlikely(csr8)) {\n\t\tif (csr8 & DMA_MISSED_FRAME_OVE) {\n\t\t\tx->rx_overflow_cntr += 0x800;\n\t\t} else {\n\t\t\tunsigned int ove_cntr;\n\t\t\tove_cntr = ((csr8 & DMA_MISSED_FRAME_OVE_CNTR) >> 17);\n\t\t\tx->rx_overflow_cntr += ove_cntr;\n\t\t}\n\n\t\tif (csr8 & DMA_MISSED_FRAME_OVE_M) {\n\t\t\tx->rx_missed_cntr += 0xffff;\n\t\t} else {\n\t\t\tunsigned int miss_f = (csr8 & DMA_MISSED_FRAME_M_CNTR);\n\t\t\tx->rx_missed_cntr += miss_f;\n\t\t}\n\t}\n}\n\nconst struct stmmac_dma_ops dwmac100_dma_ops = {\n\t.reset = dwmac_dma_reset,\n\t.init = dwmac100_dma_init,\n\t.init_rx_chan = dwmac100_dma_init_rx,\n\t.init_tx_chan = dwmac100_dma_init_tx,\n\t.dump_regs = dwmac100_dump_dma_regs,\n\t.dma_tx_mode = dwmac100_dma_operation_mode_tx,\n\t.dma_diagnostic_fr = dwmac100_dma_diagnostic_fr,\n\t.enable_dma_transmission = dwmac_enable_dma_transmission,\n\t.enable_dma_irq = dwmac_enable_dma_irq,\n\t.disable_dma_irq = dwmac_disable_dma_irq,\n\t.start_tx = dwmac_dma_start_tx,\n\t.stop_tx = dwmac_dma_stop_tx,\n\t.start_rx = dwmac_dma_start_rx,\n\t.stop_rx = dwmac_dma_stop_rx,\n\t.dma_interrupt = dwmac_dma_interrupt,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}