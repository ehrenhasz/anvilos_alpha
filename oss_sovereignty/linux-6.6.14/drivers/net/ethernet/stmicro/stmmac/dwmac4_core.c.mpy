{
  "module_name": "dwmac4_core.c",
  "hash_id": "0404cf65b78c17c1b0eb4ff9affd5cab9d974e754bd4030421a08773dabf1951",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c",
  "human_readable_source": "\n \n\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/ethtool.h>\n#include <linux/io.h>\n#include \"stmmac.h\"\n#include \"stmmac_pcs.h\"\n#include \"dwmac4.h\"\n#include \"dwmac5.h\"\n\nstatic void dwmac4_core_init(struct mac_device_info *hw,\n\t\t\t     struct net_device *dev)\n{\n\tstruct stmmac_priv *priv = netdev_priv(dev);\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value = readl(ioaddr + GMAC_CONFIG);\n\tu32 clk_rate;\n\n\tvalue |= GMAC_CORE_INIT;\n\n\tif (hw->ps) {\n\t\tvalue |= GMAC_CONFIG_TE;\n\n\t\tvalue &= hw->link.speed_mask;\n\t\tswitch (hw->ps) {\n\t\tcase SPEED_1000:\n\t\t\tvalue |= hw->link.speed1000;\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tvalue |= hw->link.speed100;\n\t\t\tbreak;\n\t\tcase SPEED_10:\n\t\t\tvalue |= hw->link.speed10;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twritel(value, ioaddr + GMAC_CONFIG);\n\n\t \n\tclk_rate = clk_get_rate(priv->plat->stmmac_clk);\n\twritel((clk_rate / 1000000) - 1, ioaddr + GMAC4_MAC_ONEUS_TIC_COUNTER);\n\n\t \n\tvalue = GMAC_INT_DEFAULT_ENABLE;\n\n\tif (hw->pcs)\n\t\tvalue |= GMAC_PCS_IRQ_DEFAULT;\n\n\t \n\tif ((GMAC_HW_FEAT_FPESEL & readl(ioaddr + GMAC_HW_FEATURE3)) >> 26)\n\t\tvalue |= GMAC_INT_FPE_EN;\n\n\twritel(value, ioaddr + GMAC_INT_EN);\n\n\tif (GMAC_INT_DEFAULT_ENABLE & GMAC_INT_TSIE)\n\t\tinit_waitqueue_head(&priv->tstamp_busy_wait);\n}\n\nstatic void dwmac4_phylink_get_caps(struct stmmac_priv *priv)\n{\n\tpriv->phylink_config.mac_capabilities |= MAC_2500FD;\n}\n\nstatic void dwmac4_rx_queue_enable(struct mac_device_info *hw,\n\t\t\t\t   u8 mode, u32 queue)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value = readl(ioaddr + GMAC_RXQ_CTRL0);\n\n\tvalue &= GMAC_RX_QUEUE_CLEAR(queue);\n\tif (mode == MTL_QUEUE_AVB)\n\t\tvalue |= GMAC_RX_AV_QUEUE_ENABLE(queue);\n\telse if (mode == MTL_QUEUE_DCB)\n\t\tvalue |= GMAC_RX_DCB_QUEUE_ENABLE(queue);\n\n\twritel(value, ioaddr + GMAC_RXQ_CTRL0);\n}\n\nstatic void dwmac4_rx_queue_priority(struct mac_device_info *hw,\n\t\t\t\t     u32 prio, u32 queue)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 base_register;\n\tu32 value;\n\n\tbase_register = (queue < 4) ? GMAC_RXQ_CTRL2 : GMAC_RXQ_CTRL3;\n\tif (queue >= 4)\n\t\tqueue -= 4;\n\n\tvalue = readl(ioaddr + base_register);\n\n\tvalue &= ~GMAC_RXQCTRL_PSRQX_MASK(queue);\n\tvalue |= (prio << GMAC_RXQCTRL_PSRQX_SHIFT(queue)) &\n\t\t\t\t\t\tGMAC_RXQCTRL_PSRQX_MASK(queue);\n\twritel(value, ioaddr + base_register);\n}\n\nstatic void dwmac4_tx_queue_priority(struct mac_device_info *hw,\n\t\t\t\t     u32 prio, u32 queue)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 base_register;\n\tu32 value;\n\n\tbase_register = (queue < 4) ? GMAC_TXQ_PRTY_MAP0 : GMAC_TXQ_PRTY_MAP1;\n\tif (queue >= 4)\n\t\tqueue -= 4;\n\n\tvalue = readl(ioaddr + base_register);\n\n\tvalue &= ~GMAC_TXQCTRL_PSTQX_MASK(queue);\n\tvalue |= (prio << GMAC_TXQCTRL_PSTQX_SHIFT(queue)) &\n\t\t\t\t\t\tGMAC_TXQCTRL_PSTQX_MASK(queue);\n\n\twritel(value, ioaddr + base_register);\n}\n\nstatic void dwmac4_rx_queue_routing(struct mac_device_info *hw,\n\t\t\t\t    u8 packet, u32 queue)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\tstatic const struct stmmac_rx_routing route_possibilities[] = {\n\t\t{ GMAC_RXQCTRL_AVCPQ_MASK, GMAC_RXQCTRL_AVCPQ_SHIFT },\n\t\t{ GMAC_RXQCTRL_PTPQ_MASK, GMAC_RXQCTRL_PTPQ_SHIFT },\n\t\t{ GMAC_RXQCTRL_DCBCPQ_MASK, GMAC_RXQCTRL_DCBCPQ_SHIFT },\n\t\t{ GMAC_RXQCTRL_UPQ_MASK, GMAC_RXQCTRL_UPQ_SHIFT },\n\t\t{ GMAC_RXQCTRL_MCBCQ_MASK, GMAC_RXQCTRL_MCBCQ_SHIFT },\n\t};\n\n\tvalue = readl(ioaddr + GMAC_RXQ_CTRL1);\n\n\t \n\tvalue &= ~route_possibilities[packet - 1].reg_mask;\n\tvalue |= (queue << route_possibilities[packet-1].reg_shift) &\n\t\t route_possibilities[packet - 1].reg_mask;\n\n\t \n\tif (packet == PACKET_AVCPQ) {\n\t\tvalue &= ~GMAC_RXQCTRL_TACPQE;\n\t\tvalue |= 0x1 << GMAC_RXQCTRL_TACPQE_SHIFT;\n\t} else if (packet == PACKET_MCBCQ) {\n\t\tvalue &= ~GMAC_RXQCTRL_MCBCQEN;\n\t\tvalue |= 0x1 << GMAC_RXQCTRL_MCBCQEN_SHIFT;\n\t}\n\n\twritel(value, ioaddr + GMAC_RXQ_CTRL1);\n}\n\nstatic void dwmac4_prog_mtl_rx_algorithms(struct mac_device_info *hw,\n\t\t\t\t\t  u32 rx_alg)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value = readl(ioaddr + MTL_OPERATION_MODE);\n\n\tvalue &= ~MTL_OPERATION_RAA;\n\tswitch (rx_alg) {\n\tcase MTL_RX_ALGORITHM_SP:\n\t\tvalue |= MTL_OPERATION_RAA_SP;\n\t\tbreak;\n\tcase MTL_RX_ALGORITHM_WSP:\n\t\tvalue |= MTL_OPERATION_RAA_WSP;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\twritel(value, ioaddr + MTL_OPERATION_MODE);\n}\n\nstatic void dwmac4_prog_mtl_tx_algorithms(struct mac_device_info *hw,\n\t\t\t\t\t  u32 tx_alg)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value = readl(ioaddr + MTL_OPERATION_MODE);\n\n\tvalue &= ~MTL_OPERATION_SCHALG_MASK;\n\tswitch (tx_alg) {\n\tcase MTL_TX_ALGORITHM_WRR:\n\t\tvalue |= MTL_OPERATION_SCHALG_WRR;\n\t\tbreak;\n\tcase MTL_TX_ALGORITHM_WFQ:\n\t\tvalue |= MTL_OPERATION_SCHALG_WFQ;\n\t\tbreak;\n\tcase MTL_TX_ALGORITHM_DWRR:\n\t\tvalue |= MTL_OPERATION_SCHALG_DWRR;\n\t\tbreak;\n\tcase MTL_TX_ALGORITHM_SP:\n\t\tvalue |= MTL_OPERATION_SCHALG_SP;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\twritel(value, ioaddr + MTL_OPERATION_MODE);\n}\n\nstatic void dwmac4_set_mtl_tx_queue_weight(struct stmmac_priv *priv,\n\t\t\t\t\t   struct mac_device_info *hw,\n\t\t\t\t\t   u32 weight, u32 queue)\n{\n\tconst struct dwmac4_addrs *dwmac4_addrs = priv->plat->dwmac4_addrs;\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value = readl(ioaddr + mtl_txqx_weight_base_addr(dwmac4_addrs,\n\t\t\t\t\t\t\t     queue));\n\n\tvalue &= ~MTL_TXQ_WEIGHT_ISCQW_MASK;\n\tvalue |= weight & MTL_TXQ_WEIGHT_ISCQW_MASK;\n\twritel(value, ioaddr + mtl_txqx_weight_base_addr(dwmac4_addrs, queue));\n}\n\nstatic void dwmac4_map_mtl_dma(struct mac_device_info *hw, u32 queue, u32 chan)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\tif (queue < 4) {\n\t\tvalue = readl(ioaddr + MTL_RXQ_DMA_MAP0);\n\t\tvalue &= ~MTL_RXQ_DMA_QXMDMACH_MASK(queue);\n\t\tvalue |= MTL_RXQ_DMA_QXMDMACH(chan, queue);\n\t\twritel(value, ioaddr + MTL_RXQ_DMA_MAP0);\n\t} else {\n\t\tvalue = readl(ioaddr + MTL_RXQ_DMA_MAP1);\n\t\tvalue &= ~MTL_RXQ_DMA_QXMDMACH_MASK(queue - 4);\n\t\tvalue |= MTL_RXQ_DMA_QXMDMACH(chan, queue - 4);\n\t\twritel(value, ioaddr + MTL_RXQ_DMA_MAP1);\n\t}\n}\n\nstatic void dwmac4_config_cbs(struct stmmac_priv *priv,\n\t\t\t      struct mac_device_info *hw,\n\t\t\t      u32 send_slope, u32 idle_slope,\n\t\t\t      u32 high_credit, u32 low_credit, u32 queue)\n{\n\tconst struct dwmac4_addrs *dwmac4_addrs = priv->plat->dwmac4_addrs;\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\tpr_debug(\"Queue %d configured as AVB. Parameters:\\n\", queue);\n\tpr_debug(\"\\tsend_slope: 0x%08x\\n\", send_slope);\n\tpr_debug(\"\\tidle_slope: 0x%08x\\n\", idle_slope);\n\tpr_debug(\"\\thigh_credit: 0x%08x\\n\", high_credit);\n\tpr_debug(\"\\tlow_credit: 0x%08x\\n\", low_credit);\n\n\t \n\tvalue = readl(ioaddr + mtl_etsx_ctrl_base_addr(dwmac4_addrs, queue));\n\tvalue |= MTL_ETS_CTRL_AVALG;\n\tvalue |= MTL_ETS_CTRL_CC;\n\twritel(value, ioaddr + mtl_etsx_ctrl_base_addr(dwmac4_addrs, queue));\n\n\t \n\tvalue = readl(ioaddr + mtl_send_slp_credx_base_addr(dwmac4_addrs,\n\t\t\t\t\t\t\t    queue));\n\tvalue &= ~MTL_SEND_SLP_CRED_SSC_MASK;\n\tvalue |= send_slope & MTL_SEND_SLP_CRED_SSC_MASK;\n\twritel(value, ioaddr + mtl_send_slp_credx_base_addr(dwmac4_addrs,\n\t\t\t\t\t\t\t    queue));\n\n\t \n\tdwmac4_set_mtl_tx_queue_weight(priv, hw, idle_slope, queue);\n\n\t \n\tvalue = readl(ioaddr + mtl_high_credx_base_addr(dwmac4_addrs, queue));\n\tvalue &= ~MTL_HIGH_CRED_HC_MASK;\n\tvalue |= high_credit & MTL_HIGH_CRED_HC_MASK;\n\twritel(value, ioaddr + mtl_high_credx_base_addr(dwmac4_addrs, queue));\n\n\t \n\tvalue = readl(ioaddr + mtl_low_credx_base_addr(dwmac4_addrs, queue));\n\tvalue &= ~MTL_HIGH_CRED_LC_MASK;\n\tvalue |= low_credit & MTL_HIGH_CRED_LC_MASK;\n\twritel(value, ioaddr + mtl_low_credx_base_addr(dwmac4_addrs, queue));\n}\n\nstatic void dwmac4_dump_regs(struct mac_device_info *hw, u32 *reg_space)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tint i;\n\n\tfor (i = 0; i < GMAC_REG_NUM; i++)\n\t\treg_space[i] = readl(ioaddr + i * 4);\n}\n\nstatic int dwmac4_rx_ipc_enable(struct mac_device_info *hw)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value = readl(ioaddr + GMAC_CONFIG);\n\n\tif (hw->rx_csum)\n\t\tvalue |= GMAC_CONFIG_IPC;\n\telse\n\t\tvalue &= ~GMAC_CONFIG_IPC;\n\n\twritel(value, ioaddr + GMAC_CONFIG);\n\n\tvalue = readl(ioaddr + GMAC_CONFIG);\n\n\treturn !!(value & GMAC_CONFIG_IPC);\n}\n\nstatic void dwmac4_pmt(struct mac_device_info *hw, unsigned long mode)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tunsigned int pmt = 0;\n\tu32 config;\n\n\tif (mode & WAKE_MAGIC) {\n\t\tpr_debug(\"GMAC: WOL Magic frame\\n\");\n\t\tpmt |= power_down | magic_pkt_en;\n\t}\n\tif (mode & WAKE_UCAST) {\n\t\tpr_debug(\"GMAC: WOL on global unicast\\n\");\n\t\tpmt |= power_down | global_unicast | wake_up_frame_en;\n\t}\n\n\tif (pmt) {\n\t\t \n\t\tconfig = readl(ioaddr + GMAC_CONFIG);\n\t\tconfig |= GMAC_CONFIG_RE;\n\t\twritel(config, ioaddr + GMAC_CONFIG);\n\t}\n\twritel(pmt, ioaddr + GMAC_PMT);\n}\n\nstatic void dwmac4_set_umac_addr(struct mac_device_info *hw,\n\t\t\t\t const unsigned char *addr, unsigned int reg_n)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\n\tstmmac_dwmac4_set_mac_addr(ioaddr, addr, GMAC_ADDR_HIGH(reg_n),\n\t\t\t\t   GMAC_ADDR_LOW(reg_n));\n}\n\nstatic void dwmac4_get_umac_addr(struct mac_device_info *hw,\n\t\t\t\t unsigned char *addr, unsigned int reg_n)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\n\tstmmac_dwmac4_get_mac_addr(ioaddr, addr, GMAC_ADDR_HIGH(reg_n),\n\t\t\t\t   GMAC_ADDR_LOW(reg_n));\n}\n\nstatic void dwmac4_set_eee_mode(struct mac_device_info *hw,\n\t\t\t\tbool en_tx_lpi_clockgating)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\t \n\tvalue = readl(ioaddr + GMAC4_LPI_CTRL_STATUS);\n\tvalue |= GMAC4_LPI_CTRL_STATUS_LPIEN | GMAC4_LPI_CTRL_STATUS_LPITXA;\n\n\tif (en_tx_lpi_clockgating)\n\t\tvalue |= GMAC4_LPI_CTRL_STATUS_LPITCSE;\n\n\twritel(value, ioaddr + GMAC4_LPI_CTRL_STATUS);\n}\n\nstatic void dwmac4_reset_eee_mode(struct mac_device_info *hw)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\tvalue = readl(ioaddr + GMAC4_LPI_CTRL_STATUS);\n\tvalue &= ~(GMAC4_LPI_CTRL_STATUS_LPIEN | GMAC4_LPI_CTRL_STATUS_LPITXA);\n\twritel(value, ioaddr + GMAC4_LPI_CTRL_STATUS);\n}\n\nstatic void dwmac4_set_eee_pls(struct mac_device_info *hw, int link)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\tvalue = readl(ioaddr + GMAC4_LPI_CTRL_STATUS);\n\n\tif (link)\n\t\tvalue |= GMAC4_LPI_CTRL_STATUS_PLS;\n\telse\n\t\tvalue &= ~GMAC4_LPI_CTRL_STATUS_PLS;\n\n\twritel(value, ioaddr + GMAC4_LPI_CTRL_STATUS);\n}\n\nstatic void dwmac4_set_eee_lpi_entry_timer(struct mac_device_info *hw, int et)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tint value = et & STMMAC_ET_MAX;\n\tint regval;\n\n\t \n\twritel(value, ioaddr + GMAC4_LPI_ENTRY_TIMER);\n\n\t \n\tregval = readl(ioaddr + GMAC4_LPI_CTRL_STATUS);\n\tregval |= GMAC4_LPI_CTRL_STATUS_LPIEN | GMAC4_LPI_CTRL_STATUS_LPITXA;\n\n\tif (et)\n\t\tregval |= GMAC4_LPI_CTRL_STATUS_LPIATE;\n\telse\n\t\tregval &= ~GMAC4_LPI_CTRL_STATUS_LPIATE;\n\n\twritel(regval, ioaddr + GMAC4_LPI_CTRL_STATUS);\n}\n\nstatic void dwmac4_set_eee_timer(struct mac_device_info *hw, int ls, int tw)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tint value = ((tw & 0xffff)) | ((ls & 0x3ff) << 16);\n\n\t \n\twritel(value, ioaddr + GMAC4_LPI_TIMER_CTRL);\n}\n\nstatic void dwmac4_write_single_vlan(struct net_device *dev, u16 vid)\n{\n\tvoid __iomem *ioaddr = (void __iomem *)dev->base_addr;\n\tu32 val;\n\n\tval = readl(ioaddr + GMAC_VLAN_TAG);\n\tval &= ~GMAC_VLAN_TAG_VID;\n\tval |= GMAC_VLAN_TAG_ETV | vid;\n\n\twritel(val, ioaddr + GMAC_VLAN_TAG);\n}\n\nstatic int dwmac4_write_vlan_filter(struct net_device *dev,\n\t\t\t\t    struct mac_device_info *hw,\n\t\t\t\t    u8 index, u32 data)\n{\n\tvoid __iomem *ioaddr = (void __iomem *)dev->base_addr;\n\tint i, timeout = 10;\n\tu32 val;\n\n\tif (index >= hw->num_vlan)\n\t\treturn -EINVAL;\n\n\twritel(data, ioaddr + GMAC_VLAN_TAG_DATA);\n\n\tval = readl(ioaddr + GMAC_VLAN_TAG);\n\tval &= ~(GMAC_VLAN_TAG_CTRL_OFS_MASK |\n\t\tGMAC_VLAN_TAG_CTRL_CT |\n\t\tGMAC_VLAN_TAG_CTRL_OB);\n\tval |= (index << GMAC_VLAN_TAG_CTRL_OFS_SHIFT) | GMAC_VLAN_TAG_CTRL_OB;\n\n\twritel(val, ioaddr + GMAC_VLAN_TAG);\n\n\tfor (i = 0; i < timeout; i++) {\n\t\tval = readl(ioaddr + GMAC_VLAN_TAG);\n\t\tif (!(val & GMAC_VLAN_TAG_CTRL_OB))\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\n\tnetdev_err(dev, \"Timeout accessing MAC_VLAN_Tag_Filter\\n\");\n\n\treturn -EBUSY;\n}\n\nstatic int dwmac4_add_hw_vlan_rx_fltr(struct net_device *dev,\n\t\t\t\t      struct mac_device_info *hw,\n\t\t\t\t      __be16 proto, u16 vid)\n{\n\tint index = -1;\n\tu32 val = 0;\n\tint i, ret;\n\n\tif (vid > 4095)\n\t\treturn -EINVAL;\n\n\t \n\tif (hw->num_vlan == 1) {\n\t\t \n\t\tif (vid == 0) {\n\t\t\tnetdev_warn(dev, \"Adding VLAN ID 0 is not supported\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\tif (hw->vlan_filter[0] & GMAC_VLAN_TAG_VID) {\n\t\t\tnetdev_err(dev, \"Only single VLAN ID supported\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\thw->vlan_filter[0] = vid;\n\t\tdwmac4_write_single_vlan(dev, vid);\n\n\t\treturn 0;\n\t}\n\n\t \n\tval |= GMAC_VLAN_TAG_DATA_ETV | GMAC_VLAN_TAG_DATA_VEN | vid;\n\n\tfor (i = 0; i < hw->num_vlan; i++) {\n\t\tif (hw->vlan_filter[i] == val)\n\t\t\treturn 0;\n\t\telse if (!(hw->vlan_filter[i] & GMAC_VLAN_TAG_DATA_VEN))\n\t\t\tindex = i;\n\t}\n\n\tif (index == -1) {\n\t\tnetdev_err(dev, \"MAC_VLAN_Tag_Filter full (size: %0u)\\n\",\n\t\t\t   hw->num_vlan);\n\t\treturn -EPERM;\n\t}\n\n\tret = dwmac4_write_vlan_filter(dev, hw, index, val);\n\n\tif (!ret)\n\t\thw->vlan_filter[index] = val;\n\n\treturn ret;\n}\n\nstatic int dwmac4_del_hw_vlan_rx_fltr(struct net_device *dev,\n\t\t\t\t      struct mac_device_info *hw,\n\t\t\t\t      __be16 proto, u16 vid)\n{\n\tint i, ret = 0;\n\n\t \n\tif (hw->num_vlan == 1) {\n\t\tif ((hw->vlan_filter[0] & GMAC_VLAN_TAG_VID) == vid) {\n\t\t\thw->vlan_filter[0] = 0;\n\t\t\tdwmac4_write_single_vlan(dev, 0);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; i < hw->num_vlan; i++) {\n\t\tif ((hw->vlan_filter[i] & GMAC_VLAN_TAG_DATA_VID) == vid) {\n\t\t\tret = dwmac4_write_vlan_filter(dev, hw, i, 0);\n\n\t\t\tif (!ret)\n\t\t\t\thw->vlan_filter[i] = 0;\n\t\t\telse\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void dwmac4_restore_hw_vlan_rx_fltr(struct net_device *dev,\n\t\t\t\t\t   struct mac_device_info *hw)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\tu32 hash;\n\tu32 val;\n\tint i;\n\n\t \n\tif (hw->num_vlan == 1) {\n\t\tdwmac4_write_single_vlan(dev, hw->vlan_filter[0]);\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0; i < hw->num_vlan; i++) {\n\t\tif (hw->vlan_filter[i] & GMAC_VLAN_TAG_DATA_VEN) {\n\t\t\tval = hw->vlan_filter[i];\n\t\t\tdwmac4_write_vlan_filter(dev, hw, i, val);\n\t\t}\n\t}\n\n\thash = readl(ioaddr + GMAC_VLAN_HASH_TABLE);\n\tif (hash & GMAC_VLAN_VLHT) {\n\t\tvalue = readl(ioaddr + GMAC_VLAN_TAG);\n\t\tvalue |= GMAC_VLAN_VTHM;\n\t\twritel(value, ioaddr + GMAC_VLAN_TAG);\n\t}\n}\n\nstatic void dwmac4_set_filter(struct mac_device_info *hw,\n\t\t\t      struct net_device *dev)\n{\n\tvoid __iomem *ioaddr = (void __iomem *)dev->base_addr;\n\tint numhashregs = (hw->multicast_filter_bins >> 5);\n\tint mcbitslog2 = hw->mcast_bits_log2;\n\tunsigned int value;\n\tu32 mc_filter[8];\n\tint i;\n\n\tmemset(mc_filter, 0, sizeof(mc_filter));\n\n\tvalue = readl(ioaddr + GMAC_PACKET_FILTER);\n\tvalue &= ~GMAC_PACKET_FILTER_HMC;\n\tvalue &= ~GMAC_PACKET_FILTER_HPF;\n\tvalue &= ~GMAC_PACKET_FILTER_PCF;\n\tvalue &= ~GMAC_PACKET_FILTER_PM;\n\tvalue &= ~GMAC_PACKET_FILTER_PR;\n\tvalue &= ~GMAC_PACKET_FILTER_RA;\n\tif (dev->flags & IFF_PROMISC) {\n\t\t \n\t\tif (hw->vlan_fail_q_en) {\n\t\t\tvalue = readl(ioaddr + GMAC_RXQ_CTRL4);\n\t\t\tvalue &= ~GMAC_RXQCTRL_VFFQ_MASK;\n\t\t\tvalue |= GMAC_RXQCTRL_VFFQE |\n\t\t\t\t (hw->vlan_fail_q << GMAC_RXQCTRL_VFFQ_SHIFT);\n\t\t\twritel(value, ioaddr + GMAC_RXQ_CTRL4);\n\t\t\tvalue = GMAC_PACKET_FILTER_PR | GMAC_PACKET_FILTER_RA;\n\t\t} else {\n\t\t\tvalue = GMAC_PACKET_FILTER_PR | GMAC_PACKET_FILTER_PCF;\n\t\t}\n\n\t} else if ((dev->flags & IFF_ALLMULTI) ||\n\t\t   (netdev_mc_count(dev) > hw->multicast_filter_bins)) {\n\t\t \n\t\tvalue |= GMAC_PACKET_FILTER_PM;\n\t\t \n\t\tmemset(mc_filter, 0xff, sizeof(mc_filter));\n\t} else if (!netdev_mc_empty(dev) && (dev->flags & IFF_MULTICAST)) {\n\t\tstruct netdev_hw_addr *ha;\n\n\t\t \n\t\tvalue |= GMAC_PACKET_FILTER_HMC;\n\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\t \n\t\t\tu32 bit_nr = bitrev32(~crc32_le(~0, ha->addr,\n\t\t\t\t\tETH_ALEN)) >> (32 - mcbitslog2);\n\t\t\t \n\t\t\tmc_filter[bit_nr >> 5] |= (1 << (bit_nr & 0x1f));\n\t\t}\n\t}\n\n\tfor (i = 0; i < numhashregs; i++)\n\t\twritel(mc_filter[i], ioaddr + GMAC_HASH_TAB(i));\n\n\tvalue |= GMAC_PACKET_FILTER_HPF;\n\n\t \n\tif (netdev_uc_count(dev) > hw->unicast_filter_entries) {\n\t\t \n\t\tvalue |= GMAC_PACKET_FILTER_PR;\n\t} else {\n\t\tstruct netdev_hw_addr *ha;\n\t\tint reg = 1;\n\n\t\tnetdev_for_each_uc_addr(ha, dev) {\n\t\t\tdwmac4_set_umac_addr(hw, ha->addr, reg);\n\t\t\treg++;\n\t\t}\n\n\t\twhile (reg < GMAC_MAX_PERFECT_ADDRESSES) {\n\t\t\twritel(0, ioaddr + GMAC_ADDR_HIGH(reg));\n\t\t\twritel(0, ioaddr + GMAC_ADDR_LOW(reg));\n\t\t\treg++;\n\t\t}\n\t}\n\n\t \n\tif (dev->flags & IFF_PROMISC && !hw->vlan_fail_q_en)\n\t\tvalue &= ~GMAC_PACKET_FILTER_VTFE;\n\telse if (dev->features & NETIF_F_HW_VLAN_CTAG_FILTER)\n\t\tvalue |= GMAC_PACKET_FILTER_VTFE;\n\n\twritel(value, ioaddr + GMAC_PACKET_FILTER);\n}\n\nstatic void dwmac4_flow_ctrl(struct mac_device_info *hw, unsigned int duplex,\n\t\t\t     unsigned int fc, unsigned int pause_time,\n\t\t\t     u32 tx_cnt)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tunsigned int flow = 0;\n\tu32 queue = 0;\n\n\tpr_debug(\"GMAC Flow-Control:\\n\");\n\tif (fc & FLOW_RX) {\n\t\tpr_debug(\"\\tReceive Flow-Control ON\\n\");\n\t\tflow |= GMAC_RX_FLOW_CTRL_RFE;\n\t} else {\n\t\tpr_debug(\"\\tReceive Flow-Control OFF\\n\");\n\t}\n\twritel(flow, ioaddr + GMAC_RX_FLOW_CTRL);\n\n\tif (fc & FLOW_TX) {\n\t\tpr_debug(\"\\tTransmit Flow-Control ON\\n\");\n\n\t\tif (duplex)\n\t\t\tpr_debug(\"\\tduplex mode: PAUSE %d\\n\", pause_time);\n\n\t\tfor (queue = 0; queue < tx_cnt; queue++) {\n\t\t\tflow = GMAC_TX_FLOW_CTRL_TFE;\n\n\t\t\tif (duplex)\n\t\t\t\tflow |=\n\t\t\t\t(pause_time << GMAC_TX_FLOW_CTRL_PT_SHIFT);\n\n\t\t\twritel(flow, ioaddr + GMAC_QX_TX_FLOW_CTRL(queue));\n\t\t}\n\t} else {\n\t\tfor (queue = 0; queue < tx_cnt; queue++)\n\t\t\twritel(0, ioaddr + GMAC_QX_TX_FLOW_CTRL(queue));\n\t}\n}\n\nstatic void dwmac4_ctrl_ane(void __iomem *ioaddr, bool ane, bool srgmi_ral,\n\t\t\t    bool loopback)\n{\n\tdwmac_ctrl_ane(ioaddr, GMAC_PCS_BASE, ane, srgmi_ral, loopback);\n}\n\nstatic void dwmac4_rane(void __iomem *ioaddr, bool restart)\n{\n\tdwmac_rane(ioaddr, GMAC_PCS_BASE, restart);\n}\n\nstatic void dwmac4_get_adv_lp(void __iomem *ioaddr, struct rgmii_adv *adv)\n{\n\tdwmac_get_adv_lp(ioaddr, GMAC_PCS_BASE, adv);\n}\n\n \nstatic void dwmac4_phystatus(void __iomem *ioaddr, struct stmmac_extra_stats *x)\n{\n\tu32 status;\n\n\tstatus = readl(ioaddr + GMAC_PHYIF_CONTROL_STATUS);\n\tx->irq_rgmii_n++;\n\n\t \n\tif (status & GMAC_PHYIF_CTRLSTATUS_LNKSTS) {\n\t\tint speed_value;\n\n\t\tx->pcs_link = 1;\n\n\t\tspeed_value = ((status & GMAC_PHYIF_CTRLSTATUS_SPEED) >>\n\t\t\t       GMAC_PHYIF_CTRLSTATUS_SPEED_SHIFT);\n\t\tif (speed_value == GMAC_PHYIF_CTRLSTATUS_SPEED_125)\n\t\t\tx->pcs_speed = SPEED_1000;\n\t\telse if (speed_value == GMAC_PHYIF_CTRLSTATUS_SPEED_25)\n\t\t\tx->pcs_speed = SPEED_100;\n\t\telse\n\t\t\tx->pcs_speed = SPEED_10;\n\n\t\tx->pcs_duplex = (status & GMAC_PHYIF_CTRLSTATUS_LNKMOD_MASK);\n\n\t\tpr_info(\"Link is Up - %d/%s\\n\", (int)x->pcs_speed,\n\t\t\tx->pcs_duplex ? \"Full\" : \"Half\");\n\t} else {\n\t\tx->pcs_link = 0;\n\t\tpr_info(\"Link is Down\\n\");\n\t}\n}\n\nstatic int dwmac4_irq_mtl_status(struct stmmac_priv *priv,\n\t\t\t\t struct mac_device_info *hw, u32 chan)\n{\n\tconst struct dwmac4_addrs *dwmac4_addrs = priv->plat->dwmac4_addrs;\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 mtl_int_qx_status;\n\tint ret = 0;\n\n\tmtl_int_qx_status = readl(ioaddr + MTL_INT_STATUS);\n\n\t \n\tif (mtl_int_qx_status & MTL_INT_QX(chan)) {\n\t\t \n\t\tu32 status = readl(ioaddr + MTL_CHAN_INT_CTRL(dwmac4_addrs,\n\t\t\t\t\t\t\t      chan));\n\n\t\tif (status & MTL_RX_OVERFLOW_INT) {\n\t\t\t \n\t\t\twritel(status | MTL_RX_OVERFLOW_INT,\n\t\t\t       ioaddr + MTL_CHAN_INT_CTRL(dwmac4_addrs, chan));\n\t\t\tret = CORE_IRQ_MTL_RX_OVERFLOW;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int dwmac4_irq_status(struct mac_device_info *hw,\n\t\t\t     struct stmmac_extra_stats *x)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 intr_status = readl(ioaddr + GMAC_INT_STATUS);\n\tu32 intr_enable = readl(ioaddr + GMAC_INT_EN);\n\tint ret = 0;\n\n\t \n\tintr_status &= intr_enable;\n\n\t \n\tif ((intr_status & mmc_tx_irq))\n\t\tx->mmc_tx_irq_n++;\n\tif (unlikely(intr_status & mmc_rx_irq))\n\t\tx->mmc_rx_irq_n++;\n\tif (unlikely(intr_status & mmc_rx_csum_offload_irq))\n\t\tx->mmc_rx_csum_offload_irq_n++;\n\t \n\tif (unlikely(intr_status & pmt_irq)) {\n\t\treadl(ioaddr + GMAC_PMT);\n\t\tx->irq_receive_pmt_irq_n++;\n\t}\n\n\t \n\tif (intr_status & lpi_irq) {\n\t\t \n\t\tu32 status = readl(ioaddr + GMAC4_LPI_CTRL_STATUS);\n\n\t\tif (status & GMAC4_LPI_CTRL_STATUS_TLPIEN) {\n\t\t\tret |= CORE_IRQ_TX_PATH_IN_LPI_MODE;\n\t\t\tx->irq_tx_path_in_lpi_mode_n++;\n\t\t}\n\t\tif (status & GMAC4_LPI_CTRL_STATUS_TLPIEX) {\n\t\t\tret |= CORE_IRQ_TX_PATH_EXIT_LPI_MODE;\n\t\t\tx->irq_tx_path_exit_lpi_mode_n++;\n\t\t}\n\t\tif (status & GMAC4_LPI_CTRL_STATUS_RLPIEN)\n\t\t\tx->irq_rx_path_in_lpi_mode_n++;\n\t\tif (status & GMAC4_LPI_CTRL_STATUS_RLPIEX)\n\t\t\tx->irq_rx_path_exit_lpi_mode_n++;\n\t}\n\n\tdwmac_pcs_isr(ioaddr, GMAC_PCS_BASE, intr_status, x);\n\tif (intr_status & PCS_RGSMIIIS_IRQ)\n\t\tdwmac4_phystatus(ioaddr, x);\n\n\treturn ret;\n}\n\nstatic void dwmac4_debug(struct stmmac_priv *priv, void __iomem *ioaddr,\n\t\t\t struct stmmac_extra_stats *x,\n\t\t\t u32 rx_queues, u32 tx_queues)\n{\n\tconst struct dwmac4_addrs *dwmac4_addrs = priv->plat->dwmac4_addrs;\n\tu32 value;\n\tu32 queue;\n\n\tfor (queue = 0; queue < tx_queues; queue++) {\n\t\tvalue = readl(ioaddr + MTL_CHAN_TX_DEBUG(dwmac4_addrs, queue));\n\n\t\tif (value & MTL_DEBUG_TXSTSFSTS)\n\t\t\tx->mtl_tx_status_fifo_full++;\n\t\tif (value & MTL_DEBUG_TXFSTS)\n\t\t\tx->mtl_tx_fifo_not_empty++;\n\t\tif (value & MTL_DEBUG_TWCSTS)\n\t\t\tx->mmtl_fifo_ctrl++;\n\t\tif (value & MTL_DEBUG_TRCSTS_MASK) {\n\t\t\tu32 trcsts = (value & MTL_DEBUG_TRCSTS_MASK)\n\t\t\t\t     >> MTL_DEBUG_TRCSTS_SHIFT;\n\t\t\tif (trcsts == MTL_DEBUG_TRCSTS_WRITE)\n\t\t\t\tx->mtl_tx_fifo_read_ctrl_write++;\n\t\t\telse if (trcsts == MTL_DEBUG_TRCSTS_TXW)\n\t\t\t\tx->mtl_tx_fifo_read_ctrl_wait++;\n\t\t\telse if (trcsts == MTL_DEBUG_TRCSTS_READ)\n\t\t\t\tx->mtl_tx_fifo_read_ctrl_read++;\n\t\t\telse\n\t\t\t\tx->mtl_tx_fifo_read_ctrl_idle++;\n\t\t}\n\t\tif (value & MTL_DEBUG_TXPAUSED)\n\t\t\tx->mac_tx_in_pause++;\n\t}\n\n\tfor (queue = 0; queue < rx_queues; queue++) {\n\t\tvalue = readl(ioaddr + MTL_CHAN_RX_DEBUG(dwmac4_addrs, queue));\n\n\t\tif (value & MTL_DEBUG_RXFSTS_MASK) {\n\t\t\tu32 rxfsts = (value & MTL_DEBUG_RXFSTS_MASK)\n\t\t\t\t     >> MTL_DEBUG_RRCSTS_SHIFT;\n\n\t\t\tif (rxfsts == MTL_DEBUG_RXFSTS_FULL)\n\t\t\t\tx->mtl_rx_fifo_fill_level_full++;\n\t\t\telse if (rxfsts == MTL_DEBUG_RXFSTS_AT)\n\t\t\t\tx->mtl_rx_fifo_fill_above_thresh++;\n\t\t\telse if (rxfsts == MTL_DEBUG_RXFSTS_BT)\n\t\t\t\tx->mtl_rx_fifo_fill_below_thresh++;\n\t\t\telse\n\t\t\t\tx->mtl_rx_fifo_fill_level_empty++;\n\t\t}\n\t\tif (value & MTL_DEBUG_RRCSTS_MASK) {\n\t\t\tu32 rrcsts = (value & MTL_DEBUG_RRCSTS_MASK) >>\n\t\t\t\t     MTL_DEBUG_RRCSTS_SHIFT;\n\n\t\t\tif (rrcsts == MTL_DEBUG_RRCSTS_FLUSH)\n\t\t\t\tx->mtl_rx_fifo_read_ctrl_flush++;\n\t\t\telse if (rrcsts == MTL_DEBUG_RRCSTS_RSTAT)\n\t\t\t\tx->mtl_rx_fifo_read_ctrl_read_data++;\n\t\t\telse if (rrcsts == MTL_DEBUG_RRCSTS_RDATA)\n\t\t\t\tx->mtl_rx_fifo_read_ctrl_status++;\n\t\t\telse\n\t\t\t\tx->mtl_rx_fifo_read_ctrl_idle++;\n\t\t}\n\t\tif (value & MTL_DEBUG_RWCSTS)\n\t\t\tx->mtl_rx_fifo_ctrl_active++;\n\t}\n\n\t \n\tvalue = readl(ioaddr + GMAC_DEBUG);\n\n\tif (value & GMAC_DEBUG_TFCSTS_MASK) {\n\t\tu32 tfcsts = (value & GMAC_DEBUG_TFCSTS_MASK)\n\t\t\t      >> GMAC_DEBUG_TFCSTS_SHIFT;\n\n\t\tif (tfcsts == GMAC_DEBUG_TFCSTS_XFER)\n\t\t\tx->mac_tx_frame_ctrl_xfer++;\n\t\telse if (tfcsts == GMAC_DEBUG_TFCSTS_GEN_PAUSE)\n\t\t\tx->mac_tx_frame_ctrl_pause++;\n\t\telse if (tfcsts == GMAC_DEBUG_TFCSTS_WAIT)\n\t\t\tx->mac_tx_frame_ctrl_wait++;\n\t\telse\n\t\t\tx->mac_tx_frame_ctrl_idle++;\n\t}\n\tif (value & GMAC_DEBUG_TPESTS)\n\t\tx->mac_gmii_tx_proto_engine++;\n\tif (value & GMAC_DEBUG_RFCFCSTS_MASK)\n\t\tx->mac_rx_frame_ctrl_fifo = (value & GMAC_DEBUG_RFCFCSTS_MASK)\n\t\t\t\t\t    >> GMAC_DEBUG_RFCFCSTS_SHIFT;\n\tif (value & GMAC_DEBUG_RPESTS)\n\t\tx->mac_gmii_rx_proto_engine++;\n}\n\nstatic void dwmac4_set_mac_loopback(void __iomem *ioaddr, bool enable)\n{\n\tu32 value = readl(ioaddr + GMAC_CONFIG);\n\n\tif (enable)\n\t\tvalue |= GMAC_CONFIG_LM;\n\telse\n\t\tvalue &= ~GMAC_CONFIG_LM;\n\n\twritel(value, ioaddr + GMAC_CONFIG);\n}\n\nstatic void dwmac4_update_vlan_hash(struct mac_device_info *hw, u32 hash,\n\t\t\t\t    __le16 perfect_match, bool is_double)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\twritel(hash, ioaddr + GMAC_VLAN_HASH_TABLE);\n\n\tvalue = readl(ioaddr + GMAC_VLAN_TAG);\n\n\tif (hash) {\n\t\tvalue |= GMAC_VLAN_VTHM | GMAC_VLAN_ETV;\n\t\tif (is_double) {\n\t\t\tvalue |= GMAC_VLAN_EDVLP;\n\t\t\tvalue |= GMAC_VLAN_ESVL;\n\t\t\tvalue |= GMAC_VLAN_DOVLTC;\n\t\t}\n\n\t\twritel(value, ioaddr + GMAC_VLAN_TAG);\n\t} else if (perfect_match) {\n\t\tu32 value = GMAC_VLAN_ETV;\n\n\t\tif (is_double) {\n\t\t\tvalue |= GMAC_VLAN_EDVLP;\n\t\t\tvalue |= GMAC_VLAN_ESVL;\n\t\t\tvalue |= GMAC_VLAN_DOVLTC;\n\t\t}\n\n\t\twritel(value | perfect_match, ioaddr + GMAC_VLAN_TAG);\n\t} else {\n\t\tvalue &= ~(GMAC_VLAN_VTHM | GMAC_VLAN_ETV);\n\t\tvalue &= ~(GMAC_VLAN_EDVLP | GMAC_VLAN_ESVL);\n\t\tvalue &= ~GMAC_VLAN_DOVLTC;\n\t\tvalue &= ~GMAC_VLAN_VID;\n\n\t\twritel(value, ioaddr + GMAC_VLAN_TAG);\n\t}\n}\n\nstatic void dwmac4_sarc_configure(void __iomem *ioaddr, int val)\n{\n\tu32 value = readl(ioaddr + GMAC_CONFIG);\n\n\tvalue &= ~GMAC_CONFIG_SARC;\n\tvalue |= val << GMAC_CONFIG_SARC_SHIFT;\n\n\twritel(value, ioaddr + GMAC_CONFIG);\n}\n\nstatic void dwmac4_enable_vlan(struct mac_device_info *hw, u32 type)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\tvalue = readl(ioaddr + GMAC_VLAN_INCL);\n\tvalue |= GMAC_VLAN_VLTI;\n\tvalue |= GMAC_VLAN_CSVL;  \n\tvalue &= ~GMAC_VLAN_VLC;\n\tvalue |= (type << GMAC_VLAN_VLC_SHIFT) & GMAC_VLAN_VLC;\n\twritel(value, ioaddr + GMAC_VLAN_INCL);\n}\n\nstatic void dwmac4_set_arp_offload(struct mac_device_info *hw, bool en,\n\t\t\t\t   u32 addr)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\twritel(addr, ioaddr + GMAC_ARP_ADDR);\n\n\tvalue = readl(ioaddr + GMAC_CONFIG);\n\tif (en)\n\t\tvalue |= GMAC_CONFIG_ARPEN;\n\telse\n\t\tvalue &= ~GMAC_CONFIG_ARPEN;\n\twritel(value, ioaddr + GMAC_CONFIG);\n}\n\nstatic int dwmac4_config_l3_filter(struct mac_device_info *hw, u32 filter_no,\n\t\t\t\t   bool en, bool ipv6, bool sa, bool inv,\n\t\t\t\t   u32 match)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\tvalue = readl(ioaddr + GMAC_PACKET_FILTER);\n\tvalue |= GMAC_PACKET_FILTER_IPFE;\n\twritel(value, ioaddr + GMAC_PACKET_FILTER);\n\n\tvalue = readl(ioaddr + GMAC_L3L4_CTRL(filter_no));\n\n\t \n\tif (ipv6) {\n\t\tvalue |= GMAC_L3PEN0;\n\t\tvalue &= ~(GMAC_L3SAM0 | GMAC_L3SAIM0);\n\t\tvalue &= ~(GMAC_L3DAM0 | GMAC_L3DAIM0);\n\t\tif (sa) {\n\t\t\tvalue |= GMAC_L3SAM0;\n\t\t\tif (inv)\n\t\t\t\tvalue |= GMAC_L3SAIM0;\n\t\t} else {\n\t\t\tvalue |= GMAC_L3DAM0;\n\t\t\tif (inv)\n\t\t\t\tvalue |= GMAC_L3DAIM0;\n\t\t}\n\t} else {\n\t\tvalue &= ~GMAC_L3PEN0;\n\t\tif (sa) {\n\t\t\tvalue |= GMAC_L3SAM0;\n\t\t\tif (inv)\n\t\t\t\tvalue |= GMAC_L3SAIM0;\n\t\t} else {\n\t\t\tvalue |= GMAC_L3DAM0;\n\t\t\tif (inv)\n\t\t\t\tvalue |= GMAC_L3DAIM0;\n\t\t}\n\t}\n\n\twritel(value, ioaddr + GMAC_L3L4_CTRL(filter_no));\n\n\tif (sa) {\n\t\twritel(match, ioaddr + GMAC_L3_ADDR0(filter_no));\n\t} else {\n\t\twritel(match, ioaddr + GMAC_L3_ADDR1(filter_no));\n\t}\n\n\tif (!en)\n\t\twritel(0, ioaddr + GMAC_L3L4_CTRL(filter_no));\n\n\treturn 0;\n}\n\nstatic int dwmac4_config_l4_filter(struct mac_device_info *hw, u32 filter_no,\n\t\t\t\t   bool en, bool udp, bool sa, bool inv,\n\t\t\t\t   u32 match)\n{\n\tvoid __iomem *ioaddr = hw->pcsr;\n\tu32 value;\n\n\tvalue = readl(ioaddr + GMAC_PACKET_FILTER);\n\tvalue |= GMAC_PACKET_FILTER_IPFE;\n\twritel(value, ioaddr + GMAC_PACKET_FILTER);\n\n\tvalue = readl(ioaddr + GMAC_L3L4_CTRL(filter_no));\n\tif (udp) {\n\t\tvalue |= GMAC_L4PEN0;\n\t} else {\n\t\tvalue &= ~GMAC_L4PEN0;\n\t}\n\n\tvalue &= ~(GMAC_L4SPM0 | GMAC_L4SPIM0);\n\tvalue &= ~(GMAC_L4DPM0 | GMAC_L4DPIM0);\n\tif (sa) {\n\t\tvalue |= GMAC_L4SPM0;\n\t\tif (inv)\n\t\t\tvalue |= GMAC_L4SPIM0;\n\t} else {\n\t\tvalue |= GMAC_L4DPM0;\n\t\tif (inv)\n\t\t\tvalue |= GMAC_L4DPIM0;\n\t}\n\n\twritel(value, ioaddr + GMAC_L3L4_CTRL(filter_no));\n\n\tif (sa) {\n\t\tvalue = match & GMAC_L4SP0;\n\t} else {\n\t\tvalue = (match << GMAC_L4DP0_SHIFT) & GMAC_L4DP0;\n\t}\n\n\twritel(value, ioaddr + GMAC_L4_ADDR(filter_no));\n\n\tif (!en)\n\t\twritel(0, ioaddr + GMAC_L3L4_CTRL(filter_no));\n\n\treturn 0;\n}\n\nconst struct stmmac_ops dwmac4_ops = {\n\t.core_init = dwmac4_core_init,\n\t.phylink_get_caps = dwmac4_phylink_get_caps,\n\t.set_mac = stmmac_set_mac,\n\t.rx_ipc = dwmac4_rx_ipc_enable,\n\t.rx_queue_enable = dwmac4_rx_queue_enable,\n\t.rx_queue_prio = dwmac4_rx_queue_priority,\n\t.tx_queue_prio = dwmac4_tx_queue_priority,\n\t.rx_queue_routing = dwmac4_rx_queue_routing,\n\t.prog_mtl_rx_algorithms = dwmac4_prog_mtl_rx_algorithms,\n\t.prog_mtl_tx_algorithms = dwmac4_prog_mtl_tx_algorithms,\n\t.set_mtl_tx_queue_weight = dwmac4_set_mtl_tx_queue_weight,\n\t.map_mtl_to_dma = dwmac4_map_mtl_dma,\n\t.config_cbs = dwmac4_config_cbs,\n\t.dump_regs = dwmac4_dump_regs,\n\t.host_irq_status = dwmac4_irq_status,\n\t.host_mtl_irq_status = dwmac4_irq_mtl_status,\n\t.flow_ctrl = dwmac4_flow_ctrl,\n\t.pmt = dwmac4_pmt,\n\t.set_umac_addr = dwmac4_set_umac_addr,\n\t.get_umac_addr = dwmac4_get_umac_addr,\n\t.set_eee_mode = dwmac4_set_eee_mode,\n\t.reset_eee_mode = dwmac4_reset_eee_mode,\n\t.set_eee_lpi_entry_timer = dwmac4_set_eee_lpi_entry_timer,\n\t.set_eee_timer = dwmac4_set_eee_timer,\n\t.set_eee_pls = dwmac4_set_eee_pls,\n\t.pcs_ctrl_ane = dwmac4_ctrl_ane,\n\t.pcs_rane = dwmac4_rane,\n\t.pcs_get_adv_lp = dwmac4_get_adv_lp,\n\t.debug = dwmac4_debug,\n\t.set_filter = dwmac4_set_filter,\n\t.set_mac_loopback = dwmac4_set_mac_loopback,\n\t.update_vlan_hash = dwmac4_update_vlan_hash,\n\t.sarc_configure = dwmac4_sarc_configure,\n\t.enable_vlan = dwmac4_enable_vlan,\n\t.set_arp_offload = dwmac4_set_arp_offload,\n\t.config_l3_filter = dwmac4_config_l3_filter,\n\t.config_l4_filter = dwmac4_config_l4_filter,\n\t.add_hw_vlan_rx_fltr = dwmac4_add_hw_vlan_rx_fltr,\n\t.del_hw_vlan_rx_fltr = dwmac4_del_hw_vlan_rx_fltr,\n\t.restore_hw_vlan_rx_fltr = dwmac4_restore_hw_vlan_rx_fltr,\n};\n\nconst struct stmmac_ops dwmac410_ops = {\n\t.core_init = dwmac4_core_init,\n\t.phylink_get_caps = dwmac4_phylink_get_caps,\n\t.set_mac = stmmac_dwmac4_set_mac,\n\t.rx_ipc = dwmac4_rx_ipc_enable,\n\t.rx_queue_enable = dwmac4_rx_queue_enable,\n\t.rx_queue_prio = dwmac4_rx_queue_priority,\n\t.tx_queue_prio = dwmac4_tx_queue_priority,\n\t.rx_queue_routing = dwmac4_rx_queue_routing,\n\t.prog_mtl_rx_algorithms = dwmac4_prog_mtl_rx_algorithms,\n\t.prog_mtl_tx_algorithms = dwmac4_prog_mtl_tx_algorithms,\n\t.set_mtl_tx_queue_weight = dwmac4_set_mtl_tx_queue_weight,\n\t.map_mtl_to_dma = dwmac4_map_mtl_dma,\n\t.config_cbs = dwmac4_config_cbs,\n\t.dump_regs = dwmac4_dump_regs,\n\t.host_irq_status = dwmac4_irq_status,\n\t.host_mtl_irq_status = dwmac4_irq_mtl_status,\n\t.flow_ctrl = dwmac4_flow_ctrl,\n\t.pmt = dwmac4_pmt,\n\t.set_umac_addr = dwmac4_set_umac_addr,\n\t.get_umac_addr = dwmac4_get_umac_addr,\n\t.set_eee_mode = dwmac4_set_eee_mode,\n\t.reset_eee_mode = dwmac4_reset_eee_mode,\n\t.set_eee_lpi_entry_timer = dwmac4_set_eee_lpi_entry_timer,\n\t.set_eee_timer = dwmac4_set_eee_timer,\n\t.set_eee_pls = dwmac4_set_eee_pls,\n\t.pcs_ctrl_ane = dwmac4_ctrl_ane,\n\t.pcs_rane = dwmac4_rane,\n\t.pcs_get_adv_lp = dwmac4_get_adv_lp,\n\t.debug = dwmac4_debug,\n\t.set_filter = dwmac4_set_filter,\n\t.flex_pps_config = dwmac5_flex_pps_config,\n\t.set_mac_loopback = dwmac4_set_mac_loopback,\n\t.update_vlan_hash = dwmac4_update_vlan_hash,\n\t.sarc_configure = dwmac4_sarc_configure,\n\t.enable_vlan = dwmac4_enable_vlan,\n\t.set_arp_offload = dwmac4_set_arp_offload,\n\t.config_l3_filter = dwmac4_config_l3_filter,\n\t.config_l4_filter = dwmac4_config_l4_filter,\n\t.est_configure = dwmac5_est_configure,\n\t.est_irq_status = dwmac5_est_irq_status,\n\t.fpe_configure = dwmac5_fpe_configure,\n\t.fpe_send_mpacket = dwmac5_fpe_send_mpacket,\n\t.fpe_irq_status = dwmac5_fpe_irq_status,\n\t.add_hw_vlan_rx_fltr = dwmac4_add_hw_vlan_rx_fltr,\n\t.del_hw_vlan_rx_fltr = dwmac4_del_hw_vlan_rx_fltr,\n\t.restore_hw_vlan_rx_fltr = dwmac4_restore_hw_vlan_rx_fltr,\n};\n\nconst struct stmmac_ops dwmac510_ops = {\n\t.core_init = dwmac4_core_init,\n\t.phylink_get_caps = dwmac4_phylink_get_caps,\n\t.set_mac = stmmac_dwmac4_set_mac,\n\t.rx_ipc = dwmac4_rx_ipc_enable,\n\t.rx_queue_enable = dwmac4_rx_queue_enable,\n\t.rx_queue_prio = dwmac4_rx_queue_priority,\n\t.tx_queue_prio = dwmac4_tx_queue_priority,\n\t.rx_queue_routing = dwmac4_rx_queue_routing,\n\t.prog_mtl_rx_algorithms = dwmac4_prog_mtl_rx_algorithms,\n\t.prog_mtl_tx_algorithms = dwmac4_prog_mtl_tx_algorithms,\n\t.set_mtl_tx_queue_weight = dwmac4_set_mtl_tx_queue_weight,\n\t.map_mtl_to_dma = dwmac4_map_mtl_dma,\n\t.config_cbs = dwmac4_config_cbs,\n\t.dump_regs = dwmac4_dump_regs,\n\t.host_irq_status = dwmac4_irq_status,\n\t.host_mtl_irq_status = dwmac4_irq_mtl_status,\n\t.flow_ctrl = dwmac4_flow_ctrl,\n\t.pmt = dwmac4_pmt,\n\t.set_umac_addr = dwmac4_set_umac_addr,\n\t.get_umac_addr = dwmac4_get_umac_addr,\n\t.set_eee_mode = dwmac4_set_eee_mode,\n\t.reset_eee_mode = dwmac4_reset_eee_mode,\n\t.set_eee_lpi_entry_timer = dwmac4_set_eee_lpi_entry_timer,\n\t.set_eee_timer = dwmac4_set_eee_timer,\n\t.set_eee_pls = dwmac4_set_eee_pls,\n\t.pcs_ctrl_ane = dwmac4_ctrl_ane,\n\t.pcs_rane = dwmac4_rane,\n\t.pcs_get_adv_lp = dwmac4_get_adv_lp,\n\t.debug = dwmac4_debug,\n\t.set_filter = dwmac4_set_filter,\n\t.safety_feat_config = dwmac5_safety_feat_config,\n\t.safety_feat_irq_status = dwmac5_safety_feat_irq_status,\n\t.safety_feat_dump = dwmac5_safety_feat_dump,\n\t.rxp_config = dwmac5_rxp_config,\n\t.flex_pps_config = dwmac5_flex_pps_config,\n\t.set_mac_loopback = dwmac4_set_mac_loopback,\n\t.update_vlan_hash = dwmac4_update_vlan_hash,\n\t.sarc_configure = dwmac4_sarc_configure,\n\t.enable_vlan = dwmac4_enable_vlan,\n\t.set_arp_offload = dwmac4_set_arp_offload,\n\t.config_l3_filter = dwmac4_config_l3_filter,\n\t.config_l4_filter = dwmac4_config_l4_filter,\n\t.est_configure = dwmac5_est_configure,\n\t.est_irq_status = dwmac5_est_irq_status,\n\t.fpe_configure = dwmac5_fpe_configure,\n\t.fpe_send_mpacket = dwmac5_fpe_send_mpacket,\n\t.fpe_irq_status = dwmac5_fpe_irq_status,\n\t.add_hw_vlan_rx_fltr = dwmac4_add_hw_vlan_rx_fltr,\n\t.del_hw_vlan_rx_fltr = dwmac4_del_hw_vlan_rx_fltr,\n\t.restore_hw_vlan_rx_fltr = dwmac4_restore_hw_vlan_rx_fltr,\n};\n\nstatic u32 dwmac4_get_num_vlan(void __iomem *ioaddr)\n{\n\tu32 val, num_vlan;\n\n\tval = readl(ioaddr + GMAC_HW_FEATURE3);\n\tswitch (val & GMAC_HW_FEAT_NRVF) {\n\tcase 0:\n\t\tnum_vlan = 1;\n\t\tbreak;\n\tcase 1:\n\t\tnum_vlan = 4;\n\t\tbreak;\n\tcase 2:\n\t\tnum_vlan = 8;\n\t\tbreak;\n\tcase 3:\n\t\tnum_vlan = 16;\n\t\tbreak;\n\tcase 4:\n\t\tnum_vlan = 24;\n\t\tbreak;\n\tcase 5:\n\t\tnum_vlan = 32;\n\t\tbreak;\n\tdefault:\n\t\tnum_vlan = 1;\n\t}\n\n\treturn num_vlan;\n}\n\nint dwmac4_setup(struct stmmac_priv *priv)\n{\n\tstruct mac_device_info *mac = priv->hw;\n\n\tdev_info(priv->device, \"\\tDWMAC4/5\\n\");\n\n\tpriv->dev->priv_flags |= IFF_UNICAST_FLT;\n\tmac->pcsr = priv->ioaddr;\n\tmac->multicast_filter_bins = priv->plat->multicast_filter_bins;\n\tmac->unicast_filter_entries = priv->plat->unicast_filter_entries;\n\tmac->mcast_bits_log2 = 0;\n\n\tif (mac->multicast_filter_bins)\n\t\tmac->mcast_bits_log2 = ilog2(mac->multicast_filter_bins);\n\n\tmac->link.duplex = GMAC_CONFIG_DM;\n\tmac->link.speed10 = GMAC_CONFIG_PS;\n\tmac->link.speed100 = GMAC_CONFIG_FES | GMAC_CONFIG_PS;\n\tmac->link.speed1000 = 0;\n\tmac->link.speed2500 = GMAC_CONFIG_FES;\n\tmac->link.speed_mask = GMAC_CONFIG_FES | GMAC_CONFIG_PS;\n\tmac->mii.addr = GMAC_MDIO_ADDR;\n\tmac->mii.data = GMAC_MDIO_DATA;\n\tmac->mii.addr_shift = 21;\n\tmac->mii.addr_mask = GENMASK(25, 21);\n\tmac->mii.reg_shift = 16;\n\tmac->mii.reg_mask = GENMASK(20, 16);\n\tmac->mii.clk_csr_shift = 8;\n\tmac->mii.clk_csr_mask = GENMASK(11, 8);\n\tmac->num_vlan = dwmac4_get_num_vlan(priv->ioaddr);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}