{
  "module_name": "stmmac_ptp.c",
  "hash_id": "5267fabdc5ab7ee4a526d40df288878997038398da1c9c4708809f3970ed6bcc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.c",
  "human_readable_source": "\n \n#include \"stmmac.h\"\n#include \"stmmac_ptp.h\"\n#include \"dwmac4.h\"\n\n \nstatic int stmmac_adjust_freq(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct stmmac_priv *priv =\n\t    container_of(ptp, struct stmmac_priv, ptp_clock_ops);\n\tunsigned long flags;\n\tu32 addend;\n\n\taddend = adjust_by_scaled_ppm(priv->default_addend, scaled_ppm);\n\n\twrite_lock_irqsave(&priv->ptp_lock, flags);\n\tstmmac_config_addend(priv, priv->ptpaddr, addend);\n\twrite_unlock_irqrestore(&priv->ptp_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int stmmac_adjust_time(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct stmmac_priv *priv =\n\t    container_of(ptp, struct stmmac_priv, ptp_clock_ops);\n\tunsigned long flags;\n\tu32 sec, nsec;\n\tu32 quotient, reminder;\n\tint neg_adj = 0;\n\tbool xmac, est_rst = false;\n\tint ret;\n\n\txmac = priv->plat->has_gmac4 || priv->plat->has_xgmac;\n\n\tif (delta < 0) {\n\t\tneg_adj = 1;\n\t\tdelta = -delta;\n\t}\n\n\tquotient = div_u64_rem(delta, 1000000000ULL, &reminder);\n\tsec = quotient;\n\tnsec = reminder;\n\n\t \n\tif (priv->plat->est && priv->plat->est->enable) {\n\t\test_rst = true;\n\t\tmutex_lock(&priv->plat->est->lock);\n\t\tpriv->plat->est->enable = false;\n\t\tstmmac_est_configure(priv, priv->ioaddr, priv->plat->est,\n\t\t\t\t     priv->plat->clk_ptp_rate);\n\t\tmutex_unlock(&priv->plat->est->lock);\n\t}\n\n\twrite_lock_irqsave(&priv->ptp_lock, flags);\n\tstmmac_adjust_systime(priv, priv->ptpaddr, sec, nsec, neg_adj, xmac);\n\twrite_unlock_irqrestore(&priv->ptp_lock, flags);\n\n\t \n\tif (est_rst) {\n\t\tstruct timespec64 current_time, time;\n\t\tktime_t current_time_ns, basetime;\n\t\tu64 cycle_time;\n\n\t\tmutex_lock(&priv->plat->est->lock);\n\t\tpriv->ptp_clock_ops.gettime64(&priv->ptp_clock_ops, &current_time);\n\t\tcurrent_time_ns = timespec64_to_ktime(current_time);\n\t\ttime.tv_nsec = priv->plat->est->btr_reserve[0];\n\t\ttime.tv_sec = priv->plat->est->btr_reserve[1];\n\t\tbasetime = timespec64_to_ktime(time);\n\t\tcycle_time = (u64)priv->plat->est->ctr[1] * NSEC_PER_SEC +\n\t\t\t     priv->plat->est->ctr[0];\n\t\ttime = stmmac_calc_tas_basetime(basetime,\n\t\t\t\t\t\tcurrent_time_ns,\n\t\t\t\t\t\tcycle_time);\n\n\t\tpriv->plat->est->btr[0] = (u32)time.tv_nsec;\n\t\tpriv->plat->est->btr[1] = (u32)time.tv_sec;\n\t\tpriv->plat->est->enable = true;\n\t\tret = stmmac_est_configure(priv, priv->ioaddr, priv->plat->est,\n\t\t\t\t\t   priv->plat->clk_ptp_rate);\n\t\tmutex_unlock(&priv->plat->est->lock);\n\t\tif (ret)\n\t\t\tnetdev_err(priv->dev, \"failed to configure EST\\n\");\n\t}\n\n\treturn 0;\n}\n\n \nstatic int stmmac_get_time(struct ptp_clock_info *ptp, struct timespec64 *ts)\n{\n\tstruct stmmac_priv *priv =\n\t    container_of(ptp, struct stmmac_priv, ptp_clock_ops);\n\tunsigned long flags;\n\tu64 ns = 0;\n\n\tread_lock_irqsave(&priv->ptp_lock, flags);\n\tstmmac_get_systime(priv, priv->ptpaddr, &ns);\n\tread_unlock_irqrestore(&priv->ptp_lock, flags);\n\n\t*ts = ns_to_timespec64(ns);\n\n\treturn 0;\n}\n\n \nstatic int stmmac_set_time(struct ptp_clock_info *ptp,\n\t\t\t   const struct timespec64 *ts)\n{\n\tstruct stmmac_priv *priv =\n\t    container_of(ptp, struct stmmac_priv, ptp_clock_ops);\n\tunsigned long flags;\n\n\twrite_lock_irqsave(&priv->ptp_lock, flags);\n\tstmmac_init_systime(priv, priv->ptpaddr, ts->tv_sec, ts->tv_nsec);\n\twrite_unlock_irqrestore(&priv->ptp_lock, flags);\n\n\treturn 0;\n}\n\nstatic int stmmac_enable(struct ptp_clock_info *ptp,\n\t\t\t struct ptp_clock_request *rq, int on)\n{\n\tstruct stmmac_priv *priv =\n\t    container_of(ptp, struct stmmac_priv, ptp_clock_ops);\n\tvoid __iomem *ptpaddr = priv->ptpaddr;\n\tstruct stmmac_pps_cfg *cfg;\n\tint ret = -EOPNOTSUPP;\n\tunsigned long flags;\n\tu32 acr_value;\n\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_PEROUT:\n\t\t \n\t\tif (rq->perout.flags)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tcfg = &priv->pps[rq->perout.index];\n\n\t\tcfg->start.tv_sec = rq->perout.start.sec;\n\t\tcfg->start.tv_nsec = rq->perout.start.nsec;\n\t\tcfg->period.tv_sec = rq->perout.period.sec;\n\t\tcfg->period.tv_nsec = rq->perout.period.nsec;\n\n\t\twrite_lock_irqsave(&priv->ptp_lock, flags);\n\t\tret = stmmac_flex_pps_config(priv, priv->ioaddr,\n\t\t\t\t\t     rq->perout.index, cfg, on,\n\t\t\t\t\t     priv->sub_second_inc,\n\t\t\t\t\t     priv->systime_flags);\n\t\twrite_unlock_irqrestore(&priv->ptp_lock, flags);\n\t\tbreak;\n\tcase PTP_CLK_REQ_EXTTS:\n\t\tif (on)\n\t\t\tpriv->plat->flags |= STMMAC_FLAG_EXT_SNAPSHOT_EN;\n\t\telse\n\t\t\tpriv->plat->flags &= ~STMMAC_FLAG_EXT_SNAPSHOT_EN;\n\t\tmutex_lock(&priv->aux_ts_lock);\n\t\tacr_value = readl(ptpaddr + PTP_ACR);\n\t\tacr_value &= ~PTP_ACR_MASK;\n\t\tif (on) {\n\t\t\t \n\t\t\tacr_value |= priv->plat->ext_snapshot_num;\n\t\t\tacr_value |= PTP_ACR_ATSFC;\n\t\t\tnetdev_dbg(priv->dev, \"Auxiliary Snapshot %d enabled.\\n\",\n\t\t\t\t   priv->plat->ext_snapshot_num >>\n\t\t\t\t   PTP_ACR_ATSEN_SHIFT);\n\t\t} else {\n\t\t\tnetdev_dbg(priv->dev, \"Auxiliary Snapshot %d disabled.\\n\",\n\t\t\t\t   priv->plat->ext_snapshot_num >>\n\t\t\t\t   PTP_ACR_ATSEN_SHIFT);\n\t\t}\n\t\twritel(acr_value, ptpaddr + PTP_ACR);\n\t\tmutex_unlock(&priv->aux_ts_lock);\n\t\t \n\t\tret = readl_poll_timeout(ptpaddr + PTP_ACR, acr_value,\n\t\t\t\t\t !(acr_value & PTP_ACR_ATSFC),\n\t\t\t\t\t 10, 10000);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int stmmac_get_syncdevicetime(ktime_t *device,\n\t\t\t\t     struct system_counterval_t *system,\n\t\t\t\t     void *ctx)\n{\n\tstruct stmmac_priv *priv = (struct stmmac_priv *)ctx;\n\n\tif (priv->plat->crosststamp)\n\t\treturn priv->plat->crosststamp(device, system, ctx);\n\telse\n\t\treturn -EOPNOTSUPP;\n}\n\nstatic int stmmac_getcrosststamp(struct ptp_clock_info *ptp,\n\t\t\t\t struct system_device_crosststamp *xtstamp)\n{\n\tstruct stmmac_priv *priv =\n\t\tcontainer_of(ptp, struct stmmac_priv, ptp_clock_ops);\n\n\treturn get_device_system_crosststamp(stmmac_get_syncdevicetime,\n\t\t\t\t\t     priv, NULL, xtstamp);\n}\n\n \nstatic struct ptp_clock_info stmmac_ptp_clock_ops = {\n\t.owner = THIS_MODULE,\n\t.name = \"stmmac ptp\",\n\t.max_adj = 62500000,\n\t.n_alarm = 0,\n\t.n_ext_ts = 0,  \n\t.n_per_out = 0,  \n\t.n_pins = 0,\n\t.pps = 0,\n\t.adjfine = stmmac_adjust_freq,\n\t.adjtime = stmmac_adjust_time,\n\t.gettime64 = stmmac_get_time,\n\t.settime64 = stmmac_set_time,\n\t.enable = stmmac_enable,\n\t.getcrosststamp = stmmac_getcrosststamp,\n};\n\n \nvoid stmmac_ptp_register(struct stmmac_priv *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < priv->dma_cap.pps_out_num; i++) {\n\t\tif (i >= STMMAC_PPS_MAX)\n\t\t\tbreak;\n\t\tpriv->pps[i].available = true;\n\t}\n\n\tif (priv->plat->ptp_max_adj)\n\t\tstmmac_ptp_clock_ops.max_adj = priv->plat->ptp_max_adj;\n\n\t \n\tpriv->plat->cdc_error_adj = 0;\n\tif (priv->plat->has_gmac4 && priv->plat->clk_ptp_rate)\n\t\tpriv->plat->cdc_error_adj = (2 * NSEC_PER_SEC) / priv->plat->clk_ptp_rate;\n\n\tstmmac_ptp_clock_ops.n_per_out = priv->dma_cap.pps_out_num;\n\tstmmac_ptp_clock_ops.n_ext_ts = priv->dma_cap.aux_snapshot_n;\n\n\trwlock_init(&priv->ptp_lock);\n\tmutex_init(&priv->aux_ts_lock);\n\tpriv->ptp_clock_ops = stmmac_ptp_clock_ops;\n\n\tpriv->ptp_clock = ptp_clock_register(&priv->ptp_clock_ops,\n\t\t\t\t\t     priv->device);\n\tif (IS_ERR(priv->ptp_clock)) {\n\t\tnetdev_err(priv->dev, \"ptp_clock_register failed\\n\");\n\t\tpriv->ptp_clock = NULL;\n\t} else if (priv->ptp_clock)\n\t\tnetdev_info(priv->dev, \"registered PTP clock\\n\");\n}\n\n \nvoid stmmac_ptp_unregister(struct stmmac_priv *priv)\n{\n\tif (priv->ptp_clock) {\n\t\tptp_clock_unregister(priv->ptp_clock);\n\t\tpriv->ptp_clock = NULL;\n\t\tpr_debug(\"Removed PTP HW clock successfully on %s\\n\",\n\t\t\t priv->dev->name);\n\t}\n\n\tmutex_destroy(&priv->aux_ts_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}