{
  "module_name": "dwxgmac2_dma.c",
  "hash_id": "f40aa10f3cbb3444fc1940e1e34db3301575e0279bc37b47e2407955e3422fe8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_dma.c",
  "human_readable_source": "\n \n\n#include <linux/iopoll.h>\n#include \"stmmac.h\"\n#include \"dwxgmac2.h\"\n\nstatic int dwxgmac2_dma_reset(void __iomem *ioaddr)\n{\n\tu32 value = readl(ioaddr + XGMAC_DMA_MODE);\n\n\t \n\twritel(value | XGMAC_SWR, ioaddr + XGMAC_DMA_MODE);\n\n\treturn readl_poll_timeout(ioaddr + XGMAC_DMA_MODE, value,\n\t\t\t\t  !(value & XGMAC_SWR), 0, 100000);\n}\n\nstatic void dwxgmac2_dma_init(void __iomem *ioaddr,\n\t\t\t      struct stmmac_dma_cfg *dma_cfg, int atds)\n{\n\tu32 value = readl(ioaddr + XGMAC_DMA_SYSBUS_MODE);\n\n\tif (dma_cfg->aal)\n\t\tvalue |= XGMAC_AAL;\n\n\tif (dma_cfg->eame)\n\t\tvalue |= XGMAC_EAME;\n\n\twritel(value, ioaddr + XGMAC_DMA_SYSBUS_MODE);\n}\n\nstatic void dwxgmac2_dma_init_chan(struct stmmac_priv *priv,\n\t\t\t\t   void __iomem *ioaddr,\n\t\t\t\t   struct stmmac_dma_cfg *dma_cfg, u32 chan)\n{\n\tu32 value = readl(ioaddr + XGMAC_DMA_CH_CONTROL(chan));\n\n\tif (dma_cfg->pblx8)\n\t\tvalue |= XGMAC_PBLx8;\n\n\twritel(value, ioaddr + XGMAC_DMA_CH_CONTROL(chan));\n\twritel(XGMAC_DMA_INT_DEFAULT_EN, ioaddr + XGMAC_DMA_CH_INT_EN(chan));\n}\n\nstatic void dwxgmac2_dma_init_rx_chan(struct stmmac_priv *priv,\n\t\t\t\t      void __iomem *ioaddr,\n\t\t\t\t      struct stmmac_dma_cfg *dma_cfg,\n\t\t\t\t      dma_addr_t phy, u32 chan)\n{\n\tu32 rxpbl = dma_cfg->rxpbl ?: dma_cfg->pbl;\n\tu32 value;\n\n\tvalue = readl(ioaddr + XGMAC_DMA_CH_RX_CONTROL(chan));\n\tvalue &= ~XGMAC_RxPBL;\n\tvalue |= (rxpbl << XGMAC_RxPBL_SHIFT) & XGMAC_RxPBL;\n\twritel(value, ioaddr + XGMAC_DMA_CH_RX_CONTROL(chan));\n\n\twritel(upper_32_bits(phy), ioaddr + XGMAC_DMA_CH_RxDESC_HADDR(chan));\n\twritel(lower_32_bits(phy), ioaddr + XGMAC_DMA_CH_RxDESC_LADDR(chan));\n}\n\nstatic void dwxgmac2_dma_init_tx_chan(struct stmmac_priv *priv,\n\t\t\t\t      void __iomem *ioaddr,\n\t\t\t\t      struct stmmac_dma_cfg *dma_cfg,\n\t\t\t\t      dma_addr_t phy, u32 chan)\n{\n\tu32 txpbl = dma_cfg->txpbl ?: dma_cfg->pbl;\n\tu32 value;\n\n\tvalue = readl(ioaddr + XGMAC_DMA_CH_TX_CONTROL(chan));\n\tvalue &= ~XGMAC_TxPBL;\n\tvalue |= (txpbl << XGMAC_TxPBL_SHIFT) & XGMAC_TxPBL;\n\tvalue |= XGMAC_OSP;\n\twritel(value, ioaddr + XGMAC_DMA_CH_TX_CONTROL(chan));\n\n\twritel(upper_32_bits(phy), ioaddr + XGMAC_DMA_CH_TxDESC_HADDR(chan));\n\twritel(lower_32_bits(phy), ioaddr + XGMAC_DMA_CH_TxDESC_LADDR(chan));\n}\n\nstatic void dwxgmac2_dma_axi(void __iomem *ioaddr, struct stmmac_axi *axi)\n{\n\tu32 value = readl(ioaddr + XGMAC_DMA_SYSBUS_MODE);\n\tint i;\n\n\tif (axi->axi_lpi_en)\n\t\tvalue |= XGMAC_EN_LPI;\n\tif (axi->axi_xit_frm)\n\t\tvalue |= XGMAC_LPI_XIT_PKT;\n\n\tvalue &= ~XGMAC_WR_OSR_LMT;\n\tvalue |= (axi->axi_wr_osr_lmt << XGMAC_WR_OSR_LMT_SHIFT) &\n\t\tXGMAC_WR_OSR_LMT;\n\n\tvalue &= ~XGMAC_RD_OSR_LMT;\n\tvalue |= (axi->axi_rd_osr_lmt << XGMAC_RD_OSR_LMT_SHIFT) &\n\t\tXGMAC_RD_OSR_LMT;\n\n\tif (!axi->axi_fb)\n\t\tvalue |= XGMAC_UNDEF;\n\n\tvalue &= ~XGMAC_BLEN;\n\tfor (i = 0; i < AXI_BLEN; i++) {\n\t\tswitch (axi->axi_blen[i]) {\n\t\tcase 256:\n\t\t\tvalue |= XGMAC_BLEN256;\n\t\t\tbreak;\n\t\tcase 128:\n\t\t\tvalue |= XGMAC_BLEN128;\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tvalue |= XGMAC_BLEN64;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tvalue |= XGMAC_BLEN32;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tvalue |= XGMAC_BLEN16;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tvalue |= XGMAC_BLEN8;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tvalue |= XGMAC_BLEN4;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\twritel(value, ioaddr + XGMAC_DMA_SYSBUS_MODE);\n\twritel(XGMAC_TDPS, ioaddr + XGMAC_TX_EDMA_CTRL);\n\twritel(XGMAC_RDPS, ioaddr + XGMAC_RX_EDMA_CTRL);\n}\n\nstatic void dwxgmac2_dma_dump_regs(struct stmmac_priv *priv,\n\t\t\t\t   void __iomem *ioaddr, u32 *reg_space)\n{\n\tint i;\n\n\tfor (i = (XGMAC_DMA_MODE / 4); i < XGMAC_REGSIZE; i++)\n\t\treg_space[i] = readl(ioaddr + i * 4);\n}\n\nstatic void dwxgmac2_dma_rx_mode(struct stmmac_priv *priv, void __iomem *ioaddr,\n\t\t\t\t int mode, u32 channel, int fifosz, u8 qmode)\n{\n\tu32 value = readl(ioaddr + XGMAC_MTL_RXQ_OPMODE(channel));\n\tunsigned int rqs = fifosz / 256 - 1;\n\n\tif (mode == SF_DMA_MODE) {\n\t\tvalue |= XGMAC_RSF;\n\t} else {\n\t\tvalue &= ~XGMAC_RSF;\n\t\tvalue &= ~XGMAC_RTC;\n\n\t\tif (mode <= 64)\n\t\t\tvalue |= 0x0 << XGMAC_RTC_SHIFT;\n\t\telse if (mode <= 96)\n\t\t\tvalue |= 0x2 << XGMAC_RTC_SHIFT;\n\t\telse\n\t\t\tvalue |= 0x3 << XGMAC_RTC_SHIFT;\n\t}\n\n\tvalue &= ~XGMAC_RQS;\n\tvalue |= (rqs << XGMAC_RQS_SHIFT) & XGMAC_RQS;\n\n\tif ((fifosz >= 4096) && (qmode != MTL_QUEUE_AVB)) {\n\t\tu32 flow = readl(ioaddr + XGMAC_MTL_RXQ_FLOW_CONTROL(channel));\n\t\tunsigned int rfd, rfa;\n\n\t\tvalue |= XGMAC_EHFC;\n\n\t\t \n\t\tswitch (fifosz) {\n\t\tcase 4096:\n\t\t\t \n\t\t\trfd = 0x03;  \n\t\t\trfa = 0x01;  \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\trfd = 0x07;  \n\t\t\trfa = 0x04;  \n\t\t\tbreak;\n\t\t}\n\n\t\tflow &= ~XGMAC_RFD;\n\t\tflow |= rfd << XGMAC_RFD_SHIFT;\n\n\t\tflow &= ~XGMAC_RFA;\n\t\tflow |= rfa << XGMAC_RFA_SHIFT;\n\n\t\twritel(flow, ioaddr + XGMAC_MTL_RXQ_FLOW_CONTROL(channel));\n\t}\n\n\twritel(value, ioaddr + XGMAC_MTL_RXQ_OPMODE(channel));\n\n\t \n\tvalue = readl(ioaddr + XGMAC_MTL_QINTEN(channel));\n\twritel(value | XGMAC_RXOIE, ioaddr + XGMAC_MTL_QINTEN(channel));\n}\n\nstatic void dwxgmac2_dma_tx_mode(struct stmmac_priv *priv, void __iomem *ioaddr,\n\t\t\t\t int mode, u32 channel, int fifosz, u8 qmode)\n{\n\tu32 value = readl(ioaddr + XGMAC_MTL_TXQ_OPMODE(channel));\n\tunsigned int tqs = fifosz / 256 - 1;\n\n\tif (mode == SF_DMA_MODE) {\n\t\tvalue |= XGMAC_TSF;\n\t} else {\n\t\tvalue &= ~XGMAC_TSF;\n\t\tvalue &= ~XGMAC_TTC;\n\n\t\tif (mode <= 64)\n\t\t\tvalue |= 0x0 << XGMAC_TTC_SHIFT;\n\t\telse if (mode <= 96)\n\t\t\tvalue |= 0x2 << XGMAC_TTC_SHIFT;\n\t\telse if (mode <= 128)\n\t\t\tvalue |= 0x3 << XGMAC_TTC_SHIFT;\n\t\telse if (mode <= 192)\n\t\t\tvalue |= 0x4 << XGMAC_TTC_SHIFT;\n\t\telse if (mode <= 256)\n\t\t\tvalue |= 0x5 << XGMAC_TTC_SHIFT;\n\t\telse if (mode <= 384)\n\t\t\tvalue |= 0x6 << XGMAC_TTC_SHIFT;\n\t\telse\n\t\t\tvalue |= 0x7 << XGMAC_TTC_SHIFT;\n\t}\n\n\t \n\tvalue |= (channel << XGMAC_Q2TCMAP_SHIFT) & XGMAC_Q2TCMAP;\n\n\tvalue &= ~XGMAC_TXQEN;\n\tif (qmode != MTL_QUEUE_AVB)\n\t\tvalue |= 0x2 << XGMAC_TXQEN_SHIFT;\n\telse\n\t\tvalue |= 0x1 << XGMAC_TXQEN_SHIFT;\n\n\tvalue &= ~XGMAC_TQS;\n\tvalue |= (tqs << XGMAC_TQS_SHIFT) & XGMAC_TQS;\n\n\twritel(value, ioaddr +  XGMAC_MTL_TXQ_OPMODE(channel));\n}\n\nstatic void dwxgmac2_enable_dma_irq(struct stmmac_priv *priv,\n\t\t\t\t    void __iomem *ioaddr, u32 chan,\n\t\t\t\t    bool rx, bool tx)\n{\n\tu32 value = readl(ioaddr + XGMAC_DMA_CH_INT_EN(chan));\n\n\tif (rx)\n\t\tvalue |= XGMAC_DMA_INT_DEFAULT_RX;\n\tif (tx)\n\t\tvalue |= XGMAC_DMA_INT_DEFAULT_TX;\n\n\twritel(value, ioaddr + XGMAC_DMA_CH_INT_EN(chan));\n}\n\nstatic void dwxgmac2_disable_dma_irq(struct stmmac_priv *priv,\n\t\t\t\t     void __iomem *ioaddr, u32 chan,\n\t\t\t\t     bool rx, bool tx)\n{\n\tu32 value = readl(ioaddr + XGMAC_DMA_CH_INT_EN(chan));\n\n\tif (rx)\n\t\tvalue &= ~XGMAC_DMA_INT_DEFAULT_RX;\n\tif (tx)\n\t\tvalue &= ~XGMAC_DMA_INT_DEFAULT_TX;\n\n\twritel(value, ioaddr + XGMAC_DMA_CH_INT_EN(chan));\n}\n\nstatic void dwxgmac2_dma_start_tx(struct stmmac_priv *priv,\n\t\t\t\t  void __iomem *ioaddr, u32 chan)\n{\n\tu32 value;\n\n\tvalue = readl(ioaddr + XGMAC_DMA_CH_TX_CONTROL(chan));\n\tvalue |= XGMAC_TXST;\n\twritel(value, ioaddr + XGMAC_DMA_CH_TX_CONTROL(chan));\n\n\tvalue = readl(ioaddr + XGMAC_TX_CONFIG);\n\tvalue |= XGMAC_CONFIG_TE;\n\twritel(value, ioaddr + XGMAC_TX_CONFIG);\n}\n\nstatic void dwxgmac2_dma_stop_tx(struct stmmac_priv *priv, void __iomem *ioaddr,\n\t\t\t\t u32 chan)\n{\n\tu32 value;\n\n\tvalue = readl(ioaddr + XGMAC_DMA_CH_TX_CONTROL(chan));\n\tvalue &= ~XGMAC_TXST;\n\twritel(value, ioaddr + XGMAC_DMA_CH_TX_CONTROL(chan));\n\n\tvalue = readl(ioaddr + XGMAC_TX_CONFIG);\n\tvalue &= ~XGMAC_CONFIG_TE;\n\twritel(value, ioaddr + XGMAC_TX_CONFIG);\n}\n\nstatic void dwxgmac2_dma_start_rx(struct stmmac_priv *priv,\n\t\t\t\t  void __iomem *ioaddr, u32 chan)\n{\n\tu32 value;\n\n\tvalue = readl(ioaddr + XGMAC_DMA_CH_RX_CONTROL(chan));\n\tvalue |= XGMAC_RXST;\n\twritel(value, ioaddr + XGMAC_DMA_CH_RX_CONTROL(chan));\n\n\tvalue = readl(ioaddr + XGMAC_RX_CONFIG);\n\tvalue |= XGMAC_CONFIG_RE;\n\twritel(value, ioaddr + XGMAC_RX_CONFIG);\n}\n\nstatic void dwxgmac2_dma_stop_rx(struct stmmac_priv *priv, void __iomem *ioaddr,\n\t\t\t\t u32 chan)\n{\n\tu32 value;\n\n\tvalue = readl(ioaddr + XGMAC_DMA_CH_RX_CONTROL(chan));\n\tvalue &= ~XGMAC_RXST;\n\twritel(value, ioaddr + XGMAC_DMA_CH_RX_CONTROL(chan));\n}\n\nstatic int dwxgmac2_dma_interrupt(struct stmmac_priv *priv,\n\t\t\t\t  void __iomem *ioaddr,\n\t\t\t\t  struct stmmac_extra_stats *x, u32 chan,\n\t\t\t\t  u32 dir)\n{\n\tstruct stmmac_rxq_stats *rxq_stats = &priv->xstats.rxq_stats[chan];\n\tstruct stmmac_txq_stats *txq_stats = &priv->xstats.txq_stats[chan];\n\tu32 intr_status = readl(ioaddr + XGMAC_DMA_CH_STATUS(chan));\n\tu32 intr_en = readl(ioaddr + XGMAC_DMA_CH_INT_EN(chan));\n\tint ret = 0;\n\n\tif (dir == DMA_DIR_RX)\n\t\tintr_status &= XGMAC_DMA_STATUS_MSK_RX;\n\telse if (dir == DMA_DIR_TX)\n\t\tintr_status &= XGMAC_DMA_STATUS_MSK_TX;\n\n\t \n\tif (unlikely(intr_status & XGMAC_AIS)) {\n\t\tif (unlikely(intr_status & XGMAC_RBU)) {\n\t\t\tx->rx_buf_unav_irq++;\n\t\t\tret |= handle_rx;\n\t\t}\n\t\tif (unlikely(intr_status & XGMAC_TPS)) {\n\t\t\tx->tx_process_stopped_irq++;\n\t\t\tret |= tx_hard_error;\n\t\t}\n\t\tif (unlikely(intr_status & XGMAC_FBE)) {\n\t\t\tx->fatal_bus_error_irq++;\n\t\t\tret |= tx_hard_error;\n\t\t}\n\t}\n\n\t \n\tif (likely(intr_status & XGMAC_NIS)) {\n\t\tif (likely(intr_status & XGMAC_RI)) {\n\t\t\tu64_stats_update_begin(&rxq_stats->syncp);\n\t\t\trxq_stats->rx_normal_irq_n++;\n\t\t\tu64_stats_update_end(&rxq_stats->syncp);\n\t\t\tret |= handle_rx;\n\t\t}\n\t\tif (likely(intr_status & (XGMAC_TI | XGMAC_TBU))) {\n\t\t\tu64_stats_update_begin(&txq_stats->syncp);\n\t\t\ttxq_stats->tx_normal_irq_n++;\n\t\t\tu64_stats_update_end(&txq_stats->syncp);\n\t\t\tret |= handle_tx;\n\t\t}\n\t}\n\n\t \n\twritel(intr_en & intr_status, ioaddr + XGMAC_DMA_CH_STATUS(chan));\n\n\treturn ret;\n}\n\nstatic int dwxgmac2_get_hw_feature(void __iomem *ioaddr,\n\t\t\t\t   struct dma_features *dma_cap)\n{\n\tu32 hw_cap;\n\n\t \n\thw_cap = readl(ioaddr + XGMAC_HW_FEATURE0);\n\tdma_cap->edma = (hw_cap & XGMAC_HWFEAT_EDMA) >> 31;\n\tdma_cap->ediffc = (hw_cap & XGMAC_HWFEAT_EDIFFC) >> 30;\n\tdma_cap->vxn = (hw_cap & XGMAC_HWFEAT_VXN) >> 29;\n\tdma_cap->vlins = (hw_cap & XGMAC_HWFEAT_SAVLANINS) >> 27;\n\tdma_cap->tssrc = (hw_cap & XGMAC_HWFEAT_TSSTSSEL) >> 25;\n\tdma_cap->multi_addr = (hw_cap & XGMAC_HWFEAT_ADDMACADRSEL) >> 18;\n\tdma_cap->rx_coe = (hw_cap & XGMAC_HWFEAT_RXCOESEL) >> 16;\n\tdma_cap->tx_coe = (hw_cap & XGMAC_HWFEAT_TXCOESEL) >> 14;\n\tdma_cap->eee = (hw_cap & XGMAC_HWFEAT_EEESEL) >> 13;\n\tdma_cap->atime_stamp = (hw_cap & XGMAC_HWFEAT_TSSEL) >> 12;\n\tdma_cap->av = (hw_cap & XGMAC_HWFEAT_AVSEL) >> 11;\n\tdma_cap->av &= !((hw_cap & XGMAC_HWFEAT_RAVSEL) >> 10);\n\tdma_cap->arpoffsel = (hw_cap & XGMAC_HWFEAT_ARPOFFSEL) >> 9;\n\tdma_cap->rmon = (hw_cap & XGMAC_HWFEAT_MMCSEL) >> 8;\n\tdma_cap->pmt_magic_frame = (hw_cap & XGMAC_HWFEAT_MGKSEL) >> 7;\n\tdma_cap->pmt_remote_wake_up = (hw_cap & XGMAC_HWFEAT_RWKSEL) >> 6;\n\tdma_cap->sma_mdio = (hw_cap & XGMAC_HWFEAT_SMASEL) >> 5;\n\tdma_cap->vlhash = (hw_cap & XGMAC_HWFEAT_VLHASH) >> 4;\n\tdma_cap->half_duplex = (hw_cap & XGMAC_HWFEAT_HDSEL) >> 3;\n\tdma_cap->mbps_1000 = (hw_cap & XGMAC_HWFEAT_GMIISEL) >> 1;\n\n\t \n\thw_cap = readl(ioaddr + XGMAC_HW_FEATURE1);\n\tdma_cap->l3l4fnum = (hw_cap & XGMAC_HWFEAT_L3L4FNUM) >> 27;\n\t \n\tif (dma_cap->l3l4fnum >= 8 && dma_cap->l3l4fnum <= 10)\n\t\tdma_cap->l3l4fnum = 8 << (dma_cap->l3l4fnum - 8);\n\telse if (dma_cap->l3l4fnum > 10)\n\t\tdma_cap->l3l4fnum = 32;\n\n\tdma_cap->hash_tb_sz = (hw_cap & XGMAC_HWFEAT_HASHTBLSZ) >> 24;\n\tdma_cap->numtc = ((hw_cap & XGMAC_HWFEAT_NUMTC) >> 21) + 1;\n\tdma_cap->rssen = (hw_cap & XGMAC_HWFEAT_RSSEN) >> 20;\n\tdma_cap->dbgmem = (hw_cap & XGMAC_HWFEAT_DBGMEMA) >> 19;\n\tdma_cap->tsoen = (hw_cap & XGMAC_HWFEAT_TSOEN) >> 18;\n\tdma_cap->sphen = (hw_cap & XGMAC_HWFEAT_SPHEN) >> 17;\n\tdma_cap->dcben = (hw_cap & XGMAC_HWFEAT_DCBEN) >> 16;\n\n\tdma_cap->addr64 = (hw_cap & XGMAC_HWFEAT_ADDR64) >> 14;\n\tswitch (dma_cap->addr64) {\n\tcase 0:\n\t\tdma_cap->addr64 = 32;\n\t\tbreak;\n\tcase 1:\n\t\tdma_cap->addr64 = 40;\n\t\tbreak;\n\tcase 2:\n\t\tdma_cap->addr64 = 48;\n\t\tbreak;\n\tdefault:\n\t\tdma_cap->addr64 = 32;\n\t\tbreak;\n\t}\n\n\tdma_cap->advthword = (hw_cap & XGMAC_HWFEAT_ADVTHWORD) >> 13;\n\tdma_cap->ptoen = (hw_cap & XGMAC_HWFEAT_PTOEN) >> 12;\n\tdma_cap->osten = (hw_cap & XGMAC_HWFEAT_OSTEN) >> 11;\n\tdma_cap->tx_fifo_size =\n\t\t128 << ((hw_cap & XGMAC_HWFEAT_TXFIFOSIZE) >> 6);\n\tdma_cap->pfcen = (hw_cap & XGMAC_HWFEAT_PFCEN) >> 5;\n\tdma_cap->rx_fifo_size =\n\t\t128 << ((hw_cap & XGMAC_HWFEAT_RXFIFOSIZE) >> 0);\n\n\t \n\thw_cap = readl(ioaddr + XGMAC_HW_FEATURE2);\n\tdma_cap->aux_snapshot_n = (hw_cap & XGMAC_HWFEAT_AUXSNAPNUM) >> 28;\n\tdma_cap->pps_out_num = (hw_cap & XGMAC_HWFEAT_PPSOUTNUM) >> 24;\n\tdma_cap->number_tx_channel =\n\t\t((hw_cap & XGMAC_HWFEAT_TXCHCNT) >> 18) + 1;\n\tdma_cap->number_rx_channel =\n\t\t((hw_cap & XGMAC_HWFEAT_RXCHCNT) >> 12) + 1;\n\tdma_cap->number_tx_queues =\n\t\t((hw_cap & XGMAC_HWFEAT_TXQCNT) >> 6) + 1;\n\tdma_cap->number_rx_queues =\n\t\t((hw_cap & XGMAC_HWFEAT_RXQCNT) >> 0) + 1;\n\n\t \n\thw_cap = readl(ioaddr + XGMAC_HW_FEATURE3);\n\tdma_cap->tbs_ch_num = ((hw_cap & XGMAC_HWFEAT_TBSCH) >> 28) + 1;\n\tdma_cap->tbssel = (hw_cap & XGMAC_HWFEAT_TBSSEL) >> 27;\n\tdma_cap->fpesel = (hw_cap & XGMAC_HWFEAT_FPESEL) >> 26;\n\tdma_cap->sgfsel = (hw_cap & XGMAC_HWFEAT_SGFSEL) >> 25;\n\tdma_cap->estwid = (hw_cap & XGMAC_HWFEAT_ESTWID) >> 23;\n\tdma_cap->estdep = (hw_cap & XGMAC_HWFEAT_ESTDEP) >> 20;\n\tdma_cap->estsel = (hw_cap & XGMAC_HWFEAT_ESTSEL) >> 19;\n\tdma_cap->ttsfd = (hw_cap & XGMAC_HWFEAT_TTSFD) >> 16;\n\tdma_cap->asp = (hw_cap & XGMAC_HWFEAT_ASP) >> 14;\n\tdma_cap->dvlan = (hw_cap & XGMAC_HWFEAT_DVLAN) >> 13;\n\tdma_cap->frpes = (hw_cap & XGMAC_HWFEAT_FRPES) >> 11;\n\tdma_cap->frpbs = (hw_cap & XGMAC_HWFEAT_FRPPB) >> 9;\n\tdma_cap->pou_ost_en = (hw_cap & XGMAC_HWFEAT_POUOST) >> 8;\n\tdma_cap->frppipe_num = ((hw_cap & XGMAC_HWFEAT_FRPPIPE) >> 5) + 1;\n\tdma_cap->cbtisel = (hw_cap & XGMAC_HWFEAT_CBTISEL) >> 4;\n\tdma_cap->frpsel = (hw_cap & XGMAC_HWFEAT_FRPSEL) >> 3;\n\tdma_cap->nrvf_num = (hw_cap & XGMAC_HWFEAT_NRVF) >> 0;\n\n\t \n\thw_cap = readl(ioaddr + XGMAC_HW_FEATURE4);\n\tdma_cap->asp |= (hw_cap & XGMAC_HWFEAT_EASP) >> 2;\n\tdma_cap->pcsel = (hw_cap & XGMAC_HWFEAT_PCSEL) >> 0;\n\n\treturn 0;\n}\n\nstatic void dwxgmac2_rx_watchdog(struct stmmac_priv *priv, void __iomem *ioaddr,\n\t\t\t\t u32 riwt, u32 queue)\n{\n\twritel(riwt & XGMAC_RWT, ioaddr + XGMAC_DMA_CH_Rx_WATCHDOG(queue));\n}\n\nstatic void dwxgmac2_set_rx_ring_len(struct stmmac_priv *priv,\n\t\t\t\t     void __iomem *ioaddr, u32 len, u32 chan)\n{\n\twritel(len, ioaddr + XGMAC_DMA_CH_RxDESC_RING_LEN(chan));\n}\n\nstatic void dwxgmac2_set_tx_ring_len(struct stmmac_priv *priv,\n\t\t\t\t     void __iomem *ioaddr, u32 len, u32 chan)\n{\n\twritel(len, ioaddr + XGMAC_DMA_CH_TxDESC_RING_LEN(chan));\n}\n\nstatic void dwxgmac2_set_rx_tail_ptr(struct stmmac_priv *priv,\n\t\t\t\t     void __iomem *ioaddr, u32 ptr, u32 chan)\n{\n\twritel(ptr, ioaddr + XGMAC_DMA_CH_RxDESC_TAIL_LPTR(chan));\n}\n\nstatic void dwxgmac2_set_tx_tail_ptr(struct stmmac_priv *priv,\n\t\t\t\t     void __iomem *ioaddr, u32 ptr, u32 chan)\n{\n\twritel(ptr, ioaddr + XGMAC_DMA_CH_TxDESC_TAIL_LPTR(chan));\n}\n\nstatic void dwxgmac2_enable_tso(struct stmmac_priv *priv, void __iomem *ioaddr,\n\t\t\t\tbool en, u32 chan)\n{\n\tu32 value = readl(ioaddr + XGMAC_DMA_CH_TX_CONTROL(chan));\n\n\tif (en)\n\t\tvalue |= XGMAC_TSE;\n\telse\n\t\tvalue &= ~XGMAC_TSE;\n\n\twritel(value, ioaddr + XGMAC_DMA_CH_TX_CONTROL(chan));\n}\n\nstatic void dwxgmac2_qmode(struct stmmac_priv *priv, void __iomem *ioaddr,\n\t\t\t   u32 channel, u8 qmode)\n{\n\tu32 value = readl(ioaddr + XGMAC_MTL_TXQ_OPMODE(channel));\n\tu32 flow = readl(ioaddr + XGMAC_RX_FLOW_CTRL);\n\n\tvalue &= ~XGMAC_TXQEN;\n\tif (qmode != MTL_QUEUE_AVB) {\n\t\tvalue |= 0x2 << XGMAC_TXQEN_SHIFT;\n\t\twritel(0, ioaddr + XGMAC_MTL_TCx_ETS_CONTROL(channel));\n\t} else {\n\t\tvalue |= 0x1 << XGMAC_TXQEN_SHIFT;\n\t\twritel(flow & (~XGMAC_RFE), ioaddr + XGMAC_RX_FLOW_CTRL);\n\t}\n\n\twritel(value, ioaddr +  XGMAC_MTL_TXQ_OPMODE(channel));\n}\n\nstatic void dwxgmac2_set_bfsize(struct stmmac_priv *priv, void __iomem *ioaddr,\n\t\t\t\tint bfsize, u32 chan)\n{\n\tu32 value;\n\n\tvalue = readl(ioaddr + XGMAC_DMA_CH_RX_CONTROL(chan));\n\tvalue &= ~XGMAC_RBSZ;\n\tvalue |= bfsize << XGMAC_RBSZ_SHIFT;\n\twritel(value, ioaddr + XGMAC_DMA_CH_RX_CONTROL(chan));\n}\n\nstatic void dwxgmac2_enable_sph(struct stmmac_priv *priv, void __iomem *ioaddr,\n\t\t\t\tbool en, u32 chan)\n{\n\tu32 value = readl(ioaddr + XGMAC_RX_CONFIG);\n\n\tvalue &= ~XGMAC_CONFIG_HDSMS;\n\tvalue |= XGMAC_CONFIG_HDSMS_256;  \n\twritel(value, ioaddr + XGMAC_RX_CONFIG);\n\n\tvalue = readl(ioaddr + XGMAC_DMA_CH_CONTROL(chan));\n\tif (en)\n\t\tvalue |= XGMAC_SPH;\n\telse\n\t\tvalue &= ~XGMAC_SPH;\n\twritel(value, ioaddr + XGMAC_DMA_CH_CONTROL(chan));\n}\n\nstatic int dwxgmac2_enable_tbs(struct stmmac_priv *priv, void __iomem *ioaddr,\n\t\t\t       bool en, u32 chan)\n{\n\tu32 value = readl(ioaddr + XGMAC_DMA_CH_TX_CONTROL(chan));\n\n\tif (en)\n\t\tvalue |= XGMAC_EDSE;\n\telse\n\t\tvalue &= ~XGMAC_EDSE;\n\n\twritel(value, ioaddr + XGMAC_DMA_CH_TX_CONTROL(chan));\n\n\tvalue = readl(ioaddr + XGMAC_DMA_CH_TX_CONTROL(chan)) & XGMAC_EDSE;\n\tif (en && !value)\n\t\treturn -EIO;\n\n\twritel(XGMAC_DEF_FTOS, ioaddr + XGMAC_DMA_TBS_CTRL0);\n\twritel(XGMAC_DEF_FTOS, ioaddr + XGMAC_DMA_TBS_CTRL1);\n\twritel(XGMAC_DEF_FTOS, ioaddr + XGMAC_DMA_TBS_CTRL2);\n\twritel(XGMAC_DEF_FTOS, ioaddr + XGMAC_DMA_TBS_CTRL3);\n\treturn 0;\n}\n\nconst struct stmmac_dma_ops dwxgmac210_dma_ops = {\n\t.reset = dwxgmac2_dma_reset,\n\t.init = dwxgmac2_dma_init,\n\t.init_chan = dwxgmac2_dma_init_chan,\n\t.init_rx_chan = dwxgmac2_dma_init_rx_chan,\n\t.init_tx_chan = dwxgmac2_dma_init_tx_chan,\n\t.axi = dwxgmac2_dma_axi,\n\t.dump_regs = dwxgmac2_dma_dump_regs,\n\t.dma_rx_mode = dwxgmac2_dma_rx_mode,\n\t.dma_tx_mode = dwxgmac2_dma_tx_mode,\n\t.enable_dma_irq = dwxgmac2_enable_dma_irq,\n\t.disable_dma_irq = dwxgmac2_disable_dma_irq,\n\t.start_tx = dwxgmac2_dma_start_tx,\n\t.stop_tx = dwxgmac2_dma_stop_tx,\n\t.start_rx = dwxgmac2_dma_start_rx,\n\t.stop_rx = dwxgmac2_dma_stop_rx,\n\t.dma_interrupt = dwxgmac2_dma_interrupt,\n\t.get_hw_feature = dwxgmac2_get_hw_feature,\n\t.rx_watchdog = dwxgmac2_rx_watchdog,\n\t.set_rx_ring_len = dwxgmac2_set_rx_ring_len,\n\t.set_tx_ring_len = dwxgmac2_set_tx_ring_len,\n\t.set_rx_tail_ptr = dwxgmac2_set_rx_tail_ptr,\n\t.set_tx_tail_ptr = dwxgmac2_set_tx_tail_ptr,\n\t.enable_tso = dwxgmac2_enable_tso,\n\t.qmode = dwxgmac2_qmode,\n\t.set_bfsize = dwxgmac2_set_bfsize,\n\t.enable_sph = dwxgmac2_enable_sph,\n\t.enable_tbs = dwxgmac2_enable_tbs,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}