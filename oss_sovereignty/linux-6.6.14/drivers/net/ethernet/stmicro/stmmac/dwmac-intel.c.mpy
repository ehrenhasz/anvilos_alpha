{
  "module_name": "dwmac-intel.c",
  "hash_id": "f915ea61266e7f98d69682c050bed5d66c00736e46e2ce8677617bebe1efdc78",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/pci.h>\n#include <linux/dmi.h>\n#include \"dwmac-intel.h\"\n#include \"dwmac4.h\"\n#include \"stmmac.h\"\n#include \"stmmac_ptp.h\"\n\nstruct intel_priv_data {\n\tint mdio_adhoc_addr;\t \n\tunsigned long crossts_adj;\n\tbool is_pse;\n};\n\n \nstruct stmmac_pci_func_data {\n\tunsigned int func;\n\tint phy_addr;\n};\n\nstruct stmmac_pci_dmi_data {\n\tconst struct stmmac_pci_func_data *func;\n\tsize_t nfuncs;\n};\n\nstruct stmmac_pci_info {\n\tint (*setup)(struct pci_dev *pdev, struct plat_stmmacenet_data *plat);\n};\n\nstatic int stmmac_pci_find_phy_addr(struct pci_dev *pdev,\n\t\t\t\t    const struct dmi_system_id *dmi_list)\n{\n\tconst struct stmmac_pci_func_data *func_data;\n\tconst struct stmmac_pci_dmi_data *dmi_data;\n\tconst struct dmi_system_id *dmi_id;\n\tint func = PCI_FUNC(pdev->devfn);\n\tsize_t n;\n\n\tdmi_id = dmi_first_match(dmi_list);\n\tif (!dmi_id)\n\t\treturn -ENODEV;\n\n\tdmi_data = dmi_id->driver_data;\n\tfunc_data = dmi_data->func;\n\n\tfor (n = 0; n < dmi_data->nfuncs; n++, func_data++)\n\t\tif (func_data->func == func)\n\t\t\treturn func_data->phy_addr;\n\n\treturn -ENODEV;\n}\n\nstatic int serdes_status_poll(struct stmmac_priv *priv, int phyaddr,\n\t\t\t      int phyreg, u32 mask, u32 val)\n{\n\tunsigned int retries = 10;\n\tint val_rd;\n\n\tdo {\n\t\tval_rd = mdiobus_read(priv->mii, phyaddr, phyreg);\n\t\tif ((val_rd & mask) == (val & mask))\n\t\t\treturn 0;\n\t\tudelay(POLL_DELAY_US);\n\t} while (--retries);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int intel_serdes_powerup(struct net_device *ndev, void *priv_data)\n{\n\tstruct intel_priv_data *intel_priv = priv_data;\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\tint serdes_phy_addr = 0;\n\tu32 data = 0;\n\n\tif (!intel_priv->mdio_adhoc_addr)\n\t\treturn 0;\n\n\tserdes_phy_addr = intel_priv->mdio_adhoc_addr;\n\n\t \n\tdata = mdiobus_read(priv->mii, serdes_phy_addr,\n\t\t\t    SERDES_GCR0);\n\n\tdata &= ~SERDES_RATE_MASK;\n\tdata &= ~SERDES_PCLK_MASK;\n\n\tif (priv->plat->max_speed == 2500)\n\t\tdata |= SERDES_RATE_PCIE_GEN2 << SERDES_RATE_PCIE_SHIFT |\n\t\t\tSERDES_PCLK_37p5MHZ << SERDES_PCLK_SHIFT;\n\telse\n\t\tdata |= SERDES_RATE_PCIE_GEN1 << SERDES_RATE_PCIE_SHIFT |\n\t\t\tSERDES_PCLK_70MHZ << SERDES_PCLK_SHIFT;\n\n\tmdiobus_write(priv->mii, serdes_phy_addr, SERDES_GCR0, data);\n\n\t \n\tdata = mdiobus_read(priv->mii, serdes_phy_addr, SERDES_GCR0);\n\tdata |= SERDES_PLL_CLK;\n\tmdiobus_write(priv->mii, serdes_phy_addr, SERDES_GCR0, data);\n\n\t \n\tdata = serdes_status_poll(priv, serdes_phy_addr,\n\t\t\t\t  SERDES_GSR0,\n\t\t\t\t  SERDES_PLL_CLK,\n\t\t\t\t  SERDES_PLL_CLK);\n\n\tif (data) {\n\t\tdev_err(priv->device, \"Serdes PLL clk request timeout\\n\");\n\t\treturn data;\n\t}\n\n\t \n\tdata = mdiobus_read(priv->mii, serdes_phy_addr, SERDES_GCR0);\n\tdata |= SERDES_RST;\n\tmdiobus_write(priv->mii, serdes_phy_addr, SERDES_GCR0, data);\n\n\t \n\tdata = serdes_status_poll(priv, serdes_phy_addr,\n\t\t\t\t  SERDES_GSR0,\n\t\t\t\t  SERDES_RST,\n\t\t\t\t  SERDES_RST);\n\n\tif (data) {\n\t\tdev_err(priv->device, \"Serdes assert lane reset timeout\\n\");\n\t\treturn data;\n\t}\n\n\t \n\tdata = mdiobus_read(priv->mii, serdes_phy_addr, SERDES_GCR0);\n\n\tdata &= ~SERDES_PWR_ST_MASK;\n\tdata |= SERDES_PWR_ST_P0 << SERDES_PWR_ST_SHIFT;\n\n\tmdiobus_write(priv->mii, serdes_phy_addr, SERDES_GCR0, data);\n\n\t \n\tdata = serdes_status_poll(priv, serdes_phy_addr,\n\t\t\t\t  SERDES_GSR0,\n\t\t\t\t  SERDES_PWR_ST_MASK,\n\t\t\t\t  SERDES_PWR_ST_P0 << SERDES_PWR_ST_SHIFT);\n\n\tif (data) {\n\t\tdev_err(priv->device, \"Serdes power state P0 timeout.\\n\");\n\t\treturn data;\n\t}\n\n\t \n\tif (intel_priv->is_pse)\n\t\tmdiobus_modify(priv->mii, serdes_phy_addr, SERDES_GCR0,\n\t\t\t       0, SERDES_PHY_RX_CLK);\n\n\treturn 0;\n}\n\nstatic void intel_serdes_powerdown(struct net_device *ndev, void *intel_data)\n{\n\tstruct intel_priv_data *intel_priv = intel_data;\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\tint serdes_phy_addr = 0;\n\tu32 data = 0;\n\n\tif (!intel_priv->mdio_adhoc_addr)\n\t\treturn;\n\n\tserdes_phy_addr = intel_priv->mdio_adhoc_addr;\n\n\t \n\tif (intel_priv->is_pse)\n\t\tmdiobus_modify(priv->mii, serdes_phy_addr, SERDES_GCR0,\n\t\t\t       SERDES_PHY_RX_CLK, 0);\n\n\t \n\tdata = mdiobus_read(priv->mii, serdes_phy_addr, SERDES_GCR0);\n\n\tdata &= ~SERDES_PWR_ST_MASK;\n\tdata |= SERDES_PWR_ST_P3 << SERDES_PWR_ST_SHIFT;\n\n\tmdiobus_write(priv->mii, serdes_phy_addr, SERDES_GCR0, data);\n\n\t \n\tdata = serdes_status_poll(priv, serdes_phy_addr,\n\t\t\t\t  SERDES_GSR0,\n\t\t\t\t  SERDES_PWR_ST_MASK,\n\t\t\t\t  SERDES_PWR_ST_P3 << SERDES_PWR_ST_SHIFT);\n\n\tif (data) {\n\t\tdev_err(priv->device, \"Serdes power state P3 timeout\\n\");\n\t\treturn;\n\t}\n\n\t \n\tdata = mdiobus_read(priv->mii, serdes_phy_addr, SERDES_GCR0);\n\tdata &= ~SERDES_PLL_CLK;\n\tmdiobus_write(priv->mii, serdes_phy_addr, SERDES_GCR0, data);\n\n\t \n\tdata = serdes_status_poll(priv, serdes_phy_addr,\n\t\t\t\t  SERDES_GSR0,\n\t\t\t\t  SERDES_PLL_CLK,\n\t\t\t\t  (u32)~SERDES_PLL_CLK);\n\n\tif (data) {\n\t\tdev_err(priv->device, \"Serdes PLL clk de-assert timeout\\n\");\n\t\treturn;\n\t}\n\n\t \n\tdata = mdiobus_read(priv->mii, serdes_phy_addr, SERDES_GCR0);\n\tdata &= ~SERDES_RST;\n\tmdiobus_write(priv->mii, serdes_phy_addr, SERDES_GCR0, data);\n\n\t \n\tdata = serdes_status_poll(priv, serdes_phy_addr,\n\t\t\t\t  SERDES_GSR0,\n\t\t\t\t  SERDES_RST,\n\t\t\t\t  (u32)~SERDES_RST);\n\n\tif (data) {\n\t\tdev_err(priv->device, \"Serdes de-assert lane reset timeout\\n\");\n\t\treturn;\n\t}\n}\n\nstatic void intel_speed_mode_2500(struct net_device *ndev, void *intel_data)\n{\n\tstruct intel_priv_data *intel_priv = intel_data;\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\tint serdes_phy_addr = 0;\n\tu32 data = 0;\n\n\tserdes_phy_addr = intel_priv->mdio_adhoc_addr;\n\n\t \n\tdata = mdiobus_read(priv->mii, serdes_phy_addr,\n\t\t\t    SERDES_GCR);\n\n\tif (((data & SERDES_LINK_MODE_MASK) >> SERDES_LINK_MODE_SHIFT) ==\n\t    SERDES_LINK_MODE_2G5) {\n\t\tdev_info(priv->device, \"Link Speed Mode: 2.5Gbps\\n\");\n\t\tpriv->plat->max_speed = 2500;\n\t\tpriv->plat->phy_interface = PHY_INTERFACE_MODE_2500BASEX;\n\t\tpriv->plat->mdio_bus_data->xpcs_an_inband = false;\n\t} else {\n\t\tpriv->plat->max_speed = 1000;\n\t}\n}\n\n \nstatic void intel_mgbe_ptp_clk_freq_config(struct stmmac_priv *priv)\n{\n\tstruct intel_priv_data *intel_priv;\n\tu32 gpio_value;\n\n\tintel_priv = (struct intel_priv_data *)priv->plat->bsp_priv;\n\n\tgpio_value = readl(priv->ioaddr + GMAC_GPIO_STATUS);\n\n\tif (intel_priv->is_pse) {\n\t\t \n\t\tgpio_value &= ~PSE_PTP_CLK_FREQ_MASK;\n\t\tgpio_value |= PSE_PTP_CLK_FREQ_200MHZ;\n\t} else {\n\t\t \n\t\tgpio_value &= ~PCH_PTP_CLK_FREQ_MASK;\n\t\tgpio_value |= PCH_PTP_CLK_FREQ_200MHZ;\n\t}\n\n\twritel(gpio_value, priv->ioaddr + GMAC_GPIO_STATUS);\n}\n\nstatic void get_arttime(struct mii_bus *mii, int intel_adhoc_addr,\n\t\t\tu64 *art_time)\n{\n\tu64 ns;\n\n\tns = mdiobus_read(mii, intel_adhoc_addr, PMC_ART_VALUE3);\n\tns <<= GMAC4_ART_TIME_SHIFT;\n\tns |= mdiobus_read(mii, intel_adhoc_addr, PMC_ART_VALUE2);\n\tns <<= GMAC4_ART_TIME_SHIFT;\n\tns |= mdiobus_read(mii, intel_adhoc_addr, PMC_ART_VALUE1);\n\tns <<= GMAC4_ART_TIME_SHIFT;\n\tns |= mdiobus_read(mii, intel_adhoc_addr, PMC_ART_VALUE0);\n\n\t*art_time = ns;\n}\n\nstatic int stmmac_cross_ts_isr(struct stmmac_priv *priv)\n{\n\treturn (readl(priv->ioaddr + GMAC_INT_STATUS) & GMAC_INT_TSIE);\n}\n\nstatic int intel_crosststamp(ktime_t *device,\n\t\t\t     struct system_counterval_t *system,\n\t\t\t     void *ctx)\n{\n\tstruct intel_priv_data *intel_priv;\n\n\tstruct stmmac_priv *priv = (struct stmmac_priv *)ctx;\n\tvoid __iomem *ptpaddr = priv->ptpaddr;\n\tvoid __iomem *ioaddr = priv->hw->pcsr;\n\tunsigned long flags;\n\tu64 art_time = 0;\n\tu64 ptp_time = 0;\n\tu32 num_snapshot;\n\tu32 gpio_value;\n\tu32 acr_value;\n\tint i;\n\n\tif (!boot_cpu_has(X86_FEATURE_ART))\n\t\treturn -EOPNOTSUPP;\n\n\tintel_priv = priv->plat->bsp_priv;\n\n\t \n\tif (priv->plat->flags & STMMAC_FLAG_EXT_SNAPSHOT_EN)\n\t\treturn -EBUSY;\n\n\tpriv->plat->flags |= STMMAC_FLAG_INT_SNAPSHOT_EN;\n\n\tmutex_lock(&priv->aux_ts_lock);\n\t \n\tacr_value = readl(ptpaddr + PTP_ACR);\n\tacr_value &= ~PTP_ACR_MASK;\n\tswitch (priv->plat->int_snapshot_num) {\n\tcase AUX_SNAPSHOT0:\n\t\tacr_value |= PTP_ACR_ATSEN0;\n\t\tbreak;\n\tcase AUX_SNAPSHOT1:\n\t\tacr_value |= PTP_ACR_ATSEN1;\n\t\tbreak;\n\tcase AUX_SNAPSHOT2:\n\t\tacr_value |= PTP_ACR_ATSEN2;\n\t\tbreak;\n\tcase AUX_SNAPSHOT3:\n\t\tacr_value |= PTP_ACR_ATSEN3;\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&priv->aux_ts_lock);\n\t\tpriv->plat->flags &= ~STMMAC_FLAG_INT_SNAPSHOT_EN;\n\t\treturn -EINVAL;\n\t}\n\twritel(acr_value, ptpaddr + PTP_ACR);\n\n\t \n\tacr_value = readl(ptpaddr + PTP_ACR);\n\tacr_value |= PTP_ACR_ATSFC;\n\twritel(acr_value, ptpaddr + PTP_ACR);\n\t \n\tmutex_unlock(&priv->aux_ts_lock);\n\n\t \n\tgpio_value = readl(ioaddr + GMAC_GPIO_STATUS);\n\tgpio_value &= ~GMAC_GPO1;\n\twritel(gpio_value, ioaddr + GMAC_GPIO_STATUS);\n\tgpio_value |= GMAC_GPO1;\n\twritel(gpio_value, ioaddr + GMAC_GPIO_STATUS);\n\n\t \n\tif (!wait_event_interruptible_timeout(priv->tstamp_busy_wait,\n\t\t\t\t\t      stmmac_cross_ts_isr(priv),\n\t\t\t\t\t      HZ / 100)) {\n\t\tpriv->plat->flags &= ~STMMAC_FLAG_INT_SNAPSHOT_EN;\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tnum_snapshot = (readl(ioaddr + GMAC_TIMESTAMP_STATUS) &\n\t\t\tGMAC_TIMESTAMP_ATSNS_MASK) >>\n\t\t\tGMAC_TIMESTAMP_ATSNS_SHIFT;\n\n\t \n\tfor (i = 0; i < num_snapshot; i++) {\n\t\tread_lock_irqsave(&priv->ptp_lock, flags);\n\t\tstmmac_get_ptptime(priv, ptpaddr, &ptp_time);\n\t\t*device = ns_to_ktime(ptp_time);\n\t\tread_unlock_irqrestore(&priv->ptp_lock, flags);\n\t\tget_arttime(priv->mii, intel_priv->mdio_adhoc_addr, &art_time);\n\t\t*system = convert_art_to_tsc(art_time);\n\t}\n\n\tsystem->cycles *= intel_priv->crossts_adj;\n\tpriv->plat->flags &= ~STMMAC_FLAG_INT_SNAPSHOT_EN;\n\n\treturn 0;\n}\n\nstatic void intel_mgbe_pse_crossts_adj(struct intel_priv_data *intel_priv,\n\t\t\t\t       int base)\n{\n\tif (boot_cpu_has(X86_FEATURE_ART)) {\n\t\tunsigned int art_freq;\n\n\t\t \n\t\tart_freq = cpuid_ecx(ART_CPUID_LEAF);\n\t\tdo_div(art_freq, base);\n\t\tintel_priv->crossts_adj = art_freq;\n\t}\n}\n\nstatic void common_default_data(struct plat_stmmacenet_data *plat)\n{\n\tplat->clk_csr = 2;\t \n\tplat->has_gmac = 1;\n\tplat->force_sf_dma_mode = 1;\n\n\tplat->mdio_bus_data->needs_reset = true;\n\n\t \n\tplat->multicast_filter_bins = HASH_TABLE_SIZE;\n\n\t \n\tplat->unicast_filter_entries = 1;\n\n\t \n\tplat->maxmtu = JUMBO_LEN;\n\n\t \n\tplat->tx_queues_to_use = 1;\n\tplat->rx_queues_to_use = 1;\n\n\t \n\tplat->tx_queues_cfg[0].use_prio = false;\n\tplat->rx_queues_cfg[0].use_prio = false;\n\n\t \n\tplat->rx_queues_cfg[0].pkt_route = 0x0;\n}\n\nstatic int intel_mgbe_common_data(struct pci_dev *pdev,\n\t\t\t\t  struct plat_stmmacenet_data *plat)\n{\n\tstruct fwnode_handle *fwnode;\n\tchar clk_name[20];\n\tint ret;\n\tint i;\n\n\tplat->pdev = pdev;\n\tplat->phy_addr = -1;\n\tplat->clk_csr = 5;\n\tplat->has_gmac = 0;\n\tplat->has_gmac4 = 1;\n\tplat->force_sf_dma_mode = 0;\n\tplat->flags |= (STMMAC_FLAG_TSO_EN | STMMAC_FLAG_SPH_DISABLE);\n\n\t \n\tplat->mult_fact_100ns = 1;\n\n\tplat->rx_sched_algorithm = MTL_RX_ALGORITHM_SP;\n\n\tfor (i = 0; i < plat->rx_queues_to_use; i++) {\n\t\tplat->rx_queues_cfg[i].mode_to_use = MTL_QUEUE_DCB;\n\t\tplat->rx_queues_cfg[i].chan = i;\n\n\t\t \n\t\tplat->rx_queues_cfg[i].use_prio = false;\n\n\t\t \n\t\tplat->rx_queues_cfg[i].pkt_route = 0x0;\n\t}\n\n\tfor (i = 0; i < plat->tx_queues_to_use; i++) {\n\t\tplat->tx_queues_cfg[i].mode_to_use = MTL_QUEUE_DCB;\n\n\t\t \n\t\tplat->tx_queues_cfg[i].use_prio = false;\n\t\t \n\t\tif (i > 0)\n\t\t\tplat->tx_queues_cfg[i].tbs_en = 1;\n\t}\n\n\t \n\tplat->tx_fifo_size = plat->tx_queues_to_use * 4096;\n\tplat->rx_fifo_size = plat->rx_queues_to_use * 4096;\n\n\tplat->tx_sched_algorithm = MTL_TX_ALGORITHM_WRR;\n\tplat->tx_queues_cfg[0].weight = 0x09;\n\tplat->tx_queues_cfg[1].weight = 0x0A;\n\tplat->tx_queues_cfg[2].weight = 0x0B;\n\tplat->tx_queues_cfg[3].weight = 0x0C;\n\tplat->tx_queues_cfg[4].weight = 0x0D;\n\tplat->tx_queues_cfg[5].weight = 0x0E;\n\tplat->tx_queues_cfg[6].weight = 0x0F;\n\tplat->tx_queues_cfg[7].weight = 0x10;\n\n\tplat->dma_cfg->pbl = 32;\n\tplat->dma_cfg->pblx8 = true;\n\tplat->dma_cfg->fixed_burst = 0;\n\tplat->dma_cfg->mixed_burst = 0;\n\tplat->dma_cfg->aal = 0;\n\tplat->dma_cfg->dche = true;\n\n\tplat->axi = devm_kzalloc(&pdev->dev, sizeof(*plat->axi),\n\t\t\t\t GFP_KERNEL);\n\tif (!plat->axi)\n\t\treturn -ENOMEM;\n\n\tplat->axi->axi_lpi_en = 0;\n\tplat->axi->axi_xit_frm = 0;\n\tplat->axi->axi_wr_osr_lmt = 1;\n\tplat->axi->axi_rd_osr_lmt = 1;\n\tplat->axi->axi_blen[0] = 4;\n\tplat->axi->axi_blen[1] = 8;\n\tplat->axi->axi_blen[2] = 16;\n\n\tplat->ptp_max_adj = plat->clk_ptp_rate;\n\tplat->eee_usecs_rate = plat->clk_ptp_rate;\n\n\t \n\tsprintf(clk_name, \"%s-%s\", \"stmmac\", pci_name(pdev));\n\n\tplat->stmmac_clk = clk_register_fixed_rate(&pdev->dev,\n\t\t\t\t\t\t   clk_name, NULL, 0,\n\t\t\t\t\t\t   plat->clk_ptp_rate);\n\n\tif (IS_ERR(plat->stmmac_clk)) {\n\t\tdev_warn(&pdev->dev, \"Fail to register stmmac-clk\\n\");\n\t\tplat->stmmac_clk = NULL;\n\t}\n\n\tret = clk_prepare_enable(plat->stmmac_clk);\n\tif (ret) {\n\t\tclk_unregister_fixed_rate(plat->stmmac_clk);\n\t\treturn ret;\n\t}\n\n\tplat->ptp_clk_freq_config = intel_mgbe_ptp_clk_freq_config;\n\n\t \n\tplat->multicast_filter_bins = HASH_TABLE_SIZE;\n\n\t \n\tplat->unicast_filter_entries = 1;\n\n\t \n\tplat->maxmtu = JUMBO_LEN;\n\n\tplat->flags |= STMMAC_FLAG_VLAN_FAIL_Q_EN;\n\n\t \n\tplat->vlan_fail_q = plat->rx_queues_to_use - 1;\n\n\t \n\tfwnode = dev_fwnode(&pdev->dev);\n\tif (fwnode) {\n\t\tint phy_mode;\n\n\t\t \n\t\tphy_mode = fwnode_get_phy_mode(fwnode);\n\t\tif (phy_mode >= 0) {\n\t\t\tif (phy_mode == PHY_INTERFACE_MODE_SGMII ||\n\t\t\t    phy_mode == PHY_INTERFACE_MODE_1000BASEX)\n\t\t\t\tplat->phy_interface = phy_mode;\n\t\t\telse\n\t\t\t\tdev_warn(&pdev->dev, \"Invalid phy-mode\\n\");\n\t\t}\n\t}\n\n\t \n\tif (plat->phy_interface == PHY_INTERFACE_MODE_SGMII ||\n\t    plat->phy_interface == PHY_INTERFACE_MODE_1000BASEX) {\n\t\tplat->mdio_bus_data->has_xpcs = true;\n\t\tplat->mdio_bus_data->xpcs_an_inband = true;\n\t}\n\n\t \n\tif (fwnode) {\n\t\tstruct fwnode_handle *fixed_node;\n\n\t\tfixed_node = fwnode_get_named_child_node(fwnode, \"fixed-link\");\n\t\tif (fixed_node)\n\t\t\tplat->mdio_bus_data->xpcs_an_inband = false;\n\n\t\tfwnode_handle_put(fixed_node);\n\t}\n\n\t \n\tplat->mdio_bus_data->phy_mask = 1 << INTEL_MGBE_ADHOC_ADDR;\n\tplat->mdio_bus_data->phy_mask |= 1 << INTEL_MGBE_XPCS_ADDR;\n\n\tplat->int_snapshot_num = AUX_SNAPSHOT1;\n\tplat->ext_snapshot_num = AUX_SNAPSHOT0;\n\n\tplat->crosststamp = intel_crosststamp;\n\tplat->flags &= ~STMMAC_FLAG_INT_SNAPSHOT_EN;\n\n\t \n\tplat->msi_mac_vec = 29;\n\tplat->msi_lpi_vec = 28;\n\tplat->msi_sfty_ce_vec = 27;\n\tplat->msi_sfty_ue_vec = 26;\n\tplat->msi_rx_base_vec = 0;\n\tplat->msi_tx_base_vec = 1;\n\n\treturn 0;\n}\n\nstatic int ehl_common_data(struct pci_dev *pdev,\n\t\t\t   struct plat_stmmacenet_data *plat)\n{\n\tplat->rx_queues_to_use = 8;\n\tplat->tx_queues_to_use = 8;\n\tplat->flags |= STMMAC_FLAG_USE_PHY_WOL;\n\tplat->flags |= STMMAC_FLAG_HWTSTAMP_CORRECT_LATENCY;\n\n\tplat->safety_feat_cfg->tsoee = 1;\n\tplat->safety_feat_cfg->mrxpee = 1;\n\tplat->safety_feat_cfg->mestee = 1;\n\tplat->safety_feat_cfg->mrxee = 1;\n\tplat->safety_feat_cfg->mtxee = 1;\n\tplat->safety_feat_cfg->epsi = 0;\n\tplat->safety_feat_cfg->edpp = 0;\n\tplat->safety_feat_cfg->prtyen = 0;\n\tplat->safety_feat_cfg->tmouten = 0;\n\n\treturn intel_mgbe_common_data(pdev, plat);\n}\n\nstatic int ehl_sgmii_data(struct pci_dev *pdev,\n\t\t\t  struct plat_stmmacenet_data *plat)\n{\n\tplat->bus_id = 1;\n\tplat->phy_interface = PHY_INTERFACE_MODE_SGMII;\n\tplat->speed_mode_2500 = intel_speed_mode_2500;\n\tplat->serdes_powerup = intel_serdes_powerup;\n\tplat->serdes_powerdown = intel_serdes_powerdown;\n\n\tplat->clk_ptp_rate = 204800000;\n\n\treturn ehl_common_data(pdev, plat);\n}\n\nstatic struct stmmac_pci_info ehl_sgmii1g_info = {\n\t.setup = ehl_sgmii_data,\n};\n\nstatic int ehl_rgmii_data(struct pci_dev *pdev,\n\t\t\t  struct plat_stmmacenet_data *plat)\n{\n\tplat->bus_id = 1;\n\tplat->phy_interface = PHY_INTERFACE_MODE_RGMII;\n\n\tplat->clk_ptp_rate = 204800000;\n\n\treturn ehl_common_data(pdev, plat);\n}\n\nstatic struct stmmac_pci_info ehl_rgmii1g_info = {\n\t.setup = ehl_rgmii_data,\n};\n\nstatic int ehl_pse0_common_data(struct pci_dev *pdev,\n\t\t\t\tstruct plat_stmmacenet_data *plat)\n{\n\tstruct intel_priv_data *intel_priv = plat->bsp_priv;\n\n\tintel_priv->is_pse = true;\n\tplat->bus_id = 2;\n\tplat->host_dma_width = 32;\n\n\tplat->clk_ptp_rate = 200000000;\n\n\tintel_mgbe_pse_crossts_adj(intel_priv, EHL_PSE_ART_MHZ);\n\n\treturn ehl_common_data(pdev, plat);\n}\n\nstatic int ehl_pse0_rgmii1g_data(struct pci_dev *pdev,\n\t\t\t\t struct plat_stmmacenet_data *plat)\n{\n\tplat->phy_interface = PHY_INTERFACE_MODE_RGMII_ID;\n\treturn ehl_pse0_common_data(pdev, plat);\n}\n\nstatic struct stmmac_pci_info ehl_pse0_rgmii1g_info = {\n\t.setup = ehl_pse0_rgmii1g_data,\n};\n\nstatic int ehl_pse0_sgmii1g_data(struct pci_dev *pdev,\n\t\t\t\t struct plat_stmmacenet_data *plat)\n{\n\tplat->phy_interface = PHY_INTERFACE_MODE_SGMII;\n\tplat->speed_mode_2500 = intel_speed_mode_2500;\n\tplat->serdes_powerup = intel_serdes_powerup;\n\tplat->serdes_powerdown = intel_serdes_powerdown;\n\treturn ehl_pse0_common_data(pdev, plat);\n}\n\nstatic struct stmmac_pci_info ehl_pse0_sgmii1g_info = {\n\t.setup = ehl_pse0_sgmii1g_data,\n};\n\nstatic int ehl_pse1_common_data(struct pci_dev *pdev,\n\t\t\t\tstruct plat_stmmacenet_data *plat)\n{\n\tstruct intel_priv_data *intel_priv = plat->bsp_priv;\n\n\tintel_priv->is_pse = true;\n\tplat->bus_id = 3;\n\tplat->host_dma_width = 32;\n\n\tplat->clk_ptp_rate = 200000000;\n\n\tintel_mgbe_pse_crossts_adj(intel_priv, EHL_PSE_ART_MHZ);\n\n\treturn ehl_common_data(pdev, plat);\n}\n\nstatic int ehl_pse1_rgmii1g_data(struct pci_dev *pdev,\n\t\t\t\t struct plat_stmmacenet_data *plat)\n{\n\tplat->phy_interface = PHY_INTERFACE_MODE_RGMII_ID;\n\treturn ehl_pse1_common_data(pdev, plat);\n}\n\nstatic struct stmmac_pci_info ehl_pse1_rgmii1g_info = {\n\t.setup = ehl_pse1_rgmii1g_data,\n};\n\nstatic int ehl_pse1_sgmii1g_data(struct pci_dev *pdev,\n\t\t\t\t struct plat_stmmacenet_data *plat)\n{\n\tplat->phy_interface = PHY_INTERFACE_MODE_SGMII;\n\tplat->speed_mode_2500 = intel_speed_mode_2500;\n\tplat->serdes_powerup = intel_serdes_powerup;\n\tplat->serdes_powerdown = intel_serdes_powerdown;\n\treturn ehl_pse1_common_data(pdev, plat);\n}\n\nstatic struct stmmac_pci_info ehl_pse1_sgmii1g_info = {\n\t.setup = ehl_pse1_sgmii1g_data,\n};\n\nstatic int tgl_common_data(struct pci_dev *pdev,\n\t\t\t   struct plat_stmmacenet_data *plat)\n{\n\tplat->rx_queues_to_use = 6;\n\tplat->tx_queues_to_use = 4;\n\tplat->clk_ptp_rate = 204800000;\n\tplat->speed_mode_2500 = intel_speed_mode_2500;\n\n\tplat->safety_feat_cfg->tsoee = 1;\n\tplat->safety_feat_cfg->mrxpee = 0;\n\tplat->safety_feat_cfg->mestee = 1;\n\tplat->safety_feat_cfg->mrxee = 1;\n\tplat->safety_feat_cfg->mtxee = 1;\n\tplat->safety_feat_cfg->epsi = 0;\n\tplat->safety_feat_cfg->edpp = 0;\n\tplat->safety_feat_cfg->prtyen = 0;\n\tplat->safety_feat_cfg->tmouten = 0;\n\n\treturn intel_mgbe_common_data(pdev, plat);\n}\n\nstatic int tgl_sgmii_phy0_data(struct pci_dev *pdev,\n\t\t\t       struct plat_stmmacenet_data *plat)\n{\n\tplat->bus_id = 1;\n\tplat->phy_interface = PHY_INTERFACE_MODE_SGMII;\n\tplat->serdes_powerup = intel_serdes_powerup;\n\tplat->serdes_powerdown = intel_serdes_powerdown;\n\treturn tgl_common_data(pdev, plat);\n}\n\nstatic struct stmmac_pci_info tgl_sgmii1g_phy0_info = {\n\t.setup = tgl_sgmii_phy0_data,\n};\n\nstatic int tgl_sgmii_phy1_data(struct pci_dev *pdev,\n\t\t\t       struct plat_stmmacenet_data *plat)\n{\n\tplat->bus_id = 2;\n\tplat->phy_interface = PHY_INTERFACE_MODE_SGMII;\n\tplat->serdes_powerup = intel_serdes_powerup;\n\tplat->serdes_powerdown = intel_serdes_powerdown;\n\treturn tgl_common_data(pdev, plat);\n}\n\nstatic struct stmmac_pci_info tgl_sgmii1g_phy1_info = {\n\t.setup = tgl_sgmii_phy1_data,\n};\n\nstatic int adls_sgmii_phy0_data(struct pci_dev *pdev,\n\t\t\t\tstruct plat_stmmacenet_data *plat)\n{\n\tplat->bus_id = 1;\n\tplat->phy_interface = PHY_INTERFACE_MODE_SGMII;\n\n\t \n\n\treturn tgl_common_data(pdev, plat);\n}\n\nstatic struct stmmac_pci_info adls_sgmii1g_phy0_info = {\n\t.setup = adls_sgmii_phy0_data,\n};\n\nstatic int adls_sgmii_phy1_data(struct pci_dev *pdev,\n\t\t\t\tstruct plat_stmmacenet_data *plat)\n{\n\tplat->bus_id = 2;\n\tplat->phy_interface = PHY_INTERFACE_MODE_SGMII;\n\n\t \n\n\treturn tgl_common_data(pdev, plat);\n}\n\nstatic struct stmmac_pci_info adls_sgmii1g_phy1_info = {\n\t.setup = adls_sgmii_phy1_data,\n};\nstatic const struct stmmac_pci_func_data galileo_stmmac_func_data[] = {\n\t{\n\t\t.func = 6,\n\t\t.phy_addr = 1,\n\t},\n};\n\nstatic const struct stmmac_pci_dmi_data galileo_stmmac_dmi_data = {\n\t.func = galileo_stmmac_func_data,\n\t.nfuncs = ARRAY_SIZE(galileo_stmmac_func_data),\n};\n\nstatic const struct stmmac_pci_func_data iot2040_stmmac_func_data[] = {\n\t{\n\t\t.func = 6,\n\t\t.phy_addr = 1,\n\t},\n\t{\n\t\t.func = 7,\n\t\t.phy_addr = 1,\n\t},\n};\n\nstatic const struct stmmac_pci_dmi_data iot2040_stmmac_dmi_data = {\n\t.func = iot2040_stmmac_func_data,\n\t.nfuncs = ARRAY_SIZE(iot2040_stmmac_func_data),\n};\n\nstatic const struct dmi_system_id quark_pci_dmi[] = {\n\t{\n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"Galileo\"),\n\t\t},\n\t\t.driver_data = (void *)&galileo_stmmac_dmi_data,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"GalileoGen2\"),\n\t\t},\n\t\t.driver_data = (void *)&galileo_stmmac_dmi_data,\n\t},\n\t \n\t{\n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"SIMATIC IOT2000\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_ASSET_TAG,\n\t\t\t\t\t\"6ES7647-0AA00-0YA2\"),\n\t\t},\n\t\t.driver_data = (void *)&galileo_stmmac_dmi_data,\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"SIMATIC IOT2000\"),\n\t\t},\n\t\t.driver_data = (void *)&iot2040_stmmac_dmi_data,\n\t},\n\t{}\n};\n\nstatic int quark_default_data(struct pci_dev *pdev,\n\t\t\t      struct plat_stmmacenet_data *plat)\n{\n\tint ret;\n\n\t \n\tcommon_default_data(plat);\n\n\t \n\tret = stmmac_pci_find_phy_addr(pdev, quark_pci_dmi);\n\tif (ret < 0) {\n\t\t \n\t\tif (dmi_get_system_info(DMI_BOARD_NAME))\n\t\t\treturn ret;\n\n\t\t \n\t\tret = 1;\n\t}\n\n\tplat->bus_id = pci_dev_id(pdev);\n\tplat->phy_addr = ret;\n\tplat->phy_interface = PHY_INTERFACE_MODE_RMII;\n\n\tplat->dma_cfg->pbl = 16;\n\tplat->dma_cfg->pblx8 = true;\n\tplat->dma_cfg->fixed_burst = 1;\n\t \n\n\treturn 0;\n}\n\nstatic const struct stmmac_pci_info quark_info = {\n\t.setup = quark_default_data,\n};\n\nstatic int stmmac_config_single_msi(struct pci_dev *pdev,\n\t\t\t\t    struct plat_stmmacenet_data *plat,\n\t\t\t\t    struct stmmac_resources *res)\n{\n\tint ret;\n\n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_ALL_TYPES);\n\tif (ret < 0) {\n\t\tdev_info(&pdev->dev, \"%s: Single IRQ enablement failed\\n\",\n\t\t\t __func__);\n\t\treturn ret;\n\t}\n\n\tres->irq = pci_irq_vector(pdev, 0);\n\tres->wol_irq = res->irq;\n\tplat->flags &= ~STMMAC_FLAG_MULTI_MSI_EN;\n\tdev_info(&pdev->dev, \"%s: Single IRQ enablement successful\\n\",\n\t\t __func__);\n\n\treturn 0;\n}\n\nstatic int stmmac_config_multi_msi(struct pci_dev *pdev,\n\t\t\t\t   struct plat_stmmacenet_data *plat,\n\t\t\t\t   struct stmmac_resources *res)\n{\n\tint ret;\n\tint i;\n\n\tif (plat->msi_rx_base_vec >= STMMAC_MSI_VEC_MAX ||\n\t    plat->msi_tx_base_vec >= STMMAC_MSI_VEC_MAX) {\n\t\tdev_info(&pdev->dev, \"%s: Invalid RX & TX vector defined\\n\",\n\t\t\t __func__);\n\t\treturn -1;\n\t}\n\n\tret = pci_alloc_irq_vectors(pdev, 2, STMMAC_MSI_VEC_MAX,\n\t\t\t\t    PCI_IRQ_MSI | PCI_IRQ_MSIX);\n\tif (ret < 0) {\n\t\tdev_info(&pdev->dev, \"%s: multi MSI enablement failed\\n\",\n\t\t\t __func__);\n\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < plat->rx_queues_to_use; i++) {\n\t\tres->rx_irq[i] = pci_irq_vector(pdev,\n\t\t\t\t\t\tplat->msi_rx_base_vec + i * 2);\n\t}\n\n\t \n\tfor (i = 0; i < plat->tx_queues_to_use; i++) {\n\t\tres->tx_irq[i] = pci_irq_vector(pdev,\n\t\t\t\t\t\tplat->msi_tx_base_vec + i * 2);\n\t}\n\n\tif (plat->msi_mac_vec < STMMAC_MSI_VEC_MAX)\n\t\tres->irq = pci_irq_vector(pdev, plat->msi_mac_vec);\n\tif (plat->msi_wol_vec < STMMAC_MSI_VEC_MAX)\n\t\tres->wol_irq = pci_irq_vector(pdev, plat->msi_wol_vec);\n\tif (plat->msi_lpi_vec < STMMAC_MSI_VEC_MAX)\n\t\tres->lpi_irq = pci_irq_vector(pdev, plat->msi_lpi_vec);\n\tif (plat->msi_sfty_ce_vec < STMMAC_MSI_VEC_MAX)\n\t\tres->sfty_ce_irq = pci_irq_vector(pdev, plat->msi_sfty_ce_vec);\n\tif (plat->msi_sfty_ue_vec < STMMAC_MSI_VEC_MAX)\n\t\tres->sfty_ue_irq = pci_irq_vector(pdev, plat->msi_sfty_ue_vec);\n\n\tplat->flags |= STMMAC_FLAG_MULTI_MSI_EN;\n\tdev_info(&pdev->dev, \"%s: multi MSI enablement successful\\n\", __func__);\n\n\treturn 0;\n}\n\n \nstatic int intel_eth_pci_probe(struct pci_dev *pdev,\n\t\t\t       const struct pci_device_id *id)\n{\n\tstruct stmmac_pci_info *info = (struct stmmac_pci_info *)id->driver_data;\n\tstruct intel_priv_data *intel_priv;\n\tstruct plat_stmmacenet_data *plat;\n\tstruct stmmac_resources res;\n\tint ret;\n\n\tintel_priv = devm_kzalloc(&pdev->dev, sizeof(*intel_priv), GFP_KERNEL);\n\tif (!intel_priv)\n\t\treturn -ENOMEM;\n\n\tplat = devm_kzalloc(&pdev->dev, sizeof(*plat), GFP_KERNEL);\n\tif (!plat)\n\t\treturn -ENOMEM;\n\n\tplat->mdio_bus_data = devm_kzalloc(&pdev->dev,\n\t\t\t\t\t   sizeof(*plat->mdio_bus_data),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!plat->mdio_bus_data)\n\t\treturn -ENOMEM;\n\n\tplat->dma_cfg = devm_kzalloc(&pdev->dev, sizeof(*plat->dma_cfg),\n\t\t\t\t     GFP_KERNEL);\n\tif (!plat->dma_cfg)\n\t\treturn -ENOMEM;\n\n\tplat->safety_feat_cfg = devm_kzalloc(&pdev->dev,\n\t\t\t\t\t     sizeof(*plat->safety_feat_cfg),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!plat->safety_feat_cfg)\n\t\treturn -ENOMEM;\n\n\t \n\tret = pcim_enable_device(pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"%s: ERROR: failed to enable device\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tret = pcim_iomap_regions(pdev, BIT(0), pci_name(pdev));\n\tif (ret)\n\t\treturn ret;\n\n\tpci_set_master(pdev);\n\n\tplat->bsp_priv = intel_priv;\n\tintel_priv->mdio_adhoc_addr = INTEL_MGBE_ADHOC_ADDR;\n\tintel_priv->crossts_adj = 1;\n\n\t \n\tplat->msi_mac_vec = STMMAC_MSI_VEC_MAX;\n\tplat->msi_wol_vec = STMMAC_MSI_VEC_MAX;\n\tplat->msi_lpi_vec = STMMAC_MSI_VEC_MAX;\n\tplat->msi_sfty_ce_vec = STMMAC_MSI_VEC_MAX;\n\tplat->msi_sfty_ue_vec = STMMAC_MSI_VEC_MAX;\n\tplat->msi_rx_base_vec = STMMAC_MSI_VEC_MAX;\n\tplat->msi_tx_base_vec = STMMAC_MSI_VEC_MAX;\n\n\tret = info->setup(pdev, plat);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(&res, 0, sizeof(res));\n\tres.addr = pcim_iomap_table(pdev)[0];\n\n\tif (plat->eee_usecs_rate > 0) {\n\t\tu32 tx_lpi_usec;\n\n\t\ttx_lpi_usec = (plat->eee_usecs_rate / 1000000) - 1;\n\t\twritel(tx_lpi_usec, res.addr + GMAC_1US_TIC_COUNTER);\n\t}\n\n\tret = stmmac_config_multi_msi(pdev, plat, &res);\n\tif (ret) {\n\t\tret = stmmac_config_single_msi(pdev, plat, &res);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"%s: ERROR: failed to enable IRQ\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto err_alloc_irq;\n\t\t}\n\t}\n\n\tret = stmmac_dvr_probe(&pdev->dev, plat, &res);\n\tif (ret) {\n\t\tgoto err_alloc_irq;\n\t}\n\n\treturn 0;\n\nerr_alloc_irq:\n\tclk_disable_unprepare(plat->stmmac_clk);\n\tclk_unregister_fixed_rate(plat->stmmac_clk);\n\treturn ret;\n}\n\n \nstatic void intel_eth_pci_remove(struct pci_dev *pdev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(&pdev->dev);\n\tstruct stmmac_priv *priv = netdev_priv(ndev);\n\n\tstmmac_dvr_remove(&pdev->dev);\n\n\tclk_disable_unprepare(priv->plat->stmmac_clk);\n\tclk_unregister_fixed_rate(priv->plat->stmmac_clk);\n}\n\nstatic int __maybe_unused intel_eth_pci_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tint ret;\n\n\tret = stmmac_suspend(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_save_state(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tpci_wake_from_d3(pdev, true);\n\tpci_set_power_state(pdev, PCI_D3hot);\n\treturn 0;\n}\n\nstatic int __maybe_unused intel_eth_pci_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tint ret;\n\n\tpci_restore_state(pdev);\n\tpci_set_power_state(pdev, PCI_D0);\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tpci_set_master(pdev);\n\n\treturn stmmac_resume(dev);\n}\n\nstatic SIMPLE_DEV_PM_OPS(intel_eth_pm_ops, intel_eth_pci_suspend,\n\t\t\t intel_eth_pci_resume);\n\n#define PCI_DEVICE_ID_INTEL_QUARK\t\t0x0937\n#define PCI_DEVICE_ID_INTEL_EHL_RGMII1G\t\t0x4b30\n#define PCI_DEVICE_ID_INTEL_EHL_SGMII1G\t\t0x4b31\n#define PCI_DEVICE_ID_INTEL_EHL_SGMII2G5\t0x4b32\n \n#define PCI_DEVICE_ID_INTEL_EHL_PSE0_RGMII1G\t0x4ba0\n#define PCI_DEVICE_ID_INTEL_EHL_PSE0_SGMII1G\t0x4ba1\n#define PCI_DEVICE_ID_INTEL_EHL_PSE0_SGMII2G5\t0x4ba2\n#define PCI_DEVICE_ID_INTEL_EHL_PSE1_RGMII1G\t0x4bb0\n#define PCI_DEVICE_ID_INTEL_EHL_PSE1_SGMII1G\t0x4bb1\n#define PCI_DEVICE_ID_INTEL_EHL_PSE1_SGMII2G5\t0x4bb2\n#define PCI_DEVICE_ID_INTEL_TGLH_SGMII1G_0\t0x43ac\n#define PCI_DEVICE_ID_INTEL_TGLH_SGMII1G_1\t0x43a2\n#define PCI_DEVICE_ID_INTEL_TGL_SGMII1G\t\t0xa0ac\n#define PCI_DEVICE_ID_INTEL_ADLS_SGMII1G_0\t0x7aac\n#define PCI_DEVICE_ID_INTEL_ADLS_SGMII1G_1\t0x7aad\n#define PCI_DEVICE_ID_INTEL_ADLN_SGMII1G\t0x54ac\n#define PCI_DEVICE_ID_INTEL_RPLP_SGMII1G\t0x51ac\n\nstatic const struct pci_device_id intel_eth_pci_id_table[] = {\n\t{ PCI_DEVICE_DATA(INTEL, QUARK, &quark_info) },\n\t{ PCI_DEVICE_DATA(INTEL, EHL_RGMII1G, &ehl_rgmii1g_info) },\n\t{ PCI_DEVICE_DATA(INTEL, EHL_SGMII1G, &ehl_sgmii1g_info) },\n\t{ PCI_DEVICE_DATA(INTEL, EHL_SGMII2G5, &ehl_sgmii1g_info) },\n\t{ PCI_DEVICE_DATA(INTEL, EHL_PSE0_RGMII1G, &ehl_pse0_rgmii1g_info) },\n\t{ PCI_DEVICE_DATA(INTEL, EHL_PSE0_SGMII1G, &ehl_pse0_sgmii1g_info) },\n\t{ PCI_DEVICE_DATA(INTEL, EHL_PSE0_SGMII2G5, &ehl_pse0_sgmii1g_info) },\n\t{ PCI_DEVICE_DATA(INTEL, EHL_PSE1_RGMII1G, &ehl_pse1_rgmii1g_info) },\n\t{ PCI_DEVICE_DATA(INTEL, EHL_PSE1_SGMII1G, &ehl_pse1_sgmii1g_info) },\n\t{ PCI_DEVICE_DATA(INTEL, EHL_PSE1_SGMII2G5, &ehl_pse1_sgmii1g_info) },\n\t{ PCI_DEVICE_DATA(INTEL, TGL_SGMII1G, &tgl_sgmii1g_phy0_info) },\n\t{ PCI_DEVICE_DATA(INTEL, TGLH_SGMII1G_0, &tgl_sgmii1g_phy0_info) },\n\t{ PCI_DEVICE_DATA(INTEL, TGLH_SGMII1G_1, &tgl_sgmii1g_phy1_info) },\n\t{ PCI_DEVICE_DATA(INTEL, ADLS_SGMII1G_0, &adls_sgmii1g_phy0_info) },\n\t{ PCI_DEVICE_DATA(INTEL, ADLS_SGMII1G_1, &adls_sgmii1g_phy1_info) },\n\t{ PCI_DEVICE_DATA(INTEL, ADLN_SGMII1G, &tgl_sgmii1g_phy0_info) },\n\t{ PCI_DEVICE_DATA(INTEL, RPLP_SGMII1G, &tgl_sgmii1g_phy0_info) },\n\t{}\n};\nMODULE_DEVICE_TABLE(pci, intel_eth_pci_id_table);\n\nstatic struct pci_driver intel_eth_pci_driver = {\n\t.name = \"intel-eth-pci\",\n\t.id_table = intel_eth_pci_id_table,\n\t.probe = intel_eth_pci_probe,\n\t.remove = intel_eth_pci_remove,\n\t.driver         = {\n\t\t.pm     = &intel_eth_pm_ops,\n\t},\n};\n\nmodule_pci_driver(intel_eth_pci_driver);\n\nMODULE_DESCRIPTION(\"INTEL 10/100/1000 Ethernet PCI driver\");\nMODULE_AUTHOR(\"Voon Weifeng <weifeng.voon@intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}