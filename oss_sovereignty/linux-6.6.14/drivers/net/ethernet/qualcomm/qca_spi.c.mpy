{
  "module_name": "qca_spi.c",
  "hash_id": "0222e52c1719122aa0b35483051da347b70ab7c0a798df1392fdbefcd6e55b6a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qualcomm/qca_spi.c",
  "human_readable_source": " \n\n \n\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/netdevice.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n#include <linux/sched.h>\n#include <linux/skbuff.h>\n#include <linux/spi/spi.h>\n#include <linux/types.h>\n\n#include \"qca_7k.h\"\n#include \"qca_7k_common.h\"\n#include \"qca_debug.h\"\n#include \"qca_spi.h\"\n\n#define MAX_DMA_BURST_LEN 5000\n\n \n#define QCASPI_CLK_SPEED_MIN 1000000\n#define QCASPI_CLK_SPEED_MAX 16000000\n#define QCASPI_CLK_SPEED     8000000\nstatic int qcaspi_clkspeed;\nmodule_param(qcaspi_clkspeed, int, 0);\nMODULE_PARM_DESC(qcaspi_clkspeed, \"SPI bus clock speed (Hz). Use 1000000-16000000.\");\n\n#define QCASPI_BURST_LEN_MIN 1\n#define QCASPI_BURST_LEN_MAX MAX_DMA_BURST_LEN\nstatic int qcaspi_burst_len = MAX_DMA_BURST_LEN;\nmodule_param(qcaspi_burst_len, int, 0);\nMODULE_PARM_DESC(qcaspi_burst_len, \"Number of data bytes per burst. Use 1-5000.\");\n\n#define QCASPI_PLUGGABLE_MIN 0\n#define QCASPI_PLUGGABLE_MAX 1\nstatic int qcaspi_pluggable = QCASPI_PLUGGABLE_MIN;\nmodule_param(qcaspi_pluggable, int, 0);\nMODULE_PARM_DESC(qcaspi_pluggable, \"Pluggable SPI connection (yes/no).\");\n\n#define QCASPI_WRITE_VERIFY_MIN 0\n#define QCASPI_WRITE_VERIFY_MAX 3\nstatic int wr_verify = QCASPI_WRITE_VERIFY_MIN;\nmodule_param(wr_verify, int, 0);\nMODULE_PARM_DESC(wr_verify, \"SPI register write verify trails. Use 0-3.\");\n\n#define QCASPI_TX_TIMEOUT (1 * HZ)\n#define QCASPI_QCA7K_REBOOT_TIME_MS 1000\n\nstatic void\nstart_spi_intr_handling(struct qcaspi *qca, u16 *intr_cause)\n{\n\t*intr_cause = 0;\n\n\tqcaspi_write_register(qca, SPI_REG_INTR_ENABLE, 0, wr_verify);\n\tqcaspi_read_register(qca, SPI_REG_INTR_CAUSE, intr_cause);\n\tnetdev_dbg(qca->net_dev, \"interrupts: 0x%04x\\n\", *intr_cause);\n}\n\nstatic void\nend_spi_intr_handling(struct qcaspi *qca, u16 intr_cause)\n{\n\tu16 intr_enable = (SPI_INT_CPU_ON |\n\t\t\t   SPI_INT_PKT_AVLBL |\n\t\t\t   SPI_INT_RDBUF_ERR |\n\t\t\t   SPI_INT_WRBUF_ERR);\n\n\tqcaspi_write_register(qca, SPI_REG_INTR_CAUSE, intr_cause, 0);\n\tqcaspi_write_register(qca, SPI_REG_INTR_ENABLE, intr_enable, wr_verify);\n\tnetdev_dbg(qca->net_dev, \"acking int: 0x%04x\\n\", intr_cause);\n}\n\nstatic u32\nqcaspi_write_burst(struct qcaspi *qca, u8 *src, u32 len)\n{\n\t__be16 cmd;\n\tstruct spi_message msg;\n\tstruct spi_transfer transfer[2];\n\tint ret;\n\n\tmemset(&transfer, 0, sizeof(transfer));\n\tspi_message_init(&msg);\n\n\tcmd = cpu_to_be16(QCA7K_SPI_WRITE | QCA7K_SPI_EXTERNAL);\n\ttransfer[0].tx_buf = &cmd;\n\ttransfer[0].len = QCASPI_CMD_LEN;\n\ttransfer[1].tx_buf = src;\n\ttransfer[1].len = len;\n\n\tspi_message_add_tail(&transfer[0], &msg);\n\tspi_message_add_tail(&transfer[1], &msg);\n\tret = spi_sync(qca->spi_dev, &msg);\n\n\tif (ret || (msg.actual_length != QCASPI_CMD_LEN + len)) {\n\t\tqcaspi_spi_error(qca);\n\t\treturn 0;\n\t}\n\n\treturn len;\n}\n\nstatic u32\nqcaspi_write_legacy(struct qcaspi *qca, u8 *src, u32 len)\n{\n\tstruct spi_message msg;\n\tstruct spi_transfer transfer;\n\tint ret;\n\n\tmemset(&transfer, 0, sizeof(transfer));\n\tspi_message_init(&msg);\n\n\ttransfer.tx_buf = src;\n\ttransfer.len = len;\n\n\tspi_message_add_tail(&transfer, &msg);\n\tret = spi_sync(qca->spi_dev, &msg);\n\n\tif (ret || (msg.actual_length != len)) {\n\t\tqcaspi_spi_error(qca);\n\t\treturn 0;\n\t}\n\n\treturn len;\n}\n\nstatic u32\nqcaspi_read_burst(struct qcaspi *qca, u8 *dst, u32 len)\n{\n\tstruct spi_message msg;\n\t__be16 cmd;\n\tstruct spi_transfer transfer[2];\n\tint ret;\n\n\tmemset(&transfer, 0, sizeof(transfer));\n\tspi_message_init(&msg);\n\n\tcmd = cpu_to_be16(QCA7K_SPI_READ | QCA7K_SPI_EXTERNAL);\n\ttransfer[0].tx_buf = &cmd;\n\ttransfer[0].len = QCASPI_CMD_LEN;\n\ttransfer[1].rx_buf = dst;\n\ttransfer[1].len = len;\n\n\tspi_message_add_tail(&transfer[0], &msg);\n\tspi_message_add_tail(&transfer[1], &msg);\n\tret = spi_sync(qca->spi_dev, &msg);\n\n\tif (ret || (msg.actual_length != QCASPI_CMD_LEN + len)) {\n\t\tqcaspi_spi_error(qca);\n\t\treturn 0;\n\t}\n\n\treturn len;\n}\n\nstatic u32\nqcaspi_read_legacy(struct qcaspi *qca, u8 *dst, u32 len)\n{\n\tstruct spi_message msg;\n\tstruct spi_transfer transfer;\n\tint ret;\n\n\tmemset(&transfer, 0, sizeof(transfer));\n\tspi_message_init(&msg);\n\n\ttransfer.rx_buf = dst;\n\ttransfer.len = len;\n\n\tspi_message_add_tail(&transfer, &msg);\n\tret = spi_sync(qca->spi_dev, &msg);\n\n\tif (ret || (msg.actual_length != len)) {\n\t\tqcaspi_spi_error(qca);\n\t\treturn 0;\n\t}\n\n\treturn len;\n}\n\nstatic int\nqcaspi_tx_cmd(struct qcaspi *qca, u16 cmd)\n{\n\t__be16 tx_data;\n\tstruct spi_message msg;\n\tstruct spi_transfer transfer;\n\tint ret;\n\n\tmemset(&transfer, 0, sizeof(transfer));\n\n\tspi_message_init(&msg);\n\n\ttx_data = cpu_to_be16(cmd);\n\ttransfer.len = sizeof(cmd);\n\ttransfer.tx_buf = &tx_data;\n\tspi_message_add_tail(&transfer, &msg);\n\n\tret = spi_sync(qca->spi_dev, &msg);\n\n\tif (!ret)\n\t\tret = msg.status;\n\n\tif (ret)\n\t\tqcaspi_spi_error(qca);\n\n\treturn ret;\n}\n\nstatic int\nqcaspi_tx_frame(struct qcaspi *qca, struct sk_buff *skb)\n{\n\tu32 count;\n\tu32 written;\n\tu32 offset;\n\tu32 len;\n\n\tlen = skb->len;\n\n\tqcaspi_write_register(qca, SPI_REG_BFR_SIZE, len, wr_verify);\n\tif (qca->legacy_mode)\n\t\tqcaspi_tx_cmd(qca, QCA7K_SPI_WRITE | QCA7K_SPI_EXTERNAL);\n\n\toffset = 0;\n\twhile (len) {\n\t\tcount = len;\n\t\tif (count > qca->burst_len)\n\t\t\tcount = qca->burst_len;\n\n\t\tif (qca->legacy_mode) {\n\t\t\twritten = qcaspi_write_legacy(qca,\n\t\t\t\t\t\t      skb->data + offset,\n\t\t\t\t\t\t      count);\n\t\t} else {\n\t\t\twritten = qcaspi_write_burst(qca,\n\t\t\t\t\t\t     skb->data + offset,\n\t\t\t\t\t\t     count);\n\t\t}\n\n\t\tif (written != count)\n\t\t\treturn -1;\n\n\t\toffset += count;\n\t\tlen -= count;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nqcaspi_transmit(struct qcaspi *qca)\n{\n\tstruct net_device_stats *n_stats = &qca->net_dev->stats;\n\tu16 available = 0;\n\tu32 pkt_len;\n\tu16 new_head;\n\tu16 packets = 0;\n\n\tif (qca->txr.skb[qca->txr.head] == NULL)\n\t\treturn 0;\n\n\tqcaspi_read_register(qca, SPI_REG_WRBUF_SPC_AVA, &available);\n\n\tif (available > QCASPI_HW_BUF_LEN) {\n\t\t \n\t\tqca->stats.buf_avail_err++;\n\t\treturn -1;\n\t}\n\n\twhile (qca->txr.skb[qca->txr.head]) {\n\t\tpkt_len = qca->txr.skb[qca->txr.head]->len + QCASPI_HW_PKT_LEN;\n\n\t\tif (available < pkt_len) {\n\t\t\tif (packets == 0)\n\t\t\t\tqca->stats.write_buf_miss++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (qcaspi_tx_frame(qca, qca->txr.skb[qca->txr.head]) == -1) {\n\t\t\tqca->stats.write_err++;\n\t\t\treturn -1;\n\t\t}\n\n\t\tpackets++;\n\t\tn_stats->tx_packets++;\n\t\tn_stats->tx_bytes += qca->txr.skb[qca->txr.head]->len;\n\t\tavailable -= pkt_len;\n\n\t\t \n\t\t \n\t\tnetif_tx_lock_bh(qca->net_dev);\n\t\tdev_kfree_skb(qca->txr.skb[qca->txr.head]);\n\t\tqca->txr.skb[qca->txr.head] = NULL;\n\t\tqca->txr.size -= pkt_len;\n\t\tnew_head = qca->txr.head + 1;\n\t\tif (new_head >= qca->txr.count)\n\t\t\tnew_head = 0;\n\t\tqca->txr.head = new_head;\n\t\tif (netif_queue_stopped(qca->net_dev))\n\t\t\tnetif_wake_queue(qca->net_dev);\n\t\tnetif_tx_unlock_bh(qca->net_dev);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nqcaspi_receive(struct qcaspi *qca)\n{\n\tstruct net_device *net_dev = qca->net_dev;\n\tstruct net_device_stats *n_stats = &net_dev->stats;\n\tu16 available = 0;\n\tu32 bytes_read;\n\tu8 *cp;\n\n\t \n\tif (!qca->rx_skb) {\n\t\tqca->rx_skb = netdev_alloc_skb_ip_align(net_dev,\n\t\t\t\t\t\t\tnet_dev->mtu +\n\t\t\t\t\t\t\tVLAN_ETH_HLEN);\n\t\tif (!qca->rx_skb) {\n\t\t\tnetdev_dbg(net_dev, \"out of RX resources\\n\");\n\t\t\tqca->stats.out_of_mem++;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t \n\tqcaspi_read_register(qca, SPI_REG_RDBUF_BYTE_AVA, &available);\n\n\tnetdev_dbg(net_dev, \"qcaspi_receive: SPI_REG_RDBUF_BYTE_AVA: Value: %08x\\n\",\n\t\t   available);\n\n\tif (available > QCASPI_HW_BUF_LEN + QCASPI_HW_PKT_LEN) {\n\t\t \n\t\tqca->stats.buf_avail_err++;\n\t\treturn -1;\n\t} else if (available == 0) {\n\t\tnetdev_dbg(net_dev, \"qcaspi_receive called without any data being available!\\n\");\n\t\treturn -1;\n\t}\n\n\tqcaspi_write_register(qca, SPI_REG_BFR_SIZE, available, wr_verify);\n\n\tif (qca->legacy_mode)\n\t\tqcaspi_tx_cmd(qca, QCA7K_SPI_READ | QCA7K_SPI_EXTERNAL);\n\n\twhile (available) {\n\t\tu32 count = available;\n\n\t\tif (count > qca->burst_len)\n\t\t\tcount = qca->burst_len;\n\n\t\tif (qca->legacy_mode) {\n\t\t\tbytes_read = qcaspi_read_legacy(qca, qca->rx_buffer,\n\t\t\t\t\t\t\tcount);\n\t\t} else {\n\t\t\tbytes_read = qcaspi_read_burst(qca, qca->rx_buffer,\n\t\t\t\t\t\t       count);\n\t\t}\n\n\t\tnetdev_dbg(net_dev, \"available: %d, byte read: %d\\n\",\n\t\t\t   available, bytes_read);\n\n\t\tif (bytes_read) {\n\t\t\tavailable -= bytes_read;\n\t\t} else {\n\t\t\tqca->stats.read_err++;\n\t\t\treturn -1;\n\t\t}\n\n\t\tcp = qca->rx_buffer;\n\n\t\twhile ((bytes_read--) && (qca->rx_skb)) {\n\t\t\ts32 retcode;\n\n\t\t\tretcode = qcafrm_fsm_decode(&qca->frm_handle,\n\t\t\t\t\t\t    qca->rx_skb->data,\n\t\t\t\t\t\t    skb_tailroom(qca->rx_skb),\n\t\t\t\t\t\t    *cp);\n\t\t\tcp++;\n\t\t\tswitch (retcode) {\n\t\t\tcase QCAFRM_GATHER:\n\t\t\tcase QCAFRM_NOHEAD:\n\t\t\t\tbreak;\n\t\t\tcase QCAFRM_NOTAIL:\n\t\t\t\tnetdev_dbg(net_dev, \"no RX tail\\n\");\n\t\t\t\tn_stats->rx_errors++;\n\t\t\t\tn_stats->rx_dropped++;\n\t\t\t\tbreak;\n\t\t\tcase QCAFRM_INVLEN:\n\t\t\t\tnetdev_dbg(net_dev, \"invalid RX length\\n\");\n\t\t\t\tn_stats->rx_errors++;\n\t\t\t\tn_stats->rx_dropped++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tqca->rx_skb->dev = qca->net_dev;\n\t\t\t\tn_stats->rx_packets++;\n\t\t\t\tn_stats->rx_bytes += retcode;\n\t\t\t\tskb_put(qca->rx_skb, retcode);\n\t\t\t\tqca->rx_skb->protocol = eth_type_trans(\n\t\t\t\t\tqca->rx_skb, qca->rx_skb->dev);\n\t\t\t\tskb_checksum_none_assert(qca->rx_skb);\n\t\t\t\tnetif_rx(qca->rx_skb);\n\t\t\t\tqca->rx_skb = netdev_alloc_skb_ip_align(net_dev,\n\t\t\t\t\tnet_dev->mtu + VLAN_ETH_HLEN);\n\t\t\t\tif (!qca->rx_skb) {\n\t\t\t\t\tnetdev_dbg(net_dev, \"out of RX resources\\n\");\n\t\t\t\t\tn_stats->rx_errors++;\n\t\t\t\t\tqca->stats.out_of_mem++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int\nqcaspi_tx_ring_has_space(struct tx_ring *txr)\n{\n\tif (txr->skb[txr->tail])\n\t\treturn 0;\n\n\treturn (txr->size + QCAFRM_MAX_LEN < QCASPI_HW_BUF_LEN) ? 1 : 0;\n}\n\n \n\nstatic void\nqcaspi_flush_tx_ring(struct qcaspi *qca)\n{\n\tint i;\n\n\t \n\tnetif_tx_lock_bh(qca->net_dev);\n\tfor (i = 0; i < TX_RING_MAX_LEN; i++) {\n\t\tif (qca->txr.skb[i]) {\n\t\t\tdev_kfree_skb(qca->txr.skb[i]);\n\t\t\tqca->txr.skb[i] = NULL;\n\t\t\tqca->net_dev->stats.tx_dropped++;\n\t\t}\n\t}\n\tqca->txr.tail = 0;\n\tqca->txr.head = 0;\n\tqca->txr.size = 0;\n\tnetif_tx_unlock_bh(qca->net_dev);\n}\n\nstatic void\nqcaspi_qca7k_sync(struct qcaspi *qca, int event)\n{\n\tu16 signature = 0;\n\tu16 spi_config;\n\tu16 wrbuf_space = 0;\n\n\tif (event == QCASPI_EVENT_CPUON) {\n\t\t \n\t\tqcaspi_read_register(qca, SPI_REG_SIGNATURE, &signature);\n\t\tqcaspi_read_register(qca, SPI_REG_SIGNATURE, &signature);\n\t\tif (signature != QCASPI_GOOD_SIGNATURE) {\n\t\t\tif (qca->sync == QCASPI_SYNC_READY)\n\t\t\t\tqca->stats.bad_signature++;\n\n\t\t\tqca->sync = QCASPI_SYNC_UNKNOWN;\n\t\t\tnetdev_dbg(qca->net_dev, \"sync: got CPU on, but signature was invalid, restart\\n\");\n\t\t\treturn;\n\t\t} else {\n\t\t\t \n\t\t\tqcaspi_read_register(qca, SPI_REG_WRBUF_SPC_AVA,\n\t\t\t\t\t     &wrbuf_space);\n\t\t\tif (wrbuf_space != QCASPI_HW_BUF_LEN) {\n\t\t\t\tnetdev_dbg(qca->net_dev, \"sync: got CPU on, but wrbuf not empty. reset!\\n\");\n\t\t\t\tqca->sync = QCASPI_SYNC_UNKNOWN;\n\t\t\t} else {\n\t\t\t\tnetdev_dbg(qca->net_dev, \"sync: got CPU on, now in sync\\n\");\n\t\t\t\tqca->sync = QCASPI_SYNC_READY;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (qca->sync) {\n\tcase QCASPI_SYNC_READY:\n\t\t \n\t\tqcaspi_read_register(qca, SPI_REG_SIGNATURE, &signature);\n\t\tif (signature != QCASPI_GOOD_SIGNATURE)\n\t\t\tqcaspi_read_register(qca, SPI_REG_SIGNATURE, &signature);\n\n\t\tif (signature != QCASPI_GOOD_SIGNATURE) {\n\t\t\tqca->sync = QCASPI_SYNC_UNKNOWN;\n\t\t\tqca->stats.bad_signature++;\n\t\t\tnetdev_dbg(qca->net_dev, \"sync: bad signature, restart\\n\");\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase QCASPI_SYNC_UNKNOWN:\n\t\t \n\t\tqcaspi_read_register(qca, SPI_REG_SIGNATURE, &signature);\n\t\tif (signature != QCASPI_GOOD_SIGNATURE) {\n\t\t\tnetdev_dbg(qca->net_dev, \"sync: could not read signature to reset device, retry.\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tnetdev_dbg(qca->net_dev, \"sync: resetting device.\\n\");\n\t\tqcaspi_read_register(qca, SPI_REG_SPI_CONFIG, &spi_config);\n\t\tspi_config |= QCASPI_SLAVE_RESET_BIT;\n\t\tqcaspi_write_register(qca, SPI_REG_SPI_CONFIG, spi_config, 0);\n\n\t\tqca->sync = QCASPI_SYNC_RESET;\n\t\tqca->stats.trig_reset++;\n\t\tqca->reset_count = 0;\n\t\tbreak;\n\tcase QCASPI_SYNC_RESET:\n\t\tqca->reset_count++;\n\t\tnetdev_dbg(qca->net_dev, \"sync: waiting for CPU on, count %u.\\n\",\n\t\t\t   qca->reset_count);\n\t\tif (qca->reset_count >= QCASPI_RESET_TIMEOUT) {\n\t\t\t \n\t\t\tqca->sync = QCASPI_SYNC_UNKNOWN;\n\t\t\tqca->stats.reset_timeout++;\n\t\t\tnetdev_dbg(qca->net_dev, \"sync: reset timeout, restarting process.\\n\");\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic int\nqcaspi_spi_thread(void *data)\n{\n\tstruct qcaspi *qca = data;\n\tu16 intr_cause = 0;\n\n\tnetdev_info(qca->net_dev, \"SPI thread created\\n\");\n\twhile (!kthread_should_stop()) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (kthread_should_park()) {\n\t\t\tnetif_tx_disable(qca->net_dev);\n\t\t\tnetif_carrier_off(qca->net_dev);\n\t\t\tqcaspi_flush_tx_ring(qca);\n\t\t\tkthread_parkme();\n\t\t\tif (qca->sync == QCASPI_SYNC_READY) {\n\t\t\t\tnetif_carrier_on(qca->net_dev);\n\t\t\t\tnetif_wake_queue(qca->net_dev);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((qca->intr_req == qca->intr_svc) &&\n\t\t    !qca->txr.skb[qca->txr.head])\n\t\t\tschedule();\n\n\t\tset_current_state(TASK_RUNNING);\n\n\t\tnetdev_dbg(qca->net_dev, \"have work to do. int: %d, tx_skb: %p\\n\",\n\t\t\t   qca->intr_req - qca->intr_svc,\n\t\t\t   qca->txr.skb[qca->txr.head]);\n\n\t\tqcaspi_qca7k_sync(qca, QCASPI_EVENT_UPDATE);\n\n\t\tif (qca->sync != QCASPI_SYNC_READY) {\n\t\t\tnetdev_dbg(qca->net_dev, \"sync: not ready %u, turn off carrier and flush\\n\",\n\t\t\t\t   (unsigned int)qca->sync);\n\t\t\tnetif_stop_queue(qca->net_dev);\n\t\t\tnetif_carrier_off(qca->net_dev);\n\t\t\tqcaspi_flush_tx_ring(qca);\n\t\t\tmsleep(QCASPI_QCA7K_REBOOT_TIME_MS);\n\t\t}\n\n\t\tif (qca->intr_svc != qca->intr_req) {\n\t\t\tqca->intr_svc = qca->intr_req;\n\t\t\tstart_spi_intr_handling(qca, &intr_cause);\n\n\t\t\tif (intr_cause & SPI_INT_CPU_ON) {\n\t\t\t\tqcaspi_qca7k_sync(qca, QCASPI_EVENT_CPUON);\n\n\t\t\t\t \n\t\t\t\tif (qca->frm_handle.state != qca->frm_handle.init)\n\t\t\t\t\tqca->net_dev->stats.rx_dropped++;\n\n\t\t\t\tqcafrm_fsm_init_spi(&qca->frm_handle);\n\t\t\t\tqca->stats.device_reset++;\n\n\t\t\t\t \n\t\t\t\tif (qca->sync != QCASPI_SYNC_READY)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tnetif_wake_queue(qca->net_dev);\n\t\t\t\tnetif_carrier_on(qca->net_dev);\n\t\t\t}\n\n\t\t\tif (intr_cause & SPI_INT_RDBUF_ERR) {\n\t\t\t\t \n\t\t\t\tnetdev_dbg(qca->net_dev, \"===> rdbuf error!\\n\");\n\t\t\t\tqca->stats.read_buf_err++;\n\t\t\t\tqca->sync = QCASPI_SYNC_UNKNOWN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (intr_cause & SPI_INT_WRBUF_ERR) {\n\t\t\t\t \n\t\t\t\tnetdev_dbg(qca->net_dev, \"===> wrbuf error!\\n\");\n\t\t\t\tqca->stats.write_buf_err++;\n\t\t\t\tqca->sync = QCASPI_SYNC_UNKNOWN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (qca->sync == QCASPI_SYNC_READY) {\n\t\t\t\tif (intr_cause & SPI_INT_PKT_AVLBL)\n\t\t\t\t\tqcaspi_receive(qca);\n\t\t\t}\n\n\t\t\tend_spi_intr_handling(qca, intr_cause);\n\t\t}\n\n\t\tif (qca->sync == QCASPI_SYNC_READY)\n\t\t\tqcaspi_transmit(qca);\n\t}\n\tset_current_state(TASK_RUNNING);\n\tnetdev_info(qca->net_dev, \"SPI thread exit\\n\");\n\n\treturn 0;\n}\n\nstatic irqreturn_t\nqcaspi_intr_handler(int irq, void *data)\n{\n\tstruct qcaspi *qca = data;\n\n\tqca->intr_req++;\n\tif (qca->spi_thread)\n\t\twake_up_process(qca->spi_thread);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int\nqcaspi_netdev_open(struct net_device *dev)\n{\n\tstruct qcaspi *qca = netdev_priv(dev);\n\tint ret = 0;\n\n\tif (!qca)\n\t\treturn -EINVAL;\n\n\tqca->intr_req = 1;\n\tqca->intr_svc = 0;\n\tqca->sync = QCASPI_SYNC_UNKNOWN;\n\tqcafrm_fsm_init_spi(&qca->frm_handle);\n\n\tqca->spi_thread = kthread_run((void *)qcaspi_spi_thread,\n\t\t\t\t      qca, \"%s\", dev->name);\n\n\tif (IS_ERR(qca->spi_thread)) {\n\t\tnetdev_err(dev, \"%s: unable to start kernel thread.\\n\",\n\t\t\t   QCASPI_DRV_NAME);\n\t\treturn PTR_ERR(qca->spi_thread);\n\t}\n\n\tret = request_irq(qca->spi_dev->irq, qcaspi_intr_handler, 0,\n\t\t\t  dev->name, qca);\n\tif (ret) {\n\t\tnetdev_err(dev, \"%s: unable to get IRQ %d (irqval=%d).\\n\",\n\t\t\t   QCASPI_DRV_NAME, qca->spi_dev->irq, ret);\n\t\tkthread_stop(qca->spi_thread);\n\t\treturn ret;\n\t}\n\n\t \n\n\treturn 0;\n}\n\nstatic int\nqcaspi_netdev_close(struct net_device *dev)\n{\n\tstruct qcaspi *qca = netdev_priv(dev);\n\n\tnetif_stop_queue(dev);\n\n\tqcaspi_write_register(qca, SPI_REG_INTR_ENABLE, 0, wr_verify);\n\tfree_irq(qca->spi_dev->irq, qca);\n\n\tkthread_stop(qca->spi_thread);\n\tqca->spi_thread = NULL;\n\tqcaspi_flush_tx_ring(qca);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t\nqcaspi_netdev_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tu32 frame_len;\n\tu8 *ptmp;\n\tstruct qcaspi *qca = netdev_priv(dev);\n\tu16 new_tail;\n\tstruct sk_buff *tskb;\n\tu8 pad_len = 0;\n\n\tif (skb->len < QCAFRM_MIN_LEN)\n\t\tpad_len = QCAFRM_MIN_LEN - skb->len;\n\n\tif (qca->txr.skb[qca->txr.tail]) {\n\t\tnetdev_warn(qca->net_dev, \"queue was unexpectedly full!\\n\");\n\t\tnetif_stop_queue(qca->net_dev);\n\t\tqca->stats.ring_full++;\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tif ((skb_headroom(skb) < QCAFRM_HEADER_LEN) ||\n\t    (skb_tailroom(skb) < QCAFRM_FOOTER_LEN + pad_len)) {\n\t\ttskb = skb_copy_expand(skb, QCAFRM_HEADER_LEN,\n\t\t\t\t       QCAFRM_FOOTER_LEN + pad_len, GFP_ATOMIC);\n\t\tif (!tskb) {\n\t\t\tqca->stats.out_of_mem++;\n\t\t\treturn NETDEV_TX_BUSY;\n\t\t}\n\t\tdev_kfree_skb(skb);\n\t\tskb = tskb;\n\t}\n\n\tframe_len = skb->len + pad_len;\n\n\tptmp = skb_push(skb, QCAFRM_HEADER_LEN);\n\tqcafrm_create_header(ptmp, frame_len);\n\n\tif (pad_len) {\n\t\tptmp = skb_put_zero(skb, pad_len);\n\t}\n\n\tptmp = skb_put(skb, QCAFRM_FOOTER_LEN);\n\tqcafrm_create_footer(ptmp);\n\n\tnetdev_dbg(qca->net_dev, \"Tx-ing packet: Size: 0x%08x\\n\",\n\t\t   skb->len);\n\n\tqca->txr.size += skb->len + QCASPI_HW_PKT_LEN;\n\n\tnew_tail = qca->txr.tail + 1;\n\tif (new_tail >= qca->txr.count)\n\t\tnew_tail = 0;\n\n\tqca->txr.skb[qca->txr.tail] = skb;\n\tqca->txr.tail = new_tail;\n\n\tif (!qcaspi_tx_ring_has_space(&qca->txr)) {\n\t\tnetif_stop_queue(qca->net_dev);\n\t\tqca->stats.ring_full++;\n\t}\n\n\tnetif_trans_update(dev);\n\n\tif (qca->spi_thread)\n\t\twake_up_process(qca->spi_thread);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void\nqcaspi_netdev_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct qcaspi *qca = netdev_priv(dev);\n\n\tnetdev_info(qca->net_dev, \"Transmit timeout at %ld, latency %ld\\n\",\n\t\t    jiffies, jiffies - dev_trans_start(dev));\n\tqca->net_dev->stats.tx_errors++;\n\t \n\tqca->sync = QCASPI_SYNC_UNKNOWN;\n\n\tif (qca->spi_thread)\n\t\twake_up_process(qca->spi_thread);\n}\n\nstatic int\nqcaspi_netdev_init(struct net_device *dev)\n{\n\tstruct qcaspi *qca = netdev_priv(dev);\n\n\tdev->mtu = QCAFRM_MAX_MTU;\n\tdev->type = ARPHRD_ETHER;\n\tqca->clkspeed = qcaspi_clkspeed;\n\tqca->burst_len = qcaspi_burst_len;\n\tqca->spi_thread = NULL;\n\tqca->buffer_size = (dev->mtu + VLAN_ETH_HLEN + QCAFRM_HEADER_LEN +\n\t\tQCAFRM_FOOTER_LEN + 4) * 4;\n\n\tmemset(&qca->stats, 0, sizeof(struct qcaspi_stats));\n\n\tqca->rx_buffer = kmalloc(qca->buffer_size, GFP_KERNEL);\n\tif (!qca->rx_buffer)\n\t\treturn -ENOBUFS;\n\n\tqca->rx_skb = netdev_alloc_skb_ip_align(dev, qca->net_dev->mtu +\n\t\t\t\t\t\tVLAN_ETH_HLEN);\n\tif (!qca->rx_skb) {\n\t\tkfree(qca->rx_buffer);\n\t\tnetdev_info(qca->net_dev, \"Failed to allocate RX sk_buff.\\n\");\n\t\treturn -ENOBUFS;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nqcaspi_netdev_uninit(struct net_device *dev)\n{\n\tstruct qcaspi *qca = netdev_priv(dev);\n\n\tkfree(qca->rx_buffer);\n\tqca->buffer_size = 0;\n\tdev_kfree_skb(qca->rx_skb);\n}\n\nstatic const struct net_device_ops qcaspi_netdev_ops = {\n\t.ndo_init = qcaspi_netdev_init,\n\t.ndo_uninit = qcaspi_netdev_uninit,\n\t.ndo_open = qcaspi_netdev_open,\n\t.ndo_stop = qcaspi_netdev_close,\n\t.ndo_start_xmit = qcaspi_netdev_xmit,\n\t.ndo_set_mac_address = eth_mac_addr,\n\t.ndo_tx_timeout = qcaspi_netdev_tx_timeout,\n\t.ndo_validate_addr = eth_validate_addr,\n};\n\nstatic void\nqcaspi_netdev_setup(struct net_device *dev)\n{\n\tstruct qcaspi *qca = NULL;\n\n\tdev->netdev_ops = &qcaspi_netdev_ops;\n\tqcaspi_set_ethtool_ops(dev);\n\tdev->watchdog_timeo = QCASPI_TX_TIMEOUT;\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->tx_queue_len = 100;\n\n\t \n\tdev->min_mtu = QCAFRM_MIN_MTU;\n\tdev->max_mtu = QCAFRM_MAX_MTU;\n\n\tqca = netdev_priv(dev);\n\tmemset(qca, 0, sizeof(struct qcaspi));\n\n\tmemset(&qca->txr, 0, sizeof(qca->txr));\n\tqca->txr.count = TX_RING_MAX_LEN;\n}\n\nstatic const struct of_device_id qca_spi_of_match[] = {\n\t{ .compatible = \"qca,qca7000\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, qca_spi_of_match);\n\nstatic int\nqca_spi_probe(struct spi_device *spi)\n{\n\tstruct qcaspi *qca = NULL;\n\tstruct net_device *qcaspi_devs = NULL;\n\tu8 legacy_mode = 0;\n\tu16 signature;\n\tint ret;\n\n\tif (!spi->dev.of_node) {\n\t\tdev_err(&spi->dev, \"Missing device tree\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlegacy_mode = of_property_read_bool(spi->dev.of_node,\n\t\t\t\t\t    \"qca,legacy-mode\");\n\n\tif (qcaspi_clkspeed == 0) {\n\t\tif (spi->max_speed_hz)\n\t\t\tqcaspi_clkspeed = spi->max_speed_hz;\n\t\telse\n\t\t\tqcaspi_clkspeed = QCASPI_CLK_SPEED;\n\t}\n\n\tif ((qcaspi_clkspeed < QCASPI_CLK_SPEED_MIN) ||\n\t    (qcaspi_clkspeed > QCASPI_CLK_SPEED_MAX)) {\n\t\tdev_err(&spi->dev, \"Invalid clkspeed: %d\\n\",\n\t\t\tqcaspi_clkspeed);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((qcaspi_burst_len < QCASPI_BURST_LEN_MIN) ||\n\t    (qcaspi_burst_len > QCASPI_BURST_LEN_MAX)) {\n\t\tdev_err(&spi->dev, \"Invalid burst len: %d\\n\",\n\t\t\tqcaspi_burst_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((qcaspi_pluggable < QCASPI_PLUGGABLE_MIN) ||\n\t    (qcaspi_pluggable > QCASPI_PLUGGABLE_MAX)) {\n\t\tdev_err(&spi->dev, \"Invalid pluggable: %d\\n\",\n\t\t\tqcaspi_pluggable);\n\t\treturn -EINVAL;\n\t}\n\n\tif (wr_verify < QCASPI_WRITE_VERIFY_MIN ||\n\t    wr_verify > QCASPI_WRITE_VERIFY_MAX) {\n\t\tdev_err(&spi->dev, \"Invalid write verify: %d\\n\",\n\t\t\twr_verify);\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(&spi->dev, \"ver=%s, clkspeed=%d, burst_len=%d, pluggable=%d\\n\",\n\t\t QCASPI_DRV_VERSION,\n\t\t qcaspi_clkspeed,\n\t\t qcaspi_burst_len,\n\t\t qcaspi_pluggable);\n\n\tspi->mode = SPI_MODE_3;\n\tspi->max_speed_hz = qcaspi_clkspeed;\n\tif (spi_setup(spi) < 0) {\n\t\tdev_err(&spi->dev, \"Unable to setup SPI device\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tqcaspi_devs = alloc_etherdev(sizeof(struct qcaspi));\n\tif (!qcaspi_devs)\n\t\treturn -ENOMEM;\n\n\tqcaspi_netdev_setup(qcaspi_devs);\n\tSET_NETDEV_DEV(qcaspi_devs, &spi->dev);\n\n\tqca = netdev_priv(qcaspi_devs);\n\tif (!qca) {\n\t\tfree_netdev(qcaspi_devs);\n\t\tdev_err(&spi->dev, \"Fail to retrieve private structure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tqca->net_dev = qcaspi_devs;\n\tqca->spi_dev = spi;\n\tqca->legacy_mode = legacy_mode;\n\n\tspi_set_drvdata(spi, qcaspi_devs);\n\n\tret = of_get_ethdev_address(spi->dev.of_node, qca->net_dev);\n\tif (ret) {\n\t\teth_hw_addr_random(qca->net_dev);\n\t\tdev_info(&spi->dev, \"Using random MAC address: %pM\\n\",\n\t\t\t qca->net_dev->dev_addr);\n\t}\n\n\tnetif_carrier_off(qca->net_dev);\n\n\tif (!qcaspi_pluggable) {\n\t\tqcaspi_read_register(qca, SPI_REG_SIGNATURE, &signature);\n\t\tqcaspi_read_register(qca, SPI_REG_SIGNATURE, &signature);\n\n\t\tif (signature != QCASPI_GOOD_SIGNATURE) {\n\t\t\tdev_err(&spi->dev, \"Invalid signature (0x%04X)\\n\",\n\t\t\t\tsignature);\n\t\t\tfree_netdev(qcaspi_devs);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tif (register_netdev(qcaspi_devs)) {\n\t\tdev_err(&spi->dev, \"Unable to register net device %s\\n\",\n\t\t\tqcaspi_devs->name);\n\t\tfree_netdev(qcaspi_devs);\n\t\treturn -EFAULT;\n\t}\n\n\tqcaspi_init_device_debugfs(qca);\n\n\treturn 0;\n}\n\nstatic void\nqca_spi_remove(struct spi_device *spi)\n{\n\tstruct net_device *qcaspi_devs = spi_get_drvdata(spi);\n\tstruct qcaspi *qca = netdev_priv(qcaspi_devs);\n\n\tqcaspi_remove_device_debugfs(qca);\n\n\tunregister_netdev(qcaspi_devs);\n\tfree_netdev(qcaspi_devs);\n}\n\nstatic const struct spi_device_id qca_spi_id[] = {\n\t{ \"qca7000\", 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(spi, qca_spi_id);\n\nstatic struct spi_driver qca_spi_driver = {\n\t.driver\t= {\n\t\t.name\t= QCASPI_DRV_NAME,\n\t\t.of_match_table = qca_spi_of_match,\n\t},\n\t.id_table = qca_spi_id,\n\t.probe    = qca_spi_probe,\n\t.remove   = qca_spi_remove,\n};\nmodule_spi_driver(qca_spi_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm Atheros QCA7000 SPI Driver\");\nMODULE_AUTHOR(\"Qualcomm Atheros Communications\");\nMODULE_AUTHOR(\"Stefan Wahren <stefan.wahren@i2se.com>\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_VERSION(QCASPI_DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}