{
  "module_name": "rmnet_config.c",
  "hash_id": "15dee25aa73e3d49dd29a136653413d29ebd4d189e28c6efc20a60c1a52580ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c",
  "human_readable_source": "\n \n\n#include <net/sock.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netdevice.h>\n#include \"rmnet_config.h\"\n#include \"rmnet_handlers.h\"\n#include \"rmnet_vnd.h\"\n#include \"rmnet_private.h\"\n#include \"rmnet_map.h\"\n\n \n\nstatic const struct nla_policy rmnet_policy[IFLA_RMNET_MAX + 1] = {\n\t[IFLA_RMNET_MUX_ID]\t= { .type = NLA_U16 },\n\t[IFLA_RMNET_FLAGS]\t= { .len = sizeof(struct ifla_rmnet_flags) },\n};\n\nstatic int rmnet_is_real_dev_registered(const struct net_device *real_dev)\n{\n\treturn rcu_access_pointer(real_dev->rx_handler) == rmnet_rx_handler;\n}\n\n \nstruct rmnet_port*\nrmnet_get_port_rtnl(const struct net_device *real_dev)\n{\n\treturn rtnl_dereference(real_dev->rx_handler_data);\n}\n\nstatic int rmnet_unregister_real_device(struct net_device *real_dev)\n{\n\tstruct rmnet_port *port = rmnet_get_port_rtnl(real_dev);\n\n\tif (port->nr_rmnet_devs)\n\t\treturn -EINVAL;\n\n\trmnet_map_tx_aggregate_exit(port);\n\n\tnetdev_rx_handler_unregister(real_dev);\n\n\tkfree(port);\n\n\tnetdev_dbg(real_dev, \"Removed from rmnet\\n\");\n\treturn 0;\n}\n\nstatic int rmnet_register_real_device(struct net_device *real_dev,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct rmnet_port *port;\n\tint rc, entry;\n\n\tASSERT_RTNL();\n\n\tif (rmnet_is_real_dev_registered(real_dev)) {\n\t\tport = rmnet_get_port_rtnl(real_dev);\n\t\tif (port->rmnet_mode != RMNET_EPMODE_VND) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"bridge device already exists\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tport = kzalloc(sizeof(*port), GFP_KERNEL);\n\tif (!port)\n\t\treturn -ENOMEM;\n\n\tport->dev = real_dev;\n\trc = netdev_rx_handler_register(real_dev, rmnet_rx_handler, port);\n\tif (rc) {\n\t\tkfree(port);\n\t\treturn -EBUSY;\n\t}\n\n\tfor (entry = 0; entry < RMNET_MAX_LOGICAL_EP; entry++)\n\t\tINIT_HLIST_HEAD(&port->muxed_ep[entry]);\n\n\trmnet_map_tx_aggregate_init(port);\n\n\tnetdev_dbg(real_dev, \"registered with rmnet\\n\");\n\treturn 0;\n}\n\nstatic void rmnet_unregister_bridge(struct rmnet_port *port)\n{\n\tstruct net_device *bridge_dev, *real_dev, *rmnet_dev;\n\tstruct rmnet_port *real_port;\n\n\tif (port->rmnet_mode != RMNET_EPMODE_BRIDGE)\n\t\treturn;\n\n\trmnet_dev = port->rmnet_dev;\n\tif (!port->nr_rmnet_devs) {\n\t\t \n\t\treal_dev = port->bridge_ep;\n\t\tbridge_dev = port->dev;\n\n\t\treal_port = rmnet_get_port_rtnl(real_dev);\n\t\treal_port->bridge_ep = NULL;\n\t\treal_port->rmnet_mode = RMNET_EPMODE_VND;\n\t} else {\n\t\t \n\t\tbridge_dev = port->bridge_ep;\n\n\t\tport->bridge_ep = NULL;\n\t\tport->rmnet_mode = RMNET_EPMODE_VND;\n\t}\n\n\tnetdev_upper_dev_unlink(bridge_dev, rmnet_dev);\n\trmnet_unregister_real_device(bridge_dev);\n}\n\nstatic int rmnet_newlink(struct net *src_net, struct net_device *dev,\n\t\t\t struct nlattr *tb[], struct nlattr *data[],\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tu32 data_format = RMNET_FLAGS_INGRESS_DEAGGREGATION;\n\tstruct net_device *real_dev;\n\tint mode = RMNET_EPMODE_VND;\n\tstruct rmnet_endpoint *ep;\n\tstruct rmnet_port *port;\n\tint err = 0;\n\tu16 mux_id;\n\n\tif (!tb[IFLA_LINK]) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"link not specified\");\n\t\treturn -EINVAL;\n\t}\n\n\treal_dev = __dev_get_by_index(src_net, nla_get_u32(tb[IFLA_LINK]));\n\tif (!real_dev) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"link does not exist\");\n\t\treturn -ENODEV;\n\t}\n\n\tep = kzalloc(sizeof(*ep), GFP_KERNEL);\n\tif (!ep)\n\t\treturn -ENOMEM;\n\n\tmux_id = nla_get_u16(data[IFLA_RMNET_MUX_ID]);\n\n\terr = rmnet_register_real_device(real_dev, extack);\n\tif (err)\n\t\tgoto err0;\n\n\tport = rmnet_get_port_rtnl(real_dev);\n\terr = rmnet_vnd_newlink(mux_id, dev, port, real_dev, ep, extack);\n\tif (err)\n\t\tgoto err1;\n\n\terr = netdev_upper_dev_link(real_dev, dev, extack);\n\tif (err < 0)\n\t\tgoto err2;\n\n\tport->rmnet_mode = mode;\n\tport->rmnet_dev = dev;\n\n\thlist_add_head_rcu(&ep->hlnode, &port->muxed_ep[mux_id]);\n\n\tif (data[IFLA_RMNET_FLAGS]) {\n\t\tstruct ifla_rmnet_flags *flags;\n\n\t\tflags = nla_data(data[IFLA_RMNET_FLAGS]);\n\t\tdata_format &= ~flags->mask;\n\t\tdata_format |= flags->flags & flags->mask;\n\t}\n\n\tnetdev_dbg(dev, \"data format [0x%08X]\\n\", data_format);\n\tport->data_format = data_format;\n\n\treturn 0;\n\nerr2:\n\tunregister_netdevice(dev);\n\trmnet_vnd_dellink(mux_id, port, ep);\nerr1:\n\trmnet_unregister_real_device(real_dev);\nerr0:\n\tkfree(ep);\n\treturn err;\n}\n\nstatic void rmnet_dellink(struct net_device *dev, struct list_head *head)\n{\n\tstruct rmnet_priv *priv = netdev_priv(dev);\n\tstruct net_device *real_dev, *bridge_dev;\n\tstruct rmnet_port *real_port, *bridge_port;\n\tstruct rmnet_endpoint *ep;\n\tu8 mux_id = priv->mux_id;\n\n\treal_dev = priv->real_dev;\n\n\tif (!rmnet_is_real_dev_registered(real_dev))\n\t\treturn;\n\n\treal_port = rmnet_get_port_rtnl(real_dev);\n\tbridge_dev = real_port->bridge_ep;\n\tif (bridge_dev) {\n\t\tbridge_port = rmnet_get_port_rtnl(bridge_dev);\n\t\trmnet_unregister_bridge(bridge_port);\n\t}\n\n\tep = rmnet_get_endpoint(real_port, mux_id);\n\tif (ep) {\n\t\thlist_del_init_rcu(&ep->hlnode);\n\t\trmnet_vnd_dellink(mux_id, real_port, ep);\n\t\tkfree(ep);\n\t}\n\n\tnetdev_upper_dev_unlink(real_dev, dev);\n\trmnet_unregister_real_device(real_dev);\n\tunregister_netdevice_queue(dev, head);\n}\n\nstatic void rmnet_force_unassociate_device(struct net_device *real_dev)\n{\n\tstruct hlist_node *tmp_ep;\n\tstruct rmnet_endpoint *ep;\n\tstruct rmnet_port *port;\n\tunsigned long bkt_ep;\n\tLIST_HEAD(list);\n\n\tport = rmnet_get_port_rtnl(real_dev);\n\n\tif (port->nr_rmnet_devs) {\n\t\t \n\t\trmnet_unregister_bridge(port);\n\t\thash_for_each_safe(port->muxed_ep, bkt_ep, tmp_ep, ep, hlnode) {\n\t\t\tunregister_netdevice_queue(ep->egress_dev, &list);\n\t\t\tnetdev_upper_dev_unlink(real_dev, ep->egress_dev);\n\t\t\trmnet_vnd_dellink(ep->mux_id, port, ep);\n\t\t\thlist_del_init_rcu(&ep->hlnode);\n\t\t\tkfree(ep);\n\t\t}\n\t\trmnet_unregister_real_device(real_dev);\n\t\tunregister_netdevice_many(&list);\n\t} else {\n\t\trmnet_unregister_bridge(port);\n\t}\n}\n\nstatic int rmnet_config_notify_cb(struct notifier_block *nb,\n\t\t\t\t  unsigned long event, void *data)\n{\n\tstruct net_device *real_dev = netdev_notifier_info_to_dev(data);\n\n\tif (!rmnet_is_real_dev_registered(real_dev))\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_UNREGISTER:\n\t\tnetdev_dbg(real_dev, \"Kernel unregister\\n\");\n\t\trmnet_force_unassociate_device(real_dev);\n\t\tbreak;\n\tcase NETDEV_CHANGEMTU:\n\t\tif (rmnet_vnd_validate_real_dev_mtu(real_dev))\n\t\t\treturn NOTIFY_BAD;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block rmnet_dev_notifier __read_mostly = {\n\t.notifier_call = rmnet_config_notify_cb,\n};\n\nstatic int rmnet_rtnl_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tu16 mux_id;\n\n\tif (!data || !data[IFLA_RMNET_MUX_ID]) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"MUX ID not specified\");\n\t\treturn -EINVAL;\n\t}\n\n\tmux_id = nla_get_u16(data[IFLA_RMNET_MUX_ID]);\n\tif (mux_id > (RMNET_MAX_LOGICAL_EP - 1)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"invalid MUX ID\");\n\t\treturn -ERANGE;\n\t}\n\n\treturn 0;\n}\n\nstatic int rmnet_changelink(struct net_device *dev, struct nlattr *tb[],\n\t\t\t    struct nlattr *data[],\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct rmnet_priv *priv = netdev_priv(dev);\n\tstruct net_device *real_dev;\n\tstruct rmnet_port *port;\n\tu16 mux_id;\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\treal_dev = priv->real_dev;\n\tif (!rmnet_is_real_dev_registered(real_dev))\n\t\treturn -ENODEV;\n\n\tport = rmnet_get_port_rtnl(real_dev);\n\n\tif (data[IFLA_RMNET_MUX_ID]) {\n\t\tmux_id = nla_get_u16(data[IFLA_RMNET_MUX_ID]);\n\n\t\tif (mux_id != priv->mux_id) {\n\t\t\tstruct rmnet_endpoint *ep;\n\n\t\t\tep = rmnet_get_endpoint(port, priv->mux_id);\n\t\t\tif (!ep)\n\t\t\t\treturn -ENODEV;\n\n\t\t\tif (rmnet_get_endpoint(port, mux_id)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"MUX ID already exists\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\thlist_del_init_rcu(&ep->hlnode);\n\t\t\thlist_add_head_rcu(&ep->hlnode,\n\t\t\t\t\t   &port->muxed_ep[mux_id]);\n\n\t\t\tep->mux_id = mux_id;\n\t\t\tpriv->mux_id = mux_id;\n\t\t}\n\t}\n\n\tif (data[IFLA_RMNET_FLAGS]) {\n\t\tstruct ifla_rmnet_flags *flags;\n\t\tu32 old_data_format;\n\n\t\told_data_format = port->data_format;\n\t\tflags = nla_data(data[IFLA_RMNET_FLAGS]);\n\t\tport->data_format &= ~flags->mask;\n\t\tport->data_format |= flags->flags & flags->mask;\n\n\t\tif (rmnet_vnd_update_dev_mtu(port, real_dev)) {\n\t\t\tport->data_format = old_data_format;\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid MTU on real dev\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic size_t rmnet_get_size(const struct net_device *dev)\n{\n\treturn\n\t\t \n\t\tnla_total_size(2) +\n\t\t \n\t\tnla_total_size(sizeof(struct ifla_rmnet_flags));\n}\n\nstatic int rmnet_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct rmnet_priv *priv = netdev_priv(dev);\n\tstruct net_device *real_dev;\n\tstruct ifla_rmnet_flags f;\n\tstruct rmnet_port *port;\n\n\treal_dev = priv->real_dev;\n\n\tif (nla_put_u16(skb, IFLA_RMNET_MUX_ID, priv->mux_id))\n\t\tgoto nla_put_failure;\n\n\tif (rmnet_is_real_dev_registered(real_dev)) {\n\t\tport = rmnet_get_port_rtnl(real_dev);\n\t\tf.flags = port->data_format;\n\t} else {\n\t\tf.flags = 0;\n\t}\n\n\tf.mask  = ~0;\n\n\tif (nla_put(skb, IFLA_RMNET_FLAGS, sizeof(f), &f))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstruct rtnl_link_ops rmnet_link_ops __read_mostly = {\n\t.kind\t\t= \"rmnet\",\n\t.maxtype\t= IFLA_RMNET_MAX,\n\t.priv_size\t= sizeof(struct rmnet_priv),\n\t.setup\t\t= rmnet_vnd_setup,\n\t.validate\t= rmnet_rtnl_validate,\n\t.newlink\t= rmnet_newlink,\n\t.dellink\t= rmnet_dellink,\n\t.get_size\t= rmnet_get_size,\n\t.changelink     = rmnet_changelink,\n\t.policy\t\t= rmnet_policy,\n\t.fill_info\t= rmnet_fill_info,\n};\n\nstruct rmnet_port *rmnet_get_port_rcu(struct net_device *real_dev)\n{\n\tif (rmnet_is_real_dev_registered(real_dev))\n\t\treturn rcu_dereference_bh(real_dev->rx_handler_data);\n\telse\n\t\treturn NULL;\n}\n\nstruct rmnet_endpoint *rmnet_get_endpoint(struct rmnet_port *port, u8 mux_id)\n{\n\tstruct rmnet_endpoint *ep;\n\n\thlist_for_each_entry_rcu(ep, &port->muxed_ep[mux_id], hlnode) {\n\t\tif (ep->mux_id == mux_id)\n\t\t\treturn ep;\n\t}\n\n\treturn NULL;\n}\n\nint rmnet_add_bridge(struct net_device *rmnet_dev,\n\t\t     struct net_device *slave_dev,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct rmnet_priv *priv = netdev_priv(rmnet_dev);\n\tstruct net_device *real_dev = priv->real_dev;\n\tstruct rmnet_port *port, *slave_port;\n\tint err;\n\n\tport = rmnet_get_port_rtnl(real_dev);\n\n\t \n\tif (port->nr_rmnet_devs > 1) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"more than one rmnet dev attached\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (port->rmnet_mode != RMNET_EPMODE_VND) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"more than one bridge dev attached\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (rmnet_is_real_dev_registered(slave_dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"slave cannot be another rmnet dev\");\n\n\t\treturn -EBUSY;\n\t}\n\n\terr = rmnet_register_real_device(slave_dev, extack);\n\tif (err)\n\t\treturn -EBUSY;\n\n\terr = netdev_master_upper_dev_link(slave_dev, rmnet_dev, NULL, NULL,\n\t\t\t\t\t   extack);\n\tif (err) {\n\t\trmnet_unregister_real_device(slave_dev);\n\t\treturn err;\n\t}\n\n\tslave_port = rmnet_get_port_rtnl(slave_dev);\n\tslave_port->rmnet_mode = RMNET_EPMODE_BRIDGE;\n\tslave_port->bridge_ep = real_dev;\n\tslave_port->rmnet_dev = rmnet_dev;\n\n\tport->rmnet_mode = RMNET_EPMODE_BRIDGE;\n\tport->bridge_ep = slave_dev;\n\n\tnetdev_dbg(slave_dev, \"registered with rmnet as slave\\n\");\n\treturn 0;\n}\n\nint rmnet_del_bridge(struct net_device *rmnet_dev,\n\t\t     struct net_device *slave_dev)\n{\n\tstruct rmnet_port *port = rmnet_get_port_rtnl(slave_dev);\n\n\trmnet_unregister_bridge(port);\n\n\tnetdev_dbg(slave_dev, \"removed from rmnet as slave\\n\");\n\treturn 0;\n}\n\n \n\nstatic int __init rmnet_init(void)\n{\n\tint rc;\n\n\trc = register_netdevice_notifier(&rmnet_dev_notifier);\n\tif (rc != 0)\n\t\treturn rc;\n\n\trc = rtnl_link_register(&rmnet_link_ops);\n\tif (rc != 0) {\n\t\tunregister_netdevice_notifier(&rmnet_dev_notifier);\n\t\treturn rc;\n\t}\n\treturn rc;\n}\n\nstatic void __exit rmnet_exit(void)\n{\n\trtnl_link_unregister(&rmnet_link_ops);\n\tunregister_netdevice_notifier(&rmnet_dev_notifier);\n}\n\nmodule_init(rmnet_init)\nmodule_exit(rmnet_exit)\nMODULE_ALIAS_RTNL_LINK(\"rmnet\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}