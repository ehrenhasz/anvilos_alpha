{
  "module_name": "rmnet_vnd.c",
  "hash_id": "1dec641a536fd8b5dad3c4624df68e2a5b035dd1db210c09e2a0e3f3ac605e81",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qualcomm/rmnet/rmnet_vnd.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/if_arp.h>\n#include <net/pkt_sched.h>\n#include \"rmnet_config.h\"\n#include \"rmnet_handlers.h\"\n#include \"rmnet_private.h\"\n#include \"rmnet_map.h\"\n#include \"rmnet_vnd.h\"\n\n \n\nvoid rmnet_vnd_rx_fixup(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct rmnet_priv *priv = netdev_priv(dev);\n\tstruct rmnet_pcpu_stats *pcpu_ptr;\n\n\tpcpu_ptr = this_cpu_ptr(priv->pcpu_stats);\n\n\tu64_stats_update_begin(&pcpu_ptr->syncp);\n\tpcpu_ptr->stats.rx_pkts++;\n\tpcpu_ptr->stats.rx_bytes += skb->len;\n\tu64_stats_update_end(&pcpu_ptr->syncp);\n}\n\nvoid rmnet_vnd_tx_fixup_len(unsigned int len, struct net_device *dev)\n{\n\tstruct rmnet_priv *priv = netdev_priv(dev);\n\tstruct rmnet_pcpu_stats *pcpu_ptr;\n\n\tpcpu_ptr = this_cpu_ptr(priv->pcpu_stats);\n\n\tu64_stats_update_begin(&pcpu_ptr->syncp);\n\tpcpu_ptr->stats.tx_pkts++;\n\tpcpu_ptr->stats.tx_bytes += len;\n\tu64_stats_update_end(&pcpu_ptr->syncp);\n}\n\nvoid rmnet_vnd_tx_fixup(struct sk_buff *skb, struct net_device *dev)\n{\n\trmnet_vnd_tx_fixup_len(skb->len, dev);\n}\n\n \n\nstatic netdev_tx_t rmnet_vnd_start_xmit(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev)\n{\n\tstruct rmnet_priv *priv;\n\n\tpriv = netdev_priv(dev);\n\tif (priv->real_dev) {\n\t\trmnet_egress_handler(skb);\n\t} else {\n\t\tthis_cpu_inc(priv->pcpu_stats->stats.tx_drops);\n\t\tkfree_skb(skb);\n\t}\n\treturn NETDEV_TX_OK;\n}\n\nstatic int rmnet_vnd_headroom(struct rmnet_port *port)\n{\n\tu32 headroom;\n\n\theadroom = sizeof(struct rmnet_map_header);\n\n\tif (port->data_format & RMNET_FLAGS_EGRESS_MAP_CKSUMV4)\n\t\theadroom += sizeof(struct rmnet_map_ul_csum_header);\n\n\treturn headroom;\n}\n\nstatic int rmnet_vnd_change_mtu(struct net_device *rmnet_dev, int new_mtu)\n{\n\tstruct rmnet_priv *priv = netdev_priv(rmnet_dev);\n\tstruct rmnet_port *port;\n\tu32 headroom;\n\n\tport = rmnet_get_port_rtnl(priv->real_dev);\n\n\theadroom = rmnet_vnd_headroom(port);\n\n\tif (new_mtu < 0 || new_mtu > RMNET_MAX_PACKET_SIZE ||\n\t    new_mtu > (priv->real_dev->mtu - headroom))\n\t\treturn -EINVAL;\n\n\trmnet_dev->mtu = new_mtu;\n\treturn 0;\n}\n\nstatic int rmnet_vnd_get_iflink(const struct net_device *dev)\n{\n\tstruct rmnet_priv *priv = netdev_priv(dev);\n\n\treturn priv->real_dev->ifindex;\n}\n\nstatic int rmnet_vnd_init(struct net_device *dev)\n{\n\tstruct rmnet_priv *priv = netdev_priv(dev);\n\tint err;\n\n\tpriv->pcpu_stats = alloc_percpu(struct rmnet_pcpu_stats);\n\tif (!priv->pcpu_stats)\n\t\treturn -ENOMEM;\n\n\terr = gro_cells_init(&priv->gro_cells, dev);\n\tif (err) {\n\t\tfree_percpu(priv->pcpu_stats);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void rmnet_vnd_uninit(struct net_device *dev)\n{\n\tstruct rmnet_priv *priv = netdev_priv(dev);\n\n\tgro_cells_destroy(&priv->gro_cells);\n\tfree_percpu(priv->pcpu_stats);\n}\n\nstatic void rmnet_get_stats64(struct net_device *dev,\n\t\t\t      struct rtnl_link_stats64 *s)\n{\n\tstruct rmnet_priv *priv = netdev_priv(dev);\n\tstruct rmnet_vnd_stats total_stats = { };\n\tstruct rmnet_pcpu_stats *pcpu_ptr;\n\tstruct rmnet_vnd_stats snapshot;\n\tunsigned int cpu, start;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tpcpu_ptr = per_cpu_ptr(priv->pcpu_stats, cpu);\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&pcpu_ptr->syncp);\n\t\t\tsnapshot = pcpu_ptr->stats;\t \n\t\t} while (u64_stats_fetch_retry(&pcpu_ptr->syncp, start));\n\n\t\ttotal_stats.rx_pkts += snapshot.rx_pkts;\n\t\ttotal_stats.rx_bytes += snapshot.rx_bytes;\n\t\ttotal_stats.tx_pkts += snapshot.tx_pkts;\n\t\ttotal_stats.tx_bytes += snapshot.tx_bytes;\n\t\ttotal_stats.tx_drops += snapshot.tx_drops;\n\t}\n\n\ts->rx_packets = total_stats.rx_pkts;\n\ts->rx_bytes = total_stats.rx_bytes;\n\ts->tx_packets = total_stats.tx_pkts;\n\ts->tx_bytes = total_stats.tx_bytes;\n\ts->tx_dropped = total_stats.tx_drops;\n}\n\nstatic const struct net_device_ops rmnet_vnd_ops = {\n\t.ndo_start_xmit = rmnet_vnd_start_xmit,\n\t.ndo_change_mtu = rmnet_vnd_change_mtu,\n\t.ndo_get_iflink = rmnet_vnd_get_iflink,\n\t.ndo_add_slave  = rmnet_add_bridge,\n\t.ndo_del_slave  = rmnet_del_bridge,\n\t.ndo_init       = rmnet_vnd_init,\n\t.ndo_uninit     = rmnet_vnd_uninit,\n\t.ndo_get_stats64 = rmnet_get_stats64,\n};\n\nstatic const char rmnet_gstrings_stats[][ETH_GSTRING_LEN] = {\n\t\"Checksum ok\",\n\t\"Bad IPv4 header checksum\",\n\t\"Checksum valid bit not set\",\n\t\"Checksum validation failed\",\n\t\"Checksum error bad buffer\",\n\t\"Checksum error bad ip version\",\n\t\"Checksum error bad transport\",\n\t\"Checksum skipped on ip fragment\",\n\t\"Checksum skipped\",\n\t\"Checksum computed in software\",\n\t\"Checksum computed in hardware\",\n};\n\nstatic void rmnet_get_strings(struct net_device *dev, u32 stringset, u8 *buf)\n{\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tmemcpy(buf, &rmnet_gstrings_stats,\n\t\t       sizeof(rmnet_gstrings_stats));\n\t\tbreak;\n\t}\n}\n\nstatic int rmnet_get_sset_count(struct net_device *dev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn ARRAY_SIZE(rmnet_gstrings_stats);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void rmnet_get_ethtool_stats(struct net_device *dev,\n\t\t\t\t    struct ethtool_stats *stats, u64 *data)\n{\n\tstruct rmnet_priv *priv = netdev_priv(dev);\n\tstruct rmnet_priv_stats *st = &priv->stats;\n\n\tif (!data)\n\t\treturn;\n\n\tmemcpy(data, st, ARRAY_SIZE(rmnet_gstrings_stats) * sizeof(u64));\n}\n\nstatic int rmnet_get_coalesce(struct net_device *dev,\n\t\t\t      struct ethtool_coalesce *coal,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct rmnet_priv *priv = netdev_priv(dev);\n\tstruct rmnet_port *port;\n\n\tport = rmnet_get_port_rtnl(priv->real_dev);\n\n\tmemset(kernel_coal, 0, sizeof(*kernel_coal));\n\tkernel_coal->tx_aggr_max_bytes = port->egress_agg_params.bytes;\n\tkernel_coal->tx_aggr_max_frames = port->egress_agg_params.count;\n\tkernel_coal->tx_aggr_time_usecs = div_u64(port->egress_agg_params.time_nsec,\n\t\t\t\t\t\t  NSEC_PER_USEC);\n\n\treturn 0;\n}\n\nstatic int rmnet_set_coalesce(struct net_device *dev,\n\t\t\t      struct ethtool_coalesce *coal,\n\t\t\t      struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct rmnet_priv *priv = netdev_priv(dev);\n\tstruct rmnet_port *port;\n\n\tport = rmnet_get_port_rtnl(priv->real_dev);\n\n\tif (kernel_coal->tx_aggr_max_frames < 1 || kernel_coal->tx_aggr_max_frames > 64)\n\t\treturn -EINVAL;\n\n\tif (kernel_coal->tx_aggr_max_bytes > 32768)\n\t\treturn -EINVAL;\n\n\trmnet_map_update_ul_agg_config(port, kernel_coal->tx_aggr_max_bytes,\n\t\t\t\t       kernel_coal->tx_aggr_max_frames,\n\t\t\t\t       kernel_coal->tx_aggr_time_usecs);\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops rmnet_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_TX_AGGR,\n\t.get_coalesce = rmnet_get_coalesce,\n\t.set_coalesce = rmnet_set_coalesce,\n\t.get_ethtool_stats = rmnet_get_ethtool_stats,\n\t.get_strings = rmnet_get_strings,\n\t.get_sset_count = rmnet_get_sset_count,\n};\n\n \nvoid rmnet_vnd_setup(struct net_device *rmnet_dev)\n{\n\trmnet_dev->netdev_ops = &rmnet_vnd_ops;\n\trmnet_dev->mtu = RMNET_DFLT_PACKET_SIZE;\n\trmnet_dev->needed_headroom = RMNET_NEEDED_HEADROOM;\n\teth_hw_addr_random(rmnet_dev);\n\trmnet_dev->tx_queue_len = RMNET_TX_QUEUE_LEN;\n\n\t \n\trmnet_dev->header_ops = NULL;   \n\trmnet_dev->type = ARPHRD_RAWIP;\n\trmnet_dev->hard_header_len = 0;\n\trmnet_dev->flags &= ~(IFF_BROADCAST | IFF_MULTICAST);\n\n\trmnet_dev->needs_free_netdev = true;\n\trmnet_dev->ethtool_ops = &rmnet_ethtool_ops;\n\n\trmnet_dev->features |= NETIF_F_LLTX;\n\n\t \n\trmnet_dev->addr_assign_type = NET_ADDR_RANDOM;\n\teth_random_addr(rmnet_dev->perm_addr);\n}\n\n \n\nint rmnet_vnd_newlink(u8 id, struct net_device *rmnet_dev,\n\t\t      struct rmnet_port *port,\n\t\t      struct net_device *real_dev,\n\t\t      struct rmnet_endpoint *ep,\n\t\t      struct netlink_ext_ack *extack)\n\n{\n\tstruct rmnet_priv *priv = netdev_priv(rmnet_dev);\n\tu32 headroom;\n\tint rc;\n\n\tif (rmnet_get_endpoint(port, id)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"MUX ID already exists\");\n\t\treturn -EBUSY;\n\t}\n\n\trmnet_dev->hw_features = NETIF_F_RXCSUM;\n\trmnet_dev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;\n\trmnet_dev->hw_features |= NETIF_F_SG;\n\n\tpriv->real_dev = real_dev;\n\n\theadroom = rmnet_vnd_headroom(port);\n\n\tif (rmnet_vnd_change_mtu(rmnet_dev, real_dev->mtu - headroom)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid MTU on real dev\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = register_netdevice(rmnet_dev);\n\tif (!rc) {\n\t\tep->egress_dev = rmnet_dev;\n\t\tep->mux_id = id;\n\t\tport->nr_rmnet_devs++;\n\n\t\trmnet_dev->rtnl_link_ops = &rmnet_link_ops;\n\n\t\tpriv->mux_id = id;\n\n\t\tnetdev_dbg(rmnet_dev, \"rmnet dev created\\n\");\n\t}\n\n\treturn rc;\n}\n\nint rmnet_vnd_dellink(u8 id, struct rmnet_port *port,\n\t\t      struct rmnet_endpoint *ep)\n{\n\tif (id >= RMNET_MAX_LOGICAL_EP || !ep->egress_dev)\n\t\treturn -EINVAL;\n\n\tep->egress_dev = NULL;\n\tport->nr_rmnet_devs--;\n\treturn 0;\n}\n\nint rmnet_vnd_do_flow_control(struct net_device *rmnet_dev, int enable)\n{\n\tnetdev_dbg(rmnet_dev, \"Setting VND TX queue state to %d\\n\", enable);\n\t \n\tif (unlikely(enable))\n\t\tnetif_wake_queue(rmnet_dev);\n\telse\n\t\tnetif_stop_queue(rmnet_dev);\n\n\treturn 0;\n}\n\nint rmnet_vnd_validate_real_dev_mtu(struct net_device *real_dev)\n{\n\tstruct hlist_node *tmp_ep;\n\tstruct rmnet_endpoint *ep;\n\tstruct rmnet_port *port;\n\tunsigned long bkt_ep;\n\tu32 headroom;\n\n\tport = rmnet_get_port_rtnl(real_dev);\n\n\theadroom = rmnet_vnd_headroom(port);\n\n\thash_for_each_safe(port->muxed_ep, bkt_ep, tmp_ep, ep, hlnode) {\n\t\tif (ep->egress_dev->mtu > (real_dev->mtu - headroom))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint rmnet_vnd_update_dev_mtu(struct rmnet_port *port,\n\t\t\t     struct net_device *real_dev)\n{\n\tstruct hlist_node *tmp_ep;\n\tstruct rmnet_endpoint *ep;\n\tunsigned long bkt_ep;\n\tu32 headroom;\n\n\theadroom = rmnet_vnd_headroom(port);\n\n\thash_for_each_safe(port->muxed_ep, bkt_ep, tmp_ep, ep, hlnode) {\n\t\tif (ep->egress_dev->mtu <= (real_dev->mtu - headroom))\n\t\t\tcontinue;\n\n\t\tif (rmnet_vnd_change_mtu(ep->egress_dev,\n\t\t\t\t\t real_dev->mtu - headroom))\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}