{
  "module_name": "rmnet_map_command.c",
  "hash_id": "1fa44a5d6831aed683500591081095ca62a72e9ba6c824064153cfe165d457a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qualcomm/rmnet/rmnet_map_command.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include \"rmnet_config.h\"\n#include \"rmnet_map.h\"\n#include \"rmnet_private.h\"\n#include \"rmnet_vnd.h\"\n\nstatic u8 rmnet_map_do_flow_control(struct sk_buff *skb,\n\t\t\t\t    struct rmnet_port *port,\n\t\t\t\t    int enable)\n{\n\tstruct rmnet_map_header *map_header = (void *)skb->data;\n\tstruct rmnet_endpoint *ep;\n\tstruct net_device *vnd;\n\tu8 mux_id;\n\tint r;\n\n\tmux_id = map_header->mux_id;\n\n\tif (mux_id >= RMNET_MAX_LOGICAL_EP) {\n\t\tkfree_skb(skb);\n\t\treturn RX_HANDLER_CONSUMED;\n\t}\n\n\tep = rmnet_get_endpoint(port, mux_id);\n\tif (!ep) {\n\t\tkfree_skb(skb);\n\t\treturn RX_HANDLER_CONSUMED;\n\t}\n\n\tvnd = ep->egress_dev;\n\n\t \n\tr = rmnet_vnd_do_flow_control(vnd, enable);\n\tif (r) {\n\t\tkfree_skb(skb);\n\t\treturn RMNET_MAP_COMMAND_UNSUPPORTED;\n\t} else {\n\t\treturn RMNET_MAP_COMMAND_ACK;\n\t}\n}\n\nstatic void rmnet_map_send_ack(struct sk_buff *skb,\n\t\t\t       unsigned char type,\n\t\t\t       struct rmnet_port *port)\n{\n\tstruct rmnet_map_header *map_header = (void *)skb->data;\n\tstruct rmnet_map_control_command *cmd;\n\tstruct net_device *dev = skb->dev;\n\n\tif (port->data_format & RMNET_FLAGS_INGRESS_MAP_CKSUMV4)\n\t\tskb_trim(skb,\n\t\t\t skb->len - sizeof(struct rmnet_map_dl_csum_trailer));\n\n\tskb->protocol = htons(ETH_P_MAP);\n\n\t \n\tcmd = (struct rmnet_map_control_command *)(map_header + 1);\n\tcmd->cmd_type = type & 0x03;\n\n\tnetif_tx_lock(dev);\n\tdev->netdev_ops->ndo_start_xmit(skb, dev);\n\tnetif_tx_unlock(dev);\n}\n\n \nvoid rmnet_map_command(struct sk_buff *skb, struct rmnet_port *port)\n{\n\tstruct rmnet_map_header *map_header = (void *)skb->data;\n\tstruct rmnet_map_control_command *cmd;\n\tunsigned char command_name;\n\tunsigned char rc = 0;\n\n\t \n\tcmd = (struct rmnet_map_control_command *)(map_header + 1);\n\tcommand_name = cmd->command_name;\n\n\tswitch (command_name) {\n\tcase RMNET_MAP_COMMAND_FLOW_ENABLE:\n\t\trc = rmnet_map_do_flow_control(skb, port, 1);\n\t\tbreak;\n\n\tcase RMNET_MAP_COMMAND_FLOW_DISABLE:\n\t\trc = rmnet_map_do_flow_control(skb, port, 0);\n\t\tbreak;\n\n\tdefault:\n\t\trc = RMNET_MAP_COMMAND_UNSUPPORTED;\n\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n\tif (rc == RMNET_MAP_COMMAND_ACK)\n\t\trmnet_map_send_ack(skb, rc, port);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}