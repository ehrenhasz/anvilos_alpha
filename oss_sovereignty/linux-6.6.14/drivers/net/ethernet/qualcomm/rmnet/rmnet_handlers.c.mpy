{
  "module_name": "rmnet_handlers.c",
  "hash_id": "76727d7fb3aff9f7f1ca2ce02a69a7c0846cc579883eb26e42ae9b85d1f37b5a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qualcomm/rmnet/rmnet_handlers.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <linux/netdev_features.h>\n#include <linux/if_arp.h>\n#include <net/sock.h>\n#include \"rmnet_private.h\"\n#include \"rmnet_config.h\"\n#include \"rmnet_vnd.h\"\n#include \"rmnet_map.h\"\n#include \"rmnet_handlers.h\"\n\n#define RMNET_IP_VERSION_4 0x40\n#define RMNET_IP_VERSION_6 0x60\n\n \n\nstatic void rmnet_set_skb_proto(struct sk_buff *skb)\n{\n\tswitch (skb->data[0] & 0xF0) {\n\tcase RMNET_IP_VERSION_4:\n\t\tskb->protocol = htons(ETH_P_IP);\n\t\tbreak;\n\tcase RMNET_IP_VERSION_6:\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tbreak;\n\tdefault:\n\t\tskb->protocol = htons(ETH_P_MAP);\n\t\tbreak;\n\t}\n}\n\n \n\nstatic void\nrmnet_deliver_skb(struct sk_buff *skb)\n{\n\tstruct rmnet_priv *priv = netdev_priv(skb->dev);\n\n\tskb_reset_transport_header(skb);\n\tskb_reset_network_header(skb);\n\trmnet_vnd_rx_fixup(skb, skb->dev);\n\n\tskb->pkt_type = PACKET_HOST;\n\tskb_set_mac_header(skb, 0);\n\tgro_cells_receive(&priv->gro_cells, skb);\n}\n\n \n\nstatic void\n__rmnet_map_ingress_handler(struct sk_buff *skb,\n\t\t\t    struct rmnet_port *port)\n{\n\tstruct rmnet_map_header *map_header = (void *)skb->data;\n\tstruct rmnet_endpoint *ep;\n\tu16 len, pad;\n\tu8 mux_id;\n\n\tif (map_header->flags & MAP_CMD_FLAG) {\n\t\t \n\t\tif (port->data_format & RMNET_FLAGS_INGRESS_MAP_COMMANDS)\n\t\t\treturn rmnet_map_command(skb, port);\n\n\t\tgoto free_skb;\n\t}\n\n\tmux_id = map_header->mux_id;\n\tpad = map_header->flags & MAP_PAD_LEN_MASK;\n\tlen = ntohs(map_header->pkt_len) - pad;\n\n\tif (mux_id >= RMNET_MAX_LOGICAL_EP)\n\t\tgoto free_skb;\n\n\tep = rmnet_get_endpoint(port, mux_id);\n\tif (!ep)\n\t\tgoto free_skb;\n\n\tskb->dev = ep->egress_dev;\n\n\tif ((port->data_format & RMNET_FLAGS_INGRESS_MAP_CKSUMV5) &&\n\t    (map_header->flags & MAP_NEXT_HEADER_FLAG)) {\n\t\tif (rmnet_map_process_next_hdr_packet(skb, len))\n\t\t\tgoto free_skb;\n\t\tskb_pull(skb, sizeof(*map_header));\n\t\trmnet_set_skb_proto(skb);\n\t} else {\n\t\t \n\t\tskb_pull(skb, sizeof(*map_header));\n\t\trmnet_set_skb_proto(skb);\n\t\tif (port->data_format & RMNET_FLAGS_INGRESS_MAP_CKSUMV4 &&\n\t\t    !rmnet_map_checksum_downlink_packet(skb, len + pad))\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t}\n\n\tskb_trim(skb, len);\n\trmnet_deliver_skb(skb);\n\treturn;\n\nfree_skb:\n\tkfree_skb(skb);\n}\n\nstatic void\nrmnet_map_ingress_handler(struct sk_buff *skb,\n\t\t\t  struct rmnet_port *port)\n{\n\tstruct sk_buff *skbn;\n\n\tif (skb->dev->type == ARPHRD_ETHER) {\n\t\tif (pskb_expand_head(skb, ETH_HLEN, 0, GFP_ATOMIC)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\n\t\tskb_push(skb, ETH_HLEN);\n\t}\n\n\tif (port->data_format & RMNET_FLAGS_INGRESS_DEAGGREGATION) {\n\t\twhile ((skbn = rmnet_map_deaggregate(skb, port)) != NULL)\n\t\t\t__rmnet_map_ingress_handler(skbn, port);\n\n\t\tconsume_skb(skb);\n\t} else {\n\t\t__rmnet_map_ingress_handler(skb, port);\n\t}\n}\n\nstatic int rmnet_map_egress_handler(struct sk_buff *skb,\n\t\t\t\t    struct rmnet_port *port, u8 mux_id,\n\t\t\t\t    struct net_device *orig_dev)\n{\n\tint required_headroom, additional_header_len, csum_type = 0;\n\tstruct rmnet_map_header *map_header;\n\n\tadditional_header_len = 0;\n\trequired_headroom = sizeof(struct rmnet_map_header);\n\n\tif (port->data_format & RMNET_FLAGS_EGRESS_MAP_CKSUMV4) {\n\t\tadditional_header_len = sizeof(struct rmnet_map_ul_csum_header);\n\t\tcsum_type = RMNET_FLAGS_EGRESS_MAP_CKSUMV4;\n\t} else if (port->data_format & RMNET_FLAGS_EGRESS_MAP_CKSUMV5) {\n\t\tadditional_header_len = sizeof(struct rmnet_map_v5_csum_header);\n\t\tcsum_type = RMNET_FLAGS_EGRESS_MAP_CKSUMV5;\n\t}\n\n\trequired_headroom += additional_header_len;\n\n\tif (skb_cow_head(skb, required_headroom) < 0)\n\t\treturn -ENOMEM;\n\n\tif (csum_type)\n\t\trmnet_map_checksum_uplink_packet(skb, port, orig_dev,\n\t\t\t\t\t\t csum_type);\n\n\tmap_header = rmnet_map_add_map_header(skb, additional_header_len,\n\t\t\t\t\t      port, 0);\n\tif (!map_header)\n\t\treturn -ENOMEM;\n\n\tmap_header->mux_id = mux_id;\n\n\tif (READ_ONCE(port->egress_agg_params.count) > 1) {\n\t\tunsigned int len;\n\n\t\tlen = rmnet_map_tx_aggregate(skb, port, orig_dev);\n\t\tif (likely(len)) {\n\t\t\trmnet_vnd_tx_fixup_len(len, orig_dev);\n\t\t\treturn -EINPROGRESS;\n\t\t}\n\t\treturn -ENOMEM;\n\t}\n\n\tskb->protocol = htons(ETH_P_MAP);\n\treturn 0;\n}\n\nstatic void\nrmnet_bridge_handler(struct sk_buff *skb, struct net_device *bridge_dev)\n{\n\tif (skb_mac_header_was_set(skb))\n\t\tskb_push(skb, skb->mac_len);\n\n\tif (bridge_dev) {\n\t\tskb->dev = bridge_dev;\n\t\tdev_queue_xmit(skb);\n\t}\n}\n\n \n\n \nrx_handler_result_t rmnet_rx_handler(struct sk_buff **pskb)\n{\n\tstruct sk_buff *skb = *pskb;\n\tstruct rmnet_port *port;\n\tstruct net_device *dev;\n\n\tif (!skb)\n\t\tgoto done;\n\n\tif (skb_linearize(skb)) {\n\t\tkfree_skb(skb);\n\t\tgoto done;\n\t}\n\n\tif (skb->pkt_type == PACKET_LOOPBACK)\n\t\treturn RX_HANDLER_PASS;\n\n\tdev = skb->dev;\n\tport = rmnet_get_port_rcu(dev);\n\tif (unlikely(!port)) {\n\t\tdev_core_stats_rx_nohandler_inc(skb->dev);\n\t\tkfree_skb(skb);\n\t\tgoto done;\n\t}\n\n\tswitch (port->rmnet_mode) {\n\tcase RMNET_EPMODE_VND:\n\t\trmnet_map_ingress_handler(skb, port);\n\t\tbreak;\n\tcase RMNET_EPMODE_BRIDGE:\n\t\trmnet_bridge_handler(skb, port->bridge_ep);\n\t\tbreak;\n\t}\n\ndone:\n\treturn RX_HANDLER_CONSUMED;\n}\n\n \nvoid rmnet_egress_handler(struct sk_buff *skb)\n{\n\tstruct net_device *orig_dev;\n\tstruct rmnet_port *port;\n\tstruct rmnet_priv *priv;\n\tu8 mux_id;\n\tint err;\n\n\tsk_pacing_shift_update(skb->sk, 8);\n\n\torig_dev = skb->dev;\n\tpriv = netdev_priv(orig_dev);\n\tskb->dev = priv->real_dev;\n\tmux_id = priv->mux_id;\n\n\tport = rmnet_get_port_rcu(skb->dev);\n\tif (!port)\n\t\tgoto drop;\n\n\terr = rmnet_map_egress_handler(skb, port, mux_id, orig_dev);\n\tif (err == -ENOMEM)\n\t\tgoto drop;\n\telse if (err == -EINPROGRESS)\n\t\treturn;\n\n\trmnet_vnd_tx_fixup(skb, orig_dev);\n\n\tdev_queue_xmit(skb);\n\treturn;\n\ndrop:\n\tthis_cpu_inc(priv->pcpu_stats->stats.tx_drops);\n\tkfree_skb(skb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}