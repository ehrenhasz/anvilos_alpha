{
  "module_name": "qca_7k_common.c",
  "hash_id": "a78817fd9f833208e98bbc991dcbac29af9631d4a43961941f7bcc07475ffe6a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qualcomm/qca_7k_common.c",
  "human_readable_source": " \n\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#include \"qca_7k_common.h\"\n\nu16\nqcafrm_create_header(u8 *buf, u16 length)\n{\n\t__le16 len;\n\n\tif (!buf)\n\t\treturn 0;\n\n\tlen = cpu_to_le16(length);\n\n\tbuf[0] = 0xAA;\n\tbuf[1] = 0xAA;\n\tbuf[2] = 0xAA;\n\tbuf[3] = 0xAA;\n\tbuf[4] = len & 0xff;\n\tbuf[5] = (len >> 8) & 0xff;\n\tbuf[6] = 0;\n\tbuf[7] = 0;\n\n\treturn QCAFRM_HEADER_LEN;\n}\nEXPORT_SYMBOL_GPL(qcafrm_create_header);\n\nu16\nqcafrm_create_footer(u8 *buf)\n{\n\tif (!buf)\n\t\treturn 0;\n\n\tbuf[0] = 0x55;\n\tbuf[1] = 0x55;\n\treturn QCAFRM_FOOTER_LEN;\n}\nEXPORT_SYMBOL_GPL(qcafrm_create_footer);\n\n \n\ns32\nqcafrm_fsm_decode(struct qcafrm_handle *handle, u8 *buf, u16 buf_len, u8 recv_byte)\n{\n\ts32 ret = QCAFRM_GATHER;\n\tu16 len;\n\n\tswitch (handle->state) {\n\tcase QCAFRM_HW_LEN0:\n\tcase QCAFRM_HW_LEN1:\n\t\t \n\t\thandle->state--;\n\n\t\tif (recv_byte != 0x00) {\n\t\t\t \n\t\t\thandle->state = handle->init;\n\t\t}\n\t\tbreak;\n\tcase QCAFRM_HW_LEN2:\n\tcase QCAFRM_HW_LEN3:\n\t\thandle->state--;\n\t\tbreak;\n\t \n\tcase QCAFRM_WAIT_AA1:\n\tcase QCAFRM_WAIT_AA2:\n\tcase QCAFRM_WAIT_AA3:\n\tcase QCAFRM_WAIT_AA4:\n\t\tif (recv_byte != 0xAA) {\n\t\t\tret = QCAFRM_NOHEAD;\n\t\t\thandle->state = handle->init;\n\t\t} else {\n\t\t\thandle->state--;\n\t\t}\n\t\tbreak;\n\t\t \n\t\t \n\tcase QCAFRM_WAIT_LEN_BYTE0:\n\t\thandle->offset = recv_byte;\n\t\thandle->state = QCAFRM_WAIT_LEN_BYTE1;\n\t\tbreak;\n\tcase QCAFRM_WAIT_LEN_BYTE1:\n\t\thandle->offset = handle->offset | (recv_byte << 8);\n\t\thandle->state = QCAFRM_WAIT_RSVD_BYTE1;\n\t\tbreak;\n\tcase QCAFRM_WAIT_RSVD_BYTE1:\n\t\thandle->state = QCAFRM_WAIT_RSVD_BYTE2;\n\t\tbreak;\n\tcase QCAFRM_WAIT_RSVD_BYTE2:\n\t\tlen = handle->offset;\n\t\tif (len > buf_len || len < QCAFRM_MIN_LEN) {\n\t\t\tret = QCAFRM_INVLEN;\n\t\t\thandle->state = handle->init;\n\t\t} else {\n\t\t\thandle->state = (enum qcafrm_state)(len + 1);\n\t\t\t \n\t\t\thandle->offset = 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbuf[handle->offset] = recv_byte;\n\t\thandle->offset++;\n\t\thandle->state--;\n\t\tbreak;\n\tcase QCAFRM_WAIT_551:\n\t\tif (recv_byte != 0x55) {\n\t\t\tret = QCAFRM_NOTAIL;\n\t\t\thandle->state = handle->init;\n\t\t} else {\n\t\t\thandle->state = QCAFRM_WAIT_552;\n\t\t}\n\t\tbreak;\n\tcase QCAFRM_WAIT_552:\n\t\tif (recv_byte != 0x55) {\n\t\t\tret = QCAFRM_NOTAIL;\n\t\t\thandle->state = handle->init;\n\t\t} else {\n\t\t\tret = handle->offset;\n\t\t\t \n\t\t\thandle->state = handle->init;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(qcafrm_fsm_decode);\n\nMODULE_DESCRIPTION(\"Qualcomm Atheros QCA7000 common\");\nMODULE_AUTHOR(\"Qualcomm Atheros Communications\");\nMODULE_AUTHOR(\"Stefan Wahren <stefan.wahren@i2se.com>\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}