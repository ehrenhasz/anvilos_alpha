{
  "module_name": "qca_uart.c",
  "hash_id": "018c6792b3f1260ddf2f6b103b60ef2aa01b37d77d3e5e5040e26979c8af23e4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qualcomm/qca_uart.c",
  "human_readable_source": " \n\n \n\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n#include <linux/sched.h>\n#include <linux/serdev.h>\n#include <linux/skbuff.h>\n#include <linux/types.h>\n\n#include \"qca_7k_common.h\"\n\n#define QCAUART_DRV_VERSION \"0.1.0\"\n#define QCAUART_DRV_NAME \"qcauart\"\n#define QCAUART_TX_TIMEOUT (1 * HZ)\n\nstruct qcauart {\n\tstruct net_device *net_dev;\n\tspinlock_t lock;\t\t\t \n\tstruct work_struct tx_work;\t\t \n\n\tstruct serdev_device *serdev;\n\tstruct qcafrm_handle frm_handle;\n\tstruct sk_buff *rx_skb;\n\n\tunsigned char *tx_head;\t\t\t \n\tint tx_left;\t\t\t\t \n\tunsigned char *tx_buffer;\n};\n\nstatic int\nqca_tty_receive(struct serdev_device *serdev, const unsigned char *data,\n\t\tsize_t count)\n{\n\tstruct qcauart *qca = serdev_device_get_drvdata(serdev);\n\tstruct net_device *netdev = qca->net_dev;\n\tstruct net_device_stats *n_stats = &netdev->stats;\n\tsize_t i;\n\n\tif (!qca->rx_skb) {\n\t\tqca->rx_skb = netdev_alloc_skb_ip_align(netdev,\n\t\t\t\t\t\t\tnetdev->mtu +\n\t\t\t\t\t\t\tVLAN_ETH_HLEN);\n\t\tif (!qca->rx_skb) {\n\t\t\tn_stats->rx_errors++;\n\t\t\tn_stats->rx_dropped++;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\ts32 retcode;\n\n\t\tretcode = qcafrm_fsm_decode(&qca->frm_handle,\n\t\t\t\t\t    qca->rx_skb->data,\n\t\t\t\t\t    skb_tailroom(qca->rx_skb),\n\t\t\t\t\t    data[i]);\n\n\t\tswitch (retcode) {\n\t\tcase QCAFRM_GATHER:\n\t\tcase QCAFRM_NOHEAD:\n\t\t\tbreak;\n\t\tcase QCAFRM_NOTAIL:\n\t\t\tnetdev_dbg(netdev, \"recv: no RX tail\\n\");\n\t\t\tn_stats->rx_errors++;\n\t\t\tn_stats->rx_dropped++;\n\t\t\tbreak;\n\t\tcase QCAFRM_INVLEN:\n\t\t\tnetdev_dbg(netdev, \"recv: invalid RX length\\n\");\n\t\t\tn_stats->rx_errors++;\n\t\t\tn_stats->rx_dropped++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tn_stats->rx_packets++;\n\t\t\tn_stats->rx_bytes += retcode;\n\t\t\tskb_put(qca->rx_skb, retcode);\n\t\t\tqca->rx_skb->protocol = eth_type_trans(\n\t\t\t\t\t\tqca->rx_skb, qca->rx_skb->dev);\n\t\t\tskb_checksum_none_assert(qca->rx_skb);\n\t\t\tnetif_rx(qca->rx_skb);\n\t\t\tqca->rx_skb = netdev_alloc_skb_ip_align(netdev,\n\t\t\t\t\t\t\t\tnetdev->mtu +\n\t\t\t\t\t\t\t\tVLAN_ETH_HLEN);\n\t\t\tif (!qca->rx_skb) {\n\t\t\t\tnetdev_dbg(netdev, \"recv: out of RX resources\\n\");\n\t\t\t\tn_stats->rx_errors++;\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn i;\n}\n\n \nstatic void qcauart_transmit(struct work_struct *work)\n{\n\tstruct qcauart *qca = container_of(work, struct qcauart, tx_work);\n\tstruct net_device_stats *n_stats = &qca->net_dev->stats;\n\tint written;\n\n\tspin_lock_bh(&qca->lock);\n\n\t \n\tif (!netif_running(qca->net_dev)) {\n\t\tspin_unlock_bh(&qca->lock);\n\t\treturn;\n\t}\n\n\tif (qca->tx_left <= 0)  {\n\t\t \n\t\tn_stats->tx_packets++;\n\t\tspin_unlock_bh(&qca->lock);\n\t\tnetif_wake_queue(qca->net_dev);\n\t\treturn;\n\t}\n\n\twritten = serdev_device_write_buf(qca->serdev, qca->tx_head,\n\t\t\t\t\t  qca->tx_left);\n\tif (written > 0) {\n\t\tqca->tx_left -= written;\n\t\tqca->tx_head += written;\n\t}\n\tspin_unlock_bh(&qca->lock);\n}\n\n \nstatic void qca_tty_wakeup(struct serdev_device *serdev)\n{\n\tstruct qcauart *qca = serdev_device_get_drvdata(serdev);\n\n\tschedule_work(&qca->tx_work);\n}\n\nstatic const struct serdev_device_ops qca_serdev_ops = {\n\t.receive_buf = qca_tty_receive,\n\t.write_wakeup = qca_tty_wakeup,\n};\n\nstatic int qcauart_netdev_open(struct net_device *dev)\n{\n\tstruct qcauart *qca = netdev_priv(dev);\n\n\tnetif_start_queue(qca->net_dev);\n\n\treturn 0;\n}\n\nstatic int qcauart_netdev_close(struct net_device *dev)\n{\n\tstruct qcauart *qca = netdev_priv(dev);\n\n\tnetif_stop_queue(dev);\n\tflush_work(&qca->tx_work);\n\n\tspin_lock_bh(&qca->lock);\n\tqca->tx_left = 0;\n\tspin_unlock_bh(&qca->lock);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t\nqcauart_netdev_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct net_device_stats *n_stats = &dev->stats;\n\tstruct qcauart *qca = netdev_priv(dev);\n\tu8 pad_len = 0;\n\tint written;\n\tu8 *pos;\n\n\tspin_lock(&qca->lock);\n\n\tWARN_ON(qca->tx_left);\n\n\tif (!netif_running(dev))  {\n\t\tspin_unlock(&qca->lock);\n\t\tnetdev_warn(qca->net_dev, \"xmit: iface is down\\n\");\n\t\tgoto out;\n\t}\n\n\tpos = qca->tx_buffer;\n\n\tif (skb->len < QCAFRM_MIN_LEN)\n\t\tpad_len = QCAFRM_MIN_LEN - skb->len;\n\n\tpos += qcafrm_create_header(pos, skb->len + pad_len);\n\n\tmemcpy(pos, skb->data, skb->len);\n\tpos += skb->len;\n\n\tif (pad_len) {\n\t\tmemset(pos, 0, pad_len);\n\t\tpos += pad_len;\n\t}\n\n\tpos += qcafrm_create_footer(pos);\n\n\tnetif_stop_queue(qca->net_dev);\n\n\twritten = serdev_device_write_buf(qca->serdev, qca->tx_buffer,\n\t\t\t\t\t  pos - qca->tx_buffer);\n\tif (written > 0) {\n\t\tqca->tx_left = (pos - qca->tx_buffer) - written;\n\t\tqca->tx_head = qca->tx_buffer + written;\n\t\tn_stats->tx_bytes += written;\n\t}\n\tspin_unlock(&qca->lock);\n\n\tnetif_trans_update(dev);\nout:\n\tdev_kfree_skb_any(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void qcauart_netdev_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct qcauart *qca = netdev_priv(dev);\n\n\tnetdev_info(qca->net_dev, \"Transmit timeout at %ld, latency %ld\\n\",\n\t\t    jiffies, dev_trans_start(dev));\n\tdev->stats.tx_errors++;\n\tdev->stats.tx_dropped++;\n}\n\nstatic int qcauart_netdev_init(struct net_device *dev)\n{\n\tstruct qcauart *qca = netdev_priv(dev);\n\tsize_t len;\n\n\t \n\tdev->mtu = QCAFRM_MAX_MTU;\n\tdev->type = ARPHRD_ETHER;\n\n\tlen = QCAFRM_HEADER_LEN + QCAFRM_MAX_LEN + QCAFRM_FOOTER_LEN;\n\tqca->tx_buffer = devm_kmalloc(&qca->serdev->dev, len, GFP_KERNEL);\n\tif (!qca->tx_buffer)\n\t\treturn -ENOMEM;\n\n\tqca->rx_skb = netdev_alloc_skb_ip_align(qca->net_dev,\n\t\t\t\t\t\tqca->net_dev->mtu +\n\t\t\t\t\t\tVLAN_ETH_HLEN);\n\tif (!qca->rx_skb)\n\t\treturn -ENOBUFS;\n\n\treturn 0;\n}\n\nstatic void qcauart_netdev_uninit(struct net_device *dev)\n{\n\tstruct qcauart *qca = netdev_priv(dev);\n\n\tdev_kfree_skb(qca->rx_skb);\n}\n\nstatic const struct net_device_ops qcauart_netdev_ops = {\n\t.ndo_init = qcauart_netdev_init,\n\t.ndo_uninit = qcauart_netdev_uninit,\n\t.ndo_open = qcauart_netdev_open,\n\t.ndo_stop = qcauart_netdev_close,\n\t.ndo_start_xmit = qcauart_netdev_xmit,\n\t.ndo_set_mac_address = eth_mac_addr,\n\t.ndo_tx_timeout = qcauart_netdev_tx_timeout,\n\t.ndo_validate_addr = eth_validate_addr,\n};\n\nstatic void qcauart_netdev_setup(struct net_device *dev)\n{\n\tdev->netdev_ops = &qcauart_netdev_ops;\n\tdev->watchdog_timeo = QCAUART_TX_TIMEOUT;\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->tx_queue_len = 100;\n\n\t \n\tdev->min_mtu = QCAFRM_MIN_MTU;\n\tdev->max_mtu = QCAFRM_MAX_MTU;\n}\n\nstatic const struct of_device_id qca_uart_of_match[] = {\n\t{\n\t .compatible = \"qca,qca7000\",\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, qca_uart_of_match);\n\nstatic int qca_uart_probe(struct serdev_device *serdev)\n{\n\tstruct net_device *qcauart_dev = alloc_etherdev(sizeof(struct qcauart));\n\tstruct qcauart *qca;\n\tu32 speed = 115200;\n\tint ret;\n\n\tif (!qcauart_dev)\n\t\treturn -ENOMEM;\n\n\tqcauart_netdev_setup(qcauart_dev);\n\tSET_NETDEV_DEV(qcauart_dev, &serdev->dev);\n\n\tqca = netdev_priv(qcauart_dev);\n\tif (!qca) {\n\t\tpr_err(\"qca_uart: Fail to retrieve private structure\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\tqca->net_dev = qcauart_dev;\n\tqca->serdev = serdev;\n\tqcafrm_fsm_init_uart(&qca->frm_handle);\n\n\tspin_lock_init(&qca->lock);\n\tINIT_WORK(&qca->tx_work, qcauart_transmit);\n\n\tof_property_read_u32(serdev->dev.of_node, \"current-speed\", &speed);\n\n\tret = of_get_ethdev_address(serdev->dev.of_node, qca->net_dev);\n\tif (ret) {\n\t\teth_hw_addr_random(qca->net_dev);\n\t\tdev_info(&serdev->dev, \"Using random MAC address: %pM\\n\",\n\t\t\t qca->net_dev->dev_addr);\n\t}\n\n\tnetif_carrier_on(qca->net_dev);\n\tserdev_device_set_drvdata(serdev, qca);\n\tserdev_device_set_client_ops(serdev, &qca_serdev_ops);\n\n\tret = serdev_device_open(serdev);\n\tif (ret) {\n\t\tdev_err(&serdev->dev, \"Unable to open device %s\\n\",\n\t\t\tqcauart_dev->name);\n\t\tgoto free;\n\t}\n\n\tspeed = serdev_device_set_baudrate(serdev, speed);\n\tdev_info(&serdev->dev, \"Using baudrate: %u\\n\", speed);\n\n\tserdev_device_set_flow_control(serdev, false);\n\n\tret = register_netdev(qcauart_dev);\n\tif (ret) {\n\t\tdev_err(&serdev->dev, \"Unable to register net device %s\\n\",\n\t\t\tqcauart_dev->name);\n\t\tserdev_device_close(serdev);\n\t\tcancel_work_sync(&qca->tx_work);\n\t\tgoto free;\n\t}\n\n\treturn 0;\n\nfree:\n\tfree_netdev(qcauart_dev);\n\treturn ret;\n}\n\nstatic void qca_uart_remove(struct serdev_device *serdev)\n{\n\tstruct qcauart *qca = serdev_device_get_drvdata(serdev);\n\n\tunregister_netdev(qca->net_dev);\n\n\t \n\tserdev_device_close(serdev);\n\tcancel_work_sync(&qca->tx_work);\n\n\tfree_netdev(qca->net_dev);\n}\n\nstatic struct serdev_device_driver qca_uart_driver = {\n\t.probe = qca_uart_probe,\n\t.remove = qca_uart_remove,\n\t.driver = {\n\t\t.name = QCAUART_DRV_NAME,\n\t\t.of_match_table = qca_uart_of_match,\n\t},\n};\n\nmodule_serdev_device_driver(qca_uart_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm Atheros QCA7000 UART Driver\");\nMODULE_AUTHOR(\"Qualcomm Atheros Communications\");\nMODULE_AUTHOR(\"Stefan Wahren <stefan.wahren@i2se.com>\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_VERSION(QCAUART_DRV_VERSION);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}