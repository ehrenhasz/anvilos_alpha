{
  "module_name": "qca_debug.c",
  "hash_id": "bd4b7cff5f154156770dbf762de8bf267775c262281258415d7d40bd5fcf15a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qualcomm/qca_debug.c",
  "human_readable_source": " \n\n \n\n#include <linux/debugfs.h>\n#include <linux/ethtool.h>\n#include <linux/seq_file.h>\n#include <linux/types.h>\n\n#include \"qca_7k.h\"\n#include \"qca_debug.h\"\n\n#define QCASPI_MAX_REGS 0x20\n\n#define QCASPI_RX_MAX_FRAMES 4\n\nstatic const u16 qcaspi_spi_regs[] = {\n\tSPI_REG_BFR_SIZE,\n\tSPI_REG_WRBUF_SPC_AVA,\n\tSPI_REG_RDBUF_BYTE_AVA,\n\tSPI_REG_SPI_CONFIG,\n\tSPI_REG_SPI_STATUS,\n\tSPI_REG_INTR_CAUSE,\n\tSPI_REG_INTR_ENABLE,\n\tSPI_REG_RDBUF_WATERMARK,\n\tSPI_REG_WRBUF_WATERMARK,\n\tSPI_REG_SIGNATURE,\n\tSPI_REG_ACTION_CTRL\n};\n\n \nstatic const char qcaspi_gstrings_stats[][ETH_GSTRING_LEN] = {\n\t\"Triggered resets\",\n\t\"Device resets\",\n\t\"Reset timeouts\",\n\t\"Read errors\",\n\t\"Write errors\",\n\t\"Read buffer errors\",\n\t\"Write buffer errors\",\n\t\"Out of memory\",\n\t\"Write buffer misses\",\n\t\"Transmit ring full\",\n\t\"SPI errors\",\n\t\"Write verify errors\",\n\t\"Buffer available errors\",\n\t\"Bad signature\",\n};\n\n#ifdef CONFIG_DEBUG_FS\n\nstatic int\nqcaspi_info_show(struct seq_file *s, void *what)\n{\n\tstruct qcaspi *qca = s->private;\n\n\tseq_printf(s, \"RX buffer size   : %lu\\n\",\n\t\t   (unsigned long)qca->buffer_size);\n\n\tseq_puts(s, \"TX ring state    : \");\n\n\tif (qca->txr.skb[qca->txr.head] == NULL)\n\t\tseq_puts(s, \"empty\");\n\telse if (qca->txr.skb[qca->txr.tail])\n\t\tseq_puts(s, \"full\");\n\telse\n\t\tseq_puts(s, \"in use\");\n\n\tseq_puts(s, \"\\n\");\n\n\tseq_printf(s, \"TX ring size     : %u\\n\",\n\t\t   qca->txr.size);\n\n\tseq_printf(s, \"Sync state       : %u (\",\n\t\t   (unsigned int)qca->sync);\n\tswitch (qca->sync) {\n\tcase QCASPI_SYNC_UNKNOWN:\n\t\tseq_puts(s, \"QCASPI_SYNC_UNKNOWN\");\n\t\tbreak;\n\tcase QCASPI_SYNC_RESET:\n\t\tseq_puts(s, \"QCASPI_SYNC_RESET\");\n\t\tbreak;\n\tcase QCASPI_SYNC_READY:\n\t\tseq_puts(s, \"QCASPI_SYNC_READY\");\n\t\tbreak;\n\tdefault:\n\t\tseq_puts(s, \"INVALID\");\n\t\tbreak;\n\t}\n\tseq_puts(s, \")\\n\");\n\n\tseq_printf(s, \"IRQ              : %d\\n\",\n\t\t   qca->spi_dev->irq);\n\tseq_printf(s, \"INTR REQ         : %u\\n\",\n\t\t   qca->intr_req);\n\tseq_printf(s, \"INTR SVC         : %u\\n\",\n\t\t   qca->intr_svc);\n\n\tseq_printf(s, \"SPI max speed    : %lu\\n\",\n\t\t   (unsigned long)qca->spi_dev->max_speed_hz);\n\tseq_printf(s, \"SPI mode         : %x\\n\",\n\t\t   qca->spi_dev->mode);\n\tseq_printf(s, \"SPI chip select  : %u\\n\",\n\t\t   (unsigned int)spi_get_chipselect(qca->spi_dev, 0));\n\tseq_printf(s, \"SPI legacy mode  : %u\\n\",\n\t\t   (unsigned int)qca->legacy_mode);\n\tseq_printf(s, \"SPI burst length : %u\\n\",\n\t\t   (unsigned int)qca->burst_len);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(qcaspi_info);\n\nvoid\nqcaspi_init_device_debugfs(struct qcaspi *qca)\n{\n\tqca->device_root = debugfs_create_dir(dev_name(&qca->net_dev->dev),\n\t\t\t\t\t      NULL);\n\n\tdebugfs_create_file(\"info\", S_IFREG | 0444, qca->device_root, qca,\n\t\t\t    &qcaspi_info_fops);\n}\n\nvoid\nqcaspi_remove_device_debugfs(struct qcaspi *qca)\n{\n\tdebugfs_remove_recursive(qca->device_root);\n}\n\n#else  \n\nvoid\nqcaspi_init_device_debugfs(struct qcaspi *qca)\n{\n}\n\nvoid\nqcaspi_remove_device_debugfs(struct qcaspi *qca)\n{\n}\n\n#endif\n\nstatic void\nqcaspi_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *p)\n{\n\tstruct qcaspi *qca = netdev_priv(dev);\n\n\tstrscpy(p->driver, QCASPI_DRV_NAME, sizeof(p->driver));\n\tstrscpy(p->version, QCASPI_DRV_VERSION, sizeof(p->version));\n\tstrscpy(p->fw_version, \"QCA7000\", sizeof(p->fw_version));\n\tstrscpy(p->bus_info, dev_name(&qca->spi_dev->dev),\n\t\tsizeof(p->bus_info));\n}\n\nstatic int\nqcaspi_get_link_ksettings(struct net_device *dev,\n\t\t\t  struct ethtool_link_ksettings *cmd)\n{\n\tethtool_link_ksettings_zero_link_mode(cmd, supported);\n\tethtool_link_ksettings_add_link_mode(cmd, supported, 10baseT_Half);\n\n\tcmd->base.speed = SPEED_10;\n\tcmd->base.duplex = DUPLEX_HALF;\n\tcmd->base.port = PORT_OTHER;\n\tcmd->base.autoneg = AUTONEG_DISABLE;\n\n\treturn 0;\n}\n\nstatic void\nqcaspi_get_ethtool_stats(struct net_device *dev, struct ethtool_stats *estats, u64 *data)\n{\n\tstruct qcaspi *qca = netdev_priv(dev);\n\tstruct qcaspi_stats *st = &qca->stats;\n\n\tmemcpy(data, st, ARRAY_SIZE(qcaspi_gstrings_stats) * sizeof(u64));\n}\n\nstatic void\nqcaspi_get_strings(struct net_device *dev, u32 stringset, u8 *buf)\n{\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tmemcpy(buf, &qcaspi_gstrings_stats,\n\t\t       sizeof(qcaspi_gstrings_stats));\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n}\n\nstatic int\nqcaspi_get_sset_count(struct net_device *dev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn ARRAY_SIZE(qcaspi_gstrings_stats);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int\nqcaspi_get_regs_len(struct net_device *dev)\n{\n\treturn sizeof(u32) * QCASPI_MAX_REGS;\n}\n\nstatic void\nqcaspi_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *p)\n{\n\tstruct qcaspi *qca = netdev_priv(dev);\n\tu32 *regs_buff = p;\n\tunsigned int i;\n\n\tregs->version = 1;\n\tmemset(regs_buff, 0, sizeof(u32) * QCASPI_MAX_REGS);\n\n\tfor (i = 0; i < ARRAY_SIZE(qcaspi_spi_regs); i++) {\n\t\tu16 offset, value;\n\n\t\tqcaspi_read_register(qca, qcaspi_spi_regs[i], &value);\n\t\toffset = qcaspi_spi_regs[i] >> 8;\n\t\tregs_buff[offset] = value;\n\t}\n}\n\nstatic void\nqcaspi_get_ringparam(struct net_device *dev, struct ethtool_ringparam *ring,\n\t\t     struct kernel_ethtool_ringparam *kernel_ring,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct qcaspi *qca = netdev_priv(dev);\n\n\tring->rx_max_pending = QCASPI_RX_MAX_FRAMES;\n\tring->tx_max_pending = TX_RING_MAX_LEN;\n\tring->rx_pending = QCASPI_RX_MAX_FRAMES;\n\tring->tx_pending = qca->txr.count;\n}\n\nstatic int\nqcaspi_set_ringparam(struct net_device *dev, struct ethtool_ringparam *ring,\n\t\t     struct kernel_ethtool_ringparam *kernel_ring,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct qcaspi *qca = netdev_priv(dev);\n\n\tif (ring->rx_pending != QCASPI_RX_MAX_FRAMES ||\n\t    (ring->rx_mini_pending) ||\n\t    (ring->rx_jumbo_pending))\n\t\treturn -EINVAL;\n\n\tif (qca->spi_thread)\n\t\tkthread_park(qca->spi_thread);\n\n\tqca->txr.count = max_t(u32, ring->tx_pending, TX_RING_MIN_LEN);\n\tqca->txr.count = min_t(u16, qca->txr.count, TX_RING_MAX_LEN);\n\n\tif (qca->spi_thread)\n\t\tkthread_unpark(qca->spi_thread);\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops qcaspi_ethtool_ops = {\n\t.get_drvinfo = qcaspi_get_drvinfo,\n\t.get_link = ethtool_op_get_link,\n\t.get_ethtool_stats = qcaspi_get_ethtool_stats,\n\t.get_strings = qcaspi_get_strings,\n\t.get_sset_count = qcaspi_get_sset_count,\n\t.get_regs_len = qcaspi_get_regs_len,\n\t.get_regs = qcaspi_get_regs,\n\t.get_ringparam = qcaspi_get_ringparam,\n\t.set_ringparam = qcaspi_set_ringparam,\n\t.get_link_ksettings = qcaspi_get_link_ksettings,\n};\n\nvoid qcaspi_set_ethtool_ops(struct net_device *dev)\n{\n\tdev->ethtool_ops = &qcaspi_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}