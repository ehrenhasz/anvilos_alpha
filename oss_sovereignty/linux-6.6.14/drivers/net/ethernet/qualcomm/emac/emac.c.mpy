{
  "module_name": "emac.c",
  "hash_id": "d65183460730c3960530f597af8a56194fbcdd2a1a9170ec3375ed49dbff17d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qualcomm/emac/emac.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/if_ether.h>\n#include <linux/if_vlan.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n#include <linux/acpi.h>\n#include \"emac.h\"\n#include \"emac-mac.h\"\n#include \"emac-phy.h\"\n#include \"emac-sgmii.h\"\n\n#define EMAC_MSG_DEFAULT (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK |  \\\n\t\tNETIF_MSG_TIMER | NETIF_MSG_IFDOWN | NETIF_MSG_IFUP)\n\n#define EMAC_RRD_SIZE\t\t\t\t\t     4\n \n#define EMAC_TS_RRD_SIZE\t\t\t\t     6\n#define EMAC_TPD_SIZE\t\t\t\t\t     4\n#define EMAC_RFD_SIZE\t\t\t\t\t     2\n\n#define REG_MAC_RX_STATUS_BIN\t\t EMAC_RXMAC_STATC_REG0\n#define REG_MAC_RX_STATUS_END\t\tEMAC_RXMAC_STATC_REG22\n#define REG_MAC_TX_STATUS_BIN\t\t EMAC_TXMAC_STATC_REG0\n#define REG_MAC_TX_STATUS_END\t\tEMAC_TXMAC_STATC_REG24\n\n#define RXQ0_NUM_RFD_PREF_DEF\t\t\t\t     8\n#define TXQ0_NUM_TPD_PREF_DEF\t\t\t\t     5\n\n#define EMAC_PREAMBLE_DEF\t\t\t\t     7\n\n#define DMAR_DLY_CNT_DEF\t\t\t\t    15\n#define DMAW_DLY_CNT_DEF\t\t\t\t     4\n\n#define IMR_NORMAL_MASK\t\t(ISR_ERROR | ISR_OVER | ISR_TX_PKT)\n\n#define ISR_TX_PKT      (\\\n\tTX_PKT_INT      |\\\n\tTX_PKT_INT1     |\\\n\tTX_PKT_INT2     |\\\n\tTX_PKT_INT3)\n\n#define ISR_OVER        (\\\n\tRFD0_UR_INT     |\\\n\tRFD1_UR_INT     |\\\n\tRFD2_UR_INT     |\\\n\tRFD3_UR_INT     |\\\n\tRFD4_UR_INT     |\\\n\tRXF_OF_INT      |\\\n\tTXF_UR_INT)\n\n#define ISR_ERROR       (\\\n\tDMAR_TO_INT     |\\\n\tDMAW_TO_INT     |\\\n\tTXQ_TO_INT)\n\n \nstatic const char * const emac_clk_name[] = {\n\t\"axi_clk\", \"cfg_ahb_clk\", \"high_speed_clk\", \"mdio_clk\", \"tx_clk\",\n\t\"rx_clk\", \"sys_clk\"\n};\n\nvoid emac_reg_update32(void __iomem *addr, u32 mask, u32 val)\n{\n\tu32 data = readl(addr);\n\n\twritel(((data & ~mask) | val), addr);\n}\n\n \nint emac_reinit_locked(struct emac_adapter *adpt)\n{\n\tint ret;\n\n\tmutex_lock(&adpt->reset_lock);\n\n\temac_mac_down(adpt);\n\temac_sgmii_reset(adpt);\n\tret = emac_mac_up(adpt);\n\n\tmutex_unlock(&adpt->reset_lock);\n\n\treturn ret;\n}\n\n \nstatic int emac_napi_rtx(struct napi_struct *napi, int budget)\n{\n\tstruct emac_rx_queue *rx_q =\n\t\tcontainer_of(napi, struct emac_rx_queue, napi);\n\tstruct emac_adapter *adpt = netdev_priv(rx_q->netdev);\n\tstruct emac_irq *irq = rx_q->irq;\n\tint work_done = 0;\n\n\temac_mac_rx_process(adpt, rx_q, &work_done, budget);\n\n\tif (work_done < budget) {\n\t\tnapi_complete_done(napi, work_done);\n\n\t\tirq->mask |= rx_q->intr;\n\t\twritel(irq->mask, adpt->base + EMAC_INT_MASK);\n\t}\n\n\treturn work_done;\n}\n\n \nstatic netdev_tx_t emac_start_xmit(struct sk_buff *skb,\n\t\t\t\t   struct net_device *netdev)\n{\n\tstruct emac_adapter *adpt = netdev_priv(netdev);\n\n\treturn emac_mac_tx_buf_send(adpt, &adpt->tx_q, skb);\n}\n\nstatic irqreturn_t emac_isr(int _irq, void *data)\n{\n\tstruct emac_irq *irq = data;\n\tstruct emac_adapter *adpt =\n\t\tcontainer_of(irq, struct emac_adapter, irq);\n\tstruct emac_rx_queue *rx_q = &adpt->rx_q;\n\tu32 isr, status;\n\n\t \n\twritel(0, adpt->base + EMAC_INT_MASK);\n\n\tisr = readl_relaxed(adpt->base + EMAC_INT_STATUS);\n\n\tstatus = isr & irq->mask;\n\tif (status == 0)\n\t\tgoto exit;\n\n\tif (status & ISR_ERROR) {\n\t\tnet_err_ratelimited(\"%s: error interrupt 0x%lx\\n\",\n\t\t\t\t    adpt->netdev->name, status & ISR_ERROR);\n\t\t \n\t\tschedule_work(&adpt->work_thread);\n\t}\n\n\t \n\tif (status & rx_q->intr) {\n\t\tif (napi_schedule_prep(&rx_q->napi)) {\n\t\t\tirq->mask &= ~rx_q->intr;\n\t\t\t__napi_schedule(&rx_q->napi);\n\t\t}\n\t}\n\n\tif (status & TX_PKT_INT)\n\t\temac_mac_tx_process(adpt, &adpt->tx_q);\n\n\tif (status & ISR_OVER)\n\t\tnet_warn_ratelimited(\"%s: TX/RX overflow interrupt\\n\",\n\t\t\t\t     adpt->netdev->name);\n\nexit:\n\t \n\twritel(irq->mask, adpt->base + EMAC_INT_MASK);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int emac_set_features(struct net_device *netdev,\n\t\t\t     netdev_features_t features)\n{\n\tnetdev_features_t changed = features ^ netdev->features;\n\tstruct emac_adapter *adpt = netdev_priv(netdev);\n\n\t \n\tif (!(changed & (NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX)))\n\t\treturn 0;\n\n\tif (!netif_running(netdev))\n\t\treturn 0;\n\n\t \n\tnetdev->features = features;\n\n\treturn emac_reinit_locked(adpt);\n}\n\n \nstatic void emac_rx_mode_set(struct net_device *netdev)\n{\n\tstruct emac_adapter *adpt = netdev_priv(netdev);\n\tstruct netdev_hw_addr *ha;\n\n\temac_mac_mode_config(adpt);\n\n\t \n\temac_mac_multicast_addr_clear(adpt);\n\tnetdev_for_each_mc_addr(ha, netdev)\n\t\temac_mac_multicast_addr_set(adpt, ha->addr);\n}\n\n \nstatic int emac_change_mtu(struct net_device *netdev, int new_mtu)\n{\n\tstruct emac_adapter *adpt = netdev_priv(netdev);\n\n\tnetif_dbg(adpt, hw, adpt->netdev,\n\t\t  \"changing MTU from %d to %d\\n\", netdev->mtu,\n\t\t  new_mtu);\n\tnetdev->mtu = new_mtu;\n\n\tif (netif_running(netdev))\n\t\treturn emac_reinit_locked(adpt);\n\n\treturn 0;\n}\n\n \nstatic int emac_open(struct net_device *netdev)\n{\n\tstruct emac_adapter *adpt = netdev_priv(netdev);\n\tstruct emac_irq\t*irq = &adpt->irq;\n\tint ret;\n\n\tret = request_irq(irq->irq, emac_isr, 0, \"emac-core0\", irq);\n\tif (ret) {\n\t\tnetdev_err(adpt->netdev, \"could not request emac-core0 irq\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = emac_mac_rx_tx_rings_alloc_all(adpt);\n\tif (ret) {\n\t\tnetdev_err(adpt->netdev, \"error allocating rx/tx rings\\n\");\n\t\tfree_irq(irq->irq, irq);\n\t\treturn ret;\n\t}\n\n\tret = emac_sgmii_open(adpt);\n\tif (ret) {\n\t\temac_mac_rx_tx_rings_free_all(adpt);\n\t\tfree_irq(irq->irq, irq);\n\t\treturn ret;\n\t}\n\n\tret = emac_mac_up(adpt);\n\tif (ret) {\n\t\temac_mac_rx_tx_rings_free_all(adpt);\n\t\tfree_irq(irq->irq, irq);\n\t\temac_sgmii_close(adpt);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int emac_close(struct net_device *netdev)\n{\n\tstruct emac_adapter *adpt = netdev_priv(netdev);\n\n\tmutex_lock(&adpt->reset_lock);\n\n\temac_sgmii_close(adpt);\n\temac_mac_down(adpt);\n\temac_mac_rx_tx_rings_free_all(adpt);\n\n\tfree_irq(adpt->irq.irq, &adpt->irq);\n\n\tmutex_unlock(&adpt->reset_lock);\n\n\treturn 0;\n}\n\n \nstatic void emac_tx_timeout(struct net_device *netdev, unsigned int txqueue)\n{\n\tstruct emac_adapter *adpt = netdev_priv(netdev);\n\n\tschedule_work(&adpt->work_thread);\n}\n\n \nvoid emac_update_hw_stats(struct emac_adapter *adpt)\n{\n\tstruct emac_stats *stats = &adpt->stats;\n\tu64 *stats_itr = &adpt->stats.rx_ok;\n\tvoid __iomem *base = adpt->base;\n\tunsigned int addr;\n\n\taddr = REG_MAC_RX_STATUS_BIN;\n\twhile (addr <= REG_MAC_RX_STATUS_END) {\n\t\t*stats_itr += readl_relaxed(base + addr);\n\t\tstats_itr++;\n\t\taddr += sizeof(u32);\n\t}\n\n\t \n\tstats->rx_crc_align += readl_relaxed(base + EMAC_RXMAC_STATC_REG23);\n\tstats->rx_jabbers += readl_relaxed(base + EMAC_RXMAC_STATC_REG24);\n\n\t \n\taddr = REG_MAC_TX_STATUS_BIN;\n\tstats_itr = &stats->tx_ok;\n\n\twhile (addr <= REG_MAC_TX_STATUS_END) {\n\t\t*stats_itr += readl_relaxed(base + addr);\n\t\tstats_itr++;\n\t\taddr += sizeof(u32);\n\t}\n\n\t \n\tstats->tx_col += readl_relaxed(base + EMAC_TXMAC_STATC_REG25);\n}\n\n \nstatic void emac_get_stats64(struct net_device *netdev,\n\t\t\t     struct rtnl_link_stats64 *net_stats)\n{\n\tstruct emac_adapter *adpt = netdev_priv(netdev);\n\tstruct emac_stats *stats = &adpt->stats;\n\n\tspin_lock(&stats->lock);\n\n\temac_update_hw_stats(adpt);\n\n\t \n\tnet_stats->rx_packets = stats->rx_ok;\n\tnet_stats->tx_packets = stats->tx_ok;\n\tnet_stats->rx_bytes = stats->rx_byte_cnt;\n\tnet_stats->tx_bytes = stats->tx_byte_cnt;\n\tnet_stats->multicast = stats->rx_mcast;\n\tnet_stats->collisions = stats->tx_1_col + stats->tx_2_col * 2 +\n\t\t\t\tstats->tx_late_col + stats->tx_abort_col;\n\n\tnet_stats->rx_errors = stats->rx_frag + stats->rx_fcs_err +\n\t\t\t       stats->rx_len_err + stats->rx_sz_ov +\n\t\t\t       stats->rx_align_err;\n\tnet_stats->rx_fifo_errors = stats->rx_rxf_ov;\n\tnet_stats->rx_length_errors = stats->rx_len_err;\n\tnet_stats->rx_crc_errors = stats->rx_fcs_err;\n\tnet_stats->rx_frame_errors = stats->rx_align_err;\n\tnet_stats->rx_over_errors = stats->rx_rxf_ov;\n\tnet_stats->rx_missed_errors = stats->rx_rxf_ov;\n\n\tnet_stats->tx_errors = stats->tx_late_col + stats->tx_abort_col +\n\t\t\t       stats->tx_underrun + stats->tx_trunc;\n\tnet_stats->tx_fifo_errors = stats->tx_underrun;\n\tnet_stats->tx_aborted_errors = stats->tx_abort_col;\n\tnet_stats->tx_window_errors = stats->tx_late_col;\n\n\tspin_unlock(&stats->lock);\n}\n\nstatic const struct net_device_ops emac_netdev_ops = {\n\t.ndo_open\t\t= emac_open,\n\t.ndo_stop\t\t= emac_close,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_start_xmit\t\t= emac_start_xmit,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_change_mtu\t\t= emac_change_mtu,\n\t.ndo_eth_ioctl\t\t= phy_do_ioctl_running,\n\t.ndo_tx_timeout\t\t= emac_tx_timeout,\n\t.ndo_get_stats64\t= emac_get_stats64,\n\t.ndo_set_features       = emac_set_features,\n\t.ndo_set_rx_mode        = emac_rx_mode_set,\n};\n\n \nstatic void emac_work_thread(struct work_struct *work)\n{\n\tstruct emac_adapter *adpt =\n\t\tcontainer_of(work, struct emac_adapter, work_thread);\n\n\temac_reinit_locked(adpt);\n}\n\n \nstatic void emac_init_adapter(struct emac_adapter *adpt)\n{\n\tu32 reg;\n\n\tadpt->rrd_size = EMAC_RRD_SIZE;\n\tadpt->tpd_size = EMAC_TPD_SIZE;\n\tadpt->rfd_size = EMAC_RFD_SIZE;\n\n\t \n\tadpt->tx_desc_cnt = EMAC_DEF_TX_DESCS;\n\tadpt->rx_desc_cnt = EMAC_DEF_RX_DESCS;\n\n\t \n\tadpt->dma_order = emac_dma_ord_out;\n\tadpt->dmar_block = emac_dma_req_4096;\n\tadpt->dmaw_block = emac_dma_req_128;\n\tadpt->dmar_dly_cnt = DMAR_DLY_CNT_DEF;\n\tadpt->dmaw_dly_cnt = DMAW_DLY_CNT_DEF;\n\tadpt->tpd_burst = TXQ0_NUM_TPD_PREF_DEF;\n\tadpt->rfd_burst = RXQ0_NUM_RFD_PREF_DEF;\n\n\t \n\treg = ((EMAC_DEF_RX_IRQ_MOD >> 1) << IRQ_MODERATOR2_INIT_SHFT) |\n\t      ((EMAC_DEF_TX_IRQ_MOD >> 1) << IRQ_MODERATOR_INIT_SHFT);\n\tadpt->irq_mod = reg;\n\n\t \n\tadpt->preamble = EMAC_PREAMBLE_DEF;\n\n\t \n\tadpt->automatic = true;\n\n\t \n\tadpt->single_pause_mode = false;\n}\n\n \nstatic int emac_clks_get(struct platform_device *pdev,\n\t\t\t struct emac_adapter *adpt)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < EMAC_CLK_CNT; i++) {\n\t\tstruct clk *clk = devm_clk_get(&pdev->dev, emac_clk_name[i]);\n\n\t\tif (IS_ERR(clk)) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"could not claim clock %s (error=%li)\\n\",\n\t\t\t\temac_clk_name[i], PTR_ERR(clk));\n\n\t\t\treturn PTR_ERR(clk);\n\t\t}\n\n\t\tadpt->clk[i] = clk;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int emac_clks_phase1_init(struct platform_device *pdev,\n\t\t\t\t struct emac_adapter *adpt)\n{\n\tint ret;\n\n\t \n\tif (has_acpi_companion(&pdev->dev))\n\t\treturn 0;\n\n\tret = emac_clks_get(pdev, adpt);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(adpt->clk[EMAC_CLK_AXI]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(adpt->clk[EMAC_CLK_CFG_AHB]);\n\tif (ret)\n\t\tgoto disable_clk_axi;\n\n\tret = clk_set_rate(adpt->clk[EMAC_CLK_HIGH_SPEED], 19200000);\n\tif (ret)\n\t\tgoto disable_clk_cfg_ahb;\n\n\tret = clk_prepare_enable(adpt->clk[EMAC_CLK_HIGH_SPEED]);\n\tif (ret)\n\t\tgoto disable_clk_cfg_ahb;\n\n\treturn 0;\n\ndisable_clk_cfg_ahb:\n\tclk_disable_unprepare(adpt->clk[EMAC_CLK_CFG_AHB]);\ndisable_clk_axi:\n\tclk_disable_unprepare(adpt->clk[EMAC_CLK_AXI]);\n\n\treturn ret;\n}\n\n \nstatic int emac_clks_phase2_init(struct platform_device *pdev,\n\t\t\t\t struct emac_adapter *adpt)\n{\n\tint ret;\n\n\tif (has_acpi_companion(&pdev->dev))\n\t\treturn 0;\n\n\tret = clk_set_rate(adpt->clk[EMAC_CLK_TX], 125000000);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(adpt->clk[EMAC_CLK_TX]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_set_rate(adpt->clk[EMAC_CLK_HIGH_SPEED], 125000000);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_set_rate(adpt->clk[EMAC_CLK_MDIO], 25000000);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(adpt->clk[EMAC_CLK_MDIO]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(adpt->clk[EMAC_CLK_RX]);\n\tif (ret)\n\t\treturn ret;\n\n\treturn clk_prepare_enable(adpt->clk[EMAC_CLK_SYS]);\n}\n\nstatic void emac_clks_teardown(struct emac_adapter *adpt)\n{\n\n\tunsigned int i;\n\n\tfor (i = 0; i < EMAC_CLK_CNT; i++)\n\t\tclk_disable_unprepare(adpt->clk[i]);\n}\n\n \nstatic int emac_probe_resources(struct platform_device *pdev,\n\t\t\t\tstruct emac_adapter *adpt)\n{\n\tstruct net_device *netdev = adpt->netdev;\n\tint ret = 0;\n\n\t \n\tif (device_get_ethdev_address(&pdev->dev, netdev))\n\t\teth_hw_addr_random(netdev);\n\n\t \n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tadpt->irq.irq = ret;\n\n\t \n\tadpt->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(adpt->base))\n\t\treturn PTR_ERR(adpt->base);\n\n\t \n\tadpt->csr = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(adpt->csr))\n\t\treturn PTR_ERR(adpt->csr);\n\n\tnetdev->base_addr = (unsigned long)adpt->base;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id emac_dt_match[] = {\n\t{\n\t\t.compatible = \"qcom,fsm9900-emac\",\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, emac_dt_match);\n\n#if IS_ENABLED(CONFIG_ACPI)\nstatic const struct acpi_device_id emac_acpi_match[] = {\n\t{\n\t\t.id = \"QCOM8070\",\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, emac_acpi_match);\n#endif\n\nstatic int emac_probe(struct platform_device *pdev)\n{\n\tstruct net_device *netdev;\n\tstruct emac_adapter *adpt;\n\tstruct emac_sgmii *phy;\n\tu16 devid, revid;\n\tu32 reg;\n\tint ret;\n\n\t \n\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(46));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not set DMA mask\\n\");\n\t\treturn ret;\n\t}\n\n\tnetdev = alloc_etherdev(sizeof(struct emac_adapter));\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&pdev->dev, netdev);\n\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\temac_set_ethtool_ops(netdev);\n\n\tadpt = netdev_priv(netdev);\n\tadpt->netdev = netdev;\n\tadpt->msg_enable = EMAC_MSG_DEFAULT;\n\n\tphy = &adpt->phy;\n\tatomic_set(&phy->decode_error_count, 0);\n\n\tmutex_init(&adpt->reset_lock);\n\tspin_lock_init(&adpt->stats.lock);\n\n\tadpt->irq.mask = RX_PKT_INT0 | IMR_NORMAL_MASK;\n\n\tret = emac_probe_resources(pdev, adpt);\n\tif (ret)\n\t\tgoto err_undo_netdev;\n\n\t \n\tret = emac_clks_phase1_init(pdev, adpt);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not initialize clocks\\n\");\n\t\tgoto err_undo_netdev;\n\t}\n\n\tnetdev->watchdog_timeo = EMAC_WATCHDOG_TIME;\n\tnetdev->irq = adpt->irq.irq;\n\n\tnetdev->netdev_ops = &emac_netdev_ops;\n\n\temac_init_adapter(adpt);\n\n\t \n\tret = emac_phy_config(pdev, adpt);\n\tif (ret)\n\t\tgoto err_undo_clocks;\n\n\t \n\tret = emac_sgmii_config(pdev, adpt);\n\tif (ret)\n\t\tgoto err_undo_mdiobus;\n\n\t \n\tret = emac_clks_phase2_init(pdev, adpt);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not initialize clocks\\n\");\n\t\tgoto err_undo_mdiobus;\n\t}\n\n\t \n\tnetdev->features = NETIF_F_SG | NETIF_F_HW_CSUM | NETIF_F_RXCSUM |\n\t\t\tNETIF_F_TSO | NETIF_F_TSO6 | NETIF_F_HW_VLAN_CTAG_RX |\n\t\t\tNETIF_F_HW_VLAN_CTAG_TX;\n\tnetdev->hw_features = netdev->features;\n\n\tnetdev->vlan_features |= NETIF_F_SG | NETIF_F_HW_CSUM |\n\t\t\t\t NETIF_F_TSO | NETIF_F_TSO6;\n\n\t \n\tnetdev->min_mtu = EMAC_MIN_ETH_FRAME_SIZE -\n\t\t\t  (ETH_HLEN + ETH_FCS_LEN + VLAN_HLEN);\n\tnetdev->max_mtu = EMAC_MAX_ETH_FRAME_SIZE -\n\t\t\t  (ETH_HLEN + ETH_FCS_LEN + VLAN_HLEN);\n\n\tINIT_WORK(&adpt->work_thread, emac_work_thread);\n\n\t \n\temac_mac_rx_tx_ring_init_all(pdev, adpt);\n\n\tnetif_napi_add(netdev, &adpt->rx_q.napi, emac_napi_rtx);\n\n\tret = register_netdev(netdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not register net device\\n\");\n\t\tgoto err_undo_napi;\n\t}\n\n\treg =  readl_relaxed(adpt->base + EMAC_DMA_MAS_CTRL);\n\tdevid = (reg & DEV_ID_NUM_BMSK)  >> DEV_ID_NUM_SHFT;\n\trevid = (reg & DEV_REV_NUM_BMSK) >> DEV_REV_NUM_SHFT;\n\treg = readl_relaxed(adpt->base + EMAC_CORE_HW_VERSION);\n\n\tnetif_info(adpt, probe, netdev,\n\t\t   \"hardware id %d.%d, hardware version %d.%d.%d\\n\",\n\t\t   devid, revid,\n\t\t   (reg & MAJOR_BMSK) >> MAJOR_SHFT,\n\t\t   (reg & MINOR_BMSK) >> MINOR_SHFT,\n\t\t   (reg & STEP_BMSK)  >> STEP_SHFT);\n\n\treturn 0;\n\nerr_undo_napi:\n\tnetif_napi_del(&adpt->rx_q.napi);\nerr_undo_mdiobus:\n\tput_device(&adpt->phydev->mdio.dev);\n\tmdiobus_unregister(adpt->mii_bus);\nerr_undo_clocks:\n\temac_clks_teardown(adpt);\nerr_undo_netdev:\n\tfree_netdev(netdev);\n\n\treturn ret;\n}\n\nstatic int emac_remove(struct platform_device *pdev)\n{\n\tstruct net_device *netdev = dev_get_drvdata(&pdev->dev);\n\tstruct emac_adapter *adpt = netdev_priv(netdev);\n\n\tnetif_carrier_off(netdev);\n\tnetif_tx_disable(netdev);\n\n\tunregister_netdev(netdev);\n\tnetif_napi_del(&adpt->rx_q.napi);\n\n\tfree_irq(adpt->irq.irq, &adpt->irq);\n\tcancel_work_sync(&adpt->work_thread);\n\n\temac_clks_teardown(adpt);\n\n\tput_device(&adpt->phydev->mdio.dev);\n\tmdiobus_unregister(adpt->mii_bus);\n\n\tif (adpt->phy.digital)\n\t\tiounmap(adpt->phy.digital);\n\tiounmap(adpt->phy.base);\n\n\tfree_netdev(netdev);\n\n\treturn 0;\n}\n\nstatic void emac_shutdown(struct platform_device *pdev)\n{\n\tstruct net_device *netdev = dev_get_drvdata(&pdev->dev);\n\tstruct emac_adapter *adpt = netdev_priv(netdev);\n\n\tif (netdev->flags & IFF_UP) {\n\t\t \n\t\temac_sgmii_close(adpt);\n\n\t\t \n\t\temac_mac_reset(adpt);\n\t}\n}\n\nstatic struct platform_driver emac_platform_driver = {\n\t.probe\t= emac_probe,\n\t.remove\t= emac_remove,\n\t.driver = {\n\t\t.name\t\t= \"qcom-emac\",\n\t\t.of_match_table = emac_dt_match,\n\t\t.acpi_match_table = ACPI_PTR(emac_acpi_match),\n\t},\n\t.shutdown = emac_shutdown,\n};\n\nmodule_platform_driver(emac_platform_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:qcom-emac\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}