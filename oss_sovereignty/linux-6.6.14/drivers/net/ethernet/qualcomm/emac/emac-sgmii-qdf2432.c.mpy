{
  "module_name": "emac-sgmii-qdf2432.c",
  "hash_id": "1a10130dbcb84d0f9d608d8493d1d0e76ca200689c30dcd666fb59262788b103",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qualcomm/emac/emac-sgmii-qdf2432.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/iopoll.h>\n#include \"emac.h\"\n\n \n#define EMAC_SGMII_PHY_TX_PWR_CTRL\t\t0x000C\n#define EMAC_SGMII_PHY_LANE_CTRL1\t\t0x0018\n#define EMAC_SGMII_PHY_CDR_CTRL0\t\t0x0058\n#define EMAC_SGMII_PHY_POW_DWN_CTRL0\t\t0x0080\n#define EMAC_SGMII_PHY_RESET_CTRL\t\t0x00a8\n#define EMAC_SGMII_PHY_INTERRUPT_MASK\t\t0x00b4\n\n \n#define EMAC_SGMII_LN_DRVR_CTRL0\t\t0x000C\n#define EMAC_SGMII_LN_DRVR_TAP_EN\t\t0x0018\n#define EMAC_SGMII_LN_TX_MARGINING\t\t0x001C\n#define EMAC_SGMII_LN_TX_PRE\t\t\t0x0020\n#define EMAC_SGMII_LN_TX_POST\t\t\t0x0024\n#define EMAC_SGMII_LN_TX_BAND_MODE\t\t0x0060\n#define EMAC_SGMII_LN_LANE_MODE\t\t\t0x0064\n#define EMAC_SGMII_LN_PARALLEL_RATE\t\t0x0078\n#define EMAC_SGMII_LN_CML_CTRL_MODE0\t\t0x00B8\n#define EMAC_SGMII_LN_MIXER_CTRL_MODE0\t\t0x00D0\n#define EMAC_SGMII_LN_VGA_INITVAL\t\t0x0134\n#define EMAC_SGMII_LN_UCDR_FO_GAIN_MODE0\t0x017C\n#define EMAC_SGMII_LN_UCDR_SO_GAIN_MODE0\t0x0188\n#define EMAC_SGMII_LN_UCDR_SO_CONFIG\t\t0x0194\n#define EMAC_SGMII_LN_RX_BAND\t\t\t0x019C\n#define EMAC_SGMII_LN_RX_RCVR_PATH1_MODE0\t0x01B8\n#define EMAC_SGMII_LN_RSM_CONFIG\t\t0x01F0\n#define EMAC_SGMII_LN_SIGDET_ENABLES\t\t0x0224\n#define EMAC_SGMII_LN_SIGDET_CNTRL\t\t0x0228\n#define EMAC_SGMII_LN_SIGDET_DEGLITCH_CNTRL\t0x022C\n#define EMAC_SGMII_LN_RX_EN_SIGNAL\t\t0x02A0\n#define EMAC_SGMII_LN_RX_MISC_CNTRL0\t\t0x02AC\n#define EMAC_SGMII_LN_DRVR_LOGIC_CLKDIV\t\t0x02BC\n\n \n#define UCDR_STEP_BY_TWO_MODE0\t\t\tBIT(7)\n#define UCDR_xO_GAIN_MODE(x)\t\t\t((x) & 0x7f)\n#define UCDR_ENABLE\t\t\t\tBIT(6)\n#define UCDR_SO_SATURATION(x)\t\t\t((x) & 0x3f)\n\n#define SIGDET_LP_BYP_PS4\t\t\tBIT(7)\n#define SIGDET_EN_PS0_TO_PS2\t\t\tBIT(6)\n\n#define TXVAL_VALID_INIT\t\t\tBIT(4)\n#define KR_PCIGEN3_MODE\t\t\t\tBIT(0)\n\n#define MAIN_EN\t\t\t\t\tBIT(0)\n\n#define TX_MARGINING_MUX\t\t\tBIT(6)\n#define TX_MARGINING(x)\t\t\t\t((x) & 0x3f)\n\n#define TX_PRE_MUX\t\t\t\tBIT(6)\n\n#define TX_POST_MUX\t\t\t\tBIT(6)\n\n#define CML_GEAR_MODE(x)\t\t\t(((x) & 7) << 3)\n#define CML2CMOS_IBOOST_MODE(x)\t\t\t((x) & 7)\n\n#define MIXER_LOADB_MODE(x)\t\t\t(((x) & 0xf) << 2)\n#define MIXER_DATARATE_MODE(x)\t\t\t((x) & 3)\n\n#define VGA_THRESH_DFE(x)\t\t\t((x) & 0x3f)\n\n#define SIGDET_LP_BYP_PS0_TO_PS2\t\tBIT(5)\n#define SIGDET_FLT_BYP\t\t\t\tBIT(0)\n\n#define SIGDET_LVL(x)\t\t\t\t(((x) & 0xf) << 4)\n\n#define SIGDET_DEGLITCH_CTRL(x)\t\t\t(((x) & 0xf) << 1)\n\n#define DRVR_LOGIC_CLK_EN\t\t\tBIT(4)\n#define DRVR_LOGIC_CLK_DIV(x)\t\t\t((x) & 0xf)\n\n#define PARALLEL_RATE_MODE0(x)\t\t\t((x) & 0x3)\n\n#define BAND_MODE0(x)\t\t\t\t((x) & 0x3)\n\n#define LANE_MODE(x)\t\t\t\t((x) & 0x1f)\n\n#define CDR_PD_SEL_MODE0(x)\t\t\t(((x) & 0x3) << 5)\n#define BYPASS_RSM_SAMP_CAL\t\t\tBIT(1)\n#define BYPASS_RSM_DLL_CAL\t\t\tBIT(0)\n\n#define L0_RX_EQUALIZE_ENABLE\t\t\tBIT(6)\n\n#define PWRDN_B\t\t\t\t\tBIT(0)\n\n#define CDR_MAX_CNT(x)\t\t\t\t((x) & 0xff)\n\n#define SERDES_START_WAIT_TIMES\t\t\t100\n\nstruct emac_reg_write {\n\tunsigned int offset;\n\tu32 val;\n};\n\nstatic void emac_reg_write_all(void __iomem *base,\n\t\t\t       const struct emac_reg_write *itr, size_t size)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < size; ++itr, ++i)\n\t\twritel(itr->val, base + itr->offset);\n}\n\nstatic const struct emac_reg_write sgmii_laned[] = {\n\t \n\t{EMAC_SGMII_LN_UCDR_FO_GAIN_MODE0,\n\t\tUCDR_STEP_BY_TWO_MODE0 | UCDR_xO_GAIN_MODE(10)},\n\t{EMAC_SGMII_LN_UCDR_SO_GAIN_MODE0, UCDR_xO_GAIN_MODE(0)},\n\t{EMAC_SGMII_LN_UCDR_SO_CONFIG, UCDR_ENABLE | UCDR_SO_SATURATION(12)},\n\n\t \n\t{EMAC_SGMII_LN_RX_EN_SIGNAL, SIGDET_LP_BYP_PS4 | SIGDET_EN_PS0_TO_PS2},\n\n\t{EMAC_SGMII_LN_DRVR_CTRL0, TXVAL_VALID_INIT | KR_PCIGEN3_MODE},\n\t{EMAC_SGMII_LN_DRVR_TAP_EN, MAIN_EN},\n\t{EMAC_SGMII_LN_TX_MARGINING, TX_MARGINING_MUX | TX_MARGINING(25)},\n\t{EMAC_SGMII_LN_TX_PRE, TX_PRE_MUX},\n\t{EMAC_SGMII_LN_TX_POST, TX_POST_MUX},\n\n\t{EMAC_SGMII_LN_CML_CTRL_MODE0,\n\t\tCML_GEAR_MODE(1) | CML2CMOS_IBOOST_MODE(1)},\n\t{EMAC_SGMII_LN_MIXER_CTRL_MODE0,\n\t\tMIXER_LOADB_MODE(12) | MIXER_DATARATE_MODE(1)},\n\t{EMAC_SGMII_LN_VGA_INITVAL, VGA_THRESH_DFE(31)},\n\t{EMAC_SGMII_LN_SIGDET_ENABLES,\n\t\tSIGDET_LP_BYP_PS0_TO_PS2 | SIGDET_FLT_BYP},\n\t{EMAC_SGMII_LN_SIGDET_CNTRL, SIGDET_LVL(8)},\n\n\t{EMAC_SGMII_LN_SIGDET_DEGLITCH_CNTRL, SIGDET_DEGLITCH_CTRL(4)},\n\t{EMAC_SGMII_LN_RX_MISC_CNTRL0, 0},\n\t{EMAC_SGMII_LN_DRVR_LOGIC_CLKDIV,\n\t\tDRVR_LOGIC_CLK_EN | DRVR_LOGIC_CLK_DIV(4)},\n\n\t{EMAC_SGMII_LN_PARALLEL_RATE, PARALLEL_RATE_MODE0(1)},\n\t{EMAC_SGMII_LN_TX_BAND_MODE, BAND_MODE0(2)},\n\t{EMAC_SGMII_LN_RX_BAND, BAND_MODE0(3)},\n\t{EMAC_SGMII_LN_LANE_MODE, LANE_MODE(26)},\n\t{EMAC_SGMII_LN_RX_RCVR_PATH1_MODE0, CDR_PD_SEL_MODE0(3)},\n\t{EMAC_SGMII_LN_RSM_CONFIG, BYPASS_RSM_SAMP_CAL | BYPASS_RSM_DLL_CAL},\n};\n\nstatic const struct emac_reg_write physical_coding_sublayer_programming[] = {\n\t{EMAC_SGMII_PHY_POW_DWN_CTRL0, PWRDN_B},\n\t{EMAC_SGMII_PHY_CDR_CTRL0, CDR_MAX_CNT(15)},\n\t{EMAC_SGMII_PHY_TX_PWR_CTRL, 0},\n\t{EMAC_SGMII_PHY_LANE_CTRL1, L0_RX_EQUALIZE_ENABLE},\n};\n\nint emac_sgmii_init_qdf2432(struct emac_adapter *adpt)\n{\n\tstruct emac_sgmii *phy = &adpt->phy;\n\tvoid __iomem *phy_regs = phy->base;\n\tvoid __iomem *laned = phy->digital;\n\tunsigned int i;\n\tu32 lnstatus;\n\n\t \n\temac_reg_write_all(phy->base, physical_coding_sublayer_programming,\n\t\t\t   ARRAY_SIZE(physical_coding_sublayer_programming));\n\n\t \n\temac_reg_write_all(phy->digital, sgmii_laned, ARRAY_SIZE(sgmii_laned));\n\n\t \n\n\twritel(0, phy_regs + EMAC_SGMII_PHY_RESET_CTRL);\n\twritel(1, laned + SGMII_LN_RSM_START);\n\n\t \n\tfor (i = 0; i < SERDES_START_WAIT_TIMES; i++) {\n\t\tlnstatus = readl(phy_regs + SGMII_PHY_LN_LANE_STATUS);\n\t\tif (lnstatus & BIT(1))\n\t\t\tbreak;\n\t\tusleep_range(100, 200);\n\t}\n\n\tif (i == SERDES_START_WAIT_TIMES) {\n\t\tnetdev_err(adpt->netdev, \"SGMII failed to start\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\twritel(0, phy_regs + SGMII_PHY_LN_BIST_GEN0);\n\twritel(0, phy_regs + SGMII_PHY_LN_BIST_GEN2);\n\twritel(0, phy_regs + SGMII_PHY_LN_CDR_CTRL1);\n\n\t \n\twritel(0, phy_regs + EMAC_SGMII_PHY_INTERRUPT_MASK);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}