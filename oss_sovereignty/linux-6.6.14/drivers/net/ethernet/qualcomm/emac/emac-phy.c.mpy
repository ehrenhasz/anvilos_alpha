{
  "module_name": "emac-phy.c",
  "hash_id": "2416e3ddd1cfbaccf7e5c99e1f8865064b02dba343022cca0d5f2c229311819d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qualcomm/emac/emac-phy.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/of_mdio.h>\n#include <linux/phy.h>\n#include <linux/iopoll.h>\n#include <linux/acpi.h>\n#include \"emac.h\"\n\n \n#define EMAC_MDIO_CTRL                                        0x001414\n#define EMAC_PHY_STS                                          0x001418\n#define EMAC_MDIO_EX_CTRL                                     0x001440\n\n \n#define MDIO_MODE                                              BIT(30)\n#define MDIO_PR                                                BIT(29)\n#define MDIO_AP_EN                                             BIT(28)\n#define MDIO_BUSY                                              BIT(27)\n#define MDIO_CLK_SEL_BMSK                                    0x7000000\n#define MDIO_CLK_SEL_SHFT                                           24\n#define MDIO_START                                             BIT(23)\n#define SUP_PREAMBLE                                           BIT(22)\n#define MDIO_RD_NWR                                            BIT(21)\n#define MDIO_REG_ADDR_BMSK                                    0x1f0000\n#define MDIO_REG_ADDR_SHFT                                          16\n#define MDIO_DATA_BMSK                                          0xffff\n#define MDIO_DATA_SHFT                                               0\n\n \n#define PHY_ADDR_BMSK                                         0x1f0000\n#define PHY_ADDR_SHFT                                               16\n\n#define MDIO_CLK_25_4                                                0\n#define MDIO_CLK_25_28                                               7\n\n#define MDIO_WAIT_TIMES                                           1000\n#define MDIO_STATUS_DELAY_TIME                                       1\n\nstatic int emac_mdio_read(struct mii_bus *bus, int addr, int regnum)\n{\n\tstruct emac_adapter *adpt = bus->priv;\n\tu32 reg;\n\n\temac_reg_update32(adpt->base + EMAC_PHY_STS, PHY_ADDR_BMSK,\n\t\t\t  (addr << PHY_ADDR_SHFT));\n\n\treg = SUP_PREAMBLE |\n\t      ((MDIO_CLK_25_4 << MDIO_CLK_SEL_SHFT) & MDIO_CLK_SEL_BMSK) |\n\t      ((regnum << MDIO_REG_ADDR_SHFT) & MDIO_REG_ADDR_BMSK) |\n\t      MDIO_START | MDIO_RD_NWR;\n\n\twritel(reg, adpt->base + EMAC_MDIO_CTRL);\n\n\tif (readl_poll_timeout(adpt->base + EMAC_MDIO_CTRL, reg,\n\t\t\t       !(reg & (MDIO_START | MDIO_BUSY)),\n\t\t\t       MDIO_STATUS_DELAY_TIME, MDIO_WAIT_TIMES * 100))\n\t\treturn -EIO;\n\n\treturn (reg >> MDIO_DATA_SHFT) & MDIO_DATA_BMSK;\n}\n\nstatic int emac_mdio_write(struct mii_bus *bus, int addr, int regnum, u16 val)\n{\n\tstruct emac_adapter *adpt = bus->priv;\n\tu32 reg;\n\n\temac_reg_update32(adpt->base + EMAC_PHY_STS, PHY_ADDR_BMSK,\n\t\t\t  (addr << PHY_ADDR_SHFT));\n\n\treg = SUP_PREAMBLE |\n\t\t((MDIO_CLK_25_4 << MDIO_CLK_SEL_SHFT) & MDIO_CLK_SEL_BMSK) |\n\t\t((regnum << MDIO_REG_ADDR_SHFT) & MDIO_REG_ADDR_BMSK) |\n\t\t((val << MDIO_DATA_SHFT) & MDIO_DATA_BMSK) |\n\t\tMDIO_START;\n\n\twritel(reg, adpt->base + EMAC_MDIO_CTRL);\n\n\tif (readl_poll_timeout(adpt->base + EMAC_MDIO_CTRL, reg,\n\t\t\t       !(reg & (MDIO_START | MDIO_BUSY)),\n\t\t\t       MDIO_STATUS_DELAY_TIME, MDIO_WAIT_TIMES * 100))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\n \nint emac_phy_config(struct platform_device *pdev, struct emac_adapter *adpt)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct mii_bus *mii_bus;\n\tint ret;\n\n\t \n\tadpt->mii_bus = mii_bus = devm_mdiobus_alloc(&pdev->dev);\n\tif (!mii_bus)\n\t\treturn -ENOMEM;\n\n\tmii_bus->name = \"emac-mdio\";\n\tsnprintf(mii_bus->id, MII_BUS_ID_SIZE, \"%s\", pdev->name);\n\tmii_bus->read = emac_mdio_read;\n\tmii_bus->write = emac_mdio_write;\n\tmii_bus->parent = &pdev->dev;\n\tmii_bus->priv = adpt;\n\n\tif (has_acpi_companion(&pdev->dev)) {\n\t\tu32 phy_addr;\n\n\t\tret = mdiobus_register(mii_bus);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"could not register mdio bus\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tret = device_property_read_u32(&pdev->dev, \"phy-channel\",\n\t\t\t\t\t       &phy_addr);\n\t\tif (ret)\n\t\t\t \n\t\t\tadpt->phydev = phy_find_first(mii_bus);\n\t\telse\n\t\t\tadpt->phydev = mdiobus_get_phy(mii_bus, phy_addr);\n\n\t\t \n\t\tif (adpt->phydev)\n\t\t\tget_device(&adpt->phydev->mdio.dev);\n\t} else {\n\t\tstruct device_node *phy_np;\n\n\t\tret = of_mdiobus_register(mii_bus, np);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"could not register mdio bus\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tphy_np = of_parse_phandle(np, \"phy-handle\", 0);\n\t\tadpt->phydev = of_phy_find_device(phy_np);\n\t\tof_node_put(phy_np);\n\t}\n\n\tif (!adpt->phydev) {\n\t\tdev_err(&pdev->dev, \"could not find external phy\\n\");\n\t\tmdiobus_unregister(mii_bus);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}