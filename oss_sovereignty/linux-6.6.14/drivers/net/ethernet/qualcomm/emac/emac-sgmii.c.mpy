{
  "module_name": "emac-sgmii.c",
  "hash_id": "5d1e7cc70c09fe51d1e6a2bba9ffe2dc802584f5d982f42a97cecf0f88f2795a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/qualcomm/emac/emac-sgmii.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/acpi.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/of_platform.h>\n#include \"emac.h\"\n#include \"emac-mac.h\"\n#include \"emac-sgmii.h\"\n\n \n#define EMAC_SGMII_PHY_AUTONEG_CFG2\t\t0x0048\n#define EMAC_SGMII_PHY_SPEED_CFG1\t\t0x0074\n#define EMAC_SGMII_PHY_IRQ_CMD\t\t\t0x00ac\n#define EMAC_SGMII_PHY_INTERRUPT_CLEAR\t\t0x00b0\n#define EMAC_SGMII_PHY_INTERRUPT_MASK\t\t0x00b4\n#define EMAC_SGMII_PHY_INTERRUPT_STATUS\t\t0x00b8\n#define EMAC_SGMII_PHY_RX_CHK_STATUS\t\t0x00d4\n\n#define FORCE_AN_TX_CFG\t\t\t\tBIT(5)\n#define FORCE_AN_RX_CFG\t\t\t\tBIT(4)\n#define AN_ENABLE\t\t\t\tBIT(0)\n\n#define DUPLEX_MODE\t\t\t\tBIT(4)\n#define SPDMODE_1000\t\t\t\tBIT(1)\n#define SPDMODE_100\t\t\t\tBIT(0)\n#define SPDMODE_10\t\t\t\t0\n\n#define CDR_ALIGN_DET\t\t\t\tBIT(6)\n\n#define IRQ_GLOBAL_CLEAR\t\t\tBIT(0)\n\n#define DECODE_CODE_ERR\t\t\t\tBIT(7)\n#define DECODE_DISP_ERR\t\t\t\tBIT(6)\n\n#define SGMII_PHY_IRQ_CLR_WAIT_TIME\t\t10\n\n#define SGMII_PHY_INTERRUPT_ERR\t\t(DECODE_CODE_ERR | DECODE_DISP_ERR)\n#define SGMII_ISR_MASK  \t\t(SGMII_PHY_INTERRUPT_ERR)\n\n#define SERDES_START_WAIT_TIMES\t\t\t100\n\nint emac_sgmii_init(struct emac_adapter *adpt)\n{\n\tif (!(adpt->phy.sgmii_ops && adpt->phy.sgmii_ops->init))\n\t\treturn 0;\n\n\treturn adpt->phy.sgmii_ops->init(adpt);\n}\n\nint emac_sgmii_open(struct emac_adapter *adpt)\n{\n\tif (!(adpt->phy.sgmii_ops && adpt->phy.sgmii_ops->open))\n\t\treturn 0;\n\n\treturn adpt->phy.sgmii_ops->open(adpt);\n}\n\nvoid emac_sgmii_close(struct emac_adapter *adpt)\n{\n\tif (!(adpt->phy.sgmii_ops && adpt->phy.sgmii_ops->close))\n\t\treturn;\n\n\tadpt->phy.sgmii_ops->close(adpt);\n}\n\nint emac_sgmii_link_change(struct emac_adapter *adpt, bool link_state)\n{\n\tif (!(adpt->phy.sgmii_ops && adpt->phy.sgmii_ops->link_change))\n\t\treturn 0;\n\n\treturn adpt->phy.sgmii_ops->link_change(adpt, link_state);\n}\n\nvoid emac_sgmii_reset(struct emac_adapter *adpt)\n{\n\tif (!(adpt->phy.sgmii_ops && adpt->phy.sgmii_ops->reset))\n\t\treturn;\n\n\tadpt->phy.sgmii_ops->reset(adpt);\n}\n\n \nstatic void emac_sgmii_link_init(struct emac_adapter *adpt)\n{\n\tstruct emac_sgmii *phy = &adpt->phy;\n\tu32 val;\n\n\t \n\tval = readl(phy->base + EMAC_SGMII_PHY_AUTONEG_CFG2);\n\tval &= ~(FORCE_AN_RX_CFG | FORCE_AN_TX_CFG);\n\tval |= AN_ENABLE;\n\twritel(val, phy->base + EMAC_SGMII_PHY_AUTONEG_CFG2);\n}\n\nstatic int emac_sgmii_irq_clear(struct emac_adapter *adpt, u8 irq_bits)\n{\n\tstruct emac_sgmii *phy = &adpt->phy;\n\tu8 status;\n\n\twritel_relaxed(irq_bits, phy->base + EMAC_SGMII_PHY_INTERRUPT_CLEAR);\n\twritel_relaxed(IRQ_GLOBAL_CLEAR, phy->base + EMAC_SGMII_PHY_IRQ_CMD);\n\t \n\twmb();\n\n\t \n\tif (readl_poll_timeout_atomic(phy->base +\n\t\t\t\t      EMAC_SGMII_PHY_INTERRUPT_STATUS,\n\t\t\t\t      status, !(status & irq_bits), 1,\n\t\t\t\t      SGMII_PHY_IRQ_CLR_WAIT_TIME)) {\n\t\tnet_err_ratelimited(\"%s: failed to clear SGMII irq: status:0x%x bits:0x%x\\n\",\n\t\t\t\t    adpt->netdev->name, status, irq_bits);\n\t\treturn -EIO;\n\t}\n\n\t \n\twritel_relaxed(0, phy->base + EMAC_SGMII_PHY_IRQ_CMD);\n\twritel_relaxed(0, phy->base + EMAC_SGMII_PHY_INTERRUPT_CLEAR);\n\n\t \n\twmb();\n\n\treturn 0;\n}\n\n \n#define DECODE_ERROR_LIMIT\t2\n\nstatic irqreturn_t emac_sgmii_interrupt(int irq, void *data)\n{\n\tstruct emac_adapter *adpt = data;\n\tstruct emac_sgmii *phy = &adpt->phy;\n\tu8 status;\n\n\tstatus = readl(phy->base + EMAC_SGMII_PHY_INTERRUPT_STATUS);\n\tstatus &= SGMII_ISR_MASK;\n\tif (!status)\n\t\treturn IRQ_HANDLED;\n\n\t \n\tif (status & SGMII_PHY_INTERRUPT_ERR) {\n\t\tint count;\n\n\t\t \n\t\tcount = atomic_inc_return(&phy->decode_error_count);\n\t\tif (count == DECODE_ERROR_LIMIT) {\n\t\t\tschedule_work(&adpt->work_thread);\n\t\t\tatomic_set(&phy->decode_error_count, 0);\n\t\t}\n\t} else {\n\t\t \n\t\tatomic_set(&phy->decode_error_count, 0);\n\t}\n\n\tif (emac_sgmii_irq_clear(adpt, status))\n\t\tschedule_work(&adpt->work_thread);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void emac_sgmii_reset_prepare(struct emac_adapter *adpt)\n{\n\tstruct emac_sgmii *phy = &adpt->phy;\n\tu32 val;\n\n\t \n\tval = readl(phy->base + EMAC_EMAC_WRAPPER_CSR2);\n\twritel(((val & ~PHY_RESET) | PHY_RESET), phy->base +\n\t       EMAC_EMAC_WRAPPER_CSR2);\n\t \n\tmsleep(50);\n\tval = readl(phy->base + EMAC_EMAC_WRAPPER_CSR2);\n\twritel((val & ~PHY_RESET), phy->base + EMAC_EMAC_WRAPPER_CSR2);\n\t \n\tmsleep(50);\n}\n\nstatic void emac_sgmii_common_reset(struct emac_adapter *adpt)\n{\n\tint ret;\n\n\temac_sgmii_reset_prepare(adpt);\n\temac_sgmii_link_init(adpt);\n\n\tret = emac_sgmii_init(adpt);\n\tif (ret)\n\t\tnetdev_err(adpt->netdev,\n\t\t\t   \"could not reinitialize internal PHY (error=%i)\\n\",\n\t\t\t   ret);\n}\n\nstatic int emac_sgmii_common_open(struct emac_adapter *adpt)\n{\n\tstruct emac_sgmii *sgmii = &adpt->phy;\n\tint ret;\n\n\tif (sgmii->irq) {\n\t\t \n\t\tret = emac_sgmii_irq_clear(adpt, 0xff);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\twritel(0, sgmii->base + EMAC_SGMII_PHY_INTERRUPT_MASK);\n\n\t\tret = request_irq(sgmii->irq, emac_sgmii_interrupt, 0,\n\t\t\t\t  \"emac-sgmii\", adpt);\n\t\tif (ret) {\n\t\t\tnetdev_err(adpt->netdev,\n\t\t\t\t   \"could not register handler for internal PHY\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void emac_sgmii_common_close(struct emac_adapter *adpt)\n{\n\tstruct emac_sgmii *sgmii = &adpt->phy;\n\n\t \n\twritel(0, sgmii->base + EMAC_SGMII_PHY_INTERRUPT_MASK);\n\tfree_irq(sgmii->irq, adpt);\n}\n\n \nstatic int emac_sgmii_common_link_change(struct emac_adapter *adpt, bool linkup)\n{\n\tstruct emac_sgmii *sgmii = &adpt->phy;\n\tint ret;\n\n\tif (linkup) {\n\t\t \n\t\tret = emac_sgmii_irq_clear(adpt, 0xff);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\twritel(SGMII_ISR_MASK,\n\t\t       sgmii->base + EMAC_SGMII_PHY_INTERRUPT_MASK);\n\t} else {\n\t\t \n\t\twritel(0, sgmii->base + EMAC_SGMII_PHY_INTERRUPT_MASK);\n\t\tsynchronize_irq(sgmii->irq);\n\t}\n\n\treturn 0;\n}\n\nstatic struct sgmii_ops fsm9900_ops = {\n\t.init = emac_sgmii_init_fsm9900,\n\t.open = emac_sgmii_common_open,\n\t.close = emac_sgmii_common_close,\n\t.link_change = emac_sgmii_common_link_change,\n\t.reset = emac_sgmii_common_reset,\n};\n\nstatic struct sgmii_ops qdf2432_ops = {\n\t.init = emac_sgmii_init_qdf2432,\n\t.open = emac_sgmii_common_open,\n\t.close = emac_sgmii_common_close,\n\t.link_change = emac_sgmii_common_link_change,\n\t.reset = emac_sgmii_common_reset,\n};\n\n#ifdef CONFIG_ACPI\nstatic struct sgmii_ops qdf2400_ops = {\n\t.init = emac_sgmii_init_qdf2400,\n\t.open = emac_sgmii_common_open,\n\t.close = emac_sgmii_common_close,\n\t.link_change = emac_sgmii_common_link_change,\n\t.reset = emac_sgmii_common_reset,\n};\n#endif\n\nstatic int emac_sgmii_acpi_match(struct device *dev, void *data)\n{\n#ifdef CONFIG_ACPI\n\tstatic const struct acpi_device_id match_table[] = {\n\t\t{\n\t\t\t.id = \"QCOM8071\",\n\t\t},\n\t\t{}\n\t};\n\tconst struct acpi_device_id *id = acpi_match_device(match_table, dev);\n\tstruct sgmii_ops **ops = data;\n\n\tif (id) {\n\t\tacpi_handle handle = ACPI_HANDLE(dev);\n\t\tunsigned long long hrv;\n\t\tacpi_status status;\n\n\t\tstatus = acpi_evaluate_integer(handle, \"_HRV\", NULL, &hrv);\n\t\tif (status) {\n\t\t\tif (status == AE_NOT_FOUND)\n\t\t\t\t \n\t\t\t\thrv = 1;\n\t\t\telse\n\t\t\t\t \n\t\t\t\treturn 0;\n\t\t}\n\n\t\tswitch (hrv) {\n\t\tcase 1:\n\t\t\t*ops = &qdf2432_ops;\n\t\t\treturn 1;\n\t\tcase 2:\n\t\t\t*ops = &qdf2400_ops;\n\t\t\treturn 1;\n\t\t}\n\t}\n#endif\n\n\treturn 0;\n}\n\nstatic const struct of_device_id emac_sgmii_dt_match[] = {\n\t{\n\t\t.compatible = \"qcom,fsm9900-emac-sgmii\",\n\t\t.data = &fsm9900_ops,\n\t},\n\t{\n\t\t.compatible = \"qcom,qdf2432-emac-sgmii\",\n\t\t.data = &qdf2432_ops,\n\t},\n\t{}\n};\n\nint emac_sgmii_config(struct platform_device *pdev, struct emac_adapter *adpt)\n{\n\tstruct platform_device *sgmii_pdev = NULL;\n\tstruct emac_sgmii *phy = &adpt->phy;\n\tstruct resource *res;\n\tint ret;\n\n\tif (has_acpi_companion(&pdev->dev)) {\n\t\tstruct device *dev;\n\n\t\tdev = device_find_child(&pdev->dev, &phy->sgmii_ops,\n\t\t\t\t\temac_sgmii_acpi_match);\n\n\t\tif (!dev) {\n\t\t\tdev_warn(&pdev->dev, \"cannot find internal phy node\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tsgmii_pdev = to_platform_device(dev);\n\t} else {\n\t\tconst struct of_device_id *match;\n\t\tstruct device_node *np;\n\n\t\tnp = of_parse_phandle(pdev->dev.of_node, \"internal-phy\", 0);\n\t\tif (!np) {\n\t\t\tdev_err(&pdev->dev, \"missing internal-phy property\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tsgmii_pdev = of_find_device_by_node(np);\n\t\tof_node_put(np);\n\t\tif (!sgmii_pdev) {\n\t\t\tdev_err(&pdev->dev, \"invalid internal-phy property\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tmatch = of_match_device(emac_sgmii_dt_match, &sgmii_pdev->dev);\n\t\tif (!match) {\n\t\t\tdev_err(&pdev->dev, \"unrecognized internal phy node\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto error_put_device;\n\t\t}\n\n\t\tphy->sgmii_ops = (struct sgmii_ops *)match->data;\n\t}\n\n\t \n\tres = platform_get_resource(sgmii_pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tret = -EINVAL;\n\t\tgoto error_put_device;\n\t}\n\n\tphy->base = ioremap(res->start, resource_size(res));\n\tif (!phy->base) {\n\t\tret = -ENOMEM;\n\t\tgoto error_put_device;\n\t}\n\n\t \n\tres = platform_get_resource(sgmii_pdev, IORESOURCE_MEM, 1);\n\tif (res) {\n\t\tphy->digital = ioremap(res->start, resource_size(res));\n\t\tif (!phy->digital) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_unmap_base;\n\t\t}\n\t}\n\n\tret = emac_sgmii_init(adpt);\n\tif (ret)\n\t\tgoto error;\n\n\temac_sgmii_link_init(adpt);\n\n\tret = platform_get_irq(sgmii_pdev, 0);\n\tif (ret > 0)\n\t\tphy->irq = ret;\n\n\t \n\tput_device(&sgmii_pdev->dev);\n\n\treturn 0;\n\nerror:\n\tif (phy->digital)\n\t\tiounmap(phy->digital);\nerror_unmap_base:\n\tiounmap(phy->base);\nerror_put_device:\n\tput_device(&sgmii_pdev->dev);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}