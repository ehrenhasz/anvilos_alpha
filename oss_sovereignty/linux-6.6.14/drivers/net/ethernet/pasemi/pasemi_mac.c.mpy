{
  "module_name": "pasemi_mac.c",
  "hash_id": "ad24b7d3e85ecc8e7ec84cc15f8d1e95e718c0e988b5780d8e3fc3dde747c005",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/pasemi/pasemi_mac.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/dmaengine.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/of_mdio.h>\n#include <linux/etherdevice.h>\n#include <asm/dma-mapping.h>\n#include <linux/in.h>\n#include <linux/skbuff.h>\n\n#include <linux/ip.h>\n#include <net/checksum.h>\n#include <linux/prefetch.h>\n\n#include <asm/irq.h>\n#include <asm/firmware.h>\n#include <asm/pasemi_dma.h>\n\n#include \"pasemi_mac.h\"\n\n \n#define LOCAL_SKB_ALIGN\t2\n\n \n\n#define PE_MIN_MTU\t(ETH_ZLEN + ETH_HLEN)\n#define PE_MAX_MTU\t9000\n#define PE_DEF_MTU\tETH_DATA_LEN\n\n#define DEFAULT_MSG_ENABLE\t  \\\n\t(NETIF_MSG_DRV\t\t| \\\n\t NETIF_MSG_PROBE\t| \\\n\t NETIF_MSG_LINK\t\t| \\\n\t NETIF_MSG_TIMER\t| \\\n\t NETIF_MSG_IFDOWN\t| \\\n\t NETIF_MSG_IFUP\t\t| \\\n\t NETIF_MSG_RX_ERR\t| \\\n\t NETIF_MSG_TX_ERR)\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR (\"Olof Johansson <olof@lixom.net>\");\nMODULE_DESCRIPTION(\"PA Semi PWRficient Ethernet driver\");\n\nstatic int debug = -1;\t \nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"PA Semi MAC bitmapped debugging message enable value\");\n\nextern const struct ethtool_ops pasemi_mac_ethtool_ops;\n\nstatic int translation_enabled(void)\n{\n#if defined(CONFIG_PPC_PASEMI_IOMMU_DMA_FORCE)\n\treturn 1;\n#else\n\treturn firmware_has_feature(FW_FEATURE_LPAR);\n#endif\n}\n\nstatic void write_iob_reg(unsigned int reg, unsigned int val)\n{\n\tpasemi_write_iob_reg(reg, val);\n}\n\nstatic unsigned int read_mac_reg(const struct pasemi_mac *mac, unsigned int reg)\n{\n\treturn pasemi_read_mac_reg(mac->dma_if, reg);\n}\n\nstatic void write_mac_reg(const struct pasemi_mac *mac, unsigned int reg,\n\t\t\t  unsigned int val)\n{\n\tpasemi_write_mac_reg(mac->dma_if, reg, val);\n}\n\nstatic unsigned int read_dma_reg(unsigned int reg)\n{\n\treturn pasemi_read_dma_reg(reg);\n}\n\nstatic void write_dma_reg(unsigned int reg, unsigned int val)\n{\n\tpasemi_write_dma_reg(reg, val);\n}\n\nstatic struct pasemi_mac_rxring *rx_ring(const struct pasemi_mac *mac)\n{\n\treturn mac->rx;\n}\n\nstatic struct pasemi_mac_txring *tx_ring(const struct pasemi_mac *mac)\n{\n\treturn mac->tx;\n}\n\nstatic inline void prefetch_skb(const struct sk_buff *skb)\n{\n\tconst void *d = skb;\n\n\tprefetch(d);\n\tprefetch(d+64);\n\tprefetch(d+128);\n\tprefetch(d+192);\n}\n\nstatic int mac_to_intf(struct pasemi_mac *mac)\n{\n\tstruct pci_dev *pdev = mac->pdev;\n\tu32 tmp;\n\tint nintf, off, i, j;\n\tint devfn = pdev->devfn;\n\n\ttmp = read_dma_reg(PAS_DMA_CAP_IFI);\n\tnintf = (tmp & PAS_DMA_CAP_IFI_NIN_M) >> PAS_DMA_CAP_IFI_NIN_S;\n\toff = (tmp & PAS_DMA_CAP_IFI_IOFF_M) >> PAS_DMA_CAP_IFI_IOFF_S;\n\n\t \n\n\tfor (i = 0; i < (nintf+3)/4; i++) {\n\t\ttmp = read_dma_reg(off+4*i);\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tif (((tmp >> (8*j)) & 0xff) == devfn)\n\t\t\t\treturn i*4 + j;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic void pasemi_mac_intf_disable(struct pasemi_mac *mac)\n{\n\tunsigned int flags;\n\n\tflags = read_mac_reg(mac, PAS_MAC_CFG_PCFG);\n\tflags &= ~PAS_MAC_CFG_PCFG_PE;\n\twrite_mac_reg(mac, PAS_MAC_CFG_PCFG, flags);\n}\n\nstatic void pasemi_mac_intf_enable(struct pasemi_mac *mac)\n{\n\tunsigned int flags;\n\n\tflags = read_mac_reg(mac, PAS_MAC_CFG_PCFG);\n\tflags |= PAS_MAC_CFG_PCFG_PE;\n\twrite_mac_reg(mac, PAS_MAC_CFG_PCFG, flags);\n}\n\nstatic int pasemi_get_mac_addr(struct pasemi_mac *mac)\n{\n\tstruct pci_dev *pdev = mac->pdev;\n\tstruct device_node *dn = pci_device_to_OF_node(pdev);\n\tint len;\n\tconst u8 *maddr;\n\tu8 addr[ETH_ALEN];\n\n\tif (!dn) {\n\t\tdev_dbg(&pdev->dev,\n\t\t\t  \"No device node for mac, not configuring\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tmaddr = of_get_property(dn, \"local-mac-address\", &len);\n\n\tif (maddr && len == ETH_ALEN) {\n\t\tmemcpy(mac->mac_addr, maddr, ETH_ALEN);\n\t\treturn 0;\n\t}\n\n\t \n\n\tif (maddr == NULL)\n\t\tmaddr = of_get_property(dn, \"mac-address\", NULL);\n\n\tif (maddr == NULL) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"no mac address in device tree, not configuring\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (!mac_pton(maddr, addr)) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"can't parse mac address, not configuring\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(mac->mac_addr, addr, ETH_ALEN);\n\n\treturn 0;\n}\n\nstatic int pasemi_mac_set_mac_addr(struct net_device *dev, void *p)\n{\n\tstruct pasemi_mac *mac = netdev_priv(dev);\n\tstruct sockaddr *addr = p;\n\tunsigned int adr0, adr1;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(dev, addr->sa_data);\n\n\tadr0 = dev->dev_addr[2] << 24 |\n\t       dev->dev_addr[3] << 16 |\n\t       dev->dev_addr[4] << 8 |\n\t       dev->dev_addr[5];\n\tadr1 = read_mac_reg(mac, PAS_MAC_CFG_ADR1);\n\tadr1 &= ~0xffff;\n\tadr1 |= dev->dev_addr[0] << 8 | dev->dev_addr[1];\n\n\tpasemi_mac_intf_disable(mac);\n\twrite_mac_reg(mac, PAS_MAC_CFG_ADR0, adr0);\n\twrite_mac_reg(mac, PAS_MAC_CFG_ADR1, adr1);\n\tpasemi_mac_intf_enable(mac);\n\n\treturn 0;\n}\n\nstatic int pasemi_mac_unmap_tx_skb(struct pasemi_mac *mac,\n\t\t\t\t    const int nfrags,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    const dma_addr_t *dmas)\n{\n\tint f;\n\tstruct pci_dev *pdev = mac->dma_pdev;\n\n\tdma_unmap_single(&pdev->dev, dmas[0], skb_headlen(skb), DMA_TO_DEVICE);\n\n\tfor (f = 0; f < nfrags; f++) {\n\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[f];\n\n\t\tdma_unmap_page(&pdev->dev, dmas[f + 1], skb_frag_size(frag),\n\t\t\t       DMA_TO_DEVICE);\n\t}\n\tdev_kfree_skb_irq(skb);\n\n\t \n\treturn (nfrags + 3) & ~1;\n}\n\nstatic struct pasemi_mac_csring *pasemi_mac_setup_csring(struct pasemi_mac *mac)\n{\n\tstruct pasemi_mac_csring *ring;\n\tu32 val;\n\tunsigned int cfg;\n\tint chno;\n\n\tring = pasemi_dma_alloc_chan(TXCHAN, sizeof(struct pasemi_mac_csring),\n\t\t\t\t       offsetof(struct pasemi_mac_csring, chan));\n\n\tif (!ring) {\n\t\tdev_err(&mac->pdev->dev, \"Can't allocate checksum channel\\n\");\n\t\tgoto out_chan;\n\t}\n\n\tchno = ring->chan.chno;\n\n\tring->size = CS_RING_SIZE;\n\tring->next_to_fill = 0;\n\n\t \n\tif (pasemi_dma_alloc_ring(&ring->chan, CS_RING_SIZE))\n\t\tgoto out_ring_desc;\n\n\twrite_dma_reg(PAS_DMA_TXCHAN_BASEL(chno),\n\t\t      PAS_DMA_TXCHAN_BASEL_BRBL(ring->chan.ring_dma));\n\tval = PAS_DMA_TXCHAN_BASEU_BRBH(ring->chan.ring_dma >> 32);\n\tval |= PAS_DMA_TXCHAN_BASEU_SIZ(CS_RING_SIZE >> 3);\n\n\twrite_dma_reg(PAS_DMA_TXCHAN_BASEU(chno), val);\n\n\tring->events[0] = pasemi_dma_alloc_flag();\n\tring->events[1] = pasemi_dma_alloc_flag();\n\tif (ring->events[0] < 0 || ring->events[1] < 0)\n\t\tgoto out_flags;\n\n\tpasemi_dma_clear_flag(ring->events[0]);\n\tpasemi_dma_clear_flag(ring->events[1]);\n\n\tring->fun = pasemi_dma_alloc_fun();\n\tif (ring->fun < 0)\n\t\tgoto out_fun;\n\n\tcfg = PAS_DMA_TXCHAN_CFG_TY_FUNC | PAS_DMA_TXCHAN_CFG_UP |\n\t      PAS_DMA_TXCHAN_CFG_TATTR(ring->fun) |\n\t      PAS_DMA_TXCHAN_CFG_LPSQ | PAS_DMA_TXCHAN_CFG_LPDQ;\n\n\tif (translation_enabled())\n\t\tcfg |= PAS_DMA_TXCHAN_CFG_TRD | PAS_DMA_TXCHAN_CFG_TRR;\n\n\twrite_dma_reg(PAS_DMA_TXCHAN_CFG(chno), cfg);\n\n\t \n\tpasemi_dma_start_chan(&ring->chan, PAS_DMA_TXCHAN_TCMDSTA_SZ |\n\t\t\t\t\t   PAS_DMA_TXCHAN_TCMDSTA_DB |\n\t\t\t\t\t   PAS_DMA_TXCHAN_TCMDSTA_DE |\n\t\t\t\t\t   PAS_DMA_TXCHAN_TCMDSTA_DA);\n\n\treturn ring;\n\nout_fun:\nout_flags:\n\tif (ring->events[0] >= 0)\n\t\tpasemi_dma_free_flag(ring->events[0]);\n\tif (ring->events[1] >= 0)\n\t\tpasemi_dma_free_flag(ring->events[1]);\n\tpasemi_dma_free_ring(&ring->chan);\nout_ring_desc:\n\tpasemi_dma_free_chan(&ring->chan);\nout_chan:\n\n\treturn NULL;\n}\n\nstatic void pasemi_mac_setup_csrings(struct pasemi_mac *mac)\n{\n\tint i;\n\tmac->cs[0] = pasemi_mac_setup_csring(mac);\n\tif (mac->type == MAC_TYPE_XAUI)\n\t\tmac->cs[1] = pasemi_mac_setup_csring(mac);\n\telse\n\t\tmac->cs[1] = 0;\n\n\tfor (i = 0; i < MAX_CS; i++)\n\t\tif (mac->cs[i])\n\t\t\tmac->num_cs++;\n}\n\nstatic void pasemi_mac_free_csring(struct pasemi_mac_csring *csring)\n{\n\tpasemi_dma_stop_chan(&csring->chan);\n\tpasemi_dma_free_flag(csring->events[0]);\n\tpasemi_dma_free_flag(csring->events[1]);\n\tpasemi_dma_free_ring(&csring->chan);\n\tpasemi_dma_free_chan(&csring->chan);\n\tpasemi_dma_free_fun(csring->fun);\n}\n\nstatic int pasemi_mac_setup_rx_resources(const struct net_device *dev)\n{\n\tstruct pasemi_mac_rxring *ring;\n\tstruct pasemi_mac *mac = netdev_priv(dev);\n\tint chno;\n\tunsigned int cfg;\n\n\tring = pasemi_dma_alloc_chan(RXCHAN, sizeof(struct pasemi_mac_rxring),\n\t\t\t\t     offsetof(struct pasemi_mac_rxring, chan));\n\n\tif (!ring) {\n\t\tdev_err(&mac->pdev->dev, \"Can't allocate RX channel\\n\");\n\t\tgoto out_chan;\n\t}\n\tchno = ring->chan.chno;\n\n\tspin_lock_init(&ring->lock);\n\n\tring->size = RX_RING_SIZE;\n\tring->ring_info = kcalloc(RX_RING_SIZE,\n\t\t\t\t  sizeof(struct pasemi_mac_buffer),\n\t\t\t\t  GFP_KERNEL);\n\n\tif (!ring->ring_info)\n\t\tgoto out_ring_info;\n\n\t \n\tif (pasemi_dma_alloc_ring(&ring->chan, RX_RING_SIZE))\n\t\tgoto out_ring_desc;\n\n\tring->buffers = dma_alloc_coherent(&mac->dma_pdev->dev,\n\t\t\t\t\t   RX_RING_SIZE * sizeof(u64),\n\t\t\t\t\t   &ring->buf_dma, GFP_KERNEL);\n\tif (!ring->buffers)\n\t\tgoto out_ring_desc;\n\n\twrite_dma_reg(PAS_DMA_RXCHAN_BASEL(chno),\n\t\t      PAS_DMA_RXCHAN_BASEL_BRBL(ring->chan.ring_dma));\n\n\twrite_dma_reg(PAS_DMA_RXCHAN_BASEU(chno),\n\t\t      PAS_DMA_RXCHAN_BASEU_BRBH(ring->chan.ring_dma >> 32) |\n\t\t      PAS_DMA_RXCHAN_BASEU_SIZ(RX_RING_SIZE >> 3));\n\n\tcfg = PAS_DMA_RXCHAN_CFG_HBU(2);\n\n\tif (translation_enabled())\n\t\tcfg |= PAS_DMA_RXCHAN_CFG_CTR;\n\n\twrite_dma_reg(PAS_DMA_RXCHAN_CFG(chno), cfg);\n\n\twrite_dma_reg(PAS_DMA_RXINT_BASEL(mac->dma_if),\n\t\t      PAS_DMA_RXINT_BASEL_BRBL(ring->buf_dma));\n\n\twrite_dma_reg(PAS_DMA_RXINT_BASEU(mac->dma_if),\n\t\t      PAS_DMA_RXINT_BASEU_BRBH(ring->buf_dma >> 32) |\n\t\t      PAS_DMA_RXINT_BASEU_SIZ(RX_RING_SIZE >> 3));\n\n\tcfg = PAS_DMA_RXINT_CFG_DHL(2) | PAS_DMA_RXINT_CFG_L2 |\n\t      PAS_DMA_RXINT_CFG_LW | PAS_DMA_RXINT_CFG_RBP |\n\t      PAS_DMA_RXINT_CFG_HEN;\n\n\tif (translation_enabled())\n\t\tcfg |= PAS_DMA_RXINT_CFG_ITRR | PAS_DMA_RXINT_CFG_ITR;\n\n\twrite_dma_reg(PAS_DMA_RXINT_CFG(mac->dma_if), cfg);\n\n\tring->next_to_fill = 0;\n\tring->next_to_clean = 0;\n\tring->mac = mac;\n\tmac->rx = ring;\n\n\treturn 0;\n\nout_ring_desc:\n\tkfree(ring->ring_info);\nout_ring_info:\n\tpasemi_dma_free_chan(&ring->chan);\nout_chan:\n\treturn -ENOMEM;\n}\n\nstatic struct pasemi_mac_txring *\npasemi_mac_setup_tx_resources(const struct net_device *dev)\n{\n\tstruct pasemi_mac *mac = netdev_priv(dev);\n\tu32 val;\n\tstruct pasemi_mac_txring *ring;\n\tunsigned int cfg;\n\tint chno;\n\n\tring = pasemi_dma_alloc_chan(TXCHAN, sizeof(struct pasemi_mac_txring),\n\t\t\t\t     offsetof(struct pasemi_mac_txring, chan));\n\n\tif (!ring) {\n\t\tdev_err(&mac->pdev->dev, \"Can't allocate TX channel\\n\");\n\t\tgoto out_chan;\n\t}\n\n\tchno = ring->chan.chno;\n\n\tspin_lock_init(&ring->lock);\n\n\tring->size = TX_RING_SIZE;\n\tring->ring_info = kcalloc(TX_RING_SIZE,\n\t\t\t\t  sizeof(struct pasemi_mac_buffer),\n\t\t\t\t  GFP_KERNEL);\n\tif (!ring->ring_info)\n\t\tgoto out_ring_info;\n\n\t \n\tif (pasemi_dma_alloc_ring(&ring->chan, TX_RING_SIZE))\n\t\tgoto out_ring_desc;\n\n\twrite_dma_reg(PAS_DMA_TXCHAN_BASEL(chno),\n\t\t      PAS_DMA_TXCHAN_BASEL_BRBL(ring->chan.ring_dma));\n\tval = PAS_DMA_TXCHAN_BASEU_BRBH(ring->chan.ring_dma >> 32);\n\tval |= PAS_DMA_TXCHAN_BASEU_SIZ(TX_RING_SIZE >> 3);\n\n\twrite_dma_reg(PAS_DMA_TXCHAN_BASEU(chno), val);\n\n\tcfg = PAS_DMA_TXCHAN_CFG_TY_IFACE |\n\t      PAS_DMA_TXCHAN_CFG_TATTR(mac->dma_if) |\n\t      PAS_DMA_TXCHAN_CFG_UP |\n\t      PAS_DMA_TXCHAN_CFG_WT(4);\n\n\tif (translation_enabled())\n\t\tcfg |= PAS_DMA_TXCHAN_CFG_TRD | PAS_DMA_TXCHAN_CFG_TRR;\n\n\twrite_dma_reg(PAS_DMA_TXCHAN_CFG(chno), cfg);\n\n\tring->next_to_fill = 0;\n\tring->next_to_clean = 0;\n\tring->mac = mac;\n\n\treturn ring;\n\nout_ring_desc:\n\tkfree(ring->ring_info);\nout_ring_info:\n\tpasemi_dma_free_chan(&ring->chan);\nout_chan:\n\treturn NULL;\n}\n\nstatic void pasemi_mac_free_tx_resources(struct pasemi_mac *mac)\n{\n\tstruct pasemi_mac_txring *txring = tx_ring(mac);\n\tunsigned int i, j;\n\tstruct pasemi_mac_buffer *info;\n\tdma_addr_t dmas[MAX_SKB_FRAGS+1];\n\tint freed, nfrags;\n\tint start, limit;\n\n\tstart = txring->next_to_clean;\n\tlimit = txring->next_to_fill;\n\n\t \n\tif (start > limit)\n\t\tlimit += TX_RING_SIZE;\n\n\tfor (i = start; i < limit; i += freed) {\n\t\tinfo = &txring->ring_info[(i+1) & (TX_RING_SIZE-1)];\n\t\tif (info->dma && info->skb) {\n\t\t\tnfrags = skb_shinfo(info->skb)->nr_frags;\n\t\t\tfor (j = 0; j <= nfrags; j++)\n\t\t\t\tdmas[j] = txring->ring_info[(i+1+j) &\n\t\t\t\t\t\t(TX_RING_SIZE-1)].dma;\n\t\t\tfreed = pasemi_mac_unmap_tx_skb(mac, nfrags,\n\t\t\t\t\t\t\tinfo->skb, dmas);\n\t\t} else {\n\t\t\tfreed = 2;\n\t\t}\n\t}\n\n\tkfree(txring->ring_info);\n\tpasemi_dma_free_chan(&txring->chan);\n\n}\n\nstatic void pasemi_mac_free_rx_buffers(struct pasemi_mac *mac)\n{\n\tstruct pasemi_mac_rxring *rx = rx_ring(mac);\n\tunsigned int i;\n\tstruct pasemi_mac_buffer *info;\n\n\tfor (i = 0; i < RX_RING_SIZE; i++) {\n\t\tinfo = &RX_DESC_INFO(rx, i);\n\t\tif (info->skb && info->dma) {\n\t\t\tdma_unmap_single(&mac->dma_pdev->dev, info->dma,\n\t\t\t\t\t info->skb->len, DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb_any(info->skb);\n\t\t}\n\t\tinfo->dma = 0;\n\t\tinfo->skb = NULL;\n\t}\n\n\tfor (i = 0; i < RX_RING_SIZE; i++)\n\t\tRX_BUFF(rx, i) = 0;\n}\n\nstatic void pasemi_mac_free_rx_resources(struct pasemi_mac *mac)\n{\n\tpasemi_mac_free_rx_buffers(mac);\n\n\tdma_free_coherent(&mac->dma_pdev->dev, RX_RING_SIZE * sizeof(u64),\n\t\t\t  rx_ring(mac)->buffers, rx_ring(mac)->buf_dma);\n\n\tkfree(rx_ring(mac)->ring_info);\n\tpasemi_dma_free_chan(&rx_ring(mac)->chan);\n\tmac->rx = NULL;\n}\n\nstatic void pasemi_mac_replenish_rx_ring(struct net_device *dev,\n\t\t\t\t\t const int limit)\n{\n\tconst struct pasemi_mac *mac = netdev_priv(dev);\n\tstruct pasemi_mac_rxring *rx = rx_ring(mac);\n\tint fill, count;\n\n\tif (limit <= 0)\n\t\treturn;\n\n\tfill = rx_ring(mac)->next_to_fill;\n\tfor (count = 0; count < limit; count++) {\n\t\tstruct pasemi_mac_buffer *info = &RX_DESC_INFO(rx, fill);\n\t\tu64 *buff = &RX_BUFF(rx, fill);\n\t\tstruct sk_buff *skb;\n\t\tdma_addr_t dma;\n\n\t\t \n\t\tWARN_ON(*buff);\n\n\t\tskb = netdev_alloc_skb(dev, mac->bufsz);\n\t\tskb_reserve(skb, LOCAL_SKB_ALIGN);\n\n\t\tif (unlikely(!skb))\n\t\t\tbreak;\n\n\t\tdma = dma_map_single(&mac->dma_pdev->dev, skb->data,\n\t\t\t\t     mac->bufsz - LOCAL_SKB_ALIGN,\n\t\t\t\t     DMA_FROM_DEVICE);\n\n\t\tif (dma_mapping_error(&mac->dma_pdev->dev, dma)) {\n\t\t\tdev_kfree_skb_irq(info->skb);\n\t\t\tbreak;\n\t\t}\n\n\t\tinfo->skb = skb;\n\t\tinfo->dma = dma;\n\t\t*buff = XCT_RXB_LEN(mac->bufsz) | XCT_RXB_ADDR(dma);\n\t\tfill++;\n\t}\n\n\twmb();\n\n\twrite_dma_reg(PAS_DMA_RXINT_INCR(mac->dma_if), count);\n\n\trx_ring(mac)->next_to_fill = (rx_ring(mac)->next_to_fill + count) &\n\t\t\t\t(RX_RING_SIZE - 1);\n}\n\nstatic void pasemi_mac_restart_rx_intr(const struct pasemi_mac *mac)\n{\n\tstruct pasemi_mac_rxring *rx = rx_ring(mac);\n\tunsigned int reg, pcnt;\n\t \n\n\tpcnt = *rx->chan.status & PAS_STATUS_PCNT_M;\n\n\treg = PAS_IOB_DMA_RXCH_RESET_PCNT(pcnt) | PAS_IOB_DMA_RXCH_RESET_PINTC;\n\n\tif (*rx->chan.status & PAS_STATUS_TIMER)\n\t\treg |= PAS_IOB_DMA_RXCH_RESET_TINTC;\n\n\twrite_iob_reg(PAS_IOB_DMA_RXCH_RESET(mac->rx->chan.chno), reg);\n}\n\nstatic void pasemi_mac_restart_tx_intr(const struct pasemi_mac *mac)\n{\n\tunsigned int reg, pcnt;\n\n\t \n\tpcnt = *tx_ring(mac)->chan.status & PAS_STATUS_PCNT_M;\n\n\treg = PAS_IOB_DMA_TXCH_RESET_PCNT(pcnt) | PAS_IOB_DMA_TXCH_RESET_PINTC;\n\n\twrite_iob_reg(PAS_IOB_DMA_TXCH_RESET(tx_ring(mac)->chan.chno), reg);\n}\n\n\nstatic inline void pasemi_mac_rx_error(const struct pasemi_mac *mac,\n\t\t\t\t       const u64 macrx)\n{\n\tunsigned int rcmdsta, ccmdsta;\n\tstruct pasemi_dmachan *chan = &rx_ring(mac)->chan;\n\n\tif (!netif_msg_rx_err(mac))\n\t\treturn;\n\n\trcmdsta = read_dma_reg(PAS_DMA_RXINT_RCMDSTA(mac->dma_if));\n\tccmdsta = read_dma_reg(PAS_DMA_RXCHAN_CCMDSTA(chan->chno));\n\n\tprintk(KERN_ERR \"pasemi_mac: rx error. macrx %016llx, rx status %llx\\n\",\n\t\tmacrx, *chan->status);\n\n\tprintk(KERN_ERR \"pasemi_mac: rcmdsta %08x ccmdsta %08x\\n\",\n\t\trcmdsta, ccmdsta);\n}\n\nstatic inline void pasemi_mac_tx_error(const struct pasemi_mac *mac,\n\t\t\t\t       const u64 mactx)\n{\n\tunsigned int cmdsta;\n\tstruct pasemi_dmachan *chan = &tx_ring(mac)->chan;\n\n\tif (!netif_msg_tx_err(mac))\n\t\treturn;\n\n\tcmdsta = read_dma_reg(PAS_DMA_TXCHAN_TCMDSTA(chan->chno));\n\n\tprintk(KERN_ERR \"pasemi_mac: tx error. mactx 0x%016llx, \"\\\n\t\t\"tx status 0x%016llx\\n\", mactx, *chan->status);\n\n\tprintk(KERN_ERR \"pasemi_mac: tcmdsta 0x%08x\\n\", cmdsta);\n}\n\nstatic int pasemi_mac_clean_rx(struct pasemi_mac_rxring *rx,\n\t\t\t       const int limit)\n{\n\tconst struct pasemi_dmachan *chan = &rx->chan;\n\tstruct pasemi_mac *mac = rx->mac;\n\tstruct pci_dev *pdev = mac->dma_pdev;\n\tunsigned int n;\n\tint count, buf_index, tot_bytes, packets;\n\tstruct pasemi_mac_buffer *info;\n\tstruct sk_buff *skb;\n\tunsigned int len;\n\tu64 macrx, eval;\n\tdma_addr_t dma;\n\n\ttot_bytes = 0;\n\tpackets = 0;\n\n\tspin_lock(&rx->lock);\n\n\tn = rx->next_to_clean;\n\n\tprefetch(&RX_DESC(rx, n));\n\n\tfor (count = 0; count < limit; count++) {\n\t\tmacrx = RX_DESC(rx, n);\n\t\tprefetch(&RX_DESC(rx, n+4));\n\n\t\tif ((macrx & XCT_MACRX_E) ||\n\t\t    (*chan->status & PAS_STATUS_ERROR))\n\t\t\tpasemi_mac_rx_error(mac, macrx);\n\n\t\tif (!(macrx & XCT_MACRX_O))\n\t\t\tbreak;\n\n\t\tinfo = NULL;\n\n\t\tBUG_ON(!(macrx & XCT_MACRX_RR_8BRES));\n\n\t\teval = (RX_DESC(rx, n+1) & XCT_RXRES_8B_EVAL_M) >>\n\t\t\tXCT_RXRES_8B_EVAL_S;\n\t\tbuf_index = eval-1;\n\n\t\tdma = (RX_DESC(rx, n+2) & XCT_PTR_ADDR_M);\n\t\tinfo = &RX_DESC_INFO(rx, buf_index);\n\n\t\tskb = info->skb;\n\n\t\tprefetch_skb(skb);\n\n\t\tlen = (macrx & XCT_MACRX_LLEN_M) >> XCT_MACRX_LLEN_S;\n\n\t\tdma_unmap_single(&pdev->dev, dma,\n\t\t\t\t mac->bufsz - LOCAL_SKB_ALIGN,\n\t\t\t\t DMA_FROM_DEVICE);\n\n\t\tif (macrx & XCT_MACRX_CRC) {\n\t\t\t \n\t\t\tmac->netdev->stats.rx_errors++;\n\t\t\tmac->netdev->stats.rx_crc_errors++;\n\t\t\t \n\t\t\tgoto next;\n\t\t}\n\n\t\tinfo->skb = NULL;\n\t\tinfo->dma = 0;\n\n\t\tif (likely((macrx & XCT_MACRX_HTY_M) == XCT_MACRX_HTY_IPV4_OK)) {\n\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\tskb->csum = (macrx & XCT_MACRX_CSUM_M) >>\n\t\t\t\t\t   XCT_MACRX_CSUM_S;\n\t\t} else {\n\t\t\tskb_checksum_none_assert(skb);\n\t\t}\n\n\t\tpackets++;\n\t\ttot_bytes += len;\n\n\t\t \n\t\tskb_put(skb, len-4);\n\n\t\tskb->protocol = eth_type_trans(skb, mac->netdev);\n\t\tnapi_gro_receive(&mac->napi, skb);\n\nnext:\n\t\tRX_DESC(rx, n) = 0;\n\t\tRX_DESC(rx, n+1) = 0;\n\n\t\t \n\t\tRX_BUFF(rx, buf_index) = 0;\n\n\t\tn += 4;\n\t}\n\n\tif (n > RX_RING_SIZE) {\n\t\t \n\t\twrite_iob_reg(PAS_IOB_COM_PKTHDRCNT, 0);\n\t\tn &= (RX_RING_SIZE-1);\n\t}\n\n\trx_ring(mac)->next_to_clean = n;\n\n\t \n\twrite_dma_reg(PAS_DMA_RXCHAN_INCR(mac->rx->chan.chno), count << 1);\n\n\tpasemi_mac_replenish_rx_ring(mac->netdev, count);\n\n\tmac->netdev->stats.rx_bytes += tot_bytes;\n\tmac->netdev->stats.rx_packets += packets;\n\n\tspin_unlock(&rx_ring(mac)->lock);\n\n\treturn count;\n}\n\n \n#define TX_CLEAN_BATCHSIZE (128/MAX_SKB_FRAGS)\n\nstatic int pasemi_mac_clean_tx(struct pasemi_mac_txring *txring)\n{\n\tstruct pasemi_dmachan *chan = &txring->chan;\n\tstruct pasemi_mac *mac = txring->mac;\n\tint i, j;\n\tunsigned int start, descr_count, buf_count, batch_limit;\n\tunsigned int ring_limit;\n\tunsigned int total_count;\n\tunsigned long flags;\n\tstruct sk_buff *skbs[TX_CLEAN_BATCHSIZE];\n\tdma_addr_t dmas[TX_CLEAN_BATCHSIZE][MAX_SKB_FRAGS+1];\n\tint nf[TX_CLEAN_BATCHSIZE];\n\tint nr_frags;\n\n\ttotal_count = 0;\n\tbatch_limit = TX_CLEAN_BATCHSIZE;\nrestart:\n\tspin_lock_irqsave(&txring->lock, flags);\n\n\tstart = txring->next_to_clean;\n\tring_limit = txring->next_to_fill;\n\n\tprefetch(&TX_DESC_INFO(txring, start+1).skb);\n\n\t \n\tif (start > ring_limit)\n\t\tring_limit += TX_RING_SIZE;\n\n\tbuf_count = 0;\n\tdescr_count = 0;\n\n\tfor (i = start;\n\t     descr_count < batch_limit && i < ring_limit;\n\t     i += buf_count) {\n\t\tu64 mactx = TX_DESC(txring, i);\n\t\tstruct sk_buff *skb;\n\n\t\tif ((mactx  & XCT_MACTX_E) ||\n\t\t    (*chan->status & PAS_STATUS_ERROR))\n\t\t\tpasemi_mac_tx_error(mac, mactx);\n\n\t\t \n\t\tif (!(mactx & XCT_MACTX_LLEN_M)) {\n\t\t\tTX_DESC(txring, i) = 0;\n\t\t\tTX_DESC(txring, i+1) = 0;\n\t\t\tbuf_count = 2;\n\t\t\tcontinue;\n\t\t}\n\n\t\tskb = TX_DESC_INFO(txring, i+1).skb;\n\t\tnr_frags = TX_DESC_INFO(txring, i).dma;\n\n\t\tif (unlikely(mactx & XCT_MACTX_O))\n\t\t\t \n\t\t\tbreak;\n\n\t\tbuf_count = 2 + nr_frags;\n\t\t \n\t\tif (buf_count & 1)\n\t\t\tbuf_count++;\n\n\t\tfor (j = 0; j <= nr_frags; j++)\n\t\t\tdmas[descr_count][j] = TX_DESC_INFO(txring, i+1+j).dma;\n\n\t\tskbs[descr_count] = skb;\n\t\tnf[descr_count] = nr_frags;\n\n\t\tTX_DESC(txring, i) = 0;\n\t\tTX_DESC(txring, i+1) = 0;\n\n\t\tdescr_count++;\n\t}\n\ttxring->next_to_clean = i & (TX_RING_SIZE-1);\n\n\tspin_unlock_irqrestore(&txring->lock, flags);\n\tnetif_wake_queue(mac->netdev);\n\n\tfor (i = 0; i < descr_count; i++)\n\t\tpasemi_mac_unmap_tx_skb(mac, nf[i], skbs[i], dmas[i]);\n\n\ttotal_count += descr_count;\n\n\t \n\tif (descr_count == batch_limit)\n\t\tgoto restart;\n\n\treturn total_count;\n}\n\n\nstatic irqreturn_t pasemi_mac_rx_intr(int irq, void *data)\n{\n\tconst struct pasemi_mac_rxring *rxring = data;\n\tstruct pasemi_mac *mac = rxring->mac;\n\tconst struct pasemi_dmachan *chan = &rxring->chan;\n\tunsigned int reg;\n\n\tif (!(*chan->status & PAS_STATUS_CAUSE_M))\n\t\treturn IRQ_NONE;\n\n\t \n\n\treg = 0;\n\tif (*chan->status & PAS_STATUS_SOFT)\n\t\treg |= PAS_IOB_DMA_RXCH_RESET_SINTC;\n\tif (*chan->status & PAS_STATUS_ERROR)\n\t\treg |= PAS_IOB_DMA_RXCH_RESET_DINTC;\n\n\tnapi_schedule(&mac->napi);\n\n\twrite_iob_reg(PAS_IOB_DMA_RXCH_RESET(chan->chno), reg);\n\n\treturn IRQ_HANDLED;\n}\n\n#define TX_CLEAN_INTERVAL HZ\n\nstatic void pasemi_mac_tx_timer(struct timer_list *t)\n{\n\tstruct pasemi_mac_txring *txring = from_timer(txring, t, clean_timer);\n\tstruct pasemi_mac *mac = txring->mac;\n\n\tpasemi_mac_clean_tx(txring);\n\n\tmod_timer(&txring->clean_timer, jiffies + TX_CLEAN_INTERVAL);\n\n\tpasemi_mac_restart_tx_intr(mac);\n}\n\nstatic irqreturn_t pasemi_mac_tx_intr(int irq, void *data)\n{\n\tstruct pasemi_mac_txring *txring = data;\n\tconst struct pasemi_dmachan *chan = &txring->chan;\n\tstruct pasemi_mac *mac = txring->mac;\n\tunsigned int reg;\n\n\tif (!(*chan->status & PAS_STATUS_CAUSE_M))\n\t\treturn IRQ_NONE;\n\n\treg = 0;\n\n\tif (*chan->status & PAS_STATUS_SOFT)\n\t\treg |= PAS_IOB_DMA_TXCH_RESET_SINTC;\n\tif (*chan->status & PAS_STATUS_ERROR)\n\t\treg |= PAS_IOB_DMA_TXCH_RESET_DINTC;\n\n\tmod_timer(&txring->clean_timer, jiffies + (TX_CLEAN_INTERVAL)*2);\n\n\tnapi_schedule(&mac->napi);\n\n\tif (reg)\n\t\twrite_iob_reg(PAS_IOB_DMA_TXCH_RESET(chan->chno), reg);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void pasemi_adjust_link(struct net_device *dev)\n{\n\tstruct pasemi_mac *mac = netdev_priv(dev);\n\tint msg;\n\tunsigned int flags;\n\tunsigned int new_flags;\n\n\tif (!dev->phydev->link) {\n\t\t \n\t\tif (mac->link && netif_msg_link(mac))\n\t\t\tprintk(KERN_INFO \"%s: Link is down.\\n\", dev->name);\n\n\t\tnetif_carrier_off(dev);\n\t\tpasemi_mac_intf_disable(mac);\n\t\tmac->link = 0;\n\n\t\treturn;\n\t} else {\n\t\tpasemi_mac_intf_enable(mac);\n\t\tnetif_carrier_on(dev);\n\t}\n\n\tflags = read_mac_reg(mac, PAS_MAC_CFG_PCFG);\n\tnew_flags = flags & ~(PAS_MAC_CFG_PCFG_HD | PAS_MAC_CFG_PCFG_SPD_M |\n\t\t\t      PAS_MAC_CFG_PCFG_TSR_M);\n\n\tif (!dev->phydev->duplex)\n\t\tnew_flags |= PAS_MAC_CFG_PCFG_HD;\n\n\tswitch (dev->phydev->speed) {\n\tcase 1000:\n\t\tnew_flags |= PAS_MAC_CFG_PCFG_SPD_1G |\n\t\t\t     PAS_MAC_CFG_PCFG_TSR_1G;\n\t\tbreak;\n\tcase 100:\n\t\tnew_flags |= PAS_MAC_CFG_PCFG_SPD_100M |\n\t\t\t     PAS_MAC_CFG_PCFG_TSR_100M;\n\t\tbreak;\n\tcase 10:\n\t\tnew_flags |= PAS_MAC_CFG_PCFG_SPD_10M |\n\t\t\t     PAS_MAC_CFG_PCFG_TSR_10M;\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"Unsupported speed %d\\n\", dev->phydev->speed);\n\t}\n\n\t \n\tmsg = mac->link != dev->phydev->link || flags != new_flags;\n\n\tmac->duplex = dev->phydev->duplex;\n\tmac->speed = dev->phydev->speed;\n\tmac->link = dev->phydev->link;\n\n\tif (new_flags != flags)\n\t\twrite_mac_reg(mac, PAS_MAC_CFG_PCFG, new_flags);\n\n\tif (msg && netif_msg_link(mac))\n\t\tprintk(KERN_INFO \"%s: Link is up at %d Mbps, %s duplex.\\n\",\n\t\t       dev->name, mac->speed, mac->duplex ? \"full\" : \"half\");\n}\n\nstatic int pasemi_mac_phy_init(struct net_device *dev)\n{\n\tstruct pasemi_mac *mac = netdev_priv(dev);\n\tstruct device_node *dn, *phy_dn;\n\tstruct phy_device *phydev;\n\n\tdn = pci_device_to_OF_node(mac->pdev);\n\tphy_dn = of_parse_phandle(dn, \"phy-handle\", 0);\n\n\tmac->link = 0;\n\tmac->speed = 0;\n\tmac->duplex = -1;\n\n\tphydev = of_phy_connect(dev, phy_dn, &pasemi_adjust_link, 0,\n\t\t\t\tPHY_INTERFACE_MODE_SGMII);\n\n\tof_node_put(phy_dn);\n\tif (!phydev) {\n\t\tprintk(KERN_ERR \"%s: Could not attach to phy\\n\", dev->name);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int pasemi_mac_open(struct net_device *dev)\n{\n\tstruct pasemi_mac *mac = netdev_priv(dev);\n\tunsigned int flags;\n\tint i, ret;\n\n\tflags = PAS_MAC_CFG_TXP_FCE | PAS_MAC_CFG_TXP_FPC(3) |\n\t\tPAS_MAC_CFG_TXP_SL(3) | PAS_MAC_CFG_TXP_COB(0xf) |\n\t\tPAS_MAC_CFG_TXP_TIFT(8) | PAS_MAC_CFG_TXP_TIFG(12);\n\n\twrite_mac_reg(mac, PAS_MAC_CFG_TXP, flags);\n\n\tret = pasemi_mac_setup_rx_resources(dev);\n\tif (ret)\n\t\tgoto out_rx_resources;\n\n\tmac->tx = pasemi_mac_setup_tx_resources(dev);\n\n\tif (!mac->tx) {\n\t\tret = -ENOMEM;\n\t\tgoto out_tx_ring;\n\t}\n\n\t \n\tif (dev->mtu > 1500 && !mac->num_cs) {\n\t\tpasemi_mac_setup_csrings(mac);\n\t\tif (!mac->num_cs) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_tx_ring;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < 32; i++)\n\t\twrite_mac_reg(mac, PAS_MAC_RMON(i), 0);\n\n\t \n\twrite_iob_reg(PAS_IOB_DMA_COM_TIMEOUTCFG,\n\t\t      PAS_IOB_DMA_COM_TIMEOUTCFG_TCNT(0x3ff));\n\n\twrite_iob_reg(PAS_IOB_DMA_RXCH_CFG(mac->rx->chan.chno),\n\t\t      PAS_IOB_DMA_RXCH_CFG_CNTTH(256));\n\n\twrite_iob_reg(PAS_IOB_DMA_TXCH_CFG(mac->tx->chan.chno),\n\t\t      PAS_IOB_DMA_TXCH_CFG_CNTTH(32));\n\n\twrite_mac_reg(mac, PAS_MAC_IPC_CHNL,\n\t\t      PAS_MAC_IPC_CHNL_DCHNO(mac->rx->chan.chno) |\n\t\t      PAS_MAC_IPC_CHNL_BCH(mac->rx->chan.chno));\n\n\t \n\twrite_dma_reg(PAS_DMA_RXINT_RCMDSTA(mac->dma_if),\n\t\t      PAS_DMA_RXINT_RCMDSTA_EN |\n\t\t      PAS_DMA_RXINT_RCMDSTA_DROPS_M |\n\t\t      PAS_DMA_RXINT_RCMDSTA_BP |\n\t\t      PAS_DMA_RXINT_RCMDSTA_OO |\n\t\t      PAS_DMA_RXINT_RCMDSTA_BT);\n\n\t \n\tpasemi_dma_start_chan(&rx_ring(mac)->chan, PAS_DMA_RXCHAN_CCMDSTA_DU |\n\t\t\t\t\t\t   PAS_DMA_RXCHAN_CCMDSTA_OD |\n\t\t\t\t\t\t   PAS_DMA_RXCHAN_CCMDSTA_FD |\n\t\t\t\t\t\t   PAS_DMA_RXCHAN_CCMDSTA_DT);\n\n\t \n\tpasemi_dma_start_chan(&tx_ring(mac)->chan, PAS_DMA_TXCHAN_TCMDSTA_SZ |\n\t\t\t\t\t\t   PAS_DMA_TXCHAN_TCMDSTA_DB |\n\t\t\t\t\t\t   PAS_DMA_TXCHAN_TCMDSTA_DE |\n\t\t\t\t\t\t   PAS_DMA_TXCHAN_TCMDSTA_DA);\n\n\tpasemi_mac_replenish_rx_ring(dev, RX_RING_SIZE);\n\n\twrite_dma_reg(PAS_DMA_RXCHAN_INCR(rx_ring(mac)->chan.chno),\n\t\t      RX_RING_SIZE>>1);\n\n\t \n\tpasemi_mac_restart_rx_intr(mac);\n\tpasemi_mac_restart_tx_intr(mac);\n\n\tflags = PAS_MAC_CFG_PCFG_S1 | PAS_MAC_CFG_PCFG_PR | PAS_MAC_CFG_PCFG_CE;\n\n\tif (mac->type == MAC_TYPE_GMAC)\n\t\tflags |= PAS_MAC_CFG_PCFG_TSR_1G | PAS_MAC_CFG_PCFG_SPD_1G;\n\telse\n\t\tflags |= PAS_MAC_CFG_PCFG_TSR_10G | PAS_MAC_CFG_PCFG_SPD_10G;\n\n\t \n\twrite_mac_reg(mac, PAS_MAC_CFG_PCFG, flags);\n\n\tret = pasemi_mac_phy_init(dev);\n\tif (ret) {\n\t\t \n\t\tpasemi_mac_intf_enable(mac);\n\t\tif (mac->type == MAC_TYPE_GMAC) {\n\t\t\t \n\t\t\tdev_warn(&mac->pdev->dev,\n\t\t\t\t \"PHY init failed: %d.\\n\", ret);\n\t\t\tdev_warn(&mac->pdev->dev,\n\t\t\t\t \"Defaulting to 1Gbit full duplex\\n\");\n\t\t}\n\t}\n\n\tnetif_start_queue(dev);\n\tnapi_enable(&mac->napi);\n\n\tsnprintf(mac->tx_irq_name, sizeof(mac->tx_irq_name), \"%s tx\",\n\t\t dev->name);\n\n\tret = request_irq(mac->tx->chan.irq, pasemi_mac_tx_intr, 0,\n\t\t\t  mac->tx_irq_name, mac->tx);\n\tif (ret) {\n\t\tdev_err(&mac->pdev->dev, \"request_irq of irq %d failed: %d\\n\",\n\t\t\tmac->tx->chan.irq, ret);\n\t\tgoto out_tx_int;\n\t}\n\n\tsnprintf(mac->rx_irq_name, sizeof(mac->rx_irq_name), \"%s rx\",\n\t\t dev->name);\n\n\tret = request_irq(mac->rx->chan.irq, pasemi_mac_rx_intr, 0,\n\t\t\t  mac->rx_irq_name, mac->rx);\n\tif (ret) {\n\t\tdev_err(&mac->pdev->dev, \"request_irq of irq %d failed: %d\\n\",\n\t\t\tmac->rx->chan.irq, ret);\n\t\tgoto out_rx_int;\n\t}\n\n\tif (dev->phydev)\n\t\tphy_start(dev->phydev);\n\n\ttimer_setup(&mac->tx->clean_timer, pasemi_mac_tx_timer, 0);\n\tmod_timer(&mac->tx->clean_timer, jiffies + HZ);\n\n\treturn 0;\n\nout_rx_int:\n\tfree_irq(mac->tx->chan.irq, mac->tx);\nout_tx_int:\n\tnapi_disable(&mac->napi);\n\tnetif_stop_queue(dev);\nout_tx_ring:\n\tif (mac->tx)\n\t\tpasemi_mac_free_tx_resources(mac);\n\tpasemi_mac_free_rx_resources(mac);\nout_rx_resources:\n\n\treturn ret;\n}\n\n#define MAX_RETRIES 5000\n\nstatic void pasemi_mac_pause_txchan(struct pasemi_mac *mac)\n{\n\tunsigned int sta, retries;\n\tint txch = tx_ring(mac)->chan.chno;\n\n\twrite_dma_reg(PAS_DMA_TXCHAN_TCMDSTA(txch),\n\t\t      PAS_DMA_TXCHAN_TCMDSTA_ST);\n\n\tfor (retries = 0; retries < MAX_RETRIES; retries++) {\n\t\tsta = read_dma_reg(PAS_DMA_TXCHAN_TCMDSTA(txch));\n\t\tif (!(sta & PAS_DMA_TXCHAN_TCMDSTA_ACT))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\n\tif (sta & PAS_DMA_TXCHAN_TCMDSTA_ACT)\n\t\tdev_err(&mac->dma_pdev->dev,\n\t\t\t\"Failed to stop tx channel, tcmdsta %08x\\n\", sta);\n\n\twrite_dma_reg(PAS_DMA_TXCHAN_TCMDSTA(txch), 0);\n}\n\nstatic void pasemi_mac_pause_rxchan(struct pasemi_mac *mac)\n{\n\tunsigned int sta, retries;\n\tint rxch = rx_ring(mac)->chan.chno;\n\n\twrite_dma_reg(PAS_DMA_RXCHAN_CCMDSTA(rxch),\n\t\t      PAS_DMA_RXCHAN_CCMDSTA_ST);\n\tfor (retries = 0; retries < MAX_RETRIES; retries++) {\n\t\tsta = read_dma_reg(PAS_DMA_RXCHAN_CCMDSTA(rxch));\n\t\tif (!(sta & PAS_DMA_RXCHAN_CCMDSTA_ACT))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\n\tif (sta & PAS_DMA_RXCHAN_CCMDSTA_ACT)\n\t\tdev_err(&mac->dma_pdev->dev,\n\t\t\t\"Failed to stop rx channel, ccmdsta 08%x\\n\", sta);\n\twrite_dma_reg(PAS_DMA_RXCHAN_CCMDSTA(rxch), 0);\n}\n\nstatic void pasemi_mac_pause_rxint(struct pasemi_mac *mac)\n{\n\tunsigned int sta, retries;\n\n\twrite_dma_reg(PAS_DMA_RXINT_RCMDSTA(mac->dma_if),\n\t\t      PAS_DMA_RXINT_RCMDSTA_ST);\n\tfor (retries = 0; retries < MAX_RETRIES; retries++) {\n\t\tsta = read_dma_reg(PAS_DMA_RXINT_RCMDSTA(mac->dma_if));\n\t\tif (!(sta & PAS_DMA_RXINT_RCMDSTA_ACT))\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\n\tif (sta & PAS_DMA_RXINT_RCMDSTA_ACT)\n\t\tdev_err(&mac->dma_pdev->dev,\n\t\t\t\"Failed to stop rx interface, rcmdsta %08x\\n\", sta);\n\twrite_dma_reg(PAS_DMA_RXINT_RCMDSTA(mac->dma_if), 0);\n}\n\nstatic int pasemi_mac_close(struct net_device *dev)\n{\n\tstruct pasemi_mac *mac = netdev_priv(dev);\n\tunsigned int sta;\n\tint rxch, txch, i;\n\n\trxch = rx_ring(mac)->chan.chno;\n\ttxch = tx_ring(mac)->chan.chno;\n\n\tif (dev->phydev) {\n\t\tphy_stop(dev->phydev);\n\t\tphy_disconnect(dev->phydev);\n\t}\n\n\tdel_timer_sync(&mac->tx->clean_timer);\n\n\tnetif_stop_queue(dev);\n\tnapi_disable(&mac->napi);\n\n\tsta = read_dma_reg(PAS_DMA_RXINT_RCMDSTA(mac->dma_if));\n\tif (sta & (PAS_DMA_RXINT_RCMDSTA_BP |\n\t\t      PAS_DMA_RXINT_RCMDSTA_OO |\n\t\t      PAS_DMA_RXINT_RCMDSTA_BT))\n\t\tprintk(KERN_DEBUG \"pasemi_mac: rcmdsta error: 0x%08x\\n\", sta);\n\n\tsta = read_dma_reg(PAS_DMA_RXCHAN_CCMDSTA(rxch));\n\tif (sta & (PAS_DMA_RXCHAN_CCMDSTA_DU |\n\t\t     PAS_DMA_RXCHAN_CCMDSTA_OD |\n\t\t     PAS_DMA_RXCHAN_CCMDSTA_FD |\n\t\t     PAS_DMA_RXCHAN_CCMDSTA_DT))\n\t\tprintk(KERN_DEBUG \"pasemi_mac: ccmdsta error: 0x%08x\\n\", sta);\n\n\tsta = read_dma_reg(PAS_DMA_TXCHAN_TCMDSTA(txch));\n\tif (sta & (PAS_DMA_TXCHAN_TCMDSTA_SZ | PAS_DMA_TXCHAN_TCMDSTA_DB |\n\t\t      PAS_DMA_TXCHAN_TCMDSTA_DE | PAS_DMA_TXCHAN_TCMDSTA_DA))\n\t\tprintk(KERN_DEBUG \"pasemi_mac: tcmdsta error: 0x%08x\\n\", sta);\n\n\t \n\tpasemi_mac_clean_tx(tx_ring(mac));\n\tpasemi_mac_clean_rx(rx_ring(mac), RX_RING_SIZE);\n\n\tpasemi_mac_pause_txchan(mac);\n\tpasemi_mac_pause_rxint(mac);\n\tpasemi_mac_pause_rxchan(mac);\n\tpasemi_mac_intf_disable(mac);\n\n\tfree_irq(mac->tx->chan.irq, mac->tx);\n\tfree_irq(mac->rx->chan.irq, mac->rx);\n\n\tfor (i = 0; i < mac->num_cs; i++) {\n\t\tpasemi_mac_free_csring(mac->cs[i]);\n\t\tmac->cs[i] = NULL;\n\t}\n\n\tmac->num_cs = 0;\n\n\t \n\tpasemi_mac_free_rx_resources(mac);\n\tpasemi_mac_free_tx_resources(mac);\n\n\treturn 0;\n}\n\nstatic void pasemi_mac_queue_csdesc(const struct sk_buff *skb,\n\t\t\t\t    const dma_addr_t *map,\n\t\t\t\t    const unsigned int *map_size,\n\t\t\t\t    struct pasemi_mac_txring *txring,\n\t\t\t\t    struct pasemi_mac_csring *csring)\n{\n\tu64 fund;\n\tdma_addr_t cs_dest;\n\tconst int nh_off = skb_network_offset(skb);\n\tconst int nh_len = skb_network_header_len(skb);\n\tconst int nfrags = skb_shinfo(skb)->nr_frags;\n\tint cs_size, i, fill, hdr, evt;\n\tdma_addr_t csdma;\n\n\tfund = XCT_FUN_ST | XCT_FUN_RR_8BRES |\n\t       XCT_FUN_O | XCT_FUN_FUN(csring->fun) |\n\t       XCT_FUN_CRM_SIG | XCT_FUN_LLEN(skb->len - nh_off) |\n\t       XCT_FUN_SHL(nh_len >> 2) | XCT_FUN_SE;\n\n\tswitch (ip_hdr(skb)->protocol) {\n\tcase IPPROTO_TCP:\n\t\tfund |= XCT_FUN_SIG_TCP4;\n\t\t \n\t\tcs_dest = map[0] + skb_transport_offset(skb) + 16;\n\t\tbreak;\n\tcase IPPROTO_UDP:\n\t\tfund |= XCT_FUN_SIG_UDP4;\n\t\t \n\t\tcs_dest = map[0] + skb_transport_offset(skb) + 6;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\t \n\tfill = csring->next_to_fill;\n\thdr = fill;\n\n\tCS_DESC(csring, fill++) = fund;\n\t \n\tcsdma = csring->chan.ring_dma + (fill & (CS_RING_SIZE-1)) * 8 + 2;\n\tCS_DESC(csring, fill++) = 0;\n\n\tCS_DESC(csring, fill) = XCT_PTR_LEN(map_size[0]-nh_off) | XCT_PTR_ADDR(map[0]+nh_off);\n\tfor (i = 1; i <= nfrags; i++)\n\t\tCS_DESC(csring, fill+i) = XCT_PTR_LEN(map_size[i]) | XCT_PTR_ADDR(map[i]);\n\n\tfill += i;\n\tif (fill & 1)\n\t\tfill++;\n\n\t \n\tCS_DESC(csring, fill++) = XCT_FUN_O | XCT_FUN_FUN(csring->fun) |\n\t\t\t\t  XCT_FUN_LLEN(2) | XCT_FUN_SE;\n\tCS_DESC(csring, fill++) = XCT_PTR_LEN(2) | XCT_PTR_ADDR(cs_dest) | XCT_PTR_T;\n\tCS_DESC(csring, fill++) = XCT_PTR_LEN(2) | XCT_PTR_ADDR(csdma);\n\tfill++;\n\n\tevt = !csring->last_event;\n\tcsring->last_event = evt;\n\n\t \n\tCS_DESC(csring, fill++) = CTRL_CMD_T | CTRL_CMD_META_EVT | CTRL_CMD_O |\n\t\t\t\t  CTRL_CMD_ETYPE_SET | CTRL_CMD_REG(csring->events[evt]);\n\tCS_DESC(csring, fill++) = 0;\n\tCS_DESC(csring, fill++) = CTRL_CMD_T | CTRL_CMD_META_EVT | CTRL_CMD_O |\n\t\t\t\t  CTRL_CMD_ETYPE_WCLR | CTRL_CMD_REG(csring->events[!evt]);\n\tCS_DESC(csring, fill++) = 0;\n\tcsring->next_to_fill = fill & (CS_RING_SIZE-1);\n\n\tcs_size = fill - hdr;\n\twrite_dma_reg(PAS_DMA_TXCHAN_INCR(csring->chan.chno), (cs_size) >> 1);\n\n\t \n\tfill = txring->next_to_fill;\n\tTX_DESC(txring, fill++) = CTRL_CMD_T | CTRL_CMD_META_EVT | CTRL_CMD_O |\n\t\t\t\t  CTRL_CMD_ETYPE_WSET | CTRL_CMD_REG(csring->events[evt]);\n\tTX_DESC(txring, fill++) = 0;\n\tTX_DESC(txring, fill++) = CTRL_CMD_T | CTRL_CMD_META_EVT | CTRL_CMD_O |\n\t\t\t\t  CTRL_CMD_ETYPE_CLR | CTRL_CMD_REG(csring->events[!evt]);\n\tTX_DESC(txring, fill++) = 0;\n\ttxring->next_to_fill = fill;\n\n\twrite_dma_reg(PAS_DMA_TXCHAN_INCR(txring->chan.chno), 2);\n}\n\nstatic netdev_tx_t pasemi_mac_start_tx(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct pasemi_mac * const mac = netdev_priv(dev);\n\tstruct pasemi_mac_txring * const txring = tx_ring(mac);\n\tstruct pasemi_mac_csring *csring;\n\tu64 dflags = 0;\n\tu64 mactx;\n\tdma_addr_t map[MAX_SKB_FRAGS+1];\n\tunsigned int map_size[MAX_SKB_FRAGS+1];\n\tunsigned long flags;\n\tint i, nfrags;\n\tint fill;\n\tconst int nh_off = skb_network_offset(skb);\n\tconst int nh_len = skb_network_header_len(skb);\n\n\tprefetch(&txring->ring_info);\n\n\tdflags = XCT_MACTX_O | XCT_MACTX_ST | XCT_MACTX_CRC_PAD;\n\n\tnfrags = skb_shinfo(skb)->nr_frags;\n\n\tmap[0] = dma_map_single(&mac->dma_pdev->dev, skb->data,\n\t\t\t\tskb_headlen(skb), DMA_TO_DEVICE);\n\tmap_size[0] = skb_headlen(skb);\n\tif (dma_mapping_error(&mac->dma_pdev->dev, map[0]))\n\t\tgoto out_err_nolock;\n\n\tfor (i = 0; i < nfrags; i++) {\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\tmap[i + 1] = skb_frag_dma_map(&mac->dma_pdev->dev, frag, 0,\n\t\t\t\t\t      skb_frag_size(frag), DMA_TO_DEVICE);\n\t\tmap_size[i+1] = skb_frag_size(frag);\n\t\tif (dma_mapping_error(&mac->dma_pdev->dev, map[i + 1])) {\n\t\t\tnfrags = i;\n\t\t\tgoto out_err_nolock;\n\t\t}\n\t}\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL && skb->len <= 1540) {\n\t\tswitch (ip_hdr(skb)->protocol) {\n\t\tcase IPPROTO_TCP:\n\t\t\tdflags |= XCT_MACTX_CSUM_TCP;\n\t\t\tdflags |= XCT_MACTX_IPH(nh_len >> 2);\n\t\t\tdflags |= XCT_MACTX_IPO(nh_off);\n\t\t\tbreak;\n\t\tcase IPPROTO_UDP:\n\t\t\tdflags |= XCT_MACTX_CSUM_UDP;\n\t\t\tdflags |= XCT_MACTX_IPH(nh_len >> 2);\n\t\t\tdflags |= XCT_MACTX_IPO(nh_off);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t}\n\t}\n\n\tmactx = dflags | XCT_MACTX_LLEN(skb->len);\n\n\tspin_lock_irqsave(&txring->lock, flags);\n\n\t \n\tif (RING_AVAIL(txring) < nfrags + 14) {\n\t\t \n\t\tnetif_stop_queue(dev);\n\t\tgoto out_err;\n\t}\n\n\t \n\tif (mac->num_cs && skb->ip_summed == CHECKSUM_PARTIAL && skb->len > 1540) {\n\t\tcsring = mac->cs[mac->last_cs];\n\t\tmac->last_cs = (mac->last_cs + 1) % mac->num_cs;\n\n\t\tpasemi_mac_queue_csdesc(skb, map, map_size, txring, csring);\n\t}\n\n\tfill = txring->next_to_fill;\n\tTX_DESC(txring, fill) = mactx;\n\tTX_DESC_INFO(txring, fill).dma = nfrags;\n\tfill++;\n\tTX_DESC_INFO(txring, fill).skb = skb;\n\tfor (i = 0; i <= nfrags; i++) {\n\t\tTX_DESC(txring, fill+i) =\n\t\t\tXCT_PTR_LEN(map_size[i]) | XCT_PTR_ADDR(map[i]);\n\t\tTX_DESC_INFO(txring, fill+i).dma = map[i];\n\t}\n\n\t \n\tif (nfrags & 1)\n\t\tnfrags++;\n\n\ttxring->next_to_fill = (fill + nfrags + 1) & (TX_RING_SIZE-1);\n\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += skb->len;\n\n\tspin_unlock_irqrestore(&txring->lock, flags);\n\n\twrite_dma_reg(PAS_DMA_TXCHAN_INCR(txring->chan.chno), (nfrags+2) >> 1);\n\n\treturn NETDEV_TX_OK;\n\nout_err:\n\tspin_unlock_irqrestore(&txring->lock, flags);\nout_err_nolock:\n\twhile (nfrags--)\n\t\tdma_unmap_single(&mac->dma_pdev->dev, map[nfrags],\n\t\t\t\t map_size[nfrags], DMA_TO_DEVICE);\n\n\treturn NETDEV_TX_BUSY;\n}\n\nstatic void pasemi_mac_set_rx_mode(struct net_device *dev)\n{\n\tconst struct pasemi_mac *mac = netdev_priv(dev);\n\tunsigned int flags;\n\n\tflags = read_mac_reg(mac, PAS_MAC_CFG_PCFG);\n\n\t \n\tif (dev->flags & IFF_PROMISC)\n\t\tflags |= PAS_MAC_CFG_PCFG_PR;\n\telse\n\t\tflags &= ~PAS_MAC_CFG_PCFG_PR;\n\n\twrite_mac_reg(mac, PAS_MAC_CFG_PCFG, flags);\n}\n\n\nstatic int pasemi_mac_poll(struct napi_struct *napi, int budget)\n{\n\tstruct pasemi_mac *mac = container_of(napi, struct pasemi_mac, napi);\n\tint pkts;\n\n\tpasemi_mac_clean_tx(tx_ring(mac));\n\tpkts = pasemi_mac_clean_rx(rx_ring(mac), budget);\n\tif (pkts < budget) {\n\t\t \n\t\tnapi_complete_done(napi, pkts);\n\n\t\tpasemi_mac_restart_rx_intr(mac);\n\t\tpasemi_mac_restart_tx_intr(mac);\n\t}\n\treturn pkts;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n \nstatic void pasemi_mac_netpoll(struct net_device *dev)\n{\n\tconst struct pasemi_mac *mac = netdev_priv(dev);\n\n\tdisable_irq(mac->tx->chan.irq);\n\tpasemi_mac_tx_intr(mac->tx->chan.irq, mac->tx);\n\tenable_irq(mac->tx->chan.irq);\n\n\tdisable_irq(mac->rx->chan.irq);\n\tpasemi_mac_rx_intr(mac->rx->chan.irq, mac->rx);\n\tenable_irq(mac->rx->chan.irq);\n}\n#endif\n\nstatic int pasemi_mac_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct pasemi_mac *mac = netdev_priv(dev);\n\tunsigned int reg;\n\tunsigned int rcmdsta = 0;\n\tint running;\n\tint ret = 0;\n\n\trunning = netif_running(dev);\n\n\tif (running) {\n\t\t \n\n\t\tnapi_disable(&mac->napi);\n\t\tnetif_tx_disable(dev);\n\t\tpasemi_mac_intf_disable(mac);\n\n\t\trcmdsta = read_dma_reg(PAS_DMA_RXINT_RCMDSTA(mac->dma_if));\n\t\tpasemi_mac_pause_rxint(mac);\n\t\tpasemi_mac_clean_rx(rx_ring(mac), RX_RING_SIZE);\n\t\tpasemi_mac_free_rx_buffers(mac);\n\n\t}\n\n\t \n\tif (new_mtu > PE_DEF_MTU && !mac->num_cs) {\n\t\tpasemi_mac_setup_csrings(mac);\n\t\tif (!mac->num_cs) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\treg = read_mac_reg(mac, PAS_MAC_CFG_MACCFG);\n\treg &= ~PAS_MAC_CFG_MACCFG_MAXF_M;\n\treg |= PAS_MAC_CFG_MACCFG_MAXF(new_mtu + ETH_HLEN + 4);\n\twrite_mac_reg(mac, PAS_MAC_CFG_MACCFG, reg);\n\n\tdev->mtu = new_mtu;\n\t \n\tmac->bufsz = new_mtu + ETH_HLEN + ETH_FCS_LEN + LOCAL_SKB_ALIGN + 128;\n\nout:\n\tif (running) {\n\t\twrite_dma_reg(PAS_DMA_RXINT_RCMDSTA(mac->dma_if),\n\t\t\t      rcmdsta | PAS_DMA_RXINT_RCMDSTA_EN);\n\n\t\trx_ring(mac)->next_to_fill = 0;\n\t\tpasemi_mac_replenish_rx_ring(dev, RX_RING_SIZE-1);\n\n\t\tnapi_enable(&mac->napi);\n\t\tnetif_start_queue(dev);\n\t\tpasemi_mac_intf_enable(mac);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct net_device_ops pasemi_netdev_ops = {\n\t.ndo_open\t\t= pasemi_mac_open,\n\t.ndo_stop\t\t= pasemi_mac_close,\n\t.ndo_start_xmit\t\t= pasemi_mac_start_tx,\n\t.ndo_set_rx_mode\t= pasemi_mac_set_rx_mode,\n\t.ndo_set_mac_address\t= pasemi_mac_set_mac_addr,\n\t.ndo_change_mtu\t\t= pasemi_mac_change_mtu,\n\t.ndo_validate_addr\t= eth_validate_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= pasemi_mac_netpoll,\n#endif\n};\n\nstatic int\npasemi_mac_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct net_device *dev;\n\tstruct pasemi_mac *mac;\n\tint err, ret;\n\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\treturn err;\n\n\tdev = alloc_etherdev(sizeof(struct pasemi_mac));\n\tif (dev == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_disable_device;\n\t}\n\n\tpci_set_drvdata(pdev, dev);\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\tmac = netdev_priv(dev);\n\n\tmac->pdev = pdev;\n\tmac->netdev = dev;\n\n\tnetif_napi_add(dev, &mac->napi, pasemi_mac_poll);\n\n\tdev->features = NETIF_F_IP_CSUM | NETIF_F_LLTX | NETIF_F_SG |\n\t\t\tNETIF_F_HIGHDMA | NETIF_F_GSO;\n\n\tmac->dma_pdev = pci_get_device(PCI_VENDOR_ID_PASEMI, 0xa007, NULL);\n\tif (!mac->dma_pdev) {\n\t\tdev_err(&mac->pdev->dev, \"Can't find DMA Controller\\n\");\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\tdma_set_mask(&mac->dma_pdev->dev, DMA_BIT_MASK(64));\n\n\tmac->iob_pdev = pci_get_device(PCI_VENDOR_ID_PASEMI, 0xa001, NULL);\n\tif (!mac->iob_pdev) {\n\t\tdev_err(&mac->pdev->dev, \"Can't find I/O Bridge\\n\");\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\t \n\tif (pasemi_get_mac_addr(mac) || !is_valid_ether_addr(mac->mac_addr)) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\teth_hw_addr_set(dev, mac->mac_addr);\n\n\tret = mac_to_intf(mac);\n\tif (ret < 0) {\n\t\tdev_err(&mac->pdev->dev, \"Can't map DMA interface\\n\");\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\tmac->dma_if = ret;\n\n\tswitch (pdev->device) {\n\tcase 0xa005:\n\t\tmac->type = MAC_TYPE_GMAC;\n\t\tbreak;\n\tcase 0xa006:\n\t\tmac->type = MAC_TYPE_XAUI;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tdev->netdev_ops = &pasemi_netdev_ops;\n\tdev->mtu = PE_DEF_MTU;\n\n\t \n\tdev->min_mtu = PE_MIN_MTU;\n\tdev->max_mtu = PE_MAX_MTU;\n\n\t \n\tmac->bufsz = dev->mtu + ETH_HLEN + ETH_FCS_LEN + LOCAL_SKB_ALIGN + 128;\n\n\tdev->ethtool_ops = &pasemi_mac_ethtool_ops;\n\n\tif (err)\n\t\tgoto out;\n\n\tmac->msg_enable = netif_msg_init(debug, DEFAULT_MSG_ENABLE);\n\n\t \n\tmac->msg_enable = (NETIF_MSG_IFUP << 1 ) - 1;\n\n\terr = register_netdev(dev);\n\n\tif (err) {\n\t\tdev_err(&mac->pdev->dev, \"register_netdev failed with error %d\\n\",\n\t\t\terr);\n\t\tgoto out;\n\t} else if (netif_msg_probe(mac)) {\n\t\tprintk(KERN_INFO \"%s: PA Semi %s: intf %d, hw addr %pM\\n\",\n\t\t       dev->name, mac->type == MAC_TYPE_GMAC ? \"GMAC\" : \"XAUI\",\n\t\t       mac->dma_if, dev->dev_addr);\n\t}\n\n\treturn err;\n\nout:\n\tpci_dev_put(mac->iob_pdev);\n\tpci_dev_put(mac->dma_pdev);\n\n\tfree_netdev(dev);\nout_disable_device:\n\tpci_disable_device(pdev);\n\treturn err;\n\n}\n\nstatic void pasemi_mac_remove(struct pci_dev *pdev)\n{\n\tstruct net_device *netdev = pci_get_drvdata(pdev);\n\tstruct pasemi_mac *mac;\n\n\tif (!netdev)\n\t\treturn;\n\n\tmac = netdev_priv(netdev);\n\n\tunregister_netdev(netdev);\n\n\tpci_disable_device(pdev);\n\tpci_dev_put(mac->dma_pdev);\n\tpci_dev_put(mac->iob_pdev);\n\n\tpasemi_dma_free_chan(&mac->tx->chan);\n\tpasemi_dma_free_chan(&mac->rx->chan);\n\n\tfree_netdev(netdev);\n}\n\nstatic const struct pci_device_id pasemi_mac_pci_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_PASEMI, 0xa005) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_PASEMI, 0xa006) },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(pci, pasemi_mac_pci_tbl);\n\nstatic struct pci_driver pasemi_mac_driver = {\n\t.name\t\t= \"pasemi_mac\",\n\t.id_table\t= pasemi_mac_pci_tbl,\n\t.probe\t\t= pasemi_mac_probe,\n\t.remove\t\t= pasemi_mac_remove,\n};\n\nstatic void __exit pasemi_mac_cleanup_module(void)\n{\n\tpci_unregister_driver(&pasemi_mac_driver);\n}\n\nstatic int pasemi_mac_init_module(void)\n{\n\tint err;\n\n\terr = pasemi_dma_init();\n\tif (err)\n\t\treturn err;\n\n\treturn pci_register_driver(&pasemi_mac_driver);\n}\n\nmodule_init(pasemi_mac_init_module);\nmodule_exit(pasemi_mac_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}