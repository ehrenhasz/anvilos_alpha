{
  "module_name": "sis190.c",
  "hash_id": "8eb54d242b1570001beda7af5309fac384772a2e2ba85d99a0064fed5a9bcd09",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sis/sis190.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/netdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/pci.h>\n#include <linux/mii.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <asm/irq.h>\n\n#define PHY_MAX_ADDR\t\t32\n#define PHY_ID_ANY\t\t0x1f\n#define MII_REG_ANY\t\t0x1f\n\n#define DRV_VERSION\t\t\"1.4\"\n#define DRV_NAME\t\t\"sis190\"\n#define SIS190_DRIVER_NAME\tDRV_NAME \" Gigabit Ethernet driver \" DRV_VERSION\n\n#define sis190_rx_skb\t\t\tnetif_rx\n#define sis190_rx_quota(count, quota)\tcount\n\n#define NUM_TX_DESC\t\t64\t \n#define NUM_RX_DESC\t\t64\t \n#define TX_RING_BYTES\t\t(NUM_TX_DESC * sizeof(struct TxDesc))\n#define RX_RING_BYTES\t\t(NUM_RX_DESC * sizeof(struct RxDesc))\n#define RX_BUF_SIZE\t\t1536\n#define RX_BUF_MASK\t\t0xfff8\n\n#define SIS190_REGS_SIZE\t0x80\n#define SIS190_TX_TIMEOUT\t(6*HZ)\n#define SIS190_PHY_TIMEOUT\t(10*HZ)\n#define SIS190_MSG_DEFAULT\t(NETIF_MSG_DRV | NETIF_MSG_PROBE | \\\n\t\t\t\t NETIF_MSG_LINK | NETIF_MSG_IFUP | \\\n\t\t\t\t NETIF_MSG_IFDOWN)\n\n \n#define EhnMIIread\t\t0x0000\n#define EhnMIIwrite\t\t0x0020\n#define EhnMIIdataShift\t\t16\n#define EhnMIIpmdShift\t\t6\t \n#define EhnMIIregShift\t\t11\n#define EhnMIIreq\t\t0x0010\n#define EhnMIInotDone\t\t0x0010\n\n \n#define SIS_W8(reg, val)\twriteb ((val), ioaddr + (reg))\n#define SIS_W16(reg, val)\twritew ((val), ioaddr + (reg))\n#define SIS_W32(reg, val)\twritel ((val), ioaddr + (reg))\n#define SIS_R8(reg)\t\treadb (ioaddr + (reg))\n#define SIS_R16(reg)\t\treadw (ioaddr + (reg))\n#define SIS_R32(reg)\t\treadl (ioaddr + (reg))\n\n#define SIS_PCI_COMMIT()\tSIS_R32(IntrControl)\n\nenum sis190_registers {\n\tTxControl\t\t= 0x00,\n\tTxDescStartAddr\t\t= 0x04,\n\trsv0\t\t\t= 0x08,\t\n\tTxSts\t\t\t= 0x0c,\t\n\tRxControl\t\t= 0x10,\n\tRxDescStartAddr\t\t= 0x14,\n\trsv1\t\t\t= 0x18,\t\n\tRxSts\t\t\t= 0x1c,\t\n\tIntrStatus\t\t= 0x20,\n\tIntrMask\t\t= 0x24,\n\tIntrControl\t\t= 0x28,\n\tIntrTimer\t\t= 0x2c,\t\n\tPMControl\t\t= 0x30,\t\n\trsv2\t\t\t= 0x34,\t\n\tROMControl\t\t= 0x38,\n\tROMInterface\t\t= 0x3c,\n\tStationControl\t\t= 0x40,\n\tGMIIControl\t\t= 0x44,\n\tGIoCR\t\t\t= 0x48, \n\tGIoCtrl\t\t\t= 0x4c, \n\tTxMacControl\t\t= 0x50,\n\tTxLimit\t\t\t= 0x54, \n\tRGDelay\t\t\t= 0x58, \n\trsv3\t\t\t= 0x5c, \n\tRxMacControl\t\t= 0x60,\n\tRxMacAddr\t\t= 0x62,\n\tRxHashTable\t\t= 0x68,\n\t\n\tRxWolCtrl\t\t= 0x70,\n\tRxWolData\t\t= 0x74, \n\tRxMPSControl\t\t= 0x78,\t\n\trsv4\t\t\t= 0x7c, \n};\n\nenum sis190_register_content {\n\t \n\tSoftInt\t\t\t= 0x40000000,\t\n\tTimeup\t\t\t= 0x20000000,\t\n\tPauseFrame\t\t= 0x00080000,\t\n\tMagicPacket\t\t= 0x00040000,\t\n\tWakeupFrame\t\t= 0x00020000,\t\n\tLinkChange\t\t= 0x00010000,\n\tRxQEmpty\t\t= 0x00000080,\n\tRxQInt\t\t\t= 0x00000040,\n\tTxQ1Empty\t\t= 0x00000020,\t\n\tTxQ1Int\t\t\t= 0x00000010,\n\tTxQ0Empty\t\t= 0x00000008,\t\n\tTxQ0Int\t\t\t= 0x00000004,\n\tRxHalt\t\t\t= 0x00000002,\n\tTxHalt\t\t\t= 0x00000001,\n\n\t \n\tCmdReset\t\t= 0x10,\n\tCmdRxEnb\t\t= 0x08,\t\t\n\tCmdTxEnb\t\t= 0x01,\n\tRxBufEmpty\t\t= 0x01,\t\t\n\n\t \n\tCfg9346_Lock\t\t= 0x00,\t\t\n\tCfg9346_Unlock\t\t= 0xc0,\t\t\n\n\t \n\tAcceptErr\t\t= 0x20,\t\t\n\tAcceptRunt\t\t= 0x10,\t\t\n\tAcceptBroadcast\t\t= 0x0800,\n\tAcceptMulticast\t\t= 0x0400,\n\tAcceptMyPhys\t\t= 0x0200,\n\tAcceptAllPhys\t\t= 0x0100,\n\n\t \n\tRxCfgFIFOShift\t\t= 13,\n\tRxCfgDMAShift\t\t= 8,\t\t\n\n\t \n\tTxInterFrameGapShift\t= 24,\n\tTxDMAShift\t\t= 8,  \n\n\tLinkStatus\t\t= 0x02,\t\t\n\tFullDup\t\t\t= 0x01,\t\t\n\n\t \n\tTBILinkOK\t\t= 0x02000000,\t\n};\n\nstruct TxDesc {\n\t__le32 PSize;\n\t__le32 status;\n\t__le32 addr;\n\t__le32 size;\n};\n\nstruct RxDesc {\n\t__le32 PSize;\n\t__le32 status;\n\t__le32 addr;\n\t__le32 size;\n};\n\nenum _DescStatusBit {\n\t \n\tOWNbit\t\t= 0x80000000, \n\tINTbit\t\t= 0x40000000, \n\tCRCbit\t\t= 0x00020000, \n\tPADbit\t\t= 0x00010000, \n\t \n\tRingEnd\t\t= 0x80000000,\n\t \n\tLSEN\t\t= 0x08000000, \n\tIPCS\t\t= 0x04000000,\n\tTCPCS\t\t= 0x02000000,\n\tUDPCS\t\t= 0x01000000,\n\tBSTEN\t\t= 0x00800000,\n\tEXTEN\t\t= 0x00400000,\n\tDEFEN\t\t= 0x00200000,\n\tBKFEN\t\t= 0x00100000,\n\tCRSEN\t\t= 0x00080000,\n\tCOLEN\t\t= 0x00040000,\n\tTHOL3\t\t= 0x30000000,\n\tTHOL2\t\t= 0x20000000,\n\tTHOL1\t\t= 0x10000000,\n\tTHOL0\t\t= 0x00000000,\n\n\tWND\t\t= 0x00080000,\n\tTABRT\t\t= 0x00040000,\n\tFIFO\t\t= 0x00020000,\n\tLINK\t\t= 0x00010000,\n\tColCountMask\t= 0x0000ffff,\n\t \n\tIPON\t\t= 0x20000000,\n\tTCPON\t\t= 0x10000000,\n\tUDPON\t\t= 0x08000000,\n\tWakup\t\t= 0x00400000,\n\tMagic\t\t= 0x00200000,\n\tPause\t\t= 0x00100000,\n\tDEFbit\t\t= 0x00200000,\n\tBCAST\t\t= 0x000c0000,\n\tMCAST\t\t= 0x00080000,\n\tUCAST\t\t= 0x00040000,\n\t \n\tTAGON\t\t= 0x80000000,\n\tRxDescCountMask\t= 0x7f000000, \n\tABORT\t\t= 0x00800000,\n\tSHORT\t\t= 0x00400000,\n\tLIMIT\t\t= 0x00200000,\n\tMIIER\t\t= 0x00100000,\n\tOVRUN\t\t= 0x00080000,\n\tNIBON\t\t= 0x00040000,\n\tCOLON\t\t= 0x00020000,\n\tCRCOK\t\t= 0x00010000,\n\tRxSizeMask\t= 0x0000ffff\n\t \n};\n\nenum sis190_eeprom_access_register_bits {\n\tEECS\t= 0x00000001,\t\n\tEECLK\t= 0x00000002,\t\n\tEEDO\t= 0x00000008,\t\n\tEEDI\t= 0x00000004,\t\n\tEEREQ\t= 0x00000080,\n\tEEROP\t= 0x00000200,\n\tEEWOP\t= 0x00000100\t\n};\n\n \nenum sis190_eeprom_address {\n\tEEPROMSignature\t= 0x00,\n\tEEPROMCLK\t= 0x01,\t\n\tEEPROMInfo\t= 0x02,\n\tEEPROMMACAddr\t= 0x03\n};\n\nenum sis190_feature {\n\tF_HAS_RGMII\t= 1,\n\tF_PHY_88E1111\t= 2,\n\tF_PHY_BCM5461\t= 4\n};\n\nstruct sis190_private {\n\tvoid __iomem *mmio_addr;\n\tstruct pci_dev *pci_dev;\n\tstruct net_device *dev;\n\tspinlock_t lock;\n\tu32 rx_buf_sz;\n\tu32 cur_rx;\n\tu32 cur_tx;\n\tu32 dirty_rx;\n\tu32 dirty_tx;\n\tdma_addr_t rx_dma;\n\tdma_addr_t tx_dma;\n\tstruct RxDesc *RxDescRing;\n\tstruct TxDesc *TxDescRing;\n\tstruct sk_buff *Rx_skbuff[NUM_RX_DESC];\n\tstruct sk_buff *Tx_skbuff[NUM_TX_DESC];\n\tstruct work_struct phy_task;\n\tstruct timer_list timer;\n\tu32 msg_enable;\n\tstruct mii_if_info mii_if;\n\tstruct list_head first_phy;\n\tu32 features;\n\tu32 negotiated_lpa;\n\tenum {\n\t\tLNK_OFF,\n\t\tLNK_ON,\n\t\tLNK_AUTONEG,\n\t} link_status;\n};\n\nstruct sis190_phy {\n\tstruct list_head list;\n\tint phy_id;\n\tu16 id[2];\n\tu16 status;\n\tu8  type;\n};\n\nenum sis190_phy_type {\n\tUNKNOWN\t= 0x00,\n\tHOME\t= 0x01,\n\tLAN\t= 0x02,\n\tMIX\t= 0x03\n};\n\nstatic struct mii_chip_info {\n        const char *name;\n        u16 id[2];\n        unsigned int type;\n\tu32 feature;\n} mii_chip_table[] = {\n\t{ \"Atheros PHY\",          { 0x004d, 0xd010 }, LAN, 0 },\n\t{ \"Atheros PHY AR8012\",   { 0x004d, 0xd020 }, LAN, 0 },\n\t{ \"Broadcom PHY BCM5461\", { 0x0020, 0x60c0 }, LAN, F_PHY_BCM5461 },\n\t{ \"Broadcom PHY AC131\",   { 0x0143, 0xbc70 }, LAN, 0 },\n\t{ \"Agere PHY ET1101B\",    { 0x0282, 0xf010 }, LAN, 0 },\n\t{ \"Marvell PHY 88E1111\",  { 0x0141, 0x0cc0 }, LAN, F_PHY_88E1111 },\n\t{ \"Realtek PHY RTL8201\",  { 0x0000, 0x8200 }, LAN, 0 },\n\t{ NULL, }\n};\n\nstatic const struct {\n\tconst char *name;\n} sis_chip_info[] = {\n\t{ \"SiS 190 PCI Fast Ethernet adapter\" },\n\t{ \"SiS 191 PCI Gigabit Ethernet adapter\" },\n};\n\nstatic const struct pci_device_id sis190_pci_tbl[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_SI, 0x0190), 0, 0, 0 },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_SI, 0x0191), 0, 0, 1 },\n\t{ 0, },\n};\n\nMODULE_DEVICE_TABLE(pci, sis190_pci_tbl);\n\nstatic int rx_copybreak = 200;\n\nstatic struct {\n\tu32 msg_enable;\n} debug = { -1 };\n\nMODULE_DESCRIPTION(\"SiS sis190/191 Gigabit Ethernet driver\");\nmodule_param(rx_copybreak, int, 0);\nMODULE_PARM_DESC(rx_copybreak, \"Copy breakpoint for copy-only-tiny-frames\");\nmodule_param_named(debug, debug.msg_enable, int, 0);\nMODULE_PARM_DESC(debug, \"Debug verbosity level (0=none, ..., 16=all)\");\nMODULE_AUTHOR(\"K.M. Liu <kmliu@sis.com>, Ueimor <romieu@fr.zoreil.com>\");\nMODULE_VERSION(DRV_VERSION);\nMODULE_LICENSE(\"GPL\");\n\nstatic const u32 sis190_intr_mask =\n\tRxQEmpty | RxQInt | TxQ1Int | TxQ0Int | RxHalt | TxHalt | LinkChange;\n\n \nstatic const int multicast_filter_limit = 32;\n\nstatic void __mdio_cmd(void __iomem *ioaddr, u32 ctl)\n{\n\tunsigned int i;\n\n\tSIS_W32(GMIIControl, ctl);\n\n\tmsleep(1);\n\n\tfor (i = 0; i < 100; i++) {\n\t\tif (!(SIS_R32(GMIIControl) & EhnMIInotDone))\n\t\t\tbreak;\n\t\tmsleep(1);\n\t}\n\n\tif (i > 99)\n\t\tpr_err(\"PHY command failed !\\n\");\n}\n\nstatic void mdio_write(void __iomem *ioaddr, int phy_id, int reg, int val)\n{\n\t__mdio_cmd(ioaddr, EhnMIIreq | EhnMIIwrite |\n\t\t(((u32) reg) << EhnMIIregShift) | (phy_id << EhnMIIpmdShift) |\n\t\t(((u32) val) << EhnMIIdataShift));\n}\n\nstatic int mdio_read(void __iomem *ioaddr, int phy_id, int reg)\n{\n\t__mdio_cmd(ioaddr, EhnMIIreq | EhnMIIread |\n\t\t(((u32) reg) << EhnMIIregShift) | (phy_id << EhnMIIpmdShift));\n\n\treturn (u16) (SIS_R32(GMIIControl) >> EhnMIIdataShift);\n}\n\nstatic void __mdio_write(struct net_device *dev, int phy_id, int reg, int val)\n{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\n\tmdio_write(tp->mmio_addr, phy_id, reg, val);\n}\n\nstatic int __mdio_read(struct net_device *dev, int phy_id, int reg)\n{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\n\treturn mdio_read(tp->mmio_addr, phy_id, reg);\n}\n\nstatic u16 mdio_read_latched(void __iomem *ioaddr, int phy_id, int reg)\n{\n\tmdio_read(ioaddr, phy_id, reg);\n\treturn mdio_read(ioaddr, phy_id, reg);\n}\n\nstatic u16 sis190_read_eeprom(void __iomem *ioaddr, u32 reg)\n{\n\tu16 data = 0xffff;\n\tunsigned int i;\n\n\tif (!(SIS_R32(ROMControl) & 0x0002))\n\t\treturn 0;\n\n\tSIS_W32(ROMInterface, EEREQ | EEROP | (reg << 10));\n\n\tfor (i = 0; i < 200; i++) {\n\t\tif (!(SIS_R32(ROMInterface) & EEREQ)) {\n\t\t\tdata = (SIS_R32(ROMInterface) & 0xffff0000) >> 16;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(1);\n\t}\n\n\treturn data;\n}\n\nstatic void sis190_irq_mask_and_ack(void __iomem *ioaddr)\n{\n\tSIS_W32(IntrMask, 0x00);\n\tSIS_W32(IntrStatus, 0xffffffff);\n\tSIS_PCI_COMMIT();\n}\n\nstatic void sis190_asic_down(void __iomem *ioaddr)\n{\n\t \n\n\tSIS_W32(TxControl, 0x1a00);\n\tSIS_W32(RxControl, 0x1a00);\n\n\tsis190_irq_mask_and_ack(ioaddr);\n}\n\nstatic void sis190_mark_as_last_descriptor(struct RxDesc *desc)\n{\n\tdesc->size |= cpu_to_le32(RingEnd);\n}\n\nstatic inline void sis190_give_to_asic(struct RxDesc *desc, u32 rx_buf_sz)\n{\n\tu32 eor = le32_to_cpu(desc->size) & RingEnd;\n\n\tdesc->PSize = 0x0;\n\tdesc->size = cpu_to_le32((rx_buf_sz & RX_BUF_MASK) | eor);\n\twmb();\n\tdesc->status = cpu_to_le32(OWNbit | INTbit);\n}\n\nstatic inline void sis190_map_to_asic(struct RxDesc *desc, dma_addr_t mapping,\n\t\t\t\t      u32 rx_buf_sz)\n{\n\tdesc->addr = cpu_to_le32(mapping);\n\tsis190_give_to_asic(desc, rx_buf_sz);\n}\n\nstatic inline void sis190_make_unusable_by_asic(struct RxDesc *desc)\n{\n\tdesc->PSize = 0x0;\n\tdesc->addr = cpu_to_le32(0xdeadbeef);\n\tdesc->size &= cpu_to_le32(RingEnd);\n\twmb();\n\tdesc->status = 0x0;\n}\n\nstatic struct sk_buff *sis190_alloc_rx_skb(struct sis190_private *tp,\n\t\t\t\t\t   struct RxDesc *desc)\n{\n\tu32 rx_buf_sz = tp->rx_buf_sz;\n\tstruct sk_buff *skb;\n\tdma_addr_t mapping;\n\n\tskb = netdev_alloc_skb(tp->dev, rx_buf_sz);\n\tif (unlikely(!skb))\n\t\tgoto skb_alloc_failed;\n\tmapping = dma_map_single(&tp->pci_dev->dev, skb->data, tp->rx_buf_sz,\n\t\t\t\t DMA_FROM_DEVICE);\n\tif (dma_mapping_error(&tp->pci_dev->dev, mapping))\n\t\tgoto out;\n\tsis190_map_to_asic(desc, mapping, rx_buf_sz);\n\n\treturn skb;\n\nout:\n\tdev_kfree_skb_any(skb);\nskb_alloc_failed:\n\tsis190_make_unusable_by_asic(desc);\n\treturn NULL;\n}\n\nstatic u32 sis190_rx_fill(struct sis190_private *tp, struct net_device *dev,\n\t\t\t  u32 start, u32 end)\n{\n\tu32 cur;\n\n\tfor (cur = start; cur < end; cur++) {\n\t\tunsigned int i = cur % NUM_RX_DESC;\n\n\t\tif (tp->Rx_skbuff[i])\n\t\t\tcontinue;\n\n\t\ttp->Rx_skbuff[i] = sis190_alloc_rx_skb(tp, tp->RxDescRing + i);\n\n\t\tif (!tp->Rx_skbuff[i])\n\t\t\tbreak;\n\t}\n\treturn cur - start;\n}\n\nstatic bool sis190_try_rx_copy(struct sis190_private *tp,\n\t\t\t       struct sk_buff **sk_buff, int pkt_size,\n\t\t\t       dma_addr_t addr)\n{\n\tstruct sk_buff *skb;\n\tbool done = false;\n\n\tif (pkt_size >= rx_copybreak)\n\t\tgoto out;\n\n\tskb = netdev_alloc_skb_ip_align(tp->dev, pkt_size);\n\tif (!skb)\n\t\tgoto out;\n\n\tdma_sync_single_for_cpu(&tp->pci_dev->dev, addr, tp->rx_buf_sz,\n\t\t\t\tDMA_FROM_DEVICE);\n\tskb_copy_to_linear_data(skb, sk_buff[0]->data, pkt_size);\n\t*sk_buff = skb;\n\tdone = true;\nout:\n\treturn done;\n}\n\nstatic inline int sis190_rx_pkt_err(u32 status, struct net_device_stats *stats)\n{\n#define ErrMask\t(OVRUN | SHORT | LIMIT | MIIER | NIBON | COLON | ABORT)\n\n\tif ((status & CRCOK) && !(status & ErrMask))\n\t\treturn 0;\n\n\tif (!(status & CRCOK))\n\t\tstats->rx_crc_errors++;\n\telse if (status & OVRUN)\n\t\tstats->rx_over_errors++;\n\telse if (status & (SHORT | LIMIT))\n\t\tstats->rx_length_errors++;\n\telse if (status & (MIIER | NIBON | COLON))\n\t\tstats->rx_frame_errors++;\n\n\tstats->rx_errors++;\n\treturn -1;\n}\n\nstatic int sis190_rx_interrupt(struct net_device *dev,\n\t\t\t       struct sis190_private *tp, void __iomem *ioaddr)\n{\n\tstruct net_device_stats *stats = &dev->stats;\n\tu32 rx_left, cur_rx = tp->cur_rx;\n\tu32 delta, count;\n\n\trx_left = NUM_RX_DESC + tp->dirty_rx - cur_rx;\n\trx_left = sis190_rx_quota(rx_left, (u32) dev->quota);\n\n\tfor (; rx_left > 0; rx_left--, cur_rx++) {\n\t\tunsigned int entry = cur_rx % NUM_RX_DESC;\n\t\tstruct RxDesc *desc = tp->RxDescRing + entry;\n\t\tu32 status;\n\n\t\tif (le32_to_cpu(desc->status) & OWNbit)\n\t\t\tbreak;\n\n\t\tstatus = le32_to_cpu(desc->PSize);\n\n\t\t \n\n\t\tif (sis190_rx_pkt_err(status, stats) < 0)\n\t\t\tsis190_give_to_asic(desc, tp->rx_buf_sz);\n\t\telse {\n\t\t\tstruct sk_buff *skb = tp->Rx_skbuff[entry];\n\t\t\tdma_addr_t addr = le32_to_cpu(desc->addr);\n\t\t\tint pkt_size = (status & RxSizeMask) - 4;\n\t\t\tstruct pci_dev *pdev = tp->pci_dev;\n\n\t\t\tif (unlikely(pkt_size > tp->rx_buf_sz)) {\n\t\t\t\tnetif_info(tp, intr, dev,\n\t\t\t\t\t   \"(frag) status = %08x\\n\", status);\n\t\t\t\tstats->rx_dropped++;\n\t\t\t\tstats->rx_length_errors++;\n\t\t\t\tsis190_give_to_asic(desc, tp->rx_buf_sz);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\n\t\t\tif (sis190_try_rx_copy(tp, &skb, pkt_size, addr)) {\n\t\t\t\tdma_sync_single_for_device(&pdev->dev, addr,\n\t\t\t\t\t\t\t   tp->rx_buf_sz,\n\t\t\t\t\t\t\t   DMA_FROM_DEVICE);\n\t\t\t\tsis190_give_to_asic(desc, tp->rx_buf_sz);\n\t\t\t} else {\n\t\t\t\tdma_unmap_single(&pdev->dev, addr,\n\t\t\t\t\t\t tp->rx_buf_sz,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\t\ttp->Rx_skbuff[entry] = NULL;\n\t\t\t\tsis190_make_unusable_by_asic(desc);\n\t\t\t}\n\n\t\t\tskb_put(skb, pkt_size);\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\n\t\t\tsis190_rx_skb(skb);\n\n\t\t\tstats->rx_packets++;\n\t\t\tstats->rx_bytes += pkt_size;\n\t\t\tif ((status & BCAST) == MCAST)\n\t\t\t\tstats->multicast++;\n\t\t}\n\t}\n\tcount = cur_rx - tp->cur_rx;\n\ttp->cur_rx = cur_rx;\n\n\tdelta = sis190_rx_fill(tp, dev, tp->dirty_rx, tp->cur_rx);\n\tif (!delta && count)\n\t\tnetif_info(tp, intr, dev, \"no Rx buffer allocated\\n\");\n\ttp->dirty_rx += delta;\n\n\tif ((tp->dirty_rx + NUM_RX_DESC) == tp->cur_rx)\n\t\tnetif_emerg(tp, intr, dev, \"Rx buffers exhausted\\n\");\n\n\treturn count;\n}\n\nstatic void sis190_unmap_tx_skb(struct pci_dev *pdev, struct sk_buff *skb,\n\t\t\t\tstruct TxDesc *desc)\n{\n\tunsigned int len;\n\n\tlen = skb->len < ETH_ZLEN ? ETH_ZLEN : skb->len;\n\n\tdma_unmap_single(&pdev->dev, le32_to_cpu(desc->addr), len,\n\t\t\t DMA_TO_DEVICE);\n\n\tmemset(desc, 0x00, sizeof(*desc));\n}\n\nstatic inline int sis190_tx_pkt_err(u32 status, struct net_device_stats *stats)\n{\n#define TxErrMask\t(WND | TABRT | FIFO | LINK)\n\n\tif (!unlikely(status & TxErrMask))\n\t\treturn 0;\n\n\tif (status & WND)\n\t\tstats->tx_window_errors++;\n\tif (status & TABRT)\n\t\tstats->tx_aborted_errors++;\n\tif (status & FIFO)\n\t\tstats->tx_fifo_errors++;\n\tif (status & LINK)\n\t\tstats->tx_carrier_errors++;\n\n\tstats->tx_errors++;\n\n\treturn -1;\n}\n\nstatic void sis190_tx_interrupt(struct net_device *dev,\n\t\t\t\tstruct sis190_private *tp, void __iomem *ioaddr)\n{\n\tstruct net_device_stats *stats = &dev->stats;\n\tu32 pending, dirty_tx = tp->dirty_tx;\n\t \n\tunsigned int queue_stopped;\n\n\tsmp_rmb();\n\tpending = tp->cur_tx - dirty_tx;\n\tqueue_stopped = (pending == NUM_TX_DESC);\n\n\tfor (; pending; pending--, dirty_tx++) {\n\t\tunsigned int entry = dirty_tx % NUM_TX_DESC;\n\t\tstruct TxDesc *txd = tp->TxDescRing + entry;\n\t\tu32 status = le32_to_cpu(txd->status);\n\t\tstruct sk_buff *skb;\n\n\t\tif (status & OWNbit)\n\t\t\tbreak;\n\n\t\tskb = tp->Tx_skbuff[entry];\n\n\t\tif (likely(sis190_tx_pkt_err(status, stats) == 0)) {\n\t\t\tstats->tx_packets++;\n\t\t\tstats->tx_bytes += skb->len;\n\t\t\tstats->collisions += ((status & ColCountMask) - 1);\n\t\t}\n\n\t\tsis190_unmap_tx_skb(tp->pci_dev, skb, txd);\n\t\ttp->Tx_skbuff[entry] = NULL;\n\t\tdev_consume_skb_irq(skb);\n\t}\n\n\tif (tp->dirty_tx != dirty_tx) {\n\t\ttp->dirty_tx = dirty_tx;\n\t\tsmp_wmb();\n\t\tif (queue_stopped)\n\t\t\tnetif_wake_queue(dev);\n\t}\n}\n\n \nstatic irqreturn_t sis190_irq(int irq, void *__dev)\n{\n\tstruct net_device *dev = __dev;\n\tstruct sis190_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tunsigned int handled = 0;\n\tu32 status;\n\n\tstatus = SIS_R32(IntrStatus);\n\n\tif ((status == 0xffffffff) || !status)\n\t\tgoto out;\n\n\thandled = 1;\n\n\tif (unlikely(!netif_running(dev))) {\n\t\tsis190_asic_down(ioaddr);\n\t\tgoto out;\n\t}\n\n\tSIS_W32(IntrStatus, status);\n\n \n\n\tif (status & LinkChange) {\n\t\tnetif_info(tp, intr, dev, \"link change\\n\");\n\t\tdel_timer(&tp->timer);\n\t\tschedule_work(&tp->phy_task);\n\t}\n\n\tif (status & RxQInt)\n\t\tsis190_rx_interrupt(dev, tp, ioaddr);\n\n\tif (status & TxQ0Int)\n\t\tsis190_tx_interrupt(dev, tp, ioaddr);\nout:\n\treturn IRQ_RETVAL(handled);\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void sis190_netpoll(struct net_device *dev)\n{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\tconst int irq = tp->pci_dev->irq;\n\n\tdisable_irq(irq);\n\tsis190_irq(irq, dev);\n\tenable_irq(irq);\n}\n#endif\n\nstatic void sis190_free_rx_skb(struct sis190_private *tp,\n\t\t\t       struct sk_buff **sk_buff, struct RxDesc *desc)\n{\n\tstruct pci_dev *pdev = tp->pci_dev;\n\n\tdma_unmap_single(&pdev->dev, le32_to_cpu(desc->addr), tp->rx_buf_sz,\n\t\t\t DMA_FROM_DEVICE);\n\tdev_kfree_skb(*sk_buff);\n\t*sk_buff = NULL;\n\tsis190_make_unusable_by_asic(desc);\n}\n\nstatic void sis190_rx_clear(struct sis190_private *tp)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < NUM_RX_DESC; i++) {\n\t\tif (!tp->Rx_skbuff[i])\n\t\t\tcontinue;\n\t\tsis190_free_rx_skb(tp, tp->Rx_skbuff + i, tp->RxDescRing + i);\n\t}\n}\n\nstatic void sis190_init_ring_indexes(struct sis190_private *tp)\n{\n\ttp->dirty_tx = tp->dirty_rx = tp->cur_tx = tp->cur_rx = 0;\n}\n\nstatic int sis190_init_ring(struct net_device *dev)\n{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\n\tsis190_init_ring_indexes(tp);\n\n\tmemset(tp->Tx_skbuff, 0x0, NUM_TX_DESC * sizeof(struct sk_buff *));\n\tmemset(tp->Rx_skbuff, 0x0, NUM_RX_DESC * sizeof(struct sk_buff *));\n\n\tif (sis190_rx_fill(tp, dev, 0, NUM_RX_DESC) != NUM_RX_DESC)\n\t\tgoto err_rx_clear;\n\n\tsis190_mark_as_last_descriptor(tp->RxDescRing + NUM_RX_DESC - 1);\n\n\treturn 0;\n\nerr_rx_clear:\n\tsis190_rx_clear(tp);\n\treturn -ENOMEM;\n}\n\nstatic void sis190_set_rx_mode(struct net_device *dev)\n{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tunsigned long flags;\n\tu32 mc_filter[2];\t \n\tu16 rx_mode;\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\trx_mode =\n\t\t\tAcceptBroadcast | AcceptMulticast | AcceptMyPhys |\n\t\t\tAcceptAllPhys;\n\t\tmc_filter[1] = mc_filter[0] = 0xffffffff;\n\t} else if ((netdev_mc_count(dev) > multicast_filter_limit) ||\n\t\t   (dev->flags & IFF_ALLMULTI)) {\n\t\t \n\t\trx_mode = AcceptBroadcast | AcceptMulticast | AcceptMyPhys;\n\t\tmc_filter[1] = mc_filter[0] = 0xffffffff;\n\t} else {\n\t\tstruct netdev_hw_addr *ha;\n\n\t\trx_mode = AcceptBroadcast | AcceptMyPhys;\n\t\tmc_filter[1] = mc_filter[0] = 0;\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tint bit_nr =\n\t\t\t\tether_crc(ETH_ALEN, ha->addr) & 0x3f;\n\t\t\tmc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);\n\t\t\trx_mode |= AcceptMulticast;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&tp->lock, flags);\n\n\tSIS_W16(RxMacControl, rx_mode | 0x2);\n\tSIS_W32(RxHashTable, mc_filter[0]);\n\tSIS_W32(RxHashTable + 4, mc_filter[1]);\n\n\tspin_unlock_irqrestore(&tp->lock, flags);\n}\n\nstatic void sis190_soft_reset(void __iomem *ioaddr)\n{\n\tSIS_W32(IntrControl, 0x8000);\n\tSIS_PCI_COMMIT();\n\tSIS_W32(IntrControl, 0x0);\n\tsis190_asic_down(ioaddr);\n}\n\nstatic void sis190_hw_start(struct net_device *dev)\n{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\n\tsis190_soft_reset(ioaddr);\n\n\tSIS_W32(TxDescStartAddr, tp->tx_dma);\n\tSIS_W32(RxDescStartAddr, tp->rx_dma);\n\n\tSIS_W32(IntrStatus, 0xffffffff);\n\tSIS_W32(IntrMask, 0x0);\n\tSIS_W32(GMIIControl, 0x0);\n\tSIS_W32(TxMacControl, 0x60);\n\tSIS_W16(RxMacControl, 0x02);\n\tSIS_W32(RxHashTable, 0x0);\n\tSIS_W32(0x6c, 0x0);\n\tSIS_W32(RxWolCtrl, 0x0);\n\tSIS_W32(RxWolData, 0x0);\n\n\tSIS_PCI_COMMIT();\n\n\tsis190_set_rx_mode(dev);\n\n\t \n\tSIS_W32(IntrMask, sis190_intr_mask);\n\n\tSIS_W32(TxControl, 0x1a00 | CmdTxEnb);\n\tSIS_W32(RxControl, 0x1a1d);\n\n\tnetif_start_queue(dev);\n}\n\nstatic void sis190_phy_task(struct work_struct *work)\n{\n\tstruct sis190_private *tp =\n\t\tcontainer_of(work, struct sis190_private, phy_task);\n\tstruct net_device *dev = tp->dev;\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tint phy_id = tp->mii_if.phy_id;\n\tu16 val;\n\n\trtnl_lock();\n\n\tif (!netif_running(dev))\n\t\tgoto out_unlock;\n\n\tval = mdio_read(ioaddr, phy_id, MII_BMCR);\n\tif (val & BMCR_RESET) {\n\t\t \n\t\tmod_timer(&tp->timer, jiffies + HZ/10);\n\t\tgoto out_unlock;\n\t}\n\n\tval = mdio_read_latched(ioaddr, phy_id, MII_BMSR);\n\tif (!(val & BMSR_ANEGCOMPLETE) && tp->link_status != LNK_AUTONEG) {\n\t\tnetif_carrier_off(dev);\n\t\tnetif_warn(tp, link, dev, \"auto-negotiating...\\n\");\n\t\ttp->link_status = LNK_AUTONEG;\n\t} else if ((val & BMSR_LSTATUS) && tp->link_status != LNK_ON) {\n\t\t \n\t\tstruct {\n\t\t\tint val;\n\t\t\tu32 ctl;\n\t\t\tconst char *msg;\n\t\t} reg31[] = {\n\t\t\t{ LPA_1000FULL, 0x07000c00 | 0x00001000,\n\t\t\t\t\"1000 Mbps Full Duplex\" },\n\t\t\t{ LPA_1000HALF, 0x07000c00,\n\t\t\t\t\"1000 Mbps Half Duplex\" },\n\t\t\t{ LPA_100FULL, 0x04000800 | 0x00001000,\n\t\t\t\t\"100 Mbps Full Duplex\" },\n\t\t\t{ LPA_100HALF, 0x04000800,\n\t\t\t\t\"100 Mbps Half Duplex\" },\n\t\t\t{ LPA_10FULL, 0x04000400 | 0x00001000,\n\t\t\t\t\"10 Mbps Full Duplex\" },\n\t\t\t{ LPA_10HALF, 0x04000400,\n\t\t\t\t\"10 Mbps Half Duplex\" },\n\t\t\t{ 0, 0x04000400, \"unknown\" }\n\t\t}, *p = NULL;\n\t\tu16 adv, autoexp, gigadv, gigrec;\n\n\t\tval = mdio_read(ioaddr, phy_id, 0x1f);\n\t\tnetif_info(tp, link, dev, \"mii ext = %04x\\n\", val);\n\n\t\tval = mdio_read(ioaddr, phy_id, MII_LPA);\n\t\tadv = mdio_read(ioaddr, phy_id, MII_ADVERTISE);\n\t\tautoexp = mdio_read(ioaddr, phy_id, MII_EXPANSION);\n\t\tnetif_info(tp, link, dev, \"mii lpa=%04x adv=%04x exp=%04x\\n\",\n\t\t\t   val, adv, autoexp);\n\n\t\tif (val & LPA_NPAGE && autoexp & EXPANSION_NWAY) {\n\t\t\t \n\t\t\tgigadv = mdio_read(ioaddr, phy_id, MII_CTRL1000);\n\t\t\tgigrec = mdio_read(ioaddr, phy_id, MII_STAT1000);\n\t\t\tval = (gigadv & (gigrec >> 2));\n\t\t\tif (val & ADVERTISE_1000FULL)\n\t\t\t\tp = reg31;\n\t\t\telse if (val & ADVERTISE_1000HALF)\n\t\t\t\tp = reg31 + 1;\n\t\t}\n\t\tif (!p) {\n\t\t\tval &= adv;\n\n\t\t\tfor (p = reg31; p->val; p++) {\n\t\t\t\tif ((val & p->val) == p->val)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tp->ctl |= SIS_R32(StationControl) & ~0x0f001c00;\n\n\t\tif ((tp->features & F_HAS_RGMII) &&\n\t\t    (tp->features & F_PHY_BCM5461)) {\n\t\t\t \n\t\t\tmdio_write(ioaddr, phy_id, 0x18, 0xf1c7);\n\t\t\tudelay(200);\n\t\t\tmdio_write(ioaddr, phy_id, 0x1c, 0x8c00);\n\t\t\tp->ctl |= 0x03000000;\n\t\t}\n\n\t\tSIS_W32(StationControl, p->ctl);\n\n\t\tif (tp->features & F_HAS_RGMII) {\n\t\t\tSIS_W32(RGDelay, 0x0441);\n\t\t\tSIS_W32(RGDelay, 0x0440);\n\t\t}\n\n\t\ttp->negotiated_lpa = p->val;\n\n\t\tnetif_info(tp, link, dev, \"link on %s mode\\n\", p->msg);\n\t\tnetif_carrier_on(dev);\n\t\ttp->link_status = LNK_ON;\n\t} else if (!(val & BMSR_LSTATUS) && tp->link_status != LNK_AUTONEG)\n\t\ttp->link_status = LNK_OFF;\n\tmod_timer(&tp->timer, jiffies + SIS190_PHY_TIMEOUT);\n\nout_unlock:\n\trtnl_unlock();\n}\n\nstatic void sis190_phy_timer(struct timer_list *t)\n{\n\tstruct sis190_private *tp = from_timer(tp, t, timer);\n\tstruct net_device *dev = tp->dev;\n\n\tif (likely(netif_running(dev)))\n\t\tschedule_work(&tp->phy_task);\n}\n\nstatic inline void sis190_delete_timer(struct net_device *dev)\n{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\n\tdel_timer_sync(&tp->timer);\n}\n\nstatic inline void sis190_request_timer(struct net_device *dev)\n{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\tstruct timer_list *timer = &tp->timer;\n\n\ttimer_setup(timer, sis190_phy_timer, 0);\n\ttimer->expires = jiffies + SIS190_PHY_TIMEOUT;\n\tadd_timer(timer);\n}\n\nstatic void sis190_set_rxbufsize(struct sis190_private *tp,\n\t\t\t\t struct net_device *dev)\n{\n\tunsigned int mtu = dev->mtu;\n\n\ttp->rx_buf_sz = (mtu > RX_BUF_SIZE) ? mtu + ETH_HLEN + 8 : RX_BUF_SIZE;\n\t \n\tif (tp->rx_buf_sz & 0x07) {\n\t\ttp->rx_buf_sz += 8;\n\t\ttp->rx_buf_sz &= RX_BUF_MASK;\n\t}\n}\n\nstatic int sis190_open(struct net_device *dev)\n{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\tstruct pci_dev *pdev = tp->pci_dev;\n\tint rc = -ENOMEM;\n\n\tsis190_set_rxbufsize(tp, dev);\n\n\t \n\ttp->TxDescRing = dma_alloc_coherent(&pdev->dev, TX_RING_BYTES,\n\t\t\t\t\t    &tp->tx_dma, GFP_KERNEL);\n\tif (!tp->TxDescRing)\n\t\tgoto out;\n\n\ttp->RxDescRing = dma_alloc_coherent(&pdev->dev, RX_RING_BYTES,\n\t\t\t\t\t    &tp->rx_dma, GFP_KERNEL);\n\tif (!tp->RxDescRing)\n\t\tgoto err_free_tx_0;\n\n\trc = sis190_init_ring(dev);\n\tif (rc < 0)\n\t\tgoto err_free_rx_1;\n\n\tsis190_request_timer(dev);\n\n\trc = request_irq(pdev->irq, sis190_irq, IRQF_SHARED, dev->name, dev);\n\tif (rc < 0)\n\t\tgoto err_release_timer_2;\n\n\tsis190_hw_start(dev);\nout:\n\treturn rc;\n\nerr_release_timer_2:\n\tsis190_delete_timer(dev);\n\tsis190_rx_clear(tp);\nerr_free_rx_1:\n\tdma_free_coherent(&pdev->dev, RX_RING_BYTES, tp->RxDescRing,\n\t\t\t  tp->rx_dma);\nerr_free_tx_0:\n\tdma_free_coherent(&pdev->dev, TX_RING_BYTES, tp->TxDescRing,\n\t\t\t  tp->tx_dma);\n\tgoto out;\n}\n\nstatic void sis190_tx_clear(struct sis190_private *tp)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < NUM_TX_DESC; i++) {\n\t\tstruct sk_buff *skb = tp->Tx_skbuff[i];\n\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\tsis190_unmap_tx_skb(tp->pci_dev, skb, tp->TxDescRing + i);\n\t\ttp->Tx_skbuff[i] = NULL;\n\t\tdev_kfree_skb(skb);\n\n\t\ttp->dev->stats.tx_dropped++;\n\t}\n\ttp->cur_tx = tp->dirty_tx = 0;\n}\n\nstatic void sis190_down(struct net_device *dev)\n{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tunsigned int poll_locked = 0;\n\n\tsis190_delete_timer(dev);\n\n\tnetif_stop_queue(dev);\n\n\tdo {\n\t\tspin_lock_irq(&tp->lock);\n\n\t\tsis190_asic_down(ioaddr);\n\n\t\tspin_unlock_irq(&tp->lock);\n\n\t\tsynchronize_irq(tp->pci_dev->irq);\n\n\t\tif (!poll_locked)\n\t\t\tpoll_locked++;\n\n\t\tsynchronize_rcu();\n\n\t} while (SIS_R32(IntrMask));\n\n\tsis190_tx_clear(tp);\n\tsis190_rx_clear(tp);\n}\n\nstatic int sis190_close(struct net_device *dev)\n{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\tstruct pci_dev *pdev = tp->pci_dev;\n\n\tsis190_down(dev);\n\n\tfree_irq(pdev->irq, dev);\n\n\tdma_free_coherent(&pdev->dev, TX_RING_BYTES, tp->TxDescRing,\n\t\t\t  tp->tx_dma);\n\tdma_free_coherent(&pdev->dev, RX_RING_BYTES, tp->RxDescRing,\n\t\t\t  tp->rx_dma);\n\n\ttp->TxDescRing = NULL;\n\ttp->RxDescRing = NULL;\n\n\treturn 0;\n}\n\nstatic netdev_tx_t sis190_start_xmit(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev)\n{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tu32 len, entry, dirty_tx;\n\tstruct TxDesc *desc;\n\tdma_addr_t mapping;\n\n\tif (unlikely(skb->len < ETH_ZLEN)) {\n\t\tif (skb_padto(skb, ETH_ZLEN)) {\n\t\t\tdev->stats.tx_dropped++;\n\t\t\tgoto out;\n\t\t}\n\t\tlen = ETH_ZLEN;\n\t} else {\n\t\tlen = skb->len;\n\t}\n\n\tentry = tp->cur_tx % NUM_TX_DESC;\n\tdesc = tp->TxDescRing + entry;\n\n\tif (unlikely(le32_to_cpu(desc->status) & OWNbit)) {\n\t\tnetif_stop_queue(dev);\n\t\tnetif_err(tp, tx_err, dev,\n\t\t\t  \"BUG! Tx Ring full when queue awake!\\n\");\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tmapping = dma_map_single(&tp->pci_dev->dev, skb->data, len,\n\t\t\t\t DMA_TO_DEVICE);\n\tif (dma_mapping_error(&tp->pci_dev->dev, mapping)) {\n\t\tnetif_err(tp, tx_err, dev,\n\t\t\t\t\"PCI mapping failed, dropping packet\");\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\ttp->Tx_skbuff[entry] = skb;\n\n\tdesc->PSize = cpu_to_le32(len);\n\tdesc->addr = cpu_to_le32(mapping);\n\n\tdesc->size = cpu_to_le32(len);\n\tif (entry == (NUM_TX_DESC - 1))\n\t\tdesc->size |= cpu_to_le32(RingEnd);\n\n\twmb();\n\n\tdesc->status = cpu_to_le32(OWNbit | INTbit | DEFbit | CRCbit | PADbit);\n\tif (tp->negotiated_lpa & (LPA_1000HALF | LPA_100HALF | LPA_10HALF)) {\n\t\t \n\t\tdesc->status |= cpu_to_le32(COLEN | CRSEN | BKFEN);\n\t\tif (tp->negotiated_lpa & (LPA_1000HALF | LPA_1000FULL))\n\t\t\tdesc->status |= cpu_to_le32(EXTEN | BSTEN);  \n\t}\n\n\ttp->cur_tx++;\n\n\tsmp_wmb();\n\n\tSIS_W32(TxControl, 0x1a00 | CmdReset | CmdTxEnb);\n\n\tdirty_tx = tp->dirty_tx;\n\tif ((tp->cur_tx - NUM_TX_DESC) == dirty_tx) {\n\t\tnetif_stop_queue(dev);\n\t\tsmp_rmb();\n\t\tif (dirty_tx != tp->dirty_tx)\n\t\t\tnetif_wake_queue(dev);\n\t}\nout:\n\treturn NETDEV_TX_OK;\n}\n\nstatic void sis190_free_phy(struct list_head *first_phy)\n{\n\tstruct sis190_phy *cur, *next;\n\n\tlist_for_each_entry_safe(cur, next, first_phy, list) {\n\t\tkfree(cur);\n\t}\n}\n\n \nstatic u16 sis190_default_phy(struct net_device *dev)\n{\n\tstruct sis190_phy *phy, *phy_home, *phy_default, *phy_lan;\n\tstruct sis190_private *tp = netdev_priv(dev);\n\tstruct mii_if_info *mii_if = &tp->mii_if;\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tu16 status;\n\n\tphy_home = phy_default = phy_lan = NULL;\n\n\tlist_for_each_entry(phy, &tp->first_phy, list) {\n\t\tstatus = mdio_read_latched(ioaddr, phy->phy_id, MII_BMSR);\n\n\t\t\n\t\tif ((status & BMSR_LSTATUS) &&\n\t\t    !phy_default &&\n\t\t    (phy->type != UNKNOWN)) {\n\t\t\tphy_default = phy;\n\t\t} else {\n\t\t\tstatus = mdio_read(ioaddr, phy->phy_id, MII_BMCR);\n\t\t\tmdio_write(ioaddr, phy->phy_id, MII_BMCR,\n\t\t\t\t   status | BMCR_ANENABLE | BMCR_ISOLATE);\n\t\t\tif (phy->type == HOME)\n\t\t\t\tphy_home = phy;\n\t\t\telse if (phy->type == LAN)\n\t\t\t\tphy_lan = phy;\n\t\t}\n\t}\n\n\tif (!phy_default) {\n\t\tif (phy_home)\n\t\t\tphy_default = phy_home;\n\t\telse if (phy_lan)\n\t\t\tphy_default = phy_lan;\n\t\telse\n\t\t\tphy_default = list_first_entry(&tp->first_phy,\n\t\t\t\t\t\t struct sis190_phy, list);\n\t}\n\n\tif (mii_if->phy_id != phy_default->phy_id) {\n\t\tmii_if->phy_id = phy_default->phy_id;\n\t\tif (netif_msg_probe(tp))\n\t\t\tpr_info(\"%s: Using transceiver at address %d as default\\n\",\n\t\t\t\tpci_name(tp->pci_dev), mii_if->phy_id);\n\t}\n\n\tstatus = mdio_read(ioaddr, mii_if->phy_id, MII_BMCR);\n\tstatus &= (~BMCR_ISOLATE);\n\n\tmdio_write(ioaddr, mii_if->phy_id, MII_BMCR, status);\n\tstatus = mdio_read_latched(ioaddr, mii_if->phy_id, MII_BMSR);\n\n\treturn status;\n}\n\nstatic void sis190_init_phy(struct net_device *dev, struct sis190_private *tp,\n\t\t\t    struct sis190_phy *phy, unsigned int phy_id,\n\t\t\t    u16 mii_status)\n{\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tstruct mii_chip_info *p;\n\n\tINIT_LIST_HEAD(&phy->list);\n\tphy->status = mii_status;\n\tphy->phy_id = phy_id;\n\n\tphy->id[0] = mdio_read(ioaddr, phy_id, MII_PHYSID1);\n\tphy->id[1] = mdio_read(ioaddr, phy_id, MII_PHYSID2);\n\n\tfor (p = mii_chip_table; p->type; p++) {\n\t\tif ((p->id[0] == phy->id[0]) &&\n\t\t    (p->id[1] == (phy->id[1] & 0xfff0))) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (p->id[1]) {\n\t\tphy->type = (p->type == MIX) ?\n\t\t\t((mii_status & (BMSR_100FULL | BMSR_100HALF)) ?\n\t\t\t\tLAN : HOME) : p->type;\n\t\ttp->features |= p->feature;\n\t\tif (netif_msg_probe(tp))\n\t\t\tpr_info(\"%s: %s transceiver at address %d\\n\",\n\t\t\t\tpci_name(tp->pci_dev), p->name, phy_id);\n\t} else {\n\t\tphy->type = UNKNOWN;\n\t\tif (netif_msg_probe(tp))\n\t\t\tpr_info(\"%s: unknown PHY 0x%x:0x%x transceiver at address %d\\n\",\n\t\t\t\tpci_name(tp->pci_dev),\n\t\t\t\tphy->id[0], (phy->id[1] & 0xfff0), phy_id);\n\t}\n}\n\nstatic void sis190_mii_probe_88e1111_fixup(struct sis190_private *tp)\n{\n\tif (tp->features & F_PHY_88E1111) {\n\t\tvoid __iomem *ioaddr = tp->mmio_addr;\n\t\tint phy_id = tp->mii_if.phy_id;\n\t\tu16 reg[2][2] = {\n\t\t\t{ 0x808b, 0x0ce1 },\n\t\t\t{ 0x808f, 0x0c60 }\n\t\t}, *p;\n\n\t\tp = (tp->features & F_HAS_RGMII) ? reg[0] : reg[1];\n\n\t\tmdio_write(ioaddr, phy_id, 0x1b, p[0]);\n\t\tudelay(200);\n\t\tmdio_write(ioaddr, phy_id, 0x14, p[1]);\n\t\tudelay(200);\n\t}\n}\n\n \nstatic int sis190_mii_probe(struct net_device *dev)\n{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\tstruct mii_if_info *mii_if = &tp->mii_if;\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tint phy_id;\n\tint rc = 0;\n\n\tINIT_LIST_HEAD(&tp->first_phy);\n\n\tfor (phy_id = 0; phy_id < PHY_MAX_ADDR; phy_id++) {\n\t\tstruct sis190_phy *phy;\n\t\tu16 status;\n\n\t\tstatus = mdio_read_latched(ioaddr, phy_id, MII_BMSR);\n\n\t\t\n\t\tif (status == 0xffff || status == 0x0000)\n\t\t\tcontinue;\n\n\t\tphy = kmalloc(sizeof(*phy), GFP_KERNEL);\n\t\tif (!phy) {\n\t\t\tsis190_free_phy(&tp->first_phy);\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsis190_init_phy(dev, tp, phy, phy_id, status);\n\n\t\tlist_add(&tp->first_phy, &phy->list);\n\t}\n\n\tif (list_empty(&tp->first_phy)) {\n\t\tif (netif_msg_probe(tp))\n\t\t\tpr_info(\"%s: No MII transceivers found!\\n\",\n\t\t\t\tpci_name(tp->pci_dev));\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tsis190_default_phy(dev);\n\n\tsis190_mii_probe_88e1111_fixup(tp);\n\n\tmii_if->dev = dev;\n\tmii_if->mdio_read = __mdio_read;\n\tmii_if->mdio_write = __mdio_write;\n\tmii_if->phy_id_mask = PHY_ID_ANY;\n\tmii_if->reg_num_mask = MII_REG_ANY;\nout:\n\treturn rc;\n}\n\nstatic void sis190_mii_remove(struct net_device *dev)\n{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\n\tsis190_free_phy(&tp->first_phy);\n}\n\nstatic void sis190_release_board(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct sis190_private *tp = netdev_priv(dev);\n\n\tiounmap(tp->mmio_addr);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tfree_netdev(dev);\n}\n\nstatic struct net_device *sis190_init_board(struct pci_dev *pdev)\n{\n\tstruct sis190_private *tp;\n\tstruct net_device *dev;\n\tvoid __iomem *ioaddr;\n\tint rc;\n\n\tdev = alloc_etherdev(sizeof(*tp));\n\tif (!dev) {\n\t\trc = -ENOMEM;\n\t\tgoto err_out_0;\n\t}\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\ttp = netdev_priv(dev);\n\ttp->dev = dev;\n\ttp->msg_enable = netif_msg_init(debug.msg_enable, SIS190_MSG_DEFAULT);\n\n\trc = pci_enable_device(pdev);\n\tif (rc < 0) {\n\t\tif (netif_msg_probe(tp))\n\t\t\tpr_err(\"%s: enable failure\\n\", pci_name(pdev));\n\t\tgoto err_free_dev_1;\n\t}\n\n\trc = -ENODEV;\n\n\tif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {\n\t\tif (netif_msg_probe(tp))\n\t\t\tpr_err(\"%s: region #0 is no MMIO resource\\n\",\n\t\t\t       pci_name(pdev));\n\t\tgoto err_pci_disable_2;\n\t}\n\tif (pci_resource_len(pdev, 0) < SIS190_REGS_SIZE) {\n\t\tif (netif_msg_probe(tp))\n\t\t\tpr_err(\"%s: invalid PCI region size(s)\\n\",\n\t\t\t       pci_name(pdev));\n\t\tgoto err_pci_disable_2;\n\t}\n\n\trc = pci_request_regions(pdev, DRV_NAME);\n\tif (rc < 0) {\n\t\tif (netif_msg_probe(tp))\n\t\t\tpr_err(\"%s: could not request regions\\n\",\n\t\t\t       pci_name(pdev));\n\t\tgoto err_pci_disable_2;\n\t}\n\n\trc = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (rc < 0) {\n\t\tif (netif_msg_probe(tp))\n\t\t\tpr_err(\"%s: DMA configuration failed\\n\",\n\t\t\t       pci_name(pdev));\n\t\tgoto err_free_res_3;\n\t}\n\n\tpci_set_master(pdev);\n\n\tioaddr = ioremap(pci_resource_start(pdev, 0), SIS190_REGS_SIZE);\n\tif (!ioaddr) {\n\t\tif (netif_msg_probe(tp))\n\t\t\tpr_err(\"%s: cannot remap MMIO, aborting\\n\",\n\t\t\t       pci_name(pdev));\n\t\trc = -EIO;\n\t\tgoto err_free_res_3;\n\t}\n\n\ttp->pci_dev = pdev;\n\ttp->mmio_addr = ioaddr;\n\ttp->link_status = LNK_OFF;\n\n\tsis190_irq_mask_and_ack(ioaddr);\n\n\tsis190_soft_reset(ioaddr);\nout:\n\treturn dev;\n\nerr_free_res_3:\n\tpci_release_regions(pdev);\nerr_pci_disable_2:\n\tpci_disable_device(pdev);\nerr_free_dev_1:\n\tfree_netdev(dev);\nerr_out_0:\n\tdev = ERR_PTR(rc);\n\tgoto out;\n}\n\nstatic void sis190_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tu8 tmp8;\n\n\t \n\ttmp8 = SIS_R8(TxControl);\n\tif (tmp8 & CmdTxEnb)\n\t\tSIS_W8(TxControl, tmp8 & ~CmdTxEnb);\n\n\tnetif_info(tp, tx_err, dev, \"Transmit timeout, status %08x %08x\\n\",\n\t\t   SIS_R32(TxControl), SIS_R32(TxSts));\n\n\t \n\tSIS_W32(IntrMask, 0x0000);\n\n\t \n\tspin_lock_irq(&tp->lock);\n\tsis190_tx_clear(tp);\n\tspin_unlock_irq(&tp->lock);\n\n\t \n\tsis190_hw_start(dev);\n\n\tnetif_wake_queue(dev);\n}\n\nstatic void sis190_set_rgmii(struct sis190_private *tp, u8 reg)\n{\n\ttp->features |= (reg & 0x80) ? F_HAS_RGMII : 0;\n}\n\nstatic int sis190_get_mac_addr_from_eeprom(struct pci_dev *pdev,\n\t\t\t\t\t   struct net_device *dev)\n{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\t__le16 addr[ETH_ALEN / 2];\n\tu16 sig;\n\tint i;\n\n\tif (netif_msg_probe(tp))\n\t\tpr_info(\"%s: Read MAC address from EEPROM\\n\", pci_name(pdev));\n\n\t \n\tsig = (u16) sis190_read_eeprom(ioaddr, EEPROMSignature);\n\n\tif ((sig == 0xffff) || (sig == 0x0000)) {\n\t\tif (netif_msg_probe(tp))\n\t\t\tpr_info(\"%s: Error EEPROM read %x\\n\",\n\t\t\t\tpci_name(pdev), sig);\n\t\treturn -EIO;\n\t}\n\n\t \n\tfor (i = 0; i < ETH_ALEN / 2; i++) {\n\t\tu16 w = sis190_read_eeprom(ioaddr, EEPROMMACAddr + i);\n\n\t\taddr[i] = cpu_to_le16(w);\n\t}\n\teth_hw_addr_set(dev, (u8 *)addr);\n\n\tsis190_set_rgmii(tp, sis190_read_eeprom(ioaddr, EEPROMInfo));\n\n\treturn 0;\n}\n\n \nstatic int sis190_get_mac_addr_from_apc(struct pci_dev *pdev,\n\t\t\t\t\tstruct net_device *dev)\n{\n\tstatic const u16 ids[] = { 0x0965, 0x0966, 0x0968 };\n\tstruct sis190_private *tp = netdev_priv(dev);\n\tstruct pci_dev *isa_bridge;\n\tu8 addr[ETH_ALEN];\n\tu8 reg, tmp8;\n\tunsigned int i;\n\n\tif (netif_msg_probe(tp))\n\t\tpr_info(\"%s: Read MAC address from APC\\n\", pci_name(pdev));\n\n\tfor (i = 0; i < ARRAY_SIZE(ids); i++) {\n\t\tisa_bridge = pci_get_device(PCI_VENDOR_ID_SI, ids[i], NULL);\n\t\tif (isa_bridge)\n\t\t\tbreak;\n\t}\n\n\tif (!isa_bridge) {\n\t\tif (netif_msg_probe(tp))\n\t\t\tpr_info(\"%s: Can not find ISA bridge\\n\",\n\t\t\t\tpci_name(pdev));\n\t\treturn -EIO;\n\t}\n\n\t \n\tpci_read_config_byte(isa_bridge, 0x48, &tmp8);\n\treg = (tmp8 & ~0x02);\n\tpci_write_config_byte(isa_bridge, 0x48, reg);\n\tudelay(50);\n\tpci_read_config_byte(isa_bridge, 0x48, &reg);\n\n        for (i = 0; i < ETH_ALEN; i++) {\n                outb(0x9 + i, 0x78);\n                addr[i] = inb(0x79);\n        }\n\teth_hw_addr_set(dev, addr);\n\n\toutb(0x12, 0x78);\n\treg = inb(0x79);\n\n\tsis190_set_rgmii(tp, reg);\n\n\t \n\tpci_write_config_byte(isa_bridge, 0x48, tmp8);\n\tpci_dev_put(isa_bridge);\n\n\treturn 0;\n}\n\n \nstatic inline void sis190_init_rxfilter(struct net_device *dev)\n{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tu16 ctl;\n\tint i;\n\n\tctl = SIS_R16(RxMacControl);\n\t \n\tSIS_W16(RxMacControl, ctl & ~0x0f00);\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tSIS_W8(RxMacAddr + i, dev->dev_addr[i]);\n\n\tSIS_W16(RxMacControl, ctl);\n\tSIS_PCI_COMMIT();\n}\n\nstatic int sis190_get_mac_addr(struct pci_dev *pdev, struct net_device *dev)\n{\n\tint rc;\n\n\trc = sis190_get_mac_addr_from_eeprom(pdev, dev);\n\tif (rc < 0) {\n\t\tu8 reg;\n\n\t\tpci_read_config_byte(pdev, 0x73, &reg);\n\n\t\tif (reg & 0x00000001)\n\t\t\trc = sis190_get_mac_addr_from_apc(pdev, dev);\n\t}\n\treturn rc;\n}\n\nstatic void sis190_set_speed_auto(struct net_device *dev)\n{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\tvoid __iomem *ioaddr = tp->mmio_addr;\n\tint phy_id = tp->mii_if.phy_id;\n\tint val;\n\n\tnetif_info(tp, link, dev, \"Enabling Auto-negotiation\\n\");\n\n\tval = mdio_read(ioaddr, phy_id, MII_ADVERTISE);\n\n\t\n\t\n\tmdio_write(ioaddr, phy_id, MII_ADVERTISE, (val & ADVERTISE_SLCT) |\n\t\t   ADVERTISE_100FULL | ADVERTISE_10FULL |\n\t\t   ADVERTISE_100HALF | ADVERTISE_10HALF);\n\n\t\n\tmdio_write(ioaddr, phy_id, MII_CTRL1000, ADVERTISE_1000FULL);\n\n\t\n\tmdio_write(ioaddr, phy_id, MII_BMCR,\n\t\t   BMCR_ANENABLE | BMCR_ANRESTART | BMCR_RESET);\n}\n\nstatic int sis190_get_link_ksettings(struct net_device *dev,\n\t\t\t\t     struct ethtool_link_ksettings *cmd)\n{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\n\tmii_ethtool_get_link_ksettings(&tp->mii_if, cmd);\n\n\treturn 0;\n}\n\nstatic int sis190_set_link_ksettings(struct net_device *dev,\n\t\t\t\t     const struct ethtool_link_ksettings *cmd)\n{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\n\treturn mii_ethtool_set_link_ksettings(&tp->mii_if, cmd);\n}\n\nstatic void sis190_get_drvinfo(struct net_device *dev,\n\t\t\t       struct ethtool_drvinfo *info)\n{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n\tstrscpy(info->bus_info, pci_name(tp->pci_dev),\n\t\tsizeof(info->bus_info));\n}\n\nstatic int sis190_get_regs_len(struct net_device *dev)\n{\n\treturn SIS190_REGS_SIZE;\n}\n\nstatic void sis190_get_regs(struct net_device *dev, struct ethtool_regs *regs,\n\t\t\t    void *p)\n{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tp->lock, flags);\n\tmemcpy_fromio(p, tp->mmio_addr, regs->len);\n\tspin_unlock_irqrestore(&tp->lock, flags);\n}\n\nstatic int sis190_nway_reset(struct net_device *dev)\n{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\n\treturn mii_nway_restart(&tp->mii_if);\n}\n\nstatic u32 sis190_get_msglevel(struct net_device *dev)\n{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\n\treturn tp->msg_enable;\n}\n\nstatic void sis190_set_msglevel(struct net_device *dev, u32 value)\n{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\n\ttp->msg_enable = value;\n}\n\nstatic const struct ethtool_ops sis190_ethtool_ops = {\n\t.get_drvinfo\t= sis190_get_drvinfo,\n\t.get_regs_len\t= sis190_get_regs_len,\n\t.get_regs\t= sis190_get_regs,\n\t.get_link\t= ethtool_op_get_link,\n\t.get_msglevel\t= sis190_get_msglevel,\n\t.set_msglevel\t= sis190_set_msglevel,\n\t.nway_reset\t= sis190_nway_reset,\n\t.get_link_ksettings = sis190_get_link_ksettings,\n\t.set_link_ksettings = sis190_set_link_ksettings,\n};\n\nstatic int sis190_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct sis190_private *tp = netdev_priv(dev);\n\n\treturn !netif_running(dev) ? -EINVAL :\n\t\tgeneric_mii_ioctl(&tp->mii_if, if_mii(ifr), cmd, NULL);\n}\n\nstatic int sis190_mac_addr(struct net_device  *dev, void *p)\n{\n\tint rc;\n\n\trc = eth_mac_addr(dev, p);\n\tif (!rc)\n\t\tsis190_init_rxfilter(dev);\n\treturn rc;\n}\n\nstatic const struct net_device_ops sis190_netdev_ops = {\n\t.ndo_open\t\t= sis190_open,\n\t.ndo_stop\t\t= sis190_close,\n\t.ndo_eth_ioctl\t\t= sis190_ioctl,\n\t.ndo_start_xmit\t\t= sis190_start_xmit,\n\t.ndo_tx_timeout\t\t= sis190_tx_timeout,\n\t.ndo_set_rx_mode\t= sis190_set_rx_mode,\n\t.ndo_set_mac_address\t= sis190_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t = sis190_netpoll,\n#endif\n};\n\nstatic int sis190_init_one(struct pci_dev *pdev,\n\t\t\t   const struct pci_device_id *ent)\n{\n\tstatic int printed_version = 0;\n\tstruct sis190_private *tp;\n\tstruct net_device *dev;\n\tvoid __iomem *ioaddr;\n\tint rc;\n\n\tif (!printed_version) {\n\t\tif (netif_msg_drv(&debug))\n\t\t\tpr_info(SIS190_DRIVER_NAME \" loaded\\n\");\n\t\tprinted_version = 1;\n\t}\n\n\tdev = sis190_init_board(pdev);\n\tif (IS_ERR(dev)) {\n\t\trc = PTR_ERR(dev);\n\t\tgoto out;\n\t}\n\n\tpci_set_drvdata(pdev, dev);\n\n\ttp = netdev_priv(dev);\n\tioaddr = tp->mmio_addr;\n\n\trc = sis190_get_mac_addr(pdev, dev);\n\tif (rc < 0)\n\t\tgoto err_release_board;\n\n\tsis190_init_rxfilter(dev);\n\n\tINIT_WORK(&tp->phy_task, sis190_phy_task);\n\n\tdev->netdev_ops = &sis190_netdev_ops;\n\n\tdev->ethtool_ops = &sis190_ethtool_ops;\n\tdev->watchdog_timeo = SIS190_TX_TIMEOUT;\n\n\tspin_lock_init(&tp->lock);\n\n\trc = sis190_mii_probe(dev);\n\tif (rc < 0)\n\t\tgoto err_release_board;\n\n\trc = register_netdev(dev);\n\tif (rc < 0)\n\t\tgoto err_remove_mii;\n\n\tif (netif_msg_probe(tp)) {\n\t\tnetdev_info(dev, \"%s: %s at %p (IRQ: %d), %pM\\n\",\n\t\t\t    pci_name(pdev),\n\t\t\t    sis_chip_info[ent->driver_data].name,\n\t\t\t    ioaddr, pdev->irq, dev->dev_addr);\n\t\tnetdev_info(dev, \"%s mode.\\n\",\n\t\t\t    (tp->features & F_HAS_RGMII) ? \"RGMII\" : \"GMII\");\n\t}\n\n\tnetif_carrier_off(dev);\n\n\tsis190_set_speed_auto(dev);\nout:\n\treturn rc;\n\nerr_remove_mii:\n\tsis190_mii_remove(dev);\nerr_release_board:\n\tsis190_release_board(pdev);\n\tgoto out;\n}\n\nstatic void sis190_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct sis190_private *tp = netdev_priv(dev);\n\n\tsis190_mii_remove(dev);\n\tcancel_work_sync(&tp->phy_task);\n\tunregister_netdev(dev);\n\tsis190_release_board(pdev);\n}\n\nstatic struct pci_driver sis190_pci_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= sis190_pci_tbl,\n\t.probe\t\t= sis190_init_one,\n\t.remove\t\t= sis190_remove_one,\n};\n\nmodule_pci_driver(sis190_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}