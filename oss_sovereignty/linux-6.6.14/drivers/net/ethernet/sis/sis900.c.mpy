{
  "module_name": "sis900.c",
  "hash_id": "9713ecaaf834b9092c96e19d4f37dedc5424d0c68b2bec3c20203bc1f6301d78",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/sis/sis900.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/init.h>\n#include <linux/mii.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\n#include <linux/ethtool.h>\n#include <linux/crc32.h>\n#include <linux/bitops.h>\n#include <linux/dma-mapping.h>\n\n#include <asm/processor.h>       \n#include <asm/io.h>\n#include <asm/irq.h>\n#include <linux/uaccess.h>\t \n\n#include \"sis900.h\"\n\n#define SIS900_MODULE_NAME \"sis900\"\n#define SIS900_DRV_VERSION \"v1.08.10 Apr. 2 2006\"\n\nstatic const char version[] =\n\tKERN_INFO \"sis900.c: \" SIS900_DRV_VERSION \"\\n\";\n\nstatic int max_interrupt_work = 40;\nstatic int multicast_filter_limit = 128;\n\nstatic int sis900_debug = -1;  \n\n#define SIS900_DEF_MSG \\\n\t(NETIF_MSG_DRV\t\t| \\\n\t NETIF_MSG_LINK\t\t| \\\n\t NETIF_MSG_RX_ERR\t| \\\n\t NETIF_MSG_TX_ERR)\n\n \n#define TX_TIMEOUT  (4*HZ)\n\nenum {\n\tSIS_900 = 0,\n\tSIS_7016\n};\nstatic const char * card_names[] = {\n\t\"SiS 900 PCI Fast Ethernet\",\n\t\"SiS 7016 PCI Fast Ethernet\"\n};\n\nstatic const struct pci_device_id sis900_pci_tbl[] = {\n\t{PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_900,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, SIS_900},\n\t{PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_7016,\n\t PCI_ANY_ID, PCI_ANY_ID, 0, 0, SIS_7016},\n\t{0,}\n};\nMODULE_DEVICE_TABLE (pci, sis900_pci_tbl);\n\nstatic void sis900_read_mode(struct net_device *net_dev, int *speed, int *duplex);\n\nstatic const struct mii_chip_info {\n\tconst char * name;\n\tu16 phy_id0;\n\tu16 phy_id1;\n\tu8  phy_types;\n#define\tHOME \t0x0001\n#define LAN\t0x0002\n#define MIX\t0x0003\n#define UNKNOWN\t0x0\n} mii_chip_table[] = {\n\t{ \"SiS 900 Internal MII PHY\", \t\t0x001d, 0x8000, LAN },\n\t{ \"SiS 7014 Physical Layer Solution\", \t0x0016, 0xf830, LAN },\n\t{ \"SiS 900 on Foxconn 661 7MI\",         0x0143, 0xBC70, LAN },\n\t{ \"Altimata AC101LF PHY\",               0x0022, 0x5520, LAN },\n\t{ \"ADM 7001 LAN PHY\",\t\t\t0x002e, 0xcc60, LAN },\n\t{ \"AMD 79C901 10BASE-T PHY\",  \t\t0x0000, 0x6B70, LAN },\n\t{ \"AMD 79C901 HomePNA PHY\",\t\t0x0000, 0x6B90, HOME},\n\t{ \"ICS LAN PHY\",\t\t\t0x0015, 0xF440, LAN },\n\t{ \"ICS LAN PHY\",\t\t\t0x0143, 0xBC70, LAN },\n\t{ \"NS 83851 PHY\",\t\t\t0x2000, 0x5C20, MIX },\n\t{ \"NS 83847 PHY\",                       0x2000, 0x5C30, MIX },\n\t{ \"Realtek RTL8201 PHY\",\t\t0x0000, 0x8200, LAN },\n\t{ \"VIA 6103 PHY\",\t\t\t0x0101, 0x8f20, LAN },\n\t{NULL,},\n};\n\nstruct mii_phy {\n\tstruct mii_phy * next;\n\tint phy_addr;\n\tu16 phy_id0;\n\tu16 phy_id1;\n\tu16 status;\n\tu8  phy_types;\n};\n\ntypedef struct _BufferDesc {\n\tu32 link;\n\tu32 cmdsts;\n\tu32 bufptr;\n} BufferDesc;\n\nstruct sis900_private {\n\tstruct pci_dev * pci_dev;\n\n\tspinlock_t lock;\n\n\tstruct mii_phy * mii;\n\tstruct mii_phy * first_mii;  \n\tunsigned int cur_phy;\n\tstruct mii_if_info mii_info;\n\n\tvoid __iomem\t*ioaddr;\n\n\tstruct timer_list timer;  \n\tu8 autong_complete;  \n\n\tu32 msg_enable;\n\n\tunsigned int cur_rx, dirty_rx;  \n\tunsigned int cur_tx, dirty_tx;\n\n\t \n\tstruct sk_buff *tx_skbuff[NUM_TX_DESC];\n\tstruct sk_buff *rx_skbuff[NUM_RX_DESC];\n\tBufferDesc *tx_ring;\n\tBufferDesc *rx_ring;\n\n\tdma_addr_t tx_ring_dma;\n\tdma_addr_t rx_ring_dma;\n\n\tunsigned int tx_full;  \n\tu8 host_bridge_rev;\n\tu8 chipset_rev;\n\t \n\tint eeprom_size;\n};\n\nMODULE_AUTHOR(\"Jim Huang <cmhuang@sis.com.tw>, Ollie Lho <ollie@sis.com.tw>\");\nMODULE_DESCRIPTION(\"SiS 900 PCI Fast Ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(multicast_filter_limit, int, 0444);\nmodule_param(max_interrupt_work, int, 0444);\nmodule_param(sis900_debug, int, 0444);\nMODULE_PARM_DESC(multicast_filter_limit, \"SiS 900/7016 maximum number of filtered multicast addresses\");\nMODULE_PARM_DESC(max_interrupt_work, \"SiS 900/7016 maximum events handled per interrupt\");\nMODULE_PARM_DESC(sis900_debug, \"SiS 900/7016 bitmapped debugging message level\");\n\n#define sw32(reg, val)\tiowrite32(val, ioaddr + (reg))\n#define sw8(reg, val)\tiowrite8(val, ioaddr + (reg))\n#define sr32(reg)\tioread32(ioaddr + (reg))\n#define sr16(reg)\tioread16(ioaddr + (reg))\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void sis900_poll(struct net_device *dev);\n#endif\nstatic int sis900_open(struct net_device *net_dev);\nstatic int sis900_mii_probe (struct net_device * net_dev);\nstatic void sis900_init_rxfilter (struct net_device * net_dev);\nstatic u16 read_eeprom(void __iomem *ioaddr, int location);\nstatic int mdio_read(struct net_device *net_dev, int phy_id, int location);\nstatic void mdio_write(struct net_device *net_dev, int phy_id, int location, int val);\nstatic void sis900_timer(struct timer_list *t);\nstatic void sis900_check_mode (struct net_device *net_dev, struct mii_phy *mii_phy);\nstatic void sis900_tx_timeout(struct net_device *net_dev, unsigned int txqueue);\nstatic void sis900_init_tx_ring(struct net_device *net_dev);\nstatic void sis900_init_rx_ring(struct net_device *net_dev);\nstatic netdev_tx_t sis900_start_xmit(struct sk_buff *skb,\n\t\t\t\t     struct net_device *net_dev);\nstatic int sis900_rx(struct net_device *net_dev);\nstatic void sis900_finish_xmit (struct net_device *net_dev);\nstatic irqreturn_t sis900_interrupt(int irq, void *dev_instance);\nstatic int sis900_close(struct net_device *net_dev);\nstatic int mii_ioctl(struct net_device *net_dev, struct ifreq *rq, int cmd);\nstatic u16 sis900_mcast_bitnr(u8 *addr, u8 revision);\nstatic void set_rx_mode(struct net_device *net_dev);\nstatic void sis900_reset(struct net_device *net_dev);\nstatic void sis630_set_eq(struct net_device *net_dev, u8 revision);\nstatic int sis900_set_config(struct net_device *dev, struct ifmap *map);\nstatic u16 sis900_default_phy(struct net_device * net_dev);\nstatic void sis900_set_capability( struct net_device *net_dev ,struct mii_phy *phy);\nstatic u16 sis900_reset_phy(struct net_device *net_dev, int phy_addr);\nstatic void sis900_auto_negotiate(struct net_device *net_dev, int phy_addr);\nstatic void sis900_set_mode(struct sis900_private *, int speed, int duplex);\nstatic const struct ethtool_ops sis900_ethtool_ops;\n\n \n\nstatic int sis900_get_mac_addr(struct pci_dev *pci_dev,\n\t\t\t       struct net_device *net_dev)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tvoid __iomem *ioaddr = sis_priv->ioaddr;\n\tu16 addr[ETH_ALEN / 2];\n\tu16 signature;\n\tint i;\n\n\t \n\tsignature = (u16) read_eeprom(ioaddr, EEPROMSignature);\n\tif (signature == 0xffff || signature == 0x0000) {\n\t\tprintk (KERN_WARNING \"%s: Error EEPROM read %x\\n\",\n\t\t\tpci_name(pci_dev), signature);\n\t\treturn 0;\n\t}\n\n\t \n\tfor (i = 0; i < 3; i++)\n\t        addr[i] = read_eeprom(ioaddr, i+EEPROMMACAddr);\n\teth_hw_addr_set(net_dev, (u8 *)addr);\n\n\treturn 1;\n}\n\n \n\nstatic int sis630e_get_mac_addr(struct pci_dev *pci_dev,\n\t\t\t\tstruct net_device *net_dev)\n{\n\tstruct pci_dev *isa_bridge = NULL;\n\tu8 addr[ETH_ALEN];\n\tu8 reg;\n\tint i;\n\n\tisa_bridge = pci_get_device(PCI_VENDOR_ID_SI, 0x0008, isa_bridge);\n\tif (!isa_bridge)\n\t\tisa_bridge = pci_get_device(PCI_VENDOR_ID_SI, 0x0018, isa_bridge);\n\tif (!isa_bridge) {\n\t\tprintk(KERN_WARNING \"%s: Can not find ISA bridge\\n\",\n\t\t       pci_name(pci_dev));\n\t\treturn 0;\n\t}\n\tpci_read_config_byte(isa_bridge, 0x48, &reg);\n\tpci_write_config_byte(isa_bridge, 0x48, reg | 0x40);\n\n\tfor (i = 0; i < 6; i++) {\n\t\toutb(0x09 + i, 0x70);\n\t\taddr[i] = inb(0x71);\n\t}\n\teth_hw_addr_set(net_dev, addr);\n\n\tpci_write_config_byte(isa_bridge, 0x48, reg & ~0x40);\n\tpci_dev_put(isa_bridge);\n\n\treturn 1;\n}\n\n\n \n\nstatic int sis635_get_mac_addr(struct pci_dev *pci_dev,\n\t\t\t       struct net_device *net_dev)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tvoid __iomem *ioaddr = sis_priv->ioaddr;\n\tu16 addr[ETH_ALEN / 2];\n\tu32 rfcrSave;\n\tu32 i;\n\n\trfcrSave = sr32(rfcr);\n\n\tsw32(cr, rfcrSave | RELOAD);\n\tsw32(cr, 0);\n\n\t \n\tsw32(rfcr, rfcrSave & ~RFEN);\n\n\t \n\tfor (i = 0 ; i < 3 ; i++) {\n\t\tsw32(rfcr, (i << RFADDR_shift));\n\t\taddr[i] = sr16(rfdr);\n\t}\n\teth_hw_addr_set(net_dev, (u8 *)addr);\n\n\t \n\tsw32(rfcr, rfcrSave | RFEN);\n\n\treturn 1;\n}\n\n \n\nstatic int sis96x_get_mac_addr(struct pci_dev *pci_dev,\n\t\t\t       struct net_device *net_dev)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tvoid __iomem *ioaddr = sis_priv->ioaddr;\n\tu16 addr[ETH_ALEN / 2];\n\tint wait, rc = 0;\n\n\tsw32(mear, EEREQ);\n\tfor (wait = 0; wait < 2000; wait++) {\n\t\tif (sr32(mear) & EEGNT) {\n\t\t\tint i;\n\n\t\t\t \n\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t        addr[i] = read_eeprom(ioaddr, i + EEPROMMACAddr);\n\t\t\teth_hw_addr_set(net_dev, (u8 *)addr);\n\n\t\t\trc = 1;\n\t\t\tbreak;\n\t\t}\n\t\tudelay(1);\n\t}\n\tsw32(mear, EEDONE);\n\treturn rc;\n}\n\nstatic const struct net_device_ops sis900_netdev_ops = {\n\t.ndo_open\t\t = sis900_open,\n\t.ndo_stop\t\t= sis900_close,\n\t.ndo_start_xmit\t\t= sis900_start_xmit,\n\t.ndo_set_config\t\t= sis900_set_config,\n\t.ndo_set_rx_mode\t= set_rx_mode,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_eth_ioctl\t\t= mii_ioctl,\n\t.ndo_tx_timeout\t\t= sis900_tx_timeout,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n        .ndo_poll_controller\t= sis900_poll,\n#endif\n};\n\n \n\nstatic int sis900_probe(struct pci_dev *pci_dev,\n\t\t\tconst struct pci_device_id *pci_id)\n{\n\tstruct sis900_private *sis_priv;\n\tstruct net_device *net_dev;\n\tstruct pci_dev *dev;\n\tdma_addr_t ring_dma;\n\tvoid *ring_space;\n\tvoid __iomem *ioaddr;\n\tint i, ret;\n\tconst char *card_name = card_names[pci_id->driver_data];\n\tconst char *dev_name = pci_name(pci_dev);\n\n \n#ifndef MODULE\n\tstatic int printed_version;\n\tif (!printed_version++)\n\t\tprintk(version);\n#endif\n\n\t \n\tret = pcim_enable_device(pci_dev);\n\tif(ret) return ret;\n\n\ti = dma_set_mask(&pci_dev->dev, DMA_BIT_MASK(32));\n\tif(i){\n\t\tprintk(KERN_ERR \"sis900.c: architecture does not support \"\n\t\t\t\"32bit PCI busmaster DMA\\n\");\n\t\treturn i;\n\t}\n\n\tpci_set_master(pci_dev);\n\n\tnet_dev = alloc_etherdev(sizeof(struct sis900_private));\n\tif (!net_dev)\n\t\treturn -ENOMEM;\n\tSET_NETDEV_DEV(net_dev, &pci_dev->dev);\n\n\t \n\tret = pci_request_regions(pci_dev, \"sis900\");\n\tif (ret)\n\t\tgoto err_out;\n\n\t \n\tioaddr = pci_iomap(pci_dev, 0, 0);\n\tif (!ioaddr) {\n\t\tret = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tsis_priv = netdev_priv(net_dev);\n\tsis_priv->ioaddr = ioaddr;\n\tsis_priv->pci_dev = pci_dev;\n\tspin_lock_init(&sis_priv->lock);\n\n\tsis_priv->eeprom_size = 24;\n\n\tpci_set_drvdata(pci_dev, net_dev);\n\n\tring_space = dma_alloc_coherent(&pci_dev->dev, TX_TOTAL_SIZE,\n\t\t\t\t\t&ring_dma, GFP_KERNEL);\n\tif (!ring_space) {\n\t\tret = -ENOMEM;\n\t\tgoto err_out_unmap;\n\t}\n\tsis_priv->tx_ring = ring_space;\n\tsis_priv->tx_ring_dma = ring_dma;\n\n\tring_space = dma_alloc_coherent(&pci_dev->dev, RX_TOTAL_SIZE,\n\t\t\t\t\t&ring_dma, GFP_KERNEL);\n\tif (!ring_space) {\n\t\tret = -ENOMEM;\n\t\tgoto err_unmap_tx;\n\t}\n\tsis_priv->rx_ring = ring_space;\n\tsis_priv->rx_ring_dma = ring_dma;\n\n\t \n\tnet_dev->netdev_ops = &sis900_netdev_ops;\n\tnet_dev->watchdog_timeo = TX_TIMEOUT;\n\tnet_dev->ethtool_ops = &sis900_ethtool_ops;\n\n\tif (sis900_debug > 0)\n\t\tsis_priv->msg_enable = sis900_debug;\n\telse\n\t\tsis_priv->msg_enable = SIS900_DEF_MSG;\n\n\tsis_priv->mii_info.dev = net_dev;\n\tsis_priv->mii_info.mdio_read = mdio_read;\n\tsis_priv->mii_info.mdio_write = mdio_write;\n\tsis_priv->mii_info.phy_id_mask = 0x1f;\n\tsis_priv->mii_info.reg_num_mask = 0x1f;\n\n\t \n\tsis_priv->chipset_rev = pci_dev->revision;\n\tif(netif_msg_probe(sis_priv))\n\t\tprintk(KERN_DEBUG \"%s: detected revision %2.2x, \"\n\t\t\t\t\"trying to get MAC address...\\n\",\n\t\t\t\tdev_name, sis_priv->chipset_rev);\n\n\tret = 0;\n\tif (sis_priv->chipset_rev == SIS630E_900_REV)\n\t\tret = sis630e_get_mac_addr(pci_dev, net_dev);\n\telse if ((sis_priv->chipset_rev > 0x81) && (sis_priv->chipset_rev <= 0x90) )\n\t\tret = sis635_get_mac_addr(pci_dev, net_dev);\n\telse if (sis_priv->chipset_rev == SIS96x_900_REV)\n\t\tret = sis96x_get_mac_addr(pci_dev, net_dev);\n\telse\n\t\tret = sis900_get_mac_addr(pci_dev, net_dev);\n\n\tif (!ret || !is_valid_ether_addr(net_dev->dev_addr)) {\n\t\teth_hw_addr_random(net_dev);\n\t\tprintk(KERN_WARNING \"%s: Unreadable or invalid MAC address,\"\n\t\t\t\t\"using random generated one\\n\", dev_name);\n\t}\n\n\t \n\tif (sis_priv->chipset_rev == SIS630ET_900_REV)\n\t\tsw32(cr, ACCESSMODE | sr32(cr));\n\n\t \n\tif (sis900_mii_probe(net_dev) == 0) {\n\t\tprintk(KERN_WARNING \"%s: Error probing MII device.\\n\",\n\t\t       dev_name);\n\t\tret = -ENODEV;\n\t\tgoto err_unmap_rx;\n\t}\n\n\t \n\tdev = pci_get_device(PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_630, NULL);\n\tif (dev) {\n\t\tsis_priv->host_bridge_rev = dev->revision;\n\t\tpci_dev_put(dev);\n\t}\n\n\tret = register_netdev(net_dev);\n\tif (ret)\n\t\tgoto err_unmap_rx;\n\n\t \n\tprintk(KERN_INFO \"%s: %s at 0x%p, IRQ %d, %pM\\n\",\n\t       net_dev->name, card_name, ioaddr, pci_dev->irq,\n\t       net_dev->dev_addr);\n\n\t \n\tret = (sr32(CFGPMC) & PMESP) >> 27;\n\tif (netif_msg_probe(sis_priv) && (ret & PME_D3C) == 0)\n\t\tprintk(KERN_INFO \"%s: Wake on LAN only available from suspend to RAM.\", net_dev->name);\n\n\treturn 0;\n\nerr_unmap_rx:\n\tdma_free_coherent(&pci_dev->dev, RX_TOTAL_SIZE, sis_priv->rx_ring,\n\t\t\t  sis_priv->rx_ring_dma);\nerr_unmap_tx:\n\tdma_free_coherent(&pci_dev->dev, TX_TOTAL_SIZE, sis_priv->tx_ring,\n\t\t\t  sis_priv->tx_ring_dma);\nerr_out_unmap:\n\tpci_iounmap(pci_dev, ioaddr);\n err_out:\n\tfree_netdev(net_dev);\n\treturn ret;\n}\n\n \n\nstatic int sis900_mii_probe(struct net_device *net_dev)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tconst char *dev_name = pci_name(sis_priv->pci_dev);\n\tu16 poll_bit = MII_STAT_LINK, status = 0;\n\tunsigned long timeout = jiffies + 5 * HZ;\n\tint phy_addr;\n\n\tsis_priv->mii = NULL;\n\n\t \n\tfor (phy_addr = 0; phy_addr < 32; phy_addr++) {\n\t\tstruct mii_phy * mii_phy = NULL;\n\t\tu16 mii_status;\n\t\tint i;\n\n\t\tmii_phy = NULL;\n\t\tfor(i = 0; i < 2; i++)\n\t\t\tmii_status = mdio_read(net_dev, phy_addr, MII_STATUS);\n\n\t\tif (mii_status == 0xffff || mii_status == 0x0000) {\n\t\t\tif (netif_msg_probe(sis_priv))\n\t\t\t\tprintk(KERN_DEBUG \"%s: MII at address %d\"\n\t\t\t\t\t\t\" not accessible\\n\",\n\t\t\t\t\t\tdev_name, phy_addr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((mii_phy = kmalloc(sizeof(struct mii_phy), GFP_KERNEL)) == NULL) {\n\t\t\tmii_phy = sis_priv->first_mii;\n\t\t\twhile (mii_phy) {\n\t\t\t\tstruct mii_phy *phy;\n\t\t\t\tphy = mii_phy;\n\t\t\t\tmii_phy = mii_phy->next;\n\t\t\t\tkfree(phy);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tmii_phy->phy_id0 = mdio_read(net_dev, phy_addr, MII_PHY_ID0);\n\t\tmii_phy->phy_id1 = mdio_read(net_dev, phy_addr, MII_PHY_ID1);\n\t\tmii_phy->phy_addr = phy_addr;\n\t\tmii_phy->status = mii_status;\n\t\tmii_phy->next = sis_priv->mii;\n\t\tsis_priv->mii = mii_phy;\n\t\tsis_priv->first_mii = mii_phy;\n\n\t\tfor (i = 0; mii_chip_table[i].phy_id1; i++)\n\t\t\tif ((mii_phy->phy_id0 == mii_chip_table[i].phy_id0 ) &&\n\t\t\t    ((mii_phy->phy_id1 & 0xFFF0) == mii_chip_table[i].phy_id1)){\n\t\t\t\tmii_phy->phy_types = mii_chip_table[i].phy_types;\n\t\t\t\tif (mii_chip_table[i].phy_types == MIX)\n\t\t\t\t\tmii_phy->phy_types =\n\t\t\t\t\t    (mii_status & (MII_STAT_CAN_TX_FDX | MII_STAT_CAN_TX)) ? LAN : HOME;\n\t\t\t\tprintk(KERN_INFO \"%s: %s transceiver found \"\n\t\t\t\t\t\t\t\"at address %d.\\n\",\n\t\t\t\t\t\t\tdev_name,\n\t\t\t\t\t\t\tmii_chip_table[i].name,\n\t\t\t\t\t\t\tphy_addr);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tif( !mii_chip_table[i].phy_id1 ) {\n\t\t\tprintk(KERN_INFO \"%s: Unknown PHY transceiver found at address %d.\\n\",\n\t\t\t       dev_name, phy_addr);\n\t\t\tmii_phy->phy_types = UNKNOWN;\n\t\t}\n\t}\n\n\tif (sis_priv->mii == NULL) {\n\t\tprintk(KERN_INFO \"%s: No MII transceivers found!\\n\", dev_name);\n\t\treturn 0;\n\t}\n\n\t \n\tsis_priv->mii = NULL;\n\tsis900_default_phy( net_dev );\n\n\t \n        if ((sis_priv->mii->phy_id0 == 0x001D) &&\n\t    ((sis_priv->mii->phy_id1&0xFFF0) == 0x8000))\n\t\tstatus = sis900_reset_phy(net_dev, sis_priv->cur_phy);\n\n         \n        if ((sis_priv->mii->phy_id0 == 0x0015) &&\n            ((sis_priv->mii->phy_id1&0xFFF0) == 0xF440))\n\t\tmdio_write(net_dev, sis_priv->cur_phy, 0x0018, 0xD200);\n\n\tif(status & MII_STAT_LINK){\n\t\twhile (poll_bit) {\n\t\t\tyield();\n\n\t\t\tpoll_bit ^= (mdio_read(net_dev, sis_priv->cur_phy, MII_STATUS) & poll_bit);\n\t\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\t\tprintk(KERN_WARNING \"%s: reset phy and link down now\\n\",\n\t\t\t\t       dev_name);\n\t\t\t\treturn -ETIME;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (sis_priv->chipset_rev == SIS630E_900_REV) {\n\t\t \n\t\tmdio_write(net_dev, sis_priv->cur_phy, MII_ANADV, 0x05e1);\n\t\tmdio_write(net_dev, sis_priv->cur_phy, MII_CONFIG1, 0x22);\n\t\tmdio_write(net_dev, sis_priv->cur_phy, MII_CONFIG2, 0xff00);\n\t\tmdio_write(net_dev, sis_priv->cur_phy, MII_MASK, 0xffc0);\n\t\t\n\t}\n\n\tif (sis_priv->mii->status & MII_STAT_LINK)\n\t\tnetif_carrier_on(net_dev);\n\telse\n\t\tnetif_carrier_off(net_dev);\n\n\treturn 1;\n}\n\n \n\nstatic u16 sis900_default_phy(struct net_device * net_dev)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tstruct mii_phy *phy = NULL, *phy_home = NULL,\n\t\t*default_phy = NULL, *phy_lan = NULL;\n\tu16 status;\n\n        for (phy=sis_priv->first_mii; phy; phy=phy->next) {\n\t\tstatus = mdio_read(net_dev, phy->phy_addr, MII_STATUS);\n\t\tstatus = mdio_read(net_dev, phy->phy_addr, MII_STATUS);\n\n\t\t \n\t\tif ((status & MII_STAT_LINK) && !default_phy &&\n\t\t    (phy->phy_types != UNKNOWN)) {\n\t\t\tdefault_phy = phy;\n\t\t} else {\n\t\t\tstatus = mdio_read(net_dev, phy->phy_addr, MII_CONTROL);\n\t\t\tmdio_write(net_dev, phy->phy_addr, MII_CONTROL,\n\t\t\t\tstatus | MII_CNTL_AUTO | MII_CNTL_ISOLATE);\n\t\t\tif (phy->phy_types == HOME)\n\t\t\t\tphy_home = phy;\n\t\t\telse if(phy->phy_types == LAN)\n\t\t\t\tphy_lan = phy;\n\t\t}\n\t}\n\n\tif (!default_phy && phy_home)\n\t\tdefault_phy = phy_home;\n\telse if (!default_phy && phy_lan)\n\t\tdefault_phy = phy_lan;\n\telse if (!default_phy)\n\t\tdefault_phy = sis_priv->first_mii;\n\n\tif (sis_priv->mii != default_phy) {\n\t\tsis_priv->mii = default_phy;\n\t\tsis_priv->cur_phy = default_phy->phy_addr;\n\t\tprintk(KERN_INFO \"%s: Using transceiver found at address %d as default\\n\",\n\t\t       pci_name(sis_priv->pci_dev), sis_priv->cur_phy);\n\t}\n\n\tsis_priv->mii_info.phy_id = sis_priv->cur_phy;\n\n\tstatus = mdio_read(net_dev, sis_priv->cur_phy, MII_CONTROL);\n\tstatus &= (~MII_CNTL_ISOLATE);\n\n\tmdio_write(net_dev, sis_priv->cur_phy, MII_CONTROL, status);\n\tstatus = mdio_read(net_dev, sis_priv->cur_phy, MII_STATUS);\n\tstatus = mdio_read(net_dev, sis_priv->cur_phy, MII_STATUS);\n\n\treturn status;\n}\n\n\n \n\nstatic void sis900_set_capability(struct net_device *net_dev, struct mii_phy *phy)\n{\n\tu16 cap;\n\n\tmdio_read(net_dev, phy->phy_addr, MII_STATUS);\n\tmdio_read(net_dev, phy->phy_addr, MII_STATUS);\n\n\tcap = MII_NWAY_CSMA_CD |\n\t\t((phy->status & MII_STAT_CAN_TX_FDX)? MII_NWAY_TX_FDX:0) |\n\t\t((phy->status & MII_STAT_CAN_TX)    ? MII_NWAY_TX:0) |\n\t\t((phy->status & MII_STAT_CAN_T_FDX) ? MII_NWAY_T_FDX:0)|\n\t\t((phy->status & MII_STAT_CAN_T)     ? MII_NWAY_T:0);\n\n\tmdio_write(net_dev, phy->phy_addr, MII_ANADV, cap);\n}\n\n\n \n#define eeprom_delay()\tsr32(mear)\n\n \n\nstatic u16 read_eeprom(void __iomem *ioaddr, int location)\n{\n\tu32 read_cmd = location | EEread;\n\tint i;\n\tu16 retval = 0;\n\n\tsw32(mear, 0);\n\teeprom_delay();\n\tsw32(mear, EECS);\n\teeprom_delay();\n\n\t \n\tfor (i = 8; i >= 0; i--) {\n\t\tu32 dataval = (read_cmd & (1 << i)) ? EEDI | EECS : EECS;\n\n\t\tsw32(mear, dataval);\n\t\teeprom_delay();\n\t\tsw32(mear, dataval | EECLK);\n\t\teeprom_delay();\n\t}\n\tsw32(mear, EECS);\n\teeprom_delay();\n\n\t \n\tfor (i = 16; i > 0; i--) {\n\t\tsw32(mear, EECS);\n\t\teeprom_delay();\n\t\tsw32(mear, EECS | EECLK);\n\t\teeprom_delay();\n\t\tretval = (retval << 1) | ((sr32(mear) & EEDO) ? 1 : 0);\n\t\teeprom_delay();\n\t}\n\n\t \n\tsw32(mear, 0);\n\teeprom_delay();\n\n\treturn retval;\n}\n\n \n#define mdio_delay()\tsr32(mear)\n\nstatic void mdio_idle(struct sis900_private *sp)\n{\n\tvoid __iomem *ioaddr = sp->ioaddr;\n\n\tsw32(mear, MDIO | MDDIR);\n\tmdio_delay();\n\tsw32(mear, MDIO | MDDIR | MDC);\n}\n\n \nstatic void mdio_reset(struct sis900_private *sp)\n{\n\tvoid __iomem *ioaddr = sp->ioaddr;\n\tint i;\n\n\tfor (i = 31; i >= 0; i--) {\n\t\tsw32(mear, MDDIR | MDIO);\n\t\tmdio_delay();\n\t\tsw32(mear, MDDIR | MDIO | MDC);\n\t\tmdio_delay();\n\t}\n}\n\n \n\nstatic int mdio_read(struct net_device *net_dev, int phy_id, int location)\n{\n\tint mii_cmd = MIIread|(phy_id<<MIIpmdShift)|(location<<MIIregShift);\n\tstruct sis900_private *sp = netdev_priv(net_dev);\n\tvoid __iomem *ioaddr = sp->ioaddr;\n\tu16 retval = 0;\n\tint i;\n\n\tmdio_reset(sp);\n\tmdio_idle(sp);\n\n\tfor (i = 15; i >= 0; i--) {\n\t\tint dataval = (mii_cmd & (1 << i)) ? MDDIR | MDIO : MDDIR;\n\n\t\tsw32(mear, dataval);\n\t\tmdio_delay();\n\t\tsw32(mear, dataval | MDC);\n\t\tmdio_delay();\n\t}\n\n\t \n\tfor (i = 16; i > 0; i--) {\n\t\tsw32(mear, 0);\n\t\tmdio_delay();\n\t\tretval = (retval << 1) | ((sr32(mear) & MDIO) ? 1 : 0);\n\t\tsw32(mear, MDC);\n\t\tmdio_delay();\n\t}\n\tsw32(mear, 0x00);\n\n\treturn retval;\n}\n\n \n\nstatic void mdio_write(struct net_device *net_dev, int phy_id, int location,\n\t\t\tint value)\n{\n\tint mii_cmd = MIIwrite|(phy_id<<MIIpmdShift)|(location<<MIIregShift);\n\tstruct sis900_private *sp = netdev_priv(net_dev);\n\tvoid __iomem *ioaddr = sp->ioaddr;\n\tint i;\n\n\tmdio_reset(sp);\n\tmdio_idle(sp);\n\n\t \n\tfor (i = 15; i >= 0; i--) {\n\t\tint dataval = (mii_cmd & (1 << i)) ? MDDIR | MDIO : MDDIR;\n\n\t\tsw8(mear, dataval);\n\t\tmdio_delay();\n\t\tsw8(mear, dataval | MDC);\n\t\tmdio_delay();\n\t}\n\tmdio_delay();\n\n\t \n\tfor (i = 15; i >= 0; i--) {\n\t\tint dataval = (value & (1 << i)) ? MDDIR | MDIO : MDDIR;\n\n\t\tsw32(mear, dataval);\n\t\tmdio_delay();\n\t\tsw32(mear, dataval | MDC);\n\t\tmdio_delay();\n\t}\n\tmdio_delay();\n\n\t \n\tfor (i = 2; i > 0; i--) {\n\t\tsw8(mear, 0);\n\t\tmdio_delay();\n\t\tsw8(mear, MDC);\n\t\tmdio_delay();\n\t}\n\tsw32(mear, 0x00);\n}\n\n\n \n\nstatic u16 sis900_reset_phy(struct net_device *net_dev, int phy_addr)\n{\n\tint i;\n\tu16 status;\n\n\tfor (i = 0; i < 2; i++)\n\t\tstatus = mdio_read(net_dev, phy_addr, MII_STATUS);\n\n\tmdio_write( net_dev, phy_addr, MII_CONTROL, MII_CNTL_RESET );\n\n\treturn status;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n \nstatic void sis900_poll(struct net_device *dev)\n{\n\tstruct sis900_private *sp = netdev_priv(dev);\n\tconst int irq = sp->pci_dev->irq;\n\n\tdisable_irq(irq);\n\tsis900_interrupt(irq, dev);\n\tenable_irq(irq);\n}\n#endif\n\n \n\nstatic int\nsis900_open(struct net_device *net_dev)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tvoid __iomem *ioaddr = sis_priv->ioaddr;\n\tint ret;\n\n\t \n\tsis900_reset(net_dev);\n\n\t \n\tsis630_set_eq(net_dev, sis_priv->chipset_rev);\n\n\tret = request_irq(sis_priv->pci_dev->irq, sis900_interrupt, IRQF_SHARED,\n\t\t\t  net_dev->name, net_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tsis900_init_rxfilter(net_dev);\n\n\tsis900_init_tx_ring(net_dev);\n\tsis900_init_rx_ring(net_dev);\n\n\tset_rx_mode(net_dev);\n\n\tnetif_start_queue(net_dev);\n\n\t \n\tsis900_set_mode(sis_priv, HW_SPEED_10_MBPS, FDX_CAPABLE_HALF_SELECTED);\n\n\t \n\tsw32(imr, RxSOVR | RxORN | RxERR | RxOK | TxURN | TxERR | TxDESC);\n\tsw32(cr, RxENA | sr32(cr));\n\tsw32(ier, IE);\n\n\tsis900_check_mode(net_dev, sis_priv->mii);\n\n\t \n\ttimer_setup(&sis_priv->timer, sis900_timer, 0);\n\tsis_priv->timer.expires = jiffies + HZ;\n\tadd_timer(&sis_priv->timer);\n\n\treturn 0;\n}\n\n \n\nstatic void\nsis900_init_rxfilter (struct net_device * net_dev)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tvoid __iomem *ioaddr = sis_priv->ioaddr;\n\tu32 rfcrSave;\n\tu32 i;\n\n\trfcrSave = sr32(rfcr);\n\n\t \n\tsw32(rfcr, rfcrSave & ~RFEN);\n\n\t \n\tfor (i = 0 ; i < 3 ; i++) {\n\t\tu32 w = (u32) *((const u16 *)(net_dev->dev_addr)+i);\n\n\t\tsw32(rfcr, i << RFADDR_shift);\n\t\tsw32(rfdr, w);\n\n\t\tif (netif_msg_hw(sis_priv)) {\n\t\t\tprintk(KERN_DEBUG \"%s: Receive Filter Address[%d]=%x\\n\",\n\t\t\t       net_dev->name, i, sr32(rfdr));\n\t\t}\n\t}\n\n\t \n\tsw32(rfcr, rfcrSave | RFEN);\n}\n\n \n\nstatic void\nsis900_init_tx_ring(struct net_device *net_dev)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tvoid __iomem *ioaddr = sis_priv->ioaddr;\n\tint i;\n\n\tsis_priv->tx_full = 0;\n\tsis_priv->dirty_tx = sis_priv->cur_tx = 0;\n\n\tfor (i = 0; i < NUM_TX_DESC; i++) {\n\t\tsis_priv->tx_skbuff[i] = NULL;\n\n\t\tsis_priv->tx_ring[i].link = sis_priv->tx_ring_dma +\n\t\t\t((i+1)%NUM_TX_DESC)*sizeof(BufferDesc);\n\t\tsis_priv->tx_ring[i].cmdsts = 0;\n\t\tsis_priv->tx_ring[i].bufptr = 0;\n\t}\n\n\t \n\tsw32(txdp, sis_priv->tx_ring_dma);\n\tif (netif_msg_hw(sis_priv))\n\t\tprintk(KERN_DEBUG \"%s: TX descriptor register loaded with: %8.8x\\n\",\n\t\t       net_dev->name, sr32(txdp));\n}\n\n \n\nstatic void\nsis900_init_rx_ring(struct net_device *net_dev)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tvoid __iomem *ioaddr = sis_priv->ioaddr;\n\tint i;\n\n\tsis_priv->cur_rx = 0;\n\tsis_priv->dirty_rx = 0;\n\n\t \n\tfor (i = 0; i < NUM_RX_DESC; i++) {\n\t\tsis_priv->rx_skbuff[i] = NULL;\n\n\t\tsis_priv->rx_ring[i].link = sis_priv->rx_ring_dma +\n\t\t\t((i+1)%NUM_RX_DESC)*sizeof(BufferDesc);\n\t\tsis_priv->rx_ring[i].cmdsts = 0;\n\t\tsis_priv->rx_ring[i].bufptr = 0;\n\t}\n\n\t \n\tfor (i = 0; i < NUM_RX_DESC; i++) {\n\t\tstruct sk_buff *skb;\n\n\t\tif ((skb = netdev_alloc_skb(net_dev, RX_BUF_SIZE)) == NULL) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tsis_priv->rx_skbuff[i] = skb;\n\t\tsis_priv->rx_ring[i].cmdsts = RX_BUF_SIZE;\n\t\tsis_priv->rx_ring[i].bufptr = dma_map_single(&sis_priv->pci_dev->dev,\n\t\t\t\t\t\t\t     skb->data,\n\t\t\t\t\t\t\t     RX_BUF_SIZE,\n\t\t\t\t\t\t\t     DMA_FROM_DEVICE);\n\t\tif (unlikely(dma_mapping_error(&sis_priv->pci_dev->dev,\n\t\t\t\t\t       sis_priv->rx_ring[i].bufptr))) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\tsis_priv->rx_skbuff[i] = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tsis_priv->dirty_rx = (unsigned int) (i - NUM_RX_DESC);\n\n\t \n\tsw32(rxdp, sis_priv->rx_ring_dma);\n\tif (netif_msg_hw(sis_priv))\n\t\tprintk(KERN_DEBUG \"%s: RX descriptor register loaded with: %8.8x\\n\",\n\t\t       net_dev->name, sr32(rxdp));\n}\n\n \n\nstatic void sis630_set_eq(struct net_device *net_dev, u8 revision)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tu16 reg14h, eq_value=0, max_value=0, min_value=0;\n\tint i, maxcount=10;\n\n\tif ( !(revision == SIS630E_900_REV || revision == SIS630EA1_900_REV ||\n\t       revision == SIS630A_900_REV || revision ==  SIS630ET_900_REV) )\n\t\treturn;\n\n\tif (netif_carrier_ok(net_dev)) {\n\t\treg14h = mdio_read(net_dev, sis_priv->cur_phy, MII_RESV);\n\t\tmdio_write(net_dev, sis_priv->cur_phy, MII_RESV,\n\t\t\t\t\t(0x2200 | reg14h) & 0xBFFF);\n\t\tfor (i=0; i < maxcount; i++) {\n\t\t\teq_value = (0x00F8 & mdio_read(net_dev,\n\t\t\t\t\tsis_priv->cur_phy, MII_RESV)) >> 3;\n\t\t\tif (i == 0)\n\t\t\t\tmax_value=min_value=eq_value;\n\t\t\tmax_value = (eq_value > max_value) ?\n\t\t\t\t\t\teq_value : max_value;\n\t\t\tmin_value = (eq_value < min_value) ?\n\t\t\t\t\t\teq_value : min_value;\n\t\t}\n\t\t \n\t\tif (revision == SIS630E_900_REV || revision == SIS630EA1_900_REV ||\n\t\t    revision == SIS630ET_900_REV) {\n\t\t\tif (max_value < 5)\n\t\t\t\teq_value = max_value;\n\t\t\telse if (max_value >= 5 && max_value < 15)\n\t\t\t\teq_value = (max_value == min_value) ?\n\t\t\t\t\t\tmax_value+2 : max_value+1;\n\t\t\telse if (max_value >= 15)\n\t\t\t\teq_value=(max_value == min_value) ?\n\t\t\t\t\t\tmax_value+6 : max_value+5;\n\t\t}\n\t\t \n\t\tif (revision == SIS630A_900_REV &&\n\t\t    (sis_priv->host_bridge_rev == SIS630B0 ||\n\t\t     sis_priv->host_bridge_rev == SIS630B1)) {\n\t\t\tif (max_value == 0)\n\t\t\t\teq_value = 3;\n\t\t\telse\n\t\t\t\teq_value = (max_value + min_value + 1)/2;\n\t\t}\n\t\t \n\t\treg14h = mdio_read(net_dev, sis_priv->cur_phy, MII_RESV);\n\t\treg14h = (reg14h & 0xFF07) | ((eq_value << 3) & 0x00F8);\n\t\treg14h = (reg14h | 0x6000) & 0xFDFF;\n\t\tmdio_write(net_dev, sis_priv->cur_phy, MII_RESV, reg14h);\n\t} else {\n\t\treg14h = mdio_read(net_dev, sis_priv->cur_phy, MII_RESV);\n\t\tif (revision == SIS630A_900_REV &&\n\t\t    (sis_priv->host_bridge_rev == SIS630B0 ||\n\t\t     sis_priv->host_bridge_rev == SIS630B1))\n\t\t\tmdio_write(net_dev, sis_priv->cur_phy, MII_RESV,\n\t\t\t\t\t\t(reg14h | 0x2200) & 0xBFFF);\n\t\telse\n\t\t\tmdio_write(net_dev, sis_priv->cur_phy, MII_RESV,\n\t\t\t\t\t\t(reg14h | 0x2000) & 0xBFFF);\n\t}\n}\n\n \n\nstatic void sis900_timer(struct timer_list *t)\n{\n\tstruct sis900_private *sis_priv = from_timer(sis_priv, t, timer);\n\tstruct net_device *net_dev = sis_priv->mii_info.dev;\n\tstruct mii_phy *mii_phy = sis_priv->mii;\n\tstatic const int next_tick = 5*HZ;\n\tint speed = 0, duplex = 0;\n\tu16 status;\n\n\tstatus = mdio_read(net_dev, sis_priv->cur_phy, MII_STATUS);\n\tstatus = mdio_read(net_dev, sis_priv->cur_phy, MII_STATUS);\n\n\t \n\tif (!netif_carrier_ok(net_dev)) {\n\tLookForLink:\n\t\t \n\t\tstatus = sis900_default_phy(net_dev);\n\t\tmii_phy = sis_priv->mii;\n\n\t\tif (status & MII_STAT_LINK) {\n\t\t\tWARN_ON(!(status & MII_STAT_AUTO_DONE));\n\n\t\t\tsis900_read_mode(net_dev, &speed, &duplex);\n\t\t\tif (duplex) {\n\t\t\t\tsis900_set_mode(sis_priv, speed, duplex);\n\t\t\t\tsis630_set_eq(net_dev, sis_priv->chipset_rev);\n\t\t\t\tnetif_carrier_on(net_dev);\n\t\t\t}\n\t\t}\n\t} else {\n\t \n                if (!(status & MII_STAT_LINK)){\n\t\t\tnetif_carrier_off(net_dev);\n\t\t\tif(netif_msg_link(sis_priv))\n\t\t\t\tprintk(KERN_INFO \"%s: Media Link Off\\n\", net_dev->name);\n\n\t\t\t \n\t\t\tif ((mii_phy->phy_id0 == 0x001D) &&\n\t\t\t\t((mii_phy->phy_id1 & 0xFFF0) == 0x8000))\n\t\t\t\t\tsis900_reset_phy(net_dev,  sis_priv->cur_phy);\n\n\t\t\tsis630_set_eq(net_dev, sis_priv->chipset_rev);\n\n\t\t\tgoto LookForLink;\n                }\n\t}\n\n\tsis_priv->timer.expires = jiffies + next_tick;\n\tadd_timer(&sis_priv->timer);\n}\n\n \n\nstatic void sis900_check_mode(struct net_device *net_dev, struct mii_phy *mii_phy)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tvoid __iomem *ioaddr = sis_priv->ioaddr;\n\tint speed, duplex;\n\n\tif (mii_phy->phy_types == LAN) {\n\t\tsw32(cfg, ~EXD & sr32(cfg));\n\t\tsis900_set_capability(net_dev , mii_phy);\n\t\tsis900_auto_negotiate(net_dev, sis_priv->cur_phy);\n\t} else {\n\t\tsw32(cfg, EXD | sr32(cfg));\n\t\tspeed = HW_SPEED_HOME;\n\t\tduplex = FDX_CAPABLE_HALF_SELECTED;\n\t\tsis900_set_mode(sis_priv, speed, duplex);\n\t\tsis_priv->autong_complete = 1;\n\t}\n}\n\n \n\nstatic void sis900_set_mode(struct sis900_private *sp, int speed, int duplex)\n{\n\tvoid __iomem *ioaddr = sp->ioaddr;\n\tu32 tx_flags = 0, rx_flags = 0;\n\n\tif (sr32( cfg) & EDB_MASTER_EN) {\n\t\ttx_flags = TxATP | (DMA_BURST_64 << TxMXDMA_shift) |\n\t\t\t\t\t(TX_FILL_THRESH << TxFILLT_shift);\n\t\trx_flags = DMA_BURST_64 << RxMXDMA_shift;\n\t} else {\n\t\ttx_flags = TxATP | (DMA_BURST_512 << TxMXDMA_shift) |\n\t\t\t\t\t(TX_FILL_THRESH << TxFILLT_shift);\n\t\trx_flags = DMA_BURST_512 << RxMXDMA_shift;\n\t}\n\n\tif (speed == HW_SPEED_HOME || speed == HW_SPEED_10_MBPS) {\n\t\trx_flags |= (RxDRNT_10 << RxDRNT_shift);\n\t\ttx_flags |= (TxDRNT_10 << TxDRNT_shift);\n\t} else {\n\t\trx_flags |= (RxDRNT_100 << RxDRNT_shift);\n\t\ttx_flags |= (TxDRNT_100 << TxDRNT_shift);\n\t}\n\n\tif (duplex == FDX_CAPABLE_FULL_SELECTED) {\n\t\ttx_flags |= (TxCSI | TxHBI);\n\t\trx_flags |= RxATX;\n\t}\n\n#if IS_ENABLED(CONFIG_VLAN_8021Q)\n\t \n\trx_flags |= RxAJAB;\n#endif\n\n\tsw32(txcfg, tx_flags);\n\tsw32(rxcfg, rx_flags);\n}\n\n \n\nstatic void sis900_auto_negotiate(struct net_device *net_dev, int phy_addr)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tint i = 0;\n\tu32 status;\n\n\tfor (i = 0; i < 2; i++)\n\t\tstatus = mdio_read(net_dev, phy_addr, MII_STATUS);\n\n\tif (!(status & MII_STAT_LINK)){\n\t\tif(netif_msg_link(sis_priv))\n\t\t\tprintk(KERN_INFO \"%s: Media Link Off\\n\", net_dev->name);\n\t\tsis_priv->autong_complete = 1;\n\t\tnetif_carrier_off(net_dev);\n\t\treturn;\n\t}\n\n\t \n\tmdio_write(net_dev, phy_addr, MII_CONTROL,\n\t\t   MII_CNTL_AUTO | MII_CNTL_RST_AUTO);\n\tsis_priv->autong_complete = 0;\n}\n\n\n \n\nstatic void sis900_read_mode(struct net_device *net_dev, int *speed, int *duplex)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tstruct mii_phy *phy = sis_priv->mii;\n\tint phy_addr = sis_priv->cur_phy;\n\tu32 status;\n\tu16 autoadv, autorec;\n\tint i;\n\n\tfor (i = 0; i < 2; i++)\n\t\tstatus = mdio_read(net_dev, phy_addr, MII_STATUS);\n\n\tif (!(status & MII_STAT_LINK))\n\t\treturn;\n\n\t \n\tautoadv = mdio_read(net_dev, phy_addr, MII_ANADV);\n\tautorec = mdio_read(net_dev, phy_addr, MII_ANLPAR);\n\tstatus = autoadv & autorec;\n\n\t*speed = HW_SPEED_10_MBPS;\n\t*duplex = FDX_CAPABLE_HALF_SELECTED;\n\n\tif (status & (MII_NWAY_TX | MII_NWAY_TX_FDX))\n\t\t*speed = HW_SPEED_100_MBPS;\n\tif (status & ( MII_NWAY_TX_FDX | MII_NWAY_T_FDX))\n\t\t*duplex = FDX_CAPABLE_FULL_SELECTED;\n\n\tsis_priv->autong_complete = 1;\n\n\t \n\tif ((phy->phy_id0 == 0x0000) && ((phy->phy_id1 & 0xFFF0) == 0x8200)) {\n\t\tif (mdio_read(net_dev, phy_addr, MII_CONTROL) & MII_CNTL_FDX)\n\t\t\t*duplex = FDX_CAPABLE_FULL_SELECTED;\n\t\tif (mdio_read(net_dev, phy_addr, 0x0019) & 0x01)\n\t\t\t*speed = HW_SPEED_100_MBPS;\n\t}\n\n\tif(netif_msg_link(sis_priv))\n\t\tprintk(KERN_INFO \"%s: Media Link On %s %s-duplex\\n\",\n\t       \t\t\t\tnet_dev->name,\n\t       \t\t\t\t*speed == HW_SPEED_100_MBPS ?\n\t       \t\t\t\t\t\"100mbps\" : \"10mbps\",\n\t       \t\t\t\t*duplex == FDX_CAPABLE_FULL_SELECTED ?\n\t       \t\t\t\t\t\"full\" : \"half\");\n}\n\n \n\nstatic void sis900_tx_timeout(struct net_device *net_dev, unsigned int txqueue)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tvoid __iomem *ioaddr = sis_priv->ioaddr;\n\tunsigned long flags;\n\tint i;\n\n\tif (netif_msg_tx_err(sis_priv)) {\n\t\tprintk(KERN_INFO \"%s: Transmit timeout, status %8.8x %8.8x\\n\",\n\t\t\tnet_dev->name, sr32(cr), sr32(isr));\n\t}\n\n\t \n\tsw32(imr, 0x0000);\n\n\t \n\tspin_lock_irqsave(&sis_priv->lock, flags);\n\n\t \n\tsis_priv->dirty_tx = sis_priv->cur_tx = 0;\n\tfor (i = 0; i < NUM_TX_DESC; i++) {\n\t\tstruct sk_buff *skb = sis_priv->tx_skbuff[i];\n\n\t\tif (skb) {\n\t\t\tdma_unmap_single(&sis_priv->pci_dev->dev,\n\t\t\t\t\t sis_priv->tx_ring[i].bufptr,\n\t\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb_irq(skb);\n\t\t\tsis_priv->tx_skbuff[i] = NULL;\n\t\t\tsis_priv->tx_ring[i].cmdsts = 0;\n\t\t\tsis_priv->tx_ring[i].bufptr = 0;\n\t\t\tnet_dev->stats.tx_dropped++;\n\t\t}\n\t}\n\tsis_priv->tx_full = 0;\n\tnetif_wake_queue(net_dev);\n\n\tspin_unlock_irqrestore(&sis_priv->lock, flags);\n\n\tnetif_trans_update(net_dev);  \n\n\t \n\tsw32(txdp, sis_priv->tx_ring_dma);\n\n\t \n\tsw32(imr, RxSOVR | RxORN | RxERR | RxOK | TxURN | TxERR | TxDESC);\n}\n\n \n\nstatic netdev_tx_t\nsis900_start_xmit(struct sk_buff *skb, struct net_device *net_dev)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tvoid __iomem *ioaddr = sis_priv->ioaddr;\n\tunsigned int  entry;\n\tunsigned long flags;\n\tunsigned int  index_cur_tx, index_dirty_tx;\n\tunsigned int  count_dirty_tx;\n\n\tspin_lock_irqsave(&sis_priv->lock, flags);\n\n\t \n\tentry = sis_priv->cur_tx % NUM_TX_DESC;\n\tsis_priv->tx_skbuff[entry] = skb;\n\n\t \n\tsis_priv->tx_ring[entry].bufptr = dma_map_single(&sis_priv->pci_dev->dev,\n\t\t\t\t\t\t\t skb->data, skb->len,\n\t\t\t\t\t\t\t DMA_TO_DEVICE);\n\tif (unlikely(dma_mapping_error(&sis_priv->pci_dev->dev,\n\t\t\t\t       sis_priv->tx_ring[entry].bufptr))) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tsis_priv->tx_skbuff[entry] = NULL;\n\t\t\tnet_dev->stats.tx_dropped++;\n\t\t\tspin_unlock_irqrestore(&sis_priv->lock, flags);\n\t\t\treturn NETDEV_TX_OK;\n\t}\n\tsis_priv->tx_ring[entry].cmdsts = (OWN | INTR | skb->len);\n\tsw32(cr, TxENA | sr32(cr));\n\n\tsis_priv->cur_tx ++;\n\tindex_cur_tx = sis_priv->cur_tx;\n\tindex_dirty_tx = sis_priv->dirty_tx;\n\n\tfor (count_dirty_tx = 0; index_cur_tx != index_dirty_tx; index_dirty_tx++)\n\t\tcount_dirty_tx ++;\n\n\tif (index_cur_tx == index_dirty_tx) {\n\t\t \n\t\tsis_priv->tx_full = 1;\n\t\tnetif_stop_queue(net_dev);\n\t} else if (count_dirty_tx < NUM_TX_DESC) {\n\t\t \n\t\tnetif_start_queue(net_dev);\n\t} else {\n\t\t \n\t\tsis_priv->tx_full = 1;\n\t\tnetif_stop_queue(net_dev);\n\t}\n\n\tspin_unlock_irqrestore(&sis_priv->lock, flags);\n\n\tif (netif_msg_tx_queued(sis_priv))\n\t\tprintk(KERN_DEBUG \"%s: Queued Tx packet at %p size %d \"\n\t\t       \"to slot %d.\\n\",\n\t\t       net_dev->name, skb->data, (int)skb->len, entry);\n\n\treturn NETDEV_TX_OK;\n}\n\n \n\nstatic irqreturn_t sis900_interrupt(int irq, void *dev_instance)\n{\n\tstruct net_device *net_dev = dev_instance;\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tint boguscnt = max_interrupt_work;\n\tvoid __iomem *ioaddr = sis_priv->ioaddr;\n\tu32 status;\n\tunsigned int handled = 0;\n\n\tspin_lock (&sis_priv->lock);\n\n\tdo {\n\t\tstatus = sr32(isr);\n\n\t\tif ((status & (HIBERR|TxURN|TxERR|TxDESC|RxORN|RxERR|RxOK)) == 0)\n\t\t\t \n\t\t\tbreak;\n\t\thandled = 1;\n\n\t\t \n\t\tif (status & (RxORN | RxERR | RxOK))\n\t\t\t \n\t\t\tsis900_rx(net_dev);\n\n\t\tif (status & (TxURN | TxERR | TxDESC))\n\t\t\t \n\t\t\tsis900_finish_xmit(net_dev);\n\n\t\t \n\t\tif (status & HIBERR) {\n\t\t\tif(netif_msg_intr(sis_priv))\n\t\t\t\tprintk(KERN_INFO \"%s: Abnormal interrupt, \"\n\t\t\t\t\t\"status %#8.8x.\\n\", net_dev->name, status);\n\t\t\tbreak;\n\t\t}\n\t\tif (--boguscnt < 0) {\n\t\t\tif(netif_msg_intr(sis_priv))\n\t\t\t\tprintk(KERN_INFO \"%s: Too much work at interrupt, \"\n\t\t\t\t\t\"interrupt status = %#8.8x.\\n\",\n\t\t\t\t\tnet_dev->name, status);\n\t\t\tbreak;\n\t\t}\n\t} while (1);\n\n\tif(netif_msg_intr(sis_priv))\n\t\tprintk(KERN_DEBUG \"%s: exiting interrupt, \"\n\t\t       \"interrupt status = %#8.8x\\n\",\n\t\t       net_dev->name, sr32(isr));\n\n\tspin_unlock (&sis_priv->lock);\n\treturn IRQ_RETVAL(handled);\n}\n\n \n\nstatic int sis900_rx(struct net_device *net_dev)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tvoid __iomem *ioaddr = sis_priv->ioaddr;\n\tunsigned int entry = sis_priv->cur_rx % NUM_RX_DESC;\n\tu32 rx_status = sis_priv->rx_ring[entry].cmdsts;\n\tint rx_work_limit;\n\n\tif (netif_msg_rx_status(sis_priv))\n\t\tprintk(KERN_DEBUG \"sis900_rx, cur_rx:%4.4d, dirty_rx:%4.4d \"\n\t\t       \"status:0x%8.8x\\n\",\n\t\t       sis_priv->cur_rx, sis_priv->dirty_rx, rx_status);\n\trx_work_limit = sis_priv->dirty_rx + NUM_RX_DESC - sis_priv->cur_rx;\n\n\twhile (rx_status & OWN) {\n\t\tunsigned int rx_size;\n\t\tunsigned int data_size;\n\n\t\tif (--rx_work_limit < 0)\n\t\t\tbreak;\n\n\t\tdata_size = rx_status & DSIZE;\n\t\trx_size = data_size - CRC_SIZE;\n\n#if IS_ENABLED(CONFIG_VLAN_8021Q)\n\t\t \n\t\tif ((rx_status & TOOLONG) && data_size <= MAX_FRAME_SIZE)\n\t\t\trx_status &= (~ ((unsigned int)TOOLONG));\n#endif\n\n\t\tif (rx_status & (ABORT|OVERRUN|TOOLONG|RUNT|RXISERR|CRCERR|FAERR)) {\n\t\t\t \n\t\t\tif (netif_msg_rx_err(sis_priv))\n\t\t\t\tprintk(KERN_DEBUG \"%s: Corrupted packet \"\n\t\t\t\t       \"received, buffer status = 0x%8.8x/%d.\\n\",\n\t\t\t\t       net_dev->name, rx_status, data_size);\n\t\t\tnet_dev->stats.rx_errors++;\n\t\t\tif (rx_status & OVERRUN)\n\t\t\t\tnet_dev->stats.rx_over_errors++;\n\t\t\tif (rx_status & (TOOLONG|RUNT))\n\t\t\t\tnet_dev->stats.rx_length_errors++;\n\t\t\tif (rx_status & (RXISERR | FAERR))\n\t\t\t\tnet_dev->stats.rx_frame_errors++;\n\t\t\tif (rx_status & CRCERR)\n\t\t\t\tnet_dev->stats.rx_crc_errors++;\n\t\t\t \n\t\t\tsis_priv->rx_ring[entry].cmdsts = RX_BUF_SIZE;\n\t\t} else {\n\t\t\tstruct sk_buff * skb;\n\t\t\tstruct sk_buff * rx_skb;\n\n\t\t\tdma_unmap_single(&sis_priv->pci_dev->dev,\n\t\t\t\t\t sis_priv->rx_ring[entry].bufptr,\n\t\t\t\t\t RX_BUF_SIZE, DMA_FROM_DEVICE);\n\n\t\t\t \n\t\t\tif ((skb = netdev_alloc_skb(net_dev, RX_BUF_SIZE)) == NULL) {\n\t\t\t\t \n\t\t\t\tskb = sis_priv->rx_skbuff[entry];\n\t\t\t\tnet_dev->stats.rx_dropped++;\n\t\t\t\tgoto refill_rx_ring;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (sis_priv->rx_skbuff[entry] == NULL) {\n\t\t\t\tif (netif_msg_rx_err(sis_priv))\n\t\t\t\t\tprintk(KERN_WARNING \"%s: NULL pointer \"\n\t\t\t\t\t      \"encountered in Rx ring\\n\"\n\t\t\t\t\t      \"cur_rx:%4.4d, dirty_rx:%4.4d\\n\",\n\t\t\t\t\t      net_dev->name, sis_priv->cur_rx,\n\t\t\t\t\t      sis_priv->dirty_rx);\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\trx_skb = sis_priv->rx_skbuff[entry];\n\t\t\tskb_put(rx_skb, rx_size);\n\t\t\trx_skb->protocol = eth_type_trans(rx_skb, net_dev);\n\t\t\tnetif_rx(rx_skb);\n\n\t\t\t \n\t\t\tif ((rx_status & BCAST) == MCAST)\n\t\t\t\tnet_dev->stats.multicast++;\n\t\t\tnet_dev->stats.rx_bytes += rx_size;\n\t\t\tnet_dev->stats.rx_packets++;\n\t\t\tsis_priv->dirty_rx++;\nrefill_rx_ring:\n\t\t\tsis_priv->rx_skbuff[entry] = skb;\n\t\t\tsis_priv->rx_ring[entry].cmdsts = RX_BUF_SIZE;\n\t\t\tsis_priv->rx_ring[entry].bufptr =\n\t\t\t\tdma_map_single(&sis_priv->pci_dev->dev,\n\t\t\t\t\t       skb->data, RX_BUF_SIZE,\n\t\t\t\t\t       DMA_FROM_DEVICE);\n\t\t\tif (unlikely(dma_mapping_error(&sis_priv->pci_dev->dev,\n\t\t\t\t\t\t       sis_priv->rx_ring[entry].bufptr))) {\n\t\t\t\tdev_kfree_skb_irq(skb);\n\t\t\t\tsis_priv->rx_skbuff[entry] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsis_priv->cur_rx++;\n\t\tentry = sis_priv->cur_rx % NUM_RX_DESC;\n\t\trx_status = sis_priv->rx_ring[entry].cmdsts;\n\t} \n\n\t \n\tfor (; sis_priv->cur_rx != sis_priv->dirty_rx; sis_priv->dirty_rx++) {\n\t\tstruct sk_buff *skb;\n\n\t\tentry = sis_priv->dirty_rx % NUM_RX_DESC;\n\n\t\tif (sis_priv->rx_skbuff[entry] == NULL) {\n\t\t\tskb = netdev_alloc_skb(net_dev, RX_BUF_SIZE);\n\t\t\tif (skb == NULL) {\n\t\t\t\t \n\t\t\t\tnet_dev->stats.rx_dropped++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsis_priv->rx_skbuff[entry] = skb;\n\t\t\tsis_priv->rx_ring[entry].cmdsts = RX_BUF_SIZE;\n\t\t\tsis_priv->rx_ring[entry].bufptr =\n\t\t\t\tdma_map_single(&sis_priv->pci_dev->dev,\n\t\t\t\t\t       skb->data, RX_BUF_SIZE,\n\t\t\t\t\t       DMA_FROM_DEVICE);\n\t\t\tif (unlikely(dma_mapping_error(&sis_priv->pci_dev->dev,\n\t\t\t\t\t\t       sis_priv->rx_ring[entry].bufptr))) {\n\t\t\t\tdev_kfree_skb_irq(skb);\n\t\t\t\tsis_priv->rx_skbuff[entry] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tsw32(cr , RxENA | sr32(cr));\n\n\treturn 0;\n}\n\n \n\nstatic void sis900_finish_xmit (struct net_device *net_dev)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\n\tfor (; sis_priv->dirty_tx != sis_priv->cur_tx; sis_priv->dirty_tx++) {\n\t\tstruct sk_buff *skb;\n\t\tunsigned int entry;\n\t\tu32 tx_status;\n\n\t\tentry = sis_priv->dirty_tx % NUM_TX_DESC;\n\t\ttx_status = sis_priv->tx_ring[entry].cmdsts;\n\n\t\tif (tx_status & OWN) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tif (tx_status & (ABORT | UNDERRUN | OWCOLL)) {\n\t\t\t \n\t\t\tif (netif_msg_tx_err(sis_priv))\n\t\t\t\tprintk(KERN_DEBUG \"%s: Transmit \"\n\t\t\t\t       \"error, Tx status %8.8x.\\n\",\n\t\t\t\t       net_dev->name, tx_status);\n\t\t\tnet_dev->stats.tx_errors++;\n\t\t\tif (tx_status & UNDERRUN)\n\t\t\t\tnet_dev->stats.tx_fifo_errors++;\n\t\t\tif (tx_status & ABORT)\n\t\t\t\tnet_dev->stats.tx_aborted_errors++;\n\t\t\tif (tx_status & NOCARRIER)\n\t\t\t\tnet_dev->stats.tx_carrier_errors++;\n\t\t\tif (tx_status & OWCOLL)\n\t\t\t\tnet_dev->stats.tx_window_errors++;\n\t\t} else {\n\t\t\t \n\t\t\tnet_dev->stats.collisions += (tx_status & COLCNT) >> 16;\n\t\t\tnet_dev->stats.tx_bytes += tx_status & DSIZE;\n\t\t\tnet_dev->stats.tx_packets++;\n\t\t}\n\t\t \n\t\tskb = sis_priv->tx_skbuff[entry];\n\t\tdma_unmap_single(&sis_priv->pci_dev->dev,\n\t\t\t\t sis_priv->tx_ring[entry].bufptr, skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\t\tdev_consume_skb_irq(skb);\n\t\tsis_priv->tx_skbuff[entry] = NULL;\n\t\tsis_priv->tx_ring[entry].bufptr = 0;\n\t\tsis_priv->tx_ring[entry].cmdsts = 0;\n\t}\n\n\tif (sis_priv->tx_full && netif_queue_stopped(net_dev) &&\n\t    sis_priv->cur_tx - sis_priv->dirty_tx < NUM_TX_DESC - 4) {\n\t\t \n\t\tsis_priv->tx_full = 0;\n\t\tnetif_wake_queue (net_dev);\n\t}\n}\n\n \n\nstatic int sis900_close(struct net_device *net_dev)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tstruct pci_dev *pdev = sis_priv->pci_dev;\n\tvoid __iomem *ioaddr = sis_priv->ioaddr;\n\tstruct sk_buff *skb;\n\tint i;\n\n\tnetif_stop_queue(net_dev);\n\n\t \n\tsw32(imr, 0x0000);\n\tsw32(ier, 0x0000);\n\n\t \n\tsw32(cr, RxDIS | TxDIS | sr32(cr));\n\n\tdel_timer(&sis_priv->timer);\n\n\tfree_irq(pdev->irq, net_dev);\n\n\t \n\tfor (i = 0; i < NUM_RX_DESC; i++) {\n\t\tskb = sis_priv->rx_skbuff[i];\n\t\tif (skb) {\n\t\t\tdma_unmap_single(&pdev->dev,\n\t\t\t\t\t sis_priv->rx_ring[i].bufptr,\n\t\t\t\t\t RX_BUF_SIZE, DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(skb);\n\t\t\tsis_priv->rx_skbuff[i] = NULL;\n\t\t}\n\t}\n\tfor (i = 0; i < NUM_TX_DESC; i++) {\n\t\tskb = sis_priv->tx_skbuff[i];\n\t\tif (skb) {\n\t\t\tdma_unmap_single(&pdev->dev,\n\t\t\t\t\t sis_priv->tx_ring[i].bufptr,\n\t\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb(skb);\n\t\t\tsis_priv->tx_skbuff[i] = NULL;\n\t\t}\n\t}\n\n\t \n\n\treturn 0;\n}\n\n \n\nstatic void sis900_get_drvinfo(struct net_device *net_dev,\n\t\t\t       struct ethtool_drvinfo *info)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\n\tstrscpy(info->driver, SIS900_MODULE_NAME, sizeof(info->driver));\n\tstrscpy(info->version, SIS900_DRV_VERSION, sizeof(info->version));\n\tstrscpy(info->bus_info, pci_name(sis_priv->pci_dev),\n\t\tsizeof(info->bus_info));\n}\n\nstatic u32 sis900_get_msglevel(struct net_device *net_dev)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\treturn sis_priv->msg_enable;\n}\n\nstatic void sis900_set_msglevel(struct net_device *net_dev, u32 value)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tsis_priv->msg_enable = value;\n}\n\nstatic u32 sis900_get_link(struct net_device *net_dev)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\treturn mii_link_ok(&sis_priv->mii_info);\n}\n\nstatic int sis900_get_link_ksettings(struct net_device *net_dev,\n\t\t\t\t     struct ethtool_link_ksettings *cmd)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tspin_lock_irq(&sis_priv->lock);\n\tmii_ethtool_get_link_ksettings(&sis_priv->mii_info, cmd);\n\tspin_unlock_irq(&sis_priv->lock);\n\treturn 0;\n}\n\nstatic int sis900_set_link_ksettings(struct net_device *net_dev,\n\t\t\t\t     const struct ethtool_link_ksettings *cmd)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tint rt;\n\tspin_lock_irq(&sis_priv->lock);\n\trt = mii_ethtool_set_link_ksettings(&sis_priv->mii_info, cmd);\n\tspin_unlock_irq(&sis_priv->lock);\n\treturn rt;\n}\n\nstatic int sis900_nway_reset(struct net_device *net_dev)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\treturn mii_nway_restart(&sis_priv->mii_info);\n}\n\n \n\nstatic int sis900_set_wol(struct net_device *net_dev, struct ethtool_wolinfo *wol)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tvoid __iomem *ioaddr = sis_priv->ioaddr;\n\tu32 cfgpmcsr = 0, pmctrl_bits = 0;\n\n\tif (wol->wolopts == 0) {\n\t\tpci_read_config_dword(sis_priv->pci_dev, CFGPMCSR, &cfgpmcsr);\n\t\tcfgpmcsr &= ~PME_EN;\n\t\tpci_write_config_dword(sis_priv->pci_dev, CFGPMCSR, cfgpmcsr);\n\t\tsw32(pmctrl, pmctrl_bits);\n\t\tif (netif_msg_wol(sis_priv))\n\t\t\tprintk(KERN_DEBUG \"%s: Wake on LAN disabled\\n\", net_dev->name);\n\t\treturn 0;\n\t}\n\n\tif (wol->wolopts & (WAKE_MAGICSECURE | WAKE_UCAST | WAKE_MCAST\n\t\t\t\t| WAKE_BCAST | WAKE_ARP))\n\t\treturn -EINVAL;\n\n\tif (wol->wolopts & WAKE_MAGIC)\n\t\tpmctrl_bits |= MAGICPKT;\n\tif (wol->wolopts & WAKE_PHY)\n\t\tpmctrl_bits |= LINKON;\n\n\tsw32(pmctrl, pmctrl_bits);\n\n\tpci_read_config_dword(sis_priv->pci_dev, CFGPMCSR, &cfgpmcsr);\n\tcfgpmcsr |= PME_EN;\n\tpci_write_config_dword(sis_priv->pci_dev, CFGPMCSR, cfgpmcsr);\n\tif (netif_msg_wol(sis_priv))\n\t\tprintk(KERN_DEBUG \"%s: Wake on LAN enabled\\n\", net_dev->name);\n\n\treturn 0;\n}\n\nstatic void sis900_get_wol(struct net_device *net_dev, struct ethtool_wolinfo *wol)\n{\n\tstruct sis900_private *sp = netdev_priv(net_dev);\n\tvoid __iomem *ioaddr = sp->ioaddr;\n\tu32 pmctrl_bits;\n\n\tpmctrl_bits = sr32(pmctrl);\n\tif (pmctrl_bits & MAGICPKT)\n\t\twol->wolopts |= WAKE_MAGIC;\n\tif (pmctrl_bits & LINKON)\n\t\twol->wolopts |= WAKE_PHY;\n\n\twol->supported = (WAKE_PHY | WAKE_MAGIC);\n}\n\nstatic int sis900_get_eeprom_len(struct net_device *dev)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(dev);\n\n\treturn sis_priv->eeprom_size;\n}\n\nstatic int sis900_read_eeprom(struct net_device *net_dev, u8 *buf)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tvoid __iomem *ioaddr = sis_priv->ioaddr;\n\tint wait, ret = -EAGAIN;\n\tu16 signature;\n\tu16 *ebuf = (u16 *)buf;\n\tint i;\n\n\tif (sis_priv->chipset_rev == SIS96x_900_REV) {\n\t\tsw32(mear, EEREQ);\n\t\tfor (wait = 0; wait < 2000; wait++) {\n\t\t\tif (sr32(mear) & EEGNT) {\n\t\t\t\t \n\t\t\t\tfor (i = 0; i < sis_priv->eeprom_size / 2; i++)\n\t\t\t\t\tebuf[i] = (u16)read_eeprom(ioaddr, i);\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudelay(1);\n\t\t}\n\t\tsw32(mear, EEDONE);\n\t} else {\n\t\tsignature = (u16)read_eeprom(ioaddr, EEPROMSignature);\n\t\tif (signature != 0xffff && signature != 0x0000) {\n\t\t\t \n\t\t\tfor (i = 0; i < sis_priv->eeprom_size / 2; i++)\n\t\t\t\tebuf[i] = (u16)read_eeprom(ioaddr, i);\n\t\t\tret = 0;\n\t\t}\n\t}\n\treturn ret;\n}\n\n#define SIS900_EEPROM_MAGIC\t0xBABE\nstatic int sis900_get_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom, u8 *data)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(dev);\n\tu8 *eebuf;\n\tint res;\n\n\teebuf = kmalloc(sis_priv->eeprom_size, GFP_KERNEL);\n\tif (!eebuf)\n\t\treturn -ENOMEM;\n\n\teeprom->magic = SIS900_EEPROM_MAGIC;\n\tspin_lock_irq(&sis_priv->lock);\n\tres = sis900_read_eeprom(dev, eebuf);\n\tspin_unlock_irq(&sis_priv->lock);\n\tif (!res)\n\t\tmemcpy(data, eebuf + eeprom->offset, eeprom->len);\n\tkfree(eebuf);\n\treturn res;\n}\n\nstatic const struct ethtool_ops sis900_ethtool_ops = {\n\t.get_drvinfo \t= sis900_get_drvinfo,\n\t.get_msglevel\t= sis900_get_msglevel,\n\t.set_msglevel\t= sis900_set_msglevel,\n\t.get_link\t= sis900_get_link,\n\t.nway_reset\t= sis900_nway_reset,\n\t.get_wol\t= sis900_get_wol,\n\t.set_wol\t= sis900_set_wol,\n\t.get_link_ksettings = sis900_get_link_ksettings,\n\t.set_link_ksettings = sis900_set_link_ksettings,\n\t.get_eeprom_len = sis900_get_eeprom_len,\n\t.get_eeprom = sis900_get_eeprom,\n};\n\n \n\nstatic int mii_ioctl(struct net_device *net_dev, struct ifreq *rq, int cmd)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tstruct mii_ioctl_data *data = if_mii(rq);\n\n\tswitch(cmd) {\n\tcase SIOCGMIIPHY:\t\t \n\t\tdata->phy_id = sis_priv->mii->phy_addr;\n\t\tfallthrough;\n\n\tcase SIOCGMIIREG:\t\t \n\t\tdata->val_out = mdio_read(net_dev, data->phy_id & 0x1f, data->reg_num & 0x1f);\n\t\treturn 0;\n\n\tcase SIOCSMIIREG:\t\t \n\t\tmdio_write(net_dev, data->phy_id & 0x1f, data->reg_num & 0x1f, data->val_in);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n \n\nstatic int sis900_set_config(struct net_device *dev, struct ifmap *map)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(dev);\n\tstruct mii_phy *mii_phy = sis_priv->mii;\n\n\tu16 status;\n\n\tif ((map->port != (u_char)(-1)) && (map->port != dev->if_port)) {\n\t\t \n\t\tswitch(map->port){\n\t\tcase IF_PORT_UNKNOWN:  \n\t\t\tdev->if_port = map->port;\n\t\t\t \n\t\t\tnetif_carrier_off(dev);\n\n\t\t\t \n\t\t\tstatus = mdio_read(dev, mii_phy->phy_addr, MII_CONTROL);\n\n\t\t\t \n\t\t\tmdio_write(dev, mii_phy->phy_addr,\n\t\t\t\t   MII_CONTROL, status | MII_CNTL_AUTO | MII_CNTL_RST_AUTO);\n\n\t\t\tbreak;\n\n\t\tcase IF_PORT_10BASET:  \n\t\t\tdev->if_port = map->port;\n\n\t\t\t \n\t\t\tnetif_carrier_off(dev);\n\n\t\t\t \n\t\t\t \n\t\t\tstatus = mdio_read(dev, mii_phy->phy_addr, MII_CONTROL);\n\n\t\t\t \n\t\t\tmdio_write(dev, mii_phy->phy_addr,\n\t\t\t\t   MII_CONTROL, status & ~(MII_CNTL_SPEED |\n\t\t\t\t\tMII_CNTL_AUTO));\n\t\t\tbreak;\n\n\t\tcase IF_PORT_100BASET:  \n\t\tcase IF_PORT_100BASETX:  \n\t\t\tdev->if_port = map->port;\n\n\t\t\t \n\t\t\tnetif_carrier_off(dev);\n\n\t\t\t \n\t\t\t \n\t\t\tstatus = mdio_read(dev, mii_phy->phy_addr, MII_CONTROL);\n\t\t\tmdio_write(dev, mii_phy->phy_addr,\n\t\t\t\t   MII_CONTROL, (status & ~MII_CNTL_SPEED) |\n\t\t\t\t   MII_CNTL_SPEED);\n\n\t\t\tbreak;\n\n\t\tcase IF_PORT_10BASE2:  \n\t\tcase IF_PORT_AUI:  \n\t\tcase IF_PORT_100BASEFX:  \n\t\t\t \n\t\t\treturn -EOPNOTSUPP;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n\nstatic inline u16 sis900_mcast_bitnr(u8 *addr, u8 revision)\n{\n\n\tu32 crc = ether_crc(6, addr);\n\n\t \n\tif ((revision >= SIS635A_900_REV) || (revision == SIS900B_900_REV))\n\t\treturn (int)(crc >> 24);\n\telse\n\t\treturn (int)(crc >> 25);\n}\n\n \n\nstatic void set_rx_mode(struct net_device *net_dev)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tvoid __iomem *ioaddr = sis_priv->ioaddr;\n\tu16 mc_filter[16] = {0};\t \n\tint i, table_entries;\n\tu32 rx_mode;\n\n\t \n\tif((sis_priv->chipset_rev >= SIS635A_900_REV) ||\n\t\t\t(sis_priv->chipset_rev == SIS900B_900_REV))\n\t\ttable_entries = 16;\n\telse\n\t\ttable_entries = 8;\n\n\tif (net_dev->flags & IFF_PROMISC) {\n\t\t \n\t\trx_mode = RFPromiscuous;\n\t\tfor (i = 0; i < table_entries; i++)\n\t\t\tmc_filter[i] = 0xffff;\n\t} else if ((netdev_mc_count(net_dev) > multicast_filter_limit) ||\n\t\t   (net_dev->flags & IFF_ALLMULTI)) {\n\t\t \n\t\trx_mode = RFAAB | RFAAM;\n\t\tfor (i = 0; i < table_entries; i++)\n\t\t\tmc_filter[i] = 0xffff;\n\t} else {\n\t\t \n\t\tstruct netdev_hw_addr *ha;\n\t\trx_mode = RFAAB;\n\n\t\tnetdev_for_each_mc_addr(ha, net_dev) {\n\t\t\tunsigned int bit_nr;\n\n\t\t\tbit_nr = sis900_mcast_bitnr(ha->addr,\n\t\t\t\t\t\t    sis_priv->chipset_rev);\n\t\t\tmc_filter[bit_nr >> 4] |= (1 << (bit_nr & 0xf));\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < table_entries; i++) {\n                 \n\t\tsw32(rfcr, (u32)(0x00000004 + i) << RFADDR_shift);\n\t\tsw32(rfdr, mc_filter[i]);\n\t}\n\n\tsw32(rfcr, RFEN | rx_mode);\n\n\t \n\tif (net_dev->flags & IFF_LOOPBACK) {\n\t\tu32 cr_saved;\n\t\t \n\t\tcr_saved = sr32(cr);\n\t\tsw32(cr, cr_saved | TxDIS | RxDIS);\n\t\t \n\t\tsw32(txcfg, sr32(txcfg) | TxMLB);\n\t\tsw32(rxcfg, sr32(rxcfg) | RxATX);\n\t\t \n\t\tsw32(cr, cr_saved);\n\t}\n}\n\n \n\nstatic void sis900_reset(struct net_device *net_dev)\n{\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tvoid __iomem *ioaddr = sis_priv->ioaddr;\n\tu32 status = TxRCMP | RxRCMP;\n\tint i;\n\n\tsw32(ier, 0);\n\tsw32(imr, 0);\n\tsw32(rfcr, 0);\n\n\tsw32(cr, RxRESET | TxRESET | RESET | sr32(cr));\n\n\t \n\tfor (i = 0; status && (i < 1000); i++)\n\t\tstatus ^= sr32(isr) & status;\n\n\tif (sis_priv->chipset_rev >= SIS635A_900_REV ||\n\t    sis_priv->chipset_rev == SIS900B_900_REV)\n\t\tsw32(cfg, PESEL | RND_CNT);\n\telse\n\t\tsw32(cfg, PESEL);\n}\n\n \n\nstatic void sis900_remove(struct pci_dev *pci_dev)\n{\n\tstruct net_device *net_dev = pci_get_drvdata(pci_dev);\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\n\tunregister_netdev(net_dev);\n\n\twhile (sis_priv->first_mii) {\n\t\tstruct mii_phy *phy = sis_priv->first_mii;\n\n\t\tsis_priv->first_mii = phy->next;\n\t\tkfree(phy);\n\t}\n\n\tdma_free_coherent(&pci_dev->dev, RX_TOTAL_SIZE, sis_priv->rx_ring,\n\t\t\t  sis_priv->rx_ring_dma);\n\tdma_free_coherent(&pci_dev->dev, TX_TOTAL_SIZE, sis_priv->tx_ring,\n\t\t\t  sis_priv->tx_ring_dma);\n\tpci_iounmap(pci_dev, sis_priv->ioaddr);\n\tfree_netdev(net_dev);\n}\n\nstatic int __maybe_unused sis900_suspend(struct device *dev)\n{\n\tstruct net_device *net_dev = dev_get_drvdata(dev);\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tvoid __iomem *ioaddr = sis_priv->ioaddr;\n\n\tif(!netif_running(net_dev))\n\t\treturn 0;\n\n\tnetif_stop_queue(net_dev);\n\tnetif_device_detach(net_dev);\n\n\t \n\tsw32(cr, RxDIS | TxDIS | sr32(cr));\n\n\treturn 0;\n}\n\nstatic int __maybe_unused sis900_resume(struct device *dev)\n{\n\tstruct net_device *net_dev = dev_get_drvdata(dev);\n\tstruct sis900_private *sis_priv = netdev_priv(net_dev);\n\tvoid __iomem *ioaddr = sis_priv->ioaddr;\n\n\tif(!netif_running(net_dev))\n\t\treturn 0;\n\n\tsis900_init_rxfilter(net_dev);\n\n\tsis900_init_tx_ring(net_dev);\n\tsis900_init_rx_ring(net_dev);\n\n\tset_rx_mode(net_dev);\n\n\tnetif_device_attach(net_dev);\n\tnetif_start_queue(net_dev);\n\n\t \n\tsis900_set_mode(sis_priv, HW_SPEED_10_MBPS, FDX_CAPABLE_HALF_SELECTED);\n\n\t \n\tsw32(imr, RxSOVR | RxORN | RxERR | RxOK | TxURN | TxERR | TxDESC);\n\tsw32(cr, RxENA | sr32(cr));\n\tsw32(ier, IE);\n\n\tsis900_check_mode(net_dev, sis_priv->mii);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(sis900_pm_ops, sis900_suspend, sis900_resume);\n\nstatic struct pci_driver sis900_pci_driver = {\n\t.name\t\t= SIS900_MODULE_NAME,\n\t.id_table\t= sis900_pci_tbl,\n\t.probe\t\t= sis900_probe,\n\t.remove\t\t= sis900_remove,\n\t.driver.pm\t= &sis900_pm_ops,\n};\n\nstatic int __init sis900_init_module(void)\n{\n \n#ifdef MODULE\n\tprintk(version);\n#endif\n\n\treturn pci_register_driver(&sis900_pci_driver);\n}\n\nstatic void __exit sis900_cleanup_module(void)\n{\n\tpci_unregister_driver(&sis900_pci_driver);\n}\n\nmodule_init(sis900_init_module);\nmodule_exit(sis900_cleanup_module);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}