{
  "module_name": "hw_atl2_utils_fw.c",
  "hash_id": "8d8fc92001375a26aec429114fd7aecaaea0aed91f5797d4c4472c7718e1e352",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2_utils_fw.c",
  "human_readable_source": "\n \n\n#include <linux/iopoll.h>\n\n#include \"aq_hw.h\"\n#include \"aq_hw_utils.h\"\n#include \"aq_nic.h\"\n#include \"hw_atl/hw_atl_llh.h\"\n#include \"hw_atl2_utils.h\"\n#include \"hw_atl2_llh.h\"\n#include \"hw_atl2_internal.h\"\n\n#define AQ_A2_FW_READ_TRY_MAX 1000\n\n#define hw_atl2_shared_buffer_write(HW, ITEM, VARIABLE) \\\n{\\\n\tBUILD_BUG_ON_MSG((offsetof(struct fw_interface_in, ITEM) % \\\n\t\t\t sizeof(u32)) != 0,\\\n\t\t\t \"Unaligned write \" # ITEM);\\\n\tBUILD_BUG_ON_MSG((sizeof(VARIABLE) %  sizeof(u32)) != 0,\\\n\t\t\t \"Unaligned write length \" # ITEM);\\\n\thw_atl2_mif_shared_buf_write(HW,\\\n\t\t(offsetof(struct fw_interface_in, ITEM) / sizeof(u32)),\\\n\t\t(u32 *)&(VARIABLE), sizeof(VARIABLE) / sizeof(u32));\\\n}\n\n#define hw_atl2_shared_buffer_get(HW, ITEM, VARIABLE) \\\n{\\\n\tBUILD_BUG_ON_MSG((offsetof(struct fw_interface_in, ITEM) % \\\n\t\t\t sizeof(u32)) != 0,\\\n\t\t\t \"Unaligned get \" # ITEM);\\\n\tBUILD_BUG_ON_MSG((sizeof(VARIABLE) %  sizeof(u32)) != 0,\\\n\t\t\t \"Unaligned get length \" # ITEM);\\\n\thw_atl2_mif_shared_buf_get(HW, \\\n\t\t(offsetof(struct fw_interface_in, ITEM) / sizeof(u32)),\\\n\t\t(u32 *)&(VARIABLE), \\\n\t\tsizeof(VARIABLE) / sizeof(u32));\\\n}\n\n \n#define hw_atl2_shared_buffer_read(HW, ITEM, VARIABLE) \\\n{\\\n\tBUILD_BUG_ON_MSG((offsetof(struct fw_interface_out, ITEM) % \\\n\t\t\t sizeof(u32)) != 0,\\\n\t\t\t \"Unaligned read \" # ITEM);\\\n\tBUILD_BUG_ON_MSG((sizeof(VARIABLE) %  sizeof(u32)) != 0,\\\n\t\t\t \"Unaligned read length \" # ITEM);\\\n\tBUILD_BUG_ON_MSG(sizeof(VARIABLE) > sizeof(u32),\\\n\t\t\t \"Non atomic read \" # ITEM);\\\n\thw_atl2_mif_shared_buf_read(HW, \\\n\t\t(offsetof(struct fw_interface_out, ITEM) / sizeof(u32)),\\\n\t\t(u32 *)&(VARIABLE), sizeof(VARIABLE) / sizeof(u32));\\\n}\n\n#define hw_atl2_shared_buffer_read_safe(HW, ITEM, DATA) \\\n({\\\n\tBUILD_BUG_ON_MSG((offsetof(struct fw_interface_out, ITEM) % \\\n\t\t\t sizeof(u32)) != 0,\\\n\t\t\t \"Unaligned read_safe \" # ITEM);\\\n\tBUILD_BUG_ON_MSG((sizeof(((struct fw_interface_out *)0)->ITEM) % \\\n\t\t\t sizeof(u32)) != 0,\\\n\t\t\t \"Unaligned read_safe length \" # ITEM);\\\n\thw_atl2_shared_buffer_read_block((HW), \\\n\t\t(offsetof(struct fw_interface_out, ITEM) / sizeof(u32)),\\\n\t\tsizeof(((struct fw_interface_out *)0)->ITEM) / sizeof(u32),\\\n\t\t(DATA));\\\n})\n\nstatic int hw_atl2_shared_buffer_read_block(struct aq_hw_s *self,\n\t\t\t\t\t    u32 offset, u32 dwords, void *data)\n{\n\tstruct transaction_counter_s tid1, tid2;\n\tint cnt = 0;\n\n\tdo {\n\t\tdo {\n\t\t\thw_atl2_shared_buffer_read(self, transaction_id, tid1);\n\t\t\tcnt++;\n\t\t\tif (cnt > AQ_A2_FW_READ_TRY_MAX)\n\t\t\t\treturn -ETIME;\n\t\t\tif (tid1.transaction_cnt_a != tid1.transaction_cnt_b)\n\t\t\t\tmdelay(1);\n\t\t} while (tid1.transaction_cnt_a != tid1.transaction_cnt_b);\n\n\t\thw_atl2_mif_shared_buf_read(self, offset, (u32 *)data, dwords);\n\n\t\thw_atl2_shared_buffer_read(self, transaction_id, tid2);\n\n\t\tcnt++;\n\t\tif (cnt > AQ_A2_FW_READ_TRY_MAX)\n\t\t\treturn -ETIME;\n\t} while (tid2.transaction_cnt_a != tid2.transaction_cnt_b ||\n\t\t tid1.transaction_cnt_a != tid2.transaction_cnt_a);\n\n\treturn 0;\n}\n\nstatic inline int hw_atl2_shared_buffer_finish_ack(struct aq_hw_s *self)\n{\n\tu32 val;\n\tint err;\n\n\thw_atl2_mif_host_finished_write_set(self, 1U);\n\terr = readx_poll_timeout_atomic(hw_atl2_mif_mcp_finished_read_get,\n\t\t\t\t\tself, val, val == 0U,\n\t\t\t\t\t100, 100000U);\n\tWARN(err, \"hw_atl2_shared_buffer_finish_ack\");\n\n\treturn err;\n}\n\nstatic int aq_a2_fw_init(struct aq_hw_s *self)\n{\n\tstruct link_control_s link_control;\n\tu32 mtu;\n\tu32 val;\n\tint err;\n\n\thw_atl2_shared_buffer_get(self, link_control, link_control);\n\tlink_control.mode = AQ_HOST_MODE_ACTIVE;\n\thw_atl2_shared_buffer_write(self, link_control, link_control);\n\n\thw_atl2_shared_buffer_get(self, mtu, mtu);\n\tmtu = HW_ATL2_MTU_JUMBO;\n\thw_atl2_shared_buffer_write(self, mtu, mtu);\n\n\thw_atl2_mif_host_finished_write_set(self, 1U);\n\terr = readx_poll_timeout_atomic(hw_atl2_mif_mcp_finished_read_get,\n\t\t\t\t\tself, val, val == 0U,\n\t\t\t\t\t100, 5000000U);\n\tWARN(err, \"hw_atl2_shared_buffer_finish_ack\");\n\n\treturn err;\n}\n\nstatic int aq_a2_fw_deinit(struct aq_hw_s *self)\n{\n\tstruct link_control_s link_control;\n\n\thw_atl2_shared_buffer_get(self, link_control, link_control);\n\tlink_control.mode = AQ_HOST_MODE_SHUTDOWN;\n\thw_atl2_shared_buffer_write(self, link_control, link_control);\n\n\treturn hw_atl2_shared_buffer_finish_ack(self);\n}\n\nstatic void a2_link_speed_mask2fw(u32 speed,\n\t\t\t\t  struct link_options_s *link_options)\n{\n\tlink_options->rate_10G = !!(speed & AQ_NIC_RATE_10G);\n\tlink_options->rate_5G = !!(speed & AQ_NIC_RATE_5G);\n\tlink_options->rate_N5G = link_options->rate_5G;\n\tlink_options->rate_2P5G = !!(speed & AQ_NIC_RATE_2G5);\n\tlink_options->rate_N2P5G = link_options->rate_2P5G;\n\tlink_options->rate_1G = !!(speed & AQ_NIC_RATE_1G);\n\tlink_options->rate_100M = !!(speed & AQ_NIC_RATE_100M);\n\tlink_options->rate_10M = !!(speed & AQ_NIC_RATE_10M);\n\n\tlink_options->rate_1G_hd = !!(speed & AQ_NIC_RATE_1G_HALF);\n\tlink_options->rate_100M_hd = !!(speed & AQ_NIC_RATE_100M_HALF);\n\tlink_options->rate_10M_hd = !!(speed & AQ_NIC_RATE_10M_HALF);\n}\n\nstatic u32 a2_fw_dev_to_eee_mask(struct device_link_caps_s *device_link_caps)\n{\n\tu32 rate = 0;\n\n\tif (device_link_caps->eee_10G)\n\t\trate |= AQ_NIC_RATE_EEE_10G;\n\tif (device_link_caps->eee_5G)\n\t\trate |= AQ_NIC_RATE_EEE_5G;\n\tif (device_link_caps->eee_2P5G)\n\t\trate |= AQ_NIC_RATE_EEE_2G5;\n\tif (device_link_caps->eee_1G)\n\t\trate |= AQ_NIC_RATE_EEE_1G;\n\tif (device_link_caps->eee_100M)\n\t\trate |= AQ_NIC_RATE_EEE_100M;\n\n\treturn rate;\n}\n\nstatic u32 a2_fw_lkp_to_mask(struct lkp_link_caps_s *lkp_link_caps)\n{\n\tu32 rate = 0;\n\n\tif (lkp_link_caps->rate_10G)\n\t\trate |= AQ_NIC_RATE_10G;\n\tif (lkp_link_caps->rate_5G)\n\t\trate |= AQ_NIC_RATE_5G;\n\tif (lkp_link_caps->rate_2P5G)\n\t\trate |= AQ_NIC_RATE_2G5;\n\tif (lkp_link_caps->rate_1G)\n\t\trate |= AQ_NIC_RATE_1G;\n\tif (lkp_link_caps->rate_1G_hd)\n\t\trate |= AQ_NIC_RATE_1G_HALF;\n\tif (lkp_link_caps->rate_100M)\n\t\trate |= AQ_NIC_RATE_100M;\n\tif (lkp_link_caps->rate_100M_hd)\n\t\trate |= AQ_NIC_RATE_100M_HALF;\n\tif (lkp_link_caps->rate_10M)\n\t\trate |= AQ_NIC_RATE_10M;\n\tif (lkp_link_caps->rate_10M_hd)\n\t\trate |= AQ_NIC_RATE_10M_HALF;\n\n\tif (lkp_link_caps->eee_10G)\n\t\trate |= AQ_NIC_RATE_EEE_10G;\n\tif (lkp_link_caps->eee_5G)\n\t\trate |= AQ_NIC_RATE_EEE_5G;\n\tif (lkp_link_caps->eee_2P5G)\n\t\trate |= AQ_NIC_RATE_EEE_2G5;\n\tif (lkp_link_caps->eee_1G)\n\t\trate |= AQ_NIC_RATE_EEE_1G;\n\tif (lkp_link_caps->eee_100M)\n\t\trate |= AQ_NIC_RATE_EEE_100M;\n\n\treturn rate;\n}\n\nstatic int aq_a2_fw_set_link_speed(struct aq_hw_s *self, u32 speed)\n{\n\tstruct link_options_s link_options;\n\n\thw_atl2_shared_buffer_get(self, link_options, link_options);\n\tlink_options.link_up = 1U;\n\ta2_link_speed_mask2fw(speed, &link_options);\n\thw_atl2_shared_buffer_write(self, link_options, link_options);\n\n\treturn hw_atl2_shared_buffer_finish_ack(self);\n}\n\nstatic void aq_a2_fw_set_mpi_flow_control(struct aq_hw_s *self,\n\t\t\t\t\t  struct link_options_s *link_options)\n{\n\tu32 flow_control = self->aq_nic_cfg->fc.req;\n\n\tlink_options->pause_rx = !!(flow_control & AQ_NIC_FC_RX);\n\tlink_options->pause_tx = !!(flow_control & AQ_NIC_FC_TX);\n}\n\nstatic void aq_a2_fw_upd_eee_rate_bits(struct aq_hw_s *self,\n\t\t\t\t       struct link_options_s *link_options,\n\t\t\t\t       u32 eee_speeds)\n{\n\tlink_options->eee_10G =  !!(eee_speeds & AQ_NIC_RATE_EEE_10G);\n\tlink_options->eee_5G = !!(eee_speeds & AQ_NIC_RATE_EEE_5G);\n\tlink_options->eee_2P5G = !!(eee_speeds & AQ_NIC_RATE_EEE_2G5);\n\tlink_options->eee_1G = !!(eee_speeds & AQ_NIC_RATE_EEE_1G);\n\tlink_options->eee_100M = !!(eee_speeds & AQ_NIC_RATE_EEE_100M);\n}\n\nstatic int aq_a2_fw_set_state(struct aq_hw_s *self,\n\t\t\t      enum hal_atl_utils_fw_state_e state)\n{\n\tstruct link_options_s link_options;\n\n\thw_atl2_shared_buffer_get(self, link_options, link_options);\n\n\tswitch (state) {\n\tcase MPI_INIT:\n\t\tlink_options.link_up = 1U;\n\t\taq_a2_fw_upd_eee_rate_bits(self, &link_options,\n\t\t\t\t\t   self->aq_nic_cfg->eee_speeds);\n\t\taq_a2_fw_set_mpi_flow_control(self, &link_options);\n\t\tbreak;\n\tcase MPI_DEINIT:\n\t\tlink_options.link_up = 0U;\n\t\tbreak;\n\tcase MPI_RESET:\n\tcase MPI_POWER:\n\t\t \n\t\tbreak;\n\t}\n\n\thw_atl2_shared_buffer_write(self, link_options, link_options);\n\n\treturn hw_atl2_shared_buffer_finish_ack(self);\n}\n\nstatic int aq_a2_fw_update_link_status(struct aq_hw_s *self)\n{\n\tstruct lkp_link_caps_s lkp_link_caps;\n\tstruct link_status_s link_status;\n\n\thw_atl2_shared_buffer_read(self, link_status, link_status);\n\n\tswitch (link_status.link_rate) {\n\tcase AQ_A2_FW_LINK_RATE_10G:\n\t\tself->aq_link_status.mbps = 10000;\n\t\tbreak;\n\tcase AQ_A2_FW_LINK_RATE_5G:\n\t\tself->aq_link_status.mbps = 5000;\n\t\tbreak;\n\tcase AQ_A2_FW_LINK_RATE_2G5:\n\t\tself->aq_link_status.mbps = 2500;\n\t\tbreak;\n\tcase AQ_A2_FW_LINK_RATE_1G:\n\t\tself->aq_link_status.mbps = 1000;\n\t\tbreak;\n\tcase AQ_A2_FW_LINK_RATE_100M:\n\t\tself->aq_link_status.mbps = 100;\n\t\tbreak;\n\tcase AQ_A2_FW_LINK_RATE_10M:\n\t\tself->aq_link_status.mbps = 10;\n\t\tbreak;\n\tdefault:\n\t\tself->aq_link_status.mbps = 0;\n\t}\n\tself->aq_link_status.full_duplex = link_status.duplex;\n\n\thw_atl2_shared_buffer_read(self, lkp_link_caps, lkp_link_caps);\n\n\tself->aq_link_status.lp_link_speed_msk =\n\t\t\t\t a2_fw_lkp_to_mask(&lkp_link_caps);\n\tself->aq_link_status.lp_flow_control =\n\t\t\t\t((lkp_link_caps.pause_rx) ? AQ_NIC_FC_RX : 0) |\n\t\t\t\t((lkp_link_caps.pause_tx) ? AQ_NIC_FC_TX : 0);\n\n\treturn 0;\n}\n\nstatic int aq_a2_fw_get_mac_permanent(struct aq_hw_s *self, u8 *mac)\n{\n\tstruct mac_address_aligned_s mac_address;\n\n\thw_atl2_shared_buffer_get(self, mac_address, mac_address);\n\tether_addr_copy(mac, (u8 *)mac_address.aligned.mac_address);\n\n\treturn 0;\n}\n\nstatic void aq_a2_fill_a0_stats(struct aq_hw_s *self,\n\t\t\t\tstruct statistics_s *stats)\n{\n\tstruct hw_atl2_priv *priv = self->priv;\n\tstruct aq_stats_s *cs = &self->curr_stats;\n\tstruct aq_stats_s curr_stats = *cs;\n\tbool corrupted_stats = false;\n\n#define AQ_SDELTA(_N, _F)  \\\ndo { \\\n\tif (!corrupted_stats && \\\n\t    ((s64)(stats->a0.msm._F - priv->last_stats.a0.msm._F)) >= 0) \\\n\t\tcurr_stats._N += stats->a0.msm._F - priv->last_stats.a0.msm._F;\\\n\telse \\\n\t\tcorrupted_stats = true; \\\n} while (0)\n\n\tif (self->aq_link_status.mbps) {\n\t\tAQ_SDELTA(uprc, rx_unicast_frames);\n\t\tAQ_SDELTA(mprc, rx_multicast_frames);\n\t\tAQ_SDELTA(bprc, rx_broadcast_frames);\n\t\tAQ_SDELTA(erpr, rx_error_frames);\n\n\t\tAQ_SDELTA(uptc, tx_unicast_frames);\n\t\tAQ_SDELTA(mptc, tx_multicast_frames);\n\t\tAQ_SDELTA(bptc, tx_broadcast_frames);\n\t\tAQ_SDELTA(erpt, tx_errors);\n\n\t\tAQ_SDELTA(ubrc, rx_unicast_octets);\n\t\tAQ_SDELTA(ubtc, tx_unicast_octets);\n\t\tAQ_SDELTA(mbrc, rx_multicast_octets);\n\t\tAQ_SDELTA(mbtc, tx_multicast_octets);\n\t\tAQ_SDELTA(bbrc, rx_broadcast_octets);\n\t\tAQ_SDELTA(bbtc, tx_broadcast_octets);\n\n\t\tif (!corrupted_stats)\n\t\t\t*cs = curr_stats;\n\t}\n#undef AQ_SDELTA\n\n}\n\nstatic void aq_a2_fill_b0_stats(struct aq_hw_s *self,\n\t\t\t\tstruct statistics_s *stats)\n{\n\tstruct hw_atl2_priv *priv = self->priv;\n\tstruct aq_stats_s *cs = &self->curr_stats;\n\tstruct aq_stats_s curr_stats = *cs;\n\tbool corrupted_stats = false;\n\n#define AQ_SDELTA(_N, _F)  \\\ndo { \\\n\tif (!corrupted_stats && \\\n\t    ((s64)(stats->b0._F - priv->last_stats.b0._F)) >= 0) \\\n\t\tcurr_stats._N += stats->b0._F - priv->last_stats.b0._F; \\\n\telse \\\n\t\tcorrupted_stats = true; \\\n} while (0)\n\n\tif (self->aq_link_status.mbps) {\n\t\tAQ_SDELTA(uprc, rx_unicast_frames);\n\t\tAQ_SDELTA(mprc, rx_multicast_frames);\n\t\tAQ_SDELTA(bprc, rx_broadcast_frames);\n\t\tAQ_SDELTA(erpr, rx_errors);\n\t\tAQ_SDELTA(brc, rx_good_octets);\n\n\t\tAQ_SDELTA(uptc, tx_unicast_frames);\n\t\tAQ_SDELTA(mptc, tx_multicast_frames);\n\t\tAQ_SDELTA(bptc, tx_broadcast_frames);\n\t\tAQ_SDELTA(erpt, tx_errors);\n\t\tAQ_SDELTA(btc, tx_good_octets);\n\n\t\tif (!corrupted_stats)\n\t\t\t*cs = curr_stats;\n\t}\n#undef AQ_SDELTA\n}\n\nstatic int aq_a2_fw_update_stats(struct aq_hw_s *self)\n{\n\tstruct aq_stats_s *cs = &self->curr_stats;\n\tstruct hw_atl2_priv *priv = self->priv;\n\tstruct statistics_s stats;\n\tstruct version_s version;\n\tint err;\n\n\terr = hw_atl2_shared_buffer_read_safe(self, version, &version);\n\tif (err)\n\t\treturn err;\n\n\terr = hw_atl2_shared_buffer_read_safe(self, stats, &stats);\n\tif (err)\n\t\treturn err;\n\n\tif (version.drv_iface_ver == AQ_A2_FW_INTERFACE_A0)\n\t\taq_a2_fill_a0_stats(self, &stats);\n\telse\n\t\taq_a2_fill_b0_stats(self, &stats);\n\n\tcs->dma_pkt_rc = hw_atl_stats_rx_dma_good_pkt_counter_get(self);\n\tcs->dma_pkt_tc = hw_atl_stats_tx_dma_good_pkt_counter_get(self);\n\tcs->dma_oct_rc = hw_atl_stats_rx_dma_good_octet_counter_get(self);\n\tcs->dma_oct_tc = hw_atl_stats_tx_dma_good_octet_counter_get(self);\n\tcs->dpc = hw_atl_rpb_rx_dma_drop_pkt_cnt_get(self);\n\n\tmemcpy(&priv->last_stats, &stats, sizeof(stats));\n\n\treturn 0;\n}\n\nstatic int aq_a2_fw_get_phy_temp(struct aq_hw_s *self, int *temp)\n{\n\tstruct phy_health_monitor_s phy_health_monitor;\n\n\thw_atl2_shared_buffer_read_safe(self, phy_health_monitor,\n\t\t\t\t\t&phy_health_monitor);\n\n\t*temp = (int8_t)phy_health_monitor.phy_temperature * 1000;\n\treturn 0;\n}\n\nstatic int aq_a2_fw_get_mac_temp(struct aq_hw_s *self, int *temp)\n{\n\t \n\treturn aq_a2_fw_get_phy_temp(self, temp);\n}\n\nstatic int aq_a2_fw_set_eee_rate(struct aq_hw_s *self, u32 speed)\n{\n\tstruct link_options_s link_options;\n\n\thw_atl2_shared_buffer_get(self, link_options, link_options);\n\n\taq_a2_fw_upd_eee_rate_bits(self, &link_options, speed);\n\n\thw_atl2_shared_buffer_write(self, link_options, link_options);\n\n\treturn hw_atl2_shared_buffer_finish_ack(self);\n}\n\nstatic int aq_a2_fw_get_eee_rate(struct aq_hw_s *self, u32 *rate,\n\t\t\t\t u32 *supported_rates)\n{\n\tstruct device_link_caps_s device_link_caps;\n\tstruct lkp_link_caps_s lkp_link_caps;\n\n\thw_atl2_shared_buffer_read(self, device_link_caps, device_link_caps);\n\thw_atl2_shared_buffer_read(self, lkp_link_caps, lkp_link_caps);\n\n\t*supported_rates = a2_fw_dev_to_eee_mask(&device_link_caps);\n\t*rate = a2_fw_lkp_to_mask(&lkp_link_caps);\n\n\treturn 0;\n}\n\nstatic int aq_a2_fw_renegotiate(struct aq_hw_s *self)\n{\n\tstruct link_options_s link_options;\n\tint err;\n\n\thw_atl2_shared_buffer_get(self, link_options, link_options);\n\tlink_options.link_renegotiate = 1U;\n\thw_atl2_shared_buffer_write(self, link_options, link_options);\n\n\terr = hw_atl2_shared_buffer_finish_ack(self);\n\n\t \n\tlink_options.link_renegotiate = 0U;\n\thw_atl2_shared_buffer_write(self, link_options, link_options);\n\n\treturn err;\n}\n\nstatic int aq_a2_fw_set_flow_control(struct aq_hw_s *self)\n{\n\tstruct link_options_s link_options;\n\n\thw_atl2_shared_buffer_get(self, link_options, link_options);\n\n\taq_a2_fw_set_mpi_flow_control(self, &link_options);\n\n\thw_atl2_shared_buffer_write(self, link_options, link_options);\n\n\treturn hw_atl2_shared_buffer_finish_ack(self);\n}\n\nstatic u32 aq_a2_fw_get_flow_control(struct aq_hw_s *self, u32 *fcmode)\n{\n\tstruct link_status_s link_status;\n\n\thw_atl2_shared_buffer_read(self, link_status, link_status);\n\n\t*fcmode = ((link_status.pause_rx) ? AQ_NIC_FC_RX : 0) |\n\t\t  ((link_status.pause_tx) ? AQ_NIC_FC_TX : 0);\n\treturn 0;\n}\n\nstatic int aq_a2_fw_set_phyloopback(struct aq_hw_s *self, u32 mode, bool enable)\n{\n\tstruct link_options_s link_options;\n\n\thw_atl2_shared_buffer_get(self, link_options, link_options);\n\n\tswitch (mode) {\n\tcase AQ_HW_LOOPBACK_PHYINT_SYS:\n\t\tlink_options.internal_loopback = enable;\n\t\tbreak;\n\tcase AQ_HW_LOOPBACK_PHYEXT_SYS:\n\t\tlink_options.external_loopback = enable;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\thw_atl2_shared_buffer_write(self, link_options, link_options);\n\n\treturn hw_atl2_shared_buffer_finish_ack(self);\n}\n\nu32 hw_atl2_utils_get_fw_version(struct aq_hw_s *self)\n{\n\tstruct version_s version;\n\n\thw_atl2_shared_buffer_read_safe(self, version, &version);\n\n\t \n\treturn version.bundle.major << 24 |\n\t       version.bundle.minor << 16 |\n\t       version.bundle.build;\n}\n\nint hw_atl2_utils_get_action_resolve_table_caps(struct aq_hw_s *self,\n\t\t\t\t\t\tu8 *base_index, u8 *count)\n{\n\tstruct filter_caps_s filter_caps;\n\tint err;\n\n\terr = hw_atl2_shared_buffer_read_safe(self, filter_caps, &filter_caps);\n\tif (err)\n\t\treturn err;\n\n\t*base_index = filter_caps.rslv_tbl_base_index;\n\t*count = filter_caps.rslv_tbl_count;\n\treturn 0;\n}\n\nstatic int aq_a2_fw_set_downshift(struct aq_hw_s *self, u32 counter)\n{\n\tstruct link_options_s link_options;\n\n\thw_atl2_shared_buffer_get(self, link_options, link_options);\n\tlink_options.downshift = !!counter;\n\tlink_options.downshift_retry = counter;\n\thw_atl2_shared_buffer_write(self, link_options, link_options);\n\n\treturn hw_atl2_shared_buffer_finish_ack(self);\n}\n\nconst struct aq_fw_ops aq_a2_fw_ops = {\n\t.init               = aq_a2_fw_init,\n\t.deinit             = aq_a2_fw_deinit,\n\t.reset              = NULL,\n\t.renegotiate        = aq_a2_fw_renegotiate,\n\t.get_mac_permanent  = aq_a2_fw_get_mac_permanent,\n\t.set_link_speed     = aq_a2_fw_set_link_speed,\n\t.set_state          = aq_a2_fw_set_state,\n\t.update_link_status = aq_a2_fw_update_link_status,\n\t.update_stats       = aq_a2_fw_update_stats,\n\t.get_mac_temp       = aq_a2_fw_get_mac_temp,\n\t.get_phy_temp       = aq_a2_fw_get_phy_temp,\n\t.set_eee_rate       = aq_a2_fw_set_eee_rate,\n\t.get_eee_rate       = aq_a2_fw_get_eee_rate,\n\t.set_flow_control   = aq_a2_fw_set_flow_control,\n\t.get_flow_control   = aq_a2_fw_get_flow_control,\n\t.set_phyloopback    = aq_a2_fw_set_phyloopback,\n\t.set_downshift      = aq_a2_fw_set_downshift,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}