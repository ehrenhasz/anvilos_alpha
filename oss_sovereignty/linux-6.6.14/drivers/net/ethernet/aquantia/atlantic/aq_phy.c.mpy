{
  "module_name": "aq_phy.c",
  "hash_id": "8fa83bed9e1d82b192581ea2657d14b99b26ec9be8d0cd518ca3502a0a2164a0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/aquantia/atlantic/aq_phy.c",
  "human_readable_source": "\n \n\n#include \"aq_phy.h\"\n\n#define HW_ATL_PTP_DISABLE_MSK\tBIT(10)\n\nbool aq_mdio_busy_wait(struct aq_hw_s *aq_hw)\n{\n\tint err = 0;\n\tu32 val;\n\n\terr = readx_poll_timeout_atomic(hw_atl_mdio_busy_get, aq_hw,\n\t\t\t\t\tval, val == 0U, 10U, 100000U);\n\n\tif (err < 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nu16 aq_mdio_read_word(struct aq_hw_s *aq_hw, u16 mmd, u16 addr)\n{\n\tu16 phy_addr = aq_hw->phy_id << 5 | mmd;\n\n\t \n\thw_atl_glb_mdio_iface4_set(aq_hw, (addr & HW_ATL_MDIO_ADDRESS_MSK) <<\n\t\t\t\t   HW_ATL_MDIO_ADDRESS_SHIFT);\n\t \n\thw_atl_glb_mdio_iface2_set(aq_hw, HW_ATL_MDIO_EXECUTE_OPERATION_MSK |\n\t\t\t\t   (3 << HW_ATL_MDIO_OP_MODE_SHIFT) |\n\t\t\t\t   ((phy_addr & HW_ATL_MDIO_PHY_ADDRESS_MSK) <<\n\t\t\t\t    HW_ATL_MDIO_PHY_ADDRESS_SHIFT));\n\n\taq_mdio_busy_wait(aq_hw);\n\n\t \n\thw_atl_glb_mdio_iface2_set(aq_hw, HW_ATL_MDIO_EXECUTE_OPERATION_MSK |\n\t\t\t\t   (1 << HW_ATL_MDIO_OP_MODE_SHIFT) |\n\t\t\t\t   ((phy_addr & HW_ATL_MDIO_PHY_ADDRESS_MSK) <<\n\t\t\t\t    HW_ATL_MDIO_PHY_ADDRESS_SHIFT));\n\t \n\taq_mdio_busy_wait(aq_hw);\n\n\treturn (u16)hw_atl_glb_mdio_iface5_get(aq_hw);\n}\n\nvoid aq_mdio_write_word(struct aq_hw_s *aq_hw, u16 mmd, u16 addr, u16 data)\n{\n\tu16 phy_addr = aq_hw->phy_id << 5 | mmd;\n\n\t \n\thw_atl_glb_mdio_iface4_set(aq_hw, (addr & HW_ATL_MDIO_ADDRESS_MSK) <<\n\t\t\t\t   HW_ATL_MDIO_ADDRESS_SHIFT);\n\t \n\thw_atl_glb_mdio_iface2_set(aq_hw, HW_ATL_MDIO_EXECUTE_OPERATION_MSK |\n\t\t\t\t   (3 << HW_ATL_MDIO_OP_MODE_SHIFT) |\n\t\t\t\t   ((phy_addr & HW_ATL_MDIO_PHY_ADDRESS_MSK) <<\n\t\t\t\t    HW_ATL_MDIO_PHY_ADDRESS_SHIFT));\n\n\taq_mdio_busy_wait(aq_hw);\n\n\thw_atl_glb_mdio_iface3_set(aq_hw, (data & HW_ATL_MDIO_WRITE_DATA_MSK) <<\n\t\t\t\t   HW_ATL_MDIO_WRITE_DATA_SHIFT);\n\t \n\thw_atl_glb_mdio_iface2_set(aq_hw, HW_ATL_MDIO_EXECUTE_OPERATION_MSK |\n\t\t\t\t   (2 << HW_ATL_MDIO_OP_MODE_SHIFT) |\n\t\t\t\t   ((phy_addr & HW_ATL_MDIO_PHY_ADDRESS_MSK) <<\n\t\t\t\t    HW_ATL_MDIO_PHY_ADDRESS_SHIFT));\n\n\taq_mdio_busy_wait(aq_hw);\n}\n\nu16 aq_phy_read_reg(struct aq_hw_s *aq_hw, u16 mmd, u16 address)\n{\n\tint err = 0;\n\tu32 val;\n\n\terr = readx_poll_timeout_atomic(hw_atl_sem_mdio_get, aq_hw,\n\t\t\t\t\tval, val == 1U, 10U, 100000U);\n\n\tif (err < 0) {\n\t\terr = 0xffff;\n\t\tgoto err_exit;\n\t}\n\n\terr = aq_mdio_read_word(aq_hw, mmd, address);\n\n\thw_atl_reg_glb_cpu_sem_set(aq_hw, 1U, HW_ATL_FW_SM_MDIO);\n\nerr_exit:\n\treturn err;\n}\n\nvoid aq_phy_write_reg(struct aq_hw_s *aq_hw, u16 mmd, u16 address, u16 data)\n{\n\tint err = 0;\n\tu32 val;\n\n\terr = readx_poll_timeout_atomic(hw_atl_sem_mdio_get, aq_hw,\n\t\t\t\t\tval, val == 1U, 10U, 100000U);\n\tif (err < 0)\n\t\treturn;\n\n\taq_mdio_write_word(aq_hw, mmd, address, data);\n\thw_atl_reg_glb_cpu_sem_set(aq_hw, 1U, HW_ATL_FW_SM_MDIO);\n}\n\nbool aq_phy_init_phy_id(struct aq_hw_s *aq_hw)\n{\n\tu16 val;\n\n\tfor (aq_hw->phy_id = 0; aq_hw->phy_id < HW_ATL_PHY_ID_MAX;\n\t     ++aq_hw->phy_id) {\n\t\t \n\t\tval = aq_phy_read_reg(aq_hw, MDIO_MMD_PMAPMD, 3);\n\n\t\tif (val != 0xffff)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool aq_phy_init(struct aq_hw_s *aq_hw)\n{\n\tu32 dev_id;\n\n\tif (aq_hw->phy_id == HW_ATL_PHY_ID_MAX)\n\t\tif (!aq_phy_init_phy_id(aq_hw))\n\t\t\treturn false;\n\n\t \n\tdev_id = aq_phy_read_reg(aq_hw, MDIO_MMD_PMAPMD, 2);\n\tdev_id <<= 16;\n\tdev_id |= aq_phy_read_reg(aq_hw, MDIO_MMD_PMAPMD, 3);\n\n\tif (dev_id == 0xffffffff) {\n\t\taq_hw->phy_id = HW_ATL_PHY_ID_MAX;\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid aq_phy_disable_ptp(struct aq_hw_s *aq_hw)\n{\n\tstatic const u16 ptp_registers[] = {\n\t\t0x031e,\n\t\t0x031d,\n\t\t0x031c,\n\t\t0x031b,\n\t};\n\tu16 val;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ptp_registers); i++) {\n\t\tval = aq_phy_read_reg(aq_hw, MDIO_MMD_VEND1,\n\t\t\t\t      ptp_registers[i]);\n\n\t\taq_phy_write_reg(aq_hw, MDIO_MMD_VEND1,\n\t\t\t\t ptp_registers[i],\n\t\t\t\t val & ~HW_ATL_PTP_DISABLE_MSK);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}