{
  "module_name": "aq_ptp.c",
  "hash_id": "a2575ef31b94904908fdaa776d9b08665864ac6a25a98969625e11d2aba9874f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/aquantia/atlantic/aq_ptp.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/ptp_clock_kernel.h>\n#include <linux/ptp_classify.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n\n#include \"aq_nic.h\"\n#include \"aq_ptp.h\"\n#include \"aq_ring.h\"\n#include \"aq_phy.h\"\n#include \"aq_filters.h\"\n\n#if IS_REACHABLE(CONFIG_PTP_1588_CLOCK)\n\n#define AQ_PTP_TX_TIMEOUT        (HZ *  10)\n\n#define POLL_SYNC_TIMER_MS 15\n\nenum ptp_speed_offsets {\n\tptp_offset_idx_10 = 0,\n\tptp_offset_idx_100,\n\tptp_offset_idx_1000,\n\tptp_offset_idx_2500,\n\tptp_offset_idx_5000,\n\tptp_offset_idx_10000,\n};\n\nstruct ptp_skb_ring {\n\tstruct sk_buff **buff;\n\tspinlock_t lock;\n\tunsigned int size;\n\tunsigned int head;\n\tunsigned int tail;\n};\n\nstruct ptp_tx_timeout {\n\tspinlock_t lock;\n\tbool active;\n\tunsigned long tx_start;\n};\n\nstruct aq_ptp_s {\n\tstruct aq_nic_s *aq_nic;\n\tstruct hwtstamp_config hwtstamp_config;\n\tspinlock_t ptp_lock;\n\tspinlock_t ptp_ring_lock;\n\tstruct ptp_clock *ptp_clock;\n\tstruct ptp_clock_info ptp_info;\n\n\tatomic_t offset_egress;\n\tatomic_t offset_ingress;\n\n\tstruct aq_ring_param_s ptp_ring_param;\n\n\tstruct ptp_tx_timeout ptp_tx_timeout;\n\n\tunsigned int idx_vector;\n\tstruct napi_struct napi;\n\n\tstruct aq_ring_s ptp_tx;\n\tstruct aq_ring_s ptp_rx;\n\tstruct aq_ring_s hwts_rx;\n\n\tstruct ptp_skb_ring skb_ring;\n\n\tstruct aq_rx_filter_l3l4 udp_filter;\n\tstruct aq_rx_filter_l2 eth_type_filter;\n\n\tstruct delayed_work poll_sync;\n\tu32 poll_timeout_ms;\n\n\tbool extts_pin_enabled;\n\tu64 last_sync1588_ts;\n\n\tbool a1_ptp;\n};\n\nstruct ptp_tm_offset {\n\tunsigned int mbps;\n\tint egress;\n\tint ingress;\n};\n\nstatic struct ptp_tm_offset ptp_offset[6];\n\nvoid aq_ptp_tm_offset_set(struct aq_nic_s *aq_nic, unsigned int mbps)\n{\n\tstruct aq_ptp_s *aq_ptp = aq_nic->aq_ptp;\n\tint i, egress, ingress;\n\n\tif (!aq_ptp)\n\t\treturn;\n\n\tegress = 0;\n\tingress = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(ptp_offset); i++) {\n\t\tif (mbps == ptp_offset[i].mbps) {\n\t\t\tegress = ptp_offset[i].egress;\n\t\t\tingress = ptp_offset[i].ingress;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tatomic_set(&aq_ptp->offset_egress, egress);\n\tatomic_set(&aq_ptp->offset_ingress, ingress);\n}\n\nstatic int __aq_ptp_skb_put(struct ptp_skb_ring *ring, struct sk_buff *skb)\n{\n\tunsigned int next_head = (ring->head + 1) % ring->size;\n\n\tif (next_head == ring->tail)\n\t\treturn -ENOMEM;\n\n\tring->buff[ring->head] = skb_get(skb);\n\tring->head = next_head;\n\n\treturn 0;\n}\n\nstatic int aq_ptp_skb_put(struct ptp_skb_ring *ring, struct sk_buff *skb)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&ring->lock, flags);\n\tret = __aq_ptp_skb_put(ring, skb);\n\tspin_unlock_irqrestore(&ring->lock, flags);\n\n\treturn ret;\n}\n\nstatic struct sk_buff *__aq_ptp_skb_get(struct ptp_skb_ring *ring)\n{\n\tstruct sk_buff *skb;\n\n\tif (ring->tail == ring->head)\n\t\treturn NULL;\n\n\tskb = ring->buff[ring->tail];\n\tring->tail = (ring->tail + 1) % ring->size;\n\n\treturn skb;\n}\n\nstatic struct sk_buff *aq_ptp_skb_get(struct ptp_skb_ring *ring)\n{\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\n\tspin_lock_irqsave(&ring->lock, flags);\n\tskb = __aq_ptp_skb_get(ring);\n\tspin_unlock_irqrestore(&ring->lock, flags);\n\n\treturn skb;\n}\n\nstatic unsigned int aq_ptp_skb_buf_len(struct ptp_skb_ring *ring)\n{\n\tunsigned long flags;\n\tunsigned int len;\n\n\tspin_lock_irqsave(&ring->lock, flags);\n\tlen = (ring->head >= ring->tail) ?\n\tring->head - ring->tail :\n\tring->size - ring->tail + ring->head;\n\tspin_unlock_irqrestore(&ring->lock, flags);\n\n\treturn len;\n}\n\nstatic int aq_ptp_skb_ring_init(struct ptp_skb_ring *ring, unsigned int size)\n{\n\tstruct sk_buff **buff = kmalloc(sizeof(*buff) * size, GFP_KERNEL);\n\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&ring->lock);\n\n\tring->buff = buff;\n\tring->size = size;\n\tring->head = 0;\n\tring->tail = 0;\n\n\treturn 0;\n}\n\nstatic void aq_ptp_skb_ring_clean(struct ptp_skb_ring *ring)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = aq_ptp_skb_get(ring)) != NULL)\n\t\tdev_kfree_skb_any(skb);\n}\n\nstatic void aq_ptp_skb_ring_release(struct ptp_skb_ring *ring)\n{\n\tif (ring->buff) {\n\t\taq_ptp_skb_ring_clean(ring);\n\t\tkfree(ring->buff);\n\t\tring->buff = NULL;\n\t}\n}\n\nstatic void aq_ptp_tx_timeout_init(struct ptp_tx_timeout *timeout)\n{\n\tspin_lock_init(&timeout->lock);\n\ttimeout->active = false;\n}\n\nstatic void aq_ptp_tx_timeout_start(struct aq_ptp_s *aq_ptp)\n{\n\tstruct ptp_tx_timeout *timeout = &aq_ptp->ptp_tx_timeout;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&timeout->lock, flags);\n\ttimeout->active = true;\n\ttimeout->tx_start = jiffies;\n\tspin_unlock_irqrestore(&timeout->lock, flags);\n}\n\nstatic void aq_ptp_tx_timeout_update(struct aq_ptp_s *aq_ptp)\n{\n\tif (!aq_ptp_skb_buf_len(&aq_ptp->skb_ring)) {\n\t\tstruct ptp_tx_timeout *timeout = &aq_ptp->ptp_tx_timeout;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&timeout->lock, flags);\n\t\ttimeout->active = false;\n\t\tspin_unlock_irqrestore(&timeout->lock, flags);\n\t}\n}\n\nstatic void aq_ptp_tx_timeout_check(struct aq_ptp_s *aq_ptp)\n{\n\tstruct ptp_tx_timeout *timeout = &aq_ptp->ptp_tx_timeout;\n\tunsigned long flags;\n\tbool timeout_flag;\n\n\ttimeout_flag = false;\n\n\tspin_lock_irqsave(&timeout->lock, flags);\n\tif (timeout->active) {\n\t\ttimeout_flag = time_is_before_jiffies(timeout->tx_start +\n\t\t\t\t\t\t      AQ_PTP_TX_TIMEOUT);\n\t\t \n\t\tif (timeout_flag)\n\t\t\ttimeout->active = false;\n\t}\n\tspin_unlock_irqrestore(&timeout->lock, flags);\n\n\tif (timeout_flag) {\n\t\taq_ptp_skb_ring_clean(&aq_ptp->skb_ring);\n\t\tnetdev_err(aq_ptp->aq_nic->ndev,\n\t\t\t   \"PTP Timeout. Clearing Tx Timestamp SKBs\\n\");\n\t}\n}\n\n \nstatic int aq_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct aq_ptp_s *aq_ptp = container_of(ptp, struct aq_ptp_s, ptp_info);\n\tstruct aq_nic_s *aq_nic = aq_ptp->aq_nic;\n\n\tmutex_lock(&aq_nic->fwreq_mutex);\n\taq_nic->aq_hw_ops->hw_adj_clock_freq(aq_nic->aq_hw,\n\t\t\t\t\t     scaled_ppm_to_ppb(scaled_ppm));\n\tmutex_unlock(&aq_nic->fwreq_mutex);\n\n\treturn 0;\n}\n\n \nstatic int aq_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct aq_ptp_s *aq_ptp = container_of(ptp, struct aq_ptp_s, ptp_info);\n\tstruct aq_nic_s *aq_nic = aq_ptp->aq_nic;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&aq_ptp->ptp_lock, flags);\n\taq_nic->aq_hw_ops->hw_adj_sys_clock(aq_nic->aq_hw, delta);\n\tspin_unlock_irqrestore(&aq_ptp->ptp_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int aq_ptp_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\n{\n\tstruct aq_ptp_s *aq_ptp = container_of(ptp, struct aq_ptp_s, ptp_info);\n\tstruct aq_nic_s *aq_nic = aq_ptp->aq_nic;\n\tunsigned long flags;\n\tu64 ns;\n\n\tspin_lock_irqsave(&aq_ptp->ptp_lock, flags);\n\taq_nic->aq_hw_ops->hw_get_ptp_ts(aq_nic->aq_hw, &ns);\n\tspin_unlock_irqrestore(&aq_ptp->ptp_lock, flags);\n\n\t*ts = ns_to_timespec64(ns);\n\n\treturn 0;\n}\n\n \nstatic int aq_ptp_settime(struct ptp_clock_info *ptp,\n\t\t\t  const struct timespec64 *ts)\n{\n\tstruct aq_ptp_s *aq_ptp = container_of(ptp, struct aq_ptp_s, ptp_info);\n\tstruct aq_nic_s *aq_nic = aq_ptp->aq_nic;\n\tunsigned long flags;\n\tu64 ns = timespec64_to_ns(ts);\n\tu64 now;\n\n\tspin_lock_irqsave(&aq_ptp->ptp_lock, flags);\n\taq_nic->aq_hw_ops->hw_get_ptp_ts(aq_nic->aq_hw, &now);\n\taq_nic->aq_hw_ops->hw_adj_sys_clock(aq_nic->aq_hw, (s64)ns - (s64)now);\n\n\tspin_unlock_irqrestore(&aq_ptp->ptp_lock, flags);\n\n\treturn 0;\n}\n\nstatic void aq_ptp_convert_to_hwtstamp(struct aq_ptp_s *aq_ptp,\n\t\t\t\t       struct skb_shared_hwtstamps *hwtstamp,\n\t\t\t\t       u64 timestamp)\n{\n\tmemset(hwtstamp, 0, sizeof(*hwtstamp));\n\thwtstamp->hwtstamp = ns_to_ktime(timestamp);\n}\n\nstatic int aq_ptp_hw_pin_conf(struct aq_nic_s *aq_nic, u32 pin_index, u64 start,\n\t\t\t      u64 period)\n{\n\tif (period)\n\t\tnetdev_dbg(aq_nic->ndev,\n\t\t\t   \"Enable GPIO %d pulsing, start time %llu, period %u\\n\",\n\t\t\t   pin_index, start, (u32)period);\n\telse\n\t\tnetdev_dbg(aq_nic->ndev,\n\t\t\t   \"Disable GPIO %d pulsing, start time %llu, period %u\\n\",\n\t\t\t   pin_index, start, (u32)period);\n\n\t \n\tmutex_lock(&aq_nic->fwreq_mutex);\n\taq_nic->aq_hw_ops->hw_gpio_pulse(aq_nic->aq_hw, pin_index,\n\t\t\t\t\t start, (u32)period);\n\tmutex_unlock(&aq_nic->fwreq_mutex);\n\n\treturn 0;\n}\n\nstatic int aq_ptp_perout_pin_configure(struct ptp_clock_info *ptp,\n\t\t\t\t       struct ptp_clock_request *rq, int on)\n{\n\tstruct aq_ptp_s *aq_ptp = container_of(ptp, struct aq_ptp_s, ptp_info);\n\tstruct ptp_clock_time *t = &rq->perout.period;\n\tstruct ptp_clock_time *s = &rq->perout.start;\n\tstruct aq_nic_s *aq_nic = aq_ptp->aq_nic;\n\tu64 start, period;\n\tu32 pin_index = rq->perout.index;\n\n\t \n\tif (pin_index >= ptp->n_per_out)\n\t\treturn -EINVAL;\n\n\t \n\tif (t->sec > 4 || t->sec < 0)\n\t\treturn -ERANGE;\n\n\t \n\tperiod = on ? t->sec * NSEC_PER_SEC + t->nsec : 0;\n\n\t \n\tif (period > U32_MAX)\n\t\treturn -ERANGE;\n\t \n\t \n\tstart = on ? s->sec * NSEC_PER_SEC + s->nsec : 0;\n\n\taq_ptp_hw_pin_conf(aq_nic, pin_index, start, period);\n\n\treturn 0;\n}\n\nstatic int aq_ptp_pps_pin_configure(struct ptp_clock_info *ptp,\n\t\t\t\t    struct ptp_clock_request *rq, int on)\n{\n\tstruct aq_ptp_s *aq_ptp = container_of(ptp, struct aq_ptp_s, ptp_info);\n\tstruct aq_nic_s *aq_nic = aq_ptp->aq_nic;\n\tu64 start, period;\n\tu32 pin_index = 0;\n\tu32 rest = 0;\n\n\t \n\tif (pin_index >= ptp->n_per_out)\n\t\treturn -EINVAL;\n\n\taq_nic->aq_hw_ops->hw_get_ptp_ts(aq_nic->aq_hw, &start);\n\tdiv_u64_rem(start, NSEC_PER_SEC, &rest);\n\tperiod = on ? NSEC_PER_SEC : 0;  \n\tstart = on ? start - rest + NSEC_PER_SEC *\n\t\t(rest > 990000000LL ? 2 : 1) : 0;\n\n\taq_ptp_hw_pin_conf(aq_nic, pin_index, start, period);\n\n\treturn 0;\n}\n\nstatic void aq_ptp_extts_pin_ctrl(struct aq_ptp_s *aq_ptp)\n{\n\tstruct aq_nic_s *aq_nic = aq_ptp->aq_nic;\n\tu32 enable = aq_ptp->extts_pin_enabled;\n\n\tif (aq_nic->aq_hw_ops->hw_extts_gpio_enable)\n\t\taq_nic->aq_hw_ops->hw_extts_gpio_enable(aq_nic->aq_hw, 0,\n\t\t\t\t\t\t\tenable);\n}\n\nstatic int aq_ptp_extts_pin_configure(struct ptp_clock_info *ptp,\n\t\t\t\t      struct ptp_clock_request *rq, int on)\n{\n\tstruct aq_ptp_s *aq_ptp = container_of(ptp, struct aq_ptp_s, ptp_info);\n\n\tu32 pin_index = rq->extts.index;\n\n\tif (pin_index >= ptp->n_ext_ts)\n\t\treturn -EINVAL;\n\n\taq_ptp->extts_pin_enabled = !!on;\n\tif (on) {\n\t\taq_ptp->poll_timeout_ms = POLL_SYNC_TIMER_MS;\n\t\tcancel_delayed_work_sync(&aq_ptp->poll_sync);\n\t\tschedule_delayed_work(&aq_ptp->poll_sync,\n\t\t\t\t      msecs_to_jiffies(aq_ptp->poll_timeout_ms));\n\t}\n\n\taq_ptp_extts_pin_ctrl(aq_ptp);\n\treturn 0;\n}\n\n \nstatic int aq_ptp_gpio_feature_enable(struct ptp_clock_info *ptp,\n\t\t\t\t      struct ptp_clock_request *rq, int on)\n{\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_EXTTS:\n\t\treturn aq_ptp_extts_pin_configure(ptp, rq, on);\n\tcase PTP_CLK_REQ_PEROUT:\n\t\treturn aq_ptp_perout_pin_configure(ptp, rq, on);\n\tcase PTP_CLK_REQ_PPS:\n\t\treturn aq_ptp_pps_pin_configure(ptp, rq, on);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int aq_ptp_verify(struct ptp_clock_info *ptp, unsigned int pin,\n\t\t\t enum ptp_pin_function func, unsigned int chan)\n{\n\t \n\tif (!ptp->pin_config || pin >= ptp->n_pins)\n\t\treturn -EINVAL;\n\n\t \n\tif (chan != ptp->pin_config[pin].chan)\n\t\treturn -EINVAL;\n\n\t \n\tif (func != ptp->pin_config[pin].func)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nvoid aq_ptp_tx_hwtstamp(struct aq_nic_s *aq_nic, u64 timestamp)\n{\n\tstruct aq_ptp_s *aq_ptp = aq_nic->aq_ptp;\n\tstruct sk_buff *skb = aq_ptp_skb_get(&aq_ptp->skb_ring);\n\tstruct skb_shared_hwtstamps hwtstamp;\n\n\tif (!skb) {\n\t\tnetdev_err(aq_nic->ndev, \"have timestamp but tx_queues empty\\n\");\n\t\treturn;\n\t}\n\n\ttimestamp += atomic_read(&aq_ptp->offset_egress);\n\taq_ptp_convert_to_hwtstamp(aq_ptp, &hwtstamp, timestamp);\n\tskb_tstamp_tx(skb, &hwtstamp);\n\tdev_kfree_skb_any(skb);\n\n\taq_ptp_tx_timeout_update(aq_ptp);\n}\n\n \nstatic void aq_ptp_rx_hwtstamp(struct aq_ptp_s *aq_ptp, struct skb_shared_hwtstamps *shhwtstamps,\n\t\t\t       u64 timestamp)\n{\n\ttimestamp -= atomic_read(&aq_ptp->offset_ingress);\n\taq_ptp_convert_to_hwtstamp(aq_ptp, shhwtstamps, timestamp);\n}\n\nvoid aq_ptp_hwtstamp_config_get(struct aq_ptp_s *aq_ptp,\n\t\t\t\tstruct hwtstamp_config *config)\n{\n\t*config = aq_ptp->hwtstamp_config;\n}\n\nstatic void aq_ptp_prepare_filters(struct aq_ptp_s *aq_ptp)\n{\n\taq_ptp->udp_filter.cmd = HW_ATL_RX_ENABLE_FLTR_L3L4 |\n\t\t\t       HW_ATL_RX_ENABLE_CMP_PROT_L4 |\n\t\t\t       HW_ATL_RX_UDP |\n\t\t\t       HW_ATL_RX_ENABLE_CMP_DEST_PORT_L4 |\n\t\t\t       HW_ATL_RX_HOST << HW_ATL_RX_ACTION_FL3F4_SHIFT |\n\t\t\t       HW_ATL_RX_ENABLE_QUEUE_L3L4 |\n\t\t\t       aq_ptp->ptp_rx.idx << HW_ATL_RX_QUEUE_FL3L4_SHIFT;\n\taq_ptp->udp_filter.p_dst = PTP_EV_PORT;\n\n\taq_ptp->eth_type_filter.ethertype = ETH_P_1588;\n\taq_ptp->eth_type_filter.queue = aq_ptp->ptp_rx.idx;\n}\n\nint aq_ptp_hwtstamp_config_set(struct aq_ptp_s *aq_ptp,\n\t\t\t       struct hwtstamp_config *config)\n{\n\tstruct aq_nic_s *aq_nic = aq_ptp->aq_nic;\n\tconst struct aq_hw_ops *hw_ops;\n\tint err = 0;\n\n\thw_ops = aq_nic->aq_hw_ops;\n\tif (config->tx_type == HWTSTAMP_TX_ON ||\n\t    config->rx_filter == HWTSTAMP_FILTER_PTP_V2_EVENT) {\n\t\taq_ptp_prepare_filters(aq_ptp);\n\t\tif (hw_ops->hw_filter_l3l4_set) {\n\t\t\terr = hw_ops->hw_filter_l3l4_set(aq_nic->aq_hw,\n\t\t\t\t\t\t\t &aq_ptp->udp_filter);\n\t\t}\n\t\tif (!err && hw_ops->hw_filter_l2_set) {\n\t\t\terr = hw_ops->hw_filter_l2_set(aq_nic->aq_hw,\n\t\t\t\t\t\t       &aq_ptp->eth_type_filter);\n\t\t}\n\t\taq_utils_obj_set(&aq_nic->flags, AQ_NIC_PTP_DPATH_UP);\n\t} else {\n\t\taq_ptp->udp_filter.cmd &= ~HW_ATL_RX_ENABLE_FLTR_L3L4;\n\t\tif (hw_ops->hw_filter_l3l4_set) {\n\t\t\terr = hw_ops->hw_filter_l3l4_set(aq_nic->aq_hw,\n\t\t\t\t\t\t\t &aq_ptp->udp_filter);\n\t\t}\n\t\tif (!err && hw_ops->hw_filter_l2_clear) {\n\t\t\terr = hw_ops->hw_filter_l2_clear(aq_nic->aq_hw,\n\t\t\t\t\t\t\t&aq_ptp->eth_type_filter);\n\t\t}\n\t\taq_utils_obj_clear(&aq_nic->flags, AQ_NIC_PTP_DPATH_UP);\n\t}\n\n\tif (err)\n\t\treturn -EREMOTEIO;\n\n\taq_ptp->hwtstamp_config = *config;\n\n\treturn 0;\n}\n\nbool aq_ptp_ring(struct aq_nic_s *aq_nic, struct aq_ring_s *ring)\n{\n\tstruct aq_ptp_s *aq_ptp = aq_nic->aq_ptp;\n\n\tif (!aq_ptp)\n\t\treturn false;\n\n\treturn &aq_ptp->ptp_tx == ring ||\n\t       &aq_ptp->ptp_rx == ring || &aq_ptp->hwts_rx == ring;\n}\n\nu16 aq_ptp_extract_ts(struct aq_nic_s *aq_nic, struct skb_shared_hwtstamps *shhwtstamps, u8 *p,\n\t\t      unsigned int len)\n{\n\tstruct aq_ptp_s *aq_ptp = aq_nic->aq_ptp;\n\tu64 timestamp = 0;\n\tu16 ret = aq_nic->aq_hw_ops->rx_extract_ts(aq_nic->aq_hw,\n\t\t\t\t\t\t   p, len, &timestamp);\n\n\tif (ret > 0)\n\t\taq_ptp_rx_hwtstamp(aq_ptp, shhwtstamps, timestamp);\n\n\treturn ret;\n}\n\nstatic int aq_ptp_poll(struct napi_struct *napi, int budget)\n{\n\tstruct aq_ptp_s *aq_ptp = container_of(napi, struct aq_ptp_s, napi);\n\tstruct aq_nic_s *aq_nic = aq_ptp->aq_nic;\n\tbool was_cleaned = false;\n\tint work_done = 0;\n\tint err;\n\n\t \n\terr = aq_nic->aq_hw_ops->hw_ring_tx_head_update(aq_nic->aq_hw,\n\t\t\t\t\t\t\t&aq_ptp->ptp_tx);\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\tif (aq_ptp->ptp_tx.sw_head != aq_ptp->ptp_tx.hw_head) {\n\t\taq_ring_tx_clean(&aq_ptp->ptp_tx);\n\n\t\twas_cleaned = true;\n\t}\n\n\t \n\terr = aq_nic->aq_hw_ops->hw_ring_hwts_rx_receive(aq_nic->aq_hw,\n\t\t\t\t\t\t\t &aq_ptp->hwts_rx);\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\tif (aq_ptp->hwts_rx.sw_head != aq_ptp->hwts_rx.hw_head) {\n\t\taq_ring_hwts_rx_clean(&aq_ptp->hwts_rx, aq_nic);\n\n\t\terr = aq_nic->aq_hw_ops->hw_ring_hwts_rx_fill(aq_nic->aq_hw,\n\t\t\t\t\t\t\t      &aq_ptp->hwts_rx);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\twas_cleaned = true;\n\t}\n\n\t \n\terr = aq_nic->aq_hw_ops->hw_ring_rx_receive(aq_nic->aq_hw,\n\t\t\t\t\t\t    &aq_ptp->ptp_rx);\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\tif (aq_ptp->ptp_rx.sw_head != aq_ptp->ptp_rx.hw_head) {\n\t\tunsigned int sw_tail_old;\n\n\t\terr = aq_ring_rx_clean(&aq_ptp->ptp_rx, napi, &work_done, budget);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\tsw_tail_old = aq_ptp->ptp_rx.sw_tail;\n\t\terr = aq_ring_rx_fill(&aq_ptp->ptp_rx);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\terr = aq_nic->aq_hw_ops->hw_ring_rx_fill(aq_nic->aq_hw,\n\t\t\t\t\t\t\t &aq_ptp->ptp_rx,\n\t\t\t\t\t\t\t sw_tail_old);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\t}\n\n\tif (was_cleaned)\n\t\twork_done = budget;\n\n\tif (work_done < budget) {\n\t\tnapi_complete_done(napi, work_done);\n\t\taq_nic->aq_hw_ops->hw_irq_enable(aq_nic->aq_hw,\n\t\t\t\t\tBIT_ULL(aq_ptp->ptp_ring_param.vec_idx));\n\t}\n\nerr_exit:\n\treturn work_done;\n}\n\nstatic irqreturn_t aq_ptp_isr(int irq, void *private)\n{\n\tstruct aq_ptp_s *aq_ptp = private;\n\tint err = 0;\n\n\tif (!aq_ptp) {\n\t\terr = -EINVAL;\n\t\tgoto err_exit;\n\t}\n\tnapi_schedule(&aq_ptp->napi);\n\nerr_exit:\n\treturn err >= 0 ? IRQ_HANDLED : IRQ_NONE;\n}\n\nint aq_ptp_xmit(struct aq_nic_s *aq_nic, struct sk_buff *skb)\n{\n\tstruct aq_ptp_s *aq_ptp = aq_nic->aq_ptp;\n\tstruct aq_ring_s *ring = &aq_ptp->ptp_tx;\n\tunsigned long irq_flags;\n\tint err = NETDEV_TX_OK;\n\tunsigned int frags;\n\n\tif (skb->len <= 0) {\n\t\tdev_kfree_skb_any(skb);\n\t\tgoto err_exit;\n\t}\n\n\tfrags = skb_shinfo(skb)->nr_frags + 1;\n\t \n\tif (frags > AQ_CFG_SKB_FRAGS_MAX || frags > aq_ring_avail_dx(ring)) {\n\t\t \n\t\tdev_kfree_skb_any(skb);\n\t\tgoto err_exit;\n\t}\n\n\terr = aq_ptp_skb_put(&aq_ptp->skb_ring, skb);\n\tif (err) {\n\t\tnetdev_err(aq_nic->ndev, \"SKB Ring is overflow (%u)!\\n\",\n\t\t\t   ring->size);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\taq_ptp_tx_timeout_start(aq_ptp);\n\tskb_tx_timestamp(skb);\n\n\tspin_lock_irqsave(&aq_nic->aq_ptp->ptp_ring_lock, irq_flags);\n\tfrags = aq_nic_map_skb(aq_nic, skb, ring);\n\n\tif (likely(frags)) {\n\t\terr = aq_nic->aq_hw_ops->hw_ring_tx_xmit(aq_nic->aq_hw,\n\t\t\t\t\t\t       ring, frags);\n\t\tif (err >= 0) {\n\t\t\tu64_stats_update_begin(&ring->stats.tx.syncp);\n\t\t\t++ring->stats.tx.packets;\n\t\t\tring->stats.tx.bytes += skb->len;\n\t\t\tu64_stats_update_end(&ring->stats.tx.syncp);\n\t\t}\n\t} else {\n\t\terr = NETDEV_TX_BUSY;\n\t}\n\tspin_unlock_irqrestore(&aq_nic->aq_ptp->ptp_ring_lock, irq_flags);\n\nerr_exit:\n\treturn err;\n}\n\nvoid aq_ptp_service_task(struct aq_nic_s *aq_nic)\n{\n\tstruct aq_ptp_s *aq_ptp = aq_nic->aq_ptp;\n\n\tif (!aq_ptp)\n\t\treturn;\n\n\taq_ptp_tx_timeout_check(aq_ptp);\n}\n\nint aq_ptp_irq_alloc(struct aq_nic_s *aq_nic)\n{\n\tstruct pci_dev *pdev = aq_nic->pdev;\n\tstruct aq_ptp_s *aq_ptp = aq_nic->aq_ptp;\n\tint err = 0;\n\n\tif (!aq_ptp)\n\t\treturn 0;\n\n\tif (pdev->msix_enabled || pdev->msi_enabled) {\n\t\terr = request_irq(pci_irq_vector(pdev, aq_ptp->idx_vector),\n\t\t\t\t  aq_ptp_isr, 0, aq_nic->ndev->name, aq_ptp);\n\t} else {\n\t\terr = -EINVAL;\n\t\tgoto err_exit;\n\t}\n\nerr_exit:\n\treturn err;\n}\n\nvoid aq_ptp_irq_free(struct aq_nic_s *aq_nic)\n{\n\tstruct aq_ptp_s *aq_ptp = aq_nic->aq_ptp;\n\tstruct pci_dev *pdev = aq_nic->pdev;\n\n\tif (!aq_ptp)\n\t\treturn;\n\n\tfree_irq(pci_irq_vector(pdev, aq_ptp->idx_vector), aq_ptp);\n}\n\nint aq_ptp_ring_init(struct aq_nic_s *aq_nic)\n{\n\tstruct aq_ptp_s *aq_ptp = aq_nic->aq_ptp;\n\tint err = 0;\n\n\tif (!aq_ptp)\n\t\treturn 0;\n\n\terr = aq_ring_init(&aq_ptp->ptp_tx, ATL_RING_TX);\n\tif (err < 0)\n\t\tgoto err_exit;\n\terr = aq_nic->aq_hw_ops->hw_ring_tx_init(aq_nic->aq_hw,\n\t\t\t\t\t\t &aq_ptp->ptp_tx,\n\t\t\t\t\t\t &aq_ptp->ptp_ring_param);\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\terr = aq_ring_init(&aq_ptp->ptp_rx, ATL_RING_RX);\n\tif (err < 0)\n\t\tgoto err_exit;\n\terr = aq_nic->aq_hw_ops->hw_ring_rx_init(aq_nic->aq_hw,\n\t\t\t\t\t\t &aq_ptp->ptp_rx,\n\t\t\t\t\t\t &aq_ptp->ptp_ring_param);\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\terr = aq_ring_rx_fill(&aq_ptp->ptp_rx);\n\tif (err < 0)\n\t\tgoto err_rx_free;\n\terr = aq_nic->aq_hw_ops->hw_ring_rx_fill(aq_nic->aq_hw,\n\t\t\t\t\t\t &aq_ptp->ptp_rx,\n\t\t\t\t\t\t 0U);\n\tif (err < 0)\n\t\tgoto err_rx_free;\n\n\terr = aq_ring_init(&aq_ptp->hwts_rx, ATL_RING_RX);\n\tif (err < 0)\n\t\tgoto err_rx_free;\n\terr = aq_nic->aq_hw_ops->hw_ring_rx_init(aq_nic->aq_hw,\n\t\t\t\t\t\t &aq_ptp->hwts_rx,\n\t\t\t\t\t\t &aq_ptp->ptp_ring_param);\n\tif (err < 0)\n\t\tgoto err_exit;\n\terr = aq_nic->aq_hw_ops->hw_ring_hwts_rx_fill(aq_nic->aq_hw,\n\t\t\t\t\t\t      &aq_ptp->hwts_rx);\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\treturn err;\n\nerr_rx_free:\n\taq_ring_rx_deinit(&aq_ptp->ptp_rx);\nerr_exit:\n\treturn err;\n}\n\nint aq_ptp_ring_start(struct aq_nic_s *aq_nic)\n{\n\tstruct aq_ptp_s *aq_ptp = aq_nic->aq_ptp;\n\tint err = 0;\n\n\tif (!aq_ptp)\n\t\treturn 0;\n\n\terr = aq_nic->aq_hw_ops->hw_ring_tx_start(aq_nic->aq_hw, &aq_ptp->ptp_tx);\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\terr = aq_nic->aq_hw_ops->hw_ring_rx_start(aq_nic->aq_hw, &aq_ptp->ptp_rx);\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\terr = aq_nic->aq_hw_ops->hw_ring_rx_start(aq_nic->aq_hw,\n\t\t\t\t\t\t  &aq_ptp->hwts_rx);\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\tnapi_enable(&aq_ptp->napi);\n\nerr_exit:\n\treturn err;\n}\n\nvoid aq_ptp_ring_stop(struct aq_nic_s *aq_nic)\n{\n\tstruct aq_ptp_s *aq_ptp = aq_nic->aq_ptp;\n\n\tif (!aq_ptp)\n\t\treturn;\n\n\taq_nic->aq_hw_ops->hw_ring_tx_stop(aq_nic->aq_hw, &aq_ptp->ptp_tx);\n\taq_nic->aq_hw_ops->hw_ring_rx_stop(aq_nic->aq_hw, &aq_ptp->ptp_rx);\n\n\taq_nic->aq_hw_ops->hw_ring_rx_stop(aq_nic->aq_hw, &aq_ptp->hwts_rx);\n\n\tnapi_disable(&aq_ptp->napi);\n}\n\nvoid aq_ptp_ring_deinit(struct aq_nic_s *aq_nic)\n{\n\tstruct aq_ptp_s *aq_ptp = aq_nic->aq_ptp;\n\n\tif (!aq_ptp || !aq_ptp->ptp_tx.aq_nic || !aq_ptp->ptp_rx.aq_nic)\n\t\treturn;\n\n\taq_ring_tx_clean(&aq_ptp->ptp_tx);\n\taq_ring_rx_deinit(&aq_ptp->ptp_rx);\n}\n\nint aq_ptp_ring_alloc(struct aq_nic_s *aq_nic)\n{\n\tstruct aq_ptp_s *aq_ptp = aq_nic->aq_ptp;\n\tunsigned int tx_ring_idx, rx_ring_idx;\n\tstruct aq_ring_s *hwts;\n\tstruct aq_ring_s *ring;\n\tint err;\n\n\tif (!aq_ptp)\n\t\treturn 0;\n\n\ttx_ring_idx = aq_ptp_ring_idx(aq_nic->aq_nic_cfg.tc_mode);\n\n\tring = aq_ring_tx_alloc(&aq_ptp->ptp_tx, aq_nic,\n\t\t\t\ttx_ring_idx, &aq_nic->aq_nic_cfg);\n\tif (!ring) {\n\t\terr = -ENOMEM;\n\t\tgoto err_exit;\n\t}\n\n\trx_ring_idx = aq_ptp_ring_idx(aq_nic->aq_nic_cfg.tc_mode);\n\n\tring = aq_ring_rx_alloc(&aq_ptp->ptp_rx, aq_nic,\n\t\t\t\trx_ring_idx, &aq_nic->aq_nic_cfg);\n\tif (!ring) {\n\t\terr = -ENOMEM;\n\t\tgoto err_exit_ptp_tx;\n\t}\n\n\thwts = aq_ring_hwts_rx_alloc(&aq_ptp->hwts_rx, aq_nic, PTP_HWST_RING_IDX,\n\t\t\t\t     aq_nic->aq_nic_cfg.rxds,\n\t\t\t\t     aq_nic->aq_nic_cfg.aq_hw_caps->rxd_size);\n\tif (!hwts) {\n\t\terr = -ENOMEM;\n\t\tgoto err_exit_ptp_rx;\n\t}\n\n\terr = aq_ptp_skb_ring_init(&aq_ptp->skb_ring, aq_nic->aq_nic_cfg.rxds);\n\tif (err != 0) {\n\t\terr = -ENOMEM;\n\t\tgoto err_exit_hwts_rx;\n\t}\n\n\taq_ptp->ptp_ring_param.vec_idx = aq_ptp->idx_vector;\n\taq_ptp->ptp_ring_param.cpu = aq_ptp->ptp_ring_param.vec_idx +\n\t\t\taq_nic_get_cfg(aq_nic)->aq_rss.base_cpu_number;\n\tcpumask_set_cpu(aq_ptp->ptp_ring_param.cpu,\n\t\t\t&aq_ptp->ptp_ring_param.affinity_mask);\n\n\treturn 0;\n\nerr_exit_hwts_rx:\n\taq_ring_free(&aq_ptp->hwts_rx);\nerr_exit_ptp_rx:\n\taq_ring_free(&aq_ptp->ptp_rx);\nerr_exit_ptp_tx:\n\taq_ring_free(&aq_ptp->ptp_tx);\nerr_exit:\n\treturn err;\n}\n\nvoid aq_ptp_ring_free(struct aq_nic_s *aq_nic)\n{\n\tstruct aq_ptp_s *aq_ptp = aq_nic->aq_ptp;\n\n\tif (!aq_ptp)\n\t\treturn;\n\n\taq_ring_free(&aq_ptp->ptp_tx);\n\taq_ring_free(&aq_ptp->ptp_rx);\n\taq_ring_free(&aq_ptp->hwts_rx);\n\n\taq_ptp_skb_ring_release(&aq_ptp->skb_ring);\n}\n\n#define MAX_PTP_GPIO_COUNT 4\n\nstatic struct ptp_clock_info aq_ptp_clock = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"atlantic ptp\",\n\t.max_adj\t= 999999999,\n\t.n_ext_ts\t= 0,\n\t.pps\t\t= 0,\n\t.adjfine\t= aq_ptp_adjfine,\n\t.adjtime\t= aq_ptp_adjtime,\n\t.gettime64\t= aq_ptp_gettime,\n\t.settime64\t= aq_ptp_settime,\n\t.n_per_out\t= 0,\n\t.enable\t\t= aq_ptp_gpio_feature_enable,\n\t.n_pins\t\t= 0,\n\t.verify\t\t= aq_ptp_verify,\n\t.pin_config\t= NULL,\n};\n\n#define ptp_offset_init(__idx, __mbps, __egress, __ingress)   do { \\\n\t\tptp_offset[__idx].mbps = (__mbps); \\\n\t\tptp_offset[__idx].egress = (__egress); \\\n\t\tptp_offset[__idx].ingress = (__ingress); } \\\n\t\twhile (0)\n\nstatic void aq_ptp_offset_init_from_fw(const struct hw_atl_ptp_offset *offsets)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ptp_offset); i++) {\n\t\tswitch (i) {\n\t\t \n\t\tcase ptp_offset_idx_100:\n\t\t\tptp_offset_init(i, 100,\n\t\t\t\t\toffsets->egress_100,\n\t\t\t\t\toffsets->ingress_100);\n\t\t\tbreak;\n\t\t \n\t\tcase ptp_offset_idx_1000:\n\t\t\tptp_offset_init(i, 1000,\n\t\t\t\t\toffsets->egress_1000,\n\t\t\t\t\toffsets->ingress_1000);\n\t\t\tbreak;\n\t\t \n\t\tcase ptp_offset_idx_2500:\n\t\t\tptp_offset_init(i, 2500,\n\t\t\t\t\toffsets->egress_2500,\n\t\t\t\t\toffsets->ingress_2500);\n\t\t\tbreak;\n\t\t \n\t\tcase ptp_offset_idx_5000:\n\t\t\tptp_offset_init(i, 5000,\n\t\t\t\t\toffsets->egress_5000,\n\t\t\t\t\toffsets->ingress_5000);\n\t\t\tbreak;\n\t\t \n\t\tcase ptp_offset_idx_10000:\n\t\t\tptp_offset_init(i, 10000,\n\t\t\t\t\toffsets->egress_10000,\n\t\t\t\t\toffsets->ingress_10000);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void aq_ptp_offset_init(const struct hw_atl_ptp_offset *offsets)\n{\n\tmemset(ptp_offset, 0, sizeof(ptp_offset));\n\n\taq_ptp_offset_init_from_fw(offsets);\n}\n\nstatic void aq_ptp_gpio_init(struct ptp_clock_info *info,\n\t\t\t     struct hw_atl_info *hw_info)\n{\n\tstruct ptp_pin_desc pin_desc[MAX_PTP_GPIO_COUNT];\n\tu32 extts_pin_cnt = 0;\n\tu32 out_pin_cnt = 0;\n\tu32 i;\n\n\tmemset(pin_desc, 0, sizeof(pin_desc));\n\n\tfor (i = 0; i < MAX_PTP_GPIO_COUNT - 1; i++) {\n\t\tif (hw_info->gpio_pin[i] ==\n\t\t    (GPIO_PIN_FUNCTION_PTP0 + out_pin_cnt)) {\n\t\t\tsnprintf(pin_desc[out_pin_cnt].name,\n\t\t\t\t sizeof(pin_desc[out_pin_cnt].name),\n\t\t\t\t \"AQ_GPIO%d\", i);\n\t\t\tpin_desc[out_pin_cnt].index = out_pin_cnt;\n\t\t\tpin_desc[out_pin_cnt].chan = out_pin_cnt;\n\t\t\tpin_desc[out_pin_cnt++].func = PTP_PF_PEROUT;\n\t\t}\n\t}\n\n\tinfo->n_per_out = out_pin_cnt;\n\n\tif (hw_info->caps_ex & BIT(CAPS_EX_PHY_CTRL_TS_PIN)) {\n\t\textts_pin_cnt += 1;\n\n\t\tsnprintf(pin_desc[out_pin_cnt].name,\n\t\t\t sizeof(pin_desc[out_pin_cnt].name),\n\t\t\t  \"AQ_GPIO%d\", out_pin_cnt);\n\t\tpin_desc[out_pin_cnt].index = out_pin_cnt;\n\t\tpin_desc[out_pin_cnt].chan = 0;\n\t\tpin_desc[out_pin_cnt].func = PTP_PF_EXTTS;\n\t}\n\n\tinfo->n_pins = out_pin_cnt + extts_pin_cnt;\n\tinfo->n_ext_ts = extts_pin_cnt;\n\n\tif (!info->n_pins)\n\t\treturn;\n\n\tinfo->pin_config = kcalloc(info->n_pins, sizeof(struct ptp_pin_desc),\n\t\t\t\t   GFP_KERNEL);\n\n\tif (!info->pin_config)\n\t\treturn;\n\n\tmemcpy(info->pin_config, &pin_desc,\n\t       sizeof(struct ptp_pin_desc) * info->n_pins);\n}\n\nvoid aq_ptp_clock_init(struct aq_nic_s *aq_nic)\n{\n\tstruct aq_ptp_s *aq_ptp = aq_nic->aq_ptp;\n\tstruct timespec64 ts;\n\n\tktime_get_real_ts64(&ts);\n\taq_ptp_settime(&aq_ptp->ptp_info, &ts);\n}\n\nstatic void aq_ptp_poll_sync_work_cb(struct work_struct *w);\n\nint aq_ptp_init(struct aq_nic_s *aq_nic, unsigned int idx_vec)\n{\n\tbool a1_ptp = ATL_HW_IS_CHIP_FEATURE(aq_nic->aq_hw, ATLANTIC);\n\tstruct hw_atl_utils_mbox mbox;\n\tstruct ptp_clock *clock;\n\tstruct aq_ptp_s *aq_ptp;\n\tint err = 0;\n\n\tif (!a1_ptp) {\n\t\taq_nic->aq_ptp = NULL;\n\t\treturn 0;\n\t}\n\n\tif (!aq_nic->aq_hw_ops->hw_get_ptp_ts) {\n\t\taq_nic->aq_ptp = NULL;\n\t\treturn 0;\n\t}\n\n\tif (!aq_nic->aq_fw_ops->enable_ptp) {\n\t\taq_nic->aq_ptp = NULL;\n\t\treturn 0;\n\t}\n\n\thw_atl_utils_mpi_read_stats(aq_nic->aq_hw, &mbox);\n\n\tif (!(mbox.info.caps_ex & BIT(CAPS_EX_PHY_PTP_EN))) {\n\t\taq_nic->aq_ptp = NULL;\n\t\treturn 0;\n\t}\n\n\taq_ptp_offset_init(&mbox.info.ptp_offset);\n\n\taq_ptp = kzalloc(sizeof(*aq_ptp), GFP_KERNEL);\n\tif (!aq_ptp) {\n\t\terr = -ENOMEM;\n\t\tgoto err_exit;\n\t}\n\n\taq_ptp->aq_nic = aq_nic;\n\taq_ptp->a1_ptp = a1_ptp;\n\n\tspin_lock_init(&aq_ptp->ptp_lock);\n\tspin_lock_init(&aq_ptp->ptp_ring_lock);\n\n\taq_ptp->ptp_info = aq_ptp_clock;\n\taq_ptp_gpio_init(&aq_ptp->ptp_info, &mbox.info);\n\tclock = ptp_clock_register(&aq_ptp->ptp_info, &aq_nic->ndev->dev);\n\tif (IS_ERR(clock)) {\n\t\tnetdev_err(aq_nic->ndev, \"ptp_clock_register failed\\n\");\n\t\terr = PTR_ERR(clock);\n\t\tgoto err_exit;\n\t}\n\taq_ptp->ptp_clock = clock;\n\taq_ptp_tx_timeout_init(&aq_ptp->ptp_tx_timeout);\n\n\tatomic_set(&aq_ptp->offset_egress, 0);\n\tatomic_set(&aq_ptp->offset_ingress, 0);\n\n\tnetif_napi_add(aq_nic_get_ndev(aq_nic), &aq_ptp->napi, aq_ptp_poll);\n\n\taq_ptp->idx_vector = idx_vec;\n\n\taq_nic->aq_ptp = aq_ptp;\n\n\t \n\taq_utils_obj_set(&aq_nic->aq_hw->flags, AQ_HW_PTP_AVAILABLE);\n\tmutex_lock(&aq_nic->fwreq_mutex);\n\taq_nic->aq_fw_ops->enable_ptp(aq_nic->aq_hw, 1);\n\taq_ptp_clock_init(aq_nic);\n\tmutex_unlock(&aq_nic->fwreq_mutex);\n\n\tINIT_DELAYED_WORK(&aq_ptp->poll_sync, &aq_ptp_poll_sync_work_cb);\n\taq_ptp->eth_type_filter.location =\n\t\t\taq_nic_reserve_filter(aq_nic, aq_rx_filter_ethertype);\n\taq_ptp->udp_filter.location =\n\t\t\taq_nic_reserve_filter(aq_nic, aq_rx_filter_l3l4);\n\n\treturn 0;\n\nerr_exit:\n\tif (aq_ptp)\n\t\tkfree(aq_ptp->ptp_info.pin_config);\n\tkfree(aq_ptp);\n\taq_nic->aq_ptp = NULL;\n\treturn err;\n}\n\nvoid aq_ptp_unregister(struct aq_nic_s *aq_nic)\n{\n\tstruct aq_ptp_s *aq_ptp = aq_nic->aq_ptp;\n\n\tif (!aq_ptp)\n\t\treturn;\n\n\tptp_clock_unregister(aq_ptp->ptp_clock);\n}\n\nvoid aq_ptp_free(struct aq_nic_s *aq_nic)\n{\n\tstruct aq_ptp_s *aq_ptp = aq_nic->aq_ptp;\n\n\tif (!aq_ptp)\n\t\treturn;\n\n\taq_nic_release_filter(aq_nic, aq_rx_filter_ethertype,\n\t\t\t      aq_ptp->eth_type_filter.location);\n\taq_nic_release_filter(aq_nic, aq_rx_filter_l3l4,\n\t\t\t      aq_ptp->udp_filter.location);\n\tcancel_delayed_work_sync(&aq_ptp->poll_sync);\n\t \n\tmutex_lock(&aq_nic->fwreq_mutex);\n\taq_nic->aq_fw_ops->enable_ptp(aq_nic->aq_hw, 0);\n\tmutex_unlock(&aq_nic->fwreq_mutex);\n\n\tkfree(aq_ptp->ptp_info.pin_config);\n\n\tnetif_napi_del(&aq_ptp->napi);\n\tkfree(aq_ptp);\n\taq_nic->aq_ptp = NULL;\n}\n\nstruct ptp_clock *aq_ptp_get_ptp_clock(struct aq_ptp_s *aq_ptp)\n{\n\treturn aq_ptp->ptp_clock;\n}\n\n \nstatic uint64_t aq_ptp_get_sync1588_ts(struct aq_nic_s *aq_nic)\n{\n\tu64 ts = 0;\n\n\tif (aq_nic->aq_hw_ops->hw_get_sync_ts)\n\t\taq_nic->aq_hw_ops->hw_get_sync_ts(aq_nic->aq_hw, &ts);\n\n\treturn ts;\n}\n\nstatic void aq_ptp_start_work(struct aq_ptp_s *aq_ptp)\n{\n\tif (aq_ptp->extts_pin_enabled) {\n\t\taq_ptp->poll_timeout_ms = POLL_SYNC_TIMER_MS;\n\t\taq_ptp->last_sync1588_ts =\n\t\t\t\taq_ptp_get_sync1588_ts(aq_ptp->aq_nic);\n\t\tschedule_delayed_work(&aq_ptp->poll_sync,\n\t\t\t\t      msecs_to_jiffies(aq_ptp->poll_timeout_ms));\n\t}\n}\n\nint aq_ptp_link_change(struct aq_nic_s *aq_nic)\n{\n\tstruct aq_ptp_s *aq_ptp = aq_nic->aq_ptp;\n\n\tif (!aq_ptp)\n\t\treturn 0;\n\n\tif (aq_nic->aq_hw->aq_link_status.mbps)\n\t\taq_ptp_start_work(aq_ptp);\n\telse\n\t\tcancel_delayed_work_sync(&aq_ptp->poll_sync);\n\n\treturn 0;\n}\n\nstatic bool aq_ptp_sync_ts_updated(struct aq_ptp_s *aq_ptp, u64 *new_ts)\n{\n\tstruct aq_nic_s *aq_nic = aq_ptp->aq_nic;\n\tu64 sync_ts2;\n\tu64 sync_ts;\n\n\tsync_ts = aq_ptp_get_sync1588_ts(aq_nic);\n\n\tif (sync_ts != aq_ptp->last_sync1588_ts) {\n\t\tsync_ts2 = aq_ptp_get_sync1588_ts(aq_nic);\n\t\tif (sync_ts != sync_ts2) {\n\t\t\tsync_ts = sync_ts2;\n\t\t\tsync_ts2 = aq_ptp_get_sync1588_ts(aq_nic);\n\t\t\tif (sync_ts != sync_ts2) {\n\t\t\t\tnetdev_err(aq_nic->ndev,\n\t\t\t\t\t   \"%s: Unable to get correct GPIO TS\",\n\t\t\t\t\t   __func__);\n\t\t\t\tsync_ts = 0;\n\t\t\t}\n\t\t}\n\n\t\t*new_ts = sync_ts;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int aq_ptp_check_sync1588(struct aq_ptp_s *aq_ptp)\n{\n\tstruct aq_nic_s *aq_nic = aq_ptp->aq_nic;\n\tu64 sync_ts;\n\n\t  \n\tif (aq_ptp_sync_ts_updated(aq_ptp, &sync_ts)) {\n\t\tif (aq_ptp->extts_pin_enabled) {\n\t\t\tstruct ptp_clock_event ptp_event;\n\t\t\tu64 time = 0;\n\n\t\t\taq_nic->aq_hw_ops->hw_ts_to_sys_clock(aq_nic->aq_hw,\n\t\t\t\t\t\t\t      sync_ts, &time);\n\t\t\tptp_event.index = aq_ptp->ptp_info.n_pins - 1;\n\t\t\tptp_event.timestamp = time;\n\n\t\t\tptp_event.type = PTP_CLOCK_EXTTS;\n\t\t\tptp_clock_event(aq_ptp->ptp_clock, &ptp_event);\n\t\t}\n\n\t\taq_ptp->last_sync1588_ts = sync_ts;\n\t}\n\n\treturn 0;\n}\n\nstatic void aq_ptp_poll_sync_work_cb(struct work_struct *w)\n{\n\tstruct delayed_work *dw = to_delayed_work(w);\n\tstruct aq_ptp_s *aq_ptp = container_of(dw, struct aq_ptp_s, poll_sync);\n\n\taq_ptp_check_sync1588(aq_ptp);\n\n\tif (aq_ptp->extts_pin_enabled) {\n\t\tunsigned long timeout = msecs_to_jiffies(aq_ptp->poll_timeout_ms);\n\n\t\tschedule_delayed_work(&aq_ptp->poll_sync, timeout);\n\t}\n}\n\nint aq_ptp_get_ring_cnt(struct aq_nic_s *aq_nic, const enum atl_ring_type ring_type)\n{\n\tif (!aq_nic->aq_ptp)\n\t\treturn 0;\n\n\t \n\treturn (aq_nic->aq_ptp->a1_ptp && ring_type == ATL_RING_RX) ? 2 : 1;\n}\n\nu64 *aq_ptp_get_stats(struct aq_nic_s *aq_nic, u64 *data)\n{\n\tstruct aq_ptp_s *aq_ptp = aq_nic->aq_ptp;\n\tunsigned int count = 0U;\n\n\tif (!aq_ptp)\n\t\treturn data;\n\n\tcount = aq_ring_fill_stats_data(&aq_ptp->ptp_rx, data);\n\tdata += count;\n\tcount = aq_ring_fill_stats_data(&aq_ptp->ptp_tx, data);\n\tdata += count;\n\n\tif (aq_ptp->a1_ptp) {\n\t\t \n\t\tcount = aq_ring_fill_stats_data(&aq_ptp->hwts_rx, data);\n\t\tdata += count;\n\t}\n\n\treturn data;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}