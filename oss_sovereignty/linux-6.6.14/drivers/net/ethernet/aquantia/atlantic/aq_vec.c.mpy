{
  "module_name": "aq_vec.c",
  "hash_id": "4f28214b0a6d78938c8a7c035fee89c0d21fbbc0613b2f9bffca87b092291ce1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/aquantia/atlantic/aq_vec.c",
  "human_readable_source": "\n \n\n \n\n#include \"aq_vec.h\"\n\nstruct aq_vec_s {\n\tconst struct aq_hw_ops *aq_hw_ops;\n\tstruct aq_hw_s *aq_hw;\n\tstruct aq_nic_s *aq_nic;\n\tunsigned int tx_rings;\n\tunsigned int rx_rings;\n\tstruct aq_ring_param_s aq_ring_param;\n\tstruct napi_struct napi;\n\tstruct aq_ring_s ring[AQ_CFG_TCS_MAX][2];\n};\n\n#define AQ_VEC_TX_ID 0\n#define AQ_VEC_RX_ID 1\n\nstatic int aq_vec_poll(struct napi_struct *napi, int budget)\n{\n\tstruct aq_vec_s *self = container_of(napi, struct aq_vec_s, napi);\n\tunsigned int sw_tail_old = 0U;\n\tstruct aq_ring_s *ring = NULL;\n\tbool was_tx_cleaned = true;\n\tunsigned int i = 0U;\n\tint work_done = 0;\n\tint err = 0;\n\n\tif (!self) {\n\t\terr = -EINVAL;\n\t} else {\n\t\tfor (i = 0U; self->tx_rings > i; ++i) {\n\t\t\tring = self->ring[i];\n\t\t\tu64_stats_update_begin(&ring[AQ_VEC_RX_ID].stats.rx.syncp);\n\t\t\tring[AQ_VEC_RX_ID].stats.rx.polls++;\n\t\t\tu64_stats_update_end(&ring[AQ_VEC_RX_ID].stats.rx.syncp);\n\t\t\tif (self->aq_hw_ops->hw_ring_tx_head_update) {\n\t\t\t\terr = self->aq_hw_ops->hw_ring_tx_head_update(\n\t\t\t\t\t\t\tself->aq_hw,\n\t\t\t\t\t\t\t&ring[AQ_VEC_TX_ID]);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto err_exit;\n\t\t\t}\n\n\t\t\tif (ring[AQ_VEC_TX_ID].sw_head !=\n\t\t\t    ring[AQ_VEC_TX_ID].hw_head) {\n\t\t\t\twas_tx_cleaned = aq_ring_tx_clean(&ring[AQ_VEC_TX_ID]);\n\t\t\t\taq_ring_update_queue_state(&ring[AQ_VEC_TX_ID]);\n\t\t\t}\n\n\t\t\terr = self->aq_hw_ops->hw_ring_rx_receive(self->aq_hw,\n\t\t\t\t\t    &ring[AQ_VEC_RX_ID]);\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_exit;\n\n\t\t\tif (ring[AQ_VEC_RX_ID].sw_head !=\n\t\t\t\tring[AQ_VEC_RX_ID].hw_head) {\n\t\t\t\terr = aq_ring_rx_clean(&ring[AQ_VEC_RX_ID],\n\t\t\t\t\t\t       napi,\n\t\t\t\t\t\t       &work_done,\n\t\t\t\t\t\t       budget - work_done);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto err_exit;\n\n\t\t\t\tsw_tail_old = ring[AQ_VEC_RX_ID].sw_tail;\n\n\t\t\t\terr = aq_ring_rx_fill(&ring[AQ_VEC_RX_ID]);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto err_exit;\n\n\t\t\t\terr = self->aq_hw_ops->hw_ring_rx_fill(\n\t\t\t\t\tself->aq_hw,\n\t\t\t\t\t&ring[AQ_VEC_RX_ID], sw_tail_old);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t}\n\nerr_exit:\n\t\tif (!was_tx_cleaned)\n\t\t\twork_done = budget;\n\n\t\tif (work_done < budget) {\n\t\t\tnapi_complete_done(napi, work_done);\n\t\t\tself->aq_hw_ops->hw_irq_enable(self->aq_hw,\n\t\t\t\t\t1U << self->aq_ring_param.vec_idx);\n\t\t}\n\t}\n\n\treturn work_done;\n}\n\nstruct aq_vec_s *aq_vec_alloc(struct aq_nic_s *aq_nic, unsigned int idx,\n\t\t\t      struct aq_nic_cfg_s *aq_nic_cfg)\n{\n\tstruct aq_vec_s *self = NULL;\n\n\tself = kzalloc(sizeof(*self), GFP_KERNEL);\n\tif (!self)\n\t\tgoto err_exit;\n\n\tself->aq_nic = aq_nic;\n\tself->aq_ring_param.vec_idx = idx;\n\tself->aq_ring_param.cpu =\n\t\tidx + aq_nic_cfg->aq_rss.base_cpu_number;\n\n\tcpumask_set_cpu(self->aq_ring_param.cpu,\n\t\t\t&self->aq_ring_param.affinity_mask);\n\n\tself->tx_rings = 0;\n\tself->rx_rings = 0;\n\n\tnetif_napi_add(aq_nic_get_ndev(aq_nic), &self->napi, aq_vec_poll);\n\nerr_exit:\n\treturn self;\n}\n\nint aq_vec_ring_alloc(struct aq_vec_s *self, struct aq_nic_s *aq_nic,\n\t\t      unsigned int idx, struct aq_nic_cfg_s *aq_nic_cfg)\n{\n\tstruct aq_ring_s *ring = NULL;\n\tunsigned int i = 0U;\n\tint err = 0;\n\n\tfor (i = 0; i < aq_nic_cfg->tcs; ++i) {\n\t\tconst unsigned int idx_ring = AQ_NIC_CFG_TCVEC2RING(aq_nic_cfg,\n\t\t\t\t\t\t\t\t    i, idx);\n\n\t\tring = aq_ring_tx_alloc(&self->ring[i][AQ_VEC_TX_ID], aq_nic,\n\t\t\t\t\tidx_ring, aq_nic_cfg);\n\t\tif (!ring) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_exit;\n\t\t}\n\n\t\t++self->tx_rings;\n\n\t\taq_nic_set_tx_ring(aq_nic, idx_ring, ring);\n\n\t\tif (xdp_rxq_info_reg(&self->ring[i][AQ_VEC_RX_ID].xdp_rxq,\n\t\t\t\t     aq_nic->ndev, idx,\n\t\t\t\t     self->napi.napi_id) < 0) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_exit;\n\t\t}\n\t\tif (xdp_rxq_info_reg_mem_model(&self->ring[i][AQ_VEC_RX_ID].xdp_rxq,\n\t\t\t\t\t       MEM_TYPE_PAGE_SHARED, NULL) < 0) {\n\t\t\txdp_rxq_info_unreg(&self->ring[i][AQ_VEC_RX_ID].xdp_rxq);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_exit;\n\t\t}\n\n\t\tring = aq_ring_rx_alloc(&self->ring[i][AQ_VEC_RX_ID], aq_nic,\n\t\t\t\t\tidx_ring, aq_nic_cfg);\n\t\tif (!ring) {\n\t\t\txdp_rxq_info_unreg(&self->ring[i][AQ_VEC_RX_ID].xdp_rxq);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_exit;\n\t\t}\n\n\t\t++self->rx_rings;\n\t}\n\nerr_exit:\n\tif (err < 0) {\n\t\taq_vec_ring_free(self);\n\t\tself = NULL;\n\t}\n\n\treturn err;\n}\n\nint aq_vec_init(struct aq_vec_s *self, const struct aq_hw_ops *aq_hw_ops,\n\t\tstruct aq_hw_s *aq_hw)\n{\n\tstruct aq_ring_s *ring = NULL;\n\tunsigned int i = 0U;\n\tint err = 0;\n\n\tself->aq_hw_ops = aq_hw_ops;\n\tself->aq_hw = aq_hw;\n\n\tfor (i = 0U; self->tx_rings > i; ++i) {\n\t\tring = self->ring[i];\n\t\terr = aq_ring_init(&ring[AQ_VEC_TX_ID], ATL_RING_TX);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\terr = self->aq_hw_ops->hw_ring_tx_init(self->aq_hw,\n\t\t\t\t\t\t       &ring[AQ_VEC_TX_ID],\n\t\t\t\t\t\t       &self->aq_ring_param);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\terr = aq_ring_init(&ring[AQ_VEC_RX_ID], ATL_RING_RX);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\terr = self->aq_hw_ops->hw_ring_rx_init(self->aq_hw,\n\t\t\t\t\t\t       &ring[AQ_VEC_RX_ID],\n\t\t\t\t\t\t       &self->aq_ring_param);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\terr = aq_ring_rx_fill(&ring[AQ_VEC_RX_ID]);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\terr = self->aq_hw_ops->hw_ring_rx_fill(self->aq_hw,\n\t\t\t\t\t\t       &ring[AQ_VEC_RX_ID], 0U);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\t}\n\nerr_exit:\n\treturn err;\n}\n\nint aq_vec_start(struct aq_vec_s *self)\n{\n\tstruct aq_ring_s *ring = NULL;\n\tunsigned int i = 0U;\n\tint err = 0;\n\n\tfor (i = 0U; self->tx_rings > i; ++i) {\n\t\tring = self->ring[i];\n\t\terr = self->aq_hw_ops->hw_ring_tx_start(self->aq_hw,\n\t\t\t\t\t\t\t&ring[AQ_VEC_TX_ID]);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\terr = self->aq_hw_ops->hw_ring_rx_start(self->aq_hw,\n\t\t\t\t\t\t\t&ring[AQ_VEC_RX_ID]);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\t}\n\n\tnapi_enable(&self->napi);\n\nerr_exit:\n\treturn err;\n}\n\nvoid aq_vec_stop(struct aq_vec_s *self)\n{\n\tstruct aq_ring_s *ring = NULL;\n\tunsigned int i = 0U;\n\n\tfor (i = 0U; self->tx_rings > i; ++i) {\n\t\tring = self->ring[i];\n\t\tself->aq_hw_ops->hw_ring_tx_stop(self->aq_hw,\n\t\t\t\t\t\t &ring[AQ_VEC_TX_ID]);\n\n\t\tself->aq_hw_ops->hw_ring_rx_stop(self->aq_hw,\n\t\t\t\t\t\t &ring[AQ_VEC_RX_ID]);\n\t}\n\n\tnapi_disable(&self->napi);\n}\n\nvoid aq_vec_deinit(struct aq_vec_s *self)\n{\n\tstruct aq_ring_s *ring = NULL;\n\tunsigned int i = 0U;\n\n\tif (!self)\n\t\tgoto err_exit;\n\n\tfor (i = 0U; self->tx_rings > i; ++i) {\n\t\tring = self->ring[i];\n\t\taq_ring_tx_clean(&ring[AQ_VEC_TX_ID]);\n\t\taq_ring_rx_deinit(&ring[AQ_VEC_RX_ID]);\n\t}\n\nerr_exit:;\n}\n\nvoid aq_vec_free(struct aq_vec_s *self)\n{\n\tif (!self)\n\t\tgoto err_exit;\n\n\tnetif_napi_del(&self->napi);\n\n\tkfree(self);\n\nerr_exit:;\n}\n\nvoid aq_vec_ring_free(struct aq_vec_s *self)\n{\n\tstruct aq_ring_s *ring = NULL;\n\tunsigned int i = 0U;\n\n\tif (!self)\n\t\tgoto err_exit;\n\n\tfor (i = 0U; self->tx_rings > i; ++i) {\n\t\tring = self->ring[i];\n\t\taq_ring_free(&ring[AQ_VEC_TX_ID]);\n\t\tif (i < self->rx_rings) {\n\t\t\txdp_rxq_info_unreg(&ring[AQ_VEC_RX_ID].xdp_rxq);\n\t\t\taq_ring_free(&ring[AQ_VEC_RX_ID]);\n\t\t}\n\t}\n\n\tself->tx_rings = 0;\n\tself->rx_rings = 0;\nerr_exit:;\n}\n\nirqreturn_t aq_vec_isr(int irq, void *private)\n{\n\tstruct aq_vec_s *self = private;\n\tint err = 0;\n\n\tif (!self) {\n\t\terr = -EINVAL;\n\t\tgoto err_exit;\n\t}\n\tnapi_schedule(&self->napi);\n\nerr_exit:\n\treturn err >= 0 ? IRQ_HANDLED : IRQ_NONE;\n}\n\nirqreturn_t aq_vec_isr_legacy(int irq, void *private)\n{\n\tstruct aq_vec_s *self = private;\n\tu64 irq_mask = 0U;\n\tint err;\n\n\tif (!self)\n\t\treturn IRQ_NONE;\n\terr = self->aq_hw_ops->hw_irq_read(self->aq_hw, &irq_mask);\n\tif (err < 0)\n\t\treturn IRQ_NONE;\n\n\tif (irq_mask) {\n\t\tself->aq_hw_ops->hw_irq_disable(self->aq_hw,\n\t\t\t      1U << self->aq_ring_param.vec_idx);\n\t\tnapi_schedule(&self->napi);\n\t} else {\n\t\tself->aq_hw_ops->hw_irq_enable(self->aq_hw, 1U);\n\t\treturn IRQ_NONE;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\ncpumask_t *aq_vec_get_affinity_mask(struct aq_vec_s *self)\n{\n\treturn &self->aq_ring_param.affinity_mask;\n}\n\nbool aq_vec_is_valid_tc(struct aq_vec_s *self, const unsigned int tc)\n{\n\treturn tc < self->rx_rings && tc < self->tx_rings;\n}\n\nunsigned int aq_vec_get_sw_stats(struct aq_vec_s *self, const unsigned int tc, u64 *data)\n{\n\tunsigned int count;\n\n\tif (!aq_vec_is_valid_tc(self, tc))\n\t\treturn 0;\n\n\tcount = aq_ring_fill_stats_data(&self->ring[tc][AQ_VEC_RX_ID], data);\n\tcount += aq_ring_fill_stats_data(&self->ring[tc][AQ_VEC_TX_ID], data + count);\n\n\treturn count;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}