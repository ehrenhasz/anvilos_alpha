{
  "module_name": "macsec_api.c",
  "hash_id": "dd0cb20eb27b22a6e2884ba477276d19597cf664d946b1e5d9f31fed5f3b68a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/aquantia/atlantic/macsec/macsec_api.c",
  "human_readable_source": "\n \n\n#include \"macsec_api.h\"\n#include <linux/mdio.h>\n#include \"MSS_Ingress_registers.h\"\n#include \"MSS_Egress_registers.h\"\n#include \"aq_phy.h\"\n\n#define AQ_API_CALL_SAFE(func, ...)                                            \\\n({                                                                             \\\n\tint ret;                                                               \\\n\tdo {                                                                   \\\n\t\tret = aq_mss_mdio_sem_get(hw);                                 \\\n\t\tif (unlikely(ret))                                             \\\n\t\t\tbreak;                                                 \\\n\t\t\t\t\t\t\t\t\t       \\\n\t\tret = func(__VA_ARGS__);                                       \\\n\t\t\t\t\t\t\t\t\t       \\\n\t\taq_mss_mdio_sem_put(hw);                                       \\\n\t} while (0);                                                           \\\n\tret;                                                                   \\\n})\n\n \nstatic int aq_mss_mdio_sem_get(struct aq_hw_s *hw)\n{\n\tu32 val;\n\n\treturn readx_poll_timeout_atomic(hw_atl_sem_mdio_get, hw, val,\n\t\t\t\t\t val == 1U, 10U, 100000U);\n}\n\nstatic void aq_mss_mdio_sem_put(struct aq_hw_s *hw)\n{\n\thw_atl_reg_glb_cpu_sem_set(hw, 1U, HW_ATL_FW_SM_MDIO);\n}\n\nstatic int aq_mss_mdio_read(struct aq_hw_s *hw, u16 mmd, u16 addr, u16 *data)\n{\n\t*data = aq_mdio_read_word(hw, mmd, addr);\n\treturn (*data != 0xffff) ? 0 : -ETIME;\n}\n\nstatic int aq_mss_mdio_write(struct aq_hw_s *hw, u16 mmd, u16 addr, u16 data)\n{\n\taq_mdio_write_word(hw, mmd, addr, data);\n\treturn 0;\n}\n\n \n\nstatic int set_raw_ingress_record(struct aq_hw_s *hw, u16 *packed_record,\n\t\t\t\t  u8 num_words, u8 table_id,\n\t\t\t\t  u16 table_index)\n{\n\tstruct mss_ingress_lut_addr_ctl_register lut_sel_reg;\n\tstruct mss_ingress_lut_ctl_register lut_op_reg;\n\n\tunsigned int i;\n\n\t \n\n\t \n\tfor (i = 0; i < num_words; i += 2) {\n\t\taq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t\t  MSS_INGRESS_LUT_DATA_CTL_REGISTER_ADDR + i,\n\t\t\t\t  packed_record[i]);\n\t\taq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t\t  MSS_INGRESS_LUT_DATA_CTL_REGISTER_ADDR + i +\n\t\t\t\t\t  1,\n\t\t\t\t  packed_record[i + 1]);\n\t}\n\n\t \n\tfor (i = num_words; i < 24; i += 2) {\n\t\taq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t\t  MSS_INGRESS_LUT_DATA_CTL_REGISTER_ADDR + i,\n\t\t\t\t  0);\n\t\taq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\tMSS_INGRESS_LUT_DATA_CTL_REGISTER_ADDR + i + 1, 0);\n\t}\n\n\t \n\tlut_sel_reg.bits_0.lut_select = table_id;\n\tlut_sel_reg.bits_0.lut_addr = table_index;\n\n\tlut_op_reg.bits_0.lut_read = 0;\n\tlut_op_reg.bits_0.lut_write = 1;\n\n\taq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t  MSS_INGRESS_LUT_ADDR_CTL_REGISTER_ADDR,\n\t\t\t  lut_sel_reg.word_0);\n\taq_mss_mdio_write(hw, MDIO_MMD_VEND1, MSS_INGRESS_LUT_CTL_REGISTER_ADDR,\n\t\t\t  lut_op_reg.word_0);\n\n\treturn 0;\n}\n\n \nstatic int get_raw_ingress_record(struct aq_hw_s *hw, u16 *packed_record,\n\t\t\t\t  u8 num_words, u8 table_id,\n\t\t\t\t  u16 table_index)\n{\n\tstruct mss_ingress_lut_addr_ctl_register lut_sel_reg;\n\tstruct mss_ingress_lut_ctl_register lut_op_reg;\n\tint ret;\n\n\tunsigned int i;\n\n\t \n\tlut_sel_reg.bits_0.lut_select = table_id;\n\tlut_sel_reg.bits_0.lut_addr = table_index;\n\n\tlut_op_reg.bits_0.lut_read = 1;\n\tlut_op_reg.bits_0.lut_write = 0;\n\n\tret = aq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t\tMSS_INGRESS_LUT_ADDR_CTL_REGISTER_ADDR,\n\t\t\t\tlut_sel_reg.word_0);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tret = aq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t\tMSS_INGRESS_LUT_CTL_REGISTER_ADDR,\n\t\t\t\tlut_op_reg.word_0);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tmemset(packed_record, 0, sizeof(u16) * num_words);\n\n\tfor (i = 0; i < num_words; i += 2) {\n\t\tret = aq_mss_mdio_read(hw, MDIO_MMD_VEND1,\n\t\t\t\t       MSS_INGRESS_LUT_DATA_CTL_REGISTER_ADDR +\n\t\t\t\t\t       i,\n\t\t\t\t       &packed_record[i]);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t\tret = aq_mss_mdio_read(hw, MDIO_MMD_VEND1,\n\t\t\t\t       MSS_INGRESS_LUT_DATA_CTL_REGISTER_ADDR +\n\t\t\t\t\t       i + 1,\n\t\t\t\t       &packed_record[i + 1]);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int set_raw_egress_record(struct aq_hw_s *hw, u16 *packed_record,\n\t\t\t\t u8 num_words, u8 table_id,\n\t\t\t\t u16 table_index)\n{\n\tstruct mss_egress_lut_addr_ctl_register lut_sel_reg;\n\tstruct mss_egress_lut_ctl_register lut_op_reg;\n\n\tunsigned int i;\n\n\t \n\tfor (i = 0; i < num_words; i += 2) {\n\t\taq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t\t  MSS_EGRESS_LUT_DATA_CTL_REGISTER_ADDR + i,\n\t\t\t\t  packed_record[i]);\n\t\taq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t\t  MSS_EGRESS_LUT_DATA_CTL_REGISTER_ADDR + i + 1,\n\t\t\t\t  packed_record[i + 1]);\n\t}\n\n\t \n\tfor (i = num_words; i < 28; i += 2) {\n\t\taq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t\t  MSS_EGRESS_LUT_DATA_CTL_REGISTER_ADDR + i, 0);\n\t\taq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t\t  MSS_EGRESS_LUT_DATA_CTL_REGISTER_ADDR + i + 1,\n\t\t\t\t  0);\n\t}\n\n\t \n\tlut_sel_reg.bits_0.lut_select = table_id;\n\tlut_sel_reg.bits_0.lut_addr = table_index;\n\n\tlut_op_reg.bits_0.lut_read = 0;\n\tlut_op_reg.bits_0.lut_write = 1;\n\n\taq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t  MSS_EGRESS_LUT_ADDR_CTL_REGISTER_ADDR,\n\t\t\t  lut_sel_reg.word_0);\n\taq_mss_mdio_write(hw, MDIO_MMD_VEND1, MSS_EGRESS_LUT_CTL_REGISTER_ADDR,\n\t\t\t  lut_op_reg.word_0);\n\n\treturn 0;\n}\n\nstatic int get_raw_egress_record(struct aq_hw_s *hw, u16 *packed_record,\n\t\t\t\t u8 num_words, u8 table_id,\n\t\t\t\t u16 table_index)\n{\n\tstruct mss_egress_lut_addr_ctl_register lut_sel_reg;\n\tstruct mss_egress_lut_ctl_register lut_op_reg;\n\tint ret;\n\n\tunsigned int i;\n\n\t \n\tlut_sel_reg.bits_0.lut_select = table_id;\n\tlut_sel_reg.bits_0.lut_addr = table_index;\n\n\tlut_op_reg.bits_0.lut_read = 1;\n\tlut_op_reg.bits_0.lut_write = 0;\n\n\tret = aq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t\tMSS_EGRESS_LUT_ADDR_CTL_REGISTER_ADDR,\n\t\t\t\tlut_sel_reg.word_0);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tret = aq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t\tMSS_EGRESS_LUT_CTL_REGISTER_ADDR,\n\t\t\t\tlut_op_reg.word_0);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tmemset(packed_record, 0, sizeof(u16) * num_words);\n\n\tfor (i = 0; i < num_words; i += 2) {\n\t\tret = aq_mss_mdio_read(hw, MDIO_MMD_VEND1,\n\t\t\t\t       MSS_EGRESS_LUT_DATA_CTL_REGISTER_ADDR +\n\t\t\t\t\t       i,\n\t\t\t\t       &packed_record[i]);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t\tret = aq_mss_mdio_read(hw, MDIO_MMD_VEND1,\n\t\t\t\t       MSS_EGRESS_LUT_DATA_CTL_REGISTER_ADDR +\n\t\t\t\t\t       i + 1,\n\t\t\t\t       &packed_record[i + 1]);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nset_ingress_prectlf_record(struct aq_hw_s *hw,\n\t\t\t   const struct aq_mss_ingress_prectlf_record *rec,\n\t\t\t   u16 table_index)\n{\n\tu16 packed_record[6];\n\n\tif (table_index >= NUMROWS_INGRESSPRECTLFRECORD)\n\t\treturn -EINVAL;\n\n\tmemset(packed_record, 0, sizeof(u16) * 6);\n\n\tpacked_record[0] = rec->sa_da[0] & 0xFFFF;\n\tpacked_record[1] = (rec->sa_da[0] >> 16) & 0xFFFF;\n\tpacked_record[2] = rec->sa_da[1] & 0xFFFF;\n\tpacked_record[3] = rec->eth_type & 0xFFFF;\n\tpacked_record[4] = rec->match_mask & 0xFFFF;\n\tpacked_record[5] = rec->match_type & 0xF;\n\tpacked_record[5] |= (rec->action & 0x1) << 4;\n\n\treturn set_raw_ingress_record(hw, packed_record, 6, 0,\n\t\t\t\t      ROWOFFSET_INGRESSPRECTLFRECORD +\n\t\t\t\t\t      table_index);\n}\n\nint aq_mss_set_ingress_prectlf_record(struct aq_hw_s *hw,\n\tconst struct aq_mss_ingress_prectlf_record *rec,\n\tu16 table_index)\n{\n\treturn AQ_API_CALL_SAFE(set_ingress_prectlf_record, hw, rec,\n\t\t\t\ttable_index);\n}\n\nstatic int get_ingress_prectlf_record(struct aq_hw_s *hw,\n\t\t\t\t      struct aq_mss_ingress_prectlf_record *rec,\n\t\t\t\t      u16 table_index)\n{\n\tu16 packed_record[6];\n\tint ret;\n\n\tif (table_index >= NUMROWS_INGRESSPRECTLFRECORD)\n\t\treturn -EINVAL;\n\n\t \n\tif ((table_index % 2) > 0) {\n\t\tret = get_raw_ingress_record(hw, packed_record, 6, 0,\n\t\t\t\t\t     ROWOFFSET_INGRESSPRECTLFRECORD +\n\t\t\t\t\t\t     table_index - 1);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tret = get_raw_ingress_record(hw, packed_record, 6, 0,\n\t\t\t\t     ROWOFFSET_INGRESSPRECTLFRECORD +\n\t\t\t\t\t     table_index);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\trec->sa_da[0] = packed_record[0];\n\trec->sa_da[0] |= packed_record[1] << 16;\n\n\trec->sa_da[1] = packed_record[2];\n\n\trec->eth_type = packed_record[3];\n\n\trec->match_mask = packed_record[4];\n\n\trec->match_type = packed_record[5] & 0xF;\n\n\trec->action = (packed_record[5] >> 4) & 0x1;\n\n\treturn 0;\n}\n\nint aq_mss_get_ingress_prectlf_record(struct aq_hw_s *hw,\n\t\t\t\t      struct aq_mss_ingress_prectlf_record *rec,\n\t\t\t\t      u16 table_index)\n{\n\tmemset(rec, 0, sizeof(*rec));\n\n\treturn AQ_API_CALL_SAFE(get_ingress_prectlf_record, hw, rec,\n\t\t\t\ttable_index);\n}\n\nstatic int\nset_ingress_preclass_record(struct aq_hw_s *hw,\n\t\t\t    const struct aq_mss_ingress_preclass_record *rec,\n\t\t\t    u16 table_index)\n{\n\tu16 packed_record[20];\n\n\tif (table_index >= NUMROWS_INGRESSPRECLASSRECORD)\n\t\treturn -EINVAL;\n\n\tmemset(packed_record, 0, sizeof(u16) * 20);\n\n\tpacked_record[0] = rec->sci[0] & 0xFFFF;\n\tpacked_record[1] = (rec->sci[0] >> 16) & 0xFFFF;\n\n\tpacked_record[2] = rec->sci[1] & 0xFFFF;\n\tpacked_record[3] = (rec->sci[1] >> 16) & 0xFFFF;\n\n\tpacked_record[4] = rec->tci & 0xFF;\n\n\tpacked_record[4] |= (rec->encr_offset & 0xFF) << 8;\n\n\tpacked_record[5] = rec->eth_type & 0xFFFF;\n\n\tpacked_record[6] = rec->snap[0] & 0xFFFF;\n\tpacked_record[7] = (rec->snap[0] >> 16) & 0xFFFF;\n\n\tpacked_record[8] = rec->snap[1] & 0xFF;\n\n\tpacked_record[8] |= (rec->llc & 0xFF) << 8;\n\tpacked_record[9] = (rec->llc >> 8) & 0xFFFF;\n\n\tpacked_record[10] = rec->mac_sa[0] & 0xFFFF;\n\tpacked_record[11] = (rec->mac_sa[0] >> 16) & 0xFFFF;\n\n\tpacked_record[12] = rec->mac_sa[1] & 0xFFFF;\n\n\tpacked_record[13] = rec->mac_da[0] & 0xFFFF;\n\tpacked_record[14] = (rec->mac_da[0] >> 16) & 0xFFFF;\n\n\tpacked_record[15] = rec->mac_da[1] & 0xFFFF;\n\n\tpacked_record[16] = rec->lpbk_packet & 0x1;\n\n\tpacked_record[16] |= (rec->an_mask & 0x3) << 1;\n\n\tpacked_record[16] |= (rec->tci_mask & 0x3F) << 3;\n\n\tpacked_record[16] |= (rec->sci_mask & 0x7F) << 9;\n\tpacked_record[17] = (rec->sci_mask >> 7) & 0x1;\n\n\tpacked_record[17] |= (rec->eth_type_mask & 0x3) << 1;\n\n\tpacked_record[17] |= (rec->snap_mask & 0x1F) << 3;\n\n\tpacked_record[17] |= (rec->llc_mask & 0x7) << 8;\n\n\tpacked_record[17] |= (rec->_802_2_encapsulate & 0x1) << 11;\n\n\tpacked_record[17] |= (rec->sa_mask & 0xF) << 12;\n\tpacked_record[18] = (rec->sa_mask >> 4) & 0x3;\n\n\tpacked_record[18] |= (rec->da_mask & 0x3F) << 2;\n\n\tpacked_record[18] |= (rec->lpbk_mask & 0x1) << 8;\n\n\tpacked_record[18] |= (rec->sc_idx & 0x1F) << 9;\n\n\tpacked_record[18] |= (rec->proc_dest & 0x1) << 14;\n\n\tpacked_record[18] |= (rec->action & 0x1) << 15;\n\tpacked_record[19] = (rec->action >> 1) & 0x1;\n\n\tpacked_record[19] |= (rec->ctrl_unctrl & 0x1) << 1;\n\n\tpacked_record[19] |= (rec->sci_from_table & 0x1) << 2;\n\n\tpacked_record[19] |= (rec->reserved & 0xF) << 3;\n\n\tpacked_record[19] |= (rec->valid & 0x1) << 7;\n\n\treturn set_raw_ingress_record(hw, packed_record, 20, 1,\n\t\t\t\t      ROWOFFSET_INGRESSPRECLASSRECORD +\n\t\t\t\t\t      table_index);\n}\n\nint aq_mss_set_ingress_preclass_record(struct aq_hw_s *hw,\n\tconst struct aq_mss_ingress_preclass_record *rec,\n\tu16 table_index)\n{\n\tint err = AQ_API_CALL_SAFE(set_ingress_preclass_record, hw, rec,\n\t\t\t\t   table_index);\n\n\tWARN_ONCE(err, \"%s failed with %d\\n\", __func__, err);\n\n\treturn err;\n}\n\nstatic int\nget_ingress_preclass_record(struct aq_hw_s *hw,\n\t\t\t    struct aq_mss_ingress_preclass_record *rec,\n\t\t\t    u16 table_index)\n{\n\tu16 packed_record[20];\n\tint ret;\n\n\tif (table_index >= NUMROWS_INGRESSPRECLASSRECORD)\n\t\treturn -EINVAL;\n\n\t \n\tif ((table_index % 2) > 0) {\n\t\tret = get_raw_ingress_record(hw, packed_record, 20, 1,\n\t\t\t\t\t     ROWOFFSET_INGRESSPRECLASSRECORD +\n\t\t\t\t\t\t     table_index - 1);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tret = get_raw_ingress_record(hw, packed_record, 20, 1,\n\t\t\t\t     ROWOFFSET_INGRESSPRECLASSRECORD +\n\t\t\t\t\t     table_index);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\trec->sci[0] = packed_record[0];\n\trec->sci[0] |= packed_record[1] << 16;\n\n\trec->sci[1] = packed_record[2];\n\trec->sci[1] |= packed_record[3] << 16;\n\n\trec->tci = packed_record[4] & 0xFF;\n\n\trec->encr_offset = (packed_record[4] >> 8) & 0xFF;\n\n\trec->eth_type = packed_record[5];\n\n\trec->snap[0] = packed_record[6];\n\trec->snap[0] |= packed_record[7] << 16;\n\n\trec->snap[1] = packed_record[8] & 0xFF;\n\n\trec->llc = (packed_record[8] >> 8) & 0xFF;\n\trec->llc |= packed_record[9] << 8;\n\n\trec->mac_sa[0] = packed_record[10];\n\trec->mac_sa[0] |= packed_record[11] << 16;\n\n\trec->mac_sa[1] = packed_record[12];\n\n\trec->mac_da[0] = packed_record[13];\n\trec->mac_da[0] |= packed_record[14] << 16;\n\n\trec->mac_da[1] = packed_record[15];\n\n\trec->lpbk_packet = packed_record[16] & 0x1;\n\n\trec->an_mask = (packed_record[16] >> 1) & 0x3;\n\n\trec->tci_mask = (packed_record[16] >> 3) & 0x3F;\n\n\trec->sci_mask = (packed_record[16] >> 9) & 0x7F;\n\trec->sci_mask |= (packed_record[17] & 0x1) << 7;\n\n\trec->eth_type_mask = (packed_record[17] >> 1) & 0x3;\n\n\trec->snap_mask = (packed_record[17] >> 3) & 0x1F;\n\n\trec->llc_mask = (packed_record[17] >> 8) & 0x7;\n\n\trec->_802_2_encapsulate = (packed_record[17] >> 11) & 0x1;\n\n\trec->sa_mask = (packed_record[17] >> 12) & 0xF;\n\trec->sa_mask |= (packed_record[18] & 0x3) << 4;\n\n\trec->da_mask = (packed_record[18] >> 2) & 0x3F;\n\n\trec->lpbk_mask = (packed_record[18] >> 8) & 0x1;\n\n\trec->sc_idx = (packed_record[18] >> 9) & 0x1F;\n\n\trec->proc_dest = (packed_record[18] >> 14) & 0x1;\n\n\trec->action = (packed_record[18] >> 15) & 0x1;\n\trec->action |= (packed_record[19] & 0x1) << 1;\n\n\trec->ctrl_unctrl = (packed_record[19] >> 1) & 0x1;\n\n\trec->sci_from_table = (packed_record[19] >> 2) & 0x1;\n\n\trec->reserved = (packed_record[19] >> 3) & 0xF;\n\n\trec->valid = (packed_record[19] >> 7) & 0x1;\n\n\treturn 0;\n}\n\nint aq_mss_get_ingress_preclass_record(struct aq_hw_s *hw,\n\tstruct aq_mss_ingress_preclass_record *rec,\n\tu16 table_index)\n{\n\tmemset(rec, 0, sizeof(*rec));\n\n\treturn AQ_API_CALL_SAFE(get_ingress_preclass_record, hw, rec,\n\t\t\t\ttable_index);\n}\n\nstatic int set_ingress_sc_record(struct aq_hw_s *hw,\n\t\t\t\t const struct aq_mss_ingress_sc_record *rec,\n\t\t\t\t u16 table_index)\n{\n\tu16 packed_record[8];\n\n\tif (table_index >= NUMROWS_INGRESSSCRECORD)\n\t\treturn -EINVAL;\n\n\tmemset(packed_record, 0, sizeof(u16) * 8);\n\n\tpacked_record[0] = rec->stop_time & 0xFFFF;\n\tpacked_record[1] = (rec->stop_time >> 16) & 0xFFFF;\n\n\tpacked_record[2] = rec->start_time & 0xFFFF;\n\tpacked_record[3] = (rec->start_time >> 16) & 0xFFFF;\n\n\tpacked_record[4] = rec->validate_frames & 0x3;\n\n\tpacked_record[4] |= (rec->replay_protect & 0x1) << 2;\n\n\tpacked_record[4] |= (rec->anti_replay_window & 0x1FFF) << 3;\n\tpacked_record[5] = (rec->anti_replay_window >> 13) & 0xFFFF;\n\tpacked_record[6] = (rec->anti_replay_window >> 29) & 0x7;\n\n\tpacked_record[6] |= (rec->receiving & 0x1) << 3;\n\n\tpacked_record[6] |= (rec->fresh & 0x1) << 4;\n\n\tpacked_record[6] |= (rec->an_rol & 0x1) << 5;\n\n\tpacked_record[6] |= (rec->reserved & 0x3FF) << 6;\n\tpacked_record[7] = (rec->reserved >> 10) & 0x7FFF;\n\n\tpacked_record[7] |= (rec->valid & 0x1) << 15;\n\n\treturn set_raw_ingress_record(hw, packed_record, 8, 3,\n\t\t\t\t      ROWOFFSET_INGRESSSCRECORD + table_index);\n}\n\nint aq_mss_set_ingress_sc_record(struct aq_hw_s *hw,\n\t\t\t\t const struct aq_mss_ingress_sc_record *rec,\n\t\t\t\t u16 table_index)\n{\n\tint err = AQ_API_CALL_SAFE(set_ingress_sc_record, hw, rec, table_index);\n\n\tWARN_ONCE(err, \"%s failed with %d\\n\", __func__, err);\n\n\treturn err;\n}\n\nstatic int get_ingress_sc_record(struct aq_hw_s *hw,\n\t\t\t\t struct aq_mss_ingress_sc_record *rec,\n\t\t\t\t u16 table_index)\n{\n\tu16 packed_record[8];\n\tint ret;\n\n\tif (table_index >= NUMROWS_INGRESSSCRECORD)\n\t\treturn -EINVAL;\n\n\tret = get_raw_ingress_record(hw, packed_record, 8, 3,\n\t\t\t\t     ROWOFFSET_INGRESSSCRECORD + table_index);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\trec->stop_time = packed_record[0];\n\trec->stop_time |= packed_record[1] << 16;\n\n\trec->start_time = packed_record[2];\n\trec->start_time |= packed_record[3] << 16;\n\n\trec->validate_frames = packed_record[4] & 0x3;\n\n\trec->replay_protect = (packed_record[4] >> 2) & 0x1;\n\n\trec->anti_replay_window = (packed_record[4] >> 3) & 0x1FFF;\n\trec->anti_replay_window |= packed_record[5] << 13;\n\trec->anti_replay_window |= (packed_record[6] & 0x7) << 29;\n\n\trec->receiving = (packed_record[6] >> 3) & 0x1;\n\n\trec->fresh = (packed_record[6] >> 4) & 0x1;\n\n\trec->an_rol = (packed_record[6] >> 5) & 0x1;\n\n\trec->reserved = (packed_record[6] >> 6) & 0x3FF;\n\trec->reserved |= (packed_record[7] & 0x7FFF) << 10;\n\n\trec->valid = (packed_record[7] >> 15) & 0x1;\n\n\treturn 0;\n}\n\nint aq_mss_get_ingress_sc_record(struct aq_hw_s *hw,\n\t\t\t\t struct aq_mss_ingress_sc_record *rec,\n\t\t\t\t u16 table_index)\n{\n\tmemset(rec, 0, sizeof(*rec));\n\n\treturn AQ_API_CALL_SAFE(get_ingress_sc_record, hw, rec, table_index);\n}\n\nstatic int set_ingress_sa_record(struct aq_hw_s *hw,\n\t\t\t\t const struct aq_mss_ingress_sa_record *rec,\n\t\t\t\t u16 table_index)\n{\n\tu16 packed_record[8];\n\n\tif (table_index >= NUMROWS_INGRESSSARECORD)\n\t\treturn -EINVAL;\n\n\tmemset(packed_record, 0, sizeof(u16) * 8);\n\n\tpacked_record[0] = rec->stop_time & 0xFFFF;\n\tpacked_record[1] = (rec->stop_time >> 16) & 0xFFFF;\n\n\tpacked_record[2] = rec->start_time & 0xFFFF;\n\tpacked_record[3] = (rec->start_time >> 16) & 0xFFFF;\n\n\tpacked_record[4] = rec->next_pn & 0xFFFF;\n\tpacked_record[5] = (rec->next_pn >> 16) & 0xFFFF;\n\n\tpacked_record[6] = rec->sat_nextpn & 0x1;\n\n\tpacked_record[6] |= (rec->in_use & 0x1) << 1;\n\n\tpacked_record[6] |= (rec->fresh & 0x1) << 2;\n\n\tpacked_record[6] |= (rec->reserved & 0x1FFF) << 3;\n\tpacked_record[7] = (rec->reserved >> 13) & 0x7FFF;\n\n\tpacked_record[7] |= (rec->valid & 0x1) << 15;\n\n\treturn set_raw_ingress_record(hw, packed_record, 8, 3,\n\t\t\t\t      ROWOFFSET_INGRESSSARECORD + table_index);\n}\n\nint aq_mss_set_ingress_sa_record(struct aq_hw_s *hw,\n\t\t\t\t const struct aq_mss_ingress_sa_record *rec,\n\t\t\t\t u16 table_index)\n{\n\tint err = AQ_API_CALL_SAFE(set_ingress_sa_record, hw, rec, table_index);\n\n\tWARN_ONCE(err, \"%s failed with %d\\n\", __func__, err);\n\n\treturn err;\n}\n\nstatic int get_ingress_sa_record(struct aq_hw_s *hw,\n\t\t\t\t struct aq_mss_ingress_sa_record *rec,\n\t\t\t\t u16 table_index)\n{\n\tu16 packed_record[8];\n\tint ret;\n\n\tif (table_index >= NUMROWS_INGRESSSARECORD)\n\t\treturn -EINVAL;\n\n\tret = get_raw_ingress_record(hw, packed_record, 8, 3,\n\t\t\t\t     ROWOFFSET_INGRESSSARECORD + table_index);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\trec->stop_time = packed_record[0];\n\trec->stop_time |= packed_record[1] << 16;\n\n\trec->start_time = packed_record[2];\n\trec->start_time |= packed_record[3] << 16;\n\n\trec->next_pn = packed_record[4];\n\trec->next_pn |= packed_record[5] << 16;\n\n\trec->sat_nextpn = packed_record[6] & 0x1;\n\n\trec->in_use = (packed_record[6] >> 1) & 0x1;\n\n\trec->fresh = (packed_record[6] >> 2) & 0x1;\n\n\trec->reserved = (packed_record[6] >> 3) & 0x1FFF;\n\trec->reserved |= (packed_record[7] & 0x7FFF) << 13;\n\n\trec->valid = (packed_record[7] >> 15) & 0x1;\n\n\treturn 0;\n}\n\nint aq_mss_get_ingress_sa_record(struct aq_hw_s *hw,\n\t\t\t\t struct aq_mss_ingress_sa_record *rec,\n\t\t\t\t u16 table_index)\n{\n\tmemset(rec, 0, sizeof(*rec));\n\n\treturn AQ_API_CALL_SAFE(get_ingress_sa_record, hw, rec, table_index);\n}\n\nstatic int\nset_ingress_sakey_record(struct aq_hw_s *hw,\n\t\t\t const struct aq_mss_ingress_sakey_record *rec,\n\t\t\t u16 table_index)\n{\n\tu16 packed_record[18];\n\tint ret;\n\n\tif (table_index >= NUMROWS_INGRESSSAKEYRECORD)\n\t\treturn -EINVAL;\n\n\tmemset(packed_record, 0, sizeof(u16) * 18);\n\n\tpacked_record[0] = rec->key[0] & 0xFFFF;\n\tpacked_record[1] = (rec->key[0] >> 16) & 0xFFFF;\n\n\tpacked_record[2] = rec->key[1] & 0xFFFF;\n\tpacked_record[3] = (rec->key[1] >> 16) & 0xFFFF;\n\n\tpacked_record[4] = rec->key[2] & 0xFFFF;\n\tpacked_record[5] = (rec->key[2] >> 16) & 0xFFFF;\n\n\tpacked_record[6] = rec->key[3] & 0xFFFF;\n\tpacked_record[7] = (rec->key[3] >> 16) & 0xFFFF;\n\n\tpacked_record[8] = rec->key[4] & 0xFFFF;\n\tpacked_record[9] = (rec->key[4] >> 16) & 0xFFFF;\n\n\tpacked_record[10] = rec->key[5] & 0xFFFF;\n\tpacked_record[11] = (rec->key[5] >> 16) & 0xFFFF;\n\n\tpacked_record[12] = rec->key[6] & 0xFFFF;\n\tpacked_record[13] = (rec->key[6] >> 16) & 0xFFFF;\n\n\tpacked_record[14] = rec->key[7] & 0xFFFF;\n\tpacked_record[15] = (rec->key[7] >> 16) & 0xFFFF;\n\n\tpacked_record[16] = rec->key_len & 0x3;\n\n\tret = set_raw_ingress_record(hw, packed_record, 18, 2,\n\t\t\t\t     ROWOFFSET_INGRESSSAKEYRECORD +\n\t\t\t\t     table_index);\n\n\tmemzero_explicit(packed_record, sizeof(packed_record));\n\treturn ret;\n}\n\nint aq_mss_set_ingress_sakey_record(struct aq_hw_s *hw,\n\tconst struct aq_mss_ingress_sakey_record *rec,\n\tu16 table_index)\n{\n\tint err = AQ_API_CALL_SAFE(set_ingress_sakey_record, hw, rec,\n\t\t\t\t   table_index);\n\n\tWARN_ONCE(err, \"%s failed with %d\\n\", __func__, err);\n\n\treturn err;\n}\n\nstatic int get_ingress_sakey_record(struct aq_hw_s *hw,\n\t\t\t\t    struct aq_mss_ingress_sakey_record *rec,\n\t\t\t\t    u16 table_index)\n{\n\tu16 packed_record[18];\n\tint ret;\n\n\tif (table_index >= NUMROWS_INGRESSSAKEYRECORD)\n\t\treturn -EINVAL;\n\n\tret = get_raw_ingress_record(hw, packed_record, 18, 2,\n\t\t\t\t     ROWOFFSET_INGRESSSAKEYRECORD +\n\t\t\t\t\t     table_index);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\trec->key[0] = packed_record[0];\n\trec->key[0] |= packed_record[1] << 16;\n\n\trec->key[1] = packed_record[2];\n\trec->key[1] |= packed_record[3] << 16;\n\n\trec->key[2] = packed_record[4];\n\trec->key[2] |= packed_record[5] << 16;\n\n\trec->key[3] = packed_record[6];\n\trec->key[3] |= packed_record[7] << 16;\n\n\trec->key[4] = packed_record[8];\n\trec->key[4] |= packed_record[9] << 16;\n\n\trec->key[5] = packed_record[10];\n\trec->key[5] |= packed_record[11] << 16;\n\n\trec->key[6] = packed_record[12];\n\trec->key[6] |= packed_record[13] << 16;\n\n\trec->key[7] = packed_record[14];\n\trec->key[7] |= packed_record[15] << 16;\n\n\trec->key_len = packed_record[16] & 0x3;\n\n\treturn 0;\n}\n\nint aq_mss_get_ingress_sakey_record(struct aq_hw_s *hw,\n\t\t\t\t    struct aq_mss_ingress_sakey_record *rec,\n\t\t\t\t    u16 table_index)\n{\n\tmemset(rec, 0, sizeof(*rec));\n\n\treturn AQ_API_CALL_SAFE(get_ingress_sakey_record, hw, rec, table_index);\n}\n\nstatic int\nset_ingress_postclass_record(struct aq_hw_s *hw,\n\t\t\t     const struct aq_mss_ingress_postclass_record *rec,\n\t\t\t     u16 table_index)\n{\n\tu16 packed_record[8];\n\n\tif (table_index >= NUMROWS_INGRESSPOSTCLASSRECORD)\n\t\treturn -EINVAL;\n\n\tmemset(packed_record, 0, sizeof(u16) * 8);\n\n\tpacked_record[0] = rec->byte0 & 0xFF;\n\n\tpacked_record[0] |= (rec->byte1 & 0xFF) << 8;\n\n\tpacked_record[1] = rec->byte2 & 0xFF;\n\n\tpacked_record[1] |= (rec->byte3 & 0xFF) << 8;\n\n\tpacked_record[2] = rec->eth_type & 0xFFFF;\n\n\tpacked_record[3] = rec->eth_type_valid & 0x1;\n\n\tpacked_record[3] |= (rec->vlan_id & 0xFFF) << 1;\n\n\tpacked_record[3] |= (rec->vlan_up & 0x7) << 13;\n\n\tpacked_record[4] = rec->vlan_valid & 0x1;\n\n\tpacked_record[4] |= (rec->sai & 0x1F) << 1;\n\n\tpacked_record[4] |= (rec->sai_hit & 0x1) << 6;\n\n\tpacked_record[4] |= (rec->eth_type_mask & 0xF) << 7;\n\n\tpacked_record[4] |= (rec->byte3_location & 0x1F) << 11;\n\tpacked_record[5] = (rec->byte3_location >> 5) & 0x1;\n\n\tpacked_record[5] |= (rec->byte3_mask & 0x3) << 1;\n\n\tpacked_record[5] |= (rec->byte2_location & 0x3F) << 3;\n\n\tpacked_record[5] |= (rec->byte2_mask & 0x3) << 9;\n\n\tpacked_record[5] |= (rec->byte1_location & 0x1F) << 11;\n\tpacked_record[6] = (rec->byte1_location >> 5) & 0x1;\n\n\tpacked_record[6] |= (rec->byte1_mask & 0x3) << 1;\n\n\tpacked_record[6] |= (rec->byte0_location & 0x3F) << 3;\n\n\tpacked_record[6] |= (rec->byte0_mask & 0x3) << 9;\n\n\tpacked_record[6] |= (rec->eth_type_valid_mask & 0x3) << 11;\n\n\tpacked_record[6] |= (rec->vlan_id_mask & 0x7) << 13;\n\tpacked_record[7] = (rec->vlan_id_mask >> 3) & 0x1;\n\n\tpacked_record[7] |= (rec->vlan_up_mask & 0x3) << 1;\n\n\tpacked_record[7] |= (rec->vlan_valid_mask & 0x3) << 3;\n\n\tpacked_record[7] |= (rec->sai_mask & 0x3) << 5;\n\n\tpacked_record[7] |= (rec->sai_hit_mask & 0x3) << 7;\n\n\tpacked_record[7] |= (rec->firstlevel_actions & 0x1) << 9;\n\n\tpacked_record[7] |= (rec->secondlevel_actions & 0x1) << 10;\n\n\tpacked_record[7] |= (rec->reserved & 0xF) << 11;\n\n\tpacked_record[7] |= (rec->valid & 0x1) << 15;\n\n\treturn set_raw_ingress_record(hw, packed_record, 8, 4,\n\t\t\t\t      ROWOFFSET_INGRESSPOSTCLASSRECORD +\n\t\t\t\t\t      table_index);\n}\n\nint aq_mss_set_ingress_postclass_record(struct aq_hw_s *hw,\n\tconst struct aq_mss_ingress_postclass_record *rec,\n\tu16 table_index)\n{\n\treturn AQ_API_CALL_SAFE(set_ingress_postclass_record, hw, rec,\n\t\t\t\ttable_index);\n}\n\nstatic int\nget_ingress_postclass_record(struct aq_hw_s *hw,\n\t\t\t     struct aq_mss_ingress_postclass_record *rec,\n\t\t\t     u16 table_index)\n{\n\tu16 packed_record[8];\n\tint ret;\n\n\tif (table_index >= NUMROWS_INGRESSPOSTCLASSRECORD)\n\t\treturn -EINVAL;\n\n\t \n\tif ((table_index % 2) > 0) {\n\t\tret = get_raw_ingress_record(hw, packed_record, 8, 4,\n\t\t\t\t\t     ROWOFFSET_INGRESSPOSTCLASSRECORD +\n\t\t\t\t\t\t     table_index - 1);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tret = get_raw_ingress_record(hw, packed_record, 8, 4,\n\t\t\t\t     ROWOFFSET_INGRESSPOSTCLASSRECORD +\n\t\t\t\t\t     table_index);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\trec->byte0 = packed_record[0] & 0xFF;\n\n\trec->byte1 = (packed_record[0] >> 8) & 0xFF;\n\n\trec->byte2 = packed_record[1] & 0xFF;\n\n\trec->byte3 = (packed_record[1] >> 8) & 0xFF;\n\n\trec->eth_type = packed_record[2];\n\n\trec->eth_type_valid = packed_record[3] & 0x1;\n\n\trec->vlan_id = (packed_record[3] >> 1) & 0xFFF;\n\n\trec->vlan_up = (packed_record[3] >> 13) & 0x7;\n\n\trec->vlan_valid = packed_record[4] & 0x1;\n\n\trec->sai = (packed_record[4] >> 1) & 0x1F;\n\n\trec->sai_hit = (packed_record[4] >> 6) & 0x1;\n\n\trec->eth_type_mask = (packed_record[4] >> 7) & 0xF;\n\n\trec->byte3_location = (packed_record[4] >> 11) & 0x1F;\n\trec->byte3_location |= (packed_record[5] & 0x1) << 5;\n\n\trec->byte3_mask = (packed_record[5] >> 1) & 0x3;\n\n\trec->byte2_location = (packed_record[5] >> 3) & 0x3F;\n\n\trec->byte2_mask = (packed_record[5] >> 9) & 0x3;\n\n\trec->byte1_location = (packed_record[5] >> 11) & 0x1F;\n\trec->byte1_location |= (packed_record[6] & 0x1) << 5;\n\n\trec->byte1_mask = (packed_record[6] >> 1) & 0x3;\n\n\trec->byte0_location = (packed_record[6] >> 3) & 0x3F;\n\n\trec->byte0_mask = (packed_record[6] >> 9) & 0x3;\n\n\trec->eth_type_valid_mask = (packed_record[6] >> 11) & 0x3;\n\n\trec->vlan_id_mask = (packed_record[6] >> 13) & 0x7;\n\trec->vlan_id_mask |= (packed_record[7] & 0x1) << 3;\n\n\trec->vlan_up_mask = (packed_record[7] >> 1) & 0x3;\n\n\trec->vlan_valid_mask = (packed_record[7] >> 3) & 0x3;\n\n\trec->sai_mask = (packed_record[7] >> 5) & 0x3;\n\n\trec->sai_hit_mask = (packed_record[7] >> 7) & 0x3;\n\n\trec->firstlevel_actions = (packed_record[7] >> 9) & 0x1;\n\n\trec->secondlevel_actions = (packed_record[7] >> 10) & 0x1;\n\n\trec->reserved = (packed_record[7] >> 11) & 0xF;\n\n\trec->valid = (packed_record[7] >> 15) & 0x1;\n\n\treturn 0;\n}\n\nint aq_mss_get_ingress_postclass_record(struct aq_hw_s *hw,\n\tstruct aq_mss_ingress_postclass_record *rec,\n\tu16 table_index)\n{\n\tmemset(rec, 0, sizeof(*rec));\n\n\treturn AQ_API_CALL_SAFE(get_ingress_postclass_record, hw, rec,\n\t\t\t\ttable_index);\n}\n\nstatic int\nset_ingress_postctlf_record(struct aq_hw_s *hw,\n\t\t\t    const struct aq_mss_ingress_postctlf_record *rec,\n\t\t\t    u16 table_index)\n{\n\tu16 packed_record[6];\n\n\tif (table_index >= NUMROWS_INGRESSPOSTCTLFRECORD)\n\t\treturn -EINVAL;\n\n\tmemset(packed_record, 0, sizeof(u16) * 6);\n\n\tpacked_record[0] = rec->sa_da[0] & 0xFFFF;\n\tpacked_record[1] = (rec->sa_da[0] >> 16) & 0xFFFF;\n\n\tpacked_record[2] = rec->sa_da[1] & 0xFFFF;\n\n\tpacked_record[3] = rec->eth_type & 0xFFFF;\n\n\tpacked_record[4] = rec->match_mask & 0xFFFF;\n\n\tpacked_record[5] = rec->match_type & 0xF;\n\n\tpacked_record[5] |= (rec->action & 0x1) << 4;\n\n\treturn set_raw_ingress_record(hw, packed_record, 6, 5,\n\t\t\t\t      ROWOFFSET_INGRESSPOSTCTLFRECORD +\n\t\t\t\t\t      table_index);\n}\n\nint aq_mss_set_ingress_postctlf_record(struct aq_hw_s *hw,\n\tconst struct aq_mss_ingress_postctlf_record *rec,\n\tu16 table_index)\n{\n\treturn AQ_API_CALL_SAFE(set_ingress_postctlf_record, hw, rec,\n\t\t\t\ttable_index);\n}\n\nstatic int\nget_ingress_postctlf_record(struct aq_hw_s *hw,\n\t\t\t    struct aq_mss_ingress_postctlf_record *rec,\n\t\t\t    u16 table_index)\n{\n\tu16 packed_record[6];\n\tint ret;\n\n\tif (table_index >= NUMROWS_INGRESSPOSTCTLFRECORD)\n\t\treturn -EINVAL;\n\n\t \n\tif ((table_index % 2) > 0) {\n\t\tret = get_raw_ingress_record(hw, packed_record, 6, 5,\n\t\t\t\t\t     ROWOFFSET_INGRESSPOSTCTLFRECORD +\n\t\t\t\t\t\t     table_index - 1);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tret = get_raw_ingress_record(hw, packed_record, 6, 5,\n\t\t\t\t     ROWOFFSET_INGRESSPOSTCTLFRECORD +\n\t\t\t\t\t     table_index);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\trec->sa_da[0] = packed_record[0];\n\trec->sa_da[0] |= packed_record[1] << 16;\n\n\trec->sa_da[1] = packed_record[2];\n\n\trec->eth_type = packed_record[3];\n\n\trec->match_mask = packed_record[4];\n\n\trec->match_type = packed_record[5] & 0xF;\n\n\trec->action = (packed_record[5] >> 4) & 0x1;\n\n\treturn 0;\n}\n\nint aq_mss_get_ingress_postctlf_record(struct aq_hw_s *hw,\n\tstruct aq_mss_ingress_postctlf_record *rec,\n\tu16 table_index)\n{\n\tmemset(rec, 0, sizeof(*rec));\n\n\treturn AQ_API_CALL_SAFE(get_ingress_postctlf_record, hw, rec,\n\t\t\t\ttable_index);\n}\n\nstatic int set_egress_ctlf_record(struct aq_hw_s *hw,\n\t\t\t\t  const struct aq_mss_egress_ctlf_record *rec,\n\t\t\t\t  u16 table_index)\n{\n\tu16 packed_record[6];\n\n\tif (table_index >= NUMROWS_EGRESSCTLFRECORD)\n\t\treturn -EINVAL;\n\n\tmemset(packed_record, 0, sizeof(u16) * 6);\n\n\tpacked_record[0] = rec->sa_da[0] & 0xFFFF;\n\tpacked_record[1] = (rec->sa_da[0] >> 16) & 0xFFFF;\n\n\tpacked_record[2] = rec->sa_da[1] & 0xFFFF;\n\n\tpacked_record[3] = rec->eth_type & 0xFFFF;\n\n\tpacked_record[4] = rec->match_mask & 0xFFFF;\n\n\tpacked_record[5] = rec->match_type & 0xF;\n\n\tpacked_record[5] |= (rec->action & 0x1) << 4;\n\n\treturn set_raw_egress_record(hw, packed_record, 6, 0,\n\t\t\t\t     ROWOFFSET_EGRESSCTLFRECORD + table_index);\n}\n\nint aq_mss_set_egress_ctlf_record(struct aq_hw_s *hw,\n\t\t\t\t  const struct aq_mss_egress_ctlf_record *rec,\n\t\t\t\t  u16 table_index)\n{\n\treturn AQ_API_CALL_SAFE(set_egress_ctlf_record, hw, rec, table_index);\n}\n\nstatic int get_egress_ctlf_record(struct aq_hw_s *hw,\n\t\t\t\t  struct aq_mss_egress_ctlf_record *rec,\n\t\t\t\t  u16 table_index)\n{\n\tu16 packed_record[6];\n\tint ret;\n\n\tif (table_index >= NUMROWS_EGRESSCTLFRECORD)\n\t\treturn -EINVAL;\n\n\t \n\tif ((table_index % 2) > 0) {\n\t\tret = get_raw_egress_record(hw, packed_record, 6, 0,\n\t\t\t\t\t    ROWOFFSET_EGRESSCTLFRECORD +\n\t\t\t\t\t\t    table_index - 1);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tret = get_raw_egress_record(hw, packed_record, 6, 0,\n\t\t\t\t    ROWOFFSET_EGRESSCTLFRECORD + table_index);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\trec->sa_da[0] = packed_record[0];\n\trec->sa_da[0] |= packed_record[1] << 16;\n\n\trec->sa_da[1] = packed_record[2];\n\n\trec->eth_type = packed_record[3];\n\n\trec->match_mask = packed_record[4];\n\n\trec->match_type = packed_record[5] & 0xF;\n\n\trec->action = (packed_record[5] >> 4) & 0x1;\n\n\treturn 0;\n}\n\nint aq_mss_get_egress_ctlf_record(struct aq_hw_s *hw,\n\t\t\t\t  struct aq_mss_egress_ctlf_record *rec,\n\t\t\t\t  u16 table_index)\n{\n\tmemset(rec, 0, sizeof(*rec));\n\n\treturn AQ_API_CALL_SAFE(get_egress_ctlf_record, hw, rec, table_index);\n}\n\nstatic int set_egress_class_record(struct aq_hw_s *hw,\n\t\t\t\t   const struct aq_mss_egress_class_record *rec,\n\t\t\t\t   u16 table_index)\n{\n\tu16 packed_record[28];\n\n\tif (table_index >= NUMROWS_EGRESSCLASSRECORD)\n\t\treturn -EINVAL;\n\n\tmemset(packed_record, 0, sizeof(u16) * 28);\n\n\tpacked_record[0] = rec->vlan_id & 0xFFF;\n\n\tpacked_record[0] |= (rec->vlan_up & 0x7) << 12;\n\n\tpacked_record[0] |= (rec->vlan_valid & 0x1) << 15;\n\n\tpacked_record[1] = rec->byte3 & 0xFF;\n\n\tpacked_record[1] |= (rec->byte2 & 0xFF) << 8;\n\n\tpacked_record[2] = rec->byte1 & 0xFF;\n\n\tpacked_record[2] |= (rec->byte0 & 0xFF) << 8;\n\n\tpacked_record[3] = rec->tci & 0xFF;\n\n\tpacked_record[3] |= (rec->sci[0] & 0xFF) << 8;\n\tpacked_record[4] = (rec->sci[0] >> 8) & 0xFFFF;\n\tpacked_record[5] = (rec->sci[0] >> 24) & 0xFF;\n\n\tpacked_record[5] |= (rec->sci[1] & 0xFF) << 8;\n\tpacked_record[6] = (rec->sci[1] >> 8) & 0xFFFF;\n\tpacked_record[7] = (rec->sci[1] >> 24) & 0xFF;\n\n\tpacked_record[7] |= (rec->eth_type & 0xFF) << 8;\n\tpacked_record[8] = (rec->eth_type >> 8) & 0xFF;\n\n\tpacked_record[8] |= (rec->snap[0] & 0xFF) << 8;\n\tpacked_record[9] = (rec->snap[0] >> 8) & 0xFFFF;\n\tpacked_record[10] = (rec->snap[0] >> 24) & 0xFF;\n\n\tpacked_record[10] |= (rec->snap[1] & 0xFF) << 8;\n\n\tpacked_record[11] = rec->llc & 0xFFFF;\n\tpacked_record[12] = (rec->llc >> 16) & 0xFF;\n\n\tpacked_record[12] |= (rec->mac_sa[0] & 0xFF) << 8;\n\tpacked_record[13] = (rec->mac_sa[0] >> 8) & 0xFFFF;\n\tpacked_record[14] = (rec->mac_sa[0] >> 24) & 0xFF;\n\n\tpacked_record[14] |= (rec->mac_sa[1] & 0xFF) << 8;\n\tpacked_record[15] = (rec->mac_sa[1] >> 8) & 0xFF;\n\n\tpacked_record[15] |= (rec->mac_da[0] & 0xFF) << 8;\n\tpacked_record[16] = (rec->mac_da[0] >> 8) & 0xFFFF;\n\tpacked_record[17] = (rec->mac_da[0] >> 24) & 0xFF;\n\n\tpacked_record[17] |= (rec->mac_da[1] & 0xFF) << 8;\n\tpacked_record[18] = (rec->mac_da[1] >> 8) & 0xFF;\n\n\tpacked_record[18] |= (rec->pn & 0xFF) << 8;\n\tpacked_record[19] = (rec->pn >> 8) & 0xFFFF;\n\tpacked_record[20] = (rec->pn >> 24) & 0xFF;\n\n\tpacked_record[20] |= (rec->byte3_location & 0x3F) << 8;\n\n\tpacked_record[20] |= (rec->byte3_mask & 0x1) << 14;\n\n\tpacked_record[20] |= (rec->byte2_location & 0x1) << 15;\n\tpacked_record[21] = (rec->byte2_location >> 1) & 0x1F;\n\n\tpacked_record[21] |= (rec->byte2_mask & 0x1) << 5;\n\n\tpacked_record[21] |= (rec->byte1_location & 0x3F) << 6;\n\n\tpacked_record[21] |= (rec->byte1_mask & 0x1) << 12;\n\n\tpacked_record[21] |= (rec->byte0_location & 0x7) << 13;\n\tpacked_record[22] = (rec->byte0_location >> 3) & 0x7;\n\n\tpacked_record[22] |= (rec->byte0_mask & 0x1) << 3;\n\n\tpacked_record[22] |= (rec->vlan_id_mask & 0x3) << 4;\n\n\tpacked_record[22] |= (rec->vlan_up_mask & 0x1) << 6;\n\n\tpacked_record[22] |= (rec->vlan_valid_mask & 0x1) << 7;\n\n\tpacked_record[22] |= (rec->tci_mask & 0xFF) << 8;\n\n\tpacked_record[23] = rec->sci_mask & 0xFF;\n\n\tpacked_record[23] |= (rec->eth_type_mask & 0x3) << 8;\n\n\tpacked_record[23] |= (rec->snap_mask & 0x1F) << 10;\n\n\tpacked_record[23] |= (rec->llc_mask & 0x1) << 15;\n\tpacked_record[24] = (rec->llc_mask >> 1) & 0x3;\n\n\tpacked_record[24] |= (rec->sa_mask & 0x3F) << 2;\n\n\tpacked_record[24] |= (rec->da_mask & 0x3F) << 8;\n\n\tpacked_record[24] |= (rec->pn_mask & 0x3) << 14;\n\tpacked_record[25] = (rec->pn_mask >> 2) & 0x3;\n\n\tpacked_record[25] |= (rec->eight02dot2 & 0x1) << 2;\n\n\tpacked_record[25] |= (rec->tci_sc & 0x1) << 3;\n\n\tpacked_record[25] |= (rec->tci_87543 & 0x1) << 4;\n\n\tpacked_record[25] |= (rec->exp_sectag_en & 0x1) << 5;\n\n\tpacked_record[25] |= (rec->sc_idx & 0x1F) << 6;\n\n\tpacked_record[25] |= (rec->sc_sa & 0x3) << 11;\n\n\tpacked_record[25] |= (rec->debug & 0x1) << 13;\n\n\tpacked_record[25] |= (rec->action & 0x3) << 14;\n\n\tpacked_record[26] = (rec->valid & 0x1) << 3;\n\n\treturn set_raw_egress_record(hw, packed_record, 28, 1,\n\t\t\t\t     ROWOFFSET_EGRESSCLASSRECORD + table_index);\n}\n\nint aq_mss_set_egress_class_record(struct aq_hw_s *hw,\n\t\t\t\t   const struct aq_mss_egress_class_record *rec,\n\t\t\t\t   u16 table_index)\n{\n\treturn AQ_API_CALL_SAFE(set_egress_class_record, hw, rec, table_index);\n}\n\nstatic int get_egress_class_record(struct aq_hw_s *hw,\n\t\t\t\t   struct aq_mss_egress_class_record *rec,\n\t\t\t\t   u16 table_index)\n{\n\tu16 packed_record[28];\n\tint ret;\n\n\tif (table_index >= NUMROWS_EGRESSCLASSRECORD)\n\t\treturn -EINVAL;\n\n\t \n\tif ((table_index % 2) > 0) {\n\t\tret = get_raw_egress_record(hw, packed_record, 28, 1,\n\t\t\t\t\t    ROWOFFSET_EGRESSCLASSRECORD +\n\t\t\t\t\t\t    table_index - 1);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\t}\n\n\tret = get_raw_egress_record(hw, packed_record, 28, 1,\n\t\t\t\t    ROWOFFSET_EGRESSCLASSRECORD + table_index);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\trec->vlan_id = packed_record[0] & 0xFFF;\n\n\trec->vlan_up = (packed_record[0] >> 12) & 0x7;\n\n\trec->vlan_valid = (packed_record[0] >> 15) & 0x1;\n\n\trec->byte3 = packed_record[1] & 0xFF;\n\n\trec->byte2 = (packed_record[1] >> 8) & 0xFF;\n\n\trec->byte1 = packed_record[2] & 0xFF;\n\n\trec->byte0 = (packed_record[2] >> 8) & 0xFF;\n\n\trec->tci = packed_record[3] & 0xFF;\n\n\trec->sci[0] = (packed_record[3] >> 8) & 0xFF;\n\trec->sci[0] |= packed_record[4] << 8;\n\trec->sci[0] |= (packed_record[5] & 0xFF) << 24;\n\n\trec->sci[1] = (packed_record[5] >> 8) & 0xFF;\n\trec->sci[1] |= packed_record[6] << 8;\n\trec->sci[1] |= (packed_record[7] & 0xFF) << 24;\n\n\trec->eth_type = (packed_record[7] >> 8) & 0xFF;\n\trec->eth_type |= (packed_record[8] & 0xFF) << 8;\n\n\trec->snap[0] = (packed_record[8] >> 8) & 0xFF;\n\trec->snap[0] |= packed_record[9] << 8;\n\trec->snap[0] |= (packed_record[10] & 0xFF) << 24;\n\n\trec->snap[1] = (packed_record[10] >> 8) & 0xFF;\n\n\trec->llc = packed_record[11];\n\trec->llc |= (packed_record[12] & 0xFF) << 16;\n\n\trec->mac_sa[0] = (packed_record[12] >> 8) & 0xFF;\n\trec->mac_sa[0] |= packed_record[13] << 8;\n\trec->mac_sa[0] |= (packed_record[14] & 0xFF) << 24;\n\n\trec->mac_sa[1] = (packed_record[14] >> 8) & 0xFF;\n\trec->mac_sa[1] |= (packed_record[15] & 0xFF) << 8;\n\n\trec->mac_da[0] = (packed_record[15] >> 8) & 0xFF;\n\trec->mac_da[0] |= packed_record[16] << 8;\n\trec->mac_da[0] |= (packed_record[17] & 0xFF) << 24;\n\n\trec->mac_da[1] = (packed_record[17] >> 8) & 0xFF;\n\trec->mac_da[1] |= (packed_record[18] & 0xFF) << 8;\n\n\trec->pn = (packed_record[18] >> 8) & 0xFF;\n\trec->pn |= packed_record[19] << 8;\n\trec->pn |= (packed_record[20] & 0xFF) << 24;\n\n\trec->byte3_location = (packed_record[20] >> 8) & 0x3F;\n\n\trec->byte3_mask = (packed_record[20] >> 14) & 0x1;\n\n\trec->byte2_location = (packed_record[20] >> 15) & 0x1;\n\trec->byte2_location |= (packed_record[21] & 0x1F) << 1;\n\n\trec->byte2_mask = (packed_record[21] >> 5) & 0x1;\n\n\trec->byte1_location = (packed_record[21] >> 6) & 0x3F;\n\n\trec->byte1_mask = (packed_record[21] >> 12) & 0x1;\n\n\trec->byte0_location = (packed_record[21] >> 13) & 0x7;\n\trec->byte0_location |= (packed_record[22] & 0x7) << 3;\n\n\trec->byte0_mask = (packed_record[22] >> 3) & 0x1;\n\n\trec->vlan_id_mask = (packed_record[22] >> 4) & 0x3;\n\n\trec->vlan_up_mask = (packed_record[22] >> 6) & 0x1;\n\n\trec->vlan_valid_mask = (packed_record[22] >> 7) & 0x1;\n\n\trec->tci_mask = (packed_record[22] >> 8) & 0xFF;\n\n\trec->sci_mask = packed_record[23] & 0xFF;\n\n\trec->eth_type_mask = (packed_record[23] >> 8) & 0x3;\n\n\trec->snap_mask = (packed_record[23] >> 10) & 0x1F;\n\n\trec->llc_mask = (packed_record[23] >> 15) & 0x1;\n\trec->llc_mask |= (packed_record[24] & 0x3) << 1;\n\n\trec->sa_mask = (packed_record[24] >> 2) & 0x3F;\n\n\trec->da_mask = (packed_record[24] >> 8) & 0x3F;\n\n\trec->pn_mask = (packed_record[24] >> 14) & 0x3;\n\trec->pn_mask |= (packed_record[25] & 0x3) << 2;\n\n\trec->eight02dot2 = (packed_record[25] >> 2) & 0x1;\n\n\trec->tci_sc = (packed_record[25] >> 3) & 0x1;\n\n\trec->tci_87543 = (packed_record[25] >> 4) & 0x1;\n\n\trec->exp_sectag_en = (packed_record[25] >> 5) & 0x1;\n\n\trec->sc_idx = (packed_record[25] >> 6) & 0x1F;\n\n\trec->sc_sa = (packed_record[25] >> 11) & 0x3;\n\n\trec->debug = (packed_record[25] >> 13) & 0x1;\n\n\trec->action = (packed_record[25] >> 14) & 0x3;\n\n\trec->valid = (packed_record[26] >> 3) & 0x1;\n\n\treturn 0;\n}\n\nint aq_mss_get_egress_class_record(struct aq_hw_s *hw,\n\t\t\t\t   struct aq_mss_egress_class_record *rec,\n\t\t\t\t   u16 table_index)\n{\n\tmemset(rec, 0, sizeof(*rec));\n\n\treturn AQ_API_CALL_SAFE(get_egress_class_record, hw, rec, table_index);\n}\n\nstatic int set_egress_sc_record(struct aq_hw_s *hw,\n\t\t\t\tconst struct aq_mss_egress_sc_record *rec,\n\t\t\t\tu16 table_index)\n{\n\tu16 packed_record[8];\n\n\tif (table_index >= NUMROWS_EGRESSSCRECORD)\n\t\treturn -EINVAL;\n\n\tmemset(packed_record, 0, sizeof(u16) * 8);\n\n\tpacked_record[0] = rec->start_time & 0xFFFF;\n\tpacked_record[1] = (rec->start_time >> 16) & 0xFFFF;\n\n\tpacked_record[2] = rec->stop_time & 0xFFFF;\n\tpacked_record[3] = (rec->stop_time >> 16) & 0xFFFF;\n\n\tpacked_record[4] = rec->curr_an & 0x3;\n\n\tpacked_record[4] |= (rec->an_roll & 0x1) << 2;\n\n\tpacked_record[4] |= (rec->tci & 0x3F) << 3;\n\n\tpacked_record[4] |= (rec->enc_off & 0x7F) << 9;\n\tpacked_record[5] = (rec->enc_off >> 7) & 0x1;\n\n\tpacked_record[5] |= (rec->protect & 0x1) << 1;\n\n\tpacked_record[5] |= (rec->recv & 0x1) << 2;\n\n\tpacked_record[5] |= (rec->fresh & 0x1) << 3;\n\n\tpacked_record[5] |= (rec->sak_len & 0x3) << 4;\n\n\tpacked_record[7] = (rec->valid & 0x1) << 15;\n\n\treturn set_raw_egress_record(hw, packed_record, 8, 2,\n\t\t\t\t     ROWOFFSET_EGRESSSCRECORD + table_index);\n}\n\nint aq_mss_set_egress_sc_record(struct aq_hw_s *hw,\n\t\t\t\tconst struct aq_mss_egress_sc_record *rec,\n\t\t\t\tu16 table_index)\n{\n\treturn AQ_API_CALL_SAFE(set_egress_sc_record, hw, rec, table_index);\n}\n\nstatic int get_egress_sc_record(struct aq_hw_s *hw,\n\t\t\t\tstruct aq_mss_egress_sc_record *rec,\n\t\t\t\tu16 table_index)\n{\n\tu16 packed_record[8];\n\tint ret;\n\n\tif (table_index >= NUMROWS_EGRESSSCRECORD)\n\t\treturn -EINVAL;\n\n\tret = get_raw_egress_record(hw, packed_record, 8, 2,\n\t\t\t\t    ROWOFFSET_EGRESSSCRECORD + table_index);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\trec->start_time = packed_record[0];\n\trec->start_time |= packed_record[1] << 16;\n\n\trec->stop_time = packed_record[2];\n\trec->stop_time |= packed_record[3] << 16;\n\n\trec->curr_an = packed_record[4] & 0x3;\n\n\trec->an_roll = (packed_record[4] >> 2) & 0x1;\n\n\trec->tci = (packed_record[4] >> 3) & 0x3F;\n\n\trec->enc_off = (packed_record[4] >> 9) & 0x7F;\n\trec->enc_off |= (packed_record[5] & 0x1) << 7;\n\n\trec->protect = (packed_record[5] >> 1) & 0x1;\n\n\trec->recv = (packed_record[5] >> 2) & 0x1;\n\n\trec->fresh = (packed_record[5] >> 3) & 0x1;\n\n\trec->sak_len = (packed_record[5] >> 4) & 0x3;\n\n\trec->valid = (packed_record[7] >> 15) & 0x1;\n\n\treturn 0;\n}\n\nint aq_mss_get_egress_sc_record(struct aq_hw_s *hw,\n\t\t\t\tstruct aq_mss_egress_sc_record *rec,\n\t\t\t\tu16 table_index)\n{\n\tmemset(rec, 0, sizeof(*rec));\n\n\treturn AQ_API_CALL_SAFE(get_egress_sc_record, hw, rec, table_index);\n}\n\nstatic int set_egress_sa_record(struct aq_hw_s *hw,\n\t\t\t\tconst struct aq_mss_egress_sa_record *rec,\n\t\t\t\tu16 table_index)\n{\n\tu16 packed_record[8];\n\n\tif (table_index >= NUMROWS_EGRESSSARECORD)\n\t\treturn -EINVAL;\n\n\tmemset(packed_record, 0, sizeof(u16) * 8);\n\n\tpacked_record[0] = rec->start_time & 0xFFFF;\n\tpacked_record[1] = (rec->start_time >> 16) & 0xFFFF;\n\n\tpacked_record[2] = rec->stop_time & 0xFFFF;\n\tpacked_record[3] = (rec->stop_time >> 16) & 0xFFFF;\n\n\tpacked_record[4] = rec->next_pn & 0xFFFF;\n\tpacked_record[5] = (rec->next_pn >> 16) & 0xFFFF;\n\n\tpacked_record[6] = rec->sat_pn & 0x1;\n\n\tpacked_record[6] |= (rec->fresh & 0x1) << 1;\n\n\tpacked_record[7] = (rec->valid & 0x1) << 15;\n\n\treturn set_raw_egress_record(hw, packed_record, 8, 2,\n\t\t\t\t     ROWOFFSET_EGRESSSARECORD + table_index);\n}\n\nint aq_mss_set_egress_sa_record(struct aq_hw_s *hw,\n\t\t\t\tconst struct aq_mss_egress_sa_record *rec,\n\t\t\t\tu16 table_index)\n{\n\tint err = AQ_API_CALL_SAFE(set_egress_sa_record, hw, rec, table_index);\n\n\tWARN_ONCE(err, \"%s failed with %d\\n\", __func__, err);\n\n\treturn err;\n}\n\nstatic int get_egress_sa_record(struct aq_hw_s *hw,\n\t\t\t\tstruct aq_mss_egress_sa_record *rec,\n\t\t\t\tu16 table_index)\n{\n\tu16 packed_record[8];\n\tint ret;\n\n\tif (table_index >= NUMROWS_EGRESSSARECORD)\n\t\treturn -EINVAL;\n\n\tret = get_raw_egress_record(hw, packed_record, 8, 2,\n\t\t\t\t    ROWOFFSET_EGRESSSARECORD + table_index);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\trec->start_time = packed_record[0];\n\trec->start_time |= packed_record[1] << 16;\n\n\trec->stop_time = packed_record[2];\n\trec->stop_time |= packed_record[3] << 16;\n\n\trec->next_pn = packed_record[4];\n\trec->next_pn |= packed_record[5] << 16;\n\n\trec->sat_pn = packed_record[6] & 0x1;\n\n\trec->fresh = (packed_record[6] >> 1) & 0x1;\n\n\trec->valid = (packed_record[7] >> 15) & 0x1;\n\n\treturn 0;\n}\n\nint aq_mss_get_egress_sa_record(struct aq_hw_s *hw,\n\t\t\t\tstruct aq_mss_egress_sa_record *rec,\n\t\t\t\tu16 table_index)\n{\n\tmemset(rec, 0, sizeof(*rec));\n\n\treturn AQ_API_CALL_SAFE(get_egress_sa_record, hw, rec, table_index);\n}\n\nstatic int set_egress_sakey_record(struct aq_hw_s *hw,\n\t\t\t\t   const struct aq_mss_egress_sakey_record *rec,\n\t\t\t\t   u16 table_index)\n{\n\tu16 packed_record[16];\n\tint ret;\n\n\tif (table_index >= NUMROWS_EGRESSSAKEYRECORD)\n\t\treturn -EINVAL;\n\n\tmemset(packed_record, 0, sizeof(u16) * 16);\n\n\tpacked_record[0] = rec->key[0] & 0xFFFF;\n\tpacked_record[1] = (rec->key[0] >> 16) & 0xFFFF;\n\n\tpacked_record[2] = rec->key[1] & 0xFFFF;\n\tpacked_record[3] = (rec->key[1] >> 16) & 0xFFFF;\n\n\tpacked_record[4] = rec->key[2] & 0xFFFF;\n\tpacked_record[5] = (rec->key[2] >> 16) & 0xFFFF;\n\n\tpacked_record[6] = rec->key[3] & 0xFFFF;\n\tpacked_record[7] = (rec->key[3] >> 16) & 0xFFFF;\n\n\tpacked_record[8] = rec->key[4] & 0xFFFF;\n\tpacked_record[9] = (rec->key[4] >> 16) & 0xFFFF;\n\n\tpacked_record[10] = rec->key[5] & 0xFFFF;\n\tpacked_record[11] = (rec->key[5] >> 16) & 0xFFFF;\n\n\tpacked_record[12] = rec->key[6] & 0xFFFF;\n\tpacked_record[13] = (rec->key[6] >> 16) & 0xFFFF;\n\n\tpacked_record[14] = rec->key[7] & 0xFFFF;\n\tpacked_record[15] = (rec->key[7] >> 16) & 0xFFFF;\n\n\tret = set_raw_egress_record(hw, packed_record, 8, 2,\n\t\t\t\t    ROWOFFSET_EGRESSSAKEYRECORD + table_index);\n\tif (unlikely(ret))\n\t\tgoto clear_key;\n\tret = set_raw_egress_record(hw, packed_record + 8, 8, 2,\n\t\t\t\t    ROWOFFSET_EGRESSSAKEYRECORD + table_index -\n\t\t\t\t\t    32);\n\nclear_key:\n\tmemzero_explicit(packed_record, sizeof(packed_record));\n\treturn ret;\n}\n\nint aq_mss_set_egress_sakey_record(struct aq_hw_s *hw,\n\t\t\t\t   const struct aq_mss_egress_sakey_record *rec,\n\t\t\t\t   u16 table_index)\n{\n\tint err = AQ_API_CALL_SAFE(set_egress_sakey_record, hw, rec,\n\t\t\t\t   table_index);\n\n\tWARN_ONCE(err, \"%s failed with %d\\n\", __func__, err);\n\n\treturn err;\n}\n\nstatic int get_egress_sakey_record(struct aq_hw_s *hw,\n\t\t\t\t   struct aq_mss_egress_sakey_record *rec,\n\t\t\t\t   u16 table_index)\n{\n\tu16 packed_record[16];\n\tint ret;\n\n\tif (table_index >= NUMROWS_EGRESSSAKEYRECORD)\n\t\treturn -EINVAL;\n\n\tret = get_raw_egress_record(hw, packed_record, 8, 2,\n\t\t\t\t    ROWOFFSET_EGRESSSAKEYRECORD + table_index);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tret = get_raw_egress_record(hw, packed_record + 8, 8, 2,\n\t\t\t\t    ROWOFFSET_EGRESSSAKEYRECORD + table_index -\n\t\t\t\t\t    32);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\trec->key[0] = packed_record[0];\n\trec->key[0] |= packed_record[1] << 16;\n\n\trec->key[1] = packed_record[2];\n\trec->key[1] |= packed_record[3] << 16;\n\n\trec->key[2] = packed_record[4];\n\trec->key[2] |= packed_record[5] << 16;\n\n\trec->key[3] = packed_record[6];\n\trec->key[3] |= packed_record[7] << 16;\n\n\trec->key[4] = packed_record[8];\n\trec->key[4] |= packed_record[9] << 16;\n\n\trec->key[5] = packed_record[10];\n\trec->key[5] |= packed_record[11] << 16;\n\n\trec->key[6] = packed_record[12];\n\trec->key[6] |= packed_record[13] << 16;\n\n\trec->key[7] = packed_record[14];\n\trec->key[7] |= packed_record[15] << 16;\n\n\treturn 0;\n}\n\nint aq_mss_get_egress_sakey_record(struct aq_hw_s *hw,\n\t\t\t\t   struct aq_mss_egress_sakey_record *rec,\n\t\t\t\t   u16 table_index)\n{\n\tmemset(rec, 0, sizeof(*rec));\n\n\treturn AQ_API_CALL_SAFE(get_egress_sakey_record, hw, rec, table_index);\n}\n\nstatic int get_egress_sc_counters(struct aq_hw_s *hw,\n\t\t\t\t  struct aq_mss_egress_sc_counters *counters,\n\t\t\t\t  u16 sc_index)\n{\n\tu16 packed_record[4];\n\tint ret;\n\n\tif (sc_index >= NUMROWS_EGRESSSCRECORD)\n\t\treturn -EINVAL;\n\n\tret = get_raw_egress_record(hw, packed_record, 4, 3, sc_index * 8 + 4);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->sc_protected_pkts[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->sc_protected_pkts[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_egress_record(hw, packed_record, 4, 3, sc_index * 8 + 5);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->sc_encrypted_pkts[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->sc_encrypted_pkts[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_egress_record(hw, packed_record, 4, 3, sc_index * 8 + 6);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->sc_protected_octets[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->sc_protected_octets[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_egress_record(hw, packed_record, 4, 3, sc_index * 8 + 7);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->sc_encrypted_octets[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->sc_encrypted_octets[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\treturn 0;\n}\n\nint aq_mss_get_egress_sc_counters(struct aq_hw_s *hw,\n\t\t\t\t  struct aq_mss_egress_sc_counters *counters,\n\t\t\t\t  u16 sc_index)\n{\n\tmemset(counters, 0, sizeof(*counters));\n\n\treturn AQ_API_CALL_SAFE(get_egress_sc_counters, hw, counters, sc_index);\n}\n\nstatic int get_egress_sa_counters(struct aq_hw_s *hw,\n\t\t\t\t  struct aq_mss_egress_sa_counters *counters,\n\t\t\t\t  u16 sa_index)\n{\n\tu16 packed_record[4];\n\tint ret;\n\n\tif (sa_index >= NUMROWS_EGRESSSARECORD)\n\t\treturn -EINVAL;\n\n\tret = get_raw_egress_record(hw, packed_record, 4, 3, sa_index * 8 + 0);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->sa_hit_drop_redirect[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->sa_hit_drop_redirect[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_egress_record(hw, packed_record, 4, 3, sa_index * 8 + 1);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->sa_protected2_pkts[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->sa_protected2_pkts[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_egress_record(hw, packed_record, 4, 3, sa_index * 8 + 2);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->sa_protected_pkts[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->sa_protected_pkts[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_egress_record(hw, packed_record, 4, 3, sa_index * 8 + 3);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->sa_encrypted_pkts[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->sa_encrypted_pkts[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\treturn 0;\n}\n\nint aq_mss_get_egress_sa_counters(struct aq_hw_s *hw,\n\t\t\t\t  struct aq_mss_egress_sa_counters *counters,\n\t\t\t\t  u16 sa_index)\n{\n\tmemset(counters, 0, sizeof(*counters));\n\n\treturn AQ_API_CALL_SAFE(get_egress_sa_counters, hw, counters, sa_index);\n}\n\nstatic int\nget_egress_common_counters(struct aq_hw_s *hw,\n\t\t\t   struct aq_mss_egress_common_counters *counters)\n{\n\tu16 packed_record[4];\n\tint ret;\n\n\tret = get_raw_egress_record(hw, packed_record, 4, 3, 256 + 0);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->ctl_pkt[0] = packed_record[0] | (packed_record[1] << 16);\n\tcounters->ctl_pkt[1] = packed_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_egress_record(hw, packed_record, 4, 3, 256 + 1);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->unknown_sa_pkts[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->unknown_sa_pkts[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_egress_record(hw, packed_record, 4, 3, 256 + 2);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->untagged_pkts[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->untagged_pkts[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_egress_record(hw, packed_record, 4, 3, 256 + 3);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->too_long[0] = packed_record[0] | (packed_record[1] << 16);\n\tcounters->too_long[1] = packed_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_egress_record(hw, packed_record, 4, 3, 256 + 4);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->ecc_error_pkts[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->ecc_error_pkts[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_egress_record(hw, packed_record, 4, 3, 256 + 5);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->unctrl_hit_drop_redir[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->unctrl_hit_drop_redir[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\treturn 0;\n}\n\nint aq_mss_get_egress_common_counters(struct aq_hw_s *hw,\n\tstruct aq_mss_egress_common_counters *counters)\n{\n\tmemset(counters, 0, sizeof(*counters));\n\n\treturn AQ_API_CALL_SAFE(get_egress_common_counters, hw, counters);\n}\n\nstatic int clear_egress_counters(struct aq_hw_s *hw)\n{\n\tstruct mss_egress_ctl_register ctl_reg;\n\tint ret;\n\n\tmemset(&ctl_reg, 0, sizeof(ctl_reg));\n\n\tret = aq_mss_mdio_read(hw, MDIO_MMD_VEND1, MSS_EGRESS_CTL_REGISTER_ADDR,\n\t\t\t       &ctl_reg.word_0);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tret = aq_mss_mdio_read(hw, MDIO_MMD_VEND1,\n\t\t\t       MSS_EGRESS_CTL_REGISTER_ADDR + 4,\n\t\t\t       &ctl_reg.word_1);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\t \n\tctl_reg.bits_0.clear_counter = 0;\n\tret = aq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t\tMSS_EGRESS_CTL_REGISTER_ADDR, ctl_reg.word_0);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tret = aq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t\tMSS_EGRESS_CTL_REGISTER_ADDR + 4,\n\t\t\t\tctl_reg.word_1);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tctl_reg.bits_0.clear_counter = 1;\n\tret = aq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t\tMSS_EGRESS_CTL_REGISTER_ADDR, ctl_reg.word_0);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tret = aq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t\tMSS_EGRESS_CTL_REGISTER_ADDR + 4,\n\t\t\t\tctl_reg.word_1);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tctl_reg.bits_0.clear_counter = 0;\n\tret = aq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t\tMSS_EGRESS_CTL_REGISTER_ADDR, ctl_reg.word_0);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tret = aq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t\tMSS_EGRESS_CTL_REGISTER_ADDR + 4,\n\t\t\t\tctl_reg.word_1);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint aq_mss_clear_egress_counters(struct aq_hw_s *hw)\n{\n\treturn AQ_API_CALL_SAFE(clear_egress_counters, hw);\n}\n\nstatic int get_ingress_sa_counters(struct aq_hw_s *hw,\n\t\t\t\t   struct aq_mss_ingress_sa_counters *counters,\n\t\t\t\t   u16 sa_index)\n{\n\tu16 packed_record[4];\n\tint ret;\n\n\tif (sa_index >= NUMROWS_INGRESSSARECORD)\n\t\treturn -EINVAL;\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6,\n\t\t\t\t     sa_index * 12 + 0);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->untagged_hit_pkts[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->untagged_hit_pkts[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6,\n\t\t\t\t     sa_index * 12 + 1);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->ctrl_hit_drop_redir_pkts[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->ctrl_hit_drop_redir_pkts[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6,\n\t\t\t\t     sa_index * 12 + 2);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->not_using_sa[0] = packed_record[0] | (packed_record[1] << 16);\n\tcounters->not_using_sa[1] = packed_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6,\n\t\t\t\t     sa_index * 12 + 3);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->unused_sa[0] = packed_record[0] | (packed_record[1] << 16);\n\tcounters->unused_sa[1] = packed_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6,\n\t\t\t\t     sa_index * 12 + 4);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->not_valid_pkts[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->not_valid_pkts[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6,\n\t\t\t\t     sa_index * 12 + 5);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->invalid_pkts[0] = packed_record[0] | (packed_record[1] << 16);\n\tcounters->invalid_pkts[1] = packed_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6,\n\t\t\t\t     sa_index * 12 + 6);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->ok_pkts[0] = packed_record[0] | (packed_record[1] << 16);\n\tcounters->ok_pkts[1] = packed_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6,\n\t\t\t\t     sa_index * 12 + 7);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->late_pkts[0] = packed_record[0] | (packed_record[1] << 16);\n\tcounters->late_pkts[1] = packed_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6,\n\t\t\t\t     sa_index * 12 + 8);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->delayed_pkts[0] = packed_record[0] | (packed_record[1] << 16);\n\tcounters->delayed_pkts[1] = packed_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6,\n\t\t\t\t     sa_index * 12 + 9);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->unchecked_pkts[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->unchecked_pkts[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6,\n\t\t\t\t     sa_index * 12 + 10);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->validated_octets[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->validated_octets[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6,\n\t\t\t\t     sa_index * 12 + 11);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->decrypted_octets[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->decrypted_octets[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\treturn 0;\n}\n\nint aq_mss_get_ingress_sa_counters(struct aq_hw_s *hw,\n\t\t\t\t   struct aq_mss_ingress_sa_counters *counters,\n\t\t\t\t   u16 sa_index)\n{\n\tmemset(counters, 0, sizeof(*counters));\n\n\treturn AQ_API_CALL_SAFE(get_ingress_sa_counters, hw, counters,\n\t\t\t\tsa_index);\n}\n\nstatic int\nget_ingress_common_counters(struct aq_hw_s *hw,\n\t\t\t    struct aq_mss_ingress_common_counters *counters)\n{\n\tu16 packed_record[4];\n\tint ret;\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6, 385 + 0);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->ctl_pkts[0] = packed_record[0] | (packed_record[1] << 16);\n\tcounters->ctl_pkts[1] = packed_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6, 385 + 1);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->tagged_miss_pkts[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->tagged_miss_pkts[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6, 385 + 2);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->untagged_miss_pkts[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->untagged_miss_pkts[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6, 385 + 3);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->notag_pkts[0] = packed_record[0] | (packed_record[1] << 16);\n\tcounters->notag_pkts[1] = packed_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6, 385 + 4);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->untagged_pkts[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->untagged_pkts[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6, 385 + 5);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->bad_tag_pkts[0] = packed_record[0] | (packed_record[1] << 16);\n\tcounters->bad_tag_pkts[1] = packed_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6, 385 + 6);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->no_sci_pkts[0] = packed_record[0] | (packed_record[1] << 16);\n\tcounters->no_sci_pkts[1] = packed_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6, 385 + 7);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->unknown_sci_pkts[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->unknown_sci_pkts[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6, 385 + 8);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->ctrl_prt_pass_pkts[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->ctrl_prt_pass_pkts[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6, 385 + 9);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->unctrl_prt_pass_pkts[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->unctrl_prt_pass_pkts[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6, 385 + 10);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->ctrl_prt_fail_pkts[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->ctrl_prt_fail_pkts[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6, 385 + 11);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->unctrl_prt_fail_pkts[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->unctrl_prt_fail_pkts[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6, 385 + 12);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->too_long_pkts[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->too_long_pkts[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6, 385 + 13);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->igpoc_ctl_pkts[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->igpoc_ctl_pkts[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6, 385 + 14);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->ecc_error_pkts[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->ecc_error_pkts[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\tret = get_raw_ingress_record(hw, packed_record, 4, 6, 385 + 15);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tcounters->unctrl_hit_drop_redir[0] =\n\t\tpacked_record[0] | (packed_record[1] << 16);\n\tcounters->unctrl_hit_drop_redir[1] =\n\t\tpacked_record[2] | (packed_record[3] << 16);\n\n\treturn 0;\n}\n\nint aq_mss_get_ingress_common_counters(struct aq_hw_s *hw,\n\tstruct aq_mss_ingress_common_counters *counters)\n{\n\tmemset(counters, 0, sizeof(*counters));\n\n\treturn AQ_API_CALL_SAFE(get_ingress_common_counters, hw, counters);\n}\n\nstatic int clear_ingress_counters(struct aq_hw_s *hw)\n{\n\tstruct mss_ingress_ctl_register ctl_reg;\n\tint ret;\n\n\tmemset(&ctl_reg, 0, sizeof(ctl_reg));\n\n\tret = aq_mss_mdio_read(hw, MDIO_MMD_VEND1,\n\t\t\t       MSS_INGRESS_CTL_REGISTER_ADDR, &ctl_reg.word_0);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tret = aq_mss_mdio_read(hw, MDIO_MMD_VEND1,\n\t\t\t       MSS_INGRESS_CTL_REGISTER_ADDR + 4,\n\t\t\t       &ctl_reg.word_1);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\t \n\tctl_reg.bits_0.clear_count = 0;\n\tret = aq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t\tMSS_INGRESS_CTL_REGISTER_ADDR, ctl_reg.word_0);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tret = aq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t\tMSS_INGRESS_CTL_REGISTER_ADDR + 4,\n\t\t\t\tctl_reg.word_1);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tctl_reg.bits_0.clear_count = 1;\n\tret = aq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t\tMSS_INGRESS_CTL_REGISTER_ADDR, ctl_reg.word_0);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tret = aq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t\tMSS_INGRESS_CTL_REGISTER_ADDR + 4,\n\t\t\t\tctl_reg.word_1);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tctl_reg.bits_0.clear_count = 0;\n\tret = aq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t\tMSS_INGRESS_CTL_REGISTER_ADDR, ctl_reg.word_0);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tret = aq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t\tMSS_INGRESS_CTL_REGISTER_ADDR + 4,\n\t\t\t\tctl_reg.word_1);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint aq_mss_clear_ingress_counters(struct aq_hw_s *hw)\n{\n\treturn AQ_API_CALL_SAFE(clear_ingress_counters, hw);\n}\n\nstatic int get_egress_sa_expired(struct aq_hw_s *hw, u32 *expired)\n{\n\tu16 val;\n\tint ret;\n\n\tret = aq_mss_mdio_read(hw, MDIO_MMD_VEND1,\n\t\t\t       MSS_EGRESS_SA_EXPIRED_STATUS_REGISTER_ADDR,\n\t\t\t       &val);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\t*expired = val;\n\n\tret = aq_mss_mdio_read(hw, MDIO_MMD_VEND1,\n\t\t\t       MSS_EGRESS_SA_EXPIRED_STATUS_REGISTER_ADDR + 1,\n\t\t\t       &val);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\t*expired |= val << 16;\n\n\treturn 0;\n}\n\nint aq_mss_get_egress_sa_expired(struct aq_hw_s *hw, u32 *expired)\n{\n\t*expired = 0;\n\n\treturn AQ_API_CALL_SAFE(get_egress_sa_expired, hw, expired);\n}\n\nstatic int get_egress_sa_threshold_expired(struct aq_hw_s *hw,\n\t\t\t\t\t   u32 *expired)\n{\n\tu16 val;\n\tint ret;\n\n\tret = aq_mss_mdio_read(hw, MDIO_MMD_VEND1,\n\t\tMSS_EGRESS_SA_THRESHOLD_EXPIRED_STATUS_REGISTER_ADDR, &val);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\t*expired = val;\n\n\tret = aq_mss_mdio_read(hw, MDIO_MMD_VEND1,\n\t\tMSS_EGRESS_SA_THRESHOLD_EXPIRED_STATUS_REGISTER_ADDR + 1, &val);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\t*expired |= val << 16;\n\n\treturn 0;\n}\n\nint aq_mss_get_egress_sa_threshold_expired(struct aq_hw_s *hw,\n\t\t\t\t\t   u32 *expired)\n{\n\t*expired = 0;\n\n\treturn AQ_API_CALL_SAFE(get_egress_sa_threshold_expired, hw, expired);\n}\n\nstatic int set_egress_sa_expired(struct aq_hw_s *hw, u32 expired)\n{\n\tint ret;\n\n\tret = aq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t\tMSS_EGRESS_SA_EXPIRED_STATUS_REGISTER_ADDR,\n\t\t\t\texpired & 0xFFFF);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tret = aq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\t\t\tMSS_EGRESS_SA_EXPIRED_STATUS_REGISTER_ADDR + 1,\n\t\t\t\texpired >> 16);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint aq_mss_set_egress_sa_expired(struct aq_hw_s *hw, u32 expired)\n{\n\treturn AQ_API_CALL_SAFE(set_egress_sa_expired, hw, expired);\n}\n\nstatic int set_egress_sa_threshold_expired(struct aq_hw_s *hw, u32 expired)\n{\n\tint ret;\n\n\tret = aq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\tMSS_EGRESS_SA_THRESHOLD_EXPIRED_STATUS_REGISTER_ADDR,\n\t\texpired & 0xFFFF);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tret = aq_mss_mdio_write(hw, MDIO_MMD_VEND1,\n\t\tMSS_EGRESS_SA_THRESHOLD_EXPIRED_STATUS_REGISTER_ADDR + 1,\n\t\texpired >> 16);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint aq_mss_set_egress_sa_threshold_expired(struct aq_hw_s *hw, u32 expired)\n{\n\treturn AQ_API_CALL_SAFE(set_egress_sa_threshold_expired, hw, expired);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}