{
  "module_name": "aq_pci_func.c",
  "hash_id": "1620220ceb2cb6899efa6f041248da1b7efd616cde5a4e22411ed71deb5fc121",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/aquantia/atlantic/aq_pci_func.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/interrupt.h>\n#include <linux/module.h>\n\n#include \"aq_main.h\"\n#include \"aq_nic.h\"\n#include \"aq_vec.h\"\n#include \"aq_hw.h\"\n#include \"aq_pci_func.h\"\n#include \"hw_atl/hw_atl_a0.h\"\n#include \"hw_atl/hw_atl_b0.h\"\n#include \"hw_atl2/hw_atl2.h\"\n#include \"aq_filters.h\"\n#include \"aq_drvinfo.h\"\n#include \"aq_macsec.h\"\n\nstatic const struct pci_device_id aq_pci_tbl[] = {\n\t{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_0001), },\n\t{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_D100), },\n\t{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_D107), },\n\t{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_D108), },\n\t{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_D109), },\n\n\t{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC100), },\n\t{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC107), },\n\t{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC108), },\n\t{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC109), },\n\t{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC111), },\n\t{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC112), },\n\n\t{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC100S), },\n\t{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC107S), },\n\t{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC108S), },\n\t{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC109S), },\n\t{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC111S), },\n\t{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC112S), },\n\n\t{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC113DEV), },\n\t{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC113CS), },\n\t{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC114CS), },\n\t{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC113), },\n\t{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC113C), },\n\t{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC115C), },\n\t{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC113CA), },\n\t{ PCI_VDEVICE(AQUANTIA, AQ_DEVICE_ID_AQC116C), },\n\n\t{}\n};\n\nstatic const struct aq_board_revision_s hw_atl_boards[] = {\n\t{ AQ_DEVICE_ID_0001,\tAQ_HWREV_1,\t&hw_atl_ops_a0, &hw_atl_a0_caps_aqc107, },\n\t{ AQ_DEVICE_ID_D100,\tAQ_HWREV_1,\t&hw_atl_ops_a0, &hw_atl_a0_caps_aqc100, },\n\t{ AQ_DEVICE_ID_D107,\tAQ_HWREV_1,\t&hw_atl_ops_a0, &hw_atl_a0_caps_aqc107, },\n\t{ AQ_DEVICE_ID_D108,\tAQ_HWREV_1,\t&hw_atl_ops_a0, &hw_atl_a0_caps_aqc108, },\n\t{ AQ_DEVICE_ID_D109,\tAQ_HWREV_1,\t&hw_atl_ops_a0, &hw_atl_a0_caps_aqc109, },\n\n\t{ AQ_DEVICE_ID_0001,\tAQ_HWREV_2,\t&hw_atl_ops_b0, &hw_atl_b0_caps_aqc107, },\n\t{ AQ_DEVICE_ID_D100,\tAQ_HWREV_2,\t&hw_atl_ops_b0, &hw_atl_b0_caps_aqc100, },\n\t{ AQ_DEVICE_ID_D107,\tAQ_HWREV_2,\t&hw_atl_ops_b0, &hw_atl_b0_caps_aqc107, },\n\t{ AQ_DEVICE_ID_D108,\tAQ_HWREV_2,\t&hw_atl_ops_b0, &hw_atl_b0_caps_aqc108, },\n\t{ AQ_DEVICE_ID_D109,\tAQ_HWREV_2,\t&hw_atl_ops_b0, &hw_atl_b0_caps_aqc109, },\n\n\t{ AQ_DEVICE_ID_AQC100,\tAQ_HWREV_ANY,\t&hw_atl_ops_b1, &hw_atl_b0_caps_aqc100, },\n\t{ AQ_DEVICE_ID_AQC107,\tAQ_HWREV_ANY,\t&hw_atl_ops_b1, &hw_atl_b0_caps_aqc107, },\n\t{ AQ_DEVICE_ID_AQC108,\tAQ_HWREV_ANY,\t&hw_atl_ops_b1, &hw_atl_b0_caps_aqc108, },\n\t{ AQ_DEVICE_ID_AQC109,\tAQ_HWREV_ANY,\t&hw_atl_ops_b1, &hw_atl_b0_caps_aqc109, },\n\t{ AQ_DEVICE_ID_AQC111,\tAQ_HWREV_ANY,\t&hw_atl_ops_b1, &hw_atl_b0_caps_aqc111, },\n\t{ AQ_DEVICE_ID_AQC112,\tAQ_HWREV_ANY,\t&hw_atl_ops_b1, &hw_atl_b0_caps_aqc112, },\n\n\t{ AQ_DEVICE_ID_AQC100S,\tAQ_HWREV_ANY,\t&hw_atl_ops_b1, &hw_atl_b0_caps_aqc100s, },\n\t{ AQ_DEVICE_ID_AQC107S,\tAQ_HWREV_ANY,\t&hw_atl_ops_b1, &hw_atl_b0_caps_aqc107s, },\n\t{ AQ_DEVICE_ID_AQC108S,\tAQ_HWREV_ANY,\t&hw_atl_ops_b1, &hw_atl_b0_caps_aqc108s, },\n\t{ AQ_DEVICE_ID_AQC109S,\tAQ_HWREV_ANY,\t&hw_atl_ops_b1, &hw_atl_b0_caps_aqc109s, },\n\t{ AQ_DEVICE_ID_AQC111S,\tAQ_HWREV_ANY,\t&hw_atl_ops_b1, &hw_atl_b0_caps_aqc111s, },\n\t{ AQ_DEVICE_ID_AQC112S,\tAQ_HWREV_ANY,\t&hw_atl_ops_b1, &hw_atl_b0_caps_aqc112s, },\n\n\t{ AQ_DEVICE_ID_AQC113DEV,\tAQ_HWREV_ANY,\t&hw_atl2_ops, &hw_atl2_caps_aqc113, },\n\t{ AQ_DEVICE_ID_AQC113,\t\tAQ_HWREV_ANY,\t&hw_atl2_ops, &hw_atl2_caps_aqc113, },\n\t{ AQ_DEVICE_ID_AQC113CS,\tAQ_HWREV_ANY,\t&hw_atl2_ops, &hw_atl2_caps_aqc113, },\n\t{ AQ_DEVICE_ID_AQC114CS,\tAQ_HWREV_ANY,\t&hw_atl2_ops, &hw_atl2_caps_aqc113, },\n\t{ AQ_DEVICE_ID_AQC113C,\t\tAQ_HWREV_ANY,\t&hw_atl2_ops, &hw_atl2_caps_aqc113, },\n\t{ AQ_DEVICE_ID_AQC115C,\t\tAQ_HWREV_ANY,\t&hw_atl2_ops, &hw_atl2_caps_aqc115c, },\n\t{ AQ_DEVICE_ID_AQC113CA,\tAQ_HWREV_ANY,\t&hw_atl2_ops, &hw_atl2_caps_aqc113, },\n\t{ AQ_DEVICE_ID_AQC116C,\t\tAQ_HWREV_ANY,\t&hw_atl2_ops, &hw_atl2_caps_aqc116c, },\n\n};\n\nMODULE_DEVICE_TABLE(pci, aq_pci_tbl);\n\nstatic int aq_pci_probe_get_hw_by_id(struct pci_dev *pdev,\n\t\t\t\t     const struct aq_hw_ops **ops,\n\t\t\t\t     const struct aq_hw_caps_s **caps)\n{\n\tint i;\n\n\tif (pdev->vendor != PCI_VENDOR_ID_AQUANTIA)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(hw_atl_boards); i++) {\n\t\tif (hw_atl_boards[i].devid == pdev->device &&\n\t\t    (hw_atl_boards[i].revision == AQ_HWREV_ANY ||\n\t\t     hw_atl_boards[i].revision == pdev->revision)) {\n\t\t\t*ops = hw_atl_boards[i].ops;\n\t\t\t*caps = hw_atl_boards[i].caps;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == ARRAY_SIZE(hw_atl_boards))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int aq_pci_func_init(struct pci_dev *pdev)\n{\n\tint err;\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err)\n\t\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (err) {\n\t\terr = -ENOSR;\n\t\tgoto err_exit;\n\t}\n\n\terr = pci_request_regions(pdev, AQ_CFG_DRV_NAME \"_mmio\");\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\tpci_set_master(pdev);\n\n\treturn 0;\n\nerr_exit:\n\treturn err;\n}\n\nint aq_pci_func_alloc_irq(struct aq_nic_s *self, unsigned int i,\n\t\t\t  char *name, irq_handler_t irq_handler,\n\t\t\t  void *irq_arg, cpumask_t *affinity_mask)\n{\n\tstruct pci_dev *pdev = self->pdev;\n\tint err;\n\n\tif (pdev->msix_enabled || pdev->msi_enabled)\n\t\terr = request_irq(pci_irq_vector(pdev, i), irq_handler, 0,\n\t\t\t\t  name, irq_arg);\n\telse\n\t\terr = request_irq(pci_irq_vector(pdev, i), aq_vec_isr_legacy,\n\t\t\t\t  IRQF_SHARED, name, irq_arg);\n\n\tif (err >= 0) {\n\t\tself->msix_entry_mask |= (1 << i);\n\n\t\tif (pdev->msix_enabled && affinity_mask)\n\t\t\tirq_set_affinity_hint(pci_irq_vector(pdev, i),\n\t\t\t\t\t      affinity_mask);\n\t}\n\n\treturn err;\n}\n\nvoid aq_pci_func_free_irqs(struct aq_nic_s *self)\n{\n\tstruct pci_dev *pdev = self->pdev;\n\tunsigned int i;\n\tvoid *irq_data;\n\n\tfor (i = 32U; i--;) {\n\t\tif (!((1U << i) & self->msix_entry_mask))\n\t\t\tcontinue;\n\t\tif (self->aq_nic_cfg.link_irq_vec &&\n\t\t    i == self->aq_nic_cfg.link_irq_vec)\n\t\t\tirq_data = self;\n\t\telse if (i < AQ_CFG_VECS_MAX)\n\t\t\tirq_data = self->aq_vec[i];\n\t\telse\n\t\t\tcontinue;\n\n\t\tif (pdev->msix_enabled)\n\t\t\tirq_set_affinity_hint(pci_irq_vector(pdev, i), NULL);\n\t\tfree_irq(pci_irq_vector(pdev, i), irq_data);\n\t\tself->msix_entry_mask &= ~(1U << i);\n\t}\n}\n\nunsigned int aq_pci_func_get_irq_type(struct aq_nic_s *self)\n{\n\tif (self->pdev->msix_enabled)\n\t\treturn AQ_HW_IRQ_MSIX;\n\tif (self->pdev->msi_enabled)\n\t\treturn AQ_HW_IRQ_MSI;\n\n\treturn AQ_HW_IRQ_LEGACY;\n}\n\nstatic void aq_pci_free_irq_vectors(struct aq_nic_s *self)\n{\n\tpci_free_irq_vectors(self->pdev);\n}\n\nstatic int aq_pci_probe(struct pci_dev *pdev,\n\t\t\tconst struct pci_device_id *pci_id)\n{\n\tstruct net_device *ndev;\n\tresource_size_t mmio_pa;\n\tstruct aq_nic_s *self;\n\tu32 numvecs;\n\tu32 bar;\n\tint err;\n\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\treturn err;\n\n\terr = aq_pci_func_init(pdev);\n\tif (err)\n\t\tgoto err_pci_func;\n\n\tndev = aq_ndev_alloc();\n\tif (!ndev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_ndev;\n\t}\n\n\tself = netdev_priv(ndev);\n\tself->pdev = pdev;\n\tSET_NETDEV_DEV(ndev, &pdev->dev);\n\tpci_set_drvdata(pdev, self);\n\n\tmutex_init(&self->fwreq_mutex);\n\n\terr = aq_pci_probe_get_hw_by_id(pdev, &self->aq_hw_ops,\n\t\t\t\t\t&aq_nic_get_cfg(self)->aq_hw_caps);\n\tif (err)\n\t\tgoto err_ioremap;\n\n\tself->aq_hw = kzalloc(sizeof(*self->aq_hw), GFP_KERNEL);\n\tif (!self->aq_hw) {\n\t\terr = -ENOMEM;\n\t\tgoto err_ioremap;\n\t}\n\tself->aq_hw->aq_nic_cfg = aq_nic_get_cfg(self);\n\tif (self->aq_hw->aq_nic_cfg->aq_hw_caps->priv_data_len) {\n\t\tint len = self->aq_hw->aq_nic_cfg->aq_hw_caps->priv_data_len;\n\n\t\tself->aq_hw->priv = kzalloc(len, GFP_KERNEL);\n\t\tif (!self->aq_hw->priv) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_free_aq_hw;\n\t\t}\n\t}\n\n\tfor (bar = 0; bar < 4; ++bar) {\n\t\tif (IORESOURCE_MEM & pci_resource_flags(pdev, bar)) {\n\t\t\tresource_size_t reg_sz;\n\n\t\t\tmmio_pa = pci_resource_start(pdev, bar);\n\t\t\tif (mmio_pa == 0U) {\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto err_free_aq_hw_priv;\n\t\t\t}\n\n\t\t\treg_sz = pci_resource_len(pdev, bar);\n\t\t\tif ((reg_sz <= 24  )) {\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto err_free_aq_hw_priv;\n\t\t\t}\n\n\t\t\tself->aq_hw->mmio = ioremap(mmio_pa, reg_sz);\n\t\t\tif (!self->aq_hw->mmio) {\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto err_free_aq_hw_priv;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (bar == 4) {\n\t\terr = -EIO;\n\t\tgoto err_free_aq_hw_priv;\n\t}\n\n\tnumvecs = min((u8)AQ_CFG_VECS_DEF,\n\t\t      aq_nic_get_cfg(self)->aq_hw_caps->msix_irqs);\n\tnumvecs = min(numvecs, num_online_cpus());\n\t \n\tnumvecs += 1;\n\n\tnumvecs += AQ_HW_SERVICE_IRQS;\n\t \n#if !AQ_CFG_FORCE_LEGACY_INT\n\terr = pci_alloc_irq_vectors(self->pdev, 1, numvecs,\n\t\t\t\t    PCI_IRQ_MSIX | PCI_IRQ_MSI |\n\t\t\t\t    PCI_IRQ_LEGACY);\n\n\tif (err < 0)\n\t\tgoto err_hwinit;\n\tnumvecs = err;\n#endif\n\tself->irqvecs = numvecs;\n\n\t \n\taq_nic_cfg_start(self);\n\n\taq_nic_ndev_init(self);\n\n\terr = aq_nic_ndev_register(self);\n\tif (err < 0)\n\t\tgoto err_register;\n\n\taq_drvinfo_init(ndev);\n\n\treturn 0;\n\nerr_register:\n\taq_nic_free_vectors(self);\n\taq_pci_free_irq_vectors(self);\nerr_hwinit:\n\tiounmap(self->aq_hw->mmio);\nerr_free_aq_hw_priv:\n\tkfree(self->aq_hw->priv);\nerr_free_aq_hw:\n\tkfree(self->aq_hw);\nerr_ioremap:\n\tfree_netdev(ndev);\nerr_ndev:\n\tpci_release_regions(pdev);\nerr_pci_func:\n\tpci_disable_device(pdev);\n\n\treturn err;\n}\n\nstatic void aq_pci_remove(struct pci_dev *pdev)\n{\n\tstruct aq_nic_s *self = pci_get_drvdata(pdev);\n\n\tif (self->ndev) {\n\t\taq_clear_rxnfc_all_rules(self);\n\t\tif (self->ndev->reg_state == NETREG_REGISTERED)\n\t\t\tunregister_netdev(self->ndev);\n\n#if IS_ENABLED(CONFIG_MACSEC)\n\t\taq_macsec_free(self);\n#endif\n\t\taq_nic_free_vectors(self);\n\t\taq_pci_free_irq_vectors(self);\n\t\tiounmap(self->aq_hw->mmio);\n\t\tkfree(self->aq_hw->priv);\n\t\tkfree(self->aq_hw);\n\t\tpci_release_regions(pdev);\n\t\tfree_netdev(self->ndev);\n\t}\n\n\tpci_disable_device(pdev);\n}\n\nstatic void aq_pci_shutdown(struct pci_dev *pdev)\n{\n\tstruct aq_nic_s *self = pci_get_drvdata(pdev);\n\n\taq_nic_shutdown(self);\n\n\tpci_disable_device(pdev);\n\n\tif (system_state == SYSTEM_POWER_OFF) {\n\t\tpci_wake_from_d3(pdev, false);\n\t\tpci_set_power_state(pdev, PCI_D3hot);\n\t}\n}\n\n#ifdef CONFIG_PM\nstatic int aq_suspend_common(struct device *dev)\n{\n\tstruct aq_nic_s *nic = pci_get_drvdata(to_pci_dev(dev));\n\n\trtnl_lock();\n\n\tnic->power_state = AQ_HW_POWER_STATE_D3;\n\tnetif_device_detach(nic->ndev);\n\tnetif_tx_stop_all_queues(nic->ndev);\n\n\tif (netif_running(nic->ndev))\n\t\taq_nic_stop(nic);\n\n\taq_nic_deinit(nic, !nic->aq_hw->aq_nic_cfg->wol);\n\taq_nic_set_power(nic);\n\n\trtnl_unlock();\n\n\treturn 0;\n}\n\nstatic int atl_resume_common(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct aq_nic_s *nic;\n\tint ret = 0;\n\n\tnic = pci_get_drvdata(pdev);\n\n\trtnl_lock();\n\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_restore_state(pdev);\n\n\tif (netif_running(nic->ndev)) {\n\t\tret = aq_nic_init(nic);\n\t\tif (ret)\n\t\t\tgoto err_exit;\n\n\t\tret = aq_nic_start(nic);\n\t\tif (ret)\n\t\t\tgoto err_exit;\n\t}\n\n\tnetif_device_attach(nic->ndev);\n\tnetif_tx_start_all_queues(nic->ndev);\n\nerr_exit:\n\tif (ret < 0)\n\t\taq_nic_deinit(nic, true);\n\n\trtnl_unlock();\n\n\treturn ret;\n}\n\nstatic int aq_pm_freeze(struct device *dev)\n{\n\treturn aq_suspend_common(dev);\n}\n\nstatic int aq_pm_suspend_poweroff(struct device *dev)\n{\n\treturn aq_suspend_common(dev);\n}\n\nstatic int aq_pm_thaw(struct device *dev)\n{\n\treturn atl_resume_common(dev);\n}\n\nstatic int aq_pm_resume_restore(struct device *dev)\n{\n\treturn atl_resume_common(dev);\n}\n\nstatic const struct dev_pm_ops aq_pm_ops = {\n\t.suspend = aq_pm_suspend_poweroff,\n\t.poweroff = aq_pm_suspend_poweroff,\n\t.freeze = aq_pm_freeze,\n\t.resume = aq_pm_resume_restore,\n\t.restore = aq_pm_resume_restore,\n\t.thaw = aq_pm_thaw,\n};\n#endif\n\nstatic struct pci_driver aq_pci_ops = {\n\t.name = AQ_CFG_DRV_NAME,\n\t.id_table = aq_pci_tbl,\n\t.probe = aq_pci_probe,\n\t.remove = aq_pci_remove,\n\t.shutdown = aq_pci_shutdown,\n#ifdef CONFIG_PM\n\t.driver.pm = &aq_pm_ops,\n#endif\n};\n\nint aq_pci_func_register_driver(void)\n{\n\treturn pci_register_driver(&aq_pci_ops);\n}\n\nvoid aq_pci_func_unregister_driver(void)\n{\n\tpci_unregister_driver(&aq_pci_ops);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}