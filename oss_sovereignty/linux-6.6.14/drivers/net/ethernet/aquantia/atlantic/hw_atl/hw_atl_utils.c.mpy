{
  "module_name": "hw_atl_utils.c",
  "hash_id": "7ca50defe3432d9e1485b69d70fb748a47b943cd001fefd5253c9ee7c9cf6582",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c",
  "human_readable_source": "\n \n\n \n\n#include \"../aq_nic.h\"\n#include \"../aq_hw_utils.h\"\n#include \"hw_atl_utils.h\"\n#include \"hw_atl_llh.h\"\n#include \"hw_atl_llh_internal.h\"\n\n#include <linux/random.h>\n\n#define HW_ATL_UCP_0X370_REG    0x0370U\n\n#define HW_ATL_MIF_CMD          0x0200U\n#define HW_ATL_MIF_ADDR         0x0208U\n#define HW_ATL_MIF_VAL          0x020CU\n\n#define HW_ATL_MPI_RPC_ADDR     0x0334U\n#define HW_ATL_RPC_CONTROL_ADR  0x0338U\n#define HW_ATL_RPC_STATE_ADR    0x033CU\n\n#define HW_ATL_MPI_FW_VERSION\t0x18\n#define HW_ATL_MPI_CONTROL_ADR  0x0368U\n#define HW_ATL_MPI_STATE_ADR    0x036CU\n\n#define HW_ATL_MPI_STATE_MSK      0x00FFU\n#define HW_ATL_MPI_STATE_SHIFT    0U\n#define HW_ATL_MPI_SPEED_MSK      0x00FF0000U\n#define HW_ATL_MPI_SPEED_SHIFT    16U\n#define HW_ATL_MPI_DIRTY_WAKE_MSK 0x02000000U\n\n#define HW_ATL_MPI_DAISY_CHAIN_STATUS\t0x704\n#define HW_ATL_MPI_BOOT_EXIT_CODE\t0x388\n\n#define HW_ATL_MAC_PHY_CONTROL\t0x4000\n#define HW_ATL_MAC_PHY_MPI_RESET_BIT 0x1D\n\n#define HW_ATL_FW_VER_1X 0x01050006U\n#define HW_ATL_FW_VER_2X 0x02000000U\n#define HW_ATL_FW_VER_3X 0x03000000U\n#define HW_ATL_FW_VER_4X 0x04000000U\n\n#define FORCE_FLASHLESS 0\n\nenum mcp_area {\n\tMCP_AREA_CONFIG = 0x80000000,\n\tMCP_AREA_SETTINGS = 0x20000000,\n};\n\nstatic int hw_atl_utils_mpi_set_state(struct aq_hw_s *self,\n\t\t\t\t      enum hal_atl_utils_fw_state_e state);\nstatic u32 hw_atl_utils_get_mpi_mbox_tid(struct aq_hw_s *self);\nstatic u32 hw_atl_utils_mpi_get_state(struct aq_hw_s *self);\nstatic u32 hw_atl_utils_mif_cmd_get(struct aq_hw_s *self);\nstatic u32 hw_atl_utils_mif_addr_get(struct aq_hw_s *self);\nstatic u32 hw_atl_utils_rpc_state_get(struct aq_hw_s *self);\nstatic u32 aq_fw1x_rpc_get(struct aq_hw_s *self);\n\nint hw_atl_utils_initfw(struct aq_hw_s *self, const struct aq_fw_ops **fw_ops)\n{\n\tint err = 0;\n\n\thw_atl_utils_hw_chip_features_init(self,\n\t\t\t\t\t   &self->chip_features);\n\n\tself->fw_ver_actual = hw_atl_utils_get_fw_version(self);\n\n\tif (hw_atl_utils_ver_match(HW_ATL_FW_VER_1X, self->fw_ver_actual)) {\n\t\t*fw_ops = &aq_fw_1x_ops;\n\t} else if (hw_atl_utils_ver_match(HW_ATL_FW_VER_2X, self->fw_ver_actual)) {\n\t\t*fw_ops = &aq_fw_2x_ops;\n\t} else if (hw_atl_utils_ver_match(HW_ATL_FW_VER_3X, self->fw_ver_actual)) {\n\t\t*fw_ops = &aq_fw_2x_ops;\n\t} else if (hw_atl_utils_ver_match(HW_ATL_FW_VER_4X, self->fw_ver_actual)) {\n\t\t*fw_ops = &aq_fw_2x_ops;\n\t} else {\n\t\taq_pr_err(\"Bad FW version detected: %x\\n\",\n\t\t\t  self->fw_ver_actual);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tself->aq_fw_ops = *fw_ops;\n\terr = self->aq_fw_ops->init(self);\n\n\treturn err;\n}\n\nstatic int hw_atl_utils_soft_reset_flb(struct aq_hw_s *self)\n{\n\tu32 gsr, val;\n\tint k = 0;\n\n\taq_hw_write_reg(self, 0x404, 0x40e1);\n\tAQ_HW_SLEEP(50);\n\n\t \n\tval = aq_hw_read_reg(self, 0x53C);\n\taq_hw_write_reg(self, 0x53C, val | 0x10);\n\n\tgsr = aq_hw_read_reg(self, HW_ATL_GLB_SOFT_RES_ADR);\n\taq_hw_write_reg(self, HW_ATL_GLB_SOFT_RES_ADR, (gsr & 0xBFFF) | 0x8000);\n\n\t \n\taq_hw_write_reg(self, 0x404, 0x80e0);\n\taq_hw_write_reg(self, 0x32a8, 0x0);\n\taq_hw_write_reg(self, 0x520, 0x1);\n\n\t \n\tval = aq_hw_read_reg(self, 0x53C);\n\taq_hw_write_reg(self, 0x53C, val | 0x10);\n\tAQ_HW_SLEEP(10);\n\t \n\taq_hw_write_reg(self, 0x53C, val & ~0x10);\n\n\taq_hw_write_reg(self, 0x404, 0x180e0);\n\n\tfor (k = 0; k < 1000; k++) {\n\t\tu32 flb_status = aq_hw_read_reg(self,\n\t\t\t\t\t\tHW_ATL_MPI_DAISY_CHAIN_STATUS);\n\n\t\tflb_status = flb_status & 0x10;\n\t\tif (flb_status)\n\t\t\tbreak;\n\t\tAQ_HW_SLEEP(10);\n\t}\n\tif (k == 1000) {\n\t\taq_pr_err(\"MAC kickstart failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\taq_hw_write_reg(self, 0x404, 0x80e0);\n\tAQ_HW_SLEEP(50);\n\taq_hw_write_reg(self, 0x3a0, 0x1);\n\n\t \n\n\t \n\thw_atl_rx_rx_reg_res_dis_set(self, 0U);\n\thw_atl_tx_tx_reg_res_dis_set(self, 0U);\n\taq_hw_write_reg_bit(self, HW_ATL_MAC_PHY_CONTROL,\n\t\t\t    BIT(HW_ATL_MAC_PHY_MPI_RESET_BIT),\n\t\t\t    HW_ATL_MAC_PHY_MPI_RESET_BIT, 0x0);\n\tgsr = aq_hw_read_reg(self, HW_ATL_GLB_SOFT_RES_ADR);\n\taq_hw_write_reg(self, HW_ATL_GLB_SOFT_RES_ADR, (gsr & 0xBFFF) | 0x8000);\n\n\tfor (k = 0; k < 1000; k++) {\n\t\tu32 fw_state = aq_hw_read_reg(self, HW_ATL_MPI_FW_VERSION);\n\n\t\tif (fw_state)\n\t\t\tbreak;\n\t\tAQ_HW_SLEEP(10);\n\t}\n\tif (k == 1000) {\n\t\taq_pr_err(\"FW kickstart failed\\n\");\n\t\treturn -EIO;\n\t}\n\t \n\tAQ_HW_SLEEP(15);\n\n\treturn 0;\n}\n\nstatic int hw_atl_utils_soft_reset_rbl(struct aq_hw_s *self)\n{\n\tu32 gsr, val, rbl_status;\n\tint k;\n\n\taq_hw_write_reg(self, 0x404, 0x40e1);\n\taq_hw_write_reg(self, 0x3a0, 0x1);\n\taq_hw_write_reg(self, 0x32a8, 0x0);\n\n\t \n\taq_hw_write_reg(self, 0x388, 0xDEAD);\n\n\t \n\tval = aq_hw_read_reg(self, 0x53C);\n\taq_hw_write_reg(self, 0x53C, val | 0x10);\n\n\t \n\thw_atl_rx_rx_reg_res_dis_set(self, 0U);\n\thw_atl_tx_tx_reg_res_dis_set(self, 0U);\n\taq_hw_write_reg_bit(self, HW_ATL_MAC_PHY_CONTROL,\n\t\t\t    BIT(HW_ATL_MAC_PHY_MPI_RESET_BIT),\n\t\t\t    HW_ATL_MAC_PHY_MPI_RESET_BIT, 0x0);\n\tgsr = aq_hw_read_reg(self, HW_ATL_GLB_SOFT_RES_ADR);\n\taq_hw_write_reg(self, HW_ATL_GLB_SOFT_RES_ADR,\n\t\t\t(gsr & 0xFFFFBFFF) | 0x8000);\n\n\tif (FORCE_FLASHLESS)\n\t\taq_hw_write_reg(self, 0x534, 0x0);\n\n\taq_hw_write_reg(self, 0x404, 0x40e0);\n\n\t \n\tfor (k = 0; k < 1000; k++) {\n\t\trbl_status = aq_hw_read_reg(self, 0x388) & 0xFFFF;\n\t\tif (rbl_status && rbl_status != 0xDEAD)\n\t\t\tbreak;\n\t\tAQ_HW_SLEEP(10);\n\t}\n\tif (!rbl_status || rbl_status == 0xDEAD) {\n\t\taq_pr_err(\"RBL Restart failed\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (FORCE_FLASHLESS)\n\t\taq_hw_write_reg(self, 0x534, 0xA0);\n\n\tif (rbl_status == 0xF1A7) {\n\t\taq_pr_err(\"No FW detected. Dynamic FW load not implemented\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tfor (k = 0; k < 1000; k++) {\n\t\tu32 fw_state = aq_hw_read_reg(self, HW_ATL_MPI_FW_VERSION);\n\n\t\tif (fw_state)\n\t\t\tbreak;\n\t\tAQ_HW_SLEEP(10);\n\t}\n\tif (k == 1000) {\n\t\taq_pr_err(\"FW kickstart failed\\n\");\n\t\treturn -EIO;\n\t}\n\t \n\tAQ_HW_SLEEP(15);\n\n\treturn 0;\n}\n\nint hw_atl_utils_soft_reset(struct aq_hw_s *self)\n{\n\tint ver = hw_atl_utils_get_fw_version(self);\n\tu32 boot_exit_code = 0;\n\tu32 val;\n\tint k;\n\n\tfor (k = 0; k < 1000; ++k) {\n\t\tu32 flb_status = aq_hw_read_reg(self,\n\t\t\t\t\t\tHW_ATL_MPI_DAISY_CHAIN_STATUS);\n\t\tboot_exit_code = aq_hw_read_reg(self,\n\t\t\t\t\t\tHW_ATL_MPI_BOOT_EXIT_CODE);\n\t\tif (flb_status != 0x06000000 || boot_exit_code != 0)\n\t\t\tbreak;\n\t}\n\n\tif (k == 1000) {\n\t\taq_pr_err(\"Neither RBL nor FLB firmware started\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tself->rbl_enabled = (boot_exit_code != 0);\n\n\tif (hw_atl_utils_ver_match(HW_ATL_FW_VER_1X, ver)) {\n\t\tint err = 0;\n\n\t\t \n\t\thw_atl_utils_mpi_set_state(self, MPI_DEINIT);\n\t\terr = readx_poll_timeout_atomic(hw_atl_utils_mpi_get_state,\n\t\t\t\t\t\tself, val,\n\t\t\t\t\t\t(val & HW_ATL_MPI_STATE_MSK) ==\n\t\t\t\t\t\t MPI_DEINIT,\n\t\t\t\t\t\t10, 10000U);\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (hw_atl_utils_ver_match(HW_ATL_FW_VER_4X, ver)) {\n\t\tu64 sem_timeout = aq_hw_read_reg(self, HW_ATL_MIF_RESET_TIMEOUT_ADR);\n\n\t\t \n\t\tif (sem_timeout > 3000)\n\t\t\tsem_timeout = 3000;\n\t\tsem_timeout = sem_timeout * 1000;\n\n\t\tif (sem_timeout != 0) {\n\t\t\tint err;\n\n\t\t\terr = readx_poll_timeout_atomic(hw_atl_sem_reset1_get, self, val,\n\t\t\t\t\t\t\tval == 1U, 1U, sem_timeout);\n\t\t\tif (err)\n\t\t\t\taq_pr_err(\"reset sema1 timeout\");\n\n\t\t\terr = readx_poll_timeout_atomic(hw_atl_sem_reset2_get, self, val,\n\t\t\t\t\t\t\tval == 1U, 1U, sem_timeout);\n\t\t\tif (err)\n\t\t\t\taq_pr_err(\"reset sema2 timeout\");\n\t\t}\n\t}\n\n\tif (self->rbl_enabled)\n\t\treturn hw_atl_utils_soft_reset_rbl(self);\n\telse\n\t\treturn hw_atl_utils_soft_reset_flb(self);\n}\n\nint hw_atl_utils_fw_downld_dwords(struct aq_hw_s *self, u32 a,\n\t\t\t\t  u32 *p, u32 cnt)\n{\n\tint err = 0;\n\tu32 val;\n\n\terr = readx_poll_timeout_atomic(hw_atl_sem_ram_get,\n\t\t\t\t\tself, val, val == 1U,\n\t\t\t\t\t1U, 10000U);\n\n\tif (err < 0) {\n\t\tbool is_locked;\n\n\t\thw_atl_reg_glb_cpu_sem_set(self, 1U, HW_ATL_FW_SM_RAM);\n\t\tis_locked = hw_atl_sem_ram_get(self);\n\t\tif (!is_locked) {\n\t\t\terr = -ETIME;\n\t\t\tgoto err_exit;\n\t\t}\n\t}\n\n\taq_hw_write_reg(self, HW_ATL_MIF_ADDR, a);\n\n\tfor (++cnt; --cnt && !err;) {\n\t\taq_hw_write_reg(self, HW_ATL_MIF_CMD, 0x00008000U);\n\n\t\tif (ATL_HW_IS_CHIP_FEATURE(self, REVISION_B1))\n\t\t\terr = readx_poll_timeout_atomic(hw_atl_utils_mif_addr_get,\n\t\t\t\t\t\t\tself, val, val != a,\n\t\t\t\t\t\t\t1U, 1000U);\n\t\telse\n\t\t\terr = readx_poll_timeout_atomic(hw_atl_utils_mif_cmd_get,\n\t\t\t\t\t\t\tself, val,\n\t\t\t\t\t\t\t!(val & 0x100),\n\t\t\t\t\t\t\t1U, 1000U);\n\n\t\t*(p++) = aq_hw_read_reg(self, HW_ATL_MIF_VAL);\n\t\ta += 4;\n\t}\n\n\thw_atl_reg_glb_cpu_sem_set(self, 1U, HW_ATL_FW_SM_RAM);\n\nerr_exit:\n\treturn err;\n}\n\nstatic int hw_atl_utils_write_b1_mbox(struct aq_hw_s *self, u32 addr,\n\t\t\t\t      u32 *p, u32 cnt, enum mcp_area area)\n{\n\tu32 data_offset = 0;\n\tu32 offset = addr;\n\tint err = 0;\n\tu32 val;\n\n\tswitch (area) {\n\tcase MCP_AREA_CONFIG:\n\t\toffset -= self->rpc_addr;\n\t\tbreak;\n\n\tcase MCP_AREA_SETTINGS:\n\t\toffset -= self->settings_addr;\n\t\tbreak;\n\t}\n\n\toffset = offset / sizeof(u32);\n\n\tfor (; data_offset < cnt; ++data_offset, ++offset) {\n\t\taq_hw_write_reg(self, 0x328, p[data_offset]);\n\t\taq_hw_write_reg(self, 0x32C,\n\t\t\t\t(area | (0xFFFF & (offset * 4))));\n\t\thw_atl_mcp_up_force_intr_set(self, 1);\n\t\t \n\t\terr = readx_poll_timeout_atomic(hw_atl_scrpad12_get,\n\t\t\t\t\t\tself, val,\n\t\t\t\t\t\t(val & 0xF0000000) !=\n\t\t\t\t\t\tarea,\n\t\t\t\t\t\t10U, 10000U);\n\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int hw_atl_utils_write_b0_mbox(struct aq_hw_s *self, u32 addr,\n\t\t\t\t      u32 *p, u32 cnt)\n{\n\tu32 offset = 0;\n\tint err = 0;\n\tu32 val;\n\n\taq_hw_write_reg(self, 0x208, addr);\n\n\tfor (; offset < cnt; ++offset) {\n\t\taq_hw_write_reg(self, 0x20C, p[offset]);\n\t\taq_hw_write_reg(self, 0x200, 0xC000);\n\n\t\terr = readx_poll_timeout_atomic(hw_atl_utils_mif_cmd_get,\n\t\t\t\t\t\tself, val,\n\t\t\t\t\t\t(val & 0x100) == 0U,\n\t\t\t\t\t\t10U, 10000U);\n\n\t\tif (err < 0)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int hw_atl_utils_fw_upload_dwords(struct aq_hw_s *self, u32 addr, u32 *p,\n\t\t\t\t\t u32 cnt, enum mcp_area area)\n{\n\tint err = 0;\n\tu32 val;\n\n\terr = readx_poll_timeout_atomic(hw_atl_sem_ram_get, self,\n\t\t\t\t\tval, val == 1U,\n\t\t\t\t\t10U, 100000U);\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\tif (ATL_HW_IS_CHIP_FEATURE(self, REVISION_B1))\n\t\terr = hw_atl_utils_write_b1_mbox(self, addr, p, cnt, area);\n\telse\n\t\terr = hw_atl_utils_write_b0_mbox(self, addr, p, cnt);\n\n\thw_atl_reg_glb_cpu_sem_set(self, 1U, HW_ATL_FW_SM_RAM);\n\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\terr = aq_hw_err_from_flags(self);\n\nerr_exit:\n\treturn err;\n}\n\nint hw_atl_write_fwcfg_dwords(struct aq_hw_s *self, u32 *p, u32 cnt)\n{\n\treturn hw_atl_utils_fw_upload_dwords(self, self->rpc_addr, p,\n\t\t\t\t\t     cnt, MCP_AREA_CONFIG);\n}\n\nint hw_atl_write_fwsettings_dwords(struct aq_hw_s *self, u32 offset, u32 *p,\n\t\t\t\t   u32 cnt)\n{\n\treturn hw_atl_utils_fw_upload_dwords(self, self->settings_addr + offset,\n\t\t\t\t\t     p, cnt, MCP_AREA_SETTINGS);\n}\n\nbool hw_atl_utils_ver_match(u32 ver_expected, u32 ver_actual)\n{\n\tconst u32 dw_major_mask = 0xff000000U;\n\tconst u32 dw_minor_mask = 0x00ffffffU;\n\tbool ver_match;\n\n\tver_match = (dw_major_mask & (ver_expected ^ ver_actual)) ? false : true;\n\tif (!ver_match)\n\t\tgoto err_exit;\n\tver_match = ((dw_minor_mask & ver_expected) > (dw_minor_mask & ver_actual)) ?\n\t\tfalse : true;\n\nerr_exit:\n\treturn ver_match;\n}\n\nstatic int hw_atl_utils_init_ucp(struct aq_hw_s *self,\n\t\t\t\t const struct aq_hw_caps_s *aq_hw_caps)\n{\n\tint err = 0;\n\n\tif (!aq_hw_read_reg(self, 0x370U)) {\n\t\tunsigned int rnd = 0U;\n\t\tunsigned int ucp_0x370 = 0U;\n\n\t\tget_random_bytes(&rnd, sizeof(unsigned int));\n\n\t\tucp_0x370 = 0x02020202U | (0xFEFEFEFEU & rnd);\n\t\taq_hw_write_reg(self, HW_ATL_UCP_0X370_REG, ucp_0x370);\n\t}\n\n\thw_atl_reg_glb_cpu_scratch_scp_set(self, 0x00000000U, 25U);\n\n\t \n\terr = readx_poll_timeout_atomic(hw_atl_scrpad25_get,\n\t\t\t\t\tself, self->mbox_addr,\n\t\t\t\t\tself->mbox_addr != 0U,\n\t\t\t\t\t1000U, 10000U);\n\terr = readx_poll_timeout_atomic(aq_fw1x_rpc_get, self,\n\t\t\t\t\tself->rpc_addr,\n\t\t\t\t\tself->rpc_addr != 0U,\n\t\t\t\t\t1000U, 100000U);\n\n\treturn err;\n}\n\nstruct aq_hw_atl_utils_fw_rpc_tid_s {\n\tunion {\n\t\tu32 val;\n\t\tstruct {\n\t\t\tu16 tid;\n\t\t\tu16 len;\n\t\t};\n\t};\n};\n\n#define hw_atl_utils_fw_rpc_init(_H_) hw_atl_utils_fw_rpc_wait(_H_, NULL)\n\nint hw_atl_utils_fw_rpc_call(struct aq_hw_s *self, unsigned int rpc_size)\n{\n\tstruct aq_hw_atl_utils_fw_rpc_tid_s sw;\n\tint err = 0;\n\n\tif (!ATL_HW_IS_CHIP_FEATURE(self, MIPS)) {\n\t\terr = -1;\n\t\tgoto err_exit;\n\t}\n\terr = hw_atl_write_fwcfg_dwords(self, (u32 *)(void *)&self->rpc,\n\t\t\t\t\t(rpc_size + sizeof(u32) -\n\t\t\t\t\t sizeof(u8)) / sizeof(u32));\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\tsw.tid = 0xFFFFU & (++self->rpc_tid);\n\tsw.len = (u16)rpc_size;\n\taq_hw_write_reg(self, HW_ATL_RPC_CONTROL_ADR, sw.val);\n\nerr_exit:\n\treturn err;\n}\n\nint hw_atl_utils_fw_rpc_wait(struct aq_hw_s *self,\n\t\t\t     struct hw_atl_utils_fw_rpc **rpc)\n{\n\tstruct aq_hw_atl_utils_fw_rpc_tid_s sw;\n\tstruct aq_hw_atl_utils_fw_rpc_tid_s fw;\n\tint err = 0;\n\n\tdo {\n\t\tsw.val = aq_hw_read_reg(self, HW_ATL_RPC_CONTROL_ADR);\n\n\t\tself->rpc_tid = sw.tid;\n\n\t\terr = readx_poll_timeout_atomic(hw_atl_utils_rpc_state_get,\n\t\t\t\t\t\tself, fw.val,\n\t\t\t\t\t\tsw.tid == fw.tid,\n\t\t\t\t\t\t1000U, 100000U);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\terr = aq_hw_err_from_flags(self);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\tif (fw.len == 0xFFFFU) {\n\t\t\tif (sw.len > sizeof(self->rpc)) {\n\t\t\t\tprintk(KERN_INFO \"Invalid sw len: %x\\n\", sw.len);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t\terr = hw_atl_utils_fw_rpc_call(self, sw.len);\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_exit;\n\t\t}\n\t} while (sw.tid != fw.tid || 0xFFFFU == fw.len);\n\n\tif (rpc) {\n\t\tif (fw.len) {\n\t\t\tif (fw.len > sizeof(self->rpc)) {\n\t\t\t\tprintk(KERN_INFO \"Invalid fw len: %x\\n\", fw.len);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t\terr =\n\t\t\thw_atl_utils_fw_downld_dwords(self,\n\t\t\t\t\t\t      self->rpc_addr,\n\t\t\t\t\t\t      (u32 *)(void *)\n\t\t\t\t\t\t      &self->rpc,\n\t\t\t\t\t\t      (fw.len + sizeof(u32) -\n\t\t\t\t\t\t       sizeof(u8)) /\n\t\t\t\t\t\t      sizeof(u32));\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_exit;\n\t\t}\n\n\t\t*rpc = &self->rpc;\n\t}\n\nerr_exit:\n\treturn err;\n}\n\nstatic int hw_atl_utils_mpi_create(struct aq_hw_s *self)\n{\n\tint err = 0;\n\n\terr = hw_atl_utils_init_ucp(self, self->aq_nic_cfg->aq_hw_caps);\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\terr = hw_atl_utils_fw_rpc_init(self);\n\tif (err < 0)\n\t\tgoto err_exit;\n\nerr_exit:\n\treturn err;\n}\n\nint hw_atl_utils_mpi_read_mbox(struct aq_hw_s *self,\n\t\t\t       struct hw_atl_utils_mbox_header *pmbox)\n{\n\treturn hw_atl_utils_fw_downld_dwords(self,\n\t\t\t\t\t     self->mbox_addr,\n\t\t\t\t\t     (u32 *)(void *)pmbox,\n\t\t\t\t\t     sizeof(*pmbox) / sizeof(u32));\n}\n\nvoid hw_atl_utils_mpi_read_stats(struct aq_hw_s *self,\n\t\t\t\t struct hw_atl_utils_mbox *pmbox)\n{\n\tint err = 0;\n\n\terr = hw_atl_utils_fw_downld_dwords(self,\n\t\t\t\t\t    self->mbox_addr,\n\t\t\t\t\t    (u32 *)(void *)pmbox,\n\t\t\t\t\t    sizeof(*pmbox) / sizeof(u32));\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\tif (ATL_HW_IS_CHIP_FEATURE(self, REVISION_A0)) {\n\t\tunsigned int mtu = self->aq_nic_cfg ?\n\t\t\t\t\tself->aq_nic_cfg->mtu : 1514U;\n\t\tpmbox->stats.ubrc = pmbox->stats.uprc * mtu;\n\t\tpmbox->stats.ubtc = pmbox->stats.uptc * mtu;\n\t\tpmbox->stats.dpc = atomic_read(&self->dpc);\n\t} else {\n\t\tpmbox->stats.dpc = hw_atl_rpb_rx_dma_drop_pkt_cnt_get(self);\n\t}\n\nerr_exit:;\n}\n\nstatic int hw_atl_utils_mpi_set_speed(struct aq_hw_s *self, u32 speed)\n{\n\tu32 val = aq_hw_read_reg(self, HW_ATL_MPI_CONTROL_ADR);\n\n\tval = val & ~HW_ATL_MPI_SPEED_MSK;\n\tval |= speed << HW_ATL_MPI_SPEED_SHIFT;\n\taq_hw_write_reg(self, HW_ATL_MPI_CONTROL_ADR, val);\n\n\treturn 0;\n}\n\nstatic int hw_atl_utils_mpi_set_state(struct aq_hw_s *self,\n\t\t\t\t      enum hal_atl_utils_fw_state_e state)\n{\n\tu32 val = aq_hw_read_reg(self, HW_ATL_MPI_CONTROL_ADR);\n\tstruct hw_atl_utils_mbox_header mbox;\n\tu32 transaction_id = 0;\n\tint err = 0;\n\n\tif (state == MPI_RESET) {\n\t\thw_atl_utils_mpi_read_mbox(self, &mbox);\n\n\t\ttransaction_id = mbox.transaction_id;\n\n\t\terr = readx_poll_timeout_atomic(hw_atl_utils_get_mpi_mbox_tid,\n\t\t\t\t\t\tself, mbox.transaction_id,\n\t\t\t\t\t\ttransaction_id !=\n\t\t\t\t\t\tmbox.transaction_id,\n\t\t\t\t\t\t1000U, 100000U);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\t}\n\t \n\tif (state == MPI_DEINIT || state == MPI_POWER)\n\t\tval |= HW_ATL_MPI_DIRTY_WAKE_MSK;\n\telse\n\t\tval &= ~HW_ATL_MPI_DIRTY_WAKE_MSK;\n\n\t \n\tval = val & ~HW_ATL_MPI_STATE_MSK;\n\tval |= state & HW_ATL_MPI_STATE_MSK;\n\n\taq_hw_write_reg(self, HW_ATL_MPI_CONTROL_ADR, val);\n\nerr_exit:\n\treturn err;\n}\n\nint hw_atl_utils_mpi_get_link_status(struct aq_hw_s *self)\n{\n\tstruct aq_hw_link_status_s *link_status = &self->aq_link_status;\n\tu32 mpi_state;\n\tu32 speed;\n\n\tmpi_state = hw_atl_utils_mpi_get_state(self);\n\tspeed = mpi_state >> HW_ATL_MPI_SPEED_SHIFT;\n\n\tif (!speed) {\n\t\tlink_status->mbps = 0U;\n\t} else {\n\t\tswitch (speed) {\n\t\tcase HAL_ATLANTIC_RATE_10G:\n\t\t\tlink_status->mbps = 10000U;\n\t\t\tbreak;\n\n\t\tcase HAL_ATLANTIC_RATE_5G:\n\t\tcase HAL_ATLANTIC_RATE_5GSR:\n\t\t\tlink_status->mbps = 5000U;\n\t\t\tbreak;\n\n\t\tcase HAL_ATLANTIC_RATE_2G5:\n\t\t\tlink_status->mbps = 2500U;\n\t\t\tbreak;\n\n\t\tcase HAL_ATLANTIC_RATE_1G:\n\t\t\tlink_status->mbps = 1000U;\n\t\t\tbreak;\n\n\t\tcase HAL_ATLANTIC_RATE_100M:\n\t\t\tlink_status->mbps = 100U;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tlink_status->full_duplex = true;\n\n\treturn 0;\n}\n\nint hw_atl_utils_get_mac_permanent(struct aq_hw_s *self,\n\t\t\t\t   u8 *mac)\n{\n\tu32 mac_addr[2];\n\tu32 efuse_addr;\n\tint err = 0;\n\tu32 h = 0U;\n\tu32 l = 0U;\n\n\tif (!aq_hw_read_reg(self, HW_ATL_UCP_0X370_REG)) {\n\t\tunsigned int ucp_0x370 = 0;\n\t\tunsigned int rnd = 0;\n\n\t\tget_random_bytes(&rnd, sizeof(unsigned int));\n\n\t\tucp_0x370 = 0x02020202 | (0xFEFEFEFE & rnd);\n\t\taq_hw_write_reg(self, HW_ATL_UCP_0X370_REG, ucp_0x370);\n\t}\n\n\tefuse_addr = aq_hw_read_reg(self, 0x00000374U);\n\n\terr = hw_atl_utils_fw_downld_dwords(self, efuse_addr + (40U * 4U),\n\t\t\t\t\t    mac_addr, ARRAY_SIZE(mac_addr));\n\tif (err < 0) {\n\t\tmac_addr[0] = 0U;\n\t\tmac_addr[1] = 0U;\n\t\terr = 0;\n\t} else {\n\t\tmac_addr[0] = __swab32(mac_addr[0]);\n\t\tmac_addr[1] = __swab32(mac_addr[1]);\n\t}\n\n\tether_addr_copy(mac, (u8 *)mac_addr);\n\n\tif ((mac[0] & 0x01U) || ((mac[0] | mac[1] | mac[2]) == 0x00U)) {\n\t\t \n\t\tl = 0xE3000000U |\n\t\t    (0xFFFFU & aq_hw_read_reg(self, HW_ATL_UCP_0X370_REG)) |\n\t\t    (0x00 << 16);\n\t\th = 0x8001300EU;\n\n\t\tmac[5] = (u8)(0xFFU & l);\n\t\tl >>= 8;\n\t\tmac[4] = (u8)(0xFFU & l);\n\t\tl >>= 8;\n\t\tmac[3] = (u8)(0xFFU & l);\n\t\tl >>= 8;\n\t\tmac[2] = (u8)(0xFFU & l);\n\t\tmac[1] = (u8)(0xFFU & h);\n\t\th >>= 8;\n\t\tmac[0] = (u8)(0xFFU & h);\n\t}\n\n\treturn err;\n}\n\nunsigned int hw_atl_utils_mbps_2_speed_index(unsigned int mbps)\n{\n\tunsigned int ret = 0U;\n\n\tswitch (mbps) {\n\tcase 100U:\n\t\tret = 5U;\n\t\tbreak;\n\n\tcase 1000U:\n\t\tret = 4U;\n\t\tbreak;\n\n\tcase 2500U:\n\t\tret = 3U;\n\t\tbreak;\n\n\tcase 5000U:\n\t\tret = 1U;\n\t\tbreak;\n\n\tcase 10000U:\n\t\tret = 0U;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nvoid hw_atl_utils_hw_chip_features_init(struct aq_hw_s *self, u32 *p)\n{\n\tu32 val = hw_atl_reg_glb_mif_id_get(self);\n\tu32 mif_rev = val & 0xFFU;\n\tu32 chip_features = 0U;\n\n\tchip_features |= ATL_HW_CHIP_ATLANTIC;\n\n\tif ((0xFU & mif_rev) == 1U) {\n\t\tchip_features |= ATL_HW_CHIP_REVISION_A0 |\n\t\t\tATL_HW_CHIP_MPI_AQ |\n\t\t\tATL_HW_CHIP_MIPS;\n\t} else if ((0xFU & mif_rev) == 2U) {\n\t\tchip_features |= ATL_HW_CHIP_REVISION_B0 |\n\t\t\tATL_HW_CHIP_MPI_AQ |\n\t\t\tATL_HW_CHIP_MIPS |\n\t\t\tATL_HW_CHIP_TPO2 |\n\t\t\tATL_HW_CHIP_RPF2;\n\t} else if ((0xFU & mif_rev) == 0xAU) {\n\t\tchip_features |= ATL_HW_CHIP_REVISION_B1 |\n\t\t\tATL_HW_CHIP_MPI_AQ |\n\t\t\tATL_HW_CHIP_MIPS |\n\t\t\tATL_HW_CHIP_TPO2 |\n\t\t\tATL_HW_CHIP_RPF2;\n\t}\n\n\t*p = chip_features;\n}\n\nstatic int hw_atl_fw1x_deinit(struct aq_hw_s *self)\n{\n\thw_atl_utils_mpi_set_speed(self, 0);\n\thw_atl_utils_mpi_set_state(self, MPI_DEINIT);\n\n\treturn 0;\n}\n\nint hw_atl_utils_update_stats(struct aq_hw_s *self)\n{\n\tstruct aq_stats_s *cs = &self->curr_stats;\n\tstruct aq_stats_s curr_stats = *cs;\n\tstruct hw_atl_utils_mbox mbox;\n\tbool corrupted_stats = false;\n\n\thw_atl_utils_mpi_read_stats(self, &mbox);\n\n#define AQ_SDELTA(_N_)  \\\ndo { \\\n\tif (!corrupted_stats && \\\n\t    ((s64)(mbox.stats._N_ - self->last_stats._N_)) >= 0) \\\n\t\tcurr_stats._N_ += mbox.stats._N_ - self->last_stats._N_; \\\n\telse \\\n\t\tcorrupted_stats = true; \\\n} while (0)\n\n\tif (self->aq_link_status.mbps) {\n\t\tAQ_SDELTA(uprc);\n\t\tAQ_SDELTA(mprc);\n\t\tAQ_SDELTA(bprc);\n\t\tAQ_SDELTA(erpt);\n\n\t\tAQ_SDELTA(uptc);\n\t\tAQ_SDELTA(mptc);\n\t\tAQ_SDELTA(bptc);\n\t\tAQ_SDELTA(erpr);\n\n\t\tAQ_SDELTA(ubrc);\n\t\tAQ_SDELTA(ubtc);\n\t\tAQ_SDELTA(mbrc);\n\t\tAQ_SDELTA(mbtc);\n\t\tAQ_SDELTA(bbrc);\n\t\tAQ_SDELTA(bbtc);\n\t\tAQ_SDELTA(dpc);\n\n\t\tif (!corrupted_stats)\n\t\t\t*cs = curr_stats;\n\t}\n#undef AQ_SDELTA\n\n\tcs->dma_pkt_rc = hw_atl_stats_rx_dma_good_pkt_counter_get(self);\n\tcs->dma_pkt_tc = hw_atl_stats_tx_dma_good_pkt_counter_get(self);\n\tcs->dma_oct_rc = hw_atl_stats_rx_dma_good_octet_counter_get(self);\n\tcs->dma_oct_tc = hw_atl_stats_tx_dma_good_octet_counter_get(self);\n\n\tmemcpy(&self->last_stats, &mbox.stats, sizeof(mbox.stats));\n\n\treturn 0;\n}\n\nstruct aq_stats_s *hw_atl_utils_get_hw_stats(struct aq_hw_s *self)\n{\n\treturn &self->curr_stats;\n}\n\nstatic const u32 hw_atl_utils_hw_mac_regs[] = {\n\t0x00005580U, 0x00005590U, 0x000055B0U, 0x000055B4U,\n\t0x000055C0U, 0x00005B00U, 0x00005B04U, 0x00005B08U,\n\t0x00005B0CU, 0x00005B10U, 0x00005B14U, 0x00005B18U,\n\t0x00005B1CU, 0x00005B20U, 0x00005B24U, 0x00005B28U,\n\t0x00005B2CU, 0x00005B30U, 0x00005B34U, 0x00005B38U,\n\t0x00005B3CU, 0x00005B40U, 0x00005B44U, 0x00005B48U,\n\t0x00005B4CU, 0x00005B50U, 0x00005B54U, 0x00005B58U,\n\t0x00005B5CU, 0x00005B60U, 0x00005B64U, 0x00005B68U,\n\t0x00005B6CU, 0x00005B70U, 0x00005B74U, 0x00005B78U,\n\t0x00005B7CU, 0x00007C00U, 0x00007C04U, 0x00007C08U,\n\t0x00007C0CU, 0x00007C10U, 0x00007C14U, 0x00007C18U,\n\t0x00007C1CU, 0x00007C20U, 0x00007C40U, 0x00007C44U,\n\t0x00007C48U, 0x00007C4CU, 0x00007C50U, 0x00007C54U,\n\t0x00007C58U, 0x00007C5CU, 0x00007C60U, 0x00007C80U,\n\t0x00007C84U, 0x00007C88U, 0x00007C8CU, 0x00007C90U,\n\t0x00007C94U, 0x00007C98U, 0x00007C9CU, 0x00007CA0U,\n\t0x00007CC0U, 0x00007CC4U, 0x00007CC8U, 0x00007CCCU,\n\t0x00007CD0U, 0x00007CD4U, 0x00007CD8U, 0x00007CDCU,\n\t0x00007CE0U, 0x00000300U, 0x00000304U, 0x00000308U,\n\t0x0000030cU, 0x00000310U, 0x00000314U, 0x00000318U,\n\t0x0000031cU, 0x00000360U, 0x00000364U, 0x00000368U,\n\t0x0000036cU, 0x00000370U, 0x00000374U, 0x00006900U,\n};\n\nint hw_atl_utils_hw_get_regs(struct aq_hw_s *self,\n\t\t\t     const struct aq_hw_caps_s *aq_hw_caps,\n\t\t\t     u32 *regs_buff)\n{\n\tunsigned int i = 0U;\n\n\tfor (i = 0; i < aq_hw_caps->mac_regs_count; i++)\n\t\tregs_buff[i] = aq_hw_read_reg(self,\n\t\t\t\t\t      hw_atl_utils_hw_mac_regs[i]);\n\n\treturn 0;\n}\n\nu32 hw_atl_utils_get_fw_version(struct aq_hw_s *self)\n{\n\treturn aq_hw_read_reg(self, HW_ATL_MPI_FW_VERSION);\n}\n\nstatic int aq_fw1x_set_wake_magic(struct aq_hw_s *self, bool wol_enabled,\n\t\t\t\t  const u8 *mac)\n{\n\tstruct hw_atl_utils_fw_rpc *prpc = NULL;\n\tunsigned int rpc_size = 0U;\n\tint err = 0;\n\n\terr = hw_atl_utils_fw_rpc_wait(self, &prpc);\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\tmemset(prpc, 0, sizeof(*prpc));\n\n\tif (wol_enabled) {\n\t\trpc_size = offsetof(struct hw_atl_utils_fw_rpc, msg_wol_add) +\n\t\t\t   sizeof(prpc->msg_wol_add);\n\n\n\t\tprpc->msg_id = HAL_ATLANTIC_UTILS_FW_MSG_WOL_ADD;\n\t\tprpc->msg_wol_add.priority =\n\t\t\t\tHAL_ATLANTIC_UTILS_FW_MSG_WOL_PRIOR;\n\t\tprpc->msg_wol_add.pattern_id =\n\t\t\t\tHAL_ATLANTIC_UTILS_FW_MSG_WOL_PATTERN;\n\t\tprpc->msg_wol_add.packet_type =\n\t\t\t\tHAL_ATLANTIC_UTILS_FW_MSG_WOL_MAG_PKT;\n\n\t\tether_addr_copy((u8 *)&prpc->msg_wol_add.magic_packet_pattern,\n\t\t\t\tmac);\n\t} else {\n\t\trpc_size = sizeof(prpc->msg_wol_remove) +\n\t\t\t   offsetof(struct hw_atl_utils_fw_rpc, msg_wol_remove);\n\n\t\tprpc->msg_id = HAL_ATLANTIC_UTILS_FW_MSG_WOL_DEL;\n\t\tprpc->msg_wol_add.pattern_id =\n\t\t\t\tHAL_ATLANTIC_UTILS_FW_MSG_WOL_PATTERN;\n\t}\n\n\terr = hw_atl_utils_fw_rpc_call(self, rpc_size);\n\nerr_exit:\n\treturn err;\n}\n\nstatic int aq_fw1x_set_power(struct aq_hw_s *self, unsigned int power_state,\n\t\t\t     const u8 *mac)\n{\n\tstruct hw_atl_utils_fw_rpc *prpc = NULL;\n\tunsigned int rpc_size = 0U;\n\tint err = 0;\n\n\tif (self->aq_nic_cfg->wol & WAKE_MAGIC) {\n\t\terr = aq_fw1x_set_wake_magic(self, 1, mac);\n\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\trpc_size = sizeof(prpc->msg_id) +\n\t\t\t   sizeof(prpc->msg_enable_wakeup);\n\n\t\terr = hw_atl_utils_fw_rpc_wait(self, &prpc);\n\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\tmemset(prpc, 0, rpc_size);\n\n\t\tprpc->msg_id = HAL_ATLANTIC_UTILS_FW_MSG_ENABLE_WAKEUP;\n\t\tprpc->msg_enable_wakeup.pattern_mask = 0x00000002;\n\n\t\terr = hw_atl_utils_fw_rpc_call(self, rpc_size);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\t}\n\thw_atl_utils_mpi_set_speed(self, 0);\n\thw_atl_utils_mpi_set_state(self, MPI_POWER);\n\nerr_exit:\n\treturn err;\n}\n\nstatic u32 hw_atl_utils_get_mpi_mbox_tid(struct aq_hw_s *self)\n{\n\tstruct hw_atl_utils_mbox_header mbox;\n\n\thw_atl_utils_mpi_read_mbox(self, &mbox);\n\n\treturn mbox.transaction_id;\n}\n\nstatic u32 hw_atl_utils_mpi_get_state(struct aq_hw_s *self)\n{\n\treturn aq_hw_read_reg(self, HW_ATL_MPI_STATE_ADR);\n}\n\nstatic u32 hw_atl_utils_mif_cmd_get(struct aq_hw_s *self)\n{\n\treturn aq_hw_read_reg(self, HW_ATL_MIF_CMD);\n}\n\nstatic u32 hw_atl_utils_mif_addr_get(struct aq_hw_s *self)\n{\n\treturn aq_hw_read_reg(self, HW_ATL_MIF_ADDR);\n}\n\nstatic u32 hw_atl_utils_rpc_state_get(struct aq_hw_s *self)\n{\n\treturn aq_hw_read_reg(self, HW_ATL_RPC_STATE_ADR);\n}\n\nstatic u32 aq_fw1x_rpc_get(struct aq_hw_s *self)\n{\n\treturn aq_hw_read_reg(self, HW_ATL_MPI_RPC_ADDR);\n}\n\nconst struct aq_fw_ops aq_fw_1x_ops = {\n\t.init = hw_atl_utils_mpi_create,\n\t.deinit = hw_atl_fw1x_deinit,\n\t.reset = NULL,\n\t.get_mac_permanent = hw_atl_utils_get_mac_permanent,\n\t.set_link_speed = hw_atl_utils_mpi_set_speed,\n\t.set_state = hw_atl_utils_mpi_set_state,\n\t.update_link_status = hw_atl_utils_mpi_get_link_status,\n\t.update_stats = hw_atl_utils_update_stats,\n\t.get_mac_temp = NULL,\n\t.get_phy_temp = NULL,\n\t.set_power = aq_fw1x_set_power,\n\t.set_eee_rate = NULL,\n\t.get_eee_rate = NULL,\n\t.set_flow_control = NULL,\n\t.send_fw_request = NULL,\n\t.enable_ptp = NULL,\n\t.led_control = NULL,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}