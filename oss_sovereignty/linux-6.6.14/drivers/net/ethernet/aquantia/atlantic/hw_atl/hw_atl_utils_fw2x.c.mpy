{
  "module_name": "hw_atl_utils_fw2x.c",
  "hash_id": "2a6dffec06612985e673afc22fd3f23bea0671291fcb368bd847ed5b4580a110",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c",
  "human_readable_source": "\n \n\n \n\n#include \"../aq_hw.h\"\n#include \"../aq_hw_utils.h\"\n#include \"../aq_pci_func.h\"\n#include \"../aq_ring.h\"\n#include \"../aq_vec.h\"\n#include \"../aq_nic.h\"\n#include \"hw_atl_utils.h\"\n#include \"hw_atl_llh.h\"\n\n#define HW_ATL_FW2X_MPI_LED_ADDR         0x31c\n#define HW_ATL_FW2X_MPI_RPC_ADDR         0x334\n\n#define HW_ATL_FW2X_MPI_MBOX_ADDR        0x360\n#define HW_ATL_FW2X_MPI_EFUSE_ADDR       0x364\n#define HW_ATL_FW2X_MPI_CONTROL_ADDR     0x368\n#define HW_ATL_FW2X_MPI_CONTROL2_ADDR    0x36C\n#define HW_ATL_FW2X_MPI_STATE_ADDR       0x370\n#define HW_ATL_FW2X_MPI_STATE2_ADDR      0x374\n\n#define HW_ATL_FW3X_EXT_CONTROL_ADDR     0x378\n#define HW_ATL_FW3X_EXT_STATE_ADDR       0x37c\n\n#define HW_ATL_FW3X_PTP_ADJ_LSW_ADDR\t 0x50a0\n#define HW_ATL_FW3X_PTP_ADJ_MSW_ADDR\t 0x50a4\n\n#define HW_ATL_FW2X_CAP_PAUSE            BIT(CAPS_HI_PAUSE)\n#define HW_ATL_FW2X_CAP_ASYM_PAUSE       BIT(CAPS_HI_ASYMMETRIC_PAUSE)\n#define HW_ATL_FW2X_CAP_SLEEP_PROXY      BIT(CAPS_HI_SLEEP_PROXY)\n#define HW_ATL_FW2X_CAP_WOL              BIT(CAPS_HI_WOL)\n\n#define HW_ATL_FW2X_CTRL_WAKE_ON_LINK     BIT(CTRL_WAKE_ON_LINK)\n#define HW_ATL_FW2X_CTRL_SLEEP_PROXY      BIT(CTRL_SLEEP_PROXY)\n#define HW_ATL_FW2X_CTRL_WOL              BIT(CTRL_WOL)\n#define HW_ATL_FW2X_CTRL_LINK_DROP        BIT(CTRL_LINK_DROP)\n#define HW_ATL_FW2X_CTRL_PAUSE            BIT(CTRL_PAUSE)\n#define HW_ATL_FW2X_CTRL_TEMPERATURE      BIT(CTRL_TEMPERATURE)\n#define HW_ATL_FW2X_CTRL_ASYMMETRIC_PAUSE BIT(CTRL_ASYMMETRIC_PAUSE)\n#define HW_ATL_FW2X_CTRL_INT_LOOPBACK     BIT(CTRL_INT_LOOPBACK)\n#define HW_ATL_FW2X_CTRL_EXT_LOOPBACK     BIT(CTRL_EXT_LOOPBACK)\n#define HW_ATL_FW2X_CTRL_DOWNSHIFT        BIT(CTRL_DOWNSHIFT)\n#define HW_ATL_FW2X_CTRL_FORCE_RECONNECT  BIT(CTRL_FORCE_RECONNECT)\n\n#define HW_ATL_FW2X_CAP_EEE_1G_MASK      BIT(CAPS_HI_1000BASET_FD_EEE)\n#define HW_ATL_FW2X_CAP_EEE_2G5_MASK     BIT(CAPS_HI_2P5GBASET_FD_EEE)\n#define HW_ATL_FW2X_CAP_EEE_5G_MASK      BIT(CAPS_HI_5GBASET_FD_EEE)\n#define HW_ATL_FW2X_CAP_EEE_10G_MASK     BIT(CAPS_HI_10GBASET_FD_EEE)\n\n#define HW_ATL_FW2X_CAP_MACSEC           BIT(CAPS_LO_MACSEC)\n\n#define HAL_ATLANTIC_WOL_FILTERS_COUNT   8\n#define HAL_ATLANTIC_UTILS_FW2X_MSG_WOL  0x0E\n\n#define HW_ATL_FW_VER_LED                0x03010026U\n#define HW_ATL_FW_VER_MEDIA_CONTROL      0x0301005aU\n\nstruct __packed fw2x_msg_wol_pattern {\n\tu8 mask[16];\n\tu32 crc;\n};\n\nstruct __packed fw2x_msg_wol {\n\tu32 msg_id;\n\tu8 hw_addr[ETH_ALEN];\n\tu8 magic_packet_enabled;\n\tu8 filter_count;\n\tstruct fw2x_msg_wol_pattern filter[HAL_ATLANTIC_WOL_FILTERS_COUNT];\n\tu8 link_up_enabled;\n\tu8 link_down_enabled;\n\tu16 reserved;\n\tu32 link_up_timeout;\n\tu32 link_down_timeout;\n};\n\nstatic int aq_fw2x_set_link_speed(struct aq_hw_s *self, u32 speed);\nstatic int aq_fw2x_set_state(struct aq_hw_s *self,\n\t\t\t     enum hal_atl_utils_fw_state_e state);\n\nstatic u32 aq_fw2x_mbox_get(struct aq_hw_s *self);\nstatic u32 aq_fw2x_rpc_get(struct aq_hw_s *self);\nstatic int aq_fw2x_settings_get(struct aq_hw_s *self, u32 *addr);\nstatic u32 aq_fw2x_state_get(struct aq_hw_s *self);\nstatic u32 aq_fw2x_state2_get(struct aq_hw_s *self);\n\nstatic int aq_fw2x_init(struct aq_hw_s *self)\n{\n\tint err = 0;\n\n\t \n\terr = readx_poll_timeout_atomic(aq_fw2x_mbox_get,\n\t\t\t\t\tself, self->mbox_addr,\n\t\t\t\t\tself->mbox_addr != 0U,\n\t\t\t\t\t1000U, 10000U);\n\n\terr = readx_poll_timeout_atomic(aq_fw2x_rpc_get,\n\t\t\t\t\tself, self->rpc_addr,\n\t\t\t\t\tself->rpc_addr != 0U,\n\t\t\t\t\t1000U, 100000U);\n\n\terr = aq_fw2x_settings_get(self, &self->settings_addr);\n\n\treturn err;\n}\n\nstatic int aq_fw2x_deinit(struct aq_hw_s *self)\n{\n\tint err = aq_fw2x_set_link_speed(self, 0);\n\n\tif (!err)\n\t\terr = aq_fw2x_set_state(self, MPI_DEINIT);\n\n\treturn err;\n}\n\nstatic enum hw_atl_fw2x_rate link_speed_mask_2fw2x_ratemask(u32 speed)\n{\n\tenum hw_atl_fw2x_rate rate = 0;\n\n\tif (speed & AQ_NIC_RATE_10G)\n\t\trate |= FW2X_RATE_10G;\n\n\tif (speed & AQ_NIC_RATE_5G)\n\t\trate |= FW2X_RATE_5G;\n\n\tif (speed & AQ_NIC_RATE_2G5)\n\t\trate |= FW2X_RATE_2G5;\n\n\tif (speed & AQ_NIC_RATE_1G)\n\t\trate |= FW2X_RATE_1G;\n\n\tif (speed & AQ_NIC_RATE_100M)\n\t\trate |= FW2X_RATE_100M;\n\n\treturn rate;\n}\n\nstatic u32 fw2x_to_eee_mask(u32 speed)\n{\n\tu32 rate = 0;\n\n\tif (speed & HW_ATL_FW2X_CAP_EEE_10G_MASK)\n\t\trate |= AQ_NIC_RATE_EEE_10G;\n\tif (speed & HW_ATL_FW2X_CAP_EEE_5G_MASK)\n\t\trate |= AQ_NIC_RATE_EEE_5G;\n\tif (speed & HW_ATL_FW2X_CAP_EEE_2G5_MASK)\n\t\trate |= AQ_NIC_RATE_EEE_2G5;\n\tif (speed & HW_ATL_FW2X_CAP_EEE_1G_MASK)\n\t\trate |= AQ_NIC_RATE_EEE_1G;\n\n\treturn rate;\n}\n\nstatic u32 eee_mask_to_fw2x(u32 speed)\n{\n\tu32 rate = 0;\n\n\tif (speed & AQ_NIC_RATE_EEE_10G)\n\t\trate |= HW_ATL_FW2X_CAP_EEE_10G_MASK;\n\tif (speed & AQ_NIC_RATE_EEE_5G)\n\t\trate |= HW_ATL_FW2X_CAP_EEE_5G_MASK;\n\tif (speed & AQ_NIC_RATE_EEE_2G5)\n\t\trate |= HW_ATL_FW2X_CAP_EEE_2G5_MASK;\n\tif (speed & AQ_NIC_RATE_EEE_1G)\n\t\trate |= HW_ATL_FW2X_CAP_EEE_1G_MASK;\n\n\treturn rate;\n}\n\nstatic int aq_fw2x_set_link_speed(struct aq_hw_s *self, u32 speed)\n{\n\tu32 val = link_speed_mask_2fw2x_ratemask(speed);\n\n\taq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL_ADDR, val);\n\n\treturn 0;\n}\n\nstatic void aq_fw2x_upd_flow_control_bits(struct aq_hw_s *self,\n\t\t\t\t\t  u32 *mpi_state, u32 fc)\n{\n\t*mpi_state &= ~(HW_ATL_FW2X_CTRL_PAUSE |\n\t\t\tHW_ATL_FW2X_CTRL_ASYMMETRIC_PAUSE);\n\n\tswitch (fc) {\n\t \n\tcase AQ_NIC_FC_FULL:\n\tcase AQ_NIC_FC_RX:\n\t\t*mpi_state |= HW_ATL_FW2X_CTRL_PAUSE |\n\t\t\t      HW_ATL_FW2X_CTRL_ASYMMETRIC_PAUSE;\n\t\tbreak;\n\tcase AQ_NIC_FC_TX:\n\t\t*mpi_state |= HW_ATL_FW2X_CTRL_ASYMMETRIC_PAUSE;\n\t\tbreak;\n\t}\n}\n\nstatic void aq_fw2x_upd_eee_rate_bits(struct aq_hw_s *self, u32 *mpi_opts,\n\t\t\t\t      u32 eee_speeds)\n{\n\t*mpi_opts &= ~(HW_ATL_FW2X_CAP_EEE_1G_MASK |\n\t\t       HW_ATL_FW2X_CAP_EEE_2G5_MASK |\n\t\t       HW_ATL_FW2X_CAP_EEE_5G_MASK |\n\t\t       HW_ATL_FW2X_CAP_EEE_10G_MASK);\n\n\t*mpi_opts |= eee_mask_to_fw2x(eee_speeds);\n}\n\nstatic int aq_fw2x_set_state(struct aq_hw_s *self,\n\t\t\t     enum hal_atl_utils_fw_state_e state)\n{\n\tu32 mpi_state = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);\n\tstruct aq_nic_cfg_s *cfg = self->aq_nic_cfg;\n\n\tswitch (state) {\n\tcase MPI_INIT:\n\t\tmpi_state &= ~BIT(CAPS_HI_LINK_DROP);\n\t\taq_fw2x_upd_eee_rate_bits(self, &mpi_state, cfg->eee_speeds);\n\t\taq_fw2x_upd_flow_control_bits(self, &mpi_state,\n\t\t\t\t\t      self->aq_nic_cfg->fc.req);\n\t\tbreak;\n\tcase MPI_DEINIT:\n\t\tmpi_state |= BIT(CAPS_HI_LINK_DROP);\n\t\tbreak;\n\tcase MPI_RESET:\n\tcase MPI_POWER:\n\t\t \n\t\tbreak;\n\t}\n\taq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_state);\n\n\treturn 0;\n}\n\nstatic int aq_fw2x_update_link_status(struct aq_hw_s *self)\n{\n\tstruct aq_hw_link_status_s *link_status = &self->aq_link_status;\n\tu32 mpi_state;\n\tu32 speed;\n\n\tmpi_state = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_STATE_ADDR);\n\tspeed = mpi_state & (FW2X_RATE_100M | FW2X_RATE_1G |\n\t\t\t     FW2X_RATE_2G5 | FW2X_RATE_5G |\n\t\t\t     FW2X_RATE_10G);\n\n\tif (speed) {\n\t\tif (speed & FW2X_RATE_10G)\n\t\t\tlink_status->mbps = 10000;\n\t\telse if (speed & FW2X_RATE_5G)\n\t\t\tlink_status->mbps = 5000;\n\t\telse if (speed & FW2X_RATE_2G5)\n\t\t\tlink_status->mbps = 2500;\n\t\telse if (speed & FW2X_RATE_1G)\n\t\t\tlink_status->mbps = 1000;\n\t\telse if (speed & FW2X_RATE_100M)\n\t\t\tlink_status->mbps = 100;\n\t\telse\n\t\t\tlink_status->mbps = 10000;\n\t} else {\n\t\tlink_status->mbps = 0;\n\t}\n\tlink_status->full_duplex = true;\n\n\treturn 0;\n}\n\nstatic int aq_fw2x_get_mac_permanent(struct aq_hw_s *self, u8 *mac)\n{\n\tu32 efuse_addr = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_EFUSE_ADDR);\n\tu32 mac_addr[2] = { 0 };\n\tint err = 0;\n\n\tif (efuse_addr != 0) {\n\t\terr = hw_atl_utils_fw_downld_dwords(self,\n\t\t\t\t\t\t    efuse_addr + (40U * 4U),\n\t\t\t\t\t\t    mac_addr,\n\t\t\t\t\t\t    ARRAY_SIZE(mac_addr));\n\t\tif (err)\n\t\t\treturn err;\n\t\tmac_addr[0] = __swab32(mac_addr[0]);\n\t\tmac_addr[1] = __swab32(mac_addr[1]);\n\t}\n\n\tether_addr_copy(mac, (u8 *)mac_addr);\n\n\treturn err;\n}\n\nstatic int aq_fw2x_update_stats(struct aq_hw_s *self)\n{\n\tu32 mpi_opts = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);\n\tu32 orig_stats_val = mpi_opts & BIT(CAPS_HI_STATISTICS);\n\tu32 stats_val;\n\tint err = 0;\n\n\t \n\tmpi_opts = mpi_opts ^ BIT(CAPS_HI_STATISTICS);\n\taq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_opts);\n\n\t \n\terr = readx_poll_timeout_atomic(aq_fw2x_state2_get,\n\t\t\t\t\tself, stats_val,\n\t\t\t\t\torig_stats_val != (stats_val &\n\t\t\t\t\tBIT(CAPS_HI_STATISTICS)),\n\t\t\t\t\t1U, 10000U);\n\tif (err)\n\t\treturn err;\n\n\treturn hw_atl_utils_update_stats(self);\n}\n\nstatic int aq_fw2x_get_phy_temp(struct aq_hw_s *self, int *temp)\n{\n\tu32 mpi_opts = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);\n\tu32 temp_val = mpi_opts & HW_ATL_FW2X_CTRL_TEMPERATURE;\n\tu32 phy_temp_offset;\n\tu32 temp_res;\n\tint err = 0;\n\tu32 val;\n\n\tphy_temp_offset = self->mbox_addr + offsetof(struct hw_atl_utils_mbox,\n\t\t\t\t\t\t     info.phy_temperature);\n\n\t \n\tmpi_opts = mpi_opts ^ HW_ATL_FW2X_CTRL_TEMPERATURE;\n\taq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_opts);\n\t \n\terr = readx_poll_timeout_atomic(aq_fw2x_state2_get, self, val,\n\t\t\t\t\ttemp_val !=\n\t\t\t\t\t(val & HW_ATL_FW2X_CTRL_TEMPERATURE),\n\t\t\t\t\t1U, 10000U);\n\terr = hw_atl_utils_fw_downld_dwords(self, phy_temp_offset,\n\t\t\t\t\t    &temp_res, 1);\n\n\tif (err)\n\t\treturn err;\n\n\t \n\t*temp = (int16_t)(temp_res & 0xFFFF) * 1000 / 256;\n\n\treturn 0;\n}\n\nstatic int aq_fw2x_set_wol(struct aq_hw_s *self, const u8 *mac)\n{\n\tstruct hw_atl_utils_fw_rpc *rpc = NULL;\n\tstruct offload_info *info = NULL;\n\tu32 wol_bits = 0;\n\tu32 rpc_size;\n\tint err = 0;\n\tu32 val;\n\n\tif (self->aq_nic_cfg->wol & WAKE_PHY) {\n\t\taq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR,\n\t\t\t\tHW_ATL_FW2X_CTRL_LINK_DROP);\n\t\treadx_poll_timeout_atomic(aq_fw2x_state2_get, self, val,\n\t\t\t\t\t  (val &\n\t\t\t\t\t   HW_ATL_FW2X_CTRL_LINK_DROP) != 0,\n\t\t\t\t\t  1000, 100000);\n\t\twol_bits |= HW_ATL_FW2X_CTRL_WAKE_ON_LINK;\n\t}\n\n\tif (self->aq_nic_cfg->wol & WAKE_MAGIC) {\n\t\twol_bits |= HW_ATL_FW2X_CTRL_SLEEP_PROXY |\n\t\t\t    HW_ATL_FW2X_CTRL_WOL;\n\n\t\terr = hw_atl_utils_fw_rpc_wait(self, &rpc);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\trpc_size = sizeof(*info) +\n\t\t\t   offsetof(struct hw_atl_utils_fw_rpc, fw2x_offloads);\n\t\tmemset(rpc, 0, rpc_size);\n\t\tinfo = &rpc->fw2x_offloads;\n\t\tmemcpy(info->mac_addr, mac, ETH_ALEN);\n\t\tinfo->len = sizeof(*info);\n\n\t\terr = hw_atl_utils_fw_rpc_call(self, rpc_size);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\t}\n\n\taq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, wol_bits);\n\nerr_exit:\n\treturn err;\n}\n\nstatic int aq_fw2x_set_power(struct aq_hw_s *self, unsigned int power_state,\n\t\t\t     const u8 *mac)\n{\n\tint err = 0;\n\n\tif (self->aq_nic_cfg->wol)\n\t\terr = aq_fw2x_set_wol(self, mac);\n\n\treturn err;\n}\n\nstatic int aq_fw2x_send_fw_request(struct aq_hw_s *self,\n\t\t\t\t   const struct hw_fw_request_iface *fw_req,\n\t\t\t\t   size_t size)\n{\n\tu32 ctrl2, orig_ctrl2;\n\tu32 dword_cnt;\n\tint err = 0;\n\tu32 val;\n\n\t \n\tdword_cnt = size / sizeof(u32);\n\tif (size % sizeof(u32))\n\t\tdword_cnt++;\n\terr = hw_atl_write_fwcfg_dwords(self, (void *)fw_req, dword_cnt);\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\t \n\tctrl2 = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);\n\torig_ctrl2 = ctrl2 & BIT(CAPS_HI_FW_REQUEST);\n\tctrl2 = ctrl2 ^ BIT(CAPS_HI_FW_REQUEST);\n\taq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, ctrl2);\n\n\t \n\terr = readx_poll_timeout_atomic(aq_fw2x_state2_get, self, val,\n\t\t\t\t\torig_ctrl2 != (val &\n\t\t\t\t\t\t       BIT(CAPS_HI_FW_REQUEST)),\n\t\t\t\t\t1U, 10000U);\n\nerr_exit:\n\treturn err;\n}\n\nstatic void aq_fw3x_enable_ptp(struct aq_hw_s *self, int enable)\n{\n\tu32 ptp_opts = aq_hw_read_reg(self, HW_ATL_FW3X_EXT_STATE_ADDR);\n\tu32 all_ptp_features = BIT(CAPS_EX_PHY_PTP_EN) |\n\t\t\t\t\t\t   BIT(CAPS_EX_PTP_GPIO_EN);\n\n\tif (enable)\n\t\tptp_opts |= all_ptp_features;\n\telse\n\t\tptp_opts &= ~all_ptp_features;\n\n\taq_hw_write_reg(self, HW_ATL_FW3X_EXT_CONTROL_ADDR, ptp_opts);\n}\n\nstatic void aq_fw3x_adjust_ptp(struct aq_hw_s *self, uint64_t adj)\n{\n\taq_hw_write_reg(self, HW_ATL_FW3X_PTP_ADJ_LSW_ADDR,\n\t\t\t(adj >>  0) & 0xffffffff);\n\taq_hw_write_reg(self, HW_ATL_FW3X_PTP_ADJ_MSW_ADDR,\n\t\t\t(adj >> 32) & 0xffffffff);\n}\n\nstatic int aq_fw2x_led_control(struct aq_hw_s *self, u32 mode)\n{\n\tif (self->fw_ver_actual < HW_ATL_FW_VER_LED)\n\t\treturn -EOPNOTSUPP;\n\n\taq_hw_write_reg(self, HW_ATL_FW2X_MPI_LED_ADDR, mode);\n\n\treturn 0;\n}\n\nstatic int aq_fw2x_set_eee_rate(struct aq_hw_s *self, u32 speed)\n{\n\tu32 mpi_opts = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);\n\n\taq_fw2x_upd_eee_rate_bits(self, &mpi_opts, speed);\n\n\taq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_opts);\n\n\treturn 0;\n}\n\nstatic int aq_fw2x_get_eee_rate(struct aq_hw_s *self, u32 *rate,\n\t\t\t\tu32 *supported_rates)\n{\n\tu32 mpi_state;\n\tu32 caps_hi;\n\tint err = 0;\n\tu32 offset;\n\n\toffset = self->mbox_addr + offsetof(struct hw_atl_utils_mbox,\n\t\t\t\t\t    info.caps_hi);\n\n\terr = hw_atl_utils_fw_downld_dwords(self, offset, &caps_hi, 1);\n\n\tif (err)\n\t\treturn err;\n\n\t*supported_rates = fw2x_to_eee_mask(caps_hi);\n\n\tmpi_state = aq_fw2x_state2_get(self);\n\t*rate = fw2x_to_eee_mask(mpi_state);\n\n\treturn err;\n}\n\nstatic int aq_fw2x_renegotiate(struct aq_hw_s *self)\n{\n\tu32 mpi_opts = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);\n\n\tmpi_opts |= BIT(CTRL_FORCE_RECONNECT);\n\n\taq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_opts);\n\n\treturn 0;\n}\n\nstatic int aq_fw2x_set_flow_control(struct aq_hw_s *self)\n{\n\tu32 mpi_state = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);\n\n\taq_fw2x_upd_flow_control_bits(self, &mpi_state,\n\t\t\t\t      self->aq_nic_cfg->fc.req);\n\n\taq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_state);\n\n\treturn 0;\n}\n\nstatic u32 aq_fw2x_get_flow_control(struct aq_hw_s *self, u32 *fcmode)\n{\n\tu32 mpi_state = aq_fw2x_state2_get(self);\n\t*fcmode = 0;\n\n\tif (mpi_state & HW_ATL_FW2X_CAP_PAUSE)\n\t\t*fcmode |= AQ_NIC_FC_RX;\n\n\tif (mpi_state & HW_ATL_FW2X_CAP_ASYM_PAUSE)\n\t\t*fcmode |= AQ_NIC_FC_TX;\n\n\treturn 0;\n}\n\nstatic int aq_fw2x_set_phyloopback(struct aq_hw_s *self, u32 mode, bool enable)\n{\n\tu32 mpi_opts;\n\n\tswitch (mode) {\n\tcase AQ_HW_LOOPBACK_PHYINT_SYS:\n\t\tmpi_opts = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);\n\t\tif (enable)\n\t\t\tmpi_opts |= HW_ATL_FW2X_CTRL_INT_LOOPBACK;\n\t\telse\n\t\t\tmpi_opts &= ~HW_ATL_FW2X_CTRL_INT_LOOPBACK;\n\t\taq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_opts);\n\t\tbreak;\n\tcase AQ_HW_LOOPBACK_PHYEXT_SYS:\n\t\tmpi_opts = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);\n\t\tif (enable)\n\t\t\tmpi_opts |= HW_ATL_FW2X_CTRL_EXT_LOOPBACK;\n\t\telse\n\t\t\tmpi_opts &= ~HW_ATL_FW2X_CTRL_EXT_LOOPBACK;\n\t\taq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_opts);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 aq_fw2x_mbox_get(struct aq_hw_s *self)\n{\n\treturn aq_hw_read_reg(self, HW_ATL_FW2X_MPI_MBOX_ADDR);\n}\n\nstatic u32 aq_fw2x_rpc_get(struct aq_hw_s *self)\n{\n\treturn aq_hw_read_reg(self, HW_ATL_FW2X_MPI_RPC_ADDR);\n}\n\nstatic int aq_fw2x_settings_get(struct aq_hw_s *self, u32 *addr)\n{\n\tint err = 0;\n\tu32 offset;\n\n\toffset = self->mbox_addr + offsetof(struct hw_atl_utils_mbox,\n\t\t\t\t\t    info.setting_address);\n\n\terr = hw_atl_utils_fw_downld_dwords(self, offset, addr, 1);\n\n\treturn err;\n}\n\nstatic u32 aq_fw2x_state_get(struct aq_hw_s *self)\n{\n\treturn aq_hw_read_reg(self, HW_ATL_FW2X_MPI_STATE_ADDR);\n}\n\nstatic u32 aq_fw2x_state2_get(struct aq_hw_s *self)\n{\n\treturn aq_hw_read_reg(self, HW_ATL_FW2X_MPI_STATE2_ADDR);\n}\n\nstatic int aq_fw2x_set_downshift(struct aq_hw_s *self, u32 counter)\n{\n\tint err = 0;\n\tu32 mpi_opts;\n\tu32 offset;\n\n\toffset = offsetof(struct hw_atl_utils_settings, downshift_retry_count);\n\terr = hw_atl_write_fwsettings_dwords(self, offset, &counter, 1);\n\tif (err)\n\t\treturn err;\n\n\tmpi_opts = aq_hw_read_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR);\n\tif (counter)\n\t\tmpi_opts |= HW_ATL_FW2X_CTRL_DOWNSHIFT;\n\telse\n\t\tmpi_opts &= ~HW_ATL_FW2X_CTRL_DOWNSHIFT;\n\taq_hw_write_reg(self, HW_ATL_FW2X_MPI_CONTROL2_ADDR, mpi_opts);\n\n\treturn err;\n}\n\nstatic int aq_fw2x_set_media_detect(struct aq_hw_s *self, bool on)\n{\n\tu32 enable;\n\tu32 offset;\n\n\tif (self->fw_ver_actual < HW_ATL_FW_VER_MEDIA_CONTROL)\n\t\treturn -EOPNOTSUPP;\n\n\toffset = offsetof(struct hw_atl_utils_settings, media_detect);\n\tenable = on;\n\n\treturn hw_atl_write_fwsettings_dwords(self, offset, &enable, 1);\n}\n\nstatic u32 aq_fw2x_get_link_capabilities(struct aq_hw_s *self)\n{\n\tint err = 0;\n\tu32 offset;\n\tu32 val;\n\n\toffset = self->mbox_addr +\n\t\t offsetof(struct hw_atl_utils_mbox, info.caps_lo);\n\n\terr = hw_atl_utils_fw_downld_dwords(self, offset, &val, 1);\n\n\tif (err)\n\t\treturn 0;\n\n\treturn val;\n}\n\nstatic int aq_fw2x_send_macsec_req(struct aq_hw_s *hw,\n\t\t\t\t   struct macsec_msg_fw_request *req,\n\t\t\t\t   struct macsec_msg_fw_response *response)\n{\n\tu32 low_status, low_req = 0;\n\tu32 dword_cnt;\n\tu32 caps_lo;\n\tu32 offset;\n\tint err;\n\n\tif (!req || !response)\n\t\treturn -EINVAL;\n\n\tcaps_lo = aq_fw2x_get_link_capabilities(hw);\n\tif (!(caps_lo & BIT(CAPS_LO_MACSEC)))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tdword_cnt = (sizeof(*req) + sizeof(u32) - 1) / sizeof(u32);\n\terr = hw_atl_write_fwcfg_dwords(hw, (void *)req, dword_cnt);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tlow_req = aq_hw_read_reg(hw, HW_ATL_FW2X_MPI_CONTROL_ADDR);\n\tlow_req ^= HW_ATL_FW2X_CAP_MACSEC;\n\taq_hw_write_reg(hw, HW_ATL_FW2X_MPI_CONTROL_ADDR, low_req);\n\n\t \n\terr = readx_poll_timeout_atomic(aq_fw2x_state_get, hw, low_status,\n\t\tlow_req != (low_status & BIT(CAPS_LO_MACSEC)), 1U, 10000U);\n\tif (err)\n\t\treturn -EIO;\n\n\t \n\toffset = hw->rpc_addr + sizeof(u32);\n\terr = hw_atl_utils_fw_downld_dwords(hw, offset, (u32 *)(void *)response,\n\t\t\t\t\t    sizeof(*response) / sizeof(u32));\n\n\treturn err;\n}\n\nconst struct aq_fw_ops aq_fw_2x_ops = {\n\t.init               = aq_fw2x_init,\n\t.deinit             = aq_fw2x_deinit,\n\t.reset              = NULL,\n\t.renegotiate        = aq_fw2x_renegotiate,\n\t.get_mac_permanent  = aq_fw2x_get_mac_permanent,\n\t.set_link_speed     = aq_fw2x_set_link_speed,\n\t.set_state          = aq_fw2x_set_state,\n\t.update_link_status = aq_fw2x_update_link_status,\n\t.update_stats       = aq_fw2x_update_stats,\n\t.get_mac_temp       = NULL,\n\t.get_phy_temp       = aq_fw2x_get_phy_temp,\n\t.set_power          = aq_fw2x_set_power,\n\t.set_eee_rate       = aq_fw2x_set_eee_rate,\n\t.get_eee_rate       = aq_fw2x_get_eee_rate,\n\t.set_flow_control   = aq_fw2x_set_flow_control,\n\t.get_flow_control   = aq_fw2x_get_flow_control,\n\t.send_fw_request    = aq_fw2x_send_fw_request,\n\t.enable_ptp         = aq_fw3x_enable_ptp,\n\t.led_control        = aq_fw2x_led_control,\n\t.set_phyloopback    = aq_fw2x_set_phyloopback,\n\t.set_downshift      = aq_fw2x_set_downshift,\n\t.set_media_detect   = aq_fw2x_set_media_detect,\n\t.adjust_ptp         = aq_fw3x_adjust_ptp,\n\t.get_link_capabilities = aq_fw2x_get_link_capabilities,\n\t.send_macsec_req    = aq_fw2x_send_macsec_req,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}