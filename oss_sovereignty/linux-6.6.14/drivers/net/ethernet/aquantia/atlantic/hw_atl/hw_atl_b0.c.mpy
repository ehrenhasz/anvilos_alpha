{
  "module_name": "hw_atl_b0.c",
  "hash_id": "4d5c7619f2083b9a8d509b560252cb6491e6160a60b194edd45ec3ea0e53e120",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c",
  "human_readable_source": "\n \n\n \n\n#include \"../aq_hw.h\"\n#include \"../aq_hw_utils.h\"\n#include \"../aq_ring.h\"\n#include \"../aq_nic.h\"\n#include \"../aq_phy.h\"\n#include \"hw_atl_b0.h\"\n#include \"hw_atl_utils.h\"\n#include \"hw_atl_llh.h\"\n#include \"hw_atl_b0_internal.h\"\n#include \"hw_atl_llh_internal.h\"\n\n#define DEFAULT_B0_BOARD_BASIC_CAPABILITIES \\\n\t.is_64_dma = true,\t\t  \\\n\t.op64bit = false,\t\t  \\\n\t.msix_irqs = 8U,\t\t  \\\n\t.irq_mask = ~0U,\t\t  \\\n\t.vecs = HW_ATL_B0_RSS_MAX,\t  \\\n\t.tcs_max = HW_ATL_B0_TC_MAX,\t  \\\n\t.rxd_alignment = 1U,\t\t  \\\n\t.rxd_size = HW_ATL_B0_RXD_SIZE,   \\\n\t.rxds_max = HW_ATL_B0_MAX_RXD,    \\\n\t.rxds_min = HW_ATL_B0_MIN_RXD,    \\\n\t.txd_alignment = 1U,\t\t  \\\n\t.txd_size = HW_ATL_B0_TXD_SIZE,   \\\n\t.txds_max = HW_ATL_B0_MAX_TXD,    \\\n\t.txds_min = HW_ATL_B0_MIN_TXD,    \\\n\t.txhwb_alignment = 4096U,\t  \\\n\t.tx_rings = HW_ATL_B0_TX_RINGS,   \\\n\t.rx_rings = HW_ATL_B0_RX_RINGS,   \\\n\t.hw_features = NETIF_F_HW_CSUM |  \\\n\t\t\tNETIF_F_RXCSUM |  \\\n\t\t\tNETIF_F_RXHASH |  \\\n\t\t\tNETIF_F_SG |      \\\n\t\t\tNETIF_F_TSO |     \\\n\t\t\tNETIF_F_TSO6 |    \\\n\t\t\tNETIF_F_LRO |     \\\n\t\t\tNETIF_F_NTUPLE |  \\\n\t\t\tNETIF_F_HW_VLAN_CTAG_FILTER | \\\n\t\t\tNETIF_F_HW_VLAN_CTAG_RX |     \\\n\t\t\tNETIF_F_HW_VLAN_CTAG_TX |     \\\n\t\t\tNETIF_F_GSO_UDP_L4      |     \\\n\t\t\tNETIF_F_GSO_PARTIAL |         \\\n\t\t\tNETIF_F_HW_TC,                \\\n\t.hw_priv_flags = IFF_UNICAST_FLT, \\\n\t.flow_control = true,\t\t  \\\n\t.mtu = HW_ATL_B0_MTU_JUMBO,\t  \\\n\t.mac_regs_count = 88,\t\t  \\\n\t.hw_alive_check_addr = 0x10U\n\nconst struct aq_hw_caps_s hw_atl_b0_caps_aqc100 = {\n\tDEFAULT_B0_BOARD_BASIC_CAPABILITIES,\n\t.media_type = AQ_HW_MEDIA_TYPE_FIBRE,\n\t.link_speed_msk = AQ_NIC_RATE_10G |\n\t\t\t  AQ_NIC_RATE_5G |\n\t\t\t  AQ_NIC_RATE_2G5 |\n\t\t\t  AQ_NIC_RATE_1G |\n\t\t\t  AQ_NIC_RATE_100M,\n};\n\nconst struct aq_hw_caps_s hw_atl_b0_caps_aqc107 = {\n\tDEFAULT_B0_BOARD_BASIC_CAPABILITIES,\n\t.media_type = AQ_HW_MEDIA_TYPE_TP,\n\t.link_speed_msk = AQ_NIC_RATE_10G |\n\t\t\t  AQ_NIC_RATE_5G |\n\t\t\t  AQ_NIC_RATE_2G5 |\n\t\t\t  AQ_NIC_RATE_1G |\n\t\t\t  AQ_NIC_RATE_100M,\n};\n\nconst struct aq_hw_caps_s hw_atl_b0_caps_aqc108 = {\n\tDEFAULT_B0_BOARD_BASIC_CAPABILITIES,\n\t.media_type = AQ_HW_MEDIA_TYPE_TP,\n\t.link_speed_msk = AQ_NIC_RATE_5G |\n\t\t\t  AQ_NIC_RATE_2G5 |\n\t\t\t  AQ_NIC_RATE_1G |\n\t\t\t  AQ_NIC_RATE_100M,\n};\n\nconst struct aq_hw_caps_s hw_atl_b0_caps_aqc109 = {\n\tDEFAULT_B0_BOARD_BASIC_CAPABILITIES,\n\t.media_type = AQ_HW_MEDIA_TYPE_TP,\n\t.link_speed_msk = AQ_NIC_RATE_2G5 |\n\t\t\t  AQ_NIC_RATE_1G |\n\t\t\t  AQ_NIC_RATE_100M,\n};\n\nconst struct aq_hw_caps_s hw_atl_b0_caps_aqc111 = {\n\tDEFAULT_B0_BOARD_BASIC_CAPABILITIES,\n\t.media_type = AQ_HW_MEDIA_TYPE_TP,\n\t.link_speed_msk = AQ_NIC_RATE_5G |\n\t\t\t  AQ_NIC_RATE_2G5 |\n\t\t\t  AQ_NIC_RATE_1G |\n\t\t\t  AQ_NIC_RATE_100M,\n\t.quirks = AQ_NIC_QUIRK_BAD_PTP,\n};\n\nconst struct aq_hw_caps_s hw_atl_b0_caps_aqc112 = {\n\tDEFAULT_B0_BOARD_BASIC_CAPABILITIES,\n\t.media_type = AQ_HW_MEDIA_TYPE_TP,\n\t.link_speed_msk = AQ_NIC_RATE_2G5 |\n\t\t\t  AQ_NIC_RATE_1G  |\n\t\t\t  AQ_NIC_RATE_100M,\n\t.quirks = AQ_NIC_QUIRK_BAD_PTP,\n};\n\nstatic int hw_atl_b0_hw_reset(struct aq_hw_s *self)\n{\n\tint err = 0;\n\n\terr = hw_atl_utils_soft_reset(self);\n\tif (err)\n\t\treturn err;\n\n\tself->aq_fw_ops->set_state(self, MPI_RESET);\n\n\terr = aq_hw_err_from_flags(self);\n\n\treturn err;\n}\n\nint hw_atl_b0_set_fc(struct aq_hw_s *self, u32 fc, u32 tc)\n{\n\thw_atl_rpb_rx_xoff_en_per_tc_set(self, !!(fc & AQ_NIC_FC_RX), tc);\n\n\treturn 0;\n}\n\nstatic int hw_atl_b0_tc_ptp_set(struct aq_hw_s *self)\n{\n\t \n\thw_atl_tpb_tx_pkt_buff_size_per_tc_set(self, HW_ATL_B0_PTP_TXBUF_SIZE,\n\t\t\t\t\t       AQ_HW_PTP_TC);\n\n\t \n\thw_atl_rpb_rx_pkt_buff_size_per_tc_set(self, HW_ATL_B0_PTP_RXBUF_SIZE,\n\t\t\t\t\t       AQ_HW_PTP_TC);\n\t \n\thw_atl_rpb_rx_xoff_en_per_tc_set(self, 0U, AQ_HW_PTP_TC);\n\n\treturn aq_hw_err_from_flags(self);\n}\n\nstatic int hw_atl_b0_hw_qos_set(struct aq_hw_s *self)\n{\n\tstruct aq_nic_cfg_s *cfg = self->aq_nic_cfg;\n\tu32 tx_buff_size = HW_ATL_B0_TXBUF_MAX;\n\tu32 rx_buff_size = HW_ATL_B0_RXBUF_MAX;\n\tunsigned int prio = 0U;\n\tu32 tc = 0U;\n\n\tif (cfg->is_ptp) {\n\t\ttx_buff_size -= HW_ATL_B0_PTP_TXBUF_SIZE;\n\t\trx_buff_size -= HW_ATL_B0_PTP_RXBUF_SIZE;\n\t}\n\n\t \n\thw_atl_tps_tx_pkt_shed_desc_rate_curr_time_res_set(self, 0x0U);\n\thw_atl_tps_tx_pkt_shed_desc_rate_lim_set(self, 0xA);\n\n\t \n\thw_atl_tps_tx_pkt_shed_desc_vm_arb_mode_set(self, 0U);\n\n\ttx_buff_size /= cfg->tcs;\n\trx_buff_size /= cfg->tcs;\n\tfor (tc = 0; tc < cfg->tcs; tc++) {\n\t\tu32 threshold = 0U;\n\n\t\t \n\t\thw_atl_tpb_tx_pkt_buff_size_per_tc_set(self, tx_buff_size, tc);\n\n\t\tthreshold = (tx_buff_size * (1024 / 32U) * 66U) / 100U;\n\t\thw_atl_tpb_tx_buff_hi_threshold_per_tc_set(self, threshold, tc);\n\n\t\tthreshold = (tx_buff_size * (1024 / 32U) * 50U) / 100U;\n\t\thw_atl_tpb_tx_buff_lo_threshold_per_tc_set(self, threshold, tc);\n\n\t\t \n\t\thw_atl_rpb_rx_pkt_buff_size_per_tc_set(self, rx_buff_size, tc);\n\n\t\tthreshold = (rx_buff_size * (1024U / 32U) * 66U) / 100U;\n\t\thw_atl_rpb_rx_buff_hi_threshold_per_tc_set(self, threshold, tc);\n\n\t\tthreshold = (rx_buff_size * (1024U / 32U) * 50U) / 100U;\n\t\thw_atl_rpb_rx_buff_lo_threshold_per_tc_set(self, threshold, tc);\n\n\t\thw_atl_b0_set_fc(self, self->aq_nic_cfg->fc.req, tc);\n\t}\n\n\tif (cfg->is_ptp)\n\t\thw_atl_b0_tc_ptp_set(self);\n\n\t \n\tfor (prio = 0; prio < 8; ++prio)\n\t\thw_atl_rpf_rpb_user_priority_tc_map_set(self, prio,\n\t\t\t\t\t\t\tcfg->prio_tc_map[prio]);\n\n\treturn aq_hw_err_from_flags(self);\n}\n\nint hw_atl_b0_hw_rss_hash_set(struct aq_hw_s *self,\n\t\t\t      struct aq_rss_parameters *rss_params)\n{\n\tstruct aq_nic_cfg_s *cfg = self->aq_nic_cfg;\n\tunsigned int addr = 0U;\n\tunsigned int i = 0U;\n\tint err = 0;\n\tu32 val;\n\n\tfor (i = 10, addr = 0U; i--; ++addr) {\n\t\tu32 key_data = cfg->is_rss ?\n\t\t\t__swab32(rss_params->hash_secret_key[i]) : 0U;\n\t\thw_atl_rpf_rss_key_wr_data_set(self, key_data);\n\t\thw_atl_rpf_rss_key_addr_set(self, addr);\n\t\thw_atl_rpf_rss_key_wr_en_set(self, 1U);\n\t\terr = readx_poll_timeout_atomic(hw_atl_rpf_rss_key_wr_en_get,\n\t\t\t\t\t\tself, val, val == 0,\n\t\t\t\t\t\t1000U, 10000U);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\t}\n\n\terr = aq_hw_err_from_flags(self);\n\nerr_exit:\n\treturn err;\n}\n\nstatic int hw_atl_b0_hw_rss_set(struct aq_hw_s *self,\n\t\t\t\tstruct aq_rss_parameters *rss_params)\n{\n\tu32 num_rss_queues = max(1U, self->aq_nic_cfg->num_rss_queues);\n\tu8 *indirection_table =\trss_params->indirection_table;\n\tu16 bitary[1 + (HW_ATL_B0_RSS_REDIRECTION_MAX *\n\t\t   HW_ATL_B0_RSS_REDIRECTION_BITS / 16U)];\n\tint err = 0;\n\tu32 i = 0U;\n\tu32 val;\n\n\tmemset(bitary, 0, sizeof(bitary));\n\n\tfor (i = HW_ATL_B0_RSS_REDIRECTION_MAX; i--;) {\n\t\t(*(u32 *)(bitary + ((i * 3U) / 16U))) |=\n\t\t\t((indirection_table[i] % num_rss_queues) <<\n\t\t\t((i * 3U) & 0xFU));\n\t}\n\n\tfor (i = ARRAY_SIZE(bitary); i--;) {\n\t\thw_atl_rpf_rss_redir_tbl_wr_data_set(self, bitary[i]);\n\t\thw_atl_rpf_rss_redir_tbl_addr_set(self, i);\n\t\thw_atl_rpf_rss_redir_wr_en_set(self, 1U);\n\t\terr = readx_poll_timeout_atomic(hw_atl_rpf_rss_redir_wr_en_get,\n\t\t\t\t\t\tself, val, val == 0,\n\t\t\t\t\t\t1000U, 10000U);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\t}\n\n\terr = aq_hw_err_from_flags(self);\n\nerr_exit:\n\treturn err;\n}\n\nint hw_atl_b0_hw_offload_set(struct aq_hw_s *self,\n\t\t\t     struct aq_nic_cfg_s *aq_nic_cfg)\n{\n\tu64 rxcsum = !!(aq_nic_cfg->features & NETIF_F_RXCSUM);\n\tunsigned int i;\n\n\t \n\thw_atl_tpo_ipv4header_crc_offload_en_set(self, 1);\n\thw_atl_tpo_tcp_udp_crc_offload_en_set(self, 1);\n\n\t \n\thw_atl_rpo_ipv4header_crc_offload_en_set(self, rxcsum);\n\thw_atl_rpo_tcp_udp_crc_offload_en_set(self, rxcsum);\n\n\t \n\thw_atl_tdm_large_send_offload_en_set(self, 0xFFFFFFFFU);\n\n\t \n\thw_atl_rpo_outer_vlan_tag_mode_set(self, 1U);\n\n\t \n\t{\n\t\tunsigned int val = (8U < HW_ATL_B0_LRO_RXD_MAX) ? 0x3U :\n\t\t\t((4U < HW_ATL_B0_LRO_RXD_MAX) ? 0x2U :\n\t\t\t((2U < HW_ATL_B0_LRO_RXD_MAX) ? 0x1U : 0x0));\n\n\t\tfor (i = 0; i < HW_ATL_B0_RINGS_MAX; i++)\n\t\t\thw_atl_rpo_lro_max_num_of_descriptors_set(self, val, i);\n\n\t\thw_atl_rpo_lro_time_base_divider_set(self, 0x61AU);\n\t\thw_atl_rpo_lro_inactive_interval_set(self, 0);\n\t\t \n\t\thw_atl_rpo_lro_max_coalescing_interval_set(self, 50);\n\n\t\thw_atl_rpo_lro_qsessions_lim_set(self, 1U);\n\n\t\thw_atl_rpo_lro_total_desc_lim_set(self, 2U);\n\n\t\thw_atl_rpo_lro_patch_optimization_en_set(self, 1U);\n\n\t\thw_atl_rpo_lro_min_pay_of_first_pkt_set(self, 10U);\n\n\t\thw_atl_rpo_lro_pkt_lim_set(self, 1U);\n\n\t\thw_atl_rpo_lro_en_set(self,\n\t\t\t\t      aq_nic_cfg->is_lro ? 0xFFFFFFFFU : 0U);\n\t\thw_atl_itr_rsc_en_set(self,\n\t\t\t\t      aq_nic_cfg->is_lro ? 0xFFFFFFFFU : 0U);\n\n\t\thw_atl_itr_rsc_delay_set(self, 1U);\n\t}\n\n\treturn aq_hw_err_from_flags(self);\n}\n\nstatic int hw_atl_b0_hw_init_tx_tc_rate_limit(struct aq_hw_s *self)\n{\n\tstatic const u32 max_weight = BIT(HW_ATL_TPS_DATA_TCTWEIGHT_WIDTH) - 1;\n\t \n\tstatic const u32 scale = BIT(HW_ATL_TPS_DESC_RATE_Y_WIDTH);\n\tstatic const u32 frac_msk = HW_ATL_TPS_DESC_RATE_Y_MSK >>\n\t\t\t\t    HW_ATL_TPS_DESC_RATE_Y_SHIFT;\n\tconst u32 link_speed = self->aq_link_status.mbps;\n\tstruct aq_nic_cfg_s *nic_cfg = self->aq_nic_cfg;\n\tunsigned long num_min_rated_tcs = 0;\n\tu32 tc_weight[AQ_CFG_TCS_MAX];\n\tu32 fixed_max_credit;\n\tu8 min_rate_msk = 0;\n\tu32 sum_weight = 0;\n\tint tc;\n\n\t \n\tfixed_max_credit = nic_cfg->aq_hw_caps->mtu / 64;\n\n\tif (link_speed) {\n\t\tmin_rate_msk = nic_cfg->tc_min_rate_msk &\n\t\t\t       (BIT(nic_cfg->tcs) - 1);\n\t\tnum_min_rated_tcs = hweight8(min_rate_msk);\n\t}\n\n\t \n\tif (num_min_rated_tcs) {\n\t\tfor (tc = 0; tc != nic_cfg->tcs; tc++) {\n\t\t\tif (!nic_cfg->tc_min_rate[tc]) {\n\t\t\t\ttc_weight[tc] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttc_weight[tc] = (-1L + link_speed +\n\t\t\t\t\t nic_cfg->tc_min_rate[tc] *\n\t\t\t\t\t max_weight) /\n\t\t\t\t\tlink_speed;\n\t\t\ttc_weight[tc] = min(tc_weight[tc], max_weight);\n\t\t\tsum_weight += tc_weight[tc];\n\t\t}\n\t}\n\n\t \n\tif (!nic_cfg->is_ptp)\n\t\thw_atl_tps_tx_pkt_shed_data_arb_mode_set(self, min_rate_msk ? 1U : 0U);\n\n\t \n\thw_atl_tps_tx_pkt_shed_desc_tc_arb_mode_set(self, 0U);\n\n\thw_atl_tps_tx_desc_rate_mode_set(self, nic_cfg->is_qos ? 1U : 0U);\n\n\tfor (tc = 0; tc != nic_cfg->tcs; tc++) {\n\t\tconst u32 en = (nic_cfg->tc_max_rate[tc] != 0) ? 1U : 0U;\n\t\tconst u32 desc = AQ_NIC_CFG_TCVEC2RING(nic_cfg, tc, 0);\n\t\tu32 weight, max_credit;\n\n\t\thw_atl_tps_tx_pkt_shed_desc_tc_max_credit_set(self, tc,\n\t\t\t\t\t\t\t      fixed_max_credit);\n\t\thw_atl_tps_tx_pkt_shed_desc_tc_weight_set(self, tc, 0x1E);\n\n\t\tif (num_min_rated_tcs) {\n\t\t\tweight = tc_weight[tc];\n\n\t\t\tif (!weight && sum_weight < max_weight)\n\t\t\t\tweight = (max_weight - sum_weight) /\n\t\t\t\t\t (nic_cfg->tcs - num_min_rated_tcs);\n\t\t\telse if (!weight)\n\t\t\t\tweight = 0x64;\n\n\t\t\tmax_credit = max(8 * weight, fixed_max_credit);\n\t\t} else {\n\t\t\tweight = 0x64;\n\t\t\tmax_credit = 0xFFF;\n\t\t}\n\n\t\thw_atl_tps_tx_pkt_shed_tc_data_weight_set(self, tc, weight);\n\t\thw_atl_tps_tx_pkt_shed_tc_data_max_credit_set(self, tc,\n\t\t\t\t\t\t\t      max_credit);\n\n\t\thw_atl_tps_tx_desc_rate_en_set(self, desc, en);\n\n\t\tif (en) {\n\t\t\t \n\t\t\tconst u32 rate = 10000U * scale /\n\t\t\t\t\t nic_cfg->tc_max_rate[tc];\n\t\t\tconst u32 rate_int = rate >>\n\t\t\t\t\t     HW_ATL_TPS_DESC_RATE_Y_WIDTH;\n\t\t\tconst u32 rate_frac = rate & frac_msk;\n\n\t\t\thw_atl_tps_tx_desc_rate_x_set(self, desc, rate_int);\n\t\t\thw_atl_tps_tx_desc_rate_y_set(self, desc, rate_frac);\n\t\t} else {\n\t\t\t \n\t\t\thw_atl_tps_tx_desc_rate_x_set(self, desc, 1U);\n\t\t\thw_atl_tps_tx_desc_rate_y_set(self, desc, 0U);\n\t\t}\n\t}\n\tfor (tc = nic_cfg->tcs; tc != AQ_CFG_TCS_MAX; tc++) {\n\t\tconst u32 desc = AQ_NIC_CFG_TCVEC2RING(nic_cfg, tc, 0);\n\n\t\thw_atl_tps_tx_desc_rate_en_set(self, desc, 0U);\n\t\thw_atl_tps_tx_desc_rate_x_set(self, desc, 1U);\n\t\thw_atl_tps_tx_desc_rate_y_set(self, desc, 0U);\n\t}\n\n\treturn aq_hw_err_from_flags(self);\n}\n\nstatic int hw_atl_b0_hw_init_tx_path(struct aq_hw_s *self)\n{\n\tstruct aq_nic_cfg_s *nic_cfg = self->aq_nic_cfg;\n\n\t \n\thw_atl_tpb_tps_tx_tc_mode_set(self, nic_cfg->tc_mode);\n\n\thw_atl_thm_lso_tcp_flag_of_first_pkt_set(self, 0x0FF6U);\n\thw_atl_thm_lso_tcp_flag_of_middle_pkt_set(self, 0x0FF6U);\n\thw_atl_thm_lso_tcp_flag_of_last_pkt_set(self, 0x0F7FU);\n\n\t \n\thw_atl_tdm_tx_desc_wr_wb_irq_en_set(self, 1U);\n\n\t \n\taq_hw_write_reg(self, 0x00007040U, ATL_HW_IS_CHIP_FEATURE(self, TPO2) ?\n\t\t\t0x00010000U : 0x00000000U);\n\thw_atl_tdm_tx_dca_en_set(self, 0U);\n\thw_atl_tdm_tx_dca_mode_set(self, 0U);\n\n\thw_atl_tpb_tx_path_scp_ins_en_set(self, 1U);\n\n\treturn aq_hw_err_from_flags(self);\n}\n\nvoid hw_atl_b0_hw_init_rx_rss_ctrl1(struct aq_hw_s *self)\n{\n\tstruct aq_nic_cfg_s *cfg = self->aq_nic_cfg;\n\tu32 rss_ctrl1 = HW_ATL_RSS_DISABLED;\n\n\tif (cfg->is_rss)\n\t\trss_ctrl1 = (cfg->tc_mode == AQ_TC_MODE_8TCS) ?\n\t\t\t    HW_ATL_RSS_ENABLED_8TCS_2INDEX_BITS :\n\t\t\t    HW_ATL_RSS_ENABLED_4TCS_3INDEX_BITS;\n\n\thw_atl_reg_rx_flr_rss_control1set(self, rss_ctrl1);\n}\n\nstatic int hw_atl_b0_hw_init_rx_path(struct aq_hw_s *self)\n{\n\tstruct aq_nic_cfg_s *cfg = self->aq_nic_cfg;\n\tint i;\n\n\t \n\thw_atl_rpb_rpf_rx_traf_class_mode_set(self, cfg->tc_mode);\n\n\t \n\thw_atl_rpb_rx_flow_ctl_mode_set(self, 1U);\n\n\t \n\thw_atl_b0_hw_init_rx_rss_ctrl1(self);\n\n\t \n\tfor (i = HW_ATL_B0_MAC_MAX; i--;) {\n\t\thw_atl_rpfl2_uc_flr_en_set(self, (i == 0U) ? 1U : 0U, i);\n\t\thw_atl_rpfl2unicast_flr_act_set(self, 1U, i);\n\t}\n\n\thw_atl_reg_rx_flr_mcst_flr_msk_set(self, 0x00000000U);\n\thw_atl_reg_rx_flr_mcst_flr_set(self, 0x00010FFFU, 0U);\n\n\t \n\thw_atl_rpf_vlan_outer_etht_set(self, 0x88A8U);\n\thw_atl_rpf_vlan_inner_etht_set(self, 0x8100U);\n\n\thw_atl_rpf_vlan_prom_mode_en_set(self, 1);\n\n\t\n\thw_atl_rpf_vlan_accept_untagged_packets_set(self, 1U);\n\thw_atl_rpf_vlan_untagged_act_set(self, 1U);\n\n\t \n\thw_atl_rdm_rx_desc_wr_wb_irq_en_set(self, 1U);\n\n\t \n\taq_hw_write_reg(self, 0x00005040U, ATL_HW_IS_CHIP_FEATURE(self, RPF2) ?\n\t\t\t0x000F0000U : 0x00000000U);\n\n\thw_atl_rpfl2broadcast_flr_act_set(self, 1U);\n\thw_atl_rpfl2broadcast_count_threshold_set(self, 0xFFFFU & (~0U / 256U));\n\n\thw_atl_rdm_rx_dca_en_set(self, 0U);\n\thw_atl_rdm_rx_dca_mode_set(self, 0U);\n\n\treturn aq_hw_err_from_flags(self);\n}\n\nint hw_atl_b0_hw_mac_addr_set(struct aq_hw_s *self, const u8 *mac_addr)\n{\n\tunsigned int h = 0U;\n\tunsigned int l = 0U;\n\tint err = 0;\n\n\tif (!mac_addr) {\n\t\terr = -EINVAL;\n\t\tgoto err_exit;\n\t}\n\th = (mac_addr[0] << 8) | (mac_addr[1]);\n\tl = (mac_addr[2] << 24) | (mac_addr[3] << 16) |\n\t\t(mac_addr[4] << 8) | mac_addr[5];\n\n\thw_atl_rpfl2_uc_flr_en_set(self, 0U, HW_ATL_B0_MAC);\n\thw_atl_rpfl2unicast_dest_addresslsw_set(self, l, HW_ATL_B0_MAC);\n\thw_atl_rpfl2unicast_dest_addressmsw_set(self, h, HW_ATL_B0_MAC);\n\thw_atl_rpfl2_uc_flr_en_set(self, 1U, HW_ATL_B0_MAC);\n\n\terr = aq_hw_err_from_flags(self);\n\nerr_exit:\n\treturn err;\n}\n\nstatic int hw_atl_b0_hw_init(struct aq_hw_s *self, const u8 *mac_addr)\n{\n\tstatic u32 aq_hw_atl_igcr_table_[4][2] = {\n\t\t[AQ_HW_IRQ_INVALID] = { 0x20000000U, 0x20000000U },\n\t\t[AQ_HW_IRQ_LEGACY]  = { 0x20000080U, 0x20000080U },\n\t\t[AQ_HW_IRQ_MSI]     = { 0x20000021U, 0x20000025U },\n\t\t[AQ_HW_IRQ_MSIX]    = { 0x20000022U, 0x20000026U },\n\t};\n\tstruct aq_nic_cfg_s *aq_nic_cfg = self->aq_nic_cfg;\n\tint err = 0;\n\tu32 val;\n\n\n\thw_atl_b0_hw_init_tx_path(self);\n\thw_atl_b0_hw_init_rx_path(self);\n\n\thw_atl_b0_hw_mac_addr_set(self, mac_addr);\n\n\tself->aq_fw_ops->set_link_speed(self, aq_nic_cfg->link_speed_msk);\n\tself->aq_fw_ops->set_state(self, MPI_INIT);\n\n\thw_atl_b0_hw_qos_set(self);\n\thw_atl_b0_hw_rss_set(self, &aq_nic_cfg->aq_rss);\n\thw_atl_b0_hw_rss_hash_set(self, &aq_nic_cfg->aq_rss);\n\n\t \n\tval = aq_hw_read_reg(self, HW_ATL_PCI_REG_CONTROL6_ADR);\n\taq_hw_write_reg(self, HW_ATL_PCI_REG_CONTROL6_ADR,\n\t\t\t(val & ~0x707) | 0x404);\n\n\t \n\taq_hw_write_reg(self, HW_ATL_TX_DMA_TOTAL_REQ_LIMIT_ADR, 24);\n\n\t \n\tself->aq_link_status.mbps = 0;\n\tself->aq_fw_ops->update_stats(self);\n\n\terr = aq_hw_err_from_flags(self);\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\t \n\thw_atl_reg_irq_glb_ctl_set(self,\n\t\t\t\t   aq_hw_atl_igcr_table_[aq_nic_cfg->irq_type]\n\t\t\t\t\t\t [(aq_nic_cfg->vecs > 1U) ?\n\t\t\t\t\t\t 1 : 0]);\n\n\thw_atl_itr_irq_auto_masklsw_set(self, aq_nic_cfg->aq_hw_caps->irq_mask);\n\n\t \n\thw_atl_reg_gen_irq_map_set(self,\n\t\t\t\t   ((HW_ATL_B0_ERR_INT << 0x18) |\n\t\t\t\t    (1U << 0x1F)) |\n\t\t\t\t   ((HW_ATL_B0_ERR_INT << 0x10) |\n\t\t\t\t    (1U << 0x17)), 0U);\n\n\t \n\tif (aq_nic_cfg->link_irq_vec)\n\t\thw_atl_reg_gen_irq_map_set(self, BIT(7) |\n\t\t\t\t\t   aq_nic_cfg->link_irq_vec, 3U);\n\n\thw_atl_b0_hw_offload_set(self, aq_nic_cfg);\n\nerr_exit:\n\treturn err;\n}\n\nint hw_atl_b0_hw_ring_tx_start(struct aq_hw_s *self, struct aq_ring_s *ring)\n{\n\thw_atl_tdm_tx_desc_en_set(self, 1, ring->idx);\n\n\treturn aq_hw_err_from_flags(self);\n}\n\nint hw_atl_b0_hw_ring_rx_start(struct aq_hw_s *self, struct aq_ring_s *ring)\n{\n\thw_atl_rdm_rx_desc_en_set(self, 1, ring->idx);\n\n\treturn aq_hw_err_from_flags(self);\n}\n\nint hw_atl_b0_hw_start(struct aq_hw_s *self)\n{\n\thw_atl_tpb_tx_buff_en_set(self, 1);\n\thw_atl_rpb_rx_buff_en_set(self, 1);\n\n\treturn aq_hw_err_from_flags(self);\n}\n\nstatic int hw_atl_b0_hw_tx_ring_tail_update(struct aq_hw_s *self,\n\t\t\t\t\t    struct aq_ring_s *ring)\n{\n\thw_atl_reg_tx_dma_desc_tail_ptr_set(self, ring->sw_tail, ring->idx);\n\n\treturn 0;\n}\n\nint hw_atl_b0_hw_ring_tx_xmit(struct aq_hw_s *self, struct aq_ring_s *ring,\n\t\t\t      unsigned int frags)\n{\n\tstruct aq_ring_buff_s *buff = NULL;\n\tstruct hw_atl_txd_s *txd = NULL;\n\tunsigned int buff_pa_len = 0U;\n\tunsigned int frag_count = 0U;\n\tunsigned int pkt_len = 0U;\n\tbool is_vlan = false;\n\tbool is_gso = false;\n\n\tbuff = &ring->buff_ring[ring->sw_tail];\n\tpkt_len = (buff->is_eop && buff->is_sop) ? buff->len : buff->len_pkt;\n\n\tfor (frag_count = 0; frag_count < frags; frag_count++) {\n\t\ttxd = (struct hw_atl_txd_s *)&ring->dx_ring[ring->sw_tail *\n\t\t\t\t\t\tHW_ATL_B0_TXD_SIZE];\n\t\ttxd->ctl = 0;\n\t\ttxd->ctl2 = 0;\n\t\ttxd->buf_addr = 0;\n\n\t\tbuff = &ring->buff_ring[ring->sw_tail];\n\n\t\tif (buff->is_gso_tcp || buff->is_gso_udp) {\n\t\t\tif (buff->is_gso_tcp)\n\t\t\t\ttxd->ctl |= HW_ATL_B0_TXD_CTL_CMD_TCP;\n\t\t\ttxd->ctl |= HW_ATL_B0_TXD_CTL_DESC_TYPE_TXC;\n\t\t\ttxd->ctl |= (buff->len_l3 << 31) |\n\t\t\t\t    (buff->len_l2 << 24);\n\t\t\ttxd->ctl2 |= (buff->mss << 16);\n\t\t\tis_gso = true;\n\n\t\t\tpkt_len -= (buff->len_l4 +\n\t\t\t\t    buff->len_l3 +\n\t\t\t\t    buff->len_l2);\n\t\t\tif (buff->is_ipv6)\n\t\t\t\ttxd->ctl |= HW_ATL_B0_TXD_CTL_CMD_IPV6;\n\t\t\ttxd->ctl2 |= (buff->len_l4 << 8) |\n\t\t\t\t     (buff->len_l3 >> 1);\n\t\t}\n\t\tif (buff->is_vlan) {\n\t\t\ttxd->ctl |= HW_ATL_B0_TXD_CTL_DESC_TYPE_TXC;\n\t\t\ttxd->ctl |= buff->vlan_tx_tag << 4;\n\t\t\tis_vlan = true;\n\t\t}\n\t\tif (!buff->is_gso_tcp && !buff->is_gso_udp && !buff->is_vlan) {\n\t\t\tbuff_pa_len = buff->len;\n\n\t\t\ttxd->buf_addr = buff->pa;\n\t\t\ttxd->ctl |= (HW_ATL_B0_TXD_CTL_BLEN &\n\t\t\t\t\t\t((u32)buff_pa_len << 4));\n\t\t\ttxd->ctl |= HW_ATL_B0_TXD_CTL_DESC_TYPE_TXD;\n\n\t\t\t \n\t\t\ttxd->ctl2 |= HW_ATL_B0_TXD_CTL2_LEN & (pkt_len << 14);\n\n\t\t\tif (is_gso || is_vlan) {\n\t\t\t\t \n\t\t\t\ttxd->ctl2 |= HW_ATL_B0_TXD_CTL2_CTX_EN;\n\t\t\t}\n\t\t\tif (is_gso)\n\t\t\t\ttxd->ctl |= HW_ATL_B0_TXD_CTL_CMD_LSO;\n\n\t\t\t \n\t\t\tif (buff->is_ip_cso)\n\t\t\t\ttxd->ctl |= HW_ATL_B0_TXD_CTL_CMD_IPCSO;\n\n\t\t\tif (buff->is_udp_cso || buff->is_tcp_cso)\n\t\t\t\ttxd->ctl |= HW_ATL_B0_TXD_CTL_CMD_TUCSO;\n\n\t\t\tif (is_vlan)\n\t\t\t\ttxd->ctl |= HW_ATL_B0_TXD_CTL_CMD_VLAN;\n\n\t\t\tif (unlikely(buff->is_eop)) {\n\t\t\t\ttxd->ctl |= HW_ATL_B0_TXD_CTL_EOP;\n\t\t\t\ttxd->ctl |= HW_ATL_B0_TXD_CTL_CMD_WB;\n\t\t\t\tis_gso = false;\n\t\t\t\tis_vlan = false;\n\t\t\t}\n\t\t}\n\t\tring->sw_tail = aq_ring_next_dx(ring, ring->sw_tail);\n\t}\n\n\thw_atl_b0_hw_tx_ring_tail_update(self, ring);\n\n\treturn aq_hw_err_from_flags(self);\n}\n\nint hw_atl_b0_hw_ring_rx_init(struct aq_hw_s *self, struct aq_ring_s *aq_ring,\n\t\t\t      struct aq_ring_param_s *aq_ring_param)\n{\n\tu32 dma_desc_addr_msw = (u32)(((u64)aq_ring->dx_ring_pa) >> 32);\n\tu32 vlan_rx_stripping = self->aq_nic_cfg->is_vlan_rx_strip;\n\tu32 dma_desc_addr_lsw = (u32)aq_ring->dx_ring_pa;\n\n\thw_atl_rdm_rx_desc_en_set(self, false, aq_ring->idx);\n\n\thw_atl_rdm_rx_desc_head_splitting_set(self, 0U, aq_ring->idx);\n\n\thw_atl_reg_rx_dma_desc_base_addresslswset(self, dma_desc_addr_lsw,\n\t\t\t\t\t\t  aq_ring->idx);\n\n\thw_atl_reg_rx_dma_desc_base_addressmswset(self,\n\t\t\t\t\t\t  dma_desc_addr_msw, aq_ring->idx);\n\n\thw_atl_rdm_rx_desc_len_set(self, aq_ring->size / 8U, aq_ring->idx);\n\n\thw_atl_rdm_rx_desc_data_buff_size_set(self,\n\t\t\t\t\t      aq_ring->frame_max / 1024U,\n\t\t\t\t       aq_ring->idx);\n\n\thw_atl_rdm_rx_desc_head_buff_size_set(self, 0U, aq_ring->idx);\n\thw_atl_rdm_rx_desc_head_splitting_set(self, 0U, aq_ring->idx);\n\thw_atl_rpo_rx_desc_vlan_stripping_set(self, !!vlan_rx_stripping,\n\t\t\t\t\t      aq_ring->idx);\n\n\t \n\n\t \n\thw_atl_itr_irq_map_rx_set(self, aq_ring_param->vec_idx, aq_ring->idx);\n\thw_atl_itr_irq_map_en_rx_set(self, true, aq_ring->idx);\n\n\thw_atl_rdm_cpu_id_set(self, aq_ring_param->cpu, aq_ring->idx);\n\thw_atl_rdm_rx_desc_dca_en_set(self, 0U, aq_ring->idx);\n\thw_atl_rdm_rx_head_dca_en_set(self, 0U, aq_ring->idx);\n\thw_atl_rdm_rx_pld_dca_en_set(self, 0U, aq_ring->idx);\n\n\treturn aq_hw_err_from_flags(self);\n}\n\nint hw_atl_b0_hw_ring_tx_init(struct aq_hw_s *self, struct aq_ring_s *aq_ring,\n\t\t\t      struct aq_ring_param_s *aq_ring_param)\n{\n\tu32 dma_desc_msw_addr = (u32)(((u64)aq_ring->dx_ring_pa) >> 32);\n\tu32 dma_desc_lsw_addr = (u32)aq_ring->dx_ring_pa;\n\n\thw_atl_reg_tx_dma_desc_base_addresslswset(self, dma_desc_lsw_addr,\n\t\t\t\t\t\t  aq_ring->idx);\n\n\thw_atl_reg_tx_dma_desc_base_addressmswset(self, dma_desc_msw_addr,\n\t\t\t\t\t\t  aq_ring->idx);\n\n\thw_atl_tdm_tx_desc_len_set(self, aq_ring->size / 8U, aq_ring->idx);\n\n\thw_atl_b0_hw_tx_ring_tail_update(self, aq_ring);\n\n\t \n\thw_atl_tdm_tx_desc_wr_wb_threshold_set(self, 0U, aq_ring->idx);\n\n\t \n\thw_atl_itr_irq_map_tx_set(self, aq_ring_param->vec_idx, aq_ring->idx);\n\thw_atl_itr_irq_map_en_tx_set(self, true, aq_ring->idx);\n\n\thw_atl_tdm_cpu_id_set(self, aq_ring_param->cpu, aq_ring->idx);\n\thw_atl_tdm_tx_desc_dca_en_set(self, 0U, aq_ring->idx);\n\n\treturn aq_hw_err_from_flags(self);\n}\n\nint hw_atl_b0_hw_ring_rx_fill(struct aq_hw_s *self, struct aq_ring_s *ring,\n\t\t\t      unsigned int sw_tail_old)\n{\n\tfor (; sw_tail_old != ring->sw_tail;\n\t\tsw_tail_old = aq_ring_next_dx(ring, sw_tail_old)) {\n\t\tstruct hw_atl_rxd_s *rxd =\n\t\t\t(struct hw_atl_rxd_s *)&ring->dx_ring[sw_tail_old *\n\t\t\t\t\t\t\tHW_ATL_B0_RXD_SIZE];\n\n\t\tstruct aq_ring_buff_s *buff = &ring->buff_ring[sw_tail_old];\n\n\t\trxd->buf_addr = buff->pa;\n\t\trxd->hdr_addr = 0U;\n\t}\n\n\thw_atl_reg_rx_dma_desc_tail_ptr_set(self, sw_tail_old, ring->idx);\n\n\treturn aq_hw_err_from_flags(self);\n}\n\nstatic int hw_atl_b0_hw_ring_hwts_rx_fill(struct aq_hw_s *self,\n\t\t\t\t\t  struct aq_ring_s *ring)\n{\n\tunsigned int i;\n\n\tfor (i = aq_ring_avail_dx(ring); i--;\n\t\t\tring->sw_tail = aq_ring_next_dx(ring, ring->sw_tail)) {\n\t\tstruct hw_atl_rxd_s *rxd =\n\t\t\t(struct hw_atl_rxd_s *)\n\t\t\t&ring->dx_ring[ring->sw_tail * HW_ATL_B0_RXD_SIZE];\n\n\t\trxd->buf_addr = ring->dx_ring_pa + ring->size * ring->dx_size;\n\t\trxd->hdr_addr = 0U;\n\t}\n\t \n\twmb();\n\n\thw_atl_reg_rx_dma_desc_tail_ptr_set(self, ring->sw_tail, ring->idx);\n\n\treturn aq_hw_err_from_flags(self);\n}\n\nstatic int hw_atl_b0_hw_ring_hwts_rx_receive(struct aq_hw_s *self,\n\t\t\t\t\t     struct aq_ring_s *ring)\n{\n\twhile (ring->hw_head != ring->sw_tail) {\n\t\tstruct hw_atl_rxd_hwts_wb_s *hwts_wb =\n\t\t\t(struct hw_atl_rxd_hwts_wb_s *)\n\t\t\t(ring->dx_ring + (ring->hw_head * HW_ATL_B0_RXD_SIZE));\n\n\t\t \n\t\tif (!(hwts_wb->sec_lw0 & 0x1U))\n\t\t\tbreak;\n\n\t\tring->hw_head = aq_ring_next_dx(ring, ring->hw_head);\n\t}\n\n\treturn aq_hw_err_from_flags(self);\n}\n\nint hw_atl_b0_hw_ring_tx_head_update(struct aq_hw_s *self,\n\t\t\t\t     struct aq_ring_s *ring)\n{\n\tunsigned int hw_head_;\n\tint err = 0;\n\n\thw_head_ = hw_atl_tdm_tx_desc_head_ptr_get(self, ring->idx);\n\n\tif (aq_utils_obj_test(&self->flags, AQ_HW_FLAG_ERR_UNPLUG)) {\n\t\terr = -ENXIO;\n\t\tgoto err_exit;\n\t}\n\n\t \n\tif (hw_head_ >= ring->size) {\n\t\terr = -ENXIO;\n\t\tgoto err_exit;\n\t}\n\n\tring->hw_head = hw_head_;\n\terr = aq_hw_err_from_flags(self);\n\nerr_exit:\n\treturn err;\n}\n\nint hw_atl_b0_hw_ring_rx_receive(struct aq_hw_s *self, struct aq_ring_s *ring)\n{\n\tfor (; ring->hw_head != ring->sw_tail;\n\t\tring->hw_head = aq_ring_next_dx(ring, ring->hw_head)) {\n\t\tstruct aq_ring_buff_s *buff = NULL;\n\t\tstruct hw_atl_rxd_wb_s *rxd_wb = (struct hw_atl_rxd_wb_s *)\n\t\t\t&ring->dx_ring[ring->hw_head * HW_ATL_B0_RXD_SIZE];\n\n\t\tunsigned int is_rx_check_sum_enabled = 0U;\n\t\tunsigned int pkt_type = 0U;\n\t\tu8 rx_stat = 0U;\n\n\t\tif (!(rxd_wb->status & 0x1U)) {  \n\t\t\tbreak;\n\t\t}\n\n\t\tbuff = &ring->buff_ring[ring->hw_head];\n\n\t\tbuff->flags = 0U;\n\t\tbuff->is_hash_l4 = 0U;\n\n\t\trx_stat = (0x0000003CU & rxd_wb->status) >> 2;\n\n\t\tis_rx_check_sum_enabled = (rxd_wb->type >> 19) & 0x3U;\n\n\t\tpkt_type = (rxd_wb->type & HW_ATL_B0_RXD_WB_STAT_PKTTYPE) >>\n\t\t\t   HW_ATL_B0_RXD_WB_STAT_PKTTYPE_SHIFT;\n\n\t\tif (is_rx_check_sum_enabled & BIT(0) &&\n\t\t    (0x0U == (pkt_type & 0x3U)))\n\t\t\tbuff->is_ip_cso = (rx_stat & BIT(1)) ? 0U : 1U;\n\n\t\tif (is_rx_check_sum_enabled & BIT(1)) {\n\t\t\tif (0x4U == (pkt_type & 0x1CU))\n\t\t\t\tbuff->is_udp_cso = (rx_stat & BIT(2)) ? 0U :\n\t\t\t\t\t\t   !!(rx_stat & BIT(3));\n\t\t\telse if (0x0U == (pkt_type & 0x1CU))\n\t\t\t\tbuff->is_tcp_cso = (rx_stat & BIT(2)) ? 0U :\n\t\t\t\t\t\t   !!(rx_stat & BIT(3));\n\t\t}\n\t\tbuff->is_cso_err = !!(rx_stat & 0x6);\n\t\t \n\t\tif (unlikely(rxd_wb->pkt_len <= 60)) {\n\t\t\tbuff->is_ip_cso = 0U;\n\t\t\tbuff->is_cso_err = 0U;\n\t\t}\n\n\t\tif (self->aq_nic_cfg->is_vlan_rx_strip &&\n\t\t    ((pkt_type & HW_ATL_B0_RXD_WB_PKTTYPE_VLAN) ||\n\t\t     (pkt_type & HW_ATL_B0_RXD_WB_PKTTYPE_VLAN_DOUBLE))) {\n\t\t\tbuff->is_vlan = 1;\n\t\t\tbuff->vlan_rx_tag = le16_to_cpu(rxd_wb->vlan);\n\t\t}\n\n\t\tif ((rx_stat & BIT(0)) || rxd_wb->type & 0x1000U) {\n\t\t\t \n\t\t\tbuff->is_error = 1U;\n\t\t}\n\t\tif (self->aq_nic_cfg->is_rss) {\n\t\t\t \n\t\t\tu16 rss_type = rxd_wb->type & 0xFU;\n\n\t\t\tif (rss_type && rss_type < 0x8U) {\n\t\t\t\tbuff->is_hash_l4 = (rss_type == 0x4 ||\n\t\t\t\trss_type == 0x5);\n\t\t\t\tbuff->rss_hash = rxd_wb->rss_hash;\n\t\t\t}\n\t\t}\n\n\t\tbuff->is_lro = !!(HW_ATL_B0_RXD_WB_STAT2_RSCCNT &\n\t\t\t\t  rxd_wb->status);\n\t\tif (HW_ATL_B0_RXD_WB_STAT2_EOP & rxd_wb->status) {\n\t\t\tbuff->len = rxd_wb->pkt_len %\n\t\t\t\tring->frame_max;\n\t\t\tbuff->len = buff->len ?\n\t\t\t\tbuff->len : ring->frame_max;\n\t\t\tbuff->next = 0U;\n\t\t\tbuff->is_eop = 1U;\n\t\t} else {\n\t\t\tbuff->len =\n\t\t\t\trxd_wb->pkt_len > ring->frame_max ?\n\t\t\t\tring->frame_max : rxd_wb->pkt_len;\n\n\t\t\tif (buff->is_lro) {\n\t\t\t\t \n\t\t\t\tbuff->next = rxd_wb->next_desc_ptr;\n\t\t\t\t++ring->stats.rx.lro_packets;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tbuff->next =\n\t\t\t\t\taq_ring_next_dx(ring,\n\t\t\t\t\t\t\tring->hw_head);\n\t\t\t\t++ring->stats.rx.jumbo_packets;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn aq_hw_err_from_flags(self);\n}\n\nint hw_atl_b0_hw_irq_enable(struct aq_hw_s *self, u64 mask)\n{\n\thw_atl_itr_irq_msk_setlsw_set(self, LODWORD(mask));\n\n\treturn aq_hw_err_from_flags(self);\n}\n\nint hw_atl_b0_hw_irq_disable(struct aq_hw_s *self, u64 mask)\n{\n\thw_atl_itr_irq_msk_clearlsw_set(self, LODWORD(mask));\n\thw_atl_itr_irq_status_clearlsw_set(self, LODWORD(mask));\n\n\tatomic_inc(&self->dpc);\n\n\treturn aq_hw_err_from_flags(self);\n}\n\nint hw_atl_b0_hw_irq_read(struct aq_hw_s *self, u64 *mask)\n{\n\t*mask = hw_atl_itr_irq_statuslsw_get(self);\n\n\treturn aq_hw_err_from_flags(self);\n}\n\n#define IS_FILTER_ENABLED(_F_) ((packet_filter & (_F_)) ? 1U : 0U)\n\nint hw_atl_b0_hw_packet_filter_set(struct aq_hw_s *self,\n\t\t\t\t   unsigned int packet_filter)\n{\n\tstruct aq_nic_cfg_s *cfg = self->aq_nic_cfg;\n\tunsigned int i = 0U;\n\tu32 vlan_promisc;\n\tu32 l2_promisc;\n\n\tl2_promisc = IS_FILTER_ENABLED(IFF_PROMISC) ||\n\t\t     !!(cfg->priv_flags & BIT(AQ_HW_LOOPBACK_DMA_NET));\n\tvlan_promisc = l2_promisc || cfg->is_vlan_force_promisc;\n\n\thw_atl_rpfl2promiscuous_mode_en_set(self, l2_promisc);\n\n\thw_atl_rpf_vlan_prom_mode_en_set(self, vlan_promisc);\n\n\thw_atl_rpfl2multicast_flr_en_set(self,\n\t\t\t\t\t IS_FILTER_ENABLED(IFF_ALLMULTI) &&\n\t\t\t\t\t IS_FILTER_ENABLED(IFF_MULTICAST), 0);\n\n\thw_atl_rpfl2_accept_all_mc_packets_set(self,\n\t\t\t\t\t      IS_FILTER_ENABLED(IFF_ALLMULTI) &&\n\t\t\t\t\t      IS_FILTER_ENABLED(IFF_MULTICAST));\n\n\thw_atl_rpfl2broadcast_en_set(self, IS_FILTER_ENABLED(IFF_BROADCAST));\n\n\n\tfor (i = HW_ATL_B0_MAC_MIN; i < HW_ATL_B0_MAC_MAX; ++i)\n\t\thw_atl_rpfl2_uc_flr_en_set(self,\n\t\t\t\t\t   (cfg->is_mc_list_enabled &&\n\t\t\t\t\t    (i <= cfg->mc_list_count)) ?\n\t\t\t\t\t   1U : 0U, i);\n\n\treturn aq_hw_err_from_flags(self);\n}\n\n#undef IS_FILTER_ENABLED\n\nstatic int hw_atl_b0_hw_multicast_list_set(struct aq_hw_s *self,\n\t\t\t\t\t   u8 ar_mac\n\t\t\t\t\t   [AQ_HW_MULTICAST_ADDRESS_MAX]\n\t\t\t\t\t   [ETH_ALEN],\n\t\t\t\t\t   u32 count)\n{\n\tint err = 0;\n\tstruct aq_nic_cfg_s *cfg = self->aq_nic_cfg;\n\n\tif (count > (HW_ATL_B0_MAC_MAX - HW_ATL_B0_MAC_MIN)) {\n\t\terr = -EBADRQC;\n\t\tgoto err_exit;\n\t}\n\tfor (cfg->mc_list_count = 0U;\n\t\t\tcfg->mc_list_count < count;\n\t\t\t++cfg->mc_list_count) {\n\t\tu32 i = cfg->mc_list_count;\n\t\tu32 h = (ar_mac[i][0] << 8) | (ar_mac[i][1]);\n\t\tu32 l = (ar_mac[i][2] << 24) | (ar_mac[i][3] << 16) |\n\t\t\t\t\t(ar_mac[i][4] << 8) | ar_mac[i][5];\n\n\t\thw_atl_rpfl2_uc_flr_en_set(self, 0U, HW_ATL_B0_MAC_MIN + i);\n\n\t\thw_atl_rpfl2unicast_dest_addresslsw_set(self, l,\n\t\t\t\t\t\t\tHW_ATL_B0_MAC_MIN + i);\n\n\t\thw_atl_rpfl2unicast_dest_addressmsw_set(self, h,\n\t\t\t\t\t\t\tHW_ATL_B0_MAC_MIN + i);\n\n\t\thw_atl_rpfl2_uc_flr_en_set(self,\n\t\t\t\t\t   (cfg->is_mc_list_enabled),\n\t\t\t\t\t   HW_ATL_B0_MAC_MIN + i);\n\t}\n\n\terr = aq_hw_err_from_flags(self);\n\nerr_exit:\n\treturn err;\n}\n\nstatic int hw_atl_b0_hw_interrupt_moderation_set(struct aq_hw_s *self)\n{\n\tunsigned int i = 0U;\n\tu32 itr_tx = 2U;\n\tu32 itr_rx = 2U;\n\n\tswitch (self->aq_nic_cfg->itr) {\n\tcase  AQ_CFG_INTERRUPT_MODERATION_ON:\n\tcase  AQ_CFG_INTERRUPT_MODERATION_AUTO:\n\t\thw_atl_tdm_tx_desc_wr_wb_irq_en_set(self, 0U);\n\t\thw_atl_tdm_tdm_intr_moder_en_set(self, 1U);\n\t\thw_atl_rdm_rx_desc_wr_wb_irq_en_set(self, 0U);\n\t\thw_atl_rdm_rdm_intr_moder_en_set(self, 1U);\n\n\t\tif (self->aq_nic_cfg->itr == AQ_CFG_INTERRUPT_MODERATION_ON) {\n\t\t\t \n\t\t\tint tx_max_timer = self->aq_nic_cfg->tx_itr / 2;\n\t\t\tint tx_min_timer = tx_max_timer / 2;\n\n\t\t\tint rx_max_timer = self->aq_nic_cfg->rx_itr / 2;\n\t\t\tint rx_min_timer = rx_max_timer / 2;\n\n\t\t\ttx_max_timer = min(HW_ATL_INTR_MODER_MAX, tx_max_timer);\n\t\t\ttx_min_timer = min(HW_ATL_INTR_MODER_MIN, tx_min_timer);\n\t\t\trx_max_timer = min(HW_ATL_INTR_MODER_MAX, rx_max_timer);\n\t\t\trx_min_timer = min(HW_ATL_INTR_MODER_MIN, rx_min_timer);\n\n\t\t\titr_tx |= tx_min_timer << 0x8U;\n\t\t\titr_tx |= tx_max_timer << 0x10U;\n\t\t\titr_rx |= rx_min_timer << 0x8U;\n\t\t\titr_rx |= rx_max_timer << 0x10U;\n\t\t} else {\n\t\t\tstatic unsigned int hw_atl_b0_timers_table_tx_[][2] = {\n\t\t\t\t{0xfU, 0xffU},  \n\t\t\t\t{0xfU, 0x1ffU},  \n\t\t\t\t{0xfU, 0x1ffU},  \n\t\t\t\t{0xfU, 0x1ffU},  \n\t\t\t\t{0xfU, 0x1ffU},  \n\t\t\t\t{0xfU, 0x1ffU},  \n\t\t\t};\n\n\t\t\tstatic unsigned int hw_atl_b0_timers_table_rx_[][2] = {\n\t\t\t\t{0x6U, 0x38U}, \n\t\t\t\t{0xCU, 0x70U}, \n\t\t\t\t{0xCU, 0x70U}, \n\t\t\t\t{0x18U, 0xE0U}, \n\t\t\t\t{0x30U, 0x80U}, \n\t\t\t\t{0x4U, 0x50U}, \n\t\t\t};\n\n\t\t\tunsigned int speed_index =\n\t\t\t\t\thw_atl_utils_mbps_2_speed_index(\n\t\t\t\t\t\tself->aq_link_status.mbps);\n\n\t\t\t \n\t\t\tself->aq_nic_cfg->tx_itr = hw_atl_b0_timers_table_tx_\n\t\t\t\t\t\t\t[speed_index][1] * 2;\n\t\t\tself->aq_nic_cfg->rx_itr = hw_atl_b0_timers_table_rx_\n\t\t\t\t\t\t\t[speed_index][1] * 2;\n\n\t\t\titr_tx |= hw_atl_b0_timers_table_tx_\n\t\t\t\t\t\t[speed_index][0] << 0x8U;\n\t\t\titr_tx |= hw_atl_b0_timers_table_tx_\n\t\t\t\t\t\t[speed_index][1] << 0x10U;\n\n\t\t\titr_rx |= hw_atl_b0_timers_table_rx_\n\t\t\t\t\t\t[speed_index][0] << 0x8U;\n\t\t\titr_rx |= hw_atl_b0_timers_table_rx_\n\t\t\t\t\t\t[speed_index][1] << 0x10U;\n\t\t}\n\t\tbreak;\n\tcase AQ_CFG_INTERRUPT_MODERATION_OFF:\n\t\thw_atl_tdm_tx_desc_wr_wb_irq_en_set(self, 1U);\n\t\thw_atl_tdm_tdm_intr_moder_en_set(self, 0U);\n\t\thw_atl_rdm_rx_desc_wr_wb_irq_en_set(self, 1U);\n\t\thw_atl_rdm_rdm_intr_moder_en_set(self, 0U);\n\t\titr_tx = 0U;\n\t\titr_rx = 0U;\n\t\tbreak;\n\t}\n\n\tfor (i = HW_ATL_B0_RINGS_MAX; i--;) {\n\t\thw_atl_reg_tx_intr_moder_ctrl_set(self, itr_tx, i);\n\t\thw_atl_reg_rx_intr_moder_ctrl_set(self, itr_rx, i);\n\t}\n\n\treturn aq_hw_err_from_flags(self);\n}\n\nstatic int hw_atl_b0_hw_stop(struct aq_hw_s *self)\n{\n\tint err;\n\tu32 val;\n\n\thw_atl_b0_hw_irq_disable(self, HW_ATL_B0_INT_MASK);\n\n\t \n\thw_atl_rdm_rx_dma_desc_cache_init_tgl(self);\n\n\terr = aq_hw_err_from_flags(self);\n\n\tif (err)\n\t\tgoto err_exit;\n\n\treadx_poll_timeout_atomic(hw_atl_rdm_rx_dma_desc_cache_init_done_get,\n\t\t\t\t  self, val, val == 1, 1000U, 10000U);\n\nerr_exit:\n\treturn err;\n}\n\nint hw_atl_b0_hw_ring_tx_stop(struct aq_hw_s *self, struct aq_ring_s *ring)\n{\n\thw_atl_tdm_tx_desc_en_set(self, 0U, ring->idx);\n\n\treturn aq_hw_err_from_flags(self);\n}\n\nint hw_atl_b0_hw_ring_rx_stop(struct aq_hw_s *self, struct aq_ring_s *ring)\n{\n\thw_atl_rdm_rx_desc_en_set(self, 0U, ring->idx);\n\n\treturn aq_hw_err_from_flags(self);\n}\n\n#define get_ptp_ts_val_u64(self, indx) \\\n\t((u64)(hw_atl_pcs_ptp_clock_get(self, indx) & 0xffff))\n\nstatic void hw_atl_b0_get_ptp_ts(struct aq_hw_s *self, u64 *stamp)\n{\n\tu64 ns;\n\n\thw_atl_pcs_ptp_clock_read_enable(self, 1);\n\thw_atl_pcs_ptp_clock_read_enable(self, 0);\n\tns = (get_ptp_ts_val_u64(self, 0) +\n\t      (get_ptp_ts_val_u64(self, 1) << 16)) * NSEC_PER_SEC +\n\t     (get_ptp_ts_val_u64(self, 3) +\n\t      (get_ptp_ts_val_u64(self, 4) << 16));\n\n\t*stamp = ns + self->ptp_clk_offset;\n}\n\nstatic void hw_atl_b0_adj_params_get(u64 freq, s64 adj, u32 *ns, u32 *fns)\n{\n\t \n\ts64 base_ns = ((adj + NSEC_PER_SEC) * NSEC_PER_SEC);\n\tu64 nsi_frac = 0;\n\tu64 nsi;\n\n\tbase_ns = div64_s64(base_ns, freq);\n\tnsi = div64_u64(base_ns, NSEC_PER_SEC);\n\n\tif (base_ns != nsi * NSEC_PER_SEC) {\n\t\ts64 divisor = div64_s64((s64)NSEC_PER_SEC * NSEC_PER_SEC,\n\t\t\t\t\tbase_ns - nsi * NSEC_PER_SEC);\n\t\tnsi_frac = div64_s64(AQ_FRAC_PER_NS * NSEC_PER_SEC, divisor);\n\t}\n\n\t*ns = (u32)nsi;\n\t*fns = (u32)nsi_frac;\n}\n\nstatic void\nhw_atl_b0_mac_adj_param_calc(struct hw_fw_request_ptp_adj_freq *ptp_adj_freq,\n\t\t\t     u64 phyfreq, u64 macfreq)\n{\n\ts64 adj_fns_val;\n\ts64 fns_in_sec_phy = phyfreq * (ptp_adj_freq->fns_phy +\n\t\t\t\t\tAQ_FRAC_PER_NS * ptp_adj_freq->ns_phy);\n\ts64 fns_in_sec_mac = macfreq * (ptp_adj_freq->fns_mac +\n\t\t\t\t\tAQ_FRAC_PER_NS * ptp_adj_freq->ns_mac);\n\ts64 fault_in_sec_phy = AQ_FRAC_PER_NS * NSEC_PER_SEC - fns_in_sec_phy;\n\ts64 fault_in_sec_mac = AQ_FRAC_PER_NS * NSEC_PER_SEC - fns_in_sec_mac;\n\t \n\ts64 diff_in_mcp_overflow = (fault_in_sec_mac - fault_in_sec_phy) *\n\t\t\t\t   4 * AQ_FRAC_PER_NS;\n\n\tdiff_in_mcp_overflow = div64_s64(diff_in_mcp_overflow,\n\t\t\t\t\t AQ_HW_MAC_COUNTER_HZ);\n\tadj_fns_val = (ptp_adj_freq->fns_mac + AQ_FRAC_PER_NS *\n\t\t       ptp_adj_freq->ns_mac) + diff_in_mcp_overflow;\n\n\tptp_adj_freq->mac_ns_adj = div64_s64(adj_fns_val, AQ_FRAC_PER_NS);\n\tptp_adj_freq->mac_fns_adj = adj_fns_val - ptp_adj_freq->mac_ns_adj *\n\t\t\t\t    AQ_FRAC_PER_NS;\n}\n\nstatic int hw_atl_b0_adj_sys_clock(struct aq_hw_s *self, s64 delta)\n{\n\tself->ptp_clk_offset += delta;\n\n\tself->aq_fw_ops->adjust_ptp(self, self->ptp_clk_offset);\n\n\treturn 0;\n}\n\nstatic int hw_atl_b0_set_sys_clock(struct aq_hw_s *self, u64 time, u64 ts)\n{\n\ts64 delta = time - (self->ptp_clk_offset + ts);\n\n\treturn hw_atl_b0_adj_sys_clock(self, delta);\n}\n\nstatic int hw_atl_b0_ts_to_sys_clock(struct aq_hw_s *self, u64 ts, u64 *time)\n{\n\t*time = self->ptp_clk_offset + ts;\n\treturn 0;\n}\n\nstatic int hw_atl_b0_adj_clock_freq(struct aq_hw_s *self, s32 ppb)\n{\n\tstruct hw_fw_request_iface fwreq;\n\tsize_t size;\n\n\tmemset(&fwreq, 0, sizeof(fwreq));\n\n\tfwreq.msg_id = HW_AQ_FW_REQUEST_PTP_ADJ_FREQ;\n\thw_atl_b0_adj_params_get(AQ_HW_MAC_COUNTER_HZ, ppb,\n\t\t\t\t &fwreq.ptp_adj_freq.ns_mac,\n\t\t\t\t &fwreq.ptp_adj_freq.fns_mac);\n\thw_atl_b0_adj_params_get(AQ_HW_PHY_COUNTER_HZ, ppb,\n\t\t\t\t &fwreq.ptp_adj_freq.ns_phy,\n\t\t\t\t &fwreq.ptp_adj_freq.fns_phy);\n\thw_atl_b0_mac_adj_param_calc(&fwreq.ptp_adj_freq,\n\t\t\t\t     AQ_HW_PHY_COUNTER_HZ,\n\t\t\t\t     AQ_HW_MAC_COUNTER_HZ);\n\n\tsize = sizeof(fwreq.msg_id) + sizeof(fwreq.ptp_adj_freq);\n\treturn self->aq_fw_ops->send_fw_request(self, &fwreq, size);\n}\n\nstatic int hw_atl_b0_gpio_pulse(struct aq_hw_s *self, u32 index,\n\t\t\t\tu64 start, u32 period)\n{\n\tstruct hw_fw_request_iface fwreq;\n\tsize_t size;\n\n\tmemset(&fwreq, 0, sizeof(fwreq));\n\n\tfwreq.msg_id = HW_AQ_FW_REQUEST_PTP_GPIO_CTRL;\n\tfwreq.ptp_gpio_ctrl.index = index;\n\tfwreq.ptp_gpio_ctrl.period = period;\n\t \n\tfwreq.ptp_gpio_ctrl.start = start;\n\n\tsize = sizeof(fwreq.msg_id) + sizeof(fwreq.ptp_gpio_ctrl);\n\treturn self->aq_fw_ops->send_fw_request(self, &fwreq, size);\n}\n\nstatic int hw_atl_b0_extts_gpio_enable(struct aq_hw_s *self, u32 index,\n\t\t\t\t       u32 enable)\n{\n\t \n\taq_phy_write_reg(self, MDIO_MMD_PCS, 0xc611, enable ? 0x71 : 0);\n\n\treturn 0;\n}\n\nstatic int hw_atl_b0_get_sync_ts(struct aq_hw_s *self, u64 *ts)\n{\n\tu64 sec_l;\n\tu64 sec_h;\n\tu64 nsec_l;\n\tu64 nsec_h;\n\n\tif (!ts)\n\t\treturn -1;\n\n\t \n\tsec_l = aq_phy_read_reg(self, MDIO_MMD_PCS, 0xc914);\n\t \n\tsec_h = aq_phy_read_reg(self, MDIO_MMD_PCS, 0xc915);\n\t \n\tnsec_l = aq_phy_read_reg(self, MDIO_MMD_PCS, 0xc916);\n\t \n\tnsec_h = aq_phy_read_reg(self, MDIO_MMD_PCS, 0xc917);\n\n\t*ts = (nsec_h << 16) + nsec_l + ((sec_h << 16) + sec_l) * NSEC_PER_SEC;\n\n\treturn 0;\n}\n\nstatic u16 hw_atl_b0_rx_extract_ts(struct aq_hw_s *self, u8 *p,\n\t\t\t\t   unsigned int len, u64 *timestamp)\n{\n\tunsigned int offset = 14;\n\tstruct ethhdr *eth;\n\t__be64 sec;\n\t__be32 ns;\n\tu8 *ptr;\n\n\tif (len <= offset || !timestamp)\n\t\treturn 0;\n\n\t \n\tptr = p + (len - offset);\n\tmemcpy(&sec, ptr, sizeof(sec));\n\tptr += sizeof(sec);\n\tmemcpy(&ns, ptr, sizeof(ns));\n\n\t*timestamp = (be64_to_cpu(sec) & 0xffffffffffffllu) * NSEC_PER_SEC +\n\t\t     be32_to_cpu(ns) + self->ptp_clk_offset;\n\n\teth = (struct ethhdr *)p;\n\n\treturn (eth->h_proto == htons(ETH_P_1588)) ? 12 : 14;\n}\n\nstatic int hw_atl_b0_extract_hwts(struct aq_hw_s *self, u8 *p, unsigned int len,\n\t\t\t\t  u64 *timestamp)\n{\n\tstruct hw_atl_rxd_hwts_wb_s *hwts_wb = (struct hw_atl_rxd_hwts_wb_s *)p;\n\tu64 tmp, sec, ns;\n\n\tsec = 0;\n\ttmp = (hwts_wb->sec_lw0 >> 2) & 0x3ff;\n\tsec += tmp;\n\ttmp = (u64)((hwts_wb->sec_lw1 >> 16) & 0xffff) << 10;\n\tsec += tmp;\n\ttmp = (u64)(hwts_wb->sec_hw & 0xfff) << 26;\n\tsec += tmp;\n\ttmp = (u64)((hwts_wb->sec_hw >> 22) & 0x3ff) << 38;\n\tsec += tmp;\n\tns = sec * NSEC_PER_SEC + hwts_wb->ns;\n\tif (timestamp)\n\t\t*timestamp = ns + self->ptp_clk_offset;\n\treturn 0;\n}\n\nstatic int hw_atl_b0_hw_fl3l4_clear(struct aq_hw_s *self,\n\t\t\t\t    struct aq_rx_filter_l3l4 *data)\n{\n\tu8 location = data->location;\n\n\tif (!data->is_ipv6) {\n\t\thw_atl_rpfl3l4_cmd_clear(self, location);\n\t\thw_atl_rpf_l4_spd_set(self, 0U, location);\n\t\thw_atl_rpf_l4_dpd_set(self, 0U, location);\n\t\thw_atl_rpfl3l4_ipv4_src_addr_clear(self, location);\n\t\thw_atl_rpfl3l4_ipv4_dest_addr_clear(self, location);\n\t} else {\n\t\tint i;\n\n\t\tfor (i = 0; i < HW_ATL_RX_CNT_REG_ADDR_IPV6; ++i) {\n\t\t\thw_atl_rpfl3l4_cmd_clear(self, location + i);\n\t\t\thw_atl_rpf_l4_spd_set(self, 0U, location + i);\n\t\t\thw_atl_rpf_l4_dpd_set(self, 0U, location + i);\n\t\t}\n\t\thw_atl_rpfl3l4_ipv6_src_addr_clear(self, location);\n\t\thw_atl_rpfl3l4_ipv6_dest_addr_clear(self, location);\n\t}\n\n\treturn aq_hw_err_from_flags(self);\n}\n\nstatic int hw_atl_b0_hw_fl3l4_set(struct aq_hw_s *self,\n\t\t\t\t  struct aq_rx_filter_l3l4 *data)\n{\n\tu8 location = data->location;\n\n\thw_atl_b0_hw_fl3l4_clear(self, data);\n\n\tif (data->cmd & (HW_ATL_RX_ENABLE_CMP_DEST_ADDR_L3 |\n\t\t\t HW_ATL_RX_ENABLE_CMP_SRC_ADDR_L3)) {\n\t\tif (!data->is_ipv6) {\n\t\t\thw_atl_rpfl3l4_ipv4_dest_addr_set(self,\n\t\t\t\t\t\t\t  location,\n\t\t\t\t\t\t\t  data->ip_dst[0]);\n\t\t\thw_atl_rpfl3l4_ipv4_src_addr_set(self,\n\t\t\t\t\t\t\t location,\n\t\t\t\t\t\t\t data->ip_src[0]);\n\t\t} else {\n\t\t\thw_atl_rpfl3l4_ipv6_dest_addr_set(self,\n\t\t\t\t\t\t\t  location,\n\t\t\t\t\t\t\t  data->ip_dst);\n\t\t\thw_atl_rpfl3l4_ipv6_src_addr_set(self,\n\t\t\t\t\t\t\t location,\n\t\t\t\t\t\t\t data->ip_src);\n\t\t}\n\t}\n\n\tif (data->cmd & (HW_ATL_RX_ENABLE_CMP_DEST_PORT_L4 |\n\t\t\t HW_ATL_RX_ENABLE_CMP_SRC_PORT_L4)) {\n\t\thw_atl_rpf_l4_dpd_set(self, data->p_dst, location);\n\t\thw_atl_rpf_l4_spd_set(self, data->p_src, location);\n\t}\n\n\thw_atl_rpfl3l4_cmd_set(self, location, data->cmd);\n\n\treturn aq_hw_err_from_flags(self);\n}\n\nstatic int hw_atl_b0_hw_fl2_set(struct aq_hw_s *self,\n\t\t\t\tstruct aq_rx_filter_l2 *data)\n{\n\thw_atl_rpf_etht_flr_en_set(self, 1U, data->location);\n\thw_atl_rpf_etht_flr_set(self, data->ethertype, data->location);\n\thw_atl_rpf_etht_user_priority_en_set(self,\n\t\t\t\t\t     !!data->user_priority_en,\n\t\t\t\t\t     data->location);\n\tif (data->user_priority_en)\n\t\thw_atl_rpf_etht_user_priority_set(self,\n\t\t\t\t\t\t  data->user_priority,\n\t\t\t\t\t\t  data->location);\n\n\tif (data->queue < 0) {\n\t\thw_atl_rpf_etht_flr_act_set(self, 0U, data->location);\n\t\thw_atl_rpf_etht_rx_queue_en_set(self, 0U, data->location);\n\t} else {\n\t\thw_atl_rpf_etht_flr_act_set(self, 1U, data->location);\n\t\thw_atl_rpf_etht_rx_queue_en_set(self, 1U, data->location);\n\t\thw_atl_rpf_etht_rx_queue_set(self, data->queue, data->location);\n\t}\n\n\treturn aq_hw_err_from_flags(self);\n}\n\nstatic int hw_atl_b0_hw_fl2_clear(struct aq_hw_s *self,\n\t\t\t\t  struct aq_rx_filter_l2 *data)\n{\n\thw_atl_rpf_etht_flr_en_set(self, 0U, data->location);\n\thw_atl_rpf_etht_flr_set(self, 0U, data->location);\n\thw_atl_rpf_etht_user_priority_en_set(self, 0U, data->location);\n\n\treturn aq_hw_err_from_flags(self);\n}\n\n \nstatic int hw_atl_b0_hw_vlan_set(struct aq_hw_s *self,\n\t\t\t\t struct aq_rx_filter_vlan *aq_vlans)\n{\n\tint i;\n\n\tfor (i = 0; i < AQ_VLAN_MAX_FILTERS; i++) {\n\t\thw_atl_rpf_vlan_flr_en_set(self, 0U, i);\n\t\thw_atl_rpf_vlan_rxq_en_flr_set(self, 0U, i);\n\t\tif (aq_vlans[i].enable) {\n\t\t\thw_atl_rpf_vlan_id_flr_set(self,\n\t\t\t\t\t\t   aq_vlans[i].vlan_id,\n\t\t\t\t\t\t   i);\n\t\t\thw_atl_rpf_vlan_flr_act_set(self, 1U, i);\n\t\t\thw_atl_rpf_vlan_flr_en_set(self, 1U, i);\n\t\t\tif (aq_vlans[i].queue != 0xFF) {\n\t\t\t\thw_atl_rpf_vlan_rxq_flr_set(self,\n\t\t\t\t\t\t\t    aq_vlans[i].queue,\n\t\t\t\t\t\t\t    i);\n\t\t\t\thw_atl_rpf_vlan_rxq_en_flr_set(self, 1U, i);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn aq_hw_err_from_flags(self);\n}\n\nstatic int hw_atl_b0_hw_vlan_ctrl(struct aq_hw_s *self, bool enable)\n{\n\t \n\thw_atl_rpf_vlan_prom_mode_en_set(self, !enable);\n\n\treturn aq_hw_err_from_flags(self);\n}\n\nint hw_atl_b0_set_loopback(struct aq_hw_s *self, u32 mode, bool enable)\n{\n\tswitch (mode) {\n\tcase AQ_HW_LOOPBACK_DMA_SYS:\n\t\thw_atl_tpb_tx_dma_sys_lbk_en_set(self, enable);\n\t\thw_atl_rpb_dma_sys_lbk_set(self, enable);\n\t\tbreak;\n\tcase AQ_HW_LOOPBACK_PKT_SYS:\n\t\thw_atl_tpo_tx_pkt_sys_lbk_en_set(self, enable);\n\t\thw_atl_rpf_tpo_to_rpf_sys_lbk_set(self, enable);\n\t\tbreak;\n\tcase AQ_HW_LOOPBACK_DMA_NET:\n\t\thw_atl_rpf_vlan_prom_mode_en_set(self, enable);\n\t\thw_atl_rpfl2promiscuous_mode_en_set(self, enable);\n\t\thw_atl_tpb_tx_tx_clk_gate_en_set(self, !enable);\n\t\thw_atl_tpb_tx_dma_net_lbk_en_set(self, enable);\n\t\thw_atl_rpb_dma_net_lbk_set(self, enable);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic u32 hw_atl_b0_ts_ready_and_latch_high_get(struct aq_hw_s *self)\n{\n\tif (hw_atl_ts_ready_get(self) && hw_atl_ts_ready_latch_high_get(self))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int hw_atl_b0_get_mac_temp(struct aq_hw_s *self, u32 *temp)\n{\n\tbool ts_disabled;\n\tint err;\n\tu32 val;\n\tu32 ts;\n\n\tts_disabled = (hw_atl_ts_power_down_get(self) == 1U);\n\n\tif (ts_disabled) {\n\t\t\n\t\thw_atl_ts_power_down_set(self, 0U);\n\n\t\t\n\t\thw_atl_ts_reset_set(self, 1);\n\t\thw_atl_ts_reset_set(self, 0);\n\t}\n\n\terr = readx_poll_timeout(hw_atl_b0_ts_ready_and_latch_high_get, self,\n\t\t\t\t val, val == 1, 10000U, 500000U);\n\tif (err)\n\t\treturn err;\n\n\tts = hw_atl_ts_data_get(self);\n\t*temp = ts * ts * 16 / 100000 + 60 * ts - 83410;\n\n\tif (ts_disabled) {\n\t\t\n\t\thw_atl_ts_power_down_set(self, 1U);\n\t}\n\n\treturn 0;\n}\n\nconst struct aq_hw_ops hw_atl_ops_b0 = {\n\t.hw_soft_reset        = hw_atl_utils_soft_reset,\n\t.hw_prepare           = hw_atl_utils_initfw,\n\t.hw_set_mac_address   = hw_atl_b0_hw_mac_addr_set,\n\t.hw_init              = hw_atl_b0_hw_init,\n\t.hw_reset             = hw_atl_b0_hw_reset,\n\t.hw_start             = hw_atl_b0_hw_start,\n\t.hw_ring_tx_start     = hw_atl_b0_hw_ring_tx_start,\n\t.hw_ring_tx_stop      = hw_atl_b0_hw_ring_tx_stop,\n\t.hw_ring_rx_start     = hw_atl_b0_hw_ring_rx_start,\n\t.hw_ring_rx_stop      = hw_atl_b0_hw_ring_rx_stop,\n\t.hw_stop              = hw_atl_b0_hw_stop,\n\n\t.hw_ring_tx_xmit         = hw_atl_b0_hw_ring_tx_xmit,\n\t.hw_ring_tx_head_update  = hw_atl_b0_hw_ring_tx_head_update,\n\n\t.hw_ring_rx_receive      = hw_atl_b0_hw_ring_rx_receive,\n\t.hw_ring_rx_fill         = hw_atl_b0_hw_ring_rx_fill,\n\n\t.hw_irq_enable           = hw_atl_b0_hw_irq_enable,\n\t.hw_irq_disable          = hw_atl_b0_hw_irq_disable,\n\t.hw_irq_read             = hw_atl_b0_hw_irq_read,\n\n\t.hw_ring_rx_init             = hw_atl_b0_hw_ring_rx_init,\n\t.hw_ring_tx_init             = hw_atl_b0_hw_ring_tx_init,\n\t.hw_packet_filter_set        = hw_atl_b0_hw_packet_filter_set,\n\t.hw_filter_l2_set            = hw_atl_b0_hw_fl2_set,\n\t.hw_filter_l2_clear          = hw_atl_b0_hw_fl2_clear,\n\t.hw_filter_l3l4_set          = hw_atl_b0_hw_fl3l4_set,\n\t.hw_filter_vlan_set          = hw_atl_b0_hw_vlan_set,\n\t.hw_filter_vlan_ctrl         = hw_atl_b0_hw_vlan_ctrl,\n\t.hw_multicast_list_set       = hw_atl_b0_hw_multicast_list_set,\n\t.hw_interrupt_moderation_set = hw_atl_b0_hw_interrupt_moderation_set,\n\t.hw_rss_set                  = hw_atl_b0_hw_rss_set,\n\t.hw_rss_hash_set             = hw_atl_b0_hw_rss_hash_set,\n\t.hw_tc_rate_limit_set        = hw_atl_b0_hw_init_tx_tc_rate_limit,\n\t.hw_get_regs                 = hw_atl_utils_hw_get_regs,\n\t.hw_get_hw_stats             = hw_atl_utils_get_hw_stats,\n\t.hw_get_fw_version           = hw_atl_utils_get_fw_version,\n\n\t.hw_ring_hwts_rx_fill        = hw_atl_b0_hw_ring_hwts_rx_fill,\n\t.hw_ring_hwts_rx_receive     = hw_atl_b0_hw_ring_hwts_rx_receive,\n\n\t.hw_get_ptp_ts           = hw_atl_b0_get_ptp_ts,\n\t.hw_adj_sys_clock        = hw_atl_b0_adj_sys_clock,\n\t.hw_set_sys_clock        = hw_atl_b0_set_sys_clock,\n\t.hw_ts_to_sys_clock      = hw_atl_b0_ts_to_sys_clock,\n\t.hw_adj_clock_freq       = hw_atl_b0_adj_clock_freq,\n\t.hw_gpio_pulse           = hw_atl_b0_gpio_pulse,\n\t.hw_extts_gpio_enable    = hw_atl_b0_extts_gpio_enable,\n\t.hw_get_sync_ts          = hw_atl_b0_get_sync_ts,\n\t.rx_extract_ts           = hw_atl_b0_rx_extract_ts,\n\t.extract_hwts            = hw_atl_b0_extract_hwts,\n\t.hw_set_offload          = hw_atl_b0_hw_offload_set,\n\t.hw_set_loopback         = hw_atl_b0_set_loopback,\n\t.hw_set_fc               = hw_atl_b0_set_fc,\n\n\t.hw_get_mac_temp         = hw_atl_b0_get_mac_temp,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}