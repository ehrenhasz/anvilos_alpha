{
  "module_name": "aq_filters.c",
  "hash_id": "9c25797b7c3df4fdac0c81e1ce43b60514843d6b71e1374f78e6c8ec196e38cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/aquantia/atlantic/aq_filters.c",
  "human_readable_source": "\n \n\n \n\n#include \"aq_filters.h\"\n\nstatic bool __must_check\naq_rule_is_approve(struct ethtool_rx_flow_spec *fsp)\n{\n\tif (fsp->flow_type & FLOW_MAC_EXT)\n\t\treturn false;\n\n\tswitch (fsp->flow_type & ~FLOW_EXT) {\n\tcase ETHER_FLOW:\n\tcase TCP_V4_FLOW:\n\tcase UDP_V4_FLOW:\n\tcase SCTP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\tcase UDP_V6_FLOW:\n\tcase SCTP_V6_FLOW:\n\tcase IPV4_FLOW:\n\tcase IPV6_FLOW:\n\t\treturn true;\n\tcase IP_USER_FLOW:\n\t\tswitch (fsp->h_u.usr_ip4_spec.proto) {\n\t\tcase IPPROTO_TCP:\n\t\tcase IPPROTO_UDP:\n\t\tcase IPPROTO_SCTP:\n\t\tcase IPPROTO_IP:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t\t}\n\tcase IPV6_USER_FLOW:\n\t\tswitch (fsp->h_u.usr_ip6_spec.l4_proto) {\n\t\tcase IPPROTO_TCP:\n\t\tcase IPPROTO_UDP:\n\t\tcase IPPROTO_SCTP:\n\t\tcase IPPROTO_IP:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t\t\t}\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn false;\n}\n\nstatic bool __must_check\naq_match_filter(struct ethtool_rx_flow_spec *fsp1,\n\t\tstruct ethtool_rx_flow_spec *fsp2)\n{\n\tif (fsp1->flow_type != fsp2->flow_type ||\n\t    memcmp(&fsp1->h_u, &fsp2->h_u, sizeof(fsp2->h_u)) ||\n\t    memcmp(&fsp1->h_ext, &fsp2->h_ext, sizeof(fsp2->h_ext)) ||\n\t    memcmp(&fsp1->m_u, &fsp2->m_u, sizeof(fsp2->m_u)) ||\n\t    memcmp(&fsp1->m_ext, &fsp2->m_ext, sizeof(fsp2->m_ext)))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool __must_check\naq_rule_already_exists(struct aq_nic_s *aq_nic,\n\t\t       struct ethtool_rx_flow_spec *fsp)\n{\n\tstruct aq_rx_filter *rule;\n\tstruct hlist_node *aq_node2;\n\tstruct aq_hw_rx_fltrs_s *rx_fltrs = aq_get_hw_rx_fltrs(aq_nic);\n\n\thlist_for_each_entry_safe(rule, aq_node2,\n\t\t\t\t  &rx_fltrs->filter_list, aq_node) {\n\t\tif (rule->aq_fsp.location == fsp->location)\n\t\t\tcontinue;\n\t\tif (aq_match_filter(&rule->aq_fsp, fsp)) {\n\t\t\tnetdev_err(aq_nic->ndev,\n\t\t\t\t   \"ethtool: This filter is already set\\n\");\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int aq_check_approve_fl3l4(struct aq_nic_s *aq_nic,\n\t\t\t\t  struct aq_hw_rx_fltrs_s *rx_fltrs,\n\t\t\t\t  struct ethtool_rx_flow_spec *fsp)\n{\n\tu32 last_location = AQ_RX_LAST_LOC_FL3L4 -\n\t\t\t    aq_nic->aq_hw_rx_fltrs.fl3l4.reserved_count;\n\n\tif (fsp->location < AQ_RX_FIRST_LOC_FL3L4 ||\n\t    fsp->location > last_location) {\n\t\tnetdev_err(aq_nic->ndev,\n\t\t\t   \"ethtool: location must be in range [%d, %d]\",\n\t\t\t   AQ_RX_FIRST_LOC_FL3L4, last_location);\n\t\treturn -EINVAL;\n\t}\n\tif (rx_fltrs->fl3l4.is_ipv6 && rx_fltrs->fl3l4.active_ipv4) {\n\t\trx_fltrs->fl3l4.is_ipv6 = false;\n\t\tnetdev_err(aq_nic->ndev,\n\t\t\t   \"ethtool: mixing ipv4 and ipv6 is not allowed\");\n\t\treturn -EINVAL;\n\t} else if (!rx_fltrs->fl3l4.is_ipv6 && rx_fltrs->fl3l4.active_ipv6) {\n\t\trx_fltrs->fl3l4.is_ipv6 = true;\n\t\tnetdev_err(aq_nic->ndev,\n\t\t\t   \"ethtool: mixing ipv4 and ipv6 is not allowed\");\n\t\treturn -EINVAL;\n\t} else if (rx_fltrs->fl3l4.is_ipv6\t\t      &&\n\t\t   fsp->location != AQ_RX_FIRST_LOC_FL3L4 + 4 &&\n\t\t   fsp->location != AQ_RX_FIRST_LOC_FL3L4) {\n\t\tnetdev_err(aq_nic->ndev,\n\t\t\t   \"ethtool: The specified location for ipv6 must be %d or %d\",\n\t\t\t   AQ_RX_FIRST_LOC_FL3L4, AQ_RX_FIRST_LOC_FL3L4 + 4);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __must_check\naq_check_approve_fl2(struct aq_nic_s *aq_nic,\n\t\t     struct aq_hw_rx_fltrs_s *rx_fltrs,\n\t\t     struct ethtool_rx_flow_spec *fsp)\n{\n\tu32 last_location = AQ_RX_LAST_LOC_FETHERT -\n\t\t\t    aq_nic->aq_hw_rx_fltrs.fet_reserved_count;\n\n\tif (fsp->location < AQ_RX_FIRST_LOC_FETHERT ||\n\t    fsp->location > last_location) {\n\t\tnetdev_err(aq_nic->ndev,\n\t\t\t   \"ethtool: location must be in range [%d, %d]\",\n\t\t\t   AQ_RX_FIRST_LOC_FETHERT,\n\t\t\t   last_location);\n\t\treturn -EINVAL;\n\t}\n\n\tif (be16_to_cpu(fsp->m_ext.vlan_tci) == VLAN_PRIO_MASK &&\n\t    fsp->m_u.ether_spec.h_proto == 0U) {\n\t\tnetdev_err(aq_nic->ndev,\n\t\t\t   \"ethtool: proto (ether_type) parameter must be specified\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __must_check\naq_check_approve_fvlan(struct aq_nic_s *aq_nic,\n\t\t       struct aq_hw_rx_fltrs_s *rx_fltrs,\n\t\t       struct ethtool_rx_flow_spec *fsp)\n{\n\tstruct aq_nic_cfg_s *cfg = &aq_nic->aq_nic_cfg;\n\n\tif (fsp->location < AQ_RX_FIRST_LOC_FVLANID ||\n\t    fsp->location > AQ_RX_LAST_LOC_FVLANID) {\n\t\tnetdev_err(aq_nic->ndev,\n\t\t\t   \"ethtool: location must be in range [%d, %d]\",\n\t\t\t   AQ_RX_FIRST_LOC_FVLANID,\n\t\t\t   AQ_RX_LAST_LOC_FVLANID);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((aq_nic->ndev->features & NETIF_F_HW_VLAN_CTAG_FILTER) &&\n\t    (!test_bit(be16_to_cpu(fsp->h_ext.vlan_tci) & VLAN_VID_MASK,\n\t\t       aq_nic->active_vlans))) {\n\t\tnetdev_err(aq_nic->ndev,\n\t\t\t   \"ethtool: unknown vlan-id specified\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (fsp->ring_cookie > cfg->num_rss_queues * cfg->tcs) {\n\t\tnetdev_err(aq_nic->ndev,\n\t\t\t   \"ethtool: queue number must be in range [0, %d]\",\n\t\t\t   cfg->num_rss_queues * cfg->tcs - 1);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int __must_check\naq_check_filter(struct aq_nic_s *aq_nic,\n\t\tstruct ethtool_rx_flow_spec *fsp)\n{\n\tint err = 0;\n\tstruct aq_hw_rx_fltrs_s *rx_fltrs = aq_get_hw_rx_fltrs(aq_nic);\n\n\tif (fsp->flow_type & FLOW_EXT) {\n\t\tif (be16_to_cpu(fsp->m_ext.vlan_tci) == VLAN_VID_MASK) {\n\t\t\terr = aq_check_approve_fvlan(aq_nic, rx_fltrs, fsp);\n\t\t} else if (be16_to_cpu(fsp->m_ext.vlan_tci) == VLAN_PRIO_MASK) {\n\t\t\terr = aq_check_approve_fl2(aq_nic, rx_fltrs, fsp);\n\t\t} else {\n\t\t\tnetdev_err(aq_nic->ndev,\n\t\t\t\t   \"ethtool: invalid vlan mask 0x%x specified\",\n\t\t\t\t   be16_to_cpu(fsp->m_ext.vlan_tci));\n\t\t\terr = -EINVAL;\n\t\t}\n\t} else {\n\t\tswitch (fsp->flow_type & ~FLOW_EXT) {\n\t\tcase ETHER_FLOW:\n\t\t\terr = aq_check_approve_fl2(aq_nic, rx_fltrs, fsp);\n\t\t\tbreak;\n\t\tcase TCP_V4_FLOW:\n\t\tcase UDP_V4_FLOW:\n\t\tcase SCTP_V4_FLOW:\n\t\tcase IPV4_FLOW:\n\t\tcase IP_USER_FLOW:\n\t\t\trx_fltrs->fl3l4.is_ipv6 = false;\n\t\t\terr = aq_check_approve_fl3l4(aq_nic, rx_fltrs, fsp);\n\t\t\tbreak;\n\t\tcase TCP_V6_FLOW:\n\t\tcase UDP_V6_FLOW:\n\t\tcase SCTP_V6_FLOW:\n\t\tcase IPV6_FLOW:\n\t\tcase IPV6_USER_FLOW:\n\t\t\trx_fltrs->fl3l4.is_ipv6 = true;\n\t\t\terr = aq_check_approve_fl3l4(aq_nic, rx_fltrs, fsp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetdev_err(aq_nic->ndev,\n\t\t\t\t   \"ethtool: unknown flow-type specified\");\n\t\t\terr = -EINVAL;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic bool __must_check\naq_rule_is_not_support(struct aq_nic_s *aq_nic,\n\t\t       struct ethtool_rx_flow_spec *fsp)\n{\n\tbool rule_is_not_support = false;\n\n\tif (!(aq_nic->ndev->features & NETIF_F_NTUPLE)) {\n\t\tnetdev_err(aq_nic->ndev,\n\t\t\t   \"ethtool: Please, to enable the RX flow control:\\n\"\n\t\t\t   \"ethtool -K %s ntuple on\\n\", aq_nic->ndev->name);\n\t\trule_is_not_support = true;\n\t} else if (!aq_rule_is_approve(fsp)) {\n\t\tnetdev_err(aq_nic->ndev,\n\t\t\t   \"ethtool: The specified flow type is not supported\\n\");\n\t\trule_is_not_support = true;\n\t} else if ((fsp->flow_type & ~FLOW_EXT) != ETHER_FLOW &&\n\t\t   (fsp->h_u.tcp_ip4_spec.tos ||\n\t\t    fsp->h_u.tcp_ip6_spec.tclass)) {\n\t\tnetdev_err(aq_nic->ndev,\n\t\t\t   \"ethtool: The specified tos tclass are not supported\\n\");\n\t\trule_is_not_support = true;\n\t} else if (fsp->flow_type & FLOW_MAC_EXT) {\n\t\tnetdev_err(aq_nic->ndev,\n\t\t\t   \"ethtool: MAC_EXT is not supported\");\n\t\trule_is_not_support = true;\n\t}\n\n\treturn rule_is_not_support;\n}\n\nstatic bool __must_check\naq_rule_is_not_correct(struct aq_nic_s *aq_nic,\n\t\t       struct ethtool_rx_flow_spec *fsp)\n{\n\tstruct aq_nic_cfg_s *cfg = &aq_nic->aq_nic_cfg;\n\tbool rule_is_not_correct = false;\n\n\tif (!aq_nic) {\n\t\trule_is_not_correct = true;\n\t} else if (fsp->location > AQ_RX_MAX_RXNFC_LOC) {\n\t\tnetdev_err(aq_nic->ndev,\n\t\t\t   \"ethtool: The specified number %u rule is invalid\\n\",\n\t\t\t   fsp->location);\n\t\trule_is_not_correct = true;\n\t} else if (aq_check_filter(aq_nic, fsp)) {\n\t\trule_is_not_correct = true;\n\t} else if (fsp->ring_cookie != RX_CLS_FLOW_DISC) {\n\t\tif (fsp->ring_cookie >= cfg->num_rss_queues * cfg->tcs) {\n\t\t\tnetdev_err(aq_nic->ndev,\n\t\t\t\t   \"ethtool: The specified action is invalid.\\n\"\n\t\t\t\t   \"Maximum allowable value action is %u.\\n\",\n\t\t\t\t   cfg->num_rss_queues * cfg->tcs - 1);\n\t\t\trule_is_not_correct = true;\n\t\t}\n\t}\n\n\treturn rule_is_not_correct;\n}\n\nstatic int __must_check\naq_check_rule(struct aq_nic_s *aq_nic,\n\t      struct ethtool_rx_flow_spec *fsp)\n{\n\tint err = 0;\n\n\tif (aq_rule_is_not_correct(aq_nic, fsp))\n\t\terr = -EINVAL;\n\telse if (aq_rule_is_not_support(aq_nic, fsp))\n\t\terr = -EOPNOTSUPP;\n\telse if (aq_rule_already_exists(aq_nic, fsp))\n\t\terr = -EEXIST;\n\n\treturn err;\n}\n\nstatic void aq_set_data_fl2(struct aq_nic_s *aq_nic,\n\t\t\t    struct aq_rx_filter *aq_rx_fltr,\n\t\t\t    struct aq_rx_filter_l2 *data, bool add)\n{\n\tconst struct ethtool_rx_flow_spec *fsp = &aq_rx_fltr->aq_fsp;\n\n\tmemset(data, 0, sizeof(*data));\n\n\tdata->location = fsp->location - AQ_RX_FIRST_LOC_FETHERT;\n\n\tif (fsp->ring_cookie != RX_CLS_FLOW_DISC)\n\t\tdata->queue = fsp->ring_cookie;\n\telse\n\t\tdata->queue = -1;\n\n\tdata->ethertype = be16_to_cpu(fsp->h_u.ether_spec.h_proto);\n\tdata->user_priority_en = be16_to_cpu(fsp->m_ext.vlan_tci)\n\t\t\t\t == VLAN_PRIO_MASK;\n\tdata->user_priority = (be16_to_cpu(fsp->h_ext.vlan_tci)\n\t\t\t       & VLAN_PRIO_MASK) >> VLAN_PRIO_SHIFT;\n}\n\nstatic int aq_add_del_fether(struct aq_nic_s *aq_nic,\n\t\t\t     struct aq_rx_filter *aq_rx_fltr, bool add)\n{\n\tstruct aq_rx_filter_l2 data;\n\tstruct aq_hw_s *aq_hw = aq_nic->aq_hw;\n\tconst struct aq_hw_ops *aq_hw_ops = aq_nic->aq_hw_ops;\n\n\taq_set_data_fl2(aq_nic, aq_rx_fltr, &data, add);\n\n\tif (unlikely(!aq_hw_ops->hw_filter_l2_set))\n\t\treturn -EOPNOTSUPP;\n\tif (unlikely(!aq_hw_ops->hw_filter_l2_clear))\n\t\treturn -EOPNOTSUPP;\n\n\tif (add)\n\t\treturn aq_hw_ops->hw_filter_l2_set(aq_hw, &data);\n\telse\n\t\treturn aq_hw_ops->hw_filter_l2_clear(aq_hw, &data);\n}\n\nstatic bool aq_fvlan_is_busy(struct aq_rx_filter_vlan *aq_vlans, int vlan)\n{\n\tint i;\n\n\tfor (i = 0; i < AQ_VLAN_MAX_FILTERS; ++i) {\n\t\tif (aq_vlans[i].enable &&\n\t\t    aq_vlans[i].queue != AQ_RX_QUEUE_NOT_ASSIGNED &&\n\t\t    aq_vlans[i].vlan_id == vlan) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n \nstatic void aq_fvlan_rebuild(struct aq_nic_s *aq_nic,\n\t\t\t     unsigned long *active_vlans,\n\t\t\t     struct aq_rx_filter_vlan *aq_vlans)\n{\n\tbool vlan_busy = false;\n\tint vlan = -1;\n\tint i;\n\n\tfor (i = 0; i < AQ_VLAN_MAX_FILTERS; ++i) {\n\t\tif (aq_vlans[i].enable &&\n\t\t    aq_vlans[i].queue != AQ_RX_QUEUE_NOT_ASSIGNED)\n\t\t\tcontinue;\n\t\tdo {\n\t\t\tvlan = find_next_bit(active_vlans,\n\t\t\t\t\t     VLAN_N_VID,\n\t\t\t\t\t     vlan + 1);\n\t\t\tif (vlan == VLAN_N_VID) {\n\t\t\t\taq_vlans[i].enable = 0U;\n\t\t\t\taq_vlans[i].queue = AQ_RX_QUEUE_NOT_ASSIGNED;\n\t\t\t\taq_vlans[i].vlan_id = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvlan_busy = aq_fvlan_is_busy(aq_vlans, vlan);\n\t\t\tif (!vlan_busy) {\n\t\t\t\taq_vlans[i].enable = 1U;\n\t\t\t\taq_vlans[i].queue = AQ_RX_QUEUE_NOT_ASSIGNED;\n\t\t\t\taq_vlans[i].vlan_id = vlan;\n\t\t\t}\n\t\t} while (vlan_busy && vlan != VLAN_N_VID);\n\t}\n}\n\nstatic int aq_set_data_fvlan(struct aq_nic_s *aq_nic,\n\t\t\t     struct aq_rx_filter *aq_rx_fltr,\n\t\t\t     struct aq_rx_filter_vlan *aq_vlans, bool add)\n{\n\tconst struct ethtool_rx_flow_spec *fsp = &aq_rx_fltr->aq_fsp;\n\tint location = fsp->location - AQ_RX_FIRST_LOC_FVLANID;\n\tint i;\n\n\tmemset(&aq_vlans[location], 0, sizeof(aq_vlans[location]));\n\n\tif (!add)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < AQ_VLAN_MAX_FILTERS; ++i) {\n\t\tif (aq_vlans[i].vlan_id ==\n\t\t   (be16_to_cpu(fsp->h_ext.vlan_tci) & VLAN_VID_MASK)) {\n\t\t\taq_vlans[i].enable = false;\n\t\t}\n\t}\n\n\taq_vlans[location].location = location;\n\taq_vlans[location].vlan_id = be16_to_cpu(fsp->h_ext.vlan_tci)\n\t\t\t\t     & VLAN_VID_MASK;\n\taq_vlans[location].queue = fsp->ring_cookie & 0x1FU;\n\taq_vlans[location].enable = 1U;\n\n\treturn 0;\n}\n\nint aq_del_fvlan_by_vlan(struct aq_nic_s *aq_nic, u16 vlan_id)\n{\n\tstruct aq_hw_rx_fltrs_s *rx_fltrs = aq_get_hw_rx_fltrs(aq_nic);\n\tstruct aq_rx_filter *rule = NULL;\n\tstruct hlist_node *aq_node2;\n\n\thlist_for_each_entry_safe(rule, aq_node2,\n\t\t\t\t  &rx_fltrs->filter_list, aq_node) {\n\t\tif (be16_to_cpu(rule->aq_fsp.h_ext.vlan_tci) == vlan_id)\n\t\t\tbreak;\n\t}\n\tif (rule && rule->type == aq_rx_filter_vlan &&\n\t    be16_to_cpu(rule->aq_fsp.h_ext.vlan_tci) == vlan_id) {\n\t\tstruct ethtool_rxnfc cmd;\n\n\t\tcmd.fs.location = rule->aq_fsp.location;\n\t\treturn aq_del_rxnfc_rule(aq_nic, &cmd);\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int aq_add_del_fvlan(struct aq_nic_s *aq_nic,\n\t\t\t    struct aq_rx_filter *aq_rx_fltr, bool add)\n{\n\tconst struct aq_hw_ops *aq_hw_ops = aq_nic->aq_hw_ops;\n\n\tif (unlikely(!aq_hw_ops->hw_filter_vlan_set))\n\t\treturn -EOPNOTSUPP;\n\n\taq_set_data_fvlan(aq_nic,\n\t\t\t  aq_rx_fltr,\n\t\t\t  aq_nic->aq_hw_rx_fltrs.fl2.aq_vlans,\n\t\t\t  add);\n\n\treturn aq_filters_vlans_update(aq_nic);\n}\n\nstatic int aq_set_data_fl3l4(struct aq_nic_s *aq_nic,\n\t\t\t     struct aq_rx_filter *aq_rx_fltr,\n\t\t\t     struct aq_rx_filter_l3l4 *data, bool add)\n{\n\tstruct aq_hw_rx_fltrs_s *rx_fltrs = aq_get_hw_rx_fltrs(aq_nic);\n\tconst struct ethtool_rx_flow_spec *fsp = &aq_rx_fltr->aq_fsp;\n\n\tmemset(data, 0, sizeof(*data));\n\n\tdata->is_ipv6 = rx_fltrs->fl3l4.is_ipv6;\n\tdata->location = HW_ATL_GET_REG_LOCATION_FL3L4(fsp->location);\n\n\tif (!add) {\n\t\tif (!data->is_ipv6)\n\t\t\trx_fltrs->fl3l4.active_ipv4 &= ~BIT(data->location);\n\t\telse\n\t\t\trx_fltrs->fl3l4.active_ipv6 &=\n\t\t\t\t~BIT((data->location) / 4);\n\n\t\treturn 0;\n\t}\n\n\tdata->cmd |= HW_ATL_RX_ENABLE_FLTR_L3L4;\n\n\tswitch (fsp->flow_type) {\n\tcase TCP_V4_FLOW:\n\tcase TCP_V6_FLOW:\n\t\tdata->cmd |= HW_ATL_RX_ENABLE_CMP_PROT_L4;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\tcase UDP_V6_FLOW:\n\t\tdata->cmd |= HW_ATL_RX_UDP;\n\t\tdata->cmd |= HW_ATL_RX_ENABLE_CMP_PROT_L4;\n\t\tbreak;\n\tcase SCTP_V4_FLOW:\n\tcase SCTP_V6_FLOW:\n\t\tdata->cmd |= HW_ATL_RX_SCTP;\n\t\tdata->cmd |= HW_ATL_RX_ENABLE_CMP_PROT_L4;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!data->is_ipv6) {\n\t\tdata->ip_src[0] =\n\t\t\tntohl(fsp->h_u.tcp_ip4_spec.ip4src);\n\t\tdata->ip_dst[0] =\n\t\t\tntohl(fsp->h_u.tcp_ip4_spec.ip4dst);\n\t\trx_fltrs->fl3l4.active_ipv4 |= BIT(data->location);\n\t} else {\n\t\tint i;\n\n\t\trx_fltrs->fl3l4.active_ipv6 |= BIT((data->location) / 4);\n\t\tfor (i = 0; i < HW_ATL_RX_CNT_REG_ADDR_IPV6; ++i) {\n\t\t\tdata->ip_dst[i] =\n\t\t\t\tntohl(fsp->h_u.tcp_ip6_spec.ip6dst[i]);\n\t\t\tdata->ip_src[i] =\n\t\t\t\tntohl(fsp->h_u.tcp_ip6_spec.ip6src[i]);\n\t\t}\n\t\tdata->cmd |= HW_ATL_RX_ENABLE_L3_IPV6;\n\t}\n\tif (fsp->flow_type != IP_USER_FLOW &&\n\t    fsp->flow_type != IPV6_USER_FLOW) {\n\t\tif (!data->is_ipv6) {\n\t\t\tdata->p_dst =\n\t\t\t\tntohs(fsp->h_u.tcp_ip4_spec.pdst);\n\t\t\tdata->p_src =\n\t\t\t\tntohs(fsp->h_u.tcp_ip4_spec.psrc);\n\t\t} else {\n\t\t\tdata->p_dst =\n\t\t\t\tntohs(fsp->h_u.tcp_ip6_spec.pdst);\n\t\t\tdata->p_src =\n\t\t\t\tntohs(fsp->h_u.tcp_ip6_spec.psrc);\n\t\t}\n\t}\n\tif (data->ip_src[0] && !data->is_ipv6)\n\t\tdata->cmd |= HW_ATL_RX_ENABLE_CMP_SRC_ADDR_L3;\n\tif (data->ip_dst[0] && !data->is_ipv6)\n\t\tdata->cmd |= HW_ATL_RX_ENABLE_CMP_DEST_ADDR_L3;\n\tif (data->p_dst)\n\t\tdata->cmd |= HW_ATL_RX_ENABLE_CMP_DEST_PORT_L4;\n\tif (data->p_src)\n\t\tdata->cmd |= HW_ATL_RX_ENABLE_CMP_SRC_PORT_L4;\n\tif (fsp->ring_cookie != RX_CLS_FLOW_DISC) {\n\t\tdata->cmd |= HW_ATL_RX_HOST << HW_ATL_RX_ACTION_FL3F4_SHIFT;\n\t\tdata->cmd |= fsp->ring_cookie << HW_ATL_RX_QUEUE_FL3L4_SHIFT;\n\t\tdata->cmd |= HW_ATL_RX_ENABLE_QUEUE_L3L4;\n\t} else {\n\t\tdata->cmd |= HW_ATL_RX_DISCARD << HW_ATL_RX_ACTION_FL3F4_SHIFT;\n\t}\n\n\treturn 0;\n}\n\nstatic int aq_set_fl3l4(struct aq_hw_s *aq_hw,\n\t\t\tconst struct aq_hw_ops *aq_hw_ops,\n\t\t\tstruct aq_rx_filter_l3l4 *data)\n{\n\tif (unlikely(!aq_hw_ops->hw_filter_l3l4_set))\n\t\treturn -EOPNOTSUPP;\n\n\treturn aq_hw_ops->hw_filter_l3l4_set(aq_hw, data);\n}\n\nstatic int aq_add_del_fl3l4(struct aq_nic_s *aq_nic,\n\t\t\t    struct aq_rx_filter *aq_rx_fltr, bool add)\n{\n\tconst struct aq_hw_ops *aq_hw_ops = aq_nic->aq_hw_ops;\n\tstruct aq_hw_s *aq_hw = aq_nic->aq_hw;\n\tstruct aq_rx_filter_l3l4 data;\n\n\tif (unlikely(aq_rx_fltr->aq_fsp.location < AQ_RX_FIRST_LOC_FL3L4 ||\n\t\t     aq_rx_fltr->aq_fsp.location > AQ_RX_LAST_LOC_FL3L4  ||\n\t\t     aq_set_data_fl3l4(aq_nic, aq_rx_fltr, &data, add)))\n\t\treturn -EINVAL;\n\n\treturn aq_set_fl3l4(aq_hw, aq_hw_ops, &data);\n}\n\nstatic int aq_add_del_rule(struct aq_nic_s *aq_nic,\n\t\t\t   struct aq_rx_filter *aq_rx_fltr, bool add)\n{\n\tint err = -EINVAL;\n\n\tif (aq_rx_fltr->aq_fsp.flow_type & FLOW_EXT) {\n\t\tif (be16_to_cpu(aq_rx_fltr->aq_fsp.m_ext.vlan_tci)\n\t\t    == VLAN_VID_MASK) {\n\t\t\taq_rx_fltr->type = aq_rx_filter_vlan;\n\t\t\terr = aq_add_del_fvlan(aq_nic, aq_rx_fltr, add);\n\t\t} else if (be16_to_cpu(aq_rx_fltr->aq_fsp.m_ext.vlan_tci)\n\t\t\t== VLAN_PRIO_MASK) {\n\t\t\taq_rx_fltr->type = aq_rx_filter_ethertype;\n\t\t\terr = aq_add_del_fether(aq_nic, aq_rx_fltr, add);\n\t\t}\n\t} else {\n\t\tswitch (aq_rx_fltr->aq_fsp.flow_type & ~FLOW_EXT) {\n\t\tcase ETHER_FLOW:\n\t\t\taq_rx_fltr->type = aq_rx_filter_ethertype;\n\t\t\terr = aq_add_del_fether(aq_nic, aq_rx_fltr, add);\n\t\t\tbreak;\n\t\tcase TCP_V4_FLOW:\n\t\tcase UDP_V4_FLOW:\n\t\tcase SCTP_V4_FLOW:\n\t\tcase IP_USER_FLOW:\n\t\tcase TCP_V6_FLOW:\n\t\tcase UDP_V6_FLOW:\n\t\tcase SCTP_V6_FLOW:\n\t\tcase IPV6_USER_FLOW:\n\t\t\taq_rx_fltr->type = aq_rx_filter_l3l4;\n\t\t\terr = aq_add_del_fl3l4(aq_nic, aq_rx_fltr, add);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int aq_update_table_filters(struct aq_nic_s *aq_nic,\n\t\t\t\t   struct aq_rx_filter *aq_rx_fltr, u16 index,\n\t\t\t\t   struct ethtool_rxnfc *cmd)\n{\n\tstruct aq_hw_rx_fltrs_s *rx_fltrs = aq_get_hw_rx_fltrs(aq_nic);\n\tstruct aq_rx_filter *rule = NULL, *parent = NULL;\n\tstruct hlist_node *aq_node2;\n\tint err = -EINVAL;\n\n\thlist_for_each_entry_safe(rule, aq_node2,\n\t\t\t\t  &rx_fltrs->filter_list, aq_node) {\n\t\tif (rule->aq_fsp.location >= index)\n\t\t\tbreak;\n\t\tparent = rule;\n\t}\n\n\tif (rule && rule->aq_fsp.location == index) {\n\t\terr = aq_add_del_rule(aq_nic, rule, false);\n\t\thlist_del(&rule->aq_node);\n\t\tkfree(rule);\n\t\t--rx_fltrs->active_filters;\n\t}\n\n\tif (unlikely(!aq_rx_fltr))\n\t\treturn err;\n\n\tINIT_HLIST_NODE(&aq_rx_fltr->aq_node);\n\n\tif (parent)\n\t\thlist_add_behind(&aq_rx_fltr->aq_node, &parent->aq_node);\n\telse\n\t\thlist_add_head(&aq_rx_fltr->aq_node, &rx_fltrs->filter_list);\n\n\t++rx_fltrs->active_filters;\n\n\treturn 0;\n}\n\nu16 aq_get_rxnfc_count_all_rules(struct aq_nic_s *aq_nic)\n{\n\tstruct aq_hw_rx_fltrs_s *rx_fltrs = aq_get_hw_rx_fltrs(aq_nic);\n\n\treturn rx_fltrs->active_filters;\n}\n\nstruct aq_hw_rx_fltrs_s *aq_get_hw_rx_fltrs(struct aq_nic_s *aq_nic)\n{\n\treturn &aq_nic->aq_hw_rx_fltrs;\n}\n\nint aq_add_rxnfc_rule(struct aq_nic_s *aq_nic, const struct ethtool_rxnfc *cmd)\n{\n\tstruct aq_hw_rx_fltrs_s *rx_fltrs = aq_get_hw_rx_fltrs(aq_nic);\n\tstruct ethtool_rx_flow_spec *fsp =\n\t\t(struct ethtool_rx_flow_spec *)&cmd->fs;\n\tstruct aq_rx_filter *aq_rx_fltr;\n\tint err = 0;\n\n\terr = aq_check_rule(aq_nic, fsp);\n\tif (err)\n\t\tgoto err_exit;\n\n\taq_rx_fltr = kzalloc(sizeof(*aq_rx_fltr), GFP_KERNEL);\n\tif (unlikely(!aq_rx_fltr)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_exit;\n\t}\n\n\tmemcpy(&aq_rx_fltr->aq_fsp, fsp, sizeof(*fsp));\n\n\terr = aq_update_table_filters(aq_nic, aq_rx_fltr, fsp->location, NULL);\n\tif (unlikely(err))\n\t\tgoto err_free;\n\n\terr = aq_add_del_rule(aq_nic, aq_rx_fltr, true);\n\tif (unlikely(err)) {\n\t\thlist_del(&aq_rx_fltr->aq_node);\n\t\t--rx_fltrs->active_filters;\n\t\tgoto err_free;\n\t}\n\n\treturn 0;\n\nerr_free:\n\tkfree(aq_rx_fltr);\nerr_exit:\n\treturn err;\n}\n\nint aq_del_rxnfc_rule(struct aq_nic_s *aq_nic, const struct ethtool_rxnfc *cmd)\n{\n\tstruct aq_hw_rx_fltrs_s *rx_fltrs = aq_get_hw_rx_fltrs(aq_nic);\n\tstruct aq_rx_filter *rule = NULL;\n\tstruct hlist_node *aq_node2;\n\tint err = -EINVAL;\n\n\thlist_for_each_entry_safe(rule, aq_node2,\n\t\t\t\t  &rx_fltrs->filter_list, aq_node) {\n\t\tif (rule->aq_fsp.location == cmd->fs.location)\n\t\t\tbreak;\n\t}\n\n\tif (rule && rule->aq_fsp.location == cmd->fs.location) {\n\t\terr = aq_add_del_rule(aq_nic, rule, false);\n\t\thlist_del(&rule->aq_node);\n\t\tkfree(rule);\n\t\t--rx_fltrs->active_filters;\n\t}\n\treturn err;\n}\n\nint aq_get_rxnfc_rule(struct aq_nic_s *aq_nic, struct ethtool_rxnfc *cmd)\n{\n\tstruct aq_hw_rx_fltrs_s *rx_fltrs = aq_get_hw_rx_fltrs(aq_nic);\n\tstruct ethtool_rx_flow_spec *fsp =\n\t\t\t(struct ethtool_rx_flow_spec *)&cmd->fs;\n\tstruct aq_rx_filter *rule = NULL;\n\tstruct hlist_node *aq_node2;\n\n\thlist_for_each_entry_safe(rule, aq_node2,\n\t\t\t\t  &rx_fltrs->filter_list, aq_node)\n\t\tif (fsp->location <= rule->aq_fsp.location)\n\t\t\tbreak;\n\n\tif (unlikely(!rule || fsp->location != rule->aq_fsp.location))\n\t\treturn -EINVAL;\n\n\tmemcpy(fsp, &rule->aq_fsp, sizeof(*fsp));\n\n\treturn 0;\n}\n\nint aq_get_rxnfc_all_rules(struct aq_nic_s *aq_nic, struct ethtool_rxnfc *cmd,\n\t\t\t   u32 *rule_locs)\n{\n\tstruct aq_hw_rx_fltrs_s *rx_fltrs = aq_get_hw_rx_fltrs(aq_nic);\n\tstruct hlist_node *aq_node2;\n\tstruct aq_rx_filter *rule;\n\tint count = 0;\n\n\tcmd->data = aq_get_rxnfc_count_all_rules(aq_nic);\n\n\thlist_for_each_entry_safe(rule, aq_node2,\n\t\t\t\t  &rx_fltrs->filter_list, aq_node) {\n\t\tif (unlikely(count == cmd->rule_cnt))\n\t\t\treturn -EMSGSIZE;\n\n\t\trule_locs[count++] = rule->aq_fsp.location;\n\t}\n\n\tcmd->rule_cnt = count;\n\n\treturn 0;\n}\n\nint aq_clear_rxnfc_all_rules(struct aq_nic_s *aq_nic)\n{\n\tstruct aq_hw_rx_fltrs_s *rx_fltrs = aq_get_hw_rx_fltrs(aq_nic);\n\tstruct hlist_node *aq_node2;\n\tstruct aq_rx_filter *rule;\n\tint err = 0;\n\n\thlist_for_each_entry_safe(rule, aq_node2,\n\t\t\t\t  &rx_fltrs->filter_list, aq_node) {\n\t\terr = aq_add_del_rule(aq_nic, rule, false);\n\t\tif (err)\n\t\t\tgoto err_exit;\n\t\thlist_del(&rule->aq_node);\n\t\tkfree(rule);\n\t\t--rx_fltrs->active_filters;\n\t}\n\nerr_exit:\n\treturn err;\n}\n\nint aq_reapply_rxnfc_all_rules(struct aq_nic_s *aq_nic)\n{\n\tstruct aq_hw_rx_fltrs_s *rx_fltrs = aq_get_hw_rx_fltrs(aq_nic);\n\tstruct hlist_node *aq_node2;\n\tstruct aq_rx_filter *rule;\n\tint err = 0;\n\n\thlist_for_each_entry_safe(rule, aq_node2,\n\t\t\t\t  &rx_fltrs->filter_list, aq_node) {\n\t\terr = aq_add_del_rule(aq_nic, rule, true);\n\t\tif (err)\n\t\t\tgoto err_exit;\n\t}\n\nerr_exit:\n\treturn err;\n}\n\nint aq_filters_vlans_update(struct aq_nic_s *aq_nic)\n{\n\tconst struct aq_hw_ops *aq_hw_ops = aq_nic->aq_hw_ops;\n\tstruct aq_hw_s *aq_hw = aq_nic->aq_hw;\n\tint hweight = 0;\n\tint err = 0;\n\n\tif (unlikely(!aq_hw_ops->hw_filter_vlan_set))\n\t\treturn -EOPNOTSUPP;\n\tif (unlikely(!aq_hw_ops->hw_filter_vlan_ctrl))\n\t\treturn -EOPNOTSUPP;\n\n\taq_fvlan_rebuild(aq_nic, aq_nic->active_vlans,\n\t\t\t aq_nic->aq_hw_rx_fltrs.fl2.aq_vlans);\n\n\tif (aq_nic->ndev->features & NETIF_F_HW_VLAN_CTAG_FILTER) {\n\t\thweight = bitmap_weight(aq_nic->active_vlans, VLAN_N_VID);\n\n\t\terr = aq_hw_ops->hw_filter_vlan_ctrl(aq_hw, false);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = aq_hw_ops->hw_filter_vlan_set(aq_hw,\n\t\t\t\t\t    aq_nic->aq_hw_rx_fltrs.fl2.aq_vlans\n\t\t\t\t\t   );\n\tif (err)\n\t\treturn err;\n\n\tif (aq_nic->ndev->features & NETIF_F_HW_VLAN_CTAG_FILTER) {\n\t\tif (hweight <= AQ_VLAN_MAX_FILTERS && hweight > 0) {\n\t\t\terr = aq_hw_ops->hw_filter_vlan_ctrl(aq_hw,\n\t\t\t\t!(aq_nic->packet_filter & IFF_PROMISC));\n\t\t\taq_nic->aq_nic_cfg.is_vlan_force_promisc = false;\n\t\t} else {\n\t\t \n\t\t\taq_nic->aq_nic_cfg.is_vlan_force_promisc = true;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nint aq_filters_vlan_offload_off(struct aq_nic_s *aq_nic)\n{\n\tconst struct aq_hw_ops *aq_hw_ops = aq_nic->aq_hw_ops;\n\tstruct aq_hw_s *aq_hw = aq_nic->aq_hw;\n\tint err = 0;\n\n\tbitmap_zero(aq_nic->active_vlans, VLAN_N_VID);\n\taq_fvlan_rebuild(aq_nic, aq_nic->active_vlans,\n\t\t\t aq_nic->aq_hw_rx_fltrs.fl2.aq_vlans);\n\n\tif (unlikely(!aq_hw_ops->hw_filter_vlan_set))\n\t\treturn -EOPNOTSUPP;\n\tif (unlikely(!aq_hw_ops->hw_filter_vlan_ctrl))\n\t\treturn -EOPNOTSUPP;\n\n\taq_nic->aq_nic_cfg.is_vlan_force_promisc = true;\n\terr = aq_hw_ops->hw_filter_vlan_ctrl(aq_hw, false);\n\tif (err)\n\t\treturn err;\n\terr = aq_hw_ops->hw_filter_vlan_set(aq_hw,\n\t\t\t\t\t    aq_nic->aq_hw_rx_fltrs.fl2.aq_vlans\n\t\t\t\t\t   );\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}