{
  "module_name": "aq_macsec.c",
  "hash_id": "b68d9b34693cb7308c400f9c70ca712fc177e41584343ede30e73ea6e5af9be1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/aquantia/atlantic/aq_macsec.c",
  "human_readable_source": "\n \n\n#include \"aq_macsec.h\"\n#include \"aq_nic.h\"\n#include <linux/rtnetlink.h>\n\n#include \"macsec/macsec_api.h\"\n#define AQ_MACSEC_KEY_LEN_128_BIT 16\n#define AQ_MACSEC_KEY_LEN_192_BIT 24\n#define AQ_MACSEC_KEY_LEN_256_BIT 32\n\nenum aq_clear_type {\n\t \n\tAQ_CLEAR_HW = BIT(0),\n\t \n\tAQ_CLEAR_SW = BIT(1),\n\t \n\tAQ_CLEAR_ALL = AQ_CLEAR_HW | AQ_CLEAR_SW,\n};\n\nstatic int aq_clear_txsc(struct aq_nic_s *nic, const int txsc_idx,\n\t\t\t enum aq_clear_type clear_type);\nstatic int aq_clear_txsa(struct aq_nic_s *nic, struct aq_macsec_txsc *aq_txsc,\n\t\t\t const int sa_num, enum aq_clear_type clear_type);\nstatic int aq_clear_rxsc(struct aq_nic_s *nic, const int rxsc_idx,\n\t\t\t enum aq_clear_type clear_type);\nstatic int aq_clear_rxsa(struct aq_nic_s *nic, struct aq_macsec_rxsc *aq_rxsc,\n\t\t\t const int sa_num, enum aq_clear_type clear_type);\nstatic int aq_clear_secy(struct aq_nic_s *nic, const struct macsec_secy *secy,\n\t\t\t enum aq_clear_type clear_type);\nstatic int aq_apply_macsec_cfg(struct aq_nic_s *nic);\nstatic int aq_apply_secy_cfg(struct aq_nic_s *nic,\n\t\t\t     const struct macsec_secy *secy);\n\nstatic void aq_ether_addr_to_mac(u32 mac[2], const unsigned char *emac)\n{\n\tu32 tmp[2] = { 0 };\n\n\tmemcpy(((u8 *)tmp) + 2, emac, ETH_ALEN);\n\n\tmac[0] = swab32(tmp[1]);\n\tmac[1] = swab32(tmp[0]);\n}\n\n \nstatic int aq_get_txsc_idx_from_secy(struct aq_macsec_cfg *macsec_cfg,\n\t\t\t\t     const struct macsec_secy *secy)\n{\n\tint i;\n\n\tif (unlikely(!secy))\n\t\treturn -1;\n\n\tfor (i = 0; i < AQ_MACSEC_MAX_SC; i++) {\n\t\tif (macsec_cfg->aq_txsc[i].sw_secy == secy)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\nstatic int aq_get_rxsc_idx_from_rxsc(struct aq_macsec_cfg *macsec_cfg,\n\t\t\t\t     const struct macsec_rx_sc *rxsc)\n{\n\tint i;\n\n\tif (unlikely(!rxsc))\n\t\treturn -1;\n\n\tfor (i = 0; i < AQ_MACSEC_MAX_SC; i++) {\n\t\tif (macsec_cfg->aq_rxsc[i].sw_rxsc == rxsc)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}\n\nstatic int aq_get_txsc_idx_from_sc_idx(const enum aq_macsec_sc_sa sc_sa,\n\t\t\t\t       const int sc_idx)\n{\n\tswitch (sc_sa) {\n\tcase aq_macsec_sa_sc_4sa_8sc:\n\t\treturn sc_idx >> 2;\n\tcase aq_macsec_sa_sc_2sa_16sc:\n\t\treturn sc_idx >> 1;\n\tcase aq_macsec_sa_sc_1sa_32sc:\n\t\treturn sc_idx;\n\tdefault:\n\t\tWARN_ONCE(true, \"Invalid sc_sa\");\n\t}\n\treturn -1;\n}\n\n \nstatic void aq_rotate_keys(u32 (*key)[8], const int key_len)\n{\n\tu32 tmp[8] = { 0 };\n\n\tmemcpy(&tmp, key, sizeof(tmp));\n\tmemset(*key, 0, sizeof(*key));\n\n\tif (key_len == AQ_MACSEC_KEY_LEN_128_BIT) {\n\t\t(*key)[0] = swab32(tmp[3]);\n\t\t(*key)[1] = swab32(tmp[2]);\n\t\t(*key)[2] = swab32(tmp[1]);\n\t\t(*key)[3] = swab32(tmp[0]);\n\t} else if (key_len == AQ_MACSEC_KEY_LEN_192_BIT) {\n\t\t(*key)[0] = swab32(tmp[5]);\n\t\t(*key)[1] = swab32(tmp[4]);\n\t\t(*key)[2] = swab32(tmp[3]);\n\t\t(*key)[3] = swab32(tmp[2]);\n\t\t(*key)[4] = swab32(tmp[1]);\n\t\t(*key)[5] = swab32(tmp[0]);\n\t} else if (key_len == AQ_MACSEC_KEY_LEN_256_BIT) {\n\t\t(*key)[0] = swab32(tmp[7]);\n\t\t(*key)[1] = swab32(tmp[6]);\n\t\t(*key)[2] = swab32(tmp[5]);\n\t\t(*key)[3] = swab32(tmp[4]);\n\t\t(*key)[4] = swab32(tmp[3]);\n\t\t(*key)[5] = swab32(tmp[2]);\n\t\t(*key)[6] = swab32(tmp[1]);\n\t\t(*key)[7] = swab32(tmp[0]);\n\t} else {\n\t\tpr_warn(\"Rotate_keys: invalid key_len\\n\");\n\t}\n}\n\n#define STATS_2x32_TO_64(stat_field)                                           \\\n\t(((u64)stat_field[1] << 32) | stat_field[0])\n\nstatic int aq_get_macsec_common_stats(struct aq_hw_s *hw,\n\t\t\t\t      struct aq_macsec_common_stats *stats)\n{\n\tstruct aq_mss_ingress_common_counters ingress_counters;\n\tstruct aq_mss_egress_common_counters egress_counters;\n\tint ret;\n\n\t \n\tret = aq_mss_get_ingress_common_counters(hw, &ingress_counters);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tstats->in.ctl_pkts = STATS_2x32_TO_64(ingress_counters.ctl_pkts);\n\tstats->in.tagged_miss_pkts =\n\t\tSTATS_2x32_TO_64(ingress_counters.tagged_miss_pkts);\n\tstats->in.untagged_miss_pkts =\n\t\tSTATS_2x32_TO_64(ingress_counters.untagged_miss_pkts);\n\tstats->in.notag_pkts = STATS_2x32_TO_64(ingress_counters.notag_pkts);\n\tstats->in.untagged_pkts =\n\t\tSTATS_2x32_TO_64(ingress_counters.untagged_pkts);\n\tstats->in.bad_tag_pkts =\n\t\tSTATS_2x32_TO_64(ingress_counters.bad_tag_pkts);\n\tstats->in.no_sci_pkts = STATS_2x32_TO_64(ingress_counters.no_sci_pkts);\n\tstats->in.unknown_sci_pkts =\n\t\tSTATS_2x32_TO_64(ingress_counters.unknown_sci_pkts);\n\tstats->in.ctrl_prt_pass_pkts =\n\t\tSTATS_2x32_TO_64(ingress_counters.ctrl_prt_pass_pkts);\n\tstats->in.unctrl_prt_pass_pkts =\n\t\tSTATS_2x32_TO_64(ingress_counters.unctrl_prt_pass_pkts);\n\tstats->in.ctrl_prt_fail_pkts =\n\t\tSTATS_2x32_TO_64(ingress_counters.ctrl_prt_fail_pkts);\n\tstats->in.unctrl_prt_fail_pkts =\n\t\tSTATS_2x32_TO_64(ingress_counters.unctrl_prt_fail_pkts);\n\tstats->in.too_long_pkts =\n\t\tSTATS_2x32_TO_64(ingress_counters.too_long_pkts);\n\tstats->in.igpoc_ctl_pkts =\n\t\tSTATS_2x32_TO_64(ingress_counters.igpoc_ctl_pkts);\n\tstats->in.ecc_error_pkts =\n\t\tSTATS_2x32_TO_64(ingress_counters.ecc_error_pkts);\n\tstats->in.unctrl_hit_drop_redir =\n\t\tSTATS_2x32_TO_64(ingress_counters.unctrl_hit_drop_redir);\n\n\tret = aq_mss_get_egress_common_counters(hw, &egress_counters);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tstats->out.ctl_pkts = STATS_2x32_TO_64(egress_counters.ctl_pkt);\n\tstats->out.unknown_sa_pkts =\n\t\tSTATS_2x32_TO_64(egress_counters.unknown_sa_pkts);\n\tstats->out.untagged_pkts =\n\t\tSTATS_2x32_TO_64(egress_counters.untagged_pkts);\n\tstats->out.too_long = STATS_2x32_TO_64(egress_counters.too_long);\n\tstats->out.ecc_error_pkts =\n\t\tSTATS_2x32_TO_64(egress_counters.ecc_error_pkts);\n\tstats->out.unctrl_hit_drop_redir =\n\t\tSTATS_2x32_TO_64(egress_counters.unctrl_hit_drop_redir);\n\n\treturn 0;\n}\n\nstatic int aq_get_rxsa_stats(struct aq_hw_s *hw, const int sa_idx,\n\t\t\t     struct aq_macsec_rx_sa_stats *stats)\n{\n\tstruct aq_mss_ingress_sa_counters i_sa_counters;\n\tint ret;\n\n\tret = aq_mss_get_ingress_sa_counters(hw, &i_sa_counters, sa_idx);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tstats->untagged_hit_pkts =\n\t\tSTATS_2x32_TO_64(i_sa_counters.untagged_hit_pkts);\n\tstats->ctrl_hit_drop_redir_pkts =\n\t\tSTATS_2x32_TO_64(i_sa_counters.ctrl_hit_drop_redir_pkts);\n\tstats->not_using_sa = STATS_2x32_TO_64(i_sa_counters.not_using_sa);\n\tstats->unused_sa = STATS_2x32_TO_64(i_sa_counters.unused_sa);\n\tstats->not_valid_pkts = STATS_2x32_TO_64(i_sa_counters.not_valid_pkts);\n\tstats->invalid_pkts = STATS_2x32_TO_64(i_sa_counters.invalid_pkts);\n\tstats->ok_pkts = STATS_2x32_TO_64(i_sa_counters.ok_pkts);\n\tstats->late_pkts = STATS_2x32_TO_64(i_sa_counters.late_pkts);\n\tstats->delayed_pkts = STATS_2x32_TO_64(i_sa_counters.delayed_pkts);\n\tstats->unchecked_pkts = STATS_2x32_TO_64(i_sa_counters.unchecked_pkts);\n\tstats->validated_octets =\n\t\tSTATS_2x32_TO_64(i_sa_counters.validated_octets);\n\tstats->decrypted_octets =\n\t\tSTATS_2x32_TO_64(i_sa_counters.decrypted_octets);\n\n\treturn 0;\n}\n\nstatic int aq_get_txsa_stats(struct aq_hw_s *hw, const int sa_idx,\n\t\t\t     struct aq_macsec_tx_sa_stats *stats)\n{\n\tstruct aq_mss_egress_sa_counters e_sa_counters;\n\tint ret;\n\n\tret = aq_mss_get_egress_sa_counters(hw, &e_sa_counters, sa_idx);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tstats->sa_hit_drop_redirect =\n\t\tSTATS_2x32_TO_64(e_sa_counters.sa_hit_drop_redirect);\n\tstats->sa_protected2_pkts =\n\t\tSTATS_2x32_TO_64(e_sa_counters.sa_protected2_pkts);\n\tstats->sa_protected_pkts =\n\t\tSTATS_2x32_TO_64(e_sa_counters.sa_protected_pkts);\n\tstats->sa_encrypted_pkts =\n\t\tSTATS_2x32_TO_64(e_sa_counters.sa_encrypted_pkts);\n\n\treturn 0;\n}\n\nstatic int aq_get_txsa_next_pn(struct aq_hw_s *hw, const int sa_idx, u32 *pn)\n{\n\tstruct aq_mss_egress_sa_record sa_rec;\n\tint ret;\n\n\tret = aq_mss_get_egress_sa_record(hw, &sa_rec, sa_idx);\n\tif (likely(!ret))\n\t\t*pn = sa_rec.next_pn;\n\n\treturn ret;\n}\n\nstatic int aq_get_rxsa_next_pn(struct aq_hw_s *hw, const int sa_idx, u32 *pn)\n{\n\tstruct aq_mss_ingress_sa_record sa_rec;\n\tint ret;\n\n\tret = aq_mss_get_ingress_sa_record(hw, &sa_rec, sa_idx);\n\tif (likely(!ret))\n\t\t*pn = (!sa_rec.sat_nextpn) ? sa_rec.next_pn : 0;\n\n\treturn ret;\n}\n\nstatic int aq_get_txsc_stats(struct aq_hw_s *hw, const int sc_idx,\n\t\t\t     struct aq_macsec_tx_sc_stats *stats)\n{\n\tstruct aq_mss_egress_sc_counters e_sc_counters;\n\tint ret;\n\n\tret = aq_mss_get_egress_sc_counters(hw, &e_sc_counters, sc_idx);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tstats->sc_protected_pkts =\n\t\tSTATS_2x32_TO_64(e_sc_counters.sc_protected_pkts);\n\tstats->sc_encrypted_pkts =\n\t\tSTATS_2x32_TO_64(e_sc_counters.sc_encrypted_pkts);\n\tstats->sc_protected_octets =\n\t\tSTATS_2x32_TO_64(e_sc_counters.sc_protected_octets);\n\tstats->sc_encrypted_octets =\n\t\tSTATS_2x32_TO_64(e_sc_counters.sc_encrypted_octets);\n\n\treturn 0;\n}\n\nstatic int aq_mdo_dev_open(struct macsec_context *ctx)\n{\n\tstruct aq_nic_s *nic = macsec_netdev_priv(ctx->netdev);\n\tint ret = 0;\n\n\tif (netif_carrier_ok(nic->ndev))\n\t\tret = aq_apply_secy_cfg(nic, ctx->secy);\n\n\treturn ret;\n}\n\nstatic int aq_mdo_dev_stop(struct macsec_context *ctx)\n{\n\tstruct aq_nic_s *nic = macsec_netdev_priv(ctx->netdev);\n\tint i;\n\n\tfor (i = 0; i < AQ_MACSEC_MAX_SC; i++) {\n\t\tif (nic->macsec_cfg->txsc_idx_busy & BIT(i))\n\t\t\taq_clear_secy(nic, nic->macsec_cfg->aq_txsc[i].sw_secy,\n\t\t\t\t      AQ_CLEAR_HW);\n\t}\n\n\treturn 0;\n}\n\nstatic int aq_set_txsc(struct aq_nic_s *nic, const int txsc_idx)\n{\n\tstruct aq_macsec_txsc *aq_txsc = &nic->macsec_cfg->aq_txsc[txsc_idx];\n\tstruct aq_mss_egress_class_record tx_class_rec = { 0 };\n\tconst struct macsec_secy *secy = aq_txsc->sw_secy;\n\tstruct aq_mss_egress_sc_record sc_rec = { 0 };\n\tunsigned int sc_idx = aq_txsc->hw_sc_idx;\n\tstruct aq_hw_s *hw = nic->aq_hw;\n\tint ret = 0;\n\n\taq_ether_addr_to_mac(tx_class_rec.mac_sa, secy->netdev->dev_addr);\n\n\tput_unaligned_be64((__force u64)secy->sci, tx_class_rec.sci);\n\ttx_class_rec.sci_mask = 0;\n\n\ttx_class_rec.sa_mask = 0x3f;\n\n\ttx_class_rec.action = 0;  \n\ttx_class_rec.valid = 1;\n\n\ttx_class_rec.sc_idx = sc_idx;\n\n\ttx_class_rec.sc_sa = nic->macsec_cfg->sc_sa;\n\n\tret = aq_mss_set_egress_class_record(hw, &tx_class_rec, txsc_idx);\n\tif (ret)\n\t\treturn ret;\n\n\tsc_rec.protect = secy->protect_frames;\n\tif (secy->tx_sc.encrypt)\n\t\tsc_rec.tci |= BIT(1);\n\tif (secy->tx_sc.scb)\n\t\tsc_rec.tci |= BIT(2);\n\tif (secy->tx_sc.send_sci)\n\t\tsc_rec.tci |= BIT(3);\n\tif (secy->tx_sc.end_station)\n\t\tsc_rec.tci |= BIT(4);\n\t \n\tif (!(secy->icv_len == 16 && !secy->tx_sc.encrypt))\n\t\tsc_rec.tci |= BIT(0);\n\n\tsc_rec.an_roll = 0;\n\n\tswitch (secy->key_len) {\n\tcase AQ_MACSEC_KEY_LEN_128_BIT:\n\t\tsc_rec.sak_len = 0;\n\t\tbreak;\n\tcase AQ_MACSEC_KEY_LEN_192_BIT:\n\t\tsc_rec.sak_len = 1;\n\t\tbreak;\n\tcase AQ_MACSEC_KEY_LEN_256_BIT:\n\t\tsc_rec.sak_len = 2;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(true, \"Invalid sc_sa\");\n\t\treturn -EINVAL;\n\t}\n\n\tsc_rec.curr_an = secy->tx_sc.encoding_sa;\n\tsc_rec.valid = 1;\n\tsc_rec.fresh = 1;\n\n\treturn aq_mss_set_egress_sc_record(hw, &sc_rec, sc_idx);\n}\n\nstatic u32 aq_sc_idx_max(const enum aq_macsec_sc_sa sc_sa)\n{\n\tu32 result = 0;\n\n\tswitch (sc_sa) {\n\tcase aq_macsec_sa_sc_4sa_8sc:\n\t\tresult = 8;\n\t\tbreak;\n\tcase aq_macsec_sa_sc_2sa_16sc:\n\t\tresult = 16;\n\t\tbreak;\n\tcase aq_macsec_sa_sc_1sa_32sc:\n\t\tresult = 32;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn result;\n}\n\nstatic u32 aq_to_hw_sc_idx(const u32 sc_idx, const enum aq_macsec_sc_sa sc_sa)\n{\n\tswitch (sc_sa) {\n\tcase aq_macsec_sa_sc_4sa_8sc:\n\t\treturn sc_idx << 2;\n\tcase aq_macsec_sa_sc_2sa_16sc:\n\t\treturn sc_idx << 1;\n\tcase aq_macsec_sa_sc_1sa_32sc:\n\t\treturn sc_idx;\n\tdefault:\n\t\tWARN_ONCE(true, \"Invalid sc_sa\");\n\t}\n\n\treturn sc_idx;\n}\n\nstatic enum aq_macsec_sc_sa sc_sa_from_num_an(const int num_an)\n{\n\tenum aq_macsec_sc_sa sc_sa = aq_macsec_sa_sc_not_used;\n\n\tswitch (num_an) {\n\tcase 4:\n\t\tsc_sa = aq_macsec_sa_sc_4sa_8sc;\n\t\tbreak;\n\tcase 2:\n\t\tsc_sa = aq_macsec_sa_sc_2sa_16sc;\n\t\tbreak;\n\tcase 1:\n\t\tsc_sa = aq_macsec_sa_sc_1sa_32sc;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn sc_sa;\n}\n\nstatic int aq_mdo_add_secy(struct macsec_context *ctx)\n{\n\tstruct aq_nic_s *nic = macsec_netdev_priv(ctx->netdev);\n\tstruct aq_macsec_cfg *cfg = nic->macsec_cfg;\n\tconst struct macsec_secy *secy = ctx->secy;\n\tenum aq_macsec_sc_sa sc_sa;\n\tu32 txsc_idx;\n\tint ret = 0;\n\n\tif (secy->xpn)\n\t\treturn -EOPNOTSUPP;\n\n\tsc_sa = sc_sa_from_num_an(MACSEC_NUM_AN);\n\tif (sc_sa == aq_macsec_sa_sc_not_used)\n\t\treturn -EINVAL;\n\n\tif (hweight32(cfg->txsc_idx_busy) >= aq_sc_idx_max(sc_sa))\n\t\treturn -ENOSPC;\n\n\ttxsc_idx = ffz(cfg->txsc_idx_busy);\n\tif (txsc_idx == AQ_MACSEC_MAX_SC)\n\t\treturn -ENOSPC;\n\n\tcfg->sc_sa = sc_sa;\n\tcfg->aq_txsc[txsc_idx].hw_sc_idx = aq_to_hw_sc_idx(txsc_idx, sc_sa);\n\tcfg->aq_txsc[txsc_idx].sw_secy = secy;\n\n\tif (netif_carrier_ok(nic->ndev) && netif_running(secy->netdev))\n\t\tret = aq_set_txsc(nic, txsc_idx);\n\n\tset_bit(txsc_idx, &cfg->txsc_idx_busy);\n\n\treturn ret;\n}\n\nstatic int aq_mdo_upd_secy(struct macsec_context *ctx)\n{\n\tstruct aq_nic_s *nic = macsec_netdev_priv(ctx->netdev);\n\tconst struct macsec_secy *secy = ctx->secy;\n\tint txsc_idx;\n\tint ret = 0;\n\n\ttxsc_idx = aq_get_txsc_idx_from_secy(nic->macsec_cfg, secy);\n\tif (txsc_idx < 0)\n\t\treturn -ENOENT;\n\n\tif (netif_carrier_ok(nic->ndev) && netif_running(secy->netdev))\n\t\tret = aq_set_txsc(nic, txsc_idx);\n\n\treturn ret;\n}\n\nstatic int aq_clear_txsc(struct aq_nic_s *nic, const int txsc_idx,\n\t\t\t enum aq_clear_type clear_type)\n{\n\tstruct aq_macsec_txsc *tx_sc = &nic->macsec_cfg->aq_txsc[txsc_idx];\n\tstruct aq_mss_egress_class_record tx_class_rec = { 0 };\n\tstruct aq_mss_egress_sc_record sc_rec = { 0 };\n\tstruct aq_hw_s *hw = nic->aq_hw;\n\tint ret = 0;\n\tint sa_num;\n\n\tfor_each_set_bit (sa_num, &tx_sc->tx_sa_idx_busy, AQ_MACSEC_MAX_SA) {\n\t\tret = aq_clear_txsa(nic, tx_sc, sa_num, clear_type);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (clear_type & AQ_CLEAR_HW) {\n\t\tret = aq_mss_set_egress_class_record(hw, &tx_class_rec,\n\t\t\t\t\t\t     txsc_idx);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsc_rec.fresh = 1;\n\t\tret = aq_mss_set_egress_sc_record(hw, &sc_rec,\n\t\t\t\t\t\t  tx_sc->hw_sc_idx);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (clear_type & AQ_CLEAR_SW) {\n\t\tclear_bit(txsc_idx, &nic->macsec_cfg->txsc_idx_busy);\n\t\tnic->macsec_cfg->aq_txsc[txsc_idx].sw_secy = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic int aq_mdo_del_secy(struct macsec_context *ctx)\n{\n\tstruct aq_nic_s *nic = macsec_netdev_priv(ctx->netdev);\n\tint ret = 0;\n\n\tif (!nic->macsec_cfg)\n\t\treturn 0;\n\n\tret = aq_clear_secy(nic, ctx->secy, AQ_CLEAR_ALL);\n\n\treturn ret;\n}\n\nstatic int aq_update_txsa(struct aq_nic_s *nic, const unsigned int sc_idx,\n\t\t\t  const struct macsec_secy *secy,\n\t\t\t  const struct macsec_tx_sa *tx_sa,\n\t\t\t  const unsigned char *key, const unsigned char an)\n{\n\tconst u32 next_pn = tx_sa->next_pn_halves.lower;\n\tstruct aq_mss_egress_sakey_record key_rec;\n\tconst unsigned int sa_idx = sc_idx | an;\n\tstruct aq_mss_egress_sa_record sa_rec;\n\tstruct aq_hw_s *hw = nic->aq_hw;\n\tint ret = 0;\n\n\tmemset(&sa_rec, 0, sizeof(sa_rec));\n\tsa_rec.valid = tx_sa->active;\n\tsa_rec.fresh = 1;\n\tsa_rec.next_pn = next_pn;\n\n\tret = aq_mss_set_egress_sa_record(hw, &sa_rec, sa_idx);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!key)\n\t\treturn ret;\n\n\tmemset(&key_rec, 0, sizeof(key_rec));\n\tmemcpy(&key_rec.key, key, secy->key_len);\n\n\taq_rotate_keys(&key_rec.key, secy->key_len);\n\n\tret = aq_mss_set_egress_sakey_record(hw, &key_rec, sa_idx);\n\n\tmemzero_explicit(&key_rec, sizeof(key_rec));\n\treturn ret;\n}\n\nstatic int aq_mdo_add_txsa(struct macsec_context *ctx)\n{\n\tstruct aq_nic_s *nic = macsec_netdev_priv(ctx->netdev);\n\tstruct aq_macsec_cfg *cfg = nic->macsec_cfg;\n\tconst struct macsec_secy *secy = ctx->secy;\n\tstruct aq_macsec_txsc *aq_txsc;\n\tint txsc_idx;\n\tint ret = 0;\n\n\ttxsc_idx = aq_get_txsc_idx_from_secy(cfg, secy);\n\tif (txsc_idx < 0)\n\t\treturn -EINVAL;\n\n\taq_txsc = &cfg->aq_txsc[txsc_idx];\n\tset_bit(ctx->sa.assoc_num, &aq_txsc->tx_sa_idx_busy);\n\n\tmemcpy(aq_txsc->tx_sa_key[ctx->sa.assoc_num], ctx->sa.key,\n\t       secy->key_len);\n\n\tif (netif_carrier_ok(nic->ndev) && netif_running(secy->netdev))\n\t\tret = aq_update_txsa(nic, aq_txsc->hw_sc_idx, secy,\n\t\t\t\t     ctx->sa.tx_sa, ctx->sa.key,\n\t\t\t\t     ctx->sa.assoc_num);\n\n\treturn ret;\n}\n\nstatic int aq_mdo_upd_txsa(struct macsec_context *ctx)\n{\n\tstruct aq_nic_s *nic = macsec_netdev_priv(ctx->netdev);\n\tstruct aq_macsec_cfg *cfg = nic->macsec_cfg;\n\tconst struct macsec_secy *secy = ctx->secy;\n\tstruct aq_macsec_txsc *aq_txsc;\n\tint txsc_idx;\n\tint ret = 0;\n\n\ttxsc_idx = aq_get_txsc_idx_from_secy(cfg, secy);\n\tif (txsc_idx < 0)\n\t\treturn -EINVAL;\n\n\taq_txsc = &cfg->aq_txsc[txsc_idx];\n\tif (netif_carrier_ok(nic->ndev) && netif_running(secy->netdev))\n\t\tret = aq_update_txsa(nic, aq_txsc->hw_sc_idx, secy,\n\t\t\t\t     ctx->sa.tx_sa, NULL, ctx->sa.assoc_num);\n\n\treturn ret;\n}\n\nstatic int aq_clear_txsa(struct aq_nic_s *nic, struct aq_macsec_txsc *aq_txsc,\n\t\t\t const int sa_num, enum aq_clear_type clear_type)\n{\n\tconst int sa_idx = aq_txsc->hw_sc_idx | sa_num;\n\tstruct aq_hw_s *hw = nic->aq_hw;\n\tint ret = 0;\n\n\tif (clear_type & AQ_CLEAR_SW)\n\t\tclear_bit(sa_num, &aq_txsc->tx_sa_idx_busy);\n\n\tif ((clear_type & AQ_CLEAR_HW) && netif_carrier_ok(nic->ndev)) {\n\t\tstruct aq_mss_egress_sakey_record key_rec;\n\t\tstruct aq_mss_egress_sa_record sa_rec;\n\n\t\tmemset(&sa_rec, 0, sizeof(sa_rec));\n\t\tsa_rec.fresh = 1;\n\n\t\tret = aq_mss_set_egress_sa_record(hw, &sa_rec, sa_idx);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmemset(&key_rec, 0, sizeof(key_rec));\n\t\treturn aq_mss_set_egress_sakey_record(hw, &key_rec, sa_idx);\n\t}\n\n\treturn 0;\n}\n\nstatic int aq_mdo_del_txsa(struct macsec_context *ctx)\n{\n\tstruct aq_nic_s *nic = macsec_netdev_priv(ctx->netdev);\n\tstruct aq_macsec_cfg *cfg = nic->macsec_cfg;\n\tint txsc_idx;\n\tint ret = 0;\n\n\ttxsc_idx = aq_get_txsc_idx_from_secy(cfg, ctx->secy);\n\tif (txsc_idx < 0)\n\t\treturn -EINVAL;\n\n\tret = aq_clear_txsa(nic, &cfg->aq_txsc[txsc_idx], ctx->sa.assoc_num,\n\t\t\t    AQ_CLEAR_ALL);\n\n\treturn ret;\n}\n\nstatic int aq_rxsc_validate_frames(const enum macsec_validation_type validate)\n{\n\tswitch (validate) {\n\tcase MACSEC_VALIDATE_DISABLED:\n\t\treturn 2;\n\tcase MACSEC_VALIDATE_CHECK:\n\t\treturn 1;\n\tcase MACSEC_VALIDATE_STRICT:\n\t\treturn 0;\n\tdefault:\n\t\tWARN_ONCE(true, \"Invalid validation type\");\n\t}\n\n\treturn 0;\n}\n\nstatic int aq_set_rxsc(struct aq_nic_s *nic, const u32 rxsc_idx)\n{\n\tconst struct aq_macsec_rxsc *aq_rxsc =\n\t\t&nic->macsec_cfg->aq_rxsc[rxsc_idx];\n\tstruct aq_mss_ingress_preclass_record pre_class_record;\n\tconst struct macsec_rx_sc *rx_sc = aq_rxsc->sw_rxsc;\n\tconst struct macsec_secy *secy = aq_rxsc->sw_secy;\n\tconst u32 hw_sc_idx = aq_rxsc->hw_sc_idx;\n\tstruct aq_mss_ingress_sc_record sc_record;\n\tstruct aq_hw_s *hw = nic->aq_hw;\n\tint ret = 0;\n\n\tmemset(&pre_class_record, 0, sizeof(pre_class_record));\n\tput_unaligned_be64((__force u64)rx_sc->sci, pre_class_record.sci);\n\tpre_class_record.sci_mask = 0xff;\n\t \n\tpre_class_record.eth_type = ETH_P_MACSEC;\n\tpre_class_record.eth_type_mask = 0x3;\n\n\taq_ether_addr_to_mac(pre_class_record.mac_sa, (char *)&rx_sc->sci);\n\tpre_class_record.sa_mask = 0x3f;\n\n\tpre_class_record.an_mask = nic->macsec_cfg->sc_sa;\n\tpre_class_record.sc_idx = hw_sc_idx;\n\t \n\tpre_class_record.action = 0x0;\n\tpre_class_record.valid = 1;\n\n\tret = aq_mss_set_ingress_preclass_record(hw, &pre_class_record,\n\t\t\t\t\t\t 2 * rxsc_idx + 1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpre_class_record.sci_mask = 0;\n\tpre_class_record.sci_from_table = 1;\n\n\tret = aq_mss_set_ingress_preclass_record(hw, &pre_class_record,\n\t\t\t\t\t\t 2 * rxsc_idx);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(&sc_record, 0, sizeof(sc_record));\n\tsc_record.validate_frames =\n\t\taq_rxsc_validate_frames(secy->validate_frames);\n\tif (secy->replay_protect) {\n\t\tsc_record.replay_protect = 1;\n\t\tsc_record.anti_replay_window = secy->replay_window;\n\t}\n\tsc_record.valid = 1;\n\tsc_record.fresh = 1;\n\n\tret = aq_mss_set_ingress_sc_record(hw, &sc_record, hw_sc_idx);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic int aq_mdo_add_rxsc(struct macsec_context *ctx)\n{\n\tstruct aq_nic_s *nic = macsec_netdev_priv(ctx->netdev);\n\tstruct aq_macsec_cfg *cfg = nic->macsec_cfg;\n\tconst u32 rxsc_idx_max = aq_sc_idx_max(cfg->sc_sa);\n\tu32 rxsc_idx;\n\tint ret = 0;\n\n\tif (hweight32(cfg->rxsc_idx_busy) >= rxsc_idx_max)\n\t\treturn -ENOSPC;\n\n\trxsc_idx = ffz(cfg->rxsc_idx_busy);\n\tif (rxsc_idx >= rxsc_idx_max)\n\t\treturn -ENOSPC;\n\n\tcfg->aq_rxsc[rxsc_idx].hw_sc_idx = aq_to_hw_sc_idx(rxsc_idx,\n\t\t\t\t\t\t\t   cfg->sc_sa);\n\tcfg->aq_rxsc[rxsc_idx].sw_secy = ctx->secy;\n\tcfg->aq_rxsc[rxsc_idx].sw_rxsc = ctx->rx_sc;\n\n\tif (netif_carrier_ok(nic->ndev) && netif_running(ctx->secy->netdev))\n\t\tret = aq_set_rxsc(nic, rxsc_idx);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tset_bit(rxsc_idx, &cfg->rxsc_idx_busy);\n\n\treturn 0;\n}\n\nstatic int aq_mdo_upd_rxsc(struct macsec_context *ctx)\n{\n\tstruct aq_nic_s *nic = macsec_netdev_priv(ctx->netdev);\n\tint rxsc_idx;\n\tint ret = 0;\n\n\trxsc_idx = aq_get_rxsc_idx_from_rxsc(nic->macsec_cfg, ctx->rx_sc);\n\tif (rxsc_idx < 0)\n\t\treturn -ENOENT;\n\n\tif (netif_carrier_ok(nic->ndev) && netif_running(ctx->secy->netdev))\n\t\tret = aq_set_rxsc(nic, rxsc_idx);\n\n\treturn ret;\n}\n\nstatic int aq_clear_rxsc(struct aq_nic_s *nic, const int rxsc_idx,\n\t\t\t enum aq_clear_type clear_type)\n{\n\tstruct aq_macsec_rxsc *rx_sc = &nic->macsec_cfg->aq_rxsc[rxsc_idx];\n\tstruct aq_hw_s *hw = nic->aq_hw;\n\tint ret = 0;\n\tint sa_num;\n\n\tfor_each_set_bit (sa_num, &rx_sc->rx_sa_idx_busy, AQ_MACSEC_MAX_SA) {\n\t\tret = aq_clear_rxsa(nic, rx_sc, sa_num, clear_type);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (clear_type & AQ_CLEAR_HW) {\n\t\tstruct aq_mss_ingress_preclass_record pre_class_record;\n\t\tstruct aq_mss_ingress_sc_record sc_record;\n\n\t\tmemset(&pre_class_record, 0, sizeof(pre_class_record));\n\t\tmemset(&sc_record, 0, sizeof(sc_record));\n\n\t\tret = aq_mss_set_ingress_preclass_record(hw, &pre_class_record,\n\t\t\t\t\t\t\t 2 * rxsc_idx);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = aq_mss_set_ingress_preclass_record(hw, &pre_class_record,\n\t\t\t\t\t\t\t 2 * rxsc_idx + 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsc_record.fresh = 1;\n\t\tret = aq_mss_set_ingress_sc_record(hw, &sc_record,\n\t\t\t\t\t\t   rx_sc->hw_sc_idx);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (clear_type & AQ_CLEAR_SW) {\n\t\tclear_bit(rxsc_idx, &nic->macsec_cfg->rxsc_idx_busy);\n\t\trx_sc->sw_secy = NULL;\n\t\trx_sc->sw_rxsc = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic int aq_mdo_del_rxsc(struct macsec_context *ctx)\n{\n\tstruct aq_nic_s *nic = macsec_netdev_priv(ctx->netdev);\n\tenum aq_clear_type clear_type = AQ_CLEAR_SW;\n\tint rxsc_idx;\n\tint ret = 0;\n\n\trxsc_idx = aq_get_rxsc_idx_from_rxsc(nic->macsec_cfg, ctx->rx_sc);\n\tif (rxsc_idx < 0)\n\t\treturn -ENOENT;\n\n\tif (netif_carrier_ok(nic->ndev))\n\t\tclear_type = AQ_CLEAR_ALL;\n\n\tret = aq_clear_rxsc(nic, rxsc_idx, clear_type);\n\n\treturn ret;\n}\n\nstatic int aq_update_rxsa(struct aq_nic_s *nic, const unsigned int sc_idx,\n\t\t\t  const struct macsec_secy *secy,\n\t\t\t  const struct macsec_rx_sa *rx_sa,\n\t\t\t  const unsigned char *key, const unsigned char an)\n{\n\tstruct aq_mss_ingress_sakey_record sa_key_record;\n\tconst u32 next_pn = rx_sa->next_pn_halves.lower;\n\tstruct aq_mss_ingress_sa_record sa_record;\n\tstruct aq_hw_s *hw = nic->aq_hw;\n\tconst int sa_idx = sc_idx | an;\n\tint ret = 0;\n\n\tmemset(&sa_record, 0, sizeof(sa_record));\n\tsa_record.valid = rx_sa->active;\n\tsa_record.fresh = 1;\n\tsa_record.next_pn = next_pn;\n\n\tret = aq_mss_set_ingress_sa_record(hw, &sa_record, sa_idx);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!key)\n\t\treturn ret;\n\n\tmemset(&sa_key_record, 0, sizeof(sa_key_record));\n\tmemcpy(&sa_key_record.key, key, secy->key_len);\n\n\tswitch (secy->key_len) {\n\tcase AQ_MACSEC_KEY_LEN_128_BIT:\n\t\tsa_key_record.key_len = 0;\n\t\tbreak;\n\tcase AQ_MACSEC_KEY_LEN_192_BIT:\n\t\tsa_key_record.key_len = 1;\n\t\tbreak;\n\tcase AQ_MACSEC_KEY_LEN_256_BIT:\n\t\tsa_key_record.key_len = 2;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\taq_rotate_keys(&sa_key_record.key, secy->key_len);\n\n\tret = aq_mss_set_ingress_sakey_record(hw, &sa_key_record, sa_idx);\n\n\tmemzero_explicit(&sa_key_record, sizeof(sa_key_record));\n\treturn ret;\n}\n\nstatic int aq_mdo_add_rxsa(struct macsec_context *ctx)\n{\n\tstruct aq_nic_s *nic = macsec_netdev_priv(ctx->netdev);\n\tconst struct macsec_rx_sc *rx_sc = ctx->sa.rx_sa->sc;\n\tconst struct macsec_secy *secy = ctx->secy;\n\tstruct aq_macsec_rxsc *aq_rxsc;\n\tint rxsc_idx;\n\tint ret = 0;\n\n\trxsc_idx = aq_get_rxsc_idx_from_rxsc(nic->macsec_cfg, rx_sc);\n\tif (rxsc_idx < 0)\n\t\treturn -EINVAL;\n\n\taq_rxsc = &nic->macsec_cfg->aq_rxsc[rxsc_idx];\n\tset_bit(ctx->sa.assoc_num, &aq_rxsc->rx_sa_idx_busy);\n\n\tmemcpy(aq_rxsc->rx_sa_key[ctx->sa.assoc_num], ctx->sa.key,\n\t       secy->key_len);\n\n\tif (netif_carrier_ok(nic->ndev) && netif_running(secy->netdev))\n\t\tret = aq_update_rxsa(nic, aq_rxsc->hw_sc_idx, secy,\n\t\t\t\t     ctx->sa.rx_sa, ctx->sa.key,\n\t\t\t\t     ctx->sa.assoc_num);\n\n\treturn ret;\n}\n\nstatic int aq_mdo_upd_rxsa(struct macsec_context *ctx)\n{\n\tstruct aq_nic_s *nic = macsec_netdev_priv(ctx->netdev);\n\tconst struct macsec_rx_sc *rx_sc = ctx->sa.rx_sa->sc;\n\tstruct aq_macsec_cfg *cfg = nic->macsec_cfg;\n\tconst struct macsec_secy *secy = ctx->secy;\n\tint rxsc_idx;\n\tint ret = 0;\n\n\trxsc_idx = aq_get_rxsc_idx_from_rxsc(cfg, rx_sc);\n\tif (rxsc_idx < 0)\n\t\treturn -EINVAL;\n\n\tif (netif_carrier_ok(nic->ndev) && netif_running(secy->netdev))\n\t\tret = aq_update_rxsa(nic, cfg->aq_rxsc[rxsc_idx].hw_sc_idx,\n\t\t\t\t     secy, ctx->sa.rx_sa, NULL,\n\t\t\t\t     ctx->sa.assoc_num);\n\n\treturn ret;\n}\n\nstatic int aq_clear_rxsa(struct aq_nic_s *nic, struct aq_macsec_rxsc *aq_rxsc,\n\t\t\t const int sa_num, enum aq_clear_type clear_type)\n{\n\tint sa_idx = aq_rxsc->hw_sc_idx | sa_num;\n\tstruct aq_hw_s *hw = nic->aq_hw;\n\tint ret = 0;\n\n\tif (clear_type & AQ_CLEAR_SW)\n\t\tclear_bit(sa_num, &aq_rxsc->rx_sa_idx_busy);\n\n\tif ((clear_type & AQ_CLEAR_HW) && netif_carrier_ok(nic->ndev)) {\n\t\tstruct aq_mss_ingress_sakey_record sa_key_record;\n\t\tstruct aq_mss_ingress_sa_record sa_record;\n\n\t\tmemset(&sa_key_record, 0, sizeof(sa_key_record));\n\t\tmemset(&sa_record, 0, sizeof(sa_record));\n\t\tsa_record.fresh = 1;\n\t\tret = aq_mss_set_ingress_sa_record(hw, &sa_record, sa_idx);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn aq_mss_set_ingress_sakey_record(hw, &sa_key_record,\n\t\t\t\t\t\t       sa_idx);\n\t}\n\n\treturn ret;\n}\n\nstatic int aq_mdo_del_rxsa(struct macsec_context *ctx)\n{\n\tstruct aq_nic_s *nic = macsec_netdev_priv(ctx->netdev);\n\tconst struct macsec_rx_sc *rx_sc = ctx->sa.rx_sa->sc;\n\tstruct aq_macsec_cfg *cfg = nic->macsec_cfg;\n\tint rxsc_idx;\n\tint ret = 0;\n\n\trxsc_idx = aq_get_rxsc_idx_from_rxsc(cfg, rx_sc);\n\tif (rxsc_idx < 0)\n\t\treturn -EINVAL;\n\n\tret = aq_clear_rxsa(nic, &cfg->aq_rxsc[rxsc_idx], ctx->sa.assoc_num,\n\t\t\t    AQ_CLEAR_ALL);\n\n\treturn ret;\n}\n\nstatic int aq_mdo_get_dev_stats(struct macsec_context *ctx)\n{\n\tstruct aq_nic_s *nic = macsec_netdev_priv(ctx->netdev);\n\tstruct aq_macsec_common_stats *stats = &nic->macsec_cfg->stats;\n\tstruct aq_hw_s *hw = nic->aq_hw;\n\n\taq_get_macsec_common_stats(hw, stats);\n\n\tctx->stats.dev_stats->OutPktsUntagged = stats->out.untagged_pkts;\n\tctx->stats.dev_stats->InPktsUntagged = stats->in.untagged_pkts;\n\tctx->stats.dev_stats->OutPktsTooLong = stats->out.too_long;\n\tctx->stats.dev_stats->InPktsNoTag = stats->in.notag_pkts;\n\tctx->stats.dev_stats->InPktsBadTag = stats->in.bad_tag_pkts;\n\tctx->stats.dev_stats->InPktsUnknownSCI = stats->in.unknown_sci_pkts;\n\tctx->stats.dev_stats->InPktsNoSCI = stats->in.no_sci_pkts;\n\tctx->stats.dev_stats->InPktsOverrun = 0;\n\n\treturn 0;\n}\n\nstatic int aq_mdo_get_tx_sc_stats(struct macsec_context *ctx)\n{\n\tstruct aq_nic_s *nic = macsec_netdev_priv(ctx->netdev);\n\tstruct aq_macsec_tx_sc_stats *stats;\n\tstruct aq_hw_s *hw = nic->aq_hw;\n\tstruct aq_macsec_txsc *aq_txsc;\n\tint txsc_idx;\n\n\ttxsc_idx = aq_get_txsc_idx_from_secy(nic->macsec_cfg, ctx->secy);\n\tif (txsc_idx < 0)\n\t\treturn -ENOENT;\n\n\taq_txsc = &nic->macsec_cfg->aq_txsc[txsc_idx];\n\tstats = &aq_txsc->stats;\n\taq_get_txsc_stats(hw, aq_txsc->hw_sc_idx, stats);\n\n\tctx->stats.tx_sc_stats->OutPktsProtected = stats->sc_protected_pkts;\n\tctx->stats.tx_sc_stats->OutPktsEncrypted = stats->sc_encrypted_pkts;\n\tctx->stats.tx_sc_stats->OutOctetsProtected = stats->sc_protected_octets;\n\tctx->stats.tx_sc_stats->OutOctetsEncrypted = stats->sc_encrypted_octets;\n\n\treturn 0;\n}\n\nstatic int aq_mdo_get_tx_sa_stats(struct macsec_context *ctx)\n{\n\tstruct aq_nic_s *nic = macsec_netdev_priv(ctx->netdev);\n\tstruct aq_macsec_cfg *cfg = nic->macsec_cfg;\n\tstruct aq_macsec_tx_sa_stats *stats;\n\tstruct aq_hw_s *hw = nic->aq_hw;\n\tconst struct macsec_secy *secy;\n\tstruct aq_macsec_txsc *aq_txsc;\n\tstruct macsec_tx_sa *tx_sa;\n\tunsigned int sa_idx;\n\tint txsc_idx;\n\tu32 next_pn;\n\tint ret;\n\n\ttxsc_idx = aq_get_txsc_idx_from_secy(cfg, ctx->secy);\n\tif (txsc_idx < 0)\n\t\treturn -EINVAL;\n\n\taq_txsc = &cfg->aq_txsc[txsc_idx];\n\tsa_idx = aq_txsc->hw_sc_idx | ctx->sa.assoc_num;\n\tstats = &aq_txsc->tx_sa_stats[ctx->sa.assoc_num];\n\tret = aq_get_txsa_stats(hw, sa_idx, stats);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->stats.tx_sa_stats->OutPktsProtected = stats->sa_protected_pkts;\n\tctx->stats.tx_sa_stats->OutPktsEncrypted = stats->sa_encrypted_pkts;\n\n\tsecy = aq_txsc->sw_secy;\n\ttx_sa = rcu_dereference_bh(secy->tx_sc.sa[ctx->sa.assoc_num]);\n\tret = aq_get_txsa_next_pn(hw, sa_idx, &next_pn);\n\tif (ret == 0) {\n\t\tspin_lock_bh(&tx_sa->lock);\n\t\ttx_sa->next_pn = next_pn;\n\t\tspin_unlock_bh(&tx_sa->lock);\n\t}\n\n\treturn ret;\n}\n\nstatic int aq_mdo_get_rx_sc_stats(struct macsec_context *ctx)\n{\n\tstruct aq_nic_s *nic = macsec_netdev_priv(ctx->netdev);\n\tstruct aq_macsec_cfg *cfg = nic->macsec_cfg;\n\tstruct aq_macsec_rx_sa_stats *stats;\n\tstruct aq_hw_s *hw = nic->aq_hw;\n\tstruct aq_macsec_rxsc *aq_rxsc;\n\tunsigned int sa_idx;\n\tint rxsc_idx;\n\tint ret = 0;\n\tint i;\n\n\trxsc_idx = aq_get_rxsc_idx_from_rxsc(cfg, ctx->rx_sc);\n\tif (rxsc_idx < 0)\n\t\treturn -ENOENT;\n\n\taq_rxsc = &cfg->aq_rxsc[rxsc_idx];\n\tfor (i = 0; i < MACSEC_NUM_AN; i++) {\n\t\tif (!test_bit(i, &aq_rxsc->rx_sa_idx_busy))\n\t\t\tcontinue;\n\n\t\tstats = &aq_rxsc->rx_sa_stats[i];\n\t\tsa_idx = aq_rxsc->hw_sc_idx | i;\n\t\tret = aq_get_rxsa_stats(hw, sa_idx, stats);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tctx->stats.rx_sc_stats->InOctetsValidated +=\n\t\t\tstats->validated_octets;\n\t\tctx->stats.rx_sc_stats->InOctetsDecrypted +=\n\t\t\tstats->decrypted_octets;\n\t\tctx->stats.rx_sc_stats->InPktsUnchecked +=\n\t\t\tstats->unchecked_pkts;\n\t\tctx->stats.rx_sc_stats->InPktsDelayed += stats->delayed_pkts;\n\t\tctx->stats.rx_sc_stats->InPktsOK += stats->ok_pkts;\n\t\tctx->stats.rx_sc_stats->InPktsInvalid += stats->invalid_pkts;\n\t\tctx->stats.rx_sc_stats->InPktsLate += stats->late_pkts;\n\t\tctx->stats.rx_sc_stats->InPktsNotValid += stats->not_valid_pkts;\n\t\tctx->stats.rx_sc_stats->InPktsNotUsingSA += stats->not_using_sa;\n\t\tctx->stats.rx_sc_stats->InPktsUnusedSA += stats->unused_sa;\n\t}\n\n\treturn ret;\n}\n\nstatic int aq_mdo_get_rx_sa_stats(struct macsec_context *ctx)\n{\n\tstruct aq_nic_s *nic = macsec_netdev_priv(ctx->netdev);\n\tstruct aq_macsec_cfg *cfg = nic->macsec_cfg;\n\tstruct aq_macsec_rx_sa_stats *stats;\n\tstruct aq_hw_s *hw = nic->aq_hw;\n\tstruct aq_macsec_rxsc *aq_rxsc;\n\tstruct macsec_rx_sa *rx_sa;\n\tunsigned int sa_idx;\n\tint rxsc_idx;\n\tu32 next_pn;\n\tint ret;\n\n\trxsc_idx = aq_get_rxsc_idx_from_rxsc(cfg, ctx->rx_sc);\n\tif (rxsc_idx < 0)\n\t\treturn -EINVAL;\n\n\taq_rxsc = &cfg->aq_rxsc[rxsc_idx];\n\tstats = &aq_rxsc->rx_sa_stats[ctx->sa.assoc_num];\n\tsa_idx = aq_rxsc->hw_sc_idx | ctx->sa.assoc_num;\n\tret = aq_get_rxsa_stats(hw, sa_idx, stats);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->stats.rx_sa_stats->InPktsOK = stats->ok_pkts;\n\tctx->stats.rx_sa_stats->InPktsInvalid = stats->invalid_pkts;\n\tctx->stats.rx_sa_stats->InPktsNotValid = stats->not_valid_pkts;\n\tctx->stats.rx_sa_stats->InPktsNotUsingSA = stats->not_using_sa;\n\tctx->stats.rx_sa_stats->InPktsUnusedSA = stats->unused_sa;\n\n\trx_sa = rcu_dereference_bh(aq_rxsc->sw_rxsc->sa[ctx->sa.assoc_num]);\n\tret = aq_get_rxsa_next_pn(hw, sa_idx, &next_pn);\n\tif (ret == 0) {\n\t\tspin_lock_bh(&rx_sa->lock);\n\t\trx_sa->next_pn = next_pn;\n\t\tspin_unlock_bh(&rx_sa->lock);\n\t}\n\n\treturn ret;\n}\n\nstatic int apply_txsc_cfg(struct aq_nic_s *nic, const int txsc_idx)\n{\n\tstruct aq_macsec_txsc *aq_txsc = &nic->macsec_cfg->aq_txsc[txsc_idx];\n\tconst struct macsec_secy *secy = aq_txsc->sw_secy;\n\tstruct macsec_tx_sa *tx_sa;\n\tint ret = 0;\n\tint i;\n\n\tif (!netif_running(secy->netdev))\n\t\treturn ret;\n\n\tret = aq_set_txsc(nic, txsc_idx);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < MACSEC_NUM_AN; i++) {\n\t\ttx_sa = rcu_dereference_bh(secy->tx_sc.sa[i]);\n\t\tif (tx_sa) {\n\t\t\tret = aq_update_txsa(nic, aq_txsc->hw_sc_idx, secy,\n\t\t\t\t\t     tx_sa, aq_txsc->tx_sa_key[i], i);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int apply_rxsc_cfg(struct aq_nic_s *nic, const int rxsc_idx)\n{\n\tstruct aq_macsec_rxsc *aq_rxsc = &nic->macsec_cfg->aq_rxsc[rxsc_idx];\n\tconst struct macsec_secy *secy = aq_rxsc->sw_secy;\n\tstruct macsec_rx_sa *rx_sa;\n\tint ret = 0;\n\tint i;\n\n\tif (!netif_running(secy->netdev))\n\t\treturn ret;\n\n\tret = aq_set_rxsc(nic, rxsc_idx);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < MACSEC_NUM_AN; i++) {\n\t\trx_sa = rcu_dereference_bh(aq_rxsc->sw_rxsc->sa[i]);\n\t\tif (rx_sa) {\n\t\t\tret = aq_update_rxsa(nic, aq_rxsc->hw_sc_idx, secy,\n\t\t\t\t\t     rx_sa, aq_rxsc->rx_sa_key[i], i);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int aq_clear_secy(struct aq_nic_s *nic, const struct macsec_secy *secy,\n\t\t\t enum aq_clear_type clear_type)\n{\n\tstruct macsec_rx_sc *rx_sc;\n\tint txsc_idx;\n\tint rxsc_idx;\n\tint ret = 0;\n\n\ttxsc_idx = aq_get_txsc_idx_from_secy(nic->macsec_cfg, secy);\n\tif (txsc_idx >= 0) {\n\t\tret = aq_clear_txsc(nic, txsc_idx, clear_type);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (rx_sc = rcu_dereference_bh(secy->rx_sc); rx_sc;\n\t     rx_sc = rcu_dereference_bh(rx_sc->next)) {\n\t\trxsc_idx = aq_get_rxsc_idx_from_rxsc(nic->macsec_cfg, rx_sc);\n\t\tif (rxsc_idx < 0)\n\t\t\tcontinue;\n\n\t\tret = aq_clear_rxsc(nic, rxsc_idx, clear_type);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int aq_apply_secy_cfg(struct aq_nic_s *nic,\n\t\t\t     const struct macsec_secy *secy)\n{\n\tstruct macsec_rx_sc *rx_sc;\n\tint txsc_idx;\n\tint rxsc_idx;\n\tint ret = 0;\n\n\ttxsc_idx = aq_get_txsc_idx_from_secy(nic->macsec_cfg, secy);\n\tif (txsc_idx >= 0)\n\t\tapply_txsc_cfg(nic, txsc_idx);\n\n\tfor (rx_sc = rcu_dereference_bh(secy->rx_sc); rx_sc && rx_sc->active;\n\t     rx_sc = rcu_dereference_bh(rx_sc->next)) {\n\t\trxsc_idx = aq_get_rxsc_idx_from_rxsc(nic->macsec_cfg, rx_sc);\n\t\tif (unlikely(rxsc_idx < 0))\n\t\t\tcontinue;\n\n\t\tret = apply_rxsc_cfg(nic, rxsc_idx);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int aq_apply_macsec_cfg(struct aq_nic_s *nic)\n{\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < AQ_MACSEC_MAX_SC; i++) {\n\t\tif (nic->macsec_cfg->txsc_idx_busy & BIT(i)) {\n\t\t\tret = apply_txsc_cfg(nic, i);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor (i = 0; i < AQ_MACSEC_MAX_SC; i++) {\n\t\tif (nic->macsec_cfg->rxsc_idx_busy & BIT(i)) {\n\t\t\tret = apply_rxsc_cfg(nic, i);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int aq_sa_from_sa_idx(const enum aq_macsec_sc_sa sc_sa, const int sa_idx)\n{\n\tswitch (sc_sa) {\n\tcase aq_macsec_sa_sc_4sa_8sc:\n\t\treturn sa_idx & 3;\n\tcase aq_macsec_sa_sc_2sa_16sc:\n\t\treturn sa_idx & 1;\n\tcase aq_macsec_sa_sc_1sa_32sc:\n\t\treturn 0;\n\tdefault:\n\t\tWARN_ONCE(true, \"Invalid sc_sa\");\n\t}\n\treturn -EINVAL;\n}\n\nstatic int aq_sc_idx_from_sa_idx(const enum aq_macsec_sc_sa sc_sa,\n\t\t\t\t const int sa_idx)\n{\n\tswitch (sc_sa) {\n\tcase aq_macsec_sa_sc_4sa_8sc:\n\t\treturn sa_idx & ~3;\n\tcase aq_macsec_sa_sc_2sa_16sc:\n\t\treturn sa_idx & ~1;\n\tcase aq_macsec_sa_sc_1sa_32sc:\n\t\treturn sa_idx;\n\tdefault:\n\t\tWARN_ONCE(true, \"Invalid sc_sa\");\n\t}\n\treturn -EINVAL;\n}\n\nstatic void aq_check_txsa_expiration(struct aq_nic_s *nic)\n{\n\tu32 egress_sa_expired, egress_sa_threshold_expired;\n\tstruct aq_macsec_cfg *cfg = nic->macsec_cfg;\n\tstruct aq_hw_s *hw = nic->aq_hw;\n\tstruct aq_macsec_txsc *aq_txsc;\n\tconst struct macsec_secy *secy;\n\tint sc_idx = 0, txsc_idx = 0;\n\tenum aq_macsec_sc_sa sc_sa;\n\tstruct macsec_tx_sa *tx_sa;\n\tunsigned char an = 0;\n\tint ret;\n\tint i;\n\n\tsc_sa = cfg->sc_sa;\n\n\tret = aq_mss_get_egress_sa_expired(hw, &egress_sa_expired);\n\tif (unlikely(ret))\n\t\treturn;\n\n\tret = aq_mss_get_egress_sa_threshold_expired(hw,\n\t\t&egress_sa_threshold_expired);\n\n\tfor (i = 0; i < AQ_MACSEC_MAX_SA; i++) {\n\t\tif (egress_sa_expired & BIT(i)) {\n\t\t\tan = aq_sa_from_sa_idx(sc_sa, i);\n\t\t\tsc_idx = aq_sc_idx_from_sa_idx(sc_sa, i);\n\t\t\ttxsc_idx = aq_get_txsc_idx_from_sc_idx(sc_sa, sc_idx);\n\t\t\tif (txsc_idx < 0)\n\t\t\t\tcontinue;\n\n\t\t\taq_txsc = &cfg->aq_txsc[txsc_idx];\n\t\t\tif (!(cfg->txsc_idx_busy & BIT(txsc_idx))) {\n\t\t\t\tnetdev_warn(nic->ndev,\n\t\t\t\t\t\"PN threshold expired on invalid TX SC\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tsecy = aq_txsc->sw_secy;\n\t\t\tif (!netif_running(secy->netdev)) {\n\t\t\t\tnetdev_warn(nic->ndev,\n\t\t\t\t\t\"PN threshold expired on down TX SC\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (unlikely(!(aq_txsc->tx_sa_idx_busy & BIT(an)))) {\n\t\t\t\tnetdev_warn(nic->ndev,\n\t\t\t\t\t\"PN threshold expired on invalid TX SA\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttx_sa = rcu_dereference_bh(secy->tx_sc.sa[an]);\n\t\t\tmacsec_pn_wrapped((struct macsec_secy *)secy, tx_sa);\n\t\t}\n\t}\n\n\taq_mss_set_egress_sa_expired(hw, egress_sa_expired);\n\tif (likely(!ret))\n\t\taq_mss_set_egress_sa_threshold_expired(hw,\n\t\t\tegress_sa_threshold_expired);\n}\n\n#define AQ_LOCKED_MDO_DEF(mdo)\t\t\t\t\t\t\\\nstatic int aq_locked_mdo_##mdo(struct macsec_context *ctx)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct aq_nic_s *nic = macsec_netdev_priv(ctx->netdev);\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tmutex_lock(&nic->macsec_mutex);\t\t\t\t\t\\\n\tret = aq_mdo_##mdo(ctx);\t\t\t\t\t\\\n\tmutex_unlock(&nic->macsec_mutex);\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\n\nAQ_LOCKED_MDO_DEF(dev_open)\nAQ_LOCKED_MDO_DEF(dev_stop)\nAQ_LOCKED_MDO_DEF(add_secy)\nAQ_LOCKED_MDO_DEF(upd_secy)\nAQ_LOCKED_MDO_DEF(del_secy)\nAQ_LOCKED_MDO_DEF(add_rxsc)\nAQ_LOCKED_MDO_DEF(upd_rxsc)\nAQ_LOCKED_MDO_DEF(del_rxsc)\nAQ_LOCKED_MDO_DEF(add_rxsa)\nAQ_LOCKED_MDO_DEF(upd_rxsa)\nAQ_LOCKED_MDO_DEF(del_rxsa)\nAQ_LOCKED_MDO_DEF(add_txsa)\nAQ_LOCKED_MDO_DEF(upd_txsa)\nAQ_LOCKED_MDO_DEF(del_txsa)\nAQ_LOCKED_MDO_DEF(get_dev_stats)\nAQ_LOCKED_MDO_DEF(get_tx_sc_stats)\nAQ_LOCKED_MDO_DEF(get_tx_sa_stats)\nAQ_LOCKED_MDO_DEF(get_rx_sc_stats)\nAQ_LOCKED_MDO_DEF(get_rx_sa_stats)\n\nconst struct macsec_ops aq_macsec_ops = {\n\t.mdo_dev_open = aq_locked_mdo_dev_open,\n\t.mdo_dev_stop = aq_locked_mdo_dev_stop,\n\t.mdo_add_secy = aq_locked_mdo_add_secy,\n\t.mdo_upd_secy = aq_locked_mdo_upd_secy,\n\t.mdo_del_secy = aq_locked_mdo_del_secy,\n\t.mdo_add_rxsc = aq_locked_mdo_add_rxsc,\n\t.mdo_upd_rxsc = aq_locked_mdo_upd_rxsc,\n\t.mdo_del_rxsc = aq_locked_mdo_del_rxsc,\n\t.mdo_add_rxsa = aq_locked_mdo_add_rxsa,\n\t.mdo_upd_rxsa = aq_locked_mdo_upd_rxsa,\n\t.mdo_del_rxsa = aq_locked_mdo_del_rxsa,\n\t.mdo_add_txsa = aq_locked_mdo_add_txsa,\n\t.mdo_upd_txsa = aq_locked_mdo_upd_txsa,\n\t.mdo_del_txsa = aq_locked_mdo_del_txsa,\n\t.mdo_get_dev_stats = aq_locked_mdo_get_dev_stats,\n\t.mdo_get_tx_sc_stats = aq_locked_mdo_get_tx_sc_stats,\n\t.mdo_get_tx_sa_stats = aq_locked_mdo_get_tx_sa_stats,\n\t.mdo_get_rx_sc_stats = aq_locked_mdo_get_rx_sc_stats,\n\t.mdo_get_rx_sa_stats = aq_locked_mdo_get_rx_sa_stats,\n};\n\nint aq_macsec_init(struct aq_nic_s *nic)\n{\n\tstruct aq_macsec_cfg *cfg;\n\tu32 caps_lo;\n\n\tif (!nic->aq_fw_ops->get_link_capabilities)\n\t\treturn 0;\n\n\tcaps_lo = nic->aq_fw_ops->get_link_capabilities(nic->aq_hw);\n\n\tif (!(caps_lo & BIT(CAPS_LO_MACSEC)))\n\t\treturn 0;\n\n\tnic->macsec_cfg = kzalloc(sizeof(*cfg), GFP_KERNEL);\n\tif (!nic->macsec_cfg)\n\t\treturn -ENOMEM;\n\n\tnic->ndev->features |= NETIF_F_HW_MACSEC;\n\tnic->ndev->macsec_ops = &aq_macsec_ops;\n\tmutex_init(&nic->macsec_mutex);\n\n\treturn 0;\n}\n\nvoid aq_macsec_free(struct aq_nic_s *nic)\n{\n\tkfree(nic->macsec_cfg);\n\tnic->macsec_cfg = NULL;\n}\n\nint aq_macsec_enable(struct aq_nic_s *nic)\n{\n\tu32 ctl_ether_types[1] = { ETH_P_PAE };\n\tstruct macsec_msg_fw_response resp = { 0 };\n\tstruct macsec_msg_fw_request msg = { 0 };\n\tstruct aq_hw_s *hw = nic->aq_hw;\n\tint num_ctl_ether_types = 0;\n\tint index = 0, tbl_idx;\n\tint ret;\n\n\tif (!nic->macsec_cfg)\n\t\treturn 0;\n\n\tmutex_lock(&nic->macsec_mutex);\n\n\tif (nic->aq_fw_ops->send_macsec_req) {\n\t\tstruct macsec_cfg_request cfg = { 0 };\n\n\t\tcfg.enabled = 1;\n\t\tcfg.egress_threshold = 0xffffffff;\n\t\tcfg.ingress_threshold = 0xffffffff;\n\t\tcfg.interrupts_enabled = 1;\n\n\t\tmsg.msg_type = macsec_cfg_msg;\n\t\tmsg.cfg = cfg;\n\n\t\tret = nic->aq_fw_ops->send_macsec_req(hw, &msg, &resp);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\n\t \n\tfor (index = 0; index < ARRAY_SIZE(ctl_ether_types); index++) {\n\t\tstruct aq_mss_ingress_prectlf_record rx_prectlf_rec;\n\t\tstruct aq_mss_egress_ctlf_record tx_ctlf_rec;\n\n\t\tif (ctl_ether_types[index] == 0)\n\t\t\tcontinue;\n\n\t\tmemset(&tx_ctlf_rec, 0, sizeof(tx_ctlf_rec));\n\t\ttx_ctlf_rec.eth_type = ctl_ether_types[index];\n\t\ttx_ctlf_rec.match_type = 4;  \n\t\ttx_ctlf_rec.match_mask = 0xf;  \n\t\ttx_ctlf_rec.action = 0;  \n\t\ttbl_idx = NUMROWS_EGRESSCTLFRECORD - num_ctl_ether_types - 1;\n\t\taq_mss_set_egress_ctlf_record(hw, &tx_ctlf_rec, tbl_idx);\n\n\t\tmemset(&rx_prectlf_rec, 0, sizeof(rx_prectlf_rec));\n\t\trx_prectlf_rec.eth_type = ctl_ether_types[index];\n\t\trx_prectlf_rec.match_type = 4;  \n\t\trx_prectlf_rec.match_mask = 0xf;  \n\t\trx_prectlf_rec.action = 0;  \n\t\ttbl_idx =\n\t\t\tNUMROWS_INGRESSPRECTLFRECORD - num_ctl_ether_types - 1;\n\t\taq_mss_set_ingress_prectlf_record(hw, &rx_prectlf_rec, tbl_idx);\n\n\t\tnum_ctl_ether_types++;\n\t}\n\n\tret = aq_apply_macsec_cfg(nic);\n\nunlock:\n\tmutex_unlock(&nic->macsec_mutex);\n\treturn ret;\n}\n\nvoid aq_macsec_work(struct aq_nic_s *nic)\n{\n\tif (!nic->macsec_cfg)\n\t\treturn;\n\n\tif (!netif_carrier_ok(nic->ndev))\n\t\treturn;\n\n\tmutex_lock(&nic->macsec_mutex);\n\taq_check_txsa_expiration(nic);\n\tmutex_unlock(&nic->macsec_mutex);\n}\n\nint aq_macsec_rx_sa_cnt(struct aq_nic_s *nic)\n{\n\tstruct aq_macsec_cfg *cfg = nic->macsec_cfg;\n\tint i, cnt = 0;\n\n\tif (!cfg)\n\t\treturn 0;\n\n\tmutex_lock(&nic->macsec_mutex);\n\n\tfor (i = 0; i < AQ_MACSEC_MAX_SC; i++) {\n\t\tif (!test_bit(i, &cfg->rxsc_idx_busy))\n\t\t\tcontinue;\n\t\tcnt += hweight_long(cfg->aq_rxsc[i].rx_sa_idx_busy);\n\t}\n\n\tmutex_unlock(&nic->macsec_mutex);\n\treturn cnt;\n}\n\nint aq_macsec_tx_sc_cnt(struct aq_nic_s *nic)\n{\n\tint cnt;\n\n\tif (!nic->macsec_cfg)\n\t\treturn 0;\n\n\tmutex_lock(&nic->macsec_mutex);\n\tcnt = hweight_long(nic->macsec_cfg->txsc_idx_busy);\n\tmutex_unlock(&nic->macsec_mutex);\n\n\treturn cnt;\n}\n\nint aq_macsec_tx_sa_cnt(struct aq_nic_s *nic)\n{\n\tstruct aq_macsec_cfg *cfg = nic->macsec_cfg;\n\tint i, cnt = 0;\n\n\tif (!cfg)\n\t\treturn 0;\n\n\tmutex_lock(&nic->macsec_mutex);\n\n\tfor (i = 0; i < AQ_MACSEC_MAX_SC; i++) {\n\t\tif (!test_bit(i, &cfg->txsc_idx_busy))\n\t\t\tcontinue;\n\t\tcnt += hweight_long(cfg->aq_txsc[i].tx_sa_idx_busy);\n\t}\n\n\tmutex_unlock(&nic->macsec_mutex);\n\treturn cnt;\n}\n\nstatic int aq_macsec_update_stats(struct aq_nic_s *nic)\n{\n\tstruct aq_macsec_cfg *cfg = nic->macsec_cfg;\n\tstruct aq_hw_s *hw = nic->aq_hw;\n\tstruct aq_macsec_txsc *aq_txsc;\n\tstruct aq_macsec_rxsc *aq_rxsc;\n\tint i, sa_idx, assoc_num;\n\tint ret = 0;\n\n\taq_get_macsec_common_stats(hw, &cfg->stats);\n\n\tfor (i = 0; i < AQ_MACSEC_MAX_SC; i++) {\n\t\tif (!(cfg->txsc_idx_busy & BIT(i)))\n\t\t\tcontinue;\n\t\taq_txsc = &cfg->aq_txsc[i];\n\n\t\tret = aq_get_txsc_stats(hw, aq_txsc->hw_sc_idx,\n\t\t\t\t\t&aq_txsc->stats);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tfor (assoc_num = 0; assoc_num < MACSEC_NUM_AN; assoc_num++) {\n\t\t\tif (!test_bit(assoc_num, &aq_txsc->tx_sa_idx_busy))\n\t\t\t\tcontinue;\n\t\t\tsa_idx = aq_txsc->hw_sc_idx | assoc_num;\n\t\t\tret = aq_get_txsa_stats(hw, sa_idx,\n\t\t\t\t\t      &aq_txsc->tx_sa_stats[assoc_num]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor (i = 0; i < AQ_MACSEC_MAX_SC; i++) {\n\t\tif (!(test_bit(i, &cfg->rxsc_idx_busy)))\n\t\t\tcontinue;\n\t\taq_rxsc = &cfg->aq_rxsc[i];\n\n\t\tfor (assoc_num = 0; assoc_num < MACSEC_NUM_AN; assoc_num++) {\n\t\t\tif (!test_bit(assoc_num, &aq_rxsc->rx_sa_idx_busy))\n\t\t\t\tcontinue;\n\t\t\tsa_idx = aq_rxsc->hw_sc_idx | assoc_num;\n\n\t\t\tret = aq_get_rxsa_stats(hw, sa_idx,\n\t\t\t\t\t      &aq_rxsc->rx_sa_stats[assoc_num]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nu64 *aq_macsec_get_stats(struct aq_nic_s *nic, u64 *data)\n{\n\tstruct aq_macsec_cfg *cfg = nic->macsec_cfg;\n\tstruct aq_macsec_common_stats *common_stats;\n\tstruct aq_macsec_tx_sc_stats *txsc_stats;\n\tstruct aq_macsec_tx_sa_stats *txsa_stats;\n\tstruct aq_macsec_rx_sa_stats *rxsa_stats;\n\tstruct aq_macsec_txsc *aq_txsc;\n\tstruct aq_macsec_rxsc *aq_rxsc;\n\tunsigned int assoc_num;\n\tunsigned int sc_num;\n\tunsigned int i = 0U;\n\n\tif (!cfg)\n\t\treturn data;\n\n\tmutex_lock(&nic->macsec_mutex);\n\n\taq_macsec_update_stats(nic);\n\n\tcommon_stats = &cfg->stats;\n\tdata[i] = common_stats->in.ctl_pkts;\n\tdata[++i] = common_stats->in.tagged_miss_pkts;\n\tdata[++i] = common_stats->in.untagged_miss_pkts;\n\tdata[++i] = common_stats->in.notag_pkts;\n\tdata[++i] = common_stats->in.untagged_pkts;\n\tdata[++i] = common_stats->in.bad_tag_pkts;\n\tdata[++i] = common_stats->in.no_sci_pkts;\n\tdata[++i] = common_stats->in.unknown_sci_pkts;\n\tdata[++i] = common_stats->in.ctrl_prt_pass_pkts;\n\tdata[++i] = common_stats->in.unctrl_prt_pass_pkts;\n\tdata[++i] = common_stats->in.ctrl_prt_fail_pkts;\n\tdata[++i] = common_stats->in.unctrl_prt_fail_pkts;\n\tdata[++i] = common_stats->in.too_long_pkts;\n\tdata[++i] = common_stats->in.igpoc_ctl_pkts;\n\tdata[++i] = common_stats->in.ecc_error_pkts;\n\tdata[++i] = common_stats->in.unctrl_hit_drop_redir;\n\tdata[++i] = common_stats->out.ctl_pkts;\n\tdata[++i] = common_stats->out.unknown_sa_pkts;\n\tdata[++i] = common_stats->out.untagged_pkts;\n\tdata[++i] = common_stats->out.too_long;\n\tdata[++i] = common_stats->out.ecc_error_pkts;\n\tdata[++i] = common_stats->out.unctrl_hit_drop_redir;\n\n\tfor (sc_num = 0; sc_num < AQ_MACSEC_MAX_SC; sc_num++) {\n\t\tif (!(test_bit(sc_num, &cfg->txsc_idx_busy)))\n\t\t\tcontinue;\n\n\t\taq_txsc = &cfg->aq_txsc[sc_num];\n\t\ttxsc_stats = &aq_txsc->stats;\n\n\t\tdata[++i] = txsc_stats->sc_protected_pkts;\n\t\tdata[++i] = txsc_stats->sc_encrypted_pkts;\n\t\tdata[++i] = txsc_stats->sc_protected_octets;\n\t\tdata[++i] = txsc_stats->sc_encrypted_octets;\n\n\t\tfor (assoc_num = 0; assoc_num < MACSEC_NUM_AN; assoc_num++) {\n\t\t\tif (!test_bit(assoc_num, &aq_txsc->tx_sa_idx_busy))\n\t\t\t\tcontinue;\n\n\t\t\ttxsa_stats = &aq_txsc->tx_sa_stats[assoc_num];\n\n\t\t\tdata[++i] = txsa_stats->sa_hit_drop_redirect;\n\t\t\tdata[++i] = txsa_stats->sa_protected2_pkts;\n\t\t\tdata[++i] = txsa_stats->sa_protected_pkts;\n\t\t\tdata[++i] = txsa_stats->sa_encrypted_pkts;\n\t\t}\n\t}\n\n\tfor (sc_num = 0; sc_num < AQ_MACSEC_MAX_SC; sc_num++) {\n\t\tif (!(test_bit(sc_num, &cfg->rxsc_idx_busy)))\n\t\t\tcontinue;\n\n\t\taq_rxsc = &cfg->aq_rxsc[sc_num];\n\n\t\tfor (assoc_num = 0; assoc_num < MACSEC_NUM_AN; assoc_num++) {\n\t\t\tif (!test_bit(assoc_num, &aq_rxsc->rx_sa_idx_busy))\n\t\t\t\tcontinue;\n\n\t\t\trxsa_stats = &aq_rxsc->rx_sa_stats[assoc_num];\n\n\t\t\tdata[++i] = rxsa_stats->untagged_hit_pkts;\n\t\t\tdata[++i] = rxsa_stats->ctrl_hit_drop_redir_pkts;\n\t\t\tdata[++i] = rxsa_stats->not_using_sa;\n\t\t\tdata[++i] = rxsa_stats->unused_sa;\n\t\t\tdata[++i] = rxsa_stats->not_valid_pkts;\n\t\t\tdata[++i] = rxsa_stats->invalid_pkts;\n\t\t\tdata[++i] = rxsa_stats->ok_pkts;\n\t\t\tdata[++i] = rxsa_stats->late_pkts;\n\t\t\tdata[++i] = rxsa_stats->delayed_pkts;\n\t\t\tdata[++i] = rxsa_stats->unchecked_pkts;\n\t\t\tdata[++i] = rxsa_stats->validated_octets;\n\t\t\tdata[++i] = rxsa_stats->decrypted_octets;\n\t\t}\n\t}\n\n\ti++;\n\n\tdata += i;\n\n\tmutex_unlock(&nic->macsec_mutex);\n\n\treturn data;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}