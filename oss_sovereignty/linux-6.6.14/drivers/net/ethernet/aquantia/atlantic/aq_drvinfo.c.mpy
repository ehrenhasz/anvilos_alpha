{
  "module_name": "aq_drvinfo.c",
  "hash_id": "bc55a2d4f2ee7e3c512b223c86d0764145caf967e1031169a79ac8a95350ffb5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/aquantia/atlantic/aq_drvinfo.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/init.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/stat.h>\n#include <linux/string.h>\n#include <linux/hwmon.h>\n#include <linux/uaccess.h>\n\n#include \"aq_drvinfo.h\"\n#include \"aq_nic.h\"\n\n#if IS_REACHABLE(CONFIG_HWMON)\nstatic const char * const atl_temp_label[] = {\n\t\"PHY Temperature\",\n\t\"MAC Temperature\",\n};\n\nstatic int aq_hwmon_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t u32 attr, int channel, long *value)\n{\n\tstruct aq_nic_s *aq_nic = dev_get_drvdata(dev);\n\tint err = 0;\n\tint temp;\n\n\tif (!aq_nic)\n\t\treturn -EIO;\n\n\tif (type != hwmon_temp || attr != hwmon_temp_input)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (channel) {\n\tcase 0:\n\t\tif (!aq_nic->aq_fw_ops->get_phy_temp)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = aq_nic->aq_fw_ops->get_phy_temp(aq_nic->aq_hw, &temp);\n\t\t*value = temp;\n\t\tbreak;\n\tcase 1:\n\t\tif (!aq_nic->aq_fw_ops->get_mac_temp &&\n\t\t    !aq_nic->aq_hw_ops->hw_get_mac_temp)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (aq_nic->aq_fw_ops->get_mac_temp)\n\t\t\terr = aq_nic->aq_fw_ops->get_mac_temp(aq_nic->aq_hw, &temp);\n\t\telse\n\t\t\terr = aq_nic->aq_hw_ops->hw_get_mac_temp(aq_nic->aq_hw, &temp);\n\t\t*value = temp;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\nstatic int aq_hwmon_read_string(struct device *dev,\n\t\t\t\tenum hwmon_sensor_types type,\n\t\t\t\tu32 attr, int channel, const char **str)\n{\n\tstruct aq_nic_s *aq_nic = dev_get_drvdata(dev);\n\n\tif (!aq_nic)\n\t\treturn -EIO;\n\n\tif (type != hwmon_temp || attr != hwmon_temp_label)\n\t\treturn -EOPNOTSUPP;\n\n\tif (channel < ARRAY_SIZE(atl_temp_label))\n\t\t*str = atl_temp_label[channel];\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic umode_t aq_hwmon_is_visible(const void *data,\n\t\t\t\t   enum hwmon_sensor_types type,\n\t\t\t\t   u32 attr, int channel)\n{\n\tconst struct aq_nic_s *nic = data;\n\n\tif (type != hwmon_temp)\n\t\treturn 0;\n\n\tif (channel == 0 && !nic->aq_fw_ops->get_phy_temp)\n\t\treturn 0;\n\telse if (channel == 1 && !nic->aq_fw_ops->get_mac_temp &&\n\t\t !nic->aq_hw_ops->hw_get_mac_temp)\n\t\treturn 0;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\tcase hwmon_temp_label:\n\t\treturn 0444;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic const struct hwmon_ops aq_hwmon_ops = {\n\t.is_visible = aq_hwmon_is_visible,\n\t.read = aq_hwmon_read,\n\t.read_string = aq_hwmon_read_string,\n};\n\nstatic u32 aq_hwmon_temp_config[] = {\n\tHWMON_T_INPUT | HWMON_T_LABEL,\n\tHWMON_T_INPUT | HWMON_T_LABEL,\n\t0,\n};\n\nstatic const struct hwmon_channel_info aq_hwmon_temp = {\n\t.type = hwmon_temp,\n\t.config = aq_hwmon_temp_config,\n};\n\nstatic const struct hwmon_channel_info * const aq_hwmon_info[] = {\n\t&aq_hwmon_temp,\n\tNULL,\n};\n\nstatic const struct hwmon_chip_info aq_hwmon_chip_info = {\n\t.ops = &aq_hwmon_ops,\n\t.info = aq_hwmon_info,\n};\n\nint aq_drvinfo_init(struct net_device *ndev)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tstruct device *dev = &aq_nic->pdev->dev;\n\tstruct device *hwmon_dev;\n\tint err = 0;\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev,\n\t\t\t\t\t\t\t ndev->name,\n\t\t\t\t\t\t\t aq_nic,\n\t\t\t\t\t\t\t &aq_hwmon_chip_info,\n\t\t\t\t\t\t\t NULL);\n\n\tif (IS_ERR(hwmon_dev))\n\t\terr = PTR_ERR(hwmon_dev);\n\n\treturn err;\n}\n\n#else\nint aq_drvinfo_init(struct net_device *ndev) { return 0; }\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}