{
  "module_name": "aq_ethtool.c",
  "hash_id": "cd4e7c15ed87b2089157fc036b424d348cda10e3046461472d18d641691e2cb9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/aquantia/atlantic/aq_ethtool.c",
  "human_readable_source": "\n \n\n \n\n#include \"aq_ethtool.h\"\n#include \"aq_nic.h\"\n#include \"aq_vec.h\"\n#include \"aq_ptp.h\"\n#include \"aq_filters.h\"\n#include \"aq_macsec.h\"\n#include \"aq_main.h\"\n\n#include <linux/ptp_clock_kernel.h>\n\nstatic void aq_ethtool_get_regs(struct net_device *ndev,\n\t\t\t\tstruct ethtool_regs *regs, void *p)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tu32 regs_count;\n\n\tregs_count = aq_nic_get_regs_count(aq_nic);\n\n\tmemset(p, 0, regs_count * sizeof(u32));\n\taq_nic_get_regs(aq_nic, regs, p);\n}\n\nstatic int aq_ethtool_get_regs_len(struct net_device *ndev)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tu32 regs_count;\n\n\tregs_count = aq_nic_get_regs_count(aq_nic);\n\n\treturn regs_count * sizeof(u32);\n}\n\nstatic u32 aq_ethtool_get_link(struct net_device *ndev)\n{\n\treturn ethtool_op_get_link(ndev);\n}\n\nstatic int aq_ethtool_get_link_ksettings(struct net_device *ndev,\n\t\t\t\t\t struct ethtool_link_ksettings *cmd)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\n\taq_nic_get_link_ksettings(aq_nic, cmd);\n\tcmd->base.speed = netif_carrier_ok(ndev) ?\n\t\t\t\taq_nic_get_link_speed(aq_nic) : 0U;\n\n\treturn 0;\n}\n\nstatic int\naq_ethtool_set_link_ksettings(struct net_device *ndev,\n\t\t\t      const struct ethtool_link_ksettings *cmd)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\n\treturn aq_nic_set_link_ksettings(aq_nic, cmd);\n}\n\nstatic const char aq_ethtool_stat_names[][ETH_GSTRING_LEN] = {\n\t\"InPackets\",\n\t\"InUCast\",\n\t\"InMCast\",\n\t\"InBCast\",\n\t\"InErrors\",\n\t\"OutPackets\",\n\t\"OutUCast\",\n\t\"OutMCast\",\n\t\"OutBCast\",\n\t\"InUCastOctets\",\n\t\"OutUCastOctets\",\n\t\"InMCastOctets\",\n\t\"OutMCastOctets\",\n\t\"InBCastOctets\",\n\t\"OutBCastOctets\",\n\t\"InOctets\",\n\t\"OutOctets\",\n\t\"InPacketsDma\",\n\t\"OutPacketsDma\",\n\t\"InOctetsDma\",\n\t\"OutOctetsDma\",\n\t\"InDroppedDma\",\n};\n\nstatic const char * const aq_ethtool_queue_rx_stat_names[] = {\n\t\"%sQueue[%d] InPackets\",\n\t\"%sQueue[%d] InJumboPackets\",\n\t\"%sQueue[%d] InLroPackets\",\n\t\"%sQueue[%d] InErrors\",\n\t\"%sQueue[%d] AllocFails\",\n\t\"%sQueue[%d] SkbAllocFails\",\n\t\"%sQueue[%d] Polls\",\n\t\"%sQueue[%d] PageFlips\",\n\t\"%sQueue[%d] PageReuses\",\n\t\"%sQueue[%d] PageFrees\",\n\t\"%sQueue[%d] XdpAbort\",\n\t\"%sQueue[%d] XdpDrop\",\n\t\"%sQueue[%d] XdpPass\",\n\t\"%sQueue[%d] XdpTx\",\n\t\"%sQueue[%d] XdpInvalid\",\n\t\"%sQueue[%d] XdpRedirect\",\n};\n\nstatic const char * const aq_ethtool_queue_tx_stat_names[] = {\n\t\"%sQueue[%d] OutPackets\",\n\t\"%sQueue[%d] Restarts\",\n};\n\n#if IS_ENABLED(CONFIG_MACSEC)\nstatic const char aq_macsec_stat_names[][ETH_GSTRING_LEN] = {\n\t\"MACSec InCtlPackets\",\n\t\"MACSec InTaggedMissPackets\",\n\t\"MACSec InUntaggedMissPackets\",\n\t\"MACSec InNotagPackets\",\n\t\"MACSec InUntaggedPackets\",\n\t\"MACSec InBadTagPackets\",\n\t\"MACSec InNoSciPackets\",\n\t\"MACSec InUnknownSciPackets\",\n\t\"MACSec InCtrlPortPassPackets\",\n\t\"MACSec InUnctrlPortPassPackets\",\n\t\"MACSec InCtrlPortFailPackets\",\n\t\"MACSec InUnctrlPortFailPackets\",\n\t\"MACSec InTooLongPackets\",\n\t\"MACSec InIgpocCtlPackets\",\n\t\"MACSec InEccErrorPackets\",\n\t\"MACSec InUnctrlHitDropRedir\",\n\t\"MACSec OutCtlPackets\",\n\t\"MACSec OutUnknownSaPackets\",\n\t\"MACSec OutUntaggedPackets\",\n\t\"MACSec OutTooLong\",\n\t\"MACSec OutEccErrorPackets\",\n\t\"MACSec OutUnctrlHitDropRedir\",\n};\n\nstatic const char * const aq_macsec_txsc_stat_names[] = {\n\t\"MACSecTXSC%d ProtectedPkts\",\n\t\"MACSecTXSC%d EncryptedPkts\",\n\t\"MACSecTXSC%d ProtectedOctets\",\n\t\"MACSecTXSC%d EncryptedOctets\",\n};\n\nstatic const char * const aq_macsec_txsa_stat_names[] = {\n\t\"MACSecTXSC%dSA%d HitDropRedirect\",\n\t\"MACSecTXSC%dSA%d Protected2Pkts\",\n\t\"MACSecTXSC%dSA%d ProtectedPkts\",\n\t\"MACSecTXSC%dSA%d EncryptedPkts\",\n};\n\nstatic const char * const aq_macsec_rxsa_stat_names[] = {\n\t\"MACSecRXSC%dSA%d UntaggedHitPkts\",\n\t\"MACSecRXSC%dSA%d CtrlHitDrpRedir\",\n\t\"MACSecRXSC%dSA%d NotUsingSa\",\n\t\"MACSecRXSC%dSA%d UnusedSa\",\n\t\"MACSecRXSC%dSA%d NotValidPkts\",\n\t\"MACSecRXSC%dSA%d InvalidPkts\",\n\t\"MACSecRXSC%dSA%d OkPkts\",\n\t\"MACSecRXSC%dSA%d LatePkts\",\n\t\"MACSecRXSC%dSA%d DelayedPkts\",\n\t\"MACSecRXSC%dSA%d UncheckedPkts\",\n\t\"MACSecRXSC%dSA%d ValidatedOctets\",\n\t\"MACSecRXSC%dSA%d DecryptedOctets\",\n};\n#endif\n\nstatic const char aq_ethtool_priv_flag_names[][ETH_GSTRING_LEN] = {\n\t\"DMASystemLoopback\",\n\t\"PKTSystemLoopback\",\n\t\"DMANetworkLoopback\",\n\t\"PHYInternalLoopback\",\n\t\"PHYExternalLoopback\",\n};\n\nstatic u32 aq_ethtool_n_stats(struct net_device *ndev)\n{\n\tconst int rx_stat_cnt = ARRAY_SIZE(aq_ethtool_queue_rx_stat_names);\n\tconst int tx_stat_cnt = ARRAY_SIZE(aq_ethtool_queue_tx_stat_names);\n\tstruct aq_nic_s *nic = netdev_priv(ndev);\n\tstruct aq_nic_cfg_s *cfg = aq_nic_get_cfg(nic);\n\tu32 n_stats = ARRAY_SIZE(aq_ethtool_stat_names) +\n\t\t      (rx_stat_cnt + tx_stat_cnt) * cfg->vecs * cfg->tcs;\n\n#if IS_REACHABLE(CONFIG_PTP_1588_CLOCK)\n\tn_stats += rx_stat_cnt * aq_ptp_get_ring_cnt(nic, ATL_RING_RX) +\n\t\t   tx_stat_cnt * aq_ptp_get_ring_cnt(nic, ATL_RING_TX);\n#endif\n\n#if IS_ENABLED(CONFIG_MACSEC)\n\tif (nic->macsec_cfg) {\n\t\tn_stats += ARRAY_SIZE(aq_macsec_stat_names) +\n\t\t\t   ARRAY_SIZE(aq_macsec_txsc_stat_names) *\n\t\t\t\t   aq_macsec_tx_sc_cnt(nic) +\n\t\t\t   ARRAY_SIZE(aq_macsec_txsa_stat_names) *\n\t\t\t\t   aq_macsec_tx_sa_cnt(nic) +\n\t\t\t   ARRAY_SIZE(aq_macsec_rxsa_stat_names) *\n\t\t\t\t   aq_macsec_rx_sa_cnt(nic);\n\t}\n#endif\n\n\treturn n_stats;\n}\n\nstatic void aq_ethtool_stats(struct net_device *ndev,\n\t\t\t     struct ethtool_stats *stats, u64 *data)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\n\tmemset(data, 0, aq_ethtool_n_stats(ndev) * sizeof(u64));\n\tdata = aq_nic_get_stats(aq_nic, data);\n#if IS_REACHABLE(CONFIG_PTP_1588_CLOCK)\n\tdata = aq_ptp_get_stats(aq_nic, data);\n#endif\n#if IS_ENABLED(CONFIG_MACSEC)\n\tdata = aq_macsec_get_stats(aq_nic, data);\n#endif\n}\n\nstatic void aq_ethtool_get_drvinfo(struct net_device *ndev,\n\t\t\t\t   struct ethtool_drvinfo *drvinfo)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ndev->dev.parent);\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tu32 firmware_version;\n\tu32 regs_count;\n\n\tfirmware_version = aq_nic_get_fw_version(aq_nic);\n\tregs_count = aq_nic_get_regs_count(aq_nic);\n\n\tstrlcat(drvinfo->driver, AQ_CFG_DRV_NAME, sizeof(drvinfo->driver));\n\n\tsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),\n\t\t \"%u.%u.%u\", firmware_version >> 24,\n\t\t (firmware_version >> 16) & 0xFFU, firmware_version & 0xFFFFU);\n\n\tstrscpy(drvinfo->bus_info, pdev ? pci_name(pdev) : \"\",\n\t\tsizeof(drvinfo->bus_info));\n\tdrvinfo->n_stats = aq_ethtool_n_stats(ndev);\n\tdrvinfo->testinfo_len = 0;\n\tdrvinfo->regdump_len = regs_count;\n\tdrvinfo->eedump_len = 0;\n}\n\nstatic void aq_ethtool_get_strings(struct net_device *ndev,\n\t\t\t\t   u32 stringset, u8 *data)\n{\n\tstruct aq_nic_s *nic = netdev_priv(ndev);\n\tstruct aq_nic_cfg_s *cfg;\n\tu8 *p = data;\n\tint i, si;\n#if IS_ENABLED(CONFIG_MACSEC)\n\tint sa;\n#endif\n\n\tcfg = aq_nic_get_cfg(nic);\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS: {\n\t\tconst int rx_stat_cnt = ARRAY_SIZE(aq_ethtool_queue_rx_stat_names);\n\t\tconst int tx_stat_cnt = ARRAY_SIZE(aq_ethtool_queue_tx_stat_names);\n\t\tchar tc_string[8];\n\t\tint tc;\n\n\t\tmemset(tc_string, 0, sizeof(tc_string));\n\t\tmemcpy(p, aq_ethtool_stat_names,\n\t\t       sizeof(aq_ethtool_stat_names));\n\t\tp = p + sizeof(aq_ethtool_stat_names);\n\n\t\tfor (tc = 0; tc < cfg->tcs; tc++) {\n\t\t\tif (cfg->is_qos)\n\t\t\t\tsnprintf(tc_string, 8, \"TC%d \", tc);\n\n\t\t\tfor (i = 0; i < cfg->vecs; i++) {\n\t\t\t\tfor (si = 0; si < rx_stat_cnt; si++) {\n\t\t\t\t\tsnprintf(p, ETH_GSTRING_LEN,\n\t\t\t\t\t     aq_ethtool_queue_rx_stat_names[si],\n\t\t\t\t\t     tc_string,\n\t\t\t\t\t     AQ_NIC_CFG_TCVEC2RING(cfg, tc, i));\n\t\t\t\t\tp += ETH_GSTRING_LEN;\n\t\t\t\t}\n\t\t\t\tfor (si = 0; si < tx_stat_cnt; si++) {\n\t\t\t\t\tsnprintf(p, ETH_GSTRING_LEN,\n\t\t\t\t\t     aq_ethtool_queue_tx_stat_names[si],\n\t\t\t\t\t     tc_string,\n\t\t\t\t\t     AQ_NIC_CFG_TCVEC2RING(cfg, tc, i));\n\t\t\t\t\tp += ETH_GSTRING_LEN;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#if IS_REACHABLE(CONFIG_PTP_1588_CLOCK)\n\t\tif (nic->aq_ptp) {\n\t\t\tconst int rx_ring_cnt = aq_ptp_get_ring_cnt(nic, ATL_RING_RX);\n\t\t\tconst int tx_ring_cnt = aq_ptp_get_ring_cnt(nic, ATL_RING_TX);\n\t\t\tunsigned int ptp_ring_idx =\n\t\t\t\taq_ptp_ring_idx(nic->aq_nic_cfg.tc_mode);\n\n\t\t\tsnprintf(tc_string, 8, \"PTP \");\n\n\t\t\tfor (i = 0; i < max(rx_ring_cnt, tx_ring_cnt); i++) {\n\t\t\t\tfor (si = 0; si < rx_stat_cnt; si++) {\n\t\t\t\t\tsnprintf(p, ETH_GSTRING_LEN,\n\t\t\t\t\t\t aq_ethtool_queue_rx_stat_names[si],\n\t\t\t\t\t\t tc_string,\n\t\t\t\t\t\t i ? PTP_HWST_RING_IDX : ptp_ring_idx);\n\t\t\t\t\tp += ETH_GSTRING_LEN;\n\t\t\t\t}\n\t\t\t\tif (i >= tx_ring_cnt)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (si = 0; si < tx_stat_cnt; si++) {\n\t\t\t\t\tsnprintf(p, ETH_GSTRING_LEN,\n\t\t\t\t\t\t aq_ethtool_queue_tx_stat_names[si],\n\t\t\t\t\t\t tc_string,\n\t\t\t\t\t\t i ? PTP_HWST_RING_IDX : ptp_ring_idx);\n\t\t\t\t\tp += ETH_GSTRING_LEN;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n#if IS_ENABLED(CONFIG_MACSEC)\n\t\tif (!nic->macsec_cfg)\n\t\t\tbreak;\n\n\t\tmemcpy(p, aq_macsec_stat_names, sizeof(aq_macsec_stat_names));\n\t\tp = p + sizeof(aq_macsec_stat_names);\n\t\tfor (i = 0; i < AQ_MACSEC_MAX_SC; i++) {\n\t\t\tstruct aq_macsec_txsc *aq_txsc;\n\n\t\t\tif (!(test_bit(i, &nic->macsec_cfg->txsc_idx_busy)))\n\t\t\t\tcontinue;\n\n\t\t\tfor (si = 0;\n\t\t\t\tsi < ARRAY_SIZE(aq_macsec_txsc_stat_names);\n\t\t\t\tsi++) {\n\t\t\t\tsnprintf(p, ETH_GSTRING_LEN,\n\t\t\t\t\t aq_macsec_txsc_stat_names[si], i);\n\t\t\t\tp += ETH_GSTRING_LEN;\n\t\t\t}\n\t\t\taq_txsc = &nic->macsec_cfg->aq_txsc[i];\n\t\t\tfor (sa = 0; sa < MACSEC_NUM_AN; sa++) {\n\t\t\t\tif (!(test_bit(sa, &aq_txsc->tx_sa_idx_busy)))\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (si = 0;\n\t\t\t\t     si < ARRAY_SIZE(aq_macsec_txsa_stat_names);\n\t\t\t\t     si++) {\n\t\t\t\t\tsnprintf(p, ETH_GSTRING_LEN,\n\t\t\t\t\t\t aq_macsec_txsa_stat_names[si],\n\t\t\t\t\t\t i, sa);\n\t\t\t\t\tp += ETH_GSTRING_LEN;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < AQ_MACSEC_MAX_SC; i++) {\n\t\t\tstruct aq_macsec_rxsc *aq_rxsc;\n\n\t\t\tif (!(test_bit(i, &nic->macsec_cfg->rxsc_idx_busy)))\n\t\t\t\tcontinue;\n\n\t\t\taq_rxsc = &nic->macsec_cfg->aq_rxsc[i];\n\t\t\tfor (sa = 0; sa < MACSEC_NUM_AN; sa++) {\n\t\t\t\tif (!(test_bit(sa, &aq_rxsc->rx_sa_idx_busy)))\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (si = 0;\n\t\t\t\t     si < ARRAY_SIZE(aq_macsec_rxsa_stat_names);\n\t\t\t\t     si++) {\n\t\t\t\t\tsnprintf(p, ETH_GSTRING_LEN,\n\t\t\t\t\t\t aq_macsec_rxsa_stat_names[si],\n\t\t\t\t\t\t i, sa);\n\t\t\t\t\tp += ETH_GSTRING_LEN;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\t\tbreak;\n\t}\n\tcase ETH_SS_PRIV_FLAGS:\n\t\tmemcpy(p, aq_ethtool_priv_flag_names,\n\t\t       sizeof(aq_ethtool_priv_flag_names));\n\t\tbreak;\n\t}\n}\n\nstatic int aq_ethtool_set_phys_id(struct net_device *ndev,\n\t\t\t\t  enum ethtool_phys_id_state state)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tstruct aq_hw_s *hw = aq_nic->aq_hw;\n\tint ret = 0;\n\n\tif (!aq_nic->aq_fw_ops->led_control)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&aq_nic->fwreq_mutex);\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\tret = aq_nic->aq_fw_ops->led_control(hw, AQ_HW_LED_BLINK |\n\t\t\t\t AQ_HW_LED_BLINK << 2 | AQ_HW_LED_BLINK << 4);\n\t\tbreak;\n\tcase ETHTOOL_ID_INACTIVE:\n\t\tret = aq_nic->aq_fw_ops->led_control(hw, AQ_HW_LED_DEFAULT);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&aq_nic->fwreq_mutex);\n\n\treturn ret;\n}\n\nstatic int aq_ethtool_get_sset_count(struct net_device *ndev, int stringset)\n{\n\tint ret = 0;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tret = aq_ethtool_n_stats(ndev);\n\t\tbreak;\n\tcase ETH_SS_PRIV_FLAGS:\n\t\tret = ARRAY_SIZE(aq_ethtool_priv_flag_names);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstatic u32 aq_ethtool_get_rss_indir_size(struct net_device *ndev)\n{\n\treturn AQ_CFG_RSS_INDIRECTION_TABLE_MAX;\n}\n\nstatic u32 aq_ethtool_get_rss_key_size(struct net_device *ndev)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tstruct aq_nic_cfg_s *cfg;\n\n\tcfg = aq_nic_get_cfg(aq_nic);\n\n\treturn sizeof(cfg->aq_rss.hash_secret_key);\n}\n\nstatic int aq_ethtool_get_rss(struct net_device *ndev, u32 *indir, u8 *key,\n\t\t\t      u8 *hfunc)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tstruct aq_nic_cfg_s *cfg;\n\tunsigned int i = 0U;\n\n\tcfg = aq_nic_get_cfg(aq_nic);\n\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;  \n\tif (indir) {\n\t\tfor (i = 0; i < AQ_CFG_RSS_INDIRECTION_TABLE_MAX; i++)\n\t\t\tindir[i] = cfg->aq_rss.indirection_table[i];\n\t}\n\tif (key)\n\t\tmemcpy(key, cfg->aq_rss.hash_secret_key,\n\t\t       sizeof(cfg->aq_rss.hash_secret_key));\n\n\treturn 0;\n}\n\nstatic int aq_ethtool_set_rss(struct net_device *netdev, const u32 *indir,\n\t\t\t      const u8 *key, const u8 hfunc)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(netdev);\n\tstruct aq_nic_cfg_s *cfg;\n\tunsigned int i = 0U;\n\tu32 rss_entries;\n\tint err = 0;\n\n\tcfg = aq_nic_get_cfg(aq_nic);\n\trss_entries = cfg->aq_rss.indirection_table_size;\n\n\t \n\tif (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP)\n\t\treturn -EOPNOTSUPP;\n\t \n\tif (indir)\n\t\tfor (i = 0; i < rss_entries; i++)\n\t\t\tcfg->aq_rss.indirection_table[i] = indir[i];\n\n\t \n\tif (key) {\n\t\tmemcpy(cfg->aq_rss.hash_secret_key, key,\n\t\t       sizeof(cfg->aq_rss.hash_secret_key));\n\t\terr = aq_nic->aq_hw_ops->hw_rss_hash_set(aq_nic->aq_hw,\n\t\t\t&cfg->aq_rss);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = aq_nic->aq_hw_ops->hw_rss_set(aq_nic->aq_hw, &cfg->aq_rss);\n\n\treturn err;\n}\n\nstatic int aq_ethtool_get_rxnfc(struct net_device *ndev,\n\t\t\t\tstruct ethtool_rxnfc *cmd,\n\t\t\t\tu32 *rule_locs)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tstruct aq_nic_cfg_s *cfg;\n\tint err = 0;\n\n\tcfg = aq_nic_get_cfg(aq_nic);\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tcmd->data = cfg->vecs;\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLCNT:\n\t\tcmd->rule_cnt = aq_get_rxnfc_count_all_rules(aq_nic);\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRULE:\n\t\terr = aq_get_rxnfc_rule(aq_nic, cmd);\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\terr = aq_get_rxnfc_all_rules(aq_nic, cmd, rule_locs);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int aq_ethtool_set_rxnfc(struct net_device *ndev,\n\t\t\t\tstruct ethtool_rxnfc *cmd)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tint err = 0;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\terr = aq_add_rxnfc_rule(aq_nic, cmd);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLDEL:\n\t\terr = aq_del_rxnfc_rule(aq_nic, cmd);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int aq_ethtool_get_coalesce(struct net_device *ndev,\n\t\t\t\t   struct ethtool_coalesce *coal,\n\t\t\t\t   struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tstruct aq_nic_cfg_s *cfg;\n\n\tcfg = aq_nic_get_cfg(aq_nic);\n\n\tif (cfg->itr == AQ_CFG_INTERRUPT_MODERATION_ON ||\n\t    cfg->itr == AQ_CFG_INTERRUPT_MODERATION_AUTO) {\n\t\tcoal->rx_coalesce_usecs = cfg->rx_itr;\n\t\tcoal->tx_coalesce_usecs = cfg->tx_itr;\n\t\tcoal->rx_max_coalesced_frames = 0;\n\t\tcoal->tx_max_coalesced_frames = 0;\n\t} else {\n\t\tcoal->rx_coalesce_usecs = 0;\n\t\tcoal->tx_coalesce_usecs = 0;\n\t\tcoal->rx_max_coalesced_frames = 1;\n\t\tcoal->tx_max_coalesced_frames = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int aq_ethtool_set_coalesce(struct net_device *ndev,\n\t\t\t\t   struct ethtool_coalesce *coal,\n\t\t\t\t   struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tstruct aq_nic_cfg_s *cfg;\n\n\tcfg = aq_nic_get_cfg(aq_nic);\n\n\t \n\tif (coal->rx_max_coalesced_frames > 1 ||\n\t    coal->tx_max_coalesced_frames > 1)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (!(coal->rx_max_coalesced_frames == !coal->rx_coalesce_usecs))\n\t\treturn -EOPNOTSUPP;\n\tif (!(coal->tx_max_coalesced_frames == !coal->tx_coalesce_usecs))\n\t\treturn -EOPNOTSUPP;\n\n\tif (coal->rx_coalesce_usecs > AQ_CFG_INTERRUPT_MODERATION_USEC_MAX ||\n\t    coal->tx_coalesce_usecs > AQ_CFG_INTERRUPT_MODERATION_USEC_MAX)\n\t\treturn -EINVAL;\n\n\tcfg->itr = AQ_CFG_INTERRUPT_MODERATION_ON;\n\n\tcfg->rx_itr = coal->rx_coalesce_usecs;\n\tcfg->tx_itr = coal->tx_coalesce_usecs;\n\n\treturn aq_nic_update_interrupt_moderation_settings(aq_nic);\n}\n\nstatic void aq_ethtool_get_wol(struct net_device *ndev,\n\t\t\t       struct ethtool_wolinfo *wol)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tstruct aq_nic_cfg_s *cfg;\n\n\tcfg = aq_nic_get_cfg(aq_nic);\n\n\twol->supported = AQ_NIC_WOL_MODES;\n\twol->wolopts = cfg->wol;\n}\n\nstatic int aq_ethtool_set_wol(struct net_device *ndev,\n\t\t\t      struct ethtool_wolinfo *wol)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ndev->dev.parent);\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tstruct aq_nic_cfg_s *cfg;\n\tint err = 0;\n\n\tcfg = aq_nic_get_cfg(aq_nic);\n\n\tif (wol->wolopts & ~AQ_NIC_WOL_MODES)\n\t\treturn -EOPNOTSUPP;\n\n\tcfg->wol = wol->wolopts;\n\n\terr = device_set_wakeup_enable(&pdev->dev, !!cfg->wol);\n\n\treturn err;\n}\n\nstatic int aq_ethtool_get_ts_info(struct net_device *ndev,\n\t\t\t\t  struct ethtool_ts_info *info)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\n\tethtool_op_get_ts_info(ndev, info);\n\n\tif (!aq_nic->aq_ptp)\n\t\treturn 0;\n\n\tinfo->so_timestamping |=\n\t\tSOF_TIMESTAMPING_TX_HARDWARE |\n\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\n\tinfo->tx_types = BIT(HWTSTAMP_TX_OFF) |\n\t\t\t BIT(HWTSTAMP_TX_ON);\n\n\tinfo->rx_filters = BIT(HWTSTAMP_FILTER_NONE);\n\n\tinfo->rx_filters |= BIT(HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |\n\t\t\t    BIT(HWTSTAMP_FILTER_PTP_V2_L2_EVENT) |\n\t\t\t    BIT(HWTSTAMP_FILTER_PTP_V2_EVENT);\n\n#if IS_REACHABLE(CONFIG_PTP_1588_CLOCK)\n\tinfo->phc_index = ptp_clock_index(aq_ptp_get_ptp_clock(aq_nic->aq_ptp));\n#endif\n\n\treturn 0;\n}\n\nstatic u32 eee_mask_to_ethtool_mask(u32 speed)\n{\n\tu32 rate = 0;\n\n\tif (speed & AQ_NIC_RATE_EEE_10G)\n\t\trate |= SUPPORTED_10000baseT_Full;\n\n\tif (speed & AQ_NIC_RATE_EEE_1G)\n\t\trate |= SUPPORTED_1000baseT_Full;\n\n\tif (speed & AQ_NIC_RATE_EEE_100M)\n\t\trate |= SUPPORTED_100baseT_Full;\n\n\treturn rate;\n}\n\nstatic int aq_ethtool_get_eee(struct net_device *ndev, struct ethtool_eee *eee)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tu32 rate, supported_rates;\n\tint err = 0;\n\n\tif (!aq_nic->aq_fw_ops->get_eee_rate)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&aq_nic->fwreq_mutex);\n\terr = aq_nic->aq_fw_ops->get_eee_rate(aq_nic->aq_hw, &rate,\n\t\t\t\t\t      &supported_rates);\n\tmutex_unlock(&aq_nic->fwreq_mutex);\n\tif (err < 0)\n\t\treturn err;\n\n\teee->supported = eee_mask_to_ethtool_mask(supported_rates);\n\n\tif (aq_nic->aq_nic_cfg.eee_speeds)\n\t\teee->advertised = eee->supported;\n\n\teee->lp_advertised = eee_mask_to_ethtool_mask(rate);\n\n\teee->eee_enabled = !!eee->advertised;\n\n\teee->tx_lpi_enabled = eee->eee_enabled;\n\tif ((supported_rates & rate) & AQ_NIC_RATE_EEE_MSK)\n\t\teee->eee_active = true;\n\n\treturn 0;\n}\n\nstatic int aq_ethtool_set_eee(struct net_device *ndev, struct ethtool_eee *eee)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tu32 rate, supported_rates;\n\tstruct aq_nic_cfg_s *cfg;\n\tint err = 0;\n\n\tcfg = aq_nic_get_cfg(aq_nic);\n\n\tif (unlikely(!aq_nic->aq_fw_ops->get_eee_rate ||\n\t\t     !aq_nic->aq_fw_ops->set_eee_rate))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&aq_nic->fwreq_mutex);\n\terr = aq_nic->aq_fw_ops->get_eee_rate(aq_nic->aq_hw, &rate,\n\t\t\t\t\t      &supported_rates);\n\tmutex_unlock(&aq_nic->fwreq_mutex);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (eee->eee_enabled) {\n\t\trate = supported_rates;\n\t\tcfg->eee_speeds = rate;\n\t} else {\n\t\trate = 0;\n\t\tcfg->eee_speeds = 0;\n\t}\n\n\tmutex_lock(&aq_nic->fwreq_mutex);\n\terr = aq_nic->aq_fw_ops->set_eee_rate(aq_nic->aq_hw, rate);\n\tmutex_unlock(&aq_nic->fwreq_mutex);\n\n\treturn err;\n}\n\nstatic int aq_ethtool_nway_reset(struct net_device *ndev)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tint err = 0;\n\n\tif (unlikely(!aq_nic->aq_fw_ops->renegotiate))\n\t\treturn -EOPNOTSUPP;\n\n\tif (netif_running(ndev)) {\n\t\tmutex_lock(&aq_nic->fwreq_mutex);\n\t\terr = aq_nic->aq_fw_ops->renegotiate(aq_nic->aq_hw);\n\t\tmutex_unlock(&aq_nic->fwreq_mutex);\n\t}\n\n\treturn err;\n}\n\nstatic void aq_ethtool_get_pauseparam(struct net_device *ndev,\n\t\t\t\t      struct ethtool_pauseparam *pause)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tint fc = aq_nic->aq_nic_cfg.fc.req;\n\n\tpause->autoneg = 0;\n\n\tpause->rx_pause = !!(fc & AQ_NIC_FC_RX);\n\tpause->tx_pause = !!(fc & AQ_NIC_FC_TX);\n}\n\nstatic int aq_ethtool_set_pauseparam(struct net_device *ndev,\n\t\t\t\t     struct ethtool_pauseparam *pause)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tint err = 0;\n\n\tif (!aq_nic->aq_fw_ops->set_flow_control)\n\t\treturn -EOPNOTSUPP;\n\n\tif (pause->autoneg == AUTONEG_ENABLE)\n\t\treturn -EOPNOTSUPP;\n\n\tif (pause->rx_pause)\n\t\taq_nic->aq_hw->aq_nic_cfg->fc.req |= AQ_NIC_FC_RX;\n\telse\n\t\taq_nic->aq_hw->aq_nic_cfg->fc.req &= ~AQ_NIC_FC_RX;\n\n\tif (pause->tx_pause)\n\t\taq_nic->aq_hw->aq_nic_cfg->fc.req |= AQ_NIC_FC_TX;\n\telse\n\t\taq_nic->aq_hw->aq_nic_cfg->fc.req &= ~AQ_NIC_FC_TX;\n\n\tmutex_lock(&aq_nic->fwreq_mutex);\n\terr = aq_nic->aq_fw_ops->set_flow_control(aq_nic->aq_hw);\n\tmutex_unlock(&aq_nic->fwreq_mutex);\n\n\treturn err;\n}\n\nstatic void aq_get_ringparam(struct net_device *ndev,\n\t\t\t     struct ethtool_ringparam *ring,\n\t\t\t     struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tstruct aq_nic_cfg_s *cfg;\n\n\tcfg = aq_nic_get_cfg(aq_nic);\n\n\tring->rx_pending = cfg->rxds;\n\tring->tx_pending = cfg->txds;\n\n\tring->rx_max_pending = cfg->aq_hw_caps->rxds_max;\n\tring->tx_max_pending = cfg->aq_hw_caps->txds_max;\n}\n\nstatic int aq_set_ringparam(struct net_device *ndev,\n\t\t\t    struct ethtool_ringparam *ring,\n\t\t\t    struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tconst struct aq_hw_caps_s *hw_caps;\n\tbool ndev_running = false;\n\tstruct aq_nic_cfg_s *cfg;\n\tint err = 0;\n\n\tcfg = aq_nic_get_cfg(aq_nic);\n\thw_caps = cfg->aq_hw_caps;\n\n\tif (ring->rx_mini_pending || ring->rx_jumbo_pending) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err_exit;\n\t}\n\n\tif (netif_running(ndev)) {\n\t\tndev_running = true;\n\t\taq_ndev_close(ndev);\n\t}\n\n\tcfg->rxds = max(ring->rx_pending, hw_caps->rxds_min);\n\tcfg->rxds = min(cfg->rxds, hw_caps->rxds_max);\n\tcfg->rxds = ALIGN(cfg->rxds, AQ_HW_RXD_MULTIPLE);\n\n\tcfg->txds = max(ring->tx_pending, hw_caps->txds_min);\n\tcfg->txds = min(cfg->txds, hw_caps->txds_max);\n\tcfg->txds = ALIGN(cfg->txds, AQ_HW_TXD_MULTIPLE);\n\n\terr = aq_nic_realloc_vectors(aq_nic);\n\tif (err)\n\t\tgoto err_exit;\n\n\tif (ndev_running)\n\t\terr = aq_ndev_open(ndev);\n\nerr_exit:\n\treturn err;\n}\n\nstatic u32 aq_get_msg_level(struct net_device *ndev)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\n\treturn aq_nic->msg_enable;\n}\n\nstatic void aq_set_msg_level(struct net_device *ndev, u32 data)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\n\taq_nic->msg_enable = data;\n}\n\nstatic u32 aq_ethtool_get_priv_flags(struct net_device *ndev)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\n\treturn aq_nic->aq_nic_cfg.priv_flags;\n}\n\nstatic int aq_ethtool_set_priv_flags(struct net_device *ndev, u32 flags)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tstruct aq_nic_cfg_s *cfg;\n\tu32 priv_flags;\n\tint ret = 0;\n\n\tcfg = aq_nic_get_cfg(aq_nic);\n\tpriv_flags = cfg->priv_flags;\n\n\tif (flags & ~AQ_PRIV_FLAGS_MASK)\n\t\treturn -EOPNOTSUPP;\n\n\tif (hweight32((flags | priv_flags) & AQ_HW_LOOPBACK_MASK) > 1) {\n\t\tnetdev_info(ndev, \"Can't enable more than one loopback simultaneously\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcfg->priv_flags = flags;\n\n\tif ((priv_flags ^ flags) & BIT(AQ_HW_LOOPBACK_DMA_NET)) {\n\t\tif (netif_running(ndev)) {\n\t\t\tdev_close(ndev);\n\n\t\t\tdev_open(ndev, NULL);\n\t\t}\n\t} else if ((priv_flags ^ flags) & AQ_HW_LOOPBACK_MASK) {\n\t\tret = aq_nic_set_loopback(aq_nic);\n\t}\n\n\treturn ret;\n}\n\nstatic int aq_ethtool_get_phy_tunable(struct net_device *ndev,\n\t\t\t\t      const struct ethtool_tunable *tuna, void *data)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\n\tswitch (tuna->id) {\n\tcase ETHTOOL_PHY_EDPD: {\n\t\tu16 *val = data;\n\n\t\t*val = aq_nic->aq_nic_cfg.is_media_detect ? AQ_HW_MEDIA_DETECT_CNT : 0;\n\t\tbreak;\n\t}\n\tcase ETHTOOL_PHY_DOWNSHIFT: {\n\t\tu8 *val = data;\n\n\t\t*val = (u8)aq_nic->aq_nic_cfg.downshift_counter;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int aq_ethtool_set_phy_tunable(struct net_device *ndev,\n\t\t\t\t      const struct ethtool_tunable *tuna, const void *data)\n{\n\tint err = -EOPNOTSUPP;\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\n\tswitch (tuna->id) {\n\tcase ETHTOOL_PHY_EDPD: {\n\t\tconst u16 *val = data;\n\n\t\terr = aq_nic_set_media_detect(aq_nic, *val);\n\t\tbreak;\n\t}\n\tcase ETHTOOL_PHY_DOWNSHIFT: {\n\t\tconst u8 *val = data;\n\n\t\terr = aq_nic_set_downshift(aq_nic, *val);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nconst struct ethtool_ops aq_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES,\n\t.get_link            = aq_ethtool_get_link,\n\t.get_regs_len        = aq_ethtool_get_regs_len,\n\t.get_regs            = aq_ethtool_get_regs,\n\t.get_drvinfo         = aq_ethtool_get_drvinfo,\n\t.get_strings         = aq_ethtool_get_strings,\n\t.set_phys_id         = aq_ethtool_set_phys_id,\n\t.get_rxfh_indir_size = aq_ethtool_get_rss_indir_size,\n\t.get_wol             = aq_ethtool_get_wol,\n\t.set_wol             = aq_ethtool_set_wol,\n\t.nway_reset          = aq_ethtool_nway_reset,\n\t.get_ringparam       = aq_get_ringparam,\n\t.set_ringparam       = aq_set_ringparam,\n\t.get_eee             = aq_ethtool_get_eee,\n\t.set_eee             = aq_ethtool_set_eee,\n\t.get_pauseparam      = aq_ethtool_get_pauseparam,\n\t.set_pauseparam      = aq_ethtool_set_pauseparam,\n\t.get_rxfh_key_size   = aq_ethtool_get_rss_key_size,\n\t.get_rxfh            = aq_ethtool_get_rss,\n\t.set_rxfh            = aq_ethtool_set_rss,\n\t.get_rxnfc           = aq_ethtool_get_rxnfc,\n\t.set_rxnfc           = aq_ethtool_set_rxnfc,\n\t.get_msglevel        = aq_get_msg_level,\n\t.set_msglevel        = aq_set_msg_level,\n\t.get_sset_count      = aq_ethtool_get_sset_count,\n\t.get_ethtool_stats   = aq_ethtool_stats,\n\t.get_priv_flags      = aq_ethtool_get_priv_flags,\n\t.set_priv_flags      = aq_ethtool_set_priv_flags,\n\t.get_link_ksettings  = aq_ethtool_get_link_ksettings,\n\t.set_link_ksettings  = aq_ethtool_set_link_ksettings,\n\t.get_coalesce\t     = aq_ethtool_get_coalesce,\n\t.set_coalesce\t     = aq_ethtool_set_coalesce,\n\t.get_ts_info         = aq_ethtool_get_ts_info,\n\t.get_phy_tunable     = aq_ethtool_get_phy_tunable,\n\t.set_phy_tunable     = aq_ethtool_set_phy_tunable,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}