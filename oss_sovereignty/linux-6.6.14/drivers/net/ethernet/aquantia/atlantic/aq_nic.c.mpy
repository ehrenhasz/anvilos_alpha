{
  "module_name": "aq_nic.c",
  "hash_id": "3e16dbcede46df56cf5d8b4a112110ffb0b3a07045975b0b1376cd0d3705be1c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/aquantia/atlantic/aq_nic.c",
  "human_readable_source": "\n \n\n \n\n#include \"aq_nic.h\"\n#include \"aq_ring.h\"\n#include \"aq_vec.h\"\n#include \"aq_hw.h\"\n#include \"aq_pci_func.h\"\n#include \"aq_macsec.h\"\n#include \"aq_main.h\"\n#include \"aq_phy.h\"\n#include \"aq_ptp.h\"\n#include \"aq_filters.h\"\n\n#include <linux/moduleparam.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/timer.h>\n#include <linux/cpu.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <net/ip.h>\n#include <net/pkt_cls.h>\n\nstatic unsigned int aq_itr = AQ_CFG_INTERRUPT_MODERATION_AUTO;\nmodule_param_named(aq_itr, aq_itr, uint, 0644);\nMODULE_PARM_DESC(aq_itr, \"Interrupt throttling mode\");\n\nstatic unsigned int aq_itr_tx;\nmodule_param_named(aq_itr_tx, aq_itr_tx, uint, 0644);\nMODULE_PARM_DESC(aq_itr_tx, \"TX interrupt throttle rate\");\n\nstatic unsigned int aq_itr_rx;\nmodule_param_named(aq_itr_rx, aq_itr_rx, uint, 0644);\nMODULE_PARM_DESC(aq_itr_rx, \"RX interrupt throttle rate\");\n\nstatic void aq_nic_update_ndev_stats(struct aq_nic_s *self);\n\nstatic void aq_nic_rss_init(struct aq_nic_s *self, unsigned int num_rss_queues)\n{\n\tstatic u8 rss_key[AQ_CFG_RSS_HASHKEY_SIZE] = {\n\t\t0x1e, 0xad, 0x71, 0x87, 0x65, 0xfc, 0x26, 0x7d,\n\t\t0x0d, 0x45, 0x67, 0x74, 0xcd, 0x06, 0x1a, 0x18,\n\t\t0xb6, 0xc1, 0xf0, 0xc7, 0xbb, 0x18, 0xbe, 0xf8,\n\t\t0x19, 0x13, 0x4b, 0xa9, 0xd0, 0x3e, 0xfe, 0x70,\n\t\t0x25, 0x03, 0xab, 0x50, 0x6a, 0x8b, 0x82, 0x0c\n\t};\n\tstruct aq_nic_cfg_s *cfg = &self->aq_nic_cfg;\n\tstruct aq_rss_parameters *rss_params;\n\tint i = 0;\n\n\trss_params = &cfg->aq_rss;\n\n\trss_params->hash_secret_key_size = sizeof(rss_key);\n\tmemcpy(rss_params->hash_secret_key, rss_key, sizeof(rss_key));\n\trss_params->indirection_table_size = AQ_CFG_RSS_INDIRECTION_TABLE_MAX;\n\n\tfor (i = rss_params->indirection_table_size; i--;)\n\t\trss_params->indirection_table[i] = i & (num_rss_queues - 1);\n}\n\n \nstatic void aq_nic_cfg_update_num_vecs(struct aq_nic_s *self)\n{\n\tstruct aq_nic_cfg_s *cfg = &self->aq_nic_cfg;\n\n\tcfg->vecs = min(cfg->aq_hw_caps->vecs, AQ_CFG_VECS_DEF);\n\tcfg->vecs = min(cfg->vecs, num_online_cpus());\n\tif (self->irqvecs > AQ_HW_SERVICE_IRQS)\n\t\tcfg->vecs = min(cfg->vecs, self->irqvecs - AQ_HW_SERVICE_IRQS);\n\t \n\tcfg->vecs = rounddown_pow_of_two(cfg->vecs);\n\n\tif (ATL_HW_IS_CHIP_FEATURE(self->aq_hw, ANTIGUA)) {\n\t\tif (cfg->tcs > 2)\n\t\t\tcfg->vecs = min(cfg->vecs, 4U);\n\t}\n\n\tif (cfg->vecs <= 4)\n\t\tcfg->tc_mode = AQ_TC_MODE_8TCS;\n\telse\n\t\tcfg->tc_mode = AQ_TC_MODE_4TCS;\n\n\t \n\tcfg->num_rss_queues = min(cfg->vecs, AQ_CFG_NUM_RSS_QUEUES_DEF);\n\taq_nic_rss_init(self, cfg->num_rss_queues);\n}\n\n \nvoid aq_nic_cfg_start(struct aq_nic_s *self)\n{\n\tstruct aq_nic_cfg_s *cfg = &self->aq_nic_cfg;\n\tint i;\n\n\tcfg->tcs = AQ_CFG_TCS_DEF;\n\n\tcfg->is_polling = AQ_CFG_IS_POLLING_DEF;\n\n\tcfg->itr = aq_itr;\n\tcfg->tx_itr = aq_itr_tx;\n\tcfg->rx_itr = aq_itr_rx;\n\n\tcfg->rxpageorder = AQ_CFG_RX_PAGEORDER;\n\tcfg->is_rss = AQ_CFG_IS_RSS_DEF;\n\tcfg->aq_rss.base_cpu_number = AQ_CFG_RSS_BASE_CPU_NUM_DEF;\n\tcfg->fc.req = AQ_CFG_FC_MODE;\n\tcfg->wol = AQ_CFG_WOL_MODES;\n\n\tcfg->mtu = AQ_CFG_MTU_DEF;\n\tcfg->link_speed_msk = AQ_CFG_SPEED_MSK;\n\tcfg->is_autoneg = AQ_CFG_IS_AUTONEG_DEF;\n\n\tcfg->is_lro = AQ_CFG_IS_LRO_DEF;\n\tcfg->is_ptp = true;\n\n\t \n\tcfg->rxds = min(cfg->aq_hw_caps->rxds_max, AQ_CFG_RXDS_DEF);\n\tcfg->txds = min(cfg->aq_hw_caps->txds_max, AQ_CFG_TXDS_DEF);\n\n\taq_nic_cfg_update_num_vecs(self);\n\n\tcfg->irq_type = aq_pci_func_get_irq_type(self);\n\n\tif ((cfg->irq_type == AQ_HW_IRQ_LEGACY) ||\n\t    (cfg->aq_hw_caps->vecs == 1U) ||\n\t    (cfg->vecs == 1U)) {\n\t\tcfg->is_rss = 0U;\n\t\tcfg->vecs = 1U;\n\t}\n\n\t \n\tif (AQ_HW_SERVICE_IRQS > 0 && cfg->vecs + 1 <= self->irqvecs)\n\t\tcfg->link_irq_vec = cfg->vecs;\n\telse\n\t\tcfg->link_irq_vec = 0;\n\n\tcfg->link_speed_msk &= cfg->aq_hw_caps->link_speed_msk;\n\tcfg->features = cfg->aq_hw_caps->hw_features;\n\tcfg->is_vlan_rx_strip = !!(cfg->features & NETIF_F_HW_VLAN_CTAG_RX);\n\tcfg->is_vlan_tx_insert = !!(cfg->features & NETIF_F_HW_VLAN_CTAG_TX);\n\tcfg->is_vlan_force_promisc = true;\n\n\tfor (i = 0; i < sizeof(cfg->prio_tc_map); i++)\n\t\tcfg->prio_tc_map[i] = cfg->tcs * i / 8;\n}\n\nstatic int aq_nic_update_link_status(struct aq_nic_s *self)\n{\n\tint err = self->aq_fw_ops->update_link_status(self->aq_hw);\n\tu32 fc = 0;\n\n\tif (err)\n\t\treturn err;\n\n\tif (self->aq_fw_ops->get_flow_control)\n\t\tself->aq_fw_ops->get_flow_control(self->aq_hw, &fc);\n\tself->aq_nic_cfg.fc.cur = fc;\n\n\tif (self->link_status.mbps != self->aq_hw->aq_link_status.mbps) {\n\t\tnetdev_info(self->ndev, \"%s: link change old %d new %d\\n\",\n\t\t\t    AQ_CFG_DRV_NAME, self->link_status.mbps,\n\t\t\t    self->aq_hw->aq_link_status.mbps);\n\t\taq_nic_update_interrupt_moderation_settings(self);\n\n\t\tif (self->aq_ptp) {\n\t\t\taq_ptp_clock_init(self);\n\t\t\taq_ptp_tm_offset_set(self,\n\t\t\t\t\t     self->aq_hw->aq_link_status.mbps);\n\t\t\taq_ptp_link_change(self);\n\t\t}\n\n\t\t \n\t\tif (self->aq_hw_ops->hw_set_fc)\n\t\t\tself->aq_hw_ops->hw_set_fc(self->aq_hw, fc, 0);\n\t}\n\n\tself->link_status = self->aq_hw->aq_link_status;\n\tif (!netif_carrier_ok(self->ndev) && self->link_status.mbps) {\n\t\taq_utils_obj_set(&self->flags,\n\t\t\t\t AQ_NIC_FLAG_STARTED);\n\t\taq_utils_obj_clear(&self->flags,\n\t\t\t\t   AQ_NIC_LINK_DOWN);\n\t\tnetif_carrier_on(self->ndev);\n#if IS_ENABLED(CONFIG_MACSEC)\n\t\taq_macsec_enable(self);\n#endif\n\t\tif (self->aq_hw_ops->hw_tc_rate_limit_set)\n\t\t\tself->aq_hw_ops->hw_tc_rate_limit_set(self->aq_hw);\n\n\t\tnetif_tx_wake_all_queues(self->ndev);\n\t}\n\tif (netif_carrier_ok(self->ndev) && !self->link_status.mbps) {\n\t\tnetif_carrier_off(self->ndev);\n\t\tnetif_tx_disable(self->ndev);\n\t\taq_utils_obj_set(&self->flags, AQ_NIC_LINK_DOWN);\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t aq_linkstate_threaded_isr(int irq, void *private)\n{\n\tstruct aq_nic_s *self = private;\n\n\tif (!self)\n\t\treturn IRQ_NONE;\n\n\taq_nic_update_link_status(self);\n\n\tself->aq_hw_ops->hw_irq_enable(self->aq_hw,\n\t\t\t\t       BIT(self->aq_nic_cfg.link_irq_vec));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void aq_nic_service_task(struct work_struct *work)\n{\n\tstruct aq_nic_s *self = container_of(work, struct aq_nic_s,\n\t\t\t\t\t     service_task);\n\tint err;\n\n\taq_ptp_service_task(self);\n\n\tif (aq_utils_obj_test(&self->flags, AQ_NIC_FLAGS_IS_NOT_READY))\n\t\treturn;\n\n\terr = aq_nic_update_link_status(self);\n\tif (err)\n\t\treturn;\n\n#if IS_ENABLED(CONFIG_MACSEC)\n\taq_macsec_work(self);\n#endif\n\n\tmutex_lock(&self->fwreq_mutex);\n\tif (self->aq_fw_ops->update_stats)\n\t\tself->aq_fw_ops->update_stats(self->aq_hw);\n\tmutex_unlock(&self->fwreq_mutex);\n\n\taq_nic_update_ndev_stats(self);\n}\n\nstatic void aq_nic_service_timer_cb(struct timer_list *t)\n{\n\tstruct aq_nic_s *self = from_timer(self, t, service_timer);\n\n\tmod_timer(&self->service_timer,\n\t\t  jiffies + AQ_CFG_SERVICE_TIMER_INTERVAL);\n\n\taq_ndev_schedule_work(&self->service_task);\n}\n\nstatic void aq_nic_polling_timer_cb(struct timer_list *t)\n{\n\tstruct aq_nic_s *self = from_timer(self, t, polling_timer);\n\tunsigned int i = 0U;\n\n\tfor (i = 0U; self->aq_vecs > i; ++i)\n\t\taq_vec_isr(i, (void *)self->aq_vec[i]);\n\n\tmod_timer(&self->polling_timer, jiffies +\n\t\t  AQ_CFG_POLLING_TIMER_INTERVAL);\n}\n\nstatic int aq_nic_hw_prepare(struct aq_nic_s *self)\n{\n\tint err = 0;\n\n\terr = self->aq_hw_ops->hw_soft_reset(self->aq_hw);\n\tif (err)\n\t\tgoto exit;\n\n\terr = self->aq_hw_ops->hw_prepare(self->aq_hw, &self->aq_fw_ops);\n\nexit:\n\treturn err;\n}\n\nstatic bool aq_nic_is_valid_ether_addr(const u8 *addr)\n{\n\t \n\treturn !(addr[0] == 0 && addr[1] == 0 && addr[2] == 0);\n}\n\nint aq_nic_ndev_register(struct aq_nic_s *self)\n{\n\tu8 addr[ETH_ALEN];\n\tint err = 0;\n\n\tif (!self->ndev) {\n\t\terr = -EINVAL;\n\t\tgoto err_exit;\n\t}\n\n\terr = aq_nic_hw_prepare(self);\n\tif (err)\n\t\tgoto err_exit;\n\n#if IS_ENABLED(CONFIG_MACSEC)\n\taq_macsec_init(self);\n#endif\n\n\tif (platform_get_ethdev_address(&self->pdev->dev, self->ndev) != 0) {\n\t\t \n\t\tmutex_lock(&self->fwreq_mutex);\n\t\terr = self->aq_fw_ops->get_mac_permanent(self->aq_hw, addr);\n\t\tmutex_unlock(&self->fwreq_mutex);\n\n\t\tif (err)\n\t\t\tgoto err_exit;\n\n\t\tif (is_valid_ether_addr(addr) &&\n\t\t    aq_nic_is_valid_ether_addr(addr)) {\n\t\t\teth_hw_addr_set(self->ndev, addr);\n\t\t} else {\n\t\t\tnetdev_warn(self->ndev, \"MAC is invalid, will use random.\");\n\t\t\teth_hw_addr_random(self->ndev);\n\t\t}\n\t}\n\n#if defined(AQ_CFG_MAC_ADDR_PERMANENT)\n\t{\n\t\tstatic u8 mac_addr_permanent[] = AQ_CFG_MAC_ADDR_PERMANENT;\n\n\t\teth_hw_addr_set(self->ndev, mac_addr_permanent);\n\t}\n#endif\n\n\tfor (self->aq_vecs = 0; self->aq_vecs < aq_nic_get_cfg(self)->vecs;\n\t     self->aq_vecs++) {\n\t\tself->aq_vec[self->aq_vecs] =\n\t\t    aq_vec_alloc(self, self->aq_vecs, aq_nic_get_cfg(self));\n\t\tif (!self->aq_vec[self->aq_vecs]) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_exit;\n\t\t}\n\t}\n\n\tnetif_carrier_off(self->ndev);\n\n\tnetif_tx_disable(self->ndev);\n\n\terr = register_netdev(self->ndev);\n\tif (err)\n\t\tgoto err_exit;\n\nerr_exit:\n#if IS_ENABLED(CONFIG_MACSEC)\n\tif (err)\n\t\taq_macsec_free(self);\n#endif\n\treturn err;\n}\n\nvoid aq_nic_ndev_init(struct aq_nic_s *self)\n{\n\tconst struct aq_hw_caps_s *aq_hw_caps = self->aq_nic_cfg.aq_hw_caps;\n\tstruct aq_nic_cfg_s *aq_nic_cfg = &self->aq_nic_cfg;\n\n\tself->ndev->hw_features |= aq_hw_caps->hw_features;\n\tself->ndev->features = aq_hw_caps->hw_features;\n\tself->ndev->vlan_features |= NETIF_F_HW_CSUM | NETIF_F_RXCSUM |\n\t\t\t\t     NETIF_F_RXHASH | NETIF_F_SG |\n\t\t\t\t     NETIF_F_LRO | NETIF_F_TSO | NETIF_F_TSO6;\n\tself->ndev->gso_partial_features = NETIF_F_GSO_UDP_L4;\n\tself->ndev->priv_flags = aq_hw_caps->hw_priv_flags;\n\tself->ndev->priv_flags |= IFF_LIVE_ADDR_CHANGE;\n\n\tself->msg_enable = NETIF_MSG_DRV | NETIF_MSG_LINK;\n\tself->ndev->mtu = aq_nic_cfg->mtu - ETH_HLEN;\n\tself->ndev->max_mtu = aq_hw_caps->mtu - ETH_FCS_LEN - ETH_HLEN;\n\n\tself->ndev->xdp_features = NETDEV_XDP_ACT_BASIC |\n\t\t\t\t   NETDEV_XDP_ACT_REDIRECT |\n\t\t\t\t   NETDEV_XDP_ACT_NDO_XMIT |\n\t\t\t\t   NETDEV_XDP_ACT_RX_SG |\n\t\t\t\t   NETDEV_XDP_ACT_NDO_XMIT_SG;\n}\n\nvoid aq_nic_set_tx_ring(struct aq_nic_s *self, unsigned int idx,\n\t\t\tstruct aq_ring_s *ring)\n{\n\tself->aq_ring_tx[idx] = ring;\n}\n\nstruct net_device *aq_nic_get_ndev(struct aq_nic_s *self)\n{\n\treturn self->ndev;\n}\n\nint aq_nic_init(struct aq_nic_s *self)\n{\n\tstruct aq_vec_s *aq_vec = NULL;\n\tunsigned int i = 0U;\n\tint err = 0;\n\n\tself->power_state = AQ_HW_POWER_STATE_D0;\n\tmutex_lock(&self->fwreq_mutex);\n\terr = self->aq_hw_ops->hw_reset(self->aq_hw);\n\tmutex_unlock(&self->fwreq_mutex);\n\tif (err < 0)\n\t\tgoto err_exit;\n\t \n\taq_nic_set_downshift(self, self->aq_nic_cfg.downshift_counter);\n\taq_nic_set_media_detect(self, self->aq_nic_cfg.is_media_detect ?\n\t\t\t\tAQ_HW_MEDIA_DETECT_CNT : 0);\n\n\terr = self->aq_hw_ops->hw_init(self->aq_hw,\n\t\t\t\t       aq_nic_get_ndev(self)->dev_addr);\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\tif (ATL_HW_IS_CHIP_FEATURE(self->aq_hw, ATLANTIC) &&\n\t    self->aq_nic_cfg.aq_hw_caps->media_type == AQ_HW_MEDIA_TYPE_TP) {\n\t\tself->aq_hw->phy_id = HW_ATL_PHY_ID_MAX;\n\t\terr = aq_phy_init(self->aq_hw);\n\n\t\t \n\t\tif (self->aq_nic_cfg.aq_hw_caps->quirks & AQ_NIC_QUIRK_BAD_PTP)\n\t\t\tif (self->aq_hw->phy_id != HW_ATL_PHY_ID_MAX)\n\t\t\t\taq_phy_disable_ptp(self->aq_hw);\n\t}\n\n\tfor (i = 0U; i < self->aq_vecs; i++) {\n\t\taq_vec = self->aq_vec[i];\n\t\terr = aq_vec_ring_alloc(aq_vec, self, i,\n\t\t\t\t\taq_nic_get_cfg(self));\n\t\tif (err)\n\t\t\tgoto err_exit;\n\n\t\taq_vec_init(aq_vec, self->aq_hw_ops, self->aq_hw);\n\t}\n\n\tif (aq_nic_get_cfg(self)->is_ptp) {\n\t\terr = aq_ptp_init(self, self->irqvecs - 1);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\terr = aq_ptp_ring_alloc(self);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\terr = aq_ptp_ring_init(self);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\t}\n\n\tnetif_carrier_off(self->ndev);\n\nerr_exit:\n\treturn err;\n}\n\nint aq_nic_start(struct aq_nic_s *self)\n{\n\tstruct aq_vec_s *aq_vec = NULL;\n\tstruct aq_nic_cfg_s *cfg;\n\tunsigned int i = 0U;\n\tint err = 0;\n\n\tcfg = aq_nic_get_cfg(self);\n\n\terr = self->aq_hw_ops->hw_multicast_list_set(self->aq_hw,\n\t\t\t\t\t\t     self->mc_list.ar,\n\t\t\t\t\t\t     self->mc_list.count);\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\terr = self->aq_hw_ops->hw_packet_filter_set(self->aq_hw,\n\t\t\t\t\t\t    self->packet_filter);\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\tfor (i = 0U; self->aq_vecs > i; ++i) {\n\t\taq_vec = self->aq_vec[i];\n\t\terr = aq_vec_start(aq_vec);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\t}\n\n\terr = aq_ptp_ring_start(self);\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\taq_nic_set_loopback(self);\n\n\terr = self->aq_hw_ops->hw_start(self->aq_hw);\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\terr = aq_nic_update_interrupt_moderation_settings(self);\n\tif (err)\n\t\tgoto err_exit;\n\n\tINIT_WORK(&self->service_task, aq_nic_service_task);\n\n\ttimer_setup(&self->service_timer, aq_nic_service_timer_cb, 0);\n\taq_nic_service_timer_cb(&self->service_timer);\n\n\tif (cfg->is_polling) {\n\t\ttimer_setup(&self->polling_timer, aq_nic_polling_timer_cb, 0);\n\t\tmod_timer(&self->polling_timer, jiffies +\n\t\t\t  AQ_CFG_POLLING_TIMER_INTERVAL);\n\t} else {\n\t\tfor (i = 0U; self->aq_vecs > i; ++i) {\n\t\t\taq_vec = self->aq_vec[i];\n\t\t\terr = aq_pci_func_alloc_irq(self, i, self->ndev->name,\n\t\t\t\t\t\t    aq_vec_isr, aq_vec,\n\t\t\t\t\t\t    aq_vec_get_affinity_mask(aq_vec));\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_exit;\n\t\t}\n\n\t\terr = aq_ptp_irq_alloc(self);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\n\t\tif (cfg->link_irq_vec) {\n\t\t\tint irqvec = pci_irq_vector(self->pdev,\n\t\t\t\t\t\t    cfg->link_irq_vec);\n\t\t\terr = request_threaded_irq(irqvec, NULL,\n\t\t\t\t\t\t   aq_linkstate_threaded_isr,\n\t\t\t\t\t\t   IRQF_SHARED | IRQF_ONESHOT,\n\t\t\t\t\t\t   self->ndev->name, self);\n\t\t\tif (err < 0)\n\t\t\t\tgoto err_exit;\n\t\t\tself->msix_entry_mask |= (1 << cfg->link_irq_vec);\n\t\t}\n\n\t\terr = self->aq_hw_ops->hw_irq_enable(self->aq_hw,\n\t\t\t\t\t\t     AQ_CFG_IRQ_MASK);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\t}\n\n\terr = netif_set_real_num_tx_queues(self->ndev,\n\t\t\t\t\t   self->aq_vecs * cfg->tcs);\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\terr = netif_set_real_num_rx_queues(self->ndev,\n\t\t\t\t\t   self->aq_vecs * cfg->tcs);\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\tfor (i = 0; i < cfg->tcs; i++) {\n\t\tu16 offset = self->aq_vecs * i;\n\n\t\tnetdev_set_tc_queue(self->ndev, i, self->aq_vecs, offset);\n\t}\n\tnetif_tx_start_all_queues(self->ndev);\n\nerr_exit:\n\treturn err;\n}\n\nstatic unsigned int aq_nic_map_xdp(struct aq_nic_s *self,\n\t\t\t\t   struct xdp_frame *xdpf,\n\t\t\t\t   struct aq_ring_s *ring)\n{\n\tstruct device *dev = aq_nic_get_dev(self);\n\tstruct aq_ring_buff_s *first = NULL;\n\tunsigned int dx = ring->sw_tail;\n\tstruct aq_ring_buff_s *dx_buff;\n\tstruct skb_shared_info *sinfo;\n\tunsigned int frag_count = 0U;\n\tunsigned int nr_frags = 0U;\n\tunsigned int ret = 0U;\n\tu16 total_len;\n\n\tdx_buff = &ring->buff_ring[dx];\n\tdx_buff->flags = 0U;\n\n\tsinfo = xdp_get_shared_info_from_frame(xdpf);\n\ttotal_len = xdpf->len;\n\tdx_buff->len = total_len;\n\tif (xdp_frame_has_frags(xdpf)) {\n\t\tnr_frags = sinfo->nr_frags;\n\t\ttotal_len += sinfo->xdp_frags_size;\n\t}\n\tdx_buff->pa = dma_map_single(dev, xdpf->data, dx_buff->len,\n\t\t\t\t     DMA_TO_DEVICE);\n\n\tif (unlikely(dma_mapping_error(dev, dx_buff->pa)))\n\t\tgoto exit;\n\n\tfirst = dx_buff;\n\tdx_buff->len_pkt = total_len;\n\tdx_buff->is_sop = 1U;\n\tdx_buff->is_mapped = 1U;\n\t++ret;\n\n\tfor (; nr_frags--; ++frag_count) {\n\t\tskb_frag_t *frag = &sinfo->frags[frag_count];\n\t\tunsigned int frag_len = skb_frag_size(frag);\n\t\tunsigned int buff_offset = 0U;\n\t\tunsigned int buff_size = 0U;\n\t\tdma_addr_t frag_pa;\n\n\t\twhile (frag_len) {\n\t\t\tif (frag_len > AQ_CFG_TX_FRAME_MAX)\n\t\t\t\tbuff_size = AQ_CFG_TX_FRAME_MAX;\n\t\t\telse\n\t\t\t\tbuff_size = frag_len;\n\n\t\t\tfrag_pa = skb_frag_dma_map(dev, frag, buff_offset,\n\t\t\t\t\t\t   buff_size, DMA_TO_DEVICE);\n\n\t\t\tif (unlikely(dma_mapping_error(dev, frag_pa)))\n\t\t\t\tgoto mapping_error;\n\n\t\t\tdx = aq_ring_next_dx(ring, dx);\n\t\t\tdx_buff = &ring->buff_ring[dx];\n\n\t\t\tdx_buff->flags = 0U;\n\t\t\tdx_buff->len = buff_size;\n\t\t\tdx_buff->pa = frag_pa;\n\t\t\tdx_buff->is_mapped = 1U;\n\t\t\tdx_buff->eop_index = 0xffffU;\n\n\t\t\tfrag_len -= buff_size;\n\t\t\tbuff_offset += buff_size;\n\n\t\t\t++ret;\n\t\t}\n\t}\n\n\tfirst->eop_index = dx;\n\tdx_buff->is_eop = 1U;\n\tdx_buff->skb = NULL;\n\tdx_buff->xdpf = xdpf;\n\tgoto exit;\n\nmapping_error:\n\tfor (dx = ring->sw_tail;\n\t     ret > 0;\n\t     --ret, dx = aq_ring_next_dx(ring, dx)) {\n\t\tdx_buff = &ring->buff_ring[dx];\n\n\t\tif (!dx_buff->pa)\n\t\t\tcontinue;\n\t\tif (unlikely(dx_buff->is_sop))\n\t\t\tdma_unmap_single(dev, dx_buff->pa, dx_buff->len,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\telse\n\t\t\tdma_unmap_page(dev, dx_buff->pa, dx_buff->len,\n\t\t\t\t       DMA_TO_DEVICE);\n\t}\n\nexit:\n\treturn ret;\n}\n\nunsigned int aq_nic_map_skb(struct aq_nic_s *self, struct sk_buff *skb,\n\t\t\t    struct aq_ring_s *ring)\n{\n\tunsigned int nr_frags = skb_shinfo(skb)->nr_frags;\n\tstruct aq_nic_cfg_s *cfg = aq_nic_get_cfg(self);\n\tstruct device *dev = aq_nic_get_dev(self);\n\tstruct aq_ring_buff_s *first = NULL;\n\tu8 ipver = ip_hdr(skb)->version;\n\tstruct aq_ring_buff_s *dx_buff;\n\tbool need_context_tag = false;\n\tunsigned int frag_count = 0U;\n\tunsigned int ret = 0U;\n\tunsigned int dx;\n\tu8 l4proto = 0;\n\n\tif (ipver == 4)\n\t\tl4proto = ip_hdr(skb)->protocol;\n\telse if (ipver == 6)\n\t\tl4proto = ipv6_hdr(skb)->nexthdr;\n\n\tdx = ring->sw_tail;\n\tdx_buff = &ring->buff_ring[dx];\n\tdx_buff->flags = 0U;\n\n\tif (unlikely(skb_is_gso(skb))) {\n\t\tdx_buff->mss = skb_shinfo(skb)->gso_size;\n\t\tif (l4proto == IPPROTO_TCP) {\n\t\t\tdx_buff->is_gso_tcp = 1U;\n\t\t\tdx_buff->len_l4 = tcp_hdrlen(skb);\n\t\t} else if (l4proto == IPPROTO_UDP) {\n\t\t\tdx_buff->is_gso_udp = 1U;\n\t\t\tdx_buff->len_l4 = sizeof(struct udphdr);\n\t\t\t \n\t\t\tudp_hdr(skb)->len = htons(dx_buff->mss +\n\t\t\t\t\t\t  dx_buff->len_l4);\n\t\t} else {\n\t\t\tWARN_ONCE(true, \"Bad GSO mode\");\n\t\t\tgoto exit;\n\t\t}\n\t\tdx_buff->len_pkt = skb->len;\n\t\tdx_buff->len_l2 = ETH_HLEN;\n\t\tdx_buff->len_l3 = skb_network_header_len(skb);\n\t\tdx_buff->eop_index = 0xffffU;\n\t\tdx_buff->is_ipv6 = (ipver == 6);\n\t\tneed_context_tag = true;\n\t}\n\n\tif (cfg->is_vlan_tx_insert && skb_vlan_tag_present(skb)) {\n\t\tdx_buff->vlan_tx_tag = skb_vlan_tag_get(skb);\n\t\tdx_buff->len_pkt = skb->len;\n\t\tdx_buff->is_vlan = 1U;\n\t\tneed_context_tag = true;\n\t}\n\n\tif (need_context_tag) {\n\t\tdx = aq_ring_next_dx(ring, dx);\n\t\tdx_buff = &ring->buff_ring[dx];\n\t\tdx_buff->flags = 0U;\n\t\t++ret;\n\t}\n\n\tdx_buff->len = skb_headlen(skb);\n\tdx_buff->pa = dma_map_single(dev,\n\t\t\t\t     skb->data,\n\t\t\t\t     dx_buff->len,\n\t\t\t\t     DMA_TO_DEVICE);\n\n\tif (unlikely(dma_mapping_error(dev, dx_buff->pa))) {\n\t\tret = 0;\n\t\tgoto exit;\n\t}\n\n\tfirst = dx_buff;\n\tdx_buff->len_pkt = skb->len;\n\tdx_buff->is_sop = 1U;\n\tdx_buff->is_mapped = 1U;\n\t++ret;\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tdx_buff->is_ip_cso = (htons(ETH_P_IP) == skb->protocol);\n\t\tdx_buff->is_tcp_cso = (l4proto == IPPROTO_TCP);\n\t\tdx_buff->is_udp_cso = (l4proto == IPPROTO_UDP);\n\t}\n\n\tfor (; nr_frags--; ++frag_count) {\n\t\tunsigned int frag_len = 0U;\n\t\tunsigned int buff_offset = 0U;\n\t\tunsigned int buff_size = 0U;\n\t\tdma_addr_t frag_pa;\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[frag_count];\n\n\t\tfrag_len = skb_frag_size(frag);\n\n\t\twhile (frag_len) {\n\t\t\tif (frag_len > AQ_CFG_TX_FRAME_MAX)\n\t\t\t\tbuff_size = AQ_CFG_TX_FRAME_MAX;\n\t\t\telse\n\t\t\t\tbuff_size = frag_len;\n\n\t\t\tfrag_pa = skb_frag_dma_map(dev,\n\t\t\t\t\t\t   frag,\n\t\t\t\t\t\t   buff_offset,\n\t\t\t\t\t\t   buff_size,\n\t\t\t\t\t\t   DMA_TO_DEVICE);\n\n\t\t\tif (unlikely(dma_mapping_error(dev,\n\t\t\t\t\t\t       frag_pa)))\n\t\t\t\tgoto mapping_error;\n\n\t\t\tdx = aq_ring_next_dx(ring, dx);\n\t\t\tdx_buff = &ring->buff_ring[dx];\n\n\t\t\tdx_buff->flags = 0U;\n\t\t\tdx_buff->len = buff_size;\n\t\t\tdx_buff->pa = frag_pa;\n\t\t\tdx_buff->is_mapped = 1U;\n\t\t\tdx_buff->eop_index = 0xffffU;\n\n\t\t\tfrag_len -= buff_size;\n\t\t\tbuff_offset += buff_size;\n\n\t\t\t++ret;\n\t\t}\n\t}\n\n\tfirst->eop_index = dx;\n\tdx_buff->is_eop = 1U;\n\tdx_buff->skb = skb;\n\tdx_buff->xdpf = NULL;\n\tgoto exit;\n\nmapping_error:\n\tfor (dx = ring->sw_tail;\n\t     ret > 0;\n\t     --ret, dx = aq_ring_next_dx(ring, dx)) {\n\t\tdx_buff = &ring->buff_ring[dx];\n\n\t\tif (!(dx_buff->is_gso_tcp || dx_buff->is_gso_udp) &&\n\t\t    !dx_buff->is_vlan && dx_buff->pa) {\n\t\t\tif (unlikely(dx_buff->is_sop)) {\n\t\t\t\tdma_unmap_single(dev,\n\t\t\t\t\t\t dx_buff->pa,\n\t\t\t\t\t\t dx_buff->len,\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\t} else {\n\t\t\t\tdma_unmap_page(dev,\n\t\t\t\t\t       dx_buff->pa,\n\t\t\t\t\t       dx_buff->len,\n\t\t\t\t\t       DMA_TO_DEVICE);\n\t\t\t}\n\t\t}\n\t}\n\nexit:\n\treturn ret;\n}\n\nint aq_nic_xmit_xdpf(struct aq_nic_s *aq_nic, struct aq_ring_s *tx_ring,\n\t\t     struct xdp_frame *xdpf)\n{\n\tu16 queue_index = AQ_NIC_RING2QMAP(aq_nic, tx_ring->idx);\n\tstruct net_device *ndev = aq_nic_get_ndev(aq_nic);\n\tstruct skb_shared_info *sinfo;\n\tint cpu = smp_processor_id();\n\tint err = NETDEV_TX_BUSY;\n\tstruct netdev_queue *nq;\n\tunsigned int frags = 1;\n\n\tif (xdp_frame_has_frags(xdpf)) {\n\t\tsinfo = xdp_get_shared_info_from_frame(xdpf);\n\t\tfrags += sinfo->nr_frags;\n\t}\n\n\tif (frags > AQ_CFG_SKB_FRAGS_MAX)\n\t\treturn err;\n\n\tnq = netdev_get_tx_queue(ndev, tx_ring->idx);\n\t__netif_tx_lock(nq, cpu);\n\n\taq_ring_update_queue_state(tx_ring);\n\n\t \n\tif (__netif_subqueue_stopped(aq_nic_get_ndev(aq_nic), queue_index))\n\t\tgoto out;\n\n\tfrags = aq_nic_map_xdp(aq_nic, xdpf, tx_ring);\n\tif (likely(frags))\n\t\terr = aq_nic->aq_hw_ops->hw_ring_tx_xmit(aq_nic->aq_hw, tx_ring,\n\t\t\t\t\t\t\t frags);\nout:\n\t__netif_tx_unlock(nq);\n\n\treturn err;\n}\n\nint aq_nic_xmit(struct aq_nic_s *self, struct sk_buff *skb)\n{\n\tstruct aq_nic_cfg_s *cfg = aq_nic_get_cfg(self);\n\tunsigned int vec = skb->queue_mapping % cfg->vecs;\n\tunsigned int tc = skb->queue_mapping / cfg->vecs;\n\tstruct aq_ring_s *ring = NULL;\n\tunsigned int frags = 0U;\n\tint err = NETDEV_TX_OK;\n\n\tfrags = skb_shinfo(skb)->nr_frags + 1;\n\n\tring = self->aq_ring_tx[AQ_NIC_CFG_TCVEC2RING(cfg, tc, vec)];\n\n\tif (frags > AQ_CFG_SKB_FRAGS_MAX) {\n\t\tdev_kfree_skb_any(skb);\n\t\tgoto err_exit;\n\t}\n\n\taq_ring_update_queue_state(ring);\n\n\tif (cfg->priv_flags & BIT(AQ_HW_LOOPBACK_DMA_NET)) {\n\t\terr = NETDEV_TX_BUSY;\n\t\tgoto err_exit;\n\t}\n\n\t \n\tif (__netif_subqueue_stopped(self->ndev,\n\t\t\t\t     AQ_NIC_RING2QMAP(self, ring->idx))) {\n\t\terr = NETDEV_TX_BUSY;\n\t\tgoto err_exit;\n\t}\n\n\tfrags = aq_nic_map_skb(self, skb, ring);\n\n\tif (likely(frags)) {\n\t\terr = self->aq_hw_ops->hw_ring_tx_xmit(self->aq_hw,\n\t\t\t\t\t\t       ring, frags);\n\t} else {\n\t\terr = NETDEV_TX_BUSY;\n\t}\n\nerr_exit:\n\treturn err;\n}\n\nint aq_nic_update_interrupt_moderation_settings(struct aq_nic_s *self)\n{\n\treturn self->aq_hw_ops->hw_interrupt_moderation_set(self->aq_hw);\n}\n\nint aq_nic_set_packet_filter(struct aq_nic_s *self, unsigned int flags)\n{\n\tint err = 0;\n\n\terr = self->aq_hw_ops->hw_packet_filter_set(self->aq_hw, flags);\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\tself->packet_filter = flags;\n\nerr_exit:\n\treturn err;\n}\n\nint aq_nic_set_multicast_list(struct aq_nic_s *self, struct net_device *ndev)\n{\n\tconst struct aq_hw_ops *hw_ops = self->aq_hw_ops;\n\tstruct aq_nic_cfg_s *cfg = &self->aq_nic_cfg;\n\tunsigned int packet_filter = ndev->flags;\n\tstruct netdev_hw_addr *ha = NULL;\n\tunsigned int i = 0U;\n\tint err = 0;\n\n\tself->mc_list.count = 0;\n\tif (netdev_uc_count(ndev) > AQ_HW_MULTICAST_ADDRESS_MAX) {\n\t\tpacket_filter |= IFF_PROMISC;\n\t} else {\n\t\tnetdev_for_each_uc_addr(ha, ndev) {\n\t\t\tether_addr_copy(self->mc_list.ar[i++], ha->addr);\n\t\t}\n\t}\n\n\tcfg->is_mc_list_enabled = !!(packet_filter & IFF_MULTICAST);\n\tif (cfg->is_mc_list_enabled) {\n\t\tif (i + netdev_mc_count(ndev) > AQ_HW_MULTICAST_ADDRESS_MAX) {\n\t\t\tpacket_filter |= IFF_ALLMULTI;\n\t\t} else {\n\t\t\tnetdev_for_each_mc_addr(ha, ndev) {\n\t\t\t\tether_addr_copy(self->mc_list.ar[i++],\n\t\t\t\t\t\tha->addr);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (i > 0 && i <= AQ_HW_MULTICAST_ADDRESS_MAX) {\n\t\tself->mc_list.count = i;\n\t\terr = hw_ops->hw_multicast_list_set(self->aq_hw,\n\t\t\t\t\t\t    self->mc_list.ar,\n\t\t\t\t\t\t    self->mc_list.count);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn aq_nic_set_packet_filter(self, packet_filter);\n}\n\nint aq_nic_set_mtu(struct aq_nic_s *self, int new_mtu)\n{\n\tself->aq_nic_cfg.mtu = new_mtu;\n\n\treturn 0;\n}\n\nint aq_nic_set_mac(struct aq_nic_s *self, struct net_device *ndev)\n{\n\treturn self->aq_hw_ops->hw_set_mac_address(self->aq_hw, ndev->dev_addr);\n}\n\nunsigned int aq_nic_get_link_speed(struct aq_nic_s *self)\n{\n\treturn self->link_status.mbps;\n}\n\nint aq_nic_get_regs(struct aq_nic_s *self, struct ethtool_regs *regs, void *p)\n{\n\tu32 *regs_buff = p;\n\tint err = 0;\n\n\tif (unlikely(!self->aq_hw_ops->hw_get_regs))\n\t\treturn -EOPNOTSUPP;\n\n\tregs->version = 1;\n\n\terr = self->aq_hw_ops->hw_get_regs(self->aq_hw,\n\t\t\t\t\t   self->aq_nic_cfg.aq_hw_caps,\n\t\t\t\t\t   regs_buff);\n\tif (err < 0)\n\t\tgoto err_exit;\n\nerr_exit:\n\treturn err;\n}\n\nint aq_nic_get_regs_count(struct aq_nic_s *self)\n{\n\tif (unlikely(!self->aq_hw_ops->hw_get_regs))\n\t\treturn 0;\n\n\treturn self->aq_nic_cfg.aq_hw_caps->mac_regs_count;\n}\n\nu64 *aq_nic_get_stats(struct aq_nic_s *self, u64 *data)\n{\n\tstruct aq_stats_s *stats;\n\tunsigned int count = 0U;\n\tunsigned int i = 0U;\n\tunsigned int tc;\n\n\tif (self->aq_fw_ops->update_stats) {\n\t\tmutex_lock(&self->fwreq_mutex);\n\t\tself->aq_fw_ops->update_stats(self->aq_hw);\n\t\tmutex_unlock(&self->fwreq_mutex);\n\t}\n\tstats = self->aq_hw_ops->hw_get_hw_stats(self->aq_hw);\n\n\tif (!stats)\n\t\tgoto err_exit;\n\n\tdata[i] = stats->uprc + stats->mprc + stats->bprc;\n\tdata[++i] = stats->uprc;\n\tdata[++i] = stats->mprc;\n\tdata[++i] = stats->bprc;\n\tdata[++i] = stats->erpt;\n\tdata[++i] = stats->uptc + stats->mptc + stats->bptc;\n\tdata[++i] = stats->uptc;\n\tdata[++i] = stats->mptc;\n\tdata[++i] = stats->bptc;\n\tdata[++i] = stats->ubrc;\n\tdata[++i] = stats->ubtc;\n\tdata[++i] = stats->mbrc;\n\tdata[++i] = stats->mbtc;\n\tdata[++i] = stats->bbrc;\n\tdata[++i] = stats->bbtc;\n\tif (stats->brc)\n\t\tdata[++i] = stats->brc;\n\telse\n\t\tdata[++i] = stats->ubrc + stats->mbrc + stats->bbrc;\n\tif (stats->btc)\n\t\tdata[++i] = stats->btc;\n\telse\n\t\tdata[++i] = stats->ubtc + stats->mbtc + stats->bbtc;\n\tdata[++i] = stats->dma_pkt_rc;\n\tdata[++i] = stats->dma_pkt_tc;\n\tdata[++i] = stats->dma_oct_rc;\n\tdata[++i] = stats->dma_oct_tc;\n\tdata[++i] = stats->dpc;\n\n\ti++;\n\n\tdata += i;\n\n\tfor (tc = 0U; tc < self->aq_nic_cfg.tcs; tc++) {\n\t\tfor (i = 0U; self->aq_vecs > i; ++i) {\n\t\t\tif (!self->aq_vec[i])\n\t\t\t\tbreak;\n\t\t\tdata += count;\n\t\t\tcount = aq_vec_get_sw_stats(self->aq_vec[i], tc, data);\n\t\t}\n\t}\n\n\tdata += count;\n\nerr_exit:\n\treturn data;\n}\n\nstatic void aq_nic_update_ndev_stats(struct aq_nic_s *self)\n{\n\tstruct aq_stats_s *stats = self->aq_hw_ops->hw_get_hw_stats(self->aq_hw);\n\tstruct net_device *ndev = self->ndev;\n\n\tndev->stats.rx_packets = stats->dma_pkt_rc;\n\tndev->stats.rx_bytes = stats->dma_oct_rc;\n\tndev->stats.rx_errors = stats->erpr;\n\tndev->stats.rx_dropped = stats->dpc;\n\tndev->stats.tx_packets = stats->dma_pkt_tc;\n\tndev->stats.tx_bytes = stats->dma_oct_tc;\n\tndev->stats.tx_errors = stats->erpt;\n\tndev->stats.multicast = stats->mprc;\n}\n\nvoid aq_nic_get_link_ksettings(struct aq_nic_s *self,\n\t\t\t       struct ethtool_link_ksettings *cmd)\n{\n\tu32 lp_link_speed_msk;\n\n\tif (self->aq_nic_cfg.aq_hw_caps->media_type == AQ_HW_MEDIA_TYPE_FIBRE)\n\t\tcmd->base.port = PORT_FIBRE;\n\telse\n\t\tcmd->base.port = PORT_TP;\n\n\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\tif (self->link_status.mbps)\n\t\tcmd->base.duplex = self->link_status.full_duplex ?\n\t\t\t\t   DUPLEX_FULL : DUPLEX_HALF;\n\tcmd->base.autoneg = self->aq_nic_cfg.is_autoneg;\n\n\tethtool_link_ksettings_zero_link_mode(cmd, supported);\n\n\tif (self->aq_nic_cfg.aq_hw_caps->link_speed_msk & AQ_NIC_RATE_10G)\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t     10000baseT_Full);\n\n\tif (self->aq_nic_cfg.aq_hw_caps->link_speed_msk & AQ_NIC_RATE_5G)\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t     5000baseT_Full);\n\n\tif (self->aq_nic_cfg.aq_hw_caps->link_speed_msk & AQ_NIC_RATE_2G5)\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t     2500baseT_Full);\n\n\tif (self->aq_nic_cfg.aq_hw_caps->link_speed_msk & AQ_NIC_RATE_1G)\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t     1000baseT_Full);\n\n\tif (self->aq_nic_cfg.aq_hw_caps->link_speed_msk & AQ_NIC_RATE_1G_HALF)\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t     1000baseT_Half);\n\n\tif (self->aq_nic_cfg.aq_hw_caps->link_speed_msk & AQ_NIC_RATE_100M)\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t     100baseT_Full);\n\n\tif (self->aq_nic_cfg.aq_hw_caps->link_speed_msk & AQ_NIC_RATE_100M_HALF)\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t     100baseT_Half);\n\n\tif (self->aq_nic_cfg.aq_hw_caps->link_speed_msk & AQ_NIC_RATE_10M)\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t     10baseT_Full);\n\n\tif (self->aq_nic_cfg.aq_hw_caps->link_speed_msk & AQ_NIC_RATE_10M_HALF)\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t     10baseT_Half);\n\n\tif (self->aq_nic_cfg.aq_hw_caps->flow_control) {\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t     Pause);\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported,\n\t\t\t\t\t\t     Asym_Pause);\n\t}\n\n\tethtool_link_ksettings_add_link_mode(cmd, supported, Autoneg);\n\n\tif (self->aq_nic_cfg.aq_hw_caps->media_type == AQ_HW_MEDIA_TYPE_FIBRE)\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported, FIBRE);\n\telse\n\t\tethtool_link_ksettings_add_link_mode(cmd, supported, TP);\n\n\tethtool_link_ksettings_zero_link_mode(cmd, advertising);\n\n\tif (self->aq_nic_cfg.is_autoneg)\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising, Autoneg);\n\n\tif (self->aq_nic_cfg.link_speed_msk & AQ_NIC_RATE_10G)\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t     10000baseT_Full);\n\n\tif (self->aq_nic_cfg.link_speed_msk & AQ_NIC_RATE_5G)\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t     5000baseT_Full);\n\n\tif (self->aq_nic_cfg.link_speed_msk & AQ_NIC_RATE_2G5)\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t     2500baseT_Full);\n\n\tif (self->aq_nic_cfg.link_speed_msk & AQ_NIC_RATE_1G)\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t     1000baseT_Full);\n\n\tif (self->aq_nic_cfg.link_speed_msk & AQ_NIC_RATE_1G_HALF)\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t     1000baseT_Half);\n\n\tif (self->aq_nic_cfg.link_speed_msk & AQ_NIC_RATE_100M)\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t     100baseT_Full);\n\n\tif (self->aq_nic_cfg.link_speed_msk & AQ_NIC_RATE_100M_HALF)\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t     100baseT_Half);\n\n\tif (self->aq_nic_cfg.link_speed_msk & AQ_NIC_RATE_10M)\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t     10baseT_Full);\n\n\tif (self->aq_nic_cfg.link_speed_msk & AQ_NIC_RATE_10M_HALF)\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t     10baseT_Half);\n\n\tif (self->aq_nic_cfg.fc.cur & AQ_NIC_FC_RX)\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t     Pause);\n\n\t \n\tif (!!(self->aq_nic_cfg.fc.cur & AQ_NIC_FC_TX) ^\n\t    !!(self->aq_nic_cfg.fc.cur & AQ_NIC_FC_RX))\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising,\n\t\t\t\t\t\t     Asym_Pause);\n\n\tif (self->aq_nic_cfg.aq_hw_caps->media_type == AQ_HW_MEDIA_TYPE_FIBRE)\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising, FIBRE);\n\telse\n\t\tethtool_link_ksettings_add_link_mode(cmd, advertising, TP);\n\n\tethtool_link_ksettings_zero_link_mode(cmd, lp_advertising);\n\tlp_link_speed_msk = self->aq_hw->aq_link_status.lp_link_speed_msk;\n\n\tif (lp_link_speed_msk & AQ_NIC_RATE_10G)\n\t\tethtool_link_ksettings_add_link_mode(cmd, lp_advertising,\n\t\t\t\t\t\t     10000baseT_Full);\n\n\tif (lp_link_speed_msk & AQ_NIC_RATE_5G)\n\t\tethtool_link_ksettings_add_link_mode(cmd, lp_advertising,\n\t\t\t\t\t\t     5000baseT_Full);\n\n\tif (lp_link_speed_msk & AQ_NIC_RATE_2G5)\n\t\tethtool_link_ksettings_add_link_mode(cmd, lp_advertising,\n\t\t\t\t\t\t     2500baseT_Full);\n\n\tif (lp_link_speed_msk & AQ_NIC_RATE_1G)\n\t\tethtool_link_ksettings_add_link_mode(cmd, lp_advertising,\n\t\t\t\t\t\t     1000baseT_Full);\n\n\tif (lp_link_speed_msk & AQ_NIC_RATE_1G_HALF)\n\t\tethtool_link_ksettings_add_link_mode(cmd, lp_advertising,\n\t\t\t\t\t\t     1000baseT_Half);\n\n\tif (lp_link_speed_msk & AQ_NIC_RATE_100M)\n\t\tethtool_link_ksettings_add_link_mode(cmd, lp_advertising,\n\t\t\t\t\t\t     100baseT_Full);\n\n\tif (lp_link_speed_msk & AQ_NIC_RATE_100M_HALF)\n\t\tethtool_link_ksettings_add_link_mode(cmd, lp_advertising,\n\t\t\t\t\t\t     100baseT_Half);\n\n\tif (lp_link_speed_msk & AQ_NIC_RATE_10M)\n\t\tethtool_link_ksettings_add_link_mode(cmd, lp_advertising,\n\t\t\t\t\t\t     10baseT_Full);\n\n\tif (lp_link_speed_msk & AQ_NIC_RATE_10M_HALF)\n\t\tethtool_link_ksettings_add_link_mode(cmd, lp_advertising,\n\t\t\t\t\t\t     10baseT_Half);\n\n\tif (self->aq_hw->aq_link_status.lp_flow_control & AQ_NIC_FC_RX)\n\t\tethtool_link_ksettings_add_link_mode(cmd, lp_advertising,\n\t\t\t\t\t\t     Pause);\n\tif (!!(self->aq_hw->aq_link_status.lp_flow_control & AQ_NIC_FC_TX) ^\n\t    !!(self->aq_hw->aq_link_status.lp_flow_control & AQ_NIC_FC_RX))\n\t\tethtool_link_ksettings_add_link_mode(cmd, lp_advertising,\n\t\t\t\t\t\t     Asym_Pause);\n}\n\nint aq_nic_set_link_ksettings(struct aq_nic_s *self,\n\t\t\t      const struct ethtool_link_ksettings *cmd)\n{\n\tint fduplex = (cmd->base.duplex == DUPLEX_FULL);\n\tu32 speed = cmd->base.speed;\n\tu32 rate = 0U;\n\tint err = 0;\n\n\tif (!fduplex && speed > SPEED_1000) {\n\t\terr = -EINVAL;\n\t\tgoto err_exit;\n\t}\n\n\tif (cmd->base.autoneg == AUTONEG_ENABLE) {\n\t\trate = self->aq_nic_cfg.aq_hw_caps->link_speed_msk;\n\t\tself->aq_nic_cfg.is_autoneg = true;\n\t} else {\n\t\tswitch (speed) {\n\t\tcase SPEED_10:\n\t\t\trate = fduplex ? AQ_NIC_RATE_10M : AQ_NIC_RATE_10M_HALF;\n\t\t\tbreak;\n\n\t\tcase SPEED_100:\n\t\t\trate = fduplex ? AQ_NIC_RATE_100M\n\t\t\t\t       : AQ_NIC_RATE_100M_HALF;\n\t\t\tbreak;\n\n\t\tcase SPEED_1000:\n\t\t\trate = fduplex ? AQ_NIC_RATE_1G : AQ_NIC_RATE_1G_HALF;\n\t\t\tbreak;\n\n\t\tcase SPEED_2500:\n\t\t\trate = AQ_NIC_RATE_2G5;\n\t\t\tbreak;\n\n\t\tcase SPEED_5000:\n\t\t\trate = AQ_NIC_RATE_5G;\n\t\t\tbreak;\n\n\t\tcase SPEED_10000:\n\t\t\trate = AQ_NIC_RATE_10G;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terr = -1;\n\t\t\tgoto err_exit;\n\t\t}\n\t\tif (!(self->aq_nic_cfg.aq_hw_caps->link_speed_msk & rate)) {\n\t\t\terr = -1;\n\t\t\tgoto err_exit;\n\t\t}\n\n\t\tself->aq_nic_cfg.is_autoneg = false;\n\t}\n\n\tmutex_lock(&self->fwreq_mutex);\n\terr = self->aq_fw_ops->set_link_speed(self->aq_hw, rate);\n\tmutex_unlock(&self->fwreq_mutex);\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\tself->aq_nic_cfg.link_speed_msk = rate;\n\nerr_exit:\n\treturn err;\n}\n\nstruct aq_nic_cfg_s *aq_nic_get_cfg(struct aq_nic_s *self)\n{\n\treturn &self->aq_nic_cfg;\n}\n\nu32 aq_nic_get_fw_version(struct aq_nic_s *self)\n{\n\treturn self->aq_hw_ops->hw_get_fw_version(self->aq_hw);\n}\n\nint aq_nic_set_loopback(struct aq_nic_s *self)\n{\n\tstruct aq_nic_cfg_s *cfg = &self->aq_nic_cfg;\n\n\tif (!self->aq_hw_ops->hw_set_loopback ||\n\t    !self->aq_fw_ops->set_phyloopback)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&self->fwreq_mutex);\n\tself->aq_hw_ops->hw_set_loopback(self->aq_hw,\n\t\t\t\t\t AQ_HW_LOOPBACK_DMA_SYS,\n\t\t\t\t\t !!(cfg->priv_flags &\n\t\t\t\t\t    BIT(AQ_HW_LOOPBACK_DMA_SYS)));\n\n\tself->aq_hw_ops->hw_set_loopback(self->aq_hw,\n\t\t\t\t\t AQ_HW_LOOPBACK_PKT_SYS,\n\t\t\t\t\t !!(cfg->priv_flags &\n\t\t\t\t\t    BIT(AQ_HW_LOOPBACK_PKT_SYS)));\n\n\tself->aq_hw_ops->hw_set_loopback(self->aq_hw,\n\t\t\t\t\t AQ_HW_LOOPBACK_DMA_NET,\n\t\t\t\t\t !!(cfg->priv_flags &\n\t\t\t\t\t    BIT(AQ_HW_LOOPBACK_DMA_NET)));\n\n\tself->aq_fw_ops->set_phyloopback(self->aq_hw,\n\t\t\t\t\t AQ_HW_LOOPBACK_PHYINT_SYS,\n\t\t\t\t\t !!(cfg->priv_flags &\n\t\t\t\t\t    BIT(AQ_HW_LOOPBACK_PHYINT_SYS)));\n\n\tself->aq_fw_ops->set_phyloopback(self->aq_hw,\n\t\t\t\t\t AQ_HW_LOOPBACK_PHYEXT_SYS,\n\t\t\t\t\t !!(cfg->priv_flags &\n\t\t\t\t\t    BIT(AQ_HW_LOOPBACK_PHYEXT_SYS)));\n\tmutex_unlock(&self->fwreq_mutex);\n\n\treturn 0;\n}\n\nint aq_nic_stop(struct aq_nic_s *self)\n{\n\tunsigned int i = 0U;\n\n\tnetif_tx_disable(self->ndev);\n\tnetif_carrier_off(self->ndev);\n\n\tdel_timer_sync(&self->service_timer);\n\tcancel_work_sync(&self->service_task);\n\n\tself->aq_hw_ops->hw_irq_disable(self->aq_hw, AQ_CFG_IRQ_MASK);\n\n\tif (self->aq_nic_cfg.is_polling)\n\t\tdel_timer_sync(&self->polling_timer);\n\telse\n\t\taq_pci_func_free_irqs(self);\n\n\taq_ptp_irq_free(self);\n\n\tfor (i = 0U; self->aq_vecs > i; ++i)\n\t\taq_vec_stop(self->aq_vec[i]);\n\n\taq_ptp_ring_stop(self);\n\n\treturn self->aq_hw_ops->hw_stop(self->aq_hw);\n}\n\nvoid aq_nic_set_power(struct aq_nic_s *self)\n{\n\tif (self->power_state != AQ_HW_POWER_STATE_D0 ||\n\t    self->aq_hw->aq_nic_cfg->wol)\n\t\tif (likely(self->aq_fw_ops->set_power)) {\n\t\t\tmutex_lock(&self->fwreq_mutex);\n\t\t\tself->aq_fw_ops->set_power(self->aq_hw,\n\t\t\t\t\t\t   self->power_state,\n\t\t\t\t\t\t   self->ndev->dev_addr);\n\t\t\tmutex_unlock(&self->fwreq_mutex);\n\t\t}\n}\n\nvoid aq_nic_deinit(struct aq_nic_s *self, bool link_down)\n{\n\tstruct aq_vec_s *aq_vec = NULL;\n\tunsigned int i = 0U;\n\n\tif (!self)\n\t\tgoto err_exit;\n\n\tfor (i = 0U; i < self->aq_vecs; i++) {\n\t\taq_vec = self->aq_vec[i];\n\t\taq_vec_deinit(aq_vec);\n\t\taq_vec_ring_free(aq_vec);\n\t}\n\n\taq_ptp_unregister(self);\n\taq_ptp_ring_deinit(self);\n\taq_ptp_ring_free(self);\n\taq_ptp_free(self);\n\n\tif (likely(self->aq_fw_ops->deinit) && link_down) {\n\t\tmutex_lock(&self->fwreq_mutex);\n\t\tself->aq_fw_ops->deinit(self->aq_hw);\n\t\tmutex_unlock(&self->fwreq_mutex);\n\t}\n\nerr_exit:;\n}\n\nvoid aq_nic_free_vectors(struct aq_nic_s *self)\n{\n\tunsigned int i = 0U;\n\n\tif (!self)\n\t\tgoto err_exit;\n\n\tfor (i = ARRAY_SIZE(self->aq_vec); i--;) {\n\t\tif (self->aq_vec[i]) {\n\t\t\taq_vec_free(self->aq_vec[i]);\n\t\t\tself->aq_vec[i] = NULL;\n\t\t}\n\t}\n\nerr_exit:;\n}\n\nint aq_nic_realloc_vectors(struct aq_nic_s *self)\n{\n\tstruct aq_nic_cfg_s *cfg = aq_nic_get_cfg(self);\n\n\taq_nic_free_vectors(self);\n\n\tfor (self->aq_vecs = 0; self->aq_vecs < cfg->vecs; self->aq_vecs++) {\n\t\tself->aq_vec[self->aq_vecs] = aq_vec_alloc(self, self->aq_vecs,\n\t\t\t\t\t\t\t   cfg);\n\t\tif (unlikely(!self->aq_vec[self->aq_vecs]))\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nvoid aq_nic_shutdown(struct aq_nic_s *self)\n{\n\tint err = 0;\n\n\tif (!self->ndev)\n\t\treturn;\n\n\trtnl_lock();\n\n\tnetif_device_detach(self->ndev);\n\n\tif (netif_running(self->ndev)) {\n\t\terr = aq_nic_stop(self);\n\t\tif (err < 0)\n\t\t\tgoto err_exit;\n\t}\n\taq_nic_deinit(self, !self->aq_hw->aq_nic_cfg->wol);\n\taq_nic_set_power(self);\n\nerr_exit:\n\trtnl_unlock();\n}\n\nu8 aq_nic_reserve_filter(struct aq_nic_s *self, enum aq_rx_filter_type type)\n{\n\tu8 location = 0xFF;\n\tu32 fltr_cnt;\n\tu32 n_bit;\n\n\tswitch (type) {\n\tcase aq_rx_filter_ethertype:\n\t\tlocation = AQ_RX_LAST_LOC_FETHERT - AQ_RX_FIRST_LOC_FETHERT -\n\t\t\t   self->aq_hw_rx_fltrs.fet_reserved_count;\n\t\tself->aq_hw_rx_fltrs.fet_reserved_count++;\n\t\tbreak;\n\tcase aq_rx_filter_l3l4:\n\t\tfltr_cnt = AQ_RX_LAST_LOC_FL3L4 - AQ_RX_FIRST_LOC_FL3L4;\n\t\tn_bit = fltr_cnt - self->aq_hw_rx_fltrs.fl3l4.reserved_count;\n\n\t\tself->aq_hw_rx_fltrs.fl3l4.active_ipv4 |= BIT(n_bit);\n\t\tself->aq_hw_rx_fltrs.fl3l4.reserved_count++;\n\t\tlocation = n_bit;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn location;\n}\n\nvoid aq_nic_release_filter(struct aq_nic_s *self, enum aq_rx_filter_type type,\n\t\t\t   u32 location)\n{\n\tswitch (type) {\n\tcase aq_rx_filter_ethertype:\n\t\tself->aq_hw_rx_fltrs.fet_reserved_count--;\n\t\tbreak;\n\tcase aq_rx_filter_l3l4:\n\t\tself->aq_hw_rx_fltrs.fl3l4.reserved_count--;\n\t\tself->aq_hw_rx_fltrs.fl3l4.active_ipv4 &= ~BIT(location);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nint aq_nic_set_downshift(struct aq_nic_s *self, int val)\n{\n\tint err = 0;\n\tstruct aq_nic_cfg_s *cfg = &self->aq_nic_cfg;\n\n\tif (!self->aq_fw_ops->set_downshift)\n\t\treturn -EOPNOTSUPP;\n\n\tif (val > 15) {\n\t\tnetdev_err(self->ndev, \"downshift counter should be <= 15\\n\");\n\t\treturn -EINVAL;\n\t}\n\tcfg->downshift_counter = val;\n\n\tmutex_lock(&self->fwreq_mutex);\n\terr = self->aq_fw_ops->set_downshift(self->aq_hw, cfg->downshift_counter);\n\tmutex_unlock(&self->fwreq_mutex);\n\n\treturn err;\n}\n\nint aq_nic_set_media_detect(struct aq_nic_s *self, int val)\n{\n\tstruct aq_nic_cfg_s *cfg = &self->aq_nic_cfg;\n\tint err = 0;\n\n\tif (!self->aq_fw_ops->set_media_detect)\n\t\treturn -EOPNOTSUPP;\n\n\tif (val > 0 && val != AQ_HW_MEDIA_DETECT_CNT) {\n\t\tnetdev_err(self->ndev, \"EDPD on this device could have only fixed value of %d\\n\",\n\t\t\t   AQ_HW_MEDIA_DETECT_CNT);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&self->fwreq_mutex);\n\terr = self->aq_fw_ops->set_media_detect(self->aq_hw, !!val);\n\tmutex_unlock(&self->fwreq_mutex);\n\n\t \n\tif (!err)\n\t\tcfg->is_media_detect = !!val;\n\n\treturn err;\n}\n\nint aq_nic_setup_tc_mqprio(struct aq_nic_s *self, u32 tcs, u8 *prio_tc_map)\n{\n\tstruct aq_nic_cfg_s *cfg = &self->aq_nic_cfg;\n\tconst unsigned int prev_vecs = cfg->vecs;\n\tbool ndev_running;\n\tint err = 0;\n\tint i;\n\n\t \n\tif (tcs == cfg->tcs || (tcs == 0 && !cfg->is_qos))\n\t\treturn 0;\n\n\tndev_running = netif_running(self->ndev);\n\tif (ndev_running)\n\t\tdev_close(self->ndev);\n\n\tcfg->tcs = tcs;\n\tif (cfg->tcs == 0)\n\t\tcfg->tcs = 1;\n\tif (prio_tc_map)\n\t\tmemcpy(cfg->prio_tc_map, prio_tc_map, sizeof(cfg->prio_tc_map));\n\telse\n\t\tfor (i = 0; i < sizeof(cfg->prio_tc_map); i++)\n\t\t\tcfg->prio_tc_map[i] = cfg->tcs * i / 8;\n\n\tcfg->is_qos = !!tcs;\n\tcfg->is_ptp = (cfg->tcs <= AQ_HW_PTP_TC);\n\tif (!cfg->is_ptp)\n\t\tnetdev_warn(self->ndev, \"%s\\n\",\n\t\t\t    \"PTP is auto disabled due to requested TC count.\");\n\n\tnetdev_set_num_tc(self->ndev, cfg->tcs);\n\n\t \n\taq_nic_cfg_update_num_vecs(self);\n\tif (prev_vecs != cfg->vecs) {\n\t\terr = aq_nic_realloc_vectors(self);\n\t\tif (err)\n\t\t\tgoto err_exit;\n\t}\n\n\tif (ndev_running)\n\t\terr = dev_open(self->ndev, NULL);\n\nerr_exit:\n\treturn err;\n}\n\nint aq_nic_setup_tc_max_rate(struct aq_nic_s *self, const unsigned int tc,\n\t\t\t     const u32 max_rate)\n{\n\tstruct aq_nic_cfg_s *cfg = &self->aq_nic_cfg;\n\n\tif (tc >= AQ_CFG_TCS_MAX)\n\t\treturn -EINVAL;\n\n\tif (max_rate && max_rate < 10) {\n\t\tnetdev_warn(self->ndev,\n\t\t\t\"Setting %s to the minimum usable value of %dMbps.\\n\",\n\t\t\t\"max rate\", 10);\n\t\tcfg->tc_max_rate[tc] = 10;\n\t} else {\n\t\tcfg->tc_max_rate[tc] = max_rate;\n\t}\n\n\treturn 0;\n}\n\nint aq_nic_setup_tc_min_rate(struct aq_nic_s *self, const unsigned int tc,\n\t\t\t     const u32 min_rate)\n{\n\tstruct aq_nic_cfg_s *cfg = &self->aq_nic_cfg;\n\n\tif (tc >= AQ_CFG_TCS_MAX)\n\t\treturn -EINVAL;\n\n\tif (min_rate)\n\t\tset_bit(tc, &cfg->tc_min_rate_msk);\n\telse\n\t\tclear_bit(tc, &cfg->tc_min_rate_msk);\n\n\tif (min_rate && min_rate < 20) {\n\t\tnetdev_warn(self->ndev,\n\t\t\t\"Setting %s to the minimum usable value of %dMbps.\\n\",\n\t\t\t\"min rate\", 20);\n\t\tcfg->tc_min_rate[tc] = 20;\n\t} else {\n\t\tcfg->tc_min_rate[tc] = min_rate;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}