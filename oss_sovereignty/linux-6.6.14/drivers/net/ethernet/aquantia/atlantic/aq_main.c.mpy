{
  "module_name": "aq_main.c",
  "hash_id": "aeb3a6cac4d754b28d99f58fe95ce392b14e22533ef1f8fc8f9762fccd7b194c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/aquantia/atlantic/aq_main.c",
  "human_readable_source": "\n \n\n \n\n#include \"aq_main.h\"\n#include \"aq_nic.h\"\n#include \"aq_pci_func.h\"\n#include \"aq_ethtool.h\"\n#include \"aq_ptp.h\"\n#include \"aq_filters.h\"\n#include \"aq_hw_utils.h\"\n#include \"aq_vec.h\"\n\n#include <linux/netdevice.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/udp.h>\n#include <net/pkt_cls.h>\n#include <net/pkt_sched.h>\n#include <linux/filter.h>\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(AQ_CFG_DRV_AUTHOR);\nMODULE_DESCRIPTION(AQ_CFG_DRV_DESC);\n\nDEFINE_STATIC_KEY_FALSE(aq_xdp_locking_key);\nEXPORT_SYMBOL(aq_xdp_locking_key);\n\nstatic const char aq_ndev_driver_name[] = AQ_CFG_DRV_NAME;\n\nstatic const struct net_device_ops aq_ndev_ops;\n\nstatic struct workqueue_struct *aq_ndev_wq;\n\nvoid aq_ndev_schedule_work(struct work_struct *work)\n{\n\tqueue_work(aq_ndev_wq, work);\n}\n\nstruct net_device *aq_ndev_alloc(void)\n{\n\tstruct net_device *ndev = NULL;\n\tstruct aq_nic_s *aq_nic = NULL;\n\n\tndev = alloc_etherdev_mq(sizeof(struct aq_nic_s), AQ_HW_QUEUES_MAX);\n\tif (!ndev)\n\t\treturn NULL;\n\n\taq_nic = netdev_priv(ndev);\n\taq_nic->ndev = ndev;\n\tndev->netdev_ops = &aq_ndev_ops;\n\tndev->ethtool_ops = &aq_ethtool_ops;\n\n\treturn ndev;\n}\n\nint aq_ndev_open(struct net_device *ndev)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tint err = 0;\n\n\terr = aq_nic_init(aq_nic);\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\terr = aq_reapply_rxnfc_all_rules(aq_nic);\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\terr = aq_filters_vlans_update(aq_nic);\n\tif (err < 0)\n\t\tgoto err_exit;\n\n\terr = aq_nic_start(aq_nic);\n\tif (err < 0) {\n\t\taq_nic_stop(aq_nic);\n\t\tgoto err_exit;\n\t}\n\nerr_exit:\n\tif (err < 0)\n\t\taq_nic_deinit(aq_nic, true);\n\n\treturn err;\n}\n\nint aq_ndev_close(struct net_device *ndev)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tint err = 0;\n\n\terr = aq_nic_stop(aq_nic);\n\taq_nic_deinit(aq_nic, true);\n\n\treturn err;\n}\n\nstatic netdev_tx_t aq_ndev_start_xmit(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\n#if IS_REACHABLE(CONFIG_PTP_1588_CLOCK)\n\tif (unlikely(aq_utils_obj_test(&aq_nic->flags, AQ_NIC_PTP_DPATH_UP))) {\n\t\t \n\t\tif (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) ||\n\t\t    unlikely((ip_hdr(skb)->version == 4) &&\n\t\t\t     (ip_hdr(skb)->protocol == IPPROTO_UDP) &&\n\t\t\t     ((udp_hdr(skb)->dest == htons(319)) ||\n\t\t\t      (udp_hdr(skb)->dest == htons(320)))) ||\n\t\t    unlikely(eth_hdr(skb)->h_proto == htons(ETH_P_1588)))\n\t\t\treturn aq_ptp_xmit(aq_nic, skb);\n\t}\n#endif\n\n\tskb_tx_timestamp(skb);\n\treturn aq_nic_xmit(aq_nic, skb);\n}\n\nstatic int aq_ndev_change_mtu(struct net_device *ndev, int new_mtu)\n{\n\tint new_frame_size = new_mtu + ETH_HLEN + ETH_FCS_LEN;\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tstruct bpf_prog *prog;\n\tint err;\n\n\tprog = READ_ONCE(aq_nic->xdp_prog);\n\tif (prog && !prog->aux->xdp_has_frags &&\n\t    new_frame_size > AQ_CFG_RX_FRAME_MAX) {\n\t\tnetdev_err(ndev, \"Illegal MTU %d for XDP prog without frags\\n\",\n\t\t\t   ndev->mtu);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = aq_nic_set_mtu(aq_nic, new_mtu + ETH_HLEN);\n\n\tif (err < 0)\n\t\tgoto err_exit;\n\tndev->mtu = new_mtu;\n\nerr_exit:\n\treturn err;\n}\n\nstatic int aq_ndev_set_features(struct net_device *ndev,\n\t\t\t\tnetdev_features_t features)\n{\n\tbool is_vlan_tx_insert = !!(features & NETIF_F_HW_VLAN_CTAG_TX);\n\tbool is_vlan_rx_strip = !!(features & NETIF_F_HW_VLAN_CTAG_RX);\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tbool need_ndev_restart = false;\n\tstruct aq_nic_cfg_s *aq_cfg;\n\tbool is_lro = false;\n\tint err = 0;\n\n\taq_cfg = aq_nic_get_cfg(aq_nic);\n\n\tif (!(features & NETIF_F_NTUPLE)) {\n\t\tif (aq_nic->ndev->features & NETIF_F_NTUPLE) {\n\t\t\terr = aq_clear_rxnfc_all_rules(aq_nic);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto err_exit;\n\t\t}\n\t}\n\tif (!(features & NETIF_F_HW_VLAN_CTAG_FILTER)) {\n\t\tif (aq_nic->ndev->features & NETIF_F_HW_VLAN_CTAG_FILTER) {\n\t\t\terr = aq_filters_vlan_offload_off(aq_nic);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto err_exit;\n\t\t}\n\t}\n\n\taq_cfg->features = features;\n\n\tif (aq_cfg->aq_hw_caps->hw_features & NETIF_F_LRO) {\n\t\tis_lro = features & NETIF_F_LRO;\n\n\t\tif (aq_cfg->is_lro != is_lro) {\n\t\t\taq_cfg->is_lro = is_lro;\n\t\t\tneed_ndev_restart = true;\n\t\t}\n\t}\n\n\tif ((aq_nic->ndev->features ^ features) & NETIF_F_RXCSUM) {\n\t\terr = aq_nic->aq_hw_ops->hw_set_offload(aq_nic->aq_hw,\n\t\t\t\t\t\t\taq_cfg);\n\n\t\tif (unlikely(err))\n\t\t\tgoto err_exit;\n\t}\n\n\tif (aq_cfg->is_vlan_rx_strip != is_vlan_rx_strip) {\n\t\taq_cfg->is_vlan_rx_strip = is_vlan_rx_strip;\n\t\tneed_ndev_restart = true;\n\t}\n\tif (aq_cfg->is_vlan_tx_insert != is_vlan_tx_insert) {\n\t\taq_cfg->is_vlan_tx_insert = is_vlan_tx_insert;\n\t\tneed_ndev_restart = true;\n\t}\n\n\tif (need_ndev_restart && netif_running(ndev)) {\n\t\taq_ndev_close(ndev);\n\t\taq_ndev_open(ndev);\n\t}\n\nerr_exit:\n\treturn err;\n}\n\nstatic netdev_features_t aq_ndev_fix_features(struct net_device *ndev,\n\t\t\t\t\t      netdev_features_t features)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tstruct bpf_prog *prog;\n\n\tif (!(features & NETIF_F_RXCSUM))\n\t\tfeatures &= ~NETIF_F_LRO;\n\n\tprog = READ_ONCE(aq_nic->xdp_prog);\n\tif (prog && !prog->aux->xdp_has_frags &&\n\t    aq_nic->xdp_prog && features & NETIF_F_LRO) {\n\t\tnetdev_err(ndev, \"LRO is not supported with single buffer XDP, disabling\\n\");\n\t\tfeatures &= ~NETIF_F_LRO;\n\t}\n\n\treturn features;\n}\n\nstatic int aq_ndev_set_mac_address(struct net_device *ndev, void *addr)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tint err = 0;\n\n\terr = eth_mac_addr(ndev, addr);\n\tif (err < 0)\n\t\tgoto err_exit;\n\terr = aq_nic_set_mac(aq_nic, ndev);\n\tif (err < 0)\n\t\tgoto err_exit;\n\nerr_exit:\n\treturn err;\n}\n\nstatic void aq_ndev_set_multicast_settings(struct net_device *ndev)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\n\t(void)aq_nic_set_multicast_list(aq_nic, ndev);\n}\n\n#if IS_REACHABLE(CONFIG_PTP_1588_CLOCK)\nstatic int aq_ndev_config_hwtstamp(struct aq_nic_s *aq_nic,\n\t\t\t\t   struct hwtstamp_config *config)\n{\n\tswitch (config->tx_type) {\n\tcase HWTSTAMP_TX_OFF:\n\tcase HWTSTAMP_TX_ON:\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tswitch (config->rx_filter) {\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\t\tconfig->rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\treturn aq_ptp_hwtstamp_config_set(aq_nic->aq_ptp, config);\n}\n#endif\n\nstatic int aq_ndev_hwtstamp_set(struct aq_nic_s *aq_nic, struct ifreq *ifr)\n{\n\tstruct hwtstamp_config config;\n#if IS_REACHABLE(CONFIG_PTP_1588_CLOCK)\n\tint ret_val;\n#endif\n\n\tif (!aq_nic->aq_ptp)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\n\t\treturn -EFAULT;\n#if IS_REACHABLE(CONFIG_PTP_1588_CLOCK)\n\tret_val = aq_ndev_config_hwtstamp(aq_nic, &config);\n\tif (ret_val)\n\t\treturn ret_val;\n#endif\n\n\treturn copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?\n\t       -EFAULT : 0;\n}\n\n#if IS_REACHABLE(CONFIG_PTP_1588_CLOCK)\nstatic int aq_ndev_hwtstamp_get(struct aq_nic_s *aq_nic, struct ifreq *ifr)\n{\n\tstruct hwtstamp_config config;\n\n\tif (!aq_nic->aq_ptp)\n\t\treturn -EOPNOTSUPP;\n\n\taq_ptp_hwtstamp_config_get(aq_nic->aq_ptp, &config);\n\treturn copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?\n\t       -EFAULT : 0;\n}\n#endif\n\nstatic int aq_ndev_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(netdev);\n\n\tswitch (cmd) {\n\tcase SIOCSHWTSTAMP:\n\t\treturn aq_ndev_hwtstamp_set(aq_nic, ifr);\n\n#if IS_REACHABLE(CONFIG_PTP_1588_CLOCK)\n\tcase SIOCGHWTSTAMP:\n\t\treturn aq_ndev_hwtstamp_get(aq_nic, ifr);\n#endif\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int aq_ndo_vlan_rx_add_vid(struct net_device *ndev, __be16 proto,\n\t\t\t\t  u16 vid)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\n\tif (!aq_nic->aq_hw_ops->hw_filter_vlan_set)\n\t\treturn -EOPNOTSUPP;\n\n\tset_bit(vid, aq_nic->active_vlans);\n\n\treturn aq_filters_vlans_update(aq_nic);\n}\n\nstatic int aq_ndo_vlan_rx_kill_vid(struct net_device *ndev, __be16 proto,\n\t\t\t\t   u16 vid)\n{\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\n\tif (!aq_nic->aq_hw_ops->hw_filter_vlan_set)\n\t\treturn -EOPNOTSUPP;\n\n\tclear_bit(vid, aq_nic->active_vlans);\n\n\tif (-ENOENT == aq_del_fvlan_by_vlan(aq_nic, vid))\n\t\treturn aq_filters_vlans_update(aq_nic);\n\n\treturn 0;\n}\n\nstatic int aq_validate_mqprio_opt(struct aq_nic_s *self,\n\t\t\t\t  struct tc_mqprio_qopt_offload *mqprio,\n\t\t\t\t  const unsigned int num_tc)\n{\n\tconst bool has_min_rate = !!(mqprio->flags & TC_MQPRIO_F_MIN_RATE);\n\tstruct aq_nic_cfg_s *aq_nic_cfg = aq_nic_get_cfg(self);\n\tconst unsigned int tcs_max = min_t(u8, aq_nic_cfg->aq_hw_caps->tcs_max,\n\t\t\t\t\t   AQ_CFG_TCS_MAX);\n\n\tif (num_tc > tcs_max) {\n\t\tnetdev_err(self->ndev, \"Too many TCs requested\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (num_tc != 0 && !is_power_of_2(num_tc)) {\n\t\tnetdev_err(self->ndev, \"TC count should be power of 2\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (has_min_rate && !ATL_HW_IS_CHIP_FEATURE(self->aq_hw, ANTIGUA)) {\n\t\tnetdev_err(self->ndev, \"Min tx rate is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int aq_ndo_setup_tc(struct net_device *dev, enum tc_setup_type type,\n\t\t\t   void *type_data)\n{\n\tstruct tc_mqprio_qopt_offload *mqprio = type_data;\n\tstruct aq_nic_s *aq_nic = netdev_priv(dev);\n\tbool has_min_rate;\n\tbool has_max_rate;\n\tint err;\n\tint i;\n\n\tif (type != TC_SETUP_QDISC_MQPRIO)\n\t\treturn -EOPNOTSUPP;\n\n\thas_min_rate = !!(mqprio->flags & TC_MQPRIO_F_MIN_RATE);\n\thas_max_rate = !!(mqprio->flags & TC_MQPRIO_F_MAX_RATE);\n\n\terr = aq_validate_mqprio_opt(aq_nic, mqprio, mqprio->qopt.num_tc);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < mqprio->qopt.num_tc; i++) {\n\t\tif (has_max_rate) {\n\t\t\tu64 max_rate = mqprio->max_rate[i];\n\n\t\t\tdo_div(max_rate, AQ_MBPS_DIVISOR);\n\t\t\taq_nic_setup_tc_max_rate(aq_nic, i, (u32)max_rate);\n\t\t}\n\n\t\tif (has_min_rate) {\n\t\t\tu64 min_rate = mqprio->min_rate[i];\n\n\t\t\tdo_div(min_rate, AQ_MBPS_DIVISOR);\n\t\t\taq_nic_setup_tc_min_rate(aq_nic, i, (u32)min_rate);\n\t\t}\n\t}\n\n\treturn aq_nic_setup_tc_mqprio(aq_nic, mqprio->qopt.num_tc,\n\t\t\t\t      mqprio->qopt.prio_tc_map);\n}\n\nstatic int aq_xdp_setup(struct net_device *ndev, struct bpf_prog *prog,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tbool need_update, running = netif_running(ndev);\n\tstruct aq_nic_s *aq_nic = netdev_priv(ndev);\n\tstruct bpf_prog *old_prog;\n\n\tif (prog && !prog->aux->xdp_has_frags) {\n\t\tif (ndev->mtu > AQ_CFG_RX_FRAME_MAX) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"prog does not support XDP frags\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (prog && ndev->features & NETIF_F_LRO) {\n\t\t\tnetdev_err(ndev,\n\t\t\t\t   \"LRO is not supported with single buffer XDP, disabling\\n\");\n\t\t\tndev->features &= ~NETIF_F_LRO;\n\t\t}\n\t}\n\n\tneed_update = !!aq_nic->xdp_prog != !!prog;\n\tif (running && need_update)\n\t\taq_ndev_close(ndev);\n\n\told_prog = xchg(&aq_nic->xdp_prog, prog);\n\tif (old_prog)\n\t\tbpf_prog_put(old_prog);\n\n\tif (!old_prog && prog)\n\t\tstatic_branch_inc(&aq_xdp_locking_key);\n\telse if (old_prog && !prog)\n\t\tstatic_branch_dec(&aq_xdp_locking_key);\n\n\tif (running && need_update)\n\t\treturn aq_ndev_open(ndev);\n\n\treturn 0;\n}\n\nstatic int aq_xdp(struct net_device *dev, struct netdev_bpf *xdp)\n{\n\tswitch (xdp->command) {\n\tcase XDP_SETUP_PROG:\n\t\treturn aq_xdp_setup(dev, xdp->prog, xdp->extack);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic const struct net_device_ops aq_ndev_ops = {\n\t.ndo_open = aq_ndev_open,\n\t.ndo_stop = aq_ndev_close,\n\t.ndo_start_xmit = aq_ndev_start_xmit,\n\t.ndo_set_rx_mode = aq_ndev_set_multicast_settings,\n\t.ndo_change_mtu = aq_ndev_change_mtu,\n\t.ndo_set_mac_address = aq_ndev_set_mac_address,\n\t.ndo_set_features = aq_ndev_set_features,\n\t.ndo_fix_features = aq_ndev_fix_features,\n\t.ndo_eth_ioctl = aq_ndev_ioctl,\n\t.ndo_vlan_rx_add_vid = aq_ndo_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid = aq_ndo_vlan_rx_kill_vid,\n\t.ndo_setup_tc = aq_ndo_setup_tc,\n\t.ndo_bpf = aq_xdp,\n\t.ndo_xdp_xmit = aq_xdp_xmit,\n};\n\nstatic int __init aq_ndev_init_module(void)\n{\n\tint ret;\n\n\taq_ndev_wq = create_singlethread_workqueue(aq_ndev_driver_name);\n\tif (!aq_ndev_wq) {\n\t\tpr_err(\"Failed to create workqueue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = aq_pci_func_register_driver();\n\tif (ret) {\n\t\tdestroy_workqueue(aq_ndev_wq);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit aq_ndev_exit_module(void)\n{\n\taq_pci_func_unregister_driver();\n\n\tif (aq_ndev_wq) {\n\t\tdestroy_workqueue(aq_ndev_wq);\n\t\taq_ndev_wq = NULL;\n\t}\n}\n\nmodule_init(aq_ndev_init_module);\nmodule_exit(aq_ndev_exit_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}