{
  "module_name": "greth.c",
  "hash_id": "c28c2fb8508bdc0e6f3808a7a4d6c920edcbdb50434d79df76042c41b7ccef1c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/aeroflex/greth.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/skbuff.h>\n#include <linux/io.h>\n#include <linux/crc32.h>\n#include <linux/mii.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <asm/cacheflush.h>\n#include <asm/byteorder.h>\n\n#ifdef CONFIG_SPARC\n#include <asm/idprom.h>\n#endif\n\n#include \"greth.h\"\n\n#define GRETH_DEF_MSG_ENABLE\t  \\\n\t(NETIF_MSG_DRV\t\t| \\\n\t NETIF_MSG_PROBE\t| \\\n\t NETIF_MSG_LINK\t\t| \\\n\t NETIF_MSG_IFDOWN\t| \\\n\t NETIF_MSG_IFUP\t\t| \\\n\t NETIF_MSG_RX_ERR\t| \\\n\t NETIF_MSG_TX_ERR)\n\nstatic int greth_debug = -1;\t \nmodule_param(greth_debug, int, 0);\nMODULE_PARM_DESC(greth_debug, \"GRETH bitmapped debugging message enable value\");\n\n \nstatic int macaddr[6];\nmodule_param_array(macaddr, int, NULL, 0);\nMODULE_PARM_DESC(macaddr, \"GRETH Ethernet MAC address\");\n\nstatic int greth_edcl = 1;\nmodule_param(greth_edcl, int, 0);\nMODULE_PARM_DESC(greth_edcl, \"GRETH EDCL usage indicator. Set to 1 if EDCL is used.\");\n\nstatic int greth_open(struct net_device *dev);\nstatic netdev_tx_t greth_start_xmit(struct sk_buff *skb,\n\t   struct net_device *dev);\nstatic netdev_tx_t greth_start_xmit_gbit(struct sk_buff *skb,\n\t   struct net_device *dev);\nstatic int greth_rx(struct net_device *dev, int limit);\nstatic int greth_rx_gbit(struct net_device *dev, int limit);\nstatic void greth_clean_tx(struct net_device *dev);\nstatic void greth_clean_tx_gbit(struct net_device *dev);\nstatic irqreturn_t greth_interrupt(int irq, void *dev_id);\nstatic int greth_close(struct net_device *dev);\nstatic int greth_set_mac_add(struct net_device *dev, void *p);\nstatic void greth_set_multicast_list(struct net_device *dev);\n\n#define GRETH_REGLOAD(a)\t    (be32_to_cpu(__raw_readl(&(a))))\n#define GRETH_REGSAVE(a, v)         (__raw_writel(cpu_to_be32(v), &(a)))\n#define GRETH_REGORIN(a, v)         (GRETH_REGSAVE(a, (GRETH_REGLOAD(a) | (v))))\n#define GRETH_REGANDIN(a, v)        (GRETH_REGSAVE(a, (GRETH_REGLOAD(a) & (v))))\n\n#define NEXT_TX(N)      (((N) + 1) & GRETH_TXBD_NUM_MASK)\n#define SKIP_TX(N, C)   (((N) + C) & GRETH_TXBD_NUM_MASK)\n#define NEXT_RX(N)      (((N) + 1) & GRETH_RXBD_NUM_MASK)\n\nstatic void greth_print_rx_packet(void *addr, int len)\n{\n\tprint_hex_dump(KERN_DEBUG, \"RX: \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\taddr, len, true);\n}\n\nstatic void greth_print_tx_packet(struct sk_buff *skb)\n{\n\tint i;\n\tint length;\n\n\tif (skb_shinfo(skb)->nr_frags == 0)\n\t\tlength = skb->len;\n\telse\n\t\tlength = skb_headlen(skb);\n\n\tprint_hex_dump(KERN_DEBUG, \"TX: \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\tskb->data, length, true);\n\n\tfor (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {\n\n\t\tprint_hex_dump(KERN_DEBUG, \"TX: \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t       skb_frag_address(&skb_shinfo(skb)->frags[i]),\n\t\t\t       skb_frag_size(&skb_shinfo(skb)->frags[i]), true);\n\t}\n}\n\nstatic inline void greth_enable_tx(struct greth_private *greth)\n{\n\twmb();\n\tGRETH_REGORIN(greth->regs->control, GRETH_TXEN);\n}\n\nstatic inline void greth_enable_tx_and_irq(struct greth_private *greth)\n{\n\twmb();  \n\tGRETH_REGORIN(greth->regs->control, GRETH_TXEN | GRETH_TXI);\n}\n\nstatic inline void greth_disable_tx(struct greth_private *greth)\n{\n\tGRETH_REGANDIN(greth->regs->control, ~GRETH_TXEN);\n}\n\nstatic inline void greth_enable_rx(struct greth_private *greth)\n{\n\twmb();\n\tGRETH_REGORIN(greth->regs->control, GRETH_RXEN);\n}\n\nstatic inline void greth_disable_rx(struct greth_private *greth)\n{\n\tGRETH_REGANDIN(greth->regs->control, ~GRETH_RXEN);\n}\n\nstatic inline void greth_enable_irqs(struct greth_private *greth)\n{\n\tGRETH_REGORIN(greth->regs->control, GRETH_RXI | GRETH_TXI);\n}\n\nstatic inline void greth_disable_irqs(struct greth_private *greth)\n{\n\tGRETH_REGANDIN(greth->regs->control, ~(GRETH_RXI|GRETH_TXI));\n}\n\nstatic inline void greth_write_bd(u32 *bd, u32 val)\n{\n\t__raw_writel(cpu_to_be32(val), bd);\n}\n\nstatic inline u32 greth_read_bd(u32 *bd)\n{\n\treturn be32_to_cpu(__raw_readl(bd));\n}\n\nstatic void greth_clean_rings(struct greth_private *greth)\n{\n\tint i;\n\tstruct greth_bd *rx_bdp = greth->rx_bd_base;\n\tstruct greth_bd *tx_bdp = greth->tx_bd_base;\n\n\tif (greth->gbit_mac) {\n\n\t\t \n\t\tfor (i = 0; i < GRETH_RXBD_NUM; i++, rx_bdp++) {\n\t\t\tif (greth->rx_skbuff[i] != NULL) {\n\t\t\t\tdev_kfree_skb(greth->rx_skbuff[i]);\n\t\t\t\tdma_unmap_single(greth->dev,\n\t\t\t\t\t\t greth_read_bd(&rx_bdp->addr),\n\t\t\t\t\t\t MAX_FRAME_SIZE+NET_IP_ALIGN,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\twhile (greth->tx_free < GRETH_TXBD_NUM) {\n\n\t\t\tstruct sk_buff *skb = greth->tx_skbuff[greth->tx_last];\n\t\t\tint nr_frags = skb_shinfo(skb)->nr_frags;\n\t\t\ttx_bdp = greth->tx_bd_base + greth->tx_last;\n\t\t\tgreth->tx_last = NEXT_TX(greth->tx_last);\n\n\t\t\tdma_unmap_single(greth->dev,\n\t\t\t\t\t greth_read_bd(&tx_bdp->addr),\n\t\t\t\t\t skb_headlen(skb),\n\t\t\t\t\t DMA_TO_DEVICE);\n\n\t\t\tfor (i = 0; i < nr_frags; i++) {\n\t\t\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\t\t\t\ttx_bdp = greth->tx_bd_base + greth->tx_last;\n\n\t\t\t\tdma_unmap_page(greth->dev,\n\t\t\t\t\t       greth_read_bd(&tx_bdp->addr),\n\t\t\t\t\t       skb_frag_size(frag),\n\t\t\t\t\t       DMA_TO_DEVICE);\n\n\t\t\t\tgreth->tx_last = NEXT_TX(greth->tx_last);\n\t\t\t}\n\t\t\tgreth->tx_free += nr_frags+1;\n\t\t\tdev_kfree_skb(skb);\n\t\t}\n\n\n\t} else {  \n\n\t\tfor (i = 0; i < GRETH_RXBD_NUM; i++, rx_bdp++) {\n\t\t\tkfree(greth->rx_bufs[i]);\n\t\t\tdma_unmap_single(greth->dev,\n\t\t\t\t\t greth_read_bd(&rx_bdp->addr),\n\t\t\t\t\t MAX_FRAME_SIZE,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t}\n\t\tfor (i = 0; i < GRETH_TXBD_NUM; i++, tx_bdp++) {\n\t\t\tkfree(greth->tx_bufs[i]);\n\t\t\tdma_unmap_single(greth->dev,\n\t\t\t\t\t greth_read_bd(&tx_bdp->addr),\n\t\t\t\t\t MAX_FRAME_SIZE,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t}\n\t}\n}\n\nstatic int greth_init_rings(struct greth_private *greth)\n{\n\tstruct sk_buff *skb;\n\tstruct greth_bd *rx_bd, *tx_bd;\n\tu32 dma_addr;\n\tint i;\n\n\trx_bd = greth->rx_bd_base;\n\ttx_bd = greth->tx_bd_base;\n\n\t \n\tif (greth->gbit_mac) {\n\n\t\tfor (i = 0; i < GRETH_RXBD_NUM; i++) {\n\t\t\tskb = netdev_alloc_skb(greth->netdev, MAX_FRAME_SIZE+NET_IP_ALIGN);\n\t\t\tif (skb == NULL) {\n\t\t\t\tif (netif_msg_ifup(greth))\n\t\t\t\t\tdev_err(greth->dev, \"Error allocating DMA ring.\\n\");\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tskb_reserve(skb, NET_IP_ALIGN);\n\t\t\tdma_addr = dma_map_single(greth->dev,\n\t\t\t\t\t\t  skb->data,\n\t\t\t\t\t\t  MAX_FRAME_SIZE+NET_IP_ALIGN,\n\t\t\t\t\t\t  DMA_FROM_DEVICE);\n\n\t\t\tif (dma_mapping_error(greth->dev, dma_addr)) {\n\t\t\t\tif (netif_msg_ifup(greth))\n\t\t\t\t\tdev_err(greth->dev, \"Could not create initial DMA mapping\\n\");\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tgreth->rx_skbuff[i] = skb;\n\t\t\tgreth_write_bd(&rx_bd[i].addr, dma_addr);\n\t\t\tgreth_write_bd(&rx_bd[i].stat, GRETH_BD_EN | GRETH_BD_IE);\n\t\t}\n\n\t} else {\n\n\t\t \n\t\tfor (i = 0; i < GRETH_RXBD_NUM; i++) {\n\n\t\t\tgreth->rx_bufs[i] = kmalloc(MAX_FRAME_SIZE, GFP_KERNEL);\n\n\t\t\tif (greth->rx_bufs[i] == NULL) {\n\t\t\t\tif (netif_msg_ifup(greth))\n\t\t\t\t\tdev_err(greth->dev, \"Error allocating DMA ring.\\n\");\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tdma_addr = dma_map_single(greth->dev,\n\t\t\t\t\t\t  greth->rx_bufs[i],\n\t\t\t\t\t\t  MAX_FRAME_SIZE,\n\t\t\t\t\t\t  DMA_FROM_DEVICE);\n\n\t\t\tif (dma_mapping_error(greth->dev, dma_addr)) {\n\t\t\t\tif (netif_msg_ifup(greth))\n\t\t\t\t\tdev_err(greth->dev, \"Could not create initial DMA mapping\\n\");\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tgreth_write_bd(&rx_bd[i].addr, dma_addr);\n\t\t\tgreth_write_bd(&rx_bd[i].stat, GRETH_BD_EN | GRETH_BD_IE);\n\t\t}\n\t\tfor (i = 0; i < GRETH_TXBD_NUM; i++) {\n\n\t\t\tgreth->tx_bufs[i] = kmalloc(MAX_FRAME_SIZE, GFP_KERNEL);\n\n\t\t\tif (greth->tx_bufs[i] == NULL) {\n\t\t\t\tif (netif_msg_ifup(greth))\n\t\t\t\t\tdev_err(greth->dev, \"Error allocating DMA ring.\\n\");\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t\tdma_addr = dma_map_single(greth->dev,\n\t\t\t\t\t\t  greth->tx_bufs[i],\n\t\t\t\t\t\t  MAX_FRAME_SIZE,\n\t\t\t\t\t\t  DMA_TO_DEVICE);\n\n\t\t\tif (dma_mapping_error(greth->dev, dma_addr)) {\n\t\t\t\tif (netif_msg_ifup(greth))\n\t\t\t\t\tdev_err(greth->dev, \"Could not create initial DMA mapping\\n\");\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tgreth_write_bd(&tx_bd[i].addr, dma_addr);\n\t\t\tgreth_write_bd(&tx_bd[i].stat, 0);\n\t\t}\n\t}\n\tgreth_write_bd(&rx_bd[GRETH_RXBD_NUM - 1].stat,\n\t\t       greth_read_bd(&rx_bd[GRETH_RXBD_NUM - 1].stat) | GRETH_BD_WR);\n\n\t \n\tgreth->rx_cur = 0;\n\tgreth->tx_next = 0;\n\tgreth->tx_last = 0;\n\tgreth->tx_free = GRETH_TXBD_NUM;\n\n\t \n\tGRETH_REGSAVE(greth->regs->tx_desc_p, greth->tx_bd_base_phys);\n\tGRETH_REGSAVE(greth->regs->rx_desc_p, greth->rx_bd_base_phys);\n\n\treturn 0;\n\ncleanup:\n\tgreth_clean_rings(greth);\n\treturn -ENOMEM;\n}\n\nstatic int greth_open(struct net_device *dev)\n{\n\tstruct greth_private *greth = netdev_priv(dev);\n\tint err;\n\n\terr = greth_init_rings(greth);\n\tif (err) {\n\t\tif (netif_msg_ifup(greth))\n\t\t\tdev_err(&dev->dev, \"Could not allocate memory for DMA rings\\n\");\n\t\treturn err;\n\t}\n\n\terr = request_irq(greth->irq, greth_interrupt, 0, \"eth\", (void *) dev);\n\tif (err) {\n\t\tif (netif_msg_ifup(greth))\n\t\t\tdev_err(&dev->dev, \"Could not allocate interrupt %d\\n\", dev->irq);\n\t\tgreth_clean_rings(greth);\n\t\treturn err;\n\t}\n\n\tif (netif_msg_ifup(greth))\n\t\tdev_dbg(&dev->dev, \" starting queue\\n\");\n\tnetif_start_queue(dev);\n\n\tGRETH_REGSAVE(greth->regs->status, 0xFF);\n\n\tnapi_enable(&greth->napi);\n\n\tgreth_enable_irqs(greth);\n\tgreth_enable_tx(greth);\n\tgreth_enable_rx(greth);\n\treturn 0;\n\n}\n\nstatic int greth_close(struct net_device *dev)\n{\n\tstruct greth_private *greth = netdev_priv(dev);\n\n\tnapi_disable(&greth->napi);\n\n\tgreth_disable_irqs(greth);\n\tgreth_disable_tx(greth);\n\tgreth_disable_rx(greth);\n\n\tnetif_stop_queue(dev);\n\n\tfree_irq(greth->irq, (void *) dev);\n\n\tgreth_clean_rings(greth);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t\ngreth_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct greth_private *greth = netdev_priv(dev);\n\tstruct greth_bd *bdp;\n\tint err = NETDEV_TX_OK;\n\tu32 status, dma_addr, ctrl;\n\tunsigned long flags;\n\n\t \n\tgreth_clean_tx(greth->netdev);\n\n\tif (unlikely(greth->tx_free <= 0)) {\n\t\tspin_lock_irqsave(&greth->devlock, flags); \n\t\tctrl = GRETH_REGLOAD(greth->regs->control);\n\t\t \n\t\tif (ctrl & GRETH_RXI)\n\t\t\tGRETH_REGSAVE(greth->regs->control, ctrl | GRETH_TXI);\n\t\tnetif_stop_queue(dev);\n\t\tspin_unlock_irqrestore(&greth->devlock, flags);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tif (netif_msg_pktdata(greth))\n\t\tgreth_print_tx_packet(skb);\n\n\n\tif (unlikely(skb->len > MAX_FRAME_SIZE)) {\n\t\tdev->stats.tx_errors++;\n\t\tgoto out;\n\t}\n\n\tbdp = greth->tx_bd_base + greth->tx_next;\n\tdma_addr = greth_read_bd(&bdp->addr);\n\n\tmemcpy((unsigned char *) phys_to_virt(dma_addr), skb->data, skb->len);\n\n\tdma_sync_single_for_device(greth->dev, dma_addr, skb->len, DMA_TO_DEVICE);\n\n\tstatus = GRETH_BD_EN | GRETH_BD_IE | (skb->len & GRETH_BD_LEN);\n\tgreth->tx_bufs_length[greth->tx_next] = skb->len & GRETH_BD_LEN;\n\n\t \n\tif (greth->tx_next == GRETH_TXBD_NUM_MASK) {\n\t\tstatus |= GRETH_BD_WR;\n\t}\n\n\tgreth->tx_next = NEXT_TX(greth->tx_next);\n\tgreth->tx_free--;\n\n\t \n\tgreth_write_bd(&bdp->stat, status);\n\tspin_lock_irqsave(&greth->devlock, flags);  \n\tgreth_enable_tx(greth);\n\tspin_unlock_irqrestore(&greth->devlock, flags);\n\nout:\n\tdev_kfree_skb(skb);\n\treturn err;\n}\n\nstatic inline u16 greth_num_free_bds(u16 tx_last, u16 tx_next)\n{\n\tif (tx_next < tx_last)\n\t\treturn (tx_last - tx_next) - 1;\n\telse\n\t\treturn GRETH_TXBD_NUM - (tx_next - tx_last) - 1;\n}\n\nstatic netdev_tx_t\ngreth_start_xmit_gbit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct greth_private *greth = netdev_priv(dev);\n\tstruct greth_bd *bdp;\n\tu32 status, dma_addr;\n\tint curr_tx, nr_frags, i, err = NETDEV_TX_OK;\n\tunsigned long flags;\n\tu16 tx_last;\n\n\tnr_frags = skb_shinfo(skb)->nr_frags;\n\ttx_last = greth->tx_last;\n\trmb();  \n\n\tif (greth_num_free_bds(tx_last, greth->tx_next) < nr_frags + 1) {\n\t\tnetif_stop_queue(dev);\n\t\terr = NETDEV_TX_BUSY;\n\t\tgoto out;\n\t}\n\n\tif (netif_msg_pktdata(greth))\n\t\tgreth_print_tx_packet(skb);\n\n\tif (unlikely(skb->len > MAX_FRAME_SIZE)) {\n\t\tdev->stats.tx_errors++;\n\t\tgoto out;\n\t}\n\n\t \n\tgreth->tx_skbuff[greth->tx_next] = skb;\n\n\t \n\tif (nr_frags != 0)\n\t\tstatus = GRETH_TXBD_MORE;\n\telse\n\t\tstatus = GRETH_BD_IE;\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\tstatus |= GRETH_TXBD_CSALL;\n\tstatus |= skb_headlen(skb) & GRETH_BD_LEN;\n\tif (greth->tx_next == GRETH_TXBD_NUM_MASK)\n\t\tstatus |= GRETH_BD_WR;\n\n\n\tbdp = greth->tx_bd_base + greth->tx_next;\n\tgreth_write_bd(&bdp->stat, status);\n\tdma_addr = dma_map_single(greth->dev, skb->data, skb_headlen(skb), DMA_TO_DEVICE);\n\n\tif (unlikely(dma_mapping_error(greth->dev, dma_addr)))\n\t\tgoto map_error;\n\n\tgreth_write_bd(&bdp->addr, dma_addr);\n\n\tcurr_tx = NEXT_TX(greth->tx_next);\n\n\t \n\tfor (i = 0; i < nr_frags; i++) {\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\t\tgreth->tx_skbuff[curr_tx] = NULL;\n\t\tbdp = greth->tx_bd_base + curr_tx;\n\n\t\tstatus = GRETH_BD_EN;\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\t\tstatus |= GRETH_TXBD_CSALL;\n\t\tstatus |= skb_frag_size(frag) & GRETH_BD_LEN;\n\n\t\t \n\t\tif (curr_tx == GRETH_TXBD_NUM_MASK)\n\t\t\tstatus |= GRETH_BD_WR;\n\n\t\t \n\t\tif (i < nr_frags - 1)\n\t\t\tstatus |= GRETH_TXBD_MORE;\n\t\telse\n\t\t\tstatus |= GRETH_BD_IE;  \n\n\t\tgreth_write_bd(&bdp->stat, status);\n\n\t\tdma_addr = skb_frag_dma_map(greth->dev, frag, 0, skb_frag_size(frag),\n\t\t\t\t\t    DMA_TO_DEVICE);\n\n\t\tif (unlikely(dma_mapping_error(greth->dev, dma_addr)))\n\t\t\tgoto frag_map_error;\n\n\t\tgreth_write_bd(&bdp->addr, dma_addr);\n\n\t\tcurr_tx = NEXT_TX(curr_tx);\n\t}\n\n\twmb();\n\n\t \n\tbdp = greth->tx_bd_base + greth->tx_next;\n\tgreth_write_bd(&bdp->stat,\n\t\t       greth_read_bd(&bdp->stat) | GRETH_BD_EN);\n\n\tspin_lock_irqsave(&greth->devlock, flags);  \n\tgreth->tx_next = curr_tx;\n\tgreth_enable_tx_and_irq(greth);\n\tspin_unlock_irqrestore(&greth->devlock, flags);\n\n\treturn NETDEV_TX_OK;\n\nfrag_map_error:\n\t \n\tfor (i = 0; greth->tx_next + i != curr_tx; i++) {\n\t\tbdp = greth->tx_bd_base + greth->tx_next + i;\n\t\tdma_unmap_single(greth->dev,\n\t\t\t\t greth_read_bd(&bdp->addr),\n\t\t\t\t greth_read_bd(&bdp->stat) & GRETH_BD_LEN,\n\t\t\t\t DMA_TO_DEVICE);\n\t\tgreth_write_bd(&bdp->stat, 0);\n\t}\nmap_error:\n\tif (net_ratelimit())\n\t\tdev_warn(greth->dev, \"Could not create TX DMA mapping\\n\");\n\tdev_kfree_skb(skb);\nout:\n\treturn err;\n}\n\nstatic irqreturn_t greth_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct greth_private *greth;\n\tu32 status, ctrl;\n\tirqreturn_t retval = IRQ_NONE;\n\n\tgreth = netdev_priv(dev);\n\n\tspin_lock(&greth->devlock);\n\n\t \n\tstatus = GRETH_REGLOAD(greth->regs->status);\n\n\t \n\tctrl = GRETH_REGLOAD(greth->regs->control);\n\n\t \n\tif (((status & (GRETH_INT_RE | GRETH_INT_RX)) && (ctrl & GRETH_RXI)) ||\n\t    ((status & (GRETH_INT_TE | GRETH_INT_TX)) && (ctrl & GRETH_TXI))) {\n\t\tretval = IRQ_HANDLED;\n\n\t\t \n\t\tgreth_disable_irqs(greth);\n\t\tnapi_schedule(&greth->napi);\n\t}\n\n\tspin_unlock(&greth->devlock);\n\n\treturn retval;\n}\n\nstatic void greth_clean_tx(struct net_device *dev)\n{\n\tstruct greth_private *greth;\n\tstruct greth_bd *bdp;\n\tu32 stat;\n\n\tgreth = netdev_priv(dev);\n\n\twhile (1) {\n\t\tbdp = greth->tx_bd_base + greth->tx_last;\n\t\tGRETH_REGSAVE(greth->regs->status, GRETH_INT_TE | GRETH_INT_TX);\n\t\tmb();\n\t\tstat = greth_read_bd(&bdp->stat);\n\n\t\tif (unlikely(stat & GRETH_BD_EN))\n\t\t\tbreak;\n\n\t\tif (greth->tx_free == GRETH_TXBD_NUM)\n\t\t\tbreak;\n\n\t\t \n\t\tif (unlikely(stat & GRETH_TXBD_STATUS)) {\n\t\t\tdev->stats.tx_errors++;\n\t\t\tif (stat & GRETH_TXBD_ERR_AL)\n\t\t\t\tdev->stats.tx_aborted_errors++;\n\t\t\tif (stat & GRETH_TXBD_ERR_UE)\n\t\t\t\tdev->stats.tx_fifo_errors++;\n\t\t}\n\t\tdev->stats.tx_packets++;\n\t\tdev->stats.tx_bytes += greth->tx_bufs_length[greth->tx_last];\n\t\tgreth->tx_last = NEXT_TX(greth->tx_last);\n\t\tgreth->tx_free++;\n\t}\n\n\tif (greth->tx_free > 0) {\n\t\tnetif_wake_queue(dev);\n\t}\n}\n\nstatic inline void greth_update_tx_stats(struct net_device *dev, u32 stat)\n{\n\t \n\tif (unlikely(stat & GRETH_TXBD_STATUS)) {\n\t\tdev->stats.tx_errors++;\n\t\tif (stat & GRETH_TXBD_ERR_AL)\n\t\t\tdev->stats.tx_aborted_errors++;\n\t\tif (stat & GRETH_TXBD_ERR_UE)\n\t\t\tdev->stats.tx_fifo_errors++;\n\t\tif (stat & GRETH_TXBD_ERR_LC)\n\t\t\tdev->stats.tx_aborted_errors++;\n\t}\n\tdev->stats.tx_packets++;\n}\n\nstatic void greth_clean_tx_gbit(struct net_device *dev)\n{\n\tstruct greth_private *greth;\n\tstruct greth_bd *bdp, *bdp_last_frag;\n\tstruct sk_buff *skb = NULL;\n\tu32 stat;\n\tint nr_frags, i;\n\tu16 tx_last;\n\n\tgreth = netdev_priv(dev);\n\ttx_last = greth->tx_last;\n\n\twhile (tx_last != greth->tx_next) {\n\n\t\tskb = greth->tx_skbuff[tx_last];\n\n\t\tnr_frags = skb_shinfo(skb)->nr_frags;\n\n\t\t \n\t\tbdp_last_frag = greth->tx_bd_base + SKIP_TX(tx_last, nr_frags);\n\n\t\tGRETH_REGSAVE(greth->regs->status, GRETH_INT_TE | GRETH_INT_TX);\n\t\tmb();\n\t\tstat = greth_read_bd(&bdp_last_frag->stat);\n\n\t\tif (stat & GRETH_BD_EN)\n\t\t\tbreak;\n\n\t\tgreth->tx_skbuff[tx_last] = NULL;\n\n\t\tgreth_update_tx_stats(dev, stat);\n\t\tdev->stats.tx_bytes += skb->len;\n\n\t\tbdp = greth->tx_bd_base + tx_last;\n\n\t\ttx_last = NEXT_TX(tx_last);\n\n\t\tdma_unmap_single(greth->dev,\n\t\t\t\t greth_read_bd(&bdp->addr),\n\t\t\t\t skb_headlen(skb),\n\t\t\t\t DMA_TO_DEVICE);\n\n\t\tfor (i = 0; i < nr_frags; i++) {\n\t\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\t\t\tbdp = greth->tx_bd_base + tx_last;\n\n\t\t\tdma_unmap_page(greth->dev,\n\t\t\t\t       greth_read_bd(&bdp->addr),\n\t\t\t\t       skb_frag_size(frag),\n\t\t\t\t       DMA_TO_DEVICE);\n\n\t\t\ttx_last = NEXT_TX(tx_last);\n\t\t}\n\t\tdev_kfree_skb(skb);\n\t}\n\tif (skb) {  \n\t\twmb();\n\t\tgreth->tx_last = tx_last;\n\n\t\tif (netif_queue_stopped(dev) &&\n\t\t    (greth_num_free_bds(tx_last, greth->tx_next) >\n\t\t    (MAX_SKB_FRAGS+1)))\n\t\t\tnetif_wake_queue(dev);\n\t}\n}\n\nstatic int greth_rx(struct net_device *dev, int limit)\n{\n\tstruct greth_private *greth;\n\tstruct greth_bd *bdp;\n\tstruct sk_buff *skb;\n\tint pkt_len;\n\tint bad, count;\n\tu32 status, dma_addr;\n\tunsigned long flags;\n\n\tgreth = netdev_priv(dev);\n\n\tfor (count = 0; count < limit; ++count) {\n\n\t\tbdp = greth->rx_bd_base + greth->rx_cur;\n\t\tGRETH_REGSAVE(greth->regs->status, GRETH_INT_RE | GRETH_INT_RX);\n\t\tmb();\n\t\tstatus = greth_read_bd(&bdp->stat);\n\n\t\tif (unlikely(status & GRETH_BD_EN)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tdma_addr = greth_read_bd(&bdp->addr);\n\t\tbad = 0;\n\n\t\t \n\t\tif (unlikely(status & GRETH_RXBD_STATUS)) {\n\t\t\tif (status & GRETH_RXBD_ERR_FT) {\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t\tbad = 1;\n\t\t\t}\n\t\t\tif (status & (GRETH_RXBD_ERR_AE | GRETH_RXBD_ERR_OE)) {\n\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t\t\tbad = 1;\n\t\t\t}\n\t\t\tif (status & GRETH_RXBD_ERR_CRC) {\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\t\tbad = 1;\n\t\t\t}\n\t\t}\n\t\tif (unlikely(bad)) {\n\t\t\tdev->stats.rx_errors++;\n\n\t\t} else {\n\n\t\t\tpkt_len = status & GRETH_BD_LEN;\n\n\t\t\tskb = netdev_alloc_skb(dev, pkt_len + NET_IP_ALIGN);\n\n\t\t\tif (unlikely(skb == NULL)) {\n\n\t\t\t\tif (net_ratelimit())\n\t\t\t\t\tdev_warn(&dev->dev, \"low on memory - \" \"packet dropped\\n\");\n\n\t\t\t\tdev->stats.rx_dropped++;\n\n\t\t\t} else {\n\t\t\t\tskb_reserve(skb, NET_IP_ALIGN);\n\n\t\t\t\tdma_sync_single_for_cpu(greth->dev,\n\t\t\t\t\t\t\tdma_addr,\n\t\t\t\t\t\t\tpkt_len,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\n\t\t\t\tif (netif_msg_pktdata(greth))\n\t\t\t\t\tgreth_print_rx_packet(phys_to_virt(dma_addr), pkt_len);\n\n\t\t\t\tskb_put_data(skb, phys_to_virt(dma_addr),\n\t\t\t\t\t     pkt_len);\n\n\t\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\t\tdev->stats.rx_bytes += pkt_len;\n\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\tnetif_receive_skb(skb);\n\t\t\t}\n\t\t}\n\n\t\tstatus = GRETH_BD_EN | GRETH_BD_IE;\n\t\tif (greth->rx_cur == GRETH_RXBD_NUM_MASK) {\n\t\t\tstatus |= GRETH_BD_WR;\n\t\t}\n\n\t\twmb();\n\t\tgreth_write_bd(&bdp->stat, status);\n\n\t\tdma_sync_single_for_device(greth->dev, dma_addr, MAX_FRAME_SIZE, DMA_FROM_DEVICE);\n\n\t\tspin_lock_irqsave(&greth->devlock, flags);  \n\t\tgreth_enable_rx(greth);\n\t\tspin_unlock_irqrestore(&greth->devlock, flags);\n\n\t\tgreth->rx_cur = NEXT_RX(greth->rx_cur);\n\t}\n\n\treturn count;\n}\n\nstatic inline int hw_checksummed(u32 status)\n{\n\n\tif (status & GRETH_RXBD_IP_FRAG)\n\t\treturn 0;\n\n\tif (status & GRETH_RXBD_IP && status & GRETH_RXBD_IP_CSERR)\n\t\treturn 0;\n\n\tif (status & GRETH_RXBD_UDP && status & GRETH_RXBD_UDP_CSERR)\n\t\treturn 0;\n\n\tif (status & GRETH_RXBD_TCP && status & GRETH_RXBD_TCP_CSERR)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int greth_rx_gbit(struct net_device *dev, int limit)\n{\n\tstruct greth_private *greth;\n\tstruct greth_bd *bdp;\n\tstruct sk_buff *skb, *newskb;\n\tint pkt_len;\n\tint bad, count = 0;\n\tu32 status, dma_addr;\n\tunsigned long flags;\n\n\tgreth = netdev_priv(dev);\n\n\tfor (count = 0; count < limit; ++count) {\n\n\t\tbdp = greth->rx_bd_base + greth->rx_cur;\n\t\tskb = greth->rx_skbuff[greth->rx_cur];\n\t\tGRETH_REGSAVE(greth->regs->status, GRETH_INT_RE | GRETH_INT_RX);\n\t\tmb();\n\t\tstatus = greth_read_bd(&bdp->stat);\n\t\tbad = 0;\n\n\t\tif (status & GRETH_BD_EN)\n\t\t\tbreak;\n\n\t\t \n\t\tif (unlikely(status & GRETH_RXBD_STATUS)) {\n\n\t\t\tif (status & GRETH_RXBD_ERR_FT) {\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t\tbad = 1;\n\t\t\t} else if (status &\n\t\t\t\t   (GRETH_RXBD_ERR_AE | GRETH_RXBD_ERR_OE | GRETH_RXBD_ERR_LE)) {\n\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t\t\tbad = 1;\n\t\t\t} else if (status & GRETH_RXBD_ERR_CRC) {\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\t\tbad = 1;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!bad && (newskb=netdev_alloc_skb(dev, MAX_FRAME_SIZE + NET_IP_ALIGN))) {\n\t\t\tskb_reserve(newskb, NET_IP_ALIGN);\n\n\t\t\tdma_addr = dma_map_single(greth->dev,\n\t\t\t\t\t\t      newskb->data,\n\t\t\t\t\t\t      MAX_FRAME_SIZE + NET_IP_ALIGN,\n\t\t\t\t\t\t      DMA_FROM_DEVICE);\n\n\t\t\tif (!dma_mapping_error(greth->dev, dma_addr)) {\n\t\t\t\t \n\t\t\t\tpkt_len = status & GRETH_BD_LEN;\n\n\t\t\t\tdma_unmap_single(greth->dev,\n\t\t\t\t\t\t greth_read_bd(&bdp->addr),\n\t\t\t\t\t\t MAX_FRAME_SIZE + NET_IP_ALIGN,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\n\t\t\t\tif (netif_msg_pktdata(greth))\n\t\t\t\t\tgreth_print_rx_packet(phys_to_virt(greth_read_bd(&bdp->addr)), pkt_len);\n\n\t\t\t\tskb_put(skb, pkt_len);\n\n\t\t\t\tif (dev->features & NETIF_F_RXCSUM && hw_checksummed(status))\n\t\t\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\t\t\telse\n\t\t\t\t\tskb_checksum_none_assert(skb);\n\n\t\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\tdev->stats.rx_bytes += pkt_len;\n\t\t\t\tnetif_receive_skb(skb);\n\n\t\t\t\tgreth->rx_skbuff[greth->rx_cur] = newskb;\n\t\t\t\tgreth_write_bd(&bdp->addr, dma_addr);\n\t\t\t} else {\n\t\t\t\tif (net_ratelimit())\n\t\t\t\t\tdev_warn(greth->dev, \"Could not create DMA mapping, dropping packet\\n\");\n\t\t\t\tdev_kfree_skb(newskb);\n\t\t\t\t \n\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t}\n\t\t} else if (bad) {\n\t\t\t \n\t\t\tdev->stats.rx_dropped++;\n\t\t} else {\n\t\t\t \n\t\t\tif (net_ratelimit())\n\t\t\t\tdev_warn(greth->dev, \"Could not allocate SKB, dropping packet\\n\");\n\t\t\t \n\t\t\tdev->stats.rx_dropped++;\n\t\t}\n\n\t\tstatus = GRETH_BD_EN | GRETH_BD_IE;\n\t\tif (greth->rx_cur == GRETH_RXBD_NUM_MASK) {\n\t\t\tstatus |= GRETH_BD_WR;\n\t\t}\n\n\t\twmb();\n\t\tgreth_write_bd(&bdp->stat, status);\n\t\tspin_lock_irqsave(&greth->devlock, flags);\n\t\tgreth_enable_rx(greth);\n\t\tspin_unlock_irqrestore(&greth->devlock, flags);\n\t\tgreth->rx_cur = NEXT_RX(greth->rx_cur);\n\t}\n\n\treturn count;\n\n}\n\nstatic int greth_poll(struct napi_struct *napi, int budget)\n{\n\tstruct greth_private *greth;\n\tint work_done = 0;\n\tunsigned long flags;\n\tu32 mask, ctrl;\n\tgreth = container_of(napi, struct greth_private, napi);\n\nrestart_txrx_poll:\n\tif (greth->gbit_mac) {\n\t\tgreth_clean_tx_gbit(greth->netdev);\n\t\twork_done += greth_rx_gbit(greth->netdev, budget - work_done);\n\t} else {\n\t\tif (netif_queue_stopped(greth->netdev))\n\t\t\tgreth_clean_tx(greth->netdev);\n\t\twork_done += greth_rx(greth->netdev, budget - work_done);\n\t}\n\n\tif (work_done < budget) {\n\n\t\tspin_lock_irqsave(&greth->devlock, flags);\n\n\t\tctrl = GRETH_REGLOAD(greth->regs->control);\n\t\tif ((greth->gbit_mac && (greth->tx_last != greth->tx_next)) ||\n\t\t    (!greth->gbit_mac && netif_queue_stopped(greth->netdev))) {\n\t\t\tGRETH_REGSAVE(greth->regs->control,\n\t\t\t\t\tctrl | GRETH_TXI | GRETH_RXI);\n\t\t\tmask = GRETH_INT_RX | GRETH_INT_RE |\n\t\t\t       GRETH_INT_TX | GRETH_INT_TE;\n\t\t} else {\n\t\t\tGRETH_REGSAVE(greth->regs->control, ctrl | GRETH_RXI);\n\t\t\tmask = GRETH_INT_RX | GRETH_INT_RE;\n\t\t}\n\n\t\tif (GRETH_REGLOAD(greth->regs->status) & mask) {\n\t\t\tGRETH_REGSAVE(greth->regs->control, ctrl);\n\t\t\tspin_unlock_irqrestore(&greth->devlock, flags);\n\t\t\tgoto restart_txrx_poll;\n\t\t} else {\n\t\t\tnapi_complete_done(napi, work_done);\n\t\t\tspin_unlock_irqrestore(&greth->devlock, flags);\n\t\t}\n\t}\n\n\treturn work_done;\n}\n\nstatic int greth_set_mac_add(struct net_device *dev, void *p)\n{\n\tstruct sockaddr *addr = p;\n\tstruct greth_private *greth;\n\tstruct greth_regs *regs;\n\n\tgreth = netdev_priv(dev);\n\tregs = greth->regs;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(dev, addr->sa_data);\n\tGRETH_REGSAVE(regs->esa_msb, dev->dev_addr[0] << 8 | dev->dev_addr[1]);\n\tGRETH_REGSAVE(regs->esa_lsb, dev->dev_addr[2] << 24 | dev->dev_addr[3] << 16 |\n\t\t      dev->dev_addr[4] << 8 | dev->dev_addr[5]);\n\n\treturn 0;\n}\n\nstatic u32 greth_hash_get_index(__u8 *addr)\n{\n\treturn (ether_crc(6, addr)) & 0x3F;\n}\n\nstatic void greth_set_hash_filter(struct net_device *dev)\n{\n\tstruct netdev_hw_addr *ha;\n\tstruct greth_private *greth = netdev_priv(dev);\n\tstruct greth_regs *regs = greth->regs;\n\tu32 mc_filter[2];\n\tunsigned int bitnr;\n\n\tmc_filter[0] = mc_filter[1] = 0;\n\n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\tbitnr = greth_hash_get_index(ha->addr);\n\t\tmc_filter[bitnr >> 5] |= 1 << (bitnr & 31);\n\t}\n\n\tGRETH_REGSAVE(regs->hash_msb, mc_filter[1]);\n\tGRETH_REGSAVE(regs->hash_lsb, mc_filter[0]);\n}\n\nstatic void greth_set_multicast_list(struct net_device *dev)\n{\n\tint cfg;\n\tstruct greth_private *greth = netdev_priv(dev);\n\tstruct greth_regs *regs = greth->regs;\n\n\tcfg = GRETH_REGLOAD(regs->control);\n\tif (dev->flags & IFF_PROMISC)\n\t\tcfg |= GRETH_CTRL_PR;\n\telse\n\t\tcfg &= ~GRETH_CTRL_PR;\n\n\tif (greth->multicast) {\n\t\tif (dev->flags & IFF_ALLMULTI) {\n\t\t\tGRETH_REGSAVE(regs->hash_msb, -1);\n\t\t\tGRETH_REGSAVE(regs->hash_lsb, -1);\n\t\t\tcfg |= GRETH_CTRL_MCEN;\n\t\t\tGRETH_REGSAVE(regs->control, cfg);\n\t\t\treturn;\n\t\t}\n\n\t\tif (netdev_mc_empty(dev)) {\n\t\t\tcfg &= ~GRETH_CTRL_MCEN;\n\t\t\tGRETH_REGSAVE(regs->control, cfg);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tgreth_set_hash_filter(dev);\n\t\tcfg |= GRETH_CTRL_MCEN;\n\t}\n\tGRETH_REGSAVE(regs->control, cfg);\n}\n\nstatic u32 greth_get_msglevel(struct net_device *dev)\n{\n\tstruct greth_private *greth = netdev_priv(dev);\n\treturn greth->msg_enable;\n}\n\nstatic void greth_set_msglevel(struct net_device *dev, u32 value)\n{\n\tstruct greth_private *greth = netdev_priv(dev);\n\tgreth->msg_enable = value;\n}\n\nstatic int greth_get_regs_len(struct net_device *dev)\n{\n\treturn sizeof(struct greth_regs);\n}\n\nstatic void greth_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct greth_private *greth = netdev_priv(dev);\n\n\tstrscpy(info->driver, dev_driver_string(greth->dev),\n\t\tsizeof(info->driver));\n\tstrscpy(info->bus_info, greth->dev->bus->name, sizeof(info->bus_info));\n}\n\nstatic void greth_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *p)\n{\n\tint i;\n\tstruct greth_private *greth = netdev_priv(dev);\n\tu32 __iomem *greth_regs = (u32 __iomem *) greth->regs;\n\tu32 *buff = p;\n\n\tfor (i = 0; i < sizeof(struct greth_regs) / sizeof(u32); i++)\n\t\tbuff[i] = greth_read_bd(&greth_regs[i]);\n}\n\nstatic const struct ethtool_ops greth_ethtool_ops = {\n\t.get_msglevel\t\t= greth_get_msglevel,\n\t.set_msglevel\t\t= greth_set_msglevel,\n\t.get_drvinfo\t\t= greth_get_drvinfo,\n\t.get_regs_len           = greth_get_regs_len,\n\t.get_regs               = greth_get_regs,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_link_ksettings\t= phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings\t= phy_ethtool_set_link_ksettings,\n};\n\nstatic struct net_device_ops greth_netdev_ops = {\n\t.ndo_open\t\t= greth_open,\n\t.ndo_stop\t\t= greth_close,\n\t.ndo_start_xmit\t\t= greth_start_xmit,\n\t.ndo_set_mac_address\t= greth_set_mac_add,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic inline int wait_for_mdio(struct greth_private *greth)\n{\n\tunsigned long timeout = jiffies + 4*HZ/100;\n\twhile (GRETH_REGLOAD(greth->regs->mdio) & GRETH_MII_BUSY) {\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int greth_mdio_read(struct mii_bus *bus, int phy, int reg)\n{\n\tstruct greth_private *greth = bus->priv;\n\tint data;\n\n\tif (!wait_for_mdio(greth))\n\t\treturn -EBUSY;\n\n\tGRETH_REGSAVE(greth->regs->mdio, ((phy & 0x1F) << 11) | ((reg & 0x1F) << 6) | 2);\n\n\tif (!wait_for_mdio(greth))\n\t\treturn -EBUSY;\n\n\tif (!(GRETH_REGLOAD(greth->regs->mdio) & GRETH_MII_NVALID)) {\n\t\tdata = (GRETH_REGLOAD(greth->regs->mdio) >> 16) & 0xFFFF;\n\t\treturn data;\n\n\t} else {\n\t\treturn -1;\n\t}\n}\n\nstatic int greth_mdio_write(struct mii_bus *bus, int phy, int reg, u16 val)\n{\n\tstruct greth_private *greth = bus->priv;\n\n\tif (!wait_for_mdio(greth))\n\t\treturn -EBUSY;\n\n\tGRETH_REGSAVE(greth->regs->mdio,\n\t\t      ((val & 0xFFFF) << 16) | ((phy & 0x1F) << 11) | ((reg & 0x1F) << 6) | 1);\n\n\tif (!wait_for_mdio(greth))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic void greth_link_change(struct net_device *dev)\n{\n\tstruct greth_private *greth = netdev_priv(dev);\n\tstruct phy_device *phydev = dev->phydev;\n\tunsigned long flags;\n\tint status_change = 0;\n\tu32 ctrl;\n\n\tspin_lock_irqsave(&greth->devlock, flags);\n\n\tif (phydev->link) {\n\n\t\tif ((greth->speed != phydev->speed) || (greth->duplex != phydev->duplex)) {\n\t\t\tctrl = GRETH_REGLOAD(greth->regs->control) &\n\t\t\t       ~(GRETH_CTRL_FD | GRETH_CTRL_SP | GRETH_CTRL_GB);\n\n\t\t\tif (phydev->duplex)\n\t\t\t\tctrl |= GRETH_CTRL_FD;\n\n\t\t\tif (phydev->speed == SPEED_100)\n\t\t\t\tctrl |= GRETH_CTRL_SP;\n\t\t\telse if (phydev->speed == SPEED_1000)\n\t\t\t\tctrl |= GRETH_CTRL_GB;\n\n\t\t\tGRETH_REGSAVE(greth->regs->control, ctrl);\n\t\t\tgreth->speed = phydev->speed;\n\t\t\tgreth->duplex = phydev->duplex;\n\t\t\tstatus_change = 1;\n\t\t}\n\t}\n\n\tif (phydev->link != greth->link) {\n\t\tif (!phydev->link) {\n\t\t\tgreth->speed = 0;\n\t\t\tgreth->duplex = -1;\n\t\t}\n\t\tgreth->link = phydev->link;\n\n\t\tstatus_change = 1;\n\t}\n\n\tspin_unlock_irqrestore(&greth->devlock, flags);\n\n\tif (status_change) {\n\t\tif (phydev->link)\n\t\t\tpr_debug(\"%s: link up (%d/%s)\\n\",\n\t\t\t\tdev->name, phydev->speed,\n\t\t\t\tDUPLEX_FULL == phydev->duplex ? \"Full\" : \"Half\");\n\t\telse\n\t\t\tpr_debug(\"%s: link down\\n\", dev->name);\n\t}\n}\n\nstatic int greth_mdio_probe(struct net_device *dev)\n{\n\tstruct greth_private *greth = netdev_priv(dev);\n\tstruct phy_device *phy = NULL;\n\tint ret;\n\n\t \n\tphy = phy_find_first(greth->mdio);\n\n\tif (!phy) {\n\t\tif (netif_msg_probe(greth))\n\t\t\tdev_err(&dev->dev, \"no PHY found\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tret = phy_connect_direct(dev, phy, &greth_link_change,\n\t\t\t\t greth->gbit_mac ? PHY_INTERFACE_MODE_GMII : PHY_INTERFACE_MODE_MII);\n\tif (ret) {\n\t\tif (netif_msg_ifup(greth))\n\t\t\tdev_err(&dev->dev, \"could not attach to PHY\\n\");\n\t\treturn ret;\n\t}\n\n\tif (greth->gbit_mac)\n\t\tphy_set_max_speed(phy, SPEED_1000);\n\telse\n\t\tphy_set_max_speed(phy, SPEED_100);\n\n\tlinkmode_copy(phy->advertising, phy->supported);\n\n\tgreth->link = 0;\n\tgreth->speed = 0;\n\tgreth->duplex = -1;\n\n\treturn 0;\n}\n\nstatic int greth_mdio_init(struct greth_private *greth)\n{\n\tint ret;\n\tunsigned long timeout;\n\tstruct net_device *ndev = greth->netdev;\n\n\tgreth->mdio = mdiobus_alloc();\n\tif (!greth->mdio) {\n\t\treturn -ENOMEM;\n\t}\n\n\tgreth->mdio->name = \"greth-mdio\";\n\tsnprintf(greth->mdio->id, MII_BUS_ID_SIZE, \"%s-%d\", greth->mdio->name, greth->irq);\n\tgreth->mdio->read = greth_mdio_read;\n\tgreth->mdio->write = greth_mdio_write;\n\tgreth->mdio->priv = greth;\n\n\tret = mdiobus_register(greth->mdio);\n\tif (ret) {\n\t\tgoto error;\n\t}\n\n\tret = greth_mdio_probe(greth->netdev);\n\tif (ret) {\n\t\tif (netif_msg_probe(greth))\n\t\t\tdev_err(&greth->netdev->dev, \"failed to probe MDIO bus\\n\");\n\t\tgoto unreg_mdio;\n\t}\n\n\tphy_start(ndev->phydev);\n\n\t \n\tif (greth->edcl && greth_edcl == 1) {\n\t\tphy_start_aneg(ndev->phydev);\n\t\ttimeout = jiffies + 6*HZ;\n\t\twhile (!phy_aneg_done(ndev->phydev) &&\n\t\t       time_before(jiffies, timeout)) {\n\t\t}\n\t\tphy_read_status(ndev->phydev);\n\t\tgreth_link_change(greth->netdev);\n\t}\n\n\treturn 0;\n\nunreg_mdio:\n\tmdiobus_unregister(greth->mdio);\nerror:\n\tmdiobus_free(greth->mdio);\n\treturn ret;\n}\n\n \nstatic int greth_of_probe(struct platform_device *ofdev)\n{\n\tstruct net_device *dev;\n\tstruct greth_private *greth;\n\tstruct greth_regs *regs;\n\n\tint i;\n\tint err;\n\tint tmp;\n\tu8 addr[ETH_ALEN];\n\tunsigned long timeout;\n\n\tdev = alloc_etherdev(sizeof(struct greth_private));\n\n\tif (dev == NULL)\n\t\treturn -ENOMEM;\n\n\tgreth = netdev_priv(dev);\n\tgreth->netdev = dev;\n\tgreth->dev = &ofdev->dev;\n\n\tif (greth_debug > 0)\n\t\tgreth->msg_enable = greth_debug;\n\telse\n\t\tgreth->msg_enable = GRETH_DEF_MSG_ENABLE;\n\n\tspin_lock_init(&greth->devlock);\n\n\tgreth->regs = of_ioremap(&ofdev->resource[0], 0,\n\t\t\t\t resource_size(&ofdev->resource[0]),\n\t\t\t\t \"grlib-greth regs\");\n\n\tif (greth->regs == NULL) {\n\t\tif (netif_msg_probe(greth))\n\t\t\tdev_err(greth->dev, \"ioremap failure.\\n\");\n\t\terr = -EIO;\n\t\tgoto error1;\n\t}\n\n\tregs = greth->regs;\n\tgreth->irq = ofdev->archdata.irqs[0];\n\n\tdev_set_drvdata(greth->dev, dev);\n\tSET_NETDEV_DEV(dev, greth->dev);\n\n\tif (netif_msg_probe(greth))\n\t\tdev_dbg(greth->dev, \"resetting controller.\\n\");\n\n\t \n\tGRETH_REGSAVE(regs->control, GRETH_RESET);\n\n\t \n\ttimeout = jiffies + HZ/100;\n\twhile (GRETH_REGLOAD(regs->control) & GRETH_RESET) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\terr = -EIO;\n\t\t\tif (netif_msg_probe(greth))\n\t\t\t\tdev_err(greth->dev, \"timeout when waiting for reset.\\n\");\n\t\t\tgoto error2;\n\t\t}\n\t}\n\n\t \n\tgreth->phyaddr = (GRETH_REGLOAD(regs->mdio) >> 11) & 0x1F;\n\n\t \n\ttmp = GRETH_REGLOAD(regs->control);\n\tgreth->gbit_mac = (tmp >> 27) & 1;\n\n\t \n\tgreth->multicast = (tmp >> 25) & 1;\n\n\tgreth->edcl = (tmp >> 31) & 1;\n\n\t \n\tif (greth->edcl != 0)\n\t\tGRETH_REGORIN(regs->control, GRETH_CTRL_DISDUPLEX);\n\n\t \n\tgreth->mdio_int_en = (tmp >> 26) & 1;\n\n\terr = greth_mdio_init(greth);\n\tif (err) {\n\t\tif (netif_msg_probe(greth))\n\t\t\tdev_err(greth->dev, \"failed to register MDIO bus\\n\");\n\t\tgoto error2;\n\t}\n\n\t \n\tgreth->tx_bd_base = dma_alloc_coherent(greth->dev, 1024,\n\t\t\t\t\t       &greth->tx_bd_base_phys,\n\t\t\t\t\t       GFP_KERNEL);\n\tif (!greth->tx_bd_base) {\n\t\terr = -ENOMEM;\n\t\tgoto error3;\n\t}\n\n\t \n\tgreth->rx_bd_base = dma_alloc_coherent(greth->dev, 1024,\n\t\t\t\t\t       &greth->rx_bd_base_phys,\n\t\t\t\t\t       GFP_KERNEL);\n\tif (!greth->rx_bd_base) {\n\t\terr = -ENOMEM;\n\t\tgoto error4;\n\t}\n\n\t \n\tfor (i = 0; i < 6; i++) {\n\t\tif (macaddr[i] != 0)\n\t\t\tbreak;\n\t}\n\tif (i == 6) {\n\t\terr = of_get_mac_address(ofdev->dev.of_node, addr);\n\t\tif (!err) {\n\t\t\tfor (i = 0; i < 6; i++)\n\t\t\t\tmacaddr[i] = (unsigned int) addr[i];\n\t\t} else {\n#ifdef CONFIG_SPARC\n\t\t\tfor (i = 0; i < 6; i++)\n\t\t\t\tmacaddr[i] = (unsigned int) idprom->id_ethaddr[i];\n#endif\n\t\t}\n\t}\n\n\tfor (i = 0; i < 6; i++)\n\t\taddr[i] = macaddr[i];\n\teth_hw_addr_set(dev, addr);\n\n\tmacaddr[5]++;\n\n\tif (!is_valid_ether_addr(&dev->dev_addr[0])) {\n\t\tif (netif_msg_probe(greth))\n\t\t\tdev_err(greth->dev, \"no valid ethernet address, aborting.\\n\");\n\t\terr = -EINVAL;\n\t\tgoto error5;\n\t}\n\n\tGRETH_REGSAVE(regs->esa_msb, dev->dev_addr[0] << 8 | dev->dev_addr[1]);\n\tGRETH_REGSAVE(regs->esa_lsb, dev->dev_addr[2] << 24 | dev->dev_addr[3] << 16 |\n\t\t      dev->dev_addr[4] << 8 | dev->dev_addr[5]);\n\n\t \n\tGRETH_REGSAVE(regs->status, 0xFF);\n\n\tif (greth->gbit_mac) {\n\t\tdev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM |\n\t\t\tNETIF_F_RXCSUM;\n\t\tdev->features = dev->hw_features | NETIF_F_HIGHDMA;\n\t\tgreth_netdev_ops.ndo_start_xmit = greth_start_xmit_gbit;\n\t}\n\n\tif (greth->multicast) {\n\t\tgreth_netdev_ops.ndo_set_rx_mode = greth_set_multicast_list;\n\t\tdev->flags |= IFF_MULTICAST;\n\t} else {\n\t\tdev->flags &= ~IFF_MULTICAST;\n\t}\n\n\tdev->netdev_ops = &greth_netdev_ops;\n\tdev->ethtool_ops = &greth_ethtool_ops;\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tif (netif_msg_probe(greth))\n\t\t\tdev_err(greth->dev, \"netdevice registration failed.\\n\");\n\t\tgoto error5;\n\t}\n\n\t \n\tnetif_napi_add(dev, &greth->napi, greth_poll);\n\n\treturn 0;\n\nerror5:\n\tdma_free_coherent(greth->dev, 1024, greth->rx_bd_base, greth->rx_bd_base_phys);\nerror4:\n\tdma_free_coherent(greth->dev, 1024, greth->tx_bd_base, greth->tx_bd_base_phys);\nerror3:\n\tmdiobus_unregister(greth->mdio);\nerror2:\n\tof_iounmap(&ofdev->resource[0], greth->regs, resource_size(&ofdev->resource[0]));\nerror1:\n\tfree_netdev(dev);\n\treturn err;\n}\n\nstatic int greth_of_remove(struct platform_device *of_dev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(of_dev);\n\tstruct greth_private *greth = netdev_priv(ndev);\n\n\t \n\tdma_free_coherent(&of_dev->dev, 1024, greth->rx_bd_base, greth->rx_bd_base_phys);\n\n\tdma_free_coherent(&of_dev->dev, 1024, greth->tx_bd_base, greth->tx_bd_base_phys);\n\n\tif (ndev->phydev)\n\t\tphy_stop(ndev->phydev);\n\tmdiobus_unregister(greth->mdio);\n\n\tunregister_netdev(ndev);\n\n\tof_iounmap(&of_dev->resource[0], greth->regs, resource_size(&of_dev->resource[0]));\n\n\tfree_netdev(ndev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id greth_of_match[] = {\n\t{\n\t .name = \"GAISLER_ETHMAC\",\n\t },\n\t{\n\t .name = \"01_01d\",\n\t },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, greth_of_match);\n\nstatic struct platform_driver greth_of_driver = {\n\t.driver = {\n\t\t.name = \"grlib-greth\",\n\t\t.of_match_table = greth_of_match,\n\t},\n\t.probe = greth_of_probe,\n\t.remove = greth_of_remove,\n};\n\nmodule_platform_driver(greth_of_driver);\n\nMODULE_AUTHOR(\"Aeroflex Gaisler AB.\");\nMODULE_DESCRIPTION(\"Aeroflex Gaisler Ethernet MAC driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}