{
  "module_name": "funeth_ethtool.c",
  "hash_id": "bd069e608b0859c09c35988e67f276b057480c85c31d3a927a5b6c228ce5503e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/fungible/funeth/funeth_ethtool.c",
  "human_readable_source": "\n\n#include <linux/ethtool.h>\n#include <linux/linkmode.h>\n#include <linux/netdevice.h>\n#include <linux/nvme.h>\n#include <linux/io.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/pci.h>\n#include <linux/rtnetlink.h>\n#include \"funeth.h\"\n#include \"fun_port.h\"\n#include \"funeth_txrx.h\"\n\n \n#define FUNETH_MIN_QDEPTH 8\n\nstatic const char mac_tx_stat_names[][ETH_GSTRING_LEN] = {\n\t\"mac_tx_octets_total\",\n\t\"mac_tx_frames_total\",\n\t\"mac_tx_vlan_frames_ok\",\n\t\"mac_tx_unicast_frames\",\n\t\"mac_tx_multicast_frames\",\n\t\"mac_tx_broadcast_frames\",\n\t\"mac_tx_errors\",\n\t\"mac_tx_CBFCPAUSE0\",\n\t\"mac_tx_CBFCPAUSE1\",\n\t\"mac_tx_CBFCPAUSE2\",\n\t\"mac_tx_CBFCPAUSE3\",\n\t\"mac_tx_CBFCPAUSE4\",\n\t\"mac_tx_CBFCPAUSE5\",\n\t\"mac_tx_CBFCPAUSE6\",\n\t\"mac_tx_CBFCPAUSE7\",\n\t\"mac_tx_CBFCPAUSE8\",\n\t\"mac_tx_CBFCPAUSE9\",\n\t\"mac_tx_CBFCPAUSE10\",\n\t\"mac_tx_CBFCPAUSE11\",\n\t\"mac_tx_CBFCPAUSE12\",\n\t\"mac_tx_CBFCPAUSE13\",\n\t\"mac_tx_CBFCPAUSE14\",\n\t\"mac_tx_CBFCPAUSE15\",\n};\n\nstatic const char mac_rx_stat_names[][ETH_GSTRING_LEN] = {\n\t\"mac_rx_octets_total\",\n\t\"mac_rx_frames_total\",\n\t\"mac_rx_VLAN_frames_ok\",\n\t\"mac_rx_unicast_frames\",\n\t\"mac_rx_multicast_frames\",\n\t\"mac_rx_broadcast_frames\",\n\t\"mac_rx_drop_events\",\n\t\"mac_rx_errors\",\n\t\"mac_rx_alignment_errors\",\n\t\"mac_rx_CBFCPAUSE0\",\n\t\"mac_rx_CBFCPAUSE1\",\n\t\"mac_rx_CBFCPAUSE2\",\n\t\"mac_rx_CBFCPAUSE3\",\n\t\"mac_rx_CBFCPAUSE4\",\n\t\"mac_rx_CBFCPAUSE5\",\n\t\"mac_rx_CBFCPAUSE6\",\n\t\"mac_rx_CBFCPAUSE7\",\n\t\"mac_rx_CBFCPAUSE8\",\n\t\"mac_rx_CBFCPAUSE9\",\n\t\"mac_rx_CBFCPAUSE10\",\n\t\"mac_rx_CBFCPAUSE11\",\n\t\"mac_rx_CBFCPAUSE12\",\n\t\"mac_rx_CBFCPAUSE13\",\n\t\"mac_rx_CBFCPAUSE14\",\n\t\"mac_rx_CBFCPAUSE15\",\n};\n\nstatic const char * const txq_stat_names[] = {\n\t\"tx_pkts\",\n\t\"tx_bytes\",\n\t\"tx_cso\",\n\t\"tx_tso\",\n\t\"tx_encapsulated_tso\",\n\t\"tx_uso\",\n\t\"tx_more\",\n\t\"tx_queue_stops\",\n\t\"tx_queue_restarts\",\n\t\"tx_mapping_errors\",\n\t\"tx_tls_encrypted_packets\",\n\t\"tx_tls_encrypted_bytes\",\n\t\"tx_tls_ooo\",\n\t\"tx_tls_drop_no_sync_data\",\n};\n\nstatic const char * const xdpq_stat_names[] = {\n\t\"tx_xdp_pkts\",\n\t\"tx_xdp_bytes\",\n\t\"tx_xdp_full\",\n\t\"tx_xdp_mapping_errors\",\n};\n\nstatic const char * const rxq_stat_names[] = {\n\t\"rx_pkts\",\n\t\"rx_bytes\",\n\t\"rx_cso\",\n\t\"gro_pkts\",\n\t\"gro_merged\",\n\t\"rx_xdp_tx\",\n\t\"rx_xdp_redir\",\n\t\"rx_xdp_drops\",\n\t\"rx_buffers\",\n\t\"rx_page_allocs\",\n\t\"rx_drops\",\n\t\"rx_budget_exhausted\",\n\t\"rx_mapping_errors\",\n};\n\nstatic const char * const tls_stat_names[] = {\n\t\"tx_tls_ctx\",\n\t\"tx_tls_del\",\n\t\"tx_tls_resync\",\n};\n\nstatic void fun_link_modes_to_ethtool(u64 modes,\n\t\t\t\t      unsigned long *ethtool_modes_map)\n{\n#define ADD_LINK_MODE(mode) \\\n\t__set_bit(ETHTOOL_LINK_MODE_ ## mode ## _BIT, ethtool_modes_map)\n\n\tif (modes & FUN_PORT_CAP_AUTONEG)\n\t\tADD_LINK_MODE(Autoneg);\n\tif (modes & FUN_PORT_CAP_1000_X)\n\t\tADD_LINK_MODE(1000baseX_Full);\n\tif (modes & FUN_PORT_CAP_10G_R) {\n\t\tADD_LINK_MODE(10000baseCR_Full);\n\t\tADD_LINK_MODE(10000baseSR_Full);\n\t\tADD_LINK_MODE(10000baseLR_Full);\n\t\tADD_LINK_MODE(10000baseER_Full);\n\t}\n\tif (modes & FUN_PORT_CAP_25G_R) {\n\t\tADD_LINK_MODE(25000baseCR_Full);\n\t\tADD_LINK_MODE(25000baseSR_Full);\n\t}\n\tif (modes & FUN_PORT_CAP_40G_R4) {\n\t\tADD_LINK_MODE(40000baseCR4_Full);\n\t\tADD_LINK_MODE(40000baseSR4_Full);\n\t\tADD_LINK_MODE(40000baseLR4_Full);\n\t}\n\tif (modes & FUN_PORT_CAP_50G_R2) {\n\t\tADD_LINK_MODE(50000baseCR2_Full);\n\t\tADD_LINK_MODE(50000baseSR2_Full);\n\t}\n\tif (modes & FUN_PORT_CAP_50G_R) {\n\t\tADD_LINK_MODE(50000baseCR_Full);\n\t\tADD_LINK_MODE(50000baseSR_Full);\n\t\tADD_LINK_MODE(50000baseLR_ER_FR_Full);\n\t}\n\tif (modes & FUN_PORT_CAP_100G_R4) {\n\t\tADD_LINK_MODE(100000baseCR4_Full);\n\t\tADD_LINK_MODE(100000baseSR4_Full);\n\t\tADD_LINK_MODE(100000baseLR4_ER4_Full);\n\t}\n\tif (modes & FUN_PORT_CAP_100G_R2) {\n\t\tADD_LINK_MODE(100000baseCR2_Full);\n\t\tADD_LINK_MODE(100000baseSR2_Full);\n\t\tADD_LINK_MODE(100000baseLR2_ER2_FR2_Full);\n\t}\n\tif (modes & FUN_PORT_CAP_FEC_NONE)\n\t\tADD_LINK_MODE(FEC_NONE);\n\tif (modes & FUN_PORT_CAP_FEC_FC)\n\t\tADD_LINK_MODE(FEC_BASER);\n\tif (modes & FUN_PORT_CAP_FEC_RS)\n\t\tADD_LINK_MODE(FEC_RS);\n\tif (modes & FUN_PORT_CAP_RX_PAUSE)\n\t\tADD_LINK_MODE(Pause);\n\n#undef ADD_LINK_MODE\n}\n\nstatic void set_asym_pause(u64 advertising, struct ethtool_link_ksettings *ks)\n{\n\tbool rx_pause, tx_pause;\n\n\trx_pause = advertising & FUN_PORT_CAP_RX_PAUSE;\n\ttx_pause = advertising & FUN_PORT_CAP_TX_PAUSE;\n\tif (tx_pause ^ rx_pause)\n\t\tethtool_link_ksettings_add_link_mode(ks, advertising,\n\t\t\t\t\t\t     Asym_Pause);\n}\n\nstatic unsigned int fun_port_type(unsigned int xcvr)\n{\n\tif (!xcvr)\n\t\treturn PORT_NONE;\n\n\tswitch (xcvr & 7) {\n\tcase FUN_XCVR_BASET:\n\t\treturn PORT_TP;\n\tcase FUN_XCVR_CU:\n\t\treturn PORT_DA;\n\tdefault:\n\t\treturn PORT_FIBRE;\n\t}\n}\n\nstatic int fun_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t  struct ethtool_link_ksettings *ks)\n{\n\tconst struct funeth_priv *fp = netdev_priv(netdev);\n\tunsigned int seq, speed, xcvr;\n\tu64 lp_advertising;\n\tbool link_up;\n\n\tethtool_link_ksettings_zero_link_mode(ks, supported);\n\tethtool_link_ksettings_zero_link_mode(ks, advertising);\n\tethtool_link_ksettings_zero_link_mode(ks, lp_advertising);\n\n\t \n\tdo {\n\t\tseq = read_seqcount_begin(&fp->link_seq);\n\t\tlink_up = netif_carrier_ok(netdev);\n\t\tspeed = fp->link_speed;\n\t\txcvr = fp->xcvr_type;\n\t\tlp_advertising = fp->lp_advertising;\n\t} while (read_seqcount_retry(&fp->link_seq, seq));\n\n\tif (link_up) {\n\t\tks->base.speed = speed;\n\t\tks->base.duplex = DUPLEX_FULL;\n\t\tfun_link_modes_to_ethtool(lp_advertising,\n\t\t\t\t\t  ks->link_modes.lp_advertising);\n\t} else {\n\t\tks->base.speed = SPEED_UNKNOWN;\n\t\tks->base.duplex = DUPLEX_UNKNOWN;\n\t}\n\n\tks->base.autoneg = (fp->advertising & FUN_PORT_CAP_AUTONEG) ?\n\t\t\t   AUTONEG_ENABLE : AUTONEG_DISABLE;\n\tks->base.port = fun_port_type(xcvr);\n\n\tfun_link_modes_to_ethtool(fp->port_caps, ks->link_modes.supported);\n\tif (fp->port_caps & (FUN_PORT_CAP_RX_PAUSE | FUN_PORT_CAP_TX_PAUSE))\n\t\tethtool_link_ksettings_add_link_mode(ks, supported, Asym_Pause);\n\n\tfun_link_modes_to_ethtool(fp->advertising, ks->link_modes.advertising);\n\tset_asym_pause(fp->advertising, ks);\n\treturn 0;\n}\n\nstatic u64 fun_advert_modes(const struct ethtool_link_ksettings *ks)\n{\n\tu64 modes = 0;\n\n#define HAS_MODE(mode) \\\n\tethtool_link_ksettings_test_link_mode(ks, advertising, mode)\n\n\tif (HAS_MODE(1000baseX_Full))\n\t\tmodes |= FUN_PORT_CAP_1000_X;\n\tif (HAS_MODE(10000baseCR_Full) || HAS_MODE(10000baseSR_Full) ||\n\t    HAS_MODE(10000baseLR_Full) || HAS_MODE(10000baseER_Full))\n\t\tmodes |= FUN_PORT_CAP_10G_R;\n\tif (HAS_MODE(25000baseCR_Full) || HAS_MODE(25000baseSR_Full))\n\t\tmodes |= FUN_PORT_CAP_25G_R;\n\tif (HAS_MODE(40000baseCR4_Full) || HAS_MODE(40000baseSR4_Full) ||\n\t    HAS_MODE(40000baseLR4_Full))\n\t\tmodes |= FUN_PORT_CAP_40G_R4;\n\tif (HAS_MODE(50000baseCR2_Full) || HAS_MODE(50000baseSR2_Full))\n\t\tmodes |= FUN_PORT_CAP_50G_R2;\n\tif (HAS_MODE(50000baseCR_Full) || HAS_MODE(50000baseSR_Full) ||\n\t    HAS_MODE(50000baseLR_ER_FR_Full))\n\t\tmodes |= FUN_PORT_CAP_50G_R;\n\tif (HAS_MODE(100000baseCR4_Full) || HAS_MODE(100000baseSR4_Full) ||\n\t    HAS_MODE(100000baseLR4_ER4_Full))\n\t\tmodes |= FUN_PORT_CAP_100G_R4;\n\tif (HAS_MODE(100000baseCR2_Full) || HAS_MODE(100000baseSR2_Full) ||\n\t    HAS_MODE(100000baseLR2_ER2_FR2_Full))\n\t\tmodes |= FUN_PORT_CAP_100G_R2;\n\n\treturn modes;\n#undef HAS_MODE\n}\n\nstatic u64 fun_speed_to_link_mode(unsigned int speed)\n{\n\tswitch (speed) {\n\tcase SPEED_100000:\n\t\treturn FUN_PORT_CAP_100G_R4 | FUN_PORT_CAP_100G_R2;\n\tcase SPEED_50000:\n\t\treturn FUN_PORT_CAP_50G_R | FUN_PORT_CAP_50G_R2;\n\tcase SPEED_40000:\n\t\treturn FUN_PORT_CAP_40G_R4;\n\tcase SPEED_25000:\n\t\treturn FUN_PORT_CAP_25G_R;\n\tcase SPEED_10000:\n\t\treturn FUN_PORT_CAP_10G_R;\n\tcase SPEED_1000:\n\t\treturn FUN_PORT_CAP_1000_X;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int fun_change_advert(struct funeth_priv *fp, u64 new_advert)\n{\n\tint err;\n\n\tif (new_advert == fp->advertising)\n\t\treturn 0;\n\n\terr = fun_port_write_cmd(fp, FUN_ADMIN_PORT_KEY_ADVERT, new_advert);\n\tif (!err)\n\t\tfp->advertising = new_advert;\n\treturn err;\n}\n\n#define FUN_PORT_CAP_FEC_MASK \\\n\t(FUN_PORT_CAP_FEC_NONE | FUN_PORT_CAP_FEC_FC | FUN_PORT_CAP_FEC_RS)\n\nstatic int fun_set_link_ksettings(struct net_device *netdev,\n\t\t\t\t  const struct ethtool_link_ksettings *ks)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(supported) = {};\n\tstruct funeth_priv *fp = netdev_priv(netdev);\n\tu64 new_advert;\n\n\t \n\tif (fp->port_caps & FUN_PORT_CAP_VPORT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (ks->base.duplex == DUPLEX_HALF)\n\t\treturn -EINVAL;\n\tif (ks->base.autoneg == AUTONEG_ENABLE &&\n\t    !(fp->port_caps & FUN_PORT_CAP_AUTONEG))\n\t\treturn -EINVAL;\n\n\tif (ks->base.autoneg == AUTONEG_ENABLE) {\n\t\tif (linkmode_empty(ks->link_modes.advertising))\n\t\t\treturn -EINVAL;\n\n\t\tfun_link_modes_to_ethtool(fp->port_caps, supported);\n\t\tif (!linkmode_subset(ks->link_modes.advertising, supported))\n\t\t\treturn -EINVAL;\n\n\t\tnew_advert = fun_advert_modes(ks) | FUN_PORT_CAP_AUTONEG;\n\t} else {\n\t\tnew_advert = fun_speed_to_link_mode(ks->base.speed);\n\t\tnew_advert &= fp->port_caps;\n\t\tif (!new_advert)\n\t\t\treturn -EINVAL;\n\t}\n\tnew_advert |= fp->advertising &\n\t\t      (FUN_PORT_CAP_PAUSE_MASK | FUN_PORT_CAP_FEC_MASK);\n\n\treturn fun_change_advert(fp, new_advert);\n}\n\nstatic void fun_get_pauseparam(struct net_device *netdev,\n\t\t\t       struct ethtool_pauseparam *pause)\n{\n\tconst struct funeth_priv *fp = netdev_priv(netdev);\n\tu8 active_pause = fp->active_fc;\n\n\tpause->rx_pause = !!(active_pause & FUN_PORT_CAP_RX_PAUSE);\n\tpause->tx_pause = !!(active_pause & FUN_PORT_CAP_TX_PAUSE);\n\tpause->autoneg = !!(fp->advertising & FUN_PORT_CAP_AUTONEG);\n}\n\nstatic int fun_set_pauseparam(struct net_device *netdev,\n\t\t\t      struct ethtool_pauseparam *pause)\n{\n\tstruct funeth_priv *fp = netdev_priv(netdev);\n\tu64 new_advert;\n\n\tif (fp->port_caps & FUN_PORT_CAP_VPORT)\n\t\treturn -EOPNOTSUPP;\n\t \n\tif (!pause->autoneg && (fp->advertising & FUN_PORT_CAP_AUTONEG))\n\t\treturn -EOPNOTSUPP;\n\tif (pause->autoneg && !(fp->advertising & FUN_PORT_CAP_AUTONEG))\n\t\treturn -EINVAL;\n\tif (pause->tx_pause && !(fp->port_caps & FUN_PORT_CAP_TX_PAUSE))\n\t\treturn -EINVAL;\n\tif (pause->rx_pause && !(fp->port_caps & FUN_PORT_CAP_RX_PAUSE))\n\t\treturn -EINVAL;\n\n\tnew_advert = fp->advertising & ~FUN_PORT_CAP_PAUSE_MASK;\n\tif (pause->tx_pause)\n\t\tnew_advert |= FUN_PORT_CAP_TX_PAUSE;\n\tif (pause->rx_pause)\n\t\tnew_advert |= FUN_PORT_CAP_RX_PAUSE;\n\n\treturn fun_change_advert(fp, new_advert);\n}\n\nstatic int fun_restart_an(struct net_device *netdev)\n{\n\tstruct funeth_priv *fp = netdev_priv(netdev);\n\n\tif (!(fp->advertising & FUN_PORT_CAP_AUTONEG))\n\t\treturn -EOPNOTSUPP;\n\n\treturn fun_port_write_cmd(fp, FUN_ADMIN_PORT_KEY_ADVERT,\n\t\t\t\t  FUN_PORT_CAP_AUTONEG);\n}\n\nstatic int fun_set_phys_id(struct net_device *netdev,\n\t\t\t   enum ethtool_phys_id_state state)\n{\n\tstruct funeth_priv *fp = netdev_priv(netdev);\n\tunsigned int beacon;\n\n\tif (fp->port_caps & FUN_PORT_CAP_VPORT)\n\t\treturn -EOPNOTSUPP;\n\tif (state != ETHTOOL_ID_ACTIVE && state != ETHTOOL_ID_INACTIVE)\n\t\treturn -EOPNOTSUPP;\n\n\tbeacon = state == ETHTOOL_ID_ACTIVE ? FUN_PORT_LED_BEACON_ON :\n\t\t\t\t\t      FUN_PORT_LED_BEACON_OFF;\n\treturn fun_port_write_cmd(fp, FUN_ADMIN_PORT_KEY_LED, beacon);\n}\n\nstatic void fun_get_drvinfo(struct net_device *netdev,\n\t\t\t    struct ethtool_drvinfo *info)\n{\n\tconst struct funeth_priv *fp = netdev_priv(netdev);\n\n\tstrscpy(info->driver, KBUILD_MODNAME, sizeof(info->driver));\n\tstrscpy(info->bus_info, pci_name(fp->pdev), sizeof(info->bus_info));\n}\n\nstatic u32 fun_get_msglevel(struct net_device *netdev)\n{\n\tconst struct funeth_priv *fp = netdev_priv(netdev);\n\n\treturn fp->msg_enable;\n}\n\nstatic void fun_set_msglevel(struct net_device *netdev, u32 value)\n{\n\tstruct funeth_priv *fp = netdev_priv(netdev);\n\n\tfp->msg_enable = value;\n}\n\nstatic int fun_get_regs_len(struct net_device *dev)\n{\n\treturn NVME_REG_ACQ + sizeof(u64);\n}\n\nstatic void fun_get_regs(struct net_device *dev, struct ethtool_regs *regs,\n\t\t\t void *buf)\n{\n\tconst struct funeth_priv *fp = netdev_priv(dev);\n\tvoid __iomem *bar = fp->fdev->bar;\n\n\tregs->version = 0;\n\t*(u64 *)(buf + NVME_REG_CAP)   = readq(bar + NVME_REG_CAP);\n\t*(u32 *)(buf + NVME_REG_VS)    = readl(bar + NVME_REG_VS);\n\t*(u32 *)(buf + NVME_REG_INTMS) = readl(bar + NVME_REG_INTMS);\n\t*(u32 *)(buf + NVME_REG_INTMC) = readl(bar + NVME_REG_INTMC);\n\t*(u32 *)(buf + NVME_REG_CC)    = readl(bar + NVME_REG_CC);\n\t*(u32 *)(buf + NVME_REG_CSTS)  = readl(bar + NVME_REG_CSTS);\n\t*(u32 *)(buf + NVME_REG_AQA)   = readl(bar + NVME_REG_AQA);\n\t*(u64 *)(buf + NVME_REG_ASQ)   = readq(bar + NVME_REG_ASQ);\n\t*(u64 *)(buf + NVME_REG_ACQ)   = readq(bar + NVME_REG_ACQ);\n}\n\nstatic int fun_get_coalesce(struct net_device *netdev,\n\t\t\t    struct ethtool_coalesce *coal,\n\t\t\t    struct kernel_ethtool_coalesce *kcoal,\n\t\t\t    struct netlink_ext_ack *ext_ack)\n{\n\tconst struct funeth_priv *fp = netdev_priv(netdev);\n\n\tcoal->rx_coalesce_usecs        = fp->rx_coal_usec;\n\tcoal->rx_max_coalesced_frames  = fp->rx_coal_count;\n\tcoal->use_adaptive_rx_coalesce = !fp->cq_irq_db;\n\tcoal->tx_coalesce_usecs        = fp->tx_coal_usec;\n\tcoal->tx_max_coalesced_frames  = fp->tx_coal_count;\n\treturn 0;\n}\n\nstatic int fun_set_coalesce(struct net_device *netdev,\n\t\t\t    struct ethtool_coalesce *coal,\n\t\t\t    struct kernel_ethtool_coalesce *kcoal,\n\t\t\t    struct netlink_ext_ack *ext_ack)\n{\n\tstruct funeth_priv *fp = netdev_priv(netdev);\n\tstruct funeth_rxq **rxqs;\n\tunsigned int i, db_val;\n\n\tif (coal->rx_coalesce_usecs > FUN_DB_INTCOAL_USEC_M ||\n\t    coal->rx_max_coalesced_frames > FUN_DB_INTCOAL_ENTRIES_M ||\n\t    (coal->rx_coalesce_usecs | coal->rx_max_coalesced_frames) == 0 ||\n\t    coal->tx_coalesce_usecs > FUN_DB_INTCOAL_USEC_M ||\n\t    coal->tx_max_coalesced_frames > FUN_DB_INTCOAL_ENTRIES_M ||\n\t    (coal->tx_coalesce_usecs | coal->tx_max_coalesced_frames) == 0)\n\t\treturn -EINVAL;\n\n\t \n\tif ((coal->rx_max_coalesced_frames > 1 && !coal->rx_coalesce_usecs) ||\n\t    (coal->tx_max_coalesced_frames > 1 && !coal->tx_coalesce_usecs))\n\t\treturn -EINVAL;\n\n\tfp->rx_coal_usec  = coal->rx_coalesce_usecs;\n\tfp->rx_coal_count = coal->rx_max_coalesced_frames;\n\tfp->tx_coal_usec  = coal->tx_coalesce_usecs;\n\tfp->tx_coal_count = coal->tx_max_coalesced_frames;\n\n\tdb_val = FUN_IRQ_CQ_DB(fp->rx_coal_usec, fp->rx_coal_count);\n\tWRITE_ONCE(fp->cq_irq_db, db_val);\n\n\trxqs = rtnl_dereference(fp->rxqs);\n\tif (!rxqs)\n\t\treturn 0;\n\n\tfor (i = 0; i < netdev->real_num_rx_queues; i++)\n\t\tWRITE_ONCE(rxqs[i]->irq_db_val, db_val);\n\n\tdb_val = FUN_IRQ_SQ_DB(fp->tx_coal_usec, fp->tx_coal_count);\n\tfor (i = 0; i < netdev->real_num_tx_queues; i++)\n\t\tWRITE_ONCE(fp->txqs[i]->irq_db_val, db_val);\n\n\treturn 0;\n}\n\nstatic void fun_get_channels(struct net_device *netdev,\n\t\t\t     struct ethtool_channels *chan)\n{\n\tchan->max_rx   = netdev->num_rx_queues;\n\tchan->rx_count = netdev->real_num_rx_queues;\n\n\tchan->max_tx   = netdev->num_tx_queues;\n\tchan->tx_count = netdev->real_num_tx_queues;\n}\n\nstatic int fun_set_channels(struct net_device *netdev,\n\t\t\t    struct ethtool_channels *chan)\n{\n\tif (!chan->tx_count || !chan->rx_count)\n\t\treturn -EINVAL;\n\n\tif (chan->tx_count == netdev->real_num_tx_queues &&\n\t    chan->rx_count == netdev->real_num_rx_queues)\n\t\treturn 0;\n\n\tif (netif_running(netdev))\n\t\treturn fun_change_num_queues(netdev, chan->tx_count,\n\t\t\t\t\t     chan->rx_count);\n\n\tfun_set_ring_count(netdev, chan->tx_count, chan->rx_count);\n\treturn 0;\n}\n\nstatic void fun_get_ringparam(struct net_device *netdev,\n\t\t\t      struct ethtool_ringparam *ring,\n\t\t\t      struct kernel_ethtool_ringparam *kring,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tconst struct funeth_priv *fp = netdev_priv(netdev);\n\tunsigned int max_depth = fp->fdev->q_depth;\n\n\t \n\tring->rx_max_pending = max_depth / 2;\n\tring->tx_max_pending = max_depth;\n\n\tring->rx_pending = fp->rq_depth;\n\tring->tx_pending = fp->sq_depth;\n\n\tkring->rx_buf_len = PAGE_SIZE;\n\tkring->cqe_size = FUNETH_CQE_SIZE;\n}\n\nstatic int fun_set_ringparam(struct net_device *netdev,\n\t\t\t     struct ethtool_ringparam *ring,\n\t\t\t     struct kernel_ethtool_ringparam *kring,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct funeth_priv *fp = netdev_priv(netdev);\n\tint rc;\n\n\tif (ring->rx_mini_pending || ring->rx_jumbo_pending)\n\t\treturn -EINVAL;\n\n\t \n\tif (!is_power_of_2(ring->rx_pending) ||\n\t    !is_power_of_2(ring->tx_pending))\n\t\treturn -EINVAL;\n\n\tif (ring->rx_pending < FUNETH_MIN_QDEPTH ||\n\t    ring->tx_pending < FUNETH_MIN_QDEPTH)\n\t\treturn -EINVAL;\n\n\tif (fp->sq_depth == ring->tx_pending &&\n\t    fp->rq_depth == ring->rx_pending)\n\t\treturn 0;\n\n\tif (netif_running(netdev)) {\n\t\tstruct fun_qset req = {\n\t\t\t.cq_depth = 2 * ring->rx_pending,\n\t\t\t.rq_depth = ring->rx_pending,\n\t\t\t.sq_depth = ring->tx_pending\n\t\t};\n\n\t\trc = fun_replace_queues(netdev, &req, extack);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tfp->sq_depth = ring->tx_pending;\n\tfp->rq_depth = ring->rx_pending;\n\tfp->cq_depth = 2 * fp->rq_depth;\n\treturn 0;\n}\n\nstatic int fun_get_sset_count(struct net_device *dev, int sset)\n{\n\tconst struct funeth_priv *fp = netdev_priv(dev);\n\tint n;\n\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\tn = (dev->real_num_tx_queues + 1) * ARRAY_SIZE(txq_stat_names) +\n\t\t    (dev->real_num_rx_queues + 1) * ARRAY_SIZE(rxq_stat_names) +\n\t\t    (fp->num_xdpqs + 1) * ARRAY_SIZE(xdpq_stat_names) +\n\t\t    ARRAY_SIZE(tls_stat_names);\n\t\tif (fp->port_caps & FUN_PORT_CAP_STATS) {\n\t\t\tn += ARRAY_SIZE(mac_tx_stat_names) +\n\t\t\t     ARRAY_SIZE(mac_rx_stat_names);\n\t\t}\n\t\treturn n;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void fun_get_strings(struct net_device *netdev, u32 sset, u8 *data)\n{\n\tconst struct funeth_priv *fp = netdev_priv(netdev);\n\tunsigned int i, j;\n\tu8 *p = data;\n\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\tif (fp->port_caps & FUN_PORT_CAP_STATS) {\n\t\t\tmemcpy(p, mac_tx_stat_names, sizeof(mac_tx_stat_names));\n\t\t\tp += sizeof(mac_tx_stat_names);\n\t\t\tmemcpy(p, mac_rx_stat_names, sizeof(mac_rx_stat_names));\n\t\t\tp += sizeof(mac_rx_stat_names);\n\t\t}\n\n\t\tfor (i = 0; i < netdev->real_num_tx_queues; i++) {\n\t\t\tfor (j = 0; j < ARRAY_SIZE(txq_stat_names); j++)\n\t\t\t\tethtool_sprintf(&p, \"%s[%u]\", txq_stat_names[j],\n\t\t\t\t\t\ti);\n\t\t}\n\t\tfor (j = 0; j < ARRAY_SIZE(txq_stat_names); j++)\n\t\t\tethtool_sprintf(&p, txq_stat_names[j]);\n\n\t\tfor (i = 0; i < fp->num_xdpqs; i++) {\n\t\t\tfor (j = 0; j < ARRAY_SIZE(xdpq_stat_names); j++)\n\t\t\t\tethtool_sprintf(&p, \"%s[%u]\",\n\t\t\t\t\t\txdpq_stat_names[j], i);\n\t\t}\n\t\tfor (j = 0; j < ARRAY_SIZE(xdpq_stat_names); j++)\n\t\t\tethtool_sprintf(&p, xdpq_stat_names[j]);\n\n\t\tfor (i = 0; i < netdev->real_num_rx_queues; i++) {\n\t\t\tfor (j = 0; j < ARRAY_SIZE(rxq_stat_names); j++)\n\t\t\t\tethtool_sprintf(&p, \"%s[%u]\", rxq_stat_names[j],\n\t\t\t\t\t\ti);\n\t\t}\n\t\tfor (j = 0; j < ARRAY_SIZE(rxq_stat_names); j++)\n\t\t\tethtool_sprintf(&p, rxq_stat_names[j]);\n\n\t\tfor (j = 0; j < ARRAY_SIZE(tls_stat_names); j++)\n\t\t\tethtool_sprintf(&p, tls_stat_names[j]);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic u64 *get_mac_stats(const struct funeth_priv *fp, u64 *data)\n{\n#define TX_STAT(s) \\\n\t*data++ = be64_to_cpu(fp->stats[PORT_MAC_RX_STATS_MAX + PORT_MAC_TX_##s])\n\n\tTX_STAT(etherStatsOctets);\n\tTX_STAT(etherStatsPkts);\n\tTX_STAT(VLANTransmittedOK);\n\tTX_STAT(ifOutUcastPkts);\n\tTX_STAT(ifOutMulticastPkts);\n\tTX_STAT(ifOutBroadcastPkts);\n\tTX_STAT(ifOutErrors);\n\tTX_STAT(CBFCPAUSEFramesTransmitted_0);\n\tTX_STAT(CBFCPAUSEFramesTransmitted_1);\n\tTX_STAT(CBFCPAUSEFramesTransmitted_2);\n\tTX_STAT(CBFCPAUSEFramesTransmitted_3);\n\tTX_STAT(CBFCPAUSEFramesTransmitted_4);\n\tTX_STAT(CBFCPAUSEFramesTransmitted_5);\n\tTX_STAT(CBFCPAUSEFramesTransmitted_6);\n\tTX_STAT(CBFCPAUSEFramesTransmitted_7);\n\tTX_STAT(CBFCPAUSEFramesTransmitted_8);\n\tTX_STAT(CBFCPAUSEFramesTransmitted_9);\n\tTX_STAT(CBFCPAUSEFramesTransmitted_10);\n\tTX_STAT(CBFCPAUSEFramesTransmitted_11);\n\tTX_STAT(CBFCPAUSEFramesTransmitted_12);\n\tTX_STAT(CBFCPAUSEFramesTransmitted_13);\n\tTX_STAT(CBFCPAUSEFramesTransmitted_14);\n\tTX_STAT(CBFCPAUSEFramesTransmitted_15);\n\n#define RX_STAT(s) *data++ = be64_to_cpu(fp->stats[PORT_MAC_RX_##s])\n\n\tRX_STAT(etherStatsOctets);\n\tRX_STAT(etherStatsPkts);\n\tRX_STAT(VLANReceivedOK);\n\tRX_STAT(ifInUcastPkts);\n\tRX_STAT(ifInMulticastPkts);\n\tRX_STAT(ifInBroadcastPkts);\n\tRX_STAT(etherStatsDropEvents);\n\tRX_STAT(ifInErrors);\n\tRX_STAT(aAlignmentErrors);\n\tRX_STAT(CBFCPAUSEFramesReceived_0);\n\tRX_STAT(CBFCPAUSEFramesReceived_1);\n\tRX_STAT(CBFCPAUSEFramesReceived_2);\n\tRX_STAT(CBFCPAUSEFramesReceived_3);\n\tRX_STAT(CBFCPAUSEFramesReceived_4);\n\tRX_STAT(CBFCPAUSEFramesReceived_5);\n\tRX_STAT(CBFCPAUSEFramesReceived_6);\n\tRX_STAT(CBFCPAUSEFramesReceived_7);\n\tRX_STAT(CBFCPAUSEFramesReceived_8);\n\tRX_STAT(CBFCPAUSEFramesReceived_9);\n\tRX_STAT(CBFCPAUSEFramesReceived_10);\n\tRX_STAT(CBFCPAUSEFramesReceived_11);\n\tRX_STAT(CBFCPAUSEFramesReceived_12);\n\tRX_STAT(CBFCPAUSEFramesReceived_13);\n\tRX_STAT(CBFCPAUSEFramesReceived_14);\n\tRX_STAT(CBFCPAUSEFramesReceived_15);\n\n\treturn data;\n\n#undef TX_STAT\n#undef RX_STAT\n}\n\nstatic void fun_get_ethtool_stats(struct net_device *netdev,\n\t\t\t\t  struct ethtool_stats *stats, u64 *data)\n{\n\tconst struct funeth_priv *fp = netdev_priv(netdev);\n\tstruct funeth_txq_stats txs;\n\tstruct funeth_rxq_stats rxs;\n\tstruct funeth_txq **xdpqs;\n\tstruct funeth_rxq **rxqs;\n\tunsigned int i, start;\n\tu64 *totals, *tot;\n\n\tif (fp->port_caps & FUN_PORT_CAP_STATS)\n\t\tdata = get_mac_stats(fp, data);\n\n\trxqs = rtnl_dereference(fp->rxqs);\n\tif (!rxqs)\n\t\treturn;\n\n#define ADD_STAT(cnt) do { \\\n\t*data = (cnt); *tot++ += *data++; \\\n} while (0)\n\n\t \n\ttotals = data + netdev->real_num_tx_queues * ARRAY_SIZE(txq_stat_names);\n\n\tfor (i = 0; i < netdev->real_num_tx_queues; i++) {\n\t\ttot = totals;\n\n\t\tFUN_QSTAT_READ(fp->txqs[i], start, txs);\n\n\t\tADD_STAT(txs.tx_pkts);\n\t\tADD_STAT(txs.tx_bytes);\n\t\tADD_STAT(txs.tx_cso);\n\t\tADD_STAT(txs.tx_tso);\n\t\tADD_STAT(txs.tx_encap_tso);\n\t\tADD_STAT(txs.tx_uso);\n\t\tADD_STAT(txs.tx_more);\n\t\tADD_STAT(txs.tx_nstops);\n\t\tADD_STAT(txs.tx_nrestarts);\n\t\tADD_STAT(txs.tx_map_err);\n\t\tADD_STAT(txs.tx_tls_pkts);\n\t\tADD_STAT(txs.tx_tls_bytes);\n\t\tADD_STAT(txs.tx_tls_fallback);\n\t\tADD_STAT(txs.tx_tls_drops);\n\t}\n\tdata += ARRAY_SIZE(txq_stat_names);\n\n\t \n\txdpqs = rtnl_dereference(fp->xdpqs);\n\ttotals = data + fp->num_xdpqs * ARRAY_SIZE(xdpq_stat_names);\n\n\tfor (i = 0; i < fp->num_xdpqs; i++) {\n\t\ttot = totals;\n\n\t\tFUN_QSTAT_READ(xdpqs[i], start, txs);\n\n\t\tADD_STAT(txs.tx_pkts);\n\t\tADD_STAT(txs.tx_bytes);\n\t\tADD_STAT(txs.tx_xdp_full);\n\t\tADD_STAT(txs.tx_map_err);\n\t}\n\tdata += ARRAY_SIZE(xdpq_stat_names);\n\n\t \n\ttotals = data + netdev->real_num_rx_queues * ARRAY_SIZE(rxq_stat_names);\n\n\tfor (i = 0; i < netdev->real_num_rx_queues; i++) {\n\t\ttot = totals;\n\n\t\tFUN_QSTAT_READ(rxqs[i], start, rxs);\n\n\t\tADD_STAT(rxs.rx_pkts);\n\t\tADD_STAT(rxs.rx_bytes);\n\t\tADD_STAT(rxs.rx_cso);\n\t\tADD_STAT(rxs.gro_pkts);\n\t\tADD_STAT(rxs.gro_merged);\n\t\tADD_STAT(rxs.xdp_tx);\n\t\tADD_STAT(rxs.xdp_redir);\n\t\tADD_STAT(rxs.xdp_drops);\n\t\tADD_STAT(rxs.rx_bufs);\n\t\tADD_STAT(rxs.rx_page_alloc);\n\t\tADD_STAT(rxs.rx_mem_drops + rxs.xdp_err);\n\t\tADD_STAT(rxs.rx_budget);\n\t\tADD_STAT(rxs.rx_map_err);\n\t}\n\tdata += ARRAY_SIZE(rxq_stat_names);\n#undef ADD_STAT\n\n\t*data++ = atomic64_read(&fp->tx_tls_add);\n\t*data++ = atomic64_read(&fp->tx_tls_del);\n\t*data++ = atomic64_read(&fp->tx_tls_resync);\n}\n\n#define RX_STAT(fp, s) be64_to_cpu((fp)->stats[PORT_MAC_RX_##s])\n#define TX_STAT(fp, s) \\\n\tbe64_to_cpu((fp)->stats[PORT_MAC_RX_STATS_MAX + PORT_MAC_TX_##s])\n#define FEC_STAT(fp, s) \\\n\tbe64_to_cpu((fp)->stats[PORT_MAC_RX_STATS_MAX + \\\n\t\t\t\tPORT_MAC_TX_STATS_MAX + PORT_MAC_FEC_##s])\n\nstatic void fun_get_pause_stats(struct net_device *netdev,\n\t\t\t\tstruct ethtool_pause_stats *stats)\n{\n\tconst struct funeth_priv *fp = netdev_priv(netdev);\n\n\tif (!(fp->port_caps & FUN_PORT_CAP_STATS))\n\t\treturn;\n\n\tstats->tx_pause_frames = TX_STAT(fp, aPAUSEMACCtrlFramesTransmitted);\n\tstats->rx_pause_frames = RX_STAT(fp, aPAUSEMACCtrlFramesReceived);\n}\n\nstatic void fun_get_802_3_stats(struct net_device *netdev,\n\t\t\t\tstruct ethtool_eth_mac_stats *stats)\n{\n\tconst struct funeth_priv *fp = netdev_priv(netdev);\n\n\tif (!(fp->port_caps & FUN_PORT_CAP_STATS))\n\t\treturn;\n\n\tstats->FramesTransmittedOK = TX_STAT(fp, aFramesTransmittedOK);\n\tstats->FramesReceivedOK = RX_STAT(fp, aFramesReceivedOK);\n\tstats->FrameCheckSequenceErrors = RX_STAT(fp, aFrameCheckSequenceErrors);\n\tstats->OctetsTransmittedOK = TX_STAT(fp, OctetsTransmittedOK);\n\tstats->OctetsReceivedOK = RX_STAT(fp, OctetsReceivedOK);\n\tstats->InRangeLengthErrors = RX_STAT(fp, aInRangeLengthErrors);\n\tstats->FrameTooLongErrors = RX_STAT(fp, aFrameTooLongErrors);\n}\n\nstatic void fun_get_802_3_ctrl_stats(struct net_device *netdev,\n\t\t\t\t     struct ethtool_eth_ctrl_stats *stats)\n{\n\tconst struct funeth_priv *fp = netdev_priv(netdev);\n\n\tif (!(fp->port_caps & FUN_PORT_CAP_STATS))\n\t\treturn;\n\n\tstats->MACControlFramesTransmitted = TX_STAT(fp, MACControlFramesTransmitted);\n\tstats->MACControlFramesReceived = RX_STAT(fp, MACControlFramesReceived);\n}\n\nstatic void fun_get_rmon_stats(struct net_device *netdev,\n\t\t\t       struct ethtool_rmon_stats *stats,\n\t\t\t       const struct ethtool_rmon_hist_range **ranges)\n{\n\tstatic const struct ethtool_rmon_hist_range rmon_ranges[] = {\n\t\t{   64,    64 },\n\t\t{   65,   127 },\n\t\t{  128,   255 },\n\t\t{  256,   511 },\n\t\t{  512,  1023 },\n\t\t{ 1024,  1518 },\n\t\t{ 1519, 32767 },\n\t\t{}\n\t};\n\n\tconst struct funeth_priv *fp = netdev_priv(netdev);\n\n\tif (!(fp->port_caps & FUN_PORT_CAP_STATS))\n\t\treturn;\n\n\tstats->undersize_pkts = RX_STAT(fp, etherStatsUndersizePkts);\n\tstats->oversize_pkts = RX_STAT(fp, etherStatsOversizePkts);\n\tstats->fragments = RX_STAT(fp, etherStatsFragments);\n\tstats->jabbers = RX_STAT(fp, etherStatsJabbers);\n\n\tstats->hist[0] = RX_STAT(fp, etherStatsPkts64Octets);\n\tstats->hist[1] = RX_STAT(fp, etherStatsPkts65to127Octets);\n\tstats->hist[2] = RX_STAT(fp, etherStatsPkts128to255Octets);\n\tstats->hist[3] = RX_STAT(fp, etherStatsPkts256to511Octets);\n\tstats->hist[4] = RX_STAT(fp, etherStatsPkts512to1023Octets);\n\tstats->hist[5] = RX_STAT(fp, etherStatsPkts1024to1518Octets);\n\tstats->hist[6] = RX_STAT(fp, etherStatsPkts1519toMaxOctets);\n\n\tstats->hist_tx[0] = TX_STAT(fp, etherStatsPkts64Octets);\n\tstats->hist_tx[1] = TX_STAT(fp, etherStatsPkts65to127Octets);\n\tstats->hist_tx[2] = TX_STAT(fp, etherStatsPkts128to255Octets);\n\tstats->hist_tx[3] = TX_STAT(fp, etherStatsPkts256to511Octets);\n\tstats->hist_tx[4] = TX_STAT(fp, etherStatsPkts512to1023Octets);\n\tstats->hist_tx[5] = TX_STAT(fp, etherStatsPkts1024to1518Octets);\n\tstats->hist_tx[6] = TX_STAT(fp, etherStatsPkts1519toMaxOctets);\n\n\t*ranges = rmon_ranges;\n}\n\nstatic void fun_get_fec_stats(struct net_device *netdev,\n\t\t\t      struct ethtool_fec_stats *stats)\n{\n\tconst struct funeth_priv *fp = netdev_priv(netdev);\n\n\tif (!(fp->port_caps & FUN_PORT_CAP_STATS))\n\t\treturn;\n\n\tstats->corrected_blocks.total = FEC_STAT(fp, Correctable);\n\tstats->uncorrectable_blocks.total = FEC_STAT(fp, Uncorrectable);\n}\n\n#undef RX_STAT\n#undef TX_STAT\n#undef FEC_STAT\n\nstatic int fun_get_rxnfc(struct net_device *netdev, struct ethtool_rxnfc *cmd,\n\t\t\t u32 *rule_locs)\n{\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tcmd->data = netdev->real_num_rx_queues;\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -EOPNOTSUPP;\n}\n\nstatic int fun_set_rxnfc(struct net_device *netdev, struct ethtool_rxnfc *info)\n{\n\treturn 0;\n}\n\nstatic u32 fun_get_rxfh_indir_size(struct net_device *netdev)\n{\n\tconst struct funeth_priv *fp = netdev_priv(netdev);\n\n\treturn fp->indir_table_nentries;\n}\n\nstatic u32 fun_get_rxfh_key_size(struct net_device *netdev)\n{\n\tconst struct funeth_priv *fp = netdev_priv(netdev);\n\n\treturn sizeof(fp->rss_key);\n}\n\nstatic int fun_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,\n\t\t\tu8 *hfunc)\n{\n\tconst struct funeth_priv *fp = netdev_priv(netdev);\n\n\tif (!fp->rss_cfg)\n\t\treturn -EOPNOTSUPP;\n\n\tif (indir)\n\t\tmemcpy(indir, fp->indir_table,\n\t\t       sizeof(u32) * fp->indir_table_nentries);\n\n\tif (key)\n\t\tmemcpy(key, fp->rss_key, sizeof(fp->rss_key));\n\n\tif (hfunc)\n\t\t*hfunc = fp->hash_algo == FUN_ETH_RSS_ALG_TOEPLITZ ?\n\t\t\t\tETH_RSS_HASH_TOP : ETH_RSS_HASH_CRC32;\n\n\treturn 0;\n}\n\nstatic int fun_set_rxfh(struct net_device *netdev, const u32 *indir,\n\t\t\tconst u8 *key, const u8 hfunc)\n{\n\tstruct funeth_priv *fp = netdev_priv(netdev);\n\tconst u32 *rss_indir = indir ? indir : fp->indir_table;\n\tconst u8 *rss_key = key ? key : fp->rss_key;\n\tenum fun_eth_hash_alg algo;\n\n\tif (!fp->rss_cfg)\n\t\treturn -EOPNOTSUPP;\n\n\tif (hfunc == ETH_RSS_HASH_NO_CHANGE)\n\t\talgo = fp->hash_algo;\n\telse if (hfunc == ETH_RSS_HASH_CRC32)\n\t\talgo = FUN_ETH_RSS_ALG_CRC32;\n\telse if (hfunc == ETH_RSS_HASH_TOP)\n\t\talgo = FUN_ETH_RSS_ALG_TOEPLITZ;\n\telse\n\t\treturn -EINVAL;\n\n\t \n\tif (netif_running(netdev)) {\n\t\tint rc = fun_config_rss(netdev, algo, rss_key, rss_indir,\n\t\t\t\t\tFUN_ADMIN_SUBOP_MODIFY);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tfp->hash_algo = algo;\n\tif (key)\n\t\tmemcpy(fp->rss_key, key, sizeof(fp->rss_key));\n\tif (indir)\n\t\tmemcpy(fp->indir_table, indir,\n\t\t       sizeof(u32) * fp->indir_table_nentries);\n\treturn 0;\n}\n\nstatic int fun_get_ts_info(struct net_device *netdev,\n\t\t\t   struct ethtool_ts_info *info)\n{\n\tinfo->so_timestamping = SOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\tinfo->phc_index = -1;\n\tinfo->tx_types = BIT(HWTSTAMP_TX_OFF);\n\tinfo->rx_filters = BIT(HWTSTAMP_FILTER_NONE) | BIT(HWTSTAMP_FILTER_ALL);\n\treturn 0;\n}\n\nstatic unsigned int to_ethtool_fec(unsigned int fun_fec)\n{\n\tunsigned int fec = 0;\n\n\tif (fun_fec == FUN_PORT_FEC_NA)\n\t\tfec |= ETHTOOL_FEC_NONE;\n\tif (fun_fec & FUN_PORT_FEC_OFF)\n\t\tfec |= ETHTOOL_FEC_OFF;\n\tif (fun_fec & FUN_PORT_FEC_RS)\n\t\tfec |= ETHTOOL_FEC_RS;\n\tif (fun_fec & FUN_PORT_FEC_FC)\n\t\tfec |= ETHTOOL_FEC_BASER;\n\tif (fun_fec & FUN_PORT_FEC_AUTO)\n\t\tfec |= ETHTOOL_FEC_AUTO;\n\treturn fec;\n}\n\nstatic int fun_get_fecparam(struct net_device *netdev,\n\t\t\t    struct ethtool_fecparam *fec)\n{\n\tstruct funeth_priv *fp = netdev_priv(netdev);\n\tu64 fec_data;\n\tint rc;\n\n\trc = fun_port_read_cmd(fp, FUN_ADMIN_PORT_KEY_FEC, &fec_data);\n\tif (rc)\n\t\treturn rc;\n\n\tfec->active_fec = to_ethtool_fec(fec_data & 0xff);\n\tfec->fec = to_ethtool_fec(fec_data >> 8);\n\treturn 0;\n}\n\nstatic int fun_set_fecparam(struct net_device *netdev,\n\t\t\t    struct ethtool_fecparam *fec)\n{\n\tstruct funeth_priv *fp = netdev_priv(netdev);\n\tu64 fec_mode;\n\n\tswitch (fec->fec) {\n\tcase ETHTOOL_FEC_AUTO:\n\t\tfec_mode = FUN_PORT_FEC_AUTO;\n\t\tbreak;\n\tcase ETHTOOL_FEC_OFF:\n\t\tif (!(fp->port_caps & FUN_PORT_CAP_FEC_NONE))\n\t\t\treturn -EINVAL;\n\t\tfec_mode = FUN_PORT_FEC_OFF;\n\t\tbreak;\n\tcase ETHTOOL_FEC_BASER:\n\t\tif (!(fp->port_caps & FUN_PORT_CAP_FEC_FC))\n\t\t\treturn -EINVAL;\n\t\tfec_mode = FUN_PORT_FEC_FC;\n\t\tbreak;\n\tcase ETHTOOL_FEC_RS:\n\t\tif (!(fp->port_caps & FUN_PORT_CAP_FEC_RS))\n\t\t\treturn -EINVAL;\n\t\tfec_mode = FUN_PORT_FEC_RS;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn fun_port_write_cmd(fp, FUN_ADMIN_PORT_KEY_FEC, fec_mode);\n}\n\nstatic int fun_get_port_module_page(struct net_device *netdev,\n\t\t\t\t    const struct ethtool_module_eeprom *req,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tunion {\n\t\tstruct fun_admin_port_req req;\n\t\tstruct fun_admin_port_xcvr_read_rsp rsp;\n\t} cmd;\n\tstruct funeth_priv *fp = netdev_priv(netdev);\n\tint rc;\n\n\tif (fp->port_caps & FUN_PORT_CAP_VPORT) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Specified port is virtual, only physical ports have modules\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tcmd.req.common = FUN_ADMIN_REQ_COMMON_INIT2(FUN_ADMIN_OP_PORT,\n\t\t\t\t\t\t    sizeof(cmd.req));\n\tcmd.req.u.xcvr_read =\n\t\tFUN_ADMIN_PORT_XCVR_READ_REQ_INIT(0, netdev->dev_port,\n\t\t\t\t\t\t  req->bank, req->page,\n\t\t\t\t\t\t  req->offset, req->length,\n\t\t\t\t\t\t  req->i2c_address);\n\trc = fun_submit_admin_sync_cmd(fp->fdev, &cmd.req.common, &cmd.rsp,\n\t\t\t\t       sizeof(cmd.rsp), 0);\n\tif (rc)\n\t\treturn rc;\n\n\tmemcpy(req->data, cmd.rsp.data, req->length);\n\treturn req->length;\n}\n\nstatic const struct ethtool_ops fun_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_MAX_FRAMES,\n\t.get_link_ksettings  = fun_get_link_ksettings,\n\t.set_link_ksettings  = fun_set_link_ksettings,\n\t.set_phys_id         = fun_set_phys_id,\n\t.get_drvinfo         = fun_get_drvinfo,\n\t.get_msglevel        = fun_get_msglevel,\n\t.set_msglevel        = fun_set_msglevel,\n\t.get_regs_len        = fun_get_regs_len,\n\t.get_regs            = fun_get_regs,\n\t.get_link\t     = ethtool_op_get_link,\n\t.get_coalesce        = fun_get_coalesce,\n\t.set_coalesce        = fun_set_coalesce,\n\t.get_ts_info         = fun_get_ts_info,\n\t.get_ringparam       = fun_get_ringparam,\n\t.set_ringparam       = fun_set_ringparam,\n\t.get_sset_count      = fun_get_sset_count,\n\t.get_strings         = fun_get_strings,\n\t.get_ethtool_stats   = fun_get_ethtool_stats,\n\t.get_rxnfc\t     = fun_get_rxnfc,\n\t.set_rxnfc           = fun_set_rxnfc,\n\t.get_rxfh_indir_size = fun_get_rxfh_indir_size,\n\t.get_rxfh_key_size   = fun_get_rxfh_key_size,\n\t.get_rxfh            = fun_get_rxfh,\n\t.set_rxfh            = fun_set_rxfh,\n\t.get_channels        = fun_get_channels,\n\t.set_channels        = fun_set_channels,\n\t.get_fecparam\t     = fun_get_fecparam,\n\t.set_fecparam\t     = fun_set_fecparam,\n\t.get_pauseparam      = fun_get_pauseparam,\n\t.set_pauseparam      = fun_set_pauseparam,\n\t.nway_reset          = fun_restart_an,\n\t.get_pause_stats     = fun_get_pause_stats,\n\t.get_fec_stats       = fun_get_fec_stats,\n\t.get_eth_mac_stats   = fun_get_802_3_stats,\n\t.get_eth_ctrl_stats  = fun_get_802_3_ctrl_stats,\n\t.get_rmon_stats      = fun_get_rmon_stats,\n\t.get_module_eeprom_by_page = fun_get_port_module_page,\n};\n\nvoid fun_set_ethtool_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &fun_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}