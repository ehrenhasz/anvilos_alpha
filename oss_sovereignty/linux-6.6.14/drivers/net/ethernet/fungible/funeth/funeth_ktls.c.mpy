{
  "module_name": "funeth_ktls.c",
  "hash_id": "adb1622f91dbdd2bfa488ff592f0ddd1bc8ccf38bf787cfc53c3f6705265e37c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/fungible/funeth/funeth_ktls.c",
  "human_readable_source": "\n\n#include \"funeth.h\"\n#include \"funeth_ktls.h\"\n\nstatic int fun_admin_ktls_create(struct funeth_priv *fp, unsigned int id)\n{\n\tstruct fun_admin_ktls_create_req req = {\n\t\t.common = FUN_ADMIN_REQ_COMMON_INIT2(FUN_ADMIN_OP_KTLS,\n\t\t\t\t\t\t     sizeof(req)),\n\t\t.subop = FUN_ADMIN_SUBOP_CREATE,\n\t\t.id = cpu_to_be32(id),\n\t};\n\n\treturn fun_submit_admin_sync_cmd(fp->fdev, &req.common, NULL, 0, 0);\n}\n\nstatic int fun_ktls_add(struct net_device *netdev, struct sock *sk,\n\t\t\tenum tls_offload_ctx_dir direction,\n\t\t\tstruct tls_crypto_info *crypto_info,\n\t\t\tu32 start_offload_tcp_sn)\n{\n\tstruct funeth_priv *fp = netdev_priv(netdev);\n\tstruct fun_admin_ktls_modify_req req = {\n\t\t.common = FUN_ADMIN_REQ_COMMON_INIT2(FUN_ADMIN_OP_KTLS,\n\t\t\t\t\t\t     sizeof(req)),\n\t\t.subop = FUN_ADMIN_SUBOP_MODIFY,\n\t\t.id = cpu_to_be32(fp->ktls_id),\n\t\t.tcp_seq = cpu_to_be32(start_offload_tcp_sn),\n\t};\n\tstruct fun_admin_ktls_modify_rsp rsp;\n\tstruct fun_ktls_tx_ctx *tx_ctx;\n\tint rc;\n\n\tif (direction != TLS_OFFLOAD_CTX_DIR_TX)\n\t\treturn -EOPNOTSUPP;\n\n\tif (crypto_info->version == TLS_1_2_VERSION)\n\t\treq.version = FUN_KTLS_TLSV2;\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (crypto_info->cipher_type) {\n\tcase TLS_CIPHER_AES_GCM_128: {\n\t\tstruct tls12_crypto_info_aes_gcm_128 *c = (void *)crypto_info;\n\n\t\treq.cipher = FUN_KTLS_CIPHER_AES_GCM_128;\n\t\tmemcpy(req.key, c->key, sizeof(c->key));\n\t\tmemcpy(req.iv, c->iv, sizeof(c->iv));\n\t\tmemcpy(req.salt, c->salt, sizeof(c->salt));\n\t\tmemcpy(req.record_seq, c->rec_seq, sizeof(c->rec_seq));\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\trc = fun_submit_admin_sync_cmd(fp->fdev, &req.common, &rsp,\n\t\t\t\t       sizeof(rsp), 0);\n\tmemzero_explicit(&req, sizeof(req));\n\tif (rc)\n\t\treturn rc;\n\n\ttx_ctx = tls_driver_ctx(sk, direction);\n\ttx_ctx->tlsid = rsp.tlsid;\n\ttx_ctx->next_seq = start_offload_tcp_sn;\n\tatomic64_inc(&fp->tx_tls_add);\n\treturn 0;\n}\n\nstatic void fun_ktls_del(struct net_device *netdev,\n\t\t\t struct tls_context *tls_ctx,\n\t\t\t enum tls_offload_ctx_dir direction)\n{\n\tstruct funeth_priv *fp = netdev_priv(netdev);\n\tstruct fun_admin_ktls_modify_req req;\n\tstruct fun_ktls_tx_ctx *tx_ctx;\n\n\tif (direction != TLS_OFFLOAD_CTX_DIR_TX)\n\t\treturn;\n\n\ttx_ctx = __tls_driver_ctx(tls_ctx, direction);\n\n\treq.common = FUN_ADMIN_REQ_COMMON_INIT2(FUN_ADMIN_OP_KTLS,\n\t\t\toffsetof(struct fun_admin_ktls_modify_req, tcp_seq));\n\treq.subop = FUN_ADMIN_SUBOP_MODIFY;\n\treq.flags = cpu_to_be16(FUN_KTLS_MODIFY_REMOVE);\n\treq.id = cpu_to_be32(fp->ktls_id);\n\treq.tlsid = tx_ctx->tlsid;\n\n\tfun_submit_admin_sync_cmd(fp->fdev, &req.common, NULL, 0, 0);\n\tatomic64_inc(&fp->tx_tls_del);\n}\n\nstatic int fun_ktls_resync(struct net_device *netdev, struct sock *sk, u32 seq,\n\t\t\t   u8 *rcd_sn, enum tls_offload_ctx_dir direction)\n{\n\tstruct funeth_priv *fp = netdev_priv(netdev);\n\tstruct fun_admin_ktls_modify_req req;\n\tstruct fun_ktls_tx_ctx *tx_ctx;\n\tint rc;\n\n\tif (direction != TLS_OFFLOAD_CTX_DIR_TX)\n\t\treturn -EOPNOTSUPP;\n\n\ttx_ctx = tls_driver_ctx(sk, direction);\n\n\treq.common = FUN_ADMIN_REQ_COMMON_INIT2(FUN_ADMIN_OP_KTLS,\n\t\t\toffsetof(struct fun_admin_ktls_modify_req, key));\n\treq.subop = FUN_ADMIN_SUBOP_MODIFY;\n\treq.flags = 0;\n\treq.id = cpu_to_be32(fp->ktls_id);\n\treq.tlsid = tx_ctx->tlsid;\n\treq.tcp_seq = cpu_to_be32(seq);\n\treq.version = 0;\n\treq.cipher = 0;\n\tmemcpy(req.record_seq, rcd_sn, sizeof(req.record_seq));\n\n\tatomic64_inc(&fp->tx_tls_resync);\n\trc = fun_submit_admin_sync_cmd(fp->fdev, &req.common, NULL, 0, 0);\n\tif (!rc)\n\t\ttx_ctx->next_seq = seq;\n\treturn rc;\n}\n\nstatic const struct tlsdev_ops fun_ktls_ops = {\n\t.tls_dev_add = fun_ktls_add,\n\t.tls_dev_del = fun_ktls_del,\n\t.tls_dev_resync = fun_ktls_resync,\n};\n\nint fun_ktls_init(struct net_device *netdev)\n{\n\tstruct funeth_priv *fp = netdev_priv(netdev);\n\tint rc;\n\n\trc = fun_admin_ktls_create(fp, netdev->dev_port);\n\tif (rc)\n\t\treturn rc;\n\n\tfp->ktls_id = netdev->dev_port;\n\tnetdev->tlsdev_ops = &fun_ktls_ops;\n\tnetdev->hw_features |= NETIF_F_HW_TLS_TX;\n\tnetdev->features |= NETIF_F_HW_TLS_TX;\n\treturn 0;\n}\n\nvoid fun_ktls_cleanup(struct funeth_priv *fp)\n{\n\tif (fp->ktls_id == FUN_HCI_ID_INVALID)\n\t\treturn;\n\n\tfun_res_destroy(fp->fdev, FUN_ADMIN_OP_KTLS, 0, fp->ktls_id);\n\tfp->ktls_id = FUN_HCI_ID_INVALID;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}