{
  "module_name": "be_ethtool.c",
  "hash_id": "af120144b73924e5ba95168c0ac9d952134c9b3ec4d80654b8d94100120ad344",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/emulex/benet/be_ethtool.c",
  "human_readable_source": "\n \n\n#include \"be.h\"\n#include \"be_cmds.h\"\n#include <linux/ethtool.h>\n\nstruct be_ethtool_stat {\n\tchar desc[ETH_GSTRING_LEN];\n\tint type;\n\tint size;\n\tint offset;\n};\n\nenum {DRVSTAT_TX, DRVSTAT_RX, DRVSTAT};\n#define FIELDINFO(_struct, field) sizeof_field(_struct, field), \\\n\t\t\t\t\toffsetof(_struct, field)\n#define DRVSTAT_TX_INFO(field)\t#field, DRVSTAT_TX,\\\n\t\t\t\t\tFIELDINFO(struct be_tx_stats, field)\n#define DRVSTAT_RX_INFO(field)\t#field, DRVSTAT_RX,\\\n\t\t\t\t\tFIELDINFO(struct be_rx_stats, field)\n#define\tDRVSTAT_INFO(field)\t#field, DRVSTAT,\\\n\t\t\t\t\tFIELDINFO(struct be_drv_stats, field)\n\nstatic const struct be_ethtool_stat et_stats[] = {\n\t{DRVSTAT_INFO(rx_crc_errors)},\n\t{DRVSTAT_INFO(rx_alignment_symbol_errors)},\n\t{DRVSTAT_INFO(rx_pause_frames)},\n\t{DRVSTAT_INFO(rx_control_frames)},\n\t \n\t{DRVSTAT_INFO(rx_in_range_errors)},\n\t \n\t{DRVSTAT_INFO(rx_out_range_errors)},\n\t \n\t{DRVSTAT_INFO(rx_frame_too_long)},\n\t \n\t{DRVSTAT_INFO(rx_address_filtered)},\n\t \n\t{DRVSTAT_INFO(rx_dropped_too_small)},\n\t \n\t{DRVSTAT_INFO(rx_dropped_too_short)},\n\t \n\t{DRVSTAT_INFO(rx_dropped_header_too_small)},\n\t \n\t{DRVSTAT_INFO(rx_dropped_tcp_length)},\n\t{DRVSTAT_INFO(rx_dropped_runt)},\n\t \n\t{DRVSTAT_INFO(rxpp_fifo_overflow_drop)},\n\t \n\t{DRVSTAT_INFO(rx_input_fifo_overflow_drop)},\n\t{DRVSTAT_INFO(rx_ip_checksum_errs)},\n\t{DRVSTAT_INFO(rx_tcp_checksum_errs)},\n\t{DRVSTAT_INFO(rx_udp_checksum_errs)},\n\t{DRVSTAT_INFO(tx_pauseframes)},\n\t{DRVSTAT_INFO(tx_controlframes)},\n\t{DRVSTAT_INFO(rx_priority_pause_frames)},\n\t{DRVSTAT_INFO(tx_priority_pauseframes)},\n\t \n\t{DRVSTAT_INFO(pmem_fifo_overflow_drop)},\n\t{DRVSTAT_INFO(jabber_events)},\n\t \n\t{DRVSTAT_INFO(rx_drops_no_pbuf)},\n\t \n\t{DRVSTAT_INFO(rx_drops_no_erx_descr)},\n\t \n\t{DRVSTAT_INFO(rx_drops_no_tpre_descr)},\n\t \n\t{DRVSTAT_INFO(rx_drops_too_many_frags)},\n\t{DRVSTAT_INFO(forwarded_packets)},\n\t \n\t{DRVSTAT_INFO(rx_drops_mtu)},\n\t \n\t{DRVSTAT_INFO(dma_map_errors)},\n\t \n\t{DRVSTAT_INFO(eth_red_drops)},\n\t{DRVSTAT_INFO(rx_roce_bytes_lsd)},\n\t{DRVSTAT_INFO(rx_roce_bytes_msd)},\n\t{DRVSTAT_INFO(rx_roce_frames)},\n\t{DRVSTAT_INFO(roce_drops_payload_len)},\n\t{DRVSTAT_INFO(roce_drops_crc)}\n};\n\n#define ETHTOOL_STATS_NUM ARRAY_SIZE(et_stats)\n\n \nstatic const struct be_ethtool_stat et_rx_stats[] = {\n\t{DRVSTAT_RX_INFO(rx_bytes)}, \n\t{DRVSTAT_RX_INFO(rx_pkts)},  \n\t{DRVSTAT_RX_INFO(rx_vxlan_offload_pkts)},\n\t{DRVSTAT_RX_INFO(rx_compl)},\n\t{DRVSTAT_RX_INFO(rx_compl_err)},\n\t{DRVSTAT_RX_INFO(rx_mcast_pkts)},\n\t \n\t{DRVSTAT_RX_INFO(rx_post_fail)},\n\t \n\t{DRVSTAT_RX_INFO(rx_drops_no_skbs)},\n\t \n\t{DRVSTAT_RX_INFO(rx_drops_no_frags)}\n};\n\n#define ETHTOOL_RXSTATS_NUM (ARRAY_SIZE(et_rx_stats))\n\n \nstatic const struct be_ethtool_stat et_tx_stats[] = {\n\t{DRVSTAT_TX_INFO(tx_compl)},  \n\t \n\t{DRVSTAT_TX_INFO(tx_hdr_parse_err)},\n\t \n\t{DRVSTAT_TX_INFO(tx_dma_err)},\n\t \n\t{DRVSTAT_TX_INFO(tx_spoof_check_err)},\n\t \n\t{DRVSTAT_TX_INFO(tx_tso_err)},\n\t \n\t{DRVSTAT_TX_INFO(tx_qinq_err)},\n\t \n\t{DRVSTAT_TX_INFO(tx_internal_parity_err)},\n\t{DRVSTAT_TX_INFO(tx_sge_err)},\n\t{DRVSTAT_TX_INFO(tx_bytes)},\n\t{DRVSTAT_TX_INFO(tx_pkts)},\n\t{DRVSTAT_TX_INFO(tx_vxlan_offload_pkts)},\n\t \n\t{DRVSTAT_TX_INFO(tx_reqs)},\n\t \n\t{DRVSTAT_TX_INFO(tx_stops)},\n\t \n\t{DRVSTAT_TX_INFO(tx_drv_drops)}\n};\n\n#define ETHTOOL_TXSTATS_NUM (ARRAY_SIZE(et_tx_stats))\n\nstatic const char et_self_tests[][ETH_GSTRING_LEN] = {\n\t\"MAC Loopback test\",\n\t\"PHY Loopback test\",\n\t\"External Loopback test\",\n\t\"DDR DMA test\",\n\t\"Link test\"\n};\n\n#define ETHTOOL_TESTS_NUM ARRAY_SIZE(et_self_tests)\n#define BE_MAC_LOOPBACK 0x0\n#define BE_PHY_LOOPBACK 0x1\n#define BE_ONE_PORT_EXT_LOOPBACK 0x2\n#define BE_NO_LOOPBACK 0xff\n\nstatic void be_get_drvinfo(struct net_device *netdev,\n\t\t\t   struct ethtool_drvinfo *drvinfo)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\n\tstrscpy(drvinfo->driver, DRV_NAME, sizeof(drvinfo->driver));\n\tif (!memcmp(adapter->fw_ver, adapter->fw_on_flash, FW_VER_LEN))\n\t\tstrscpy(drvinfo->fw_version, adapter->fw_ver,\n\t\t\tsizeof(drvinfo->fw_version));\n\telse\n\t\tsnprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),\n\t\t\t \"%s [%s]\", adapter->fw_ver, adapter->fw_on_flash);\n\n\tstrscpy(drvinfo->bus_info, pci_name(adapter->pdev),\n\t\tsizeof(drvinfo->bus_info));\n}\n\nstatic u32 lancer_cmd_get_file_len(struct be_adapter *adapter, u8 *file_name)\n{\n\tu32 data_read = 0, eof;\n\tu8 addn_status;\n\tstruct be_dma_mem data_len_cmd;\n\n\tmemset(&data_len_cmd, 0, sizeof(data_len_cmd));\n\t \n\tlancer_cmd_read_object(adapter, &data_len_cmd, 0, 0, file_name,\n\t\t\t       &data_read, &eof, &addn_status);\n\n\treturn data_read;\n}\n\nstatic int be_get_dump_len(struct be_adapter *adapter)\n{\n\tu32 dump_size = 0;\n\n\tif (lancer_chip(adapter))\n\t\tdump_size = lancer_cmd_get_file_len(adapter,\n\t\t\t\t\t\t    LANCER_FW_DUMP_FILE);\n\telse\n\t\tdump_size = adapter->fat_dump_len;\n\n\treturn dump_size;\n}\n\nstatic int lancer_cmd_read_file(struct be_adapter *adapter, u8 *file_name,\n\t\t\t\tu32 buf_len, void *buf)\n{\n\tstruct be_dma_mem read_cmd;\n\tu32 read_len = 0, total_read_len = 0, chunk_size;\n\tu32 eof = 0;\n\tu8 addn_status;\n\tint status = 0;\n\n\tread_cmd.size = LANCER_READ_FILE_CHUNK;\n\tread_cmd.va = dma_alloc_coherent(&adapter->pdev->dev, read_cmd.size,\n\t\t\t\t\t &read_cmd.dma, GFP_ATOMIC);\n\n\tif (!read_cmd.va) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"Memory allocation failure while reading dump\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\twhile ((total_read_len < buf_len) && !eof) {\n\t\tchunk_size = min_t(u32, (buf_len - total_read_len),\n\t\t\t\t   LANCER_READ_FILE_CHUNK);\n\t\tchunk_size = ALIGN(chunk_size, 4);\n\t\tstatus = lancer_cmd_read_object(adapter, &read_cmd, chunk_size,\n\t\t\t\t\t\ttotal_read_len, file_name,\n\t\t\t\t\t\t&read_len, &eof, &addn_status);\n\t\tif (!status) {\n\t\t\tmemcpy(buf + total_read_len, read_cmd.va, read_len);\n\t\t\ttotal_read_len += read_len;\n\t\t\teof &= LANCER_READ_FILE_EOF_MASK;\n\t\t} else {\n\t\t\tstatus = -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdma_free_coherent(&adapter->pdev->dev, read_cmd.size, read_cmd.va,\n\t\t\t  read_cmd.dma);\n\n\treturn status;\n}\n\nstatic int be_read_dump_data(struct be_adapter *adapter, u32 dump_len,\n\t\t\t     void *buf)\n{\n\tint status = 0;\n\n\tif (lancer_chip(adapter))\n\t\tstatus = lancer_cmd_read_file(adapter, LANCER_FW_DUMP_FILE,\n\t\t\t\t\t      dump_len, buf);\n\telse\n\t\tstatus = be_cmd_get_fat_dump(adapter, dump_len, buf);\n\n\treturn status;\n}\n\nstatic int be_get_coalesce(struct net_device *netdev,\n\t\t\t   struct ethtool_coalesce *et,\n\t\t\t   struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\tstruct be_aic_obj *aic = &adapter->aic_obj[0];\n\n\tet->rx_coalesce_usecs = aic->prev_eqd;\n\tet->rx_coalesce_usecs_high = aic->max_eqd;\n\tet->rx_coalesce_usecs_low = aic->min_eqd;\n\n\tet->tx_coalesce_usecs = aic->prev_eqd;\n\tet->tx_coalesce_usecs_high = aic->max_eqd;\n\tet->tx_coalesce_usecs_low = aic->min_eqd;\n\n\tet->use_adaptive_rx_coalesce = adapter->aic_enabled;\n\tet->use_adaptive_tx_coalesce = adapter->aic_enabled;\n\n\treturn 0;\n}\n\n \nstatic int be_set_coalesce(struct net_device *netdev,\n\t\t\t   struct ethtool_coalesce *et,\n\t\t\t   struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\tstruct be_aic_obj *aic = &adapter->aic_obj[0];\n\tstruct be_eq_obj *eqo;\n\tint i;\n\n\tadapter->aic_enabled = et->use_adaptive_rx_coalesce;\n\n\tfor_all_evt_queues(adapter, eqo, i) {\n\t\taic->max_eqd = min(et->rx_coalesce_usecs_high, BE_MAX_EQD);\n\t\taic->min_eqd = min(et->rx_coalesce_usecs_low, aic->max_eqd);\n\t\taic->et_eqd = min(et->rx_coalesce_usecs, aic->max_eqd);\n\t\taic->et_eqd = max(aic->et_eqd, aic->min_eqd);\n\t\taic++;\n\t}\n\n\t \n\tif (!et->use_adaptive_rx_coalesce && skyhawk_chip(adapter))\n\t\tbe_eqd_update(adapter, true);\n\n\treturn 0;\n}\n\nstatic void be_get_ethtool_stats(struct net_device *netdev,\n\t\t\t\t struct ethtool_stats *stats, uint64_t *data)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\tstruct be_rx_obj *rxo;\n\tstruct be_tx_obj *txo;\n\tvoid *p;\n\tunsigned int i, j, base = 0, start;\n\n\tfor (i = 0; i < ETHTOOL_STATS_NUM; i++) {\n\t\tp = (u8 *)&adapter->drv_stats + et_stats[i].offset;\n\t\tdata[i] = *(u32 *)p;\n\t}\n\tbase += ETHTOOL_STATS_NUM;\n\n\tfor_all_rx_queues(adapter, rxo, j) {\n\t\tstruct be_rx_stats *stats = rx_stats(rxo);\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&stats->sync);\n\t\t\tdata[base] = stats->rx_bytes;\n\t\t\tdata[base + 1] = stats->rx_pkts;\n\t\t} while (u64_stats_fetch_retry(&stats->sync, start));\n\n\t\tfor (i = 2; i < ETHTOOL_RXSTATS_NUM; i++) {\n\t\t\tp = (u8 *)stats + et_rx_stats[i].offset;\n\t\t\tdata[base + i] = *(u32 *)p;\n\t\t}\n\t\tbase += ETHTOOL_RXSTATS_NUM;\n\t}\n\n\tfor_all_tx_queues(adapter, txo, j) {\n\t\tstruct be_tx_stats *stats = tx_stats(txo);\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&stats->sync_compl);\n\t\t\tdata[base] = stats->tx_compl;\n\t\t} while (u64_stats_fetch_retry(&stats->sync_compl, start));\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&stats->sync);\n\t\t\tfor (i = 1; i < ETHTOOL_TXSTATS_NUM; i++) {\n\t\t\t\tp = (u8 *)stats + et_tx_stats[i].offset;\n\t\t\t\tdata[base + i] =\n\t\t\t\t\t(et_tx_stats[i].size == sizeof(u64)) ?\n\t\t\t\t\t\t*(u64 *)p : *(u32 *)p;\n\t\t\t}\n\t\t} while (u64_stats_fetch_retry(&stats->sync, start));\n\t\tbase += ETHTOOL_TXSTATS_NUM;\n\t}\n}\n\nstatic const char be_priv_flags[][ETH_GSTRING_LEN] = {\n\t\"disable-tpe-recovery\"\n};\n\nstatic void be_get_stat_strings(struct net_device *netdev, uint32_t stringset,\n\t\t\t\tuint8_t *data)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\tint i, j;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < ETHTOOL_STATS_NUM; i++) {\n\t\t\tmemcpy(data, et_stats[i].desc, ETH_GSTRING_LEN);\n\t\t\tdata += ETH_GSTRING_LEN;\n\t\t}\n\t\tfor (i = 0; i < adapter->num_rx_qs; i++) {\n\t\t\tfor (j = 0; j < ETHTOOL_RXSTATS_NUM; j++) {\n\t\t\t\tsprintf(data, \"rxq%d: %s\", i,\n\t\t\t\t\tet_rx_stats[j].desc);\n\t\t\t\tdata += ETH_GSTRING_LEN;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < adapter->num_tx_qs; i++) {\n\t\t\tfor (j = 0; j < ETHTOOL_TXSTATS_NUM; j++) {\n\t\t\t\tsprintf(data, \"txq%d: %s\", i,\n\t\t\t\t\tet_tx_stats[j].desc);\n\t\t\t\tdata += ETH_GSTRING_LEN;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ETH_SS_TEST:\n\t\tfor (i = 0; i < ETHTOOL_TESTS_NUM; i++) {\n\t\t\tmemcpy(data, et_self_tests[i], ETH_GSTRING_LEN);\n\t\t\tdata += ETH_GSTRING_LEN;\n\t\t}\n\t\tbreak;\n\tcase ETH_SS_PRIV_FLAGS:\n\t\tfor (i = 0; i < ARRAY_SIZE(be_priv_flags); i++)\n\t\t\tstrcpy(data + i * ETH_GSTRING_LEN, be_priv_flags[i]);\n\t\tbreak;\n\t}\n}\n\nstatic int be_get_sset_count(struct net_device *netdev, int stringset)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\n\tswitch (stringset) {\n\tcase ETH_SS_TEST:\n\t\treturn ETHTOOL_TESTS_NUM;\n\tcase ETH_SS_STATS:\n\t\treturn ETHTOOL_STATS_NUM +\n\t\t\tadapter->num_rx_qs * ETHTOOL_RXSTATS_NUM +\n\t\t\tadapter->num_tx_qs * ETHTOOL_TXSTATS_NUM;\n\tcase ETH_SS_PRIV_FLAGS:\n\t\treturn ARRAY_SIZE(be_priv_flags);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic u32 be_get_port_type(struct be_adapter *adapter)\n{\n\tu32 port;\n\n\tswitch (adapter->phy.interface_type) {\n\tcase PHY_TYPE_BASET_1GB:\n\tcase PHY_TYPE_BASEX_1GB:\n\tcase PHY_TYPE_SGMII:\n\t\tport = PORT_TP;\n\t\tbreak;\n\tcase PHY_TYPE_SFP_PLUS_10GB:\n\t\tif (adapter->phy.cable_type & SFP_PLUS_COPPER_CABLE)\n\t\t\tport = PORT_DA;\n\t\telse\n\t\t\tport = PORT_FIBRE;\n\t\tbreak;\n\tcase PHY_TYPE_QSFP:\n\t\tif (adapter->phy.cable_type & QSFP_PLUS_CR4_CABLE)\n\t\t\tport = PORT_DA;\n\t\telse\n\t\t\tport = PORT_FIBRE;\n\t\tbreak;\n\tcase PHY_TYPE_XFP_10GB:\n\tcase PHY_TYPE_SFP_1GB:\n\t\tport = PORT_FIBRE;\n\t\tbreak;\n\tcase PHY_TYPE_BASET_10GB:\n\t\tport = PORT_TP;\n\t\tbreak;\n\tdefault:\n\t\tport = PORT_OTHER;\n\t}\n\n\treturn port;\n}\n\nstatic u32 convert_to_et_setting(struct be_adapter *adapter, u32 if_speeds)\n{\n\tu32 val = 0;\n\n\tswitch (adapter->phy.interface_type) {\n\tcase PHY_TYPE_BASET_1GB:\n\tcase PHY_TYPE_BASEX_1GB:\n\tcase PHY_TYPE_SGMII:\n\t\tval |= SUPPORTED_TP;\n\t\tif (if_speeds & BE_SUPPORTED_SPEED_1GBPS)\n\t\t\tval |= SUPPORTED_1000baseT_Full;\n\t\tif (if_speeds & BE_SUPPORTED_SPEED_100MBPS)\n\t\t\tval |= SUPPORTED_100baseT_Full;\n\t\tif (if_speeds & BE_SUPPORTED_SPEED_10MBPS)\n\t\t\tval |= SUPPORTED_10baseT_Full;\n\t\tbreak;\n\tcase PHY_TYPE_KX4_10GB:\n\t\tval |= SUPPORTED_Backplane;\n\t\tif (if_speeds & BE_SUPPORTED_SPEED_1GBPS)\n\t\t\tval |= SUPPORTED_1000baseKX_Full;\n\t\tif (if_speeds & BE_SUPPORTED_SPEED_10GBPS)\n\t\t\tval |= SUPPORTED_10000baseKX4_Full;\n\t\tbreak;\n\tcase PHY_TYPE_KR2_20GB:\n\t\tval |= SUPPORTED_Backplane;\n\t\tif (if_speeds & BE_SUPPORTED_SPEED_10GBPS)\n\t\t\tval |= SUPPORTED_10000baseKR_Full;\n\t\tif (if_speeds & BE_SUPPORTED_SPEED_20GBPS)\n\t\t\tval |= SUPPORTED_20000baseKR2_Full;\n\t\tbreak;\n\tcase PHY_TYPE_KR_10GB:\n\t\tval |= SUPPORTED_Backplane |\n\t\t\t\tSUPPORTED_10000baseKR_Full;\n\t\tbreak;\n\tcase PHY_TYPE_KR4_40GB:\n\t\tval |= SUPPORTED_Backplane;\n\t\tif (if_speeds & BE_SUPPORTED_SPEED_10GBPS)\n\t\t\tval |= SUPPORTED_10000baseKR_Full;\n\t\tif (if_speeds & BE_SUPPORTED_SPEED_40GBPS)\n\t\t\tval |= SUPPORTED_40000baseKR4_Full;\n\t\tbreak;\n\tcase PHY_TYPE_QSFP:\n\t\tif (if_speeds & BE_SUPPORTED_SPEED_40GBPS) {\n\t\t\tswitch (adapter->phy.cable_type) {\n\t\t\tcase QSFP_PLUS_CR4_CABLE:\n\t\t\t\tval |= SUPPORTED_40000baseCR4_Full;\n\t\t\t\tbreak;\n\t\t\tcase QSFP_PLUS_LR4_CABLE:\n\t\t\t\tval |= SUPPORTED_40000baseLR4_Full;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tval |= SUPPORTED_40000baseSR4_Full;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfallthrough;\n\tcase PHY_TYPE_SFP_PLUS_10GB:\n\tcase PHY_TYPE_XFP_10GB:\n\tcase PHY_TYPE_SFP_1GB:\n\t\tval |= SUPPORTED_FIBRE;\n\t\tif (if_speeds & BE_SUPPORTED_SPEED_10GBPS)\n\t\t\tval |= SUPPORTED_10000baseT_Full;\n\t\tif (if_speeds & BE_SUPPORTED_SPEED_1GBPS)\n\t\t\tval |= SUPPORTED_1000baseT_Full;\n\t\tbreak;\n\tcase PHY_TYPE_BASET_10GB:\n\t\tval |= SUPPORTED_TP;\n\t\tif (if_speeds & BE_SUPPORTED_SPEED_10GBPS)\n\t\t\tval |= SUPPORTED_10000baseT_Full;\n\t\tif (if_speeds & BE_SUPPORTED_SPEED_1GBPS)\n\t\t\tval |= SUPPORTED_1000baseT_Full;\n\t\tif (if_speeds & BE_SUPPORTED_SPEED_100MBPS)\n\t\t\tval |= SUPPORTED_100baseT_Full;\n\t\tbreak;\n\tdefault:\n\t\tval |= SUPPORTED_TP;\n\t}\n\n\treturn val;\n}\n\nbool be_pause_supported(struct be_adapter *adapter)\n{\n\treturn (adapter->phy.interface_type == PHY_TYPE_SFP_PLUS_10GB ||\n\t\tadapter->phy.interface_type == PHY_TYPE_XFP_10GB) ?\n\t\tfalse : true;\n}\n\nstatic int be_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t struct ethtool_link_ksettings *cmd)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\tu8 link_status;\n\tu16 link_speed = 0;\n\tint status;\n\tu32 auto_speeds;\n\tu32 fixed_speeds;\n\tu32 supported = 0, advertising = 0;\n\n\tif (adapter->phy.link_speed < 0) {\n\t\tstatus = be_cmd_link_status_query(adapter, &link_speed,\n\t\t\t\t\t\t  &link_status, 0);\n\t\tif (!status)\n\t\t\tbe_link_status_update(adapter, link_status);\n\t\tcmd->base.speed = link_speed;\n\n\t\tstatus = be_cmd_get_phy_info(adapter);\n\t\tif (!status) {\n\t\t\tauto_speeds = adapter->phy.auto_speeds_supported;\n\t\t\tfixed_speeds = adapter->phy.fixed_speeds_supported;\n\n\t\t\tbe_cmd_query_cable_type(adapter);\n\n\t\t\tsupported =\n\t\t\t\tconvert_to_et_setting(adapter,\n\t\t\t\t\t\t      auto_speeds |\n\t\t\t\t\t\t      fixed_speeds);\n\t\t\tadvertising =\n\t\t\t\tconvert_to_et_setting(adapter, auto_speeds);\n\n\t\t\tcmd->base.port = be_get_port_type(adapter);\n\n\t\t\tif (adapter->phy.auto_speeds_supported) {\n\t\t\t\tsupported |= SUPPORTED_Autoneg;\n\t\t\t\tcmd->base.autoneg = AUTONEG_ENABLE;\n\t\t\t\tadvertising |= ADVERTISED_Autoneg;\n\t\t\t}\n\n\t\t\tsupported |= SUPPORTED_Pause;\n\t\t\tif (be_pause_supported(adapter))\n\t\t\t\tadvertising |= ADVERTISED_Pause;\n\t\t} else {\n\t\t\tcmd->base.port = PORT_OTHER;\n\t\t\tcmd->base.autoneg = AUTONEG_DISABLE;\n\t\t}\n\n\t\t \n\t\tadapter->phy.link_speed = cmd->base.speed;\n\t\tadapter->phy.port_type = cmd->base.port;\n\t\tadapter->phy.autoneg = cmd->base.autoneg;\n\t\tadapter->phy.advertising = advertising;\n\t\tadapter->phy.supported = supported;\n\t} else {\n\t\tcmd->base.speed = adapter->phy.link_speed;\n\t\tcmd->base.port = adapter->phy.port_type;\n\t\tcmd->base.autoneg = adapter->phy.autoneg;\n\t\tadvertising = adapter->phy.advertising;\n\t\tsupported = adapter->phy.supported;\n\t}\n\n\tcmd->base.duplex = netif_carrier_ok(netdev) ?\n\t\tDUPLEX_FULL : DUPLEX_UNKNOWN;\n\tcmd->base.phy_address = adapter->port_num;\n\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\n\t\t\t\t\t\tsupported);\n\tethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\n\t\t\t\t\t\tadvertising);\n\n\treturn 0;\n}\n\nstatic void be_get_ringparam(struct net_device *netdev,\n\t\t\t     struct ethtool_ringparam *ring,\n\t\t\t     struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\n\tring->rx_max_pending = adapter->rx_obj[0].q.len;\n\tring->rx_pending = adapter->rx_obj[0].q.len;\n\tring->tx_max_pending = adapter->tx_obj[0].q.len;\n\tring->tx_pending = adapter->tx_obj[0].q.len;\n}\n\nstatic void\nbe_get_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *ecmd)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\n\tbe_cmd_get_flow_control(adapter, &ecmd->tx_pause, &ecmd->rx_pause);\n\tecmd->autoneg = adapter->phy.fc_autoneg;\n}\n\nstatic int\nbe_set_pauseparam(struct net_device *netdev, struct ethtool_pauseparam *ecmd)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\tint status;\n\n\tif (ecmd->autoneg != adapter->phy.fc_autoneg)\n\t\treturn -EINVAL;\n\n\tstatus = be_cmd_set_flow_control(adapter, ecmd->tx_pause,\n\t\t\t\t\t ecmd->rx_pause);\n\tif (status) {\n\t\tdev_warn(&adapter->pdev->dev, \"Pause param set failed\\n\");\n\t\treturn be_cmd_status(status);\n\t}\n\n\tadapter->tx_fc = ecmd->tx_pause;\n\tadapter->rx_fc = ecmd->rx_pause;\n\treturn 0;\n}\n\nstatic int be_set_phys_id(struct net_device *netdev,\n\t\t\t  enum ethtool_phys_id_state state)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\tint status = 0;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\tstatus = be_cmd_get_beacon_state(adapter, adapter->hba_port_num,\n\t\t\t\t\t\t &adapter->beacon_state);\n\t\tif (status)\n\t\t\treturn be_cmd_status(status);\n\t\treturn 1;        \n\n\tcase ETHTOOL_ID_ON:\n\t\tstatus = be_cmd_set_beacon_state(adapter, adapter->hba_port_num,\n\t\t\t\t\t\t 0, 0, BEACON_STATE_ENABLED);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_OFF:\n\t\tstatus = be_cmd_set_beacon_state(adapter, adapter->hba_port_num,\n\t\t\t\t\t\t 0, 0, BEACON_STATE_DISABLED);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_INACTIVE:\n\t\tstatus = be_cmd_set_beacon_state(adapter, adapter->hba_port_num,\n\t\t\t\t\t\t 0, 0, adapter->beacon_state);\n\t}\n\n\treturn be_cmd_status(status);\n}\n\nstatic int be_set_dump(struct net_device *netdev, struct ethtool_dump *dump)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\tstruct device *dev = &adapter->pdev->dev;\n\tint status;\n\n\tif (!lancer_chip(adapter) ||\n\t    !check_privilege(adapter, MAX_PRIVILEGES))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (dump->flag) {\n\tcase LANCER_INITIATE_FW_DUMP:\n\t\tstatus = lancer_initiate_dump(adapter);\n\t\tif (!status)\n\t\t\tdev_info(dev, \"FW dump initiated successfully\\n\");\n\t\tbreak;\n\tcase LANCER_DELETE_FW_DUMP:\n\t\tstatus = lancer_delete_dump(adapter);\n\t\tif (!status)\n\t\t\tdev_info(dev, \"FW dump deleted successfully\\n\");\n\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Invalid dump level: 0x%x\\n\", dump->flag);\n\t\treturn -EINVAL;\n\t}\n\treturn status;\n}\n\nstatic void be_get_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\n\tif (adapter->wol_cap & BE_WOL_CAP) {\n\t\twol->supported |= WAKE_MAGIC;\n\t\tif (adapter->wol_en)\n\t\t\twol->wolopts |= WAKE_MAGIC;\n\t} else {\n\t\twol->wolopts = 0;\n\t}\n\tmemset(&wol->sopass, 0, sizeof(wol->sopass));\n}\n\nstatic int be_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\tstruct device *dev = &adapter->pdev->dev;\n\tstruct be_dma_mem cmd;\n\tu8 mac[ETH_ALEN];\n\tbool enable;\n\tint status;\n\n\tif (wol->wolopts & ~WAKE_MAGIC)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!(adapter->wol_cap & BE_WOL_CAP)) {\n\t\tdev_warn(&adapter->pdev->dev, \"WOL not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tcmd.size = sizeof(struct be_cmd_req_acpi_wol_magic_config);\n\tcmd.va = dma_alloc_coherent(dev, cmd.size, &cmd.dma, GFP_KERNEL);\n\tif (!cmd.va)\n\t\treturn -ENOMEM;\n\n\teth_zero_addr(mac);\n\n\tenable = wol->wolopts & WAKE_MAGIC;\n\tif (enable)\n\t\tether_addr_copy(mac, adapter->netdev->dev_addr);\n\n\tstatus = be_cmd_enable_magic_wol(adapter, mac, &cmd);\n\tif (status) {\n\t\tdev_err(dev, \"Could not set Wake-on-lan mac address\\n\");\n\t\tstatus = be_cmd_status(status);\n\t\tgoto err;\n\t}\n\n\tpci_enable_wake(adapter->pdev, PCI_D3hot, enable);\n\tpci_enable_wake(adapter->pdev, PCI_D3cold, enable);\n\n\tadapter->wol_en = enable ? true : false;\n\nerr:\n\tdma_free_coherent(dev, cmd.size, cmd.va, cmd.dma);\n\treturn status;\n}\n\nstatic int be_test_ddr_dma(struct be_adapter *adapter)\n{\n\tint ret, i;\n\tstruct be_dma_mem ddrdma_cmd;\n\tstatic const u64 pattern[2] = {\n\t\t0x5a5a5a5a5a5a5a5aULL, 0xa5a5a5a5a5a5a5a5ULL\n\t};\n\n\tddrdma_cmd.size = sizeof(struct be_cmd_req_ddrdma_test);\n\tddrdma_cmd.va = dma_alloc_coherent(&adapter->pdev->dev,\n\t\t\t\t\t   ddrdma_cmd.size, &ddrdma_cmd.dma,\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!ddrdma_cmd.va)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tret = be_cmd_ddr_dma_test(adapter, pattern[i],\n\t\t\t\t\t  4096, &ddrdma_cmd);\n\t\tif (ret != 0)\n\t\t\tgoto err;\n\t}\n\nerr:\n\tdma_free_coherent(&adapter->pdev->dev, ddrdma_cmd.size, ddrdma_cmd.va,\n\t\t\t  ddrdma_cmd.dma);\n\treturn be_cmd_status(ret);\n}\n\nstatic u64 be_loopback_test(struct be_adapter *adapter, u8 loopback_type,\n\t\t\t    u64 *status)\n{\n\tint ret;\n\n\tret = be_cmd_set_loopback(adapter, adapter->hba_port_num,\n\t\t\t\t  loopback_type, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t*status = be_cmd_loopback_test(adapter, adapter->hba_port_num,\n\t\t\t\t       loopback_type, 1500, 2, 0xabc);\n\n\tret = be_cmd_set_loopback(adapter, adapter->hba_port_num,\n\t\t\t\t  BE_NO_LOOPBACK, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn *status;\n}\n\nstatic void be_self_test(struct net_device *netdev, struct ethtool_test *test,\n\t\t\t u64 *data)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\tint status, cnt;\n\tu8 link_status = 0;\n\n\tif (adapter->function_caps & BE_FUNCTION_CAPS_SUPER_NIC) {\n\t\tdev_err(&adapter->pdev->dev, \"Self test not supported\\n\");\n\t\ttest->flags |= ETH_TEST_FL_FAILED;\n\t\treturn;\n\t}\n\n\tmemset(data, 0, sizeof(u64) * ETHTOOL_TESTS_NUM);\n\n\t \n\tlink_status = netif_carrier_ok(netdev);\n\n\tif (test->flags & ETH_TEST_FL_OFFLINE) {\n\t\tif (be_loopback_test(adapter, BE_MAC_LOOPBACK, &data[0]) != 0)\n\t\t\ttest->flags |= ETH_TEST_FL_FAILED;\n\n\t\tif (be_loopback_test(adapter, BE_PHY_LOOPBACK, &data[1]) != 0)\n\t\t\ttest->flags |= ETH_TEST_FL_FAILED;\n\n\t\tif (test->flags & ETH_TEST_FL_EXTERNAL_LB) {\n\t\t\tif (be_loopback_test(adapter, BE_ONE_PORT_EXT_LOOPBACK,\n\t\t\t\t\t     &data[2]) != 0)\n\t\t\t\ttest->flags |= ETH_TEST_FL_FAILED;\n\t\t\ttest->flags |= ETH_TEST_FL_EXTERNAL_LB_DONE;\n\t\t}\n\t}\n\n\tif (!lancer_chip(adapter) && be_test_ddr_dma(adapter) != 0) {\n\t\tdata[3] = 1;\n\t\ttest->flags |= ETH_TEST_FL_FAILED;\n\t}\n\n\t \n\tif (!link_status) {\n\t\ttest->flags |= ETH_TEST_FL_FAILED;\n\t\tdata[4] = 1;\n\t\treturn;\n\t}\n\n\tfor (cnt = 10; cnt; cnt--) {\n\t\tstatus = be_cmd_link_status_query(adapter, NULL, &link_status,\n\t\t\t\t\t\t  0);\n\t\tif (status) {\n\t\t\ttest->flags |= ETH_TEST_FL_FAILED;\n\t\t\tdata[4] = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (link_status)\n\t\t\tbreak;\n\n\t\tmsleep_interruptible(500);\n\t}\n}\n\nstatic int be_do_flash(struct net_device *netdev, struct ethtool_flash *efl)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\n\treturn be_load_fw(adapter, efl->data);\n}\n\nstatic int\nbe_get_dump_flag(struct net_device *netdev, struct ethtool_dump *dump)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\n\tif (!check_privilege(adapter, MAX_PRIVILEGES))\n\t\treturn -EOPNOTSUPP;\n\n\tdump->len = be_get_dump_len(adapter);\n\tdump->version = 1;\n\tdump->flag = 0x1;\t \n\treturn 0;\n}\n\nstatic int\nbe_get_dump_data(struct net_device *netdev, struct ethtool_dump *dump,\n\t\t void *buf)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\tint status;\n\n\tif (!check_privilege(adapter, MAX_PRIVILEGES))\n\t\treturn -EOPNOTSUPP;\n\n\tstatus = be_read_dump_data(adapter, dump->len, buf);\n\treturn be_cmd_status(status);\n}\n\nstatic int be_get_eeprom_len(struct net_device *netdev)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\n\tif (!check_privilege(adapter, MAX_PRIVILEGES))\n\t\treturn 0;\n\n\tif (lancer_chip(adapter)) {\n\t\tif (be_physfn(adapter))\n\t\t\treturn lancer_cmd_get_file_len(adapter,\n\t\t\t\t\t\t       LANCER_VPD_PF_FILE);\n\t\telse\n\t\t\treturn lancer_cmd_get_file_len(adapter,\n\t\t\t\t\t\t       LANCER_VPD_VF_FILE);\n\t} else {\n\t\treturn BE_READ_SEEPROM_LEN;\n\t}\n}\n\nstatic int be_read_eeprom(struct net_device *netdev,\n\t\t\t  struct ethtool_eeprom *eeprom, uint8_t *data)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\tstruct be_dma_mem eeprom_cmd;\n\tstruct be_cmd_resp_seeprom_read *resp;\n\tint status;\n\n\tif (!eeprom->len)\n\t\treturn -EINVAL;\n\n\tif (lancer_chip(adapter)) {\n\t\tif (be_physfn(adapter))\n\t\t\treturn lancer_cmd_read_file(adapter, LANCER_VPD_PF_FILE,\n\t\t\t\t\t\t    eeprom->len, data);\n\t\telse\n\t\t\treturn lancer_cmd_read_file(adapter, LANCER_VPD_VF_FILE,\n\t\t\t\t\t\t    eeprom->len, data);\n\t}\n\n\teeprom->magic = BE_VENDOR_ID | (adapter->pdev->device<<16);\n\n\tmemset(&eeprom_cmd, 0, sizeof(struct be_dma_mem));\n\teeprom_cmd.size = sizeof(struct be_cmd_req_seeprom_read);\n\teeprom_cmd.va = dma_alloc_coherent(&adapter->pdev->dev,\n\t\t\t\t\t   eeprom_cmd.size, &eeprom_cmd.dma,\n\t\t\t\t\t   GFP_KERNEL);\n\n\tif (!eeprom_cmd.va)\n\t\treturn -ENOMEM;\n\n\tstatus = be_cmd_get_seeprom_data(adapter, &eeprom_cmd);\n\n\tif (!status) {\n\t\tresp = eeprom_cmd.va;\n\t\tmemcpy(data, resp->seeprom_data + eeprom->offset, eeprom->len);\n\t}\n\tdma_free_coherent(&adapter->pdev->dev, eeprom_cmd.size, eeprom_cmd.va,\n\t\t\t  eeprom_cmd.dma);\n\n\treturn be_cmd_status(status);\n}\n\nstatic u32 be_get_msg_level(struct net_device *netdev)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\n\treturn adapter->msg_enable;\n}\n\nstatic void be_set_msg_level(struct net_device *netdev, u32 level)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\n\tif (adapter->msg_enable == level)\n\t\treturn;\n\n\tif ((level & NETIF_MSG_HW) != (adapter->msg_enable & NETIF_MSG_HW))\n\t\tif (BEx_chip(adapter))\n\t\t\tbe_cmd_set_fw_log_level(adapter, level & NETIF_MSG_HW ?\n\t\t\t\t\t\tFW_LOG_LEVEL_DEFAULT :\n\t\t\t\t\t\tFW_LOG_LEVEL_FATAL);\n\tadapter->msg_enable = level;\n}\n\nstatic u64 be_get_rss_hash_opts(struct be_adapter *adapter, u64 flow_type)\n{\n\tu64 data = 0;\n\n\tswitch (flow_type) {\n\tcase TCP_V4_FLOW:\n\t\tif (adapter->rss_info.rss_flags & RSS_ENABLE_IPV4)\n\t\t\tdata |= RXH_IP_DST | RXH_IP_SRC;\n\t\tif (adapter->rss_info.rss_flags & RSS_ENABLE_TCP_IPV4)\n\t\t\tdata |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\tif (adapter->rss_info.rss_flags & RSS_ENABLE_IPV4)\n\t\t\tdata |= RXH_IP_DST | RXH_IP_SRC;\n\t\tif (adapter->rss_info.rss_flags & RSS_ENABLE_UDP_IPV4)\n\t\t\tdata |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\t\tif (adapter->rss_info.rss_flags & RSS_ENABLE_IPV6)\n\t\t\tdata |= RXH_IP_DST | RXH_IP_SRC;\n\t\tif (adapter->rss_info.rss_flags & RSS_ENABLE_TCP_IPV6)\n\t\t\tdata |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\tif (adapter->rss_info.rss_flags & RSS_ENABLE_IPV6)\n\t\t\tdata |= RXH_IP_DST | RXH_IP_SRC;\n\t\tif (adapter->rss_info.rss_flags & RSS_ENABLE_UDP_IPV6)\n\t\t\tdata |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tbreak;\n\t}\n\n\treturn data;\n}\n\nstatic int be_get_rxnfc(struct net_device *netdev, struct ethtool_rxnfc *cmd,\n\t\t\tu32 *rule_locs)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\n\tif (!be_multi_rxq(adapter)) {\n\t\tdev_info(&adapter->pdev->dev,\n\t\t\t \"ethtool::get_rxnfc: RX flow hashing is disabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_GRXFH:\n\t\tcmd->data = be_get_rss_hash_opts(adapter, cmd->flow_type);\n\t\tbreak;\n\tcase ETHTOOL_GRXRINGS:\n\t\tcmd->data = adapter->num_rx_qs;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int be_set_rss_hash_opts(struct be_adapter *adapter,\n\t\t\t\tstruct ethtool_rxnfc *cmd)\n{\n\tint status;\n\tu32 rss_flags = adapter->rss_info.rss_flags;\n\n\tif (cmd->data != L3_RSS_FLAGS &&\n\t    cmd->data != (L3_RSS_FLAGS | L4_RSS_FLAGS))\n\t\treturn -EINVAL;\n\n\tswitch (cmd->flow_type) {\n\tcase TCP_V4_FLOW:\n\t\tif (cmd->data == L3_RSS_FLAGS)\n\t\t\trss_flags &= ~RSS_ENABLE_TCP_IPV4;\n\t\telse if (cmd->data == (L3_RSS_FLAGS | L4_RSS_FLAGS))\n\t\t\trss_flags |= RSS_ENABLE_IPV4 |\n\t\t\t\t\tRSS_ENABLE_TCP_IPV4;\n\t\tbreak;\n\tcase TCP_V6_FLOW:\n\t\tif (cmd->data == L3_RSS_FLAGS)\n\t\t\trss_flags &= ~RSS_ENABLE_TCP_IPV6;\n\t\telse if (cmd->data == (L3_RSS_FLAGS | L4_RSS_FLAGS))\n\t\t\trss_flags |= RSS_ENABLE_IPV6 |\n\t\t\t\t\tRSS_ENABLE_TCP_IPV6;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\tif ((cmd->data == (L3_RSS_FLAGS | L4_RSS_FLAGS)) &&\n\t\t    BEx_chip(adapter))\n\t\t\treturn -EINVAL;\n\n\t\tif (cmd->data == L3_RSS_FLAGS)\n\t\t\trss_flags &= ~RSS_ENABLE_UDP_IPV4;\n\t\telse if (cmd->data == (L3_RSS_FLAGS | L4_RSS_FLAGS))\n\t\t\trss_flags |= RSS_ENABLE_IPV4 |\n\t\t\t\t\tRSS_ENABLE_UDP_IPV4;\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\tif ((cmd->data == (L3_RSS_FLAGS | L4_RSS_FLAGS)) &&\n\t\t    BEx_chip(adapter))\n\t\t\treturn -EINVAL;\n\n\t\tif (cmd->data == L3_RSS_FLAGS)\n\t\t\trss_flags &= ~RSS_ENABLE_UDP_IPV6;\n\t\telse if (cmd->data == (L3_RSS_FLAGS | L4_RSS_FLAGS))\n\t\t\trss_flags |= RSS_ENABLE_IPV6 |\n\t\t\t\t\tRSS_ENABLE_UDP_IPV6;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (rss_flags == adapter->rss_info.rss_flags)\n\t\treturn 0;\n\n\tstatus = be_cmd_rss_config(adapter, adapter->rss_info.rsstable,\n\t\t\t\t   rss_flags, RSS_INDIR_TABLE_LEN,\n\t\t\t\t   adapter->rss_info.rss_hkey);\n\tif (!status)\n\t\tadapter->rss_info.rss_flags = rss_flags;\n\n\treturn be_cmd_status(status);\n}\n\nstatic int be_set_rxnfc(struct net_device *netdev, struct ethtool_rxnfc *cmd)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\tint status = 0;\n\n\tif (!be_multi_rxq(adapter)) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"ethtool::set_rxnfc: RX flow hashing is disabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_SRXFH:\n\t\tstatus = be_set_rss_hash_opts(adapter, cmd);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn status;\n}\n\nstatic void be_get_channels(struct net_device *netdev,\n\t\t\t    struct ethtool_channels *ch)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\tu16 num_rx_irqs = max_t(u16, adapter->num_rss_qs, 1);\n\n\t \n\tch->combined_count = min(adapter->num_tx_qs, num_rx_irqs);\n\tch->rx_count = num_rx_irqs - ch->combined_count;\n\tch->tx_count = adapter->num_tx_qs - ch->combined_count;\n\n\tch->max_combined = be_max_qp_irqs(adapter);\n\t \n\tch->max_rx = be_max_rx_irqs(adapter) - 1;\n\tch->max_tx = be_max_tx_irqs(adapter) - 1;\n}\n\nstatic int be_set_channels(struct net_device  *netdev,\n\t\t\t   struct ethtool_channels *ch)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\tint status;\n\n\t \n\tif (ch->other_count || !ch->combined_count ||\n\t    (ch->rx_count && ch->tx_count))\n\t\treturn -EINVAL;\n\n\tif (ch->combined_count > be_max_qp_irqs(adapter) ||\n\t    (ch->rx_count &&\n\t     (ch->rx_count + ch->combined_count) > be_max_rx_irqs(adapter)) ||\n\t    (ch->tx_count &&\n\t     (ch->tx_count + ch->combined_count) > be_max_tx_irqs(adapter)))\n\t\treturn -EINVAL;\n\n\tadapter->cfg_num_rx_irqs = ch->combined_count + ch->rx_count;\n\tadapter->cfg_num_tx_irqs = ch->combined_count + ch->tx_count;\n\n\tstatus = be_update_queues(adapter);\n\treturn be_cmd_status(status);\n}\n\nstatic u32 be_get_rxfh_indir_size(struct net_device *netdev)\n{\n\treturn RSS_INDIR_TABLE_LEN;\n}\n\nstatic u32 be_get_rxfh_key_size(struct net_device *netdev)\n{\n\treturn RSS_HASH_KEY_LEN;\n}\n\nstatic int be_get_rxfh(struct net_device *netdev, u32 *indir, u8 *hkey,\n\t\t       u8 *hfunc)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\tint i;\n\tstruct rss_info *rss = &adapter->rss_info;\n\n\tif (indir) {\n\t\tfor (i = 0; i < RSS_INDIR_TABLE_LEN; i++)\n\t\t\tindir[i] = rss->rss_queue[i];\n\t}\n\n\tif (hkey)\n\t\tmemcpy(hkey, rss->rss_hkey, RSS_HASH_KEY_LEN);\n\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;\n\n\treturn 0;\n}\n\nstatic int be_set_rxfh(struct net_device *netdev, const u32 *indir,\n\t\t       const u8 *hkey, const u8 hfunc)\n{\n\tint rc = 0, i, j;\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\tu8 rsstable[RSS_INDIR_TABLE_LEN];\n\n\t \n\tif (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP)\n\t\treturn -EOPNOTSUPP;\n\n\tif (indir) {\n\t\tstruct be_rx_obj *rxo;\n\n\t\tfor (i = 0; i < RSS_INDIR_TABLE_LEN; i++) {\n\t\t\tj = indir[i];\n\t\t\trxo = &adapter->rx_obj[j];\n\t\t\trsstable[i] = rxo->rss_id;\n\t\t\tadapter->rss_info.rss_queue[i] = j;\n\t\t}\n\t} else {\n\t\tmemcpy(rsstable, adapter->rss_info.rsstable,\n\t\t       RSS_INDIR_TABLE_LEN);\n\t}\n\n\tif (!hkey)\n\t\thkey =  adapter->rss_info.rss_hkey;\n\n\trc = be_cmd_rss_config(adapter, rsstable,\n\t\t\t       adapter->rss_info.rss_flags,\n\t\t\t       RSS_INDIR_TABLE_LEN, hkey);\n\tif (rc) {\n\t\tadapter->rss_info.rss_flags = RSS_ENABLE_NONE;\n\t\treturn -EIO;\n\t}\n\tmemcpy(adapter->rss_info.rss_hkey, hkey, RSS_HASH_KEY_LEN);\n\tmemcpy(adapter->rss_info.rsstable, rsstable,\n\t       RSS_INDIR_TABLE_LEN);\n\treturn 0;\n}\n\nstatic int be_get_module_info(struct net_device *netdev,\n\t\t\t      struct ethtool_modinfo *modinfo)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\tu8 page_data[PAGE_DATA_LEN];\n\tint status;\n\n\tif (!check_privilege(adapter, MAX_PRIVILEGES))\n\t\treturn -EOPNOTSUPP;\n\n\tstatus = be_cmd_read_port_transceiver_data(adapter, TR_PAGE_A0,\n\t\t\t\t\t\t   0, PAGE_DATA_LEN, page_data);\n\tif (!status) {\n\t\tif (!page_data[SFP_PLUS_SFF_8472_COMP]) {\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8079;\n\t\t\tmodinfo->eeprom_len = PAGE_DATA_LEN;\n\t\t} else {\n\t\t\tmodinfo->type = ETH_MODULE_SFF_8472;\n\t\t\tmodinfo->eeprom_len = 2 * PAGE_DATA_LEN;\n\t\t}\n\t}\n\treturn be_cmd_status(status);\n}\n\nstatic int be_get_module_eeprom(struct net_device *netdev,\n\t\t\t\tstruct ethtool_eeprom *eeprom, u8 *data)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\tint status;\n\tu32 begin, end;\n\n\tif (!check_privilege(adapter, MAX_PRIVILEGES))\n\t\treturn -EOPNOTSUPP;\n\n\tbegin = eeprom->offset;\n\tend = eeprom->offset + eeprom->len;\n\n\tif (begin < PAGE_DATA_LEN) {\n\t\tstatus = be_cmd_read_port_transceiver_data(adapter, TR_PAGE_A0, begin,\n\t\t\t\t\t\t\t   min_t(u32, end, PAGE_DATA_LEN) - begin,\n\t\t\t\t\t\t\t   data);\n\t\tif (status)\n\t\t\tgoto err;\n\n\t\tdata += PAGE_DATA_LEN - begin;\n\t\tbegin = PAGE_DATA_LEN;\n\t}\n\n\tif (end > PAGE_DATA_LEN) {\n\t\tstatus = be_cmd_read_port_transceiver_data(adapter, TR_PAGE_A2,\n\t\t\t\t\t\t\t   begin - PAGE_DATA_LEN,\n\t\t\t\t\t\t\t   end - begin, data);\n\t\tif (status)\n\t\t\tgoto err;\n\t}\nerr:\n\treturn be_cmd_status(status);\n}\n\nstatic u32 be_get_priv_flags(struct net_device *netdev)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\n\treturn adapter->priv_flags;\n}\n\nstatic int be_set_priv_flags(struct net_device *netdev, u32 flags)\n{\n\tstruct be_adapter *adapter = netdev_priv(netdev);\n\tbool tpe_old = !!(adapter->priv_flags & BE_DISABLE_TPE_RECOVERY);\n\tbool tpe_new = !!(flags & BE_DISABLE_TPE_RECOVERY);\n\n\tif (tpe_old != tpe_new) {\n\t\tif (tpe_new) {\n\t\t\tadapter->priv_flags |= BE_DISABLE_TPE_RECOVERY;\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t \"HW error recovery is disabled\\n\");\n\t\t} else {\n\t\t\tadapter->priv_flags &= ~BE_DISABLE_TPE_RECOVERY;\n\t\t\tdev_info(&adapter->pdev->dev,\n\t\t\t\t \"HW error recovery is enabled\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nconst struct ethtool_ops be_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_USE_ADAPTIVE |\n\t\t\t\t     ETHTOOL_COALESCE_USECS_LOW_HIGH,\n\t.get_drvinfo = be_get_drvinfo,\n\t.get_wol = be_get_wol,\n\t.set_wol = be_set_wol,\n\t.get_link = ethtool_op_get_link,\n\t.get_eeprom_len = be_get_eeprom_len,\n\t.get_eeprom = be_read_eeprom,\n\t.get_coalesce = be_get_coalesce,\n\t.set_coalesce = be_set_coalesce,\n\t.get_ringparam = be_get_ringparam,\n\t.get_pauseparam = be_get_pauseparam,\n\t.set_pauseparam = be_set_pauseparam,\n\t.set_priv_flags = be_set_priv_flags,\n\t.get_priv_flags = be_get_priv_flags,\n\t.get_strings = be_get_stat_strings,\n\t.set_phys_id = be_set_phys_id,\n\t.set_dump = be_set_dump,\n\t.get_msglevel = be_get_msg_level,\n\t.set_msglevel = be_set_msg_level,\n\t.get_sset_count = be_get_sset_count,\n\t.get_ethtool_stats = be_get_ethtool_stats,\n\t.flash_device = be_do_flash,\n\t.self_test = be_self_test,\n\t.get_rxnfc = be_get_rxnfc,\n\t.set_rxnfc = be_set_rxnfc,\n\t.get_rxfh_indir_size = be_get_rxfh_indir_size,\n\t.get_rxfh_key_size = be_get_rxfh_key_size,\n\t.get_rxfh = be_get_rxfh,\n\t.set_rxfh = be_set_rxfh,\n\t.get_dump_flag = be_get_dump_flag,\n\t.get_dump_data = be_get_dump_data,\n\t.get_channels = be_get_channels,\n\t.set_channels = be_set_channels,\n\t.get_module_info = be_get_module_info,\n\t.get_module_eeprom = be_get_module_eeprom,\n\t.get_link_ksettings = be_get_link_ksettings,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}