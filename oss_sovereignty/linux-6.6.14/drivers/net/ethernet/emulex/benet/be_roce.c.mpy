{
  "module_name": "be_roce.c",
  "hash_id": "039680d8e1d6132524b1c758d2633264944de25ef294bf734393c27ec6a9f9ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/emulex/benet/be_roce.c",
  "human_readable_source": "\n \n\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/netdevice.h>\n#include <linux/module.h>\n\n#include \"be.h\"\n#include \"be_cmds.h\"\n\nstatic struct ocrdma_driver *ocrdma_drv;\nstatic LIST_HEAD(be_adapter_list);\nstatic DEFINE_MUTEX(be_adapter_list_lock);\n\nstatic void _be_roce_dev_add(struct be_adapter *adapter)\n{\n\tstruct be_dev_info dev_info;\n\tint i, num_vec;\n\tstruct pci_dev *pdev = adapter->pdev;\n\n\tif (!ocrdma_drv)\n\t\treturn;\n\n\tif (ocrdma_drv->be_abi_version != BE_ROCE_ABI_VERSION) {\n\t\tdev_warn(&pdev->dev, \"Cannot initialize RoCE due to ocrdma ABI mismatch\\n\");\n\t\treturn;\n\t}\n\n\tif (pdev->device == OC_DEVICE_ID5) {\n\t\t \n\t\tif (!msix_enabled(adapter))\n\t\t\treturn;\n\t\t \n\t\tdev_info.dpp_unmapped_addr = pci_resource_start(pdev, 2);\n\t\tdev_info.dpp_unmapped_len = pci_resource_len(pdev, 2);\n\t} else {\n\t\tdev_info.dpp_unmapped_addr = 0;\n\t\tdev_info.dpp_unmapped_len = 0;\n\t}\n\tdev_info.pdev = adapter->pdev;\n\tdev_info.db = adapter->db;\n\tdev_info.unmapped_db = adapter->roce_db.io_addr;\n\tdev_info.db_page_size = adapter->roce_db.size;\n\tdev_info.db_total_size = adapter->roce_db.total_size;\n\tdev_info.netdev = adapter->netdev;\n\tmemcpy(dev_info.mac_addr, adapter->netdev->dev_addr, ETH_ALEN);\n\tdev_info.dev_family = adapter->sli_family;\n\tif (msix_enabled(adapter)) {\n\t\t \n\t\tnum_vec = adapter->num_msix_vec + adapter->num_msix_roce_vec;\n\t\tdev_info.intr_mode = BE_INTERRUPT_MODE_MSIX;\n\t\tdev_info.msix.num_vectors = min(num_vec, MAX_MSIX_VECTORS);\n\t\t \n\t\tdev_info.msix.start_vector = adapter->num_evt_qs;\n\t\tfor (i = 0; i < dev_info.msix.num_vectors; i++) {\n\t\t\tdev_info.msix.vector_list[i] =\n\t\t\t    adapter->msix_entries[i].vector;\n\t\t}\n\t} else {\n\t\tdev_info.msix.num_vectors = 0;\n\t\tdev_info.intr_mode = BE_INTERRUPT_MODE_INTX;\n\t}\n\tadapter->ocrdma_dev = ocrdma_drv->add(&dev_info);\n}\n\nvoid be_roce_dev_add(struct be_adapter *adapter)\n{\n\tif (be_roce_supported(adapter)) {\n\t\tINIT_LIST_HEAD(&adapter->entry);\n\t\tmutex_lock(&be_adapter_list_lock);\n\t\tlist_add_tail(&adapter->entry, &be_adapter_list);\n\n\t\t \n\t\t_be_roce_dev_add(adapter);\n\t\tmutex_unlock(&be_adapter_list_lock);\n\t}\n}\n\nstatic void _be_roce_dev_remove(struct be_adapter *adapter)\n{\n\tif (ocrdma_drv && ocrdma_drv->remove && adapter->ocrdma_dev)\n\t\tocrdma_drv->remove(adapter->ocrdma_dev);\n\tadapter->ocrdma_dev = NULL;\n}\n\nvoid be_roce_dev_remove(struct be_adapter *adapter)\n{\n\tif (be_roce_supported(adapter)) {\n\t\tmutex_lock(&be_adapter_list_lock);\n\t\t_be_roce_dev_remove(adapter);\n\t\tlist_del(&adapter->entry);\n\t\tmutex_unlock(&be_adapter_list_lock);\n\t}\n}\n\nvoid be_roce_dev_shutdown(struct be_adapter *adapter)\n{\n\tif (be_roce_supported(adapter)) {\n\t\tmutex_lock(&be_adapter_list_lock);\n\t\tif (ocrdma_drv && adapter->ocrdma_dev &&\n\t\t    ocrdma_drv->state_change_handler)\n\t\t\tocrdma_drv->state_change_handler(adapter->ocrdma_dev,\n\t\t\t\t\t\t\t BE_DEV_SHUTDOWN);\n\t\tmutex_unlock(&be_adapter_list_lock);\n\t}\n}\n\nint be_roce_register_driver(struct ocrdma_driver *drv)\n{\n\tstruct be_adapter *dev;\n\n\tmutex_lock(&be_adapter_list_lock);\n\tif (ocrdma_drv) {\n\t\tmutex_unlock(&be_adapter_list_lock);\n\t\treturn -EINVAL;\n\t}\n\tocrdma_drv = drv;\n\tlist_for_each_entry(dev, &be_adapter_list, entry) {\n\t\t_be_roce_dev_add(dev);\n\t}\n\tmutex_unlock(&be_adapter_list_lock);\n\treturn 0;\n}\nEXPORT_SYMBOL(be_roce_register_driver);\n\nvoid be_roce_unregister_driver(struct ocrdma_driver *drv)\n{\n\tstruct be_adapter *dev;\n\n\tmutex_lock(&be_adapter_list_lock);\n\tlist_for_each_entry(dev, &be_adapter_list, entry) {\n\t\tif (dev->ocrdma_dev)\n\t\t\t_be_roce_dev_remove(dev);\n\t}\n\tocrdma_drv = NULL;\n\tmutex_unlock(&be_adapter_list_lock);\n}\nEXPORT_SYMBOL(be_roce_unregister_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}