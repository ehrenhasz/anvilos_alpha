{
  "module_name": "be.h",
  "hash_id": "e349384adceb4771b9eda4756a636e7d2ea8e8d7d7e7e0f088d747d7f6f18c74",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/emulex/benet/be.h",
  "human_readable_source": " \n \n\n#ifndef BE_H\n#define BE_H\n\n#include <linux/pci.h>\n#include <linux/etherdevice.h>\n#include <linux/delay.h>\n#include <net/tcp.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <linux/if_vlan.h>\n#include <linux/workqueue.h>\n#include <linux/interrupt.h>\n#include <linux/firmware.h>\n#include <linux/slab.h>\n#include <linux/u64_stats_sync.h>\n#include <linux/cpumask.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n\n#include \"be_hw.h\"\n#include \"be_roce.h\"\n\n#define DRV_NAME\t\t\"be2net\"\n#define BE_NAME\t\t\t\"Emulex BladeEngine2\"\n#define BE3_NAME\t\t\"Emulex BladeEngine3\"\n#define OC_NAME\t\t\t\"Emulex OneConnect\"\n#define OC_NAME_BE\t\tOC_NAME\t\"(be3)\"\n#define OC_NAME_LANCER\t\tOC_NAME \"(Lancer)\"\n#define OC_NAME_SH\t\tOC_NAME \"(Skyhawk)\"\n#define DRV_DESC\t\t\"Emulex OneConnect NIC Driver\"\n\n#define BE_VENDOR_ID \t\t0x19a2\n#define EMULEX_VENDOR_ID\t0x10df\n#define BE_DEVICE_ID1\t\t0x211\n#define BE_DEVICE_ID2\t\t0x221\n#define OC_DEVICE_ID1\t\t0x700\t \n#define OC_DEVICE_ID2\t\t0x710\t \n#define OC_DEVICE_ID3\t\t0xe220\t \n#define OC_DEVICE_ID4           0xe228    \n#define OC_DEVICE_ID5\t\t0x720\t \n#define OC_DEVICE_ID6\t\t0x728    \n#define OC_SUBSYS_DEVICE_ID1\t0xE602\n#define OC_SUBSYS_DEVICE_ID2\t0xE642\n#define OC_SUBSYS_DEVICE_ID3\t0xE612\n#define OC_SUBSYS_DEVICE_ID4\t0xE652\n\n \n#define BE_HDR_LEN\t\t((u16) 64)\n \n#define BE_RX_SKB_ALLOC_SIZE\t256\n\n#define BE_MAX_JUMBO_FRAME_SIZE\t9018\n#define BE_MIN_MTU\t\t256\n#define BE_MAX_MTU              (BE_MAX_JUMBO_FRAME_SIZE -\t\\\n\t\t\t\t (ETH_HLEN + ETH_FCS_LEN))\n\n \n#define BE_MAX_GSO_SIZE\t\t(65535 - 2 * VLAN_HLEN)\n\n#define BE_NUM_VLANS_SUPPORTED\t64\n#define BE_MAX_EQD\t\t128u\n#define\tBE_MAX_TX_FRAG_COUNT\t30\n\n#define EVNT_Q_LEN\t\t1024\n#define TX_Q_LEN\t\t2048\n#define TX_CQ_LEN\t\t1024\n#define RX_Q_LEN\t\t1024\t \n#define RX_CQ_LEN\t\t1024\n#define MCC_Q_LEN\t\t128\t \n#define MCC_CQ_LEN\t\t256\n\n#define BE2_MAX_RSS_QS\t\t4\n#define BE3_MAX_RSS_QS\t\t16\n#define BE3_MAX_TX_QS\t\t16\n#define BE3_MAX_EVT_QS\t\t16\n#define BE3_SRIOV_MAX_EVT_QS\t8\n#define SH_VF_MAX_NIC_EQS\t3\t \n\n#define MAX_PORT_RSS_TABLES\t15\n#define MAX_NIC_FUNCS\t\t16\n#define MAX_RX_QS\t\t32\n#define MAX_EVT_QS\t\t32\n#define MAX_TX_QS\t\t32\n\n#define MAX_ROCE_EQS\t\t5\n#define MAX_MSIX_VECTORS\t32\n#define MIN_MSIX_VECTORS\t1\n#define MAX_RX_POST\t\tNAPI_POLL_WEIGHT  \n#define RX_FRAGS_REFILL_WM\t(RX_Q_LEN - MAX_RX_POST)\n#define MAX_NUM_POST_ERX_DB\t255u\n\n#define MAX_VFS\t\t\t30  \n#define FW_VER_LEN\t\t32\n#define\tCNTL_SERIAL_NUM_WORDS\t8   \n#define\tCNTL_SERIAL_NUM_WORD_SZ\t(sizeof(u16))  \n\n#define\tRSS_INDIR_TABLE_LEN\t128\n#define RSS_HASH_KEY_LEN\t40\n\n#define BE_UNKNOWN_PHY_STATE\t0xFF\n\nstruct be_dma_mem {\n\tvoid *va;\n\tdma_addr_t dma;\n\tu32 size;\n};\n\nstruct be_queue_info {\n\tu32 len;\n\tu32 entry_size;\t \n\tu32 tail, head;\n\tatomic_t used;\t \n\tu32 id;\n\tstruct be_dma_mem dma_mem;\n\tbool created;\n};\n\nstatic inline u32 MODULO(u32 val, u32 limit)\n{\n\tBUG_ON(limit & (limit - 1));\n\treturn val & (limit - 1);\n}\n\nstatic inline void index_adv(u32 *index, u32 val, u32 limit)\n{\n\t*index = MODULO((*index + val), limit);\n}\n\nstatic inline void index_inc(u32 *index, u32 limit)\n{\n\t*index = MODULO((*index + 1), limit);\n}\n\nstatic inline void *queue_head_node(struct be_queue_info *q)\n{\n\treturn q->dma_mem.va + q->head * q->entry_size;\n}\n\nstatic inline void *queue_tail_node(struct be_queue_info *q)\n{\n\treturn q->dma_mem.va + q->tail * q->entry_size;\n}\n\nstatic inline void *queue_index_node(struct be_queue_info *q, u16 index)\n{\n\treturn q->dma_mem.va + index * q->entry_size;\n}\n\nstatic inline void queue_head_inc(struct be_queue_info *q)\n{\n\tindex_inc(&q->head, q->len);\n}\n\nstatic inline void index_dec(u32 *index, u32 limit)\n{\n\t*index = MODULO((*index - 1), limit);\n}\n\nstatic inline void queue_tail_inc(struct be_queue_info *q)\n{\n\tindex_inc(&q->tail, q->len);\n}\n\nstruct be_eq_obj {\n\tstruct be_queue_info q;\n\tchar desc[32];\n\n\tstruct be_adapter *adapter;\n\tstruct napi_struct napi;\n\tu8 idx;\t\t\t \n\tu8 msix_idx;\n\tu16 spurious_intr;\n\tcpumask_var_t  affinity_mask;\n} ____cacheline_aligned_in_smp;\n\nstruct be_aic_obj {\t\t \n\tu32 min_eqd;\t\t \n\tu32 max_eqd;\t\t \n\tu32 prev_eqd;\t\t \n\tu32 et_eqd;\t\t \n\tulong jiffies;\n\tu64 rx_pkts_prev;\t \n\tu64 tx_reqs_prev;\t \n};\n\nstruct be_mcc_obj {\n\tstruct be_queue_info q;\n\tstruct be_queue_info cq;\n\tbool rearm_cq;\n};\n\nstruct be_tx_stats {\n\tu64 tx_bytes;\n\tu64 tx_pkts;\n\tu64 tx_vxlan_offload_pkts;\n\tu64 tx_reqs;\n\tu64 tx_compl;\n\tu32 tx_stops;\n\tu32 tx_drv_drops;\t \n\t \n\tu32 tx_hdr_parse_err;\n\tu32 tx_dma_err;\n\tu32 tx_tso_err;\n\tu32 tx_spoof_check_err;\n\tu32 tx_qinq_err;\n\tu32 tx_internal_parity_err;\n\tu32 tx_sge_err;\n\tstruct u64_stats_sync sync;\n\tstruct u64_stats_sync sync_compl;\n};\n\n \nstruct be_tx_compl_info {\n\tu8 status;\t\t \n\tu16 end_index;\t\t \n};\n\nstruct be_tx_obj {\n\tu32 db_offset;\n\tstruct be_tx_compl_info txcp;\n\tstruct be_queue_info q;\n\tstruct be_queue_info cq;\n\t \n\tstruct sk_buff *sent_skb_list[TX_Q_LEN];\n\tstruct be_tx_stats stats;\n\tu16 pend_wrb_cnt;\t \n\tu16 last_req_wrb_cnt;\t \n\tu16 last_req_hdr;\t \n} ____cacheline_aligned_in_smp;\n\n \nstruct be_rx_page_info {\n\tstruct page *page;\n\t \n\tDEFINE_DMA_UNMAP_ADDR(bus);\n\tu16 page_offset;\n\tbool last_frag;\t\t \n};\n\nstruct be_rx_stats {\n\tu64 rx_bytes;\n\tu64 rx_pkts;\n\tu64 rx_vxlan_offload_pkts;\n\tu32 rx_drops_no_skbs;\t \n\tu32 rx_drops_no_frags;\t \n\tu32 rx_post_fail;\t \n\tu32 rx_compl;\n\tu32 rx_mcast_pkts;\n\tu32 rx_compl_err;\t \n\tstruct u64_stats_sync sync;\n};\n\nstruct be_rx_compl_info {\n\tu32 rss_hash;\n\tu16 vlan_tag;\n\tu16 pkt_size;\n\tu16 port;\n\tu8 vlanf;\n\tu8 num_rcvd;\n\tu8 err;\n\tu8 ipf;\n\tu8 tcpf;\n\tu8 udpf;\n\tu8 ip_csum;\n\tu8 l4_csum;\n\tu8 ipv6;\n\tu8 qnq;\n\tu8 pkt_type;\n\tu8 ip_frag;\n\tu8 tunneled;\n};\n\nstruct be_rx_obj {\n\tstruct be_adapter *adapter;\n\tstruct be_queue_info q;\n\tstruct be_queue_info cq;\n\tstruct be_rx_compl_info rxcp;\n\tstruct be_rx_page_info page_info_tbl[RX_Q_LEN];\n\tstruct be_rx_stats stats;\n\tu8 rss_id;\n\tbool rx_post_starved;\t \n} ____cacheline_aligned_in_smp;\n\nstruct be_drv_stats {\n\tu32 eth_red_drops;\n\tu32 dma_map_errors;\n\tu32 rx_drops_no_pbuf;\n\tu32 rx_drops_no_txpb;\n\tu32 rx_drops_no_erx_descr;\n\tu32 rx_drops_no_tpre_descr;\n\tu32 rx_drops_too_many_frags;\n\tu32 forwarded_packets;\n\tu32 rx_drops_mtu;\n\tu32 rx_crc_errors;\n\tu32 rx_alignment_symbol_errors;\n\tu32 rx_pause_frames;\n\tu32 rx_priority_pause_frames;\n\tu32 rx_control_frames;\n\tu32 rx_in_range_errors;\n\tu32 rx_out_range_errors;\n\tu32 rx_frame_too_long;\n\tu32 rx_address_filtered;\n\tu32 rx_dropped_too_small;\n\tu32 rx_dropped_too_short;\n\tu32 rx_dropped_header_too_small;\n\tu32 rx_dropped_tcp_length;\n\tu32 rx_dropped_runt;\n\tu32 rx_ip_checksum_errs;\n\tu32 rx_tcp_checksum_errs;\n\tu32 rx_udp_checksum_errs;\n\tu32 tx_pauseframes;\n\tu32 tx_priority_pauseframes;\n\tu32 tx_controlframes;\n\tu32 rxpp_fifo_overflow_drop;\n\tu32 rx_input_fifo_overflow_drop;\n\tu32 pmem_fifo_overflow_drop;\n\tu32 jabber_events;\n\tu32 rx_roce_bytes_lsd;\n\tu32 rx_roce_bytes_msd;\n\tu32 rx_roce_frames;\n\tu32 roce_drops_payload_len;\n\tu32 roce_drops_crc;\n};\n\n \n#define BE_RESET_VLAN_TAG_ID\t0xFFFF\n\nstruct be_vf_cfg {\n\tunsigned char mac_addr[ETH_ALEN];\n\tint if_handle;\n\tint pmac_id;\n\tu16 vlan_tag;\n\tu32 tx_rate;\n\tu32 plink_tracking;\n\tu32 privileges;\n\tbool spoofchk;\n};\n\nenum vf_state {\n\tENABLED = 0,\n\tASSIGNED = 1\n};\n\n#define BE_FLAGS_LINK_STATUS_INIT\t\tBIT(1)\n#define BE_FLAGS_SRIOV_ENABLED\t\t\tBIT(2)\n#define BE_FLAGS_WORKER_SCHEDULED\t\tBIT(3)\n#define BE_FLAGS_NAPI_ENABLED\t\t\tBIT(6)\n#define BE_FLAGS_QNQ_ASYNC_EVT_RCVD\t\tBIT(7)\n#define BE_FLAGS_VXLAN_OFFLOADS\t\t\tBIT(8)\n#define BE_FLAGS_SETUP_DONE\t\t\tBIT(9)\n#define BE_FLAGS_PHY_MISCONFIGURED\t\tBIT(10)\n#define BE_FLAGS_ERR_DETECTION_SCHEDULED\tBIT(11)\n#define BE_FLAGS_OS2BMC\t\t\t\tBIT(12)\n#define BE_FLAGS_TRY_RECOVERY\t\t\tBIT(13)\n\n#define BE_UC_PMAC_COUNT\t\t\t30\n#define BE_VF_UC_PMAC_COUNT\t\t\t2\n\n#define MAX_ERR_RECOVERY_RETRY_COUNT\t\t3\n#define ERR_DETECTION_DELAY\t\t\t1000\n\n \n#define LANCER_INITIATE_FW_DUMP\t\t\t0x1\n#define LANCER_DELETE_FW_DUMP\t\t\t0x2\n\nstruct phy_info {\n \n#define SFP_VENDOR_NAME_LEN\t\t\t17\n\tu8 transceiver;\n\tu8 autoneg;\n\tu8 fc_autoneg;\n\tu8 port_type;\n\tu16 phy_type;\n\tu16 interface_type;\n\tu32 misc_params;\n\tu16 auto_speeds_supported;\n\tu16 fixed_speeds_supported;\n\tint link_speed;\n\tu32 advertising;\n\tu32 supported;\n\tu8 cable_type;\n\tu8 vendor_name[SFP_VENDOR_NAME_LEN];\n\tu8 vendor_pn[SFP_VENDOR_NAME_LEN];\n};\n\nstruct be_resources {\n\tu16 max_vfs;\t\t \n\tu16 max_mcast_mac;\n\tu16 max_tx_qs;\n\tu16 max_rss_qs;\n\tu16 max_rx_qs;\n\tu16 max_cq_count;\n\tu16 max_uc_mac;\t\t \n\tu16 max_vlans;\t\t \n\tu16 max_iface_count;\n\tu16 max_mcc_count;\n\tu16 max_evt_qs;\n\tu16 max_nic_evt_qs;\t \n\tu32 if_cap_flags;\n\tu32 vf_if_cap_flags;\t \n\tu32 flags;\n\t \n\tu16 max_rss_tables;\n};\n\n \nstruct be_port_resources {\n\tu16 max_vfs;\n\tu16 nic_pfs;\n};\n\n#define be_is_os2bmc_enabled(adapter) (adapter->flags & BE_FLAGS_OS2BMC)\n\nstruct rss_info {\n\tu8 rsstable[RSS_INDIR_TABLE_LEN];\n\tu8 rss_queue[RSS_INDIR_TABLE_LEN];\n\tu8 rss_hkey[RSS_HASH_KEY_LEN];\n\tu64 rss_flags;\n};\n\n#define BE_INVALID_DIE_TEMP\t0xFF\nstruct be_hwmon {\n\tstruct device *hwmon_dev;\n\tu8 be_on_die_temp;   \n};\n\n \n#define\tBE_WRB_F_BIT(name)\t\t\tBE_WRB_F_##name##_BIT\n#define\tBE_WRB_F_MASK(name)\t\t\tBIT_MASK(BE_WRB_F_##name##_BIT)\n\n#define\tBE_WRB_F_GET(word, name)\t\\\n\t(((word) & (BE_WRB_F_MASK(name))) >> BE_WRB_F_BIT(name))\n\n#define\tBE_WRB_F_SET(word, name, val)\t\\\n\t((word) |= (((val) << BE_WRB_F_BIT(name)) & BE_WRB_F_MASK(name)))\n\n \nenum {\n\tBE_WRB_F_CRC_BIT,\t\t \n\tBE_WRB_F_IPCS_BIT,\t\t \n\tBE_WRB_F_TCPCS_BIT,\t\t \n\tBE_WRB_F_UDPCS_BIT,\t\t \n\tBE_WRB_F_LSO_BIT,\t\t \n\tBE_WRB_F_LSO6_BIT,\t\t \n\tBE_WRB_F_VLAN_BIT,\t\t \n\tBE_WRB_F_VLAN_SKIP_HW_BIT,\t \n\tBE_WRB_F_OS2BMC_BIT\t\t \n};\n\n \nstruct be_wrb_params {\n\tu32 features;\t \n\tu16 vlan_tag;\t \n\tu16 lso_mss;\t \n};\n\nstruct be_eth_addr {\n\tunsigned char mac[ETH_ALEN];\n};\n\n#define BE_SEC\t1000\t\t\t \n#define BE_MIN\t(60 * BE_SEC)\t\t \n#define BE_HOUR\t(60 * BE_MIN)\t\t \n\n#define ERR_RECOVERY_MAX_RETRY_COUNT\t\t3\n#define ERR_RECOVERY_DETECTION_DELAY\t\tBE_SEC\n#define ERR_RECOVERY_RETRY_DELAY\t\t(30 * BE_SEC)\n\n \n#define ERR_RECOVERY_UE_DETECT_DURATION\t\t\tBE_SEC\n\n \n#define ERR_IDLE_HR\t\t\t24\n#define ERR_RECOVERY_IDLE_TIME\t\t(ERR_IDLE_HR * BE_HOUR)\n\n \n#define ERR_INTERVAL_HR\t\t\t72\n#define ERR_RECOVERY_INTERVAL\t\t(ERR_INTERVAL_HR * BE_HOUR)\n\n \nenum {\n\tERR_RECOVERY_ST_NONE = 0,\t\t \n\tERR_RECOVERY_ST_DETECT = 1,\t\t \n\tERR_RECOVERY_ST_RESET = 2,\t\t \n\tERR_RECOVERY_ST_PRE_POLL = 3,\t\t \n\tERR_RECOVERY_ST_REINIT = 4\t\t \n};\n\nstruct be_error_recovery {\n\tunion {\n\t\tu8 recovery_retries;\t \n\t\tu8 recovery_state;\t \n\t};\n\n\t \n\tbool recovery_supported;\n\tu16 ue_to_reset_time;\t\t \n\tu16 ue_to_poll_time;\t\t \n\tu16 last_err_code;\n\tunsigned long probe_time;\n\tunsigned long last_recovery_time;\n\n\t \n\tu32 resched_delay;\n\tstruct delayed_work err_detection_work;\n};\n\n \n#define\tBE_DISABLE_TPE_RECOVERY\t0x1\n\nstruct be_vxlan_port {\n\tstruct list_head list;\n\t__be16 port;\t\t \n\tint port_aliases;\t \n};\n\nstruct be_adapter {\n\tstruct pci_dev *pdev;\n\tstruct net_device *netdev;\n\n\tu8 __iomem *csr;\t \n\tu8 __iomem *db;\t\t \n\tu8 __iomem *pcicfg;\t \n\n\tstruct mutex mbox_lock;  \n\tstruct be_dma_mem mbox_mem;\n\t \n\tstruct be_dma_mem mbox_mem_alloced;\n\n\tstruct be_mcc_obj mcc_obj;\n\tstruct mutex mcc_lock;\t \n\tspinlock_t mcc_cq_lock;\n\n\tu16 cfg_num_rx_irqs;\t\t \n\tu16 cfg_num_tx_irqs;\t\t \n\tu16 num_evt_qs;\n\tu16 num_msix_vec;\n\tstruct be_eq_obj eq_obj[MAX_EVT_QS];\n\tstruct msix_entry msix_entries[MAX_MSIX_VECTORS];\n\tbool isr_registered;\n\n\t \n\tu16 num_tx_qs;\n\tstruct be_tx_obj tx_obj[MAX_TX_QS];\n\n\t \n\tu16 num_rx_qs;\n\tu16 num_rss_qs;\n\tu16 need_def_rxq;\n\tstruct be_rx_obj rx_obj[MAX_RX_QS];\n\tu32 big_page_size;\t \n\n\tstruct be_drv_stats drv_stats;\n\tstruct be_aic_obj aic_obj[MAX_EVT_QS];\n\tbool aic_enabled;\n\tu8 vlan_prio_bmap;\t \n\tu16 recommended_prio_bits; \n\tstruct be_dma_mem rx_filter;  \n\n\tstruct be_dma_mem stats_cmd;\n\t \n\tstruct delayed_work work;\n\tu16 work_counter;\n\n\tu8 recovery_retries;\n\tu8 err_flags;\n\tbool pcicfg_mapped;\t \n\tu32 flags;\n\tu32 cmd_privileges;\n\t \n\tchar fw_ver[FW_VER_LEN];\n\tchar fw_on_flash[FW_VER_LEN];\n\n\t \n\tint if_handle;\t\t \n\tu32 if_flags;\t\t \n\tu32 *pmac_id;\t\t \n\tstruct be_eth_addr *uc_list; \n\tu32 uc_macs;\t\t \n\tstruct be_eth_addr *mc_list; \n\tu32 mc_count;\n\tunsigned long vids[BITS_TO_LONGS(VLAN_N_VID)];\n\tu16 vlans_added;\n\tbool update_uc_list;\n\tbool update_mc_list;\n\tstruct mutex rx_filter_lock; \n\n\tu32 beacon_state;\t \n\n\tu32 port_num;\n\tchar port_name;\n\tu8 mc_type;\n\tu32 function_mode;\n\tu32 function_caps;\n\tu32 rx_fc;\t\t \n\tu32 tx_fc;\t\t \n\tbool stats_cmd_sent;\n\tstruct {\n\t\tu32 size;\n\t\tu32 total_size;\n\t\tu64 io_addr;\n\t} roce_db;\n\tu32 num_msix_roce_vec;\n\tstruct ocrdma_dev *ocrdma_dev;\n\tstruct list_head entry;\n\n\tu32 flash_status;\n\tstruct completion et_cmd_compl;\n\n\tstruct be_resources pool_res;\t \n\tstruct be_resources res;\t \n\tu16 num_vfs;\t\t\t \n\tu8 pf_num;\t\t\t \n\tu8 vf_num;\t\t\t \n\tu8 virtfn;\n\tstruct be_vf_cfg *vf_cfg;\n\tbool be3_native;\n\tu32 sli_family;\n\tu8 hba_port_num;\n\tu16 pvid;\n\t__be16 vxlan_port;\t\t \n\tstruct phy_info phy;\n\tu8 wol_cap;\n\tbool wol_en;\n\tu16 asic_rev;\n\tu16 qnq_vid;\n\tu32 msg_enable;\n\tint be_get_temp_freq;\n\tstruct be_hwmon hwmon_info;\n\tstruct rss_info rss_info;\n\t \n\tu32 bmc_filt_mask;\n\tu32 fat_dump_len;\n\tu16 serial_num[CNTL_SERIAL_NUM_WORDS];\n\tu8 phy_state;  \n\tu8 dev_mac[ETH_ALEN];\n\tu32 priv_flags;  \n\tstruct be_error_recovery error_recovery;\n};\n\n \nstruct be_cmd_work {\n\tstruct work_struct work;\n\tstruct be_adapter *adapter;\n};\n\n#define be_physfn(adapter)\t\t(!adapter->virtfn)\n#define be_virtfn(adapter)\t\t(adapter->virtfn)\n#define sriov_enabled(adapter)\t\t(adapter->flags &\t\\\n\t\t\t\t\t BE_FLAGS_SRIOV_ENABLED)\n\n#define for_all_vfs(adapter, vf_cfg, i)\t\t\t\t\t\\\n\tfor (i = 0, vf_cfg = &adapter->vf_cfg[i]; i < adapter->num_vfs;\t\\\n\t\ti++, vf_cfg++)\n\n#define ON\t\t\t\t1\n#define OFF\t\t\t\t0\n\n#define be_max_vlans(adapter)\t\t(adapter->res.max_vlans)\n#define be_max_uc(adapter)\t\t(adapter->res.max_uc_mac)\n#define be_max_mc(adapter)\t\t(adapter->res.max_mcast_mac)\n#define be_max_vfs(adapter)\t\t(adapter->pool_res.max_vfs)\n#define be_max_rss(adapter)\t\t(adapter->res.max_rss_qs)\n#define be_max_txqs(adapter)\t\t(adapter->res.max_tx_qs)\n#define be_max_prio_txqs(adapter)\t(adapter->res.max_prio_tx_qs)\n#define be_max_rxqs(adapter)\t\t(adapter->res.max_rx_qs)\n \n#define be_max_func_eqs(adapter)\t(adapter->res.max_evt_qs)\n \n#define be_max_nic_eqs(adapter)\t\t(adapter->res.max_nic_evt_qs)\n#define be_if_cap_flags(adapter)\t(adapter->res.if_cap_flags)\n#define be_max_pf_pool_rss_tables(adapter)\t\\\n\t\t\t\t(adapter->pool_res.max_rss_tables)\n \n#define be_max_irqs(adapter)\t\t\\\n\t\t\t(min_t(u16, be_max_nic_eqs(adapter), num_online_cpus()))\n\n \nstatic inline u16 be_max_rx_irqs(struct be_adapter *adapter)\n{\n\t \n\tu16 num = max_t(u16, be_max_rss(adapter), 1);\n\n\treturn min_t(u16, num, be_max_irqs(adapter));\n}\n\n \nstatic inline u16 be_max_tx_irqs(struct be_adapter *adapter)\n{\n\treturn min_t(u16, be_max_txqs(adapter), be_max_irqs(adapter));\n}\n\n \nstatic inline u16 be_max_qp_irqs(struct be_adapter *adapter)\n{\n\treturn min(be_max_tx_irqs(adapter), be_max_rx_irqs(adapter));\n}\n\n \nstatic inline u16 be_max_any_irqs(struct be_adapter *adapter)\n{\n\treturn max(be_max_tx_irqs(adapter), be_max_rx_irqs(adapter));\n}\n\n \n#define be_pvid_tagging_enabled(adapter)\t(adapter->pvid)\n\n \n#define be_is_qnq_mode(adapter)\t\t(adapter->function_mode & QNQ_MODE)\n\n#ifdef CONFIG_BE2NET_LANCER\n#define lancer_chip(adapter)\t(adapter->pdev->device == OC_DEVICE_ID3 || \\\n\t\t\t\t adapter->pdev->device == OC_DEVICE_ID4)\n#else\n#define lancer_chip(adapter)\t(0)\n#endif  \n\n#ifdef CONFIG_BE2NET_SKYHAWK\n#define skyhawk_chip(adapter)\t(adapter->pdev->device == OC_DEVICE_ID5 || \\\n\t\t\t\t adapter->pdev->device == OC_DEVICE_ID6)\n#else\n#define skyhawk_chip(adapter)\t(0)\n#endif  \n\n#ifdef CONFIG_BE2NET_BE3\n#define BE3_chip(adapter)\t(adapter->pdev->device == BE_DEVICE_ID2 || \\\n\t\t\t\t adapter->pdev->device == OC_DEVICE_ID2)\n#else\n#define BE3_chip(adapter)\t(0)\n#endif  \n\n#ifdef CONFIG_BE2NET_BE2\n#define BE2_chip(adapter)\t(adapter->pdev->device == BE_DEVICE_ID1 || \\\n\t\t\t\t adapter->pdev->device == OC_DEVICE_ID1)\n#else\n#define BE2_chip(adapter)\t(0)\n#endif  \n\n#define BEx_chip(adapter)\t(BE3_chip(adapter) || BE2_chip(adapter))\n\n#define be_roce_supported(adapter)\t(skyhawk_chip(adapter) && \\\n\t\t\t\t\t(adapter->function_mode & RDMA_ENABLED))\n\nextern const struct ethtool_ops be_ethtool_ops;\n\n#define msix_enabled(adapter)\t\t(adapter->num_msix_vec > 0)\n#define num_irqs(adapter)\t\t(msix_enabled(adapter) ?\t\\\n\t\t\t\t\t\tadapter->num_msix_vec : 1)\n#define tx_stats(txo)\t\t\t(&(txo)->stats)\n#define rx_stats(rxo)\t\t\t(&(rxo)->stats)\n\n \n#define default_rxo(adpt)\t\t(&adpt->rx_obj[adpt->num_rx_qs - 1])\n\n#define for_all_rx_queues(adapter, rxo, i)\t\t\t\t\\\n\tfor (i = 0, rxo = &adapter->rx_obj[i]; i < adapter->num_rx_qs;\t\\\n\t\ti++, rxo++)\n\n#define for_all_rss_queues(adapter, rxo, i)\t\t\t\t\\\n\tfor (i = 0, rxo = &adapter->rx_obj[i]; i < adapter->num_rss_qs;\t\\\n\t\ti++, rxo++)\n\n#define for_all_tx_queues(adapter, txo, i)\t\t\t\t\\\n\tfor (i = 0, txo = &adapter->tx_obj[i]; i < adapter->num_tx_qs;\t\\\n\t\ti++, txo++)\n\n#define for_all_evt_queues(adapter, eqo, i)\t\t\t\t\\\n\tfor (i = 0, eqo = &adapter->eq_obj[i]; i < adapter->num_evt_qs; \\\n\t\ti++, eqo++)\n\n#define for_all_rx_queues_on_eq(adapter, eqo, rxo, i)\t\t\t\\\n\tfor (i = eqo->idx, rxo = &adapter->rx_obj[i]; i < adapter->num_rx_qs;\\\n\t\t i += adapter->num_evt_qs, rxo += adapter->num_evt_qs)\n\n#define for_all_tx_queues_on_eq(adapter, eqo, txo, i)\t\t\t\\\n\tfor (i = eqo->idx, txo = &adapter->tx_obj[i]; i < adapter->num_tx_qs;\\\n\t\ti += adapter->num_evt_qs, txo += adapter->num_evt_qs)\n\n#define is_mcc_eqo(eqo)\t\t\t(eqo->idx == 0)\n#define mcc_eqo(adapter)\t\t(&adapter->eq_obj[0])\n\n#define PAGE_SHIFT_4K\t\t12\n#define PAGE_SIZE_4K\t\t(1 << PAGE_SHIFT_4K)\n\n \n#define PAGES_4K_SPANNED(_address, size) \t\t\t\t\\\n\t\t((u32)((((size_t)(_address) & (PAGE_SIZE_4K - 1)) + \t\\\n\t\t\t(size) + (PAGE_SIZE_4K - 1)) >> PAGE_SHIFT_4K))\n\n \n#define AMAP_BIT_OFFSET(_struct, field)  \t\t\t\t\\\n\t\t(((size_t)&(((_struct *)0)->field))%32)\n\n \nstatic inline u32 amap_mask(u32 bitsize)\n{\n\treturn (bitsize == 32 ? 0xFFFFFFFF : (1 << bitsize) - 1);\n}\n\nstatic inline void\namap_set(void *ptr, u32 dw_offset, u32 mask, u32 offset, u32 value)\n{\n\tu32 *dw = (u32 *) ptr + dw_offset;\n\t*dw &= ~(mask << offset);\n\t*dw |= (mask & value) << offset;\n}\n\n#define AMAP_SET_BITS(_struct, field, ptr, val)\t\t\t\t\\\n\t\tamap_set(ptr,\t\t\t\t\t\t\\\n\t\t\toffsetof(_struct, field)/32,\t\t\t\\\n\t\t\tamap_mask(sizeof(((_struct *)0)->field)),\t\\\n\t\t\tAMAP_BIT_OFFSET(_struct, field),\t\t\\\n\t\t\tval)\n\nstatic inline u32 amap_get(void *ptr, u32 dw_offset, u32 mask, u32 offset)\n{\n\tu32 *dw = (u32 *) ptr;\n\treturn mask & (*(dw + dw_offset) >> offset);\n}\n\n#define AMAP_GET_BITS(_struct, field, ptr)\t\t\t\t\\\n\t\tamap_get(ptr,\t\t\t\t\t\t\\\n\t\t\toffsetof(_struct, field)/32,\t\t\t\\\n\t\t\tamap_mask(sizeof(((_struct *)0)->field)),\t\\\n\t\t\tAMAP_BIT_OFFSET(_struct, field))\n\n#define GET_RX_COMPL_V0_BITS(field, ptr)\t\t\t\t\\\n\t\tAMAP_GET_BITS(struct amap_eth_rx_compl_v0, field, ptr)\n\n#define GET_RX_COMPL_V1_BITS(field, ptr)\t\t\t\t\\\n\t\tAMAP_GET_BITS(struct amap_eth_rx_compl_v1, field, ptr)\n\n#define GET_TX_COMPL_BITS(field, ptr)\t\t\t\t\t\\\n\t\tAMAP_GET_BITS(struct amap_eth_tx_compl, field, ptr)\n\n#define SET_TX_WRB_HDR_BITS(field, ptr, val)\t\t\t\t\\\n\t\tAMAP_SET_BITS(struct amap_eth_hdr_wrb, field, ptr, val)\n\n#define be_dws_cpu_to_le(wrb, len)\tswap_dws(wrb, len)\n#define be_dws_le_to_cpu(wrb, len)\tswap_dws(wrb, len)\nstatic inline void swap_dws(void *wrb, int len)\n{\n#ifdef __BIG_ENDIAN\n\tu32 *dw = wrb;\n\tBUG_ON(len % 4);\n\tdo {\n\t\t*dw = cpu_to_le32(*dw);\n\t\tdw++;\n\t\tlen -= 4;\n\t} while (len);\n#endif\t\t\t\t \n}\n\n#define be_cmd_status(status)\t\t(status > 0 ? -EIO : status)\n\nstatic inline u8 is_tcp_pkt(struct sk_buff *skb)\n{\n\tu8 val = 0;\n\n\tif (ip_hdr(skb)->version == 4)\n\t\tval = (ip_hdr(skb)->protocol == IPPROTO_TCP);\n\telse if (ip_hdr(skb)->version == 6)\n\t\tval = (ipv6_hdr(skb)->nexthdr == NEXTHDR_TCP);\n\n\treturn val;\n}\n\nstatic inline u8 is_udp_pkt(struct sk_buff *skb)\n{\n\tu8 val = 0;\n\n\tif (ip_hdr(skb)->version == 4)\n\t\tval = (ip_hdr(skb)->protocol == IPPROTO_UDP);\n\telse if (ip_hdr(skb)->version == 6)\n\t\tval = (ipv6_hdr(skb)->nexthdr == NEXTHDR_UDP);\n\n\treturn val;\n}\n\nstatic inline bool is_ipv4_pkt(struct sk_buff *skb)\n{\n\treturn skb->protocol == htons(ETH_P_IP) && ip_hdr(skb)->version == 4;\n}\n\nstatic inline bool is_ipv6_ext_hdr(struct sk_buff *skb)\n{\n\tif (ip_hdr(skb)->version == 6)\n\t\treturn ipv6_ext_hdr(ipv6_hdr(skb)->nexthdr);\n\telse\n\t\treturn false;\n}\n\n#define be_error_recovering(adapter)\t\\\n\t\t(adapter->flags & BE_FLAGS_TRY_RECOVERY)\n\n#define BE_ERROR_EEH\t\t1\n#define BE_ERROR_UE\t\tBIT(1)\n#define BE_ERROR_FW\t\tBIT(2)\n#define BE_ERROR_TX\t\tBIT(3)\n#define BE_ERROR_HW\t\t(BE_ERROR_EEH | BE_ERROR_UE | BE_ERROR_TX)\n#define BE_ERROR_ANY\t\t(BE_ERROR_EEH | BE_ERROR_UE | BE_ERROR_FW | \\\n\t\t\t\t BE_ERROR_TX)\n#define BE_CLEAR_ALL\t\t0xFF\n\nstatic inline u8 be_check_error(struct be_adapter *adapter, u32 err_type)\n{\n\treturn (adapter->err_flags & err_type);\n}\n\nstatic inline void be_set_error(struct be_adapter *adapter, int err_type)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\tadapter->err_flags |= err_type;\n\tnetif_carrier_off(netdev);\n\n\tdev_info(&adapter->pdev->dev, \"%s: Link down\\n\", netdev->name);\n}\n\nstatic inline void  be_clear_error(struct be_adapter *adapter, int err_type)\n{\n\tadapter->err_flags &= ~err_type;\n}\n\nstatic inline bool be_multi_rxq(const struct be_adapter *adapter)\n{\n\treturn adapter->num_rx_qs > 1;\n}\n\nvoid be_cq_notify(struct be_adapter *adapter, u16 qid, bool arm,\n\t\t  u16 num_popped);\nvoid be_link_status_update(struct be_adapter *adapter, u8 link_status);\nvoid be_parse_stats(struct be_adapter *adapter);\nint be_load_fw(struct be_adapter *adapter, u8 *func);\nbool be_is_wol_supported(struct be_adapter *adapter);\nbool be_pause_supported(struct be_adapter *adapter);\nu32 be_get_fw_log_level(struct be_adapter *adapter);\nint be_update_queues(struct be_adapter *adapter);\nint be_poll(struct napi_struct *napi, int budget);\nvoid be_eqd_update(struct be_adapter *adapter, bool force_update);\n\n \nvoid be_roce_dev_add(struct be_adapter *);\nvoid be_roce_dev_remove(struct be_adapter *);\n\n \nvoid be_roce_dev_shutdown(struct be_adapter *);\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}