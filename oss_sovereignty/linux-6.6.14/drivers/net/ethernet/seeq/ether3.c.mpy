{
  "module_name": "ether3.c",
  "hash_id": "1d2327043a8623651b6290255dbb728c7afa7b78df2a3945aaf68cd8a467107e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/seeq/ether3.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/bitops.h>\n\n#include <asm/ecard.h>\n#include <asm/io.h>\n\nstatic char version[] = \"ether3 ethernet driver (c) 1995-2000 R.M.King v1.17\\n\";\n\n#include \"ether3.h\"\n\nstatic unsigned int net_debug = NET_DEBUG;\n\nstatic void\tether3_setmulticastlist(struct net_device *dev);\nstatic int\tether3_rx(struct net_device *dev, unsigned int maxcnt);\nstatic void\tether3_tx(struct net_device *dev);\nstatic int\tether3_open (struct net_device *dev);\nstatic netdev_tx_t\tether3_sendpacket(struct sk_buff *skb,\n\t\t\t\t\t  struct net_device *dev);\nstatic irqreturn_t ether3_interrupt (int irq, void *dev_id);\nstatic int\tether3_close (struct net_device *dev);\nstatic void\tether3_setmulticastlist (struct net_device *dev);\nstatic void\tether3_timeout(struct net_device *dev, unsigned int txqueue);\n\n#define BUS_16\t\t2\n#define BUS_8\t\t1\n#define BUS_UNKNOWN\t0\n\n \n\ntypedef enum {\n\tbuffer_write,\n\tbuffer_read\n} buffer_rw_t;\n\n \nstatic inline void ether3_outb(int v, void __iomem *r)\n{\n\twriteb(v, r);\n\tudelay(1);\n}\n\nstatic inline void ether3_outw(int v, void __iomem *r)\n{\n\twritew(v, r);\n\tudelay(1);\n}\n#define ether3_inb(r)\t\t({ unsigned int __v = readb((r)); udelay(1); __v; })\n#define ether3_inw(r)\t\t({ unsigned int __v = readw((r)); udelay(1); __v; })\n\nstatic int\nether3_setbuffer(struct net_device *dev, buffer_rw_t read, int start)\n{\n\tint timeout = 1000;\n\n\tether3_outw(priv(dev)->regs.config1 | CFG1_LOCBUFMEM, REG_CONFIG1);\n\tether3_outw(priv(dev)->regs.command | CMD_FIFOWRITE, REG_COMMAND);\n\n\twhile ((ether3_inw(REG_STATUS) & STAT_FIFOEMPTY) == 0) {\n\t\tif (!timeout--) {\n\t\t\tprintk(\"%s: setbuffer broken\\n\", dev->name);\n\t\t\tpriv(dev)->broken = 1;\n\t\t\treturn 1;\n\t\t}\n\t\tudelay(1);\n\t}\n\n\tif (read == buffer_read) {\n\t\tether3_outw(start, REG_DMAADDR);\n\t\tether3_outw(priv(dev)->regs.command | CMD_FIFOREAD, REG_COMMAND);\n\t} else {\n\t\tether3_outw(priv(dev)->regs.command | CMD_FIFOWRITE, REG_COMMAND);\n\t\tether3_outw(start, REG_DMAADDR);\n\t}\n\treturn 0;\n}\n\n \n#define ether3_writebuffer(dev,data,length)\t\t\t\\\n\twritesw(REG_BUFWIN, (data), (length) >> 1)\n\n#define ether3_writeword(dev,data)\t\t\t\t\\\n\twritew((data), REG_BUFWIN)\n\n#define ether3_writelong(dev,data)\t{\t\t\t\\\n\tvoid __iomem *reg_bufwin = REG_BUFWIN;\t\t\t\\\n\twritew((data), reg_bufwin);\t\t\t\t\\\n\twritew((data) >> 16, reg_bufwin);\t\t\t\\\n}\n\n \n#define ether3_readbuffer(dev,data,length)\t\t\t\\\n\treadsw(REG_BUFWIN, (data), (length) >> 1)\n\n#define ether3_readword(dev)\t\t\t\t\t\\\n\treadw(REG_BUFWIN)\n\n#define ether3_readlong(dev)\t \t\t\t\t\\\n\treadw(REG_BUFWIN) | (readw(REG_BUFWIN) << 16)\n\n \nstatic void ether3_ledoff(struct timer_list *t)\n{\n\tstruct dev_priv *private = from_timer(private, t, timer);\n\tstruct net_device *dev = private->dev;\n\n\tether3_outw(priv(dev)->regs.config2 |= CFG2_CTRLO, REG_CONFIG2);\n}\n\n \nstatic inline void ether3_ledon(struct net_device *dev)\n{\n\tdel_timer(&priv(dev)->timer);\n\tpriv(dev)->timer.expires = jiffies + HZ / 50;  \n\tadd_timer(&priv(dev)->timer);\n\tif (priv(dev)->regs.config2 & CFG2_CTRLO)\n\t\tether3_outw(priv(dev)->regs.config2 &= ~CFG2_CTRLO, REG_CONFIG2);\n}\n\n \nstatic int\nether3_addr(char *addr, struct expansion_card *ec)\n{\n\tstruct in_chunk_dir cd;\n\tchar *s;\n\t\n\tif (ecard_readchunk(&cd, ec, 0xf5, 0) && (s = strchr(cd.d.string, '('))) {\n\t\tint i;\n\t\tfor (i = 0; i<6; i++) {\n\t\t\taddr[i] = simple_strtoul(s + 1, &s, 0x10);\n\t\t\tif (*s != (i==5?')' : ':' ))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == 6)\n\t\t\treturn 0;\n\t}\n\t \n\tprintk(KERN_ERR \"ether3: Couldn't read a valid MAC address from card.\\n\");\n\treturn -ENODEV;\n}\n\n \n\nstatic int\nether3_ramtest(struct net_device *dev, unsigned char byte)\n{\n\tunsigned char *buffer = kmalloc(RX_END, GFP_KERNEL);\n\tint i,ret = 0;\n\tint max_errors = 4;\n\tint bad = -1;\n\n\tif (!buffer)\n\t\treturn 1;\n\n\tmemset(buffer, byte, RX_END);\n\tether3_setbuffer(dev, buffer_write, 0);\n\tether3_writebuffer(dev, buffer, TX_END);\n\tether3_setbuffer(dev, buffer_write, RX_START);\n\tether3_writebuffer(dev, buffer + RX_START, RX_LEN);\n\tmemset(buffer, byte ^ 0xff, RX_END);\n\tether3_setbuffer(dev, buffer_read, 0);\n\tether3_readbuffer(dev, buffer, TX_END);\n\tether3_setbuffer(dev, buffer_read, RX_START);\n\tether3_readbuffer(dev, buffer + RX_START, RX_LEN);\n\n\tfor (i = 0; i < RX_END; i++) {\n\t\tif (buffer[i] != byte) {\n\t\t\tif (max_errors > 0 && bad != buffer[i]) {\n\t\t\t\tprintk(\"%s: RAM failed with (%02X instead of %02X) at 0x%04X\",\n\t\t\t\t       dev->name, buffer[i], byte, i);\n\t\t\t\tret = 2;\n\t\t\t\tmax_errors--;\n\t\t\t\tbad = i;\n\t\t\t}\n\t\t} else {\n\t\t\tif (bad != -1) {\n\t\t\t\tif (bad != i - 1)\n\t\t\t\t\tprintk(\" - 0x%04X\\n\", i - 1);\n\t\t\t\tprintk(\"\\n\");\n\t\t\t\tbad = -1;\n\t\t\t}\n\t\t}\n\t}\n\tif (bad != -1)\n\t\tprintk(\" - 0xffff\\n\");\n\tkfree(buffer);\n\n\treturn ret;\n}\n\n \n\nstatic int ether3_init_2(struct net_device *dev)\n{\n\tint i;\n\n\tpriv(dev)->regs.config1 = CFG1_RECVCOMPSTAT0|CFG1_DMABURST8;\n\tpriv(dev)->regs.config2 = CFG2_CTRLO|CFG2_RECVCRC|CFG2_ERRENCRC;\n\tpriv(dev)->regs.command = 0;\n\n\t \n\tether3_outw(priv(dev)->regs.config1 | CFG1_BUFSELSTAT0, REG_CONFIG1);\n\tfor (i = 0; i < 6; i++)\n\t\tether3_outb(dev->dev_addr[i], REG_BUFWIN);\n\n\tif (dev->flags & IFF_PROMISC)\n\t\tpriv(dev)->regs.config1 |= CFG1_RECVPROMISC;\n\telse if (dev->flags & IFF_MULTICAST)\n\t\tpriv(dev)->regs.config1 |= CFG1_RECVSPECBRMULTI;\n\telse\n\t\tpriv(dev)->regs.config1 |= CFG1_RECVSPECBROAD;\n\n\t \n\tether3_outw(priv(dev)->regs.config1 | CFG1_TRANSEND, REG_CONFIG1);\n\tether3_outw((TX_END>>8) - 1, REG_BUFWIN);\n\tether3_outw(priv(dev)->rx_head, REG_RECVPTR);\n\tether3_outw(0, REG_TRANSMITPTR);\n\tether3_outw(priv(dev)->rx_head >> 8, REG_RECVEND);\n\tether3_outw(priv(dev)->regs.config2, REG_CONFIG2);\n\tether3_outw(priv(dev)->regs.config1 | CFG1_LOCBUFMEM, REG_CONFIG1);\n\tether3_outw(priv(dev)->regs.command, REG_COMMAND);\n\n\ti = ether3_ramtest(dev, 0x5A);\n\tif(i)\n\t\treturn i;\n\ti = ether3_ramtest(dev, 0x1E);\n\tif(i)\n\t\treturn i;\n\n\tether3_setbuffer(dev, buffer_write, 0);\n\tether3_writelong(dev, 0);\n\treturn 0;\n}\n\nstatic void\nether3_init_for_open(struct net_device *dev)\n{\n\tint i;\n\n\t \n\tether3_outw(CFG2_RESET, REG_CONFIG2);\n\tudelay(4);\n\n\tpriv(dev)->regs.command = 0;\n\tether3_outw(CMD_RXOFF|CMD_TXOFF, REG_COMMAND);\n\twhile (ether3_inw(REG_STATUS) & (STAT_RXON|STAT_TXON))\n\t\tbarrier();\n\n\tether3_outw(priv(dev)->regs.config1 | CFG1_BUFSELSTAT0, REG_CONFIG1);\n\tfor (i = 0; i < 6; i++)\n\t\tether3_outb(dev->dev_addr[i], REG_BUFWIN);\n\n\tpriv(dev)->tx_head\t= 0;\n\tpriv(dev)->tx_tail\t= 0;\n\tpriv(dev)->regs.config2 |= CFG2_CTRLO;\n\tpriv(dev)->rx_head\t= RX_START;\n\n\tether3_outw(priv(dev)->regs.config1 | CFG1_TRANSEND, REG_CONFIG1);\n\tether3_outw((TX_END>>8) - 1, REG_BUFWIN);\n\tether3_outw(priv(dev)->rx_head, REG_RECVPTR);\n\tether3_outw(priv(dev)->rx_head >> 8, REG_RECVEND);\n\tether3_outw(0, REG_TRANSMITPTR);\n\tether3_outw(priv(dev)->regs.config2, REG_CONFIG2);\n\tether3_outw(priv(dev)->regs.config1 | CFG1_LOCBUFMEM, REG_CONFIG1);\n\n\tether3_setbuffer(dev, buffer_write, 0);\n\tether3_writelong(dev, 0);\n\n\tpriv(dev)->regs.command = CMD_ENINTRX | CMD_ENINTTX;\n\tether3_outw(priv(dev)->regs.command | CMD_RXON, REG_COMMAND);\n}\n\nstatic inline int\nether3_probe_bus_8(struct net_device *dev, int val)\n{\n\tint write_low, write_high, read_low, read_high;\n\n\twrite_low = val & 255;\n\twrite_high = val >> 8;\n\n\tprintk(KERN_DEBUG \"ether3_probe: write8 [%02X:%02X]\", write_high, write_low);\n\n\tether3_outb(write_low, REG_RECVPTR);\n\tether3_outb(write_high, REG_RECVPTR + 4);\n\n\tread_low = ether3_inb(REG_RECVPTR);\n\tread_high = ether3_inb(REG_RECVPTR + 4);\n\n\tprintk(\", read8 [%02X:%02X]\\n\", read_high, read_low);\n\n\treturn read_low == write_low && read_high == write_high;\n}\n\nstatic inline int\nether3_probe_bus_16(struct net_device *dev, int val)\n{\n\tint read_val;\n\n\tether3_outw(val, REG_RECVPTR);\n\tread_val = ether3_inw(REG_RECVPTR);\n\n\tprintk(KERN_DEBUG \"ether3_probe: write16 [%04X], read16 [%04X]\\n\", val, read_val);\n\n\treturn read_val == val;\n}\n\n \nstatic int\nether3_open(struct net_device *dev)\n{\n\tif (request_irq(dev->irq, ether3_interrupt, 0, \"ether3\", dev))\n\t\treturn -EAGAIN;\n\n\tether3_init_for_open(dev);\n\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\n \nstatic int\nether3_close(struct net_device *dev)\n{\n\tnetif_stop_queue(dev);\n\n\tdisable_irq(dev->irq);\n\n\tether3_outw(CMD_RXOFF|CMD_TXOFF, REG_COMMAND);\n\tpriv(dev)->regs.command = 0;\n\twhile (ether3_inw(REG_STATUS) & (STAT_RXON|STAT_TXON))\n\t\tbarrier();\n\tether3_outb(0x80, REG_CONFIG2 + 4);\n\tether3_outw(0, REG_COMMAND);\n\n\tfree_irq(dev->irq, dev);\n\n\treturn 0;\n}\n\n \nstatic void ether3_setmulticastlist(struct net_device *dev)\n{\n\tpriv(dev)->regs.config1 &= ~CFG1_RECVPROMISC;\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\t \n\t\tpriv(dev)->regs.config1 |= CFG1_RECVPROMISC;\n\t} else if (dev->flags & IFF_ALLMULTI || !netdev_mc_empty(dev)) {\n\t\tpriv(dev)->regs.config1 |= CFG1_RECVSPECBRMULTI;\n\t} else\n\t\tpriv(dev)->regs.config1 |= CFG1_RECVSPECBROAD;\n\n\tether3_outw(priv(dev)->regs.config1 | CFG1_LOCBUFMEM, REG_CONFIG1);\n}\n\nstatic void ether3_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tunsigned long flags;\n\n\tdel_timer(&priv(dev)->timer);\n\n\tlocal_irq_save(flags);\n\tprintk(KERN_ERR \"%s: transmit timed out, network cable problem?\\n\", dev->name);\n\tprintk(KERN_ERR \"%s: state: { status=%04X cfg1=%04X cfg2=%04X }\\n\", dev->name,\n\t\tether3_inw(REG_STATUS), ether3_inw(REG_CONFIG1), ether3_inw(REG_CONFIG2));\n\tprintk(KERN_ERR \"%s: { rpr=%04X rea=%04X tpr=%04X }\\n\", dev->name,\n\t\tether3_inw(REG_RECVPTR), ether3_inw(REG_RECVEND), ether3_inw(REG_TRANSMITPTR));\n\tprintk(KERN_ERR \"%s: tx head=%X tx tail=%X\\n\", dev->name,\n\t\tpriv(dev)->tx_head, priv(dev)->tx_tail);\n\tether3_setbuffer(dev, buffer_read, priv(dev)->tx_tail);\n\tprintk(KERN_ERR \"%s: packet status = %08X\\n\", dev->name, ether3_readlong(dev));\n\tlocal_irq_restore(flags);\n\n\tpriv(dev)->regs.config2 |= CFG2_CTRLO;\n\tdev->stats.tx_errors += 1;\n\tether3_outw(priv(dev)->regs.config2, REG_CONFIG2);\n\tpriv(dev)->tx_head = priv(dev)->tx_tail = 0;\n\n\tnetif_wake_queue(dev);\n}\n\n \nstatic netdev_tx_t\nether3_sendpacket(struct sk_buff *skb, struct net_device *dev)\n{\n\tunsigned long flags;\n\tunsigned int length = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;\n\tunsigned int ptr, next_ptr;\n\n\tif (priv(dev)->broken) {\n\t\tdev_kfree_skb(skb);\n\t\tdev->stats.tx_dropped++;\n\t\tnetif_start_queue(dev);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tlength = (length + 1) & ~1;\n\tif (length != skb->len) {\n\t\tif (skb_padto(skb, length))\n\t\t\tgoto out;\n\t}\n\n\tnext_ptr = (priv(dev)->tx_head + 1) & 15;\n\n\tlocal_irq_save(flags);\n\n\tif (priv(dev)->tx_tail == next_ptr) {\n\t\tlocal_irq_restore(flags);\n\t\treturn NETDEV_TX_BUSY;\t \n\t}\n\n\tptr\t\t = 0x600 * priv(dev)->tx_head;\n\tpriv(dev)->tx_head = next_ptr;\n\tnext_ptr\t*= 0x600;\n\n#define TXHDR_FLAGS (TXHDR_TRANSMIT|TXHDR_CHAINCONTINUE|TXHDR_DATAFOLLOWS|TXHDR_ENSUCCESS)\n\n\tether3_setbuffer(dev, buffer_write, next_ptr);\n\tether3_writelong(dev, 0);\n\tether3_setbuffer(dev, buffer_write, ptr);\n\tether3_writelong(dev, 0);\n\tether3_writebuffer(dev, skb->data, length);\n\tether3_writeword(dev, htons(next_ptr));\n\tether3_writeword(dev, TXHDR_CHAINCONTINUE >> 16);\n\tether3_setbuffer(dev, buffer_write, ptr);\n\tether3_writeword(dev, htons((ptr + length + 4)));\n\tether3_writeword(dev, TXHDR_FLAGS >> 16);\n\tether3_ledon(dev);\n\n\tif (!(ether3_inw(REG_STATUS) & STAT_TXON)) {\n\t\tether3_outw(ptr, REG_TRANSMITPTR);\n\t\tether3_outw(priv(dev)->regs.command | CMD_TXON, REG_COMMAND);\n\t}\n\n\tnext_ptr = (priv(dev)->tx_head + 1) & 15;\n\tlocal_irq_restore(flags);\n\n\tdev_kfree_skb(skb);\n\n\tif (priv(dev)->tx_tail == next_ptr)\n\t\tnetif_stop_queue(dev);\n\n out:\n\treturn NETDEV_TX_OK;\n}\n\nstatic irqreturn_t\nether3_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = (struct net_device *)dev_id;\n\tunsigned int status, handled = IRQ_NONE;\n\n#if NET_DEBUG > 1\n\tif(net_debug & DEBUG_INT)\n\t\tprintk(\"eth3irq: %d \", irq);\n#endif\n\n\tstatus = ether3_inw(REG_STATUS);\n\n\tif (status & STAT_INTRX) {\n\t\tether3_outw(CMD_ACKINTRX | priv(dev)->regs.command, REG_COMMAND);\n\t\tether3_rx(dev, 12);\n\t\thandled = IRQ_HANDLED;\n\t}\n\n\tif (status & STAT_INTTX) {\n\t\tether3_outw(CMD_ACKINTTX | priv(dev)->regs.command, REG_COMMAND);\n\t\tether3_tx(dev);\n\t\thandled = IRQ_HANDLED;\n\t}\n\n#if NET_DEBUG > 1\n\tif(net_debug & DEBUG_INT)\n\t\tprintk(\"done\\n\");\n#endif\n\treturn handled;\n}\n\n \nstatic int ether3_rx(struct net_device *dev, unsigned int maxcnt)\n{\n\tunsigned int next_ptr = priv(dev)->rx_head, received = 0;\n\n\tether3_ledon(dev);\n\n\tdo {\n\t\tunsigned int this_ptr, status;\n\t\tunsigned char addrs[16];\n\n\t\t \n\t\t{\n\t\t\tunsigned int temp_ptr;\n\t\t\tether3_setbuffer(dev, buffer_read, next_ptr);\n\t\t\ttemp_ptr = ether3_readword(dev);\n\t\t\tstatus = ether3_readword(dev);\n\t\t\tif ((status & (RXSTAT_DONE | RXHDR_CHAINCONTINUE | RXHDR_RECEIVE)) !=\n\t\t\t\t(RXSTAT_DONE | RXHDR_CHAINCONTINUE) || !temp_ptr)\n\t\t\t\tbreak;\n\n\t\t\tthis_ptr = next_ptr + 4;\n\t\t\tnext_ptr = ntohs(temp_ptr);\n\t\t}\n\t\tether3_setbuffer(dev, buffer_read, this_ptr);\n\t\tether3_readbuffer(dev, addrs+2, 12);\n\nif (next_ptr < RX_START || next_ptr >= RX_END) {\n printk(\"%s: bad next pointer @%04X: \", dev->name, priv(dev)->rx_head);\n printk(\"%02X %02X %02X %02X \", next_ptr >> 8, next_ptr & 255, status & 255, status >> 8);\n printk(\"%pM %pM\\n\", addrs + 2, addrs + 8);\n next_ptr = priv(dev)->rx_head;\n break;\n}\n\t\t \n\t\tif (!(*(unsigned long *)&dev->dev_addr[0] ^ *(unsigned long *)&addrs[2+6]) &&\n\t\t    !(*(unsigned short *)&dev->dev_addr[4] ^ *(unsigned short *)&addrs[2+10])) {\n\t\t\tmaxcnt ++;  \n\t\t\tether3_outw(next_ptr >> 8, REG_RECVEND);\n\t\t} else\n\t\tif (!(status & (RXSTAT_OVERSIZE|RXSTAT_CRCERROR|RXSTAT_DRIBBLEERROR|RXSTAT_SHORTPACKET))) {\n\t\t\tunsigned int length = next_ptr - this_ptr;\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tif (next_ptr <= this_ptr)\n\t\t\t\tlength += RX_END - RX_START;\n\n\t\t\tskb = netdev_alloc_skb(dev, length + 2);\n\t\t\tif (skb) {\n\t\t\t\tunsigned char *buf;\n\n\t\t\t\tskb_reserve(skb, 2);\n\t\t\t\tbuf = skb_put(skb, length);\n\t\t\t\tether3_readbuffer(dev, buf + 12, length - 12);\n\t\t\t\tether3_outw(next_ptr >> 8, REG_RECVEND);\n\t\t\t\t*(unsigned short *)(buf + 0)\t= *(unsigned short *)(addrs + 2);\n\t\t\t\t*(unsigned long *)(buf + 2)\t= *(unsigned long *)(addrs + 4);\n\t\t\t\t*(unsigned long *)(buf + 6)\t= *(unsigned long *)(addrs + 8);\n\t\t\t\t*(unsigned short *)(buf + 10)\t= *(unsigned short *)(addrs + 12);\n\t\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\t\tnetif_rx(skb);\n\t\t\t\treceived ++;\n\t\t\t} else {\n\t\t\t\tether3_outw(next_ptr >> 8, REG_RECVEND);\n\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else {\n\t\t\tstruct net_device_stats *stats = &dev->stats;\n\t\t\tether3_outw(next_ptr >> 8, REG_RECVEND);\n\t\t\tif (status & RXSTAT_OVERSIZE)\t  stats->rx_over_errors ++;\n\t\t\tif (status & RXSTAT_CRCERROR)\t  stats->rx_crc_errors ++;\n\t\t\tif (status & RXSTAT_DRIBBLEERROR) stats->rx_fifo_errors ++;\n\t\t\tif (status & RXSTAT_SHORTPACKET)  stats->rx_length_errors ++;\n\t\t\tstats->rx_errors++;\n\t\t}\n\t}\n\twhile (-- maxcnt);\n\ndone:\n\tdev->stats.rx_packets += received;\n\tpriv(dev)->rx_head = next_ptr;\n\t \n\tif (!(ether3_inw(REG_STATUS) & STAT_RXON)) {\n\t\tdev->stats.rx_dropped++;\n\t\tether3_outw(next_ptr, REG_RECVPTR);\n\t\tether3_outw(priv(dev)->regs.command | CMD_RXON, REG_COMMAND);\n\t}\n\n\treturn maxcnt;\n}\n\n \nstatic void ether3_tx(struct net_device *dev)\n{\n\tunsigned int tx_tail = priv(dev)->tx_tail;\n\tint max_work = 14;\n\n\tdo {\n\t    \tunsigned long status;\n\n\t\t \n\t    \tether3_setbuffer(dev, buffer_read, tx_tail * 0x600);\n\t\tstatus = ether3_readlong(dev);\n\n\t\t \n\t\tif ((status & (TXSTAT_DONE | TXHDR_TRANSMIT)) !=\n\t\t    (TXSTAT_DONE | TXHDR_TRANSMIT))\n\t\t\tbreak;\n\n\t\t \n\t\tif (!(status & (TXSTAT_BABBLED | TXSTAT_16COLLISIONS)))\n\t\t\tdev->stats.tx_packets++;\n\t\telse {\n\t\t\tdev->stats.tx_errors++;\n\t\t\tif (status & TXSTAT_16COLLISIONS)\n\t\t\t\tdev->stats.collisions += 16;\n\t\t\tif (status & TXSTAT_BABBLED)\n\t\t\t\tdev->stats.tx_fifo_errors++;\n\t\t}\n\n\t\ttx_tail = (tx_tail + 1) & 15;\n\t} while (--max_work);\n\n\tif (priv(dev)->tx_tail != tx_tail) {\n\t\tpriv(dev)->tx_tail = tx_tail;\n\t\tnetif_wake_queue(dev);\n\t}\n}\n\nstatic void ether3_banner(void)\n{\n\tstatic unsigned version_printed = 0;\n\n\tif (net_debug && version_printed++ == 0)\n\t\tprintk(KERN_INFO \"%s\", version);\n}\n\nstatic const struct net_device_ops ether3_netdev_ops = {\n\t.ndo_open\t\t= ether3_open,\n\t.ndo_stop\t\t= ether3_close,\n\t.ndo_start_xmit\t\t= ether3_sendpacket,\n\t.ndo_set_rx_mode\t= ether3_setmulticastlist,\n\t.ndo_tx_timeout\t\t= ether3_timeout,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n};\n\nstatic int\nether3_probe(struct expansion_card *ec, const struct ecard_id *id)\n{\n\tconst struct ether3_data *data = id->data;\n\tstruct net_device *dev;\n\tint bus_type, ret;\n\tu8 addr[ETH_ALEN];\n\n\tether3_banner();\n\n\tret = ecard_request_resources(ec);\n\tif (ret)\n\t\tgoto out;\n\n\tdev = alloc_etherdev(sizeof(struct dev_priv));\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto release;\n\t}\n\n\tSET_NETDEV_DEV(dev, &ec->dev);\n\n\tpriv(dev)->base = ecardm_iomap(ec, ECARD_RES_MEMC, 0, 0);\n\tif (!priv(dev)->base) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tec->irqaddr = priv(dev)->base + data->base_offset;\n\tec->irqmask = 0xf0;\n\n\tpriv(dev)->seeq = priv(dev)->base + data->base_offset;\n\tdev->irq = ec->irq;\n\n\tether3_addr(addr, ec);\n\teth_hw_addr_set(dev, addr);\n\n\tpriv(dev)->dev = dev;\n\ttimer_setup(&priv(dev)->timer, ether3_ledoff, 0);\n\n\t \n\tether3_outb(0x80, REG_CONFIG2 + 4);\n\tbus_type = BUS_UNKNOWN;\n\tudelay(4);\n\n\t \n\tif (ether3_probe_bus_8(dev, 0x100) &&\n\t    ether3_probe_bus_8(dev, 0x201))\n\t\tbus_type = BUS_8;\n\n\tif (bus_type == BUS_UNKNOWN &&\n\t    ether3_probe_bus_16(dev, 0x101) &&\n\t    ether3_probe_bus_16(dev, 0x201))\n\t\tbus_type = BUS_16;\n\n\tswitch (bus_type) {\n\tcase BUS_UNKNOWN:\n\t\tprintk(KERN_ERR \"%s: unable to identify bus width\\n\", dev->name);\n\t\tret = -ENODEV;\n\t\tgoto free;\n\n\tcase BUS_8:\n\t\tprintk(KERN_ERR \"%s: %s found, but is an unsupported \"\n\t\t\t\"8-bit card\\n\", dev->name, data->name);\n\t\tret = -ENODEV;\n\t\tgoto free;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (ether3_init_2(dev)) {\n\t\tret = -ENODEV;\n\t\tgoto free;\n\t}\n\n\tdev->netdev_ops\t\t= &ether3_netdev_ops;\n\tdev->watchdog_timeo\t= 5 * HZ / 100;\n\n\tret = register_netdev(dev);\n\tif (ret)\n\t\tgoto free;\n\n\tprintk(\"%s: %s in slot %d, %pM\\n\",\n\t       dev->name, data->name, ec->slot_no, dev->dev_addr);\n\n\tecard_set_drvdata(ec, dev);\n\treturn 0;\n\n free:\n\tfree_netdev(dev);\n release:\n\tecard_release_resources(ec);\n out:\n\treturn ret;\n}\n\nstatic void ether3_remove(struct expansion_card *ec)\n{\n\tstruct net_device *dev = ecard_get_drvdata(ec);\n\n\tecard_set_drvdata(ec, NULL);\n\n\tunregister_netdev(dev);\n\tfree_netdev(dev);\n\tecard_release_resources(ec);\n}\n\nstatic struct ether3_data ether3 = {\n\t.name\t\t= \"ether3\",\n\t.base_offset\t= 0,\n};\n\nstatic struct ether3_data etherb = {\n\t.name\t\t= \"etherb\",\n\t.base_offset\t= 0x800,\n};\n\nstatic const struct ecard_id ether3_ids[] = {\n\t{ MANU_ANT2, PROD_ANT_ETHER3, &ether3 },\n\t{ MANU_ANT,  PROD_ANT_ETHER3, &ether3 },\n\t{ MANU_ANT,  PROD_ANT_ETHERB, &etherb },\n\t{ 0xffff, 0xffff }\n};\n\nstatic struct ecard_driver ether3_driver = {\n\t.probe\t\t= ether3_probe,\n\t.remove\t\t= ether3_remove,\n\t.id_table\t= ether3_ids,\n\t.drv = {\n\t\t.name\t= \"ether3\",\n\t},\n};\n\nstatic int __init ether3_init(void)\n{\n\treturn ecard_register_driver(&ether3_driver);\n}\n\nstatic void __exit ether3_exit(void)\n{\n\tecard_remove_driver(&ether3_driver);\n}\n\nmodule_init(ether3_init);\nmodule_exit(ether3_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}