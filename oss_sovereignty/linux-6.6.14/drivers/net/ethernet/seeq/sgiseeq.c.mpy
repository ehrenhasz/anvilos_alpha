{
  "module_name": "sgiseeq.c",
  "hash_id": "98f1782741dd5e270d1627a05b3231500a2c689c288563ce662e497977cb9e10",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/seeq/sgiseeq.c",
  "human_readable_source": "\n \n\n#undef DEBUG\n\n#include <linux/dma-mapping.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/platform_device.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n\n#include <asm/sgi/hpc3.h>\n#include <asm/sgi/ip22.h>\n#include <asm/sgi/seeq.h>\n\n#include \"sgiseeq.h\"\n\nstatic char *sgiseeqstr = \"SGI Seeq8003\";\n\n \n\n \n#define SEEQ_RX_BUFFERS  16\n#define SEEQ_TX_BUFFERS  16\n\n#define PKT_BUF_SZ       1584\n\n#define NEXT_RX(i)  (((i) + 1) & (SEEQ_RX_BUFFERS - 1))\n#define NEXT_TX(i)  (((i) + 1) & (SEEQ_TX_BUFFERS - 1))\n#define PREV_RX(i)  (((i) - 1) & (SEEQ_RX_BUFFERS - 1))\n#define PREV_TX(i)  (((i) - 1) & (SEEQ_TX_BUFFERS - 1))\n\n#define TX_BUFFS_AVAIL(sp) ((sp->tx_old <= sp->tx_new) ? \\\n\t\t\t    sp->tx_old + (SEEQ_TX_BUFFERS - 1) - sp->tx_new : \\\n\t\t\t    sp->tx_old - sp->tx_new - 1)\n\n#define VIRT_TO_DMA(sp, v) ((sp)->srings_dma +                                 \\\n\t\t\t\t  (dma_addr_t)((unsigned long)(v) -            \\\n\t\t\t\t\t       (unsigned long)((sp)->rx_desc)))\n\n \nstatic int rx_copybreak = 100;\n\n#define PAD_SIZE    (128 - sizeof(struct hpc_dma_desc) - sizeof(void *))\n\nstruct sgiseeq_rx_desc {\n\tvolatile struct hpc_dma_desc rdma;\n\tu8 padding[PAD_SIZE];\n\tstruct sk_buff *skb;\n};\n\nstruct sgiseeq_tx_desc {\n\tvolatile struct hpc_dma_desc tdma;\n\tu8 padding[PAD_SIZE];\n\tstruct sk_buff *skb;\n};\n\n \nstruct sgiseeq_init_block {  \n\tstruct sgiseeq_rx_desc rxvector[SEEQ_RX_BUFFERS];\n\tstruct sgiseeq_tx_desc txvector[SEEQ_TX_BUFFERS];\n};\n\nstruct sgiseeq_private {\n\tstruct sgiseeq_init_block *srings;\n\tdma_addr_t srings_dma;\n\n\t \n\tstruct sgiseeq_rx_desc *rx_desc;\n\tstruct sgiseeq_tx_desc *tx_desc;\n\n\tchar *name;\n\tstruct hpc3_ethregs *hregs;\n\tstruct sgiseeq_regs *sregs;\n\n\t \n\tunsigned int rx_new, tx_new;\n\tunsigned int rx_old, tx_old;\n\n\tint is_edlc;\n\tunsigned char control;\n\tunsigned char mode;\n\n\tspinlock_t tx_lock;\n};\n\nstatic inline void dma_sync_desc_cpu(struct net_device *dev, void *addr)\n{\n\tstruct sgiseeq_private *sp = netdev_priv(dev);\n\n\tdma_sync_single_for_cpu(dev->dev.parent, VIRT_TO_DMA(sp, addr),\n\t\t\tsizeof(struct sgiseeq_rx_desc), DMA_BIDIRECTIONAL);\n}\n\nstatic inline void dma_sync_desc_dev(struct net_device *dev, void *addr)\n{\n\tstruct sgiseeq_private *sp = netdev_priv(dev);\n\n\tdma_sync_single_for_device(dev->dev.parent, VIRT_TO_DMA(sp, addr),\n\t\t\tsizeof(struct sgiseeq_rx_desc), DMA_BIDIRECTIONAL);\n}\n\nstatic inline void hpc3_eth_reset(struct hpc3_ethregs *hregs)\n{\n\thregs->reset = HPC3_ERST_CRESET | HPC3_ERST_CLRIRQ;\n\tudelay(20);\n\thregs->reset = 0;\n}\n\nstatic inline void reset_hpc3_and_seeq(struct hpc3_ethregs *hregs,\n\t\t\t\t       struct sgiseeq_regs *sregs)\n{\n\thregs->rx_ctrl = hregs->tx_ctrl = 0;\n\thpc3_eth_reset(hregs);\n}\n\n#define RSTAT_GO_BITS (SEEQ_RCMD_IGOOD | SEEQ_RCMD_IEOF | SEEQ_RCMD_ISHORT | \\\n\t\t       SEEQ_RCMD_IDRIB | SEEQ_RCMD_ICRC)\n\nstatic inline void seeq_go(struct sgiseeq_private *sp,\n\t\t\t   struct hpc3_ethregs *hregs,\n\t\t\t   struct sgiseeq_regs *sregs)\n{\n\tsregs->rstat = sp->mode | RSTAT_GO_BITS;\n\thregs->rx_ctrl = HPC3_ERXCTRL_ACTIVE;\n}\n\nstatic inline void __sgiseeq_set_mac_address(struct net_device *dev)\n{\n\tstruct sgiseeq_private *sp = netdev_priv(dev);\n\tstruct sgiseeq_regs *sregs = sp->sregs;\n\tint i;\n\n\tsregs->tstat = SEEQ_TCMD_RB0;\n\tfor (i = 0; i < 6; i++)\n\t\tsregs->rw.eth_addr[i] = dev->dev_addr[i];\n}\n\nstatic int sgiseeq_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct sgiseeq_private *sp = netdev_priv(dev);\n\tstruct sockaddr *sa = addr;\n\n\teth_hw_addr_set(dev, sa->sa_data);\n\n\tspin_lock_irq(&sp->tx_lock);\n\t__sgiseeq_set_mac_address(dev);\n\tspin_unlock_irq(&sp->tx_lock);\n\n\treturn 0;\n}\n\n#define TCNTINFO_INIT (HPCDMA_EOX | HPCDMA_ETXD)\n#define RCNTCFG_INIT  (HPCDMA_OWN | HPCDMA_EORP | HPCDMA_XIE)\n#define RCNTINFO_INIT (RCNTCFG_INIT | (PKT_BUF_SZ & HPCDMA_BCNT))\n\nstatic int seeq_init_ring(struct net_device *dev)\n{\n\tstruct sgiseeq_private *sp = netdev_priv(dev);\n\tint i;\n\n\tnetif_stop_queue(dev);\n\tsp->rx_new = sp->tx_new = 0;\n\tsp->rx_old = sp->tx_old = 0;\n\n\t__sgiseeq_set_mac_address(dev);\n\n\t \n\tfor(i = 0; i < SEEQ_TX_BUFFERS; i++) {\n\t\tsp->tx_desc[i].tdma.cntinfo = TCNTINFO_INIT;\n\t\tdma_sync_desc_dev(dev, &sp->tx_desc[i]);\n\t}\n\n\t \n\tfor (i = 0; i < SEEQ_RX_BUFFERS; i++) {\n\t\tif (!sp->rx_desc[i].skb) {\n\t\t\tdma_addr_t dma_addr;\n\t\t\tstruct sk_buff *skb = netdev_alloc_skb(dev, PKT_BUF_SZ);\n\n\t\t\tif (skb == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t\tskb_reserve(skb, 2);\n\t\t\tdma_addr = dma_map_single(dev->dev.parent,\n\t\t\t\t\t\t  skb->data - 2,\n\t\t\t\t\t\t  PKT_BUF_SZ, DMA_FROM_DEVICE);\n\t\t\tsp->rx_desc[i].skb = skb;\n\t\t\tsp->rx_desc[i].rdma.pbuf = dma_addr;\n\t\t}\n\t\tsp->rx_desc[i].rdma.cntinfo = RCNTINFO_INIT;\n\t\tdma_sync_desc_dev(dev, &sp->rx_desc[i]);\n\t}\n\tsp->rx_desc[i - 1].rdma.cntinfo |= HPCDMA_EOR;\n\tdma_sync_desc_dev(dev, &sp->rx_desc[i - 1]);\n\treturn 0;\n}\n\nstatic void seeq_purge_ring(struct net_device *dev)\n{\n\tstruct sgiseeq_private *sp = netdev_priv(dev);\n\tint i;\n\n\t \n\tfor (i = 0; i < SEEQ_TX_BUFFERS; i++) {\n\t\tif (sp->tx_desc[i].skb) {\n\t\t\tdev_kfree_skb(sp->tx_desc[i].skb);\n\t\t\tsp->tx_desc[i].skb = NULL;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < SEEQ_RX_BUFFERS; i++) {\n\t\tif (sp->rx_desc[i].skb) {\n\t\t\tdev_kfree_skb(sp->rx_desc[i].skb);\n\t\t\tsp->rx_desc[i].skb = NULL;\n\t\t}\n\t}\n}\n\n#ifdef DEBUG\nstatic struct sgiseeq_private *gpriv;\nstatic struct net_device *gdev;\n\nstatic void sgiseeq_dump_rings(void)\n{\n\tstatic int once;\n\tstruct sgiseeq_rx_desc *r = gpriv->rx_desc;\n\tstruct sgiseeq_tx_desc *t = gpriv->tx_desc;\n\tstruct hpc3_ethregs *hregs = gpriv->hregs;\n\tint i;\n\n\tif (once)\n\t\treturn;\n\tonce++;\n\tprintk(\"RING DUMP:\\n\");\n\tfor (i = 0; i < SEEQ_RX_BUFFERS; i++) {\n\t\tprintk(\"RX [%d]: @(%p) [%08x,%08x,%08x] \",\n\t\t       i, (&r[i]), r[i].rdma.pbuf, r[i].rdma.cntinfo,\n\t\t       r[i].rdma.pnext);\n\t\ti += 1;\n\t\tprintk(\"-- [%d]: @(%p) [%08x,%08x,%08x]\\n\",\n\t\t       i, (&r[i]), r[i].rdma.pbuf, r[i].rdma.cntinfo,\n\t\t       r[i].rdma.pnext);\n\t}\n\tfor (i = 0; i < SEEQ_TX_BUFFERS; i++) {\n\t\tprintk(\"TX [%d]: @(%p) [%08x,%08x,%08x] \",\n\t\t       i, (&t[i]), t[i].tdma.pbuf, t[i].tdma.cntinfo,\n\t\t       t[i].tdma.pnext);\n\t\ti += 1;\n\t\tprintk(\"-- [%d]: @(%p) [%08x,%08x,%08x]\\n\",\n\t\t       i, (&t[i]), t[i].tdma.pbuf, t[i].tdma.cntinfo,\n\t\t       t[i].tdma.pnext);\n\t}\n\tprintk(\"INFO: [rx_new = %d rx_old=%d] [tx_new = %d tx_old = %d]\\n\",\n\t       gpriv->rx_new, gpriv->rx_old, gpriv->tx_new, gpriv->tx_old);\n\tprintk(\"RREGS: rx_cbptr[%08x] rx_ndptr[%08x] rx_ctrl[%08x]\\n\",\n\t       hregs->rx_cbptr, hregs->rx_ndptr, hregs->rx_ctrl);\n\tprintk(\"TREGS: tx_cbptr[%08x] tx_ndptr[%08x] tx_ctrl[%08x]\\n\",\n\t       hregs->tx_cbptr, hregs->tx_ndptr, hregs->tx_ctrl);\n}\n#endif\n\n#define TSTAT_INIT_SEEQ (SEEQ_TCMD_IPT|SEEQ_TCMD_I16|SEEQ_TCMD_IC|SEEQ_TCMD_IUF)\n#define TSTAT_INIT_EDLC ((TSTAT_INIT_SEEQ) | SEEQ_TCMD_RB2)\n\nstatic int init_seeq(struct net_device *dev, struct sgiseeq_private *sp,\n\t\t     struct sgiseeq_regs *sregs)\n{\n\tstruct hpc3_ethregs *hregs = sp->hregs;\n\tint err;\n\n\treset_hpc3_and_seeq(hregs, sregs);\n\terr = seeq_init_ring(dev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (sp->is_edlc) {\n\t\tsregs->tstat = TSTAT_INIT_EDLC;\n\t\tsregs->rw.wregs.control = sp->control;\n\t\tsregs->rw.wregs.frame_gap = 0;\n\t} else {\n\t\tsregs->tstat = TSTAT_INIT_SEEQ;\n\t}\n\n\thregs->rx_ndptr = VIRT_TO_DMA(sp, sp->rx_desc);\n\thregs->tx_ndptr = VIRT_TO_DMA(sp, sp->tx_desc);\n\n\tseeq_go(sp, hregs, sregs);\n\treturn 0;\n}\n\nstatic void record_rx_errors(struct net_device *dev, unsigned char status)\n{\n\tif (status & SEEQ_RSTAT_OVERF ||\n\t    status & SEEQ_RSTAT_SFRAME)\n\t\tdev->stats.rx_over_errors++;\n\tif (status & SEEQ_RSTAT_CERROR)\n\t\tdev->stats.rx_crc_errors++;\n\tif (status & SEEQ_RSTAT_DERROR)\n\t\tdev->stats.rx_frame_errors++;\n\tif (status & SEEQ_RSTAT_REOF)\n\t\tdev->stats.rx_errors++;\n}\n\nstatic inline void rx_maybe_restart(struct sgiseeq_private *sp,\n\t\t\t\t    struct hpc3_ethregs *hregs,\n\t\t\t\t    struct sgiseeq_regs *sregs)\n{\n\tif (!(hregs->rx_ctrl & HPC3_ERXCTRL_ACTIVE)) {\n\t\thregs->rx_ndptr = VIRT_TO_DMA(sp, sp->rx_desc + sp->rx_new);\n\t\tseeq_go(sp, hregs, sregs);\n\t}\n}\n\nstatic inline void sgiseeq_rx(struct net_device *dev, struct sgiseeq_private *sp,\n\t\t\t      struct hpc3_ethregs *hregs,\n\t\t\t      struct sgiseeq_regs *sregs)\n{\n\tstruct sgiseeq_rx_desc *rd;\n\tstruct sk_buff *skb = NULL;\n\tstruct sk_buff *newskb;\n\tunsigned char pkt_status;\n\tint len = 0;\n\tunsigned int orig_end = PREV_RX(sp->rx_new);\n\n\t \n\trd = &sp->rx_desc[sp->rx_new];\n\tdma_sync_desc_cpu(dev, rd);\n\twhile (!(rd->rdma.cntinfo & HPCDMA_OWN)) {\n\t\tlen = PKT_BUF_SZ - (rd->rdma.cntinfo & HPCDMA_BCNT) - 3;\n\t\tdma_unmap_single(dev->dev.parent, rd->rdma.pbuf,\n\t\t\t\t PKT_BUF_SZ, DMA_FROM_DEVICE);\n\t\tpkt_status = rd->skb->data[len];\n\t\tif (pkt_status & SEEQ_RSTAT_FIG) {\n\t\t\t \n\t\t\t \n\t\t\tif (!ether_addr_equal(rd->skb->data + 6, dev->dev_addr)) {\n\t\t\t\tif (len > rx_copybreak) {\n\t\t\t\t\tskb = rd->skb;\n\t\t\t\t\tnewskb = netdev_alloc_skb(dev, PKT_BUF_SZ);\n\t\t\t\t\tif (!newskb) {\n\t\t\t\t\t\tnewskb = skb;\n\t\t\t\t\t\tskb = NULL;\n\t\t\t\t\t\tgoto memory_squeeze;\n\t\t\t\t\t}\n\t\t\t\t\tskb_reserve(newskb, 2);\n\t\t\t\t} else {\n\t\t\t\t\tskb = netdev_alloc_skb_ip_align(dev, len);\n\t\t\t\t\tif (skb)\n\t\t\t\t\t\tskb_copy_to_linear_data(skb, rd->skb->data, len);\n\n\t\t\t\t\tnewskb = rd->skb;\n\t\t\t\t}\nmemory_squeeze:\n\t\t\t\tif (skb) {\n\t\t\t\t\tskb_put(skb, len);\n\t\t\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\t\t\tnetif_rx(skb);\n\t\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\t\tdev->stats.rx_bytes += len;\n\t\t\t\t} else {\n\t\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tnewskb = rd->skb;\n\t\t\t}\n\t\t} else {\n\t\t\trecord_rx_errors(dev, pkt_status);\n\t\t\tnewskb = rd->skb;\n\t\t}\n\t\trd->skb = newskb;\n\t\trd->rdma.pbuf = dma_map_single(dev->dev.parent,\n\t\t\t\t\t       newskb->data - 2,\n\t\t\t\t\t       PKT_BUF_SZ, DMA_FROM_DEVICE);\n\n\t\t \n\t\trd->rdma.cntinfo = RCNTINFO_INIT;\n\t\tsp->rx_new = NEXT_RX(sp->rx_new);\n\t\tdma_sync_desc_dev(dev, rd);\n\t\trd = &sp->rx_desc[sp->rx_new];\n\t\tdma_sync_desc_cpu(dev, rd);\n\t}\n\tdma_sync_desc_dev(dev, rd);\n\n\tdma_sync_desc_cpu(dev, &sp->rx_desc[orig_end]);\n\tsp->rx_desc[orig_end].rdma.cntinfo &= ~(HPCDMA_EOR);\n\tdma_sync_desc_dev(dev, &sp->rx_desc[orig_end]);\n\tdma_sync_desc_cpu(dev, &sp->rx_desc[PREV_RX(sp->rx_new)]);\n\tsp->rx_desc[PREV_RX(sp->rx_new)].rdma.cntinfo |= HPCDMA_EOR;\n\tdma_sync_desc_dev(dev, &sp->rx_desc[PREV_RX(sp->rx_new)]);\n\trx_maybe_restart(sp, hregs, sregs);\n}\n\nstatic inline void tx_maybe_reset_collisions(struct sgiseeq_private *sp,\n\t\t\t\t\t     struct sgiseeq_regs *sregs)\n{\n\tif (sp->is_edlc) {\n\t\tsregs->rw.wregs.control = sp->control & ~(SEEQ_CTRL_XCNT);\n\t\tsregs->rw.wregs.control = sp->control;\n\t}\n}\n\nstatic inline void kick_tx(struct net_device *dev,\n\t\t\t   struct sgiseeq_private *sp,\n\t\t\t   struct hpc3_ethregs *hregs)\n{\n\tstruct sgiseeq_tx_desc *td;\n\tint i = sp->tx_old;\n\n\t \n\ttd = &sp->tx_desc[i];\n\tdma_sync_desc_cpu(dev, td);\n\twhile ((td->tdma.cntinfo & (HPCDMA_XIU | HPCDMA_ETXD)) ==\n\t      (HPCDMA_XIU | HPCDMA_ETXD)) {\n\t\ti = NEXT_TX(i);\n\t\ttd = &sp->tx_desc[i];\n\t\tdma_sync_desc_cpu(dev, td);\n\t}\n\tif (td->tdma.cntinfo & HPCDMA_XIU) {\n\t\tdma_sync_desc_dev(dev, td);\n\t\thregs->tx_ndptr = VIRT_TO_DMA(sp, td);\n\t\thregs->tx_ctrl = HPC3_ETXCTRL_ACTIVE;\n\t}\n}\n\nstatic inline void sgiseeq_tx(struct net_device *dev, struct sgiseeq_private *sp,\n\t\t\t      struct hpc3_ethregs *hregs,\n\t\t\t      struct sgiseeq_regs *sregs)\n{\n\tstruct sgiseeq_tx_desc *td;\n\tunsigned long status = hregs->tx_ctrl;\n\tint j;\n\n\ttx_maybe_reset_collisions(sp, sregs);\n\n\tif (!(status & (HPC3_ETXCTRL_ACTIVE | SEEQ_TSTAT_PTRANS))) {\n\t\t \n\t\tif (status & SEEQ_TSTAT_R16)\n\t\t\tdev->stats.tx_aborted_errors++;\n\t\tif (status & SEEQ_TSTAT_UFLOW)\n\t\t\tdev->stats.tx_fifo_errors++;\n\t\tif (status & SEEQ_TSTAT_LCLS)\n\t\t\tdev->stats.collisions++;\n\t}\n\n\t \n\tfor (j = sp->tx_old; j != sp->tx_new; j = NEXT_TX(j)) {\n\t\ttd = &sp->tx_desc[j];\n\n\t\tdma_sync_desc_cpu(dev, td);\n\t\tif (!(td->tdma.cntinfo & (HPCDMA_XIU)))\n\t\t\tbreak;\n\t\tif (!(td->tdma.cntinfo & (HPCDMA_ETXD))) {\n\t\t\tdma_sync_desc_dev(dev, td);\n\t\t\tif (!(status & HPC3_ETXCTRL_ACTIVE)) {\n\t\t\t\thregs->tx_ndptr = VIRT_TO_DMA(sp, td);\n\t\t\t\thregs->tx_ctrl = HPC3_ETXCTRL_ACTIVE;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tdev->stats.tx_packets++;\n\t\tsp->tx_old = NEXT_TX(sp->tx_old);\n\t\ttd->tdma.cntinfo &= ~(HPCDMA_XIU | HPCDMA_XIE);\n\t\ttd->tdma.cntinfo |= HPCDMA_EOX;\n\t\tif (td->skb) {\n\t\t\tdev_kfree_skb_any(td->skb);\n\t\t\ttd->skb = NULL;\n\t\t}\n\t\tdma_sync_desc_dev(dev, td);\n\t}\n}\n\nstatic irqreturn_t sgiseeq_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = (struct net_device *) dev_id;\n\tstruct sgiseeq_private *sp = netdev_priv(dev);\n\tstruct hpc3_ethregs *hregs = sp->hregs;\n\tstruct sgiseeq_regs *sregs = sp->sregs;\n\n\tspin_lock(&sp->tx_lock);\n\n\t \n\thregs->reset = HPC3_ERST_CLRIRQ;\n\n\t \n\tsgiseeq_rx(dev, sp, hregs, sregs);\n\n\t \n\tif (sp->tx_old != sp->tx_new)\n\t\tsgiseeq_tx(dev, sp, hregs, sregs);\n\n\tif ((TX_BUFFS_AVAIL(sp) > 0) && netif_queue_stopped(dev)) {\n\t\tnetif_wake_queue(dev);\n\t}\n\tspin_unlock(&sp->tx_lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sgiseeq_open(struct net_device *dev)\n{\n\tstruct sgiseeq_private *sp = netdev_priv(dev);\n\tstruct sgiseeq_regs *sregs = sp->sregs;\n\tunsigned int irq = dev->irq;\n\tint err;\n\n\tif (request_irq(irq, sgiseeq_interrupt, 0, sgiseeqstr, dev)) {\n\t\tprintk(KERN_ERR \"Seeq8003: Can't get irq %d\\n\", dev->irq);\n\t\treturn -EAGAIN;\n\t}\n\n\terr = init_seeq(dev, sp, sregs);\n\tif (err)\n\t\tgoto out_free_irq;\n\n\tnetif_start_queue(dev);\n\n\treturn 0;\n\nout_free_irq:\n\tfree_irq(irq, dev);\n\n\treturn err;\n}\n\nstatic int sgiseeq_close(struct net_device *dev)\n{\n\tstruct sgiseeq_private *sp = netdev_priv(dev);\n\tstruct sgiseeq_regs *sregs = sp->sregs;\n\tunsigned int irq = dev->irq;\n\n\tnetif_stop_queue(dev);\n\n\t \n\treset_hpc3_and_seeq(sp->hregs, sregs);\n\tfree_irq(irq, dev);\n\tseeq_purge_ring(dev);\n\n\treturn 0;\n}\n\nstatic inline int sgiseeq_reset(struct net_device *dev)\n{\n\tstruct sgiseeq_private *sp = netdev_priv(dev);\n\tstruct sgiseeq_regs *sregs = sp->sregs;\n\tint err;\n\n\terr = init_seeq(dev, sp, sregs);\n\tif (err)\n\t\treturn err;\n\n\tnetif_trans_update(dev);  \n\tnetif_wake_queue(dev);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t\nsgiseeq_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct sgiseeq_private *sp = netdev_priv(dev);\n\tstruct hpc3_ethregs *hregs = sp->hregs;\n\tunsigned long flags;\n\tstruct sgiseeq_tx_desc *td;\n\tint len, entry;\n\n\tspin_lock_irqsave(&sp->tx_lock, flags);\n\n\t \n\tlen = skb->len;\n\tif (len < ETH_ZLEN) {\n\t\tif (skb_padto(skb, ETH_ZLEN)) {\n\t\t\tspin_unlock_irqrestore(&sp->tx_lock, flags);\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t\tlen = ETH_ZLEN;\n\t}\n\n\tdev->stats.tx_bytes += len;\n\tentry = sp->tx_new;\n\ttd = &sp->tx_desc[entry];\n\tdma_sync_desc_cpu(dev, td);\n\n\t \n\ttd->skb = skb;\n\ttd->tdma.pbuf = dma_map_single(dev->dev.parent, skb->data,\n\t\t\t\t       len, DMA_TO_DEVICE);\n\ttd->tdma.cntinfo = (len & HPCDMA_BCNT) |\n\t                   HPCDMA_XIU | HPCDMA_EOXP | HPCDMA_XIE | HPCDMA_EOX;\n\tdma_sync_desc_dev(dev, td);\n\tif (sp->tx_old != sp->tx_new) {\n\t\tstruct sgiseeq_tx_desc *backend;\n\n\t\tbackend = &sp->tx_desc[PREV_TX(sp->tx_new)];\n\t\tdma_sync_desc_cpu(dev, backend);\n\t\tbackend->tdma.cntinfo &= ~HPCDMA_EOX;\n\t\tdma_sync_desc_dev(dev, backend);\n\t}\n\tsp->tx_new = NEXT_TX(sp->tx_new);  \n\n\t \n\tif (!(hregs->tx_ctrl & HPC3_ETXCTRL_ACTIVE))\n\t\tkick_tx(dev, sp, hregs);\n\n\tif (!TX_BUFFS_AVAIL(sp))\n\t\tnetif_stop_queue(dev);\n\tspin_unlock_irqrestore(&sp->tx_lock, flags);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tprintk(KERN_NOTICE \"%s: transmit timed out, resetting\\n\", dev->name);\n\tsgiseeq_reset(dev);\n\n\tnetif_trans_update(dev);  \n\tnetif_wake_queue(dev);\n}\n\nstatic void sgiseeq_set_multicast(struct net_device *dev)\n{\n\tstruct sgiseeq_private *sp = netdev_priv(dev);\n\tunsigned char oldmode = sp->mode;\n\n\tif(dev->flags & IFF_PROMISC)\n\t\tsp->mode = SEEQ_RCMD_RANY;\n\telse if ((dev->flags & IFF_ALLMULTI) || !netdev_mc_empty(dev))\n\t\tsp->mode = SEEQ_RCMD_RBMCAST;\n\telse\n\t\tsp->mode = SEEQ_RCMD_RBCAST;\n\n\t \n\n\tif (oldmode != sp->mode)\n\t\tsgiseeq_reset(dev);\n}\n\nstatic inline void setup_tx_ring(struct net_device *dev,\n\t\t\t\t struct sgiseeq_tx_desc *buf,\n\t\t\t\t int nbufs)\n{\n\tstruct sgiseeq_private *sp = netdev_priv(dev);\n\tint i = 0;\n\n\twhile (i < (nbufs - 1)) {\n\t\tbuf[i].tdma.pnext = VIRT_TO_DMA(sp, buf + i + 1);\n\t\tbuf[i].tdma.pbuf = 0;\n\t\tdma_sync_desc_dev(dev, &buf[i]);\n\t\ti++;\n\t}\n\tbuf[i].tdma.pnext = VIRT_TO_DMA(sp, buf);\n\tdma_sync_desc_dev(dev, &buf[i]);\n}\n\nstatic inline void setup_rx_ring(struct net_device *dev,\n\t\t\t\t struct sgiseeq_rx_desc *buf,\n\t\t\t\t int nbufs)\n{\n\tstruct sgiseeq_private *sp = netdev_priv(dev);\n\tint i = 0;\n\n\twhile (i < (nbufs - 1)) {\n\t\tbuf[i].rdma.pnext = VIRT_TO_DMA(sp, buf + i + 1);\n\t\tbuf[i].rdma.pbuf = 0;\n\t\tdma_sync_desc_dev(dev, &buf[i]);\n\t\ti++;\n\t}\n\tbuf[i].rdma.pbuf = 0;\n\tbuf[i].rdma.pnext = VIRT_TO_DMA(sp, buf);\n\tdma_sync_desc_dev(dev, &buf[i]);\n}\n\nstatic const struct net_device_ops sgiseeq_netdev_ops = {\n\t.ndo_open\t\t= sgiseeq_open,\n\t.ndo_stop\t\t= sgiseeq_close,\n\t.ndo_start_xmit\t\t= sgiseeq_start_xmit,\n\t.ndo_tx_timeout\t\t= timeout,\n\t.ndo_set_rx_mode\t= sgiseeq_set_multicast,\n\t.ndo_set_mac_address\t= sgiseeq_set_mac_address,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int sgiseeq_probe(struct platform_device *pdev)\n{\n\tstruct sgiseeq_platform_data *pd = dev_get_platdata(&pdev->dev);\n\tstruct hpc3_regs *hpcregs = pd->hpc;\n\tstruct sgiseeq_init_block *sr;\n\tunsigned int irq = pd->irq;\n\tstruct sgiseeq_private *sp;\n\tstruct net_device *dev;\n\tint err;\n\n\tdev = alloc_etherdev(sizeof (struct sgiseeq_private));\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tplatform_set_drvdata(pdev, dev);\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\tsp = netdev_priv(dev);\n\n\t \n\tsr = dma_alloc_noncoherent(&pdev->dev, sizeof(*sp->srings),\n\t\t\t&sp->srings_dma, DMA_BIDIRECTIONAL, GFP_KERNEL);\n\tif (!sr) {\n\t\tprintk(KERN_ERR \"Sgiseeq: Page alloc failed, aborting.\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_out_free_dev;\n\t}\n\tsp->srings = sr;\n\tsp->rx_desc = sp->srings->rxvector;\n\tsp->tx_desc = sp->srings->txvector;\n\tspin_lock_init(&sp->tx_lock);\n\n\t \n\tsetup_rx_ring(dev, sp->rx_desc, SEEQ_RX_BUFFERS);\n\tsetup_tx_ring(dev, sp->tx_desc, SEEQ_TX_BUFFERS);\n\n\teth_hw_addr_set(dev, pd->mac);\n\n#ifdef DEBUG\n\tgpriv = sp;\n\tgdev = dev;\n#endif\n\tsp->sregs = (struct sgiseeq_regs *) &hpcregs->eth_ext[0];\n\tsp->hregs = &hpcregs->ethregs;\n\tsp->name = sgiseeqstr;\n\tsp->mode = SEEQ_RCMD_RBCAST;\n\n\t \n\tsp->hregs->pconfig = 0x161;\n\tsp->hregs->dconfig = HPC3_EDCFG_FIRQ | HPC3_EDCFG_FEOP |\n\t\t\t     HPC3_EDCFG_FRXDC | HPC3_EDCFG_PTO | 0x026;\n\n\t \n\tsp->hregs->pconfig = 0x161;\n\tsp->hregs->dconfig = HPC3_EDCFG_FIRQ | HPC3_EDCFG_FEOP |\n\t\t\t     HPC3_EDCFG_FRXDC | HPC3_EDCFG_PTO | 0x026;\n\n\t \n\thpc3_eth_reset(sp->hregs);\n\n\tsp->is_edlc = !(sp->sregs->rw.rregs.collision_tx[0] & 0xff);\n\tif (sp->is_edlc)\n\t\tsp->control = SEEQ_CTRL_XCNT | SEEQ_CTRL_ACCNT |\n\t\t\t      SEEQ_CTRL_SFLAG | SEEQ_CTRL_ESHORT |\n\t\t\t      SEEQ_CTRL_ENCARR;\n\n\tdev->netdev_ops\t\t= &sgiseeq_netdev_ops;\n\tdev->watchdog_timeo\t= (200 * HZ) / 1000;\n\tdev->irq\t\t= irq;\n\n\tif (register_netdev(dev)) {\n\t\tprintk(KERN_ERR \"Sgiseeq: Cannot register net device, \"\n\t\t       \"aborting.\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_out_free_attrs;\n\t}\n\n\tprintk(KERN_INFO \"%s: %s %pM\\n\", dev->name, sgiseeqstr, dev->dev_addr);\n\n\treturn 0;\n\nerr_out_free_attrs:\n\tdma_free_noncoherent(&pdev->dev, sizeof(*sp->srings), sp->srings,\n\t\t       sp->srings_dma, DMA_BIDIRECTIONAL);\nerr_out_free_dev:\n\tfree_netdev(dev);\n\nerr_out:\n\treturn err;\n}\n\nstatic int sgiseeq_remove(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\tstruct sgiseeq_private *sp = netdev_priv(dev);\n\n\tunregister_netdev(dev);\n\tdma_free_noncoherent(&pdev->dev, sizeof(*sp->srings), sp->srings,\n\t\t       sp->srings_dma, DMA_BIDIRECTIONAL);\n\tfree_netdev(dev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver sgiseeq_driver = {\n\t.probe\t= sgiseeq_probe,\n\t.remove\t= sgiseeq_remove,\n\t.driver = {\n\t\t.name\t= \"sgiseeq\",\n\t}\n};\n\nmodule_platform_driver(sgiseeq_driver);\n\nMODULE_DESCRIPTION(\"SGI Seeq 8003 driver\");\nMODULE_AUTHOR(\"Linux/MIPS Mailing List <linux-mips@linux-mips.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:sgiseeq\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}