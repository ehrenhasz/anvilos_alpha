{
  "module_name": "adin1110.c",
  "hash_id": "06b247c9b68013dfa5559bfbda6db3eb3a1ba5139a9fade4014d730657ef41af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/adi/adin1110.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/cache.h>\n#include <linux/crc8.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/if_bridge.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/gpio.h>\n#include <linux/kernel.h>\n#include <linux/mii.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/regulator/consumer.h>\n#include <linux/phy.h>\n#include <linux/property.h>\n#include <linux/spi/spi.h>\n\n#include <net/switchdev.h>\n\n#include <asm/unaligned.h>\n\n#define ADIN1110_PHY_ID\t\t\t\t0x1\n\n#define ADIN1110_RESET\t\t\t\t0x03\n#define   ADIN1110_SWRESET\t\t\tBIT(0)\n\n#define ADIN1110_CONFIG1\t\t\t0x04\n#define   ADIN1110_CONFIG1_SYNC\t\t\tBIT(15)\n\n#define ADIN1110_CONFIG2\t\t\t0x06\n#define   ADIN2111_P2_FWD_UNK2HOST\t\tBIT(12)\n#define   ADIN2111_PORT_CUT_THRU_EN\t\tBIT(11)\n#define   ADIN1110_CRC_APPEND\t\t\tBIT(5)\n#define   ADIN1110_FWD_UNK2HOST\t\t\tBIT(2)\n\n#define ADIN1110_STATUS0\t\t\t0x08\n\n#define ADIN1110_STATUS1\t\t\t0x09\n#define   ADIN2111_P2_RX_RDY\t\t\tBIT(17)\n#define   ADIN1110_SPI_ERR\t\t\tBIT(10)\n#define   ADIN1110_RX_RDY\t\t\tBIT(4)\n\n#define ADIN1110_IMASK1\t\t\t\t0x0D\n#define   ADIN2111_RX_RDY_IRQ\t\t\tBIT(17)\n#define   ADIN1110_SPI_ERR_IRQ\t\t\tBIT(10)\n#define   ADIN1110_RX_RDY_IRQ\t\t\tBIT(4)\n#define   ADIN1110_TX_RDY_IRQ\t\t\tBIT(3)\n\n#define ADIN1110_MDIOACC\t\t\t0x20\n#define   ADIN1110_MDIO_TRDONE\t\t\tBIT(31)\n#define   ADIN1110_MDIO_ST\t\t\tGENMASK(29, 28)\n#define   ADIN1110_MDIO_OP\t\t\tGENMASK(27, 26)\n#define   ADIN1110_MDIO_PRTAD\t\t\tGENMASK(25, 21)\n#define   ADIN1110_MDIO_DEVAD\t\t\tGENMASK(20, 16)\n#define   ADIN1110_MDIO_DATA\t\t\tGENMASK(15, 0)\n\n#define ADIN1110_TX_FSIZE\t\t\t0x30\n#define ADIN1110_TX\t\t\t\t0x31\n#define ADIN1110_TX_SPACE\t\t\t0x32\n\n#define ADIN1110_MAC_ADDR_FILTER_UPR\t\t0x50\n#define   ADIN2111_MAC_ADDR_APPLY2PORT2\t\tBIT(31)\n#define   ADIN1110_MAC_ADDR_APPLY2PORT\t\tBIT(30)\n#define   ADIN2111_MAC_ADDR_TO_OTHER_PORT\tBIT(17)\n#define   ADIN1110_MAC_ADDR_TO_HOST\t\tBIT(16)\n\n#define ADIN1110_MAC_ADDR_FILTER_LWR\t\t0x51\n\n#define ADIN1110_MAC_ADDR_MASK_UPR\t\t0x70\n#define ADIN1110_MAC_ADDR_MASK_LWR\t\t0x71\n\n#define ADIN1110_RX_FSIZE\t\t\t0x90\n#define ADIN1110_RX\t\t\t\t0x91\n\n#define ADIN2111_RX_P2_FSIZE\t\t\t0xC0\n#define ADIN2111_RX_P2\t\t\t\t0xC1\n\n#define ADIN1110_CLEAR_STATUS0\t\t\t0xFFF\n\n \n#define ADIN1110_MDIO_OP_WR\t\t\t0x1\n#define ADIN1110_MDIO_OP_RD\t\t\t0x3\n\n#define ADIN1110_CD\t\t\t\tBIT(7)\n#define ADIN1110_WRITE\t\t\t\tBIT(5)\n\n#define ADIN1110_MAX_BUFF\t\t\t2048\n#define ADIN1110_MAX_FRAMES_READ\t\t64\n#define ADIN1110_WR_HEADER_LEN\t\t\t2\n#define ADIN1110_FRAME_HEADER_LEN\t\t2\n#define ADIN1110_INTERNAL_SIZE_HEADER_LEN\t2\n#define ADIN1110_RD_HEADER_LEN\t\t\t3\n#define ADIN1110_REG_LEN\t\t\t4\n#define ADIN1110_FEC_LEN\t\t\t4\n\n#define ADIN1110_PHY_ID_VAL\t\t\t0x0283BC91\n#define ADIN2111_PHY_ID_VAL\t\t\t0x0283BCA1\n\n#define ADIN_MAC_MAX_PORTS\t\t\t2\n#define ADIN_MAC_MAX_ADDR_SLOTS\t\t\t16\n\n#define ADIN_MAC_MULTICAST_ADDR_SLOT\t\t0\n#define ADIN_MAC_BROADCAST_ADDR_SLOT\t\t1\n#define ADIN_MAC_P1_ADDR_SLOT\t\t\t2\n#define ADIN_MAC_P2_ADDR_SLOT\t\t\t3\n#define ADIN_MAC_FDB_ADDR_SLOT\t\t\t4\n\nDECLARE_CRC8_TABLE(adin1110_crc_table);\n\nenum adin1110_chips_id {\n\tADIN1110_MAC = 0,\n\tADIN2111_MAC,\n};\n\nstruct adin1110_cfg {\n\tenum adin1110_chips_id\tid;\n\tchar\t\t\tname[MDIO_NAME_SIZE];\n\tu32\t\t\tphy_ids[PHY_MAX_ADDR];\n\tu32\t\t\tports_nr;\n\tu32\t\t\tphy_id_val;\n};\n\nstruct adin1110_port_priv {\n\tstruct adin1110_priv\t\t*priv;\n\tstruct net_device\t\t*netdev;\n\tstruct net_device\t\t*bridge;\n\tstruct phy_device\t\t*phydev;\n\tstruct work_struct\t\ttx_work;\n\tu64\t\t\t\trx_packets;\n\tu64\t\t\t\ttx_packets;\n\tu64\t\t\t\trx_bytes;\n\tu64\t\t\t\ttx_bytes;\n\tstruct work_struct\t\trx_mode_work;\n\tu32\t\t\t\tflags;\n\tstruct sk_buff_head\t\ttxq;\n\tu32\t\t\t\tnr;\n\tu32\t\t\t\tstate;\n\tstruct adin1110_cfg\t\t*cfg;\n};\n\nstruct adin1110_priv {\n\tstruct mutex\t\t\tlock;  \n\tspinlock_t\t\t\tstate_lock;  \n\tstruct mii_bus\t\t\t*mii_bus;\n\tstruct spi_device\t\t*spidev;\n\tbool\t\t\t\tappend_crc;\n\tstruct adin1110_cfg\t\t*cfg;\n\tu32\t\t\t\ttx_space;\n\tu32\t\t\t\tirq_mask;\n\tbool\t\t\t\tforwarding;\n\tint\t\t\t\tirq;\n\tstruct adin1110_port_priv\t*ports[ADIN_MAC_MAX_PORTS];\n\tchar\t\t\t\tmii_bus_name[MII_BUS_ID_SIZE];\n\tu8\t\t\t\tdata[ADIN1110_MAX_BUFF] ____cacheline_aligned;\n};\n\nstruct adin1110_switchdev_event_work {\n\tstruct work_struct work;\n\tstruct switchdev_notifier_fdb_info fdb_info;\n\tstruct adin1110_port_priv *port_priv;\n\tunsigned long event;\n};\n\nstatic struct adin1110_cfg adin1110_cfgs[] = {\n\t{\n\t\t.id = ADIN1110_MAC,\n\t\t.name = \"adin1110\",\n\t\t.phy_ids = {1},\n\t\t.ports_nr = 1,\n\t\t.phy_id_val = ADIN1110_PHY_ID_VAL,\n\t},\n\t{\n\t\t.id = ADIN2111_MAC,\n\t\t.name = \"adin2111\",\n\t\t.phy_ids = {1, 2},\n\t\t.ports_nr = 2,\n\t\t.phy_id_val = ADIN2111_PHY_ID_VAL,\n\t},\n};\n\nstatic u8 adin1110_crc_data(u8 *data, u32 len)\n{\n\treturn crc8(adin1110_crc_table, data, len, 0);\n}\n\nstatic int adin1110_read_reg(struct adin1110_priv *priv, u16 reg, u32 *val)\n{\n\tu32 header_len = ADIN1110_RD_HEADER_LEN;\n\tu32 read_len = ADIN1110_REG_LEN;\n\tstruct spi_transfer t = {0};\n\tint ret;\n\n\tpriv->data[0] = ADIN1110_CD | FIELD_GET(GENMASK(12, 8), reg);\n\tpriv->data[1] = FIELD_GET(GENMASK(7, 0), reg);\n\tpriv->data[2] = 0x00;\n\n\tif (priv->append_crc) {\n\t\tpriv->data[2] = adin1110_crc_data(&priv->data[0], 2);\n\t\tpriv->data[3] = 0x00;\n\t\theader_len++;\n\t}\n\n\tif (priv->append_crc)\n\t\tread_len++;\n\n\tmemset(&priv->data[header_len], 0, read_len);\n\tt.tx_buf = &priv->data[0];\n\tt.rx_buf = &priv->data[0];\n\tt.len = read_len + header_len;\n\n\tret = spi_sync_transfer(priv->spidev, &t, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (priv->append_crc) {\n\t\tu8 recv_crc;\n\t\tu8 crc;\n\n\t\tcrc = adin1110_crc_data(&priv->data[header_len],\n\t\t\t\t\tADIN1110_REG_LEN);\n\t\trecv_crc = priv->data[header_len + ADIN1110_REG_LEN];\n\n\t\tif (crc != recv_crc) {\n\t\t\tdev_err_ratelimited(&priv->spidev->dev, \"CRC error.\");\n\t\t\treturn -EBADMSG;\n\t\t}\n\t}\n\n\t*val = get_unaligned_be32(&priv->data[header_len]);\n\n\treturn ret;\n}\n\nstatic int adin1110_write_reg(struct adin1110_priv *priv, u16 reg, u32 val)\n{\n\tu32 header_len = ADIN1110_WR_HEADER_LEN;\n\tu32 write_len = ADIN1110_REG_LEN;\n\n\tpriv->data[0] = ADIN1110_CD | ADIN1110_WRITE | FIELD_GET(GENMASK(12, 8), reg);\n\tpriv->data[1] = FIELD_GET(GENMASK(7, 0), reg);\n\n\tif (priv->append_crc) {\n\t\tpriv->data[2] = adin1110_crc_data(&priv->data[0], header_len);\n\t\theader_len++;\n\t}\n\n\tput_unaligned_be32(val, &priv->data[header_len]);\n\tif (priv->append_crc) {\n\t\tpriv->data[header_len + write_len] = adin1110_crc_data(&priv->data[header_len],\n\t\t\t\t\t\t\t\t       write_len);\n\t\twrite_len++;\n\t}\n\n\treturn spi_write(priv->spidev, &priv->data[0], header_len + write_len);\n}\n\nstatic int adin1110_set_bits(struct adin1110_priv *priv, u16 reg,\n\t\t\t     unsigned long mask, unsigned long val)\n{\n\tu32 write_val;\n\tint ret;\n\n\tret = adin1110_read_reg(priv, reg, &write_val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tset_mask_bits(&write_val, mask, val);\n\n\treturn adin1110_write_reg(priv, reg, write_val);\n}\n\nstatic int adin1110_round_len(int len)\n{\n\t \n\tlen = ALIGN(len, 4);\n\n\t \n\tif (len + ADIN1110_RD_HEADER_LEN > ADIN1110_MAX_BUFF)\n\t\treturn -EINVAL;\n\n\treturn len;\n}\n\nstatic int adin1110_read_fifo(struct adin1110_port_priv *port_priv)\n{\n\tstruct adin1110_priv *priv = port_priv->priv;\n\tu32 header_len = ADIN1110_RD_HEADER_LEN;\n\tstruct spi_transfer t = {0};\n\tu32 frame_size_no_fcs;\n\tstruct sk_buff *rxb;\n\tu32 frame_size;\n\tint round_len;\n\tu16 reg;\n\tint ret;\n\n\tif (!port_priv->nr) {\n\t\treg = ADIN1110_RX;\n\t\tret = adin1110_read_reg(priv, ADIN1110_RX_FSIZE, &frame_size);\n\t} else {\n\t\treg = ADIN2111_RX_P2;\n\t\tret = adin1110_read_reg(priv, ADIN2111_RX_P2_FSIZE,\n\t\t\t\t\t&frame_size);\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (frame_size < ADIN1110_FRAME_HEADER_LEN + ADIN1110_FEC_LEN)\n\t\treturn ret;\n\n\tround_len = adin1110_round_len(frame_size);\n\tif (round_len < 0)\n\t\treturn ret;\n\n\tframe_size_no_fcs = frame_size - ADIN1110_FRAME_HEADER_LEN - ADIN1110_FEC_LEN;\n\tmemset(priv->data, 0, ADIN1110_RD_HEADER_LEN);\n\n\tpriv->data[0] = ADIN1110_CD | FIELD_GET(GENMASK(12, 8), reg);\n\tpriv->data[1] = FIELD_GET(GENMASK(7, 0), reg);\n\n\tif (priv->append_crc) {\n\t\tpriv->data[2] = adin1110_crc_data(&priv->data[0], 2);\n\t\theader_len++;\n\t}\n\n\trxb = netdev_alloc_skb(port_priv->netdev, round_len + header_len);\n\tif (!rxb)\n\t\treturn -ENOMEM;\n\n\tskb_put(rxb, frame_size_no_fcs + header_len + ADIN1110_FRAME_HEADER_LEN);\n\n\tt.tx_buf = &priv->data[0];\n\tt.rx_buf = &rxb->data[0];\n\tt.len = header_len + round_len;\n\n\tret = spi_sync_transfer(priv->spidev, &t, 1);\n\tif (ret) {\n\t\tkfree_skb(rxb);\n\t\treturn ret;\n\t}\n\n\tskb_pull(rxb, header_len + ADIN1110_FRAME_HEADER_LEN);\n\trxb->protocol = eth_type_trans(rxb, port_priv->netdev);\n\n\tif ((port_priv->flags & IFF_ALLMULTI && rxb->pkt_type == PACKET_MULTICAST) ||\n\t    (port_priv->flags & IFF_BROADCAST && rxb->pkt_type == PACKET_BROADCAST))\n\t\trxb->offload_fwd_mark = port_priv->priv->forwarding;\n\n\tnetif_rx(rxb);\n\n\tport_priv->rx_bytes += frame_size - ADIN1110_FRAME_HEADER_LEN;\n\tport_priv->rx_packets++;\n\n\treturn 0;\n}\n\nstatic int adin1110_write_fifo(struct adin1110_port_priv *port_priv,\n\t\t\t       struct sk_buff *txb)\n{\n\tstruct adin1110_priv *priv = port_priv->priv;\n\tu32 header_len = ADIN1110_WR_HEADER_LEN;\n\t__be16 frame_header;\n\tint padding = 0;\n\tint padded_len;\n\tint round_len;\n\tint ret;\n\n\t \n\tif (txb->len + ADIN1110_FEC_LEN < 64)\n\t\tpadding = 64 - (txb->len + ADIN1110_FEC_LEN);\n\n\tpadded_len = txb->len + padding + ADIN1110_FRAME_HEADER_LEN;\n\n\tround_len = adin1110_round_len(padded_len);\n\tif (round_len < 0)\n\t\treturn round_len;\n\n\tret = adin1110_write_reg(priv, ADIN1110_TX_FSIZE, padded_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmemset(priv->data, 0, round_len + ADIN1110_WR_HEADER_LEN);\n\n\tpriv->data[0] = ADIN1110_CD | ADIN1110_WRITE;\n\tpriv->data[0] |= FIELD_GET(GENMASK(12, 8), ADIN1110_TX);\n\tpriv->data[1] = FIELD_GET(GENMASK(7, 0), ADIN1110_TX);\n\tif (priv->append_crc) {\n\t\tpriv->data[2] = adin1110_crc_data(&priv->data[0], 2);\n\t\theader_len++;\n\t}\n\n\t \n\tframe_header = cpu_to_be16(port_priv->nr);\n\tmemcpy(&priv->data[header_len], &frame_header,\n\t       ADIN1110_FRAME_HEADER_LEN);\n\n\tmemcpy(&priv->data[header_len + ADIN1110_FRAME_HEADER_LEN],\n\t       txb->data, txb->len);\n\n\tret = spi_write(priv->spidev, &priv->data[0], round_len + header_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tport_priv->tx_bytes += txb->len;\n\tport_priv->tx_packets++;\n\n\treturn 0;\n}\n\nstatic int adin1110_read_mdio_acc(struct adin1110_priv *priv)\n{\n\tu32 val;\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\tret = adin1110_read_reg(priv, ADIN1110_MDIOACC, &val);\n\tmutex_unlock(&priv->lock);\n\tif (ret < 0)\n\t\treturn 0;\n\n\treturn val;\n}\n\nstatic int adin1110_mdio_read(struct mii_bus *bus, int phy_id, int reg)\n{\n\tstruct adin1110_priv *priv = bus->priv;\n\tu32 val = 0;\n\tint ret;\n\n\tif (mdio_phy_id_is_c45(phy_id))\n\t\treturn -EOPNOTSUPP;\n\n\tval |= FIELD_PREP(ADIN1110_MDIO_OP, ADIN1110_MDIO_OP_RD);\n\tval |= FIELD_PREP(ADIN1110_MDIO_ST, 0x1);\n\tval |= FIELD_PREP(ADIN1110_MDIO_PRTAD, phy_id);\n\tval |= FIELD_PREP(ADIN1110_MDIO_DEVAD, reg);\n\n\t \n\tmutex_lock(&priv->lock);\n\tret = adin1110_write_reg(priv, ADIN1110_MDIOACC, val);\n\tmutex_unlock(&priv->lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = readx_poll_timeout(adin1110_read_mdio_acc, priv, val,\n\t\t\t\t (val & ADIN1110_MDIO_TRDONE), 10000, 30000);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn (val & ADIN1110_MDIO_DATA);\n}\n\nstatic int adin1110_mdio_write(struct mii_bus *bus, int phy_id,\n\t\t\t       int reg, u16 reg_val)\n{\n\tstruct adin1110_priv *priv = bus->priv;\n\tu32 val = 0;\n\tint ret;\n\n\tif (mdio_phy_id_is_c45(phy_id))\n\t\treturn -EOPNOTSUPP;\n\n\tval |= FIELD_PREP(ADIN1110_MDIO_OP, ADIN1110_MDIO_OP_WR);\n\tval |= FIELD_PREP(ADIN1110_MDIO_ST, 0x1);\n\tval |= FIELD_PREP(ADIN1110_MDIO_PRTAD, phy_id);\n\tval |= FIELD_PREP(ADIN1110_MDIO_DEVAD, reg);\n\tval |= FIELD_PREP(ADIN1110_MDIO_DATA, reg_val);\n\n\t \n\tmutex_lock(&priv->lock);\n\tret = adin1110_write_reg(priv, ADIN1110_MDIOACC, val);\n\tmutex_unlock(&priv->lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn readx_poll_timeout(adin1110_read_mdio_acc, priv, val,\n\t\t\t\t  (val & ADIN1110_MDIO_TRDONE), 10000, 30000);\n}\n\n \nstatic int adin1110_register_mdiobus(struct adin1110_priv *priv,\n\t\t\t\t     struct device *dev)\n{\n\tstruct mii_bus *mii_bus;\n\tint ret;\n\n\tmii_bus = devm_mdiobus_alloc(dev);\n\tif (!mii_bus)\n\t\treturn -ENOMEM;\n\n\tsnprintf(priv->mii_bus_name, MII_BUS_ID_SIZE, \"%s-%u\",\n\t\t priv->cfg->name, spi_get_chipselect(priv->spidev, 0));\n\n\tmii_bus->name = priv->mii_bus_name;\n\tmii_bus->read = adin1110_mdio_read;\n\tmii_bus->write = adin1110_mdio_write;\n\tmii_bus->priv = priv;\n\tmii_bus->parent = dev;\n\tmii_bus->phy_mask = ~((u32)GENMASK(2, 0));\n\tsnprintf(mii_bus->id, MII_BUS_ID_SIZE, \"%s\", dev_name(dev));\n\n\tret = devm_mdiobus_register(dev, mii_bus);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->mii_bus = mii_bus;\n\n\treturn 0;\n}\n\nstatic bool adin1110_port_rx_ready(struct adin1110_port_priv *port_priv,\n\t\t\t\t   u32 status)\n{\n\tif (!netif_oper_up(port_priv->netdev))\n\t\treturn false;\n\n\tif (!port_priv->nr)\n\t\treturn !!(status & ADIN1110_RX_RDY);\n\telse\n\t\treturn !!(status & ADIN2111_P2_RX_RDY);\n}\n\nstatic void adin1110_read_frames(struct adin1110_port_priv *port_priv,\n\t\t\t\t unsigned int budget)\n{\n\tstruct adin1110_priv *priv = port_priv->priv;\n\tu32 status1;\n\tint ret;\n\n\twhile (budget) {\n\t\tret = adin1110_read_reg(priv, ADIN1110_STATUS1, &status1);\n\t\tif (ret < 0)\n\t\t\treturn;\n\n\t\tif (!adin1110_port_rx_ready(port_priv, status1))\n\t\t\tbreak;\n\n\t\tret = adin1110_read_fifo(port_priv);\n\t\tif (ret < 0)\n\t\t\treturn;\n\n\t\tbudget--;\n\t}\n}\n\nstatic void adin1110_wake_queues(struct adin1110_priv *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < priv->cfg->ports_nr; i++)\n\t\tnetif_wake_queue(priv->ports[i]->netdev);\n}\n\nstatic irqreturn_t adin1110_irq(int irq, void *p)\n{\n\tstruct adin1110_priv *priv = p;\n\tu32 status1;\n\tu32 val;\n\tint ret;\n\tint i;\n\n\tmutex_lock(&priv->lock);\n\n\tret = adin1110_read_reg(priv, ADIN1110_STATUS1, &status1);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (priv->append_crc && (status1 & ADIN1110_SPI_ERR))\n\t\tdev_warn_ratelimited(&priv->spidev->dev,\n\t\t\t\t     \"SPI CRC error on write.\\n\");\n\n\tret = adin1110_read_reg(priv, ADIN1110_TX_SPACE, &val);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tpriv->tx_space = 2 * val;\n\n\tfor (i = 0; i < priv->cfg->ports_nr; i++) {\n\t\tif (adin1110_port_rx_ready(priv->ports[i], status1))\n\t\t\tadin1110_read_frames(priv->ports[i],\n\t\t\t\t\t     ADIN1110_MAX_FRAMES_READ);\n\t}\n\n\t \n\tadin1110_write_reg(priv, ADIN1110_STATUS0, ADIN1110_CLEAR_STATUS0);\n\tadin1110_write_reg(priv, ADIN1110_STATUS1, priv->irq_mask);\n\nout:\n\tmutex_unlock(&priv->lock);\n\n\tif (priv->tx_space > 0 && ret >= 0)\n\t\tadin1110_wake_queues(priv);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int adin1110_write_mac_address(struct adin1110_port_priv *port_priv,\n\t\t\t\t      int mac_nr, const u8 *addr,\n\t\t\t\t      u8 *mask, u32 port_rules)\n{\n\tstruct adin1110_priv *priv = port_priv->priv;\n\tu32 offset = mac_nr * 2;\n\tu32 port_rules_mask;\n\tint ret;\n\tu32 val;\n\n\tif (!port_priv->nr)\n\t\tport_rules_mask = ADIN1110_MAC_ADDR_APPLY2PORT;\n\telse\n\t\tport_rules_mask = ADIN2111_MAC_ADDR_APPLY2PORT2;\n\n\tif (port_rules & port_rules_mask)\n\t\tport_rules_mask |= ADIN1110_MAC_ADDR_TO_HOST | ADIN2111_MAC_ADDR_TO_OTHER_PORT;\n\n\tport_rules_mask |= GENMASK(15, 0);\n\tval = port_rules | get_unaligned_be16(&addr[0]);\n\tret = adin1110_set_bits(priv, ADIN1110_MAC_ADDR_FILTER_UPR + offset,\n\t\t\t\tport_rules_mask, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = get_unaligned_be32(&addr[2]);\n\tret =  adin1110_write_reg(priv,\n\t\t\t\t  ADIN1110_MAC_ADDR_FILTER_LWR + offset, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (mac_nr < ADIN_MAC_P1_ADDR_SLOT) {\n\t\tval = get_unaligned_be16(&mask[0]);\n\t\tret = adin1110_write_reg(priv,\n\t\t\t\t\t ADIN1110_MAC_ADDR_MASK_UPR + offset,\n\t\t\t\t\t val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tval = get_unaligned_be32(&mask[2]);\n\t\treturn adin1110_write_reg(priv,\n\t\t\t\t\t  ADIN1110_MAC_ADDR_MASK_LWR + offset,\n\t\t\t\t\t  val);\n\t}\n\n\treturn 0;\n}\n\nstatic int adin1110_clear_mac_address(struct adin1110_priv *priv, int mac_nr)\n{\n\tu32 offset = mac_nr * 2;\n\tint ret;\n\n\tret = adin1110_write_reg(priv, ADIN1110_MAC_ADDR_FILTER_UPR + offset, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret =  adin1110_write_reg(priv, ADIN1110_MAC_ADDR_FILTER_LWR + offset, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (mac_nr <= 1) {\n\t\tret = adin1110_write_reg(priv, ADIN1110_MAC_ADDR_MASK_UPR + offset, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = adin1110_write_reg(priv, ADIN1110_MAC_ADDR_MASK_LWR + offset, 0);\n\t}\n\n\treturn ret;\n}\n\nstatic u32 adin1110_port_rules(struct adin1110_port_priv *port_priv,\n\t\t\t       bool fw_to_host,\n\t\t\t       bool fw_to_other_port)\n{\n\tu32 port_rules = 0;\n\n\tif (!port_priv->nr)\n\t\tport_rules |= ADIN1110_MAC_ADDR_APPLY2PORT;\n\telse\n\t\tport_rules |= ADIN2111_MAC_ADDR_APPLY2PORT2;\n\n\tif (fw_to_host)\n\t\tport_rules |= ADIN1110_MAC_ADDR_TO_HOST;\n\n\tif (fw_to_other_port && port_priv->priv->forwarding)\n\t\tport_rules |= ADIN2111_MAC_ADDR_TO_OTHER_PORT;\n\n\treturn port_rules;\n}\n\nstatic int adin1110_multicast_filter(struct adin1110_port_priv *port_priv,\n\t\t\t\t     int mac_nr, bool accept_multicast)\n{\n\tu8 mask[ETH_ALEN] = {0};\n\tu8 mac[ETH_ALEN] = {0};\n\tu32 port_rules = 0;\n\n\tmask[0] = BIT(0);\n\tmac[0] = BIT(0);\n\n\tif (accept_multicast && port_priv->state == BR_STATE_FORWARDING)\n\t\tport_rules = adin1110_port_rules(port_priv, true, true);\n\n\treturn adin1110_write_mac_address(port_priv, mac_nr, mac,\n\t\t\t\t\t  mask, port_rules);\n}\n\nstatic int adin1110_broadcasts_filter(struct adin1110_port_priv *port_priv,\n\t\t\t\t      int mac_nr, bool accept_broadcast)\n{\n\tu32 port_rules = 0;\n\tu8 mask[ETH_ALEN];\n\n\teth_broadcast_addr(mask);\n\n\tif (accept_broadcast && port_priv->state == BR_STATE_FORWARDING)\n\t\tport_rules = adin1110_port_rules(port_priv, true, true);\n\n\treturn adin1110_write_mac_address(port_priv, mac_nr, mask,\n\t\t\t\t\t  mask, port_rules);\n}\n\nstatic int adin1110_set_mac_address(struct net_device *netdev,\n\t\t\t\t    const unsigned char *dev_addr)\n{\n\tstruct adin1110_port_priv *port_priv = netdev_priv(netdev);\n\tu8 mask[ETH_ALEN];\n\tu32 port_rules;\n\tu32 mac_slot;\n\n\tif (!is_valid_ether_addr(dev_addr))\n\t\treturn -EADDRNOTAVAIL;\n\n\teth_hw_addr_set(netdev, dev_addr);\n\teth_broadcast_addr(mask);\n\n\tmac_slot = (!port_priv->nr) ?  ADIN_MAC_P1_ADDR_SLOT : ADIN_MAC_P2_ADDR_SLOT;\n\tport_rules = adin1110_port_rules(port_priv, true, false);\n\n\treturn adin1110_write_mac_address(port_priv, mac_slot, netdev->dev_addr,\n\t\t\t\t\t  mask, port_rules);\n}\n\nstatic int adin1110_ndo_set_mac_address(struct net_device *netdev, void *addr)\n{\n\tstruct sockaddr *sa = addr;\n\tint ret;\n\n\tret = eth_prepare_mac_addr_change(netdev, addr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn adin1110_set_mac_address(netdev, sa->sa_data);\n}\n\nstatic int adin1110_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)\n{\n\tif (!netif_running(netdev))\n\t\treturn -EINVAL;\n\n\treturn phy_do_ioctl(netdev, rq, cmd);\n}\n\nstatic int adin1110_set_promisc_mode(struct adin1110_port_priv *port_priv,\n\t\t\t\t     bool promisc)\n{\n\tstruct adin1110_priv *priv = port_priv->priv;\n\tu32 mask;\n\n\tif (port_priv->state != BR_STATE_FORWARDING)\n\t\tpromisc = false;\n\n\tif (!port_priv->nr)\n\t\tmask = ADIN1110_FWD_UNK2HOST;\n\telse\n\t\tmask = ADIN2111_P2_FWD_UNK2HOST;\n\n\treturn adin1110_set_bits(priv, ADIN1110_CONFIG2,\n\t\t\t\t mask, promisc ? mask : 0);\n}\n\nstatic int adin1110_setup_rx_mode(struct adin1110_port_priv *port_priv)\n{\n\tint ret;\n\n\tret = adin1110_set_promisc_mode(port_priv,\n\t\t\t\t\t!!(port_priv->flags & IFF_PROMISC));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = adin1110_multicast_filter(port_priv, ADIN_MAC_MULTICAST_ADDR_SLOT,\n\t\t\t\t\t!!(port_priv->flags & IFF_ALLMULTI));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = adin1110_broadcasts_filter(port_priv,\n\t\t\t\t\t ADIN_MAC_BROADCAST_ADDR_SLOT,\n\t\t\t\t\t !!(port_priv->flags & IFF_BROADCAST));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn adin1110_set_bits(port_priv->priv, ADIN1110_CONFIG1,\n\t\t\t\t ADIN1110_CONFIG1_SYNC, ADIN1110_CONFIG1_SYNC);\n}\n\nstatic bool adin1110_can_offload_forwarding(struct adin1110_priv *priv)\n{\n\tint i;\n\n\tif (priv->cfg->id != ADIN2111_MAC)\n\t\treturn false;\n\n\t \n\tif (priv->ports[0]->bridge != priv->ports[1]->bridge || !priv->ports[0]->bridge)\n\t\treturn false;\n\n\t \n\tfor (i = 0; i < priv->cfg->ports_nr; i++) {\n\t\tif (priv->ports[i]->state != BR_STATE_FORWARDING)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void adin1110_rx_mode_work(struct work_struct *work)\n{\n\tstruct adin1110_port_priv *port_priv;\n\tstruct adin1110_priv *priv;\n\n\tport_priv = container_of(work, struct adin1110_port_priv, rx_mode_work);\n\tpriv = port_priv->priv;\n\n\tmutex_lock(&priv->lock);\n\tadin1110_setup_rx_mode(port_priv);\n\tmutex_unlock(&priv->lock);\n}\n\nstatic void adin1110_set_rx_mode(struct net_device *dev)\n{\n\tstruct adin1110_port_priv *port_priv = netdev_priv(dev);\n\tstruct adin1110_priv *priv = port_priv->priv;\n\n\tspin_lock(&priv->state_lock);\n\n\tport_priv->flags = dev->flags;\n\tschedule_work(&port_priv->rx_mode_work);\n\n\tspin_unlock(&priv->state_lock);\n}\n\nstatic int adin1110_net_open(struct net_device *net_dev)\n{\n\tstruct adin1110_port_priv *port_priv = netdev_priv(net_dev);\n\tstruct adin1110_priv *priv = port_priv->priv;\n\tu32 val;\n\tint ret;\n\n\tmutex_lock(&priv->lock);\n\n\t \n\tret = adin1110_write_reg(priv, ADIN1110_CONFIG2, ADIN1110_CRC_APPEND);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tval = ADIN1110_TX_RDY_IRQ | ADIN1110_RX_RDY_IRQ | ADIN1110_SPI_ERR_IRQ;\n\tif (priv->cfg->id == ADIN2111_MAC)\n\t\tval |= ADIN2111_RX_RDY_IRQ;\n\n\tpriv->irq_mask = val;\n\tret = adin1110_write_reg(priv, ADIN1110_IMASK1, ~val);\n\tif (ret < 0) {\n\t\tnetdev_err(net_dev, \"Failed to enable chip IRQs: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = adin1110_read_reg(priv, ADIN1110_TX_SPACE, &val);\n\tif (ret < 0) {\n\t\tnetdev_err(net_dev, \"Failed to read TX FIFO space: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tpriv->tx_space = 2 * val;\n\n\tport_priv->state = BR_STATE_FORWARDING;\n\tret = adin1110_set_mac_address(net_dev, net_dev->dev_addr);\n\tif (ret < 0) {\n\t\tnetdev_err(net_dev, \"Could not set MAC address: %pM, %d\\n\",\n\t\t\t   net_dev->dev_addr, ret);\n\t\tgoto out;\n\t}\n\n\tret = adin1110_set_bits(priv, ADIN1110_CONFIG1, ADIN1110_CONFIG1_SYNC,\n\t\t\t\tADIN1110_CONFIG1_SYNC);\n\nout:\n\tmutex_unlock(&priv->lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tphy_start(port_priv->phydev);\n\n\tnetif_start_queue(net_dev);\n\n\treturn 0;\n}\n\nstatic int adin1110_net_stop(struct net_device *net_dev)\n{\n\tstruct adin1110_port_priv *port_priv = netdev_priv(net_dev);\n\tstruct adin1110_priv *priv = port_priv->priv;\n\tu32 mask;\n\tint ret;\n\n\tmask = !port_priv->nr ? ADIN2111_RX_RDY_IRQ : ADIN1110_RX_RDY_IRQ;\n\n\t \n\tmutex_lock(&priv->lock);\n\tret = adin1110_set_bits(priv, ADIN1110_IMASK1, mask, mask);\n\tmutex_unlock(&priv->lock);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnetif_stop_queue(port_priv->netdev);\n\tflush_work(&port_priv->tx_work);\n\tphy_stop(port_priv->phydev);\n\n\treturn 0;\n}\n\nstatic void adin1110_tx_work(struct work_struct *work)\n{\n\tstruct adin1110_port_priv *port_priv;\n\tstruct adin1110_priv *priv;\n\tstruct sk_buff *txb;\n\tint ret;\n\n\tport_priv = container_of(work, struct adin1110_port_priv, tx_work);\n\tpriv = port_priv->priv;\n\n\tmutex_lock(&priv->lock);\n\n\twhile ((txb = skb_dequeue(&port_priv->txq))) {\n\t\tret = adin1110_write_fifo(port_priv, txb);\n\t\tif (ret < 0)\n\t\t\tdev_err_ratelimited(&priv->spidev->dev,\n\t\t\t\t\t    \"Frame write error: %d\\n\", ret);\n\n\t\tdev_kfree_skb(txb);\n\t}\n\n\tmutex_unlock(&priv->lock);\n}\n\nstatic netdev_tx_t adin1110_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct adin1110_port_priv *port_priv = netdev_priv(dev);\n\tstruct adin1110_priv *priv = port_priv->priv;\n\tnetdev_tx_t netdev_ret = NETDEV_TX_OK;\n\tu32 tx_space_needed;\n\n\ttx_space_needed = skb->len + ADIN1110_FRAME_HEADER_LEN + ADIN1110_INTERNAL_SIZE_HEADER_LEN;\n\tif (tx_space_needed > priv->tx_space) {\n\t\tnetif_stop_queue(dev);\n\t\tnetdev_ret = NETDEV_TX_BUSY;\n\t} else {\n\t\tpriv->tx_space -= tx_space_needed;\n\t\tskb_queue_tail(&port_priv->txq, skb);\n\t}\n\n\tschedule_work(&port_priv->tx_work);\n\n\treturn netdev_ret;\n}\n\nstatic void adin1110_ndo_get_stats64(struct net_device *dev,\n\t\t\t\t     struct rtnl_link_stats64 *storage)\n{\n\tstruct adin1110_port_priv *port_priv = netdev_priv(dev);\n\n\tstorage->rx_packets = port_priv->rx_packets;\n\tstorage->tx_packets = port_priv->tx_packets;\n\n\tstorage->rx_bytes = port_priv->rx_bytes;\n\tstorage->tx_bytes = port_priv->tx_bytes;\n}\n\nstatic int adin1110_port_get_port_parent_id(struct net_device *dev,\n\t\t\t\t\t    struct netdev_phys_item_id *ppid)\n{\n\tstruct adin1110_port_priv *port_priv = netdev_priv(dev);\n\tstruct adin1110_priv *priv = port_priv->priv;\n\n\tppid->id_len = strnlen(priv->mii_bus_name, MAX_PHYS_ITEM_ID_LEN);\n\tmemcpy(ppid->id, priv->mii_bus_name, ppid->id_len);\n\n\treturn 0;\n}\n\nstatic int adin1110_ndo_get_phys_port_name(struct net_device *dev,\n\t\t\t\t\t   char *name, size_t len)\n{\n\tstruct adin1110_port_priv *port_priv = netdev_priv(dev);\n\tint err;\n\n\terr = snprintf(name, len, \"p%d\", port_priv->nr);\n\tif (err >= len)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops adin1110_netdev_ops = {\n\t.ndo_open\t\t= adin1110_net_open,\n\t.ndo_stop\t\t= adin1110_net_stop,\n\t.ndo_eth_ioctl\t\t= adin1110_ioctl,\n\t.ndo_start_xmit\t\t= adin1110_start_xmit,\n\t.ndo_set_mac_address\t= adin1110_ndo_set_mac_address,\n\t.ndo_set_rx_mode\t= adin1110_set_rx_mode,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_get_stats64\t= adin1110_ndo_get_stats64,\n\t.ndo_get_port_parent_id\t= adin1110_port_get_port_parent_id,\n\t.ndo_get_phys_port_name\t= adin1110_ndo_get_phys_port_name,\n};\n\nstatic void adin1110_get_drvinfo(struct net_device *dev,\n\t\t\t\t struct ethtool_drvinfo *di)\n{\n\tstrscpy(di->driver, \"ADIN1110\", sizeof(di->driver));\n\tstrscpy(di->bus_info, dev_name(dev->dev.parent), sizeof(di->bus_info));\n}\n\nstatic const struct ethtool_ops adin1110_ethtool_ops = {\n\t.get_drvinfo\t\t= adin1110_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_link_ksettings\t= phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings\t= phy_ethtool_set_link_ksettings,\n};\n\nstatic void adin1110_adjust_link(struct net_device *dev)\n{\n\tstruct phy_device *phydev = dev->phydev;\n\n\tif (!phydev->link)\n\t\tphy_print_status(phydev);\n}\n\n \nstatic int adin1110_check_spi(struct adin1110_priv *priv)\n{\n\tstruct gpio_desc *reset_gpio;\n\tint ret;\n\tu32 val;\n\n\treset_gpio = devm_gpiod_get_optional(&priv->spidev->dev, \"reset\",\n\t\t\t\t\t     GPIOD_OUT_LOW);\n\tif (reset_gpio) {\n\t\t \n\t\tspi_bus_lock(priv->spidev->controller);\n\n\t\tgpiod_set_value(reset_gpio, 1);\n\t\tfsleep(10000);\n\t\tgpiod_set_value(reset_gpio, 0);\n\n\t\t \n\t\tfsleep(90000);\n\n\t\tspi_bus_unlock(priv->spidev->controller);\n\t}\n\n\tret = adin1110_read_reg(priv, ADIN1110_PHY_ID, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (val != priv->cfg->phy_id_val) {\n\t\tdev_err(&priv->spidev->dev, \"PHY ID expected: %x, read: %x\\n\",\n\t\t\tpriv->cfg->phy_id_val, val);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int adin1110_hw_forwarding(struct adin1110_priv *priv, bool enable)\n{\n\tint ret;\n\tint i;\n\n\tpriv->forwarding = enable;\n\n\tif (!priv->forwarding) {\n\t\tfor (i = ADIN_MAC_FDB_ADDR_SLOT; i < ADIN_MAC_MAX_ADDR_SLOTS; i++) {\n\t\t\tret = adin1110_clear_mac_address(priv, i);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tret = adin1110_set_bits(priv, ADIN1110_CONFIG2,\n\t\t\t\tADIN2111_PORT_CUT_THRU_EN,\n\t\t\t\tpriv->forwarding ? ADIN2111_PORT_CUT_THRU_EN : 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < priv->cfg->ports_nr; i++) {\n\t\tret = adin1110_setup_rx_mode(priv->ports[i]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int adin1110_port_bridge_join(struct adin1110_port_priv *port_priv,\n\t\t\t\t     struct net_device *bridge)\n{\n\tstruct adin1110_priv *priv = port_priv->priv;\n\tint ret;\n\n\tport_priv->bridge = bridge;\n\n\tif (adin1110_can_offload_forwarding(priv)) {\n\t\tmutex_lock(&priv->lock);\n\t\tret = adin1110_hw_forwarding(priv, true);\n\t\tmutex_unlock(&priv->lock);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn adin1110_set_mac_address(port_priv->netdev, bridge->dev_addr);\n}\n\nstatic int adin1110_port_bridge_leave(struct adin1110_port_priv *port_priv,\n\t\t\t\t      struct net_device *bridge)\n{\n\tstruct adin1110_priv *priv = port_priv->priv;\n\tint ret;\n\n\tport_priv->bridge = NULL;\n\n\tmutex_lock(&priv->lock);\n\tret = adin1110_hw_forwarding(priv, false);\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic bool adin1110_port_dev_check(const struct net_device *dev)\n{\n\treturn dev->netdev_ops == &adin1110_netdev_ops;\n}\n\nstatic int adin1110_netdevice_event(struct notifier_block *unused,\n\t\t\t\t    unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct adin1110_port_priv *port_priv = netdev_priv(dev);\n\tstruct netdev_notifier_changeupper_info *info = ptr;\n\tint ret = 0;\n\n\tif (!adin1110_port_dev_check(dev))\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_CHANGEUPPER:\n\t\tif (netif_is_bridge_master(info->upper_dev)) {\n\t\t\tif (info->linking)\n\t\t\t\tret = adin1110_port_bridge_join(port_priv, info->upper_dev);\n\t\t\telse\n\t\t\t\tret = adin1110_port_bridge_leave(port_priv, info->upper_dev);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn notifier_from_errno(ret);\n}\n\nstatic struct notifier_block adin1110_netdevice_nb = {\n\t.notifier_call = adin1110_netdevice_event,\n};\n\nstatic void adin1110_disconnect_phy(void *data)\n{\n\tphy_disconnect(data);\n}\n\nstatic int adin1110_port_set_forwarding_state(struct adin1110_port_priv *port_priv)\n{\n\tstruct adin1110_priv *priv = port_priv->priv;\n\tint ret;\n\n\tport_priv->state = BR_STATE_FORWARDING;\n\n\tmutex_lock(&priv->lock);\n\tret = adin1110_set_mac_address(port_priv->netdev,\n\t\t\t\t       port_priv->netdev->dev_addr);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (adin1110_can_offload_forwarding(priv))\n\t\tret = adin1110_hw_forwarding(priv, true);\n\telse\n\t\tret = adin1110_setup_rx_mode(port_priv);\nout:\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\nstatic int adin1110_port_set_blocking_state(struct adin1110_port_priv *port_priv)\n{\n\tu8 mac[ETH_ALEN] = {0x01, 0x80, 0xC2, 0x00, 0x00, 0x00};\n\tstruct adin1110_priv *priv = port_priv->priv;\n\tu8 mask[ETH_ALEN];\n\tu32 port_rules;\n\tint mac_slot;\n\tint ret;\n\n\tport_priv->state = BR_STATE_BLOCKING;\n\n\tmutex_lock(&priv->lock);\n\n\tmac_slot = (!port_priv->nr) ?  ADIN_MAC_P1_ADDR_SLOT : ADIN_MAC_P2_ADDR_SLOT;\n\tret = adin1110_clear_mac_address(priv, mac_slot);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = adin1110_hw_forwarding(priv, false);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\teth_broadcast_addr(mask);\n\tport_rules = adin1110_port_rules(port_priv, true, false);\n\tret = adin1110_write_mac_address(port_priv, mac_slot, mac,\n\t\t\t\t\t mask, port_rules);\nout:\n\tmutex_unlock(&priv->lock);\n\n\treturn ret;\n}\n\n \nstatic int adin1110_port_attr_stp_state_set(struct adin1110_port_priv *port_priv,\n\t\t\t\t\t    u8 state)\n{\n\tswitch (state) {\n\tcase BR_STATE_FORWARDING:\n\t\treturn adin1110_port_set_forwarding_state(port_priv);\n\tcase BR_STATE_LEARNING:\n\tcase BR_STATE_LISTENING:\n\tcase BR_STATE_DISABLED:\n\tcase BR_STATE_BLOCKING:\n\t\treturn adin1110_port_set_blocking_state(port_priv);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int adin1110_port_attr_set(struct net_device *dev, const void *ctx,\n\t\t\t\t  const struct switchdev_attr *attr,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct adin1110_port_priv *port_priv = netdev_priv(dev);\n\n\tswitch (attr->id) {\n\tcase SWITCHDEV_ATTR_ID_PORT_STP_STATE:\n\t\treturn adin1110_port_attr_stp_state_set(port_priv,\n\t\t\t\t\t\t\tattr->u.stp_state);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int adin1110_switchdev_blocking_event(struct notifier_block *unused,\n\t\t\t\t\t     unsigned long event,\n\t\t\t\t\t     void *ptr)\n{\n\tstruct net_device *netdev = switchdev_notifier_info_to_dev(ptr);\n\tint ret;\n\n\tif (event == SWITCHDEV_PORT_ATTR_SET) {\n\t\tret = switchdev_handle_port_attr_set(netdev, ptr,\n\t\t\t\t\t\t     adin1110_port_dev_check,\n\t\t\t\t\t\t     adin1110_port_attr_set);\n\n\t\treturn notifier_from_errno(ret);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block adin1110_switchdev_blocking_notifier = {\n\t.notifier_call = adin1110_switchdev_blocking_event,\n};\n\nstatic void adin1110_fdb_offload_notify(struct net_device *netdev,\n\t\t\t\t\tstruct switchdev_notifier_fdb_info *rcv)\n{\n\tstruct switchdev_notifier_fdb_info info = {};\n\n\tinfo.addr = rcv->addr;\n\tinfo.vid = rcv->vid;\n\tinfo.offloaded = true;\n\tcall_switchdev_notifiers(SWITCHDEV_FDB_OFFLOADED,\n\t\t\t\t netdev, &info.info, NULL);\n}\n\nstatic int adin1110_fdb_add(struct adin1110_port_priv *port_priv,\n\t\t\t    struct switchdev_notifier_fdb_info *fdb)\n{\n\tstruct adin1110_priv *priv = port_priv->priv;\n\tstruct adin1110_port_priv *other_port;\n\tu8 mask[ETH_ALEN];\n\tu32 port_rules;\n\tint mac_nr;\n\tu32 val;\n\tint ret;\n\n\tnetdev_dbg(port_priv->netdev,\n\t\t   \"DEBUG: %s: MACID = %pM vid = %u flags = %u %u -- port %d\\n\",\n\t\t    __func__, fdb->addr, fdb->vid, fdb->added_by_user,\n\t\t    fdb->offloaded, port_priv->nr);\n\n\tif (!priv->forwarding)\n\t\treturn 0;\n\n\tif (fdb->is_local)\n\t\treturn -EINVAL;\n\n\t \n\tfor (mac_nr = ADIN_MAC_FDB_ADDR_SLOT; mac_nr < ADIN_MAC_MAX_ADDR_SLOTS; mac_nr++) {\n\t\tret = adin1110_read_reg(priv, ADIN1110_MAC_ADDR_FILTER_UPR + (mac_nr * 2), &val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (!val)\n\t\t\tbreak;\n\t}\n\n\tif (mac_nr == ADIN_MAC_MAX_ADDR_SLOTS)\n\t\treturn -ENOMEM;\n\n\tother_port = priv->ports[!port_priv->nr];\n\tport_rules = adin1110_port_rules(other_port, false, true);\n\teth_broadcast_addr(mask);\n\n\treturn adin1110_write_mac_address(other_port, mac_nr, (u8 *)fdb->addr,\n\t\t\t\t\t  mask, port_rules);\n}\n\nstatic int adin1110_read_mac(struct adin1110_priv *priv, int mac_nr, u8 *addr)\n{\n\tu32 val;\n\tint ret;\n\n\tret = adin1110_read_reg(priv, ADIN1110_MAC_ADDR_FILTER_UPR + (mac_nr * 2), &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tput_unaligned_be16(val, addr);\n\n\tret = adin1110_read_reg(priv, ADIN1110_MAC_ADDR_FILTER_LWR + (mac_nr * 2), &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tput_unaligned_be32(val, addr + 2);\n\n\treturn 0;\n}\n\nstatic int adin1110_fdb_del(struct adin1110_port_priv *port_priv,\n\t\t\t    struct switchdev_notifier_fdb_info *fdb)\n{\n\tstruct adin1110_priv *priv = port_priv->priv;\n\tu8 addr[ETH_ALEN];\n\tint mac_nr;\n\tint ret;\n\n\tnetdev_dbg(port_priv->netdev,\n\t\t   \"DEBUG: %s: MACID = %pM vid = %u flags = %u %u -- port %d\\n\",\n\t\t   __func__, fdb->addr, fdb->vid, fdb->added_by_user,\n\t\t   fdb->offloaded, port_priv->nr);\n\n\tif (fdb->is_local)\n\t\treturn -EINVAL;\n\n\tfor (mac_nr = ADIN_MAC_FDB_ADDR_SLOT; mac_nr < ADIN_MAC_MAX_ADDR_SLOTS; mac_nr++) {\n\t\tret = adin1110_read_mac(priv, mac_nr, addr);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (ether_addr_equal(addr, fdb->addr)) {\n\t\t\tret = adin1110_clear_mac_address(priv, mac_nr);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void adin1110_switchdev_event_work(struct work_struct *work)\n{\n\tstruct adin1110_switchdev_event_work *switchdev_work;\n\tstruct adin1110_port_priv *port_priv;\n\tint ret;\n\n\tswitchdev_work = container_of(work, struct adin1110_switchdev_event_work, work);\n\tport_priv = switchdev_work->port_priv;\n\n\tmutex_lock(&port_priv->priv->lock);\n\n\tswitch (switchdev_work->event) {\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\t\tret = adin1110_fdb_add(port_priv, &switchdev_work->fdb_info);\n\t\tif (!ret)\n\t\t\tadin1110_fdb_offload_notify(port_priv->netdev,\n\t\t\t\t\t\t    &switchdev_work->fdb_info);\n\t\tbreak;\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\tadin1110_fdb_del(port_priv, &switchdev_work->fdb_info);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&port_priv->priv->lock);\n\n\tkfree(switchdev_work->fdb_info.addr);\n\tkfree(switchdev_work);\n\tdev_put(port_priv->netdev);\n}\n\n \nstatic int adin1110_switchdev_event(struct notifier_block *unused,\n\t\t\t\t    unsigned long event, void *ptr)\n{\n\tstruct net_device *netdev = switchdev_notifier_info_to_dev(ptr);\n\tstruct adin1110_port_priv *port_priv = netdev_priv(netdev);\n\tstruct adin1110_switchdev_event_work *switchdev_work;\n\tstruct switchdev_notifier_fdb_info *fdb_info = ptr;\n\n\tif (!adin1110_port_dev_check(netdev))\n\t\treturn NOTIFY_DONE;\n\n\tswitchdev_work = kzalloc(sizeof(*switchdev_work), GFP_ATOMIC);\n\tif (WARN_ON(!switchdev_work))\n\t\treturn NOTIFY_BAD;\n\n\tINIT_WORK(&switchdev_work->work, adin1110_switchdev_event_work);\n\tswitchdev_work->port_priv = port_priv;\n\tswitchdev_work->event = event;\n\n\tswitch (event) {\n\tcase SWITCHDEV_FDB_ADD_TO_DEVICE:\n\tcase SWITCHDEV_FDB_DEL_TO_DEVICE:\n\t\tmemcpy(&switchdev_work->fdb_info, ptr,\n\t\t       sizeof(switchdev_work->fdb_info));\n\t\tswitchdev_work->fdb_info.addr = kzalloc(ETH_ALEN, GFP_ATOMIC);\n\n\t\tif (!switchdev_work->fdb_info.addr)\n\t\t\tgoto err_addr_alloc;\n\n\t\tether_addr_copy((u8 *)switchdev_work->fdb_info.addr,\n\t\t\t\tfdb_info->addr);\n\t\tdev_hold(netdev);\n\t\tbreak;\n\tdefault:\n\t\tkfree(switchdev_work);\n\t\treturn NOTIFY_DONE;\n\t}\n\n\tqueue_work(system_long_wq, &switchdev_work->work);\n\n\treturn NOTIFY_DONE;\n\nerr_addr_alloc:\n\tkfree(switchdev_work);\n\treturn NOTIFY_BAD;\n}\n\nstatic struct notifier_block adin1110_switchdev_notifier = {\n\t.notifier_call = adin1110_switchdev_event,\n};\n\nstatic void adin1110_unregister_notifiers(void)\n{\n\tunregister_switchdev_blocking_notifier(&adin1110_switchdev_blocking_notifier);\n\tunregister_switchdev_notifier(&adin1110_switchdev_notifier);\n\tunregister_netdevice_notifier(&adin1110_netdevice_nb);\n}\n\nstatic int adin1110_setup_notifiers(void)\n{\n\tint ret;\n\n\tret = register_netdevice_notifier(&adin1110_netdevice_nb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = register_switchdev_notifier(&adin1110_switchdev_notifier);\n\tif (ret < 0)\n\t\tgoto err_netdev;\n\n\tret = register_switchdev_blocking_notifier(&adin1110_switchdev_blocking_notifier);\n\tif (ret < 0)\n\t\tgoto err_sdev;\n\n\treturn 0;\n\nerr_sdev:\n\tunregister_switchdev_notifier(&adin1110_switchdev_notifier);\n\nerr_netdev:\n\tunregister_netdevice_notifier(&adin1110_netdevice_nb);\n\n\treturn ret;\n}\n\nstatic int adin1110_probe_netdevs(struct adin1110_priv *priv)\n{\n\tstruct device *dev = &priv->spidev->dev;\n\tstruct adin1110_port_priv *port_priv;\n\tstruct net_device *netdev;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < priv->cfg->ports_nr; i++) {\n\t\tnetdev = devm_alloc_etherdev(dev, sizeof(*port_priv));\n\t\tif (!netdev)\n\t\t\treturn -ENOMEM;\n\n\t\tport_priv = netdev_priv(netdev);\n\t\tport_priv->netdev = netdev;\n\t\tport_priv->priv = priv;\n\t\tport_priv->cfg = priv->cfg;\n\t\tport_priv->nr = i;\n\t\tpriv->ports[i] = port_priv;\n\t\tSET_NETDEV_DEV(netdev, dev);\n\n\t\tret = device_get_ethdev_address(dev, netdev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tnetdev->irq = priv->spidev->irq;\n\t\tINIT_WORK(&port_priv->tx_work, adin1110_tx_work);\n\t\tINIT_WORK(&port_priv->rx_mode_work, adin1110_rx_mode_work);\n\t\tskb_queue_head_init(&port_priv->txq);\n\n\t\tnetif_carrier_off(netdev);\n\n\t\tnetdev->if_port = IF_PORT_10BASET;\n\t\tnetdev->netdev_ops = &adin1110_netdev_ops;\n\t\tnetdev->ethtool_ops = &adin1110_ethtool_ops;\n\t\tnetdev->priv_flags |= IFF_UNICAST_FLT;\n\t\tnetdev->features |= NETIF_F_NETNS_LOCAL;\n\n\t\tport_priv->phydev = get_phy_device(priv->mii_bus, i + 1, false);\n\t\tif (IS_ERR(port_priv->phydev)) {\n\t\t\tnetdev_err(netdev, \"Could not find PHY with device address: %d.\\n\", i);\n\t\t\treturn PTR_ERR(port_priv->phydev);\n\t\t}\n\n\t\tport_priv->phydev = phy_connect(netdev,\n\t\t\t\t\t\tphydev_name(port_priv->phydev),\n\t\t\t\t\t\tadin1110_adjust_link,\n\t\t\t\t\t\tPHY_INTERFACE_MODE_INTERNAL);\n\t\tif (IS_ERR(port_priv->phydev)) {\n\t\t\tnetdev_err(netdev, \"Could not connect PHY with device address: %d.\\n\", i);\n\t\t\treturn PTR_ERR(port_priv->phydev);\n\t\t}\n\n\t\tret = devm_add_action_or_reset(dev, adin1110_disconnect_phy,\n\t\t\t\t\t       port_priv->phydev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = devm_request_threaded_irq(dev, priv->spidev->irq, NULL,\n\t\t\t\t\tadin1110_irq,\n\t\t\t\t\tIRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\t\t\t\t\tdev_name(dev), priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < priv->cfg->ports_nr; i++) {\n\t\tret = devm_register_netdev(dev, priv->ports[i]->netdev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Failed to register network device.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int adin1110_probe(struct spi_device *spi)\n{\n\tconst struct spi_device_id *dev_id = spi_get_device_id(spi);\n\tstruct device *dev = &spi->dev;\n\tstruct adin1110_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(struct adin1110_priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->spidev = spi;\n\tpriv->cfg = &adin1110_cfgs[dev_id->driver_data];\n\tspi->bits_per_word = 8;\n\tspi->mode = SPI_MODE_0;\n\n\tmutex_init(&priv->lock);\n\tspin_lock_init(&priv->state_lock);\n\n\t \n\tpriv->append_crc = device_property_read_bool(dev, \"adi,spi-crc\");\n\tif (priv->append_crc)\n\t\tcrc8_populate_msb(adin1110_crc_table, 0x7);\n\n\tret = adin1110_check_spi(priv);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Probe SPI Read check failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = adin1110_write_reg(priv, ADIN1110_RESET, ADIN1110_SWRESET);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = adin1110_register_mdiobus(priv, dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Could not register MDIO bus %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn adin1110_probe_netdevs(priv);\n}\n\nstatic const struct of_device_id adin1110_match_table[] = {\n\t{ .compatible = \"adi,adin1110\" },\n\t{ .compatible = \"adi,adin2111\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, adin1110_match_table);\n\nstatic const struct spi_device_id adin1110_spi_id[] = {\n\t{ .name = \"adin1110\", .driver_data = ADIN1110_MAC },\n\t{ .name = \"adin2111\", .driver_data = ADIN2111_MAC },\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, adin1110_spi_id);\n\nstatic struct spi_driver adin1110_driver = {\n\t.driver = {\n\t\t.name = \"adin1110\",\n\t\t.of_match_table = adin1110_match_table,\n\t},\n\t.probe = adin1110_probe,\n\t.id_table = adin1110_spi_id,\n};\n\nstatic int __init adin1110_driver_init(void)\n{\n\tint ret;\n\n\tret = adin1110_setup_notifiers();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = spi_register_driver(&adin1110_driver);\n\tif (ret < 0) {\n\t\tadin1110_unregister_notifiers();\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit adin1110_exit(void)\n{\n\tadin1110_unregister_notifiers();\n\tspi_unregister_driver(&adin1110_driver);\n}\nmodule_init(adin1110_driver_init);\nmodule_exit(adin1110_exit);\n\nMODULE_DESCRIPTION(\"ADIN1110 Network driver\");\nMODULE_AUTHOR(\"Alexandru Tachici <alexandru.tachici@analog.com>\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}