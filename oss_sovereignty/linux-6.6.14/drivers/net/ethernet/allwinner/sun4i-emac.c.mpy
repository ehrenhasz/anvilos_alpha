{
  "module_name": "sun4i-emac.c",
  "hash_id": "8365be4822af01b1c0611dc7e52dadbffd69e48f32e4969eaae4194d0d7907b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/allwinner/sun4i-emac.c",
  "human_readable_source": " \n\n#include <linux/clk.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/gpio.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/mii.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/phy.h>\n#include <linux/soc/sunxi/sunxi_sram.h>\n#include <linux/dmaengine.h>\n\n#include \"sun4i-emac.h\"\n\n#define DRV_NAME\t\t\"sun4i-emac\"\n\n#define EMAC_MAX_FRAME_LEN\t0x0600\n\n#define EMAC_DEFAULT_MSG_ENABLE 0x0000\nstatic int debug = -1;      ;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"debug message flags\");\n\n \nstatic int watchdog = 5000;\nmodule_param(watchdog, int, 0400);\nMODULE_PARM_DESC(watchdog, \"transmit timeout in milliseconds\");\n\n \n\n \n\nstruct emac_board_info {\n\tstruct clk\t\t*clk;\n\tstruct device\t\t*dev;\n\tstruct platform_device\t*pdev;\n\tspinlock_t\t\tlock;\n\tvoid __iomem\t\t*membase;\n\tu32\t\t\tmsg_enable;\n\tstruct net_device\t*ndev;\n\tu16\t\t\ttx_fifo_stat;\n\n\tint\t\t\temacrx_completed_flag;\n\n\tstruct device_node\t*phy_node;\n\tunsigned int\t\tlink;\n\tunsigned int\t\tspeed;\n\tunsigned int\t\tduplex;\n\n\tphy_interface_t\t\tphy_interface;\n\tstruct dma_chan\t*rx_chan;\n\tphys_addr_t emac_rx_fifo;\n};\n\nstruct emac_dma_req {\n\tstruct emac_board_info *db;\n\tstruct dma_async_tx_descriptor *desc;\n\tstruct sk_buff *skb;\n\tdma_addr_t rxbuf;\n\tint count;\n};\n\nstatic void emac_update_speed(struct net_device *dev)\n{\n\tstruct emac_board_info *db = netdev_priv(dev);\n\tunsigned int reg_val;\n\n\t \n\treg_val = readl(db->membase + EMAC_MAC_SUPP_REG);\n\treg_val &= ~EMAC_MAC_SUPP_100M;\n\tif (db->speed == SPEED_100)\n\t\treg_val |= EMAC_MAC_SUPP_100M;\n\twritel(reg_val, db->membase + EMAC_MAC_SUPP_REG);\n}\n\nstatic void emac_update_duplex(struct net_device *dev)\n{\n\tstruct emac_board_info *db = netdev_priv(dev);\n\tunsigned int reg_val;\n\n\t \n\treg_val = readl(db->membase + EMAC_MAC_CTL1_REG);\n\treg_val &= ~EMAC_MAC_CTL1_DUPLEX_EN;\n\tif (db->duplex)\n\t\treg_val |= EMAC_MAC_CTL1_DUPLEX_EN;\n\twritel(reg_val, db->membase + EMAC_MAC_CTL1_REG);\n}\n\nstatic void emac_handle_link_change(struct net_device *dev)\n{\n\tstruct emac_board_info *db = netdev_priv(dev);\n\tstruct phy_device *phydev = dev->phydev;\n\tunsigned long flags;\n\tint status_change = 0;\n\n\tif (phydev->link) {\n\t\tif (db->speed != phydev->speed) {\n\t\t\tspin_lock_irqsave(&db->lock, flags);\n\t\t\tdb->speed = phydev->speed;\n\t\t\temac_update_speed(dev);\n\t\t\tspin_unlock_irqrestore(&db->lock, flags);\n\t\t\tstatus_change = 1;\n\t\t}\n\n\t\tif (db->duplex != phydev->duplex) {\n\t\t\tspin_lock_irqsave(&db->lock, flags);\n\t\t\tdb->duplex = phydev->duplex;\n\t\t\temac_update_duplex(dev);\n\t\t\tspin_unlock_irqrestore(&db->lock, flags);\n\t\t\tstatus_change = 1;\n\t\t}\n\t}\n\n\tif (phydev->link != db->link) {\n\t\tif (!phydev->link) {\n\t\t\tdb->speed = 0;\n\t\t\tdb->duplex = -1;\n\t\t}\n\t\tdb->link = phydev->link;\n\n\t\tstatus_change = 1;\n\t}\n\n\tif (status_change)\n\t\tphy_print_status(phydev);\n}\n\nstatic int emac_mdio_probe(struct net_device *dev)\n{\n\tstruct emac_board_info *db = netdev_priv(dev);\n\tstruct phy_device *phydev;\n\n\t \n\n\t \n\tphydev = of_phy_connect(db->ndev, db->phy_node,\n\t\t\t\t&emac_handle_link_change, 0,\n\t\t\t\tdb->phy_interface);\n\tif (!phydev) {\n\t\tnetdev_err(db->ndev, \"could not find the PHY\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tphy_set_max_speed(phydev, SPEED_100);\n\n\tdb->link = 0;\n\tdb->speed = 0;\n\tdb->duplex = -1;\n\n\treturn 0;\n}\n\nstatic void emac_mdio_remove(struct net_device *dev)\n{\n\tphy_disconnect(dev->phydev);\n}\n\nstatic void emac_reset(struct emac_board_info *db)\n{\n\tdev_dbg(db->dev, \"resetting device\\n\");\n\n\t \n\twritel(0, db->membase + EMAC_CTL_REG);\n\tudelay(200);\n\twritel(EMAC_CTL_RESET, db->membase + EMAC_CTL_REG);\n\tudelay(200);\n}\n\nstatic void emac_outblk_32bit(void __iomem *reg, void *data, int count)\n{\n\twritesl(reg, data, round_up(count, 4) / 4);\n}\n\nstatic void emac_inblk_32bit(void __iomem *reg, void *data, int count)\n{\n\treadsl(reg, data, round_up(count, 4) / 4);\n}\n\nstatic struct emac_dma_req *\nemac_alloc_dma_req(struct emac_board_info *db,\n\t\t   struct dma_async_tx_descriptor *desc, struct sk_buff *skb,\n\t\t   dma_addr_t rxbuf, int count)\n{\n\tstruct emac_dma_req *req;\n\n\treq = kzalloc(sizeof(struct emac_dma_req), GFP_ATOMIC);\n\tif (!req)\n\t\treturn NULL;\n\n\treq->db = db;\n\treq->desc = desc;\n\treq->skb = skb;\n\treq->rxbuf = rxbuf;\n\treq->count = count;\n\treturn req;\n}\n\nstatic void emac_free_dma_req(struct emac_dma_req *req)\n{\n\tkfree(req);\n}\n\nstatic void emac_dma_done_callback(void *arg)\n{\n\tstruct emac_dma_req *req = arg;\n\tstruct emac_board_info *db = req->db;\n\tstruct sk_buff *skb = req->skb;\n\tstruct net_device *dev = db->ndev;\n\tint rxlen = req->count;\n\tu32 reg_val;\n\n\tdma_unmap_single(db->dev, req->rxbuf, rxlen, DMA_FROM_DEVICE);\n\n\tskb->protocol = eth_type_trans(skb, dev);\n\tnetif_rx(skb);\n\tdev->stats.rx_bytes += rxlen;\n\t \n\tdev->stats.rx_packets++;\n\n\t \n\treg_val = readl(db->membase + EMAC_RX_CTL_REG);\n\treg_val &= ~EMAC_RX_CTL_DMA_EN;\n\twritel(reg_val, db->membase + EMAC_RX_CTL_REG);\n\n\t \n\treg_val = readl(db->membase + EMAC_INT_CTL_REG);\n\treg_val |= EMAC_INT_CTL_RX_EN;\n\twritel(reg_val, db->membase + EMAC_INT_CTL_REG);\n\n\tdb->emacrx_completed_flag = 1;\n\temac_free_dma_req(req);\n}\n\nstatic int emac_dma_inblk_32bit(struct emac_board_info *db,\n\t\tstruct sk_buff *skb, void *rdptr, int count)\n{\n\tstruct dma_async_tx_descriptor *desc;\n\tdma_cookie_t cookie;\n\tdma_addr_t rxbuf;\n\tstruct emac_dma_req *req;\n\tint ret = 0;\n\n\trxbuf = dma_map_single(db->dev, rdptr, count, DMA_FROM_DEVICE);\n\tret = dma_mapping_error(db->dev, rxbuf);\n\tif (ret) {\n\t\tdev_err(db->dev, \"dma mapping error.\\n\");\n\t\treturn ret;\n\t}\n\n\tdesc = dmaengine_prep_slave_single(db->rx_chan, rxbuf, count,\n\t\t\t\t\t   DMA_DEV_TO_MEM,\n\t\t\t\t\t   DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc) {\n\t\tdev_err(db->dev, \"prepare slave single failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto prepare_err;\n\t}\n\n\treq = emac_alloc_dma_req(db, desc, skb, rxbuf, count);\n\tif (!req) {\n\t\tdev_err(db->dev, \"alloc emac dma req error.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto alloc_req_err;\n\t}\n\n\tdesc->callback_param = req;\n\tdesc->callback = emac_dma_done_callback;\n\n\tcookie = dmaengine_submit(desc);\n\tret = dma_submit_error(cookie);\n\tif (ret) {\n\t\tdev_err(db->dev, \"dma submit error.\\n\");\n\t\tgoto submit_err;\n\t}\n\n\tdma_async_issue_pending(db->rx_chan);\n\treturn ret;\n\nsubmit_err:\n\temac_free_dma_req(req);\n\nalloc_req_err:\n\tdmaengine_desc_free(desc);\n\nprepare_err:\n\tdma_unmap_single(db->dev, rxbuf, count, DMA_FROM_DEVICE);\n\treturn ret;\n}\n\n \nstatic void emac_get_drvinfo(struct net_device *dev,\n\t\t\t      struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->bus_info, dev_name(&dev->dev), sizeof(info->bus_info));\n}\n\nstatic u32 emac_get_msglevel(struct net_device *dev)\n{\n\tstruct emac_board_info *db = netdev_priv(dev);\n\n\treturn db->msg_enable;\n}\n\nstatic void emac_set_msglevel(struct net_device *dev, u32 value)\n{\n\tstruct emac_board_info *db = netdev_priv(dev);\n\n\tdb->msg_enable = value;\n}\n\nstatic const struct ethtool_ops emac_ethtool_ops = {\n\t.get_drvinfo\t= emac_get_drvinfo,\n\t.get_link\t= ethtool_op_get_link,\n\t.get_link_ksettings = phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings = phy_ethtool_set_link_ksettings,\n\t.get_msglevel\t= emac_get_msglevel,\n\t.set_msglevel\t= emac_set_msglevel,\n};\n\nstatic unsigned int emac_setup(struct net_device *ndev)\n{\n\tstruct emac_board_info *db = netdev_priv(ndev);\n\tunsigned int reg_val;\n\n\t \n\treg_val = readl(db->membase + EMAC_TX_MODE_REG);\n\n\twritel(reg_val | EMAC_TX_MODE_ABORTED_FRAME_EN,\n\t\tdb->membase + EMAC_TX_MODE_REG);\n\n\t \n\t \n\treg_val = readl(db->membase + EMAC_MAC_CTL0_REG);\n\twritel(reg_val | EMAC_MAC_CTL0_RX_FLOW_CTL_EN |\n\t\tEMAC_MAC_CTL0_TX_FLOW_CTL_EN,\n\t\tdb->membase + EMAC_MAC_CTL0_REG);\n\n\t \n\treg_val = readl(db->membase + EMAC_MAC_CTL1_REG);\n\treg_val |= EMAC_MAC_CTL1_LEN_CHECK_EN;\n\treg_val |= EMAC_MAC_CTL1_CRC_EN;\n\treg_val |= EMAC_MAC_CTL1_PAD_EN;\n\twritel(reg_val, db->membase + EMAC_MAC_CTL1_REG);\n\n\t \n\twritel(EMAC_MAC_IPGT_FULL_DUPLEX, db->membase + EMAC_MAC_IPGT_REG);\n\n\t \n\twritel((EMAC_MAC_IPGR_IPG1 << 8) | EMAC_MAC_IPGR_IPG2,\n\t\tdb->membase + EMAC_MAC_IPGR_REG);\n\n\t \n\twritel((EMAC_MAC_CLRT_COLLISION_WINDOW << 8) | EMAC_MAC_CLRT_RM,\n\t\tdb->membase + EMAC_MAC_CLRT_REG);\n\n\t \n\twritel(EMAC_MAX_FRAME_LEN,\n\t\tdb->membase + EMAC_MAC_MAXF_REG);\n\n\treturn 0;\n}\n\nstatic void emac_set_rx_mode(struct net_device *ndev)\n{\n\tstruct emac_board_info *db = netdev_priv(ndev);\n\tunsigned int reg_val;\n\n\t \n\treg_val = readl(db->membase + EMAC_RX_CTL_REG);\n\n\tif (ndev->flags & IFF_PROMISC)\n\t\treg_val |= EMAC_RX_CTL_PASS_ALL_EN;\n\telse\n\t\treg_val &= ~EMAC_RX_CTL_PASS_ALL_EN;\n\n\twritel(reg_val | EMAC_RX_CTL_PASS_LEN_OOR_EN |\n\t\tEMAC_RX_CTL_ACCEPT_UNICAST_EN | EMAC_RX_CTL_DA_FILTER_EN |\n\t\tEMAC_RX_CTL_ACCEPT_MULTICAST_EN |\n\t\tEMAC_RX_CTL_ACCEPT_BROADCAST_EN,\n\t\tdb->membase + EMAC_RX_CTL_REG);\n}\n\nstatic unsigned int emac_powerup(struct net_device *ndev)\n{\n\tstruct emac_board_info *db = netdev_priv(ndev);\n\tunsigned int reg_val;\n\n\t \n\t \n\treg_val = readl(db->membase + EMAC_RX_CTL_REG);\n\treg_val |= EMAC_RX_CTL_FLUSH_FIFO;\n\twritel(reg_val, db->membase + EMAC_RX_CTL_REG);\n\tudelay(1);\n\n\t \n\t \n\treg_val = readl(db->membase + EMAC_MAC_CTL0_REG);\n\treg_val &= ~EMAC_MAC_CTL0_SOFT_RESET;\n\twritel(reg_val, db->membase + EMAC_MAC_CTL0_REG);\n\n\t \n\treg_val = readl(db->membase + EMAC_MAC_MCFG_REG);\n\treg_val &= ~EMAC_MAC_MCFG_MII_CLKD_MASK;\n\treg_val |= EMAC_MAC_MCFG_MII_CLKD_72;\n\twritel(reg_val, db->membase + EMAC_MAC_MCFG_REG);\n\n\t \n\twritel(0x0, db->membase + EMAC_RX_FBC_REG);\n\n\t \n\twritel(0, db->membase + EMAC_INT_CTL_REG);\n\treg_val = readl(db->membase + EMAC_INT_STA_REG);\n\twritel(reg_val, db->membase + EMAC_INT_STA_REG);\n\n\tudelay(1);\n\n\t \n\temac_setup(ndev);\n\n\t \n\twritel(ndev->dev_addr[0] << 16 | ndev->dev_addr[1] << 8 | ndev->\n\t       dev_addr[2], db->membase + EMAC_MAC_A1_REG);\n\twritel(ndev->dev_addr[3] << 16 | ndev->dev_addr[4] << 8 | ndev->\n\t       dev_addr[5], db->membase + EMAC_MAC_A0_REG);\n\n\tmdelay(1);\n\n\treturn 0;\n}\n\nstatic int emac_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct sockaddr *addr = p;\n\tstruct emac_board_info *db = netdev_priv(dev);\n\n\tif (netif_running(dev))\n\t\treturn -EBUSY;\n\n\teth_hw_addr_set(dev, addr->sa_data);\n\n\twritel(dev->dev_addr[0] << 16 | dev->dev_addr[1] << 8 | dev->\n\t       dev_addr[2], db->membase + EMAC_MAC_A1_REG);\n\twritel(dev->dev_addr[3] << 16 | dev->dev_addr[4] << 8 | dev->\n\t       dev_addr[5], db->membase + EMAC_MAC_A0_REG);\n\n\treturn 0;\n}\n\n \nstatic void emac_init_device(struct net_device *dev)\n{\n\tstruct emac_board_info *db = netdev_priv(dev);\n\tunsigned long flags;\n\tunsigned int reg_val;\n\n\tspin_lock_irqsave(&db->lock, flags);\n\n\temac_update_speed(dev);\n\temac_update_duplex(dev);\n\n\t \n\treg_val = readl(db->membase + EMAC_CTL_REG);\n\twritel(reg_val | EMAC_CTL_RESET | EMAC_CTL_TX_EN | EMAC_CTL_RX_EN,\n\t\tdb->membase + EMAC_CTL_REG);\n\n\t \n\treg_val = readl(db->membase + EMAC_INT_CTL_REG);\n\treg_val |= (EMAC_INT_CTL_TX_EN | EMAC_INT_CTL_TX_ABRT_EN | EMAC_INT_CTL_RX_EN);\n\twritel(reg_val, db->membase + EMAC_INT_CTL_REG);\n\n\tspin_unlock_irqrestore(&db->lock, flags);\n}\n\n \nstatic void emac_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct emac_board_info *db = netdev_priv(dev);\n\tunsigned long flags;\n\n\tif (netif_msg_timer(db))\n\t\tdev_err(db->dev, \"tx time out.\\n\");\n\n\t \n\tspin_lock_irqsave(&db->lock, flags);\n\n\tnetif_stop_queue(dev);\n\temac_reset(db);\n\temac_init_device(dev);\n\t \n\tnetif_trans_update(dev);\n\tnetif_wake_queue(dev);\n\n\t \n\tspin_unlock_irqrestore(&db->lock, flags);\n}\n\n \nstatic netdev_tx_t emac_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct emac_board_info *db = netdev_priv(dev);\n\tunsigned long channel;\n\tunsigned long flags;\n\n\tchannel = db->tx_fifo_stat & 3;\n\tif (channel == 3)\n\t\treturn NETDEV_TX_BUSY;\n\n\tchannel = (channel == 1 ? 1 : 0);\n\n\tspin_lock_irqsave(&db->lock, flags);\n\n\twritel(channel, db->membase + EMAC_TX_INS_REG);\n\n\temac_outblk_32bit(db->membase + EMAC_TX_IO_DATA_REG,\n\t\t\tskb->data, skb->len);\n\tdev->stats.tx_bytes += skb->len;\n\n\tdb->tx_fifo_stat |= 1 << channel;\n\t \n\tif (channel == 0) {\n\t\t \n\t\twritel(skb->len, db->membase + EMAC_TX_PL0_REG);\n\t\t \n\t\twritel(readl(db->membase + EMAC_TX_CTL0_REG) | 1,\n\t\t       db->membase + EMAC_TX_CTL0_REG);\n\n\t\t \n\t\tnetif_trans_update(dev);\n\t} else if (channel == 1) {\n\t\t \n\t\twritel(skb->len, db->membase + EMAC_TX_PL1_REG);\n\t\t \n\t\twritel(readl(db->membase + EMAC_TX_CTL1_REG) | 1,\n\t\t       db->membase + EMAC_TX_CTL1_REG);\n\n\t\t \n\t\tnetif_trans_update(dev);\n\t}\n\n\tif ((db->tx_fifo_stat & 3) == 3) {\n\t\t \n\t\tnetif_stop_queue(dev);\n\t}\n\n\tspin_unlock_irqrestore(&db->lock, flags);\n\n\t \n\tdev_consume_skb_any(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic void emac_tx_done(struct net_device *dev, struct emac_board_info *db,\n\t\t\t  unsigned int tx_status)\n{\n\t \n\tdb->tx_fifo_stat &= ~(tx_status & 3);\n\tif (3 == (tx_status & 3))\n\t\tdev->stats.tx_packets += 2;\n\telse\n\t\tdev->stats.tx_packets++;\n\n\tif (netif_msg_tx_done(db))\n\t\tdev_dbg(db->dev, \"tx done, NSR %02x\\n\", tx_status);\n\n\tnetif_wake_queue(dev);\n}\n\n \nstatic void emac_rx(struct net_device *dev)\n{\n\tstruct emac_board_info *db = netdev_priv(dev);\n\tstruct sk_buff *skb;\n\tu8 *rdptr;\n\tbool good_packet;\n\tunsigned int reg_val;\n\tu32 rxhdr, rxstatus, rxcount, rxlen;\n\n\t \n\twhile (1) {\n\t\t \n\t\trxcount = readl(db->membase + EMAC_RX_FBC_REG);\n\n\t\tif (netif_msg_rx_status(db))\n\t\t\tdev_dbg(db->dev, \"RXCount: %x\\n\", rxcount);\n\n\t\tif (!rxcount) {\n\t\t\tdb->emacrx_completed_flag = 1;\n\t\t\treg_val = readl(db->membase + EMAC_INT_CTL_REG);\n\t\t\treg_val |= (EMAC_INT_CTL_TX_EN |\n\t\t\t\t\tEMAC_INT_CTL_TX_ABRT_EN |\n\t\t\t\t\tEMAC_INT_CTL_RX_EN);\n\t\t\twritel(reg_val, db->membase + EMAC_INT_CTL_REG);\n\n\t\t\t \n\t\t\trxcount = readl(db->membase + EMAC_RX_FBC_REG);\n\t\t\tif (!rxcount)\n\t\t\t\treturn;\n\t\t}\n\n\t\treg_val = readl(db->membase + EMAC_RX_IO_DATA_REG);\n\t\tif (netif_msg_rx_status(db))\n\t\t\tdev_dbg(db->dev, \"receive header: %x\\n\", reg_val);\n\t\tif (reg_val != EMAC_UNDOCUMENTED_MAGIC) {\n\t\t\t \n\t\t\treg_val = readl(db->membase + EMAC_CTL_REG);\n\t\t\twritel(reg_val & ~EMAC_CTL_RX_EN,\n\t\t\t       db->membase + EMAC_CTL_REG);\n\n\t\t\t \n\t\t\treg_val = readl(db->membase + EMAC_RX_CTL_REG);\n\t\t\twritel(reg_val | (1 << 3),\n\t\t\t       db->membase + EMAC_RX_CTL_REG);\n\n\t\t\tdo {\n\t\t\t\treg_val = readl(db->membase + EMAC_RX_CTL_REG);\n\t\t\t} while (reg_val & (1 << 3));\n\n\t\t\t \n\t\t\treg_val = readl(db->membase + EMAC_CTL_REG);\n\t\t\twritel(reg_val | EMAC_CTL_RX_EN,\n\t\t\t       db->membase + EMAC_CTL_REG);\n\t\t\treg_val = readl(db->membase + EMAC_INT_CTL_REG);\n\t\t\treg_val |= (EMAC_INT_CTL_TX_EN |\n\t\t\t\t\tEMAC_INT_CTL_TX_ABRT_EN |\n\t\t\t\t\tEMAC_INT_CTL_RX_EN);\n\t\t\twritel(reg_val, db->membase + EMAC_INT_CTL_REG);\n\n\t\t\tdb->emacrx_completed_flag = 1;\n\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tgood_packet = true;\n\n\t\trxhdr = readl(db->membase + EMAC_RX_IO_DATA_REG);\n\n\t\tif (netif_msg_rx_status(db))\n\t\t\tdev_dbg(db->dev, \"rxhdr: %x\\n\", *((int *)(&rxhdr)));\n\n\t\trxlen = EMAC_RX_IO_DATA_LEN(rxhdr);\n\t\trxstatus = EMAC_RX_IO_DATA_STATUS(rxhdr);\n\n\t\tif (netif_msg_rx_status(db))\n\t\t\tdev_dbg(db->dev, \"RX: status %02x, length %04x\\n\",\n\t\t\t\trxstatus, rxlen);\n\n\t\t \n\t\tif (rxlen < 0x40) {\n\t\t\tgood_packet = false;\n\t\t\tif (netif_msg_rx_err(db))\n\t\t\t\tdev_dbg(db->dev, \"RX: Bad Packet (runt)\\n\");\n\t\t}\n\n\t\tif (unlikely(!(rxstatus & EMAC_RX_IO_DATA_STATUS_OK))) {\n\t\t\tgood_packet = false;\n\n\t\t\tif (rxstatus & EMAC_RX_IO_DATA_STATUS_CRC_ERR) {\n\t\t\t\tif (netif_msg_rx_err(db))\n\t\t\t\t\tdev_dbg(db->dev, \"crc error\\n\");\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\t}\n\n\t\t\tif (rxstatus & EMAC_RX_IO_DATA_STATUS_LEN_ERR) {\n\t\t\t\tif (netif_msg_rx_err(db))\n\t\t\t\t\tdev_dbg(db->dev, \"length error\\n\");\n\t\t\t\tdev->stats.rx_length_errors++;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (good_packet) {\n\t\t\tskb = netdev_alloc_skb(dev, rxlen + 4);\n\t\t\tif (!skb)\n\t\t\t\tcontinue;\n\t\t\tskb_reserve(skb, 2);\n\t\t\trdptr = skb_put(skb, rxlen - 4);\n\n\t\t\t \n\t\t\tif (netif_msg_rx_status(db))\n\t\t\t\tdev_dbg(db->dev, \"RxLen %x\\n\", rxlen);\n\n\t\t\tif (rxlen >= dev->mtu && db->rx_chan) {\n\t\t\t\treg_val = readl(db->membase + EMAC_RX_CTL_REG);\n\t\t\t\treg_val |= EMAC_RX_CTL_DMA_EN;\n\t\t\t\twritel(reg_val, db->membase + EMAC_RX_CTL_REG);\n\t\t\t\tif (!emac_dma_inblk_32bit(db, skb, rdptr, rxlen))\n\t\t\t\t\tbreak;\n\n\t\t\t\t \n\t\t\t\treg_val = readl(db->membase + EMAC_RX_CTL_REG);\n\t\t\t\treg_val &= ~EMAC_RX_CTL_DMA_EN;\n\t\t\t\twritel(reg_val, db->membase + EMAC_RX_CTL_REG);\n\t\t\t}\n\n\t\t\temac_inblk_32bit(db->membase + EMAC_RX_IO_DATA_REG,\n\t\t\t\t\trdptr, rxlen);\n\t\t\tdev->stats.rx_bytes += rxlen;\n\n\t\t\t \n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\tnetif_rx(skb);\n\t\t\tdev->stats.rx_packets++;\n\t\t}\n\t}\n}\n\nstatic irqreturn_t emac_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct emac_board_info *db = netdev_priv(dev);\n\tint int_status;\n\tunsigned int reg_val;\n\n\t \n\n\tspin_lock(&db->lock);\n\n\t \n\twritel(0, db->membase + EMAC_INT_CTL_REG);\n\n\t \n\t \n\tint_status = readl(db->membase + EMAC_INT_STA_REG);\n\t \n\twritel(int_status, db->membase + EMAC_INT_STA_REG);\n\n\tif (netif_msg_intr(db))\n\t\tdev_dbg(db->dev, \"emac interrupt %02x\\n\", int_status);\n\n\t \n\tif ((int_status & 0x100) && (db->emacrx_completed_flag == 1)) {\n\t\t \n\t\tdb->emacrx_completed_flag = 0;\n\t\temac_rx(dev);\n\t}\n\n\t \n\tif (int_status & EMAC_INT_STA_TX_COMPLETE)\n\t\temac_tx_done(dev, db, int_status);\n\n\tif (int_status & EMAC_INT_STA_TX_ABRT)\n\t\tnetdev_info(dev, \" ab : %x\\n\", int_status);\n\n\t \n\tif (db->emacrx_completed_flag == 1) {\n\t\treg_val = readl(db->membase + EMAC_INT_CTL_REG);\n\t\treg_val |= (EMAC_INT_CTL_TX_EN | EMAC_INT_CTL_TX_ABRT_EN | EMAC_INT_CTL_RX_EN);\n\t\twritel(reg_val, db->membase + EMAC_INT_CTL_REG);\n\t} else {\n\t\treg_val = readl(db->membase + EMAC_INT_CTL_REG);\n\t\treg_val |= (EMAC_INT_CTL_TX_EN | EMAC_INT_CTL_TX_ABRT_EN);\n\t\twritel(reg_val, db->membase + EMAC_INT_CTL_REG);\n\t}\n\n\tspin_unlock(&db->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n \nstatic void emac_poll_controller(struct net_device *dev)\n{\n\tdisable_irq(dev->irq);\n\temac_interrupt(dev->irq, dev);\n\tenable_irq(dev->irq);\n}\n#endif\n\n \nstatic int emac_open(struct net_device *dev)\n{\n\tstruct emac_board_info *db = netdev_priv(dev);\n\tint ret;\n\n\tif (netif_msg_ifup(db))\n\t\tdev_dbg(db->dev, \"enabling %s\\n\", dev->name);\n\n\tif (request_irq(dev->irq, &emac_interrupt, 0, dev->name, dev))\n\t\treturn -EAGAIN;\n\n\t \n\temac_reset(db);\n\temac_init_device(dev);\n\n\tret = emac_mdio_probe(dev);\n\tif (ret < 0) {\n\t\tfree_irq(dev->irq, dev);\n\t\tnetdev_err(dev, \"cannot probe MDIO bus\\n\");\n\t\treturn ret;\n\t}\n\n\tphy_start(dev->phydev);\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\nstatic void emac_shutdown(struct net_device *dev)\n{\n\tunsigned int reg_val;\n\tstruct emac_board_info *db = netdev_priv(dev);\n\n\t \n\twritel(0, db->membase + EMAC_INT_CTL_REG);\n\n\t \n\treg_val = readl(db->membase + EMAC_INT_STA_REG);\n\twritel(reg_val, db->membase + EMAC_INT_STA_REG);\n\n\t \n\treg_val = readl(db->membase + EMAC_CTL_REG);\n\treg_val &= ~(EMAC_CTL_TX_EN | EMAC_CTL_RX_EN | EMAC_CTL_RESET);\n\twritel(reg_val, db->membase + EMAC_CTL_REG);\n}\n\n \nstatic int emac_stop(struct net_device *ndev)\n{\n\tstruct emac_board_info *db = netdev_priv(ndev);\n\n\tif (netif_msg_ifdown(db))\n\t\tdev_dbg(db->dev, \"shutting down %s\\n\", ndev->name);\n\n\tnetif_stop_queue(ndev);\n\tnetif_carrier_off(ndev);\n\n\tphy_stop(ndev->phydev);\n\n\temac_mdio_remove(ndev);\n\n\temac_shutdown(ndev);\n\n\tfree_irq(ndev->irq, ndev);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops emac_netdev_ops = {\n\t.ndo_open\t\t= emac_open,\n\t.ndo_stop\t\t= emac_stop,\n\t.ndo_start_xmit\t\t= emac_start_xmit,\n\t.ndo_tx_timeout\t\t= emac_timeout,\n\t.ndo_set_rx_mode\t= emac_set_rx_mode,\n\t.ndo_eth_ioctl\t\t= phy_do_ioctl_running,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= emac_set_mac_address,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= emac_poll_controller,\n#endif\n};\n\nstatic int emac_configure_dma(struct emac_board_info *db)\n{\n\tstruct platform_device *pdev = db->pdev;\n\tstruct net_device *ndev = db->ndev;\n\tstruct dma_slave_config conf = {};\n\tstruct resource *regs;\n\tint err = 0;\n\n\tregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!regs) {\n\t\tnetdev_err(ndev, \"get io resource from device failed.\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto out_clear_chan;\n\t}\n\n\tnetdev_info(ndev, \"get io resource from device: %pa, size = %u\\n\",\n\t\t    &regs->start, (unsigned int)resource_size(regs));\n\tdb->emac_rx_fifo = regs->start + EMAC_RX_IO_DATA_REG;\n\n\tdb->rx_chan = dma_request_chan(&pdev->dev, \"rx\");\n\tif (IS_ERR(db->rx_chan)) {\n\t\tnetdev_err(ndev,\n\t\t\t   \"failed to request dma channel. dma is disabled\\n\");\n\t\terr = PTR_ERR(db->rx_chan);\n\t\tgoto out_clear_chan;\n\t}\n\n\tconf.direction = DMA_DEV_TO_MEM;\n\tconf.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tconf.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tconf.src_addr = db->emac_rx_fifo;\n\tconf.dst_maxburst = 4;\n\tconf.src_maxburst = 4;\n\tconf.device_fc = false;\n\n\terr = dmaengine_slave_config(db->rx_chan, &conf);\n\tif (err) {\n\t\tnetdev_err(ndev, \"config dma slave failed\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out_slave_configure_err;\n\t}\n\n\treturn err;\n\nout_slave_configure_err:\n\tdma_release_channel(db->rx_chan);\n\nout_clear_chan:\n\tdb->rx_chan = NULL;\n\treturn err;\n}\n\n \nstatic int emac_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct emac_board_info *db;\n\tstruct net_device *ndev;\n\tint ret = 0;\n\n\tndev = alloc_etherdev(sizeof(struct emac_board_info));\n\tif (!ndev) {\n\t\tdev_err(&pdev->dev, \"could not allocate device.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tSET_NETDEV_DEV(ndev, &pdev->dev);\n\n\tdb = netdev_priv(ndev);\n\n\tdb->dev = &pdev->dev;\n\tdb->ndev = ndev;\n\tdb->pdev = pdev;\n\tdb->msg_enable = netif_msg_init(debug, EMAC_DEFAULT_MSG_ENABLE);\n\n\tspin_lock_init(&db->lock);\n\n\tdb->membase = of_iomap(np, 0);\n\tif (!db->membase) {\n\t\tdev_err(&pdev->dev, \"failed to remap registers\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tndev->base_addr = (unsigned long)db->membase;\n\tndev->irq = irq_of_parse_and_map(np, 0);\n\tif (ndev->irq == -ENXIO) {\n\t\tnetdev_err(ndev, \"No irq resource\\n\");\n\t\tret = ndev->irq;\n\t\tgoto out_iounmap;\n\t}\n\n\tif (emac_configure_dma(db))\n\t\tnetdev_info(ndev, \"configure dma failed. disable dma.\\n\");\n\n\tdb->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(db->clk)) {\n\t\tret = PTR_ERR(db->clk);\n\t\tgoto out_dispose_mapping;\n\t}\n\n\tret = clk_prepare_enable(db->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Error couldn't enable clock (%d)\\n\", ret);\n\t\tgoto out_dispose_mapping;\n\t}\n\n\tret = sunxi_sram_claim(&pdev->dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Error couldn't map SRAM to device\\n\");\n\t\tgoto out_clk_disable_unprepare;\n\t}\n\n\tdb->phy_node = of_parse_phandle(np, \"phy-handle\", 0);\n\tif (!db->phy_node)\n\t\tdb->phy_node = of_parse_phandle(np, \"phy\", 0);\n\tif (!db->phy_node) {\n\t\tdev_err(&pdev->dev, \"no associated PHY\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_release_sram;\n\t}\n\n\t \n\tret = of_get_ethdev_address(np, ndev);\n\tif (ret) {\n\t\t \n\t\teth_hw_addr_random(ndev);\n\t\tdev_warn(&pdev->dev, \"using random MAC address %pM\\n\",\n\t\t\t ndev->dev_addr);\n\t}\n\n\tdb->emacrx_completed_flag = 1;\n\temac_powerup(ndev);\n\temac_reset(db);\n\n\tndev->netdev_ops = &emac_netdev_ops;\n\tndev->watchdog_timeo = msecs_to_jiffies(watchdog);\n\tndev->ethtool_ops = &emac_ethtool_ops;\n\n\tplatform_set_drvdata(pdev, ndev);\n\n\t \n\tnetif_carrier_off(ndev);\n\n\tret = register_netdev(ndev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Registering netdev failed!\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_release_sram;\n\t}\n\n\tdev_info(&pdev->dev, \"%s: at %p, IRQ %d MAC: %pM\\n\",\n\t\t ndev->name, db->membase, ndev->irq, ndev->dev_addr);\n\n\treturn 0;\n\nout_release_sram:\n\tsunxi_sram_release(&pdev->dev);\nout_clk_disable_unprepare:\n\tclk_disable_unprepare(db->clk);\nout_dispose_mapping:\n\tirq_dispose_mapping(ndev->irq);\n\tdma_release_channel(db->rx_chan);\nout_iounmap:\n\tiounmap(db->membase);\nout:\n\tdev_err(db->dev, \"not found (%d).\\n\", ret);\n\n\tfree_netdev(ndev);\n\n\treturn ret;\n}\n\nstatic int emac_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct emac_board_info *db = netdev_priv(ndev);\n\n\tif (db->rx_chan) {\n\t\tdmaengine_terminate_all(db->rx_chan);\n\t\tdma_release_channel(db->rx_chan);\n\t}\n\n\tunregister_netdev(ndev);\n\tsunxi_sram_release(&pdev->dev);\n\tclk_disable_unprepare(db->clk);\n\tirq_dispose_mapping(ndev->irq);\n\tiounmap(db->membase);\n\tfree_netdev(ndev);\n\n\tdev_dbg(&pdev->dev, \"released and freed device\\n\");\n\treturn 0;\n}\n\nstatic int emac_suspend(struct platform_device *dev, pm_message_t state)\n{\n\tstruct net_device *ndev = platform_get_drvdata(dev);\n\n\tnetif_carrier_off(ndev);\n\tnetif_device_detach(ndev);\n\temac_shutdown(ndev);\n\n\treturn 0;\n}\n\nstatic int emac_resume(struct platform_device *dev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(dev);\n\tstruct emac_board_info *db = netdev_priv(ndev);\n\n\temac_reset(db);\n\temac_init_device(ndev);\n\tnetif_device_attach(ndev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id emac_of_match[] = {\n\t{.compatible = \"allwinner,sun4i-a10-emac\",},\n\n\t \n\t{.compatible = \"allwinner,sun4i-emac\",},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, emac_of_match);\n\nstatic struct platform_driver emac_driver = {\n\t.driver = {\n\t\t.name = \"sun4i-emac\",\n\t\t.of_match_table = emac_of_match,\n\t},\n\t.probe = emac_probe,\n\t.remove = emac_remove,\n\t.suspend = emac_suspend,\n\t.resume = emac_resume,\n};\n\nmodule_platform_driver(emac_driver);\n\nMODULE_AUTHOR(\"Stefan Roese <sr@denx.de>\");\nMODULE_AUTHOR(\"Maxime Ripard <maxime.ripard@free-electrons.com>\");\nMODULE_DESCRIPTION(\"Allwinner A10 emac network driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}