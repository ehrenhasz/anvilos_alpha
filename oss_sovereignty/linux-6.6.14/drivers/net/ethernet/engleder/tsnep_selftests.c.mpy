{
  "module_name": "tsnep_selftests.c",
  "hash_id": "b211ebf022a5f10db71aa11d6c717375a44b12d3f2c93eab00d2105e98eff123",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/engleder/tsnep_selftests.c",
  "human_readable_source": "\n \n\n#include \"tsnep.h\"\n\n#include <net/pkt_sched.h>\n\nenum tsnep_test {\n\tTSNEP_TEST_ENABLE = 0,\n\tTSNEP_TEST_TAPRIO,\n\tTSNEP_TEST_TAPRIO_CHANGE,\n\tTSNEP_TEST_TAPRIO_EXTENSION,\n};\n\nstatic const char tsnep_test_strings[][ETH_GSTRING_LEN] = {\n\t\"Enable timeout        (offline)\",\n\t\"TAPRIO                (offline)\",\n\t\"TAPRIO change         (offline)\",\n\t\"TAPRIO extension      (offline)\",\n};\n\n#define TSNEP_TEST_COUNT (sizeof(tsnep_test_strings) / ETH_GSTRING_LEN)\n\nstatic bool enable_gc_timeout(struct tsnep_adapter *adapter)\n{\n\tiowrite8(TSNEP_GC_ENABLE_TIMEOUT, adapter->addr + TSNEP_GC);\n\tif (!(ioread32(adapter->addr + TSNEP_GC) & TSNEP_GC_TIMEOUT_ACTIVE))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool gc_timeout_signaled(struct tsnep_adapter *adapter)\n{\n\tif (ioread32(adapter->addr + TSNEP_GC) & TSNEP_GC_TIMEOUT_SIGNAL)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool ack_gc_timeout(struct tsnep_adapter *adapter)\n{\n\tiowrite8(TSNEP_GC_ENABLE_TIMEOUT, adapter->addr + TSNEP_GC);\n\tif (ioread32(adapter->addr + TSNEP_GC) &\n\t    (TSNEP_GC_TIMEOUT_ACTIVE | TSNEP_GC_TIMEOUT_SIGNAL))\n\t\treturn false;\n\treturn true;\n}\n\nstatic bool enable_gc(struct tsnep_adapter *adapter, bool a)\n{\n\tu8 enable;\n\tu8 active;\n\n\tif (a) {\n\t\tenable = TSNEP_GC_ENABLE_A;\n\t\tactive = TSNEP_GC_ACTIVE_A;\n\t} else {\n\t\tenable = TSNEP_GC_ENABLE_B;\n\t\tactive = TSNEP_GC_ACTIVE_B;\n\t}\n\n\tiowrite8(enable, adapter->addr + TSNEP_GC);\n\tif (!(ioread32(adapter->addr + TSNEP_GC) & active))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool disable_gc(struct tsnep_adapter *adapter)\n{\n\tiowrite8(TSNEP_GC_DISABLE, adapter->addr + TSNEP_GC);\n\tif (ioread32(adapter->addr + TSNEP_GC) &\n\t    (TSNEP_GC_ACTIVE_A | TSNEP_GC_ACTIVE_B))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool gc_delayed_enable(struct tsnep_adapter *adapter, bool a, int delay)\n{\n\tu64 before, after;\n\tu32 time;\n\tbool enabled;\n\n\tif (!disable_gc(adapter))\n\t\treturn false;\n\n\tbefore = ktime_get_ns();\n\n\tif (!enable_gc_timeout(adapter))\n\t\treturn false;\n\n\t \n\ttime = ioread32(adapter->addr + ECM_SYSTEM_TIME_LOW);\n\ttime += TSNEP_GC_TIMEOUT;\n\tiowrite32(time, adapter->addr + TSNEP_GC_TIME);\n\n\tndelay(delay);\n\n\tenabled = enable_gc(adapter, a);\n\tafter = ktime_get_ns();\n\n\tif (delay > TSNEP_GC_TIMEOUT) {\n\t\t \n\t\tif (enabled)\n\t\t\treturn false;\n\t} else if ((after - before) < TSNEP_GC_TIMEOUT * 14 / 16) {\n\t\t \n\t\tif (!enabled)\n\t\t\treturn false;\n\t}\n\n\tif (enabled) {\n\t\tif (gc_timeout_signaled(adapter))\n\t\t\treturn false;\n\t} else {\n\t\tif (!gc_timeout_signaled(adapter))\n\t\t\treturn false;\n\t\tif (!ack_gc_timeout(adapter))\n\t\t\treturn false;\n\t}\n\n\tif (!disable_gc(adapter))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool tsnep_test_gc_enable(struct tsnep_adapter *adapter)\n{\n\tint i;\n\n\tiowrite32(0x80000001, adapter->addr + TSNEP_GCL_A + 0);\n\tiowrite32(100000, adapter->addr + TSNEP_GCL_A + 4);\n\n\tfor (i = 0; i < 200000; i += 100) {\n\t\tif (!gc_delayed_enable(adapter, true, i))\n\t\t\treturn false;\n\t}\n\n\tiowrite32(0x80000001, adapter->addr + TSNEP_GCL_B + 0);\n\tiowrite32(100000, adapter->addr + TSNEP_GCL_B + 4);\n\n\tfor (i = 0; i < 200000; i += 100) {\n\t\tif (!gc_delayed_enable(adapter, false, i))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void delay_base_time(struct tsnep_adapter *adapter,\n\t\t\t    struct tc_taprio_qopt_offload *qopt, s64 ms)\n{\n\tu64 system_time;\n\tu64 base_time = ktime_to_ns(qopt->base_time);\n\tu64 n;\n\n\ttsnep_get_system_time(adapter, &system_time);\n\tsystem_time += ms * 1000000;\n\tn = div64_u64(system_time - base_time, qopt->cycle_time);\n\n\tqopt->base_time = ktime_add_ns(qopt->base_time,\n\t\t\t\t       (n + 1) * qopt->cycle_time);\n}\n\nstatic void get_gate_state(struct tsnep_adapter *adapter, u32 *gc, u32 *gc_time,\n\t\t\t   u64 *system_time)\n{\n\tu32 time_high_before;\n\tu32 time_low;\n\tu32 time_high;\n\tu32 gc_time_before;\n\n\ttime_high = ioread32(adapter->addr + ECM_SYSTEM_TIME_HIGH);\n\t*gc_time = ioread32(adapter->addr + TSNEP_GC_TIME);\n\tdo {\n\t\ttime_low = ioread32(adapter->addr + ECM_SYSTEM_TIME_LOW);\n\t\t*gc = ioread32(adapter->addr + TSNEP_GC);\n\n\t\tgc_time_before = *gc_time;\n\t\t*gc_time = ioread32(adapter->addr + TSNEP_GC_TIME);\n\t\ttime_high_before = time_high;\n\t\ttime_high = ioread32(adapter->addr + ECM_SYSTEM_TIME_HIGH);\n\t} while ((time_high != time_high_before) ||\n\t\t (*gc_time != gc_time_before));\n\n\t*system_time = (((u64)time_high) << 32) | ((u64)time_low);\n}\n\nstatic int get_operation(struct tsnep_gcl *gcl, u64 system_time, u64 *next)\n{\n\tu64 n = div64_u64(system_time - gcl->base_time, gcl->cycle_time);\n\tu64 cycle_start = gcl->base_time + gcl->cycle_time * n;\n\tint i;\n\n\t*next = cycle_start;\n\tfor (i = 0; i < gcl->count; i++) {\n\t\t*next += gcl->operation[i].interval;\n\t\tif (*next > system_time)\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}\n\nstatic bool check_gate(struct tsnep_adapter *adapter)\n{\n\tu32 gc_time;\n\tu32 gc;\n\tu64 system_time;\n\tstruct tsnep_gcl *curr;\n\tstruct tsnep_gcl *prev;\n\tu64 next_time;\n\tu8 gate_open;\n\tu8 next_gate_open;\n\n\tget_gate_state(adapter, &gc, &gc_time, &system_time);\n\n\tif (gc & TSNEP_GC_ACTIVE_A) {\n\t\tcurr = &adapter->gcl[0];\n\t\tprev = &adapter->gcl[1];\n\t} else if (gc & TSNEP_GC_ACTIVE_B) {\n\t\tcurr = &adapter->gcl[1];\n\t\tprev = &adapter->gcl[0];\n\t} else {\n\t\treturn false;\n\t}\n\tif (curr->start_time <= system_time) {\n\t\t \n\t\tint index;\n\n\t\tindex = get_operation(curr, system_time, &next_time);\n\t\tgate_open = curr->operation[index].properties & TSNEP_GCL_MASK;\n\t\tif (index == curr->count - 1)\n\t\t\tindex = 0;\n\t\telse\n\t\t\tindex++;\n\t\tnext_gate_open =\n\t\t\tcurr->operation[index].properties & TSNEP_GCL_MASK;\n\t} else if (curr->change) {\n\t\t \n\t\tint index;\n\t\tu64 start_before;\n\t\tu64 n;\n\n\t\tindex = get_operation(prev, system_time, &next_time);\n\t\tnext_time = curr->start_time;\n\t\tstart_before = prev->base_time;\n\t\tn = div64_u64(curr->start_time - start_before,\n\t\t\t      prev->cycle_time);\n\t\tstart_before += n * prev->cycle_time;\n\t\tif (curr->start_time == start_before)\n\t\t\tstart_before -= prev->cycle_time;\n\t\tif (((start_before + prev->cycle_time_extension) >=\n\t\t     curr->start_time) &&\n\t\t    (curr->start_time - prev->cycle_time_extension <=\n\t\t     system_time)) {\n\t\t\t \n\t\t\tindex = prev->count - 1;\n\t\t}\n\t\tgate_open = prev->operation[index].properties & TSNEP_GCL_MASK;\n\t\tnext_gate_open =\n\t\t\tcurr->operation[0].properties & TSNEP_GCL_MASK;\n\t} else {\n\t\t \n\t\tnext_time = curr->start_time;\n\t\tgate_open = 0xFF;\n\t\tnext_gate_open = curr->operation[0].properties & TSNEP_GCL_MASK;\n\t}\n\n\tif (gc_time != (next_time & 0xFFFFFFFF)) {\n\t\tdev_err(&adapter->pdev->dev, \"gate control time 0x%x!=0x%llx\\n\",\n\t\t\tgc_time, next_time);\n\t\treturn false;\n\t}\n\tif (((gc & TSNEP_GC_OPEN) >> TSNEP_GC_OPEN_SHIFT) != gate_open) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"gate control open 0x%02x!=0x%02x\\n\",\n\t\t\t((gc & TSNEP_GC_OPEN) >> TSNEP_GC_OPEN_SHIFT),\n\t\t\tgate_open);\n\t\treturn false;\n\t}\n\tif (((gc & TSNEP_GC_NEXT_OPEN) >> TSNEP_GC_NEXT_OPEN_SHIFT) !=\n\t    next_gate_open) {\n\t\tdev_err(&adapter->pdev->dev,\n\t\t\t\"gate control next open 0x%02x!=0x%02x\\n\",\n\t\t\t((gc & TSNEP_GC_NEXT_OPEN) >> TSNEP_GC_NEXT_OPEN_SHIFT),\n\t\t\tnext_gate_open);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool check_gate_duration(struct tsnep_adapter *adapter, s64 ms)\n{\n\tktime_t start = ktime_get();\n\n\tdo {\n\t\tif (!check_gate(adapter))\n\t\t\treturn false;\n\t} while (ktime_ms_delta(ktime_get(), start) < ms);\n\n\treturn true;\n}\n\nstatic bool enable_check_taprio(struct tsnep_adapter *adapter,\n\t\t\t\tstruct tc_taprio_qopt_offload *qopt, s64 ms)\n{\n\tint retval;\n\n\tretval = tsnep_tc_setup(adapter->netdev, TC_SETUP_QDISC_TAPRIO, qopt);\n\tif (retval)\n\t\treturn false;\n\n\tif (!check_gate_duration(adapter, ms))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool disable_taprio(struct tsnep_adapter *adapter)\n{\n\tstruct tc_taprio_qopt_offload qopt;\n\tint retval;\n\n\tmemset(&qopt, 0, sizeof(qopt));\n\tqopt.cmd = TAPRIO_CMD_DESTROY;\n\tretval = tsnep_tc_setup(adapter->netdev, TC_SETUP_QDISC_TAPRIO, &qopt);\n\tif (retval)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool run_taprio(struct tsnep_adapter *adapter,\n\t\t       struct tc_taprio_qopt_offload *qopt, s64 ms)\n{\n\tif (!enable_check_taprio(adapter, qopt, ms))\n\t\treturn false;\n\n\tif (!disable_taprio(adapter))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool tsnep_test_taprio(struct tsnep_adapter *adapter)\n{\n\tstruct tc_taprio_qopt_offload *qopt;\n\tint i;\n\n\tqopt = kzalloc(struct_size(qopt, entries, 255), GFP_KERNEL);\n\tif (!qopt)\n\t\treturn false;\n\tfor (i = 0; i < 255; i++)\n\t\tqopt->entries[i].command = TC_TAPRIO_CMD_SET_GATES;\n\n\tqopt->cmd = TAPRIO_CMD_REPLACE;\n\tqopt->base_time = ktime_set(0, 0);\n\tqopt->cycle_time = 1500000;\n\tqopt->cycle_time_extension = 0;\n\tqopt->entries[0].gate_mask = 0x02;\n\tqopt->entries[0].interval = 200000;\n\tqopt->entries[1].gate_mask = 0x03;\n\tqopt->entries[1].interval = 800000;\n\tqopt->entries[2].gate_mask = 0x07;\n\tqopt->entries[2].interval = 240000;\n\tqopt->entries[3].gate_mask = 0x01;\n\tqopt->entries[3].interval = 80000;\n\tqopt->entries[4].gate_mask = 0x04;\n\tqopt->entries[4].interval = 70000;\n\tqopt->entries[5].gate_mask = 0x06;\n\tqopt->entries[5].interval = 60000;\n\tqopt->entries[6].gate_mask = 0x0F;\n\tqopt->entries[6].interval = 50000;\n\tqopt->num_entries = 7;\n\tif (!run_taprio(adapter, qopt, 100))\n\t\tgoto failed;\n\n\tqopt->cmd = TAPRIO_CMD_REPLACE;\n\tqopt->base_time = ktime_set(0, 0);\n\tqopt->cycle_time = 411854;\n\tqopt->cycle_time_extension = 0;\n\tqopt->entries[0].gate_mask = 0x17;\n\tqopt->entries[0].interval = 23842;\n\tqopt->entries[1].gate_mask = 0x16;\n\tqopt->entries[1].interval = 13482;\n\tqopt->entries[2].gate_mask = 0x15;\n\tqopt->entries[2].interval = 49428;\n\tqopt->entries[3].gate_mask = 0x14;\n\tqopt->entries[3].interval = 38189;\n\tqopt->entries[4].gate_mask = 0x13;\n\tqopt->entries[4].interval = 92321;\n\tqopt->entries[5].gate_mask = 0x12;\n\tqopt->entries[5].interval = 71239;\n\tqopt->entries[6].gate_mask = 0x11;\n\tqopt->entries[6].interval = 69932;\n\tqopt->entries[7].gate_mask = 0x10;\n\tqopt->entries[7].interval = 53421;\n\tqopt->num_entries = 8;\n\tif (!run_taprio(adapter, qopt, 100))\n\t\tgoto failed;\n\n\tqopt->cmd = TAPRIO_CMD_REPLACE;\n\tqopt->base_time = ktime_set(0, 0);\n\tdelay_base_time(adapter, qopt, 12);\n\tqopt->cycle_time = 125000;\n\tqopt->cycle_time_extension = 0;\n\tqopt->entries[0].gate_mask = 0x27;\n\tqopt->entries[0].interval = 15000;\n\tqopt->entries[1].gate_mask = 0x26;\n\tqopt->entries[1].interval = 15000;\n\tqopt->entries[2].gate_mask = 0x25;\n\tqopt->entries[2].interval = 12500;\n\tqopt->entries[3].gate_mask = 0x24;\n\tqopt->entries[3].interval = 17500;\n\tqopt->entries[4].gate_mask = 0x23;\n\tqopt->entries[4].interval = 10000;\n\tqopt->entries[5].gate_mask = 0x22;\n\tqopt->entries[5].interval = 11000;\n\tqopt->entries[6].gate_mask = 0x21;\n\tqopt->entries[6].interval = 9000;\n\tqopt->entries[7].gate_mask = 0x20;\n\tqopt->entries[7].interval = 10000;\n\tqopt->entries[8].gate_mask = 0x20;\n\tqopt->entries[8].interval = 12500;\n\tqopt->entries[9].gate_mask = 0x20;\n\tqopt->entries[9].interval = 12500;\n\tqopt->num_entries = 10;\n\tif (!run_taprio(adapter, qopt, 100))\n\t\tgoto failed;\n\n\tkfree(qopt);\n\n\treturn true;\n\nfailed:\n\tdisable_taprio(adapter);\n\tkfree(qopt);\n\n\treturn false;\n}\n\nstatic bool tsnep_test_taprio_change(struct tsnep_adapter *adapter)\n{\n\tstruct tc_taprio_qopt_offload *qopt;\n\tint i;\n\n\tqopt = kzalloc(struct_size(qopt, entries, 255), GFP_KERNEL);\n\tif (!qopt)\n\t\treturn false;\n\tfor (i = 0; i < 255; i++)\n\t\tqopt->entries[i].command = TC_TAPRIO_CMD_SET_GATES;\n\n\tqopt->cmd = TAPRIO_CMD_REPLACE;\n\tqopt->base_time = ktime_set(0, 0);\n\tqopt->cycle_time = 100000;\n\tqopt->cycle_time_extension = 0;\n\tqopt->entries[0].gate_mask = 0x30;\n\tqopt->entries[0].interval = 20000;\n\tqopt->entries[1].gate_mask = 0x31;\n\tqopt->entries[1].interval = 80000;\n\tqopt->num_entries = 2;\n\tif (!enable_check_taprio(adapter, qopt, 100))\n\t\tgoto failed;\n\n\t \n\tif (!enable_check_taprio(adapter, qopt, 100))\n\t\tgoto failed;\n\tdelay_base_time(adapter, qopt, 17);\n\tif (!enable_check_taprio(adapter, qopt, 100))\n\t\tgoto failed;\n\n\t \n\tqopt->base_time = ktime_set(0, 0);\n\tqopt->entries[0].gate_mask = 0x42;\n\tqopt->entries[1].gate_mask = 0x43;\n\tdelay_base_time(adapter, qopt, 2);\n\tif (!enable_check_taprio(adapter, qopt, 100))\n\t\tgoto failed;\n\tqopt->base_time = ktime_set(0, 0);\n\tqopt->entries[0].gate_mask = 0x54;\n\tqopt->entries[0].interval = 33333;\n\tqopt->entries[1].gate_mask = 0x55;\n\tqopt->entries[1].interval = 66667;\n\tdelay_base_time(adapter, qopt, 23);\n\tif (!enable_check_taprio(adapter, qopt, 100))\n\t\tgoto failed;\n\tqopt->base_time = ktime_set(0, 0);\n\tqopt->entries[0].gate_mask = 0x66;\n\tqopt->entries[0].interval = 50000;\n\tqopt->entries[1].gate_mask = 0x67;\n\tqopt->entries[1].interval = 25000;\n\tqopt->entries[2].gate_mask = 0x68;\n\tqopt->entries[2].interval = 25000;\n\tqopt->num_entries = 3;\n\tdelay_base_time(adapter, qopt, 11);\n\tif (!enable_check_taprio(adapter, qopt, 100))\n\t\tgoto failed;\n\n\t \n\tqopt->base_time = ktime_set(0, 0);\n\tqopt->cycle_time = 200000;\n\tqopt->entries[0].gate_mask = 0x79;\n\tqopt->entries[0].interval = 50000;\n\tqopt->entries[1].gate_mask = 0x7A;\n\tqopt->entries[1].interval = 150000;\n\tqopt->num_entries = 2;\n\tdelay_base_time(adapter, qopt, 11);\n\tif (!enable_check_taprio(adapter, qopt, 100))\n\t\tgoto failed;\n\tqopt->base_time = ktime_set(0, 0);\n\tqopt->cycle_time = 1000000;\n\tqopt->entries[0].gate_mask = 0x7B;\n\tqopt->entries[0].interval = 125000;\n\tqopt->entries[1].gate_mask = 0x7C;\n\tqopt->entries[1].interval = 250000;\n\tqopt->entries[2].gate_mask = 0x7D;\n\tqopt->entries[2].interval = 375000;\n\tqopt->entries[3].gate_mask = 0x7E;\n\tqopt->entries[3].interval = 250000;\n\tqopt->num_entries = 4;\n\tdelay_base_time(adapter, qopt, 3);\n\tif (!enable_check_taprio(adapter, qopt, 100))\n\t\tgoto failed;\n\n\t \n\tqopt->base_time = ktime_set(0, 0);\n\tqopt->cycle_time = 333333;\n\tqopt->entries[0].gate_mask = 0x8F;\n\tqopt->entries[0].interval = 166666;\n\tqopt->entries[1].gate_mask = 0x80;\n\tqopt->entries[1].interval = 166667;\n\tqopt->num_entries = 2;\n\tdelay_base_time(adapter, qopt, 11);\n\tif (!enable_check_taprio(adapter, qopt, 100))\n\t\tgoto failed;\n\tqopt->base_time = ktime_set(0, 0);\n\tqopt->cycle_time = 62500;\n\tqopt->entries[0].gate_mask = 0x81;\n\tqopt->entries[0].interval = 31250;\n\tqopt->entries[1].gate_mask = 0x82;\n\tqopt->entries[1].interval = 15625;\n\tqopt->entries[2].gate_mask = 0x83;\n\tqopt->entries[2].interval = 15625;\n\tqopt->num_entries = 3;\n\tdelay_base_time(adapter, qopt, 1);\n\tif (!enable_check_taprio(adapter, qopt, 100))\n\t\tgoto failed;\n\n\t \n\tqopt->base_time = ktime_set(0, 0);\n\tqopt->cycle_time = 400000;\n\tqopt->entries[0].gate_mask = 0x84;\n\tqopt->entries[0].interval = 100000;\n\tqopt->entries[1].gate_mask = 0x85;\n\tqopt->entries[1].interval = 100000;\n\tqopt->entries[2].gate_mask = 0x86;\n\tqopt->entries[2].interval = 100000;\n\tqopt->entries[3].gate_mask = 0x87;\n\tqopt->entries[3].interval = 100000;\n\tqopt->num_entries = 4;\n\tdelay_base_time(adapter, qopt, 7);\n\tif (!enable_check_taprio(adapter, qopt, 100))\n\t\tgoto failed;\n\tqopt->base_time = ktime_set(0, 0);\n\tqopt->cycle_time = 1700000;\n\tqopt->entries[0].gate_mask = 0x88;\n\tqopt->entries[0].interval = 200000;\n\tqopt->entries[1].gate_mask = 0x89;\n\tqopt->entries[1].interval = 300000;\n\tqopt->entries[2].gate_mask = 0x8A;\n\tqopt->entries[2].interval = 600000;\n\tqopt->entries[3].gate_mask = 0x8B;\n\tqopt->entries[3].interval = 100000;\n\tqopt->entries[4].gate_mask = 0x8C;\n\tqopt->entries[4].interval = 500000;\n\tqopt->num_entries = 5;\n\tdelay_base_time(adapter, qopt, 6);\n\tif (!enable_check_taprio(adapter, qopt, 100))\n\t\tgoto failed;\n\n\tif (!disable_taprio(adapter))\n\t\tgoto failed;\n\n\tkfree(qopt);\n\n\treturn true;\n\nfailed:\n\tdisable_taprio(adapter);\n\tkfree(qopt);\n\n\treturn false;\n}\n\nstatic bool tsnep_test_taprio_extension(struct tsnep_adapter *adapter)\n{\n\tstruct tc_taprio_qopt_offload *qopt;\n\tint i;\n\n\tqopt = kzalloc(struct_size(qopt, entries, 255), GFP_KERNEL);\n\tif (!qopt)\n\t\treturn false;\n\tfor (i = 0; i < 255; i++)\n\t\tqopt->entries[i].command = TC_TAPRIO_CMD_SET_GATES;\n\n\tqopt->cmd = TAPRIO_CMD_REPLACE;\n\tqopt->base_time = ktime_set(0, 0);\n\tqopt->cycle_time = 100000;\n\tqopt->cycle_time_extension = 50000;\n\tqopt->entries[0].gate_mask = 0x90;\n\tqopt->entries[0].interval = 20000;\n\tqopt->entries[1].gate_mask = 0x91;\n\tqopt->entries[1].interval = 80000;\n\tqopt->num_entries = 2;\n\tif (!enable_check_taprio(adapter, qopt, 100))\n\t\tgoto failed;\n\n\t \n\tqopt->base_time = ktime_set(0, 50000);\n\tqopt->entries[0].gate_mask = 0x92;\n\tqopt->entries[0].interval = 33000;\n\tqopt->entries[1].gate_mask = 0x93;\n\tqopt->entries[1].interval = 67000;\n\tqopt->num_entries = 2;\n\tdelay_base_time(adapter, qopt, 2);\n\tif (!enable_check_taprio(adapter, qopt, 100))\n\t\tgoto failed;\n\n\t \n\tqopt->base_time = ktime_set(0, 0);\n\tqopt->cycle_time = 1000000;\n\tqopt->cycle_time_extension = 700000;\n\tqopt->entries[0].gate_mask = 0x94;\n\tqopt->entries[0].interval = 400000;\n\tqopt->entries[1].gate_mask = 0x95;\n\tqopt->entries[1].interval = 600000;\n\tqopt->num_entries = 2;\n\tdelay_base_time(adapter, qopt, 7);\n\tif (!enable_check_taprio(adapter, qopt, 100))\n\t\tgoto failed;\n\tqopt->base_time = ktime_set(0, 700000);\n\tqopt->cycle_time = 2000000;\n\tqopt->cycle_time_extension = 1900000;\n\tqopt->entries[0].gate_mask = 0x96;\n\tqopt->entries[0].interval = 400000;\n\tqopt->entries[1].gate_mask = 0x97;\n\tqopt->entries[1].interval = 1600000;\n\tqopt->num_entries = 2;\n\tdelay_base_time(adapter, qopt, 9);\n\tif (!enable_check_taprio(adapter, qopt, 100))\n\t\tgoto failed;\n\n\t \n\tqopt->base_time = ktime_set(0, 0);\n\tqopt->cycle_time = 1500000;\n\tqopt->cycle_time_extension = 700000;\n\tqopt->entries[0].gate_mask = 0x98;\n\tqopt->entries[0].interval = 400000;\n\tqopt->entries[1].gate_mask = 0x99;\n\tqopt->entries[1].interval = 600000;\n\tqopt->entries[2].gate_mask = 0x9A;\n\tqopt->entries[2].interval = 500000;\n\tqopt->num_entries = 3;\n\tdelay_base_time(adapter, qopt, 3);\n\tif (!enable_check_taprio(adapter, qopt, 100))\n\t\tgoto failed;\n\tqopt->base_time = ktime_set(0, 100000);\n\tqopt->cycle_time = 500000;\n\tqopt->cycle_time_extension = 300000;\n\tqopt->entries[0].gate_mask = 0x9B;\n\tqopt->entries[0].interval = 150000;\n\tqopt->entries[1].gate_mask = 0x9C;\n\tqopt->entries[1].interval = 350000;\n\tqopt->num_entries = 2;\n\tdelay_base_time(adapter, qopt, 9);\n\tif (!enable_check_taprio(adapter, qopt, 100))\n\t\tgoto failed;\n\n\t \n\tqopt->base_time = ktime_set(0, 0);\n\tqopt->cycle_time = 1000000;\n\tqopt->cycle_time_extension = 700000;\n\tqopt->entries[0].gate_mask = 0xAD;\n\tqopt->entries[0].interval = 400000;\n\tqopt->entries[1].gate_mask = 0xAE;\n\tqopt->entries[1].interval = 300000;\n\tqopt->entries[2].gate_mask = 0xAF;\n\tqopt->entries[2].interval = 300000;\n\tqopt->num_entries = 3;\n\tif (!enable_check_taprio(adapter, qopt, 100))\n\t\tgoto failed;\n\tqopt->base_time = ktime_set(0, 0);\n\tqopt->cycle_time = 400000;\n\tqopt->cycle_time_extension = 100000;\n\tqopt->entries[0].gate_mask = 0xA0;\n\tqopt->entries[0].interval = 200000;\n\tqopt->entries[1].gate_mask = 0xA1;\n\tqopt->entries[1].interval = 200000;\n\tqopt->num_entries = 2;\n\tdelay_base_time(adapter, qopt, 19);\n\tif (!enable_check_taprio(adapter, qopt, 100))\n\t\tgoto failed;\n\tqopt->base_time = ktime_set(0, 0);\n\tqopt->cycle_time = 500000;\n\tqopt->cycle_time_extension = 499999;\n\tqopt->entries[0].gate_mask = 0xB2;\n\tqopt->entries[0].interval = 100000;\n\tqopt->entries[1].gate_mask = 0xB3;\n\tqopt->entries[1].interval = 100000;\n\tqopt->entries[2].gate_mask = 0xB4;\n\tqopt->entries[2].interval = 100000;\n\tqopt->entries[3].gate_mask = 0xB5;\n\tqopt->entries[3].interval = 200000;\n\tqopt->num_entries = 4;\n\tdelay_base_time(adapter, qopt, 19);\n\tif (!enable_check_taprio(adapter, qopt, 100))\n\t\tgoto failed;\n\tqopt->base_time = ktime_set(0, 0);\n\tqopt->cycle_time = 6000000;\n\tqopt->cycle_time_extension = 5999999;\n\tqopt->entries[0].gate_mask = 0xC6;\n\tqopt->entries[0].interval = 1000000;\n\tqopt->entries[1].gate_mask = 0xC7;\n\tqopt->entries[1].interval = 1000000;\n\tqopt->entries[2].gate_mask = 0xC8;\n\tqopt->entries[2].interval = 1000000;\n\tqopt->entries[3].gate_mask = 0xC9;\n\tqopt->entries[3].interval = 1500000;\n\tqopt->entries[4].gate_mask = 0xCA;\n\tqopt->entries[4].interval = 1500000;\n\tqopt->num_entries = 5;\n\tdelay_base_time(adapter, qopt, 1);\n\tif (!enable_check_taprio(adapter, qopt, 100))\n\t\tgoto failed;\n\n\tif (!disable_taprio(adapter))\n\t\tgoto failed;\n\n\tkfree(qopt);\n\n\treturn true;\n\nfailed:\n\tdisable_taprio(adapter);\n\tkfree(qopt);\n\n\treturn false;\n}\n\nint tsnep_ethtool_get_test_count(void)\n{\n\treturn TSNEP_TEST_COUNT;\n}\n\nvoid tsnep_ethtool_get_test_strings(u8 *data)\n{\n\tmemcpy(data, tsnep_test_strings, sizeof(tsnep_test_strings));\n}\n\nvoid tsnep_ethtool_self_test(struct net_device *netdev,\n\t\t\t     struct ethtool_test *eth_test, u64 *data)\n{\n\tstruct tsnep_adapter *adapter = netdev_priv(netdev);\n\n\teth_test->len = TSNEP_TEST_COUNT;\n\n\tif (eth_test->flags != ETH_TEST_FL_OFFLINE) {\n\t\t \n\t\tdata[TSNEP_TEST_ENABLE] = 0;\n\t\tdata[TSNEP_TEST_TAPRIO] = 0;\n\t\tdata[TSNEP_TEST_TAPRIO_CHANGE] = 0;\n\t\tdata[TSNEP_TEST_TAPRIO_EXTENSION] = 0;\n\n\t\treturn;\n\t}\n\n\tif (tsnep_test_gc_enable(adapter)) {\n\t\tdata[TSNEP_TEST_ENABLE] = 0;\n\t} else {\n\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\t\tdata[TSNEP_TEST_ENABLE] = 1;\n\t}\n\n\tif (tsnep_test_taprio(adapter)) {\n\t\tdata[TSNEP_TEST_TAPRIO] = 0;\n\t} else {\n\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\t\tdata[TSNEP_TEST_TAPRIO] = 1;\n\t}\n\n\tif (tsnep_test_taprio_change(adapter)) {\n\t\tdata[TSNEP_TEST_TAPRIO_CHANGE] = 0;\n\t} else {\n\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\t\tdata[TSNEP_TEST_TAPRIO_CHANGE] = 1;\n\t}\n\n\tif (tsnep_test_taprio_extension(adapter)) {\n\t\tdata[TSNEP_TEST_TAPRIO_EXTENSION] = 0;\n\t} else {\n\t\teth_test->flags |= ETH_TEST_FL_FAILED;\n\t\tdata[TSNEP_TEST_TAPRIO_EXTENSION] = 1;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}