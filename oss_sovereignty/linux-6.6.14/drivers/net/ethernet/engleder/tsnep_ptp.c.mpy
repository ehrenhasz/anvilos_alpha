{
  "module_name": "tsnep_ptp.c",
  "hash_id": "0a6a2494ad267757851883b4b1e2427380ec394ca539e5d97805bfd3751b9f1e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/engleder/tsnep_ptp.c",
  "human_readable_source": "\n \n\n#include \"tsnep.h\"\n\nvoid tsnep_get_system_time(struct tsnep_adapter *adapter, u64 *time)\n{\n\tu32 high_before;\n\tu32 low;\n\tu32 high;\n\n\t \n\thigh = ioread32(adapter->addr + ECM_SYSTEM_TIME_HIGH);\n\tdo {\n\t\tlow = ioread32(adapter->addr + ECM_SYSTEM_TIME_LOW);\n\t\thigh_before = high;\n\t\thigh = ioread32(adapter->addr + ECM_SYSTEM_TIME_HIGH);\n\t} while (high != high_before);\n\t*time = (((u64)high) << 32) | ((u64)low);\n}\n\nint tsnep_ptp_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\n{\n\tstruct tsnep_adapter *adapter = netdev_priv(netdev);\n\tstruct hwtstamp_config config;\n\n\tif (!ifr)\n\t\treturn -EINVAL;\n\n\tif (cmd == SIOCSHWTSTAMP) {\n\t\tif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\n\t\t\treturn -EFAULT;\n\n\t\tswitch (config.tx_type) {\n\t\tcase HWTSTAMP_TX_OFF:\n\t\tcase HWTSTAMP_TX_ON:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ERANGE;\n\t\t}\n\n\t\tswitch (config.rx_filter) {\n\t\tcase HWTSTAMP_FILTER_NONE:\n\t\t\tbreak;\n\t\tcase HWTSTAMP_FILTER_ALL:\n\t\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\t\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\t\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\t\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\t\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\t\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\t\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\t\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\t\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\t\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\t\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\t\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\t\tcase HWTSTAMP_FILTER_NTP_ALL:\n\t\t\tconfig.rx_filter = HWTSTAMP_FILTER_ALL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ERANGE;\n\t\t}\n\n\t\tmemcpy(&adapter->hwtstamp_config, &config,\n\t\t       sizeof(adapter->hwtstamp_config));\n\t}\n\n\tif (copy_to_user(ifr->ifr_data, &adapter->hwtstamp_config,\n\t\t\t sizeof(adapter->hwtstamp_config)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int tsnep_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct tsnep_adapter *adapter = container_of(ptp, struct tsnep_adapter,\n\t\t\t\t\t\t     ptp_clock_info);\n\tbool negative = false;\n\tu64 rate_offset;\n\n\tif (scaled_ppm < 0) {\n\t\tscaled_ppm = -scaled_ppm;\n\t\tnegative = true;\n\t}\n\n\t \n\trate_offset = scaled_ppm;\n\trate_offset <<= 16 - 3;\n\trate_offset = div_u64(rate_offset, 15625);\n\n\trate_offset &= ECM_CLOCK_RATE_OFFSET_MASK;\n\tif (negative)\n\t\trate_offset |= ECM_CLOCK_RATE_OFFSET_SIGN;\n\tiowrite32(rate_offset & 0xFFFFFFFF, adapter->addr + ECM_CLOCK_RATE);\n\n\treturn 0;\n}\n\nstatic int tsnep_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct tsnep_adapter *adapter = container_of(ptp, struct tsnep_adapter,\n\t\t\t\t\t\t     ptp_clock_info);\n\tu64 system_time;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&adapter->ptp_lock, flags);\n\n\ttsnep_get_system_time(adapter, &system_time);\n\n\tsystem_time += delta;\n\n\t \n\tiowrite32(system_time >> 32, adapter->addr + ECM_SYSTEM_TIME_HIGH);\n\tiowrite32(system_time & 0xFFFFFFFF,\n\t\t  adapter->addr + ECM_SYSTEM_TIME_LOW);\n\n\tspin_unlock_irqrestore(&adapter->ptp_lock, flags);\n\n\treturn 0;\n}\n\nstatic int tsnep_ptp_gettimex64(struct ptp_clock_info *ptp,\n\t\t\t\tstruct timespec64 *ts,\n\t\t\t\tstruct ptp_system_timestamp *sts)\n{\n\tstruct tsnep_adapter *adapter = container_of(ptp, struct tsnep_adapter,\n\t\t\t\t\t\t     ptp_clock_info);\n\tu32 high_before;\n\tu32 low;\n\tu32 high;\n\tu64 system_time;\n\n\t \n\thigh = ioread32(adapter->addr + ECM_SYSTEM_TIME_HIGH);\n\tdo {\n\t\tptp_read_system_prets(sts);\n\t\tlow = ioread32(adapter->addr + ECM_SYSTEM_TIME_LOW);\n\t\tptp_read_system_postts(sts);\n\t\thigh_before = high;\n\t\thigh = ioread32(adapter->addr + ECM_SYSTEM_TIME_HIGH);\n\t} while (high != high_before);\n\tsystem_time = (((u64)high) << 32) | ((u64)low);\n\n\t*ts = ns_to_timespec64(system_time);\n\n\treturn 0;\n}\n\nstatic int tsnep_ptp_settime64(struct ptp_clock_info *ptp,\n\t\t\t       const struct timespec64 *ts)\n{\n\tstruct tsnep_adapter *adapter = container_of(ptp, struct tsnep_adapter,\n\t\t\t\t\t\t     ptp_clock_info);\n\tu64 system_time = timespec64_to_ns(ts);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&adapter->ptp_lock, flags);\n\n\t \n\tiowrite32(system_time >> 32, adapter->addr + ECM_SYSTEM_TIME_HIGH);\n\tiowrite32(system_time & 0xFFFFFFFF,\n\t\t  adapter->addr + ECM_SYSTEM_TIME_LOW);\n\n\tspin_unlock_irqrestore(&adapter->ptp_lock, flags);\n\n\treturn 0;\n}\n\nstatic int tsnep_ptp_getcyclesx64(struct ptp_clock_info *ptp,\n\t\t\t\t  struct timespec64 *ts,\n\t\t\t\t  struct ptp_system_timestamp *sts)\n{\n\tstruct tsnep_adapter *adapter = container_of(ptp, struct tsnep_adapter,\n\t\t\t\t\t\t     ptp_clock_info);\n\tu32 high_before;\n\tu32 low;\n\tu32 high;\n\tu64 counter;\n\n\t \n\thigh = ioread32(adapter->addr + ECM_COUNTER_HIGH);\n\tdo {\n\t\tptp_read_system_prets(sts);\n\t\tlow = ioread32(adapter->addr + ECM_COUNTER_LOW);\n\t\tptp_read_system_postts(sts);\n\t\thigh_before = high;\n\t\thigh = ioread32(adapter->addr + ECM_COUNTER_HIGH);\n\t} while (high != high_before);\n\tcounter = (((u64)high) << 32) | ((u64)low);\n\n\t*ts = ns_to_timespec64(counter);\n\n\treturn 0;\n}\n\nint tsnep_ptp_init(struct tsnep_adapter *adapter)\n{\n\tint retval = 0;\n\n\tadapter->hwtstamp_config.rx_filter = HWTSTAMP_FILTER_NONE;\n\tadapter->hwtstamp_config.tx_type = HWTSTAMP_TX_OFF;\n\n\tsnprintf(adapter->ptp_clock_info.name, 16, \"%s\", TSNEP);\n\tadapter->ptp_clock_info.owner = THIS_MODULE;\n\t \n\tadapter->ptp_clock_info.max_adj = (500000000 / 8 - 1);\n\tadapter->ptp_clock_info.adjfine = tsnep_ptp_adjfine;\n\tadapter->ptp_clock_info.adjtime = tsnep_ptp_adjtime;\n\tadapter->ptp_clock_info.gettimex64 = tsnep_ptp_gettimex64;\n\tadapter->ptp_clock_info.settime64 = tsnep_ptp_settime64;\n\tadapter->ptp_clock_info.getcyclesx64 = tsnep_ptp_getcyclesx64;\n\n\tspin_lock_init(&adapter->ptp_lock);\n\n\tadapter->ptp_clock = ptp_clock_register(&adapter->ptp_clock_info,\n\t\t\t\t\t\t&adapter->pdev->dev);\n\tif (IS_ERR(adapter->ptp_clock)) {\n\t\tnetdev_err(adapter->netdev, \"ptp_clock_register failed\\n\");\n\n\t\tretval = PTR_ERR(adapter->ptp_clock);\n\t\tadapter->ptp_clock = NULL;\n\t} else if (adapter->ptp_clock) {\n\t\tnetdev_info(adapter->netdev, \"PHC added\\n\");\n\t}\n\n\treturn retval;\n}\n\nvoid tsnep_ptp_cleanup(struct tsnep_adapter *adapter)\n{\n\tif (adapter->ptp_clock) {\n\t\tptp_clock_unregister(adapter->ptp_clock);\n\t\tnetdev_info(adapter->netdev, \"PHC removed\\n\");\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}