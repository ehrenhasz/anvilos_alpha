{
  "module_name": "tsnep_tc.c",
  "hash_id": "647cbf3778f6c7f533d7aa5df1c0793fa5d3fa5cea6d5e4dd915a5579adbea75",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/engleder/tsnep_tc.c",
  "human_readable_source": "\n \n\n#include \"tsnep.h\"\n\n#include <net/pkt_sched.h>\n\n \n#define TSNEP_MAX_GCL_NUM (TSNEP_GCL_COUNT - 1)\n\nstatic int tsnep_validate_gcl(struct tc_taprio_qopt_offload *qopt)\n{\n\tint i;\n\tu64 cycle_time;\n\n\tif (!qopt->cycle_time)\n\t\treturn -ERANGE;\n\tif (qopt->num_entries > TSNEP_MAX_GCL_NUM)\n\t\treturn -EINVAL;\n\tcycle_time = 0;\n\tfor (i = 0; i < qopt->num_entries; i++) {\n\t\tif (qopt->entries[i].command != TC_TAPRIO_CMD_SET_GATES)\n\t\t\treturn -EINVAL;\n\t\tif (qopt->entries[i].gate_mask & ~TSNEP_GCL_MASK)\n\t\t\treturn -EINVAL;\n\t\tif (qopt->entries[i].interval < TSNEP_GCL_MIN_INTERVAL)\n\t\t\treturn -EINVAL;\n\t\tcycle_time += qopt->entries[i].interval;\n\t}\n\tif (qopt->cycle_time != cycle_time)\n\t\treturn -EINVAL;\n\tif (qopt->cycle_time_extension >= qopt->cycle_time)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void tsnep_write_gcl_operation(struct tsnep_gcl *gcl, int index,\n\t\t\t\t      u32 properties, u32 interval, bool flush)\n{\n\tvoid __iomem *addr = gcl->addr +\n\t\t\t     sizeof(struct tsnep_gcl_operation) * index;\n\n\tgcl->operation[index].properties = properties;\n\tgcl->operation[index].interval = interval;\n\n\tiowrite32(properties, addr);\n\tiowrite32(interval, addr + sizeof(u32));\n\n\tif (flush) {\n\t\t \n\t\tioread32(addr);\n\t}\n}\n\nstatic u64 tsnep_change_duration(struct tsnep_gcl *gcl, int index)\n{\n\tu64 duration;\n\tint count;\n\n\t \n\tduration = 0;\n\tcount = 3;\n\twhile (count) {\n\t\tduration += gcl->operation[index].interval;\n\n\t\tindex--;\n\t\tif (index < 0)\n\t\t\tindex = gcl->count - 1;\n\n\t\tcount--;\n\t}\n\n\treturn duration;\n}\n\nstatic void tsnep_write_gcl(struct tsnep_gcl *gcl,\n\t\t\t    struct tc_taprio_qopt_offload *qopt)\n{\n\tint i;\n\tu32 properties;\n\tu64 extend;\n\tu64 cut;\n\n\tgcl->base_time = ktime_to_ns(qopt->base_time);\n\tgcl->cycle_time = qopt->cycle_time;\n\tgcl->cycle_time_extension = qopt->cycle_time_extension;\n\n\tfor (i = 0; i < qopt->num_entries; i++) {\n\t\tproperties = qopt->entries[i].gate_mask;\n\t\tif (i == (qopt->num_entries - 1))\n\t\t\tproperties |= TSNEP_GCL_LAST;\n\n\t\ttsnep_write_gcl_operation(gcl, i, properties,\n\t\t\t\t\t  qopt->entries[i].interval, true);\n\t}\n\tgcl->count = qopt->num_entries;\n\n\t \n\n\t \n\textend = tsnep_change_duration(gcl, gcl->count - 1);\n\textend += gcl->cycle_time_extension;\n\n\t \n\tcut = 0;\n\tfor (i = 0; i < gcl->count; i++)\n\t\tcut = max(cut, tsnep_change_duration(gcl, i));\n\n\t \n\tgcl->change_limit = max(extend, cut);\n}\n\nstatic u64 tsnep_gcl_start_after(struct tsnep_gcl *gcl, u64 limit)\n{\n\tu64 start = gcl->base_time;\n\tu64 n;\n\n\tif (start <= limit) {\n\t\tn = div64_u64(limit - start, gcl->cycle_time);\n\t\tstart += (n + 1) * gcl->cycle_time;\n\t}\n\n\treturn start;\n}\n\nstatic u64 tsnep_gcl_start_before(struct tsnep_gcl *gcl, u64 limit)\n{\n\tu64 start = gcl->base_time;\n\tu64 n;\n\n\tn = div64_u64(limit - start, gcl->cycle_time);\n\tstart += n * gcl->cycle_time;\n\tif (start == limit)\n\t\tstart -= gcl->cycle_time;\n\n\treturn start;\n}\n\nstatic u64 tsnep_set_gcl_change(struct tsnep_gcl *gcl, int index, u64 change,\n\t\t\t\tbool insert)\n{\n\t \n\tif (index == 0)\n\t\tindex = gcl->count - 1;\n\telse\n\t\tindex = index - 1;\n\tchange -= gcl->operation[index].interval;\n\n\t \n\tif (insert) {\n\t\tvoid __iomem *addr = gcl->addr +\n\t\t\t\t     sizeof(struct tsnep_gcl_operation) * index;\n\n\t\tgcl->operation[index].properties |= TSNEP_GCL_INSERT;\n\t\tiowrite32(gcl->operation[index].properties, addr);\n\t}\n\n\treturn change;\n}\n\nstatic void tsnep_clean_gcl(struct tsnep_gcl *gcl)\n{\n\tint i;\n\tu32 mask = TSNEP_GCL_LAST | TSNEP_GCL_MASK;\n\tvoid __iomem *addr;\n\n\t \n\tfor (i = 0; i < gcl->count; i++) {\n\t\tif (gcl->operation[i].properties & ~mask) {\n\t\t\taddr = gcl->addr +\n\t\t\t       sizeof(struct tsnep_gcl_operation) * i;\n\n\t\t\tgcl->operation[i].properties &= mask;\n\t\t\tiowrite32(gcl->operation[i].properties, addr);\n\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic u64 tsnep_insert_gcl_operation(struct tsnep_gcl *gcl, int ref,\n\t\t\t\t      u64 change, u32 interval)\n{\n\tu32 properties;\n\n\tproperties = gcl->operation[ref].properties & TSNEP_GCL_MASK;\n\t \n\tproperties |= TSNEP_GCL_CHANGE;\n\n\t \n\ttsnep_write_gcl_operation(gcl, TSNEP_GCL_COUNT - 1, properties,\n\t\t\t\t  interval, false);\n\n\treturn tsnep_set_gcl_change(gcl, ref, change, true);\n}\n\nstatic u64 tsnep_extend_gcl(struct tsnep_gcl *gcl, u64 start, u32 extension)\n{\n\tint ref = gcl->count - 1;\n\tu32 interval = gcl->operation[ref].interval + extension;\n\n\tstart -= gcl->operation[ref].interval;\n\n\treturn tsnep_insert_gcl_operation(gcl, ref, start, interval);\n}\n\nstatic u64 tsnep_cut_gcl(struct tsnep_gcl *gcl, u64 start, u64 cycle_time)\n{\n\tu64 sum = 0;\n\tint i;\n\n\t \n\tfor (i = 0; i < gcl->count; i++) {\n\t\tu64 sum_tmp = sum + gcl->operation[i].interval;\n\t\tu64 interval;\n\n\t\t \n\t\tif (sum_tmp > cycle_time)\n\t\t\tbreak;\n\n\t\t \n\t\tinterval = cycle_time - sum_tmp;\n\t\tif (interval > 0 && interval < TSNEP_GCL_MIN_INTERVAL)\n\t\t\tbreak;\n\n\t\tsum = sum_tmp;\n\t}\n\tif (sum == cycle_time) {\n\t\t \n\t\treturn tsnep_set_gcl_change(gcl, i, start + sum, false);\n\t}\n\treturn tsnep_insert_gcl_operation(gcl, i, start + sum,\n\t\t\t\t\t  cycle_time - sum);\n}\n\nstatic int tsnep_enable_gcl(struct tsnep_adapter *adapter,\n\t\t\t    struct tsnep_gcl *gcl, struct tsnep_gcl *curr)\n{\n\tu64 system_time;\n\tu64 timeout;\n\tu64 limit;\n\n\t \n\ttsnep_get_system_time(adapter, &system_time);\n\ttimeout = system_time + TSNEP_GC_TIMEOUT;\n\n\tif (curr)\n\t\tlimit = timeout + curr->change_limit;\n\telse\n\t\tlimit = timeout;\n\n\tgcl->start_time = tsnep_gcl_start_after(gcl, limit);\n\n\t \n\tif ((gcl->start_time - system_time) >= U32_MAX)\n\t\treturn -EAGAIN;\n\n\tif (curr) {\n\t\t \n\t\tu64 last;\n\t\tu64 change;\n\n\t\tlast = tsnep_gcl_start_before(curr, gcl->start_time);\n\t\tif ((last + curr->cycle_time) == gcl->start_time)\n\t\t\tchange = tsnep_cut_gcl(curr, last,\n\t\t\t\t\t       gcl->start_time - last);\n\t\telse if (((gcl->start_time - last) <=\n\t\t\t  curr->cycle_time_extension) ||\n\t\t\t ((gcl->start_time - last) <= TSNEP_GCL_MIN_INTERVAL))\n\t\t\tchange = tsnep_extend_gcl(curr, last,\n\t\t\t\t\t\t  gcl->start_time - last);\n\t\telse\n\t\t\tchange = tsnep_cut_gcl(curr, last,\n\t\t\t\t\t       gcl->start_time - last);\n\n\t\tWARN_ON(change <= timeout);\n\t\tgcl->change = true;\n\t\tiowrite32(change & 0xFFFFFFFF, adapter->addr + TSNEP_GC_CHANGE);\n\t} else {\n\t\t \n\t\tWARN_ON(gcl->start_time <= timeout);\n\t\tgcl->change = false;\n\t\tiowrite32(gcl->start_time & 0xFFFFFFFF,\n\t\t\t  adapter->addr + TSNEP_GC_TIME);\n\t}\n\n\treturn 0;\n}\n\nstatic int tsnep_taprio(struct tsnep_adapter *adapter,\n\t\t\tstruct tc_taprio_qopt_offload *qopt)\n{\n\tstruct tsnep_gcl *gcl;\n\tstruct tsnep_gcl *curr;\n\tint retval;\n\n\tif (!adapter->gate_control)\n\t\treturn -EOPNOTSUPP;\n\n\tif (qopt->cmd == TAPRIO_CMD_DESTROY) {\n\t\t \n\t\tmutex_lock(&adapter->gate_control_lock);\n\n\t\tif (adapter->gate_control_active) {\n\t\t\tiowrite8(TSNEP_GC_DISABLE, adapter->addr + TSNEP_GC);\n\t\t\tadapter->gate_control_active = false;\n\t\t}\n\n\t\tmutex_unlock(&adapter->gate_control_lock);\n\n\t\treturn 0;\n\t} else if (qopt->cmd != TAPRIO_CMD_REPLACE) {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tretval = tsnep_validate_gcl(qopt);\n\tif (retval)\n\t\treturn retval;\n\n\tmutex_lock(&adapter->gate_control_lock);\n\n\tgcl = &adapter->gcl[adapter->next_gcl];\n\ttsnep_write_gcl(gcl, qopt);\n\n\t \n\tif (adapter->gate_control_active) {\n\t\tif (adapter->next_gcl == 0)\n\t\t\tcurr = &adapter->gcl[1];\n\t\telse\n\t\t\tcurr = &adapter->gcl[0];\n\t} else {\n\t\tcurr = NULL;\n\t}\n\n\tfor (;;) {\n\t\t \n\t\tiowrite8(TSNEP_GC_ENABLE_TIMEOUT, adapter->addr + TSNEP_GC);\n\n\t\tretval = tsnep_enable_gcl(adapter, gcl, curr);\n\t\tif (retval) {\n\t\t\tmutex_unlock(&adapter->gate_control_lock);\n\n\t\t\treturn retval;\n\t\t}\n\n\t\t \n\t\tif (adapter->next_gcl == 0)\n\t\t\tiowrite8(TSNEP_GC_ENABLE_A, adapter->addr + TSNEP_GC);\n\t\telse\n\t\t\tiowrite8(TSNEP_GC_ENABLE_B, adapter->addr + TSNEP_GC);\n\n\t\t \n\t\tif (!(ioread32(adapter->addr + TSNEP_GC) &\n\t\t      TSNEP_GC_TIMEOUT_SIGNAL))\n\t\t\tbreak;\n\n\t\t \n\t\tiowrite8(TSNEP_GC_ENABLE_A, adapter->addr + TSNEP_GC);\n\n\t\tif (curr)\n\t\t\ttsnep_clean_gcl(curr);\n\n\t\t \n\t}\n\n\tadapter->gate_control_active = true;\n\n\tif (adapter->next_gcl == 0)\n\t\tadapter->next_gcl = 1;\n\telse\n\t\tadapter->next_gcl = 0;\n\n\tmutex_unlock(&adapter->gate_control_lock);\n\n\treturn 0;\n}\n\nstatic int tsnep_tc_query_caps(struct tsnep_adapter *adapter,\n\t\t\t       struct tc_query_caps_base *base)\n{\n\tswitch (base->type) {\n\tcase TC_SETUP_QDISC_TAPRIO: {\n\t\tstruct tc_taprio_caps *caps = base->caps;\n\n\t\tif (!adapter->gate_control)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tcaps->gate_mask_per_txq = true;\n\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nint tsnep_tc_setup(struct net_device *netdev, enum tc_setup_type type,\n\t\t   void *type_data)\n{\n\tstruct tsnep_adapter *adapter = netdev_priv(netdev);\n\n\tswitch (type) {\n\tcase TC_QUERY_CAPS:\n\t\treturn tsnep_tc_query_caps(adapter, type_data);\n\tcase TC_SETUP_QDISC_TAPRIO:\n\t\treturn tsnep_taprio(adapter, type_data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nint tsnep_tc_init(struct tsnep_adapter *adapter)\n{\n\tif (!adapter->gate_control)\n\t\treturn 0;\n\n\t \n\tiowrite8(TSNEP_GC_DISABLE, adapter->addr + TSNEP_GC);\n\tiowrite32(TSNEP_GC_OPEN | TSNEP_GC_NEXT_OPEN, adapter->addr + TSNEP_GC);\n\n\tadapter->gcl[0].addr = adapter->addr + TSNEP_GCL_A;\n\tadapter->gcl[1].addr = adapter->addr + TSNEP_GCL_B;\n\n\treturn 0;\n}\n\nvoid tsnep_tc_cleanup(struct tsnep_adapter *adapter)\n{\n\tif (!adapter->gate_control)\n\t\treturn;\n\n\tif (adapter->gate_control_active) {\n\t\tiowrite8(TSNEP_GC_DISABLE, adapter->addr + TSNEP_GC);\n\t\tadapter->gate_control_active = false;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}