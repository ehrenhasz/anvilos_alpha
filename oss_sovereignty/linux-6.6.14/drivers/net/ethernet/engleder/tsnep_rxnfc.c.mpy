{
  "module_name": "tsnep_rxnfc.c",
  "hash_id": "0939b75bf250a17c2c4bd01888fe2b337329a1bf87efdf35b95bf85ba98e4781",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/engleder/tsnep_rxnfc.c",
  "human_readable_source": "\n \n\n#include \"tsnep.h\"\n\n#define ETHER_TYPE_FULL_MASK ((__force __be16)~0)\n\nstatic void tsnep_enable_rule(struct tsnep_adapter *adapter,\n\t\t\t      struct tsnep_rxnfc_rule *rule)\n{\n\tu8 rx_assign;\n\tvoid __iomem *addr;\n\n\trx_assign = TSNEP_RX_ASSIGN_ACTIVE;\n\trx_assign |= (rule->queue_index << TSNEP_RX_ASSIGN_QUEUE_SHIFT) &\n\t\t     TSNEP_RX_ASSIGN_QUEUE_MASK;\n\n\taddr = adapter->addr + TSNEP_RX_ASSIGN_ETHER_TYPE +\n\t       TSNEP_RX_ASSIGN_ETHER_TYPE_OFFSET * rule->location;\n\tiowrite16(rule->filter.ether_type, addr);\n\n\t \n\taddr = adapter->addr + TSNEP_RX_ASSIGN +\n\t       TSNEP_RX_ASSIGN_OFFSET * rule->location;\n\tiowrite8(rx_assign, addr);\n}\n\nstatic void tsnep_disable_rule(struct tsnep_adapter *adapter,\n\t\t\t       struct tsnep_rxnfc_rule *rule)\n{\n\tvoid __iomem *addr;\n\n\taddr = adapter->addr + TSNEP_RX_ASSIGN +\n\t       TSNEP_RX_ASSIGN_OFFSET * rule->location;\n\tiowrite8(0, addr);\n}\n\nstatic struct tsnep_rxnfc_rule *tsnep_get_rule(struct tsnep_adapter *adapter,\n\t\t\t\t\t       int location)\n{\n\tstruct tsnep_rxnfc_rule *rule;\n\n\tlist_for_each_entry(rule, &adapter->rxnfc_rules, list) {\n\t\tif (rule->location == location)\n\t\t\treturn rule;\n\t\tif (rule->location > location)\n\t\t\tbreak;\n\t}\n\n\treturn NULL;\n}\n\nstatic void tsnep_add_rule(struct tsnep_adapter *adapter,\n\t\t\t   struct tsnep_rxnfc_rule *rule)\n{\n\tstruct tsnep_rxnfc_rule *pred, *cur;\n\n\ttsnep_enable_rule(adapter, rule);\n\n\tpred = NULL;\n\tlist_for_each_entry(cur, &adapter->rxnfc_rules, list) {\n\t\tif (cur->location >= rule->location)\n\t\t\tbreak;\n\t\tpred = cur;\n\t}\n\n\tlist_add(&rule->list, pred ? &pred->list : &adapter->rxnfc_rules);\n\tadapter->rxnfc_count++;\n}\n\nstatic void tsnep_delete_rule(struct tsnep_adapter *adapter,\n\t\t\t      struct tsnep_rxnfc_rule *rule)\n{\n\ttsnep_disable_rule(adapter, rule);\n\n\tlist_del(&rule->list);\n\tadapter->rxnfc_count--;\n\n\tkfree(rule);\n}\n\nstatic void tsnep_flush_rules(struct tsnep_adapter *adapter)\n{\n\tstruct tsnep_rxnfc_rule *rule, *tmp;\n\n\tmutex_lock(&adapter->rxnfc_lock);\n\n\tlist_for_each_entry_safe(rule, tmp, &adapter->rxnfc_rules, list)\n\t\ttsnep_delete_rule(adapter, rule);\n\n\tmutex_unlock(&adapter->rxnfc_lock);\n}\n\nint tsnep_rxnfc_get_rule(struct tsnep_adapter *adapter,\n\t\t\t struct ethtool_rxnfc *cmd)\n{\n\tstruct ethtool_rx_flow_spec *fsp = &cmd->fs;\n\tstruct tsnep_rxnfc_rule *rule = NULL;\n\n\tcmd->data = adapter->rxnfc_max;\n\n\tmutex_lock(&adapter->rxnfc_lock);\n\n\trule = tsnep_get_rule(adapter, fsp->location);\n\tif (!rule) {\n\t\tmutex_unlock(&adapter->rxnfc_lock);\n\n\t\treturn -ENOENT;\n\t}\n\n\tfsp->flow_type = ETHER_FLOW;\n\tfsp->ring_cookie = rule->queue_index;\n\n\tif (rule->filter.type == TSNEP_RXNFC_ETHER_TYPE) {\n\t\tfsp->h_u.ether_spec.h_proto = htons(rule->filter.ether_type);\n\t\tfsp->m_u.ether_spec.h_proto = ETHER_TYPE_FULL_MASK;\n\t}\n\n\tmutex_unlock(&adapter->rxnfc_lock);\n\n\treturn 0;\n}\n\nint tsnep_rxnfc_get_all(struct tsnep_adapter *adapter,\n\t\t\tstruct ethtool_rxnfc *cmd,\n\t\t\tu32 *rule_locs)\n{\n\tstruct tsnep_rxnfc_rule *rule;\n\tint count = 0;\n\n\tcmd->data = adapter->rxnfc_max;\n\n\tmutex_lock(&adapter->rxnfc_lock);\n\n\tlist_for_each_entry(rule, &adapter->rxnfc_rules, list) {\n\t\tif (count == cmd->rule_cnt) {\n\t\t\tmutex_unlock(&adapter->rxnfc_lock);\n\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\n\t\trule_locs[count] = rule->location;\n\t\tcount++;\n\t}\n\n\tmutex_unlock(&adapter->rxnfc_lock);\n\n\tcmd->rule_cnt = count;\n\n\treturn 0;\n}\n\nstatic int tsnep_rxnfc_find_location(struct tsnep_adapter *adapter)\n{\n\tstruct tsnep_rxnfc_rule *tmp;\n\tint location = 0;\n\n\tlist_for_each_entry(tmp, &adapter->rxnfc_rules, list) {\n\t\tif (tmp->location == location)\n\t\t\tlocation++;\n\t\telse\n\t\t\treturn location;\n\t}\n\n\tif (location >= adapter->rxnfc_max)\n\t\treturn -ENOSPC;\n\n\treturn location;\n}\n\nstatic void tsnep_rxnfc_init_rule(struct tsnep_rxnfc_rule *rule,\n\t\t\t\t  const struct ethtool_rx_flow_spec *fsp)\n{\n\tINIT_LIST_HEAD(&rule->list);\n\n\trule->queue_index = fsp->ring_cookie;\n\trule->location = fsp->location;\n\n\trule->filter.type = TSNEP_RXNFC_ETHER_TYPE;\n\trule->filter.ether_type = ntohs(fsp->h_u.ether_spec.h_proto);\n}\n\nstatic int tsnep_rxnfc_check_rule(struct tsnep_adapter *adapter,\n\t\t\t\t  struct tsnep_rxnfc_rule *rule)\n{\n\tstruct net_device *dev = adapter->netdev;\n\tstruct tsnep_rxnfc_rule *tmp;\n\n\tlist_for_each_entry(tmp, &adapter->rxnfc_rules, list) {\n\t\tif (!memcmp(&rule->filter, &tmp->filter, sizeof(rule->filter)) &&\n\t\t    tmp->location != rule->location) {\n\t\t\tnetdev_dbg(dev, \"rule already exists\\n\");\n\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint tsnep_rxnfc_add_rule(struct tsnep_adapter *adapter,\n\t\t\t struct ethtool_rxnfc *cmd)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct ethtool_rx_flow_spec *fsp =\n\t\t(struct ethtool_rx_flow_spec *)&cmd->fs;\n\tstruct tsnep_rxnfc_rule *rule, *old_rule;\n\tint retval;\n\n\t \n\tif (fsp->flow_type != ETHER_FLOW ||\n\t    !is_zero_ether_addr(fsp->m_u.ether_spec.h_dest) ||\n\t    !is_zero_ether_addr(fsp->m_u.ether_spec.h_source) ||\n\t    fsp->m_u.ether_spec.h_proto != ETHER_TYPE_FULL_MASK) {\n\t\tnetdev_dbg(netdev, \"only ethernet protocol is supported\\n\");\n\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (fsp->ring_cookie >\n\t    (TSNEP_RX_ASSIGN_QUEUE_MASK >> TSNEP_RX_ASSIGN_QUEUE_SHIFT)) {\n\t\tnetdev_dbg(netdev, \"invalid action\\n\");\n\n\t\treturn -EINVAL;\n\t}\n\n\tif (fsp->location != RX_CLS_LOC_ANY &&\n\t    fsp->location >= adapter->rxnfc_max) {\n\t\tnetdev_dbg(netdev, \"invalid location\\n\");\n\n\t\treturn -EINVAL;\n\t}\n\n\trule = kzalloc(sizeof(*rule), GFP_KERNEL);\n\tif (!rule)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&adapter->rxnfc_lock);\n\n\tif (fsp->location == RX_CLS_LOC_ANY) {\n\t\tretval = tsnep_rxnfc_find_location(adapter);\n\t\tif (retval < 0)\n\t\t\tgoto failed;\n\t\tfsp->location = retval;\n\t}\n\n\ttsnep_rxnfc_init_rule(rule, fsp);\n\n\tretval = tsnep_rxnfc_check_rule(adapter, rule);\n\tif (retval)\n\t\tgoto failed;\n\n\told_rule = tsnep_get_rule(adapter, fsp->location);\n\tif (old_rule)\n\t\ttsnep_delete_rule(adapter, old_rule);\n\n\ttsnep_add_rule(adapter, rule);\n\n\tmutex_unlock(&adapter->rxnfc_lock);\n\n\treturn 0;\n\nfailed:\n\tmutex_unlock(&adapter->rxnfc_lock);\n\tkfree(rule);\n\treturn retval;\n}\n\nint tsnep_rxnfc_del_rule(struct tsnep_adapter *adapter,\n\t\t\t struct ethtool_rxnfc *cmd)\n{\n\tstruct ethtool_rx_flow_spec *fsp =\n\t\t(struct ethtool_rx_flow_spec *)&cmd->fs;\n\tstruct tsnep_rxnfc_rule *rule;\n\n\tmutex_lock(&adapter->rxnfc_lock);\n\n\trule = tsnep_get_rule(adapter, fsp->location);\n\tif (!rule) {\n\t\tmutex_unlock(&adapter->rxnfc_lock);\n\n\t\treturn -ENOENT;\n\t}\n\n\ttsnep_delete_rule(adapter, rule);\n\n\tmutex_unlock(&adapter->rxnfc_lock);\n\n\treturn 0;\n}\n\nint tsnep_rxnfc_init(struct tsnep_adapter *adapter)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < adapter->rxnfc_max;\n\t     i += sizeof(u32) / TSNEP_RX_ASSIGN_OFFSET)\n\t\tiowrite32(0, adapter->addr + TSNEP_RX_ASSIGN + i);\n\n\treturn 0;\n}\n\nvoid tsnep_rxnfc_cleanup(struct tsnep_adapter *adapter)\n{\n\ttsnep_flush_rules(adapter);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}