{
  "module_name": "tsnep.h",
  "hash_id": "a129b6783ea71fb4252d230dc75e60348e5550dc1b0d0be504e93862f3c6d276",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/engleder/tsnep.h",
  "human_readable_source": " \n \n\n#ifndef _TSNEP_H\n#define _TSNEP_H\n\n#include \"tsnep_hw.h\"\n\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/etherdevice.h>\n#include <linux/phy.h>\n#include <linux/ethtool.h>\n#include <linux/net_tstamp.h>\n#include <linux/ptp_clock_kernel.h>\n#include <linux/miscdevice.h>\n#include <net/xdp.h>\n\n#define TSNEP \"tsnep\"\n\n#define TSNEP_RING_SIZE 256\n#define TSNEP_RING_MASK (TSNEP_RING_SIZE - 1)\n#define TSNEP_RING_RX_REFILL 16\n#define TSNEP_RING_RX_REUSE (TSNEP_RING_SIZE - TSNEP_RING_SIZE / 4)\n#define TSNEP_RING_ENTRIES_PER_PAGE (PAGE_SIZE / TSNEP_DESC_SIZE)\n#define TSNEP_RING_PAGE_COUNT (TSNEP_RING_SIZE / TSNEP_RING_ENTRIES_PER_PAGE)\n\nstruct tsnep_gcl {\n\tvoid __iomem *addr;\n\n\tu64 base_time;\n\tu64 cycle_time;\n\tu64 cycle_time_extension;\n\n\tstruct tsnep_gcl_operation operation[TSNEP_GCL_COUNT];\n\tint count;\n\n\tu64 change_limit;\n\n\tu64 start_time;\n\tbool change;\n};\n\nenum tsnep_rxnfc_filter_type {\n\tTSNEP_RXNFC_ETHER_TYPE,\n};\n\nstruct tsnep_rxnfc_filter {\n\tenum tsnep_rxnfc_filter_type type;\n\tunion {\n\t\tu16 ether_type;\n\t};\n};\n\nstruct tsnep_rxnfc_rule {\n\tstruct list_head list;\n\tstruct tsnep_rxnfc_filter filter;\n\tint queue_index;\n\tint location;\n};\n\nstruct tsnep_tx_entry {\n\tstruct tsnep_tx_desc *desc;\n\tstruct tsnep_tx_desc_wb *desc_wb;\n\tdma_addr_t desc_dma;\n\tbool owner_user_flag;\n\n\tu32 properties;\n\n\tu32 type;\n\tunion {\n\t\tstruct sk_buff *skb;\n\t\tstruct xdp_frame *xdpf;\n\t\tbool zc;\n\t};\n\tsize_t len;\n\tDEFINE_DMA_UNMAP_ADDR(dma);\n};\n\nstruct tsnep_tx {\n\tstruct tsnep_adapter *adapter;\n\tvoid __iomem *addr;\n\tint queue_index;\n\n\tvoid *page[TSNEP_RING_PAGE_COUNT];\n\tdma_addr_t page_dma[TSNEP_RING_PAGE_COUNT];\n\n\tstruct tsnep_tx_entry entry[TSNEP_RING_SIZE];\n\tint write;\n\tint read;\n\tu32 owner_counter;\n\tint increment_owner_counter;\n\tstruct xsk_buff_pool *xsk_pool;\n\n\tu32 packets;\n\tu32 bytes;\n\tu32 dropped;\n};\n\nstruct tsnep_rx_entry {\n\tstruct tsnep_rx_desc *desc;\n\tstruct tsnep_rx_desc_wb *desc_wb;\n\tdma_addr_t desc_dma;\n\n\tu32 properties;\n\n\tunion {\n\t\tstruct page *page;\n\t\tstruct xdp_buff *xdp;\n\t};\n\tsize_t len;\n\tdma_addr_t dma;\n};\n\nstruct tsnep_rx {\n\tstruct tsnep_adapter *adapter;\n\tvoid __iomem *addr;\n\tint queue_index;\n\tint tx_queue_index;\n\n\tvoid *page[TSNEP_RING_PAGE_COUNT];\n\tdma_addr_t page_dma[TSNEP_RING_PAGE_COUNT];\n\n\tstruct tsnep_rx_entry entry[TSNEP_RING_SIZE];\n\tint write;\n\tint read;\n\tu32 owner_counter;\n\tint increment_owner_counter;\n\tstruct page_pool *page_pool;\n\tstruct page **page_buffer;\n\tstruct xsk_buff_pool *xsk_pool;\n\tstruct xdp_buff **xdp_batch;\n\n\tu32 packets;\n\tu32 bytes;\n\tu32 dropped;\n\tu32 multicast;\n\tu32 alloc_failed;\n\n\tstruct xdp_rxq_info xdp_rxq;\n\tstruct xdp_rxq_info xdp_rxq_zc;\n};\n\nstruct tsnep_queue {\n\tstruct tsnep_adapter *adapter;\n\tchar name[IFNAMSIZ + 16];\n\n\tstruct tsnep_tx *tx;\n\tstruct tsnep_rx *rx;\n\n\tstruct napi_struct napi;\n\n\tint irq;\n\tu32 irq_mask;\n\tvoid __iomem *irq_delay_addr;\n\tu8 irq_delay;\n};\n\nstruct tsnep_adapter {\n\tstruct net_device *netdev;\n\tu8 mac_address[ETH_ALEN];\n\tstruct mii_bus *mdiobus;\n\tbool suppress_preamble;\n\tphy_interface_t phy_mode;\n\tstruct phy_device *phydev;\n\tint msg_enable;\n\n\tstruct platform_device *pdev;\n\tstruct device *dmadev;\n\tvoid __iomem *addr;\n\n\tbool gate_control;\n\t \n\tstruct mutex gate_control_lock;\n\tbool gate_control_active;\n\tstruct tsnep_gcl gcl[2];\n\tint next_gcl;\n\n\tstruct hwtstamp_config hwtstamp_config;\n\tstruct ptp_clock *ptp_clock;\n\tstruct ptp_clock_info ptp_clock_info;\n\t \n\tspinlock_t ptp_lock;\n\n\t \n\tstruct mutex rxnfc_lock;\n\tstruct list_head rxnfc_rules;\n\tint rxnfc_count;\n\tint rxnfc_max;\n\n\tstruct bpf_prog *xdp_prog;\n\n\tint num_tx_queues;\n\tstruct tsnep_tx tx[TSNEP_MAX_QUEUES];\n\tint num_rx_queues;\n\tstruct tsnep_rx rx[TSNEP_MAX_QUEUES];\n\n\tint num_queues;\n\tstruct tsnep_queue queue[TSNEP_MAX_QUEUES];\n};\n\nextern const struct ethtool_ops tsnep_ethtool_ops;\n\nint tsnep_ptp_init(struct tsnep_adapter *adapter);\nvoid tsnep_ptp_cleanup(struct tsnep_adapter *adapter);\nint tsnep_ptp_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd);\n\nint tsnep_tc_init(struct tsnep_adapter *adapter);\nvoid tsnep_tc_cleanup(struct tsnep_adapter *adapter);\nint tsnep_tc_setup(struct net_device *netdev, enum tc_setup_type type,\n\t\t   void *type_data);\n\nint tsnep_rxnfc_init(struct tsnep_adapter *adapter);\nvoid tsnep_rxnfc_cleanup(struct tsnep_adapter *adapter);\nint tsnep_rxnfc_get_rule(struct tsnep_adapter *adapter,\n\t\t\t struct ethtool_rxnfc *cmd);\nint tsnep_rxnfc_get_all(struct tsnep_adapter *adapter,\n\t\t\tstruct ethtool_rxnfc *cmd,\n\t\t\tu32 *rule_locs);\nint tsnep_rxnfc_add_rule(struct tsnep_adapter *adapter,\n\t\t\t struct ethtool_rxnfc *cmd);\nint tsnep_rxnfc_del_rule(struct tsnep_adapter *adapter,\n\t\t\t struct ethtool_rxnfc *cmd);\n\nint tsnep_xdp_setup_prog(struct tsnep_adapter *adapter, struct bpf_prog *prog,\n\t\t\t struct netlink_ext_ack *extack);\nint tsnep_xdp_setup_pool(struct tsnep_adapter *adapter,\n\t\t\t struct xsk_buff_pool *pool, u16 queue_id);\n\n#if IS_ENABLED(CONFIG_TSNEP_SELFTESTS)\nint tsnep_ethtool_get_test_count(void);\nvoid tsnep_ethtool_get_test_strings(u8 *data);\nvoid tsnep_ethtool_self_test(struct net_device *netdev,\n\t\t\t     struct ethtool_test *eth_test, u64 *data);\n#else\nstatic inline int tsnep_ethtool_get_test_count(void)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline void tsnep_ethtool_get_test_strings(u8 *data)\n{\n\t \n}\n\nstatic inline void tsnep_ethtool_self_test(struct net_device *dev,\n\t\t\t\t\t   struct ethtool_test *eth_test,\n\t\t\t\t\t   u64 *data)\n{\n\t \n}\n#endif  \n\nvoid tsnep_get_system_time(struct tsnep_adapter *adapter, u64 *time);\nint tsnep_set_irq_coalesce(struct tsnep_queue *queue, u32 usecs);\nu32 tsnep_get_irq_coalesce(struct tsnep_queue *queue);\nint tsnep_enable_xsk(struct tsnep_queue *queue, struct xsk_buff_pool *pool);\nvoid tsnep_disable_xsk(struct tsnep_queue *queue);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}