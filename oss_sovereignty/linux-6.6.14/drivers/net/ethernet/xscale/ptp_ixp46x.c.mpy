{
  "module_name": "ptp_ixp46x.c",
  "hash_id": "c8a8ab5294bf5d463665ac01922f6ae8032a2ed564e0ab6f026c65b8fdcc7611",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/xscale/ptp_ixp46x.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/ptp_clock_kernel.h>\n#include <linux/platform_device.h>\n#include <linux/soc/ixp4xx/cpu.h>\n\n#include \"ixp46x_ts.h\"\n\n#define DRIVER\t\t\"ptp_ixp46x\"\n#define N_EXT_TS\t2\n\nstruct ixp_clock {\n\tstruct ixp46x_ts_regs *regs;\n\tstruct ptp_clock *ptp_clock;\n\tstruct ptp_clock_info caps;\n\tint exts0_enabled;\n\tint exts1_enabled;\n\tint slave_irq;\n\tint master_irq;\n};\n\nstatic DEFINE_SPINLOCK(register_lock);\n\n \n\nstatic u64 ixp_systime_read(struct ixp46x_ts_regs *regs)\n{\n\tu64 ns;\n\tu32 lo, hi;\n\n\tlo = __raw_readl(&regs->systime_lo);\n\thi = __raw_readl(&regs->systime_hi);\n\n\tns = ((u64) hi) << 32;\n\tns |= lo;\n\tns <<= TICKS_NS_SHIFT;\n\n\treturn ns;\n}\n\nstatic void ixp_systime_write(struct ixp46x_ts_regs *regs, u64 ns)\n{\n\tu32 hi, lo;\n\n\tns >>= TICKS_NS_SHIFT;\n\thi = ns >> 32;\n\tlo = ns & 0xffffffff;\n\n\t__raw_writel(lo, &regs->systime_lo);\n\t__raw_writel(hi, &regs->systime_hi);\n}\n\n \n\nstatic irqreturn_t isr(int irq, void *priv)\n{\n\tstruct ixp_clock *ixp_clock = priv;\n\tstruct ixp46x_ts_regs *regs = ixp_clock->regs;\n\tstruct ptp_clock_event event;\n\tu32 ack = 0, lo, hi, val;\n\n\tval = __raw_readl(&regs->event);\n\n\tif (val & TSER_SNS) {\n\t\tack |= TSER_SNS;\n\t\tif (ixp_clock->exts0_enabled) {\n\t\t\thi = __raw_readl(&regs->asms_hi);\n\t\t\tlo = __raw_readl(&regs->asms_lo);\n\t\t\tevent.type = PTP_CLOCK_EXTTS;\n\t\t\tevent.index = 0;\n\t\t\tevent.timestamp = ((u64) hi) << 32;\n\t\t\tevent.timestamp |= lo;\n\t\t\tevent.timestamp <<= TICKS_NS_SHIFT;\n\t\t\tptp_clock_event(ixp_clock->ptp_clock, &event);\n\t\t}\n\t}\n\n\tif (val & TSER_SNM) {\n\t\tack |= TSER_SNM;\n\t\tif (ixp_clock->exts1_enabled) {\n\t\t\thi = __raw_readl(&regs->amms_hi);\n\t\t\tlo = __raw_readl(&regs->amms_lo);\n\t\t\tevent.type = PTP_CLOCK_EXTTS;\n\t\t\tevent.index = 1;\n\t\t\tevent.timestamp = ((u64) hi) << 32;\n\t\t\tevent.timestamp |= lo;\n\t\t\tevent.timestamp <<= TICKS_NS_SHIFT;\n\t\t\tptp_clock_event(ixp_clock->ptp_clock, &event);\n\t\t}\n\t}\n\n\tif (val & TTIPEND)\n\t\tack |= TTIPEND;  \n\n\tif (ack) {\n\t\t__raw_writel(ack, &regs->event);\n\t\treturn IRQ_HANDLED;\n\t} else\n\t\treturn IRQ_NONE;\n}\n\n \n\nstatic int ptp_ixp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tu32 addend;\n\tstruct ixp_clock *ixp_clock = container_of(ptp, struct ixp_clock, caps);\n\tstruct ixp46x_ts_regs *regs = ixp_clock->regs;\n\n\taddend = adjust_by_scaled_ppm(DEFAULT_ADDEND, scaled_ppm);\n\n\t__raw_writel(addend, &regs->addend);\n\n\treturn 0;\n}\n\nstatic int ptp_ixp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\ts64 now;\n\tunsigned long flags;\n\tstruct ixp_clock *ixp_clock = container_of(ptp, struct ixp_clock, caps);\n\tstruct ixp46x_ts_regs *regs = ixp_clock->regs;\n\n\tspin_lock_irqsave(&register_lock, flags);\n\n\tnow = ixp_systime_read(regs);\n\tnow += delta;\n\tixp_systime_write(regs, now);\n\n\tspin_unlock_irqrestore(&register_lock, flags);\n\n\treturn 0;\n}\n\nstatic int ptp_ixp_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\n{\n\tu64 ns;\n\tunsigned long flags;\n\tstruct ixp_clock *ixp_clock = container_of(ptp, struct ixp_clock, caps);\n\tstruct ixp46x_ts_regs *regs = ixp_clock->regs;\n\n\tspin_lock_irqsave(&register_lock, flags);\n\n\tns = ixp_systime_read(regs);\n\n\tspin_unlock_irqrestore(&register_lock, flags);\n\n\t*ts = ns_to_timespec64(ns);\n\treturn 0;\n}\n\nstatic int ptp_ixp_settime(struct ptp_clock_info *ptp,\n\t\t\t   const struct timespec64 *ts)\n{\n\tu64 ns;\n\tunsigned long flags;\n\tstruct ixp_clock *ixp_clock = container_of(ptp, struct ixp_clock, caps);\n\tstruct ixp46x_ts_regs *regs = ixp_clock->regs;\n\n\tns = timespec64_to_ns(ts);\n\n\tspin_lock_irqsave(&register_lock, flags);\n\n\tixp_systime_write(regs, ns);\n\n\tspin_unlock_irqrestore(&register_lock, flags);\n\n\treturn 0;\n}\n\nstatic int ptp_ixp_enable(struct ptp_clock_info *ptp,\n\t\t\t  struct ptp_clock_request *rq, int on)\n{\n\tstruct ixp_clock *ixp_clock = container_of(ptp, struct ixp_clock, caps);\n\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_EXTTS:\n\t\tswitch (rq->extts.index) {\n\t\tcase 0:\n\t\t\tixp_clock->exts0_enabled = on ? 1 : 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tixp_clock->exts1_enabled = on ? 1 : 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct ptp_clock_info ptp_ixp_caps = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"IXP46X timer\",\n\t.max_adj\t= 66666655,\n\t.n_ext_ts\t= N_EXT_TS,\n\t.n_pins\t\t= 0,\n\t.pps\t\t= 0,\n\t.adjfine\t= ptp_ixp_adjfine,\n\t.adjtime\t= ptp_ixp_adjtime,\n\t.gettime64\t= ptp_ixp_gettime,\n\t.settime64\t= ptp_ixp_settime,\n\t.enable\t\t= ptp_ixp_enable,\n};\n\n \n\nstatic struct ixp_clock ixp_clock;\n\nint ixp46x_ptp_find(struct ixp46x_ts_regs *__iomem *regs, int *phc_index)\n{\n\t*regs = ixp_clock.regs;\n\t*phc_index = ptp_clock_index(ixp_clock.ptp_clock);\n\n\tif (!ixp_clock.ptp_clock)\n\t\treturn -EPROBE_DEFER;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ixp46x_ptp_find);\n\n \nstatic void ptp_ixp_unregister_action(void *d)\n{\n\tstruct ptp_clock *ptp_clock = d;\n\n\tptp_clock_unregister(ptp_clock);\n\tixp_clock.ptp_clock = NULL;\n}\n\nstatic int ptp_ixp_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tixp_clock.regs = devm_platform_ioremap_resource(pdev, 0);\n\tixp_clock.master_irq = platform_get_irq(pdev, 0);\n\tixp_clock.slave_irq = platform_get_irq(pdev, 1);\n\tif (IS_ERR(ixp_clock.regs) ||\n\t    ixp_clock.master_irq < 0 || ixp_clock.slave_irq < 0)\n\t\treturn -ENXIO;\n\n\tixp_clock.caps = ptp_ixp_caps;\n\n\tixp_clock.ptp_clock = ptp_clock_register(&ixp_clock.caps, NULL);\n\n\tif (IS_ERR(ixp_clock.ptp_clock))\n\t\treturn PTR_ERR(ixp_clock.ptp_clock);\n\n\tret = devm_add_action_or_reset(dev, ptp_ixp_unregister_action,\n\t\t\t\t       ixp_clock.ptp_clock);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to install clock removal handler\\n\");\n\t\treturn ret;\n\t}\n\n\t__raw_writel(DEFAULT_ADDEND, &ixp_clock.regs->addend);\n\t__raw_writel(1, &ixp_clock.regs->trgt_lo);\n\t__raw_writel(0, &ixp_clock.regs->trgt_hi);\n\t__raw_writel(TTIPEND, &ixp_clock.regs->event);\n\n\tret = devm_request_irq(dev, ixp_clock.master_irq, isr,\n\t\t\t       0, DRIVER, &ixp_clock);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"request_irq failed for irq %d\\n\",\n\t\t\t\t     ixp_clock.master_irq);\n\n\tret = devm_request_irq(dev, ixp_clock.slave_irq, isr,\n\t\t\t       0, DRIVER, &ixp_clock);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"request_irq failed for irq %d\\n\",\n\t\t\t\t     ixp_clock.slave_irq);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ptp_ixp_match[] = {\n\t{\n\t\t.compatible = \"intel,ixp46x-ptp-timer\",\n\t},\n\t{ },\n};\n\nstatic struct platform_driver ptp_ixp_driver = {\n\t.driver = {\n\t\t.name = \"ptp-ixp46x\",\n\t\t.of_match_table = ptp_ixp_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe = ptp_ixp_probe,\n};\nmodule_platform_driver(ptp_ixp_driver);\n\nMODULE_AUTHOR(\"Richard Cochran <richardcochran@gmail.com>\");\nMODULE_DESCRIPTION(\"PTP clock using the IXP46X timer\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}