{
  "module_name": "vnic_rq.h",
  "hash_id": "008904bfa36c43cac78bd0b1baad16e16728284bc746e29b29b2f1fed2fa96e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cisco/enic/vnic_rq.h",
  "human_readable_source": " \n \n\n#ifndef _VNIC_RQ_H_\n#define _VNIC_RQ_H_\n\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n\n#include \"vnic_dev.h\"\n#include \"vnic_cq.h\"\n\n \nstruct vnic_rq_ctrl {\n\tu64 ring_base;\t\t\t \n\tu32 ring_size;\t\t\t \n\tu32 pad0;\n\tu32 posted_index;\t\t \n\tu32 pad1;\n\tu32 cq_index;\t\t\t \n\tu32 pad2;\n\tu32 enable;\t\t\t \n\tu32 pad3;\n\tu32 running;\t\t\t \n\tu32 pad4;\n\tu32 fetch_index;\t\t \n\tu32 pad5;\n\tu32 error_interrupt_enable;\t \n\tu32 pad6;\n\tu32 error_interrupt_offset;\t \n\tu32 pad7;\n\tu32 error_status;\t\t \n\tu32 pad8;\n\tu32 dropped_packet_count;\t \n\tu32 pad9;\n\tu32 dropped_packet_count_rc;\t \n\tu32 pad10;\n};\n\n \n#define VNIC_RQ_BUF_MIN_BLK_ENTRIES 32\n#define VNIC_RQ_BUF_DFLT_BLK_ENTRIES 64\n#define VNIC_RQ_BUF_BLK_ENTRIES(entries) \\\n\t((unsigned int)((entries < VNIC_RQ_BUF_DFLT_BLK_ENTRIES) ? \\\n\tVNIC_RQ_BUF_MIN_BLK_ENTRIES : VNIC_RQ_BUF_DFLT_BLK_ENTRIES))\n#define VNIC_RQ_BUF_BLK_SZ(entries) \\\n\t(VNIC_RQ_BUF_BLK_ENTRIES(entries) * sizeof(struct vnic_rq_buf))\n#define VNIC_RQ_BUF_BLKS_NEEDED(entries) \\\n\tDIV_ROUND_UP(entries, VNIC_RQ_BUF_BLK_ENTRIES(entries))\n#define VNIC_RQ_BUF_BLKS_MAX VNIC_RQ_BUF_BLKS_NEEDED(4096)\n\nstruct vnic_rq_buf {\n\tstruct vnic_rq_buf *next;\n\tdma_addr_t dma_addr;\n\tvoid *os_buf;\n\tunsigned int os_buf_index;\n\tunsigned int len;\n\tunsigned int index;\n\tvoid *desc;\n\tuint64_t wr_id;\n};\n\nenum enic_poll_state {\n\tENIC_POLL_STATE_IDLE,\n\tENIC_POLL_STATE_NAPI,\n\tENIC_POLL_STATE_POLL\n};\n\nstruct vnic_rq {\n\tunsigned int index;\n\tstruct vnic_dev *vdev;\n\tstruct vnic_rq_ctrl __iomem *ctrl;               \n\tstruct vnic_dev_ring ring;\n\tstruct vnic_rq_buf *bufs[VNIC_RQ_BUF_BLKS_MAX];\n\tstruct vnic_rq_buf *to_use;\n\tstruct vnic_rq_buf *to_clean;\n\tvoid *os_buf_head;\n\tunsigned int pkts_outstanding;\n};\n\nstatic inline unsigned int vnic_rq_desc_avail(struct vnic_rq *rq)\n{\n\t \n\treturn rq->ring.desc_avail;\n}\n\nstatic inline unsigned int vnic_rq_desc_used(struct vnic_rq *rq)\n{\n\t \n\treturn rq->ring.desc_count - rq->ring.desc_avail - 1;\n}\n\nstatic inline void *vnic_rq_next_desc(struct vnic_rq *rq)\n{\n\treturn rq->to_use->desc;\n}\n\nstatic inline unsigned int vnic_rq_next_index(struct vnic_rq *rq)\n{\n\treturn rq->to_use->index;\n}\n\nstatic inline void vnic_rq_post(struct vnic_rq *rq,\n\tvoid *os_buf, unsigned int os_buf_index,\n\tdma_addr_t dma_addr, unsigned int len,\n\tuint64_t wrid)\n{\n\tstruct vnic_rq_buf *buf = rq->to_use;\n\n\tbuf->os_buf = os_buf;\n\tbuf->os_buf_index = os_buf_index;\n\tbuf->dma_addr = dma_addr;\n\tbuf->len = len;\n\tbuf->wr_id = wrid;\n\n\tbuf = buf->next;\n\trq->to_use = buf;\n\trq->ring.desc_avail--;\n\n\t \n\n#ifndef VNIC_RQ_RETURN_RATE\n#define VNIC_RQ_RETURN_RATE\t\t0xf\t \n#endif\n\n\tif ((buf->index & VNIC_RQ_RETURN_RATE) == 0) {\n\t\t \n\t\twmb();\n\t\tiowrite32(buf->index, &rq->ctrl->posted_index);\n\t}\n}\n\nstatic inline void vnic_rq_return_descs(struct vnic_rq *rq, unsigned int count)\n{\n\trq->ring.desc_avail += count;\n}\n\nenum desc_return_options {\n\tVNIC_RQ_RETURN_DESC,\n\tVNIC_RQ_DEFER_RETURN_DESC,\n};\n\nstatic inline void vnic_rq_service(struct vnic_rq *rq,\n\tstruct cq_desc *cq_desc, u16 completed_index,\n\tint desc_return, void (*buf_service)(struct vnic_rq *rq,\n\tstruct cq_desc *cq_desc, struct vnic_rq_buf *buf,\n\tint skipped, void *opaque), void *opaque)\n{\n\tstruct vnic_rq_buf *buf;\n\tint skipped;\n\n\tbuf = rq->to_clean;\n\twhile (1) {\n\n\t\tskipped = (buf->index != completed_index);\n\n\t\t(*buf_service)(rq, cq_desc, buf, skipped, opaque);\n\n\t\tif (desc_return == VNIC_RQ_RETURN_DESC)\n\t\t\trq->ring.desc_avail++;\n\n\t\trq->to_clean = buf->next;\n\n\t\tif (!skipped)\n\t\t\tbreak;\n\n\t\tbuf = rq->to_clean;\n\t}\n}\n\nstatic inline int vnic_rq_fill(struct vnic_rq *rq,\n\tint (*buf_fill)(struct vnic_rq *rq))\n{\n\tint err;\n\n\twhile (vnic_rq_desc_avail(rq) > 0) {\n\n\t\terr = (*buf_fill)(rq);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nvoid vnic_rq_free(struct vnic_rq *rq);\nint vnic_rq_alloc(struct vnic_dev *vdev, struct vnic_rq *rq, unsigned int index,\n\tunsigned int desc_count, unsigned int desc_size);\nvoid vnic_rq_init(struct vnic_rq *rq, unsigned int cq_index,\n\tunsigned int error_interrupt_enable,\n\tunsigned int error_interrupt_offset);\nunsigned int vnic_rq_error_status(struct vnic_rq *rq);\nvoid vnic_rq_enable(struct vnic_rq *rq);\nint vnic_rq_disable(struct vnic_rq *rq);\nvoid vnic_rq_clean(struct vnic_rq *rq,\n\tvoid (*buf_clean)(struct vnic_rq *rq, struct vnic_rq_buf *buf));\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}