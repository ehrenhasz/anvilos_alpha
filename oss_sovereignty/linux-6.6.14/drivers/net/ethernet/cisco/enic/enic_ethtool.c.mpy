{
  "module_name": "enic_ethtool.c",
  "hash_id": "a6bdecb666b6817b1ec29fa0496efc8bebb5106ee2c7027dbaafe69b3d89fdbf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cisco/enic/enic_ethtool.c",
  "human_readable_source": "\n\n\n#include <linux/netdevice.h>\n#include <linux/ethtool.h>\n#include <linux/net_tstamp.h>\n\n#include \"enic_res.h\"\n#include \"enic.h\"\n#include \"enic_dev.h\"\n#include \"enic_clsf.h\"\n#include \"vnic_rss.h\"\n#include \"vnic_stats.h\"\n\nstruct enic_stat {\n\tchar name[ETH_GSTRING_LEN];\n\tunsigned int index;\n};\n\n#define ENIC_TX_STAT(stat) { \\\n\t.name = #stat, \\\n\t.index = offsetof(struct vnic_tx_stats, stat) / sizeof(u64) \\\n}\n\n#define ENIC_RX_STAT(stat) { \\\n\t.name = #stat, \\\n\t.index = offsetof(struct vnic_rx_stats, stat) / sizeof(u64) \\\n}\n\n#define ENIC_GEN_STAT(stat) { \\\n\t.name = #stat, \\\n\t.index = offsetof(struct vnic_gen_stats, stat) / sizeof(u64)\\\n}\n\nstatic const struct enic_stat enic_tx_stats[] = {\n\tENIC_TX_STAT(tx_frames_ok),\n\tENIC_TX_STAT(tx_unicast_frames_ok),\n\tENIC_TX_STAT(tx_multicast_frames_ok),\n\tENIC_TX_STAT(tx_broadcast_frames_ok),\n\tENIC_TX_STAT(tx_bytes_ok),\n\tENIC_TX_STAT(tx_unicast_bytes_ok),\n\tENIC_TX_STAT(tx_multicast_bytes_ok),\n\tENIC_TX_STAT(tx_broadcast_bytes_ok),\n\tENIC_TX_STAT(tx_drops),\n\tENIC_TX_STAT(tx_errors),\n\tENIC_TX_STAT(tx_tso),\n};\n\nstatic const struct enic_stat enic_rx_stats[] = {\n\tENIC_RX_STAT(rx_frames_ok),\n\tENIC_RX_STAT(rx_frames_total),\n\tENIC_RX_STAT(rx_unicast_frames_ok),\n\tENIC_RX_STAT(rx_multicast_frames_ok),\n\tENIC_RX_STAT(rx_broadcast_frames_ok),\n\tENIC_RX_STAT(rx_bytes_ok),\n\tENIC_RX_STAT(rx_unicast_bytes_ok),\n\tENIC_RX_STAT(rx_multicast_bytes_ok),\n\tENIC_RX_STAT(rx_broadcast_bytes_ok),\n\tENIC_RX_STAT(rx_drop),\n\tENIC_RX_STAT(rx_no_bufs),\n\tENIC_RX_STAT(rx_errors),\n\tENIC_RX_STAT(rx_rss),\n\tENIC_RX_STAT(rx_crc_errors),\n\tENIC_RX_STAT(rx_frames_64),\n\tENIC_RX_STAT(rx_frames_127),\n\tENIC_RX_STAT(rx_frames_255),\n\tENIC_RX_STAT(rx_frames_511),\n\tENIC_RX_STAT(rx_frames_1023),\n\tENIC_RX_STAT(rx_frames_1518),\n\tENIC_RX_STAT(rx_frames_to_max),\n};\n\nstatic const struct enic_stat enic_gen_stats[] = {\n\tENIC_GEN_STAT(dma_map_error),\n};\n\nstatic const unsigned int enic_n_tx_stats = ARRAY_SIZE(enic_tx_stats);\nstatic const unsigned int enic_n_rx_stats = ARRAY_SIZE(enic_rx_stats);\nstatic const unsigned int enic_n_gen_stats = ARRAY_SIZE(enic_gen_stats);\n\nstatic void enic_intr_coal_set_rx(struct enic *enic, u32 timer)\n{\n\tint i;\n\tint intr;\n\n\tfor (i = 0; i < enic->rq_count; i++) {\n\t\tintr = enic_msix_rq_intr(enic, i);\n\t\tvnic_intr_coalescing_timer_set(&enic->intr[intr], timer);\n\t}\n}\n\nstatic int enic_get_ksettings(struct net_device *netdev,\n\t\t\t      struct ethtool_link_ksettings *ecmd)\n{\n\tstruct enic *enic = netdev_priv(netdev);\n\tstruct ethtool_link_settings *base = &ecmd->base;\n\n\tethtool_link_ksettings_add_link_mode(ecmd, supported,\n\t\t\t\t\t     10000baseT_Full);\n\tethtool_link_ksettings_add_link_mode(ecmd, supported, FIBRE);\n\tethtool_link_ksettings_add_link_mode(ecmd, advertising,\n\t\t\t\t\t     10000baseT_Full);\n\tethtool_link_ksettings_add_link_mode(ecmd, advertising, FIBRE);\n\tbase->port = PORT_FIBRE;\n\n\tif (netif_carrier_ok(netdev)) {\n\t\tbase->speed = vnic_dev_port_speed(enic->vdev);\n\t\tbase->duplex = DUPLEX_FULL;\n\t} else {\n\t\tbase->speed = SPEED_UNKNOWN;\n\t\tbase->duplex = DUPLEX_UNKNOWN;\n\t}\n\n\tbase->autoneg = AUTONEG_DISABLE;\n\n\treturn 0;\n}\n\nstatic void enic_get_drvinfo(struct net_device *netdev,\n\tstruct ethtool_drvinfo *drvinfo)\n{\n\tstruct enic *enic = netdev_priv(netdev);\n\tstruct vnic_devcmd_fw_info *fw_info;\n\tint err;\n\n\terr = enic_dev_fw_info(enic, &fw_info);\n\t \n\tif (err == -ENOMEM)\n\t\treturn;\n\n\tstrscpy(drvinfo->driver, DRV_NAME, sizeof(drvinfo->driver));\n\tstrscpy(drvinfo->fw_version, fw_info->fw_version,\n\t\tsizeof(drvinfo->fw_version));\n\tstrscpy(drvinfo->bus_info, pci_name(enic->pdev),\n\t\tsizeof(drvinfo->bus_info));\n}\n\nstatic void enic_get_strings(struct net_device *netdev, u32 stringset,\n\tu8 *data)\n{\n\tunsigned int i;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < enic_n_tx_stats; i++) {\n\t\t\tmemcpy(data, enic_tx_stats[i].name, ETH_GSTRING_LEN);\n\t\t\tdata += ETH_GSTRING_LEN;\n\t\t}\n\t\tfor (i = 0; i < enic_n_rx_stats; i++) {\n\t\t\tmemcpy(data, enic_rx_stats[i].name, ETH_GSTRING_LEN);\n\t\t\tdata += ETH_GSTRING_LEN;\n\t\t}\n\t\tfor (i = 0; i < enic_n_gen_stats; i++) {\n\t\t\tmemcpy(data, enic_gen_stats[i].name, ETH_GSTRING_LEN);\n\t\t\tdata += ETH_GSTRING_LEN;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void enic_get_ringparam(struct net_device *netdev,\n\t\t\t       struct ethtool_ringparam *ring,\n\t\t\t       struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct enic *enic = netdev_priv(netdev);\n\tstruct vnic_enet_config *c = &enic->config;\n\n\tring->rx_max_pending = ENIC_MAX_RQ_DESCS;\n\tring->rx_pending = c->rq_desc_count;\n\tring->tx_max_pending = ENIC_MAX_WQ_DESCS;\n\tring->tx_pending = c->wq_desc_count;\n}\n\nstatic int enic_set_ringparam(struct net_device *netdev,\n\t\t\t      struct ethtool_ringparam *ring,\n\t\t\t      struct kernel_ethtool_ringparam *kernel_ring,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct enic *enic = netdev_priv(netdev);\n\tstruct vnic_enet_config *c = &enic->config;\n\tint running = netif_running(netdev);\n\tunsigned int rx_pending;\n\tunsigned int tx_pending;\n\tint err = 0;\n\n\tif (ring->rx_mini_max_pending || ring->rx_mini_pending) {\n\t\tnetdev_info(netdev,\n\t\t\t    \"modifying mini ring params is not supported\");\n\t\treturn -EINVAL;\n\t}\n\tif (ring->rx_jumbo_max_pending || ring->rx_jumbo_pending) {\n\t\tnetdev_info(netdev,\n\t\t\t    \"modifying jumbo ring params is not supported\");\n\t\treturn -EINVAL;\n\t}\n\trx_pending = c->rq_desc_count;\n\ttx_pending = c->wq_desc_count;\n\tif (ring->rx_pending > ENIC_MAX_RQ_DESCS ||\n\t    ring->rx_pending < ENIC_MIN_RQ_DESCS) {\n\t\tnetdev_info(netdev, \"rx pending (%u) not in range [%u,%u]\",\n\t\t\t    ring->rx_pending, ENIC_MIN_RQ_DESCS,\n\t\t\t    ENIC_MAX_RQ_DESCS);\n\t\treturn -EINVAL;\n\t}\n\tif (ring->tx_pending > ENIC_MAX_WQ_DESCS ||\n\t    ring->tx_pending < ENIC_MIN_WQ_DESCS) {\n\t\tnetdev_info(netdev, \"tx pending (%u) not in range [%u,%u]\",\n\t\t\t    ring->tx_pending, ENIC_MIN_WQ_DESCS,\n\t\t\t    ENIC_MAX_WQ_DESCS);\n\t\treturn -EINVAL;\n\t}\n\tif (running)\n\t\tdev_close(netdev);\n\tc->rq_desc_count =\n\t\tring->rx_pending & 0xffffffe0;  \n\tc->wq_desc_count =\n\t\tring->tx_pending & 0xffffffe0;  \n\tenic_free_vnic_resources(enic);\n\terr = enic_alloc_vnic_resources(enic);\n\tif (err) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"Failed to alloc vNIC resources, aborting\\n\");\n\t\tenic_free_vnic_resources(enic);\n\t\tgoto err_out;\n\t}\n\tenic_init_vnic_resources(enic);\n\tif (running) {\n\t\terr = dev_open(netdev, NULL);\n\t\tif (err)\n\t\t\tgoto err_out;\n\t}\n\treturn 0;\nerr_out:\n\tc->rq_desc_count = rx_pending;\n\tc->wq_desc_count = tx_pending;\n\treturn err;\n}\n\nstatic int enic_get_sset_count(struct net_device *netdev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn enic_n_tx_stats + enic_n_rx_stats + enic_n_gen_stats;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void enic_get_ethtool_stats(struct net_device *netdev,\n\tstruct ethtool_stats *stats, u64 *data)\n{\n\tstruct enic *enic = netdev_priv(netdev);\n\tstruct vnic_stats *vstats;\n\tunsigned int i;\n\tint err;\n\n\terr = enic_dev_stats_dump(enic, &vstats);\n\t \n\tif (err == -ENOMEM)\n\t\treturn;\n\n\tfor (i = 0; i < enic_n_tx_stats; i++)\n\t\t*(data++) = ((u64 *)&vstats->tx)[enic_tx_stats[i].index];\n\tfor (i = 0; i < enic_n_rx_stats; i++)\n\t\t*(data++) = ((u64 *)&vstats->rx)[enic_rx_stats[i].index];\n\tfor (i = 0; i < enic_n_gen_stats; i++)\n\t\t*(data++) = ((u64 *)&enic->gen_stats)[enic_gen_stats[i].index];\n}\n\nstatic u32 enic_get_msglevel(struct net_device *netdev)\n{\n\tstruct enic *enic = netdev_priv(netdev);\n\treturn enic->msg_enable;\n}\n\nstatic void enic_set_msglevel(struct net_device *netdev, u32 value)\n{\n\tstruct enic *enic = netdev_priv(netdev);\n\tenic->msg_enable = value;\n}\n\nstatic int enic_get_coalesce(struct net_device *netdev,\n\t\t\t     struct ethtool_coalesce *ecmd,\n\t\t\t     struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct enic *enic = netdev_priv(netdev);\n\tstruct enic_rx_coal *rxcoal = &enic->rx_coalesce_setting;\n\n\tif (vnic_dev_get_intr_mode(enic->vdev) == VNIC_DEV_INTR_MODE_MSIX)\n\t\tecmd->tx_coalesce_usecs = enic->tx_coalesce_usecs;\n\tecmd->rx_coalesce_usecs = enic->rx_coalesce_usecs;\n\tif (rxcoal->use_adaptive_rx_coalesce)\n\t\tecmd->use_adaptive_rx_coalesce = 1;\n\tecmd->rx_coalesce_usecs_low = rxcoal->small_pkt_range_start;\n\tecmd->rx_coalesce_usecs_high = rxcoal->range_end;\n\n\treturn 0;\n}\n\nstatic int enic_coalesce_valid(struct enic *enic,\n\t\t\t       struct ethtool_coalesce *ec)\n{\n\tu32 coalesce_usecs_max = vnic_dev_get_intr_coal_timer_max(enic->vdev);\n\tu32 rx_coalesce_usecs_high = min_t(u32, coalesce_usecs_max,\n\t\t\t\t\t   ec->rx_coalesce_usecs_high);\n\tu32 rx_coalesce_usecs_low = min_t(u32, coalesce_usecs_max,\n\t\t\t\t\t  ec->rx_coalesce_usecs_low);\n\n\tif ((vnic_dev_get_intr_mode(enic->vdev) != VNIC_DEV_INTR_MODE_MSIX) &&\n\t    ec->tx_coalesce_usecs)\n\t\treturn -EINVAL;\n\n\tif ((ec->tx_coalesce_usecs > coalesce_usecs_max)\t||\n\t    (ec->rx_coalesce_usecs > coalesce_usecs_max)\t||\n\t    (ec->rx_coalesce_usecs_low > coalesce_usecs_max)\t||\n\t    (ec->rx_coalesce_usecs_high > coalesce_usecs_max))\n\t\tnetdev_info(enic->netdev, \"ethtool_set_coalesce: adaptor supports max coalesce value of %d. Setting max value.\\n\",\n\t\t\t    coalesce_usecs_max);\n\n\tif (ec->rx_coalesce_usecs_high &&\n\t    (rx_coalesce_usecs_high <\n\t     rx_coalesce_usecs_low + ENIC_AIC_LARGE_PKT_DIFF))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int enic_set_coalesce(struct net_device *netdev,\n\t\t\t     struct ethtool_coalesce *ecmd,\n\t\t\t     struct kernel_ethtool_coalesce *kernel_coal,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct enic *enic = netdev_priv(netdev);\n\tu32 tx_coalesce_usecs;\n\tu32 rx_coalesce_usecs;\n\tu32 rx_coalesce_usecs_low;\n\tu32 rx_coalesce_usecs_high;\n\tu32 coalesce_usecs_max;\n\tunsigned int i, intr;\n\tint ret;\n\tstruct enic_rx_coal *rxcoal = &enic->rx_coalesce_setting;\n\n\tret = enic_coalesce_valid(enic, ecmd);\n\tif (ret)\n\t\treturn ret;\n\tcoalesce_usecs_max = vnic_dev_get_intr_coal_timer_max(enic->vdev);\n\ttx_coalesce_usecs = min_t(u32, ecmd->tx_coalesce_usecs,\n\t\t\t\t  coalesce_usecs_max);\n\trx_coalesce_usecs = min_t(u32, ecmd->rx_coalesce_usecs,\n\t\t\t\t  coalesce_usecs_max);\n\n\trx_coalesce_usecs_low = min_t(u32, ecmd->rx_coalesce_usecs_low,\n\t\t\t\t      coalesce_usecs_max);\n\trx_coalesce_usecs_high = min_t(u32, ecmd->rx_coalesce_usecs_high,\n\t\t\t\t       coalesce_usecs_max);\n\n\tif (vnic_dev_get_intr_mode(enic->vdev) == VNIC_DEV_INTR_MODE_MSIX) {\n\t\tfor (i = 0; i < enic->wq_count; i++) {\n\t\t\tintr = enic_msix_wq_intr(enic, i);\n\t\t\tvnic_intr_coalescing_timer_set(&enic->intr[intr],\n\t\t\t\t\t\t       tx_coalesce_usecs);\n\t\t}\n\t\tenic->tx_coalesce_usecs = tx_coalesce_usecs;\n\t}\n\trxcoal->use_adaptive_rx_coalesce = !!ecmd->use_adaptive_rx_coalesce;\n\tif (!rxcoal->use_adaptive_rx_coalesce)\n\t\tenic_intr_coal_set_rx(enic, rx_coalesce_usecs);\n\tif (ecmd->rx_coalesce_usecs_high) {\n\t\trxcoal->range_end = rx_coalesce_usecs_high;\n\t\trxcoal->small_pkt_range_start = rx_coalesce_usecs_low;\n\t\trxcoal->large_pkt_range_start = rx_coalesce_usecs_low +\n\t\t\t\t\t\tENIC_AIC_LARGE_PKT_DIFF;\n\t}\n\n\tenic->rx_coalesce_usecs = rx_coalesce_usecs;\n\n\treturn 0;\n}\n\nstatic int enic_grxclsrlall(struct enic *enic, struct ethtool_rxnfc *cmd,\n\t\t\t    u32 *rule_locs)\n{\n\tint j, ret = 0, cnt = 0;\n\n\tcmd->data = enic->rfs_h.max - enic->rfs_h.free;\n\tfor (j = 0; j < (1 << ENIC_RFS_FLW_BITSHIFT); j++) {\n\t\tstruct hlist_head *hhead;\n\t\tstruct hlist_node *tmp;\n\t\tstruct enic_rfs_fltr_node *n;\n\n\t\thhead = &enic->rfs_h.ht_head[j];\n\t\thlist_for_each_entry_safe(n, tmp, hhead, node) {\n\t\t\tif (cnt == cmd->rule_cnt)\n\t\t\t\treturn -EMSGSIZE;\n\t\t\trule_locs[cnt] = n->fltr_id;\n\t\t\tcnt++;\n\t\t}\n\t}\n\tcmd->rule_cnt = cnt;\n\n\treturn ret;\n}\n\nstatic int enic_grxclsrule(struct enic *enic, struct ethtool_rxnfc *cmd)\n{\n\tstruct ethtool_rx_flow_spec *fsp =\n\t\t\t\t(struct ethtool_rx_flow_spec *)&cmd->fs;\n\tstruct enic_rfs_fltr_node *n;\n\n\tn = htbl_fltr_search(enic, (u16)fsp->location);\n\tif (!n)\n\t\treturn -EINVAL;\n\tswitch (n->keys.basic.ip_proto) {\n\tcase IPPROTO_TCP:\n\t\tfsp->flow_type = TCP_V4_FLOW;\n\t\tbreak;\n\tcase IPPROTO_UDP:\n\t\tfsp->flow_type = UDP_V4_FLOW;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tfsp->h_u.tcp_ip4_spec.ip4src = flow_get_u32_src(&n->keys);\n\tfsp->m_u.tcp_ip4_spec.ip4src = (__u32)~0;\n\n\tfsp->h_u.tcp_ip4_spec.ip4dst = flow_get_u32_dst(&n->keys);\n\tfsp->m_u.tcp_ip4_spec.ip4dst = (__u32)~0;\n\n\tfsp->h_u.tcp_ip4_spec.psrc = n->keys.ports.src;\n\tfsp->m_u.tcp_ip4_spec.psrc = (__u16)~0;\n\n\tfsp->h_u.tcp_ip4_spec.pdst = n->keys.ports.dst;\n\tfsp->m_u.tcp_ip4_spec.pdst = (__u16)~0;\n\n\tfsp->ring_cookie = n->rq_id;\n\n\treturn 0;\n}\n\nstatic int enic_get_rx_flow_hash(struct enic *enic, struct ethtool_rxnfc *cmd)\n{\n\tu8 rss_hash_type = 0;\n\tcmd->data = 0;\n\n\tspin_lock_bh(&enic->devcmd_lock);\n\t(void)vnic_dev_capable_rss_hash_type(enic->vdev, &rss_hash_type);\n\tspin_unlock_bh(&enic->devcmd_lock);\n\tswitch (cmd->flow_type) {\n\tcase TCP_V6_FLOW:\n\tcase TCP_V4_FLOW:\n\t\tcmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3 |\n\t\t\t     RXH_IP_SRC | RXH_IP_DST;\n\t\tbreak;\n\tcase UDP_V6_FLOW:\n\t\tcmd->data |= RXH_IP_SRC | RXH_IP_DST;\n\t\tif (rss_hash_type & NIC_CFG_RSS_HASH_TYPE_UDP_IPV6)\n\t\t\tcmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tbreak;\n\tcase UDP_V4_FLOW:\n\t\tcmd->data |= RXH_IP_SRC | RXH_IP_DST;\n\t\tif (rss_hash_type & NIC_CFG_RSS_HASH_TYPE_UDP_IPV4)\n\t\t\tcmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;\n\t\tbreak;\n\tcase SCTP_V4_FLOW:\n\tcase AH_ESP_V4_FLOW:\n\tcase AH_V4_FLOW:\n\tcase ESP_V4_FLOW:\n\tcase SCTP_V6_FLOW:\n\tcase AH_ESP_V6_FLOW:\n\tcase AH_V6_FLOW:\n\tcase ESP_V6_FLOW:\n\tcase IPV4_FLOW:\n\tcase IPV6_FLOW:\n\t\tcmd->data |= RXH_IP_SRC | RXH_IP_DST;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int enic_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,\n\t\t\t  u32 *rule_locs)\n{\n\tstruct enic *enic = netdev_priv(dev);\n\tint ret = 0;\n\n\tswitch (cmd->cmd) {\n\tcase ETHTOOL_GRXRINGS:\n\t\tcmd->data = enic->rq_count;\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLCNT:\n\t\tspin_lock_bh(&enic->rfs_h.lock);\n\t\tcmd->rule_cnt = enic->rfs_h.max - enic->rfs_h.free;\n\t\tcmd->data = enic->rfs_h.max;\n\t\tspin_unlock_bh(&enic->rfs_h.lock);\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\tspin_lock_bh(&enic->rfs_h.lock);\n\t\tret = enic_grxclsrlall(enic, cmd, rule_locs);\n\t\tspin_unlock_bh(&enic->rfs_h.lock);\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRULE:\n\t\tspin_lock_bh(&enic->rfs_h.lock);\n\t\tret = enic_grxclsrule(enic, cmd);\n\t\tspin_unlock_bh(&enic->rfs_h.lock);\n\t\tbreak;\n\tcase ETHTOOL_GRXFH:\n\t\tret = enic_get_rx_flow_hash(enic, cmd);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int enic_get_tunable(struct net_device *dev,\n\t\t\t    const struct ethtool_tunable *tuna, void *data)\n{\n\tstruct enic *enic = netdev_priv(dev);\n\tint ret = 0;\n\n\tswitch (tuna->id) {\n\tcase ETHTOOL_RX_COPYBREAK:\n\t\t*(u32 *)data = enic->rx_copybreak;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int enic_set_tunable(struct net_device *dev,\n\t\t\t    const struct ethtool_tunable *tuna,\n\t\t\t    const void *data)\n{\n\tstruct enic *enic = netdev_priv(dev);\n\tint ret = 0;\n\n\tswitch (tuna->id) {\n\tcase ETHTOOL_RX_COPYBREAK:\n\t\tenic->rx_copybreak = *(u32 *)data;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic u32 enic_get_rxfh_key_size(struct net_device *netdev)\n{\n\treturn ENIC_RSS_LEN;\n}\n\nstatic int enic_get_rxfh(struct net_device *netdev, u32 *indir, u8 *hkey,\n\t\t\t u8 *hfunc)\n{\n\tstruct enic *enic = netdev_priv(netdev);\n\n\tif (hkey)\n\t\tmemcpy(hkey, enic->rss_key, ENIC_RSS_LEN);\n\n\tif (hfunc)\n\t\t*hfunc = ETH_RSS_HASH_TOP;\n\n\treturn 0;\n}\n\nstatic int enic_set_rxfh(struct net_device *netdev, const u32 *indir,\n\t\t\t const u8 *hkey, const u8 hfunc)\n{\n\tstruct enic *enic = netdev_priv(netdev);\n\n\tif ((hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP) ||\n\t    indir)\n\t\treturn -EINVAL;\n\n\tif (hkey)\n\t\tmemcpy(enic->rss_key, hkey, ENIC_RSS_LEN);\n\n\treturn __enic_set_rsskey(enic);\n}\n\nstatic int enic_get_ts_info(struct net_device *netdev,\n\t\t\t    struct ethtool_ts_info *info)\n{\n\tinfo->so_timestamping = SOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\tSOF_TIMESTAMPING_SOFTWARE;\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops enic_ethtool_ops = {\n\t.supported_coalesce_params = ETHTOOL_COALESCE_USECS |\n\t\t\t\t     ETHTOOL_COALESCE_USE_ADAPTIVE_RX |\n\t\t\t\t     ETHTOOL_COALESCE_RX_USECS_LOW |\n\t\t\t\t     ETHTOOL_COALESCE_RX_USECS_HIGH,\n\t.get_drvinfo = enic_get_drvinfo,\n\t.get_msglevel = enic_get_msglevel,\n\t.set_msglevel = enic_set_msglevel,\n\t.get_link = ethtool_op_get_link,\n\t.get_strings = enic_get_strings,\n\t.get_ringparam = enic_get_ringparam,\n\t.set_ringparam = enic_set_ringparam,\n\t.get_sset_count = enic_get_sset_count,\n\t.get_ethtool_stats = enic_get_ethtool_stats,\n\t.get_coalesce = enic_get_coalesce,\n\t.set_coalesce = enic_set_coalesce,\n\t.get_rxnfc = enic_get_rxnfc,\n\t.get_tunable = enic_get_tunable,\n\t.set_tunable = enic_set_tunable,\n\t.get_rxfh_key_size = enic_get_rxfh_key_size,\n\t.get_rxfh = enic_get_rxfh,\n\t.set_rxfh = enic_set_rxfh,\n\t.get_link_ksettings = enic_get_ksettings,\n\t.get_ts_info = enic_get_ts_info,\n};\n\nvoid enic_set_ethtool_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &enic_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}