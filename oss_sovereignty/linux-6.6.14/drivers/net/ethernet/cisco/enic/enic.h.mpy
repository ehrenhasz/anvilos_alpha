{
  "module_name": "enic.h",
  "hash_id": "b48a47827dc747bcaa7b4e1eab861927b4ff748b3912735d1b89d0ed209ecc22",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cisco/enic/enic.h",
  "human_readable_source": " \n \n\n#ifndef _ENIC_H_\n#define _ENIC_H_\n\n#include \"vnic_enet.h\"\n#include \"vnic_dev.h\"\n#include \"vnic_wq.h\"\n#include \"vnic_rq.h\"\n#include \"vnic_cq.h\"\n#include \"vnic_intr.h\"\n#include \"vnic_stats.h\"\n#include \"vnic_nic.h\"\n#include \"vnic_rss.h\"\n#include <linux/irq.h>\n\n#define DRV_NAME\t\t\"enic\"\n#define DRV_DESCRIPTION\t\t\"Cisco VIC Ethernet NIC Driver\"\n\n#define ENIC_BARS_MAX\t\t6\n\n#define ENIC_WQ_MAX\t\t8\n#define ENIC_RQ_MAX\t\t8\n#define ENIC_CQ_MAX\t\t(ENIC_WQ_MAX + ENIC_RQ_MAX)\n#define ENIC_INTR_MAX\t\t(ENIC_CQ_MAX + 2)\n\n#define ENIC_WQ_NAPI_BUDGET\t256\n\n#define ENIC_AIC_LARGE_PKT_DIFF\t3\n\nstruct enic_msix_entry {\n\tint requested;\n\tchar devname[IFNAMSIZ + 8];\n\tirqreturn_t (*isr)(int, void *);\n\tvoid *devid;\n\tcpumask_var_t affinity_mask;\n};\n\n \nstruct enic_intr_mod_range {\n\tu32 small_pkt_range_start;\n\tu32 large_pkt_range_start;\n};\n\nstruct enic_intr_mod_table {\n\tu32 rx_rate;\n\tu32 range_percent;\n};\n\n#define ENIC_MAX_LINK_SPEEDS\t\t3\n#define ENIC_LINK_SPEED_10G\t\t10000\n#define ENIC_LINK_SPEED_4G\t\t4000\n#define ENIC_LINK_40G_INDEX\t\t2\n#define ENIC_LINK_10G_INDEX\t\t1\n#define ENIC_LINK_4G_INDEX\t\t0\n#define ENIC_RX_COALESCE_RANGE_END\t125\n#define ENIC_AIC_TS_BREAK\t\t100\n\nstruct enic_rx_coal {\n\tu32 small_pkt_range_start;\n\tu32 large_pkt_range_start;\n\tu32 range_end;\n\tu32 use_adaptive_rx_coalesce;\n};\n\n \n#define ENIC_SRIOV_ENABLED\t\t(1 << 0)\n\n \n#define ENIC_PORT_REQUEST_APPLIED\t(1 << 0)\n#define ENIC_SET_REQUEST\t\t(1 << 1)\n#define ENIC_SET_NAME\t\t\t(1 << 2)\n#define ENIC_SET_INSTANCE\t\t(1 << 3)\n#define ENIC_SET_HOST\t\t\t(1 << 4)\n\nstruct enic_port_profile {\n\tu32 set;\n\tu8 request;\n\tchar name[PORT_PROFILE_MAX];\n\tu8 instance_uuid[PORT_UUID_MAX];\n\tu8 host_uuid[PORT_UUID_MAX];\n\tu8 vf_mac[ETH_ALEN];\n\tu8 mac_addr[ETH_ALEN];\n};\n\n \nstruct enic_rfs_fltr_node {\n\tstruct flow_keys keys;\n\tu32 flow_id;\n\tu16 fltr_id;\n\tu16 rq_id;\n\tstruct hlist_node node;\n};\n\n \nstruct enic_rfs_flw_tbl {\n\tu16 max;\n\tint free;\n\n#define ENIC_RFS_FLW_BITSHIFT\t(10)\n#define ENIC_RFS_FLW_MASK\t((1 << ENIC_RFS_FLW_BITSHIFT) - 1)\n\tu16 toclean:ENIC_RFS_FLW_BITSHIFT;\n\tstruct hlist_head ht_head[1 << ENIC_RFS_FLW_BITSHIFT];\n\tspinlock_t lock;\n\tstruct timer_list rfs_may_expire;\n};\n\nstruct vxlan_offload {\n\tu16 vxlan_udp_port_number;\n\tu8 patch_level;\n\tu8 flags;\n};\n\n \nstruct enic {\n\tstruct net_device *netdev;\n\tstruct pci_dev *pdev;\n\tstruct vnic_enet_config config;\n\tstruct vnic_dev_bar bar[ENIC_BARS_MAX];\n\tstruct vnic_dev *vdev;\n\tstruct timer_list notify_timer;\n\tstruct work_struct reset;\n\tstruct work_struct tx_hang_reset;\n\tstruct work_struct change_mtu_work;\n\tstruct msix_entry msix_entry[ENIC_INTR_MAX];\n\tstruct enic_msix_entry msix[ENIC_INTR_MAX];\n\tu32 msg_enable;\n\tspinlock_t devcmd_lock;\n\tu8 mac_addr[ETH_ALEN];\n\tunsigned int flags;\n\tunsigned int priv_flags;\n\tunsigned int mc_count;\n\tunsigned int uc_count;\n\tu32 port_mtu;\n\tstruct enic_rx_coal rx_coalesce_setting;\n\tu32 rx_coalesce_usecs;\n\tu32 tx_coalesce_usecs;\n#ifdef CONFIG_PCI_IOV\n\tu16 num_vfs;\n#endif\n\tspinlock_t enic_api_lock;\n\tbool enic_api_busy;\n\tstruct enic_port_profile *pp;\n\n\t \n\t____cacheline_aligned struct vnic_wq wq[ENIC_WQ_MAX];\n\tspinlock_t wq_lock[ENIC_WQ_MAX];\n\tunsigned int wq_count;\n\tu16 loop_enable;\n\tu16 loop_tag;\n\n\t \n\t____cacheline_aligned struct vnic_rq rq[ENIC_RQ_MAX];\n\tunsigned int rq_count;\n\tstruct vxlan_offload vxlan;\n\tu64 rq_truncated_pkts;\n\tu64 rq_bad_fcs;\n\tstruct napi_struct napi[ENIC_RQ_MAX + ENIC_WQ_MAX];\n\n\t \n\t____cacheline_aligned struct vnic_intr intr[ENIC_INTR_MAX];\n\tunsigned int intr_count;\n\tu32 __iomem *legacy_pba;\t\t \n\n\t \n\t____cacheline_aligned struct vnic_cq cq[ENIC_CQ_MAX];\n\tunsigned int cq_count;\n\tstruct enic_rfs_flw_tbl rfs_h;\n\tu32 rx_copybreak;\n\tu8 rss_key[ENIC_RSS_LEN];\n\tstruct vnic_gen_stats gen_stats;\n};\n\nstatic inline struct net_device *vnic_get_netdev(struct vnic_dev *vdev)\n{\n\tstruct enic *enic = vdev->priv;\n\n\treturn enic->netdev;\n}\n\n \n#define vdev_err(vdev, fmt, ...)\t\t\t\t\t\\\n\tdev_err(&(vdev)->pdev->dev, fmt, ##__VA_ARGS__)\n#define vdev_warn(vdev, fmt, ...)\t\t\t\t\t\\\n\tdev_warn(&(vdev)->pdev->dev, fmt, ##__VA_ARGS__)\n#define vdev_info(vdev, fmt, ...)\t\t\t\t\t\\\n\tdev_info(&(vdev)->pdev->dev, fmt, ##__VA_ARGS__)\n\n#define vdev_neterr(vdev, fmt, ...)\t\t\t\t\t\\\n\tnetdev_err(vnic_get_netdev(vdev), fmt, ##__VA_ARGS__)\n#define vdev_netwarn(vdev, fmt, ...)\t\t\t\t\t\\\n\tnetdev_warn(vnic_get_netdev(vdev), fmt, ##__VA_ARGS__)\n#define vdev_netinfo(vdev, fmt, ...)\t\t\t\t\t\\\n\tnetdev_info(vnic_get_netdev(vdev), fmt, ##__VA_ARGS__)\n\nstatic inline struct device *enic_get_dev(struct enic *enic)\n{\n\treturn &(enic->pdev->dev);\n}\n\nstatic inline unsigned int enic_cq_rq(struct enic *enic, unsigned int rq)\n{\n\treturn rq;\n}\n\nstatic inline unsigned int enic_cq_wq(struct enic *enic, unsigned int wq)\n{\n\treturn enic->rq_count + wq;\n}\n\nstatic inline unsigned int enic_msix_rq_intr(struct enic *enic,\n\tunsigned int rq)\n{\n\treturn enic->cq[enic_cq_rq(enic, rq)].interrupt_offset;\n}\n\nstatic inline unsigned int enic_msix_wq_intr(struct enic *enic,\n\tunsigned int wq)\n{\n\treturn enic->cq[enic_cq_wq(enic, wq)].interrupt_offset;\n}\n\nstatic inline unsigned int enic_msix_err_intr(struct enic *enic)\n{\n\treturn enic->rq_count + enic->wq_count;\n}\n\n#define ENIC_LEGACY_IO_INTR\t0\n#define ENIC_LEGACY_ERR_INTR\t1\n#define ENIC_LEGACY_NOTIFY_INTR\t2\n\nstatic inline unsigned int enic_msix_notify_intr(struct enic *enic)\n{\n\treturn enic->rq_count + enic->wq_count + 1;\n}\n\nstatic inline bool enic_is_err_intr(struct enic *enic, int intr)\n{\n\tswitch (vnic_dev_get_intr_mode(enic->vdev)) {\n\tcase VNIC_DEV_INTR_MODE_INTX:\n\t\treturn intr == ENIC_LEGACY_ERR_INTR;\n\tcase VNIC_DEV_INTR_MODE_MSIX:\n\t\treturn intr == enic_msix_err_intr(enic);\n\tcase VNIC_DEV_INTR_MODE_MSI:\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic inline bool enic_is_notify_intr(struct enic *enic, int intr)\n{\n\tswitch (vnic_dev_get_intr_mode(enic->vdev)) {\n\tcase VNIC_DEV_INTR_MODE_INTX:\n\t\treturn intr == ENIC_LEGACY_NOTIFY_INTR;\n\tcase VNIC_DEV_INTR_MODE_MSIX:\n\t\treturn intr == enic_msix_notify_intr(enic);\n\tcase VNIC_DEV_INTR_MODE_MSI:\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic inline int enic_dma_map_check(struct enic *enic, dma_addr_t dma_addr)\n{\n\tif (unlikely(dma_mapping_error(&enic->pdev->dev, dma_addr))) {\n\t\tnet_warn_ratelimited(\"%s: PCI dma mapping failed!\\n\",\n\t\t\t\t     enic->netdev->name);\n\t\tenic->gen_stats.dma_map_error++;\n\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nvoid enic_reset_addr_lists(struct enic *enic);\nint enic_sriov_enabled(struct enic *enic);\nint enic_is_valid_vf(struct enic *enic, int vf);\nint enic_is_dynamic(struct enic *enic);\nvoid enic_set_ethtool_ops(struct net_device *netdev);\nint __enic_set_rsskey(struct enic *enic);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}