{
  "module_name": "vnic_cq.h",
  "hash_id": "d066cbc1d1d8810beb5180e70693b9b52a045466396dc37aacdae379b61f78d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cisco/enic/vnic_cq.h",
  "human_readable_source": " \n \n\n#ifndef _VNIC_CQ_H_\n#define _VNIC_CQ_H_\n\n#include \"cq_desc.h\"\n#include \"vnic_dev.h\"\n\n \nstruct vnic_cq_ctrl {\n\tu64 ring_base;\t\t\t \n\tu32 ring_size;\t\t\t \n\tu32 pad0;\n\tu32 flow_control_enable;\t \n\tu32 pad1;\n\tu32 color_enable;\t\t \n\tu32 pad2;\n\tu32 cq_head;\t\t\t \n\tu32 pad3;\n\tu32 cq_tail;\t\t\t \n\tu32 pad4;\n\tu32 cq_tail_color;\t\t \n\tu32 pad5;\n\tu32 interrupt_enable;\t\t \n\tu32 pad6;\n\tu32 cq_entry_enable;\t\t \n\tu32 pad7;\n\tu32 cq_message_enable;\t\t \n\tu32 pad8;\n\tu32 interrupt_offset;\t\t \n\tu32 pad9;\n\tu64 cq_message_addr;\t\t \n\tu32 pad10;\n};\n\nstruct vnic_rx_bytes_counter {\n\tunsigned int small_pkt_bytes_cnt;\n\tunsigned int large_pkt_bytes_cnt;\n};\n\nstruct vnic_cq {\n\tunsigned int index;\n\tstruct vnic_dev *vdev;\n\tstruct vnic_cq_ctrl __iomem *ctrl;               \n\tstruct vnic_dev_ring ring;\n\tunsigned int to_clean;\n\tunsigned int last_color;\n\tunsigned int interrupt_offset;\n\tstruct vnic_rx_bytes_counter pkt_size_counter;\n\tunsigned int cur_rx_coal_timeval;\n\tunsigned int tobe_rx_coal_timeval;\n\tktime_t prev_ts;\n};\n\nstatic inline unsigned int vnic_cq_service(struct vnic_cq *cq,\n\tunsigned int work_to_do,\n\tint (*q_service)(struct vnic_dev *vdev, struct cq_desc *cq_desc,\n\tu8 type, u16 q_number, u16 completed_index, void *opaque),\n\tvoid *opaque)\n{\n\tstruct cq_desc *cq_desc;\n\tunsigned int work_done = 0;\n\tu16 q_number, completed_index;\n\tu8 type, color;\n\n\tcq_desc = (struct cq_desc *)((u8 *)cq->ring.descs +\n\t\tcq->ring.desc_size * cq->to_clean);\n\tcq_desc_dec(cq_desc, &type, &color,\n\t\t&q_number, &completed_index);\n\n\twhile (color != cq->last_color) {\n\n\t\tif ((*q_service)(cq->vdev, cq_desc, type,\n\t\t\tq_number, completed_index, opaque))\n\t\t\tbreak;\n\n\t\tcq->to_clean++;\n\t\tif (cq->to_clean == cq->ring.desc_count) {\n\t\t\tcq->to_clean = 0;\n\t\t\tcq->last_color = cq->last_color ? 0 : 1;\n\t\t}\n\n\t\tcq_desc = (struct cq_desc *)((u8 *)cq->ring.descs +\n\t\t\tcq->ring.desc_size * cq->to_clean);\n\t\tcq_desc_dec(cq_desc, &type, &color,\n\t\t\t&q_number, &completed_index);\n\n\t\twork_done++;\n\t\tif (work_done >= work_to_do)\n\t\t\tbreak;\n\t}\n\n\treturn work_done;\n}\n\nvoid vnic_cq_free(struct vnic_cq *cq);\nint vnic_cq_alloc(struct vnic_dev *vdev, struct vnic_cq *cq, unsigned int index,\n\tunsigned int desc_count, unsigned int desc_size);\nvoid vnic_cq_init(struct vnic_cq *cq, unsigned int flow_control_enable,\n\tunsigned int color_enable, unsigned int cq_head, unsigned int cq_tail,\n\tunsigned int cq_tail_color, unsigned int interrupt_enable,\n\tunsigned int cq_entry_enable, unsigned int message_enable,\n\tunsigned int interrupt_offset, u64 message_addr);\nvoid vnic_cq_clean(struct vnic_cq *cq);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}