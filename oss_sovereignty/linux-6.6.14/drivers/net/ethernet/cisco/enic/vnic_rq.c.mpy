{
  "module_name": "vnic_rq.c",
  "hash_id": "cbe9eb3d78872c66fffeb7b4cf4ef9b91381d974ac89770f91fbaac052f46548",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cisco/enic/vnic_rq.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n\n#include \"vnic_dev.h\"\n#include \"vnic_rq.h\"\n#include \"enic.h\"\n\nstatic int vnic_rq_alloc_bufs(struct vnic_rq *rq)\n{\n\tstruct vnic_rq_buf *buf;\n\tunsigned int i, j, count = rq->ring.desc_count;\n\tunsigned int blks = VNIC_RQ_BUF_BLKS_NEEDED(count);\n\n\tfor (i = 0; i < blks; i++) {\n\t\trq->bufs[i] = kzalloc(VNIC_RQ_BUF_BLK_SZ(count), GFP_KERNEL);\n\t\tif (!rq->bufs[i])\n\t\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < blks; i++) {\n\t\tbuf = rq->bufs[i];\n\t\tfor (j = 0; j < VNIC_RQ_BUF_BLK_ENTRIES(count); j++) {\n\t\t\tbuf->index = i * VNIC_RQ_BUF_BLK_ENTRIES(count) + j;\n\t\t\tbuf->desc = (u8 *)rq->ring.descs +\n\t\t\t\trq->ring.desc_size * buf->index;\n\t\t\tif (buf->index + 1 == count) {\n\t\t\t\tbuf->next = rq->bufs[0];\n\t\t\t\tbreak;\n\t\t\t} else if (j + 1 == VNIC_RQ_BUF_BLK_ENTRIES(count)) {\n\t\t\t\tbuf->next = rq->bufs[i + 1];\n\t\t\t} else {\n\t\t\t\tbuf->next = buf + 1;\n\t\t\t\tbuf++;\n\t\t\t}\n\t\t}\n\t}\n\n\trq->to_use = rq->to_clean = rq->bufs[0];\n\n\treturn 0;\n}\n\nvoid vnic_rq_free(struct vnic_rq *rq)\n{\n\tstruct vnic_dev *vdev;\n\tunsigned int i;\n\n\tvdev = rq->vdev;\n\n\tvnic_dev_free_desc_ring(vdev, &rq->ring);\n\n\tfor (i = 0; i < VNIC_RQ_BUF_BLKS_MAX; i++) {\n\t\tif (rq->bufs[i]) {\n\t\t\tkfree(rq->bufs[i]);\n\t\t\trq->bufs[i] = NULL;\n\t\t}\n\t}\n\n\trq->ctrl = NULL;\n}\n\nint vnic_rq_alloc(struct vnic_dev *vdev, struct vnic_rq *rq, unsigned int index,\n\tunsigned int desc_count, unsigned int desc_size)\n{\n\tint err;\n\n\trq->index = index;\n\trq->vdev = vdev;\n\n\trq->ctrl = vnic_dev_get_res(vdev, RES_TYPE_RQ, index);\n\tif (!rq->ctrl) {\n\t\tvdev_err(vdev, \"Failed to hook RQ[%d] resource\\n\", index);\n\t\treturn -EINVAL;\n\t}\n\n\tvnic_rq_disable(rq);\n\n\terr = vnic_dev_alloc_desc_ring(vdev, &rq->ring, desc_count, desc_size);\n\tif (err)\n\t\treturn err;\n\n\terr = vnic_rq_alloc_bufs(rq);\n\tif (err) {\n\t\tvnic_rq_free(rq);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void vnic_rq_init_start(struct vnic_rq *rq, unsigned int cq_index,\n\tunsigned int fetch_index, unsigned int posted_index,\n\tunsigned int error_interrupt_enable,\n\tunsigned int error_interrupt_offset)\n{\n\tu64 paddr;\n\tunsigned int count = rq->ring.desc_count;\n\n\tpaddr = (u64)rq->ring.base_addr | VNIC_PADDR_TARGET;\n\twriteq(paddr, &rq->ctrl->ring_base);\n\tiowrite32(count, &rq->ctrl->ring_size);\n\tiowrite32(cq_index, &rq->ctrl->cq_index);\n\tiowrite32(error_interrupt_enable, &rq->ctrl->error_interrupt_enable);\n\tiowrite32(error_interrupt_offset, &rq->ctrl->error_interrupt_offset);\n\tiowrite32(0, &rq->ctrl->dropped_packet_count);\n\tiowrite32(0, &rq->ctrl->error_status);\n\tiowrite32(fetch_index, &rq->ctrl->fetch_index);\n\tiowrite32(posted_index, &rq->ctrl->posted_index);\n\n\trq->to_use = rq->to_clean =\n\t\t&rq->bufs[fetch_index / VNIC_RQ_BUF_BLK_ENTRIES(count)]\n\t\t\t[fetch_index % VNIC_RQ_BUF_BLK_ENTRIES(count)];\n}\n\nvoid vnic_rq_init(struct vnic_rq *rq, unsigned int cq_index,\n\tunsigned int error_interrupt_enable,\n\tunsigned int error_interrupt_offset)\n{\n\tvnic_rq_init_start(rq, cq_index, 0, 0, error_interrupt_enable,\n\t\t\t   error_interrupt_offset);\n}\n\nunsigned int vnic_rq_error_status(struct vnic_rq *rq)\n{\n\treturn ioread32(&rq->ctrl->error_status);\n}\n\nvoid vnic_rq_enable(struct vnic_rq *rq)\n{\n\tiowrite32(1, &rq->ctrl->enable);\n}\n\nint vnic_rq_disable(struct vnic_rq *rq)\n{\n\tunsigned int wait;\n\tstruct vnic_dev *vdev = rq->vdev;\n\tint i;\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tiowrite32(0, &rq->ctrl->enable);\n\n\t\t \n\t\tfor (wait = 20000; wait > 0; wait--)\n\t\t\tif (!ioread32(&rq->ctrl->running))\n\t\t\t\tbreak;\n\t\tif (!wait) {\n\t\t\tvdev_neterr(vdev, \"Failed to disable RQ[%d]\\n\",\n\t\t\t\t    rq->index);\n\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid vnic_rq_clean(struct vnic_rq *rq,\n\tvoid (*buf_clean)(struct vnic_rq *rq, struct vnic_rq_buf *buf))\n{\n\tstruct vnic_rq_buf *buf;\n\tu32 fetch_index;\n\tunsigned int count = rq->ring.desc_count;\n\tint i;\n\n\tbuf = rq->to_clean;\n\n\tfor (i = 0; i < rq->ring.desc_count; i++) {\n\t\t(*buf_clean)(rq, buf);\n\t\tbuf = buf->next;\n\t}\n\trq->ring.desc_avail = rq->ring.desc_count - 1;\n\n\t \n\tfetch_index = ioread32(&rq->ctrl->fetch_index);\n\n\tif (fetch_index == 0xFFFFFFFF) {  \n\t\t \n\t\tfetch_index = 0;\n\t}\n\trq->to_use = rq->to_clean =\n\t\t&rq->bufs[fetch_index / VNIC_RQ_BUF_BLK_ENTRIES(count)]\n\t\t\t[fetch_index % VNIC_RQ_BUF_BLK_ENTRIES(count)];\n\tiowrite32(fetch_index, &rq->ctrl->posted_index);\n\n\t \n\tiowrite32(0, &rq->ctrl->enable);\n\n\tvnic_dev_clear_desc_ring(&rq->ring);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}