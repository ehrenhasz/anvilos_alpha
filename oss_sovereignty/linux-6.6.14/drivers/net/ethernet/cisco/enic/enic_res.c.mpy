{
  "module_name": "enic_res.c",
  "hash_id": "ec30f93b98ba530d7ce7878d0aeb1f9ca4159f734c8be730fbb7fff123c88348",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cisco/enic/enic_res.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n\n#include \"wq_enet_desc.h\"\n#include \"rq_enet_desc.h\"\n#include \"cq_enet_desc.h\"\n#include \"vnic_resource.h\"\n#include \"vnic_enet.h\"\n#include \"vnic_dev.h\"\n#include \"vnic_wq.h\"\n#include \"vnic_rq.h\"\n#include \"vnic_cq.h\"\n#include \"vnic_intr.h\"\n#include \"vnic_stats.h\"\n#include \"vnic_nic.h\"\n#include \"vnic_rss.h\"\n#include \"enic_res.h\"\n#include \"enic.h\"\n\nint enic_get_vnic_config(struct enic *enic)\n{\n\tstruct vnic_enet_config *c = &enic->config;\n\tint err;\n\n\terr = vnic_dev_get_mac_addr(enic->vdev, enic->mac_addr);\n\tif (err) {\n\t\tdev_err(enic_get_dev(enic),\n\t\t\t\"Error getting MAC addr, %d\\n\", err);\n\t\treturn err;\n\t}\n\n#define GET_CONFIG(m) \\\n\tdo { \\\n\t\terr = vnic_dev_spec(enic->vdev, \\\n\t\t\toffsetof(struct vnic_enet_config, m), \\\n\t\t\tsizeof(c->m), &c->m); \\\n\t\tif (err) { \\\n\t\t\tdev_err(enic_get_dev(enic), \\\n\t\t\t\t\"Error getting %s, %d\\n\", #m, err); \\\n\t\t\treturn err; \\\n\t\t} \\\n\t} while (0)\n\n\tGET_CONFIG(flags);\n\tGET_CONFIG(wq_desc_count);\n\tGET_CONFIG(rq_desc_count);\n\tGET_CONFIG(mtu);\n\tGET_CONFIG(intr_timer_type);\n\tGET_CONFIG(intr_mode);\n\tGET_CONFIG(intr_timer_usec);\n\tGET_CONFIG(loop_tag);\n\tGET_CONFIG(num_arfs);\n\n\tc->wq_desc_count =\n\t\tmin_t(u32, ENIC_MAX_WQ_DESCS,\n\t\tmax_t(u32, ENIC_MIN_WQ_DESCS,\n\t\tc->wq_desc_count));\n\tc->wq_desc_count &= 0xffffffe0;  \n\n\tc->rq_desc_count =\n\t\tmin_t(u32, ENIC_MAX_RQ_DESCS,\n\t\tmax_t(u32, ENIC_MIN_RQ_DESCS,\n\t\tc->rq_desc_count));\n\tc->rq_desc_count &= 0xffffffe0;  \n\n\tif (c->mtu == 0)\n\t\tc->mtu = 1500;\n\tc->mtu = min_t(u16, ENIC_MAX_MTU,\n\t\tmax_t(u16, ENIC_MIN_MTU,\n\t\tc->mtu));\n\n\tc->intr_timer_usec = min_t(u32, c->intr_timer_usec,\n\t\tvnic_dev_get_intr_coal_timer_max(enic->vdev));\n\n\tdev_info(enic_get_dev(enic),\n\t\t\"vNIC MAC addr %pM wq/rq %d/%d mtu %d\\n\",\n\t\tenic->mac_addr, c->wq_desc_count, c->rq_desc_count, c->mtu);\n\n\tdev_info(enic_get_dev(enic), \"vNIC csum tx/rx %s/%s \"\n\t\t\"tso/lro %s/%s rss %s intr mode %s type %s timer %d usec \"\n\t\t\"loopback tag 0x%04x\\n\",\n\t\tENIC_SETTING(enic, TXCSUM) ? \"yes\" : \"no\",\n\t\tENIC_SETTING(enic, RXCSUM) ? \"yes\" : \"no\",\n\t\tENIC_SETTING(enic, TSO) ? \"yes\" : \"no\",\n\t\tENIC_SETTING(enic, LRO) ? \"yes\" : \"no\",\n\t\tENIC_SETTING(enic, RSS) ? \"yes\" : \"no\",\n\t\tc->intr_mode == VENET_INTR_MODE_INTX ? \"INTx\" :\n\t\tc->intr_mode == VENET_INTR_MODE_MSI ? \"MSI\" :\n\t\tc->intr_mode == VENET_INTR_MODE_ANY ? \"any\" :\n\t\t\"unknown\",\n\t\tc->intr_timer_type == VENET_INTR_TYPE_MIN ? \"min\" :\n\t\tc->intr_timer_type == VENET_INTR_TYPE_IDLE ? \"idle\" :\n\t\t\"unknown\",\n\t\tc->intr_timer_usec,\n\t\tc->loop_tag);\n\n\treturn 0;\n}\n\nint enic_add_vlan(struct enic *enic, u16 vlanid)\n{\n\tu64 a0 = vlanid, a1 = 0;\n\tint wait = 1000;\n\tint err;\n\n\terr = vnic_dev_cmd(enic->vdev, CMD_VLAN_ADD, &a0, &a1, wait);\n\tif (err)\n\t\tdev_err(enic_get_dev(enic), \"Can't add vlan id, %d\\n\", err);\n\n\treturn err;\n}\n\nint enic_del_vlan(struct enic *enic, u16 vlanid)\n{\n\tu64 a0 = vlanid, a1 = 0;\n\tint wait = 1000;\n\tint err;\n\n\terr = vnic_dev_cmd(enic->vdev, CMD_VLAN_DEL, &a0, &a1, wait);\n\tif (err)\n\t\tdev_err(enic_get_dev(enic), \"Can't delete vlan id, %d\\n\", err);\n\n\treturn err;\n}\n\nint enic_set_nic_cfg(struct enic *enic, u8 rss_default_cpu, u8 rss_hash_type,\n\tu8 rss_hash_bits, u8 rss_base_cpu, u8 rss_enable, u8 tso_ipid_split_en,\n\tu8 ig_vlan_strip_en)\n{\n\tenum vnic_devcmd_cmd cmd = CMD_NIC_CFG;\n\tu64 a0, a1;\n\tu32 nic_cfg;\n\tint wait = 1000;\n\n\tvnic_set_nic_cfg(&nic_cfg, rss_default_cpu,\n\t\trss_hash_type, rss_hash_bits, rss_base_cpu,\n\t\trss_enable, tso_ipid_split_en, ig_vlan_strip_en);\n\n\ta0 = nic_cfg;\n\ta1 = 0;\n\n\tif (rss_hash_type & (NIC_CFG_RSS_HASH_TYPE_UDP_IPV4 |\n\t\t\t     NIC_CFG_RSS_HASH_TYPE_UDP_IPV6))\n\t\tcmd = CMD_NIC_CFG_CHK;\n\n\treturn vnic_dev_cmd(enic->vdev, cmd, &a0, &a1, wait);\n}\n\nint enic_set_rss_key(struct enic *enic, dma_addr_t key_pa, u64 len)\n{\n\tu64 a0 = (u64)key_pa, a1 = len;\n\tint wait = 1000;\n\n\treturn vnic_dev_cmd(enic->vdev, CMD_RSS_KEY, &a0, &a1, wait);\n}\n\nint enic_set_rss_cpu(struct enic *enic, dma_addr_t cpu_pa, u64 len)\n{\n\tu64 a0 = (u64)cpu_pa, a1 = len;\n\tint wait = 1000;\n\n\treturn vnic_dev_cmd(enic->vdev, CMD_RSS_CPU, &a0, &a1, wait);\n}\n\nvoid enic_free_vnic_resources(struct enic *enic)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < enic->wq_count; i++)\n\t\tvnic_wq_free(&enic->wq[i]);\n\tfor (i = 0; i < enic->rq_count; i++)\n\t\tvnic_rq_free(&enic->rq[i]);\n\tfor (i = 0; i < enic->cq_count; i++)\n\t\tvnic_cq_free(&enic->cq[i]);\n\tfor (i = 0; i < enic->intr_count; i++)\n\t\tvnic_intr_free(&enic->intr[i]);\n}\n\nvoid enic_get_res_counts(struct enic *enic)\n{\n\tenic->wq_count = vnic_dev_get_res_count(enic->vdev, RES_TYPE_WQ);\n\tenic->rq_count = vnic_dev_get_res_count(enic->vdev, RES_TYPE_RQ);\n\tenic->cq_count = vnic_dev_get_res_count(enic->vdev, RES_TYPE_CQ);\n\tenic->intr_count = vnic_dev_get_res_count(enic->vdev,\n\t\tRES_TYPE_INTR_CTRL);\n\n\tdev_info(enic_get_dev(enic),\n\t\t\"vNIC resources avail: wq %d rq %d cq %d intr %d\\n\",\n\t\tenic->wq_count, enic->rq_count,\n\t\tenic->cq_count, enic->intr_count);\n}\n\nvoid enic_init_vnic_resources(struct enic *enic)\n{\n\tenum vnic_dev_intr_mode intr_mode;\n\tunsigned int mask_on_assertion;\n\tunsigned int interrupt_offset;\n\tunsigned int error_interrupt_enable;\n\tunsigned int error_interrupt_offset;\n\tunsigned int cq_index;\n\tunsigned int i;\n\n\tintr_mode = vnic_dev_get_intr_mode(enic->vdev);\n\n\t \n\n\tswitch (intr_mode) {\n\tcase VNIC_DEV_INTR_MODE_INTX:\n\tcase VNIC_DEV_INTR_MODE_MSIX:\n\t\terror_interrupt_enable = 1;\n\t\terror_interrupt_offset = enic->intr_count - 2;\n\t\tbreak;\n\tdefault:\n\t\terror_interrupt_enable = 0;\n\t\terror_interrupt_offset = 0;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < enic->rq_count; i++) {\n\t\tcq_index = i;\n\t\tvnic_rq_init(&enic->rq[i],\n\t\t\tcq_index,\n\t\t\terror_interrupt_enable,\n\t\t\terror_interrupt_offset);\n\t}\n\n\tfor (i = 0; i < enic->wq_count; i++) {\n\t\tcq_index = enic->rq_count + i;\n\t\tvnic_wq_init(&enic->wq[i],\n\t\t\tcq_index,\n\t\t\terror_interrupt_enable,\n\t\t\terror_interrupt_offset);\n\t}\n\n\t \n\n\tfor (i = 0; i < enic->cq_count; i++) {\n\n\t\tswitch (intr_mode) {\n\t\tcase VNIC_DEV_INTR_MODE_MSIX:\n\t\t\tinterrupt_offset = i;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tinterrupt_offset = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tvnic_cq_init(&enic->cq[i],\n\t\t\t0  ,\n\t\t\t1  ,\n\t\t\t0  ,\n\t\t\t0  ,\n\t\t\t1  ,\n\t\t\t1  ,\n\t\t\t1  ,\n\t\t\t0  ,\n\t\t\tinterrupt_offset,\n\t\t\t0  );\n\t}\n\n\t \n\n\tswitch (intr_mode) {\n\tcase VNIC_DEV_INTR_MODE_MSI:\n\tcase VNIC_DEV_INTR_MODE_MSIX:\n\t\tmask_on_assertion = 1;\n\t\tbreak;\n\tdefault:\n\t\tmask_on_assertion = 0;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < enic->intr_count; i++) {\n\t\tvnic_intr_init(&enic->intr[i],\n\t\t\tenic->config.intr_timer_usec,\n\t\t\tenic->config.intr_timer_type,\n\t\t\tmask_on_assertion);\n\t}\n}\n\nint enic_alloc_vnic_resources(struct enic *enic)\n{\n\tenum vnic_dev_intr_mode intr_mode;\n\tunsigned int i;\n\tint err;\n\n\tintr_mode = vnic_dev_get_intr_mode(enic->vdev);\n\n\tdev_info(enic_get_dev(enic), \"vNIC resources used:  \"\n\t\t\"wq %d rq %d cq %d intr %d intr mode %s\\n\",\n\t\tenic->wq_count, enic->rq_count,\n\t\tenic->cq_count, enic->intr_count,\n\t\tintr_mode == VNIC_DEV_INTR_MODE_INTX ? \"legacy PCI INTx\" :\n\t\tintr_mode == VNIC_DEV_INTR_MODE_MSI ? \"MSI\" :\n\t\tintr_mode == VNIC_DEV_INTR_MODE_MSIX ? \"MSI-X\" :\n\t\t\"unknown\");\n\n\t \n\n\tfor (i = 0; i < enic->wq_count; i++) {\n\t\terr = vnic_wq_alloc(enic->vdev, &enic->wq[i], i,\n\t\t\tenic->config.wq_desc_count,\n\t\t\tsizeof(struct wq_enet_desc));\n\t\tif (err)\n\t\t\tgoto err_out_cleanup;\n\t}\n\n\tfor (i = 0; i < enic->rq_count; i++) {\n\t\terr = vnic_rq_alloc(enic->vdev, &enic->rq[i], i,\n\t\t\tenic->config.rq_desc_count,\n\t\t\tsizeof(struct rq_enet_desc));\n\t\tif (err)\n\t\t\tgoto err_out_cleanup;\n\t}\n\n\tfor (i = 0; i < enic->cq_count; i++) {\n\t\tif (i < enic->rq_count)\n\t\t\terr = vnic_cq_alloc(enic->vdev, &enic->cq[i], i,\n\t\t\t\tenic->config.rq_desc_count,\n\t\t\t\tsizeof(struct cq_enet_rq_desc));\n\t\telse\n\t\t\terr = vnic_cq_alloc(enic->vdev, &enic->cq[i], i,\n\t\t\t\tenic->config.wq_desc_count,\n\t\t\t\tsizeof(struct cq_enet_wq_desc));\n\t\tif (err)\n\t\t\tgoto err_out_cleanup;\n\t}\n\n\tfor (i = 0; i < enic->intr_count; i++) {\n\t\terr = vnic_intr_alloc(enic->vdev, &enic->intr[i], i);\n\t\tif (err)\n\t\t\tgoto err_out_cleanup;\n\t}\n\n\t \n\n\tenic->legacy_pba = vnic_dev_get_res(enic->vdev,\n\t\tRES_TYPE_INTR_PBA_LEGACY, 0);\n\tif (!enic->legacy_pba && intr_mode == VNIC_DEV_INTR_MODE_INTX) {\n\t\tdev_err(enic_get_dev(enic),\n\t\t\t\"Failed to hook legacy pba resource\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_out_cleanup;\n\t}\n\n\treturn 0;\n\nerr_out_cleanup:\n\tenic_free_vnic_resources(enic);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}