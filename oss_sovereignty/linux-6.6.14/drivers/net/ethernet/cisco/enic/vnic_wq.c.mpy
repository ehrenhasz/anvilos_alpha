{
  "module_name": "vnic_wq.c",
  "hash_id": "23968e3cc024551942a6672323bcdc3c48bce905763fee5fa9b0114292e84a3b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cisco/enic/vnic_wq.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n\n#include \"vnic_dev.h\"\n#include \"vnic_wq.h\"\n#include \"enic.h\"\n\nstatic int vnic_wq_alloc_bufs(struct vnic_wq *wq)\n{\n\tstruct vnic_wq_buf *buf;\n\tunsigned int i, j, count = wq->ring.desc_count;\n\tunsigned int blks = VNIC_WQ_BUF_BLKS_NEEDED(count);\n\n\tfor (i = 0; i < blks; i++) {\n\t\twq->bufs[i] = kzalloc(VNIC_WQ_BUF_BLK_SZ(count), GFP_KERNEL);\n\t\tif (!wq->bufs[i])\n\t\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < blks; i++) {\n\t\tbuf = wq->bufs[i];\n\t\tfor (j = 0; j < VNIC_WQ_BUF_BLK_ENTRIES(count); j++) {\n\t\t\tbuf->index = i * VNIC_WQ_BUF_BLK_ENTRIES(count) + j;\n\t\t\tbuf->desc = (u8 *)wq->ring.descs +\n\t\t\t\twq->ring.desc_size * buf->index;\n\t\t\tif (buf->index + 1 == count) {\n\t\t\t\tbuf->next = wq->bufs[0];\n\t\t\t\tbuf->next->prev = buf;\n\t\t\t\tbreak;\n\t\t\t} else if (j + 1 == VNIC_WQ_BUF_BLK_ENTRIES(count)) {\n\t\t\t\tbuf->next = wq->bufs[i + 1];\n\t\t\t\tbuf->next->prev = buf;\n\t\t\t} else {\n\t\t\t\tbuf->next = buf + 1;\n\t\t\t\tbuf->next->prev = buf;\n\t\t\t\tbuf++;\n\t\t\t}\n\t\t}\n\t}\n\n\twq->to_use = wq->to_clean = wq->bufs[0];\n\n\treturn 0;\n}\n\nvoid vnic_wq_free(struct vnic_wq *wq)\n{\n\tstruct vnic_dev *vdev;\n\tunsigned int i;\n\n\tvdev = wq->vdev;\n\n\tvnic_dev_free_desc_ring(vdev, &wq->ring);\n\n\tfor (i = 0; i < VNIC_WQ_BUF_BLKS_MAX; i++) {\n\t\tif (wq->bufs[i]) {\n\t\t\tkfree(wq->bufs[i]);\n\t\t\twq->bufs[i] = NULL;\n\t\t}\n\t}\n\n\twq->ctrl = NULL;\n}\n\nint vnic_wq_alloc(struct vnic_dev *vdev, struct vnic_wq *wq, unsigned int index,\n\tunsigned int desc_count, unsigned int desc_size)\n{\n\tint err;\n\n\twq->index = index;\n\twq->vdev = vdev;\n\n\twq->ctrl = vnic_dev_get_res(vdev, RES_TYPE_WQ, index);\n\tif (!wq->ctrl) {\n\t\tvdev_err(vdev, \"Failed to hook WQ[%d] resource\\n\", index);\n\t\treturn -EINVAL;\n\t}\n\n\tvnic_wq_disable(wq);\n\n\terr = vnic_dev_alloc_desc_ring(vdev, &wq->ring, desc_count, desc_size);\n\tif (err)\n\t\treturn err;\n\n\terr = vnic_wq_alloc_bufs(wq);\n\tif (err) {\n\t\tvnic_wq_free(wq);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint enic_wq_devcmd2_alloc(struct vnic_dev *vdev, struct vnic_wq *wq,\n\t\t\t  unsigned int desc_count, unsigned int desc_size)\n{\n\tint err;\n\n\twq->index = 0;\n\twq->vdev = vdev;\n\n\twq->ctrl = vnic_dev_get_res(vdev, RES_TYPE_DEVCMD2, 0);\n\tif (!wq->ctrl)\n\t\treturn -EINVAL;\n\tvnic_wq_disable(wq);\n\terr = vnic_dev_alloc_desc_ring(vdev, &wq->ring, desc_count, desc_size);\n\n\treturn err;\n}\n\nvoid enic_wq_init_start(struct vnic_wq *wq, unsigned int cq_index,\n\t\t\tunsigned int fetch_index, unsigned int posted_index,\n\t\t\tunsigned int error_interrupt_enable,\n\t\t\tunsigned int error_interrupt_offset)\n{\n\tu64 paddr;\n\tunsigned int count = wq->ring.desc_count;\n\n\tpaddr = (u64)wq->ring.base_addr | VNIC_PADDR_TARGET;\n\twriteq(paddr, &wq->ctrl->ring_base);\n\tiowrite32(count, &wq->ctrl->ring_size);\n\tiowrite32(fetch_index, &wq->ctrl->fetch_index);\n\tiowrite32(posted_index, &wq->ctrl->posted_index);\n\tiowrite32(cq_index, &wq->ctrl->cq_index);\n\tiowrite32(error_interrupt_enable, &wq->ctrl->error_interrupt_enable);\n\tiowrite32(error_interrupt_offset, &wq->ctrl->error_interrupt_offset);\n\tiowrite32(0, &wq->ctrl->error_status);\n\n\twq->to_use = wq->to_clean =\n\t\t&wq->bufs[fetch_index / VNIC_WQ_BUF_BLK_ENTRIES(count)]\n\t\t\t[fetch_index % VNIC_WQ_BUF_BLK_ENTRIES(count)];\n}\n\nvoid vnic_wq_init(struct vnic_wq *wq, unsigned int cq_index,\n\tunsigned int error_interrupt_enable,\n\tunsigned int error_interrupt_offset)\n{\n\tenic_wq_init_start(wq, cq_index, 0, 0,\n\t\terror_interrupt_enable,\n\t\terror_interrupt_offset);\n}\n\nunsigned int vnic_wq_error_status(struct vnic_wq *wq)\n{\n\treturn ioread32(&wq->ctrl->error_status);\n}\n\nvoid vnic_wq_enable(struct vnic_wq *wq)\n{\n\tiowrite32(1, &wq->ctrl->enable);\n}\n\nint vnic_wq_disable(struct vnic_wq *wq)\n{\n\tunsigned int wait;\n\tstruct vnic_dev *vdev = wq->vdev;\n\n\tiowrite32(0, &wq->ctrl->enable);\n\n\t \n\tfor (wait = 0; wait < 1000; wait++) {\n\t\tif (!(ioread32(&wq->ctrl->running)))\n\t\t\treturn 0;\n\t\tudelay(10);\n\t}\n\n\tvdev_neterr(vdev, \"Failed to disable WQ[%d]\\n\", wq->index);\n\n\treturn -ETIMEDOUT;\n}\n\nvoid vnic_wq_clean(struct vnic_wq *wq,\n\tvoid (*buf_clean)(struct vnic_wq *wq, struct vnic_wq_buf *buf))\n{\n\tstruct vnic_wq_buf *buf;\n\n\tbuf = wq->to_clean;\n\n\twhile (vnic_wq_desc_used(wq) > 0) {\n\n\t\t(*buf_clean)(wq, buf);\n\n\t\tbuf = wq->to_clean = buf->next;\n\t\twq->ring.desc_avail++;\n\t}\n\n\twq->to_use = wq->to_clean = wq->bufs[0];\n\n\tiowrite32(0, &wq->ctrl->fetch_index);\n\tiowrite32(0, &wq->ctrl->posted_index);\n\tiowrite32(0, &wq->ctrl->error_status);\n\n\tvnic_dev_clear_desc_ring(&wq->ring);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}