{
  "module_name": "enic_clsf.c",
  "hash_id": "d676ab01c1279f668284ffb3d5dde8d7d8581db283c76c728586a65c16cfd62a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cisco/enic/enic_clsf.c",
  "human_readable_source": "\n#include <linux/if.h>\n#include <linux/if_ether.h>\n#include <linux/if_link.h>\n#include <linux/netdevice.h>\n#include <linux/in.h>\n#include <linux/types.h>\n#include <linux/skbuff.h>\n#include <net/flow_dissector.h>\n#include \"enic_res.h\"\n#include \"enic_clsf.h\"\n\n \nint enic_addfltr_5t(struct enic *enic, struct flow_keys *keys, u16 rq)\n{\n\tint res;\n\tstruct filter data;\n\n\tswitch (keys->basic.ip_proto) {\n\tcase IPPROTO_TCP:\n\t\tdata.u.ipv4.protocol = PROTO_TCP;\n\t\tbreak;\n\tcase IPPROTO_UDP:\n\t\tdata.u.ipv4.protocol = PROTO_UDP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EPROTONOSUPPORT;\n\t}\n\n\tdata.type = FILTER_IPV4_5TUPLE;\n\tdata.u.ipv4.src_addr = ntohl(keys->addrs.v4addrs.src);\n\tdata.u.ipv4.dst_addr = ntohl(keys->addrs.v4addrs.dst);\n\tdata.u.ipv4.src_port = ntohs(keys->ports.src);\n\tdata.u.ipv4.dst_port = ntohs(keys->ports.dst);\n\tdata.u.ipv4.flags = FILTER_FIELDS_IPV4_5TUPLE;\n\n\tspin_lock_bh(&enic->devcmd_lock);\n\tres = vnic_dev_classifier(enic->vdev, CLSF_ADD, &rq, &data);\n\tspin_unlock_bh(&enic->devcmd_lock);\n\tres = (res == 0) ? rq : res;\n\n\treturn res;\n}\n\n \nint enic_delfltr(struct enic *enic, u16 filter_id)\n{\n\tint ret;\n\n\tspin_lock_bh(&enic->devcmd_lock);\n\tret = vnic_dev_classifier(enic->vdev, CLSF_DEL, &filter_id, NULL);\n\tspin_unlock_bh(&enic->devcmd_lock);\n\n\treturn ret;\n}\n\n \nvoid enic_rfs_flw_tbl_init(struct enic *enic)\n{\n\tint i;\n\n\tspin_lock_init(&enic->rfs_h.lock);\n\tfor (i = 0; i <= ENIC_RFS_FLW_MASK; i++)\n\t\tINIT_HLIST_HEAD(&enic->rfs_h.ht_head[i]);\n\tenic->rfs_h.max = enic->config.num_arfs;\n\tenic->rfs_h.free = enic->rfs_h.max;\n\tenic->rfs_h.toclean = 0;\n}\n\nvoid enic_rfs_flw_tbl_free(struct enic *enic)\n{\n\tint i;\n\n\tenic_rfs_timer_stop(enic);\n\tspin_lock_bh(&enic->rfs_h.lock);\n\tfor (i = 0; i < (1 << ENIC_RFS_FLW_BITSHIFT); i++) {\n\t\tstruct hlist_head *hhead;\n\t\tstruct hlist_node *tmp;\n\t\tstruct enic_rfs_fltr_node *n;\n\n\t\thhead = &enic->rfs_h.ht_head[i];\n\t\thlist_for_each_entry_safe(n, tmp, hhead, node) {\n\t\t\tenic_delfltr(enic, n->fltr_id);\n\t\t\thlist_del(&n->node);\n\t\t\tkfree(n);\n\t\t\tenic->rfs_h.free++;\n\t\t}\n\t}\n\tspin_unlock_bh(&enic->rfs_h.lock);\n}\n\nstruct enic_rfs_fltr_node *htbl_fltr_search(struct enic *enic, u16 fltr_id)\n{\n\tint i;\n\n\tfor (i = 0; i < (1 << ENIC_RFS_FLW_BITSHIFT); i++) {\n\t\tstruct hlist_head *hhead;\n\t\tstruct hlist_node *tmp;\n\t\tstruct enic_rfs_fltr_node *n;\n\n\t\thhead = &enic->rfs_h.ht_head[i];\n\t\thlist_for_each_entry_safe(n, tmp, hhead, node)\n\t\t\tif (n->fltr_id == fltr_id)\n\t\t\t\treturn n;\n\t}\n\n\treturn NULL;\n}\n\n#ifdef CONFIG_RFS_ACCEL\nvoid enic_flow_may_expire(struct timer_list *t)\n{\n\tstruct enic *enic = from_timer(enic, t, rfs_h.rfs_may_expire);\n\tbool res;\n\tint j;\n\n\tspin_lock_bh(&enic->rfs_h.lock);\n\tfor (j = 0; j < ENIC_CLSF_EXPIRE_COUNT; j++) {\n\t\tstruct hlist_head *hhead;\n\t\tstruct hlist_node *tmp;\n\t\tstruct enic_rfs_fltr_node *n;\n\n\t\thhead = &enic->rfs_h.ht_head[enic->rfs_h.toclean++];\n\t\thlist_for_each_entry_safe(n, tmp, hhead, node) {\n\t\t\tres = rps_may_expire_flow(enic->netdev, n->rq_id,\n\t\t\t\t\t\t  n->flow_id, n->fltr_id);\n\t\t\tif (res) {\n\t\t\t\tres = enic_delfltr(enic, n->fltr_id);\n\t\t\t\tif (unlikely(res))\n\t\t\t\t\tcontinue;\n\t\t\t\thlist_del(&n->node);\n\t\t\t\tkfree(n);\n\t\t\t\tenic->rfs_h.free++;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_bh(&enic->rfs_h.lock);\n\tmod_timer(&enic->rfs_h.rfs_may_expire, jiffies + HZ/4);\n}\n\nstatic struct enic_rfs_fltr_node *htbl_key_search(struct hlist_head *h,\n\t\t\t\t\t\t  struct flow_keys *k)\n{\n\tstruct enic_rfs_fltr_node *tpos;\n\n\thlist_for_each_entry(tpos, h, node)\n\t\tif (tpos->keys.addrs.v4addrs.src == k->addrs.v4addrs.src &&\n\t\t    tpos->keys.addrs.v4addrs.dst == k->addrs.v4addrs.dst &&\n\t\t    tpos->keys.ports.ports == k->ports.ports &&\n\t\t    tpos->keys.basic.ip_proto == k->basic.ip_proto &&\n\t\t    tpos->keys.basic.n_proto == k->basic.n_proto)\n\t\t\treturn tpos;\n\treturn NULL;\n}\n\nint enic_rx_flow_steer(struct net_device *dev, const struct sk_buff *skb,\n\t\t       u16 rxq_index, u32 flow_id)\n{\n\tstruct flow_keys keys;\n\tstruct enic_rfs_fltr_node *n;\n\tstruct enic *enic;\n\tu16 tbl_idx;\n\tint res, i;\n\n\tenic = netdev_priv(dev);\n\tres = skb_flow_dissect_flow_keys(skb, &keys, 0);\n\tif (!res || keys.basic.n_proto != htons(ETH_P_IP) ||\n\t    (keys.basic.ip_proto != IPPROTO_TCP &&\n\t     keys.basic.ip_proto != IPPROTO_UDP))\n\t\treturn -EPROTONOSUPPORT;\n\n\ttbl_idx = skb_get_hash_raw(skb) & ENIC_RFS_FLW_MASK;\n\tspin_lock_bh(&enic->rfs_h.lock);\n\tn = htbl_key_search(&enic->rfs_h.ht_head[tbl_idx], &keys);\n\n\tif (n) {  \n\t\tif (rxq_index == n->rq_id) {\n\t\t\tres = -EEXIST;\n\t\t\tgoto ret_unlock;\n\t\t}\n\n\t\t \n\t\ti = --enic->rfs_h.free;\n\t\t \n\t\tif (unlikely(i < 0)) {\n\t\t\tenic->rfs_h.free++;\n\t\t\tres = enic_delfltr(enic, n->fltr_id);\n\t\t\tif (unlikely(res < 0))\n\t\t\t\tgoto ret_unlock;\n\t\t\tres = enic_addfltr_5t(enic, &keys, rxq_index);\n\t\t\tif (res < 0) {\n\t\t\t\thlist_del(&n->node);\n\t\t\t\tenic->rfs_h.free++;\n\t\t\t\tgoto ret_unlock;\n\t\t\t}\n\t\t \n\t\t} else {\n\t\t\tint ret;\n\n\t\t\tres = enic_addfltr_5t(enic, &keys, rxq_index);\n\t\t\tif (res < 0) {\n\t\t\t\tenic->rfs_h.free++;\n\t\t\t\tgoto ret_unlock;\n\t\t\t}\n\t\t\tret = enic_delfltr(enic, n->fltr_id);\n\t\t\t \n\t\t\tif (unlikely(ret < 0)) {\n\t\t\t\tstruct enic_rfs_fltr_node *d;\n\t\t\t\tstruct hlist_head *head;\n\n\t\t\t\thead = &enic->rfs_h.ht_head[tbl_idx];\n\t\t\t\td = kmalloc(sizeof(*d), GFP_ATOMIC);\n\t\t\t\tif (d) {\n\t\t\t\t\td->fltr_id = n->fltr_id;\n\t\t\t\t\tINIT_HLIST_NODE(&d->node);\n\t\t\t\t\thlist_add_head(&d->node, head);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tenic->rfs_h.free++;\n\t\t\t}\n\t\t}\n\t\tn->rq_id = rxq_index;\n\t\tn->fltr_id = res;\n\t\tn->flow_id = flow_id;\n\t \n\t} else {\n\t\ti = --enic->rfs_h.free;\n\t\tif (i <= 0) {\n\t\t\tenic->rfs_h.free++;\n\t\t\tres = -EBUSY;\n\t\t\tgoto ret_unlock;\n\t\t}\n\n\t\tn = kmalloc(sizeof(*n), GFP_ATOMIC);\n\t\tif (!n) {\n\t\t\tres = -ENOMEM;\n\t\t\tenic->rfs_h.free++;\n\t\t\tgoto ret_unlock;\n\t\t}\n\n\t\tres = enic_addfltr_5t(enic, &keys, rxq_index);\n\t\tif (res < 0) {\n\t\t\tkfree(n);\n\t\t\tenic->rfs_h.free++;\n\t\t\tgoto ret_unlock;\n\t\t}\n\t\tn->rq_id = rxq_index;\n\t\tn->fltr_id = res;\n\t\tn->flow_id = flow_id;\n\t\tn->keys = keys;\n\t\tINIT_HLIST_NODE(&n->node);\n\t\thlist_add_head(&n->node, &enic->rfs_h.ht_head[tbl_idx]);\n\t}\n\nret_unlock:\n\tspin_unlock_bh(&enic->rfs_h.lock);\n\treturn res;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}