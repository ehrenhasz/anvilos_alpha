{
  "module_name": "vnic_dev.c",
  "hash_id": "6a527bb00ab6c99f6d92a03c59066c67783fe30e5e5a17118dba5458ced6e299",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cisco/enic/vnic_dev.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/if_ether.h>\n\n#include \"vnic_resource.h\"\n#include \"vnic_devcmd.h\"\n#include \"vnic_dev.h\"\n#include \"vnic_wq.h\"\n#include \"vnic_stats.h\"\n#include \"enic.h\"\n\n#define VNIC_MAX_RES_HDR_SIZE \\\n\t(sizeof(struct vnic_resource_header) + \\\n\tsizeof(struct vnic_resource) * RES_TYPE_MAX)\n#define VNIC_RES_STRIDE\t128\n\nvoid *vnic_dev_priv(struct vnic_dev *vdev)\n{\n\treturn vdev->priv;\n}\n\nstatic int vnic_dev_discover_res(struct vnic_dev *vdev,\n\tstruct vnic_dev_bar *bar, unsigned int num_bars)\n{\n\tstruct vnic_resource_header __iomem *rh;\n\tstruct mgmt_barmap_hdr __iomem *mrh;\n\tstruct vnic_resource __iomem *r;\n\tu8 type;\n\n\tif (num_bars == 0)\n\t\treturn -EINVAL;\n\n\tif (bar->len < VNIC_MAX_RES_HDR_SIZE) {\n\t\tvdev_err(vdev, \"vNIC BAR0 res hdr length error\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trh  = bar->vaddr;\n\tmrh = bar->vaddr;\n\tif (!rh) {\n\t\tvdev_err(vdev, \"vNIC BAR0 res hdr not mem-mapped\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((ioread32(&rh->magic) != VNIC_RES_MAGIC) ||\n\t\t(ioread32(&rh->version) != VNIC_RES_VERSION)) {\n\t\tif ((ioread32(&mrh->magic) != MGMTVNIC_MAGIC) ||\n\t\t\t(ioread32(&mrh->version) != MGMTVNIC_VERSION)) {\n\t\t\tvdev_err(vdev, \"vNIC BAR0 res magic/version error exp (%lx/%lx) or (%lx/%lx), curr (%x/%x)\\n\",\n\t\t\t\t VNIC_RES_MAGIC, VNIC_RES_VERSION,\n\t\t\t\t MGMTVNIC_MAGIC, MGMTVNIC_VERSION,\n\t\t\t\t ioread32(&rh->magic), ioread32(&rh->version));\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (ioread32(&mrh->magic) == MGMTVNIC_MAGIC)\n\t\tr = (struct vnic_resource __iomem *)(mrh + 1);\n\telse\n\t\tr = (struct vnic_resource __iomem *)(rh + 1);\n\n\n\twhile ((type = ioread8(&r->type)) != RES_TYPE_EOL) {\n\n\t\tu8 bar_num = ioread8(&r->bar);\n\t\tu32 bar_offset = ioread32(&r->bar_offset);\n\t\tu32 count = ioread32(&r->count);\n\t\tu32 len;\n\n\t\tr++;\n\n\t\tif (bar_num >= num_bars)\n\t\t\tcontinue;\n\n\t\tif (!bar[bar_num].len || !bar[bar_num].vaddr)\n\t\t\tcontinue;\n\n\t\tswitch (type) {\n\t\tcase RES_TYPE_WQ:\n\t\tcase RES_TYPE_RQ:\n\t\tcase RES_TYPE_CQ:\n\t\tcase RES_TYPE_INTR_CTRL:\n\t\t\t \n\t\t\tlen = count * VNIC_RES_STRIDE;\n\t\t\tif (len + bar_offset > bar[bar_num].len) {\n\t\t\t\tvdev_err(vdev, \"vNIC BAR0 resource %d out-of-bounds, offset 0x%x + size 0x%x > bar len 0x%lx\\n\",\n\t\t\t\t\t type, bar_offset, len,\n\t\t\t\t\t bar[bar_num].len);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase RES_TYPE_INTR_PBA_LEGACY:\n\t\tcase RES_TYPE_DEVCMD:\n\t\tcase RES_TYPE_DEVCMD2:\n\t\t\tlen = count;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tvdev->res[type].count = count;\n\t\tvdev->res[type].vaddr = (char __iomem *)bar[bar_num].vaddr +\n\t\t\tbar_offset;\n\t\tvdev->res[type].bus_addr = bar[bar_num].bus_addr + bar_offset;\n\t}\n\n\treturn 0;\n}\n\nunsigned int vnic_dev_get_res_count(struct vnic_dev *vdev,\n\tenum vnic_res_type type)\n{\n\treturn vdev->res[type].count;\n}\nEXPORT_SYMBOL(vnic_dev_get_res_count);\n\nvoid __iomem *vnic_dev_get_res(struct vnic_dev *vdev, enum vnic_res_type type,\n\tunsigned int index)\n{\n\tif (!vdev->res[type].vaddr)\n\t\treturn NULL;\n\n\tswitch (type) {\n\tcase RES_TYPE_WQ:\n\tcase RES_TYPE_RQ:\n\tcase RES_TYPE_CQ:\n\tcase RES_TYPE_INTR_CTRL:\n\t\treturn (char __iomem *)vdev->res[type].vaddr +\n\t\t\tindex * VNIC_RES_STRIDE;\n\tdefault:\n\t\treturn (char __iomem *)vdev->res[type].vaddr;\n\t}\n}\nEXPORT_SYMBOL(vnic_dev_get_res);\n\nstatic unsigned int vnic_dev_desc_ring_size(struct vnic_dev_ring *ring,\n\tunsigned int desc_count, unsigned int desc_size)\n{\n\t \n\n\tunsigned int count_align = 32;\n\tunsigned int desc_align = 16;\n\n\tring->base_align = 512;\n\n\tif (desc_count == 0)\n\t\tdesc_count = 4096;\n\n\tring->desc_count = ALIGN(desc_count, count_align);\n\n\tring->desc_size = ALIGN(desc_size, desc_align);\n\n\tring->size = ring->desc_count * ring->desc_size;\n\tring->size_unaligned = ring->size + ring->base_align;\n\n\treturn ring->size_unaligned;\n}\n\nvoid vnic_dev_clear_desc_ring(struct vnic_dev_ring *ring)\n{\n\tmemset(ring->descs, 0, ring->size);\n}\n\nint vnic_dev_alloc_desc_ring(struct vnic_dev *vdev, struct vnic_dev_ring *ring,\n\tunsigned int desc_count, unsigned int desc_size)\n{\n\tvnic_dev_desc_ring_size(ring, desc_count, desc_size);\n\n\tring->descs_unaligned = dma_alloc_coherent(&vdev->pdev->dev,\n\t\t\t\t\t\t   ring->size_unaligned,\n\t\t\t\t\t\t   &ring->base_addr_unaligned,\n\t\t\t\t\t\t   GFP_KERNEL);\n\n\tif (!ring->descs_unaligned) {\n\t\tvdev_err(vdev, \"Failed to allocate ring (size=%d), aborting\\n\",\n\t\t\t (int)ring->size);\n\t\treturn -ENOMEM;\n\t}\n\n\tring->base_addr = ALIGN(ring->base_addr_unaligned,\n\t\tring->base_align);\n\tring->descs = (u8 *)ring->descs_unaligned +\n\t\t(ring->base_addr - ring->base_addr_unaligned);\n\n\tvnic_dev_clear_desc_ring(ring);\n\n\tring->desc_avail = ring->desc_count - 1;\n\n\treturn 0;\n}\n\nvoid vnic_dev_free_desc_ring(struct vnic_dev *vdev, struct vnic_dev_ring *ring)\n{\n\tif (ring->descs) {\n\t\tdma_free_coherent(&vdev->pdev->dev, ring->size_unaligned,\n\t\t\t\t  ring->descs_unaligned,\n\t\t\t\t  ring->base_addr_unaligned);\n\t\tring->descs = NULL;\n\t}\n}\n\nstatic int _vnic_dev_cmd(struct vnic_dev *vdev, enum vnic_devcmd_cmd cmd,\n\tint wait)\n{\n\tstruct vnic_devcmd __iomem *devcmd = vdev->devcmd;\n\tunsigned int i;\n\tint delay;\n\tu32 status;\n\tint err;\n\n\tstatus = ioread32(&devcmd->status);\n\tif (status == 0xFFFFFFFF) {\n\t\t \n\t\treturn -ENODEV;\n\t}\n\tif (status & STAT_BUSY) {\n\t\tvdev_neterr(vdev, \"Busy devcmd %d\\n\", _CMD_N(cmd));\n\t\treturn -EBUSY;\n\t}\n\n\tif (_CMD_DIR(cmd) & _CMD_DIR_WRITE) {\n\t\tfor (i = 0; i < VNIC_DEVCMD_NARGS; i++)\n\t\t\twriteq(vdev->args[i], &devcmd->args[i]);\n\t\twmb();\n\t}\n\n\tiowrite32(cmd, &devcmd->cmd);\n\n\tif ((_CMD_FLAGS(cmd) & _CMD_FLAGS_NOWAIT))\n\t\treturn 0;\n\n\tfor (delay = 0; delay < wait; delay++) {\n\n\t\tudelay(100);\n\n\t\tstatus = ioread32(&devcmd->status);\n\t\tif (status == 0xFFFFFFFF) {\n\t\t\t \n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tif (!(status & STAT_BUSY)) {\n\n\t\t\tif (status & STAT_ERROR) {\n\t\t\t\terr = (int)readq(&devcmd->args[0]);\n\t\t\t\tif (err == ERR_EINVAL &&\n\t\t\t\t    cmd == CMD_CAPABILITY)\n\t\t\t\t\treturn -err;\n\t\t\t\tif (err != ERR_ECMDUNKNOWN ||\n\t\t\t\t    cmd != CMD_CAPABILITY)\n\t\t\t\t\tvdev_neterr(vdev, \"Error %d devcmd %d\\n\",\n\t\t\t\t\t\t    err, _CMD_N(cmd));\n\t\t\t\treturn -err;\n\t\t\t}\n\n\t\t\tif (_CMD_DIR(cmd) & _CMD_DIR_READ) {\n\t\t\t\trmb();\n\t\t\t\tfor (i = 0; i < VNIC_DEVCMD_NARGS; i++)\n\t\t\t\t\tvdev->args[i] = readq(&devcmd->args[i]);\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvdev_neterr(vdev, \"Timedout devcmd %d\\n\", _CMD_N(cmd));\n\treturn -ETIMEDOUT;\n}\n\nstatic int _vnic_dev_cmd2(struct vnic_dev *vdev, enum vnic_devcmd_cmd cmd,\n\t\t\t  int wait)\n{\n\tstruct devcmd2_controller *dc2c = vdev->devcmd2;\n\tstruct devcmd2_result *result;\n\tu8 color;\n\tunsigned int i;\n\tint delay, err;\n\tu32 fetch_index, new_posted;\n\tu32 posted = dc2c->posted;\n\n\tfetch_index = ioread32(&dc2c->wq_ctrl->fetch_index);\n\n\tif (fetch_index == 0xFFFFFFFF)\n\t\treturn -ENODEV;\n\n\tnew_posted = (posted + 1) % DEVCMD2_RING_SIZE;\n\n\tif (new_posted == fetch_index) {\n\t\tvdev_neterr(vdev, \"devcmd2 %d: wq is full. fetch index: %u, posted index: %u\\n\",\n\t\t\t    _CMD_N(cmd), fetch_index, posted);\n\t\treturn -EBUSY;\n\t}\n\tdc2c->cmd_ring[posted].cmd = cmd;\n\tdc2c->cmd_ring[posted].flags = 0;\n\n\tif ((_CMD_FLAGS(cmd) & _CMD_FLAGS_NOWAIT))\n\t\tdc2c->cmd_ring[posted].flags |= DEVCMD2_FNORESULT;\n\tif (_CMD_DIR(cmd) & _CMD_DIR_WRITE)\n\t\tfor (i = 0; i < VNIC_DEVCMD_NARGS; i++)\n\t\t\tdc2c->cmd_ring[posted].args[i] = vdev->args[i];\n\n\t \n\twmb();\n\tiowrite32(new_posted, &dc2c->wq_ctrl->posted_index);\n\tdc2c->posted = new_posted;\n\n\tif (dc2c->cmd_ring[posted].flags & DEVCMD2_FNORESULT)\n\t\treturn 0;\n\n\tresult = dc2c->result + dc2c->next_result;\n\tcolor = dc2c->color;\n\n\tdc2c->next_result++;\n\tif (dc2c->next_result == dc2c->result_size) {\n\t\tdc2c->next_result = 0;\n\t\tdc2c->color = dc2c->color ? 0 : 1;\n\t}\n\n\tfor (delay = 0; delay < wait; delay++) {\n\t\tif (result->color == color) {\n\t\t\tif (result->error) {\n\t\t\t\terr = result->error;\n\t\t\t\tif (err != ERR_ECMDUNKNOWN ||\n\t\t\t\t    cmd != CMD_CAPABILITY)\n\t\t\t\t\tvdev_neterr(vdev, \"Error %d devcmd %d\\n\",\n\t\t\t\t\t\t    err, _CMD_N(cmd));\n\t\t\t\treturn -err;\n\t\t\t}\n\t\t\tif (_CMD_DIR(cmd) & _CMD_DIR_READ)\n\t\t\t\tfor (i = 0; i < VNIC_DEVCMD2_NARGS; i++)\n\t\t\t\t\tvdev->args[i] = result->results[i];\n\n\t\t\treturn 0;\n\t\t}\n\t\tudelay(100);\n\t}\n\n\tvdev_neterr(vdev, \"devcmd %d timed out\\n\", _CMD_N(cmd));\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int vnic_dev_init_devcmd1(struct vnic_dev *vdev)\n{\n\tvdev->devcmd = vnic_dev_get_res(vdev, RES_TYPE_DEVCMD, 0);\n\tif (!vdev->devcmd)\n\t\treturn -ENODEV;\n\tvdev->devcmd_rtn = _vnic_dev_cmd;\n\n\treturn 0;\n}\n\nstatic int vnic_dev_init_devcmd2(struct vnic_dev *vdev)\n{\n\tint err;\n\tunsigned int fetch_index;\n\n\tif (vdev->devcmd2)\n\t\treturn 0;\n\n\tvdev->devcmd2 = kzalloc(sizeof(*vdev->devcmd2), GFP_KERNEL);\n\tif (!vdev->devcmd2)\n\t\treturn -ENOMEM;\n\n\tvdev->devcmd2->color = 1;\n\tvdev->devcmd2->result_size = DEVCMD2_RING_SIZE;\n\terr = enic_wq_devcmd2_alloc(vdev, &vdev->devcmd2->wq, DEVCMD2_RING_SIZE,\n\t\t\t\t    DEVCMD2_DESC_SIZE);\n\tif (err)\n\t\tgoto err_free_devcmd2;\n\n\tfetch_index = ioread32(&vdev->devcmd2->wq.ctrl->fetch_index);\n\tif (fetch_index == 0xFFFFFFFF) {  \n\t\tvdev_err(vdev, \"Fatal error in devcmd2 init - hardware surprise removal\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_free_wq;\n\t}\n\n\tenic_wq_init_start(&vdev->devcmd2->wq, 0, fetch_index, fetch_index, 0,\n\t\t\t   0);\n\tvdev->devcmd2->posted = fetch_index;\n\tvnic_wq_enable(&vdev->devcmd2->wq);\n\n\terr = vnic_dev_alloc_desc_ring(vdev, &vdev->devcmd2->results_ring,\n\t\t\t\t       DEVCMD2_RING_SIZE, DEVCMD2_DESC_SIZE);\n\tif (err)\n\t\tgoto err_disable_wq;\n\n\tvdev->devcmd2->result = vdev->devcmd2->results_ring.descs;\n\tvdev->devcmd2->cmd_ring = vdev->devcmd2->wq.ring.descs;\n\tvdev->devcmd2->wq_ctrl = vdev->devcmd2->wq.ctrl;\n\tvdev->args[0] = (u64)vdev->devcmd2->results_ring.base_addr |\n\t\t\tVNIC_PADDR_TARGET;\n\tvdev->args[1] = DEVCMD2_RING_SIZE;\n\n\terr = _vnic_dev_cmd2(vdev, CMD_INITIALIZE_DEVCMD2, 1000);\n\tif (err)\n\t\tgoto err_free_desc_ring;\n\n\tvdev->devcmd_rtn = _vnic_dev_cmd2;\n\n\treturn 0;\n\nerr_free_desc_ring:\n\tvnic_dev_free_desc_ring(vdev, &vdev->devcmd2->results_ring);\nerr_disable_wq:\n\tvnic_wq_disable(&vdev->devcmd2->wq);\nerr_free_wq:\n\tvnic_wq_free(&vdev->devcmd2->wq);\nerr_free_devcmd2:\n\tkfree(vdev->devcmd2);\n\tvdev->devcmd2 = NULL;\n\n\treturn err;\n}\n\nstatic void vnic_dev_deinit_devcmd2(struct vnic_dev *vdev)\n{\n\tvnic_dev_free_desc_ring(vdev, &vdev->devcmd2->results_ring);\n\tvnic_wq_disable(&vdev->devcmd2->wq);\n\tvnic_wq_free(&vdev->devcmd2->wq);\n\tkfree(vdev->devcmd2);\n}\n\nstatic int vnic_dev_cmd_proxy(struct vnic_dev *vdev,\n\tenum vnic_devcmd_cmd proxy_cmd, enum vnic_devcmd_cmd cmd,\n\tu64 *a0, u64 *a1, int wait)\n{\n\tu32 status;\n\tint err;\n\n\tmemset(vdev->args, 0, sizeof(vdev->args));\n\n\tvdev->args[0] = vdev->proxy_index;\n\tvdev->args[1] = cmd;\n\tvdev->args[2] = *a0;\n\tvdev->args[3] = *a1;\n\n\terr = vdev->devcmd_rtn(vdev, proxy_cmd, wait);\n\tif (err)\n\t\treturn err;\n\n\tstatus = (u32)vdev->args[0];\n\tif (status & STAT_ERROR) {\n\t\terr = (int)vdev->args[1];\n\t\tif (err != ERR_ECMDUNKNOWN ||\n\t\t    cmd != CMD_CAPABILITY)\n\t\t\tvdev_neterr(vdev, \"Error %d proxy devcmd %d\\n\",\n\t\t\t\t    err, _CMD_N(cmd));\n\t\treturn err;\n\t}\n\n\t*a0 = vdev->args[1];\n\t*a1 = vdev->args[2];\n\n\treturn 0;\n}\n\nstatic int vnic_dev_cmd_no_proxy(struct vnic_dev *vdev,\n\tenum vnic_devcmd_cmd cmd, u64 *a0, u64 *a1, int wait)\n{\n\tint err;\n\n\tvdev->args[0] = *a0;\n\tvdev->args[1] = *a1;\n\n\terr = vdev->devcmd_rtn(vdev, cmd, wait);\n\n\t*a0 = vdev->args[0];\n\t*a1 = vdev->args[1];\n\n\treturn err;\n}\n\nvoid vnic_dev_cmd_proxy_by_index_start(struct vnic_dev *vdev, u16 index)\n{\n\tvdev->proxy = PROXY_BY_INDEX;\n\tvdev->proxy_index = index;\n}\n\nvoid vnic_dev_cmd_proxy_end(struct vnic_dev *vdev)\n{\n\tvdev->proxy = PROXY_NONE;\n\tvdev->proxy_index = 0;\n}\n\nint vnic_dev_cmd(struct vnic_dev *vdev, enum vnic_devcmd_cmd cmd,\n\tu64 *a0, u64 *a1, int wait)\n{\n\tmemset(vdev->args, 0, sizeof(vdev->args));\n\n\tswitch (vdev->proxy) {\n\tcase PROXY_BY_INDEX:\n\t\treturn vnic_dev_cmd_proxy(vdev, CMD_PROXY_BY_INDEX, cmd,\n\t\t\t\ta0, a1, wait);\n\tcase PROXY_BY_BDF:\n\t\treturn vnic_dev_cmd_proxy(vdev, CMD_PROXY_BY_BDF, cmd,\n\t\t\t\ta0, a1, wait);\n\tcase PROXY_NONE:\n\tdefault:\n\t\treturn vnic_dev_cmd_no_proxy(vdev, cmd, a0, a1, wait);\n\t}\n}\n\nstatic int vnic_dev_capable(struct vnic_dev *vdev, enum vnic_devcmd_cmd cmd)\n{\n\tu64 a0 = (u32)cmd, a1 = 0;\n\tint wait = 1000;\n\tint err;\n\n\terr = vnic_dev_cmd(vdev, CMD_CAPABILITY, &a0, &a1, wait);\n\n\treturn !(err || a0);\n}\n\nint vnic_dev_fw_info(struct vnic_dev *vdev,\n\tstruct vnic_devcmd_fw_info **fw_info)\n{\n\tu64 a0, a1 = 0;\n\tint wait = 1000;\n\tint err = 0;\n\n\tif (!vdev->fw_info) {\n\t\tvdev->fw_info = dma_alloc_coherent(&vdev->pdev->dev,\n\t\t\t\t\t\t   sizeof(struct vnic_devcmd_fw_info),\n\t\t\t\t\t\t   &vdev->fw_info_pa, GFP_ATOMIC);\n\t\tif (!vdev->fw_info)\n\t\t\treturn -ENOMEM;\n\n\t\ta0 = vdev->fw_info_pa;\n\t\ta1 = sizeof(struct vnic_devcmd_fw_info);\n\n\t\t \n\t\tif (vnic_dev_capable(vdev, CMD_MCPU_FW_INFO))\n\t\t\terr = vnic_dev_cmd(vdev, CMD_MCPU_FW_INFO,\n\t\t\t\t&a0, &a1, wait);\n\t\telse\n\t\t\terr = vnic_dev_cmd(vdev, CMD_MCPU_FW_INFO_OLD,\n\t\t\t\t&a0, &a1, wait);\n\t}\n\n\t*fw_info = vdev->fw_info;\n\n\treturn err;\n}\n\nint vnic_dev_spec(struct vnic_dev *vdev, unsigned int offset, unsigned int size,\n\tvoid *value)\n{\n\tu64 a0, a1;\n\tint wait = 1000;\n\tint err;\n\n\ta0 = offset;\n\ta1 = size;\n\n\terr = vnic_dev_cmd(vdev, CMD_DEV_SPEC, &a0, &a1, wait);\n\n\tswitch (size) {\n\tcase 1: *(u8 *)value = (u8)a0; break;\n\tcase 2: *(u16 *)value = (u16)a0; break;\n\tcase 4: *(u32 *)value = (u32)a0; break;\n\tcase 8: *(u64 *)value = a0; break;\n\tdefault: BUG(); break;\n\t}\n\n\treturn err;\n}\n\nint vnic_dev_stats_dump(struct vnic_dev *vdev, struct vnic_stats **stats)\n{\n\tu64 a0, a1;\n\tint wait = 1000;\n\n\tif (!vdev->stats) {\n\t\tvdev->stats = dma_alloc_coherent(&vdev->pdev->dev,\n\t\t\t\t\t\t sizeof(struct vnic_stats),\n\t\t\t\t\t\t &vdev->stats_pa, GFP_ATOMIC);\n\t\tif (!vdev->stats)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t*stats = vdev->stats;\n\ta0 = vdev->stats_pa;\n\ta1 = sizeof(struct vnic_stats);\n\n\treturn vnic_dev_cmd(vdev, CMD_STATS_DUMP, &a0, &a1, wait);\n}\n\nint vnic_dev_close(struct vnic_dev *vdev)\n{\n\tu64 a0 = 0, a1 = 0;\n\tint wait = 1000;\n\treturn vnic_dev_cmd(vdev, CMD_CLOSE, &a0, &a1, wait);\n}\n\nint vnic_dev_enable_wait(struct vnic_dev *vdev)\n{\n\tu64 a0 = 0, a1 = 0;\n\tint wait = 1000;\n\n\tif (vnic_dev_capable(vdev, CMD_ENABLE_WAIT))\n\t\treturn vnic_dev_cmd(vdev, CMD_ENABLE_WAIT, &a0, &a1, wait);\n\telse\n\t\treturn vnic_dev_cmd(vdev, CMD_ENABLE, &a0, &a1, wait);\n}\n\nint vnic_dev_disable(struct vnic_dev *vdev)\n{\n\tu64 a0 = 0, a1 = 0;\n\tint wait = 1000;\n\treturn vnic_dev_cmd(vdev, CMD_DISABLE, &a0, &a1, wait);\n}\n\nint vnic_dev_open(struct vnic_dev *vdev, int arg)\n{\n\tu64 a0 = (u32)arg, a1 = 0;\n\tint wait = 1000;\n\treturn vnic_dev_cmd(vdev, CMD_OPEN, &a0, &a1, wait);\n}\n\nint vnic_dev_open_done(struct vnic_dev *vdev, int *done)\n{\n\tu64 a0 = 0, a1 = 0;\n\tint wait = 1000;\n\tint err;\n\n\t*done = 0;\n\n\terr = vnic_dev_cmd(vdev, CMD_OPEN_STATUS, &a0, &a1, wait);\n\tif (err)\n\t\treturn err;\n\n\t*done = (a0 == 0);\n\n\treturn 0;\n}\n\nint vnic_dev_soft_reset(struct vnic_dev *vdev, int arg)\n{\n\tu64 a0 = (u32)arg, a1 = 0;\n\tint wait = 1000;\n\treturn vnic_dev_cmd(vdev, CMD_SOFT_RESET, &a0, &a1, wait);\n}\n\nint vnic_dev_soft_reset_done(struct vnic_dev *vdev, int *done)\n{\n\tu64 a0 = 0, a1 = 0;\n\tint wait = 1000;\n\tint err;\n\n\t*done = 0;\n\n\terr = vnic_dev_cmd(vdev, CMD_SOFT_RESET_STATUS, &a0, &a1, wait);\n\tif (err)\n\t\treturn err;\n\n\t*done = (a0 == 0);\n\n\treturn 0;\n}\n\nint vnic_dev_hang_reset(struct vnic_dev *vdev, int arg)\n{\n\tu64 a0 = (u32)arg, a1 = 0;\n\tint wait = 1000;\n\tint err;\n\n\tif (vnic_dev_capable(vdev, CMD_HANG_RESET)) {\n\t\treturn vnic_dev_cmd(vdev, CMD_HANG_RESET,\n\t\t\t\t&a0, &a1, wait);\n\t} else {\n\t\terr = vnic_dev_soft_reset(vdev, arg);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn vnic_dev_init(vdev, 0);\n\t}\n}\n\nint vnic_dev_hang_reset_done(struct vnic_dev *vdev, int *done)\n{\n\tu64 a0 = 0, a1 = 0;\n\tint wait = 1000;\n\tint err;\n\n\t*done = 0;\n\n\tif (vnic_dev_capable(vdev, CMD_HANG_RESET_STATUS)) {\n\t\terr = vnic_dev_cmd(vdev, CMD_HANG_RESET_STATUS,\n\t\t\t\t&a0, &a1, wait);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\treturn vnic_dev_soft_reset_done(vdev, done);\n\t}\n\n\t*done = (a0 == 0);\n\n\treturn 0;\n}\n\nint vnic_dev_hang_notify(struct vnic_dev *vdev)\n{\n\tu64 a0, a1;\n\tint wait = 1000;\n\treturn vnic_dev_cmd(vdev, CMD_HANG_NOTIFY, &a0, &a1, wait);\n}\n\nint vnic_dev_get_mac_addr(struct vnic_dev *vdev, u8 *mac_addr)\n{\n\tu64 a0, a1;\n\tint wait = 1000;\n\tint err, i;\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tmac_addr[i] = 0;\n\n\terr = vnic_dev_cmd(vdev, CMD_GET_MAC_ADDR, &a0, &a1, wait);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tmac_addr[i] = ((u8 *)&a0)[i];\n\n\treturn 0;\n}\n\nint vnic_dev_packet_filter(struct vnic_dev *vdev, int directed, int multicast,\n\tint broadcast, int promisc, int allmulti)\n{\n\tu64 a0, a1 = 0;\n\tint wait = 1000;\n\tint err;\n\n\ta0 = (directed ? CMD_PFILTER_DIRECTED : 0) |\n\t     (multicast ? CMD_PFILTER_MULTICAST : 0) |\n\t     (broadcast ? CMD_PFILTER_BROADCAST : 0) |\n\t     (promisc ? CMD_PFILTER_PROMISCUOUS : 0) |\n\t     (allmulti ? CMD_PFILTER_ALL_MULTICAST : 0);\n\n\terr = vnic_dev_cmd(vdev, CMD_PACKET_FILTER, &a0, &a1, wait);\n\tif (err)\n\t\tvdev_neterr(vdev, \"Can't set packet filter\\n\");\n\n\treturn err;\n}\n\nint vnic_dev_add_addr(struct vnic_dev *vdev, const u8 *addr)\n{\n\tu64 a0 = 0, a1 = 0;\n\tint wait = 1000;\n\tint err;\n\tint i;\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\t((u8 *)&a0)[i] = addr[i];\n\n\terr = vnic_dev_cmd(vdev, CMD_ADDR_ADD, &a0, &a1, wait);\n\tif (err)\n\t\tvdev_neterr(vdev, \"Can't add addr [%pM], %d\\n\", addr, err);\n\n\treturn err;\n}\n\nint vnic_dev_del_addr(struct vnic_dev *vdev, const u8 *addr)\n{\n\tu64 a0 = 0, a1 = 0;\n\tint wait = 1000;\n\tint err;\n\tint i;\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\t((u8 *)&a0)[i] = addr[i];\n\n\terr = vnic_dev_cmd(vdev, CMD_ADDR_DEL, &a0, &a1, wait);\n\tif (err)\n\t\tvdev_neterr(vdev, \"Can't del addr [%pM], %d\\n\", addr, err);\n\n\treturn err;\n}\n\nint vnic_dev_set_ig_vlan_rewrite_mode(struct vnic_dev *vdev,\n\tu8 ig_vlan_rewrite_mode)\n{\n\tu64 a0 = ig_vlan_rewrite_mode, a1 = 0;\n\tint wait = 1000;\n\n\tif (vnic_dev_capable(vdev, CMD_IG_VLAN_REWRITE_MODE))\n\t\treturn vnic_dev_cmd(vdev, CMD_IG_VLAN_REWRITE_MODE,\n\t\t\t\t&a0, &a1, wait);\n\telse\n\t\treturn 0;\n}\n\nstatic int vnic_dev_notify_setcmd(struct vnic_dev *vdev,\n\tvoid *notify_addr, dma_addr_t notify_pa, u16 intr)\n{\n\tu64 a0, a1;\n\tint wait = 1000;\n\tint r;\n\n\tmemset(notify_addr, 0, sizeof(struct vnic_devcmd_notify));\n\tvdev->notify = notify_addr;\n\tvdev->notify_pa = notify_pa;\n\n\ta0 = (u64)notify_pa;\n\ta1 = ((u64)intr << 32) & 0x0000ffff00000000ULL;\n\ta1 += sizeof(struct vnic_devcmd_notify);\n\n\tr = vnic_dev_cmd(vdev, CMD_NOTIFY, &a0, &a1, wait);\n\tvdev->notify_sz = (r == 0) ? (u32)a1 : 0;\n\treturn r;\n}\n\nint vnic_dev_notify_set(struct vnic_dev *vdev, u16 intr)\n{\n\tvoid *notify_addr;\n\tdma_addr_t notify_pa;\n\n\tif (vdev->notify || vdev->notify_pa) {\n\t\tvdev_neterr(vdev, \"notify block %p still allocated\\n\",\n\t\t\t    vdev->notify);\n\t\treturn -EINVAL;\n\t}\n\n\tnotify_addr = dma_alloc_coherent(&vdev->pdev->dev,\n\t\t\t\t\t sizeof(struct vnic_devcmd_notify),\n\t\t\t\t\t &notify_pa, GFP_ATOMIC);\n\tif (!notify_addr)\n\t\treturn -ENOMEM;\n\n\treturn vnic_dev_notify_setcmd(vdev, notify_addr, notify_pa, intr);\n}\n\nstatic int vnic_dev_notify_unsetcmd(struct vnic_dev *vdev)\n{\n\tu64 a0, a1;\n\tint wait = 1000;\n\tint err;\n\n\ta0 = 0;   \n\ta1 = 0x0000ffff00000000ULL;  \n\ta1 += sizeof(struct vnic_devcmd_notify);\n\n\terr = vnic_dev_cmd(vdev, CMD_NOTIFY, &a0, &a1, wait);\n\tvdev->notify = NULL;\n\tvdev->notify_pa = 0;\n\tvdev->notify_sz = 0;\n\n\treturn err;\n}\n\nint vnic_dev_notify_unset(struct vnic_dev *vdev)\n{\n\tif (vdev->notify) {\n\t\tdma_free_coherent(&vdev->pdev->dev,\n\t\t\t\t  sizeof(struct vnic_devcmd_notify),\n\t\t\t\t  vdev->notify, vdev->notify_pa);\n\t}\n\n\treturn vnic_dev_notify_unsetcmd(vdev);\n}\n\nstatic int vnic_dev_notify_ready(struct vnic_dev *vdev)\n{\n\tu32 *words;\n\tunsigned int nwords = vdev->notify_sz / 4;\n\tunsigned int i;\n\tu32 csum;\n\n\tif (!vdev->notify || !vdev->notify_sz)\n\t\treturn 0;\n\n\tdo {\n\t\tcsum = 0;\n\t\tmemcpy(&vdev->notify_copy, vdev->notify, vdev->notify_sz);\n\t\twords = (u32 *)&vdev->notify_copy;\n\t\tfor (i = 1; i < nwords; i++)\n\t\t\tcsum += words[i];\n\t} while (csum != words[0]);\n\n\treturn 1;\n}\n\nint vnic_dev_init(struct vnic_dev *vdev, int arg)\n{\n\tu64 a0 = (u32)arg, a1 = 0;\n\tint wait = 1000;\n\tint r = 0;\n\n\tif (vnic_dev_capable(vdev, CMD_INIT))\n\t\tr = vnic_dev_cmd(vdev, CMD_INIT, &a0, &a1, wait);\n\telse {\n\t\tvnic_dev_cmd(vdev, CMD_INIT_v1, &a0, &a1, wait);\n\t\tif (a0 & CMD_INITF_DEFAULT_MAC) {\n\t\t\t \n\t\t\tvnic_dev_cmd(vdev, CMD_GET_MAC_ADDR, &a0, &a1, wait);\n\t\t\tvnic_dev_cmd(vdev, CMD_ADDR_ADD, &a0, &a1, wait);\n\t\t}\n\t}\n\treturn r;\n}\n\nint vnic_dev_deinit(struct vnic_dev *vdev)\n{\n\tu64 a0 = 0, a1 = 0;\n\tint wait = 1000;\n\n\treturn vnic_dev_cmd(vdev, CMD_DEINIT, &a0, &a1, wait);\n}\n\nvoid vnic_dev_intr_coal_timer_info_default(struct vnic_dev *vdev)\n{\n\t \n\tvdev->intr_coal_timer_info.mul = 2;\n\tvdev->intr_coal_timer_info.div = 3;\n\tvdev->intr_coal_timer_info.max_usec =\n\t\tvnic_dev_intr_coal_timer_hw_to_usec(vdev, 0xffff);\n}\n\nint vnic_dev_intr_coal_timer_info(struct vnic_dev *vdev)\n{\n\tint wait = 1000;\n\tint err;\n\n\tmemset(vdev->args, 0, sizeof(vdev->args));\n\n\tif (vnic_dev_capable(vdev, CMD_INTR_COAL_CONVERT))\n\t\terr = vdev->devcmd_rtn(vdev, CMD_INTR_COAL_CONVERT, wait);\n\telse\n\t\terr = ERR_ECMDUNKNOWN;\n\n\t \n\tif ((err == ERR_ECMDUNKNOWN) ||\n\t\t(!err && !(vdev->args[0] && vdev->args[1] && vdev->args[2]))) {\n\t\tvdev_netwarn(vdev, \"Using default conversion factor for interrupt coalesce timer\\n\");\n\t\tvnic_dev_intr_coal_timer_info_default(vdev);\n\t\treturn 0;\n\t}\n\n\tif (!err) {\n\t\tvdev->intr_coal_timer_info.mul = (u32) vdev->args[0];\n\t\tvdev->intr_coal_timer_info.div = (u32) vdev->args[1];\n\t\tvdev->intr_coal_timer_info.max_usec = (u32) vdev->args[2];\n\t}\n\n\treturn err;\n}\n\nint vnic_dev_link_status(struct vnic_dev *vdev)\n{\n\tif (!vnic_dev_notify_ready(vdev))\n\t\treturn 0;\n\n\treturn vdev->notify_copy.link_state;\n}\n\nu32 vnic_dev_port_speed(struct vnic_dev *vdev)\n{\n\tif (!vnic_dev_notify_ready(vdev))\n\t\treturn 0;\n\n\treturn vdev->notify_copy.port_speed;\n}\n\nu32 vnic_dev_msg_lvl(struct vnic_dev *vdev)\n{\n\tif (!vnic_dev_notify_ready(vdev))\n\t\treturn 0;\n\n\treturn vdev->notify_copy.msglvl;\n}\n\nu32 vnic_dev_mtu(struct vnic_dev *vdev)\n{\n\tif (!vnic_dev_notify_ready(vdev))\n\t\treturn 0;\n\n\treturn vdev->notify_copy.mtu;\n}\n\nvoid vnic_dev_set_intr_mode(struct vnic_dev *vdev,\n\tenum vnic_dev_intr_mode intr_mode)\n{\n\tvdev->intr_mode = intr_mode;\n}\n\nenum vnic_dev_intr_mode vnic_dev_get_intr_mode(\n\tstruct vnic_dev *vdev)\n{\n\treturn vdev->intr_mode;\n}\n\nu32 vnic_dev_intr_coal_timer_usec_to_hw(struct vnic_dev *vdev, u32 usec)\n{\n\treturn (usec * vdev->intr_coal_timer_info.mul) /\n\t\tvdev->intr_coal_timer_info.div;\n}\n\nu32 vnic_dev_intr_coal_timer_hw_to_usec(struct vnic_dev *vdev, u32 hw_cycles)\n{\n\treturn (hw_cycles * vdev->intr_coal_timer_info.div) /\n\t\tvdev->intr_coal_timer_info.mul;\n}\n\nu32 vnic_dev_get_intr_coal_timer_max(struct vnic_dev *vdev)\n{\n\treturn vdev->intr_coal_timer_info.max_usec;\n}\n\nvoid vnic_dev_unregister(struct vnic_dev *vdev)\n{\n\tif (vdev) {\n\t\tif (vdev->notify)\n\t\t\tdma_free_coherent(&vdev->pdev->dev,\n\t\t\t\t\t  sizeof(struct vnic_devcmd_notify),\n\t\t\t\t\t  vdev->notify, vdev->notify_pa);\n\t\tif (vdev->stats)\n\t\t\tdma_free_coherent(&vdev->pdev->dev,\n\t\t\t\t\t  sizeof(struct vnic_stats),\n\t\t\t\t\t  vdev->stats, vdev->stats_pa);\n\t\tif (vdev->fw_info)\n\t\t\tdma_free_coherent(&vdev->pdev->dev,\n\t\t\t\t\t  sizeof(struct vnic_devcmd_fw_info),\n\t\t\t\t\t  vdev->fw_info, vdev->fw_info_pa);\n\t\tif (vdev->devcmd2)\n\t\t\tvnic_dev_deinit_devcmd2(vdev);\n\n\t\tkfree(vdev);\n\t}\n}\nEXPORT_SYMBOL(vnic_dev_unregister);\n\nstruct vnic_dev *vnic_dev_register(struct vnic_dev *vdev,\n\tvoid *priv, struct pci_dev *pdev, struct vnic_dev_bar *bar,\n\tunsigned int num_bars)\n{\n\tif (!vdev) {\n\t\tvdev = kzalloc(sizeof(struct vnic_dev), GFP_KERNEL);\n\t\tif (!vdev)\n\t\t\treturn NULL;\n\t}\n\n\tvdev->priv = priv;\n\tvdev->pdev = pdev;\n\n\tif (vnic_dev_discover_res(vdev, bar, num_bars))\n\t\tgoto err_out;\n\n\treturn vdev;\n\nerr_out:\n\tvnic_dev_unregister(vdev);\n\treturn NULL;\n}\nEXPORT_SYMBOL(vnic_dev_register);\n\nstruct pci_dev *vnic_dev_get_pdev(struct vnic_dev *vdev)\n{\n\treturn vdev->pdev;\n}\nEXPORT_SYMBOL(vnic_dev_get_pdev);\n\nint vnic_devcmd_init(struct vnic_dev *vdev)\n{\n\tvoid __iomem *res;\n\tint err;\n\n\tres = vnic_dev_get_res(vdev, RES_TYPE_DEVCMD2, 0);\n\tif (res) {\n\t\terr = vnic_dev_init_devcmd2(vdev);\n\t\tif (err)\n\t\t\tvdev_warn(vdev, \"DEVCMD2 init failed: %d, Using DEVCMD1\\n\",\n\t\t\t\t  err);\n\t\telse\n\t\t\treturn 0;\n\t} else {\n\t\tvdev_warn(vdev, \"DEVCMD2 resource not found (old firmware?) Using DEVCMD1\\n\");\n\t}\n\terr = vnic_dev_init_devcmd1(vdev);\n\tif (err)\n\t\tvdev_err(vdev, \"DEVCMD1 initialization failed: %d\\n\", err);\n\n\treturn err;\n}\n\nint vnic_dev_init_prov2(struct vnic_dev *vdev, u8 *buf, u32 len)\n{\n\tu64 a0, a1 = len;\n\tint wait = 1000;\n\tdma_addr_t prov_pa;\n\tvoid *prov_buf;\n\tint ret;\n\n\tprov_buf = dma_alloc_coherent(&vdev->pdev->dev, len, &prov_pa, GFP_ATOMIC);\n\tif (!prov_buf)\n\t\treturn -ENOMEM;\n\n\tmemcpy(prov_buf, buf, len);\n\n\ta0 = prov_pa;\n\n\tret = vnic_dev_cmd(vdev, CMD_INIT_PROV_INFO2, &a0, &a1, wait);\n\n\tdma_free_coherent(&vdev->pdev->dev, len, prov_buf, prov_pa);\n\n\treturn ret;\n}\n\nint vnic_dev_enable2(struct vnic_dev *vdev, int active)\n{\n\tu64 a0, a1 = 0;\n\tint wait = 1000;\n\n\ta0 = (active ? CMD_ENABLE2_ACTIVE : 0);\n\n\treturn vnic_dev_cmd(vdev, CMD_ENABLE2, &a0, &a1, wait);\n}\n\nstatic int vnic_dev_cmd_status(struct vnic_dev *vdev, enum vnic_devcmd_cmd cmd,\n\tint *status)\n{\n\tu64 a0 = cmd, a1 = 0;\n\tint wait = 1000;\n\tint ret;\n\n\tret = vnic_dev_cmd(vdev, CMD_STATUS, &a0, &a1, wait);\n\tif (!ret)\n\t\t*status = (int)a0;\n\n\treturn ret;\n}\n\nint vnic_dev_enable2_done(struct vnic_dev *vdev, int *status)\n{\n\treturn vnic_dev_cmd_status(vdev, CMD_ENABLE2, status);\n}\n\nint vnic_dev_deinit_done(struct vnic_dev *vdev, int *status)\n{\n\treturn vnic_dev_cmd_status(vdev, CMD_DEINIT, status);\n}\n\nint vnic_dev_set_mac_addr(struct vnic_dev *vdev, u8 *mac_addr)\n{\n\tu64 a0, a1;\n\tint wait = 1000;\n\tint i;\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\t((u8 *)&a0)[i] = mac_addr[i];\n\n\treturn vnic_dev_cmd(vdev, CMD_SET_MAC_ADDR, &a0, &a1, wait);\n}\n\n \nint vnic_dev_classifier(struct vnic_dev *vdev, u8 cmd, u16 *entry,\n\t\t\tstruct filter *data)\n{\n\tu64 a0, a1;\n\tint wait = 1000;\n\tdma_addr_t tlv_pa;\n\tint ret = -EINVAL;\n\tstruct filter_tlv *tlv, *tlv_va;\n\tstruct filter_action *action;\n\tu64 tlv_size;\n\n\tif (cmd == CLSF_ADD) {\n\t\ttlv_size = sizeof(struct filter) +\n\t\t\t   sizeof(struct filter_action) +\n\t\t\t   2 * sizeof(struct filter_tlv);\n\t\ttlv_va = dma_alloc_coherent(&vdev->pdev->dev, tlv_size,\n\t\t\t\t\t    &tlv_pa, GFP_ATOMIC);\n\t\tif (!tlv_va)\n\t\t\treturn -ENOMEM;\n\t\ttlv = tlv_va;\n\t\ta0 = tlv_pa;\n\t\ta1 = tlv_size;\n\t\tmemset(tlv, 0, tlv_size);\n\t\ttlv->type = CLSF_TLV_FILTER;\n\t\ttlv->length = sizeof(struct filter);\n\t\t*(struct filter *)&tlv->val = *data;\n\n\t\ttlv = (struct filter_tlv *)((char *)tlv +\n\t\t\t\t\t    sizeof(struct filter_tlv) +\n\t\t\t\t\t    sizeof(struct filter));\n\n\t\ttlv->type = CLSF_TLV_ACTION;\n\t\ttlv->length = sizeof(struct filter_action);\n\t\taction = (struct filter_action *)&tlv->val;\n\t\taction->type = FILTER_ACTION_RQ_STEERING;\n\t\taction->u.rq_idx = *entry;\n\n\t\tret = vnic_dev_cmd(vdev, CMD_ADD_FILTER, &a0, &a1, wait);\n\t\t*entry = (u16)a0;\n\t\tdma_free_coherent(&vdev->pdev->dev, tlv_size, tlv_va, tlv_pa);\n\t} else if (cmd == CLSF_DEL) {\n\t\ta0 = *entry;\n\t\tret = vnic_dev_cmd(vdev, CMD_DEL_FILTER, &a0, &a1, wait);\n\t}\n\n\treturn ret;\n}\n\nint vnic_dev_overlay_offload_ctrl(struct vnic_dev *vdev, u8 overlay, u8 config)\n{\n\tu64 a0 = overlay;\n\tu64 a1 = config;\n\tint wait = 1000;\n\n\treturn vnic_dev_cmd(vdev, CMD_OVERLAY_OFFLOAD_CTRL, &a0, &a1, wait);\n}\n\nint vnic_dev_overlay_offload_cfg(struct vnic_dev *vdev, u8 overlay,\n\t\t\t\t u16 vxlan_udp_port_number)\n{\n\tu64 a1 = vxlan_udp_port_number;\n\tu64 a0 = overlay;\n\tint wait = 1000;\n\n\treturn vnic_dev_cmd(vdev, CMD_OVERLAY_OFFLOAD_CFG, &a0, &a1, wait);\n}\n\nint vnic_dev_get_supported_feature_ver(struct vnic_dev *vdev, u8 feature,\n\t\t\t\t       u64 *supported_versions, u64 *a1)\n{\n\tu64 a0 = feature;\n\tint wait = 1000;\n\tint ret;\n\n\tret = vnic_dev_cmd(vdev, CMD_GET_SUPP_FEATURE_VER, &a0, a1, wait);\n\tif (!ret)\n\t\t*supported_versions = a0;\n\n\treturn ret;\n}\n\nint vnic_dev_capable_rss_hash_type(struct vnic_dev *vdev, u8 *rss_hash_type)\n{\n\tu64 a0 = CMD_NIC_CFG, a1 = 0;\n\tint wait = 1000;\n\tint err;\n\n\terr = vnic_dev_cmd(vdev, CMD_CAPABILITY, &a0, &a1, wait);\n\t \n\tif (err || (a0 != 1))\n\t\treturn -EOPNOTSUPP;\n\n\ta1 = (a1 >> NIC_CFG_RSS_HASH_TYPE_SHIFT) &\n\t     NIC_CFG_RSS_HASH_TYPE_MASK_FIELD;\n\n\t*rss_hash_type = (u8)a1;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}