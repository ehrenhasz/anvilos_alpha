{
  "module_name": "enic_pp.c",
  "hash_id": "ff5a3b2ca09ed077b4ca1fb3c1e2f65a2eef944edcc076fc5d46fa8128a75347",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/cisco/enic/enic_pp.c",
  "human_readable_source": "\n\n\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/rtnetlink.h>\n#include <net/ip.h>\n\n#include \"vnic_vic.h\"\n#include \"enic_res.h\"\n#include \"enic.h\"\n#include \"enic_dev.h\"\n#include \"enic_pp.h\"\n\n \nint enic_is_valid_pp_vf(struct enic *enic, int vf, int *err)\n{\n\tif (vf != PORT_SELF_VF) {\n#ifdef CONFIG_PCI_IOV\n\t\tif (enic_sriov_enabled(enic)) {\n\t\t\tif (vf < 0 || vf >= enic->num_vfs) {\n\t\t\t\t*err = -EINVAL;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t} else {\n\t\t\t*err = -EOPNOTSUPP;\n\t\t\tgoto err_out;\n\t\t}\n#else\n\t\t*err = -EOPNOTSUPP;\n\t\tgoto err_out;\n#endif\n\t}\n\n\tif (vf == PORT_SELF_VF && !enic_is_dynamic(enic)) {\n\t\t*err = -EOPNOTSUPP;\n\t\tgoto err_out;\n\t}\n\n\t*err = 0;\n\treturn 1;\n\nerr_out:\n\treturn 0;\n}\n\nstatic int enic_set_port_profile(struct enic *enic, int vf)\n{\n\tstruct net_device *netdev = enic->netdev;\n\tstruct enic_port_profile *pp;\n\tstruct vic_provinfo *vp;\n\tconst u8 oui[3] = VIC_PROVINFO_CISCO_OUI;\n\tconst __be16 os_type = htons(VIC_GENERIC_PROV_OS_TYPE_LINUX);\n\tconst u8 *client_mac;\n\tchar uuid_str[38];\n\tchar client_mac_str[18];\n\tint err;\n\n\tENIC_PP_BY_INDEX(enic, vf, pp, &err);\n\tif (err)\n\t\treturn err;\n\n\tif (!(pp->set & ENIC_SET_NAME) || !strlen(pp->name))\n\t\treturn -EINVAL;\n\n\tvp = vic_provinfo_alloc(GFP_KERNEL, oui,\n\t\tVIC_PROVINFO_GENERIC_TYPE);\n\tif (!vp)\n\t\treturn -ENOMEM;\n\n\tVIC_PROVINFO_ADD_TLV(vp,\n\t\tVIC_GENERIC_PROV_TLV_PORT_PROFILE_NAME_STR,\n\t\tstrlen(pp->name) + 1, pp->name);\n\n\tif (!is_zero_ether_addr(pp->mac_addr)) {\n\t\tclient_mac = pp->mac_addr;\n\t} else if (vf == PORT_SELF_VF) {\n\t\tclient_mac = netdev->dev_addr;\n\t} else {\n\t\tnetdev_err(netdev, \"Cannot find pp mac address \"\n\t\t\t\"for VF %d\\n\", vf);\n\t\terr = -EINVAL;\n\t\tgoto add_tlv_failure;\n\t}\n\n\tVIC_PROVINFO_ADD_TLV(vp,\n\t\tVIC_GENERIC_PROV_TLV_CLIENT_MAC_ADDR,\n\t\tETH_ALEN, client_mac);\n\n\tsnprintf(client_mac_str, sizeof(client_mac_str), \"%pM\", client_mac);\n\tVIC_PROVINFO_ADD_TLV(vp,\n\t\tVIC_GENERIC_PROV_TLV_CLUSTER_PORT_UUID_STR,\n\t\tsizeof(client_mac_str), client_mac_str);\n\n\tif (pp->set & ENIC_SET_INSTANCE) {\n\t\tsprintf(uuid_str, \"%pUB\", pp->instance_uuid);\n\t\tVIC_PROVINFO_ADD_TLV(vp,\n\t\t\tVIC_GENERIC_PROV_TLV_CLIENT_UUID_STR,\n\t\t\tsizeof(uuid_str), uuid_str);\n\t}\n\n\tif (pp->set & ENIC_SET_HOST) {\n\t\tsprintf(uuid_str, \"%pUB\", pp->host_uuid);\n\t\tVIC_PROVINFO_ADD_TLV(vp,\n\t\t\tVIC_GENERIC_PROV_TLV_HOST_UUID_STR,\n\t\t\tsizeof(uuid_str), uuid_str);\n\t}\n\n\tVIC_PROVINFO_ADD_TLV(vp,\n\t\tVIC_GENERIC_PROV_TLV_OS_TYPE,\n\t\tsizeof(os_type), &os_type);\n\n\tENIC_DEVCMD_PROXY_BY_INDEX(vf, err, enic, vnic_dev_init_prov2, (u8 *)vp,\n\t\tvic_provinfo_size(vp));\n\terr = enic_dev_status_to_errno(err);\n\nadd_tlv_failure:\n\tvic_provinfo_free(vp);\n\n\treturn err;\n}\n\nstatic int enic_unset_port_profile(struct enic *enic, int vf)\n{\n\tint err;\n\n\tENIC_DEVCMD_PROXY_BY_INDEX(vf, err, enic, vnic_dev_deinit);\n\tif (err)\n\t\treturn enic_dev_status_to_errno(err);\n\n\tif (vf == PORT_SELF_VF)\n\t\tenic_reset_addr_lists(enic);\n\n\treturn 0;\n}\n\nstatic int enic_are_pp_different(struct enic_port_profile *pp1,\n\t\tstruct enic_port_profile *pp2)\n{\n\treturn strcmp(pp1->name, pp2->name) | !!memcmp(pp1->instance_uuid,\n\t\tpp2->instance_uuid, PORT_UUID_MAX) |\n\t\t!!memcmp(pp1->host_uuid, pp2->host_uuid, PORT_UUID_MAX) |\n\t\t!ether_addr_equal(pp1->mac_addr, pp2->mac_addr);\n}\n\nstatic int enic_pp_preassociate(struct enic *enic, int vf,\n\tstruct enic_port_profile *prev_pp, int *restore_pp);\nstatic int enic_pp_disassociate(struct enic *enic, int vf,\n\tstruct enic_port_profile *prev_pp, int *restore_pp);\nstatic int enic_pp_preassociate_rr(struct enic *enic, int vf,\n\tstruct enic_port_profile *prev_pp, int *restore_pp);\nstatic int enic_pp_associate(struct enic *enic, int vf,\n\tstruct enic_port_profile *prev_pp, int *restore_pp);\n\nstatic int (*enic_pp_handlers[])(struct enic *enic, int vf,\n\t\tstruct enic_port_profile *prev_state,\n\t\tint *restore_pp) = {\n\t[PORT_REQUEST_PREASSOCIATE]\t= enic_pp_preassociate,\n\t[PORT_REQUEST_PREASSOCIATE_RR]\t= enic_pp_preassociate_rr,\n\t[PORT_REQUEST_ASSOCIATE]\t= enic_pp_associate,\n\t[PORT_REQUEST_DISASSOCIATE]\t= enic_pp_disassociate,\n};\n\nstatic const int enic_pp_handlers_count =\n\t\t\tARRAY_SIZE(enic_pp_handlers);\n\nstatic int enic_pp_preassociate(struct enic *enic, int vf,\n\tstruct enic_port_profile *prev_pp, int *restore_pp)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int enic_pp_disassociate(struct enic *enic, int vf,\n\tstruct enic_port_profile *prev_pp, int *restore_pp)\n{\n\tstruct net_device *netdev = enic->netdev;\n\tstruct enic_port_profile *pp;\n\tint err;\n\n\tENIC_PP_BY_INDEX(enic, vf, pp, &err);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!is_zero_ether_addr(pp->mac_addr))\n\t\tENIC_DEVCMD_PROXY_BY_INDEX(vf, err, enic, vnic_dev_del_addr,\n\t\t\tpp->mac_addr);\n\telse if (vf == PORT_SELF_VF && !is_zero_ether_addr(netdev->dev_addr))\n\t\tENIC_DEVCMD_PROXY_BY_INDEX(vf, err, enic, vnic_dev_del_addr,\n\t\t\tnetdev->dev_addr);\n\n\treturn enic_unset_port_profile(enic, vf);\n}\n\nstatic int enic_pp_preassociate_rr(struct enic *enic, int vf,\n\tstruct enic_port_profile *prev_pp, int *restore_pp)\n{\n\tstruct enic_port_profile *pp;\n\tint err;\n\tint active = 0;\n\n\tENIC_PP_BY_INDEX(enic, vf, pp, &err);\n\tif (err)\n\t\treturn err;\n\n\tif (pp->request != PORT_REQUEST_ASSOCIATE) {\n\t\t \n\t\terr = enic_pp_handlers[PORT_REQUEST_DISASSOCIATE](enic, vf,\n\t\t\tprev_pp, restore_pp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t*restore_pp = 0;\n\t}\n\n\t*restore_pp = 0;\n\n\terr = enic_set_port_profile(enic, vf);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (pp->request != PORT_REQUEST_ASSOCIATE) {\n\t\t \n\t\tENIC_DEVCMD_PROXY_BY_INDEX(vf, err, enic, vnic_dev_enable2,\n\t\t\tactive);\n\t\terr = enic_dev_status_to_errno(err);\n\t}\n\n\treturn err;\n}\n\nstatic int enic_pp_associate(struct enic *enic, int vf,\n\tstruct enic_port_profile *prev_pp, int *restore_pp)\n{\n\tstruct net_device *netdev = enic->netdev;\n\tstruct enic_port_profile *pp;\n\tint err;\n\tint active = 1;\n\n\tENIC_PP_BY_INDEX(enic, vf, pp, &err);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (prev_pp->request != PORT_REQUEST_PREASSOCIATE_RR ||\n\t\t(prev_pp->request == PORT_REQUEST_PREASSOCIATE_RR &&\n\t\t\tenic_are_pp_different(prev_pp, pp))) {\n\t\terr = enic_pp_handlers[PORT_REQUEST_DISASSOCIATE](\n\t\t\tenic, vf, prev_pp, restore_pp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t*restore_pp = 0;\n\t}\n\n\terr = enic_pp_handlers[PORT_REQUEST_PREASSOCIATE_RR](\n\t\t\tenic, vf, prev_pp, restore_pp);\n\tif (err)\n\t\treturn err;\n\n\t*restore_pp = 0;\n\n\t \n\tENIC_DEVCMD_PROXY_BY_INDEX(vf, err, enic, vnic_dev_enable2, active);\n\terr = enic_dev_status_to_errno(err);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!is_zero_ether_addr(pp->mac_addr))\n\t\tENIC_DEVCMD_PROXY_BY_INDEX(vf, err, enic, vnic_dev_add_addr,\n\t\t\tpp->mac_addr);\n\telse if (vf == PORT_SELF_VF && !is_zero_ether_addr(netdev->dev_addr))\n\t\tENIC_DEVCMD_PROXY_BY_INDEX(vf, err, enic, vnic_dev_add_addr,\n\t\t\tnetdev->dev_addr);\n\n\treturn 0;\n}\n\nint enic_process_set_pp_request(struct enic *enic, int vf,\n\tstruct enic_port_profile *prev_pp, int *restore_pp)\n{\n\tstruct enic_port_profile *pp;\n\tint err;\n\n\tENIC_PP_BY_INDEX(enic, vf, pp, &err);\n\tif (err)\n\t\treturn err;\n\n\tif (pp->request >= enic_pp_handlers_count\n\t\t|| !enic_pp_handlers[pp->request])\n\t\treturn -EOPNOTSUPP;\n\n\treturn enic_pp_handlers[pp->request](enic, vf, prev_pp, restore_pp);\n}\n\nint enic_process_get_pp_request(struct enic *enic, int vf,\n\tint request, u16 *response)\n{\n\tint err, status = ERR_SUCCESS;\n\n\tswitch (request) {\n\n\tcase PORT_REQUEST_PREASSOCIATE_RR:\n\tcase PORT_REQUEST_ASSOCIATE:\n\t\tENIC_DEVCMD_PROXY_BY_INDEX(vf, err, enic,\n\t\t\tvnic_dev_enable2_done, &status);\n\t\tbreak;\n\n\tcase PORT_REQUEST_DISASSOCIATE:\n\t\tENIC_DEVCMD_PROXY_BY_INDEX(vf, err, enic,\n\t\t\tvnic_dev_deinit_done, &status);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (err)\n\t\tstatus = err;\n\n\tswitch (status) {\n\tcase ERR_SUCCESS:\n\t\t*response = PORT_PROFILE_RESPONSE_SUCCESS;\n\t\tbreak;\n\tcase ERR_EINVAL:\n\t\t*response = PORT_PROFILE_RESPONSE_INVALID;\n\t\tbreak;\n\tcase ERR_EBADSTATE:\n\t\t*response = PORT_PROFILE_RESPONSE_BADSTATE;\n\t\tbreak;\n\tcase ERR_ENOMEM:\n\t\t*response = PORT_PROFILE_RESPONSE_INSUFFICIENT_RESOURCES;\n\t\tbreak;\n\tcase ERR_EINPROGRESS:\n\t\t*response = PORT_PROFILE_RESPONSE_INPROGRESS;\n\t\tbreak;\n\tdefault:\n\t\t*response = PORT_PROFILE_RESPONSE_ERROR;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}