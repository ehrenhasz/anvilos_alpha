{
  "module_name": "dnet.c",
  "hash_id": "83a409d34825c0e7e8bcf474e60c0096f5fd63ff1207bc43726f2fe8fb4cac83",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ethernet/dnet.c",
  "human_readable_source": "\n \n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/dma-mapping.h>\n#include <linux/platform_device.h>\n#include <linux/phy.h>\n\n#include \"dnet.h\"\n\n#undef DEBUG\n\n \nstatic u16 dnet_readw_mac(struct dnet *bp, u16 reg)\n{\n\tu16 data_read;\n\n\t \n\tdnet_writel(bp, reg, MACREG_ADDR);\n\n\t \n\tndelay(500);\n\n\t \n\tdata_read = dnet_readl(bp, MACREG_DATA);\n\n\t \n\treturn data_read;\n}\n\n \nstatic void dnet_writew_mac(struct dnet *bp, u16 reg, u16 val)\n{\n\t \n\tdnet_writel(bp, val, MACREG_DATA);\n\n\t \n\tdnet_writel(bp, reg | DNET_INTERNAL_WRITE, MACREG_ADDR);\n\n\t \n\tndelay(500);\n}\n\nstatic void __dnet_set_hwaddr(struct dnet *bp)\n{\n\tu16 tmp;\n\n\ttmp = be16_to_cpup((const __be16 *)bp->dev->dev_addr);\n\tdnet_writew_mac(bp, DNET_INTERNAL_MAC_ADDR_0_REG, tmp);\n\ttmp = be16_to_cpup((const __be16 *)(bp->dev->dev_addr + 2));\n\tdnet_writew_mac(bp, DNET_INTERNAL_MAC_ADDR_1_REG, tmp);\n\ttmp = be16_to_cpup((const __be16 *)(bp->dev->dev_addr + 4));\n\tdnet_writew_mac(bp, DNET_INTERNAL_MAC_ADDR_2_REG, tmp);\n}\n\nstatic void dnet_get_hwaddr(struct dnet *bp)\n{\n\tu16 tmp;\n\tu8 addr[6];\n\n\t \n\ttmp = dnet_readw_mac(bp, DNET_INTERNAL_MAC_ADDR_0_REG);\n\t*((__be16 *)addr) = cpu_to_be16(tmp);\n\ttmp = dnet_readw_mac(bp, DNET_INTERNAL_MAC_ADDR_1_REG);\n\t*((__be16 *)(addr + 2)) = cpu_to_be16(tmp);\n\ttmp = dnet_readw_mac(bp, DNET_INTERNAL_MAC_ADDR_2_REG);\n\t*((__be16 *)(addr + 4)) = cpu_to_be16(tmp);\n\n\tif (is_valid_ether_addr(addr))\n\t\teth_hw_addr_set(bp->dev, addr);\n}\n\nstatic int dnet_mdio_read(struct mii_bus *bus, int mii_id, int regnum)\n{\n\tstruct dnet *bp = bus->priv;\n\tu16 value;\n\n\twhile (!(dnet_readw_mac(bp, DNET_INTERNAL_GMII_MNG_CTL_REG)\n\t\t\t\t& DNET_INTERNAL_GMII_MNG_CMD_FIN))\n\t\tcpu_relax();\n\n\t \n\tmii_id &= 0x1f;\n\tregnum &= 0x1f;\n\n\t \n\tvalue = (mii_id << 8);\n\tvalue |= regnum;\n\n\t \n\tdnet_writew_mac(bp, DNET_INTERNAL_GMII_MNG_CTL_REG, value);\n\n\t \n\twhile (!(dnet_readw_mac(bp, DNET_INTERNAL_GMII_MNG_CTL_REG)\n\t\t\t\t& DNET_INTERNAL_GMII_MNG_CMD_FIN))\n\t\tcpu_relax();\n\n\tvalue = dnet_readw_mac(bp, DNET_INTERNAL_GMII_MNG_DAT_REG);\n\n\tpr_debug(\"mdio_read %02x:%02x <- %04x\\n\", mii_id, regnum, value);\n\n\treturn value;\n}\n\nstatic int dnet_mdio_write(struct mii_bus *bus, int mii_id, int regnum,\n\t\t\t   u16 value)\n{\n\tstruct dnet *bp = bus->priv;\n\tu16 tmp;\n\n\tpr_debug(\"mdio_write %02x:%02x <- %04x\\n\", mii_id, regnum, value);\n\n\twhile (!(dnet_readw_mac(bp, DNET_INTERNAL_GMII_MNG_CTL_REG)\n\t\t\t\t& DNET_INTERNAL_GMII_MNG_CMD_FIN))\n\t\tcpu_relax();\n\n\t \n\ttmp = (1 << 13);\n\n\t \n\tmii_id &= 0x1f;\n\tregnum &= 0x1f;\n\n\t \n\tvalue &= 0xffff;\n\n\t \n\ttmp |= (mii_id << 8);\n\ttmp |= regnum;\n\n\t \n\tdnet_writew_mac(bp, DNET_INTERNAL_GMII_MNG_DAT_REG, value);\n\n\t \n\tdnet_writew_mac(bp, DNET_INTERNAL_GMII_MNG_CTL_REG, tmp);\n\n\twhile (!(dnet_readw_mac(bp, DNET_INTERNAL_GMII_MNG_CTL_REG)\n\t\t\t\t& DNET_INTERNAL_GMII_MNG_CMD_FIN))\n\t\tcpu_relax();\n\n\treturn 0;\n}\n\nstatic void dnet_handle_link_change(struct net_device *dev)\n{\n\tstruct dnet *bp = netdev_priv(dev);\n\tstruct phy_device *phydev = dev->phydev;\n\tunsigned long flags;\n\tu32 mode_reg, ctl_reg;\n\n\tint status_change = 0;\n\n\tspin_lock_irqsave(&bp->lock, flags);\n\n\tmode_reg = dnet_readw_mac(bp, DNET_INTERNAL_MODE_REG);\n\tctl_reg = dnet_readw_mac(bp, DNET_INTERNAL_RXTX_CONTROL_REG);\n\n\tif (phydev->link) {\n\t\tif (bp->duplex != phydev->duplex) {\n\t\t\tif (phydev->duplex)\n\t\t\t\tctl_reg &=\n\t\t\t\t    ~(DNET_INTERNAL_RXTX_CONTROL_ENABLEHALFDUP);\n\t\t\telse\n\t\t\t\tctl_reg |=\n\t\t\t\t    DNET_INTERNAL_RXTX_CONTROL_ENABLEHALFDUP;\n\n\t\t\tbp->duplex = phydev->duplex;\n\t\t\tstatus_change = 1;\n\t\t}\n\n\t\tif (bp->speed != phydev->speed) {\n\t\t\tstatus_change = 1;\n\t\t\tswitch (phydev->speed) {\n\t\t\tcase 1000:\n\t\t\t\tmode_reg |= DNET_INTERNAL_MODE_GBITEN;\n\t\t\t\tbreak;\n\t\t\tcase 100:\n\t\t\tcase 10:\n\t\t\t\tmode_reg &= ~DNET_INTERNAL_MODE_GBITEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"%s: Ack!  Speed (%d) is not \"\n\t\t\t\t       \"10/100/1000!\\n\", dev->name,\n\t\t\t\t       phydev->speed);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbp->speed = phydev->speed;\n\t\t}\n\t}\n\n\tif (phydev->link != bp->link) {\n\t\tif (phydev->link) {\n\t\t\tmode_reg |=\n\t\t\t    (DNET_INTERNAL_MODE_RXEN | DNET_INTERNAL_MODE_TXEN);\n\t\t} else {\n\t\t\tmode_reg &=\n\t\t\t    ~(DNET_INTERNAL_MODE_RXEN |\n\t\t\t      DNET_INTERNAL_MODE_TXEN);\n\t\t\tbp->speed = 0;\n\t\t\tbp->duplex = -1;\n\t\t}\n\t\tbp->link = phydev->link;\n\n\t\tstatus_change = 1;\n\t}\n\n\tif (status_change) {\n\t\tdnet_writew_mac(bp, DNET_INTERNAL_RXTX_CONTROL_REG, ctl_reg);\n\t\tdnet_writew_mac(bp, DNET_INTERNAL_MODE_REG, mode_reg);\n\t}\n\n\tspin_unlock_irqrestore(&bp->lock, flags);\n\n\tif (status_change) {\n\t\tif (phydev->link)\n\t\t\tprintk(KERN_INFO \"%s: link up (%d/%s)\\n\",\n\t\t\t       dev->name, phydev->speed,\n\t\t\t       DUPLEX_FULL == phydev->duplex ? \"Full\" : \"Half\");\n\t\telse\n\t\t\tprintk(KERN_INFO \"%s: link down\\n\", dev->name);\n\t}\n}\n\nstatic int dnet_mii_probe(struct net_device *dev)\n{\n\tstruct dnet *bp = netdev_priv(dev);\n\tstruct phy_device *phydev = NULL;\n\n\t \n\tphydev = phy_find_first(bp->mii_bus);\n\n\tif (!phydev) {\n\t\tprintk(KERN_ERR \"%s: no PHY found\\n\", dev->name);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\n\t \n\tif (bp->capabilities & DNET_HAS_RMII) {\n\t\tphydev = phy_connect(dev, phydev_name(phydev),\n\t\t\t\t     &dnet_handle_link_change,\n\t\t\t\t     PHY_INTERFACE_MODE_RMII);\n\t} else {\n\t\tphydev = phy_connect(dev, phydev_name(phydev),\n\t\t\t\t     &dnet_handle_link_change,\n\t\t\t\t     PHY_INTERFACE_MODE_MII);\n\t}\n\n\tif (IS_ERR(phydev)) {\n\t\tprintk(KERN_ERR \"%s: Could not attach to PHY\\n\", dev->name);\n\t\treturn PTR_ERR(phydev);\n\t}\n\n\t \n\tif (bp->capabilities & DNET_HAS_GIGABIT)\n\t\tphy_set_max_speed(phydev, SPEED_1000);\n\telse\n\t\tphy_set_max_speed(phydev, SPEED_100);\n\n\tphy_support_asym_pause(phydev);\n\n\tbp->link = 0;\n\tbp->speed = 0;\n\tbp->duplex = -1;\n\n\treturn 0;\n}\n\nstatic int dnet_mii_init(struct dnet *bp)\n{\n\tint err;\n\n\tbp->mii_bus = mdiobus_alloc();\n\tif (bp->mii_bus == NULL)\n\t\treturn -ENOMEM;\n\n\tbp->mii_bus->name = \"dnet_mii_bus\";\n\tbp->mii_bus->read = &dnet_mdio_read;\n\tbp->mii_bus->write = &dnet_mdio_write;\n\n\tsnprintf(bp->mii_bus->id, MII_BUS_ID_SIZE, \"%s-%x\",\n\t\tbp->pdev->name, bp->pdev->id);\n\n\tbp->mii_bus->priv = bp;\n\n\tif (mdiobus_register(bp->mii_bus)) {\n\t\terr = -ENXIO;\n\t\tgoto err_out;\n\t}\n\n\tif (dnet_mii_probe(bp->dev) != 0) {\n\t\terr = -ENXIO;\n\t\tgoto err_out_unregister_bus;\n\t}\n\n\treturn 0;\n\nerr_out_unregister_bus:\n\tmdiobus_unregister(bp->mii_bus);\nerr_out:\n\tmdiobus_free(bp->mii_bus);\n\treturn err;\n}\n\n \nstatic int dnet_phy_marvell_fixup(struct phy_device *phydev)\n{\n\treturn phy_write(phydev, 0x18, 0x4148);\n}\n\nstatic void dnet_update_stats(struct dnet *bp)\n{\n\tu32 __iomem *reg = bp->regs + DNET_RX_PKT_IGNR_CNT;\n\tu32 *p = &bp->hw_stats.rx_pkt_ignr;\n\tu32 *end = &bp->hw_stats.rx_byte + 1;\n\n\tWARN_ON((unsigned long)(end - p - 1) !=\n\t\t(DNET_RX_BYTE_CNT - DNET_RX_PKT_IGNR_CNT) / 4);\n\n\tfor (; p < end; p++, reg++)\n\t\t*p += readl(reg);\n\n\treg = bp->regs + DNET_TX_UNICAST_CNT;\n\tp = &bp->hw_stats.tx_unicast;\n\tend = &bp->hw_stats.tx_byte + 1;\n\n\tWARN_ON((unsigned long)(end - p - 1) !=\n\t\t(DNET_TX_BYTE_CNT - DNET_TX_UNICAST_CNT) / 4);\n\n\tfor (; p < end; p++, reg++)\n\t\t*p += readl(reg);\n}\n\nstatic int dnet_poll(struct napi_struct *napi, int budget)\n{\n\tstruct dnet *bp = container_of(napi, struct dnet, napi);\n\tstruct net_device *dev = bp->dev;\n\tint npackets = 0;\n\tunsigned int pkt_len;\n\tstruct sk_buff *skb;\n\tunsigned int *data_ptr;\n\tu32 int_enable;\n\tu32 cmd_word;\n\tint i;\n\n\twhile (npackets < budget) {\n\t\t \n\t\tif (!(dnet_readl(bp, RX_FIFO_WCNT) >> 16))\n\t\t\tbreak;\n\n\t\tcmd_word = dnet_readl(bp, RX_LEN_FIFO);\n\t\tpkt_len = cmd_word & 0xFFFF;\n\n\t\tif (cmd_word & 0xDF180000)\n\t\t\tprintk(KERN_ERR \"%s packet receive error %x\\n\",\n\t\t\t       __func__, cmd_word);\n\n\t\tskb = netdev_alloc_skb(dev, pkt_len + 5);\n\t\tif (skb != NULL) {\n\t\t\t \n\t\t\tskb_reserve(skb, 2);\n\t\t\t \n\t\t\tdata_ptr = skb_put(skb, pkt_len);\n\t\t\tfor (i = 0; i < (pkt_len + 3) >> 2; i++)\n\t\t\t\t*data_ptr++ = dnet_readl(bp, RX_DATA_FIFO);\n\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\tnetif_receive_skb(skb);\n\t\t\tnpackets++;\n\t\t} else\n\t\t\tprintk(KERN_NOTICE\n\t\t\t       \"%s: No memory to allocate a sk_buff of \"\n\t\t\t       \"size %u.\\n\", dev->name, pkt_len);\n\t}\n\n\tif (npackets < budget) {\n\t\t \n\t\tnapi_complete_done(napi, npackets);\n\t\tint_enable = dnet_readl(bp, INTR_ENB);\n\t\tint_enable |= DNET_INTR_SRC_RX_CMDFIFOAF;\n\t\tdnet_writel(bp, int_enable, INTR_ENB);\n\t}\n\n\treturn npackets;\n}\n\nstatic irqreturn_t dnet_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct dnet *bp = netdev_priv(dev);\n\tu32 int_src, int_enable, int_current;\n\tunsigned long flags;\n\tunsigned int handled = 0;\n\n\tspin_lock_irqsave(&bp->lock, flags);\n\n\t \n\tint_src = dnet_readl(bp, INTR_SRC);\n\tint_enable = dnet_readl(bp, INTR_ENB);\n\tint_current = int_src & int_enable;\n\n\t \n\tif (int_current & DNET_INTR_SRC_TX_FIFOAE) {\n\t\tint_enable = dnet_readl(bp, INTR_ENB);\n\t\tint_enable &= ~DNET_INTR_ENB_TX_FIFOAE;\n\t\tdnet_writel(bp, int_enable, INTR_ENB);\n\t\tnetif_wake_queue(dev);\n\t\thandled = 1;\n\t}\n\n\t \n\tif (int_current &\n\t    (DNET_INTR_SRC_RX_CMDFIFOFF | DNET_INTR_SRC_RX_DATAFIFOFF)) {\n\t\tprintk(KERN_ERR \"%s: RX fifo error %x, irq %x\\n\", __func__,\n\t\t       dnet_readl(bp, RX_STATUS), int_current);\n\t\t \n\t\tdnet_writel(bp, DNET_SYS_CTL_RXFIFOFLUSH, SYS_CTL);\n\t\tndelay(500);\n\t\tdnet_writel(bp, 0, SYS_CTL);\n\t\thandled = 1;\n\t}\n\n\t \n\tif (int_current &\n\t    (DNET_INTR_SRC_TX_FIFOFULL | DNET_INTR_SRC_TX_DISCFRM)) {\n\t\tprintk(KERN_ERR \"%s: TX fifo error %x, irq %x\\n\", __func__,\n\t\t       dnet_readl(bp, TX_STATUS), int_current);\n\t\t \n\t\tdnet_writel(bp, DNET_SYS_CTL_TXFIFOFLUSH, SYS_CTL);\n\t\tndelay(500);\n\t\tdnet_writel(bp, 0, SYS_CTL);\n\t\thandled = 1;\n\t}\n\n\tif (int_current & DNET_INTR_SRC_RX_CMDFIFOAF) {\n\t\tif (napi_schedule_prep(&bp->napi)) {\n\t\t\t \n\t\t\t \n\t\t\tint_enable = dnet_readl(bp, INTR_ENB);\n\t\t\tint_enable &= ~DNET_INTR_SRC_RX_CMDFIFOAF;\n\t\t\tdnet_writel(bp, int_enable, INTR_ENB);\n\t\t\t__napi_schedule(&bp->napi);\n\t\t}\n\t\thandled = 1;\n\t}\n\n\tif (!handled)\n\t\tpr_debug(\"%s: irq %x remains\\n\", __func__, int_current);\n\n\tspin_unlock_irqrestore(&bp->lock, flags);\n\n\treturn IRQ_RETVAL(handled);\n}\n\n#ifdef DEBUG\nstatic inline void dnet_print_skb(struct sk_buff *skb)\n{\n\tint k;\n\tprintk(KERN_DEBUG PFX \"data:\");\n\tfor (k = 0; k < skb->len; k++)\n\t\tprintk(\" %02x\", (unsigned int)skb->data[k]);\n\tprintk(\"\\n\");\n}\n#else\n#define dnet_print_skb(skb)\tdo {} while (0)\n#endif\n\nstatic netdev_tx_t dnet_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\n\tstruct dnet *bp = netdev_priv(dev);\n\tunsigned int i, tx_cmd, wrsz;\n\tunsigned long flags;\n\tunsigned int *bufp;\n\tu32 irq_enable;\n\n\tdnet_readl(bp, TX_STATUS);\n\n\tpr_debug(\"start_xmit: len %u head %p data %p\\n\",\n\t       skb->len, skb->head, skb->data);\n\tdnet_print_skb(skb);\n\n\tspin_lock_irqsave(&bp->lock, flags);\n\n\tdnet_readl(bp, TX_STATUS);\n\n\tbufp = (unsigned int *)(((unsigned long) skb->data) & ~0x3UL);\n\twrsz = (u32) skb->len + 3;\n\twrsz += ((unsigned long) skb->data) & 0x3;\n\twrsz >>= 2;\n\ttx_cmd = ((((unsigned long)(skb->data)) & 0x03) << 16) | (u32) skb->len;\n\n\t \n\tif (wrsz < (DNET_FIFO_SIZE - dnet_readl(bp, TX_FIFO_WCNT))) {\n\t\tfor (i = 0; i < wrsz; i++)\n\t\t\tdnet_writel(bp, *bufp++, TX_DATA_FIFO);\n\n\t\t \n\t\tdnet_writel(bp, tx_cmd, TX_LEN_FIFO);\n\t}\n\n\tif (dnet_readl(bp, TX_FIFO_WCNT) > DNET_FIFO_TX_DATA_AF_TH) {\n\t\tnetif_stop_queue(dev);\n\t\tdnet_readl(bp, INTR_SRC);\n\t\tirq_enable = dnet_readl(bp, INTR_ENB);\n\t\tirq_enable |= DNET_INTR_ENB_TX_FIFOAE;\n\t\tdnet_writel(bp, irq_enable, INTR_ENB);\n\t}\n\n\tskb_tx_timestamp(skb);\n\n\tspin_unlock_irqrestore(&bp->lock, flags);\n\n\t \n\tdev_kfree_skb(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void dnet_reset_hw(struct dnet *bp)\n{\n\t \n\tdnet_writew_mac(bp, DNET_INTERNAL_MODE_REG, DNET_INTERNAL_MODE_FCEN);\n\n\t \n\tdnet_writel(bp, DNET_FIFO_RX_CMD_AF_TH, RX_FIFO_TH);\n\t \n\tdnet_writel(bp, DNET_FIFO_TX_DATA_AE_TH, TX_FIFO_TH);\n\n\t \n\tdnet_writel(bp, DNET_SYS_CTL_RXFIFOFLUSH | DNET_SYS_CTL_TXFIFOFLUSH,\n\t\t\tSYS_CTL);\n\tmsleep(1);\n\tdnet_writel(bp, 0, SYS_CTL);\n}\n\nstatic void dnet_init_hw(struct dnet *bp)\n{\n\tu32 config;\n\n\tdnet_reset_hw(bp);\n\t__dnet_set_hwaddr(bp);\n\n\tconfig = dnet_readw_mac(bp, DNET_INTERNAL_RXTX_CONTROL_REG);\n\n\tif (bp->dev->flags & IFF_PROMISC)\n\t\t \n\t\tconfig |= DNET_INTERNAL_RXTX_CONTROL_ENPROMISC;\n\tif (!(bp->dev->flags & IFF_BROADCAST))\n\t\t \n\t\tconfig |= DNET_INTERNAL_RXTX_CONTROL_RXMULTICAST;\n\n\tconfig |= DNET_INTERNAL_RXTX_CONTROL_RXPAUSE |\n\t    DNET_INTERNAL_RXTX_CONTROL_RXBROADCAST |\n\t    DNET_INTERNAL_RXTX_CONTROL_DROPCONTROL |\n\t    DNET_INTERNAL_RXTX_CONTROL_DISCFXFCS;\n\n\tdnet_writew_mac(bp, DNET_INTERNAL_RXTX_CONTROL_REG, config);\n\n\t \n\tconfig = dnet_readl(bp, INTR_SRC);\n\n\t \n\tdnet_writel(bp, DNET_INTR_ENB_GLOBAL_ENABLE | DNET_INTR_ENB_RX_SUMMARY |\n\t\t\tDNET_INTR_ENB_TX_SUMMARY | DNET_INTR_ENB_RX_FIFOERR |\n\t\t\tDNET_INTR_ENB_RX_ERROR | DNET_INTR_ENB_RX_FIFOFULL |\n\t\t\tDNET_INTR_ENB_TX_FIFOFULL | DNET_INTR_ENB_TX_DISCFRM |\n\t\t\tDNET_INTR_ENB_RX_PKTRDY, INTR_ENB);\n}\n\nstatic int dnet_open(struct net_device *dev)\n{\n\tstruct dnet *bp = netdev_priv(dev);\n\n\t \n\tif (!dev->phydev)\n\t\treturn -EAGAIN;\n\n\tnapi_enable(&bp->napi);\n\tdnet_init_hw(bp);\n\n\tphy_start_aneg(dev->phydev);\n\n\t \n\tphy_start(dev->phydev);\n\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\nstatic int dnet_close(struct net_device *dev)\n{\n\tstruct dnet *bp = netdev_priv(dev);\n\n\tnetif_stop_queue(dev);\n\tnapi_disable(&bp->napi);\n\n\tif (dev->phydev)\n\t\tphy_stop(dev->phydev);\n\n\tdnet_reset_hw(bp);\n\tnetif_carrier_off(dev);\n\n\treturn 0;\n}\n\nstatic inline void dnet_print_pretty_hwstats(struct dnet_stats *hwstat)\n{\n\tpr_debug(\"%s\\n\", __func__);\n\tpr_debug(\"----------------------------- RX statistics \"\n\t\t \"-------------------------------\\n\");\n\tpr_debug(\"RX_PKT_IGNR_CNT %-8x\\n\", hwstat->rx_pkt_ignr);\n\tpr_debug(\"RX_LEN_CHK_ERR_CNT %-8x\\n\", hwstat->rx_len_chk_err);\n\tpr_debug(\"RX_LNG_FRM_CNT %-8x\\n\", hwstat->rx_lng_frm);\n\tpr_debug(\"RX_SHRT_FRM_CNT %-8x\\n\", hwstat->rx_shrt_frm);\n\tpr_debug(\"RX_IPG_VIOL_CNT %-8x\\n\", hwstat->rx_ipg_viol);\n\tpr_debug(\"RX_CRC_ERR_CNT %-8x\\n\", hwstat->rx_crc_err);\n\tpr_debug(\"RX_OK_PKT_CNT %-8x\\n\", hwstat->rx_ok_pkt);\n\tpr_debug(\"RX_CTL_FRM_CNT %-8x\\n\", hwstat->rx_ctl_frm);\n\tpr_debug(\"RX_PAUSE_FRM_CNT %-8x\\n\", hwstat->rx_pause_frm);\n\tpr_debug(\"RX_MULTICAST_CNT %-8x\\n\", hwstat->rx_multicast);\n\tpr_debug(\"RX_BROADCAST_CNT %-8x\\n\", hwstat->rx_broadcast);\n\tpr_debug(\"RX_VLAN_TAG_CNT %-8x\\n\", hwstat->rx_vlan_tag);\n\tpr_debug(\"RX_PRE_SHRINK_CNT %-8x\\n\", hwstat->rx_pre_shrink);\n\tpr_debug(\"RX_DRIB_NIB_CNT %-8x\\n\", hwstat->rx_drib_nib);\n\tpr_debug(\"RX_UNSUP_OPCD_CNT %-8x\\n\", hwstat->rx_unsup_opcd);\n\tpr_debug(\"RX_BYTE_CNT %-8x\\n\", hwstat->rx_byte);\n\tpr_debug(\"----------------------------- TX statistics \"\n\t\t \"-------------------------------\\n\");\n\tpr_debug(\"TX_UNICAST_CNT %-8x\\n\", hwstat->tx_unicast);\n\tpr_debug(\"TX_PAUSE_FRM_CNT %-8x\\n\", hwstat->tx_pause_frm);\n\tpr_debug(\"TX_MULTICAST_CNT %-8x\\n\", hwstat->tx_multicast);\n\tpr_debug(\"TX_BRDCAST_CNT %-8x\\n\", hwstat->tx_brdcast);\n\tpr_debug(\"TX_VLAN_TAG_CNT %-8x\\n\", hwstat->tx_vlan_tag);\n\tpr_debug(\"TX_BAD_FCS_CNT %-8x\\n\", hwstat->tx_bad_fcs);\n\tpr_debug(\"TX_JUMBO_CNT %-8x\\n\", hwstat->tx_jumbo);\n\tpr_debug(\"TX_BYTE_CNT %-8x\\n\", hwstat->tx_byte);\n}\n\nstatic struct net_device_stats *dnet_get_stats(struct net_device *dev)\n{\n\n\tstruct dnet *bp = netdev_priv(dev);\n\tstruct net_device_stats *nstat = &dev->stats;\n\tstruct dnet_stats *hwstat = &bp->hw_stats;\n\n\t \n\tdnet_update_stats(bp);\n\n\t \n\tnstat->rx_errors = (hwstat->rx_len_chk_err +\n\t\t\t    hwstat->rx_lng_frm + hwstat->rx_shrt_frm +\n\t\t\t     \n\t\t\t    hwstat->rx_crc_err +\n\t\t\t    hwstat->rx_pre_shrink +\n\t\t\t    hwstat->rx_drib_nib + hwstat->rx_unsup_opcd);\n\tnstat->tx_errors = hwstat->tx_bad_fcs;\n\tnstat->rx_length_errors = (hwstat->rx_len_chk_err +\n\t\t\t\t   hwstat->rx_lng_frm +\n\t\t\t\t   hwstat->rx_shrt_frm + hwstat->rx_pre_shrink);\n\tnstat->rx_crc_errors = hwstat->rx_crc_err;\n\tnstat->rx_frame_errors = hwstat->rx_pre_shrink + hwstat->rx_drib_nib;\n\tnstat->rx_packets = hwstat->rx_ok_pkt;\n\tnstat->tx_packets = (hwstat->tx_unicast +\n\t\t\t     hwstat->tx_multicast + hwstat->tx_brdcast);\n\tnstat->rx_bytes = hwstat->rx_byte;\n\tnstat->tx_bytes = hwstat->tx_byte;\n\tnstat->multicast = hwstat->rx_multicast;\n\tnstat->rx_missed_errors = hwstat->rx_pkt_ignr;\n\n\tdnet_print_pretty_hwstats(hwstat);\n\n\treturn nstat;\n}\n\nstatic void dnet_get_drvinfo(struct net_device *dev,\n\t\t\t     struct ethtool_drvinfo *info)\n{\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->bus_info, \"0\", sizeof(info->bus_info));\n}\n\nstatic const struct ethtool_ops dnet_ethtool_ops = {\n\t.get_drvinfo\t\t= dnet_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_ts_info\t\t= ethtool_op_get_ts_info,\n\t.get_link_ksettings     = phy_ethtool_get_link_ksettings,\n\t.set_link_ksettings     = phy_ethtool_set_link_ksettings,\n};\n\nstatic const struct net_device_ops dnet_netdev_ops = {\n\t.ndo_open\t\t= dnet_open,\n\t.ndo_stop\t\t= dnet_close,\n\t.ndo_get_stats\t\t= dnet_get_stats,\n\t.ndo_start_xmit\t\t= dnet_start_xmit,\n\t.ndo_eth_ioctl\t\t= phy_do_ioctl_running,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int dnet_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct net_device *dev;\n\tstruct dnet *bp;\n\tstruct phy_device *phydev;\n\tint err;\n\tunsigned int irq;\n\n\tirq = platform_get_irq(pdev, 0);\n\n\tdev = alloc_etherdev(sizeof(*bp));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\t \n\tdev->features |= 0;\n\n\tbp = netdev_priv(dev);\n\tbp->dev = dev;\n\n\tplatform_set_drvdata(pdev, dev);\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\tspin_lock_init(&bp->lock);\n\n\tbp->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(bp->regs)) {\n\t\terr = PTR_ERR(bp->regs);\n\t\tgoto err_out_free_dev;\n\t}\n\n\tdev->irq = irq;\n\terr = request_irq(dev->irq, dnet_interrupt, 0, DRV_NAME, dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Unable to request IRQ %d (error %d)\\n\",\n\t\t       irq, err);\n\t\tgoto err_out_free_dev;\n\t}\n\n\tdev->netdev_ops = &dnet_netdev_ops;\n\tnetif_napi_add(dev, &bp->napi, dnet_poll);\n\tdev->ethtool_ops = &dnet_ethtool_ops;\n\n\tdev->base_addr = (unsigned long)bp->regs;\n\n\tbp->capabilities = dnet_readl(bp, VERCAPS) & DNET_CAPS_MASK;\n\n\tdnet_get_hwaddr(bp);\n\n\tif (!is_valid_ether_addr(dev->dev_addr)) {\n\t\t \n\t\teth_hw_addr_random(dev);\n\t\t__dnet_set_hwaddr(bp);\n\t}\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Cannot register net device, aborting.\\n\");\n\t\tgoto err_out_free_irq;\n\t}\n\n\t \n\terr = phy_register_fixup_for_uid(0x01410cc0, 0xfffffff0,\n\t\t\t\t\t dnet_phy_marvell_fixup);\n\t \n\tif (err)\n\t\tdev_warn(&pdev->dev, \"Cannot register PHY board fixup.\\n\");\n\n\terr = dnet_mii_init(bp);\n\tif (err)\n\t\tgoto err_out_unregister_netdev;\n\n\tdev_info(&pdev->dev, \"Dave DNET at 0x%p (0x%08x) irq %d %pM\\n\",\n\t       bp->regs, (unsigned int)res->start, dev->irq, dev->dev_addr);\n\tdev_info(&pdev->dev, \"has %smdio, %sirq, %sgigabit, %sdma\\n\",\n\t       (bp->capabilities & DNET_HAS_MDIO) ? \"\" : \"no \",\n\t       (bp->capabilities & DNET_HAS_IRQ) ? \"\" : \"no \",\n\t       (bp->capabilities & DNET_HAS_GIGABIT) ? \"\" : \"no \",\n\t       (bp->capabilities & DNET_HAS_DMA) ? \"\" : \"no \");\n\tphydev = dev->phydev;\n\tphy_attached_info(phydev);\n\n\treturn 0;\n\nerr_out_unregister_netdev:\n\tunregister_netdev(dev);\nerr_out_free_irq:\n\tfree_irq(dev->irq, dev);\nerr_out_free_dev:\n\tfree_netdev(dev);\n\treturn err;\n}\n\nstatic int dnet_remove(struct platform_device *pdev)\n{\n\n\tstruct net_device *dev;\n\tstruct dnet *bp;\n\n\tdev = platform_get_drvdata(pdev);\n\n\tif (dev) {\n\t\tbp = netdev_priv(dev);\n\t\tif (dev->phydev)\n\t\t\tphy_disconnect(dev->phydev);\n\t\tmdiobus_unregister(bp->mii_bus);\n\t\tmdiobus_free(bp->mii_bus);\n\t\tunregister_netdev(dev);\n\t\tfree_irq(dev->irq, dev);\n\t\tfree_netdev(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver dnet_driver = {\n\t.probe\t\t= dnet_probe,\n\t.remove\t\t= dnet_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"dnet\",\n\t},\n};\n\nmodule_platform_driver(dnet_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Dave DNET Ethernet driver\");\nMODULE_AUTHOR(\"Ilya Yanok <yanok@emcraft.com>, \"\n\t      \"Matteo Vit <matteo.vit@dave.eu>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}