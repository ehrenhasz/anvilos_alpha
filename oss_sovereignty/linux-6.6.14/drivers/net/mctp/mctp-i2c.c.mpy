{
  "module_name": "mctp-i2c.c",
  "hash_id": "525f8b388160ce7140f8ad0914b1ca7934357aa9578ada48a60c20ace3b1f0cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/mctp/mctp-i2c.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/i2c.h>\n#include <linux/i2c-mux.h>\n#include <linux/if_arp.h>\n#include <net/mctp.h>\n#include <net/mctpdevice.h>\n\n \n#define MCTP_I2C_MAXBLOCK 255\n \n#define MCTP_I2C_MAXMTU (MCTP_I2C_MAXBLOCK - 1)\n#define MCTP_I2C_MINMTU (64 + 4)\n \n#define MCTP_I2C_BUFSZ (3 + MCTP_I2C_MAXBLOCK + 1)\n#define MCTP_I2C_MINLEN 8\n#define MCTP_I2C_COMMANDCODE 0x0f\n#define MCTP_I2C_TX_WORK_LEN 100\n \n#define MCTP_I2C_TX_QUEUE_LEN 1100\n\n#define MCTP_I2C_OF_PROP \"mctp-controller\"\n\nenum {\n\tMCTP_I2C_FLOW_STATE_NEW = 0,\n\tMCTP_I2C_FLOW_STATE_ACTIVE,\n\tMCTP_I2C_FLOW_STATE_INVALID,\n};\n\n \nstatic DEFINE_MUTEX(driver_clients_lock);\nstatic LIST_HEAD(driver_clients);\n\nstruct mctp_i2c_client;\n\n \nstruct mctp_i2c_dev {\n\tstruct net_device *ndev;\n\tstruct i2c_adapter *adapter;\n\tstruct mctp_i2c_client *client;\n\tstruct list_head list;  \n\n\tsize_t rx_pos;\n\tu8 rx_buffer[MCTP_I2C_BUFSZ];\n\tstruct completion rx_done;\n\n\tstruct task_struct *tx_thread;\n\twait_queue_head_t tx_wq;\n\tstruct sk_buff_head tx_queue;\n\tu8 tx_scratch[MCTP_I2C_BUFSZ];\n\n\t \n\tstruct sk_buff unlock_marker;\n\n\t \n\tspinlock_t lock;\n\tint i2c_lock_count;\n\tint release_count;\n\t \n\tbool allow_rx;\n\n};\n\n \nstruct mctp_i2c_client {\n\tstruct i2c_client *client;\n\tu8 lladdr;\n\n\tstruct mctp_i2c_dev *sel;\n\tstruct list_head devs;\n\tspinlock_t sel_lock;  \n\n\tstruct list_head list;  \n};\n\n \nstruct mctp_i2c_hdr {\n\tu8 dest_slave;\n\tu8 command;\n\t \n\tu8 byte_count;\n\tu8 source_slave;\n};\n\nstatic int mctp_i2c_recv(struct mctp_i2c_dev *midev);\nstatic int mctp_i2c_slave_cb(struct i2c_client *client,\n\t\t\t     enum i2c_slave_event event, u8 *val);\nstatic void mctp_i2c_ndo_uninit(struct net_device *dev);\nstatic int mctp_i2c_ndo_open(struct net_device *dev);\n\nstatic struct i2c_adapter *mux_root_adapter(struct i2c_adapter *adap)\n{\n#if IS_ENABLED(CONFIG_I2C_MUX)\n\treturn i2c_root_adapter(&adap->dev);\n#else\n\t \n\treturn adap;\n#endif\n}\n\n \nstatic struct mctp_i2c_client *mctp_i2c_new_client(struct i2c_client *client)\n{\n\tstruct mctp_i2c_client *mcli = NULL;\n\tstruct i2c_adapter *root = NULL;\n\tint rc;\n\n\tif (client->flags & I2C_CLIENT_TEN) {\n\t\tdev_err(&client->dev, \"failed, MCTP requires a 7-bit I2C address, addr=0x%x\\n\",\n\t\t\tclient->addr);\n\t\trc = -EINVAL;\n\t\tgoto err;\n\t}\n\n\troot = mux_root_adapter(client->adapter);\n\tif (!root) {\n\t\tdev_err(&client->dev, \"failed to find root adapter\\n\");\n\t\trc = -ENOENT;\n\t\tgoto err;\n\t}\n\tif (root != client->adapter) {\n\t\tdev_err(&client->dev,\n\t\t\t\"A mctp-i2c-controller client cannot be placed on an I2C mux adapter.\\n\"\n\t\t\t\" It should be placed on the mux tree root adapter\\n\"\n\t\t\t\" then set mctp-controller property on adapters to attach\\n\");\n\t\trc = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tmcli = kzalloc(sizeof(*mcli), GFP_KERNEL);\n\tif (!mcli) {\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\tspin_lock_init(&mcli->sel_lock);\n\tINIT_LIST_HEAD(&mcli->devs);\n\tINIT_LIST_HEAD(&mcli->list);\n\tmcli->lladdr = client->addr & 0xff;\n\tmcli->client = client;\n\ti2c_set_clientdata(client, mcli);\n\n\trc = i2c_slave_register(mcli->client, mctp_i2c_slave_cb);\n\tif (rc < 0) {\n\t\tdev_err(&client->dev, \"i2c register failed %d\\n\", rc);\n\t\tmcli->client = NULL;\n\t\ti2c_set_clientdata(client, NULL);\n\t\tgoto err;\n\t}\n\n\treturn mcli;\nerr:\n\tif (mcli) {\n\t\tif (mcli->client)\n\t\t\ti2c_unregister_device(mcli->client);\n\t\tkfree(mcli);\n\t}\n\treturn ERR_PTR(rc);\n}\n\nstatic void mctp_i2c_free_client(struct mctp_i2c_client *mcli)\n{\n\tint rc;\n\n\tWARN_ON(!mutex_is_locked(&driver_clients_lock));\n\tWARN_ON(!list_empty(&mcli->devs));\n\tWARN_ON(mcli->sel);  \n\n\trc = i2c_slave_unregister(mcli->client);\n\t \n\tif (rc < 0)\n\t\tdev_err(&mcli->client->dev, \"i2c unregister failed %d\\n\", rc);\n\telse\n\t\tkfree(mcli);\n}\n\n \nstatic void __mctp_i2c_device_select(struct mctp_i2c_client *mcli,\n\t\t\t\t     struct mctp_i2c_dev *midev)\n{\n\tassert_spin_locked(&mcli->sel_lock);\n\tif (midev)\n\t\tdev_hold(midev->ndev);\n\tif (mcli->sel)\n\t\tdev_put(mcli->sel->ndev);\n\tmcli->sel = midev;\n}\n\n \nstatic void mctp_i2c_device_select(struct mctp_i2c_client *mcli,\n\t\t\t\t   struct mctp_i2c_dev *midev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mcli->sel_lock, flags);\n\t__mctp_i2c_device_select(mcli, midev);\n\tspin_unlock_irqrestore(&mcli->sel_lock, flags);\n}\n\nstatic int mctp_i2c_slave_cb(struct i2c_client *client,\n\t\t\t     enum i2c_slave_event event, u8 *val)\n{\n\tstruct mctp_i2c_client *mcli = i2c_get_clientdata(client);\n\tstruct mctp_i2c_dev *midev = NULL;\n\tunsigned long flags;\n\tint rc = 0;\n\n\tspin_lock_irqsave(&mcli->sel_lock, flags);\n\tmidev = mcli->sel;\n\tif (midev)\n\t\tdev_hold(midev->ndev);\n\tspin_unlock_irqrestore(&mcli->sel_lock, flags);\n\n\tif (!midev)\n\t\treturn 0;\n\n\tswitch (event) {\n\tcase I2C_SLAVE_WRITE_RECEIVED:\n\t\tif (midev->rx_pos < MCTP_I2C_BUFSZ) {\n\t\t\tmidev->rx_buffer[midev->rx_pos] = *val;\n\t\t\tmidev->rx_pos++;\n\t\t} else {\n\t\t\tmidev->ndev->stats.rx_over_errors++;\n\t\t}\n\n\t\tbreak;\n\tcase I2C_SLAVE_WRITE_REQUESTED:\n\t\t \n\t\tmidev->rx_buffer[0] = mcli->lladdr << 1;\n\t\tmidev->rx_pos = 1;\n\t\tbreak;\n\tcase I2C_SLAVE_STOP:\n\t\trc = mctp_i2c_recv(midev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdev_put(midev->ndev);\n\treturn rc;\n}\n\n \nstatic int mctp_i2c_recv(struct mctp_i2c_dev *midev)\n{\n\tstruct net_device *ndev = midev->ndev;\n\tstruct mctp_i2c_hdr *hdr;\n\tstruct mctp_skb_cb *cb;\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\tu8 pec, calc_pec;\n\tsize_t recvlen;\n\tint status;\n\n\t \n\tif (midev->rx_pos < MCTP_I2C_MINLEN + 1) {\n\t\tndev->stats.rx_length_errors++;\n\t\treturn -EINVAL;\n\t}\n\t \n\trecvlen = midev->rx_pos - 1;\n\n\thdr = (void *)midev->rx_buffer;\n\tif (hdr->command != MCTP_I2C_COMMANDCODE) {\n\t\tndev->stats.rx_dropped++;\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdr->byte_count + offsetof(struct mctp_i2c_hdr, source_slave) != recvlen) {\n\t\tndev->stats.rx_length_errors++;\n\t\treturn -EINVAL;\n\t}\n\n\tpec = midev->rx_buffer[midev->rx_pos - 1];\n\tcalc_pec = i2c_smbus_pec(0, midev->rx_buffer, recvlen);\n\tif (pec != calc_pec) {\n\t\tndev->stats.rx_crc_errors++;\n\t\treturn -EINVAL;\n\t}\n\n\tskb = netdev_alloc_skb(ndev, recvlen);\n\tif (!skb) {\n\t\tndev->stats.rx_dropped++;\n\t\treturn -ENOMEM;\n\t}\n\n\tskb->protocol = htons(ETH_P_MCTP);\n\tskb_put_data(skb, midev->rx_buffer, recvlen);\n\tskb_reset_mac_header(skb);\n\tskb_pull(skb, sizeof(struct mctp_i2c_hdr));\n\tskb_reset_network_header(skb);\n\n\tcb = __mctp_cb(skb);\n\tcb->halen = 1;\n\tcb->haddr[0] = hdr->source_slave >> 1;\n\n\t \n\tspin_lock_irqsave(&midev->lock, flags);\n\tif (midev->allow_rx) {\n\t\treinit_completion(&midev->rx_done);\n\t\tspin_unlock_irqrestore(&midev->lock, flags);\n\n\t\tstatus = netif_rx(skb);\n\t\tcomplete(&midev->rx_done);\n\t} else {\n\t\tstatus = NET_RX_DROP;\n\t\tspin_unlock_irqrestore(&midev->lock, flags);\n\t}\n\n\tif (status == NET_RX_SUCCESS) {\n\t\tndev->stats.rx_packets++;\n\t\tndev->stats.rx_bytes += recvlen;\n\t} else {\n\t\tndev->stats.rx_dropped++;\n\t}\n\treturn 0;\n}\n\nenum mctp_i2c_flow_state {\n\tMCTP_I2C_TX_FLOW_INVALID,\n\tMCTP_I2C_TX_FLOW_NONE,\n\tMCTP_I2C_TX_FLOW_NEW,\n\tMCTP_I2C_TX_FLOW_EXISTING,\n};\n\nstatic enum mctp_i2c_flow_state\nmctp_i2c_get_tx_flow_state(struct mctp_i2c_dev *midev, struct sk_buff *skb)\n{\n\tenum mctp_i2c_flow_state state;\n\tstruct mctp_sk_key *key;\n\tstruct mctp_flow *flow;\n\tunsigned long flags;\n\n\tflow = skb_ext_find(skb, SKB_EXT_MCTP);\n\tif (!flow)\n\t\treturn MCTP_I2C_TX_FLOW_NONE;\n\n\tkey = flow->key;\n\tif (!key)\n\t\treturn MCTP_I2C_TX_FLOW_NONE;\n\n\tspin_lock_irqsave(&key->lock, flags);\n\t \n\tif (!key->valid) {\n\t\tstate = MCTP_I2C_TX_FLOW_INVALID;\n\t} else {\n\t\tswitch (key->dev_flow_state) {\n\t\tcase MCTP_I2C_FLOW_STATE_NEW:\n\t\t\tkey->dev_flow_state = MCTP_I2C_FLOW_STATE_ACTIVE;\n\t\t\tstate = MCTP_I2C_TX_FLOW_NEW;\n\t\t\tbreak;\n\t\tcase MCTP_I2C_FLOW_STATE_ACTIVE:\n\t\t\tstate = MCTP_I2C_TX_FLOW_EXISTING;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstate = MCTP_I2C_TX_FLOW_INVALID;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&key->lock, flags);\n\n\treturn state;\n}\n\n \nstatic void mctp_i2c_lock_nest(struct mctp_i2c_dev *midev)\n{\n\tunsigned long flags;\n\tbool lock;\n\n\tspin_lock_irqsave(&midev->lock, flags);\n\tlock = midev->i2c_lock_count == 0;\n\tmidev->i2c_lock_count++;\n\tspin_unlock_irqrestore(&midev->lock, flags);\n\n\tif (lock)\n\t\ti2c_lock_bus(midev->adapter, I2C_LOCK_SEGMENT);\n}\n\nstatic void mctp_i2c_unlock_nest(struct mctp_i2c_dev *midev)\n{\n\tunsigned long flags;\n\tbool unlock;\n\n\tspin_lock_irqsave(&midev->lock, flags);\n\tif (!WARN_ONCE(midev->i2c_lock_count == 0, \"lock count underflow!\"))\n\t\tmidev->i2c_lock_count--;\n\tunlock = midev->i2c_lock_count == 0;\n\tspin_unlock_irqrestore(&midev->lock, flags);\n\n\tif (unlock)\n\t\ti2c_unlock_bus(midev->adapter, I2C_LOCK_SEGMENT);\n}\n\n \nstatic void mctp_i2c_unlock_reset(struct mctp_i2c_dev *midev)\n{\n\tunsigned long flags;\n\tbool unlock;\n\n\tspin_lock_irqsave(&midev->lock, flags);\n\tunlock = midev->i2c_lock_count > 0;\n\tmidev->i2c_lock_count = 0;\n\tspin_unlock_irqrestore(&midev->lock, flags);\n\n\tif (unlock)\n\t\ti2c_unlock_bus(midev->adapter, I2C_LOCK_SEGMENT);\n}\n\nstatic void mctp_i2c_xmit(struct mctp_i2c_dev *midev, struct sk_buff *skb)\n{\n\tstruct net_device_stats *stats = &midev->ndev->stats;\n\tenum mctp_i2c_flow_state fs;\n\tstruct mctp_i2c_hdr *hdr;\n\tstruct i2c_msg msg = {0};\n\tu8 *pecp;\n\tint rc;\n\n\tfs = mctp_i2c_get_tx_flow_state(midev, skb);\n\n\thdr = (void *)skb_mac_header(skb);\n\t \n\tif (skb->len != hdr->byte_count + 3) {\n\t\tdev_warn_ratelimited(&midev->adapter->dev,\n\t\t\t\t     \"Bad tx length %d vs skb %u\\n\",\n\t\t\t\t     hdr->byte_count + 3, skb->len);\n\t\treturn;\n\t}\n\n\tif (skb_tailroom(skb) >= 1) {\n\t\t \n\t\tskb_put(skb, 1);\n\t} else {\n\t\t \n\t\tskb_copy_bits(skb, 0, midev->tx_scratch, skb->len);\n\t\thdr = (void *)midev->tx_scratch;\n\t}\n\n\tpecp = (void *)&hdr->source_slave + hdr->byte_count;\n\t*pecp = i2c_smbus_pec(0, (u8 *)hdr, hdr->byte_count + 3);\n\tmsg.buf = (void *)&hdr->command;\n\t \n\tmsg.len = 2 + hdr->byte_count + 1;\n\tmsg.addr = hdr->dest_slave >> 1;\n\n\tswitch (fs) {\n\tcase MCTP_I2C_TX_FLOW_NONE:\n\t\t \n\t\tmctp_i2c_lock_nest(midev);\n\t\tmctp_i2c_device_select(midev->client, midev);\n\t\trc = __i2c_transfer(midev->adapter, &msg, 1);\n\t\tmctp_i2c_unlock_nest(midev);\n\t\tbreak;\n\n\tcase MCTP_I2C_TX_FLOW_NEW:\n\t\t \n\t\tmctp_i2c_lock_nest(midev);\n\t\tmctp_i2c_device_select(midev->client, midev);\n\t\tfallthrough;\n\n\tcase MCTP_I2C_TX_FLOW_EXISTING:\n\t\t \n\t\trc = __i2c_transfer(midev->adapter, &msg, 1);\n\t\tbreak;\n\n\tcase MCTP_I2C_TX_FLOW_INVALID:\n\t\treturn;\n\t}\n\n\tif (rc < 0) {\n\t\tdev_warn_ratelimited(&midev->adapter->dev,\n\t\t\t\t     \"__i2c_transfer failed %d\\n\", rc);\n\t\tstats->tx_errors++;\n\t} else {\n\t\tstats->tx_bytes += skb->len;\n\t\tstats->tx_packets++;\n\t}\n}\n\nstatic void mctp_i2c_flow_release(struct mctp_i2c_dev *midev)\n{\n\tunsigned long flags;\n\tbool unlock;\n\n\tspin_lock_irqsave(&midev->lock, flags);\n\tif (midev->release_count > midev->i2c_lock_count) {\n\t\tWARN_ONCE(1, \"release count overflow\");\n\t\tmidev->release_count = midev->i2c_lock_count;\n\t}\n\n\tmidev->i2c_lock_count -= midev->release_count;\n\tunlock = midev->i2c_lock_count == 0 && midev->release_count > 0;\n\tmidev->release_count = 0;\n\tspin_unlock_irqrestore(&midev->lock, flags);\n\n\tif (unlock)\n\t\ti2c_unlock_bus(midev->adapter, I2C_LOCK_SEGMENT);\n}\n\nstatic int mctp_i2c_header_create(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t  unsigned short type, const void *daddr,\n\t   const void *saddr, unsigned int len)\n{\n\tstruct mctp_i2c_hdr *hdr;\n\tstruct mctp_hdr *mhdr;\n\tu8 lldst, llsrc;\n\n\tif (len > MCTP_I2C_MAXMTU)\n\t\treturn -EMSGSIZE;\n\n\tlldst = *((u8 *)daddr);\n\tllsrc = *((u8 *)saddr);\n\n\tskb_push(skb, sizeof(struct mctp_i2c_hdr));\n\tskb_reset_mac_header(skb);\n\thdr = (void *)skb_mac_header(skb);\n\tmhdr = mctp_hdr(skb);\n\thdr->dest_slave = (lldst << 1) & 0xff;\n\thdr->command = MCTP_I2C_COMMANDCODE;\n\thdr->byte_count = len + 1;\n\thdr->source_slave = ((llsrc << 1) & 0xff) | 0x01;\n\tmhdr->ver = 0x01;\n\n\treturn sizeof(struct mctp_i2c_hdr);\n}\n\nstatic int mctp_i2c_tx_thread(void *data)\n{\n\tstruct mctp_i2c_dev *midev = data;\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\n\tfor (;;) {\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\n\t\tspin_lock_irqsave(&midev->tx_queue.lock, flags);\n\t\tskb = __skb_dequeue(&midev->tx_queue);\n\t\tif (netif_queue_stopped(midev->ndev))\n\t\t\tnetif_wake_queue(midev->ndev);\n\t\tspin_unlock_irqrestore(&midev->tx_queue.lock, flags);\n\n\t\tif (skb == &midev->unlock_marker) {\n\t\t\tmctp_i2c_flow_release(midev);\n\n\t\t} else if (skb) {\n\t\t\tmctp_i2c_xmit(midev, skb);\n\t\t\tkfree_skb(skb);\n\n\t\t} else {\n\t\t\twait_event_idle(midev->tx_wq,\n\t\t\t\t\t!skb_queue_empty(&midev->tx_queue) ||\n\t\t\t\t   kthread_should_stop());\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic netdev_tx_t mctp_i2c_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *dev)\n{\n\tstruct mctp_i2c_dev *midev = netdev_priv(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&midev->tx_queue.lock, flags);\n\tif (skb_queue_len(&midev->tx_queue) >= MCTP_I2C_TX_WORK_LEN) {\n\t\tnetif_stop_queue(dev);\n\t\tspin_unlock_irqrestore(&midev->tx_queue.lock, flags);\n\t\tnetdev_err(dev, \"BUG! Tx Ring full when queue awake!\\n\");\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\t__skb_queue_tail(&midev->tx_queue, skb);\n\tif (skb_queue_len(&midev->tx_queue) == MCTP_I2C_TX_WORK_LEN)\n\t\tnetif_stop_queue(dev);\n\tspin_unlock_irqrestore(&midev->tx_queue.lock, flags);\n\n\twake_up(&midev->tx_wq);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void mctp_i2c_release_flow(struct mctp_dev *mdev,\n\t\t\t\t  struct mctp_sk_key *key)\n\n{\n\tstruct mctp_i2c_dev *midev = netdev_priv(mdev->dev);\n\tbool queue_release = false;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&midev->lock, flags);\n\t \n\tif (key->dev_flow_state == MCTP_I2C_FLOW_STATE_ACTIVE) {\n\t\tmidev->release_count++;\n\t\tqueue_release = true;\n\t}\n\tkey->dev_flow_state = MCTP_I2C_FLOW_STATE_INVALID;\n\tspin_unlock_irqrestore(&midev->lock, flags);\n\n\tif (queue_release) {\n\t\t \n\t\tspin_lock(&midev->tx_queue.lock);\n\t\tif (!midev->unlock_marker.next)\n\t\t\t__skb_queue_tail(&midev->tx_queue,\n\t\t\t\t\t &midev->unlock_marker);\n\t\tspin_unlock(&midev->tx_queue.lock);\n\t\twake_up(&midev->tx_wq);\n\t}\n}\n\nstatic const struct net_device_ops mctp_i2c_ops = {\n\t.ndo_start_xmit = mctp_i2c_start_xmit,\n\t.ndo_uninit = mctp_i2c_ndo_uninit,\n\t.ndo_open = mctp_i2c_ndo_open,\n};\n\nstatic const struct header_ops mctp_i2c_headops = {\n\t.create = mctp_i2c_header_create,\n};\n\nstatic const struct mctp_netdev_ops mctp_i2c_mctp_ops = {\n\t.release_flow = mctp_i2c_release_flow,\n};\n\nstatic void mctp_i2c_net_setup(struct net_device *dev)\n{\n\tdev->type = ARPHRD_MCTP;\n\n\tdev->mtu = MCTP_I2C_MAXMTU;\n\tdev->min_mtu = MCTP_I2C_MINMTU;\n\tdev->max_mtu = MCTP_I2C_MAXMTU;\n\tdev->tx_queue_len = MCTP_I2C_TX_QUEUE_LEN;\n\n\tdev->hard_header_len = sizeof(struct mctp_i2c_hdr);\n\tdev->addr_len = 1;\n\n\tdev->netdev_ops\t\t= &mctp_i2c_ops;\n\tdev->header_ops\t\t= &mctp_i2c_headops;\n}\n\n \nstatic struct mctp_i2c_dev *mctp_i2c_midev_init(struct net_device *dev,\n\t\t\t\t\t\tstruct mctp_i2c_client *mcli,\n\t\t\t\t\t\tstruct i2c_adapter *adap)\n{\n\tstruct mctp_i2c_dev *midev = netdev_priv(dev);\n\tunsigned long flags;\n\n\tmidev->tx_thread = kthread_create(mctp_i2c_tx_thread, midev,\n\t\t\t\t\t  \"%s/tx\", dev->name);\n\tif (IS_ERR(midev->tx_thread))\n\t\treturn ERR_CAST(midev->tx_thread);\n\n\tmidev->ndev = dev;\n\tget_device(&adap->dev);\n\tmidev->adapter = adap;\n\tget_device(&mcli->client->dev);\n\tmidev->client = mcli;\n\tINIT_LIST_HEAD(&midev->list);\n\tspin_lock_init(&midev->lock);\n\tmidev->i2c_lock_count = 0;\n\tmidev->release_count = 0;\n\tinit_completion(&midev->rx_done);\n\tcomplete(&midev->rx_done);\n\tinit_waitqueue_head(&midev->tx_wq);\n\tskb_queue_head_init(&midev->tx_queue);\n\n\t \n\tspin_lock_irqsave(&mcli->sel_lock, flags);\n\tlist_add(&midev->list, &mcli->devs);\n\t \n\tif (!mcli->sel)\n\t\t__mctp_i2c_device_select(mcli, midev);\n\tspin_unlock_irqrestore(&mcli->sel_lock, flags);\n\n\t \n\twake_up_process(midev->tx_thread);\n\n\treturn midev;\n}\n\n \nstatic void mctp_i2c_midev_free(struct mctp_i2c_dev *midev)\n{\n\tstruct mctp_i2c_client *mcli = midev->client;\n\tunsigned long flags;\n\n\tif (midev->tx_thread) {\n\t\tkthread_stop(midev->tx_thread);\n\t\tmidev->tx_thread = NULL;\n\t}\n\n\t \n\tmctp_i2c_unlock_reset(midev);\n\n\t \n\tspin_lock_irqsave(&mcli->sel_lock, flags);\n\tlist_del(&midev->list);\n\tif (mcli->sel == midev) {\n\t\tstruct mctp_i2c_dev *first;\n\n\t\tfirst = list_first_entry_or_null(&mcli->devs, struct mctp_i2c_dev, list);\n\t\t__mctp_i2c_device_select(mcli, first);\n\t}\n\tspin_unlock_irqrestore(&mcli->sel_lock, flags);\n\n\tskb_queue_purge(&midev->tx_queue);\n\tput_device(&midev->adapter->dev);\n\tput_device(&mcli->client->dev);\n}\n\n \nstatic void mctp_i2c_unregister(struct mctp_i2c_dev *midev)\n{\n\tunsigned long flags;\n\n\t \n\tkthread_stop(midev->tx_thread);\n\tmidev->tx_thread = NULL;\n\n\t \n\tspin_lock_irqsave(&midev->lock, flags);\n\tmidev->allow_rx = false;\n\tspin_unlock_irqrestore(&midev->lock, flags);\n\twait_for_completion(&midev->rx_done);\n\n\tmctp_unregister_netdev(midev->ndev);\n\t \n\n\tfree_netdev(midev->ndev);\n}\n\nstatic void mctp_i2c_ndo_uninit(struct net_device *dev)\n{\n\tstruct mctp_i2c_dev *midev = netdev_priv(dev);\n\n\t \n\tmctp_i2c_midev_free(midev);\n}\n\nstatic int mctp_i2c_ndo_open(struct net_device *dev)\n{\n\tstruct mctp_i2c_dev *midev = netdev_priv(dev);\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&midev->lock, flags);\n\tmidev->allow_rx = true;\n\tspin_unlock_irqrestore(&midev->lock, flags);\n\n\treturn 0;\n}\n\nstatic int mctp_i2c_add_netdev(struct mctp_i2c_client *mcli,\n\t\t\t       struct i2c_adapter *adap)\n{\n\tstruct mctp_i2c_dev *midev = NULL;\n\tstruct net_device *ndev = NULL;\n\tstruct i2c_adapter *root;\n\tunsigned long flags;\n\tchar namebuf[30];\n\tint rc;\n\n\troot = mux_root_adapter(adap);\n\tif (root != mcli->client->adapter) {\n\t\tdev_err(&mcli->client->dev,\n\t\t\t\"I2C adapter %s is not a child bus of %s\\n\",\n\t\t\tmcli->client->adapter->name, root->name);\n\t\treturn -EINVAL;\n\t}\n\n\tWARN_ON(!mutex_is_locked(&driver_clients_lock));\n\tsnprintf(namebuf, sizeof(namebuf), \"mctpi2c%d\", adap->nr);\n\tndev = alloc_netdev(sizeof(*midev), namebuf, NET_NAME_ENUM, mctp_i2c_net_setup);\n\tif (!ndev) {\n\t\tdev_err(&mcli->client->dev, \"alloc netdev failed\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdev_net_set(ndev, current->nsproxy->net_ns);\n\tSET_NETDEV_DEV(ndev, &adap->dev);\n\tdev_addr_set(ndev, &mcli->lladdr);\n\n\tmidev = mctp_i2c_midev_init(ndev, mcli, adap);\n\tif (IS_ERR(midev)) {\n\t\trc = PTR_ERR(midev);\n\t\tmidev = NULL;\n\t\tgoto err;\n\t}\n\n\trc = mctp_register_netdev(ndev, &mctp_i2c_mctp_ops);\n\tif (rc < 0) {\n\t\tdev_err(&mcli->client->dev,\n\t\t\t\"register netdev \\\"%s\\\" failed %d\\n\",\n\t\t\tndev->name, rc);\n\t\tgoto err;\n\t}\n\n\tspin_lock_irqsave(&midev->lock, flags);\n\tmidev->allow_rx = false;\n\tspin_unlock_irqrestore(&midev->lock, flags);\n\n\treturn 0;\nerr:\n\tif (midev)\n\t\tmctp_i2c_midev_free(midev);\n\tif (ndev)\n\t\tfree_netdev(ndev);\n\treturn rc;\n}\n\n \nstatic void mctp_i2c_remove_netdev(struct mctp_i2c_client *mcli,\n\t\t\t\t   struct i2c_adapter *adap)\n{\n\tstruct mctp_i2c_dev *midev = NULL, *m = NULL;\n\tunsigned long flags;\n\n\tWARN_ON(!mutex_is_locked(&driver_clients_lock));\n\tspin_lock_irqsave(&mcli->sel_lock, flags);\n\t \n\tlist_for_each_entry(m, &mcli->devs, list)\n\t\tif (m->adapter == adap) {\n\t\t\tmidev = m;\n\t\t\tbreak;\n\t\t}\n\tspin_unlock_irqrestore(&mcli->sel_lock, flags);\n\n\tif (midev)\n\t\tmctp_i2c_unregister(midev);\n}\n\n \nstatic struct i2c_adapter *mctp_i2c_get_adapter(struct device *dev,\n\t\t\t\t\t\tstruct i2c_adapter **ret_root)\n{\n\tstruct i2c_adapter *root, *adap;\n\n\tif (dev->type != &i2c_adapter_type)\n\t\treturn NULL;\n\tadap = to_i2c_adapter(dev);\n\troot = mux_root_adapter(adap);\n\tWARN_ONCE(!root, \"MCTP I2C failed to find root adapter for %s\\n\",\n\t\t  dev_name(dev));\n\tif (!root)\n\t\treturn NULL;\n\tif (ret_root)\n\t\t*ret_root = root;\n\treturn adap;\n}\n\n \nstatic bool mctp_i2c_adapter_match(struct i2c_adapter *adap, bool match_no_of)\n{\n\tif (!adap->dev.of_node)\n\t\treturn match_no_of;\n\treturn of_property_read_bool(adap->dev.of_node, MCTP_I2C_OF_PROP);\n}\n\n \nstatic int mctp_i2c_client_try_attach(struct device *dev, void *data)\n{\n\tstruct i2c_adapter *adap = NULL, *root = NULL;\n\tstruct mctp_i2c_client *mcli = data;\n\n\tadap = mctp_i2c_get_adapter(dev, &root);\n\tif (!adap)\n\t\treturn 0;\n\tif (mcli->client->adapter != root)\n\t\treturn 0;\n\t \n\tif (!mctp_i2c_adapter_match(adap, adap == root))\n\t\treturn 0;\n\n\treturn mctp_i2c_add_netdev(mcli, adap);\n}\n\nstatic void mctp_i2c_notify_add(struct device *dev)\n{\n\tstruct mctp_i2c_client *mcli = NULL, *m = NULL;\n\tstruct i2c_adapter *root = NULL, *adap = NULL;\n\tint rc;\n\n\tadap = mctp_i2c_get_adapter(dev, &root);\n\tif (!adap)\n\t\treturn;\n\t \n\tif (!mctp_i2c_adapter_match(adap, false))\n\t\treturn;\n\n\t \n\tmutex_lock(&driver_clients_lock);\n\tlist_for_each_entry(m, &driver_clients, list) {\n\t\tif (m->client->adapter == root) {\n\t\t\tmcli = m;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (mcli) {\n\t\trc = mctp_i2c_add_netdev(mcli, adap);\n\t\tif (rc < 0)\n\t\t\tdev_warn(dev, \"Failed adding mctp-i2c net device\\n\");\n\t}\n\tmutex_unlock(&driver_clients_lock);\n}\n\nstatic void mctp_i2c_notify_del(struct device *dev)\n{\n\tstruct i2c_adapter *root = NULL, *adap = NULL;\n\tstruct mctp_i2c_client *mcli = NULL;\n\n\tadap = mctp_i2c_get_adapter(dev, &root);\n\tif (!adap)\n\t\treturn;\n\n\tmutex_lock(&driver_clients_lock);\n\tlist_for_each_entry(mcli, &driver_clients, list) {\n\t\tif (mcli->client->adapter == root) {\n\t\t\tmctp_i2c_remove_netdev(mcli, adap);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&driver_clients_lock);\n}\n\nstatic int mctp_i2c_probe(struct i2c_client *client)\n{\n\tstruct mctp_i2c_client *mcli = NULL;\n\tint rc;\n\n\tmutex_lock(&driver_clients_lock);\n\tmcli = mctp_i2c_new_client(client);\n\tif (IS_ERR(mcli)) {\n\t\trc = PTR_ERR(mcli);\n\t\tmcli = NULL;\n\t\tgoto out;\n\t} else {\n\t\tlist_add(&mcli->list, &driver_clients);\n\t}\n\n\t \n\ti2c_for_each_dev(mcli, mctp_i2c_client_try_attach);\n\trc = 0;\nout:\n\tmutex_unlock(&driver_clients_lock);\n\treturn rc;\n}\n\nstatic void mctp_i2c_remove(struct i2c_client *client)\n{\n\tstruct mctp_i2c_client *mcli = i2c_get_clientdata(client);\n\tstruct mctp_i2c_dev *midev = NULL, *tmp = NULL;\n\n\tmutex_lock(&driver_clients_lock);\n\tlist_del(&mcli->list);\n\t \n\tlist_for_each_entry_safe(midev, tmp, &mcli->devs, list)\n\t\tmctp_i2c_unregister(midev);\n\n\tmctp_i2c_free_client(mcli);\n\tmutex_unlock(&driver_clients_lock);\n}\n\n \nstatic int mctp_i2c_notifier_call(struct notifier_block *nb,\n\t\t\t\t  unsigned long action, void *data)\n{\n\tstruct device *dev = data;\n\n\tswitch (action) {\n\tcase BUS_NOTIFY_ADD_DEVICE:\n\t\tmctp_i2c_notify_add(dev);\n\t\tbreak;\n\tcase BUS_NOTIFY_DEL_DEVICE:\n\t\tmctp_i2c_notify_del(dev);\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block mctp_i2c_notifier = {\n\t.notifier_call = mctp_i2c_notifier_call,\n};\n\nstatic const struct i2c_device_id mctp_i2c_id[] = {\n\t{ \"mctp-i2c-interface\", 0 },\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, mctp_i2c_id);\n\nstatic const struct of_device_id mctp_i2c_of_match[] = {\n\t{ .compatible = \"mctp-i2c-controller\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mctp_i2c_of_match);\n\nstatic struct i2c_driver mctp_i2c_driver = {\n\t.driver = {\n\t\t.name = \"mctp-i2c-interface\",\n\t\t.of_match_table = mctp_i2c_of_match,\n\t},\n\t.probe = mctp_i2c_probe,\n\t.remove = mctp_i2c_remove,\n\t.id_table = mctp_i2c_id,\n};\n\nstatic __init int mctp_i2c_mod_init(void)\n{\n\tint rc;\n\n\tpr_info(\"MCTP I2C interface driver\\n\");\n\trc = i2c_add_driver(&mctp_i2c_driver);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = bus_register_notifier(&i2c_bus_type, &mctp_i2c_notifier);\n\tif (rc < 0) {\n\t\ti2c_del_driver(&mctp_i2c_driver);\n\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic __exit void mctp_i2c_mod_exit(void)\n{\n\tint rc;\n\n\trc = bus_unregister_notifier(&i2c_bus_type, &mctp_i2c_notifier);\n\tif (rc < 0)\n\t\tpr_warn(\"MCTP I2C could not unregister notifier, %d\\n\", rc);\n\ti2c_del_driver(&mctp_i2c_driver);\n}\n\nmodule_init(mctp_i2c_mod_init);\nmodule_exit(mctp_i2c_mod_exit);\n\nMODULE_DESCRIPTION(\"MCTP I2C device\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Matt Johnston <matt@codeconstruct.com.au>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}