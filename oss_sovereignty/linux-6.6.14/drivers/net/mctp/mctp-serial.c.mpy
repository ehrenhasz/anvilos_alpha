{
  "module_name": "mctp-serial.c",
  "hash_id": "48e5669a5cc7c3125ce2f09ca8c38968d070e757251e4ca521e65eede8957dfb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/mctp/mctp-serial.c",
  "human_readable_source": "\n \n\n#include <linux/idr.h>\n#include <linux/if_arp.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/tty.h>\n#include <linux/workqueue.h>\n#include <linux/crc-ccitt.h>\n\n#include <linux/mctp.h>\n#include <net/mctp.h>\n#include <net/pkt_sched.h>\n\n#define MCTP_SERIAL_MTU\t\t68  \n#define MCTP_SERIAL_FRAME_MTU\t(MCTP_SERIAL_MTU + 6)  \n\n#define MCTP_SERIAL_VERSION\t0x1  \n\n#define BUFSIZE\t\t\tMCTP_SERIAL_FRAME_MTU\n\n#define BYTE_FRAME\t\t0x7e\n#define BYTE_ESC\t\t0x7d\n\n#define FCS_INIT\t\t0xffff\n\nstatic DEFINE_IDA(mctp_serial_ida);\n\nenum mctp_serial_state {\n\tSTATE_IDLE,\n\tSTATE_START,\n\tSTATE_HEADER,\n\tSTATE_DATA,\n\tSTATE_ESCAPE,\n\tSTATE_TRAILER,\n\tSTATE_DONE,\n\tSTATE_ERR,\n};\n\nstruct mctp_serial {\n\tstruct net_device\t*netdev;\n\tstruct tty_struct\t*tty;\n\n\tint\t\t\tidx;\n\n\t \n\tspinlock_t\t\tlock;\n\n\tstruct work_struct\ttx_work;\n\tenum mctp_serial_state\ttxstate, rxstate;\n\tu16\t\t\ttxfcs, rxfcs, rxfcs_rcvd;\n\tunsigned int\t\ttxlen, rxlen;\n\tunsigned int\t\ttxpos, rxpos;\n\tunsigned char\t\ttxbuf[BUFSIZE],\n\t\t\t\trxbuf[BUFSIZE];\n};\n\nstatic bool needs_escape(unsigned char c)\n{\n\treturn c == BYTE_ESC || c == BYTE_FRAME;\n}\n\nstatic int next_chunk_len(struct mctp_serial *dev)\n{\n\tint i;\n\n\t \n\tif (dev->txpos == dev->txlen)\n\t\treturn 0;\n\n\t \n\tif (needs_escape(dev->txbuf[dev->txpos]))\n\t\treturn 1;\n\n\t \n\tfor (i = 1; i + dev->txpos + 1 < dev->txlen; i++) {\n\t\tif (needs_escape(dev->txbuf[dev->txpos + i + 1]))\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}\n\nstatic int write_chunk(struct mctp_serial *dev, unsigned char *buf, int len)\n{\n\treturn dev->tty->ops->write(dev->tty, buf, len);\n}\n\nstatic void mctp_serial_tx_work(struct work_struct *work)\n{\n\tstruct mctp_serial *dev = container_of(work, struct mctp_serial,\n\t\t\t\t\t       tx_work);\n\tunsigned char c, buf[3];\n\tunsigned long flags;\n\tint len, txlen;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\t \n\tswitch (dev->txstate) {\n\tcase STATE_START:\n\t\tdev->txpos = 0;\n\t\tfallthrough;\n\tcase STATE_HEADER:\n\t\tbuf[0] = BYTE_FRAME;\n\t\tbuf[1] = MCTP_SERIAL_VERSION;\n\t\tbuf[2] = dev->txlen;\n\n\t\tif (!dev->txpos)\n\t\t\tdev->txfcs = crc_ccitt(FCS_INIT, buf + 1, 2);\n\n\t\ttxlen = write_chunk(dev, buf + dev->txpos, 3 - dev->txpos);\n\t\tif (txlen <= 0) {\n\t\t\tdev->txstate = STATE_ERR;\n\t\t} else {\n\t\t\tdev->txpos += txlen;\n\t\t\tif (dev->txpos == 3) {\n\t\t\t\tdev->txstate = STATE_DATA;\n\t\t\t\tdev->txpos = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase STATE_ESCAPE:\n\t\tbuf[0] = dev->txbuf[dev->txpos] & ~0x20;\n\t\ttxlen = write_chunk(dev, buf, 1);\n\t\tif (txlen <= 0) {\n\t\t\tdev->txstate = STATE_ERR;\n\t\t} else {\n\t\t\tdev->txpos += txlen;\n\t\t\tif (dev->txpos == dev->txlen) {\n\t\t\t\tdev->txstate = STATE_TRAILER;\n\t\t\t\tdev->txpos = 0;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tcase STATE_DATA:\n\t\tlen = next_chunk_len(dev);\n\t\tif (len) {\n\t\t\tc = dev->txbuf[dev->txpos];\n\t\t\tif (len == 1 && needs_escape(c)) {\n\t\t\t\tbuf[0] = BYTE_ESC;\n\t\t\t\tbuf[1] = c & ~0x20;\n\t\t\t\tdev->txfcs = crc_ccitt_byte(dev->txfcs, c);\n\t\t\t\ttxlen = write_chunk(dev, buf, 2);\n\t\t\t\tif (txlen == 2)\n\t\t\t\t\tdev->txpos++;\n\t\t\t\telse if (txlen == 1)\n\t\t\t\t\tdev->txstate = STATE_ESCAPE;\n\t\t\t\telse\n\t\t\t\t\tdev->txstate = STATE_ERR;\n\t\t\t} else {\n\t\t\t\ttxlen = write_chunk(dev,\n\t\t\t\t\t\t    dev->txbuf + dev->txpos,\n\t\t\t\t\t\t    len);\n\t\t\t\tif (txlen <= 0) {\n\t\t\t\t\tdev->txstate = STATE_ERR;\n\t\t\t\t} else {\n\t\t\t\t\tdev->txfcs = crc_ccitt(dev->txfcs,\n\t\t\t\t\t\t\t       dev->txbuf +\n\t\t\t\t\t\t\t       dev->txpos,\n\t\t\t\t\t\t\t       txlen);\n\t\t\t\t\tdev->txpos += txlen;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dev->txstate == STATE_DATA &&\n\t\t\t    dev->txpos == dev->txlen) {\n\t\t\t\tdev->txstate = STATE_TRAILER;\n\t\t\t\tdev->txpos = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tdev->txstate = STATE_TRAILER;\n\t\tdev->txpos = 0;\n\t\tfallthrough;\n\n\tcase STATE_TRAILER:\n\t\tbuf[0] = dev->txfcs >> 8;\n\t\tbuf[1] = dev->txfcs & 0xff;\n\t\tbuf[2] = BYTE_FRAME;\n\t\ttxlen = write_chunk(dev, buf + dev->txpos, 3 - dev->txpos);\n\t\tif (txlen <= 0) {\n\t\t\tdev->txstate = STATE_ERR;\n\t\t} else {\n\t\t\tdev->txpos += txlen;\n\t\t\tif (dev->txpos == 3) {\n\t\t\t\tdev->txstate = STATE_DONE;\n\t\t\t\tdev->txpos = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err_once(dev->netdev, \"invalid tx state %d\\n\",\n\t\t\t\tdev->txstate);\n\t}\n\n\tif (dev->txstate == STATE_DONE) {\n\t\tdev->netdev->stats.tx_packets++;\n\t\tdev->netdev->stats.tx_bytes += dev->txlen;\n\t\tdev->txlen = 0;\n\t\tdev->txpos = 0;\n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &dev->tty->flags);\n\t\tdev->txstate = STATE_IDLE;\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\tnetif_wake_queue(dev->netdev);\n\t} else {\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t}\n}\n\nstatic netdev_tx_t mctp_serial_tx(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct mctp_serial *dev = netdev_priv(ndev);\n\tunsigned long flags;\n\n\tWARN_ON(dev->txstate != STATE_IDLE);\n\n\tif (skb->len > MCTP_SERIAL_MTU) {\n\t\tdev->netdev->stats.tx_dropped++;\n\t\tgoto out;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tnetif_stop_queue(dev->netdev);\n\tskb_copy_bits(skb, 0, dev->txbuf, skb->len);\n\tdev->txpos = 0;\n\tdev->txlen = skb->len;\n\tdev->txstate = STATE_START;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tset_bit(TTY_DO_WRITE_WAKEUP, &dev->tty->flags);\n\tschedule_work(&dev->tx_work);\n\nout:\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void mctp_serial_tty_write_wakeup(struct tty_struct *tty)\n{\n\tstruct mctp_serial *dev = tty->disc_data;\n\n\tschedule_work(&dev->tx_work);\n}\n\nstatic void mctp_serial_rx(struct mctp_serial *dev)\n{\n\tstruct mctp_skb_cb *cb;\n\tstruct sk_buff *skb;\n\n\tif (dev->rxfcs != dev->rxfcs_rcvd) {\n\t\tdev->netdev->stats.rx_dropped++;\n\t\tdev->netdev->stats.rx_crc_errors++;\n\t\treturn;\n\t}\n\n\tskb = netdev_alloc_skb(dev->netdev, dev->rxlen);\n\tif (!skb) {\n\t\tdev->netdev->stats.rx_dropped++;\n\t\treturn;\n\t}\n\n\tskb->protocol = htons(ETH_P_MCTP);\n\tskb_put_data(skb, dev->rxbuf, dev->rxlen);\n\tskb_reset_network_header(skb);\n\n\tcb = __mctp_cb(skb);\n\tcb->halen = 0;\n\n\tnetif_rx(skb);\n\tdev->netdev->stats.rx_packets++;\n\tdev->netdev->stats.rx_bytes += dev->rxlen;\n}\n\nstatic void mctp_serial_push_header(struct mctp_serial *dev, unsigned char c)\n{\n\tswitch (dev->rxpos) {\n\tcase 0:\n\t\tif (c == BYTE_FRAME)\n\t\t\tdev->rxpos++;\n\t\telse\n\t\t\tdev->rxstate = STATE_ERR;\n\t\tbreak;\n\tcase 1:\n\t\tif (c == MCTP_SERIAL_VERSION) {\n\t\t\tdev->rxpos++;\n\t\t\tdev->rxfcs = crc_ccitt_byte(FCS_INIT, c);\n\t\t} else {\n\t\t\tdev->rxstate = STATE_ERR;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif (c > MCTP_SERIAL_FRAME_MTU) {\n\t\t\tdev->rxstate = STATE_ERR;\n\t\t} else {\n\t\t\tdev->rxlen = c;\n\t\t\tdev->rxpos = 0;\n\t\t\tdev->rxstate = STATE_DATA;\n\t\t\tdev->rxfcs = crc_ccitt_byte(dev->rxfcs, c);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void mctp_serial_push_trailer(struct mctp_serial *dev, unsigned char c)\n{\n\tswitch (dev->rxpos) {\n\tcase 0:\n\t\tdev->rxfcs_rcvd = c << 8;\n\t\tdev->rxpos++;\n\t\tbreak;\n\tcase 1:\n\t\tdev->rxfcs_rcvd |= c;\n\t\tdev->rxpos++;\n\t\tbreak;\n\tcase 2:\n\t\tif (c != BYTE_FRAME) {\n\t\t\tdev->rxstate = STATE_ERR;\n\t\t} else {\n\t\t\tmctp_serial_rx(dev);\n\t\t\tdev->rxlen = 0;\n\t\t\tdev->rxpos = 0;\n\t\t\tdev->rxstate = STATE_IDLE;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void mctp_serial_push(struct mctp_serial *dev, unsigned char c)\n{\n\tswitch (dev->rxstate) {\n\tcase STATE_IDLE:\n\t\tdev->rxstate = STATE_HEADER;\n\t\tfallthrough;\n\tcase STATE_HEADER:\n\t\tmctp_serial_push_header(dev, c);\n\t\tbreak;\n\n\tcase STATE_ESCAPE:\n\t\tc |= 0x20;\n\t\tfallthrough;\n\tcase STATE_DATA:\n\t\tif (dev->rxstate != STATE_ESCAPE && c == BYTE_ESC) {\n\t\t\tdev->rxstate = STATE_ESCAPE;\n\t\t} else {\n\t\t\tdev->rxfcs = crc_ccitt_byte(dev->rxfcs, c);\n\t\t\tdev->rxbuf[dev->rxpos] = c;\n\t\t\tdev->rxpos++;\n\t\t\tdev->rxstate = STATE_DATA;\n\t\t\tif (dev->rxpos == dev->rxlen) {\n\t\t\t\tdev->rxpos = 0;\n\t\t\t\tdev->rxstate = STATE_TRAILER;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase STATE_TRAILER:\n\t\tmctp_serial_push_trailer(dev, c);\n\t\tbreak;\n\n\tcase STATE_ERR:\n\t\tif (c == BYTE_FRAME)\n\t\t\tdev->rxstate = STATE_IDLE;\n\t\tbreak;\n\n\tdefault:\n\t\tnetdev_err_once(dev->netdev, \"invalid rx state %d\\n\",\n\t\t\t\tdev->rxstate);\n\t}\n}\n\nstatic void mctp_serial_tty_receive_buf(struct tty_struct *tty, const u8 *c,\n\t\t\t\t\tconst u8 *f, size_t len)\n{\n\tstruct mctp_serial *dev = tty->disc_data;\n\tint i;\n\n\tif (!netif_running(dev->netdev))\n\t\treturn;\n\n\t \n\tfor (i = 0; i < len; i++)\n\t\tmctp_serial_push(dev, c[i]);\n}\n\nstatic void mctp_serial_uninit(struct net_device *ndev)\n{\n\tstruct mctp_serial *dev = netdev_priv(ndev);\n\n\tcancel_work_sync(&dev->tx_work);\n}\n\nstatic const struct net_device_ops mctp_serial_netdev_ops = {\n\t.ndo_start_xmit = mctp_serial_tx,\n\t.ndo_uninit = mctp_serial_uninit,\n};\n\nstatic void mctp_serial_setup(struct net_device *ndev)\n{\n\tndev->type = ARPHRD_MCTP;\n\n\t \n\tndev->mtu = MCTP_SERIAL_MTU;\n\tndev->max_mtu = MCTP_SERIAL_MTU;\n\tndev->min_mtu = MCTP_SERIAL_MTU;\n\n\tndev->hard_header_len = 0;\n\tndev->addr_len = 0;\n\tndev->tx_queue_len = DEFAULT_TX_QUEUE_LEN;\n\tndev->flags = IFF_NOARP;\n\tndev->netdev_ops = &mctp_serial_netdev_ops;\n\tndev->needs_free_netdev = true;\n}\n\nstatic int mctp_serial_open(struct tty_struct *tty)\n{\n\tstruct mctp_serial *dev;\n\tstruct net_device *ndev;\n\tchar name[32];\n\tint idx, rc;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!tty->ops->write)\n\t\treturn -EOPNOTSUPP;\n\n\tidx = ida_alloc(&mctp_serial_ida, GFP_KERNEL);\n\tif (idx < 0)\n\t\treturn idx;\n\n\tsnprintf(name, sizeof(name), \"mctpserial%d\", idx);\n\tndev = alloc_netdev(sizeof(*dev), name, NET_NAME_ENUM,\n\t\t\t    mctp_serial_setup);\n\tif (!ndev) {\n\t\trc = -ENOMEM;\n\t\tgoto free_ida;\n\t}\n\n\tdev = netdev_priv(ndev);\n\tdev->idx = idx;\n\tdev->tty = tty;\n\tdev->netdev = ndev;\n\tdev->txstate = STATE_IDLE;\n\tdev->rxstate = STATE_IDLE;\n\tspin_lock_init(&dev->lock);\n\tINIT_WORK(&dev->tx_work, mctp_serial_tx_work);\n\n\trc = register_netdev(ndev);\n\tif (rc)\n\t\tgoto free_netdev;\n\n\ttty->receive_room = 64 * 1024;\n\ttty->disc_data = dev;\n\n\treturn 0;\n\nfree_netdev:\n\tfree_netdev(ndev);\n\nfree_ida:\n\tida_free(&mctp_serial_ida, idx);\n\treturn rc;\n}\n\nstatic void mctp_serial_close(struct tty_struct *tty)\n{\n\tstruct mctp_serial *dev = tty->disc_data;\n\tint idx = dev->idx;\n\n\tunregister_netdev(dev->netdev);\n\tida_free(&mctp_serial_ida, idx);\n}\n\nstatic struct tty_ldisc_ops mctp_ldisc = {\n\t.owner\t\t= THIS_MODULE,\n\t.num\t\t= N_MCTP,\n\t.name\t\t= \"mctp\",\n\t.open\t\t= mctp_serial_open,\n\t.close\t\t= mctp_serial_close,\n\t.receive_buf\t= mctp_serial_tty_receive_buf,\n\t.write_wakeup\t= mctp_serial_tty_write_wakeup,\n};\n\nstatic int __init mctp_serial_init(void)\n{\n\treturn tty_register_ldisc(&mctp_ldisc);\n}\n\nstatic void __exit mctp_serial_exit(void)\n{\n\ttty_unregister_ldisc(&mctp_ldisc);\n}\n\nmodule_init(mctp_serial_init);\nmodule_exit(mctp_serial_exit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Jeremy Kerr <jk@codeconstruct.com.au>\");\nMODULE_DESCRIPTION(\"MCTP Serial transport\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}