{
  "module_name": "eql.c",
  "hash_id": "b084d5c48a9e2a725d90f69b4ffb75208e0d0208925254f1ebec2f1b6e490a96",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/eql.c",
  "human_readable_source": " \n\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/compat.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/netdevice.h>\n#include <net/net_namespace.h>\n\n#include <linux/if.h>\n#include <linux/if_arp.h>\n#include <linux/if_eql.h>\n#include <linux/pkt_sched.h>\n\n#include <linux/uaccess.h>\n\nstatic int eql_open(struct net_device *dev);\nstatic int eql_close(struct net_device *dev);\nstatic int eql_siocdevprivate(struct net_device *dev, struct ifreq *ifr,\n\t\t\t      void __user *data, int cmd);\nstatic netdev_tx_t eql_slave_xmit(struct sk_buff *skb, struct net_device *dev);\n\n#define eql_is_slave(dev)\t((dev->flags & IFF_SLAVE) == IFF_SLAVE)\n#define eql_is_master(dev)\t((dev->flags & IFF_MASTER) == IFF_MASTER)\n\nstatic void eql_kill_one_slave(slave_queue_t *queue, slave_t *slave);\n\nstatic void eql_timer(struct timer_list *t)\n{\n\tequalizer_t *eql = from_timer(eql, t, timer);\n\tstruct list_head *this, *tmp, *head;\n\n\tspin_lock(&eql->queue.lock);\n\thead = &eql->queue.all_slaves;\n\tlist_for_each_safe(this, tmp, head) {\n\t\tslave_t *slave = list_entry(this, slave_t, list);\n\n\t\tif ((slave->dev->flags & IFF_UP) == IFF_UP) {\n\t\t\tslave->bytes_queued -= slave->priority_Bps;\n\t\t\tif (slave->bytes_queued < 0)\n\t\t\t\tslave->bytes_queued = 0;\n\t\t} else {\n\t\t\teql_kill_one_slave(&eql->queue, slave);\n\t\t}\n\n\t}\n\tspin_unlock(&eql->queue.lock);\n\n\teql->timer.expires = jiffies + EQL_DEFAULT_RESCHED_IVAL;\n\tadd_timer(&eql->timer);\n}\n\nstatic const char version[] __initconst =\n\t\"Equalizer2002: Simon Janes (simon@ncm.com) and David S. Miller (davem@redhat.com)\";\n\nstatic const struct net_device_ops eql_netdev_ops = {\n\t.ndo_open\t= eql_open,\n\t.ndo_stop\t= eql_close,\n\t.ndo_siocdevprivate = eql_siocdevprivate,\n\t.ndo_start_xmit\t= eql_slave_xmit,\n};\n\nstatic void __init eql_setup(struct net_device *dev)\n{\n\tequalizer_t *eql = netdev_priv(dev);\n\n\ttimer_setup(&eql->timer, eql_timer, 0);\n\teql->timer.expires  \t= jiffies + EQL_DEFAULT_RESCHED_IVAL;\n\n\tspin_lock_init(&eql->queue.lock);\n\tINIT_LIST_HEAD(&eql->queue.all_slaves);\n\teql->queue.master_dev\t= dev;\n\n\tdev->netdev_ops\t\t= &eql_netdev_ops;\n\n\t \n\n\tdev->mtu        \t= EQL_DEFAULT_MTU;\t \n\tdev->flags      \t= IFF_MASTER;\n\n\tdev->type       \t= ARPHRD_SLIP;\n\tdev->tx_queue_len \t= 5;\t\t \n\tnetif_keep_dst(dev);\n}\n\nstatic int eql_open(struct net_device *dev)\n{\n\tequalizer_t *eql = netdev_priv(dev);\n\n\t \n\tnetdev_info(dev,\n\t\t    \"remember to turn off Van-Jacobson compression on your slave devices\\n\");\n\n\tBUG_ON(!list_empty(&eql->queue.all_slaves));\n\n\teql->min_slaves = 1;\n\teql->max_slaves = EQL_DEFAULT_MAX_SLAVES;  \n\n\tadd_timer(&eql->timer);\n\n\treturn 0;\n}\n\nstatic void eql_kill_one_slave(slave_queue_t *queue, slave_t *slave)\n{\n\tlist_del(&slave->list);\n\tqueue->num_slaves--;\n\tslave->dev->flags &= ~IFF_SLAVE;\n\tnetdev_put(slave->dev, &slave->dev_tracker);\n\tkfree(slave);\n}\n\nstatic void eql_kill_slave_queue(slave_queue_t *queue)\n{\n\tstruct list_head *head, *tmp, *this;\n\n\tspin_lock_bh(&queue->lock);\n\n\thead = &queue->all_slaves;\n\tlist_for_each_safe(this, tmp, head) {\n\t\tslave_t *s = list_entry(this, slave_t, list);\n\n\t\teql_kill_one_slave(queue, s);\n\t}\n\n\tspin_unlock_bh(&queue->lock);\n}\n\nstatic int eql_close(struct net_device *dev)\n{\n\tequalizer_t *eql = netdev_priv(dev);\n\n\t \n\n\tdel_timer_sync(&eql->timer);\n\n\teql_kill_slave_queue(&eql->queue);\n\n\treturn 0;\n}\n\nstatic int eql_enslave(struct net_device *dev,  slaving_request_t __user *srq);\nstatic int eql_emancipate(struct net_device *dev, slaving_request_t __user *srq);\n\nstatic int eql_g_slave_cfg(struct net_device *dev, slave_config_t __user *sc);\nstatic int eql_s_slave_cfg(struct net_device *dev, slave_config_t __user *sc);\n\nstatic int eql_g_master_cfg(struct net_device *dev, master_config_t __user *mc);\nstatic int eql_s_master_cfg(struct net_device *dev, master_config_t __user *mc);\n\nstatic int eql_siocdevprivate(struct net_device *dev, struct ifreq *ifr,\n\t\t\t      void __user *data, int cmd)\n{\n\tif (cmd != EQL_GETMASTRCFG && cmd != EQL_GETSLAVECFG &&\n\t    !capable(CAP_NET_ADMIN))\n\t  \treturn -EPERM;\n\n\tif (in_compat_syscall())  \n\t\treturn -EOPNOTSUPP;\n\n\tswitch (cmd) {\n\t\tcase EQL_ENSLAVE:\n\t\t\treturn eql_enslave(dev, data);\n\t\tcase EQL_EMANCIPATE:\n\t\t\treturn eql_emancipate(dev, data);\n\t\tcase EQL_GETSLAVECFG:\n\t\t\treturn eql_g_slave_cfg(dev, data);\n\t\tcase EQL_SETSLAVECFG:\n\t\t\treturn eql_s_slave_cfg(dev, data);\n\t\tcase EQL_GETMASTRCFG:\n\t\t\treturn eql_g_master_cfg(dev, data);\n\t\tcase EQL_SETMASTRCFG:\n\t\t\treturn eql_s_master_cfg(dev, data);\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n \nstatic slave_t *__eql_schedule_slaves(slave_queue_t *queue)\n{\n\tunsigned long best_load = ~0UL;\n\tstruct list_head *this, *tmp, *head;\n\tslave_t *best_slave;\n\n\tbest_slave = NULL;\n\n\t \n\thead = &queue->all_slaves;\n\tlist_for_each_safe(this, tmp, head) {\n\t\tslave_t *slave = list_entry(this, slave_t, list);\n\t\tunsigned long slave_load, bytes_queued, priority_Bps;\n\n\t\t \n\t\tbytes_queued = slave->bytes_queued;\n\t\tpriority_Bps = slave->priority_Bps;\n\t\tif ((slave->dev->flags & IFF_UP) == IFF_UP) {\n\t\t\tslave_load = (~0UL - (~0UL / 2)) -\n\t\t\t\t(priority_Bps) + bytes_queued * 8;\n\n\t\t\tif (slave_load < best_load) {\n\t\t\t\tbest_load = slave_load;\n\t\t\t\tbest_slave = slave;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\teql_kill_one_slave(queue, slave);\n\t\t}\n\t}\n\treturn best_slave;\n}\n\nstatic netdev_tx_t eql_slave_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tequalizer_t *eql = netdev_priv(dev);\n\tslave_t *slave;\n\n\tspin_lock(&eql->queue.lock);\n\n\tslave = __eql_schedule_slaves(&eql->queue);\n\tif (slave) {\n\t\tstruct net_device *slave_dev = slave->dev;\n\n\t\tskb->dev = slave_dev;\n\t\tskb->priority = TC_PRIO_FILLER;\n\t\tslave->bytes_queued += skb->len;\n\t\tdev_queue_xmit(skb);\n\t\tdev->stats.tx_packets++;\n\t} else {\n\t\tdev->stats.tx_dropped++;\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tspin_unlock(&eql->queue.lock);\n\n\treturn NETDEV_TX_OK;\n}\n\n \n\n \nstatic slave_t *__eql_find_slave_dev(slave_queue_t *queue, struct net_device *dev)\n{\n\tstruct list_head *this, *head;\n\n\thead = &queue->all_slaves;\n\tlist_for_each(this, head) {\n\t\tslave_t *slave = list_entry(this, slave_t, list);\n\n\t\tif (slave->dev == dev)\n\t\t\treturn slave;\n\t}\n\n\treturn NULL;\n}\n\nstatic inline int eql_is_full(slave_queue_t *queue)\n{\n\tequalizer_t *eql = netdev_priv(queue->master_dev);\n\n\tif (queue->num_slaves >= eql->max_slaves)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic int __eql_insert_slave(slave_queue_t *queue, slave_t *slave)\n{\n\tif (!eql_is_full(queue)) {\n\t\tslave_t *duplicate_slave = NULL;\n\n\t\tduplicate_slave = __eql_find_slave_dev(queue, slave->dev);\n\t\tif (duplicate_slave)\n\t\t\teql_kill_one_slave(queue, duplicate_slave);\n\n\t\tnetdev_hold(slave->dev, &slave->dev_tracker, GFP_ATOMIC);\n\t\tlist_add(&slave->list, &queue->all_slaves);\n\t\tqueue->num_slaves++;\n\t\tslave->dev->flags |= IFF_SLAVE;\n\n\t\treturn 0;\n\t}\n\n\treturn -ENOSPC;\n}\n\nstatic int eql_enslave(struct net_device *master_dev, slaving_request_t __user *srqp)\n{\n\tstruct net_device *slave_dev;\n\tslaving_request_t srq;\n\n\tif (copy_from_user(&srq, srqp, sizeof (slaving_request_t)))\n\t\treturn -EFAULT;\n\n\tslave_dev = __dev_get_by_name(&init_net, srq.slave_name);\n\tif (!slave_dev)\n\t\treturn -ENODEV;\n\n\tif ((master_dev->flags & IFF_UP) == IFF_UP) {\n\t\t \n\t\tif (!eql_is_master(slave_dev) && !eql_is_slave(slave_dev)) {\n\t\t\tslave_t *s = kzalloc(sizeof(*s), GFP_KERNEL);\n\t\t\tequalizer_t *eql = netdev_priv(master_dev);\n\t\t\tint ret;\n\n\t\t\tif (!s)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\ts->dev = slave_dev;\n\t\t\ts->priority = srq.priority;\n\t\t\ts->priority_bps = srq.priority;\n\t\t\ts->priority_Bps = srq.priority / 8;\n\n\t\t\tspin_lock_bh(&eql->queue.lock);\n\t\t\tret = __eql_insert_slave(&eql->queue, s);\n\t\t\tif (ret)\n\t\t\t\tkfree(s);\n\n\t\t\tspin_unlock_bh(&eql->queue.lock);\n\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int eql_emancipate(struct net_device *master_dev, slaving_request_t __user *srqp)\n{\n\tequalizer_t *eql = netdev_priv(master_dev);\n\tstruct net_device *slave_dev;\n\tslaving_request_t srq;\n\tint ret;\n\n\tif (copy_from_user(&srq, srqp, sizeof (slaving_request_t)))\n\t\treturn -EFAULT;\n\n\tslave_dev = __dev_get_by_name(&init_net, srq.slave_name);\n\tif (!slave_dev)\n\t\treturn -ENODEV;\n\n\tret = -EINVAL;\n\tspin_lock_bh(&eql->queue.lock);\n\tif (eql_is_slave(slave_dev)) {\n\t\tslave_t *slave = __eql_find_slave_dev(&eql->queue, slave_dev);\n\t\tif (slave) {\n\t\t\teql_kill_one_slave(&eql->queue, slave);\n\t\t\tret = 0;\n\t\t}\n\t}\n\tspin_unlock_bh(&eql->queue.lock);\n\n\treturn ret;\n}\n\nstatic int eql_g_slave_cfg(struct net_device *dev, slave_config_t __user *scp)\n{\n\tequalizer_t *eql = netdev_priv(dev);\n\tslave_t *slave;\n\tstruct net_device *slave_dev;\n\tslave_config_t sc;\n\tint ret;\n\n\tif (copy_from_user(&sc, scp, sizeof (slave_config_t)))\n\t\treturn -EFAULT;\n\n\tslave_dev = __dev_get_by_name(&init_net, sc.slave_name);\n\tif (!slave_dev)\n\t\treturn -ENODEV;\n\n\tret = -EINVAL;\n\n\tspin_lock_bh(&eql->queue.lock);\n\tif (eql_is_slave(slave_dev)) {\n\t\tslave = __eql_find_slave_dev(&eql->queue, slave_dev);\n\t\tif (slave) {\n\t\t\tsc.priority = slave->priority;\n\t\t\tret = 0;\n\t\t}\n\t}\n\tspin_unlock_bh(&eql->queue.lock);\n\n\tif (!ret && copy_to_user(scp, &sc, sizeof (slave_config_t)))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}\n\nstatic int eql_s_slave_cfg(struct net_device *dev, slave_config_t __user *scp)\n{\n\tslave_t *slave;\n\tequalizer_t *eql;\n\tstruct net_device *slave_dev;\n\tslave_config_t sc;\n\tint ret;\n\n\tif (copy_from_user(&sc, scp, sizeof (slave_config_t)))\n\t\treturn -EFAULT;\n\n\tslave_dev = __dev_get_by_name(&init_net, sc.slave_name);\n\tif (!slave_dev)\n\t\treturn -ENODEV;\n\n\tret = -EINVAL;\n\n\teql = netdev_priv(dev);\n\tspin_lock_bh(&eql->queue.lock);\n\tif (eql_is_slave(slave_dev)) {\n\t\tslave = __eql_find_slave_dev(&eql->queue, slave_dev);\n\t\tif (slave) {\n\t\t\tslave->priority = sc.priority;\n\t\t\tslave->priority_bps = sc.priority;\n\t\t\tslave->priority_Bps = sc.priority / 8;\n\t\t\tret = 0;\n\t\t}\n\t}\n\tspin_unlock_bh(&eql->queue.lock);\n\n\treturn ret;\n}\n\nstatic int eql_g_master_cfg(struct net_device *dev, master_config_t __user *mcp)\n{\n\tequalizer_t *eql;\n\tmaster_config_t mc;\n\n\tmemset(&mc, 0, sizeof(master_config_t));\n\n\tif (eql_is_master(dev)) {\n\t\teql = netdev_priv(dev);\n\t\tmc.max_slaves = eql->max_slaves;\n\t\tmc.min_slaves = eql->min_slaves;\n\t\tif (copy_to_user(mcp, &mc, sizeof (master_config_t)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int eql_s_master_cfg(struct net_device *dev, master_config_t __user *mcp)\n{\n\tequalizer_t *eql;\n\tmaster_config_t mc;\n\n\tif (copy_from_user(&mc, mcp, sizeof (master_config_t)))\n\t\treturn -EFAULT;\n\n\tif (eql_is_master(dev)) {\n\t\teql = netdev_priv(dev);\n\t\teql->max_slaves = mc.max_slaves;\n\t\teql->min_slaves = mc.min_slaves;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic struct net_device *dev_eql;\n\nstatic int __init eql_init_module(void)\n{\n\tint err;\n\n\tpr_info(\"%s\\n\", version);\n\n\tdev_eql = alloc_netdev(sizeof(equalizer_t), \"eql\", NET_NAME_UNKNOWN,\n\t\t\t       eql_setup);\n\tif (!dev_eql)\n\t\treturn -ENOMEM;\n\n\terr = register_netdev(dev_eql);\n\tif (err)\n\t\tfree_netdev(dev_eql);\n\treturn err;\n}\n\nstatic void __exit eql_cleanup_module(void)\n{\n\tunregister_netdev(dev_eql);\n\tfree_netdev(dev_eql);\n}\n\nmodule_init(eql_init_module);\nmodule_exit(eql_cleanup_module);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}