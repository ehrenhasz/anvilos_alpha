{
  "module_name": "allowedips.c",
  "hash_id": "ecdbd436c0834b5a52c9fa08c200539f7708655541f2c0ccac092dc2130699d7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireguard/allowedips.c",
  "human_readable_source": "\n \n\n#include \"allowedips.h\"\n#include \"peer.h\"\n\nenum { MAX_ALLOWEDIPS_DEPTH = 129 };\n\nstatic struct kmem_cache *node_cache;\n\nstatic void swap_endian(u8 *dst, const u8 *src, u8 bits)\n{\n\tif (bits == 32) {\n\t\t*(u32 *)dst = be32_to_cpu(*(const __be32 *)src);\n\t} else if (bits == 128) {\n\t\t((u64 *)dst)[0] = be64_to_cpu(((const __be64 *)src)[0]);\n\t\t((u64 *)dst)[1] = be64_to_cpu(((const __be64 *)src)[1]);\n\t}\n}\n\nstatic void copy_and_assign_cidr(struct allowedips_node *node, const u8 *src,\n\t\t\t\t u8 cidr, u8 bits)\n{\n\tnode->cidr = cidr;\n\tnode->bit_at_a = cidr / 8U;\n#ifdef __LITTLE_ENDIAN\n\tnode->bit_at_a ^= (bits / 8U - 1U) % 8U;\n#endif\n\tnode->bit_at_b = 7U - (cidr % 8U);\n\tnode->bitlen = bits;\n\tmemcpy(node->bits, src, bits / 8U);\n}\n\nstatic inline u8 choose(struct allowedips_node *node, const u8 *key)\n{\n\treturn (key[node->bit_at_a] >> node->bit_at_b) & 1;\n}\n\nstatic void push_rcu(struct allowedips_node **stack,\n\t\t     struct allowedips_node __rcu *p, unsigned int *len)\n{\n\tif (rcu_access_pointer(p)) {\n\t\tif (WARN_ON(IS_ENABLED(DEBUG) && *len >= MAX_ALLOWEDIPS_DEPTH))\n\t\t\treturn;\n\t\tstack[(*len)++] = rcu_dereference_raw(p);\n\t}\n}\n\nstatic void node_free_rcu(struct rcu_head *rcu)\n{\n\tkmem_cache_free(node_cache, container_of(rcu, struct allowedips_node, rcu));\n}\n\nstatic void root_free_rcu(struct rcu_head *rcu)\n{\n\tstruct allowedips_node *node, *stack[MAX_ALLOWEDIPS_DEPTH] = {\n\t\tcontainer_of(rcu, struct allowedips_node, rcu) };\n\tunsigned int len = 1;\n\n\twhile (len > 0 && (node = stack[--len])) {\n\t\tpush_rcu(stack, node->bit[0], &len);\n\t\tpush_rcu(stack, node->bit[1], &len);\n\t\tkmem_cache_free(node_cache, node);\n\t}\n}\n\nstatic void root_remove_peer_lists(struct allowedips_node *root)\n{\n\tstruct allowedips_node *node, *stack[MAX_ALLOWEDIPS_DEPTH] = { root };\n\tunsigned int len = 1;\n\n\twhile (len > 0 && (node = stack[--len])) {\n\t\tpush_rcu(stack, node->bit[0], &len);\n\t\tpush_rcu(stack, node->bit[1], &len);\n\t\tif (rcu_access_pointer(node->peer))\n\t\t\tlist_del(&node->peer_list);\n\t}\n}\n\nstatic unsigned int fls128(u64 a, u64 b)\n{\n\treturn a ? fls64(a) + 64U : fls64(b);\n}\n\nstatic u8 common_bits(const struct allowedips_node *node, const u8 *key,\n\t\t      u8 bits)\n{\n\tif (bits == 32)\n\t\treturn 32U - fls(*(const u32 *)node->bits ^ *(const u32 *)key);\n\telse if (bits == 128)\n\t\treturn 128U - fls128(\n\t\t\t*(const u64 *)&node->bits[0] ^ *(const u64 *)&key[0],\n\t\t\t*(const u64 *)&node->bits[8] ^ *(const u64 *)&key[8]);\n\treturn 0;\n}\n\nstatic bool prefix_matches(const struct allowedips_node *node, const u8 *key,\n\t\t\t   u8 bits)\n{\n\t \n\treturn common_bits(node, key, bits) >= node->cidr;\n}\n\nstatic struct allowedips_node *find_node(struct allowedips_node *trie, u8 bits,\n\t\t\t\t\t const u8 *key)\n{\n\tstruct allowedips_node *node = trie, *found = NULL;\n\n\twhile (node && prefix_matches(node, key, bits)) {\n\t\tif (rcu_access_pointer(node->peer))\n\t\t\tfound = node;\n\t\tif (node->cidr == bits)\n\t\t\tbreak;\n\t\tnode = rcu_dereference_bh(node->bit[choose(node, key)]);\n\t}\n\treturn found;\n}\n\n \nstatic struct wg_peer *lookup(struct allowedips_node __rcu *root, u8 bits,\n\t\t\t      const void *be_ip)\n{\n\t \n\tu8 ip[16] __aligned(__alignof(u64));\n\tstruct allowedips_node *node;\n\tstruct wg_peer *peer = NULL;\n\n\tswap_endian(ip, be_ip, bits);\n\n\trcu_read_lock_bh();\nretry:\n\tnode = find_node(rcu_dereference_bh(root), bits, ip);\n\tif (node) {\n\t\tpeer = wg_peer_get_maybe_zero(rcu_dereference_bh(node->peer));\n\t\tif (!peer)\n\t\t\tgoto retry;\n\t}\n\trcu_read_unlock_bh();\n\treturn peer;\n}\n\nstatic bool node_placement(struct allowedips_node __rcu *trie, const u8 *key,\n\t\t\t   u8 cidr, u8 bits, struct allowedips_node **rnode,\n\t\t\t   struct mutex *lock)\n{\n\tstruct allowedips_node *node = rcu_dereference_protected(trie, lockdep_is_held(lock));\n\tstruct allowedips_node *parent = NULL;\n\tbool exact = false;\n\n\twhile (node && node->cidr <= cidr && prefix_matches(node, key, bits)) {\n\t\tparent = node;\n\t\tif (parent->cidr == cidr) {\n\t\t\texact = true;\n\t\t\tbreak;\n\t\t}\n\t\tnode = rcu_dereference_protected(parent->bit[choose(parent, key)], lockdep_is_held(lock));\n\t}\n\t*rnode = parent;\n\treturn exact;\n}\n\nstatic inline void connect_node(struct allowedips_node __rcu **parent, u8 bit, struct allowedips_node *node)\n{\n\tnode->parent_bit_packed = (unsigned long)parent | bit;\n\trcu_assign_pointer(*parent, node);\n}\n\nstatic inline void choose_and_connect_node(struct allowedips_node *parent, struct allowedips_node *node)\n{\n\tu8 bit = choose(parent, node->bits);\n\tconnect_node(&parent->bit[bit], bit, node);\n}\n\nstatic int add(struct allowedips_node __rcu **trie, u8 bits, const u8 *key,\n\t       u8 cidr, struct wg_peer *peer, struct mutex *lock)\n{\n\tstruct allowedips_node *node, *parent, *down, *newnode;\n\n\tif (unlikely(cidr > bits || !peer))\n\t\treturn -EINVAL;\n\n\tif (!rcu_access_pointer(*trie)) {\n\t\tnode = kmem_cache_zalloc(node_cache, GFP_KERNEL);\n\t\tif (unlikely(!node))\n\t\t\treturn -ENOMEM;\n\t\tRCU_INIT_POINTER(node->peer, peer);\n\t\tlist_add_tail(&node->peer_list, &peer->allowedips_list);\n\t\tcopy_and_assign_cidr(node, key, cidr, bits);\n\t\tconnect_node(trie, 2, node);\n\t\treturn 0;\n\t}\n\tif (node_placement(*trie, key, cidr, bits, &node, lock)) {\n\t\trcu_assign_pointer(node->peer, peer);\n\t\tlist_move_tail(&node->peer_list, &peer->allowedips_list);\n\t\treturn 0;\n\t}\n\n\tnewnode = kmem_cache_zalloc(node_cache, GFP_KERNEL);\n\tif (unlikely(!newnode))\n\t\treturn -ENOMEM;\n\tRCU_INIT_POINTER(newnode->peer, peer);\n\tlist_add_tail(&newnode->peer_list, &peer->allowedips_list);\n\tcopy_and_assign_cidr(newnode, key, cidr, bits);\n\n\tif (!node) {\n\t\tdown = rcu_dereference_protected(*trie, lockdep_is_held(lock));\n\t} else {\n\t\tconst u8 bit = choose(node, key);\n\t\tdown = rcu_dereference_protected(node->bit[bit], lockdep_is_held(lock));\n\t\tif (!down) {\n\t\t\tconnect_node(&node->bit[bit], bit, newnode);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcidr = min(cidr, common_bits(down, key, bits));\n\tparent = node;\n\n\tif (newnode->cidr == cidr) {\n\t\tchoose_and_connect_node(newnode, down);\n\t\tif (!parent)\n\t\t\tconnect_node(trie, 2, newnode);\n\t\telse\n\t\t\tchoose_and_connect_node(parent, newnode);\n\t\treturn 0;\n\t}\n\n\tnode = kmem_cache_zalloc(node_cache, GFP_KERNEL);\n\tif (unlikely(!node)) {\n\t\tlist_del(&newnode->peer_list);\n\t\tkmem_cache_free(node_cache, newnode);\n\t\treturn -ENOMEM;\n\t}\n\tINIT_LIST_HEAD(&node->peer_list);\n\tcopy_and_assign_cidr(node, newnode->bits, cidr, bits);\n\n\tchoose_and_connect_node(node, down);\n\tchoose_and_connect_node(node, newnode);\n\tif (!parent)\n\t\tconnect_node(trie, 2, node);\n\telse\n\t\tchoose_and_connect_node(parent, node);\n\treturn 0;\n}\n\nvoid wg_allowedips_init(struct allowedips *table)\n{\n\ttable->root4 = table->root6 = NULL;\n\ttable->seq = 1;\n}\n\nvoid wg_allowedips_free(struct allowedips *table, struct mutex *lock)\n{\n\tstruct allowedips_node __rcu *old4 = table->root4, *old6 = table->root6;\n\n\t++table->seq;\n\tRCU_INIT_POINTER(table->root4, NULL);\n\tRCU_INIT_POINTER(table->root6, NULL);\n\tif (rcu_access_pointer(old4)) {\n\t\tstruct allowedips_node *node = rcu_dereference_protected(old4,\n\t\t\t\t\t\t\tlockdep_is_held(lock));\n\n\t\troot_remove_peer_lists(node);\n\t\tcall_rcu(&node->rcu, root_free_rcu);\n\t}\n\tif (rcu_access_pointer(old6)) {\n\t\tstruct allowedips_node *node = rcu_dereference_protected(old6,\n\t\t\t\t\t\t\tlockdep_is_held(lock));\n\n\t\troot_remove_peer_lists(node);\n\t\tcall_rcu(&node->rcu, root_free_rcu);\n\t}\n}\n\nint wg_allowedips_insert_v4(struct allowedips *table, const struct in_addr *ip,\n\t\t\t    u8 cidr, struct wg_peer *peer, struct mutex *lock)\n{\n\t \n\tu8 key[4] __aligned(__alignof(u32));\n\n\t++table->seq;\n\tswap_endian(key, (const u8 *)ip, 32);\n\treturn add(&table->root4, 32, key, cidr, peer, lock);\n}\n\nint wg_allowedips_insert_v6(struct allowedips *table, const struct in6_addr *ip,\n\t\t\t    u8 cidr, struct wg_peer *peer, struct mutex *lock)\n{\n\t \n\tu8 key[16] __aligned(__alignof(u64));\n\n\t++table->seq;\n\tswap_endian(key, (const u8 *)ip, 128);\n\treturn add(&table->root6, 128, key, cidr, peer, lock);\n}\n\nvoid wg_allowedips_remove_by_peer(struct allowedips *table,\n\t\t\t\t  struct wg_peer *peer, struct mutex *lock)\n{\n\tstruct allowedips_node *node, *child, **parent_bit, *parent, *tmp;\n\tbool free_parent;\n\n\tif (list_empty(&peer->allowedips_list))\n\t\treturn;\n\t++table->seq;\n\tlist_for_each_entry_safe(node, tmp, &peer->allowedips_list, peer_list) {\n\t\tlist_del_init(&node->peer_list);\n\t\tRCU_INIT_POINTER(node->peer, NULL);\n\t\tif (node->bit[0] && node->bit[1])\n\t\t\tcontinue;\n\t\tchild = rcu_dereference_protected(node->bit[!rcu_access_pointer(node->bit[0])],\n\t\t\t\t\t\t  lockdep_is_held(lock));\n\t\tif (child)\n\t\t\tchild->parent_bit_packed = node->parent_bit_packed;\n\t\tparent_bit = (struct allowedips_node **)(node->parent_bit_packed & ~3UL);\n\t\t*parent_bit = child;\n\t\tparent = (void *)parent_bit -\n\t\t\t offsetof(struct allowedips_node, bit[node->parent_bit_packed & 1]);\n\t\tfree_parent = !rcu_access_pointer(node->bit[0]) &&\n\t\t\t      !rcu_access_pointer(node->bit[1]) &&\n\t\t\t      (node->parent_bit_packed & 3) <= 1 &&\n\t\t\t      !rcu_access_pointer(parent->peer);\n\t\tif (free_parent)\n\t\t\tchild = rcu_dereference_protected(\n\t\t\t\t\tparent->bit[!(node->parent_bit_packed & 1)],\n\t\t\t\t\tlockdep_is_held(lock));\n\t\tcall_rcu(&node->rcu, node_free_rcu);\n\t\tif (!free_parent)\n\t\t\tcontinue;\n\t\tif (child)\n\t\t\tchild->parent_bit_packed = parent->parent_bit_packed;\n\t\t*(struct allowedips_node **)(parent->parent_bit_packed & ~3UL) = child;\n\t\tcall_rcu(&parent->rcu, node_free_rcu);\n\t}\n}\n\nint wg_allowedips_read_node(struct allowedips_node *node, u8 ip[16], u8 *cidr)\n{\n\tconst unsigned int cidr_bytes = DIV_ROUND_UP(node->cidr, 8U);\n\tswap_endian(ip, node->bits, node->bitlen);\n\tmemset(ip + cidr_bytes, 0, node->bitlen / 8U - cidr_bytes);\n\tif (node->cidr)\n\t\tip[cidr_bytes - 1U] &= ~0U << (-node->cidr % 8U);\n\n\t*cidr = node->cidr;\n\treturn node->bitlen == 32 ? AF_INET : AF_INET6;\n}\n\n \nstruct wg_peer *wg_allowedips_lookup_dst(struct allowedips *table,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn lookup(table->root4, 32, &ip_hdr(skb)->daddr);\n\telse if (skb->protocol == htons(ETH_P_IPV6))\n\t\treturn lookup(table->root6, 128, &ipv6_hdr(skb)->daddr);\n\treturn NULL;\n}\n\n \nstruct wg_peer *wg_allowedips_lookup_src(struct allowedips *table,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn lookup(table->root4, 32, &ip_hdr(skb)->saddr);\n\telse if (skb->protocol == htons(ETH_P_IPV6))\n\t\treturn lookup(table->root6, 128, &ipv6_hdr(skb)->saddr);\n\treturn NULL;\n}\n\nint __init wg_allowedips_slab_init(void)\n{\n\tnode_cache = KMEM_CACHE(allowedips_node, 0);\n\treturn node_cache ? 0 : -ENOMEM;\n}\n\nvoid wg_allowedips_slab_uninit(void)\n{\n\trcu_barrier();\n\tkmem_cache_destroy(node_cache);\n}\n\n#include \"selftest/allowedips.c\"\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}