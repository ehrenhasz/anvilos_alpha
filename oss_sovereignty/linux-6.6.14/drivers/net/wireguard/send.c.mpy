{
  "module_name": "send.c",
  "hash_id": "f5b34aca5059a249b6acf8d2fac55fdf2f397cddf09728fd0ba03dff5ec07a61",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireguard/send.c",
  "human_readable_source": "\n \n\n#include \"queueing.h\"\n#include \"timers.h\"\n#include \"device.h\"\n#include \"peer.h\"\n#include \"socket.h\"\n#include \"messages.h\"\n#include \"cookie.h\"\n\n#include <linux/uio.h>\n#include <linux/inetdevice.h>\n#include <linux/socket.h>\n#include <net/ip_tunnels.h>\n#include <net/udp.h>\n#include <net/sock.h>\n\nstatic void wg_packet_send_handshake_initiation(struct wg_peer *peer)\n{\n\tstruct message_handshake_initiation packet;\n\n\tif (!wg_birthdate_has_expired(atomic64_read(&peer->last_sent_handshake),\n\t\t\t\t      REKEY_TIMEOUT))\n\t\treturn;  \n\n\tatomic64_set(&peer->last_sent_handshake, ktime_get_coarse_boottime_ns());\n\tnet_dbg_ratelimited(\"%s: Sending handshake initiation to peer %llu (%pISpfsc)\\n\",\n\t\t\t    peer->device->dev->name, peer->internal_id,\n\t\t\t    &peer->endpoint.addr);\n\n\tif (wg_noise_handshake_create_initiation(&packet, &peer->handshake)) {\n\t\twg_cookie_add_mac_to_packet(&packet, sizeof(packet), peer);\n\t\twg_timers_any_authenticated_packet_traversal(peer);\n\t\twg_timers_any_authenticated_packet_sent(peer);\n\t\tatomic64_set(&peer->last_sent_handshake,\n\t\t\t     ktime_get_coarse_boottime_ns());\n\t\twg_socket_send_buffer_to_peer(peer, &packet, sizeof(packet),\n\t\t\t\t\t      HANDSHAKE_DSCP);\n\t\twg_timers_handshake_initiated(peer);\n\t}\n}\n\nvoid wg_packet_handshake_send_worker(struct work_struct *work)\n{\n\tstruct wg_peer *peer = container_of(work, struct wg_peer,\n\t\t\t\t\t    transmit_handshake_work);\n\n\twg_packet_send_handshake_initiation(peer);\n\twg_peer_put(peer);\n}\n\nvoid wg_packet_send_queued_handshake_initiation(struct wg_peer *peer,\n\t\t\t\t\t\tbool is_retry)\n{\n\tif (!is_retry)\n\t\tpeer->timer_handshake_attempts = 0;\n\n\trcu_read_lock_bh();\n\t \n\tif (!wg_birthdate_has_expired(atomic64_read(&peer->last_sent_handshake),\n\t\t\t\t      REKEY_TIMEOUT) ||\n\t\t\tunlikely(READ_ONCE(peer->is_dead)))\n\t\tgoto out;\n\n\twg_peer_get(peer);\n\t \n\tif (!queue_work(peer->device->handshake_send_wq,\n\t\t\t&peer->transmit_handshake_work))\n\t\t \n\t\twg_peer_put(peer);\nout:\n\trcu_read_unlock_bh();\n}\n\nvoid wg_packet_send_handshake_response(struct wg_peer *peer)\n{\n\tstruct message_handshake_response packet;\n\n\tatomic64_set(&peer->last_sent_handshake, ktime_get_coarse_boottime_ns());\n\tnet_dbg_ratelimited(\"%s: Sending handshake response to peer %llu (%pISpfsc)\\n\",\n\t\t\t    peer->device->dev->name, peer->internal_id,\n\t\t\t    &peer->endpoint.addr);\n\n\tif (wg_noise_handshake_create_response(&packet, &peer->handshake)) {\n\t\twg_cookie_add_mac_to_packet(&packet, sizeof(packet), peer);\n\t\tif (wg_noise_handshake_begin_session(&peer->handshake,\n\t\t\t\t\t\t     &peer->keypairs)) {\n\t\t\twg_timers_session_derived(peer);\n\t\t\twg_timers_any_authenticated_packet_traversal(peer);\n\t\t\twg_timers_any_authenticated_packet_sent(peer);\n\t\t\tatomic64_set(&peer->last_sent_handshake,\n\t\t\t\t     ktime_get_coarse_boottime_ns());\n\t\t\twg_socket_send_buffer_to_peer(peer, &packet,\n\t\t\t\t\t\t      sizeof(packet),\n\t\t\t\t\t\t      HANDSHAKE_DSCP);\n\t\t}\n\t}\n}\n\nvoid wg_packet_send_handshake_cookie(struct wg_device *wg,\n\t\t\t\t     struct sk_buff *initiating_skb,\n\t\t\t\t     __le32 sender_index)\n{\n\tstruct message_handshake_cookie packet;\n\n\tnet_dbg_skb_ratelimited(\"%s: Sending cookie response for denied handshake message for %pISpfsc\\n\",\n\t\t\t\twg->dev->name, initiating_skb);\n\twg_cookie_message_create(&packet, initiating_skb, sender_index,\n\t\t\t\t &wg->cookie_checker);\n\twg_socket_send_buffer_as_reply_to_skb(wg, initiating_skb, &packet,\n\t\t\t\t\t      sizeof(packet));\n}\n\nstatic void keep_key_fresh(struct wg_peer *peer)\n{\n\tstruct noise_keypair *keypair;\n\tbool send;\n\n\trcu_read_lock_bh();\n\tkeypair = rcu_dereference_bh(peer->keypairs.current_keypair);\n\tsend = keypair && READ_ONCE(keypair->sending.is_valid) &&\n\t       (atomic64_read(&keypair->sending_counter) > REKEY_AFTER_MESSAGES ||\n\t\t(keypair->i_am_the_initiator &&\n\t\t wg_birthdate_has_expired(keypair->sending.birthdate, REKEY_AFTER_TIME)));\n\trcu_read_unlock_bh();\n\n\tif (unlikely(send))\n\t\twg_packet_send_queued_handshake_initiation(peer, false);\n}\n\nstatic unsigned int calculate_skb_padding(struct sk_buff *skb)\n{\n\tunsigned int padded_size, last_unit = skb->len;\n\n\tif (unlikely(!PACKET_CB(skb)->mtu))\n\t\treturn ALIGN(last_unit, MESSAGE_PADDING_MULTIPLE) - last_unit;\n\n\t \n\tif (unlikely(last_unit > PACKET_CB(skb)->mtu))\n\t\tlast_unit %= PACKET_CB(skb)->mtu;\n\n\tpadded_size = min(PACKET_CB(skb)->mtu,\n\t\t\t  ALIGN(last_unit, MESSAGE_PADDING_MULTIPLE));\n\treturn padded_size - last_unit;\n}\n\nstatic bool encrypt_packet(struct sk_buff *skb, struct noise_keypair *keypair)\n{\n\tunsigned int padding_len, plaintext_len, trailer_len;\n\tstruct scatterlist sg[MAX_SKB_FRAGS + 8];\n\tstruct message_data *header;\n\tstruct sk_buff *trailer;\n\tint num_frags;\n\n\t \n\tskb_get_hash(skb);\n\n\t \n\tpadding_len = calculate_skb_padding(skb);\n\ttrailer_len = padding_len + noise_encrypted_len(0);\n\tplaintext_len = skb->len + padding_len;\n\n\t \n\tnum_frags = skb_cow_data(skb, trailer_len, &trailer);\n\tif (unlikely(num_frags < 0 || num_frags > ARRAY_SIZE(sg)))\n\t\treturn false;\n\n\t \n\tmemset(skb_tail_pointer(trailer), 0, padding_len);\n\n\t \n\tif (unlikely(skb_cow_head(skb, DATA_PACKET_HEAD_ROOM) < 0))\n\t\treturn false;\n\n\t \n\tif (unlikely(skb->ip_summed == CHECKSUM_PARTIAL &&\n\t\t     skb_checksum_help(skb)))\n\t\treturn false;\n\n\t \n\tskb_set_inner_network_header(skb, 0);\n\theader = (struct message_data *)skb_push(skb, sizeof(*header));\n\theader->header.type = cpu_to_le32(MESSAGE_DATA);\n\theader->key_idx = keypair->remote_index;\n\theader->counter = cpu_to_le64(PACKET_CB(skb)->nonce);\n\tpskb_put(skb, trailer, trailer_len);\n\n\t \n\tsg_init_table(sg, num_frags);\n\tif (skb_to_sgvec(skb, sg, sizeof(struct message_data),\n\t\t\t noise_encrypted_len(plaintext_len)) <= 0)\n\t\treturn false;\n\treturn chacha20poly1305_encrypt_sg_inplace(sg, plaintext_len, NULL, 0,\n\t\t\t\t\t\t   PACKET_CB(skb)->nonce,\n\t\t\t\t\t\t   keypair->sending.key);\n}\n\nvoid wg_packet_send_keepalive(struct wg_peer *peer)\n{\n\tstruct sk_buff *skb;\n\n\tif (skb_queue_empty(&peer->staged_packet_queue)) {\n\t\tskb = alloc_skb(DATA_PACKET_HEAD_ROOM + MESSAGE_MINIMUM_LENGTH,\n\t\t\t\tGFP_ATOMIC);\n\t\tif (unlikely(!skb))\n\t\t\treturn;\n\t\tskb_reserve(skb, DATA_PACKET_HEAD_ROOM);\n\t\tskb->dev = peer->device->dev;\n\t\tPACKET_CB(skb)->mtu = skb->dev->mtu;\n\t\tskb_queue_tail(&peer->staged_packet_queue, skb);\n\t\tnet_dbg_ratelimited(\"%s: Sending keepalive packet to peer %llu (%pISpfsc)\\n\",\n\t\t\t\t    peer->device->dev->name, peer->internal_id,\n\t\t\t\t    &peer->endpoint.addr);\n\t}\n\n\twg_packet_send_staged_packets(peer);\n}\n\nstatic void wg_packet_create_data_done(struct wg_peer *peer, struct sk_buff *first)\n{\n\tstruct sk_buff *skb, *next;\n\tbool is_keepalive, data_sent = false;\n\n\twg_timers_any_authenticated_packet_traversal(peer);\n\twg_timers_any_authenticated_packet_sent(peer);\n\tskb_list_walk_safe(first, skb, next) {\n\t\tis_keepalive = skb->len == message_data_len(0);\n\t\tif (likely(!wg_socket_send_skb_to_peer(peer, skb,\n\t\t\t\tPACKET_CB(skb)->ds) && !is_keepalive))\n\t\t\tdata_sent = true;\n\t}\n\n\tif (likely(data_sent))\n\t\twg_timers_data_sent(peer);\n\n\tkeep_key_fresh(peer);\n}\n\nvoid wg_packet_tx_worker(struct work_struct *work)\n{\n\tstruct wg_peer *peer = container_of(work, struct wg_peer, transmit_packet_work);\n\tstruct noise_keypair *keypair;\n\tenum packet_state state;\n\tstruct sk_buff *first;\n\n\twhile ((first = wg_prev_queue_peek(&peer->tx_queue)) != NULL &&\n\t       (state = atomic_read_acquire(&PACKET_CB(first)->state)) !=\n\t\t       PACKET_STATE_UNCRYPTED) {\n\t\twg_prev_queue_drop_peeked(&peer->tx_queue);\n\t\tkeypair = PACKET_CB(first)->keypair;\n\n\t\tif (likely(state == PACKET_STATE_CRYPTED))\n\t\t\twg_packet_create_data_done(peer, first);\n\t\telse\n\t\t\tkfree_skb_list(first);\n\n\t\twg_noise_keypair_put(keypair, false);\n\t\twg_peer_put(peer);\n\t\tif (need_resched())\n\t\t\tcond_resched();\n\t}\n}\n\nvoid wg_packet_encrypt_worker(struct work_struct *work)\n{\n\tstruct crypt_queue *queue = container_of(work, struct multicore_worker,\n\t\t\t\t\t\t work)->ptr;\n\tstruct sk_buff *first, *skb, *next;\n\n\twhile ((first = ptr_ring_consume_bh(&queue->ring)) != NULL) {\n\t\tenum packet_state state = PACKET_STATE_CRYPTED;\n\n\t\tskb_list_walk_safe(first, skb, next) {\n\t\t\tif (likely(encrypt_packet(skb,\n\t\t\t\t\tPACKET_CB(first)->keypair))) {\n\t\t\t\twg_reset_packet(skb, true);\n\t\t\t} else {\n\t\t\t\tstate = PACKET_STATE_DEAD;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twg_queue_enqueue_per_peer_tx(first, state);\n\t\tif (need_resched())\n\t\t\tcond_resched();\n\t}\n}\n\nstatic void wg_packet_create_data(struct wg_peer *peer, struct sk_buff *first)\n{\n\tstruct wg_device *wg = peer->device;\n\tint ret = -EINVAL;\n\n\trcu_read_lock_bh();\n\tif (unlikely(READ_ONCE(peer->is_dead)))\n\t\tgoto err;\n\n\tret = wg_queue_enqueue_per_device_and_peer(&wg->encrypt_queue, &peer->tx_queue, first,\n\t\t\t\t\t\t   wg->packet_crypt_wq);\n\tif (unlikely(ret == -EPIPE))\n\t\twg_queue_enqueue_per_peer_tx(first, PACKET_STATE_DEAD);\nerr:\n\trcu_read_unlock_bh();\n\tif (likely(!ret || ret == -EPIPE))\n\t\treturn;\n\twg_noise_keypair_put(PACKET_CB(first)->keypair, false);\n\twg_peer_put(peer);\n\tkfree_skb_list(first);\n}\n\nvoid wg_packet_purge_staged_packets(struct wg_peer *peer)\n{\n\tspin_lock_bh(&peer->staged_packet_queue.lock);\n\tDEV_STATS_ADD(peer->device->dev, tx_dropped,\n\t\t      peer->staged_packet_queue.qlen);\n\t__skb_queue_purge(&peer->staged_packet_queue);\n\tspin_unlock_bh(&peer->staged_packet_queue.lock);\n}\n\nvoid wg_packet_send_staged_packets(struct wg_peer *peer)\n{\n\tstruct noise_keypair *keypair;\n\tstruct sk_buff_head packets;\n\tstruct sk_buff *skb;\n\n\t \n\t__skb_queue_head_init(&packets);\n\tspin_lock_bh(&peer->staged_packet_queue.lock);\n\tskb_queue_splice_init(&peer->staged_packet_queue, &packets);\n\tspin_unlock_bh(&peer->staged_packet_queue.lock);\n\tif (unlikely(skb_queue_empty(&packets)))\n\t\treturn;\n\n\t \n\trcu_read_lock_bh();\n\tkeypair = wg_noise_keypair_get(\n\t\trcu_dereference_bh(peer->keypairs.current_keypair));\n\trcu_read_unlock_bh();\n\tif (unlikely(!keypair))\n\t\tgoto out_nokey;\n\tif (unlikely(!READ_ONCE(keypair->sending.is_valid)))\n\t\tgoto out_nokey;\n\tif (unlikely(wg_birthdate_has_expired(keypair->sending.birthdate,\n\t\t\t\t\t      REJECT_AFTER_TIME)))\n\t\tgoto out_invalid;\n\n\t \n\tskb_queue_walk(&packets, skb) {\n\t\t \n\t\tPACKET_CB(skb)->ds = ip_tunnel_ecn_encap(0, ip_hdr(skb), skb);\n\t\tPACKET_CB(skb)->nonce =\n\t\t\t\tatomic64_inc_return(&keypair->sending_counter) - 1;\n\t\tif (unlikely(PACKET_CB(skb)->nonce >= REJECT_AFTER_MESSAGES))\n\t\t\tgoto out_invalid;\n\t}\n\n\tpackets.prev->next = NULL;\n\twg_peer_get(keypair->entry.peer);\n\tPACKET_CB(packets.next)->keypair = keypair;\n\twg_packet_create_data(peer, packets.next);\n\treturn;\n\nout_invalid:\n\tWRITE_ONCE(keypair->sending.is_valid, false);\nout_nokey:\n\twg_noise_keypair_put(keypair, false);\n\n\t \n\tskb_queue_walk(&packets, skb)\n\t\tskb_orphan(skb);\n\t \n\tspin_lock_bh(&peer->staged_packet_queue.lock);\n\tskb_queue_splice(&packets, &peer->staged_packet_queue);\n\tspin_unlock_bh(&peer->staged_packet_queue.lock);\n\n\t \n\twg_packet_send_queued_handshake_initiation(peer, false);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}