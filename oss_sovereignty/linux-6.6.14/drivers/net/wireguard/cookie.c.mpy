{
  "module_name": "cookie.c",
  "hash_id": "a1979b8ffdd0bd9c5f38b55059994cc9d88faa2d26f8f1c4b0a830e56498a627",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireguard/cookie.c",
  "human_readable_source": "\n \n\n#include \"cookie.h\"\n#include \"peer.h\"\n#include \"device.h\"\n#include \"messages.h\"\n#include \"ratelimiter.h\"\n#include \"timers.h\"\n\n#include <crypto/blake2s.h>\n#include <crypto/chacha20poly1305.h>\n\n#include <net/ipv6.h>\n#include <crypto/algapi.h>\n\nvoid wg_cookie_checker_init(struct cookie_checker *checker,\n\t\t\t    struct wg_device *wg)\n{\n\tinit_rwsem(&checker->secret_lock);\n\tchecker->secret_birthdate = ktime_get_coarse_boottime_ns();\n\tget_random_bytes(checker->secret, NOISE_HASH_LEN);\n\tchecker->device = wg;\n}\n\nenum { COOKIE_KEY_LABEL_LEN = 8 };\nstatic const u8 mac1_key_label[COOKIE_KEY_LABEL_LEN] = \"mac1----\";\nstatic const u8 cookie_key_label[COOKIE_KEY_LABEL_LEN] = \"cookie--\";\n\nstatic void precompute_key(u8 key[NOISE_SYMMETRIC_KEY_LEN],\n\t\t\t   const u8 pubkey[NOISE_PUBLIC_KEY_LEN],\n\t\t\t   const u8 label[COOKIE_KEY_LABEL_LEN])\n{\n\tstruct blake2s_state blake;\n\n\tblake2s_init(&blake, NOISE_SYMMETRIC_KEY_LEN);\n\tblake2s_update(&blake, label, COOKIE_KEY_LABEL_LEN);\n\tblake2s_update(&blake, pubkey, NOISE_PUBLIC_KEY_LEN);\n\tblake2s_final(&blake, key);\n}\n\n \nvoid wg_cookie_checker_precompute_device_keys(struct cookie_checker *checker)\n{\n\tif (likely(checker->device->static_identity.has_identity)) {\n\t\tprecompute_key(checker->cookie_encryption_key,\n\t\t\t       checker->device->static_identity.static_public,\n\t\t\t       cookie_key_label);\n\t\tprecompute_key(checker->message_mac1_key,\n\t\t\t       checker->device->static_identity.static_public,\n\t\t\t       mac1_key_label);\n\t} else {\n\t\tmemset(checker->cookie_encryption_key, 0,\n\t\t       NOISE_SYMMETRIC_KEY_LEN);\n\t\tmemset(checker->message_mac1_key, 0, NOISE_SYMMETRIC_KEY_LEN);\n\t}\n}\n\nvoid wg_cookie_checker_precompute_peer_keys(struct wg_peer *peer)\n{\n\tprecompute_key(peer->latest_cookie.cookie_decryption_key,\n\t\t       peer->handshake.remote_static, cookie_key_label);\n\tprecompute_key(peer->latest_cookie.message_mac1_key,\n\t\t       peer->handshake.remote_static, mac1_key_label);\n}\n\nvoid wg_cookie_init(struct cookie *cookie)\n{\n\tmemset(cookie, 0, sizeof(*cookie));\n\tinit_rwsem(&cookie->lock);\n}\n\nstatic void compute_mac1(u8 mac1[COOKIE_LEN], const void *message, size_t len,\n\t\t\t const u8 key[NOISE_SYMMETRIC_KEY_LEN])\n{\n\tlen = len - sizeof(struct message_macs) +\n\t      offsetof(struct message_macs, mac1);\n\tblake2s(mac1, message, key, COOKIE_LEN, len, NOISE_SYMMETRIC_KEY_LEN);\n}\n\nstatic void compute_mac2(u8 mac2[COOKIE_LEN], const void *message, size_t len,\n\t\t\t const u8 cookie[COOKIE_LEN])\n{\n\tlen = len - sizeof(struct message_macs) +\n\t      offsetof(struct message_macs, mac2);\n\tblake2s(mac2, message, cookie, COOKIE_LEN, len, COOKIE_LEN);\n}\n\nstatic void make_cookie(u8 cookie[COOKIE_LEN], struct sk_buff *skb,\n\t\t\tstruct cookie_checker *checker)\n{\n\tstruct blake2s_state state;\n\n\tif (wg_birthdate_has_expired(checker->secret_birthdate,\n\t\t\t\t     COOKIE_SECRET_MAX_AGE)) {\n\t\tdown_write(&checker->secret_lock);\n\t\tchecker->secret_birthdate = ktime_get_coarse_boottime_ns();\n\t\tget_random_bytes(checker->secret, NOISE_HASH_LEN);\n\t\tup_write(&checker->secret_lock);\n\t}\n\n\tdown_read(&checker->secret_lock);\n\n\tblake2s_init_key(&state, COOKIE_LEN, checker->secret, NOISE_HASH_LEN);\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\tblake2s_update(&state, (u8 *)&ip_hdr(skb)->saddr,\n\t\t\t       sizeof(struct in_addr));\n\telse if (skb->protocol == htons(ETH_P_IPV6))\n\t\tblake2s_update(&state, (u8 *)&ipv6_hdr(skb)->saddr,\n\t\t\t       sizeof(struct in6_addr));\n\tblake2s_update(&state, (u8 *)&udp_hdr(skb)->source, sizeof(__be16));\n\tblake2s_final(&state, cookie);\n\n\tup_read(&checker->secret_lock);\n}\n\nenum cookie_mac_state wg_cookie_validate_packet(struct cookie_checker *checker,\n\t\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\t\tbool check_cookie)\n{\n\tstruct message_macs *macs = (struct message_macs *)\n\t\t(skb->data + skb->len - sizeof(*macs));\n\tenum cookie_mac_state ret;\n\tu8 computed_mac[COOKIE_LEN];\n\tu8 cookie[COOKIE_LEN];\n\n\tret = INVALID_MAC;\n\tcompute_mac1(computed_mac, skb->data, skb->len,\n\t\t     checker->message_mac1_key);\n\tif (crypto_memneq(computed_mac, macs->mac1, COOKIE_LEN))\n\t\tgoto out;\n\n\tret = VALID_MAC_BUT_NO_COOKIE;\n\n\tif (!check_cookie)\n\t\tgoto out;\n\n\tmake_cookie(cookie, skb, checker);\n\n\tcompute_mac2(computed_mac, skb->data, skb->len, cookie);\n\tif (crypto_memneq(computed_mac, macs->mac2, COOKIE_LEN))\n\t\tgoto out;\n\n\tret = VALID_MAC_WITH_COOKIE_BUT_RATELIMITED;\n\tif (!wg_ratelimiter_allow(skb, dev_net(checker->device->dev)))\n\t\tgoto out;\n\n\tret = VALID_MAC_WITH_COOKIE;\n\nout:\n\treturn ret;\n}\n\nvoid wg_cookie_add_mac_to_packet(void *message, size_t len,\n\t\t\t\t struct wg_peer *peer)\n{\n\tstruct message_macs *macs = (struct message_macs *)\n\t\t((u8 *)message + len - sizeof(*macs));\n\n\tdown_write(&peer->latest_cookie.lock);\n\tcompute_mac1(macs->mac1, message, len,\n\t\t     peer->latest_cookie.message_mac1_key);\n\tmemcpy(peer->latest_cookie.last_mac1_sent, macs->mac1, COOKIE_LEN);\n\tpeer->latest_cookie.have_sent_mac1 = true;\n\tup_write(&peer->latest_cookie.lock);\n\n\tdown_read(&peer->latest_cookie.lock);\n\tif (peer->latest_cookie.is_valid &&\n\t    !wg_birthdate_has_expired(peer->latest_cookie.birthdate,\n\t\t\t\tCOOKIE_SECRET_MAX_AGE - COOKIE_SECRET_LATENCY))\n\t\tcompute_mac2(macs->mac2, message, len,\n\t\t\t     peer->latest_cookie.cookie);\n\telse\n\t\tmemset(macs->mac2, 0, COOKIE_LEN);\n\tup_read(&peer->latest_cookie.lock);\n}\n\nvoid wg_cookie_message_create(struct message_handshake_cookie *dst,\n\t\t\t      struct sk_buff *skb, __le32 index,\n\t\t\t      struct cookie_checker *checker)\n{\n\tstruct message_macs *macs = (struct message_macs *)\n\t\t((u8 *)skb->data + skb->len - sizeof(*macs));\n\tu8 cookie[COOKIE_LEN];\n\n\tdst->header.type = cpu_to_le32(MESSAGE_HANDSHAKE_COOKIE);\n\tdst->receiver_index = index;\n\tget_random_bytes_wait(dst->nonce, COOKIE_NONCE_LEN);\n\n\tmake_cookie(cookie, skb, checker);\n\txchacha20poly1305_encrypt(dst->encrypted_cookie, cookie, COOKIE_LEN,\n\t\t\t\t  macs->mac1, COOKIE_LEN, dst->nonce,\n\t\t\t\t  checker->cookie_encryption_key);\n}\n\nvoid wg_cookie_message_consume(struct message_handshake_cookie *src,\n\t\t\t       struct wg_device *wg)\n{\n\tstruct wg_peer *peer = NULL;\n\tu8 cookie[COOKIE_LEN];\n\tbool ret;\n\n\tif (unlikely(!wg_index_hashtable_lookup(wg->index_hashtable,\n\t\t\t\t\t\tINDEX_HASHTABLE_HANDSHAKE |\n\t\t\t\t\t\tINDEX_HASHTABLE_KEYPAIR,\n\t\t\t\t\t\tsrc->receiver_index, &peer)))\n\t\treturn;\n\n\tdown_read(&peer->latest_cookie.lock);\n\tif (unlikely(!peer->latest_cookie.have_sent_mac1)) {\n\t\tup_read(&peer->latest_cookie.lock);\n\t\tgoto out;\n\t}\n\tret = xchacha20poly1305_decrypt(\n\t\tcookie, src->encrypted_cookie, sizeof(src->encrypted_cookie),\n\t\tpeer->latest_cookie.last_mac1_sent, COOKIE_LEN, src->nonce,\n\t\tpeer->latest_cookie.cookie_decryption_key);\n\tup_read(&peer->latest_cookie.lock);\n\n\tif (ret) {\n\t\tdown_write(&peer->latest_cookie.lock);\n\t\tmemcpy(peer->latest_cookie.cookie, cookie, COOKIE_LEN);\n\t\tpeer->latest_cookie.birthdate = ktime_get_coarse_boottime_ns();\n\t\tpeer->latest_cookie.is_valid = true;\n\t\tpeer->latest_cookie.have_sent_mac1 = false;\n\t\tup_write(&peer->latest_cookie.lock);\n\t} else {\n\t\tnet_dbg_ratelimited(\"%s: Could not decrypt invalid cookie response\\n\",\n\t\t\t\t    wg->dev->name);\n\t}\n\nout:\n\twg_peer_put(peer);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}