{
  "module_name": "messages.h",
  "hash_id": "3f079bf4cb5a7692771147659f803bba45dbf9e7f32a774c175be2bbafe2f5b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireguard/messages.h",
  "human_readable_source": " \n \n\n#ifndef _WG_MESSAGES_H\n#define _WG_MESSAGES_H\n\n#include <crypto/curve25519.h>\n#include <crypto/chacha20poly1305.h>\n#include <crypto/blake2s.h>\n\n#include <linux/kernel.h>\n#include <linux/param.h>\n#include <linux/skbuff.h>\n\nenum noise_lengths {\n\tNOISE_PUBLIC_KEY_LEN = CURVE25519_KEY_SIZE,\n\tNOISE_SYMMETRIC_KEY_LEN = CHACHA20POLY1305_KEY_SIZE,\n\tNOISE_TIMESTAMP_LEN = sizeof(u64) + sizeof(u32),\n\tNOISE_AUTHTAG_LEN = CHACHA20POLY1305_AUTHTAG_SIZE,\n\tNOISE_HASH_LEN = BLAKE2S_HASH_SIZE\n};\n\n#define noise_encrypted_len(plain_len) ((plain_len) + NOISE_AUTHTAG_LEN)\n\nenum cookie_values {\n\tCOOKIE_SECRET_MAX_AGE = 2 * 60,\n\tCOOKIE_SECRET_LATENCY = 5,\n\tCOOKIE_NONCE_LEN = XCHACHA20POLY1305_NONCE_SIZE,\n\tCOOKIE_LEN = 16\n};\n\nenum counter_values {\n\tCOUNTER_BITS_TOTAL = 8192,\n\tCOUNTER_REDUNDANT_BITS = BITS_PER_LONG,\n\tCOUNTER_WINDOW_SIZE = COUNTER_BITS_TOTAL - COUNTER_REDUNDANT_BITS\n};\n\nenum limits {\n\tREKEY_AFTER_MESSAGES = 1ULL << 60,\n\tREJECT_AFTER_MESSAGES = U64_MAX - COUNTER_WINDOW_SIZE - 1,\n\tREKEY_TIMEOUT = 5,\n\tREKEY_TIMEOUT_JITTER_MAX_JIFFIES = HZ / 3,\n\tREKEY_AFTER_TIME = 120,\n\tREJECT_AFTER_TIME = 180,\n\tINITIATIONS_PER_SECOND = 50,\n\tMAX_PEERS_PER_DEVICE = 1U << 20,\n\tKEEPALIVE_TIMEOUT = 10,\n\tMAX_TIMER_HANDSHAKES = 90 / REKEY_TIMEOUT,\n\tMAX_QUEUED_INCOMING_HANDSHAKES = 4096,  \n\tMAX_STAGED_PACKETS = 128,\n\tMAX_QUEUED_PACKETS = 1024  \n};\n\nenum message_type {\n\tMESSAGE_INVALID = 0,\n\tMESSAGE_HANDSHAKE_INITIATION = 1,\n\tMESSAGE_HANDSHAKE_RESPONSE = 2,\n\tMESSAGE_HANDSHAKE_COOKIE = 3,\n\tMESSAGE_DATA = 4\n};\n\nstruct message_header {\n\t \n\t__le32 type;\n};\n\nstruct message_macs {\n\tu8 mac1[COOKIE_LEN];\n\tu8 mac2[COOKIE_LEN];\n};\n\nstruct message_handshake_initiation {\n\tstruct message_header header;\n\t__le32 sender_index;\n\tu8 unencrypted_ephemeral[NOISE_PUBLIC_KEY_LEN];\n\tu8 encrypted_static[noise_encrypted_len(NOISE_PUBLIC_KEY_LEN)];\n\tu8 encrypted_timestamp[noise_encrypted_len(NOISE_TIMESTAMP_LEN)];\n\tstruct message_macs macs;\n};\n\nstruct message_handshake_response {\n\tstruct message_header header;\n\t__le32 sender_index;\n\t__le32 receiver_index;\n\tu8 unencrypted_ephemeral[NOISE_PUBLIC_KEY_LEN];\n\tu8 encrypted_nothing[noise_encrypted_len(0)];\n\tstruct message_macs macs;\n};\n\nstruct message_handshake_cookie {\n\tstruct message_header header;\n\t__le32 receiver_index;\n\tu8 nonce[COOKIE_NONCE_LEN];\n\tu8 encrypted_cookie[noise_encrypted_len(COOKIE_LEN)];\n};\n\nstruct message_data {\n\tstruct message_header header;\n\t__le32 key_idx;\n\t__le64 counter;\n\tu8 encrypted_data[];\n};\n\n#define message_data_len(plain_len) \\\n\t(noise_encrypted_len(plain_len) + sizeof(struct message_data))\n\nenum message_alignments {\n\tMESSAGE_PADDING_MULTIPLE = 16,\n\tMESSAGE_MINIMUM_LENGTH = message_data_len(0)\n};\n\n#define SKB_HEADER_LEN                                       \\\n\t(max(sizeof(struct iphdr), sizeof(struct ipv6hdr)) + \\\n\t sizeof(struct udphdr) + NET_SKB_PAD)\n#define DATA_PACKET_HEAD_ROOM \\\n\tALIGN(sizeof(struct message_data) + SKB_HEADER_LEN, 4)\n\nenum { HANDSHAKE_DSCP = 0x88   };\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}