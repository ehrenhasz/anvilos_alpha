{
  "module_name": "noise.c",
  "hash_id": "bec0c1d962dce3320fe6ec4e0e39d18e478392cdd4e8cff52e367b4db947961e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireguard/noise.c",
  "human_readable_source": "\n \n\n#include \"noise.h\"\n#include \"device.h\"\n#include \"peer.h\"\n#include \"messages.h\"\n#include \"queueing.h\"\n#include \"peerlookup.h\"\n\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/bitmap.h>\n#include <linux/scatterlist.h>\n#include <linux/highmem.h>\n#include <crypto/algapi.h>\n\n \n\nstatic const u8 handshake_name[37] = \"Noise_IKpsk2_25519_ChaChaPoly_BLAKE2s\";\nstatic const u8 identifier_name[34] = \"WireGuard v1 zx2c4 Jason@zx2c4.com\";\nstatic u8 handshake_init_hash[NOISE_HASH_LEN] __ro_after_init;\nstatic u8 handshake_init_chaining_key[NOISE_HASH_LEN] __ro_after_init;\nstatic atomic64_t keypair_counter = ATOMIC64_INIT(0);\n\nvoid __init wg_noise_init(void)\n{\n\tstruct blake2s_state blake;\n\n\tblake2s(handshake_init_chaining_key, handshake_name, NULL,\n\t\tNOISE_HASH_LEN, sizeof(handshake_name), 0);\n\tblake2s_init(&blake, NOISE_HASH_LEN);\n\tblake2s_update(&blake, handshake_init_chaining_key, NOISE_HASH_LEN);\n\tblake2s_update(&blake, identifier_name, sizeof(identifier_name));\n\tblake2s_final(&blake, handshake_init_hash);\n}\n\n \nvoid wg_noise_precompute_static_static(struct wg_peer *peer)\n{\n\tdown_write(&peer->handshake.lock);\n\tif (!peer->handshake.static_identity->has_identity ||\n\t    !curve25519(peer->handshake.precomputed_static_static,\n\t\t\tpeer->handshake.static_identity->static_private,\n\t\t\tpeer->handshake.remote_static))\n\t\tmemset(peer->handshake.precomputed_static_static, 0,\n\t\t       NOISE_PUBLIC_KEY_LEN);\n\tup_write(&peer->handshake.lock);\n}\n\nvoid wg_noise_handshake_init(struct noise_handshake *handshake,\n\t\t\t     struct noise_static_identity *static_identity,\n\t\t\t     const u8 peer_public_key[NOISE_PUBLIC_KEY_LEN],\n\t\t\t     const u8 peer_preshared_key[NOISE_SYMMETRIC_KEY_LEN],\n\t\t\t     struct wg_peer *peer)\n{\n\tmemset(handshake, 0, sizeof(*handshake));\n\tinit_rwsem(&handshake->lock);\n\thandshake->entry.type = INDEX_HASHTABLE_HANDSHAKE;\n\thandshake->entry.peer = peer;\n\tmemcpy(handshake->remote_static, peer_public_key, NOISE_PUBLIC_KEY_LEN);\n\tif (peer_preshared_key)\n\t\tmemcpy(handshake->preshared_key, peer_preshared_key,\n\t\t       NOISE_SYMMETRIC_KEY_LEN);\n\thandshake->static_identity = static_identity;\n\thandshake->state = HANDSHAKE_ZEROED;\n\twg_noise_precompute_static_static(peer);\n}\n\nstatic void handshake_zero(struct noise_handshake *handshake)\n{\n\tmemset(&handshake->ephemeral_private, 0, NOISE_PUBLIC_KEY_LEN);\n\tmemset(&handshake->remote_ephemeral, 0, NOISE_PUBLIC_KEY_LEN);\n\tmemset(&handshake->hash, 0, NOISE_HASH_LEN);\n\tmemset(&handshake->chaining_key, 0, NOISE_HASH_LEN);\n\thandshake->remote_index = 0;\n\thandshake->state = HANDSHAKE_ZEROED;\n}\n\nvoid wg_noise_handshake_clear(struct noise_handshake *handshake)\n{\n\tdown_write(&handshake->lock);\n\twg_index_hashtable_remove(\n\t\t\thandshake->entry.peer->device->index_hashtable,\n\t\t\t&handshake->entry);\n\thandshake_zero(handshake);\n\tup_write(&handshake->lock);\n}\n\nstatic struct noise_keypair *keypair_create(struct wg_peer *peer)\n{\n\tstruct noise_keypair *keypair = kzalloc(sizeof(*keypair), GFP_KERNEL);\n\n\tif (unlikely(!keypair))\n\t\treturn NULL;\n\tspin_lock_init(&keypair->receiving_counter.lock);\n\tkeypair->internal_id = atomic64_inc_return(&keypair_counter);\n\tkeypair->entry.type = INDEX_HASHTABLE_KEYPAIR;\n\tkeypair->entry.peer = peer;\n\tkref_init(&keypair->refcount);\n\treturn keypair;\n}\n\nstatic void keypair_free_rcu(struct rcu_head *rcu)\n{\n\tkfree_sensitive(container_of(rcu, struct noise_keypair, rcu));\n}\n\nstatic void keypair_free_kref(struct kref *kref)\n{\n\tstruct noise_keypair *keypair =\n\t\tcontainer_of(kref, struct noise_keypair, refcount);\n\n\tnet_dbg_ratelimited(\"%s: Keypair %llu destroyed for peer %llu\\n\",\n\t\t\t    keypair->entry.peer->device->dev->name,\n\t\t\t    keypair->internal_id,\n\t\t\t    keypair->entry.peer->internal_id);\n\twg_index_hashtable_remove(keypair->entry.peer->device->index_hashtable,\n\t\t\t\t  &keypair->entry);\n\tcall_rcu(&keypair->rcu, keypair_free_rcu);\n}\n\nvoid wg_noise_keypair_put(struct noise_keypair *keypair, bool unreference_now)\n{\n\tif (unlikely(!keypair))\n\t\treturn;\n\tif (unlikely(unreference_now))\n\t\twg_index_hashtable_remove(\n\t\t\tkeypair->entry.peer->device->index_hashtable,\n\t\t\t&keypair->entry);\n\tkref_put(&keypair->refcount, keypair_free_kref);\n}\n\nstruct noise_keypair *wg_noise_keypair_get(struct noise_keypair *keypair)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_bh_held(),\n\t\t\"Taking noise keypair reference without holding the RCU BH read lock\");\n\tif (unlikely(!keypair || !kref_get_unless_zero(&keypair->refcount)))\n\t\treturn NULL;\n\treturn keypair;\n}\n\nvoid wg_noise_keypairs_clear(struct noise_keypairs *keypairs)\n{\n\tstruct noise_keypair *old;\n\n\tspin_lock_bh(&keypairs->keypair_update_lock);\n\n\t \n\told = rcu_dereference_protected(keypairs->next_keypair,\n\t\tlockdep_is_held(&keypairs->keypair_update_lock));\n\tRCU_INIT_POINTER(keypairs->next_keypair, NULL);\n\twg_noise_keypair_put(old, true);\n\n\told = rcu_dereference_protected(keypairs->previous_keypair,\n\t\tlockdep_is_held(&keypairs->keypair_update_lock));\n\tRCU_INIT_POINTER(keypairs->previous_keypair, NULL);\n\twg_noise_keypair_put(old, true);\n\n\told = rcu_dereference_protected(keypairs->current_keypair,\n\t\tlockdep_is_held(&keypairs->keypair_update_lock));\n\tRCU_INIT_POINTER(keypairs->current_keypair, NULL);\n\twg_noise_keypair_put(old, true);\n\n\tspin_unlock_bh(&keypairs->keypair_update_lock);\n}\n\nvoid wg_noise_expire_current_peer_keypairs(struct wg_peer *peer)\n{\n\tstruct noise_keypair *keypair;\n\n\twg_noise_handshake_clear(&peer->handshake);\n\twg_noise_reset_last_sent_handshake(&peer->last_sent_handshake);\n\n\tspin_lock_bh(&peer->keypairs.keypair_update_lock);\n\tkeypair = rcu_dereference_protected(peer->keypairs.next_keypair,\n\t\t\tlockdep_is_held(&peer->keypairs.keypair_update_lock));\n\tif (keypair)\n\t\tkeypair->sending.is_valid = false;\n\tkeypair = rcu_dereference_protected(peer->keypairs.current_keypair,\n\t\t\tlockdep_is_held(&peer->keypairs.keypair_update_lock));\n\tif (keypair)\n\t\tkeypair->sending.is_valid = false;\n\tspin_unlock_bh(&peer->keypairs.keypair_update_lock);\n}\n\nstatic void add_new_keypair(struct noise_keypairs *keypairs,\n\t\t\t    struct noise_keypair *new_keypair)\n{\n\tstruct noise_keypair *previous_keypair, *next_keypair, *current_keypair;\n\n\tspin_lock_bh(&keypairs->keypair_update_lock);\n\tprevious_keypair = rcu_dereference_protected(keypairs->previous_keypair,\n\t\tlockdep_is_held(&keypairs->keypair_update_lock));\n\tnext_keypair = rcu_dereference_protected(keypairs->next_keypair,\n\t\tlockdep_is_held(&keypairs->keypair_update_lock));\n\tcurrent_keypair = rcu_dereference_protected(keypairs->current_keypair,\n\t\tlockdep_is_held(&keypairs->keypair_update_lock));\n\tif (new_keypair->i_am_the_initiator) {\n\t\t \n\t\tif (next_keypair) {\n\t\t\t \n\t\t\tRCU_INIT_POINTER(keypairs->next_keypair, NULL);\n\t\t\trcu_assign_pointer(keypairs->previous_keypair,\n\t\t\t\t\t   next_keypair);\n\t\t\twg_noise_keypair_put(current_keypair, true);\n\t\t} else  \n\t\t\trcu_assign_pointer(keypairs->previous_keypair,\n\t\t\t\t\t   current_keypair);\n\t\t \n\t\twg_noise_keypair_put(previous_keypair, true);\n\t\trcu_assign_pointer(keypairs->current_keypair, new_keypair);\n\t} else {\n\t\t \n\t\trcu_assign_pointer(keypairs->next_keypair, new_keypair);\n\t\twg_noise_keypair_put(next_keypair, true);\n\t\tRCU_INIT_POINTER(keypairs->previous_keypair, NULL);\n\t\twg_noise_keypair_put(previous_keypair, true);\n\t}\n\tspin_unlock_bh(&keypairs->keypair_update_lock);\n}\n\nbool wg_noise_received_with_keypair(struct noise_keypairs *keypairs,\n\t\t\t\t    struct noise_keypair *received_keypair)\n{\n\tstruct noise_keypair *old_keypair;\n\tbool key_is_new;\n\n\t \n\tkey_is_new = received_keypair ==\n\t\t     rcu_access_pointer(keypairs->next_keypair);\n\tif (likely(!key_is_new))\n\t\treturn false;\n\n\tspin_lock_bh(&keypairs->keypair_update_lock);\n\t \n\tif (unlikely(received_keypair !=\n\t\t    rcu_dereference_protected(keypairs->next_keypair,\n\t\t\t    lockdep_is_held(&keypairs->keypair_update_lock)))) {\n\t\tspin_unlock_bh(&keypairs->keypair_update_lock);\n\t\treturn false;\n\t}\n\n\t \n\told_keypair = rcu_dereference_protected(keypairs->previous_keypair,\n\t\tlockdep_is_held(&keypairs->keypair_update_lock));\n\trcu_assign_pointer(keypairs->previous_keypair,\n\t\trcu_dereference_protected(keypairs->current_keypair,\n\t\t\tlockdep_is_held(&keypairs->keypair_update_lock)));\n\twg_noise_keypair_put(old_keypair, true);\n\trcu_assign_pointer(keypairs->current_keypair, received_keypair);\n\tRCU_INIT_POINTER(keypairs->next_keypair, NULL);\n\n\tspin_unlock_bh(&keypairs->keypair_update_lock);\n\treturn true;\n}\n\n \nvoid wg_noise_set_static_identity_private_key(\n\tstruct noise_static_identity *static_identity,\n\tconst u8 private_key[NOISE_PUBLIC_KEY_LEN])\n{\n\tmemcpy(static_identity->static_private, private_key,\n\t       NOISE_PUBLIC_KEY_LEN);\n\tcurve25519_clamp_secret(static_identity->static_private);\n\tstatic_identity->has_identity = curve25519_generate_public(\n\t\tstatic_identity->static_public, private_key);\n}\n\nstatic void hmac(u8 *out, const u8 *in, const u8 *key, const size_t inlen, const size_t keylen)\n{\n\tstruct blake2s_state state;\n\tu8 x_key[BLAKE2S_BLOCK_SIZE] __aligned(__alignof__(u32)) = { 0 };\n\tu8 i_hash[BLAKE2S_HASH_SIZE] __aligned(__alignof__(u32));\n\tint i;\n\n\tif (keylen > BLAKE2S_BLOCK_SIZE) {\n\t\tblake2s_init(&state, BLAKE2S_HASH_SIZE);\n\t\tblake2s_update(&state, key, keylen);\n\t\tblake2s_final(&state, x_key);\n\t} else\n\t\tmemcpy(x_key, key, keylen);\n\n\tfor (i = 0; i < BLAKE2S_BLOCK_SIZE; ++i)\n\t\tx_key[i] ^= 0x36;\n\n\tblake2s_init(&state, BLAKE2S_HASH_SIZE);\n\tblake2s_update(&state, x_key, BLAKE2S_BLOCK_SIZE);\n\tblake2s_update(&state, in, inlen);\n\tblake2s_final(&state, i_hash);\n\n\tfor (i = 0; i < BLAKE2S_BLOCK_SIZE; ++i)\n\t\tx_key[i] ^= 0x5c ^ 0x36;\n\n\tblake2s_init(&state, BLAKE2S_HASH_SIZE);\n\tblake2s_update(&state, x_key, BLAKE2S_BLOCK_SIZE);\n\tblake2s_update(&state, i_hash, BLAKE2S_HASH_SIZE);\n\tblake2s_final(&state, i_hash);\n\n\tmemcpy(out, i_hash, BLAKE2S_HASH_SIZE);\n\tmemzero_explicit(x_key, BLAKE2S_BLOCK_SIZE);\n\tmemzero_explicit(i_hash, BLAKE2S_HASH_SIZE);\n}\n\n \nstatic void kdf(u8 *first_dst, u8 *second_dst, u8 *third_dst, const u8 *data,\n\t\tsize_t first_len, size_t second_len, size_t third_len,\n\t\tsize_t data_len, const u8 chaining_key[NOISE_HASH_LEN])\n{\n\tu8 output[BLAKE2S_HASH_SIZE + 1];\n\tu8 secret[BLAKE2S_HASH_SIZE];\n\n\tWARN_ON(IS_ENABLED(DEBUG) &&\n\t\t(first_len > BLAKE2S_HASH_SIZE ||\n\t\t second_len > BLAKE2S_HASH_SIZE ||\n\t\t third_len > BLAKE2S_HASH_SIZE ||\n\t\t ((second_len || second_dst || third_len || third_dst) &&\n\t\t  (!first_len || !first_dst)) ||\n\t\t ((third_len || third_dst) && (!second_len || !second_dst))));\n\n\t \n\thmac(secret, data, chaining_key, data_len, NOISE_HASH_LEN);\n\n\tif (!first_dst || !first_len)\n\t\tgoto out;\n\n\t \n\toutput[0] = 1;\n\thmac(output, output, secret, 1, BLAKE2S_HASH_SIZE);\n\tmemcpy(first_dst, output, first_len);\n\n\tif (!second_dst || !second_len)\n\t\tgoto out;\n\n\t \n\toutput[BLAKE2S_HASH_SIZE] = 2;\n\thmac(output, output, secret, BLAKE2S_HASH_SIZE + 1, BLAKE2S_HASH_SIZE);\n\tmemcpy(second_dst, output, second_len);\n\n\tif (!third_dst || !third_len)\n\t\tgoto out;\n\n\t \n\toutput[BLAKE2S_HASH_SIZE] = 3;\n\thmac(output, output, secret, BLAKE2S_HASH_SIZE + 1, BLAKE2S_HASH_SIZE);\n\tmemcpy(third_dst, output, third_len);\n\nout:\n\t \n\tmemzero_explicit(secret, BLAKE2S_HASH_SIZE);\n\tmemzero_explicit(output, BLAKE2S_HASH_SIZE + 1);\n}\n\nstatic void derive_keys(struct noise_symmetric_key *first_dst,\n\t\t\tstruct noise_symmetric_key *second_dst,\n\t\t\tconst u8 chaining_key[NOISE_HASH_LEN])\n{\n\tu64 birthdate = ktime_get_coarse_boottime_ns();\n\tkdf(first_dst->key, second_dst->key, NULL, NULL,\n\t    NOISE_SYMMETRIC_KEY_LEN, NOISE_SYMMETRIC_KEY_LEN, 0, 0,\n\t    chaining_key);\n\tfirst_dst->birthdate = second_dst->birthdate = birthdate;\n\tfirst_dst->is_valid = second_dst->is_valid = true;\n}\n\nstatic bool __must_check mix_dh(u8 chaining_key[NOISE_HASH_LEN],\n\t\t\t\tu8 key[NOISE_SYMMETRIC_KEY_LEN],\n\t\t\t\tconst u8 private[NOISE_PUBLIC_KEY_LEN],\n\t\t\t\tconst u8 public[NOISE_PUBLIC_KEY_LEN])\n{\n\tu8 dh_calculation[NOISE_PUBLIC_KEY_LEN];\n\n\tif (unlikely(!curve25519(dh_calculation, private, public)))\n\t\treturn false;\n\tkdf(chaining_key, key, NULL, dh_calculation, NOISE_HASH_LEN,\n\t    NOISE_SYMMETRIC_KEY_LEN, 0, NOISE_PUBLIC_KEY_LEN, chaining_key);\n\tmemzero_explicit(dh_calculation, NOISE_PUBLIC_KEY_LEN);\n\treturn true;\n}\n\nstatic bool __must_check mix_precomputed_dh(u8 chaining_key[NOISE_HASH_LEN],\n\t\t\t\t\t    u8 key[NOISE_SYMMETRIC_KEY_LEN],\n\t\t\t\t\t    const u8 precomputed[NOISE_PUBLIC_KEY_LEN])\n{\n\tstatic u8 zero_point[NOISE_PUBLIC_KEY_LEN];\n\tif (unlikely(!crypto_memneq(precomputed, zero_point, NOISE_PUBLIC_KEY_LEN)))\n\t\treturn false;\n\tkdf(chaining_key, key, NULL, precomputed, NOISE_HASH_LEN,\n\t    NOISE_SYMMETRIC_KEY_LEN, 0, NOISE_PUBLIC_KEY_LEN,\n\t    chaining_key);\n\treturn true;\n}\n\nstatic void mix_hash(u8 hash[NOISE_HASH_LEN], const u8 *src, size_t src_len)\n{\n\tstruct blake2s_state blake;\n\n\tblake2s_init(&blake, NOISE_HASH_LEN);\n\tblake2s_update(&blake, hash, NOISE_HASH_LEN);\n\tblake2s_update(&blake, src, src_len);\n\tblake2s_final(&blake, hash);\n}\n\nstatic void mix_psk(u8 chaining_key[NOISE_HASH_LEN], u8 hash[NOISE_HASH_LEN],\n\t\t    u8 key[NOISE_SYMMETRIC_KEY_LEN],\n\t\t    const u8 psk[NOISE_SYMMETRIC_KEY_LEN])\n{\n\tu8 temp_hash[NOISE_HASH_LEN];\n\n\tkdf(chaining_key, temp_hash, key, psk, NOISE_HASH_LEN, NOISE_HASH_LEN,\n\t    NOISE_SYMMETRIC_KEY_LEN, NOISE_SYMMETRIC_KEY_LEN, chaining_key);\n\tmix_hash(hash, temp_hash, NOISE_HASH_LEN);\n\tmemzero_explicit(temp_hash, NOISE_HASH_LEN);\n}\n\nstatic void handshake_init(u8 chaining_key[NOISE_HASH_LEN],\n\t\t\t   u8 hash[NOISE_HASH_LEN],\n\t\t\t   const u8 remote_static[NOISE_PUBLIC_KEY_LEN])\n{\n\tmemcpy(hash, handshake_init_hash, NOISE_HASH_LEN);\n\tmemcpy(chaining_key, handshake_init_chaining_key, NOISE_HASH_LEN);\n\tmix_hash(hash, remote_static, NOISE_PUBLIC_KEY_LEN);\n}\n\nstatic void message_encrypt(u8 *dst_ciphertext, const u8 *src_plaintext,\n\t\t\t    size_t src_len, u8 key[NOISE_SYMMETRIC_KEY_LEN],\n\t\t\t    u8 hash[NOISE_HASH_LEN])\n{\n\tchacha20poly1305_encrypt(dst_ciphertext, src_plaintext, src_len, hash,\n\t\t\t\t NOISE_HASH_LEN,\n\t\t\t\t 0  , key);\n\tmix_hash(hash, dst_ciphertext, noise_encrypted_len(src_len));\n}\n\nstatic bool message_decrypt(u8 *dst_plaintext, const u8 *src_ciphertext,\n\t\t\t    size_t src_len, u8 key[NOISE_SYMMETRIC_KEY_LEN],\n\t\t\t    u8 hash[NOISE_HASH_LEN])\n{\n\tif (!chacha20poly1305_decrypt(dst_plaintext, src_ciphertext, src_len,\n\t\t\t\t      hash, NOISE_HASH_LEN,\n\t\t\t\t      0  , key))\n\t\treturn false;\n\tmix_hash(hash, src_ciphertext, src_len);\n\treturn true;\n}\n\nstatic void message_ephemeral(u8 ephemeral_dst[NOISE_PUBLIC_KEY_LEN],\n\t\t\t      const u8 ephemeral_src[NOISE_PUBLIC_KEY_LEN],\n\t\t\t      u8 chaining_key[NOISE_HASH_LEN],\n\t\t\t      u8 hash[NOISE_HASH_LEN])\n{\n\tif (ephemeral_dst != ephemeral_src)\n\t\tmemcpy(ephemeral_dst, ephemeral_src, NOISE_PUBLIC_KEY_LEN);\n\tmix_hash(hash, ephemeral_src, NOISE_PUBLIC_KEY_LEN);\n\tkdf(chaining_key, NULL, NULL, ephemeral_src, NOISE_HASH_LEN, 0, 0,\n\t    NOISE_PUBLIC_KEY_LEN, chaining_key);\n}\n\nstatic void tai64n_now(u8 output[NOISE_TIMESTAMP_LEN])\n{\n\tstruct timespec64 now;\n\n\tktime_get_real_ts64(&now);\n\n\t \n\tnow.tv_nsec = ALIGN_DOWN(now.tv_nsec,\n\t\trounddown_pow_of_two(NSEC_PER_SEC / INITIATIONS_PER_SECOND));\n\n\t \n\twait_for_random_bytes();\n\n\tdown_read(&handshake->static_identity->lock);\n\tdown_write(&handshake->lock);\n\n\tif (unlikely(!handshake->static_identity->has_identity))\n\t\tgoto out;\n\n\tdst->header.type = cpu_to_le32(MESSAGE_HANDSHAKE_INITIATION);\n\n\thandshake_init(handshake->chaining_key, handshake->hash,\n\t\t       handshake->remote_static);\n\n\t \n\tcurve25519_generate_secret(handshake->ephemeral_private);\n\tif (!curve25519_generate_public(dst->unencrypted_ephemeral,\n\t\t\t\t\thandshake->ephemeral_private))\n\t\tgoto out;\n\tmessage_ephemeral(dst->unencrypted_ephemeral,\n\t\t\t  dst->unencrypted_ephemeral, handshake->chaining_key,\n\t\t\t  handshake->hash);\n\n\t \n\tif (!mix_dh(handshake->chaining_key, key, handshake->ephemeral_private,\n\t\t    handshake->remote_static))\n\t\tgoto out;\n\n\t \n\tmessage_encrypt(dst->encrypted_static,\n\t\t\thandshake->static_identity->static_public,\n\t\t\tNOISE_PUBLIC_KEY_LEN, key, handshake->hash);\n\n\t \n\tif (!mix_precomputed_dh(handshake->chaining_key, key,\n\t\t\t\thandshake->precomputed_static_static))\n\t\tgoto out;\n\n\t \n\ttai64n_now(timestamp);\n\tmessage_encrypt(dst->encrypted_timestamp, timestamp,\n\t\t\tNOISE_TIMESTAMP_LEN, key, handshake->hash);\n\n\tdst->sender_index = wg_index_hashtable_insert(\n\t\thandshake->entry.peer->device->index_hashtable,\n\t\t&handshake->entry);\n\n\thandshake->state = HANDSHAKE_CREATED_INITIATION;\n\tret = true;\n\nout:\n\tup_write(&handshake->lock);\n\tup_read(&handshake->static_identity->lock);\n\tmemzero_explicit(key, NOISE_SYMMETRIC_KEY_LEN);\n\treturn ret;\n}\n\nstruct wg_peer *\nwg_noise_handshake_consume_initiation(struct message_handshake_initiation *src,\n\t\t\t\t      struct wg_device *wg)\n{\n\tstruct wg_peer *peer = NULL, *ret_peer = NULL;\n\tstruct noise_handshake *handshake;\n\tbool replay_attack, flood_attack;\n\tu8 key[NOISE_SYMMETRIC_KEY_LEN];\n\tu8 chaining_key[NOISE_HASH_LEN];\n\tu8 hash[NOISE_HASH_LEN];\n\tu8 s[NOISE_PUBLIC_KEY_LEN];\n\tu8 e[NOISE_PUBLIC_KEY_LEN];\n\tu8 t[NOISE_TIMESTAMP_LEN];\n\tu64 initiation_consumption;\n\n\tdown_read(&wg->static_identity.lock);\n\tif (unlikely(!wg->static_identity.has_identity))\n\t\tgoto out;\n\n\thandshake_init(chaining_key, hash, wg->static_identity.static_public);\n\n\t \n\tmessage_ephemeral(e, src->unencrypted_ephemeral, chaining_key, hash);\n\n\t \n\tif (!mix_dh(chaining_key, key, wg->static_identity.static_private, e))\n\t\tgoto out;\n\n\t \n\tif (!message_decrypt(s, src->encrypted_static,\n\t\t\t     sizeof(src->encrypted_static), key, hash))\n\t\tgoto out;\n\n\t \n\tpeer = wg_pubkey_hashtable_lookup(wg->peer_hashtable, s);\n\tif (!peer)\n\t\tgoto out;\n\thandshake = &peer->handshake;\n\n\t \n\tif (!mix_precomputed_dh(chaining_key, key,\n\t\t\t\thandshake->precomputed_static_static))\n\t    goto out;\n\n\t \n\tif (!message_decrypt(t, src->encrypted_timestamp,\n\t\t\t     sizeof(src->encrypted_timestamp), key, hash))\n\t\tgoto out;\n\n\tdown_read(&handshake->lock);\n\treplay_attack = memcmp(t, handshake->latest_timestamp,\n\t\t\t       NOISE_TIMESTAMP_LEN) <= 0;\n\tflood_attack = (s64)handshake->last_initiation_consumption +\n\t\t\t       NSEC_PER_SEC / INITIATIONS_PER_SECOND >\n\t\t       (s64)ktime_get_coarse_boottime_ns();\n\tup_read(&handshake->lock);\n\tif (replay_attack || flood_attack)\n\t\tgoto out;\n\n\t \n\tdown_write(&handshake->lock);\n\tmemcpy(handshake->remote_ephemeral, e, NOISE_PUBLIC_KEY_LEN);\n\tif (memcmp(t, handshake->latest_timestamp, NOISE_TIMESTAMP_LEN) > 0)\n\t\tmemcpy(handshake->latest_timestamp, t, NOISE_TIMESTAMP_LEN);\n\tmemcpy(handshake->hash, hash, NOISE_HASH_LEN);\n\tmemcpy(handshake->chaining_key, chaining_key, NOISE_HASH_LEN);\n\thandshake->remote_index = src->sender_index;\n\tinitiation_consumption = ktime_get_coarse_boottime_ns();\n\tif ((s64)(handshake->last_initiation_consumption - initiation_consumption) < 0)\n\t\thandshake->last_initiation_consumption = initiation_consumption;\n\thandshake->state = HANDSHAKE_CONSUMED_INITIATION;\n\tup_write(&handshake->lock);\n\tret_peer = peer;\n\nout:\n\tmemzero_explicit(key, NOISE_SYMMETRIC_KEY_LEN);\n\tmemzero_explicit(hash, NOISE_HASH_LEN);\n\tmemzero_explicit(chaining_key, NOISE_HASH_LEN);\n\tup_read(&wg->static_identity.lock);\n\tif (!ret_peer)\n\t\twg_peer_put(peer);\n\treturn ret_peer;\n}\n\nbool wg_noise_handshake_create_response(struct message_handshake_response *dst,\n\t\t\t\t\tstruct noise_handshake *handshake)\n{\n\tu8 key[NOISE_SYMMETRIC_KEY_LEN];\n\tbool ret = false;\n\n\t \n\twait_for_random_bytes();\n\n\tdown_read(&handshake->static_identity->lock);\n\tdown_write(&handshake->lock);\n\n\tif (handshake->state != HANDSHAKE_CONSUMED_INITIATION)\n\t\tgoto out;\n\n\tdst->header.type = cpu_to_le32(MESSAGE_HANDSHAKE_RESPONSE);\n\tdst->receiver_index = handshake->remote_index;\n\n\t \n\tcurve25519_generate_secret(handshake->ephemeral_private);\n\tif (!curve25519_generate_public(dst->unencrypted_ephemeral,\n\t\t\t\t\thandshake->ephemeral_private))\n\t\tgoto out;\n\tmessage_ephemeral(dst->unencrypted_ephemeral,\n\t\t\t  dst->unencrypted_ephemeral, handshake->chaining_key,\n\t\t\t  handshake->hash);\n\n\t \n\tif (!mix_dh(handshake->chaining_key, NULL, handshake->ephemeral_private,\n\t\t    handshake->remote_ephemeral))\n\t\tgoto out;\n\n\t \n\tif (!mix_dh(handshake->chaining_key, NULL, handshake->ephemeral_private,\n\t\t    handshake->remote_static))\n\t\tgoto out;\n\n\t \n\tmix_psk(handshake->chaining_key, handshake->hash, key,\n\t\thandshake->preshared_key);\n\n\t \n\tmessage_encrypt(dst->encrypted_nothing, NULL, 0, key, handshake->hash);\n\n\tdst->sender_index = wg_index_hashtable_insert(\n\t\thandshake->entry.peer->device->index_hashtable,\n\t\t&handshake->entry);\n\n\thandshake->state = HANDSHAKE_CREATED_RESPONSE;\n\tret = true;\n\nout:\n\tup_write(&handshake->lock);\n\tup_read(&handshake->static_identity->lock);\n\tmemzero_explicit(key, NOISE_SYMMETRIC_KEY_LEN);\n\treturn ret;\n}\n\nstruct wg_peer *\nwg_noise_handshake_consume_response(struct message_handshake_response *src,\n\t\t\t\t    struct wg_device *wg)\n{\n\tenum noise_handshake_state state = HANDSHAKE_ZEROED;\n\tstruct wg_peer *peer = NULL, *ret_peer = NULL;\n\tstruct noise_handshake *handshake;\n\tu8 key[NOISE_SYMMETRIC_KEY_LEN];\n\tu8 hash[NOISE_HASH_LEN];\n\tu8 chaining_key[NOISE_HASH_LEN];\n\tu8 e[NOISE_PUBLIC_KEY_LEN];\n\tu8 ephemeral_private[NOISE_PUBLIC_KEY_LEN];\n\tu8 static_private[NOISE_PUBLIC_KEY_LEN];\n\tu8 preshared_key[NOISE_SYMMETRIC_KEY_LEN];\n\n\tdown_read(&wg->static_identity.lock);\n\n\tif (unlikely(!wg->static_identity.has_identity))\n\t\tgoto out;\n\n\thandshake = (struct noise_handshake *)wg_index_hashtable_lookup(\n\t\twg->index_hashtable, INDEX_HASHTABLE_HANDSHAKE,\n\t\tsrc->receiver_index, &peer);\n\tif (unlikely(!handshake))\n\t\tgoto out;\n\n\tdown_read(&handshake->lock);\n\tstate = handshake->state;\n\tmemcpy(hash, handshake->hash, NOISE_HASH_LEN);\n\tmemcpy(chaining_key, handshake->chaining_key, NOISE_HASH_LEN);\n\tmemcpy(ephemeral_private, handshake->ephemeral_private,\n\t       NOISE_PUBLIC_KEY_LEN);\n\tmemcpy(preshared_key, handshake->preshared_key,\n\t       NOISE_SYMMETRIC_KEY_LEN);\n\tup_read(&handshake->lock);\n\n\tif (state != HANDSHAKE_CREATED_INITIATION)\n\t\tgoto fail;\n\n\t \n\tmessage_ephemeral(e, src->unencrypted_ephemeral, chaining_key, hash);\n\n\t \n\tif (!mix_dh(chaining_key, NULL, ephemeral_private, e))\n\t\tgoto fail;\n\n\t \n\tif (!mix_dh(chaining_key, NULL, wg->static_identity.static_private, e))\n\t\tgoto fail;\n\n\t \n\tmix_psk(chaining_key, hash, key, preshared_key);\n\n\t \n\tif (!message_decrypt(NULL, src->encrypted_nothing,\n\t\t\t     sizeof(src->encrypted_nothing), key, hash))\n\t\tgoto fail;\n\n\t \n\tdown_write(&handshake->lock);\n\t \n\tif (handshake->state != state) {\n\t\tup_write(&handshake->lock);\n\t\tgoto fail;\n\t}\n\tmemcpy(handshake->remote_ephemeral, e, NOISE_PUBLIC_KEY_LEN);\n\tmemcpy(handshake->hash, hash, NOISE_HASH_LEN);\n\tmemcpy(handshake->chaining_key, chaining_key, NOISE_HASH_LEN);\n\thandshake->remote_index = src->sender_index;\n\thandshake->state = HANDSHAKE_CONSUMED_RESPONSE;\n\tup_write(&handshake->lock);\n\tret_peer = peer;\n\tgoto out;\n\nfail:\n\twg_peer_put(peer);\nout:\n\tmemzero_explicit(key, NOISE_SYMMETRIC_KEY_LEN);\n\tmemzero_explicit(hash, NOISE_HASH_LEN);\n\tmemzero_explicit(chaining_key, NOISE_HASH_LEN);\n\tmemzero_explicit(ephemeral_private, NOISE_PUBLIC_KEY_LEN);\n\tmemzero_explicit(static_private, NOISE_PUBLIC_KEY_LEN);\n\tmemzero_explicit(preshared_key, NOISE_SYMMETRIC_KEY_LEN);\n\tup_read(&wg->static_identity.lock);\n\treturn ret_peer;\n}\n\nbool wg_noise_handshake_begin_session(struct noise_handshake *handshake,\n\t\t\t\t      struct noise_keypairs *keypairs)\n{\n\tstruct noise_keypair *new_keypair;\n\tbool ret = false;\n\n\tdown_write(&handshake->lock);\n\tif (handshake->state != HANDSHAKE_CREATED_RESPONSE &&\n\t    handshake->state != HANDSHAKE_CONSUMED_RESPONSE)\n\t\tgoto out;\n\n\tnew_keypair = keypair_create(handshake->entry.peer);\n\tif (!new_keypair)\n\t\tgoto out;\n\tnew_keypair->i_am_the_initiator = handshake->state ==\n\t\t\t\t\t  HANDSHAKE_CONSUMED_RESPONSE;\n\tnew_keypair->remote_index = handshake->remote_index;\n\n\tif (new_keypair->i_am_the_initiator)\n\t\tderive_keys(&new_keypair->sending, &new_keypair->receiving,\n\t\t\t    handshake->chaining_key);\n\telse\n\t\tderive_keys(&new_keypair->receiving, &new_keypair->sending,\n\t\t\t    handshake->chaining_key);\n\n\thandshake_zero(handshake);\n\trcu_read_lock_bh();\n\tif (likely(!READ_ONCE(container_of(handshake, struct wg_peer,\n\t\t\t\t\t   handshake)->is_dead))) {\n\t\tadd_new_keypair(keypairs, new_keypair);\n\t\tnet_dbg_ratelimited(\"%s: Keypair %llu created for peer %llu\\n\",\n\t\t\t\t    handshake->entry.peer->device->dev->name,\n\t\t\t\t    new_keypair->internal_id,\n\t\t\t\t    handshake->entry.peer->internal_id);\n\t\tret = wg_index_hashtable_replace(\n\t\t\thandshake->entry.peer->device->index_hashtable,\n\t\t\t&handshake->entry, &new_keypair->entry);\n\t} else {\n\t\tkfree_sensitive(new_keypair);\n\t}\n\trcu_read_unlock_bh();\n\nout:\n\tup_write(&handshake->lock);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}