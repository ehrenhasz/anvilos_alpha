{
  "module_name": "timers.c",
  "hash_id": "68136b7e8b8263ad080353041b43671382c0bcca48a1c9173d00de44dda54783",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireguard/timers.c",
  "human_readable_source": "\n \n\n#include \"timers.h\"\n#include \"device.h\"\n#include \"peer.h\"\n#include \"queueing.h\"\n#include \"socket.h\"\n\n \n\nstatic inline void mod_peer_timer(struct wg_peer *peer,\n\t\t\t\t  struct timer_list *timer,\n\t\t\t\t  unsigned long expires)\n{\n\trcu_read_lock_bh();\n\tif (likely(netif_running(peer->device->dev) &&\n\t\t   !READ_ONCE(peer->is_dead)))\n\t\tmod_timer(timer, expires);\n\trcu_read_unlock_bh();\n}\n\nstatic void wg_expired_retransmit_handshake(struct timer_list *timer)\n{\n\tstruct wg_peer *peer = from_timer(peer, timer,\n\t\t\t\t\t  timer_retransmit_handshake);\n\n\tif (peer->timer_handshake_attempts > MAX_TIMER_HANDSHAKES) {\n\t\tpr_debug(\"%s: Handshake for peer %llu (%pISpfsc) did not complete after %d attempts, giving up\\n\",\n\t\t\t peer->device->dev->name, peer->internal_id,\n\t\t\t &peer->endpoint.addr, (int)MAX_TIMER_HANDSHAKES + 2);\n\n\t\tdel_timer(&peer->timer_send_keepalive);\n\t\t \n\t\twg_packet_purge_staged_packets(peer);\n\n\t\t \n\t\tif (!timer_pending(&peer->timer_zero_key_material))\n\t\t\tmod_peer_timer(peer, &peer->timer_zero_key_material,\n\t\t\t\t       jiffies + REJECT_AFTER_TIME * 3 * HZ);\n\t} else {\n\t\t++peer->timer_handshake_attempts;\n\t\tpr_debug(\"%s: Handshake for peer %llu (%pISpfsc) did not complete after %d seconds, retrying (try %d)\\n\",\n\t\t\t peer->device->dev->name, peer->internal_id,\n\t\t\t &peer->endpoint.addr, (int)REKEY_TIMEOUT,\n\t\t\t peer->timer_handshake_attempts + 1);\n\n\t\t \n\t\twg_socket_clear_peer_endpoint_src(peer);\n\n\t\twg_packet_send_queued_handshake_initiation(peer, true);\n\t}\n}\n\nstatic void wg_expired_send_keepalive(struct timer_list *timer)\n{\n\tstruct wg_peer *peer = from_timer(peer, timer, timer_send_keepalive);\n\n\twg_packet_send_keepalive(peer);\n\tif (peer->timer_need_another_keepalive) {\n\t\tpeer->timer_need_another_keepalive = false;\n\t\tmod_peer_timer(peer, &peer->timer_send_keepalive,\n\t\t\t       jiffies + KEEPALIVE_TIMEOUT * HZ);\n\t}\n}\n\nstatic void wg_expired_new_handshake(struct timer_list *timer)\n{\n\tstruct wg_peer *peer = from_timer(peer, timer, timer_new_handshake);\n\n\tpr_debug(\"%s: Retrying handshake with peer %llu (%pISpfsc) because we stopped hearing back after %d seconds\\n\",\n\t\t peer->device->dev->name, peer->internal_id,\n\t\t &peer->endpoint.addr, (int)(KEEPALIVE_TIMEOUT + REKEY_TIMEOUT));\n\t \n\twg_socket_clear_peer_endpoint_src(peer);\n\twg_packet_send_queued_handshake_initiation(peer, false);\n}\n\nstatic void wg_expired_zero_key_material(struct timer_list *timer)\n{\n\tstruct wg_peer *peer = from_timer(peer, timer, timer_zero_key_material);\n\n\trcu_read_lock_bh();\n\tif (!READ_ONCE(peer->is_dead)) {\n\t\twg_peer_get(peer);\n\t\tif (!queue_work(peer->device->handshake_send_wq,\n\t\t\t\t&peer->clear_peer_work))\n\t\t\t \n\t\t\twg_peer_put(peer);\n\t}\n\trcu_read_unlock_bh();\n}\n\nstatic void wg_queued_expired_zero_key_material(struct work_struct *work)\n{\n\tstruct wg_peer *peer = container_of(work, struct wg_peer,\n\t\t\t\t\t    clear_peer_work);\n\n\tpr_debug(\"%s: Zeroing out all keys for peer %llu (%pISpfsc), since we haven't received a new one in %d seconds\\n\",\n\t\t peer->device->dev->name, peer->internal_id,\n\t\t &peer->endpoint.addr, (int)REJECT_AFTER_TIME * 3);\n\twg_noise_handshake_clear(&peer->handshake);\n\twg_noise_keypairs_clear(&peer->keypairs);\n\twg_peer_put(peer);\n}\n\nstatic void wg_expired_send_persistent_keepalive(struct timer_list *timer)\n{\n\tstruct wg_peer *peer = from_timer(peer, timer,\n\t\t\t\t\t  timer_persistent_keepalive);\n\n\tif (likely(peer->persistent_keepalive_interval))\n\t\twg_packet_send_keepalive(peer);\n}\n\n \nvoid wg_timers_data_sent(struct wg_peer *peer)\n{\n\tif (!timer_pending(&peer->timer_new_handshake))\n\t\tmod_peer_timer(peer, &peer->timer_new_handshake,\n\t\t\tjiffies + (KEEPALIVE_TIMEOUT + REKEY_TIMEOUT) * HZ +\n\t\t\tget_random_u32_below(REKEY_TIMEOUT_JITTER_MAX_JIFFIES));\n}\n\n \nvoid wg_timers_data_received(struct wg_peer *peer)\n{\n\tif (likely(netif_running(peer->device->dev))) {\n\t\tif (!timer_pending(&peer->timer_send_keepalive))\n\t\t\tmod_peer_timer(peer, &peer->timer_send_keepalive,\n\t\t\t\t       jiffies + KEEPALIVE_TIMEOUT * HZ);\n\t\telse\n\t\t\tpeer->timer_need_another_keepalive = true;\n\t}\n}\n\n \nvoid wg_timers_any_authenticated_packet_sent(struct wg_peer *peer)\n{\n\tdel_timer(&peer->timer_send_keepalive);\n}\n\n \nvoid wg_timers_any_authenticated_packet_received(struct wg_peer *peer)\n{\n\tdel_timer(&peer->timer_new_handshake);\n}\n\n \nvoid wg_timers_handshake_initiated(struct wg_peer *peer)\n{\n\tmod_peer_timer(peer, &peer->timer_retransmit_handshake,\n\t\t       jiffies + REKEY_TIMEOUT * HZ +\n\t\t       get_random_u32_below(REKEY_TIMEOUT_JITTER_MAX_JIFFIES));\n}\n\n \nvoid wg_timers_handshake_complete(struct wg_peer *peer)\n{\n\tdel_timer(&peer->timer_retransmit_handshake);\n\tpeer->timer_handshake_attempts = 0;\n\tpeer->sent_lastminute_handshake = false;\n\tktime_get_real_ts64(&peer->walltime_last_handshake);\n}\n\n \nvoid wg_timers_session_derived(struct wg_peer *peer)\n{\n\tmod_peer_timer(peer, &peer->timer_zero_key_material,\n\t\t       jiffies + REJECT_AFTER_TIME * 3 * HZ);\n}\n\n \nvoid wg_timers_any_authenticated_packet_traversal(struct wg_peer *peer)\n{\n\tif (peer->persistent_keepalive_interval)\n\t\tmod_peer_timer(peer, &peer->timer_persistent_keepalive,\n\t\t\tjiffies + peer->persistent_keepalive_interval * HZ);\n}\n\nvoid wg_timers_init(struct wg_peer *peer)\n{\n\ttimer_setup(&peer->timer_retransmit_handshake,\n\t\t    wg_expired_retransmit_handshake, 0);\n\ttimer_setup(&peer->timer_send_keepalive, wg_expired_send_keepalive, 0);\n\ttimer_setup(&peer->timer_new_handshake, wg_expired_new_handshake, 0);\n\ttimer_setup(&peer->timer_zero_key_material,\n\t\t    wg_expired_zero_key_material, 0);\n\ttimer_setup(&peer->timer_persistent_keepalive,\n\t\t    wg_expired_send_persistent_keepalive, 0);\n\tINIT_WORK(&peer->clear_peer_work, wg_queued_expired_zero_key_material);\n\tpeer->timer_handshake_attempts = 0;\n\tpeer->sent_lastminute_handshake = false;\n\tpeer->timer_need_another_keepalive = false;\n}\n\nvoid wg_timers_stop(struct wg_peer *peer)\n{\n\ttimer_delete_sync(&peer->timer_retransmit_handshake);\n\ttimer_delete_sync(&peer->timer_send_keepalive);\n\ttimer_delete_sync(&peer->timer_new_handshake);\n\ttimer_delete_sync(&peer->timer_zero_key_material);\n\ttimer_delete_sync(&peer->timer_persistent_keepalive);\n\tflush_work(&peer->clear_peer_work);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}