{
  "module_name": "device.c",
  "hash_id": "e9e6c56715602a7ebffdb49c665c23929b4abecc74a5d6e4d966c9534606b461",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireguard/device.c",
  "human_readable_source": "\n \n\n#include \"queueing.h\"\n#include \"socket.h\"\n#include \"timers.h\"\n#include \"device.h\"\n#include \"ratelimiter.h\"\n#include \"peer.h\"\n#include \"messages.h\"\n\n#include <linux/module.h>\n#include <linux/rtnetlink.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/inetdevice.h>\n#include <linux/if_arp.h>\n#include <linux/icmp.h>\n#include <linux/suspend.h>\n#include <net/dst_metadata.h>\n#include <net/gso.h>\n#include <net/icmp.h>\n#include <net/rtnetlink.h>\n#include <net/ip_tunnels.h>\n#include <net/addrconf.h>\n\nstatic LIST_HEAD(device_list);\n\nstatic int wg_open(struct net_device *dev)\n{\n\tstruct in_device *dev_v4 = __in_dev_get_rtnl(dev);\n\tstruct inet6_dev *dev_v6 = __in6_dev_get(dev);\n\tstruct wg_device *wg = netdev_priv(dev);\n\tstruct wg_peer *peer;\n\tint ret;\n\n\tif (dev_v4) {\n\t\t \n\t\tIN_DEV_CONF_SET(dev_v4, SEND_REDIRECTS, false);\n\t\tIPV4_DEVCONF_ALL(dev_net(dev), SEND_REDIRECTS) = false;\n\t}\n\tif (dev_v6)\n\t\tdev_v6->cnf.addr_gen_mode = IN6_ADDR_GEN_MODE_NONE;\n\n\tmutex_lock(&wg->device_update_lock);\n\tret = wg_socket_init(wg, wg->incoming_port);\n\tif (ret < 0)\n\t\tgoto out;\n\tlist_for_each_entry(peer, &wg->peer_list, peer_list) {\n\t\twg_packet_send_staged_packets(peer);\n\t\tif (peer->persistent_keepalive_interval)\n\t\t\twg_packet_send_keepalive(peer);\n\t}\nout:\n\tmutex_unlock(&wg->device_update_lock);\n\treturn ret;\n}\n\nstatic int wg_pm_notification(struct notifier_block *nb, unsigned long action, void *data)\n{\n\tstruct wg_device *wg;\n\tstruct wg_peer *peer;\n\n\t \n\tif (IS_ENABLED(CONFIG_PM_AUTOSLEEP) ||\n\t    IS_ENABLED(CONFIG_PM_USERSPACE_AUTOSLEEP))\n\t\treturn 0;\n\n\tif (action != PM_HIBERNATION_PREPARE && action != PM_SUSPEND_PREPARE)\n\t\treturn 0;\n\n\trtnl_lock();\n\tlist_for_each_entry(wg, &device_list, device_list) {\n\t\tmutex_lock(&wg->device_update_lock);\n\t\tlist_for_each_entry(peer, &wg->peer_list, peer_list) {\n\t\t\tdel_timer(&peer->timer_zero_key_material);\n\t\t\twg_noise_handshake_clear(&peer->handshake);\n\t\t\twg_noise_keypairs_clear(&peer->keypairs);\n\t\t}\n\t\tmutex_unlock(&wg->device_update_lock);\n\t}\n\trtnl_unlock();\n\trcu_barrier();\n\treturn 0;\n}\n\nstatic struct notifier_block pm_notifier = { .notifier_call = wg_pm_notification };\n\nstatic int wg_vm_notification(struct notifier_block *nb, unsigned long action, void *data)\n{\n\tstruct wg_device *wg;\n\tstruct wg_peer *peer;\n\n\trtnl_lock();\n\tlist_for_each_entry(wg, &device_list, device_list) {\n\t\tmutex_lock(&wg->device_update_lock);\n\t\tlist_for_each_entry(peer, &wg->peer_list, peer_list)\n\t\t\twg_noise_expire_current_peer_keypairs(peer);\n\t\tmutex_unlock(&wg->device_update_lock);\n\t}\n\trtnl_unlock();\n\treturn 0;\n}\n\nstatic struct notifier_block vm_notifier = { .notifier_call = wg_vm_notification };\n\nstatic int wg_stop(struct net_device *dev)\n{\n\tstruct wg_device *wg = netdev_priv(dev);\n\tstruct wg_peer *peer;\n\tstruct sk_buff *skb;\n\n\tmutex_lock(&wg->device_update_lock);\n\tlist_for_each_entry(peer, &wg->peer_list, peer_list) {\n\t\twg_packet_purge_staged_packets(peer);\n\t\twg_timers_stop(peer);\n\t\twg_noise_handshake_clear(&peer->handshake);\n\t\twg_noise_keypairs_clear(&peer->keypairs);\n\t\twg_noise_reset_last_sent_handshake(&peer->last_sent_handshake);\n\t}\n\tmutex_unlock(&wg->device_update_lock);\n\twhile ((skb = ptr_ring_consume(&wg->handshake_queue.ring)) != NULL)\n\t\tkfree_skb(skb);\n\tatomic_set(&wg->handshake_queue_len, 0);\n\twg_socket_reinit(wg, NULL, NULL);\n\treturn 0;\n}\n\nstatic netdev_tx_t wg_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct wg_device *wg = netdev_priv(dev);\n\tstruct sk_buff_head packets;\n\tstruct wg_peer *peer;\n\tstruct sk_buff *next;\n\tsa_family_t family;\n\tu32 mtu;\n\tint ret;\n\n\tif (unlikely(!wg_check_packet_protocol(skb))) {\n\t\tret = -EPROTONOSUPPORT;\n\t\tnet_dbg_ratelimited(\"%s: Invalid IP packet\\n\", dev->name);\n\t\tgoto err;\n\t}\n\n\tpeer = wg_allowedips_lookup_dst(&wg->peer_allowedips, skb);\n\tif (unlikely(!peer)) {\n\t\tret = -ENOKEY;\n\t\tif (skb->protocol == htons(ETH_P_IP))\n\t\t\tnet_dbg_ratelimited(\"%s: No peer has allowed IPs matching %pI4\\n\",\n\t\t\t\t\t    dev->name, &ip_hdr(skb)->daddr);\n\t\telse if (skb->protocol == htons(ETH_P_IPV6))\n\t\t\tnet_dbg_ratelimited(\"%s: No peer has allowed IPs matching %pI6\\n\",\n\t\t\t\t\t    dev->name, &ipv6_hdr(skb)->daddr);\n\t\tgoto err_icmp;\n\t}\n\n\tfamily = READ_ONCE(peer->endpoint.addr.sa_family);\n\tif (unlikely(family != AF_INET && family != AF_INET6)) {\n\t\tret = -EDESTADDRREQ;\n\t\tnet_dbg_ratelimited(\"%s: No valid endpoint has been configured or discovered for peer %llu\\n\",\n\t\t\t\t    dev->name, peer->internal_id);\n\t\tgoto err_peer;\n\t}\n\n\tmtu = skb_valid_dst(skb) ? dst_mtu(skb_dst(skb)) : dev->mtu;\n\n\t__skb_queue_head_init(&packets);\n\tif (!skb_is_gso(skb)) {\n\t\tskb_mark_not_on_list(skb);\n\t} else {\n\t\tstruct sk_buff *segs = skb_gso_segment(skb, 0);\n\n\t\tif (IS_ERR(segs)) {\n\t\t\tret = PTR_ERR(segs);\n\t\t\tgoto err_peer;\n\t\t}\n\t\tdev_kfree_skb(skb);\n\t\tskb = segs;\n\t}\n\n\tskb_list_walk_safe(skb, skb, next) {\n\t\tskb_mark_not_on_list(skb);\n\n\t\tskb = skb_share_check(skb, GFP_ATOMIC);\n\t\tif (unlikely(!skb))\n\t\t\tcontinue;\n\n\t\t \n\t\tskb_dst_drop(skb);\n\n\t\tPACKET_CB(skb)->mtu = mtu;\n\n\t\t__skb_queue_tail(&packets, skb);\n\t}\n\n\tspin_lock_bh(&peer->staged_packet_queue.lock);\n\t \n\twhile (skb_queue_len(&peer->staged_packet_queue) > MAX_STAGED_PACKETS) {\n\t\tdev_kfree_skb(__skb_dequeue(&peer->staged_packet_queue));\n\t\tDEV_STATS_INC(dev, tx_dropped);\n\t}\n\tskb_queue_splice_tail(&packets, &peer->staged_packet_queue);\n\tspin_unlock_bh(&peer->staged_packet_queue.lock);\n\n\twg_packet_send_staged_packets(peer);\n\n\twg_peer_put(peer);\n\treturn NETDEV_TX_OK;\n\nerr_peer:\n\twg_peer_put(peer);\nerr_icmp:\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\ticmp_ndo_send(skb, ICMP_DEST_UNREACH, ICMP_HOST_UNREACH, 0);\n\telse if (skb->protocol == htons(ETH_P_IPV6))\n\t\ticmpv6_ndo_send(skb, ICMPV6_DEST_UNREACH, ICMPV6_ADDR_UNREACH, 0);\nerr:\n\tDEV_STATS_INC(dev, tx_errors);\n\tkfree_skb(skb);\n\treturn ret;\n}\n\nstatic const struct net_device_ops netdev_ops = {\n\t.ndo_open\t\t= wg_open,\n\t.ndo_stop\t\t= wg_stop,\n\t.ndo_start_xmit\t\t= wg_xmit,\n\t.ndo_get_stats64\t= dev_get_tstats64\n};\n\nstatic void wg_destruct(struct net_device *dev)\n{\n\tstruct wg_device *wg = netdev_priv(dev);\n\n\trtnl_lock();\n\tlist_del(&wg->device_list);\n\trtnl_unlock();\n\tmutex_lock(&wg->device_update_lock);\n\trcu_assign_pointer(wg->creating_net, NULL);\n\twg->incoming_port = 0;\n\twg_socket_reinit(wg, NULL, NULL);\n\t \n\twg_peer_remove_all(wg);\n\tdestroy_workqueue(wg->handshake_receive_wq);\n\tdestroy_workqueue(wg->handshake_send_wq);\n\tdestroy_workqueue(wg->packet_crypt_wq);\n\twg_packet_queue_free(&wg->handshake_queue, true);\n\twg_packet_queue_free(&wg->decrypt_queue, false);\n\twg_packet_queue_free(&wg->encrypt_queue, false);\n\trcu_barrier();  \n\twg_ratelimiter_uninit();\n\tmemzero_explicit(&wg->static_identity, sizeof(wg->static_identity));\n\tfree_percpu(dev->tstats);\n\tkvfree(wg->index_hashtable);\n\tkvfree(wg->peer_hashtable);\n\tmutex_unlock(&wg->device_update_lock);\n\n\tpr_debug(\"%s: Interface destroyed\\n\", dev->name);\n\tfree_netdev(dev);\n}\n\nstatic const struct device_type device_type = { .name = KBUILD_MODNAME };\n\nstatic void wg_setup(struct net_device *dev)\n{\n\tstruct wg_device *wg = netdev_priv(dev);\n\tenum { WG_NETDEV_FEATURES = NETIF_F_HW_CSUM | NETIF_F_RXCSUM |\n\t\t\t\t    NETIF_F_SG | NETIF_F_GSO |\n\t\t\t\t    NETIF_F_GSO_SOFTWARE | NETIF_F_HIGHDMA };\n\tconst int overhead = MESSAGE_MINIMUM_LENGTH + sizeof(struct udphdr) +\n\t\t\t     max(sizeof(struct ipv6hdr), sizeof(struct iphdr));\n\n\tdev->netdev_ops = &netdev_ops;\n\tdev->header_ops = &ip_tunnel_header_ops;\n\tdev->hard_header_len = 0;\n\tdev->addr_len = 0;\n\tdev->needed_headroom = DATA_PACKET_HEAD_ROOM;\n\tdev->needed_tailroom = noise_encrypted_len(MESSAGE_PADDING_MULTIPLE);\n\tdev->type = ARPHRD_NONE;\n\tdev->flags = IFF_POINTOPOINT | IFF_NOARP;\n\tdev->priv_flags |= IFF_NO_QUEUE;\n\tdev->features |= NETIF_F_LLTX;\n\tdev->features |= WG_NETDEV_FEATURES;\n\tdev->hw_features |= WG_NETDEV_FEATURES;\n\tdev->hw_enc_features |= WG_NETDEV_FEATURES;\n\tdev->mtu = ETH_DATA_LEN - overhead;\n\tdev->max_mtu = round_down(INT_MAX, MESSAGE_PADDING_MULTIPLE) - overhead;\n\n\tSET_NETDEV_DEVTYPE(dev, &device_type);\n\n\t \n\tnetif_keep_dst(dev);\n\n\tmemset(wg, 0, sizeof(*wg));\n\twg->dev = dev;\n}\n\nstatic int wg_newlink(struct net *src_net, struct net_device *dev,\n\t\t      struct nlattr *tb[], struct nlattr *data[],\n\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct wg_device *wg = netdev_priv(dev);\n\tint ret = -ENOMEM;\n\n\trcu_assign_pointer(wg->creating_net, src_net);\n\tinit_rwsem(&wg->static_identity.lock);\n\tmutex_init(&wg->socket_update_lock);\n\tmutex_init(&wg->device_update_lock);\n\twg_allowedips_init(&wg->peer_allowedips);\n\twg_cookie_checker_init(&wg->cookie_checker, wg);\n\tINIT_LIST_HEAD(&wg->peer_list);\n\twg->device_update_gen = 1;\n\n\twg->peer_hashtable = wg_pubkey_hashtable_alloc();\n\tif (!wg->peer_hashtable)\n\t\treturn ret;\n\n\twg->index_hashtable = wg_index_hashtable_alloc();\n\tif (!wg->index_hashtable)\n\t\tgoto err_free_peer_hashtable;\n\n\tdev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\n\tif (!dev->tstats)\n\t\tgoto err_free_index_hashtable;\n\n\twg->handshake_receive_wq = alloc_workqueue(\"wg-kex-%s\",\n\t\t\tWQ_CPU_INTENSIVE | WQ_FREEZABLE, 0, dev->name);\n\tif (!wg->handshake_receive_wq)\n\t\tgoto err_free_tstats;\n\n\twg->handshake_send_wq = alloc_workqueue(\"wg-kex-%s\",\n\t\t\tWQ_UNBOUND | WQ_FREEZABLE, 0, dev->name);\n\tif (!wg->handshake_send_wq)\n\t\tgoto err_destroy_handshake_receive;\n\n\twg->packet_crypt_wq = alloc_workqueue(\"wg-crypt-%s\",\n\t\t\tWQ_CPU_INTENSIVE | WQ_MEM_RECLAIM, 0, dev->name);\n\tif (!wg->packet_crypt_wq)\n\t\tgoto err_destroy_handshake_send;\n\n\tret = wg_packet_queue_init(&wg->encrypt_queue, wg_packet_encrypt_worker,\n\t\t\t\t   MAX_QUEUED_PACKETS);\n\tif (ret < 0)\n\t\tgoto err_destroy_packet_crypt;\n\n\tret = wg_packet_queue_init(&wg->decrypt_queue, wg_packet_decrypt_worker,\n\t\t\t\t   MAX_QUEUED_PACKETS);\n\tif (ret < 0)\n\t\tgoto err_free_encrypt_queue;\n\n\tret = wg_packet_queue_init(&wg->handshake_queue, wg_packet_handshake_receive_worker,\n\t\t\t\t   MAX_QUEUED_INCOMING_HANDSHAKES);\n\tif (ret < 0)\n\t\tgoto err_free_decrypt_queue;\n\n\tret = wg_ratelimiter_init();\n\tif (ret < 0)\n\t\tgoto err_free_handshake_queue;\n\n\tret = register_netdevice(dev);\n\tif (ret < 0)\n\t\tgoto err_uninit_ratelimiter;\n\n\tlist_add(&wg->device_list, &device_list);\n\n\t \n\tdev->priv_destructor = wg_destruct;\n\n\tpr_debug(\"%s: Interface created\\n\", dev->name);\n\treturn ret;\n\nerr_uninit_ratelimiter:\n\twg_ratelimiter_uninit();\nerr_free_handshake_queue:\n\twg_packet_queue_free(&wg->handshake_queue, false);\nerr_free_decrypt_queue:\n\twg_packet_queue_free(&wg->decrypt_queue, false);\nerr_free_encrypt_queue:\n\twg_packet_queue_free(&wg->encrypt_queue, false);\nerr_destroy_packet_crypt:\n\tdestroy_workqueue(wg->packet_crypt_wq);\nerr_destroy_handshake_send:\n\tdestroy_workqueue(wg->handshake_send_wq);\nerr_destroy_handshake_receive:\n\tdestroy_workqueue(wg->handshake_receive_wq);\nerr_free_tstats:\n\tfree_percpu(dev->tstats);\nerr_free_index_hashtable:\n\tkvfree(wg->index_hashtable);\nerr_free_peer_hashtable:\n\tkvfree(wg->peer_hashtable);\n\treturn ret;\n}\n\nstatic struct rtnl_link_ops link_ops __read_mostly = {\n\t.kind\t\t\t= KBUILD_MODNAME,\n\t.priv_size\t\t= sizeof(struct wg_device),\n\t.setup\t\t\t= wg_setup,\n\t.newlink\t\t= wg_newlink,\n};\n\nstatic void wg_netns_pre_exit(struct net *net)\n{\n\tstruct wg_device *wg;\n\tstruct wg_peer *peer;\n\n\trtnl_lock();\n\tlist_for_each_entry(wg, &device_list, device_list) {\n\t\tif (rcu_access_pointer(wg->creating_net) == net) {\n\t\t\tpr_debug(\"%s: Creating namespace exiting\\n\", wg->dev->name);\n\t\t\tnetif_carrier_off(wg->dev);\n\t\t\tmutex_lock(&wg->device_update_lock);\n\t\t\trcu_assign_pointer(wg->creating_net, NULL);\n\t\t\twg_socket_reinit(wg, NULL, NULL);\n\t\t\tlist_for_each_entry(peer, &wg->peer_list, peer_list)\n\t\t\t\twg_socket_clear_peer_endpoint_src(peer);\n\t\t\tmutex_unlock(&wg->device_update_lock);\n\t\t}\n\t}\n\trtnl_unlock();\n}\n\nstatic struct pernet_operations pernet_ops = {\n\t.pre_exit = wg_netns_pre_exit\n};\n\nint __init wg_device_init(void)\n{\n\tint ret;\n\n\tret = register_pm_notifier(&pm_notifier);\n\tif (ret)\n\t\treturn ret;\n\n\tret = register_random_vmfork_notifier(&vm_notifier);\n\tif (ret)\n\t\tgoto error_pm;\n\n\tret = register_pernet_device(&pernet_ops);\n\tif (ret)\n\t\tgoto error_vm;\n\n\tret = rtnl_link_register(&link_ops);\n\tif (ret)\n\t\tgoto error_pernet;\n\n\treturn 0;\n\nerror_pernet:\n\tunregister_pernet_device(&pernet_ops);\nerror_vm:\n\tunregister_random_vmfork_notifier(&vm_notifier);\nerror_pm:\n\tunregister_pm_notifier(&pm_notifier);\n\treturn ret;\n}\n\nvoid wg_device_uninit(void)\n{\n\trtnl_link_unregister(&link_ops);\n\tunregister_pernet_device(&pernet_ops);\n\tunregister_random_vmfork_notifier(&vm_notifier);\n\tunregister_pm_notifier(&pm_notifier);\n\trcu_barrier();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}