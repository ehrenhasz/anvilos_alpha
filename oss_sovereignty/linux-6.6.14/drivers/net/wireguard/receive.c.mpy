{
  "module_name": "receive.c",
  "hash_id": "8a9a5309075286f49d098e29f7013760d277445675db354f1c526c02458140a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireguard/receive.c",
  "human_readable_source": "\n \n\n#include \"queueing.h\"\n#include \"device.h\"\n#include \"peer.h\"\n#include \"timers.h\"\n#include \"messages.h\"\n#include \"cookie.h\"\n#include \"socket.h\"\n\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/udp.h>\n#include <net/ip_tunnels.h>\n\n \nstatic void update_rx_stats(struct wg_peer *peer, size_t len)\n{\n\tdev_sw_netstats_rx_add(peer->device->dev, len);\n\tpeer->rx_bytes += len;\n}\n\n#define SKB_TYPE_LE32(skb) (((struct message_header *)(skb)->data)->type)\n\nstatic size_t validate_header_len(struct sk_buff *skb)\n{\n\tif (unlikely(skb->len < sizeof(struct message_header)))\n\t\treturn 0;\n\tif (SKB_TYPE_LE32(skb) == cpu_to_le32(MESSAGE_DATA) &&\n\t    skb->len >= MESSAGE_MINIMUM_LENGTH)\n\t\treturn sizeof(struct message_data);\n\tif (SKB_TYPE_LE32(skb) == cpu_to_le32(MESSAGE_HANDSHAKE_INITIATION) &&\n\t    skb->len == sizeof(struct message_handshake_initiation))\n\t\treturn sizeof(struct message_handshake_initiation);\n\tif (SKB_TYPE_LE32(skb) == cpu_to_le32(MESSAGE_HANDSHAKE_RESPONSE) &&\n\t    skb->len == sizeof(struct message_handshake_response))\n\t\treturn sizeof(struct message_handshake_response);\n\tif (SKB_TYPE_LE32(skb) == cpu_to_le32(MESSAGE_HANDSHAKE_COOKIE) &&\n\t    skb->len == sizeof(struct message_handshake_cookie))\n\t\treturn sizeof(struct message_handshake_cookie);\n\treturn 0;\n}\n\nstatic int prepare_skb_header(struct sk_buff *skb, struct wg_device *wg)\n{\n\tsize_t data_offset, data_len, header_len;\n\tstruct udphdr *udp;\n\n\tif (unlikely(!wg_check_packet_protocol(skb) ||\n\t\t     skb_transport_header(skb) < skb->head ||\n\t\t     (skb_transport_header(skb) + sizeof(struct udphdr)) >\n\t\t\t     skb_tail_pointer(skb)))\n\t\treturn -EINVAL;  \n\tudp = udp_hdr(skb);\n\tdata_offset = (u8 *)udp - skb->data;\n\tif (unlikely(data_offset > U16_MAX ||\n\t\t     data_offset + sizeof(struct udphdr) > skb->len))\n\t\t \n\t\treturn -EINVAL;\n\tdata_len = ntohs(udp->len);\n\tif (unlikely(data_len < sizeof(struct udphdr) ||\n\t\t     data_len > skb->len - data_offset))\n\t\t \n\t\treturn -EINVAL;\n\tdata_len -= sizeof(struct udphdr);\n\tdata_offset = (u8 *)udp + sizeof(struct udphdr) - skb->data;\n\tif (unlikely(!pskb_may_pull(skb,\n\t\t\t\tdata_offset + sizeof(struct message_header)) ||\n\t\t     pskb_trim(skb, data_len + data_offset) < 0))\n\t\treturn -EINVAL;\n\tskb_pull(skb, data_offset);\n\tif (unlikely(skb->len != data_len))\n\t\t \n\t\treturn -EINVAL;\n\theader_len = validate_header_len(skb);\n\tif (unlikely(!header_len))\n\t\treturn -EINVAL;\n\t__skb_push(skb, data_offset);\n\tif (unlikely(!pskb_may_pull(skb, data_offset + header_len)))\n\t\treturn -EINVAL;\n\t__skb_pull(skb, data_offset);\n\treturn 0;\n}\n\nstatic void wg_receive_handshake_packet(struct wg_device *wg,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tenum cookie_mac_state mac_state;\n\tstruct wg_peer *peer = NULL;\n\t \n\tstatic u64 last_under_load;\n\tbool packet_needs_cookie;\n\tbool under_load;\n\n\tif (SKB_TYPE_LE32(skb) == cpu_to_le32(MESSAGE_HANDSHAKE_COOKIE)) {\n\t\tnet_dbg_skb_ratelimited(\"%s: Receiving cookie response from %pISpfsc\\n\",\n\t\t\t\t\twg->dev->name, skb);\n\t\twg_cookie_message_consume(\n\t\t\t(struct message_handshake_cookie *)skb->data, wg);\n\t\treturn;\n\t}\n\n\tunder_load = atomic_read(&wg->handshake_queue_len) >=\n\t\t\tMAX_QUEUED_INCOMING_HANDSHAKES / 8;\n\tif (under_load) {\n\t\tlast_under_load = ktime_get_coarse_boottime_ns();\n\t} else if (last_under_load) {\n\t\tunder_load = !wg_birthdate_has_expired(last_under_load, 1);\n\t\tif (!under_load)\n\t\t\tlast_under_load = 0;\n\t}\n\tmac_state = wg_cookie_validate_packet(&wg->cookie_checker, skb,\n\t\t\t\t\t      under_load);\n\tif ((under_load && mac_state == VALID_MAC_WITH_COOKIE) ||\n\t    (!under_load && mac_state == VALID_MAC_BUT_NO_COOKIE)) {\n\t\tpacket_needs_cookie = false;\n\t} else if (under_load && mac_state == VALID_MAC_BUT_NO_COOKIE) {\n\t\tpacket_needs_cookie = true;\n\t} else {\n\t\tnet_dbg_skb_ratelimited(\"%s: Invalid MAC of handshake, dropping packet from %pISpfsc\\n\",\n\t\t\t\t\twg->dev->name, skb);\n\t\treturn;\n\t}\n\n\tswitch (SKB_TYPE_LE32(skb)) {\n\tcase cpu_to_le32(MESSAGE_HANDSHAKE_INITIATION): {\n\t\tstruct message_handshake_initiation *message =\n\t\t\t(struct message_handshake_initiation *)skb->data;\n\n\t\tif (packet_needs_cookie) {\n\t\t\twg_packet_send_handshake_cookie(wg, skb,\n\t\t\t\t\t\t\tmessage->sender_index);\n\t\t\treturn;\n\t\t}\n\t\tpeer = wg_noise_handshake_consume_initiation(message, wg);\n\t\tif (unlikely(!peer)) {\n\t\t\tnet_dbg_skb_ratelimited(\"%s: Invalid handshake initiation from %pISpfsc\\n\",\n\t\t\t\t\t\twg->dev->name, skb);\n\t\t\treturn;\n\t\t}\n\t\twg_socket_set_peer_endpoint_from_skb(peer, skb);\n\t\tnet_dbg_ratelimited(\"%s: Receiving handshake initiation from peer %llu (%pISpfsc)\\n\",\n\t\t\t\t    wg->dev->name, peer->internal_id,\n\t\t\t\t    &peer->endpoint.addr);\n\t\twg_packet_send_handshake_response(peer);\n\t\tbreak;\n\t}\n\tcase cpu_to_le32(MESSAGE_HANDSHAKE_RESPONSE): {\n\t\tstruct message_handshake_response *message =\n\t\t\t(struct message_handshake_response *)skb->data;\n\n\t\tif (packet_needs_cookie) {\n\t\t\twg_packet_send_handshake_cookie(wg, skb,\n\t\t\t\t\t\t\tmessage->sender_index);\n\t\t\treturn;\n\t\t}\n\t\tpeer = wg_noise_handshake_consume_response(message, wg);\n\t\tif (unlikely(!peer)) {\n\t\t\tnet_dbg_skb_ratelimited(\"%s: Invalid handshake response from %pISpfsc\\n\",\n\t\t\t\t\t\twg->dev->name, skb);\n\t\t\treturn;\n\t\t}\n\t\twg_socket_set_peer_endpoint_from_skb(peer, skb);\n\t\tnet_dbg_ratelimited(\"%s: Receiving handshake response from peer %llu (%pISpfsc)\\n\",\n\t\t\t\t    wg->dev->name, peer->internal_id,\n\t\t\t\t    &peer->endpoint.addr);\n\t\tif (wg_noise_handshake_begin_session(&peer->handshake,\n\t\t\t\t\t\t     &peer->keypairs)) {\n\t\t\twg_timers_session_derived(peer);\n\t\t\twg_timers_handshake_complete(peer);\n\t\t\t \n\t\t\twg_packet_send_keepalive(peer);\n\t\t}\n\t\tbreak;\n\t}\n\t}\n\n\tif (unlikely(!peer)) {\n\t\tWARN(1, \"Somehow a wrong type of packet wound up in the handshake queue!\\n\");\n\t\treturn;\n\t}\n\n\tlocal_bh_disable();\n\tupdate_rx_stats(peer, skb->len);\n\tlocal_bh_enable();\n\n\twg_timers_any_authenticated_packet_received(peer);\n\twg_timers_any_authenticated_packet_traversal(peer);\n\twg_peer_put(peer);\n}\n\nvoid wg_packet_handshake_receive_worker(struct work_struct *work)\n{\n\tstruct crypt_queue *queue = container_of(work, struct multicore_worker, work)->ptr;\n\tstruct wg_device *wg = container_of(queue, struct wg_device, handshake_queue);\n\tstruct sk_buff *skb;\n\n\twhile ((skb = ptr_ring_consume_bh(&queue->ring)) != NULL) {\n\t\twg_receive_handshake_packet(wg, skb);\n\t\tdev_kfree_skb(skb);\n\t\tatomic_dec(&wg->handshake_queue_len);\n\t\tcond_resched();\n\t}\n}\n\nstatic void keep_key_fresh(struct wg_peer *peer)\n{\n\tstruct noise_keypair *keypair;\n\tbool send;\n\n\tif (peer->sent_lastminute_handshake)\n\t\treturn;\n\n\trcu_read_lock_bh();\n\tkeypair = rcu_dereference_bh(peer->keypairs.current_keypair);\n\tsend = keypair && READ_ONCE(keypair->sending.is_valid) &&\n\t       keypair->i_am_the_initiator &&\n\t       wg_birthdate_has_expired(keypair->sending.birthdate,\n\t\t\tREJECT_AFTER_TIME - KEEPALIVE_TIMEOUT - REKEY_TIMEOUT);\n\trcu_read_unlock_bh();\n\n\tif (unlikely(send)) {\n\t\tpeer->sent_lastminute_handshake = true;\n\t\twg_packet_send_queued_handshake_initiation(peer, false);\n\t}\n}\n\nstatic bool decrypt_packet(struct sk_buff *skb, struct noise_keypair *keypair)\n{\n\tstruct scatterlist sg[MAX_SKB_FRAGS + 8];\n\tstruct sk_buff *trailer;\n\tunsigned int offset;\n\tint num_frags;\n\n\tif (unlikely(!keypair))\n\t\treturn false;\n\n\tif (unlikely(!READ_ONCE(keypair->receiving.is_valid) ||\n\t\t  wg_birthdate_has_expired(keypair->receiving.birthdate, REJECT_AFTER_TIME) ||\n\t\t  keypair->receiving_counter.counter >= REJECT_AFTER_MESSAGES)) {\n\t\tWRITE_ONCE(keypair->receiving.is_valid, false);\n\t\treturn false;\n\t}\n\n\tPACKET_CB(skb)->nonce =\n\t\tle64_to_cpu(((struct message_data *)skb->data)->counter);\n\n\t \n\toffset = skb->data - skb_network_header(skb);\n\tskb_push(skb, offset);\n\tnum_frags = skb_cow_data(skb, 0, &trailer);\n\toffset += sizeof(struct message_data);\n\tskb_pull(skb, offset);\n\tif (unlikely(num_frags < 0 || num_frags > ARRAY_SIZE(sg)))\n\t\treturn false;\n\n\tsg_init_table(sg, num_frags);\n\tif (skb_to_sgvec(skb, sg, 0, skb->len) <= 0)\n\t\treturn false;\n\n\tif (!chacha20poly1305_decrypt_sg_inplace(sg, skb->len, NULL, 0,\n\t\t\t\t\t         PACKET_CB(skb)->nonce,\n\t\t\t\t\t\t keypair->receiving.key))\n\t\treturn false;\n\n\t \n\tskb_push(skb, offset);\n\tif (pskb_trim(skb, skb->len - noise_encrypted_len(0)))\n\t\treturn false;\n\tskb_pull(skb, offset);\n\n\treturn true;\n}\n\n \nstatic bool counter_validate(struct noise_replay_counter *counter, u64 their_counter)\n{\n\tunsigned long index, index_current, top, i;\n\tbool ret = false;\n\n\tspin_lock_bh(&counter->lock);\n\n\tif (unlikely(counter->counter >= REJECT_AFTER_MESSAGES + 1 ||\n\t\t     their_counter >= REJECT_AFTER_MESSAGES))\n\t\tgoto out;\n\n\t++their_counter;\n\n\tif (unlikely((COUNTER_WINDOW_SIZE + their_counter) <\n\t\t     counter->counter))\n\t\tgoto out;\n\n\tindex = their_counter >> ilog2(BITS_PER_LONG);\n\n\tif (likely(their_counter > counter->counter)) {\n\t\tindex_current = counter->counter >> ilog2(BITS_PER_LONG);\n\t\ttop = min_t(unsigned long, index - index_current,\n\t\t\t    COUNTER_BITS_TOTAL / BITS_PER_LONG);\n\t\tfor (i = 1; i <= top; ++i)\n\t\t\tcounter->backtrack[(i + index_current) &\n\t\t\t\t((COUNTER_BITS_TOTAL / BITS_PER_LONG) - 1)] = 0;\n\t\tcounter->counter = their_counter;\n\t}\n\n\tindex &= (COUNTER_BITS_TOTAL / BITS_PER_LONG) - 1;\n\tret = !test_and_set_bit(their_counter & (BITS_PER_LONG - 1),\n\t\t\t\t&counter->backtrack[index]);\n\nout:\n\tspin_unlock_bh(&counter->lock);\n\treturn ret;\n}\n\n#include \"selftest/counter.c\"\n\nstatic void wg_packet_consume_data_done(struct wg_peer *peer,\n\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\tstruct endpoint *endpoint)\n{\n\tstruct net_device *dev = peer->device->dev;\n\tunsigned int len, len_before_trim;\n\tstruct wg_peer *routed_peer;\n\n\twg_socket_set_peer_endpoint(peer, endpoint);\n\n\tif (unlikely(wg_noise_received_with_keypair(&peer->keypairs,\n\t\t\t\t\t\t    PACKET_CB(skb)->keypair))) {\n\t\twg_timers_handshake_complete(peer);\n\t\twg_packet_send_staged_packets(peer);\n\t}\n\n\tkeep_key_fresh(peer);\n\n\twg_timers_any_authenticated_packet_received(peer);\n\twg_timers_any_authenticated_packet_traversal(peer);\n\n\t \n\tif (unlikely(!skb->len)) {\n\t\tupdate_rx_stats(peer, message_data_len(0));\n\t\tnet_dbg_ratelimited(\"%s: Receiving keepalive packet from peer %llu (%pISpfsc)\\n\",\n\t\t\t\t    dev->name, peer->internal_id,\n\t\t\t\t    &peer->endpoint.addr);\n\t\tgoto packet_processed;\n\t}\n\n\twg_timers_data_received(peer);\n\n\tif (unlikely(skb_network_header(skb) < skb->head))\n\t\tgoto dishonest_packet_size;\n\tif (unlikely(!(pskb_network_may_pull(skb, sizeof(struct iphdr)) &&\n\t\t       (ip_hdr(skb)->version == 4 ||\n\t\t\t(ip_hdr(skb)->version == 6 &&\n\t\t\t pskb_network_may_pull(skb, sizeof(struct ipv6hdr)))))))\n\t\tgoto dishonest_packet_type;\n\n\tskb->dev = dev;\n\t \n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\tskb->csum_level = ~0;  \n\tskb->protocol = ip_tunnel_parse_protocol(skb);\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\tlen = ntohs(ip_hdr(skb)->tot_len);\n\t\tif (unlikely(len < sizeof(struct iphdr)))\n\t\t\tgoto dishonest_packet_size;\n\t\tINET_ECN_decapsulate(skb, PACKET_CB(skb)->ds, ip_hdr(skb)->tos);\n\t} else if (skb->protocol == htons(ETH_P_IPV6)) {\n\t\tlen = ntohs(ipv6_hdr(skb)->payload_len) +\n\t\t      sizeof(struct ipv6hdr);\n\t\tINET_ECN_decapsulate(skb, PACKET_CB(skb)->ds, ipv6_get_dsfield(ipv6_hdr(skb)));\n\t} else {\n\t\tgoto dishonest_packet_type;\n\t}\n\n\tif (unlikely(len > skb->len))\n\t\tgoto dishonest_packet_size;\n\tlen_before_trim = skb->len;\n\tif (unlikely(pskb_trim(skb, len)))\n\t\tgoto packet_processed;\n\n\trouted_peer = wg_allowedips_lookup_src(&peer->device->peer_allowedips,\n\t\t\t\t\t       skb);\n\twg_peer_put(routed_peer);  \n\n\tif (unlikely(routed_peer != peer))\n\t\tgoto dishonest_packet_peer;\n\n\tnapi_gro_receive(&peer->napi, skb);\n\tupdate_rx_stats(peer, message_data_len(len_before_trim));\n\treturn;\n\ndishonest_packet_peer:\n\tnet_dbg_skb_ratelimited(\"%s: Packet has unallowed src IP (%pISc) from peer %llu (%pISpfsc)\\n\",\n\t\t\t\tdev->name, skb, peer->internal_id,\n\t\t\t\t&peer->endpoint.addr);\n\tDEV_STATS_INC(dev, rx_errors);\n\tDEV_STATS_INC(dev, rx_frame_errors);\n\tgoto packet_processed;\ndishonest_packet_type:\n\tnet_dbg_ratelimited(\"%s: Packet is neither ipv4 nor ipv6 from peer %llu (%pISpfsc)\\n\",\n\t\t\t    dev->name, peer->internal_id, &peer->endpoint.addr);\n\tDEV_STATS_INC(dev, rx_errors);\n\tDEV_STATS_INC(dev, rx_frame_errors);\n\tgoto packet_processed;\ndishonest_packet_size:\n\tnet_dbg_ratelimited(\"%s: Packet has incorrect size from peer %llu (%pISpfsc)\\n\",\n\t\t\t    dev->name, peer->internal_id, &peer->endpoint.addr);\n\tDEV_STATS_INC(dev, rx_errors);\n\tDEV_STATS_INC(dev, rx_length_errors);\n\tgoto packet_processed;\npacket_processed:\n\tdev_kfree_skb(skb);\n}\n\nint wg_packet_rx_poll(struct napi_struct *napi, int budget)\n{\n\tstruct wg_peer *peer = container_of(napi, struct wg_peer, napi);\n\tstruct noise_keypair *keypair;\n\tstruct endpoint endpoint;\n\tenum packet_state state;\n\tstruct sk_buff *skb;\n\tint work_done = 0;\n\tbool free;\n\n\tif (unlikely(budget <= 0))\n\t\treturn 0;\n\n\twhile ((skb = wg_prev_queue_peek(&peer->rx_queue)) != NULL &&\n\t       (state = atomic_read_acquire(&PACKET_CB(skb)->state)) !=\n\t\t       PACKET_STATE_UNCRYPTED) {\n\t\twg_prev_queue_drop_peeked(&peer->rx_queue);\n\t\tkeypair = PACKET_CB(skb)->keypair;\n\t\tfree = true;\n\n\t\tif (unlikely(state != PACKET_STATE_CRYPTED))\n\t\t\tgoto next;\n\n\t\tif (unlikely(!counter_validate(&keypair->receiving_counter,\n\t\t\t\t\t       PACKET_CB(skb)->nonce))) {\n\t\t\tnet_dbg_ratelimited(\"%s: Packet has invalid nonce %llu (max %llu)\\n\",\n\t\t\t\t\t    peer->device->dev->name,\n\t\t\t\t\t    PACKET_CB(skb)->nonce,\n\t\t\t\t\t    keypair->receiving_counter.counter);\n\t\t\tgoto next;\n\t\t}\n\n\t\tif (unlikely(wg_socket_endpoint_from_skb(&endpoint, skb)))\n\t\t\tgoto next;\n\n\t\twg_reset_packet(skb, false);\n\t\twg_packet_consume_data_done(peer, skb, &endpoint);\n\t\tfree = false;\n\nnext:\n\t\twg_noise_keypair_put(keypair, false);\n\t\twg_peer_put(peer);\n\t\tif (unlikely(free))\n\t\t\tdev_kfree_skb(skb);\n\n\t\tif (++work_done >= budget)\n\t\t\tbreak;\n\t}\n\n\tif (work_done < budget)\n\t\tnapi_complete_done(napi, work_done);\n\n\treturn work_done;\n}\n\nvoid wg_packet_decrypt_worker(struct work_struct *work)\n{\n\tstruct crypt_queue *queue = container_of(work, struct multicore_worker,\n\t\t\t\t\t\t work)->ptr;\n\tstruct sk_buff *skb;\n\n\twhile ((skb = ptr_ring_consume_bh(&queue->ring)) != NULL) {\n\t\tenum packet_state state =\n\t\t\tlikely(decrypt_packet(skb, PACKET_CB(skb)->keypair)) ?\n\t\t\t\tPACKET_STATE_CRYPTED : PACKET_STATE_DEAD;\n\t\twg_queue_enqueue_per_peer_rx(skb, state);\n\t\tif (need_resched())\n\t\t\tcond_resched();\n\t}\n}\n\nstatic void wg_packet_consume_data(struct wg_device *wg, struct sk_buff *skb)\n{\n\t__le32 idx = ((struct message_data *)skb->data)->key_idx;\n\tstruct wg_peer *peer = NULL;\n\tint ret;\n\n\trcu_read_lock_bh();\n\tPACKET_CB(skb)->keypair =\n\t\t(struct noise_keypair *)wg_index_hashtable_lookup(\n\t\t\twg->index_hashtable, INDEX_HASHTABLE_KEYPAIR, idx,\n\t\t\t&peer);\n\tif (unlikely(!wg_noise_keypair_get(PACKET_CB(skb)->keypair)))\n\t\tgoto err_keypair;\n\n\tif (unlikely(READ_ONCE(peer->is_dead)))\n\t\tgoto err;\n\n\tret = wg_queue_enqueue_per_device_and_peer(&wg->decrypt_queue, &peer->rx_queue, skb,\n\t\t\t\t\t\t   wg->packet_crypt_wq);\n\tif (unlikely(ret == -EPIPE))\n\t\twg_queue_enqueue_per_peer_rx(skb, PACKET_STATE_DEAD);\n\tif (likely(!ret || ret == -EPIPE)) {\n\t\trcu_read_unlock_bh();\n\t\treturn;\n\t}\nerr:\n\twg_noise_keypair_put(PACKET_CB(skb)->keypair, false);\nerr_keypair:\n\trcu_read_unlock_bh();\n\twg_peer_put(peer);\n\tdev_kfree_skb(skb);\n}\n\nvoid wg_packet_receive(struct wg_device *wg, struct sk_buff *skb)\n{\n\tif (unlikely(prepare_skb_header(skb, wg) < 0))\n\t\tgoto err;\n\tswitch (SKB_TYPE_LE32(skb)) {\n\tcase cpu_to_le32(MESSAGE_HANDSHAKE_INITIATION):\n\tcase cpu_to_le32(MESSAGE_HANDSHAKE_RESPONSE):\n\tcase cpu_to_le32(MESSAGE_HANDSHAKE_COOKIE): {\n\t\tint cpu, ret = -EBUSY;\n\n\t\tif (unlikely(!rng_is_initialized()))\n\t\t\tgoto drop;\n\t\tif (atomic_read(&wg->handshake_queue_len) > MAX_QUEUED_INCOMING_HANDSHAKES / 2) {\n\t\t\tif (spin_trylock_bh(&wg->handshake_queue.ring.producer_lock)) {\n\t\t\t\tret = __ptr_ring_produce(&wg->handshake_queue.ring, skb);\n\t\t\t\tspin_unlock_bh(&wg->handshake_queue.ring.producer_lock);\n\t\t\t}\n\t\t} else\n\t\t\tret = ptr_ring_produce_bh(&wg->handshake_queue.ring, skb);\n\t\tif (ret) {\n\tdrop:\n\t\t\tnet_dbg_skb_ratelimited(\"%s: Dropping handshake packet from %pISpfsc\\n\",\n\t\t\t\t\t\twg->dev->name, skb);\n\t\t\tgoto err;\n\t\t}\n\t\tatomic_inc(&wg->handshake_queue_len);\n\t\tcpu = wg_cpumask_next_online(&wg->handshake_queue.last_cpu);\n\t\t \n\t\tqueue_work_on(cpu, wg->handshake_receive_wq,\n\t\t\t      &per_cpu_ptr(wg->handshake_queue.worker, cpu)->work);\n\t\tbreak;\n\t}\n\tcase cpu_to_le32(MESSAGE_DATA):\n\t\tPACKET_CB(skb)->ds = ip_tunnel_get_dsfield(ip_hdr(skb), skb);\n\t\twg_packet_consume_data(wg, skb);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Non-exhaustive parsing of packet header lead to unknown packet type!\\n\");\n\t\tgoto err;\n\t}\n\treturn;\n\nerr:\n\tdev_kfree_skb(skb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}