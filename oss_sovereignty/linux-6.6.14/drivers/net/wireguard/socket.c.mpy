{
  "module_name": "socket.c",
  "hash_id": "a4fc2fbb243c47571abaea4e8400143f8b8dda6800e99c70cfe4721399a50a8e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireguard/socket.c",
  "human_readable_source": "\n \n\n#include \"device.h\"\n#include \"peer.h\"\n#include \"socket.h\"\n#include \"queueing.h\"\n#include \"messages.h\"\n\n#include <linux/ctype.h>\n#include <linux/net.h>\n#include <linux/if_vlan.h>\n#include <linux/if_ether.h>\n#include <linux/inetdevice.h>\n#include <net/udp_tunnel.h>\n#include <net/ipv6.h>\n\nstatic int send4(struct wg_device *wg, struct sk_buff *skb,\n\t\t struct endpoint *endpoint, u8 ds, struct dst_cache *cache)\n{\n\tstruct flowi4 fl = {\n\t\t.saddr = endpoint->src4.s_addr,\n\t\t.daddr = endpoint->addr4.sin_addr.s_addr,\n\t\t.fl4_dport = endpoint->addr4.sin_port,\n\t\t.flowi4_mark = wg->fwmark,\n\t\t.flowi4_proto = IPPROTO_UDP\n\t};\n\tstruct rtable *rt = NULL;\n\tstruct sock *sock;\n\tint ret = 0;\n\n\tskb_mark_not_on_list(skb);\n\tskb->dev = wg->dev;\n\tskb->mark = wg->fwmark;\n\n\trcu_read_lock_bh();\n\tsock = rcu_dereference_bh(wg->sock4);\n\n\tif (unlikely(!sock)) {\n\t\tret = -ENONET;\n\t\tgoto err;\n\t}\n\n\tfl.fl4_sport = inet_sk(sock)->inet_sport;\n\n\tif (cache)\n\t\trt = dst_cache_get_ip4(cache, &fl.saddr);\n\n\tif (!rt) {\n\t\tsecurity_sk_classify_flow(sock, flowi4_to_flowi_common(&fl));\n\t\tif (unlikely(!inet_confirm_addr(sock_net(sock), NULL, 0,\n\t\t\t\t\t\tfl.saddr, RT_SCOPE_HOST))) {\n\t\t\tendpoint->src4.s_addr = 0;\n\t\t\tendpoint->src_if4 = 0;\n\t\t\tfl.saddr = 0;\n\t\t\tif (cache)\n\t\t\t\tdst_cache_reset(cache);\n\t\t}\n\t\trt = ip_route_output_flow(sock_net(sock), &fl, sock);\n\t\tif (unlikely(endpoint->src_if4 && ((IS_ERR(rt) &&\n\t\t\t     PTR_ERR(rt) == -EINVAL) || (!IS_ERR(rt) &&\n\t\t\t     rt->dst.dev->ifindex != endpoint->src_if4)))) {\n\t\t\tendpoint->src4.s_addr = 0;\n\t\t\tendpoint->src_if4 = 0;\n\t\t\tfl.saddr = 0;\n\t\t\tif (cache)\n\t\t\t\tdst_cache_reset(cache);\n\t\t\tif (!IS_ERR(rt))\n\t\t\t\tip_rt_put(rt);\n\t\t\trt = ip_route_output_flow(sock_net(sock), &fl, sock);\n\t\t}\n\t\tif (IS_ERR(rt)) {\n\t\t\tret = PTR_ERR(rt);\n\t\t\tnet_dbg_ratelimited(\"%s: No route to %pISpfsc, error %d\\n\",\n\t\t\t\t\t    wg->dev->name, &endpoint->addr, ret);\n\t\t\tgoto err;\n\t\t}\n\t\tif (cache)\n\t\t\tdst_cache_set_ip4(cache, &rt->dst, fl.saddr);\n\t}\n\n\tskb->ignore_df = 1;\n\tudp_tunnel_xmit_skb(rt, sock, skb, fl.saddr, fl.daddr, ds,\n\t\t\t    ip4_dst_hoplimit(&rt->dst), 0, fl.fl4_sport,\n\t\t\t    fl.fl4_dport, false, false);\n\tgoto out;\n\nerr:\n\tkfree_skb(skb);\nout:\n\trcu_read_unlock_bh();\n\treturn ret;\n}\n\nstatic int send6(struct wg_device *wg, struct sk_buff *skb,\n\t\t struct endpoint *endpoint, u8 ds, struct dst_cache *cache)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct flowi6 fl = {\n\t\t.saddr = endpoint->src6,\n\t\t.daddr = endpoint->addr6.sin6_addr,\n\t\t.fl6_dport = endpoint->addr6.sin6_port,\n\t\t.flowi6_mark = wg->fwmark,\n\t\t.flowi6_oif = endpoint->addr6.sin6_scope_id,\n\t\t.flowi6_proto = IPPROTO_UDP\n\t\t \n\t};\n\tstruct dst_entry *dst = NULL;\n\tstruct sock *sock;\n\tint ret = 0;\n\n\tskb_mark_not_on_list(skb);\n\tskb->dev = wg->dev;\n\tskb->mark = wg->fwmark;\n\n\trcu_read_lock_bh();\n\tsock = rcu_dereference_bh(wg->sock6);\n\n\tif (unlikely(!sock)) {\n\t\tret = -ENONET;\n\t\tgoto err;\n\t}\n\n\tfl.fl6_sport = inet_sk(sock)->inet_sport;\n\n\tif (cache)\n\t\tdst = dst_cache_get_ip6(cache, &fl.saddr);\n\n\tif (!dst) {\n\t\tsecurity_sk_classify_flow(sock, flowi6_to_flowi_common(&fl));\n\t\tif (unlikely(!ipv6_addr_any(&fl.saddr) &&\n\t\t\t     !ipv6_chk_addr(sock_net(sock), &fl.saddr, NULL, 0))) {\n\t\t\tendpoint->src6 = fl.saddr = in6addr_any;\n\t\t\tif (cache)\n\t\t\t\tdst_cache_reset(cache);\n\t\t}\n\t\tdst = ipv6_stub->ipv6_dst_lookup_flow(sock_net(sock), sock, &fl,\n\t\t\t\t\t\t      NULL);\n\t\tif (IS_ERR(dst)) {\n\t\t\tret = PTR_ERR(dst);\n\t\t\tnet_dbg_ratelimited(\"%s: No route to %pISpfsc, error %d\\n\",\n\t\t\t\t\t    wg->dev->name, &endpoint->addr, ret);\n\t\t\tgoto err;\n\t\t}\n\t\tif (cache)\n\t\t\tdst_cache_set_ip6(cache, dst, &fl.saddr);\n\t}\n\n\tskb->ignore_df = 1;\n\tudp_tunnel6_xmit_skb(dst, sock, skb, skb->dev, &fl.saddr, &fl.daddr, ds,\n\t\t\t     ip6_dst_hoplimit(dst), 0, fl.fl6_sport,\n\t\t\t     fl.fl6_dport, false);\n\tgoto out;\n\nerr:\n\tkfree_skb(skb);\nout:\n\trcu_read_unlock_bh();\n\treturn ret;\n#else\n\tkfree_skb(skb);\n\treturn -EAFNOSUPPORT;\n#endif\n}\n\nint wg_socket_send_skb_to_peer(struct wg_peer *peer, struct sk_buff *skb, u8 ds)\n{\n\tsize_t skb_len = skb->len;\n\tint ret = -EAFNOSUPPORT;\n\n\tread_lock_bh(&peer->endpoint_lock);\n\tif (peer->endpoint.addr.sa_family == AF_INET)\n\t\tret = send4(peer->device, skb, &peer->endpoint, ds,\n\t\t\t    &peer->endpoint_cache);\n\telse if (peer->endpoint.addr.sa_family == AF_INET6)\n\t\tret = send6(peer->device, skb, &peer->endpoint, ds,\n\t\t\t    &peer->endpoint_cache);\n\telse\n\t\tdev_kfree_skb(skb);\n\tif (likely(!ret))\n\t\tpeer->tx_bytes += skb_len;\n\tread_unlock_bh(&peer->endpoint_lock);\n\n\treturn ret;\n}\n\nint wg_socket_send_buffer_to_peer(struct wg_peer *peer, void *buffer,\n\t\t\t\t  size_t len, u8 ds)\n{\n\tstruct sk_buff *skb = alloc_skb(len + SKB_HEADER_LEN, GFP_ATOMIC);\n\n\tif (unlikely(!skb))\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, SKB_HEADER_LEN);\n\tskb_set_inner_network_header(skb, 0);\n\tskb_put_data(skb, buffer, len);\n\treturn wg_socket_send_skb_to_peer(peer, skb, ds);\n}\n\nint wg_socket_send_buffer_as_reply_to_skb(struct wg_device *wg,\n\t\t\t\t\t  struct sk_buff *in_skb, void *buffer,\n\t\t\t\t\t  size_t len)\n{\n\tint ret = 0;\n\tstruct sk_buff *skb;\n\tstruct endpoint endpoint;\n\n\tif (unlikely(!in_skb))\n\t\treturn -EINVAL;\n\tret = wg_socket_endpoint_from_skb(&endpoint, in_skb);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tskb = alloc_skb(len + SKB_HEADER_LEN, GFP_ATOMIC);\n\tif (unlikely(!skb))\n\t\treturn -ENOMEM;\n\tskb_reserve(skb, SKB_HEADER_LEN);\n\tskb_set_inner_network_header(skb, 0);\n\tskb_put_data(skb, buffer, len);\n\n\tif (endpoint.addr.sa_family == AF_INET)\n\t\tret = send4(wg, skb, &endpoint, 0, NULL);\n\telse if (endpoint.addr.sa_family == AF_INET6)\n\t\tret = send6(wg, skb, &endpoint, 0, NULL);\n\t \n\n\treturn ret;\n}\n\nint wg_socket_endpoint_from_skb(struct endpoint *endpoint,\n\t\t\t\tconst struct sk_buff *skb)\n{\n\tmemset(endpoint, 0, sizeof(*endpoint));\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\tendpoint->addr4.sin_family = AF_INET;\n\t\tendpoint->addr4.sin_port = udp_hdr(skb)->source;\n\t\tendpoint->addr4.sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tendpoint->src4.s_addr = ip_hdr(skb)->daddr;\n\t\tendpoint->src_if4 = skb->skb_iif;\n\t} else if (IS_ENABLED(CONFIG_IPV6) && skb->protocol == htons(ETH_P_IPV6)) {\n\t\tendpoint->addr6.sin6_family = AF_INET6;\n\t\tendpoint->addr6.sin6_port = udp_hdr(skb)->source;\n\t\tendpoint->addr6.sin6_addr = ipv6_hdr(skb)->saddr;\n\t\tendpoint->addr6.sin6_scope_id = ipv6_iface_scope_id(\n\t\t\t&ipv6_hdr(skb)->saddr, skb->skb_iif);\n\t\tendpoint->src6 = ipv6_hdr(skb)->daddr;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic bool endpoint_eq(const struct endpoint *a, const struct endpoint *b)\n{\n\treturn (a->addr.sa_family == AF_INET && b->addr.sa_family == AF_INET &&\n\t\ta->addr4.sin_port == b->addr4.sin_port &&\n\t\ta->addr4.sin_addr.s_addr == b->addr4.sin_addr.s_addr &&\n\t\ta->src4.s_addr == b->src4.s_addr && a->src_if4 == b->src_if4) ||\n\t       (a->addr.sa_family == AF_INET6 &&\n\t\tb->addr.sa_family == AF_INET6 &&\n\t\ta->addr6.sin6_port == b->addr6.sin6_port &&\n\t\tipv6_addr_equal(&a->addr6.sin6_addr, &b->addr6.sin6_addr) &&\n\t\ta->addr6.sin6_scope_id == b->addr6.sin6_scope_id &&\n\t\tipv6_addr_equal(&a->src6, &b->src6)) ||\n\t       unlikely(!a->addr.sa_family && !b->addr.sa_family);\n}\n\nvoid wg_socket_set_peer_endpoint(struct wg_peer *peer,\n\t\t\t\t const struct endpoint *endpoint)\n{\n\t \n\tif (endpoint_eq(endpoint, &peer->endpoint))\n\t\treturn;\n\twrite_lock_bh(&peer->endpoint_lock);\n\tif (endpoint->addr.sa_family == AF_INET) {\n\t\tpeer->endpoint.addr4 = endpoint->addr4;\n\t\tpeer->endpoint.src4 = endpoint->src4;\n\t\tpeer->endpoint.src_if4 = endpoint->src_if4;\n\t} else if (IS_ENABLED(CONFIG_IPV6) && endpoint->addr.sa_family == AF_INET6) {\n\t\tpeer->endpoint.addr6 = endpoint->addr6;\n\t\tpeer->endpoint.src6 = endpoint->src6;\n\t} else {\n\t\tgoto out;\n\t}\n\tdst_cache_reset(&peer->endpoint_cache);\nout:\n\twrite_unlock_bh(&peer->endpoint_lock);\n}\n\nvoid wg_socket_set_peer_endpoint_from_skb(struct wg_peer *peer,\n\t\t\t\t\t  const struct sk_buff *skb)\n{\n\tstruct endpoint endpoint;\n\n\tif (!wg_socket_endpoint_from_skb(&endpoint, skb))\n\t\twg_socket_set_peer_endpoint(peer, &endpoint);\n}\n\nvoid wg_socket_clear_peer_endpoint_src(struct wg_peer *peer)\n{\n\twrite_lock_bh(&peer->endpoint_lock);\n\tmemset(&peer->endpoint.src6, 0, sizeof(peer->endpoint.src6));\n\tdst_cache_reset_now(&peer->endpoint_cache);\n\twrite_unlock_bh(&peer->endpoint_lock);\n}\n\nstatic int wg_receive(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct wg_device *wg;\n\n\tif (unlikely(!sk))\n\t\tgoto err;\n\twg = sk->sk_user_data;\n\tif (unlikely(!wg))\n\t\tgoto err;\n\tskb_mark_not_on_list(skb);\n\twg_packet_receive(wg, skb);\n\treturn 0;\n\nerr:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic void sock_free(struct sock *sock)\n{\n\tif (unlikely(!sock))\n\t\treturn;\n\tsk_clear_memalloc(sock);\n\tudp_tunnel_sock_release(sock->sk_socket);\n}\n\nstatic void set_sock_opts(struct socket *sock)\n{\n\tsock->sk->sk_allocation = GFP_ATOMIC;\n\tsock->sk->sk_sndbuf = INT_MAX;\n\tsk_set_memalloc(sock->sk);\n}\n\nint wg_socket_init(struct wg_device *wg, u16 port)\n{\n\tstruct net *net;\n\tint ret;\n\tstruct udp_tunnel_sock_cfg cfg = {\n\t\t.sk_user_data = wg,\n\t\t.encap_type = 1,\n\t\t.encap_rcv = wg_receive\n\t};\n\tstruct socket *new4 = NULL, *new6 = NULL;\n\tstruct udp_port_cfg port4 = {\n\t\t.family = AF_INET,\n\t\t.local_ip.s_addr = htonl(INADDR_ANY),\n\t\t.local_udp_port = htons(port),\n\t\t.use_udp_checksums = true\n\t};\n#if IS_ENABLED(CONFIG_IPV6)\n\tint retries = 0;\n\tstruct udp_port_cfg port6 = {\n\t\t.family = AF_INET6,\n\t\t.local_ip6 = IN6ADDR_ANY_INIT,\n\t\t.use_udp6_tx_checksums = true,\n\t\t.use_udp6_rx_checksums = true,\n\t\t.ipv6_v6only = true\n\t};\n#endif\n\n\trcu_read_lock();\n\tnet = rcu_dereference(wg->creating_net);\n\tnet = net ? maybe_get_net(net) : NULL;\n\trcu_read_unlock();\n\tif (unlikely(!net))\n\t\treturn -ENONET;\n\n#if IS_ENABLED(CONFIG_IPV6)\nretry:\n#endif\n\n\tret = udp_sock_create(net, &port4, &new4);\n\tif (ret < 0) {\n\t\tpr_err(\"%s: Could not create IPv4 socket\\n\", wg->dev->name);\n\t\tgoto out;\n\t}\n\tset_sock_opts(new4);\n\tsetup_udp_tunnel_sock(net, new4, &cfg);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (ipv6_mod_enabled()) {\n\t\tport6.local_udp_port = inet_sk(new4->sk)->inet_sport;\n\t\tret = udp_sock_create(net, &port6, &new6);\n\t\tif (ret < 0) {\n\t\t\tudp_tunnel_sock_release(new4);\n\t\t\tif (ret == -EADDRINUSE && !port && retries++ < 100)\n\t\t\t\tgoto retry;\n\t\t\tpr_err(\"%s: Could not create IPv6 socket\\n\",\n\t\t\t       wg->dev->name);\n\t\t\tgoto out;\n\t\t}\n\t\tset_sock_opts(new6);\n\t\tsetup_udp_tunnel_sock(net, new6, &cfg);\n\t}\n#endif\n\n\twg_socket_reinit(wg, new4->sk, new6 ? new6->sk : NULL);\n\tret = 0;\nout:\n\tput_net(net);\n\treturn ret;\n}\n\nvoid wg_socket_reinit(struct wg_device *wg, struct sock *new4,\n\t\t      struct sock *new6)\n{\n\tstruct sock *old4, *old6;\n\n\tmutex_lock(&wg->socket_update_lock);\n\told4 = rcu_dereference_protected(wg->sock4,\n\t\t\t\tlockdep_is_held(&wg->socket_update_lock));\n\told6 = rcu_dereference_protected(wg->sock6,\n\t\t\t\tlockdep_is_held(&wg->socket_update_lock));\n\trcu_assign_pointer(wg->sock4, new4);\n\trcu_assign_pointer(wg->sock6, new6);\n\tif (new4)\n\t\twg->incoming_port = ntohs(inet_sk(new4)->inet_sport);\n\tmutex_unlock(&wg->socket_update_lock);\n\tsynchronize_net();\n\tsock_free(old4);\n\tsock_free(old6);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}