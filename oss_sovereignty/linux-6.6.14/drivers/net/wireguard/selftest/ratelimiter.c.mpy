{
  "module_name": "ratelimiter.c",
  "hash_id": "68c4c998907ada935515132ecb4a41a09ed7dce43d44710d6ffe9027766d0586",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireguard/selftest/ratelimiter.c",
  "human_readable_source": "\n \n\n#ifdef DEBUG\n\n#include <linux/jiffies.h>\n\nstatic const struct {\n\tbool result;\n\tunsigned int msec_to_sleep_before;\n} expected_results[] __initconst = {\n\t[0 ... PACKETS_BURSTABLE - 1] = { true, 0 },\n\t[PACKETS_BURSTABLE] = { false, 0 },\n\t[PACKETS_BURSTABLE + 1] = { true, MSEC_PER_SEC / PACKETS_PER_SECOND },\n\t[PACKETS_BURSTABLE + 2] = { false, 0 },\n\t[PACKETS_BURSTABLE + 3] = { true, (MSEC_PER_SEC / PACKETS_PER_SECOND) * 2 },\n\t[PACKETS_BURSTABLE + 4] = { true, 0 },\n\t[PACKETS_BURSTABLE + 5] = { false, 0 }\n};\n\nstatic __init unsigned int maximum_jiffies_at_index(int index)\n{\n\tunsigned int total_msecs = 2 * MSEC_PER_SEC / PACKETS_PER_SECOND / 3;\n\tint i;\n\n\tfor (i = 0; i <= index; ++i)\n\t\ttotal_msecs += expected_results[i].msec_to_sleep_before;\n\treturn msecs_to_jiffies(total_msecs);\n}\n\nstatic __init int timings_test(struct sk_buff *skb4, struct iphdr *hdr4,\n\t\t\t       struct sk_buff *skb6, struct ipv6hdr *hdr6,\n\t\t\t       int *test)\n{\n\tunsigned long loop_start_time;\n\tint i;\n\n\twg_ratelimiter_gc_entries(NULL);\n\trcu_barrier();\n\tloop_start_time = jiffies;\n\n\tfor (i = 0; i < ARRAY_SIZE(expected_results); ++i) {\n\t\tif (expected_results[i].msec_to_sleep_before)\n\t\t\tmsleep(expected_results[i].msec_to_sleep_before);\n\n\t\tif (time_is_before_jiffies(loop_start_time +\n\t\t\t\t\t   maximum_jiffies_at_index(i)))\n\t\t\treturn -ETIMEDOUT;\n\t\tif (wg_ratelimiter_allow(skb4, &init_net) !=\n\t\t\t\t\texpected_results[i].result)\n\t\t\treturn -EXFULL;\n\t\t++(*test);\n\n\t\thdr4->saddr = htonl(ntohl(hdr4->saddr) + i + 1);\n\t\tif (time_is_before_jiffies(loop_start_time +\n\t\t\t\t\t   maximum_jiffies_at_index(i)))\n\t\t\treturn -ETIMEDOUT;\n\t\tif (!wg_ratelimiter_allow(skb4, &init_net))\n\t\t\treturn -EXFULL;\n\t\t++(*test);\n\n\t\thdr4->saddr = htonl(ntohl(hdr4->saddr) - i - 1);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t\thdr6->saddr.in6_u.u6_addr32[2] = htonl(i);\n\t\thdr6->saddr.in6_u.u6_addr32[3] = htonl(i);\n\t\tif (time_is_before_jiffies(loop_start_time +\n\t\t\t\t\t   maximum_jiffies_at_index(i)))\n\t\t\treturn -ETIMEDOUT;\n\t\tif (wg_ratelimiter_allow(skb6, &init_net) !=\n\t\t\t\t\texpected_results[i].result)\n\t\t\treturn -EXFULL;\n\t\t++(*test);\n\n\t\thdr6->saddr.in6_u.u6_addr32[0] =\n\t\t\thtonl(ntohl(hdr6->saddr.in6_u.u6_addr32[0]) + i + 1);\n\t\tif (time_is_before_jiffies(loop_start_time +\n\t\t\t\t\t   maximum_jiffies_at_index(i)))\n\t\t\treturn -ETIMEDOUT;\n\t\tif (!wg_ratelimiter_allow(skb6, &init_net))\n\t\t\treturn -EXFULL;\n\t\t++(*test);\n\n\t\thdr6->saddr.in6_u.u6_addr32[0] =\n\t\t\thtonl(ntohl(hdr6->saddr.in6_u.u6_addr32[0]) - i - 1);\n\n\t\tif (time_is_before_jiffies(loop_start_time +\n\t\t\t\t\t   maximum_jiffies_at_index(i)))\n\t\t\treturn -ETIMEDOUT;\n#endif\n\t}\n\treturn 0;\n}\n\nstatic __init int capacity_test(struct sk_buff *skb4, struct iphdr *hdr4,\n\t\t\t\tint *test)\n{\n\tint i;\n\n\twg_ratelimiter_gc_entries(NULL);\n\trcu_barrier();\n\n\tif (atomic_read(&total_entries))\n\t\treturn -EXFULL;\n\t++(*test);\n\n\tfor (i = 0; i <= max_entries; ++i) {\n\t\thdr4->saddr = htonl(i);\n\t\tif (wg_ratelimiter_allow(skb4, &init_net) != (i != max_entries))\n\t\t\treturn -EXFULL;\n\t\t++(*test);\n\t}\n\treturn 0;\n}\n\nbool __init wg_ratelimiter_selftest(void)\n{\n\tenum { TRIALS_BEFORE_GIVING_UP = 5000 };\n\tbool success = false;\n\tint test = 0, trials;\n\tstruct sk_buff *skb4, *skb6 = NULL;\n\tstruct iphdr *hdr4;\n\tstruct ipv6hdr *hdr6 = NULL;\n\n\tif (IS_ENABLED(CONFIG_KASAN) || IS_ENABLED(CONFIG_UBSAN))\n\t\treturn true;\n\n\tBUILD_BUG_ON(MSEC_PER_SEC % PACKETS_PER_SECOND != 0);\n\n\tif (wg_ratelimiter_init())\n\t\tgoto out;\n\t++test;\n\tif (wg_ratelimiter_init()) {\n\t\twg_ratelimiter_uninit();\n\t\tgoto out;\n\t}\n\t++test;\n\tif (wg_ratelimiter_init()) {\n\t\twg_ratelimiter_uninit();\n\t\twg_ratelimiter_uninit();\n\t\tgoto out;\n\t}\n\t++test;\n\n\tskb4 = alloc_skb(sizeof(struct iphdr), GFP_KERNEL);\n\tif (unlikely(!skb4))\n\t\tgoto err_nofree;\n\tskb4->protocol = htons(ETH_P_IP);\n\thdr4 = (struct iphdr *)skb_put(skb4, sizeof(*hdr4));\n\thdr4->saddr = htonl(8182);\n\tskb_reset_network_header(skb4);\n\t++test;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tskb6 = alloc_skb(sizeof(struct ipv6hdr), GFP_KERNEL);\n\tif (unlikely(!skb6)) {\n\t\tkfree_skb(skb4);\n\t\tgoto err_nofree;\n\t}\n\tskb6->protocol = htons(ETH_P_IPV6);\n\thdr6 = (struct ipv6hdr *)skb_put(skb6, sizeof(*hdr6));\n\thdr6->saddr.in6_u.u6_addr32[0] = htonl(1212);\n\thdr6->saddr.in6_u.u6_addr32[1] = htonl(289188);\n\tskb_reset_network_header(skb6);\n\t++test;\n#endif\n\n\tfor (trials = TRIALS_BEFORE_GIVING_UP; IS_ENABLED(DEBUG_RATELIMITER_TIMINGS);) {\n\t\tint test_count = 0, ret;\n\n\t\tret = timings_test(skb4, hdr4, skb6, hdr6, &test_count);\n\t\tif (ret == -ETIMEDOUT) {\n\t\t\tif (!trials--) {\n\t\t\t\ttest += test_count;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tcontinue;\n\t\t} else if (ret < 0) {\n\t\t\ttest += test_count;\n\t\t\tgoto err;\n\t\t} else {\n\t\t\ttest += test_count;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (trials = TRIALS_BEFORE_GIVING_UP;;) {\n\t\tint test_count = 0;\n\n\t\tif (capacity_test(skb4, hdr4, &test_count) < 0) {\n\t\t\tif (!trials--) {\n\t\t\t\ttest += test_count;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\ttest += test_count;\n\t\tbreak;\n\t}\n\n\tsuccess = true;\n\nerr:\n\tkfree_skb(skb4);\n#if IS_ENABLED(CONFIG_IPV6)\n\tkfree_skb(skb6);\n#endif\nerr_nofree:\n\twg_ratelimiter_uninit();\n\twg_ratelimiter_uninit();\n\twg_ratelimiter_uninit();\n\t \n\twg_ratelimiter_uninit();\nout:\n\tif (success)\n\t\tpr_info(\"ratelimiter self-tests: pass\\n\");\n\telse\n\t\tpr_err(\"ratelimiter self-test %d: FAIL\\n\", test);\n\n\treturn success;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}