{
  "module_name": "allowedips.c",
  "hash_id": "821c8787dfe059c9ca7256952c76940c31041c71b23c2af45c50f32a13058f12",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireguard/selftest/allowedips.c",
  "human_readable_source": "\n \n\n#ifdef DEBUG\n\n#include <linux/siphash.h>\n\nstatic __init void print_node(struct allowedips_node *node, u8 bits)\n{\n\tchar *fmt_connection = KERN_DEBUG \"\\t\\\"%p/%d\\\" -> \\\"%p/%d\\\";\\n\";\n\tchar *fmt_declaration = KERN_DEBUG \"\\t\\\"%p/%d\\\"[style=%s, color=\\\"#%06x\\\"];\\n\";\n\tu8 ip1[16], ip2[16], cidr1, cidr2;\n\tchar *style = \"dotted\";\n\tu32 color = 0;\n\n\tif (node == NULL)\n\t\treturn;\n\tif (bits == 32) {\n\t\tfmt_connection = KERN_DEBUG \"\\t\\\"%pI4/%d\\\" -> \\\"%pI4/%d\\\";\\n\";\n\t\tfmt_declaration = KERN_DEBUG \"\\t\\\"%pI4/%d\\\"[style=%s, color=\\\"#%06x\\\"];\\n\";\n\t} else if (bits == 128) {\n\t\tfmt_connection = KERN_DEBUG \"\\t\\\"%pI6/%d\\\" -> \\\"%pI6/%d\\\";\\n\";\n\t\tfmt_declaration = KERN_DEBUG \"\\t\\\"%pI6/%d\\\"[style=%s, color=\\\"#%06x\\\"];\\n\";\n\t}\n\tif (node->peer) {\n\t\thsiphash_key_t key = { { 0 } };\n\n\t\tmemcpy(&key, &node->peer, sizeof(node->peer));\n\t\tcolor = hsiphash_1u32(0xdeadbeef, &key) % 200 << 16 |\n\t\t\thsiphash_1u32(0xbabecafe, &key) % 200 << 8 |\n\t\t\thsiphash_1u32(0xabad1dea, &key) % 200;\n\t\tstyle = \"bold\";\n\t}\n\twg_allowedips_read_node(node, ip1, &cidr1);\n\tprintk(fmt_declaration, ip1, cidr1, style, color);\n\tif (node->bit[0]) {\n\t\twg_allowedips_read_node(rcu_dereference_raw(node->bit[0]), ip2, &cidr2);\n\t\tprintk(fmt_connection, ip1, cidr1, ip2, cidr2);\n\t}\n\tif (node->bit[1]) {\n\t\twg_allowedips_read_node(rcu_dereference_raw(node->bit[1]), ip2, &cidr2);\n\t\tprintk(fmt_connection, ip1, cidr1, ip2, cidr2);\n\t}\n\tif (node->bit[0])\n\t\tprint_node(rcu_dereference_raw(node->bit[0]), bits);\n\tif (node->bit[1])\n\t\tprint_node(rcu_dereference_raw(node->bit[1]), bits);\n}\n\nstatic __init void print_tree(struct allowedips_node __rcu *top, u8 bits)\n{\n\tprintk(KERN_DEBUG \"digraph trie {\\n\");\n\tprint_node(rcu_dereference_raw(top), bits);\n\tprintk(KERN_DEBUG \"}\\n\");\n}\n\nenum {\n\tNUM_PEERS = 2000,\n\tNUM_RAND_ROUTES = 400,\n\tNUM_MUTATED_ROUTES = 100,\n\tNUM_QUERIES = NUM_RAND_ROUTES * NUM_MUTATED_ROUTES * 30\n};\n\nstruct horrible_allowedips {\n\tstruct hlist_head head;\n};\n\nstruct horrible_allowedips_node {\n\tstruct hlist_node table;\n\tunion nf_inet_addr ip;\n\tunion nf_inet_addr mask;\n\tu8 ip_version;\n\tvoid *value;\n};\n\nstatic __init void horrible_allowedips_init(struct horrible_allowedips *table)\n{\n\tINIT_HLIST_HEAD(&table->head);\n}\n\nstatic __init void horrible_allowedips_free(struct horrible_allowedips *table)\n{\n\tstruct horrible_allowedips_node *node;\n\tstruct hlist_node *h;\n\n\thlist_for_each_entry_safe(node, h, &table->head, table) {\n\t\thlist_del(&node->table);\n\t\tkfree(node);\n\t}\n}\n\nstatic __init inline union nf_inet_addr horrible_cidr_to_mask(u8 cidr)\n{\n\tunion nf_inet_addr mask;\n\n\tmemset(&mask, 0, sizeof(mask));\n\tmemset(&mask.all, 0xff, cidr / 8);\n\tif (cidr % 32)\n\t\tmask.all[cidr / 32] = (__force u32)htonl(\n\t\t\t(0xFFFFFFFFUL << (32 - (cidr % 32))) & 0xFFFFFFFFUL);\n\treturn mask;\n}\n\nstatic __init inline u8 horrible_mask_to_cidr(union nf_inet_addr subnet)\n{\n\treturn hweight32(subnet.all[0]) + hweight32(subnet.all[1]) +\n\t       hweight32(subnet.all[2]) + hweight32(subnet.all[3]);\n}\n\nstatic __init inline void\nhorrible_mask_self(struct horrible_allowedips_node *node)\n{\n\tif (node->ip_version == 4) {\n\t\tnode->ip.ip &= node->mask.ip;\n\t} else if (node->ip_version == 6) {\n\t\tnode->ip.ip6[0] &= node->mask.ip6[0];\n\t\tnode->ip.ip6[1] &= node->mask.ip6[1];\n\t\tnode->ip.ip6[2] &= node->mask.ip6[2];\n\t\tnode->ip.ip6[3] &= node->mask.ip6[3];\n\t}\n}\n\nstatic __init inline bool\nhorrible_match_v4(const struct horrible_allowedips_node *node, struct in_addr *ip)\n{\n\treturn (ip->s_addr & node->mask.ip) == node->ip.ip;\n}\n\nstatic __init inline bool\nhorrible_match_v6(const struct horrible_allowedips_node *node, struct in6_addr *ip)\n{\n\treturn (ip->in6_u.u6_addr32[0] & node->mask.ip6[0]) == node->ip.ip6[0] &&\n\t       (ip->in6_u.u6_addr32[1] & node->mask.ip6[1]) == node->ip.ip6[1] &&\n\t       (ip->in6_u.u6_addr32[2] & node->mask.ip6[2]) == node->ip.ip6[2] &&\n\t       (ip->in6_u.u6_addr32[3] & node->mask.ip6[3]) == node->ip.ip6[3];\n}\n\nstatic __init void\nhorrible_insert_ordered(struct horrible_allowedips *table, struct horrible_allowedips_node *node)\n{\n\tstruct horrible_allowedips_node *other = NULL, *where = NULL;\n\tu8 my_cidr = horrible_mask_to_cidr(node->mask);\n\n\thlist_for_each_entry(other, &table->head, table) {\n\t\tif (other->ip_version == node->ip_version &&\n\t\t    !memcmp(&other->mask, &node->mask, sizeof(union nf_inet_addr)) &&\n\t\t    !memcmp(&other->ip, &node->ip, sizeof(union nf_inet_addr))) {\n\t\t\tother->value = node->value;\n\t\t\tkfree(node);\n\t\t\treturn;\n\t\t}\n\t}\n\thlist_for_each_entry(other, &table->head, table) {\n\t\twhere = other;\n\t\tif (horrible_mask_to_cidr(other->mask) <= my_cidr)\n\t\t\tbreak;\n\t}\n\tif (!other && !where)\n\t\thlist_add_head(&node->table, &table->head);\n\telse if (!other)\n\t\thlist_add_behind(&node->table, &where->table);\n\telse\n\t\thlist_add_before(&node->table, &where->table);\n}\n\nstatic __init int\nhorrible_allowedips_insert_v4(struct horrible_allowedips *table,\n\t\t\t      struct in_addr *ip, u8 cidr, void *value)\n{\n\tstruct horrible_allowedips_node *node = kzalloc(sizeof(*node), GFP_KERNEL);\n\n\tif (unlikely(!node))\n\t\treturn -ENOMEM;\n\tnode->ip.in = *ip;\n\tnode->mask = horrible_cidr_to_mask(cidr);\n\tnode->ip_version = 4;\n\tnode->value = value;\n\thorrible_mask_self(node);\n\thorrible_insert_ordered(table, node);\n\treturn 0;\n}\n\nstatic __init int\nhorrible_allowedips_insert_v6(struct horrible_allowedips *table,\n\t\t\t      struct in6_addr *ip, u8 cidr, void *value)\n{\n\tstruct horrible_allowedips_node *node = kzalloc(sizeof(*node), GFP_KERNEL);\n\n\tif (unlikely(!node))\n\t\treturn -ENOMEM;\n\tnode->ip.in6 = *ip;\n\tnode->mask = horrible_cidr_to_mask(cidr);\n\tnode->ip_version = 6;\n\tnode->value = value;\n\thorrible_mask_self(node);\n\thorrible_insert_ordered(table, node);\n\treturn 0;\n}\n\nstatic __init void *\nhorrible_allowedips_lookup_v4(struct horrible_allowedips *table, struct in_addr *ip)\n{\n\tstruct horrible_allowedips_node *node;\n\n\thlist_for_each_entry(node, &table->head, table) {\n\t\tif (node->ip_version == 4 && horrible_match_v4(node, ip))\n\t\t\treturn node->value;\n\t}\n\treturn NULL;\n}\n\nstatic __init void *\nhorrible_allowedips_lookup_v6(struct horrible_allowedips *table, struct in6_addr *ip)\n{\n\tstruct horrible_allowedips_node *node;\n\n\thlist_for_each_entry(node, &table->head, table) {\n\t\tif (node->ip_version == 6 && horrible_match_v6(node, ip))\n\t\t\treturn node->value;\n\t}\n\treturn NULL;\n}\n\n\nstatic __init void\nhorrible_allowedips_remove_by_value(struct horrible_allowedips *table, void *value)\n{\n\tstruct horrible_allowedips_node *node;\n\tstruct hlist_node *h;\n\n\thlist_for_each_entry_safe(node, h, &table->head, table) {\n\t\tif (node->value != value)\n\t\t\tcontinue;\n\t\thlist_del(&node->table);\n\t\tkfree(node);\n\t}\n\n}\n\nstatic __init bool randomized_test(void)\n{\n\tunsigned int i, j, k, mutate_amount, cidr;\n\tu8 ip[16], mutate_mask[16], mutated[16];\n\tstruct wg_peer **peers, *peer;\n\tstruct horrible_allowedips h;\n\tDEFINE_MUTEX(mutex);\n\tstruct allowedips t;\n\tbool ret = false;\n\n\tmutex_init(&mutex);\n\n\twg_allowedips_init(&t);\n\thorrible_allowedips_init(&h);\n\n\tpeers = kcalloc(NUM_PEERS, sizeof(*peers), GFP_KERNEL);\n\tif (unlikely(!peers)) {\n\t\tpr_err(\"allowedips random self-test malloc: FAIL\\n\");\n\t\tgoto free;\n\t}\n\tfor (i = 0; i < NUM_PEERS; ++i) {\n\t\tpeers[i] = kzalloc(sizeof(*peers[i]), GFP_KERNEL);\n\t\tif (unlikely(!peers[i])) {\n\t\t\tpr_err(\"allowedips random self-test malloc: FAIL\\n\");\n\t\t\tgoto free;\n\t\t}\n\t\tkref_init(&peers[i]->refcount);\n\t\tINIT_LIST_HEAD(&peers[i]->allowedips_list);\n\t}\n\n\tmutex_lock(&mutex);\n\n\tfor (i = 0; i < NUM_RAND_ROUTES; ++i) {\n\t\tget_random_bytes(ip, 4);\n\t\tcidr = get_random_u32_inclusive(1, 32);\n\t\tpeer = peers[get_random_u32_below(NUM_PEERS)];\n\t\tif (wg_allowedips_insert_v4(&t, (struct in_addr *)ip, cidr,\n\t\t\t\t\t    peer, &mutex) < 0) {\n\t\t\tpr_err(\"allowedips random self-test malloc: FAIL\\n\");\n\t\t\tgoto free_locked;\n\t\t}\n\t\tif (horrible_allowedips_insert_v4(&h, (struct in_addr *)ip,\n\t\t\t\t\t\t  cidr, peer) < 0) {\n\t\t\tpr_err(\"allowedips random self-test malloc: FAIL\\n\");\n\t\t\tgoto free_locked;\n\t\t}\n\t\tfor (j = 0; j < NUM_MUTATED_ROUTES; ++j) {\n\t\t\tmemcpy(mutated, ip, 4);\n\t\t\tget_random_bytes(mutate_mask, 4);\n\t\t\tmutate_amount = get_random_u32_below(32);\n\t\t\tfor (k = 0; k < mutate_amount / 8; ++k)\n\t\t\t\tmutate_mask[k] = 0xff;\n\t\t\tmutate_mask[k] = 0xff\n\t\t\t\t\t << ((8 - (mutate_amount % 8)) % 8);\n\t\t\tfor (; k < 4; ++k)\n\t\t\t\tmutate_mask[k] = 0;\n\t\t\tfor (k = 0; k < 4; ++k)\n\t\t\t\tmutated[k] = (mutated[k] & mutate_mask[k]) |\n\t\t\t\t\t     (~mutate_mask[k] &\n\t\t\t\t\t      get_random_u8());\n\t\t\tcidr = get_random_u32_inclusive(1, 32);\n\t\t\tpeer = peers[get_random_u32_below(NUM_PEERS)];\n\t\t\tif (wg_allowedips_insert_v4(&t,\n\t\t\t\t\t\t    (struct in_addr *)mutated,\n\t\t\t\t\t\t    cidr, peer, &mutex) < 0) {\n\t\t\t\tpr_err(\"allowedips random self-test malloc: FAIL\\n\");\n\t\t\t\tgoto free_locked;\n\t\t\t}\n\t\t\tif (horrible_allowedips_insert_v4(&h,\n\t\t\t\t(struct in_addr *)mutated, cidr, peer)) {\n\t\t\t\tpr_err(\"allowedips random self-test malloc: FAIL\\n\");\n\t\t\t\tgoto free_locked;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < NUM_RAND_ROUTES; ++i) {\n\t\tget_random_bytes(ip, 16);\n\t\tcidr = get_random_u32_inclusive(1, 128);\n\t\tpeer = peers[get_random_u32_below(NUM_PEERS)];\n\t\tif (wg_allowedips_insert_v6(&t, (struct in6_addr *)ip, cidr,\n\t\t\t\t\t    peer, &mutex) < 0) {\n\t\t\tpr_err(\"allowedips random self-test malloc: FAIL\\n\");\n\t\t\tgoto free_locked;\n\t\t}\n\t\tif (horrible_allowedips_insert_v6(&h, (struct in6_addr *)ip,\n\t\t\t\t\t\t  cidr, peer) < 0) {\n\t\t\tpr_err(\"allowedips random self-test malloc: FAIL\\n\");\n\t\t\tgoto free_locked;\n\t\t}\n\t\tfor (j = 0; j < NUM_MUTATED_ROUTES; ++j) {\n\t\t\tmemcpy(mutated, ip, 16);\n\t\t\tget_random_bytes(mutate_mask, 16);\n\t\t\tmutate_amount = get_random_u32_below(128);\n\t\t\tfor (k = 0; k < mutate_amount / 8; ++k)\n\t\t\t\tmutate_mask[k] = 0xff;\n\t\t\tmutate_mask[k] = 0xff\n\t\t\t\t\t << ((8 - (mutate_amount % 8)) % 8);\n\t\t\tfor (; k < 4; ++k)\n\t\t\t\tmutate_mask[k] = 0;\n\t\t\tfor (k = 0; k < 4; ++k)\n\t\t\t\tmutated[k] = (mutated[k] & mutate_mask[k]) |\n\t\t\t\t\t     (~mutate_mask[k] &\n\t\t\t\t\t      get_random_u8());\n\t\t\tcidr = get_random_u32_inclusive(1, 128);\n\t\t\tpeer = peers[get_random_u32_below(NUM_PEERS)];\n\t\t\tif (wg_allowedips_insert_v6(&t,\n\t\t\t\t\t\t    (struct in6_addr *)mutated,\n\t\t\t\t\t\t    cidr, peer, &mutex) < 0) {\n\t\t\t\tpr_err(\"allowedips random self-test malloc: FAIL\\n\");\n\t\t\t\tgoto free_locked;\n\t\t\t}\n\t\t\tif (horrible_allowedips_insert_v6(\n\t\t\t\t    &h, (struct in6_addr *)mutated, cidr,\n\t\t\t\t    peer)) {\n\t\t\t\tpr_err(\"allowedips random self-test malloc: FAIL\\n\");\n\t\t\t\tgoto free_locked;\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&mutex);\n\n\tif (IS_ENABLED(DEBUG_PRINT_TRIE_GRAPHVIZ)) {\n\t\tprint_tree(t.root4, 32);\n\t\tprint_tree(t.root6, 128);\n\t}\n\n\tfor (j = 0;; ++j) {\n\t\tfor (i = 0; i < NUM_QUERIES; ++i) {\n\t\t\tget_random_bytes(ip, 4);\n\t\t\tif (lookup(t.root4, 32, ip) != horrible_allowedips_lookup_v4(&h, (struct in_addr *)ip)) {\n\t\t\t\thorrible_allowedips_lookup_v4(&h, (struct in_addr *)ip);\n\t\t\t\tpr_err(\"allowedips random v4 self-test: FAIL\\n\");\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\tget_random_bytes(ip, 16);\n\t\t\tif (lookup(t.root6, 128, ip) != horrible_allowedips_lookup_v6(&h, (struct in6_addr *)ip)) {\n\t\t\t\tpr_err(\"allowedips random v6 self-test: FAIL\\n\");\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t}\n\t\tif (j >= NUM_PEERS)\n\t\t\tbreak;\n\t\tmutex_lock(&mutex);\n\t\twg_allowedips_remove_by_peer(&t, peers[j], &mutex);\n\t\tmutex_unlock(&mutex);\n\t\thorrible_allowedips_remove_by_value(&h, peers[j]);\n\t}\n\n\tif (t.root4 || t.root6) {\n\t\tpr_err(\"allowedips random self-test removal: FAIL\\n\");\n\t\tgoto free;\n\t}\n\n\tret = true;\n\nfree:\n\tmutex_lock(&mutex);\nfree_locked:\n\twg_allowedips_free(&t, &mutex);\n\tmutex_unlock(&mutex);\n\thorrible_allowedips_free(&h);\n\tif (peers) {\n\t\tfor (i = 0; i < NUM_PEERS; ++i)\n\t\t\tkfree(peers[i]);\n\t}\n\tkfree(peers);\n\treturn ret;\n}\n\nstatic __init inline struct in_addr *ip4(u8 a, u8 b, u8 c, u8 d)\n{\n\tstatic struct in_addr ip;\n\tu8 *split = (u8 *)&ip;\n\n\tsplit[0] = a;\n\tsplit[1] = b;\n\tsplit[2] = c;\n\tsplit[3] = d;\n\treturn &ip;\n}\n\nstatic __init inline struct in6_addr *ip6(u32 a, u32 b, u32 c, u32 d)\n{\n\tstatic struct in6_addr ip;\n\t__be32 *split = (__be32 *)&ip;\n\n\tsplit[0] = cpu_to_be32(a);\n\tsplit[1] = cpu_to_be32(b);\n\tsplit[2] = cpu_to_be32(c);\n\tsplit[3] = cpu_to_be32(d);\n\treturn &ip;\n}\n\nstatic __init struct wg_peer *init_peer(void)\n{\n\tstruct wg_peer *peer = kzalloc(sizeof(*peer), GFP_KERNEL);\n\n\tif (!peer)\n\t\treturn NULL;\n\tkref_init(&peer->refcount);\n\tINIT_LIST_HEAD(&peer->allowedips_list);\n\treturn peer;\n}\n\n#define insert(version, mem, ipa, ipb, ipc, ipd, cidr)                       \\\n\twg_allowedips_insert_v##version(&t, ip##version(ipa, ipb, ipc, ipd), \\\n\t\t\t\t\tcidr, mem, &mutex)\n\n#define maybe_fail() do {                                               \\\n\t\t++i;                                                    \\\n\t\tif (!_s) {                                              \\\n\t\t\tpr_info(\"allowedips self-test %zu: FAIL\\n\", i); \\\n\t\t\tsuccess = false;                                \\\n\t\t}                                                       \\\n\t} while (0)\n\n#define test(version, mem, ipa, ipb, ipc, ipd) do {                          \\\n\t\tbool _s = lookup(t.root##version, (version) == 4 ? 32 : 128, \\\n\t\t\t\t ip##version(ipa, ipb, ipc, ipd)) == (mem);  \\\n\t\tmaybe_fail();                                                \\\n\t} while (0)\n\n#define test_negative(version, mem, ipa, ipb, ipc, ipd) do {                 \\\n\t\tbool _s = lookup(t.root##version, (version) == 4 ? 32 : 128, \\\n\t\t\t\t ip##version(ipa, ipb, ipc, ipd)) != (mem);  \\\n\t\tmaybe_fail();                                                \\\n\t} while (0)\n\n#define test_boolean(cond) do {   \\\n\t\tbool _s = (cond); \\\n\t\tmaybe_fail();     \\\n\t} while (0)\n\nbool __init wg_allowedips_selftest(void)\n{\n\tbool found_a = false, found_b = false, found_c = false, found_d = false,\n\t     found_e = false, found_other = false;\n\tstruct wg_peer *a = init_peer(), *b = init_peer(), *c = init_peer(),\n\t\t       *d = init_peer(), *e = init_peer(), *f = init_peer(),\n\t\t       *g = init_peer(), *h = init_peer();\n\tstruct allowedips_node *iter_node;\n\tbool success = false;\n\tstruct allowedips t;\n\tDEFINE_MUTEX(mutex);\n\tstruct in6_addr ip;\n\tsize_t i = 0, count = 0;\n\t__be64 part;\n\n\tmutex_init(&mutex);\n\tmutex_lock(&mutex);\n\twg_allowedips_init(&t);\n\n\tif (!a || !b || !c || !d || !e || !f || !g || !h) {\n\t\tpr_err(\"allowedips self-test malloc: FAIL\\n\");\n\t\tgoto free;\n\t}\n\n\tinsert(4, a, 192, 168, 4, 0, 24);\n\tinsert(4, b, 192, 168, 4, 4, 32);\n\tinsert(4, c, 192, 168, 0, 0, 16);\n\tinsert(4, d, 192, 95, 5, 64, 27);\n\t \n\tinsert(4, c, 192, 95, 5, 65, 27);\n\tinsert(6, d, 0x26075300, 0x60006b00, 0, 0xc05f0543, 128);\n\tinsert(6, c, 0x26075300, 0x60006b00, 0, 0, 64);\n\tinsert(4, e, 0, 0, 0, 0, 0);\n\tinsert(6, e, 0, 0, 0, 0, 0);\n\t \n\tinsert(6, f, 0, 0, 0, 0, 0);\n\tinsert(6, g, 0x24046800, 0, 0, 0, 32);\n\t \n\tinsert(6, h, 0x24046800, 0x40040800, 0xdeadbeef, 0xdeadbeef, 64);\n\tinsert(6, a, 0x24046800, 0x40040800, 0xdeadbeef, 0xdeadbeef, 128);\n\tinsert(6, c, 0x24446800, 0x40e40800, 0xdeaebeef, 0xdefbeef, 128);\n\tinsert(6, b, 0x24446800, 0xf0e40800, 0xeeaebeef, 0, 98);\n\tinsert(4, g, 64, 15, 112, 0, 20);\n\t \n\tinsert(4, h, 64, 15, 123, 211, 25);\n\tinsert(4, a, 10, 0, 0, 0, 25);\n\tinsert(4, b, 10, 0, 0, 128, 25);\n\tinsert(4, a, 10, 1, 0, 0, 30);\n\tinsert(4, b, 10, 1, 0, 4, 30);\n\tinsert(4, c, 10, 1, 0, 8, 29);\n\tinsert(4, d, 10, 1, 0, 16, 29);\n\n\tif (IS_ENABLED(DEBUG_PRINT_TRIE_GRAPHVIZ)) {\n\t\tprint_tree(t.root4, 32);\n\t\tprint_tree(t.root6, 128);\n\t}\n\n\tsuccess = true;\n\n\ttest(4, a, 192, 168, 4, 20);\n\ttest(4, a, 192, 168, 4, 0);\n\ttest(4, b, 192, 168, 4, 4);\n\ttest(4, c, 192, 168, 200, 182);\n\ttest(4, c, 192, 95, 5, 68);\n\ttest(4, e, 192, 95, 5, 96);\n\ttest(6, d, 0x26075300, 0x60006b00, 0, 0xc05f0543);\n\ttest(6, c, 0x26075300, 0x60006b00, 0, 0xc02e01ee);\n\ttest(6, f, 0x26075300, 0x60006b01, 0, 0);\n\ttest(6, g, 0x24046800, 0x40040806, 0, 0x1006);\n\ttest(6, g, 0x24046800, 0x40040806, 0x1234, 0x5678);\n\ttest(6, f, 0x240467ff, 0x40040806, 0x1234, 0x5678);\n\ttest(6, f, 0x24046801, 0x40040806, 0x1234, 0x5678);\n\ttest(6, h, 0x24046800, 0x40040800, 0x1234, 0x5678);\n\ttest(6, h, 0x24046800, 0x40040800, 0, 0);\n\ttest(6, h, 0x24046800, 0x40040800, 0x10101010, 0x10101010);\n\ttest(6, a, 0x24046800, 0x40040800, 0xdeadbeef, 0xdeadbeef);\n\ttest(4, g, 64, 15, 116, 26);\n\ttest(4, g, 64, 15, 127, 3);\n\ttest(4, g, 64, 15, 123, 1);\n\ttest(4, h, 64, 15, 123, 128);\n\ttest(4, h, 64, 15, 123, 129);\n\ttest(4, a, 10, 0, 0, 52);\n\ttest(4, b, 10, 0, 0, 220);\n\ttest(4, a, 10, 1, 0, 2);\n\ttest(4, b, 10, 1, 0, 6);\n\ttest(4, c, 10, 1, 0, 10);\n\ttest(4, d, 10, 1, 0, 20);\n\n\tinsert(4, a, 1, 0, 0, 0, 32);\n\tinsert(4, a, 64, 0, 0, 0, 32);\n\tinsert(4, a, 128, 0, 0, 0, 32);\n\tinsert(4, a, 192, 0, 0, 0, 32);\n\tinsert(4, a, 255, 0, 0, 0, 32);\n\twg_allowedips_remove_by_peer(&t, a, &mutex);\n\ttest_negative(4, a, 1, 0, 0, 0);\n\ttest_negative(4, a, 64, 0, 0, 0);\n\ttest_negative(4, a, 128, 0, 0, 0);\n\ttest_negative(4, a, 192, 0, 0, 0);\n\ttest_negative(4, a, 255, 0, 0, 0);\n\n\twg_allowedips_free(&t, &mutex);\n\twg_allowedips_init(&t);\n\tinsert(4, a, 192, 168, 0, 0, 16);\n\tinsert(4, a, 192, 168, 0, 0, 24);\n\twg_allowedips_remove_by_peer(&t, a, &mutex);\n\ttest_negative(4, a, 192, 168, 0, 1);\n\n\t \n\tfor (i = 0; i < 64; ++i) {\n\t\tpart = cpu_to_be64(~0LLU << i);\n\t\tmemset(&ip, 0xff, 8);\n\t\tmemcpy((u8 *)&ip + 8, &part, 8);\n\t\twg_allowedips_insert_v6(&t, &ip, 128, a, &mutex);\n\t\tmemcpy(&ip, &part, 8);\n\t\tmemset((u8 *)&ip + 8, 0, 8);\n\t\twg_allowedips_insert_v6(&t, &ip, 128, a, &mutex);\n\t}\n\tmemset(&ip, 0, 16);\n\twg_allowedips_insert_v6(&t, &ip, 128, a, &mutex);\n\twg_allowedips_free(&t, &mutex);\n\n\twg_allowedips_init(&t);\n\tinsert(4, a, 192, 95, 5, 93, 27);\n\tinsert(6, a, 0x26075300, 0x60006b00, 0, 0xc05f0543, 128);\n\tinsert(4, a, 10, 1, 0, 20, 29);\n\tinsert(6, a, 0x26075300, 0x6d8a6bf8, 0xdab1f1df, 0xc05f1523, 83);\n\tinsert(6, a, 0x26075300, 0x6d8a6bf8, 0xdab1f1df, 0xc05f1523, 21);\n\tlist_for_each_entry(iter_node, &a->allowedips_list, peer_list) {\n\t\tu8 cidr, ip[16] __aligned(__alignof(u64));\n\t\tint family = wg_allowedips_read_node(iter_node, ip, &cidr);\n\n\t\tcount++;\n\n\t\tif (cidr == 27 && family == AF_INET &&\n\t\t    !memcmp(ip, ip4(192, 95, 5, 64), sizeof(struct in_addr)))\n\t\t\tfound_a = true;\n\t\telse if (cidr == 128 && family == AF_INET6 &&\n\t\t\t !memcmp(ip, ip6(0x26075300, 0x60006b00, 0, 0xc05f0543),\n\t\t\t\t sizeof(struct in6_addr)))\n\t\t\tfound_b = true;\n\t\telse if (cidr == 29 && family == AF_INET &&\n\t\t\t !memcmp(ip, ip4(10, 1, 0, 16), sizeof(struct in_addr)))\n\t\t\tfound_c = true;\n\t\telse if (cidr == 83 && family == AF_INET6 &&\n\t\t\t !memcmp(ip, ip6(0x26075300, 0x6d8a6bf8, 0xdab1e000, 0),\n\t\t\t\t sizeof(struct in6_addr)))\n\t\t\tfound_d = true;\n\t\telse if (cidr == 21 && family == AF_INET6 &&\n\t\t\t !memcmp(ip, ip6(0x26075000, 0, 0, 0),\n\t\t\t\t sizeof(struct in6_addr)))\n\t\t\tfound_e = true;\n\t\telse\n\t\t\tfound_other = true;\n\t}\n\ttest_boolean(count == 5);\n\ttest_boolean(found_a);\n\ttest_boolean(found_b);\n\ttest_boolean(found_c);\n\ttest_boolean(found_d);\n\ttest_boolean(found_e);\n\ttest_boolean(!found_other);\n\n\tif (IS_ENABLED(DEBUG_RANDOM_TRIE) && success)\n\t\tsuccess = randomized_test();\n\n\tif (success)\n\t\tpr_info(\"allowedips self-tests: pass\\n\");\n\nfree:\n\twg_allowedips_free(&t, &mutex);\n\tkfree(a);\n\tkfree(b);\n\tkfree(c);\n\tkfree(d);\n\tkfree(e);\n\tkfree(f);\n\tkfree(g);\n\tkfree(h);\n\tmutex_unlock(&mutex);\n\n\treturn success;\n}\n\n#undef test_negative\n#undef test\n#undef remove\n#undef insert\n#undef init_peer\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}