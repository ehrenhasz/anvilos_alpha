{
  "module_name": "netlink.c",
  "hash_id": "ba92752961e8028aa976785899bb273b9f4bdedb1d9e1ac9048bca655e4e06ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireguard/netlink.c",
  "human_readable_source": "\n \n\n#include \"netlink.h\"\n#include \"device.h\"\n#include \"peer.h\"\n#include \"socket.h\"\n#include \"queueing.h\"\n#include \"messages.h\"\n\n#include <uapi/linux/wireguard.h>\n\n#include <linux/if.h>\n#include <net/genetlink.h>\n#include <net/sock.h>\n#include <crypto/algapi.h>\n\nstatic struct genl_family genl_family;\n\nstatic const struct nla_policy device_policy[WGDEVICE_A_MAX + 1] = {\n\t[WGDEVICE_A_IFINDEX]\t\t= { .type = NLA_U32 },\n\t[WGDEVICE_A_IFNAME]\t\t= { .type = NLA_NUL_STRING, .len = IFNAMSIZ - 1 },\n\t[WGDEVICE_A_PRIVATE_KEY]\t= NLA_POLICY_EXACT_LEN(NOISE_PUBLIC_KEY_LEN),\n\t[WGDEVICE_A_PUBLIC_KEY]\t\t= NLA_POLICY_EXACT_LEN(NOISE_PUBLIC_KEY_LEN),\n\t[WGDEVICE_A_FLAGS]\t\t= { .type = NLA_U32 },\n\t[WGDEVICE_A_LISTEN_PORT]\t= { .type = NLA_U16 },\n\t[WGDEVICE_A_FWMARK]\t\t= { .type = NLA_U32 },\n\t[WGDEVICE_A_PEERS]\t\t= { .type = NLA_NESTED }\n};\n\nstatic const struct nla_policy peer_policy[WGPEER_A_MAX + 1] = {\n\t[WGPEER_A_PUBLIC_KEY]\t\t\t\t= NLA_POLICY_EXACT_LEN(NOISE_PUBLIC_KEY_LEN),\n\t[WGPEER_A_PRESHARED_KEY]\t\t\t= NLA_POLICY_EXACT_LEN(NOISE_SYMMETRIC_KEY_LEN),\n\t[WGPEER_A_FLAGS]\t\t\t\t= { .type = NLA_U32 },\n\t[WGPEER_A_ENDPOINT]\t\t\t\t= NLA_POLICY_MIN_LEN(sizeof(struct sockaddr)),\n\t[WGPEER_A_PERSISTENT_KEEPALIVE_INTERVAL]\t= { .type = NLA_U16 },\n\t[WGPEER_A_LAST_HANDSHAKE_TIME]\t\t\t= NLA_POLICY_EXACT_LEN(sizeof(struct __kernel_timespec)),\n\t[WGPEER_A_RX_BYTES]\t\t\t\t= { .type = NLA_U64 },\n\t[WGPEER_A_TX_BYTES]\t\t\t\t= { .type = NLA_U64 },\n\t[WGPEER_A_ALLOWEDIPS]\t\t\t\t= { .type = NLA_NESTED },\n\t[WGPEER_A_PROTOCOL_VERSION]\t\t\t= { .type = NLA_U32 }\n};\n\nstatic const struct nla_policy allowedip_policy[WGALLOWEDIP_A_MAX + 1] = {\n\t[WGALLOWEDIP_A_FAMILY]\t\t= { .type = NLA_U16 },\n\t[WGALLOWEDIP_A_IPADDR]\t\t= NLA_POLICY_MIN_LEN(sizeof(struct in_addr)),\n\t[WGALLOWEDIP_A_CIDR_MASK]\t= { .type = NLA_U8 }\n};\n\nstatic struct wg_device *lookup_interface(struct nlattr **attrs,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct net_device *dev = NULL;\n\n\tif (!attrs[WGDEVICE_A_IFINDEX] == !attrs[WGDEVICE_A_IFNAME])\n\t\treturn ERR_PTR(-EBADR);\n\tif (attrs[WGDEVICE_A_IFINDEX])\n\t\tdev = dev_get_by_index(sock_net(skb->sk),\n\t\t\t\t       nla_get_u32(attrs[WGDEVICE_A_IFINDEX]));\n\telse if (attrs[WGDEVICE_A_IFNAME])\n\t\tdev = dev_get_by_name(sock_net(skb->sk),\n\t\t\t\t      nla_data(attrs[WGDEVICE_A_IFNAME]));\n\tif (!dev)\n\t\treturn ERR_PTR(-ENODEV);\n\tif (!dev->rtnl_link_ops || !dev->rtnl_link_ops->kind ||\n\t    strcmp(dev->rtnl_link_ops->kind, KBUILD_MODNAME)) {\n\t\tdev_put(dev);\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\treturn netdev_priv(dev);\n}\n\nstatic int get_allowedips(struct sk_buff *skb, const u8 *ip, u8 cidr,\n\t\t\t  int family)\n{\n\tstruct nlattr *allowedip_nest;\n\n\tallowedip_nest = nla_nest_start(skb, 0);\n\tif (!allowedip_nest)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u8(skb, WGALLOWEDIP_A_CIDR_MASK, cidr) ||\n\t    nla_put_u16(skb, WGALLOWEDIP_A_FAMILY, family) ||\n\t    nla_put(skb, WGALLOWEDIP_A_IPADDR, family == AF_INET6 ?\n\t\t    sizeof(struct in6_addr) : sizeof(struct in_addr), ip)) {\n\t\tnla_nest_cancel(skb, allowedip_nest);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tnla_nest_end(skb, allowedip_nest);\n\treturn 0;\n}\n\nstruct dump_ctx {\n\tstruct wg_device *wg;\n\tstruct wg_peer *next_peer;\n\tu64 allowedips_seq;\n\tstruct allowedips_node *next_allowedip;\n};\n\n#define DUMP_CTX(cb) ((struct dump_ctx *)(cb)->args)\n\nstatic int\nget_peer(struct wg_peer *peer, struct sk_buff *skb, struct dump_ctx *ctx)\n{\n\n\tstruct nlattr *allowedips_nest, *peer_nest = nla_nest_start(skb, 0);\n\tstruct allowedips_node *allowedips_node = ctx->next_allowedip;\n\tbool fail;\n\n\tif (!peer_nest)\n\t\treturn -EMSGSIZE;\n\n\tdown_read(&peer->handshake.lock);\n\tfail = nla_put(skb, WGPEER_A_PUBLIC_KEY, NOISE_PUBLIC_KEY_LEN,\n\t\t       peer->handshake.remote_static);\n\tup_read(&peer->handshake.lock);\n\tif (fail)\n\t\tgoto err;\n\n\tif (!allowedips_node) {\n\t\tconst struct __kernel_timespec last_handshake = {\n\t\t\t.tv_sec = peer->walltime_last_handshake.tv_sec,\n\t\t\t.tv_nsec = peer->walltime_last_handshake.tv_nsec\n\t\t};\n\n\t\tdown_read(&peer->handshake.lock);\n\t\tfail = nla_put(skb, WGPEER_A_PRESHARED_KEY,\n\t\t\t       NOISE_SYMMETRIC_KEY_LEN,\n\t\t\t       peer->handshake.preshared_key);\n\t\tup_read(&peer->handshake.lock);\n\t\tif (fail)\n\t\t\tgoto err;\n\n\t\tif (nla_put(skb, WGPEER_A_LAST_HANDSHAKE_TIME,\n\t\t\t    sizeof(last_handshake), &last_handshake) ||\n\t\t    nla_put_u16(skb, WGPEER_A_PERSISTENT_KEEPALIVE_INTERVAL,\n\t\t\t\tpeer->persistent_keepalive_interval) ||\n\t\t    nla_put_u64_64bit(skb, WGPEER_A_TX_BYTES, peer->tx_bytes,\n\t\t\t\t      WGPEER_A_UNSPEC) ||\n\t\t    nla_put_u64_64bit(skb, WGPEER_A_RX_BYTES, peer->rx_bytes,\n\t\t\t\t      WGPEER_A_UNSPEC) ||\n\t\t    nla_put_u32(skb, WGPEER_A_PROTOCOL_VERSION, 1))\n\t\t\tgoto err;\n\n\t\tread_lock_bh(&peer->endpoint_lock);\n\t\tif (peer->endpoint.addr.sa_family == AF_INET)\n\t\t\tfail = nla_put(skb, WGPEER_A_ENDPOINT,\n\t\t\t\t       sizeof(peer->endpoint.addr4),\n\t\t\t\t       &peer->endpoint.addr4);\n\t\telse if (peer->endpoint.addr.sa_family == AF_INET6)\n\t\t\tfail = nla_put(skb, WGPEER_A_ENDPOINT,\n\t\t\t\t       sizeof(peer->endpoint.addr6),\n\t\t\t\t       &peer->endpoint.addr6);\n\t\tread_unlock_bh(&peer->endpoint_lock);\n\t\tif (fail)\n\t\t\tgoto err;\n\t\tallowedips_node =\n\t\t\tlist_first_entry_or_null(&peer->allowedips_list,\n\t\t\t\t\tstruct allowedips_node, peer_list);\n\t}\n\tif (!allowedips_node)\n\t\tgoto no_allowedips;\n\tif (!ctx->allowedips_seq)\n\t\tctx->allowedips_seq = peer->device->peer_allowedips.seq;\n\telse if (ctx->allowedips_seq != peer->device->peer_allowedips.seq)\n\t\tgoto no_allowedips;\n\n\tallowedips_nest = nla_nest_start(skb, WGPEER_A_ALLOWEDIPS);\n\tif (!allowedips_nest)\n\t\tgoto err;\n\n\tlist_for_each_entry_from(allowedips_node, &peer->allowedips_list,\n\t\t\t\t peer_list) {\n\t\tu8 cidr, ip[16] __aligned(__alignof(u64));\n\t\tint family;\n\n\t\tfamily = wg_allowedips_read_node(allowedips_node, ip, &cidr);\n\t\tif (get_allowedips(skb, ip, cidr, family)) {\n\t\t\tnla_nest_end(skb, allowedips_nest);\n\t\t\tnla_nest_end(skb, peer_nest);\n\t\t\tctx->next_allowedip = allowedips_node;\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t}\n\tnla_nest_end(skb, allowedips_nest);\nno_allowedips:\n\tnla_nest_end(skb, peer_nest);\n\tctx->next_allowedip = NULL;\n\tctx->allowedips_seq = 0;\n\treturn 0;\nerr:\n\tnla_nest_cancel(skb, peer_nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int wg_get_device_start(struct netlink_callback *cb)\n{\n\tstruct wg_device *wg;\n\n\twg = lookup_interface(genl_info_dump(cb)->attrs, cb->skb);\n\tif (IS_ERR(wg))\n\t\treturn PTR_ERR(wg);\n\tDUMP_CTX(cb)->wg = wg;\n\treturn 0;\n}\n\nstatic int wg_get_device_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct wg_peer *peer, *next_peer_cursor;\n\tstruct dump_ctx *ctx = DUMP_CTX(cb);\n\tstruct wg_device *wg = ctx->wg;\n\tstruct nlattr *peers_nest;\n\tint ret = -EMSGSIZE;\n\tbool done = true;\n\tvoid *hdr;\n\n\trtnl_lock();\n\tmutex_lock(&wg->device_update_lock);\n\tcb->seq = wg->device_update_gen;\n\tnext_peer_cursor = ctx->next_peer;\n\n\thdr = genlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\t  &genl_family, NLM_F_MULTI, WG_CMD_GET_DEVICE);\n\tif (!hdr)\n\t\tgoto out;\n\tgenl_dump_check_consistent(cb, hdr);\n\n\tif (!ctx->next_peer) {\n\t\tif (nla_put_u16(skb, WGDEVICE_A_LISTEN_PORT,\n\t\t\t\twg->incoming_port) ||\n\t\t    nla_put_u32(skb, WGDEVICE_A_FWMARK, wg->fwmark) ||\n\t\t    nla_put_u32(skb, WGDEVICE_A_IFINDEX, wg->dev->ifindex) ||\n\t\t    nla_put_string(skb, WGDEVICE_A_IFNAME, wg->dev->name))\n\t\t\tgoto out;\n\n\t\tdown_read(&wg->static_identity.lock);\n\t\tif (wg->static_identity.has_identity) {\n\t\t\tif (nla_put(skb, WGDEVICE_A_PRIVATE_KEY,\n\t\t\t\t    NOISE_PUBLIC_KEY_LEN,\n\t\t\t\t    wg->static_identity.static_private) ||\n\t\t\t    nla_put(skb, WGDEVICE_A_PUBLIC_KEY,\n\t\t\t\t    NOISE_PUBLIC_KEY_LEN,\n\t\t\t\t    wg->static_identity.static_public)) {\n\t\t\t\tup_read(&wg->static_identity.lock);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tup_read(&wg->static_identity.lock);\n\t}\n\n\tpeers_nest = nla_nest_start(skb, WGDEVICE_A_PEERS);\n\tif (!peers_nest)\n\t\tgoto out;\n\tret = 0;\n\t \n\tif (list_empty(&wg->peer_list) ||\n\t    (ctx->next_peer && list_empty(&ctx->next_peer->peer_list))) {\n\t\tnla_nest_cancel(skb, peers_nest);\n\t\tgoto out;\n\t}\n\tlockdep_assert_held(&wg->device_update_lock);\n\tpeer = list_prepare_entry(ctx->next_peer, &wg->peer_list, peer_list);\n\tlist_for_each_entry_continue(peer, &wg->peer_list, peer_list) {\n\t\tif (get_peer(peer, skb, ctx)) {\n\t\t\tdone = false;\n\t\t\tbreak;\n\t\t}\n\t\tnext_peer_cursor = peer;\n\t}\n\tnla_nest_end(skb, peers_nest);\n\nout:\n\tif (!ret && !done && next_peer_cursor)\n\t\twg_peer_get(next_peer_cursor);\n\twg_peer_put(ctx->next_peer);\n\tmutex_unlock(&wg->device_update_lock);\n\trtnl_unlock();\n\n\tif (ret) {\n\t\tgenlmsg_cancel(skb, hdr);\n\t\treturn ret;\n\t}\n\tgenlmsg_end(skb, hdr);\n\tif (done) {\n\t\tctx->next_peer = NULL;\n\t\treturn 0;\n\t}\n\tctx->next_peer = next_peer_cursor;\n\treturn skb->len;\n\n\t \n}\n\nstatic int wg_get_device_done(struct netlink_callback *cb)\n{\n\tstruct dump_ctx *ctx = DUMP_CTX(cb);\n\n\tif (ctx->wg)\n\t\tdev_put(ctx->wg->dev);\n\twg_peer_put(ctx->next_peer);\n\treturn 0;\n}\n\nstatic int set_port(struct wg_device *wg, u16 port)\n{\n\tstruct wg_peer *peer;\n\n\tif (wg->incoming_port == port)\n\t\treturn 0;\n\tlist_for_each_entry(peer, &wg->peer_list, peer_list)\n\t\twg_socket_clear_peer_endpoint_src(peer);\n\tif (!netif_running(wg->dev)) {\n\t\twg->incoming_port = port;\n\t\treturn 0;\n\t}\n\treturn wg_socket_init(wg, port);\n}\n\nstatic int set_allowedip(struct wg_peer *peer, struct nlattr **attrs)\n{\n\tint ret = -EINVAL;\n\tu16 family;\n\tu8 cidr;\n\n\tif (!attrs[WGALLOWEDIP_A_FAMILY] || !attrs[WGALLOWEDIP_A_IPADDR] ||\n\t    !attrs[WGALLOWEDIP_A_CIDR_MASK])\n\t\treturn ret;\n\tfamily = nla_get_u16(attrs[WGALLOWEDIP_A_FAMILY]);\n\tcidr = nla_get_u8(attrs[WGALLOWEDIP_A_CIDR_MASK]);\n\n\tif (family == AF_INET && cidr <= 32 &&\n\t    nla_len(attrs[WGALLOWEDIP_A_IPADDR]) == sizeof(struct in_addr))\n\t\tret = wg_allowedips_insert_v4(\n\t\t\t&peer->device->peer_allowedips,\n\t\t\tnla_data(attrs[WGALLOWEDIP_A_IPADDR]), cidr, peer,\n\t\t\t&peer->device->device_update_lock);\n\telse if (family == AF_INET6 && cidr <= 128 &&\n\t\t nla_len(attrs[WGALLOWEDIP_A_IPADDR]) == sizeof(struct in6_addr))\n\t\tret = wg_allowedips_insert_v6(\n\t\t\t&peer->device->peer_allowedips,\n\t\t\tnla_data(attrs[WGALLOWEDIP_A_IPADDR]), cidr, peer,\n\t\t\t&peer->device->device_update_lock);\n\n\treturn ret;\n}\n\nstatic int set_peer(struct wg_device *wg, struct nlattr **attrs)\n{\n\tu8 *public_key = NULL, *preshared_key = NULL;\n\tstruct wg_peer *peer = NULL;\n\tu32 flags = 0;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (attrs[WGPEER_A_PUBLIC_KEY] &&\n\t    nla_len(attrs[WGPEER_A_PUBLIC_KEY]) == NOISE_PUBLIC_KEY_LEN)\n\t\tpublic_key = nla_data(attrs[WGPEER_A_PUBLIC_KEY]);\n\telse\n\t\tgoto out;\n\tif (attrs[WGPEER_A_PRESHARED_KEY] &&\n\t    nla_len(attrs[WGPEER_A_PRESHARED_KEY]) == NOISE_SYMMETRIC_KEY_LEN)\n\t\tpreshared_key = nla_data(attrs[WGPEER_A_PRESHARED_KEY]);\n\n\tif (attrs[WGPEER_A_FLAGS])\n\t\tflags = nla_get_u32(attrs[WGPEER_A_FLAGS]);\n\tret = -EOPNOTSUPP;\n\tif (flags & ~__WGPEER_F_ALL)\n\t\tgoto out;\n\n\tret = -EPFNOSUPPORT;\n\tif (attrs[WGPEER_A_PROTOCOL_VERSION]) {\n\t\tif (nla_get_u32(attrs[WGPEER_A_PROTOCOL_VERSION]) != 1)\n\t\t\tgoto out;\n\t}\n\n\tpeer = wg_pubkey_hashtable_lookup(wg->peer_hashtable,\n\t\t\t\t\t  nla_data(attrs[WGPEER_A_PUBLIC_KEY]));\n\tret = 0;\n\tif (!peer) {  \n\t\tif (flags & (WGPEER_F_REMOVE_ME | WGPEER_F_UPDATE_ONLY))\n\t\t\tgoto out;\n\n\t\t \n\t\tflags &= ~WGPEER_F_REPLACE_ALLOWEDIPS;\n\n\t\tdown_read(&wg->static_identity.lock);\n\t\tif (wg->static_identity.has_identity &&\n\t\t    !memcmp(nla_data(attrs[WGPEER_A_PUBLIC_KEY]),\n\t\t\t    wg->static_identity.static_public,\n\t\t\t    NOISE_PUBLIC_KEY_LEN)) {\n\t\t\t \n\t\t\tup_read(&wg->static_identity.lock);\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t\tup_read(&wg->static_identity.lock);\n\n\t\tpeer = wg_peer_create(wg, public_key, preshared_key);\n\t\tif (IS_ERR(peer)) {\n\t\t\tret = PTR_ERR(peer);\n\t\t\tpeer = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\twg_peer_get(peer);\n\t}\n\n\tif (flags & WGPEER_F_REMOVE_ME) {\n\t\twg_peer_remove(peer);\n\t\tgoto out;\n\t}\n\n\tif (preshared_key) {\n\t\tdown_write(&peer->handshake.lock);\n\t\tmemcpy(&peer->handshake.preshared_key, preshared_key,\n\t\t       NOISE_SYMMETRIC_KEY_LEN);\n\t\tup_write(&peer->handshake.lock);\n\t}\n\n\tif (attrs[WGPEER_A_ENDPOINT]) {\n\t\tstruct sockaddr *addr = nla_data(attrs[WGPEER_A_ENDPOINT]);\n\t\tsize_t len = nla_len(attrs[WGPEER_A_ENDPOINT]);\n\t\tstruct endpoint endpoint = { { { 0 } } };\n\n\t\tif (len == sizeof(struct sockaddr_in) && addr->sa_family == AF_INET) {\n\t\t\tendpoint.addr4 = *(struct sockaddr_in *)addr;\n\t\t\twg_socket_set_peer_endpoint(peer, &endpoint);\n\t\t} else if (len == sizeof(struct sockaddr_in6) && addr->sa_family == AF_INET6) {\n\t\t\tendpoint.addr6 = *(struct sockaddr_in6 *)addr;\n\t\t\twg_socket_set_peer_endpoint(peer, &endpoint);\n\t\t}\n\t}\n\n\tif (flags & WGPEER_F_REPLACE_ALLOWEDIPS)\n\t\twg_allowedips_remove_by_peer(&wg->peer_allowedips, peer,\n\t\t\t\t\t     &wg->device_update_lock);\n\n\tif (attrs[WGPEER_A_ALLOWEDIPS]) {\n\t\tstruct nlattr *attr, *allowedip[WGALLOWEDIP_A_MAX + 1];\n\t\tint rem;\n\n\t\tnla_for_each_nested(attr, attrs[WGPEER_A_ALLOWEDIPS], rem) {\n\t\t\tret = nla_parse_nested(allowedip, WGALLOWEDIP_A_MAX,\n\t\t\t\t\t       attr, allowedip_policy, NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = set_allowedip(peer, allowedip);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (attrs[WGPEER_A_PERSISTENT_KEEPALIVE_INTERVAL]) {\n\t\tconst u16 persistent_keepalive_interval = nla_get_u16(\n\t\t\t\tattrs[WGPEER_A_PERSISTENT_KEEPALIVE_INTERVAL]);\n\t\tconst bool send_keepalive =\n\t\t\t!peer->persistent_keepalive_interval &&\n\t\t\tpersistent_keepalive_interval &&\n\t\t\tnetif_running(wg->dev);\n\n\t\tpeer->persistent_keepalive_interval = persistent_keepalive_interval;\n\t\tif (send_keepalive)\n\t\t\twg_packet_send_keepalive(peer);\n\t}\n\n\tif (netif_running(wg->dev))\n\t\twg_packet_send_staged_packets(peer);\n\nout:\n\twg_peer_put(peer);\n\tif (attrs[WGPEER_A_PRESHARED_KEY])\n\t\tmemzero_explicit(nla_data(attrs[WGPEER_A_PRESHARED_KEY]),\n\t\t\t\t nla_len(attrs[WGPEER_A_PRESHARED_KEY]));\n\treturn ret;\n}\n\nstatic int wg_set_device(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct wg_device *wg = lookup_interface(info->attrs, skb);\n\tu32 flags = 0;\n\tint ret;\n\n\tif (IS_ERR(wg)) {\n\t\tret = PTR_ERR(wg);\n\t\tgoto out_nodev;\n\t}\n\n\trtnl_lock();\n\tmutex_lock(&wg->device_update_lock);\n\n\tif (info->attrs[WGDEVICE_A_FLAGS])\n\t\tflags = nla_get_u32(info->attrs[WGDEVICE_A_FLAGS]);\n\tret = -EOPNOTSUPP;\n\tif (flags & ~__WGDEVICE_F_ALL)\n\t\tgoto out;\n\n\tif (info->attrs[WGDEVICE_A_LISTEN_PORT] || info->attrs[WGDEVICE_A_FWMARK]) {\n\t\tstruct net *net;\n\t\trcu_read_lock();\n\t\tnet = rcu_dereference(wg->creating_net);\n\t\tret = !net || !ns_capable(net->user_ns, CAP_NET_ADMIN) ? -EPERM : 0;\n\t\trcu_read_unlock();\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t++wg->device_update_gen;\n\n\tif (info->attrs[WGDEVICE_A_FWMARK]) {\n\t\tstruct wg_peer *peer;\n\n\t\twg->fwmark = nla_get_u32(info->attrs[WGDEVICE_A_FWMARK]);\n\t\tlist_for_each_entry(peer, &wg->peer_list, peer_list)\n\t\t\twg_socket_clear_peer_endpoint_src(peer);\n\t}\n\n\tif (info->attrs[WGDEVICE_A_LISTEN_PORT]) {\n\t\tret = set_port(wg,\n\t\t\tnla_get_u16(info->attrs[WGDEVICE_A_LISTEN_PORT]));\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (flags & WGDEVICE_F_REPLACE_PEERS)\n\t\twg_peer_remove_all(wg);\n\n\tif (info->attrs[WGDEVICE_A_PRIVATE_KEY] &&\n\t    nla_len(info->attrs[WGDEVICE_A_PRIVATE_KEY]) ==\n\t\t    NOISE_PUBLIC_KEY_LEN) {\n\t\tu8 *private_key = nla_data(info->attrs[WGDEVICE_A_PRIVATE_KEY]);\n\t\tu8 public_key[NOISE_PUBLIC_KEY_LEN];\n\t\tstruct wg_peer *peer, *temp;\n\t\tbool send_staged_packets;\n\n\t\tif (!crypto_memneq(wg->static_identity.static_private,\n\t\t\t\t   private_key, NOISE_PUBLIC_KEY_LEN))\n\t\t\tgoto skip_set_private_key;\n\n\t\t \n\t\tif (curve25519_generate_public(public_key, private_key)) {\n\t\t\tpeer = wg_pubkey_hashtable_lookup(wg->peer_hashtable,\n\t\t\t\t\t\t\t  public_key);\n\t\t\tif (peer) {\n\t\t\t\twg_peer_put(peer);\n\t\t\t\twg_peer_remove(peer);\n\t\t\t}\n\t\t}\n\n\t\tdown_write(&wg->static_identity.lock);\n\t\tsend_staged_packets = !wg->static_identity.has_identity && netif_running(wg->dev);\n\t\twg_noise_set_static_identity_private_key(&wg->static_identity, private_key);\n\t\tsend_staged_packets = send_staged_packets && wg->static_identity.has_identity;\n\n\t\twg_cookie_checker_precompute_device_keys(&wg->cookie_checker);\n\t\tlist_for_each_entry_safe(peer, temp, &wg->peer_list, peer_list) {\n\t\t\twg_noise_precompute_static_static(peer);\n\t\t\twg_noise_expire_current_peer_keypairs(peer);\n\t\t\tif (send_staged_packets)\n\t\t\t\twg_packet_send_staged_packets(peer);\n\t\t}\n\t\tup_write(&wg->static_identity.lock);\n\t}\nskip_set_private_key:\n\n\tif (info->attrs[WGDEVICE_A_PEERS]) {\n\t\tstruct nlattr *attr, *peer[WGPEER_A_MAX + 1];\n\t\tint rem;\n\n\t\tnla_for_each_nested(attr, info->attrs[WGDEVICE_A_PEERS], rem) {\n\t\t\tret = nla_parse_nested(peer, WGPEER_A_MAX, attr,\n\t\t\t\t\t       peer_policy, NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tret = set_peer(wg, peer);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 0;\n\nout:\n\tmutex_unlock(&wg->device_update_lock);\n\trtnl_unlock();\n\tdev_put(wg->dev);\nout_nodev:\n\tif (info->attrs[WGDEVICE_A_PRIVATE_KEY])\n\t\tmemzero_explicit(nla_data(info->attrs[WGDEVICE_A_PRIVATE_KEY]),\n\t\t\t\t nla_len(info->attrs[WGDEVICE_A_PRIVATE_KEY]));\n\treturn ret;\n}\n\nstatic const struct genl_ops genl_ops[] = {\n\t{\n\t\t.cmd = WG_CMD_GET_DEVICE,\n\t\t.start = wg_get_device_start,\n\t\t.dumpit = wg_get_device_dump,\n\t\t.done = wg_get_device_done,\n\t\t.flags = GENL_UNS_ADMIN_PERM\n\t}, {\n\t\t.cmd = WG_CMD_SET_DEVICE,\n\t\t.doit = wg_set_device,\n\t\t.flags = GENL_UNS_ADMIN_PERM\n\t}\n};\n\nstatic struct genl_family genl_family __ro_after_init = {\n\t.ops = genl_ops,\n\t.n_ops = ARRAY_SIZE(genl_ops),\n\t.resv_start_op = WG_CMD_SET_DEVICE + 1,\n\t.name = WG_GENL_NAME,\n\t.version = WG_GENL_VERSION,\n\t.maxattr = WGDEVICE_A_MAX,\n\t.module = THIS_MODULE,\n\t.policy = device_policy,\n\t.netnsok = true\n};\n\nint __init wg_genetlink_init(void)\n{\n\treturn genl_register_family(&genl_family);\n}\n\nvoid __exit wg_genetlink_uninit(void)\n{\n\tgenl_unregister_family(&genl_family);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}