{
  "module_name": "peer.c",
  "hash_id": "accebe6230f266576062dbd817067176b9e3ae9ce955618495dd145fefe2c1ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireguard/peer.c",
  "human_readable_source": "\n \n\n#include \"peer.h\"\n#include \"device.h\"\n#include \"queueing.h\"\n#include \"timers.h\"\n#include \"peerlookup.h\"\n#include \"noise.h\"\n\n#include <linux/kref.h>\n#include <linux/lockdep.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n\nstatic struct kmem_cache *peer_cache;\nstatic atomic64_t peer_counter = ATOMIC64_INIT(0);\n\nstruct wg_peer *wg_peer_create(struct wg_device *wg,\n\t\t\t       const u8 public_key[NOISE_PUBLIC_KEY_LEN],\n\t\t\t       const u8 preshared_key[NOISE_SYMMETRIC_KEY_LEN])\n{\n\tstruct wg_peer *peer;\n\tint ret = -ENOMEM;\n\n\tlockdep_assert_held(&wg->device_update_lock);\n\n\tif (wg->num_peers >= MAX_PEERS_PER_DEVICE)\n\t\treturn ERR_PTR(ret);\n\n\tpeer = kmem_cache_zalloc(peer_cache, GFP_KERNEL);\n\tif (unlikely(!peer))\n\t\treturn ERR_PTR(ret);\n\tif (unlikely(dst_cache_init(&peer->endpoint_cache, GFP_KERNEL)))\n\t\tgoto err;\n\n\tpeer->device = wg;\n\twg_noise_handshake_init(&peer->handshake, &wg->static_identity,\n\t\t\t\tpublic_key, preshared_key, peer);\n\tpeer->internal_id = atomic64_inc_return(&peer_counter);\n\tpeer->serial_work_cpu = nr_cpumask_bits;\n\twg_cookie_init(&peer->latest_cookie);\n\twg_timers_init(peer);\n\twg_cookie_checker_precompute_peer_keys(peer);\n\tspin_lock_init(&peer->keypairs.keypair_update_lock);\n\tINIT_WORK(&peer->transmit_handshake_work, wg_packet_handshake_send_worker);\n\tINIT_WORK(&peer->transmit_packet_work, wg_packet_tx_worker);\n\twg_prev_queue_init(&peer->tx_queue);\n\twg_prev_queue_init(&peer->rx_queue);\n\trwlock_init(&peer->endpoint_lock);\n\tkref_init(&peer->refcount);\n\tskb_queue_head_init(&peer->staged_packet_queue);\n\twg_noise_reset_last_sent_handshake(&peer->last_sent_handshake);\n\tset_bit(NAPI_STATE_NO_BUSY_POLL, &peer->napi.state);\n\tnetif_napi_add(wg->dev, &peer->napi, wg_packet_rx_poll);\n\tnapi_enable(&peer->napi);\n\tlist_add_tail(&peer->peer_list, &wg->peer_list);\n\tINIT_LIST_HEAD(&peer->allowedips_list);\n\twg_pubkey_hashtable_add(wg->peer_hashtable, peer);\n\t++wg->num_peers;\n\tpr_debug(\"%s: Peer %llu created\\n\", wg->dev->name, peer->internal_id);\n\treturn peer;\n\nerr:\n\tkmem_cache_free(peer_cache, peer);\n\treturn ERR_PTR(ret);\n}\n\nstruct wg_peer *wg_peer_get_maybe_zero(struct wg_peer *peer)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_bh_held(),\n\t\t\t \"Taking peer reference without holding the RCU read lock\");\n\tif (unlikely(!peer || !kref_get_unless_zero(&peer->refcount)))\n\t\treturn NULL;\n\treturn peer;\n}\n\nstatic void peer_make_dead(struct wg_peer *peer)\n{\n\t \n\tlist_del_init(&peer->peer_list);\n\twg_allowedips_remove_by_peer(&peer->device->peer_allowedips, peer,\n\t\t\t\t     &peer->device->device_update_lock);\n\twg_pubkey_hashtable_remove(peer->device->peer_hashtable, peer);\n\n\t \n\tWRITE_ONCE(peer->is_dead, true);\n\n\t \n}\n\nstatic void peer_remove_after_dead(struct wg_peer *peer)\n{\n\tWARN_ON(!peer->is_dead);\n\n\t \n\twg_noise_keypairs_clear(&peer->keypairs);\n\n\t \n\twg_timers_stop(peer);\n\n\t \n\n\t \n\tflush_workqueue(peer->device->packet_crypt_wq);\n\t \n\tflush_workqueue(peer->device->packet_crypt_wq);\n\t \n\tnapi_disable(&peer->napi);\n\t \n\tnetif_napi_del(&peer->napi);\n\n\t \n\tflush_workqueue(peer->device->handshake_send_wq);\n\n\t \n\n\t--peer->device->num_peers;\n\twg_peer_put(peer);\n}\n\n \nvoid wg_peer_remove(struct wg_peer *peer)\n{\n\tif (unlikely(!peer))\n\t\treturn;\n\tlockdep_assert_held(&peer->device->device_update_lock);\n\n\tpeer_make_dead(peer);\n\tsynchronize_net();\n\tpeer_remove_after_dead(peer);\n}\n\nvoid wg_peer_remove_all(struct wg_device *wg)\n{\n\tstruct wg_peer *peer, *temp;\n\tLIST_HEAD(dead_peers);\n\n\tlockdep_assert_held(&wg->device_update_lock);\n\n\t \n\twg_allowedips_free(&wg->peer_allowedips, &wg->device_update_lock);\n\n\tlist_for_each_entry_safe(peer, temp, &wg->peer_list, peer_list) {\n\t\tpeer_make_dead(peer);\n\t\tlist_add_tail(&peer->peer_list, &dead_peers);\n\t}\n\tsynchronize_net();\n\tlist_for_each_entry_safe(peer, temp, &dead_peers, peer_list)\n\t\tpeer_remove_after_dead(peer);\n}\n\nstatic void rcu_release(struct rcu_head *rcu)\n{\n\tstruct wg_peer *peer = container_of(rcu, struct wg_peer, rcu);\n\n\tdst_cache_destroy(&peer->endpoint_cache);\n\tWARN_ON(wg_prev_queue_peek(&peer->tx_queue) || wg_prev_queue_peek(&peer->rx_queue));\n\n\t \n\tmemzero_explicit(peer, sizeof(*peer));\n\tkmem_cache_free(peer_cache, peer);\n}\n\nstatic void kref_release(struct kref *refcount)\n{\n\tstruct wg_peer *peer = container_of(refcount, struct wg_peer, refcount);\n\n\tpr_debug(\"%s: Peer %llu (%pISpfsc) destroyed\\n\",\n\t\t peer->device->dev->name, peer->internal_id,\n\t\t &peer->endpoint.addr);\n\n\t \n\twg_index_hashtable_remove(peer->device->index_hashtable,\n\t\t\t\t  &peer->handshake.entry);\n\n\t \n\twg_packet_purge_staged_packets(peer);\n\n\t \n\tcall_rcu(&peer->rcu, rcu_release);\n}\n\nvoid wg_peer_put(struct wg_peer *peer)\n{\n\tif (unlikely(!peer))\n\t\treturn;\n\tkref_put(&peer->refcount, kref_release);\n}\n\nint __init wg_peer_init(void)\n{\n\tpeer_cache = KMEM_CACHE(wg_peer, 0);\n\treturn peer_cache ? 0 : -ENOMEM;\n}\n\nvoid wg_peer_uninit(void)\n{\n\tkmem_cache_destroy(peer_cache);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}