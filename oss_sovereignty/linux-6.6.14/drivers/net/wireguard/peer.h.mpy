{
  "module_name": "peer.h",
  "hash_id": "0b231ee3e66c2ecd728ec1c069c36158b0284ee5e3efd7e832b697f76f4e2a50",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireguard/peer.h",
  "human_readable_source": " \n \n\n#ifndef _WG_PEER_H\n#define _WG_PEER_H\n\n#include \"device.h\"\n#include \"noise.h\"\n#include \"cookie.h\"\n\n#include <linux/types.h>\n#include <linux/netfilter.h>\n#include <linux/spinlock.h>\n#include <linux/kref.h>\n#include <net/dst_cache.h>\n\nstruct wg_device;\n\nstruct endpoint {\n\tunion {\n\t\tstruct sockaddr addr;\n\t\tstruct sockaddr_in addr4;\n\t\tstruct sockaddr_in6 addr6;\n\t};\n\tunion {\n\t\tstruct {\n\t\t\tstruct in_addr src4;\n\t\t\t \n\t\t\tint src_if4;\n\t\t};\n\t\tstruct in6_addr src6;\n\t};\n};\n\nstruct wg_peer {\n\tstruct wg_device *device;\n\tstruct prev_queue tx_queue, rx_queue;\n\tstruct sk_buff_head staged_packet_queue;\n\tint serial_work_cpu;\n\tbool is_dead;\n\tstruct noise_keypairs keypairs;\n\tstruct endpoint endpoint;\n\tstruct dst_cache endpoint_cache;\n\trwlock_t endpoint_lock;\n\tstruct noise_handshake handshake;\n\tatomic64_t last_sent_handshake;\n\tstruct work_struct transmit_handshake_work, clear_peer_work, transmit_packet_work;\n\tstruct cookie latest_cookie;\n\tstruct hlist_node pubkey_hash;\n\tu64 rx_bytes, tx_bytes;\n\tstruct timer_list timer_retransmit_handshake, timer_send_keepalive;\n\tstruct timer_list timer_new_handshake, timer_zero_key_material;\n\tstruct timer_list timer_persistent_keepalive;\n\tunsigned int timer_handshake_attempts;\n\tu16 persistent_keepalive_interval;\n\tbool timer_need_another_keepalive;\n\tbool sent_lastminute_handshake;\n\tstruct timespec64 walltime_last_handshake;\n\tstruct kref refcount;\n\tstruct rcu_head rcu;\n\tstruct list_head peer_list;\n\tstruct list_head allowedips_list;\n\tstruct napi_struct napi;\n\tu64 internal_id;\n};\n\nstruct wg_peer *wg_peer_create(struct wg_device *wg,\n\t\t\t       const u8 public_key[NOISE_PUBLIC_KEY_LEN],\n\t\t\t       const u8 preshared_key[NOISE_SYMMETRIC_KEY_LEN]);\n\nstruct wg_peer *__must_check wg_peer_get_maybe_zero(struct wg_peer *peer);\nstatic inline struct wg_peer *wg_peer_get(struct wg_peer *peer)\n{\n\tkref_get(&peer->refcount);\n\treturn peer;\n}\nvoid wg_peer_put(struct wg_peer *peer);\nvoid wg_peer_remove(struct wg_peer *peer);\nvoid wg_peer_remove_all(struct wg_device *wg);\n\nint wg_peer_init(void);\nvoid wg_peer_uninit(void);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}