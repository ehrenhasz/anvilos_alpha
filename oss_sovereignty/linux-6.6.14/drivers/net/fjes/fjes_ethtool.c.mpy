{
  "module_name": "fjes_ethtool.c",
  "hash_id": "147b6d2005380328dcd4686b2ef4f77e27cf53694d3aa48a4a3d7fc7cb3a2f70",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/fjes/fjes_ethtool.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/vmalloc.h>\n#include <linux/netdevice.h>\n#include <linux/ethtool.h>\n#include <linux/platform_device.h>\n\n#include \"fjes.h\"\n\nstruct fjes_stats {\n\tchar stat_string[ETH_GSTRING_LEN];\n\tint sizeof_stat;\n\tint stat_offset;\n};\n\n#define FJES_STAT(name, stat) { \\\n\t.stat_string = name, \\\n\t.sizeof_stat = sizeof_field(struct fjes_adapter, stat), \\\n\t.stat_offset = offsetof(struct fjes_adapter, stat) \\\n}\n\nstatic const struct fjes_stats fjes_gstrings_stats[] = {\n\tFJES_STAT(\"rx_packets\", stats64.rx_packets),\n\tFJES_STAT(\"tx_packets\", stats64.tx_packets),\n\tFJES_STAT(\"rx_bytes\", stats64.rx_bytes),\n\tFJES_STAT(\"tx_bytes\", stats64.rx_bytes),\n\tFJES_STAT(\"rx_dropped\", stats64.rx_dropped),\n\tFJES_STAT(\"tx_dropped\", stats64.tx_dropped),\n};\n\n#define FJES_EP_STATS_LEN 14\n#define FJES_STATS_LEN \\\n\t(ARRAY_SIZE(fjes_gstrings_stats) + \\\n\t ((&((struct fjes_adapter *)netdev_priv(netdev))->hw)->max_epid - 1) * \\\n\t FJES_EP_STATS_LEN)\n\nstatic void fjes_get_ethtool_stats(struct net_device *netdev,\n\t\t\t\t   struct ethtool_stats *stats, u64 *data)\n{\n\tstruct fjes_adapter *adapter = netdev_priv(netdev);\n\tstruct fjes_hw *hw = &adapter->hw;\n\tint epidx;\n\tchar *p;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fjes_gstrings_stats); i++) {\n\t\tp = (char *)adapter + fjes_gstrings_stats[i].stat_offset;\n\t\tdata[i] = (fjes_gstrings_stats[i].sizeof_stat == sizeof(u64))\n\t\t\t? *(u64 *)p : *(u32 *)p;\n\t}\n\tfor (epidx = 0; epidx < hw->max_epid; epidx++) {\n\t\tif (epidx == hw->my_epid)\n\t\t\tcontinue;\n\t\tdata[i++] = hw->ep_shm_info[epidx].ep_stats\n\t\t\t\t.com_regist_buf_exec;\n\t\tdata[i++] = hw->ep_shm_info[epidx].ep_stats\n\t\t\t\t.com_unregist_buf_exec;\n\t\tdata[i++] = hw->ep_shm_info[epidx].ep_stats.send_intr_rx;\n\t\tdata[i++] = hw->ep_shm_info[epidx].ep_stats.send_intr_unshare;\n\t\tdata[i++] = hw->ep_shm_info[epidx].ep_stats\n\t\t\t\t.send_intr_zoneupdate;\n\t\tdata[i++] = hw->ep_shm_info[epidx].ep_stats.recv_intr_rx;\n\t\tdata[i++] = hw->ep_shm_info[epidx].ep_stats.recv_intr_unshare;\n\t\tdata[i++] = hw->ep_shm_info[epidx].ep_stats.recv_intr_stop;\n\t\tdata[i++] = hw->ep_shm_info[epidx].ep_stats\n\t\t\t\t.recv_intr_zoneupdate;\n\t\tdata[i++] = hw->ep_shm_info[epidx].ep_stats.tx_buffer_full;\n\t\tdata[i++] = hw->ep_shm_info[epidx].ep_stats\n\t\t\t\t.tx_dropped_not_shared;\n\t\tdata[i++] = hw->ep_shm_info[epidx].ep_stats\n\t\t\t\t.tx_dropped_ver_mismatch;\n\t\tdata[i++] = hw->ep_shm_info[epidx].ep_stats\n\t\t\t\t.tx_dropped_buf_size_mismatch;\n\t\tdata[i++] = hw->ep_shm_info[epidx].ep_stats\n\t\t\t\t.tx_dropped_vlanid_mismatch;\n\t}\n}\n\nstatic void fjes_get_strings(struct net_device *netdev,\n\t\t\t     u32 stringset, u8 *data)\n{\n\tstruct fjes_adapter *adapter = netdev_priv(netdev);\n\tstruct fjes_hw *hw = &adapter->hw;\n\tu8 *p = data;\n\tint i;\n\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tfor (i = 0; i < ARRAY_SIZE(fjes_gstrings_stats); i++) {\n\t\t\tmemcpy(p, fjes_gstrings_stats[i].stat_string,\n\t\t\t       ETH_GSTRING_LEN);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\t\tfor (i = 0; i < hw->max_epid; i++) {\n\t\t\tif (i == hw->my_epid)\n\t\t\t\tcontinue;\n\t\t\tsprintf(p, \"ep%u_com_regist_buf_exec\", i);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tsprintf(p, \"ep%u_com_unregist_buf_exec\", i);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tsprintf(p, \"ep%u_send_intr_rx\", i);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tsprintf(p, \"ep%u_send_intr_unshare\", i);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tsprintf(p, \"ep%u_send_intr_zoneupdate\", i);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tsprintf(p, \"ep%u_recv_intr_rx\", i);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tsprintf(p, \"ep%u_recv_intr_unshare\", i);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tsprintf(p, \"ep%u_recv_intr_stop\", i);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tsprintf(p, \"ep%u_recv_intr_zoneupdate\", i);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tsprintf(p, \"ep%u_tx_buffer_full\", i);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tsprintf(p, \"ep%u_tx_dropped_not_shared\", i);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tsprintf(p, \"ep%u_tx_dropped_ver_mismatch\", i);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tsprintf(p, \"ep%u_tx_dropped_buf_size_mismatch\", i);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t\tsprintf(p, \"ep%u_tx_dropped_vlanid_mismatch\", i);\n\t\t\tp += ETH_GSTRING_LEN;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic int fjes_get_sset_count(struct net_device *netdev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn FJES_STATS_LEN;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void fjes_get_drvinfo(struct net_device *netdev,\n\t\t\t     struct ethtool_drvinfo *drvinfo)\n{\n\tstruct fjes_adapter *adapter = netdev_priv(netdev);\n\tstruct platform_device *plat_dev;\n\n\tplat_dev = adapter->plat_dev;\n\n\tstrscpy(drvinfo->driver, fjes_driver_name, sizeof(drvinfo->driver));\n\tstrscpy(drvinfo->version, fjes_driver_version,\n\t\tsizeof(drvinfo->version));\n\n\tstrscpy(drvinfo->fw_version, \"none\", sizeof(drvinfo->fw_version));\n\tsnprintf(drvinfo->bus_info, sizeof(drvinfo->bus_info),\n\t\t \"platform:%s\", plat_dev->name);\n}\n\nstatic int fjes_get_link_ksettings(struct net_device *netdev,\n\t\t\t\t   struct ethtool_link_ksettings *ecmd)\n{\n\tethtool_link_ksettings_zero_link_mode(ecmd, supported);\n\tethtool_link_ksettings_zero_link_mode(ecmd, advertising);\n\tecmd->base.duplex = DUPLEX_FULL;\n\tecmd->base.autoneg = AUTONEG_DISABLE;\n\tecmd->base.port = PORT_NONE;\n\tecmd->base.speed = 20000;\t \n\n\treturn 0;\n}\n\nstatic int fjes_get_regs_len(struct net_device *netdev)\n{\n#define FJES_REGS_LEN\t37\n\treturn FJES_REGS_LEN * sizeof(u32);\n}\n\nstatic void fjes_get_regs(struct net_device *netdev,\n\t\t\t  struct ethtool_regs *regs, void *p)\n{\n\tstruct fjes_adapter *adapter = netdev_priv(netdev);\n\tstruct fjes_hw *hw = &adapter->hw;\n\tu32 *regs_buff = p;\n\n\tmemset(p, 0, FJES_REGS_LEN * sizeof(u32));\n\n\tregs->version = 1;\n\n\t \n\tregs_buff[0] = rd32(XSCT_OWNER_EPID);\n\tregs_buff[1] = rd32(XSCT_MAX_EP);\n\n\t \n\tregs_buff[4] = rd32(XSCT_DCTL);\n\n\t \n\tregs_buff[8] = rd32(XSCT_CR);\n\tregs_buff[9] = rd32(XSCT_CS);\n\tregs_buff[10] = rd32(XSCT_SHSTSAL);\n\tregs_buff[11] = rd32(XSCT_SHSTSAH);\n\n\tregs_buff[13] = rd32(XSCT_REQBL);\n\tregs_buff[14] = rd32(XSCT_REQBAL);\n\tregs_buff[15] = rd32(XSCT_REQBAH);\n\n\tregs_buff[17] = rd32(XSCT_RESPBL);\n\tregs_buff[18] = rd32(XSCT_RESPBAL);\n\tregs_buff[19] = rd32(XSCT_RESPBAH);\n\n\t \n\tregs_buff[32] = rd32(XSCT_IS);\n\tregs_buff[33] = rd32(XSCT_IMS);\n\tregs_buff[34] = rd32(XSCT_IMC);\n\tregs_buff[35] = rd32(XSCT_IG);\n\tregs_buff[36] = rd32(XSCT_ICTL);\n}\n\nstatic int fjes_set_dump(struct net_device *netdev, struct ethtool_dump *dump)\n{\n\tstruct fjes_adapter *adapter = netdev_priv(netdev);\n\tstruct fjes_hw *hw = &adapter->hw;\n\tint ret = 0;\n\n\tif (dump->flag) {\n\t\tif (hw->debug_mode)\n\t\t\treturn -EPERM;\n\n\t\thw->debug_mode = dump->flag;\n\n\t\t \n\t\tmutex_lock(&hw->hw_info.lock);\n\t\tret = fjes_hw_start_debug(hw);\n\t\tmutex_unlock(&hw->hw_info.lock);\n\n\t\tif (ret)\n\t\t\thw->debug_mode = 0;\n\t} else {\n\t\tif (!hw->debug_mode)\n\t\t\treturn -EPERM;\n\n\t\t \n\t\tmutex_lock(&hw->hw_info.lock);\n\t\tret = fjes_hw_stop_debug(hw);\n\t\tmutex_unlock(&hw->hw_info.lock);\n\t}\n\n\treturn ret;\n}\n\nstatic int fjes_get_dump_flag(struct net_device *netdev,\n\t\t\t      struct ethtool_dump *dump)\n{\n\tstruct fjes_adapter *adapter = netdev_priv(netdev);\n\tstruct fjes_hw *hw = &adapter->hw;\n\n\tdump->len = hw->hw_info.trace_size;\n\tdump->version = 1;\n\tdump->flag = hw->debug_mode;\n\n\treturn 0;\n}\n\nstatic int fjes_get_dump_data(struct net_device *netdev,\n\t\t\t      struct ethtool_dump *dump, void *buf)\n{\n\tstruct fjes_adapter *adapter = netdev_priv(netdev);\n\tstruct fjes_hw *hw = &adapter->hw;\n\tint ret = 0;\n\n\tif (hw->hw_info.trace)\n\t\tmemcpy(buf, hw->hw_info.trace, hw->hw_info.trace_size);\n\telse\n\t\tret = -EPERM;\n\n\treturn ret;\n}\n\nstatic const struct ethtool_ops fjes_ethtool_ops = {\n\t\t.get_drvinfo\t\t= fjes_get_drvinfo,\n\t\t.get_ethtool_stats = fjes_get_ethtool_stats,\n\t\t.get_strings      = fjes_get_strings,\n\t\t.get_sset_count   = fjes_get_sset_count,\n\t\t.get_regs\t\t= fjes_get_regs,\n\t\t.get_regs_len\t\t= fjes_get_regs_len,\n\t\t.set_dump\t\t= fjes_set_dump,\n\t\t.get_dump_flag\t\t= fjes_get_dump_flag,\n\t\t.get_dump_data\t\t= fjes_get_dump_data,\n\t\t.get_link_ksettings\t= fjes_get_link_ksettings,\n};\n\nvoid fjes_set_ethtool_ops(struct net_device *netdev)\n{\n\tnetdev->ethtool_ops = &fjes_ethtool_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}