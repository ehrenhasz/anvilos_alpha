{
  "module_name": "fjes_hw.c",
  "hash_id": "becabe413b868649b8a95edc70d39b33e9192dee960100db4a1f03d46d9f2f27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/fjes/fjes_hw.c",
  "human_readable_source": "\n \n\n#include \"fjes_hw.h\"\n#include \"fjes.h\"\n#include \"fjes_trace.h\"\n\nstatic void fjes_hw_update_zone_task(struct work_struct *);\nstatic void fjes_hw_epstop_task(struct work_struct *);\n\n \nconst u32 fjes_support_mtu[] = {\n\tFJES_MTU_DEFINE(8 * 1024),\n\tFJES_MTU_DEFINE(16 * 1024),\n\tFJES_MTU_DEFINE(32 * 1024),\n\tFJES_MTU_DEFINE(64 * 1024),\n\t0\n};\n\nu32 fjes_hw_rd32(struct fjes_hw *hw, u32 reg)\n{\n\tu8 *base = hw->base;\n\tu32 value = 0;\n\n\tvalue = readl(&base[reg]);\n\n\treturn value;\n}\n\nstatic u8 *fjes_hw_iomap(struct fjes_hw *hw)\n{\n\tu8 *base;\n\n\tif (!request_mem_region(hw->hw_res.start, hw->hw_res.size,\n\t\t\t\tfjes_driver_name)) {\n\t\tpr_err(\"request_mem_region failed\\n\");\n\t\treturn NULL;\n\t}\n\n\tbase = (u8 *)ioremap(hw->hw_res.start, hw->hw_res.size);\n\n\treturn base;\n}\n\nstatic void fjes_hw_iounmap(struct fjes_hw *hw)\n{\n\tiounmap(hw->base);\n\trelease_mem_region(hw->hw_res.start, hw->hw_res.size);\n}\n\nint fjes_hw_reset(struct fjes_hw *hw)\n{\n\tunion REG_DCTL dctl;\n\tint timeout;\n\n\tdctl.reg = 0;\n\tdctl.bits.reset = 1;\n\twr32(XSCT_DCTL, dctl.reg);\n\n\ttimeout = FJES_DEVICE_RESET_TIMEOUT * 1000;\n\tdctl.reg = rd32(XSCT_DCTL);\n\twhile ((dctl.bits.reset == 1) && (timeout > 0)) {\n\t\tmsleep(1000);\n\t\tdctl.reg = rd32(XSCT_DCTL);\n\t\ttimeout -= 1000;\n\t}\n\n\treturn timeout > 0 ? 0 : -EIO;\n}\n\nstatic int fjes_hw_get_max_epid(struct fjes_hw *hw)\n{\n\tunion REG_MAX_EP info;\n\n\tinfo.reg = rd32(XSCT_MAX_EP);\n\n\treturn info.bits.maxep;\n}\n\nstatic int fjes_hw_get_my_epid(struct fjes_hw *hw)\n{\n\tunion REG_OWNER_EPID info;\n\n\tinfo.reg = rd32(XSCT_OWNER_EPID);\n\n\treturn info.bits.epid;\n}\n\nstatic int fjes_hw_alloc_shared_status_region(struct fjes_hw *hw)\n{\n\tsize_t size;\n\n\tsize = sizeof(struct fjes_device_shared_info) +\n\t    (sizeof(u8) * hw->max_epid);\n\thw->hw_info.share = kzalloc(size, GFP_KERNEL);\n\tif (!hw->hw_info.share)\n\t\treturn -ENOMEM;\n\n\thw->hw_info.share->epnum = hw->max_epid;\n\n\treturn 0;\n}\n\nstatic void fjes_hw_free_shared_status_region(struct fjes_hw *hw)\n{\n\tkfree(hw->hw_info.share);\n\thw->hw_info.share = NULL;\n}\n\nstatic int fjes_hw_alloc_epbuf(struct epbuf_handler *epbh)\n{\n\tvoid *mem;\n\n\tmem = vzalloc(EP_BUFFER_SIZE);\n\tif (!mem)\n\t\treturn -ENOMEM;\n\n\tepbh->buffer = mem;\n\tepbh->size = EP_BUFFER_SIZE;\n\n\tepbh->info = (union ep_buffer_info *)mem;\n\tepbh->ring = (u8 *)(mem + sizeof(union ep_buffer_info));\n\n\treturn 0;\n}\n\nstatic void fjes_hw_free_epbuf(struct epbuf_handler *epbh)\n{\n\tvfree(epbh->buffer);\n\tepbh->buffer = NULL;\n\tepbh->size = 0;\n\n\tepbh->info = NULL;\n\tepbh->ring = NULL;\n}\n\nvoid fjes_hw_setup_epbuf(struct epbuf_handler *epbh, const u8 *mac_addr,\n\t\t\t u32 mtu)\n{\n\tunion ep_buffer_info *info = epbh->info;\n\tu16 vlan_id[EP_BUFFER_SUPPORT_VLAN_MAX];\n\tint i;\n\n\tfor (i = 0; i < EP_BUFFER_SUPPORT_VLAN_MAX; i++)\n\t\tvlan_id[i] = info->v1i.vlan_id[i];\n\n\tmemset(info, 0, sizeof(union ep_buffer_info));\n\n\tinfo->v1i.version = 0;   \n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tinfo->v1i.mac_addr[i] = mac_addr[i];\n\n\tinfo->v1i.head = 0;\n\tinfo->v1i.tail = 1;\n\n\tinfo->v1i.info_size = sizeof(union ep_buffer_info);\n\tinfo->v1i.buffer_size = epbh->size - info->v1i.info_size;\n\n\tinfo->v1i.frame_max = FJES_MTU_TO_FRAME_SIZE(mtu);\n\tinfo->v1i.count_max =\n\t    EP_RING_NUM(info->v1i.buffer_size, info->v1i.frame_max);\n\n\tfor (i = 0; i < EP_BUFFER_SUPPORT_VLAN_MAX; i++)\n\t\tinfo->v1i.vlan_id[i] = vlan_id[i];\n\n\tinfo->v1i.rx_status |= FJES_RX_MTU_CHANGING_DONE;\n}\n\nvoid\nfjes_hw_init_command_registers(struct fjes_hw *hw,\n\t\t\t       struct fjes_device_command_param *param)\n{\n\t \n\twr32(XSCT_REQBL, (__le32)(param->req_len));\n\t \n\twr32(XSCT_RESPBL, (__le32)(param->res_len));\n\n\t \n\twr32(XSCT_REQBAL,\n\t     (__le32)(param->req_start & GENMASK_ULL(31, 0)));\n\twr32(XSCT_REQBAH,\n\t     (__le32)((param->req_start & GENMASK_ULL(63, 32)) >> 32));\n\n\t \n\twr32(XSCT_RESPBAL,\n\t     (__le32)(param->res_start & GENMASK_ULL(31, 0)));\n\twr32(XSCT_RESPBAH,\n\t     (__le32)((param->res_start & GENMASK_ULL(63, 32)) >> 32));\n\n\t \n\twr32(XSCT_SHSTSAL,\n\t     (__le32)(param->share_start & GENMASK_ULL(31, 0)));\n\twr32(XSCT_SHSTSAH,\n\t     (__le32)((param->share_start & GENMASK_ULL(63, 32)) >> 32));\n}\n\nstatic int fjes_hw_setup(struct fjes_hw *hw)\n{\n\tu8 mac[ETH_ALEN] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\tstruct fjes_device_command_param param;\n\tstruct ep_share_mem_info *buf_pair;\n\tunsigned long flags;\n\tsize_t mem_size;\n\tint result;\n\tint epidx;\n\tvoid *buf;\n\n\thw->hw_info.max_epid = &hw->max_epid;\n\thw->hw_info.my_epid = &hw->my_epid;\n\n\tbuf = kcalloc(hw->max_epid, sizeof(struct ep_share_mem_info),\n\t\t      GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\thw->ep_shm_info = (struct ep_share_mem_info *)buf;\n\n\tmem_size = FJES_DEV_REQ_BUF_SIZE(hw->max_epid);\n\thw->hw_info.req_buf = kzalloc(mem_size, GFP_KERNEL);\n\tif (!(hw->hw_info.req_buf))\n\t\treturn -ENOMEM;\n\n\thw->hw_info.req_buf_size = mem_size;\n\n\tmem_size = FJES_DEV_RES_BUF_SIZE(hw->max_epid);\n\thw->hw_info.res_buf = kzalloc(mem_size, GFP_KERNEL);\n\tif (!(hw->hw_info.res_buf))\n\t\treturn -ENOMEM;\n\n\thw->hw_info.res_buf_size = mem_size;\n\n\tresult = fjes_hw_alloc_shared_status_region(hw);\n\tif (result)\n\t\treturn result;\n\n\thw->hw_info.buffer_share_bit = 0;\n\thw->hw_info.buffer_unshare_reserve_bit = 0;\n\n\tfor (epidx = 0; epidx < hw->max_epid; epidx++) {\n\t\tif (epidx != hw->my_epid) {\n\t\t\tbuf_pair = &hw->ep_shm_info[epidx];\n\n\t\t\tresult = fjes_hw_alloc_epbuf(&buf_pair->tx);\n\t\t\tif (result)\n\t\t\t\treturn result;\n\n\t\t\tresult = fjes_hw_alloc_epbuf(&buf_pair->rx);\n\t\t\tif (result)\n\t\t\t\treturn result;\n\n\t\t\tspin_lock_irqsave(&hw->rx_status_lock, flags);\n\t\t\tfjes_hw_setup_epbuf(&buf_pair->tx, mac,\n\t\t\t\t\t    fjes_support_mtu[0]);\n\t\t\tfjes_hw_setup_epbuf(&buf_pair->rx, mac,\n\t\t\t\t\t    fjes_support_mtu[0]);\n\t\t\tspin_unlock_irqrestore(&hw->rx_status_lock, flags);\n\t\t}\n\t}\n\n\tmemset(&param, 0, sizeof(param));\n\n\tparam.req_len = hw->hw_info.req_buf_size;\n\tparam.req_start = __pa(hw->hw_info.req_buf);\n\tparam.res_len = hw->hw_info.res_buf_size;\n\tparam.res_start = __pa(hw->hw_info.res_buf);\n\n\tparam.share_start = __pa(hw->hw_info.share->ep_status);\n\n\tfjes_hw_init_command_registers(hw, &param);\n\n\treturn 0;\n}\n\nstatic void fjes_hw_cleanup(struct fjes_hw *hw)\n{\n\tint epidx;\n\n\tif (!hw->ep_shm_info)\n\t\treturn;\n\n\tfjes_hw_free_shared_status_region(hw);\n\n\tkfree(hw->hw_info.req_buf);\n\thw->hw_info.req_buf = NULL;\n\n\tkfree(hw->hw_info.res_buf);\n\thw->hw_info.res_buf = NULL;\n\n\tfor (epidx = 0; epidx < hw->max_epid ; epidx++) {\n\t\tif (epidx == hw->my_epid)\n\t\t\tcontinue;\n\t\tfjes_hw_free_epbuf(&hw->ep_shm_info[epidx].tx);\n\t\tfjes_hw_free_epbuf(&hw->ep_shm_info[epidx].rx);\n\t}\n\n\tkfree(hw->ep_shm_info);\n\thw->ep_shm_info = NULL;\n}\n\nint fjes_hw_init(struct fjes_hw *hw)\n{\n\tint ret;\n\n\thw->base = fjes_hw_iomap(hw);\n\tif (!hw->base)\n\t\treturn -EIO;\n\n\tret = fjes_hw_reset(hw);\n\tif (ret)\n\t\treturn ret;\n\n\tfjes_hw_set_irqmask(hw, REG_ICTL_MASK_ALL, true);\n\n\tINIT_WORK(&hw->update_zone_task, fjes_hw_update_zone_task);\n\tINIT_WORK(&hw->epstop_task, fjes_hw_epstop_task);\n\n\tmutex_init(&hw->hw_info.lock);\n\tspin_lock_init(&hw->rx_status_lock);\n\n\thw->max_epid = fjes_hw_get_max_epid(hw);\n\thw->my_epid = fjes_hw_get_my_epid(hw);\n\n\tif ((hw->max_epid == 0) || (hw->my_epid >= hw->max_epid))\n\t\treturn -ENXIO;\n\n\tret = fjes_hw_setup(hw);\n\n\thw->hw_info.trace = vzalloc(FJES_DEBUG_BUFFER_SIZE);\n\thw->hw_info.trace_size = FJES_DEBUG_BUFFER_SIZE;\n\n\treturn ret;\n}\n\nvoid fjes_hw_exit(struct fjes_hw *hw)\n{\n\tint ret;\n\n\tif (hw->base) {\n\n\t\tif (hw->debug_mode) {\n\t\t\t \n\t\t\tmutex_lock(&hw->hw_info.lock);\n\t\t\tfjes_hw_stop_debug(hw);\n\t\t\tmutex_unlock(&hw->hw_info.lock);\n\t\t}\n\t\tvfree(hw->hw_info.trace);\n\t\thw->hw_info.trace = NULL;\n\t\thw->hw_info.trace_size = 0;\n\t\thw->debug_mode = 0;\n\n\t\tret = fjes_hw_reset(hw);\n\t\tif (ret)\n\t\t\tpr_err(\"%s: reset error\", __func__);\n\n\t\tfjes_hw_iounmap(hw);\n\t\thw->base = NULL;\n\t}\n\n\tfjes_hw_cleanup(hw);\n\n\tcancel_work_sync(&hw->update_zone_task);\n\tcancel_work_sync(&hw->epstop_task);\n}\n\nstatic enum fjes_dev_command_response_e\nfjes_hw_issue_request_command(struct fjes_hw *hw,\n\t\t\t      enum fjes_dev_command_request_type type)\n{\n\tenum fjes_dev_command_response_e ret = FJES_CMD_STATUS_UNKNOWN;\n\tunion REG_CR cr;\n\tunion REG_CS cs;\n\tint timeout = FJES_COMMAND_REQ_TIMEOUT * 1000;\n\n\tcr.reg = 0;\n\tcr.bits.req_start = 1;\n\tcr.bits.req_code = type;\n\twr32(XSCT_CR, cr.reg);\n\tcr.reg = rd32(XSCT_CR);\n\n\tif (cr.bits.error == 0) {\n\t\ttimeout = FJES_COMMAND_REQ_TIMEOUT * 1000;\n\t\tcs.reg = rd32(XSCT_CS);\n\n\t\twhile ((cs.bits.complete != 1) && timeout > 0) {\n\t\t\tmsleep(1000);\n\t\t\tcs.reg = rd32(XSCT_CS);\n\t\t\ttimeout -= 1000;\n\t\t}\n\n\t\tif (cs.bits.complete == 1)\n\t\t\tret = FJES_CMD_STATUS_NORMAL;\n\t\telse if (timeout <= 0)\n\t\t\tret = FJES_CMD_STATUS_TIMEOUT;\n\n\t} else {\n\t\tswitch (cr.bits.err_info) {\n\t\tcase FJES_CMD_REQ_ERR_INFO_PARAM:\n\t\t\tret = FJES_CMD_STATUS_ERROR_PARAM;\n\t\t\tbreak;\n\t\tcase FJES_CMD_REQ_ERR_INFO_STATUS:\n\t\t\tret = FJES_CMD_STATUS_ERROR_STATUS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = FJES_CMD_STATUS_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ttrace_fjes_hw_issue_request_command(&cr, &cs, timeout, ret);\n\n\treturn ret;\n}\n\nint fjes_hw_request_info(struct fjes_hw *hw)\n{\n\tunion fjes_device_command_req *req_buf = hw->hw_info.req_buf;\n\tunion fjes_device_command_res *res_buf = hw->hw_info.res_buf;\n\tenum fjes_dev_command_response_e ret;\n\tint result;\n\n\tmemset(req_buf, 0, hw->hw_info.req_buf_size);\n\tmemset(res_buf, 0, hw->hw_info.res_buf_size);\n\n\treq_buf->info.length = FJES_DEV_COMMAND_INFO_REQ_LEN;\n\n\tres_buf->info.length = 0;\n\tres_buf->info.code = 0;\n\n\tret = fjes_hw_issue_request_command(hw, FJES_CMD_REQ_INFO);\n\ttrace_fjes_hw_request_info(hw, res_buf);\n\n\tresult = 0;\n\n\tif (FJES_DEV_COMMAND_INFO_RES_LEN((*hw->hw_info.max_epid)) !=\n\t\tres_buf->info.length) {\n\t\ttrace_fjes_hw_request_info_err(\"Invalid res_buf\");\n\t\tresult = -ENOMSG;\n\t} else if (ret == FJES_CMD_STATUS_NORMAL) {\n\t\tswitch (res_buf->info.code) {\n\t\tcase FJES_CMD_REQ_RES_CODE_NORMAL:\n\t\t\tresult = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tresult = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (ret) {\n\t\tcase FJES_CMD_STATUS_UNKNOWN:\n\t\t\tresult = -EPERM;\n\t\t\tbreak;\n\t\tcase FJES_CMD_STATUS_TIMEOUT:\n\t\t\ttrace_fjes_hw_request_info_err(\"Timeout\");\n\t\t\tresult = -EBUSY;\n\t\t\tbreak;\n\t\tcase FJES_CMD_STATUS_ERROR_PARAM:\n\t\t\tresult = -EPERM;\n\t\t\tbreak;\n\t\tcase FJES_CMD_STATUS_ERROR_STATUS:\n\t\t\tresult = -EPERM;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tresult = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nint fjes_hw_register_buff_addr(struct fjes_hw *hw, int dest_epid,\n\t\t\t       struct ep_share_mem_info *buf_pair)\n{\n\tunion fjes_device_command_req *req_buf = hw->hw_info.req_buf;\n\tunion fjes_device_command_res *res_buf = hw->hw_info.res_buf;\n\tenum fjes_dev_command_response_e ret;\n\tint page_count;\n\tint timeout;\n\tint i, idx;\n\tvoid *addr;\n\tint result;\n\n\tif (test_bit(dest_epid, &hw->hw_info.buffer_share_bit))\n\t\treturn 0;\n\n\tmemset(req_buf, 0, hw->hw_info.req_buf_size);\n\tmemset(res_buf, 0, hw->hw_info.res_buf_size);\n\n\treq_buf->share_buffer.length = FJES_DEV_COMMAND_SHARE_BUFFER_REQ_LEN(\n\t\t\t\t\t\tbuf_pair->tx.size,\n\t\t\t\t\t\tbuf_pair->rx.size);\n\treq_buf->share_buffer.epid = dest_epid;\n\n\tidx = 0;\n\treq_buf->share_buffer.buffer[idx++] = buf_pair->tx.size;\n\tpage_count = buf_pair->tx.size / EP_BUFFER_INFO_SIZE;\n\tfor (i = 0; i < page_count; i++) {\n\t\taddr = ((u8 *)(buf_pair->tx.buffer)) +\n\t\t\t\t(i * EP_BUFFER_INFO_SIZE);\n\t\treq_buf->share_buffer.buffer[idx++] =\n\t\t\t\t(__le64)(page_to_phys(vmalloc_to_page(addr)) +\n\t\t\t\t\t\toffset_in_page(addr));\n\t}\n\n\treq_buf->share_buffer.buffer[idx++] = buf_pair->rx.size;\n\tpage_count = buf_pair->rx.size / EP_BUFFER_INFO_SIZE;\n\tfor (i = 0; i < page_count; i++) {\n\t\taddr = ((u8 *)(buf_pair->rx.buffer)) +\n\t\t\t\t(i * EP_BUFFER_INFO_SIZE);\n\t\treq_buf->share_buffer.buffer[idx++] =\n\t\t\t\t(__le64)(page_to_phys(vmalloc_to_page(addr)) +\n\t\t\t\t\t\toffset_in_page(addr));\n\t}\n\n\tres_buf->share_buffer.length = 0;\n\tres_buf->share_buffer.code = 0;\n\n\ttrace_fjes_hw_register_buff_addr_req(req_buf, buf_pair);\n\n\tret = fjes_hw_issue_request_command(hw, FJES_CMD_REQ_SHARE_BUFFER);\n\n\ttimeout = FJES_COMMAND_REQ_BUFF_TIMEOUT * 1000;\n\twhile ((ret == FJES_CMD_STATUS_NORMAL) &&\n\t       (res_buf->share_buffer.length ==\n\t\tFJES_DEV_COMMAND_SHARE_BUFFER_RES_LEN) &&\n\t       (res_buf->share_buffer.code == FJES_CMD_REQ_RES_CODE_BUSY) &&\n\t       (timeout > 0)) {\n\t\t\tmsleep(200 + hw->my_epid * 20);\n\t\t\ttimeout -= (200 + hw->my_epid * 20);\n\n\t\t\tres_buf->share_buffer.length = 0;\n\t\t\tres_buf->share_buffer.code = 0;\n\n\t\t\tret = fjes_hw_issue_request_command(\n\t\t\t\t\thw, FJES_CMD_REQ_SHARE_BUFFER);\n\t}\n\n\tresult = 0;\n\n\ttrace_fjes_hw_register_buff_addr(res_buf, timeout);\n\n\tif (res_buf->share_buffer.length !=\n\t\t\tFJES_DEV_COMMAND_SHARE_BUFFER_RES_LEN) {\n\t\ttrace_fjes_hw_register_buff_addr_err(\"Invalid res_buf\");\n\t\tresult = -ENOMSG;\n\t} else if (ret == FJES_CMD_STATUS_NORMAL) {\n\t\tswitch (res_buf->share_buffer.code) {\n\t\tcase FJES_CMD_REQ_RES_CODE_NORMAL:\n\t\t\tresult = 0;\n\t\t\tset_bit(dest_epid, &hw->hw_info.buffer_share_bit);\n\t\t\tbreak;\n\t\tcase FJES_CMD_REQ_RES_CODE_BUSY:\n\t\t\ttrace_fjes_hw_register_buff_addr_err(\"Busy Timeout\");\n\t\t\tresult = -EBUSY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tresult = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (ret) {\n\t\tcase FJES_CMD_STATUS_UNKNOWN:\n\t\t\tresult = -EPERM;\n\t\t\tbreak;\n\t\tcase FJES_CMD_STATUS_TIMEOUT:\n\t\t\ttrace_fjes_hw_register_buff_addr_err(\"Timeout\");\n\t\t\tresult = -EBUSY;\n\t\t\tbreak;\n\t\tcase FJES_CMD_STATUS_ERROR_PARAM:\n\t\tcase FJES_CMD_STATUS_ERROR_STATUS:\n\t\tdefault:\n\t\t\tresult = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nint fjes_hw_unregister_buff_addr(struct fjes_hw *hw, int dest_epid)\n{\n\tunion fjes_device_command_req *req_buf = hw->hw_info.req_buf;\n\tunion fjes_device_command_res *res_buf = hw->hw_info.res_buf;\n\tstruct fjes_device_shared_info *share = hw->hw_info.share;\n\tenum fjes_dev_command_response_e ret;\n\tint timeout;\n\tint result;\n\n\tif (!hw->base)\n\t\treturn -EPERM;\n\n\tif (!req_buf || !res_buf || !share)\n\t\treturn -EPERM;\n\n\tif (!test_bit(dest_epid, &hw->hw_info.buffer_share_bit))\n\t\treturn 0;\n\n\tmemset(req_buf, 0, hw->hw_info.req_buf_size);\n\tmemset(res_buf, 0, hw->hw_info.res_buf_size);\n\n\treq_buf->unshare_buffer.length =\n\t\t\tFJES_DEV_COMMAND_UNSHARE_BUFFER_REQ_LEN;\n\treq_buf->unshare_buffer.epid = dest_epid;\n\n\tres_buf->unshare_buffer.length = 0;\n\tres_buf->unshare_buffer.code = 0;\n\n\ttrace_fjes_hw_unregister_buff_addr_req(req_buf);\n\tret = fjes_hw_issue_request_command(hw, FJES_CMD_REQ_UNSHARE_BUFFER);\n\n\ttimeout = FJES_COMMAND_REQ_BUFF_TIMEOUT * 1000;\n\twhile ((ret == FJES_CMD_STATUS_NORMAL) &&\n\t       (res_buf->unshare_buffer.length ==\n\t\tFJES_DEV_COMMAND_UNSHARE_BUFFER_RES_LEN) &&\n\t       (res_buf->unshare_buffer.code ==\n\t\tFJES_CMD_REQ_RES_CODE_BUSY) &&\n\t       (timeout > 0)) {\n\t\tmsleep(200 + hw->my_epid * 20);\n\t\ttimeout -= (200 + hw->my_epid * 20);\n\n\t\tres_buf->unshare_buffer.length = 0;\n\t\tres_buf->unshare_buffer.code = 0;\n\n\t\tret =\n\t\tfjes_hw_issue_request_command(hw, FJES_CMD_REQ_UNSHARE_BUFFER);\n\t}\n\n\tresult = 0;\n\n\ttrace_fjes_hw_unregister_buff_addr(res_buf, timeout);\n\n\tif (res_buf->unshare_buffer.length !=\n\t\t\tFJES_DEV_COMMAND_UNSHARE_BUFFER_RES_LEN) {\n\t\ttrace_fjes_hw_unregister_buff_addr_err(\"Invalid res_buf\");\n\t\tresult = -ENOMSG;\n\t} else if (ret == FJES_CMD_STATUS_NORMAL) {\n\t\tswitch (res_buf->unshare_buffer.code) {\n\t\tcase FJES_CMD_REQ_RES_CODE_NORMAL:\n\t\t\tresult = 0;\n\t\t\tclear_bit(dest_epid, &hw->hw_info.buffer_share_bit);\n\t\t\tbreak;\n\t\tcase FJES_CMD_REQ_RES_CODE_BUSY:\n\t\t\ttrace_fjes_hw_unregister_buff_addr_err(\"Busy Timeout\");\n\t\t\tresult = -EBUSY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tresult = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (ret) {\n\t\tcase FJES_CMD_STATUS_UNKNOWN:\n\t\t\tresult = -EPERM;\n\t\t\tbreak;\n\t\tcase FJES_CMD_STATUS_TIMEOUT:\n\t\t\ttrace_fjes_hw_unregister_buff_addr_err(\"Timeout\");\n\t\t\tresult = -EBUSY;\n\t\t\tbreak;\n\t\tcase FJES_CMD_STATUS_ERROR_PARAM:\n\t\tcase FJES_CMD_STATUS_ERROR_STATUS:\n\t\tdefault:\n\t\t\tresult = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nint fjes_hw_raise_interrupt(struct fjes_hw *hw, int dest_epid,\n\t\t\t    enum REG_ICTL_MASK  mask)\n{\n\tu32 ig = mask | dest_epid;\n\n\twr32(XSCT_IG, cpu_to_le32(ig));\n\n\treturn 0;\n}\n\nu32 fjes_hw_capture_interrupt_status(struct fjes_hw *hw)\n{\n\tu32 cur_is;\n\n\tcur_is = rd32(XSCT_IS);\n\n\treturn cur_is;\n}\n\nvoid fjes_hw_set_irqmask(struct fjes_hw *hw,\n\t\t\t enum REG_ICTL_MASK intr_mask, bool mask)\n{\n\tif (mask)\n\t\twr32(XSCT_IMS, intr_mask);\n\telse\n\t\twr32(XSCT_IMC, intr_mask);\n}\n\nbool fjes_hw_epid_is_same_zone(struct fjes_hw *hw, int epid)\n{\n\tif (epid >= hw->max_epid)\n\t\treturn false;\n\n\tif ((hw->ep_shm_info[epid].es_status !=\n\t\t\tFJES_ZONING_STATUS_ENABLE) ||\n\t\t(hw->ep_shm_info[hw->my_epid].zone ==\n\t\t\tFJES_ZONING_ZONE_TYPE_NONE))\n\t\treturn false;\n\telse\n\t\treturn (hw->ep_shm_info[epid].zone ==\n\t\t\t\thw->ep_shm_info[hw->my_epid].zone);\n}\n\nint fjes_hw_epid_is_shared(struct fjes_device_shared_info *share,\n\t\t\t   int dest_epid)\n{\n\tint value = false;\n\n\tif (dest_epid < share->epnum)\n\t\tvalue = share->ep_status[dest_epid];\n\n\treturn value;\n}\n\nstatic bool fjes_hw_epid_is_stop_requested(struct fjes_hw *hw, int src_epid)\n{\n\treturn test_bit(src_epid, &hw->txrx_stop_req_bit);\n}\n\nstatic bool fjes_hw_epid_is_stop_process_done(struct fjes_hw *hw, int src_epid)\n{\n\treturn (hw->ep_shm_info[src_epid].tx.info->v1i.rx_status &\n\t\t\tFJES_RX_STOP_REQ_DONE);\n}\n\nenum ep_partner_status\nfjes_hw_get_partner_ep_status(struct fjes_hw *hw, int epid)\n{\n\tenum ep_partner_status status;\n\n\tif (fjes_hw_epid_is_shared(hw->hw_info.share, epid)) {\n\t\tif (fjes_hw_epid_is_stop_requested(hw, epid)) {\n\t\t\tstatus = EP_PARTNER_WAITING;\n\t\t} else {\n\t\t\tif (fjes_hw_epid_is_stop_process_done(hw, epid))\n\t\t\t\tstatus = EP_PARTNER_COMPLETE;\n\t\t\telse\n\t\t\t\tstatus = EP_PARTNER_SHARED;\n\t\t}\n\t} else {\n\t\tstatus = EP_PARTNER_UNSHARE;\n\t}\n\n\treturn status;\n}\n\nvoid fjes_hw_raise_epstop(struct fjes_hw *hw)\n{\n\tenum ep_partner_status status;\n\tunsigned long flags;\n\tint epidx;\n\n\tfor (epidx = 0; epidx < hw->max_epid; epidx++) {\n\t\tif (epidx == hw->my_epid)\n\t\t\tcontinue;\n\n\t\tstatus = fjes_hw_get_partner_ep_status(hw, epidx);\n\t\tswitch (status) {\n\t\tcase EP_PARTNER_SHARED:\n\t\t\tfjes_hw_raise_interrupt(hw, epidx,\n\t\t\t\t\t\tREG_ICTL_MASK_TXRX_STOP_REQ);\n\t\t\thw->ep_shm_info[epidx].ep_stats.send_intr_unshare += 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tset_bit(epidx, &hw->hw_info.buffer_unshare_reserve_bit);\n\t\tset_bit(epidx, &hw->txrx_stop_req_bit);\n\n\t\tspin_lock_irqsave(&hw->rx_status_lock, flags);\n\t\thw->ep_shm_info[epidx].tx.info->v1i.rx_status |=\n\t\t\t\tFJES_RX_STOP_REQ_REQUEST;\n\t\tspin_unlock_irqrestore(&hw->rx_status_lock, flags);\n\t}\n}\n\nint fjes_hw_wait_epstop(struct fjes_hw *hw)\n{\n\tenum ep_partner_status status;\n\tunion ep_buffer_info *info;\n\tint wait_time = 0;\n\tint epidx;\n\n\twhile (hw->hw_info.buffer_unshare_reserve_bit &&\n\t       (wait_time < FJES_COMMAND_EPSTOP_WAIT_TIMEOUT * 1000)) {\n\t\tfor (epidx = 0; epidx < hw->max_epid; epidx++) {\n\t\t\tif (epidx == hw->my_epid)\n\t\t\t\tcontinue;\n\t\t\tstatus = fjes_hw_epid_is_shared(hw->hw_info.share,\n\t\t\t\t\t\t\tepidx);\n\t\t\tinfo = hw->ep_shm_info[epidx].rx.info;\n\t\t\tif ((!status ||\n\t\t\t     (info->v1i.rx_status &\n\t\t\t      FJES_RX_STOP_REQ_DONE)) &&\n\t\t\t    test_bit(epidx,\n\t\t\t\t     &hw->hw_info.buffer_unshare_reserve_bit)) {\n\t\t\t\tclear_bit(epidx,\n\t\t\t\t\t  &hw->hw_info.buffer_unshare_reserve_bit);\n\t\t\t}\n\t\t}\n\n\t\tmsleep(100);\n\t\twait_time += 100;\n\t}\n\n\tfor (epidx = 0; epidx < hw->max_epid; epidx++) {\n\t\tif (epidx == hw->my_epid)\n\t\t\tcontinue;\n\t\tif (test_bit(epidx, &hw->hw_info.buffer_unshare_reserve_bit))\n\t\t\tclear_bit(epidx,\n\t\t\t\t  &hw->hw_info.buffer_unshare_reserve_bit);\n\t}\n\n\treturn (wait_time < FJES_COMMAND_EPSTOP_WAIT_TIMEOUT * 1000)\n\t\t\t? 0 : -EBUSY;\n}\n\nbool fjes_hw_check_epbuf_version(struct epbuf_handler *epbh, u32 version)\n{\n\tunion ep_buffer_info *info = epbh->info;\n\n\treturn (info->common.version == version);\n}\n\nbool fjes_hw_check_mtu(struct epbuf_handler *epbh, u32 mtu)\n{\n\tunion ep_buffer_info *info = epbh->info;\n\n\treturn ((info->v1i.frame_max == FJES_MTU_TO_FRAME_SIZE(mtu)) &&\n\t\tinfo->v1i.rx_status & FJES_RX_MTU_CHANGING_DONE);\n}\n\nbool fjes_hw_check_vlan_id(struct epbuf_handler *epbh, u16 vlan_id)\n{\n\tunion ep_buffer_info *info = epbh->info;\n\tbool ret = false;\n\tint i;\n\n\tif (vlan_id == 0) {\n\t\tret = true;\n\t} else {\n\t\tfor (i = 0; i < EP_BUFFER_SUPPORT_VLAN_MAX; i++) {\n\t\t\tif (vlan_id == info->v1i.vlan_id[i]) {\n\t\t\t\tret = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool fjes_hw_set_vlan_id(struct epbuf_handler *epbh, u16 vlan_id)\n{\n\tunion ep_buffer_info *info = epbh->info;\n\tint i;\n\n\tfor (i = 0; i < EP_BUFFER_SUPPORT_VLAN_MAX; i++) {\n\t\tif (info->v1i.vlan_id[i] == 0) {\n\t\t\tinfo->v1i.vlan_id[i] = vlan_id;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid fjes_hw_del_vlan_id(struct epbuf_handler *epbh, u16 vlan_id)\n{\n\tunion ep_buffer_info *info = epbh->info;\n\tint i;\n\n\tif (0 != vlan_id) {\n\t\tfor (i = 0; i < EP_BUFFER_SUPPORT_VLAN_MAX; i++) {\n\t\t\tif (vlan_id == info->v1i.vlan_id[i])\n\t\t\t\tinfo->v1i.vlan_id[i] = 0;\n\t\t}\n\t}\n}\n\nbool fjes_hw_epbuf_rx_is_empty(struct epbuf_handler *epbh)\n{\n\tunion ep_buffer_info *info = epbh->info;\n\n\tif (!(info->v1i.rx_status & FJES_RX_MTU_CHANGING_DONE))\n\t\treturn true;\n\n\tif (info->v1i.count_max == 0)\n\t\treturn true;\n\n\treturn EP_RING_EMPTY(info->v1i.head, info->v1i.tail,\n\t\t\t     info->v1i.count_max);\n}\n\nvoid *fjes_hw_epbuf_rx_curpkt_get_addr(struct epbuf_handler *epbh,\n\t\t\t\t       size_t *psize)\n{\n\tunion ep_buffer_info *info = epbh->info;\n\tstruct esmem_frame *ring_frame;\n\tvoid *frame;\n\n\tring_frame = (struct esmem_frame *)&(epbh->ring[EP_RING_INDEX\n\t\t\t\t\t     (info->v1i.head,\n\t\t\t\t\t      info->v1i.count_max) *\n\t\t\t\t\t     info->v1i.frame_max]);\n\n\t*psize = (size_t)ring_frame->frame_size;\n\n\tframe = ring_frame->frame_data;\n\n\treturn frame;\n}\n\nvoid fjes_hw_epbuf_rx_curpkt_drop(struct epbuf_handler *epbh)\n{\n\tunion ep_buffer_info *info = epbh->info;\n\n\tif (fjes_hw_epbuf_rx_is_empty(epbh))\n\t\treturn;\n\n\tEP_RING_INDEX_INC(epbh->info->v1i.head, info->v1i.count_max);\n}\n\nint fjes_hw_epbuf_tx_pkt_send(struct epbuf_handler *epbh,\n\t\t\t      void *frame, size_t size)\n{\n\tunion ep_buffer_info *info = epbh->info;\n\tstruct esmem_frame *ring_frame;\n\n\tif (EP_RING_FULL(info->v1i.head, info->v1i.tail, info->v1i.count_max))\n\t\treturn -ENOBUFS;\n\n\tring_frame = (struct esmem_frame *)&(epbh->ring[EP_RING_INDEX\n\t\t\t\t\t     (info->v1i.tail - 1,\n\t\t\t\t\t      info->v1i.count_max) *\n\t\t\t\t\t     info->v1i.frame_max]);\n\n\tring_frame->frame_size = size;\n\tmemcpy((void *)(ring_frame->frame_data), (void *)frame, size);\n\n\tEP_RING_INDEX_INC(epbh->info->v1i.tail, info->v1i.count_max);\n\n\treturn 0;\n}\n\nstatic void fjes_hw_update_zone_task(struct work_struct *work)\n{\n\tstruct fjes_hw *hw = container_of(work,\n\t\t\tstruct fjes_hw, update_zone_task);\n\n\tstruct my_s {u8 es_status; u8 zone; } *info;\n\tunion fjes_device_command_res *res_buf;\n\tenum ep_partner_status pstatus;\n\n\tstruct fjes_adapter *adapter;\n\tstruct net_device *netdev;\n\tunsigned long flags;\n\n\tulong unshare_bit = 0;\n\tulong share_bit = 0;\n\tulong irq_bit = 0;\n\n\tint epidx;\n\tint ret;\n\n\tadapter = (struct fjes_adapter *)hw->back;\n\tnetdev = adapter->netdev;\n\tres_buf = hw->hw_info.res_buf;\n\tinfo = (struct my_s *)&res_buf->info.info;\n\n\tmutex_lock(&hw->hw_info.lock);\n\n\tret = fjes_hw_request_info(hw);\n\tswitch (ret) {\n\tcase -ENOMSG:\n\tcase -EBUSY:\n\tdefault:\n\t\tif (!work_pending(&adapter->force_close_task)) {\n\t\t\tadapter->force_reset = true;\n\t\t\tschedule_work(&adapter->force_close_task);\n\t\t}\n\t\tbreak;\n\n\tcase 0:\n\n\t\tfor (epidx = 0; epidx < hw->max_epid; epidx++) {\n\t\t\tif (epidx == hw->my_epid) {\n\t\t\t\thw->ep_shm_info[epidx].es_status =\n\t\t\t\t\tinfo[epidx].es_status;\n\t\t\t\thw->ep_shm_info[epidx].zone =\n\t\t\t\t\tinfo[epidx].zone;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tpstatus = fjes_hw_get_partner_ep_status(hw, epidx);\n\t\t\tswitch (pstatus) {\n\t\t\tcase EP_PARTNER_UNSHARE:\n\t\t\tdefault:\n\t\t\t\tif ((info[epidx].zone !=\n\t\t\t\t\tFJES_ZONING_ZONE_TYPE_NONE) &&\n\t\t\t\t    (info[epidx].es_status ==\n\t\t\t\t\tFJES_ZONING_STATUS_ENABLE) &&\n\t\t\t\t    (info[epidx].zone ==\n\t\t\t\t\tinfo[hw->my_epid].zone))\n\t\t\t\t\tset_bit(epidx, &share_bit);\n\t\t\t\telse\n\t\t\t\t\tset_bit(epidx, &unshare_bit);\n\t\t\t\tbreak;\n\n\t\t\tcase EP_PARTNER_COMPLETE:\n\t\t\tcase EP_PARTNER_WAITING:\n\t\t\t\tif ((info[epidx].zone ==\n\t\t\t\t\tFJES_ZONING_ZONE_TYPE_NONE) ||\n\t\t\t\t    (info[epidx].es_status !=\n\t\t\t\t\tFJES_ZONING_STATUS_ENABLE) ||\n\t\t\t\t    (info[epidx].zone !=\n\t\t\t\t\tinfo[hw->my_epid].zone)) {\n\t\t\t\t\tset_bit(epidx,\n\t\t\t\t\t\t&adapter->unshare_watch_bitmask);\n\t\t\t\t\tset_bit(epidx,\n\t\t\t\t\t\t&hw->hw_info.buffer_unshare_reserve_bit);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase EP_PARTNER_SHARED:\n\t\t\t\tif ((info[epidx].zone ==\n\t\t\t\t\tFJES_ZONING_ZONE_TYPE_NONE) ||\n\t\t\t\t    (info[epidx].es_status !=\n\t\t\t\t\tFJES_ZONING_STATUS_ENABLE) ||\n\t\t\t\t    (info[epidx].zone !=\n\t\t\t\t\tinfo[hw->my_epid].zone))\n\t\t\t\t\tset_bit(epidx, &irq_bit);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\thw->ep_shm_info[epidx].es_status =\n\t\t\t\tinfo[epidx].es_status;\n\t\t\thw->ep_shm_info[epidx].zone = info[epidx].zone;\n\t\t}\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&hw->hw_info.lock);\n\n\tfor (epidx = 0; epidx < hw->max_epid; epidx++) {\n\t\tif (epidx == hw->my_epid)\n\t\t\tcontinue;\n\n\t\tif (test_bit(epidx, &share_bit)) {\n\t\t\tspin_lock_irqsave(&hw->rx_status_lock, flags);\n\t\t\tfjes_hw_setup_epbuf(&hw->ep_shm_info[epidx].tx,\n\t\t\t\t\t    netdev->dev_addr, netdev->mtu);\n\t\t\tspin_unlock_irqrestore(&hw->rx_status_lock, flags);\n\n\t\t\tmutex_lock(&hw->hw_info.lock);\n\n\t\t\tret = fjes_hw_register_buff_addr(\n\t\t\t\thw, epidx, &hw->ep_shm_info[epidx]);\n\n\t\t\tswitch (ret) {\n\t\t\tcase 0:\n\t\t\t\tbreak;\n\t\t\tcase -ENOMSG:\n\t\t\tcase -EBUSY:\n\t\t\tdefault:\n\t\t\t\tif (!work_pending(&adapter->force_close_task)) {\n\t\t\t\t\tadapter->force_reset = true;\n\t\t\t\t\tschedule_work(\n\t\t\t\t\t  &adapter->force_close_task);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmutex_unlock(&hw->hw_info.lock);\n\n\t\t\thw->ep_shm_info[epidx].ep_stats\n\t\t\t\t\t      .com_regist_buf_exec += 1;\n\t\t}\n\n\t\tif (test_bit(epidx, &unshare_bit)) {\n\t\t\tmutex_lock(&hw->hw_info.lock);\n\n\t\t\tret = fjes_hw_unregister_buff_addr(hw, epidx);\n\n\t\t\tswitch (ret) {\n\t\t\tcase 0:\n\t\t\t\tbreak;\n\t\t\tcase -ENOMSG:\n\t\t\tcase -EBUSY:\n\t\t\tdefault:\n\t\t\t\tif (!work_pending(&adapter->force_close_task)) {\n\t\t\t\t\tadapter->force_reset = true;\n\t\t\t\t\tschedule_work(\n\t\t\t\t\t  &adapter->force_close_task);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmutex_unlock(&hw->hw_info.lock);\n\n\t\t\thw->ep_shm_info[epidx].ep_stats\n\t\t\t\t\t      .com_unregist_buf_exec += 1;\n\n\t\t\tif (ret == 0) {\n\t\t\t\tspin_lock_irqsave(&hw->rx_status_lock, flags);\n\t\t\t\tfjes_hw_setup_epbuf(\n\t\t\t\t\t&hw->ep_shm_info[epidx].tx,\n\t\t\t\t\tnetdev->dev_addr, netdev->mtu);\n\t\t\t\tspin_unlock_irqrestore(&hw->rx_status_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t}\n\t\t}\n\n\t\tif (test_bit(epidx, &irq_bit)) {\n\t\t\tfjes_hw_raise_interrupt(hw, epidx,\n\t\t\t\t\t\tREG_ICTL_MASK_TXRX_STOP_REQ);\n\n\t\t\thw->ep_shm_info[epidx].ep_stats.send_intr_unshare += 1;\n\n\t\t\tset_bit(epidx, &hw->txrx_stop_req_bit);\n\t\t\tspin_lock_irqsave(&hw->rx_status_lock, flags);\n\t\t\thw->ep_shm_info[epidx].tx.\n\t\t\t\tinfo->v1i.rx_status |=\n\t\t\t\t\tFJES_RX_STOP_REQ_REQUEST;\n\t\t\tspin_unlock_irqrestore(&hw->rx_status_lock, flags);\n\t\t\tset_bit(epidx, &hw->hw_info.buffer_unshare_reserve_bit);\n\t\t}\n\t}\n\n\tif (irq_bit || adapter->unshare_watch_bitmask) {\n\t\tif (!work_pending(&adapter->unshare_watch_task))\n\t\t\tqueue_work(adapter->control_wq,\n\t\t\t\t   &adapter->unshare_watch_task);\n\t}\n}\n\nstatic void fjes_hw_epstop_task(struct work_struct *work)\n{\n\tstruct fjes_hw *hw = container_of(work, struct fjes_hw, epstop_task);\n\tstruct fjes_adapter *adapter = (struct fjes_adapter *)hw->back;\n\tunsigned long flags;\n\n\tulong remain_bit;\n\tint epid_bit;\n\n\twhile ((remain_bit = hw->epstop_req_bit)) {\n\t\tfor (epid_bit = 0; remain_bit; remain_bit >>= 1, epid_bit++) {\n\t\t\tif (remain_bit & 1) {\n\t\t\t\tspin_lock_irqsave(&hw->rx_status_lock, flags);\n\t\t\t\thw->ep_shm_info[epid_bit].\n\t\t\t\t\ttx.info->v1i.rx_status |=\n\t\t\t\t\t\tFJES_RX_STOP_REQ_DONE;\n\t\t\t\tspin_unlock_irqrestore(&hw->rx_status_lock,\n\t\t\t\t\t\t       flags);\n\n\t\t\t\tclear_bit(epid_bit, &hw->epstop_req_bit);\n\t\t\t\tset_bit(epid_bit,\n\t\t\t\t\t&adapter->unshare_watch_bitmask);\n\n\t\t\t\tif (!work_pending(&adapter->unshare_watch_task))\n\t\t\t\t\tqueue_work(\n\t\t\t\t\t\tadapter->control_wq,\n\t\t\t\t\t\t&adapter->unshare_watch_task);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint fjes_hw_start_debug(struct fjes_hw *hw)\n{\n\tunion fjes_device_command_req *req_buf = hw->hw_info.req_buf;\n\tunion fjes_device_command_res *res_buf = hw->hw_info.res_buf;\n\tenum fjes_dev_command_response_e ret;\n\tint page_count;\n\tint result = 0;\n\tvoid *addr;\n\tint i;\n\n\tif (!hw->hw_info.trace)\n\t\treturn -EPERM;\n\tmemset(hw->hw_info.trace, 0, FJES_DEBUG_BUFFER_SIZE);\n\n\tmemset(req_buf, 0, hw->hw_info.req_buf_size);\n\tmemset(res_buf, 0, hw->hw_info.res_buf_size);\n\n\treq_buf->start_trace.length =\n\t\tFJES_DEV_COMMAND_START_DBG_REQ_LEN(hw->hw_info.trace_size);\n\treq_buf->start_trace.mode = hw->debug_mode;\n\treq_buf->start_trace.buffer_len = hw->hw_info.trace_size;\n\tpage_count = hw->hw_info.trace_size / FJES_DEBUG_PAGE_SIZE;\n\tfor (i = 0; i < page_count; i++) {\n\t\taddr = ((u8 *)hw->hw_info.trace) + i * FJES_DEBUG_PAGE_SIZE;\n\t\treq_buf->start_trace.buffer[i] =\n\t\t\t(__le64)(page_to_phys(vmalloc_to_page(addr)) +\n\t\t\toffset_in_page(addr));\n\t}\n\n\tres_buf->start_trace.length = 0;\n\tres_buf->start_trace.code = 0;\n\n\ttrace_fjes_hw_start_debug_req(req_buf);\n\tret = fjes_hw_issue_request_command(hw, FJES_CMD_REQ_START_DEBUG);\n\ttrace_fjes_hw_start_debug(res_buf);\n\n\tif (res_buf->start_trace.length !=\n\t\tFJES_DEV_COMMAND_START_DBG_RES_LEN) {\n\t\tresult = -ENOMSG;\n\t\ttrace_fjes_hw_start_debug_err(\"Invalid res_buf\");\n\t} else if (ret == FJES_CMD_STATUS_NORMAL) {\n\t\tswitch (res_buf->start_trace.code) {\n\t\tcase FJES_CMD_REQ_RES_CODE_NORMAL:\n\t\t\tresult = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tresult = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (ret) {\n\t\tcase FJES_CMD_STATUS_UNKNOWN:\n\t\t\tresult = -EPERM;\n\t\t\tbreak;\n\t\tcase FJES_CMD_STATUS_TIMEOUT:\n\t\t\ttrace_fjes_hw_start_debug_err(\"Busy Timeout\");\n\t\t\tresult = -EBUSY;\n\t\t\tbreak;\n\t\tcase FJES_CMD_STATUS_ERROR_PARAM:\n\t\tcase FJES_CMD_STATUS_ERROR_STATUS:\n\t\tdefault:\n\t\t\tresult = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nint fjes_hw_stop_debug(struct fjes_hw *hw)\n{\n\tunion fjes_device_command_req *req_buf = hw->hw_info.req_buf;\n\tunion fjes_device_command_res *res_buf = hw->hw_info.res_buf;\n\tenum fjes_dev_command_response_e ret;\n\tint result = 0;\n\n\tif (!hw->hw_info.trace)\n\t\treturn -EPERM;\n\n\tmemset(req_buf, 0, hw->hw_info.req_buf_size);\n\tmemset(res_buf, 0, hw->hw_info.res_buf_size);\n\treq_buf->stop_trace.length = FJES_DEV_COMMAND_STOP_DBG_REQ_LEN;\n\n\tres_buf->stop_trace.length = 0;\n\tres_buf->stop_trace.code = 0;\n\n\tret = fjes_hw_issue_request_command(hw, FJES_CMD_REQ_STOP_DEBUG);\n\ttrace_fjes_hw_stop_debug(res_buf);\n\n\tif (res_buf->stop_trace.length != FJES_DEV_COMMAND_STOP_DBG_RES_LEN) {\n\t\ttrace_fjes_hw_stop_debug_err(\"Invalid res_buf\");\n\t\tresult = -ENOMSG;\n\t} else if (ret == FJES_CMD_STATUS_NORMAL) {\n\t\tswitch (res_buf->stop_trace.code) {\n\t\tcase FJES_CMD_REQ_RES_CODE_NORMAL:\n\t\t\tresult = 0;\n\t\t\thw->debug_mode = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tresult = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (ret) {\n\t\tcase FJES_CMD_STATUS_UNKNOWN:\n\t\t\tresult = -EPERM;\n\t\t\tbreak;\n\t\tcase FJES_CMD_STATUS_TIMEOUT:\n\t\t\tresult = -EBUSY;\n\t\t\ttrace_fjes_hw_stop_debug_err(\"Busy Timeout\");\n\t\t\tbreak;\n\t\tcase FJES_CMD_STATUS_ERROR_PARAM:\n\t\tcase FJES_CMD_STATUS_ERROR_STATUS:\n\t\tdefault:\n\t\t\tresult = -EPERM;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}