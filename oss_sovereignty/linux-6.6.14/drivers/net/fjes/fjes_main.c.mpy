{
  "module_name": "fjes_main.c",
  "hash_id": "b5f76089275302da75bb1e1aa3241607b5a5e0020c00c9916c850fa0fd5b60c9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/fjes/fjes_main.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/nls.h>\n#include <linux/platform_device.h>\n#include <linux/netdevice.h>\n#include <linux/interrupt.h>\n\n#include \"fjes.h\"\n#include \"fjes_trace.h\"\n\n#define MAJ 1\n#define MIN 2\n#define DRV_VERSION __stringify(MAJ) \".\" __stringify(MIN)\n#define DRV_NAME\t\"fjes\"\nchar fjes_driver_name[] = DRV_NAME;\nchar fjes_driver_version[] = DRV_VERSION;\nstatic const char fjes_driver_string[] =\n\t\t\"FUJITSU Extended Socket Network Device Driver\";\nstatic const char fjes_copyright[] =\n\t\t\"Copyright (c) 2015 FUJITSU LIMITED\";\n\nMODULE_AUTHOR(\"Taku Izumi <izumi.taku@jp.fujitsu.com>\");\nMODULE_DESCRIPTION(\"FUJITSU Extended Socket Network Device Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\n\n#define ACPI_MOTHERBOARD_RESOURCE_HID \"PNP0C02\"\n\nstatic const struct acpi_device_id fjes_acpi_ids[] = {\n\t{ACPI_MOTHERBOARD_RESOURCE_HID, 0},\n\t{\"\", 0},\n};\nMODULE_DEVICE_TABLE(acpi, fjes_acpi_ids);\n\nstatic bool is_extended_socket_device(struct acpi_device *device)\n{\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL};\n\tchar str_buf[sizeof(FJES_ACPI_SYMBOL) + 1];\n\tunion acpi_object *str;\n\tacpi_status status;\n\tint result;\n\n\tstatus = acpi_evaluate_object(device->handle, \"_STR\", NULL, &buffer);\n\tif (ACPI_FAILURE(status))\n\t\treturn false;\n\n\tstr = buffer.pointer;\n\tresult = utf16s_to_utf8s((wchar_t *)str->string.pointer,\n\t\t\t\t str->string.length, UTF16_LITTLE_ENDIAN,\n\t\t\t\t str_buf, sizeof(str_buf) - 1);\n\tstr_buf[result] = 0;\n\n\tif (strncmp(FJES_ACPI_SYMBOL, str_buf, strlen(FJES_ACPI_SYMBOL)) != 0) {\n\t\tkfree(buffer.pointer);\n\t\treturn false;\n\t}\n\tkfree(buffer.pointer);\n\n\treturn true;\n}\n\nstatic int acpi_check_extended_socket_status(struct acpi_device *device)\n{\n\tunsigned long long sta;\n\tacpi_status status;\n\n\tstatus = acpi_evaluate_integer(device->handle, \"_STA\", NULL, &sta);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\tif (!((sta & ACPI_STA_DEVICE_PRESENT) &&\n\t      (sta & ACPI_STA_DEVICE_ENABLED) &&\n\t      (sta & ACPI_STA_DEVICE_UI) &&\n\t      (sta & ACPI_STA_DEVICE_FUNCTIONING)))\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic acpi_status\nfjes_get_acpi_resource(struct acpi_resource *acpi_res, void *data)\n{\n\tstruct acpi_resource_address32 *addr;\n\tstruct acpi_resource_irq *irq;\n\tstruct resource *res = data;\n\n\tswitch (acpi_res->type) {\n\tcase ACPI_RESOURCE_TYPE_ADDRESS32:\n\t\taddr = &acpi_res->data.address32;\n\t\tres[0].start = addr->address.minimum;\n\t\tres[0].end = addr->address.minimum +\n\t\t\taddr->address.address_length - 1;\n\t\tbreak;\n\n\tcase ACPI_RESOURCE_TYPE_IRQ:\n\t\tirq = &acpi_res->data.irq;\n\t\tif (irq->interrupt_count != 1)\n\t\t\treturn AE_ERROR;\n\t\tres[1].start = irq->interrupts[0];\n\t\tres[1].end = irq->interrupts[0];\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn AE_OK;\n}\n\nstatic struct resource fjes_resource[] = {\n\tDEFINE_RES_MEM(0, 1),\n\tDEFINE_RES_IRQ(0)\n};\n\nstatic int fjes_acpi_add(struct acpi_device *device)\n{\n\tstruct platform_device *plat_dev;\n\tacpi_status status;\n\n\tif (!is_extended_socket_device(device))\n\t\treturn -ENODEV;\n\n\tif (acpi_check_extended_socket_status(device))\n\t\treturn -ENODEV;\n\n\tstatus = acpi_walk_resources(device->handle, METHOD_NAME__CRS,\n\t\t\t\t     fjes_get_acpi_resource, fjes_resource);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\t \n\tplat_dev = platform_device_register_simple(DRV_NAME, 0, fjes_resource,\n\t\t\t\t\t\t   ARRAY_SIZE(fjes_resource));\n\tif (IS_ERR(plat_dev))\n\t\treturn PTR_ERR(plat_dev);\n\n\tdevice->driver_data = plat_dev;\n\n\treturn 0;\n}\n\nstatic void fjes_acpi_remove(struct acpi_device *device)\n{\n\tstruct platform_device *plat_dev;\n\n\tplat_dev = (struct platform_device *)acpi_driver_data(device);\n\tplatform_device_unregister(plat_dev);\n}\n\nstatic struct acpi_driver fjes_acpi_driver = {\n\t.name = DRV_NAME,\n\t.class = DRV_NAME,\n\t.owner = THIS_MODULE,\n\t.ids = fjes_acpi_ids,\n\t.ops = {\n\t\t.add = fjes_acpi_add,\n\t\t.remove = fjes_acpi_remove,\n\t},\n};\n\nstatic int fjes_setup_resources(struct fjes_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct ep_share_mem_info *buf_pair;\n\tstruct fjes_hw *hw = &adapter->hw;\n\tunsigned long flags;\n\tint result;\n\tint epidx;\n\n\tmutex_lock(&hw->hw_info.lock);\n\tresult = fjes_hw_request_info(hw);\n\tswitch (result) {\n\tcase 0:\n\t\tfor (epidx = 0; epidx < hw->max_epid; epidx++) {\n\t\t\thw->ep_shm_info[epidx].es_status =\n\t\t\t    hw->hw_info.res_buf->info.info[epidx].es_status;\n\t\t\thw->ep_shm_info[epidx].zone =\n\t\t\t    hw->hw_info.res_buf->info.info[epidx].zone;\n\t\t}\n\t\tbreak;\n\tdefault:\n\tcase -ENOMSG:\n\tcase -EBUSY:\n\t\tadapter->force_reset = true;\n\n\t\tmutex_unlock(&hw->hw_info.lock);\n\t\treturn result;\n\t}\n\tmutex_unlock(&hw->hw_info.lock);\n\n\tfor (epidx = 0; epidx < (hw->max_epid); epidx++) {\n\t\tif ((epidx != hw->my_epid) &&\n\t\t    (hw->ep_shm_info[epidx].es_status ==\n\t\t     FJES_ZONING_STATUS_ENABLE)) {\n\t\t\tfjes_hw_raise_interrupt(hw, epidx,\n\t\t\t\t\t\tREG_ICTL_MASK_INFO_UPDATE);\n\t\t\thw->ep_shm_info[epidx].ep_stats\n\t\t\t\t.send_intr_zoneupdate += 1;\n\t\t}\n\t}\n\n\tmsleep(FJES_OPEN_ZONE_UPDATE_WAIT * hw->max_epid);\n\n\tfor (epidx = 0; epidx < (hw->max_epid); epidx++) {\n\t\tif (epidx == hw->my_epid)\n\t\t\tcontinue;\n\n\t\tbuf_pair = &hw->ep_shm_info[epidx];\n\n\t\tspin_lock_irqsave(&hw->rx_status_lock, flags);\n\t\tfjes_hw_setup_epbuf(&buf_pair->tx, netdev->dev_addr,\n\t\t\t\t    netdev->mtu);\n\t\tspin_unlock_irqrestore(&hw->rx_status_lock, flags);\n\n\t\tif (fjes_hw_epid_is_same_zone(hw, epidx)) {\n\t\t\tmutex_lock(&hw->hw_info.lock);\n\t\t\tresult =\n\t\t\tfjes_hw_register_buff_addr(hw, epidx, buf_pair);\n\t\t\tmutex_unlock(&hw->hw_info.lock);\n\n\t\t\tswitch (result) {\n\t\t\tcase 0:\n\t\t\t\tbreak;\n\t\t\tcase -ENOMSG:\n\t\t\tcase -EBUSY:\n\t\t\tdefault:\n\t\t\t\tadapter->force_reset = true;\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\thw->ep_shm_info[epidx].ep_stats\n\t\t\t\t.com_regist_buf_exec += 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void fjes_rx_irq(struct fjes_adapter *adapter, int src_epid)\n{\n\tstruct fjes_hw *hw = &adapter->hw;\n\n\tfjes_hw_set_irqmask(hw, REG_ICTL_MASK_RX_DATA, true);\n\n\tadapter->unset_rx_last = true;\n\tnapi_schedule(&adapter->napi);\n}\n\nstatic void fjes_stop_req_irq(struct fjes_adapter *adapter, int src_epid)\n{\n\tstruct fjes_hw *hw = &adapter->hw;\n\tenum ep_partner_status status;\n\tunsigned long flags;\n\n\tset_bit(src_epid, &hw->hw_info.buffer_unshare_reserve_bit);\n\n\tstatus = fjes_hw_get_partner_ep_status(hw, src_epid);\n\ttrace_fjes_stop_req_irq_pre(hw, src_epid, status);\n\tswitch (status) {\n\tcase EP_PARTNER_WAITING:\n\t\tspin_lock_irqsave(&hw->rx_status_lock, flags);\n\t\thw->ep_shm_info[src_epid].tx.info->v1i.rx_status |=\n\t\t\t\tFJES_RX_STOP_REQ_DONE;\n\t\tspin_unlock_irqrestore(&hw->rx_status_lock, flags);\n\t\tclear_bit(src_epid, &hw->txrx_stop_req_bit);\n\t\tfallthrough;\n\tcase EP_PARTNER_UNSHARE:\n\tcase EP_PARTNER_COMPLETE:\n\tdefault:\n\t\tset_bit(src_epid, &adapter->unshare_watch_bitmask);\n\t\tif (!work_pending(&adapter->unshare_watch_task))\n\t\t\tqueue_work(adapter->control_wq,\n\t\t\t\t   &adapter->unshare_watch_task);\n\t\tbreak;\n\tcase EP_PARTNER_SHARED:\n\t\tset_bit(src_epid, &hw->epstop_req_bit);\n\n\t\tif (!work_pending(&hw->epstop_task))\n\t\t\tqueue_work(adapter->control_wq, &hw->epstop_task);\n\t\tbreak;\n\t}\n\ttrace_fjes_stop_req_irq_post(hw, src_epid);\n}\n\nstatic void fjes_txrx_stop_req_irq(struct fjes_adapter *adapter,\n\t\t\t\t   int src_epid)\n{\n\tstruct fjes_hw *hw = &adapter->hw;\n\tenum ep_partner_status status;\n\tunsigned long flags;\n\n\tstatus = fjes_hw_get_partner_ep_status(hw, src_epid);\n\ttrace_fjes_txrx_stop_req_irq_pre(hw, src_epid, status);\n\tswitch (status) {\n\tcase EP_PARTNER_UNSHARE:\n\tcase EP_PARTNER_COMPLETE:\n\tdefault:\n\t\tbreak;\n\tcase EP_PARTNER_WAITING:\n\t\tif (src_epid < hw->my_epid) {\n\t\t\tspin_lock_irqsave(&hw->rx_status_lock, flags);\n\t\t\thw->ep_shm_info[src_epid].tx.info->v1i.rx_status |=\n\t\t\t\tFJES_RX_STOP_REQ_DONE;\n\t\t\tspin_unlock_irqrestore(&hw->rx_status_lock, flags);\n\n\t\t\tclear_bit(src_epid, &hw->txrx_stop_req_bit);\n\t\t\tset_bit(src_epid, &adapter->unshare_watch_bitmask);\n\n\t\t\tif (!work_pending(&adapter->unshare_watch_task))\n\t\t\t\tqueue_work(adapter->control_wq,\n\t\t\t\t\t   &adapter->unshare_watch_task);\n\t\t}\n\t\tbreak;\n\tcase EP_PARTNER_SHARED:\n\t\tif (hw->ep_shm_info[src_epid].rx.info->v1i.rx_status &\n\t\t    FJES_RX_STOP_REQ_REQUEST) {\n\t\t\tset_bit(src_epid, &hw->epstop_req_bit);\n\t\t\tif (!work_pending(&hw->epstop_task))\n\t\t\t\tqueue_work(adapter->control_wq,\n\t\t\t\t\t   &hw->epstop_task);\n\t\t}\n\t\tbreak;\n\t}\n\ttrace_fjes_txrx_stop_req_irq_post(hw, src_epid);\n}\n\nstatic void fjes_update_zone_irq(struct fjes_adapter *adapter,\n\t\t\t\t int src_epid)\n{\n\tstruct fjes_hw *hw = &adapter->hw;\n\n\tif (!work_pending(&hw->update_zone_task))\n\t\tqueue_work(adapter->control_wq, &hw->update_zone_task);\n}\n\nstatic irqreturn_t fjes_intr(int irq, void *data)\n{\n\tstruct fjes_adapter *adapter = data;\n\tstruct fjes_hw *hw = &adapter->hw;\n\tirqreturn_t ret;\n\tu32 icr;\n\n\ticr = fjes_hw_capture_interrupt_status(hw);\n\n\tif (icr & REG_IS_MASK_IS_ASSERT) {\n\t\tif (icr & REG_ICTL_MASK_RX_DATA) {\n\t\t\tfjes_rx_irq(adapter, icr & REG_IS_MASK_EPID);\n\t\t\thw->ep_shm_info[icr & REG_IS_MASK_EPID].ep_stats\n\t\t\t\t.recv_intr_rx += 1;\n\t\t}\n\n\t\tif (icr & REG_ICTL_MASK_DEV_STOP_REQ) {\n\t\t\tfjes_stop_req_irq(adapter, icr & REG_IS_MASK_EPID);\n\t\t\thw->ep_shm_info[icr & REG_IS_MASK_EPID].ep_stats\n\t\t\t\t.recv_intr_stop += 1;\n\t\t}\n\n\t\tif (icr & REG_ICTL_MASK_TXRX_STOP_REQ) {\n\t\t\tfjes_txrx_stop_req_irq(adapter, icr & REG_IS_MASK_EPID);\n\t\t\thw->ep_shm_info[icr & REG_IS_MASK_EPID].ep_stats\n\t\t\t\t.recv_intr_unshare += 1;\n\t\t}\n\n\t\tif (icr & REG_ICTL_MASK_TXRX_STOP_DONE)\n\t\t\tfjes_hw_set_irqmask(hw,\n\t\t\t\t\t    REG_ICTL_MASK_TXRX_STOP_DONE, true);\n\n\t\tif (icr & REG_ICTL_MASK_INFO_UPDATE) {\n\t\t\tfjes_update_zone_irq(adapter, icr & REG_IS_MASK_EPID);\n\t\t\thw->ep_shm_info[icr & REG_IS_MASK_EPID].ep_stats\n\t\t\t\t.recv_intr_zoneupdate += 1;\n\t\t}\n\n\t\tret = IRQ_HANDLED;\n\t} else {\n\t\tret = IRQ_NONE;\n\t}\n\n\treturn ret;\n}\n\nstatic int fjes_request_irq(struct fjes_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tint result = -1;\n\n\tadapter->interrupt_watch_enable = true;\n\tif (!delayed_work_pending(&adapter->interrupt_watch_task)) {\n\t\tqueue_delayed_work(adapter->control_wq,\n\t\t\t\t   &adapter->interrupt_watch_task,\n\t\t\t\t   FJES_IRQ_WATCH_DELAY);\n\t}\n\n\tif (!adapter->irq_registered) {\n\t\tresult = request_irq(adapter->hw.hw_res.irq, fjes_intr,\n\t\t\t\t     IRQF_SHARED, netdev->name, adapter);\n\t\tif (result)\n\t\t\tadapter->irq_registered = false;\n\t\telse\n\t\t\tadapter->irq_registered = true;\n\t}\n\n\treturn result;\n}\n\nstatic void fjes_free_irq(struct fjes_adapter *adapter)\n{\n\tstruct fjes_hw *hw = &adapter->hw;\n\n\tadapter->interrupt_watch_enable = false;\n\tcancel_delayed_work_sync(&adapter->interrupt_watch_task);\n\n\tfjes_hw_set_irqmask(hw, REG_ICTL_MASK_ALL, true);\n\n\tif (adapter->irq_registered) {\n\t\tfree_irq(adapter->hw.hw_res.irq, adapter);\n\t\tadapter->irq_registered = false;\n\t}\n}\n\nstatic void fjes_free_resources(struct fjes_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct fjes_device_command_param param;\n\tstruct ep_share_mem_info *buf_pair;\n\tstruct fjes_hw *hw = &adapter->hw;\n\tbool reset_flag = false;\n\tunsigned long flags;\n\tint result;\n\tint epidx;\n\n\tfor (epidx = 0; epidx < hw->max_epid; epidx++) {\n\t\tif (epidx == hw->my_epid)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&hw->hw_info.lock);\n\t\tresult = fjes_hw_unregister_buff_addr(hw, epidx);\n\t\tmutex_unlock(&hw->hw_info.lock);\n\n\t\thw->ep_shm_info[epidx].ep_stats.com_unregist_buf_exec += 1;\n\n\t\tif (result)\n\t\t\treset_flag = true;\n\n\t\tbuf_pair = &hw->ep_shm_info[epidx];\n\n\t\tspin_lock_irqsave(&hw->rx_status_lock, flags);\n\t\tfjes_hw_setup_epbuf(&buf_pair->tx,\n\t\t\t\t    netdev->dev_addr, netdev->mtu);\n\t\tspin_unlock_irqrestore(&hw->rx_status_lock, flags);\n\n\t\tclear_bit(epidx, &hw->txrx_stop_req_bit);\n\t}\n\n\tif (reset_flag || adapter->force_reset) {\n\t\tresult = fjes_hw_reset(hw);\n\n\t\tadapter->force_reset = false;\n\n\t\tif (result)\n\t\t\tadapter->open_guard = true;\n\n\t\thw->hw_info.buffer_share_bit = 0;\n\n\t\tmemset((void *)&param, 0, sizeof(param));\n\n\t\tparam.req_len = hw->hw_info.req_buf_size;\n\t\tparam.req_start = __pa(hw->hw_info.req_buf);\n\t\tparam.res_len = hw->hw_info.res_buf_size;\n\t\tparam.res_start = __pa(hw->hw_info.res_buf);\n\t\tparam.share_start = __pa(hw->hw_info.share->ep_status);\n\n\t\tfjes_hw_init_command_registers(hw, &param);\n\t}\n}\n\n \nstatic int fjes_open(struct net_device *netdev)\n{\n\tstruct fjes_adapter *adapter = netdev_priv(netdev);\n\tstruct fjes_hw *hw = &adapter->hw;\n\tint result;\n\n\tif (adapter->open_guard)\n\t\treturn -ENXIO;\n\n\tresult = fjes_setup_resources(adapter);\n\tif (result)\n\t\tgoto err_setup_res;\n\n\thw->txrx_stop_req_bit = 0;\n\thw->epstop_req_bit = 0;\n\n\tnapi_enable(&adapter->napi);\n\n\tfjes_hw_capture_interrupt_status(hw);\n\n\tresult = fjes_request_irq(adapter);\n\tif (result)\n\t\tgoto err_req_irq;\n\n\tfjes_hw_set_irqmask(hw, REG_ICTL_MASK_ALL, false);\n\n\tnetif_tx_start_all_queues(netdev);\n\tnetif_carrier_on(netdev);\n\n\treturn 0;\n\nerr_req_irq:\n\tfjes_free_irq(adapter);\n\tnapi_disable(&adapter->napi);\n\nerr_setup_res:\n\tfjes_free_resources(adapter);\n\treturn result;\n}\n\n \nstatic int fjes_close(struct net_device *netdev)\n{\n\tstruct fjes_adapter *adapter = netdev_priv(netdev);\n\tstruct fjes_hw *hw = &adapter->hw;\n\tunsigned long flags;\n\tint epidx;\n\n\tnetif_tx_stop_all_queues(netdev);\n\tnetif_carrier_off(netdev);\n\n\tfjes_hw_raise_epstop(hw);\n\n\tnapi_disable(&adapter->napi);\n\n\tspin_lock_irqsave(&hw->rx_status_lock, flags);\n\tfor (epidx = 0; epidx < hw->max_epid; epidx++) {\n\t\tif (epidx == hw->my_epid)\n\t\t\tcontinue;\n\n\t\tif (fjes_hw_get_partner_ep_status(hw, epidx) ==\n\t\t    EP_PARTNER_SHARED)\n\t\t\tadapter->hw.ep_shm_info[epidx]\n\t\t\t\t   .tx.info->v1i.rx_status &=\n\t\t\t\t~FJES_RX_POLL_WORK;\n\t}\n\tspin_unlock_irqrestore(&hw->rx_status_lock, flags);\n\n\tfjes_free_irq(adapter);\n\n\tcancel_delayed_work_sync(&adapter->interrupt_watch_task);\n\tcancel_work_sync(&adapter->unshare_watch_task);\n\tadapter->unshare_watch_bitmask = 0;\n\tcancel_work_sync(&adapter->raise_intr_rxdata_task);\n\tcancel_work_sync(&adapter->tx_stall_task);\n\n\tcancel_work_sync(&hw->update_zone_task);\n\tcancel_work_sync(&hw->epstop_task);\n\n\tfjes_hw_wait_epstop(hw);\n\n\tfjes_free_resources(adapter);\n\n\treturn 0;\n}\n\nstatic int fjes_tx_send(struct fjes_adapter *adapter, int dest,\n\t\t\tvoid *data, size_t len)\n{\n\tint retval;\n\n\tretval = fjes_hw_epbuf_tx_pkt_send(&adapter->hw.ep_shm_info[dest].tx,\n\t\t\t\t\t   data, len);\n\tif (retval)\n\t\treturn retval;\n\n\tadapter->hw.ep_shm_info[dest].tx.info->v1i.tx_status =\n\t\tFJES_TX_DELAY_SEND_PENDING;\n\tif (!work_pending(&adapter->raise_intr_rxdata_task))\n\t\tqueue_work(adapter->txrx_wq,\n\t\t\t   &adapter->raise_intr_rxdata_task);\n\n\tretval = 0;\n\treturn retval;\n}\n\nstatic netdev_tx_t\nfjes_xmit_frame(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct fjes_adapter *adapter = netdev_priv(netdev);\n\tstruct fjes_hw *hw = &adapter->hw;\n\n\tint max_epid, my_epid, dest_epid;\n\tenum ep_partner_status pstatus;\n\tstruct netdev_queue *cur_queue;\n\tchar shortpkt[VLAN_ETH_HLEN];\n\tbool is_multi, vlan;\n\tstruct ethhdr *eth;\n\tu16 queue_no = 0;\n\tu16 vlan_id = 0;\n\tnetdev_tx_t ret;\n\tchar *data;\n\tint len;\n\n\tret = NETDEV_TX_OK;\n\tis_multi = false;\n\tcur_queue = netdev_get_tx_queue(netdev, queue_no);\n\n\teth = (struct ethhdr *)skb->data;\n\tmy_epid = hw->my_epid;\n\n\tvlan = (vlan_get_tag(skb, &vlan_id) == 0) ? true : false;\n\n\tdata = skb->data;\n\tlen = skb->len;\n\n\tif (is_multicast_ether_addr(eth->h_dest)) {\n\t\tdest_epid = 0;\n\t\tmax_epid = hw->max_epid;\n\t\tis_multi = true;\n\t} else if (is_local_ether_addr(eth->h_dest)) {\n\t\tdest_epid = eth->h_dest[ETH_ALEN - 1];\n\t\tmax_epid = dest_epid + 1;\n\n\t\tif ((eth->h_dest[0] == 0x02) &&\n\t\t    (0x00 == (eth->h_dest[1] | eth->h_dest[2] |\n\t\t\t      eth->h_dest[3] | eth->h_dest[4])) &&\n\t\t    (dest_epid < hw->max_epid)) {\n\t\t\t;\n\t\t} else {\n\t\t\tdest_epid = 0;\n\t\t\tmax_epid = 0;\n\t\t\tret = NETDEV_TX_OK;\n\n\t\t\tadapter->stats64.tx_packets += 1;\n\t\t\thw->ep_shm_info[my_epid].net_stats.tx_packets += 1;\n\t\t\tadapter->stats64.tx_bytes += len;\n\t\t\thw->ep_shm_info[my_epid].net_stats.tx_bytes += len;\n\t\t}\n\t} else {\n\t\tdest_epid = 0;\n\t\tmax_epid = 0;\n\t\tret = NETDEV_TX_OK;\n\n\t\tadapter->stats64.tx_packets += 1;\n\t\thw->ep_shm_info[my_epid].net_stats.tx_packets += 1;\n\t\tadapter->stats64.tx_bytes += len;\n\t\thw->ep_shm_info[my_epid].net_stats.tx_bytes += len;\n\t}\n\n\tfor (; dest_epid < max_epid; dest_epid++) {\n\t\tif (my_epid == dest_epid)\n\t\t\tcontinue;\n\n\t\tpstatus = fjes_hw_get_partner_ep_status(hw, dest_epid);\n\t\tif (pstatus != EP_PARTNER_SHARED) {\n\t\t\tif (!is_multi)\n\t\t\t\thw->ep_shm_info[dest_epid].ep_stats\n\t\t\t\t\t.tx_dropped_not_shared += 1;\n\t\t\tret = NETDEV_TX_OK;\n\t\t} else if (!fjes_hw_check_epbuf_version(\n\t\t\t\t&adapter->hw.ep_shm_info[dest_epid].rx, 0)) {\n\t\t\t \n\t\t\tadapter->stats64.tx_carrier_errors += 1;\n\t\t\thw->ep_shm_info[dest_epid].net_stats\n\t\t\t\t\t\t.tx_carrier_errors += 1;\n\t\t\thw->ep_shm_info[dest_epid].ep_stats\n\t\t\t\t\t.tx_dropped_ver_mismatch += 1;\n\n\t\t\tret = NETDEV_TX_OK;\n\t\t} else if (!fjes_hw_check_mtu(\n\t\t\t\t&adapter->hw.ep_shm_info[dest_epid].rx,\n\t\t\t\tnetdev->mtu)) {\n\t\t\tadapter->stats64.tx_dropped += 1;\n\t\t\thw->ep_shm_info[dest_epid].net_stats.tx_dropped += 1;\n\t\t\tadapter->stats64.tx_errors += 1;\n\t\t\thw->ep_shm_info[dest_epid].net_stats.tx_errors += 1;\n\t\t\thw->ep_shm_info[dest_epid].ep_stats\n\t\t\t\t\t.tx_dropped_buf_size_mismatch += 1;\n\n\t\t\tret = NETDEV_TX_OK;\n\t\t} else if (vlan &&\n\t\t\t   !fjes_hw_check_vlan_id(\n\t\t\t\t&adapter->hw.ep_shm_info[dest_epid].rx,\n\t\t\t\tvlan_id)) {\n\t\t\thw->ep_shm_info[dest_epid].ep_stats\n\t\t\t\t.tx_dropped_vlanid_mismatch += 1;\n\t\t\tret = NETDEV_TX_OK;\n\t\t} else {\n\t\t\tif (len < VLAN_ETH_HLEN) {\n\t\t\t\tmemset(shortpkt, 0, VLAN_ETH_HLEN);\n\t\t\t\tmemcpy(shortpkt, skb->data, skb->len);\n\t\t\t\tlen = VLAN_ETH_HLEN;\n\t\t\t\tdata = shortpkt;\n\t\t\t}\n\n\t\t\tif (adapter->tx_retry_count == 0) {\n\t\t\t\tadapter->tx_start_jiffies = jiffies;\n\t\t\t\tadapter->tx_retry_count = 1;\n\t\t\t} else {\n\t\t\t\tadapter->tx_retry_count++;\n\t\t\t}\n\n\t\t\tif (fjes_tx_send(adapter, dest_epid, data, len)) {\n\t\t\t\tif (is_multi) {\n\t\t\t\t\tret = NETDEV_TX_OK;\n\t\t\t\t} else if (\n\t\t\t\t\t   ((long)jiffies -\n\t\t\t\t\t    (long)adapter->tx_start_jiffies) >=\n\t\t\t\t\t    FJES_TX_RETRY_TIMEOUT) {\n\t\t\t\t\tadapter->stats64.tx_fifo_errors += 1;\n\t\t\t\t\thw->ep_shm_info[dest_epid].net_stats\n\t\t\t\t\t\t\t\t.tx_fifo_errors += 1;\n\t\t\t\t\tadapter->stats64.tx_errors += 1;\n\t\t\t\t\thw->ep_shm_info[dest_epid].net_stats\n\t\t\t\t\t\t\t\t.tx_errors += 1;\n\n\t\t\t\t\tret = NETDEV_TX_OK;\n\t\t\t\t} else {\n\t\t\t\t\tnetif_trans_update(netdev);\n\t\t\t\t\thw->ep_shm_info[dest_epid].ep_stats\n\t\t\t\t\t\t.tx_buffer_full += 1;\n\t\t\t\t\tnetif_tx_stop_queue(cur_queue);\n\n\t\t\t\t\tif (!work_pending(&adapter->tx_stall_task))\n\t\t\t\t\t\tqueue_work(adapter->txrx_wq,\n\t\t\t\t\t\t\t   &adapter->tx_stall_task);\n\n\t\t\t\t\tret = NETDEV_TX_BUSY;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!is_multi) {\n\t\t\t\t\tadapter->stats64.tx_packets += 1;\n\t\t\t\t\thw->ep_shm_info[dest_epid].net_stats\n\t\t\t\t\t\t\t\t.tx_packets += 1;\n\t\t\t\t\tadapter->stats64.tx_bytes += len;\n\t\t\t\t\thw->ep_shm_info[dest_epid].net_stats\n\t\t\t\t\t\t\t\t.tx_bytes += len;\n\t\t\t\t}\n\n\t\t\t\tadapter->tx_retry_count = 0;\n\t\t\t\tret = NETDEV_TX_OK;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ret == NETDEV_TX_OK) {\n\t\tdev_kfree_skb(skb);\n\t\tif (is_multi) {\n\t\t\tadapter->stats64.tx_packets += 1;\n\t\t\thw->ep_shm_info[my_epid].net_stats.tx_packets += 1;\n\t\t\tadapter->stats64.tx_bytes += 1;\n\t\t\thw->ep_shm_info[my_epid].net_stats.tx_bytes += len;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void\nfjes_get_stats64(struct net_device *netdev, struct rtnl_link_stats64 *stats)\n{\n\tstruct fjes_adapter *adapter = netdev_priv(netdev);\n\n\tmemcpy(stats, &adapter->stats64, sizeof(struct rtnl_link_stats64));\n}\n\nstatic int fjes_change_mtu(struct net_device *netdev, int new_mtu)\n{\n\tstruct fjes_adapter *adapter = netdev_priv(netdev);\n\tbool running = netif_running(netdev);\n\tstruct fjes_hw *hw = &adapter->hw;\n\tunsigned long flags;\n\tint ret = -EINVAL;\n\tint idx, epidx;\n\n\tfor (idx = 0; fjes_support_mtu[idx] != 0; idx++) {\n\t\tif (new_mtu <= fjes_support_mtu[idx]) {\n\t\t\tnew_mtu = fjes_support_mtu[idx];\n\t\t\tif (new_mtu == netdev->mtu)\n\t\t\t\treturn 0;\n\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (running) {\n\t\tspin_lock_irqsave(&hw->rx_status_lock, flags);\n\t\tfor (epidx = 0; epidx < hw->max_epid; epidx++) {\n\t\t\tif (epidx == hw->my_epid)\n\t\t\t\tcontinue;\n\t\t\thw->ep_shm_info[epidx].tx.info->v1i.rx_status &=\n\t\t\t\t~FJES_RX_MTU_CHANGING_DONE;\n\t\t}\n\t\tspin_unlock_irqrestore(&hw->rx_status_lock, flags);\n\n\t\tnetif_tx_stop_all_queues(netdev);\n\t\tnetif_carrier_off(netdev);\n\t\tcancel_work_sync(&adapter->tx_stall_task);\n\t\tnapi_disable(&adapter->napi);\n\n\t\tmsleep(1000);\n\n\t\tnetif_tx_stop_all_queues(netdev);\n\t}\n\n\tnetdev->mtu = new_mtu;\n\n\tif (running) {\n\t\tfor (epidx = 0; epidx < hw->max_epid; epidx++) {\n\t\t\tif (epidx == hw->my_epid)\n\t\t\t\tcontinue;\n\n\t\t\tspin_lock_irqsave(&hw->rx_status_lock, flags);\n\t\t\tfjes_hw_setup_epbuf(&hw->ep_shm_info[epidx].tx,\n\t\t\t\t\t    netdev->dev_addr,\n\t\t\t\t\t    netdev->mtu);\n\n\t\t\thw->ep_shm_info[epidx].tx.info->v1i.rx_status |=\n\t\t\t\tFJES_RX_MTU_CHANGING_DONE;\n\t\t\tspin_unlock_irqrestore(&hw->rx_status_lock, flags);\n\t\t}\n\n\t\tnetif_tx_wake_all_queues(netdev);\n\t\tnetif_carrier_on(netdev);\n\t\tnapi_enable(&adapter->napi);\n\t\tnapi_schedule(&adapter->napi);\n\t}\n\n\treturn ret;\n}\n\nstatic void fjes_tx_retry(struct net_device *netdev, unsigned int txqueue)\n{\n\tstruct netdev_queue *queue = netdev_get_tx_queue(netdev, 0);\n\n\tnetif_tx_wake_queue(queue);\n}\n\nstatic int fjes_vlan_rx_add_vid(struct net_device *netdev,\n\t\t\t\t__be16 proto, u16 vid)\n{\n\tstruct fjes_adapter *adapter = netdev_priv(netdev);\n\tbool ret = true;\n\tint epid;\n\n\tfor (epid = 0; epid < adapter->hw.max_epid; epid++) {\n\t\tif (epid == adapter->hw.my_epid)\n\t\t\tcontinue;\n\n\t\tif (!fjes_hw_check_vlan_id(\n\t\t\t&adapter->hw.ep_shm_info[epid].tx, vid))\n\t\t\tret = fjes_hw_set_vlan_id(\n\t\t\t\t&adapter->hw.ep_shm_info[epid].tx, vid);\n\t}\n\n\treturn ret ? 0 : -ENOSPC;\n}\n\nstatic int fjes_vlan_rx_kill_vid(struct net_device *netdev,\n\t\t\t\t __be16 proto, u16 vid)\n{\n\tstruct fjes_adapter *adapter = netdev_priv(netdev);\n\tint epid;\n\n\tfor (epid = 0; epid < adapter->hw.max_epid; epid++) {\n\t\tif (epid == adapter->hw.my_epid)\n\t\t\tcontinue;\n\n\t\tfjes_hw_del_vlan_id(&adapter->hw.ep_shm_info[epid].tx, vid);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops fjes_netdev_ops = {\n\t.ndo_open\t\t= fjes_open,\n\t.ndo_stop\t\t= fjes_close,\n\t.ndo_start_xmit\t\t= fjes_xmit_frame,\n\t.ndo_get_stats64\t= fjes_get_stats64,\n\t.ndo_change_mtu\t\t= fjes_change_mtu,\n\t.ndo_tx_timeout\t\t= fjes_tx_retry,\n\t.ndo_vlan_rx_add_vid\t= fjes_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid = fjes_vlan_rx_kill_vid,\n};\n\n \nstatic void fjes_netdev_setup(struct net_device *netdev)\n{\n\tether_setup(netdev);\n\n\tnetdev->watchdog_timeo = FJES_TX_RETRY_INTERVAL;\n\tnetdev->netdev_ops = &fjes_netdev_ops;\n\tfjes_set_ethtool_ops(netdev);\n\tnetdev->mtu = fjes_support_mtu[3];\n\tnetdev->min_mtu = fjes_support_mtu[0];\n\tnetdev->max_mtu = fjes_support_mtu[3];\n\tnetdev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;\n}\n\nstatic int fjes_rxframe_search_exist(struct fjes_adapter *adapter,\n\t\t\t\t     int start_epid)\n{\n\tstruct fjes_hw *hw = &adapter->hw;\n\tenum ep_partner_status pstatus;\n\tint max_epid, cur_epid;\n\tint i;\n\n\tmax_epid = hw->max_epid;\n\tstart_epid = (start_epid + 1 + max_epid) % max_epid;\n\n\tfor (i = 0; i < max_epid; i++) {\n\t\tcur_epid = (start_epid + i) % max_epid;\n\t\tif (cur_epid == hw->my_epid)\n\t\t\tcontinue;\n\n\t\tpstatus = fjes_hw_get_partner_ep_status(hw, cur_epid);\n\t\tif (pstatus == EP_PARTNER_SHARED) {\n\t\t\tif (!fjes_hw_epbuf_rx_is_empty(\n\t\t\t\t&hw->ep_shm_info[cur_epid].rx))\n\t\t\t\treturn cur_epid;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic void *fjes_rxframe_get(struct fjes_adapter *adapter, size_t *psize,\n\t\t\t      int *cur_epid)\n{\n\tvoid *frame;\n\n\t*cur_epid = fjes_rxframe_search_exist(adapter, *cur_epid);\n\tif (*cur_epid < 0)\n\t\treturn NULL;\n\n\tframe =\n\tfjes_hw_epbuf_rx_curpkt_get_addr(\n\t\t&adapter->hw.ep_shm_info[*cur_epid].rx, psize);\n\n\treturn frame;\n}\n\nstatic void fjes_rxframe_release(struct fjes_adapter *adapter, int cur_epid)\n{\n\tfjes_hw_epbuf_rx_curpkt_drop(&adapter->hw.ep_shm_info[cur_epid].rx);\n}\n\nstatic int fjes_poll(struct napi_struct *napi, int budget)\n{\n\tstruct fjes_adapter *adapter =\n\t\t\tcontainer_of(napi, struct fjes_adapter, napi);\n\tstruct net_device *netdev = napi->dev;\n\tstruct fjes_hw *hw = &adapter->hw;\n\tstruct sk_buff *skb;\n\tint work_done = 0;\n\tint cur_epid = 0;\n\tint epidx;\n\tsize_t frame_len;\n\tvoid *frame;\n\n\tspin_lock(&hw->rx_status_lock);\n\tfor (epidx = 0; epidx < hw->max_epid; epidx++) {\n\t\tif (epidx == hw->my_epid)\n\t\t\tcontinue;\n\n\t\tif (fjes_hw_get_partner_ep_status(hw, epidx) ==\n\t\t    EP_PARTNER_SHARED)\n\t\t\tadapter->hw.ep_shm_info[epidx]\n\t\t\t\t   .tx.info->v1i.rx_status |= FJES_RX_POLL_WORK;\n\t}\n\tspin_unlock(&hw->rx_status_lock);\n\n\twhile (work_done < budget) {\n\t\tprefetch(&adapter->hw);\n\t\tframe = fjes_rxframe_get(adapter, &frame_len, &cur_epid);\n\n\t\tif (frame) {\n\t\t\tskb = napi_alloc_skb(napi, frame_len);\n\t\t\tif (!skb) {\n\t\t\t\tadapter->stats64.rx_dropped += 1;\n\t\t\t\thw->ep_shm_info[cur_epid].net_stats\n\t\t\t\t\t\t\t .rx_dropped += 1;\n\t\t\t\tadapter->stats64.rx_errors += 1;\n\t\t\t\thw->ep_shm_info[cur_epid].net_stats\n\t\t\t\t\t\t\t .rx_errors += 1;\n\t\t\t} else {\n\t\t\t\tskb_put_data(skb, frame, frame_len);\n\t\t\t\tskb->protocol = eth_type_trans(skb, netdev);\n\t\t\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\t\t\t\tnetif_receive_skb(skb);\n\n\t\t\t\twork_done++;\n\n\t\t\t\tadapter->stats64.rx_packets += 1;\n\t\t\t\thw->ep_shm_info[cur_epid].net_stats\n\t\t\t\t\t\t\t .rx_packets += 1;\n\t\t\t\tadapter->stats64.rx_bytes += frame_len;\n\t\t\t\thw->ep_shm_info[cur_epid].net_stats\n\t\t\t\t\t\t\t .rx_bytes += frame_len;\n\n\t\t\t\tif (is_multicast_ether_addr(\n\t\t\t\t\t((struct ethhdr *)frame)->h_dest)) {\n\t\t\t\t\tadapter->stats64.multicast += 1;\n\t\t\t\t\thw->ep_shm_info[cur_epid].net_stats\n\t\t\t\t\t\t\t\t .multicast += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfjes_rxframe_release(adapter, cur_epid);\n\t\t\tadapter->unset_rx_last = true;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (work_done < budget) {\n\t\tnapi_complete_done(napi, work_done);\n\n\t\tif (adapter->unset_rx_last) {\n\t\t\tadapter->rx_last_jiffies = jiffies;\n\t\t\tadapter->unset_rx_last = false;\n\t\t}\n\n\t\tif (((long)jiffies - (long)adapter->rx_last_jiffies) < 3) {\n\t\t\tnapi_reschedule(napi);\n\t\t} else {\n\t\t\tspin_lock(&hw->rx_status_lock);\n\t\t\tfor (epidx = 0; epidx < hw->max_epid; epidx++) {\n\t\t\t\tif (epidx == hw->my_epid)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (fjes_hw_get_partner_ep_status(hw, epidx) ==\n\t\t\t\t    EP_PARTNER_SHARED)\n\t\t\t\t\tadapter->hw.ep_shm_info[epidx].tx\n\t\t\t\t\t\t   .info->v1i.rx_status &=\n\t\t\t\t\t\t~FJES_RX_POLL_WORK;\n\t\t\t}\n\t\t\tspin_unlock(&hw->rx_status_lock);\n\n\t\t\tfjes_hw_set_irqmask(hw, REG_ICTL_MASK_RX_DATA, false);\n\t\t}\n\t}\n\n\treturn work_done;\n}\n\nstatic int fjes_sw_init(struct fjes_adapter *adapter)\n{\n\tstruct net_device *netdev = adapter->netdev;\n\n\tnetif_napi_add(netdev, &adapter->napi, fjes_poll);\n\n\treturn 0;\n}\n\nstatic void fjes_force_close_task(struct work_struct *work)\n{\n\tstruct fjes_adapter *adapter = container_of(work,\n\t\t\tstruct fjes_adapter, force_close_task);\n\tstruct net_device *netdev = adapter->netdev;\n\n\trtnl_lock();\n\tdev_close(netdev);\n\trtnl_unlock();\n}\n\nstatic void fjes_tx_stall_task(struct work_struct *work)\n{\n\tstruct fjes_adapter *adapter = container_of(work,\n\t\t\tstruct fjes_adapter, tx_stall_task);\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct fjes_hw *hw = &adapter->hw;\n\tint all_queue_available, sendable;\n\tenum ep_partner_status pstatus;\n\tint max_epid, my_epid, epid;\n\tunion ep_buffer_info *info;\n\tint i;\n\n\tif (((long)jiffies -\n\t\tdev_trans_start(netdev)) > FJES_TX_TX_STALL_TIMEOUT) {\n\t\tnetif_wake_queue(netdev);\n\t\treturn;\n\t}\n\n\tmy_epid = hw->my_epid;\n\tmax_epid = hw->max_epid;\n\n\tfor (i = 0; i < 5; i++) {\n\t\tall_queue_available = 1;\n\n\t\tfor (epid = 0; epid < max_epid; epid++) {\n\t\t\tif (my_epid == epid)\n\t\t\t\tcontinue;\n\n\t\t\tpstatus = fjes_hw_get_partner_ep_status(hw, epid);\n\t\t\tsendable = (pstatus == EP_PARTNER_SHARED);\n\t\t\tif (!sendable)\n\t\t\t\tcontinue;\n\n\t\t\tinfo = adapter->hw.ep_shm_info[epid].tx.info;\n\n\t\t\tif (!(info->v1i.rx_status & FJES_RX_MTU_CHANGING_DONE))\n\t\t\t\treturn;\n\n\t\t\tif (EP_RING_FULL(info->v1i.head, info->v1i.tail,\n\t\t\t\t\t info->v1i.count_max)) {\n\t\t\t\tall_queue_available = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (all_queue_available) {\n\t\t\tnetif_wake_queue(netdev);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tusleep_range(50, 100);\n\n\tqueue_work(adapter->txrx_wq, &adapter->tx_stall_task);\n}\n\nstatic void fjes_raise_intr_rxdata_task(struct work_struct *work)\n{\n\tstruct fjes_adapter *adapter = container_of(work,\n\t\t\tstruct fjes_adapter, raise_intr_rxdata_task);\n\tstruct fjes_hw *hw = &adapter->hw;\n\tenum ep_partner_status pstatus;\n\tint max_epid, my_epid, epid;\n\n\tmy_epid = hw->my_epid;\n\tmax_epid = hw->max_epid;\n\n\tfor (epid = 0; epid < max_epid; epid++)\n\t\thw->ep_shm_info[epid].tx_status_work = 0;\n\n\tfor (epid = 0; epid < max_epid; epid++) {\n\t\tif (epid == my_epid)\n\t\t\tcontinue;\n\n\t\tpstatus = fjes_hw_get_partner_ep_status(hw, epid);\n\t\tif (pstatus == EP_PARTNER_SHARED) {\n\t\t\thw->ep_shm_info[epid].tx_status_work =\n\t\t\t\thw->ep_shm_info[epid].tx.info->v1i.tx_status;\n\n\t\t\tif (hw->ep_shm_info[epid].tx_status_work ==\n\t\t\t\tFJES_TX_DELAY_SEND_PENDING) {\n\t\t\t\thw->ep_shm_info[epid].tx.info->v1i.tx_status =\n\t\t\t\t\tFJES_TX_DELAY_SEND_NONE;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (epid = 0; epid < max_epid; epid++) {\n\t\tif (epid == my_epid)\n\t\t\tcontinue;\n\n\t\tpstatus = fjes_hw_get_partner_ep_status(hw, epid);\n\t\tif ((hw->ep_shm_info[epid].tx_status_work ==\n\t\t     FJES_TX_DELAY_SEND_PENDING) &&\n\t\t    (pstatus == EP_PARTNER_SHARED) &&\n\t\t    !(hw->ep_shm_info[epid].rx.info->v1i.rx_status &\n\t\t      FJES_RX_POLL_WORK)) {\n\t\t\tfjes_hw_raise_interrupt(hw, epid,\n\t\t\t\t\t\tREG_ICTL_MASK_RX_DATA);\n\t\t\thw->ep_shm_info[epid].ep_stats.send_intr_rx += 1;\n\t\t}\n\t}\n\n\tusleep_range(500, 1000);\n}\n\nstatic void fjes_watch_unshare_task(struct work_struct *work)\n{\n\tstruct fjes_adapter *adapter =\n\tcontainer_of(work, struct fjes_adapter, unshare_watch_task);\n\n\tstruct net_device *netdev = adapter->netdev;\n\tstruct fjes_hw *hw = &adapter->hw;\n\n\tint unshare_watch, unshare_reserve;\n\tint max_epid, my_epid, epidx;\n\tint stop_req, stop_req_done;\n\tulong unshare_watch_bitmask;\n\tunsigned long flags;\n\tint wait_time = 0;\n\tint is_shared;\n\tint ret;\n\n\tmy_epid = hw->my_epid;\n\tmax_epid = hw->max_epid;\n\n\tunshare_watch_bitmask = adapter->unshare_watch_bitmask;\n\tadapter->unshare_watch_bitmask = 0;\n\n\twhile ((unshare_watch_bitmask || hw->txrx_stop_req_bit) &&\n\t       (wait_time < 3000)) {\n\t\tfor (epidx = 0; epidx < max_epid; epidx++) {\n\t\t\tif (epidx == my_epid)\n\t\t\t\tcontinue;\n\n\t\t\tis_shared = fjes_hw_epid_is_shared(hw->hw_info.share,\n\t\t\t\t\t\t\t   epidx);\n\n\t\t\tstop_req = test_bit(epidx, &hw->txrx_stop_req_bit);\n\n\t\t\tstop_req_done = hw->ep_shm_info[epidx].rx.info->v1i.rx_status &\n\t\t\t\t\tFJES_RX_STOP_REQ_DONE;\n\n\t\t\tunshare_watch = test_bit(epidx, &unshare_watch_bitmask);\n\n\t\t\tunshare_reserve = test_bit(epidx,\n\t\t\t\t\t\t   &hw->hw_info.buffer_unshare_reserve_bit);\n\n\t\t\tif ((!stop_req ||\n\t\t\t     (is_shared && (!is_shared || !stop_req_done))) &&\n\t\t\t    (is_shared || !unshare_watch || !unshare_reserve))\n\t\t\t\tcontinue;\n\n\t\t\tmutex_lock(&hw->hw_info.lock);\n\t\t\tret = fjes_hw_unregister_buff_addr(hw, epidx);\n\t\t\tswitch (ret) {\n\t\t\tcase 0:\n\t\t\t\tbreak;\n\t\t\tcase -ENOMSG:\n\t\t\tcase -EBUSY:\n\t\t\tdefault:\n\t\t\t\tif (!work_pending(\n\t\t\t\t\t&adapter->force_close_task)) {\n\t\t\t\t\tadapter->force_reset = true;\n\t\t\t\t\tschedule_work(\n\t\t\t\t\t\t&adapter->force_close_task);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmutex_unlock(&hw->hw_info.lock);\n\t\t\thw->ep_shm_info[epidx].ep_stats\n\t\t\t\t\t.com_unregist_buf_exec += 1;\n\n\t\t\tspin_lock_irqsave(&hw->rx_status_lock, flags);\n\t\t\tfjes_hw_setup_epbuf(&hw->ep_shm_info[epidx].tx,\n\t\t\t\t\t    netdev->dev_addr, netdev->mtu);\n\t\t\tspin_unlock_irqrestore(&hw->rx_status_lock, flags);\n\n\t\t\tclear_bit(epidx, &hw->txrx_stop_req_bit);\n\t\t\tclear_bit(epidx, &unshare_watch_bitmask);\n\t\t\tclear_bit(epidx,\n\t\t\t\t  &hw->hw_info.buffer_unshare_reserve_bit);\n\t\t}\n\n\t\tmsleep(100);\n\t\twait_time += 100;\n\t}\n\n\tif (hw->hw_info.buffer_unshare_reserve_bit) {\n\t\tfor (epidx = 0; epidx < max_epid; epidx++) {\n\t\t\tif (epidx == my_epid)\n\t\t\t\tcontinue;\n\n\t\t\tif (test_bit(epidx,\n\t\t\t\t     &hw->hw_info.buffer_unshare_reserve_bit)) {\n\t\t\t\tmutex_lock(&hw->hw_info.lock);\n\n\t\t\t\tret = fjes_hw_unregister_buff_addr(hw, epidx);\n\t\t\t\tswitch (ret) {\n\t\t\t\tcase 0:\n\t\t\t\t\tbreak;\n\t\t\t\tcase -ENOMSG:\n\t\t\t\tcase -EBUSY:\n\t\t\t\tdefault:\n\t\t\t\t\tif (!work_pending(\n\t\t\t\t\t\t&adapter->force_close_task)) {\n\t\t\t\t\t\tadapter->force_reset = true;\n\t\t\t\t\t\tschedule_work(\n\t\t\t\t\t\t\t&adapter->force_close_task);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmutex_unlock(&hw->hw_info.lock);\n\n\t\t\t\thw->ep_shm_info[epidx].ep_stats\n\t\t\t\t\t.com_unregist_buf_exec += 1;\n\n\t\t\t\tspin_lock_irqsave(&hw->rx_status_lock, flags);\n\t\t\t\tfjes_hw_setup_epbuf(\n\t\t\t\t\t&hw->ep_shm_info[epidx].tx,\n\t\t\t\t\tnetdev->dev_addr, netdev->mtu);\n\t\t\t\tspin_unlock_irqrestore(&hw->rx_status_lock,\n\t\t\t\t\t\t       flags);\n\n\t\t\t\tclear_bit(epidx, &hw->txrx_stop_req_bit);\n\t\t\t\tclear_bit(epidx, &unshare_watch_bitmask);\n\t\t\t\tclear_bit(epidx, &hw->hw_info.buffer_unshare_reserve_bit);\n\t\t\t}\n\n\t\t\tif (test_bit(epidx, &unshare_watch_bitmask)) {\n\t\t\t\tspin_lock_irqsave(&hw->rx_status_lock, flags);\n\t\t\t\thw->ep_shm_info[epidx].tx.info->v1i.rx_status &=\n\t\t\t\t\t\t~FJES_RX_STOP_REQ_DONE;\n\t\t\t\tspin_unlock_irqrestore(&hw->rx_status_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void fjes_irq_watch_task(struct work_struct *work)\n{\n\tstruct fjes_adapter *adapter = container_of(to_delayed_work(work),\n\t\t\tstruct fjes_adapter, interrupt_watch_task);\n\n\tlocal_irq_disable();\n\tfjes_intr(adapter->hw.hw_res.irq, adapter);\n\tlocal_irq_enable();\n\n\tif (fjes_rxframe_search_exist(adapter, 0) >= 0)\n\t\tnapi_schedule(&adapter->napi);\n\n\tif (adapter->interrupt_watch_enable) {\n\t\tif (!delayed_work_pending(&adapter->interrupt_watch_task))\n\t\t\tqueue_delayed_work(adapter->control_wq,\n\t\t\t\t\t   &adapter->interrupt_watch_task,\n\t\t\t\t\t   FJES_IRQ_WATCH_DELAY);\n\t}\n}\n\n \nstatic int fjes_probe(struct platform_device *plat_dev)\n{\n\tstruct fjes_adapter *adapter;\n\tstruct net_device *netdev;\n\tstruct resource *res;\n\tstruct fjes_hw *hw;\n\tu8 addr[ETH_ALEN];\n\tint err;\n\n\terr = -ENOMEM;\n\tnetdev = alloc_netdev_mq(sizeof(struct fjes_adapter), \"es%d\",\n\t\t\t\t NET_NAME_UNKNOWN, fjes_netdev_setup,\n\t\t\t\t FJES_MAX_QUEUES);\n\n\tif (!netdev)\n\t\tgoto err_out;\n\n\tSET_NETDEV_DEV(netdev, &plat_dev->dev);\n\n\tdev_set_drvdata(&plat_dev->dev, netdev);\n\tadapter = netdev_priv(netdev);\n\tadapter->netdev = netdev;\n\tadapter->plat_dev = plat_dev;\n\thw = &adapter->hw;\n\thw->back = adapter;\n\n\t \n\terr = fjes_sw_init(adapter);\n\tif (err)\n\t\tgoto err_free_netdev;\n\n\tINIT_WORK(&adapter->force_close_task, fjes_force_close_task);\n\tadapter->force_reset = false;\n\tadapter->open_guard = false;\n\n\tadapter->txrx_wq = alloc_workqueue(DRV_NAME \"/txrx\", WQ_MEM_RECLAIM, 0);\n\tif (unlikely(!adapter->txrx_wq)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_netdev;\n\t}\n\n\tadapter->control_wq = alloc_workqueue(DRV_NAME \"/control\",\n\t\t\t\t\t      WQ_MEM_RECLAIM, 0);\n\tif (unlikely(!adapter->control_wq)) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_txrx_wq;\n\t}\n\n\tINIT_WORK(&adapter->tx_stall_task, fjes_tx_stall_task);\n\tINIT_WORK(&adapter->raise_intr_rxdata_task,\n\t\t  fjes_raise_intr_rxdata_task);\n\tINIT_WORK(&adapter->unshare_watch_task, fjes_watch_unshare_task);\n\tadapter->unshare_watch_bitmask = 0;\n\n\tINIT_DELAYED_WORK(&adapter->interrupt_watch_task, fjes_irq_watch_task);\n\tadapter->interrupt_watch_enable = false;\n\n\tres = platform_get_resource(plat_dev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\terr = -EINVAL;\n\t\tgoto err_free_control_wq;\n\t}\n\thw->hw_res.start = res->start;\n\thw->hw_res.size = resource_size(res);\n\thw->hw_res.irq = platform_get_irq(plat_dev, 0);\n\tif (hw->hw_res.irq < 0) {\n\t\terr = hw->hw_res.irq;\n\t\tgoto err_free_control_wq;\n\t}\n\n\terr = fjes_hw_init(&adapter->hw);\n\tif (err)\n\t\tgoto err_free_control_wq;\n\n\t \n\taddr[0] = 2;\n\taddr[1] = 0;\n\taddr[2] = 0;\n\taddr[3] = 0;\n\taddr[4] = 0;\n\taddr[5] = hw->my_epid;  \n\teth_hw_addr_set(netdev, addr);\n\n\terr = register_netdev(netdev);\n\tif (err)\n\t\tgoto err_hw_exit;\n\n\tnetif_carrier_off(netdev);\n\n\tfjes_dbg_adapter_init(adapter);\n\n\treturn 0;\n\nerr_hw_exit:\n\tfjes_hw_exit(&adapter->hw);\nerr_free_control_wq:\n\tdestroy_workqueue(adapter->control_wq);\nerr_free_txrx_wq:\n\tdestroy_workqueue(adapter->txrx_wq);\nerr_free_netdev:\n\tfree_netdev(netdev);\nerr_out:\n\treturn err;\n}\n\n \nstatic int fjes_remove(struct platform_device *plat_dev)\n{\n\tstruct net_device *netdev = dev_get_drvdata(&plat_dev->dev);\n\tstruct fjes_adapter *adapter = netdev_priv(netdev);\n\tstruct fjes_hw *hw = &adapter->hw;\n\n\tfjes_dbg_adapter_exit(adapter);\n\n\tcancel_delayed_work_sync(&adapter->interrupt_watch_task);\n\tcancel_work_sync(&adapter->unshare_watch_task);\n\tcancel_work_sync(&adapter->raise_intr_rxdata_task);\n\tcancel_work_sync(&adapter->tx_stall_task);\n\tif (adapter->control_wq)\n\t\tdestroy_workqueue(adapter->control_wq);\n\tif (adapter->txrx_wq)\n\t\tdestroy_workqueue(adapter->txrx_wq);\n\n\tunregister_netdev(netdev);\n\n\tfjes_hw_exit(hw);\n\n\tnetif_napi_del(&adapter->napi);\n\n\tfree_netdev(netdev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver fjes_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t},\n\t.probe = fjes_probe,\n\t.remove = fjes_remove,\n};\n\nstatic acpi_status\nacpi_find_extended_socket_device(acpi_handle obj_handle, u32 level,\n\t\t\t\t void *context, void **return_value)\n{\n\tstruct acpi_device *device;\n\tbool *found = context;\n\n\tdevice = acpi_fetch_acpi_dev(obj_handle);\n\tif (!device)\n\t\treturn AE_OK;\n\n\tif (strcmp(acpi_device_hid(device), ACPI_MOTHERBOARD_RESOURCE_HID))\n\t\treturn AE_OK;\n\n\tif (!is_extended_socket_device(device))\n\t\treturn AE_OK;\n\n\tif (acpi_check_extended_socket_status(device))\n\t\treturn AE_OK;\n\n\t*found = true;\n\treturn AE_CTRL_TERMINATE;\n}\n\n \nstatic int __init fjes_init_module(void)\n{\n\tbool found = false;\n\tint result;\n\n\tacpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX,\n\t\t\t    acpi_find_extended_socket_device, NULL, &found,\n\t\t\t    NULL);\n\n\tif (!found)\n\t\treturn -ENODEV;\n\n\tpr_info(\"%s - version %s - %s\\n\",\n\t\tfjes_driver_string, fjes_driver_version, fjes_copyright);\n\n\tfjes_dbg_init();\n\n\tresult = platform_driver_register(&fjes_driver);\n\tif (result < 0) {\n\t\tfjes_dbg_exit();\n\t\treturn result;\n\t}\n\n\tresult = acpi_bus_register_driver(&fjes_acpi_driver);\n\tif (result < 0)\n\t\tgoto fail_acpi_driver;\n\n\treturn 0;\n\nfail_acpi_driver:\n\tplatform_driver_unregister(&fjes_driver);\n\tfjes_dbg_exit();\n\treturn result;\n}\n\nmodule_init(fjes_init_module);\n\n \nstatic void __exit fjes_exit_module(void)\n{\n\tacpi_bus_unregister_driver(&fjes_acpi_driver);\n\tplatform_driver_unregister(&fjes_driver);\n\tfjes_dbg_exit();\n}\n\nmodule_exit(fjes_exit_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}