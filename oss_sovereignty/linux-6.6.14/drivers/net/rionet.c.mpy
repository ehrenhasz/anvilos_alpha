{
  "module_name": "rionet.c",
  "hash_id": "e957ee0660009ca336197f953a511a1b8588b1cb95e983d00dacbe2ac1c36ad6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/rionet.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/rio.h>\n#include <linux/rio_drv.h>\n#include <linux/slab.h>\n#include <linux/rio_ids.h>\n\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/crc32.h>\n#include <linux/ethtool.h>\n#include <linux/reboot.h>\n\n#define DRV_NAME        \"rionet\"\n#define DRV_VERSION     \"0.3\"\n#define DRV_AUTHOR      \"Matt Porter <mporter@kernel.crashing.org>\"\n#define DRV_DESC        \"Ethernet over RapidIO\"\n\nMODULE_AUTHOR(DRV_AUTHOR);\nMODULE_DESCRIPTION(DRV_DESC);\nMODULE_LICENSE(\"GPL\");\n\n#define RIONET_DEFAULT_MSGLEVEL \\\n\t\t\t(NETIF_MSG_DRV          | \\\n\t\t\t NETIF_MSG_LINK         | \\\n\t\t\t NETIF_MSG_RX_ERR       | \\\n\t\t\t NETIF_MSG_TX_ERR)\n\n#define RIONET_DOORBELL_JOIN\t0x1000\n#define RIONET_DOORBELL_LEAVE\t0x1001\n\n#define RIONET_MAILBOX\t\t0\n\n#define RIONET_TX_RING_SIZE\tCONFIG_RIONET_TX_SIZE\n#define RIONET_RX_RING_SIZE\tCONFIG_RIONET_RX_SIZE\n#define RIONET_MAX_NETS\t\t8\n#define RIONET_MSG_SIZE         RIO_MAX_MSG_SIZE\n#define RIONET_MAX_MTU          (RIONET_MSG_SIZE - ETH_HLEN)\n\nstruct rionet_private {\n\tstruct rio_mport *mport;\n\tstruct sk_buff *rx_skb[RIONET_RX_RING_SIZE];\n\tstruct sk_buff *tx_skb[RIONET_TX_RING_SIZE];\n\tint rx_slot;\n\tint tx_slot;\n\tint tx_cnt;\n\tint ack_slot;\n\tspinlock_t lock;\n\tspinlock_t tx_lock;\n\tu32 msg_enable;\n\tbool open;\n};\n\nstruct rionet_peer {\n\tstruct list_head node;\n\tstruct rio_dev *rdev;\n\tstruct resource *res;\n};\n\nstruct rionet_net {\n\tstruct net_device *ndev;\n\tstruct list_head peers;\n\tspinlock_t lock;\t \n\tstruct rio_dev **active;\n\tint nact;\t \n};\n\nstatic struct rionet_net nets[RIONET_MAX_NETS];\n\n#define is_rionet_capable(src_ops, dst_ops)\t\t\t\\\n\t\t\t((src_ops & RIO_SRC_OPS_DATA_MSG) &&\t\\\n\t\t\t (dst_ops & RIO_DST_OPS_DATA_MSG) &&\t\\\n\t\t\t (src_ops & RIO_SRC_OPS_DOORBELL) &&\t\\\n\t\t\t (dst_ops & RIO_DST_OPS_DOORBELL))\n#define dev_rionet_capable(dev) \\\n\tis_rionet_capable(dev->src_ops, dev->dst_ops)\n\n#define RIONET_MAC_MATCH(x)\t(!memcmp((x), \"\\00\\01\\00\\01\", 4))\n#define RIONET_GET_DESTID(x)\t((*((u8 *)x + 4) << 8) | *((u8 *)x + 5))\n\nstatic int rionet_rx_clean(struct net_device *ndev)\n{\n\tint i;\n\tint error = 0;\n\tstruct rionet_private *rnet = netdev_priv(ndev);\n\tvoid *data;\n\n\ti = rnet->rx_slot;\n\n\tdo {\n\t\tif (!rnet->rx_skb[i])\n\t\t\tcontinue;\n\n\t\tif (!(data = rio_get_inb_message(rnet->mport, RIONET_MAILBOX)))\n\t\t\tbreak;\n\n\t\trnet->rx_skb[i]->data = data;\n\t\tskb_put(rnet->rx_skb[i], RIO_MAX_MSG_SIZE);\n\t\trnet->rx_skb[i]->protocol =\n\t\t    eth_type_trans(rnet->rx_skb[i], ndev);\n\t\terror = __netif_rx(rnet->rx_skb[i]);\n\n\t\tif (error == NET_RX_DROP) {\n\t\t\tndev->stats.rx_dropped++;\n\t\t} else {\n\t\t\tndev->stats.rx_packets++;\n\t\t\tndev->stats.rx_bytes += RIO_MAX_MSG_SIZE;\n\t\t}\n\n\t} while ((i = (i + 1) % RIONET_RX_RING_SIZE) != rnet->rx_slot);\n\n\treturn i;\n}\n\nstatic void rionet_rx_fill(struct net_device *ndev, int end)\n{\n\tint i;\n\tstruct rionet_private *rnet = netdev_priv(ndev);\n\n\ti = rnet->rx_slot;\n\tdo {\n\t\trnet->rx_skb[i] = dev_alloc_skb(RIO_MAX_MSG_SIZE);\n\n\t\tif (!rnet->rx_skb[i])\n\t\t\tbreak;\n\n\t\trio_add_inb_buffer(rnet->mport, RIONET_MAILBOX,\n\t\t\t\t   rnet->rx_skb[i]->data);\n\t} while ((i = (i + 1) % RIONET_RX_RING_SIZE) != end);\n\n\trnet->rx_slot = i;\n}\n\nstatic int rionet_queue_tx_msg(struct sk_buff *skb, struct net_device *ndev,\n\t\t\t       struct rio_dev *rdev)\n{\n\tstruct rionet_private *rnet = netdev_priv(ndev);\n\n\trio_add_outb_message(rnet->mport, rdev, 0, skb->data, skb->len);\n\trnet->tx_skb[rnet->tx_slot] = skb;\n\n\tndev->stats.tx_packets++;\n\tndev->stats.tx_bytes += skb->len;\n\n\tif (++rnet->tx_cnt == RIONET_TX_RING_SIZE)\n\t\tnetif_stop_queue(ndev);\n\n\t++rnet->tx_slot;\n\trnet->tx_slot &= (RIONET_TX_RING_SIZE - 1);\n\n\tif (netif_msg_tx_queued(rnet))\n\t\tprintk(KERN_INFO \"%s: queued skb len %8.8x\\n\", DRV_NAME,\n\t\t       skb->len);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t rionet_start_xmit(struct sk_buff *skb,\n\t\t\t\t     struct net_device *ndev)\n{\n\tint i;\n\tstruct rionet_private *rnet = netdev_priv(ndev);\n\tstruct ethhdr *eth = (struct ethhdr *)skb->data;\n\tu16 destid;\n\tunsigned long flags;\n\tint add_num = 1;\n\n\tspin_lock_irqsave(&rnet->tx_lock, flags);\n\n\tif (is_multicast_ether_addr(eth->h_dest))\n\t\tadd_num = nets[rnet->mport->id].nact;\n\n\tif ((rnet->tx_cnt + add_num) > RIONET_TX_RING_SIZE) {\n\t\tnetif_stop_queue(ndev);\n\t\tspin_unlock_irqrestore(&rnet->tx_lock, flags);\n\t\tprintk(KERN_ERR \"%s: BUG! Tx Ring full when queue awake!\\n\",\n\t\t       ndev->name);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tif (is_multicast_ether_addr(eth->h_dest)) {\n\t\tint count = 0;\n\n\t\tfor (i = 0; i < RIO_MAX_ROUTE_ENTRIES(rnet->mport->sys_size);\n\t\t\t\ti++)\n\t\t\tif (nets[rnet->mport->id].active[i]) {\n\t\t\t\trionet_queue_tx_msg(skb, ndev,\n\t\t\t\t\tnets[rnet->mport->id].active[i]);\n\t\t\t\tif (count)\n\t\t\t\t\trefcount_inc(&skb->users);\n\t\t\t\tcount++;\n\t\t\t}\n\t} else if (RIONET_MAC_MATCH(eth->h_dest)) {\n\t\tdestid = RIONET_GET_DESTID(eth->h_dest);\n\t\tif (nets[rnet->mport->id].active[destid])\n\t\t\trionet_queue_tx_msg(skb, ndev,\n\t\t\t\t\tnets[rnet->mport->id].active[destid]);\n\t\telse {\n\t\t\t \n\t\t\tndev->stats.tx_packets++;\n\t\t\tndev->stats.tx_bytes += skb->len;\n\t\t\tdev_kfree_skb_any(skb);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&rnet->tx_lock, flags);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void rionet_dbell_event(struct rio_mport *mport, void *dev_id, u16 sid, u16 tid,\n\t\t\t       u16 info)\n{\n\tstruct net_device *ndev = dev_id;\n\tstruct rionet_private *rnet = netdev_priv(ndev);\n\tstruct rionet_peer *peer;\n\tunsigned char netid = rnet->mport->id;\n\n\tif (netif_msg_intr(rnet))\n\t\tprintk(KERN_INFO \"%s: doorbell sid %4.4x tid %4.4x info %4.4x\",\n\t\t       DRV_NAME, sid, tid, info);\n\tif (info == RIONET_DOORBELL_JOIN) {\n\t\tif (!nets[netid].active[sid]) {\n\t\t\tspin_lock(&nets[netid].lock);\n\t\t\tlist_for_each_entry(peer, &nets[netid].peers, node) {\n\t\t\t\tif (peer->rdev->destid == sid) {\n\t\t\t\t\tnets[netid].active[sid] = peer->rdev;\n\t\t\t\t\tnets[netid].nact++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&nets[netid].lock);\n\n\t\t\trio_mport_send_doorbell(mport, sid,\n\t\t\t\t\t\tRIONET_DOORBELL_JOIN);\n\t\t}\n\t} else if (info == RIONET_DOORBELL_LEAVE) {\n\t\tspin_lock(&nets[netid].lock);\n\t\tif (nets[netid].active[sid]) {\n\t\t\tnets[netid].active[sid] = NULL;\n\t\t\tnets[netid].nact--;\n\t\t}\n\t\tspin_unlock(&nets[netid].lock);\n\t} else {\n\t\tif (netif_msg_intr(rnet))\n\t\t\tprintk(KERN_WARNING \"%s: unhandled doorbell\\n\",\n\t\t\t       DRV_NAME);\n\t}\n}\n\nstatic void rionet_inb_msg_event(struct rio_mport *mport, void *dev_id, int mbox, int slot)\n{\n\tint n;\n\tstruct net_device *ndev = dev_id;\n\tstruct rionet_private *rnet = netdev_priv(ndev);\n\n\tif (netif_msg_intr(rnet))\n\t\tprintk(KERN_INFO \"%s: inbound message event, mbox %d slot %d\\n\",\n\t\t       DRV_NAME, mbox, slot);\n\n\tspin_lock(&rnet->lock);\n\tif ((n = rionet_rx_clean(ndev)) != rnet->rx_slot)\n\t\trionet_rx_fill(ndev, n);\n\tspin_unlock(&rnet->lock);\n}\n\nstatic void rionet_outb_msg_event(struct rio_mport *mport, void *dev_id, int mbox, int slot)\n{\n\tstruct net_device *ndev = dev_id;\n\tstruct rionet_private *rnet = netdev_priv(ndev);\n\n\tspin_lock(&rnet->tx_lock);\n\n\tif (netif_msg_intr(rnet))\n\t\tprintk(KERN_INFO\n\t\t       \"%s: outbound message event, mbox %d slot %d\\n\",\n\t\t       DRV_NAME, mbox, slot);\n\n\twhile (rnet->tx_cnt && (rnet->ack_slot != slot)) {\n\t\t \n\t\tdev_kfree_skb_irq(rnet->tx_skb[rnet->ack_slot]);\n\t\trnet->tx_skb[rnet->ack_slot] = NULL;\n\t\t++rnet->ack_slot;\n\t\trnet->ack_slot &= (RIONET_TX_RING_SIZE - 1);\n\t\trnet->tx_cnt--;\n\t}\n\n\tif (rnet->tx_cnt < RIONET_TX_RING_SIZE)\n\t\tnetif_wake_queue(ndev);\n\n\tspin_unlock(&rnet->tx_lock);\n}\n\nstatic int rionet_open(struct net_device *ndev)\n{\n\tint i, rc = 0;\n\tstruct rionet_peer *peer;\n\tstruct rionet_private *rnet = netdev_priv(ndev);\n\tunsigned char netid = rnet->mport->id;\n\tunsigned long flags;\n\n\tif (netif_msg_ifup(rnet))\n\t\tprintk(KERN_INFO \"%s: open\\n\", DRV_NAME);\n\n\tif ((rc = rio_request_inb_dbell(rnet->mport,\n\t\t\t\t\t(void *)ndev,\n\t\t\t\t\tRIONET_DOORBELL_JOIN,\n\t\t\t\t\tRIONET_DOORBELL_LEAVE,\n\t\t\t\t\trionet_dbell_event)) < 0)\n\t\tgoto out;\n\n\tif ((rc = rio_request_inb_mbox(rnet->mport,\n\t\t\t\t       (void *)ndev,\n\t\t\t\t       RIONET_MAILBOX,\n\t\t\t\t       RIONET_RX_RING_SIZE,\n\t\t\t\t       rionet_inb_msg_event)) < 0)\n\t\tgoto out;\n\n\tif ((rc = rio_request_outb_mbox(rnet->mport,\n\t\t\t\t\t(void *)ndev,\n\t\t\t\t\tRIONET_MAILBOX,\n\t\t\t\t\tRIONET_TX_RING_SIZE,\n\t\t\t\t\trionet_outb_msg_event)) < 0)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < RIONET_RX_RING_SIZE; i++)\n\t\trnet->rx_skb[i] = NULL;\n\trnet->rx_slot = 0;\n\trionet_rx_fill(ndev, 0);\n\n\trnet->tx_slot = 0;\n\trnet->tx_cnt = 0;\n\trnet->ack_slot = 0;\n\n\tnetif_carrier_on(ndev);\n\tnetif_start_queue(ndev);\n\n\tspin_lock_irqsave(&nets[netid].lock, flags);\n\tlist_for_each_entry(peer, &nets[netid].peers, node) {\n\t\t \n\t\trio_send_doorbell(peer->rdev, RIONET_DOORBELL_JOIN);\n\t}\n\tspin_unlock_irqrestore(&nets[netid].lock, flags);\n\trnet->open = true;\n\n      out:\n\treturn rc;\n}\n\nstatic int rionet_close(struct net_device *ndev)\n{\n\tstruct rionet_private *rnet = netdev_priv(ndev);\n\tstruct rionet_peer *peer;\n\tunsigned char netid = rnet->mport->id;\n\tunsigned long flags;\n\tint i;\n\n\tif (netif_msg_ifup(rnet))\n\t\tprintk(KERN_INFO \"%s: close %s\\n\", DRV_NAME, ndev->name);\n\n\tnetif_stop_queue(ndev);\n\tnetif_carrier_off(ndev);\n\trnet->open = false;\n\n\tfor (i = 0; i < RIONET_RX_RING_SIZE; i++)\n\t\tkfree_skb(rnet->rx_skb[i]);\n\n\tspin_lock_irqsave(&nets[netid].lock, flags);\n\tlist_for_each_entry(peer, &nets[netid].peers, node) {\n\t\tif (nets[netid].active[peer->rdev->destid]) {\n\t\t\trio_send_doorbell(peer->rdev, RIONET_DOORBELL_LEAVE);\n\t\t\tnets[netid].active[peer->rdev->destid] = NULL;\n\t\t}\n\t\tif (peer->res)\n\t\t\trio_release_outb_dbell(peer->rdev, peer->res);\n\t}\n\tspin_unlock_irqrestore(&nets[netid].lock, flags);\n\n\trio_release_inb_dbell(rnet->mport, RIONET_DOORBELL_JOIN,\n\t\t\t      RIONET_DOORBELL_LEAVE);\n\trio_release_inb_mbox(rnet->mport, RIONET_MAILBOX);\n\trio_release_outb_mbox(rnet->mport, RIONET_MAILBOX);\n\n\treturn 0;\n}\n\nstatic void rionet_remove_dev(struct device *dev, struct subsys_interface *sif)\n{\n\tstruct rio_dev *rdev = to_rio_dev(dev);\n\tunsigned char netid = rdev->net->hport->id;\n\tstruct rionet_peer *peer;\n\tint state, found = 0;\n\tunsigned long flags;\n\n\tif (!dev_rionet_capable(rdev))\n\t\treturn;\n\n\tspin_lock_irqsave(&nets[netid].lock, flags);\n\tlist_for_each_entry(peer, &nets[netid].peers, node) {\n\t\tif (peer->rdev == rdev) {\n\t\t\tlist_del(&peer->node);\n\t\t\tif (nets[netid].active[rdev->destid]) {\n\t\t\t\tstate = atomic_read(&rdev->state);\n\t\t\t\tif (state != RIO_DEVICE_GONE &&\n\t\t\t\t    state != RIO_DEVICE_INITIALIZING) {\n\t\t\t\t\trio_send_doorbell(rdev,\n\t\t\t\t\t\t\tRIONET_DOORBELL_LEAVE);\n\t\t\t\t}\n\t\t\t\tnets[netid].active[rdev->destid] = NULL;\n\t\t\t\tnets[netid].nact--;\n\t\t\t}\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&nets[netid].lock, flags);\n\n\tif (found) {\n\t\tif (peer->res)\n\t\t\trio_release_outb_dbell(rdev, peer->res);\n\t\tkfree(peer);\n\t}\n}\n\nstatic void rionet_get_drvinfo(struct net_device *ndev,\n\t\t\t       struct ethtool_drvinfo *info)\n{\n\tstruct rionet_private *rnet = netdev_priv(ndev);\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n\tstrscpy(info->fw_version, \"n/a\", sizeof(info->fw_version));\n\tstrscpy(info->bus_info, rnet->mport->name, sizeof(info->bus_info));\n}\n\nstatic u32 rionet_get_msglevel(struct net_device *ndev)\n{\n\tstruct rionet_private *rnet = netdev_priv(ndev);\n\n\treturn rnet->msg_enable;\n}\n\nstatic void rionet_set_msglevel(struct net_device *ndev, u32 value)\n{\n\tstruct rionet_private *rnet = netdev_priv(ndev);\n\n\trnet->msg_enable = value;\n}\n\nstatic const struct ethtool_ops rionet_ethtool_ops = {\n\t.get_drvinfo = rionet_get_drvinfo,\n\t.get_msglevel = rionet_get_msglevel,\n\t.set_msglevel = rionet_set_msglevel,\n\t.get_link = ethtool_op_get_link,\n};\n\nstatic const struct net_device_ops rionet_netdev_ops = {\n\t.ndo_open\t\t= rionet_open,\n\t.ndo_stop\t\t= rionet_close,\n\t.ndo_start_xmit\t\t= rionet_start_xmit,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n};\n\nstatic int rionet_setup_netdev(struct rio_mport *mport, struct net_device *ndev)\n{\n\tint rc = 0;\n\tstruct rionet_private *rnet;\n\tu8 addr[ETH_ALEN];\n\tu16 device_id;\n\tconst size_t rionet_active_bytes = sizeof(void *) *\n\t\t\t\tRIO_MAX_ROUTE_ENTRIES(mport->sys_size);\n\n\tnets[mport->id].active = (struct rio_dev **)__get_free_pages(GFP_KERNEL,\n\t\t\t\t\t\tget_order(rionet_active_bytes));\n\tif (!nets[mport->id].active) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemset((void *)nets[mport->id].active, 0, rionet_active_bytes);\n\n\t \n\trnet = netdev_priv(ndev);\n\trnet->mport = mport;\n\trnet->open = false;\n\n\t \n\tdevice_id = rio_local_get_device_id(mport);\n\taddr[0] = 0x00;\n\taddr[1] = 0x01;\n\taddr[2] = 0x00;\n\taddr[3] = 0x01;\n\taddr[4] = device_id >> 8;\n\taddr[5] = device_id & 0xff;\n\teth_hw_addr_set(ndev, addr);\n\n\tndev->netdev_ops = &rionet_netdev_ops;\n\tndev->mtu = RIONET_MAX_MTU;\n\t \n\tndev->min_mtu = ETH_MIN_MTU;\n\tndev->max_mtu = RIONET_MAX_MTU;\n\tndev->features = NETIF_F_LLTX;\n\tSET_NETDEV_DEV(ndev, &mport->dev);\n\tndev->ethtool_ops = &rionet_ethtool_ops;\n\n\tspin_lock_init(&rnet->lock);\n\tspin_lock_init(&rnet->tx_lock);\n\n\trnet->msg_enable = RIONET_DEFAULT_MSGLEVEL;\n\n\trc = register_netdev(ndev);\n\tif (rc != 0) {\n\t\tfree_pages((unsigned long)nets[mport->id].active,\n\t\t\t   get_order(rionet_active_bytes));\n\t\tgoto out;\n\t}\n\n\tprintk(KERN_INFO \"%s: %s %s Version %s, MAC %pM, %s\\n\",\n\t       ndev->name,\n\t       DRV_NAME,\n\t       DRV_DESC,\n\t       DRV_VERSION,\n\t       ndev->dev_addr,\n\t       mport->name);\n\n      out:\n\treturn rc;\n}\n\nstatic int rionet_add_dev(struct device *dev, struct subsys_interface *sif)\n{\n\tint rc = -ENODEV;\n\tu32 lsrc_ops, ldst_ops;\n\tstruct rionet_peer *peer;\n\tstruct net_device *ndev = NULL;\n\tstruct rio_dev *rdev = to_rio_dev(dev);\n\tunsigned char netid = rdev->net->hport->id;\n\n\tif (netid >= RIONET_MAX_NETS)\n\t\treturn rc;\n\n\t \n\tif (!nets[netid].ndev) {\n\t\trio_local_read_config_32(rdev->net->hport, RIO_SRC_OPS_CAR,\n\t\t\t\t\t &lsrc_ops);\n\t\trio_local_read_config_32(rdev->net->hport, RIO_DST_OPS_CAR,\n\t\t\t\t\t &ldst_ops);\n\t\tif (!is_rionet_capable(lsrc_ops, ldst_ops)) {\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"%s: local device %s is not network capable\\n\",\n\t\t\t       DRV_NAME, rdev->net->hport->name);\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tndev = alloc_etherdev(sizeof(struct rionet_private));\n\t\tif (ndev == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\trc = rionet_setup_netdev(rdev->net->hport, ndev);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: failed to setup netdev (rc=%d)\\n\",\n\t\t\t       DRV_NAME, rc);\n\t\t\tfree_netdev(ndev);\n\t\t\tgoto out;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&nets[netid].peers);\n\t\tspin_lock_init(&nets[netid].lock);\n\t\tnets[netid].nact = 0;\n\t\tnets[netid].ndev = ndev;\n\t}\n\n\t \n\tif (dev_rionet_capable(rdev)) {\n\t\tstruct rionet_private *rnet;\n\t\tunsigned long flags;\n\n\t\trnet = netdev_priv(nets[netid].ndev);\n\n\t\tpeer = kzalloc(sizeof(*peer), GFP_KERNEL);\n\t\tif (!peer) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tpeer->rdev = rdev;\n\t\tpeer->res = rio_request_outb_dbell(peer->rdev,\n\t\t\t\t\t\tRIONET_DOORBELL_JOIN,\n\t\t\t\t\t\tRIONET_DOORBELL_LEAVE);\n\t\tif (!peer->res) {\n\t\t\tpr_err(\"%s: error requesting doorbells\\n\", DRV_NAME);\n\t\t\tkfree(peer);\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tspin_lock_irqsave(&nets[netid].lock, flags);\n\t\tlist_add_tail(&peer->node, &nets[netid].peers);\n\t\tspin_unlock_irqrestore(&nets[netid].lock, flags);\n\t\tpr_debug(\"%s: %s add peer %s\\n\",\n\t\t\t DRV_NAME, __func__, rio_name(rdev));\n\n\t\t \n\t\tif (rnet->open)\n\t\t\trio_send_doorbell(peer->rdev, RIONET_DOORBELL_JOIN);\n\t}\n\n\treturn 0;\nout:\n\treturn rc;\n}\n\nstatic int rionet_shutdown(struct notifier_block *nb, unsigned long code,\n\t\t\t   void *unused)\n{\n\tstruct rionet_peer *peer;\n\tunsigned long flags;\n\tint i;\n\n\tpr_debug(\"%s: %s\\n\", DRV_NAME, __func__);\n\n\tfor (i = 0; i < RIONET_MAX_NETS; i++) {\n\t\tif (!nets[i].ndev)\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&nets[i].lock, flags);\n\t\tlist_for_each_entry(peer, &nets[i].peers, node) {\n\t\t\tif (nets[i].active[peer->rdev->destid]) {\n\t\t\t\trio_send_doorbell(peer->rdev,\n\t\t\t\t\t\t  RIONET_DOORBELL_LEAVE);\n\t\t\t\tnets[i].active[peer->rdev->destid] = NULL;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irqrestore(&nets[i].lock, flags);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic void rionet_remove_mport(struct device *dev)\n{\n\tstruct rio_mport *mport = to_rio_mport(dev);\n\tstruct net_device *ndev;\n\tint id = mport->id;\n\n\tpr_debug(\"%s %s\\n\", __func__, mport->name);\n\n\tWARN(nets[id].nact, \"%s called when connected to %d peers\\n\",\n\t     __func__, nets[id].nact);\n\tWARN(!nets[id].ndev, \"%s called for mport without NDEV\\n\",\n\t     __func__);\n\n\tif (nets[id].ndev) {\n\t\tndev = nets[id].ndev;\n\t\tnetif_stop_queue(ndev);\n\t\tunregister_netdev(ndev);\n\n\t\tfree_pages((unsigned long)nets[id].active,\n\t\t\t   get_order(sizeof(void *) *\n\t\t\t   RIO_MAX_ROUTE_ENTRIES(mport->sys_size)));\n\t\tnets[id].active = NULL;\n\t\tfree_netdev(ndev);\n\t\tnets[id].ndev = NULL;\n\t}\n}\n\n#ifdef MODULE\nstatic struct rio_device_id rionet_id_table[] = {\n\t{RIO_DEVICE(RIO_ANY_ID, RIO_ANY_ID)},\n\t{ 0, }\t \n};\n\nMODULE_DEVICE_TABLE(rapidio, rionet_id_table);\n#endif\n\nstatic struct subsys_interface rionet_interface = {\n\t.name\t\t= \"rionet\",\n\t.subsys\t\t= &rio_bus_type,\n\t.add_dev\t= rionet_add_dev,\n\t.remove_dev\t= rionet_remove_dev,\n};\n\nstatic struct notifier_block rionet_notifier = {\n\t.notifier_call = rionet_shutdown,\n};\n\n \nstatic struct class_interface rio_mport_interface __refdata = {\n\t.class = &rio_mport_class,\n\t.add_dev = NULL,\n\t.remove_dev = rionet_remove_mport,\n};\n\nstatic int __init rionet_init(void)\n{\n\tint ret;\n\n\tret = register_reboot_notifier(&rionet_notifier);\n\tif (ret) {\n\t\tpr_err(\"%s: failed to register reboot notifier (err=%d)\\n\",\n\t\t       DRV_NAME, ret);\n\t\treturn ret;\n\t}\n\n\tret = class_interface_register(&rio_mport_interface);\n\tif (ret) {\n\t\tpr_err(\"%s: class_interface_register error: %d\\n\",\n\t\t       DRV_NAME, ret);\n\t\treturn ret;\n\t}\n\n\treturn subsys_interface_register(&rionet_interface);\n}\n\nstatic void __exit rionet_exit(void)\n{\n\tunregister_reboot_notifier(&rionet_notifier);\n\tsubsys_interface_unregister(&rionet_interface);\n\tclass_interface_unregister(&rio_mport_interface);\n}\n\nlate_initcall(rionet_init);\nmodule_exit(rionet_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}