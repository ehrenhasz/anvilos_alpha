{
  "module_name": "defza.c",
  "hash_id": "977c14f0446f8c3323337d5b5d04987b10777daf9e17e282aceceaf6f250d0a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/fddi/defza.c",
  "human_readable_source": "\n \n\n \n \n\n \n#define FZA_RING_TX_MODE 0\n\n \n#define FZA_RING_RX_SIZE 256\n\n \n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/fddidevice.h>\n#include <linux/sched.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/stat.h>\n#include <linux/tc.h>\n#include <linux/timer.h>\n#include <linux/types.h>\n#include <linux/wait.h>\n\n#include <asm/barrier.h>\n\n#include \"defza.h\"\n\n#define DRV_NAME \"defza\"\n#define DRV_VERSION \"v.1.1.4\"\n#define DRV_RELDATE \"Oct  6 2018\"\n\nstatic const char version[] =\n\tDRV_NAME \": \" DRV_VERSION \"  \" DRV_RELDATE \"  Maciej W. Rozycki\\n\";\n\nMODULE_AUTHOR(\"Maciej W. Rozycki <macro@orcam.me.uk>\");\nMODULE_DESCRIPTION(\"DEC FDDIcontroller 700 (DEFZA-xx) driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int loopback;\nmodule_param(loopback, int, 0644);\n\n \nstatic u8 hw_addr_purger[8] = { 0x09, 0x00, 0x2b, 0x02, 0x01, 0x05 };\n \nstatic u8 hw_addr_beacon[8] = { 0x01, 0x80, 0xc2, 0x00, 0x01, 0x00 };\n\n \n#define readw_o readw_relaxed\n#define readl_o readl_relaxed\n\n#define writew_o writew_relaxed\n#define writel_o writel_relaxed\n\n \n#define readw_u readw_relaxed\n#define readl_u readl_relaxed\n#define readq_u readq_relaxed\n\n#define writew_u writew_relaxed\n#define writel_u writel_relaxed\n#define writeq_u writeq_relaxed\n\nstatic inline struct sk_buff *fza_alloc_skb_irq(struct net_device *dev,\n\t\t\t\t\t\tunsigned int length)\n{\n\treturn __netdev_alloc_skb(dev, length, GFP_ATOMIC);\n}\n\nstatic inline struct sk_buff *fza_alloc_skb(struct net_device *dev,\n\t\t\t\t\t    unsigned int length)\n{\n\treturn __netdev_alloc_skb(dev, length, GFP_KERNEL);\n}\n\nstatic inline void fza_skb_align(struct sk_buff *skb, unsigned int v)\n{\n\tunsigned long x, y;\n\n\tx = (unsigned long)skb->data;\n\ty = ALIGN(x, v);\n\n\tskb_reserve(skb, y - x);\n}\n\nstatic inline void fza_reads(const void __iomem *from, void *to,\n\t\t\t     unsigned long size)\n{\n\tif (sizeof(unsigned long) == 8) {\n\t\tconst u64 __iomem *src = from;\n\t\tconst u32 __iomem *src_trail;\n\t\tu64 *dst = to;\n\t\tu32 *dst_trail;\n\n\t\tfor (size = (size + 3) / 4; size > 1; size -= 2)\n\t\t\t*dst++ = readq_u(src++);\n\t\tif (size) {\n\t\t\tsrc_trail = (u32 __iomem *)src;\n\t\t\tdst_trail = (u32 *)dst;\n\t\t\t*dst_trail = readl_u(src_trail);\n\t\t}\n\t} else {\n\t\tconst u32 __iomem *src = from;\n\t\tu32 *dst = to;\n\n\t\tfor (size = (size + 3) / 4; size; size--)\n\t\t\t*dst++ = readl_u(src++);\n\t}\n}\n\nstatic inline void fza_writes(const void *from, void __iomem *to,\n\t\t\t      unsigned long size)\n{\n\tif (sizeof(unsigned long) == 8) {\n\t\tconst u64 *src = from;\n\t\tconst u32 *src_trail;\n\t\tu64 __iomem *dst = to;\n\t\tu32 __iomem *dst_trail;\n\n\t\tfor (size = (size + 3) / 4; size > 1; size -= 2)\n\t\t\twriteq_u(*src++, dst++);\n\t\tif (size) {\n\t\t\tsrc_trail = (u32 *)src;\n\t\t\tdst_trail = (u32 __iomem *)dst;\n\t\t\twritel_u(*src_trail, dst_trail);\n\t\t}\n\t} else {\n\t\tconst u32 *src = from;\n\t\tu32 __iomem *dst = to;\n\n\t\tfor (size = (size + 3) / 4; size; size--)\n\t\t\twritel_u(*src++, dst++);\n\t}\n}\n\nstatic inline void fza_moves(const void __iomem *from, void __iomem *to,\n\t\t\t     unsigned long size)\n{\n\tif (sizeof(unsigned long) == 8) {\n\t\tconst u64 __iomem *src = from;\n\t\tconst u32 __iomem *src_trail;\n\t\tu64 __iomem *dst = to;\n\t\tu32 __iomem *dst_trail;\n\n\t\tfor (size = (size + 3) / 4; size > 1; size -= 2)\n\t\t\twriteq_u(readq_u(src++), dst++);\n\t\tif (size) {\n\t\t\tsrc_trail = (u32 __iomem *)src;\n\t\t\tdst_trail = (u32 __iomem *)dst;\n\t\t\twritel_u(readl_u(src_trail), dst_trail);\n\t\t}\n\t} else {\n\t\tconst u32 __iomem *src = from;\n\t\tu32 __iomem *dst = to;\n\n\t\tfor (size = (size + 3) / 4; size; size--)\n\t\t\twritel_u(readl_u(src++), dst++);\n\t}\n}\n\nstatic inline void fza_zeros(void __iomem *to, unsigned long size)\n{\n\tif (sizeof(unsigned long) == 8) {\n\t\tu64 __iomem *dst = to;\n\t\tu32 __iomem *dst_trail;\n\n\t\tfor (size = (size + 3) / 4; size > 1; size -= 2)\n\t\t\twriteq_u(0, dst++);\n\t\tif (size) {\n\t\t\tdst_trail = (u32 __iomem *)dst;\n\t\t\twritel_u(0, dst_trail);\n\t\t}\n\t} else {\n\t\tu32 __iomem *dst = to;\n\n\t\tfor (size = (size + 3) / 4; size; size--)\n\t\t\twritel_u(0, dst++);\n\t}\n}\n\nstatic inline void fza_regs_dump(struct fza_private *fp)\n{\n\tpr_debug(\"%s: iomem registers:\\n\", fp->name);\n\tpr_debug(\" reset:           0x%04x\\n\", readw_o(&fp->regs->reset));\n\tpr_debug(\" interrupt event: 0x%04x\\n\", readw_u(&fp->regs->int_event));\n\tpr_debug(\" status:          0x%04x\\n\", readw_u(&fp->regs->status));\n\tpr_debug(\" interrupt mask:  0x%04x\\n\", readw_u(&fp->regs->int_mask));\n\tpr_debug(\" control A:       0x%04x\\n\", readw_u(&fp->regs->control_a));\n\tpr_debug(\" control B:       0x%04x\\n\", readw_u(&fp->regs->control_b));\n}\n\nstatic inline void fza_do_reset(struct fza_private *fp)\n{\n\t \n\twritew_o(FZA_RESET_INIT, &fp->regs->reset);\n\treadw_o(&fp->regs->reset);\t \n\treadw_o(&fp->regs->reset);\t \n\twritew_o(FZA_RESET_CLR, &fp->regs->reset);\n\n\t \n\twritew_o(fp->int_mask, &fp->regs->int_mask);\n\treadw_o(&fp->regs->int_mask);\t \n}\n\nstatic inline void fza_do_shutdown(struct fza_private *fp)\n{\n\t \n\twritew_o(FZA_CONTROL_B_IDLE, &fp->regs->control_b);\n\n\t \n\twritew_o(FZA_RESET_INIT, &fp->regs->reset);\n\treadw_o(&fp->regs->reset);\t \n\twritew_o(FZA_RESET_CLR, &fp->regs->reset);\n\treadw_o(&fp->regs->reset);\t \n}\n\nstatic int fza_reset(struct fza_private *fp)\n{\n\tunsigned long flags;\n\tuint status, state;\n\tlong t;\n\n\tpr_info(\"%s: resetting the board...\\n\", fp->name);\n\n\tspin_lock_irqsave(&fp->lock, flags);\n\tfp->state_chg_flag = 0;\n\tfza_do_reset(fp);\n\tspin_unlock_irqrestore(&fp->lock, flags);\n\n\t \n\tt = wait_event_timeout(fp->state_chg_wait, fp->state_chg_flag,\n\t\t\t       45 * HZ);\n\tstatus = readw_u(&fp->regs->status);\n\tstate = FZA_STATUS_GET_STATE(status);\n\tif (fp->state_chg_flag == 0) {\n\t\tpr_err(\"%s: RESET timed out!, state %x\\n\", fp->name, state);\n\t\treturn -EIO;\n\t}\n\tif (state != FZA_STATE_UNINITIALIZED) {\n\t\tpr_err(\"%s: RESET failed!, state %x, failure ID %x\\n\",\n\t\t       fp->name, state, FZA_STATUS_GET_TEST(status));\n\t\treturn -EIO;\n\t}\n\tpr_info(\"%s: OK\\n\", fp->name);\n\tpr_debug(\"%s: RESET: %lums elapsed\\n\", fp->name,\n\t\t (45 * HZ - t) * 1000 / HZ);\n\n\treturn 0;\n}\n\nstatic struct fza_ring_cmd __iomem *fza_cmd_send(struct net_device *dev,\n\t\t\t\t\t\t int command)\n{\n\tstruct fza_private *fp = netdev_priv(dev);\n\tstruct fza_ring_cmd __iomem *ring = fp->ring_cmd + fp->ring_cmd_index;\n\tunsigned int old_mask, new_mask;\n\tunion fza_cmd_buf __iomem *buf;\n\tstruct netdev_hw_addr *ha;\n\tint i;\n\n\told_mask = fp->int_mask;\n\tnew_mask = old_mask & ~FZA_MASK_STATE_CHG;\n\twritew_u(new_mask, &fp->regs->int_mask);\n\treadw_o(&fp->regs->int_mask);\t\t\t \n\tfp->int_mask = new_mask;\n\n\tbuf = fp->mmio + readl_u(&ring->buffer);\n\n\tif ((readl_u(&ring->cmd_own) & FZA_RING_OWN_MASK) !=\n\t    FZA_RING_OWN_HOST) {\n\t\tpr_warn(\"%s: command buffer full, command: %u!\\n\", fp->name,\n\t\t\tcommand);\n\t\treturn NULL;\n\t}\n\n\tswitch (command) {\n\tcase FZA_RING_CMD_INIT:\n\t\twritel_u(FZA_RING_TX_MODE, &buf->init.tx_mode);\n\t\twritel_u(FZA_RING_RX_SIZE, &buf->init.hst_rx_size);\n\t\tfza_zeros(&buf->init.counters, sizeof(buf->init.counters));\n\t\tbreak;\n\n\tcase FZA_RING_CMD_MODCAM:\n\t\ti = 0;\n\t\tfza_writes(&hw_addr_purger, &buf->cam.hw_addr[i++],\n\t\t\t   sizeof(*buf->cam.hw_addr));\n\t\tfza_writes(&hw_addr_beacon, &buf->cam.hw_addr[i++],\n\t\t\t   sizeof(*buf->cam.hw_addr));\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tif (i >= FZA_CMD_CAM_SIZE)\n\t\t\t\tbreak;\n\t\t\tfza_writes(ha->addr, &buf->cam.hw_addr[i++],\n\t\t\t\t   sizeof(*buf->cam.hw_addr));\n\t\t}\n\t\twhile (i < FZA_CMD_CAM_SIZE)\n\t\t\tfza_zeros(&buf->cam.hw_addr[i++],\n\t\t\t\t  sizeof(*buf->cam.hw_addr));\n\t\tbreak;\n\n\tcase FZA_RING_CMD_PARAM:\n\t\twritel_u(loopback, &buf->param.loop_mode);\n\t\twritel_u(fp->t_max, &buf->param.t_max);\n\t\twritel_u(fp->t_req, &buf->param.t_req);\n\t\twritel_u(fp->tvx, &buf->param.tvx);\n\t\twritel_u(fp->lem_threshold, &buf->param.lem_threshold);\n\t\tfza_writes(&fp->station_id, &buf->param.station_id,\n\t\t\t   sizeof(buf->param.station_id));\n\t\t \n\t\twritel_u(fp->rtoken_timeout / 12500,\n\t\t\t &buf->param.rtoken_timeout);\n\t\twritel_u(fp->ring_purger, &buf->param.ring_purger);\n\t\tbreak;\n\n\tcase FZA_RING_CMD_MODPROM:\n\t\tif (dev->flags & IFF_PROMISC) {\n\t\t\twritel_u(1, &buf->modprom.llc_prom);\n\t\t\twritel_u(1, &buf->modprom.smt_prom);\n\t\t} else {\n\t\t\twritel_u(0, &buf->modprom.llc_prom);\n\t\t\twritel_u(0, &buf->modprom.smt_prom);\n\t\t}\n\t\tif (dev->flags & IFF_ALLMULTI ||\n\t\t    netdev_mc_count(dev) > FZA_CMD_CAM_SIZE - 2)\n\t\t\twritel_u(1, &buf->modprom.llc_multi);\n\t\telse\n\t\t\twritel_u(0, &buf->modprom.llc_multi);\n\t\twritel_u(1, &buf->modprom.llc_bcast);\n\t\tbreak;\n\t}\n\n\t \n\twritel_u(FZA_RING_OWN_FZA | command, &ring->cmd_own);\n\twritew_o(FZA_CONTROL_A_CMD_POLL, &fp->regs->control_a);\n\n\tfp->ring_cmd_index = (fp->ring_cmd_index + 1) % FZA_RING_CMD_SIZE;\n\n\tfp->int_mask = old_mask;\n\twritew_u(fp->int_mask, &fp->regs->int_mask);\n\n\treturn ring;\n}\n\nstatic int fza_init_send(struct net_device *dev,\n\t\t\t struct fza_cmd_init *__iomem *init)\n{\n\tstruct fza_private *fp = netdev_priv(dev);\n\tstruct fza_ring_cmd __iomem *ring;\n\tunsigned long flags;\n\tu32 stat;\n\tlong t;\n\n\tspin_lock_irqsave(&fp->lock, flags);\n\tfp->cmd_done_flag = 0;\n\tring = fza_cmd_send(dev, FZA_RING_CMD_INIT);\n\tspin_unlock_irqrestore(&fp->lock, flags);\n\tif (!ring)\n\t\t \n\t\treturn -ENOBUFS;\n\n\t \n\tt = wait_event_timeout(fp->cmd_done_wait, fp->cmd_done_flag, 3 * HZ);\n\tif (fp->cmd_done_flag == 0) {\n\t\tpr_err(\"%s: INIT command timed out!, state %x\\n\", fp->name,\n\t\t       FZA_STATUS_GET_STATE(readw_u(&fp->regs->status)));\n\t\treturn -EIO;\n\t}\n\tstat = readl_u(&ring->stat);\n\tif (stat != FZA_RING_STAT_SUCCESS) {\n\t\tpr_err(\"%s: INIT command failed!, status %02x, state %x\\n\",\n\t\t       fp->name, stat,\n\t\t       FZA_STATUS_GET_STATE(readw_u(&fp->regs->status)));\n\t\treturn -EIO;\n\t}\n\tpr_debug(\"%s: INIT: %lums elapsed\\n\", fp->name,\n\t\t (3 * HZ - t) * 1000 / HZ);\n\n\tif (init)\n\t\t*init = fp->mmio + readl_u(&ring->buffer);\n\treturn 0;\n}\n\nstatic void fza_rx_init(struct fza_private *fp)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < FZA_RING_RX_SIZE; i++) {\n\t\twritel_o(0, &fp->ring_hst_rx[i].rmc);\n\t\twritel_o((fp->rx_dma[i] + 0x1000) >> 9,\n\t\t\t &fp->ring_hst_rx[i].buffer1);\n\t\twritel_o(fp->rx_dma[i] >> 9 | FZA_RING_OWN_FZA,\n\t\t\t &fp->ring_hst_rx[i].buf0_own);\n\t}\n}\n\nstatic void fza_set_rx_mode(struct net_device *dev)\n{\n\tfza_cmd_send(dev, FZA_RING_CMD_MODCAM);\n\tfza_cmd_send(dev, FZA_RING_CMD_MODPROM);\n}\n\nunion fza_buffer_txp {\n\tstruct fza_buffer_tx *data_ptr;\n\tstruct fza_buffer_tx __iomem *mmio_ptr;\n};\n\nstatic int fza_do_xmit(union fza_buffer_txp ub, int len,\n\t\t       struct net_device *dev, int smt)\n{\n\tstruct fza_private *fp = netdev_priv(dev);\n\tstruct fza_buffer_tx __iomem *rmc_tx_ptr;\n\tint i, first, frag_len, left_len;\n\tu32 own, rmc;\n\n\tif (((((fp->ring_rmc_txd_index - 1 + fp->ring_rmc_tx_size) -\n\t       fp->ring_rmc_tx_index) % fp->ring_rmc_tx_size) *\n\t     FZA_TX_BUFFER_SIZE) < len)\n\t\treturn 1;\n\n\tfirst = fp->ring_rmc_tx_index;\n\n\tleft_len = len;\n\tfrag_len = FZA_TX_BUFFER_SIZE;\n\t \n\town = FZA_RING_TX_OWN_HOST;\n\t \n\trmc = FZA_RING_TX_SOP | FZA_RING_TX_VBC | len;\n\tdo {\n\t\ti = fp->ring_rmc_tx_index;\n\t\trmc_tx_ptr = &fp->buffer_tx[i];\n\n\t\tif (left_len < FZA_TX_BUFFER_SIZE)\n\t\t\tfrag_len = left_len;\n\t\tleft_len -= frag_len;\n\n\t\t \n\t\tfrag_len = (frag_len + 3) & ~3;\n\t\tif (smt)\n\t\t\tfza_moves(ub.mmio_ptr, rmc_tx_ptr, frag_len);\n\t\telse\n\t\t\tfza_writes(ub.data_ptr, rmc_tx_ptr, frag_len);\n\n\t\tif (left_len == 0)\n\t\t\trmc |= FZA_RING_TX_EOP;\t\t \n\n\t\twritel_o(rmc, &fp->ring_rmc_tx[i].rmc);\n\t\twritel_o(own, &fp->ring_rmc_tx[i].own);\n\n\t\tub.data_ptr++;\n\t\tfp->ring_rmc_tx_index = (fp->ring_rmc_tx_index + 1) %\n\t\t\t\t\tfp->ring_rmc_tx_size;\n\n\t\t \n\t\town = FZA_RING_TX_OWN_RMC;\n\t\trmc = 0;\n\t} while (left_len > 0);\n\n\tif (((((fp->ring_rmc_txd_index - 1 + fp->ring_rmc_tx_size) -\n\t       fp->ring_rmc_tx_index) % fp->ring_rmc_tx_size) *\n\t     FZA_TX_BUFFER_SIZE) < dev->mtu + dev->hard_header_len) {\n\t\tnetif_stop_queue(dev);\n\t\tpr_debug(\"%s: queue stopped\\n\", fp->name);\n\t}\n\n\twritel_o(FZA_RING_TX_OWN_RMC, &fp->ring_rmc_tx[first].own);\n\n\t \n\twritew_o(FZA_CONTROL_A_TX_POLL, &fp->regs->control_a);\n\n\treturn 0;\n}\n\nstatic int fza_do_recv_smt(struct fza_buffer_tx *data_ptr, int len,\n\t\t\t   u32 rmc, struct net_device *dev)\n{\n\tstruct fza_private *fp = netdev_priv(dev);\n\tstruct fza_buffer_tx __iomem *smt_rx_ptr;\n\tu32 own;\n\tint i;\n\n\ti = fp->ring_smt_rx_index;\n\town = readl_o(&fp->ring_smt_rx[i].own);\n\tif ((own & FZA_RING_OWN_MASK) == FZA_RING_OWN_FZA)\n\t\treturn 1;\n\n\tsmt_rx_ptr = fp->mmio + readl_u(&fp->ring_smt_rx[i].buffer);\n\n\t \n\tfza_writes(data_ptr, smt_rx_ptr, (len + 3) & ~3);\n\n\twritel_o(rmc, &fp->ring_smt_rx[i].rmc);\n\twritel_o(FZA_RING_OWN_FZA, &fp->ring_smt_rx[i].own);\n\n\tfp->ring_smt_rx_index =\n\t\t(fp->ring_smt_rx_index + 1) % fp->ring_smt_rx_size;\n\n\t \n\twritew_o(FZA_CONTROL_A_SMT_RX_POLL, &fp->regs->control_a);\n\n\treturn 0;\n}\n\nstatic void fza_tx(struct net_device *dev)\n{\n\tstruct fza_private *fp = netdev_priv(dev);\n\tu32 own, rmc;\n\tint i;\n\n\twhile (1) {\n\t\ti = fp->ring_rmc_txd_index;\n\t\tif (i == fp->ring_rmc_tx_index)\n\t\t\tbreak;\n\t\town = readl_o(&fp->ring_rmc_tx[i].own);\n\t\tif ((own & FZA_RING_OWN_MASK) == FZA_RING_TX_OWN_RMC)\n\t\t\tbreak;\n\n\t\trmc = readl_u(&fp->ring_rmc_tx[i].rmc);\n\t\t \n\t\tif ((rmc & FZA_RING_TX_SOP) != 0) {\n\t\t\tif ((rmc & FZA_RING_TX_DCC_MASK) ==\n\t\t\t    FZA_RING_TX_DCC_SUCCESS) {\n\t\t\t\tint pkt_len = (rmc & FZA_RING_PBC_MASK) - 3;\n\t\t\t\t\t\t\t\t \n\n\t\t\t\tfp->stats.tx_packets++;\n\t\t\t\tfp->stats.tx_bytes += pkt_len;\n\t\t\t} else {\n\t\t\t\tfp->stats.tx_errors++;\n\t\t\t\tswitch (rmc & FZA_RING_TX_DCC_MASK) {\n\t\t\t\tcase FZA_RING_TX_DCC_DTP_SOP:\n\t\t\t\tcase FZA_RING_TX_DCC_DTP:\n\t\t\t\tcase FZA_RING_TX_DCC_ABORT:\n\t\t\t\t\tfp->stats.tx_aborted_errors++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FZA_RING_TX_DCC_UNDRRUN:\n\t\t\t\t\tfp->stats.tx_fifo_errors++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase FZA_RING_TX_DCC_PARITY:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfp->ring_rmc_txd_index = (fp->ring_rmc_txd_index + 1) %\n\t\t\t\t\t fp->ring_rmc_tx_size;\n\t}\n\n\tif (((((fp->ring_rmc_txd_index - 1 + fp->ring_rmc_tx_size) -\n\t       fp->ring_rmc_tx_index) % fp->ring_rmc_tx_size) *\n\t     FZA_TX_BUFFER_SIZE) >= dev->mtu + dev->hard_header_len) {\n\t\tif (fp->queue_active) {\n\t\t\tnetif_wake_queue(dev);\n\t\t\tpr_debug(\"%s: queue woken\\n\", fp->name);\n\t\t}\n\t}\n}\n\nstatic inline int fza_rx_err(struct fza_private *fp,\n\t\t\t     const u32 rmc, const u8 fc)\n{\n\tint len, min_len, max_len;\n\n\tlen = rmc & FZA_RING_PBC_MASK;\n\n\tif (unlikely((rmc & FZA_RING_RX_BAD) != 0)) {\n\t\tfp->stats.rx_errors++;\n\n\t\t \n\t\tif ((rmc & (FZA_RING_RX_CRC | FZA_RING_RX_RRR_MASK |\n\t\t\t    FZA_RING_RX_DA_MASK | FZA_RING_RX_SA_MASK)) ==\n\t\t     (FZA_RING_RX_CRC | FZA_RING_RX_RRR_DADDR |\n\t\t      FZA_RING_RX_DA_CAM | FZA_RING_RX_SA_ALIAS)) {\n\t\t\tif (len >= 8190)\n\t\t\t\tfp->stats.rx_length_errors++;\n\t\t\treturn 1;\n\t\t}\n\t\tif ((rmc & (FZA_RING_RX_CRC | FZA_RING_RX_RRR_MASK |\n\t\t\t    FZA_RING_RX_DA_MASK | FZA_RING_RX_SA_MASK)) ==\n\t\t     (FZA_RING_RX_CRC | FZA_RING_RX_RRR_DADDR |\n\t\t      FZA_RING_RX_DA_CAM | FZA_RING_RX_SA_CAM)) {\n\t\t\t \n\t\t\twritew_o(FZA_CONTROL_A_HALT, &fp->regs->control_a);\n\t\t\treadw_o(&fp->regs->control_a);\t \n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\tswitch (rmc & FZA_RING_RX_RRR_MASK) {\n\t\tcase FZA_RING_RX_RRR_OK:\n\t\t\tif ((rmc & FZA_RING_RX_CRC) != 0)\n\t\t\t\tfp->stats.rx_crc_errors++;\n\t\t\telse if ((rmc & FZA_RING_RX_FSC_MASK) == 0 ||\n\t\t\t\t (rmc & FZA_RING_RX_FSB_ERR) != 0)\n\t\t\t\tfp->stats.rx_frame_errors++;\n\t\t\treturn 1;\n\t\tcase FZA_RING_RX_RRR_SADDR:\n\t\tcase FZA_RING_RX_RRR_DADDR:\n\t\tcase FZA_RING_RX_RRR_ABORT:\n\t\t\t \n\t\t\twritew_o(FZA_CONTROL_A_HALT, &fp->regs->control_a);\n\t\t\treadw_o(&fp->regs->control_a);\t \n\t\t\treturn 1;\n\t\tcase FZA_RING_RX_RRR_LENGTH:\n\t\t\tfp->stats.rx_frame_errors++;\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t \n\tswitch (fc & FDDI_FC_K_FORMAT_MASK) {\n\tcase FDDI_FC_K_FORMAT_MANAGEMENT:\n\t\tif ((fc & FDDI_FC_K_CLASS_MASK) == FDDI_FC_K_CLASS_ASYNC)\n\t\t\tmin_len = 37;\n\t\telse\n\t\t\tmin_len = 17;\n\t\tbreak;\n\tcase FDDI_FC_K_FORMAT_LLC:\n\t\tmin_len = 20;\n\t\tbreak;\n\tdefault:\n\t\tmin_len = 17;\n\t\tbreak;\n\t}\n\tmax_len = 4495;\n\tif (len < min_len || len > max_len) {\n\t\tfp->stats.rx_errors++;\n\t\tfp->stats.rx_length_errors++;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void fza_rx(struct net_device *dev)\n{\n\tstruct fza_private *fp = netdev_priv(dev);\n\tstruct sk_buff *skb, *newskb;\n\tstruct fza_fddihdr *frame;\n\tdma_addr_t dma, newdma;\n\tu32 own, rmc, buf;\n\tint i, len;\n\tu8 fc;\n\n\twhile (1) {\n\t\ti = fp->ring_hst_rx_index;\n\t\town = readl_o(&fp->ring_hst_rx[i].buf0_own);\n\t\tif ((own & FZA_RING_OWN_MASK) == FZA_RING_OWN_FZA)\n\t\t\tbreak;\n\n\t\trmc = readl_u(&fp->ring_hst_rx[i].rmc);\n\t\tskb = fp->rx_skbuff[i];\n\t\tdma = fp->rx_dma[i];\n\n\t\t \n\t\tdma_rmb();\n\t\tlen = (rmc & FZA_RING_PBC_MASK) + 3;\n\t\tframe = (struct fza_fddihdr *)skb->data;\n\n\t\t \n\t\tdma_sync_single_for_cpu(fp->bdev,\n\t\t\t\t\tdma +\n\t\t\t\t\t((u8 *)&frame->hdr.fc - (u8 *)frame),\n\t\t\t\t\tsizeof(frame->hdr.fc),\n\t\t\t\t\tDMA_FROM_DEVICE);\n\t\tfc = frame->hdr.fc;\n\n\t\tif (fza_rx_err(fp, rmc, fc))\n\t\t\tgoto err_rx;\n\n\t\t \n\t\tnewskb = fza_alloc_skb_irq(dev, FZA_RX_BUFFER_SIZE + 511);\n\t\tif (newskb) {\n\t\t\tfza_skb_align(newskb, 512);\n\t\t\tnewdma = dma_map_single(fp->bdev, newskb->data,\n\t\t\t\t\t\tFZA_RX_BUFFER_SIZE,\n\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\tif (dma_mapping_error(fp->bdev, newdma)) {\n\t\t\t\tdev_kfree_skb_irq(newskb);\n\t\t\t\tnewskb = NULL;\n\t\t\t}\n\t\t}\n\t\tif (newskb) {\n\t\t\tint pkt_len = len - 7;\t \n\t\t\tint is_multi;\n\t\t\tint rx_stat;\n\n\t\t\tdma_unmap_single(fp->bdev, dma, FZA_RX_BUFFER_SIZE,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\n\t\t\t \n\t\t\tif ((fc & (FDDI_FC_K_CLASS_MASK |\n\t\t\t\t   FDDI_FC_K_FORMAT_MASK)) ==\n\t\t\t     (FDDI_FC_K_CLASS_ASYNC |\n\t\t\t      FDDI_FC_K_FORMAT_MANAGEMENT) &&\n\t\t\t    (rmc & FZA_RING_RX_DA_MASK) !=\n\t\t\t     FZA_RING_RX_DA_PROM) {\n\t\t\t\tif (fza_do_recv_smt((struct fza_buffer_tx *)\n\t\t\t\t\t\t    skb->data, len, rmc,\n\t\t\t\t\t\t    dev)) {\n\t\t\t\t\twritel_o(FZA_CONTROL_A_SMT_RX_OVFL,\n\t\t\t\t\t\t &fp->regs->control_a);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tis_multi = ((frame->hdr.daddr[0] & 0x01) != 0);\n\n\t\t\tskb_reserve(skb, 3);\t \n\t\t\tskb_put(skb, pkt_len);\t \n\t\t\tskb->protocol = fddi_type_trans(skb, dev);\n\n\t\t\trx_stat = netif_rx(skb);\n\t\t\tif (rx_stat != NET_RX_DROP) {\n\t\t\t\tfp->stats.rx_packets++;\n\t\t\t\tfp->stats.rx_bytes += pkt_len;\n\t\t\t\tif (is_multi)\n\t\t\t\t\tfp->stats.multicast++;\n\t\t\t} else {\n\t\t\t\tfp->stats.rx_dropped++;\n\t\t\t}\n\n\t\t\tskb = newskb;\n\t\t\tdma = newdma;\n\t\t\tfp->rx_skbuff[i] = skb;\n\t\t\tfp->rx_dma[i] = dma;\n\t\t} else {\n\t\t\tfp->stats.rx_dropped++;\n\t\t\tpr_notice(\"%s: memory squeeze, dropping packet\\n\",\n\t\t\t\t  fp->name);\n\t\t}\n\nerr_rx:\n\t\twritel_o(0, &fp->ring_hst_rx[i].rmc);\n\t\tbuf = (dma + 0x1000) >> 9;\n\t\twritel_o(buf, &fp->ring_hst_rx[i].buffer1);\n\t\tbuf = dma >> 9 | FZA_RING_OWN_FZA;\n\t\twritel_o(buf, &fp->ring_hst_rx[i].buf0_own);\n\t\tfp->ring_hst_rx_index =\n\t\t\t(fp->ring_hst_rx_index + 1) % fp->ring_hst_rx_size;\n\t}\n}\n\nstatic void fza_tx_smt(struct net_device *dev)\n{\n\tstruct fza_private *fp = netdev_priv(dev);\n\tstruct fza_buffer_tx __iomem *smt_tx_ptr;\n\tint i, len;\n\tu32 own;\n\n\twhile (1) {\n\t\ti = fp->ring_smt_tx_index;\n\t\town = readl_o(&fp->ring_smt_tx[i].own);\n\t\tif ((own & FZA_RING_OWN_MASK) == FZA_RING_OWN_FZA)\n\t\t\tbreak;\n\n\t\tsmt_tx_ptr = fp->mmio + readl_u(&fp->ring_smt_tx[i].buffer);\n\t\tlen = readl_u(&fp->ring_smt_tx[i].rmc) & FZA_RING_PBC_MASK;\n\n\t\tif (!netif_queue_stopped(dev)) {\n\t\t\tif (dev_nit_active(dev)) {\n\t\t\t\tstruct fza_buffer_tx *skb_data_ptr;\n\t\t\t\tstruct sk_buff *skb;\n\n\t\t\t\t \n\t\t\t\tskb = fza_alloc_skb_irq(dev, (len + 3) & ~3);\n\t\t\t\tif (!skb)\n\t\t\t\t\tgoto err_no_skb;\t \n\n\t\t\t\tskb_data_ptr = (struct fza_buffer_tx *)\n\t\t\t\t\t       skb->data;\n\n\t\t\t\tfza_reads(smt_tx_ptr, skb_data_ptr,\n\t\t\t\t\t  (len + 3) & ~3);\n\t\t\t\tskb->dev = dev;\n\t\t\t\tskb_reserve(skb, 3);\t \n\t\t\t\tskb_put(skb, len - 3);\n\t\t\t\tskb_reset_network_header(skb);\n\n\t\t\t\tdev_queue_xmit_nit(skb, dev);\n\n\t\t\t\tdev_kfree_skb_irq(skb);\n\nerr_no_skb:\n\t\t\t\t;\n\t\t\t}\n\n\t\t\t \n\t\t\tfza_do_xmit((union fza_buffer_txp)\n\t\t\t\t    { .mmio_ptr = smt_tx_ptr },\n\t\t\t\t    len, dev, 1);\n\t\t}\n\n\t\twritel_o(FZA_RING_OWN_FZA, &fp->ring_smt_tx[i].own);\n\t\tfp->ring_smt_tx_index =\n\t\t\t(fp->ring_smt_tx_index + 1) % fp->ring_smt_tx_size;\n\t}\n}\n\nstatic void fza_uns(struct net_device *dev)\n{\n\tstruct fza_private *fp = netdev_priv(dev);\n\tu32 own;\n\tint i;\n\n\twhile (1) {\n\t\ti = fp->ring_uns_index;\n\t\town = readl_o(&fp->ring_uns[i].own);\n\t\tif ((own & FZA_RING_OWN_MASK) == FZA_RING_OWN_FZA)\n\t\t\tbreak;\n\n\t\tif (readl_u(&fp->ring_uns[i].id) == FZA_RING_UNS_RX_OVER) {\n\t\t\tfp->stats.rx_errors++;\n\t\t\tfp->stats.rx_over_errors++;\n\t\t}\n\n\t\twritel_o(FZA_RING_OWN_FZA, &fp->ring_uns[i].own);\n\t\tfp->ring_uns_index =\n\t\t\t(fp->ring_uns_index + 1) % FZA_RING_UNS_SIZE;\n\t}\n}\n\nstatic void fza_tx_flush(struct net_device *dev)\n{\n\tstruct fza_private *fp = netdev_priv(dev);\n\tu32 own;\n\tint i;\n\n\t \n\ti = fp->ring_smt_tx_index;\n\tdo {\n\t\twritel_o(FZA_RING_OWN_FZA, &fp->ring_smt_tx[i].own);\n\t\tfp->ring_smt_tx_index =\n\t\t\t(fp->ring_smt_tx_index + 1) % fp->ring_smt_tx_size;\n\n\t} while (i != fp->ring_smt_tx_index);\n\n\t \n\ti = fp->ring_rmc_tx_index;\n\tdo {\n\t\town = readl_o(&fp->ring_rmc_tx[i].own);\n\t\tif ((own & FZA_RING_OWN_MASK) == FZA_RING_TX_OWN_RMC) {\n\t\t\tu32 rmc = readl_u(&fp->ring_rmc_tx[i].rmc);\n\n\t\t\twritel_u(rmc | FZA_RING_TX_DTP,\n\t\t\t\t &fp->ring_rmc_tx[i].rmc);\n\t\t}\n\t\tfp->ring_rmc_tx_index =\n\t\t\t(fp->ring_rmc_tx_index + 1) % fp->ring_rmc_tx_size;\n\n\t} while (i != fp->ring_rmc_tx_index);\n\n\t \n\twritew_o(FZA_CONTROL_A_FLUSH_DONE, &fp->regs->control_a);\n}\n\nstatic irqreturn_t fza_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct fza_private *fp = netdev_priv(dev);\n\tuint int_event;\n\n\t \n\tint_event = readw_o(&fp->regs->int_event) & fp->int_mask;\n\tif (int_event == 0)\n\t\treturn IRQ_NONE;\n\n\t \n\twritew_u(int_event, &fp->regs->int_event);\n\n\t \n\n\t \n\tif ((int_event & FZA_EVENT_CMD_DONE) != 0) {\n\t\tfp->irq_count_cmd_done++;\n\n\t\tspin_lock(&fp->lock);\n\t\tfp->cmd_done_flag = 1;\n\t\twake_up(&fp->cmd_done_wait);\n\t\tspin_unlock(&fp->lock);\n\t}\n\n\t \n\tif ((int_event & FZA_EVENT_TX_DONE) != 0) {\n\t\tfp->irq_count_tx_done++;\n\t\tfza_tx(dev);\n\t}\n\n\t \n\tif ((int_event & FZA_EVENT_RX_POLL) != 0) {\n\t\tfp->irq_count_rx_poll++;\n\t\tfza_rx(dev);\n\t}\n\n\t \n\tif ((int_event & FZA_EVENT_SMT_TX_POLL) != 0) {\n\t\tfp->irq_count_smt_tx_poll++;\n\t\tfza_tx_smt(dev);\n\t}\n\n\t \n\tif ((int_event & FZA_EVENT_FLUSH_TX) != 0) {\n\t\tfp->irq_count_flush_tx++;\n\t\tfza_tx_flush(dev);\n\t}\n\n\t \n\tif ((int_event & FZA_EVENT_LINK_ST_CHG) != 0) {\n\t\tuint status;\n\n\t\tfp->irq_count_link_st_chg++;\n\t\tstatus = readw_u(&fp->regs->status);\n\t\tif (FZA_STATUS_GET_LINK(status) == FZA_LINK_ON) {\n\t\t\tnetif_carrier_on(dev);\n\t\t\tpr_info(\"%s: link available\\n\", fp->name);\n\t\t} else {\n\t\t\tnetif_carrier_off(dev);\n\t\t\tpr_info(\"%s: link unavailable\\n\", fp->name);\n\t\t}\n\t}\n\n\t \n\tif ((int_event & FZA_EVENT_UNS_POLL) != 0) {\n\t\tfp->irq_count_uns_poll++;\n\t\tfza_uns(dev);\n\t}\n\n\t \n\tif ((int_event & FZA_EVENT_STATE_CHG) != 0) {\n\t\tuint status, state;\n\n\t\tfp->irq_count_state_chg++;\n\n\t\tstatus = readw_u(&fp->regs->status);\n\t\tstate = FZA_STATUS_GET_STATE(status);\n\t\tpr_debug(\"%s: state change: %x\\n\", fp->name, state);\n\t\tswitch (state) {\n\t\tcase FZA_STATE_RESET:\n\t\t\tbreak;\n\n\t\tcase FZA_STATE_UNINITIALIZED:\n\t\t\tnetif_carrier_off(dev);\n\t\t\tdel_timer_sync(&fp->reset_timer);\n\t\t\tfp->ring_cmd_index = 0;\n\t\t\tfp->ring_uns_index = 0;\n\t\t\tfp->ring_rmc_tx_index = 0;\n\t\t\tfp->ring_rmc_txd_index = 0;\n\t\t\tfp->ring_hst_rx_index = 0;\n\t\t\tfp->ring_smt_tx_index = 0;\n\t\t\tfp->ring_smt_rx_index = 0;\n\t\t\tif (fp->state > state) {\n\t\t\t\tpr_info(\"%s: OK\\n\", fp->name);\n\t\t\t\tfza_cmd_send(dev, FZA_RING_CMD_INIT);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase FZA_STATE_INITIALIZED:\n\t\t\tif (fp->state > state) {\n\t\t\t\tfza_set_rx_mode(dev);\n\t\t\t\tfza_cmd_send(dev, FZA_RING_CMD_PARAM);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase FZA_STATE_RUNNING:\n\t\tcase FZA_STATE_MAINTENANCE:\n\t\t\tfp->state = state;\n\t\t\tfza_rx_init(fp);\n\t\t\tfp->queue_active = 1;\n\t\t\tnetif_wake_queue(dev);\n\t\t\tpr_debug(\"%s: queue woken\\n\", fp->name);\n\t\t\tbreak;\n\n\t\tcase FZA_STATE_HALTED:\n\t\t\tfp->queue_active = 0;\n\t\t\tnetif_stop_queue(dev);\n\t\t\tpr_debug(\"%s: queue stopped\\n\", fp->name);\n\t\t\tdel_timer_sync(&fp->reset_timer);\n\t\t\tpr_warn(\"%s: halted, reason: %x\\n\", fp->name,\n\t\t\t\tFZA_STATUS_GET_HALT(status));\n\t\t\tfza_regs_dump(fp);\n\t\t\tpr_info(\"%s: resetting the board...\\n\", fp->name);\n\t\t\tfza_do_reset(fp);\n\t\t\tfp->timer_state = 0;\n\t\t\tfp->reset_timer.expires = jiffies + 45 * HZ;\n\t\t\tadd_timer(&fp->reset_timer);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_warn(\"%s: undefined state: %x\\n\", fp->name, state);\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_lock(&fp->lock);\n\t\tfp->state_chg_flag = 1;\n\t\twake_up(&fp->state_chg_wait);\n\t\tspin_unlock(&fp->lock);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void fza_reset_timer(struct timer_list *t)\n{\n\tstruct fza_private *fp = from_timer(fp, t, reset_timer);\n\n\tif (!fp->timer_state) {\n\t\tpr_err(\"%s: RESET timed out!\\n\", fp->name);\n\t\tpr_info(\"%s: trying harder...\\n\", fp->name);\n\n\t\t \n\t\twritew_o(FZA_RESET_INIT, &fp->regs->reset);\n\t\treadw_o(&fp->regs->reset);\t\t \n\n\t\tfp->timer_state = 1;\n\t\tfp->reset_timer.expires = jiffies + HZ;\n\t} else {\n\t\t \n\t\twritew_u(FZA_RESET_CLR, &fp->regs->reset);\n\n\t\t \n\t\twritew_o(fp->int_mask, &fp->regs->int_mask);\n\t\treadw_o(&fp->regs->int_mask);\t\t \n\n\t\tfp->timer_state = 0;\n\t\tfp->reset_timer.expires = jiffies + 45 * HZ;\n\t}\n\tadd_timer(&fp->reset_timer);\n}\n\nstatic int fza_set_mac_address(struct net_device *dev, void *addr)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic netdev_tx_t fza_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct fza_private *fp = netdev_priv(dev);\n\tunsigned int old_mask, new_mask;\n\tint ret;\n\tu8 fc;\n\n\tskb_push(skb, 3);\t\t\t \n\n\t \n\tfc = skb->data[3];\n\tskb->data[0] = 0;\n\tskb->data[1] = 0;\n\tskb->data[2] = FZA_PRH2_NORMAL;\n\tif ((fc & FDDI_FC_K_CLASS_MASK) == FDDI_FC_K_CLASS_SYNC)\n\t\tskb->data[0] |= FZA_PRH0_FRAME_SYNC;\n\tswitch (fc & FDDI_FC_K_FORMAT_MASK) {\n\tcase FDDI_FC_K_FORMAT_MANAGEMENT:\n\t\tif ((fc & FDDI_FC_K_CONTROL_MASK) == 0) {\n\t\t\t \n\t\t\tskb->data[0] |= FZA_PRH0_TKN_TYPE_IMM;\n\t\t\tskb->data[1] |= FZA_PRH1_TKN_SEND_NONE;\n\t\t} else {\n\t\t\t \n\t\t\tskb->data[0] |= FZA_PRH0_TKN_TYPE_UNR;\n\t\t\tskb->data[1] |= FZA_PRH1_TKN_SEND_UNR;\n\t\t}\n\t\tskb->data[1] |= FZA_PRH1_CRC_NORMAL;\n\t\tbreak;\n\tcase FDDI_FC_K_FORMAT_LLC:\n\tcase FDDI_FC_K_FORMAT_FUTURE:\n\t\tskb->data[0] |= FZA_PRH0_TKN_TYPE_UNR;\n\t\tskb->data[1] |= FZA_PRH1_CRC_NORMAL | FZA_PRH1_TKN_SEND_UNR;\n\t\tbreak;\n\tcase FDDI_FC_K_FORMAT_IMPLEMENTOR:\n\t\tskb->data[0] |= FZA_PRH0_TKN_TYPE_UNR;\n\t\tskb->data[1] |= FZA_PRH1_TKN_SEND_ORIG;\n\t\tbreak;\n\t}\n\n\t \n\told_mask = fp->int_mask;\n\tnew_mask = old_mask & ~FZA_MASK_SMT_TX_POLL;\n\twritew_u(new_mask, &fp->regs->int_mask);\n\treadw_o(&fp->regs->int_mask);\t\t\t \n\tfp->int_mask = new_mask;\n\tret = fza_do_xmit((union fza_buffer_txp)\n\t\t\t  { .data_ptr = (struct fza_buffer_tx *)skb->data },\n\t\t\t  skb->len, dev, 0);\n\tfp->int_mask = old_mask;\n\twritew_u(fp->int_mask, &fp->regs->int_mask);\n\n\tif (ret) {\n\t\t \n\t\tnetif_stop_queue(dev);\n\t\tpr_debug(\"%s: queue stopped\\n\", fp->name);\n\t\tfp->stats.tx_dropped++;\n\t}\n\n\tdev_kfree_skb(skb);\n\n\treturn ret;\n}\n\nstatic int fza_open(struct net_device *dev)\n{\n\tstruct fza_private *fp = netdev_priv(dev);\n\tstruct fza_ring_cmd __iomem *ring;\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\tdma_addr_t dma;\n\tint ret, i;\n\tu32 stat;\n\tlong t;\n\n\tfor (i = 0; i < FZA_RING_RX_SIZE; i++) {\n\t\t \n\t\tskb = fza_alloc_skb(dev, FZA_RX_BUFFER_SIZE + 511);\n\t\tif (skb) {\n\t\t\tfza_skb_align(skb, 512);\n\t\t\tdma = dma_map_single(fp->bdev, skb->data,\n\t\t\t\t\t     FZA_RX_BUFFER_SIZE,\n\t\t\t\t\t     DMA_FROM_DEVICE);\n\t\t\tif (dma_mapping_error(fp->bdev, dma)) {\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\tskb = NULL;\n\t\t\t}\n\t\t}\n\t\tif (!skb) {\n\t\t\tfor (--i; i >= 0; i--) {\n\t\t\t\tdma_unmap_single(fp->bdev, fp->rx_dma[i],\n\t\t\t\t\t\t FZA_RX_BUFFER_SIZE,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\t\tdev_kfree_skb(fp->rx_skbuff[i]);\n\t\t\t\tfp->rx_dma[i] = 0;\n\t\t\t\tfp->rx_skbuff[i] = NULL;\n\t\t\t}\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tfp->rx_skbuff[i] = skb;\n\t\tfp->rx_dma[i] = dma;\n\t}\n\n\tret = fza_init_send(dev, NULL);\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tfza_set_rx_mode(dev);\n\n\tspin_lock_irqsave(&fp->lock, flags);\n\tfp->cmd_done_flag = 0;\n\tring = fza_cmd_send(dev, FZA_RING_CMD_PARAM);\n\tspin_unlock_irqrestore(&fp->lock, flags);\n\tif (!ring)\n\t\treturn -ENOBUFS;\n\n\tt = wait_event_timeout(fp->cmd_done_wait, fp->cmd_done_flag, 3 * HZ);\n\tif (fp->cmd_done_flag == 0) {\n\t\tpr_err(\"%s: PARAM command timed out!, state %x\\n\", fp->name,\n\t\t       FZA_STATUS_GET_STATE(readw_u(&fp->regs->status)));\n\t\treturn -EIO;\n\t}\n\tstat = readl_u(&ring->stat);\n\tif (stat != FZA_RING_STAT_SUCCESS) {\n\t\tpr_err(\"%s: PARAM command failed!, status %02x, state %x\\n\",\n\t\t       fp->name, stat,\n\t\t       FZA_STATUS_GET_STATE(readw_u(&fp->regs->status)));\n\t\treturn -EIO;\n\t}\n\tpr_debug(\"%s: PARAM: %lums elapsed\\n\", fp->name,\n\t\t (3 * HZ - t) * 1000 / HZ);\n\n\treturn 0;\n}\n\nstatic int fza_close(struct net_device *dev)\n{\n\tstruct fza_private *fp = netdev_priv(dev);\n\tunsigned long flags;\n\tuint state;\n\tlong t;\n\tint i;\n\n\tnetif_stop_queue(dev);\n\tpr_debug(\"%s: queue stopped\\n\", fp->name);\n\n\tdel_timer_sync(&fp->reset_timer);\n\tspin_lock_irqsave(&fp->lock, flags);\n\tfp->state = FZA_STATE_UNINITIALIZED;\n\tfp->state_chg_flag = 0;\n\t \n\twritew_o(FZA_CONTROL_A_SHUT, &fp->regs->control_a);\n\treadw_o(&fp->regs->control_a);\t\t\t \n\tspin_unlock_irqrestore(&fp->lock, flags);\n\n\t \n\tt = wait_event_timeout(fp->state_chg_wait, fp->state_chg_flag,\n\t\t\t       15 * HZ);\n\tstate = FZA_STATUS_GET_STATE(readw_o(&fp->regs->status));\n\tif (fp->state_chg_flag == 0) {\n\t\tpr_err(\"%s: SHUT timed out!, state %x\\n\", fp->name, state);\n\t\treturn -EIO;\n\t}\n\tif (state != FZA_STATE_UNINITIALIZED) {\n\t\tpr_err(\"%s: SHUT failed!, state %x\\n\", fp->name, state);\n\t\treturn -EIO;\n\t}\n\tpr_debug(\"%s: SHUT: %lums elapsed\\n\", fp->name,\n\t\t (15 * HZ - t) * 1000 / HZ);\n\n\tfor (i = 0; i < FZA_RING_RX_SIZE; i++)\n\t\tif (fp->rx_skbuff[i]) {\n\t\t\tdma_unmap_single(fp->bdev, fp->rx_dma[i],\n\t\t\t\t\t FZA_RX_BUFFER_SIZE, DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(fp->rx_skbuff[i]);\n\t\t\tfp->rx_dma[i] = 0;\n\t\t\tfp->rx_skbuff[i] = NULL;\n\t\t}\n\n\treturn 0;\n}\n\nstatic struct net_device_stats *fza_get_stats(struct net_device *dev)\n{\n\tstruct fza_private *fp = netdev_priv(dev);\n\n\treturn &fp->stats;\n}\n\nstatic int fza_probe(struct device *bdev)\n{\n\tstatic const struct net_device_ops netdev_ops = {\n\t\t.ndo_open = fza_open,\n\t\t.ndo_stop = fza_close,\n\t\t.ndo_start_xmit = fza_start_xmit,\n\t\t.ndo_set_rx_mode = fza_set_rx_mode,\n\t\t.ndo_set_mac_address = fza_set_mac_address,\n\t\t.ndo_get_stats = fza_get_stats,\n\t};\n\tstatic int version_printed;\n\tchar rom_rev[4], fw_rev[4], rmc_rev[4];\n\tstruct tc_dev *tdev = to_tc_dev(bdev);\n\tstruct fza_cmd_init __iomem *init;\n\tresource_size_t start, len;\n\tstruct net_device *dev;\n\tstruct fza_private *fp;\n\tuint smt_ver, pmd_type;\n\tvoid __iomem *mmio;\n\tuint hw_addr[2];\n\tint ret, i;\n\n\tif (!version_printed) {\n\t\tpr_info(\"%s\", version);\n\t\tversion_printed = 1;\n\t}\n\n\tdev = alloc_fddidev(sizeof(*fp));\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tSET_NETDEV_DEV(dev, bdev);\n\n\tfp = netdev_priv(dev);\n\tdev_set_drvdata(bdev, dev);\n\n\tfp->bdev = bdev;\n\tfp->name = dev_name(bdev);\n\n\t \n\tstart = tdev->resource.start;\n\tlen = tdev->resource.end - start + 1;\n\tif (!request_mem_region(start, len, dev_name(bdev))) {\n\t\tpr_err(\"%s: cannot reserve MMIO region\\n\", fp->name);\n\t\tret = -EBUSY;\n\t\tgoto err_out_kfree;\n\t}\n\n\t \n\tmmio = ioremap(start, len);\n\tif (!mmio) {\n\t\tpr_err(\"%s: cannot map MMIO\\n\", fp->name);\n\t\tret = -ENOMEM;\n\t\tgoto err_out_resource;\n\t}\n\n\t \n\tswitch (loopback) {\n\tcase FZA_LOOP_NORMAL:\n\tcase FZA_LOOP_INTERN:\n\tcase FZA_LOOP_EXTERN:\n\t\tbreak;\n\tdefault:\n\t\tloopback = FZA_LOOP_NORMAL;\n\t}\n\n\tfp->mmio = mmio;\n\tdev->irq = tdev->interrupt;\n\n\tpr_info(\"%s: DEC FDDIcontroller 700 or 700-C at 0x%08llx, irq %d\\n\",\n\t\tfp->name, (long long)tdev->resource.start, dev->irq);\n\tpr_debug(\"%s: mapped at: 0x%p\\n\", fp->name, mmio);\n\n\tfp->regs = mmio + FZA_REG_BASE;\n\tfp->ring_cmd = mmio + FZA_RING_CMD;\n\tfp->ring_uns = mmio + FZA_RING_UNS;\n\n\tinit_waitqueue_head(&fp->state_chg_wait);\n\tinit_waitqueue_head(&fp->cmd_done_wait);\n\tspin_lock_init(&fp->lock);\n\tfp->int_mask = FZA_MASK_NORMAL;\n\n\ttimer_setup(&fp->reset_timer, fza_reset_timer, 0);\n\n\t \n\tfza_regs_dump(fp);\n\tfza_do_shutdown(fp);\n\n\tret = request_irq(dev->irq, fza_interrupt, IRQF_SHARED, fp->name, dev);\n\tif (ret != 0) {\n\t\tpr_err(\"%s: unable to get IRQ %d!\\n\", fp->name, dev->irq);\n\t\tgoto err_out_map;\n\t}\n\n\t \n\twritew_o(FZA_CONTROL_B_DRIVER, &fp->regs->control_b);\n\n\t \n\tfp->ring_rmc_tx_size = FZA_RING_TX_SIZE;\n\n\tret = fza_reset(fp);\n\tif (ret != 0)\n\t\tgoto err_out_irq;\n\n\tret = fza_init_send(dev, &init);\n\tif (ret != 0)\n\t\tgoto err_out_irq;\n\n\tfza_reads(&init->hw_addr, &hw_addr, sizeof(hw_addr));\n\tdev_addr_set(dev, (u8 *)&hw_addr);\n\n\tfza_reads(&init->rom_rev, &rom_rev, sizeof(rom_rev));\n\tfza_reads(&init->fw_rev, &fw_rev, sizeof(fw_rev));\n\tfza_reads(&init->rmc_rev, &rmc_rev, sizeof(rmc_rev));\n\tfor (i = 3; i >= 0 && rom_rev[i] == ' '; i--)\n\t\trom_rev[i] = 0;\n\tfor (i = 3; i >= 0 && fw_rev[i] == ' '; i--)\n\t\tfw_rev[i] = 0;\n\tfor (i = 3; i >= 0 && rmc_rev[i] == ' '; i--)\n\t\trmc_rev[i] = 0;\n\n\tfp->ring_rmc_tx = mmio + readl_u(&init->rmc_tx);\n\tfp->ring_rmc_tx_size = readl_u(&init->rmc_tx_size);\n\tfp->ring_hst_rx = mmio + readl_u(&init->hst_rx);\n\tfp->ring_hst_rx_size = readl_u(&init->hst_rx_size);\n\tfp->ring_smt_tx = mmio + readl_u(&init->smt_tx);\n\tfp->ring_smt_tx_size = readl_u(&init->smt_tx_size);\n\tfp->ring_smt_rx = mmio + readl_u(&init->smt_rx);\n\tfp->ring_smt_rx_size = readl_u(&init->smt_rx_size);\n\n\tfp->buffer_tx = mmio + FZA_TX_BUFFER_ADDR(readl_u(&init->rmc_tx));\n\n\tfp->t_max = readl_u(&init->def_t_max);\n\tfp->t_req = readl_u(&init->def_t_req);\n\tfp->tvx = readl_u(&init->def_tvx);\n\tfp->lem_threshold = readl_u(&init->lem_threshold);\n\tfza_reads(&init->def_station_id, &fp->station_id,\n\t\t  sizeof(fp->station_id));\n\tfp->rtoken_timeout = readl_u(&init->rtoken_timeout);\n\tfp->ring_purger = readl_u(&init->ring_purger);\n\n\tsmt_ver = readl_u(&init->smt_ver);\n\tpmd_type = readl_u(&init->pmd_type);\n\n\tpr_debug(\"%s: INIT parameters:\\n\", fp->name);\n\tpr_debug(\"        tx_mode: %u\\n\", readl_u(&init->tx_mode));\n\tpr_debug(\"    hst_rx_size: %u\\n\", readl_u(&init->hst_rx_size));\n\tpr_debug(\"        rmc_rev: %.4s\\n\", rmc_rev);\n\tpr_debug(\"        rom_rev: %.4s\\n\", rom_rev);\n\tpr_debug(\"         fw_rev: %.4s\\n\", fw_rev);\n\tpr_debug(\"       mop_type: %u\\n\", readl_u(&init->mop_type));\n\tpr_debug(\"         hst_rx: 0x%08x\\n\", readl_u(&init->hst_rx));\n\tpr_debug(\"         rmc_tx: 0x%08x\\n\", readl_u(&init->rmc_tx));\n\tpr_debug(\"    rmc_tx_size: %u\\n\", readl_u(&init->rmc_tx_size));\n\tpr_debug(\"         smt_tx: 0x%08x\\n\", readl_u(&init->smt_tx));\n\tpr_debug(\"    smt_tx_size: %u\\n\", readl_u(&init->smt_tx_size));\n\tpr_debug(\"         smt_rx: 0x%08x\\n\", readl_u(&init->smt_rx));\n\tpr_debug(\"    smt_rx_size: %u\\n\", readl_u(&init->smt_rx_size));\n\t \n\tpr_debug(\"        hw_addr: 0x%02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n\t\t (readl_u(&init->hw_addr[0]) >> 0) & 0xff,\n\t\t (readl_u(&init->hw_addr[0]) >> 8) & 0xff,\n\t\t (readl_u(&init->hw_addr[0]) >> 16) & 0xff,\n\t\t (readl_u(&init->hw_addr[0]) >> 24) & 0xff,\n\t\t (readl_u(&init->hw_addr[1]) >> 0) & 0xff,\n\t\t (readl_u(&init->hw_addr[1]) >> 8) & 0xff,\n\t\t (readl_u(&init->hw_addr[1]) >> 16) & 0xff,\n\t\t (readl_u(&init->hw_addr[1]) >> 24) & 0xff);\n\tpr_debug(\"      def_t_req: %u\\n\", readl_u(&init->def_t_req));\n\tpr_debug(\"        def_tvx: %u\\n\", readl_u(&init->def_tvx));\n\tpr_debug(\"      def_t_max: %u\\n\", readl_u(&init->def_t_max));\n\tpr_debug(\"  lem_threshold: %u\\n\", readl_u(&init->lem_threshold));\n\t \n\tpr_debug(\" def_station_id: 0x%02x%02x%02x%02x%02x%02x%02x%02x\\n\",\n\t\t (readl_u(&init->def_station_id[0]) >> 0) & 0xff,\n\t\t (readl_u(&init->def_station_id[0]) >> 8) & 0xff,\n\t\t (readl_u(&init->def_station_id[0]) >> 16) & 0xff,\n\t\t (readl_u(&init->def_station_id[0]) >> 24) & 0xff,\n\t\t (readl_u(&init->def_station_id[1]) >> 0) & 0xff,\n\t\t (readl_u(&init->def_station_id[1]) >> 8) & 0xff,\n\t\t (readl_u(&init->def_station_id[1]) >> 16) & 0xff,\n\t\t (readl_u(&init->def_station_id[1]) >> 24) & 0xff);\n\tpr_debug(\"   pmd_type_alt: %u\\n\", readl_u(&init->pmd_type_alt));\n\tpr_debug(\"        smt_ver: %u\\n\", readl_u(&init->smt_ver));\n\tpr_debug(\" rtoken_timeout: %u\\n\", readl_u(&init->rtoken_timeout));\n\tpr_debug(\"    ring_purger: %u\\n\", readl_u(&init->ring_purger));\n\tpr_debug(\"    smt_ver_max: %u\\n\", readl_u(&init->smt_ver_max));\n\tpr_debug(\"    smt_ver_min: %u\\n\", readl_u(&init->smt_ver_min));\n\tpr_debug(\"       pmd_type: %u\\n\", readl_u(&init->pmd_type));\n\n\tpr_info(\"%s: model %s, address %pMF\\n\",\n\t\tfp->name,\n\t\tpmd_type == FZA_PMD_TYPE_TW ?\n\t\t\t\"700-C (DEFZA-CA), ThinWire PMD selected\" :\n\t\t\tpmd_type == FZA_PMD_TYPE_STP ?\n\t\t\t\t\"700-C (DEFZA-CA), STP PMD selected\" :\n\t\t\t\t\"700 (DEFZA-AA), MMF PMD\",\n\t\tdev->dev_addr);\n\tpr_info(\"%s: ROM rev. %.4s, firmware rev. %.4s, RMC rev. %.4s, \"\n\t\t\"SMT ver. %u\\n\", fp->name, rom_rev, fw_rev, rmc_rev, smt_ver);\n\n\t \n\tret = fza_close(dev);\n\tif (ret != 0)\n\t\tgoto err_out_irq;\n\n\t \n\tdev->netdev_ops = &netdev_ops;\n\n\tret = register_netdev(dev);\n\tif (ret != 0)\n\t\tgoto err_out_irq;\n\n\tpr_info(\"%s: registered as %s\\n\", fp->name, dev->name);\n\tfp->name = (const char *)dev->name;\n\n\tget_device(bdev);\n\treturn 0;\n\nerr_out_irq:\n\tdel_timer_sync(&fp->reset_timer);\n\tfza_do_shutdown(fp);\n\tfree_irq(dev->irq, dev);\n\nerr_out_map:\n\tiounmap(mmio);\n\nerr_out_resource:\n\trelease_mem_region(start, len);\n\nerr_out_kfree:\n\tpr_err(\"%s: initialization failure, aborting!\\n\", fp->name);\n\tfree_netdev(dev);\n\treturn ret;\n}\n\nstatic int fza_remove(struct device *bdev)\n{\n\tstruct net_device *dev = dev_get_drvdata(bdev);\n\tstruct fza_private *fp = netdev_priv(dev);\n\tstruct tc_dev *tdev = to_tc_dev(bdev);\n\tresource_size_t start, len;\n\n\tput_device(bdev);\n\n\tunregister_netdev(dev);\n\n\tdel_timer_sync(&fp->reset_timer);\n\tfza_do_shutdown(fp);\n\tfree_irq(dev->irq, dev);\n\n\tiounmap(fp->mmio);\n\n\tstart = tdev->resource.start;\n\tlen = tdev->resource.end - start + 1;\n\trelease_mem_region(start, len);\n\n\tfree_netdev(dev);\n\n\treturn 0;\n}\n\nstatic struct tc_device_id const fza_tc_table[] = {\n\t{ \"DEC     \", \"PMAF-AA \" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(tc, fza_tc_table);\n\nstatic struct tc_driver fza_driver = {\n\t.id_table\t= fza_tc_table,\n\t.driver\t\t= {\n\t\t.name\t= \"defza\",\n\t\t.bus\t= &tc_bus_type,\n\t\t.probe\t= fza_probe,\n\t\t.remove\t= fza_remove,\n\t},\n};\n\nstatic int fza_init(void)\n{\n\treturn tc_register_driver(&fza_driver);\n}\n\nstatic void fza_exit(void)\n{\n\ttc_unregister_driver(&fza_driver);\n}\n\nmodule_init(fza_init);\nmodule_exit(fza_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}