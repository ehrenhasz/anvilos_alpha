{
  "module_name": "defxx.c",
  "hash_id": "77fe954b0c22794ee45f7a1a2f19f8eb727b20828f2d98e300e164dd0193f5ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/fddi/defxx.c",
  "human_readable_source": " \n\n \n#include <linux/bitops.h>\n#include <linux/compiler.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/eisa.h>\n#include <linux/errno.h>\n#include <linux/fddidevice.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/pci.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/tc.h>\n\n#include <asm/byteorder.h>\n#include <asm/io.h>\n\n#include \"defxx.h\"\n\n \n#define DRV_NAME \"defxx\"\n#define DRV_VERSION \"v1.12\"\n#define DRV_RELDATE \"2021/03/10\"\n\nstatic const char version[] =\n\tDRV_NAME \": \" DRV_VERSION \" \" DRV_RELDATE\n\t\"  Lawrence V. Stefani and others\\n\";\n\n#define DYNAMIC_BUFFERS 1\n\n#define SKBUFF_RX_COPYBREAK 200\n \n#define NEW_SKB_SIZE (PI_RCV_DATA_K_SIZE_MAX+128)\n\n#ifdef CONFIG_EISA\n#define DFX_BUS_EISA(dev) (dev->bus == &eisa_bus_type)\n#else\n#define DFX_BUS_EISA(dev) 0\n#endif\n\n#ifdef CONFIG_TC\n#define DFX_BUS_TC(dev) (dev->bus == &tc_bus_type)\n#else\n#define DFX_BUS_TC(dev) 0\n#endif\n\n#if defined(CONFIG_EISA) || defined(CONFIG_PCI)\n#define dfx_use_mmio bp->mmio\n#else\n#define dfx_use_mmio true\n#endif\n\n \n\nstatic void\t\tdfx_bus_init(struct net_device *dev);\nstatic void\t\tdfx_bus_uninit(struct net_device *dev);\nstatic void\t\tdfx_bus_config_check(DFX_board_t *bp);\n\nstatic int\t\tdfx_driver_init(struct net_device *dev,\n\t\t\t\t\tconst char *print_name,\n\t\t\t\t\tresource_size_t bar_start);\nstatic int\t\tdfx_adap_init(DFX_board_t *bp, int get_buffers);\n\nstatic int\t\tdfx_open(struct net_device *dev);\nstatic int\t\tdfx_close(struct net_device *dev);\n\nstatic void\t\tdfx_int_pr_halt_id(DFX_board_t *bp);\nstatic void\t\tdfx_int_type_0_process(DFX_board_t *bp);\nstatic void\t\tdfx_int_common(struct net_device *dev);\nstatic irqreturn_t\tdfx_interrupt(int irq, void *dev_id);\n\nstatic struct\t\tnet_device_stats *dfx_ctl_get_stats(struct net_device *dev);\nstatic void\t\tdfx_ctl_set_multicast_list(struct net_device *dev);\nstatic int\t\tdfx_ctl_set_mac_address(struct net_device *dev, void *addr);\nstatic int\t\tdfx_ctl_update_cam(DFX_board_t *bp);\nstatic int\t\tdfx_ctl_update_filters(DFX_board_t *bp);\n\nstatic int\t\tdfx_hw_dma_cmd_req(DFX_board_t *bp);\nstatic int\t\tdfx_hw_port_ctrl_req(DFX_board_t *bp, PI_UINT32\tcommand, PI_UINT32 data_a, PI_UINT32 data_b, PI_UINT32 *host_data);\nstatic void\t\tdfx_hw_adap_reset(DFX_board_t *bp, PI_UINT32 type);\nstatic int\t\tdfx_hw_adap_state_rd(DFX_board_t *bp);\nstatic int\t\tdfx_hw_dma_uninit(DFX_board_t *bp, PI_UINT32 type);\n\nstatic int\t\tdfx_rcv_init(DFX_board_t *bp, int get_buffers);\nstatic void\t\tdfx_rcv_queue_process(DFX_board_t *bp);\n#ifdef DYNAMIC_BUFFERS\nstatic void\t\tdfx_rcv_flush(DFX_board_t *bp);\n#else\nstatic inline void\tdfx_rcv_flush(DFX_board_t *bp) {}\n#endif\n\nstatic netdev_tx_t dfx_xmt_queue_pkt(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev);\nstatic int\t\tdfx_xmt_done(DFX_board_t *bp);\nstatic void\t\tdfx_xmt_flush(DFX_board_t *bp);\n\n \n\nstatic struct pci_driver dfx_pci_driver;\nstatic struct eisa_driver dfx_eisa_driver;\nstatic struct tc_driver dfx_tc_driver;\n\n\n \n\nstatic inline void dfx_writel(DFX_board_t *bp, int offset, u32 data)\n{\n\twritel(data, bp->base.mem + offset);\n\tmb();\n}\n\nstatic inline void dfx_outl(DFX_board_t *bp, int offset, u32 data)\n{\n\toutl(data, bp->base.port + offset);\n}\n\nstatic void dfx_port_write_long(DFX_board_t *bp, int offset, u32 data)\n{\n\tstruct device __maybe_unused *bdev = bp->bus_dev;\n\n\tif (dfx_use_mmio)\n\t\tdfx_writel(bp, offset, data);\n\telse\n\t\tdfx_outl(bp, offset, data);\n}\n\n\nstatic inline void dfx_readl(DFX_board_t *bp, int offset, u32 *data)\n{\n\tmb();\n\t*data = readl(bp->base.mem + offset);\n}\n\nstatic inline void dfx_inl(DFX_board_t *bp, int offset, u32 *data)\n{\n\t*data = inl(bp->base.port + offset);\n}\n\nstatic void dfx_port_read_long(DFX_board_t *bp, int offset, u32 *data)\n{\n\tstruct device __maybe_unused *bdev = bp->bus_dev;\n\n\tif (dfx_use_mmio)\n\t\tdfx_readl(bp, offset, data);\n\telse\n\t\tdfx_inl(bp, offset, data);\n}\n\n\n \nstatic void dfx_get_bars(DFX_board_t *bp,\n\t\t\t resource_size_t *bar_start, resource_size_t *bar_len)\n{\n\tstruct device *bdev = bp->bus_dev;\n\tint dfx_bus_pci = dev_is_pci(bdev);\n\tint dfx_bus_eisa = DFX_BUS_EISA(bdev);\n\tint dfx_bus_tc = DFX_BUS_TC(bdev);\n\n\tif (dfx_bus_pci) {\n\t\tint num = dfx_use_mmio ? 0 : 1;\n\n\t\tbar_start[0] = pci_resource_start(to_pci_dev(bdev), num);\n\t\tbar_len[0] = pci_resource_len(to_pci_dev(bdev), num);\n\t\tbar_start[2] = bar_start[1] = 0;\n\t\tbar_len[2] = bar_len[1] = 0;\n\t}\n\tif (dfx_bus_eisa) {\n\t\tunsigned long base_addr = to_eisa_device(bdev)->base_addr;\n\t\tresource_size_t bar_lo;\n\t\tresource_size_t bar_hi;\n\n\t\tif (dfx_use_mmio) {\n\t\t\tbar_lo = inb(base_addr + PI_ESIC_K_MEM_ADD_LO_CMP_2);\n\t\t\tbar_lo <<= 8;\n\t\t\tbar_lo |= inb(base_addr + PI_ESIC_K_MEM_ADD_LO_CMP_1);\n\t\t\tbar_lo <<= 8;\n\t\t\tbar_lo |= inb(base_addr + PI_ESIC_K_MEM_ADD_LO_CMP_0);\n\t\t\tbar_lo <<= 8;\n\t\t\tbar_start[0] = bar_lo;\n\t\t\tbar_hi = inb(base_addr + PI_ESIC_K_MEM_ADD_HI_CMP_2);\n\t\t\tbar_hi <<= 8;\n\t\t\tbar_hi |= inb(base_addr + PI_ESIC_K_MEM_ADD_HI_CMP_1);\n\t\t\tbar_hi <<= 8;\n\t\t\tbar_hi |= inb(base_addr + PI_ESIC_K_MEM_ADD_HI_CMP_0);\n\t\t\tbar_hi <<= 8;\n\t\t\tbar_len[0] = ((bar_hi - bar_lo) | PI_MEM_ADD_MASK_M) +\n\t\t\t\t     1;\n\t\t} else {\n\t\t\tbar_start[0] = base_addr;\n\t\t\tbar_len[0] = PI_ESIC_K_CSR_IO_LEN;\n\t\t}\n\t\tbar_start[1] = base_addr + PI_DEFEA_K_BURST_HOLDOFF;\n\t\tbar_len[1] = PI_ESIC_K_BURST_HOLDOFF_LEN;\n\t\tbar_start[2] = base_addr + PI_ESIC_K_ESIC_CSR;\n\t\tbar_len[2] = PI_ESIC_K_ESIC_CSR_LEN;\n\t}\n\tif (dfx_bus_tc) {\n\t\tbar_start[0] = to_tc_dev(bdev)->resource.start +\n\t\t\t       PI_TC_K_CSR_OFFSET;\n\t\tbar_len[0] = PI_TC_K_CSR_LEN;\n\t\tbar_start[2] = bar_start[1] = 0;\n\t\tbar_len[2] = bar_len[1] = 0;\n\t}\n}\n\nstatic const struct net_device_ops dfx_netdev_ops = {\n\t.ndo_open\t\t= dfx_open,\n\t.ndo_stop\t\t= dfx_close,\n\t.ndo_start_xmit\t\t= dfx_xmt_queue_pkt,\n\t.ndo_get_stats\t\t= dfx_ctl_get_stats,\n\t.ndo_set_rx_mode\t= dfx_ctl_set_multicast_list,\n\t.ndo_set_mac_address\t= dfx_ctl_set_mac_address,\n};\n\nstatic void dfx_register_res_err(const char *print_name, bool mmio,\n\t\t\t\t unsigned long start, unsigned long len)\n{\n\tpr_err(\"%s: Cannot reserve %s resource 0x%lx @ 0x%lx, aborting\\n\",\n\t       print_name, mmio ? \"MMIO\" : \"I/O\", len, start);\n}\n\n \nstatic int dfx_register(struct device *bdev)\n{\n\tstatic int version_disp;\n\tint dfx_bus_pci = dev_is_pci(bdev);\n\tint dfx_bus_eisa = DFX_BUS_EISA(bdev);\n\tconst char *print_name = dev_name(bdev);\n\tstruct net_device *dev;\n\tDFX_board_t\t  *bp;\t\t\t \n\tresource_size_t bar_start[3] = {0};\t \n\tresource_size_t bar_len[3] = {0};\t \n\tint alloc_size;\t\t\t\t \n\tstruct resource *region;\n\tint err = 0;\n\n\tif (!version_disp) {\t \n\t\tversion_disp = 1;\t \n\t\tprintk(version);\t \n\t}\n\n\tdev = alloc_fddidev(sizeof(*bp));\n\tif (!dev) {\n\t\tprintk(KERN_ERR \"%s: Unable to allocate fddidev, aborting\\n\",\n\t\t       print_name);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (dfx_bus_pci) {\n\t\terr = pci_enable_device(to_pci_dev(bdev));\n\t\tif (err) {\n\t\t\tpr_err(\"%s: Cannot enable PCI device, aborting\\n\",\n\t\t\t       print_name);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tSET_NETDEV_DEV(dev, bdev);\n\n\tbp = netdev_priv(dev);\n\tbp->bus_dev = bdev;\n\tdev_set_drvdata(bdev, dev);\n\n\tbp->mmio = true;\n\n\tdfx_get_bars(bp, bar_start, bar_len);\n\tif (bar_len[0] == 0 ||\n\t    (dfx_bus_eisa && dfx_use_mmio && bar_start[0] == 0)) {\n\t\tbp->mmio = false;\n\t\tdfx_get_bars(bp, bar_start, bar_len);\n\t}\n\n\tif (dfx_use_mmio) {\n\t\tregion = request_mem_region(bar_start[0], bar_len[0],\n\t\t\t\t\t    bdev->driver->name);\n\t\tif (!region && (dfx_bus_eisa || dfx_bus_pci)) {\n\t\t\tbp->mmio = false;\n\t\t\tdfx_get_bars(bp, bar_start, bar_len);\n\t\t}\n\t}\n\tif (!dfx_use_mmio)\n\t\tregion = request_region(bar_start[0], bar_len[0],\n\t\t\t\t\tbdev->driver->name);\n\tif (!region) {\n\t\tdfx_register_res_err(print_name, dfx_use_mmio,\n\t\t\t\t     bar_start[0], bar_len[0]);\n\t\terr = -EBUSY;\n\t\tgoto err_out_disable;\n\t}\n\tif (bar_start[1] != 0) {\n\t\tregion = request_region(bar_start[1], bar_len[1],\n\t\t\t\t\tbdev->driver->name);\n\t\tif (!region) {\n\t\t\tdfx_register_res_err(print_name, 0,\n\t\t\t\t\t     bar_start[1], bar_len[1]);\n\t\t\terr = -EBUSY;\n\t\t\tgoto err_out_csr_region;\n\t\t}\n\t}\n\tif (bar_start[2] != 0) {\n\t\tregion = request_region(bar_start[2], bar_len[2],\n\t\t\t\t\tbdev->driver->name);\n\t\tif (!region) {\n\t\t\tdfx_register_res_err(print_name, 0,\n\t\t\t\t\t     bar_start[2], bar_len[2]);\n\t\t\terr = -EBUSY;\n\t\t\tgoto err_out_bh_region;\n\t\t}\n\t}\n\n\t \n\tif (dfx_use_mmio) {\n\t\tbp->base.mem = ioremap(bar_start[0], bar_len[0]);\n\t\tif (!bp->base.mem) {\n\t\t\tprintk(KERN_ERR \"%s: Cannot map MMIO\\n\", print_name);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out_esic_region;\n\t\t}\n\t} else {\n\t\tbp->base.port = bar_start[0];\n\t\tdev->base_addr = bar_start[0];\n\t}\n\n\t \n\tdev->netdev_ops\t\t\t= &dfx_netdev_ops;\n\n\tif (dfx_bus_pci)\n\t\tpci_set_master(to_pci_dev(bdev));\n\n\tif (dfx_driver_init(dev, print_name, bar_start[0]) != DFX_K_SUCCESS) {\n\t\terr = -ENODEV;\n\t\tgoto err_out_unmap;\n\t}\n\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto err_out_kfree;\n\n\tprintk(\"%s: registered as %s\\n\", print_name, dev->name);\n\treturn 0;\n\nerr_out_kfree:\n\talloc_size = sizeof(PI_DESCR_BLOCK) +\n\t\t     PI_CMD_REQ_K_SIZE_MAX + PI_CMD_RSP_K_SIZE_MAX +\n#ifndef DYNAMIC_BUFFERS\n\t\t     (bp->rcv_bufs_to_post * PI_RCV_DATA_K_SIZE_MAX) +\n#endif\n\t\t     sizeof(PI_CONSUMER_BLOCK) +\n\t\t     (PI_ALIGN_K_DESC_BLK - 1);\n\tif (bp->kmalloced)\n\t\tdma_free_coherent(bdev, alloc_size,\n\t\t\t\t  bp->kmalloced, bp->kmalloced_dma);\n\nerr_out_unmap:\n\tif (dfx_use_mmio)\n\t\tiounmap(bp->base.mem);\n\nerr_out_esic_region:\n\tif (bar_start[2] != 0)\n\t\trelease_region(bar_start[2], bar_len[2]);\n\nerr_out_bh_region:\n\tif (bar_start[1] != 0)\n\t\trelease_region(bar_start[1], bar_len[1]);\n\nerr_out_csr_region:\n\tif (dfx_use_mmio)\n\t\trelease_mem_region(bar_start[0], bar_len[0]);\n\telse\n\t\trelease_region(bar_start[0], bar_len[0]);\n\nerr_out_disable:\n\tif (dfx_bus_pci)\n\t\tpci_disable_device(to_pci_dev(bdev));\n\nerr_out:\n\tfree_netdev(dev);\n\treturn err;\n}\n\n\n \n\nstatic void dfx_bus_init(struct net_device *dev)\n{\n\tDFX_board_t *bp = netdev_priv(dev);\n\tstruct device *bdev = bp->bus_dev;\n\tint dfx_bus_pci = dev_is_pci(bdev);\n\tint dfx_bus_eisa = DFX_BUS_EISA(bdev);\n\tint dfx_bus_tc = DFX_BUS_TC(bdev);\n\tu8 val;\n\n\tDBG_printk(\"In dfx_bus_init...\\n\");\n\n\t \n\tbp->dev = dev;\n\n\t \n\n\tif (dfx_bus_tc)\n\t\tdev->irq = to_tc_dev(bdev)->interrupt;\n\tif (dfx_bus_eisa) {\n\t\tunsigned long base_addr = to_eisa_device(bdev)->base_addr;\n\n\t\t \n\t\toutb(0, base_addr + PI_ESIC_K_SLOT_CNTRL);\n\n\t\t \n\t\tval = inb(base_addr + PI_ESIC_K_IO_CONFIG_STAT_0);\n\t\tval &= PI_CONFIG_STAT_0_M_IRQ;\n\t\tval >>= PI_CONFIG_STAT_0_V_IRQ;\n\n\t\tswitch (val) {\n\t\tcase PI_CONFIG_STAT_0_IRQ_K_9:\n\t\t\tdev->irq = 9;\n\t\t\tbreak;\n\n\t\tcase PI_CONFIG_STAT_0_IRQ_K_10:\n\t\t\tdev->irq = 10;\n\t\t\tbreak;\n\n\t\tcase PI_CONFIG_STAT_0_IRQ_K_11:\n\t\t\tdev->irq = 11;\n\t\t\tbreak;\n\n\t\tcase PI_CONFIG_STAT_0_IRQ_K_15:\n\t\t\tdev->irq = 15;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\t \n\t\tval = 0;\n\t\toutb(val, base_addr + PI_ESIC_K_IO_ADD_CMP_0_1);\n\t\tval = PI_DEFEA_K_CSR_IO;\n\t\toutb(val, base_addr + PI_ESIC_K_IO_ADD_CMP_0_0);\n\n\t\tval = PI_IO_CMP_M_SLOT;\n\t\toutb(val, base_addr + PI_ESIC_K_IO_ADD_MASK_0_1);\n\t\tval = (PI_ESIC_K_CSR_IO_LEN - 1) & ~3;\n\t\toutb(val, base_addr + PI_ESIC_K_IO_ADD_MASK_0_0);\n\n\t\tval = 0;\n\t\toutb(val, base_addr + PI_ESIC_K_IO_ADD_CMP_1_1);\n\t\tval = PI_DEFEA_K_BURST_HOLDOFF;\n\t\toutb(val, base_addr + PI_ESIC_K_IO_ADD_CMP_1_0);\n\n\t\tval = PI_IO_CMP_M_SLOT;\n\t\toutb(val, base_addr + PI_ESIC_K_IO_ADD_MASK_1_1);\n\t\tval = (PI_ESIC_K_BURST_HOLDOFF_LEN - 1) & ~3;\n\t\toutb(val, base_addr + PI_ESIC_K_IO_ADD_MASK_1_0);\n\n\t\t \n\t\tval = PI_FUNCTION_CNTRL_M_IOCS1;\n\t\tif (dfx_use_mmio)\n\t\t\tval |= PI_FUNCTION_CNTRL_M_MEMCS1;\n\t\telse\n\t\t\tval |= PI_FUNCTION_CNTRL_M_IOCS0;\n\t\toutb(val, base_addr + PI_ESIC_K_FUNCTION_CNTRL);\n\n\t\t \n\t\tval = PI_SLOT_CNTRL_M_ENB;\n\t\toutb(val, base_addr + PI_ESIC_K_SLOT_CNTRL);\n\n\t\t \n\t\tval = inb(base_addr + PI_DEFEA_K_BURST_HOLDOFF);\n\t\tif (dfx_use_mmio)\n\t\t\tval |= PI_BURST_HOLDOFF_M_MEM_MAP;\n\t\telse\n\t\t\tval &= ~PI_BURST_HOLDOFF_M_MEM_MAP;\n\t\toutb(val, base_addr + PI_DEFEA_K_BURST_HOLDOFF);\n\n\t\t \n\t\tval = inb(base_addr + PI_ESIC_K_IO_CONFIG_STAT_0);\n\t\tval |= PI_CONFIG_STAT_0_M_INT_ENB;\n\t\toutb(val, base_addr + PI_ESIC_K_IO_CONFIG_STAT_0);\n\t}\n\tif (dfx_bus_pci) {\n\t\tstruct pci_dev *pdev = to_pci_dev(bdev);\n\n\t\t \n\n\t\tdev->irq = pdev->irq;\n\n\t\t \n\n\t\tpci_read_config_byte(pdev, PCI_LATENCY_TIMER, &val);\n\t\tif (val < PFI_K_LAT_TIMER_MIN) {\n\t\t\tval = PFI_K_LAT_TIMER_DEF;\n\t\t\tpci_write_config_byte(pdev, PCI_LATENCY_TIMER, val);\n\t\t}\n\n\t\t \n\t\tval = PFI_MODE_M_PDQ_INT_ENB | PFI_MODE_M_DMA_ENB;\n\t\tdfx_port_write_long(bp, PFI_K_REG_MODE_CTRL, val);\n\t}\n}\n\n \n\nstatic void dfx_bus_uninit(struct net_device *dev)\n{\n\tDFX_board_t *bp = netdev_priv(dev);\n\tstruct device *bdev = bp->bus_dev;\n\tint dfx_bus_pci = dev_is_pci(bdev);\n\tint dfx_bus_eisa = DFX_BUS_EISA(bdev);\n\tu8 val;\n\n\tDBG_printk(\"In dfx_bus_uninit...\\n\");\n\n\t \n\n\tif (dfx_bus_eisa) {\n\t\tunsigned long base_addr = to_eisa_device(bdev)->base_addr;\n\n\t\t \n\t\tval = inb(base_addr + PI_ESIC_K_IO_CONFIG_STAT_0);\n\t\tval &= ~PI_CONFIG_STAT_0_M_INT_ENB;\n\t\toutb(val, base_addr + PI_ESIC_K_IO_CONFIG_STAT_0);\n\n\t\t \n\t\toutb(0, base_addr + PI_ESIC_K_SLOT_CNTRL);\n\n\t\t \n\t\toutb(0, base_addr + PI_ESIC_K_FUNCTION_CNTRL);\n\t}\n\tif (dfx_bus_pci) {\n\t\t \n\t\tdfx_port_write_long(bp, PFI_K_REG_MODE_CTRL, 0);\n\t}\n}\n\n\n \n\nstatic void dfx_bus_config_check(DFX_board_t *bp)\n{\n\tstruct device __maybe_unused *bdev = bp->bus_dev;\n\tint dfx_bus_eisa = DFX_BUS_EISA(bdev);\n\tint\tstatus;\t\t\t\t \n\tu32\thost_data;\t\t\t \n\n\tDBG_printk(\"In dfx_bus_config_check...\\n\");\n\n\t \n\n\tif (dfx_bus_eisa) {\n\t\t \n\t\tif (to_eisa_device(bdev)->id.driver_data == DEFEA_PROD_ID_2) {\n\t\t\t \n\t\t\tstatus = dfx_hw_port_ctrl_req(bp,\n\t\t\t\t\t\t\t\t\t\t\tPI_PCTRL_M_SUB_CMD,\n\t\t\t\t\t\t\t\t\t\t\tPI_SUB_CMD_K_PDQ_REV_GET,\n\t\t\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\t\t\t&host_data);\n\t\t\tif ((status != DFX_K_SUCCESS) || (host_data == 2))\n\t\t\t\t{\n\t\t\t\t \n\n\t\t\t\t \n\n\t\t\t\tswitch (bp->burst_size)\n\t\t\t\t\t{\n\t\t\t\t\tcase PI_PDATA_B_DMA_BURST_SIZE_32:\n\t\t\t\t\tcase PI_PDATA_B_DMA_BURST_SIZE_16:\n\t\t\t\t\t\tbp->burst_size = PI_PDATA_B_DMA_BURST_SIZE_8;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t \n\n\t\t\t\tbp->full_duplex_enb = PI_SNMP_K_FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n \n\nstatic int dfx_driver_init(struct net_device *dev, const char *print_name,\n\t\t\t   resource_size_t bar_start)\n{\n\tDFX_board_t *bp = netdev_priv(dev);\n\tstruct device *bdev = bp->bus_dev;\n\tint dfx_bus_pci = dev_is_pci(bdev);\n\tint dfx_bus_eisa = DFX_BUS_EISA(bdev);\n\tint dfx_bus_tc = DFX_BUS_TC(bdev);\n\tint alloc_size;\t\t\t \n\tchar *top_v, *curr_v;\t\t \n\tdma_addr_t top_p, curr_p;\t \n\tu32 data;\t\t\t \n\t__le32 le32;\n\tchar *board_name = NULL;\n\n\tDBG_printk(\"In dfx_driver_init...\\n\");\n\n\t \n\n\tdfx_bus_init(dev);\n\n\t \n\n\tbp->full_duplex_enb\t\t= PI_SNMP_K_FALSE;\n\tbp->req_ttrt\t\t\t= 8 * 12500;\t\t \n\tbp->burst_size\t\t\t= PI_PDATA_B_DMA_BURST_SIZE_DEF;\n\tbp->rcv_bufs_to_post\t= RCV_BUFS_DEF;\n\n\t \n\n\tdfx_bus_config_check(bp);\n\n\t \n\n\tdfx_port_write_long(bp, PI_PDQ_K_REG_HOST_INT_ENB, PI_HOST_INT_K_DISABLE_ALL_INTS);\n\n\t \n\n\t(void) dfx_hw_dma_uninit(bp, PI_PDATA_A_RESET_M_SKIP_ST);\n\n\t \n\n\tif (dfx_hw_port_ctrl_req(bp, PI_PCTRL_M_MLA, PI_PDATA_A_MLA_K_LO, 0,\n\t\t\t\t &data) != DFX_K_SUCCESS) {\n\t\tprintk(\"%s: Could not read adapter factory MAC address!\\n\",\n\t\t       print_name);\n\t\treturn DFX_K_FAILURE;\n\t}\n\tle32 = cpu_to_le32(data);\n\tmemcpy(&bp->factory_mac_addr[0], &le32, sizeof(u32));\n\n\tif (dfx_hw_port_ctrl_req(bp, PI_PCTRL_M_MLA, PI_PDATA_A_MLA_K_HI, 0,\n\t\t\t\t &data) != DFX_K_SUCCESS) {\n\t\tprintk(\"%s: Could not read adapter factory MAC address!\\n\",\n\t\t       print_name);\n\t\treturn DFX_K_FAILURE;\n\t}\n\tle32 = cpu_to_le32(data);\n\tmemcpy(&bp->factory_mac_addr[4], &le32, sizeof(u16));\n\n\t \n\n\tdev_addr_set(dev, bp->factory_mac_addr);\n\tif (dfx_bus_tc)\n\t\tboard_name = \"DEFTA\";\n\tif (dfx_bus_eisa)\n\t\tboard_name = \"DEFEA\";\n\tif (dfx_bus_pci)\n\t\tboard_name = \"DEFPA\";\n\tpr_info(\"%s: %s at %s addr = 0x%llx, IRQ = %d, Hardware addr = %pMF\\n\",\n\t\tprint_name, board_name, dfx_use_mmio ? \"MMIO\" : \"I/O\",\n\t\t(long long)bar_start, dev->irq, dev->dev_addr);\n\n\t \n\n\talloc_size = sizeof(PI_DESCR_BLOCK) +\n\t\t\t\t\tPI_CMD_REQ_K_SIZE_MAX +\n\t\t\t\t\tPI_CMD_RSP_K_SIZE_MAX +\n#ifndef DYNAMIC_BUFFERS\n\t\t\t\t\t(bp->rcv_bufs_to_post * PI_RCV_DATA_K_SIZE_MAX) +\n#endif\n\t\t\t\t\tsizeof(PI_CONSUMER_BLOCK) +\n\t\t\t\t\t(PI_ALIGN_K_DESC_BLK - 1);\n\tbp->kmalloced = top_v = dma_alloc_coherent(bp->bus_dev, alloc_size,\n\t\t\t\t\t\t   &bp->kmalloced_dma,\n\t\t\t\t\t\t   GFP_ATOMIC);\n\tif (top_v == NULL)\n\t\treturn DFX_K_FAILURE;\n\n\ttop_p = bp->kmalloced_dma;\t \n\n\t \n\n\tcurr_p = ALIGN(top_p, PI_ALIGN_K_DESC_BLK);\n\tcurr_v = top_v + (curr_p - top_p);\n\n\t \n\n\tbp->descr_block_virt = (PI_DESCR_BLOCK *) curr_v;\n\tbp->descr_block_phys = curr_p;\n\tcurr_v += sizeof(PI_DESCR_BLOCK);\n\tcurr_p += sizeof(PI_DESCR_BLOCK);\n\n\t \n\n\tbp->cmd_req_virt = (PI_DMA_CMD_REQ *) curr_v;\n\tbp->cmd_req_phys = curr_p;\n\tcurr_v += PI_CMD_REQ_K_SIZE_MAX;\n\tcurr_p += PI_CMD_REQ_K_SIZE_MAX;\n\n\t \n\n\tbp->cmd_rsp_virt = (PI_DMA_CMD_RSP *) curr_v;\n\tbp->cmd_rsp_phys = curr_p;\n\tcurr_v += PI_CMD_RSP_K_SIZE_MAX;\n\tcurr_p += PI_CMD_RSP_K_SIZE_MAX;\n\n\t \n\n\tbp->rcv_block_virt = curr_v;\n\tbp->rcv_block_phys = curr_p;\n\n#ifndef DYNAMIC_BUFFERS\n\tcurr_v += (bp->rcv_bufs_to_post * PI_RCV_DATA_K_SIZE_MAX);\n\tcurr_p += (bp->rcv_bufs_to_post * PI_RCV_DATA_K_SIZE_MAX);\n#endif\n\n\t \n\n\tbp->cons_block_virt = (PI_CONSUMER_BLOCK *) curr_v;\n\tbp->cons_block_phys = curr_p;\n\n\t \n\n\tDBG_printk(\"%s: Descriptor block virt = %p, phys = %pad\\n\",\n\t\t   print_name, bp->descr_block_virt, &bp->descr_block_phys);\n\tDBG_printk(\"%s: Command Request buffer virt = %p, phys = %pad\\n\",\n\t\t   print_name, bp->cmd_req_virt, &bp->cmd_req_phys);\n\tDBG_printk(\"%s: Command Response buffer virt = %p, phys = %pad\\n\",\n\t\t   print_name, bp->cmd_rsp_virt, &bp->cmd_rsp_phys);\n\tDBG_printk(\"%s: Receive buffer block virt = %p, phys = %pad\\n\",\n\t\t   print_name, bp->rcv_block_virt, &bp->rcv_block_phys);\n\tDBG_printk(\"%s: Consumer block virt = %p, phys = %pad\\n\",\n\t\t   print_name, bp->cons_block_virt, &bp->cons_block_phys);\n\n\treturn DFX_K_SUCCESS;\n}\n\n\n \n\nstatic int dfx_adap_init(DFX_board_t *bp, int get_buffers)\n\t{\n\tDBG_printk(\"In dfx_adap_init...\\n\");\n\n\t \n\n\tdfx_port_write_long(bp, PI_PDQ_K_REG_HOST_INT_ENB, PI_HOST_INT_K_DISABLE_ALL_INTS);\n\n\t \n\n\tif (dfx_hw_dma_uninit(bp, bp->reset_type) != DFX_K_SUCCESS)\n\t\t{\n\t\tprintk(\"%s: Could not uninitialize/reset adapter!\\n\", bp->dev->name);\n\t\treturn DFX_K_FAILURE;\n\t\t}\n\n\t \n\n\tdfx_port_write_long(bp, PI_PDQ_K_REG_TYPE_0_STATUS, PI_HOST_INT_K_ACK_ALL_TYPE_0);\n\n\t \n\n\tbp->cmd_req_reg.lword\t= 0;\n\tbp->cmd_rsp_reg.lword\t= 0;\n\tbp->rcv_xmt_reg.lword\t= 0;\n\n\t \n\n\tmemset(bp->cons_block_virt, 0, sizeof(PI_CONSUMER_BLOCK));\n\n\t \n\n\tif (dfx_hw_port_ctrl_req(bp,\n\t\t\t\t\t\t\tPI_PCTRL_M_SUB_CMD,\n\t\t\t\t\t\t\tPI_SUB_CMD_K_BURST_SIZE_SET,\n\t\t\t\t\t\t\tbp->burst_size,\n\t\t\t\t\t\t\tNULL) != DFX_K_SUCCESS)\n\t\t{\n\t\tprintk(\"%s: Could not set adapter burst size!\\n\", bp->dev->name);\n\t\treturn DFX_K_FAILURE;\n\t\t}\n\n\t \n\n\tif (dfx_hw_port_ctrl_req(bp,\n\t\t\t\t\t\t\tPI_PCTRL_M_CONS_BLOCK,\n\t\t\t\t\t\t\tbp->cons_block_phys,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tNULL) != DFX_K_SUCCESS)\n\t\t{\n\t\tprintk(\"%s: Could not set consumer block address!\\n\", bp->dev->name);\n\t\treturn DFX_K_FAILURE;\n\t\t}\n\n\t \n\tif (dfx_hw_port_ctrl_req(bp, PI_PCTRL_M_INIT,\n\t\t\t\t (u32)(bp->descr_block_phys |\n\t\t\t\t       PI_PDATA_A_INIT_M_BSWAP_INIT),\n\t\t\t\t 0, NULL) != DFX_K_SUCCESS) {\n\t\tprintk(\"%s: Could not set descriptor block address!\\n\",\n\t\t       bp->dev->name);\n\t\treturn DFX_K_FAILURE;\n\t}\n\n\t \n\n\tbp->cmd_req_virt->cmd_type = PI_CMD_K_CHARS_SET;\n\tbp->cmd_req_virt->char_set.item[0].item_code\t= PI_ITEM_K_FLUSH_TIME;\n\tbp->cmd_req_virt->char_set.item[0].value\t\t= 3;\t \n\tbp->cmd_req_virt->char_set.item[0].item_index\t= 0;\n\tbp->cmd_req_virt->char_set.item[1].item_code\t= PI_ITEM_K_EOL;\n\tif (dfx_hw_dma_cmd_req(bp) != DFX_K_SUCCESS)\n\t\t{\n\t\tprintk(\"%s: DMA command request failed!\\n\", bp->dev->name);\n\t\treturn DFX_K_FAILURE;\n\t\t}\n\n\t \n\n\tbp->cmd_req_virt->cmd_type = PI_CMD_K_SNMP_SET;\n\tbp->cmd_req_virt->snmp_set.item[0].item_code\t= PI_ITEM_K_FDX_ENB_DIS;\n\tbp->cmd_req_virt->snmp_set.item[0].value\t\t= bp->full_duplex_enb;\n\tbp->cmd_req_virt->snmp_set.item[0].item_index\t= 0;\n\tbp->cmd_req_virt->snmp_set.item[1].item_code\t= PI_ITEM_K_MAC_T_REQ;\n\tbp->cmd_req_virt->snmp_set.item[1].value\t\t= bp->req_ttrt;\n\tbp->cmd_req_virt->snmp_set.item[1].item_index\t= 0;\n\tbp->cmd_req_virt->snmp_set.item[2].item_code\t= PI_ITEM_K_EOL;\n\tif (dfx_hw_dma_cmd_req(bp) != DFX_K_SUCCESS)\n\t\t{\n\t\tprintk(\"%s: DMA command request failed!\\n\", bp->dev->name);\n\t\treturn DFX_K_FAILURE;\n\t\t}\n\n\t \n\n\tif (dfx_ctl_update_cam(bp) != DFX_K_SUCCESS)\n\t\t{\n\t\tprintk(\"%s: Adapter CAM update failed!\\n\", bp->dev->name);\n\t\treturn DFX_K_FAILURE;\n\t\t}\n\n\t \n\n\tif (dfx_ctl_update_filters(bp) != DFX_K_SUCCESS)\n\t\t{\n\t\tprintk(\"%s: Adapter filters update failed!\\n\", bp->dev->name);\n\t\treturn DFX_K_FAILURE;\n\t\t}\n\n\t \n\n\tif (get_buffers)\n\t\tdfx_rcv_flush(bp);\n\n\t \n\n\tif (dfx_rcv_init(bp, get_buffers))\n\t        {\n\t\tprintk(\"%s: Receive buffer allocation failed\\n\", bp->dev->name);\n\t\tif (get_buffers)\n\t\t\tdfx_rcv_flush(bp);\n\t\treturn DFX_K_FAILURE;\n\t\t}\n\n\t \n\n\tbp->cmd_req_virt->cmd_type = PI_CMD_K_START;\n\tif (dfx_hw_dma_cmd_req(bp) != DFX_K_SUCCESS)\n\t\t{\n\t\tprintk(\"%s: Start command failed\\n\", bp->dev->name);\n\t\tif (get_buffers)\n\t\t\tdfx_rcv_flush(bp);\n\t\treturn DFX_K_FAILURE;\n\t\t}\n\n\t \n\n\tdfx_port_write_long(bp, PI_PDQ_K_REG_HOST_INT_ENB, PI_HOST_INT_K_ENABLE_DEF_INTS);\n\treturn DFX_K_SUCCESS;\n\t}\n\n\n \n\nstatic int dfx_open(struct net_device *dev)\n{\n\tDFX_board_t *bp = netdev_priv(dev);\n\tint ret;\n\n\tDBG_printk(\"In dfx_open...\\n\");\n\n\t \n\n\tret = request_irq(dev->irq, dfx_interrupt, IRQF_SHARED, dev->name,\n\t\t\t  dev);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"%s: Requested IRQ %d is busy\\n\", dev->name, dev->irq);\n\t\treturn ret;\n\t}\n\n\t \n\n\tdev_addr_set(dev, bp->factory_mac_addr);\n\n\t \n\n\tmemset(bp->uc_table, 0, sizeof(bp->uc_table));\n\tmemset(bp->mc_table, 0, sizeof(bp->mc_table));\n\tbp->uc_count = 0;\n\tbp->mc_count = 0;\n\n\t \n\n\tbp->ind_group_prom\t= PI_FSTATE_K_BLOCK;\n\tbp->group_prom\t\t= PI_FSTATE_K_BLOCK;\n\n\tspin_lock_init(&bp->lock);\n\n\t \n\n\tbp->reset_type = PI_PDATA_A_RESET_M_SKIP_ST;\t \n\tif (dfx_adap_init(bp, 1) != DFX_K_SUCCESS)\n\t{\n\t\tprintk(KERN_ERR \"%s: Adapter open failed!\\n\", dev->name);\n\t\tfree_irq(dev->irq, dev);\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tnetif_start_queue(dev);\n\treturn 0;\n}\n\n\n \n\nstatic int dfx_close(struct net_device *dev)\n{\n\tDFX_board_t *bp = netdev_priv(dev);\n\n\tDBG_printk(\"In dfx_close...\\n\");\n\n\t \n\n\tdfx_port_write_long(bp, PI_PDQ_K_REG_HOST_INT_ENB, PI_HOST_INT_K_DISABLE_ALL_INTS);\n\n\t \n\n\t(void) dfx_hw_dma_uninit(bp, PI_PDATA_A_RESET_M_SKIP_ST);\n\n\t \n\n\tdfx_xmt_flush(bp);\n\n\t \n\n\tbp->cmd_req_reg.lword\t= 0;\n\tbp->cmd_rsp_reg.lword\t= 0;\n\tbp->rcv_xmt_reg.lword\t= 0;\n\n\t \n\n\tmemset(bp->cons_block_virt, 0, sizeof(PI_CONSUMER_BLOCK));\n\n\t \n\n\tdfx_rcv_flush(bp);\n\n\t \n\n\tnetif_stop_queue(dev);\n\n\t \n\n\tfree_irq(dev->irq, dev);\n\n\treturn 0;\n}\n\n\n \n\nstatic void dfx_int_pr_halt_id(DFX_board_t\t*bp)\n\t{\n\tPI_UINT32\tport_status;\t\t\t \n\tPI_UINT32\thalt_id;\t\t\t\t \n\n\t \n\n\tdfx_port_read_long(bp, PI_PDQ_K_REG_PORT_STATUS, &port_status);\n\n\t \n\n\thalt_id = (port_status & PI_PSTATUS_M_HALT_ID) >> PI_PSTATUS_V_HALT_ID;\n\tswitch (halt_id)\n\t\t{\n\t\tcase PI_HALT_ID_K_SELFTEST_TIMEOUT:\n\t\t\tprintk(\"%s: Halt ID: Selftest Timeout\\n\", bp->dev->name);\n\t\t\tbreak;\n\n\t\tcase PI_HALT_ID_K_PARITY_ERROR:\n\t\t\tprintk(\"%s: Halt ID: Host Bus Parity Error\\n\", bp->dev->name);\n\t\t\tbreak;\n\n\t\tcase PI_HALT_ID_K_HOST_DIR_HALT:\n\t\t\tprintk(\"%s: Halt ID: Host-Directed Halt\\n\", bp->dev->name);\n\t\t\tbreak;\n\n\t\tcase PI_HALT_ID_K_SW_FAULT:\n\t\t\tprintk(\"%s: Halt ID: Adapter Software Fault\\n\", bp->dev->name);\n\t\t\tbreak;\n\n\t\tcase PI_HALT_ID_K_HW_FAULT:\n\t\t\tprintk(\"%s: Halt ID: Adapter Hardware Fault\\n\", bp->dev->name);\n\t\t\tbreak;\n\n\t\tcase PI_HALT_ID_K_PC_TRACE:\n\t\t\tprintk(\"%s: Halt ID: FDDI Network PC Trace Path Test\\n\", bp->dev->name);\n\t\t\tbreak;\n\n\t\tcase PI_HALT_ID_K_DMA_ERROR:\n\t\t\tprintk(\"%s: Halt ID: Adapter DMA Error\\n\", bp->dev->name);\n\t\t\tbreak;\n\n\t\tcase PI_HALT_ID_K_IMAGE_CRC_ERROR:\n\t\t\tprintk(\"%s: Halt ID: Firmware Image CRC Error\\n\", bp->dev->name);\n\t\t\tbreak;\n\n\t\tcase PI_HALT_ID_K_BUS_EXCEPTION:\n\t\t\tprintk(\"%s: Halt ID: 68000 Bus Exception\\n\", bp->dev->name);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tprintk(\"%s: Halt ID: Unknown (code = %X)\\n\", bp->dev->name, halt_id);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n \n\nstatic void dfx_int_type_0_process(DFX_board_t\t*bp)\n\n\t{\n\tPI_UINT32\ttype_0_status;\t\t \n\tPI_UINT32\tstate;\t\t\t\t \n\n\t \n\n\tdfx_port_read_long(bp, PI_PDQ_K_REG_TYPE_0_STATUS, &type_0_status);\n\tdfx_port_write_long(bp, PI_PDQ_K_REG_TYPE_0_STATUS, type_0_status);\n\n\t \n\n\tif (type_0_status & (PI_TYPE_0_STAT_M_NXM |\n\t\t\t\t\t\t\tPI_TYPE_0_STAT_M_PM_PAR_ERR |\n\t\t\t\t\t\t\tPI_TYPE_0_STAT_M_BUS_PAR_ERR))\n\t\t{\n\t\t \n\n\t\tif (type_0_status & PI_TYPE_0_STAT_M_NXM)\n\t\t\tprintk(\"%s: Non-Existent Memory Access Error\\n\", bp->dev->name);\n\n\t\t \n\n\t\tif (type_0_status & PI_TYPE_0_STAT_M_PM_PAR_ERR)\n\t\t\tprintk(\"%s: Packet Memory Parity Error\\n\", bp->dev->name);\n\n\t\t \n\n\t\tif (type_0_status & PI_TYPE_0_STAT_M_BUS_PAR_ERR)\n\t\t\tprintk(\"%s: Host Bus Parity Error\\n\", bp->dev->name);\n\n\t\t \n\n\t\tbp->link_available = PI_K_FALSE;\t \n\t\tbp->reset_type = 0;\t\t\t\t\t \n\t\tprintk(\"%s: Resetting adapter...\\n\", bp->dev->name);\n\t\tif (dfx_adap_init(bp, 0) != DFX_K_SUCCESS)\n\t\t\t{\n\t\t\tprintk(\"%s: Adapter reset failed!  Disabling adapter interrupts.\\n\", bp->dev->name);\n\t\t\tdfx_port_write_long(bp, PI_PDQ_K_REG_HOST_INT_ENB, PI_HOST_INT_K_DISABLE_ALL_INTS);\n\t\t\treturn;\n\t\t\t}\n\t\tprintk(\"%s: Adapter reset successful!\\n\", bp->dev->name);\n\t\treturn;\n\t\t}\n\n\t \n\n\tif (type_0_status & PI_TYPE_0_STAT_M_XMT_FLUSH)\n\t\t{\n\t\t \n\n\t\tbp->link_available = PI_K_FALSE;\t\t \n\t\tdfx_xmt_flush(bp);\t\t\t\t\t\t \n\t\t(void) dfx_hw_port_ctrl_req(bp,\n\t\t\t\t\t\t\t\t\tPI_PCTRL_M_XMT_DATA_FLUSH_DONE,\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\tNULL);\n\t\t}\n\n\t \n\n\tif (type_0_status & PI_TYPE_0_STAT_M_STATE_CHANGE)\n\t\t{\n\t\t \n\n\t\tstate = dfx_hw_adap_state_rd(bp);\t \n\t\tif (state == PI_STATE_K_HALTED)\n\t\t\t{\n\t\t\t \n\n\t\t\tprintk(\"%s: Controller has transitioned to HALTED state!\\n\", bp->dev->name);\n\t\t\tdfx_int_pr_halt_id(bp);\t\t\t \n\n\t\t\t \n\n\t\t\tbp->link_available = PI_K_FALSE;\t \n\t\t\tbp->reset_type = 0;\t\t\t\t\t \n\t\t\tprintk(\"%s: Resetting adapter...\\n\", bp->dev->name);\n\t\t\tif (dfx_adap_init(bp, 0) != DFX_K_SUCCESS)\n\t\t\t\t{\n\t\t\t\tprintk(\"%s: Adapter reset failed!  Disabling adapter interrupts.\\n\", bp->dev->name);\n\t\t\t\tdfx_port_write_long(bp, PI_PDQ_K_REG_HOST_INT_ENB, PI_HOST_INT_K_DISABLE_ALL_INTS);\n\t\t\t\treturn;\n\t\t\t\t}\n\t\t\tprintk(\"%s: Adapter reset successful!\\n\", bp->dev->name);\n\t\t\t}\n\t\telse if (state == PI_STATE_K_LINK_AVAIL)\n\t\t\t{\n\t\t\tbp->link_available = PI_K_TRUE;\t\t \n\t\t\t}\n\t\t}\n\t}\n\n\n \n\nstatic void dfx_int_common(struct net_device *dev)\n{\n\tDFX_board_t *bp = netdev_priv(dev);\n\tPI_UINT32\tport_status;\t\t \n\n\t \n\n\tif(dfx_xmt_done(bp))\t\t\t\t \n\t\tnetif_wake_queue(dev);\n\n\t \n\n\tdfx_rcv_queue_process(bp);\t\t \n\n\t \n\n\tdfx_port_write_long(bp, PI_PDQ_K_REG_TYPE_2_PROD, bp->rcv_xmt_reg.lword);\n\n\t \n\n\tdfx_port_read_long(bp, PI_PDQ_K_REG_PORT_STATUS, &port_status);\n\n\t \n\n\tif (port_status & PI_PSTATUS_M_TYPE_0_PENDING)\n\t\tdfx_int_type_0_process(bp);\t \n\t}\n\n\n \n\nstatic irqreturn_t dfx_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tDFX_board_t *bp = netdev_priv(dev);\n\tstruct device *bdev = bp->bus_dev;\n\tint dfx_bus_pci = dev_is_pci(bdev);\n\tint dfx_bus_eisa = DFX_BUS_EISA(bdev);\n\tint dfx_bus_tc = DFX_BUS_TC(bdev);\n\n\t \n\n\tif (dfx_bus_pci) {\n\t\tu32 status;\n\n\t\tdfx_port_read_long(bp, PFI_K_REG_STATUS, &status);\n\t\tif (!(status & PFI_STATUS_M_PDQ_INT))\n\t\t\treturn IRQ_NONE;\n\n\t\tspin_lock(&bp->lock);\n\n\t\t \n\t\tdfx_port_write_long(bp, PFI_K_REG_MODE_CTRL,\n\t\t\t\t    PFI_MODE_M_DMA_ENB);\n\n\t\t \n\t\tdfx_int_common(dev);\n\n\t\t \n\t\tdfx_port_write_long(bp, PFI_K_REG_STATUS,\n\t\t\t\t    PFI_STATUS_M_PDQ_INT);\n\t\tdfx_port_write_long(bp, PFI_K_REG_MODE_CTRL,\n\t\t\t\t    (PFI_MODE_M_PDQ_INT_ENB |\n\t\t\t\t     PFI_MODE_M_DMA_ENB));\n\n\t\tspin_unlock(&bp->lock);\n\t}\n\tif (dfx_bus_eisa) {\n\t\tunsigned long base_addr = to_eisa_device(bdev)->base_addr;\n\t\tu8 status;\n\n\t\tstatus = inb(base_addr + PI_ESIC_K_IO_CONFIG_STAT_0);\n\t\tif (!(status & PI_CONFIG_STAT_0_M_PEND))\n\t\t\treturn IRQ_NONE;\n\n\t\tspin_lock(&bp->lock);\n\n\t\t \n\t\tstatus &= ~PI_CONFIG_STAT_0_M_INT_ENB;\n\t\toutb(status, base_addr + PI_ESIC_K_IO_CONFIG_STAT_0);\n\n\t\t \n\t\tdfx_int_common(dev);\n\n\t\t \n\t\tstatus = inb(base_addr + PI_ESIC_K_IO_CONFIG_STAT_0);\n\t\tstatus |= PI_CONFIG_STAT_0_M_INT_ENB;\n\t\toutb(status, base_addr + PI_ESIC_K_IO_CONFIG_STAT_0);\n\n\t\tspin_unlock(&bp->lock);\n\t}\n\tif (dfx_bus_tc) {\n\t\tu32 status;\n\n\t\tdfx_port_read_long(bp, PI_PDQ_K_REG_PORT_STATUS, &status);\n\t\tif (!(status & (PI_PSTATUS_M_RCV_DATA_PENDING |\n\t\t\t\tPI_PSTATUS_M_XMT_DATA_PENDING |\n\t\t\t\tPI_PSTATUS_M_SMT_HOST_PENDING |\n\t\t\t\tPI_PSTATUS_M_UNSOL_PENDING |\n\t\t\t\tPI_PSTATUS_M_CMD_RSP_PENDING |\n\t\t\t\tPI_PSTATUS_M_CMD_REQ_PENDING |\n\t\t\t\tPI_PSTATUS_M_TYPE_0_PENDING)))\n\t\t\treturn IRQ_NONE;\n\n\t\tspin_lock(&bp->lock);\n\n\t\t \n\t\tdfx_int_common(dev);\n\n\t\tspin_unlock(&bp->lock);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n\n \n\nstatic struct net_device_stats *dfx_ctl_get_stats(struct net_device *dev)\n\t{\n\tDFX_board_t *bp = netdev_priv(dev);\n\n\t \n\n\tbp->stats.gen.rx_packets = bp->rcv_total_frames;\n\tbp->stats.gen.tx_packets = bp->xmt_total_frames;\n\tbp->stats.gen.rx_bytes   = bp->rcv_total_bytes;\n\tbp->stats.gen.tx_bytes   = bp->xmt_total_bytes;\n\tbp->stats.gen.rx_errors  = bp->rcv_crc_errors +\n\t\t\t\t   bp->rcv_frame_status_errors +\n\t\t\t\t   bp->rcv_length_errors;\n\tbp->stats.gen.tx_errors  = bp->xmt_length_errors;\n\tbp->stats.gen.rx_dropped = bp->rcv_discards;\n\tbp->stats.gen.tx_dropped = bp->xmt_discards;\n\tbp->stats.gen.multicast  = bp->rcv_multicast_frames;\n\tbp->stats.gen.collisions = 0;\t\t \n\n\t \n\n\tbp->cmd_req_virt->cmd_type = PI_CMD_K_SMT_MIB_GET;\n\tif (dfx_hw_dma_cmd_req(bp) != DFX_K_SUCCESS)\n\t\treturn (struct net_device_stats *)&bp->stats;\n\n\t \n\n\tmemcpy(bp->stats.smt_station_id, &bp->cmd_rsp_virt->smt_mib_get.smt_station_id, sizeof(bp->cmd_rsp_virt->smt_mib_get.smt_station_id));\n\tbp->stats.smt_op_version_id\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.smt_op_version_id;\n\tbp->stats.smt_hi_version_id\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.smt_hi_version_id;\n\tbp->stats.smt_lo_version_id\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.smt_lo_version_id;\n\tmemcpy(bp->stats.smt_user_data, &bp->cmd_rsp_virt->smt_mib_get.smt_user_data, sizeof(bp->cmd_rsp_virt->smt_mib_get.smt_user_data));\n\tbp->stats.smt_mib_version_id\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.smt_mib_version_id;\n\tbp->stats.smt_mac_cts\t\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.smt_mac_ct;\n\tbp->stats.smt_non_master_cts\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.smt_non_master_ct;\n\tbp->stats.smt_master_cts\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.smt_master_ct;\n\tbp->stats.smt_available_paths\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.smt_available_paths;\n\tbp->stats.smt_config_capabilities\t\t\t= bp->cmd_rsp_virt->smt_mib_get.smt_config_capabilities;\n\tbp->stats.smt_config_policy\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.smt_config_policy;\n\tbp->stats.smt_connection_policy\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.smt_connection_policy;\n\tbp->stats.smt_t_notify\t\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.smt_t_notify;\n\tbp->stats.smt_stat_rpt_policy\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.smt_stat_rpt_policy;\n\tbp->stats.smt_trace_max_expiration\t\t\t= bp->cmd_rsp_virt->smt_mib_get.smt_trace_max_expiration;\n\tbp->stats.smt_bypass_present\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.smt_bypass_present;\n\tbp->stats.smt_ecm_state\t\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.smt_ecm_state;\n\tbp->stats.smt_cf_state\t\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.smt_cf_state;\n\tbp->stats.smt_remote_disconnect_flag\t\t= bp->cmd_rsp_virt->smt_mib_get.smt_remote_disconnect_flag;\n\tbp->stats.smt_station_status\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.smt_station_status;\n\tbp->stats.smt_peer_wrap_flag\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.smt_peer_wrap_flag;\n\tbp->stats.smt_time_stamp\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.smt_msg_time_stamp.ls;\n\tbp->stats.smt_transition_time_stamp\t\t\t= bp->cmd_rsp_virt->smt_mib_get.smt_transition_time_stamp.ls;\n\tbp->stats.mac_frame_status_functions\t\t= bp->cmd_rsp_virt->smt_mib_get.mac_frame_status_functions;\n\tbp->stats.mac_t_max_capability\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.mac_t_max_capability;\n\tbp->stats.mac_tvx_capability\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.mac_tvx_capability;\n\tbp->stats.mac_available_paths\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.mac_available_paths;\n\tbp->stats.mac_current_path\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.mac_current_path;\n\tmemcpy(bp->stats.mac_upstream_nbr, &bp->cmd_rsp_virt->smt_mib_get.mac_upstream_nbr, FDDI_K_ALEN);\n\tmemcpy(bp->stats.mac_downstream_nbr, &bp->cmd_rsp_virt->smt_mib_get.mac_downstream_nbr, FDDI_K_ALEN);\n\tmemcpy(bp->stats.mac_old_upstream_nbr, &bp->cmd_rsp_virt->smt_mib_get.mac_old_upstream_nbr, FDDI_K_ALEN);\n\tmemcpy(bp->stats.mac_old_downstream_nbr, &bp->cmd_rsp_virt->smt_mib_get.mac_old_downstream_nbr, FDDI_K_ALEN);\n\tbp->stats.mac_dup_address_test\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.mac_dup_address_test;\n\tbp->stats.mac_requested_paths\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.mac_requested_paths;\n\tbp->stats.mac_downstream_port_type\t\t\t= bp->cmd_rsp_virt->smt_mib_get.mac_downstream_port_type;\n\tmemcpy(bp->stats.mac_smt_address, &bp->cmd_rsp_virt->smt_mib_get.mac_smt_address, FDDI_K_ALEN);\n\tbp->stats.mac_t_req\t\t\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.mac_t_req;\n\tbp->stats.mac_t_neg\t\t\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.mac_t_neg;\n\tbp->stats.mac_t_max\t\t\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.mac_t_max;\n\tbp->stats.mac_tvx_value\t\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.mac_tvx_value;\n\tbp->stats.mac_frame_error_threshold\t\t\t= bp->cmd_rsp_virt->smt_mib_get.mac_frame_error_threshold;\n\tbp->stats.mac_frame_error_ratio\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.mac_frame_error_ratio;\n\tbp->stats.mac_rmt_state\t\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.mac_rmt_state;\n\tbp->stats.mac_da_flag\t\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.mac_da_flag;\n\tbp->stats.mac_una_da_flag\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.mac_unda_flag;\n\tbp->stats.mac_frame_error_flag\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.mac_frame_error_flag;\n\tbp->stats.mac_ma_unitdata_available\t\t\t= bp->cmd_rsp_virt->smt_mib_get.mac_ma_unitdata_available;\n\tbp->stats.mac_hardware_present\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.mac_hardware_present;\n\tbp->stats.mac_ma_unitdata_enable\t\t\t= bp->cmd_rsp_virt->smt_mib_get.mac_ma_unitdata_enable;\n\tbp->stats.path_tvx_lower_bound\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.path_tvx_lower_bound;\n\tbp->stats.path_t_max_lower_bound\t\t\t= bp->cmd_rsp_virt->smt_mib_get.path_t_max_lower_bound;\n\tbp->stats.path_max_t_req\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.path_max_t_req;\n\tmemcpy(bp->stats.path_configuration, &bp->cmd_rsp_virt->smt_mib_get.path_configuration, sizeof(bp->cmd_rsp_virt->smt_mib_get.path_configuration));\n\tbp->stats.port_my_type[0]\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_my_type[0];\n\tbp->stats.port_my_type[1]\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_my_type[1];\n\tbp->stats.port_neighbor_type[0]\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_neighbor_type[0];\n\tbp->stats.port_neighbor_type[1]\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_neighbor_type[1];\n\tbp->stats.port_connection_policies[0]\t\t= bp->cmd_rsp_virt->smt_mib_get.port_connection_policies[0];\n\tbp->stats.port_connection_policies[1]\t\t= bp->cmd_rsp_virt->smt_mib_get.port_connection_policies[1];\n\tbp->stats.port_mac_indicated[0]\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_mac_indicated[0];\n\tbp->stats.port_mac_indicated[1]\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_mac_indicated[1];\n\tbp->stats.port_current_path[0]\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_current_path[0];\n\tbp->stats.port_current_path[1]\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_current_path[1];\n\tmemcpy(&bp->stats.port_requested_paths[0*3], &bp->cmd_rsp_virt->smt_mib_get.port_requested_paths[0], 3);\n\tmemcpy(&bp->stats.port_requested_paths[1*3], &bp->cmd_rsp_virt->smt_mib_get.port_requested_paths[1], 3);\n\tbp->stats.port_mac_placement[0]\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_mac_placement[0];\n\tbp->stats.port_mac_placement[1]\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_mac_placement[1];\n\tbp->stats.port_available_paths[0]\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_available_paths[0];\n\tbp->stats.port_available_paths[1]\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_available_paths[1];\n\tbp->stats.port_pmd_class[0]\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_pmd_class[0];\n\tbp->stats.port_pmd_class[1]\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_pmd_class[1];\n\tbp->stats.port_connection_capabilities[0]\t= bp->cmd_rsp_virt->smt_mib_get.port_connection_capabilities[0];\n\tbp->stats.port_connection_capabilities[1]\t= bp->cmd_rsp_virt->smt_mib_get.port_connection_capabilities[1];\n\tbp->stats.port_bs_flag[0]\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_bs_flag[0];\n\tbp->stats.port_bs_flag[1]\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_bs_flag[1];\n\tbp->stats.port_ler_estimate[0]\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_ler_estimate[0];\n\tbp->stats.port_ler_estimate[1]\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_ler_estimate[1];\n\tbp->stats.port_ler_cutoff[0]\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_ler_cutoff[0];\n\tbp->stats.port_ler_cutoff[1]\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_ler_cutoff[1];\n\tbp->stats.port_ler_alarm[0]\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_ler_alarm[0];\n\tbp->stats.port_ler_alarm[1]\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_ler_alarm[1];\n\tbp->stats.port_connect_state[0]\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_connect_state[0];\n\tbp->stats.port_connect_state[1]\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_connect_state[1];\n\tbp->stats.port_pcm_state[0]\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_pcm_state[0];\n\tbp->stats.port_pcm_state[1]\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_pcm_state[1];\n\tbp->stats.port_pc_withhold[0]\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_pc_withhold[0];\n\tbp->stats.port_pc_withhold[1]\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_pc_withhold[1];\n\tbp->stats.port_ler_flag[0]\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_ler_flag[0];\n\tbp->stats.port_ler_flag[1]\t\t\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_ler_flag[1];\n\tbp->stats.port_hardware_present[0]\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_hardware_present[0];\n\tbp->stats.port_hardware_present[1]\t\t\t= bp->cmd_rsp_virt->smt_mib_get.port_hardware_present[1];\n\n\t \n\n\tbp->cmd_req_virt->cmd_type = PI_CMD_K_CNTRS_GET;\n\tif (dfx_hw_dma_cmd_req(bp) != DFX_K_SUCCESS)\n\t\treturn (struct net_device_stats *)&bp->stats;\n\n\t \n\n\tbp->stats.mac_frame_cts\t\t\t\t= bp->cmd_rsp_virt->cntrs_get.cntrs.frame_cnt.ls;\n\tbp->stats.mac_copied_cts\t\t\t= bp->cmd_rsp_virt->cntrs_get.cntrs.copied_cnt.ls;\n\tbp->stats.mac_transmit_cts\t\t\t= bp->cmd_rsp_virt->cntrs_get.cntrs.transmit_cnt.ls;\n\tbp->stats.mac_error_cts\t\t\t\t= bp->cmd_rsp_virt->cntrs_get.cntrs.error_cnt.ls;\n\tbp->stats.mac_lost_cts\t\t\t\t= bp->cmd_rsp_virt->cntrs_get.cntrs.lost_cnt.ls;\n\tbp->stats.port_lct_fail_cts[0]\t\t= bp->cmd_rsp_virt->cntrs_get.cntrs.lct_rejects[0].ls;\n\tbp->stats.port_lct_fail_cts[1]\t\t= bp->cmd_rsp_virt->cntrs_get.cntrs.lct_rejects[1].ls;\n\tbp->stats.port_lem_reject_cts[0]\t= bp->cmd_rsp_virt->cntrs_get.cntrs.lem_rejects[0].ls;\n\tbp->stats.port_lem_reject_cts[1]\t= bp->cmd_rsp_virt->cntrs_get.cntrs.lem_rejects[1].ls;\n\tbp->stats.port_lem_cts[0]\t\t\t= bp->cmd_rsp_virt->cntrs_get.cntrs.link_errors[0].ls;\n\tbp->stats.port_lem_cts[1]\t\t\t= bp->cmd_rsp_virt->cntrs_get.cntrs.link_errors[1].ls;\n\n\treturn (struct net_device_stats *)&bp->stats;\n\t}\n\n\n \n\nstatic void dfx_ctl_set_multicast_list(struct net_device *dev)\n{\n\tDFX_board_t *bp = netdev_priv(dev);\n\tint\t\t\t\t\ti;\t\t\t \n\tstruct netdev_hw_addr *ha;\n\n\t \n\n\tif (dev->flags & IFF_PROMISC)\n\t\tbp->ind_group_prom = PI_FSTATE_K_PASS;\t\t \n\n\t \n\n\telse\n\t\t{\n\t\tbp->ind_group_prom = PI_FSTATE_K_BLOCK;\t\t \n\t\t \n\n\t\tif (netdev_mc_count(dev) > (PI_CMD_ADDR_FILTER_K_SIZE - bp->uc_count))\n\t\t\t{\n\t\t\tbp->group_prom\t= PI_FSTATE_K_PASS;\t\t \n\t\t\tbp->mc_count\t= 0;\t\t\t\t\t \n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tbp->group_prom\t= PI_FSTATE_K_BLOCK;\t \n\t\t\tbp->mc_count\t= netdev_mc_count(dev);\t\t \n\t\t\t}\n\n\t\t \n\n\t\ti = 0;\n\t\tnetdev_for_each_mc_addr(ha, dev)\n\t\t\tmemcpy(&bp->mc_table[i++ * FDDI_K_ALEN],\n\t\t\t       ha->addr, FDDI_K_ALEN);\n\n\t\tif (dfx_ctl_update_cam(bp) != DFX_K_SUCCESS)\n\t\t\t{\n\t\t\tDBG_printk(\"%s: Could not update multicast address table!\\n\", dev->name);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tDBG_printk(\"%s: Multicast address table updated!  Added %d addresses.\\n\", dev->name, bp->mc_count);\n\t\t\t}\n\t\t}\n\n\t \n\n\tif (dfx_ctl_update_filters(bp) != DFX_K_SUCCESS)\n\t\t{\n\t\tDBG_printk(\"%s: Could not update adapter filters!\\n\", dev->name);\n\t\t}\n\telse\n\t\t{\n\t\tDBG_printk(\"%s: Adapter filters updated!\\n\", dev->name);\n\t\t}\n\t}\n\n\n \n\nstatic int dfx_ctl_set_mac_address(struct net_device *dev, void *addr)\n\t{\n\tstruct sockaddr\t*p_sockaddr = (struct sockaddr *)addr;\n\tDFX_board_t *bp = netdev_priv(dev);\n\n\t \n\n\tdev_addr_set(dev, p_sockaddr->sa_data);\t\t\t\t \n\tmemcpy(&bp->uc_table[0], p_sockaddr->sa_data, FDDI_K_ALEN);\t \n\tbp->uc_count = 1;\n\n\t \n\n\tif ((bp->uc_count + bp->mc_count) > PI_CMD_ADDR_FILTER_K_SIZE)\n\t\t{\n\t\tbp->group_prom\t= PI_FSTATE_K_PASS;\t\t \n\t\tbp->mc_count\t= 0;\t\t\t\t\t \n\n\t\t \n\n\t\tif (dfx_ctl_update_filters(bp) != DFX_K_SUCCESS)\n\t\t\t{\n\t\t\tDBG_printk(\"%s: Could not update adapter filters!\\n\", dev->name);\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\tDBG_printk(\"%s: Adapter filters updated!\\n\", dev->name);\n\t\t\t}\n\t\t}\n\n\t \n\n\tif (dfx_ctl_update_cam(bp) != DFX_K_SUCCESS)\n\t\t{\n\t\tDBG_printk(\"%s: Could not set new MAC address!\\n\", dev->name);\n\t\t}\n\telse\n\t\t{\n\t\tDBG_printk(\"%s: Adapter CAM updated with new MAC address\\n\", dev->name);\n\t\t}\n\treturn 0;\t\t\t \n\t}\n\n\n \n\nstatic int dfx_ctl_update_cam(DFX_board_t *bp)\n\t{\n\tint\t\t\ti;\t\t\t\t \n\tPI_LAN_ADDR\t*p_addr;\t\t \n\n\t \n\n\tmemset(bp->cmd_req_virt, 0, PI_CMD_REQ_K_SIZE_MAX);\t \n\tbp->cmd_req_virt->cmd_type = PI_CMD_K_ADDR_FILTER_SET;\n\tp_addr = &bp->cmd_req_virt->addr_filter_set.entry[0];\n\n\t \n\n\tfor (i=0; i < (int)bp->uc_count; i++)\n\t\t{\n\t\tif (i < PI_CMD_ADDR_FILTER_K_SIZE)\n\t\t\t{\n\t\t\tmemcpy(p_addr, &bp->uc_table[i*FDDI_K_ALEN], FDDI_K_ALEN);\n\t\t\tp_addr++;\t\t\t \n\t\t\t}\n\t\t}\n\n\t \n\n\tfor (i=0; i < (int)bp->mc_count; i++)\n\t\t{\n\t\tif ((i + bp->uc_count) < PI_CMD_ADDR_FILTER_K_SIZE)\n\t\t\t{\n\t\t\tmemcpy(p_addr, &bp->mc_table[i*FDDI_K_ALEN], FDDI_K_ALEN);\n\t\t\tp_addr++;\t\t\t \n\t\t\t}\n\t\t}\n\n\t \n\n\tif (dfx_hw_dma_cmd_req(bp) != DFX_K_SUCCESS)\n\t\treturn DFX_K_FAILURE;\n\treturn DFX_K_SUCCESS;\n\t}\n\n\n \n\nstatic int dfx_ctl_update_filters(DFX_board_t *bp)\n\t{\n\tint\ti = 0;\t\t\t\t\t \n\n\t \n\n\tbp->cmd_req_virt->cmd_type = PI_CMD_K_FILTERS_SET;\n\n\t \n\n\tbp->cmd_req_virt->filter_set.item[i].item_code\t= PI_ITEM_K_BROADCAST;\n\tbp->cmd_req_virt->filter_set.item[i++].value\t= PI_FSTATE_K_PASS;\n\n\t \n\n\tbp->cmd_req_virt->filter_set.item[i].item_code\t= PI_ITEM_K_IND_GROUP_PROM;\n\tbp->cmd_req_virt->filter_set.item[i++].value\t= bp->ind_group_prom;\n\n\t \n\n\tbp->cmd_req_virt->filter_set.item[i].item_code\t= PI_ITEM_K_GROUP_PROM;\n\tbp->cmd_req_virt->filter_set.item[i++].value\t= bp->group_prom;\n\n\t \n\n\tbp->cmd_req_virt->filter_set.item[i].item_code\t= PI_ITEM_K_EOL;\n\n\t \n\n\tif (dfx_hw_dma_cmd_req(bp) != DFX_K_SUCCESS)\n\t\treturn DFX_K_FAILURE;\n\treturn DFX_K_SUCCESS;\n\t}\n\n\n \n\nstatic int dfx_hw_dma_cmd_req(DFX_board_t *bp)\n\t{\n\tint status;\t\t\t \n\tint timeout_cnt;\t \n\n\t \n\n\tstatus = dfx_hw_adap_state_rd(bp);\n\tif ((status == PI_STATE_K_RESET)\t\t||\n\t\t(status == PI_STATE_K_HALTED)\t\t||\n\t\t(status == PI_STATE_K_DMA_UNAVAIL)\t||\n\t\t(status == PI_STATE_K_UPGRADE))\n\t\treturn DFX_K_OUTSTATE;\n\n\t \n\n\tbp->descr_block_virt->cmd_rsp[bp->cmd_rsp_reg.index.prod].long_0 = (u32) (PI_RCV_DESCR_M_SOP |\n\t\t\t((PI_CMD_RSP_K_SIZE_MAX / PI_ALIGN_K_CMD_RSP_BUFF) << PI_RCV_DESCR_V_SEG_LEN));\n\tbp->descr_block_virt->cmd_rsp[bp->cmd_rsp_reg.index.prod].long_1 = bp->cmd_rsp_phys;\n\n\t \n\n\tbp->cmd_rsp_reg.index.prod += 1;\n\tbp->cmd_rsp_reg.index.prod &= PI_CMD_RSP_K_NUM_ENTRIES-1;\n\tdfx_port_write_long(bp, PI_PDQ_K_REG_CMD_RSP_PROD, bp->cmd_rsp_reg.lword);\n\n\t \n\n\tbp->descr_block_virt->cmd_req[bp->cmd_req_reg.index.prod].long_0 = (u32) (PI_XMT_DESCR_M_SOP |\n\t\t\tPI_XMT_DESCR_M_EOP | (PI_CMD_REQ_K_SIZE_MAX << PI_XMT_DESCR_V_SEG_LEN));\n\tbp->descr_block_virt->cmd_req[bp->cmd_req_reg.index.prod].long_1 = bp->cmd_req_phys;\n\n\t \n\n\tbp->cmd_req_reg.index.prod += 1;\n\tbp->cmd_req_reg.index.prod &= PI_CMD_REQ_K_NUM_ENTRIES-1;\n\tdfx_port_write_long(bp, PI_PDQ_K_REG_CMD_REQ_PROD, bp->cmd_req_reg.lword);\n\n\t \n\n\tfor (timeout_cnt = 20000; timeout_cnt > 0; timeout_cnt--)\n\t\t{\n\t\tif (bp->cmd_req_reg.index.prod == (u8)(bp->cons_block_virt->cmd_req))\n\t\t\tbreak;\n\t\tudelay(100);\t\t\t \n\t\t}\n\tif (timeout_cnt == 0)\n\t\treturn DFX_K_HW_TIMEOUT;\n\n\t \n\n\tbp->cmd_req_reg.index.comp += 1;\n\tbp->cmd_req_reg.index.comp &= PI_CMD_REQ_K_NUM_ENTRIES-1;\n\tdfx_port_write_long(bp, PI_PDQ_K_REG_CMD_REQ_PROD, bp->cmd_req_reg.lword);\n\n\t \n\n\tfor (timeout_cnt = 20000; timeout_cnt > 0; timeout_cnt--)\n\t\t{\n\t\tif (bp->cmd_rsp_reg.index.prod == (u8)(bp->cons_block_virt->cmd_rsp))\n\t\t\tbreak;\n\t\tudelay(100);\t\t\t \n\t\t}\n\tif (timeout_cnt == 0)\n\t\treturn DFX_K_HW_TIMEOUT;\n\n\t \n\n\tbp->cmd_rsp_reg.index.comp += 1;\n\tbp->cmd_rsp_reg.index.comp &= PI_CMD_RSP_K_NUM_ENTRIES-1;\n\tdfx_port_write_long(bp, PI_PDQ_K_REG_CMD_RSP_PROD, bp->cmd_rsp_reg.lword);\n\treturn DFX_K_SUCCESS;\n\t}\n\n\n \n\nstatic int dfx_hw_port_ctrl_req(\n\tDFX_board_t\t*bp,\n\tPI_UINT32\tcommand,\n\tPI_UINT32\tdata_a,\n\tPI_UINT32\tdata_b,\n\tPI_UINT32\t*host_data\n\t)\n\n\t{\n\tPI_UINT32\tport_cmd;\t\t \n\tint\t\t\ttimeout_cnt;\t \n\n\t \n\n\tport_cmd = (PI_UINT32) (command | PI_PCTRL_M_CMD_ERROR);\n\n\t \n\n\tdfx_port_write_long(bp, PI_PDQ_K_REG_PORT_DATA_A, data_a);\n\tdfx_port_write_long(bp, PI_PDQ_K_REG_PORT_DATA_B, data_b);\n\tdfx_port_write_long(bp, PI_PDQ_K_REG_PORT_CTRL, port_cmd);\n\n\t \n\n\tif (command == PI_PCTRL_M_BLAST_FLASH)\n\t\ttimeout_cnt = 600000;\t \n\telse\n\t\ttimeout_cnt = 20000;\t \n\n\tfor (; timeout_cnt > 0; timeout_cnt--)\n\t\t{\n\t\tdfx_port_read_long(bp, PI_PDQ_K_REG_PORT_CTRL, &port_cmd);\n\t\tif (!(port_cmd & PI_PCTRL_M_CMD_ERROR))\n\t\t\tbreak;\n\t\tudelay(100);\t\t\t \n\t\t}\n\tif (timeout_cnt == 0)\n\t\treturn DFX_K_HW_TIMEOUT;\n\n\t \n\n\tif (host_data != NULL)\n\t\tdfx_port_read_long(bp, PI_PDQ_K_REG_HOST_DATA, host_data);\n\treturn DFX_K_SUCCESS;\n\t}\n\n\n \n\nstatic void dfx_hw_adap_reset(\n\tDFX_board_t\t*bp,\n\tPI_UINT32\ttype\n\t)\n\n\t{\n\t \n\n\tdfx_port_write_long(bp, PI_PDQ_K_REG_PORT_DATA_A, type);\t \n\tdfx_port_write_long(bp, PI_PDQ_K_REG_PORT_RESET, PI_RESET_M_ASSERT_RESET);\n\n\t \n\n\tudelay(20);\n\n\t \n\n\tdfx_port_write_long(bp, PI_PDQ_K_REG_PORT_RESET, 0);\n\t}\n\n\n \n\nstatic int dfx_hw_adap_state_rd(DFX_board_t *bp)\n\t{\n\tPI_UINT32 port_status;\t\t \n\n\tdfx_port_read_long(bp, PI_PDQ_K_REG_PORT_STATUS, &port_status);\n\treturn (port_status & PI_PSTATUS_M_STATE) >> PI_PSTATUS_V_STATE;\n\t}\n\n\n \n\nstatic int dfx_hw_dma_uninit(DFX_board_t *bp, PI_UINT32 type)\n\t{\n\tint timeout_cnt;\t \n\n\t \n\n\tdfx_hw_adap_reset(bp, type);\n\n\t \n\n\tfor (timeout_cnt = 100000; timeout_cnt > 0; timeout_cnt--)\n\t\t{\n\t\tif (dfx_hw_adap_state_rd(bp) == PI_STATE_K_DMA_UNAVAIL)\n\t\t\tbreak;\n\t\tudelay(100);\t\t\t\t\t \n\t\t}\n\tif (timeout_cnt == 0)\n\t\treturn DFX_K_HW_TIMEOUT;\n\treturn DFX_K_SUCCESS;\n\t}\n\n \n#ifdef DYNAMIC_BUFFERS\nstatic void my_skb_align(struct sk_buff *skb, int n)\n{\n\tunsigned long x = (unsigned long)skb->data;\n\tunsigned long v;\n\n\tv = ALIGN(x, n);\t \n\n\tskb_reserve(skb, v - x);\n}\n#endif\n\n \n\nstatic int dfx_rcv_init(DFX_board_t *bp, int get_buffers)\n\t{\n\tint\ti, j;\t\t\t\t\t \n\n\t \n\n\tif (get_buffers) {\n#ifdef DYNAMIC_BUFFERS\n\tfor (i = 0; i < (int)(bp->rcv_bufs_to_post); i++)\n\t\tfor (j = 0; (i + j) < (int)PI_RCV_DATA_K_NUM_ENTRIES; j += bp->rcv_bufs_to_post)\n\t\t{\n\t\t\tstruct sk_buff *newskb;\n\t\t\tdma_addr_t dma_addr;\n\n\t\t\tnewskb = __netdev_alloc_skb(bp->dev, NEW_SKB_SIZE,\n\t\t\t\t\t\t    GFP_NOIO);\n\t\t\tif (!newskb)\n\t\t\t\treturn -ENOMEM;\n\t\t\t \n\n\t\t\tmy_skb_align(newskb, 128);\n\t\t\tdma_addr = dma_map_single(bp->bus_dev,\n\t\t\t\t\t\t  newskb->data,\n\t\t\t\t\t\t  PI_RCV_DATA_K_SIZE_MAX,\n\t\t\t\t\t\t  DMA_FROM_DEVICE);\n\t\t\tif (dma_mapping_error(bp->bus_dev, dma_addr)) {\n\t\t\t\tdev_kfree_skb(newskb);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tbp->descr_block_virt->rcv_data[i + j].long_0 =\n\t\t\t\t(u32)(PI_RCV_DESCR_M_SOP |\n\t\t\t\t      ((PI_RCV_DATA_K_SIZE_MAX /\n\t\t\t\t\tPI_ALIGN_K_RCV_DATA_BUFF) <<\n\t\t\t\t       PI_RCV_DESCR_V_SEG_LEN));\n\t\t\tbp->descr_block_virt->rcv_data[i + j].long_1 =\n\t\t\t\t(u32)dma_addr;\n\n\t\t\t \n\t\t\tbp->p_rcv_buff_va[i+j] = (char *) newskb;\n\t\t}\n#else\n\tfor (i=0; i < (int)(bp->rcv_bufs_to_post); i++)\n\t\tfor (j=0; (i + j) < (int)PI_RCV_DATA_K_NUM_ENTRIES; j += bp->rcv_bufs_to_post)\n\t\t\t{\n\t\t\tbp->descr_block_virt->rcv_data[i+j].long_0 = (u32) (PI_RCV_DESCR_M_SOP |\n\t\t\t\t((PI_RCV_DATA_K_SIZE_MAX / PI_ALIGN_K_RCV_DATA_BUFF) << PI_RCV_DESCR_V_SEG_LEN));\n\t\t\tbp->descr_block_virt->rcv_data[i+j].long_1 = (u32) (bp->rcv_block_phys + (i * PI_RCV_DATA_K_SIZE_MAX));\n\t\t\tbp->p_rcv_buff_va[i+j] = (bp->rcv_block_virt + (i * PI_RCV_DATA_K_SIZE_MAX));\n\t\t\t}\n#endif\n\t}\n\n\t \n\n\tbp->rcv_xmt_reg.index.rcv_prod = bp->rcv_bufs_to_post;\n\tdfx_port_write_long(bp, PI_PDQ_K_REG_TYPE_2_PROD, bp->rcv_xmt_reg.lword);\n\treturn 0;\n\t}\n\n\n \n\nstatic void dfx_rcv_queue_process(\n\tDFX_board_t *bp\n\t)\n\n\t{\n\tPI_TYPE_2_CONSUMER\t*p_type_2_cons;\t\t \n\tchar\t\t\t\t*p_buff;\t\t\t \n\tu32\t\t\t\t\tdescr, pkt_len;\t\t \n\tstruct sk_buff\t\t*skb = NULL;\t\t\t \n\n\t \n\n\tp_type_2_cons = (PI_TYPE_2_CONSUMER *)(&bp->cons_block_virt->xmt_rcv_data);\n\twhile (bp->rcv_xmt_reg.index.rcv_comp != p_type_2_cons->index.rcv_cons)\n\t\t{\n\t\t \n\t\tdma_addr_t dma_addr;\n\t\tint entry;\n\n\t\tentry = bp->rcv_xmt_reg.index.rcv_comp;\n#ifdef DYNAMIC_BUFFERS\n\t\tp_buff = (char *) (((struct sk_buff *)bp->p_rcv_buff_va[entry])->data);\n#else\n\t\tp_buff = bp->p_rcv_buff_va[entry];\n#endif\n\t\tdma_addr = bp->descr_block_virt->rcv_data[entry].long_1;\n\t\tdma_sync_single_for_cpu(bp->bus_dev,\n\t\t\t\t\tdma_addr + RCV_BUFF_K_DESCR,\n\t\t\t\t\tsizeof(u32),\n\t\t\t\t\tDMA_FROM_DEVICE);\n\t\tmemcpy(&descr, p_buff + RCV_BUFF_K_DESCR, sizeof(u32));\n\n\t\tif (descr & PI_FMC_DESCR_M_RCC_FLUSH)\n\t\t\t{\n\t\t\tif (descr & PI_FMC_DESCR_M_RCC_CRC)\n\t\t\t\tbp->rcv_crc_errors++;\n\t\t\telse\n\t\t\t\tbp->rcv_frame_status_errors++;\n\t\t\t}\n\t\telse\n\t\t{\n\t\t\tint rx_in_place = 0;\n\n\t\t\t \n\n\t\t\tpkt_len = (u32)((descr & PI_FMC_DESCR_M_LEN) >> PI_FMC_DESCR_V_LEN);\n\t\t\tpkt_len -= 4;\t\t\t\t \n\t\t\tif (!IN_RANGE(pkt_len, FDDI_K_LLC_ZLEN, FDDI_K_LLC_LEN))\n\t\t\t\tbp->rcv_length_errors++;\n\t\t\telse{\n#ifdef DYNAMIC_BUFFERS\n\t\t\t\tstruct sk_buff *newskb = NULL;\n\n\t\t\t\tif (pkt_len > SKBUFF_RX_COPYBREAK) {\n\t\t\t\t\tdma_addr_t new_dma_addr;\n\n\t\t\t\t\tnewskb = netdev_alloc_skb(bp->dev,\n\t\t\t\t\t\t\t\t  NEW_SKB_SIZE);\n\t\t\t\t\tif (newskb){\n\t\t\t\t\t\tmy_skb_align(newskb, 128);\n\t\t\t\t\t\tnew_dma_addr = dma_map_single(\n\t\t\t\t\t\t\t\tbp->bus_dev,\n\t\t\t\t\t\t\t\tnewskb->data,\n\t\t\t\t\t\t\t\tPI_RCV_DATA_K_SIZE_MAX,\n\t\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\t\t\t\tif (dma_mapping_error(\n\t\t\t\t\t\t\t\tbp->bus_dev,\n\t\t\t\t\t\t\t\tnew_dma_addr)) {\n\t\t\t\t\t\t\tdev_kfree_skb(newskb);\n\t\t\t\t\t\t\tnewskb = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (newskb) {\n\t\t\t\t\t\trx_in_place = 1;\n\n\t\t\t\t\t\tskb = (struct sk_buff *)bp->p_rcv_buff_va[entry];\n\t\t\t\t\t\tdma_unmap_single(bp->bus_dev,\n\t\t\t\t\t\t\tdma_addr,\n\t\t\t\t\t\t\tPI_RCV_DATA_K_SIZE_MAX,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\t\t\t\tskb_reserve(skb, RCV_BUFF_K_PADDING);\n\t\t\t\t\t\tbp->p_rcv_buff_va[entry] = (char *)newskb;\n\t\t\t\t\t\tbp->descr_block_virt->rcv_data[entry].long_1 = (u32)new_dma_addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!newskb)\n#endif\n\t\t\t\t\t \n\t\t\t\t\tskb = netdev_alloc_skb(bp->dev,\n\t\t\t\t\t\t\t       pkt_len + 3);\n\t\t\t\tif (skb == NULL)\n\t\t\t\t\t{\n\t\t\t\t\tprintk(\"%s: Could not allocate receive buffer.  Dropping packet.\\n\", bp->dev->name);\n\t\t\t\t\tbp->rcv_discards++;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!rx_in_place) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tdma_sync_single_for_cpu(\n\t\t\t\t\t\t\tbp->bus_dev,\n\t\t\t\t\t\t\tdma_addr +\n\t\t\t\t\t\t\tRCV_BUFF_K_PADDING,\n\t\t\t\t\t\t\tpkt_len + 3,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\n\t\t\t\t\t\tskb_copy_to_linear_data(skb,\n\t\t\t\t\t\t\t       p_buff + RCV_BUFF_K_PADDING,\n\t\t\t\t\t\t\t       pkt_len + 3);\n\t\t\t\t\t}\n\n\t\t\t\t\tskb_reserve(skb,3);\t\t \n\t\t\t\t\tskb_put(skb, pkt_len);\t\t \n\t\t\t\t\tskb->protocol = fddi_type_trans(skb, bp->dev);\n\t\t\t\t\tbp->rcv_total_bytes += skb->len;\n\t\t\t\t\tnetif_rx(skb);\n\n\t\t\t\t\t \n\t\t\t\t\tbp->rcv_total_frames++;\n\t\t\t\t\tif (*(p_buff + RCV_BUFF_K_DA) & 0x01)\n\t\t\t\t\t\tbp->rcv_multicast_frames++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\n\t\t \n\n\t\tbp->rcv_xmt_reg.index.rcv_prod += 1;\n\t\tbp->rcv_xmt_reg.index.rcv_comp += 1;\n\t\t}\n\t}\n\n\n \n\nstatic netdev_tx_t dfx_xmt_queue_pkt(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev)\n\t{\n\tDFX_board_t\t\t*bp = netdev_priv(dev);\n\tu8\t\t\tprod;\t\t\t\t \n\tPI_XMT_DESCR\t\t*p_xmt_descr;\t\t \n\tXMT_DRIVER_DESCR\t*p_xmt_drv_descr;\t \n\tdma_addr_t\t\tdma_addr;\n\tunsigned long\t\tflags;\n\n\tnetif_stop_queue(dev);\n\n\t \n\n\tif (!IN_RANGE(skb->len, FDDI_K_LLC_ZLEN, FDDI_K_LLC_LEN))\n\t{\n\t\tprintk(\"%s: Invalid packet length - %u bytes\\n\",\n\t\t\tdev->name, skb->len);\n\t\tbp->xmt_length_errors++;\t\t \n\t\tnetif_wake_queue(dev);\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\t\t\t \n\t}\n\t \n\n\tif (bp->link_available == PI_K_FALSE)\n\t\t{\n\t\tif (dfx_hw_adap_state_rd(bp) == PI_STATE_K_LINK_AVAIL)\t \n\t\t\tbp->link_available = PI_K_TRUE;\t\t \n\t\telse\n\t\t\t{\n\t\t\tbp->xmt_discards++;\t\t\t\t\t \n\t\t\tdev_kfree_skb(skb);\t\t \n\t\t\tnetif_wake_queue(dev);\n\t\t\treturn NETDEV_TX_OK;\t\t \n\t\t\t}\n\t\t}\n\n\t \n\n\tskb_push(skb, 3);\n\tskb->data[0] = DFX_PRH0_BYTE;\t \n\tskb->data[1] = DFX_PRH1_BYTE;\t \n\tskb->data[2] = DFX_PRH2_BYTE;\t \n\n\tdma_addr = dma_map_single(bp->bus_dev, skb->data, skb->len,\n\t\t\t\t  DMA_TO_DEVICE);\n\tif (dma_mapping_error(bp->bus_dev, dma_addr)) {\n\t\tskb_pull(skb, 3);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tspin_lock_irqsave(&bp->lock, flags);\n\n\t \n\n\tprod\t\t= bp->rcv_xmt_reg.index.xmt_prod;\n\tp_xmt_descr = &(bp->descr_block_virt->xmt_data[prod]);\n\n\t \n\n\tp_xmt_drv_descr = &(bp->xmt_drv_descr_blk[prod++]);\t \n\n\t \n\n\tp_xmt_descr->long_0\t= (u32) (PI_XMT_DESCR_M_SOP | PI_XMT_DESCR_M_EOP | ((skb->len) << PI_XMT_DESCR_V_SEG_LEN));\n\tp_xmt_descr->long_1 = (u32)dma_addr;\n\n\t \n\n\tif (prod == bp->rcv_xmt_reg.index.xmt_comp)\n\t{\n\t\tskb_pull(skb,3);\n\t\tspin_unlock_irqrestore(&bp->lock, flags);\n\t\treturn NETDEV_TX_BUSY;\t \n\t}\n\n\t \n\n\tp_xmt_drv_descr->p_skb = skb;\n\n\t \n\n\tbp->rcv_xmt_reg.index.xmt_prod = prod;\n\tdfx_port_write_long(bp, PI_PDQ_K_REG_TYPE_2_PROD, bp->rcv_xmt_reg.lword);\n\tspin_unlock_irqrestore(&bp->lock, flags);\n\tnetif_wake_queue(dev);\n\treturn NETDEV_TX_OK;\t \n\t}\n\n\n \n\nstatic int dfx_xmt_done(DFX_board_t *bp)\n\t{\n\tXMT_DRIVER_DESCR\t*p_xmt_drv_descr;\t \n\tPI_TYPE_2_CONSUMER\t*p_type_2_cons;\t\t \n\tu8\t\t\tcomp;\t\t\t \n\tint \t\t\tfreed = 0;\t\t \n\n\t \n\n\tp_type_2_cons = (PI_TYPE_2_CONSUMER *)(&bp->cons_block_virt->xmt_rcv_data);\n\twhile (bp->rcv_xmt_reg.index.xmt_comp != p_type_2_cons->index.xmt_cons)\n\t\t{\n\t\t \n\n\t\tp_xmt_drv_descr = &(bp->xmt_drv_descr_blk[bp->rcv_xmt_reg.index.xmt_comp]);\n\n\t\t \n\n\t\tbp->xmt_total_frames++;\n\t\tbp->xmt_total_bytes += p_xmt_drv_descr->p_skb->len;\n\n\t\t \n\t\tcomp = bp->rcv_xmt_reg.index.xmt_comp;\n\t\tdma_unmap_single(bp->bus_dev,\n\t\t\t\t bp->descr_block_virt->xmt_data[comp].long_1,\n\t\t\t\t p_xmt_drv_descr->p_skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\t\tdev_consume_skb_irq(p_xmt_drv_descr->p_skb);\n\n\t\t \n\n\t\tbp->rcv_xmt_reg.index.xmt_comp += 1;\n\t\tfreed++;\n\t\t}\n\treturn freed;\n\t}\n\n\n \n#ifdef DYNAMIC_BUFFERS\nstatic void dfx_rcv_flush( DFX_board_t *bp )\n\t{\n\tint i, j;\n\n\tfor (i = 0; i < (int)(bp->rcv_bufs_to_post); i++)\n\t\tfor (j = 0; (i + j) < (int)PI_RCV_DATA_K_NUM_ENTRIES; j += bp->rcv_bufs_to_post)\n\t\t{\n\t\t\tstruct sk_buff *skb;\n\t\t\tskb = (struct sk_buff *)bp->p_rcv_buff_va[i+j];\n\t\t\tif (skb) {\n\t\t\t\tdma_unmap_single(bp->bus_dev,\n\t\t\t\t\t\t bp->descr_block_virt->rcv_data[i+j].long_1,\n\t\t\t\t\t\t PI_RCV_DATA_K_SIZE_MAX,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t}\n\t\t\tbp->p_rcv_buff_va[i+j] = NULL;\n\t\t}\n\n\t}\n#endif  \n\n \n\nstatic void dfx_xmt_flush( DFX_board_t *bp )\n\t{\n\tu32\t\t\tprod_cons;\t\t \n\tXMT_DRIVER_DESCR\t*p_xmt_drv_descr;\t \n\tu8\t\t\tcomp;\t\t\t \n\n\t \n\n\twhile (bp->rcv_xmt_reg.index.xmt_comp != bp->rcv_xmt_reg.index.xmt_prod)\n\t\t{\n\t\t \n\n\t\tp_xmt_drv_descr = &(bp->xmt_drv_descr_blk[bp->rcv_xmt_reg.index.xmt_comp]);\n\n\t\t \n\t\tcomp = bp->rcv_xmt_reg.index.xmt_comp;\n\t\tdma_unmap_single(bp->bus_dev,\n\t\t\t\t bp->descr_block_virt->xmt_data[comp].long_1,\n\t\t\t\t p_xmt_drv_descr->p_skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\t\tdev_kfree_skb(p_xmt_drv_descr->p_skb);\n\n\t\t \n\n\t\tbp->xmt_discards++;\n\n\t\t \n\n\t\tbp->rcv_xmt_reg.index.xmt_comp += 1;\n\t\t}\n\n\t \n\n\tprod_cons = (u32)(bp->cons_block_virt->xmt_rcv_data & ~PI_CONS_M_XMT_INDEX);\n\tprod_cons |= (u32)(bp->rcv_xmt_reg.index.xmt_prod << PI_CONS_V_XMT_INDEX);\n\tbp->cons_block_virt->xmt_rcv_data = prod_cons;\n\t}\n\n \nstatic void dfx_unregister(struct device *bdev)\n{\n\tstruct net_device *dev = dev_get_drvdata(bdev);\n\tDFX_board_t *bp = netdev_priv(dev);\n\tint dfx_bus_pci = dev_is_pci(bdev);\n\tresource_size_t bar_start[3] = {0};\t \n\tresource_size_t bar_len[3] = {0};\t \n\tint\t\talloc_size;\t\t \n\n\tunregister_netdev(dev);\n\n\talloc_size = sizeof(PI_DESCR_BLOCK) +\n\t\t     PI_CMD_REQ_K_SIZE_MAX + PI_CMD_RSP_K_SIZE_MAX +\n#ifndef DYNAMIC_BUFFERS\n\t\t     (bp->rcv_bufs_to_post * PI_RCV_DATA_K_SIZE_MAX) +\n#endif\n\t\t     sizeof(PI_CONSUMER_BLOCK) +\n\t\t     (PI_ALIGN_K_DESC_BLK - 1);\n\tif (bp->kmalloced)\n\t\tdma_free_coherent(bdev, alloc_size,\n\t\t\t\t  bp->kmalloced, bp->kmalloced_dma);\n\n\tdfx_bus_uninit(dev);\n\n\tdfx_get_bars(bp, bar_start, bar_len);\n\tif (bar_start[2] != 0)\n\t\trelease_region(bar_start[2], bar_len[2]);\n\tif (bar_start[1] != 0)\n\t\trelease_region(bar_start[1], bar_len[1]);\n\tif (dfx_use_mmio) {\n\t\tiounmap(bp->base.mem);\n\t\trelease_mem_region(bar_start[0], bar_len[0]);\n\t} else\n\t\trelease_region(bar_start[0], bar_len[0]);\n\n\tif (dfx_bus_pci)\n\t\tpci_disable_device(to_pci_dev(bdev));\n\n\tfree_netdev(dev);\n}\n\n\nstatic int __maybe_unused dfx_dev_register(struct device *);\nstatic int __maybe_unused dfx_dev_unregister(struct device *);\n\n#ifdef CONFIG_PCI\nstatic int dfx_pci_register(struct pci_dev *, const struct pci_device_id *);\nstatic void dfx_pci_unregister(struct pci_dev *);\n\nstatic const struct pci_device_id dfx_pci_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_DEC, PCI_DEVICE_ID_DEC_FDDI) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, dfx_pci_table);\n\nstatic struct pci_driver dfx_pci_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= dfx_pci_table,\n\t.probe\t\t= dfx_pci_register,\n\t.remove\t\t= dfx_pci_unregister,\n};\n\nstatic int dfx_pci_register(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *ent)\n{\n\treturn dfx_register(&pdev->dev);\n}\n\nstatic void dfx_pci_unregister(struct pci_dev *pdev)\n{\n\tdfx_unregister(&pdev->dev);\n}\n#endif  \n\n#ifdef CONFIG_EISA\nstatic const struct eisa_device_id dfx_eisa_table[] = {\n        { \"DEC3001\", DEFEA_PROD_ID_1 },\n        { \"DEC3002\", DEFEA_PROD_ID_2 },\n        { \"DEC3003\", DEFEA_PROD_ID_3 },\n        { \"DEC3004\", DEFEA_PROD_ID_4 },\n        { }\n};\nMODULE_DEVICE_TABLE(eisa, dfx_eisa_table);\n\nstatic struct eisa_driver dfx_eisa_driver = {\n\t.id_table\t= dfx_eisa_table,\n\t.driver\t\t= {\n\t\t.name\t= DRV_NAME,\n\t\t.bus\t= &eisa_bus_type,\n\t\t.probe\t= dfx_dev_register,\n\t\t.remove\t= dfx_dev_unregister,\n\t},\n};\n#endif  \n\n#ifdef CONFIG_TC\nstatic struct tc_device_id const dfx_tc_table[] = {\n\t{ \"DEC     \", \"PMAF-FA \" },\n\t{ \"DEC     \", \"PMAF-FD \" },\n\t{ \"DEC     \", \"PMAF-FS \" },\n\t{ \"DEC     \", \"PMAF-FU \" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(tc, dfx_tc_table);\n\nstatic struct tc_driver dfx_tc_driver = {\n\t.id_table\t= dfx_tc_table,\n\t.driver\t\t= {\n\t\t.name\t= DRV_NAME,\n\t\t.bus\t= &tc_bus_type,\n\t\t.probe\t= dfx_dev_register,\n\t\t.remove\t= dfx_dev_unregister,\n\t},\n};\n#endif  \n\nstatic int __maybe_unused dfx_dev_register(struct device *dev)\n{\n\tint status;\n\n\tstatus = dfx_register(dev);\n\tif (!status)\n\t\tget_device(dev);\n\treturn status;\n}\n\nstatic int __maybe_unused dfx_dev_unregister(struct device *dev)\n{\n\tput_device(dev);\n\tdfx_unregister(dev);\n\treturn 0;\n}\n\n\nstatic int dfx_init(void)\n{\n\tint status;\n\n\tstatus = pci_register_driver(&dfx_pci_driver);\n\tif (status)\n\t\tgoto err_pci_register;\n\n\tstatus = eisa_driver_register(&dfx_eisa_driver);\n\tif (status)\n\t\tgoto err_eisa_register;\n\n\tstatus = tc_register_driver(&dfx_tc_driver);\n\tif (status)\n\t\tgoto err_tc_register;\n\n\treturn 0;\n\nerr_tc_register:\n\teisa_driver_unregister(&dfx_eisa_driver);\nerr_eisa_register:\n\tpci_unregister_driver(&dfx_pci_driver);\nerr_pci_register:\n\treturn status;\n}\n\nstatic void dfx_cleanup(void)\n{\n\ttc_unregister_driver(&dfx_tc_driver);\n\teisa_driver_unregister(&dfx_eisa_driver);\n\tpci_unregister_driver(&dfx_pci_driver);\n}\n\nmodule_init(dfx_init);\nmodule_exit(dfx_cleanup);\nMODULE_AUTHOR(\"Lawrence V. Stefani\");\nMODULE_DESCRIPTION(\"DEC FDDIcontroller TC/EISA/PCI (DEFTA/DEFEA/DEFPA) driver \"\n\t\t   DRV_VERSION \" \" DRV_RELDATE);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}