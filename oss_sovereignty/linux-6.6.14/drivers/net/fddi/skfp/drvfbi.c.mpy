{
  "module_name": "drvfbi.c",
  "hash_id": "61fc902ff9f014cc9dfed43351df1cbf387fbbdd1e16c6ccc583874d35fea274",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/fddi/skfp/drvfbi.c",
  "human_readable_source": "\n \n\n \n\n#include \"h/types.h\"\n#include \"h/fddi.h\"\n#include \"h/smc.h\"\n#include \"h/supern_2.h\"\n#include \"h/skfbiinc.h\"\n#include <linux/bitrev.h>\n#include <linux/pci.h>\n\n \n#define PC8_ACTIVE\t8\n\n#define\tLED_Y_ON\t0x11\t \n#define\tLED_Y_OFF\t0x10\n\n\n#define MS2BCLK(x)\t((x)*12500L)\n\n \n\n \n#ifndef MULT_OEM\n#ifndef\tOEM_CONCEPT\nconst u_char oem_id[] = \"xPOS_ID:xxxx\" ;\n#else\t \nconst u_char oem_id[] = OEM_ID ;\n#endif\t \n#define\tID_BYTE0\t8\n#define\tOEMID(smc,i)\toem_id[ID_BYTE0 + i]\n#else\t \nconst struct s_oem_ids oem_ids[] = {\n#include \"oemids.h\"\n{0}\n};\n#define\tOEMID(smc,i)\tsmc->hw.oem_id->oi_id[i]\n#endif\t \n\n \n#ifdef AIX\nextern int AIX_vpdReadByte() ;\n#endif\n\n\n \nstatic void smt_stop_watchdog(struct s_smc *smc);\n\n \nstatic void card_start(struct s_smc *smc)\n{\n\tint i ;\n#ifdef\tPCI\n\tu_char\trev_id ;\n\tu_short word;\n#endif\n\n\tsmt_stop_watchdog(smc) ;\n\n#ifdef\tPCI\n\t \n\toutpw(FM_A(FM_MDREG1),FM_MINIT) ;\n\toutp(ADDR(B0_CTRL), CTRL_HPI_SET) ;\n\thwt_wait_time(smc,hwt_quick_read(smc),MS2BCLK(10)) ;\n\t \n\toutp(ADDR(B0_CTRL),CTRL_RST_SET) ;\t \n\ti = (int) inp(ADDR(B0_CTRL)) ;\t\t \n\tSK_UNUSED(i) ;\t\t\t\t \n\toutp(ADDR(B0_CTRL), CTRL_RST_CLR) ;\n\n\t \n\toutp(ADDR(B0_TST_CTRL), TST_CFG_WRITE_ON) ;\t \n\tword = inpw(PCI_C(PCI_STATUS)) ;\n\toutpw(PCI_C(PCI_STATUS), word | PCI_STATUS_ERROR_BITS);\n\toutp(ADDR(B0_TST_CTRL), TST_CFG_WRITE_OFF) ;\t \n\n\t \n\toutp(ADDR(B0_CTRL), CTRL_MRST_CLR|CTRL_HPI_CLR) ;\n\n\t \n\trev_id = inp(PCI_C(PCI_REVISION_ID)) ;\n\tif ((rev_id & 0xf0) == SK_ML_ID_1 || (rev_id & 0xf0) == SK_ML_ID_2) {\n\t\tsmc->hw.hw_is_64bit = TRUE ;\n\t} else {\n\t\tsmc->hw.hw_is_64bit = FALSE ;\n\t}\n\n\t \n\tif (!smc->hw.hw_is_64bit) {\n\t\toutpd(ADDR(B4_R1_F), RX_WATERMARK) ;\n\t\toutpd(ADDR(B5_XA_F), TX_WATERMARK) ;\n\t\toutpd(ADDR(B5_XS_F), TX_WATERMARK) ;\n\t}\n\n\toutp(ADDR(B0_CTRL),CTRL_RST_CLR) ;\t \n\toutp(ADDR(B0_LED),LED_GA_OFF|LED_MY_ON|LED_GB_OFF) ;  \n\n\t \n\toutpd(ADDR(B2_WDOG_INI),0x6FC23AC0) ;\n\n\t \n\tsmc->hw.is_imask = ISR_MASK ;\n\tsmc->hw.hw_state = STOPPED ;\n#endif\n\tGET_PAGE(0) ;\t\t \n}\n\nvoid card_stop(struct s_smc *smc)\n{\n\tsmt_stop_watchdog(smc) ;\n\tsmc->hw.mac_ring_is_up = 0 ;\t\t \n\n#ifdef\tPCI\n\t \n\toutpw(FM_A(FM_MDREG1),FM_MINIT) ;\n\toutp(ADDR(B0_CTRL), CTRL_HPI_SET) ;\n\thwt_wait_time(smc,hwt_quick_read(smc),MS2BCLK(10)) ;\n\t \n\toutp(ADDR(B0_CTRL),CTRL_RST_SET) ;\t \n\toutp(ADDR(B0_CTRL),CTRL_RST_CLR) ;\t \n\toutp(ADDR(B0_LED),LED_GA_OFF|LED_MY_OFF|LED_GB_OFF) ;  \n\tsmc->hw.hw_state = STOPPED ;\n#endif\n}\n \n\nvoid mac1_irq(struct s_smc *smc, u_short stu, u_short stl)\n{\n\tint\trestart_tx = 0 ;\nagain:\n\n\t \n\tif (stl & (FM_SPCEPDS  |\t \n\t\t   FM_SPCEPDA0 |\t \n\t\t   FM_SPCEPDA1)) {\t \n\t\tSMT_PANIC(smc,SMT_E0134, SMT_E0134_MSG) ;\n\t}\n\t \n\tif (stl & (FM_STBURS  |\t\t \n\t\t   FM_STBURA0 |\t\t \n\t\t   FM_STBURA1)) {\t \n\t\tSMT_PANIC(smc,SMT_E0133, SMT_E0133_MSG) ;\n\t}\n\n\tif ( (stu & (FM_SXMTABT |\t\t \n\t\t     FM_STXABRS |\t\t \n\t\t     FM_STXABRA0)) ||\t\t \n\t     (stl & (FM_SQLCKS |\t\t \n\t\t     FM_SQLCKA0)) ) {\t\t \n\t\tformac_tx_restart(smc) ;\t \n\t\trestart_tx = 1 ;\n\t\tstu = inpw(FM_A(FM_ST1U)) ;\n\t\tstl = inpw(FM_A(FM_ST1L)) ;\n\t\tstu &= ~ (FM_STECFRMA0 | FM_STEFRMA0 | FM_STEFRMS) ;\n\t\tif (stu || stl)\n\t\t\tgoto again ;\n\t}\n\n\tif (stu & (FM_STEFRMA0 |\t \n\t\t    FM_STEFRMS)) {\t \n\t\trestart_tx = 1 ;\n\t}\n\n\tif (restart_tx)\n\t\tllc_restart_tx(smc) ;\n}\n\n \nvoid plc1_irq(struct s_smc *smc)\n{\n\tu_short\tst = inpw(PLC(PB,PL_INTR_EVENT)) ;\n\n\tplc_irq(smc,PB,st) ;\n}\n\n \nvoid plc2_irq(struct s_smc *smc)\n{\n\tu_short\tst = inpw(PLC(PA,PL_INTR_EVENT)) ;\n\n\tplc_irq(smc,PA,st) ;\n}\n\n\n \nvoid timer_irq(struct s_smc *smc)\n{\n\thwt_restart(smc);\n\tsmc->hw.t_stop = smc->hw.t_start;\n\tsmt_timer_done(smc) ;\n}\n\n \nint pcm_get_s_port(struct s_smc *smc)\n{\n\tSK_UNUSED(smc) ;\n\treturn PS;\n}\n\n \n#define STATION_LABEL_CONNECTOR_OFFSET\t5\n#define STATION_LABEL_PMD_OFFSET\t6\n#define STATION_LABEL_PORT_OFFSET\t7\n\nvoid read_address(struct s_smc *smc, u_char *mac_addr)\n{\n\tchar ConnectorType ;\n\tchar PmdType ;\n\tint\ti ;\n\n#ifdef\tPCI\n\tfor (i = 0; i < 6; i++) {\t \n\t\tsmc->hw.fddi_phys_addr.a[i] =\n\t\t\tbitrev8(inp(ADDR(B2_MAC_0+i)));\n\t}\n#endif\n\n\tConnectorType = inp(ADDR(B2_CONN_TYP)) ;\n\tPmdType = inp(ADDR(B2_PMD_TYP)) ;\n\n\tsmc->y[PA].pmd_type[PMD_SK_CONN] =\n\tsmc->y[PB].pmd_type[PMD_SK_CONN] = ConnectorType ;\n\tsmc->y[PA].pmd_type[PMD_SK_PMD ] =\n\tsmc->y[PB].pmd_type[PMD_SK_PMD ] = PmdType ;\n\n\tif (mac_addr) {\n\t\tfor (i = 0; i < 6 ;i++) {\n\t\t\tsmc->hw.fddi_canon_addr.a[i] = mac_addr[i] ;\n\t\t\tsmc->hw.fddi_home_addr.a[i] = bitrev8(mac_addr[i]);\n\t\t}\n\t\treturn ;\n\t}\n\tsmc->hw.fddi_home_addr = smc->hw.fddi_phys_addr ;\n\n\tfor (i = 0; i < 6 ;i++) {\n\t\tsmc->hw.fddi_canon_addr.a[i] =\n\t\t\tbitrev8(smc->hw.fddi_phys_addr.a[i]);\n\t}\n}\n\n \nvoid init_board(struct s_smc *smc, u_char *mac_addr)\n{\n\tcard_start(smc) ;\n\tread_address(smc,mac_addr) ;\n\n\tif (!(inp(ADDR(B0_DAS)) & DAS_AVAIL))\n\t\tsmc->s.sas = SMT_SAS ;\t \n\telse\n\t\tsmc->s.sas = SMT_DAS ;\t \n\n\tif (!(inp(ADDR(B0_DAS)) & DAS_BYP_ST))\n\t\tsmc->mib.fddiSMTBypassPresent = 0 ;\n\t\t \n\telse\n\t\tsmc->mib.fddiSMTBypassPresent = 1 ;\n\t\t \n}\n\n \nvoid sm_pm_bypass_req(struct s_smc *smc, int mode)\n{\n\tDB_ECMN(1, \"ECM : sm_pm_bypass_req(%s)\",\n\t\tmode == BP_INSERT ? \"BP_INSERT\" : \"BP_DEINSERT\");\n\n\tif (smc->s.sas != SMT_DAS)\n\t\treturn ;\n\n#ifdef\tPCI\n\tswitch(mode) {\n\tcase BP_INSERT :\n\t\toutp(ADDR(B0_DAS),DAS_BYP_INS) ;\t \n\t\tbreak ;\n\tcase BP_DEINSERT :\n\t\toutp(ADDR(B0_DAS),DAS_BYP_RMV) ;\t \n\t\tbreak ;\n\t}\n#endif\n}\n\n \nint sm_pm_bypass_present(struct s_smc *smc)\n{\n\treturn (inp(ADDR(B0_DAS)) & DAS_BYP_ST) ? TRUE : FALSE;\n}\n\nvoid plc_clear_irq(struct s_smc *smc, int p)\n{\n\tSK_UNUSED(p) ;\n\n\tSK_UNUSED(smc) ;\n}\n\n\n \nstatic void led_indication(struct s_smc *smc, int led_event)\n{\n\t \n\tu_short\t\t\tled_state ;\n\tstruct s_phy\t\t*phy ;\n\tstruct fddi_mib_p\t*mib_a ;\n\tstruct fddi_mib_p\t*mib_b ;\n\n\tphy = &smc->y[PA] ;\n\tmib_a = phy->mib ;\n\tphy = &smc->y[PB] ;\n\tmib_b = phy->mib ;\n\n#ifdef\tPCI\n        led_state = 0 ;\n\t\n\t \n\tif (led_event == LED_Y_ON) {\n\t\tled_state |= LED_MY_ON ;\n\t}\n\telse if (led_event == LED_Y_OFF) {\n\t\tled_state |= LED_MY_OFF ;\n\t}\n\telse {\t \n\t\t \n\t\tif (mib_a->fddiPORTPCMState == PC8_ACTIVE) {\t\n\t\t\tled_state |= LED_GA_ON ;\n\t\t}\n\t\telse {\n\t\t\tled_state |= LED_GA_OFF ;\n\t\t}\n\t\t\n\t\t \n\t\tif (mib_b->fddiPORTPCMState == PC8_ACTIVE) {\n\t\t\tled_state |= LED_GB_ON ;\n\t\t}\n\t\telse {\n\t\t\tled_state |= LED_GB_OFF ;\n\t\t}\n\t}\n\n        outp(ADDR(B0_LED), led_state) ;\n#endif\t \n\n}\n\n\nvoid pcm_state_change(struct s_smc *smc, int plc, int p_state)\n{\n\t \n\tDRV_PCM_STATE_CHANGE(smc,plc,p_state) ;\n\t\n\tled_indication(smc,0) ;\n}\n\n\nvoid rmt_indication(struct s_smc *smc, int i)\n{\n\t \n\tDRV_RMT_INDICATION(smc,i) ;\n\n        led_indication(smc, i ? LED_Y_OFF : LED_Y_ON) ;\n}\n\n\n \nvoid llc_recover_tx(struct s_smc *smc)\n{\n#ifdef\tLOAD_GEN\n\textern\tint load_gen_flag ;\n\n\tload_gen_flag = 0 ;\n#endif\n#ifndef\tSYNC\n\tsmc->hw.n_a_send= 0 ;\n#else\n\tSK_UNUSED(smc) ;\n#endif\n}\n\n#ifdef MULT_OEM\nstatic int is_equal_num(char comp1[], char comp2[], int num)\n{\n\tint i ;\n\n\tfor (i = 0 ; i < num ; i++) {\n\t\tif (comp1[i] != comp2[i])\n\t\t\treturn 0;\n\t}\n\t\treturn 1;\n}\t \n\n\n \nint set_oi_id_def(struct s_smc *smc)\n{\n\tint sel_id ;\n\tint i ;\n\tint act_entries ;\n\n\ti = 0 ;\n\tsel_id = -1 ;\n\tact_entries = FALSE ;\n\tsmc->hw.oem_id = 0 ;\n\tsmc->hw.oem_min_status = OI_STAT_ACTIVE ;\n\t\n\t \n\twhile (oem_ids[i].oi_status) {\n\t\tswitch (oem_ids[i].oi_status) {\n\t\tcase OI_STAT_ACTIVE:\n\t\t\tact_entries = TRUE ;\t \n\t\t\tif (sel_id == -1)\n\t\t\t\tsel_id = i ;\t \n\t\tcase OI_STAT_VALID:\n\t\tcase OI_STAT_PRESENT:\n\t\t\ti++ ;\n\t\t\tbreak ;\t\t\t \n\t\tdefault:\n\t\t\treturn 1;\t\t \n\t\t}\n\t}\n\n\tif (i == 0)\n\t\treturn 2;\n\tif (!act_entries)\n\t\treturn 3;\n\n\t \n\tsmc->hw.oem_id = (struct s_oem_ids *)  &oem_ids[sel_id] ;\n\treturn 0;\n}\n#endif\t \n\nvoid driver_get_bia(struct s_smc *smc, struct fddi_addr *bia_addr)\n{\n\tint i ;\n\n\tfor (i = 0 ; i < 6 ; i++)\n\t\tbia_addr->a[i] = bitrev8(smc->hw.fddi_phys_addr.a[i]);\n}\n\nvoid smt_start_watchdog(struct s_smc *smc)\n{\n\tSK_UNUSED(smc) ;\t \n\n#ifndef\tDEBUG\n\n#ifdef\tPCI\n\tif (smc->hw.wdog_used) {\n\t\toutpw(ADDR(B2_WDOG_CRTL),TIM_START) ;\t \n\t}\n#endif\n\n#endif\t \n}\n\nstatic void smt_stop_watchdog(struct s_smc *smc)\n{\n\tSK_UNUSED(smc) ;\t \n#ifndef\tDEBUG\n\n#ifdef\tPCI\n\tif (smc->hw.wdog_used) {\n\t\toutpw(ADDR(B2_WDOG_CRTL),TIM_STOP) ;\t \n\t}\n#endif\n\n#endif\t \n}\n\n#ifdef\tPCI\n\nvoid mac_do_pci_fix(struct s_smc *smc)\n{\n\tSK_UNUSED(smc) ;\n}\n#endif\t \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}