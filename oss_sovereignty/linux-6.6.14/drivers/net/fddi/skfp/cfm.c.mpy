{
  "module_name": "cfm.c",
  "hash_id": "6d58b8e35d663ddae879562ff74bc6b1fbb8aabf3cbf30ad7db6facb68e7ef94",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/fddi/skfp/cfm.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include \"h/types.h\"\n#include \"h/fddi.h\"\n#include \"h/smc.h\"\n\n#define KERNEL\n#include \"h/smtstate.h\"\n\n \n#define AFLAG\t0x10\n#define GO_STATE(x)\t(smc->mib.fddiSMTCF_State = (x)|AFLAG)\n#define ACTIONS_DONE()\t(smc->mib.fddiSMTCF_State &= ~AFLAG)\n#define ACTIONS(x)\t(x|AFLAG)\n\n \nstatic const char * const cfm_states[] = {\n\t\"SC0_ISOLATED\",\"CF1\",\"CF2\",\"CF3\",\"CF4\",\n\t\"SC1_WRAP_A\",\"SC2_WRAP_B\",\"SC5_TRHU_B\",\"SC7_WRAP_S\",\n\t\"SC9_C_WRAP_A\",\"SC10_C_WRAP_B\",\"SC11_C_WRAP_S\",\"SC4_THRU_A\"\n} ;\n\n \nstatic const char * const cfm_events[] = {\n\t\"NONE\",\"CF_LOOP_A\",\"CF_LOOP_B\",\"CF_JOIN_A\",\"CF_JOIN_B\"\n} ;\n\n \nstatic const unsigned char cf_to_ptype[] = {\n\tTNONE,TNONE,TNONE,TNONE,TNONE,\n\tTNONE,TB,TB,TS,\n\tTA,TB,TS,TB\n} ;\n\n \n#define\tCEM_PST_DOWN\t0\n#define\tCEM_PST_UP\t1\n#define\tCEM_PST_HOLD\t2\n \n \n\n \n\n \nstatic void cfm_fsm(struct s_smc *smc, int cmd);\n\n \nvoid cfm_init(struct s_smc *smc)\n{\n\tsmc->mib.fddiSMTCF_State = ACTIONS(SC0_ISOLATED) ;\n\tsmc->r.rm_join = 0 ;\n\tsmc->r.rm_loop = 0 ;\n\tsmc->y[PA].scrub = 0 ;\n\tsmc->y[PB].scrub = 0 ;\n\tsmc->y[PA].cem_pst = CEM_PST_DOWN ;\n\tsmc->y[PB].cem_pst = CEM_PST_DOWN ;\n}\n\n \n#define THRU_ENABLED(smc)\t(smc->y[PA].pc_mode != PM_TREE && \\\n\t\t\t\t smc->y[PB].pc_mode != PM_TREE)\n \nstatic void selection_criteria (struct s_smc *smc, struct s_phy *phy)\n{\n\n\tswitch (phy->mib->fddiPORTMy_Type) {\n\tcase TA:\n\t\tif ( !THRU_ENABLED(smc) && smc->y[PB].cf_join ) {\n\t\t\tphy->wc_flag = TRUE ;\n\t\t} else {\n\t\t\tphy->wc_flag = FALSE ;\n\t\t}\n\n\t\tbreak;\n\tcase TB:\n\t\t \n\t\tphy->wc_flag = FALSE ;\n\t\tbreak;\n\tcase TS:\n\t\tphy->wc_flag = FALSE ;\n\t\tbreak;\n\tcase TM:\n\t\tphy->wc_flag = FALSE ;\n\t\tbreak;\n\t}\n\n}\n\nvoid all_selection_criteria(struct s_smc *smc)\n{\n\tstruct s_phy\t*phy ;\n\tint\t\tp ;\n\n\tfor ( p = 0,phy = smc->y ; p < NUMPHYS; p++, phy++ ) {\n\t\t \n\t\tselection_criteria (smc,phy);\n\t}\n}\n\nstatic void cem_priv_state(struct s_smc *smc, int event)\n \n{\n\tint\tnp;\t \n\tint\ti;\n\n\t \n\tif (smc->s.sas != SMT_DAS )\n\t\treturn ;\n\n\tnp = event - CF_JOIN;\n\n\tif (np != PA && np != PB) {\n\t\treturn ;\n\t}\n\t \n\tif (smc->y[np].cf_join) {\n\t\tsmc->y[np].cem_pst = CEM_PST_UP ;\n\t} else if (!smc->y[np].wc_flag) {\n\t\t \n\t\tsmc->y[np].cem_pst = CEM_PST_DOWN ;\n\t}\n\n\t \n\n\t \n\tfor (i = 0 ; i < 2 ; i ++ ) {\n\t\t \n\t\tif ( smc->y[i].cem_pst == CEM_PST_HOLD && !smc->y[i].wc_flag ) {\n\t\t\tsmc->y[i].cem_pst = CEM_PST_DOWN;\n\t\t\tqueue_event(smc,(int)(EVENT_PCM+i),PC_START) ;\n\t\t}\n\t\tif ( smc->y[i].cem_pst == CEM_PST_UP && smc->y[i].wc_flag ) {\n\t\t\tsmc->y[i].cem_pst = CEM_PST_HOLD;\n\t\t\tqueue_event(smc,(int)(EVENT_PCM+i),PC_START) ;\n\t\t}\n\t\tif ( smc->y[i].cem_pst == CEM_PST_DOWN && smc->y[i].wc_flag ) {\n\t\t\t \n\t\t\tsmc->y[i].cem_pst = CEM_PST_HOLD;\n\t\t}\n\t}\n\treturn ;\n}\n\n \nvoid cfm(struct s_smc *smc, int event)\n{\n\tint\tstate ;\t\t \n\tint\tcond ;\n\n\t \n\t \n\t \n\t \n\t \n\n\tall_selection_criteria (smc);\n\n\t \n\t \n\tcem_priv_state (smc, event);\n\n\tdo {\n\t\tDB_CFM(\"CFM : state %s%s event %s\",\n\t\t       smc->mib.fddiSMTCF_State & AFLAG ? \"ACTIONS \" : \"\",\n\t\t       cfm_states[smc->mib.fddiSMTCF_State & ~AFLAG],\n\t\t       cfm_events[event]);\n\t\tstate = smc->mib.fddiSMTCF_State ;\n\t\tcfm_fsm(smc,event) ;\n\t\tevent = 0 ;\n\t} while (state != smc->mib.fddiSMTCF_State) ;\n\n#ifndef\tSLIM_SMT\n\t \n\tcond = FALSE ;\n\tif (\t(smc->mib.fddiSMTCF_State == SC9_C_WRAP_A &&\n\t\tsmc->y[PA].pc_mode == PM_PEER) \t||\n\t\t(smc->mib.fddiSMTCF_State == SC10_C_WRAP_B &&\n\t\tsmc->y[PB].pc_mode == PM_PEER) \t||\n\t\t(smc->mib.fddiSMTCF_State == SC11_C_WRAP_S &&\n\t\tsmc->y[PS].pc_mode == PM_PEER &&\n\t\tsmc->y[PS].mib->fddiPORTNeighborType != TS ) ) {\n\t\t\tcond = TRUE ;\n\t}\n\tif (cond != smc->mib.fddiSMTPeerWrapFlag)\n\t\tsmt_srf_event(smc,SMT_COND_SMT_PEER_WRAP,0,cond) ;\n\n\t \n\n#endif\t \n\n\t \n\tsmc->mib.m[MAC0].fddiMACDownstreamPORTType =\n\t\tcf_to_ptype[smc->mib.fddiSMTCF_State] ;\n\tcfm_state_change(smc,(int)smc->mib.fddiSMTCF_State) ;\n}\n\n \n \nstatic void cfm_fsm(struct s_smc *smc, int cmd)\n{\n\tswitch(smc->mib.fddiSMTCF_State) {\n\tcase ACTIONS(SC0_ISOLATED) :\n\t\tsmc->mib.p[PA].fddiPORTCurrentPath = MIB_PATH_ISOLATED ;\n\t\tsmc->mib.p[PB].fddiPORTCurrentPath = MIB_PATH_ISOLATED ;\n\t\tsmc->mib.p[PA].fddiPORTMACPlacement = 0 ;\n\t\tsmc->mib.p[PB].fddiPORTMACPlacement = 0 ;\n\t\tsmc->mib.fddiSMTStationStatus = MIB_SMT_STASTA_SEPA ;\n\t\tconfig_mux(smc,MUX_ISOLATE) ;\t \n\t\tsmc->r.rm_loop = FALSE ;\n\t\tsmc->r.rm_join = FALSE ;\n\t\tqueue_event(smc,EVENT_RMT,RM_JOIN) ; \n\t\t \n\t\tACTIONS_DONE() ;\n\t\tDB_CFMN(1, \"CFM : %s\", cfm_states[smc->mib.fddiSMTCF_State]);\n\t\tbreak;\n\tcase SC0_ISOLATED :\n\t\t \n\t\t \n\t\tif (smc->s.sas && (smc->y[PA].cf_join || smc->y[PA].cf_loop ||\n\t\t\t\tsmc->y[PB].cf_join || smc->y[PB].cf_loop)) {\n\t\t\tGO_STATE(SC11_C_WRAP_S) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\tif ((smc->y[PA].cem_pst == CEM_PST_UP && smc->y[PA].cf_join &&\n\t\t     !smc->y[PA].wc_flag) || smc->y[PA].cf_loop) {\n\t\t\tGO_STATE(SC9_C_WRAP_A) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\tif ((smc->y[PB].cem_pst == CEM_PST_UP && smc->y[PB].cf_join &&\n\t\t     !smc->y[PB].wc_flag) || smc->y[PB].cf_loop) {\n\t\t\tGO_STATE(SC10_C_WRAP_B) ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak ;\n\tcase ACTIONS(SC9_C_WRAP_A) :\n\t\tsmc->mib.p[PA].fddiPORTCurrentPath = MIB_PATH_CONCATENATED ;\n\t\tsmc->mib.p[PB].fddiPORTCurrentPath = MIB_PATH_ISOLATED ;\n\t\tsmc->mib.p[PA].fddiPORTMACPlacement = INDEX_MAC ;\n\t\tsmc->mib.p[PB].fddiPORTMACPlacement = 0 ;\n\t\tsmc->mib.fddiSMTStationStatus = MIB_SMT_STASTA_CON ;\n\t\tconfig_mux(smc,MUX_WRAPA) ;\t\t \n\t\tif (smc->y[PA].cf_loop) {\n\t\t\tsmc->r.rm_join = FALSE ;\n\t\t\tsmc->r.rm_loop = TRUE ;\n\t\t\tqueue_event(smc,EVENT_RMT,RM_LOOP) ; \n\t\t}\n\t\tif (smc->y[PA].cf_join) {\n\t\t\tsmc->r.rm_loop = FALSE ;\n\t\t\tsmc->r.rm_join = TRUE ;\n\t\t\tqueue_event(smc,EVENT_RMT,RM_JOIN) ; \n\t\t}\n\t\tACTIONS_DONE() ;\n\t\tDB_CFMN(1, \"CFM : %s\", cfm_states[smc->mib.fddiSMTCF_State]);\n\t\tbreak ;\n\tcase SC9_C_WRAP_A :\n\t\t \n\t\tif ( (smc->y[PA].wc_flag || !smc->y[PA].cf_join) &&\n\t\t      !smc->y[PA].cf_loop ) {\n\t\t\tGO_STATE(SC0_ISOLATED) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if ( (smc->y[PB].cf_loop && smc->y[PA].cf_join &&\n\t\t\t   smc->y[PA].cem_pst == CEM_PST_UP) ||\n\t\t\t  ((smc->y[PB].cf_loop ||\n\t\t\t   (smc->y[PB].cf_join &&\n\t\t\t    smc->y[PB].cem_pst == CEM_PST_UP)) &&\n\t\t\t    (smc->y[PA].pc_mode == PM_TREE ||\n\t\t\t     smc->y[PB].pc_mode == PM_TREE))) {\n\t\t\tsmc->y[PA].scrub = TRUE ;\n\t\t\tGO_STATE(SC10_C_WRAP_B) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (!smc->s.attach_s &&\n\t\t\t  smc->y[PA].cf_join &&\n\t\t\t  smc->y[PA].cem_pst == CEM_PST_UP &&\n\t\t\t  smc->y[PA].pc_mode == PM_PEER && smc->y[PB].cf_join &&\n\t\t\t  smc->y[PB].cem_pst == CEM_PST_UP &&\n\t\t\t  smc->y[PB].pc_mode == PM_PEER) {\n\t\t\tsmc->y[PA].scrub = TRUE ;\n\t\t\tsmc->y[PB].scrub = TRUE ;\n\t\t\tGO_STATE(SC4_THRU_A) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if ( smc->s.attach_s &&\n\t\t\t  smc->y[PA].cf_join &&\n\t\t\t  smc->y[PA].cem_pst == CEM_PST_UP &&\n\t\t\t  smc->y[PA].pc_mode == PM_PEER &&\n\t\t\t  smc->y[PB].cf_join &&\n\t\t\t  smc->y[PB].cem_pst == CEM_PST_UP &&\n\t\t\t  smc->y[PB].pc_mode == PM_PEER) {\n\t\t\tsmc->y[PA].scrub = TRUE ;\n\t\t\tsmc->y[PB].scrub = TRUE ;\n\t\t\tGO_STATE(SC5_THRU_B) ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak ;\n\tcase ACTIONS(SC10_C_WRAP_B) :\n\t\tsmc->mib.p[PA].fddiPORTCurrentPath = MIB_PATH_ISOLATED ;\n\t\tsmc->mib.p[PB].fddiPORTCurrentPath = MIB_PATH_CONCATENATED ;\n\t\tsmc->mib.p[PA].fddiPORTMACPlacement = 0 ;\n\t\tsmc->mib.p[PB].fddiPORTMACPlacement = INDEX_MAC ;\n\t\tsmc->mib.fddiSMTStationStatus = MIB_SMT_STASTA_CON ;\n\t\tconfig_mux(smc,MUX_WRAPB) ;\t\t \n\t\tif (smc->y[PB].cf_loop) {\n\t\t\tsmc->r.rm_join = FALSE ;\n\t\t\tsmc->r.rm_loop = TRUE ;\n\t\t\tqueue_event(smc,EVENT_RMT,RM_LOOP) ; \n\t\t}\n\t\tif (smc->y[PB].cf_join) {\n\t\t\tsmc->r.rm_loop = FALSE ;\n\t\t\tsmc->r.rm_join = TRUE ;\n\t\t\tqueue_event(smc,EVENT_RMT,RM_JOIN) ; \n\t\t}\n\t\tACTIONS_DONE() ;\n\t\tDB_CFMN(1, \"CFM : %s\", cfm_states[smc->mib.fddiSMTCF_State]);\n\t\tbreak ;\n\tcase SC10_C_WRAP_B :\n\t\t \n\t\tif ( !smc->y[PB].cf_join && !smc->y[PB].cf_loop ) {\n\t\t\tGO_STATE(SC0_ISOLATED) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if ( smc->y[PA].cf_loop && smc->y[PA].pc_mode == PM_PEER &&\n\t\t\t  smc->y[PB].cf_join && smc->y[PB].pc_mode == PM_PEER) {\n\t\t\tsmc->y[PB].scrub = TRUE ;\n\t\t\tGO_STATE(SC9_C_WRAP_A) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (!smc->s.attach_s &&\n\t\t\t smc->y[PA].cf_join && smc->y[PA].pc_mode == PM_PEER &&\n\t\t\t smc->y[PB].cf_join && smc->y[PB].pc_mode == PM_PEER) {\n\t\t\tsmc->y[PA].scrub = TRUE ;\n\t\t\tsmc->y[PB].scrub = TRUE ;\n\t\t\tGO_STATE(SC4_THRU_A) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if ( smc->s.attach_s &&\n\t\t\t smc->y[PA].cf_join && smc->y[PA].pc_mode == PM_PEER &&\n\t\t\t smc->y[PB].cf_join && smc->y[PB].pc_mode == PM_PEER) {\n\t\t\tsmc->y[PA].scrub = TRUE ;\n\t\t\tsmc->y[PB].scrub = TRUE ;\n\t\t\tGO_STATE(SC5_THRU_B) ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak ;\n\tcase ACTIONS(SC4_THRU_A) :\n\t\tsmc->mib.p[PA].fddiPORTCurrentPath = MIB_PATH_THRU ;\n\t\tsmc->mib.p[PB].fddiPORTCurrentPath = MIB_PATH_THRU ;\n\t\tsmc->mib.p[PA].fddiPORTMACPlacement = 0 ;\n\t\tsmc->mib.p[PB].fddiPORTMACPlacement = INDEX_MAC ;\n\t\tsmc->mib.fddiSMTStationStatus = MIB_SMT_STASTA_THRU ;\n\t\tconfig_mux(smc,MUX_THRUA) ;\t\t \n\t\tsmc->r.rm_loop = FALSE ;\n\t\tsmc->r.rm_join = TRUE ;\n\t\tqueue_event(smc,EVENT_RMT,RM_JOIN) ; \n\t\tACTIONS_DONE() ;\n\t\tDB_CFMN(1, \"CFM : %s\", cfm_states[smc->mib.fddiSMTCF_State]);\n\t\tbreak ;\n\tcase SC4_THRU_A :\n\t\t \n\t\tif (smc->y[PB].wc_flag || !smc->y[PB].cf_join) {\n\t\t\tsmc->y[PA].scrub = TRUE ;\n\t\t\tGO_STATE(SC9_C_WRAP_A) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (!smc->y[PA].cf_join || smc->y[PA].wc_flag) {\n\t\t\tsmc->y[PB].scrub = TRUE ;\n\t\t\tGO_STATE(SC10_C_WRAP_B) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (smc->s.attach_s) {\n\t\t\tsmc->y[PB].scrub = TRUE ;\n\t\t\tGO_STATE(SC5_THRU_B) ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak ;\n\tcase ACTIONS(SC5_THRU_B) :\n\t\tsmc->mib.p[PA].fddiPORTCurrentPath = MIB_PATH_THRU ;\n\t\tsmc->mib.p[PB].fddiPORTCurrentPath = MIB_PATH_THRU ;\n\t\tsmc->mib.p[PA].fddiPORTMACPlacement = INDEX_MAC ;\n\t\tsmc->mib.p[PB].fddiPORTMACPlacement = 0 ;\n\t\tsmc->mib.fddiSMTStationStatus = MIB_SMT_STASTA_THRU ;\n\t\tconfig_mux(smc,MUX_THRUB) ;\t\t \n\t\tsmc->r.rm_loop = FALSE ;\n\t\tsmc->r.rm_join = TRUE ;\n\t\tqueue_event(smc,EVENT_RMT,RM_JOIN) ; \n\t\tACTIONS_DONE() ;\n\t\tDB_CFMN(1, \"CFM : %s\", cfm_states[smc->mib.fddiSMTCF_State]);\n\t\tbreak ;\n\tcase SC5_THRU_B :\n\t\t \n\t\tif (!smc->y[PB].cf_join || smc->y[PB].wc_flag) {\n\t\t\tsmc->y[PA].scrub = TRUE ;\n\t\t\tGO_STATE(SC9_C_WRAP_A) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (!smc->y[PA].cf_join || smc->y[PA].wc_flag) {\n\t\t\tsmc->y[PB].scrub = TRUE ;\n\t\t\tGO_STATE(SC10_C_WRAP_B) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (!smc->s.attach_s) {\n\t\t\tsmc->y[PA].scrub = TRUE ;\n\t\t\tGO_STATE(SC4_THRU_A) ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak ;\n\tcase ACTIONS(SC11_C_WRAP_S) :\n\t\tsmc->mib.p[PS].fddiPORTCurrentPath = MIB_PATH_CONCATENATED ;\n\t\tsmc->mib.p[PS].fddiPORTMACPlacement = INDEX_MAC ;\n\t\tsmc->mib.fddiSMTStationStatus = MIB_SMT_STASTA_CON ;\n\t\tconfig_mux(smc,MUX_WRAPS) ;\t\t \n\t\tif (smc->y[PA].cf_loop || smc->y[PB].cf_loop) {\n\t\t\tsmc->r.rm_join = FALSE ;\n\t\t\tsmc->r.rm_loop = TRUE ;\n\t\t\tqueue_event(smc,EVENT_RMT,RM_LOOP) ; \n\t\t}\n\t\tif (smc->y[PA].cf_join || smc->y[PB].cf_join) {\n\t\t\tsmc->r.rm_loop = FALSE ;\n\t\t\tsmc->r.rm_join = TRUE ;\n\t\t\tqueue_event(smc,EVENT_RMT,RM_JOIN) ; \n\t\t}\n\t\tACTIONS_DONE() ;\n\t\tDB_CFMN(1, \"CFM : %s\", cfm_states[smc->mib.fddiSMTCF_State]);\n\t\tbreak ;\n\tcase SC11_C_WRAP_S :\n\t\t \n\t\tif ( !smc->y[PA].cf_join && !smc->y[PA].cf_loop &&\n\t\t     !smc->y[PB].cf_join && !smc->y[PB].cf_loop) {\n\t\t\tGO_STATE(SC0_ISOLATED) ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak ;\n\tdefault:\n\t\tSMT_PANIC(smc,SMT_E0106, SMT_E0106_MSG) ;\n\t\tbreak;\n\t}\n}\n\n \nint cfm_get_mac_input(struct s_smc *smc)\n{\n\treturn (smc->mib.fddiSMTCF_State == SC10_C_WRAP_B ||\n\t\tsmc->mib.fddiSMTCF_State == SC5_THRU_B) ? PB : PA;\n}\n\n \nint cfm_get_mac_output(struct s_smc *smc)\n{\n\treturn (smc->mib.fddiSMTCF_State == SC10_C_WRAP_B ||\n\t\tsmc->mib.fddiSMTCF_State == SC4_THRU_A) ? PB : PA;\n}\n\nstatic char path_iso[] = {\n\t0,0,\t0,RES_PORT,\t0,PA + INDEX_PORT,\t0,PATH_ISO,\n\t0,0,\t0,RES_MAC,\t0,INDEX_MAC,\t\t0,PATH_ISO,\n\t0,0,\t0,RES_PORT,\t0,PB + INDEX_PORT,\t0,PATH_ISO\n} ;\n\nstatic char path_wrap_a[] = {\n\t0,0,\t0,RES_PORT,\t0,PA + INDEX_PORT,\t0,PATH_PRIM,\n\t0,0,\t0,RES_MAC,\t0,INDEX_MAC,\t\t0,PATH_PRIM,\n\t0,0,\t0,RES_PORT,\t0,PB + INDEX_PORT,\t0,PATH_ISO\n} ;\n\nstatic char path_wrap_b[] = {\n\t0,0,\t0,RES_PORT,\t0,PB + INDEX_PORT,\t0,PATH_PRIM,\n\t0,0,\t0,RES_MAC,\t0,INDEX_MAC,\t\t0,PATH_PRIM,\n\t0,0,\t0,RES_PORT,\t0,PA + INDEX_PORT,\t0,PATH_ISO\n} ;\n\nstatic char path_thru[] = {\n\t0,0,\t0,RES_PORT,\t0,PA + INDEX_PORT,\t0,PATH_PRIM,\n\t0,0,\t0,RES_MAC,\t0,INDEX_MAC,\t\t0,PATH_PRIM,\n\t0,0,\t0,RES_PORT,\t0,PB + INDEX_PORT,\t0,PATH_PRIM\n} ;\n\nstatic char path_wrap_s[] = {\n\t0,0,\t0,RES_PORT,\t0,PS + INDEX_PORT,\t0,PATH_PRIM,\n\t0,0,\t0,RES_MAC,\t0,INDEX_MAC,\t\t0,PATH_PRIM,\n} ;\n\nstatic char path_iso_s[] = {\n\t0,0,\t0,RES_PORT,\t0,PS + INDEX_PORT,\t0,PATH_ISO,\n\t0,0,\t0,RES_MAC,\t0,INDEX_MAC,\t\t0,PATH_ISO,\n} ;\n\nint cem_build_path(struct s_smc *smc, char *to, int path_index)\n{\n\tchar\t*path ;\n\tint\tlen ;\n\n\tswitch (smc->mib.fddiSMTCF_State) {\n\tdefault :\n\tcase SC0_ISOLATED :\n\t\tpath = smc->s.sas ? path_iso_s : path_iso ;\n\t\tlen = smc->s.sas ? sizeof(path_iso_s) :  sizeof(path_iso) ;\n\t\tbreak ;\n\tcase SC9_C_WRAP_A :\n\t\tpath = path_wrap_a ;\n\t\tlen = sizeof(path_wrap_a) ;\n\t\tbreak ;\n\tcase SC10_C_WRAP_B :\n\t\tpath = path_wrap_b ;\n\t\tlen = sizeof(path_wrap_b) ;\n\t\tbreak ;\n\tcase SC4_THRU_A :\n\t\tpath = path_thru ;\n\t\tlen = sizeof(path_thru) ;\n\t\tbreak ;\n\tcase SC11_C_WRAP_S :\n\t\tpath = path_wrap_s ;\n\t\tlen = sizeof(path_wrap_s) ;\n\t\tbreak ;\n\t}\n\tmemcpy(to,path,len) ;\n\n\tLINT_USE(path_index);\n\n\treturn len;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}