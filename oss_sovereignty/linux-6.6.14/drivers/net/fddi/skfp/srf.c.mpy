{
  "module_name": "srf.c",
  "hash_id": "5fd8b615e82694860d5923a51d8022ef93a33345e83c48e0445f1e3801a9719f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/fddi/skfp/srf.c",
  "human_readable_source": "\n \n\n \n\n#include \"h/types.h\"\n#include \"h/fddi.h\"\n#include \"h/smc.h\"\n#include \"h/smt_p.h\"\n\n#define KERNEL\n#include \"h/smtstate.h\"\n\n#ifndef\tSLIM_SMT\n#ifndef\tBOOT\n\n \nstatic void clear_all_rep(struct s_smc *smc);\nstatic void clear_reported(struct s_smc *smc);\nstatic void smt_send_srf(struct s_smc *smc);\nstatic struct s_srf_evc *smt_get_evc(struct s_smc *smc, int code, int index);\n\n#define MAX_EVCS\tARRAY_SIZE(smc->evcs)\n\nstruct evc_init {\n\tu_char code ;\n\tu_char index ;\n\tu_char n ;\n\tu_short\tpara ;\n}  ;\n\nstatic const struct evc_init evc_inits[] = {\n\t{ SMT_COND_SMT_PEER_WRAP,\t\t0,1,SMT_P1048\t} ,\n\n\t{ SMT_COND_MAC_DUP_ADDR,\t\tINDEX_MAC, NUMMACS,SMT_P208C } ,\n\t{ SMT_COND_MAC_FRAME_ERROR,\t\tINDEX_MAC, NUMMACS,SMT_P208D } ,\n\t{ SMT_COND_MAC_NOT_COPIED,\t\tINDEX_MAC, NUMMACS,SMT_P208E } ,\n\t{ SMT_EVENT_MAC_NEIGHBOR_CHANGE,\tINDEX_MAC, NUMMACS,SMT_P208F } ,\n\t{ SMT_EVENT_MAC_PATH_CHANGE,\t\tINDEX_MAC, NUMMACS,SMT_P2090 } ,\n\n\t{ SMT_COND_PORT_LER,\t\t\tINDEX_PORT,NUMPHYS,SMT_P4050 } ,\n\t{ SMT_COND_PORT_EB_ERROR,\t\tINDEX_PORT,NUMPHYS,SMT_P4052 } ,\n\t{ SMT_EVENT_PORT_CONNECTION,\t\tINDEX_PORT,NUMPHYS,SMT_P4051 } ,\n\t{ SMT_EVENT_PORT_PATH_CHANGE,\t\tINDEX_PORT,NUMPHYS,SMT_P4053 } ,\n} ;\n\n#define MAX_INIT_EVC\tARRAY_SIZE(evc_inits)\n\nvoid smt_init_evc(struct s_smc *smc)\n{\n\tstruct s_srf_evc\t*evc ;\n\tconst struct evc_init \t*init ;\n\tunsigned int\t\ti ;\n\tint\t\t\tindex ;\n\tint\t\t\toffset ;\n\n\tstatic u_char\t\tfail_safe = FALSE ;\n\n\tmemset((char *)smc->evcs,0,sizeof(smc->evcs)) ;\n\n\tevc = smc->evcs ;\n\tinit = evc_inits ;\n\n\tfor (i = 0 ; i < MAX_INIT_EVC ; i++) {\n\t\tfor (index = 0 ; index < init->n ; index++) {\n\t\t\tevc->evc_code = init->code ;\n\t\t\tevc->evc_para = init->para ;\n\t\t\tevc->evc_index = init->index + index ;\n#ifndef\tDEBUG\n\t\t\tevc->evc_multiple = &fail_safe ;\n\t\t\tevc->evc_cond_state = &fail_safe ;\n#endif\n\t\t\tevc++ ;\n\t\t}\n\t\tinit++ ;\n\t}\n\n\tif ((unsigned int) (evc - smc->evcs) > MAX_EVCS) {\n\t\tSMT_PANIC(smc,SMT_E0127, SMT_E0127_MSG) ;\n\t}\n\n\t \n\tsmc->evcs[0].evc_cond_state = &smc->mib.fddiSMTPeerWrapFlag ;\n\tsmc->evcs[1].evc_cond_state =\n\t\t&smc->mib.m[MAC0].fddiMACDuplicateAddressCond ;\n\tsmc->evcs[2].evc_cond_state =\n\t\t&smc->mib.m[MAC0].fddiMACFrameErrorFlag ;\n\tsmc->evcs[3].evc_cond_state =\n\t\t&smc->mib.m[MAC0].fddiMACNotCopiedFlag ;\n\n\t \n\tsmc->evcs[4].evc_multiple = &smc->mib.m[MAC0].fddiMACMultiple_N ;\n\tsmc->evcs[5].evc_multiple = &smc->mib.m[MAC0].fddiMACMultiple_P ;\n\n\toffset = 6 ;\n\tfor (i = 0 ; i < NUMPHYS ; i++) {\n\t\t \n\t\tsmc->evcs[offset + 0*NUMPHYS].evc_cond_state =\n\t\t\t&smc->mib.p[i].fddiPORTLerFlag ;\n\t\tsmc->evcs[offset + 1*NUMPHYS].evc_cond_state =\n\t\t\t&smc->mib.p[i].fddiPORTEB_Condition ;\n\n\t\t \n\t\tsmc->evcs[offset + 2*NUMPHYS].evc_multiple =\n\t\t\t&smc->mib.p[i].fddiPORTMultiple_U ;\n\t\tsmc->evcs[offset + 3*NUMPHYS].evc_multiple =\n\t\t\t&smc->mib.p[i].fddiPORTMultiple_P ;\n\t\toffset++ ;\n\t}\n#ifdef\tDEBUG\n\tfor (i = 0, evc = smc->evcs ; i < MAX_EVCS ; i++, evc++) {\n\t\tif (SMT_IS_CONDITION(evc->evc_code)) {\n\t\t\tif (!evc->evc_cond_state) {\n\t\t\t\tSMT_PANIC(smc,SMT_E0128, SMT_E0128_MSG) ;\n\t\t\t}\n\t\t\tevc->evc_multiple = &fail_safe ;\n\t\t}\n\t\telse {\n\t\t\tif (!evc->evc_multiple) {\n\t\t\t\tSMT_PANIC(smc,SMT_E0129, SMT_E0129_MSG) ;\n\t\t\t}\n\t\t\tevc->evc_cond_state = &fail_safe ;\n\t\t}\n\t}\n#endif\n\tsmc->srf.TSR = smt_get_time() ;\n\tsmc->srf.sr_state = SR0_WAIT ;\n}\n\nstatic struct s_srf_evc *smt_get_evc(struct s_smc *smc, int code, int index)\n{\n\tunsigned int\t\ti ;\n\tstruct s_srf_evc\t*evc ;\n\n\tfor (i = 0, evc = smc->evcs ; i < MAX_EVCS ; i++, evc++) {\n\t\tif (evc->evc_code == code && evc->evc_index == index)\n\t\t\treturn evc;\n\t}\n\treturn NULL;\n}\n\n#define THRESHOLD_2\t(2*TICKS_PER_SECOND)\n#define THRESHOLD_32\t(32*TICKS_PER_SECOND)\n\nstatic const char * const srf_names[] = {\n\t\"None\",\"MACPathChangeEvent\",\t\"MACNeighborChangeEvent\",\n\t\"PORTPathChangeEvent\",\t\t\"PORTUndesiredConnectionAttemptEvent\",\n\t\"SMTPeerWrapCondition\",\t\t\"SMTHoldCondition\",\n\t\"MACFrameErrorCondition\",\t\"MACDuplicateAddressCondition\",\n\t\"MACNotCopiedCondition\",\t\"PORTEBErrorCondition\",\n\t\"PORTLerCondition\"\n} ;\n\nvoid smt_srf_event(struct s_smc *smc, int code, int index, int cond)\n{\n\tstruct s_srf_evc\t*evc ;\n\tint\t\t\tcond_asserted = 0 ;\n\tint\t\t\tcond_deasserted = 0 ;\n\tint\t\t\tevent_occurred = 0 ;\n\tint\t\t\ttsr ;\n\tint\t\t\tT_Limit = 2*TICKS_PER_SECOND ;\n\n\tif (code == SMT_COND_MAC_DUP_ADDR && cond) {\n\t\tRS_SET(smc,RS_DUPADDR) ;\n\t}\n\n\tif (code) {\n\t\tDB_SMT(\"SRF: %s index %d\", srf_names[code], index);\n\n\t\tif (!(evc = smt_get_evc(smc,code,index))) {\n\t\t\tDB_SMT(\"SRF : smt_get_evc() failed\");\n\t\t\treturn ;\n\t\t}\n\t\t \n\t\tif (SMT_IS_CONDITION(code)) {\n\t\t\tif (*evc->evc_cond_state == cond)\n\t\t\t\treturn ;\n\t\t}\n\n\t\t \n\t\tsmt_set_timestamp(smc,smc->mib.fddiSMTTransitionTimeStamp) ;\n\t\tif (SMT_IS_CONDITION(code)) {\n\t\t\tDB_SMT(\"SRF: condition is %s\", cond ? \"ON\" : \"OFF\");\n\t\t\tif (cond) {\n\t\t\t\t*evc->evc_cond_state = TRUE ;\n\t\t\t\tevc->evc_rep_required = TRUE ;\n\t\t\t\tsmc->srf.any_report = TRUE ;\n\t\t\t\tcond_asserted = TRUE ;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t*evc->evc_cond_state = FALSE ;\n\t\t\t\tcond_deasserted = TRUE ;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (evc->evc_rep_required) {\n\t\t\t\t*evc->evc_multiple  = TRUE ;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tevc->evc_rep_required = TRUE ;\n\t\t\t\t*evc->evc_multiple  = FALSE ;\n\t\t\t}\n\t\t\tsmc->srf.any_report = TRUE ;\n\t\t\tevent_occurred = TRUE ;\n\t\t}\n#ifdef\tFDDI_MIB\n\t\tsnmp_srf_event(smc,evc) ;\n#endif\t \n\t}\n\ttsr = smt_get_time() - smc->srf.TSR ;\n\n\tswitch (smc->srf.sr_state) {\n\tcase SR0_WAIT :\n\t\t \n\t\tif (cond_asserted && tsr < T_Limit) {\n\t\t\tsmc->srf.SRThreshold = THRESHOLD_2 ;\n\t\t\tsmc->srf.sr_state = SR1_HOLDOFF ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\tif (cond_deasserted && tsr < T_Limit) {\n\t\t\tsmc->srf.sr_state = SR1_HOLDOFF ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\tif (event_occurred && tsr < T_Limit) {\n\t\t\tsmc->srf.sr_state = SR1_HOLDOFF ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\tif (cond_asserted && tsr >= T_Limit) {\n\t\t\tsmc->srf.SRThreshold = THRESHOLD_2 ;\n\t\t\tsmc->srf.TSR = smt_get_time() ;\n\t\t\tsmt_send_srf(smc) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\tif (cond_deasserted && tsr >= T_Limit) {\n\t\t\tsmc->srf.TSR = smt_get_time() ;\n\t\t\tsmt_send_srf(smc) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\tif (event_occurred && tsr >= T_Limit) {\n\t\t\tsmc->srf.TSR = smt_get_time() ;\n\t\t\tsmt_send_srf(smc) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\tif (smc->srf.any_report && (u_long) tsr >=\n\t\t\tsmc->srf.SRThreshold) {\n\t\t\tsmc->srf.SRThreshold *= 2 ;\n\t\t\tif (smc->srf.SRThreshold > THRESHOLD_32)\n\t\t\t\tsmc->srf.SRThreshold = THRESHOLD_32 ;\n\t\t\tsmc->srf.TSR = smt_get_time() ;\n\t\t\tsmt_send_srf(smc) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\tif (!smc->mib.fddiSMTStatRptPolicy) {\n\t\t\tsmc->srf.sr_state = SR2_DISABLED ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak ;\n\tcase SR1_HOLDOFF :\n\t\t \n\t\tif (tsr >= T_Limit) {\n\t\t\tsmc->srf.sr_state = SR0_WAIT ;\n\t\t\tsmc->srf.TSR = smt_get_time() ;\n\t\t\tsmt_send_srf(smc) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\tif (cond_asserted) {\n\t\t\tsmc->srf.SRThreshold = THRESHOLD_2 ;\n\t\t}\n\t\t \n\t\t \n\t\t \n\t\t \n\t\tif (!smc->mib.fddiSMTStatRptPolicy) {\n\t\t\tsmc->srf.sr_state = SR2_DISABLED ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak ;\n\tcase SR2_DISABLED :\n\t\tif (smc->mib.fddiSMTStatRptPolicy) {\n\t\t\tsmc->srf.sr_state = SR0_WAIT ;\n\t\t\tsmc->srf.TSR = smt_get_time() ;\n\t\t\tsmc->srf.SRThreshold = THRESHOLD_2 ;\n\t\t\tclear_all_rep(smc) ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak ;\n\t}\n}\n\nstatic void clear_all_rep(struct s_smc *smc)\n{\n\tstruct s_srf_evc\t*evc ;\n\tunsigned int\t\ti ;\n\n\tfor (i = 0, evc = smc->evcs ; i < MAX_EVCS ; i++, evc++) {\n\t\tevc->evc_rep_required = FALSE ;\n\t\tif (SMT_IS_CONDITION(evc->evc_code))\n\t\t\t*evc->evc_cond_state = FALSE ;\n\t}\n\tsmc->srf.any_report = FALSE ;\n}\n\nstatic void clear_reported(struct s_smc *smc)\n{\n\tstruct s_srf_evc\t*evc ;\n\tunsigned int\t\ti ;\n\n\tsmc->srf.any_report = FALSE ;\n\tfor (i = 0, evc = smc->evcs ; i < MAX_EVCS ; i++, evc++) {\n\t\tif (SMT_IS_CONDITION(evc->evc_code)) {\n\t\t\tif (*evc->evc_cond_state == FALSE)\n\t\t\t\tevc->evc_rep_required = FALSE ;\n\t\t\telse\n\t\t\t\tsmc->srf.any_report = TRUE ;\n\t\t}\n\t\telse {\n\t\t\tevc->evc_rep_required = FALSE ;\n\t\t\t*evc->evc_multiple = FALSE ;\n\t\t}\n\t}\n}\n\n \nstatic void smt_send_srf(struct s_smc *smc)\n{\n\n\tstruct smt_header\t*smt ;\n\tstruct s_srf_evc\t*evc ;\n\tSK_LOC_DECL(struct s_pcon,pcon) ;\n\tSMbuf\t\t\t*mb ;\n\tunsigned int\t\ti ;\n\n\tstatic const struct fddi_addr SMT_SRF_DA = {\n\t\t{ 0x80, 0x01, 0x43, 0x00, 0x80, 0x08 }\n\t} ;\n\n\t \n\tif (!smc->r.sm_ma_avail)\n\t\treturn ;\n\tif (!(mb = smt_build_frame(smc,SMT_SRF,SMT_ANNOUNCE,0)))\n\t\treturn ;\n\n\tRS_SET(smc,RS_SOFTERROR) ;\n\n\tsmt = smtod(mb, struct smt_header *) ;\n\tsmt->smt_dest = SMT_SRF_DA ;\t\t \n\n\t \n\tpcon.pc_len = SMT_MAX_INFO_LEN ;\t \n\tpcon.pc_err = 0 ;\t\t\t \n\tpcon.pc_badset = 0 ;\t\t\t \n\tpcon.pc_p = (void *) (smt + 1) ;\t \n\n\tsmt_add_para(smc,&pcon,(u_short) SMT_P1033,0,0) ;\n\tsmt_add_para(smc,&pcon,(u_short) SMT_P1034,0,0) ;\n\n\tfor (i = 0, evc = smc->evcs ; i < MAX_EVCS ; i++, evc++) {\n\t\tif (evc->evc_rep_required) {\n\t\t\tsmt_add_para(smc,&pcon,evc->evc_para,\n\t\t\t\t(int)evc->evc_index,0) ;\n\t\t}\n\t}\n\tsmt->smt_len = SMT_MAX_INFO_LEN - pcon.pc_len ;\n\tmb->sm_len = smt->smt_len + sizeof(struct smt_header) ;\n\n\tDB_SMT(\"SRF: sending SRF at %p, len %d\", smt, mb->sm_len);\n\tDB_SMT(\"SRF: state SR%d Threshold %lu\",\n\t       smc->srf.sr_state, smc->srf.SRThreshold / TICKS_PER_SECOND);\n#ifdef\tDEBUG\n\tdump_smt(smc,smt,\"SRF Send\") ;\n#endif\n\tsmt_send_frame(smc,mb,FC_SMT_INFO,0) ;\n\tclear_reported(smc) ;\n}\n\n#endif\t \n#endif\t \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}