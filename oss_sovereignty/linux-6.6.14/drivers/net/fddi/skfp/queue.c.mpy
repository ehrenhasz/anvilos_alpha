{
  "module_name": "queue.c",
  "hash_id": "75fffe1c29d908b39e5a87f07306f3777ae8e005c505704d8bafb4d9fe255b38",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/fddi/skfp/queue.c",
  "human_readable_source": "\n \n\n \n\n#include \"h/types.h\"\n#include \"h/fddi.h\"\n#include \"h/smc.h\"\n\n#define PRINTF(a,b,c)\n\n \nvoid ev_init(struct s_smc *smc)\n{\n\tsmc->q.ev_put = smc->q.ev_get = smc->q.ev_queue ;\n}\n\n \nvoid queue_event(struct s_smc *smc, int class, int event)\n{\n\tPRINTF(\"queue class %d event %d\\n\",class,event) ;\n\tsmc->q.ev_put->class = class ;\n\tsmc->q.ev_put->event = event ;\n\tif (++smc->q.ev_put == &smc->q.ev_queue[MAX_EVENT])\n\t\tsmc->q.ev_put = smc->q.ev_queue ;\n\n\tif (smc->q.ev_put == smc->q.ev_get) {\n\t\tSMT_ERR_LOG(smc,SMT_E0137, SMT_E0137_MSG) ;\n\t}\n}\n\n \nvoid timer_event(struct s_smc *smc, u_long token)\n{\n\tPRINTF(\"timer event class %d token %d\\n\",\n\t\tEV_T_CLASS(token),\n\t\tEV_T_EVENT(token)) ;\n\tqueue_event(smc,EV_T_CLASS(token),EV_T_EVENT(token));\n}\n\n \nvoid ev_dispatcher(struct s_smc *smc)\n{\n\tstruct event_queue *ev ;\t \n\tint\t\tclass ;\n\n\tev = smc->q.ev_get ;\n\tPRINTF(\"dispatch get %x put %x\\n\",ev,smc->q.ev_put) ;\n\twhile (ev != smc->q.ev_put) {\n\t\tPRINTF(\"dispatch class %d event %d\\n\",ev->class,ev->event) ;\n\t\tswitch(class = ev->class) {\n\t\tcase EVENT_ECM :\t\t \n\t\t\tecm(smc,(int)ev->event) ;\n\t\t\tbreak ;\n\t\tcase EVENT_CFM :\t\t \n\t\t\tcfm(smc,(int)ev->event) ;\n\t\t\tbreak ;\n\t\tcase EVENT_RMT :\t\t \n\t\t\trmt(smc,(int)ev->event) ;\n\t\t\tbreak ;\n\t\tcase EVENT_SMT :\n\t\t\tsmt_event(smc,(int)ev->event) ;\n\t\t\tbreak ;\n#ifdef\tCONCENTRATOR\n\t\tcase 99 :\n\t\t\ttimer_test_event(smc,(int)ev->event) ;\n\t\t\tbreak ;\n#endif\n\t\tcase EVENT_PCMA :\t\t \n\t\tcase EVENT_PCMB :\t\t \n\t\tdefault :\n\t\t\tif (class >= EVENT_PCMA &&\n\t\t\t    class < EVENT_PCMA + NUMPHYS) {\n\t\t\t\tpcm(smc,class - EVENT_PCMA,(int)ev->event) ;\n\t\t\t\tbreak ;\n\t\t\t}\n\t\t\tSMT_PANIC(smc,SMT_E0121, SMT_E0121_MSG) ;\n\t\t\treturn ;\n\t\t}\n\n\t\tif (++ev == &smc->q.ev_queue[MAX_EVENT])\n\t\t\tev = smc->q.ev_queue ;\n\n\t\t \n\t\tsmc->q.ev_get = ev;\n\t}\n}\n\n \nu_short smt_online(struct s_smc *smc, int on)\n{\n\tqueue_event(smc,EVENT_ECM,on ? EC_CONNECT : EC_DISCONNECT) ;\n\tev_dispatcher(smc) ;\n\treturn smc->mib.fddiSMTCF_State;\n}\n\n \n#ifdef\tCONCENTRATOR\nvoid do_smt_flag(struct s_smc *smc, char *flag, int value)\n{\n#ifdef\tDEBUG\n\tstruct smt_debug\t*deb;\n\n\tSK_UNUSED(smc) ;\n\n#ifdef\tDEBUG_BRD\n\tdeb = &smc->debug;\n#else\n\tdeb = &debug;\n#endif\n\tif (!strcmp(flag,\"smt\"))\n\t\tdeb->d_smt = value ;\n\telse if (!strcmp(flag,\"smtf\"))\n\t\tdeb->d_smtf = value ;\n\telse if (!strcmp(flag,\"pcm\"))\n\t\tdeb->d_pcm = value ;\n\telse if (!strcmp(flag,\"rmt\"))\n\t\tdeb->d_rmt = value ;\n\telse if (!strcmp(flag,\"cfm\"))\n\t\tdeb->d_cfm = value ;\n\telse if (!strcmp(flag,\"ecm\"))\n\t\tdeb->d_ecm = value ;\n\tprintf(\"smt\t%d\\n\",deb->d_smt) ;\n\tprintf(\"smtf\t%d\\n\",deb->d_smtf) ;\n\tprintf(\"pcm\t%d\\n\",deb->d_pcm) ;\n\tprintf(\"rmt\t%d\\n\",deb->d_rmt) ;\n\tprintf(\"cfm\t%d\\n\",deb->d_cfm) ;\n\tprintf(\"ecm\t%d\\n\",deb->d_ecm) ;\n#endif\t \n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}