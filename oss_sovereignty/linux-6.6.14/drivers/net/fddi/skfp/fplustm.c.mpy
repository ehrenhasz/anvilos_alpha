{
  "module_name": "fplustm.c",
  "hash_id": "f86d3e973dc3cbb224a571e5a929f6553945e1987376362164c6f33058caa0d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/fddi/skfp/fplustm.c",
  "human_readable_source": "\n \n\n \n\n#include \"h/types.h\"\n#include \"h/fddi.h\"\n#include \"h/smc.h\"\n#include \"h/supern_2.h\"\n#include <linux/bitrev.h>\n#include <linux/etherdevice.h>\n\n#ifndef UNUSED\n#ifdef  lint\n#define UNUSED(x)\t(x) = (x)\n#else\n#define UNUSED(x)\n#endif\n#endif\n\n#define FM_ADDRX\t (FM_ADDET|FM_EXGPA0|FM_EXGPA1)\n#define MS2BCLK(x)\t((x)*12500L)\n#define US2BCLK(x)\t((x)*1250L)\n\n \nstatic void build_claim_beacon(struct s_smc *smc, u_long t_request);\nstatic int init_mac(struct s_smc *smc, int all);\nstatic void rtm_init(struct s_smc *smc);\nstatic void smt_split_up_fifo(struct s_smc *smc);\n\n#if (!defined(NO_SMT_PANIC) || defined(DEBUG))\nstatic\tchar write_mdr_warning [] = \"E350 write_mdr() FM_SNPPND is set\\n\";\nstatic\tchar cam_warning [] = \"E_SMT_004: CAM still busy\\n\";\n#endif\n\n#define\tDUMMY_READ()\tsmc->hw.mc_dummy = (u_short) inp(ADDR(B0_RAP))\n\n#define\tCHECK_NPP() {\tunsigned int k = 10000 ;\\\n\t\t\twhile ((inpw(FM_A(FM_STMCHN)) & FM_SNPPND) && k) k--;\\\n\t\t\tif (!k) { \\\n\t\t\t\tSMT_PANIC(smc,SMT_E0130, SMT_E0130_MSG) ; \\\n\t\t\t}\t\\\n\t\t}\n\n#define\tCHECK_CAM() {\tunsigned int k = 10 ;\\\n\t\t\twhile (!(inpw(FM_A(FM_AFSTAT)) & FM_DONE) && k) k--;\\\n\t\t\tif (!k) { \\\n\t\t\t\tSMT_PANIC(smc,SMT_E0131, SMT_E0131_MSG) ; \\\n\t\t\t}\t\\\n\t\t}\n\nconst struct fddi_addr fddi_broadcast = {{0xff,0xff,0xff,0xff,0xff,0xff}};\nstatic const struct fddi_addr null_addr = {{0,0,0,0,0,0}};\nstatic const struct fddi_addr dbeacon_multi = {{0x01,0x80,0xc2,0x00,0x01,0x00}};\n\nstatic const u_short my_said = 0xffff ;\t \nstatic const u_short my_sagp = 0xffff ;\t \n\n \n#ifdef\tUSE_CAN_ADDR\n#define MA\tsmc->hw.fddi_canon_addr\n#else\n#define MA\tsmc->hw.fddi_home_addr\n#endif\n\n\n \nstatic const int mac_imsk1u = FM_STXABRS | FM_STXABRA0 | FM_SXMTABT ;\nstatic const int mac_imsk1l = FM_SQLCKS | FM_SQLCKA0 | FM_SPCEPDS | FM_SPCEPDA0|\n\t\t\tFM_STBURS | FM_STBURA0 ;\n\n\t \nstatic const int mac_imsk2u = FM_SERRSF | FM_SNFSLD | FM_SRCVOVR | FM_SRBFL |\n\t\t\tFM_SMYCLM ;\nstatic const int mac_imsk2l = FM_STRTEXR | FM_SDUPCLM | FM_SFRMCTR |\n\t\t\tFM_SERRCTR | FM_SLSTCTR |\n\t\t\tFM_STRTEXP | FM_SMULTDA | FM_SRNGOP ;\n\nstatic const int mac_imsk3u = FM_SRCVOVR2 | FM_SRBFL2 ;\nstatic const int mac_imsk3l = FM_SRPERRQ2 | FM_SRPERRQ1 ;\n\nstatic const int mac_beacon_imsk2u = FM_SOTRBEC | FM_SMYBEC | FM_SBEC |\n\t\t\tFM_SLOCLM | FM_SHICLM | FM_SMYCLM | FM_SCLM ;\n\n\nstatic u_long mac_get_tneg(struct s_smc *smc)\n{\n\tu_long\ttneg ;\n\n\ttneg = (u_long)((long)inpw(FM_A(FM_TNEG))<<5) ;\n\treturn (u_long)((tneg + ((inpw(FM_A(FM_TMRS))>>10)&0x1f)) |\n\t\t0xffe00000L) ;\n}\n\nvoid mac_update_counter(struct s_smc *smc)\n{\n\tsmc->mib.m[MAC0].fddiMACFrame_Ct =\n\t\t(smc->mib.m[MAC0].fddiMACFrame_Ct & 0xffff0000L)\n\t\t+ (u_short) inpw(FM_A(FM_FCNTR)) ;\n\tsmc->mib.m[MAC0].fddiMACLost_Ct =\n\t\t(smc->mib.m[MAC0].fddiMACLost_Ct & 0xffff0000L)\n\t\t+ (u_short) inpw(FM_A(FM_LCNTR)) ;\n\tsmc->mib.m[MAC0].fddiMACError_Ct =\n\t\t(smc->mib.m[MAC0].fddiMACError_Ct & 0xffff0000L)\n\t\t+ (u_short) inpw(FM_A(FM_ECNTR)) ;\n\tsmc->mib.m[MAC0].fddiMACT_Neg = mac_get_tneg(smc) ;\n#ifdef SMT_REAL_TOKEN_CT\n\t \n\tTBD\n#else\n\tsmt_emulate_token_ct( smc, MAC0 );\n#endif\n}\n\n \nstatic void write_mdr(struct s_smc *smc, u_long val)\n{\n\tCHECK_NPP() ;\n\tMDRW(val) ;\n}\n\n#if 0\n \nstatic u_long read_mdr(struct s_smc *smc, unsigned int addr)\n{\n\tlong p ;\n\tCHECK_NPP() ;\n\tMARR(addr) ;\n\toutpw(FM_A(FM_CMDREG1),FM_IRMEMWO) ;\n\tCHECK_NPP() ;\t \n \t \n\t\t\t \n\t\t\t \n\tp = (u_long)inpw(FM_A(FM_MDRU))<<16 ;\n\tp += (u_long)inpw(FM_A(FM_MDRL)) ;\n\treturn p;\n}\n#endif\n\n \nstatic void init_ram(struct s_smc *smc)\n{\n\tu_short i ;\n\n\tsmc->hw.fp.fifo.rbc_ram_start = 0 ;\n\tsmc->hw.fp.fifo.rbc_ram_end =\n\t\tsmc->hw.fp.fifo.rbc_ram_start + RBC_MEM_SIZE ;\n\tCHECK_NPP() ;\n\tMARW(smc->hw.fp.fifo.rbc_ram_start) ;\n\tfor (i = smc->hw.fp.fifo.rbc_ram_start;\n\t\ti < (u_short) (smc->hw.fp.fifo.rbc_ram_end-1); i++)\n\t\twrite_mdr(smc,0L) ;\n\t \n\twrite_mdr(smc,0L) ;\n}\n\n \nstatic void set_recvptr(struct s_smc *smc)\n{\n\t \n\toutpw(FM_A(FM_RPR1),smc->hw.fp.fifo.rx1_fifo_start) ;\t \n\toutpw(FM_A(FM_SWPR1),smc->hw.fp.fifo.rx1_fifo_start) ;\t \n\toutpw(FM_A(FM_WPR1),smc->hw.fp.fifo.rx1_fifo_start) ;\t \n\toutpw(FM_A(FM_EARV1),smc->hw.fp.fifo.tx_s_start-1) ;\t \n\n\t \n\tif (smc->hw.fp.fifo.rx2_fifo_size) {\n\t\toutpw(FM_A(FM_RPR2),smc->hw.fp.fifo.rx2_fifo_start) ;\n\t\toutpw(FM_A(FM_SWPR2),smc->hw.fp.fifo.rx2_fifo_start) ;\n\t\toutpw(FM_A(FM_WPR2),smc->hw.fp.fifo.rx2_fifo_start) ;\n\t\toutpw(FM_A(FM_EARV2),smc->hw.fp.fifo.rbc_ram_end-1) ;\n\t}\n\telse {\n\t\toutpw(FM_A(FM_RPR2),smc->hw.fp.fifo.rbc_ram_end-1) ;\n\t\toutpw(FM_A(FM_SWPR2),smc->hw.fp.fifo.rbc_ram_end-1) ;\n\t\toutpw(FM_A(FM_WPR2),smc->hw.fp.fifo.rbc_ram_end-1) ;\n\t\toutpw(FM_A(FM_EARV2),smc->hw.fp.fifo.rbc_ram_end-1) ;\n\t}\n}\n\n \nstatic void set_txptr(struct s_smc *smc)\n{\n\toutpw(FM_A(FM_CMDREG2),FM_IRSTQ) ;\t \n\n\t \n\toutpw(FM_A(FM_RPXA0),smc->hw.fp.fifo.tx_a0_start) ;\t \n\toutpw(FM_A(FM_SWPXA0),smc->hw.fp.fifo.tx_a0_start) ;\t \n\toutpw(FM_A(FM_WPXA0),smc->hw.fp.fifo.tx_a0_start) ;\t \n\toutpw(FM_A(FM_EAA0),smc->hw.fp.fifo.rx2_fifo_start-1) ;\t \n\n\t \n\tif (smc->hw.fp.fifo.tx_s_size) {\n\t\toutpw(FM_A(FM_RPXS),smc->hw.fp.fifo.tx_s_start) ;\n\t\toutpw(FM_A(FM_SWPXS),smc->hw.fp.fifo.tx_s_start) ;\n\t\toutpw(FM_A(FM_WPXS),smc->hw.fp.fifo.tx_s_start) ;\n\t\toutpw(FM_A(FM_EAS),smc->hw.fp.fifo.tx_a0_start-1) ;\n\t}\n\telse {\n\t\toutpw(FM_A(FM_RPXS),smc->hw.fp.fifo.tx_a0_start-1) ;\n\t\toutpw(FM_A(FM_SWPXS),smc->hw.fp.fifo.tx_a0_start-1) ;\n\t\toutpw(FM_A(FM_WPXS),smc->hw.fp.fifo.tx_a0_start-1) ;\n\t\toutpw(FM_A(FM_EAS),smc->hw.fp.fifo.tx_a0_start-1) ;\n\t}\n}\n\n \nstatic void init_rbc(struct s_smc *smc)\n{\n\tu_short\trbc_ram_addr ;\n\n\t \n\trbc_ram_addr = smc->hw.fp.fifo.rx2_fifo_start - 1 ;\n\n\toutpw(FM_A(FM_RPXA1),rbc_ram_addr) ;\t \n\toutpw(FM_A(FM_WPXA1),rbc_ram_addr) ;\n\toutpw(FM_A(FM_SWPXA1),rbc_ram_addr) ;\n\toutpw(FM_A(FM_EAA1),rbc_ram_addr) ;\n\n\tset_recvptr(smc) ;\n\tset_txptr(smc) ;\n}\n\n \nstatic void init_rx(struct s_smc *smc)\n{\n\tstruct s_smt_rx_queue\t*queue ;\n\n\t \n\tsmc->hw.fp.rx[QUEUE_R1] = queue = &smc->hw.fp.rx_q[QUEUE_R1] ;\n\tqueue->rx_bmu_ctl = (HW_PTR) ADDR(B0_R1_CSR) ;\n\tqueue->rx_bmu_dsc = (HW_PTR) ADDR(B4_R1_DA) ;\n\n\t \n\tsmc->hw.fp.rx[QUEUE_R2] = queue = &smc->hw.fp.rx_q[QUEUE_R2] ;\n\tqueue->rx_bmu_ctl = (HW_PTR) ADDR(B0_R2_CSR) ;\n\tqueue->rx_bmu_dsc = (HW_PTR) ADDR(B4_R2_DA) ;\n}\n\n \nvoid set_formac_tsync(struct s_smc *smc, long sync_bw)\n{\n\toutpw(FM_A(FM_TSYNC),(unsigned int) (((-sync_bw) >> 5) & 0xffff) ) ;\n}\n\n \nstatic void init_tx(struct s_smc *smc)\n{\n\tstruct s_smt_tx_queue\t*queue ;\n\n\t \n\tsmc->hw.fp.tx[QUEUE_S] = queue = &smc->hw.fp.tx_q[QUEUE_S] ;\n\tqueue->tx_bmu_ctl = (HW_PTR) ADDR(B0_XS_CSR) ;\n\tqueue->tx_bmu_dsc = (HW_PTR) ADDR(B5_XS_DA) ;\n\n#ifdef ESS\n\tset_formac_tsync(smc,smc->ess.sync_bw) ;\n#endif\n\n\t \n\tsmc->hw.fp.tx[QUEUE_A0] = queue = &smc->hw.fp.tx_q[QUEUE_A0] ;\n\tqueue->tx_bmu_ctl = (HW_PTR) ADDR(B0_XA_CSR) ;\n\tqueue->tx_bmu_dsc = (HW_PTR) ADDR(B5_XA_DA) ;\n\n\n\tllc_recover_tx(smc) ;\n}\n\nstatic void mac_counter_init(struct s_smc *smc)\n{\n\tint i ;\n\tu_long *ec ;\n\n\t \n\toutpw(FM_A(FM_FCNTR),0) ;\n\toutpw(FM_A(FM_LCNTR),0) ;\n\toutpw(FM_A(FM_ECNTR),0) ;\n\t \n\tec = (u_long *)&smc->hw.fp.err_stats ;\n\tfor (i = (sizeof(struct err_st)/sizeof(long)) ; i ; i--)\n\t\t*ec++ = 0L ;\n\tsmc->mib.m[MAC0].fddiMACRingOp_Ct = 0 ;\n}\n\n \nstatic\tvoid set_formac_addr(struct s_smc *smc)\n{\n\tlong\tt_requ = smc->mib.m[MAC0].fddiMACT_Req ;\n\n\toutpw(FM_A(FM_SAID),my_said) ;\t \n\toutpw(FM_A(FM_LAIL),(unsigned short)((smc->hw.fddi_home_addr.a[4]<<8) +\n\t\t\t\t\tsmc->hw.fddi_home_addr.a[5])) ;\n\toutpw(FM_A(FM_LAIC),(unsigned short)((smc->hw.fddi_home_addr.a[2]<<8) +\n\t\t\t\t\tsmc->hw.fddi_home_addr.a[3])) ;\n\toutpw(FM_A(FM_LAIM),(unsigned short)((smc->hw.fddi_home_addr.a[0]<<8) +\n\t\t\t\t\tsmc->hw.fddi_home_addr.a[1])) ;\n\n\toutpw(FM_A(FM_SAGP),my_sagp) ;\t \n\n\toutpw(FM_A(FM_LAGL),(unsigned short)((smc->hw.fp.group_addr.a[4]<<8) +\n\t\t\t\t\tsmc->hw.fp.group_addr.a[5])) ;\n\toutpw(FM_A(FM_LAGC),(unsigned short)((smc->hw.fp.group_addr.a[2]<<8) +\n\t\t\t\t\tsmc->hw.fp.group_addr.a[3])) ;\n\toutpw(FM_A(FM_LAGM),(unsigned short)((smc->hw.fp.group_addr.a[0]<<8) +\n\t\t\t\t\tsmc->hw.fp.group_addr.a[1])) ;\n\n\t \n\toutpw(FM_A(FM_TREQ1),(unsigned short)(t_requ>>16)) ;\n\toutpw(FM_A(FM_TREQ0),(unsigned short)t_requ) ;\n}\n\nstatic void set_int(char *p, int l)\n{\n\tp[0] = (char)(l >> 24) ;\n\tp[1] = (char)(l >> 16) ;\n\tp[2] = (char)(l >> 8) ;\n\tp[3] = (char)(l >> 0) ;\n}\n\n \nstatic void copy_tx_mac(struct s_smc *smc, u_long td, struct fddi_mac *mac,\n\t\t\tunsigned int off, int len)\n \n \n \n \n{\n\tint\ti ;\n\t__le32\t*p ;\n\n\tCHECK_NPP() ;\n\tMARW(off) ;\t\t \n\n\tp = (__le32 *) mac ;\n\tfor (i = (len + 3)/4 ; i ; i--) {\n\t\tif (i == 1) {\n\t\t\t \n\t\t\toutpw(FM_A(FM_CMDREG2),FM_ISTTB) ;\n\t\t}\n\t\twrite_mdr(smc,le32_to_cpu(*p)) ;\n\t\tp++ ;\n\t}\n\n\toutpw(FM_A(FM_CMDREG2),FM_ISTTB) ;\t \n\twrite_mdr(smc,td) ;\t \n}\n\n \nstatic void directed_beacon(struct s_smc *smc)\n{\n\tSK_LOC_DECL(__le32,a[2]) ;\n\n\t \n\t* (char *) a = (char) ((long)DBEACON_INFO<<24L) ;\n\ta[1] = 0 ;\n\tmemcpy((char *)a+1, (char *) &smc->mib.m[MAC0].fddiMACUpstreamNbr, ETH_ALEN);\n\n\tCHECK_NPP() ;\n\t  \n\tMARW(smc->hw.fp.fifo.rbc_ram_start+DBEACON_FRAME_OFF+4) ;\n\twrite_mdr(smc,le32_to_cpu(a[0])) ;\n\toutpw(FM_A(FM_CMDREG2),FM_ISTTB) ;\t \n\twrite_mdr(smc,le32_to_cpu(a[1])) ;\n\n\toutpw(FM_A(FM_SABC),smc->hw.fp.fifo.rbc_ram_start + DBEACON_FRAME_OFF) ;\n}\n\n \nstatic void build_claim_beacon(struct s_smc *smc, u_long t_request)\n{\n\tu_int\ttd ;\n\tint\tlen ;\n\tstruct fddi_mac_sf *mac ;\n\n\t \n\tlen = 17 ;\n\ttd = TX_DESCRIPTOR | ((((u_int)len-1)&3)<<27) ;\n\tmac = &smc->hw.fp.mac_sfb ;\n\tmac->mac_fc = FC_CLAIM ;\n\t \n\tmac->mac_source = mac->mac_dest = MA ;\n\t \n\tset_int((char *)mac->mac_info,(int)t_request) ;\n\n\tcopy_tx_mac(smc,td,(struct fddi_mac *)mac,\n\t\tsmc->hw.fp.fifo.rbc_ram_start + CLAIM_FRAME_OFF,len) ;\n\t \n\toutpw(FM_A(FM_SACL),smc->hw.fp.fifo.rbc_ram_start + CLAIM_FRAME_OFF) ;\n\n\t \n\tlen = 17 ;\n\ttd = TX_DESCRIPTOR | ((((u_int)len-1)&3)<<27) ;\n\tmac->mac_fc = FC_BEACON ;\n\tmac->mac_source = MA ;\n\tmac->mac_dest = null_addr ;\t\t \n\tset_int((char *) mac->mac_info,((int)BEACON_INFO<<24) + 0 ) ;\n\n\tcopy_tx_mac(smc,td,(struct fddi_mac *)mac,\n\t\tsmc->hw.fp.fifo.rbc_ram_start + BEACON_FRAME_OFF,len) ;\n\t \n\toutpw(FM_A(FM_SABC),smc->hw.fp.fifo.rbc_ram_start + BEACON_FRAME_OFF) ;\n\n\t \n\tlen = 23 ;\n\ttd = TX_DESCRIPTOR | ((((u_int)len-1)&3)<<27) ;\n\tmac->mac_fc = FC_BEACON ;\n\tmac->mac_source = MA ;\n\tmac->mac_dest = dbeacon_multi ;\t\t \n\tset_int((char *) mac->mac_info,((int)DBEACON_INFO<<24) + 0 ) ;\n\tset_int((char *) mac->mac_info+4,0) ;\n\tset_int((char *) mac->mac_info+8,0) ;\n\n\tcopy_tx_mac(smc,td,(struct fddi_mac *)mac,\n\t\tsmc->hw.fp.fifo.rbc_ram_start + DBEACON_FRAME_OFF,len) ;\n\n\t \n\toutpw(FM_A(FM_EACB),smc->hw.fp.fifo.rx1_fifo_start-1) ;\n\n\toutpw(FM_A(FM_WPXSF),0) ;\n\toutpw(FM_A(FM_RPXSF),0) ;\n}\n\nstatic void formac_rcv_restart(struct s_smc *smc)\n{\n\t \n\tSETMASK(FM_A(FM_MDREG1),smc->hw.fp.rx_mode,FM_ADDRX) ;\n\n\toutpw(FM_A(FM_CMDREG1),FM_ICLLR) ;\t \n}\n\nvoid formac_tx_restart(struct s_smc *smc)\n{\n\toutpw(FM_A(FM_CMDREG1),FM_ICLLS) ;\t \n\toutpw(FM_A(FM_CMDREG1),FM_ICLLA0) ;\t \n}\n\nstatic void enable_formac(struct s_smc *smc)\n{\n\t \n\toutpw(FM_A(FM_IMSK1U),(unsigned short)~mac_imsk1u);\n\toutpw(FM_A(FM_IMSK1L),(unsigned short)~mac_imsk1l);\n\toutpw(FM_A(FM_IMSK2U),(unsigned short)~mac_imsk2u);\n\toutpw(FM_A(FM_IMSK2L),(unsigned short)~mac_imsk2l);\n\toutpw(FM_A(FM_IMSK3U),(unsigned short)~mac_imsk3u);\n\toutpw(FM_A(FM_IMSK3L),(unsigned short)~mac_imsk3l);\n}\n\n#if 0\t \n\t \n\n \nvoid enable_tx_irq(struct s_smc *smc, u_short queue)\n \n{\n\tu_short\timask ;\n\n\timask = ~(inpw(FM_A(FM_IMSK1U))) ;\n\n\tif (queue == 0) {\n\t\toutpw(FM_A(FM_IMSK1U),~(imask|FM_STEFRMS)) ;\n\t}\n\tif (queue == 1) {\n\t\toutpw(FM_A(FM_IMSK1U),~(imask|FM_STEFRMA0)) ;\n\t}\n}\n\n \nvoid disable_tx_irq(struct s_smc *smc, u_short queue)\n \n{\n\tu_short\timask ;\n\n\timask = ~(inpw(FM_A(FM_IMSK1U))) ;\n\n\tif (queue == 0) {\n\t\toutpw(FM_A(FM_IMSK1U),~(imask&~FM_STEFRMS)) ;\n\t}\n\tif (queue == 1) {\n\t\toutpw(FM_A(FM_IMSK1U),~(imask&~FM_STEFRMA0)) ;\n\t}\n}\n#endif\n\nstatic void disable_formac(struct s_smc *smc)\n{\n\t \n\toutpw(FM_A(FM_IMSK1U),MW) ;\n\toutpw(FM_A(FM_IMSK1L),MW) ;\n\toutpw(FM_A(FM_IMSK2U),MW) ;\n\toutpw(FM_A(FM_IMSK2L),MW) ;\n\toutpw(FM_A(FM_IMSK3U),MW) ;\n\toutpw(FM_A(FM_IMSK3L),MW) ;\n}\n\n\nstatic void mac_ring_up(struct s_smc *smc, int up)\n{\n\tif (up) {\n\t\tformac_rcv_restart(smc) ;\t \n\t\tsmc->hw.mac_ring_is_up = TRUE ;\n\t\tllc_restart_tx(smc) ;\t\t \n\t}\n\telse {\n\t\t \n\t\tSETMASK(FM_A(FM_MDREG1),FM_MDISRCV,FM_ADDET) ;\n\n\t\t \n\t\toutpw(FM_A(FM_CMDREG2),FM_IACTR) ;\n\n\t\tsmc->hw.mac_ring_is_up = FALSE ;\n\t}\n}\n\n \n \n\n \nvoid mac2_irq(struct s_smc *smc, u_short code_s2u, u_short code_s2l)\n{\n\tu_short\tchange_s2l ;\n\tu_short\tchange_s2u ;\n\n\t \n\tif (code_s2u & (FM_SCLM|FM_SHICLM|FM_SBEC|FM_SOTRBEC)) {\n\t\tqueue_event(smc,EVENT_RMT,RM_TX_STATE_CHANGE) ;\n\t}\n\telse if (code_s2l & (FM_STKISS)) {\n\t\tqueue_event(smc,EVENT_RMT,RM_TX_STATE_CHANGE) ;\n\t}\n\n\t \n\tchange_s2l = smc->hw.fp.s2l ^ code_s2l ;\n\tchange_s2u = smc->hw.fp.s2u ^ code_s2u ;\n\n\tif ((change_s2l & FM_SRNGOP) ||\n\t\t(!smc->hw.mac_ring_is_up && ((code_s2l & FM_SRNGOP)))) {\n\t\tif (code_s2l & FM_SRNGOP) {\n\t\t\tmac_ring_up(smc,1) ;\n\t\t\tqueue_event(smc,EVENT_RMT,RM_RING_OP) ;\n\t\t\tsmc->mib.m[MAC0].fddiMACRingOp_Ct++ ;\n\t\t}\n\t\telse {\n\t\t\tmac_ring_up(smc,0) ;\n\t\t\tqueue_event(smc,EVENT_RMT,RM_RING_NON_OP) ;\n\t\t}\n\t\tgoto mac2_end ;\n\t}\n\tif (code_s2l & FM_SMISFRM) {\t \n\t\tsmc->mib.m[MAC0].fddiMACNotCopied_Ct++ ;\n\t}\n\tif (code_s2u & (FM_SRCVOVR |\t \n\t\t\tFM_SRBFL)) {\t \n\t\tsmc->hw.mac_ct.mac_r_restart_counter++ ;\n \n\t\tsmt_stat_counter(smc,1) ;\n \n\t}\n\tif (code_s2u & FM_SOTRBEC)\n\t\tqueue_event(smc,EVENT_RMT,RM_OTHER_BEACON) ;\n\tif (code_s2u & FM_SMYBEC)\n\t\tqueue_event(smc,EVENT_RMT,RM_MY_BEACON) ;\n\tif (change_s2u & code_s2u & FM_SLOCLM) {\n\t\tDB_RMTN(2, \"RMT : lower claim received\");\n\t}\n\tif ((code_s2u & FM_SMYCLM) && !(code_s2l & FM_SDUPCLM)) {\n\t\t \n\t\tqueue_event(smc,EVENT_RMT,RM_MY_CLAIM) ;\n\t}\n\tif (code_s2l & FM_SDUPCLM) {\n\t\t \n\t\tqueue_event(smc,EVENT_RMT,RM_VALID_CLAIM) ;\n\t}\n\tif (change_s2u & code_s2u & FM_SHICLM) {\n\t\tDB_RMTN(2, \"RMT : higher claim received\");\n\t}\n\tif ( (code_s2l & FM_STRTEXP) ||\n\t     (code_s2l & FM_STRTEXR) )\n\t\tqueue_event(smc,EVENT_RMT,RM_TRT_EXP) ;\n\tif (code_s2l & FM_SMULTDA) {\n\t\t \n\t\tsmc->r.dup_addr_test = DA_FAILED ;\n\t\tqueue_event(smc,EVENT_RMT,RM_DUP_ADDR) ;\n\t}\n\tif (code_s2u & FM_SBEC)\n\t\tsmc->hw.fp.err_stats.err_bec_stat++ ;\n\tif (code_s2u & FM_SCLM)\n\t\tsmc->hw.fp.err_stats.err_clm_stat++ ;\n\tif (code_s2l & FM_STVXEXP)\n\t\tsmc->mib.m[MAC0].fddiMACTvxExpired_Ct++ ;\n\tif ((code_s2u & (FM_SBEC|FM_SCLM))) {\n\t\tif (!(change_s2l & FM_SRNGOP) && (smc->hw.fp.s2l & FM_SRNGOP)) {\n\t\t\tmac_ring_up(smc,0) ;\n\t\t\tqueue_event(smc,EVENT_RMT,RM_RING_NON_OP) ;\n\n\t\t\tmac_ring_up(smc,1) ;\n\t\t\tqueue_event(smc,EVENT_RMT,RM_RING_OP) ;\n\t\t\tsmc->mib.m[MAC0].fddiMACRingOp_Ct++ ;\n\t\t}\n\t}\n\tif (code_s2l & FM_SPHINV)\n\t\tsmc->hw.fp.err_stats.err_phinv++ ;\n\tif (code_s2l & FM_SSIFG)\n\t\tsmc->hw.fp.err_stats.err_sifg_det++ ;\n\tif (code_s2l & FM_STKISS)\n\t\tsmc->hw.fp.err_stats.err_tkiss++ ;\n\tif (code_s2l & FM_STKERR)\n\t\tsmc->hw.fp.err_stats.err_tkerr++ ;\n\tif (code_s2l & FM_SFRMCTR)\n\t\tsmc->mib.m[MAC0].fddiMACFrame_Ct += 0x10000L ;\n\tif (code_s2l & FM_SERRCTR)\n\t\tsmc->mib.m[MAC0].fddiMACError_Ct += 0x10000L ;\n\tif (code_s2l & FM_SLSTCTR)\n\t\tsmc->mib.m[MAC0].fddiMACLost_Ct  += 0x10000L ;\n\tif (code_s2u & FM_SERRSF) {\n\t\tSMT_PANIC(smc,SMT_E0114, SMT_E0114_MSG) ;\n\t}\nmac2_end:\n\t \n\tsmc->hw.fp.s2l = code_s2l ;\n\tsmc->hw.fp.s2u = code_s2u ;\n\toutpw(FM_A(FM_IMSK2U),~mac_imsk2u) ;\n}\n\n \nvoid mac3_irq(struct s_smc *smc, u_short code_s3u, u_short code_s3l)\n{\n\tUNUSED(code_s3l) ;\n\n\tif (code_s3u & (FM_SRCVOVR2 |\t \n\t\t\tFM_SRBFL2)) {\t \n\t\tsmc->hw.mac_ct.mac_r_restart_counter++ ;\n\t\tsmt_stat_counter(smc,1);\n\t}\n\n\n\tif (code_s3u & FM_SRPERRQ2) {\t \n\t\tSMT_PANIC(smc,SMT_E0115, SMT_E0115_MSG) ;\n\t}\n\tif (code_s3u & FM_SRPERRQ1) {\t \n\t\tSMT_PANIC(smc,SMT_E0116, SMT_E0116_MSG) ;\n\t}\n}\n\n\n \nstatic void formac_offline(struct s_smc *smc)\n{\n\toutpw(FM_A(FM_CMDREG2),FM_IACTR) ; \n\n\t \n\tSETMASK(FM_A(FM_MDREG1),FM_MDISRCV,FM_ADDET) ;\n\n\t \n\tSETMASK(FM_A(FM_MDREG1),FM_MINIT,FM_MMODE) ;\n\n\tdisable_formac(smc) ;\n\tsmc->hw.mac_ring_is_up = FALSE ;\n\tsmc->hw.hw_state = STOPPED ;\n}\n\n \nstatic void formac_online(struct s_smc *smc)\n{\n\tenable_formac(smc) ;\n\tSETMASK(FM_A(FM_MDREG1),FM_MONLINE | FM_SELRA | MDR1INIT |\n\t\tsmc->hw.fp.rx_mode, FM_MMODE | FM_SELRA | FM_ADDRX) ;\n}\n\n \nint init_fplus(struct s_smc *smc)\n{\n\tsmc->hw.fp.nsa_mode = FM_MRNNSAFNMA ;\n\tsmc->hw.fp.rx_mode = FM_MDAMA ;\n\tsmc->hw.fp.group_addr = fddi_broadcast ;\n\tsmc->hw.fp.func_addr = 0 ;\n\tsmc->hw.fp.frselreg_init = 0 ;\n\n\tinit_driver_fplus(smc) ;\n\tif (smc->s.sas == SMT_DAS)\n\t\tsmc->hw.fp.mdr3init |= FM_MENDAS ;\n\n\tsmc->hw.mac_ct.mac_nobuf_counter = 0 ;\n\tsmc->hw.mac_ct.mac_r_restart_counter = 0 ;\n\n\tsmc->hw.fp.fm_st1u = (HW_PTR) ADDR(B0_ST1U) ;\n\tsmc->hw.fp.fm_st1l = (HW_PTR) ADDR(B0_ST1L) ;\n\tsmc->hw.fp.fm_st2u = (HW_PTR) ADDR(B0_ST2U) ;\n\tsmc->hw.fp.fm_st2l = (HW_PTR) ADDR(B0_ST2L) ;\n\tsmc->hw.fp.fm_st3u = (HW_PTR) ADDR(B0_ST3U) ;\n\tsmc->hw.fp.fm_st3l = (HW_PTR) ADDR(B0_ST3L) ;\n\n\tsmc->hw.fp.s2l = smc->hw.fp.s2u = 0 ;\n\tsmc->hw.mac_ring_is_up = 0 ;\n\n\tmac_counter_init(smc) ;\n\n\t \n\tsmc->hw.mac_pa.t_neg = (u_long)0 ;\n\tsmc->hw.mac_pa.t_pri = (u_long)0 ;\n\n\t \n\tmac_do_pci_fix(smc) ;\n\n\treturn init_mac(smc, 1);\n\t \n}\n\nstatic int init_mac(struct s_smc *smc, int all)\n{\n\tu_short\tt_max,x ;\n\tu_long\ttime=0 ;\n\n\t \n\toutpw(FM_A(FM_MDREG1),FM_MINIT) ;\t \n\tset_formac_addr(smc) ;\n\toutpw(FM_A(FM_MDREG1),FM_MMEMACT) ;\t \n\t \n\toutpw(FM_A(FM_MDREG2),smc->hw.fp.mdr2init) ;\n\n\tif (all) {\n\t\tinit_ram(smc) ;\n\t}\n\telse {\n\t\t \n\t\toutp(ADDR(B0_CTRL), CTRL_HPI_SET) ;\n\t\ttime = hwt_quick_read(smc) ;\n\t}\n\n\t \n\tsmt_split_up_fifo(smc) ;\n\n\tinit_tx(smc) ;\n\tinit_rx(smc) ;\n\tinit_rbc(smc) ;\n\n\tbuild_claim_beacon(smc,smc->mib.m[MAC0].fddiMACT_Req) ;\n\n\t \n\t \n\toutpw(FM_A(FM_FRMTHR),14<<12) ;\t\t \n\n\t \n\toutpw(FM_A(FM_MDREG1),MDR1INIT | FM_SELRA | smc->hw.fp.rx_mode) ;\n\toutpw(FM_A(FM_MDREG2),smc->hw.fp.mdr2init) ;\n\toutpw(FM_A(FM_MDREG3),smc->hw.fp.mdr3init) ;\n\toutpw(FM_A(FM_FRSELREG),smc->hw.fp.frselreg_init) ;\n\n\t \n\t \n\tt_max = (u_short)(smc->mib.m[MAC0].fddiMACT_Max/32) ;\n\tx = t_max/0x27 ;\n\tx *= 0x27 ;\n\tif ((t_max == 0xfffe) || (t_max - x == 0x16))\n\t\tt_max-- ;\n\toutpw(FM_A(FM_TMAX),(u_short)t_max) ;\n\n\t \n\tif (smc->mib.m[MAC0].fddiMACTvxValue < (u_long) (- US2BCLK(52))) {\n\t\toutpw(FM_A(FM_TVX), (u_short) (- US2BCLK(52))/255 & MB) ;\n\t} else {\n\t\toutpw(FM_A(FM_TVX),\n\t\t\t(u_short)((smc->mib.m[MAC0].fddiMACTvxValue/255) & MB)) ;\n\t}\n\n\toutpw(FM_A(FM_CMDREG1),FM_ICLLS) ;\t \n\toutpw(FM_A(FM_CMDREG1),FM_ICLLA0) ;\t \n\toutpw(FM_A(FM_CMDREG1),FM_ICLLR);\t \n\n\t \n\toutpw(FM_A(FM_UNLCKDLY),(0xff|(0xff<<8))) ;\n\n\trtm_init(smc) ;\t\t\t\t \n\n\tif (!all) {\n\t\t \n\t\thwt_wait_time(smc,time,MS2BCLK(10)) ;\n\t\toutpd(ADDR(B0_R1_CSR),CSR_SET_RESET) ;\n\t\toutpd(ADDR(B0_XA_CSR),CSR_SET_RESET) ;\n\t\toutpd(ADDR(B0_XS_CSR),CSR_SET_RESET) ;\n\t\toutp(ADDR(B0_CTRL), CTRL_HPI_CLR) ;\n\t\toutpd(ADDR(B0_R1_CSR),CSR_CLR_RESET) ;\n\t\toutpd(ADDR(B0_XA_CSR),CSR_CLR_RESET) ;\n\t\toutpd(ADDR(B0_XS_CSR),CSR_CLR_RESET) ;\n\t\tif (!smc->hw.hw_is_64bit) {\n\t\t\toutpd(ADDR(B4_R1_F), RX_WATERMARK) ;\n\t\t\toutpd(ADDR(B5_XA_F), TX_WATERMARK) ;\n\t\t\toutpd(ADDR(B5_XS_F), TX_WATERMARK) ;\n\t\t}\n\t\tsmc->hw.hw_state = STOPPED ;\n\t\tmac_drv_repair_descr(smc) ;\n\t}\n\tsmc->hw.hw_state = STARTED ;\n\n\treturn 0;\n}\n\n\n \nvoid config_mux(struct s_smc *smc, int mux)\n{\n\tplc_config_mux(smc,mux) ;\n\n\tSETMASK(FM_A(FM_MDREG1),FM_SELRA,FM_SELRA) ;\n}\n\n \nvoid sm_mac_check_beacon_claim(struct s_smc *smc)\n{\n\t \n\toutpw(FM_A(FM_IMSK2U),~(mac_imsk2u | mac_beacon_imsk2u)) ;\n\t \n\tformac_rcv_restart(smc) ;\n\tprocess_receive(smc) ;\n}\n\n \n \nvoid sm_ma_control(struct s_smc *smc, int mode)\n{\n\tswitch(mode) {\n\tcase MA_OFFLINE :\n\t\t \n\t\tformac_offline(smc) ;\n\t\tbreak ;\n\tcase MA_RESET :\n\t\t(void)init_mac(smc,0) ;\n\t\tbreak ;\n\tcase MA_BEACON :\n\t\tformac_online(smc) ;\n\t\tbreak ;\n\tcase MA_DIRECTED :\n\t\tdirected_beacon(smc) ;\n\t\tbreak ;\n\tcase MA_TREQ :\n\t\t \n\t\tbreak ;\n\t}\n}\n\nint sm_mac_get_tx_state(struct s_smc *smc)\n{\n\treturn (inpw(FM_A(FM_STMCHN))>>4) & 7;\n}\n\n \n\nstatic struct s_fpmc* mac_get_mc_table(struct s_smc *smc,\n\t\t\t\t       struct fddi_addr *user,\n\t\t\t\t       struct fddi_addr *own,\n\t\t\t\t       int del, int can)\n{\n\tstruct s_fpmc\t*tb ;\n\tstruct s_fpmc\t*slot ;\n\tu_char\t*p ;\n\tint i ;\n\n\t \n\t*own = *user ;\n\tif (can) {\n\t\tp = own->a ;\n\t\tfor (i = 0 ; i < 6 ; i++, p++)\n\t\t\t*p = bitrev8(*p);\n\t}\n\tslot = NULL;\n\tfor (i = 0, tb = smc->hw.fp.mc.table ; i < FPMAX_MULTICAST ; i++, tb++){\n\t\tif (!tb->n) {\t\t \n\t\t\tif (!del && !slot)\t \n\t\t\t\tslot = tb ;\n\t\t\tcontinue ;\n\t\t}\n\t\tif (!ether_addr_equal((char *)&tb->a, (char *)own))\n\t\t\tcontinue ;\n\t\treturn tb;\n\t}\n\treturn slot;\t\t\t \n}\n\n \nvoid mac_clear_multicast(struct s_smc *smc)\n{\n\tstruct s_fpmc\t*tb ;\n\tint i ;\n\n\tsmc->hw.fp.os_slots_used = 0 ;\t \n\t\t\t\t\t \n\tfor (i = 0, tb = smc->hw.fp.mc.table ; i < FPMAX_MULTICAST ; i++, tb++){\n\t\tif (!tb->perm) {\n\t\t\ttb->n = 0 ;\n\t\t}\n\t}\n}\n\n \nint mac_add_multicast(struct s_smc *smc, struct fddi_addr *addr, int can)\n{\n\tSK_LOC_DECL(struct fddi_addr,own) ;\n\tstruct s_fpmc\t*tb ;\n\n\t \n\tif (can & 0x80) {\n\t\tif (smc->hw.fp.smt_slots_used >= SMT_MAX_MULTI) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\telse {\n\t\tif (smc->hw.fp.os_slots_used >= FPMAX_MULTICAST-SMT_MAX_MULTI) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t \n\tif (!(tb = mac_get_mc_table(smc,addr,&own,0,can & ~0x80)))\n\t\treturn 1;\n\ttb->n++ ;\n\ttb->a = own ;\n\ttb->perm = (can & 0x80) ? 1 : 0 ;\n\n\tif (can & 0x80)\n\t\tsmc->hw.fp.smt_slots_used++ ;\n\telse\n\t\tsmc->hw.fp.os_slots_used++ ;\n\n\treturn 0;\n}\n\n \n\n#define RX_MODE_PROM\t\t0x1\n#define RX_MODE_ALL_MULTI\t0x2\n\n \nvoid mac_update_multicast(struct s_smc *smc)\n{\n\tstruct s_fpmc\t*tb ;\n\tu_char\t*fu ;\n\tint\ti ;\n\n\t \n\toutpw(FM_A(FM_AFCMD),FM_IINV_CAM) ;\n\n\t \n\tif (smc->hw.fp.func_addr) {\n\t\tfu = (u_char *) &smc->hw.fp.func_addr ;\n\t\toutpw(FM_A(FM_AFMASK2),0xffff) ;\n\t\toutpw(FM_A(FM_AFMASK1),(u_short) ~((fu[0] << 8) + fu[1])) ;\n\t\toutpw(FM_A(FM_AFMASK0),(u_short) ~((fu[2] << 8) + fu[3])) ;\n\t\toutpw(FM_A(FM_AFPERS),FM_VALID|FM_DA) ;\n\t\toutpw(FM_A(FM_AFCOMP2), 0xc000) ;\n\t\toutpw(FM_A(FM_AFCOMP1), 0x0000) ;\n\t\toutpw(FM_A(FM_AFCOMP0), 0x0000) ;\n\t\toutpw(FM_A(FM_AFCMD),FM_IWRITE_CAM) ;\n\t}\n\n\t \n\toutpw(FM_A(FM_AFMASK0),0xffff) ;\n\toutpw(FM_A(FM_AFMASK1),0xffff) ;\n\toutpw(FM_A(FM_AFMASK2),0xffff) ;\n\toutpw(FM_A(FM_AFPERS),FM_VALID|FM_DA) ;\n\n\tfor (i = 0, tb = smc->hw.fp.mc.table; i < FPMAX_MULTICAST; i++, tb++) {\n\t\tif (tb->n) {\n\t\t\tCHECK_CAM() ;\n\n\t\t\t \n\t\t\toutpw(FM_A(FM_AFCOMP2),\n\t\t\t\t(u_short)((tb->a.a[0]<<8)+tb->a.a[1])) ;\n\t\t\toutpw(FM_A(FM_AFCOMP1),\n\t\t\t\t(u_short)((tb->a.a[2]<<8)+tb->a.a[3])) ;\n\t\t\toutpw(FM_A(FM_AFCOMP0),\n\t\t\t\t(u_short)((tb->a.a[4]<<8)+tb->a.a[5])) ;\n\t\t\toutpw(FM_A(FM_AFCMD),FM_IWRITE_CAM) ;\n\t\t}\n\t}\n}\n\n \nvoid mac_set_rx_mode(struct s_smc *smc, int mode)\n{\n\tswitch (mode) {\n\tcase RX_ENABLE_ALLMULTI :\n\t\tsmc->hw.fp.rx_prom |= RX_MODE_ALL_MULTI ;\n\t\tbreak ;\n\tcase RX_DISABLE_ALLMULTI :\n\t\tsmc->hw.fp.rx_prom &= ~RX_MODE_ALL_MULTI ;\n\t\tbreak ;\n\tcase RX_ENABLE_PROMISC :\n\t\tsmc->hw.fp.rx_prom |= RX_MODE_PROM ;\n\t\tbreak ;\n\tcase RX_DISABLE_PROMISC :\n\t\tsmc->hw.fp.rx_prom &= ~RX_MODE_PROM ;\n\t\tbreak ;\n\tcase RX_ENABLE_NSA :\n\t\tsmc->hw.fp.nsa_mode = FM_MDAMA ;\n\t\tsmc->hw.fp.rx_mode = (smc->hw.fp.rx_mode & ~FM_ADDET) |\n\t\t\tsmc->hw.fp.nsa_mode ;\n\t\tbreak ;\n\tcase RX_DISABLE_NSA :\n\t\tsmc->hw.fp.nsa_mode = FM_MRNNSAFNMA ;\n\t\tsmc->hw.fp.rx_mode = (smc->hw.fp.rx_mode & ~FM_ADDET) |\n\t\t\tsmc->hw.fp.nsa_mode ;\n\t\tbreak ;\n\t}\n\tif (smc->hw.fp.rx_prom & RX_MODE_PROM) {\n\t\tsmc->hw.fp.rx_mode = FM_MLIMPROM ;\n\t}\n\telse if (smc->hw.fp.rx_prom & RX_MODE_ALL_MULTI) {\n\t\tsmc->hw.fp.rx_mode = smc->hw.fp.nsa_mode | FM_EXGPA0 ;\n\t}\n\telse\n\t\tsmc->hw.fp.rx_mode = smc->hw.fp.nsa_mode ;\n\tSETMASK(FM_A(FM_MDREG1),smc->hw.fp.rx_mode,FM_ADDRX) ;\n\tmac_update_multicast(smc) ;\n}\n\n \nvoid rtm_irq(struct s_smc *smc)\n{\n\toutpw(ADDR(B2_RTM_CRTL),TIM_CL_IRQ) ;\t\t \n\tif (inpw(ADDR(B2_RTM_CRTL)) & TIM_RES_TOK) {\n\t\toutpw(FM_A(FM_CMDREG1),FM_ICL) ;\t \n\t\tDB_RMT(\"RMT: fddiPATHT_Rmode expired\");\n\t\tAIX_EVENT(smc, (u_long) FDDI_RING_STATUS,\n\t\t\t\t(u_long) FDDI_SMT_EVENT,\n\t\t\t\t(u_long) FDDI_RTT, smt_get_event_word(smc));\n\t}\n\toutpw(ADDR(B2_RTM_CRTL),TIM_START) ;\t \n}\n\nstatic void rtm_init(struct s_smc *smc)\n{\n\toutpd(ADDR(B2_RTM_INI),0) ;\t\t \n\toutpw(ADDR(B2_RTM_CRTL),TIM_START) ;\t \n}\n\nvoid rtm_set_timer(struct s_smc *smc)\n{\n\t \n\tDB_RMT(\"RMT: setting new fddiPATHT_Rmode, t = %d ns\",\n\t       (int)smc->mib.a[PATH0].fddiPATHT_Rmode);\n\toutpd(ADDR(B2_RTM_INI),smc->mib.a[PATH0].fddiPATHT_Rmode) ;\n}\n\nstatic void smt_split_up_fifo(struct s_smc *smc)\n{\n\n \n\n\tif (SMT_R1_RXD_COUNT == 0) {\n\t\tSMT_PANIC(smc,SMT_E0117, SMT_E0117_MSG) ;\n\t}\n\n\tswitch(SMT_R2_RXD_COUNT) {\n\tcase 0:\n\t\tsmc->hw.fp.fifo.rx1_fifo_size = RX_FIFO_SPACE ;\n\t\tsmc->hw.fp.fifo.rx2_fifo_size = 0 ;\n\t\tbreak ;\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\t\tsmc->hw.fp.fifo.rx1_fifo_size = RX_LARGE_FIFO ;\n\t\tsmc->hw.fp.fifo.rx2_fifo_size = RX_SMALL_FIFO ;\n\t\tbreak ;\n\tdefault:\t \n\t\tsmc->hw.fp.fifo.rx1_fifo_size = RX_FIFO_SPACE *\n\t\tSMT_R1_RXD_COUNT/(SMT_R1_RXD_COUNT+SMT_R2_RXD_COUNT) ;\n\t\tsmc->hw.fp.fifo.rx2_fifo_size = RX_FIFO_SPACE *\n\t\tSMT_R2_RXD_COUNT/(SMT_R1_RXD_COUNT+SMT_R2_RXD_COUNT) ;\n\t\tbreak ;\n\t}\n\n \n\n\t \n\tif (smc->mib.a[PATH0].fddiPATHSbaPayload) {\n#ifdef ESS\n\t\tsmc->hw.fp.fifo.fifo_config_mode |=\n\t\t\tsmc->mib.fddiESSSynchTxMode | SYNC_TRAFFIC_ON ;\n#endif\n\t}\n\telse {\n\t\tsmc->hw.fp.fifo.fifo_config_mode &=\n\t\t\t~(SEND_ASYNC_AS_SYNC|SYNC_TRAFFIC_ON) ;\n\t}\n\n\t \n\tif (smc->hw.fp.fifo.fifo_config_mode & SYNC_TRAFFIC_ON) {\n\t\tif (smc->hw.fp.fifo.fifo_config_mode & SEND_ASYNC_AS_SYNC) {\n\t\t\tsmc->hw.fp.fifo.tx_s_size = TX_LARGE_FIFO ;\n\t\t\tsmc->hw.fp.fifo.tx_a0_size = TX_SMALL_FIFO ;\n\t\t}\n\t\telse {\n\t\t\tsmc->hw.fp.fifo.tx_s_size = TX_MEDIUM_FIFO ;\n\t\t\tsmc->hw.fp.fifo.tx_a0_size = TX_MEDIUM_FIFO ;\n\t\t}\n\t}\n\telse {\n\t\t\tsmc->hw.fp.fifo.tx_s_size = 0 ;\n\t\t\tsmc->hw.fp.fifo.tx_a0_size = TX_FIFO_SPACE ;\n\t}\n\n\tsmc->hw.fp.fifo.rx1_fifo_start = smc->hw.fp.fifo.rbc_ram_start +\n\t\tRX_FIFO_OFF ;\n\tsmc->hw.fp.fifo.tx_s_start = smc->hw.fp.fifo.rx1_fifo_start +\n\t\tsmc->hw.fp.fifo.rx1_fifo_size ;\n\tsmc->hw.fp.fifo.tx_a0_start = smc->hw.fp.fifo.tx_s_start +\n\t\tsmc->hw.fp.fifo.tx_s_size ;\n\tsmc->hw.fp.fifo.rx2_fifo_start = smc->hw.fp.fifo.tx_a0_start +\n\t\tsmc->hw.fp.fifo.tx_a0_size ;\n\n\tDB_SMT(\"FIFO split: mode = %x\", smc->hw.fp.fifo.fifo_config_mode);\n\tDB_SMT(\"rbc_ram_start =\t%x\t rbc_ram_end = \t%x\",\n\t       smc->hw.fp.fifo.rbc_ram_start, smc->hw.fp.fifo.rbc_ram_end);\n\tDB_SMT(\"rx1_fifo_start = %x\t tx_s_start = \t%x\",\n\t       smc->hw.fp.fifo.rx1_fifo_start, smc->hw.fp.fifo.tx_s_start);\n\tDB_SMT(\"tx_a0_start =\t%x\t rx2_fifo_start = \t%x\",\n\t       smc->hw.fp.fifo.tx_a0_start, smc->hw.fp.fifo.rx2_fifo_start);\n}\n\nvoid formac_reinit_tx(struct s_smc *smc)\n{\n\t \n\tif (!smc->hw.fp.fifo.tx_s_size && smc->mib.a[PATH0].fddiPATHSbaPayload){\n\t\t(void)init_mac(smc,0) ;\n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}