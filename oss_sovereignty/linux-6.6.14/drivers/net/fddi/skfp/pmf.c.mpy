{
  "module_name": "pmf.c",
  "hash_id": "6204c967f75e1db11941af2583bab10157e2082bd8401bde8d5866b6911983cf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/fddi/skfp/pmf.c",
  "human_readable_source": "\n \n\n \n\n#include \"h/types.h\"\n#include \"h/fddi.h\"\n#include \"h/smc.h\"\n#include \"h/smt_p.h\"\n\n#define KERNEL\n#include \"h/smtstate.h\"\n\n#ifndef\tSLIM_SMT\n\nstatic int smt_authorize(struct s_smc *smc, struct smt_header *sm);\nstatic int smt_check_set_count(struct s_smc *smc, struct smt_header *sm);\nstatic const struct s_p_tab* smt_get_ptab(u_short para);\nstatic int smt_mib_phys(struct s_smc *smc);\nstatic int smt_set_para(struct s_smc *smc, struct smt_para *pa, int index,\n\t\t\tint local, int set);\nvoid smt_add_para(struct s_smc *smc, struct s_pcon *pcon, u_short para,\n\t\t  int index, int local);\nstatic SMbuf *smt_build_pmf_response(struct s_smc *smc, struct smt_header *req,\n\t\t\t\t     int set, int local);\nstatic int port_to_mib(struct s_smc *smc, int p);\n\n#define MOFFSS(e)\toffsetof(struct fddi_mib, e)\n#define MOFFMS(e)\toffsetof(struct fddi_mib_m, e)\n#define MOFFAS(e)\toffsetof(struct fddi_mib_a, e)\n#define MOFFPS(e)\toffsetof(struct fddi_mib_p, e)\n\n\n#define AC_G\t0x01\t\t \n#define AC_GR\t0x02\t\t \n#define AC_S\t0x04\t\t \n#define AC_NA\t0x08\n#define AC_GROUP\t0x10\t\t \n#define MS2BCLK(x)\t((x)*12500L)\n \nstatic const struct s_p_tab {\n\tu_short\tp_num ;\t\t \n\tu_char\tp_access ;\t \n\tu_short\tp_offset ;\t \n\tchar\tp_swap[3] ;\t \n} p_tab[] = {\n\t \n\t{ SMT_P100A,AC_GROUP\t} ,\n\t{ SMT_P100B,AC_G,\tMOFFSS(fddiSMTStationId),\t\"8\"\t} ,\n\t{ SMT_P100D,AC_G,\tMOFFSS(fddiSMTOpVersionId),\t\"S\"\t} ,\n\t{ SMT_P100E,AC_G,\tMOFFSS(fddiSMTHiVersionId),\t\"S\"\t} ,\n\t{ SMT_P100F,AC_G,\tMOFFSS(fddiSMTLoVersionId),\t\"S\"\t} ,\n\t{ SMT_P1010,AC_G,\tMOFFSS(fddiSMTManufacturerData), \"D\" } ,\n\t{ SMT_P1011,AC_GR,\tMOFFSS(fddiSMTUserData),\t\"D\"\t} ,\n\t{ SMT_P1012,AC_G,\tMOFFSS(fddiSMTMIBVersionId),\t\"S\"\t} ,\n\n\t \n\t{ SMT_P1014,AC_GROUP\t} ,\n\t{ SMT_P1015,AC_G,\tMOFFSS(fddiSMTMac_Ct),\t\t\"B\"\t} ,\n\t{ SMT_P1016,AC_G,\tMOFFSS(fddiSMTNonMaster_Ct),\t\"B\"\t} ,\n\t{ SMT_P1017,AC_G,\tMOFFSS(fddiSMTMaster_Ct),\t\"B\"\t} ,\n\t{ SMT_P1018,AC_G,\tMOFFSS(fddiSMTAvailablePaths),\t\"B\"\t} ,\n\t{ SMT_P1019,AC_G,\tMOFFSS(fddiSMTConfigCapabilities),\"S\"\t} ,\n\t{ SMT_P101A,AC_GR,\tMOFFSS(fddiSMTConfigPolicy),\t\"wS\"\t} ,\n\t{ SMT_P101B,AC_GR,\tMOFFSS(fddiSMTConnectionPolicy),\"wS\"\t} ,\n\t{ SMT_P101D,AC_GR,\tMOFFSS(fddiSMTTT_Notify),\t\"wS\"\t} ,\n\t{ SMT_P101E,AC_GR,\tMOFFSS(fddiSMTStatRptPolicy),\t\"bB\"\t} ,\n\t{ SMT_P101F,AC_GR,\tMOFFSS(fddiSMTTrace_MaxExpiration),\"lL\"\t} ,\n\t{ SMT_P1020,AC_G,\tMOFFSS(fddiSMTPORTIndexes),\t\"II\"\t} ,\n\t{ SMT_P1021,AC_G,\tMOFFSS(fddiSMTMACIndexes),\t\"I\"\t} ,\n\t{ SMT_P1022,AC_G,\tMOFFSS(fddiSMTBypassPresent),\t\"F\"\t} ,\n\n\t \n\t{ SMT_P1028,AC_GROUP\t} ,\n\t{ SMT_P1029,AC_G,\tMOFFSS(fddiSMTECMState),\t\"E\"\t} ,\n\t{ SMT_P102A,AC_G,\tMOFFSS(fddiSMTCF_State),\t\"E\"\t} ,\n\t{ SMT_P102C,AC_G,\tMOFFSS(fddiSMTRemoteDisconnectFlag),\"F\"\t} ,\n\t{ SMT_P102D,AC_G,\tMOFFSS(fddiSMTStationStatus),\t\"E\"\t} ,\n\t{ SMT_P102E,AC_G,\tMOFFSS(fddiSMTPeerWrapFlag),\t\"F\"\t} ,\n\n\t \n\t{ SMT_P1032,AC_GROUP\t} ,\n\t{ SMT_P1033,AC_G,\tMOFFSS(fddiSMTTimeStamp),\"P\"\t\t} ,\n\t{ SMT_P1034,AC_G,\tMOFFSS(fddiSMTTransitionTimeStamp),\"P\"\t} ,\n\t \n\t{ SMT_P1035,AC_G,\tMOFFSS(fddiSMTSetCount),\"4P\"\t\t} ,\n\t{ SMT_P1036,AC_G,\tMOFFSS(fddiSMTLastSetStationId),\"8\"\t} ,\n\n\t{ SMT_P103C,AC_S,\t0,\t\t\t\t\"wS\"\t} ,\n\n\t \n\t{ SMT_P10F0,AC_GR,\tMOFFSS(fddiPRPMFPasswd),\t\"8\"\t} ,\n\t{ SMT_P10F1,AC_GR,\tMOFFSS(fddiPRPMFStation),\t\"8\"\t} ,\n#ifdef\tESS\n\t{ SMT_P10F2,AC_GR,\tMOFFSS(fddiESSPayload),\t\t\"lL\"\t} ,\n\t{ SMT_P10F3,AC_GR,\tMOFFSS(fddiESSOverhead),\t\"lL\"\t} ,\n\t{ SMT_P10F4,AC_GR,\tMOFFSS(fddiESSMaxTNeg),\t\t\"lL\"\t} ,\n\t{ SMT_P10F5,AC_GR,\tMOFFSS(fddiESSMinSegmentSize),\t\"lL\"\t} ,\n\t{ SMT_P10F6,AC_GR,\tMOFFSS(fddiESSCategory),\t\"lL\"\t} ,\n\t{ SMT_P10F7,AC_GR,\tMOFFSS(fddiESSSynchTxMode),\t\"wS\"\t} ,\n#endif\n#ifdef\tSBA\n\t{ SMT_P10F8,AC_GR,\tMOFFSS(fddiSBACommand),\t\t\"bF\"\t} ,\n\t{ SMT_P10F9,AC_GR,\tMOFFSS(fddiSBAAvailable),\t\"bF\"\t} ,\n#endif\n\t \n\t{ SMT_P200A,AC_GROUP\t} ,\n\t{ SMT_P200B,AC_G,\tMOFFMS(fddiMACFrameStatusFunctions),\"S\"\t} ,\n\t{ SMT_P200D,AC_G,\tMOFFMS(fddiMACT_MaxCapabilitiy),\"T\"\t} ,\n\t{ SMT_P200E,AC_G,\tMOFFMS(fddiMACTVXCapabilitiy),\"T\"\t} ,\n\n\t \n\t{ SMT_P2014,AC_GROUP\t} ,\n\t{ SMT_P2016,AC_G,\tMOFFMS(fddiMACAvailablePaths),\t\"B\"\t} ,\n\t{ SMT_P2017,AC_G,\tMOFFMS(fddiMACCurrentPath),\t\"S\"\t} ,\n\t{ SMT_P2018,AC_G,\tMOFFMS(fddiMACUpstreamNbr),\t\"A\"\t} ,\n\t{ SMT_P2019,AC_G,\tMOFFMS(fddiMACDownstreamNbr),\t\"A\"\t} ,\n\t{ SMT_P201A,AC_G,\tMOFFMS(fddiMACOldUpstreamNbr),\t\"A\"\t} ,\n\t{ SMT_P201B,AC_G,\tMOFFMS(fddiMACOldDownstreamNbr),\"A\"\t} ,\n\t{ SMT_P201D,AC_G,\tMOFFMS(fddiMACDupAddressTest),\t\"E\"\t} ,\n\t{ SMT_P2020,AC_GR,\tMOFFMS(fddiMACRequestedPaths),\t\"wS\"\t} ,\n\t{ SMT_P2021,AC_G,\tMOFFMS(fddiMACDownstreamPORTType),\"E\"\t} ,\n\t{ SMT_P2022,AC_G,\tMOFFMS(fddiMACIndex),\t\t\"S\"\t} ,\n\n\t \n\t{ SMT_P2028,AC_GROUP\t} ,\n\t{ SMT_P2029,AC_G,\tMOFFMS(fddiMACSMTAddress),\t\"A\"\t} ,\n\n\t \n\t{ SMT_P2032,AC_GROUP\t} ,\n\t{ SMT_P2033,AC_G,\tMOFFMS(fddiMACT_Req),\t\t\"T\"\t} ,\n\t{ SMT_P2034,AC_G,\tMOFFMS(fddiMACT_Neg),\t\t\"T\"\t} ,\n\t{ SMT_P2035,AC_G,\tMOFFMS(fddiMACT_Max),\t\t\"T\"\t} ,\n\t{ SMT_P2036,AC_G,\tMOFFMS(fddiMACTvxValue),\t\"T\"\t} ,\n\t{ SMT_P2038,AC_G,\tMOFFMS(fddiMACT_Pri0),\t\t\"T\"\t} ,\n\t{ SMT_P2039,AC_G,\tMOFFMS(fddiMACT_Pri1),\t\t\"T\"\t} ,\n\t{ SMT_P203A,AC_G,\tMOFFMS(fddiMACT_Pri2),\t\t\"T\"\t} ,\n\t{ SMT_P203B,AC_G,\tMOFFMS(fddiMACT_Pri3),\t\t\"T\"\t} ,\n\t{ SMT_P203C,AC_G,\tMOFFMS(fddiMACT_Pri4),\t\t\"T\"\t} ,\n\t{ SMT_P203D,AC_G,\tMOFFMS(fddiMACT_Pri5),\t\t\"T\"\t} ,\n\t{ SMT_P203E,AC_G,\tMOFFMS(fddiMACT_Pri6),\t\t\"T\"\t} ,\n\n\n\t \n\t{ SMT_P2046,AC_GROUP\t} ,\n\t{ SMT_P2047,AC_G,\tMOFFMS(fddiMACFrame_Ct),\t\"C\"\t} ,\n\t{ SMT_P2048,AC_G,\tMOFFMS(fddiMACCopied_Ct),\t\"C\"\t} ,\n\t{ SMT_P2049,AC_G,\tMOFFMS(fddiMACTransmit_Ct),\t\"C\"\t} ,\n\t{ SMT_P204A,AC_G,\tMOFFMS(fddiMACToken_Ct),\t\"C\"\t} ,\n\t{ SMT_P2051,AC_G,\tMOFFMS(fddiMACError_Ct),\t\"C\"\t} ,\n\t{ SMT_P2052,AC_G,\tMOFFMS(fddiMACLost_Ct),\t\t\"C\"\t} ,\n\t{ SMT_P2053,AC_G,\tMOFFMS(fddiMACTvxExpired_Ct),\t\"C\"\t} ,\n\t{ SMT_P2054,AC_G,\tMOFFMS(fddiMACNotCopied_Ct),\t\"C\"\t} ,\n\t{ SMT_P2056,AC_G,\tMOFFMS(fddiMACRingOp_Ct),\t\"C\"\t} ,\n\n\t \n\t{ SMT_P205A,AC_GROUP\t} ,\n\t{ SMT_P205F,AC_GR,\tMOFFMS(fddiMACFrameErrorThreshold),\"wS\"\t} ,\n\t{ SMT_P2060,AC_G,\tMOFFMS(fddiMACFrameErrorRatio),\t\"S\"\t} ,\n\n\t \n\t{ SMT_P2064,AC_GROUP\t} ,\n\t{ SMT_P2067,AC_GR,\tMOFFMS(fddiMACNotCopiedThreshold),\"wS\"\t} ,\n\t{ SMT_P2069,AC_G,\tMOFFMS(fddiMACNotCopiedRatio),\t\"S\"\t} ,\n\n\t \n\t{ SMT_P206E,AC_GROUP\t} ,\n\t{ SMT_P206F,AC_G,\tMOFFMS(fddiMACRMTState),\t\"S\"\t} ,\n\t{ SMT_P2070,AC_G,\tMOFFMS(fddiMACDA_Flag),\t\"F\"\t} ,\n\t{ SMT_P2071,AC_G,\tMOFFMS(fddiMACUNDA_Flag),\t\"F\"\t} ,\n\t{ SMT_P2072,AC_G,\tMOFFMS(fddiMACFrameErrorFlag),\t\"F\"\t} ,\n\t{ SMT_P2073,AC_G,\tMOFFMS(fddiMACNotCopiedFlag),\t\"F\"\t} ,\n\t{ SMT_P2074,AC_G,\tMOFFMS(fddiMACMA_UnitdataAvailable),\"F\"\t} ,\n\t{ SMT_P2075,AC_G,\tMOFFMS(fddiMACHardwarePresent),\t\"F\"\t} ,\n\t{ SMT_P2076,AC_GR,\tMOFFMS(fddiMACMA_UnitdataEnable),\"bF\"\t} ,\n\n\t \n\t{ SMT_P20F0,AC_NA\t\t\t\t\t\t} ,\n\t{ SMT_P20F1,AC_GR,\tMOFFMS(fddiMACT_Min),\t\t\"lT\"\t} ,\n\n\t \n\t \n\t{ SMT_P320A,AC_GROUP\t} ,\n\t{ SMT_P320B,AC_G,\tMOFFAS(fddiPATHIndex),\t\t\"r\"\t} ,\n\t{ SMT_P320F,AC_GR,\tMOFFAS(fddiPATHSbaPayload),\t\"l4\"\t} ,\n\t{ SMT_P3210,AC_GR,\tMOFFAS(fddiPATHSbaOverhead),\t\"l4\"\t} ,\n\t \n\t{ SMT_P3212,AC_G,\t0,\t\t\t\t\"\"\t} ,\n\t{ SMT_P3213,AC_GR,\tMOFFAS(fddiPATHT_Rmode),\t\"lT\"\t} ,\n\t{ SMT_P3214,AC_GR,\tMOFFAS(fddiPATHSbaAvailable),\t\"lL\"\t} ,\n\t{ SMT_P3215,AC_GR,\tMOFFAS(fddiPATHTVXLowerBound),\t\"lT\"\t} ,\n\t{ SMT_P3216,AC_GR,\tMOFFAS(fddiPATHT_MaxLowerBound),\"lT\"\t} ,\n\t{ SMT_P3217,AC_GR,\tMOFFAS(fddiPATHMaxT_Req),\t\"lT\"\t} ,\n\n\t \n\t \n\t{ SMT_P400A,AC_GROUP\t} ,\n\t{ SMT_P400C,AC_G,\tMOFFPS(fddiPORTMy_Type),\t\"E\"\t} ,\n\t{ SMT_P400D,AC_G,\tMOFFPS(fddiPORTNeighborType),\t\"E\"\t} ,\n\t{ SMT_P400E,AC_GR,\tMOFFPS(fddiPORTConnectionPolicies),\"bB\"\t} ,\n\t{ SMT_P400F,AC_G,\tMOFFPS(fddiPORTMacIndicated),\t\"2\"\t} ,\n\t{ SMT_P4010,AC_G,\tMOFFPS(fddiPORTCurrentPath),\t\"E\"\t} ,\n\t{ SMT_P4011,AC_GR,\tMOFFPS(fddiPORTRequestedPaths),\t\"l4\"\t} ,\n\t{ SMT_P4012,AC_G,\tMOFFPS(fddiPORTMACPlacement),\t\"S\"\t} ,\n\t{ SMT_P4013,AC_G,\tMOFFPS(fddiPORTAvailablePaths),\t\"B\"\t} ,\n\t{ SMT_P4016,AC_G,\tMOFFPS(fddiPORTPMDClass),\t\"E\"\t} ,\n\t{ SMT_P4017,AC_G,\tMOFFPS(fddiPORTConnectionCapabilities),\t\"B\"} ,\n\t{ SMT_P401D,AC_G,\tMOFFPS(fddiPORTIndex),\t\t\"R\"\t} ,\n\n\t \n\t{ SMT_P401E,AC_GROUP\t} ,\n\t{ SMT_P401F,AC_GR,\tMOFFPS(fddiPORTMaint_LS),\t\"wE\"\t} ,\n\t{ SMT_P4021,AC_G,\tMOFFPS(fddiPORTBS_Flag),\t\"F\"\t} ,\n\t{ SMT_P4022,AC_G,\tMOFFPS(fddiPORTPC_LS),\t\t\"E\"\t} ,\n\n\t \n\t{ SMT_P4028,AC_GROUP\t} ,\n\t{ SMT_P4029,AC_G,\tMOFFPS(fddiPORTEBError_Ct),\t\"C\"\t} ,\n\t{ SMT_P402A,AC_G,\tMOFFPS(fddiPORTLCTFail_Ct),\t\"C\"\t} ,\n\n\t \n\t{ SMT_P4032,AC_GROUP\t} ,\n\t{ SMT_P4033,AC_G,\tMOFFPS(fddiPORTLer_Estimate),\t\"F\"\t} ,\n\t{ SMT_P4034,AC_G,\tMOFFPS(fddiPORTLem_Reject_Ct),\t\"C\"\t} ,\n\t{ SMT_P4035,AC_G,\tMOFFPS(fddiPORTLem_Ct),\t\t\"C\"\t} ,\n\t{ SMT_P403A,AC_GR,\tMOFFPS(fddiPORTLer_Cutoff),\t\"bB\"\t} ,\n\t{ SMT_P403B,AC_GR,\tMOFFPS(fddiPORTLer_Alarm),\t\"bB\"\t} ,\n\n\t \n\t{ SMT_P403C,AC_GROUP\t} ,\n\t{ SMT_P403D,AC_G,\tMOFFPS(fddiPORTConnectState),\t\"E\"\t} ,\n\t{ SMT_P403E,AC_G,\tMOFFPS(fddiPORTPCMStateX),\t\"E\"\t} ,\n\t{ SMT_P403F,AC_G,\tMOFFPS(fddiPORTPC_Withhold),\t\"E\"\t} ,\n\t{ SMT_P4040,AC_G,\tMOFFPS(fddiPORTLerFlag),\t\"F\"\t} ,\n\t{ SMT_P4041,AC_G,\tMOFFPS(fddiPORTHardwarePresent),\"F\"\t} ,\n\n\t{ SMT_P4046,AC_S,\t0,\t\t\t\t\"wS\"\t} ,\n\n\t{ 0,\tAC_GROUP\t} ,\n\t{ 0 }\n} ;\n\nvoid smt_pmf_received_pack(struct s_smc *smc, SMbuf *mb, int local)\n{\n\tstruct smt_header\t*sm ;\n\tSMbuf\t\t*reply ;\n\n\tsm = smtod(mb,struct smt_header *) ;\n\tDB_SMT(\"SMT: processing PMF frame at %p len %d\", sm, mb->sm_len);\n#ifdef\tDEBUG\n\tdump_smt(smc,sm,\"PMF Received\") ;\n#endif\n\t \n\tsmt_start_watchdog(smc) ;\n\n\tif (sm->smt_class == SMT_PMF_GET ||\n\t    sm->smt_class == SMT_PMF_SET) {\n\t\treply = smt_build_pmf_response(smc,sm,\n\t\t\tsm->smt_class == SMT_PMF_SET,local) ;\n\t\tif (reply) {\n\t\t\tsm = smtod(reply,struct smt_header *) ;\n#ifdef\tDEBUG\n\t\t\tdump_smt(smc,sm,\"PMF Reply\") ;\n#endif\n\t\t\tsmt_send_frame(smc,reply,FC_SMT_INFO,local) ;\n\t\t}\n\t}\n}\n\nstatic SMbuf *smt_build_pmf_response(struct s_smc *smc, struct smt_header *req,\n\t\t\t\t     int set, int local)\n{\n\tSMbuf\t\t\t*mb ;\n\tstruct smt_header\t*smt ;\n\tstruct smt_para\t\t*pa ;\n\tstruct smt_p_reason\t*res ;\n\tconst struct s_p_tab\t*pt ;\n\tint\t\t\tlen ;\n\tint\t\t\tindex ;\n\tint\t\t\tidx_end ;\n\tint\t\t\terror ;\n\tint\t\t\trange ;\n\tSK_LOC_DECL(struct s_pcon,pcon) ;\n\tSK_LOC_DECL(struct s_pcon,set_pcon) ;\n\n\t \n\tif (!(mb = smt_get_mbuf(smc)))\n\t\treturn mb;\n\n\tsmt = smtod(mb, struct smt_header *) ;\n\tsmt->smt_dest = req->smt_source ;\t \n\tsmt->smt_class = req->smt_class ;\t \n\tsmt->smt_type = SMT_REPLY ;\n\tsmt->smt_version = SMT_VID_2 ;\n\tsmt->smt_tid = req->smt_tid ;\t\t \n\tsmt->smt_pad = 0 ;\n\tsmt->smt_len = 0 ;\n\n\t \n\tpcon.pc_len = SMT_MAX_INFO_LEN ;\t \n\tpcon.pc_err = 0 ;\t\t\t \n\tpcon.pc_badset = 0 ;\t\t\t \n\tpcon.pc_p = (void *) (smt + 1) ;\t \n\n\t \n\terror = 0 ;\n\tif (set) {\n\t\tif (!local && smt_authorize(smc,req))\n\t\t\terror = SMT_RDF_AUTHOR ;\n\t\telse if (smt_check_set_count(smc,req))\n\t\t\tpcon.pc_badset = SMT_RDF_BADSET ;\n\t}\n\t \n\tres = (struct smt_p_reason *) pcon.pc_p ;\n\tsmt_add_para(smc,&pcon,(u_short) SMT_P_REASON,0,0) ;\n\tsmt_add_para(smc,&pcon,(u_short) SMT_P1033,0,0) ;\n\t \n\tset_pcon = pcon ;\n\tsmt_add_para(smc,&pcon,(u_short) SMT_P1035,0,0) ;\n\tsmt_add_para(smc,&pcon,(u_short) SMT_P1036,0,0) ;\n\n\tpcon.pc_err = error ;\n\tlen = req->smt_len ;\n\tpa = (struct smt_para *) (req + 1) ;\n\t \n\twhile (!pcon.pc_err && len > 0 ) {\n\t\tif (((u_short)len < pa->p_len + PARA_LEN) || (pa->p_len & 3)) {\n\t\t\tpcon.pc_err = SMT_RDF_LENGTH ;\n\t\t\tbreak ;\n\t\t}\n\n\t\tif (((range = (pa->p_type & 0xf000)) == 0x2000) ||\n\t\t\trange == 0x3000 || range == 0x4000) {\n\t\t\t \n\t\t\tindex = *((u_char *)pa + PARA_LEN + 3) ; \n\t\t\tidx_end = index ;\n\t\t\tif (!set && (pa->p_len != 4)) {\n\t\t\t\tpcon.pc_err = SMT_RDF_LENGTH ;\n\t\t\t\tbreak ;\n\t\t\t}\n\t\t\tif (!index && !set) {\n\t\t\t\tswitch (range) {\n\t\t\t\tcase 0x2000 :\n\t\t\t\t\tindex = INDEX_MAC ;\n\t\t\t\t\tidx_end = index - 1 + NUMMACS ;\n\t\t\t\t\tbreak ;\n\t\t\t\tcase 0x3000 :\n\t\t\t\t\tindex = INDEX_PATH ;\n\t\t\t\t\tidx_end = index - 1 + NUMPATHS ;\n\t\t\t\t\tbreak ;\n\t\t\t\tcase 0x4000 :\n\t\t\t\t\tindex = INDEX_PORT ;\n\t\t\t\t\tidx_end = index - 1 + NUMPHYS ;\n#ifndef\tCONCENTRATOR\n\t\t\t\t\tif (smc->s.sas == SMT_SAS)\n\t\t\t\t\t\tidx_end = INDEX_PORT ;\n#endif\n\t\t\t\t\tbreak ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t \n\t\t\tif (!set && (pa->p_len != 0)) {\n\t\t\t\tpcon.pc_err = SMT_RDF_LENGTH ;\n\t\t\t\tbreak ;\n\t\t\t}\n\t\t\tindex = 0 ;\n\t\t\tidx_end = 0 ;\n\t\t}\n\t\twhile (index <= idx_end) {\n\t\t\t \n\t\t\tpt = smt_get_ptab(pa->p_type) ;\n\t\t\tif (pt && pt->p_access == AC_GROUP && !set) {\n\t\t\t\tpt++ ;\n\t\t\t\twhile (pt->p_access == AC_G ||\n\t\t\t\t\tpt->p_access == AC_GR) {\n\t\t\t\t\tsmt_add_para(smc,&pcon,pt->p_num,\n\t\t\t\t\t\tindex,local);\n\t\t\t\t\tpt++ ;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\telse if (pa->p_type != SMT_P_AUTHOR &&\n\t\t\t\t (!set || (pa->p_type != SMT_P1035))) {\n\t\t\t\tint\tst ;\n\t\t\t\tif (pcon.pc_badset) {\n\t\t\t\t\tsmt_add_para(smc,&pcon,pa->p_type,\n\t\t\t\t\t\tindex,local) ;\n\t\t\t\t}\n\t\t\t\telse if (set) {\n\t\t\t\t\tst = smt_set_para(smc,pa,index,local,1);\n\t\t\t\t\t \n\t\t\t\t\tsmt_add_para(smc,&pcon,pa->p_type,\n\t\t\t\t\t\tindex,local) ;\n\t\t\t\t\tpcon.pc_err = st ;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (pt && pt->p_access == AC_S) {\n\t\t\t\t\t\tpcon.pc_err =\n\t\t\t\t\t\t\tSMT_RDF_ILLEGAL ;\n\t\t\t\t\t}\n\t\t\t\t\tsmt_add_para(smc,&pcon,pa->p_type,\n\t\t\t\t\t\tindex,local) ;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pcon.pc_err)\n\t\t\t\tbreak ;\n\t\t\tindex++ ;\n\t\t}\n\t\tlen -= pa->p_len + PARA_LEN ;\n\t\tpa = (struct smt_para *) ((char *)pa + pa->p_len + PARA_LEN) ;\n\t}\n\tsmt->smt_len = SMT_MAX_INFO_LEN - pcon.pc_len ;\n\tmb->sm_len = smt->smt_len + sizeof(struct smt_header) ;\n\n\t \n\tres->rdf_reason = pcon.pc_badset ? pcon.pc_badset :\n\t\t\tpcon.pc_err ? pcon.pc_err : SMT_RDF_SUCCESS ;\n\tif (set && (res->rdf_reason == SMT_RDF_SUCCESS)) {\n\t\t \n\t\tsmc->mib.fddiSMTSetCount.count++ ;\n\t\tsmt_set_timestamp(smc,smc->mib.fddiSMTSetCount.timestamp) ;\n\t\tsmc->mib.fddiSMTLastSetStationId = req->smt_sid ;\n\t\tsmt_add_para(smc,&set_pcon,(u_short) SMT_P1035,0,0) ;\n\t\tsmt_add_para(smc,&set_pcon,(u_short) SMT_P1036,0,0) ;\n\t}\n\treturn mb;\n}\n\nstatic int smt_authorize(struct s_smc *smc, struct smt_header *sm)\n{\n\tstruct smt_para\t*pa ;\n\tint\t\ti ;\n\tchar\t\t*p ;\n\n\t \n\tp = (char *) &smc->mib.fddiPRPMFStation ;\n\tfor (i = 0 ; i < 8 && !p[i] ; i++)\n\t\t;\n\tif (i != 8) {\n\t\tif (memcmp((char *) &sm->smt_sid,\n\t\t\t(char *) &smc->mib.fddiPRPMFStation,8))\n\t\t\treturn 1;\n\t}\n\t \n\tp = (char *) smc->mib.fddiPRPMFPasswd ;\n\tfor (i = 0 ; i < 8 && !p[i] ; i++)\n\t\t;\n\tif (i != 8) {\n\t\tpa = (struct smt_para *) sm_to_para(smc,sm,SMT_P_AUTHOR) ;\n\t\tif (!pa)\n\t\t\treturn 1;\n\t\tif (pa->p_len != 8)\n\t\t\treturn 1;\n\t\tif (memcmp((char *)(pa+1),(char *)smc->mib.fddiPRPMFPasswd,8))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int smt_check_set_count(struct s_smc *smc, struct smt_header *sm)\n{\n\tstruct smt_para\t*pa ;\n\tstruct smt_p_setcount\t*sc ;\n\n\tpa = (struct smt_para *) sm_to_para(smc,sm,SMT_P1035) ;\n\tif (pa) {\n\t\tsc = (struct smt_p_setcount *) pa ;\n\t\tif ((smc->mib.fddiSMTSetCount.count != sc->count) ||\n\t\t\tmemcmp((char *) smc->mib.fddiSMTSetCount.timestamp,\n\t\t\t(char *)sc->timestamp,8))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nvoid smt_add_para(struct s_smc *smc, struct s_pcon *pcon, u_short para,\n\t\t  int index, int local)\n{\n\tstruct smt_para\t*pa ;\n\tconst struct s_p_tab\t*pt ;\n\tstruct fddi_mib_m *mib_m = NULL;\n\tstruct fddi_mib_p *mib_p = NULL;\n\tint\t\tlen ;\n\tint\t\tplen ;\n\tchar\t\t*from ;\n\tchar\t\t*to ;\n\tconst char\t*swap ;\n\tchar\t\tc ;\n\tint\t\trange ;\n\tchar\t\t*mib_addr ;\n\tint\t\tmac ;\n\tint\t\tpath ;\n\tint\t\tport ;\n\tint\t\tsp_len ;\n\n\t \n\tif (pcon->pc_err)\n\t\treturn ;\n\n\t \n\tpt = smt_get_ptab(para) ;\n\tif (pt && pt->p_access == AC_S)\n\t\treturn ;\n\n\tto = (char *) (pcon->pc_p) ;\t \n\tlen = pcon->pc_len ;\t\t \n\tplen = len ;\t\t\t \n\tpa = (struct smt_para *) to ;\t \n\tto += PARA_LEN ;\t\t \n\tlen -= PARA_LEN ;\n\t \n\tif (((range = (para & 0xf000)) == 0x2000) ||\n\t\trange == 0x3000 || range == 0x4000) {\n\t\tif (len < 4)\n\t\t\tgoto wrong_error ;\n\t\tto[0] = 0 ;\n\t\tto[1] = 0 ;\n\t\tto[2] = 0 ;\n\t\tto[3] = index ;\n\t\tlen -= 4 ;\n\t\tto += 4 ;\n\t}\n\tmac = index - INDEX_MAC ;\n\tpath = index - INDEX_PATH ;\n\tport = index - INDEX_PORT ;\n\t \n\tswitch (range) {\n\tcase 0x1000 :\n\tdefault :\n\t\tmib_addr = (char *) (&smc->mib) ;\n\t\tbreak ;\n\tcase 0x2000 :\n\t\tif (mac < 0 || mac >= NUMMACS) {\n\t\t\tpcon->pc_err = SMT_RDF_NOPARAM ;\n\t\t\treturn ;\n\t\t}\n\t\tmib_addr = (char *) (&smc->mib.m[mac]) ;\n\t\tmib_m = (struct fddi_mib_m *) mib_addr ;\n\t\tbreak ;\n\tcase 0x3000 :\n\t\tif (path < 0 || path >= NUMPATHS) {\n\t\t\tpcon->pc_err = SMT_RDF_NOPARAM ;\n\t\t\treturn ;\n\t\t}\n\t\tmib_addr = (char *) (&smc->mib.a[path]) ;\n\t\tbreak ;\n\tcase 0x4000 :\n\t\tif (port < 0 || port >= smt_mib_phys(smc)) {\n\t\t\tpcon->pc_err = SMT_RDF_NOPARAM ;\n\t\t\treturn ;\n\t\t}\n\t\tmib_addr = (char *) (&smc->mib.p[port_to_mib(smc,port)]) ;\n\t\tmib_p = (struct fddi_mib_p *) mib_addr ;\n\t\tbreak ;\n\t}\n\t \n\tswap = NULL;\n\tswitch (para) {\n\tcase SMT_P10F0 :\n\tcase SMT_P10F1 :\n#ifdef\tESS\n\tcase SMT_P10F2 :\n\tcase SMT_P10F3 :\n\tcase SMT_P10F4 :\n\tcase SMT_P10F5 :\n\tcase SMT_P10F6 :\n\tcase SMT_P10F7 :\n#endif\n#ifdef\tSBA\n\tcase SMT_P10F8 :\n\tcase SMT_P10F9 :\n#endif\n\tcase SMT_P20F1 :\n\t\tif (!local) {\n\t\t\tpcon->pc_err = SMT_RDF_NOPARAM ;\n\t\t\treturn ;\n\t\t}\n\t\tbreak ;\n\tcase SMT_P2034 :\n\tcase SMT_P2046 :\n\tcase SMT_P2047 :\n\tcase SMT_P204A :\n\tcase SMT_P2051 :\n\tcase SMT_P2052 :\n\t\tmac_update_counter(smc) ;\n\t\tbreak ;\n\tcase SMT_P4022:\n\t\tmib_p->fddiPORTPC_LS = LS2MIB(\n\t\t\tsm_pm_get_ls(smc,port_to_mib(smc,port))) ;\n\t\tbreak ;\n\tcase SMT_P_REASON :\n\t\t*(u32 *)to = 0 ;\n\t\tsp_len = 4 ;\n\t\tgoto sp_done ;\n\tcase SMT_P1033 :\t\t\t \n\t\tsmt_set_timestamp(smc,smc->mib.fddiSMTTimeStamp) ;\n\t\tbreak ;\n\n\tcase SMT_P1020:\t\t\t\t \n#if\tNUMPHYS == 12\n\t\tswap = \"IIIIIIIIIIII\" ;\n#else\n#if\tNUMPHYS == 2\n\t\tif (smc->s.sas == SMT_SAS)\n\t\t\tswap = \"I\" ;\n\t\telse\n\t\t\tswap = \"II\" ;\n#else\n#if\tNUMPHYS == 24\n\t\tswap = \"IIIIIIIIIIIIIIIIIIIIIIII\" ;\n#else\n\t????\n#endif\n#endif\n#endif\n\t\tbreak ;\n\tcase SMT_P3212 :\n\t\t{\n\t\t\tsp_len = cem_build_path(smc,to,path) ;\n\t\t\tgoto sp_done ;\n\t\t}\n\tcase SMT_P1048 :\t\t \n\t\t{\n\t\t\tstruct smt_p_1048\t*sp ;\n\t\t\tsp = (struct smt_p_1048 *) to ;\n\t\t\tsp->p1048_flag = smc->mib.fddiSMTPeerWrapFlag ;\n\t\t\tsp->p1048_cf_state = smc->mib.fddiSMTCF_State ;\n\t\t\tsp_len = sizeof(struct smt_p_1048) ;\n\t\t\tgoto sp_done ;\n\t\t}\n\tcase SMT_P208C :\n\t\t{\n\t\t\tstruct smt_p_208c\t*sp ;\n\t\t\tsp = (struct smt_p_208c *) to ;\n\t\t\tsp->p208c_flag =\n\t\t\t\tsmc->mib.m[MAC0].fddiMACDuplicateAddressCond ;\n\t\t\tsp->p208c_dupcondition =\n\t\t\t\t(mib_m->fddiMACDA_Flag ? SMT_ST_MY_DUPA : 0) |\n\t\t\t\t(mib_m->fddiMACUNDA_Flag ? SMT_ST_UNA_DUPA : 0);\n\t\t\tsp->p208c_fddilong =\n\t\t\t\tmib_m->fddiMACSMTAddress ;\n\t\t\tsp->p208c_fddiunalong =\n\t\t\t\tmib_m->fddiMACUpstreamNbr ;\n\t\t\tsp->p208c_pad = 0 ;\n\t\t\tsp_len = sizeof(struct smt_p_208c) ;\n\t\t\tgoto sp_done ;\n\t\t}\n\tcase SMT_P208D :\t\t \n\t\t{\n\t\t\tstruct smt_p_208d\t*sp ;\n\t\t\tsp = (struct smt_p_208d *) to ;\n\t\t\tsp->p208d_flag =\n\t\t\t\tmib_m->fddiMACFrameErrorFlag ;\n\t\t\tsp->p208d_frame_ct =\n\t\t\t\tmib_m->fddiMACFrame_Ct ;\n\t\t\tsp->p208d_error_ct =\n\t\t\t\tmib_m->fddiMACError_Ct ;\n\t\t\tsp->p208d_lost_ct =\n\t\t\t\tmib_m->fddiMACLost_Ct ;\n\t\t\tsp->p208d_ratio =\n\t\t\t\tmib_m->fddiMACFrameErrorRatio ;\n\t\t\tsp_len = sizeof(struct smt_p_208d) ;\n\t\t\tgoto sp_done ;\n\t\t}\n\tcase SMT_P208E :\t\t \n\t\t{\n\t\t\tstruct smt_p_208e\t*sp ;\n\t\t\tsp = (struct smt_p_208e *) to ;\n\t\t\tsp->p208e_flag =\n\t\t\t\tmib_m->fddiMACNotCopiedFlag ;\n\t\t\tsp->p208e_not_copied =\n\t\t\t\tmib_m->fddiMACNotCopied_Ct ;\n\t\t\tsp->p208e_copied =\n\t\t\t\tmib_m->fddiMACCopied_Ct ;\n\t\t\tsp->p208e_not_copied_ratio =\n\t\t\t\tmib_m->fddiMACNotCopiedRatio ;\n\t\t\tsp_len = sizeof(struct smt_p_208e) ;\n\t\t\tgoto sp_done ;\n\t\t}\n\tcase SMT_P208F :\t \n\t\t{\n\t\t\tstruct smt_p_208f\t*sp ;\n\t\t\tsp = (struct smt_p_208f *) to ;\n\t\t\tsp->p208f_multiple =\n\t\t\t\tmib_m->fddiMACMultiple_N ;\n\t\t\tsp->p208f_nacondition =\n\t\t\t\tmib_m->fddiMACDuplicateAddressCond ;\n\t\t\tsp->p208f_old_una =\n\t\t\t\tmib_m->fddiMACOldUpstreamNbr ;\n\t\t\tsp->p208f_new_una =\n\t\t\t\tmib_m->fddiMACUpstreamNbr ;\n\t\t\tsp->p208f_old_dna =\n\t\t\t\tmib_m->fddiMACOldDownstreamNbr ;\n\t\t\tsp->p208f_new_dna =\n\t\t\t\tmib_m->fddiMACDownstreamNbr ;\n\t\t\tsp->p208f_curren_path =\n\t\t\t\tmib_m->fddiMACCurrentPath ;\n\t\t\tsp->p208f_smt_address =\n\t\t\t\tmib_m->fddiMACSMTAddress ;\n\t\t\tsp_len = sizeof(struct smt_p_208f) ;\n\t\t\tgoto sp_done ;\n\t\t}\n\tcase SMT_P2090 :\n\t\t{\n\t\t\tstruct smt_p_2090\t*sp ;\n\t\t\tsp = (struct smt_p_2090 *) to ;\n\t\t\tsp->p2090_multiple =\n\t\t\t\tmib_m->fddiMACMultiple_P ;\n\t\t\tsp->p2090_availablepaths =\n\t\t\t\tmib_m->fddiMACAvailablePaths ;\n\t\t\tsp->p2090_currentpath =\n\t\t\t\tmib_m->fddiMACCurrentPath ;\n\t\t\tsp->p2090_requestedpaths =\n\t\t\t\tmib_m->fddiMACRequestedPaths ;\n\t\t\tsp_len = sizeof(struct smt_p_2090) ;\n\t\t\tgoto sp_done ;\n\t\t}\n\tcase SMT_P4050 :\n\t\t{\n\t\t\tstruct smt_p_4050\t*sp ;\n\t\t\tsp = (struct smt_p_4050 *) to ;\n\t\t\tsp->p4050_flag =\n\t\t\t\tmib_p->fddiPORTLerFlag ;\n\t\t\tsp->p4050_pad = 0 ;\n\t\t\tsp->p4050_cutoff =\n\t\t\t\tmib_p->fddiPORTLer_Cutoff ;\n\t\t\tsp->p4050_alarm =\n\t\t\t\tmib_p->fddiPORTLer_Alarm ;\n\t\t\tsp->p4050_estimate =\n\t\t\t\tmib_p->fddiPORTLer_Estimate ;\n\t\t\tsp->p4050_reject_ct =\n\t\t\t\tmib_p->fddiPORTLem_Reject_Ct ;\n\t\t\tsp->p4050_ct =\n\t\t\t\tmib_p->fddiPORTLem_Ct ;\n\t\t\tsp_len = sizeof(struct smt_p_4050) ;\n\t\t\tgoto sp_done ;\n\t\t}\n\n\tcase SMT_P4051 :\n\t\t{\n\t\t\tstruct smt_p_4051\t*sp ;\n\t\t\tsp = (struct smt_p_4051 *) to ;\n\t\t\tsp->p4051_multiple =\n\t\t\t\tmib_p->fddiPORTMultiple_U ;\n\t\t\tsp->p4051_porttype =\n\t\t\t\tmib_p->fddiPORTMy_Type ;\n\t\t\tsp->p4051_connectstate =\n\t\t\t\tmib_p->fddiPORTConnectState ;\n\t\t\tsp->p4051_pc_neighbor =\n\t\t\t\tmib_p->fddiPORTNeighborType ;\n\t\t\tsp->p4051_pc_withhold =\n\t\t\t\tmib_p->fddiPORTPC_Withhold ;\n\t\t\tsp_len = sizeof(struct smt_p_4051) ;\n\t\t\tgoto sp_done ;\n\t\t}\n\tcase SMT_P4052 :\n\t\t{\n\t\t\tstruct smt_p_4052\t*sp ;\n\t\t\tsp = (struct smt_p_4052 *) to ;\n\t\t\tsp->p4052_flag =\n\t\t\t\tmib_p->fddiPORTEB_Condition ;\n\t\t\tsp->p4052_eberrorcount =\n\t\t\t\tmib_p->fddiPORTEBError_Ct ;\n\t\t\tsp_len = sizeof(struct smt_p_4052) ;\n\t\t\tgoto sp_done ;\n\t\t}\n\tcase SMT_P4053 :\n\t\t{\n\t\t\tstruct smt_p_4053\t*sp ;\n\t\t\tsp = (struct smt_p_4053 *) to ;\n\t\t\tsp->p4053_multiple =\n\t\t\t\tmib_p->fddiPORTMultiple_P ;\n\t\t\tsp->p4053_availablepaths =\n\t\t\t\tmib_p->fddiPORTAvailablePaths ;\n\t\t\tsp->p4053_currentpath =\n\t\t\t\tmib_p->fddiPORTCurrentPath ;\n\t\t\tmemcpy(\t(char *) &sp->p4053_requestedpaths,\n\t\t\t\t(char *) mib_p->fddiPORTRequestedPaths,4) ;\n\t\t\tsp->p4053_mytype =\n\t\t\t\tmib_p->fddiPORTMy_Type ;\n\t\t\tsp->p4053_neighbortype =\n\t\t\t\tmib_p->fddiPORTNeighborType ;\n\t\t\tsp_len = sizeof(struct smt_p_4053) ;\n\t\t\tgoto sp_done ;\n\t\t}\n\tdefault :\n\t\tbreak ;\n\t}\n\t \n\tif (!pt) {\n\t\tpcon->pc_err = (para & 0xff00) ? SMT_RDF_NOPARAM :\n\t\t\t\t\t\tSMT_RDF_ILLEGAL ;\n\t\treturn ;\n\t}\n\t \n\tswitch (pt->p_access) {\n\tcase AC_G :\n\tcase AC_GR :\n\t\tbreak ;\n\tdefault :\n\t\tpcon->pc_err = SMT_RDF_ILLEGAL ;\n\t\treturn ;\n\t}\n\tfrom = mib_addr + pt->p_offset ;\n\tif (!swap)\n\t\tswap = pt->p_swap ;\t\t \n\n\t \n\twhile ((c = *swap++)) {\n\t\tswitch(c) {\n\t\tcase 'b' :\n\t\tcase 'w' :\n\t\tcase 'l' :\n\t\t\tbreak ;\n\t\tcase 'S' :\n\t\tcase 'E' :\n\t\tcase 'R' :\n\t\tcase 'r' :\n\t\t\tif (len < 4)\n\t\t\t\tgoto len_error ;\n\t\t\tto[0] = 0 ;\n\t\t\tto[1] = 0 ;\n#ifdef\tLITTLE_ENDIAN\n\t\t\tif (c == 'r') {\n\t\t\t\tto[2] = *from++ ;\n\t\t\t\tto[3] = *from++ ;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tto[3] = *from++ ;\n\t\t\t\tto[2] = *from++ ;\n\t\t\t}\n#else\n\t\t\tto[2] = *from++ ;\n\t\t\tto[3] = *from++ ;\n#endif\n\t\t\tto += 4 ;\n\t\t\tlen -= 4 ;\n\t\t\tbreak ;\n\t\tcase 'I' :\t\t \n\t\t\tif (len < 2)\n\t\t\t\tgoto len_error ;\n#ifdef\tLITTLE_ENDIAN\n\t\t\tto[1] = *from++ ;\n\t\t\tto[0] = *from++ ;\n#else\n\t\t\tto[0] = *from++ ;\n\t\t\tto[1] = *from++ ;\n#endif\n\t\t\tto += 2 ;\n\t\t\tlen -= 2 ;\n\t\t\tbreak ;\n\t\tcase 'F' :\n\t\tcase 'B' :\n\t\t\tif (len < 4)\n\t\t\t\tgoto len_error ;\n\t\t\tlen -= 4 ;\n\t\t\tto[0] = 0 ;\n\t\t\tto[1] = 0 ;\n\t\t\tto[2] = 0 ;\n\t\t\tto[3] = *from++ ;\n\t\t\tto += 4 ;\n\t\t\tbreak ;\n\t\tcase 'C' :\n\t\tcase 'T' :\n\t\tcase 'L' :\n\t\t\tif (len < 4)\n\t\t\t\tgoto len_error ;\n#ifdef\tLITTLE_ENDIAN\n\t\t\tto[3] = *from++ ;\n\t\t\tto[2] = *from++ ;\n\t\t\tto[1] = *from++ ;\n\t\t\tto[0] = *from++ ;\n#else\n\t\t\tto[0] = *from++ ;\n\t\t\tto[1] = *from++ ;\n\t\t\tto[2] = *from++ ;\n\t\t\tto[3] = *from++ ;\n#endif\n\t\t\tlen -= 4 ;\n\t\t\tto += 4 ;\n\t\t\tbreak ;\n\t\tcase '2' :\t\t \n\t\t\tif (len < 4)\n\t\t\t\tgoto len_error ;\n\t\t\tto[0] = 0 ;\n\t\t\tto[1] = 0 ;\n\t\t\tto[2] = *from++ ;\n\t\t\tto[3] = *from++ ;\n\t\t\tlen -= 4 ;\n\t\t\tto += 4 ;\n\t\t\tbreak ;\n\t\tcase '4' :\n\t\t\tif (len < 4)\n\t\t\t\tgoto len_error ;\n\t\t\tto[0] = *from++ ;\n\t\t\tto[1] = *from++ ;\n\t\t\tto[2] = *from++ ;\n\t\t\tto[3] = *from++ ;\n\t\t\tlen -= 4 ;\n\t\t\tto += 4 ;\n\t\t\tbreak ;\n\t\tcase 'A' :\n\t\t\tif (len < 8)\n\t\t\t\tgoto len_error ;\n\t\t\tto[0] = 0 ;\n\t\t\tto[1] = 0 ;\n\t\t\tmemcpy((char *) to+2,(char *) from,6) ;\n\t\t\tto += 8 ;\n\t\t\tfrom += 8 ;\n\t\t\tlen -= 8 ;\n\t\t\tbreak ;\n\t\tcase '8' :\n\t\t\tif (len < 8)\n\t\t\t\tgoto len_error ;\n\t\t\tmemcpy((char *) to,(char *) from,8) ;\n\t\t\tto += 8 ;\n\t\t\tfrom += 8 ;\n\t\t\tlen -= 8 ;\n\t\t\tbreak ;\n\t\tcase 'D' :\n\t\t\tif (len < 32)\n\t\t\t\tgoto len_error ;\n\t\t\tmemcpy((char *) to,(char *) from,32) ;\n\t\t\tto += 32 ;\n\t\t\tfrom += 32 ;\n\t\t\tlen -= 32 ;\n\t\t\tbreak ;\n\t\tcase 'P' :\t\t \n\t\t\tif (len < 8)\n\t\t\t\tgoto len_error ;\n\t\t\tto[0] = *from++ ;\n\t\t\tto[1] = *from++ ;\n\t\t\tto[2] = *from++ ;\n\t\t\tto[3] = *from++ ;\n\t\t\tto[4] = *from++ ;\n\t\t\tto[5] = *from++ ;\n\t\t\tto[6] = *from++ ;\n\t\t\tto[7] = *from++ ;\n\t\t\tto += 8 ;\n\t\t\tlen -= 8 ;\n\t\t\tbreak ;\n\t\tdefault :\n\t\t\tSMT_PANIC(smc,SMT_E0119, SMT_E0119_MSG) ;\n\t\t\tbreak ;\n\t\t}\n\t}\n\ndone:\n\t \n\tif (len & 3) {\n\t\tto[0] = 0 ;\n\t\tto[1] = 0 ;\n\t\tto += 4 - (len & 3 ) ;\n\t\tlen = len & ~ 3 ;\n\t}\n\n\t \n\tpa->p_type = para ;\n\tpa->p_len = plen - len - PARA_LEN ;\n\t \n\tpcon->pc_p = (void *) to ;\n\tpcon->pc_len = len ;\n\treturn ;\n\nsp_done:\n\tlen -= sp_len ;\n\tto += sp_len ;\n\tgoto done ;\n\nlen_error:\n\t \n\tpcon->pc_err = SMT_RDF_TOOLONG ;\n\treturn ;\n\nwrong_error:\n\tpcon->pc_err = SMT_RDF_LENGTH ;\n}\n\n \nstatic int smt_set_para(struct s_smc *smc, struct smt_para *pa, int index,\n\t\t\tint local, int set)\n{\n#define IFSET(x)\tif (set) (x)\n\n\tconst struct s_p_tab\t*pt ;\n\tint\t\tlen ;\n\tchar\t\t*from ;\n\tchar\t\t*to ;\n\tconst char\t*swap ;\n\tchar\t\tc ;\n\tchar\t\t*mib_addr ;\n\tstruct fddi_mib\t*mib ;\n\tstruct fddi_mib_m\t*mib_m = NULL;\n\tstruct fddi_mib_a\t*mib_a = NULL;\n\tstruct fddi_mib_p\t*mib_p = NULL;\n\tint\t\tmac ;\n\tint\t\tpath ;\n\tint\t\tport ;\n\tSK_LOC_DECL(u_char,byte_val) ;\n\tSK_LOC_DECL(u_short,word_val) ;\n\tSK_LOC_DECL(u_long,long_val) ;\n\n\tmac = index - INDEX_MAC ;\n\tpath = index - INDEX_PATH ;\n\tport = index - INDEX_PORT ;\n\tlen = pa->p_len ;\n\tfrom = (char *) (pa + 1 ) ;\n\n\tmib = &smc->mib ;\n\tswitch (pa->p_type & 0xf000) {\n\tcase 0x1000 :\n\tdefault :\n\t\tmib_addr = (char *) mib ;\n\t\tbreak ;\n\tcase 0x2000 :\n\t\tif (mac < 0 || mac >= NUMMACS) {\n\t\t\treturn SMT_RDF_NOPARAM;\n\t\t}\n\t\tmib_m = &smc->mib.m[mac] ;\n\t\tmib_addr = (char *) mib_m ;\n\t\tfrom += 4 ;\t\t \n\t\tlen -= 4 ;\n\t\tbreak ;\n\tcase 0x3000 :\n\t\tif (path < 0 || path >= NUMPATHS) {\n\t\t\treturn SMT_RDF_NOPARAM;\n\t\t}\n\t\tmib_a = &smc->mib.a[path] ;\n\t\tmib_addr = (char *) mib_a ;\n\t\tfrom += 4 ;\t\t \n\t\tlen -= 4 ;\n\t\tbreak ;\n\tcase 0x4000 :\n\t\tif (port < 0 || port >= smt_mib_phys(smc)) {\n\t\t\treturn SMT_RDF_NOPARAM;\n\t\t}\n\t\tmib_p = &smc->mib.p[port_to_mib(smc,port)] ;\n\t\tmib_addr = (char *) mib_p ;\n\t\tfrom += 4 ;\t\t \n\t\tlen -= 4 ;\n\t\tbreak ;\n\t}\n\tswitch (pa->p_type) {\n\tcase SMT_P10F0 :\n\tcase SMT_P10F1 :\n#ifdef\tESS\n\tcase SMT_P10F2 :\n\tcase SMT_P10F3 :\n\tcase SMT_P10F4 :\n\tcase SMT_P10F5 :\n\tcase SMT_P10F6 :\n\tcase SMT_P10F7 :\n#endif\n#ifdef\tSBA\n\tcase SMT_P10F8 :\n\tcase SMT_P10F9 :\n#endif\n\tcase SMT_P20F1 :\n\t\tif (!local)\n\t\t\treturn SMT_RDF_NOPARAM;\n\t\tbreak ;\n\t}\n\tpt = smt_get_ptab(pa->p_type) ;\n\tif (!pt)\n\t\treturn (pa->p_type & 0xff00) ? SMT_RDF_NOPARAM :\n\t\t\t\t\t       SMT_RDF_ILLEGAL;\n\tswitch (pt->p_access) {\n\tcase AC_GR :\n\tcase AC_S :\n\t\tbreak ;\n\tdefault :\n\t\treturn SMT_RDF_ILLEGAL;\n\t}\n\tto = mib_addr + pt->p_offset ;\n\tswap = pt->p_swap ;\t\t \n\n\twhile (swap && (c = *swap++)) {\n\t\tswitch(c) {\n\t\tcase 'b' :\n\t\t\tto = (char *) &byte_val ;\n\t\t\tbreak ;\n\t\tcase 'w' :\n\t\t\tto = (char *) &word_val ;\n\t\t\tbreak ;\n\t\tcase 'l' :\n\t\t\tto = (char *) &long_val ;\n\t\t\tbreak ;\n\t\tcase 'S' :\n\t\tcase 'E' :\n\t\tcase 'R' :\n\t\tcase 'r' :\n\t\t\tif (len < 4) {\n\t\t\t\tgoto len_error ;\n\t\t\t}\n\t\t\tif (from[0] | from[1])\n\t\t\t\tgoto val_error ;\n#ifdef\tLITTLE_ENDIAN\n\t\t\tif (c == 'r') {\n\t\t\t\tto[0] = from[2] ;\n\t\t\t\tto[1] = from[3] ;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tto[1] = from[2] ;\n\t\t\t\tto[0] = from[3] ;\n\t\t\t}\n#else\n\t\t\tto[0] = from[2] ;\n\t\t\tto[1] = from[3] ;\n#endif\n\t\t\tfrom += 4 ;\n\t\t\tto += 2 ;\n\t\t\tlen -= 4 ;\n\t\t\tbreak ;\n\t\tcase 'F' :\n\t\tcase 'B' :\n\t\t\tif (len < 4) {\n\t\t\t\tgoto len_error ;\n\t\t\t}\n\t\t\tif (from[0] | from[1] | from[2])\n\t\t\t\tgoto val_error ;\n\t\t\tto[0] = from[3] ;\n\t\t\tlen -= 4 ;\n\t\t\tfrom += 4 ;\n\t\t\tto += 4 ;\n\t\t\tbreak ;\n\t\tcase 'C' :\n\t\tcase 'T' :\n\t\tcase 'L' :\n\t\t\tif (len < 4) {\n\t\t\t\tgoto len_error ;\n\t\t\t}\n#ifdef\tLITTLE_ENDIAN\n\t\t\tto[3] = *from++ ;\n\t\t\tto[2] = *from++ ;\n\t\t\tto[1] = *from++ ;\n\t\t\tto[0] = *from++ ;\n#else\n\t\t\tto[0] = *from++ ;\n\t\t\tto[1] = *from++ ;\n\t\t\tto[2] = *from++ ;\n\t\t\tto[3] = *from++ ;\n#endif\n\t\t\tlen -= 4 ;\n\t\t\tto += 4 ;\n\t\t\tbreak ;\n\t\tcase 'A' :\n\t\t\tif (len < 8)\n\t\t\t\tgoto len_error ;\n\t\t\tif (set)\n\t\t\t\tmemcpy(to,from+2,6) ;\n\t\t\tto += 8 ;\n\t\t\tfrom += 8 ;\n\t\t\tlen -= 8 ;\n\t\t\tbreak ;\n\t\tcase '4' :\n\t\t\tif (len < 4)\n\t\t\t\tgoto len_error ;\n\t\t\tif (set)\n\t\t\t\tmemcpy(to,from,4) ;\n\t\t\tto += 4 ;\n\t\t\tfrom += 4 ;\n\t\t\tlen -= 4 ;\n\t\t\tbreak ;\n\t\tcase '8' :\n\t\t\tif (len < 8)\n\t\t\t\tgoto len_error ;\n\t\t\tif (set)\n\t\t\t\tmemcpy(to,from,8) ;\n\t\t\tto += 8 ;\n\t\t\tfrom += 8 ;\n\t\t\tlen -= 8 ;\n\t\t\tbreak ;\n\t\tcase 'D' :\n\t\t\tif (len < 32)\n\t\t\t\tgoto len_error ;\n\t\t\tif (set)\n\t\t\t\tmemcpy(to,from,32) ;\n\t\t\tto += 32 ;\n\t\t\tfrom += 32 ;\n\t\t\tlen -= 32 ;\n\t\t\tbreak ;\n\t\tcase 'P' :\t\t \n\t\t\tif (set) {\n\t\t\t\tto[0] = *from++ ;\n\t\t\t\tto[1] = *from++ ;\n\t\t\t\tto[2] = *from++ ;\n\t\t\t\tto[3] = *from++ ;\n\t\t\t\tto[4] = *from++ ;\n\t\t\t\tto[5] = *from++ ;\n\t\t\t\tto[6] = *from++ ;\n\t\t\t\tto[7] = *from++ ;\n\t\t\t}\n\t\t\tto += 8 ;\n\t\t\tlen -= 8 ;\n\t\t\tbreak ;\n\t\tdefault :\n\t\t\tSMT_PANIC(smc,SMT_E0120, SMT_E0120_MSG) ;\n\t\t\treturn SMT_RDF_ILLEGAL;\n\t\t}\n\t}\n\t \n\tswitch (pa->p_type) {\n\tcase SMT_P101A:\t\t\t \n\t\tif (word_val & ~1)\n\t\t\tgoto val_error ;\n\t\tIFSET(mib->fddiSMTConfigPolicy = word_val) ;\n\t\tbreak ;\n\tcase SMT_P101B :\t\t \n\t\tif (!(word_val & POLICY_MM))\n\t\t\tgoto val_error ;\n\t\tIFSET(mib->fddiSMTConnectionPolicy = word_val) ;\n\t\tbreak ;\n\tcase SMT_P101D : \t\t \n\t\tif (word_val < 2 || word_val > 30)\n\t\t\tgoto val_error ;\n\t\tIFSET(mib->fddiSMTTT_Notify = word_val) ;\n\t\tbreak ;\n\tcase SMT_P101E :\t\t \n\t\tif (byte_val & ~1)\n\t\t\tgoto val_error ;\n\t\tIFSET(mib->fddiSMTStatRptPolicy = byte_val) ;\n\t\tbreak ;\n\tcase SMT_P101F :\t\t \n\t\t \n\t\tif (long_val < (long)0x478bf51L)\n\t\t\tgoto val_error ;\n\t\tIFSET(mib->fddiSMTTrace_MaxExpiration = long_val) ;\n\t\tbreak ;\n#ifdef\tESS\n\tcase SMT_P10F2 :\t\t \n\t\tif (long_val > 1562)\n\t\t\tgoto val_error ;\n\t\tif (set && smc->mib.fddiESSPayload != long_val) {\n\t\t\tsmc->ess.raf_act_timer_poll = TRUE ;\n\t\t\tsmc->mib.fddiESSPayload = long_val ;\n\t\t}\n\t\tbreak ;\n\tcase SMT_P10F3 :\t\t \n\t\tif (long_val < 50 || long_val > 5000)\n\t\t\tgoto val_error ;\n\t\tif (set && smc->mib.fddiESSPayload &&\n\t\t\tsmc->mib.fddiESSOverhead != long_val) {\n\t\t\tsmc->ess.raf_act_timer_poll = TRUE ;\n\t\t\tsmc->mib.fddiESSOverhead = long_val ;\n\t\t}\n\t\tbreak ;\n\tcase SMT_P10F4 :\t\t \n\t\tif (long_val > -MS2BCLK(5) || long_val < -MS2BCLK(165))\n\t\t\tgoto val_error ;\n\t\tIFSET(mib->fddiESSMaxTNeg = long_val) ;\n\t\tbreak ;\n\tcase SMT_P10F5 :\t\t \n\t\tif (long_val < 1 || long_val > 4478)\n\t\t\tgoto val_error ;\n\t\tIFSET(mib->fddiESSMinSegmentSize = long_val) ;\n\t\tbreak ;\n\tcase SMT_P10F6 :\t\t \n\t\tif ((long_val & 0xffff) != 1)\n\t\t\tgoto val_error ;\n\t\tIFSET(mib->fddiESSCategory = long_val) ;\n\t\tbreak ;\n\tcase SMT_P10F7 :\t\t \n\t\tif (word_val > 1)\n\t\t\tgoto val_error ;\n\t\tIFSET(mib->fddiESSSynchTxMode = word_val) ;\n\t\tbreak ;\n#endif\n#ifdef\tSBA\n\tcase SMT_P10F8 :\t\t \n\t\tif (byte_val != SB_STOP && byte_val != SB_START)\n\t\t\tgoto val_error ;\n\t\tIFSET(mib->fddiSBACommand = byte_val) ;\n\t\tbreak ;\n\tcase SMT_P10F9 :\t\t \n\t\tif (byte_val > 100)\n\t\t\tgoto val_error ;\n\t\tIFSET(mib->fddiSBAAvailable = byte_val) ;\n\t\tbreak ;\n#endif\n\tcase SMT_P2020 :\t\t \n\t\tif ((word_val & (MIB_P_PATH_PRIM_PREFER |\n\t\t\tMIB_P_PATH_PRIM_ALTER)) == 0 )\n\t\t\tgoto val_error ;\n\t\tIFSET(mib_m->fddiMACRequestedPaths = word_val) ;\n\t\tbreak ;\n\tcase SMT_P205F :\t\t \n\t\t \n\t\tIFSET(mib_m->fddiMACFrameErrorThreshold = word_val) ;\n\t\tbreak ;\n\tcase SMT_P2067 :\t\t \n\t\t \n\t\tIFSET(mib_m->fddiMACNotCopiedThreshold = word_val) ;\n\t\tbreak ;\n\tcase SMT_P2076:\t\t\t \n\t\tif (byte_val & ~1)\n\t\t\tgoto val_error ;\n\t\tif (set) {\n\t\t\tmib_m->fddiMACMA_UnitdataEnable = byte_val ;\n\t\t\tqueue_event(smc,EVENT_RMT,RM_ENABLE_FLAG) ;\n\t\t}\n\t\tbreak ;\n\tcase SMT_P20F1 :\t\t \n\t\tIFSET(mib_m->fddiMACT_Min = long_val) ;\n\t\tbreak ;\n\tcase SMT_P320F :\n\t\tif (long_val > 1562)\n\t\t\tgoto val_error ;\n\t\tIFSET(mib_a->fddiPATHSbaPayload = long_val) ;\n#ifdef\tESS\n\t\tif (set)\n\t\t\tess_para_change(smc) ;\n#endif\n\t\tbreak ;\n\tcase SMT_P3210 :\n\t\tif (long_val > 5000)\n\t\t\tgoto val_error ;\n\t\t\n\t\tif (long_val != 0 && mib_a->fddiPATHSbaPayload == 0)\n\t\t\tgoto val_error ;\n\n\t\tIFSET(mib_a->fddiPATHSbaOverhead = long_val) ;\n#ifdef\tESS\n\t\tif (set)\n\t\t\tess_para_change(smc) ;\n#endif\n\t\tbreak ;\n\tcase SMT_P3213:\t\t\t \n\t\t \n\t\tif (set) {\n\t\t\tmib_a->fddiPATHT_Rmode = long_val ;\n\t\t\trtm_set_timer(smc) ;\n\t\t}\n\t\tbreak ;\n\tcase SMT_P3214 :\t\t \n\t\tif (long_val > 0x00BEBC20L)\n\t\t\tgoto val_error ;\n#ifdef SBA \n\t\tif (set && mib->fddiSBACommand == SB_STOP)\n\t\t\tgoto val_error ;\n#endif\n\t\tIFSET(mib_a->fddiPATHSbaAvailable = long_val) ;\n\t\tbreak ;\n\tcase SMT_P3215 :\t\t \n\t\tIFSET(mib_a->fddiPATHTVXLowerBound = long_val) ;\n\t\tgoto change_mac_para ;\n\tcase SMT_P3216 :\t\t \n\t\tIFSET(mib_a->fddiPATHT_MaxLowerBound = long_val) ;\n\t\tgoto change_mac_para ;\n\tcase SMT_P3217 :\t\t \n\t\tIFSET(mib_a->fddiPATHMaxT_Req = long_val) ;\n\nchange_mac_para:\n\t\tif (set && smt_set_mac_opvalues(smc)) {\n\t\t\tRS_SET(smc,RS_EVENT) ;\n\t\t\tsmc->sm.please_reconnect = 1 ;\n\t\t\tqueue_event(smc,EVENT_ECM,EC_DISCONNECT) ;\n\t\t}\n\t\tbreak ;\n\tcase SMT_P400E :\t\t \n\t\tif (byte_val > 1)\n\t\t\tgoto val_error ;\n\t\tIFSET(mib_p->fddiPORTConnectionPolicies = byte_val) ;\n\t\tbreak ;\n\tcase SMT_P4011 :\t\t \n\t\t \n\t\tIFSET(memcpy((char *)mib_p->fddiPORTRequestedPaths,\n\t\t\t(char *)&long_val,4)) ;\n\t\tbreak ;\n\tcase SMT_P401F:\t\t\t \n\t\tif (word_val > 4)\n\t\t\tgoto val_error ;\n\t\tIFSET(mib_p->fddiPORTMaint_LS = word_val) ;\n\t\tbreak ;\n\tcase SMT_P403A :\t\t \n\t\tif (byte_val < 4 || byte_val > 15)\n\t\t\tgoto val_error ;\n\t\tIFSET(mib_p->fddiPORTLer_Cutoff = byte_val) ;\n\t\tbreak ;\n\tcase SMT_P403B :\t\t \n\t\tif (byte_val < 4 || byte_val > 15)\n\t\t\tgoto val_error ;\n\t\tIFSET(mib_p->fddiPORTLer_Alarm = byte_val) ;\n\t\tbreak ;\n\n\t \n\tcase SMT_P103C :\t\t \n\t\tif (smt_action(smc,SMT_STATION_ACTION, (int) word_val, 0))\n\t\t\tgoto val_error ;\n\t\tbreak ;\n\tcase SMT_P4046:\t\t\t \n\t\tif (smt_action(smc,SMT_PORT_ACTION, (int) word_val,\n\t\t\tport_to_mib(smc,port)))\n\t\t\tgoto val_error ;\n\t\tbreak ;\n\tdefault :\n\t\tbreak ;\n\t}\n\treturn 0;\n\nval_error:\n\t \n\treturn SMT_RDF_RANGE;\n\nlen_error:\n\t \n\treturn SMT_RDF_LENGTH;\n\n#if\t0\nno_author_error:\n\t \n\treturn SMT_RDF_AUTHOR;\n#endif\n}\n\nstatic const struct s_p_tab *smt_get_ptab(u_short para)\n{\n\tconst struct s_p_tab\t*pt ;\n\tfor (pt = p_tab ; pt->p_num && pt->p_num != para ; pt++)\n\t\t;\n\treturn pt->p_num ? pt : NULL;\n}\n\nstatic int smt_mib_phys(struct s_smc *smc)\n{\n#ifdef\tCONCENTRATOR\n\tSK_UNUSED(smc) ;\n\n\treturn NUMPHYS;\n#else\n\tif (smc->s.sas == SMT_SAS)\n\t\treturn 1;\n\treturn NUMPHYS;\n#endif\n}\n\nstatic int port_to_mib(struct s_smc *smc, int p)\n{\n#ifdef\tCONCENTRATOR\n\tSK_UNUSED(smc) ;\n\n\treturn p;\n#else\n\tif (smc->s.sas == SMT_SAS)\n\t\treturn PS;\n\treturn p;\n#endif\n}\n\n\n#ifdef\tDEBUG\n#ifndef\tBOOT\nvoid dump_smt(struct s_smc *smc, struct smt_header *sm, char *text)\n{\n\tint\tlen ;\n\tstruct smt_para\t*pa ;\n\tchar\t*c ;\n\tint\tn ;\n\tint\tnn ;\n#ifdef\tLITTLE_ENDIAN\n\tint\tsmtlen ;\n#endif\n\n\tSK_UNUSED(smc) ;\n\n#ifdef\tDEBUG_BRD\n\tif (smc->debug.d_smtf < 2)\n#else\n\tif (debug.d_smtf < 2)\n#endif\n\t\treturn ;\n#ifdef\tLITTLE_ENDIAN\n\tsmtlen = sm->smt_len + sizeof(struct smt_header) ;\n#endif\n\tprintf(\"SMT Frame [%s]:\\nDA  \",text) ;\n\tdump_hex((char *) &sm->smt_dest,6) ;\n\tprintf(\"\\tSA \") ;\n\tdump_hex((char *) &sm->smt_source,6) ;\n\tprintf(\" Class %x Type %x Version %x\\n\",\n\t\tsm->smt_class,sm->smt_type,sm->smt_version)  ;\n\tprintf(\"TID %x\\t\\tSID \", sm->smt_tid);\n\tdump_hex((char *) &sm->smt_sid,8) ;\n\tprintf(\" LEN %x\\n\",sm->smt_len) ;\n\n\tlen = sm->smt_len ;\n\tpa = (struct smt_para *) (sm + 1) ;\n\twhile (len > 0 ) {\n\t\tint\tplen ;\n#ifdef UNIX\n\t\tprintf(\"TYPE %x LEN %x VALUE\\t\",pa->p_type,pa->p_len) ;\n#else\n\t\tprintf(\"TYPE %04x LEN %2x VALUE\\t\",pa->p_type,pa->p_len) ;\n#endif\n\t\tn = pa->p_len ;\n\t\tif ( (n < 0 ) || (n > (int)(len - PARA_LEN))) {\n\t\t\tn = len - PARA_LEN ;\n\t\t\tprintf(\" BAD LENGTH\\n\") ;\n\t\t\tbreak ;\n\t\t}\n#ifdef\tLITTLE_ENDIAN\n\t\tsmt_swap_para(sm,smtlen,0) ;\n#endif\n\t\tif (n < 24) {\n\t\t\tdump_hex((char *)(pa+1),(int) n) ;\n\t\t\tprintf(\"\\n\") ;\n\t\t}\n\t\telse {\n\t\t\tint\tfirst = 0 ;\n\t\t\tc = (char *)(pa+1) ;\n\t\t\tdump_hex(c,16) ;\n\t\t\tprintf(\"\\n\") ;\n\t\t\tn -= 16 ;\n\t\t\tc += 16 ;\n\t\t\twhile (n > 0) {\n\t\t\t\tnn = (n > 16) ? 16 : n ;\n\t\t\t\tif (n > 64) {\n\t\t\t\t\tif (first == 0)\n\t\t\t\t\t\tprintf(\"\\t\\t\\t...\\n\") ;\n\t\t\t\t\tfirst = 1 ;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprintf(\"\\t\\t\\t\") ;\n\t\t\t\t\tdump_hex(c,nn) ;\n\t\t\t\t\tprintf(\"\\n\") ;\n\t\t\t\t}\n\t\t\t\tn -= nn ;\n\t\t\t\tc += 16 ;\n\t\t\t}\n\t\t}\n#ifdef\tLITTLE_ENDIAN\n\t\tsmt_swap_para(sm,smtlen,1) ;\n#endif\n\t\tplen = (pa->p_len + PARA_LEN + 3) & ~3 ;\n\t\tlen -= plen ;\n\t\tpa = (struct smt_para *)((char *)pa + plen) ;\n\t}\n\tprintf(\"-------------------------------------------------\\n\\n\") ;\n}\n\nvoid dump_hex(char *p, int len)\n{\n\tint\tn = 0 ;\n\twhile (len--) {\n\t\tn++ ;\n#ifdef UNIX\n\t\tprintf(\"%x%s\",*p++ & 0xff,len ? ( (n & 7) ? \" \" : \"-\") : \"\") ;\n#else\n\t\tprintf(\"%02x%s\",*p++ & 0xff,len ? ( (n & 7) ? \" \" : \"-\") : \"\") ;\n#endif\n\t}\n}\n#endif\t \n#endif\t \n\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}