{
  "module_name": "rmt.c",
  "hash_id": "254cc5cad5af946b4a8027d5f25f8e904678e0ce51800ccc58aadc119825fa59",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/fddi/skfp/rmt.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include \"h/types.h\"\n#include \"h/fddi.h\"\n#include \"h/smc.h\"\n\n#define KERNEL\n#include \"h/smtstate.h\"\n\n \n#define AFLAG\t0x10\n#define GO_STATE(x)\t(smc->mib.m[MAC0].fddiMACRMTState = (x)|AFLAG)\n#define ACTIONS_DONE()\t(smc->mib.m[MAC0].fddiMACRMTState &= ~AFLAG)\n#define ACTIONS(x)\t(x|AFLAG)\n\n#define RM0_ISOLATED\t0\n#define RM1_NON_OP\t1\t\t \n#define RM2_RING_OP\t2\t\t \n#define RM3_DETECT\t3\t\t \n#define RM4_NON_OP_DUP\t4\t\t \n#define RM5_RING_OP_DUP\t5\t\t \n#define RM6_DIRECTED\t6\t\t \n#define RM7_TRACE\t7\t\t \n\n \nstatic const char * const rmt_states[] = {\n\t\"RM0_ISOLATED\",\"RM1_NON_OP\",\"RM2_RING_OP\",\"RM3_DETECT\",\n\t\"RM4_NON_OP_DUP\",\"RM5_RING_OP_DUP\",\"RM6_DIRECTED\",\n\t\"RM7_TRACE\"\n} ;\n\n \nstatic const char * const rmt_events[] = {\n\t\"NONE\",\"RM_RING_OP\",\"RM_RING_NON_OP\",\"RM_MY_BEACON\",\n\t\"RM_OTHER_BEACON\",\"RM_MY_CLAIM\",\"RM_TRT_EXP\",\"RM_VALID_CLAIM\",\n\t\"RM_JOIN\",\"RM_LOOP\",\"RM_DUP_ADDR\",\"RM_ENABLE_FLAG\",\n\t\"RM_TIMEOUT_NON_OP\",\"RM_TIMEOUT_T_STUCK\",\n\t\"RM_TIMEOUT_ANNOUNCE\",\"RM_TIMEOUT_T_DIRECT\",\n\t\"RM_TIMEOUT_D_MAX\",\"RM_TIMEOUT_POLL\",\"RM_TX_STATE_CHANGE\"\n} ;\n\n \n\n\n \nstatic void rmt_fsm(struct s_smc *smc, int cmd);\nstatic void start_rmt_timer0(struct s_smc *smc, u_long value, int event);\nstatic void start_rmt_timer1(struct s_smc *smc, u_long value, int event);\nstatic void start_rmt_timer2(struct s_smc *smc, u_long value, int event);\nstatic void stop_rmt_timer0(struct s_smc *smc);\nstatic void stop_rmt_timer1(struct s_smc *smc);\nstatic void stop_rmt_timer2(struct s_smc *smc);\nstatic void rmt_dup_actions(struct s_smc *smc);\nstatic void rmt_reinsert_actions(struct s_smc *smc);\nstatic void rmt_leave_actions(struct s_smc *smc);\nstatic void rmt_new_dup_actions(struct s_smc *smc);\n\n#ifndef SUPERNET_3\nextern void restart_trt_for_dbcn() ;\n#endif  \n\n \nvoid rmt_init(struct s_smc *smc)\n{\n\tsmc->mib.m[MAC0].fddiMACRMTState = ACTIONS(RM0_ISOLATED) ;\n\tsmc->r.dup_addr_test = DA_NONE ;\n\tsmc->r.da_flag = 0 ;\n\tsmc->mib.m[MAC0].fddiMACMA_UnitdataAvailable = FALSE ;\n\tsmc->r.sm_ma_avail = FALSE ;\n\tsmc->r.loop_avail = 0 ;\n\tsmc->r.bn_flag = 0 ;\n\tsmc->r.jm_flag = 0 ;\n\tsmc->r.no_flag = TRUE ;\n}\n\n \nvoid rmt(struct s_smc *smc, int event)\n{\n\tint\tstate ;\n\n\tdo {\n\t\tDB_RMT(\"RMT : state %s%s event %s\",\n\t\t       smc->mib.m[MAC0].fddiMACRMTState & AFLAG ? \"ACTIONS \" : \"\",\n\t\t       rmt_states[smc->mib.m[MAC0].fddiMACRMTState & ~AFLAG],\n\t\t       rmt_events[event]);\n\t\tstate = smc->mib.m[MAC0].fddiMACRMTState ;\n\t\trmt_fsm(smc,event) ;\n\t\tevent = 0 ;\n\t} while (state != smc->mib.m[MAC0].fddiMACRMTState) ;\n\trmt_state_change(smc,(int)smc->mib.m[MAC0].fddiMACRMTState) ;\n}\n\n \nstatic void rmt_fsm(struct s_smc *smc, int cmd)\n{\n\t \n\tif (!smc->r.rm_join && !smc->r.rm_loop &&\n\t\tsmc->mib.m[MAC0].fddiMACRMTState != ACTIONS(RM0_ISOLATED) &&\n\t\tsmc->mib.m[MAC0].fddiMACRMTState != RM0_ISOLATED) {\n\t\tRS_SET(smc,RS_NORINGOP) ;\n\t\trmt_indication(smc,0) ;\n\t\tGO_STATE(RM0_ISOLATED) ;\n\t\treturn ;\n\t}\n\n\tswitch(smc->mib.m[MAC0].fddiMACRMTState) {\n\tcase ACTIONS(RM0_ISOLATED) :\n\t\tstop_rmt_timer0(smc) ;\n\t\tstop_rmt_timer1(smc) ;\n\t\tstop_rmt_timer2(smc) ;\n\n\t\t \n\t\tsm_ma_control(smc,MA_OFFLINE) ;\n\t\tsmc->mib.m[MAC0].fddiMACMA_UnitdataAvailable = FALSE ;\n\t\tsmc->r.loop_avail = FALSE ;\n\t\tsmc->r.sm_ma_avail = FALSE ;\n\t\tsmc->r.no_flag = TRUE ;\n\t\tDB_RMTN(1, \"RMT : ISOLATED\");\n\t\tACTIONS_DONE() ;\n\t\tbreak ;\n\tcase RM0_ISOLATED :\n\t\t \n\t\tif (smc->r.rm_join || smc->r.rm_loop) {\n\t\t\t \n\t\t\tsm_ma_control(smc,MA_RESET) ;\n\t\t\tGO_STATE(RM1_NON_OP) ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak ;\n\tcase ACTIONS(RM1_NON_OP) :\n\t\tstart_rmt_timer0(smc,smc->s.rmt_t_non_op,RM_TIMEOUT_NON_OP) ;\n\t\tstop_rmt_timer1(smc) ;\n\t\tstop_rmt_timer2(smc) ;\n\t\tsm_ma_control(smc,MA_BEACON) ;\n\t\tDB_RMTN(1, \"RMT : RING DOWN\");\n\t\tRS_SET(smc,RS_NORINGOP) ;\n\t\tsmc->r.sm_ma_avail = FALSE ;\n\t\trmt_indication(smc,0) ;\n\t\tACTIONS_DONE() ;\n\t\tbreak ;\n\tcase RM1_NON_OP :\n\t\t \n\t\tif (cmd == RM_RING_OP) {\n\t\t\tRS_SET(smc,RS_RINGOPCHANGE) ;\n\t\t\tGO_STATE(RM2_RING_OP) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (cmd == RM_TIMEOUT_NON_OP) {\n\t\t\tsmc->r.bn_flag = FALSE ;\n\t\t\tsmc->r.no_flag = TRUE ;\n\t\t\tGO_STATE(RM3_DETECT) ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak ;\n\tcase ACTIONS(RM2_RING_OP) :\n\t\tstop_rmt_timer0(smc) ;\n\t\tstop_rmt_timer1(smc) ;\n\t\tstop_rmt_timer2(smc) ;\n\t\tsmc->r.no_flag = FALSE ;\n\t\tif (smc->r.rm_loop)\n\t\t\tsmc->r.loop_avail = TRUE ;\n\t\tif (smc->r.rm_join) {\n\t\t\tsmc->r.sm_ma_avail = TRUE ;\n\t\t\tif (smc->mib.m[MAC0].fddiMACMA_UnitdataEnable)\n\t\t\t\tsmc->mib.m[MAC0].fddiMACMA_UnitdataAvailable = TRUE;\n\t\t\telse\n\t\t\t\tsmc->mib.m[MAC0].fddiMACMA_UnitdataAvailable = FALSE;\n\t\t}\n\t\tDB_RMTN(1, \"RMT : RING UP\");\n\t\tRS_CLEAR(smc,RS_NORINGOP) ;\n\t\tRS_SET(smc,RS_RINGOPCHANGE) ;\n\t\trmt_indication(smc,1) ;\n\t\tsmt_stat_counter(smc,0) ;\n\t\tACTIONS_DONE() ;\n\t\tbreak ;\n\tcase RM2_RING_OP :\n\t\t \n\t\tif (cmd == RM_RING_NON_OP) {\n\t\t\tsmc->mib.m[MAC0].fddiMACMA_UnitdataAvailable = FALSE ;\n\t\t\tsmc->r.loop_avail = FALSE ;\n\t\t\tRS_SET(smc,RS_RINGOPCHANGE) ;\n\t\t\tGO_STATE(RM1_NON_OP) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (cmd == RM_ENABLE_FLAG) {\n\t\t\tif (smc->mib.m[MAC0].fddiMACMA_UnitdataEnable)\n\t\t\tsmc->mib.m[MAC0].fddiMACMA_UnitdataAvailable = TRUE ;\n\t\t\t\telse\n\t\t\tsmc->mib.m[MAC0].fddiMACMA_UnitdataAvailable = FALSE ;\n\t\t}\n\t\t \n\t\telse if (smc->r.dup_addr_test == DA_FAILED) {\n\t\t\tsmc->mib.m[MAC0].fddiMACMA_UnitdataAvailable = FALSE ;\n\t\t\tsmc->r.loop_avail = FALSE ;\n\t\t\tsmc->r.da_flag = TRUE ;\n\t\t\tGO_STATE(RM5_RING_OP_DUP) ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak ;\n\tcase ACTIONS(RM3_DETECT) :\n\t\tstart_rmt_timer0(smc,smc->s.mac_d_max*2,RM_TIMEOUT_D_MAX) ;\n\t\tstart_rmt_timer1(smc,smc->s.rmt_t_stuck,RM_TIMEOUT_T_STUCK) ;\n\t\tstart_rmt_timer2(smc,smc->s.rmt_t_poll,RM_TIMEOUT_POLL) ;\n\t\tsm_mac_check_beacon_claim(smc) ;\n\t\tDB_RMTN(1, \"RMT : RM3_DETECT\");\n\t\tACTIONS_DONE() ;\n\t\tbreak ;\n\tcase RM3_DETECT :\n\t\tif (cmd == RM_TIMEOUT_POLL) {\n\t\t\tstart_rmt_timer2(smc,smc->s.rmt_t_poll,RM_TIMEOUT_POLL);\n\t\t\tsm_mac_check_beacon_claim(smc) ;\n\t\t\tbreak ;\n\t\t}\n\t\tif (cmd == RM_TIMEOUT_D_MAX) {\n\t\t\tsmc->r.timer0_exp = TRUE ;\n\t\t}\n\t\t \n\t\tif (cmd == RM_TX_STATE_CHANGE) {\n\t\t\tstart_rmt_timer0(smc,\n\t\t\t\t\t smc->s.mac_d_max*2,\n\t\t\t\t\t RM_TIMEOUT_D_MAX) ;\n\t\t}\n\t\t \n\t\tif (cmd == RM_RING_OP) {\n\t\t\tGO_STATE(RM2_RING_OP) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if ((cmd == RM_MY_BEACON || cmd == RM_OTHER_BEACON)\n\t\t\t&& smc->r.bn_flag) {\n\t\t\tsmc->r.bn_flag = FALSE ;\n\t\t}\n\t\t \n\t\telse if (cmd == RM_TRT_EXP && !smc->r.bn_flag) {\n\t\t\tint\ttx ;\n\t\t\t \n\t\t\tif ((tx =  sm_mac_get_tx_state(smc)) == 4 || tx == 5) {\n\t\t\tDB_RMTN(2, \"RMT : DETECT && TRT_EXPIRED && T4/T5\");\n\t\t\t\tsmc->r.bn_flag = TRUE ;\n\t\t\t\t \n\t\t\t\tstart_rmt_timer1(smc,smc->s.rmt_t_stuck,\n\t\t\t\t\tRM_TIMEOUT_T_STUCK) ;\n\t\t\t}\n\t\t\t \n\n\t\t\tDB_RMTN(2, \"RMT : sm_mac_get_tx_state() = %d (bn_flag = %d)\",\n\t\t\t\ttx, smc->r.bn_flag);\n\t\t}\n\t\t \n\t\telse if (cmd == RM_MY_CLAIM && smc->r.timer0_exp) {\n\t\t\trmt_new_dup_actions(smc) ;\n\t\t\tGO_STATE(RM4_NON_OP_DUP) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (cmd == RM_MY_BEACON && smc->r.timer0_exp) {\n\t\t\trmt_new_dup_actions(smc) ;\n\t\t\tGO_STATE(RM4_NON_OP_DUP) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (cmd == RM_VALID_CLAIM) {\n\t\t\trmt_new_dup_actions(smc) ;\n\t\t\tGO_STATE(RM4_NON_OP_DUP) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (cmd == RM_TIMEOUT_T_STUCK &&\n\t\t\tsmc->r.rm_join && smc->r.bn_flag) {\n\t\t\tGO_STATE(RM6_DIRECTED) ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak ;\n\tcase ACTIONS(RM4_NON_OP_DUP) :\n\t\tstart_rmt_timer0(smc,smc->s.rmt_t_announce,RM_TIMEOUT_ANNOUNCE);\n\t\tstart_rmt_timer1(smc,smc->s.rmt_t_stuck,RM_TIMEOUT_T_STUCK) ;\n\t\tstart_rmt_timer2(smc,smc->s.rmt_t_poll,RM_TIMEOUT_POLL) ;\n\t\tsm_mac_check_beacon_claim(smc) ;\n\t\tDB_RMTN(1, \"RMT : RM4_NON_OP_DUP\");\n\t\tACTIONS_DONE() ;\n\t\tbreak ;\n\tcase RM4_NON_OP_DUP :\n\t\tif (cmd == RM_TIMEOUT_POLL) {\n\t\t\tstart_rmt_timer2(smc,smc->s.rmt_t_poll,RM_TIMEOUT_POLL);\n\t\t\tsm_mac_check_beacon_claim(smc) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\tif (!smc->r.da_flag) {\n\t\t\tGO_STATE(RM1_NON_OP) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if ((cmd == RM_MY_BEACON || cmd == RM_OTHER_BEACON) &&\n\t\t\tsmc->r.bn_flag) {\n\t\t\tsmc->r.bn_flag = FALSE ;\n\t\t}\n\t\t \n\t\telse if (cmd == RM_TRT_EXP && !smc->r.bn_flag) {\n\t\t\tint\ttx ;\n\t\t\t \n\t\t\tif ((tx =  sm_mac_get_tx_state(smc)) == 4 || tx == 5) {\n\t\t\tDB_RMTN(2, \"RMT : NOPDUP && TRT_EXPIRED && T4/T5\");\n\t\t\t\tsmc->r.bn_flag = TRUE ;\n\t\t\t\t \n\t\t\t\tstart_rmt_timer1(smc,smc->s.rmt_t_stuck,\n\t\t\t\t\tRM_TIMEOUT_T_STUCK) ;\n\t\t\t}\n\t\t\t \n\n\t\t\tDB_RMTN(2, \"RMT : sm_mac_get_tx_state() = %d (bn_flag = %d)\",\n\t\t\t\ttx, smc->r.bn_flag);\n\t\t}\n\t\t \n\t\telse if (cmd == RM_TIMEOUT_ANNOUNCE && !smc->r.bn_flag) {\n\t\t\trmt_dup_actions(smc) ;\n\t\t}\n\t\t \n\t\telse if (cmd == RM_RING_OP) {\n\t\t\tsmc->r.no_flag = FALSE ;\n\t\t\tGO_STATE(RM5_RING_OP_DUP) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (cmd == RM_TIMEOUT_T_STUCK &&\n\t\t\tsmc->r.rm_join && smc->r.bn_flag) {\n\t\t\tGO_STATE(RM6_DIRECTED) ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak ;\n\tcase ACTIONS(RM5_RING_OP_DUP) :\n\t\tstop_rmt_timer0(smc) ;\n\t\tstop_rmt_timer1(smc) ;\n\t\tstop_rmt_timer2(smc) ;\n\t\tDB_RMTN(1, \"RMT : RM5_RING_OP_DUP\");\n\t\tACTIONS_DONE() ;\n\t\tbreak;\n\tcase RM5_RING_OP_DUP :\n\t\t \n\t\tif (smc->r.dup_addr_test == DA_PASSED) {\n\t\t\tsmc->r.da_flag = FALSE ;\n\t\t\tGO_STATE(RM2_RING_OP) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (cmd == RM_RING_NON_OP) {\n\t\t\tsmc->r.jm_flag = FALSE ;\n\t\t\tsmc->r.bn_flag = FALSE ;\n\t\t\tGO_STATE(RM4_NON_OP_DUP) ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak ;\n\tcase ACTIONS(RM6_DIRECTED) :\n\t\tstart_rmt_timer0(smc,smc->s.rmt_t_direct,RM_TIMEOUT_T_DIRECT) ;\n\t\tstop_rmt_timer1(smc) ;\n\t\tstart_rmt_timer2(smc,smc->s.rmt_t_poll,RM_TIMEOUT_POLL) ;\n\t\tsm_ma_control(smc,MA_DIRECTED) ;\n\t\tRS_SET(smc,RS_BEACON) ;\n\t\tDB_RMTN(1, \"RMT : RM6_DIRECTED\");\n\t\tACTIONS_DONE() ;\n\t\tbreak ;\n\tcase RM6_DIRECTED :\n\t\t \n\t\tif (cmd == RM_TIMEOUT_POLL) {\n\t\t\tstart_rmt_timer2(smc,smc->s.rmt_t_poll,RM_TIMEOUT_POLL);\n\t\t\tsm_mac_check_beacon_claim(smc) ;\n#ifndef SUPERNET_3\n\t\t\t \n\t\t\trestart_trt_for_dbcn(smc) ;\n#endif  \n\t\t\tbreak ;\n\t\t}\n\t\tif ((cmd == RM_MY_BEACON || cmd == RM_OTHER_BEACON) &&\n\t\t\t!smc->r.da_flag) {\n\t\t\tsmc->r.bn_flag = FALSE ;\n\t\t\tGO_STATE(RM3_DETECT) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if ((cmd == RM_MY_BEACON || cmd == RM_OTHER_BEACON) &&\n\t\t\tsmc->r.da_flag) {\n\t\t\tsmc->r.bn_flag = FALSE ;\n\t\t\tGO_STATE(RM4_NON_OP_DUP) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (cmd == RM_TIMEOUT_T_DIRECT) {\n\t\t\tGO_STATE(RM7_TRACE) ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak ;\n\tcase ACTIONS(RM7_TRACE) :\n\t\tstop_rmt_timer0(smc) ;\n\t\tstop_rmt_timer1(smc) ;\n\t\tstop_rmt_timer2(smc) ;\n\t\tsmc->e.trace_prop |= ENTITY_BIT(ENTITY_MAC) ;\n\t\tqueue_event(smc,EVENT_ECM,EC_TRACE_PROP) ;\n\t\tDB_RMTN(1, \"RMT : RM7_TRACE\");\n\t\tACTIONS_DONE() ;\n\t\tbreak ;\n\tcase RM7_TRACE :\n\t\tbreak ;\n\tdefault:\n\t\tSMT_PANIC(smc,SMT_E0122, SMT_E0122_MSG) ;\n\t\tbreak;\n\t}\n}\n\n \nstatic void rmt_dup_actions(struct s_smc *smc)\n{\n\tif (smc->r.jm_flag) {\n\t}\n\telse {\n\t\tif (smc->s.rmt_dup_mac_behavior) {\n\t\t\tSMT_ERR_LOG(smc,SMT_E0138, SMT_E0138_MSG) ;\n                        rmt_reinsert_actions(smc) ;\n\t\t}\n\t\telse {\n\t\t\tSMT_ERR_LOG(smc,SMT_E0135, SMT_E0135_MSG) ;\n\t\t\trmt_leave_actions(smc) ;\n\t\t}\n\t}\n}\n\n \nstatic void rmt_reinsert_actions(struct s_smc *smc)\n{\n\tqueue_event(smc,EVENT_ECM,EC_DISCONNECT) ;\n\tqueue_event(smc,EVENT_ECM,EC_CONNECT) ;\n}\n\n \nstatic void rmt_new_dup_actions(struct s_smc *smc)\n{\n\tsmc->r.da_flag = TRUE ;\n\tsmc->r.bn_flag = FALSE ;\n\tsmc->r.jm_flag = FALSE ;\n\t \n\tif (smc->s.rmt_dup_mac_behavior) {\n\t\tSMT_ERR_LOG(smc,SMT_E0138, SMT_E0138_MSG) ;\n\t\trmt_reinsert_actions(smc) ;\n\t}\n\telse {\n\t\tSMT_ERR_LOG(smc,SMT_E0135, SMT_E0135_MSG) ;\n\t\trmt_leave_actions(smc) ;\n\t}\n}\n\n\n \nstatic void rmt_leave_actions(struct s_smc *smc)\n{\n\tqueue_event(smc,EVENT_ECM,EC_DISCONNECT) ;\n\t \n}\n\n \nstatic void start_rmt_timer0(struct s_smc *smc, u_long value, int event)\n{\n\tsmc->r.timer0_exp = FALSE ;\t\t \n\tsmt_timer_start(smc,&smc->r.rmt_timer0,value,EV_TOKEN(EVENT_RMT,event));\n}\n\n \nstatic void start_rmt_timer1(struct s_smc *smc, u_long value, int event)\n{\n\tsmc->r.timer1_exp = FALSE ;\t \n\tsmt_timer_start(smc,&smc->r.rmt_timer1,value,EV_TOKEN(EVENT_RMT,event));\n}\n\n \nstatic void start_rmt_timer2(struct s_smc *smc, u_long value, int event)\n{\n\tsmc->r.timer2_exp = FALSE ;\t\t \n\tsmt_timer_start(smc,&smc->r.rmt_timer2,value,EV_TOKEN(EVENT_RMT,event));\n}\n\n \nstatic void stop_rmt_timer0(struct s_smc *smc)\n{\n\tif (smc->r.rmt_timer0.tm_active)\n\t\tsmt_timer_stop(smc,&smc->r.rmt_timer0) ;\n}\n\n \nstatic void stop_rmt_timer1(struct s_smc *smc)\n{\n\tif (smc->r.rmt_timer1.tm_active)\n\t\tsmt_timer_stop(smc,&smc->r.rmt_timer1) ;\n}\n\n \nstatic void stop_rmt_timer2(struct s_smc *smc)\n{\n\tif (smc->r.rmt_timer2.tm_active)\n\t\tsmt_timer_stop(smc,&smc->r.rmt_timer2) ;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}