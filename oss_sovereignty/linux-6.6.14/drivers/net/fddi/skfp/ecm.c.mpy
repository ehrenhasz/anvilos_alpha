{
  "module_name": "ecm.c",
  "hash_id": "6c0b56d48b63403ff9da82e07fc09509b696b8579c1acab7221d2fd4cf5c8786",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/fddi/skfp/ecm.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include \"h/types.h\"\n#include \"h/fddi.h\"\n#include \"h/smc.h\"\n\n#define KERNEL\n#include \"h/smtstate.h\"\n\n \n#define AFLAG\t0x10\n#define GO_STATE(x)\t(smc->mib.fddiSMTECMState = (x)|AFLAG)\n#define ACTIONS_DONE()\t(smc->mib.fddiSMTECMState &= ~AFLAG)\n#define ACTIONS(x)\t(x|AFLAG)\n\n#define EC0_OUT\t\t0\t\t\t \n#define EC1_IN\t\t1\t\t\t \n#define EC2_TRACE\t2\t\t\t \n#define EC3_LEAVE\t3\t\t\t \n#define EC4_PATH_TEST\t4\t\t\t \n#define EC5_INSERT\t5\t\t\t \n#define EC6_CHECK\t6\t\t\t \n#define EC7_DEINSERT\t7\t\t\t \n\n \nstatic const char * const ecm_states[] = {\n\t\"EC0_OUT\",\"EC1_IN\",\"EC2_TRACE\",\"EC3_LEAVE\",\"EC4_PATH_TEST\",\n\t\"EC5_INSERT\",\"EC6_CHECK\",\"EC7_DEINSERT\"\n} ;\n\n \nstatic const char * const ecm_events[] = {\n\t\"NONE\",\"EC_CONNECT\",\"EC_DISCONNECT\",\"EC_TRACE_PROP\",\"EC_PATH_TEST\",\n\t\"EC_TIMEOUT_TD\",\"EC_TIMEOUT_TMAX\",\n\t\"EC_TIMEOUT_IMAX\",\"EC_TIMEOUT_INMAX\",\"EC_TEST_DONE\"\n} ;\n\n \n\n \n\nstatic void ecm_fsm(struct s_smc *smc, int cmd);\nstatic void start_ecm_timer(struct s_smc *smc, u_long value, int event);\nstatic void stop_ecm_timer(struct s_smc *smc);\nstatic void prop_actions(struct s_smc *smc);\n\n \nvoid ecm_init(struct s_smc *smc)\n{\n\tsmc->e.path_test = PT_PASSED ;\n\tsmc->e.trace_prop = 0 ;\n\tsmc->e.sb_flag = 0 ;\n\tsmc->mib.fddiSMTECMState = ACTIONS(EC0_OUT) ;\n\tsmc->e.ecm_line_state = FALSE ;\n}\n\n \nvoid ecm(struct s_smc *smc, int event)\n{\n\tint\tstate ;\n\n\tdo {\n\t\tDB_ECM(\"ECM : state %s%s event %s\",\n\t\t       smc->mib.fddiSMTECMState & AFLAG ? \"ACTIONS \" : \"\",\n\t\t       ecm_states[smc->mib.fddiSMTECMState & ~AFLAG],\n\t\t       ecm_events[event]);\n\t\tstate = smc->mib.fddiSMTECMState ;\n\t\tecm_fsm(smc,event) ;\n\t\tevent = 0 ;\n\t} while (state != smc->mib.fddiSMTECMState) ;\n\tecm_state_change(smc,(int)smc->mib.fddiSMTECMState) ;\n}\n\n \nstatic void ecm_fsm(struct s_smc *smc, int cmd)\n{\n\tint ls_a ;\t\t\t \n\tint ls_b ;\t\t\t \n\tint\tp ;\t\t\t \n\n\n\tsmc->mib.fddiSMTBypassPresent = sm_pm_bypass_present(smc) ;\n\tif (cmd == EC_CONNECT)\n\t\tsmc->mib.fddiSMTRemoteDisconnectFlag = FALSE ;\n\n\t \n\t \n\tif (cmd == EC_DISCONNECT &&\n\t    smc->mib.fddiSMTRemoteDisconnectFlag == TRUE) {\n\t\tAIX_EVENT (smc, (u_long) CIO_HARD_FAIL, (u_long)\n\t\t\tFDDI_REMOTE_DISCONNECT, smt_get_event_word(smc),\n\t\t\tsmt_get_error_word(smc) );\n\t}\n\n\t \n\tif (cmd == EC_CONNECT) {\n\t\tsmc->e.DisconnectFlag = FALSE ;\n\t}\n\telse if (cmd == EC_DISCONNECT) {\n\t\tsmc->e.DisconnectFlag = TRUE ;\n\t}\n\t\n\tswitch(smc->mib.fddiSMTECMState) {\n\tcase ACTIONS(EC0_OUT) :\n\t\t \n\t\tsmc->e.path_test = PT_PASSED ;\n\t\tsmc->e.ecm_line_state = FALSE ;\n\t\tstop_ecm_timer(smc) ;\n\t\tACTIONS_DONE() ;\n\t\tbreak ;\n\tcase EC0_OUT:\n\t\t \n\t\tif (cmd == EC_CONNECT && !smc->mib.fddiSMTBypassPresent\n\t\t\t&& smc->e.path_test==PT_PASSED) {\n\t\t\tGO_STATE(EC1_IN) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (cmd == EC_CONNECT && (smc->e.path_test==PT_PASSED) &&\n\t\t\tsmc->mib.fddiSMTBypassPresent &&\n\t\t\t(smc->s.sas == SMT_DAS)) {\n\t\t\tGO_STATE(EC5_INSERT) ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak;\n\tcase ACTIONS(EC1_IN) :\n\t\tstop_ecm_timer(smc) ;\n\t\tsmc->e.trace_prop = 0 ;\n\t\tsm_ma_control(smc,MA_TREQ) ;\n\t\tfor (p = 0 ; p < NUMPHYS ; p++)\n\t\t\tif (smc->mib.p[p].fddiPORTHardwarePresent)\n\t\t\t\tqueue_event(smc,EVENT_PCMA+p,PC_START) ;\n\t\tACTIONS_DONE() ;\n\t\tbreak ;\n\tcase EC1_IN:\n\t\t \n\t\tif (cmd == EC_TRACE_PROP) {\n\t\t\tprop_actions(smc) ;\n\t\t\tGO_STATE(EC2_TRACE) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (cmd == EC_DISCONNECT) {\n\t\t\tGO_STATE(EC3_LEAVE) ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak;\n\tcase ACTIONS(EC2_TRACE) :\n\t\tstart_ecm_timer(smc,MIB2US(smc->mib.fddiSMTTrace_MaxExpiration),\n\t\t\tEC_TIMEOUT_TMAX) ;\n\t\tACTIONS_DONE() ;\n\t\tbreak ;\n\tcase EC2_TRACE :\n\t\t \n\t\tif (cmd == EC_TRACE_PROP) {\n\t\t\tprop_actions(smc) ;\n\t\t\tGO_STATE(EC2_TRACE) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (cmd == EC_DISCONNECT) {\n\t\t\tsmc->e.path_test = PT_EXITING ;\n\t\t\tGO_STATE(EC3_LEAVE) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (smc->e.path_test == PT_PENDING) {\n\t\t\tGO_STATE(EC3_LEAVE) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (cmd == EC_TIMEOUT_TMAX) {\n\t\t\t \n\t\t\t \n\t\t\tAIX_EVENT(smc, (u_long) FDDI_RING_STATUS,\n\t\t\t\t(u_long) FDDI_SMT_ERROR, (u_long)\n\t\t\t\tFDDI_TRACE_MAX, smt_get_error_word(smc));\n\t\t\tsmc->e.path_test = PT_PENDING ;\n\t\t\tGO_STATE(EC3_LEAVE) ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak ;\n\tcase ACTIONS(EC3_LEAVE) :\n\t\tstart_ecm_timer(smc,smc->s.ecm_td_min,EC_TIMEOUT_TD) ;\n\t\tfor (p = 0 ; p < NUMPHYS ; p++)\n\t\t\tqueue_event(smc,EVENT_PCMA+p,PC_STOP) ;\n\t\tACTIONS_DONE() ;\n\t\tbreak ;\n\tcase EC3_LEAVE:\n\t\t \n\t\tif (cmd == EC_TIMEOUT_TD && !smc->mib.fddiSMTBypassPresent &&\n\t\t\t(smc->e.path_test != PT_PENDING)) {\n\t\t\tGO_STATE(EC0_OUT) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (cmd == EC_TIMEOUT_TD &&\n\t\t\t(smc->e.path_test == PT_PENDING)) {\n\t\t\tGO_STATE(EC4_PATH_TEST) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (cmd == EC_CONNECT && smc->e.path_test == PT_PASSED) {\n\t\t\tGO_STATE(EC1_IN) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (cmd == EC_DISCONNECT &&\n\t\t\tsmc->e.path_test == PT_PENDING) {\n\t\t\tsmc->e.path_test = PT_EXITING ;\n\t\t\t \n\t\t}\n\t\t \n\t\telse if (cmd == EC_TIMEOUT_TD &&\n\t\t\tsmc->mib.fddiSMTBypassPresent &&\n\t\t\tsmc->e.path_test != PT_PENDING) {\n\t\t\tGO_STATE(EC7_DEINSERT) ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak ;\n\tcase ACTIONS(EC4_PATH_TEST) :\n\t\tstop_ecm_timer(smc) ;\n\t\tsmc->e.path_test = PT_TESTING ;\n\t\tstart_ecm_timer(smc,smc->s.ecm_test_done,EC_TEST_DONE) ;\n\t\t \n\t\tACTIONS_DONE() ;\n\t\tbreak ;\n\tcase EC4_PATH_TEST :\n\t\t \n\t\tif (cmd == EC_TEST_DONE)\n\t\t\tsmc->e.path_test = PT_PASSED ;\n\n\t\tif (smc->e.path_test == PT_FAILED)\n\t\t\tRS_SET(smc,RS_PATHTEST) ;\n\n\t\t \n\t\tif (smc->e.path_test == PT_FAILED &&\n\t\t\t!smc->mib.fddiSMTBypassPresent) {\n\t\t\tGO_STATE(EC0_OUT) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (cmd == EC_DISCONNECT &&\n\t\t\t!smc->mib.fddiSMTBypassPresent) {\n\t\t\tGO_STATE(EC0_OUT) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (smc->e.path_test == PT_PASSED) {\n\t\t\tGO_STATE(EC1_IN) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (smc->e.path_test == PT_FAILED &&\n\t\t\tsmc->mib.fddiSMTBypassPresent) {\n\t\t\tGO_STATE(EC7_DEINSERT) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (cmd == EC_DISCONNECT &&\n\t\t\tsmc->mib.fddiSMTBypassPresent) {\n\t\t\tGO_STATE(EC7_DEINSERT) ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak ;\n\tcase ACTIONS(EC5_INSERT) :\n\t\tsm_pm_bypass_req(smc,BP_INSERT);\n\t\tstart_ecm_timer(smc,smc->s.ecm_in_max,EC_TIMEOUT_INMAX) ;\n\t\tACTIONS_DONE() ;\n\t\tbreak ;\n\tcase EC5_INSERT :\n\t\t \n\t\tif (cmd == EC_TIMEOUT_INMAX) {\n\t\t\tGO_STATE(EC6_CHECK) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (cmd == EC_DISCONNECT) {\n\t\t\tGO_STATE(EC7_DEINSERT) ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak ;\n\tcase ACTIONS(EC6_CHECK) :\n\t\t \n\t\tstart_ecm_timer(smc,smc->s.ecm_check_poll,0) ;\n\t\tsmc->e.ecm_line_state = TRUE ;\t \n\t\tACTIONS_DONE() ;\n\t\tbreak ;\n\tcase EC6_CHECK :\n\t\tls_a = sm_pm_get_ls(smc,PA) ;\n\t\tls_b = sm_pm_get_ls(smc,PB) ;\n\n\t\t \n\t\tif (((ls_a == PC_QLS) || (ls_a == PC_HLS)) &&\n\t\t    ((ls_b == PC_QLS) || (ls_b == PC_HLS)) ) {\n\t\t\tsmc->e.sb_flag = FALSE ;\n\t\t\tsmc->e.ecm_line_state = FALSE ;\n\t\t\tGO_STATE(EC1_IN) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (!smc->e.sb_flag &&\n\t\t\t (((ls_a == PC_ILS) && (ls_b == PC_QLS)) ||\n\t\t\t  ((ls_a == PC_QLS) && (ls_b == PC_ILS)))){\n\t\t\tsmc->e.sb_flag = TRUE ;\n\t\t\tDB_ECMN(1, \"ECM : EC6_CHECK - stuck bypass\");\n\t\t\tAIX_EVENT(smc, (u_long) FDDI_RING_STATUS, (u_long)\n\t\t\t\tFDDI_SMT_ERROR, (u_long) FDDI_BYPASS_STUCK,\n\t\t\t\tsmt_get_error_word(smc));\n\t\t}\n\t\t \n\t\telse if (cmd == EC_DISCONNECT) {\n\t\t\tsmc->e.ecm_line_state = FALSE ;\n\t\t\tGO_STATE(EC7_DEINSERT) ;\n\t\t\tbreak ;\n\t\t}\n\t\telse {\n\t\t\t \n\t\t\tstart_ecm_timer(smc,smc->s.ecm_check_poll,0) ;\n\t\t}\n\t\tbreak ;\n\tcase ACTIONS(EC7_DEINSERT) :\n\t\tsm_pm_bypass_req(smc,BP_DEINSERT);\n\t\tstart_ecm_timer(smc,smc->s.ecm_i_max,EC_TIMEOUT_IMAX) ;\n\t\tACTIONS_DONE() ;\n\t\tbreak ;\n\tcase EC7_DEINSERT:\n\t\t \n\t\tif (cmd == EC_TIMEOUT_IMAX) {\n\t\t\tGO_STATE(EC0_OUT) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\telse if (cmd == EC_CONNECT && smc->e.path_test == PT_PASSED) {\n\t\t\tGO_STATE(EC5_INSERT) ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tSMT_PANIC(smc,SMT_E0107, SMT_E0107_MSG) ;\n\t\tbreak;\n\t}\n}\n\n#ifndef\tCONCENTRATOR\n \nstatic void prop_actions(struct s_smc *smc)\n{\n\tint\tport_in = 0 ;\n\tint\tport_out = 0 ;\n\n\tRS_SET(smc,RS_EVENT) ;\n\tswitch (smc->s.sas) {\n\tcase SMT_SAS :\n\t\tport_in = port_out = pcm_get_s_port(smc) ;\n\t\tbreak ;\n\tcase SMT_DAS :\n\t\tport_in = cfm_get_mac_input(smc) ;\t \n\t\tport_out = cfm_get_mac_output(smc) ;\t \n\t\tbreak ;\n\tcase SMT_NAC :\n\t\tSMT_PANIC(smc,SMT_E0108, SMT_E0108_MSG) ;\n\t\treturn ;\n\t}\n\n\tDB_ECM(\"ECM : prop_actions - trace_prop %lu\", smc->e.trace_prop);\n\tDB_ECM(\"ECM : prop_actions - in %d out %d\", port_in, port_out);\n\n\tif (smc->e.trace_prop & ENTITY_BIT(ENTITY_MAC)) {\n\t\t \n\t\tDB_ECM(\"ECM : initiate TRACE on PHY %c\", 'A' + port_in - PA);\n\t\tqueue_event(smc,EVENT_PCM+port_in,PC_TRACE) ;\n\t}\n\telse if ((smc->e.trace_prop & ENTITY_BIT(ENTITY_PHY(PA))) &&\n\t\tport_out != PA) {\n\t\t \n\t\tDB_ECM(\"ECM : propagate TRACE on PHY B\");\n\t\tqueue_event(smc,EVENT_PCMB,PC_TRACE) ;\n\t}\n\telse if ((smc->e.trace_prop & ENTITY_BIT(ENTITY_PHY(PB))) &&\n\t\tport_out != PB) {\n\t\t \n\t\tDB_ECM(\"ECM : propagate TRACE on PHY A\");\n\t\tqueue_event(smc,EVENT_PCMA,PC_TRACE) ;\n\t}\n\telse {\n\t\t \n\t\tDB_ECM(\"ECM : TRACE terminated\");\n\t\tsmc->e.path_test = PT_PENDING ;\n\t}\n\tsmc->e.trace_prop = 0 ;\n}\n#else\n \nstatic void prop_actions(struct s_smc *smc)\n{\n\tint\tinitiator ;\n\tint\tupstream ;\n\tint\tp ;\n\n\tRS_SET(smc,RS_EVENT) ;\n\twhile (smc->e.trace_prop) {\n\t\tDB_ECM(\"ECM : prop_actions - trace_prop %d\",\n\t\t       smc->e.trace_prop);\n\n\t\tif (smc->e.trace_prop & ENTITY_BIT(ENTITY_MAC)) {\n\t\t\tinitiator = ENTITY_MAC ;\n\t\t\tsmc->e.trace_prop &= ~ENTITY_BIT(ENTITY_MAC) ;\n\t\t\tDB_ECM(\"ECM: MAC initiates trace\");\n\t\t}\n\t\telse {\n\t\t\tfor (p = NUMPHYS-1 ; p >= 0 ; p--) {\n\t\t\t\tif (smc->e.trace_prop &\n\t\t\t\t\tENTITY_BIT(ENTITY_PHY(p)))\n\t\t\t\t\tbreak ;\n\t\t\t}\n\t\t\tinitiator = ENTITY_PHY(p) ;\n\t\t\tsmc->e.trace_prop &= ~ENTITY_BIT(ENTITY_PHY(p)) ;\n\t\t}\n\t\tupstream = cem_get_upstream(smc,initiator) ;\n\n\t\tif (upstream == ENTITY_MAC) {\n\t\t\t \n\t\t\tDB_ECM(\"ECM : TRACE terminated\");\n\t\t\tsmc->e.path_test = PT_PENDING ;\n\t\t}\n\t\telse {\n\t\t\t \n\t\t\tDB_ECM(\"ECM : propagate TRACE on PHY %d\", upstream);\n\t\t\tqueue_event(smc,EVENT_PCM+upstream,PC_TRACE) ;\n\t\t}\n\t}\n}\n#endif\n\n\n \nstatic void start_ecm_timer(struct s_smc *smc, u_long value, int event)\n{\n\tsmt_timer_start(smc,&smc->e.ecm_timer,value,EV_TOKEN(EVENT_ECM,event));\n}\n\n \nstatic void stop_ecm_timer(struct s_smc *smc)\n{\n\tif (smc->e.ecm_timer.tm_active)\n\t\tsmt_timer_stop(smc,&smc->e.ecm_timer) ;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}