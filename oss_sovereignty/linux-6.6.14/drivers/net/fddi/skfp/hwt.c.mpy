{
  "module_name": "hwt.c",
  "hash_id": "5bea47b66befb8a6937fa12476658ec6a7680bcbf04a81d556981d746dd8d5a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/fddi/skfp/hwt.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include \"h/types.h\"\n#include \"h/fddi.h\"\n#include \"h/smc.h\"\n\n \n \n \n\n \n#define\tHWT_MAX\t(65000)\n\nvoid hwt_start(struct s_smc *smc, u_long time)\n{\n\tu_short\tcnt ;\n\n\tif (time > HWT_MAX)\n\t\ttime = HWT_MAX ;\n\n\tsmc->hw.t_start = time ;\n\tsmc->hw.t_stop = 0L ;\n\n\tcnt = (u_short)time ;\n\t \n\tif (!cnt)\n\t\tcnt++ ;\n\n\toutpd(ADDR(B2_TI_INI), (u_long) cnt * 200) ;\t \n\toutpw(ADDR(B2_TI_CRTL), TIM_START) ;\t\t \n\n\tsmc->hw.timer_activ = TRUE ;\n}\n\n \nvoid hwt_stop(struct s_smc *smc)\n{\n\toutpw(ADDR(B2_TI_CRTL), TIM_STOP) ;\n\toutpw(ADDR(B2_TI_CRTL), TIM_CL_IRQ) ;\n\n\tsmc->hw.timer_activ = FALSE ;\n}\n\n \nvoid hwt_init(struct s_smc *smc)\n{\n\tsmc->hw.t_start = 0 ;\n\tsmc->hw.t_stop\t= 0 ;\n\tsmc->hw.timer_activ = FALSE ;\n\n\thwt_restart(smc) ;\n}\n\n \nvoid hwt_restart(struct s_smc *smc)\n{\n\thwt_stop(smc) ;\n}\n\n \nu_long hwt_read(struct s_smc *smc)\n{\n\tu_short\ttr ;\n\tu_long\tis ;\n\n\tif (smc->hw.timer_activ) {\n\t\thwt_stop(smc) ;\n\t\ttr = (u_short)((inpd(ADDR(B2_TI_VAL))/200) & 0xffff) ;\n\n\t\tis = GET_ISR() ;\n\t\t \n\t\tif ((tr > smc->hw.t_start) || (is & IS_TIMINT)) {\n\t\t\thwt_restart(smc) ;\n\t\t\tsmc->hw.t_stop = smc->hw.t_start ;\n\t\t}\n\t\telse\n\t\t\tsmc->hw.t_stop = smc->hw.t_start - tr ;\n\t}\n\treturn smc->hw.t_stop;\n}\n\n#ifdef\tPCI\n \nu_long hwt_quick_read(struct s_smc *smc)\n{\n\tu_long interval ;\n\tu_long time ;\n\n\tinterval = inpd(ADDR(B2_TI_INI)) ;\n\toutpw(ADDR(B2_TI_CRTL), TIM_STOP) ;\n\ttime = inpd(ADDR(B2_TI_VAL)) ;\n\toutpd(ADDR(B2_TI_INI),time) ;\n\toutpw(ADDR(B2_TI_CRTL), TIM_START) ;\n\toutpd(ADDR(B2_TI_INI),interval) ;\n\n\treturn time;\n}\n\n \nvoid hwt_wait_time(struct s_smc *smc, u_long start, long int duration)\n{\n\tlong\tdiff ;\n\tlong\tinterval ;\n\tint\twrapped ;\n\n\t \n\tif (smc->hw.timer_activ == FALSE ||\n\t\thwt_quick_read(smc) == hwt_quick_read(smc)) {\n\t\treturn ;\n\t}\n\n\tinterval = inpd(ADDR(B2_TI_INI)) ;\n\tif (interval > duration) {\n\t\tdo {\n\t\t\tdiff = (long)(start - hwt_quick_read(smc)) ;\n\t\t\tif (diff < 0) {\n\t\t\t\tdiff += interval ;\n\t\t\t}\n\t\t} while (diff <= duration) ;\n\t}\n\telse {\n\t\tdiff = interval ;\n\t\twrapped = 0 ;\n\t\tdo {\n\t\t\tif (!wrapped) {\n\t\t\t\tif (hwt_quick_read(smc) >= start) {\n\t\t\t\t\tdiff += interval ;\n\t\t\t\t\twrapped = 1 ;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (hwt_quick_read(smc) < start) {\n\t\t\t\t\twrapped = 0 ;\n\t\t\t\t}\n\t\t\t}\n\t\t} while (diff <= duration) ;\n\t}\n}\n#endif\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}