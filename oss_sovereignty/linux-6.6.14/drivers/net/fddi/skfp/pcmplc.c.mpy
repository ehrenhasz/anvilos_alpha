{
  "module_name": "pcmplc.c",
  "hash_id": "79a7abfc97814e53ad2a5eb599e270701fb0a428a724c5b88681a1dab8a24b7d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/fddi/skfp/pcmplc.c",
  "human_readable_source": "\n \n\n \n\n \n\n\n#include \"h/types.h\"\n#include \"h/fddi.h\"\n#include \"h/smc.h\"\n#include \"h/supern_2.h\"\n#define KERNEL\n#include \"h/smtstate.h\"\n\n#ifdef\tFDDI_MIB\nextern int snmp_fddi_trap(\n#ifdef\tANSIC\nstruct s_smc\t* smc, int  type, int  index\n#endif\n);\n#endif\n#ifdef\tCONCENTRATOR\nextern int plc_is_installed(\n#ifdef\tANSIC\nstruct s_smc *smc ,\nint p\n#endif\n) ;\n#endif\n \n#define AFLAG\t\t(0x20)\n#define GO_STATE(x)\t(mib->fddiPORTPCMState = (x)|AFLAG)\n#define ACTIONS_DONE()\t(mib->fddiPORTPCMState &= ~AFLAG)\n#define ACTIONS(x)\t(x|AFLAG)\n\n \n#define PC0_OFF\t\t\t0\n#define PC1_BREAK\t\t1\n#define PC2_TRACE\t\t2\n#define PC3_CONNECT\t\t3\n#define PC4_NEXT\t\t4\n#define PC5_SIGNAL\t\t5\n#define PC6_JOIN\t\t6\n#define PC7_VERIFY\t\t7\n#define PC8_ACTIVE\t\t8\n#define PC9_MAINT\t\t9\n\n \nstatic const char * const pcm_states[] =  {\n\t\"PC0_OFF\",\"PC1_BREAK\",\"PC2_TRACE\",\"PC3_CONNECT\",\"PC4_NEXT\",\n\t\"PC5_SIGNAL\",\"PC6_JOIN\",\"PC7_VERIFY\",\"PC8_ACTIVE\",\"PC9_MAINT\"\n} ;\n\n \nstatic const char * const pcm_events[] = {\n\t\"NONE\",\"PC_START\",\"PC_STOP\",\"PC_LOOP\",\"PC_JOIN\",\"PC_SIGNAL\",\n\t\"PC_REJECT\",\"PC_MAINT\",\"PC_TRACE\",\"PC_PDR\",\n\t\"PC_ENABLE\",\"PC_DISABLE\",\n\t\"PC_QLS\",\"PC_ILS\",\"PC_MLS\",\"PC_HLS\",\"PC_LS_PDR\",\"PC_LS_NONE\",\n\t\"PC_TIMEOUT_TB_MAX\",\"PC_TIMEOUT_TB_MIN\",\n\t\"PC_TIMEOUT_C_MIN\",\"PC_TIMEOUT_T_OUT\",\n\t\"PC_TIMEOUT_TL_MIN\",\"PC_TIMEOUT_T_NEXT\",\"PC_TIMEOUT_LCT\",\n\t\"PC_NSE\",\"PC_LEM\"\n} ;\n\n#ifdef\tMOT_ELM\n \n#define PLCS_CONTROL_C_U\t0\n#define PLCS_CONTROL_C_S\t(PL_C_SDOFF_ENABLE | PL_C_SDON_ENABLE | \\\n\t\t\t\t PL_C_CIPHER_ENABLE)\n#define\tPLCS_FASSERT_U\t\t0\n#define\tPLCS_FASSERT_S\t\t0xFd76\t \n#define\tPLCS_FDEASSERT_U\t0\n#define\tPLCS_FDEASSERT_S\t0\n#else\t \n \nstatic const u_char plcs_control_c_u[17] = \"PLC_CNTRL_C_U=\\0\\0\" ;\nstatic const u_char plcs_control_c_s[17] = \"PLC_CNTRL_C_S=\\01\\02\" ;\n\n#define PLCS_CONTROL_C_U (plcs_control_c_u[14] | (plcs_control_c_u[15]<<8))\n#define PLCS_CONTROL_C_S (plcs_control_c_s[14] | (plcs_control_c_s[15]<<8))\n#endif\t \n\n \n \n\n#define PS_OFF\t\t0\n#define PS_BIT3\t\t1\n#define PS_BIT4\t\t2\n#define PS_BIT7\t\t3\n#define PS_LCT\t\t4\n#define PS_BIT8\t\t5\n#define PS_JOIN\t\t6\n#define PS_ACTIVE\t7\n\n#define LCT_LEM_MAX\t255\n\n \n\n#define PLC_MS(m)\t((int)((0x10000L-(m*100000L/2048))))\n#define SLOW_TL_MIN\tPLC_MS(6)\n#define SLOW_C_MIN\tPLC_MS(10)\n\nstatic\tconst struct plt {\n\tint\ttimer ;\t\t\t \n\tint\tpara ;\t\t\t \n} pltm[] = {\n\t{ PL_C_MIN, SLOW_C_MIN },\t \n\t{ PL_TL_MIN, SLOW_TL_MIN },\t \n\t{ PL_TB_MIN, TP_TB_MIN },\t \n\t{ PL_T_OUT, TP_T_OUT },\t\t \n\t{ PL_LC_LENGTH, TP_LC_LENGTH },\t \n\t{ PL_T_SCRUB, TP_T_SCRUB },\t \n\t{ PL_NS_MAX, TP_NS_MAX },\t \n\t{ 0,0 }\n} ;\n\n \n#ifdef\tSUPERNET_3\n \nstatic const int plc_imsk_na = PL_PCM_CODE | PL_TRACE_PROP | PL_PCM_BREAK |\n\t\t\tPL_PCM_ENABLED | PL_SELF_TEST | PL_EBUF_ERR;\n#else\t \n \nstatic int plc_imsk_na = PL_PCM_CODE | PL_TRACE_PROP | PL_PCM_BREAK |\n\t\t\tPL_PCM_ENABLED | PL_SELF_TEST ;\n#endif\t \nstatic const int plc_imsk_act = PL_PCM_CODE | PL_TRACE_PROP | PL_PCM_BREAK |\n\t\t\tPL_PCM_ENABLED | PL_SELF_TEST | PL_EBUF_ERR;\n\n \nstatic void pcm_fsm(struct s_smc *smc, struct s_phy *phy, int cmd);\nstatic void pc_rcode_actions(struct s_smc *smc, int bit, struct s_phy *phy);\nstatic void pc_tcode_actions(struct s_smc *smc, const int bit, struct s_phy *phy);\nstatic void reset_lem_struct(struct s_phy *phy);\nstatic void plc_init(struct s_smc *smc, int p);\nstatic void sm_ph_lem_start(struct s_smc *smc, int np, int threshold);\nstatic void sm_ph_lem_stop(struct s_smc *smc, int np);\nstatic void sm_ph_linestate(struct s_smc *smc, int phy, int ls);\nstatic void real_init_plc(struct s_smc *smc);\n\n \nstatic void start_pcm_timer0(struct s_smc *smc, u_long value, int event,\n\t\t\t     struct s_phy *phy)\n{\n\tphy->timer0_exp = FALSE ;        \n\tsmt_timer_start(smc,&phy->pcm_timer0,value,\n\t\tEV_TOKEN(EVENT_PCM+phy->np,event)) ;\n}\n \nstatic void stop_pcm_timer0(struct s_smc *smc, struct s_phy *phy)\n{\n\tif (phy->pcm_timer0.tm_active)\n\t\tsmt_timer_stop(smc,&phy->pcm_timer0) ;\n}\n\n \nvoid pcm_init(struct s_smc *smc)\n{\n\tint\t\ti ;\n\tint\t\tnp ;\n\tstruct s_phy\t*phy ;\n\tstruct fddi_mib_p\t*mib ;\n\n\tfor (np = 0,phy = smc->y ; np < NUMPHYS ; np++,phy++) {\n\t\t \n\t\tmib = phy->mib ;\n\t\tmib->fddiPORTPCMState = ACTIONS(PC0_OFF) ;\n\t\tphy->np = np ;\n\t\tswitch (smc->s.sas) {\n#ifdef\tCONCENTRATOR\n\t\tcase SMT_SAS :\n\t\t\tmib->fddiPORTMy_Type = (np == PS) ? TS : TM ;\n\t\t\tbreak ;\n\t\tcase SMT_DAS :\n\t\t\tmib->fddiPORTMy_Type = (np == PA) ? TA :\n\t\t\t\t\t(np == PB) ? TB : TM ;\n\t\t\tbreak ;\n\t\tcase SMT_NAC :\n\t\t\tmib->fddiPORTMy_Type = TM ;\n\t\t\tbreak;\n#else\n\t\tcase SMT_SAS :\n\t\t\tmib->fddiPORTMy_Type = (np == PS) ? TS : TNONE ;\n\t\t\tmib->fddiPORTHardwarePresent = (np == PS) ? TRUE :\n\t\t\t\t\tFALSE ;\n#ifndef\tSUPERNET_3\n\t\t\tsmc->y[PA].mib->fddiPORTPCMState = PC0_OFF ;\n#else\n\t\t\tsmc->y[PB].mib->fddiPORTPCMState = PC0_OFF ;\n#endif\n\t\t\tbreak ;\n\t\tcase SMT_DAS :\n\t\t\tmib->fddiPORTMy_Type = (np == PB) ? TB : TA ;\n\t\t\tbreak ;\n#endif\n\t\t}\n\t\t \n\t\tphy->pmd_scramble = 0 ;\n\t\tswitch (phy->pmd_type[PMD_SK_PMD]) {\n\t\tcase 'P' :\n\t\t\tmib->fddiPORTPMDClass = MIB_PMDCLASS_MULTI ;\n\t\t\tbreak ;\n\t\tcase 'L' :\n\t\t\tmib->fddiPORTPMDClass = MIB_PMDCLASS_LCF ;\n\t\t\tbreak ;\n\t\tcase 'D' :\n\t\t\tmib->fddiPORTPMDClass = MIB_PMDCLASS_TP ;\n\t\t\tbreak ;\n\t\tcase 'S' :\n\t\t\tmib->fddiPORTPMDClass = MIB_PMDCLASS_TP ;\n\t\t\tphy->pmd_scramble = TRUE ;\n\t\t\tbreak ;\n\t\tcase 'U' :\n\t\t\tmib->fddiPORTPMDClass = MIB_PMDCLASS_TP ;\n\t\t\tphy->pmd_scramble = TRUE ;\n\t\t\tbreak ;\n\t\tcase '1' :\n\t\t\tmib->fddiPORTPMDClass = MIB_PMDCLASS_SINGLE1 ;\n\t\t\tbreak ;\n\t\tcase '2' :\n\t\t\tmib->fddiPORTPMDClass = MIB_PMDCLASS_SINGLE2 ;\n\t\t\tbreak ;\n\t\tcase '3' :\n\t\t\tmib->fddiPORTPMDClass = MIB_PMDCLASS_SINGLE2 ;\n\t\t\tbreak ;\n\t\tcase '4' :\n\t\t\tmib->fddiPORTPMDClass = MIB_PMDCLASS_SINGLE1 ;\n\t\t\tbreak ;\n\t\tcase 'H' :\n\t\t\tmib->fddiPORTPMDClass = MIB_PMDCLASS_UNKNOWN ;\n\t\t\tbreak ;\n\t\tcase 'I' :\n\t\t\tmib->fddiPORTPMDClass = MIB_PMDCLASS_TP ;\n\t\t\tbreak ;\n\t\tcase 'G' :\n\t\t\tmib->fddiPORTPMDClass = MIB_PMDCLASS_TP ;\n\t\t\tbreak ;\n\t\tdefault:\n\t\t\tmib->fddiPORTPMDClass = MIB_PMDCLASS_UNKNOWN ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\t\tswitch (mib->fddiPORTMy_Type) {\n\t\tcase TA :\n\t\t\tmib->fddiPORTAvailablePaths |= MIB_PATH_S ;\n\t\t\tmib->fddiPORTRequestedPaths[1] = MIB_P_PATH_LOCAL ;\n\t\t\tmib->fddiPORTRequestedPaths[2] =\n\t\t\t\tMIB_P_PATH_LOCAL |\n\t\t\t\tMIB_P_PATH_CON_ALTER |\n\t\t\t\tMIB_P_PATH_SEC_PREFER ;\n\t\t\tmib->fddiPORTRequestedPaths[3] =\n\t\t\t\tMIB_P_PATH_LOCAL |\n\t\t\t\tMIB_P_PATH_CON_ALTER |\n\t\t\t\tMIB_P_PATH_SEC_PREFER |\n\t\t\t\tMIB_P_PATH_THRU ;\n\t\t\tbreak ;\n\t\tcase TB :\n\t\t\tmib->fddiPORTAvailablePaths |= MIB_PATH_S ;\n\t\t\tmib->fddiPORTRequestedPaths[1] = MIB_P_PATH_LOCAL ;\n\t\t\tmib->fddiPORTRequestedPaths[2] =\n\t\t\t\tMIB_P_PATH_LOCAL |\n\t\t\t\tMIB_P_PATH_PRIM_PREFER ;\n\t\t\tmib->fddiPORTRequestedPaths[3] =\n\t\t\t\tMIB_P_PATH_LOCAL |\n\t\t\t\tMIB_P_PATH_PRIM_PREFER |\n\t\t\t\tMIB_P_PATH_CON_PREFER |\n\t\t\t\tMIB_P_PATH_THRU ;\n\t\t\tbreak ;\n\t\tcase TS :\n\t\t\tmib->fddiPORTAvailablePaths |= MIB_PATH_S ;\n\t\t\tmib->fddiPORTRequestedPaths[1] = MIB_P_PATH_LOCAL ;\n\t\t\tmib->fddiPORTRequestedPaths[2] =\n\t\t\t\tMIB_P_PATH_LOCAL |\n\t\t\t\tMIB_P_PATH_CON_ALTER |\n\t\t\t\tMIB_P_PATH_PRIM_PREFER ;\n\t\t\tmib->fddiPORTRequestedPaths[3] =\n\t\t\t\tMIB_P_PATH_LOCAL |\n\t\t\t\tMIB_P_PATH_CON_ALTER |\n\t\t\t\tMIB_P_PATH_PRIM_PREFER ;\n\t\t\tbreak ;\n\t\tcase TM :\n\t\t\tmib->fddiPORTRequestedPaths[1] = MIB_P_PATH_LOCAL ;\n\t\t\tmib->fddiPORTRequestedPaths[2] =\n\t\t\t\tMIB_P_PATH_LOCAL |\n\t\t\t\tMIB_P_PATH_SEC_ALTER |\n\t\t\t\tMIB_P_PATH_PRIM_ALTER ;\n\t\t\tmib->fddiPORTRequestedPaths[3] = 0 ;\n\t\t\tbreak ;\n\t\t}\n\n\t\tphy->pc_lem_fail = FALSE ;\n\t\tmib->fddiPORTPCMStateX = mib->fddiPORTPCMState ;\n\t\tmib->fddiPORTLCTFail_Ct = 0 ;\n\t\tmib->fddiPORTBS_Flag = 0 ;\n\t\tmib->fddiPORTCurrentPath = MIB_PATH_ISOLATED ;\n\t\tmib->fddiPORTNeighborType = TNONE ;\n\t\tphy->ls_flag = 0 ;\n\t\tphy->rc_flag = 0 ;\n\t\tphy->tc_flag = 0 ;\n\t\tphy->td_flag = 0 ;\n\t\tif (np >= PM)\n\t\t\tphy->phy_name = '0' + np - PM ;\n\t\telse\n\t\t\tphy->phy_name = 'A' + np ;\n\t\tphy->wc_flag = FALSE ;\t\t \n\t\tmemset((char *)&phy->lem,0,sizeof(struct lem_counter)) ;\n\t\treset_lem_struct(phy) ;\n\t\tmemset((char *)&phy->plc,0,sizeof(struct s_plc)) ;\n\t\tphy->plc.p_state = PS_OFF ;\n\t\tfor (i = 0 ; i < NUMBITS ; i++) {\n\t\t\tphy->t_next[i] = 0 ;\n\t\t}\n\t}\n\treal_init_plc(smc) ;\n}\n\nvoid init_plc(struct s_smc *smc)\n{\n\tSK_UNUSED(smc) ;\n\n\t \n}\n\nstatic void real_init_plc(struct s_smc *smc)\n{\n\tint\tp ;\n\n\tfor (p = 0 ; p < NUMPHYS ; p++)\n\t\tplc_init(smc,p) ;\n}\n\nstatic void plc_init(struct s_smc *smc, int p)\n{\n\tint\ti ;\n#ifndef\tMOT_ELM\n\tint\trev ;\t \n#endif\t \n\n\t \n\toutpw(PLC(p,PL_CNTRL_B),0) ;\n\toutpw(PLC(p,PL_CNTRL_B),PL_PCM_STOP) ;\n\toutpw(PLC(p,PL_CNTRL_A),0) ;\n\n\t \n#ifndef\tMOT_ELM\n\trev = inpw(PLC(p,PL_STATUS_A)) & PLC_REV_MASK ;\n\tif (rev != PLC_REVISION_A)\n#endif\t \n\t{\n\t\tif (smc->y[p].pmd_scramble) {\n\t\t\toutpw(PLC(p,PL_CNTRL_C),PLCS_CONTROL_C_S) ;\n#ifdef\tMOT_ELM\n\t\t\toutpw(PLC(p,PL_T_FOT_ASS),PLCS_FASSERT_S) ;\n\t\t\toutpw(PLC(p,PL_T_FOT_DEASS),PLCS_FDEASSERT_S) ;\n#endif\t \n\t\t}\n\t\telse {\n\t\t\toutpw(PLC(p,PL_CNTRL_C),PLCS_CONTROL_C_U) ;\n#ifdef\tMOT_ELM\n\t\t\toutpw(PLC(p,PL_T_FOT_ASS),PLCS_FASSERT_U) ;\n\t\t\toutpw(PLC(p,PL_T_FOT_DEASS),PLCS_FDEASSERT_U) ;\n#endif\t \n\t\t}\n\t}\n\n\t \n\tfor ( i = 0 ; pltm[i].timer; i++)\t \n\t\toutpw(PLC(p,pltm[i].timer),pltm[i].para) ;\n\n\t(void)inpw(PLC(p,PL_INTR_EVENT)) ;\t \n\tplc_clear_irq(smc,p) ;\n\toutpw(PLC(p,PL_INTR_MASK),plc_imsk_na);  \n\n\t \n#ifndef\tCONCENTRATOR\n\tif ((smc->s.sas == SMT_SAS) && (p == PS)) {\n\t\toutpw(PLC(p,PL_CNTRL_B),PL_CLASS_S) ;\n\t}\n#endif\n}\n\n \nstatic void plc_go_state(struct s_smc *smc, int p, int state)\n{\n\tHW_PTR port ;\n\tint val ;\n\n\tSK_UNUSED(smc) ;\n\n\tport = (HW_PTR) (PLC(p,PL_CNTRL_B)) ;\n\tval = inpw(port) & ~(PL_PCM_CNTRL | PL_MAINT) ;\n\toutpw(port,val) ;\n\toutpw(port,val | state) ;\n}\n\n \nint sm_pm_get_ls(struct s_smc *smc, int phy)\n{\n\tint\tstate ;\n\n#ifdef\tCONCENTRATOR\n\tif (!plc_is_installed(smc,phy))\n\t\treturn PC_QLS;\n#endif\n\n\tstate = inpw(PLC(phy,PL_STATUS_A)) & PL_LINE_ST ;\n\tswitch(state) {\n\tcase PL_L_QLS:\n\t\tstate = PC_QLS ;\n\t\tbreak ;\n\tcase PL_L_MLS:\n\t\tstate = PC_MLS ;\n\t\tbreak ;\n\tcase PL_L_HLS:\n\t\tstate = PC_HLS ;\n\t\tbreak ;\n\tcase PL_L_ILS4:\n\tcase PL_L_ILS16:\n\t\tstate = PC_ILS ;\n\t\tbreak ;\n\tcase PL_L_ALS:\n\t\tstate = PC_LS_PDR ;\n\t\tbreak ;\n\tdefault :\n\t\tstate = PC_LS_NONE ;\n\t}\n\treturn state;\n}\n\nstatic int plc_send_bits(struct s_smc *smc, struct s_phy *phy, int len)\n{\n\tint np = phy->np ;\t\t \n\tint\tn ;\n\tint\ti ;\n\n\tSK_UNUSED(smc) ;\n\n\t \n\tfor (i = len-1,n = 0 ; i >= 0 ; i--) {\n\t\tn = (n<<1) | phy->t_val[phy->bitn+i] ;\n\t}\n\tif (inpw(PLC(np,PL_STATUS_B)) & PL_PCM_SIGNAL) {\n#if\t0\n\t\tprintf(\"PL_PCM_SIGNAL is set\\n\") ;\n#endif\n\t\treturn 1;\n\t}\n\t \n\toutpw(PLC(np,PL_VECTOR_LEN),len-1) ;\t \n\toutpw(PLC(np,PL_XMIT_VECTOR),n) ;\n#ifdef\tDEBUG\n#if 1\n#ifdef\tDEBUG_BRD\n\tif (smc->debug.d_plc & 0x80)\n#else\n\tif (debug.d_plc & 0x80)\n#endif\n\t\tprintf(\"SIGNALING bit %d .. %d\\n\",phy->bitn,phy->bitn+len-1) ;\n#endif\n#endif\n\treturn 0;\n}\n\n \nvoid plc_config_mux(struct s_smc *smc, int mux)\n{\n\tif (smc->s.sas != SMT_DAS)\n\t\treturn ;\n\tif (mux == MUX_WRAPB) {\n\t\tSETMASK(PLC(PA,PL_CNTRL_B),PL_CONFIG_CNTRL,PL_CONFIG_CNTRL) ;\n\t\tSETMASK(PLC(PA,PL_CNTRL_A),PL_SC_REM_LOOP,PL_SC_REM_LOOP) ;\n\t}\n\telse {\n\t\tCLEAR(PLC(PA,PL_CNTRL_B),PL_CONFIG_CNTRL) ;\n\t\tCLEAR(PLC(PA,PL_CNTRL_A),PL_SC_REM_LOOP) ;\n\t}\n\tCLEAR(PLC(PB,PL_CNTRL_B),PL_CONFIG_CNTRL) ;\n\tCLEAR(PLC(PB,PL_CNTRL_A),PL_SC_REM_LOOP) ;\n}\n\n \nvoid pcm(struct s_smc *smc, const int np, int event)\n{\n\tint\tstate ;\n\tint\toldstate ;\n\tstruct s_phy\t*phy ;\n\tstruct fddi_mib_p\t*mib ;\n\n#ifndef\tCONCENTRATOR\n\t \n\tif ((np != PS) && (smc->s.sas == SMT_SAS))\n\t\treturn ;\n#endif\n\tphy = &smc->y[np] ;\n\tmib = phy->mib ;\n\toldstate = mib->fddiPORTPCMState ;\n\tdo {\n\t\tDB_PCM(\"PCM %c: state %s%s, event %s\",\n\t\t       phy->phy_name,\n\t\t       mib->fddiPORTPCMState & AFLAG ? \"ACTIONS \" : \"\",\n\t\t       pcm_states[mib->fddiPORTPCMState & ~AFLAG],\n\t\t       pcm_events[event]);\n\t\tstate = mib->fddiPORTPCMState ;\n\t\tpcm_fsm(smc,phy,event) ;\n\t\tevent = 0 ;\n\t} while (state != mib->fddiPORTPCMState) ;\n\t \n\tif (state == PC5_SIGNAL)\n\t\tmib->fddiPORTPCMStateX = PC3_CONNECT ;\n\telse\n\t\tmib->fddiPORTPCMStateX = state ;\n\n#ifndef\tSLIM_SMT\n\t \n\tif (\tmib->fddiPORTPCMState != oldstate &&\n\t\t((oldstate == PC8_ACTIVE) || (mib->fddiPORTPCMState == PC8_ACTIVE))) {\n\t\tsmt_srf_event(smc,SMT_EVENT_PORT_PATH_CHANGE,\n\t\t\t(int) (INDEX_PORT+ phy->np),0) ;\n\t}\n#endif\n\n#ifdef FDDI_MIB\n\t \n\n\tif ( mib->fddiPORTPCMState != oldstate ) {\n\t\t \n\t\tDB_SNMP (\"PCM from %d to %d\\n\", oldstate, mib->fddiPORTPCMState);\n\t\tif ( mib->fddiPORTPCMState == PC0_OFF ) {\n\t\t\t \n\t\t\tsnmp_fddi_trap (smc, 1, (int) mib->fddiPORTIndex );\n\t\t} else if ( oldstate == PC0_OFF ) {\n\t\t\t \n\t\t\tsnmp_fddi_trap (smc, 2, (int) mib->fddiPORTIndex );\n\t\t} else if ( mib->fddiPORTPCMState != PC2_TRACE &&\n\t\t\toldstate == PC8_ACTIVE ) {\n\t\t\t \n\t\t\tsnmp_fddi_trap (smc, 3, (int) mib->fddiPORTIndex );\n\t\t} else if ( mib->fddiPORTPCMState == PC8_ACTIVE ) {\n\t\t\t \n\t\t\tsnmp_fddi_trap (smc, 4, (int) mib->fddiPORTIndex );\n\t\t}\n\t}\n#endif\n\n\tpcm_state_change(smc,np,state) ;\n}\n\n \nstatic void pcm_fsm(struct s_smc *smc, struct s_phy *phy, int cmd)\n{\n\tint\ti ;\n\tint\tnp = phy->np ;\t\t \n\tstruct s_plc\t*plc ;\n\tstruct fddi_mib_p\t*mib ;\n#ifndef\tMOT_ELM\n\tu_short\tplc_rev ;\t\t \n#endif\t \n\n\tplc = &phy->plc ;\n\tmib = phy->mib ;\n\n\t \n\tswitch (cmd) {\n\tcase PC_STOP :\n\t\t \n\t\tif (mib->fddiPORTPCMState != PC9_MAINT) {\n\t\t\tGO_STATE(PC0_OFF) ;\n\t\t\tAIX_EVENT(smc, (u_long) FDDI_RING_STATUS, (u_long)\n\t\t\t\tFDDI_PORT_EVENT, (u_long) FDDI_PORT_STOP,\n\t\t\t\tsmt_get_port_event_word(smc));\n\t\t}\n\t\treturn ;\n\tcase PC_START :\n\t\t \n\t\tif (mib->fddiPORTPCMState != PC9_MAINT)\n\t\t\tGO_STATE(PC1_BREAK) ;\n\t\treturn ;\n\tcase PC_DISABLE :\n\t\t \n\t\tGO_STATE(PC9_MAINT) ;\n\t\tAIX_EVENT(smc, (u_long) FDDI_RING_STATUS, (u_long)\n\t\t\tFDDI_PORT_EVENT, (u_long) FDDI_PORT_DISABLED,\n\t\t\tsmt_get_port_event_word(smc));\n\t\treturn ;\n\tcase PC_TIMEOUT_LCT :\n\t\t \n\t\tstop_pcm_timer0(smc,phy) ;\n\t\tCLEAR(PLC(np,PL_CNTRL_B),PL_LONG) ;\n\t\t \n\t\treturn ;\n\t}\n\n\tswitch(mib->fddiPORTPCMState) {\n\tcase ACTIONS(PC0_OFF) :\n\t\tstop_pcm_timer0(smc,phy) ;\n\t\toutpw(PLC(np,PL_CNTRL_A),0) ;\n\t\tCLEAR(PLC(np,PL_CNTRL_B),PL_PC_JOIN) ;\n\t\tCLEAR(PLC(np,PL_CNTRL_B),PL_LONG) ;\n\t\tsm_ph_lem_stop(smc,np) ;\t\t \n\t\tphy->cf_loop = FALSE ;\n\t\tphy->cf_join = FALSE ;\n\t\tqueue_event(smc,EVENT_CFM,CF_JOIN+np) ;\n\t\tplc_go_state(smc,np,PL_PCM_STOP) ;\n\t\tmib->fddiPORTConnectState = PCM_DISABLED ;\n\t\tACTIONS_DONE() ;\n\t\tbreak ;\n\tcase PC0_OFF:\n\t\t \n\t\tif (cmd == PC_MAINT) {\n\t\t\tGO_STATE(PC9_MAINT) ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak ;\n\tcase ACTIONS(PC1_BREAK) :\n\t\t \n\t\tstop_pcm_timer0(smc,phy) ;\n\t\tACTIONS_DONE() ;\n\t\tplc_go_state(smc,np,0) ;\n\t\tCLEAR(PLC(np,PL_CNTRL_B),PL_PC_JOIN) ;\n\t\tCLEAR(PLC(np,PL_CNTRL_B),PL_LONG) ;\n\t\tsm_ph_lem_stop(smc,np) ;\t\t \n\t\t \n#if\t0\n\t\tif (inpw(PLC(np,PL_STATUS_B)) & PL_PCM_SIGNAL) {\n\t\t\tplc_go_state(smc,np,PL_PCM_STOP) ;\n\t\t\t \n\t\t}\n#endif\n\t\t \n\t\tplc_go_state(smc,np,PL_PCM_STOP) ;\n\n\t\tif (mib->fddiPORTPC_Withhold == PC_WH_NONE)\n\t\t\tmib->fddiPORTConnectState = PCM_CONNECTING ;\n\t\tphy->cf_loop = FALSE ;\n\t\tphy->cf_join = FALSE ;\n\t\tqueue_event(smc,EVENT_CFM,CF_JOIN+np) ;\n\t\tphy->ls_flag = FALSE ;\n\t\tphy->pc_mode = PM_NONE ;\t \n\t\tphy->bitn = 0 ;\t\t\t \n\t\tfor (i = 0 ; i < 3 ; i++)\n\t\t\tpc_tcode_actions(smc,i,phy) ;\n\n\t\t \n\t\toutpw(PLC(np,PL_INTR_MASK),plc_imsk_na) ;\n\n\t\t \n\t\t(void)inpw(PLC(np,PL_INTR_EVENT)) ;\n#ifndef\tMOT_ELM\n\t\t \n\t\tplc_rev = inpw(PLC(np,PL_STATUS_A)) & PLC_REV_MASK ;\n\n\t\tif (plc_rev != PLC_REV_SN3)\n#endif\t \n\t\t{\n\t\t\t \n\t\t\tif (plc_send_bits(smc,phy,3)) {\n\t\t\t\treturn ;\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t\tplc_go_state(smc,np,PL_PCM_START) ;\n\n\t\t \n#ifdef\tMOT_ELM\n\t\tif (!(inpw(PLC(np,PL_STATUS_B)) & PL_PCM_SIGNAL))\n#else\t \n\t\tif (((inpw(PLC(np,PL_STATUS_A)) & PLC_REV_MASK) !=\n\t\t\tPLC_REVISION_A) &&\n\t\t\t!(inpw(PLC(np,PL_STATUS_B)) & PL_PCM_SIGNAL))\n#endif\t \n\t\t{\n\t\t\t \n\t\t\t(void) plc_send_bits(smc,phy,3) ;\n\t\t}\n\t\t \n\n\t\tGO_STATE(PC5_SIGNAL) ;\n\t\tplc->p_state = PS_BIT3 ;\n\t\tplc->p_bits = 3 ;\n\t\tplc->p_start = 0 ;\n\n\t\tbreak ;\n\tcase PC1_BREAK :\n\t\tbreak ;\n\tcase ACTIONS(PC2_TRACE) :\n\t\tplc_go_state(smc,np,PL_PCM_TRACE) ;\n\t\tACTIONS_DONE() ;\n\t\tbreak ;\n\tcase PC2_TRACE :\n\t\tbreak ;\n\n\tcase PC3_CONNECT :\t \n\tcase PC4_NEXT :\n\t\tbreak ;\n\n\tcase ACTIONS(PC5_SIGNAL) :\n\t\tACTIONS_DONE() ;\n\t\tfallthrough;\n\tcase PC5_SIGNAL :\n\t\tif ((cmd != PC_SIGNAL) && (cmd != PC_TIMEOUT_LCT))\n\t\t\tbreak ;\n\t\tswitch (plc->p_state) {\n\t\tcase PS_BIT3 :\n\t\t\tfor (i = 0 ; i <= 2 ; i++)\n\t\t\t\tpc_rcode_actions(smc,i,phy) ;\n\t\t\tpc_tcode_actions(smc,3,phy) ;\n\t\t\tplc->p_state = PS_BIT4 ;\n\t\t\tplc->p_bits = 1 ;\n\t\t\tplc->p_start = 3 ;\n\t\t\tphy->bitn = 3 ;\n\t\t\tif (plc_send_bits(smc,phy,1)) {\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tbreak ;\n\t\tcase PS_BIT4 :\n\t\t\tpc_rcode_actions(smc,3,phy) ;\n\t\t\tfor (i = 4 ; i <= 6 ; i++)\n\t\t\t\tpc_tcode_actions(smc,i,phy) ;\n\t\t\tplc->p_state = PS_BIT7 ;\n\t\t\tplc->p_bits = 3 ;\n\t\t\tplc->p_start = 4 ;\n\t\t\tphy->bitn = 4 ;\n\t\t\tif (plc_send_bits(smc,phy,3)) {\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tbreak ;\n\t\tcase PS_BIT7 :\n\t\t\tfor (i = 3 ; i <= 6 ; i++)\n\t\t\t\tpc_rcode_actions(smc,i,phy) ;\n\t\t\tplc->p_state = PS_LCT ;\n\t\t\tplc->p_bits = 0 ;\n\t\t\tplc->p_start = 7 ;\n\t\t\tphy->bitn = 7 ;\n\t\tsm_ph_lem_start(smc,np,(int)smc->s.lct_short) ;  \n\t\t\t \n\t\t\ti = inpw(PLC(np,PL_CNTRL_B)) & ~PL_PC_LOOP ;\n\t\t\toutpw(PLC(np,PL_CNTRL_B),i) ;\t \n\t\t\toutpw(PLC(np,PL_CNTRL_B),i | PL_RLBP) ;\n\t\t\tbreak ;\n\t\tcase PS_LCT :\n\t\t\t \n\t\t\tpc_tcode_actions(smc,7,phy) ;\n\t\t\t \n\t\t\tplc->p_state = PS_BIT8 ;\n\t\t\tplc->p_bits = 1 ;\n\t\t\tplc->p_start = 7 ;\n\t\t\tphy->bitn = 7 ;\n\t\t\tif (plc_send_bits(smc,phy,1)) {\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tbreak ;\n\t\tcase PS_BIT8 :\n\t\t\t \n\t\t\tpc_rcode_actions(smc,7,phy) ;\n\t\t\tif (phy->t_val[7] || phy->r_val[7]) {\n\t\t\t\tplc_go_state(smc,np,PL_PCM_STOP) ;\n\t\t\t\tGO_STATE(PC1_BREAK) ;\n\t\t\t\tbreak ;\n\t\t\t}\n\t\t\tfor (i = 8 ; i <= 9 ; i++)\n\t\t\t\tpc_tcode_actions(smc,i,phy) ;\n\t\t\tplc->p_state = PS_JOIN ;\n\t\t\tplc->p_bits = 2 ;\n\t\t\tplc->p_start = 8 ;\n\t\t\tphy->bitn = 8 ;\n\t\t\tif (plc_send_bits(smc,phy,2)) {\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tbreak ;\n\t\tcase PS_JOIN :\n\t\t\tfor (i = 8 ; i <= 9 ; i++)\n\t\t\t\tpc_rcode_actions(smc,i,phy) ;\n\t\t\tplc->p_state = PS_ACTIVE ;\n\t\t\tGO_STATE(PC6_JOIN) ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak ;\n\n\tcase ACTIONS(PC6_JOIN) :\n\t\t \n\t\tif (smc->s.sas == SMT_DAS && np == PB &&\n\t\t\t(smc->y[PA].pc_mode == PM_TREE ||\n\t\t\t smc->y[PB].pc_mode == PM_TREE)) {\n\t\t\tSETMASK(PLC(np,PL_CNTRL_A),\n\t\t\t\tPL_SC_REM_LOOP,PL_SC_REM_LOOP) ;\n\t\t\tSETMASK(PLC(np,PL_CNTRL_B),\n\t\t\t\tPL_CONFIG_CNTRL,PL_CONFIG_CNTRL) ;\n\t\t}\n\t\tSETMASK(PLC(np,PL_CNTRL_B),PL_PC_JOIN,PL_PC_JOIN) ;\n\t\tSETMASK(PLC(np,PL_CNTRL_B),PL_PC_JOIN,PL_PC_JOIN) ;\n\t\tACTIONS_DONE() ;\n\t\tcmd = 0 ;\n\t\tfallthrough;\n\tcase PC6_JOIN :\n\t\tswitch (plc->p_state) {\n\t\tcase PS_ACTIVE:\n\t\t\t \n\t\t\tif (!phy->cf_join) {\n\t\t\t\tphy->cf_join = TRUE ;\n\t\t\t\tqueue_event(smc,EVENT_CFM,CF_JOIN+np) ;\n\t\t\t}\n\t\t\tif (cmd == PC_JOIN)\n\t\t\t\tGO_STATE(PC8_ACTIVE) ;\n\t\t\t \n\t\t\tif (cmd == PC_TRACE) {\n\t\t\t\tGO_STATE(PC2_TRACE) ;\n\t\t\t\tbreak ;\n\t\t\t}\n\t\t\tbreak ;\n\t\t}\n\t\tbreak ;\n\n\tcase PC7_VERIFY :\n\t\tbreak ;\n\n\tcase ACTIONS(PC8_ACTIVE) :\n\t\t \n\t\tsm_ph_lem_start(smc,(int)phy->np,LCT_LEM_MAX) ;\n\n\t\tphy->tr_flag = FALSE ;\n\t\tmib->fddiPORTConnectState = PCM_ACTIVE ;\n\n\t\t \n\t\toutpw(PLC(np,PL_INTR_MASK),plc_imsk_act) ;\n\n\t\tACTIONS_DONE() ;\n\t\tbreak ;\n\tcase PC8_ACTIVE :\n\t\t \n\t\t \n\t\tif (cmd == PC_TRACE) {\n\t\t\tGO_STATE(PC2_TRACE) ;\n\t\t\tbreak ;\n\t\t}\n\t\t \n\n\t\tbreak ;\n\tcase ACTIONS(PC9_MAINT) :\n\t\tstop_pcm_timer0(smc,phy) ;\n\t\tCLEAR(PLC(np,PL_CNTRL_B),PL_PC_JOIN) ;\n\t\tCLEAR(PLC(np,PL_CNTRL_B),PL_LONG) ;\n\t\tCLEAR(PLC(np,PL_INTR_MASK),PL_LE_CTR) ;\t \n\t\tsm_ph_lem_stop(smc,np) ;\t\t \n\t\tphy->cf_loop = FALSE ;\n\t\tphy->cf_join = FALSE ;\n\t\tqueue_event(smc,EVENT_CFM,CF_JOIN+np) ;\n\t\tplc_go_state(smc,np,PL_PCM_STOP) ;\n\t\tmib->fddiPORTConnectState = PCM_DISABLED ;\n\t\tSETMASK(PLC(np,PL_CNTRL_B),PL_MAINT,PL_MAINT) ;\n\t\tsm_ph_linestate(smc,np,(int) MIB2LS(mib->fddiPORTMaint_LS)) ;\n\t\toutpw(PLC(np,PL_CNTRL_A),PL_SC_BYPASS) ;\n\t\tACTIONS_DONE() ;\n\t\tbreak ;\n\tcase PC9_MAINT :\n\t\tDB_PCMN(1, \"PCM %c : MAINT\", phy->phy_name);\n\t\t \n\t\tif (cmd == PC_ENABLE) {\n\t\t\tGO_STATE(PC0_OFF) ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak ;\n\n\tdefault:\n\t\tSMT_PANIC(smc,SMT_E0118, SMT_E0118_MSG) ;\n\t\tbreak ;\n\t}\n}\n\n \nstatic void sm_ph_linestate(struct s_smc *smc, int phy, int ls)\n{\n\tint\tcntrl ;\n\n\tSK_UNUSED(smc) ;\n\n\tcntrl = (inpw(PLC(phy,PL_CNTRL_B)) & ~PL_MAINT_LS) |\n\t\t\t\t\t\tPL_PCM_STOP | PL_MAINT ;\n\tswitch(ls) {\n\tcase PC_QLS: \t\t \n\t\tcntrl |= PL_M_QUI0 ;\n\t\tbreak ;\n\tcase PC_MLS: \t\t \n\t\tcntrl |= PL_M_MASTR ;\n\t\tbreak ;\n\tcase PC_HLS: \t\t \n\t\tcntrl |= PL_M_HALT ;\n\t\tbreak ;\n\tdefault :\n\tcase PC_ILS: \t\t \n\t\tcntrl |= PL_M_IDLE ;\n\t\tbreak ;\n\tcase PC_LS_PDR: \t \n\t\tcntrl |= PL_M_TPDR ;\n\t\tbreak ;\n\t}\n\toutpw(PLC(phy,PL_CNTRL_B),cntrl) ;\n}\n\nstatic void reset_lem_struct(struct s_phy *phy)\n{\n\tstruct lem_counter *lem = &phy->lem ;\n\n\tphy->mib->fddiPORTLer_Estimate = 15 ;\n\tlem->lem_float_ber = 15 * 100 ;\n}\n\n \nstatic void lem_evaluate(struct s_smc *smc, struct s_phy *phy)\n{\n\tint ber ;\n\tu_long errors ;\n\tstruct lem_counter *lem = &phy->lem ;\n\tstruct fddi_mib_p\t*mib ;\n\tint\t\t\tcond ;\n\n\tmib = phy->mib ;\n\n\tif (!lem->lem_on)\n\t\treturn ;\n\n\terrors = inpw(PLC(((int) phy->np),PL_LINK_ERR_CTR)) ;\n\tlem->lem_errors += errors ;\n\tmib->fddiPORTLem_Ct += errors ;\n\n\terrors = lem->lem_errors ;\n\t \n\n\t\tif (!errors)\t\tber = 15 ;\n\telse\tif (errors <= 9)\tber = 9 ;\n\telse\tif (errors <= 99)\tber = 8 ;\n\telse\tif (errors <= 999)\tber = 7 ;\n\telse\tif (errors <= 9999)\tber = 6 ;\n\telse\tif (errors <= 99999)\tber = 5 ;\n\telse\tif (errors <= 999999)\tber = 4 ;\n\telse\tif (errors <= 9999999)\tber = 3 ;\n\telse\tif (errors <= 99999999)\tber = 2 ;\n\telse\tif (errors <= 999999999) ber = 1 ;\n\telse\t\t\t\tber = 0 ;\n\n\t \n\tber *= 100 ;\n\tlem->lem_float_ber = lem->lem_float_ber * 7 + ber * 3 ;\n\tlem->lem_float_ber /= 10 ;\n\tmib->fddiPORTLer_Estimate = lem->lem_float_ber / 100 ;\n\tif (mib->fddiPORTLer_Estimate < 4) {\n\t\tmib->fddiPORTLer_Estimate = 4 ;\n\t}\n\n\tif (lem->lem_errors) {\n\t\tDB_PCMN(1, \"LEM %c :\", phy->np == PB ? 'B' : 'A');\n\t\tDB_PCMN(1, \"errors      : %ld\", lem->lem_errors);\n\t\tDB_PCMN(1, \"sum_errors  : %ld\", mib->fddiPORTLem_Ct);\n\t\tDB_PCMN(1, \"current BER : 10E-%d\", ber / 100);\n\t\tDB_PCMN(1, \"float BER   : 10E-(%d/100)\", lem->lem_float_ber);\n\t\tDB_PCMN(1, \"avg. BER    : 10E-%d\", mib->fddiPORTLer_Estimate);\n\t}\n\n\tlem->lem_errors = 0L ;\n\n#ifndef\tSLIM_SMT\n\tcond = (mib->fddiPORTLer_Estimate <= mib->fddiPORTLer_Alarm) ?\n\t\tTRUE : FALSE ;\n#ifdef\tSMT_EXT_CUTOFF\n\tsmt_ler_alarm_check(smc,phy,cond) ;\n#endif\t \n\tif (cond != mib->fddiPORTLerFlag) {\n\t\tsmt_srf_event(smc,SMT_COND_PORT_LER,\n\t\t\t(int) (INDEX_PORT+ phy->np) ,cond) ;\n\t}\n#endif\n\n\tif (\tmib->fddiPORTLer_Estimate <= mib->fddiPORTLer_Cutoff) {\n\t\tphy->pc_lem_fail = TRUE ;\t\t \n\t\tmib->fddiPORTLem_Reject_Ct++ ;\n\t\t \n\t\tlem->lem_float_ber += 2*100 ;\n\n\t\t \n#ifdef\tCONCENTRATOR\n\t\tDB_PCMN(1, \"PCM: LER cutoff on port %d cutoff %d\",\n\t\t\tphy->np, mib->fddiPORTLer_Cutoff);\n#endif\n#ifdef\tSMT_EXT_CUTOFF\n\t\tsmt_port_off_event(smc,phy->np);\n#else\t \n\t\tqueue_event(smc,(int)(EVENT_PCM+phy->np),PC_START) ;\n#endif\t \n\t}\n}\n\n \nvoid sm_lem_evaluate(struct s_smc *smc)\n{\n\tint np ;\n\n\tfor (np = 0 ; np < NUMPHYS ; np++)\n\t\tlem_evaluate(smc,&smc->y[np]) ;\n}\n\nstatic void lem_check_lct(struct s_smc *smc, struct s_phy *phy)\n{\n\tstruct lem_counter\t*lem = &phy->lem ;\n\tstruct fddi_mib_p\t*mib ;\n\tint errors ;\n\n\tmib = phy->mib ;\n\n\tphy->pc_lem_fail = FALSE ;\t\t \n\terrors = inpw(PLC(((int)phy->np),PL_LINK_ERR_CTR)) ;\n\tlem->lem_errors += errors ;\n\tmib->fddiPORTLem_Ct += errors ;\n\tif (lem->lem_errors) {\n\t\tswitch(phy->lc_test) {\n\t\tcase LC_SHORT:\n\t\t\tif (lem->lem_errors >= smc->s.lct_short)\n\t\t\t\tphy->pc_lem_fail = TRUE ;\n\t\t\tbreak ;\n\t\tcase LC_MEDIUM:\n\t\t\tif (lem->lem_errors >= smc->s.lct_medium)\n\t\t\t\tphy->pc_lem_fail = TRUE ;\n\t\t\tbreak ;\n\t\tcase LC_LONG:\n\t\t\tif (lem->lem_errors >= smc->s.lct_long)\n\t\t\t\tphy->pc_lem_fail = TRUE ;\n\t\t\tbreak ;\n\t\tcase LC_EXTENDED:\n\t\t\tif (lem->lem_errors >= smc->s.lct_extended)\n\t\t\t\tphy->pc_lem_fail = TRUE ;\n\t\t\tbreak ;\n\t\t}\n\t\tDB_PCMN(1, \" >>errors : %lu\", lem->lem_errors);\n\t}\n\tif (phy->pc_lem_fail) {\n\t\tmib->fddiPORTLCTFail_Ct++ ;\n\t\tmib->fddiPORTLem_Reject_Ct++ ;\n\t}\n\telse\n\t\tmib->fddiPORTLCTFail_Ct = 0 ;\n}\n\n \nstatic void sm_ph_lem_start(struct s_smc *smc, int np, int threshold)\n{\n\tstruct lem_counter *lem = &smc->y[np].lem ;\n\n\tlem->lem_on = 1 ;\n\tlem->lem_errors = 0L ;\n\n\t \n\n\toutpw(PLC(np,PL_LE_THRESHOLD),threshold) ;\n\t(void)inpw(PLC(np,PL_LINK_ERR_CTR)) ;\t \n\n\t \n\tSETMASK(PLC(np,PL_INTR_MASK),PL_LE_CTR,PL_LE_CTR) ;\n}\n\nstatic void sm_ph_lem_stop(struct s_smc *smc, int np)\n{\n\tstruct lem_counter *lem = &smc->y[np].lem ;\n\n\tlem->lem_on = 0 ;\n\tCLEAR(PLC(np,PL_INTR_MASK),PL_LE_CTR) ;\n}\n\n \n\n \nstatic void pc_rcode_actions(struct s_smc *smc, int bit, struct s_phy *phy)\n{\n\tstruct fddi_mib_p\t*mib ;\n\n\tmib = phy->mib ;\n\n\tDB_PCMN(1, \"SIG rec %x %x:\", bit, phy->r_val[bit]);\n\tbit++ ;\n\n\tswitch(bit) {\n\tcase 0:\n\tcase 1:\n\tcase 2:\n\t\tbreak ;\n\tcase 3 :\n\t\tif (phy->r_val[1] == 0 && phy->r_val[2] == 0)\n\t\t\tmib->fddiPORTNeighborType = TA ;\n\t\telse if (phy->r_val[1] == 0 && phy->r_val[2] == 1)\n\t\t\tmib->fddiPORTNeighborType = TB ;\n\t\telse if (phy->r_val[1] == 1 && phy->r_val[2] == 0)\n\t\t\tmib->fddiPORTNeighborType = TS ;\n\t\telse if (phy->r_val[1] == 1 && phy->r_val[2] == 1)\n\t\t\tmib->fddiPORTNeighborType = TM ;\n\t\tbreak ;\n\tcase 4:\n\t\tif (mib->fddiPORTMy_Type == TM &&\n\t\t\tmib->fddiPORTNeighborType == TM) {\n\t\t\tDB_PCMN(1, \"PCM %c : E100 withhold M-M\",\n\t\t\t\tphy->phy_name);\n\t\t\tmib->fddiPORTPC_Withhold = PC_WH_M_M ;\n\t\t\tRS_SET(smc,RS_EVENT) ;\n\t\t}\n\t\telse if (phy->t_val[3] || phy->r_val[3]) {\n\t\t\tmib->fddiPORTPC_Withhold = PC_WH_NONE ;\n\t\t\tif (mib->fddiPORTMy_Type == TM ||\n\t\t\t    mib->fddiPORTNeighborType == TM)\n\t\t\t\tphy->pc_mode = PM_TREE ;\n\t\t\telse\n\t\t\t\tphy->pc_mode = PM_PEER ;\n\n\t\t\t \n\t\t\tall_selection_criteria (smc);\n\n\t\t\tif (phy->wc_flag) {\n\t\t\t\tmib->fddiPORTPC_Withhold = PC_WH_PATH ;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmib->fddiPORTPC_Withhold = PC_WH_OTHER ;\n\t\t\tRS_SET(smc,RS_EVENT) ;\n\t\t\tDB_PCMN(1, \"PCM %c : E101 withhold other\",\n\t\t\t\tphy->phy_name);\n\t\t}\n\t\tphy->twisted = ((mib->fddiPORTMy_Type != TS) &&\n\t\t\t\t(mib->fddiPORTMy_Type != TM) &&\n\t\t\t\t(mib->fddiPORTNeighborType ==\n\t\t\t\tmib->fddiPORTMy_Type)) ;\n\t\tif (phy->twisted) {\n\t\t\tDB_PCMN(1, \"PCM %c : E102 !!! TWISTED !!!\",\n\t\t\t\tphy->phy_name);\n\t\t}\n\t\tbreak ;\n\tcase 5 :\n\t\tbreak ;\n\tcase 6:\n\t\tif (phy->t_val[4] || phy->r_val[4]) {\n\t\t\tif ((phy->t_val[4] && phy->t_val[5]) ||\n\t\t\t    (phy->r_val[4] && phy->r_val[5]) )\n\t\t\t\tphy->lc_test = LC_EXTENDED ;\n\t\t\telse\n\t\t\t\tphy->lc_test = LC_LONG ;\n\t\t}\n\t\telse if (phy->t_val[5] || phy->r_val[5])\n\t\t\tphy->lc_test = LC_MEDIUM ;\n\t\telse\n\t\t\tphy->lc_test = LC_SHORT ;\n\t\tswitch (phy->lc_test) {\n\t\tcase LC_SHORT :\t\t\t\t \n\t\t\toutpw(PLC((int)phy->np,PL_LC_LENGTH), TP_LC_LENGTH ) ;\n\t\t\tphy->t_next[7] = smc->s.pcm_lc_short ;\n\t\t\tbreak ;\n\t\tcase LC_MEDIUM :\t\t\t \n\t\t\toutpw(PLC((int)phy->np,PL_LC_LENGTH), TP_LC_LONGLN ) ;\n\t\t\tphy->t_next[7] = smc->s.pcm_lc_medium ;\n\t\t\tbreak ;\n\t\tcase LC_LONG :\n\t\t\tSETMASK(PLC((int)phy->np,PL_CNTRL_B),PL_LONG,PL_LONG) ;\n\t\t\tphy->t_next[7] = smc->s.pcm_lc_long ;\n\t\t\tbreak ;\n\t\tcase LC_EXTENDED :\n\t\t\tSETMASK(PLC((int)phy->np,PL_CNTRL_B),PL_LONG,PL_LONG) ;\n\t\t\tphy->t_next[7] = smc->s.pcm_lc_extended ;\n\t\t\tbreak ;\n\t\t}\n\t\tif (phy->t_next[7] > smc->s.pcm_lc_medium) {\n\t\t\tstart_pcm_timer0(smc,phy->t_next[7],PC_TIMEOUT_LCT,phy);\n\t\t}\n\t\tDB_PCMN(1, \"LCT timer = %ld us\", phy->t_next[7]);\n\t\tphy->t_next[9] = smc->s.pcm_t_next_9 ;\n\t\tbreak ;\n\tcase 7:\n\t\tif (phy->t_val[6]) {\n\t\t\tphy->cf_loop = TRUE ;\n\t\t}\n\t\tphy->td_flag = TRUE ;\n\t\tbreak ;\n\tcase 8:\n\t\tif (phy->t_val[7] || phy->r_val[7]) {\n\t\t\tDB_PCMN(1, \"PCM %c : E103 LCT fail %s\",\n\t\t\t\tphy->phy_name,\n\t\t\t\tphy->t_val[7] ? \"local\" : \"remote\");\n\t\t\tqueue_event(smc,(int)(EVENT_PCM+phy->np),PC_START) ;\n\t\t}\n\t\tbreak ;\n\tcase 9:\n\t\tif (phy->t_val[8] || phy->r_val[8]) {\n\t\t\tif (phy->t_val[8])\n\t\t\t\tphy->cf_loop = TRUE ;\n\t\t\tphy->td_flag = TRUE ;\n\t\t}\n\t\tbreak ;\n\tcase 10:\n\t\tif (phy->r_val[9]) {\n\t\t\t  ;\n\t\t\tmib->fddiPORTMacIndicated.R_val = TRUE ;\n\t\t}\n\t\telse {\n\t\t\t  ;\n\t\t\tmib->fddiPORTMacIndicated.R_val = FALSE ;\n\t\t}\n\t\tbreak ;\n\t}\n}\n\n \nstatic void pc_tcode_actions(struct s_smc *smc, const int bit, struct s_phy *phy)\n{\n\tint\tnp = phy->np ;\n\tstruct fddi_mib_p\t*mib ;\n\n\tmib = phy->mib ;\n\n\tswitch(bit) {\n\tcase 0:\n\t\tphy->t_val[0] = 0 ;\t\t \n\t\tbreak ;\n\tcase 1:\n\t\tif (mib->fddiPORTMy_Type == TS || mib->fddiPORTMy_Type == TM)\n\t\t\tphy->t_val[1] = 1 ;\n\t\telse\n\t\t\tphy->t_val[1] = 0 ;\n\t\tbreak ;\n\tcase 2 :\n\t\tif (mib->fddiPORTMy_Type == TB || mib->fddiPORTMy_Type == TM)\n\t\t\tphy->t_val[2] = 1 ;\n\t\telse\n\t\t\tphy->t_val[2] = 0 ;\n\t\tbreak ;\n\tcase 3:\n\t\t{\n\t\tint\ttype,ne ;\n\t\tint\tpolicy ;\n\n\t\ttype = mib->fddiPORTMy_Type ;\n\t\tne = mib->fddiPORTNeighborType ;\n\t\tpolicy = smc->mib.fddiSMTConnectionPolicy ;\n\n\t\tphy->t_val[3] = 1 ;\t \n\t\tswitch (type) {\n\t\tcase TA :\n\t\t\tif (\n\t\t\t\t((policy & POLICY_AA) && ne == TA) ||\n\t\t\t\t((policy & POLICY_AB) && ne == TB) ||\n\t\t\t\t((policy & POLICY_AS) && ne == TS) ||\n\t\t\t\t((policy & POLICY_AM) && ne == TM) )\n\t\t\t\tphy->t_val[3] = 0 ;\t \n\t\t\tbreak ;\n\t\tcase TB :\n\t\t\tif (\n\t\t\t\t((policy & POLICY_BA) && ne == TA) ||\n\t\t\t\t((policy & POLICY_BB) && ne == TB) ||\n\t\t\t\t((policy & POLICY_BS) && ne == TS) ||\n\t\t\t\t((policy & POLICY_BM) && ne == TM) )\n\t\t\t\tphy->t_val[3] = 0 ;\t \n\t\t\tbreak ;\n\t\tcase TS :\n\t\t\tif (\n\t\t\t\t((policy & POLICY_SA) && ne == TA) ||\n\t\t\t\t((policy & POLICY_SB) && ne == TB) ||\n\t\t\t\t((policy & POLICY_SS) && ne == TS) ||\n\t\t\t\t((policy & POLICY_SM) && ne == TM) )\n\t\t\t\tphy->t_val[3] = 0 ;\t \n\t\t\tbreak ;\n\t\tcase TM :\n\t\t\tif (\tne == TM ||\n\t\t\t\t((policy & POLICY_MA) && ne == TA) ||\n\t\t\t\t((policy & POLICY_MB) && ne == TB) ||\n\t\t\t\t((policy & POLICY_MS) && ne == TS) ||\n\t\t\t\t((policy & POLICY_MM) && ne == TM) )\n\t\t\t\tphy->t_val[3] = 0 ;\t \n\t\t\tbreak ;\n\t\t}\n#ifndef\tSLIM_SMT\n\t\t \n\t\tif (\t(type == TA && ne == TA ) ||\n\t\t\t(type == TA && ne == TS ) ||\n\t\t\t(type == TB && ne == TB ) ||\n\t\t\t(type == TB && ne == TS ) ||\n\t\t\t(type == TS && ne == TA ) ||\n\t\t\t(type == TS && ne == TB ) ) {\n\t\t\tsmt_srf_event(smc,SMT_EVENT_PORT_CONNECTION,\n\t\t\t\t(int) (INDEX_PORT+ phy->np) ,0) ;\n\t\t}\n#endif\n\t\t}\n\t\tbreak ;\n\tcase 4:\n\t\tif (mib->fddiPORTPC_Withhold == PC_WH_NONE) {\n\t\t\tif (phy->pc_lem_fail) {\n\t\t\t\tphy->t_val[4] = 1 ;\t \n\t\t\t\tphy->t_val[5] = 0 ;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tphy->t_val[4] = 0 ;\n\t\t\t\tif (mib->fddiPORTLCTFail_Ct > 0)\n\t\t\t\t\tphy->t_val[5] = 1 ;\t \n\t\t\t\telse\n\t\t\t\t\tphy->t_val[5] = 0 ;\t \n\n\t\t\t\t \n\t\t\t\tif (phy->wc_flag)\n\t\t\t\t\tphy->t_val[5] = 1 ;\t \n\t\t\t}\n\t\t\tmib->fddiPORTConnectState = PCM_CONNECTING ;\n\t\t}\n\t\telse {\n\t\t\tmib->fddiPORTConnectState = PCM_STANDBY ;\n\t\t\tphy->t_val[4] = 1 ;\t \n\t\t\tphy->t_val[5] = 1 ;\n\t\t}\n\t\tbreak ;\n\tcase 5:\n\t\tbreak ;\n\tcase 6:\n\t\t \n\t\tphy->t_val[6] = 0 ;\n\t\tbreak ;\n\tcase 7:\n\t\tphy->cf_loop = FALSE ;\n\t\tlem_check_lct(smc,phy) ;\n\t\tif (phy->pc_lem_fail) {\n\t\t\tDB_PCMN(1, \"PCM %c : E104 LCT failed\", phy->phy_name);\n\t\t\tphy->t_val[7] = 1 ;\n\t\t}\n\t\telse\n\t\t\tphy->t_val[7] = 0 ;\n\t\tbreak ;\n\tcase 8:\n\t\tphy->t_val[8] = 0 ;\t \n\t\tbreak ;\n\tcase 9:\n\t\tphy->cf_loop = 0 ;\n\t\tif ((mib->fddiPORTPC_Withhold != PC_WH_NONE) ||\n\t\t     ((smc->s.sas == SMT_DAS) && (phy->wc_flag))) {\n\t\t\tqueue_event(smc,EVENT_PCM+np,PC_START) ;\n\t\t\tbreak ;\n\t\t}\n\t\tphy->t_val[9] = FALSE ;\n\t\tswitch (smc->s.sas) {\n\t\tcase SMT_DAS :\n\t\t\t \n\t\t\tif (phy->pc_mode == PM_TREE) {\n\t\t\t\tif ((np == PB) || ((np == PA) &&\n\t\t\t\t(smc->y[PB].mib->fddiPORTConnectState !=\n\t\t\t\t\tPCM_ACTIVE)))\n\t\t\t\t\tphy->t_val[9] = TRUE ;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (np == PB)\n\t\t\t\t\tphy->t_val[9] = TRUE ;\n\t\t\t}\n\t\t\tbreak ;\n\t\tcase SMT_SAS :\n\t\t\tif (np == PS)\n\t\t\t\tphy->t_val[9] = TRUE ;\n\t\t\tbreak ;\n#ifdef\tCONCENTRATOR\n\t\tcase SMT_NAC :\n\t\t\t \n\t\t\tif (np == PB)\n\t\t\t\tphy->t_val[9] = TRUE ;\n\t\t\tbreak ;\n#endif\n\t\t}\n\t\tmib->fddiPORTMacIndicated.T_val = phy->t_val[9] ;\n\t\tbreak ;\n\t}\n\tDB_PCMN(1, \"SIG snd %x %x:\", bit, phy->t_val[bit]);\n}\n\n \nint pcm_status_twisted(struct s_smc *smc)\n{\n\tint\ttwist = 0 ;\n\tif (smc->s.sas != SMT_DAS)\n\t\treturn 0;\n\tif (smc->y[PA].twisted && (smc->y[PA].mib->fddiPORTPCMState == PC8_ACTIVE))\n\t\ttwist |= 1 ;\n\tif (smc->y[PB].twisted && (smc->y[PB].mib->fddiPORTPCMState == PC8_ACTIVE))\n\t\ttwist |= 2 ;\n\treturn twist;\n}\n\n \nvoid pcm_status_state(struct s_smc *smc, int np, int *type, int *state,\n\t\t      int *remote, int *mac)\n{\n\tstruct s_phy\t*phy = &smc->y[np] ;\n\tstruct fddi_mib_p\t*mib ;\n\n\tmib = phy->mib ;\n\n\t \n\t*mac = 0 ;\n\t*type = mib->fddiPORTMy_Type ;\t\t \n\t*state = mib->fddiPORTConnectState ;\n\t*remote = mib->fddiPORTNeighborType ;\n\n\tswitch(mib->fddiPORTPCMState) {\n\tcase PC8_ACTIVE :\n\t\t*mac = mib->fddiPORTMacIndicated.R_val ;\n\t\tbreak ;\n\t}\n}\n\n \nint pcm_rooted_station(struct s_smc *smc)\n{\n\tint\tn ;\n\n\tfor (n = 0 ; n < NUMPHYS ; n++) {\n\t\tif (smc->y[n].mib->fddiPORTPCMState == PC8_ACTIVE &&\n\t\t    smc->y[n].mib->fddiPORTNeighborType == TM)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \nvoid plc_irq(struct s_smc *smc, int np, unsigned int cmd)\n \n{\n\tstruct s_phy *phy = &smc->y[np] ;\n\tstruct s_plc *plc = &phy->plc ;\n\tint\t\tn ;\n#ifdef\tSUPERNET_3\n\tint\t\tcorr_mask ;\n#endif\t \n\tint\t\ti ;\n\n\tif (np >= smc->s.numphys) {\n\t\tplc->soft_err++ ;\n\t\treturn ;\n\t}\n\tif (cmd & PL_EBUF_ERR) {\t \n\t\t \n\t\tif (!plc->ebuf_cont && phy->mib->fddiPORTPCMState == PC8_ACTIVE){\n\t\t\t \n\t\t\tphy->mib->fddiPORTEBError_Ct ++ ;\n\n\t\t}\n\n\t\tplc->ebuf_err++ ;\n\t\tif (plc->ebuf_cont <= 1000) {\n\t\t\t \n\t\t\tplc->ebuf_cont++ ;\t \n\t\t}\n\n#ifdef\tSUPERNET_3\n\t\tif (plc->ebuf_cont == 1000 &&\n\t\t\t((inpw(PLC(np,PL_STATUS_A)) & PLC_REV_MASK) ==\n\t\t\tPLC_REV_SN3)) {\n\t\t\t \n\t\t\tcorr_mask = (plc_imsk_na & ~PL_EBUF_ERR) ;\n\t\t\toutpw(PLC(np,PL_INTR_MASK),corr_mask);\n\n\t\t\t \n\t\t\tqueue_event(smc,EVENT_ECM,EC_DISCONNECT) ;\n\n\t\t\t \n\t\t\tSMT_ERR_LOG(smc,SMT_E0136, SMT_E0136_MSG) ;\n\n\t\t\t \n\t\t\tdrv_reset_indication(smc) ;\n\t\t}\n#endif\t \n\t} else {\n\t\t \n\t\tplc->ebuf_cont = 0 ;\t \n\t}\n\tif (cmd & PL_PHYINV) {\t\t \n\t\tplc->phyinv++ ;\n\t}\n\tif (cmd & PL_VSYM_CTR) {\t \n\t\tplc->vsym_ctr++ ;\n\t}\n\tif (cmd & PL_MINI_CTR) {\t \n\t\tplc->mini_ctr++ ;\n\t}\n\tif (cmd & PL_LE_CTR) {\t\t \n\t\tint\tj ;\n\n\t\t \n\t\tj = inpw(PLC(np,PL_LE_THRESHOLD)) ;\n\t\ti = inpw(PLC(np,PL_LINK_ERR_CTR)) ;\n\n\t\tif (i < j) {\n\t\t\t \n\t\t\ti += 256 ;\n\t\t}\n\n\t\tif (phy->lem.lem_on) {\n\t\t\t \n\t\t\tphy->lem.lem_errors += i ;\n\t\t\tphy->mib->fddiPORTLem_Ct += i ;\n\t\t}\n\t}\n\tif (cmd & PL_TPC_EXPIRED) {\t \n\t\tif (plc->p_state == PS_LCT) {\n\t\t\t \n\t\t\t;\n\t\t}\n\t\tplc->tpc_exp++ ;\n\t}\n\tif (cmd & PL_LS_MATCH) {\t \n\t\tswitch (inpw(PLC(np,PL_CNTRL_B)) & PL_MATCH_LS) {\n\t\tcase PL_I_IDLE :\tphy->curr_ls = PC_ILS ;\t\tbreak ;\n\t\tcase PL_I_HALT :\tphy->curr_ls = PC_HLS ;\t\tbreak ;\n\t\tcase PL_I_MASTR :\tphy->curr_ls = PC_MLS ;\t\tbreak ;\n\t\tcase PL_I_QUIET :\tphy->curr_ls = PC_QLS ;\t\tbreak ;\n\t\t}\n\t}\n\tif (cmd & PL_PCM_BREAK) {\t \n\t\tint\treason;\n\n\t\treason = inpw(PLC(np,PL_STATUS_B)) & PL_BREAK_REASON ;\n\n\t\tswitch (reason) {\n\t\tcase PL_B_PCS :\t\tplc->b_pcs++ ;\tbreak ;\n\t\tcase PL_B_TPC :\t\tplc->b_tpc++ ;\tbreak ;\n\t\tcase PL_B_TNE :\t\tplc->b_tne++ ;\tbreak ;\n\t\tcase PL_B_QLS :\t\tplc->b_qls++ ;\tbreak ;\n\t\tcase PL_B_ILS :\t\tplc->b_ils++ ;\tbreak ;\n\t\tcase PL_B_HLS :\t\tplc->b_hls++ ;\tbreak ;\n\t\t}\n\n\t\t \n\t\tDB_PCMN(1, \"PLC %d: MDcF = %x\", np, smc->e.DisconnectFlag);\n\t\tif (smc->e.DisconnectFlag == FALSE) {\n\t\t\tDB_PCMN(1, \"PLC %d: restart (reason %x)\", np, reason);\n\t\t\tqueue_event(smc,EVENT_PCM+np,PC_START) ;\n\t\t}\n\t\telse {\n\t\t\tDB_PCMN(1, \"PLC %d: NO!! restart (reason %x)\",\n\t\t\t\tnp, reason);\n\t\t}\n\t\treturn ;\n\t}\n\t \n\tif (cmd & PL_PCM_CODE) {  \n\t\tqueue_event(smc,EVENT_PCM+np,PC_SIGNAL) ;\n\t\tn = inpw(PLC(np,PL_RCV_VECTOR)) ;\n\t\tfor (i = 0 ; i < plc->p_bits ; i++) {\n\t\t\tphy->r_val[plc->p_start+i] = n & 1 ;\n\t\t\tn >>= 1 ;\n\t\t}\n\t}\n\telse if (cmd & PL_PCM_ENABLED) {  \n\t\tqueue_event(smc,EVENT_PCM+np,PC_JOIN) ;\n\t}\n\tif (cmd & PL_TRACE_PROP) {\t \n\t\t \n\t\tif (!phy->tr_flag) {\n\t\t\tDB_PCMN(1, \"PCM : irq TRACE_PROP %d %d\",\n\t\t\t\tnp, smc->mib.fddiSMTECMState);\n\t\t\tphy->tr_flag = TRUE ;\n\t\t\tsmc->e.trace_prop |= ENTITY_BIT(ENTITY_PHY(np)) ;\n\t\t\tqueue_event(smc,EVENT_ECM,EC_TRACE_PROP) ;\n\t\t}\n\t}\n\t \n\tif ((cmd & PL_SELF_TEST) && (phy->mib->fddiPORTPCMState == PC2_TRACE)) {\n\t\t \n\t\tif (smc->e.path_test == PT_PASSED) {\n\t\t\tDB_PCMN(1, \"PCM : state = %s %d\",\n\t\t\t\tget_pcmstate(smc, np),\n\t\t\t\tphy->mib->fddiPORTPCMState);\n\n\t\t\tsmc->e.path_test = PT_PENDING ;\n\t\t\tqueue_event(smc,EVENT_ECM,EC_PATH_TEST) ;\n\t\t}\n\t}\n\tif (cmd & PL_TNE_EXPIRED) {\t \n\t\t \n\t\tif (phy->mib->fddiPORTPCMState == PC8_ACTIVE) {\n\t\t\tif (!phy->tr_flag) {\n\t\t\t\tDB_PCMN(1, \"PCM %c : PC81 %s\",\n\t\t\t\t\tphy->phy_name, \"NSE\");\n\t\t\t\tqueue_event(smc, EVENT_PCM + np, PC_START);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n#if\t0\n\tif (cmd & PL_NP_ERR) {\t\t \n\t\t \n\t\tplc->np_err++ ;\n\t}\n\t \n\tif (cmd & PL_PARITY_ERR) {\t \n\t\tplc->parity_err++ ;\n\t}\n\tif (cmd & PL_LSDO) {\t\t \n\t\t;\n\t}\n#endif\n}\n\n#ifdef\tDEBUG\n \nvoid pcm_get_state(struct s_smc *smc, struct smt_state *state)\n{\n\tstruct s_phy\t*phy ;\n\tstruct pcm_state *pcs ;\n\tint\ti ;\n\tint\tii ;\n\tshort\trbits ;\n\tshort\ttbits ;\n\tstruct fddi_mib_p\t*mib ;\n\n\tfor (i = 0, phy = smc->y, pcs = state->pcm_state ; i < NUMPHYS ;\n\t\ti++ , phy++, pcs++ ) {\n\t\tmib = phy->mib ;\n\t\tpcs->pcm_type = (u_char) mib->fddiPORTMy_Type ;\n\t\tpcs->pcm_state = (u_char) mib->fddiPORTPCMState ;\n\t\tpcs->pcm_mode = phy->pc_mode ;\n\t\tpcs->pcm_neighbor = (u_char) mib->fddiPORTNeighborType ;\n\t\tpcs->pcm_bsf = mib->fddiPORTBS_Flag ;\n\t\tpcs->pcm_lsf = phy->ls_flag ;\n\t\tpcs->pcm_lct_fail = (u_char) mib->fddiPORTLCTFail_Ct ;\n\t\tpcs->pcm_ls_rx = LS2MIB(sm_pm_get_ls(smc,i)) ;\n\t\tfor (ii = 0, rbits = tbits = 0 ; ii < NUMBITS ; ii++) {\n\t\t\trbits <<= 1 ;\n\t\t\ttbits <<= 1 ;\n\t\t\tif (phy->r_val[NUMBITS-1-ii])\n\t\t\t\trbits |= 1 ;\n\t\t\tif (phy->t_val[NUMBITS-1-ii])\n\t\t\t\ttbits |= 1 ;\n\t\t}\n\t\tpcs->pcm_r_val = rbits ;\n\t\tpcs->pcm_t_val = tbits ;\n\t}\n}\n\nint get_pcm_state(struct s_smc *smc, int np)\n{\n\tint pcs ;\n\n\tSK_UNUSED(smc) ;\n\n\tswitch (inpw(PLC(np,PL_STATUS_B)) & PL_PCM_STATE) {\n\t\tcase PL_PC0 :\tpcs = PC_STOP ;\t\tbreak ;\n\t\tcase PL_PC1 :\tpcs = PC_START ;\tbreak ;\n\t\tcase PL_PC2 :\tpcs = PC_TRACE ;\tbreak ;\n\t\tcase PL_PC3 :\tpcs = PC_SIGNAL ;\tbreak ;\n\t\tcase PL_PC4 :\tpcs = PC_SIGNAL ;\tbreak ;\n\t\tcase PL_PC5 :\tpcs = PC_SIGNAL ;\tbreak ;\n\t\tcase PL_PC6 :\tpcs = PC_JOIN ;\t\tbreak ;\n\t\tcase PL_PC7 :\tpcs = PC_JOIN ;\t\tbreak ;\n\t\tcase PL_PC8 :\tpcs = PC_ENABLE ;\tbreak ;\n\t\tcase PL_PC9 :\tpcs = PC_MAINT ;\tbreak ;\n\t\tdefault :\tpcs = PC_DISABLE ; \tbreak ;\n\t}\n\treturn pcs;\n}\n\nchar *get_linestate(struct s_smc *smc, int np)\n{\n\tchar *ls = \"\" ;\n\n\tSK_UNUSED(smc) ;\n\n\tswitch (inpw(PLC(np,PL_STATUS_A)) & PL_LINE_ST) {\n\t\tcase PL_L_NLS :\tls = \"NOISE\" ;\tbreak ;\n\t\tcase PL_L_ALS :\tls = \"ACTIV\" ;\tbreak ;\n\t\tcase PL_L_UND :\tls = \"UNDEF\" ;\tbreak ;\n\t\tcase PL_L_ILS4:\tls = \"ILS 4\" ;\tbreak ;\n\t\tcase PL_L_QLS :\tls = \"QLS\" ;\tbreak ;\n\t\tcase PL_L_MLS :\tls = \"MLS\" ;\tbreak ;\n\t\tcase PL_L_HLS :\tls = \"HLS\" ;\tbreak ;\n\t\tcase PL_L_ILS16:ls = \"ILS16\" ;\tbreak ;\n#ifdef\tlint\n\t\tdefault:\tls = \"unknown\" ; break ;\n#endif\n\t}\n\treturn ls;\n}\n\nchar *get_pcmstate(struct s_smc *smc, int np)\n{\n\tchar *pcs ;\n\t\n\tSK_UNUSED(smc) ;\n\n\tswitch (inpw(PLC(np,PL_STATUS_B)) & PL_PCM_STATE) {\n\t\tcase PL_PC0 :\tpcs = \"OFF\" ;\t\tbreak ;\n\t\tcase PL_PC1 :\tpcs = \"BREAK\" ;\t\tbreak ;\n\t\tcase PL_PC2 :\tpcs = \"TRACE\" ;\t\tbreak ;\n\t\tcase PL_PC3 :\tpcs = \"CONNECT\";\tbreak ;\n\t\tcase PL_PC4 :\tpcs = \"NEXT\" ;\t\tbreak ;\n\t\tcase PL_PC5 :\tpcs = \"SIGNAL\" ;\tbreak ;\n\t\tcase PL_PC6 :\tpcs = \"JOIN\" ;\t\tbreak ;\n\t\tcase PL_PC7 :\tpcs = \"VERIFY\" ;\tbreak ;\n\t\tcase PL_PC8 :\tpcs = \"ACTIV\" ;\t\tbreak ;\n\t\tcase PL_PC9 :\tpcs = \"MAINT\" ;\t\tbreak ;\n\t\tdefault :\tpcs = \"UNKNOWN\" ; \tbreak ;\n\t}\n\treturn pcs;\n}\n\nvoid list_phy(struct s_smc *smc)\n{\n\tstruct s_plc *plc ;\n\tint np ;\n\n\tfor (np = 0 ; np < NUMPHYS ; np++) {\n\t\tplc  = &smc->y[np].plc ;\n\t\tprintf(\"PHY %d:\\tERRORS\\t\\t\\tBREAK_REASONS\\t\\tSTATES:\\n\",np) ;\n\t\tprintf(\"\\tsoft_error: %ld \\t\\tPC_Start : %ld\\n\",\n\t\t\t\t\t\tplc->soft_err,plc->b_pcs);\n\t\tprintf(\"\\tparity_err: %ld \\t\\tTPC exp. : %ld\\t\\tLine: %s\\n\",\n\t\t\tplc->parity_err,plc->b_tpc,get_linestate(smc,np)) ;\n\t\tprintf(\"\\tebuf_error: %ld \\t\\tTNE exp. : %ld\\n\",\n\t\t\t\t\t\tplc->ebuf_err,plc->b_tne) ;\n\t\tprintf(\"\\tphyinvalid: %ld \\t\\tQLS det. : %ld\\t\\tPCM : %s\\n\",\n\t\t\tplc->phyinv,plc->b_qls,get_pcmstate(smc,np)) ;\n\t\tprintf(\"\\tviosym_ctr: %ld \\t\\tILS det. : %ld\\n\",\n\t\t\t\t\t\tplc->vsym_ctr,plc->b_ils)  ;\n\t\tprintf(\"\\tmingap_ctr: %ld \\t\\tHLS det. : %ld\\n\",\n\t\t\t\t\t\tplc->mini_ctr,plc->b_hls) ;\n\t\tprintf(\"\\tnodepr_err: %ld\\n\",plc->np_err) ;\n\t\tprintf(\"\\tTPC_exp : %ld\\n\",plc->tpc_exp) ;\n\t\tprintf(\"\\tLEM_err : %ld\\n\",smc->y[np].lem.lem_errors) ;\n\t}\n}\n\n\n#ifdef\tCONCENTRATOR\nvoid pcm_lem_dump(struct s_smc *smc)\n{\n\tint\t\ti ;\n\tstruct s_phy\t*phy ;\n\tstruct fddi_mib_p\t*mib ;\n\n\tchar\t\t*entostring() ;\n\n\tprintf(\"PHY\terrors\tBER\\n\") ;\n\tprintf(\"----------------------\\n\") ;\n\tfor (i = 0,phy = smc->y ; i < NUMPHYS ; i++,phy++) {\n\t\tif (!plc_is_installed(smc,i))\n\t\t\tcontinue ;\n\t\tmib = phy->mib ;\n\t\tprintf(\"%s\\t%ld\\t10E-%d\\n\",\n\t\t\tentostring(smc,ENTITY_PHY(i)),\n\t\t\tmib->fddiPORTLem_Ct,\n\t\t\tmib->fddiPORTLer_Estimate) ;\n\t}\n}\n#endif\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}