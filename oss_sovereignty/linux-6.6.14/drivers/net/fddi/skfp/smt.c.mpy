{
  "module_name": "smt.c",
  "hash_id": "adbd83c6c0282ea777fbc5e9a88c4dd3a54569c3b5663a37f89acc645748cf48",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/fddi/skfp/smt.c",
  "human_readable_source": "\n \n\n#include \"h/types.h\"\n#include \"h/fddi.h\"\n#include \"h/smc.h\"\n#include \"h/smt_p.h\"\n#include <linux/bitrev.h>\n#include <linux/kernel.h>\n\n#define KERNEL\n#include \"h/smtstate.h\"\n\n \n#define m_fc(mb)\t((mb)->sm_data[0])\n\n#define SMT_TID_MAGIC\t0x1f0a7b3c\n\nstatic const char *const smt_type_name[] = {\n\t\"SMT_00??\", \"SMT_INFO\", \"SMT_02??\", \"SMT_03??\",\n\t\"SMT_04??\", \"SMT_05??\", \"SMT_06??\", \"SMT_07??\",\n\t\"SMT_08??\", \"SMT_09??\", \"SMT_0A??\", \"SMT_0B??\",\n\t\"SMT_0C??\", \"SMT_0D??\", \"SMT_0E??\", \"SMT_NSA\"\n} ;\n\nstatic const char *const smt_class_name[] = {\n\t\"UNKNOWN\",\"NIF\",\"SIF_CONFIG\",\"SIF_OPER\",\"ECF\",\"RAF\",\"RDF\",\n\t\"SRF\",\"PMF_GET\",\"PMF_SET\",\"ESF\"\n} ;\n\n#define LAST_CLASS\t(SMT_PMF_SET)\n\nstatic const struct fddi_addr SMT_Unknown = {\n\t{ 0,0,0x1f,0,0,0 }\n} ;\n\n \n#ifdef\tLITTLE_ENDIAN\nstatic int smt_swap_short(u_short s);\n#endif\nstatic int mac_index(struct s_smc *smc, int mac);\nstatic int phy_index(struct s_smc *smc, int phy);\nstatic int mac_con_resource_index(struct s_smc *smc, int mac);\nstatic int phy_con_resource_index(struct s_smc *smc, int phy);\nstatic void smt_send_rdf(struct s_smc *smc, SMbuf *rej, int fc, int reason,\n\t\t\t int local);\nstatic void smt_send_nif(struct s_smc *smc, const struct fddi_addr *dest, \n\t\t\t int fc, u_long tid, int type, int local);\nstatic void smt_send_ecf(struct s_smc *smc, struct fddi_addr *dest, int fc,\n                         u_long tid, int type, int len);\nstatic void smt_echo_test(struct s_smc *smc, int dna);\nstatic void smt_send_sif_config(struct s_smc *smc, struct fddi_addr *dest,\n\t\t\t\tu_long tid, int local);\nstatic void smt_send_sif_operation(struct s_smc *smc, struct fddi_addr *dest,\n\t\t\t\t   u_long tid, int local);\n#ifdef LITTLE_ENDIAN\nstatic void smt_string_swap(char *data, const char *format, int len);\n#endif\nstatic void smt_add_frame_len(SMbuf *mb, int len);\nstatic void smt_fill_una(struct s_smc *smc, struct smt_p_una *una);\nstatic void smt_fill_sde(struct s_smc *smc, struct smt_p_sde *sde);\nstatic void smt_fill_state(struct s_smc *smc, struct smt_p_state *state);\nstatic void smt_fill_timestamp(struct s_smc *smc, struct smt_p_timestamp *ts);\nstatic void smt_fill_policy(struct s_smc *smc, struct smt_p_policy *policy);\nstatic void smt_fill_latency(struct s_smc *smc, struct smt_p_latency *latency);\nstatic void smt_fill_neighbor(struct s_smc *smc, struct smt_p_neighbor *neighbor);\nstatic int smt_fill_path(struct s_smc *smc, struct smt_p_path *path);\nstatic void smt_fill_mac_status(struct s_smc *smc, struct smt_p_mac_status *st);\nstatic void smt_fill_lem(struct s_smc *smc, struct smt_p_lem *lem, int phy);\nstatic void smt_fill_version(struct s_smc *smc, struct smt_p_version *vers);\nstatic void smt_fill_fsc(struct s_smc *smc, struct smt_p_fsc *fsc);\nstatic void smt_fill_mac_counter(struct s_smc *smc, struct smt_p_mac_counter *mc);\nstatic void smt_fill_mac_fnc(struct s_smc *smc, struct smt_p_mac_fnc *fnc);\nstatic void smt_fill_manufacturer(struct s_smc *smc, \n\t\t\t\t  struct smp_p_manufacturer *man);\nstatic void smt_fill_user(struct s_smc *smc, struct smp_p_user *user);\nstatic void smt_fill_setcount(struct s_smc *smc, struct smt_p_setcount *setcount);\nstatic void smt_fill_echo(struct s_smc *smc, struct smt_p_echo *echo, u_long seed,\n\t\t\t  int len);\n\nstatic void smt_clear_una_dna(struct s_smc *smc);\nstatic void smt_clear_old_una_dna(struct s_smc *smc);\n#ifdef\tCONCENTRATOR\nstatic int entity_to_index(void);\n#endif\nstatic void update_dac(struct s_smc *smc, int report);\nstatic int div_ratio(u_long upper, u_long lower);\n#ifdef  USE_CAN_ADDR\nstatic void\thwm_conv_can(struct s_smc *smc, char *data, int len);\n#else\n#define\t\thwm_conv_can(smc,data,len)\n#endif\n\n\nstatic inline int is_my_addr(const struct s_smc *smc, \n\t\t\t     const struct fddi_addr *addr)\n{\n\treturn(*(short *)(&addr->a[0]) ==\n\t\t*(short *)(&smc->mib.m[MAC0].fddiMACSMTAddress.a[0])\n\t  && *(short *)(&addr->a[2]) ==\n\t\t*(short *)(&smc->mib.m[MAC0].fddiMACSMTAddress.a[2])\n\t  && *(short *)(&addr->a[4]) ==\n\t\t*(short *)(&smc->mib.m[MAC0].fddiMACSMTAddress.a[4])) ;\n}\n\nstatic inline int is_broadcast(const struct fddi_addr *addr)\n{\n\treturn *(u_short *)(&addr->a[0]) == 0xffff &&\n\t       *(u_short *)(&addr->a[2]) == 0xffff &&\n\t       *(u_short *)(&addr->a[4]) == 0xffff;\n}\n\nstatic inline int is_individual(const struct fddi_addr *addr)\n{\n\treturn !(addr->a[0] & GROUP_ADDR);\n}\n\nstatic inline int is_equal(const struct fddi_addr *addr1, \n\t\t\t   const struct fddi_addr *addr2)\n{\n\treturn *(u_short *)(&addr1->a[0]) == *(u_short *)(&addr2->a[0]) &&\n\t       *(u_short *)(&addr1->a[2]) == *(u_short *)(&addr2->a[2]) &&\n\t       *(u_short *)(&addr1->a[4]) == *(u_short *)(&addr2->a[4]);\n}\n\n \nstatic const u_short plist_nif[] = { SMT_P_UNA,SMT_P_SDE,SMT_P_STATE,0 } ;\n\n \nvoid smt_agent_init(struct s_smc *smc)\n{\n\tint\t\ti ;\n\n\t \n\tsmc->mib.m[MAC0].fddiMACSMTAddress = smc->hw.fddi_home_addr ;\n\n\t \n\tsmc->mib.fddiSMTStationId.sid_oem[0] = 0 ;\n\tsmc->mib.fddiSMTStationId.sid_oem[1] = 0 ;\n\tdriver_get_bia(smc,&smc->mib.fddiSMTStationId.sid_node) ;\n\tfor (i = 0 ; i < 6 ; i ++) {\n\t\tsmc->mib.fddiSMTStationId.sid_node.a[i] =\n\t\t\tbitrev8(smc->mib.fddiSMTStationId.sid_node.a[i]);\n\t}\n\tsmc->mib.fddiSMTManufacturerData[0] =\n\t\tsmc->mib.fddiSMTStationId.sid_node.a[0] ;\n\tsmc->mib.fddiSMTManufacturerData[1] =\n\t\tsmc->mib.fddiSMTStationId.sid_node.a[1] ;\n\tsmc->mib.fddiSMTManufacturerData[2] =\n\t\tsmc->mib.fddiSMTStationId.sid_node.a[2] ;\n\tsmc->sm.smt_tid = 0 ;\n\tsmc->mib.m[MAC0].fddiMACDupAddressTest = DA_NONE ;\n\tsmc->mib.m[MAC0].fddiMACUNDA_Flag = FALSE ;\n#ifndef\tSLIM_SMT\n\tsmt_clear_una_dna(smc) ;\n\tsmt_clear_old_una_dna(smc) ;\n#endif\n\tfor (i = 0 ; i < SMT_MAX_TEST ; i++)\n\t\tsmc->sm.pend[i] = 0 ;\n\tsmc->sm.please_reconnect = 0 ;\n\tsmc->sm.uniq_ticks = 0 ;\n}\n\n \nvoid smt_agent_task(struct s_smc *smc)\n{\n\tsmt_timer_start(smc,&smc->sm.smt_timer, (u_long)1000000L,\n\t\tEV_TOKEN(EVENT_SMT,SM_TIMER)) ;\n\tDB_SMT(\"SMT agent task\");\n}\n\n#ifndef SMT_REAL_TOKEN_CT\nvoid smt_emulate_token_ct(struct s_smc *smc, int mac_index)\n{\n\tu_long\tcount;\n\tu_long\ttime;\n\n\n\ttime = smt_get_time();\n\tcount =\t((time - smc->sm.last_tok_time[mac_index]) *\n\t\t\t\t\t100)/TICKS_PER_SECOND;\n\n\t \n\tif (smc->hw.mac_ring_is_up){\n\t\tsmc->mib.m[mac_index].fddiMACToken_Ct += count;\n\t}\n\n\t \n\tsmc->sm.last_tok_time[mac_index] = time;\n\n}\n#endif\n\n \nvoid smt_event(struct s_smc *smc, int event)\n{\n\tu_long\t\ttime ;\n#ifndef SMT_REAL_TOKEN_CT\n\tint\t\ti ;\n#endif\n\n\n\tif (smc->sm.please_reconnect) {\n\t\tsmc->sm.please_reconnect -- ;\n\t\tif (smc->sm.please_reconnect == 0) {\n\t\t\t \n\t\t\tqueue_event(smc,EVENT_ECM,EC_CONNECT) ;\n\t\t}\n\t}\n\n\tif (event == SM_FAST)\n\t\treturn ;\n\n\t \n\tsmt_timer_poll(smc) ;\n\tsmt_start_watchdog(smc) ;\n#ifndef\tSLIM_SMT\n#ifndef BOOT\n#ifdef\tESS\n\tess_timer_poll(smc) ;\n#endif\n#endif\n#ifdef\tSBA\n\tsba_timer_poll(smc) ;\n#endif\n\n\tsmt_srf_event(smc,0,0,0) ;\n\n#endif\t \n\n\ttime = smt_get_time() ;\n\n\tif (time - smc->sm.smt_last_lem >= TICKS_PER_SECOND*8) {\n\t\t \n\t\tstruct fddi_mib_m\t*mib ;\n\t\tu_long\t\t\tupper ;\n\t\tu_long\t\t\tlower ;\n\t\tint\t\t\tcond ;\n\t\tint\t\t\tport;\n\t\tstruct s_phy\t\t*phy ;\n\t\t \n\t\tsm_lem_evaluate(smc) ;\n\t\tsmc->sm.smt_last_lem = time ;\n\n\t\t \n#ifndef\tSLIM_SMT\n\t\tmac_update_counter(smc) ;\n\t\tmib = smc->mib.m ;\n\t\tupper =\n\t\t(mib->fddiMACLost_Ct - mib->fddiMACOld_Lost_Ct) +\n\t\t(mib->fddiMACError_Ct - mib->fddiMACOld_Error_Ct) ;\n\t\tlower =\n\t\t(mib->fddiMACFrame_Ct - mib->fddiMACOld_Frame_Ct) +\n\t\t(mib->fddiMACLost_Ct - mib->fddiMACOld_Lost_Ct) ;\n\t\tmib->fddiMACFrameErrorRatio = div_ratio(upper,lower) ;\n\n\t\tcond =\n\t\t\t((!mib->fddiMACFrameErrorThreshold &&\n\t\t\tmib->fddiMACError_Ct != mib->fddiMACOld_Error_Ct) ||\n\t\t\t(mib->fddiMACFrameErrorRatio >\n\t\t\tmib->fddiMACFrameErrorThreshold)) ;\n\n\t\tif (cond != mib->fddiMACFrameErrorFlag)\n\t\t\tsmt_srf_event(smc,SMT_COND_MAC_FRAME_ERROR,\n\t\t\t\tINDEX_MAC,cond) ;\n\n\t\tupper =\n\t\t(mib->fddiMACNotCopied_Ct - mib->fddiMACOld_NotCopied_Ct) ;\n\t\tlower =\n\t\tupper +\n\t\t(mib->fddiMACCopied_Ct - mib->fddiMACOld_Copied_Ct) ;\n\t\tmib->fddiMACNotCopiedRatio = div_ratio(upper,lower) ;\n\n\t\tcond =\n\t\t\t((!mib->fddiMACNotCopiedThreshold &&\n\t\t\tmib->fddiMACNotCopied_Ct !=\n\t\t\t\tmib->fddiMACOld_NotCopied_Ct)||\n\t\t\t(mib->fddiMACNotCopiedRatio >\n\t\t\tmib->fddiMACNotCopiedThreshold)) ;\n\n\t\tif (cond != mib->fddiMACNotCopiedFlag)\n\t\t\tsmt_srf_event(smc,SMT_COND_MAC_NOT_COPIED,\n\t\t\t\tINDEX_MAC,cond) ;\n\n\t\t \n\t\tmib->fddiMACOld_Frame_Ct = mib->fddiMACFrame_Ct ;\n\t\tmib->fddiMACOld_Copied_Ct = mib->fddiMACCopied_Ct ;\n\t\tmib->fddiMACOld_Error_Ct = mib->fddiMACError_Ct ;\n\t\tmib->fddiMACOld_Lost_Ct = mib->fddiMACLost_Ct ;\n\t\tmib->fddiMACOld_NotCopied_Ct = mib->fddiMACNotCopied_Ct ;\n\n\t\t \n\t\tfor (port = 0; port < NUMPHYS; port ++) {\n\t\t\tphy = &smc->y[port] ;\n\n\t\t\tif (!phy->mib->fddiPORTHardwarePresent) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcond = (phy->mib->fddiPORTEBError_Ct -\n\t\t\t\tphy->mib->fddiPORTOldEBError_Ct > 5) ;\n\n\t\t\t \n\t\t\tsmt_srf_event(smc,SMT_COND_PORT_EB_ERROR,\n\t\t\t\t(int) (INDEX_PORT+ phy->np) ,cond) ;\n\n\t\t\t \n\t\t\tphy->mib->fddiPORTOldEBError_Ct =\n\t\t\t\tphy->mib->fddiPORTEBError_Ct ;\n\t\t}\n\n#endif\t \n\t}\n\n#ifndef\tSLIM_SMT\n\n\tif (time - smc->sm.smt_last_notify >= (u_long)\n\t\t(smc->mib.fddiSMTTT_Notify * TICKS_PER_SECOND) ) {\n\t\t \n\t\tif (!smc->sm.pend[SMT_TID_NIF])\n\t\t\tsmc->sm.pend[SMT_TID_NIF] = smt_get_tid(smc) ;\n\t\tsmt_send_nif(smc,&fddi_broadcast, FC_SMT_NSA,\n\t\t\tsmc->sm.pend[SMT_TID_NIF], SMT_REQUEST,0) ;\n\t\tsmc->sm.smt_last_notify = time ;\n\t}\n\n\t \n\tif (smc->sm.smt_tvu &&\n\t    time - smc->sm.smt_tvu > 228*TICKS_PER_SECOND) {\n\t\tDB_SMT(\"SMT : UNA expired\");\n\t\tsmc->sm.smt_tvu = 0 ;\n\n\t\tif (!is_equal(&smc->mib.m[MAC0].fddiMACUpstreamNbr,\n\t\t\t&SMT_Unknown)){\n\t\t\t \n\t\t\tsmc->mib.m[MAC0].fddiMACOldUpstreamNbr=\n\t\t\t\tsmc->mib.m[MAC0].fddiMACUpstreamNbr ;\n\t\t}\n\t\tsmc->mib.m[MAC0].fddiMACUpstreamNbr = SMT_Unknown ;\n\t\tsmc->mib.m[MAC0].fddiMACUNDA_Flag = FALSE ;\n\t\t \n\t\tupdate_dac(smc,0) ;\n\t\tsmt_srf_event(smc, SMT_EVENT_MAC_NEIGHBOR_CHANGE,\n\t\t\tINDEX_MAC,0) ;\n\t}\n\tif (smc->sm.smt_tvd &&\n\t    time - smc->sm.smt_tvd > 228*TICKS_PER_SECOND) {\n\t\tDB_SMT(\"SMT : DNA expired\");\n\t\tsmc->sm.smt_tvd = 0 ;\n\t\tif (!is_equal(&smc->mib.m[MAC0].fddiMACDownstreamNbr,\n\t\t\t&SMT_Unknown)){\n\t\t\t \n\t\t\tsmc->mib.m[MAC0].fddiMACOldDownstreamNbr=\n\t\t\t\tsmc->mib.m[MAC0].fddiMACDownstreamNbr ;\n\t\t}\n\t\tsmc->mib.m[MAC0].fddiMACDownstreamNbr = SMT_Unknown ;\n\t\tsmt_srf_event(smc, SMT_EVENT_MAC_NEIGHBOR_CHANGE,\n\t\t\tINDEX_MAC,0) ;\n\t}\n\n#endif\t \n\n#ifndef SMT_REAL_TOKEN_CT\n\t \n\tfor (i = MAC0; i < NUMMACS; i++ ){\n\t\tif (time - smc->sm.last_tok_time[i] > 2*TICKS_PER_SECOND ){\n\t\t\tsmt_emulate_token_ct( smc, i );\n\t\t}\n\t}\n#endif\n\n\tsmt_timer_start(smc,&smc->sm.smt_timer, (u_long)1000000L,\n\t\tEV_TOKEN(EVENT_SMT,SM_TIMER)) ;\n}\n\nstatic int div_ratio(u_long upper, u_long lower)\n{\n\tif ((upper<<16L) < upper)\n\t\tupper = 0xffff0000L ;\n\telse\n\t\tupper <<= 16L ;\n\tif (!lower)\n\t\treturn 0;\n\treturn (int)(upper/lower) ;\n}\n\n#ifndef\tSLIM_SMT\n\n \nvoid smt_received_pack(struct s_smc *smc, SMbuf *mb, int fs)\n \n{\n\tstruct smt_header\t*sm ;\n\tint\t\t\tlocal ;\n\n\tint\t\t\tillegal = 0 ;\n\n\tswitch (m_fc(mb)) {\n\tcase FC_SMT_INFO :\n\tcase FC_SMT_LAN_LOC :\n\tcase FC_SMT_LOC :\n\tcase FC_SMT_NSA :\n\t\tbreak ;\n\tdefault :\n\t\tsmt_free_mbuf(smc,mb) ;\n\t\treturn ;\n\t}\n\n\tsmc->mib.m[MAC0].fddiMACSMTCopied_Ct++ ;\n\tsm = smtod(mb,struct smt_header *) ;\n\tlocal = ((fs & L_INDICATOR) != 0) ;\n\thwm_conv_can(smc,(char *)sm,12) ;\n\n\t \n\tif (is_individual(&sm->smt_dest) && !is_my_addr(smc,&sm->smt_dest)) {\n\t\tsmt_free_mbuf(smc,mb) ;\n\t\treturn ;\n\t}\n#if\t0\t\t \n\t \n\tif (is_my_addr(smc,&sm->smt_source) && !local) {\n\t\tsmt_free_mbuf(smc,mb) ;\n\t\treturn ;\n\t}\n#endif\n\n\tsmt_swap_para(sm,(int) mb->sm_len,1) ;\n\tDB_SMT(\"SMT : received packet [%s] at 0x%p\",\n\t       smt_type_name[m_fc(mb) & 0xf], sm);\n\tDB_SMT(\"SMT : version %d, class %s\",\n\t       sm->smt_version,\n\t       smt_class_name[sm->smt_class > LAST_CLASS ? 0 : sm->smt_class]);\n\n#ifdef\tSBA\n\t \n\tif (m_fc(mb) == FC_SMT_NSA && sm->smt_class == SMT_NIF &&\n\t\t(sm->smt_type == SMT_ANNOUNCE || sm->smt_type == SMT_REQUEST)) {\n\t\t\tsmc->sba.sm = sm ;\n\t\t\tsba(smc,NIF) ;\n\t}\n#endif\n\n\t \n\tif ( (fs & A_INDICATOR) && m_fc(mb) == FC_SMT_NSA) {\n\t\tDB_SMT(\"SMT : ignoring NSA with A-indicator set from %pM\",\n\t\t       &sm->smt_source);\n\t\tsmt_free_mbuf(smc,mb) ;\n\t\treturn ;\n\t}\n\n\t \n\tif (((sm->smt_class == SMT_ECF) && (sm->smt_len > SMT_MAX_ECHO_LEN)) ||\n\t    ((sm->smt_class != SMT_ECF) && (sm->smt_len > SMT_MAX_INFO_LEN))) {\n\t\tsmt_free_mbuf(smc,mb) ;\n\t\treturn ;\n\t}\n\n\t \n\tswitch (sm->smt_class) {\n\tcase SMT_NIF :\n\tcase SMT_SIF_CONFIG :\n\tcase SMT_SIF_OPER :\n\tcase SMT_ECF :\n\t\tif (sm->smt_version != SMT_VID)\n\t\t\tillegal = 1;\n\t\tbreak ;\n\tdefault :\n\t\tif (sm->smt_version != SMT_VID_2)\n\t\t\tillegal = 1;\n\t\tbreak ;\n\t}\n\tif (illegal) {\n\t\tDB_SMT(\"SMT : version = %d, dest = %pM\",\n\t\t       sm->smt_version, &sm->smt_source);\n\t\tsmt_send_rdf(smc,mb,m_fc(mb),SMT_RDF_VERSION,local) ;\n\t\tsmt_free_mbuf(smc,mb) ;\n\t\treturn ;\n\t}\n\tif ((sm->smt_len > mb->sm_len - sizeof(struct smt_header)) ||\n\t    ((sm->smt_len & 3) && (sm->smt_class != SMT_ECF))) {\n\t\tDB_SMT(\"SMT: info length error, len = %d\", sm->smt_len);\n\t\tsmt_send_rdf(smc,mb,m_fc(mb),SMT_RDF_LENGTH,local) ;\n\t\tsmt_free_mbuf(smc,mb) ;\n\t\treturn ;\n\t}\n\tswitch (sm->smt_class) {\n\tcase SMT_NIF :\n\t\tif (smt_check_para(smc,sm,plist_nif)) {\n\t\t\tDB_SMT(\"SMT: NIF with para problem, ignoring\");\n\t\t\tbreak ;\n\t\t}\n\t\tswitch (sm->smt_type) {\n\t\tcase SMT_ANNOUNCE :\n\t\tcase SMT_REQUEST :\n\t\t\tif (!(fs & C_INDICATOR) && m_fc(mb) == FC_SMT_NSA\n\t\t\t\t&& is_broadcast(&sm->smt_dest)) {\n\t\t\t\tstruct smt_p_state\t*st ;\n\n\t\t\t\t \n\t\t\t\tif (!is_equal(\n\t\t\t\t\t&smc->mib.m[MAC0].fddiMACUpstreamNbr,\n\t\t\t\t\t&sm->smt_source)) {\n\t\t\t\t\tDB_SMT(\"SMT : updated my UNA = %pM\",\n\t\t\t\t\t       &sm->smt_source);\n\t\t\t\t\tif (!is_equal(&smc->mib.m[MAC0].\n\t\t\t\t\t    fddiMACUpstreamNbr,&SMT_Unknown)){\n\t\t\t\t\t  \n\t\t\t\t\t smc->mib.m[MAC0].fddiMACOldUpstreamNbr=\n\t\t\t\t\t smc->mib.m[MAC0].fddiMACUpstreamNbr ;\n\t\t\t\t\t}\n\n\t\t\t\t\tsmc->mib.m[MAC0].fddiMACUpstreamNbr =\n\t\t\t\t\t\tsm->smt_source ;\n\t\t\t\t\tsmt_srf_event(smc,\n\t\t\t\t\t\tSMT_EVENT_MAC_NEIGHBOR_CHANGE,\n\t\t\t\t\t\tINDEX_MAC,0) ;\n\t\t\t\t\tsmt_echo_test(smc,0) ;\n\t\t\t\t}\n\t\t\t\tsmc->sm.smt_tvu = smt_get_time() ;\n\t\t\t\tst = (struct smt_p_state *)\n\t\t\t\t\tsm_to_para(smc,sm,SMT_P_STATE) ;\n\t\t\t\tif (st) {\n\t\t\t\t\tsmc->mib.m[MAC0].fddiMACUNDA_Flag =\n\t\t\t\t\t(st->st_dupl_addr & SMT_ST_MY_DUPA) ?\n\t\t\t\t\tTRUE : FALSE ;\n\t\t\t\t\tupdate_dac(smc,1) ;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((sm->smt_type == SMT_REQUEST) &&\n\t\t\t    is_individual(&sm->smt_source) &&\n\t\t\t    ((!(fs & A_INDICATOR) && m_fc(mb) == FC_SMT_NSA) ||\n\t\t\t     (m_fc(mb) != FC_SMT_NSA))) {\n\t\t\t\tDB_SMT(\"SMT : replying to NIF request %pM\",\n\t\t\t\t       &sm->smt_source);\n\t\t\t\tsmt_send_nif(smc,&sm->smt_source,\n\t\t\t\t\tFC_SMT_INFO,\n\t\t\t\t\tsm->smt_tid,\n\t\t\t\t\tSMT_REPLY,local) ;\n\t\t\t}\n\t\t\tbreak ;\n\t\tcase SMT_REPLY :\n\t\t\tDB_SMT(\"SMT : received NIF response from %pM\",\n\t\t\t       &sm->smt_source);\n\t\t\tif (fs & A_INDICATOR) {\n\t\t\t\tsmc->sm.pend[SMT_TID_NIF] = 0 ;\n\t\t\t\tDB_SMT(\"SMT : duplicate address\");\n\t\t\t\tsmc->mib.m[MAC0].fddiMACDupAddressTest =\n\t\t\t\t\tDA_FAILED ;\n\t\t\t\tsmc->r.dup_addr_test = DA_FAILED ;\n\t\t\t\tqueue_event(smc,EVENT_RMT,RM_DUP_ADDR) ;\n\t\t\t\tsmc->mib.m[MAC0].fddiMACDA_Flag = TRUE ;\n\t\t\t\tupdate_dac(smc,1) ;\n\t\t\t\tbreak ;\n\t\t\t}\n\t\t\tif (sm->smt_tid == smc->sm.pend[SMT_TID_NIF]) {\n\t\t\t\tsmc->sm.pend[SMT_TID_NIF] = 0 ;\n\t\t\t\t \n\t\t\t\tif (!is_equal(\n\t\t\t\t\t&smc->mib.m[MAC0].fddiMACDownstreamNbr,\n\t\t\t\t\t&sm->smt_source)) {\n\t\t\t\t\tDB_SMT(\"SMT : updated my DNA\");\n\t\t\t\t\tif (!is_equal(&smc->mib.m[MAC0].\n\t\t\t\t\t fddiMACDownstreamNbr, &SMT_Unknown)){\n\t\t\t\t\t  \n\t\t\t\tsmc->mib.m[MAC0].fddiMACOldDownstreamNbr =\n\t\t\t\t\t smc->mib.m[MAC0].fddiMACDownstreamNbr ;\n\t\t\t\t\t}\n\n\t\t\t\t\tsmc->mib.m[MAC0].fddiMACDownstreamNbr =\n\t\t\t\t\t\tsm->smt_source ;\n\t\t\t\t\tsmt_srf_event(smc,\n\t\t\t\t\t\tSMT_EVENT_MAC_NEIGHBOR_CHANGE,\n\t\t\t\t\t\tINDEX_MAC,0) ;\n\t\t\t\t\tsmt_echo_test(smc,1) ;\n\t\t\t\t}\n\t\t\t\tsmc->mib.m[MAC0].fddiMACDA_Flag = FALSE ;\n\t\t\t\tupdate_dac(smc,1) ;\n\t\t\t\tsmc->sm.smt_tvd = smt_get_time() ;\n\t\t\t\tsmc->mib.m[MAC0].fddiMACDupAddressTest =\n\t\t\t\t\tDA_PASSED ;\n\t\t\t\tif (smc->r.dup_addr_test != DA_PASSED) {\n\t\t\t\t\tsmc->r.dup_addr_test = DA_PASSED ;\n\t\t\t\t\tqueue_event(smc,EVENT_RMT,RM_DUP_ADDR) ;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (sm->smt_tid ==\n\t\t\t\tsmc->sm.pend[SMT_TID_NIF_TEST]) {\n\t\t\t\tDB_SMT(\"SMT : NIF test TID ok\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDB_SMT(\"SMT : expected TID %lx, got %x\",\n\t\t\t\t       smc->sm.pend[SMT_TID_NIF], sm->smt_tid);\n\t\t\t}\n\t\t\tbreak ;\n\t\tdefault :\n\t\t\tillegal = 2 ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak ;\n\tcase SMT_SIF_CONFIG :\t \n\t\tif (sm->smt_type != SMT_REQUEST)\n\t\t\tbreak ;\n\t\tDB_SMT(\"SMT : replying to SIF Config request from %pM\",\n\t\t       &sm->smt_source);\n\t\tsmt_send_sif_config(smc,&sm->smt_source,sm->smt_tid,local) ;\n\t\tbreak ;\n\tcase SMT_SIF_OPER :\t \n\t\tif (sm->smt_type != SMT_REQUEST)\n\t\t\tbreak ;\n\t\tDB_SMT(\"SMT : replying to SIF Operation request from %pM\",\n\t\t       &sm->smt_source);\n\t\tsmt_send_sif_operation(smc,&sm->smt_source,sm->smt_tid,local) ;\n\t\tbreak ;\n\tcase SMT_ECF :\t\t \n\t\tswitch (sm->smt_type) {\n\t\tcase SMT_REPLY :\n\t\t\tsmc->mib.priv.fddiPRIVECF_Reply_Rx++ ;\n\t\t\tDB_SMT(\"SMT: received ECF reply from %pM\",\n\t\t\t       &sm->smt_source);\n\t\t\tif (sm_to_para(smc,sm,SMT_P_ECHODATA) == NULL) {\n\t\t\t\tDB_SMT(\"SMT: ECHODATA missing\");\n\t\t\t\tbreak ;\n\t\t\t}\n\t\t\tif (sm->smt_tid == smc->sm.pend[SMT_TID_ECF]) {\n\t\t\t\tDB_SMT(\"SMT : ECF test TID ok\");\n\t\t\t}\n\t\t\telse if (sm->smt_tid == smc->sm.pend[SMT_TID_ECF_UNA]) {\n\t\t\t\tDB_SMT(\"SMT : ECF test UNA ok\");\n\t\t\t}\n\t\t\telse if (sm->smt_tid == smc->sm.pend[SMT_TID_ECF_DNA]) {\n\t\t\t\tDB_SMT(\"SMT : ECF test DNA ok\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDB_SMT(\"SMT : expected TID %lx, got %x\",\n\t\t\t\t       smc->sm.pend[SMT_TID_ECF],\n\t\t\t\t       sm->smt_tid);\n\t\t\t}\n\t\t\tbreak ;\n\t\tcase SMT_REQUEST :\n\t\t\tsmc->mib.priv.fddiPRIVECF_Req_Rx++ ;\n\t\t\t{\n\t\t\tif (sm->smt_len && !sm_to_para(smc,sm,SMT_P_ECHODATA)) {\n\t\t\t\tDB_SMT(\"SMT: ECF with para problem,sending RDF\");\n\t\t\t\tsmt_send_rdf(smc,mb,m_fc(mb),SMT_RDF_LENGTH,\n\t\t\t\t\tlocal) ;\n\t\t\t\tbreak ;\n\t\t\t}\n\t\t\tDB_SMT(\"SMT - sending ECF reply to %pM\",\n\t\t\t       &sm->smt_source);\n\n\t\t\t \n\t\t\tsm->smt_dest = sm->smt_source ;\n\t\t\tsm->smt_type = SMT_REPLY ;\n\t\t\tdump_smt(smc,sm,\"ECF REPLY\") ;\n\t\t\tsmc->mib.priv.fddiPRIVECF_Reply_Tx++ ;\n\t\t\tsmt_send_frame(smc,mb,FC_SMT_INFO,local) ;\n\t\t\treturn ;\t\t \n\t\t\t}\n\t\tdefault :\n\t\t\tillegal = 1 ;\n\t\t\tbreak ;\n\t\t}\n\t\tbreak ;\n#ifndef\tBOOT\n\tcase SMT_RAF :\t\t \n#ifdef\tESS\n\t\tDB_ESSN(2, \"ESS: RAF frame received\");\n\t\tfs = ess_raf_received_pack(smc,mb,sm,fs) ;\n#endif\n\n#ifdef\tSBA\n\t\tDB_SBAN(2, \"SBA: RAF frame received\") ;\n\t\tsba_raf_received_pack(smc,sm,fs) ;\n#endif\n\t\tbreak ;\n\tcase SMT_RDF :\t\t \n\t\tsmc->mib.priv.fddiPRIVRDF_Rx++ ;\n\t\tbreak ;\n\tcase SMT_ESF :\t\t \n\t\tif (sm->smt_type == SMT_REQUEST) {\n\t\t\tDB_SMT(\"SMT - received ESF, sending RDF\");\n\t\t\tsmt_send_rdf(smc,mb,m_fc(mb),SMT_RDF_CLASS,local) ;\n\t\t}\n\t\tbreak ;\n\tcase SMT_PMF_GET :\n\tcase SMT_PMF_SET :\n\t\tif (sm->smt_type != SMT_REQUEST)\n\t\t\tbreak ;\n\t\t \n\t\tif (sm->smt_class == SMT_PMF_GET)\n\t\t\tsmc->mib.priv.fddiPRIVPMF_Get_Rx++ ;\n\t\telse\n\t\t\tsmc->mib.priv.fddiPRIVPMF_Set_Rx++ ;\n\t\t \n\t\tif ((sm->smt_class == SMT_PMF_SET) &&\n\t\t\t!is_individual(&sm->smt_dest)) {\n\t\t\tDB_SMT(\"SMT: ignoring PMF-SET with I/G set\");\n\t\t\tbreak ;\n\t\t}\n\t\tsmt_pmf_received_pack(smc,mb, local) ;\n\t\tbreak ;\n\tcase SMT_SRF :\n\t\tdump_smt(smc,sm,\"SRF received\") ;\n\t\tbreak ;\n\tdefault :\n\t\tif (sm->smt_type != SMT_REQUEST)\n\t\t\tbreak ;\n\t\t \n\t\tDB_SMT(\"SMT : class = %d, send RDF to %pM\",\n\t\t       sm->smt_class, &sm->smt_source);\n\n\t\tsmt_send_rdf(smc,mb,m_fc(mb),SMT_RDF_CLASS,local) ;\n\t\tbreak ;\n#endif\n\t}\n\tif (illegal) {\n\t\tDB_SMT(\"SMT: discarding invalid frame, reason = %d\", illegal);\n\t}\n\tsmt_free_mbuf(smc,mb) ;\n}\n\nstatic void update_dac(struct s_smc *smc, int report)\n{\n\tint\tcond ;\n\n\tcond = ( smc->mib.m[MAC0].fddiMACUNDA_Flag |\n\t\tsmc->mib.m[MAC0].fddiMACDA_Flag) != 0 ;\n\tif (report && (cond != smc->mib.m[MAC0].fddiMACDuplicateAddressCond))\n\t\tsmt_srf_event(smc, SMT_COND_MAC_DUP_ADDR,INDEX_MAC,cond) ;\n\telse\n\t\tsmc->mib.m[MAC0].fddiMACDuplicateAddressCond = cond ;\n}\n\n \nvoid smt_send_frame(struct s_smc *smc, SMbuf *mb, int fc, int local)\n \n \n{\n\tstruct smt_header\t*sm ;\n\n\tif (!smc->r.sm_ma_avail && !local) {\n\t\tsmt_free_mbuf(smc,mb) ;\n\t\treturn ;\n\t}\n\tsm = smtod(mb,struct smt_header *) ;\n\tsm->smt_source = smc->mib.m[MAC0].fddiMACSMTAddress ;\n\tsm->smt_sid = smc->mib.fddiSMTStationId ;\n\n\tsmt_swap_para(sm,(int) mb->sm_len,0) ;\t\t \n\thwm_conv_can(smc,(char *)sm,12) ;\t\t \n\tsmc->mib.m[MAC0].fddiMACSMTTransmit_Ct++ ;\n\tsmt_send_mbuf(smc,mb,local ? FC_SMT_LOC : fc) ;\n}\n\n \nstatic void smt_send_rdf(struct s_smc *smc, SMbuf *rej, int fc, int reason,\n\t\t\t int local)\n \n \n \n{\n\tSMbuf\t*mb ;\n\tstruct smt_header\t*sm ;\t \n\tstruct smt_rdf\t*rdf ;\n\tint\t\tlen ;\n\tint\t\tframe_len ;\n\n\tsm = smtod(rej,struct smt_header *) ;\n\tif (sm->smt_type != SMT_REQUEST)\n\t\treturn ;\n\n\tDB_SMT(\"SMT: sending RDF to %pM,reason = 0x%x\",\n\t       &sm->smt_source, reason);\n\n\n\t \n\tframe_len = rej->sm_len ;\n\n\tif (!(mb=smt_build_frame(smc,SMT_RDF,SMT_REPLY,sizeof(struct smt_rdf))))\n\t\treturn ;\n\trdf = smtod(mb,struct smt_rdf *) ;\n\trdf->smt.smt_tid = sm->smt_tid ;\t\t \n\trdf->smt.smt_dest = sm->smt_source ;\t\t \n\n\t \n\trdf->reason.para.p_type = SMT_P_REASON ;\n\trdf->reason.para.p_len = sizeof(struct smt_p_reason) - PARA_LEN ;\n\trdf->reason.rdf_reason = reason ;\n\n\t \n\trdf->version.para.p_type = SMT_P_VERSION ;\n\trdf->version.para.p_len = sizeof(struct smt_p_version) - PARA_LEN ;\n\trdf->version.v_pad = 0 ;\n\trdf->version.v_n = 1 ;\n\trdf->version.v_index = 1 ;\n\trdf->version.v_version[0] = SMT_VID_2 ;\n\trdf->version.v_pad2 = 0 ;\n\n\t \n\tif ((unsigned int) frame_len <= SMT_MAX_INFO_LEN - sizeof(*rdf) +\n\t\t2*sizeof(struct smt_header))\n\t\tlen = frame_len ;\n\telse\n\t\tlen = SMT_MAX_INFO_LEN - sizeof(*rdf) +\n\t\t\t2*sizeof(struct smt_header) ;\n\t \n\tlen &= ~3 ;\n\trdf->refused.para.p_type = SMT_P_REFUSED ;\n\t \n\trdf->refused.para.p_len = len + 4 ;\n\trdf->refused.ref_fc = fc ;\n\n\t \n\tsmt_swap_para(sm,frame_len,0) ;\n\n\tmemcpy((char *) &rdf->refused.ref_header,(char *) sm,len) ;\n\n\tlen -= sizeof(struct smt_header) ;\n\tmb->sm_len += len ;\n\trdf->smt.smt_len += len ;\n\n\tdump_smt(smc,(struct smt_header *)rdf,\"RDF\") ;\n\tsmc->mib.priv.fddiPRIVRDF_Tx++ ;\n\tsmt_send_frame(smc,mb,FC_SMT_INFO,local) ;\n}\n\n \nstatic void smt_send_nif(struct s_smc *smc, const struct fddi_addr *dest, \n\t\t\t int fc, u_long tid, int type, int local)\n \n \n \n \n{\n\tstruct smt_nif\t*nif ;\n\tSMbuf\t\t*mb ;\n\n\tif (!(mb = smt_build_frame(smc,SMT_NIF,type,sizeof(struct smt_nif))))\n\t\treturn ;\n\tnif = smtod(mb, struct smt_nif *) ;\n\tsmt_fill_una(smc,&nif->una) ;\t \n\tsmt_fill_sde(smc,&nif->sde) ;\t \n\tsmt_fill_state(smc,&nif->state) ;\t \n#ifdef\tSMT6_10\n\tsmt_fill_fsc(smc,&nif->fsc) ;\t \n#endif\n\tnif->smt.smt_dest = *dest ;\t \n\tnif->smt.smt_tid = tid ;\t \n\tdump_smt(smc,(struct smt_header *)nif,\"NIF\") ;\n\tsmt_send_frame(smc,mb,fc,local) ;\n}\n\n#ifdef\tDEBUG\n \nstatic void smt_send_nif_request(struct s_smc *smc, struct fddi_addr *dest)\n{\n\tsmc->sm.pend[SMT_TID_NIF_TEST] = smt_get_tid(smc) ;\n\tsmt_send_nif(smc,dest, FC_SMT_INFO, smc->sm.pend[SMT_TID_NIF_TEST],\n\t\tSMT_REQUEST,0) ;\n}\n\n \nstatic void smt_send_ecf_request(struct s_smc *smc, struct fddi_addr *dest,\n\t\t\t\t int len)\n{\n\tsmc->sm.pend[SMT_TID_ECF] = smt_get_tid(smc) ;\n\tsmt_send_ecf(smc,dest, FC_SMT_INFO, smc->sm.pend[SMT_TID_ECF],\n\t\tSMT_REQUEST,len) ;\n}\n#endif\n\n \nstatic void smt_echo_test(struct s_smc *smc, int dna)\n{\n\tu_long\ttid ;\n\n\tsmc->sm.pend[dna ? SMT_TID_ECF_DNA : SMT_TID_ECF_UNA] =\n\t\ttid = smt_get_tid(smc) ;\n\tsmt_send_ecf(smc, dna ?\n\t\t&smc->mib.m[MAC0].fddiMACDownstreamNbr :\n\t\t&smc->mib.m[MAC0].fddiMACUpstreamNbr,\n\t\tFC_SMT_INFO,tid, SMT_REQUEST, (SMT_TEST_ECHO_LEN & ~3)-8) ;\n}\n\n \nstatic void smt_send_ecf(struct s_smc *smc, struct fddi_addr *dest, int fc,\n\t\t\t u_long tid, int type, int len)\n \n \n \n \n \n{\n\tstruct smt_ecf\t*ecf ;\n\tSMbuf\t\t*mb ;\n\n\tif (!(mb = smt_build_frame(smc,SMT_ECF,type,SMT_ECF_LEN + len)))\n\t\treturn ;\n\tecf = smtod(mb, struct smt_ecf *) ;\n\n\tsmt_fill_echo(smc,&ecf->ec_echo,tid,len) ;\t \n\tecf->smt.smt_dest = *dest ;\t \n\tecf->smt.smt_tid = tid ;\t \n\tsmc->mib.priv.fddiPRIVECF_Req_Tx++ ;\n\tsmt_send_frame(smc,mb,fc,0) ;\n}\n\n \n\nstatic void smt_send_sif_config(struct s_smc *smc, struct fddi_addr *dest,\n\t\t\t\tu_long tid, int local)\n \n \n{\n\tstruct smt_sif_config\t*sif ;\n\tSMbuf\t\t\t*mb ;\n\tint\t\t\tlen ;\n\tif (!(mb = smt_build_frame(smc,SMT_SIF_CONFIG,SMT_REPLY,\n\t\tSIZEOF_SMT_SIF_CONFIG)))\n\t\treturn ;\n\n\tsif = smtod(mb, struct smt_sif_config *) ;\n\tsmt_fill_timestamp(smc,&sif->ts) ;\t \n\tsmt_fill_sde(smc,&sif->sde) ;\t\t \n\tsmt_fill_version(smc,&sif->version) ;\t \n\tsmt_fill_state(smc,&sif->state) ;\t \n\tsmt_fill_policy(smc,&sif->policy) ;\t \n\tsmt_fill_latency(smc,&sif->latency);\t \n\tsmt_fill_neighbor(smc,&sif->neighbor);\t \n\tsmt_fill_setcount(smc,&sif->setcount) ;\t \n\tlen = smt_fill_path(smc,&sif->path);\t \n\tsif->smt.smt_dest = *dest ;\t\t \n\tsif->smt.smt_tid = tid ;\t\t \n\tsmt_add_frame_len(mb,len) ;\t\t \n\tdump_smt(smc,(struct smt_header *)sif,\"SIF Configuration Reply\") ;\n\tsmt_send_frame(smc,mb,FC_SMT_INFO,local) ;\n}\n\n \n\nstatic void smt_send_sif_operation(struct s_smc *smc, struct fddi_addr *dest,\n\t\t\t\t   u_long tid, int local)\n \n \n{\n\tstruct smt_sif_operation *sif ;\n\tSMbuf\t\t\t*mb ;\n\tint\t\t\tports ;\n\tint\t\t\ti ;\n\n\tports = NUMPHYS ;\n#ifndef\tCONCENTRATOR\n\tif (smc->s.sas == SMT_SAS)\n\t\tports = 1 ;\n#endif\n\n\tif (!(mb = smt_build_frame(smc,SMT_SIF_OPER,SMT_REPLY,\n\t\t\t\t   struct_size(sif, lem, ports))))\n\t\treturn ;\n\tsif = smtod(mb, typeof(sif));\n\tsmt_fill_timestamp(smc,&sif->ts) ;\t \n\tsmt_fill_mac_status(smc,&sif->status) ;  \n\tsmt_fill_mac_counter(smc,&sif->mc) ;  \n\tsmt_fill_mac_fnc(smc,&sif->fnc) ;  \n\tsmt_fill_manufacturer(smc,&sif->man) ;  \n\tsmt_fill_user(smc,&sif->user) ;\t\t \n\tsmt_fill_setcount(smc,&sif->setcount) ;\t \n\t \n\tif (ports == 1) {\n\t\tsmt_fill_lem(smc,sif->lem,PS) ;\n\t}\n\telse {\n\t\tfor (i = 0 ; i < ports ; i++) {\n\t\t\tsmt_fill_lem(smc,&sif->lem[i],i) ;\n\t\t}\n\t}\n\n\tsif->smt.smt_dest = *dest ;\t \n\tsif->smt.smt_tid = tid ;\t \n\tdump_smt(smc,(struct smt_header *)sif,\"SIF Operation Reply\") ;\n\tsmt_send_frame(smc,mb,FC_SMT_INFO,local) ;\n}\n\n \nSMbuf *smt_build_frame(struct s_smc *smc, int class, int type,\n\t\t\t\t  int length)\n{\n\tSMbuf\t\t\t*mb ;\n\tstruct smt_header\t*smt ;\n\n#if\t0\n\tif (!smc->r.sm_ma_avail) {\n\t\treturn 0;\n\t}\n#endif\n\tif (!(mb = smt_get_mbuf(smc)))\n\t\treturn mb;\n\n\tmb->sm_len = length ;\n\tsmt = smtod(mb, struct smt_header *) ;\n\tsmt->smt_dest = fddi_broadcast ;  \n\tsmt->smt_class = class ;\n\tsmt->smt_type = type ;\n\tswitch (class) {\n\tcase SMT_NIF :\n\tcase SMT_SIF_CONFIG :\n\tcase SMT_SIF_OPER :\n\tcase SMT_ECF :\n\t\tsmt->smt_version = SMT_VID ;\n\t\tbreak ;\n\tdefault :\n\t\tsmt->smt_version = SMT_VID_2 ;\n\t\tbreak ;\n\t}\n\tsmt->smt_tid = smt_get_tid(smc) ;\t \n\tsmt->smt_pad = 0 ;\n\tsmt->smt_len = length - sizeof(struct smt_header) ;\n\treturn mb;\n}\n\nstatic void smt_add_frame_len(SMbuf *mb, int len)\n{\n\tstruct smt_header\t*smt ;\n\n\tsmt = smtod(mb, struct smt_header *) ;\n\tsmt->smt_len += len ;\n\tmb->sm_len += len ;\n}\n\n\n\n \nstatic void smt_fill_una(struct s_smc *smc, struct smt_p_una *una)\n{\n\tSMTSETPARA(una,SMT_P_UNA) ;\n\tuna->una_pad = 0 ;\n\tuna->una_node = smc->mib.m[MAC0].fddiMACUpstreamNbr ;\n}\n\n \nstatic void smt_fill_sde(struct s_smc *smc, struct smt_p_sde *sde)\n{\n\tSMTSETPARA(sde,SMT_P_SDE) ;\n\tsde->sde_non_master = smc->mib.fddiSMTNonMaster_Ct ;\n\tsde->sde_master = smc->mib.fddiSMTMaster_Ct ;\n\tsde->sde_mac_count = NUMMACS ;\t\t \n#ifdef\tCONCENTRATOR\n\tsde->sde_type = SMT_SDE_CONCENTRATOR ;\n#else\n\tsde->sde_type = SMT_SDE_STATION ;\n#endif\n}\n\n \nstatic void smt_fill_state(struct s_smc *smc, struct smt_p_state *state)\n{\n\tint\ttop ;\n\tint\ttwist ;\n\n\tSMTSETPARA(state,SMT_P_STATE) ;\n\tstate->st_pad = 0 ;\n\n\t \n\ttop = 0 ;\n\tif (smc->mib.fddiSMTPeerWrapFlag) {\n\t\ttop |= SMT_ST_WRAPPED ;\t\t \n\t}\n#ifdef\tCONCENTRATOR\n\tif (cfm_status_unattached(smc)) {\n\t\ttop |= SMT_ST_UNATTACHED ;\t \n\t}\n#endif\n\tif ((twist = pcm_status_twisted(smc)) & 1) {\n\t\ttop |= SMT_ST_TWISTED_A ;\t \n\t}\n\tif (twist & 2) {\n\t\ttop |= SMT_ST_TWISTED_B ;\t \n\t}\n#ifdef\tOPT_SRF\n\ttop |= SMT_ST_SRF ;\n#endif\n\tif (pcm_rooted_station(smc))\n\t\ttop |= SMT_ST_ROOTED_S ;\n\tif (smc->mib.a[0].fddiPATHSbaPayload != 0)\n\t\ttop |= SMT_ST_SYNC_SERVICE ;\n\tstate->st_topology = top ;\n\tstate->st_dupl_addr =\n\t\t((smc->mib.m[MAC0].fddiMACDA_Flag ? SMT_ST_MY_DUPA : 0 ) |\n\t\t (smc->mib.m[MAC0].fddiMACUNDA_Flag ? SMT_ST_UNA_DUPA : 0)) ;\n}\n\n \nstatic void smt_fill_timestamp(struct s_smc *smc, struct smt_p_timestamp *ts)\n{\n\n\tSMTSETPARA(ts,SMT_P_TIMESTAMP) ;\n\tsmt_set_timestamp(smc,ts->ts_time) ;\n}\n\nvoid smt_set_timestamp(struct s_smc *smc, u_char *p)\n{\n\tu_long\ttime ;\n\tu_long\tutime ;\n\n\t \n\tutime = smt_get_time() ;\n\ttime = utime * 100 ;\n\ttime /= TICKS_PER_SECOND ;\n\tp[0] = 0 ;\n\tp[1] = (u_char)((time>>(8+8+8+8-1)) & 1) ;\n\tp[2] = (u_char)(time>>(8+8+8-1)) ;\n\tp[3] = (u_char)(time>>(8+8-1)) ;\n\tp[4] = (u_char)(time>>(8-1)) ;\n\tp[5] = (u_char)(time<<1) ;\n\tp[6] = (u_char)(smc->sm.uniq_ticks>>8) ;\n\tp[7] = (u_char)smc->sm.uniq_ticks ;\n\t \n\tif (utime != smc->sm.uniq_time) {\n\t\tsmc->sm.uniq_ticks = 0 ;\n\t}\n\tsmc->sm.uniq_ticks++ ;\n\tsmc->sm.uniq_time = utime ;\n}\n\n \nstatic void smt_fill_policy(struct s_smc *smc, struct smt_p_policy *policy)\n{\n\tint\ti ;\n\tconst u_char *map ;\n\tu_short\tin ;\n\tu_short\tout ;\n\n\t \n\tstatic const u_char ansi_weirdness[16] = {\n\t\t0,7,5,3,8,1,6,4,9,10,2,11,12,13,14,15\n\t} ;\n\tSMTSETPARA(policy,SMT_P_POLICY) ;\n\n\tout = 0 ;\n\tin = smc->mib.fddiSMTConnectionPolicy ;\n\tfor (i = 0, map = ansi_weirdness ; i < 16 ; i++) {\n\t\tif (in & 1)\n\t\t\tout |= (1<<*map) ;\n\t\tin >>= 1 ;\n\t\tmap++ ;\n\t}\n\tpolicy->pl_config = smc->mib.fddiSMTConfigPolicy ;\n\tpolicy->pl_connect = out ;\n}\n\n \nstatic void smt_fill_latency(struct s_smc *smc, struct smt_p_latency *latency)\n{\n\tSMTSETPARA(latency,SMT_P_LATENCY) ;\n\n\tlatency->lt_phyout_idx1 = phy_index(smc,0) ;\n\tlatency->lt_latency1 = 10 ;\t \n\t \n\tif (smc->s.sas == SMT_DAS) {\n\t\tlatency->lt_phyout_idx2 = phy_index(smc,1) ;\n\t\tlatency->lt_latency2 = 10 ;\t \n\t}\n\telse {\n\t\tlatency->lt_phyout_idx2 = 0 ;\n\t\tlatency->lt_latency2 = 0 ;\n\t}\n}\n\n \nstatic void smt_fill_neighbor(struct s_smc *smc, struct smt_p_neighbor *neighbor)\n{\n\tSMTSETPARA(neighbor,SMT_P_NEIGHBORS) ;\n\n\tneighbor->nb_mib_index = INDEX_MAC ;\n\tneighbor->nb_mac_index = mac_index(smc,1) ;\n\tneighbor->nb_una = smc->mib.m[MAC0].fddiMACUpstreamNbr ;\n\tneighbor->nb_dna = smc->mib.m[MAC0].fddiMACDownstreamNbr ;\n}\n\n \n#ifdef\tCONCENTRATOR\n#define ALLPHYS\tNUMPHYS\n#else\n#define ALLPHYS\t((smc->s.sas == SMT_SAS) ? 1 : 2)\n#endif\n\nstatic int smt_fill_path(struct s_smc *smc, struct smt_p_path *path)\n{\n\tSK_LOC_DECL(int,type) ;\n\tSK_LOC_DECL(int,state) ;\n\tSK_LOC_DECL(int,remote) ;\n\tSK_LOC_DECL(int,mac) ;\n\tint\tlen ;\n\tint\tp ;\n\tint\tphysp ;\n\tstruct smt_phy_rec\t*phy ;\n\tstruct smt_mac_rec\t*pd_mac ;\n\n\tlen =\tPARA_LEN +\n\t\tsizeof(struct smt_mac_rec) * NUMMACS +\n\t\tsizeof(struct smt_phy_rec) * ALLPHYS ;\n\tpath->para.p_type = SMT_P_PATH ;\n\tpath->para.p_len = len - PARA_LEN ;\n\n\t \n\tfor (p = 0,phy = path->pd_phy ; p < ALLPHYS ; p++, phy++) {\n\t\tphysp = p ;\n#ifndef\tCONCENTRATOR\n\t\tif (smc->s.sas == SMT_SAS)\n\t\t\tphysp = PS ;\n#endif\n\t\tpcm_status_state(smc,physp,&type,&state,&remote,&mac) ;\n#ifdef\tLITTLE_ENDIAN\n\t\tphy->phy_mib_index = smt_swap_short((u_short)p+INDEX_PORT) ;\n#else\n\t\tphy->phy_mib_index = p+INDEX_PORT ;\n#endif\n\t\tphy->phy_type = type ;\n\t\tphy->phy_connect_state = state ;\n\t\tphy->phy_remote_type = remote ;\n\t\tphy->phy_remote_mac = mac ;\n\t\tphy->phy_resource_idx = phy_con_resource_index(smc,p) ;\n\t}\n\n\t \n\tpd_mac = (struct smt_mac_rec *) phy ;\n\tpd_mac->mac_addr = smc->mib.m[MAC0].fddiMACSMTAddress ;\n\tpd_mac->mac_resource_idx = mac_con_resource_index(smc,1) ;\n\treturn len;\n}\n\n \nstatic void smt_fill_mac_status(struct s_smc *smc, struct smt_p_mac_status *st)\n{\n\tSMTSETPARA(st,SMT_P_MAC_STATUS) ;\n\n\tst->st_mib_index = INDEX_MAC ;\n\tst->st_mac_index = mac_index(smc,1) ;\n\n\tmac_update_counter(smc) ;\n\t \n\tst->st_t_req = smc->mib.m[MAC0].fddiMACT_Req ;\n\tst->st_t_neg = smc->mib.m[MAC0].fddiMACT_Neg ;\n\tst->st_t_max = smc->mib.m[MAC0].fddiMACT_Max ;\n\tst->st_tvx_value = smc->mib.m[MAC0].fddiMACTvxValue ;\n\tst->st_t_min = smc->mib.m[MAC0].fddiMACT_Min ;\n\n\tst->st_sba = smc->mib.a[PATH0].fddiPATHSbaPayload ;\n\tst->st_frame_ct = smc->mib.m[MAC0].fddiMACFrame_Ct ;\n\tst->st_error_ct = smc->mib.m[MAC0].fddiMACError_Ct ;\n\tst->st_lost_ct = smc->mib.m[MAC0].fddiMACLost_Ct ;\n}\n\n \nstatic void smt_fill_lem(struct s_smc *smc, struct smt_p_lem *lem, int phy)\n{\n\tstruct fddi_mib_p\t*mib ;\n\n\tmib = smc->y[phy].mib ;\n\n\tSMTSETPARA(lem,SMT_P_LEM) ;\n\tlem->lem_mib_index = phy+INDEX_PORT ;\n\tlem->lem_phy_index = phy_index(smc,phy) ;\n\tlem->lem_pad2 = 0 ;\n\tlem->lem_cutoff = mib->fddiPORTLer_Cutoff ;\n\tlem->lem_alarm = mib->fddiPORTLer_Alarm ;\n\t \n\tlem->lem_estimate = mib->fddiPORTLer_Estimate ;\n\t \n\tlem->lem_reject_ct = mib->fddiPORTLem_Reject_Ct ;\n\tlem->lem_ct = mib->fddiPORTLem_Ct ;\t \n}\n\n \nstatic void smt_fill_version(struct s_smc *smc, struct smt_p_version *vers)\n{\n\tSK_UNUSED(smc) ;\n\tSMTSETPARA(vers,SMT_P_VERSION) ;\n\tvers->v_pad = 0 ;\n\tvers->v_n = 1 ;\t\t\t\t \n\tvers->v_index = 1 ;\n\tvers->v_version[0] = SMT_VID_2 ;\n\tvers->v_pad2 = 0 ;\n}\n\n#ifdef\tSMT6_10\n \n \nstatic void smt_fill_fsc(struct s_smc *smc, struct smt_p_fsc *fsc)\n{\n\tSK_UNUSED(smc) ;\n\tSMTSETPARA(fsc,SMT_P_FSC) ;\n\tfsc->fsc_pad0 = 0 ;\n\tfsc->fsc_mac_index = INDEX_MAC ;\t \n\tfsc->fsc_pad1 = 0 ;\n\tfsc->fsc_value = FSC_TYPE0 ;\t\t \n#ifdef\tLITTLE_ENDIAN\n\tfsc->fsc_mac_index = smt_swap_short(INDEX_MAC) ;\n\tfsc->fsc_value = smt_swap_short(FSC_TYPE0) ;\n#endif\n}\n#endif\n\n \nstatic void smt_fill_mac_counter(struct s_smc *smc, struct smt_p_mac_counter *mc)\n{\n\tSMTSETPARA(mc,SMT_P_MAC_COUNTER) ;\n\tmc->mc_mib_index = INDEX_MAC ;\n\tmc->mc_index = mac_index(smc,1) ;\n\tmc->mc_receive_ct = smc->mib.m[MAC0].fddiMACCopied_Ct ;\n\tmc->mc_transmit_ct =  smc->mib.m[MAC0].fddiMACTransmit_Ct ;\n}\n\n \nstatic void smt_fill_mac_fnc(struct s_smc *smc, struct smt_p_mac_fnc *fnc)\n{\n\tSMTSETPARA(fnc,SMT_P_MAC_FNC) ;\n\tfnc->nc_mib_index = INDEX_MAC ;\n\tfnc->nc_index = mac_index(smc,1) ;\n\tfnc->nc_counter = smc->mib.m[MAC0].fddiMACNotCopied_Ct ;\n}\n\n\n \nstatic void smt_fill_manufacturer(struct s_smc *smc, \n\t\t\t\t  struct smp_p_manufacturer *man)\n{\n\tSMTSETPARA(man,SMT_P_MANUFACTURER) ;\n\tmemcpy((char *) man->mf_data,\n\t\t(char *) smc->mib.fddiSMTManufacturerData,\n\t\tsizeof(man->mf_data)) ;\n}\n\n \nstatic void smt_fill_user(struct s_smc *smc, struct smp_p_user *user)\n{\n\tSMTSETPARA(user,SMT_P_USER) ;\n\tmemcpy((char *) user->us_data,\n\t\t(char *) smc->mib.fddiSMTUserData,\n\t\tsizeof(user->us_data)) ;\n}\n\n \nstatic void smt_fill_setcount(struct s_smc *smc, struct smt_p_setcount *setcount)\n{\n\tSK_UNUSED(smc) ;\n\tSMTSETPARA(setcount,SMT_P_SETCOUNT) ;\n\tsetcount->count = smc->mib.fddiSMTSetCount.count ;\n\tmemcpy((char *)setcount->timestamp,\n\t\t(char *)smc->mib.fddiSMTSetCount.timestamp,8) ;\n}\n\n \nstatic void smt_fill_echo(struct s_smc *smc, struct smt_p_echo *echo, u_long seed,\n\t\t\t  int len)\n{\n\tu_char\t*p ;\n\n\tSK_UNUSED(smc) ;\n\tSMTSETPARA(echo,SMT_P_ECHODATA) ;\n\techo->para.p_len = len ;\n\tfor (p = echo->ec_data ; len ; len--) {\n\t\t*p++ = (u_char) seed ;\n\t\tseed += 13 ;\n\t}\n}\n\n \nstatic void smt_clear_una_dna(struct s_smc *smc)\n{\n\tsmc->mib.m[MAC0].fddiMACUpstreamNbr = SMT_Unknown ;\n\tsmc->mib.m[MAC0].fddiMACDownstreamNbr = SMT_Unknown ;\n}\n\nstatic void smt_clear_old_una_dna(struct s_smc *smc)\n{\n\tsmc->mib.m[MAC0].fddiMACOldUpstreamNbr = SMT_Unknown ;\n\tsmc->mib.m[MAC0].fddiMACOldDownstreamNbr = SMT_Unknown ;\n}\n\nu_long smt_get_tid(struct s_smc *smc)\n{\n\tu_long\ttid ;\n\twhile ((tid = ++(smc->sm.smt_tid) ^ SMT_TID_MAGIC) == 0)\n\t\t;\n\treturn tid & 0x3fffffffL;\n}\n\n#ifdef\tLITTLE_ENDIAN\n \nstatic const struct smt_pdef {\n\tint\tptype ;\n\tint\tplen ;\n\tconst char\t*pswap ;\n} smt_pdef[] = {\n\t{ SMT_P_UNA,\tsizeof(struct smt_p_una) ,\n\t\tSWAP_SMT_P_UNA\t\t\t\t\t} ,\n\t{ SMT_P_SDE,\tsizeof(struct smt_p_sde) ,\n\t\tSWAP_SMT_P_SDE\t\t\t\t\t} ,\n\t{ SMT_P_STATE,\tsizeof(struct smt_p_state) ,\n\t\tSWAP_SMT_P_STATE\t\t\t\t} ,\n\t{ SMT_P_TIMESTAMP,sizeof(struct smt_p_timestamp) ,\n\t\tSWAP_SMT_P_TIMESTAMP\t\t\t\t} ,\n\t{ SMT_P_POLICY,\tsizeof(struct smt_p_policy) ,\n\t\tSWAP_SMT_P_POLICY\t\t\t\t} ,\n\t{ SMT_P_LATENCY,\tsizeof(struct smt_p_latency) ,\n\t\tSWAP_SMT_P_LATENCY\t\t\t\t} ,\n\t{ SMT_P_NEIGHBORS,sizeof(struct smt_p_neighbor) ,\n\t\tSWAP_SMT_P_NEIGHBORS\t\t\t\t} ,\n\t{ SMT_P_PATH,\tsizeof(struct smt_p_path) ,\n\t\tSWAP_SMT_P_PATH\t\t\t\t\t} ,\n\t{ SMT_P_MAC_STATUS,sizeof(struct smt_p_mac_status) ,\n\t\tSWAP_SMT_P_MAC_STATUS\t\t\t\t} ,\n\t{ SMT_P_LEM,\tsizeof(struct smt_p_lem) ,\n\t\tSWAP_SMT_P_LEM\t\t\t\t\t} ,\n\t{ SMT_P_MAC_COUNTER,sizeof(struct smt_p_mac_counter) ,\n\t\tSWAP_SMT_P_MAC_COUNTER\t\t\t\t} ,\n\t{ SMT_P_MAC_FNC,sizeof(struct smt_p_mac_fnc) ,\n\t\tSWAP_SMT_P_MAC_FNC\t\t\t\t} ,\n\t{ SMT_P_PRIORITY,sizeof(struct smt_p_priority) ,\n\t\tSWAP_SMT_P_PRIORITY\t\t\t\t} ,\n\t{ SMT_P_EB,sizeof(struct smt_p_eb) ,\n\t\tSWAP_SMT_P_EB\t\t\t\t\t} ,\n\t{ SMT_P_MANUFACTURER,sizeof(struct smp_p_manufacturer) ,\n\t\tSWAP_SMT_P_MANUFACTURER\t\t\t\t} ,\n\t{ SMT_P_REASON,\tsizeof(struct smt_p_reason) ,\n\t\tSWAP_SMT_P_REASON\t\t\t\t} ,\n\t{ SMT_P_REFUSED, sizeof(struct smt_p_refused) ,\n\t\tSWAP_SMT_P_REFUSED\t\t\t\t} ,\n\t{ SMT_P_VERSION, sizeof(struct smt_p_version) ,\n\t\tSWAP_SMT_P_VERSION\t\t\t\t} ,\n#ifdef ESS\n\t{ SMT_P0015, sizeof(struct smt_p_0015) , SWAP_SMT_P0015 } ,\n\t{ SMT_P0016, sizeof(struct smt_p_0016) , SWAP_SMT_P0016 } ,\n\t{ SMT_P0017, sizeof(struct smt_p_0017) , SWAP_SMT_P0017 } ,\n\t{ SMT_P0018, sizeof(struct smt_p_0018) , SWAP_SMT_P0018 } ,\n\t{ SMT_P0019, sizeof(struct smt_p_0019) , SWAP_SMT_P0019 } ,\n\t{ SMT_P001A, sizeof(struct smt_p_001a) , SWAP_SMT_P001A } ,\n\t{ SMT_P001B, sizeof(struct smt_p_001b) , SWAP_SMT_P001B } ,\n\t{ SMT_P001C, sizeof(struct smt_p_001c) , SWAP_SMT_P001C } ,\n\t{ SMT_P001D, sizeof(struct smt_p_001d) , SWAP_SMT_P001D } ,\n#endif\n#if\t0\n\t{ SMT_P_FSC,\tsizeof(struct smt_p_fsc) ,\n\t\tSWAP_SMT_P_FSC\t\t\t\t\t} ,\n#endif\n\n\t{ SMT_P_SETCOUNT,0,\tSWAP_SMT_P_SETCOUNT\t\t} ,\n\t{ SMT_P1048,\t0,\tSWAP_SMT_P1048\t\t\t} ,\n\t{ SMT_P208C,\t0,\tSWAP_SMT_P208C\t\t\t} ,\n\t{ SMT_P208D,\t0,\tSWAP_SMT_P208D\t\t\t} ,\n\t{ SMT_P208E,\t0,\tSWAP_SMT_P208E\t\t\t} ,\n\t{ SMT_P208F,\t0,\tSWAP_SMT_P208F\t\t\t} ,\n\t{ SMT_P2090,\t0,\tSWAP_SMT_P2090\t\t\t} ,\n#ifdef\tESS\n\t{ SMT_P320B, sizeof(struct smt_p_320b) , SWAP_SMT_P320B } ,\n\t{ SMT_P320F, sizeof(struct smt_p_320f) , SWAP_SMT_P320F } ,\n\t{ SMT_P3210, sizeof(struct smt_p_3210) , SWAP_SMT_P3210 } ,\n#endif\n\t{ SMT_P4050,\t0,\tSWAP_SMT_P4050\t\t\t} ,\n\t{ SMT_P4051,\t0,\tSWAP_SMT_P4051\t\t\t} ,\n\t{ SMT_P4052,\t0,\tSWAP_SMT_P4052\t\t\t} ,\n\t{ SMT_P4053,\t0,\tSWAP_SMT_P4053\t\t\t} ,\n} ;\n\n#define N_SMT_PLEN\tARRAY_SIZE(smt_pdef)\n#endif\n\nint smt_check_para(struct s_smc *smc, struct smt_header\t*sm,\n\t\t   const u_short list[])\n{\n\tconst u_short\t\t*p = list ;\n\twhile (*p) {\n\t\tif (!sm_to_para(smc,sm,(int) *p)) {\n\t\t\tDB_SMT(\"SMT: smt_check_para - missing para %hx\", *p);\n\t\t\treturn -1;\n\t\t}\n\t\tp++ ;\n\t}\n\treturn 0;\n}\n\nvoid *sm_to_para(struct s_smc *smc, struct smt_header *sm, int para)\n{\n\tchar\t*p ;\n\tint\tlen ;\n\tint\tplen ;\n\tvoid\t*found = NULL;\n\n\tSK_UNUSED(smc) ;\n\n\tlen = sm->smt_len ;\n\tp = (char *)(sm+1) ;\t\t \n\twhile (len > 0 ) {\n\t\tif (((struct smt_para *)p)->p_type == para)\n\t\t\tfound = (void *) p ;\n\t\tplen = ((struct smt_para *)p)->p_len + PARA_LEN ;\n\t\tp += plen ;\n\t\tlen -= plen ;\n\t\tif (len < 0) {\n\t\t\tDB_SMT(\"SMT : sm_to_para - length error %d\", plen);\n\t\t\treturn NULL;\n\t\t}\n\t\tif ((plen & 3) && (para != SMT_P_ECHODATA)) {\n\t\t\tDB_SMT(\"SMT : sm_to_para - odd length %d\", plen);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (found)\n\t\t\treturn found;\n\t}\n\treturn NULL;\n}\n\n#if\t0\n \nvoid fddi_send_antc(struct s_smc *smc, struct fddi_addr *dest)\n{\n\tSK_UNUSED(smc) ;\n\tSK_UNUSED(dest) ;\n#if\t0\n\tSMbuf\t\t\t*mb ;\n\tstruct smt_header\t*smt ;\n\tint\t\t\ti ;\n\tchar\t\t\t*p ;\n\n\tmb = smt_get_mbuf() ;\n\tmb->sm_len = 3000+12 ;\n\tp = smtod(mb, char *) + 12 ;\n\tfor (i = 0 ; i < 3000 ; i++)\n\t\t*p++ = 1 << (i&7) ;\n\n\tsmt = smtod(mb, struct smt_header *) ;\n\tsmt->smt_dest = *dest ;\n\tsmt->smt_source = smc->mib.m[MAC0].fddiMACSMTAddress ;\n\tsmt_send_mbuf(smc,mb,FC_ASYNC_LLC) ;\n#endif\n}\n#endif\n\n \nstatic int mac_index(struct s_smc *smc, int mac)\n{\n\tSK_UNUSED(mac) ;\n#ifdef\tCONCENTRATOR\n\tSK_UNUSED(smc) ;\n\treturn NUMPHYS + 1;\n#else\n\treturn (smc->s.sas == SMT_SAS) ? 2 : 3;\n#endif\n}\n\n \nstatic int phy_index(struct s_smc *smc, int phy)\n{\n\tSK_UNUSED(smc) ;\n\treturn phy + 1;\n}\n\n \nstatic int mac_con_resource_index(struct s_smc *smc, int mac)\n{\n#ifdef\tCONCENTRATOR\n\tSK_UNUSED(smc) ;\n\tSK_UNUSED(mac) ;\n\treturn entity_to_index(smc, cem_get_downstream(smc, ENTITY_MAC));\n#else\n\tSK_UNUSED(mac) ;\n\tswitch (smc->mib.fddiSMTCF_State) {\n\tcase SC9_C_WRAP_A :\n\tcase SC5_THRU_B :\n\tcase SC11_C_WRAP_S :\n\t\treturn 1;\n\tcase SC10_C_WRAP_B :\n\tcase SC4_THRU_A :\n\t\treturn 2;\n\t}\n\treturn smc->s.sas == SMT_SAS ? 2 : 3;\n#endif\n}\n\n \nstatic int phy_con_resource_index(struct s_smc *smc, int phy)\n{\n#ifdef\tCONCENTRATOR\n\treturn entity_to_index(smc, cem_get_downstream(smc, ENTITY_PHY(phy))) ;\n#else\n\tswitch (smc->mib.fddiSMTCF_State) {\n\tcase SC9_C_WRAP_A :\n\t\treturn phy == PA ? 3 : 2;\n\tcase SC10_C_WRAP_B :\n\t\treturn phy == PA ? 1 : 3;\n\tcase SC4_THRU_A :\n\t\treturn phy == PA ? 3 : 1;\n\tcase SC5_THRU_B :\n\t\treturn phy == PA ? 2 : 3;\n\tcase SC11_C_WRAP_S :\n\t\treturn 2;\n\t}\n\treturn phy;\n#endif\n}\n\n#ifdef\tCONCENTRATOR\nstatic int entity_to_index(struct s_smc *smc, int e)\n{\n\tif (e == ENTITY_MAC)\n\t\treturn mac_index(smc, 1);\n\telse\n\t\treturn phy_index(smc, e - ENTITY_PHY(0));\n}\n#endif\n\n#ifdef\tLITTLE_ENDIAN\nstatic int smt_swap_short(u_short s)\n{\n\treturn ((s>>8)&0xff) | ((s&0xff)<<8);\n}\n\nvoid smt_swap_para(struct smt_header *sm, int len, int direction)\n \n{\n\tstruct smt_para\t*pa ;\n\tconst  struct smt_pdef\t*pd ;\n\tchar\t*p ;\n\tint\tplen ;\n\tint\ttype ;\n\tint\ti ;\n\n \n\tsmt_string_swap((char *)sm,SWAP_SMTHEADER,len) ;\n\n\t \n\tlen -= sizeof(struct smt_header) ;\n\n\tp = (char *) (sm + 1) ;\n\twhile (len > 0) {\n\t\tpa = (struct smt_para *) p ;\n\t\tplen = pa->p_len ;\n\t\ttype = pa->p_type ;\n\t\tpa->p_type = smt_swap_short(pa->p_type) ;\n\t\tpa->p_len = smt_swap_short(pa->p_len) ;\n\t\tif (direction) {\n\t\t\tplen = pa->p_len ;\n\t\t\ttype = pa->p_type ;\n\t\t}\n\t\t \n\t\tif (plen < 0)\n\t\t\tbreak ;\n\t\tplen += PARA_LEN ;\n\t\tfor (i = N_SMT_PLEN, pd = smt_pdef; i ; i--,pd++) {\n\t\t\tif (pd->ptype == type)\n\t\t\t\tbreak ;\n\t\t}\n\t\tif (i && pd->pswap) {\n\t\t\tsmt_string_swap(p+PARA_LEN,pd->pswap,len) ;\n\t\t}\n\t\tlen -= plen ;\n\t\tp += plen ;\n\t}\n}\n\n\nstatic void smt_string_swap(char *data, const char *format, int len)\n{\n\tconst char\t*open_paren = NULL ;\n\n\twhile (len > 0  && *format) {\n\t\tswitch (*format) {\n\t\tcase '[' :\n\t\t\topen_paren = format ;\n\t\t\tbreak ;\n\t\tcase ']' :\n\t\t\tformat = open_paren ;\n\t\t\tbreak ;\n\t\tcase '1' :\n\t\tcase '2' :\n\t\tcase '3' :\n\t\tcase '4' :\n\t\tcase '5' :\n\t\tcase '6' :\n\t\tcase '7' :\n\t\tcase '8' :\n\t\tcase '9' :\n\t\t\tdata  += *format - '0' ;\n\t\t\tlen   -= *format - '0' ;\n\t\t\tbreak ;\n\t\tcase 'c':\n\t\t\tdata++ ;\n\t\t\tlen-- ;\n\t\t\tbreak ;\n\t\tcase 's' :\n\t\t\tswap(data[0], data[1]) ;\n\t\t\tdata += 2 ;\n\t\t\tlen -= 2 ;\n\t\t\tbreak ;\n\t\tcase 'l' :\n\t\t\tswap(data[0], data[3]) ;\n\t\t\tswap(data[1], data[2]) ;\n\t\t\tdata += 4 ;\n\t\t\tlen -= 4 ;\n\t\t\tbreak ;\n\t\t}\n\t\tformat++ ;\n\t}\n}\n#else\nvoid smt_swap_para(struct smt_header *sm, int len, int direction)\n \n{\n\tSK_UNUSED(sm) ;\n\tSK_UNUSED(len) ;\n\tSK_UNUSED(direction) ;\n}\n#endif\n\n \nint smt_action(struct s_smc *smc, int class, int code, int index)\n{\n\tint\tevent ;\n\tint\tport ;\n\tDB_SMT(\"SMT: action %d code %d\", class, code);\n\tswitch(class) {\n\tcase SMT_STATION_ACTION :\n\t\tswitch(code) {\n\t\tcase SMT_STATION_ACTION_CONNECT :\n\t\t\tsmc->mib.fddiSMTRemoteDisconnectFlag = FALSE ;\n\t\t\tqueue_event(smc,EVENT_ECM,EC_CONNECT) ;\n\t\t\tbreak ;\n\t\tcase SMT_STATION_ACTION_DISCONNECT :\n\t\t\tqueue_event(smc,EVENT_ECM,EC_DISCONNECT) ;\n\t\t\tsmc->mib.fddiSMTRemoteDisconnectFlag = TRUE ;\n\t\t\tRS_SET(smc,RS_DISCONNECT) ;\n\t\t\tAIX_EVENT(smc, (u_long) FDDI_RING_STATUS, (u_long)\n\t\t\t\tFDDI_SMT_EVENT, (u_long) FDDI_REMOTE_DISCONNECT,\n\t\t\t\tsmt_get_event_word(smc));\n\t\t\tbreak ;\n\t\tcase SMT_STATION_ACTION_PATHTEST :\n\t\t\tAIX_EVENT(smc, (u_long) FDDI_RING_STATUS, (u_long)\n\t\t\t\tFDDI_SMT_EVENT, (u_long) FDDI_PATH_TEST,\n\t\t\t\tsmt_get_event_word(smc));\n\t\t\tbreak ;\n\t\tcase SMT_STATION_ACTION_SELFTEST :\n\t\t\tAIX_EVENT(smc, (u_long) FDDI_RING_STATUS, (u_long)\n\t\t\t\tFDDI_SMT_EVENT, (u_long) FDDI_REMOTE_SELF_TEST,\n\t\t\t\tsmt_get_event_word(smc));\n\t\t\tbreak ;\n\t\tcase SMT_STATION_ACTION_DISABLE_A :\n\t\t\tif (smc->y[PA].pc_mode == PM_PEER) {\n\t\t\t\tRS_SET(smc,RS_EVENT) ;\n\t\t\t\tqueue_event(smc,EVENT_PCM+PA,PC_DISABLE) ;\n\t\t\t}\n\t\t\tbreak ;\n\t\tcase SMT_STATION_ACTION_DISABLE_B :\n\t\t\tif (smc->y[PB].pc_mode == PM_PEER) {\n\t\t\t\tRS_SET(smc,RS_EVENT) ;\n\t\t\t\tqueue_event(smc,EVENT_PCM+PB,PC_DISABLE) ;\n\t\t\t}\n\t\t\tbreak ;\n\t\tcase SMT_STATION_ACTION_DISABLE_M :\n\t\t\tfor (port = 0 ; port <  NUMPHYS ; port++) {\n\t\t\t\tif (smc->mib.p[port].fddiPORTMy_Type != TM)\n\t\t\t\t\tcontinue ;\n\t\t\t\tRS_SET(smc,RS_EVENT) ;\n\t\t\t\tqueue_event(smc,EVENT_PCM+port,PC_DISABLE) ;\n\t\t\t}\n\t\t\tbreak ;\n\t\tdefault :\n\t\t\treturn 1;\n\t\t}\n\t\tbreak ;\n\tcase SMT_PORT_ACTION :\n\t\tswitch(code) {\n\t\tcase SMT_PORT_ACTION_ENABLE :\n\t\t\tevent = PC_ENABLE ;\n\t\t\tbreak ;\n\t\tcase SMT_PORT_ACTION_DISABLE :\n\t\t\tevent = PC_DISABLE ;\n\t\t\tbreak ;\n\t\tcase SMT_PORT_ACTION_MAINT :\n\t\t\tevent = PC_MAINT ;\n\t\t\tbreak ;\n\t\tcase SMT_PORT_ACTION_START :\n\t\t\tevent = PC_START ;\n\t\t\tbreak ;\n\t\tcase SMT_PORT_ACTION_STOP :\n\t\t\tevent = PC_STOP ;\n\t\t\tbreak ;\n\t\tdefault :\n\t\t\treturn 1;\n\t\t}\n\t\tqueue_event(smc,EVENT_PCM+index,event) ;\n\t\tbreak ;\n\tdefault :\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \n#ifdef  USE_CAN_ADDR\nstatic void hwm_conv_can(struct s_smc *smc, char *data, int len)\n{\n\tint i ;\n\n\tSK_UNUSED(smc) ;\n\n\tfor (i = len; i ; i--, data++)\n\t\t*data = bitrev8(*data);\n}\n#endif\n\n#endif\t \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}