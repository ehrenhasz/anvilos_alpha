{
  "module_name": "smttimer.c",
  "hash_id": "92d3bf6d0ce2bf0f86b138b32990e3353d3ce55f6806fbdf444366071e15218f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/fddi/skfp/smttimer.c",
  "human_readable_source": "\n \n\n \n\n#include \"h/types.h\"\n#include \"h/fddi.h\"\n#include \"h/smc.h\"\n\nstatic void timer_done(struct s_smc *smc, int restart);\n\nvoid smt_timer_init(struct s_smc *smc)\n{\n\tsmc->t.st_queue = NULL;\n\tsmc->t.st_fast.tm_active = FALSE ;\n\tsmc->t.st_fast.tm_next = NULL;\n\thwt_init(smc) ;\n}\n\nvoid smt_timer_stop(struct s_smc *smc, struct smt_timer *timer)\n{\n\tstruct smt_timer\t**prev ;\n\tstruct smt_timer\t*tm ;\n\n\t \n\ttimer->tm_active = FALSE ;\n\tif (smc->t.st_queue == timer && !timer->tm_next) {\n\t\thwt_stop(smc) ;\n\t}\n\tfor (prev = &smc->t.st_queue ; (tm = *prev) ; prev = &tm->tm_next ) {\n\t\tif (tm == timer) {\n\t\t\t*prev = tm->tm_next ;\n\t\t\tif (tm->tm_next) {\n\t\t\t\ttm->tm_next->tm_delta += tm->tm_delta ;\n\t\t\t}\n\t\t\treturn ;\n\t\t}\n\t}\n}\n\nvoid smt_timer_start(struct s_smc *smc, struct smt_timer *timer, u_long time,\n\t\t     u_long token)\n{\n\tstruct smt_timer\t**prev ;\n\tstruct smt_timer\t*tm ;\n\tu_long\t\t\tdelta = 0 ;\n\n\ttime /= 16 ;\t\t \n\tif (!time)\n\t\ttime = 1 ;\n\tsmt_timer_stop(smc,timer) ;\n\ttimer->tm_smc = smc ;\n\ttimer->tm_token = token ;\n\ttimer->tm_active = TRUE ;\n\tif (!smc->t.st_queue) {\n\t\tsmc->t.st_queue = timer ;\n\t\ttimer->tm_next = NULL;\n\t\ttimer->tm_delta = time ;\n\t\thwt_start(smc,time) ;\n\t\treturn ;\n\t}\n\t \n\ttimer_done(smc,0) ;\n\n\t \n\tdelta = 0 ;\n\tfor (prev = &smc->t.st_queue ; (tm = *prev) ; prev = &tm->tm_next ) {\n\t\tif (delta + tm->tm_delta > time) {\n\t\t\tbreak ;\n\t\t}\n\t\tdelta += tm->tm_delta ;\n\t}\n\t \n\t*prev = timer ;\n\ttimer->tm_next = tm ;\n\ttimer->tm_delta = time - delta ;\n\tif (tm)\n\t\ttm->tm_delta -= timer->tm_delta ;\n\t \n\thwt_start(smc,smc->t.st_queue->tm_delta) ;\n}\n\nvoid smt_force_irq(struct s_smc *smc)\n{\n\tsmt_timer_start(smc,&smc->t.st_fast,32L, EV_TOKEN(EVENT_SMT,SM_FAST)); \n}\n\nvoid smt_timer_done(struct s_smc *smc)\n{\n\ttimer_done(smc,1) ;\n}\n\nstatic void timer_done(struct s_smc *smc, int restart)\n{\n\tu_long\t\t\tdelta ;\n\tstruct smt_timer\t*tm ;\n\tstruct smt_timer\t*next ;\n\tstruct smt_timer\t**last ;\n\tint\t\t\tdone = 0 ;\n\n\tdelta = hwt_read(smc) ;\n\tlast = &smc->t.st_queue ;\n\ttm = smc->t.st_queue ;\n\twhile (tm && !done) {\n\t\tif (delta >= tm->tm_delta) {\n\t\t\ttm->tm_active = FALSE ;\n\t\t\tdelta -= tm->tm_delta ;\n\t\t\tlast = &tm->tm_next ;\n\t\t\ttm = tm->tm_next ;\n\t\t}\n\t\telse {\n\t\t\ttm->tm_delta -= delta ;\n\t\t\tdelta = 0 ;\n\t\t\tdone = 1 ;\n\t\t}\n\t}\n\t*last = NULL;\n\tnext = smc->t.st_queue ;\n\tsmc->t.st_queue = tm ;\n\n\tfor ( tm = next ; tm ; tm = next) {\n\t\tnext = tm->tm_next ;\n\t\ttimer_event(smc,tm->tm_token) ;\n\t}\n\n\tif (restart && smc->t.st_queue)\n\t\thwt_start(smc,smc->t.st_queue->tm_delta) ;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}