{
  "module_name": "skfddi.c",
  "hash_id": "fc58ca59c1c9bf731fa46676039a9b2e5d14e0bec87a74a07a067e89e9f9c383",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/fddi/skfp/skfddi.c",
  "human_readable_source": "\n \n\n \n \n#define VERSION\t\t\"2.07\"\n\nstatic const char * const boot_msg = \n\t\"SysKonnect FDDI PCI Adapter driver v\" VERSION \" for\\n\"\n\t\"  SK-55xx/SK-58xx adapters (SK-NET FDDI-FP/UP/LP)\";\n\n \n\n#include <linux/capability.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/ioport.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/fddidevice.h>\n#include <linux/skbuff.h>\n#include <linux/bitops.h>\n#include <linux/gfp.h>\n\n#include <asm/byteorder.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n#include\t\"h/types.h\"\n#undef ADDR\t\t\t \n#include\t\"h/skfbi.h\"\n#include\t\"h/fddi.h\"\n#include\t\"h/smc.h\"\n#include\t\"h/smtstate.h\"\n\n\n \nstatic int skfp_driver_init(struct net_device *dev);\nstatic int skfp_open(struct net_device *dev);\nstatic int skfp_close(struct net_device *dev);\nstatic irqreturn_t skfp_interrupt(int irq, void *dev_id);\nstatic struct net_device_stats *skfp_ctl_get_stats(struct net_device *dev);\nstatic void skfp_ctl_set_multicast_list(struct net_device *dev);\nstatic void skfp_ctl_set_multicast_list_wo_lock(struct net_device *dev);\nstatic int skfp_ctl_set_mac_address(struct net_device *dev, void *addr);\nstatic int skfp_siocdevprivate(struct net_device *dev, struct ifreq *rq,\n\t\t\t       void __user *data, int cmd);\nstatic netdev_tx_t skfp_send_pkt(struct sk_buff *skb,\n\t\t\t\t       struct net_device *dev);\nstatic void send_queued_packets(struct s_smc *smc);\nstatic void CheckSourceAddress(unsigned char *frame, unsigned char *hw_addr);\nstatic void ResetAdapter(struct s_smc *smc);\n\n\n \nvoid *mac_drv_get_space(struct s_smc *smc, u_int size);\nvoid *mac_drv_get_desc_mem(struct s_smc *smc, u_int size);\nunsigned long mac_drv_virt2phys(struct s_smc *smc, void *virt);\nunsigned long dma_master(struct s_smc *smc, void *virt, int len, int flag);\nvoid dma_complete(struct s_smc *smc, volatile union s_fp_descr *descr,\n\t\t  int flag);\nvoid mac_drv_tx_complete(struct s_smc *smc, volatile struct s_smt_fp_txd *txd);\nvoid llc_restart_tx(struct s_smc *smc);\nvoid mac_drv_rx_complete(struct s_smc *smc, volatile struct s_smt_fp_rxd *rxd,\n\t\t\t int frag_count, int len);\nvoid mac_drv_requeue_rxd(struct s_smc *smc, volatile struct s_smt_fp_rxd *rxd,\n\t\t\t int frag_count);\nvoid mac_drv_fill_rxd(struct s_smc *smc);\nvoid mac_drv_clear_rxd(struct s_smc *smc, volatile struct s_smt_fp_rxd *rxd,\n\t\t       int frag_count);\nint mac_drv_rx_init(struct s_smc *smc, int len, int fc, char *look_ahead,\n\t\t    int la_len);\nvoid dump_data(unsigned char *Data, int length);\n\n \nextern u_int mac_drv_check_space(void);\nextern int mac_drv_init(struct s_smc *smc);\nextern void hwm_tx_frag(struct s_smc *smc, char far * virt, u_long phys,\n\t\t\tint len, int frame_status);\nextern int hwm_tx_init(struct s_smc *smc, u_char fc, int frag_count,\n\t\t       int frame_len, int frame_status);\nextern void fddi_isr(struct s_smc *smc);\nextern void hwm_rx_frag(struct s_smc *smc, char far * virt, u_long phys,\n\t\t\tint len, int frame_status);\nextern void mac_drv_rx_mode(struct s_smc *smc, int mode);\nextern void mac_drv_clear_rx_queue(struct s_smc *smc);\nextern void enable_tx_irq(struct s_smc *smc, u_short queue);\n\nstatic const struct pci_device_id skfddi_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_SK, PCI_DEVICE_ID_SK_FP, PCI_ANY_ID, PCI_ANY_ID, },\n\t{ }\t\t\t \n};\nMODULE_DEVICE_TABLE(pci, skfddi_pci_tbl);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Mirko Lindner <mlindner@syskonnect.de>\");\n\n \n\nstatic int num_boards;\t \n\nstatic const struct net_device_ops skfp_netdev_ops = {\n\t.ndo_open\t\t= skfp_open,\n\t.ndo_stop\t\t= skfp_close,\n\t.ndo_start_xmit\t\t= skfp_send_pkt,\n\t.ndo_get_stats\t\t= skfp_ctl_get_stats,\n\t.ndo_set_rx_mode\t= skfp_ctl_set_multicast_list,\n\t.ndo_set_mac_address\t= skfp_ctl_set_mac_address,\n\t.ndo_siocdevprivate\t= skfp_siocdevprivate,\n};\n\n \nstatic int skfp_init_one(struct pci_dev *pdev,\n\t\t\t\tconst struct pci_device_id *ent)\n{\n\tstruct net_device *dev;\n\tstruct s_smc *smc;\t \n\tvoid __iomem *mem;\n\tint err;\n\n\tpr_debug(\"entering skfp_init_one\\n\");\n\n\tif (num_boards == 0) \n\t\tprintk(\"%s\\n\", boot_msg);\n\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\treturn err;\n\n\terr = pci_request_regions(pdev, \"skfddi\");\n\tif (err)\n\t\tgoto err_out1;\n\n\tpci_set_master(pdev);\n\n#ifdef MEM_MAPPED_IO\n\tif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {\n\t\tprintk(KERN_ERR \"skfp: region is not an MMIO resource\\n\");\n\t\terr = -EIO;\n\t\tgoto err_out2;\n\t}\n\n\tmem = ioremap(pci_resource_start(pdev, 0), 0x4000);\n#else\n\tif (!(pci_resource_flags(pdev, 1) & IO_RESOURCE_IO)) {\n\t\tprintk(KERN_ERR \"skfp: region is not PIO resource\\n\");\n\t\terr = -EIO;\n\t\tgoto err_out2;\n\t}\n\n\tmem = ioport_map(pci_resource_start(pdev, 1), FP_IO_LEN);\n#endif\n\tif (!mem) {\n\t\tprintk(KERN_ERR \"skfp:  Unable to map register, \"\n\t\t\t\t\"FDDI adapter will be disabled.\\n\");\n\t\terr = -EIO;\n\t\tgoto err_out2;\n\t}\n\n\tdev = alloc_fddidev(sizeof(struct s_smc));\n\tif (!dev) {\n\t\tprintk(KERN_ERR \"skfp: Unable to allocate fddi device, \"\n\t\t\t\t\"FDDI adapter will be disabled.\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_out3;\n\t}\n\n\tdev->irq = pdev->irq;\n\tdev->netdev_ops = &skfp_netdev_ops;\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\t \n\tsmc = netdev_priv(dev);\n\tsmc->os.dev = dev;\n\tsmc->os.bus_type = SK_BUS_TYPE_PCI;\n\tsmc->os.pdev = *pdev;\n\tsmc->os.QueueSkb = MAX_TX_QUEUE_LEN;\n\tsmc->os.MaxFrameSize = MAX_FRAME_SIZE;\n\tsmc->os.dev = dev;\n\tsmc->hw.slot = -1;\n\tsmc->hw.iop = mem;\n\tsmc->os.ResetRequested = FALSE;\n\tskb_queue_head_init(&smc->os.SendSkbQueue);\n\n\tdev->base_addr = (unsigned long)mem;\n\n\terr = skfp_driver_init(dev);\n\tif (err)\n\t\tgoto err_out4;\n\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto err_out5;\n\n\t++num_boards;\n\tpci_set_drvdata(pdev, dev);\n\n\tif ((pdev->subsystem_device & 0xff00) == 0x5500 ||\n\t    (pdev->subsystem_device & 0xff00) == 0x5800) \n\t\tprintk(\"%s: SysKonnect FDDI PCI adapter\"\n\t\t       \" found (SK-%04X)\\n\", dev->name,\t\n\t\t       pdev->subsystem_device);\n\telse\n\t\tprintk(\"%s: FDDI PCI adapter found\\n\", dev->name);\n\n\treturn 0;\nerr_out5:\n\tif (smc->os.SharedMemAddr) \n\t\tdma_free_coherent(&pdev->dev, smc->os.SharedMemSize,\n\t\t\t\t  smc->os.SharedMemAddr,\n\t\t\t\t  smc->os.SharedMemDMA);\n\tdma_free_coherent(&pdev->dev, MAX_FRAME_SIZE,\n\t\t\t  smc->os.LocalRxBuffer, smc->os.LocalRxBufferDMA);\nerr_out4:\n\tfree_netdev(dev);\nerr_out3:\n#ifdef MEM_MAPPED_IO\n\tiounmap(mem);\n#else\n\tioport_unmap(mem);\n#endif\nerr_out2:\n\tpci_release_regions(pdev);\nerr_out1:\n\tpci_disable_device(pdev);\n\treturn err;\n}\n\n \nstatic void skfp_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *p = pci_get_drvdata(pdev);\n\tstruct s_smc *lp = netdev_priv(p);\n\n\tunregister_netdev(p);\n\n\tif (lp->os.SharedMemAddr) {\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t  lp->os.SharedMemSize,\n\t\t\t\t  lp->os.SharedMemAddr,\n\t\t\t\t  lp->os.SharedMemDMA);\n\t\tlp->os.SharedMemAddr = NULL;\n\t}\n\tif (lp->os.LocalRxBuffer) {\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t  MAX_FRAME_SIZE,\n\t\t\t\t  lp->os.LocalRxBuffer,\n\t\t\t\t  lp->os.LocalRxBufferDMA);\n\t\tlp->os.LocalRxBuffer = NULL;\n\t}\n#ifdef MEM_MAPPED_IO\n\tiounmap(lp->hw.iop);\n#else\n\tioport_unmap(lp->hw.iop);\n#endif\n\tpci_release_regions(pdev);\n\tfree_netdev(p);\n\n\tpci_disable_device(pdev);\n}\n\n \nstatic  int skfp_driver_init(struct net_device *dev)\n{\n\tstruct s_smc *smc = netdev_priv(dev);\n\tskfddi_priv *bp = &smc->os;\n\tint err = -EIO;\n\n\tpr_debug(\"entering skfp_driver_init\\n\");\n\n\t \n\tbp->base_addr = dev->base_addr;\n\n\t \n\tsmc->hw.irq = dev->irq;\n\n\tspin_lock_init(&bp->DriverLock);\n\t\n\t \n\tbp->LocalRxBuffer = dma_alloc_coherent(&bp->pdev.dev, MAX_FRAME_SIZE,\n\t\t\t\t\t       &bp->LocalRxBufferDMA,\n\t\t\t\t\t       GFP_ATOMIC);\n\tif (!bp->LocalRxBuffer) {\n\t\tprintk(\"could not allocate mem for \");\n\t\tprintk(\"LocalRxBuffer: %d byte\\n\", MAX_FRAME_SIZE);\n\t\tgoto fail;\n\t}\n\n\t \n\tbp->SharedMemSize = mac_drv_check_space();\n\tpr_debug(\"Memory for HWM: %ld\\n\", bp->SharedMemSize);\n\tif (bp->SharedMemSize > 0) {\n\t\tbp->SharedMemSize += 16;\t \n\n\t\tbp->SharedMemAddr = dma_alloc_coherent(&bp->pdev.dev,\n\t\t\t\t\t\t       bp->SharedMemSize,\n\t\t\t\t\t\t       &bp->SharedMemDMA,\n\t\t\t\t\t\t       GFP_ATOMIC);\n\t\tif (!bp->SharedMemAddr) {\n\t\t\tprintk(\"could not allocate mem for \");\n\t\t\tprintk(\"hardware module: %ld byte\\n\",\n\t\t\t       bp->SharedMemSize);\n\t\t\tgoto fail;\n\t\t}\n\n\t} else {\n\t\tbp->SharedMemAddr = NULL;\n\t}\n\n\tbp->SharedMemHeap = 0;\n\n\tcard_stop(smc);\t\t \n\n\tpr_debug(\"mac_drv_init()..\\n\");\n\tif (mac_drv_init(smc) != 0) {\n\t\tpr_debug(\"mac_drv_init() failed\\n\");\n\t\tgoto fail;\n\t}\n\tread_address(smc, NULL);\n\tpr_debug(\"HW-Addr: %pMF\\n\", smc->hw.fddi_canon_addr.a);\n\teth_hw_addr_set(dev, smc->hw.fddi_canon_addr.a);\n\n\tsmt_reset_defaults(smc, 0);\n\n\treturn 0;\n\nfail:\n\tif (bp->SharedMemAddr) {\n\t\tdma_free_coherent(&bp->pdev.dev,\n\t\t\t\t  bp->SharedMemSize,\n\t\t\t\t  bp->SharedMemAddr,\n\t\t\t\t  bp->SharedMemDMA);\n\t\tbp->SharedMemAddr = NULL;\n\t}\n\tif (bp->LocalRxBuffer) {\n\t\tdma_free_coherent(&bp->pdev.dev, MAX_FRAME_SIZE,\n\t\t\t\t  bp->LocalRxBuffer, bp->LocalRxBufferDMA);\n\t\tbp->LocalRxBuffer = NULL;\n\t}\n\treturn err;\n}\t\t\t\t \n\n\n \nstatic int skfp_open(struct net_device *dev)\n{\n\tstruct s_smc *smc = netdev_priv(dev);\n\tint err;\n\n\tpr_debug(\"entering skfp_open\\n\");\n\t \n\terr = request_irq(dev->irq, skfp_interrupt, IRQF_SHARED,\n\t\t\t  dev->name, dev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tread_address(smc, NULL);\n\teth_hw_addr_set(dev, smc->hw.fddi_canon_addr.a);\n\n\tinit_smt(smc, NULL);\n\tsmt_online(smc, 1);\n\tSTI_FBI();\n\n\t \n\tmac_clear_multicast(smc);\n\n\t \n\tmac_drv_rx_mode(smc, RX_DISABLE_PROMISC);\n\n\tnetif_start_queue(dev);\n\treturn 0;\n}\t\t\t\t\n\n\n \nstatic int skfp_close(struct net_device *dev)\n{\n\tstruct s_smc *smc = netdev_priv(dev);\n\tskfddi_priv *bp = &smc->os;\n\n\tCLI_FBI();\n\tsmt_reset_defaults(smc, 1);\n\tcard_stop(smc);\n\tmac_drv_clear_tx_queue(smc);\n\tmac_drv_clear_rx_queue(smc);\n\n\tnetif_stop_queue(dev);\n\t \n\tfree_irq(dev->irq, dev);\n\n\tskb_queue_purge(&bp->SendSkbQueue);\n\tbp->QueueSkb = MAX_TX_QUEUE_LEN;\n\n\treturn 0;\n}\t\t\t\t\n\n\n \n\nstatic irqreturn_t skfp_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct s_smc *smc;\t \n\tskfddi_priv *bp;\n\n\tsmc = netdev_priv(dev);\n\tbp = &smc->os;\n\n\t\n\tif (inpd(ADDR(B0_IMSK)) == 0) {\n\t\t\n\t\treturn IRQ_NONE;\n\t}\n\t\n\tif ((inpd(ISR_A) & smc->hw.is_imask) == 0) {\t\n\t\t\n\t\treturn IRQ_NONE;\n\t}\n\tCLI_FBI();\t\t\n\tspin_lock(&bp->DriverLock);\n\n\t\n\tfddi_isr(smc);\n\n\tif (smc->os.ResetRequested) {\n\t\tResetAdapter(smc);\n\t\tsmc->os.ResetRequested = FALSE;\n\t}\n\tspin_unlock(&bp->DriverLock);\n\tSTI_FBI();\t\t\n\n\treturn IRQ_HANDLED;\n}\t\t\t\t\n\n\n \nstatic struct net_device_stats *skfp_ctl_get_stats(struct net_device *dev)\n{\n\tstruct s_smc *bp = netdev_priv(dev);\n\n\t \n\n\tbp->os.MacStat.port_bs_flag[0] = 0x1234;\n\tbp->os.MacStat.port_bs_flag[1] = 0x5678;\n \n#if 0\n\t \n\n \n\n\tmemcpy(bp->stats.smt_station_id, &bp->cmd_rsp_virt->smt_mib_get.smt_station_id, sizeof(bp->cmd_rsp_virt->smt_mib_get.smt_station_id));\n\tbp->stats.smt_op_version_id = bp->cmd_rsp_virt->smt_mib_get.smt_op_version_id;\n\tbp->stats.smt_hi_version_id = bp->cmd_rsp_virt->smt_mib_get.smt_hi_version_id;\n\tbp->stats.smt_lo_version_id = bp->cmd_rsp_virt->smt_mib_get.smt_lo_version_id;\n\tmemcpy(bp->stats.smt_user_data, &bp->cmd_rsp_virt->smt_mib_get.smt_user_data, sizeof(bp->cmd_rsp_virt->smt_mib_get.smt_user_data));\n\tbp->stats.smt_mib_version_id = bp->cmd_rsp_virt->smt_mib_get.smt_mib_version_id;\n\tbp->stats.smt_mac_cts = bp->cmd_rsp_virt->smt_mib_get.smt_mac_ct;\n\tbp->stats.smt_non_master_cts = bp->cmd_rsp_virt->smt_mib_get.smt_non_master_ct;\n\tbp->stats.smt_master_cts = bp->cmd_rsp_virt->smt_mib_get.smt_master_ct;\n\tbp->stats.smt_available_paths = bp->cmd_rsp_virt->smt_mib_get.smt_available_paths;\n\tbp->stats.smt_config_capabilities = bp->cmd_rsp_virt->smt_mib_get.smt_config_capabilities;\n\tbp->stats.smt_config_policy = bp->cmd_rsp_virt->smt_mib_get.smt_config_policy;\n\tbp->stats.smt_connection_policy = bp->cmd_rsp_virt->smt_mib_get.smt_connection_policy;\n\tbp->stats.smt_t_notify = bp->cmd_rsp_virt->smt_mib_get.smt_t_notify;\n\tbp->stats.smt_stat_rpt_policy = bp->cmd_rsp_virt->smt_mib_get.smt_stat_rpt_policy;\n\tbp->stats.smt_trace_max_expiration = bp->cmd_rsp_virt->smt_mib_get.smt_trace_max_expiration;\n\tbp->stats.smt_bypass_present = bp->cmd_rsp_virt->smt_mib_get.smt_bypass_present;\n\tbp->stats.smt_ecm_state = bp->cmd_rsp_virt->smt_mib_get.smt_ecm_state;\n\tbp->stats.smt_cf_state = bp->cmd_rsp_virt->smt_mib_get.smt_cf_state;\n\tbp->stats.smt_remote_disconnect_flag = bp->cmd_rsp_virt->smt_mib_get.smt_remote_disconnect_flag;\n\tbp->stats.smt_station_status = bp->cmd_rsp_virt->smt_mib_get.smt_station_status;\n\tbp->stats.smt_peer_wrap_flag = bp->cmd_rsp_virt->smt_mib_get.smt_peer_wrap_flag;\n\tbp->stats.smt_time_stamp = bp->cmd_rsp_virt->smt_mib_get.smt_msg_time_stamp.ls;\n\tbp->stats.smt_transition_time_stamp = bp->cmd_rsp_virt->smt_mib_get.smt_transition_time_stamp.ls;\n\tbp->stats.mac_frame_status_functions = bp->cmd_rsp_virt->smt_mib_get.mac_frame_status_functions;\n\tbp->stats.mac_t_max_capability = bp->cmd_rsp_virt->smt_mib_get.mac_t_max_capability;\n\tbp->stats.mac_tvx_capability = bp->cmd_rsp_virt->smt_mib_get.mac_tvx_capability;\n\tbp->stats.mac_available_paths = bp->cmd_rsp_virt->smt_mib_get.mac_available_paths;\n\tbp->stats.mac_current_path = bp->cmd_rsp_virt->smt_mib_get.mac_current_path;\n\tmemcpy(bp->stats.mac_upstream_nbr, &bp->cmd_rsp_virt->smt_mib_get.mac_upstream_nbr, FDDI_K_ALEN);\n\tmemcpy(bp->stats.mac_downstream_nbr, &bp->cmd_rsp_virt->smt_mib_get.mac_downstream_nbr, FDDI_K_ALEN);\n\tmemcpy(bp->stats.mac_old_upstream_nbr, &bp->cmd_rsp_virt->smt_mib_get.mac_old_upstream_nbr, FDDI_K_ALEN);\n\tmemcpy(bp->stats.mac_old_downstream_nbr, &bp->cmd_rsp_virt->smt_mib_get.mac_old_downstream_nbr, FDDI_K_ALEN);\n\tbp->stats.mac_dup_address_test = bp->cmd_rsp_virt->smt_mib_get.mac_dup_address_test;\n\tbp->stats.mac_requested_paths = bp->cmd_rsp_virt->smt_mib_get.mac_requested_paths;\n\tbp->stats.mac_downstream_port_type = bp->cmd_rsp_virt->smt_mib_get.mac_downstream_port_type;\n\tmemcpy(bp->stats.mac_smt_address, &bp->cmd_rsp_virt->smt_mib_get.mac_smt_address, FDDI_K_ALEN);\n\tbp->stats.mac_t_req = bp->cmd_rsp_virt->smt_mib_get.mac_t_req;\n\tbp->stats.mac_t_neg = bp->cmd_rsp_virt->smt_mib_get.mac_t_neg;\n\tbp->stats.mac_t_max = bp->cmd_rsp_virt->smt_mib_get.mac_t_max;\n\tbp->stats.mac_tvx_value = bp->cmd_rsp_virt->smt_mib_get.mac_tvx_value;\n\tbp->stats.mac_frame_error_threshold = bp->cmd_rsp_virt->smt_mib_get.mac_frame_error_threshold;\n\tbp->stats.mac_frame_error_ratio = bp->cmd_rsp_virt->smt_mib_get.mac_frame_error_ratio;\n\tbp->stats.mac_rmt_state = bp->cmd_rsp_virt->smt_mib_get.mac_rmt_state;\n\tbp->stats.mac_da_flag = bp->cmd_rsp_virt->smt_mib_get.mac_da_flag;\n\tbp->stats.mac_una_da_flag = bp->cmd_rsp_virt->smt_mib_get.mac_unda_flag;\n\tbp->stats.mac_frame_error_flag = bp->cmd_rsp_virt->smt_mib_get.mac_frame_error_flag;\n\tbp->stats.mac_ma_unitdata_available = bp->cmd_rsp_virt->smt_mib_get.mac_ma_unitdata_available;\n\tbp->stats.mac_hardware_present = bp->cmd_rsp_virt->smt_mib_get.mac_hardware_present;\n\tbp->stats.mac_ma_unitdata_enable = bp->cmd_rsp_virt->smt_mib_get.mac_ma_unitdata_enable;\n\tbp->stats.path_tvx_lower_bound = bp->cmd_rsp_virt->smt_mib_get.path_tvx_lower_bound;\n\tbp->stats.path_t_max_lower_bound = bp->cmd_rsp_virt->smt_mib_get.path_t_max_lower_bound;\n\tbp->stats.path_max_t_req = bp->cmd_rsp_virt->smt_mib_get.path_max_t_req;\n\tmemcpy(bp->stats.path_configuration, &bp->cmd_rsp_virt->smt_mib_get.path_configuration, sizeof(bp->cmd_rsp_virt->smt_mib_get.path_configuration));\n\tbp->stats.port_my_type[0] = bp->cmd_rsp_virt->smt_mib_get.port_my_type[0];\n\tbp->stats.port_my_type[1] = bp->cmd_rsp_virt->smt_mib_get.port_my_type[1];\n\tbp->stats.port_neighbor_type[0] = bp->cmd_rsp_virt->smt_mib_get.port_neighbor_type[0];\n\tbp->stats.port_neighbor_type[1] = bp->cmd_rsp_virt->smt_mib_get.port_neighbor_type[1];\n\tbp->stats.port_connection_policies[0] = bp->cmd_rsp_virt->smt_mib_get.port_connection_policies[0];\n\tbp->stats.port_connection_policies[1] = bp->cmd_rsp_virt->smt_mib_get.port_connection_policies[1];\n\tbp->stats.port_mac_indicated[0] = bp->cmd_rsp_virt->smt_mib_get.port_mac_indicated[0];\n\tbp->stats.port_mac_indicated[1] = bp->cmd_rsp_virt->smt_mib_get.port_mac_indicated[1];\n\tbp->stats.port_current_path[0] = bp->cmd_rsp_virt->smt_mib_get.port_current_path[0];\n\tbp->stats.port_current_path[1] = bp->cmd_rsp_virt->smt_mib_get.port_current_path[1];\n\tmemcpy(&bp->stats.port_requested_paths[0 * 3], &bp->cmd_rsp_virt->smt_mib_get.port_requested_paths[0], 3);\n\tmemcpy(&bp->stats.port_requested_paths[1 * 3], &bp->cmd_rsp_virt->smt_mib_get.port_requested_paths[1], 3);\n\tbp->stats.port_mac_placement[0] = bp->cmd_rsp_virt->smt_mib_get.port_mac_placement[0];\n\tbp->stats.port_mac_placement[1] = bp->cmd_rsp_virt->smt_mib_get.port_mac_placement[1];\n\tbp->stats.port_available_paths[0] = bp->cmd_rsp_virt->smt_mib_get.port_available_paths[0];\n\tbp->stats.port_available_paths[1] = bp->cmd_rsp_virt->smt_mib_get.port_available_paths[1];\n\tbp->stats.port_pmd_class[0] = bp->cmd_rsp_virt->smt_mib_get.port_pmd_class[0];\n\tbp->stats.port_pmd_class[1] = bp->cmd_rsp_virt->smt_mib_get.port_pmd_class[1];\n\tbp->stats.port_connection_capabilities[0] = bp->cmd_rsp_virt->smt_mib_get.port_connection_capabilities[0];\n\tbp->stats.port_connection_capabilities[1] = bp->cmd_rsp_virt->smt_mib_get.port_connection_capabilities[1];\n\tbp->stats.port_bs_flag[0] = bp->cmd_rsp_virt->smt_mib_get.port_bs_flag[0];\n\tbp->stats.port_bs_flag[1] = bp->cmd_rsp_virt->smt_mib_get.port_bs_flag[1];\n\tbp->stats.port_ler_estimate[0] = bp->cmd_rsp_virt->smt_mib_get.port_ler_estimate[0];\n\tbp->stats.port_ler_estimate[1] = bp->cmd_rsp_virt->smt_mib_get.port_ler_estimate[1];\n\tbp->stats.port_ler_cutoff[0] = bp->cmd_rsp_virt->smt_mib_get.port_ler_cutoff[0];\n\tbp->stats.port_ler_cutoff[1] = bp->cmd_rsp_virt->smt_mib_get.port_ler_cutoff[1];\n\tbp->stats.port_ler_alarm[0] = bp->cmd_rsp_virt->smt_mib_get.port_ler_alarm[0];\n\tbp->stats.port_ler_alarm[1] = bp->cmd_rsp_virt->smt_mib_get.port_ler_alarm[1];\n\tbp->stats.port_connect_state[0] = bp->cmd_rsp_virt->smt_mib_get.port_connect_state[0];\n\tbp->stats.port_connect_state[1] = bp->cmd_rsp_virt->smt_mib_get.port_connect_state[1];\n\tbp->stats.port_pcm_state[0] = bp->cmd_rsp_virt->smt_mib_get.port_pcm_state[0];\n\tbp->stats.port_pcm_state[1] = bp->cmd_rsp_virt->smt_mib_get.port_pcm_state[1];\n\tbp->stats.port_pc_withhold[0] = bp->cmd_rsp_virt->smt_mib_get.port_pc_withhold[0];\n\tbp->stats.port_pc_withhold[1] = bp->cmd_rsp_virt->smt_mib_get.port_pc_withhold[1];\n\tbp->stats.port_ler_flag[0] = bp->cmd_rsp_virt->smt_mib_get.port_ler_flag[0];\n\tbp->stats.port_ler_flag[1] = bp->cmd_rsp_virt->smt_mib_get.port_ler_flag[1];\n\tbp->stats.port_hardware_present[0] = bp->cmd_rsp_virt->smt_mib_get.port_hardware_present[0];\n\tbp->stats.port_hardware_present[1] = bp->cmd_rsp_virt->smt_mib_get.port_hardware_present[1];\n\n\n\t \n\n\tbp->stats.mac_frame_cts = bp->cmd_rsp_virt->cntrs_get.cntrs.frame_cnt.ls;\n\tbp->stats.mac_copied_cts = bp->cmd_rsp_virt->cntrs_get.cntrs.copied_cnt.ls;\n\tbp->stats.mac_transmit_cts = bp->cmd_rsp_virt->cntrs_get.cntrs.transmit_cnt.ls;\n\tbp->stats.mac_error_cts = bp->cmd_rsp_virt->cntrs_get.cntrs.error_cnt.ls;\n\tbp->stats.mac_lost_cts = bp->cmd_rsp_virt->cntrs_get.cntrs.lost_cnt.ls;\n\tbp->stats.port_lct_fail_cts[0] = bp->cmd_rsp_virt->cntrs_get.cntrs.lct_rejects[0].ls;\n\tbp->stats.port_lct_fail_cts[1] = bp->cmd_rsp_virt->cntrs_get.cntrs.lct_rejects[1].ls;\n\tbp->stats.port_lem_reject_cts[0] = bp->cmd_rsp_virt->cntrs_get.cntrs.lem_rejects[0].ls;\n\tbp->stats.port_lem_reject_cts[1] = bp->cmd_rsp_virt->cntrs_get.cntrs.lem_rejects[1].ls;\n\tbp->stats.port_lem_cts[0] = bp->cmd_rsp_virt->cntrs_get.cntrs.link_errors[0].ls;\n\tbp->stats.port_lem_cts[1] = bp->cmd_rsp_virt->cntrs_get.cntrs.link_errors[1].ls;\n\n#endif\n\treturn (struct net_device_stats *)&bp->os.MacStat;\n}\t\t\t\t \n\n\n \nstatic void skfp_ctl_set_multicast_list(struct net_device *dev)\n{\n\tstruct s_smc *smc = netdev_priv(dev);\n\tskfddi_priv *bp = &smc->os;\n\tunsigned long Flags;\n\n\tspin_lock_irqsave(&bp->DriverLock, Flags);\n\tskfp_ctl_set_multicast_list_wo_lock(dev);\n\tspin_unlock_irqrestore(&bp->DriverLock, Flags);\n}\t\t\t\t \n\n\n\nstatic void skfp_ctl_set_multicast_list_wo_lock(struct net_device *dev)\n{\n\tstruct s_smc *smc = netdev_priv(dev);\n\tstruct netdev_hw_addr *ha;\n\n\t \n\tif (dev->flags & IFF_PROMISC) {\n\t\tmac_drv_rx_mode(smc, RX_ENABLE_PROMISC);\n\t\tpr_debug(\"PROMISCUOUS MODE ENABLED\\n\");\n\t}\n\t \n\telse {\n\t\tmac_drv_rx_mode(smc, RX_DISABLE_PROMISC);\n\t\tpr_debug(\"PROMISCUOUS MODE DISABLED\\n\");\n\n\t\t \n\t\tmac_clear_multicast(smc);\n\t\tmac_drv_rx_mode(smc, RX_DISABLE_ALLMULTI);\n\n\t\tif (dev->flags & IFF_ALLMULTI) {\n\t\t\tmac_drv_rx_mode(smc, RX_ENABLE_ALLMULTI);\n\t\t\tpr_debug(\"ENABLE ALL MC ADDRESSES\\n\");\n\t\t} else if (!netdev_mc_empty(dev)) {\n\t\t\tif (netdev_mc_count(dev) <= FPMAX_MULTICAST) {\n\t\t\t\t \n\n\t\t\t\t \n\t\t\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\t\t\tmac_add_multicast(smc,\n\t\t\t\t\t\t(struct fddi_addr *)ha->addr,\n\t\t\t\t\t\t1);\n\n\t\t\t\t\tpr_debug(\"ENABLE MC ADDRESS: %pMF\\n\",\n\t\t\t\t\t\t ha->addr);\n\t\t\t\t}\n\n\t\t\t} else {\t \n\n\t\t\t\tmac_drv_rx_mode(smc, RX_ENABLE_ALLMULTI);\n\t\t\t\tpr_debug(\"ENABLE ALL MC ADDRESSES\\n\");\n\t\t\t}\n\t\t} else {\t \n\n\t\t\tpr_debug(\"DISABLE ALL MC ADDRESSES\\n\");\n\t\t}\n\n\t\t \n\t\tmac_update_multicast(smc);\n\t}\n}\t\t\t\t \n\n\n \nstatic int skfp_ctl_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct s_smc *smc = netdev_priv(dev);\n\tstruct sockaddr *p_sockaddr = (struct sockaddr *) addr;\n\tskfddi_priv *bp = &smc->os;\n\tunsigned long Flags;\n\n\n\tdev_addr_set(dev, p_sockaddr->sa_data);\n\tspin_lock_irqsave(&bp->DriverLock, Flags);\n\tResetAdapter(smc);\n\tspin_unlock_irqrestore(&bp->DriverLock, Flags);\n\n\treturn 0;\t\t \n}\t\t\t\t \n\n\n \n\n\nstatic int skfp_siocdevprivate(struct net_device *dev, struct ifreq *rq, void __user *data, int cmd)\n{\n\tstruct s_smc *smc = netdev_priv(dev);\n\tskfddi_priv *lp = &smc->os;\n\tstruct s_skfp_ioctl ioc;\n\tint status = 0;\n\n\tif (copy_from_user(&ioc, data, sizeof(struct s_skfp_ioctl)))\n\t\treturn -EFAULT;\n\n\tif (in_compat_syscall())\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (ioc.cmd) {\n\tcase SKFP_GET_STATS:\t \n\t\tioc.len = sizeof(lp->MacStat);\n\t\tstatus = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)\n\t\t\t\t? -EFAULT : 0;\n\t\tbreak;\n\tcase SKFP_CLR_STATS:\t \n\t\tif (!capable(CAP_NET_ADMIN)) {\n\t\t\tstatus = -EPERM;\n\t\t} else {\n\t\t\tmemset(&lp->MacStat, 0, sizeof(lp->MacStat));\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprintk(\"ioctl for %s: unknown cmd: %04x\\n\", dev->name, ioc.cmd);\n\t\tstatus = -EOPNOTSUPP;\n\n\t}\t\t\t \n\n\treturn status;\n}\t\t\t\t \n\n\n \nstatic netdev_tx_t skfp_send_pkt(struct sk_buff *skb,\n\t\t\t\t       struct net_device *dev)\n{\n\tstruct s_smc *smc = netdev_priv(dev);\n\tskfddi_priv *bp = &smc->os;\n\n\tpr_debug(\"skfp_send_pkt\\n\");\n\n\t \n\n\tif (!(skb->len >= FDDI_K_LLC_ZLEN && skb->len <= FDDI_K_LLC_LEN)) {\n\t\tbp->MacStat.gen.tx_errors++;\t \n\t\t\n\t\tnetif_start_queue(dev);\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\t \n\t}\n\tif (bp->QueueSkb == 0) {\t\n\n\t\tnetif_stop_queue(dev);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\tbp->QueueSkb--;\n\tskb_queue_tail(&bp->SendSkbQueue, skb);\n\tsend_queued_packets(netdev_priv(dev));\n\tif (bp->QueueSkb == 0) {\n\t\tnetif_stop_queue(dev);\n\t}\n\treturn NETDEV_TX_OK;\n\n}\t\t\t\t\n\n\n \nstatic void send_queued_packets(struct s_smc *smc)\n{\n\tskfddi_priv *bp = &smc->os;\n\tstruct sk_buff *skb;\n\tunsigned char fc;\n\tint queue;\n\tstruct s_smt_fp_txd *txd;\t\n\tdma_addr_t dma_address;\n\tunsigned long Flags;\n\n\tint frame_status;\t\n\n\tpr_debug(\"send queued packets\\n\");\n\tfor (;;) {\n\t\t\n\t\tskb = skb_dequeue(&bp->SendSkbQueue);\n\n\t\tif (!skb) {\n\t\t\tpr_debug(\"queue empty\\n\");\n\t\t\treturn;\n\t\t}\t\t\n\n\t\tspin_lock_irqsave(&bp->DriverLock, Flags);\n\t\tfc = skb->data[0];\n\t\tqueue = (fc & FC_SYNC_BIT) ? QUEUE_S : QUEUE_A0;\n#ifdef ESS\n\t\t\n\n\t\tif ((fc & ~(FC_SYNC_BIT | FC_LLC_PRIOR)) == FC_ASYNC_LLC) {\n\t\t\t\n\t\t\tif (!smc->ess.sync_bw_available)\n\t\t\t\tfc &= ~FC_SYNC_BIT; \n\n\t\t\telse {\t\n\n\t\t\t\tif (smc->mib.fddiESSSynchTxMode) {\n\t\t\t\t\t\n\t\t\t\t\tfc |= FC_SYNC_BIT;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\t\t\t\t\n\t\tframe_status = hwm_tx_init(smc, fc, 1, skb->len, queue);\n\n\t\tif ((frame_status & (LOC_TX | LAN_TX)) == 0) {\n\t\t\t\n\n\t\t\tif ((frame_status & RING_DOWN) != 0) {\n\t\t\t\t\n\t\t\t\tpr_debug(\"Tx attempt while ring down.\\n\");\n\t\t\t} else if ((frame_status & OUT_OF_TXD) != 0) {\n\t\t\t\tpr_debug(\"%s: out of TXDs.\\n\", bp->dev->name);\n\t\t\t} else {\n\t\t\t\tpr_debug(\"%s: out of transmit resources\",\n\t\t\t\t\tbp->dev->name);\n\t\t\t}\n\n\t\t\t\n\t\t\t\n\t\t\tskb_queue_head(&bp->SendSkbQueue, skb);\n\t\t\tspin_unlock_irqrestore(&bp->DriverLock, Flags);\n\t\t\treturn;\t\n\n\t\t}\t\t\n\n\t\tbp->QueueSkb++;\t\n\n\t\t\n\t\tCheckSourceAddress(skb->data, smc->hw.fddi_canon_addr.a);\n\n\t\ttxd = (struct s_smt_fp_txd *) HWM_GET_CURR_TXD(smc, queue);\n\n\t\tdma_address = dma_map_single(&(&bp->pdev)->dev, skb->data,\n\t\t\t\t\t     skb->len, DMA_TO_DEVICE);\n\t\tif (frame_status & LAN_TX) {\n\t\t\ttxd->txd_os.skb = skb;\t\t\t\n\t\t\ttxd->txd_os.dma_addr = dma_address;\t\n\t\t}\n\t\thwm_tx_frag(smc, skb->data, dma_address, skb->len,\n                      frame_status | FIRST_FRAG | LAST_FRAG | EN_IRQ_EOF);\n\n\t\tif (!(frame_status & LAN_TX)) {\t\t\n\t\t\tdma_unmap_single(&(&bp->pdev)->dev, dma_address,\n\t\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb_irq(skb);\n\t\t}\n\t\tspin_unlock_irqrestore(&bp->DriverLock, Flags);\n\t}\t\t\t\n\n\treturn;\t\t\t\n\n}\t\t\t\t\n\n\n \nstatic void CheckSourceAddress(unsigned char *frame, unsigned char *hw_addr)\n{\n\tunsigned char SRBit;\n\n\tif ((((unsigned long) frame[1 + 6]) & ~0x01) != 0) \n\n\t\treturn;\n\tif ((unsigned short) frame[1 + 10] != 0)\n\t\treturn;\n\tSRBit = frame[1 + 6] & 0x01;\n\tmemcpy(&frame[1 + 6], hw_addr, ETH_ALEN);\n\tframe[8] |= SRBit;\n}\t\t\t\t\n\n\n \nstatic void ResetAdapter(struct s_smc *smc)\n{\n\n\tpr_debug(\"[fddi: ResetAdapter]\\n\");\n\n\t\n\n\tcard_stop(smc);\t\t\n\n\t\n\tmac_drv_clear_tx_queue(smc);\n\tmac_drv_clear_rx_queue(smc);\n\n\t\n\n\tsmt_reset_defaults(smc, 1);\t\n\n\tinit_smt(smc, (smc->os.dev)->dev_addr);\t\n\n\tsmt_online(smc, 1);\t\n\tSTI_FBI();\n\n\t\n\tskfp_ctl_set_multicast_list_wo_lock(smc->os.dev);\n}\t\t\t\t\n\n\n\n\n \nvoid llc_restart_tx(struct s_smc *smc)\n{\n\tskfddi_priv *bp = &smc->os;\n\n\tpr_debug(\"[llc_restart_tx]\\n\");\n\n\t\n\tspin_unlock(&bp->DriverLock);\n\tsend_queued_packets(smc);\n\tspin_lock(&bp->DriverLock);\n\tnetif_start_queue(bp->dev);\n\n}\t\t\t\t\n\n\n \nvoid *mac_drv_get_space(struct s_smc *smc, unsigned int size)\n{\n\tvoid *virt;\n\n\tpr_debug(\"mac_drv_get_space (%d bytes), \", size);\n\tvirt = (void *) (smc->os.SharedMemAddr + smc->os.SharedMemHeap);\n\n\tif ((smc->os.SharedMemHeap + size) > smc->os.SharedMemSize) {\n\t\tprintk(\"Unexpected SMT memory size requested: %d\\n\", size);\n\t\treturn NULL;\n\t}\n\tsmc->os.SharedMemHeap += size;\t\n\n\tpr_debug(\"mac_drv_get_space end\\n\");\n\tpr_debug(\"virt addr: %lx\\n\", (ulong) virt);\n\tpr_debug(\"bus  addr: %lx\\n\", (ulong)\n\t       (smc->os.SharedMemDMA +\n\t\t((char *) virt - (char *)smc->os.SharedMemAddr)));\n\treturn virt;\n}\t\t\t\t\n\n\n \nvoid *mac_drv_get_desc_mem(struct s_smc *smc, unsigned int size)\n{\n\n\tchar *virt;\n\n\tpr_debug(\"mac_drv_get_desc_mem\\n\");\n\n\t\n\n\tvirt = mac_drv_get_space(smc, size);\n\n\tsize = (u_int) (16 - (((unsigned long) virt) & 15UL));\n\tsize = size % 16;\n\n\tpr_debug(\"Allocate %u bytes alignment gap \", size);\n\tpr_debug(\"for descriptor memory.\\n\");\n\n\tif (!mac_drv_get_space(smc, size)) {\n\t\tprintk(\"fddi: Unable to align descriptor memory.\\n\");\n\t\treturn NULL;\n\t}\n\treturn virt + size;\n}\t\t\t\t\n\n\n \nunsigned long mac_drv_virt2phys(struct s_smc *smc, void *virt)\n{\n\treturn smc->os.SharedMemDMA +\n\t\t((char *) virt - (char *)smc->os.SharedMemAddr);\n}\t\t\t\t\n\n\n \nu_long dma_master(struct s_smc * smc, void *virt, int len, int flag)\n{\n\treturn smc->os.SharedMemDMA +\n\t\t((char *) virt - (char *)smc->os.SharedMemAddr);\n}\t\t\t\t\n\n\n \nvoid dma_complete(struct s_smc *smc, volatile union s_fp_descr *descr, int flag)\n{\n\t \n\tif (flag & DMA_WR) {\n\t\tskfddi_priv *bp = &smc->os;\n\t\tvolatile struct s_smt_fp_rxd *r = &descr->r;\n\n\t\t \n\t\tif (r->rxd_os.skb && r->rxd_os.dma_addr) {\n\t\t\tint MaxFrameSize = bp->MaxFrameSize;\n\n\t\t\tdma_unmap_single(&(&bp->pdev)->dev,\n\t\t\t\t\t r->rxd_os.dma_addr, MaxFrameSize,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tr->rxd_os.dma_addr = 0;\n\t\t}\n\t}\n}\t\t\t\t\n\n\n \nvoid mac_drv_tx_complete(struct s_smc *smc, volatile struct s_smt_fp_txd *txd)\n{\n\tstruct sk_buff *skb;\n\n\tpr_debug(\"entering mac_drv_tx_complete\\n\");\n\t\n\n\tif (!(skb = txd->txd_os.skb)) {\n\t\tpr_debug(\"TXD with no skb assigned.\\n\");\n\t\treturn;\n\t}\n\ttxd->txd_os.skb = NULL;\n\n\t\n\tdma_unmap_single(&(&smc->os.pdev)->dev, txd->txd_os.dma_addr,\n\t\t\t skb->len, DMA_TO_DEVICE);\n\ttxd->txd_os.dma_addr = 0;\n\n\tsmc->os.MacStat.gen.tx_packets++;\t\n\tsmc->os.MacStat.gen.tx_bytes+=skb->len;\t\n\n\t\n\tdev_kfree_skb_irq(skb);\n\n\tpr_debug(\"leaving mac_drv_tx_complete\\n\");\n}\t\t\t\t\n\n\n \n#ifdef DUMPPACKETS\nvoid dump_data(unsigned char *Data, int length)\n{\n\tprintk(KERN_INFO \"---Packet start---\\n\");\n\tprint_hex_dump(KERN_INFO, \"\", DUMP_PREFIX_NONE, 16, 1, Data, min_t(size_t, length, 64), false);\n\tprintk(KERN_INFO \"------------------\\n\");\n}\t\t\t\t\n#else\n#define dump_data(data,len)\n#endif\t\t\t\t\n\n \nvoid mac_drv_rx_complete(struct s_smc *smc, volatile struct s_smt_fp_rxd *rxd,\n\t\t\t int frag_count, int len)\n{\n\tskfddi_priv *bp = &smc->os;\n\tstruct sk_buff *skb;\n\tunsigned char *virt, *cp;\n\tunsigned short ri;\n\tu_int RifLength;\n\n\tpr_debug(\"entering mac_drv_rx_complete (len=%d)\\n\", len);\n\tif (frag_count != 1) {\t\n\n\t\tprintk(\"fddi: Multi-fragment receive!\\n\");\n\t\tgoto RequeueRxd;\t\n\n\t}\n\tskb = rxd->rxd_os.skb;\n\tif (!skb) {\n\t\tpr_debug(\"No skb in rxd\\n\");\n\t\tsmc->os.MacStat.gen.rx_errors++;\n\t\tgoto RequeueRxd;\n\t}\n\tvirt = skb->data;\n\n\t\n\n\tdump_data(skb->data, len);\n\n\t \n\n\t\n\n\tif ((virt[1 + 6] & FDDI_RII) == 0)\n\t\tRifLength = 0;\n\telse {\n\t\tint n;\n\n\t\tpr_debug(\"RIF found\\n\");\n\t\t\n\t\tcp = virt + FDDI_MAC_HDR_LEN;\t\n\n\t\tri = ntohs(*((__be16 *) cp));\n\t\tRifLength = ri & FDDI_RCF_LEN_MASK;\n\t\tif (len < (int) (FDDI_MAC_HDR_LEN + RifLength)) {\n\t\t\tprintk(\"fddi: Invalid RIF.\\n\");\n\t\t\tgoto RequeueRxd;\t\n\n\t\t}\n\t\tvirt[1 + 6] &= ~FDDI_RII;\t\n\t\t\n\n\t\tvirt = cp + RifLength;\n\t\tfor (n = FDDI_MAC_HDR_LEN; n; n--)\n\t\t\t*--virt = *--cp;\n\t\t\n\t\tskb_pull(skb, RifLength);\n\t\tlen -= RifLength;\n\t\tRifLength = 0;\n\t}\n\n\t\n\tsmc->os.MacStat.gen.rx_packets++;\t\n\t\t\t\t\t\t\n\tsmc->os.MacStat.gen.rx_bytes+=len;\t\n\n\t\n\tif (virt[1] & 0x01) {\t\n\n\t\tsmc->os.MacStat.gen.multicast++;\n\t}\n\n\t\n\trxd->rxd_os.skb = NULL;\n\tskb_trim(skb, len);\n\tskb->protocol = fddi_type_trans(skb, bp->dev);\n\n\tnetif_rx(skb);\n\n\tHWM_RX_CHECK(smc, RX_LOW_WATERMARK);\n\treturn;\n\n      RequeueRxd:\n\tpr_debug(\"Rx: re-queue RXD.\\n\");\n\tmac_drv_requeue_rxd(smc, rxd, frag_count);\n\tsmc->os.MacStat.gen.rx_errors++;\t\n\t\t\t\t\t\t\n\n}\t\t\t\t\n\n\n \nvoid mac_drv_requeue_rxd(struct s_smc *smc, volatile struct s_smt_fp_rxd *rxd,\n\t\t\t int frag_count)\n{\n\tvolatile struct s_smt_fp_rxd *next_rxd;\n\tvolatile struct s_smt_fp_rxd *src_rxd;\n\tstruct sk_buff *skb;\n\tint MaxFrameSize;\n\tunsigned char *v_addr;\n\tdma_addr_t b_addr;\n\n\tif (frag_count != 1)\t\n\n\t\tprintk(\"fddi: Multi-fragment requeue!\\n\");\n\n\tMaxFrameSize = smc->os.MaxFrameSize;\n\tsrc_rxd = rxd;\n\tfor (; frag_count > 0; frag_count--) {\n\t\tnext_rxd = src_rxd->rxd_next;\n\t\trxd = HWM_GET_CURR_RXD(smc);\n\n\t\tskb = src_rxd->rxd_os.skb;\n\t\tif (skb == NULL) {\t\n\n\t\t\tpr_debug(\"Requeue with no skb in rxd!\\n\");\n\t\t\tskb = alloc_skb(MaxFrameSize + 3, GFP_ATOMIC);\n\t\t\tif (skb) {\n\t\t\t\t\n\t\t\t\trxd->rxd_os.skb = skb;\n\t\t\t\tskb_reserve(skb, 3);\n\t\t\t\tskb_put(skb, MaxFrameSize);\n\t\t\t\tv_addr = skb->data;\n\t\t\t\tb_addr = dma_map_single(&(&smc->os.pdev)->dev,\n\t\t\t\t\t\t\tv_addr, MaxFrameSize,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\t\trxd->rxd_os.dma_addr = b_addr;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tpr_debug(\"Queueing invalid buffer!\\n\");\n\t\t\t\trxd->rxd_os.skb = NULL;\n\t\t\t\tv_addr = smc->os.LocalRxBuffer;\n\t\t\t\tb_addr = smc->os.LocalRxBufferDMA;\n\t\t\t}\n\t\t} else {\n\t\t\t\n\t\t\trxd->rxd_os.skb = skb;\n\t\t\tv_addr = skb->data;\n\t\t\tb_addr = dma_map_single(&(&smc->os.pdev)->dev, v_addr,\n\t\t\t\t\t\tMaxFrameSize, DMA_FROM_DEVICE);\n\t\t\trxd->rxd_os.dma_addr = b_addr;\n\t\t}\n\t\thwm_rx_frag(smc, v_addr, b_addr, MaxFrameSize,\n\t\t\t    FIRST_FRAG | LAST_FRAG);\n\n\t\tsrc_rxd = next_rxd;\n\t}\n}\t\t\t\t\n\n\n \nvoid mac_drv_fill_rxd(struct s_smc *smc)\n{\n\tint MaxFrameSize;\n\tunsigned char *v_addr;\n\tunsigned long b_addr;\n\tstruct sk_buff *skb;\n\tvolatile struct s_smt_fp_rxd *rxd;\n\n\tpr_debug(\"entering mac_drv_fill_rxd\\n\");\n\n\t\n\t\n\n\tMaxFrameSize = smc->os.MaxFrameSize;\n\t\n\twhile (HWM_GET_RX_FREE(smc) > 0) {\n\t\tpr_debug(\".\\n\");\n\n\t\trxd = HWM_GET_CURR_RXD(smc);\n\t\tskb = alloc_skb(MaxFrameSize + 3, GFP_ATOMIC);\n\t\tif (skb) {\n\t\t\t\n\t\t\tskb_reserve(skb, 3);\n\t\t\tskb_put(skb, MaxFrameSize);\n\t\t\tv_addr = skb->data;\n\t\t\tb_addr = dma_map_single(&(&smc->os.pdev)->dev, v_addr,\n\t\t\t\t\t\tMaxFrameSize, DMA_FROM_DEVICE);\n\t\t\trxd->rxd_os.dma_addr = b_addr;\n\t\t} else {\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tpr_debug(\"Queueing invalid buffer!\\n\");\n\t\t\tv_addr = smc->os.LocalRxBuffer;\n\t\t\tb_addr = smc->os.LocalRxBufferDMA;\n\t\t}\n\n\t\trxd->rxd_os.skb = skb;\n\n\t\t\n\t\thwm_rx_frag(smc, v_addr, b_addr, MaxFrameSize,\n\t\t\t    FIRST_FRAG | LAST_FRAG);\n\t}\n\tpr_debug(\"leaving mac_drv_fill_rxd\\n\");\n}\t\t\t\t\n\n\n \nvoid mac_drv_clear_rxd(struct s_smc *smc, volatile struct s_smt_fp_rxd *rxd,\n\t\t       int frag_count)\n{\n\n\tstruct sk_buff *skb;\n\n\tpr_debug(\"entering mac_drv_clear_rxd\\n\");\n\n\tif (frag_count != 1)\t\n\n\t\tprintk(\"fddi: Multi-fragment clear!\\n\");\n\n\tfor (; frag_count > 0; frag_count--) {\n\t\tskb = rxd->rxd_os.skb;\n\t\tif (skb != NULL) {\n\t\t\tskfddi_priv *bp = &smc->os;\n\t\t\tint MaxFrameSize = bp->MaxFrameSize;\n\n\t\t\tdma_unmap_single(&(&bp->pdev)->dev,\n\t\t\t\t\t rxd->rxd_os.dma_addr, MaxFrameSize,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\n\t\t\tdev_kfree_skb(skb);\n\t\t\trxd->rxd_os.skb = NULL;\n\t\t}\n\t\trxd = rxd->rxd_next;\t\n\n\t}\n}\t\t\t\t\n\n\n \nint mac_drv_rx_init(struct s_smc *smc, int len, int fc,\n\t\t    char *look_ahead, int la_len)\n{\n\tstruct sk_buff *skb;\n\n\tpr_debug(\"entering mac_drv_rx_init(len=%d)\\n\", len);\n\n\t\n\n\tif (len != la_len || len < FDDI_MAC_HDR_LEN || !look_ahead) {\n\t\tpr_debug(\"fddi: Discard invalid local SMT frame\\n\");\n\t\tpr_debug(\"  len=%d, la_len=%d, (ULONG) look_ahead=%08lXh.\\n\",\n\t\t       len, la_len, (unsigned long) look_ahead);\n\t\treturn 0;\n\t}\n\tskb = alloc_skb(len + 3, GFP_ATOMIC);\n\tif (!skb) {\n\t\tpr_debug(\"fddi: Local SMT: skb memory exhausted.\\n\");\n\t\treturn 0;\n\t}\n\tskb_reserve(skb, 3);\n\tskb_put(skb, len);\n\tskb_copy_to_linear_data(skb, look_ahead, len);\n\n\t\n\tskb->protocol = fddi_type_trans(skb, smc->os.dev);\n\tnetif_rx(skb);\n\n\treturn 0;\n}\t\t\t\t\n\n\n \nvoid smt_timer_poll(struct s_smc *smc)\n{\n}\t\t\t\t\n\n\n \nvoid ring_status_indication(struct s_smc *smc, u_long status)\n{\n\tpr_debug(\"ring_status_indication( \");\n\tif (status & RS_RES15)\n\t\tpr_debug(\"RS_RES15 \");\n\tif (status & RS_HARDERROR)\n\t\tpr_debug(\"RS_HARDERROR \");\n\tif (status & RS_SOFTERROR)\n\t\tpr_debug(\"RS_SOFTERROR \");\n\tif (status & RS_BEACON)\n\t\tpr_debug(\"RS_BEACON \");\n\tif (status & RS_PATHTEST)\n\t\tpr_debug(\"RS_PATHTEST \");\n\tif (status & RS_SELFTEST)\n\t\tpr_debug(\"RS_SELFTEST \");\n\tif (status & RS_RES9)\n\t\tpr_debug(\"RS_RES9 \");\n\tif (status & RS_DISCONNECT)\n\t\tpr_debug(\"RS_DISCONNECT \");\n\tif (status & RS_RES7)\n\t\tpr_debug(\"RS_RES7 \");\n\tif (status & RS_DUPADDR)\n\t\tpr_debug(\"RS_DUPADDR \");\n\tif (status & RS_NORINGOP)\n\t\tpr_debug(\"RS_NORINGOP \");\n\tif (status & RS_VERSION)\n\t\tpr_debug(\"RS_VERSION \");\n\tif (status & RS_STUCKBYPASSS)\n\t\tpr_debug(\"RS_STUCKBYPASSS \");\n\tif (status & RS_EVENT)\n\t\tpr_debug(\"RS_EVENT \");\n\tif (status & RS_RINGOPCHANGE)\n\t\tpr_debug(\"RS_RINGOPCHANGE \");\n\tif (status & RS_RES0)\n\t\tpr_debug(\"RS_RES0 \");\n\tpr_debug(\"]\\n\");\n}\t\t\t\t\n\n\n \nunsigned long smt_get_time(void)\n{\n\treturn jiffies;\n}\t\t\t\t\n\n\n \nvoid smt_stat_counter(struct s_smc *smc, int stat)\n{\n\n\n\tpr_debug(\"smt_stat_counter\\n\");\n\tswitch (stat) {\n\tcase 0:\n\t\tpr_debug(\"Ring operational change.\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tpr_debug(\"Receive fifo overflow.\\n\");\n\t\tsmc->os.MacStat.gen.rx_errors++;\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"Unknown status (%d).\\n\", stat);\n\t\tbreak;\n\t}\n}\t\t\t\t\n\n\n \nvoid cfm_state_change(struct s_smc *smc, int c_state)\n{\n#ifdef DRIVERDEBUG\n\tchar *s;\n\n\tswitch (c_state) {\n\tcase SC0_ISOLATED:\n\t\ts = \"SC0_ISOLATED\";\n\t\tbreak;\n\tcase SC1_WRAP_A:\n\t\ts = \"SC1_WRAP_A\";\n\t\tbreak;\n\tcase SC2_WRAP_B:\n\t\ts = \"SC2_WRAP_B\";\n\t\tbreak;\n\tcase SC4_THRU_A:\n\t\ts = \"SC4_THRU_A\";\n\t\tbreak;\n\tcase SC5_THRU_B:\n\t\ts = \"SC5_THRU_B\";\n\t\tbreak;\n\tcase SC7_WRAP_S:\n\t\ts = \"SC7_WRAP_S\";\n\t\tbreak;\n\tcase SC9_C_WRAP_A:\n\t\ts = \"SC9_C_WRAP_A\";\n\t\tbreak;\n\tcase SC10_C_WRAP_B:\n\t\ts = \"SC10_C_WRAP_B\";\n\t\tbreak;\n\tcase SC11_C_WRAP_S:\n\t\ts = \"SC11_C_WRAP_S\";\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"cfm_state_change: unknown %d\\n\", c_state);\n\t\treturn;\n\t}\n\tpr_debug(\"cfm_state_change: %s\\n\", s);\n#endif\t\t\t\t\n}\t\t\t\t\n\n\n \nvoid ecm_state_change(struct s_smc *smc, int e_state)\n{\n#ifdef DRIVERDEBUG\n\tchar *s;\n\n\tswitch (e_state) {\n\tcase EC0_OUT:\n\t\ts = \"EC0_OUT\";\n\t\tbreak;\n\tcase EC1_IN:\n\t\ts = \"EC1_IN\";\n\t\tbreak;\n\tcase EC2_TRACE:\n\t\ts = \"EC2_TRACE\";\n\t\tbreak;\n\tcase EC3_LEAVE:\n\t\ts = \"EC3_LEAVE\";\n\t\tbreak;\n\tcase EC4_PATH_TEST:\n\t\ts = \"EC4_PATH_TEST\";\n\t\tbreak;\n\tcase EC5_INSERT:\n\t\ts = \"EC5_INSERT\";\n\t\tbreak;\n\tcase EC6_CHECK:\n\t\ts = \"EC6_CHECK\";\n\t\tbreak;\n\tcase EC7_DEINSERT:\n\t\ts = \"EC7_DEINSERT\";\n\t\tbreak;\n\tdefault:\n\t\ts = \"unknown\";\n\t\tbreak;\n\t}\n\tpr_debug(\"ecm_state_change: %s\\n\", s);\n#endif\t\t\t\t\n}\t\t\t\t\n\n\n \nvoid rmt_state_change(struct s_smc *smc, int r_state)\n{\n#ifdef DRIVERDEBUG\n\tchar *s;\n\n\tswitch (r_state) {\n\tcase RM0_ISOLATED:\n\t\ts = \"RM0_ISOLATED\";\n\t\tbreak;\n\tcase RM1_NON_OP:\n\t\ts = \"RM1_NON_OP - not operational\";\n\t\tbreak;\n\tcase RM2_RING_OP:\n\t\ts = \"RM2_RING_OP - ring operational\";\n\t\tbreak;\n\tcase RM3_DETECT:\n\t\ts = \"RM3_DETECT - detect dupl addresses\";\n\t\tbreak;\n\tcase RM4_NON_OP_DUP:\n\t\ts = \"RM4_NON_OP_DUP - dupl. addr detected\";\n\t\tbreak;\n\tcase RM5_RING_OP_DUP:\n\t\ts = \"RM5_RING_OP_DUP - ring oper. with dupl. addr\";\n\t\tbreak;\n\tcase RM6_DIRECTED:\n\t\ts = \"RM6_DIRECTED - sending directed beacons\";\n\t\tbreak;\n\tcase RM7_TRACE:\n\t\ts = \"RM7_TRACE - trace initiated\";\n\t\tbreak;\n\tdefault:\n\t\ts = \"unknown\";\n\t\tbreak;\n\t}\n\tpr_debug(\"[rmt_state_change: %s]\\n\", s);\n#endif\t\t\t\t\n}\t\t\t\t\n\n\n \nvoid drv_reset_indication(struct s_smc *smc)\n{\n\tpr_debug(\"entering drv_reset_indication\\n\");\n\n\tsmc->os.ResetRequested = TRUE;\t\n\n}\t\t\t\t\n\nstatic struct pci_driver skfddi_pci_driver = {\n\t.name\t\t= \"skfddi\",\n\t.id_table\t= skfddi_pci_tbl,\n\t.probe\t\t= skfp_init_one,\n\t.remove\t\t= skfp_remove_one,\n};\n\nmodule_pci_driver(skfddi_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}