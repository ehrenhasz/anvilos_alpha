{
  "module_name": "hwmtm.h",
  "hash_id": "0edca2b265ac0881728f45208d1816529606bdeb81f067ec0c41b8b04f2d468b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/fddi/skfp/h/hwmtm.h",
  "human_readable_source": " \n \n\n#ifndef\t_HWM_\n#define\t_HWM_\n\n#include \"mbuf.h\"\n\n \n#ifndef DRV_BUF_FLUSH\n#define DRV_BUF_FLUSH(desc,flag)\n#define DDI_DMA_SYNC_FORCPU\n#define DDI_DMA_SYNC_FORDEV\n#endif\n\n\t \n#define\tRX_ENABLE_PASS_SMT\t21\n#define\tRX_DISABLE_PASS_SMT\t22\n#define\tRX_ENABLE_PASS_NSA\t23\n#define\tRX_DISABLE_PASS_NSA\t24\n#define\tRX_ENABLE_PASS_DB\t25\n#define\tRX_DISABLE_PASS_DB\t26\n#define\tRX_DISABLE_PASS_ALL\t27\n#define\tRX_DISABLE_LLC_PROMISC\t28\n#define\tRX_ENABLE_LLC_PROMISC\t29\n\n\n#ifndef\tDMA_RD\n#define DMA_RD\t\t1\t \n#endif\n#ifndef DMA_WR\n#define DMA_WR\t\t2\t \n#endif\n#define SMT_BUF\t\t0x80\n\n\t \n#define EN_IRQ_EOF\t0x02\t \n#define\tLOC_TX\t\t0x04\t \n#define LAST_FRAG\t0x08\t \n#define\tFIRST_FRAG\t0x10\t \n#define\tLAN_TX\t\t0x20\t \n#define RING_DOWN\t0x40\t \n#define OUT_OF_TXD\t0x80\t \n\n\n#ifndef NULL\n#define NULL \t\t0\n#endif\n\n#define C_INDIC\t\t(1L<<25)\n#define A_INDIC\t\t(1L<<26)\n#define\tRD_FS_LOCAL\t0x80\n\n\t \n#define\tDEBUG_SMTF\t1\n#define\tDEBUG_SMT\t2\n#define\tDEBUG_ECM\t3\n#define\tDEBUG_RMT\t4\n#define\tDEBUG_CFM\t5\n#define\tDEBUG_PCM\t6\n#define\tDEBUG_SBA\t7\n#define\tDEBUG_ESS\t8\n\n#define\tDB_HWM_RX\t10\n#define\tDB_HWM_TX\t11\n#define DB_HWM_GEN\t12\n\nstruct s_mbuf_pool {\n#ifndef\tMB_OUTSIDE_SMC\n\tSMbuf\t\tmb[MAX_MBUF] ;\t\t \n#endif\n\tSMbuf\t\t*mb_start ;\t\t \n\tSMbuf\t\t*mb_free ;\t\t \n} ;\n\nstruct hwm_r {\n\t \n\tu_int\t\t\tlen ;\t\t \n\tchar\t\t\t*mb_pos ;\t \n} ;\n\nstruct hw_modul {\n\t \n\tstruct\ts_mbuf_pool\tmbuf_pool ;\n\tstruct\thwm_r\tr ;\n\n\tunion s_fp_descr volatile *descr_p ;  \n\n\tu_short pass_SMT ;\t\t \n\tu_short pass_NSA ;\t\t \n\tu_short pass_DB ;\t\t \n\tu_short pass_llc_promisc ;\t \n\n\tSMbuf\t*llc_rx_pipe ;\t\t \n\tSMbuf\t*llc_rx_tail ;\t\t \n\tint\tqueued_rx_frames ;\t \n\n\tSMbuf\t*txd_tx_pipe ;\t\t \n\tSMbuf\t*txd_tx_tail ;\t\t \n\tint\tqueued_txd_mb ;\t\t \n\n\tint\trx_break ;\t\t \n\tint\tleave_isr ;\t\t \n\tint\tisr_flag ;\t\t \n\t \n\tstruct s_smt_tx_queue *tx_p ;\t \n\tu_long\ttx_descr ;\t\t \n\tint\ttx_len ;\t\t \n\tSMbuf\t*tx_mb ;\t\t \n\tchar\t*tx_data ;\t\t \n\n\tint\tdetec_count ;\t\t \n\tu_long\trx_len_error ;\t\t \n} ;\n\n\n \n\n#ifdef\tDEBUG\nstruct os_debug {\n\tint\thwm_rx ;\n\tint\thwm_tx ;\n\tint\thwm_gen ;\n} ;\n#endif\n\n#ifdef\tDEBUG\n#ifdef\tDEBUG_BRD\n#define\tDB_P\tsmc->debug\n#else\n#define DB_P\tdebug\n#endif\n\n#define DB_RX(lev, fmt, ...)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (DB_P.d_os.hwm_rx >= (lev))\t\t\t\t\t\\\n\t\tprintf(fmt \"\\n\", ##__VA_ARGS__);\t\t\t\\\n} while (0)\n#define DB_TX(lev, fmt, ...)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (DB_P.d_os.hwm_tx >= (lev))\t\t\t\t\t\\\n\t\tprintf(fmt \"\\n\", ##__VA_ARGS__);\t\t\t\\\n} while (0)\n#define DB_GEN(lev, fmt, ...)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif (DB_P.d_os.hwm_gen >= (lev))\t\t\t\t\t\\\n\t\tprintf(fmt \"\\n\", ##__VA_ARGS__);\t\t\t\\\n} while (0)\n#else\t \n#define DB_RX(lev, fmt, ...)\tno_printk(fmt \"\\n\", ##__VA_ARGS__)\n#define DB_TX(lev, fmt, ...)\tno_printk(fmt \"\\n\", ##__VA_ARGS__)\n#define DB_GEN(lev, fmt, ...)\tno_printk(fmt \"\\n\", ##__VA_ARGS__)\n#endif\t \n\n#ifndef\tSK_BREAK\n#define\tSK_BREAK()\n#endif\n\n\n \n\n \n#define\tHWM_GET_TX_PHYS(txd)\t\t(u_long)AIX_REVERSE((txd)->txd_tbadr)\n\n \n#define\tHWM_GET_TX_LEN(txd)\t((int)AIX_REVERSE((txd)->txd_tbctrl)& RD_LENGTH)\n\n \n#define\tHWM_GET_TX_USED(smc,queue)\t(int) (smc)->hw.fp.tx_q[queue].tx_used\n\n \n#define\tHWM_GET_CURR_TXD(smc,queue)\t(struct s_smt_fp_txd volatile *)\\\n\t\t\t\t\t(smc)->hw.fp.tx_q[queue].tx_curr_put\n\n \n#define\tHWM_GET_RX_FRAG_LEN(rxd)\t((int)AIX_REVERSE((rxd)->rxd_rbctrl)& \\\n\t\t\t\tRD_LENGTH)\n\n \n#define\tHWM_GET_RX_PHYS(rxd)\t(u_long)AIX_REVERSE((rxd)->rxd_rbadr)\n\n \n#define\tHWM_GET_RX_USED(smc)\t((int)(smc)->hw.fp.rx_q[QUEUE_R1].rx_used)\n\n \n#define\tHWM_GET_RX_FREE(smc)\t((int)(smc)->hw.fp.rx_q[QUEUE_R1].rx_free-1)\n\n \n#define\tHWM_GET_CURR_RXD(smc)\t(struct s_smt_fp_rxd volatile *)\\\n\t\t\t\t(smc)->hw.fp.rx_q[QUEUE_R1].rx_curr_put\n\n \n#ifndef HWM_NO_FLOW_CTL\n#define\tHWM_RX_CHECK(smc,low_water) {\\\n\tif ((low_water) >= (smc)->hw.fp.rx_q[QUEUE_R1].rx_used) {\\\n\t\tmac_drv_fill_rxd(smc) ;\\\n\t}\\\n}\n#else\n#define\tHWM_RX_CHECK(smc,low_water)\t\tmac_drv_fill_rxd(smc)\n#endif\n\n#ifndef\tHWM_EBASE\n#define\tHWM_EBASE\t500\n#endif\n\n#define\tHWM_E0001\tHWM_EBASE + 1\n#define\tHWM_E0001_MSG\t\"HWM: Wrong size of s_rxd_os struct\"\n#define\tHWM_E0002\tHWM_EBASE + 2\n#define\tHWM_E0002_MSG\t\"HWM: Wrong size of s_txd_os struct\"\n#define\tHWM_E0003\tHWM_EBASE + 3\n#define\tHWM_E0003_MSG\t\"HWM: smt_free_mbuf() called with NULL pointer\"\n#define\tHWM_E0004\tHWM_EBASE + 4\n#define\tHWM_E0004_MSG\t\"HWM: Parity error rx queue 1\"\n#define\tHWM_E0005\tHWM_EBASE + 5\n#define\tHWM_E0005_MSG\t\"HWM: Encoding error rx queue 1\"\n#define\tHWM_E0006\tHWM_EBASE + 6\n#define\tHWM_E0006_MSG\t\"HWM: Encoding error async tx queue\"\n#define\tHWM_E0007\tHWM_EBASE + 7\n#define\tHWM_E0007_MSG\t\"HWM: Encoding error sync tx queue\"\n#define\tHWM_E0008\tHWM_EBASE + 8\n#define\tHWM_E0008_MSG\t\"\"\n#define\tHWM_E0009\tHWM_EBASE + 9\n#define\tHWM_E0009_MSG\t\"HWM: Out of RxD condition detected\"\n#define\tHWM_E0010\tHWM_EBASE + 10\n#define\tHWM_E0010_MSG\t\"HWM: A protocol layer has tried to send a frame with an invalid frame control\"\n#define HWM_E0011\tHWM_EBASE + 11\n#define HWM_E0011_MSG\t\"HWM: mac_drv_clear_tx_queue was called although the hardware wasn't stopped\"\n#define HWM_E0012\tHWM_EBASE + 12\n#define HWM_E0012_MSG\t\"HWM: mac_drv_clear_rx_queue was called although the hardware wasn't stopped\"\n#define HWM_E0013\tHWM_EBASE + 13\n#define HWM_E0013_MSG\t\"HWM: mac_drv_repair_descr was called although the hardware wasn't stopped\"\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}