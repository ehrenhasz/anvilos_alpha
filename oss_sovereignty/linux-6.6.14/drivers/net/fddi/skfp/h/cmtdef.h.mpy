{
  "module_name": "cmtdef.h",
  "hash_id": "3812e93370c2ccb07e30dffd4c2bc1ab4ad1a7f1c2de8dff54ff3eb1c47fa196",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/fddi/skfp/h/cmtdef.h",
  "human_readable_source": " \n \n\n#ifndef\t_CMTDEF_\n#define _CMTDEF_\n\n \n\n \n#define AMDPLC\t\t\t \n#ifdef\tCONC\n#define NUMPHYS\t\t12\t \n#else\n#ifdef\tCONC_II\n#define NUMPHYS\t\t24\t \n#else\n#define NUMPHYS\t\t2\t \n#endif\n#endif\n#define NUMMACS\t\t1\t \n#define NUMPATHS\t2\t \n\n \n\n \n\n#if\tNUMPHYS > 2\n#define CONCENTRATOR\n#endif\n\n \n#ifdef\tlint\n#define LINT_USE(x)\t(x)=(x)\n#else\n#define LINT_USE(x)\n#endif\n\n#ifdef\tDEBUG\n#define\tDB_PR(flag, fmt, ...)\t\t\t\t\t\t\\\n\tdo { if (flag) printf(fmt \"\\n\", ##__VA_ARGS__); } while (0)\n#else\n#define\tDB_PR(flag, fmt, ...)\tno_printk(fmt \"\\n\", ##__VA_ARGS__)\n\n#endif\n\n#ifdef DEBUG_BRD\n#define DB_TEST (smc->debug)\n#else\n#define DB_TEST (debug)\n#endif\n\n#define DB_ECM(fmt, ...)\t\t\t\t\t\t\\\n\tDB_PR((DB_TEST).d_smt & 1, fmt, ##__VA_ARGS__)\n#define DB_ECMN(n, fmt, ...)\t\t\t\t\t\t\\\n\tDB_PR((DB_TEST).d_ecm >= (n), fmt, ##__VA_ARGS__)\n#define DB_RMT(fmt, ...)\t\t\t\t\t\t\\\n\tDB_PR((DB_TEST).d_smt & 2, fmt, ##__VA_ARGS__)\n#define DB_RMTN(n, fmt, ...)\t\t\t\t\t\t\\\n\tDB_PR((DB_TEST).d_rmt >= (n), fmt, ##__VA_ARGS__)\n#define DB_CFM(fmt, ...)\t\t\t\t\t\t\\\n\tDB_PR((DB_TEST).d_smt & 4, fmt, ##__VA_ARGS__)\n#define DB_CFMN(n, fmt, ...)\t\t\t\t\t\t\\\n\tDB_PR((DB_TEST).d_cfm >= (n), fmt, ##__VA_ARGS__)\n#define DB_PCM(fmt, ...)\t\t\t\t\t\t\\\n\tDB_PR((DB_TEST).d_smt & 8, fmt, ##__VA_ARGS__)\n#define DB_PCMN(n, fmt, ...)\t\t\t\t\t\t\\\n\tDB_PR((DB_TEST).d_pcm >= (n), fmt, ##__VA_ARGS__)\n#define DB_SMT(fmt, ...)\t\t\t\t\t\t\\\n\tDB_PR((DB_TEST).d_smtf, fmt, ##__VA_ARGS__)\n#define DB_SMTN(n, fmt, ...)\t\t\t\t\t\t\\\n\tDB_PR((DB_TEST).d_smtf >= (n), fmt, ##__VA_ARGS__)\n#define DB_SBA(fmt, ...)\t\t\t\t\t\t\\\n\tDB_PR((DB_TEST).d_sba, fmt, ##__VA_ARGS__)\n#define DB_SBAN(n, fmt, ...)\t\t\t\t\t\t\\\n\tDB_PR((DB_TEST).d_sba >= (n), fmt, ##__VA_ARGS__)\n#define DB_ESS(fmt, ...)\t\t\t\t\t\t\\\n\tDB_PR((DB_TEST).d_ess, fmt, ##__VA_ARGS__)\n#define DB_ESSN(n, fmt, ...)\t\t\t\t\t\t\\\n\tDB_PR((DB_TEST).d_ess >= (n), fmt, ##__VA_ARGS__)\n\n#ifndef\tSS_NOT_DS\n#define\tSK_LOC_DECL(type,var)\ttype var\n#else\n#define\tSK_LOC_DECL(type,var)\tstatic type var\n#endif\n \n#define PA\t\t0\n#define PB\t\t1\n#if\tdefined(SUPERNET_3) || defined(CONC_II)\n \n#define PS\t\t0\t \n#else\n#define PS\t\t1\n#endif\n#define PM\t\t2\t\t \n\n \n#define TA\t\t\t0\t \n#define TB\t\t\t1\t \n#define TS\t\t\t2\t \n#define TM\t\t\t3\t \n#define TNONE\t\t\t4\n\n\n \n#define INDEX_MAC\t1\n#define INDEX_PATH\t1\n#define INDEX_PORT\t1\n\n\n \n#define POLICY_AA\t(1<<0)\t\t \n#define POLICY_AB\t(1<<1)\t\t \n#define POLICY_AS\t(1<<2)\t\t \n#define POLICY_AM\t(1<<3)\t\t \n#define POLICY_BA\t(1<<4)\t\t \n#define POLICY_BB\t(1<<5)\t\t \n#define POLICY_BS\t(1<<6)\t\t \n#define POLICY_BM\t(1<<7)\t\t \n#define POLICY_SA\t(1<<8)\t\t \n#define POLICY_SB\t(1<<9)\t\t \n#define POLICY_SS\t(1<<10)\t\t \n#define POLICY_SM\t(1<<11)\t\t \n#define POLICY_MA\t(1<<12)\t\t \n#define POLICY_MB\t(1<<13)\t\t \n#define POLICY_MS\t(1<<14)\t\t \n#define POLICY_MM\t(1<<15)\t\t \n\n \n\n \n#define EVENT_ECM\t1\t\t \n#define EVENT_CFM\t2\t\t \n#define EVENT_RMT\t3\t\t \n#define EVENT_SMT\t4\t\t \n#define EVENT_PCM\t5\t\t \n#define EVENT_PCMA\t5\t\t \n#define EVENT_PCMB\t6\t\t \n\n \n\n#define EV_TOKEN(class,event)\t(((u_long)(class)<<16L)|((u_long)(event)))\n#define EV_T_CLASS(token)\t((int)((token)>>16)&0xffff)\n#define EV_T_EVENT(token)\t((int)(token)&0xffff)\n\n \n#define EC_CONNECT\t1\t\t \n#define EC_DISCONNECT\t2\t\t \n#define EC_TRACE_PROP\t3\t\t \n#define EC_PATH_TEST\t4\t\t \n#define EC_TIMEOUT_TD\t5\t\t \n#define EC_TIMEOUT_TMAX\t6\t\t \n#define EC_TIMEOUT_IMAX\t7\t\t \n#define EC_TIMEOUT_INMAX 8\t\t \n#define EC_TEST_DONE\t9\t\t \n\n \n#define CF_LOOP\t\t1\t\t \n#define CF_LOOP_A\t1\t\t \n#define CF_LOOP_B\t2\t\t \n#define CF_JOIN\t\t3\t\t \n#define CF_JOIN_A\t3\t\t \n#define CF_JOIN_B\t4\t\t \n\n \n#define PC_START\t\t1\n#define PC_STOP\t\t\t2\n#define PC_LOOP\t\t\t3\n#define PC_JOIN\t\t\t4\n#define PC_SIGNAL\t\t5\n#define PC_REJECT\t\t6\n#define PC_MAINT    \t\t7\n#define PC_TRACE\t\t8\n#define PC_PDR\t\t\t9\n#define PC_ENABLE\t\t10\n#define PC_DISABLE\t\t11\n\n \n#define PC_QLS\t\t\t12\n#define PC_ILS\t\t\t13\n#define PC_MLS\t\t\t14\n#define PC_HLS\t\t\t15\n#define PC_LS_PDR\t\t16\n#define PC_LS_NONE\t\t17\n#define LS2MIB(x)\t((x)-PC_QLS)\n#define MIB2LS(x)\t((x)+PC_QLS)\n\n#define PC_TIMEOUT_TB_MAX\t18\t \n#define PC_TIMEOUT_TB_MIN\t19\t \n#define PC_TIMEOUT_C_MIN\t20\t \n#define PC_TIMEOUT_T_OUT\t21\t \n#define PC_TIMEOUT_TL_MIN\t22\t \n#define PC_TIMEOUT_T_NEXT\t23\t \n#define PC_TIMEOUT_LCT\t\t24\n#define PC_NSE\t\t\t25\t \n#define PC_LEM\t\t\t26\t \n\n \n#define RM_RING_OP\t1\t\t \n#define RM_RING_NON_OP\t2\t\t \n#define RM_MY_BEACON\t3\t\t \n#define RM_OTHER_BEACON\t4\t\t \n#define RM_MY_CLAIM\t5\t\t \n#define RM_TRT_EXP\t6\t\t \n#define RM_VALID_CLAIM\t7\t\t \n#define RM_JOIN\t\t8\t\t \n#define RM_LOOP\t\t9\t\t \n#define RM_DUP_ADDR\t10\t\t \n#define RM_ENABLE_FLAG\t11\t\t \n\n#define RM_TIMEOUT_NON_OP\t12\t \n#define RM_TIMEOUT_T_STUCK\t13\t \n#define RM_TIMEOUT_ANNOUNCE\t14\t \n#define RM_TIMEOUT_T_DIRECT\t15\t \n#define RM_TIMEOUT_D_MAX\t16\t \n#define RM_TIMEOUT_POLL\t\t17\t \n#define RM_TX_STATE_CHANGE\t18\t \n\n \n#define SM_TIMER\t1\t\t \n#define SM_FAST\t\t2\t\t \n\n \n#define PM_NONE\t\t0\n#define PM_PEER\t\t1\n#define PM_TREE\t\t2\n\n \n#define PC_WH_NONE\t0\t\t \n#define PC_WH_M_M\t1\t\t \n#define PC_WH_OTHER\t2\t\t \n#define PC_WH_PATH\t3\t\t \n \n#define LC_SHORT\t1\t\t \n#define LC_MEDIUM\t2\t\t \n#define LC_LONG\t\t3\t\t \n#define LC_EXTENDED\t4\t\t \n\n \n#define PT_NONE\t\t0\n#define PT_TESTING\t1\t\t \n#define PT_PASSED\t2\t\t \n#define PT_FAILED\t3\t\t \n#define PT_PENDING\t4\t\t \n#define PT_EXITING\t5\t\t \n\n \n#define DA_NONE\t\t0\t\t \n#define DA_PASSED\t1\t\t \n#define DA_FAILED\t2\t\t \n\n\n \n#define BP_DEINSERT\t0\t\t \n#define BP_INSERT\t1\t\t \n\n \n#define PM_TRANSMIT_DISABLE\t0\t \n#define PM_TRANSMIT_ENABLE\t1\t \n\n \n#define MUX_THRUA\t0\t\t \n#define MUX_THRUB\t1\t\t \n#define MUX_WRAPA\t2\t\t \n#define MUX_WRAPB\t3\t\t \n#define MUX_ISOLATE\t4\t\t \n#define MUX_WRAPS\t5\t\t \n\n \n#define MA_RESET\t0\n#define MA_BEACON\t1\n#define MA_CLAIM\t2\n#define MA_DIRECTED\t3\t\t \n#define MA_TREQ\t\t4\t\t \n#define MA_OFFLINE\t5\t\t \n\n\n \n#define ENTITY_MAC\t(NUMPHYS)\n#define ENTITY_PHY(p)\t(p)\n#define ENTITY_BIT(m)\t(1<<(m))\n\n \n#define PATH_ISO\t0\t \n#define PATH_PRIM\t3\t \n#define PATH_THRU\t5\t \n\n#define RES_MAC\t\t2\t \n#define RES_PORT\t4\t \n\n\n \n#define SC0_ISOLATED\t0\t\t \n#define SC1_WRAP_A\t5\t\t \n#define SC2_WRAP_B\t6\t\t \n#define SC4_THRU_A\t12\t\t \n#define SC5_THRU_B\t7\t\t \n#define SC7_WRAP_S\t8\t\t \n#define SC9_C_WRAP_A\t9\t\t \n#define SC10_C_WRAP_B\t10\t\t \n#define SC11_C_WRAP_S\t11\t\t \n\n \n#define MIB2US(t)\t\t((t)/12)\n#define SEC2MIB(s)\t((s)*12500000L)\n \nstruct smt_timer {\n\tstruct smt_timer\t*tm_next ;\t \n\tstruct s_smc\t\t*tm_smc ;\t \n\tu_long\t\t\ttm_delta ;\t \n\tu_long\t\t\ttm_token ;\t \n\tu_short\t\t\ttm_active ;\t \n\tu_short\t\t\ttm_pad ;\t \n} ;\n\n \nstruct mac_parameter {\n\tu_long\tt_neg ;\t\t \n\tu_long\tt_pri ;\t\t \n} ;\n\n \nstruct mac_counter {\n\tu_long\tmac_nobuf_counter ;\t \n\tu_long\tmac_r_restart_counter ;\t \n} ;\n\n \nstruct s_pcon {\n\tint\tpc_len ;\n\tint\tpc_err ;\n\tint\tpc_badset ;\n\tvoid\t*pc_p ;\n} ;\n\n \n#define LEM_AVG\t5\nstruct lem_counter {\n#ifdef\tAM29K\n\tint\tlem_on\t;\n\tu_long\tlem_errors ;\n\tu_long\tlem_symbols ;\n\tu_long\tlem_tsymbols ;\n\tint\tlem_s_count ;\n\tint\tlem_n_s ;\n\tint\tlem_values ;\n\tint\tlem_index ;\n\tint\tlem_avg_ber[LEM_AVG] ;\n\tint\tlem_sum ;\n#else\n\tu_short\tlem_float_ber ;\t\t \n\tu_long\tlem_errors ;\t\t \n\tu_short\tlem_on\t;\n#endif\n} ;\n\n#define NUMBITS\t10\n\n#ifdef\tAMDPLC\n\n \nstruct s_plc {\n\tu_short\tp_state ;\t\t \n\tu_short\tp_bits ;\t\t \n\tu_short\tp_start ;\t\t \n\tu_short\tp_pad ;\t\t\t \n\tu_long soft_err ;\t\t \n\tu_long parity_err ;\t\t \n\tu_long ebuf_err ;\t\t \n\tu_long ebuf_cont ;\t\t \n\tu_long phyinv ;\t\t\t \n\tu_long vsym_ctr ;\t\t \n\tu_long mini_ctr ;\t\t \n\tu_long tpc_exp ;\t\t \n\tu_long np_err ;\t\t\t \n\tu_long b_pcs ;\t\t\t \n\tu_long b_tpc ;\t\t\t \n\tu_long b_tne ;\t\t\t \n\tu_long b_qls ;\t\t\t \n\tu_long b_ils ;\t\t\t \n\tu_long b_hls ;\t\t\t \n} ;\n#endif\n\n#ifdef\tPROTOTYP_INC\n#include \"fddi/driver.pro\"\n#else\t \n \n#include \"mbuf.h\"\t \n#include \"smtstate.h\"\t \n\nvoid hwt_restart(struct s_smc *smc);\t \nSMbuf *smt_build_frame(struct s_smc *smc, int class, int type,\n\t\t       int length);\t \nSMbuf *smt_get_mbuf(struct s_smc *smc);\t \nvoid *sm_to_para(struct s_smc *smc, struct smt_header *sm,\n\t\t int para);\t\t \n\n#ifndef SK_UNUSED\n#define SK_UNUSED(var)\t\t(void)(var)\n#endif\n\nvoid queue_event(struct s_smc *smc, int class, int event);\nvoid ecm(struct s_smc *smc, int event);\nvoid ecm_init(struct s_smc *smc);\nvoid rmt(struct s_smc *smc, int event);\nvoid rmt_init(struct s_smc *smc);\nvoid pcm(struct s_smc *smc, const int np, int event);\nvoid pcm_init(struct s_smc *smc);\nvoid cfm(struct s_smc *smc, int event);\nvoid cfm_init(struct s_smc *smc);\nvoid smt_timer_start(struct s_smc *smc, struct smt_timer *timer, u_long time,\n\t\t     u_long token);\nvoid smt_timer_stop(struct s_smc *smc, struct smt_timer *timer);\nvoid pcm_status_state(struct s_smc *smc, int np, int *type, int *state,\n\t\t      int *remote, int *mac);\nvoid plc_config_mux(struct s_smc *smc, int mux);\nvoid sm_lem_evaluate(struct s_smc *smc);\nvoid mac_update_counter(struct s_smc *smc);\nvoid sm_ma_control(struct s_smc *smc, int mode);\nvoid sm_mac_check_beacon_claim(struct s_smc *smc);\nvoid config_mux(struct s_smc *smc, int mux);\nvoid smt_agent_init(struct s_smc *smc);\nvoid smt_timer_init(struct s_smc *smc);\nvoid smt_received_pack(struct s_smc *smc, SMbuf *mb, int fs);\nvoid smt_add_para(struct s_smc *smc, struct s_pcon *pcon, u_short para,\n\t\t  int index, int local);\nvoid smt_swap_para(struct smt_header *sm, int len, int direction);\nvoid ev_init(struct s_smc *smc);\nvoid hwt_init(struct s_smc *smc);\nu_long hwt_read(struct s_smc *smc);\nvoid hwt_stop(struct s_smc *smc);\nvoid hwt_start(struct s_smc *smc, u_long time);\nvoid smt_send_mbuf(struct s_smc *smc, SMbuf *mb, int fc);\nvoid smt_free_mbuf(struct s_smc *smc, SMbuf *mb);\nvoid sm_pm_bypass_req(struct s_smc *smc, int mode);\nvoid rmt_indication(struct s_smc *smc, int i);\nvoid cfm_state_change(struct s_smc *smc, int c_state);\n\n#if defined(DEBUG) || !defined(NO_SMT_PANIC)\nvoid smt_panic(struct s_smc *smc, char *text);\n#else\n#define\tsmt_panic(smc,text)\n#endif  \n\nvoid smt_stat_counter(struct s_smc *smc, int stat);\nvoid smt_timer_poll(struct s_smc *smc);\nu_long smt_get_time(void);\nu_long smt_get_tid(struct s_smc *smc);\nvoid smt_timer_done(struct s_smc *smc);\nvoid smt_fixup_mib(struct s_smc *smc);\nvoid smt_reset_defaults(struct s_smc *smc, int level);\nvoid smt_agent_task(struct s_smc *smc);\nint smt_check_para(struct s_smc *smc, struct smt_header *sm,\n\t\t   const u_short list[]);\nvoid driver_get_bia(struct s_smc *smc, struct fddi_addr *bia_addr);\n\n#ifdef SUPERNET_3\nvoid drv_reset_indication(struct s_smc *smc);\n#endif\t \n\nvoid smt_start_watchdog(struct s_smc *smc);\nvoid smt_event(struct s_smc *smc, int event);\nvoid timer_event(struct s_smc *smc, u_long token);\nvoid ev_dispatcher(struct s_smc *smc);\nvoid pcm_get_state(struct s_smc *smc, struct smt_state *state);\nvoid ecm_state_change(struct s_smc *smc, int e_state);\nint sm_pm_bypass_present(struct s_smc *smc);\nvoid pcm_state_change(struct s_smc *smc, int plc, int p_state);\nvoid rmt_state_change(struct s_smc *smc, int r_state);\nint sm_pm_get_ls(struct s_smc *smc, int phy);\nint pcm_get_s_port(struct s_smc *smc);\nint pcm_rooted_station(struct s_smc *smc);\nint cfm_get_mac_input(struct s_smc *smc);\nint cfm_get_mac_output(struct s_smc *smc);\nint cem_build_path(struct s_smc *smc, char *to, int path_index);\nint sm_mac_get_tx_state(struct s_smc *smc);\nchar *get_pcmstate(struct s_smc *smc, int np);\nint smt_action(struct s_smc *smc, int class, int code, int index);\nu_short smt_online(struct s_smc *smc, int on);\nvoid smt_force_irq(struct s_smc *smc);\nvoid smt_pmf_received_pack(struct s_smc *smc, SMbuf *mb, int local);\nvoid smt_send_frame(struct s_smc *smc, SMbuf *mb, int fc, int local);\nvoid smt_set_timestamp(struct s_smc *smc, u_char *p);\nvoid mac_set_rx_mode(struct s_smc *smc,\tint mode);\nint mac_add_multicast(struct s_smc *smc, struct fddi_addr *addr, int can);\nvoid mac_update_multicast(struct s_smc *smc);\nvoid mac_clear_multicast(struct s_smc *smc);\nvoid set_formac_tsync(struct s_smc *smc, long sync_bw);\nvoid formac_reinit_tx(struct s_smc *smc);\nvoid formac_tx_restart(struct s_smc *smc);\nvoid process_receive(struct s_smc *smc);\nvoid init_driver_fplus(struct s_smc *smc);\nvoid rtm_irq(struct s_smc *smc);\nvoid rtm_set_timer(struct s_smc *smc);\nvoid ring_status_indication(struct s_smc *smc, u_long status);\nvoid llc_recover_tx(struct s_smc *smc);\nvoid llc_restart_tx(struct s_smc *smc);\nvoid plc_clear_irq(struct s_smc *smc, int p);\nvoid plc_irq(struct s_smc *smc,\tint np,\tunsigned int cmd);\nint smt_set_mac_opvalues(struct s_smc *smc);\n\n#ifdef TAG_MODE\nvoid mac_do_pci_fix(struct s_smc *smc);\nvoid mac_drv_clear_tx_queue(struct s_smc *smc);\nvoid mac_drv_repair_descr(struct s_smc *smc);\nu_long hwt_quick_read(struct s_smc *smc);\nvoid hwt_wait_time(struct s_smc *smc, u_long start, long duration);\n#endif\n\n#ifdef SMT_PNMI\nint pnmi_init(struct s_smc* smc);\nint pnmi_process_ndis_id(struct s_smc *smc, u_long ndis_oid, void *buf, int len,\n\t\t\t int *BytesAccessed, int *BytesNeeded, u_char action);\n#endif\n\n#ifdef\tSBA\n#ifndef _H2INC\nvoid sba();\n#endif\nvoid sba_raf_received_pack();\nvoid sba_timer_poll();\nvoid smt_init_sba();\n#endif\n\n#ifdef\tESS\nint ess_raf_received_pack(struct s_smc *smc, SMbuf *mb, struct smt_header *sm,\n\t\t\t  int fs);\nvoid ess_timer_poll(struct s_smc *smc);\nvoid ess_para_change(struct s_smc *smc);\n#endif\n\n#ifndef\tBOOT\nvoid smt_init_evc(struct s_smc *smc);\nvoid smt_srf_event(struct s_smc *smc, int code, int index, int cond);\n#else\n#define smt_init_evc(smc)\n#define smt_srf_event(smc,code,index,cond)\n#endif\n\n#ifndef SMT_REAL_TOKEN_CT\nvoid smt_emulate_token_ct(struct s_smc *smc, int mac_index);\n#endif\n\n#if defined(DEBUG) && !defined(BOOT)\nvoid dump_smt(struct s_smc *smc, struct smt_header *sm, char *text);\n#else\n#define\tdump_smt(smc,sm,text)\n#endif\n\n#ifdef\tDEBUG\nvoid dump_hex(char *p, int len);\n#endif\n\n#endif\t \n\n \n#ifndef PNMI_INIT\n#define\tPNMI_INIT(smc)\t \n#endif\n\n \n#ifndef\tSMT_PANIC\n#define\tSMT_PANIC(smc,nr,msg)\tsmt_panic (smc, msg)\n#endif\n\n#ifndef\tSMT_ERR_LOG\n#define\tSMT_ERR_LOG(smc,nr,msg)\tSMT_PANIC (smc, nr, msg)\n#endif\n\n#ifndef\tSMT_EBASE\n#define\tSMT_EBASE\t100\n#endif\n\n#define\tSMT_E0100\tSMT_EBASE + 0\n#define\tSMT_E0100_MSG\t\"cfm FSM: invalid ce_type\"\n#define\tSMT_E0101\tSMT_EBASE + 1\n#define\tSMT_E0101_MSG\t\"CEM: case ???\"\n#define\tSMT_E0102\tSMT_EBASE + 2\n#define\tSMT_E0102_MSG\t\"CEM A: invalid state\"\n#define\tSMT_E0103\tSMT_EBASE + 3\n#define\tSMT_E0103_MSG\t\"CEM B: invalid state\"\n#define\tSMT_E0104\tSMT_EBASE + 4\n#define\tSMT_E0104_MSG\t\"CEM M: invalid state\"\n#define\tSMT_E0105\tSMT_EBASE + 5\n#define\tSMT_E0105_MSG\t\"CEM S: invalid state\"\n#define\tSMT_E0106\tSMT_EBASE + 6\n#define\tSMT_E0106_MSG\t\"CFM : invalid state\"\n#define\tSMT_E0107\tSMT_EBASE + 7\n#define\tSMT_E0107_MSG\t\"ECM : invalid state\"\n#define\tSMT_E0108\tSMT_EBASE + 8\n#define\tSMT_E0108_MSG\t\"prop_actions : NAC in DAS CFM\"\n#define\tSMT_E0109\tSMT_EBASE + 9\n#define\tSMT_E0109_MSG\t\"ST2U.FM_SERRSF error in special frame\"\n#define\tSMT_E0110\tSMT_EBASE + 10\n#define\tSMT_E0110_MSG\t\"ST2U.FM_SRFRCTOV recv. count. overflow\"\n#define\tSMT_E0111\tSMT_EBASE + 11\n#define\tSMT_E0111_MSG\t\"ST2U.FM_SNFSLD NP & FORMAC simult. load\"\n#define\tSMT_E0112\tSMT_EBASE + 12\n#define\tSMT_E0112_MSG\t\"ST2U.FM_SRCVFRM single-frame recv.-mode\"\n#define\tSMT_E0113\tSMT_EBASE + 13\n#define\tSMT_E0113_MSG\t\"FPLUS: Buffer Memory Error\"\n#define\tSMT_E0114\tSMT_EBASE + 14\n#define\tSMT_E0114_MSG\t\"ST2U.FM_SERRSF error in special frame\"\n#define\tSMT_E0115\tSMT_EBASE + 15\n#define\tSMT_E0115_MSG\t\"ST3L: parity error in receive queue 2\"\n#define\tSMT_E0116\tSMT_EBASE + 16\n#define\tSMT_E0116_MSG\t\"ST3L: parity error in receive queue 1\"\n#define\tSMT_E0117\tSMT_EBASE + 17\n#define\tSMT_E0117_MSG\t\"E_SMT_001: RxD count for receive queue 1 = 0\"\n#define\tSMT_E0118\tSMT_EBASE + 18\n#define\tSMT_E0118_MSG\t\"PCM : invalid state\"\n#define\tSMT_E0119\tSMT_EBASE + 19\n#define\tSMT_E0119_MSG\t\"smt_add_para\"\n#define\tSMT_E0120\tSMT_EBASE + 20\n#define\tSMT_E0120_MSG\t\"smt_set_para\"\n#define\tSMT_E0121\tSMT_EBASE + 21\n#define\tSMT_E0121_MSG\t\"invalid event in dispatcher\"\n#define\tSMT_E0122\tSMT_EBASE + 22\n#define\tSMT_E0122_MSG\t\"RMT : invalid state\"\n#define\tSMT_E0123\tSMT_EBASE + 23\n#define\tSMT_E0123_MSG\t\"SBA: state machine has invalid state\"\n#define\tSMT_E0124\tSMT_EBASE + 24\n#define\tSMT_E0124_MSG\t\"sba_free_session() called with NULL pointer\"\n#define\tSMT_E0125\tSMT_EBASE + 25\n#define\tSMT_E0125_MSG\t\"SBA : invalid session pointer\"\n#define\tSMT_E0126\tSMT_EBASE + 26\n#define\tSMT_E0126_MSG\t\"smt_free_mbuf() called with NULL pointer\\n\"\n#define\tSMT_E0127\tSMT_EBASE + 27\n#define\tSMT_E0127_MSG\t\"sizeof evcs\"\n#define\tSMT_E0128\tSMT_EBASE + 28\n#define\tSMT_E0128_MSG\t\"evc->evc_cond_state = 0\"\n#define\tSMT_E0129\tSMT_EBASE + 29\n#define\tSMT_E0129_MSG\t\"evc->evc_multiple = 0\"\n#define\tSMT_E0130\tSMT_EBASE + 30\n#define\tSMT_E0130_MSG\twrite_mdr_warning\n#define\tSMT_E0131\tSMT_EBASE + 31\n#define\tSMT_E0131_MSG\tcam_warning\n#define SMT_E0132\tSMT_EBASE + 32\n#define SMT_E0132_MSG\t\"ST1L.FM_SPCEPDx parity/coding error\"\n#define SMT_E0133\tSMT_EBASE + 33\n#define SMT_E0133_MSG\t\"ST1L.FM_STBURx tx buffer underrun\"\n#define SMT_E0134\tSMT_EBASE + 34\n#define SMT_E0134_MSG\t\"ST1L.FM_SPCEPDx parity error\"\n#define SMT_E0135\tSMT_EBASE + 35\n#define SMT_E0135_MSG\t\"RMT: duplicate MAC address detected. Ring left!\"\n#define SMT_E0136\tSMT_EBASE + 36\n#define SMT_E0136_MSG\t\"Elasticity Buffer hang-up\"\n#define SMT_E0137\tSMT_EBASE + 37\n#define SMT_E0137_MSG\t\"SMT: queue overrun\"\n#define SMT_E0138\tSMT_EBASE + 38\n#define SMT_E0138_MSG\t\"RMT: duplicate MAC address detected. Ring NOT left!\"\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}