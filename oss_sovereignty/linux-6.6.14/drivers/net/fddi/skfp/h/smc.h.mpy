{
  "module_name": "smc.h",
  "hash_id": "11d12d7915e00490079d761ed32911d619f860ad2836e8f8433414f492b9c424",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/fddi/skfp/h/smc.h",
  "human_readable_source": " \n \n\n#ifndef\t_SCMECM_\n#define _SCMECM_\n\n#if\tdefined(PCI) && !defined(OSDEF)\n \n#define\tOSDEF\n#endif\n\n#ifdef\tPCI\n#ifndef\tSUPERNET_3\n#define\tSUPERNET_3\n#endif\n#ifndef\tTAG_MODE\n#define\tTAG_MODE\n#endif\n#endif\n\n \n#ifdef\tOSDEF\n#include \"osdef1st.h\"\n#endif\t \n#ifdef\tOEM_CONCEPT\n#include \"oemdef.h\"\n#endif\t \n#include \"smt.h\"\n#include \"cmtdef.h\"\n#include \"fddimib.h\"\n#include \"targethw.h\"\t\t \n#include \"targetos.h\"\t\t \n#ifdef\tESS\n#include \"sba.h\"\n#endif\n\n \nstruct event_queue {\n\tu_short\tclass ;\t\t\t \n\tu_short\tevent ;\t\t\t \n} ;\n\n \n#ifdef\tCONCENTRATOR\n#define MAX_EVENT\t128\n#else\t \n#define MAX_EVENT\t64\n#endif\t \n\nstruct s_queue {\n\n\tstruct event_queue ev_queue[MAX_EVENT];\n\tstruct event_queue *ev_put ;\n\tstruct event_queue *ev_get ;\n} ;\n\n \nstruct s_ecm {\n\tu_char path_test ;\t\t \n\tu_char sb_flag ;\t\t \n\tu_char DisconnectFlag ;\t\t \n\tu_char ecm_line_state ;\t\t \n\tu_long trace_prop ;\t\t \n\t \n\tchar\tec_pad[2] ;\n\tstruct smt_timer ecm_timer ;\t \n} ;\n\n\n \nstruct s_rmt {\n\tu_char dup_addr_test ;\t\t \n\tu_char da_flag ;\t\t \n\tu_char loop_avail ;\t\t \n\tu_char sm_ma_avail ;\t\t \n\tu_char no_flag ;\t\t \n\tu_char bn_flag ;\t\t \n\tu_char jm_flag ;\t\t \n\tu_char rm_join ;\t\t \n\tu_char rm_loop ;\t\t \n\n\tlong fast_rm_join ;\t\t \n\t \n\tstruct smt_timer rmt_timer0 ;\t \n\tstruct smt_timer rmt_timer1 ;\t \n\tstruct smt_timer rmt_timer2 ;\t \n\tu_char timer0_exp ;\t\t \n\tu_char timer1_exp ;\t\t \n\tu_char timer2_exp ;\t\t \n\n\tu_char rm_pad1;\n} ;\n\n \nstruct s_cfm {\n\tu_char cf_state;\t\t \n\tu_char cf_pad[3] ;\n} ;\n\n \n#ifdef\tCONCENTRATOR\nstruct s_cem {\n\tint\tce_state ;\t \n\tint\tce_port ;\t \n\tint\tce_type ;\t \n} ;\n\n \nstruct s_c_ring {\n\tstruct s_c_ring\t*c_next ;\n\tchar\t\tc_entity ;\n} ;\n\nstruct mib_path_config {\n\tu_long\tfddimibPATHConfigSMTIndex;\n\tu_long\tfddimibPATHConfigPATHIndex;\n\tu_long\tfddimibPATHConfigTokenOrder;\n\tu_long\tfddimibPATHConfigResourceType;\n#define SNMP_RES_TYPE_MAC\t2\t \n#define SNMP_RES_TYPE_PORT\t4\t \n\tu_long\tfddimibPATHConfigResourceIndex;\n\tu_long\tfddimibPATHConfigCurrentPath;\n#define SNMP_PATH_ISOLATED\t1\t \n#define SNMP_PATH_LOCAL\t\t2\t \n#define SNMP_PATH_SECONDARY\t3\t \n#define SNMP_PATH_PRIMARY\t4\t \n#define SNMP_PATH_CONCATENATED\t5\t \n#define SNMP_PATH_THRU\t\t6\t \n};\n\n\n#endif\n\n \n#define PCM_DISABLED\t0\n#define PCM_CONNECTING\t1\n#define PCM_STANDBY\t2\n#define PCM_ACTIVE\t3\n\nstruct s_pcm {\n\tu_char\tpcm_pad[3] ;\n} ;\n\n \nstruct s_phy {\n\t \n\tstruct fddi_mib_p\t*mib ;\n\n\tu_char np ;\t\t \n\tu_char cf_join ;\n\tu_char cf_loop ;\n\tu_char wc_flag ;\t \n\tu_char pc_mode ;\t \n\tu_char pc_lem_fail ;\t \n\tu_char lc_test ;\n\tu_char scrub ;\t\t \n\tchar phy_name ;\n\tu_char pmd_type[2] ;\t \n#define PMD_SK_CONN\t0\t \n#define PMD_SK_PMD\t1\t \n\tu_char pmd_scramble ;\t \n\n\t \n\tu_char curr_ls ;\t \n\tu_char ls_flag ;\n\tu_char rc_flag ;\n\tu_char tc_flag ;\n\tu_char td_flag ;\n\tu_char bitn ;\n\tu_char tr_flag ;\t \n\tu_char twisted ;\t \n\tu_char t_val[NUMBITS] ;\t \n\tu_char r_val[NUMBITS] ;\t \n\tu_long t_next[NUMBITS] ;\n\tstruct smt_timer pcm_timer0 ;\n\tstruct smt_timer pcm_timer1 ;\n\tstruct smt_timer pcm_timer2 ;\n\tu_char timer0_exp ;\n\tu_char timer1_exp ;\n\tu_char timer2_exp ;\n\tu_char pcm_pad1[1] ;\n\tint\tcem_pst ;\t \n\tstruct lem_counter lem ;\n#ifdef\tAMDPLC\n\tstruct s_plc\tplc ;\n#endif\n} ;\n\n \nstruct s_timer {\n\tstruct smt_timer\t*st_queue ;\n\tstruct smt_timer\tst_fast ;\n} ;\n\n \n#define SMT_EVENT_BASE\t\t\t1\n#define SMT_EVENT_MAC_PATH_CHANGE\t(SMT_EVENT_BASE+0)\n#define SMT_EVENT_MAC_NEIGHBOR_CHANGE\t(SMT_EVENT_BASE+1)\n#define SMT_EVENT_PORT_PATH_CHANGE\t(SMT_EVENT_BASE+2)\n#define SMT_EVENT_PORT_CONNECTION\t(SMT_EVENT_BASE+3)\n\n#define SMT_IS_CONDITION(x)\t\t\t((x)>=SMT_COND_BASE)\n\n#define SMT_COND_BASE\t\t(SMT_EVENT_PORT_CONNECTION+1)\n#define SMT_COND_SMT_PEER_WRAP\t\t(SMT_COND_BASE+0)\n#define SMT_COND_SMT_HOLD\t\t(SMT_COND_BASE+1)\n#define SMT_COND_MAC_FRAME_ERROR\t(SMT_COND_BASE+2)\n#define SMT_COND_MAC_DUP_ADDR\t\t(SMT_COND_BASE+3)\n#define SMT_COND_MAC_NOT_COPIED\t\t(SMT_COND_BASE+4)\n#define SMT_COND_PORT_EB_ERROR\t\t(SMT_COND_BASE+5)\n#define SMT_COND_PORT_LER\t\t(SMT_COND_BASE+6)\n\n#define SR0_WAIT\t0\n#define SR1_HOLDOFF\t1\n#define SR2_DISABLED\t2\n\nstruct s_srf {\n\tu_long\tSRThreshold ;\t\t\t \n\tu_char\tRT_Flag ;\t\t\t \n\tu_char\tsr_state ;\t\t\t \n\tu_char\tany_report ;\t\t\t \n\tu_long\tTSR ;\t\t\t\t \n\tu_short\tring_status ;\t\t\t \n} ;\n\n \n#define RS_RES15\t(1<<15)\t\t\t \n#define RS_HARDERROR\t(1<<14)\t\t\t \n#define RS_SOFTERROR\t(1<<13)\t\t\t \n#define RS_BEACON\t(1<<12)\t\t\t \n#define RS_PATHTEST\t(1<<11)\t\t\t \n#define RS_SELFTEST\t(1<<10)\t\t\t \n#define RS_RES9\t\t(1<< 9)\t\t\t \n#define RS_DISCONNECT\t(1<< 8)\t\t\t \n#define RS_RES7\t\t(1<< 7)\t\t\t \n#define RS_DUPADDR\t(1<< 6)\t\t\t \n#define RS_NORINGOP\t(1<< 5)\t\t\t \n#define RS_VERSION\t(1<< 4)\t\t\t \n#define RS_STUCKBYPASSS\t(1<< 3)\t\t\t \n#define RS_EVENT\t(1<< 2)\t\t\t \n#define RS_RINGOPCHANGE\t(1<< 1)\t\t\t \n#define RS_RES0\t\t(1<< 0)\t\t\t \n\n#define RS_SET(smc,bit) \\\n\tring_status_indication(smc,smc->srf.ring_status |= bit)\n#define RS_CLEAR(smc,bit)\t\\\n\tring_status_indication(smc,smc->srf.ring_status &= ~bit)\n\n#define RS_CLEAR_EVENT\t(0xffff & ~(RS_NORINGOP))\n\n \n \n#ifndef AIX_EVENT\n#define AIX_EVENT(smc,opt0,opt1,opt2,opt3)\t \n#endif\n\nstruct s_srf_evc {\n\tu_char\tevc_code ;\t\t\t \n\tu_char\tevc_index ;\t\t\t \n\tu_char\tevc_rep_required ;\t\t \n\tu_short\tevc_para ;\t\t\t \n\tu_char\t*evc_cond_state ;\t\t \n\tu_char\t*evc_multiple ;\t\t\t \n} ;\n\n \n#define SMT_MAX_TEST\t\t5\n#define SMT_TID_NIF\t\t0\t\t \n#define SMT_TID_NIF_TEST\t1\t\t \n#define SMT_TID_ECF_UNA\t\t2\t\t \n#define SMT_TID_ECF_DNA\t\t3\t\t \n#define SMT_TID_ECF\t\t4\t\t \n\nstruct smt_values {\n\tu_long\t\tsmt_tvu ;\t\t \n\tu_long\t\tsmt_tvd ;\t\t \n\tu_long\t\tsmt_tid ;\t\t \n\tu_long\t\tpend[SMT_MAX_TEST] ;\t \n\tu_long\t\tuniq_time ;\t\t \n\tu_short\t\tuniq_ticks  ;\t\t \n\tu_short\t\tplease_reconnect ;\t \n\tu_long\t\tsmt_last_lem ;\n\tu_long\t\tsmt_last_notify ;\n\tstruct smt_timer\tsmt_timer ;\t \n\tu_long\t\tlast_tok_time[NUMMACS];\t \n} ;\n\n \n#define SMT_DAS\t0\t\t\t \n#define SMT_SAS\t1\t\t\t \n#define SMT_NAC\t2\t\t\t \n\nstruct smt_config {\n\tu_char\tattach_s ;\t\t \n\tu_char\tsas ;\t\t\t \n\tu_char\tbuild_ring_map ;\t \n\tu_char\tnumphys ;\t\t \n\tu_char\tsc_pad[1] ;\n\n\tu_long\tpcm_tb_min ;\t\t \n\tu_long\tpcm_tb_max ;\t\t \n\tu_long\tpcm_c_min ;\t\t \n\tu_long\tpcm_t_out ;\t\t \n\tu_long\tpcm_tl_min ;\t\t \n\tu_long\tpcm_lc_short ;\t\t \n\tu_long\tpcm_lc_medium ;\t\t \n\tu_long\tpcm_lc_long ;\t\t \n\tu_long\tpcm_lc_extended ;\t \n\tu_long\tpcm_t_next_9 ;\t\t \n\tu_long\tpcm_ns_max ;\t\t \n\n\tu_long\tecm_i_max ;\t\t \n\tu_long\tecm_in_max ;\t\t \n\tu_long\tecm_td_min ;\t\t \n\tu_long\tecm_test_done ;\t\t \n\tu_long\tecm_check_poll ;\t \n\n\tu_long\trmt_t_non_op ;\t\t \n\tu_long\trmt_t_stuck ;\t\t \n\tu_long\trmt_t_direct ;\t\t \n\tu_long\trmt_t_jam ;\t\t \n\tu_long\trmt_t_announce ;\t \n\tu_long\trmt_t_poll ;\t\t \n\tu_long  rmt_dup_mac_behavior ;   \n\tu_long\tmac_d_max ;\t\t \n\n\tu_long lct_short ;\t\t \n\tu_long lct_medium ;\t\t \n\tu_long lct_long ;\t\t \n\tu_long lct_extended ;\t\t \n} ;\n\n#ifdef\tDEBUG\n \nstruct\tsmt_debug {\n\tint\td_smtf ;\n\tint\td_smt ;\n\tint\td_ecm ;\n\tint\td_rmt ;\n\tint\td_cfm ;\n\tint\td_pcm ;\n\tint\td_plc ;\n#ifdef\tESS\n\tint\td_ess ;\n#endif\n#ifdef\tSBA\n\tint\td_sba ;\n#endif\n\tstruct\tos_debug\td_os;\t \n} ;\n\n#ifndef\tDEBUG_BRD\n \nextern\tstruct\tsmt_debug\tdebug;\t \n#endif\t \n\n#endif\t \n\n \nstruct s_smc {\n\tstruct s_smt_os\tos ;\t\t \n\tstruct s_smt_hw\thw ;\t\t \n\n \n\tstruct smt_config s ;\t\t \n\tstruct smt_values sm ;\t\t \n\tstruct s_ecm\te ;\t\t \n\tstruct s_rmt\tr ;\t\t \n\tstruct s_cfm\tcf ;\t\t \n#ifdef\tCONCENTRATOR\n\tstruct s_cem\tce[NUMPHYS] ;\t \n\tstruct s_c_ring\tcr[NUMPHYS+NUMMACS] ;\n#endif\n\tstruct s_pcm\tp ;\t\t \n\tstruct s_phy\ty[NUMPHYS] ;\t \n\tstruct s_queue\tq ;\t\t \n\tstruct s_timer\tt ;\t\t \n\tstruct s_srf srf ;\t\t \n\tstruct s_srf_evc evcs[6+NUMPHYS*4] ;\n\tstruct fddi_mib\tmib ;\t\t \n#ifdef\tSBA\n\tstruct s_sba\tsba ;\t\t \n#endif\n#ifdef\tESS\n\tstruct s_ess\tess ;\t\t \n#endif\n#if\tdefined(DEBUG) && defined(DEBUG_BRD)\n\t \n\tstruct smt_debug\tdebug;\t \n#endif\t \n} ;\n\nextern const struct fddi_addr fddi_broadcast;\n\nvoid all_selection_criteria(struct s_smc *smc);\nvoid card_stop(struct s_smc *smc);\nvoid init_board(struct s_smc *smc, u_char *mac_addr);\nint init_fplus(struct s_smc *smc);\nvoid init_plc(struct s_smc *smc);\nint init_smt(struct s_smc *smc, const u_char *mac_addr);\nvoid mac1_irq(struct s_smc *smc, u_short stu, u_short stl);\nvoid mac2_irq(struct s_smc *smc, u_short code_s2u, u_short code_s2l);\nvoid mac3_irq(struct s_smc *smc, u_short code_s3u, u_short code_s3l);\nint pcm_status_twisted(struct s_smc *smc);\nvoid plc1_irq(struct s_smc *smc);\nvoid plc2_irq(struct s_smc *smc);\nvoid read_address(struct s_smc *smc, u_char *mac_addr);\nvoid timer_irq(struct s_smc *smc);\n\n#endif\t \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}