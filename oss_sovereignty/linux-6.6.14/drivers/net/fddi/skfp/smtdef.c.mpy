{
  "module_name": "smtdef.c",
  "hash_id": "972b913de8e832ec618d060c0e2e0d1f5efbd3b61cf1a34f5ecd9da36ffc4b75",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/fddi/skfp/smtdef.c",
  "human_readable_source": "\n \n\n \n\n#include \"h/types.h\"\n#include \"h/fddi.h\"\n#include \"h/smc.h\"\n\n#ifndef OEM_USER_DATA\n#define OEM_USER_DATA\t\"SK-NET FDDI V2.0 Userdata\"\n#endif\n\n \n#define TTMS(x)\t((u_long)(x)*1000L)\n#define TTS(x)\t((u_long)(x)*1000000L)\n#define TTUS(x)\t((u_long)(x))\n\n#define DEFAULT_TB_MIN\t\tTTMS(5)\n#define DEFAULT_TB_MAX\t\tTTMS(50)\n#define DEFAULT_C_MIN\t\tTTUS(1600)\n#define DEFAULT_T_OUT\t\tTTMS(100+5)\n#define DEFAULT_TL_MIN\t\tTTUS(30)\n#define DEFAULT_LC_SHORT\tTTMS(50+5)\n#define DEFAULT_LC_MEDIUM\tTTMS(500+20)\n#define DEFAULT_LC_LONG\t\tTTS(5)+TTMS(50)\n#define DEFAULT_LC_EXTENDED\tTTS(50)+TTMS(50)\n#define DEFAULT_T_NEXT_9\tTTMS(200+10)\n#define DEFAULT_NS_MAX\t\tTTUS(1310)\n#define DEFAULT_I_MAX\t\tTTMS(25)\n#define DEFAULT_IN_MAX\t\tTTMS(40)\n#define DEFAULT_TD_MIN\t\tTTMS(5)\n#define DEFAULT_T_NON_OP\tTTS(1)\n#define DEFAULT_T_STUCK\t\tTTS(8)\n#define DEFAULT_T_DIRECT\tTTMS(370)\n#define DEFAULT_T_JAM\t\tTTMS(370)\n#define DEFAULT_T_ANNOUNCE\tTTMS(2500)\n#define DEFAULT_D_MAX\t\tTTUS(1617)\n#define DEFAULT_LEM_ALARM\t(8)\n#define DEFAULT_LEM_CUTOFF\t(7)\n#define DEFAULT_TEST_DONE\tTTS(1)\n#define DEFAULT_CHECK_POLL\tTTS(1)\n#define DEFAULT_POLL\t\tTTMS(50)\n\n \n#define DEFAULT_LCT_SHORT\t1\n#define DEFAULT_LCT_MEDIUM\t3\n#define DEFAULT_LCT_LONG\t5\n#define DEFAULT_LCT_EXTEND\t50\n\n \nvoid smt_reset_defaults(struct s_smc *smc, int level);\nstatic void smt_init_mib(struct s_smc *smc, int level);\nstatic int set_min_max(int maxflag, u_long mib, u_long limit, u_long *oper);\n\n#define MS2BCLK(x)\t((x)*12500L)\n#define US2BCLK(x)\t((x)*1250L)\n\nvoid smt_reset_defaults(struct s_smc *smc, int level)\n{\n\tstruct smt_config\t*smt ;\n\tint\t\t\ti ;\n\tu_long\t\t\tsmt_boot_time;\n\n\n\tsmt_init_mib(smc,level) ;\n\n\tsmc->os.smc_version = SMC_VERSION ;\n\tsmt_boot_time = smt_get_time();\n\tfor( i = 0; i < NUMMACS; i++ )\n\t\tsmc->sm.last_tok_time[i] = smt_boot_time ;\n\tsmt = &smc->s ;\n\tsmt->attach_s = 0 ;\n\tsmt->build_ring_map = 1 ;\n\tsmt->sas = SMT_DAS ;\n\tsmt->numphys = NUMPHYS ;\n\tsmt->pcm_tb_min = DEFAULT_TB_MIN ;\n\tsmt->pcm_tb_max = DEFAULT_TB_MAX ;\n\tsmt->pcm_c_min = DEFAULT_C_MIN ;\n\tsmt->pcm_t_out = DEFAULT_T_OUT ;\n\tsmt->pcm_tl_min = DEFAULT_TL_MIN ;\n\tsmt->pcm_lc_short = DEFAULT_LC_SHORT ;\n\tsmt->pcm_lc_medium = DEFAULT_LC_MEDIUM ;\n\tsmt->pcm_lc_long = DEFAULT_LC_LONG ;\n\tsmt->pcm_lc_extended = DEFAULT_LC_EXTENDED ;\n\tsmt->pcm_t_next_9 = DEFAULT_T_NEXT_9 ;\n\tsmt->pcm_ns_max = DEFAULT_NS_MAX ;\n\tsmt->ecm_i_max = DEFAULT_I_MAX ;\n\tsmt->ecm_in_max = DEFAULT_IN_MAX ;\n\tsmt->ecm_td_min = DEFAULT_TD_MIN ;\n\tsmt->ecm_test_done = DEFAULT_TEST_DONE ;\n\tsmt->ecm_check_poll = DEFAULT_CHECK_POLL ;\n\tsmt->rmt_t_non_op = DEFAULT_T_NON_OP ;\n\tsmt->rmt_t_stuck = DEFAULT_T_STUCK ;\n\tsmt->rmt_t_direct = DEFAULT_T_DIRECT ;\n\tsmt->rmt_t_jam = DEFAULT_T_JAM ;\n\tsmt->rmt_t_announce = DEFAULT_T_ANNOUNCE ;\n\tsmt->rmt_t_poll = DEFAULT_POLL ;\n        smt->rmt_dup_mac_behavior = FALSE ;   \n\tsmt->mac_d_max = DEFAULT_D_MAX ;\n\n\tsmt->lct_short = DEFAULT_LCT_SHORT ;\n\tsmt->lct_medium = DEFAULT_LCT_MEDIUM ;\n\tsmt->lct_long = DEFAULT_LCT_LONG ;\n\tsmt->lct_extended = DEFAULT_LCT_EXTEND ;\n\n#ifndef\tSLIM_SMT\n#ifdef\tESS\n\tif (level == 0) {\n\t\tsmc->ess.sync_bw_available = FALSE ;\n\t\tsmc->mib.fddiESSPayload = 0 ;\n\t\tsmc->mib.fddiESSOverhead = 0 ;\n\t\tsmc->mib.fddiESSMaxTNeg = (u_long)(- MS2BCLK(25)) ;\n\t\tsmc->mib.fddiESSMinSegmentSize = 1 ;\n\t\tsmc->mib.fddiESSCategory = SB_STATIC ;\n\t\tsmc->mib.fddiESSSynchTxMode = FALSE ;\n\t\tsmc->ess.raf_act_timer_poll = FALSE ;\n\t\tsmc->ess.timer_count = 7 ; \t \n\t}\n\tsmc->ess.local_sba_active = FALSE ;\n\tsmc->ess.sba_reply_pend = NULL ;\n#endif\n#ifdef\tSBA\n\tsmt_init_sba(smc,level) ;\n#endif\n#endif\t \n#ifdef\tTAG_MODE\n\tif (level == 0) {\n\t\tsmc->hw.pci_fix_value = 0 ;\n\t}\n#endif\n}\n\n \nstatic const char man_data[32] =\n \n\t\"xxxSK-NET FDDI SMT 7.3 - V2.8.8\" ;\n\nstatic void smt_init_mib(struct s_smc *smc, int level)\n{\n\tstruct fddi_mib\t\t*mib ;\n\tstruct fddi_mib_p\t*pm ;\n\tint\t\t\tport ;\n\tint\t\t\tpath ;\n\n\tmib = &smc->mib ;\n\tif (level == 0) {\n\t\t \n\t\tmemset(((char *)smc)+\n\t\t\tsizeof(struct s_smt_os)+sizeof(struct s_smt_hw), 0,\n\t\t\tsizeof(struct s_smc) -\n\t\t\tsizeof(struct s_smt_os) - sizeof(struct s_smt_hw)) ;\n\t}\n\telse {\n\t\tmib->fddiSMTRemoteDisconnectFlag = 0 ;\n\t\tmib->fddiSMTPeerWrapFlag = 0 ;\n\t}\n\n\tmib->fddiSMTOpVersionId = 2 ;\n\tmib->fddiSMTHiVersionId = 2 ;\n\tmib->fddiSMTLoVersionId = 2 ;\n\tmemcpy((char *) mib->fddiSMTManufacturerData,man_data,32) ;\n\tif (level == 0) {\n\t\tstrcpy(mib->fddiSMTUserData,OEM_USER_DATA) ;\n\t}\n\tmib->fddiSMTMIBVersionId = 1 ;\n\tmib->fddiSMTMac_Ct = NUMMACS ;\n\tmib->fddiSMTConnectionPolicy = POLICY_MM | POLICY_AA | POLICY_BB ;\n\n\t \n\tmib->fddiSMTAvailablePaths = MIB_PATH_P | MIB_PATH_S ;\n\n\tmib->fddiSMTConfigCapabilities = 0 ;\t \n\tmib->fddiSMTTT_Notify = 10 ;\n\tmib->fddiSMTStatRptPolicy = TRUE ;\n\tmib->fddiSMTTrace_MaxExpiration = SEC2MIB(7) ;\n\tmib->fddiSMTMACIndexes = INDEX_MAC ;\n\tmib->fddiSMTStationStatus = MIB_SMT_STASTA_SEPA ;\t \n\n\tmib->m[MAC0].fddiMACIndex = INDEX_MAC ;\n\tmib->m[MAC0].fddiMACFrameStatusFunctions = FSC_TYPE0 ;\n\tmib->m[MAC0].fddiMACRequestedPaths =\n\t\tMIB_P_PATH_LOCAL |\n\t\tMIB_P_PATH_SEC_ALTER |\n\t\tMIB_P_PATH_PRIM_ALTER ;\n\tmib->m[MAC0].fddiMACAvailablePaths = MIB_PATH_P ;\n\tmib->m[MAC0].fddiMACCurrentPath = MIB_PATH_PRIMARY ;\n\tmib->m[MAC0].fddiMACT_MaxCapabilitiy = (u_long)(- MS2BCLK(165)) ;\n\tmib->m[MAC0].fddiMACTVXCapabilitiy = (u_long)(- US2BCLK(52)) ;\n\tif (level == 0) {\n\t\tmib->m[MAC0].fddiMACTvxValue = (u_long)(- US2BCLK(27)) ;\n\t\tmib->m[MAC0].fddiMACTvxValueMIB = (u_long)(- US2BCLK(27)) ;\n\t\tmib->m[MAC0].fddiMACT_Req = (u_long)(- MS2BCLK(165)) ;\n\t\tmib->m[MAC0].fddiMACT_ReqMIB = (u_long)(- MS2BCLK(165)) ;\n\t\tmib->m[MAC0].fddiMACT_Max = (u_long)(- MS2BCLK(165)) ;\n\t\tmib->m[MAC0].fddiMACT_MaxMIB = (u_long)(- MS2BCLK(165)) ;\n\t\tmib->m[MAC0].fddiMACT_Min = (u_long)(- MS2BCLK(4)) ;\n\t}\n\tmib->m[MAC0].fddiMACHardwarePresent = TRUE ;\n\tmib->m[MAC0].fddiMACMA_UnitdataEnable = TRUE ;\n\tmib->m[MAC0].fddiMACFrameErrorThreshold = 1 ;\n\tmib->m[MAC0].fddiMACNotCopiedThreshold = 1 ;\n\t \n\tfor (path = 0 ; path < NUMPATHS ; path++) {\n\t\tmib->a[path].fddiPATHIndex = INDEX_PATH + path ;\n\t\tif (level == 0) {\n\t\t\tmib->a[path].fddiPATHTVXLowerBound =\n\t\t\t\t(u_long)(- US2BCLK(27)) ;\n\t\t\tmib->a[path].fddiPATHT_MaxLowerBound =\n\t\t\t\t(u_long)(- MS2BCLK(165)) ;\n\t\t\tmib->a[path].fddiPATHMaxT_Req =\n\t\t\t\t(u_long)(- MS2BCLK(165)) ;\n\t\t}\n\t}\n\n\n\t \n\tpm = mib->p ;\n\tfor (port = 0 ; port <  NUMPHYS ; port++) {\n\t\t \n\t\t \n\t\t \n\t\tsmc->y[port].mib = NULL;\n\t\tmib->fddiSMTPORTIndexes[port] = port+INDEX_PORT ;\n\n\t\tpm->fddiPORTIndex = port+INDEX_PORT ;\n\t\tpm->fddiPORTHardwarePresent = TRUE ;\n\t\tif (level == 0) {\n\t\t\tpm->fddiPORTLer_Alarm = DEFAULT_LEM_ALARM ;\n\t\t\tpm->fddiPORTLer_Cutoff = DEFAULT_LEM_CUTOFF ;\n\t\t}\n\t\t \n\t\tpm->fddiPORTRequestedPaths[1] = 0 ;\n\t\tpm->fddiPORTRequestedPaths[2] = 0 ;\n\t\tpm->fddiPORTRequestedPaths[3] = 0 ;\n\t\tpm->fddiPORTAvailablePaths = MIB_PATH_P ;\n\t\tpm->fddiPORTPMDClass = MIB_PMDCLASS_MULTI ;\n\t\tpm++ ;\n\t}\n\n\t(void) smt_set_mac_opvalues(smc) ;\n}\n\nint smt_set_mac_opvalues(struct s_smc *smc)\n{\n\tint\tst ;\n\tint\tst2 ;\n\n\tst = set_min_max(1,smc->mib.m[MAC0].fddiMACTvxValueMIB,\n\t\tsmc->mib.a[PATH0].fddiPATHTVXLowerBound,\n\t\t&smc->mib.m[MAC0].fddiMACTvxValue) ;\n\tst |= set_min_max(0,smc->mib.m[MAC0].fddiMACT_MaxMIB,\n\t\tsmc->mib.a[PATH0].fddiPATHT_MaxLowerBound,\n\t\t&smc->mib.m[MAC0].fddiMACT_Max) ;\n\tst |= (st2 = set_min_max(0,smc->mib.m[MAC0].fddiMACT_ReqMIB,\n\t\tsmc->mib.a[PATH0].fddiPATHMaxT_Req,\n\t\t&smc->mib.m[MAC0].fddiMACT_Req)) ;\n\tif (st2) {\n\t\t \n\t\tAIX_EVENT(smc, (u_long) FDDI_RING_STATUS, (u_long)\n\t\t\tFDDI_SMT_EVENT, (u_long) FDDI_REMOTE_T_REQ,\n\t\t\tsmt_get_event_word(smc));\n\t}\n\treturn st;\n}\n\nvoid smt_fixup_mib(struct s_smc *smc)\n{\n#ifdef\tCONCENTRATOR\n\tswitch (smc->s.sas) {\n\tcase SMT_SAS :\n\t\tsmc->mib.fddiSMTNonMaster_Ct = 1 ;\n\t\tbreak ;\n\tcase SMT_DAS :\n\t\tsmc->mib.fddiSMTNonMaster_Ct = 2 ;\n\t\tbreak ;\n\tcase SMT_NAC :\n\t\tsmc->mib.fddiSMTNonMaster_Ct = 0 ;\n\t\tbreak ;\n\t}\n\tsmc->mib.fddiSMTMaster_Ct = NUMPHYS - smc->mib.fddiSMTNonMaster_Ct ;\n#else\n\tswitch (smc->s.sas) {\n\tcase SMT_SAS :\n\t\tsmc->mib.fddiSMTNonMaster_Ct = 1 ;\n\t\tbreak ;\n\tcase SMT_DAS :\n\t\tsmc->mib.fddiSMTNonMaster_Ct = 2 ;\n\t\tbreak ;\n\t}\n\tsmc->mib.fddiSMTMaster_Ct = 0 ;\n#endif\n}\n\n \nstatic int set_min_max(int maxflag, u_long mib, u_long limit, u_long *oper)\n{\n\tu_long\told ;\n\told = *oper ;\n\tif ((limit > mib) ^ maxflag)\n\t\t*oper = limit ;\n\telse\n\t\t*oper = mib ;\n\treturn old != *oper;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}