{
  "module_name": "ipvtap.c",
  "hash_id": "a3c2780ffbe83f658787fee1445a2db6735db55051dcdaef4d77327b84b324b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ipvlan/ipvtap.c",
  "human_readable_source": "\n#include <linux/etherdevice.h>\n#include \"ipvlan.h\"\n#include <linux/if_vlan.h>\n#include <linux/if_tap.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/compat.h>\n#include <linux/if_tun.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/cache.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/cdev.h>\n#include <linux/idr.h>\n#include <linux/fs.h>\n#include <linux/uio.h>\n\n#include <net/net_namespace.h>\n#include <net/rtnetlink.h>\n#include <net/sock.h>\n#include <linux/virtio_net.h>\n\n#define TUN_OFFLOADS (NETIF_F_HW_CSUM | NETIF_F_TSO_ECN | NETIF_F_TSO | \\\n\t\t      NETIF_F_TSO6)\n\nstatic dev_t ipvtap_major;\nstatic struct cdev ipvtap_cdev;\n\nstatic const void *ipvtap_net_namespace(const struct device *d)\n{\n\tconst struct net_device *dev = to_net_dev(d->parent);\n\treturn dev_net(dev);\n}\n\nstatic struct class ipvtap_class = {\n\t .name = \"ipvtap\",\n\t .ns_type = &net_ns_type_operations,\n\t .namespace = ipvtap_net_namespace,\n};\n\nstruct ipvtap_dev {\n\tstruct ipvl_dev vlan;\n\tstruct tap_dev\t  tap;\n};\n\nstatic void ipvtap_count_tx_dropped(struct tap_dev *tap)\n{\n\tstruct ipvtap_dev *vlantap = container_of(tap, struct ipvtap_dev, tap);\n\tstruct ipvl_dev *vlan = &vlantap->vlan;\n\n\tthis_cpu_inc(vlan->pcpu_stats->tx_drps);\n}\n\nstatic void ipvtap_count_rx_dropped(struct tap_dev *tap)\n{\n\tstruct ipvtap_dev *vlantap = container_of(tap, struct ipvtap_dev, tap);\n\tstruct ipvl_dev *vlan = &vlantap->vlan;\n\n\tipvlan_count_rx(vlan, 0, 0, 0);\n}\n\nstatic void ipvtap_update_features(struct tap_dev *tap,\n\t\t\t\t   netdev_features_t features)\n{\n\tstruct ipvtap_dev *vlantap = container_of(tap, struct ipvtap_dev, tap);\n\tstruct ipvl_dev *vlan = &vlantap->vlan;\n\n\tvlan->sfeatures = features;\n\tnetdev_update_features(vlan->dev);\n}\n\nstatic int ipvtap_newlink(struct net *src_net, struct net_device *dev,\n\t\t\t  struct nlattr *tb[], struct nlattr *data[],\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct ipvtap_dev *vlantap = netdev_priv(dev);\n\tint err;\n\n\tINIT_LIST_HEAD(&vlantap->tap.queue_list);\n\n\t \n\tvlantap->tap.tap_features = TUN_OFFLOADS;\n\tvlantap->tap.count_tx_dropped = ipvtap_count_tx_dropped;\n\tvlantap->tap.update_features =\tipvtap_update_features;\n\tvlantap->tap.count_rx_dropped = ipvtap_count_rx_dropped;\n\n\terr = netdev_rx_handler_register(dev, tap_handle_frame, &vlantap->tap);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr =  ipvlan_link_new(src_net, dev, tb, data, extack);\n\tif (err) {\n\t\tnetdev_rx_handler_unregister(dev);\n\t\treturn err;\n\t}\n\n\tvlantap->tap.dev = vlantap->vlan.dev;\n\n\treturn err;\n}\n\nstatic void ipvtap_dellink(struct net_device *dev,\n\t\t\t   struct list_head *head)\n{\n\tstruct ipvtap_dev *vlan = netdev_priv(dev);\n\n\tnetdev_rx_handler_unregister(dev);\n\ttap_del_queues(&vlan->tap);\n\tipvlan_link_delete(dev, head);\n}\n\nstatic void ipvtap_setup(struct net_device *dev)\n{\n\tipvlan_link_setup(dev);\n\tdev->tx_queue_len = TUN_READQ_SIZE;\n\tdev->priv_flags &= ~IFF_NO_QUEUE;\n}\n\nstatic struct rtnl_link_ops ipvtap_link_ops __read_mostly = {\n\t.kind\t\t= \"ipvtap\",\n\t.setup\t\t= ipvtap_setup,\n\t.newlink\t= ipvtap_newlink,\n\t.dellink\t= ipvtap_dellink,\n\t.priv_size\t= sizeof(struct ipvtap_dev),\n};\n\nstatic int ipvtap_device_event(struct notifier_block *unused,\n\t\t\t       unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct ipvtap_dev *vlantap;\n\tstruct device *classdev;\n\tdev_t devt;\n\tint err;\n\tchar tap_name[IFNAMSIZ];\n\n\tif (dev->rtnl_link_ops != &ipvtap_link_ops)\n\t\treturn NOTIFY_DONE;\n\n\tsnprintf(tap_name, IFNAMSIZ, \"tap%d\", dev->ifindex);\n\tvlantap = netdev_priv(dev);\n\n\tswitch (event) {\n\tcase NETDEV_REGISTER:\n\t\t \n\t\terr = tap_get_minor(ipvtap_major, &vlantap->tap);\n\t\tif (err)\n\t\t\treturn notifier_from_errno(err);\n\n\t\tdevt = MKDEV(MAJOR(ipvtap_major), vlantap->tap.minor);\n\t\tclassdev = device_create(&ipvtap_class, &dev->dev, devt,\n\t\t\t\t\t dev, \"%s\", tap_name);\n\t\tif (IS_ERR(classdev)) {\n\t\t\ttap_free_minor(ipvtap_major, &vlantap->tap);\n\t\t\treturn notifier_from_errno(PTR_ERR(classdev));\n\t\t}\n\t\terr = sysfs_create_link(&dev->dev.kobj, &classdev->kobj,\n\t\t\t\t\ttap_name);\n\t\tif (err)\n\t\t\treturn notifier_from_errno(err);\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\t\t \n\t\tif (vlantap->tap.minor == 0)\n\t\t\tbreak;\n\t\tsysfs_remove_link(&dev->dev.kobj, tap_name);\n\t\tdevt = MKDEV(MAJOR(ipvtap_major), vlantap->tap.minor);\n\t\tdevice_destroy(&ipvtap_class, devt);\n\t\ttap_free_minor(ipvtap_major, &vlantap->tap);\n\t\tbreak;\n\tcase NETDEV_CHANGE_TX_QUEUE_LEN:\n\t\tif (tap_queue_resize(&vlantap->tap))\n\t\t\treturn NOTIFY_BAD;\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block ipvtap_notifier_block __read_mostly = {\n\t.notifier_call\t= ipvtap_device_event,\n};\n\nstatic int __init ipvtap_init(void)\n{\n\tint err;\n\n\terr = tap_create_cdev(&ipvtap_cdev, &ipvtap_major, \"ipvtap\",\n\t\t\t      THIS_MODULE);\n\tif (err)\n\t\tgoto out1;\n\n\terr = class_register(&ipvtap_class);\n\tif (err)\n\t\tgoto out2;\n\n\terr = register_netdevice_notifier(&ipvtap_notifier_block);\n\tif (err)\n\t\tgoto out3;\n\n\terr = ipvlan_link_register(&ipvtap_link_ops);\n\tif (err)\n\t\tgoto out4;\n\n\treturn 0;\n\nout4:\n\tunregister_netdevice_notifier(&ipvtap_notifier_block);\nout3:\n\tclass_unregister(&ipvtap_class);\nout2:\n\ttap_destroy_cdev(ipvtap_major, &ipvtap_cdev);\nout1:\n\treturn err;\n}\nmodule_init(ipvtap_init);\n\nstatic void __exit ipvtap_exit(void)\n{\n\trtnl_link_unregister(&ipvtap_link_ops);\n\tunregister_netdevice_notifier(&ipvtap_notifier_block);\n\tclass_unregister(&ipvtap_class);\n\ttap_destroy_cdev(ipvtap_major, &ipvtap_cdev);\n}\nmodule_exit(ipvtap_exit);\nMODULE_ALIAS_RTNL_LINK(\"ipvtap\");\nMODULE_AUTHOR(\"Sainath Grandhi <sainath.grandhi@intel.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}