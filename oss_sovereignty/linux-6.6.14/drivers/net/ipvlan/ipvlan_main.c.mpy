{
  "module_name": "ipvlan_main.c",
  "hash_id": "fe46e51d7964c173a650f228eb264996a8963822fed5e9f1aff51ed35a811277",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ipvlan/ipvlan_main.c",
  "human_readable_source": "\n \n\n#include <linux/ethtool.h>\n\n#include \"ipvlan.h\"\n\nstatic int ipvlan_set_port_mode(struct ipvl_port *port, u16 nval,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct ipvl_dev *ipvlan;\n\tunsigned int flags;\n\tint err;\n\n\tASSERT_RTNL();\n\tif (port->mode != nval) {\n\t\tlist_for_each_entry(ipvlan, &port->ipvlans, pnode) {\n\t\t\tflags = ipvlan->dev->flags;\n\t\t\tif (nval == IPVLAN_MODE_L3 || nval == IPVLAN_MODE_L3S) {\n\t\t\t\terr = dev_change_flags(ipvlan->dev,\n\t\t\t\t\t\t       flags | IFF_NOARP,\n\t\t\t\t\t\t       extack);\n\t\t\t} else {\n\t\t\t\terr = dev_change_flags(ipvlan->dev,\n\t\t\t\t\t\t       flags & ~IFF_NOARP,\n\t\t\t\t\t\t       extack);\n\t\t\t}\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto fail;\n\t\t}\n\t\tif (nval == IPVLAN_MODE_L3S) {\n\t\t\t \n\t\t\terr = ipvlan_l3s_register(port);\n\t\t\tif (err)\n\t\t\t\tgoto fail;\n\t\t} else if (port->mode == IPVLAN_MODE_L3S) {\n\t\t\t \n\t\t\tipvlan_l3s_unregister(port);\n\t\t}\n\t\tport->mode = nval;\n\t}\n\treturn 0;\n\nfail:\n\t \n\tlist_for_each_entry_continue_reverse(ipvlan, &port->ipvlans, pnode) {\n\t\tflags = ipvlan->dev->flags;\n\t\tif (port->mode == IPVLAN_MODE_L3 ||\n\t\t    port->mode == IPVLAN_MODE_L3S)\n\t\t\tdev_change_flags(ipvlan->dev, flags | IFF_NOARP,\n\t\t\t\t\t NULL);\n\t\telse\n\t\t\tdev_change_flags(ipvlan->dev, flags & ~IFF_NOARP,\n\t\t\t\t\t NULL);\n\t}\n\n\treturn err;\n}\n\nstatic int ipvlan_port_create(struct net_device *dev)\n{\n\tstruct ipvl_port *port;\n\tint err, idx;\n\n\tport = kzalloc(sizeof(struct ipvl_port), GFP_KERNEL);\n\tif (!port)\n\t\treturn -ENOMEM;\n\n\twrite_pnet(&port->pnet, dev_net(dev));\n\tport->dev = dev;\n\tport->mode = IPVLAN_MODE_L3;\n\tINIT_LIST_HEAD(&port->ipvlans);\n\tfor (idx = 0; idx < IPVLAN_HASH_SIZE; idx++)\n\t\tINIT_HLIST_HEAD(&port->hlhead[idx]);\n\n\tskb_queue_head_init(&port->backlog);\n\tINIT_WORK(&port->wq, ipvlan_process_multicast);\n\tida_init(&port->ida);\n\tport->dev_id_start = 1;\n\n\terr = netdev_rx_handler_register(dev, ipvlan_handle_frame, port);\n\tif (err)\n\t\tgoto err;\n\n\tnetdev_hold(dev, &port->dev_tracker, GFP_KERNEL);\n\treturn 0;\n\nerr:\n\tkfree(port);\n\treturn err;\n}\n\nstatic void ipvlan_port_destroy(struct net_device *dev)\n{\n\tstruct ipvl_port *port = ipvlan_port_get_rtnl(dev);\n\tstruct sk_buff *skb;\n\n\tnetdev_put(dev, &port->dev_tracker);\n\tif (port->mode == IPVLAN_MODE_L3S)\n\t\tipvlan_l3s_unregister(port);\n\tnetdev_rx_handler_unregister(dev);\n\tcancel_work_sync(&port->wq);\n\twhile ((skb = __skb_dequeue(&port->backlog)) != NULL) {\n\t\tdev_put(skb->dev);\n\t\tkfree_skb(skb);\n\t}\n\tida_destroy(&port->ida);\n\tkfree(port);\n}\n\n#define IPVLAN_ALWAYS_ON_OFLOADS \\\n\t(NETIF_F_SG | NETIF_F_HW_CSUM | \\\n\t NETIF_F_GSO_ROBUST | NETIF_F_GSO_SOFTWARE | NETIF_F_GSO_ENCAP_ALL)\n\n#define IPVLAN_ALWAYS_ON \\\n\t(IPVLAN_ALWAYS_ON_OFLOADS | NETIF_F_LLTX | NETIF_F_VLAN_CHALLENGED)\n\n#define IPVLAN_FEATURES \\\n\t(NETIF_F_SG | NETIF_F_HW_CSUM | NETIF_F_HIGHDMA | NETIF_F_FRAGLIST | \\\n\t NETIF_F_GSO | NETIF_F_ALL_TSO | NETIF_F_GSO_ROBUST | \\\n\t NETIF_F_GRO | NETIF_F_RXCSUM | \\\n\t NETIF_F_HW_VLAN_CTAG_FILTER | NETIF_F_HW_VLAN_STAG_FILTER)\n\n\t \n\n#define IPVLAN_STATE_MASK \\\n\t((1<<__LINK_STATE_NOCARRIER) | (1<<__LINK_STATE_DORMANT))\n\nstatic int ipvlan_init(struct net_device *dev)\n{\n\tstruct ipvl_dev *ipvlan = netdev_priv(dev);\n\tstruct net_device *phy_dev = ipvlan->phy_dev;\n\tstruct ipvl_port *port;\n\tint err;\n\n\tdev->state = (dev->state & ~IPVLAN_STATE_MASK) |\n\t\t     (phy_dev->state & IPVLAN_STATE_MASK);\n\tdev->features = phy_dev->features & IPVLAN_FEATURES;\n\tdev->features |= IPVLAN_ALWAYS_ON;\n\tdev->vlan_features = phy_dev->vlan_features & IPVLAN_FEATURES;\n\tdev->vlan_features |= IPVLAN_ALWAYS_ON_OFLOADS;\n\tdev->hw_enc_features |= dev->features;\n\tnetif_inherit_tso_max(dev, phy_dev);\n\tdev->hard_header_len = phy_dev->hard_header_len;\n\n\tnetdev_lockdep_set_classes(dev);\n\n\tipvlan->pcpu_stats = netdev_alloc_pcpu_stats(struct ipvl_pcpu_stats);\n\tif (!ipvlan->pcpu_stats)\n\t\treturn -ENOMEM;\n\n\tif (!netif_is_ipvlan_port(phy_dev)) {\n\t\terr = ipvlan_port_create(phy_dev);\n\t\tif (err < 0) {\n\t\t\tfree_percpu(ipvlan->pcpu_stats);\n\t\t\treturn err;\n\t\t}\n\t}\n\tport = ipvlan_port_get_rtnl(phy_dev);\n\tport->count += 1;\n\treturn 0;\n}\n\nstatic void ipvlan_uninit(struct net_device *dev)\n{\n\tstruct ipvl_dev *ipvlan = netdev_priv(dev);\n\tstruct net_device *phy_dev = ipvlan->phy_dev;\n\tstruct ipvl_port *port;\n\n\tfree_percpu(ipvlan->pcpu_stats);\n\n\tport = ipvlan_port_get_rtnl(phy_dev);\n\tport->count -= 1;\n\tif (!port->count)\n\t\tipvlan_port_destroy(port->dev);\n}\n\nstatic int ipvlan_open(struct net_device *dev)\n{\n\tstruct ipvl_dev *ipvlan = netdev_priv(dev);\n\tstruct ipvl_addr *addr;\n\n\tif (ipvlan->port->mode == IPVLAN_MODE_L3 ||\n\t    ipvlan->port->mode == IPVLAN_MODE_L3S)\n\t\tdev->flags |= IFF_NOARP;\n\telse\n\t\tdev->flags &= ~IFF_NOARP;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(addr, &ipvlan->addrs, anode)\n\t\tipvlan_ht_addr_add(ipvlan, addr);\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic int ipvlan_stop(struct net_device *dev)\n{\n\tstruct ipvl_dev *ipvlan = netdev_priv(dev);\n\tstruct net_device *phy_dev = ipvlan->phy_dev;\n\tstruct ipvl_addr *addr;\n\n\tdev_uc_unsync(phy_dev, dev);\n\tdev_mc_unsync(phy_dev, dev);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(addr, &ipvlan->addrs, anode)\n\t\tipvlan_ht_addr_del(addr);\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic netdev_tx_t ipvlan_start_xmit(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev)\n{\n\tconst struct ipvl_dev *ipvlan = netdev_priv(dev);\n\tint skblen = skb->len;\n\tint ret;\n\n\tret = ipvlan_queue_xmit(skb, dev);\n\tif (likely(ret == NET_XMIT_SUCCESS || ret == NET_XMIT_CN)) {\n\t\tstruct ipvl_pcpu_stats *pcptr;\n\n\t\tpcptr = this_cpu_ptr(ipvlan->pcpu_stats);\n\n\t\tu64_stats_update_begin(&pcptr->syncp);\n\t\tu64_stats_inc(&pcptr->tx_pkts);\n\t\tu64_stats_add(&pcptr->tx_bytes, skblen);\n\t\tu64_stats_update_end(&pcptr->syncp);\n\t} else {\n\t\tthis_cpu_inc(ipvlan->pcpu_stats->tx_drps);\n\t}\n\treturn ret;\n}\n\nstatic netdev_features_t ipvlan_fix_features(struct net_device *dev,\n\t\t\t\t\t     netdev_features_t features)\n{\n\tstruct ipvl_dev *ipvlan = netdev_priv(dev);\n\n\tfeatures |= NETIF_F_ALL_FOR_ALL;\n\tfeatures &= (ipvlan->sfeatures | ~IPVLAN_FEATURES);\n\tfeatures = netdev_increment_features(ipvlan->phy_dev->features,\n\t\t\t\t\t     features, features);\n\tfeatures |= IPVLAN_ALWAYS_ON;\n\tfeatures &= (IPVLAN_FEATURES | IPVLAN_ALWAYS_ON);\n\n\treturn features;\n}\n\nstatic void ipvlan_change_rx_flags(struct net_device *dev, int change)\n{\n\tstruct ipvl_dev *ipvlan = netdev_priv(dev);\n\tstruct net_device *phy_dev = ipvlan->phy_dev;\n\n\tif (change & IFF_ALLMULTI)\n\t\tdev_set_allmulti(phy_dev, dev->flags & IFF_ALLMULTI? 1 : -1);\n}\n\nstatic void ipvlan_set_multicast_mac_filter(struct net_device *dev)\n{\n\tstruct ipvl_dev *ipvlan = netdev_priv(dev);\n\n\tif (dev->flags & (IFF_PROMISC | IFF_ALLMULTI)) {\n\t\tbitmap_fill(ipvlan->mac_filters, IPVLAN_MAC_FILTER_SIZE);\n\t} else {\n\t\tstruct netdev_hw_addr *ha;\n\t\tDECLARE_BITMAP(mc_filters, IPVLAN_MAC_FILTER_SIZE);\n\n\t\tbitmap_zero(mc_filters, IPVLAN_MAC_FILTER_SIZE);\n\t\tnetdev_for_each_mc_addr(ha, dev)\n\t\t\t__set_bit(ipvlan_mac_hash(ha->addr), mc_filters);\n\n\t\t \n\t\t__set_bit(ipvlan_mac_hash(dev->broadcast), mc_filters);\n\n\t\tbitmap_copy(ipvlan->mac_filters, mc_filters,\n\t\t\t    IPVLAN_MAC_FILTER_SIZE);\n\t}\n\tdev_uc_sync(ipvlan->phy_dev, dev);\n\tdev_mc_sync(ipvlan->phy_dev, dev);\n}\n\nstatic void ipvlan_get_stats64(struct net_device *dev,\n\t\t\t       struct rtnl_link_stats64 *s)\n{\n\tstruct ipvl_dev *ipvlan = netdev_priv(dev);\n\n\tif (ipvlan->pcpu_stats) {\n\t\tstruct ipvl_pcpu_stats *pcptr;\n\t\tu64 rx_pkts, rx_bytes, rx_mcast, tx_pkts, tx_bytes;\n\t\tu32 rx_errs = 0, tx_drps = 0;\n\t\tu32 strt;\n\t\tint idx;\n\n\t\tfor_each_possible_cpu(idx) {\n\t\t\tpcptr = per_cpu_ptr(ipvlan->pcpu_stats, idx);\n\t\t\tdo {\n\t\t\t\tstrt = u64_stats_fetch_begin(&pcptr->syncp);\n\t\t\t\trx_pkts = u64_stats_read(&pcptr->rx_pkts);\n\t\t\t\trx_bytes = u64_stats_read(&pcptr->rx_bytes);\n\t\t\t\trx_mcast = u64_stats_read(&pcptr->rx_mcast);\n\t\t\t\ttx_pkts = u64_stats_read(&pcptr->tx_pkts);\n\t\t\t\ttx_bytes = u64_stats_read(&pcptr->tx_bytes);\n\t\t\t} while (u64_stats_fetch_retry(&pcptr->syncp,\n\t\t\t\t\t\t\t   strt));\n\n\t\t\ts->rx_packets += rx_pkts;\n\t\t\ts->rx_bytes += rx_bytes;\n\t\t\ts->multicast += rx_mcast;\n\t\t\ts->tx_packets += tx_pkts;\n\t\t\ts->tx_bytes += tx_bytes;\n\n\t\t\t \n\t\t\trx_errs += READ_ONCE(pcptr->rx_errs);\n\t\t\ttx_drps += READ_ONCE(pcptr->tx_drps);\n\t\t}\n\t\ts->rx_errors = rx_errs;\n\t\ts->rx_dropped = rx_errs;\n\t\ts->tx_dropped = tx_drps;\n\t}\n\ts->tx_errors = DEV_STATS_READ(dev, tx_errors);\n}\n\nstatic int ipvlan_vlan_rx_add_vid(struct net_device *dev, __be16 proto, u16 vid)\n{\n\tstruct ipvl_dev *ipvlan = netdev_priv(dev);\n\tstruct net_device *phy_dev = ipvlan->phy_dev;\n\n\treturn vlan_vid_add(phy_dev, proto, vid);\n}\n\nstatic int ipvlan_vlan_rx_kill_vid(struct net_device *dev, __be16 proto,\n\t\t\t\t   u16 vid)\n{\n\tstruct ipvl_dev *ipvlan = netdev_priv(dev);\n\tstruct net_device *phy_dev = ipvlan->phy_dev;\n\n\tvlan_vid_del(phy_dev, proto, vid);\n\treturn 0;\n}\n\nstatic int ipvlan_get_iflink(const struct net_device *dev)\n{\n\tstruct ipvl_dev *ipvlan = netdev_priv(dev);\n\n\treturn ipvlan->phy_dev->ifindex;\n}\n\nstatic const struct net_device_ops ipvlan_netdev_ops = {\n\t.ndo_init\t\t= ipvlan_init,\n\t.ndo_uninit\t\t= ipvlan_uninit,\n\t.ndo_open\t\t= ipvlan_open,\n\t.ndo_stop\t\t= ipvlan_stop,\n\t.ndo_start_xmit\t\t= ipvlan_start_xmit,\n\t.ndo_fix_features\t= ipvlan_fix_features,\n\t.ndo_change_rx_flags\t= ipvlan_change_rx_flags,\n\t.ndo_set_rx_mode\t= ipvlan_set_multicast_mac_filter,\n\t.ndo_get_stats64\t= ipvlan_get_stats64,\n\t.ndo_vlan_rx_add_vid\t= ipvlan_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= ipvlan_vlan_rx_kill_vid,\n\t.ndo_get_iflink\t\t= ipvlan_get_iflink,\n};\n\nstatic int ipvlan_hard_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\t      unsigned short type, const void *daddr,\n\t\t\t      const void *saddr, unsigned len)\n{\n\tconst struct ipvl_dev *ipvlan = netdev_priv(dev);\n\tstruct net_device *phy_dev = ipvlan->phy_dev;\n\n\t \n\treturn dev_hard_header(skb, phy_dev, type, daddr,\n\t\t\t       saddr ? : phy_dev->dev_addr, len);\n}\n\nstatic const struct header_ops ipvlan_header_ops = {\n\t.create  \t= ipvlan_hard_header,\n\t.parse\t\t= eth_header_parse,\n\t.cache\t\t= eth_header_cache,\n\t.cache_update\t= eth_header_cache_update,\n};\n\nstatic void ipvlan_adjust_mtu(struct ipvl_dev *ipvlan, struct net_device *dev)\n{\n\tipvlan->dev->mtu = dev->mtu;\n}\n\nstatic bool netif_is_ipvlan(const struct net_device *dev)\n{\n\t \n\treturn dev->netdev_ops == &ipvlan_netdev_ops;\n}\n\nstatic int ipvlan_ethtool_get_link_ksettings(struct net_device *dev,\n\t\t\t\t\t     struct ethtool_link_ksettings *cmd)\n{\n\tconst struct ipvl_dev *ipvlan = netdev_priv(dev);\n\n\treturn __ethtool_get_link_ksettings(ipvlan->phy_dev, cmd);\n}\n\nstatic void ipvlan_ethtool_get_drvinfo(struct net_device *dev,\n\t\t\t\t       struct ethtool_drvinfo *drvinfo)\n{\n\tstrscpy(drvinfo->driver, IPVLAN_DRV, sizeof(drvinfo->driver));\n\tstrscpy(drvinfo->version, IPV_DRV_VER, sizeof(drvinfo->version));\n}\n\nstatic u32 ipvlan_ethtool_get_msglevel(struct net_device *dev)\n{\n\tconst struct ipvl_dev *ipvlan = netdev_priv(dev);\n\n\treturn ipvlan->msg_enable;\n}\n\nstatic void ipvlan_ethtool_set_msglevel(struct net_device *dev, u32 value)\n{\n\tstruct ipvl_dev *ipvlan = netdev_priv(dev);\n\n\tipvlan->msg_enable = value;\n}\n\nstatic const struct ethtool_ops ipvlan_ethtool_ops = {\n\t.get_link\t= ethtool_op_get_link,\n\t.get_link_ksettings\t= ipvlan_ethtool_get_link_ksettings,\n\t.get_drvinfo\t= ipvlan_ethtool_get_drvinfo,\n\t.get_msglevel\t= ipvlan_ethtool_get_msglevel,\n\t.set_msglevel\t= ipvlan_ethtool_set_msglevel,\n};\n\nstatic int ipvlan_nl_changelink(struct net_device *dev,\n\t\t\t\tstruct nlattr *tb[], struct nlattr *data[],\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct ipvl_dev *ipvlan = netdev_priv(dev);\n\tstruct ipvl_port *port = ipvlan_port_get_rtnl(ipvlan->phy_dev);\n\tint err = 0;\n\n\tif (!data)\n\t\treturn 0;\n\tif (!ns_capable(dev_net(ipvlan->phy_dev)->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (data[IFLA_IPVLAN_MODE]) {\n\t\tu16 nmode = nla_get_u16(data[IFLA_IPVLAN_MODE]);\n\n\t\terr = ipvlan_set_port_mode(port, nmode, extack);\n\t}\n\n\tif (!err && data[IFLA_IPVLAN_FLAGS]) {\n\t\tu16 flags = nla_get_u16(data[IFLA_IPVLAN_FLAGS]);\n\n\t\tif (flags & IPVLAN_F_PRIVATE)\n\t\t\tipvlan_mark_private(port);\n\t\telse\n\t\t\tipvlan_clear_private(port);\n\n\t\tif (flags & IPVLAN_F_VEPA)\n\t\t\tipvlan_mark_vepa(port);\n\t\telse\n\t\t\tipvlan_clear_vepa(port);\n\t}\n\n\treturn err;\n}\n\nstatic size_t ipvlan_nl_getsize(const struct net_device *dev)\n{\n\treturn (0\n\t\t+ nla_total_size(2)  \n\t\t+ nla_total_size(2)  \n\t\t);\n}\n\nstatic int ipvlan_nl_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tif (!data)\n\t\treturn 0;\n\n\tif (data[IFLA_IPVLAN_MODE]) {\n\t\tu16 mode = nla_get_u16(data[IFLA_IPVLAN_MODE]);\n\n\t\tif (mode >= IPVLAN_MODE_MAX)\n\t\t\treturn -EINVAL;\n\t}\n\tif (data[IFLA_IPVLAN_FLAGS]) {\n\t\tu16 flags = nla_get_u16(data[IFLA_IPVLAN_FLAGS]);\n\n\t\t \n\t\tif (flags & ~(IPVLAN_F_PRIVATE | IPVLAN_F_VEPA))\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif ((flags & (IPVLAN_F_PRIVATE | IPVLAN_F_VEPA)) ==\n\t\t    (IPVLAN_F_PRIVATE | IPVLAN_F_VEPA))\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ipvlan_nl_fillinfo(struct sk_buff *skb,\n\t\t\t      const struct net_device *dev)\n{\n\tstruct ipvl_dev *ipvlan = netdev_priv(dev);\n\tstruct ipvl_port *port = ipvlan_port_get_rtnl(ipvlan->phy_dev);\n\tint ret = -EINVAL;\n\n\tif (!port)\n\t\tgoto err;\n\n\tret = -EMSGSIZE;\n\tif (nla_put_u16(skb, IFLA_IPVLAN_MODE, port->mode))\n\t\tgoto err;\n\tif (nla_put_u16(skb, IFLA_IPVLAN_FLAGS, port->flags))\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\treturn ret;\n}\n\nint ipvlan_link_new(struct net *src_net, struct net_device *dev,\n\t\t    struct nlattr *tb[], struct nlattr *data[],\n\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct ipvl_dev *ipvlan = netdev_priv(dev);\n\tstruct ipvl_port *port;\n\tstruct net_device *phy_dev;\n\tint err;\n\tu16 mode = IPVLAN_MODE_L3;\n\n\tif (!tb[IFLA_LINK])\n\t\treturn -EINVAL;\n\n\tphy_dev = __dev_get_by_index(src_net, nla_get_u32(tb[IFLA_LINK]));\n\tif (!phy_dev)\n\t\treturn -ENODEV;\n\n\tif (netif_is_ipvlan(phy_dev)) {\n\t\tstruct ipvl_dev *tmp = netdev_priv(phy_dev);\n\n\t\tphy_dev = tmp->phy_dev;\n\t\tif (!ns_capable(dev_net(phy_dev)->user_ns, CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t} else if (!netif_is_ipvlan_port(phy_dev)) {\n\t\t \n\t\tif (phy_dev->type != ARPHRD_ETHER ||\n\t\t    phy_dev->flags & IFF_LOOPBACK) {\n\t\t\tnetdev_err(phy_dev,\n\t\t\t\t   \"Master is either lo or non-ether device\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (netdev_is_rx_handler_busy(phy_dev)) {\n\t\t\tnetdev_err(phy_dev, \"Device is already in use.\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tipvlan->phy_dev = phy_dev;\n\tipvlan->dev = dev;\n\tipvlan->sfeatures = IPVLAN_FEATURES;\n\tif (!tb[IFLA_MTU])\n\t\tipvlan_adjust_mtu(ipvlan, phy_dev);\n\tINIT_LIST_HEAD(&ipvlan->addrs);\n\tspin_lock_init(&ipvlan->addrs_lock);\n\n\t \n\teth_hw_addr_set(dev, phy_dev->dev_addr);\n\n\tdev->priv_flags |= IFF_NO_RX_HANDLER;\n\n\terr = register_netdevice(dev);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tport = ipvlan_port_get_rtnl(phy_dev);\n\tipvlan->port = port;\n\n\t \n\tif (port->dev_id_start == 0xFFFE)\n\t\tport->dev_id_start = 0x1;\n\n\t \n\terr = ida_simple_get(&port->ida, port->dev_id_start, 0xFFFE,\n\t\t\t     GFP_KERNEL);\n\tif (err < 0)\n\t\terr = ida_simple_get(&port->ida, 0x1, port->dev_id_start,\n\t\t\t\t     GFP_KERNEL);\n\tif (err < 0)\n\t\tgoto unregister_netdev;\n\tdev->dev_id = err;\n\n\t \n\tport->dev_id_start = err + 1;\n\n\terr = netdev_upper_dev_link(phy_dev, dev, extack);\n\tif (err)\n\t\tgoto remove_ida;\n\n\t \n\tif (data && data[IFLA_IPVLAN_FLAGS])\n\t\tport->flags = nla_get_u16(data[IFLA_IPVLAN_FLAGS]);\n\n\tif (data && data[IFLA_IPVLAN_MODE])\n\t\tmode = nla_get_u16(data[IFLA_IPVLAN_MODE]);\n\n\terr = ipvlan_set_port_mode(port, mode, extack);\n\tif (err)\n\t\tgoto unlink_netdev;\n\n\tlist_add_tail_rcu(&ipvlan->pnode, &port->ipvlans);\n\tnetif_stacked_transfer_operstate(phy_dev, dev);\n\treturn 0;\n\nunlink_netdev:\n\tnetdev_upper_dev_unlink(phy_dev, dev);\nremove_ida:\n\tida_simple_remove(&port->ida, dev->dev_id);\nunregister_netdev:\n\tunregister_netdevice(dev);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(ipvlan_link_new);\n\nvoid ipvlan_link_delete(struct net_device *dev, struct list_head *head)\n{\n\tstruct ipvl_dev *ipvlan = netdev_priv(dev);\n\tstruct ipvl_addr *addr, *next;\n\n\tspin_lock_bh(&ipvlan->addrs_lock);\n\tlist_for_each_entry_safe(addr, next, &ipvlan->addrs, anode) {\n\t\tipvlan_ht_addr_del(addr);\n\t\tlist_del_rcu(&addr->anode);\n\t\tkfree_rcu(addr, rcu);\n\t}\n\tspin_unlock_bh(&ipvlan->addrs_lock);\n\n\tida_simple_remove(&ipvlan->port->ida, dev->dev_id);\n\tlist_del_rcu(&ipvlan->pnode);\n\tunregister_netdevice_queue(dev, head);\n\tnetdev_upper_dev_unlink(ipvlan->phy_dev, dev);\n}\nEXPORT_SYMBOL_GPL(ipvlan_link_delete);\n\nvoid ipvlan_link_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\n\tdev->max_mtu = ETH_MAX_MTU;\n\tdev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n\tdev->priv_flags |= IFF_UNICAST_FLT | IFF_NO_QUEUE;\n\tdev->netdev_ops = &ipvlan_netdev_ops;\n\tdev->needs_free_netdev = true;\n\tdev->header_ops = &ipvlan_header_ops;\n\tdev->ethtool_ops = &ipvlan_ethtool_ops;\n}\nEXPORT_SYMBOL_GPL(ipvlan_link_setup);\n\nstatic const struct nla_policy ipvlan_nl_policy[IFLA_IPVLAN_MAX + 1] =\n{\n\t[IFLA_IPVLAN_MODE] = { .type = NLA_U16 },\n\t[IFLA_IPVLAN_FLAGS] = { .type = NLA_U16 },\n};\n\nstatic struct net *ipvlan_get_link_net(const struct net_device *dev)\n{\n\tstruct ipvl_dev *ipvlan = netdev_priv(dev);\n\n\treturn dev_net(ipvlan->phy_dev);\n}\n\nstatic struct rtnl_link_ops ipvlan_link_ops = {\n\t.kind\t\t= \"ipvlan\",\n\t.priv_size\t= sizeof(struct ipvl_dev),\n\n\t.setup\t\t= ipvlan_link_setup,\n\t.newlink\t= ipvlan_link_new,\n\t.dellink\t= ipvlan_link_delete,\n\t.get_link_net   = ipvlan_get_link_net,\n};\n\nint ipvlan_link_register(struct rtnl_link_ops *ops)\n{\n\tops->get_size\t= ipvlan_nl_getsize;\n\tops->policy\t= ipvlan_nl_policy;\n\tops->validate\t= ipvlan_nl_validate;\n\tops->fill_info\t= ipvlan_nl_fillinfo;\n\tops->changelink = ipvlan_nl_changelink;\n\tops->maxtype\t= IFLA_IPVLAN_MAX;\n\treturn rtnl_link_register(ops);\n}\nEXPORT_SYMBOL_GPL(ipvlan_link_register);\n\nstatic int ipvlan_device_event(struct notifier_block *unused,\n\t\t\t       unsigned long event, void *ptr)\n{\n\tstruct netlink_ext_ack *extack = netdev_notifier_info_to_extack(ptr);\n\tstruct netdev_notifier_pre_changeaddr_info *prechaddr_info;\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct ipvl_dev *ipvlan, *next;\n\tstruct ipvl_port *port;\n\tLIST_HEAD(lst_kill);\n\tint err;\n\n\tif (!netif_is_ipvlan_port(dev))\n\t\treturn NOTIFY_DONE;\n\n\tport = ipvlan_port_get_rtnl(dev);\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\tcase NETDEV_CHANGE:\n\t\tlist_for_each_entry(ipvlan, &port->ipvlans, pnode)\n\t\t\tnetif_stacked_transfer_operstate(ipvlan->phy_dev,\n\t\t\t\t\t\t\t ipvlan->dev);\n\t\tbreak;\n\n\tcase NETDEV_REGISTER: {\n\t\tstruct net *oldnet, *newnet = dev_net(dev);\n\n\t\toldnet = read_pnet(&port->pnet);\n\t\tif (net_eq(newnet, oldnet))\n\t\t\tbreak;\n\n\t\twrite_pnet(&port->pnet, newnet);\n\n\t\tif (port->mode == IPVLAN_MODE_L3S)\n\t\t\tipvlan_migrate_l3s_hook(oldnet, newnet);\n\t\tbreak;\n\t}\n\tcase NETDEV_UNREGISTER:\n\t\tif (dev->reg_state != NETREG_UNREGISTERING)\n\t\t\tbreak;\n\n\t\tlist_for_each_entry_safe(ipvlan, next, &port->ipvlans, pnode)\n\t\t\tipvlan->dev->rtnl_link_ops->dellink(ipvlan->dev,\n\t\t\t\t\t\t\t    &lst_kill);\n\t\tunregister_netdevice_many(&lst_kill);\n\t\tbreak;\n\n\tcase NETDEV_FEAT_CHANGE:\n\t\tlist_for_each_entry(ipvlan, &port->ipvlans, pnode) {\n\t\t\tnetif_inherit_tso_max(ipvlan->dev, dev);\n\t\t\tnetdev_update_features(ipvlan->dev);\n\t\t}\n\t\tbreak;\n\n\tcase NETDEV_CHANGEMTU:\n\t\tlist_for_each_entry(ipvlan, &port->ipvlans, pnode)\n\t\t\tipvlan_adjust_mtu(ipvlan, dev);\n\t\tbreak;\n\n\tcase NETDEV_PRE_CHANGEADDR:\n\t\tprechaddr_info = ptr;\n\t\tlist_for_each_entry(ipvlan, &port->ipvlans, pnode) {\n\t\t\terr = dev_pre_changeaddr_notify(ipvlan->dev,\n\t\t\t\t\t\t    prechaddr_info->dev_addr,\n\t\t\t\t\t\t    extack);\n\t\t\tif (err)\n\t\t\t\treturn notifier_from_errno(err);\n\t\t}\n\t\tbreak;\n\n\tcase NETDEV_CHANGEADDR:\n\t\tlist_for_each_entry(ipvlan, &port->ipvlans, pnode) {\n\t\t\teth_hw_addr_set(ipvlan->dev, dev->dev_addr);\n\t\t\tcall_netdevice_notifiers(NETDEV_CHANGEADDR, ipvlan->dev);\n\t\t}\n\t\tbreak;\n\n\tcase NETDEV_PRE_TYPE_CHANGE:\n\t\t \n\t\treturn NOTIFY_BAD;\n\t}\n\treturn NOTIFY_DONE;\n}\n\n \nstatic int ipvlan_add_addr(struct ipvl_dev *ipvlan, void *iaddr, bool is_v6)\n{\n\tstruct ipvl_addr *addr;\n\n\taddr = kzalloc(sizeof(struct ipvl_addr), GFP_ATOMIC);\n\tif (!addr)\n\t\treturn -ENOMEM;\n\n\taddr->master = ipvlan;\n\tif (!is_v6) {\n\t\tmemcpy(&addr->ip4addr, iaddr, sizeof(struct in_addr));\n\t\taddr->atype = IPVL_IPV4;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else {\n\t\tmemcpy(&addr->ip6addr, iaddr, sizeof(struct in6_addr));\n\t\taddr->atype = IPVL_IPV6;\n#endif\n\t}\n\n\tlist_add_tail_rcu(&addr->anode, &ipvlan->addrs);\n\n\t \n\tif (netif_running(ipvlan->dev))\n\t\tipvlan_ht_addr_add(ipvlan, addr);\n\n\treturn 0;\n}\n\nstatic void ipvlan_del_addr(struct ipvl_dev *ipvlan, void *iaddr, bool is_v6)\n{\n\tstruct ipvl_addr *addr;\n\n\tspin_lock_bh(&ipvlan->addrs_lock);\n\taddr = ipvlan_find_addr(ipvlan, iaddr, is_v6);\n\tif (!addr) {\n\t\tspin_unlock_bh(&ipvlan->addrs_lock);\n\t\treturn;\n\t}\n\n\tipvlan_ht_addr_del(addr);\n\tlist_del_rcu(&addr->anode);\n\tspin_unlock_bh(&ipvlan->addrs_lock);\n\tkfree_rcu(addr, rcu);\n}\n\nstatic bool ipvlan_is_valid_dev(const struct net_device *dev)\n{\n\tstruct ipvl_dev *ipvlan = netdev_priv(dev);\n\n\tif (!netif_is_ipvlan(dev))\n\t\treturn false;\n\n\tif (!ipvlan || !ipvlan->port)\n\t\treturn false;\n\n\treturn true;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int ipvlan_add_addr6(struct ipvl_dev *ipvlan, struct in6_addr *ip6_addr)\n{\n\tint ret = -EINVAL;\n\n\tspin_lock_bh(&ipvlan->addrs_lock);\n\tif (ipvlan_addr_busy(ipvlan->port, ip6_addr, true))\n\t\tnetif_err(ipvlan, ifup, ipvlan->dev,\n\t\t\t  \"Failed to add IPv6=%pI6c addr for %s intf\\n\",\n\t\t\t  ip6_addr, ipvlan->dev->name);\n\telse\n\t\tret = ipvlan_add_addr(ipvlan, ip6_addr, true);\n\tspin_unlock_bh(&ipvlan->addrs_lock);\n\treturn ret;\n}\n\nstatic void ipvlan_del_addr6(struct ipvl_dev *ipvlan, struct in6_addr *ip6_addr)\n{\n\treturn ipvlan_del_addr(ipvlan, ip6_addr, true);\n}\n\nstatic int ipvlan_addr6_event(struct notifier_block *unused,\n\t\t\t      unsigned long event, void *ptr)\n{\n\tstruct inet6_ifaddr *if6 = (struct inet6_ifaddr *)ptr;\n\tstruct net_device *dev = (struct net_device *)if6->idev->dev;\n\tstruct ipvl_dev *ipvlan = netdev_priv(dev);\n\n\tif (!ipvlan_is_valid_dev(dev))\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\tif (ipvlan_add_addr6(ipvlan, &if6->addr))\n\t\t\treturn NOTIFY_BAD;\n\t\tbreak;\n\n\tcase NETDEV_DOWN:\n\t\tipvlan_del_addr6(ipvlan, &if6->addr);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic int ipvlan_addr6_validator_event(struct notifier_block *unused,\n\t\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct in6_validator_info *i6vi = (struct in6_validator_info *)ptr;\n\tstruct net_device *dev = (struct net_device *)i6vi->i6vi_dev->dev;\n\tstruct ipvl_dev *ipvlan = netdev_priv(dev);\n\n\tif (!ipvlan_is_valid_dev(dev))\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\tif (ipvlan_addr_busy(ipvlan->port, &i6vi->i6vi_addr, true)) {\n\t\t\tNL_SET_ERR_MSG(i6vi->extack,\n\t\t\t\t       \"Address already assigned to an ipvlan device\");\n\t\t\treturn notifier_from_errno(-EADDRINUSE);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n}\n#endif\n\nstatic int ipvlan_add_addr4(struct ipvl_dev *ipvlan, struct in_addr *ip4_addr)\n{\n\tint ret = -EINVAL;\n\n\tspin_lock_bh(&ipvlan->addrs_lock);\n\tif (ipvlan_addr_busy(ipvlan->port, ip4_addr, false))\n\t\tnetif_err(ipvlan, ifup, ipvlan->dev,\n\t\t\t  \"Failed to add IPv4=%pI4 on %s intf.\\n\",\n\t\t\t  ip4_addr, ipvlan->dev->name);\n\telse\n\t\tret = ipvlan_add_addr(ipvlan, ip4_addr, false);\n\tspin_unlock_bh(&ipvlan->addrs_lock);\n\treturn ret;\n}\n\nstatic void ipvlan_del_addr4(struct ipvl_dev *ipvlan, struct in_addr *ip4_addr)\n{\n\treturn ipvlan_del_addr(ipvlan, ip4_addr, false);\n}\n\nstatic int ipvlan_addr4_event(struct notifier_block *unused,\n\t\t\t      unsigned long event, void *ptr)\n{\n\tstruct in_ifaddr *if4 = (struct in_ifaddr *)ptr;\n\tstruct net_device *dev = (struct net_device *)if4->ifa_dev->dev;\n\tstruct ipvl_dev *ipvlan = netdev_priv(dev);\n\tstruct in_addr ip4_addr;\n\n\tif (!ipvlan_is_valid_dev(dev))\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\tip4_addr.s_addr = if4->ifa_address;\n\t\tif (ipvlan_add_addr4(ipvlan, &ip4_addr))\n\t\t\treturn NOTIFY_BAD;\n\t\tbreak;\n\n\tcase NETDEV_DOWN:\n\t\tip4_addr.s_addr = if4->ifa_address;\n\t\tipvlan_del_addr4(ipvlan, &ip4_addr);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic int ipvlan_addr4_validator_event(struct notifier_block *unused,\n\t\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct in_validator_info *ivi = (struct in_validator_info *)ptr;\n\tstruct net_device *dev = (struct net_device *)ivi->ivi_dev->dev;\n\tstruct ipvl_dev *ipvlan = netdev_priv(dev);\n\n\tif (!ipvlan_is_valid_dev(dev))\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\tif (ipvlan_addr_busy(ipvlan->port, &ivi->ivi_addr, false)) {\n\t\t\tNL_SET_ERR_MSG(ivi->extack,\n\t\t\t\t       \"Address already assigned to an ipvlan device\");\n\t\t\treturn notifier_from_errno(-EADDRINUSE);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block ipvlan_addr4_notifier_block __read_mostly = {\n\t.notifier_call = ipvlan_addr4_event,\n};\n\nstatic struct notifier_block ipvlan_addr4_vtor_notifier_block __read_mostly = {\n\t.notifier_call = ipvlan_addr4_validator_event,\n};\n\nstatic struct notifier_block ipvlan_notifier_block __read_mostly = {\n\t.notifier_call = ipvlan_device_event,\n};\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic struct notifier_block ipvlan_addr6_notifier_block __read_mostly = {\n\t.notifier_call = ipvlan_addr6_event,\n};\n\nstatic struct notifier_block ipvlan_addr6_vtor_notifier_block __read_mostly = {\n\t.notifier_call = ipvlan_addr6_validator_event,\n};\n#endif\n\nstatic int __init ipvlan_init_module(void)\n{\n\tint err;\n\n\tipvlan_init_secret();\n\tregister_netdevice_notifier(&ipvlan_notifier_block);\n#if IS_ENABLED(CONFIG_IPV6)\n\tregister_inet6addr_notifier(&ipvlan_addr6_notifier_block);\n\tregister_inet6addr_validator_notifier(\n\t    &ipvlan_addr6_vtor_notifier_block);\n#endif\n\tregister_inetaddr_notifier(&ipvlan_addr4_notifier_block);\n\tregister_inetaddr_validator_notifier(&ipvlan_addr4_vtor_notifier_block);\n\n\terr = ipvlan_l3s_init();\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = ipvlan_link_register(&ipvlan_link_ops);\n\tif (err < 0) {\n\t\tipvlan_l3s_cleanup();\n\t\tgoto error;\n\t}\n\n\treturn 0;\nerror:\n\tunregister_inetaddr_notifier(&ipvlan_addr4_notifier_block);\n\tunregister_inetaddr_validator_notifier(\n\t    &ipvlan_addr4_vtor_notifier_block);\n#if IS_ENABLED(CONFIG_IPV6)\n\tunregister_inet6addr_notifier(&ipvlan_addr6_notifier_block);\n\tunregister_inet6addr_validator_notifier(\n\t    &ipvlan_addr6_vtor_notifier_block);\n#endif\n\tunregister_netdevice_notifier(&ipvlan_notifier_block);\n\treturn err;\n}\n\nstatic void __exit ipvlan_cleanup_module(void)\n{\n\trtnl_link_unregister(&ipvlan_link_ops);\n\tipvlan_l3s_cleanup();\n\tunregister_netdevice_notifier(&ipvlan_notifier_block);\n\tunregister_inetaddr_notifier(&ipvlan_addr4_notifier_block);\n\tunregister_inetaddr_validator_notifier(\n\t    &ipvlan_addr4_vtor_notifier_block);\n#if IS_ENABLED(CONFIG_IPV6)\n\tunregister_inet6addr_notifier(&ipvlan_addr6_notifier_block);\n\tunregister_inet6addr_validator_notifier(\n\t    &ipvlan_addr6_vtor_notifier_block);\n#endif\n}\n\nmodule_init(ipvlan_init_module);\nmodule_exit(ipvlan_cleanup_module);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Mahesh Bandewar <maheshb@google.com>\");\nMODULE_DESCRIPTION(\"Driver for L3 (IPv6/IPv4) based VLANs\");\nMODULE_ALIAS_RTNL_LINK(\"ipvlan\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}