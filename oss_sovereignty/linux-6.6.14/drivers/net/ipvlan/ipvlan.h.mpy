{
  "module_name": "ipvlan.h",
  "hash_id": "e0c9082e664f1a114d9ff91afb27a7f81ce7e53dc03effd8e6f80741f3ea9c1c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ipvlan/ipvlan.h",
  "human_readable_source": " \n \n#ifndef __IPVLAN_H\n#define __IPVLAN_H\n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/rculist.h>\n#include <linux/notifier.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/if_arp.h>\n#include <linux/if_link.h>\n#include <linux/if_vlan.h>\n#include <linux/ip.h>\n#include <linux/inetdevice.h>\n#include <linux/netfilter.h>\n#include <net/ip.h>\n#include <net/ip6_route.h>\n#include <net/netns/generic.h>\n#include <net/rtnetlink.h>\n#include <net/route.h>\n#include <net/addrconf.h>\n#include <net/l3mdev.h>\n\n#define IPVLAN_DRV\t\"ipvlan\"\n#define IPV_DRV_VER\t\"0.1\"\n\n#define IPVLAN_HASH_SIZE\t(1 << BITS_PER_BYTE)\n#define IPVLAN_HASH_MASK\t(IPVLAN_HASH_SIZE - 1)\n\n#define IPVLAN_MAC_FILTER_BITS\t8\n#define IPVLAN_MAC_FILTER_SIZE\t(1 << IPVLAN_MAC_FILTER_BITS)\n#define IPVLAN_MAC_FILTER_MASK\t(IPVLAN_MAC_FILTER_SIZE - 1)\n\n#define IPVLAN_QBACKLOG_LIMIT\t1000\n\ntypedef enum {\n\tIPVL_IPV6 = 0,\n\tIPVL_ICMPV6,\n\tIPVL_IPV4,\n\tIPVL_ARP,\n} ipvl_hdr_type;\n\nstruct ipvl_pcpu_stats {\n\tu64_stats_t\t\trx_pkts;\n\tu64_stats_t\t\trx_bytes;\n\tu64_stats_t\t\trx_mcast;\n\tu64_stats_t\t\ttx_pkts;\n\tu64_stats_t\t\ttx_bytes;\n\tstruct u64_stats_sync\tsyncp;\n\tu32\t\t\trx_errs;\n\tu32\t\t\ttx_drps;\n};\n\nstruct ipvl_port;\n\nstruct ipvl_dev {\n\tstruct net_device\t*dev;\n\tstruct list_head\tpnode;\n\tstruct ipvl_port\t*port;\n\tstruct net_device\t*phy_dev;\n\tstruct list_head\taddrs;\n\tstruct ipvl_pcpu_stats\t__percpu *pcpu_stats;\n\tDECLARE_BITMAP(mac_filters, IPVLAN_MAC_FILTER_SIZE);\n\tnetdev_features_t\tsfeatures;\n\tu32\t\t\tmsg_enable;\n\tspinlock_t\t\taddrs_lock;\n};\n\nstruct ipvl_addr {\n\tstruct ipvl_dev\t\t*master;  \n\tunion {\n\t\tstruct in6_addr\tip6;\t  \n\t\tstruct in_addr\tip4;\t  \n\t} ipu;\n#define ip6addr\tipu.ip6\n#define ip4addr ipu.ip4\n\tstruct hlist_node\thlnode;   \n\tstruct list_head\tanode;    \n\tipvl_hdr_type\t\tatype;\n\tstruct rcu_head\t\trcu;\n};\n\nstruct ipvl_port {\n\tstruct net_device\t*dev;\n\tpossible_net_t\t\tpnet;\n\tstruct hlist_head\thlhead[IPVLAN_HASH_SIZE];\n\tstruct list_head\tipvlans;\n\tu16\t\t\tmode;\n\tu16\t\t\tflags;\n\tu16\t\t\tdev_id_start;\n\tstruct work_struct\twq;\n\tstruct sk_buff_head\tbacklog;\n\tint\t\t\tcount;\n\tstruct ida\t\tida;\n\tnetdevice_tracker\tdev_tracker;\n};\n\nstruct ipvl_skb_cb {\n\tbool tx_pkt;\n};\n#define IPVL_SKB_CB(_skb) ((struct ipvl_skb_cb *)&((_skb)->cb[0]))\n\nstatic inline struct ipvl_port *ipvlan_port_get_rcu(const struct net_device *d)\n{\n\treturn rcu_dereference(d->rx_handler_data);\n}\n\nstatic inline struct ipvl_port *ipvlan_port_get_rcu_bh(const struct net_device *d)\n{\n\treturn rcu_dereference_bh(d->rx_handler_data);\n}\n\nstatic inline struct ipvl_port *ipvlan_port_get_rtnl(const struct net_device *d)\n{\n\treturn rtnl_dereference(d->rx_handler_data);\n}\n\nstatic inline bool ipvlan_is_private(const struct ipvl_port *port)\n{\n\treturn !!(port->flags & IPVLAN_F_PRIVATE);\n}\n\nstatic inline void ipvlan_mark_private(struct ipvl_port *port)\n{\n\tport->flags |= IPVLAN_F_PRIVATE;\n}\n\nstatic inline void ipvlan_clear_private(struct ipvl_port *port)\n{\n\tport->flags &= ~IPVLAN_F_PRIVATE;\n}\n\nstatic inline bool ipvlan_is_vepa(const struct ipvl_port *port)\n{\n\treturn !!(port->flags & IPVLAN_F_VEPA);\n}\n\nstatic inline void ipvlan_mark_vepa(struct ipvl_port *port)\n{\n\tport->flags |= IPVLAN_F_VEPA;\n}\n\nstatic inline void ipvlan_clear_vepa(struct ipvl_port *port)\n{\n\tport->flags &= ~IPVLAN_F_VEPA;\n}\n\nvoid ipvlan_init_secret(void);\nunsigned int ipvlan_mac_hash(const unsigned char *addr);\nrx_handler_result_t ipvlan_handle_frame(struct sk_buff **pskb);\nvoid ipvlan_process_multicast(struct work_struct *work);\nint ipvlan_queue_xmit(struct sk_buff *skb, struct net_device *dev);\nvoid ipvlan_ht_addr_add(struct ipvl_dev *ipvlan, struct ipvl_addr *addr);\nstruct ipvl_addr *ipvlan_find_addr(const struct ipvl_dev *ipvlan,\n\t\t\t\t   const void *iaddr, bool is_v6);\nbool ipvlan_addr_busy(struct ipvl_port *port, void *iaddr, bool is_v6);\nvoid ipvlan_ht_addr_del(struct ipvl_addr *addr);\nstruct ipvl_addr *ipvlan_addr_lookup(struct ipvl_port *port, void *lyr3h,\n\t\t\t\t     int addr_type, bool use_dest);\nvoid *ipvlan_get_L3_hdr(struct ipvl_port *port, struct sk_buff *skb, int *type);\nvoid ipvlan_count_rx(const struct ipvl_dev *ipvlan,\n\t\t     unsigned int len, bool success, bool mcast);\nint ipvlan_link_new(struct net *src_net, struct net_device *dev,\n\t\t    struct nlattr *tb[], struct nlattr *data[],\n\t\t    struct netlink_ext_ack *extack);\nvoid ipvlan_link_delete(struct net_device *dev, struct list_head *head);\nvoid ipvlan_link_setup(struct net_device *dev);\nint ipvlan_link_register(struct rtnl_link_ops *ops);\n#ifdef CONFIG_IPVLAN_L3S\nint ipvlan_l3s_register(struct ipvl_port *port);\nvoid ipvlan_l3s_unregister(struct ipvl_port *port);\nvoid ipvlan_migrate_l3s_hook(struct net *oldnet, struct net *newnet);\nint ipvlan_l3s_init(void);\nvoid ipvlan_l3s_cleanup(void);\n#else\nstatic inline int ipvlan_l3s_register(struct ipvl_port *port)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic inline void ipvlan_l3s_unregister(struct ipvl_port *port)\n{\n}\n\nstatic inline void ipvlan_migrate_l3s_hook(struct net *oldnet,\n\t\t\t\t\t   struct net *newnet)\n{\n}\n\nstatic inline int ipvlan_l3s_init(void)\n{\n\treturn 0;\n}\n\nstatic inline void ipvlan_l3s_cleanup(void)\n{\n}\n#endif  \n\nstatic inline bool netif_is_ipvlan_port(const struct net_device *dev)\n{\n\treturn rcu_access_pointer(dev->rx_handler) == ipvlan_handle_frame;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}