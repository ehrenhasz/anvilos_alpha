{
  "module_name": "ipvlan_core.c",
  "hash_id": "d5ba1459aabb3ab0422fb8b5e7433504d8a1ca438abc88f4428c1bd8c6c61f57",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ipvlan/ipvlan_core.c",
  "human_readable_source": "\n \n\n#include \"ipvlan.h\"\n\nstatic u32 ipvlan_jhash_secret __read_mostly;\n\nvoid ipvlan_init_secret(void)\n{\n\tnet_get_random_once(&ipvlan_jhash_secret, sizeof(ipvlan_jhash_secret));\n}\n\nvoid ipvlan_count_rx(const struct ipvl_dev *ipvlan,\n\t\t\t    unsigned int len, bool success, bool mcast)\n{\n\tif (likely(success)) {\n\t\tstruct ipvl_pcpu_stats *pcptr;\n\n\t\tpcptr = this_cpu_ptr(ipvlan->pcpu_stats);\n\t\tu64_stats_update_begin(&pcptr->syncp);\n\t\tu64_stats_inc(&pcptr->rx_pkts);\n\t\tu64_stats_add(&pcptr->rx_bytes, len);\n\t\tif (mcast)\n\t\t\tu64_stats_inc(&pcptr->rx_mcast);\n\t\tu64_stats_update_end(&pcptr->syncp);\n\t} else {\n\t\tthis_cpu_inc(ipvlan->pcpu_stats->rx_errs);\n\t}\n}\nEXPORT_SYMBOL_GPL(ipvlan_count_rx);\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic u8 ipvlan_get_v6_hash(const void *iaddr)\n{\n\tconst struct in6_addr *ip6_addr = iaddr;\n\n\treturn __ipv6_addr_jhash(ip6_addr, ipvlan_jhash_secret) &\n\t       IPVLAN_HASH_MASK;\n}\n#else\nstatic u8 ipvlan_get_v6_hash(const void *iaddr)\n{\n\treturn 0;\n}\n#endif\n\nstatic u8 ipvlan_get_v4_hash(const void *iaddr)\n{\n\tconst struct in_addr *ip4_addr = iaddr;\n\n\treturn jhash_1word(ip4_addr->s_addr, ipvlan_jhash_secret) &\n\t       IPVLAN_HASH_MASK;\n}\n\nstatic bool addr_equal(bool is_v6, struct ipvl_addr *addr, const void *iaddr)\n{\n\tif (!is_v6 && addr->atype == IPVL_IPV4) {\n\t\tstruct in_addr *i4addr = (struct in_addr *)iaddr;\n\n\t\treturn addr->ip4addr.s_addr == i4addr->s_addr;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (is_v6 && addr->atype == IPVL_IPV6) {\n\t\tstruct in6_addr *i6addr = (struct in6_addr *)iaddr;\n\n\t\treturn ipv6_addr_equal(&addr->ip6addr, i6addr);\n#endif\n\t}\n\n\treturn false;\n}\n\nstatic struct ipvl_addr *ipvlan_ht_addr_lookup(const struct ipvl_port *port,\n\t\t\t\t\t       const void *iaddr, bool is_v6)\n{\n\tstruct ipvl_addr *addr;\n\tu8 hash;\n\n\thash = is_v6 ? ipvlan_get_v6_hash(iaddr) :\n\t       ipvlan_get_v4_hash(iaddr);\n\thlist_for_each_entry_rcu(addr, &port->hlhead[hash], hlnode)\n\t\tif (addr_equal(is_v6, addr, iaddr))\n\t\t\treturn addr;\n\treturn NULL;\n}\n\nvoid ipvlan_ht_addr_add(struct ipvl_dev *ipvlan, struct ipvl_addr *addr)\n{\n\tstruct ipvl_port *port = ipvlan->port;\n\tu8 hash;\n\n\thash = (addr->atype == IPVL_IPV6) ?\n\t       ipvlan_get_v6_hash(&addr->ip6addr) :\n\t       ipvlan_get_v4_hash(&addr->ip4addr);\n\tif (hlist_unhashed(&addr->hlnode))\n\t\thlist_add_head_rcu(&addr->hlnode, &port->hlhead[hash]);\n}\n\nvoid ipvlan_ht_addr_del(struct ipvl_addr *addr)\n{\n\thlist_del_init_rcu(&addr->hlnode);\n}\n\nstruct ipvl_addr *ipvlan_find_addr(const struct ipvl_dev *ipvlan,\n\t\t\t\t   const void *iaddr, bool is_v6)\n{\n\tstruct ipvl_addr *addr, *ret = NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(addr, &ipvlan->addrs, anode) {\n\t\tif (addr_equal(is_v6, addr, iaddr)) {\n\t\t\tret = addr;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n\nbool ipvlan_addr_busy(struct ipvl_port *port, void *iaddr, bool is_v6)\n{\n\tstruct ipvl_dev *ipvlan;\n\tbool ret = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(ipvlan, &port->ipvlans, pnode) {\n\t\tif (ipvlan_find_addr(ipvlan, iaddr, is_v6)) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}\n\nvoid *ipvlan_get_L3_hdr(struct ipvl_port *port, struct sk_buff *skb, int *type)\n{\n\tvoid *lyr3h = NULL;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_ARP): {\n\t\tstruct arphdr *arph;\n\n\t\tif (unlikely(!pskb_may_pull(skb, arp_hdr_len(port->dev))))\n\t\t\treturn NULL;\n\n\t\tarph = arp_hdr(skb);\n\t\t*type = IPVL_ARP;\n\t\tlyr3h = arph;\n\t\tbreak;\n\t}\n\tcase htons(ETH_P_IP): {\n\t\tu32 pktlen;\n\t\tstruct iphdr *ip4h;\n\n\t\tif (unlikely(!pskb_may_pull(skb, sizeof(*ip4h))))\n\t\t\treturn NULL;\n\n\t\tip4h = ip_hdr(skb);\n\t\tpktlen = skb_ip_totlen(skb);\n\t\tif (ip4h->ihl < 5 || ip4h->version != 4)\n\t\t\treturn NULL;\n\t\tif (skb->len < pktlen || pktlen < (ip4h->ihl * 4))\n\t\t\treturn NULL;\n\n\t\t*type = IPVL_IPV4;\n\t\tlyr3h = ip4h;\n\t\tbreak;\n\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6): {\n\t\tstruct ipv6hdr *ip6h;\n\n\t\tif (unlikely(!pskb_may_pull(skb, sizeof(*ip6h))))\n\t\t\treturn NULL;\n\n\t\tip6h = ipv6_hdr(skb);\n\t\tif (ip6h->version != 6)\n\t\t\treturn NULL;\n\n\t\t*type = IPVL_IPV6;\n\t\tlyr3h = ip6h;\n\t\t \n\t\tif (ipv6_addr_any(&ip6h->saddr) &&\n\t\t    ip6h->nexthdr == NEXTHDR_ICMP) {\n\t\t\tstruct icmp6hdr\t*icmph;\n\n\t\t\tif (unlikely(!pskb_may_pull(skb, sizeof(*ip6h) + sizeof(*icmph))))\n\t\t\t\treturn NULL;\n\n\t\t\tip6h = ipv6_hdr(skb);\n\t\t\ticmph = (struct icmp6hdr *)(ip6h + 1);\n\n\t\t\tif (icmph->icmp6_type == NDISC_NEIGHBOUR_SOLICITATION) {\n\t\t\t\t \n\t\t\t\tif (unlikely(!pskb_may_pull(skb, sizeof(*ip6h) + sizeof(*icmph)\n\t\t\t\t\t\t+ sizeof(struct in6_addr))))\n\t\t\t\t\treturn NULL;\n\n\t\t\t\tip6h = ipv6_hdr(skb);\n\t\t\t\ticmph = (struct icmp6hdr *)(ip6h + 1);\n\t\t\t}\n\n\t\t\t*type = IPVL_ICMPV6;\n\t\t\tlyr3h = icmph;\n\t\t}\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\treturn lyr3h;\n}\n\nunsigned int ipvlan_mac_hash(const unsigned char *addr)\n{\n\tu32 hash = jhash_1word(__get_unaligned_cpu32(addr+2),\n\t\t\t       ipvlan_jhash_secret);\n\n\treturn hash & IPVLAN_MAC_FILTER_MASK;\n}\n\nvoid ipvlan_process_multicast(struct work_struct *work)\n{\n\tstruct ipvl_port *port = container_of(work, struct ipvl_port, wq);\n\tstruct ethhdr *ethh;\n\tstruct ipvl_dev *ipvlan;\n\tstruct sk_buff *skb, *nskb;\n\tstruct sk_buff_head list;\n\tunsigned int len;\n\tunsigned int mac_hash;\n\tint ret;\n\tu8 pkt_type;\n\tbool tx_pkt;\n\n\t__skb_queue_head_init(&list);\n\n\tspin_lock_bh(&port->backlog.lock);\n\tskb_queue_splice_tail_init(&port->backlog, &list);\n\tspin_unlock_bh(&port->backlog.lock);\n\n\twhile ((skb = __skb_dequeue(&list)) != NULL) {\n\t\tstruct net_device *dev = skb->dev;\n\t\tbool consumed = false;\n\n\t\tethh = eth_hdr(skb);\n\t\ttx_pkt = IPVL_SKB_CB(skb)->tx_pkt;\n\t\tmac_hash = ipvlan_mac_hash(ethh->h_dest);\n\n\t\tif (ether_addr_equal(ethh->h_dest, port->dev->broadcast))\n\t\t\tpkt_type = PACKET_BROADCAST;\n\t\telse\n\t\t\tpkt_type = PACKET_MULTICAST;\n\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(ipvlan, &port->ipvlans, pnode) {\n\t\t\tif (tx_pkt && (ipvlan->dev == skb->dev))\n\t\t\t\tcontinue;\n\t\t\tif (!test_bit(mac_hash, ipvlan->mac_filters))\n\t\t\t\tcontinue;\n\t\t\tif (!(ipvlan->dev->flags & IFF_UP))\n\t\t\t\tcontinue;\n\t\t\tret = NET_RX_DROP;\n\t\t\tlen = skb->len + ETH_HLEN;\n\t\t\tnskb = skb_clone(skb, GFP_ATOMIC);\n\t\t\tlocal_bh_disable();\n\t\t\tif (nskb) {\n\t\t\t\tconsumed = true;\n\t\t\t\tnskb->pkt_type = pkt_type;\n\t\t\t\tnskb->dev = ipvlan->dev;\n\t\t\t\tif (tx_pkt)\n\t\t\t\t\tret = dev_forward_skb(ipvlan->dev, nskb);\n\t\t\t\telse\n\t\t\t\t\tret = netif_rx(nskb);\n\t\t\t}\n\t\t\tipvlan_count_rx(ipvlan, len, ret == NET_RX_SUCCESS, true);\n\t\t\tlocal_bh_enable();\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (tx_pkt) {\n\t\t\t \n\t\t\tskb->dev = port->dev;\n\t\t\tskb->pkt_type = pkt_type;\n\t\t\tdev_queue_xmit(skb);\n\t\t} else {\n\t\t\tif (consumed)\n\t\t\t\tconsume_skb(skb);\n\t\t\telse\n\t\t\t\tkfree_skb(skb);\n\t\t}\n\t\tdev_put(dev);\n\t\tcond_resched();\n\t}\n}\n\nstatic void ipvlan_skb_crossing_ns(struct sk_buff *skb, struct net_device *dev)\n{\n\tbool xnet = true;\n\n\tif (dev)\n\t\txnet = !net_eq(dev_net(skb->dev), dev_net(dev));\n\n\tskb_scrub_packet(skb, xnet);\n\tif (dev)\n\t\tskb->dev = dev;\n}\n\nstatic int ipvlan_rcv_frame(struct ipvl_addr *addr, struct sk_buff **pskb,\n\t\t\t    bool local)\n{\n\tstruct ipvl_dev *ipvlan = addr->master;\n\tstruct net_device *dev = ipvlan->dev;\n\tunsigned int len;\n\trx_handler_result_t ret = RX_HANDLER_CONSUMED;\n\tbool success = false;\n\tstruct sk_buff *skb = *pskb;\n\n\tlen = skb->len + ETH_HLEN;\n\t \n\tif (local) {\n\t\tif (unlikely(!(dev->flags & IFF_UP))) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out;\n\t\t}\n\n\t\tskb = skb_share_check(skb, GFP_ATOMIC);\n\t\tif (!skb)\n\t\t\tgoto out;\n\n\t\t*pskb = skb;\n\t}\n\n\tif (local) {\n\t\tskb->pkt_type = PACKET_HOST;\n\t\tif (dev_forward_skb(ipvlan->dev, skb) == NET_RX_SUCCESS)\n\t\t\tsuccess = true;\n\t} else {\n\t\tskb->dev = dev;\n\t\tret = RX_HANDLER_ANOTHER;\n\t\tsuccess = true;\n\t}\n\nout:\n\tipvlan_count_rx(ipvlan, len, success, false);\n\treturn ret;\n}\n\nstruct ipvl_addr *ipvlan_addr_lookup(struct ipvl_port *port, void *lyr3h,\n\t\t\t\t     int addr_type, bool use_dest)\n{\n\tstruct ipvl_addr *addr = NULL;\n\n\tswitch (addr_type) {\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase IPVL_IPV6: {\n\t\tstruct ipv6hdr *ip6h;\n\t\tstruct in6_addr *i6addr;\n\n\t\tip6h = (struct ipv6hdr *)lyr3h;\n\t\ti6addr = use_dest ? &ip6h->daddr : &ip6h->saddr;\n\t\taddr = ipvlan_ht_addr_lookup(port, i6addr, true);\n\t\tbreak;\n\t}\n\tcase IPVL_ICMPV6: {\n\t\tstruct nd_msg *ndmh;\n\t\tstruct in6_addr *i6addr;\n\n\t\t \n\t\tndmh = (struct nd_msg *)lyr3h;\n\t\tif (ndmh->icmph.icmp6_type == NDISC_NEIGHBOUR_SOLICITATION) {\n\t\t\ti6addr = &ndmh->target;\n\t\t\taddr = ipvlan_ht_addr_lookup(port, i6addr, true);\n\t\t}\n\t\tbreak;\n\t}\n#endif\n\tcase IPVL_IPV4: {\n\t\tstruct iphdr *ip4h;\n\t\t__be32 *i4addr;\n\n\t\tip4h = (struct iphdr *)lyr3h;\n\t\ti4addr = use_dest ? &ip4h->daddr : &ip4h->saddr;\n\t\taddr = ipvlan_ht_addr_lookup(port, i4addr, false);\n\t\tbreak;\n\t}\n\tcase IPVL_ARP: {\n\t\tstruct arphdr *arph;\n\t\tunsigned char *arp_ptr;\n\t\t__be32 dip;\n\n\t\tarph = (struct arphdr *)lyr3h;\n\t\tarp_ptr = (unsigned char *)(arph + 1);\n\t\tif (use_dest)\n\t\t\tarp_ptr += (2 * port->dev->addr_len) + 4;\n\t\telse\n\t\t\tarp_ptr += port->dev->addr_len;\n\n\t\tmemcpy(&dip, arp_ptr, 4);\n\t\taddr = ipvlan_ht_addr_lookup(port, &dip, false);\n\t\tbreak;\n\t}\n\t}\n\n\treturn addr;\n}\n\nstatic noinline_for_stack int ipvlan_process_v4_outbound(struct sk_buff *skb)\n{\n\tconst struct iphdr *ip4h = ip_hdr(skb);\n\tstruct net_device *dev = skb->dev;\n\tstruct net *net = dev_net(dev);\n\tstruct rtable *rt;\n\tint err, ret = NET_XMIT_DROP;\n\tstruct flowi4 fl4 = {\n\t\t.flowi4_oif = dev->ifindex,\n\t\t.flowi4_tos = RT_TOS(ip4h->tos),\n\t\t.flowi4_flags = FLOWI_FLAG_ANYSRC,\n\t\t.flowi4_mark = skb->mark,\n\t\t.daddr = ip4h->daddr,\n\t\t.saddr = ip4h->saddr,\n\t};\n\n\trt = ip_route_output_flow(net, &fl4, NULL);\n\tif (IS_ERR(rt))\n\t\tgoto err;\n\n\tif (rt->rt_type != RTN_UNICAST && rt->rt_type != RTN_LOCAL) {\n\t\tip_rt_put(rt);\n\t\tgoto err;\n\t}\n\tskb_dst_set(skb, &rt->dst);\n\n\tmemset(IPCB(skb), 0, sizeof(*IPCB(skb)));\n\n\terr = ip_local_out(net, skb->sk, skb);\n\tif (unlikely(net_xmit_eval(err)))\n\t\tDEV_STATS_INC(dev, tx_errors);\n\telse\n\t\tret = NET_XMIT_SUCCESS;\n\tgoto out;\nerr:\n\tDEV_STATS_INC(dev, tx_errors);\n\tkfree_skb(skb);\nout:\n\treturn ret;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\n\nstatic noinline_for_stack int\nipvlan_route_v6_outbound(struct net_device *dev, struct sk_buff *skb)\n{\n\tconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\n\tstruct flowi6 fl6 = {\n\t\t.flowi6_oif = dev->ifindex,\n\t\t.daddr = ip6h->daddr,\n\t\t.saddr = ip6h->saddr,\n\t\t.flowi6_flags = FLOWI_FLAG_ANYSRC,\n\t\t.flowlabel = ip6_flowinfo(ip6h),\n\t\t.flowi6_mark = skb->mark,\n\t\t.flowi6_proto = ip6h->nexthdr,\n\t};\n\tstruct dst_entry *dst;\n\tint err;\n\n\tdst = ip6_route_output(dev_net(dev), NULL, &fl6);\n\terr = dst->error;\n\tif (err) {\n\t\tdst_release(dst);\n\t\treturn err;\n\t}\n\tskb_dst_set(skb, dst);\n\treturn 0;\n}\n\nstatic int ipvlan_process_v6_outbound(struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev;\n\tint err, ret = NET_XMIT_DROP;\n\n\terr = ipvlan_route_v6_outbound(dev, skb);\n\tif (unlikely(err)) {\n\t\tDEV_STATS_INC(dev, tx_errors);\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\tmemset(IP6CB(skb), 0, sizeof(*IP6CB(skb)));\n\n\terr = ip6_local_out(dev_net(dev), skb->sk, skb);\n\tif (unlikely(net_xmit_eval(err)))\n\t\tDEV_STATS_INC(dev, tx_errors);\n\telse\n\t\tret = NET_XMIT_SUCCESS;\n\treturn ret;\n}\n#else\nstatic int ipvlan_process_v6_outbound(struct sk_buff *skb)\n{\n\treturn NET_XMIT_DROP;\n}\n#endif\n\nstatic int ipvlan_process_outbound(struct sk_buff *skb)\n{\n\tint ret = NET_XMIT_DROP;\n\n\t \n\tif (skb_mac_header_was_set(skb)) {\n\t\t \n\t\tstruct ethhdr *ethh = eth_hdr(skb);\n\n\t\tif (is_multicast_ether_addr(ethh->h_dest)) {\n\t\t\tpr_debug_ratelimited(\n\t\t\t\t\"Dropped {multi|broad}cast of type=[%x]\\n\",\n\t\t\t\tntohs(skb->protocol));\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out;\n\t\t}\n\n\t\tskb_pull(skb, sizeof(*ethh));\n\t\tskb->mac_header = (typeof(skb->mac_header))~0U;\n\t\tskb_reset_network_header(skb);\n\t}\n\n\tif (skb->protocol == htons(ETH_P_IPV6))\n\t\tret = ipvlan_process_v6_outbound(skb);\n\telse if (skb->protocol == htons(ETH_P_IP))\n\t\tret = ipvlan_process_v4_outbound(skb);\n\telse {\n\t\tpr_warn_ratelimited(\"Dropped outbound packet type=%x\\n\",\n\t\t\t\t    ntohs(skb->protocol));\n\t\tkfree_skb(skb);\n\t}\nout:\n\treturn ret;\n}\n\nstatic void ipvlan_multicast_enqueue(struct ipvl_port *port,\n\t\t\t\t     struct sk_buff *skb, bool tx_pkt)\n{\n\tif (skb->protocol == htons(ETH_P_PAUSE)) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\t \n\tIPVL_SKB_CB(skb)->tx_pkt = tx_pkt;\n\n\tspin_lock(&port->backlog.lock);\n\tif (skb_queue_len(&port->backlog) < IPVLAN_QBACKLOG_LIMIT) {\n\t\tdev_hold(skb->dev);\n\t\t__skb_queue_tail(&port->backlog, skb);\n\t\tspin_unlock(&port->backlog.lock);\n\t\tschedule_work(&port->wq);\n\t} else {\n\t\tspin_unlock(&port->backlog.lock);\n\t\tdev_core_stats_rx_dropped_inc(skb->dev);\n\t\tkfree_skb(skb);\n\t}\n}\n\nstatic int ipvlan_xmit_mode_l3(struct sk_buff *skb, struct net_device *dev)\n{\n\tconst struct ipvl_dev *ipvlan = netdev_priv(dev);\n\tvoid *lyr3h;\n\tstruct ipvl_addr *addr;\n\tint addr_type;\n\n\tlyr3h = ipvlan_get_L3_hdr(ipvlan->port, skb, &addr_type);\n\tif (!lyr3h)\n\t\tgoto out;\n\n\tif (!ipvlan_is_vepa(ipvlan->port)) {\n\t\taddr = ipvlan_addr_lookup(ipvlan->port, lyr3h, addr_type, true);\n\t\tif (addr) {\n\t\t\tif (ipvlan_is_private(ipvlan->port)) {\n\t\t\t\tconsume_skb(skb);\n\t\t\t\treturn NET_XMIT_DROP;\n\t\t\t}\n\t\t\tipvlan_rcv_frame(addr, &skb, true);\n\t\t\treturn NET_XMIT_SUCCESS;\n\t\t}\n\t}\nout:\n\tipvlan_skb_crossing_ns(skb, ipvlan->phy_dev);\n\treturn ipvlan_process_outbound(skb);\n}\n\nstatic int ipvlan_xmit_mode_l2(struct sk_buff *skb, struct net_device *dev)\n{\n\tconst struct ipvl_dev *ipvlan = netdev_priv(dev);\n\tstruct ethhdr *eth = skb_eth_hdr(skb);\n\tstruct ipvl_addr *addr;\n\tvoid *lyr3h;\n\tint addr_type;\n\n\tif (!ipvlan_is_vepa(ipvlan->port) &&\n\t    ether_addr_equal(eth->h_dest, eth->h_source)) {\n\t\tlyr3h = ipvlan_get_L3_hdr(ipvlan->port, skb, &addr_type);\n\t\tif (lyr3h) {\n\t\t\taddr = ipvlan_addr_lookup(ipvlan->port, lyr3h, addr_type, true);\n\t\t\tif (addr) {\n\t\t\t\tif (ipvlan_is_private(ipvlan->port)) {\n\t\t\t\t\tconsume_skb(skb);\n\t\t\t\t\treturn NET_XMIT_DROP;\n\t\t\t\t}\n\t\t\t\tipvlan_rcv_frame(addr, &skb, true);\n\t\t\t\treturn NET_XMIT_SUCCESS;\n\t\t\t}\n\t\t}\n\t\tskb = skb_share_check(skb, GFP_ATOMIC);\n\t\tif (!skb)\n\t\t\treturn NET_XMIT_DROP;\n\n\t\t \n\t\tdev_forward_skb(ipvlan->phy_dev, skb);\n\t\treturn NET_XMIT_SUCCESS;\n\n\t} else if (is_multicast_ether_addr(eth->h_dest)) {\n\t\tskb_reset_mac_header(skb);\n\t\tipvlan_skb_crossing_ns(skb, NULL);\n\t\tipvlan_multicast_enqueue(ipvlan->port, skb, true);\n\t\treturn NET_XMIT_SUCCESS;\n\t}\n\n\tskb->dev = ipvlan->phy_dev;\n\treturn dev_queue_xmit(skb);\n}\n\nint ipvlan_queue_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ipvl_dev *ipvlan = netdev_priv(dev);\n\tstruct ipvl_port *port = ipvlan_port_get_rcu_bh(ipvlan->phy_dev);\n\n\tif (!port)\n\t\tgoto out;\n\n\tif (unlikely(!pskb_may_pull(skb, sizeof(struct ethhdr))))\n\t\tgoto out;\n\n\tswitch(port->mode) {\n\tcase IPVLAN_MODE_L2:\n\t\treturn ipvlan_xmit_mode_l2(skb, dev);\n\tcase IPVLAN_MODE_L3:\n#ifdef CONFIG_IPVLAN_L3S\n\tcase IPVLAN_MODE_L3S:\n#endif\n\t\treturn ipvlan_xmit_mode_l3(skb, dev);\n\t}\n\n\t \n\tWARN_ONCE(true, \"%s called for mode = [%x]\\n\", __func__, port->mode);\nout:\n\tkfree_skb(skb);\n\treturn NET_XMIT_DROP;\n}\n\nstatic bool ipvlan_external_frame(struct sk_buff *skb, struct ipvl_port *port)\n{\n\tstruct ethhdr *eth = eth_hdr(skb);\n\tstruct ipvl_addr *addr;\n\tvoid *lyr3h;\n\tint addr_type;\n\n\tif (ether_addr_equal(eth->h_source, skb->dev->dev_addr)) {\n\t\tlyr3h = ipvlan_get_L3_hdr(port, skb, &addr_type);\n\t\tif (!lyr3h)\n\t\t\treturn true;\n\n\t\taddr = ipvlan_addr_lookup(port, lyr3h, addr_type, false);\n\t\tif (addr)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic rx_handler_result_t ipvlan_handle_mode_l3(struct sk_buff **pskb,\n\t\t\t\t\t\t struct ipvl_port *port)\n{\n\tvoid *lyr3h;\n\tint addr_type;\n\tstruct ipvl_addr *addr;\n\tstruct sk_buff *skb = *pskb;\n\trx_handler_result_t ret = RX_HANDLER_PASS;\n\n\tlyr3h = ipvlan_get_L3_hdr(port, skb, &addr_type);\n\tif (!lyr3h)\n\t\tgoto out;\n\n\taddr = ipvlan_addr_lookup(port, lyr3h, addr_type, true);\n\tif (addr)\n\t\tret = ipvlan_rcv_frame(addr, pskb, false);\n\nout:\n\treturn ret;\n}\n\nstatic rx_handler_result_t ipvlan_handle_mode_l2(struct sk_buff **pskb,\n\t\t\t\t\t\t struct ipvl_port *port)\n{\n\tstruct sk_buff *skb = *pskb;\n\tstruct ethhdr *eth = eth_hdr(skb);\n\trx_handler_result_t ret = RX_HANDLER_PASS;\n\n\tif (is_multicast_ether_addr(eth->h_dest)) {\n\t\tif (ipvlan_external_frame(skb, port)) {\n\t\t\tstruct sk_buff *nskb = skb_clone(skb, GFP_ATOMIC);\n\n\t\t\t \n\t\t\tif (nskb) {\n\t\t\t\tipvlan_skb_crossing_ns(nskb, NULL);\n\t\t\t\tipvlan_multicast_enqueue(port, nskb, false);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tret = ipvlan_handle_mode_l3(pskb, port);\n\t}\n\n\treturn ret;\n}\n\nrx_handler_result_t ipvlan_handle_frame(struct sk_buff **pskb)\n{\n\tstruct sk_buff *skb = *pskb;\n\tstruct ipvl_port *port = ipvlan_port_get_rcu(skb->dev);\n\n\tif (!port)\n\t\treturn RX_HANDLER_PASS;\n\n\tswitch (port->mode) {\n\tcase IPVLAN_MODE_L2:\n\t\treturn ipvlan_handle_mode_l2(pskb, port);\n\tcase IPVLAN_MODE_L3:\n\t\treturn ipvlan_handle_mode_l3(pskb, port);\n#ifdef CONFIG_IPVLAN_L3S\n\tcase IPVLAN_MODE_L3S:\n\t\treturn RX_HANDLER_PASS;\n#endif\n\t}\n\n\t \n\tWARN_ONCE(true, \"%s called for mode = [%x]\\n\", __func__, port->mode);\n\tkfree_skb(skb);\n\treturn RX_HANDLER_CONSUMED;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}