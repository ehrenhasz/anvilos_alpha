{
  "module_name": "ipvlan_l3s.c",
  "hash_id": "a3a623907c098e52758c6ba926d618eadc8b5baed2290d1864a0e5c5c608a521",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ipvlan/ipvlan_l3s.c",
  "human_readable_source": "\n \n\n#include \"ipvlan.h\"\n\nstatic unsigned int ipvlan_netid __read_mostly;\n\nstruct ipvlan_netns {\n\tunsigned int ipvl_nf_hook_refcnt;\n};\n\nstatic struct ipvl_addr *ipvlan_skb_to_addr(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *dev)\n{\n\tstruct ipvl_addr *addr = NULL;\n\tstruct ipvl_port *port;\n\tint addr_type;\n\tvoid *lyr3h;\n\n\tif (!dev || !netif_is_ipvlan_port(dev))\n\t\tgoto out;\n\n\tport = ipvlan_port_get_rcu(dev);\n\tif (!port || port->mode != IPVLAN_MODE_L3S)\n\t\tgoto out;\n\n\tlyr3h = ipvlan_get_L3_hdr(port, skb, &addr_type);\n\tif (!lyr3h)\n\t\tgoto out;\n\n\taddr = ipvlan_addr_lookup(port, lyr3h, addr_type, true);\nout:\n\treturn addr;\n}\n\nstatic struct sk_buff *ipvlan_l3_rcv(struct net_device *dev,\n\t\t\t\t     struct sk_buff *skb, u16 proto)\n{\n\tstruct ipvl_addr *addr;\n\tstruct net_device *sdev;\n\n\taddr = ipvlan_skb_to_addr(skb, dev);\n\tif (!addr)\n\t\tgoto out;\n\n\tsdev = addr->master->dev;\n\tswitch (proto) {\n\tcase AF_INET:\n\t{\n\t\tstruct iphdr *ip4h = ip_hdr(skb);\n\t\tint err;\n\n\t\terr = ip_route_input_noref(skb, ip4h->daddr, ip4h->saddr,\n\t\t\t\t\t   ip4h->tos, sdev);\n\t\tif (unlikely(err))\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t{\n\t\tstruct dst_entry *dst;\n\t\tstruct ipv6hdr *ip6h = ipv6_hdr(skb);\n\t\tint flags = RT6_LOOKUP_F_HAS_SADDR;\n\t\tstruct flowi6 fl6 = {\n\t\t\t.flowi6_iif   = sdev->ifindex,\n\t\t\t.daddr        = ip6h->daddr,\n\t\t\t.saddr        = ip6h->saddr,\n\t\t\t.flowlabel    = ip6_flowinfo(ip6h),\n\t\t\t.flowi6_mark  = skb->mark,\n\t\t\t.flowi6_proto = ip6h->nexthdr,\n\t\t};\n\n\t\tskb_dst_drop(skb);\n\t\tdst = ip6_route_input_lookup(dev_net(sdev), sdev, &fl6,\n\t\t\t\t\t     skb, flags);\n\t\tskb_dst_set(skb, dst);\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tbreak;\n\t}\nout:\n\treturn skb;\n}\n\nstatic const struct l3mdev_ops ipvl_l3mdev_ops = {\n\t.l3mdev_l3_rcv = ipvlan_l3_rcv,\n};\n\nstatic unsigned int ipvlan_nf_input(void *priv, struct sk_buff *skb,\n\t\t\t\t    const struct nf_hook_state *state)\n{\n\tstruct ipvl_addr *addr;\n\tunsigned int len;\n\n\taddr = ipvlan_skb_to_addr(skb, skb->dev);\n\tif (!addr)\n\t\tgoto out;\n\n\tskb->dev = addr->master->dev;\n\tskb->skb_iif = skb->dev->ifindex;\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (addr->atype == IPVL_IPV6)\n\t\tIP6CB(skb)->iif = skb->dev->ifindex;\n#endif\n\tlen = skb->len + ETH_HLEN;\n\tipvlan_count_rx(addr->master, len, true, false);\nout:\n\treturn NF_ACCEPT;\n}\n\nstatic const struct nf_hook_ops ipvl_nfops[] = {\n\t{\n\t\t.hook     = ipvlan_nf_input,\n\t\t.pf       = NFPROTO_IPV4,\n\t\t.hooknum  = NF_INET_LOCAL_IN,\n\t\t.priority = INT_MAX,\n\t},\n#if IS_ENABLED(CONFIG_IPV6)\n\t{\n\t\t.hook     = ipvlan_nf_input,\n\t\t.pf       = NFPROTO_IPV6,\n\t\t.hooknum  = NF_INET_LOCAL_IN,\n\t\t.priority = INT_MAX,\n\t},\n#endif\n};\n\nstatic int ipvlan_register_nf_hook(struct net *net)\n{\n\tstruct ipvlan_netns *vnet = net_generic(net, ipvlan_netid);\n\tint err = 0;\n\n\tif (!vnet->ipvl_nf_hook_refcnt) {\n\t\terr = nf_register_net_hooks(net, ipvl_nfops,\n\t\t\t\t\t    ARRAY_SIZE(ipvl_nfops));\n\t\tif (!err)\n\t\t\tvnet->ipvl_nf_hook_refcnt = 1;\n\t} else {\n\t\tvnet->ipvl_nf_hook_refcnt++;\n\t}\n\n\treturn err;\n}\n\nstatic void ipvlan_unregister_nf_hook(struct net *net)\n{\n\tstruct ipvlan_netns *vnet = net_generic(net, ipvlan_netid);\n\n\tif (WARN_ON(!vnet->ipvl_nf_hook_refcnt))\n\t\treturn;\n\n\tvnet->ipvl_nf_hook_refcnt--;\n\tif (!vnet->ipvl_nf_hook_refcnt)\n\t\tnf_unregister_net_hooks(net, ipvl_nfops,\n\t\t\t\t\tARRAY_SIZE(ipvl_nfops));\n}\n\nvoid ipvlan_migrate_l3s_hook(struct net *oldnet, struct net *newnet)\n{\n\tstruct ipvlan_netns *old_vnet;\n\n\tASSERT_RTNL();\n\n\told_vnet = net_generic(oldnet, ipvlan_netid);\n\tif (!old_vnet->ipvl_nf_hook_refcnt)\n\t\treturn;\n\n\tipvlan_register_nf_hook(newnet);\n\tipvlan_unregister_nf_hook(oldnet);\n}\n\nstatic void ipvlan_ns_exit(struct net *net)\n{\n\tstruct ipvlan_netns *vnet = net_generic(net, ipvlan_netid);\n\n\tif (WARN_ON_ONCE(vnet->ipvl_nf_hook_refcnt)) {\n\t\tvnet->ipvl_nf_hook_refcnt = 0;\n\t\tnf_unregister_net_hooks(net, ipvl_nfops,\n\t\t\t\t\tARRAY_SIZE(ipvl_nfops));\n\t}\n}\n\nstatic struct pernet_operations ipvlan_net_ops = {\n\t.id   = &ipvlan_netid,\n\t.size = sizeof(struct ipvlan_netns),\n\t.exit = ipvlan_ns_exit,\n};\n\nint ipvlan_l3s_init(void)\n{\n\treturn register_pernet_subsys(&ipvlan_net_ops);\n}\n\nvoid ipvlan_l3s_cleanup(void)\n{\n\tunregister_pernet_subsys(&ipvlan_net_ops);\n}\n\nint ipvlan_l3s_register(struct ipvl_port *port)\n{\n\tstruct net_device *dev = port->dev;\n\tint ret;\n\n\tASSERT_RTNL();\n\n\tret = ipvlan_register_nf_hook(read_pnet(&port->pnet));\n\tif (!ret) {\n\t\tdev->l3mdev_ops = &ipvl_l3mdev_ops;\n\t\tdev->priv_flags |= IFF_L3MDEV_RX_HANDLER;\n\t}\n\n\treturn ret;\n}\n\nvoid ipvlan_l3s_unregister(struct ipvl_port *port)\n{\n\tstruct net_device *dev = port->dev;\n\n\tASSERT_RTNL();\n\n\tdev->priv_flags &= ~IFF_L3MDEV_RX_HANDLER;\n\tipvlan_unregister_nf_hook(read_pnet(&port->pnet));\n\tdev->l3mdev_ops = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}