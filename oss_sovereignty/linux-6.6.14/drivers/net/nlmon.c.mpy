{
  "module_name": "nlmon.c",
  "hash_id": "b1b7283ab311dfa19a926f8effd7cc6c2e673d29bd028b89ad94d62e6c92689b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/nlmon.c",
  "human_readable_source": "\n#include <linux/ethtool.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/netlink.h>\n#include <net/net_namespace.h>\n#include <linux/if_arp.h>\n#include <net/rtnetlink.h>\n\nstatic netdev_tx_t nlmon_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tdev_lstats_add(dev, skb->len);\n\n\tdev_kfree_skb(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int nlmon_dev_init(struct net_device *dev)\n{\n\tdev->lstats = netdev_alloc_pcpu_stats(struct pcpu_lstats);\n\treturn dev->lstats == NULL ? -ENOMEM : 0;\n}\n\nstatic void nlmon_dev_uninit(struct net_device *dev)\n{\n\tfree_percpu(dev->lstats);\n}\n\nstruct nlmon {\n\tstruct netlink_tap nt;\n};\n\nstatic int nlmon_open(struct net_device *dev)\n{\n\tstruct nlmon *nlmon = netdev_priv(dev);\n\n\tnlmon->nt.dev = dev;\n\tnlmon->nt.module = THIS_MODULE;\n\treturn netlink_add_tap(&nlmon->nt);\n}\n\nstatic int nlmon_close(struct net_device *dev)\n{\n\tstruct nlmon *nlmon = netdev_priv(dev);\n\n\treturn netlink_remove_tap(&nlmon->nt);\n}\n\nstatic void\nnlmon_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)\n{\n\tu64 packets, bytes;\n\n\tdev_lstats_read(dev, &packets, &bytes);\n\n\tstats->rx_packets = packets;\n\tstats->tx_packets = 0;\n\n\tstats->rx_bytes = bytes;\n\tstats->tx_bytes = 0;\n}\n\nstatic u32 always_on(struct net_device *dev)\n{\n\treturn 1;\n}\n\nstatic const struct ethtool_ops nlmon_ethtool_ops = {\n\t.get_link = always_on,\n};\n\nstatic const struct net_device_ops nlmon_ops = {\n\t.ndo_init = nlmon_dev_init,\n\t.ndo_uninit = nlmon_dev_uninit,\n\t.ndo_open = nlmon_open,\n\t.ndo_stop = nlmon_close,\n\t.ndo_start_xmit = nlmon_xmit,\n\t.ndo_get_stats64 = nlmon_get_stats64,\n};\n\nstatic void nlmon_setup(struct net_device *dev)\n{\n\tdev->type = ARPHRD_NETLINK;\n\tdev->priv_flags |= IFF_NO_QUEUE;\n\n\tdev->netdev_ops\t= &nlmon_ops;\n\tdev->ethtool_ops = &nlmon_ethtool_ops;\n\tdev->needs_free_netdev = true;\n\n\tdev->features = NETIF_F_SG | NETIF_F_FRAGLIST |\n\t\t\tNETIF_F_HIGHDMA | NETIF_F_LLTX;\n\tdev->flags = IFF_NOARP;\n\n\t \n\tdev->mtu = NLMSG_GOODSIZE;\n\tdev->min_mtu = sizeof(struct nlmsghdr);\n}\n\nstatic int nlmon_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tif (tb[IFLA_ADDRESS])\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic struct rtnl_link_ops nlmon_link_ops __read_mostly = {\n\t.kind\t\t\t= \"nlmon\",\n\t.priv_size\t\t= sizeof(struct nlmon),\n\t.setup\t\t\t= nlmon_setup,\n\t.validate\t\t= nlmon_validate,\n};\n\nstatic __init int nlmon_register(void)\n{\n\treturn rtnl_link_register(&nlmon_link_ops);\n}\n\nstatic __exit void nlmon_unregister(void)\n{\n\trtnl_link_unregister(&nlmon_link_ops);\n}\n\nmodule_init(nlmon_register);\nmodule_exit(nlmon_unregister);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Daniel Borkmann <dborkman@redhat.com>\");\nMODULE_AUTHOR(\"Mathieu Geli <geli@enseirb.fr>\");\nMODULE_DESCRIPTION(\"Netlink monitoring device\");\nMODULE_ALIAS_RTNL_LINK(\"nlmon\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}