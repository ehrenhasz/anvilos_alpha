{
  "module_name": "amt.c",
  "hash_id": "ba145974a85368ea90bab0660681ba5b192c603dff74481305139a2edf043c84",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/amt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/udp.h>\n#include <linux/jhash.h>\n#include <linux/if_tunnel.h>\n#include <linux/net.h>\n#include <linux/igmp.h>\n#include <linux/workqueue.h>\n#include <net/pkt_sched.h>\n#include <net/net_namespace.h>\n#include <net/ip.h>\n#include <net/udp.h>\n#include <net/udp_tunnel.h>\n#include <net/icmp.h>\n#include <net/mld.h>\n#include <net/amt.h>\n#include <uapi/linux/amt.h>\n#include <linux/security.h>\n#include <net/gro_cells.h>\n#include <net/ipv6.h>\n#include <net/if_inet6.h>\n#include <net/ndisc.h>\n#include <net/addrconf.h>\n#include <net/ip6_route.h>\n#include <net/inet_common.h>\n#include <net/ip6_checksum.h>\n\nstatic struct workqueue_struct *amt_wq;\n\nstatic HLIST_HEAD(source_gc_list);\n \nstatic spinlock_t source_gc_lock;\nstatic struct delayed_work source_gc_wq;\nstatic char *status_str[] = {\n\t\"AMT_STATUS_INIT\",\n\t\"AMT_STATUS_SENT_DISCOVERY\",\n\t\"AMT_STATUS_RECEIVED_DISCOVERY\",\n\t\"AMT_STATUS_SENT_ADVERTISEMENT\",\n\t\"AMT_STATUS_RECEIVED_ADVERTISEMENT\",\n\t\"AMT_STATUS_SENT_REQUEST\",\n\t\"AMT_STATUS_RECEIVED_REQUEST\",\n\t\"AMT_STATUS_SENT_QUERY\",\n\t\"AMT_STATUS_RECEIVED_QUERY\",\n\t\"AMT_STATUS_SENT_UPDATE\",\n\t\"AMT_STATUS_RECEIVED_UPDATE\",\n};\n\nstatic char *type_str[] = {\n\t\"\",  \n\t\"AMT_MSG_DISCOVERY\",\n\t\"AMT_MSG_ADVERTISEMENT\",\n\t\"AMT_MSG_REQUEST\",\n\t\"AMT_MSG_MEMBERSHIP_QUERY\",\n\t\"AMT_MSG_MEMBERSHIP_UPDATE\",\n\t\"AMT_MSG_MULTICAST_DATA\",\n\t\"AMT_MSG_TEARDOWN\",\n};\n\nstatic char *action_str[] = {\n\t\"AMT_ACT_GMI\",\n\t\"AMT_ACT_GMI_ZERO\",\n\t\"AMT_ACT_GT\",\n\t\"AMT_ACT_STATUS_FWD_NEW\",\n\t\"AMT_ACT_STATUS_D_FWD_NEW\",\n\t\"AMT_ACT_STATUS_NONE_NEW\",\n};\n\nstatic struct igmpv3_grec igmpv3_zero_grec;\n\n#if IS_ENABLED(CONFIG_IPV6)\n#define MLD2_ALL_NODE_INIT { { { 0xff, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01 } } }\nstatic struct in6_addr mld2_all_node = MLD2_ALL_NODE_INIT;\nstatic struct mld2_grec mldv2_zero_grec;\n#endif\n\nstatic struct amt_skb_cb *amt_skb_cb(struct sk_buff *skb)\n{\n\tBUILD_BUG_ON(sizeof(struct amt_skb_cb) + sizeof(struct tc_skb_cb) >\n\t\t     sizeof_field(struct sk_buff, cb));\n\n\treturn (struct amt_skb_cb *)((void *)skb->cb +\n\t\tsizeof(struct tc_skb_cb));\n}\n\nstatic void __amt_source_gc_work(void)\n{\n\tstruct amt_source_node *snode;\n\tstruct hlist_head gc_list;\n\tstruct hlist_node *t;\n\n\tspin_lock_bh(&source_gc_lock);\n\thlist_move_list(&source_gc_list, &gc_list);\n\tspin_unlock_bh(&source_gc_lock);\n\n\thlist_for_each_entry_safe(snode, t, &gc_list, node) {\n\t\thlist_del_rcu(&snode->node);\n\t\tkfree_rcu(snode, rcu);\n\t}\n}\n\nstatic void amt_source_gc_work(struct work_struct *work)\n{\n\t__amt_source_gc_work();\n\n\tspin_lock_bh(&source_gc_lock);\n\tmod_delayed_work(amt_wq, &source_gc_wq,\n\t\t\t msecs_to_jiffies(AMT_GC_INTERVAL));\n\tspin_unlock_bh(&source_gc_lock);\n}\n\nstatic bool amt_addr_equal(union amt_addr *a, union amt_addr *b)\n{\n\treturn !memcmp(a, b, sizeof(union amt_addr));\n}\n\nstatic u32 amt_source_hash(struct amt_tunnel_list *tunnel, union amt_addr *src)\n{\n\tu32 hash = jhash(src, sizeof(*src), tunnel->amt->hash_seed);\n\n\treturn reciprocal_scale(hash, tunnel->amt->hash_buckets);\n}\n\nstatic bool amt_status_filter(struct amt_source_node *snode,\n\t\t\t      enum amt_filter filter)\n{\n\tbool rc = false;\n\n\tswitch (filter) {\n\tcase AMT_FILTER_FWD:\n\t\tif (snode->status == AMT_SOURCE_STATUS_FWD &&\n\t\t    snode->flags == AMT_SOURCE_OLD)\n\t\t\trc = true;\n\t\tbreak;\n\tcase AMT_FILTER_D_FWD:\n\t\tif (snode->status == AMT_SOURCE_STATUS_D_FWD &&\n\t\t    snode->flags == AMT_SOURCE_OLD)\n\t\t\trc = true;\n\t\tbreak;\n\tcase AMT_FILTER_FWD_NEW:\n\t\tif (snode->status == AMT_SOURCE_STATUS_FWD &&\n\t\t    snode->flags == AMT_SOURCE_NEW)\n\t\t\trc = true;\n\t\tbreak;\n\tcase AMT_FILTER_D_FWD_NEW:\n\t\tif (snode->status == AMT_SOURCE_STATUS_D_FWD &&\n\t\t    snode->flags == AMT_SOURCE_NEW)\n\t\t\trc = true;\n\t\tbreak;\n\tcase AMT_FILTER_ALL:\n\t\trc = true;\n\t\tbreak;\n\tcase AMT_FILTER_NONE_NEW:\n\t\tif (snode->status == AMT_SOURCE_STATUS_NONE &&\n\t\t    snode->flags == AMT_SOURCE_NEW)\n\t\t\trc = true;\n\t\tbreak;\n\tcase AMT_FILTER_BOTH:\n\t\tif ((snode->status == AMT_SOURCE_STATUS_D_FWD ||\n\t\t     snode->status == AMT_SOURCE_STATUS_FWD) &&\n\t\t    snode->flags == AMT_SOURCE_OLD)\n\t\t\trc = true;\n\t\tbreak;\n\tcase AMT_FILTER_BOTH_NEW:\n\t\tif ((snode->status == AMT_SOURCE_STATUS_D_FWD ||\n\t\t     snode->status == AMT_SOURCE_STATUS_FWD) &&\n\t\t    snode->flags == AMT_SOURCE_NEW)\n\t\t\trc = true;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic struct amt_source_node *amt_lookup_src(struct amt_tunnel_list *tunnel,\n\t\t\t\t\t      struct amt_group_node *gnode,\n\t\t\t\t\t      enum amt_filter filter,\n\t\t\t\t\t      union amt_addr *src)\n{\n\tu32 hash = amt_source_hash(tunnel, src);\n\tstruct amt_source_node *snode;\n\n\thlist_for_each_entry_rcu(snode, &gnode->sources[hash], node)\n\t\tif (amt_status_filter(snode, filter) &&\n\t\t    amt_addr_equal(&snode->source_addr, src))\n\t\t\treturn snode;\n\n\treturn NULL;\n}\n\nstatic u32 amt_group_hash(struct amt_tunnel_list *tunnel, union amt_addr *group)\n{\n\tu32 hash = jhash(group, sizeof(*group), tunnel->amt->hash_seed);\n\n\treturn reciprocal_scale(hash, tunnel->amt->hash_buckets);\n}\n\nstatic struct amt_group_node *amt_lookup_group(struct amt_tunnel_list *tunnel,\n\t\t\t\t\t       union amt_addr *group,\n\t\t\t\t\t       union amt_addr *host,\n\t\t\t\t\t       bool v6)\n{\n\tu32 hash = amt_group_hash(tunnel, group);\n\tstruct amt_group_node *gnode;\n\n\thlist_for_each_entry_rcu(gnode, &tunnel->groups[hash], node) {\n\t\tif (amt_addr_equal(&gnode->group_addr, group) &&\n\t\t    amt_addr_equal(&gnode->host_addr, host) &&\n\t\t    gnode->v6 == v6)\n\t\t\treturn gnode;\n\t}\n\n\treturn NULL;\n}\n\nstatic void amt_destroy_source(struct amt_source_node *snode)\n{\n\tstruct amt_group_node *gnode = snode->gnode;\n\tstruct amt_tunnel_list *tunnel;\n\n\ttunnel = gnode->tunnel_list;\n\n\tif (!gnode->v6) {\n\t\tnetdev_dbg(snode->gnode->amt->dev,\n\t\t\t   \"Delete source %pI4 from %pI4\\n\",\n\t\t\t   &snode->source_addr.ip4,\n\t\t\t   &gnode->group_addr.ip4);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else {\n\t\tnetdev_dbg(snode->gnode->amt->dev,\n\t\t\t   \"Delete source %pI6 from %pI6\\n\",\n\t\t\t   &snode->source_addr.ip6,\n\t\t\t   &gnode->group_addr.ip6);\n#endif\n\t}\n\n\tcancel_delayed_work(&snode->source_timer);\n\thlist_del_init_rcu(&snode->node);\n\ttunnel->nr_sources--;\n\tgnode->nr_sources--;\n\tspin_lock_bh(&source_gc_lock);\n\thlist_add_head_rcu(&snode->node, &source_gc_list);\n\tspin_unlock_bh(&source_gc_lock);\n}\n\nstatic void amt_del_group(struct amt_dev *amt, struct amt_group_node *gnode)\n{\n\tstruct amt_source_node *snode;\n\tstruct hlist_node *t;\n\tint i;\n\n\tif (cancel_delayed_work(&gnode->group_timer))\n\t\tdev_put(amt->dev);\n\thlist_del_rcu(&gnode->node);\n\tgnode->tunnel_list->nr_groups--;\n\n\tif (!gnode->v6)\n\t\tnetdev_dbg(amt->dev, \"Leave group %pI4\\n\",\n\t\t\t   &gnode->group_addr.ip4);\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tnetdev_dbg(amt->dev, \"Leave group %pI6\\n\",\n\t\t\t   &gnode->group_addr.ip6);\n#endif\n\tfor (i = 0; i < amt->hash_buckets; i++)\n\t\thlist_for_each_entry_safe(snode, t, &gnode->sources[i], node)\n\t\t\tamt_destroy_source(snode);\n\n\t \n\tkfree_rcu(gnode, rcu);\n}\n\n \nstatic void amt_source_work(struct work_struct *work)\n{\n\tstruct amt_source_node *snode = container_of(to_delayed_work(work),\n\t\t\t\t\t\t     struct amt_source_node,\n\t\t\t\t\t\t     source_timer);\n\tstruct amt_group_node *gnode = snode->gnode;\n\tstruct amt_dev *amt = gnode->amt;\n\tstruct amt_tunnel_list *tunnel;\n\n\ttunnel = gnode->tunnel_list;\n\tspin_lock_bh(&tunnel->lock);\n\trcu_read_lock();\n\tif (gnode->filter_mode == MCAST_INCLUDE) {\n\t\tamt_destroy_source(snode);\n\t\tif (!gnode->nr_sources)\n\t\t\tamt_del_group(amt, gnode);\n\t} else {\n\t\t \n\t\tsnode->status = AMT_SOURCE_STATUS_D_FWD;\n\t}\n\trcu_read_unlock();\n\tspin_unlock_bh(&tunnel->lock);\n}\n\nstatic void amt_act_src(struct amt_tunnel_list *tunnel,\n\t\t\tstruct amt_group_node *gnode,\n\t\t\tstruct amt_source_node *snode,\n\t\t\tenum amt_act act)\n{\n\tstruct amt_dev *amt = tunnel->amt;\n\n\tswitch (act) {\n\tcase AMT_ACT_GMI:\n\t\tmod_delayed_work(amt_wq, &snode->source_timer,\n\t\t\t\t msecs_to_jiffies(amt_gmi(amt)));\n\t\tbreak;\n\tcase AMT_ACT_GMI_ZERO:\n\t\tcancel_delayed_work(&snode->source_timer);\n\t\tbreak;\n\tcase AMT_ACT_GT:\n\t\tmod_delayed_work(amt_wq, &snode->source_timer,\n\t\t\t\t gnode->group_timer.timer.expires);\n\t\tbreak;\n\tcase AMT_ACT_STATUS_FWD_NEW:\n\t\tsnode->status = AMT_SOURCE_STATUS_FWD;\n\t\tsnode->flags = AMT_SOURCE_NEW;\n\t\tbreak;\n\tcase AMT_ACT_STATUS_D_FWD_NEW:\n\t\tsnode->status = AMT_SOURCE_STATUS_D_FWD;\n\t\tsnode->flags = AMT_SOURCE_NEW;\n\t\tbreak;\n\tcase AMT_ACT_STATUS_NONE_NEW:\n\t\tcancel_delayed_work(&snode->source_timer);\n\t\tsnode->status = AMT_SOURCE_STATUS_NONE;\n\t\tsnode->flags = AMT_SOURCE_NEW;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\tif (!gnode->v6)\n\t\tnetdev_dbg(amt->dev, \"Source %pI4 from %pI4 Acted %s\\n\",\n\t\t\t   &snode->source_addr.ip4,\n\t\t\t   &gnode->group_addr.ip4,\n\t\t\t   action_str[act]);\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tnetdev_dbg(amt->dev, \"Source %pI6 from %pI6 Acted %s\\n\",\n\t\t\t   &snode->source_addr.ip6,\n\t\t\t   &gnode->group_addr.ip6,\n\t\t\t   action_str[act]);\n#endif\n}\n\nstatic struct amt_source_node *amt_alloc_snode(struct amt_group_node *gnode,\n\t\t\t\t\t       union amt_addr *src)\n{\n\tstruct amt_source_node *snode;\n\n\tsnode = kzalloc(sizeof(*snode), GFP_ATOMIC);\n\tif (!snode)\n\t\treturn NULL;\n\n\tmemcpy(&snode->source_addr, src, sizeof(union amt_addr));\n\tsnode->gnode = gnode;\n\tsnode->status = AMT_SOURCE_STATUS_NONE;\n\tsnode->flags = AMT_SOURCE_NEW;\n\tINIT_HLIST_NODE(&snode->node);\n\tINIT_DELAYED_WORK(&snode->source_timer, amt_source_work);\n\n\treturn snode;\n}\n\n \nstatic void amt_group_work(struct work_struct *work)\n{\n\tstruct amt_group_node *gnode = container_of(to_delayed_work(work),\n\t\t\t\t\t\t    struct amt_group_node,\n\t\t\t\t\t\t    group_timer);\n\tstruct amt_tunnel_list *tunnel = gnode->tunnel_list;\n\tstruct amt_dev *amt = gnode->amt;\n\tstruct amt_source_node *snode;\n\tbool delete_group = true;\n\tstruct hlist_node *t;\n\tint i, buckets;\n\n\tbuckets = amt->hash_buckets;\n\n\tspin_lock_bh(&tunnel->lock);\n\tif (gnode->filter_mode == MCAST_INCLUDE) {\n\t\t \n\t\tspin_unlock_bh(&tunnel->lock);\n\t\tgoto out;\n\t}\n\n\trcu_read_lock();\n\tfor (i = 0; i < buckets; i++) {\n\t\thlist_for_each_entry_safe(snode, t,\n\t\t\t\t\t  &gnode->sources[i], node) {\n\t\t\tif (!delayed_work_pending(&snode->source_timer) ||\n\t\t\t    snode->status == AMT_SOURCE_STATUS_D_FWD) {\n\t\t\t\tamt_destroy_source(snode);\n\t\t\t} else {\n\t\t\t\tdelete_group = false;\n\t\t\t\tsnode->status = AMT_SOURCE_STATUS_FWD;\n\t\t\t}\n\t\t}\n\t}\n\tif (delete_group)\n\t\tamt_del_group(amt, gnode);\n\telse\n\t\tgnode->filter_mode = MCAST_INCLUDE;\n\trcu_read_unlock();\n\tspin_unlock_bh(&tunnel->lock);\nout:\n\tdev_put(amt->dev);\n}\n\n \nstatic struct amt_group_node *amt_add_group(struct amt_dev *amt,\n\t\t\t\t\t    struct amt_tunnel_list *tunnel,\n\t\t\t\t\t    union amt_addr *group,\n\t\t\t\t\t    union amt_addr *host,\n\t\t\t\t\t    bool v6)\n{\n\tstruct amt_group_node *gnode;\n\tu32 hash;\n\tint i;\n\n\tif (tunnel->nr_groups >= amt->max_groups)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tgnode = kzalloc(sizeof(*gnode) +\n\t\t\t(sizeof(struct hlist_head) * amt->hash_buckets),\n\t\t\tGFP_ATOMIC);\n\tif (unlikely(!gnode))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tgnode->amt = amt;\n\tgnode->group_addr = *group;\n\tgnode->host_addr = *host;\n\tgnode->v6 = v6;\n\tgnode->tunnel_list = tunnel;\n\tgnode->filter_mode = MCAST_INCLUDE;\n\tINIT_HLIST_NODE(&gnode->node);\n\tINIT_DELAYED_WORK(&gnode->group_timer, amt_group_work);\n\tfor (i = 0; i < amt->hash_buckets; i++)\n\t\tINIT_HLIST_HEAD(&gnode->sources[i]);\n\n\thash = amt_group_hash(tunnel, group);\n\thlist_add_head_rcu(&gnode->node, &tunnel->groups[hash]);\n\ttunnel->nr_groups++;\n\n\tif (!gnode->v6)\n\t\tnetdev_dbg(amt->dev, \"Join group %pI4\\n\",\n\t\t\t   &gnode->group_addr.ip4);\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\tnetdev_dbg(amt->dev, \"Join group %pI6\\n\",\n\t\t\t   &gnode->group_addr.ip6);\n#endif\n\n\treturn gnode;\n}\n\nstatic struct sk_buff *amt_build_igmp_gq(struct amt_dev *amt)\n{\n\tu8 ra[AMT_IPHDR_OPTS] = { IPOPT_RA, 4, 0, 0 };\n\tint hlen = LL_RESERVED_SPACE(amt->dev);\n\tint tlen = amt->dev->needed_tailroom;\n\tstruct igmpv3_query *ihv3;\n\tvoid *csum_start = NULL;\n\t__sum16 *csum = NULL;\n\tstruct sk_buff *skb;\n\tstruct ethhdr *eth;\n\tstruct iphdr *iph;\n\tunsigned int len;\n\tint offset;\n\n\tlen = hlen + tlen + sizeof(*iph) + AMT_IPHDR_OPTS + sizeof(*ihv3);\n\tskb = netdev_alloc_skb_ip_align(amt->dev, len);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, hlen);\n\tskb_push(skb, sizeof(*eth));\n\tskb->protocol = htons(ETH_P_IP);\n\tskb_reset_mac_header(skb);\n\tskb->priority = TC_PRIO_CONTROL;\n\tskb_put(skb, sizeof(*iph));\n\tskb_put_data(skb, ra, sizeof(ra));\n\tskb_put(skb, sizeof(*ihv3));\n\tskb_pull(skb, sizeof(*eth));\n\tskb_reset_network_header(skb);\n\n\tiph\t\t= ip_hdr(skb);\n\tiph->version\t= 4;\n\tiph->ihl\t= (sizeof(struct iphdr) + AMT_IPHDR_OPTS) >> 2;\n\tiph->tos\t= AMT_TOS;\n\tiph->tot_len\t= htons(sizeof(*iph) + AMT_IPHDR_OPTS + sizeof(*ihv3));\n\tiph->frag_off\t= htons(IP_DF);\n\tiph->ttl\t= 1;\n\tiph->id\t\t= 0;\n\tiph->protocol\t= IPPROTO_IGMP;\n\tiph->daddr\t= htonl(INADDR_ALLHOSTS_GROUP);\n\tiph->saddr\t= htonl(INADDR_ANY);\n\tip_send_check(iph);\n\n\teth = eth_hdr(skb);\n\tether_addr_copy(eth->h_source, amt->dev->dev_addr);\n\tip_eth_mc_map(htonl(INADDR_ALLHOSTS_GROUP), eth->h_dest);\n\teth->h_proto = htons(ETH_P_IP);\n\n\tihv3\t\t= skb_pull(skb, sizeof(*iph) + AMT_IPHDR_OPTS);\n\tskb_reset_transport_header(skb);\n\tihv3->type\t= IGMP_HOST_MEMBERSHIP_QUERY;\n\tihv3->code\t= 1;\n\tihv3->group\t= 0;\n\tihv3->qqic\t= amt->qi;\n\tihv3->nsrcs\t= 0;\n\tihv3->resv\t= 0;\n\tihv3->suppress\t= false;\n\tihv3->qrv\t= READ_ONCE(amt->net->ipv4.sysctl_igmp_qrv);\n\tihv3->csum\t= 0;\n\tcsum\t\t= &ihv3->csum;\n\tcsum_start\t= (void *)ihv3;\n\t*csum\t\t= ip_compute_csum(csum_start, sizeof(*ihv3));\n\toffset\t\t= skb_transport_offset(skb);\n\tskb->csum\t= skb_checksum(skb, offset, skb->len - offset, 0);\n\tskb->ip_summed\t= CHECKSUM_NONE;\n\n\tskb_push(skb, sizeof(*eth) + sizeof(*iph) + AMT_IPHDR_OPTS);\n\n\treturn skb;\n}\n\nstatic void amt_update_gw_status(struct amt_dev *amt, enum amt_status status,\n\t\t\t\t bool validate)\n{\n\tif (validate && amt->status >= status)\n\t\treturn;\n\tnetdev_dbg(amt->dev, \"Update GW status %s -> %s\",\n\t\t   status_str[amt->status], status_str[status]);\n\tWRITE_ONCE(amt->status, status);\n}\n\nstatic void __amt_update_relay_status(struct amt_tunnel_list *tunnel,\n\t\t\t\t      enum amt_status status,\n\t\t\t\t      bool validate)\n{\n\tif (validate && tunnel->status >= status)\n\t\treturn;\n\tnetdev_dbg(tunnel->amt->dev,\n\t\t   \"Update Tunnel(IP = %pI4, PORT = %u) status %s -> %s\",\n\t\t   &tunnel->ip4, ntohs(tunnel->source_port),\n\t\t   status_str[tunnel->status], status_str[status]);\n\ttunnel->status = status;\n}\n\nstatic void amt_update_relay_status(struct amt_tunnel_list *tunnel,\n\t\t\t\t    enum amt_status status, bool validate)\n{\n\tspin_lock_bh(&tunnel->lock);\n\t__amt_update_relay_status(tunnel, status, validate);\n\tspin_unlock_bh(&tunnel->lock);\n}\n\nstatic void amt_send_discovery(struct amt_dev *amt)\n{\n\tstruct amt_header_discovery *amtd;\n\tint hlen, tlen, offset;\n\tstruct socket *sock;\n\tstruct udphdr *udph;\n\tstruct sk_buff *skb;\n\tstruct iphdr *iph;\n\tstruct rtable *rt;\n\tstruct flowi4 fl4;\n\tu32 len;\n\tint err;\n\n\trcu_read_lock();\n\tsock = rcu_dereference(amt->sock);\n\tif (!sock)\n\t\tgoto out;\n\n\tif (!netif_running(amt->stream_dev) || !netif_running(amt->dev))\n\t\tgoto out;\n\n\trt = ip_route_output_ports(amt->net, &fl4, sock->sk,\n\t\t\t\t   amt->discovery_ip, amt->local_ip,\n\t\t\t\t   amt->gw_port, amt->relay_port,\n\t\t\t\t   IPPROTO_UDP, 0,\n\t\t\t\t   amt->stream_dev->ifindex);\n\tif (IS_ERR(rt)) {\n\t\tamt->dev->stats.tx_errors++;\n\t\tgoto out;\n\t}\n\n\thlen = LL_RESERVED_SPACE(amt->dev);\n\ttlen = amt->dev->needed_tailroom;\n\tlen = hlen + tlen + sizeof(*iph) + sizeof(*udph) + sizeof(*amtd);\n\tskb = netdev_alloc_skb_ip_align(amt->dev, len);\n\tif (!skb) {\n\t\tip_rt_put(rt);\n\t\tamt->dev->stats.tx_errors++;\n\t\tgoto out;\n\t}\n\n\tskb->priority = TC_PRIO_CONTROL;\n\tskb_dst_set(skb, &rt->dst);\n\n\tlen = sizeof(*iph) + sizeof(*udph) + sizeof(*amtd);\n\tskb_reset_network_header(skb);\n\tskb_put(skb, len);\n\tamtd = skb_pull(skb, sizeof(*iph) + sizeof(*udph));\n\tamtd->version\t= 0;\n\tamtd->type\t= AMT_MSG_DISCOVERY;\n\tamtd->reserved\t= 0;\n\tamtd->nonce\t= amt->nonce;\n\tskb_push(skb, sizeof(*udph));\n\tskb_reset_transport_header(skb);\n\tudph\t\t= udp_hdr(skb);\n\tudph->source\t= amt->gw_port;\n\tudph->dest\t= amt->relay_port;\n\tudph->len\t= htons(sizeof(*udph) + sizeof(*amtd));\n\tudph->check\t= 0;\n\toffset = skb_transport_offset(skb);\n\tskb->csum = skb_checksum(skb, offset, skb->len - offset, 0);\n\tudph->check = csum_tcpudp_magic(amt->local_ip, amt->discovery_ip,\n\t\t\t\t\tsizeof(*udph) + sizeof(*amtd),\n\t\t\t\t\tIPPROTO_UDP, skb->csum);\n\n\tskb_push(skb, sizeof(*iph));\n\tiph\t\t= ip_hdr(skb);\n\tiph->version\t= 4;\n\tiph->ihl\t= (sizeof(struct iphdr)) >> 2;\n\tiph->tos\t= AMT_TOS;\n\tiph->frag_off\t= 0;\n\tiph->ttl\t= ip4_dst_hoplimit(&rt->dst);\n\tiph->daddr\t= amt->discovery_ip;\n\tiph->saddr\t= amt->local_ip;\n\tiph->protocol\t= IPPROTO_UDP;\n\tiph->tot_len\t= htons(len);\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\tip_select_ident(amt->net, skb, NULL);\n\tip_send_check(iph);\n\terr = ip_local_out(amt->net, sock->sk, skb);\n\tif (unlikely(net_xmit_eval(err)))\n\t\tamt->dev->stats.tx_errors++;\n\n\tamt_update_gw_status(amt, AMT_STATUS_SENT_DISCOVERY, true);\nout:\n\trcu_read_unlock();\n}\n\nstatic void amt_send_request(struct amt_dev *amt, bool v6)\n{\n\tstruct amt_header_request *amtrh;\n\tint hlen, tlen, offset;\n\tstruct socket *sock;\n\tstruct udphdr *udph;\n\tstruct sk_buff *skb;\n\tstruct iphdr *iph;\n\tstruct rtable *rt;\n\tstruct flowi4 fl4;\n\tu32 len;\n\tint err;\n\n\trcu_read_lock();\n\tsock = rcu_dereference(amt->sock);\n\tif (!sock)\n\t\tgoto out;\n\n\tif (!netif_running(amt->stream_dev) || !netif_running(amt->dev))\n\t\tgoto out;\n\n\trt = ip_route_output_ports(amt->net, &fl4, sock->sk,\n\t\t\t\t   amt->remote_ip, amt->local_ip,\n\t\t\t\t   amt->gw_port, amt->relay_port,\n\t\t\t\t   IPPROTO_UDP, 0,\n\t\t\t\t   amt->stream_dev->ifindex);\n\tif (IS_ERR(rt)) {\n\t\tamt->dev->stats.tx_errors++;\n\t\tgoto out;\n\t}\n\n\thlen = LL_RESERVED_SPACE(amt->dev);\n\ttlen = amt->dev->needed_tailroom;\n\tlen = hlen + tlen + sizeof(*iph) + sizeof(*udph) + sizeof(*amtrh);\n\tskb = netdev_alloc_skb_ip_align(amt->dev, len);\n\tif (!skb) {\n\t\tip_rt_put(rt);\n\t\tamt->dev->stats.tx_errors++;\n\t\tgoto out;\n\t}\n\n\tskb->priority = TC_PRIO_CONTROL;\n\tskb_dst_set(skb, &rt->dst);\n\n\tlen = sizeof(*iph) + sizeof(*udph) + sizeof(*amtrh);\n\tskb_reset_network_header(skb);\n\tskb_put(skb, len);\n\tamtrh = skb_pull(skb, sizeof(*iph) + sizeof(*udph));\n\tamtrh->version\t = 0;\n\tamtrh->type\t = AMT_MSG_REQUEST;\n\tamtrh->reserved1 = 0;\n\tamtrh->p\t = v6;\n\tamtrh->reserved2 = 0;\n\tamtrh->nonce\t = amt->nonce;\n\tskb_push(skb, sizeof(*udph));\n\tskb_reset_transport_header(skb);\n\tudph\t\t= udp_hdr(skb);\n\tudph->source\t= amt->gw_port;\n\tudph->dest\t= amt->relay_port;\n\tudph->len\t= htons(sizeof(*amtrh) + sizeof(*udph));\n\tudph->check\t= 0;\n\toffset = skb_transport_offset(skb);\n\tskb->csum = skb_checksum(skb, offset, skb->len - offset, 0);\n\tudph->check = csum_tcpudp_magic(amt->local_ip, amt->remote_ip,\n\t\t\t\t\tsizeof(*udph) + sizeof(*amtrh),\n\t\t\t\t\tIPPROTO_UDP, skb->csum);\n\n\tskb_push(skb, sizeof(*iph));\n\tiph\t\t= ip_hdr(skb);\n\tiph->version\t= 4;\n\tiph->ihl\t= (sizeof(struct iphdr)) >> 2;\n\tiph->tos\t= AMT_TOS;\n\tiph->frag_off\t= 0;\n\tiph->ttl\t= ip4_dst_hoplimit(&rt->dst);\n\tiph->daddr\t= amt->remote_ip;\n\tiph->saddr\t= amt->local_ip;\n\tiph->protocol\t= IPPROTO_UDP;\n\tiph->tot_len\t= htons(len);\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\tip_select_ident(amt->net, skb, NULL);\n\tip_send_check(iph);\n\terr = ip_local_out(amt->net, sock->sk, skb);\n\tif (unlikely(net_xmit_eval(err)))\n\t\tamt->dev->stats.tx_errors++;\n\nout:\n\trcu_read_unlock();\n}\n\nstatic void amt_send_igmp_gq(struct amt_dev *amt,\n\t\t\t     struct amt_tunnel_list *tunnel)\n{\n\tstruct sk_buff *skb;\n\n\tskb = amt_build_igmp_gq(amt);\n\tif (!skb)\n\t\treturn;\n\n\tamt_skb_cb(skb)->tunnel = tunnel;\n\tdev_queue_xmit(skb);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic struct sk_buff *amt_build_mld_gq(struct amt_dev *amt)\n{\n\tu8 ra[AMT_IP6HDR_OPTS] = { IPPROTO_ICMPV6, 0, IPV6_TLV_ROUTERALERT,\n\t\t\t\t   2, 0, 0, IPV6_TLV_PAD1, IPV6_TLV_PAD1 };\n\tint hlen = LL_RESERVED_SPACE(amt->dev);\n\tint tlen = amt->dev->needed_tailroom;\n\tstruct mld2_query *mld2q;\n\tvoid *csum_start = NULL;\n\tstruct ipv6hdr *ip6h;\n\tstruct sk_buff *skb;\n\tstruct ethhdr *eth;\n\tu32 len;\n\n\tlen = hlen + tlen + sizeof(*ip6h) + sizeof(ra) + sizeof(*mld2q);\n\tskb = netdev_alloc_skb_ip_align(amt->dev, len);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, hlen);\n\tskb_push(skb, sizeof(*eth));\n\tskb_reset_mac_header(skb);\n\teth = eth_hdr(skb);\n\tskb->priority = TC_PRIO_CONTROL;\n\tskb->protocol = htons(ETH_P_IPV6);\n\tskb_put_zero(skb, sizeof(*ip6h));\n\tskb_put_data(skb, ra, sizeof(ra));\n\tskb_put_zero(skb, sizeof(*mld2q));\n\tskb_pull(skb, sizeof(*eth));\n\tskb_reset_network_header(skb);\n\tip6h\t\t\t= ipv6_hdr(skb);\n\tip6h->payload_len\t= htons(sizeof(ra) + sizeof(*mld2q));\n\tip6h->nexthdr\t\t= NEXTHDR_HOP;\n\tip6h->hop_limit\t\t= 1;\n\tip6h->daddr\t\t= mld2_all_node;\n\tip6_flow_hdr(ip6h, 0, 0);\n\n\tif (ipv6_dev_get_saddr(amt->net, amt->dev, &ip6h->daddr, 0,\n\t\t\t       &ip6h->saddr)) {\n\t\tamt->dev->stats.tx_errors++;\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\teth->h_proto = htons(ETH_P_IPV6);\n\tether_addr_copy(eth->h_source, amt->dev->dev_addr);\n\tipv6_eth_mc_map(&mld2_all_node, eth->h_dest);\n\n\tskb_pull(skb, sizeof(*ip6h) + sizeof(ra));\n\tskb_reset_transport_header(skb);\n\tmld2q\t\t\t= (struct mld2_query *)icmp6_hdr(skb);\n\tmld2q->mld2q_mrc\t= htons(1);\n\tmld2q->mld2q_type\t= ICMPV6_MGM_QUERY;\n\tmld2q->mld2q_code\t= 0;\n\tmld2q->mld2q_cksum\t= 0;\n\tmld2q->mld2q_resv1\t= 0;\n\tmld2q->mld2q_resv2\t= 0;\n\tmld2q->mld2q_suppress\t= 0;\n\tmld2q->mld2q_qrv\t= amt->qrv;\n\tmld2q->mld2q_nsrcs\t= 0;\n\tmld2q->mld2q_qqic\t= amt->qi;\n\tcsum_start\t\t= (void *)mld2q;\n\tmld2q->mld2q_cksum = csum_ipv6_magic(&ip6h->saddr, &ip6h->daddr,\n\t\t\t\t\t     sizeof(*mld2q),\n\t\t\t\t\t     IPPROTO_ICMPV6,\n\t\t\t\t\t     csum_partial(csum_start,\n\t\t\t\t\t\t\t  sizeof(*mld2q), 0));\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\tskb_push(skb, sizeof(*eth) + sizeof(*ip6h) + sizeof(ra));\n\treturn skb;\n}\n\nstatic void amt_send_mld_gq(struct amt_dev *amt, struct amt_tunnel_list *tunnel)\n{\n\tstruct sk_buff *skb;\n\n\tskb = amt_build_mld_gq(amt);\n\tif (!skb)\n\t\treturn;\n\n\tamt_skb_cb(skb)->tunnel = tunnel;\n\tdev_queue_xmit(skb);\n}\n#else\nstatic void amt_send_mld_gq(struct amt_dev *amt, struct amt_tunnel_list *tunnel)\n{\n}\n#endif\n\nstatic bool amt_queue_event(struct amt_dev *amt, enum amt_event event,\n\t\t\t    struct sk_buff *skb)\n{\n\tint index;\n\n\tspin_lock_bh(&amt->lock);\n\tif (amt->nr_events >= AMT_MAX_EVENTS) {\n\t\tspin_unlock_bh(&amt->lock);\n\t\treturn 1;\n\t}\n\n\tindex = (amt->event_idx + amt->nr_events) % AMT_MAX_EVENTS;\n\tamt->events[index].event = event;\n\tamt->events[index].skb = skb;\n\tamt->nr_events++;\n\tamt->event_idx %= AMT_MAX_EVENTS;\n\tqueue_work(amt_wq, &amt->event_wq);\n\tspin_unlock_bh(&amt->lock);\n\n\treturn 0;\n}\n\nstatic void amt_secret_work(struct work_struct *work)\n{\n\tstruct amt_dev *amt = container_of(to_delayed_work(work),\n\t\t\t\t\t   struct amt_dev,\n\t\t\t\t\t   secret_wq);\n\n\tspin_lock_bh(&amt->lock);\n\tget_random_bytes(&amt->key, sizeof(siphash_key_t));\n\tspin_unlock_bh(&amt->lock);\n\tmod_delayed_work(amt_wq, &amt->secret_wq,\n\t\t\t msecs_to_jiffies(AMT_SECRET_TIMEOUT));\n}\n\nstatic void amt_event_send_discovery(struct amt_dev *amt)\n{\n\tif (amt->status > AMT_STATUS_SENT_DISCOVERY)\n\t\tgoto out;\n\tget_random_bytes(&amt->nonce, sizeof(__be32));\n\n\tamt_send_discovery(amt);\nout:\n\tmod_delayed_work(amt_wq, &amt->discovery_wq,\n\t\t\t msecs_to_jiffies(AMT_DISCOVERY_TIMEOUT));\n}\n\nstatic void amt_discovery_work(struct work_struct *work)\n{\n\tstruct amt_dev *amt = container_of(to_delayed_work(work),\n\t\t\t\t\t   struct amt_dev,\n\t\t\t\t\t   discovery_wq);\n\n\tif (amt_queue_event(amt, AMT_EVENT_SEND_DISCOVERY, NULL))\n\t\tmod_delayed_work(amt_wq, &amt->discovery_wq,\n\t\t\t\t msecs_to_jiffies(AMT_DISCOVERY_TIMEOUT));\n}\n\nstatic void amt_event_send_request(struct amt_dev *amt)\n{\n\tu32 exp;\n\n\tif (amt->status < AMT_STATUS_RECEIVED_ADVERTISEMENT)\n\t\tgoto out;\n\n\tif (amt->req_cnt > AMT_MAX_REQ_COUNT) {\n\t\tnetdev_dbg(amt->dev, \"Gateway is not ready\");\n\t\tamt->qi = AMT_INIT_REQ_TIMEOUT;\n\t\tWRITE_ONCE(amt->ready4, false);\n\t\tWRITE_ONCE(amt->ready6, false);\n\t\tamt->remote_ip = 0;\n\t\tamt_update_gw_status(amt, AMT_STATUS_INIT, false);\n\t\tamt->req_cnt = 0;\n\t\tamt->nonce = 0;\n\t\tgoto out;\n\t}\n\n\tif (!amt->req_cnt) {\n\t\tWRITE_ONCE(amt->ready4, false);\n\t\tWRITE_ONCE(amt->ready6, false);\n\t\tget_random_bytes(&amt->nonce, sizeof(__be32));\n\t}\n\n\tamt_send_request(amt, false);\n\tamt_send_request(amt, true);\n\tamt_update_gw_status(amt, AMT_STATUS_SENT_REQUEST, true);\n\tamt->req_cnt++;\nout:\n\texp = min_t(u32, (1 * (1 << amt->req_cnt)), AMT_MAX_REQ_TIMEOUT);\n\tmod_delayed_work(amt_wq, &amt->req_wq, msecs_to_jiffies(exp * 1000));\n}\n\nstatic void amt_req_work(struct work_struct *work)\n{\n\tstruct amt_dev *amt = container_of(to_delayed_work(work),\n\t\t\t\t\t   struct amt_dev,\n\t\t\t\t\t   req_wq);\n\n\tif (amt_queue_event(amt, AMT_EVENT_SEND_REQUEST, NULL))\n\t\tmod_delayed_work(amt_wq, &amt->req_wq,\n\t\t\t\t msecs_to_jiffies(100));\n}\n\nstatic bool amt_send_membership_update(struct amt_dev *amt,\n\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t       bool v6)\n{\n\tstruct amt_header_membership_update *amtmu;\n\tstruct socket *sock;\n\tstruct iphdr *iph;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\tint err;\n\n\tsock = rcu_dereference_bh(amt->sock);\n\tif (!sock)\n\t\treturn true;\n\n\terr = skb_cow_head(skb, LL_RESERVED_SPACE(amt->dev) + sizeof(*amtmu) +\n\t\t\t   sizeof(*iph) + sizeof(struct udphdr));\n\tif (err)\n\t\treturn true;\n\n\tskb_reset_inner_headers(skb);\n\tmemset(&fl4, 0, sizeof(struct flowi4));\n\tfl4.flowi4_oif         = amt->stream_dev->ifindex;\n\tfl4.daddr              = amt->remote_ip;\n\tfl4.saddr              = amt->local_ip;\n\tfl4.flowi4_tos         = AMT_TOS;\n\tfl4.flowi4_proto       = IPPROTO_UDP;\n\trt = ip_route_output_key(amt->net, &fl4);\n\tif (IS_ERR(rt)) {\n\t\tnetdev_dbg(amt->dev, \"no route to %pI4\\n\", &amt->remote_ip);\n\t\treturn true;\n\t}\n\n\tamtmu\t\t\t= skb_push(skb, sizeof(*amtmu));\n\tamtmu->version\t\t= 0;\n\tamtmu->type\t\t= AMT_MSG_MEMBERSHIP_UPDATE;\n\tamtmu->reserved\t\t= 0;\n\tamtmu->nonce\t\t= amt->nonce;\n\tamtmu->response_mac\t= amt->mac;\n\n\tif (!v6)\n\t\tskb_set_inner_protocol(skb, htons(ETH_P_IP));\n\telse\n\t\tskb_set_inner_protocol(skb, htons(ETH_P_IPV6));\n\tudp_tunnel_xmit_skb(rt, sock->sk, skb,\n\t\t\t    fl4.saddr,\n\t\t\t    fl4.daddr,\n\t\t\t    AMT_TOS,\n\t\t\t    ip4_dst_hoplimit(&rt->dst),\n\t\t\t    0,\n\t\t\t    amt->gw_port,\n\t\t\t    amt->relay_port,\n\t\t\t    false,\n\t\t\t    false);\n\tamt_update_gw_status(amt, AMT_STATUS_SENT_UPDATE, true);\n\treturn false;\n}\n\nstatic void amt_send_multicast_data(struct amt_dev *amt,\n\t\t\t\t    const struct sk_buff *oskb,\n\t\t\t\t    struct amt_tunnel_list *tunnel,\n\t\t\t\t    bool v6)\n{\n\tstruct amt_header_mcast_data *amtmd;\n\tstruct socket *sock;\n\tstruct sk_buff *skb;\n\tstruct iphdr *iph;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\n\tsock = rcu_dereference_bh(amt->sock);\n\tif (!sock)\n\t\treturn;\n\n\tskb = skb_copy_expand(oskb, sizeof(*amtmd) + sizeof(*iph) +\n\t\t\t      sizeof(struct udphdr), 0, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tskb_reset_inner_headers(skb);\n\tmemset(&fl4, 0, sizeof(struct flowi4));\n\tfl4.flowi4_oif         = amt->stream_dev->ifindex;\n\tfl4.daddr              = tunnel->ip4;\n\tfl4.saddr              = amt->local_ip;\n\tfl4.flowi4_proto       = IPPROTO_UDP;\n\trt = ip_route_output_key(amt->net, &fl4);\n\tif (IS_ERR(rt)) {\n\t\tnetdev_dbg(amt->dev, \"no route to %pI4\\n\", &tunnel->ip4);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tamtmd = skb_push(skb, sizeof(*amtmd));\n\tamtmd->version = 0;\n\tamtmd->reserved = 0;\n\tamtmd->type = AMT_MSG_MULTICAST_DATA;\n\n\tif (!v6)\n\t\tskb_set_inner_protocol(skb, htons(ETH_P_IP));\n\telse\n\t\tskb_set_inner_protocol(skb, htons(ETH_P_IPV6));\n\tudp_tunnel_xmit_skb(rt, sock->sk, skb,\n\t\t\t    fl4.saddr,\n\t\t\t    fl4.daddr,\n\t\t\t    AMT_TOS,\n\t\t\t    ip4_dst_hoplimit(&rt->dst),\n\t\t\t    0,\n\t\t\t    amt->relay_port,\n\t\t\t    tunnel->source_port,\n\t\t\t    false,\n\t\t\t    false);\n}\n\nstatic bool amt_send_membership_query(struct amt_dev *amt,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      struct amt_tunnel_list *tunnel,\n\t\t\t\t      bool v6)\n{\n\tstruct amt_header_membership_query *amtmq;\n\tstruct socket *sock;\n\tstruct rtable *rt;\n\tstruct flowi4 fl4;\n\tint err;\n\n\tsock = rcu_dereference_bh(amt->sock);\n\tif (!sock)\n\t\treturn true;\n\n\terr = skb_cow_head(skb, LL_RESERVED_SPACE(amt->dev) + sizeof(*amtmq) +\n\t\t\t   sizeof(struct iphdr) + sizeof(struct udphdr));\n\tif (err)\n\t\treturn true;\n\n\tskb_reset_inner_headers(skb);\n\tmemset(&fl4, 0, sizeof(struct flowi4));\n\tfl4.flowi4_oif         = amt->stream_dev->ifindex;\n\tfl4.daddr              = tunnel->ip4;\n\tfl4.saddr              = amt->local_ip;\n\tfl4.flowi4_tos         = AMT_TOS;\n\tfl4.flowi4_proto       = IPPROTO_UDP;\n\trt = ip_route_output_key(amt->net, &fl4);\n\tif (IS_ERR(rt)) {\n\t\tnetdev_dbg(amt->dev, \"no route to %pI4\\n\", &tunnel->ip4);\n\t\treturn true;\n\t}\n\n\tamtmq\t\t= skb_push(skb, sizeof(*amtmq));\n\tamtmq->version\t= 0;\n\tamtmq->type\t= AMT_MSG_MEMBERSHIP_QUERY;\n\tamtmq->reserved = 0;\n\tamtmq->l\t= 0;\n\tamtmq->g\t= 0;\n\tamtmq->nonce\t= tunnel->nonce;\n\tamtmq->response_mac = tunnel->mac;\n\n\tif (!v6)\n\t\tskb_set_inner_protocol(skb, htons(ETH_P_IP));\n\telse\n\t\tskb_set_inner_protocol(skb, htons(ETH_P_IPV6));\n\tudp_tunnel_xmit_skb(rt, sock->sk, skb,\n\t\t\t    fl4.saddr,\n\t\t\t    fl4.daddr,\n\t\t\t    AMT_TOS,\n\t\t\t    ip4_dst_hoplimit(&rt->dst),\n\t\t\t    0,\n\t\t\t    amt->relay_port,\n\t\t\t    tunnel->source_port,\n\t\t\t    false,\n\t\t\t    false);\n\tamt_update_relay_status(tunnel, AMT_STATUS_SENT_QUERY, true);\n\treturn false;\n}\n\nstatic netdev_tx_t amt_dev_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct amt_dev *amt = netdev_priv(dev);\n\tstruct amt_tunnel_list *tunnel;\n\tstruct amt_group_node *gnode;\n\tunion amt_addr group = {0,};\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct ipv6hdr *ip6h;\n\tstruct mld_msg *mld;\n#endif\n\tbool report = false;\n\tstruct igmphdr *ih;\n\tbool query = false;\n\tstruct iphdr *iph;\n\tbool data = false;\n\tbool v6 = false;\n\tu32 hash;\n\n\tiph = ip_hdr(skb);\n\tif (iph->version == 4) {\n\t\tif (!ipv4_is_multicast(iph->daddr))\n\t\t\tgoto free;\n\n\t\tif (!ip_mc_check_igmp(skb)) {\n\t\t\tih = igmp_hdr(skb);\n\t\t\tswitch (ih->type) {\n\t\t\tcase IGMPV3_HOST_MEMBERSHIP_REPORT:\n\t\t\tcase IGMP_HOST_MEMBERSHIP_REPORT:\n\t\t\t\treport = true;\n\t\t\t\tbreak;\n\t\t\tcase IGMP_HOST_MEMBERSHIP_QUERY:\n\t\t\t\tquery = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t} else {\n\t\t\tdata = true;\n\t\t}\n\t\tv6 = false;\n\t\tgroup.ip4 = iph->daddr;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (iph->version == 6) {\n\t\tip6h = ipv6_hdr(skb);\n\t\tif (!ipv6_addr_is_multicast(&ip6h->daddr))\n\t\t\tgoto free;\n\n\t\tif (!ipv6_mc_check_mld(skb)) {\n\t\t\tmld = (struct mld_msg *)skb_transport_header(skb);\n\t\t\tswitch (mld->mld_type) {\n\t\t\tcase ICMPV6_MGM_REPORT:\n\t\t\tcase ICMPV6_MLD2_REPORT:\n\t\t\t\treport = true;\n\t\t\t\tbreak;\n\t\t\tcase ICMPV6_MGM_QUERY:\n\t\t\t\tquery = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t} else {\n\t\t\tdata = true;\n\t\t}\n\t\tv6 = true;\n\t\tgroup.ip6 = ip6h->daddr;\n#endif\n\t} else {\n\t\tdev->stats.tx_errors++;\n\t\tgoto free;\n\t}\n\n\tif (!pskb_may_pull(skb, sizeof(struct ethhdr)))\n\t\tgoto free;\n\n\tskb_pull(skb, sizeof(struct ethhdr));\n\n\tif (amt->mode == AMT_MODE_GATEWAY) {\n\t\t \n\t\tif (!report)\n\t\t\tgoto free;\n\t\tif ((!v6 && !READ_ONCE(amt->ready4)) ||\n\t\t    (v6 && !READ_ONCE(amt->ready6)))\n\t\t\tgoto free;\n\t\tif (amt_send_membership_update(amt, skb,  v6))\n\t\t\tgoto free;\n\t\tgoto unlock;\n\t} else if (amt->mode == AMT_MODE_RELAY) {\n\t\tif (query) {\n\t\t\ttunnel = amt_skb_cb(skb)->tunnel;\n\t\t\tif (!tunnel) {\n\t\t\t\tWARN_ON(1);\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (amt_send_membership_query(amt, skb, tunnel, v6))\n\t\t\t\tgoto free;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (!data)\n\t\t\tgoto free;\n\t\tlist_for_each_entry_rcu(tunnel, &amt->tunnel_list, list) {\n\t\t\thash = amt_group_hash(tunnel, &group);\n\t\t\thlist_for_each_entry_rcu(gnode, &tunnel->groups[hash],\n\t\t\t\t\t\t node) {\n\t\t\t\tif (!v6) {\n\t\t\t\t\tif (gnode->group_addr.ip4 == iph->daddr)\n\t\t\t\t\t\tgoto found;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\t\t} else {\n\t\t\t\t\tif (ipv6_addr_equal(&gnode->group_addr.ip6,\n\t\t\t\t\t\t\t    &ip6h->daddr))\n\t\t\t\t\t\tgoto found;\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\nfound:\n\t\t\tamt_send_multicast_data(amt, skb, tunnel, v6);\n\t\t}\n\t}\n\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\nfree:\n\tdev_kfree_skb(skb);\nunlock:\n\tdev->stats.tx_dropped++;\n\treturn NETDEV_TX_OK;\n}\n\nstatic int amt_parse_type(struct sk_buff *skb)\n{\n\tstruct amt_header *amth;\n\n\tif (!pskb_may_pull(skb, sizeof(struct udphdr) +\n\t\t\t   sizeof(struct amt_header)))\n\t\treturn -1;\n\n\tamth = (struct amt_header *)(udp_hdr(skb) + 1);\n\n\tif (amth->version != 0)\n\t\treturn -1;\n\n\tif (amth->type >= __AMT_MSG_MAX || !amth->type)\n\t\treturn -1;\n\treturn amth->type;\n}\n\nstatic void amt_clear_groups(struct amt_tunnel_list *tunnel)\n{\n\tstruct amt_dev *amt = tunnel->amt;\n\tstruct amt_group_node *gnode;\n\tstruct hlist_node *t;\n\tint i;\n\n\tspin_lock_bh(&tunnel->lock);\n\trcu_read_lock();\n\tfor (i = 0; i < amt->hash_buckets; i++)\n\t\thlist_for_each_entry_safe(gnode, t, &tunnel->groups[i], node)\n\t\t\tamt_del_group(amt, gnode);\n\trcu_read_unlock();\n\tspin_unlock_bh(&tunnel->lock);\n}\n\nstatic void amt_tunnel_expire(struct work_struct *work)\n{\n\tstruct amt_tunnel_list *tunnel = container_of(to_delayed_work(work),\n\t\t\t\t\t\t      struct amt_tunnel_list,\n\t\t\t\t\t\t      gc_wq);\n\tstruct amt_dev *amt = tunnel->amt;\n\n\tspin_lock_bh(&amt->lock);\n\trcu_read_lock();\n\tlist_del_rcu(&tunnel->list);\n\tamt->nr_tunnels--;\n\tamt_clear_groups(tunnel);\n\trcu_read_unlock();\n\tspin_unlock_bh(&amt->lock);\n\tkfree_rcu(tunnel, rcu);\n}\n\nstatic void amt_cleanup_srcs(struct amt_dev *amt,\n\t\t\t     struct amt_tunnel_list *tunnel,\n\t\t\t     struct amt_group_node *gnode)\n{\n\tstruct amt_source_node *snode;\n\tstruct hlist_node *t;\n\tint i;\n\n\t \n\tfor (i = 0; i < amt->hash_buckets; i++) {\n\t\thlist_for_each_entry_safe(snode, t, &gnode->sources[i], node) {\n\t\t\tif (snode->flags == AMT_SOURCE_OLD)\n\t\t\t\tamt_destroy_source(snode);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < amt->hash_buckets; i++)  {\n\t\thlist_for_each_entry_rcu(snode, &gnode->sources[i], node) {\n\t\t\tsnode->flags = AMT_SOURCE_OLD;\n\t\t\tif (!gnode->v6)\n\t\t\t\tnetdev_dbg(snode->gnode->amt->dev,\n\t\t\t\t\t   \"Add source as OLD %pI4 from %pI4\\n\",\n\t\t\t\t\t   &snode->source_addr.ip4,\n\t\t\t\t\t   &gnode->group_addr.ip4);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\telse\n\t\t\t\tnetdev_dbg(snode->gnode->amt->dev,\n\t\t\t\t\t   \"Add source as OLD %pI6 from %pI6\\n\",\n\t\t\t\t\t   &snode->source_addr.ip6,\n\t\t\t\t\t   &gnode->group_addr.ip6);\n#endif\n\t\t}\n\t}\n}\n\nstatic void amt_add_srcs(struct amt_dev *amt, struct amt_tunnel_list *tunnel,\n\t\t\t struct amt_group_node *gnode, void *grec,\n\t\t\t bool v6)\n{\n\tstruct igmpv3_grec *igmp_grec;\n\tstruct amt_source_node *snode;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct mld2_grec *mld_grec;\n#endif\n\tunion amt_addr src = {0,};\n\tu16 nsrcs;\n\tu32 hash;\n\tint i;\n\n\tif (!v6) {\n\t\tigmp_grec = grec;\n\t\tnsrcs = ntohs(igmp_grec->grec_nsrcs);\n\t} else {\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tmld_grec = grec;\n\t\tnsrcs = ntohs(mld_grec->grec_nsrcs);\n#else\n\treturn;\n#endif\n\t}\n\tfor (i = 0; i < nsrcs; i++) {\n\t\tif (tunnel->nr_sources >= amt->max_sources)\n\t\t\treturn;\n\t\tif (!v6)\n\t\t\tsrc.ip4 = igmp_grec->grec_src[i];\n#if IS_ENABLED(CONFIG_IPV6)\n\t\telse\n\t\t\tmemcpy(&src.ip6, &mld_grec->grec_src[i],\n\t\t\t       sizeof(struct in6_addr));\n#endif\n\t\tif (amt_lookup_src(tunnel, gnode, AMT_FILTER_ALL, &src))\n\t\t\tcontinue;\n\n\t\tsnode = amt_alloc_snode(gnode, &src);\n\t\tif (snode) {\n\t\t\thash = amt_source_hash(tunnel, &snode->source_addr);\n\t\t\thlist_add_head_rcu(&snode->node, &gnode->sources[hash]);\n\t\t\ttunnel->nr_sources++;\n\t\t\tgnode->nr_sources++;\n\n\t\t\tif (!gnode->v6)\n\t\t\t\tnetdev_dbg(snode->gnode->amt->dev,\n\t\t\t\t\t   \"Add source as NEW %pI4 from %pI4\\n\",\n\t\t\t\t\t   &snode->source_addr.ip4,\n\t\t\t\t\t   &gnode->group_addr.ip4);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\telse\n\t\t\t\tnetdev_dbg(snode->gnode->amt->dev,\n\t\t\t\t\t   \"Add source as NEW %pI6 from %pI6\\n\",\n\t\t\t\t\t   &snode->source_addr.ip6,\n\t\t\t\t\t   &gnode->group_addr.ip6);\n#endif\n\t\t}\n\t}\n}\n\n \nstatic void amt_lookup_act_srcs(struct amt_tunnel_list *tunnel,\n\t\t\t\tstruct amt_group_node *gnode,\n\t\t\t\tvoid *grec,\n\t\t\t\tenum amt_ops ops,\n\t\t\t\tenum amt_filter filter,\n\t\t\t\tenum amt_act act,\n\t\t\t\tbool v6)\n{\n\tstruct amt_dev *amt = tunnel->amt;\n\tstruct amt_source_node *snode;\n\tstruct igmpv3_grec *igmp_grec;\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct mld2_grec *mld_grec;\n#endif\n\tunion amt_addr src = {0,};\n\tstruct hlist_node *t;\n\tu16 nsrcs;\n\tint i, j;\n\n\tif (!v6) {\n\t\tigmp_grec = grec;\n\t\tnsrcs = ntohs(igmp_grec->grec_nsrcs);\n\t} else {\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tmld_grec = grec;\n\t\tnsrcs = ntohs(mld_grec->grec_nsrcs);\n#else\n\treturn;\n#endif\n\t}\n\n\tmemset(&src, 0, sizeof(union amt_addr));\n\tswitch (ops) {\n\tcase AMT_OPS_INT:\n\t\t \n\t\tfor (i = 0; i < nsrcs; i++) {\n\t\t\tif (!v6)\n\t\t\t\tsrc.ip4 = igmp_grec->grec_src[i];\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\telse\n\t\t\t\tmemcpy(&src.ip6, &mld_grec->grec_src[i],\n\t\t\t\t       sizeof(struct in6_addr));\n#endif\n\t\t\tsnode = amt_lookup_src(tunnel, gnode, filter, &src);\n\t\t\tif (!snode)\n\t\t\t\tcontinue;\n\t\t\tamt_act_src(tunnel, gnode, snode, act);\n\t\t}\n\t\tbreak;\n\tcase AMT_OPS_UNI:\n\t\t \n\t\tfor (i = 0; i < amt->hash_buckets; i++) {\n\t\t\thlist_for_each_entry_safe(snode, t, &gnode->sources[i],\n\t\t\t\t\t\t  node) {\n\t\t\t\tif (amt_status_filter(snode, filter))\n\t\t\t\t\tamt_act_src(tunnel, gnode, snode, act);\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < nsrcs; i++) {\n\t\t\tif (!v6)\n\t\t\t\tsrc.ip4 = igmp_grec->grec_src[i];\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\telse\n\t\t\t\tmemcpy(&src.ip6, &mld_grec->grec_src[i],\n\t\t\t\t       sizeof(struct in6_addr));\n#endif\n\t\t\tsnode = amt_lookup_src(tunnel, gnode, filter, &src);\n\t\t\tif (!snode)\n\t\t\t\tcontinue;\n\t\t\tamt_act_src(tunnel, gnode, snode, act);\n\t\t}\n\t\tbreak;\n\tcase AMT_OPS_SUB:\n\t\t \n\t\tfor (i = 0; i < amt->hash_buckets; i++) {\n\t\t\thlist_for_each_entry_safe(snode, t, &gnode->sources[i],\n\t\t\t\t\t\t  node) {\n\t\t\t\tif (!amt_status_filter(snode, filter))\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (j = 0; j < nsrcs; j++) {\n\t\t\t\t\tif (!v6)\n\t\t\t\t\t\tsrc.ip4 = igmp_grec->grec_src[j];\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\t\t\telse\n\t\t\t\t\t\tmemcpy(&src.ip6,\n\t\t\t\t\t\t       &mld_grec->grec_src[j],\n\t\t\t\t\t\t       sizeof(struct in6_addr));\n#endif\n\t\t\t\t\tif (amt_addr_equal(&snode->source_addr,\n\t\t\t\t\t\t\t   &src))\n\t\t\t\t\t\tgoto out_sub;\n\t\t\t\t}\n\t\t\t\tamt_act_src(tunnel, gnode, snode, act);\n\t\t\t\tcontinue;\nout_sub:;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase AMT_OPS_SUB_REV:\n\t\t \n\t\tfor (i = 0; i < nsrcs; i++) {\n\t\t\tif (!v6)\n\t\t\t\tsrc.ip4 = igmp_grec->grec_src[i];\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\telse\n\t\t\t\tmemcpy(&src.ip6, &mld_grec->grec_src[i],\n\t\t\t\t       sizeof(struct in6_addr));\n#endif\n\t\t\tsnode = amt_lookup_src(tunnel, gnode, AMT_FILTER_ALL,\n\t\t\t\t\t       &src);\n\t\t\tif (!snode) {\n\t\t\t\tsnode = amt_lookup_src(tunnel, gnode,\n\t\t\t\t\t\t       filter, &src);\n\t\t\t\tif (snode)\n\t\t\t\t\tamt_act_src(tunnel, gnode, snode, act);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tnetdev_dbg(amt->dev, \"Invalid type\\n\");\n\t\treturn;\n\t}\n}\n\nstatic void amt_mcast_is_in_handler(struct amt_dev *amt,\n\t\t\t\t    struct amt_tunnel_list *tunnel,\n\t\t\t\t    struct amt_group_node *gnode,\n\t\t\t\t    void *grec, void *zero_grec, bool v6)\n{\n\tif (gnode->filter_mode == MCAST_INCLUDE) {\n \n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_UNI,\n\t\t\t\t    AMT_FILTER_NONE_NEW,\n\t\t\t\t    AMT_ACT_STATUS_FWD_NEW,\n\t\t\t\t    v6);\n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_UNI,\n\t\t\t\t    AMT_FILTER_FWD,\n\t\t\t\t    AMT_ACT_STATUS_FWD_NEW,\n\t\t\t\t    v6);\n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_INT,\n\t\t\t\t    AMT_FILTER_FWD_NEW,\n\t\t\t\t    AMT_ACT_GMI,\n\t\t\t\t    v6);\n\t} else {\n \n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_INT,\n\t\t\t\t    AMT_FILTER_BOTH,\n\t\t\t\t    AMT_ACT_STATUS_NONE_NEW,\n\t\t\t\t    v6);\n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, zero_grec, AMT_OPS_UNI,\n\t\t\t\t    AMT_FILTER_FWD,\n\t\t\t\t    AMT_ACT_STATUS_FWD_NEW,\n\t\t\t\t    v6);\n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_INT,\n\t\t\t\t    AMT_FILTER_NONE_NEW,\n\t\t\t\t    AMT_ACT_STATUS_FWD_NEW,\n\t\t\t\t    v6);\n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_SUB,\n\t\t\t\t    AMT_FILTER_D_FWD,\n\t\t\t\t    AMT_ACT_STATUS_D_FWD_NEW,\n\t\t\t\t    v6);\n\t}\n}\n\nstatic void amt_mcast_is_ex_handler(struct amt_dev *amt,\n\t\t\t\t    struct amt_tunnel_list *tunnel,\n\t\t\t\t    struct amt_group_node *gnode,\n\t\t\t\t    void *grec, void *zero_grec, bool v6)\n{\n\tif (gnode->filter_mode == MCAST_INCLUDE) {\n \n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_INT,\n\t\t\t\t    AMT_FILTER_FWD,\n\t\t\t\t    AMT_ACT_STATUS_FWD_NEW,\n\t\t\t\t    v6);\n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_SUB_REV,\n\t\t\t\t    AMT_FILTER_FWD,\n\t\t\t\t    AMT_ACT_STATUS_D_FWD_NEW,\n\t\t\t\t    v6);\n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, zero_grec, AMT_OPS_UNI,\n\t\t\t\t    AMT_FILTER_D_FWD_NEW,\n\t\t\t\t    AMT_ACT_GMI_ZERO,\n\t\t\t\t    v6);\n\t\t \n\t\tif (!mod_delayed_work(amt_wq, &gnode->group_timer,\n\t\t\t\t      msecs_to_jiffies(amt_gmi(amt))))\n\t\t\tdev_hold(amt->dev);\n\t\tgnode->filter_mode = MCAST_EXCLUDE;\n\t\t \n\t} else {\n \n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_SUB_REV,\n\t\t\t\t    AMT_FILTER_D_FWD,\n\t\t\t\t    AMT_ACT_STATUS_FWD_NEW,\n\t\t\t\t    v6);\n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_INT,\n\t\t\t\t    AMT_FILTER_D_FWD,\n\t\t\t\t    AMT_ACT_STATUS_D_FWD_NEW,\n\t\t\t\t    v6);\n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_SUB_REV,\n\t\t\t\t    AMT_FILTER_BOTH_NEW,\n\t\t\t\t    AMT_ACT_GMI,\n\t\t\t\t    v6);\n\t\t \n\t\tif (!mod_delayed_work(amt_wq, &gnode->group_timer,\n\t\t\t\t      msecs_to_jiffies(amt_gmi(amt))))\n\t\t\tdev_hold(amt->dev);\n\t\t \n\t}\n}\n\nstatic void amt_mcast_to_in_handler(struct amt_dev *amt,\n\t\t\t\t    struct amt_tunnel_list *tunnel,\n\t\t\t\t    struct amt_group_node *gnode,\n\t\t\t\t    void *grec, void *zero_grec, bool v6)\n{\n\tif (gnode->filter_mode == MCAST_INCLUDE) {\n \n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_UNI,\n\t\t\t\t    AMT_FILTER_NONE_NEW,\n\t\t\t\t    AMT_ACT_STATUS_FWD_NEW,\n\t\t\t\t    v6);\n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_UNI,\n\t\t\t\t    AMT_FILTER_FWD,\n\t\t\t\t    AMT_ACT_STATUS_FWD_NEW,\n\t\t\t\t    v6);\n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_INT,\n\t\t\t\t    AMT_FILTER_FWD_NEW,\n\t\t\t\t    AMT_ACT_GMI,\n\t\t\t\t    v6);\n\t} else {\n \n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_UNI,\n\t\t\t\t    AMT_FILTER_NONE_NEW,\n\t\t\t\t    AMT_ACT_STATUS_FWD_NEW,\n\t\t\t\t    v6);\n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_UNI,\n\t\t\t\t    AMT_FILTER_FWD,\n\t\t\t\t    AMT_ACT_STATUS_FWD_NEW,\n\t\t\t\t    v6);\n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, zero_grec, AMT_OPS_UNI,\n\t\t\t\t    AMT_FILTER_D_FWD,\n\t\t\t\t    AMT_ACT_STATUS_D_FWD_NEW,\n\t\t\t\t    v6);\n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_INT,\n\t\t\t\t    AMT_FILTER_FWD_NEW,\n\t\t\t\t    AMT_ACT_GMI,\n\t\t\t\t    v6);\n\t}\n}\n\nstatic void amt_mcast_to_ex_handler(struct amt_dev *amt,\n\t\t\t\t    struct amt_tunnel_list *tunnel,\n\t\t\t\t    struct amt_group_node *gnode,\n\t\t\t\t    void *grec, void *zero_grec, bool v6)\n{\n\tif (gnode->filter_mode == MCAST_INCLUDE) {\n \n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_INT,\n\t\t\t\t    AMT_FILTER_FWD,\n\t\t\t\t    AMT_ACT_STATUS_FWD_NEW,\n\t\t\t\t    v6);\n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_SUB_REV,\n\t\t\t\t    AMT_FILTER_FWD,\n\t\t\t\t    AMT_ACT_STATUS_D_FWD_NEW,\n\t\t\t\t    v6);\n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, zero_grec, AMT_OPS_UNI,\n\t\t\t\t    AMT_FILTER_D_FWD_NEW,\n\t\t\t\t    AMT_ACT_GMI_ZERO,\n\t\t\t\t    v6);\n\t\t \n\t\tif (!mod_delayed_work(amt_wq, &gnode->group_timer,\n\t\t\t\t      msecs_to_jiffies(amt_gmi(amt))))\n\t\t\tdev_hold(amt->dev);\n\t\tgnode->filter_mode = MCAST_EXCLUDE;\n\t\t \n\t} else {\n \n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_SUB_REV,\n\t\t\t\t    AMT_FILTER_BOTH,\n\t\t\t\t    AMT_ACT_GT,\n\t\t\t\t    v6);\n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_SUB_REV,\n\t\t\t\t    AMT_FILTER_D_FWD,\n\t\t\t\t    AMT_ACT_STATUS_FWD_NEW,\n\t\t\t\t    v6);\n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_INT,\n\t\t\t\t    AMT_FILTER_D_FWD,\n\t\t\t\t    AMT_ACT_STATUS_D_FWD_NEW,\n\t\t\t\t    v6);\n\t\t \n\t\tif (!mod_delayed_work(amt_wq, &gnode->group_timer,\n\t\t\t\t      msecs_to_jiffies(amt_gmi(amt))))\n\t\t\tdev_hold(amt->dev);\n\t\t \n\t}\n}\n\nstatic void amt_mcast_allow_handler(struct amt_dev *amt,\n\t\t\t\t    struct amt_tunnel_list *tunnel,\n\t\t\t\t    struct amt_group_node *gnode,\n\t\t\t\t    void *grec, void *zero_grec, bool v6)\n{\n\tif (gnode->filter_mode == MCAST_INCLUDE) {\n \n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_UNI,\n\t\t\t\t    AMT_FILTER_FWD,\n\t\t\t\t    AMT_ACT_STATUS_FWD_NEW,\n\t\t\t\t    v6);\n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_INT,\n\t\t\t\t    AMT_FILTER_FWD_NEW,\n\t\t\t\t    AMT_ACT_GMI,\n\t\t\t\t    v6);\n\t} else {\n \n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_UNI,\n\t\t\t\t    AMT_FILTER_FWD,\n\t\t\t\t    AMT_ACT_STATUS_FWD_NEW,\n\t\t\t\t    v6);\n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_SUB,\n\t\t\t\t    AMT_FILTER_D_FWD,\n\t\t\t\t    AMT_ACT_STATUS_D_FWD_NEW,\n\t\t\t\t    v6);\n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_INT,\n\t\t\t\t    AMT_FILTER_FWD_NEW,\n\t\t\t\t    AMT_ACT_GMI,\n\t\t\t\t    v6);\n\t}\n}\n\nstatic void amt_mcast_block_handler(struct amt_dev *amt,\n\t\t\t\t    struct amt_tunnel_list *tunnel,\n\t\t\t\t    struct amt_group_node *gnode,\n\t\t\t\t    void *grec, void *zero_grec, bool v6)\n{\n\tif (gnode->filter_mode == MCAST_INCLUDE) {\n \n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, zero_grec, AMT_OPS_UNI,\n\t\t\t\t    AMT_FILTER_FWD,\n\t\t\t\t    AMT_ACT_STATUS_FWD_NEW,\n\t\t\t\t    v6);\n\t} else {\n \n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_SUB_REV,\n\t\t\t\t    AMT_FILTER_BOTH,\n\t\t\t\t    AMT_ACT_GT,\n\t\t\t\t    v6);\n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_UNI,\n\t\t\t\t    AMT_FILTER_FWD,\n\t\t\t\t    AMT_ACT_STATUS_FWD_NEW,\n\t\t\t\t    v6);\n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_SUB_REV,\n\t\t\t\t    AMT_FILTER_D_FWD,\n\t\t\t\t    AMT_ACT_STATUS_FWD_NEW,\n\t\t\t\t    v6);\n\t\t \n\t\tamt_lookup_act_srcs(tunnel, gnode, grec, AMT_OPS_UNI,\n\t\t\t\t    AMT_FILTER_D_FWD,\n\t\t\t\t    AMT_ACT_STATUS_D_FWD_NEW,\n\t\t\t\t    v6);\n\t}\n}\n\n \nstatic void amt_igmpv2_report_handler(struct amt_dev *amt, struct sk_buff *skb,\n\t\t\t\t      struct amt_tunnel_list *tunnel)\n{\n\tstruct igmphdr *ih = igmp_hdr(skb);\n\tstruct iphdr *iph = ip_hdr(skb);\n\tstruct amt_group_node *gnode;\n\tunion amt_addr group, host;\n\n\tmemset(&group, 0, sizeof(union amt_addr));\n\tgroup.ip4 = ih->group;\n\tmemset(&host, 0, sizeof(union amt_addr));\n\thost.ip4 = iph->saddr;\n\n\tgnode = amt_lookup_group(tunnel, &group, &host, false);\n\tif (!gnode) {\n\t\tgnode = amt_add_group(amt, tunnel, &group, &host, false);\n\t\tif (!IS_ERR(gnode)) {\n\t\t\tgnode->filter_mode = MCAST_EXCLUDE;\n\t\t\tif (!mod_delayed_work(amt_wq, &gnode->group_timer,\n\t\t\t\t\t      msecs_to_jiffies(amt_gmi(amt))))\n\t\t\t\tdev_hold(amt->dev);\n\t\t}\n\t}\n}\n\n \nstatic void amt_igmpv2_leave_handler(struct amt_dev *amt, struct sk_buff *skb,\n\t\t\t\t     struct amt_tunnel_list *tunnel)\n{\n\tstruct igmphdr *ih = igmp_hdr(skb);\n\tstruct iphdr *iph = ip_hdr(skb);\n\tstruct amt_group_node *gnode;\n\tunion amt_addr group, host;\n\n\tmemset(&group, 0, sizeof(union amt_addr));\n\tgroup.ip4 = ih->group;\n\tmemset(&host, 0, sizeof(union amt_addr));\n\thost.ip4 = iph->saddr;\n\n\tgnode = amt_lookup_group(tunnel, &group, &host, false);\n\tif (gnode)\n\t\tamt_del_group(amt, gnode);\n}\n\nstatic void amt_igmpv3_report_handler(struct amt_dev *amt, struct sk_buff *skb,\n\t\t\t\t      struct amt_tunnel_list *tunnel)\n{\n\tstruct igmpv3_report *ihrv3 = igmpv3_report_hdr(skb);\n\tint len = skb_transport_offset(skb) + sizeof(*ihrv3);\n\tvoid *zero_grec = (void *)&igmpv3_zero_grec;\n\tstruct iphdr *iph = ip_hdr(skb);\n\tstruct amt_group_node *gnode;\n\tunion amt_addr group, host;\n\tstruct igmpv3_grec *grec;\n\tu16 nsrcs;\n\tint i;\n\n\tfor (i = 0; i < ntohs(ihrv3->ngrec); i++) {\n\t\tlen += sizeof(*grec);\n\t\tif (!ip_mc_may_pull(skb, len))\n\t\t\tbreak;\n\n\t\tgrec = (void *)(skb->data + len - sizeof(*grec));\n\t\tnsrcs = ntohs(grec->grec_nsrcs);\n\n\t\tlen += nsrcs * sizeof(__be32);\n\t\tif (!ip_mc_may_pull(skb, len))\n\t\t\tbreak;\n\n\t\tmemset(&group, 0, sizeof(union amt_addr));\n\t\tgroup.ip4 = grec->grec_mca;\n\t\tmemset(&host, 0, sizeof(union amt_addr));\n\t\thost.ip4 = iph->saddr;\n\t\tgnode = amt_lookup_group(tunnel, &group, &host, false);\n\t\tif (!gnode) {\n\t\t\tgnode = amt_add_group(amt, tunnel, &group, &host,\n\t\t\t\t\t      false);\n\t\t\tif (IS_ERR(gnode))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tamt_add_srcs(amt, tunnel, gnode, grec, false);\n\t\tswitch (grec->grec_type) {\n\t\tcase IGMPV3_MODE_IS_INCLUDE:\n\t\t\tamt_mcast_is_in_handler(amt, tunnel, gnode, grec,\n\t\t\t\t\t\tzero_grec, false);\n\t\t\tbreak;\n\t\tcase IGMPV3_MODE_IS_EXCLUDE:\n\t\t\tamt_mcast_is_ex_handler(amt, tunnel, gnode, grec,\n\t\t\t\t\t\tzero_grec, false);\n\t\t\tbreak;\n\t\tcase IGMPV3_CHANGE_TO_INCLUDE:\n\t\t\tamt_mcast_to_in_handler(amt, tunnel, gnode, grec,\n\t\t\t\t\t\tzero_grec, false);\n\t\t\tbreak;\n\t\tcase IGMPV3_CHANGE_TO_EXCLUDE:\n\t\t\tamt_mcast_to_ex_handler(amt, tunnel, gnode, grec,\n\t\t\t\t\t\tzero_grec, false);\n\t\t\tbreak;\n\t\tcase IGMPV3_ALLOW_NEW_SOURCES:\n\t\t\tamt_mcast_allow_handler(amt, tunnel, gnode, grec,\n\t\t\t\t\t\tzero_grec, false);\n\t\t\tbreak;\n\t\tcase IGMPV3_BLOCK_OLD_SOURCES:\n\t\t\tamt_mcast_block_handler(amt, tunnel, gnode, grec,\n\t\t\t\t\t\tzero_grec, false);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tamt_cleanup_srcs(amt, tunnel, gnode);\n\t}\n}\n\n \nstatic void amt_igmp_report_handler(struct amt_dev *amt, struct sk_buff *skb,\n\t\t\t\t    struct amt_tunnel_list *tunnel)\n{\n\tstruct igmphdr *ih = igmp_hdr(skb);\n\n\tswitch (ih->type) {\n\tcase IGMPV3_HOST_MEMBERSHIP_REPORT:\n\t\tamt_igmpv3_report_handler(amt, skb, tunnel);\n\t\tbreak;\n\tcase IGMPV2_HOST_MEMBERSHIP_REPORT:\n\t\tamt_igmpv2_report_handler(amt, skb, tunnel);\n\t\tbreak;\n\tcase IGMP_HOST_LEAVE_MESSAGE:\n\t\tamt_igmpv2_leave_handler(amt, skb, tunnel);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\n \nstatic void amt_mldv1_report_handler(struct amt_dev *amt, struct sk_buff *skb,\n\t\t\t\t     struct amt_tunnel_list *tunnel)\n{\n\tstruct mld_msg *mld = (struct mld_msg *)icmp6_hdr(skb);\n\tstruct ipv6hdr *ip6h = ipv6_hdr(skb);\n\tstruct amt_group_node *gnode;\n\tunion amt_addr group, host;\n\n\tmemcpy(&group.ip6, &mld->mld_mca, sizeof(struct in6_addr));\n\tmemcpy(&host.ip6, &ip6h->saddr, sizeof(struct in6_addr));\n\n\tgnode = amt_lookup_group(tunnel, &group, &host, true);\n\tif (!gnode) {\n\t\tgnode = amt_add_group(amt, tunnel, &group, &host, true);\n\t\tif (!IS_ERR(gnode)) {\n\t\t\tgnode->filter_mode = MCAST_EXCLUDE;\n\t\t\tif (!mod_delayed_work(amt_wq, &gnode->group_timer,\n\t\t\t\t\t      msecs_to_jiffies(amt_gmi(amt))))\n\t\t\t\tdev_hold(amt->dev);\n\t\t}\n\t}\n}\n\n \nstatic void amt_mldv1_leave_handler(struct amt_dev *amt, struct sk_buff *skb,\n\t\t\t\t    struct amt_tunnel_list *tunnel)\n{\n\tstruct mld_msg *mld = (struct mld_msg *)icmp6_hdr(skb);\n\tstruct iphdr *iph = ip_hdr(skb);\n\tstruct amt_group_node *gnode;\n\tunion amt_addr group, host;\n\n\tmemcpy(&group.ip6, &mld->mld_mca, sizeof(struct in6_addr));\n\tmemset(&host, 0, sizeof(union amt_addr));\n\thost.ip4 = iph->saddr;\n\n\tgnode = amt_lookup_group(tunnel, &group, &host, true);\n\tif (gnode) {\n\t\tamt_del_group(amt, gnode);\n\t\treturn;\n\t}\n}\n\nstatic void amt_mldv2_report_handler(struct amt_dev *amt, struct sk_buff *skb,\n\t\t\t\t     struct amt_tunnel_list *tunnel)\n{\n\tstruct mld2_report *mld2r = (struct mld2_report *)icmp6_hdr(skb);\n\tint len = skb_transport_offset(skb) + sizeof(*mld2r);\n\tvoid *zero_grec = (void *)&mldv2_zero_grec;\n\tstruct ipv6hdr *ip6h = ipv6_hdr(skb);\n\tstruct amt_group_node *gnode;\n\tunion amt_addr group, host;\n\tstruct mld2_grec *grec;\n\tu16 nsrcs;\n\tint i;\n\n\tfor (i = 0; i < ntohs(mld2r->mld2r_ngrec); i++) {\n\t\tlen += sizeof(*grec);\n\t\tif (!ipv6_mc_may_pull(skb, len))\n\t\t\tbreak;\n\n\t\tgrec = (void *)(skb->data + len - sizeof(*grec));\n\t\tnsrcs = ntohs(grec->grec_nsrcs);\n\n\t\tlen += nsrcs * sizeof(struct in6_addr);\n\t\tif (!ipv6_mc_may_pull(skb, len))\n\t\t\tbreak;\n\n\t\tmemset(&group, 0, sizeof(union amt_addr));\n\t\tgroup.ip6 = grec->grec_mca;\n\t\tmemset(&host, 0, sizeof(union amt_addr));\n\t\thost.ip6 = ip6h->saddr;\n\t\tgnode = amt_lookup_group(tunnel, &group, &host, true);\n\t\tif (!gnode) {\n\t\t\tgnode = amt_add_group(amt, tunnel, &group, &host,\n\t\t\t\t\t      ETH_P_IPV6);\n\t\t\tif (IS_ERR(gnode))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tamt_add_srcs(amt, tunnel, gnode, grec, true);\n\t\tswitch (grec->grec_type) {\n\t\tcase MLD2_MODE_IS_INCLUDE:\n\t\t\tamt_mcast_is_in_handler(amt, tunnel, gnode, grec,\n\t\t\t\t\t\tzero_grec, true);\n\t\t\tbreak;\n\t\tcase MLD2_MODE_IS_EXCLUDE:\n\t\t\tamt_mcast_is_ex_handler(amt, tunnel, gnode, grec,\n\t\t\t\t\t\tzero_grec, true);\n\t\t\tbreak;\n\t\tcase MLD2_CHANGE_TO_INCLUDE:\n\t\t\tamt_mcast_to_in_handler(amt, tunnel, gnode, grec,\n\t\t\t\t\t\tzero_grec, true);\n\t\t\tbreak;\n\t\tcase MLD2_CHANGE_TO_EXCLUDE:\n\t\t\tamt_mcast_to_ex_handler(amt, tunnel, gnode, grec,\n\t\t\t\t\t\tzero_grec, true);\n\t\t\tbreak;\n\t\tcase MLD2_ALLOW_NEW_SOURCES:\n\t\t\tamt_mcast_allow_handler(amt, tunnel, gnode, grec,\n\t\t\t\t\t\tzero_grec, true);\n\t\t\tbreak;\n\t\tcase MLD2_BLOCK_OLD_SOURCES:\n\t\t\tamt_mcast_block_handler(amt, tunnel, gnode, grec,\n\t\t\t\t\t\tzero_grec, true);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tamt_cleanup_srcs(amt, tunnel, gnode);\n\t}\n}\n\n \nstatic void amt_mld_report_handler(struct amt_dev *amt, struct sk_buff *skb,\n\t\t\t\t   struct amt_tunnel_list *tunnel)\n{\n\tstruct mld_msg *mld = (struct mld_msg *)icmp6_hdr(skb);\n\n\tswitch (mld->mld_type) {\n\tcase ICMPV6_MGM_REPORT:\n\t\tamt_mldv1_report_handler(amt, skb, tunnel);\n\t\tbreak;\n\tcase ICMPV6_MLD2_REPORT:\n\t\tamt_mldv2_report_handler(amt, skb, tunnel);\n\t\tbreak;\n\tcase ICMPV6_MGM_REDUCTION:\n\t\tamt_mldv1_leave_handler(amt, skb, tunnel);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n#endif\n\nstatic bool amt_advertisement_handler(struct amt_dev *amt, struct sk_buff *skb)\n{\n\tstruct amt_header_advertisement *amta;\n\tint hdr_size;\n\n\thdr_size = sizeof(*amta) + sizeof(struct udphdr);\n\tif (!pskb_may_pull(skb, hdr_size))\n\t\treturn true;\n\n\tamta = (struct amt_header_advertisement *)(udp_hdr(skb) + 1);\n\tif (!amta->ip4)\n\t\treturn true;\n\n\tif (amta->reserved || amta->version)\n\t\treturn true;\n\n\tif (ipv4_is_loopback(amta->ip4) || ipv4_is_multicast(amta->ip4) ||\n\t    ipv4_is_zeronet(amta->ip4))\n\t\treturn true;\n\n\tif (amt->status != AMT_STATUS_SENT_DISCOVERY ||\n\t    amt->nonce != amta->nonce)\n\t\treturn true;\n\n\tamt->remote_ip = amta->ip4;\n\tnetdev_dbg(amt->dev, \"advertised remote ip = %pI4\\n\", &amt->remote_ip);\n\tmod_delayed_work(amt_wq, &amt->req_wq, 0);\n\n\tamt_update_gw_status(amt, AMT_STATUS_RECEIVED_ADVERTISEMENT, true);\n\treturn false;\n}\n\nstatic bool amt_multicast_data_handler(struct amt_dev *amt, struct sk_buff *skb)\n{\n\tstruct amt_header_mcast_data *amtmd;\n\tint hdr_size, len, err;\n\tstruct ethhdr *eth;\n\tstruct iphdr *iph;\n\n\tif (READ_ONCE(amt->status) != AMT_STATUS_SENT_UPDATE)\n\t\treturn true;\n\n\thdr_size = sizeof(*amtmd) + sizeof(struct udphdr);\n\tif (!pskb_may_pull(skb, hdr_size))\n\t\treturn true;\n\n\tamtmd = (struct amt_header_mcast_data *)(udp_hdr(skb) + 1);\n\tif (amtmd->reserved || amtmd->version)\n\t\treturn true;\n\n\tif (iptunnel_pull_header(skb, hdr_size, htons(ETH_P_IP), false))\n\t\treturn true;\n\n\tskb_reset_network_header(skb);\n\tskb_push(skb, sizeof(*eth));\n\tskb_reset_mac_header(skb);\n\tskb_pull(skb, sizeof(*eth));\n\teth = eth_hdr(skb);\n\n\tif (!pskb_may_pull(skb, sizeof(*iph)))\n\t\treturn true;\n\tiph = ip_hdr(skb);\n\n\tif (iph->version == 4) {\n\t\tif (!ipv4_is_multicast(iph->daddr))\n\t\t\treturn true;\n\t\tskb->protocol = htons(ETH_P_IP);\n\t\teth->h_proto = htons(ETH_P_IP);\n\t\tip_eth_mc_map(iph->daddr, eth->h_dest);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (iph->version == 6) {\n\t\tstruct ipv6hdr *ip6h;\n\n\t\tif (!pskb_may_pull(skb, sizeof(*ip6h)))\n\t\t\treturn true;\n\n\t\tip6h = ipv6_hdr(skb);\n\t\tif (!ipv6_addr_is_multicast(&ip6h->daddr))\n\t\t\treturn true;\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\teth->h_proto = htons(ETH_P_IPV6);\n\t\tipv6_eth_mc_map(&ip6h->daddr, eth->h_dest);\n#endif\n\t} else {\n\t\treturn true;\n\t}\n\n\tskb->pkt_type = PACKET_MULTICAST;\n\tskb->ip_summed = CHECKSUM_NONE;\n\tlen = skb->len;\n\terr = gro_cells_receive(&amt->gro_cells, skb);\n\tif (likely(err == NET_RX_SUCCESS))\n\t\tdev_sw_netstats_rx_add(amt->dev, len);\n\telse\n\t\tamt->dev->stats.rx_dropped++;\n\n\treturn false;\n}\n\nstatic bool amt_membership_query_handler(struct amt_dev *amt,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct amt_header_membership_query *amtmq;\n\tstruct igmpv3_query *ihv3;\n\tstruct ethhdr *eth, *oeth;\n\tstruct iphdr *iph;\n\tint hdr_size, len;\n\n\thdr_size = sizeof(*amtmq) + sizeof(struct udphdr);\n\tif (!pskb_may_pull(skb, hdr_size))\n\t\treturn true;\n\n\tamtmq = (struct amt_header_membership_query *)(udp_hdr(skb) + 1);\n\tif (amtmq->reserved || amtmq->version)\n\t\treturn true;\n\n\tif (amtmq->nonce != amt->nonce)\n\t\treturn true;\n\n\thdr_size -= sizeof(*eth);\n\tif (iptunnel_pull_header(skb, hdr_size, htons(ETH_P_TEB), false))\n\t\treturn true;\n\n\toeth = eth_hdr(skb);\n\tskb_reset_mac_header(skb);\n\tskb_pull(skb, sizeof(*eth));\n\tskb_reset_network_header(skb);\n\teth = eth_hdr(skb);\n\tif (!pskb_may_pull(skb, sizeof(*iph)))\n\t\treturn true;\n\n\tiph = ip_hdr(skb);\n\tif (iph->version == 4) {\n\t\tif (READ_ONCE(amt->ready4))\n\t\t\treturn true;\n\n\t\tif (!pskb_may_pull(skb, sizeof(*iph) + AMT_IPHDR_OPTS +\n\t\t\t\t   sizeof(*ihv3)))\n\t\t\treturn true;\n\n\t\tif (!ipv4_is_multicast(iph->daddr))\n\t\t\treturn true;\n\n\t\tihv3 = skb_pull(skb, sizeof(*iph) + AMT_IPHDR_OPTS);\n\t\tskb_reset_transport_header(skb);\n\t\tskb_push(skb, sizeof(*iph) + AMT_IPHDR_OPTS);\n\t\tWRITE_ONCE(amt->ready4, true);\n\t\tamt->mac = amtmq->response_mac;\n\t\tamt->req_cnt = 0;\n\t\tamt->qi = ihv3->qqic;\n\t\tskb->protocol = htons(ETH_P_IP);\n\t\teth->h_proto = htons(ETH_P_IP);\n\t\tip_eth_mc_map(iph->daddr, eth->h_dest);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (iph->version == 6) {\n\t\tstruct mld2_query *mld2q;\n\t\tstruct ipv6hdr *ip6h;\n\n\t\tif (READ_ONCE(amt->ready6))\n\t\t\treturn true;\n\n\t\tif (!pskb_may_pull(skb, sizeof(*ip6h) + AMT_IP6HDR_OPTS +\n\t\t\t\t   sizeof(*mld2q)))\n\t\t\treturn true;\n\n\t\tip6h = ipv6_hdr(skb);\n\t\tif (!ipv6_addr_is_multicast(&ip6h->daddr))\n\t\t\treturn true;\n\n\t\tmld2q = skb_pull(skb, sizeof(*ip6h) + AMT_IP6HDR_OPTS);\n\t\tskb_reset_transport_header(skb);\n\t\tskb_push(skb, sizeof(*ip6h) + AMT_IP6HDR_OPTS);\n\t\tWRITE_ONCE(amt->ready6, true);\n\t\tamt->mac = amtmq->response_mac;\n\t\tamt->req_cnt = 0;\n\t\tamt->qi = mld2q->mld2q_qqic;\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\teth->h_proto = htons(ETH_P_IPV6);\n\t\tipv6_eth_mc_map(&ip6h->daddr, eth->h_dest);\n#endif\n\t} else {\n\t\treturn true;\n\t}\n\n\tether_addr_copy(eth->h_source, oeth->h_source);\n\tskb->pkt_type = PACKET_MULTICAST;\n\tskb->ip_summed = CHECKSUM_NONE;\n\tlen = skb->len;\n\tlocal_bh_disable();\n\tif (__netif_rx(skb) == NET_RX_SUCCESS) {\n\t\tamt_update_gw_status(amt, AMT_STATUS_RECEIVED_QUERY, true);\n\t\tdev_sw_netstats_rx_add(amt->dev, len);\n\t} else {\n\t\tamt->dev->stats.rx_dropped++;\n\t}\n\tlocal_bh_enable();\n\n\treturn false;\n}\n\nstatic bool amt_update_handler(struct amt_dev *amt, struct sk_buff *skb)\n{\n\tstruct amt_header_membership_update *amtmu;\n\tstruct amt_tunnel_list *tunnel;\n\tstruct ethhdr *eth;\n\tstruct iphdr *iph;\n\tint len, hdr_size;\n\n\tiph = ip_hdr(skb);\n\n\thdr_size = sizeof(*amtmu) + sizeof(struct udphdr);\n\tif (!pskb_may_pull(skb, hdr_size))\n\t\treturn true;\n\n\tamtmu = (struct amt_header_membership_update *)(udp_hdr(skb) + 1);\n\tif (amtmu->reserved || amtmu->version)\n\t\treturn true;\n\n\tif (iptunnel_pull_header(skb, hdr_size, skb->protocol, false))\n\t\treturn true;\n\n\tskb_reset_network_header(skb);\n\n\tlist_for_each_entry_rcu(tunnel, &amt->tunnel_list, list) {\n\t\tif (tunnel->ip4 == iph->saddr) {\n\t\t\tif ((amtmu->nonce == tunnel->nonce &&\n\t\t\t     amtmu->response_mac == tunnel->mac)) {\n\t\t\t\tmod_delayed_work(amt_wq, &tunnel->gc_wq,\n\t\t\t\t\t\t msecs_to_jiffies(amt_gmi(amt))\n\t\t\t\t\t\t\t\t  * 3);\n\t\t\t\tgoto report;\n\t\t\t} else {\n\t\t\t\tnetdev_dbg(amt->dev, \"Invalid MAC\\n\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n\nreport:\n\tif (!pskb_may_pull(skb, sizeof(*iph)))\n\t\treturn true;\n\n\tiph = ip_hdr(skb);\n\tif (iph->version == 4) {\n\t\tif (ip_mc_check_igmp(skb)) {\n\t\t\tnetdev_dbg(amt->dev, \"Invalid IGMP\\n\");\n\t\t\treturn true;\n\t\t}\n\n\t\tspin_lock_bh(&tunnel->lock);\n\t\tamt_igmp_report_handler(amt, skb, tunnel);\n\t\tspin_unlock_bh(&tunnel->lock);\n\n\t\tskb_push(skb, sizeof(struct ethhdr));\n\t\tskb_reset_mac_header(skb);\n\t\teth = eth_hdr(skb);\n\t\tskb->protocol = htons(ETH_P_IP);\n\t\teth->h_proto = htons(ETH_P_IP);\n\t\tip_eth_mc_map(iph->daddr, eth->h_dest);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (iph->version == 6) {\n\t\tstruct ipv6hdr *ip6h = ipv6_hdr(skb);\n\n\t\tif (ipv6_mc_check_mld(skb)) {\n\t\t\tnetdev_dbg(amt->dev, \"Invalid MLD\\n\");\n\t\t\treturn true;\n\t\t}\n\n\t\tspin_lock_bh(&tunnel->lock);\n\t\tamt_mld_report_handler(amt, skb, tunnel);\n\t\tspin_unlock_bh(&tunnel->lock);\n\n\t\tskb_push(skb, sizeof(struct ethhdr));\n\t\tskb_reset_mac_header(skb);\n\t\teth = eth_hdr(skb);\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\teth->h_proto = htons(ETH_P_IPV6);\n\t\tipv6_eth_mc_map(&ip6h->daddr, eth->h_dest);\n#endif\n\t} else {\n\t\tnetdev_dbg(amt->dev, \"Unsupported Protocol\\n\");\n\t\treturn true;\n\t}\n\n\tskb_pull(skb, sizeof(struct ethhdr));\n\tskb->pkt_type = PACKET_MULTICAST;\n\tskb->ip_summed = CHECKSUM_NONE;\n\tlen = skb->len;\n\tif (__netif_rx(skb) == NET_RX_SUCCESS) {\n\t\tamt_update_relay_status(tunnel, AMT_STATUS_RECEIVED_UPDATE,\n\t\t\t\t\ttrue);\n\t\tdev_sw_netstats_rx_add(amt->dev, len);\n\t} else {\n\t\tamt->dev->stats.rx_dropped++;\n\t}\n\n\treturn false;\n}\n\nstatic void amt_send_advertisement(struct amt_dev *amt, __be32 nonce,\n\t\t\t\t   __be32 daddr, __be16 dport)\n{\n\tstruct amt_header_advertisement *amta;\n\tint hlen, tlen, offset;\n\tstruct socket *sock;\n\tstruct udphdr *udph;\n\tstruct sk_buff *skb;\n\tstruct iphdr *iph;\n\tstruct rtable *rt;\n\tstruct flowi4 fl4;\n\tu32 len;\n\tint err;\n\n\trcu_read_lock();\n\tsock = rcu_dereference(amt->sock);\n\tif (!sock)\n\t\tgoto out;\n\n\tif (!netif_running(amt->stream_dev) || !netif_running(amt->dev))\n\t\tgoto out;\n\n\trt = ip_route_output_ports(amt->net, &fl4, sock->sk,\n\t\t\t\t   daddr, amt->local_ip,\n\t\t\t\t   dport, amt->relay_port,\n\t\t\t\t   IPPROTO_UDP, 0,\n\t\t\t\t   amt->stream_dev->ifindex);\n\tif (IS_ERR(rt)) {\n\t\tamt->dev->stats.tx_errors++;\n\t\tgoto out;\n\t}\n\n\thlen = LL_RESERVED_SPACE(amt->dev);\n\ttlen = amt->dev->needed_tailroom;\n\tlen = hlen + tlen + sizeof(*iph) + sizeof(*udph) + sizeof(*amta);\n\tskb = netdev_alloc_skb_ip_align(amt->dev, len);\n\tif (!skb) {\n\t\tip_rt_put(rt);\n\t\tamt->dev->stats.tx_errors++;\n\t\tgoto out;\n\t}\n\n\tskb->priority = TC_PRIO_CONTROL;\n\tskb_dst_set(skb, &rt->dst);\n\n\tlen = sizeof(*iph) + sizeof(*udph) + sizeof(*amta);\n\tskb_reset_network_header(skb);\n\tskb_put(skb, len);\n\tamta = skb_pull(skb, sizeof(*iph) + sizeof(*udph));\n\tamta->version\t= 0;\n\tamta->type\t= AMT_MSG_ADVERTISEMENT;\n\tamta->reserved\t= 0;\n\tamta->nonce\t= nonce;\n\tamta->ip4\t= amt->local_ip;\n\tskb_push(skb, sizeof(*udph));\n\tskb_reset_transport_header(skb);\n\tudph\t\t= udp_hdr(skb);\n\tudph->source\t= amt->relay_port;\n\tudph->dest\t= dport;\n\tudph->len\t= htons(sizeof(*amta) + sizeof(*udph));\n\tudph->check\t= 0;\n\toffset = skb_transport_offset(skb);\n\tskb->csum = skb_checksum(skb, offset, skb->len - offset, 0);\n\tudph->check = csum_tcpudp_magic(amt->local_ip, daddr,\n\t\t\t\t\tsizeof(*udph) + sizeof(*amta),\n\t\t\t\t\tIPPROTO_UDP, skb->csum);\n\n\tskb_push(skb, sizeof(*iph));\n\tiph\t\t= ip_hdr(skb);\n\tiph->version\t= 4;\n\tiph->ihl\t= (sizeof(struct iphdr)) >> 2;\n\tiph->tos\t= AMT_TOS;\n\tiph->frag_off\t= 0;\n\tiph->ttl\t= ip4_dst_hoplimit(&rt->dst);\n\tiph->daddr\t= daddr;\n\tiph->saddr\t= amt->local_ip;\n\tiph->protocol\t= IPPROTO_UDP;\n\tiph->tot_len\t= htons(len);\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\tip_select_ident(amt->net, skb, NULL);\n\tip_send_check(iph);\n\terr = ip_local_out(amt->net, sock->sk, skb);\n\tif (unlikely(net_xmit_eval(err)))\n\t\tamt->dev->stats.tx_errors++;\n\nout:\n\trcu_read_unlock();\n}\n\nstatic bool amt_discovery_handler(struct amt_dev *amt, struct sk_buff *skb)\n{\n\tstruct amt_header_discovery *amtd;\n\tstruct udphdr *udph;\n\tstruct iphdr *iph;\n\n\tif (!pskb_may_pull(skb, sizeof(*udph) + sizeof(*amtd)))\n\t\treturn true;\n\n\tiph = ip_hdr(skb);\n\tudph = udp_hdr(skb);\n\tamtd = (struct amt_header_discovery *)(udp_hdr(skb) + 1);\n\n\tif (amtd->reserved || amtd->version)\n\t\treturn true;\n\n\tamt_send_advertisement(amt, amtd->nonce, iph->saddr, udph->source);\n\n\treturn false;\n}\n\nstatic bool amt_request_handler(struct amt_dev *amt, struct sk_buff *skb)\n{\n\tstruct amt_header_request *amtrh;\n\tstruct amt_tunnel_list *tunnel;\n\tunsigned long long key;\n\tstruct udphdr *udph;\n\tstruct iphdr *iph;\n\tu64 mac;\n\tint i;\n\n\tif (!pskb_may_pull(skb, sizeof(*udph) + sizeof(*amtrh)))\n\t\treturn true;\n\n\tiph = ip_hdr(skb);\n\tudph = udp_hdr(skb);\n\tamtrh = (struct amt_header_request *)(udp_hdr(skb) + 1);\n\n\tif (amtrh->reserved1 || amtrh->reserved2 || amtrh->version)\n\t\treturn true;\n\n\tlist_for_each_entry_rcu(tunnel, &amt->tunnel_list, list)\n\t\tif (tunnel->ip4 == iph->saddr)\n\t\t\tgoto send;\n\n\tspin_lock_bh(&amt->lock);\n\tif (amt->nr_tunnels >= amt->max_tunnels) {\n\t\tspin_unlock_bh(&amt->lock);\n\t\ticmp_ndo_send(skb, ICMP_DEST_UNREACH, ICMP_HOST_UNREACH, 0);\n\t\treturn true;\n\t}\n\n\ttunnel = kzalloc(sizeof(*tunnel) +\n\t\t\t (sizeof(struct hlist_head) * amt->hash_buckets),\n\t\t\t GFP_ATOMIC);\n\tif (!tunnel) {\n\t\tspin_unlock_bh(&amt->lock);\n\t\treturn true;\n\t}\n\n\ttunnel->source_port = udph->source;\n\ttunnel->ip4 = iph->saddr;\n\n\tmemcpy(&key, &tunnel->key, sizeof(unsigned long long));\n\ttunnel->amt = amt;\n\tspin_lock_init(&tunnel->lock);\n\tfor (i = 0; i < amt->hash_buckets; i++)\n\t\tINIT_HLIST_HEAD(&tunnel->groups[i]);\n\n\tINIT_DELAYED_WORK(&tunnel->gc_wq, amt_tunnel_expire);\n\n\tlist_add_tail_rcu(&tunnel->list, &amt->tunnel_list);\n\ttunnel->key = amt->key;\n\t__amt_update_relay_status(tunnel, AMT_STATUS_RECEIVED_REQUEST, true);\n\tamt->nr_tunnels++;\n\tmod_delayed_work(amt_wq, &tunnel->gc_wq,\n\t\t\t msecs_to_jiffies(amt_gmi(amt)));\n\tspin_unlock_bh(&amt->lock);\n\nsend:\n\ttunnel->nonce = amtrh->nonce;\n\tmac = siphash_3u32((__force u32)tunnel->ip4,\n\t\t\t   (__force u32)tunnel->source_port,\n\t\t\t   (__force u32)tunnel->nonce,\n\t\t\t   &tunnel->key);\n\ttunnel->mac = mac >> 16;\n\n\tif (!netif_running(amt->dev) || !netif_running(amt->stream_dev))\n\t\treturn true;\n\n\tif (!amtrh->p)\n\t\tamt_send_igmp_gq(amt, tunnel);\n\telse\n\t\tamt_send_mld_gq(amt, tunnel);\n\n\treturn false;\n}\n\nstatic void amt_gw_rcv(struct amt_dev *amt, struct sk_buff *skb)\n{\n\tint type = amt_parse_type(skb);\n\tint err = 1;\n\n\tif (type == -1)\n\t\tgoto drop;\n\n\tif (amt->mode == AMT_MODE_GATEWAY) {\n\t\tswitch (type) {\n\t\tcase AMT_MSG_ADVERTISEMENT:\n\t\t\terr = amt_advertisement_handler(amt, skb);\n\t\t\tbreak;\n\t\tcase AMT_MSG_MEMBERSHIP_QUERY:\n\t\t\terr = amt_membership_query_handler(amt, skb);\n\t\t\tif (!err)\n\t\t\t\treturn;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetdev_dbg(amt->dev, \"Invalid type of Gateway\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\ndrop:\n\tif (err) {\n\t\tamt->dev->stats.rx_dropped++;\n\t\tkfree_skb(skb);\n\t} else {\n\t\tconsume_skb(skb);\n\t}\n}\n\nstatic int amt_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct amt_dev *amt;\n\tstruct iphdr *iph;\n\tint type;\n\tbool err;\n\n\trcu_read_lock_bh();\n\tamt = rcu_dereference_sk_user_data(sk);\n\tif (!amt) {\n\t\terr = true;\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tskb->dev = amt->dev;\n\tiph = ip_hdr(skb);\n\ttype = amt_parse_type(skb);\n\tif (type == -1) {\n\t\terr = true;\n\t\tgoto drop;\n\t}\n\n\tif (amt->mode == AMT_MODE_GATEWAY) {\n\t\tswitch (type) {\n\t\tcase AMT_MSG_ADVERTISEMENT:\n\t\t\tif (iph->saddr != amt->discovery_ip) {\n\t\t\t\tnetdev_dbg(amt->dev, \"Invalid Relay IP\\n\");\n\t\t\t\terr = true;\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\tif (amt_queue_event(amt, AMT_EVENT_RECEIVE, skb)) {\n\t\t\t\tnetdev_dbg(amt->dev, \"AMT Event queue full\\n\");\n\t\t\t\terr = true;\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\tgoto out;\n\t\tcase AMT_MSG_MULTICAST_DATA:\n\t\t\tif (iph->saddr != amt->remote_ip) {\n\t\t\t\tnetdev_dbg(amt->dev, \"Invalid Relay IP\\n\");\n\t\t\t\terr = true;\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\terr = amt_multicast_data_handler(amt, skb);\n\t\t\tif (err)\n\t\t\t\tgoto drop;\n\t\t\telse\n\t\t\t\tgoto out;\n\t\tcase AMT_MSG_MEMBERSHIP_QUERY:\n\t\t\tif (iph->saddr != amt->remote_ip) {\n\t\t\t\tnetdev_dbg(amt->dev, \"Invalid Relay IP\\n\");\n\t\t\t\terr = true;\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\tif (amt_queue_event(amt, AMT_EVENT_RECEIVE, skb)) {\n\t\t\t\tnetdev_dbg(amt->dev, \"AMT Event queue full\\n\");\n\t\t\t\terr = true;\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\terr = true;\n\t\t\tnetdev_dbg(amt->dev, \"Invalid type of Gateway\\n\");\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (type) {\n\t\tcase AMT_MSG_DISCOVERY:\n\t\t\terr = amt_discovery_handler(amt, skb);\n\t\t\tbreak;\n\t\tcase AMT_MSG_REQUEST:\n\t\t\terr = amt_request_handler(amt, skb);\n\t\t\tbreak;\n\t\tcase AMT_MSG_MEMBERSHIP_UPDATE:\n\t\t\terr = amt_update_handler(amt, skb);\n\t\t\tif (err)\n\t\t\t\tgoto drop;\n\t\t\telse\n\t\t\t\tgoto out;\n\t\tdefault:\n\t\t\terr = true;\n\t\t\tnetdev_dbg(amt->dev, \"Invalid type of relay\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\ndrop:\n\tif (err) {\n\t\tamt->dev->stats.rx_dropped++;\n\t\tkfree_skb(skb);\n\t} else {\n\t\tconsume_skb(skb);\n\t}\nout:\n\trcu_read_unlock_bh();\n\treturn 0;\n}\n\nstatic void amt_event_work(struct work_struct *work)\n{\n\tstruct amt_dev *amt = container_of(work, struct amt_dev, event_wq);\n\tstruct sk_buff *skb;\n\tu8 event;\n\tint i;\n\n\tfor (i = 0; i < AMT_MAX_EVENTS; i++) {\n\t\tspin_lock_bh(&amt->lock);\n\t\tif (amt->nr_events == 0) {\n\t\t\tspin_unlock_bh(&amt->lock);\n\t\t\treturn;\n\t\t}\n\t\tevent = amt->events[amt->event_idx].event;\n\t\tskb = amt->events[amt->event_idx].skb;\n\t\tamt->events[amt->event_idx].event = AMT_EVENT_NONE;\n\t\tamt->events[amt->event_idx].skb = NULL;\n\t\tamt->nr_events--;\n\t\tamt->event_idx++;\n\t\tamt->event_idx %= AMT_MAX_EVENTS;\n\t\tspin_unlock_bh(&amt->lock);\n\n\t\tswitch (event) {\n\t\tcase AMT_EVENT_RECEIVE:\n\t\t\tamt_gw_rcv(amt, skb);\n\t\t\tbreak;\n\t\tcase AMT_EVENT_SEND_DISCOVERY:\n\t\t\tamt_event_send_discovery(amt);\n\t\t\tbreak;\n\t\tcase AMT_EVENT_SEND_REQUEST:\n\t\t\tamt_event_send_request(amt);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tkfree_skb(skb);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int amt_err_lookup(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct amt_dev *amt;\n\tint type;\n\n\trcu_read_lock_bh();\n\tamt = rcu_dereference_sk_user_data(sk);\n\tif (!amt)\n\t\tgoto out;\n\n\tif (amt->mode != AMT_MODE_GATEWAY)\n\t\tgoto drop;\n\n\ttype = amt_parse_type(skb);\n\tif (type == -1)\n\t\tgoto drop;\n\n\tnetdev_dbg(amt->dev, \"Received IGMP Unreachable of %s\\n\",\n\t\t   type_str[type]);\n\tswitch (type) {\n\tcase AMT_MSG_DISCOVERY:\n\t\tbreak;\n\tcase AMT_MSG_REQUEST:\n\tcase AMT_MSG_MEMBERSHIP_UPDATE:\n\t\tif (READ_ONCE(amt->status) >= AMT_STATUS_RECEIVED_ADVERTISEMENT)\n\t\t\tmod_delayed_work(amt_wq, &amt->req_wq, 0);\n\t\tbreak;\n\tdefault:\n\t\tgoto drop;\n\t}\nout:\n\trcu_read_unlock_bh();\n\treturn 0;\ndrop:\n\trcu_read_unlock_bh();\n\tamt->dev->stats.rx_dropped++;\n\treturn 0;\n}\n\nstatic struct socket *amt_create_sock(struct net *net, __be16 port)\n{\n\tstruct udp_port_cfg udp_conf;\n\tstruct socket *sock;\n\tint err;\n\n\tmemset(&udp_conf, 0, sizeof(udp_conf));\n\tudp_conf.family = AF_INET;\n\tudp_conf.local_ip.s_addr = htonl(INADDR_ANY);\n\n\tudp_conf.local_udp_port = port;\n\n\terr = udp_sock_create(net, &udp_conf, &sock);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\treturn sock;\n}\n\nstatic int amt_socket_create(struct amt_dev *amt)\n{\n\tstruct udp_tunnel_sock_cfg tunnel_cfg;\n\tstruct socket *sock;\n\n\tsock = amt_create_sock(amt->net, amt->relay_port);\n\tif (IS_ERR(sock))\n\t\treturn PTR_ERR(sock);\n\n\t \n\tmemset(&tunnel_cfg, 0, sizeof(tunnel_cfg));\n\ttunnel_cfg.sk_user_data = amt;\n\ttunnel_cfg.encap_type = 1;\n\ttunnel_cfg.encap_rcv = amt_rcv;\n\ttunnel_cfg.encap_err_lookup = amt_err_lookup;\n\ttunnel_cfg.encap_destroy = NULL;\n\tsetup_udp_tunnel_sock(amt->net, sock, &tunnel_cfg);\n\n\trcu_assign_pointer(amt->sock, sock);\n\treturn 0;\n}\n\nstatic int amt_dev_open(struct net_device *dev)\n{\n\tstruct amt_dev *amt = netdev_priv(dev);\n\tint err;\n\n\tamt->ready4 = false;\n\tamt->ready6 = false;\n\tamt->event_idx = 0;\n\tamt->nr_events = 0;\n\n\terr = amt_socket_create(amt);\n\tif (err)\n\t\treturn err;\n\n\tamt->req_cnt = 0;\n\tamt->remote_ip = 0;\n\tamt->nonce = 0;\n\tget_random_bytes(&amt->key, sizeof(siphash_key_t));\n\n\tamt->status = AMT_STATUS_INIT;\n\tif (amt->mode == AMT_MODE_GATEWAY) {\n\t\tmod_delayed_work(amt_wq, &amt->discovery_wq, 0);\n\t\tmod_delayed_work(amt_wq, &amt->req_wq, 0);\n\t} else if (amt->mode == AMT_MODE_RELAY) {\n\t\tmod_delayed_work(amt_wq, &amt->secret_wq,\n\t\t\t\t msecs_to_jiffies(AMT_SECRET_TIMEOUT));\n\t}\n\treturn err;\n}\n\nstatic int amt_dev_stop(struct net_device *dev)\n{\n\tstruct amt_dev *amt = netdev_priv(dev);\n\tstruct amt_tunnel_list *tunnel, *tmp;\n\tstruct socket *sock;\n\tstruct sk_buff *skb;\n\tint i;\n\n\tcancel_delayed_work_sync(&amt->req_wq);\n\tcancel_delayed_work_sync(&amt->discovery_wq);\n\tcancel_delayed_work_sync(&amt->secret_wq);\n\n\t \n\tsock = rtnl_dereference(amt->sock);\n\tRCU_INIT_POINTER(amt->sock, NULL);\n\tsynchronize_net();\n\tif (sock)\n\t\tudp_tunnel_sock_release(sock);\n\n\tcancel_work_sync(&amt->event_wq);\n\tfor (i = 0; i < AMT_MAX_EVENTS; i++) {\n\t\tskb = amt->events[i].skb;\n\t\tkfree_skb(skb);\n\t\tamt->events[i].event = AMT_EVENT_NONE;\n\t\tamt->events[i].skb = NULL;\n\t}\n\n\tamt->ready4 = false;\n\tamt->ready6 = false;\n\tamt->req_cnt = 0;\n\tamt->remote_ip = 0;\n\n\tlist_for_each_entry_safe(tunnel, tmp, &amt->tunnel_list, list) {\n\t\tlist_del_rcu(&tunnel->list);\n\t\tamt->nr_tunnels--;\n\t\tcancel_delayed_work_sync(&tunnel->gc_wq);\n\t\tamt_clear_groups(tunnel);\n\t\tkfree_rcu(tunnel, rcu);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct device_type amt_type = {\n\t.name = \"amt\",\n};\n\nstatic int amt_dev_init(struct net_device *dev)\n{\n\tstruct amt_dev *amt = netdev_priv(dev);\n\tint err;\n\n\tamt->dev = dev;\n\tdev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\n\tif (!dev->tstats)\n\t\treturn -ENOMEM;\n\n\terr = gro_cells_init(&amt->gro_cells, dev);\n\tif (err) {\n\t\tfree_percpu(dev->tstats);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void amt_dev_uninit(struct net_device *dev)\n{\n\tstruct amt_dev *amt = netdev_priv(dev);\n\n\tgro_cells_destroy(&amt->gro_cells);\n\tfree_percpu(dev->tstats);\n}\n\nstatic const struct net_device_ops amt_netdev_ops = {\n\t.ndo_init               = amt_dev_init,\n\t.ndo_uninit             = amt_dev_uninit,\n\t.ndo_open\t\t= amt_dev_open,\n\t.ndo_stop\t\t= amt_dev_stop,\n\t.ndo_start_xmit         = amt_dev_xmit,\n\t.ndo_get_stats64        = dev_get_tstats64,\n};\n\nstatic void amt_link_setup(struct net_device *dev)\n{\n\tdev->netdev_ops         = &amt_netdev_ops;\n\tdev->needs_free_netdev  = true;\n\tSET_NETDEV_DEVTYPE(dev, &amt_type);\n\tdev->min_mtu\t\t= ETH_MIN_MTU;\n\tdev->max_mtu\t\t= ETH_MAX_MTU;\n\tdev->type\t\t= ARPHRD_NONE;\n\tdev->flags\t\t= IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\tdev->hard_header_len\t= 0;\n\tdev->addr_len\t\t= 0;\n\tdev->priv_flags\t\t|= IFF_NO_QUEUE;\n\tdev->features\t\t|= NETIF_F_LLTX;\n\tdev->features\t\t|= NETIF_F_GSO_SOFTWARE;\n\tdev->features\t\t|= NETIF_F_NETNS_LOCAL;\n\tdev->hw_features\t|= NETIF_F_SG | NETIF_F_HW_CSUM;\n\tdev->hw_features\t|= NETIF_F_FRAGLIST | NETIF_F_RXCSUM;\n\tdev->hw_features\t|= NETIF_F_GSO_SOFTWARE;\n\teth_hw_addr_random(dev);\n\teth_zero_addr(dev->broadcast);\n\tether_setup(dev);\n}\n\nstatic const struct nla_policy amt_policy[IFLA_AMT_MAX + 1] = {\n\t[IFLA_AMT_MODE]\t\t= { .type = NLA_U32 },\n\t[IFLA_AMT_RELAY_PORT]\t= { .type = NLA_U16 },\n\t[IFLA_AMT_GATEWAY_PORT]\t= { .type = NLA_U16 },\n\t[IFLA_AMT_LINK]\t\t= { .type = NLA_U32 },\n\t[IFLA_AMT_LOCAL_IP]\t= { .len = sizeof_field(struct iphdr, daddr) },\n\t[IFLA_AMT_REMOTE_IP]\t= { .len = sizeof_field(struct iphdr, daddr) },\n\t[IFLA_AMT_DISCOVERY_IP]\t= { .len = sizeof_field(struct iphdr, daddr) },\n\t[IFLA_AMT_MAX_TUNNELS]\t= { .type = NLA_U32 },\n};\n\nstatic int amt_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tif (!data[IFLA_AMT_LINK]) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, data[IFLA_AMT_LINK],\n\t\t\t\t    \"Link attribute is required\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!data[IFLA_AMT_MODE]) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, data[IFLA_AMT_MODE],\n\t\t\t\t    \"Mode attribute is required\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (nla_get_u32(data[IFLA_AMT_MODE]) > AMT_MODE_MAX) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, data[IFLA_AMT_MODE],\n\t\t\t\t    \"Mode attribute is not valid\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!data[IFLA_AMT_LOCAL_IP]) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, data[IFLA_AMT_DISCOVERY_IP],\n\t\t\t\t    \"Local attribute is required\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!data[IFLA_AMT_DISCOVERY_IP] &&\n\t    nla_get_u32(data[IFLA_AMT_MODE]) == AMT_MODE_GATEWAY) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, data[IFLA_AMT_LOCAL_IP],\n\t\t\t\t    \"Discovery attribute is required\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int amt_newlink(struct net *net, struct net_device *dev,\n\t\t       struct nlattr *tb[], struct nlattr *data[],\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct amt_dev *amt = netdev_priv(dev);\n\tint err = -EINVAL;\n\n\tamt->net = net;\n\tamt->mode = nla_get_u32(data[IFLA_AMT_MODE]);\n\n\tif (data[IFLA_AMT_MAX_TUNNELS] &&\n\t    nla_get_u32(data[IFLA_AMT_MAX_TUNNELS]))\n\t\tamt->max_tunnels = nla_get_u32(data[IFLA_AMT_MAX_TUNNELS]);\n\telse\n\t\tamt->max_tunnels = AMT_MAX_TUNNELS;\n\n\tspin_lock_init(&amt->lock);\n\tamt->max_groups = AMT_MAX_GROUP;\n\tamt->max_sources = AMT_MAX_SOURCE;\n\tamt->hash_buckets = AMT_HSIZE;\n\tamt->nr_tunnels = 0;\n\tget_random_bytes(&amt->hash_seed, sizeof(amt->hash_seed));\n\tamt->stream_dev = dev_get_by_index(net,\n\t\t\t\t\t   nla_get_u32(data[IFLA_AMT_LINK]));\n\tif (!amt->stream_dev) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, tb[IFLA_AMT_LINK],\n\t\t\t\t    \"Can't find stream device\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (amt->stream_dev->type != ARPHRD_ETHER) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, tb[IFLA_AMT_LINK],\n\t\t\t\t    \"Invalid stream device type\");\n\t\tgoto err;\n\t}\n\n\tamt->local_ip = nla_get_in_addr(data[IFLA_AMT_LOCAL_IP]);\n\tif (ipv4_is_loopback(amt->local_ip) ||\n\t    ipv4_is_zeronet(amt->local_ip) ||\n\t    ipv4_is_multicast(amt->local_ip)) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, tb[IFLA_AMT_LOCAL_IP],\n\t\t\t\t    \"Invalid Local address\");\n\t\tgoto err;\n\t}\n\n\tif (data[IFLA_AMT_RELAY_PORT])\n\t\tamt->relay_port = nla_get_be16(data[IFLA_AMT_RELAY_PORT]);\n\telse\n\t\tamt->relay_port = htons(IANA_AMT_UDP_PORT);\n\n\tif (data[IFLA_AMT_GATEWAY_PORT])\n\t\tamt->gw_port = nla_get_be16(data[IFLA_AMT_GATEWAY_PORT]);\n\telse\n\t\tamt->gw_port = htons(IANA_AMT_UDP_PORT);\n\n\tif (!amt->relay_port) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, tb[IFLA_AMT_DISCOVERY_IP],\n\t\t\t\t    \"relay port must not be 0\");\n\t\tgoto err;\n\t}\n\tif (amt->mode == AMT_MODE_RELAY) {\n\t\tamt->qrv = READ_ONCE(amt->net->ipv4.sysctl_igmp_qrv);\n\t\tamt->qri = 10;\n\t\tdev->needed_headroom = amt->stream_dev->needed_headroom +\n\t\t\t\t       AMT_RELAY_HLEN;\n\t\tdev->mtu = amt->stream_dev->mtu - AMT_RELAY_HLEN;\n\t\tdev->max_mtu = dev->mtu;\n\t\tdev->min_mtu = ETH_MIN_MTU + AMT_RELAY_HLEN;\n\t} else {\n\t\tif (!data[IFLA_AMT_DISCOVERY_IP]) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, tb[IFLA_AMT_DISCOVERY_IP],\n\t\t\t\t\t    \"discovery must be set in gateway mode\");\n\t\t\tgoto err;\n\t\t}\n\t\tif (!amt->gw_port) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, tb[IFLA_AMT_DISCOVERY_IP],\n\t\t\t\t\t    \"gateway port must not be 0\");\n\t\t\tgoto err;\n\t\t}\n\t\tamt->remote_ip = 0;\n\t\tamt->discovery_ip = nla_get_in_addr(data[IFLA_AMT_DISCOVERY_IP]);\n\t\tif (ipv4_is_loopback(amt->discovery_ip) ||\n\t\t    ipv4_is_zeronet(amt->discovery_ip) ||\n\t\t    ipv4_is_multicast(amt->discovery_ip)) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, tb[IFLA_AMT_DISCOVERY_IP],\n\t\t\t\t\t    \"discovery must be unicast\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tdev->needed_headroom = amt->stream_dev->needed_headroom +\n\t\t\t\t       AMT_GW_HLEN;\n\t\tdev->mtu = amt->stream_dev->mtu - AMT_GW_HLEN;\n\t\tdev->max_mtu = dev->mtu;\n\t\tdev->min_mtu = ETH_MIN_MTU + AMT_GW_HLEN;\n\t}\n\tamt->qi = AMT_INIT_QUERY_INTERVAL;\n\n\terr = register_netdevice(dev);\n\tif (err < 0) {\n\t\tnetdev_dbg(dev, \"failed to register new netdev %d\\n\", err);\n\t\tgoto err;\n\t}\n\n\terr = netdev_upper_dev_link(amt->stream_dev, dev, extack);\n\tif (err < 0) {\n\t\tunregister_netdevice(dev);\n\t\tgoto err;\n\t}\n\n\tINIT_DELAYED_WORK(&amt->discovery_wq, amt_discovery_work);\n\tINIT_DELAYED_WORK(&amt->req_wq, amt_req_work);\n\tINIT_DELAYED_WORK(&amt->secret_wq, amt_secret_work);\n\tINIT_WORK(&amt->event_wq, amt_event_work);\n\tINIT_LIST_HEAD(&amt->tunnel_list);\n\treturn 0;\nerr:\n\tdev_put(amt->stream_dev);\n\treturn err;\n}\n\nstatic void amt_dellink(struct net_device *dev, struct list_head *head)\n{\n\tstruct amt_dev *amt = netdev_priv(dev);\n\n\tunregister_netdevice_queue(dev, head);\n\tnetdev_upper_dev_unlink(amt->stream_dev, dev);\n\tdev_put(amt->stream_dev);\n}\n\nstatic size_t amt_get_size(const struct net_device *dev)\n{\n\treturn nla_total_size(sizeof(__u32)) +  \n\t       nla_total_size(sizeof(__u16)) +  \n\t       nla_total_size(sizeof(__u16)) +  \n\t       nla_total_size(sizeof(__u32)) +  \n\t       nla_total_size(sizeof(__u32)) +  \n\t       nla_total_size(sizeof(struct iphdr)) +  \n\t       nla_total_size(sizeof(struct iphdr)) +  \n\t       nla_total_size(sizeof(struct iphdr));  \n}\n\nstatic int amt_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct amt_dev *amt = netdev_priv(dev);\n\n\tif (nla_put_u32(skb, IFLA_AMT_MODE, amt->mode))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be16(skb, IFLA_AMT_RELAY_PORT, amt->relay_port))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be16(skb, IFLA_AMT_GATEWAY_PORT, amt->gw_port))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(skb, IFLA_AMT_LINK, amt->stream_dev->ifindex))\n\t\tgoto nla_put_failure;\n\tif (nla_put_in_addr(skb, IFLA_AMT_LOCAL_IP, amt->local_ip))\n\t\tgoto nla_put_failure;\n\tif (nla_put_in_addr(skb, IFLA_AMT_DISCOVERY_IP, amt->discovery_ip))\n\t\tgoto nla_put_failure;\n\tif (amt->remote_ip)\n\t\tif (nla_put_in_addr(skb, IFLA_AMT_REMOTE_IP, amt->remote_ip))\n\t\t\tgoto nla_put_failure;\n\tif (nla_put_u32(skb, IFLA_AMT_MAX_TUNNELS, amt->max_tunnels))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic struct rtnl_link_ops amt_link_ops __read_mostly = {\n\t.kind\t\t= \"amt\",\n\t.maxtype\t= IFLA_AMT_MAX,\n\t.policy\t\t= amt_policy,\n\t.priv_size\t= sizeof(struct amt_dev),\n\t.setup\t\t= amt_link_setup,\n\t.validate\t= amt_validate,\n\t.newlink\t= amt_newlink,\n\t.dellink\t= amt_dellink,\n\t.get_size       = amt_get_size,\n\t.fill_info      = amt_fill_info,\n};\n\nstatic struct net_device *amt_lookup_upper_dev(struct net_device *dev)\n{\n\tstruct net_device *upper_dev;\n\tstruct amt_dev *amt;\n\n\tfor_each_netdev(dev_net(dev), upper_dev) {\n\t\tif (netif_is_amt(upper_dev)) {\n\t\t\tamt = netdev_priv(upper_dev);\n\t\t\tif (amt->stream_dev == dev)\n\t\t\t\treturn upper_dev;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic int amt_device_event(struct notifier_block *unused,\n\t\t\t    unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct net_device *upper_dev;\n\tstruct amt_dev *amt;\n\tLIST_HEAD(list);\n\tint new_mtu;\n\n\tupper_dev = amt_lookup_upper_dev(dev);\n\tif (!upper_dev)\n\t\treturn NOTIFY_DONE;\n\tamt = netdev_priv(upper_dev);\n\n\tswitch (event) {\n\tcase NETDEV_UNREGISTER:\n\t\tamt_dellink(amt->dev, &list);\n\t\tunregister_netdevice_many(&list);\n\t\tbreak;\n\tcase NETDEV_CHANGEMTU:\n\t\tif (amt->mode == AMT_MODE_RELAY)\n\t\t\tnew_mtu = dev->mtu - AMT_RELAY_HLEN;\n\t\telse\n\t\t\tnew_mtu = dev->mtu - AMT_GW_HLEN;\n\n\t\tdev_set_mtu(amt->dev, new_mtu);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block amt_notifier_block __read_mostly = {\n\t.notifier_call = amt_device_event,\n};\n\nstatic int __init amt_init(void)\n{\n\tint err;\n\n\terr = register_netdevice_notifier(&amt_notifier_block);\n\tif (err < 0)\n\t\tgoto err;\n\n\terr = rtnl_link_register(&amt_link_ops);\n\tif (err < 0)\n\t\tgoto unregister_notifier;\n\n\tamt_wq = alloc_workqueue(\"amt\", WQ_UNBOUND, 0);\n\tif (!amt_wq) {\n\t\terr = -ENOMEM;\n\t\tgoto rtnl_unregister;\n\t}\n\n\tspin_lock_init(&source_gc_lock);\n\tspin_lock_bh(&source_gc_lock);\n\tINIT_DELAYED_WORK(&source_gc_wq, amt_source_gc_work);\n\tmod_delayed_work(amt_wq, &source_gc_wq,\n\t\t\t msecs_to_jiffies(AMT_GC_INTERVAL));\n\tspin_unlock_bh(&source_gc_lock);\n\n\treturn 0;\n\nrtnl_unregister:\n\trtnl_link_unregister(&amt_link_ops);\nunregister_notifier:\n\tunregister_netdevice_notifier(&amt_notifier_block);\nerr:\n\tpr_err(\"error loading AMT module loaded\\n\");\n\treturn err;\n}\nlate_initcall(amt_init);\n\nstatic void __exit amt_fini(void)\n{\n\trtnl_link_unregister(&amt_link_ops);\n\tunregister_netdevice_notifier(&amt_notifier_block);\n\tcancel_delayed_work_sync(&source_gc_wq);\n\t__amt_source_gc_work();\n\tdestroy_workqueue(amt_wq);\n}\nmodule_exit(amt_fini);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Taehee Yoo <ap420073@gmail.com>\");\nMODULE_ALIAS_RTNL_LINK(\"amt\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}