{
  "module_name": "vitesse-vsc73xx-core.c",
  "hash_id": "946a0ecdfecd3f95b1439d2d50d961ddfe9085d86def2e74ad91174012682412",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/vitesse-vsc73xx-core.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/of_mdio.h>\n#include <linux/bitops.h>\n#include <linux/if_bridge.h>\n#include <linux/etherdevice.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/driver.h>\n#include <linux/random.h>\n#include <net/dsa.h>\n\n#include \"vitesse-vsc73xx.h\"\n\n#define VSC73XX_BLOCK_MAC\t0x1  \n#define VSC73XX_BLOCK_ANALYZER\t0x2  \n#define VSC73XX_BLOCK_MII\t0x3  \n#define VSC73XX_BLOCK_MEMINIT\t0x3  \n#define VSC73XX_BLOCK_CAPTURE\t0x4  \n#define VSC73XX_BLOCK_ARBITER\t0x5  \n#define VSC73XX_BLOCK_SYSTEM\t0x7  \n\n#define CPU_PORT\t6  \n\n \n#define VSC73XX_MAC_CFG\t\t0x00\n#define VSC73XX_MACHDXGAP\t0x02\n#define VSC73XX_FCCONF\t\t0x04\n#define VSC73XX_FCMACHI\t\t0x08\n#define VSC73XX_FCMACLO\t\t0x0c\n#define VSC73XX_MAXLEN\t\t0x10\n#define VSC73XX_ADVPORTM\t0x19\n#define VSC73XX_TXUPDCFG\t0x24\n#define VSC73XX_TXQ_SELECT_CFG\t0x28\n#define VSC73XX_RXOCT\t\t0x50\n#define VSC73XX_TXOCT\t\t0x51\n#define VSC73XX_C_RX0\t\t0x52\n#define VSC73XX_C_RX1\t\t0x53\n#define VSC73XX_C_RX2\t\t0x54\n#define VSC73XX_C_TX0\t\t0x55\n#define VSC73XX_C_TX1\t\t0x56\n#define VSC73XX_C_TX2\t\t0x57\n#define VSC73XX_C_CFG\t\t0x58\n#define VSC73XX_CAT_DROP\t0x6e\n#define VSC73XX_CAT_PR_MISC_L2\t0x6f\n#define VSC73XX_CAT_PR_USR_PRIO\t0x75\n#define VSC73XX_Q_MISC_CONF\t0xdf\n\n \n#define VSC73XX_MAC_CFG_WEXC_DIS\tBIT(31)\n#define VSC73XX_MAC_CFG_PORT_RST\tBIT(29)\n#define VSC73XX_MAC_CFG_TX_EN\t\tBIT(28)\n#define VSC73XX_MAC_CFG_SEED_LOAD\tBIT(27)\n#define VSC73XX_MAC_CFG_SEED_MASK\tGENMASK(26, 19)\n#define VSC73XX_MAC_CFG_SEED_OFFSET\t19\n#define VSC73XX_MAC_CFG_FDX\t\tBIT(18)\n#define VSC73XX_MAC_CFG_GIGA_MODE\tBIT(17)\n#define VSC73XX_MAC_CFG_RX_EN\t\tBIT(16)\n#define VSC73XX_MAC_CFG_VLAN_DBLAWR\tBIT(15)\n#define VSC73XX_MAC_CFG_VLAN_AWR\tBIT(14)\n#define VSC73XX_MAC_CFG_100_BASE_T\tBIT(13)  \n#define VSC73XX_MAC_CFG_TX_IPG_MASK\tGENMASK(10, 6)\n#define VSC73XX_MAC_CFG_TX_IPG_OFFSET\t6\n#define VSC73XX_MAC_CFG_TX_IPG_1000M\t(6 << VSC73XX_MAC_CFG_TX_IPG_OFFSET)\n#define VSC73XX_MAC_CFG_TX_IPG_100_10M\t(17 << VSC73XX_MAC_CFG_TX_IPG_OFFSET)\n#define VSC73XX_MAC_CFG_MAC_RX_RST\tBIT(5)\n#define VSC73XX_MAC_CFG_MAC_TX_RST\tBIT(4)\n#define VSC73XX_MAC_CFG_CLK_SEL_MASK\tGENMASK(2, 0)\n#define VSC73XX_MAC_CFG_CLK_SEL_OFFSET\t0\n#define VSC73XX_MAC_CFG_CLK_SEL_1000M\t1\n#define VSC73XX_MAC_CFG_CLK_SEL_100M\t2\n#define VSC73XX_MAC_CFG_CLK_SEL_10M\t3\n#define VSC73XX_MAC_CFG_CLK_SEL_EXT\t4\n\n#define VSC73XX_MAC_CFG_1000M_F_PHY\t(VSC73XX_MAC_CFG_FDX | \\\n\t\t\t\t\t VSC73XX_MAC_CFG_GIGA_MODE | \\\n\t\t\t\t\t VSC73XX_MAC_CFG_TX_IPG_1000M | \\\n\t\t\t\t\t VSC73XX_MAC_CFG_CLK_SEL_EXT)\n#define VSC73XX_MAC_CFG_100_10M_F_PHY\t(VSC73XX_MAC_CFG_FDX | \\\n\t\t\t\t\t VSC73XX_MAC_CFG_TX_IPG_100_10M | \\\n\t\t\t\t\t VSC73XX_MAC_CFG_CLK_SEL_EXT)\n#define VSC73XX_MAC_CFG_100_10M_H_PHY\t(VSC73XX_MAC_CFG_TX_IPG_100_10M | \\\n\t\t\t\t\t VSC73XX_MAC_CFG_CLK_SEL_EXT)\n#define VSC73XX_MAC_CFG_1000M_F_RGMII\t(VSC73XX_MAC_CFG_FDX | \\\n\t\t\t\t\t VSC73XX_MAC_CFG_GIGA_MODE | \\\n\t\t\t\t\t VSC73XX_MAC_CFG_TX_IPG_1000M | \\\n\t\t\t\t\t VSC73XX_MAC_CFG_CLK_SEL_1000M)\n#define VSC73XX_MAC_CFG_RESET\t\t(VSC73XX_MAC_CFG_PORT_RST | \\\n\t\t\t\t\t VSC73XX_MAC_CFG_MAC_RX_RST | \\\n\t\t\t\t\t VSC73XX_MAC_CFG_MAC_TX_RST)\n\n \n#define VSC73XX_FCCONF_ZERO_PAUSE_EN\tBIT(17)\n#define VSC73XX_FCCONF_FLOW_CTRL_OBEY\tBIT(16)\n#define VSC73XX_FCCONF_PAUSE_VAL_MASK\tGENMASK(15, 0)\n\n \n#define VSC73XX_ADVPORTM_IFG_PPM\tBIT(7)\n#define VSC73XX_ADVPORTM_EXC_COL_CONT\tBIT(6)\n#define VSC73XX_ADVPORTM_EXT_PORT\tBIT(5)\n#define VSC73XX_ADVPORTM_INV_GTX\tBIT(4)\n#define VSC73XX_ADVPORTM_ENA_GTX\tBIT(3)\n#define VSC73XX_ADVPORTM_DDR_MODE\tBIT(2)\n#define VSC73XX_ADVPORTM_IO_LOOPBACK\tBIT(1)\n#define VSC73XX_ADVPORTM_HOST_LOOPBACK\tBIT(0)\n\n \n#define VSC73XX_CAT_DROP_DROP_MC_SMAC_ENA\tBIT(6)\n#define VSC73XX_CAT_DROP_FWD_CTRL_ENA\t\tBIT(4)\n#define VSC73XX_CAT_DROP_FWD_PAUSE_ENA\t\tBIT(3)\n#define VSC73XX_CAT_DROP_UNTAGGED_ENA\t\tBIT(2)\n#define VSC73XX_CAT_DROP_TAGGED_ENA\t\tBIT(1)\n#define VSC73XX_CAT_DROP_NULL_MAC_ENA\t\tBIT(0)\n\n#define VSC73XX_Q_MISC_CONF_EXTENT_MEM\t\tBIT(31)\n#define VSC73XX_Q_MISC_CONF_EARLY_TX_MASK\tGENMASK(4, 1)\n#define VSC73XX_Q_MISC_CONF_EARLY_TX_512\t(1 << 1)\n#define VSC73XX_Q_MISC_CONF_MAC_PAUSE_MODE\tBIT(0)\n\n \n#define VSC73XX_STORMLIMIT\t0x02\n#define VSC73XX_ADVLEARN\t0x03\n#define VSC73XX_IFLODMSK\t0x04\n#define VSC73XX_VLANMASK\t0x05\n#define VSC73XX_MACHDATA\t0x06\n#define VSC73XX_MACLDATA\t0x07\n#define VSC73XX_ANMOVED\t\t0x08\n#define VSC73XX_ANAGEFIL\t0x09\n#define VSC73XX_ANEVENTS\t0x0a\n#define VSC73XX_ANCNTMASK\t0x0b\n#define VSC73XX_ANCNTVAL\t0x0c\n#define VSC73XX_LEARNMASK\t0x0d\n#define VSC73XX_UFLODMASK\t0x0e\n#define VSC73XX_MFLODMASK\t0x0f\n#define VSC73XX_RECVMASK\t0x10\n#define VSC73XX_AGGRCTRL\t0x20\n#define VSC73XX_AGGRMSKS\t0x30  \n#define VSC73XX_DSTMASKS\t0x40  \n#define VSC73XX_SRCMASKS\t0x80  \n#define VSC73XX_CAPENAB\t\t0xa0\n#define VSC73XX_MACACCESS\t0xb0\n#define VSC73XX_IPMCACCESS\t0xb1\n#define VSC73XX_MACTINDX\t0xc0\n#define VSC73XX_VLANACCESS\t0xd0\n#define VSC73XX_VLANTIDX\t0xe0\n#define VSC73XX_AGENCTRL\t0xf0\n#define VSC73XX_CAPRST\t\t0xff\n\n#define VSC73XX_MACACCESS_CPU_COPY\t\tBIT(14)\n#define VSC73XX_MACACCESS_FWD_KILL\t\tBIT(13)\n#define VSC73XX_MACACCESS_IGNORE_VLAN\t\tBIT(12)\n#define VSC73XX_MACACCESS_AGED_FLAG\t\tBIT(11)\n#define VSC73XX_MACACCESS_VALID\t\t\tBIT(10)\n#define VSC73XX_MACACCESS_LOCKED\t\tBIT(9)\n#define VSC73XX_MACACCESS_DEST_IDX_MASK\t\tGENMASK(8, 3)\n#define VSC73XX_MACACCESS_CMD_MASK\t\tGENMASK(2, 0)\n#define VSC73XX_MACACCESS_CMD_IDLE\t\t0\n#define VSC73XX_MACACCESS_CMD_LEARN\t\t1\n#define VSC73XX_MACACCESS_CMD_FORGET\t\t2\n#define VSC73XX_MACACCESS_CMD_AGE_TABLE\t\t3\n#define VSC73XX_MACACCESS_CMD_FLUSH_TABLE\t4\n#define VSC73XX_MACACCESS_CMD_CLEAR_TABLE\t5\n#define VSC73XX_MACACCESS_CMD_READ_ENTRY\t6\n#define VSC73XX_MACACCESS_CMD_WRITE_ENTRY\t7\n\n#define VSC73XX_VLANACCESS_LEARN_DISABLED\tBIT(30)\n#define VSC73XX_VLANACCESS_VLAN_MIRROR\t\tBIT(29)\n#define VSC73XX_VLANACCESS_VLAN_SRC_CHECK\tBIT(28)\n#define VSC73XX_VLANACCESS_VLAN_PORT_MASK\tGENMASK(9, 2)\n#define VSC73XX_VLANACCESS_VLAN_TBL_CMD_MASK\tGENMASK(2, 0)\n#define VSC73XX_VLANACCESS_VLAN_TBL_CMD_IDLE\t0\n#define VSC73XX_VLANACCESS_VLAN_TBL_CMD_READ_ENTRY\t1\n#define VSC73XX_VLANACCESS_VLAN_TBL_CMD_WRITE_ENTRY\t2\n#define VSC73XX_VLANACCESS_VLAN_TBL_CMD_CLEAR_TABLE\t3\n\n \n#define VSC73XX_MII_STAT\t0x0\n#define VSC73XX_MII_CMD\t\t0x1\n#define VSC73XX_MII_DATA\t0x2\n\n \n#define VSC73XX_ARBEMPTY\t\t0x0c\n#define VSC73XX_ARBDISC\t\t\t0x0e\n#define VSC73XX_SBACKWDROP\t\t0x12\n#define VSC73XX_DBACKWDROP\t\t0x13\n#define VSC73XX_ARBBURSTPROB\t\t0x15\n\n \n#define VSC73XX_ICPU_SIPAD\t\t0x01\n#define VSC73XX_GMIIDELAY\t\t0x05\n#define VSC73XX_ICPU_CTRL\t\t0x10\n#define VSC73XX_ICPU_ADDR\t\t0x11\n#define VSC73XX_ICPU_SRAM\t\t0x12\n#define VSC73XX_HWSEM\t\t\t0x13\n#define VSC73XX_GLORESET\t\t0x14\n#define VSC73XX_ICPU_MBOX_VAL\t\t0x15\n#define VSC73XX_ICPU_MBOX_SET\t\t0x16\n#define VSC73XX_ICPU_MBOX_CLR\t\t0x17\n#define VSC73XX_CHIPID\t\t\t0x18\n#define VSC73XX_GPIO\t\t\t0x34\n\n#define VSC73XX_GMIIDELAY_GMII0_GTXDELAY_NONE\t0\n#define VSC73XX_GMIIDELAY_GMII0_GTXDELAY_1_4_NS\t1\n#define VSC73XX_GMIIDELAY_GMII0_GTXDELAY_1_7_NS\t2\n#define VSC73XX_GMIIDELAY_GMII0_GTXDELAY_2_0_NS\t3\n\n#define VSC73XX_GMIIDELAY_GMII0_RXDELAY_NONE\t(0 << 4)\n#define VSC73XX_GMIIDELAY_GMII0_RXDELAY_1_4_NS\t(1 << 4)\n#define VSC73XX_GMIIDELAY_GMII0_RXDELAY_1_7_NS\t(2 << 4)\n#define VSC73XX_GMIIDELAY_GMII0_RXDELAY_2_0_NS\t(3 << 4)\n\n#define VSC73XX_ICPU_CTRL_WATCHDOG_RST\tBIT(31)\n#define VSC73XX_ICPU_CTRL_CLK_DIV_MASK\tGENMASK(12, 8)\n#define VSC73XX_ICPU_CTRL_SRST_HOLD\tBIT(7)\n#define VSC73XX_ICPU_CTRL_ICPU_PI_EN\tBIT(6)\n#define VSC73XX_ICPU_CTRL_BOOT_EN\tBIT(3)\n#define VSC73XX_ICPU_CTRL_EXT_ACC_EN\tBIT(2)\n#define VSC73XX_ICPU_CTRL_CLK_EN\tBIT(1)\n#define VSC73XX_ICPU_CTRL_SRST\t\tBIT(0)\n\n#define VSC73XX_CHIPID_ID_SHIFT\t\t12\n#define VSC73XX_CHIPID_ID_MASK\t\t0xffff\n#define VSC73XX_CHIPID_REV_SHIFT\t28\n#define VSC73XX_CHIPID_REV_MASK\t\t0xf\n#define VSC73XX_CHIPID_ID_7385\t\t0x7385\n#define VSC73XX_CHIPID_ID_7388\t\t0x7388\n#define VSC73XX_CHIPID_ID_7395\t\t0x7395\n#define VSC73XX_CHIPID_ID_7398\t\t0x7398\n\n#define VSC73XX_GLORESET_STROBE\t\tBIT(4)\n#define VSC73XX_GLORESET_ICPU_LOCK\tBIT(3)\n#define VSC73XX_GLORESET_MEM_LOCK\tBIT(2)\n#define VSC73XX_GLORESET_PHY_RESET\tBIT(1)\n#define VSC73XX_GLORESET_MASTER_RESET\tBIT(0)\n\n#define VSC7385_CLOCK_DELAY\t\t((3 << 4) | 3)\n#define VSC7385_CLOCK_DELAY_MASK\t((3 << 4) | 3)\n\n#define VSC73XX_ICPU_CTRL_STOP\t(VSC73XX_ICPU_CTRL_SRST_HOLD | \\\n\t\t\t\t VSC73XX_ICPU_CTRL_BOOT_EN | \\\n\t\t\t\t VSC73XX_ICPU_CTRL_EXT_ACC_EN)\n\n#define VSC73XX_ICPU_CTRL_START\t(VSC73XX_ICPU_CTRL_CLK_DIV | \\\n\t\t\t\t VSC73XX_ICPU_CTRL_BOOT_EN | \\\n\t\t\t\t VSC73XX_ICPU_CTRL_CLK_EN | \\\n\t\t\t\t VSC73XX_ICPU_CTRL_SRST)\n\n#define IS_7385(a) ((a)->chipid == VSC73XX_CHIPID_ID_7385)\n#define IS_7388(a) ((a)->chipid == VSC73XX_CHIPID_ID_7388)\n#define IS_7395(a) ((a)->chipid == VSC73XX_CHIPID_ID_7395)\n#define IS_7398(a) ((a)->chipid == VSC73XX_CHIPID_ID_7398)\n#define IS_739X(a) (IS_7395(a) || IS_7398(a))\n\nstruct vsc73xx_counter {\n\tu8 counter;\n\tconst char *name;\n};\n\n \nstatic const struct vsc73xx_counter vsc73xx_rx_counters[] = {\n\t{ 0, \"RxEtherStatsPkts\" },\n\t{ 1, \"RxBroadcast+MulticastPkts\" },  \n\t{ 2, \"RxTotalErrorPackets\" },  \n\t{ 3, \"RxEtherStatsBroadcastPkts\" },\n\t{ 4, \"RxEtherStatsMulticastPkts\" },\n\t{ 5, \"RxEtherStatsPkts64Octets\" },\n\t{ 6, \"RxEtherStatsPkts65to127Octets\" },\n\t{ 7, \"RxEtherStatsPkts128to255Octets\" },\n\t{ 8, \"RxEtherStatsPkts256to511Octets\" },\n\t{ 9, \"RxEtherStatsPkts512to1023Octets\" },\n\t{ 10, \"RxEtherStatsPkts1024to1518Octets\" },\n\t{ 11, \"RxJumboFrames\" },  \n\t{ 12, \"RxaPauseMACControlFramesTransmitted\" },\n\t{ 13, \"RxFIFODrops\" },  \n\t{ 14, \"RxBackwardDrops\" },  \n\t{ 15, \"RxClassifierDrops\" },  \n\t{ 16, \"RxEtherStatsCRCAlignErrors\" },\n\t{ 17, \"RxEtherStatsUndersizePkts\" },\n\t{ 18, \"RxEtherStatsOversizePkts\" },\n\t{ 19, \"RxEtherStatsFragments\" },\n\t{ 20, \"RxEtherStatsJabbers\" },\n\t{ 21, \"RxaMACControlFramesReceived\" },\n\t \n\t{ 25, \"RxaFramesReceivedOK\" },\n\t{ 26, \"RxQoSClass0\" },  \n\t{ 27, \"RxQoSClass1\" },  \n\t{ 28, \"RxQoSClass2\" },  \n\t{ 29, \"RxQoSClass3\" },  \n};\n\nstatic const struct vsc73xx_counter vsc73xx_tx_counters[] = {\n\t{ 0, \"TxEtherStatsPkts\" },\n\t{ 1, \"TxBroadcast+MulticastPkts\" },  \n\t{ 2, \"TxTotalErrorPackets\" },  \n\t{ 3, \"TxEtherStatsBroadcastPkts\" },\n\t{ 4, \"TxEtherStatsMulticastPkts\" },\n\t{ 5, \"TxEtherStatsPkts64Octets\" },\n\t{ 6, \"TxEtherStatsPkts65to127Octets\" },\n\t{ 7, \"TxEtherStatsPkts128to255Octets\" },\n\t{ 8, \"TxEtherStatsPkts256to511Octets\" },\n\t{ 9, \"TxEtherStatsPkts512to1023Octets\" },\n\t{ 10, \"TxEtherStatsPkts1024to1518Octets\" },\n\t{ 11, \"TxJumboFrames\" },  \n\t{ 12, \"TxaPauseMACControlFramesTransmitted\" },\n\t{ 13, \"TxFIFODrops\" },  \n\t{ 14, \"TxDrops\" },  \n\t{ 15, \"TxEtherStatsCollisions\" },\n\t{ 16, \"TxEtherStatsCRCAlignErrors\" },\n\t{ 17, \"TxEtherStatsUndersizePkts\" },\n\t{ 18, \"TxEtherStatsOversizePkts\" },\n\t{ 19, \"TxEtherStatsFragments\" },\n\t{ 20, \"TxEtherStatsJabbers\" },\n\t \n\t{ 25, \"TxaFramesReceivedOK\" },\n\t{ 26, \"TxQoSClass0\" },  \n\t{ 27, \"TxQoSClass1\" },  \n\t{ 28, \"TxQoSClass2\" },  \n\t{ 29, \"TxQoSClass3\" },  \n};\n\nint vsc73xx_is_addr_valid(u8 block, u8 subblock)\n{\n\tswitch (block) {\n\tcase VSC73XX_BLOCK_MAC:\n\t\tswitch (subblock) {\n\t\tcase 0 ... 4:\n\t\tcase 6:\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\n\tcase VSC73XX_BLOCK_ANALYZER:\n\tcase VSC73XX_BLOCK_SYSTEM:\n\t\tswitch (subblock) {\n\t\tcase 0:\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\n\tcase VSC73XX_BLOCK_MII:\n\tcase VSC73XX_BLOCK_CAPTURE:\n\tcase VSC73XX_BLOCK_ARBITER:\n\t\tswitch (subblock) {\n\t\tcase 0 ... 1:\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(vsc73xx_is_addr_valid);\n\nstatic int vsc73xx_read(struct vsc73xx *vsc, u8 block, u8 subblock, u8 reg,\n\t\t\tu32 *val)\n{\n\treturn vsc->ops->read(vsc, block, subblock, reg, val);\n}\n\nstatic int vsc73xx_write(struct vsc73xx *vsc, u8 block, u8 subblock, u8 reg,\n\t\t\t u32 val)\n{\n\treturn vsc->ops->write(vsc, block, subblock, reg, val);\n}\n\nstatic int vsc73xx_update_bits(struct vsc73xx *vsc, u8 block, u8 subblock,\n\t\t\t       u8 reg, u32 mask, u32 val)\n{\n\tu32 tmp, orig;\n\tint ret;\n\n\t \n\tret = vsc73xx_read(vsc, block, subblock, reg, &orig);\n\tif (ret)\n\t\treturn ret;\n\ttmp = orig & ~mask;\n\ttmp |= val & mask;\n\treturn vsc73xx_write(vsc, block, subblock, reg, tmp);\n}\n\nstatic int vsc73xx_detect(struct vsc73xx *vsc)\n{\n\tbool icpu_si_boot_en;\n\tbool icpu_pi_en;\n\tu32 val;\n\tu32 rev;\n\tint ret;\n\tu32 id;\n\n\tret = vsc73xx_read(vsc, VSC73XX_BLOCK_SYSTEM, 0,\n\t\t\t   VSC73XX_ICPU_MBOX_VAL, &val);\n\tif (ret) {\n\t\tdev_err(vsc->dev, \"unable to read mailbox (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (val == 0xffffffff) {\n\t\tdev_info(vsc->dev, \"chip seems dead.\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tret = vsc73xx_read(vsc, VSC73XX_BLOCK_SYSTEM, 0,\n\t\t\t   VSC73XX_CHIPID, &val);\n\tif (ret) {\n\t\tdev_err(vsc->dev, \"unable to read chip id (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tid = (val >> VSC73XX_CHIPID_ID_SHIFT) &\n\t\tVSC73XX_CHIPID_ID_MASK;\n\tswitch (id) {\n\tcase VSC73XX_CHIPID_ID_7385:\n\tcase VSC73XX_CHIPID_ID_7388:\n\tcase VSC73XX_CHIPID_ID_7395:\n\tcase VSC73XX_CHIPID_ID_7398:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(vsc->dev, \"unsupported chip, id=%04x\\n\", id);\n\t\treturn -ENODEV;\n\t}\n\n\tvsc->chipid = id;\n\trev = (val >> VSC73XX_CHIPID_REV_SHIFT) &\n\t\tVSC73XX_CHIPID_REV_MASK;\n\tdev_info(vsc->dev, \"VSC%04X (rev: %d) switch found\\n\", id, rev);\n\n\tret = vsc73xx_read(vsc, VSC73XX_BLOCK_SYSTEM, 0,\n\t\t\t   VSC73XX_ICPU_CTRL, &val);\n\tif (ret) {\n\t\tdev_err(vsc->dev, \"unable to read iCPU control\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\ticpu_pi_en = !!(val & VSC73XX_ICPU_CTRL_ICPU_PI_EN);\n\ticpu_si_boot_en = !!(val & VSC73XX_ICPU_CTRL_BOOT_EN);\n\tif (icpu_si_boot_en && icpu_pi_en) {\n\t\tdev_err(vsc->dev,\n\t\t\t\"iCPU enabled boots from SI, has external memory\\n\");\n\t\tdev_err(vsc->dev, \"no idea how to deal with this\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (icpu_si_boot_en && !icpu_pi_en) {\n\t\tdev_err(vsc->dev,\n\t\t\t\"iCPU enabled boots from PI/SI, no external memory\\n\");\n\t\treturn -EAGAIN;\n\t}\n\tif (!icpu_si_boot_en && icpu_pi_en) {\n\t\tdev_err(vsc->dev,\n\t\t\t\"iCPU enabled, boots from PI external memory\\n\");\n\t\tdev_err(vsc->dev, \"no idea how to deal with this\\n\");\n\t\treturn -ENODEV;\n\t}\n\t \n\tdev_info(vsc->dev, \"iCPU disabled, no external memory\\n\");\n\n\treturn 0;\n}\n\nstatic int vsc73xx_phy_read(struct dsa_switch *ds, int phy, int regnum)\n{\n\tstruct vsc73xx *vsc = ds->priv;\n\tu32 cmd;\n\tu32 val;\n\tint ret;\n\n\t \n\tcmd = BIT(26) | (phy << 21) | (regnum << 16);\n\tret = vsc73xx_write(vsc, VSC73XX_BLOCK_MII, 0, 1, cmd);\n\tif (ret)\n\t\treturn ret;\n\tmsleep(2);\n\tret = vsc73xx_read(vsc, VSC73XX_BLOCK_MII, 0, 2, &val);\n\tif (ret)\n\t\treturn ret;\n\tif (val & BIT(16)) {\n\t\tdev_err(vsc->dev, \"reading reg %02x from phy%d failed\\n\",\n\t\t\tregnum, phy);\n\t\treturn -EIO;\n\t}\n\tval &= 0xFFFFU;\n\n\tdev_dbg(vsc->dev, \"read reg %02x from phy%d = %04x\\n\",\n\t\tregnum, phy, val);\n\n\treturn val;\n}\n\nstatic int vsc73xx_phy_write(struct dsa_switch *ds, int phy, int regnum,\n\t\t\t     u16 val)\n{\n\tstruct vsc73xx *vsc = ds->priv;\n\tu32 cmd;\n\tint ret;\n\n\t \n\tif (regnum == 0 && (val & BIT(15))) {\n\t\tdev_info(vsc->dev, \"reset PHY - disallowed\\n\");\n\t\treturn 0;\n\t}\n\n\tcmd = (phy << 21) | (regnum << 16);\n\tret = vsc73xx_write(vsc, VSC73XX_BLOCK_MII, 0, 1, cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(vsc->dev, \"write %04x to reg %02x in phy%d\\n\",\n\t\tval, regnum, phy);\n\treturn 0;\n}\n\nstatic enum dsa_tag_protocol vsc73xx_get_tag_protocol(struct dsa_switch *ds,\n\t\t\t\t\t\t      int port,\n\t\t\t\t\t\t      enum dsa_tag_protocol mp)\n{\n\t \n\treturn DSA_TAG_PROTO_NONE;\n}\n\nstatic int vsc73xx_setup(struct dsa_switch *ds)\n{\n\tstruct vsc73xx *vsc = ds->priv;\n\tint i;\n\n\tdev_info(vsc->dev, \"set up the switch\\n\");\n\n\t \n\tvsc73xx_write(vsc, VSC73XX_BLOCK_SYSTEM, 0, VSC73XX_GLORESET,\n\t\t      VSC73XX_GLORESET_MASTER_RESET);\n\tusleep_range(125, 200);\n\n\t \n\tfor (i = 0; i <= 15; i++) {\n\t\tif (i != 6 && i != 7) {\n\t\t\tvsc73xx_write(vsc, VSC73XX_BLOCK_MEMINIT,\n\t\t\t\t      2,\n\t\t\t\t      0, 0x1010400 + i);\n\t\t\tmdelay(1);\n\t\t}\n\t}\n\tmdelay(30);\n\n\t \n\tvsc73xx_write(vsc, VSC73XX_BLOCK_ANALYZER, 0,\n\t\t      VSC73XX_MACACCESS,\n\t\t      VSC73XX_MACACCESS_CMD_CLEAR_TABLE);\n\n\t \n\tvsc73xx_write(vsc, VSC73XX_BLOCK_ANALYZER, 0,\n\t\t      VSC73XX_VLANACCESS,\n\t\t      VSC73XX_VLANACCESS_VLAN_TBL_CMD_CLEAR_TABLE);\n\n\tmsleep(40);\n\n\t \n\tif (IS_739X(vsc))\n\t\tvsc73xx_write(vsc, VSC73XX_BLOCK_MAC, 0x1f,\n\t\t\t      VSC73XX_Q_MISC_CONF,\n\t\t\t      VSC73XX_Q_MISC_CONF_EXTENT_MEM);\n\n\t \n\tfor (i = 0; i < 7; i++) {\n\t\tif (i == 5)\n\t\t\tcontinue;\n\t\tvsc73xx_write(vsc, VSC73XX_BLOCK_MAC, 4,\n\t\t\t      VSC73XX_MAC_CFG, VSC73XX_MAC_CFG_RESET);\n\t}\n\n\t \n\tvsc73xx_write(vsc, VSC73XX_BLOCK_SYSTEM, 0, VSC73XX_GMIIDELAY,\n\t\t      VSC73XX_GMIIDELAY_GMII0_GTXDELAY_2_0_NS |\n\t\t      VSC73XX_GMIIDELAY_GMII0_RXDELAY_2_0_NS);\n\t \n\tvsc73xx_write(vsc, VSC73XX_BLOCK_ANALYZER, 0, VSC73XX_RECVMASK,\n\t\t      0x5f);\n\t \n\tvsc73xx_write(vsc, VSC73XX_BLOCK_ANALYZER, 0, VSC73XX_IFLODMSK,\n\t\t      0xff);\n\n\tmdelay(50);\n\n\t \n\tvsc73xx_write(vsc, VSC73XX_BLOCK_SYSTEM, 0, VSC73XX_GLORESET,\n\t\t      VSC73XX_GLORESET_PHY_RESET);\n\n\tudelay(4);\n\n\treturn 0;\n}\n\nstatic void vsc73xx_init_port(struct vsc73xx *vsc, int port)\n{\n\tu32 val;\n\n\t \n\tvsc73xx_write(vsc, VSC73XX_BLOCK_MAC,\n\t\t      port,\n\t\t      VSC73XX_MAC_CFG,\n\t\t      VSC73XX_MAC_CFG_RESET);\n\n\t \n\tif (port == CPU_PORT)\n\t\tval = VSC73XX_MAC_CFG_1000M_F_RGMII;\n\telse\n\t\tval = VSC73XX_MAC_CFG_1000M_F_PHY;\n\n\tvsc73xx_write(vsc, VSC73XX_BLOCK_MAC,\n\t\t      port,\n\t\t      VSC73XX_MAC_CFG,\n\t\t      val |\n\t\t      VSC73XX_MAC_CFG_TX_EN |\n\t\t      VSC73XX_MAC_CFG_RX_EN);\n\n\t \n\tvsc73xx_write(vsc, VSC73XX_BLOCK_MAC,\n\t\t      port,\n\t\t      VSC73XX_FCCONF,\n\t\t      VSC73XX_FCCONF_ZERO_PAUSE_EN |\n\t\t      VSC73XX_FCCONF_FLOW_CTRL_OBEY);\n\n\t \n\tif (port == CPU_PORT)\n\t\tval = VSC73XX_Q_MISC_CONF_EARLY_TX_512;\n\telse\n\t\tval = VSC73XX_Q_MISC_CONF_MAC_PAUSE_MODE;\n\tval |= VSC73XX_Q_MISC_CONF_EXTENT_MEM;\n\tvsc73xx_write(vsc, VSC73XX_BLOCK_MAC,\n\t\t      port,\n\t\t      VSC73XX_Q_MISC_CONF,\n\t\t      val);\n\n\t \n\tval = (vsc->addr[5] << 16) | (vsc->addr[4] << 8) | (vsc->addr[3]);\n\tvsc73xx_write(vsc, VSC73XX_BLOCK_MAC,\n\t\t      port,\n\t\t      VSC73XX_FCMACHI,\n\t\t      val);\n\tval = (vsc->addr[2] << 16) | (vsc->addr[1] << 8) | (vsc->addr[0]);\n\tvsc73xx_write(vsc, VSC73XX_BLOCK_MAC,\n\t\t      port,\n\t\t      VSC73XX_FCMACLO,\n\t\t      val);\n\n\t \n\tvsc73xx_write(vsc, VSC73XX_BLOCK_MAC,\n\t\t      port,\n\t\t      VSC73XX_CAT_DROP,\n\t\t      VSC73XX_CAT_DROP_FWD_PAUSE_ENA);\n\n\t \n\tvsc73xx_write(vsc, VSC73XX_BLOCK_MAC,\n\t\t      port, VSC73XX_C_RX0, 0);\n}\n\nstatic void vsc73xx_adjust_enable_port(struct vsc73xx *vsc,\n\t\t\t\t       int port, struct phy_device *phydev,\n\t\t\t\t       u32 initval)\n{\n\tu32 val = initval;\n\tu8 seed;\n\n\t \n\tval |= VSC73XX_MAC_CFG_RESET;\n\tvsc73xx_write(vsc, VSC73XX_BLOCK_MAC, port, VSC73XX_MAC_CFG, val);\n\n\t \n\tget_random_bytes(&seed, 1);\n\tval |= seed << VSC73XX_MAC_CFG_SEED_OFFSET;\n\tval |= VSC73XX_MAC_CFG_SEED_LOAD;\n\tval |= VSC73XX_MAC_CFG_WEXC_DIS;\n\tvsc73xx_write(vsc, VSC73XX_BLOCK_MAC, port, VSC73XX_MAC_CFG, val);\n\n\t \n\tvsc73xx_write(vsc, VSC73XX_BLOCK_MAC, port, VSC73XX_FCCONF,\n\t\t      VSC73XX_FCCONF_ZERO_PAUSE_EN |\n\t\t      VSC73XX_FCCONF_FLOW_CTRL_OBEY |\n\t\t      0xff);\n\n\t \n\tvsc73xx_update_bits(vsc, VSC73XX_BLOCK_ARBITER, 0,\n\t\t\t    VSC73XX_SBACKWDROP, BIT(port), 0);\n\n\t \n\tvsc73xx_update_bits(vsc, VSC73XX_BLOCK_MAC, port,\n\t\t\t    VSC73XX_MAC_CFG,\n\t\t\t    VSC73XX_MAC_CFG_RESET | VSC73XX_MAC_CFG_SEED_LOAD |\n\t\t\t    VSC73XX_MAC_CFG_TX_EN | VSC73XX_MAC_CFG_RX_EN,\n\t\t\t    VSC73XX_MAC_CFG_TX_EN | VSC73XX_MAC_CFG_RX_EN);\n}\n\nstatic void vsc73xx_adjust_link(struct dsa_switch *ds, int port,\n\t\t\t\tstruct phy_device *phydev)\n{\n\tstruct vsc73xx *vsc = ds->priv;\n\tu32 val;\n\n\t \n\tif (port == CPU_PORT) {\n\t\t \n\t\tvsc73xx_init_port(vsc, CPU_PORT);\n\t\t \n\t\tvsc73xx_write(vsc, VSC73XX_BLOCK_MAC,\n\t\t\t      CPU_PORT,\n\t\t\t      VSC73XX_ADVPORTM,\n\t\t\t      VSC73XX_ADVPORTM_EXT_PORT |\n\t\t\t      VSC73XX_ADVPORTM_ENA_GTX |\n\t\t\t      VSC73XX_ADVPORTM_DDR_MODE);\n\t}\n\n\t \n\tif (!phydev->link) {\n\t\tint maxloop = 10;\n\n\t\tdev_dbg(vsc->dev, \"port %d: went down\\n\",\n\t\t\tport);\n\n\t\t \n\t\tvsc73xx_update_bits(vsc, VSC73XX_BLOCK_MAC, port,\n\t\t\t\t    VSC73XX_MAC_CFG,\n\t\t\t\t    VSC73XX_MAC_CFG_RX_EN, 0);\n\n\t\t \n\t\tvsc73xx_update_bits(vsc, VSC73XX_BLOCK_ARBITER, 0,\n\t\t\t\t    VSC73XX_ARBDISC, BIT(port), BIT(port));\n\n\t\t \n\t\tvsc73xx_read(vsc, VSC73XX_BLOCK_ARBITER, 0,\n\t\t\t     VSC73XX_ARBEMPTY, &val);\n\t\twhile (!(val & BIT(port))) {\n\t\t\tmsleep(1);\n\t\t\tvsc73xx_read(vsc, VSC73XX_BLOCK_ARBITER, 0,\n\t\t\t\t     VSC73XX_ARBEMPTY, &val);\n\t\t\tif (--maxloop == 0) {\n\t\t\t\tdev_err(vsc->dev,\n\t\t\t\t\t\"timeout waiting for block arbiter\\n\");\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tvsc73xx_write(vsc, VSC73XX_BLOCK_MAC, port, VSC73XX_MAC_CFG,\n\t\t\t      VSC73XX_MAC_CFG_RESET);\n\n\t\t \n\t\tvsc73xx_update_bits(vsc, VSC73XX_BLOCK_ARBITER, 0,\n\t\t\t\t    VSC73XX_ARBDISC, BIT(port), 0);\n\n\t\t \n\t\tvsc73xx_update_bits(vsc, VSC73XX_BLOCK_ARBITER, 0,\n\t\t\t\t    VSC73XX_SBACKWDROP, BIT(port), BIT(port));\n\n\t\t \n\t\tvsc73xx_update_bits(vsc, VSC73XX_BLOCK_ANALYZER, 0,\n\t\t\t\t    VSC73XX_RECVMASK, BIT(port), 0);\n\n\t\treturn;\n\t}\n\n\t \n\tif (phydev->speed == SPEED_1000) {\n\t\tdev_dbg(vsc->dev, \"port %d: 1000 Mbit mode full duplex\\n\",\n\t\t\tport);\n\n\t\t \n\t\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII)\n\t\t\tval = VSC73XX_MAC_CFG_1000M_F_RGMII;\n\t\telse\n\t\t\tval = VSC73XX_MAC_CFG_1000M_F_PHY;\n\t\tvsc73xx_adjust_enable_port(vsc, port, phydev, val);\n\t} else if (phydev->speed == SPEED_100) {\n\t\tif (phydev->duplex == DUPLEX_FULL) {\n\t\t\tval = VSC73XX_MAC_CFG_100_10M_F_PHY;\n\t\t\tdev_dbg(vsc->dev,\n\t\t\t\t\"port %d: 100 Mbit full duplex mode\\n\",\n\t\t\t\tport);\n\t\t} else {\n\t\t\tval = VSC73XX_MAC_CFG_100_10M_H_PHY;\n\t\t\tdev_dbg(vsc->dev,\n\t\t\t\t\"port %d: 100 Mbit half duplex mode\\n\",\n\t\t\t\tport);\n\t\t}\n\t\tvsc73xx_adjust_enable_port(vsc, port, phydev, val);\n\t} else if (phydev->speed == SPEED_10) {\n\t\tif (phydev->duplex == DUPLEX_FULL) {\n\t\t\tval = VSC73XX_MAC_CFG_100_10M_F_PHY;\n\t\t\tdev_dbg(vsc->dev,\n\t\t\t\t\"port %d: 10 Mbit full duplex mode\\n\",\n\t\t\t\tport);\n\t\t} else {\n\t\t\tval = VSC73XX_MAC_CFG_100_10M_H_PHY;\n\t\t\tdev_dbg(vsc->dev,\n\t\t\t\t\"port %d: 10 Mbit half duplex mode\\n\",\n\t\t\t\tport);\n\t\t}\n\t\tvsc73xx_adjust_enable_port(vsc, port, phydev, val);\n\t} else {\n\t\tdev_err(vsc->dev,\n\t\t\t\"could not adjust link: unknown speed\\n\");\n\t}\n\n\t \n\tvsc73xx_update_bits(vsc, VSC73XX_BLOCK_ANALYZER, 0,\n\t\t\t    VSC73XX_RECVMASK, BIT(port), BIT(port));\n}\n\nstatic int vsc73xx_port_enable(struct dsa_switch *ds, int port,\n\t\t\t       struct phy_device *phy)\n{\n\tstruct vsc73xx *vsc = ds->priv;\n\n\tdev_info(vsc->dev, \"enable port %d\\n\", port);\n\tvsc73xx_init_port(vsc, port);\n\n\treturn 0;\n}\n\nstatic void vsc73xx_port_disable(struct dsa_switch *ds, int port)\n{\n\tstruct vsc73xx *vsc = ds->priv;\n\n\t \n\tvsc73xx_write(vsc, VSC73XX_BLOCK_MAC, port,\n\t\t      VSC73XX_MAC_CFG, VSC73XX_MAC_CFG_RESET);\n}\n\nstatic const struct vsc73xx_counter *\nvsc73xx_find_counter(struct vsc73xx *vsc,\n\t\t     u8 counter,\n\t\t     bool tx)\n{\n\tconst struct vsc73xx_counter *cnts;\n\tint num_cnts;\n\tint i;\n\n\tif (tx) {\n\t\tcnts = vsc73xx_tx_counters;\n\t\tnum_cnts = ARRAY_SIZE(vsc73xx_tx_counters);\n\t} else {\n\t\tcnts = vsc73xx_rx_counters;\n\t\tnum_cnts = ARRAY_SIZE(vsc73xx_rx_counters);\n\t}\n\n\tfor (i = 0; i < num_cnts; i++) {\n\t\tconst struct vsc73xx_counter *cnt;\n\n\t\tcnt = &cnts[i];\n\t\tif (cnt->counter == counter)\n\t\t\treturn cnt;\n\t}\n\n\treturn NULL;\n}\n\nstatic void vsc73xx_get_strings(struct dsa_switch *ds, int port, u32 stringset,\n\t\t\t\tuint8_t *data)\n{\n\tconst struct vsc73xx_counter *cnt;\n\tstruct vsc73xx *vsc = ds->priv;\n\tu8 indices[6];\n\tint i, j;\n\tu32 val;\n\tint ret;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tret = vsc73xx_read(vsc, VSC73XX_BLOCK_MAC, port,\n\t\t\t   VSC73XX_C_CFG, &val);\n\tif (ret)\n\t\treturn;\n\n\tindices[0] = (val & 0x1f);  \n\tindices[1] = ((val >> 5) & 0x1f);  \n\tindices[2] = ((val >> 10) & 0x1f);  \n\tindices[3] = ((val >> 16) & 0x1f);  \n\tindices[4] = ((val >> 21) & 0x1f);  \n\tindices[5] = ((val >> 26) & 0x1f);  \n\n\t \n\tj = 0;\n\tstrncpy(data + j * ETH_GSTRING_LEN,\n\t\t\"RxEtherStatsOctets\", ETH_GSTRING_LEN);\n\tj++;\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tcnt = vsc73xx_find_counter(vsc, indices[i], false);\n\t\tif (cnt)\n\t\t\tstrncpy(data + j * ETH_GSTRING_LEN,\n\t\t\t\tcnt->name, ETH_GSTRING_LEN);\n\t\tj++;\n\t}\n\n\t \n\tstrncpy(data + j * ETH_GSTRING_LEN,\n\t\t\"TxEtherStatsOctets\", ETH_GSTRING_LEN);\n\tj++;\n\n\tfor (i = 3; i < 6; i++) {\n\t\tcnt = vsc73xx_find_counter(vsc, indices[i], true);\n\t\tif (cnt)\n\t\t\tstrncpy(data + j * ETH_GSTRING_LEN,\n\t\t\t\tcnt->name, ETH_GSTRING_LEN);\n\t\tj++;\n\t}\n}\n\nstatic int vsc73xx_get_sset_count(struct dsa_switch *ds, int port, int sset)\n{\n\t \n\tif (sset != ETH_SS_STATS)\n\t\treturn 0;\n\t \n\treturn 8;\n}\n\nstatic void vsc73xx_get_ethtool_stats(struct dsa_switch *ds, int port,\n\t\t\t\t      uint64_t *data)\n{\n\tstruct vsc73xx *vsc = ds->priv;\n\tu8 regs[] = {\n\t\tVSC73XX_RXOCT,\n\t\tVSC73XX_C_RX0,\n\t\tVSC73XX_C_RX1,\n\t\tVSC73XX_C_RX2,\n\t\tVSC73XX_TXOCT,\n\t\tVSC73XX_C_TX0,\n\t\tVSC73XX_C_TX1,\n\t\tVSC73XX_C_TX2,\n\t};\n\tu32 val;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(regs); i++) {\n\t\tret = vsc73xx_read(vsc, VSC73XX_BLOCK_MAC, port,\n\t\t\t\t   regs[i], &val);\n\t\tif (ret) {\n\t\t\tdev_err(vsc->dev, \"error reading counter %d\\n\", i);\n\t\t\treturn;\n\t\t}\n\t\tdata[i] = val;\n\t}\n}\n\nstatic int vsc73xx_change_mtu(struct dsa_switch *ds, int port, int new_mtu)\n{\n\tstruct vsc73xx *vsc = ds->priv;\n\n\treturn vsc73xx_write(vsc, VSC73XX_BLOCK_MAC, port,\n\t\t\t     VSC73XX_MAXLEN, new_mtu + ETH_HLEN + ETH_FCS_LEN);\n}\n\n \nstatic int vsc73xx_get_max_mtu(struct dsa_switch *ds, int port)\n{\n\treturn 9600 - ETH_HLEN - ETH_FCS_LEN;\n}\n\nstatic const struct dsa_switch_ops vsc73xx_ds_ops = {\n\t.get_tag_protocol = vsc73xx_get_tag_protocol,\n\t.setup = vsc73xx_setup,\n\t.phy_read = vsc73xx_phy_read,\n\t.phy_write = vsc73xx_phy_write,\n\t.adjust_link = vsc73xx_adjust_link,\n\t.get_strings = vsc73xx_get_strings,\n\t.get_ethtool_stats = vsc73xx_get_ethtool_stats,\n\t.get_sset_count = vsc73xx_get_sset_count,\n\t.port_enable = vsc73xx_port_enable,\n\t.port_disable = vsc73xx_port_disable,\n\t.port_change_mtu = vsc73xx_change_mtu,\n\t.port_max_mtu = vsc73xx_get_max_mtu,\n};\n\nstatic int vsc73xx_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct vsc73xx *vsc = gpiochip_get_data(chip);\n\tu32 val;\n\tint ret;\n\n\tret = vsc73xx_read(vsc, VSC73XX_BLOCK_SYSTEM, 0,\n\t\t\t   VSC73XX_GPIO, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !!(val & BIT(offset));\n}\n\nstatic void vsc73xx_gpio_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t     int val)\n{\n\tstruct vsc73xx *vsc = gpiochip_get_data(chip);\n\tu32 tmp = val ? BIT(offset) : 0;\n\n\tvsc73xx_update_bits(vsc, VSC73XX_BLOCK_SYSTEM, 0,\n\t\t\t    VSC73XX_GPIO, BIT(offset), tmp);\n}\n\nstatic int vsc73xx_gpio_direction_output(struct gpio_chip *chip,\n\t\t\t\t\t unsigned int offset, int val)\n{\n\tstruct vsc73xx *vsc = gpiochip_get_data(chip);\n\tu32 tmp = val ? BIT(offset) : 0;\n\n\treturn vsc73xx_update_bits(vsc, VSC73XX_BLOCK_SYSTEM, 0,\n\t\t\t\t   VSC73XX_GPIO, BIT(offset + 4) | BIT(offset),\n\t\t\t\t   BIT(offset + 4) | tmp);\n}\n\nstatic int vsc73xx_gpio_direction_input(struct gpio_chip *chip,\n\t\t\t\t\tunsigned int offset)\n{\n\tstruct vsc73xx *vsc = gpiochip_get_data(chip);\n\n\treturn  vsc73xx_update_bits(vsc, VSC73XX_BLOCK_SYSTEM, 0,\n\t\t\t\t    VSC73XX_GPIO, BIT(offset + 4),\n\t\t\t\t    0);\n}\n\nstatic int vsc73xx_gpio_get_direction(struct gpio_chip *chip,\n\t\t\t\t      unsigned int offset)\n{\n\tstruct vsc73xx *vsc = gpiochip_get_data(chip);\n\tu32 val;\n\tint ret;\n\n\tret = vsc73xx_read(vsc, VSC73XX_BLOCK_SYSTEM, 0,\n\t\t\t   VSC73XX_GPIO, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn !(val & BIT(offset + 4));\n}\n\nstatic int vsc73xx_gpio_probe(struct vsc73xx *vsc)\n{\n\tint ret;\n\n\tvsc->gc.label = devm_kasprintf(vsc->dev, GFP_KERNEL, \"VSC%04x\",\n\t\t\t\t       vsc->chipid);\n\tif (!vsc->gc.label)\n\t\treturn -ENOMEM;\n\tvsc->gc.ngpio = 4;\n\tvsc->gc.owner = THIS_MODULE;\n\tvsc->gc.parent = vsc->dev;\n\tvsc->gc.base = -1;\n\tvsc->gc.get = vsc73xx_gpio_get;\n\tvsc->gc.set = vsc73xx_gpio_set;\n\tvsc->gc.direction_input = vsc73xx_gpio_direction_input;\n\tvsc->gc.direction_output = vsc73xx_gpio_direction_output;\n\tvsc->gc.get_direction = vsc73xx_gpio_get_direction;\n\tvsc->gc.can_sleep = true;\n\tret = devm_gpiochip_add_data(vsc->dev, &vsc->gc, vsc);\n\tif (ret) {\n\t\tdev_err(vsc->dev, \"unable to register GPIO chip\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nint vsc73xx_probe(struct vsc73xx *vsc)\n{\n\tstruct device *dev = vsc->dev;\n\tint ret;\n\n\t \n\tvsc->reset = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(vsc->reset)) {\n\t\tdev_err(dev, \"failed to get RESET GPIO\\n\");\n\t\treturn PTR_ERR(vsc->reset);\n\t}\n\tif (vsc->reset)\n\t\t \n\t\tmsleep(20);\n\n\tret = vsc73xx_detect(vsc);\n\tif (ret == -EAGAIN) {\n\t\tdev_err(vsc->dev,\n\t\t\t\"Chip seems to be out of control. Assert reset and try again.\\n\");\n\t\tgpiod_set_value_cansleep(vsc->reset, 1);\n\t\t \n\t\tusleep_range(10, 100);\n\t\tgpiod_set_value_cansleep(vsc->reset, 0);\n\t\t \n\t\tmsleep(20);\n\t\tret = vsc73xx_detect(vsc);\n\t}\n\tif (ret) {\n\t\tdev_err(dev, \"no chip found (%d)\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\teth_random_addr(vsc->addr);\n\tdev_info(vsc->dev,\n\t\t \"MAC for control frames: %02X:%02X:%02X:%02X:%02X:%02X\\n\",\n\t\t vsc->addr[0], vsc->addr[1], vsc->addr[2],\n\t\t vsc->addr[3], vsc->addr[4], vsc->addr[5]);\n\n\t \n\tvsc->ds = devm_kzalloc(dev, sizeof(*vsc->ds), GFP_KERNEL);\n\tif (!vsc->ds)\n\t\treturn -ENOMEM;\n\n\tvsc->ds->dev = dev;\n\tvsc->ds->num_ports = 8;\n\tvsc->ds->priv = vsc;\n\n\tvsc->ds->ops = &vsc73xx_ds_ops;\n\tret = dsa_register_switch(vsc->ds);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to register switch (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = vsc73xx_gpio_probe(vsc);\n\tif (ret) {\n\t\tdsa_unregister_switch(vsc->ds);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(vsc73xx_probe);\n\nvoid vsc73xx_remove(struct vsc73xx *vsc)\n{\n\tdsa_unregister_switch(vsc->ds);\n\tgpiod_set_value(vsc->reset, 1);\n}\nEXPORT_SYMBOL(vsc73xx_remove);\n\nvoid vsc73xx_shutdown(struct vsc73xx *vsc)\n{\n\tdsa_switch_shutdown(vsc->ds);\n}\nEXPORT_SYMBOL(vsc73xx_shutdown);\n\nMODULE_AUTHOR(\"Linus Walleij <linus.walleij@linaro.org>\");\nMODULE_DESCRIPTION(\"Vitesse VSC7385/7388/7395/7398 driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}