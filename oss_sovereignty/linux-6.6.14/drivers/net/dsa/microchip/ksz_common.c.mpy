{
  "module_name": "ksz_common.c",
  "hash_id": "b7c5a8e43be2c68adb814b10c5a3acf44cf8121735b5f515c4698b8a10b6ccf5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/microchip/ksz_common.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/dsa/ksz_common.h>\n#include <linux/export.h>\n#include <linux/gpio/consumer.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_data/microchip-ksz.h>\n#include <linux/phy.h>\n#include <linux/etherdevice.h>\n#include <linux/if_bridge.h>\n#include <linux/if_vlan.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/of.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/micrel_phy.h>\n#include <net/dsa.h>\n#include <net/pkt_cls.h>\n#include <net/switchdev.h>\n\n#include \"ksz_common.h\"\n#include \"ksz_ptp.h\"\n#include \"ksz8.h\"\n#include \"ksz9477.h\"\n#include \"lan937x.h\"\n\n#define MIB_COUNTER_NUM 0x20\n\nstruct ksz_stats_raw {\n\tu64 rx_hi;\n\tu64 rx_undersize;\n\tu64 rx_fragments;\n\tu64 rx_oversize;\n\tu64 rx_jabbers;\n\tu64 rx_symbol_err;\n\tu64 rx_crc_err;\n\tu64 rx_align_err;\n\tu64 rx_mac_ctrl;\n\tu64 rx_pause;\n\tu64 rx_bcast;\n\tu64 rx_mcast;\n\tu64 rx_ucast;\n\tu64 rx_64_or_less;\n\tu64 rx_65_127;\n\tu64 rx_128_255;\n\tu64 rx_256_511;\n\tu64 rx_512_1023;\n\tu64 rx_1024_1522;\n\tu64 rx_1523_2000;\n\tu64 rx_2001;\n\tu64 tx_hi;\n\tu64 tx_late_col;\n\tu64 tx_pause;\n\tu64 tx_bcast;\n\tu64 tx_mcast;\n\tu64 tx_ucast;\n\tu64 tx_deferred;\n\tu64 tx_total_col;\n\tu64 tx_exc_col;\n\tu64 tx_single_col;\n\tu64 tx_mult_col;\n\tu64 rx_total;\n\tu64 tx_total;\n\tu64 rx_discards;\n\tu64 tx_discards;\n};\n\nstruct ksz88xx_stats_raw {\n\tu64 rx;\n\tu64 rx_hi;\n\tu64 rx_undersize;\n\tu64 rx_fragments;\n\tu64 rx_oversize;\n\tu64 rx_jabbers;\n\tu64 rx_symbol_err;\n\tu64 rx_crc_err;\n\tu64 rx_align_err;\n\tu64 rx_mac_ctrl;\n\tu64 rx_pause;\n\tu64 rx_bcast;\n\tu64 rx_mcast;\n\tu64 rx_ucast;\n\tu64 rx_64_or_less;\n\tu64 rx_65_127;\n\tu64 rx_128_255;\n\tu64 rx_256_511;\n\tu64 rx_512_1023;\n\tu64 rx_1024_1522;\n\tu64 tx;\n\tu64 tx_hi;\n\tu64 tx_late_col;\n\tu64 tx_pause;\n\tu64 tx_bcast;\n\tu64 tx_mcast;\n\tu64 tx_ucast;\n\tu64 tx_deferred;\n\tu64 tx_total_col;\n\tu64 tx_exc_col;\n\tu64 tx_single_col;\n\tu64 tx_mult_col;\n\tu64 rx_discards;\n\tu64 tx_discards;\n};\n\nstatic const struct ksz_mib_names ksz88xx_mib_names[] = {\n\t{ 0x00, \"rx\" },\n\t{ 0x01, \"rx_hi\" },\n\t{ 0x02, \"rx_undersize\" },\n\t{ 0x03, \"rx_fragments\" },\n\t{ 0x04, \"rx_oversize\" },\n\t{ 0x05, \"rx_jabbers\" },\n\t{ 0x06, \"rx_symbol_err\" },\n\t{ 0x07, \"rx_crc_err\" },\n\t{ 0x08, \"rx_align_err\" },\n\t{ 0x09, \"rx_mac_ctrl\" },\n\t{ 0x0a, \"rx_pause\" },\n\t{ 0x0b, \"rx_bcast\" },\n\t{ 0x0c, \"rx_mcast\" },\n\t{ 0x0d, \"rx_ucast\" },\n\t{ 0x0e, \"rx_64_or_less\" },\n\t{ 0x0f, \"rx_65_127\" },\n\t{ 0x10, \"rx_128_255\" },\n\t{ 0x11, \"rx_256_511\" },\n\t{ 0x12, \"rx_512_1023\" },\n\t{ 0x13, \"rx_1024_1522\" },\n\t{ 0x14, \"tx\" },\n\t{ 0x15, \"tx_hi\" },\n\t{ 0x16, \"tx_late_col\" },\n\t{ 0x17, \"tx_pause\" },\n\t{ 0x18, \"tx_bcast\" },\n\t{ 0x19, \"tx_mcast\" },\n\t{ 0x1a, \"tx_ucast\" },\n\t{ 0x1b, \"tx_deferred\" },\n\t{ 0x1c, \"tx_total_col\" },\n\t{ 0x1d, \"tx_exc_col\" },\n\t{ 0x1e, \"tx_single_col\" },\n\t{ 0x1f, \"tx_mult_col\" },\n\t{ 0x100, \"rx_discards\" },\n\t{ 0x101, \"tx_discards\" },\n};\n\nstatic const struct ksz_mib_names ksz9477_mib_names[] = {\n\t{ 0x00, \"rx_hi\" },\n\t{ 0x01, \"rx_undersize\" },\n\t{ 0x02, \"rx_fragments\" },\n\t{ 0x03, \"rx_oversize\" },\n\t{ 0x04, \"rx_jabbers\" },\n\t{ 0x05, \"rx_symbol_err\" },\n\t{ 0x06, \"rx_crc_err\" },\n\t{ 0x07, \"rx_align_err\" },\n\t{ 0x08, \"rx_mac_ctrl\" },\n\t{ 0x09, \"rx_pause\" },\n\t{ 0x0A, \"rx_bcast\" },\n\t{ 0x0B, \"rx_mcast\" },\n\t{ 0x0C, \"rx_ucast\" },\n\t{ 0x0D, \"rx_64_or_less\" },\n\t{ 0x0E, \"rx_65_127\" },\n\t{ 0x0F, \"rx_128_255\" },\n\t{ 0x10, \"rx_256_511\" },\n\t{ 0x11, \"rx_512_1023\" },\n\t{ 0x12, \"rx_1024_1522\" },\n\t{ 0x13, \"rx_1523_2000\" },\n\t{ 0x14, \"rx_2001\" },\n\t{ 0x15, \"tx_hi\" },\n\t{ 0x16, \"tx_late_col\" },\n\t{ 0x17, \"tx_pause\" },\n\t{ 0x18, \"tx_bcast\" },\n\t{ 0x19, \"tx_mcast\" },\n\t{ 0x1A, \"tx_ucast\" },\n\t{ 0x1B, \"tx_deferred\" },\n\t{ 0x1C, \"tx_total_col\" },\n\t{ 0x1D, \"tx_exc_col\" },\n\t{ 0x1E, \"tx_single_col\" },\n\t{ 0x1F, \"tx_mult_col\" },\n\t{ 0x80, \"rx_total\" },\n\t{ 0x81, \"tx_total\" },\n\t{ 0x82, \"rx_discards\" },\n\t{ 0x83, \"tx_discards\" },\n};\n\nstatic const struct ksz_dev_ops ksz8_dev_ops = {\n\t.setup = ksz8_setup,\n\t.get_port_addr = ksz8_get_port_addr,\n\t.cfg_port_member = ksz8_cfg_port_member,\n\t.flush_dyn_mac_table = ksz8_flush_dyn_mac_table,\n\t.port_setup = ksz8_port_setup,\n\t.r_phy = ksz8_r_phy,\n\t.w_phy = ksz8_w_phy,\n\t.r_mib_cnt = ksz8_r_mib_cnt,\n\t.r_mib_pkt = ksz8_r_mib_pkt,\n\t.r_mib_stat64 = ksz88xx_r_mib_stats64,\n\t.freeze_mib = ksz8_freeze_mib,\n\t.port_init_cnt = ksz8_port_init_cnt,\n\t.fdb_dump = ksz8_fdb_dump,\n\t.fdb_add = ksz8_fdb_add,\n\t.fdb_del = ksz8_fdb_del,\n\t.mdb_add = ksz8_mdb_add,\n\t.mdb_del = ksz8_mdb_del,\n\t.vlan_filtering = ksz8_port_vlan_filtering,\n\t.vlan_add = ksz8_port_vlan_add,\n\t.vlan_del = ksz8_port_vlan_del,\n\t.mirror_add = ksz8_port_mirror_add,\n\t.mirror_del = ksz8_port_mirror_del,\n\t.get_caps = ksz8_get_caps,\n\t.config_cpu_port = ksz8_config_cpu_port,\n\t.enable_stp_addr = ksz8_enable_stp_addr,\n\t.reset = ksz8_reset_switch,\n\t.init = ksz8_switch_init,\n\t.exit = ksz8_switch_exit,\n\t.change_mtu = ksz8_change_mtu,\n};\n\nstatic void ksz9477_phylink_mac_link_up(struct ksz_device *dev, int port,\n\t\t\t\t\tunsigned int mode,\n\t\t\t\t\tphy_interface_t interface,\n\t\t\t\t\tstruct phy_device *phydev, int speed,\n\t\t\t\t\tint duplex, bool tx_pause,\n\t\t\t\t\tbool rx_pause);\n\nstatic const struct ksz_dev_ops ksz9477_dev_ops = {\n\t.setup = ksz9477_setup,\n\t.get_port_addr = ksz9477_get_port_addr,\n\t.cfg_port_member = ksz9477_cfg_port_member,\n\t.flush_dyn_mac_table = ksz9477_flush_dyn_mac_table,\n\t.port_setup = ksz9477_port_setup,\n\t.set_ageing_time = ksz9477_set_ageing_time,\n\t.r_phy = ksz9477_r_phy,\n\t.w_phy = ksz9477_w_phy,\n\t.r_mib_cnt = ksz9477_r_mib_cnt,\n\t.r_mib_pkt = ksz9477_r_mib_pkt,\n\t.r_mib_stat64 = ksz_r_mib_stats64,\n\t.freeze_mib = ksz9477_freeze_mib,\n\t.port_init_cnt = ksz9477_port_init_cnt,\n\t.vlan_filtering = ksz9477_port_vlan_filtering,\n\t.vlan_add = ksz9477_port_vlan_add,\n\t.vlan_del = ksz9477_port_vlan_del,\n\t.mirror_add = ksz9477_port_mirror_add,\n\t.mirror_del = ksz9477_port_mirror_del,\n\t.get_caps = ksz9477_get_caps,\n\t.fdb_dump = ksz9477_fdb_dump,\n\t.fdb_add = ksz9477_fdb_add,\n\t.fdb_del = ksz9477_fdb_del,\n\t.mdb_add = ksz9477_mdb_add,\n\t.mdb_del = ksz9477_mdb_del,\n\t.change_mtu = ksz9477_change_mtu,\n\t.phylink_mac_link_up = ksz9477_phylink_mac_link_up,\n\t.config_cpu_port = ksz9477_config_cpu_port,\n\t.tc_cbs_set_cinc = ksz9477_tc_cbs_set_cinc,\n\t.enable_stp_addr = ksz9477_enable_stp_addr,\n\t.reset = ksz9477_reset_switch,\n\t.init = ksz9477_switch_init,\n\t.exit = ksz9477_switch_exit,\n};\n\nstatic const struct ksz_dev_ops lan937x_dev_ops = {\n\t.setup = lan937x_setup,\n\t.teardown = lan937x_teardown,\n\t.get_port_addr = ksz9477_get_port_addr,\n\t.cfg_port_member = ksz9477_cfg_port_member,\n\t.flush_dyn_mac_table = ksz9477_flush_dyn_mac_table,\n\t.port_setup = lan937x_port_setup,\n\t.set_ageing_time = lan937x_set_ageing_time,\n\t.r_phy = lan937x_r_phy,\n\t.w_phy = lan937x_w_phy,\n\t.r_mib_cnt = ksz9477_r_mib_cnt,\n\t.r_mib_pkt = ksz9477_r_mib_pkt,\n\t.r_mib_stat64 = ksz_r_mib_stats64,\n\t.freeze_mib = ksz9477_freeze_mib,\n\t.port_init_cnt = ksz9477_port_init_cnt,\n\t.vlan_filtering = ksz9477_port_vlan_filtering,\n\t.vlan_add = ksz9477_port_vlan_add,\n\t.vlan_del = ksz9477_port_vlan_del,\n\t.mirror_add = ksz9477_port_mirror_add,\n\t.mirror_del = ksz9477_port_mirror_del,\n\t.get_caps = lan937x_phylink_get_caps,\n\t.setup_rgmii_delay = lan937x_setup_rgmii_delay,\n\t.fdb_dump = ksz9477_fdb_dump,\n\t.fdb_add = ksz9477_fdb_add,\n\t.fdb_del = ksz9477_fdb_del,\n\t.mdb_add = ksz9477_mdb_add,\n\t.mdb_del = ksz9477_mdb_del,\n\t.change_mtu = lan937x_change_mtu,\n\t.phylink_mac_link_up = ksz9477_phylink_mac_link_up,\n\t.config_cpu_port = lan937x_config_cpu_port,\n\t.tc_cbs_set_cinc = lan937x_tc_cbs_set_cinc,\n\t.enable_stp_addr = ksz9477_enable_stp_addr,\n\t.reset = lan937x_reset_switch,\n\t.init = lan937x_switch_init,\n\t.exit = lan937x_switch_exit,\n};\n\nstatic const u16 ksz8795_regs[] = {\n\t[REG_IND_CTRL_0]\t\t= 0x6E,\n\t[REG_IND_DATA_8]\t\t= 0x70,\n\t[REG_IND_DATA_CHECK]\t\t= 0x72,\n\t[REG_IND_DATA_HI]\t\t= 0x71,\n\t[REG_IND_DATA_LO]\t\t= 0x75,\n\t[REG_IND_MIB_CHECK]\t\t= 0x74,\n\t[REG_IND_BYTE]\t\t\t= 0xA0,\n\t[P_FORCE_CTRL]\t\t\t= 0x0C,\n\t[P_LINK_STATUS]\t\t\t= 0x0E,\n\t[P_LOCAL_CTRL]\t\t\t= 0x07,\n\t[P_NEG_RESTART_CTRL]\t\t= 0x0D,\n\t[P_REMOTE_STATUS]\t\t= 0x08,\n\t[P_SPEED_STATUS]\t\t= 0x09,\n\t[S_TAIL_TAG_CTRL]\t\t= 0x0C,\n\t[P_STP_CTRL]\t\t\t= 0x02,\n\t[S_START_CTRL]\t\t\t= 0x01,\n\t[S_BROADCAST_CTRL]\t\t= 0x06,\n\t[S_MULTICAST_CTRL]\t\t= 0x04,\n\t[P_XMII_CTRL_0]\t\t\t= 0x06,\n\t[P_XMII_CTRL_1]\t\t\t= 0x06,\n};\n\nstatic const u32 ksz8795_masks[] = {\n\t[PORT_802_1P_REMAPPING]\t\t= BIT(7),\n\t[SW_TAIL_TAG_ENABLE]\t\t= BIT(1),\n\t[MIB_COUNTER_OVERFLOW]\t\t= BIT(6),\n\t[MIB_COUNTER_VALID]\t\t= BIT(5),\n\t[VLAN_TABLE_FID]\t\t= GENMASK(6, 0),\n\t[VLAN_TABLE_MEMBERSHIP]\t\t= GENMASK(11, 7),\n\t[VLAN_TABLE_VALID]\t\t= BIT(12),\n\t[STATIC_MAC_TABLE_VALID]\t= BIT(21),\n\t[STATIC_MAC_TABLE_USE_FID]\t= BIT(23),\n\t[STATIC_MAC_TABLE_FID]\t\t= GENMASK(30, 24),\n\t[STATIC_MAC_TABLE_OVERRIDE]\t= BIT(22),\n\t[STATIC_MAC_TABLE_FWD_PORTS]\t= GENMASK(20, 16),\n\t[DYNAMIC_MAC_TABLE_ENTRIES_H]\t= GENMASK(6, 0),\n\t[DYNAMIC_MAC_TABLE_MAC_EMPTY]\t= BIT(7),\n\t[DYNAMIC_MAC_TABLE_NOT_READY]\t= BIT(7),\n\t[DYNAMIC_MAC_TABLE_ENTRIES]\t= GENMASK(31, 29),\n\t[DYNAMIC_MAC_TABLE_FID]\t\t= GENMASK(22, 16),\n\t[DYNAMIC_MAC_TABLE_SRC_PORT]\t= GENMASK(26, 24),\n\t[DYNAMIC_MAC_TABLE_TIMESTAMP]\t= GENMASK(28, 27),\n\t[P_MII_TX_FLOW_CTRL]\t\t= BIT(5),\n\t[P_MII_RX_FLOW_CTRL]\t\t= BIT(5),\n};\n\nstatic const u8 ksz8795_xmii_ctrl0[] = {\n\t[P_MII_100MBIT]\t\t\t= 0,\n\t[P_MII_10MBIT]\t\t\t= 1,\n\t[P_MII_FULL_DUPLEX]\t\t= 0,\n\t[P_MII_HALF_DUPLEX]\t\t= 1,\n};\n\nstatic const u8 ksz8795_xmii_ctrl1[] = {\n\t[P_RGMII_SEL]\t\t\t= 3,\n\t[P_GMII_SEL]\t\t\t= 2,\n\t[P_RMII_SEL]\t\t\t= 1,\n\t[P_MII_SEL]\t\t\t= 0,\n\t[P_GMII_1GBIT]\t\t\t= 1,\n\t[P_GMII_NOT_1GBIT]\t\t= 0,\n};\n\nstatic const u8 ksz8795_shifts[] = {\n\t[VLAN_TABLE_MEMBERSHIP_S]\t= 7,\n\t[VLAN_TABLE]\t\t\t= 16,\n\t[STATIC_MAC_FWD_PORTS]\t\t= 16,\n\t[STATIC_MAC_FID]\t\t= 24,\n\t[DYNAMIC_MAC_ENTRIES_H]\t\t= 3,\n\t[DYNAMIC_MAC_ENTRIES]\t\t= 29,\n\t[DYNAMIC_MAC_FID]\t\t= 16,\n\t[DYNAMIC_MAC_TIMESTAMP]\t\t= 27,\n\t[DYNAMIC_MAC_SRC_PORT]\t\t= 24,\n};\n\nstatic const u16 ksz8863_regs[] = {\n\t[REG_IND_CTRL_0]\t\t= 0x79,\n\t[REG_IND_DATA_8]\t\t= 0x7B,\n\t[REG_IND_DATA_CHECK]\t\t= 0x7B,\n\t[REG_IND_DATA_HI]\t\t= 0x7C,\n\t[REG_IND_DATA_LO]\t\t= 0x80,\n\t[REG_IND_MIB_CHECK]\t\t= 0x80,\n\t[P_FORCE_CTRL]\t\t\t= 0x0C,\n\t[P_LINK_STATUS]\t\t\t= 0x0E,\n\t[P_LOCAL_CTRL]\t\t\t= 0x0C,\n\t[P_NEG_RESTART_CTRL]\t\t= 0x0D,\n\t[P_REMOTE_STATUS]\t\t= 0x0E,\n\t[P_SPEED_STATUS]\t\t= 0x0F,\n\t[S_TAIL_TAG_CTRL]\t\t= 0x03,\n\t[P_STP_CTRL]\t\t\t= 0x02,\n\t[S_START_CTRL]\t\t\t= 0x01,\n\t[S_BROADCAST_CTRL]\t\t= 0x06,\n\t[S_MULTICAST_CTRL]\t\t= 0x04,\n};\n\nstatic const u32 ksz8863_masks[] = {\n\t[PORT_802_1P_REMAPPING]\t\t= BIT(3),\n\t[SW_TAIL_TAG_ENABLE]\t\t= BIT(6),\n\t[MIB_COUNTER_OVERFLOW]\t\t= BIT(7),\n\t[MIB_COUNTER_VALID]\t\t= BIT(6),\n\t[VLAN_TABLE_FID]\t\t= GENMASK(15, 12),\n\t[VLAN_TABLE_MEMBERSHIP]\t\t= GENMASK(18, 16),\n\t[VLAN_TABLE_VALID]\t\t= BIT(19),\n\t[STATIC_MAC_TABLE_VALID]\t= BIT(19),\n\t[STATIC_MAC_TABLE_USE_FID]\t= BIT(21),\n\t[STATIC_MAC_TABLE_FID]\t\t= GENMASK(25, 22),\n\t[STATIC_MAC_TABLE_OVERRIDE]\t= BIT(20),\n\t[STATIC_MAC_TABLE_FWD_PORTS]\t= GENMASK(18, 16),\n\t[DYNAMIC_MAC_TABLE_ENTRIES_H]\t= GENMASK(1, 0),\n\t[DYNAMIC_MAC_TABLE_MAC_EMPTY]\t= BIT(2),\n\t[DYNAMIC_MAC_TABLE_NOT_READY]\t= BIT(7),\n\t[DYNAMIC_MAC_TABLE_ENTRIES]\t= GENMASK(31, 24),\n\t[DYNAMIC_MAC_TABLE_FID]\t\t= GENMASK(19, 16),\n\t[DYNAMIC_MAC_TABLE_SRC_PORT]\t= GENMASK(21, 20),\n\t[DYNAMIC_MAC_TABLE_TIMESTAMP]\t= GENMASK(23, 22),\n};\n\nstatic u8 ksz8863_shifts[] = {\n\t[VLAN_TABLE_MEMBERSHIP_S]\t= 16,\n\t[STATIC_MAC_FWD_PORTS]\t\t= 16,\n\t[STATIC_MAC_FID]\t\t= 22,\n\t[DYNAMIC_MAC_ENTRIES_H]\t\t= 8,\n\t[DYNAMIC_MAC_ENTRIES]\t\t= 24,\n\t[DYNAMIC_MAC_FID]\t\t= 16,\n\t[DYNAMIC_MAC_TIMESTAMP]\t\t= 22,\n\t[DYNAMIC_MAC_SRC_PORT]\t\t= 20,\n};\n\nstatic const u16 ksz9477_regs[] = {\n\t[P_STP_CTRL]\t\t\t= 0x0B04,\n\t[S_START_CTRL]\t\t\t= 0x0300,\n\t[S_BROADCAST_CTRL]\t\t= 0x0332,\n\t[S_MULTICAST_CTRL]\t\t= 0x0331,\n\t[P_XMII_CTRL_0]\t\t\t= 0x0300,\n\t[P_XMII_CTRL_1]\t\t\t= 0x0301,\n};\n\nstatic const u32 ksz9477_masks[] = {\n\t[ALU_STAT_WRITE]\t\t= 0,\n\t[ALU_STAT_READ]\t\t\t= 1,\n\t[P_MII_TX_FLOW_CTRL]\t\t= BIT(5),\n\t[P_MII_RX_FLOW_CTRL]\t\t= BIT(3),\n};\n\nstatic const u8 ksz9477_shifts[] = {\n\t[ALU_STAT_INDEX]\t\t= 16,\n};\n\nstatic const u8 ksz9477_xmii_ctrl0[] = {\n\t[P_MII_100MBIT]\t\t\t= 1,\n\t[P_MII_10MBIT]\t\t\t= 0,\n\t[P_MII_FULL_DUPLEX]\t\t= 1,\n\t[P_MII_HALF_DUPLEX]\t\t= 0,\n};\n\nstatic const u8 ksz9477_xmii_ctrl1[] = {\n\t[P_RGMII_SEL]\t\t\t= 0,\n\t[P_RMII_SEL]\t\t\t= 1,\n\t[P_GMII_SEL]\t\t\t= 2,\n\t[P_MII_SEL]\t\t\t= 3,\n\t[P_GMII_1GBIT]\t\t\t= 0,\n\t[P_GMII_NOT_1GBIT]\t\t= 1,\n};\n\nstatic const u32 lan937x_masks[] = {\n\t[ALU_STAT_WRITE]\t\t= 1,\n\t[ALU_STAT_READ]\t\t\t= 2,\n\t[P_MII_TX_FLOW_CTRL]\t\t= BIT(5),\n\t[P_MII_RX_FLOW_CTRL]\t\t= BIT(3),\n};\n\nstatic const u8 lan937x_shifts[] = {\n\t[ALU_STAT_INDEX]\t\t= 8,\n};\n\nstatic const struct regmap_range ksz8563_valid_regs[] = {\n\tregmap_reg_range(0x0000, 0x0003),\n\tregmap_reg_range(0x0006, 0x0006),\n\tregmap_reg_range(0x000f, 0x001f),\n\tregmap_reg_range(0x0100, 0x0100),\n\tregmap_reg_range(0x0104, 0x0107),\n\tregmap_reg_range(0x010d, 0x010d),\n\tregmap_reg_range(0x0110, 0x0113),\n\tregmap_reg_range(0x0120, 0x012b),\n\tregmap_reg_range(0x0201, 0x0201),\n\tregmap_reg_range(0x0210, 0x0213),\n\tregmap_reg_range(0x0300, 0x0300),\n\tregmap_reg_range(0x0302, 0x031b),\n\tregmap_reg_range(0x0320, 0x032b),\n\tregmap_reg_range(0x0330, 0x0336),\n\tregmap_reg_range(0x0338, 0x033e),\n\tregmap_reg_range(0x0340, 0x035f),\n\tregmap_reg_range(0x0370, 0x0370),\n\tregmap_reg_range(0x0378, 0x0378),\n\tregmap_reg_range(0x037c, 0x037d),\n\tregmap_reg_range(0x0390, 0x0393),\n\tregmap_reg_range(0x0400, 0x040e),\n\tregmap_reg_range(0x0410, 0x042f),\n\tregmap_reg_range(0x0500, 0x0519),\n\tregmap_reg_range(0x0520, 0x054b),\n\tregmap_reg_range(0x0550, 0x05b3),\n\n\t \n\tregmap_reg_range(0x1000, 0x1001),\n\tregmap_reg_range(0x1004, 0x100b),\n\tregmap_reg_range(0x1013, 0x1013),\n\tregmap_reg_range(0x1017, 0x1017),\n\tregmap_reg_range(0x101b, 0x101b),\n\tregmap_reg_range(0x101f, 0x1021),\n\tregmap_reg_range(0x1030, 0x1030),\n\tregmap_reg_range(0x1100, 0x1111),\n\tregmap_reg_range(0x111a, 0x111d),\n\tregmap_reg_range(0x1122, 0x1127),\n\tregmap_reg_range(0x112a, 0x112b),\n\tregmap_reg_range(0x1136, 0x1139),\n\tregmap_reg_range(0x113e, 0x113f),\n\tregmap_reg_range(0x1400, 0x1401),\n\tregmap_reg_range(0x1403, 0x1403),\n\tregmap_reg_range(0x1410, 0x1417),\n\tregmap_reg_range(0x1420, 0x1423),\n\tregmap_reg_range(0x1500, 0x1507),\n\tregmap_reg_range(0x1600, 0x1612),\n\tregmap_reg_range(0x1800, 0x180f),\n\tregmap_reg_range(0x1900, 0x1907),\n\tregmap_reg_range(0x1914, 0x191b),\n\tregmap_reg_range(0x1a00, 0x1a03),\n\tregmap_reg_range(0x1a04, 0x1a08),\n\tregmap_reg_range(0x1b00, 0x1b01),\n\tregmap_reg_range(0x1b04, 0x1b04),\n\tregmap_reg_range(0x1c00, 0x1c05),\n\tregmap_reg_range(0x1c08, 0x1c1b),\n\n\t \n\tregmap_reg_range(0x2000, 0x2001),\n\tregmap_reg_range(0x2004, 0x200b),\n\tregmap_reg_range(0x2013, 0x2013),\n\tregmap_reg_range(0x2017, 0x2017),\n\tregmap_reg_range(0x201b, 0x201b),\n\tregmap_reg_range(0x201f, 0x2021),\n\tregmap_reg_range(0x2030, 0x2030),\n\tregmap_reg_range(0x2100, 0x2111),\n\tregmap_reg_range(0x211a, 0x211d),\n\tregmap_reg_range(0x2122, 0x2127),\n\tregmap_reg_range(0x212a, 0x212b),\n\tregmap_reg_range(0x2136, 0x2139),\n\tregmap_reg_range(0x213e, 0x213f),\n\tregmap_reg_range(0x2400, 0x2401),\n\tregmap_reg_range(0x2403, 0x2403),\n\tregmap_reg_range(0x2410, 0x2417),\n\tregmap_reg_range(0x2420, 0x2423),\n\tregmap_reg_range(0x2500, 0x2507),\n\tregmap_reg_range(0x2600, 0x2612),\n\tregmap_reg_range(0x2800, 0x280f),\n\tregmap_reg_range(0x2900, 0x2907),\n\tregmap_reg_range(0x2914, 0x291b),\n\tregmap_reg_range(0x2a00, 0x2a03),\n\tregmap_reg_range(0x2a04, 0x2a08),\n\tregmap_reg_range(0x2b00, 0x2b01),\n\tregmap_reg_range(0x2b04, 0x2b04),\n\tregmap_reg_range(0x2c00, 0x2c05),\n\tregmap_reg_range(0x2c08, 0x2c1b),\n\n\t \n\tregmap_reg_range(0x3000, 0x3001),\n\tregmap_reg_range(0x3004, 0x300b),\n\tregmap_reg_range(0x3013, 0x3013),\n\tregmap_reg_range(0x3017, 0x3017),\n\tregmap_reg_range(0x301b, 0x301b),\n\tregmap_reg_range(0x301f, 0x3021),\n\tregmap_reg_range(0x3030, 0x3030),\n\tregmap_reg_range(0x3300, 0x3301),\n\tregmap_reg_range(0x3303, 0x3303),\n\tregmap_reg_range(0x3400, 0x3401),\n\tregmap_reg_range(0x3403, 0x3403),\n\tregmap_reg_range(0x3410, 0x3417),\n\tregmap_reg_range(0x3420, 0x3423),\n\tregmap_reg_range(0x3500, 0x3507),\n\tregmap_reg_range(0x3600, 0x3612),\n\tregmap_reg_range(0x3800, 0x380f),\n\tregmap_reg_range(0x3900, 0x3907),\n\tregmap_reg_range(0x3914, 0x391b),\n\tregmap_reg_range(0x3a00, 0x3a03),\n\tregmap_reg_range(0x3a04, 0x3a08),\n\tregmap_reg_range(0x3b00, 0x3b01),\n\tregmap_reg_range(0x3b04, 0x3b04),\n\tregmap_reg_range(0x3c00, 0x3c05),\n\tregmap_reg_range(0x3c08, 0x3c1b),\n};\n\nstatic const struct regmap_access_table ksz8563_register_set = {\n\t.yes_ranges = ksz8563_valid_regs,\n\t.n_yes_ranges = ARRAY_SIZE(ksz8563_valid_regs),\n};\n\nstatic const struct regmap_range ksz9477_valid_regs[] = {\n\tregmap_reg_range(0x0000, 0x0003),\n\tregmap_reg_range(0x0006, 0x0006),\n\tregmap_reg_range(0x0010, 0x001f),\n\tregmap_reg_range(0x0100, 0x0100),\n\tregmap_reg_range(0x0103, 0x0107),\n\tregmap_reg_range(0x010d, 0x010d),\n\tregmap_reg_range(0x0110, 0x0113),\n\tregmap_reg_range(0x0120, 0x012b),\n\tregmap_reg_range(0x0201, 0x0201),\n\tregmap_reg_range(0x0210, 0x0213),\n\tregmap_reg_range(0x0300, 0x0300),\n\tregmap_reg_range(0x0302, 0x031b),\n\tregmap_reg_range(0x0320, 0x032b),\n\tregmap_reg_range(0x0330, 0x0336),\n\tregmap_reg_range(0x0338, 0x033b),\n\tregmap_reg_range(0x033e, 0x033e),\n\tregmap_reg_range(0x0340, 0x035f),\n\tregmap_reg_range(0x0370, 0x0370),\n\tregmap_reg_range(0x0378, 0x0378),\n\tregmap_reg_range(0x037c, 0x037d),\n\tregmap_reg_range(0x0390, 0x0393),\n\tregmap_reg_range(0x0400, 0x040e),\n\tregmap_reg_range(0x0410, 0x042f),\n\tregmap_reg_range(0x0444, 0x044b),\n\tregmap_reg_range(0x0450, 0x046f),\n\tregmap_reg_range(0x0500, 0x0519),\n\tregmap_reg_range(0x0520, 0x054b),\n\tregmap_reg_range(0x0550, 0x05b3),\n\tregmap_reg_range(0x0604, 0x060b),\n\tregmap_reg_range(0x0610, 0x0612),\n\tregmap_reg_range(0x0614, 0x062c),\n\tregmap_reg_range(0x0640, 0x0645),\n\tregmap_reg_range(0x0648, 0x064d),\n\n\t \n\tregmap_reg_range(0x1000, 0x1001),\n\tregmap_reg_range(0x1013, 0x1013),\n\tregmap_reg_range(0x1017, 0x1017),\n\tregmap_reg_range(0x101b, 0x101b),\n\tregmap_reg_range(0x101f, 0x1020),\n\tregmap_reg_range(0x1030, 0x1030),\n\tregmap_reg_range(0x1100, 0x1115),\n\tregmap_reg_range(0x111a, 0x111f),\n\tregmap_reg_range(0x1120, 0x112b),\n\tregmap_reg_range(0x1134, 0x113b),\n\tregmap_reg_range(0x113c, 0x113f),\n\tregmap_reg_range(0x1400, 0x1401),\n\tregmap_reg_range(0x1403, 0x1403),\n\tregmap_reg_range(0x1410, 0x1417),\n\tregmap_reg_range(0x1420, 0x1423),\n\tregmap_reg_range(0x1500, 0x1507),\n\tregmap_reg_range(0x1600, 0x1613),\n\tregmap_reg_range(0x1800, 0x180f),\n\tregmap_reg_range(0x1820, 0x1827),\n\tregmap_reg_range(0x1830, 0x1837),\n\tregmap_reg_range(0x1840, 0x184b),\n\tregmap_reg_range(0x1900, 0x1907),\n\tregmap_reg_range(0x1914, 0x191b),\n\tregmap_reg_range(0x1920, 0x1920),\n\tregmap_reg_range(0x1923, 0x1927),\n\tregmap_reg_range(0x1a00, 0x1a03),\n\tregmap_reg_range(0x1a04, 0x1a07),\n\tregmap_reg_range(0x1b00, 0x1b01),\n\tregmap_reg_range(0x1b04, 0x1b04),\n\tregmap_reg_range(0x1c00, 0x1c05),\n\tregmap_reg_range(0x1c08, 0x1c1b),\n\n\t \n\tregmap_reg_range(0x2000, 0x2001),\n\tregmap_reg_range(0x2013, 0x2013),\n\tregmap_reg_range(0x2017, 0x2017),\n\tregmap_reg_range(0x201b, 0x201b),\n\tregmap_reg_range(0x201f, 0x2020),\n\tregmap_reg_range(0x2030, 0x2030),\n\tregmap_reg_range(0x2100, 0x2115),\n\tregmap_reg_range(0x211a, 0x211f),\n\tregmap_reg_range(0x2120, 0x212b),\n\tregmap_reg_range(0x2134, 0x213b),\n\tregmap_reg_range(0x213c, 0x213f),\n\tregmap_reg_range(0x2400, 0x2401),\n\tregmap_reg_range(0x2403, 0x2403),\n\tregmap_reg_range(0x2410, 0x2417),\n\tregmap_reg_range(0x2420, 0x2423),\n\tregmap_reg_range(0x2500, 0x2507),\n\tregmap_reg_range(0x2600, 0x2613),\n\tregmap_reg_range(0x2800, 0x280f),\n\tregmap_reg_range(0x2820, 0x2827),\n\tregmap_reg_range(0x2830, 0x2837),\n\tregmap_reg_range(0x2840, 0x284b),\n\tregmap_reg_range(0x2900, 0x2907),\n\tregmap_reg_range(0x2914, 0x291b),\n\tregmap_reg_range(0x2920, 0x2920),\n\tregmap_reg_range(0x2923, 0x2927),\n\tregmap_reg_range(0x2a00, 0x2a03),\n\tregmap_reg_range(0x2a04, 0x2a07),\n\tregmap_reg_range(0x2b00, 0x2b01),\n\tregmap_reg_range(0x2b04, 0x2b04),\n\tregmap_reg_range(0x2c00, 0x2c05),\n\tregmap_reg_range(0x2c08, 0x2c1b),\n\n\t \n\tregmap_reg_range(0x3000, 0x3001),\n\tregmap_reg_range(0x3013, 0x3013),\n\tregmap_reg_range(0x3017, 0x3017),\n\tregmap_reg_range(0x301b, 0x301b),\n\tregmap_reg_range(0x301f, 0x3020),\n\tregmap_reg_range(0x3030, 0x3030),\n\tregmap_reg_range(0x3100, 0x3115),\n\tregmap_reg_range(0x311a, 0x311f),\n\tregmap_reg_range(0x3120, 0x312b),\n\tregmap_reg_range(0x3134, 0x313b),\n\tregmap_reg_range(0x313c, 0x313f),\n\tregmap_reg_range(0x3400, 0x3401),\n\tregmap_reg_range(0x3403, 0x3403),\n\tregmap_reg_range(0x3410, 0x3417),\n\tregmap_reg_range(0x3420, 0x3423),\n\tregmap_reg_range(0x3500, 0x3507),\n\tregmap_reg_range(0x3600, 0x3613),\n\tregmap_reg_range(0x3800, 0x380f),\n\tregmap_reg_range(0x3820, 0x3827),\n\tregmap_reg_range(0x3830, 0x3837),\n\tregmap_reg_range(0x3840, 0x384b),\n\tregmap_reg_range(0x3900, 0x3907),\n\tregmap_reg_range(0x3914, 0x391b),\n\tregmap_reg_range(0x3920, 0x3920),\n\tregmap_reg_range(0x3923, 0x3927),\n\tregmap_reg_range(0x3a00, 0x3a03),\n\tregmap_reg_range(0x3a04, 0x3a07),\n\tregmap_reg_range(0x3b00, 0x3b01),\n\tregmap_reg_range(0x3b04, 0x3b04),\n\tregmap_reg_range(0x3c00, 0x3c05),\n\tregmap_reg_range(0x3c08, 0x3c1b),\n\n\t \n\tregmap_reg_range(0x4000, 0x4001),\n\tregmap_reg_range(0x4013, 0x4013),\n\tregmap_reg_range(0x4017, 0x4017),\n\tregmap_reg_range(0x401b, 0x401b),\n\tregmap_reg_range(0x401f, 0x4020),\n\tregmap_reg_range(0x4030, 0x4030),\n\tregmap_reg_range(0x4100, 0x4115),\n\tregmap_reg_range(0x411a, 0x411f),\n\tregmap_reg_range(0x4120, 0x412b),\n\tregmap_reg_range(0x4134, 0x413b),\n\tregmap_reg_range(0x413c, 0x413f),\n\tregmap_reg_range(0x4400, 0x4401),\n\tregmap_reg_range(0x4403, 0x4403),\n\tregmap_reg_range(0x4410, 0x4417),\n\tregmap_reg_range(0x4420, 0x4423),\n\tregmap_reg_range(0x4500, 0x4507),\n\tregmap_reg_range(0x4600, 0x4613),\n\tregmap_reg_range(0x4800, 0x480f),\n\tregmap_reg_range(0x4820, 0x4827),\n\tregmap_reg_range(0x4830, 0x4837),\n\tregmap_reg_range(0x4840, 0x484b),\n\tregmap_reg_range(0x4900, 0x4907),\n\tregmap_reg_range(0x4914, 0x491b),\n\tregmap_reg_range(0x4920, 0x4920),\n\tregmap_reg_range(0x4923, 0x4927),\n\tregmap_reg_range(0x4a00, 0x4a03),\n\tregmap_reg_range(0x4a04, 0x4a07),\n\tregmap_reg_range(0x4b00, 0x4b01),\n\tregmap_reg_range(0x4b04, 0x4b04),\n\tregmap_reg_range(0x4c00, 0x4c05),\n\tregmap_reg_range(0x4c08, 0x4c1b),\n\n\t \n\tregmap_reg_range(0x5000, 0x5001),\n\tregmap_reg_range(0x5013, 0x5013),\n\tregmap_reg_range(0x5017, 0x5017),\n\tregmap_reg_range(0x501b, 0x501b),\n\tregmap_reg_range(0x501f, 0x5020),\n\tregmap_reg_range(0x5030, 0x5030),\n\tregmap_reg_range(0x5100, 0x5115),\n\tregmap_reg_range(0x511a, 0x511f),\n\tregmap_reg_range(0x5120, 0x512b),\n\tregmap_reg_range(0x5134, 0x513b),\n\tregmap_reg_range(0x513c, 0x513f),\n\tregmap_reg_range(0x5400, 0x5401),\n\tregmap_reg_range(0x5403, 0x5403),\n\tregmap_reg_range(0x5410, 0x5417),\n\tregmap_reg_range(0x5420, 0x5423),\n\tregmap_reg_range(0x5500, 0x5507),\n\tregmap_reg_range(0x5600, 0x5613),\n\tregmap_reg_range(0x5800, 0x580f),\n\tregmap_reg_range(0x5820, 0x5827),\n\tregmap_reg_range(0x5830, 0x5837),\n\tregmap_reg_range(0x5840, 0x584b),\n\tregmap_reg_range(0x5900, 0x5907),\n\tregmap_reg_range(0x5914, 0x591b),\n\tregmap_reg_range(0x5920, 0x5920),\n\tregmap_reg_range(0x5923, 0x5927),\n\tregmap_reg_range(0x5a00, 0x5a03),\n\tregmap_reg_range(0x5a04, 0x5a07),\n\tregmap_reg_range(0x5b00, 0x5b01),\n\tregmap_reg_range(0x5b04, 0x5b04),\n\tregmap_reg_range(0x5c00, 0x5c05),\n\tregmap_reg_range(0x5c08, 0x5c1b),\n\n\t \n\tregmap_reg_range(0x6000, 0x6001),\n\tregmap_reg_range(0x6013, 0x6013),\n\tregmap_reg_range(0x6017, 0x6017),\n\tregmap_reg_range(0x601b, 0x601b),\n\tregmap_reg_range(0x601f, 0x6020),\n\tregmap_reg_range(0x6030, 0x6030),\n\tregmap_reg_range(0x6300, 0x6301),\n\tregmap_reg_range(0x6400, 0x6401),\n\tregmap_reg_range(0x6403, 0x6403),\n\tregmap_reg_range(0x6410, 0x6417),\n\tregmap_reg_range(0x6420, 0x6423),\n\tregmap_reg_range(0x6500, 0x6507),\n\tregmap_reg_range(0x6600, 0x6613),\n\tregmap_reg_range(0x6800, 0x680f),\n\tregmap_reg_range(0x6820, 0x6827),\n\tregmap_reg_range(0x6830, 0x6837),\n\tregmap_reg_range(0x6840, 0x684b),\n\tregmap_reg_range(0x6900, 0x6907),\n\tregmap_reg_range(0x6914, 0x691b),\n\tregmap_reg_range(0x6920, 0x6920),\n\tregmap_reg_range(0x6923, 0x6927),\n\tregmap_reg_range(0x6a00, 0x6a03),\n\tregmap_reg_range(0x6a04, 0x6a07),\n\tregmap_reg_range(0x6b00, 0x6b01),\n\tregmap_reg_range(0x6b04, 0x6b04),\n\tregmap_reg_range(0x6c00, 0x6c05),\n\tregmap_reg_range(0x6c08, 0x6c1b),\n\n\t \n\tregmap_reg_range(0x7000, 0x7001),\n\tregmap_reg_range(0x7013, 0x7013),\n\tregmap_reg_range(0x7017, 0x7017),\n\tregmap_reg_range(0x701b, 0x701b),\n\tregmap_reg_range(0x701f, 0x7020),\n\tregmap_reg_range(0x7030, 0x7030),\n\tregmap_reg_range(0x7200, 0x7203),\n\tregmap_reg_range(0x7206, 0x7207),\n\tregmap_reg_range(0x7300, 0x7301),\n\tregmap_reg_range(0x7400, 0x7401),\n\tregmap_reg_range(0x7403, 0x7403),\n\tregmap_reg_range(0x7410, 0x7417),\n\tregmap_reg_range(0x7420, 0x7423),\n\tregmap_reg_range(0x7500, 0x7507),\n\tregmap_reg_range(0x7600, 0x7613),\n\tregmap_reg_range(0x7800, 0x780f),\n\tregmap_reg_range(0x7820, 0x7827),\n\tregmap_reg_range(0x7830, 0x7837),\n\tregmap_reg_range(0x7840, 0x784b),\n\tregmap_reg_range(0x7900, 0x7907),\n\tregmap_reg_range(0x7914, 0x791b),\n\tregmap_reg_range(0x7920, 0x7920),\n\tregmap_reg_range(0x7923, 0x7927),\n\tregmap_reg_range(0x7a00, 0x7a03),\n\tregmap_reg_range(0x7a04, 0x7a07),\n\tregmap_reg_range(0x7b00, 0x7b01),\n\tregmap_reg_range(0x7b04, 0x7b04),\n\tregmap_reg_range(0x7c00, 0x7c05),\n\tregmap_reg_range(0x7c08, 0x7c1b),\n};\n\nstatic const struct regmap_access_table ksz9477_register_set = {\n\t.yes_ranges = ksz9477_valid_regs,\n\t.n_yes_ranges = ARRAY_SIZE(ksz9477_valid_regs),\n};\n\nstatic const struct regmap_range ksz9896_valid_regs[] = {\n\tregmap_reg_range(0x0000, 0x0003),\n\tregmap_reg_range(0x0006, 0x0006),\n\tregmap_reg_range(0x0010, 0x001f),\n\tregmap_reg_range(0x0100, 0x0100),\n\tregmap_reg_range(0x0103, 0x0107),\n\tregmap_reg_range(0x010d, 0x010d),\n\tregmap_reg_range(0x0110, 0x0113),\n\tregmap_reg_range(0x0120, 0x0127),\n\tregmap_reg_range(0x0201, 0x0201),\n\tregmap_reg_range(0x0210, 0x0213),\n\tregmap_reg_range(0x0300, 0x0300),\n\tregmap_reg_range(0x0302, 0x030b),\n\tregmap_reg_range(0x0310, 0x031b),\n\tregmap_reg_range(0x0320, 0x032b),\n\tregmap_reg_range(0x0330, 0x0336),\n\tregmap_reg_range(0x0338, 0x033b),\n\tregmap_reg_range(0x033e, 0x033e),\n\tregmap_reg_range(0x0340, 0x035f),\n\tregmap_reg_range(0x0370, 0x0370),\n\tregmap_reg_range(0x0378, 0x0378),\n\tregmap_reg_range(0x037c, 0x037d),\n\tregmap_reg_range(0x0390, 0x0393),\n\tregmap_reg_range(0x0400, 0x040e),\n\tregmap_reg_range(0x0410, 0x042f),\n\n\t \n\tregmap_reg_range(0x1000, 0x1001),\n\tregmap_reg_range(0x1013, 0x1013),\n\tregmap_reg_range(0x1017, 0x1017),\n\tregmap_reg_range(0x101b, 0x101b),\n\tregmap_reg_range(0x101f, 0x1020),\n\tregmap_reg_range(0x1030, 0x1030),\n\tregmap_reg_range(0x1100, 0x1115),\n\tregmap_reg_range(0x111a, 0x111f),\n\tregmap_reg_range(0x1122, 0x1127),\n\tregmap_reg_range(0x112a, 0x112b),\n\tregmap_reg_range(0x1136, 0x1139),\n\tregmap_reg_range(0x113e, 0x113f),\n\tregmap_reg_range(0x1400, 0x1401),\n\tregmap_reg_range(0x1403, 0x1403),\n\tregmap_reg_range(0x1410, 0x1417),\n\tregmap_reg_range(0x1420, 0x1423),\n\tregmap_reg_range(0x1500, 0x1507),\n\tregmap_reg_range(0x1600, 0x1612),\n\tregmap_reg_range(0x1800, 0x180f),\n\tregmap_reg_range(0x1820, 0x1827),\n\tregmap_reg_range(0x1830, 0x1837),\n\tregmap_reg_range(0x1840, 0x184b),\n\tregmap_reg_range(0x1900, 0x1907),\n\tregmap_reg_range(0x1914, 0x1915),\n\tregmap_reg_range(0x1a00, 0x1a03),\n\tregmap_reg_range(0x1a04, 0x1a07),\n\tregmap_reg_range(0x1b00, 0x1b01),\n\tregmap_reg_range(0x1b04, 0x1b04),\n\n\t \n\tregmap_reg_range(0x2000, 0x2001),\n\tregmap_reg_range(0x2013, 0x2013),\n\tregmap_reg_range(0x2017, 0x2017),\n\tregmap_reg_range(0x201b, 0x201b),\n\tregmap_reg_range(0x201f, 0x2020),\n\tregmap_reg_range(0x2030, 0x2030),\n\tregmap_reg_range(0x2100, 0x2115),\n\tregmap_reg_range(0x211a, 0x211f),\n\tregmap_reg_range(0x2122, 0x2127),\n\tregmap_reg_range(0x212a, 0x212b),\n\tregmap_reg_range(0x2136, 0x2139),\n\tregmap_reg_range(0x213e, 0x213f),\n\tregmap_reg_range(0x2400, 0x2401),\n\tregmap_reg_range(0x2403, 0x2403),\n\tregmap_reg_range(0x2410, 0x2417),\n\tregmap_reg_range(0x2420, 0x2423),\n\tregmap_reg_range(0x2500, 0x2507),\n\tregmap_reg_range(0x2600, 0x2612),\n\tregmap_reg_range(0x2800, 0x280f),\n\tregmap_reg_range(0x2820, 0x2827),\n\tregmap_reg_range(0x2830, 0x2837),\n\tregmap_reg_range(0x2840, 0x284b),\n\tregmap_reg_range(0x2900, 0x2907),\n\tregmap_reg_range(0x2914, 0x2915),\n\tregmap_reg_range(0x2a00, 0x2a03),\n\tregmap_reg_range(0x2a04, 0x2a07),\n\tregmap_reg_range(0x2b00, 0x2b01),\n\tregmap_reg_range(0x2b04, 0x2b04),\n\n\t \n\tregmap_reg_range(0x3000, 0x3001),\n\tregmap_reg_range(0x3013, 0x3013),\n\tregmap_reg_range(0x3017, 0x3017),\n\tregmap_reg_range(0x301b, 0x301b),\n\tregmap_reg_range(0x301f, 0x3020),\n\tregmap_reg_range(0x3030, 0x3030),\n\tregmap_reg_range(0x3100, 0x3115),\n\tregmap_reg_range(0x311a, 0x311f),\n\tregmap_reg_range(0x3122, 0x3127),\n\tregmap_reg_range(0x312a, 0x312b),\n\tregmap_reg_range(0x3136, 0x3139),\n\tregmap_reg_range(0x313e, 0x313f),\n\tregmap_reg_range(0x3400, 0x3401),\n\tregmap_reg_range(0x3403, 0x3403),\n\tregmap_reg_range(0x3410, 0x3417),\n\tregmap_reg_range(0x3420, 0x3423),\n\tregmap_reg_range(0x3500, 0x3507),\n\tregmap_reg_range(0x3600, 0x3612),\n\tregmap_reg_range(0x3800, 0x380f),\n\tregmap_reg_range(0x3820, 0x3827),\n\tregmap_reg_range(0x3830, 0x3837),\n\tregmap_reg_range(0x3840, 0x384b),\n\tregmap_reg_range(0x3900, 0x3907),\n\tregmap_reg_range(0x3914, 0x3915),\n\tregmap_reg_range(0x3a00, 0x3a03),\n\tregmap_reg_range(0x3a04, 0x3a07),\n\tregmap_reg_range(0x3b00, 0x3b01),\n\tregmap_reg_range(0x3b04, 0x3b04),\n\n\t \n\tregmap_reg_range(0x4000, 0x4001),\n\tregmap_reg_range(0x4013, 0x4013),\n\tregmap_reg_range(0x4017, 0x4017),\n\tregmap_reg_range(0x401b, 0x401b),\n\tregmap_reg_range(0x401f, 0x4020),\n\tregmap_reg_range(0x4030, 0x4030),\n\tregmap_reg_range(0x4100, 0x4115),\n\tregmap_reg_range(0x411a, 0x411f),\n\tregmap_reg_range(0x4122, 0x4127),\n\tregmap_reg_range(0x412a, 0x412b),\n\tregmap_reg_range(0x4136, 0x4139),\n\tregmap_reg_range(0x413e, 0x413f),\n\tregmap_reg_range(0x4400, 0x4401),\n\tregmap_reg_range(0x4403, 0x4403),\n\tregmap_reg_range(0x4410, 0x4417),\n\tregmap_reg_range(0x4420, 0x4423),\n\tregmap_reg_range(0x4500, 0x4507),\n\tregmap_reg_range(0x4600, 0x4612),\n\tregmap_reg_range(0x4800, 0x480f),\n\tregmap_reg_range(0x4820, 0x4827),\n\tregmap_reg_range(0x4830, 0x4837),\n\tregmap_reg_range(0x4840, 0x484b),\n\tregmap_reg_range(0x4900, 0x4907),\n\tregmap_reg_range(0x4914, 0x4915),\n\tregmap_reg_range(0x4a00, 0x4a03),\n\tregmap_reg_range(0x4a04, 0x4a07),\n\tregmap_reg_range(0x4b00, 0x4b01),\n\tregmap_reg_range(0x4b04, 0x4b04),\n\n\t \n\tregmap_reg_range(0x5000, 0x5001),\n\tregmap_reg_range(0x5013, 0x5013),\n\tregmap_reg_range(0x5017, 0x5017),\n\tregmap_reg_range(0x501b, 0x501b),\n\tregmap_reg_range(0x501f, 0x5020),\n\tregmap_reg_range(0x5030, 0x5030),\n\tregmap_reg_range(0x5100, 0x5115),\n\tregmap_reg_range(0x511a, 0x511f),\n\tregmap_reg_range(0x5122, 0x5127),\n\tregmap_reg_range(0x512a, 0x512b),\n\tregmap_reg_range(0x5136, 0x5139),\n\tregmap_reg_range(0x513e, 0x513f),\n\tregmap_reg_range(0x5400, 0x5401),\n\tregmap_reg_range(0x5403, 0x5403),\n\tregmap_reg_range(0x5410, 0x5417),\n\tregmap_reg_range(0x5420, 0x5423),\n\tregmap_reg_range(0x5500, 0x5507),\n\tregmap_reg_range(0x5600, 0x5612),\n\tregmap_reg_range(0x5800, 0x580f),\n\tregmap_reg_range(0x5820, 0x5827),\n\tregmap_reg_range(0x5830, 0x5837),\n\tregmap_reg_range(0x5840, 0x584b),\n\tregmap_reg_range(0x5900, 0x5907),\n\tregmap_reg_range(0x5914, 0x5915),\n\tregmap_reg_range(0x5a00, 0x5a03),\n\tregmap_reg_range(0x5a04, 0x5a07),\n\tregmap_reg_range(0x5b00, 0x5b01),\n\tregmap_reg_range(0x5b04, 0x5b04),\n\n\t \n\tregmap_reg_range(0x6000, 0x6001),\n\tregmap_reg_range(0x6013, 0x6013),\n\tregmap_reg_range(0x6017, 0x6017),\n\tregmap_reg_range(0x601b, 0x601b),\n\tregmap_reg_range(0x601f, 0x6020),\n\tregmap_reg_range(0x6030, 0x6030),\n\tregmap_reg_range(0x6100, 0x6115),\n\tregmap_reg_range(0x611a, 0x611f),\n\tregmap_reg_range(0x6122, 0x6127),\n\tregmap_reg_range(0x612a, 0x612b),\n\tregmap_reg_range(0x6136, 0x6139),\n\tregmap_reg_range(0x613e, 0x613f),\n\tregmap_reg_range(0x6300, 0x6301),\n\tregmap_reg_range(0x6400, 0x6401),\n\tregmap_reg_range(0x6403, 0x6403),\n\tregmap_reg_range(0x6410, 0x6417),\n\tregmap_reg_range(0x6420, 0x6423),\n\tregmap_reg_range(0x6500, 0x6507),\n\tregmap_reg_range(0x6600, 0x6612),\n\tregmap_reg_range(0x6800, 0x680f),\n\tregmap_reg_range(0x6820, 0x6827),\n\tregmap_reg_range(0x6830, 0x6837),\n\tregmap_reg_range(0x6840, 0x684b),\n\tregmap_reg_range(0x6900, 0x6907),\n\tregmap_reg_range(0x6914, 0x6915),\n\tregmap_reg_range(0x6a00, 0x6a03),\n\tregmap_reg_range(0x6a04, 0x6a07),\n\tregmap_reg_range(0x6b00, 0x6b01),\n\tregmap_reg_range(0x6b04, 0x6b04),\n};\n\nstatic const struct regmap_access_table ksz9896_register_set = {\n\t.yes_ranges = ksz9896_valid_regs,\n\t.n_yes_ranges = ARRAY_SIZE(ksz9896_valid_regs),\n};\n\nstatic const struct regmap_range ksz8873_valid_regs[] = {\n\tregmap_reg_range(0x00, 0x01),\n\t \n\tregmap_reg_range(0x02, 0x0f),\n\n\t \n\tregmap_reg_range(0x10, 0x1d),\n\tregmap_reg_range(0x1e, 0x1f),\n\tregmap_reg_range(0x20, 0x2d),\n\tregmap_reg_range(0x2e, 0x2f),\n\tregmap_reg_range(0x30, 0x39),\n\tregmap_reg_range(0x3f, 0x3f),\n\n\t \n\tregmap_reg_range(0x60, 0x6f),\n\tregmap_reg_range(0x70, 0x75),\n\tregmap_reg_range(0x76, 0x78),\n\tregmap_reg_range(0x79, 0x7a),\n\tregmap_reg_range(0x7b, 0x83),\n\tregmap_reg_range(0x8e, 0x99),\n\tregmap_reg_range(0x9a, 0xa5),\n\tregmap_reg_range(0xa6, 0xa6),\n\tregmap_reg_range(0xa7, 0xaa),\n\tregmap_reg_range(0xab, 0xae),\n\tregmap_reg_range(0xaf, 0xba),\n\tregmap_reg_range(0xbb, 0xbc),\n\tregmap_reg_range(0xbd, 0xbd),\n\tregmap_reg_range(0xc0, 0xc0),\n\tregmap_reg_range(0xc2, 0xc2),\n\tregmap_reg_range(0xc3, 0xc3),\n\tregmap_reg_range(0xc4, 0xc4),\n\tregmap_reg_range(0xc6, 0xc6),\n};\n\nstatic const struct regmap_access_table ksz8873_register_set = {\n\t.yes_ranges = ksz8873_valid_regs,\n\t.n_yes_ranges = ARRAY_SIZE(ksz8873_valid_regs),\n};\n\nconst struct ksz_chip_data ksz_switch_chips[] = {\n\t[KSZ8563] = {\n\t\t.chip_id = KSZ8563_CHIP_ID,\n\t\t.dev_name = \"KSZ8563\",\n\t\t.num_vlans = 4096,\n\t\t.num_alus = 4096,\n\t\t.num_statics = 16,\n\t\t.cpu_ports = 0x07,\t \n\t\t.port_cnt = 3,\t\t \n\t\t.port_nirqs = 3,\n\t\t.num_tx_queues = 4,\n\t\t.tc_cbs_supported = true,\n\t\t.tc_ets_supported = true,\n\t\t.ops = &ksz9477_dev_ops,\n\t\t.mib_names = ksz9477_mib_names,\n\t\t.mib_cnt = ARRAY_SIZE(ksz9477_mib_names),\n\t\t.reg_mib_cnt = MIB_COUNTER_NUM,\n\t\t.regs = ksz9477_regs,\n\t\t.masks = ksz9477_masks,\n\t\t.shifts = ksz9477_shifts,\n\t\t.xmii_ctrl0 = ksz9477_xmii_ctrl0,\n\t\t.xmii_ctrl1 = ksz8795_xmii_ctrl1,  \n\t\t.supports_mii = {false, false, true},\n\t\t.supports_rmii = {false, false, true},\n\t\t.supports_rgmii = {false, false, true},\n\t\t.internal_phy = {true, true, false},\n\t\t.gbit_capable = {false, false, true},\n\t\t.wr_table = &ksz8563_register_set,\n\t\t.rd_table = &ksz8563_register_set,\n\t},\n\n\t[KSZ8795] = {\n\t\t.chip_id = KSZ8795_CHIP_ID,\n\t\t.dev_name = \"KSZ8795\",\n\t\t.num_vlans = 4096,\n\t\t.num_alus = 0,\n\t\t.num_statics = 8,\n\t\t.cpu_ports = 0x10,\t \n\t\t.port_cnt = 5,\t\t \n\t\t.num_tx_queues = 4,\n\t\t.ops = &ksz8_dev_ops,\n\t\t.ksz87xx_eee_link_erratum = true,\n\t\t.mib_names = ksz9477_mib_names,\n\t\t.mib_cnt = ARRAY_SIZE(ksz9477_mib_names),\n\t\t.reg_mib_cnt = MIB_COUNTER_NUM,\n\t\t.regs = ksz8795_regs,\n\t\t.masks = ksz8795_masks,\n\t\t.shifts = ksz8795_shifts,\n\t\t.xmii_ctrl0 = ksz8795_xmii_ctrl0,\n\t\t.xmii_ctrl1 = ksz8795_xmii_ctrl1,\n\t\t.supports_mii = {false, false, false, false, true},\n\t\t.supports_rmii = {false, false, false, false, true},\n\t\t.supports_rgmii = {false, false, false, false, true},\n\t\t.internal_phy = {true, true, true, true, false},\n\t},\n\n\t[KSZ8794] = {\n\t\t \n\t\t.chip_id = KSZ8794_CHIP_ID,\n\t\t.dev_name = \"KSZ8794\",\n\t\t.num_vlans = 4096,\n\t\t.num_alus = 0,\n\t\t.num_statics = 8,\n\t\t.cpu_ports = 0x10,\t \n\t\t.port_cnt = 5,\t\t \n\t\t.num_tx_queues = 4,\n\t\t.ops = &ksz8_dev_ops,\n\t\t.ksz87xx_eee_link_erratum = true,\n\t\t.mib_names = ksz9477_mib_names,\n\t\t.mib_cnt = ARRAY_SIZE(ksz9477_mib_names),\n\t\t.reg_mib_cnt = MIB_COUNTER_NUM,\n\t\t.regs = ksz8795_regs,\n\t\t.masks = ksz8795_masks,\n\t\t.shifts = ksz8795_shifts,\n\t\t.xmii_ctrl0 = ksz8795_xmii_ctrl0,\n\t\t.xmii_ctrl1 = ksz8795_xmii_ctrl1,\n\t\t.supports_mii = {false, false, false, false, true},\n\t\t.supports_rmii = {false, false, false, false, true},\n\t\t.supports_rgmii = {false, false, false, false, true},\n\t\t.internal_phy = {true, true, true, false, false},\n\t},\n\n\t[KSZ8765] = {\n\t\t.chip_id = KSZ8765_CHIP_ID,\n\t\t.dev_name = \"KSZ8765\",\n\t\t.num_vlans = 4096,\n\t\t.num_alus = 0,\n\t\t.num_statics = 8,\n\t\t.cpu_ports = 0x10,\t \n\t\t.port_cnt = 5,\t\t \n\t\t.num_tx_queues = 4,\n\t\t.ops = &ksz8_dev_ops,\n\t\t.ksz87xx_eee_link_erratum = true,\n\t\t.mib_names = ksz9477_mib_names,\n\t\t.mib_cnt = ARRAY_SIZE(ksz9477_mib_names),\n\t\t.reg_mib_cnt = MIB_COUNTER_NUM,\n\t\t.regs = ksz8795_regs,\n\t\t.masks = ksz8795_masks,\n\t\t.shifts = ksz8795_shifts,\n\t\t.xmii_ctrl0 = ksz8795_xmii_ctrl0,\n\t\t.xmii_ctrl1 = ksz8795_xmii_ctrl1,\n\t\t.supports_mii = {false, false, false, false, true},\n\t\t.supports_rmii = {false, false, false, false, true},\n\t\t.supports_rgmii = {false, false, false, false, true},\n\t\t.internal_phy = {true, true, true, true, false},\n\t},\n\n\t[KSZ8830] = {\n\t\t.chip_id = KSZ8830_CHIP_ID,\n\t\t.dev_name = \"KSZ8863/KSZ8873\",\n\t\t.num_vlans = 16,\n\t\t.num_alus = 0,\n\t\t.num_statics = 8,\n\t\t.cpu_ports = 0x4,\t \n\t\t.port_cnt = 3,\n\t\t.num_tx_queues = 4,\n\t\t.ops = &ksz8_dev_ops,\n\t\t.mib_names = ksz88xx_mib_names,\n\t\t.mib_cnt = ARRAY_SIZE(ksz88xx_mib_names),\n\t\t.reg_mib_cnt = MIB_COUNTER_NUM,\n\t\t.regs = ksz8863_regs,\n\t\t.masks = ksz8863_masks,\n\t\t.shifts = ksz8863_shifts,\n\t\t.supports_mii = {false, false, true},\n\t\t.supports_rmii = {false, false, true},\n\t\t.internal_phy = {true, true, false},\n\t\t.wr_table = &ksz8873_register_set,\n\t\t.rd_table = &ksz8873_register_set,\n\t},\n\n\t[KSZ9477] = {\n\t\t.chip_id = KSZ9477_CHIP_ID,\n\t\t.dev_name = \"KSZ9477\",\n\t\t.num_vlans = 4096,\n\t\t.num_alus = 4096,\n\t\t.num_statics = 16,\n\t\t.cpu_ports = 0x7F,\t \n\t\t.port_cnt = 7,\t\t \n\t\t.port_nirqs = 4,\n\t\t.num_tx_queues = 4,\n\t\t.tc_cbs_supported = true,\n\t\t.tc_ets_supported = true,\n\t\t.ops = &ksz9477_dev_ops,\n\t\t.mib_names = ksz9477_mib_names,\n\t\t.mib_cnt = ARRAY_SIZE(ksz9477_mib_names),\n\t\t.reg_mib_cnt = MIB_COUNTER_NUM,\n\t\t.regs = ksz9477_regs,\n\t\t.masks = ksz9477_masks,\n\t\t.shifts = ksz9477_shifts,\n\t\t.xmii_ctrl0 = ksz9477_xmii_ctrl0,\n\t\t.xmii_ctrl1 = ksz9477_xmii_ctrl1,\n\t\t.supports_mii\t= {false, false, false, false,\n\t\t\t\t   false, true, false},\n\t\t.supports_rmii\t= {false, false, false, false,\n\t\t\t\t   false, true, false},\n\t\t.supports_rgmii = {false, false, false, false,\n\t\t\t\t   false, true, false},\n\t\t.internal_phy\t= {true, true, true, true,\n\t\t\t\t   true, false, false},\n\t\t.gbit_capable\t= {true, true, true, true, true, true, true},\n\t\t.wr_table = &ksz9477_register_set,\n\t\t.rd_table = &ksz9477_register_set,\n\t},\n\n\t[KSZ9896] = {\n\t\t.chip_id = KSZ9896_CHIP_ID,\n\t\t.dev_name = \"KSZ9896\",\n\t\t.num_vlans = 4096,\n\t\t.num_alus = 4096,\n\t\t.num_statics = 16,\n\t\t.cpu_ports = 0x3F,\t \n\t\t.port_cnt = 6,\t\t \n\t\t.port_nirqs = 2,\n\t\t.num_tx_queues = 4,\n\t\t.ops = &ksz9477_dev_ops,\n\t\t.mib_names = ksz9477_mib_names,\n\t\t.mib_cnt = ARRAY_SIZE(ksz9477_mib_names),\n\t\t.reg_mib_cnt = MIB_COUNTER_NUM,\n\t\t.regs = ksz9477_regs,\n\t\t.masks = ksz9477_masks,\n\t\t.shifts = ksz9477_shifts,\n\t\t.xmii_ctrl0 = ksz9477_xmii_ctrl0,\n\t\t.xmii_ctrl1 = ksz9477_xmii_ctrl1,\n\t\t.supports_mii\t= {false, false, false, false,\n\t\t\t\t   false, true},\n\t\t.supports_rmii\t= {false, false, false, false,\n\t\t\t\t   false, true},\n\t\t.supports_rgmii = {false, false, false, false,\n\t\t\t\t   false, true},\n\t\t.internal_phy\t= {true, true, true, true,\n\t\t\t\t   true, false},\n\t\t.gbit_capable\t= {true, true, true, true, true, true},\n\t\t.wr_table = &ksz9896_register_set,\n\t\t.rd_table = &ksz9896_register_set,\n\t},\n\n\t[KSZ9897] = {\n\t\t.chip_id = KSZ9897_CHIP_ID,\n\t\t.dev_name = \"KSZ9897\",\n\t\t.num_vlans = 4096,\n\t\t.num_alus = 4096,\n\t\t.num_statics = 16,\n\t\t.cpu_ports = 0x7F,\t \n\t\t.port_cnt = 7,\t\t \n\t\t.port_nirqs = 2,\n\t\t.num_tx_queues = 4,\n\t\t.ops = &ksz9477_dev_ops,\n\t\t.mib_names = ksz9477_mib_names,\n\t\t.mib_cnt = ARRAY_SIZE(ksz9477_mib_names),\n\t\t.reg_mib_cnt = MIB_COUNTER_NUM,\n\t\t.regs = ksz9477_regs,\n\t\t.masks = ksz9477_masks,\n\t\t.shifts = ksz9477_shifts,\n\t\t.xmii_ctrl0 = ksz9477_xmii_ctrl0,\n\t\t.xmii_ctrl1 = ksz9477_xmii_ctrl1,\n\t\t.supports_mii\t= {false, false, false, false,\n\t\t\t\t   false, true, true},\n\t\t.supports_rmii\t= {false, false, false, false,\n\t\t\t\t   false, true, true},\n\t\t.supports_rgmii = {false, false, false, false,\n\t\t\t\t   false, true, true},\n\t\t.internal_phy\t= {true, true, true, true,\n\t\t\t\t   true, false, false},\n\t\t.gbit_capable\t= {true, true, true, true, true, true, true},\n\t},\n\n\t[KSZ9893] = {\n\t\t.chip_id = KSZ9893_CHIP_ID,\n\t\t.dev_name = \"KSZ9893\",\n\t\t.num_vlans = 4096,\n\t\t.num_alus = 4096,\n\t\t.num_statics = 16,\n\t\t.cpu_ports = 0x07,\t \n\t\t.port_cnt = 3,\t\t \n\t\t.port_nirqs = 2,\n\t\t.num_tx_queues = 4,\n\t\t.ops = &ksz9477_dev_ops,\n\t\t.mib_names = ksz9477_mib_names,\n\t\t.mib_cnt = ARRAY_SIZE(ksz9477_mib_names),\n\t\t.reg_mib_cnt = MIB_COUNTER_NUM,\n\t\t.regs = ksz9477_regs,\n\t\t.masks = ksz9477_masks,\n\t\t.shifts = ksz9477_shifts,\n\t\t.xmii_ctrl0 = ksz9477_xmii_ctrl0,\n\t\t.xmii_ctrl1 = ksz8795_xmii_ctrl1,  \n\t\t.supports_mii = {false, false, true},\n\t\t.supports_rmii = {false, false, true},\n\t\t.supports_rgmii = {false, false, true},\n\t\t.internal_phy = {true, true, false},\n\t\t.gbit_capable = {true, true, true},\n\t},\n\n\t[KSZ9563] = {\n\t\t.chip_id = KSZ9563_CHIP_ID,\n\t\t.dev_name = \"KSZ9563\",\n\t\t.num_vlans = 4096,\n\t\t.num_alus = 4096,\n\t\t.num_statics = 16,\n\t\t.cpu_ports = 0x07,\t \n\t\t.port_cnt = 3,\t\t \n\t\t.port_nirqs = 3,\n\t\t.num_tx_queues = 4,\n\t\t.tc_cbs_supported = true,\n\t\t.tc_ets_supported = true,\n\t\t.ops = &ksz9477_dev_ops,\n\t\t.mib_names = ksz9477_mib_names,\n\t\t.mib_cnt = ARRAY_SIZE(ksz9477_mib_names),\n\t\t.reg_mib_cnt = MIB_COUNTER_NUM,\n\t\t.regs = ksz9477_regs,\n\t\t.masks = ksz9477_masks,\n\t\t.shifts = ksz9477_shifts,\n\t\t.xmii_ctrl0 = ksz9477_xmii_ctrl0,\n\t\t.xmii_ctrl1 = ksz8795_xmii_ctrl1,  \n\t\t.supports_mii = {false, false, true},\n\t\t.supports_rmii = {false, false, true},\n\t\t.supports_rgmii = {false, false, true},\n\t\t.internal_phy = {true, true, false},\n\t\t.gbit_capable = {true, true, true},\n\t},\n\n\t[KSZ9567] = {\n\t\t.chip_id = KSZ9567_CHIP_ID,\n\t\t.dev_name = \"KSZ9567\",\n\t\t.num_vlans = 4096,\n\t\t.num_alus = 4096,\n\t\t.num_statics = 16,\n\t\t.cpu_ports = 0x7F,\t \n\t\t.port_cnt = 7,\t\t \n\t\t.port_nirqs = 3,\n\t\t.num_tx_queues = 4,\n\t\t.tc_cbs_supported = true,\n\t\t.tc_ets_supported = true,\n\t\t.ops = &ksz9477_dev_ops,\n\t\t.mib_names = ksz9477_mib_names,\n\t\t.mib_cnt = ARRAY_SIZE(ksz9477_mib_names),\n\t\t.reg_mib_cnt = MIB_COUNTER_NUM,\n\t\t.regs = ksz9477_regs,\n\t\t.masks = ksz9477_masks,\n\t\t.shifts = ksz9477_shifts,\n\t\t.xmii_ctrl0 = ksz9477_xmii_ctrl0,\n\t\t.xmii_ctrl1 = ksz9477_xmii_ctrl1,\n\t\t.supports_mii\t= {false, false, false, false,\n\t\t\t\t   false, true, true},\n\t\t.supports_rmii\t= {false, false, false, false,\n\t\t\t\t   false, true, true},\n\t\t.supports_rgmii = {false, false, false, false,\n\t\t\t\t   false, true, true},\n\t\t.internal_phy\t= {true, true, true, true,\n\t\t\t\t   true, false, false},\n\t\t.gbit_capable\t= {true, true, true, true, true, true, true},\n\t},\n\n\t[LAN9370] = {\n\t\t.chip_id = LAN9370_CHIP_ID,\n\t\t.dev_name = \"LAN9370\",\n\t\t.num_vlans = 4096,\n\t\t.num_alus = 1024,\n\t\t.num_statics = 256,\n\t\t.cpu_ports = 0x10,\t \n\t\t.port_cnt = 5,\t\t \n\t\t.port_nirqs = 6,\n\t\t.num_tx_queues = 8,\n\t\t.tc_cbs_supported = true,\n\t\t.tc_ets_supported = true,\n\t\t.ops = &lan937x_dev_ops,\n\t\t.mib_names = ksz9477_mib_names,\n\t\t.mib_cnt = ARRAY_SIZE(ksz9477_mib_names),\n\t\t.reg_mib_cnt = MIB_COUNTER_NUM,\n\t\t.regs = ksz9477_regs,\n\t\t.masks = lan937x_masks,\n\t\t.shifts = lan937x_shifts,\n\t\t.xmii_ctrl0 = ksz9477_xmii_ctrl0,\n\t\t.xmii_ctrl1 = ksz9477_xmii_ctrl1,\n\t\t.supports_mii = {false, false, false, false, true},\n\t\t.supports_rmii = {false, false, false, false, true},\n\t\t.supports_rgmii = {false, false, false, false, true},\n\t\t.internal_phy = {true, true, true, true, false},\n\t},\n\n\t[LAN9371] = {\n\t\t.chip_id = LAN9371_CHIP_ID,\n\t\t.dev_name = \"LAN9371\",\n\t\t.num_vlans = 4096,\n\t\t.num_alus = 1024,\n\t\t.num_statics = 256,\n\t\t.cpu_ports = 0x30,\t \n\t\t.port_cnt = 6,\t\t \n\t\t.port_nirqs = 6,\n\t\t.num_tx_queues = 8,\n\t\t.tc_cbs_supported = true,\n\t\t.tc_ets_supported = true,\n\t\t.ops = &lan937x_dev_ops,\n\t\t.mib_names = ksz9477_mib_names,\n\t\t.mib_cnt = ARRAY_SIZE(ksz9477_mib_names),\n\t\t.reg_mib_cnt = MIB_COUNTER_NUM,\n\t\t.regs = ksz9477_regs,\n\t\t.masks = lan937x_masks,\n\t\t.shifts = lan937x_shifts,\n\t\t.xmii_ctrl0 = ksz9477_xmii_ctrl0,\n\t\t.xmii_ctrl1 = ksz9477_xmii_ctrl1,\n\t\t.supports_mii = {false, false, false, false, true, true},\n\t\t.supports_rmii = {false, false, false, false, true, true},\n\t\t.supports_rgmii = {false, false, false, false, true, true},\n\t\t.internal_phy = {true, true, true, true, false, false},\n\t},\n\n\t[LAN9372] = {\n\t\t.chip_id = LAN9372_CHIP_ID,\n\t\t.dev_name = \"LAN9372\",\n\t\t.num_vlans = 4096,\n\t\t.num_alus = 1024,\n\t\t.num_statics = 256,\n\t\t.cpu_ports = 0x30,\t \n\t\t.port_cnt = 8,\t\t \n\t\t.port_nirqs = 6,\n\t\t.num_tx_queues = 8,\n\t\t.tc_cbs_supported = true,\n\t\t.tc_ets_supported = true,\n\t\t.ops = &lan937x_dev_ops,\n\t\t.mib_names = ksz9477_mib_names,\n\t\t.mib_cnt = ARRAY_SIZE(ksz9477_mib_names),\n\t\t.reg_mib_cnt = MIB_COUNTER_NUM,\n\t\t.regs = ksz9477_regs,\n\t\t.masks = lan937x_masks,\n\t\t.shifts = lan937x_shifts,\n\t\t.xmii_ctrl0 = ksz9477_xmii_ctrl0,\n\t\t.xmii_ctrl1 = ksz9477_xmii_ctrl1,\n\t\t.supports_mii\t= {false, false, false, false,\n\t\t\t\t   true, true, false, false},\n\t\t.supports_rmii\t= {false, false, false, false,\n\t\t\t\t   true, true, false, false},\n\t\t.supports_rgmii = {false, false, false, false,\n\t\t\t\t   true, true, false, false},\n\t\t.internal_phy\t= {true, true, true, true,\n\t\t\t\t   false, false, true, true},\n\t},\n\n\t[LAN9373] = {\n\t\t.chip_id = LAN9373_CHIP_ID,\n\t\t.dev_name = \"LAN9373\",\n\t\t.num_vlans = 4096,\n\t\t.num_alus = 1024,\n\t\t.num_statics = 256,\n\t\t.cpu_ports = 0x38,\t \n\t\t.port_cnt = 5,\t\t \n\t\t.port_nirqs = 6,\n\t\t.num_tx_queues = 8,\n\t\t.tc_cbs_supported = true,\n\t\t.tc_ets_supported = true,\n\t\t.ops = &lan937x_dev_ops,\n\t\t.mib_names = ksz9477_mib_names,\n\t\t.mib_cnt = ARRAY_SIZE(ksz9477_mib_names),\n\t\t.reg_mib_cnt = MIB_COUNTER_NUM,\n\t\t.regs = ksz9477_regs,\n\t\t.masks = lan937x_masks,\n\t\t.shifts = lan937x_shifts,\n\t\t.xmii_ctrl0 = ksz9477_xmii_ctrl0,\n\t\t.xmii_ctrl1 = ksz9477_xmii_ctrl1,\n\t\t.supports_mii\t= {false, false, false, false,\n\t\t\t\t   true, true, false, false},\n\t\t.supports_rmii\t= {false, false, false, false,\n\t\t\t\t   true, true, false, false},\n\t\t.supports_rgmii = {false, false, false, false,\n\t\t\t\t   true, true, false, false},\n\t\t.internal_phy\t= {true, true, true, false,\n\t\t\t\t   false, false, true, true},\n\t},\n\n\t[LAN9374] = {\n\t\t.chip_id = LAN9374_CHIP_ID,\n\t\t.dev_name = \"LAN9374\",\n\t\t.num_vlans = 4096,\n\t\t.num_alus = 1024,\n\t\t.num_statics = 256,\n\t\t.cpu_ports = 0x30,\t \n\t\t.port_cnt = 8,\t\t \n\t\t.port_nirqs = 6,\n\t\t.num_tx_queues = 8,\n\t\t.tc_cbs_supported = true,\n\t\t.tc_ets_supported = true,\n\t\t.ops = &lan937x_dev_ops,\n\t\t.mib_names = ksz9477_mib_names,\n\t\t.mib_cnt = ARRAY_SIZE(ksz9477_mib_names),\n\t\t.reg_mib_cnt = MIB_COUNTER_NUM,\n\t\t.regs = ksz9477_regs,\n\t\t.masks = lan937x_masks,\n\t\t.shifts = lan937x_shifts,\n\t\t.xmii_ctrl0 = ksz9477_xmii_ctrl0,\n\t\t.xmii_ctrl1 = ksz9477_xmii_ctrl1,\n\t\t.supports_mii\t= {false, false, false, false,\n\t\t\t\t   true, true, false, false},\n\t\t.supports_rmii\t= {false, false, false, false,\n\t\t\t\t   true, true, false, false},\n\t\t.supports_rgmii = {false, false, false, false,\n\t\t\t\t   true, true, false, false},\n\t\t.internal_phy\t= {true, true, true, true,\n\t\t\t\t   false, false, true, true},\n\t},\n};\nEXPORT_SYMBOL_GPL(ksz_switch_chips);\n\nstatic const struct ksz_chip_data *ksz_lookup_info(unsigned int prod_num)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ksz_switch_chips); i++) {\n\t\tconst struct ksz_chip_data *chip = &ksz_switch_chips[i];\n\n\t\tif (chip->chip_id == prod_num)\n\t\t\treturn chip;\n\t}\n\n\treturn NULL;\n}\n\nstatic int ksz_check_device_id(struct ksz_device *dev)\n{\n\tconst struct ksz_chip_data *dt_chip_data;\n\n\tdt_chip_data = of_device_get_match_data(dev->dev);\n\n\t \n\tif (dt_chip_data->chip_id != dev->chip_id) {\n\t\tdev_err(dev->dev,\n\t\t\t\"Device tree specifies chip %s but found %s, please fix it!\\n\",\n\t\t\tdt_chip_data->dev_name, dev->info->dev_name);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void ksz_phylink_get_caps(struct dsa_switch *ds, int port,\n\t\t\t\t struct phylink_config *config)\n{\n\tstruct ksz_device *dev = ds->priv;\n\n\tif (dev->info->supports_mii[port])\n\t\t__set_bit(PHY_INTERFACE_MODE_MII, config->supported_interfaces);\n\n\tif (dev->info->supports_rmii[port])\n\t\t__set_bit(PHY_INTERFACE_MODE_RMII,\n\t\t\t  config->supported_interfaces);\n\n\tif (dev->info->supports_rgmii[port])\n\t\tphy_interface_set_rgmii(config->supported_interfaces);\n\n\tif (dev->info->internal_phy[port]) {\n\t\t__set_bit(PHY_INTERFACE_MODE_INTERNAL,\n\t\t\t  config->supported_interfaces);\n\t\t \n\t\t__set_bit(PHY_INTERFACE_MODE_GMII,\n\t\t\t  config->supported_interfaces);\n\t}\n\n\tif (dev->dev_ops->get_caps)\n\t\tdev->dev_ops->get_caps(dev, port, config);\n}\n\nvoid ksz_r_mib_stats64(struct ksz_device *dev, int port)\n{\n\tstruct ethtool_pause_stats *pstats;\n\tstruct rtnl_link_stats64 *stats;\n\tstruct ksz_stats_raw *raw;\n\tstruct ksz_port_mib *mib;\n\n\tmib = &dev->ports[port].mib;\n\tstats = &mib->stats64;\n\tpstats = &mib->pause_stats;\n\traw = (struct ksz_stats_raw *)mib->counters;\n\n\tspin_lock(&mib->stats64_lock);\n\n\tstats->rx_packets = raw->rx_bcast + raw->rx_mcast + raw->rx_ucast +\n\t\traw->rx_pause;\n\tstats->tx_packets = raw->tx_bcast + raw->tx_mcast + raw->tx_ucast +\n\t\traw->tx_pause;\n\n\t \n\tstats->rx_bytes = raw->rx_total - stats->rx_packets * ETH_FCS_LEN;\n\tstats->tx_bytes = raw->tx_total - stats->tx_packets * ETH_FCS_LEN;\n\n\tstats->rx_length_errors = raw->rx_undersize + raw->rx_fragments +\n\t\traw->rx_oversize;\n\n\tstats->rx_crc_errors = raw->rx_crc_err;\n\tstats->rx_frame_errors = raw->rx_align_err;\n\tstats->rx_dropped = raw->rx_discards;\n\tstats->rx_errors = stats->rx_length_errors + stats->rx_crc_errors +\n\t\tstats->rx_frame_errors  + stats->rx_dropped;\n\n\tstats->tx_window_errors = raw->tx_late_col;\n\tstats->tx_fifo_errors = raw->tx_discards;\n\tstats->tx_aborted_errors = raw->tx_exc_col;\n\tstats->tx_errors = stats->tx_window_errors + stats->tx_fifo_errors +\n\t\tstats->tx_aborted_errors;\n\n\tstats->multicast = raw->rx_mcast;\n\tstats->collisions = raw->tx_total_col;\n\n\tpstats->tx_pause_frames = raw->tx_pause;\n\tpstats->rx_pause_frames = raw->rx_pause;\n\n\tspin_unlock(&mib->stats64_lock);\n}\n\nvoid ksz88xx_r_mib_stats64(struct ksz_device *dev, int port)\n{\n\tstruct ethtool_pause_stats *pstats;\n\tstruct rtnl_link_stats64 *stats;\n\tstruct ksz88xx_stats_raw *raw;\n\tstruct ksz_port_mib *mib;\n\n\tmib = &dev->ports[port].mib;\n\tstats = &mib->stats64;\n\tpstats = &mib->pause_stats;\n\traw = (struct ksz88xx_stats_raw *)mib->counters;\n\n\tspin_lock(&mib->stats64_lock);\n\n\tstats->rx_packets = raw->rx_bcast + raw->rx_mcast + raw->rx_ucast +\n\t\traw->rx_pause;\n\tstats->tx_packets = raw->tx_bcast + raw->tx_mcast + raw->tx_ucast +\n\t\traw->tx_pause;\n\n\t \n\tstats->rx_bytes = raw->rx + raw->rx_hi - stats->rx_packets * ETH_FCS_LEN;\n\tstats->tx_bytes = raw->tx + raw->tx_hi - stats->tx_packets * ETH_FCS_LEN;\n\n\tstats->rx_length_errors = raw->rx_undersize + raw->rx_fragments +\n\t\traw->rx_oversize;\n\n\tstats->rx_crc_errors = raw->rx_crc_err;\n\tstats->rx_frame_errors = raw->rx_align_err;\n\tstats->rx_dropped = raw->rx_discards;\n\tstats->rx_errors = stats->rx_length_errors + stats->rx_crc_errors +\n\t\tstats->rx_frame_errors  + stats->rx_dropped;\n\n\tstats->tx_window_errors = raw->tx_late_col;\n\tstats->tx_fifo_errors = raw->tx_discards;\n\tstats->tx_aborted_errors = raw->tx_exc_col;\n\tstats->tx_errors = stats->tx_window_errors + stats->tx_fifo_errors +\n\t\tstats->tx_aborted_errors;\n\n\tstats->multicast = raw->rx_mcast;\n\tstats->collisions = raw->tx_total_col;\n\n\tpstats->tx_pause_frames = raw->tx_pause;\n\tpstats->rx_pause_frames = raw->rx_pause;\n\n\tspin_unlock(&mib->stats64_lock);\n}\n\nstatic void ksz_get_stats64(struct dsa_switch *ds, int port,\n\t\t\t    struct rtnl_link_stats64 *s)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tstruct ksz_port_mib *mib;\n\n\tmib = &dev->ports[port].mib;\n\n\tspin_lock(&mib->stats64_lock);\n\tmemcpy(s, &mib->stats64, sizeof(*s));\n\tspin_unlock(&mib->stats64_lock);\n}\n\nstatic void ksz_get_pause_stats(struct dsa_switch *ds, int port,\n\t\t\t\tstruct ethtool_pause_stats *pause_stats)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tstruct ksz_port_mib *mib;\n\n\tmib = &dev->ports[port].mib;\n\n\tspin_lock(&mib->stats64_lock);\n\tmemcpy(pause_stats, &mib->pause_stats, sizeof(*pause_stats));\n\tspin_unlock(&mib->stats64_lock);\n}\n\nstatic void ksz_get_strings(struct dsa_switch *ds, int port,\n\t\t\t    u32 stringset, uint8_t *buf)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tint i;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tfor (i = 0; i < dev->info->mib_cnt; i++) {\n\t\tmemcpy(buf + i * ETH_GSTRING_LEN,\n\t\t       dev->info->mib_names[i].string, ETH_GSTRING_LEN);\n\t}\n}\n\nstatic void ksz_update_port_member(struct ksz_device *dev, int port)\n{\n\tstruct ksz_port *p = &dev->ports[port];\n\tstruct dsa_switch *ds = dev->ds;\n\tu8 port_member = 0, cpu_port;\n\tconst struct dsa_port *dp;\n\tint i, j;\n\n\tif (!dsa_is_user_port(ds, port))\n\t\treturn;\n\n\tdp = dsa_to_port(ds, port);\n\tcpu_port = BIT(dsa_upstream_port(ds, port));\n\n\tfor (i = 0; i < ds->num_ports; i++) {\n\t\tconst struct dsa_port *other_dp = dsa_to_port(ds, i);\n\t\tstruct ksz_port *other_p = &dev->ports[i];\n\t\tu8 val = 0;\n\n\t\tif (!dsa_is_user_port(ds, i))\n\t\t\tcontinue;\n\t\tif (port == i)\n\t\t\tcontinue;\n\t\tif (!dsa_port_bridge_same(dp, other_dp))\n\t\t\tcontinue;\n\t\tif (other_p->stp_state != BR_STATE_FORWARDING)\n\t\t\tcontinue;\n\n\t\tif (p->stp_state == BR_STATE_FORWARDING) {\n\t\t\tval |= BIT(port);\n\t\t\tport_member |= BIT(i);\n\t\t}\n\n\t\t \n\t\tfor (j = 0; j < ds->num_ports; j++) {\n\t\t\tconst struct dsa_port *third_dp;\n\t\t\tstruct ksz_port *third_p;\n\n\t\t\tif (j == i)\n\t\t\t\tcontinue;\n\t\t\tif (j == port)\n\t\t\t\tcontinue;\n\t\t\tif (!dsa_is_user_port(ds, j))\n\t\t\t\tcontinue;\n\t\t\tthird_p = &dev->ports[j];\n\t\t\tif (third_p->stp_state != BR_STATE_FORWARDING)\n\t\t\t\tcontinue;\n\t\t\tthird_dp = dsa_to_port(ds, j);\n\t\t\tif (dsa_port_bridge_same(other_dp, third_dp))\n\t\t\t\tval |= BIT(j);\n\t\t}\n\n\t\tdev->dev_ops->cfg_port_member(dev, i, val | cpu_port);\n\t}\n\n\tdev->dev_ops->cfg_port_member(dev, port, port_member | cpu_port);\n}\n\nstatic int ksz_sw_mdio_read(struct mii_bus *bus, int addr, int regnum)\n{\n\tstruct ksz_device *dev = bus->priv;\n\tu16 val;\n\tint ret;\n\n\tret = dev->dev_ops->r_phy(dev, addr, regnum, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn val;\n}\n\nstatic int ksz_sw_mdio_write(struct mii_bus *bus, int addr, int regnum,\n\t\t\t     u16 val)\n{\n\tstruct ksz_device *dev = bus->priv;\n\n\treturn dev->dev_ops->w_phy(dev, addr, regnum, val);\n}\n\nstatic int ksz_irq_phy_setup(struct ksz_device *dev)\n{\n\tstruct dsa_switch *ds = dev->ds;\n\tint phy;\n\tint irq;\n\tint ret;\n\n\tfor (phy = 0; phy < KSZ_MAX_NUM_PORTS; phy++) {\n\t\tif (BIT(phy) & ds->phys_mii_mask) {\n\t\t\tirq = irq_find_mapping(dev->ports[phy].pirq.domain,\n\t\t\t\t\t       PORT_SRC_PHY_INT);\n\t\t\tif (irq < 0) {\n\t\t\t\tret = irq;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tds->slave_mii_bus->irq[phy] = irq;\n\t\t}\n\t}\n\treturn 0;\nout:\n\twhile (phy--)\n\t\tif (BIT(phy) & ds->phys_mii_mask)\n\t\t\tirq_dispose_mapping(ds->slave_mii_bus->irq[phy]);\n\n\treturn ret;\n}\n\nstatic void ksz_irq_phy_free(struct ksz_device *dev)\n{\n\tstruct dsa_switch *ds = dev->ds;\n\tint phy;\n\n\tfor (phy = 0; phy < KSZ_MAX_NUM_PORTS; phy++)\n\t\tif (BIT(phy) & ds->phys_mii_mask)\n\t\t\tirq_dispose_mapping(ds->slave_mii_bus->irq[phy]);\n}\n\nstatic int ksz_mdio_register(struct ksz_device *dev)\n{\n\tstruct dsa_switch *ds = dev->ds;\n\tstruct device_node *mdio_np;\n\tstruct mii_bus *bus;\n\tint ret;\n\n\tmdio_np = of_get_child_by_name(dev->dev->of_node, \"mdio\");\n\tif (!mdio_np)\n\t\treturn 0;\n\n\tbus = devm_mdiobus_alloc(ds->dev);\n\tif (!bus) {\n\t\tof_node_put(mdio_np);\n\t\treturn -ENOMEM;\n\t}\n\n\tbus->priv = dev;\n\tbus->read = ksz_sw_mdio_read;\n\tbus->write = ksz_sw_mdio_write;\n\tbus->name = \"ksz slave smi\";\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"SMI-%d\", ds->index);\n\tbus->parent = ds->dev;\n\tbus->phy_mask = ~ds->phys_mii_mask;\n\n\tds->slave_mii_bus = bus;\n\n\tif (dev->irq > 0) {\n\t\tret = ksz_irq_phy_setup(dev);\n\t\tif (ret) {\n\t\t\tof_node_put(mdio_np);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = devm_of_mdiobus_register(ds->dev, bus, mdio_np);\n\tif (ret) {\n\t\tdev_err(ds->dev, \"unable to register MDIO bus %s\\n\",\n\t\t\tbus->id);\n\t\tif (dev->irq > 0)\n\t\t\tksz_irq_phy_free(dev);\n\t}\n\n\tof_node_put(mdio_np);\n\n\treturn ret;\n}\n\nstatic void ksz_irq_mask(struct irq_data *d)\n{\n\tstruct ksz_irq *kirq = irq_data_get_irq_chip_data(d);\n\n\tkirq->masked |= BIT(d->hwirq);\n}\n\nstatic void ksz_irq_unmask(struct irq_data *d)\n{\n\tstruct ksz_irq *kirq = irq_data_get_irq_chip_data(d);\n\n\tkirq->masked &= ~BIT(d->hwirq);\n}\n\nstatic void ksz_irq_bus_lock(struct irq_data *d)\n{\n\tstruct ksz_irq *kirq  = irq_data_get_irq_chip_data(d);\n\n\tmutex_lock(&kirq->dev->lock_irq);\n}\n\nstatic void ksz_irq_bus_sync_unlock(struct irq_data *d)\n{\n\tstruct ksz_irq *kirq  = irq_data_get_irq_chip_data(d);\n\tstruct ksz_device *dev = kirq->dev;\n\tint ret;\n\n\tret = ksz_write32(dev, kirq->reg_mask, kirq->masked);\n\tif (ret)\n\t\tdev_err(dev->dev, \"failed to change IRQ mask\\n\");\n\n\tmutex_unlock(&dev->lock_irq);\n}\n\nstatic const struct irq_chip ksz_irq_chip = {\n\t.name\t\t\t= \"ksz-irq\",\n\t.irq_mask\t\t= ksz_irq_mask,\n\t.irq_unmask\t\t= ksz_irq_unmask,\n\t.irq_bus_lock\t\t= ksz_irq_bus_lock,\n\t.irq_bus_sync_unlock\t= ksz_irq_bus_sync_unlock,\n};\n\nstatic int ksz_irq_domain_map(struct irq_domain *d,\n\t\t\t      unsigned int irq, irq_hw_number_t hwirq)\n{\n\tirq_set_chip_data(irq, d->host_data);\n\tirq_set_chip_and_handler(irq, &ksz_irq_chip, handle_level_irq);\n\tirq_set_noprobe(irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops ksz_irq_domain_ops = {\n\t.map\t= ksz_irq_domain_map,\n\t.xlate\t= irq_domain_xlate_twocell,\n};\n\nstatic void ksz_irq_free(struct ksz_irq *kirq)\n{\n\tint irq, virq;\n\n\tfree_irq(kirq->irq_num, kirq);\n\n\tfor (irq = 0; irq < kirq->nirqs; irq++) {\n\t\tvirq = irq_find_mapping(kirq->domain, irq);\n\t\tirq_dispose_mapping(virq);\n\t}\n\n\tirq_domain_remove(kirq->domain);\n}\n\nstatic irqreturn_t ksz_irq_thread_fn(int irq, void *dev_id)\n{\n\tstruct ksz_irq *kirq = dev_id;\n\tunsigned int nhandled = 0;\n\tstruct ksz_device *dev;\n\tunsigned int sub_irq;\n\tu8 data;\n\tint ret;\n\tu8 n;\n\n\tdev = kirq->dev;\n\n\t \n\tret = ksz_read8(dev, kirq->reg_status, &data);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (n = 0; n < kirq->nirqs; ++n) {\n\t\tif (data & BIT(n)) {\n\t\t\tsub_irq = irq_find_mapping(kirq->domain, n);\n\t\t\thandle_nested_irq(sub_irq);\n\t\t\t++nhandled;\n\t\t}\n\t}\nout:\n\treturn (nhandled > 0 ? IRQ_HANDLED : IRQ_NONE);\n}\n\nstatic int ksz_irq_common_setup(struct ksz_device *dev, struct ksz_irq *kirq)\n{\n\tint ret, n;\n\n\tkirq->dev = dev;\n\tkirq->masked = ~0;\n\n\tkirq->domain = irq_domain_add_simple(dev->dev->of_node, kirq->nirqs, 0,\n\t\t\t\t\t     &ksz_irq_domain_ops, kirq);\n\tif (!kirq->domain)\n\t\treturn -ENOMEM;\n\n\tfor (n = 0; n < kirq->nirqs; n++)\n\t\tirq_create_mapping(kirq->domain, n);\n\n\tret = request_threaded_irq(kirq->irq_num, NULL, ksz_irq_thread_fn,\n\t\t\t\t   IRQF_ONESHOT, kirq->name, kirq);\n\tif (ret)\n\t\tgoto out;\n\n\treturn 0;\n\nout:\n\tksz_irq_free(kirq);\n\n\treturn ret;\n}\n\nstatic int ksz_girq_setup(struct ksz_device *dev)\n{\n\tstruct ksz_irq *girq = &dev->girq;\n\n\tgirq->nirqs = dev->info->port_cnt;\n\tgirq->reg_mask = REG_SW_PORT_INT_MASK__1;\n\tgirq->reg_status = REG_SW_PORT_INT_STATUS__1;\n\tsnprintf(girq->name, sizeof(girq->name), \"global_port_irq\");\n\n\tgirq->irq_num = dev->irq;\n\n\treturn ksz_irq_common_setup(dev, girq);\n}\n\nstatic int ksz_pirq_setup(struct ksz_device *dev, u8 p)\n{\n\tstruct ksz_irq *pirq = &dev->ports[p].pirq;\n\n\tpirq->nirqs = dev->info->port_nirqs;\n\tpirq->reg_mask = dev->dev_ops->get_port_addr(p, REG_PORT_INT_MASK);\n\tpirq->reg_status = dev->dev_ops->get_port_addr(p, REG_PORT_INT_STATUS);\n\tsnprintf(pirq->name, sizeof(pirq->name), \"port_irq-%d\", p);\n\n\tpirq->irq_num = irq_find_mapping(dev->girq.domain, p);\n\tif (pirq->irq_num < 0)\n\t\treturn pirq->irq_num;\n\n\treturn ksz_irq_common_setup(dev, pirq);\n}\n\nstatic int ksz_setup(struct dsa_switch *ds)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tstruct dsa_port *dp;\n\tstruct ksz_port *p;\n\tconst u16 *regs;\n\tint ret;\n\n\tregs = dev->info->regs;\n\n\tdev->vlan_cache = devm_kcalloc(dev->dev, sizeof(struct vlan_table),\n\t\t\t\t       dev->info->num_vlans, GFP_KERNEL);\n\tif (!dev->vlan_cache)\n\t\treturn -ENOMEM;\n\n\tret = dev->dev_ops->reset(dev);\n\tif (ret) {\n\t\tdev_err(ds->dev, \"failed to reset switch\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tregmap_update_bits(ksz_regmap_16(dev), regs[S_BROADCAST_CTRL],\n\t\t\t   BROADCAST_STORM_RATE,\n\t\t\t   (BROADCAST_STORM_VALUE *\n\t\t\t   BROADCAST_STORM_PROT_RATE) / 100);\n\n\tdev->dev_ops->config_cpu_port(ds);\n\n\tdev->dev_ops->enable_stp_addr(dev);\n\n\tds->num_tx_queues = dev->info->num_tx_queues;\n\n\tregmap_update_bits(ksz_regmap_8(dev), regs[S_MULTICAST_CTRL],\n\t\t\t   MULTICAST_STORM_DISABLE, MULTICAST_STORM_DISABLE);\n\n\tksz_init_mib_timer(dev);\n\n\tds->configure_vlan_while_not_filtering = false;\n\n\tif (dev->dev_ops->setup) {\n\t\tret = dev->dev_ops->setup(ds);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tp = &dev->ports[dev->cpu_port];\n\tp->learning = true;\n\n\tif (dev->irq > 0) {\n\t\tret = ksz_girq_setup(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdsa_switch_for_each_user_port(dp, dev->ds) {\n\t\t\tret = ksz_pirq_setup(dev, dp->index);\n\t\t\tif (ret)\n\t\t\t\tgoto out_girq;\n\n\t\t\tret = ksz_ptp_irq_setup(ds, dp->index);\n\t\t\tif (ret)\n\t\t\t\tgoto out_pirq;\n\t\t}\n\t}\n\n\tret = ksz_ptp_clock_register(ds);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"Failed to register PTP clock: %d\\n\", ret);\n\t\tgoto out_ptpirq;\n\t}\n\n\tret = ksz_mdio_register(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev->dev, \"failed to register the mdio\");\n\t\tgoto out_ptp_clock_unregister;\n\t}\n\n\t \n\tregmap_update_bits(ksz_regmap_8(dev), regs[S_START_CTRL],\n\t\t\t   SW_START, SW_START);\n\n\treturn 0;\n\nout_ptp_clock_unregister:\n\tksz_ptp_clock_unregister(ds);\nout_ptpirq:\n\tif (dev->irq > 0)\n\t\tdsa_switch_for_each_user_port(dp, dev->ds)\n\t\t\tksz_ptp_irq_free(ds, dp->index);\nout_pirq:\n\tif (dev->irq > 0)\n\t\tdsa_switch_for_each_user_port(dp, dev->ds)\n\t\t\tksz_irq_free(&dev->ports[dp->index].pirq);\nout_girq:\n\tif (dev->irq > 0)\n\t\tksz_irq_free(&dev->girq);\n\n\treturn ret;\n}\n\nstatic void ksz_teardown(struct dsa_switch *ds)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tstruct dsa_port *dp;\n\n\tksz_ptp_clock_unregister(ds);\n\n\tif (dev->irq > 0) {\n\t\tdsa_switch_for_each_user_port(dp, dev->ds) {\n\t\t\tksz_ptp_irq_free(ds, dp->index);\n\n\t\t\tksz_irq_free(&dev->ports[dp->index].pirq);\n\t\t}\n\n\t\tksz_irq_free(&dev->girq);\n\t}\n\n\tif (dev->dev_ops->teardown)\n\t\tdev->dev_ops->teardown(ds);\n}\n\nstatic void port_r_cnt(struct ksz_device *dev, int port)\n{\n\tstruct ksz_port_mib *mib = &dev->ports[port].mib;\n\tu64 *dropped;\n\n\t \n\twhile (mib->cnt_ptr < dev->info->reg_mib_cnt) {\n\t\tdev->dev_ops->r_mib_cnt(dev, port, mib->cnt_ptr,\n\t\t\t\t\t&mib->counters[mib->cnt_ptr]);\n\t\t++mib->cnt_ptr;\n\t}\n\n\t \n\tdropped = &mib->counters[dev->info->mib_cnt];\n\n\t \n\twhile (mib->cnt_ptr < dev->info->mib_cnt) {\n\t\tdev->dev_ops->r_mib_pkt(dev, port, mib->cnt_ptr,\n\t\t\t\t\tdropped, &mib->counters[mib->cnt_ptr]);\n\t\t++mib->cnt_ptr;\n\t}\n\tmib->cnt_ptr = 0;\n}\n\nstatic void ksz_mib_read_work(struct work_struct *work)\n{\n\tstruct ksz_device *dev = container_of(work, struct ksz_device,\n\t\t\t\t\t      mib_read.work);\n\tstruct ksz_port_mib *mib;\n\tstruct ksz_port *p;\n\tint i;\n\n\tfor (i = 0; i < dev->info->port_cnt; i++) {\n\t\tif (dsa_is_unused_port(dev->ds, i))\n\t\t\tcontinue;\n\n\t\tp = &dev->ports[i];\n\t\tmib = &p->mib;\n\t\tmutex_lock(&mib->cnt_mutex);\n\n\t\t \n\t\tif (!p->read) {\n\t\t\tconst struct dsa_port *dp = dsa_to_port(dev->ds, i);\n\n\t\t\tif (!netif_carrier_ok(dp->slave))\n\t\t\t\tmib->cnt_ptr = dev->info->reg_mib_cnt;\n\t\t}\n\t\tport_r_cnt(dev, i);\n\t\tp->read = false;\n\n\t\tif (dev->dev_ops->r_mib_stat64)\n\t\t\tdev->dev_ops->r_mib_stat64(dev, i);\n\n\t\tmutex_unlock(&mib->cnt_mutex);\n\t}\n\n\tschedule_delayed_work(&dev->mib_read, dev->mib_read_interval);\n}\n\nvoid ksz_init_mib_timer(struct ksz_device *dev)\n{\n\tint i;\n\n\tINIT_DELAYED_WORK(&dev->mib_read, ksz_mib_read_work);\n\n\tfor (i = 0; i < dev->info->port_cnt; i++) {\n\t\tstruct ksz_port_mib *mib = &dev->ports[i].mib;\n\n\t\tdev->dev_ops->port_init_cnt(dev, i);\n\n\t\tmib->cnt_ptr = 0;\n\t\tmemset(mib->counters, 0, dev->info->mib_cnt * sizeof(u64));\n\t}\n}\n\nstatic int ksz_phy_read16(struct dsa_switch *ds, int addr, int reg)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tu16 val = 0xffff;\n\tint ret;\n\n\tret = dev->dev_ops->r_phy(dev, addr, reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn val;\n}\n\nstatic int ksz_phy_write16(struct dsa_switch *ds, int addr, int reg, u16 val)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tint ret;\n\n\tret = dev->dev_ops->w_phy(dev, addr, reg, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic u32 ksz_get_phy_flags(struct dsa_switch *ds, int port)\n{\n\tstruct ksz_device *dev = ds->priv;\n\n\tswitch (dev->chip_id) {\n\tcase KSZ8830_CHIP_ID:\n\t\t \n\t\tif (!port)\n\t\t\treturn MICREL_KSZ8_P1_ERRATA;\n\t\tbreak;\n\tcase KSZ9477_CHIP_ID:\n\t\t \n\t\treturn MICREL_NO_EEE;\n\t}\n\n\treturn 0;\n}\n\nstatic void ksz_mac_link_down(struct dsa_switch *ds, int port,\n\t\t\t      unsigned int mode, phy_interface_t interface)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tstruct ksz_port *p = &dev->ports[port];\n\n\t \n\tp->read = true;\n\t \n\tif (dev->mib_read_interval)\n\t\tschedule_delayed_work(&dev->mib_read, 0);\n}\n\nstatic int ksz_sset_count(struct dsa_switch *ds, int port, int sset)\n{\n\tstruct ksz_device *dev = ds->priv;\n\n\tif (sset != ETH_SS_STATS)\n\t\treturn 0;\n\n\treturn dev->info->mib_cnt;\n}\n\nstatic void ksz_get_ethtool_stats(struct dsa_switch *ds, int port,\n\t\t\t\t  uint64_t *buf)\n{\n\tconst struct dsa_port *dp = dsa_to_port(ds, port);\n\tstruct ksz_device *dev = ds->priv;\n\tstruct ksz_port_mib *mib;\n\n\tmib = &dev->ports[port].mib;\n\tmutex_lock(&mib->cnt_mutex);\n\n\t \n\tif (!netif_carrier_ok(dp->slave))\n\t\tmib->cnt_ptr = dev->info->reg_mib_cnt;\n\tport_r_cnt(dev, port);\n\tmemcpy(buf, mib->counters, dev->info->mib_cnt * sizeof(u64));\n\tmutex_unlock(&mib->cnt_mutex);\n}\n\nstatic int ksz_port_bridge_join(struct dsa_switch *ds, int port,\n\t\t\t\tstruct dsa_bridge bridge,\n\t\t\t\tbool *tx_fwd_offload,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\t \n\n\treturn 0;\n}\n\nstatic void ksz_port_bridge_leave(struct dsa_switch *ds, int port,\n\t\t\t\t  struct dsa_bridge bridge)\n{\n\t \n}\n\nstatic void ksz_port_fast_age(struct dsa_switch *ds, int port)\n{\n\tstruct ksz_device *dev = ds->priv;\n\n\tdev->dev_ops->flush_dyn_mac_table(dev, port);\n}\n\nstatic int ksz_set_ageing_time(struct dsa_switch *ds, unsigned int msecs)\n{\n\tstruct ksz_device *dev = ds->priv;\n\n\tif (!dev->dev_ops->set_ageing_time)\n\t\treturn -EOPNOTSUPP;\n\n\treturn dev->dev_ops->set_ageing_time(dev, msecs);\n}\n\nstatic int ksz_port_fdb_add(struct dsa_switch *ds, int port,\n\t\t\t    const unsigned char *addr, u16 vid,\n\t\t\t    struct dsa_db db)\n{\n\tstruct ksz_device *dev = ds->priv;\n\n\tif (!dev->dev_ops->fdb_add)\n\t\treturn -EOPNOTSUPP;\n\n\treturn dev->dev_ops->fdb_add(dev, port, addr, vid, db);\n}\n\nstatic int ksz_port_fdb_del(struct dsa_switch *ds, int port,\n\t\t\t    const unsigned char *addr,\n\t\t\t    u16 vid, struct dsa_db db)\n{\n\tstruct ksz_device *dev = ds->priv;\n\n\tif (!dev->dev_ops->fdb_del)\n\t\treturn -EOPNOTSUPP;\n\n\treturn dev->dev_ops->fdb_del(dev, port, addr, vid, db);\n}\n\nstatic int ksz_port_fdb_dump(struct dsa_switch *ds, int port,\n\t\t\t     dsa_fdb_dump_cb_t *cb, void *data)\n{\n\tstruct ksz_device *dev = ds->priv;\n\n\tif (!dev->dev_ops->fdb_dump)\n\t\treturn -EOPNOTSUPP;\n\n\treturn dev->dev_ops->fdb_dump(dev, port, cb, data);\n}\n\nstatic int ksz_port_mdb_add(struct dsa_switch *ds, int port,\n\t\t\t    const struct switchdev_obj_port_mdb *mdb,\n\t\t\t    struct dsa_db db)\n{\n\tstruct ksz_device *dev = ds->priv;\n\n\tif (!dev->dev_ops->mdb_add)\n\t\treturn -EOPNOTSUPP;\n\n\treturn dev->dev_ops->mdb_add(dev, port, mdb, db);\n}\n\nstatic int ksz_port_mdb_del(struct dsa_switch *ds, int port,\n\t\t\t    const struct switchdev_obj_port_mdb *mdb,\n\t\t\t    struct dsa_db db)\n{\n\tstruct ksz_device *dev = ds->priv;\n\n\tif (!dev->dev_ops->mdb_del)\n\t\treturn -EOPNOTSUPP;\n\n\treturn dev->dev_ops->mdb_del(dev, port, mdb, db);\n}\n\nstatic int ksz_enable_port(struct dsa_switch *ds, int port,\n\t\t\t   struct phy_device *phy)\n{\n\tstruct ksz_device *dev = ds->priv;\n\n\tif (!dsa_is_user_port(ds, port))\n\t\treturn 0;\n\n\t \n\tdev->dev_ops->port_setup(dev, port, false);\n\n\t \n\n\treturn 0;\n}\n\nvoid ksz_port_stp_state_set(struct dsa_switch *ds, int port, u8 state)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tstruct ksz_port *p;\n\tconst u16 *regs;\n\tu8 data;\n\n\tregs = dev->info->regs;\n\n\tksz_pread8(dev, port, regs[P_STP_CTRL], &data);\n\tdata &= ~(PORT_TX_ENABLE | PORT_RX_ENABLE | PORT_LEARN_DISABLE);\n\n\tp = &dev->ports[port];\n\n\tswitch (state) {\n\tcase BR_STATE_DISABLED:\n\t\tdata |= PORT_LEARN_DISABLE;\n\t\tbreak;\n\tcase BR_STATE_LISTENING:\n\t\tdata |= (PORT_RX_ENABLE | PORT_LEARN_DISABLE);\n\t\tbreak;\n\tcase BR_STATE_LEARNING:\n\t\tdata |= PORT_RX_ENABLE;\n\t\tif (!p->learning)\n\t\t\tdata |= PORT_LEARN_DISABLE;\n\t\tbreak;\n\tcase BR_STATE_FORWARDING:\n\t\tdata |= (PORT_TX_ENABLE | PORT_RX_ENABLE);\n\t\tif (!p->learning)\n\t\t\tdata |= PORT_LEARN_DISABLE;\n\t\tbreak;\n\tcase BR_STATE_BLOCKING:\n\t\tdata |= PORT_LEARN_DISABLE;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(ds->dev, \"invalid STP state: %d\\n\", state);\n\t\treturn;\n\t}\n\n\tksz_pwrite8(dev, port, regs[P_STP_CTRL], data);\n\n\tp->stp_state = state;\n\n\tksz_update_port_member(dev, port);\n}\n\nstatic int ksz_port_pre_bridge_flags(struct dsa_switch *ds, int port,\n\t\t\t\t     struct switchdev_brport_flags flags,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tif (flags.mask & ~BR_LEARNING)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ksz_port_bridge_flags(struct dsa_switch *ds, int port,\n\t\t\t\t struct switchdev_brport_flags flags,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tstruct ksz_port *p = &dev->ports[port];\n\n\tif (flags.mask & BR_LEARNING) {\n\t\tp->learning = !!(flags.val & BR_LEARNING);\n\n\t\t \n\t\tksz_port_stp_state_set(ds, port, p->stp_state);\n\t}\n\n\treturn 0;\n}\n\nstatic enum dsa_tag_protocol ksz_get_tag_protocol(struct dsa_switch *ds,\n\t\t\t\t\t\t  int port,\n\t\t\t\t\t\t  enum dsa_tag_protocol mp)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tenum dsa_tag_protocol proto = DSA_TAG_PROTO_NONE;\n\n\tif (dev->chip_id == KSZ8795_CHIP_ID ||\n\t    dev->chip_id == KSZ8794_CHIP_ID ||\n\t    dev->chip_id == KSZ8765_CHIP_ID)\n\t\tproto = DSA_TAG_PROTO_KSZ8795;\n\n\tif (dev->chip_id == KSZ8830_CHIP_ID ||\n\t    dev->chip_id == KSZ8563_CHIP_ID ||\n\t    dev->chip_id == KSZ9893_CHIP_ID ||\n\t    dev->chip_id == KSZ9563_CHIP_ID)\n\t\tproto = DSA_TAG_PROTO_KSZ9893;\n\n\tif (dev->chip_id == KSZ9477_CHIP_ID ||\n\t    dev->chip_id == KSZ9896_CHIP_ID ||\n\t    dev->chip_id == KSZ9897_CHIP_ID ||\n\t    dev->chip_id == KSZ9567_CHIP_ID)\n\t\tproto = DSA_TAG_PROTO_KSZ9477;\n\n\tif (is_lan937x(dev))\n\t\tproto = DSA_TAG_PROTO_LAN937X_VALUE;\n\n\treturn proto;\n}\n\nstatic int ksz_connect_tag_protocol(struct dsa_switch *ds,\n\t\t\t\t    enum dsa_tag_protocol proto)\n{\n\tstruct ksz_tagger_data *tagger_data;\n\n\tswitch (proto) {\n\tcase DSA_TAG_PROTO_KSZ8795:\n\t\treturn 0;\n\tcase DSA_TAG_PROTO_KSZ9893:\n\tcase DSA_TAG_PROTO_KSZ9477:\n\tcase DSA_TAG_PROTO_LAN937X:\n\t\ttagger_data = ksz_tagger_data(ds);\n\t\ttagger_data->xmit_work_fn = ksz_port_deferred_xmit;\n\t\treturn 0;\n\tdefault:\n\t\treturn -EPROTONOSUPPORT;\n\t}\n}\n\nstatic int ksz_port_vlan_filtering(struct dsa_switch *ds, int port,\n\t\t\t\t   bool flag, struct netlink_ext_ack *extack)\n{\n\tstruct ksz_device *dev = ds->priv;\n\n\tif (!dev->dev_ops->vlan_filtering)\n\t\treturn -EOPNOTSUPP;\n\n\treturn dev->dev_ops->vlan_filtering(dev, port, flag, extack);\n}\n\nstatic int ksz_port_vlan_add(struct dsa_switch *ds, int port,\n\t\t\t     const struct switchdev_obj_port_vlan *vlan,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct ksz_device *dev = ds->priv;\n\n\tif (!dev->dev_ops->vlan_add)\n\t\treturn -EOPNOTSUPP;\n\n\treturn dev->dev_ops->vlan_add(dev, port, vlan, extack);\n}\n\nstatic int ksz_port_vlan_del(struct dsa_switch *ds, int port,\n\t\t\t     const struct switchdev_obj_port_vlan *vlan)\n{\n\tstruct ksz_device *dev = ds->priv;\n\n\tif (!dev->dev_ops->vlan_del)\n\t\treturn -EOPNOTSUPP;\n\n\treturn dev->dev_ops->vlan_del(dev, port, vlan);\n}\n\nstatic int ksz_port_mirror_add(struct dsa_switch *ds, int port,\n\t\t\t       struct dsa_mall_mirror_tc_entry *mirror,\n\t\t\t       bool ingress, struct netlink_ext_ack *extack)\n{\n\tstruct ksz_device *dev = ds->priv;\n\n\tif (!dev->dev_ops->mirror_add)\n\t\treturn -EOPNOTSUPP;\n\n\treturn dev->dev_ops->mirror_add(dev, port, mirror, ingress, extack);\n}\n\nstatic void ksz_port_mirror_del(struct dsa_switch *ds, int port,\n\t\t\t\tstruct dsa_mall_mirror_tc_entry *mirror)\n{\n\tstruct ksz_device *dev = ds->priv;\n\n\tif (dev->dev_ops->mirror_del)\n\t\tdev->dev_ops->mirror_del(dev, port, mirror);\n}\n\nstatic int ksz_change_mtu(struct dsa_switch *ds, int port, int mtu)\n{\n\tstruct ksz_device *dev = ds->priv;\n\n\tif (!dev->dev_ops->change_mtu)\n\t\treturn -EOPNOTSUPP;\n\n\treturn dev->dev_ops->change_mtu(dev, port, mtu);\n}\n\nstatic int ksz_max_mtu(struct dsa_switch *ds, int port)\n{\n\tstruct ksz_device *dev = ds->priv;\n\n\tswitch (dev->chip_id) {\n\tcase KSZ8795_CHIP_ID:\n\tcase KSZ8794_CHIP_ID:\n\tcase KSZ8765_CHIP_ID:\n\t\treturn KSZ8795_HUGE_PACKET_SIZE - VLAN_ETH_HLEN - ETH_FCS_LEN;\n\tcase KSZ8830_CHIP_ID:\n\t\treturn KSZ8863_HUGE_PACKET_SIZE - VLAN_ETH_HLEN - ETH_FCS_LEN;\n\tcase KSZ8563_CHIP_ID:\n\tcase KSZ9477_CHIP_ID:\n\tcase KSZ9563_CHIP_ID:\n\tcase KSZ9567_CHIP_ID:\n\tcase KSZ9893_CHIP_ID:\n\tcase KSZ9896_CHIP_ID:\n\tcase KSZ9897_CHIP_ID:\n\tcase LAN9370_CHIP_ID:\n\tcase LAN9371_CHIP_ID:\n\tcase LAN9372_CHIP_ID:\n\tcase LAN9373_CHIP_ID:\n\tcase LAN9374_CHIP_ID:\n\t\treturn KSZ9477_MAX_FRAME_SIZE - VLAN_ETH_HLEN - ETH_FCS_LEN;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ksz_validate_eee(struct dsa_switch *ds, int port)\n{\n\tstruct ksz_device *dev = ds->priv;\n\n\tif (!dev->info->internal_phy[port])\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (dev->chip_id) {\n\tcase KSZ8563_CHIP_ID:\n\tcase KSZ9477_CHIP_ID:\n\tcase KSZ9563_CHIP_ID:\n\tcase KSZ9567_CHIP_ID:\n\tcase KSZ9893_CHIP_ID:\n\tcase KSZ9896_CHIP_ID:\n\tcase KSZ9897_CHIP_ID:\n\t\treturn 0;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ksz_get_mac_eee(struct dsa_switch *ds, int port,\n\t\t\t   struct ethtool_eee *e)\n{\n\tint ret;\n\n\tret = ksz_validate_eee(ds, port);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\te->tx_lpi_enabled = true;\n\n\t \n\te->tx_lpi_timer = 0;\n\n\treturn 0;\n}\n\nstatic int ksz_set_mac_eee(struct dsa_switch *ds, int port,\n\t\t\t   struct ethtool_eee *e)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tint ret;\n\n\tret = ksz_validate_eee(ds, port);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!e->tx_lpi_enabled) {\n\t\tdev_err(dev->dev, \"Disabling EEE Tx LPI is not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->tx_lpi_timer) {\n\t\tdev_err(dev->dev, \"Setting EEE Tx LPI timer is not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void ksz_set_xmii(struct ksz_device *dev, int port,\n\t\t\t phy_interface_t interface)\n{\n\tconst u8 *bitval = dev->info->xmii_ctrl1;\n\tstruct ksz_port *p = &dev->ports[port];\n\tconst u16 *regs = dev->info->regs;\n\tu8 data8;\n\n\tksz_pread8(dev, port, regs[P_XMII_CTRL_1], &data8);\n\n\tdata8 &= ~(P_MII_SEL_M | P_RGMII_ID_IG_ENABLE |\n\t\t   P_RGMII_ID_EG_ENABLE);\n\n\tswitch (interface) {\n\tcase PHY_INTERFACE_MODE_MII:\n\t\tdata8 |= bitval[P_MII_SEL];\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tdata8 |= bitval[P_RMII_SEL];\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_GMII:\n\t\tdata8 |= bitval[P_GMII_SEL];\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\tdata8 |= bitval[P_RGMII_SEL];\n\t\t \n\t\tif (dev->chip_id == KSZ9893_CHIP_ID ||\n\t\t    dev->chip_id == KSZ8563_CHIP_ID ||\n\t\t    dev->chip_id == KSZ9563_CHIP_ID)\n\t\t\tdata8 &= ~P_MII_MAC_MODE;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->dev, \"Unsupported interface '%s' for port %d\\n\",\n\t\t\tphy_modes(interface), port);\n\t\treturn;\n\t}\n\n\tif (p->rgmii_tx_val)\n\t\tdata8 |= P_RGMII_ID_EG_ENABLE;\n\n\tif (p->rgmii_rx_val)\n\t\tdata8 |= P_RGMII_ID_IG_ENABLE;\n\n\t \n\tksz_pwrite8(dev, port, regs[P_XMII_CTRL_1], data8);\n}\n\nphy_interface_t ksz_get_xmii(struct ksz_device *dev, int port, bool gbit)\n{\n\tconst u8 *bitval = dev->info->xmii_ctrl1;\n\tconst u16 *regs = dev->info->regs;\n\tphy_interface_t interface;\n\tu8 data8;\n\tu8 val;\n\n\tksz_pread8(dev, port, regs[P_XMII_CTRL_1], &data8);\n\n\tval = FIELD_GET(P_MII_SEL_M, data8);\n\n\tif (val == bitval[P_MII_SEL]) {\n\t\tif (gbit)\n\t\t\tinterface = PHY_INTERFACE_MODE_GMII;\n\t\telse\n\t\t\tinterface = PHY_INTERFACE_MODE_MII;\n\t} else if (val == bitval[P_RMII_SEL]) {\n\t\tinterface = PHY_INTERFACE_MODE_RGMII;\n\t} else {\n\t\tinterface = PHY_INTERFACE_MODE_RGMII;\n\t\tif (data8 & P_RGMII_ID_EG_ENABLE)\n\t\t\tinterface = PHY_INTERFACE_MODE_RGMII_TXID;\n\t\tif (data8 & P_RGMII_ID_IG_ENABLE) {\n\t\t\tinterface = PHY_INTERFACE_MODE_RGMII_RXID;\n\t\t\tif (data8 & P_RGMII_ID_EG_ENABLE)\n\t\t\t\tinterface = PHY_INTERFACE_MODE_RGMII_ID;\n\t\t}\n\t}\n\n\treturn interface;\n}\n\nstatic void ksz_phylink_mac_config(struct dsa_switch *ds, int port,\n\t\t\t\t   unsigned int mode,\n\t\t\t\t   const struct phylink_link_state *state)\n{\n\tstruct ksz_device *dev = ds->priv;\n\n\tif (ksz_is_ksz88x3(dev))\n\t\treturn;\n\n\t \n\tif (dev->info->internal_phy[port])\n\t\treturn;\n\n\tif (phylink_autoneg_inband(mode)) {\n\t\tdev_err(dev->dev, \"In-band AN not supported!\\n\");\n\t\treturn;\n\t}\n\n\tksz_set_xmii(dev, port, state->interface);\n\n\tif (dev->dev_ops->phylink_mac_config)\n\t\tdev->dev_ops->phylink_mac_config(dev, port, mode, state);\n\n\tif (dev->dev_ops->setup_rgmii_delay)\n\t\tdev->dev_ops->setup_rgmii_delay(dev, port);\n}\n\nbool ksz_get_gbit(struct ksz_device *dev, int port)\n{\n\tconst u8 *bitval = dev->info->xmii_ctrl1;\n\tconst u16 *regs = dev->info->regs;\n\tbool gbit = false;\n\tu8 data8;\n\tbool val;\n\n\tksz_pread8(dev, port, regs[P_XMII_CTRL_1], &data8);\n\n\tval = FIELD_GET(P_GMII_1GBIT_M, data8);\n\n\tif (val == bitval[P_GMII_1GBIT])\n\t\tgbit = true;\n\n\treturn gbit;\n}\n\nstatic void ksz_set_gbit(struct ksz_device *dev, int port, bool gbit)\n{\n\tconst u8 *bitval = dev->info->xmii_ctrl1;\n\tconst u16 *regs = dev->info->regs;\n\tu8 data8;\n\n\tksz_pread8(dev, port, regs[P_XMII_CTRL_1], &data8);\n\n\tdata8 &= ~P_GMII_1GBIT_M;\n\n\tif (gbit)\n\t\tdata8 |= FIELD_PREP(P_GMII_1GBIT_M, bitval[P_GMII_1GBIT]);\n\telse\n\t\tdata8 |= FIELD_PREP(P_GMII_1GBIT_M, bitval[P_GMII_NOT_1GBIT]);\n\n\t \n\tksz_pwrite8(dev, port, regs[P_XMII_CTRL_1], data8);\n}\n\nstatic void ksz_set_100_10mbit(struct ksz_device *dev, int port, int speed)\n{\n\tconst u8 *bitval = dev->info->xmii_ctrl0;\n\tconst u16 *regs = dev->info->regs;\n\tu8 data8;\n\n\tksz_pread8(dev, port, regs[P_XMII_CTRL_0], &data8);\n\n\tdata8 &= ~P_MII_100MBIT_M;\n\n\tif (speed == SPEED_100)\n\t\tdata8 |= FIELD_PREP(P_MII_100MBIT_M, bitval[P_MII_100MBIT]);\n\telse\n\t\tdata8 |= FIELD_PREP(P_MII_100MBIT_M, bitval[P_MII_10MBIT]);\n\n\t \n\tksz_pwrite8(dev, port, regs[P_XMII_CTRL_0], data8);\n}\n\nstatic void ksz_port_set_xmii_speed(struct ksz_device *dev, int port, int speed)\n{\n\tif (speed == SPEED_1000)\n\t\tksz_set_gbit(dev, port, true);\n\telse\n\t\tksz_set_gbit(dev, port, false);\n\n\tif (speed == SPEED_100 || speed == SPEED_10)\n\t\tksz_set_100_10mbit(dev, port, speed);\n}\n\nstatic void ksz_duplex_flowctrl(struct ksz_device *dev, int port, int duplex,\n\t\t\t\tbool tx_pause, bool rx_pause)\n{\n\tconst u8 *bitval = dev->info->xmii_ctrl0;\n\tconst u32 *masks = dev->info->masks;\n\tconst u16 *regs = dev->info->regs;\n\tu8 mask;\n\tu8 val;\n\n\tmask = P_MII_DUPLEX_M | masks[P_MII_TX_FLOW_CTRL] |\n\t       masks[P_MII_RX_FLOW_CTRL];\n\n\tif (duplex == DUPLEX_FULL)\n\t\tval = FIELD_PREP(P_MII_DUPLEX_M, bitval[P_MII_FULL_DUPLEX]);\n\telse\n\t\tval = FIELD_PREP(P_MII_DUPLEX_M, bitval[P_MII_HALF_DUPLEX]);\n\n\tif (tx_pause)\n\t\tval |= masks[P_MII_TX_FLOW_CTRL];\n\n\tif (rx_pause)\n\t\tval |= masks[P_MII_RX_FLOW_CTRL];\n\n\tksz_prmw8(dev, port, regs[P_XMII_CTRL_0], mask, val);\n}\n\nstatic void ksz9477_phylink_mac_link_up(struct ksz_device *dev, int port,\n\t\t\t\t\tunsigned int mode,\n\t\t\t\t\tphy_interface_t interface,\n\t\t\t\t\tstruct phy_device *phydev, int speed,\n\t\t\t\t\tint duplex, bool tx_pause,\n\t\t\t\t\tbool rx_pause)\n{\n\tstruct ksz_port *p;\n\n\tp = &dev->ports[port];\n\n\t \n\tif (dev->info->internal_phy[port])\n\t\treturn;\n\n\tp->phydev.speed = speed;\n\n\tksz_port_set_xmii_speed(dev, port, speed);\n\n\tksz_duplex_flowctrl(dev, port, duplex, tx_pause, rx_pause);\n}\n\nstatic void ksz_phylink_mac_link_up(struct dsa_switch *ds, int port,\n\t\t\t\t    unsigned int mode,\n\t\t\t\t    phy_interface_t interface,\n\t\t\t\t    struct phy_device *phydev, int speed,\n\t\t\t\t    int duplex, bool tx_pause, bool rx_pause)\n{\n\tstruct ksz_device *dev = ds->priv;\n\n\tif (dev->dev_ops->phylink_mac_link_up)\n\t\tdev->dev_ops->phylink_mac_link_up(dev, port, mode, interface,\n\t\t\t\t\t\t  phydev, speed, duplex,\n\t\t\t\t\t\t  tx_pause, rx_pause);\n}\n\nstatic int ksz_switch_detect(struct ksz_device *dev)\n{\n\tu8 id1, id2, id4;\n\tu16 id16;\n\tu32 id32;\n\tint ret;\n\n\t \n\tret = ksz_read16(dev, REG_CHIP_ID0, &id16);\n\tif (ret)\n\t\treturn ret;\n\n\tid1 = FIELD_GET(SW_FAMILY_ID_M, id16);\n\tid2 = FIELD_GET(SW_CHIP_ID_M, id16);\n\n\tswitch (id1) {\n\tcase KSZ87_FAMILY_ID:\n\t\tif (id2 == KSZ87_CHIP_ID_95) {\n\t\t\tu8 val;\n\n\t\t\tdev->chip_id = KSZ8795_CHIP_ID;\n\n\t\t\tksz_read8(dev, KSZ8_PORT_STATUS_0, &val);\n\t\t\tif (val & KSZ8_PORT_FIBER_MODE)\n\t\t\t\tdev->chip_id = KSZ8765_CHIP_ID;\n\t\t} else if (id2 == KSZ87_CHIP_ID_94) {\n\t\t\tdev->chip_id = KSZ8794_CHIP_ID;\n\t\t} else {\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tbreak;\n\tcase KSZ88_FAMILY_ID:\n\t\tif (id2 == KSZ88_CHIP_ID_63)\n\t\t\tdev->chip_id = KSZ8830_CHIP_ID;\n\t\telse\n\t\t\treturn -ENODEV;\n\t\tbreak;\n\tdefault:\n\t\tret = ksz_read32(dev, REG_CHIP_ID0, &id32);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdev->chip_rev = FIELD_GET(SW_REV_ID_M, id32);\n\t\tid32 &= ~0xFF;\n\n\t\tswitch (id32) {\n\t\tcase KSZ9477_CHIP_ID:\n\t\tcase KSZ9896_CHIP_ID:\n\t\tcase KSZ9897_CHIP_ID:\n\t\tcase KSZ9567_CHIP_ID:\n\t\tcase LAN9370_CHIP_ID:\n\t\tcase LAN9371_CHIP_ID:\n\t\tcase LAN9372_CHIP_ID:\n\t\tcase LAN9373_CHIP_ID:\n\t\tcase LAN9374_CHIP_ID:\n\t\t\tdev->chip_id = id32;\n\t\t\tbreak;\n\t\tcase KSZ9893_CHIP_ID:\n\t\t\tret = ksz_read8(dev, REG_CHIP_ID4,\n\t\t\t\t\t&id4);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (id4 == SKU_ID_KSZ8563)\n\t\t\t\tdev->chip_id = KSZ8563_CHIP_ID;\n\t\t\telse if (id4 == SKU_ID_KSZ9563)\n\t\t\t\tdev->chip_id = KSZ9563_CHIP_ID;\n\t\t\telse\n\t\t\t\tdev->chip_id = KSZ9893_CHIP_ID;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"unsupported switch detected %x)\\n\", id32);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic int cinc_cal(s32 idle_slope, s32 send_slope, u32 *bw)\n{\n\tu32 cinc = 0;\n\tu32 txrate;\n\tu32 rate;\n\tu8 temp;\n\tu8 i;\n\n\ttxrate = idle_slope - send_slope;\n\n\tif (!txrate)\n\t\treturn -EINVAL;\n\n\trate = idle_slope;\n\n\t \n\tfor (i = 0; i < 6; i++) {\n\t\trate = rate * 16;\n\n\t\ttemp = rate / txrate;\n\n\t\trate %= txrate;\n\n\t\tcinc = ((cinc << 4) | temp);\n\t}\n\n\t*bw = cinc;\n\n\treturn 0;\n}\n\nstatic int ksz_setup_tc_mode(struct ksz_device *dev, int port, u8 scheduler,\n\t\t\t     u8 shaper)\n{\n\treturn ksz_pwrite8(dev, port, REG_PORT_MTI_QUEUE_CTRL_0,\n\t\t\t   FIELD_PREP(MTI_SCHEDULE_MODE_M, scheduler) |\n\t\t\t   FIELD_PREP(MTI_SHAPING_M, shaper));\n}\n\nstatic int ksz_setup_tc_cbs(struct dsa_switch *ds, int port,\n\t\t\t    struct tc_cbs_qopt_offload *qopt)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tint ret;\n\tu32 bw;\n\n\tif (!dev->info->tc_cbs_supported)\n\t\treturn -EOPNOTSUPP;\n\n\tif (qopt->queue > dev->info->num_tx_queues)\n\t\treturn -EINVAL;\n\n\t \n\tret = ksz_pwrite32(dev, port, REG_PORT_MTI_QUEUE_INDEX__4, qopt->queue);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!qopt->enable)\n\t\treturn ksz_setup_tc_mode(dev, port, MTI_SCHEDULE_WRR,\n\t\t\t\t\t MTI_SHAPING_OFF);\n\n\t \n\tret = ksz_pwrite16(dev, port, REG_PORT_MTI_HI_WATER_MARK,\n\t\t\t   qopt->hicredit);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ksz_pwrite16(dev, port, REG_PORT_MTI_LO_WATER_MARK,\n\t\t\t   qopt->locredit);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = cinc_cal(qopt->idleslope, qopt->sendslope, &bw);\n\tif (ret)\n\t\treturn ret;\n\n\tif (dev->dev_ops->tc_cbs_set_cinc) {\n\t\tret = dev->dev_ops->tc_cbs_set_cinc(dev, port, bw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ksz_setup_tc_mode(dev, port, MTI_SCHEDULE_STRICT_PRIO,\n\t\t\t\t MTI_SHAPING_SRP);\n}\n\nstatic int ksz_disable_egress_rate_limit(struct ksz_device *dev, int port)\n{\n\tint queue, ret;\n\n\t \n\tfor (queue = 0; queue < dev->info->num_tx_queues; queue++) {\n\t\tret = ksz_pwrite8(dev, port, KSZ9477_REG_PORT_OUT_RATE_0 + queue,\n\t\t\t\t  KSZ9477_OUT_RATE_NO_LIMIT);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ksz_ets_band_to_queue(struct tc_ets_qopt_offload_replace_params *p,\n\t\t\t\t int band)\n{\n\t \n\treturn p->bands - 1 - band;\n}\n\nstatic int ksz_queue_set_strict(struct ksz_device *dev, int port, int queue)\n{\n\tint ret;\n\n\tret = ksz_pwrite32(dev, port, REG_PORT_MTI_QUEUE_INDEX__4, queue);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ksz_setup_tc_mode(dev, port, MTI_SCHEDULE_STRICT_PRIO,\n\t\t\t\t MTI_SHAPING_OFF);\n}\n\nstatic int ksz_queue_set_wrr(struct ksz_device *dev, int port, int queue,\n\t\t\t     int weight)\n{\n\tint ret;\n\n\tret = ksz_pwrite32(dev, port, REG_PORT_MTI_QUEUE_INDEX__4, queue);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ksz_setup_tc_mode(dev, port, MTI_SCHEDULE_WRR,\n\t\t\t\tMTI_SHAPING_OFF);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ksz_pwrite8(dev, port, KSZ9477_PORT_MTI_QUEUE_CTRL_1, weight);\n}\n\nstatic int ksz_tc_ets_add(struct ksz_device *dev, int port,\n\t\t\t  struct tc_ets_qopt_offload_replace_params *p)\n{\n\tint ret, band, tc_prio;\n\tu32 queue_map = 0;\n\n\t \n\tret = ksz_disable_egress_rate_limit(dev, port);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (band = 0; band < p->bands; band++) {\n\t\tint queue = ksz_ets_band_to_queue(p, band);\n\n\t\tret = ksz_queue_set_strict(dev, port, queue);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tfor (tc_prio = 0; tc_prio < ARRAY_SIZE(p->priomap); tc_prio++) {\n\t\tint queue;\n\n\t\tif (tc_prio > KSZ9477_MAX_TC_PRIO)\n\t\t\tbreak;\n\n\t\tqueue = ksz_ets_band_to_queue(p, p->priomap[tc_prio]);\n\t\tqueue_map |= queue << (tc_prio * KSZ9477_PORT_TC_MAP_S);\n\t}\n\n\treturn ksz_pwrite32(dev, port, KSZ9477_PORT_MRI_TC_MAP__4, queue_map);\n}\n\nstatic int ksz_tc_ets_del(struct ksz_device *dev, int port)\n{\n\tint ret, queue, tc_prio, s;\n\tu32 queue_map = 0;\n\n\t \n\tfor (queue = 0; queue < dev->info->num_tx_queues; queue++) {\n\t\tret = ksz_queue_set_wrr(dev, port, queue,\n\t\t\t\t\tKSZ9477_DEFAULT_WRR_WEIGHT);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tswitch (dev->info->num_tx_queues) {\n\tcase 2:\n\t\ts = 2;\n\t\tbreak;\n\tcase 4:\n\t\ts = 1;\n\t\tbreak;\n\tcase 8:\n\t\ts = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (tc_prio = 0; tc_prio <= KSZ9477_MAX_TC_PRIO; tc_prio++) {\n\t\tint queue;\n\n\t\tqueue = tc_prio >> s;\n\t\tqueue_map |= queue << (tc_prio * KSZ9477_PORT_TC_MAP_S);\n\t}\n\n\treturn ksz_pwrite32(dev, port, KSZ9477_PORT_MRI_TC_MAP__4, queue_map);\n}\n\nstatic int ksz_tc_ets_validate(struct ksz_device *dev, int port,\n\t\t\t       struct tc_ets_qopt_offload_replace_params *p)\n{\n\tint band;\n\n\t \n\tif (p->bands != dev->info->num_tx_queues) {\n\t\tdev_err(dev->dev, \"Not supported amount of bands. It should be %d\\n\",\n\t\t\tdev->info->num_tx_queues);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tfor (band = 0; band < p->bands; ++band) {\n\t\t \n\t\tif (p->quanta[band]) {\n\t\t\tdev_err(dev->dev, \"Quanta/weights configuration is not supported.\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ksz_tc_setup_qdisc_ets(struct dsa_switch *ds, int port,\n\t\t\t\t  struct tc_ets_qopt_offload *qopt)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tint ret;\n\n\tif (!dev->info->tc_ets_supported)\n\t\treturn -EOPNOTSUPP;\n\n\tif (qopt->parent != TC_H_ROOT) {\n\t\tdev_err(dev->dev, \"Parent should be \\\"root\\\"\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (qopt->command) {\n\tcase TC_ETS_REPLACE:\n\t\tret = ksz_tc_ets_validate(dev, port, &qopt->replace_params);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn ksz_tc_ets_add(dev, port, &qopt->replace_params);\n\tcase TC_ETS_DESTROY:\n\t\treturn ksz_tc_ets_del(dev, port);\n\tcase TC_ETS_STATS:\n\tcase TC_ETS_GRAFT:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ksz_setup_tc(struct dsa_switch *ds, int port,\n\t\t\tenum tc_setup_type type, void *type_data)\n{\n\tswitch (type) {\n\tcase TC_SETUP_QDISC_CBS:\n\t\treturn ksz_setup_tc_cbs(ds, port, type_data);\n\tcase TC_SETUP_QDISC_ETS:\n\t\treturn ksz_tc_setup_qdisc_ets(ds, port, type_data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct dsa_switch_ops ksz_switch_ops = {\n\t.get_tag_protocol\t= ksz_get_tag_protocol,\n\t.connect_tag_protocol   = ksz_connect_tag_protocol,\n\t.get_phy_flags\t\t= ksz_get_phy_flags,\n\t.setup\t\t\t= ksz_setup,\n\t.teardown\t\t= ksz_teardown,\n\t.phy_read\t\t= ksz_phy_read16,\n\t.phy_write\t\t= ksz_phy_write16,\n\t.phylink_get_caps\t= ksz_phylink_get_caps,\n\t.phylink_mac_config\t= ksz_phylink_mac_config,\n\t.phylink_mac_link_up\t= ksz_phylink_mac_link_up,\n\t.phylink_mac_link_down\t= ksz_mac_link_down,\n\t.port_enable\t\t= ksz_enable_port,\n\t.set_ageing_time\t= ksz_set_ageing_time,\n\t.get_strings\t\t= ksz_get_strings,\n\t.get_ethtool_stats\t= ksz_get_ethtool_stats,\n\t.get_sset_count\t\t= ksz_sset_count,\n\t.port_bridge_join\t= ksz_port_bridge_join,\n\t.port_bridge_leave\t= ksz_port_bridge_leave,\n\t.port_stp_state_set\t= ksz_port_stp_state_set,\n\t.port_pre_bridge_flags\t= ksz_port_pre_bridge_flags,\n\t.port_bridge_flags\t= ksz_port_bridge_flags,\n\t.port_fast_age\t\t= ksz_port_fast_age,\n\t.port_vlan_filtering\t= ksz_port_vlan_filtering,\n\t.port_vlan_add\t\t= ksz_port_vlan_add,\n\t.port_vlan_del\t\t= ksz_port_vlan_del,\n\t.port_fdb_dump\t\t= ksz_port_fdb_dump,\n\t.port_fdb_add\t\t= ksz_port_fdb_add,\n\t.port_fdb_del\t\t= ksz_port_fdb_del,\n\t.port_mdb_add           = ksz_port_mdb_add,\n\t.port_mdb_del           = ksz_port_mdb_del,\n\t.port_mirror_add\t= ksz_port_mirror_add,\n\t.port_mirror_del\t= ksz_port_mirror_del,\n\t.get_stats64\t\t= ksz_get_stats64,\n\t.get_pause_stats\t= ksz_get_pause_stats,\n\t.port_change_mtu\t= ksz_change_mtu,\n\t.port_max_mtu\t\t= ksz_max_mtu,\n\t.get_ts_info\t\t= ksz_get_ts_info,\n\t.port_hwtstamp_get\t= ksz_hwtstamp_get,\n\t.port_hwtstamp_set\t= ksz_hwtstamp_set,\n\t.port_txtstamp\t\t= ksz_port_txtstamp,\n\t.port_rxtstamp\t\t= ksz_port_rxtstamp,\n\t.port_setup_tc\t\t= ksz_setup_tc,\n\t.get_mac_eee\t\t= ksz_get_mac_eee,\n\t.set_mac_eee\t\t= ksz_set_mac_eee,\n};\n\nstruct ksz_device *ksz_switch_alloc(struct device *base, void *priv)\n{\n\tstruct dsa_switch *ds;\n\tstruct ksz_device *swdev;\n\n\tds = devm_kzalloc(base, sizeof(*ds), GFP_KERNEL);\n\tif (!ds)\n\t\treturn NULL;\n\n\tds->dev = base;\n\tds->num_ports = DSA_MAX_PORTS;\n\tds->ops = &ksz_switch_ops;\n\n\tswdev = devm_kzalloc(base, sizeof(*swdev), GFP_KERNEL);\n\tif (!swdev)\n\t\treturn NULL;\n\n\tds->priv = swdev;\n\tswdev->dev = base;\n\n\tswdev->ds = ds;\n\tswdev->priv = priv;\n\n\treturn swdev;\n}\nEXPORT_SYMBOL(ksz_switch_alloc);\n\nstatic void ksz_parse_rgmii_delay(struct ksz_device *dev, int port_num,\n\t\t\t\t  struct device_node *port_dn)\n{\n\tphy_interface_t phy_mode = dev->ports[port_num].interface;\n\tint rx_delay = -1, tx_delay = -1;\n\n\tif (!phy_interface_mode_is_rgmii(phy_mode))\n\t\treturn;\n\n\tof_property_read_u32(port_dn, \"rx-internal-delay-ps\", &rx_delay);\n\tof_property_read_u32(port_dn, \"tx-internal-delay-ps\", &tx_delay);\n\n\tif (rx_delay == -1 && tx_delay == -1) {\n\t\tdev_warn(dev->dev,\n\t\t\t \"Port %d interpreting RGMII delay settings based on \\\"phy-mode\\\" property, \"\n\t\t\t \"please update device tree to specify \\\"rx-internal-delay-ps\\\" and \"\n\t\t\t \"\\\"tx-internal-delay-ps\\\"\",\n\t\t\t port_num);\n\n\t\tif (phy_mode == PHY_INTERFACE_MODE_RGMII_RXID ||\n\t\t    phy_mode == PHY_INTERFACE_MODE_RGMII_ID)\n\t\t\trx_delay = 2000;\n\n\t\tif (phy_mode == PHY_INTERFACE_MODE_RGMII_TXID ||\n\t\t    phy_mode == PHY_INTERFACE_MODE_RGMII_ID)\n\t\t\ttx_delay = 2000;\n\t}\n\n\tif (rx_delay < 0)\n\t\trx_delay = 0;\n\tif (tx_delay < 0)\n\t\ttx_delay = 0;\n\n\tdev->ports[port_num].rgmii_rx_val = rx_delay;\n\tdev->ports[port_num].rgmii_tx_val = tx_delay;\n}\n\nint ksz_switch_register(struct ksz_device *dev)\n{\n\tconst struct ksz_chip_data *info;\n\tstruct device_node *port, *ports;\n\tphy_interface_t interface;\n\tunsigned int port_num;\n\tint ret;\n\tint i;\n\n\tif (dev->pdata)\n\t\tdev->chip_id = dev->pdata->chip_id;\n\n\tdev->reset_gpio = devm_gpiod_get_optional(dev->dev, \"reset\",\n\t\t\t\t\t\t  GPIOD_OUT_LOW);\n\tif (IS_ERR(dev->reset_gpio))\n\t\treturn PTR_ERR(dev->reset_gpio);\n\n\tif (dev->reset_gpio) {\n\t\tgpiod_set_value_cansleep(dev->reset_gpio, 1);\n\t\tusleep_range(10000, 12000);\n\t\tgpiod_set_value_cansleep(dev->reset_gpio, 0);\n\t\tmsleep(100);\n\t}\n\n\tmutex_init(&dev->dev_mutex);\n\tmutex_init(&dev->regmap_mutex);\n\tmutex_init(&dev->alu_mutex);\n\tmutex_init(&dev->vlan_mutex);\n\n\tret = ksz_switch_detect(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tinfo = ksz_lookup_info(dev->chip_id);\n\tif (!info)\n\t\treturn -ENODEV;\n\n\t \n\tdev->info = info;\n\n\tdev_info(dev->dev, \"found switch: %s, rev %i\\n\",\n\t\t dev->info->dev_name, dev->chip_rev);\n\n\tret = ksz_check_device_id(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->dev_ops = dev->info->ops;\n\n\tret = dev->dev_ops->init(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->ports = devm_kzalloc(dev->dev,\n\t\t\t\t  dev->info->port_cnt * sizeof(struct ksz_port),\n\t\t\t\t  GFP_KERNEL);\n\tif (!dev->ports)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < dev->info->port_cnt; i++) {\n\t\tspin_lock_init(&dev->ports[i].mib.stats64_lock);\n\t\tmutex_init(&dev->ports[i].mib.cnt_mutex);\n\t\tdev->ports[i].mib.counters =\n\t\t\tdevm_kzalloc(dev->dev,\n\t\t\t\t     sizeof(u64) * (dev->info->mib_cnt + 1),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!dev->ports[i].mib.counters)\n\t\t\treturn -ENOMEM;\n\n\t\tdev->ports[i].ksz_dev = dev;\n\t\tdev->ports[i].num = i;\n\t}\n\n\t \n\tdev->ds->num_ports = dev->info->port_cnt;\n\n\t \n\tfor (port_num = 0; port_num < dev->info->port_cnt; ++port_num)\n\t\tdev->ports[port_num].interface = PHY_INTERFACE_MODE_NA;\n\tif (dev->dev->of_node) {\n\t\tret = of_get_phy_mode(dev->dev->of_node, &interface);\n\t\tif (ret == 0)\n\t\t\tdev->compat_interface = interface;\n\t\tports = of_get_child_by_name(dev->dev->of_node, \"ethernet-ports\");\n\t\tif (!ports)\n\t\t\tports = of_get_child_by_name(dev->dev->of_node, \"ports\");\n\t\tif (ports) {\n\t\t\tfor_each_available_child_of_node(ports, port) {\n\t\t\t\tif (of_property_read_u32(port, \"reg\",\n\t\t\t\t\t\t\t &port_num))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!(dev->port_mask & BIT(port_num))) {\n\t\t\t\t\tof_node_put(port);\n\t\t\t\t\tof_node_put(ports);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tof_get_phy_mode(port,\n\t\t\t\t\t\t&dev->ports[port_num].interface);\n\n\t\t\t\tksz_parse_rgmii_delay(dev, port_num, port);\n\t\t\t}\n\t\t\tof_node_put(ports);\n\t\t}\n\t\tdev->synclko_125 = of_property_read_bool(dev->dev->of_node,\n\t\t\t\t\t\t\t \"microchip,synclko-125\");\n\t\tdev->synclko_disable = of_property_read_bool(dev->dev->of_node,\n\t\t\t\t\t\t\t     \"microchip,synclko-disable\");\n\t\tif (dev->synclko_125 && dev->synclko_disable) {\n\t\t\tdev_err(dev->dev, \"inconsistent synclko settings\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tret = dsa_register_switch(dev->ds);\n\tif (ret) {\n\t\tdev->dev_ops->exit(dev);\n\t\treturn ret;\n\t}\n\n\t \n\tdev->mib_read_interval = msecs_to_jiffies(5000);\n\n\t \n\tschedule_delayed_work(&dev->mib_read, 0);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(ksz_switch_register);\n\nvoid ksz_switch_remove(struct ksz_device *dev)\n{\n\t \n\tif (dev->mib_read_interval) {\n\t\tdev->mib_read_interval = 0;\n\t\tcancel_delayed_work_sync(&dev->mib_read);\n\t}\n\n\tdev->dev_ops->exit(dev);\n\tdsa_unregister_switch(dev->ds);\n\n\tif (dev->reset_gpio)\n\t\tgpiod_set_value_cansleep(dev->reset_gpio, 1);\n\n}\nEXPORT_SYMBOL(ksz_switch_remove);\n\nMODULE_AUTHOR(\"Woojung Huh <Woojung.Huh@microchip.com>\");\nMODULE_DESCRIPTION(\"Microchip KSZ Series Switch DSA Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}