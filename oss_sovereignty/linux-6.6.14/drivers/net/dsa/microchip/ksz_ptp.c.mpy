{
  "module_name": "ksz_ptp.c",
  "hash_id": "47d5aa6e899acaa135685149e522980451a5e72704fe7afc60ea7db048b5fd42",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/microchip/ksz_ptp.c",
  "human_readable_source": "\n \n\n#include <linux/dsa/ksz_common.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel.h>\n#include <linux/ptp_classify.h>\n#include <linux/ptp_clock_kernel.h>\n\n#include \"ksz_common.h\"\n#include \"ksz_ptp.h\"\n#include \"ksz_ptp_reg.h\"\n\n#define ptp_caps_to_data(d) container_of((d), struct ksz_ptp_data, caps)\n#define ptp_data_to_ksz_dev(d) container_of((d), struct ksz_device, ptp_data)\n#define work_to_xmit_work(w) \\\n\t\tcontainer_of((w), struct ksz_deferred_xmit_work, work)\n\n \n#define KSZ_MAX_DRIFT_CORR 6249999\n#define KSZ_MAX_PULSE_WIDTH 125000000LL\n\n#define KSZ_PTP_INC_NS 40ULL   \n#define KSZ_PTP_SUBNS_BITS 32\n\n#define KSZ_PTP_INT_START 13\n\nstatic int ksz_ptp_tou_gpio(struct ksz_device *dev)\n{\n\tint ret;\n\n\tif (!is_lan937x(dev))\n\t\treturn 0;\n\n\tret = ksz_rmw32(dev, REG_PTP_CTRL_STAT__4, GPIO_OUT,\n\t\t\tGPIO_OUT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ksz_rmw32(dev, REG_SW_GLOBAL_LED_OVR__4, LED_OVR_1 | LED_OVR_2,\n\t\t\tLED_OVR_1 | LED_OVR_2);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ksz_rmw32(dev, REG_SW_GLOBAL_LED_SRC__4,\n\t\t\t LED_SRC_PTP_GPIO_1 | LED_SRC_PTP_GPIO_2,\n\t\t\t LED_SRC_PTP_GPIO_1 | LED_SRC_PTP_GPIO_2);\n}\n\nstatic int ksz_ptp_tou_reset(struct ksz_device *dev, u8 unit)\n{\n\tu32 data;\n\tint ret;\n\n\t \n\tret = ksz_rmw32(dev, REG_PTP_CTRL_STAT__4, TRIG_RESET, TRIG_RESET);\n\n\tdata = FIELD_PREP(TRIG_DONE_M, BIT(unit));\n\tret = ksz_write32(dev, REG_PTP_TRIG_STATUS__4, data);\n\tif (ret)\n\t\treturn ret;\n\n\tdata = FIELD_PREP(TRIG_INT_M, BIT(unit));\n\tret = ksz_write32(dev, REG_PTP_INT_STATUS__4, data);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn ksz_rmw32(dev, REG_PTP_CTRL_STAT__4, (TRIG_RESET | TRIG_ENABLE),\n\t\t\t 0);\n}\n\nstatic int ksz_ptp_tou_pulse_verify(u64 pulse_ns)\n{\n\tu32 data;\n\n\tif (pulse_ns & 0x3)\n\t\treturn -EINVAL;\n\n\tdata = (pulse_ns / 8);\n\tif (!FIELD_FIT(TRIG_PULSE_WIDTH_M, data))\n\t\treturn -ERANGE;\n\n\treturn 0;\n}\n\nstatic int ksz_ptp_tou_target_time_set(struct ksz_device *dev,\n\t\t\t\t       struct timespec64 const *ts)\n{\n\tint ret;\n\n\t \n\tif ((ts->tv_sec & 0xffffffff) != ts->tv_sec)\n\t\treturn -EINVAL;\n\n\tret = ksz_write32(dev, REG_TRIG_TARGET_NANOSEC, ts->tv_nsec);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ksz_write32(dev, REG_TRIG_TARGET_SEC, ts->tv_sec);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ksz_ptp_tou_start(struct ksz_device *dev, u8 unit)\n{\n\tu32 data;\n\tint ret;\n\n\tret = ksz_rmw32(dev, REG_PTP_CTRL_STAT__4, TRIG_ENABLE, TRIG_ENABLE);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ksz_read32(dev, REG_PTP_TRIG_STATUS__4, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tif (FIELD_GET(TRIG_ERROR_M, data) & (1 << unit)) {\n\t\tdev_err(dev->dev, \"%s: Trigger unit%d error!\\n\", __func__,\n\t\t\tunit);\n\t\tret = -EIO;\n\t\t \n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ksz_ptp_configure_perout(struct ksz_device *dev,\n\t\t\t\t    u32 cycle_width_ns, u32 pulse_width_ns,\n\t\t\t\t    struct timespec64 const *target_time,\n\t\t\t\t    u8 index)\n{\n\tu32 data;\n\tint ret;\n\n\tdata = FIELD_PREP(TRIG_NOTIFY, 1) |\n\t\tFIELD_PREP(TRIG_GPO_M, index) |\n\t\tFIELD_PREP(TRIG_PATTERN_M, TRIG_POS_PERIOD);\n\tret = ksz_write32(dev, REG_TRIG_CTRL__4, data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ksz_write32(dev, REG_TRIG_CYCLE_WIDTH, cycle_width_ns);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ksz_rmw32(dev, REG_TRIG_CYCLE_CNT, TRIG_CYCLE_CNT_M, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tdata = (pulse_width_ns / 8);\n\tret = ksz_write32(dev, REG_TRIG_PULSE_WIDTH__4, data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ksz_ptp_tou_target_time_set(dev, target_time);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ksz_ptp_enable_perout(struct ksz_device *dev,\n\t\t\t\t struct ptp_perout_request const *request,\n\t\t\t\t int on)\n{\n\tstruct ksz_ptp_data *ptp_data = &dev->ptp_data;\n\tu64 req_pulse_width_ns;\n\tu64 cycle_width_ns;\n\tu64 pulse_width_ns;\n\tint pin = 0;\n\tu32 data32;\n\tint ret;\n\n\tif (request->flags & ~PTP_PEROUT_DUTY_CYCLE)\n\t\treturn -EOPNOTSUPP;\n\n\tif (ptp_data->tou_mode != KSZ_PTP_TOU_PEROUT &&\n\t    ptp_data->tou_mode != KSZ_PTP_TOU_IDLE)\n\t\treturn -EBUSY;\n\n\tpin = ptp_find_pin(ptp_data->clock, PTP_PF_PEROUT, request->index);\n\tif (pin < 0)\n\t\treturn -EINVAL;\n\n\tdata32 = FIELD_PREP(PTP_GPIO_INDEX, pin) |\n\t\t FIELD_PREP(PTP_TOU_INDEX, request->index);\n\tret = ksz_rmw32(dev, REG_PTP_UNIT_INDEX__4,\n\t\t\tPTP_GPIO_INDEX | PTP_TOU_INDEX, data32);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ksz_ptp_tou_reset(dev, request->index);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!on) {\n\t\tptp_data->tou_mode = KSZ_PTP_TOU_IDLE;\n\t\treturn 0;\n\t}\n\n\tptp_data->perout_target_time_first.tv_sec  = request->start.sec;\n\tptp_data->perout_target_time_first.tv_nsec = request->start.nsec;\n\n\tptp_data->perout_period.tv_sec = request->period.sec;\n\tptp_data->perout_period.tv_nsec = request->period.nsec;\n\n\tcycle_width_ns = timespec64_to_ns(&ptp_data->perout_period);\n\tif ((cycle_width_ns & TRIG_CYCLE_WIDTH_M) != cycle_width_ns)\n\t\treturn -EINVAL;\n\n\tif (request->flags & PTP_PEROUT_DUTY_CYCLE) {\n\t\tpulse_width_ns = request->on.sec * NSEC_PER_SEC +\n\t\t\trequest->on.nsec;\n\t} else {\n\t\t \n\t\treq_pulse_width_ns = (request->period.sec * NSEC_PER_SEC +\n\t\t\t\t      request->period.nsec) / 2;\n\t\tpulse_width_ns = min_t(u64, req_pulse_width_ns,\n\t\t\t\t       KSZ_MAX_PULSE_WIDTH);\n\t}\n\n\tret = ksz_ptp_tou_pulse_verify(pulse_width_ns);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ksz_ptp_configure_perout(dev, cycle_width_ns, pulse_width_ns,\n\t\t\t\t       &ptp_data->perout_target_time_first,\n\t\t\t\t       pin);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ksz_ptp_tou_gpio(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ksz_ptp_tou_start(dev, request->index);\n\tif (ret)\n\t\treturn ret;\n\n\tptp_data->tou_mode = KSZ_PTP_TOU_PEROUT;\n\n\treturn 0;\n}\n\nstatic int ksz_ptp_enable_mode(struct ksz_device *dev)\n{\n\tstruct ksz_tagger_data *tagger_data = ksz_tagger_data(dev->ds);\n\tstruct ksz_ptp_data *ptp_data = &dev->ptp_data;\n\tstruct ksz_port *prt;\n\tstruct dsa_port *dp;\n\tbool tag_en = false;\n\tint ret;\n\n\tdsa_switch_for_each_user_port(dp, dev->ds) {\n\t\tprt = &dev->ports[dp->index];\n\t\tif (prt->hwts_tx_en || prt->hwts_rx_en) {\n\t\t\ttag_en = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (tag_en) {\n\t\tret = ptp_schedule_worker(ptp_data->clock, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tptp_cancel_worker_sync(ptp_data->clock);\n\t}\n\n\ttagger_data->hwtstamp_set_state(dev->ds, tag_en);\n\n\treturn ksz_rmw16(dev, REG_PTP_MSG_CONF1, PTP_ENABLE,\n\t\t\t tag_en ? PTP_ENABLE : 0);\n}\n\n \nint ksz_get_ts_info(struct dsa_switch *ds, int port, struct ethtool_ts_info *ts)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tstruct ksz_ptp_data *ptp_data;\n\n\tptp_data = &dev->ptp_data;\n\n\tif (!ptp_data->clock)\n\t\treturn -ENODEV;\n\n\tts->so_timestamping = SOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t      SOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t      SOF_TIMESTAMPING_RAW_HARDWARE;\n\n\tts->tx_types = BIT(HWTSTAMP_TX_OFF) | BIT(HWTSTAMP_TX_ONESTEP_P2P);\n\n\tif (is_lan937x(dev))\n\t\tts->tx_types |= BIT(HWTSTAMP_TX_ON);\n\n\tts->rx_filters = BIT(HWTSTAMP_FILTER_NONE) |\n\t\t\t BIT(HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |\n\t\t\t BIT(HWTSTAMP_FILTER_PTP_V2_L2_EVENT) |\n\t\t\t BIT(HWTSTAMP_FILTER_PTP_V2_EVENT);\n\n\tts->phc_index = ptp_clock_index(ptp_data->clock);\n\n\treturn 0;\n}\n\nint ksz_hwtstamp_get(struct dsa_switch *ds, int port, struct ifreq *ifr)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tstruct hwtstamp_config *config;\n\tstruct ksz_port *prt;\n\n\tprt = &dev->ports[port];\n\tconfig = &prt->tstamp_config;\n\n\treturn copy_to_user(ifr->ifr_data, config, sizeof(*config)) ?\n\t\t-EFAULT : 0;\n}\n\nstatic int ksz_set_hwtstamp_config(struct ksz_device *dev,\n\t\t\t\t   struct ksz_port *prt,\n\t\t\t\t   struct hwtstamp_config *config)\n{\n\tint ret;\n\n\tif (config->flags)\n\t\treturn -EINVAL;\n\n\tswitch (config->tx_type) {\n\tcase HWTSTAMP_TX_OFF:\n\t\tprt->ptpmsg_irq[KSZ_SYNC_MSG].ts_en  = false;\n\t\tprt->ptpmsg_irq[KSZ_XDREQ_MSG].ts_en = false;\n\t\tprt->ptpmsg_irq[KSZ_PDRES_MSG].ts_en = false;\n\t\tprt->hwts_tx_en = false;\n\t\tbreak;\n\tcase HWTSTAMP_TX_ONESTEP_P2P:\n\t\tprt->ptpmsg_irq[KSZ_SYNC_MSG].ts_en  = false;\n\t\tprt->ptpmsg_irq[KSZ_XDREQ_MSG].ts_en = true;\n\t\tprt->ptpmsg_irq[KSZ_PDRES_MSG].ts_en = false;\n\t\tprt->hwts_tx_en = true;\n\n\t\tret = ksz_rmw16(dev, REG_PTP_MSG_CONF1, PTP_1STEP, PTP_1STEP);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbreak;\n\tcase HWTSTAMP_TX_ON:\n\t\tif (!is_lan937x(dev))\n\t\t\treturn -ERANGE;\n\n\t\tprt->ptpmsg_irq[KSZ_SYNC_MSG].ts_en  = true;\n\t\tprt->ptpmsg_irq[KSZ_XDREQ_MSG].ts_en = true;\n\t\tprt->ptpmsg_irq[KSZ_PDRES_MSG].ts_en = true;\n\t\tprt->hwts_tx_en = true;\n\n\t\tret = ksz_rmw16(dev, REG_PTP_MSG_CONF1, PTP_1STEP, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tswitch (config->rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tprt->hwts_rx_en = false;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\t\tconfig->rx_filter = HWTSTAMP_FILTER_PTP_V2_L4_EVENT;\n\t\tprt->hwts_rx_en = true;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\t\tconfig->rx_filter = HWTSTAMP_FILTER_PTP_V2_L2_EVENT;\n\t\tprt->hwts_rx_en = true;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\t\tconfig->rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\n\t\tprt->hwts_rx_en = true;\n\t\tbreak;\n\tdefault:\n\t\tconfig->rx_filter = HWTSTAMP_FILTER_NONE;\n\t\treturn -ERANGE;\n\t}\n\n\treturn ksz_ptp_enable_mode(dev);\n}\n\nint ksz_hwtstamp_set(struct dsa_switch *ds, int port, struct ifreq *ifr)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tstruct hwtstamp_config config;\n\tstruct ksz_port *prt;\n\tint ret;\n\n\tprt = &dev->ports[port];\n\n\tif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\n\t\treturn -EFAULT;\n\n\tret = ksz_set_hwtstamp_config(dev, prt, &config);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(&prt->tstamp_config, &config, sizeof(config));\n\n\tif (copy_to_user(ifr->ifr_data, &config, sizeof(config)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic ktime_t ksz_tstamp_reconstruct(struct ksz_device *dev, ktime_t tstamp)\n{\n\tstruct timespec64 ptp_clock_time;\n\tstruct ksz_ptp_data *ptp_data;\n\tstruct timespec64 diff;\n\tstruct timespec64 ts;\n\n\tptp_data = &dev->ptp_data;\n\tts = ktime_to_timespec64(tstamp);\n\n\tspin_lock_bh(&ptp_data->clock_lock);\n\tptp_clock_time = ptp_data->clock_time;\n\tspin_unlock_bh(&ptp_data->clock_lock);\n\n\t \n\tts.tv_sec = (ptp_clock_time.tv_sec & ~3) | ts.tv_sec;\n\n\t \n\tdiff = timespec64_sub(ts, ptp_clock_time);\n\tif (diff.tv_sec > 2)\n\t\tts.tv_sec -= 4;\n\telse if (diff.tv_sec < -2)\n\t\tts.tv_sec += 4;\n\n\treturn timespec64_to_ktime(ts);\n}\n\nbool ksz_port_rxtstamp(struct dsa_switch *ds, int port, struct sk_buff *skb,\n\t\t       unsigned int type)\n{\n\tstruct skb_shared_hwtstamps *hwtstamps = skb_hwtstamps(skb);\n\tstruct ksz_device *dev = ds->priv;\n\tstruct ptp_header *ptp_hdr;\n\tstruct ksz_port *prt;\n\tu8 ptp_msg_type;\n\tktime_t tstamp;\n\ts64 correction;\n\n\tprt = &dev->ports[port];\n\n\ttstamp = KSZ_SKB_CB(skb)->tstamp;\n\tmemset(hwtstamps, 0, sizeof(*hwtstamps));\n\thwtstamps->hwtstamp = ksz_tstamp_reconstruct(dev, tstamp);\n\n\tif (prt->tstamp_config.tx_type != HWTSTAMP_TX_ONESTEP_P2P)\n\t\tgoto out;\n\n\tptp_hdr = ptp_parse_header(skb, type);\n\tif (!ptp_hdr)\n\t\tgoto out;\n\n\tptp_msg_type = ptp_get_msgtype(ptp_hdr, type);\n\tif (ptp_msg_type != PTP_MSGTYPE_PDELAY_REQ)\n\t\tgoto out;\n\n\t \n\tcorrection = (s64)get_unaligned_be64(&ptp_hdr->correction);\n\tcorrection -= ktime_to_ns(tstamp) << 16;\n\n\tptp_header_update_correction(skb, type, ptp_hdr, correction);\n\nout:\n\treturn false;\n}\n\nvoid ksz_port_txtstamp(struct dsa_switch *ds, int port, struct sk_buff *skb)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tstruct ptp_header *hdr;\n\tstruct sk_buff *clone;\n\tstruct ksz_port *prt;\n\tunsigned int type;\n\tu8 ptp_msg_type;\n\n\tprt = &dev->ports[port];\n\n\tif (!prt->hwts_tx_en)\n\t\treturn;\n\n\ttype = ptp_classify_raw(skb);\n\tif (type == PTP_CLASS_NONE)\n\t\treturn;\n\n\thdr = ptp_parse_header(skb, type);\n\tif (!hdr)\n\t\treturn;\n\n\tptp_msg_type = ptp_get_msgtype(hdr, type);\n\n\tswitch (ptp_msg_type) {\n\tcase PTP_MSGTYPE_SYNC:\n\t\tif (prt->tstamp_config.tx_type == HWTSTAMP_TX_ONESTEP_P2P)\n\t\t\treturn;\n\t\tbreak;\n\tcase PTP_MSGTYPE_PDELAY_REQ:\n\t\tbreak;\n\tcase PTP_MSGTYPE_PDELAY_RESP:\n\t\tif (prt->tstamp_config.tx_type == HWTSTAMP_TX_ONESTEP_P2P) {\n\t\t\tKSZ_SKB_CB(skb)->ptp_type = type;\n\t\t\tKSZ_SKB_CB(skb)->update_correction = true;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\tclone = skb_clone_sk(skb);\n\tif (!clone)\n\t\treturn;\n\n\t \n\tKSZ_SKB_CB(skb)->clone = clone;\n}\n\nstatic void ksz_ptp_txtstamp_skb(struct ksz_device *dev,\n\t\t\t\t struct ksz_port *prt, struct sk_buff *skb)\n{\n\tstruct skb_shared_hwtstamps hwtstamps = {};\n\tint ret;\n\n\t \n\tret = wait_for_completion_timeout(&prt->tstamp_msg_comp,\n\t\t\t\t\t  msecs_to_jiffies(100));\n\tif (!ret)\n\t\treturn;\n\n\thwtstamps.hwtstamp = prt->tstamp_msg;\n\tskb_complete_tx_timestamp(skb, &hwtstamps);\n}\n\nvoid ksz_port_deferred_xmit(struct kthread_work *work)\n{\n\tstruct ksz_deferred_xmit_work *xmit_work = work_to_xmit_work(work);\n\tstruct sk_buff *clone, *skb = xmit_work->skb;\n\tstruct dsa_switch *ds = xmit_work->dp->ds;\n\tstruct ksz_device *dev = ds->priv;\n\tstruct ksz_port *prt;\n\n\tprt = &dev->ports[xmit_work->dp->index];\n\n\tclone = KSZ_SKB_CB(skb)->clone;\n\n\tskb_shinfo(clone)->tx_flags |= SKBTX_IN_PROGRESS;\n\n\treinit_completion(&prt->tstamp_msg_comp);\n\n\tdsa_enqueue_skb(skb, skb->dev);\n\n\tksz_ptp_txtstamp_skb(dev, prt, clone);\n\n\tkfree(xmit_work);\n}\n\nstatic int _ksz_ptp_gettime(struct ksz_device *dev, struct timespec64 *ts)\n{\n\tu32 nanoseconds;\n\tu32 seconds;\n\tu8 phase;\n\tint ret;\n\n\t \n\tret = ksz_rmw16(dev, REG_PTP_CLK_CTRL, PTP_READ_TIME, PTP_READ_TIME);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ksz_read8(dev, REG_PTP_RTC_SUB_NANOSEC__2, &phase);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ksz_read32(dev, REG_PTP_RTC_NANOSEC, &nanoseconds);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ksz_read32(dev, REG_PTP_RTC_SEC, &seconds);\n\tif (ret)\n\t\treturn ret;\n\n\tts->tv_sec = seconds;\n\tts->tv_nsec = nanoseconds + phase * 8;\n\n\treturn 0;\n}\n\nstatic int ksz_ptp_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\n{\n\tstruct ksz_ptp_data *ptp_data = ptp_caps_to_data(ptp);\n\tstruct ksz_device *dev = ptp_data_to_ksz_dev(ptp_data);\n\tint ret;\n\n\tmutex_lock(&ptp_data->lock);\n\tret = _ksz_ptp_gettime(dev, ts);\n\tmutex_unlock(&ptp_data->lock);\n\n\treturn ret;\n}\n\nstatic int ksz_ptp_restart_perout(struct ksz_device *dev)\n{\n\tstruct ksz_ptp_data *ptp_data = &dev->ptp_data;\n\ts64 now_ns, first_ns, period_ns, next_ns;\n\tstruct ptp_perout_request request;\n\tstruct timespec64 next;\n\tstruct timespec64 now;\n\tunsigned int count;\n\tint ret;\n\n\tdev_info(dev->dev, \"Restarting periodic output signal\\n\");\n\n\tret = _ksz_ptp_gettime(dev, &now);\n\tif (ret)\n\t\treturn ret;\n\n\tnow_ns = timespec64_to_ns(&now);\n\tfirst_ns = timespec64_to_ns(&ptp_data->perout_target_time_first);\n\n\t \n\tperiod_ns = timespec64_to_ns(&ptp_data->perout_period);\n\n\tif (first_ns < now_ns) {\n\t\tcount = div_u64(now_ns - first_ns, period_ns);\n\t\tnext_ns = first_ns + count * period_ns;\n\t} else {\n\t\tnext_ns = first_ns;\n\t}\n\n\t \n\twhile (next_ns < now_ns + 100000000)\n\t\tnext_ns += period_ns;\n\n\t \n\tnext = ns_to_timespec64(next_ns);\n\trequest.start.sec  = next.tv_sec;\n\trequest.start.nsec = next.tv_nsec;\n\trequest.period.sec  = ptp_data->perout_period.tv_sec;\n\trequest.period.nsec = ptp_data->perout_period.tv_nsec;\n\trequest.index = 0;\n\trequest.flags = 0;\n\n\treturn ksz_ptp_enable_perout(dev, &request, 1);\n}\n\nstatic int ksz_ptp_settime(struct ptp_clock_info *ptp,\n\t\t\t   const struct timespec64 *ts)\n{\n\tstruct ksz_ptp_data *ptp_data = ptp_caps_to_data(ptp);\n\tstruct ksz_device *dev = ptp_data_to_ksz_dev(ptp_data);\n\tint ret;\n\n\tmutex_lock(&ptp_data->lock);\n\n\t \n\tret = ksz_write16(dev, REG_PTP_RTC_SUB_NANOSEC__2, PTP_RTC_0NS);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = ksz_write32(dev, REG_PTP_RTC_NANOSEC, ts->tv_nsec);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = ksz_write32(dev, REG_PTP_RTC_SEC, ts->tv_sec);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = ksz_rmw16(dev, REG_PTP_CLK_CTRL, PTP_LOAD_TIME, PTP_LOAD_TIME);\n\tif (ret)\n\t\tgoto unlock;\n\n\tswitch (ptp_data->tou_mode) {\n\tcase KSZ_PTP_TOU_IDLE:\n\t\tbreak;\n\n\tcase KSZ_PTP_TOU_PEROUT:\n\t\tret = ksz_ptp_restart_perout(dev);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\n\t\tbreak;\n\t}\n\n\tspin_lock_bh(&ptp_data->clock_lock);\n\tptp_data->clock_time = *ts;\n\tspin_unlock_bh(&ptp_data->clock_lock);\n\nunlock:\n\tmutex_unlock(&ptp_data->lock);\n\n\treturn ret;\n}\n\nstatic int ksz_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct ksz_ptp_data *ptp_data = ptp_caps_to_data(ptp);\n\tstruct ksz_device *dev = ptp_data_to_ksz_dev(ptp_data);\n\tu64 base, adj;\n\tbool negative;\n\tu32 data32;\n\tint ret;\n\n\tmutex_lock(&ptp_data->lock);\n\n\tif (scaled_ppm) {\n\t\tbase = KSZ_PTP_INC_NS << KSZ_PTP_SUBNS_BITS;\n\t\tnegative = diff_by_scaled_ppm(base, scaled_ppm, &adj);\n\n\t\tdata32 = (u32)adj;\n\t\tdata32 &= PTP_SUBNANOSEC_M;\n\t\tif (!negative)\n\t\t\tdata32 |= PTP_RATE_DIR;\n\n\t\tret = ksz_write32(dev, REG_PTP_SUBNANOSEC_RATE, data32);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\n\t\tret = ksz_rmw16(dev, REG_PTP_CLK_CTRL, PTP_CLK_ADJ_ENABLE,\n\t\t\t\tPTP_CLK_ADJ_ENABLE);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t} else {\n\t\tret = ksz_rmw16(dev, REG_PTP_CLK_CTRL, PTP_CLK_ADJ_ENABLE, 0);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\nunlock:\n\tmutex_unlock(&ptp_data->lock);\n\treturn ret;\n}\n\nstatic int ksz_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct ksz_ptp_data *ptp_data = ptp_caps_to_data(ptp);\n\tstruct ksz_device *dev = ptp_data_to_ksz_dev(ptp_data);\n\tstruct timespec64 delta64 = ns_to_timespec64(delta);\n\ts32 sec, nsec;\n\tu16 data16;\n\tint ret;\n\n\tmutex_lock(&ptp_data->lock);\n\n\t \n\tsec = div_s64_rem(delta, NSEC_PER_SEC, &nsec);\n\n\tret = ksz_write32(dev, REG_PTP_RTC_NANOSEC, abs(nsec));\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = ksz_write32(dev, REG_PTP_RTC_SEC, abs(sec));\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = ksz_read16(dev, REG_PTP_CLK_CTRL, &data16);\n\tif (ret)\n\t\tgoto unlock;\n\n\tdata16 |= PTP_STEP_ADJ;\n\n\t \n\tif (delta < 0)\n\t\tdata16 &= ~PTP_STEP_DIR;\n\telse\n\t\tdata16 |= PTP_STEP_DIR;\n\n\tret = ksz_write16(dev, REG_PTP_CLK_CTRL, data16);\n\tif (ret)\n\t\tgoto unlock;\n\n\tswitch (ptp_data->tou_mode) {\n\tcase KSZ_PTP_TOU_IDLE:\n\t\tbreak;\n\n\tcase KSZ_PTP_TOU_PEROUT:\n\t\tret = ksz_ptp_restart_perout(dev);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\n\t\tbreak;\n\t}\n\n\tspin_lock_bh(&ptp_data->clock_lock);\n\tptp_data->clock_time = timespec64_add(ptp_data->clock_time, delta64);\n\tspin_unlock_bh(&ptp_data->clock_lock);\n\nunlock:\n\tmutex_unlock(&ptp_data->lock);\n\treturn ret;\n}\n\nstatic int ksz_ptp_enable(struct ptp_clock_info *ptp,\n\t\t\t  struct ptp_clock_request *req, int on)\n{\n\tstruct ksz_ptp_data *ptp_data = ptp_caps_to_data(ptp);\n\tstruct ksz_device *dev = ptp_data_to_ksz_dev(ptp_data);\n\tint ret;\n\n\tswitch (req->type) {\n\tcase PTP_CLK_REQ_PEROUT:\n\t\tmutex_lock(&ptp_data->lock);\n\t\tret = ksz_ptp_enable_perout(dev, &req->perout, on);\n\t\tmutex_unlock(&ptp_data->lock);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstatic int ksz_ptp_verify_pin(struct ptp_clock_info *ptp, unsigned int pin,\n\t\t\t      enum ptp_pin_function func, unsigned int chan)\n{\n\tint ret = 0;\n\n\tswitch (func) {\n\tcase PTP_PF_NONE:\n\tcase PTP_PF_PEROUT:\n\t\tbreak;\n\tdefault:\n\t\tret = -1;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic long ksz_ptp_do_aux_work(struct ptp_clock_info *ptp)\n{\n\tstruct ksz_ptp_data *ptp_data = ptp_caps_to_data(ptp);\n\tstruct ksz_device *dev = ptp_data_to_ksz_dev(ptp_data);\n\tstruct timespec64 ts;\n\tint ret;\n\n\tmutex_lock(&ptp_data->lock);\n\tret = _ksz_ptp_gettime(dev, &ts);\n\tif (ret)\n\t\tgoto out;\n\n\tspin_lock_bh(&ptp_data->clock_lock);\n\tptp_data->clock_time = ts;\n\tspin_unlock_bh(&ptp_data->clock_lock);\n\nout:\n\tmutex_unlock(&ptp_data->lock);\n\n\treturn HZ;   \n}\n\nstatic int ksz_ptp_start_clock(struct ksz_device *dev)\n{\n\tstruct ksz_ptp_data *ptp_data = &dev->ptp_data;\n\tint ret;\n\n\tret = ksz_rmw16(dev, REG_PTP_CLK_CTRL, PTP_CLK_ENABLE, PTP_CLK_ENABLE);\n\tif (ret)\n\t\treturn ret;\n\n\tptp_data->clock_time.tv_sec = 0;\n\tptp_data->clock_time.tv_nsec = 0;\n\n\treturn 0;\n}\n\nint ksz_ptp_clock_register(struct dsa_switch *ds)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tstruct ksz_ptp_data *ptp_data;\n\tint ret;\n\tu8 i;\n\n\tptp_data = &dev->ptp_data;\n\tmutex_init(&ptp_data->lock);\n\tspin_lock_init(&ptp_data->clock_lock);\n\n\tptp_data->caps.owner\t\t= THIS_MODULE;\n\tsnprintf(ptp_data->caps.name, 16, \"Microchip Clock\");\n\tptp_data->caps.max_adj\t\t= KSZ_MAX_DRIFT_CORR;\n\tptp_data->caps.gettime64\t= ksz_ptp_gettime;\n\tptp_data->caps.settime64\t= ksz_ptp_settime;\n\tptp_data->caps.adjfine\t\t= ksz_ptp_adjfine;\n\tptp_data->caps.adjtime\t\t= ksz_ptp_adjtime;\n\tptp_data->caps.do_aux_work\t= ksz_ptp_do_aux_work;\n\tptp_data->caps.enable\t\t= ksz_ptp_enable;\n\tptp_data->caps.verify\t\t= ksz_ptp_verify_pin;\n\tptp_data->caps.n_pins\t\t= KSZ_PTP_N_GPIO;\n\tptp_data->caps.n_per_out\t= 3;\n\n\tret = ksz_ptp_start_clock(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < KSZ_PTP_N_GPIO; i++) {\n\t\tstruct ptp_pin_desc *ptp_pin = &ptp_data->pin_config[i];\n\n\t\tsnprintf(ptp_pin->name,\n\t\t\t sizeof(ptp_pin->name), \"ksz_ptp_pin_%02d\", i);\n\t\tptp_pin->index = i;\n\t\tptp_pin->func = PTP_PF_NONE;\n\t}\n\n\tptp_data->caps.pin_config = ptp_data->pin_config;\n\n\t \n\tret = ksz_rmw16(dev, REG_PTP_MSG_CONF1, PTP_TC_P2P | PTP_802_1AS,\n\t\t\tPTP_TC_P2P | PTP_802_1AS);\n\tif (ret)\n\t\treturn ret;\n\n\tptp_data->clock = ptp_clock_register(&ptp_data->caps, dev->dev);\n\tif (IS_ERR_OR_NULL(ptp_data->clock))\n\t\treturn PTR_ERR(ptp_data->clock);\n\n\treturn 0;\n}\n\nvoid ksz_ptp_clock_unregister(struct dsa_switch *ds)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tstruct ksz_ptp_data *ptp_data;\n\n\tptp_data = &dev->ptp_data;\n\n\tif (ptp_data->clock)\n\t\tptp_clock_unregister(ptp_data->clock);\n}\n\nstatic irqreturn_t ksz_ptp_msg_thread_fn(int irq, void *dev_id)\n{\n\tstruct ksz_ptp_irq *ptpmsg_irq = dev_id;\n\tstruct ksz_device *dev;\n\tstruct ksz_port *port;\n\tu32 tstamp_raw;\n\tktime_t tstamp;\n\tint ret;\n\n\tport = ptpmsg_irq->port;\n\tdev = port->ksz_dev;\n\n\tif (ptpmsg_irq->ts_en) {\n\t\tret = ksz_read32(dev, ptpmsg_irq->ts_reg, &tstamp_raw);\n\t\tif (ret)\n\t\t\treturn IRQ_NONE;\n\n\t\ttstamp = ksz_decode_tstamp(tstamp_raw);\n\n\t\tport->tstamp_msg = ksz_tstamp_reconstruct(dev, tstamp);\n\n\t\tcomplete(&port->tstamp_msg_comp);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t ksz_ptp_irq_thread_fn(int irq, void *dev_id)\n{\n\tstruct ksz_irq *ptpirq = dev_id;\n\tunsigned int nhandled = 0;\n\tstruct ksz_device *dev;\n\tunsigned int sub_irq;\n\tu16 data;\n\tint ret;\n\tu8 n;\n\n\tdev = ptpirq->dev;\n\n\tret = ksz_read16(dev, ptpirq->reg_status, &data);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = ksz_write16(dev, ptpirq->reg_status, data);\n\tif (ret)\n\t\treturn IRQ_NONE;\n\n\tfor (n = 0; n < ptpirq->nirqs; ++n) {\n\t\tif (data & BIT(n + KSZ_PTP_INT_START)) {\n\t\t\tsub_irq = irq_find_mapping(ptpirq->domain, n);\n\t\t\thandle_nested_irq(sub_irq);\n\t\t\t++nhandled;\n\t\t}\n\t}\n\nout:\n\treturn (nhandled > 0 ? IRQ_HANDLED : IRQ_NONE);\n}\n\nstatic void ksz_ptp_irq_mask(struct irq_data *d)\n{\n\tstruct ksz_irq *kirq = irq_data_get_irq_chip_data(d);\n\n\tkirq->masked &= ~BIT(d->hwirq + KSZ_PTP_INT_START);\n}\n\nstatic void ksz_ptp_irq_unmask(struct irq_data *d)\n{\n\tstruct ksz_irq *kirq = irq_data_get_irq_chip_data(d);\n\n\tkirq->masked |= BIT(d->hwirq + KSZ_PTP_INT_START);\n}\n\nstatic void ksz_ptp_irq_bus_lock(struct irq_data *d)\n{\n\tstruct ksz_irq *kirq  = irq_data_get_irq_chip_data(d);\n\n\tmutex_lock(&kirq->dev->lock_irq);\n}\n\nstatic void ksz_ptp_irq_bus_sync_unlock(struct irq_data *d)\n{\n\tstruct ksz_irq *kirq  = irq_data_get_irq_chip_data(d);\n\tstruct ksz_device *dev = kirq->dev;\n\tint ret;\n\n\tret = ksz_write16(dev, kirq->reg_mask, kirq->masked);\n\tif (ret)\n\t\tdev_err(dev->dev, \"failed to change IRQ mask\\n\");\n\n\tmutex_unlock(&dev->lock_irq);\n}\n\nstatic const struct irq_chip ksz_ptp_irq_chip = {\n\t.name\t\t\t= \"ksz-irq\",\n\t.irq_mask\t\t= ksz_ptp_irq_mask,\n\t.irq_unmask\t\t= ksz_ptp_irq_unmask,\n\t.irq_bus_lock\t\t= ksz_ptp_irq_bus_lock,\n\t.irq_bus_sync_unlock\t= ksz_ptp_irq_bus_sync_unlock,\n};\n\nstatic int ksz_ptp_irq_domain_map(struct irq_domain *d,\n\t\t\t\t  unsigned int irq, irq_hw_number_t hwirq)\n{\n\tirq_set_chip_data(irq, d->host_data);\n\tirq_set_chip_and_handler(irq, &ksz_ptp_irq_chip, handle_level_irq);\n\tirq_set_noprobe(irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops ksz_ptp_irq_domain_ops = {\n\t.map\t= ksz_ptp_irq_domain_map,\n\t.xlate\t= irq_domain_xlate_twocell,\n};\n\nstatic void ksz_ptp_msg_irq_free(struct ksz_port *port, u8 n)\n{\n\tstruct ksz_ptp_irq *ptpmsg_irq;\n\n\tptpmsg_irq = &port->ptpmsg_irq[n];\n\n\tfree_irq(ptpmsg_irq->num, ptpmsg_irq);\n\tirq_dispose_mapping(ptpmsg_irq->num);\n}\n\nstatic int ksz_ptp_msg_irq_setup(struct ksz_port *port, u8 n)\n{\n\tu16 ts_reg[] = {REG_PTP_PORT_PDRESP_TS, REG_PTP_PORT_XDELAY_TS,\n\t\t\tREG_PTP_PORT_SYNC_TS};\n\tstatic const char * const name[] = {\"pdresp-msg\", \"xdreq-msg\",\n\t\t\t\t\t    \"sync-msg\"};\n\tconst struct ksz_dev_ops *ops = port->ksz_dev->dev_ops;\n\tstruct ksz_ptp_irq *ptpmsg_irq;\n\n\tptpmsg_irq = &port->ptpmsg_irq[n];\n\n\tptpmsg_irq->port = port;\n\tptpmsg_irq->ts_reg = ops->get_port_addr(port->num, ts_reg[n]);\n\n\tsnprintf(ptpmsg_irq->name, sizeof(ptpmsg_irq->name), name[n]);\n\n\tptpmsg_irq->num = irq_find_mapping(port->ptpirq.domain, n);\n\tif (ptpmsg_irq->num < 0)\n\t\treturn ptpmsg_irq->num;\n\n\treturn request_threaded_irq(ptpmsg_irq->num, NULL,\n\t\t\t\t    ksz_ptp_msg_thread_fn, IRQF_ONESHOT,\n\t\t\t\t    ptpmsg_irq->name, ptpmsg_irq);\n}\n\nint ksz_ptp_irq_setup(struct dsa_switch *ds, u8 p)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tconst struct ksz_dev_ops *ops = dev->dev_ops;\n\tstruct ksz_port *port = &dev->ports[p];\n\tstruct ksz_irq *ptpirq = &port->ptpirq;\n\tint irq;\n\tint ret;\n\n\tptpirq->dev = dev;\n\tptpirq->masked = 0;\n\tptpirq->nirqs = 3;\n\tptpirq->reg_mask = ops->get_port_addr(p, REG_PTP_PORT_TX_INT_ENABLE__2);\n\tptpirq->reg_status = ops->get_port_addr(p,\n\t\t\t\t\t\tREG_PTP_PORT_TX_INT_STATUS__2);\n\tsnprintf(ptpirq->name, sizeof(ptpirq->name), \"ptp-irq-%d\", p);\n\n\tinit_completion(&port->tstamp_msg_comp);\n\n\tptpirq->domain = irq_domain_add_linear(dev->dev->of_node, ptpirq->nirqs,\n\t\t\t\t\t       &ksz_ptp_irq_domain_ops, ptpirq);\n\tif (!ptpirq->domain)\n\t\treturn -ENOMEM;\n\n\tfor (irq = 0; irq < ptpirq->nirqs; irq++)\n\t\tirq_create_mapping(ptpirq->domain, irq);\n\n\tptpirq->irq_num = irq_find_mapping(port->pirq.domain, PORT_SRC_PTP_INT);\n\tif (ptpirq->irq_num < 0) {\n\t\tret = ptpirq->irq_num;\n\t\tgoto out;\n\t}\n\n\tret = request_threaded_irq(ptpirq->irq_num, NULL, ksz_ptp_irq_thread_fn,\n\t\t\t\t   IRQF_ONESHOT, ptpirq->name, ptpirq);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (irq = 0; irq < ptpirq->nirqs; irq++) {\n\t\tret = ksz_ptp_msg_irq_setup(port, irq);\n\t\tif (ret)\n\t\t\tgoto out_ptp_msg;\n\t}\n\n\treturn 0;\n\nout_ptp_msg:\n\tfree_irq(ptpirq->irq_num, ptpirq);\n\twhile (irq--)\n\t\tfree_irq(port->ptpmsg_irq[irq].num, &port->ptpmsg_irq[irq]);\nout:\n\tfor (irq = 0; irq < ptpirq->nirqs; irq++)\n\t\tirq_dispose_mapping(port->ptpmsg_irq[irq].num);\n\n\tirq_domain_remove(ptpirq->domain);\n\n\treturn ret;\n}\n\nvoid ksz_ptp_irq_free(struct dsa_switch *ds, u8 p)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tstruct ksz_port *port = &dev->ports[p];\n\tstruct ksz_irq *ptpirq = &port->ptpirq;\n\tu8 n;\n\n\tfor (n = 0; n < ptpirq->nirqs; n++)\n\t\tksz_ptp_msg_irq_free(port, n);\n\n\tfree_irq(ptpirq->irq_num, ptpirq);\n\tirq_dispose_mapping(ptpirq->irq_num);\n\n\tirq_domain_remove(ptpirq->domain);\n}\n\nMODULE_AUTHOR(\"Christian Eggers <ceggers@arri.de>\");\nMODULE_AUTHOR(\"Arun Ramadoss <arun.ramadoss@microchip.com>\");\nMODULE_DESCRIPTION(\"PTP support for KSZ switch\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}