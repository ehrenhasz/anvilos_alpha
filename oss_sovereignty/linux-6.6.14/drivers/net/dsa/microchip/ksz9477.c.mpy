{
  "module_name": "ksz9477.c",
  "hash_id": "df2d4277bada67918b4af731ce6df1b9578ea415d81e706413a6792b0a57f436",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/microchip/ksz9477.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/iopoll.h>\n#include <linux/platform_data/microchip-ksz.h>\n#include <linux/phy.h>\n#include <linux/if_bridge.h>\n#include <linux/if_vlan.h>\n#include <net/dsa.h>\n#include <net/switchdev.h>\n\n#include \"ksz9477_reg.h\"\n#include \"ksz_common.h\"\n#include \"ksz9477.h\"\n\nstatic void ksz_cfg(struct ksz_device *dev, u32 addr, u8 bits, bool set)\n{\n\tregmap_update_bits(ksz_regmap_8(dev), addr, bits, set ? bits : 0);\n}\n\nstatic void ksz_port_cfg(struct ksz_device *dev, int port, int offset, u8 bits,\n\t\t\t bool set)\n{\n\tregmap_update_bits(ksz_regmap_8(dev), PORT_CTRL_ADDR(port, offset),\n\t\t\t   bits, set ? bits : 0);\n}\n\nstatic void ksz9477_cfg32(struct ksz_device *dev, u32 addr, u32 bits, bool set)\n{\n\tregmap_update_bits(ksz_regmap_32(dev), addr, bits, set ? bits : 0);\n}\n\nstatic void ksz9477_port_cfg32(struct ksz_device *dev, int port, int offset,\n\t\t\t       u32 bits, bool set)\n{\n\tregmap_update_bits(ksz_regmap_32(dev), PORT_CTRL_ADDR(port, offset),\n\t\t\t   bits, set ? bits : 0);\n}\n\nint ksz9477_change_mtu(struct ksz_device *dev, int port, int mtu)\n{\n\tu16 frame_size;\n\n\tif (!dsa_is_cpu_port(dev->ds, port))\n\t\treturn 0;\n\n\tframe_size = mtu + VLAN_ETH_HLEN + ETH_FCS_LEN;\n\n\treturn regmap_update_bits(ksz_regmap_16(dev), REG_SW_MTU__2,\n\t\t\t\t  REG_SW_MTU_MASK, frame_size);\n}\n\nstatic int ksz9477_wait_vlan_ctrl_ready(struct ksz_device *dev)\n{\n\tunsigned int val;\n\n\treturn regmap_read_poll_timeout(ksz_regmap_8(dev), REG_SW_VLAN_CTRL,\n\t\t\t\t\tval, !(val & VLAN_START), 10, 1000);\n}\n\nstatic int ksz9477_get_vlan_table(struct ksz_device *dev, u16 vid,\n\t\t\t\t  u32 *vlan_table)\n{\n\tint ret;\n\n\tmutex_lock(&dev->vlan_mutex);\n\n\tksz_write16(dev, REG_SW_VLAN_ENTRY_INDEX__2, vid & VLAN_INDEX_M);\n\tksz_write8(dev, REG_SW_VLAN_CTRL, VLAN_READ | VLAN_START);\n\n\t \n\tret = ksz9477_wait_vlan_ctrl_ready(dev);\n\tif (ret) {\n\t\tdev_dbg(dev->dev, \"Failed to read vlan table\\n\");\n\t\tgoto exit;\n\t}\n\n\tksz_read32(dev, REG_SW_VLAN_ENTRY__4, &vlan_table[0]);\n\tksz_read32(dev, REG_SW_VLAN_ENTRY_UNTAG__4, &vlan_table[1]);\n\tksz_read32(dev, REG_SW_VLAN_ENTRY_PORTS__4, &vlan_table[2]);\n\n\tksz_write8(dev, REG_SW_VLAN_CTRL, 0);\n\nexit:\n\tmutex_unlock(&dev->vlan_mutex);\n\n\treturn ret;\n}\n\nstatic int ksz9477_set_vlan_table(struct ksz_device *dev, u16 vid,\n\t\t\t\t  u32 *vlan_table)\n{\n\tint ret;\n\n\tmutex_lock(&dev->vlan_mutex);\n\n\tksz_write32(dev, REG_SW_VLAN_ENTRY__4, vlan_table[0]);\n\tksz_write32(dev, REG_SW_VLAN_ENTRY_UNTAG__4, vlan_table[1]);\n\tksz_write32(dev, REG_SW_VLAN_ENTRY_PORTS__4, vlan_table[2]);\n\n\tksz_write16(dev, REG_SW_VLAN_ENTRY_INDEX__2, vid & VLAN_INDEX_M);\n\tksz_write8(dev, REG_SW_VLAN_CTRL, VLAN_START | VLAN_WRITE);\n\n\t \n\tret = ksz9477_wait_vlan_ctrl_ready(dev);\n\tif (ret) {\n\t\tdev_dbg(dev->dev, \"Failed to write vlan table\\n\");\n\t\tgoto exit;\n\t}\n\n\tksz_write8(dev, REG_SW_VLAN_CTRL, 0);\n\n\t \n\tdev->vlan_cache[vid].table[0] = vlan_table[0];\n\tdev->vlan_cache[vid].table[1] = vlan_table[1];\n\tdev->vlan_cache[vid].table[2] = vlan_table[2];\n\nexit:\n\tmutex_unlock(&dev->vlan_mutex);\n\n\treturn ret;\n}\n\nstatic void ksz9477_read_table(struct ksz_device *dev, u32 *table)\n{\n\tksz_read32(dev, REG_SW_ALU_VAL_A, &table[0]);\n\tksz_read32(dev, REG_SW_ALU_VAL_B, &table[1]);\n\tksz_read32(dev, REG_SW_ALU_VAL_C, &table[2]);\n\tksz_read32(dev, REG_SW_ALU_VAL_D, &table[3]);\n}\n\nstatic void ksz9477_write_table(struct ksz_device *dev, u32 *table)\n{\n\tksz_write32(dev, REG_SW_ALU_VAL_A, table[0]);\n\tksz_write32(dev, REG_SW_ALU_VAL_B, table[1]);\n\tksz_write32(dev, REG_SW_ALU_VAL_C, table[2]);\n\tksz_write32(dev, REG_SW_ALU_VAL_D, table[3]);\n}\n\nstatic int ksz9477_wait_alu_ready(struct ksz_device *dev)\n{\n\tunsigned int val;\n\n\treturn regmap_read_poll_timeout(ksz_regmap_32(dev), REG_SW_ALU_CTRL__4,\n\t\t\t\t\tval, !(val & ALU_START), 10, 1000);\n}\n\nstatic int ksz9477_wait_alu_sta_ready(struct ksz_device *dev)\n{\n\tunsigned int val;\n\n\treturn regmap_read_poll_timeout(ksz_regmap_32(dev),\n\t\t\t\t\tREG_SW_ALU_STAT_CTRL__4,\n\t\t\t\t\tval, !(val & ALU_STAT_START),\n\t\t\t\t\t10, 1000);\n}\n\nint ksz9477_reset_switch(struct ksz_device *dev)\n{\n\tu8 data8;\n\tu32 data32;\n\n\t \n\tksz_cfg(dev, REG_SW_OPERATION, SW_RESET, true);\n\n\t \n\tregmap_update_bits(ksz_regmap_8(dev), REG_SW_GLOBAL_SERIAL_CTRL_0,\n\t\t\t   SPI_AUTO_EDGE_DETECTION, 0);\n\n\t \n\tksz_read8(dev, REG_SW_LUE_CTRL_1, &data8);\n\tdata8 = SW_AGING_ENABLE | SW_LINK_AUTO_AGING |\n\t      SW_SRC_ADDR_FILTER | SW_FLUSH_STP_TABLE | SW_FLUSH_MSTP_TABLE;\n\tksz_write8(dev, REG_SW_LUE_CTRL_1, data8);\n\n\t \n\tksz_write32(dev, REG_SW_INT_MASK__4, SWITCH_INT_MASK);\n\tksz_write32(dev, REG_SW_PORT_INT_MASK__4, 0x7F);\n\tksz_read32(dev, REG_SW_PORT_INT_STATUS__4, &data32);\n\n\t \n\tif (dev->chip_id == KSZ9893_CHIP_ID ||\n\t    dev->chip_id == KSZ8563_CHIP_ID ||\n\t    dev->chip_id == KSZ9563_CHIP_ID)\n\t\treturn 0;\n\n\tdata8 = SW_ENABLE_REFCLKO;\n\tif (dev->synclko_disable)\n\t\tdata8 = 0;\n\telse if (dev->synclko_125)\n\t\tdata8 = SW_ENABLE_REFCLKO | SW_REFCLKO_IS_125MHZ;\n\tksz_write8(dev, REG_SW_GLOBAL_OUTPUT_CTRL__1, data8);\n\n\treturn 0;\n}\n\nvoid ksz9477_r_mib_cnt(struct ksz_device *dev, int port, u16 addr, u64 *cnt)\n{\n\tstruct ksz_port *p = &dev->ports[port];\n\tunsigned int val;\n\tu32 data;\n\tint ret;\n\n\t \n\tdata = p->freeze ? MIB_COUNTER_FLUSH_FREEZE : 0;\n\tdata |= MIB_COUNTER_READ;\n\tdata |= (addr << MIB_COUNTER_INDEX_S);\n\tksz_pwrite32(dev, port, REG_PORT_MIB_CTRL_STAT__4, data);\n\n\tret = regmap_read_poll_timeout(ksz_regmap_32(dev),\n\t\t\tPORT_CTRL_ADDR(port, REG_PORT_MIB_CTRL_STAT__4),\n\t\t\tval, !(val & MIB_COUNTER_READ), 10, 1000);\n\t \n\tif (ret) {\n\t\tdev_dbg(dev->dev, \"Failed to get MIB\\n\");\n\t\treturn;\n\t}\n\n\t \n\tksz_pread32(dev, port, REG_PORT_MIB_DATA, &data);\n\t*cnt += data;\n}\n\nvoid ksz9477_r_mib_pkt(struct ksz_device *dev, int port, u16 addr,\n\t\t       u64 *dropped, u64 *cnt)\n{\n\taddr = dev->info->mib_names[addr].index;\n\tksz9477_r_mib_cnt(dev, port, addr, cnt);\n}\n\nvoid ksz9477_freeze_mib(struct ksz_device *dev, int port, bool freeze)\n{\n\tu32 val = freeze ? MIB_COUNTER_FLUSH_FREEZE : 0;\n\tstruct ksz_port *p = &dev->ports[port];\n\n\t \n\tmutex_lock(&p->mib.cnt_mutex);\n\tksz_pwrite32(dev, port, REG_PORT_MIB_CTRL_STAT__4, val);\n\n\t \n\tp->freeze = freeze;\n\tmutex_unlock(&p->mib.cnt_mutex);\n}\n\nvoid ksz9477_port_init_cnt(struct ksz_device *dev, int port)\n{\n\tstruct ksz_port_mib *mib = &dev->ports[port].mib;\n\n\t \n\tmutex_lock(&mib->cnt_mutex);\n\tksz_pwrite32(dev, port, REG_PORT_MIB_CTRL_STAT__4,\n\t\t     MIB_COUNTER_FLUSH_FREEZE);\n\tksz_write8(dev, REG_SW_MAC_CTRL_6, SW_MIB_COUNTER_FLUSH);\n\tksz_pwrite32(dev, port, REG_PORT_MIB_CTRL_STAT__4, 0);\n\tmutex_unlock(&mib->cnt_mutex);\n}\n\nstatic void ksz9477_r_phy_quirks(struct ksz_device *dev, u16 addr, u16 reg,\n\t\t\t\t u16 *data)\n{\n\t \n\tif (dev->chip_id == KSZ8563_CHIP_ID && reg == MII_BMSR)\n\t\t*data &= ~(BMSR_ESTATEN | BMSR_ERCAP);\n}\n\nint ksz9477_r_phy(struct ksz_device *dev, u16 addr, u16 reg, u16 *data)\n{\n\tu16 val = 0xffff;\n\tint ret;\n\n\t \n\tif (!dev->info->internal_phy[addr]) {\n\t\tstruct ksz_port *p = &dev->ports[addr];\n\n\t\tswitch (reg) {\n\t\tcase MII_BMCR:\n\t\t\tval = 0x1140;\n\t\t\tbreak;\n\t\tcase MII_BMSR:\n\t\t\tval = 0x796d;\n\t\t\tbreak;\n\t\tcase MII_PHYSID1:\n\t\t\tval = 0x0022;\n\t\t\tbreak;\n\t\tcase MII_PHYSID2:\n\t\t\tval = 0x1631;\n\t\t\tbreak;\n\t\tcase MII_ADVERTISE:\n\t\t\tval = 0x05e1;\n\t\t\tbreak;\n\t\tcase MII_LPA:\n\t\t\tval = 0xc5e1;\n\t\t\tbreak;\n\t\tcase MII_CTRL1000:\n\t\t\tval = 0x0700;\n\t\t\tbreak;\n\t\tcase MII_STAT1000:\n\t\t\tif (p->phydev.speed == SPEED_1000)\n\t\t\t\tval = 0x3800;\n\t\t\telse\n\t\t\t\tval = 0;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tret = ksz_pread16(dev, addr, 0x100 + (reg << 1), &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tksz9477_r_phy_quirks(dev, addr, reg, &val);\n\t}\n\n\t*data = val;\n\n\treturn 0;\n}\n\nint ksz9477_w_phy(struct ksz_device *dev, u16 addr, u16 reg, u16 val)\n{\n\tu32 mask, val32;\n\n\t \n\tif (!dev->info->internal_phy[addr])\n\t\treturn 0;\n\n\tif (reg < 0x10)\n\t\treturn ksz_pwrite16(dev, addr, 0x100 + (reg << 1), val);\n\n\t \n\tval32 = val;\n\tmask = 0xffff;\n\tif ((reg & 1) == 0) {\n\t\tval32 <<= 16;\n\t\tmask <<= 16;\n\t}\n\treg &= ~1;\n\treturn ksz_prmw32(dev, addr, 0x100 + (reg << 1), mask, val32);\n}\n\nvoid ksz9477_cfg_port_member(struct ksz_device *dev, int port, u8 member)\n{\n\tksz_pwrite32(dev, port, REG_PORT_VLAN_MEMBERSHIP__4, member);\n}\n\nvoid ksz9477_flush_dyn_mac_table(struct ksz_device *dev, int port)\n{\n\tconst u16 *regs = dev->info->regs;\n\tu8 data;\n\n\tregmap_update_bits(ksz_regmap_8(dev), REG_SW_LUE_CTRL_2,\n\t\t\t   SW_FLUSH_OPTION_M << SW_FLUSH_OPTION_S,\n\t\t\t   SW_FLUSH_OPTION_DYN_MAC << SW_FLUSH_OPTION_S);\n\n\tif (port < dev->info->port_cnt) {\n\t\t \n\t\tksz_pread8(dev, port, regs[P_STP_CTRL], &data);\n\t\tif (!(data & PORT_LEARN_DISABLE))\n\t\t\tksz_pwrite8(dev, port, regs[P_STP_CTRL],\n\t\t\t\t    data | PORT_LEARN_DISABLE);\n\t\tksz_cfg(dev, S_FLUSH_TABLE_CTRL, SW_FLUSH_DYN_MAC_TABLE, true);\n\t\tksz_pwrite8(dev, port, regs[P_STP_CTRL], data);\n\t} else {\n\t\t \n\t\tksz_cfg(dev, S_FLUSH_TABLE_CTRL, SW_FLUSH_STP_TABLE, true);\n\t}\n}\n\nint ksz9477_port_vlan_filtering(struct ksz_device *dev, int port,\n\t\t\t\tbool flag, struct netlink_ext_ack *extack)\n{\n\tif (flag) {\n\t\tksz_port_cfg(dev, port, REG_PORT_LUE_CTRL,\n\t\t\t     PORT_VLAN_LOOKUP_VID_0, true);\n\t\tksz_cfg(dev, REG_SW_LUE_CTRL_0, SW_VLAN_ENABLE, true);\n\t} else {\n\t\tksz_cfg(dev, REG_SW_LUE_CTRL_0, SW_VLAN_ENABLE, false);\n\t\tksz_port_cfg(dev, port, REG_PORT_LUE_CTRL,\n\t\t\t     PORT_VLAN_LOOKUP_VID_0, false);\n\t}\n\n\treturn 0;\n}\n\nint ksz9477_port_vlan_add(struct ksz_device *dev, int port,\n\t\t\t  const struct switchdev_obj_port_vlan *vlan,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tu32 vlan_table[3];\n\tbool untagged = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;\n\tint err;\n\n\terr = ksz9477_get_vlan_table(dev, vlan->vid, vlan_table);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to get vlan table\");\n\t\treturn err;\n\t}\n\n\tvlan_table[0] = VLAN_VALID | (vlan->vid & VLAN_FID_M);\n\tif (untagged)\n\t\tvlan_table[1] |= BIT(port);\n\telse\n\t\tvlan_table[1] &= ~BIT(port);\n\tvlan_table[1] &= ~(BIT(dev->cpu_port));\n\n\tvlan_table[2] |= BIT(port) | BIT(dev->cpu_port);\n\n\terr = ksz9477_set_vlan_table(dev, vlan->vid, vlan_table);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to set vlan table\");\n\t\treturn err;\n\t}\n\n\t \n\tif (vlan->flags & BRIDGE_VLAN_INFO_PVID)\n\t\tksz_pwrite16(dev, port, REG_PORT_DEFAULT_VID, vlan->vid);\n\n\treturn 0;\n}\n\nint ksz9477_port_vlan_del(struct ksz_device *dev, int port,\n\t\t\t  const struct switchdev_obj_port_vlan *vlan)\n{\n\tbool untagged = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;\n\tu32 vlan_table[3];\n\tu16 pvid;\n\n\tksz_pread16(dev, port, REG_PORT_DEFAULT_VID, &pvid);\n\tpvid = pvid & 0xFFF;\n\n\tif (ksz9477_get_vlan_table(dev, vlan->vid, vlan_table)) {\n\t\tdev_dbg(dev->dev, \"Failed to get vlan table\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tvlan_table[2] &= ~BIT(port);\n\n\tif (pvid == vlan->vid)\n\t\tpvid = 1;\n\n\tif (untagged)\n\t\tvlan_table[1] &= ~BIT(port);\n\n\tif (ksz9477_set_vlan_table(dev, vlan->vid, vlan_table)) {\n\t\tdev_dbg(dev->dev, \"Failed to set vlan table\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tksz_pwrite16(dev, port, REG_PORT_DEFAULT_VID, pvid);\n\n\treturn 0;\n}\n\nint ksz9477_fdb_add(struct ksz_device *dev, int port,\n\t\t    const unsigned char *addr, u16 vid, struct dsa_db db)\n{\n\tu32 alu_table[4];\n\tu32 data;\n\tint ret = 0;\n\n\tmutex_lock(&dev->alu_mutex);\n\n\t \n\tdata = vid << ALU_FID_INDEX_S;\n\tdata |= ((addr[0] << 8) | addr[1]);\n\tksz_write32(dev, REG_SW_ALU_INDEX_0, data);\n\n\tdata = ((addr[2] << 24) | (addr[3] << 16));\n\tdata |= ((addr[4] << 8) | addr[5]);\n\tksz_write32(dev, REG_SW_ALU_INDEX_1, data);\n\n\t \n\tksz_write32(dev, REG_SW_ALU_CTRL__4, ALU_READ | ALU_START);\n\n\t \n\tret = ksz9477_wait_alu_ready(dev);\n\tif (ret) {\n\t\tdev_dbg(dev->dev, \"Failed to read ALU\\n\");\n\t\tgoto exit;\n\t}\n\n\t \n\tksz9477_read_table(dev, alu_table);\n\n\t \n\talu_table[0] = ALU_V_STATIC_VALID;\n\talu_table[1] |= BIT(port);\n\tif (vid)\n\t\talu_table[1] |= ALU_V_USE_FID;\n\talu_table[2] = (vid << ALU_V_FID_S);\n\talu_table[2] |= ((addr[0] << 8) | addr[1]);\n\talu_table[3] = ((addr[2] << 24) | (addr[3] << 16));\n\talu_table[3] |= ((addr[4] << 8) | addr[5]);\n\n\tksz9477_write_table(dev, alu_table);\n\n\tksz_write32(dev, REG_SW_ALU_CTRL__4, ALU_WRITE | ALU_START);\n\n\t \n\tret = ksz9477_wait_alu_ready(dev);\n\tif (ret)\n\t\tdev_dbg(dev->dev, \"Failed to write ALU\\n\");\n\nexit:\n\tmutex_unlock(&dev->alu_mutex);\n\n\treturn ret;\n}\n\nint ksz9477_fdb_del(struct ksz_device *dev, int port,\n\t\t    const unsigned char *addr, u16 vid, struct dsa_db db)\n{\n\tu32 alu_table[4];\n\tu32 data;\n\tint ret = 0;\n\n\tmutex_lock(&dev->alu_mutex);\n\n\t \n\tdata = vid << ALU_FID_INDEX_S;\n\tdata |= ((addr[0] << 8) | addr[1]);\n\tksz_write32(dev, REG_SW_ALU_INDEX_0, data);\n\n\tdata = ((addr[2] << 24) | (addr[3] << 16));\n\tdata |= ((addr[4] << 8) | addr[5]);\n\tksz_write32(dev, REG_SW_ALU_INDEX_1, data);\n\n\t \n\tksz_write32(dev, REG_SW_ALU_CTRL__4, ALU_READ | ALU_START);\n\n\t \n\tret = ksz9477_wait_alu_ready(dev);\n\tif (ret) {\n\t\tdev_dbg(dev->dev, \"Failed to read ALU\\n\");\n\t\tgoto exit;\n\t}\n\n\tksz_read32(dev, REG_SW_ALU_VAL_A, &alu_table[0]);\n\tif (alu_table[0] & ALU_V_STATIC_VALID) {\n\t\tksz_read32(dev, REG_SW_ALU_VAL_B, &alu_table[1]);\n\t\tksz_read32(dev, REG_SW_ALU_VAL_C, &alu_table[2]);\n\t\tksz_read32(dev, REG_SW_ALU_VAL_D, &alu_table[3]);\n\n\t\t \n\t\talu_table[1] &= ~BIT(port);\n\n\t\t \n\t\tif ((alu_table[1] & ALU_V_PORT_MAP) == 0) {\n\t\t\talu_table[0] = 0;\n\t\t\talu_table[1] = 0;\n\t\t\talu_table[2] = 0;\n\t\t\talu_table[3] = 0;\n\t\t}\n\t} else {\n\t\talu_table[0] = 0;\n\t\talu_table[1] = 0;\n\t\talu_table[2] = 0;\n\t\talu_table[3] = 0;\n\t}\n\n\tksz9477_write_table(dev, alu_table);\n\n\tksz_write32(dev, REG_SW_ALU_CTRL__4, ALU_WRITE | ALU_START);\n\n\t \n\tret = ksz9477_wait_alu_ready(dev);\n\tif (ret)\n\t\tdev_dbg(dev->dev, \"Failed to write ALU\\n\");\n\nexit:\n\tmutex_unlock(&dev->alu_mutex);\n\n\treturn ret;\n}\n\nstatic void ksz9477_convert_alu(struct alu_struct *alu, u32 *alu_table)\n{\n\talu->is_static = !!(alu_table[0] & ALU_V_STATIC_VALID);\n\talu->is_src_filter = !!(alu_table[0] & ALU_V_SRC_FILTER);\n\talu->is_dst_filter = !!(alu_table[0] & ALU_V_DST_FILTER);\n\talu->prio_age = (alu_table[0] >> ALU_V_PRIO_AGE_CNT_S) &\n\t\t\tALU_V_PRIO_AGE_CNT_M;\n\talu->mstp = alu_table[0] & ALU_V_MSTP_M;\n\n\talu->is_override = !!(alu_table[1] & ALU_V_OVERRIDE);\n\talu->is_use_fid = !!(alu_table[1] & ALU_V_USE_FID);\n\talu->port_forward = alu_table[1] & ALU_V_PORT_MAP;\n\n\talu->fid = (alu_table[2] >> ALU_V_FID_S) & ALU_V_FID_M;\n\n\talu->mac[0] = (alu_table[2] >> 8) & 0xFF;\n\talu->mac[1] = alu_table[2] & 0xFF;\n\talu->mac[2] = (alu_table[3] >> 24) & 0xFF;\n\talu->mac[3] = (alu_table[3] >> 16) & 0xFF;\n\talu->mac[4] = (alu_table[3] >> 8) & 0xFF;\n\talu->mac[5] = alu_table[3] & 0xFF;\n}\n\nint ksz9477_fdb_dump(struct ksz_device *dev, int port,\n\t\t     dsa_fdb_dump_cb_t *cb, void *data)\n{\n\tint ret = 0;\n\tu32 ksz_data;\n\tu32 alu_table[4];\n\tstruct alu_struct alu;\n\tint timeout;\n\n\tmutex_lock(&dev->alu_mutex);\n\n\t \n\tksz_write32(dev, REG_SW_ALU_CTRL__4, ALU_START | ALU_SEARCH);\n\n\tdo {\n\t\ttimeout = 1000;\n\t\tdo {\n\t\t\tksz_read32(dev, REG_SW_ALU_CTRL__4, &ksz_data);\n\t\t\tif ((ksz_data & ALU_VALID) || !(ksz_data & ALU_START))\n\t\t\t\tbreak;\n\t\t\tusleep_range(1, 10);\n\t\t} while (timeout-- > 0);\n\n\t\tif (!timeout) {\n\t\t\tdev_dbg(dev->dev, \"Failed to search ALU\\n\");\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (!(ksz_data & ALU_VALID))\n\t\t\tcontinue;\n\n\t\t \n\t\tksz9477_read_table(dev, alu_table);\n\n\t\tksz9477_convert_alu(&alu, alu_table);\n\n\t\tif (alu.port_forward & BIT(port)) {\n\t\t\tret = cb(alu.mac, alu.fid, alu.is_static, data);\n\t\t\tif (ret)\n\t\t\t\tgoto exit;\n\t\t}\n\t} while (ksz_data & ALU_START);\n\nexit:\n\n\t \n\tksz_write32(dev, REG_SW_ALU_CTRL__4, 0);\n\n\tmutex_unlock(&dev->alu_mutex);\n\n\treturn ret;\n}\n\nint ksz9477_mdb_add(struct ksz_device *dev, int port,\n\t\t    const struct switchdev_obj_port_mdb *mdb, struct dsa_db db)\n{\n\tu32 static_table[4];\n\tconst u8 *shifts;\n\tconst u32 *masks;\n\tu32 data;\n\tint index;\n\tu32 mac_hi, mac_lo;\n\tint err = 0;\n\n\tshifts = dev->info->shifts;\n\tmasks = dev->info->masks;\n\n\tmac_hi = ((mdb->addr[0] << 8) | mdb->addr[1]);\n\tmac_lo = ((mdb->addr[2] << 24) | (mdb->addr[3] << 16));\n\tmac_lo |= ((mdb->addr[4] << 8) | mdb->addr[5]);\n\n\tmutex_lock(&dev->alu_mutex);\n\n\tfor (index = 0; index < dev->info->num_statics; index++) {\n\t\t \n\t\tdata = (index << shifts[ALU_STAT_INDEX]) |\n\t\t\tmasks[ALU_STAT_READ] | ALU_STAT_START;\n\t\tksz_write32(dev, REG_SW_ALU_STAT_CTRL__4, data);\n\n\t\t \n\t\terr = ksz9477_wait_alu_sta_ready(dev);\n\t\tif (err) {\n\t\t\tdev_dbg(dev->dev, \"Failed to read ALU STATIC\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\t \n\t\tksz9477_read_table(dev, static_table);\n\n\t\tif (static_table[0] & ALU_V_STATIC_VALID) {\n\t\t\t \n\t\t\tif (((static_table[2] >> ALU_V_FID_S) == mdb->vid) &&\n\t\t\t    ((static_table[2] & ALU_V_MAC_ADDR_HI) == mac_hi) &&\n\t\t\t    static_table[3] == mac_lo) {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (index == dev->info->num_statics) {\n\t\terr = -ENOSPC;\n\t\tgoto exit;\n\t}\n\n\t \n\tstatic_table[0] = ALU_V_STATIC_VALID;\n\tstatic_table[1] |= BIT(port);\n\tif (mdb->vid)\n\t\tstatic_table[1] |= ALU_V_USE_FID;\n\tstatic_table[2] = (mdb->vid << ALU_V_FID_S);\n\tstatic_table[2] |= mac_hi;\n\tstatic_table[3] = mac_lo;\n\n\tksz9477_write_table(dev, static_table);\n\n\tdata = (index << shifts[ALU_STAT_INDEX]) | ALU_STAT_START;\n\tksz_write32(dev, REG_SW_ALU_STAT_CTRL__4, data);\n\n\t \n\tif (ksz9477_wait_alu_sta_ready(dev))\n\t\tdev_dbg(dev->dev, \"Failed to read ALU STATIC\\n\");\n\nexit:\n\tmutex_unlock(&dev->alu_mutex);\n\treturn err;\n}\n\nint ksz9477_mdb_del(struct ksz_device *dev, int port,\n\t\t    const struct switchdev_obj_port_mdb *mdb, struct dsa_db db)\n{\n\tu32 static_table[4];\n\tconst u8 *shifts;\n\tconst u32 *masks;\n\tu32 data;\n\tint index;\n\tint ret = 0;\n\tu32 mac_hi, mac_lo;\n\n\tshifts = dev->info->shifts;\n\tmasks = dev->info->masks;\n\n\tmac_hi = ((mdb->addr[0] << 8) | mdb->addr[1]);\n\tmac_lo = ((mdb->addr[2] << 24) | (mdb->addr[3] << 16));\n\tmac_lo |= ((mdb->addr[4] << 8) | mdb->addr[5]);\n\n\tmutex_lock(&dev->alu_mutex);\n\n\tfor (index = 0; index < dev->info->num_statics; index++) {\n\t\t \n\t\tdata = (index << shifts[ALU_STAT_INDEX]) |\n\t\t\tmasks[ALU_STAT_READ] | ALU_STAT_START;\n\t\tksz_write32(dev, REG_SW_ALU_STAT_CTRL__4, data);\n\n\t\t \n\t\tret = ksz9477_wait_alu_sta_ready(dev);\n\t\tif (ret) {\n\t\t\tdev_dbg(dev->dev, \"Failed to read ALU STATIC\\n\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\t \n\t\tksz9477_read_table(dev, static_table);\n\n\t\tif (static_table[0] & ALU_V_STATIC_VALID) {\n\t\t\t \n\n\t\t\tif (((static_table[2] >> ALU_V_FID_S) == mdb->vid) &&\n\t\t\t    ((static_table[2] & ALU_V_MAC_ADDR_HI) == mac_hi) &&\n\t\t\t    static_table[3] == mac_lo) {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (index == dev->info->num_statics)\n\t\tgoto exit;\n\n\t \n\tstatic_table[1] &= ~BIT(port);\n\n\tif ((static_table[1] & ALU_V_PORT_MAP) == 0) {\n\t\t \n\t\tstatic_table[0] = 0;\n\t\tstatic_table[1] = 0;\n\t\tstatic_table[2] = 0;\n\t\tstatic_table[3] = 0;\n\t}\n\n\tksz9477_write_table(dev, static_table);\n\n\tdata = (index << shifts[ALU_STAT_INDEX]) | ALU_STAT_START;\n\tksz_write32(dev, REG_SW_ALU_STAT_CTRL__4, data);\n\n\t \n\tret = ksz9477_wait_alu_sta_ready(dev);\n\tif (ret)\n\t\tdev_dbg(dev->dev, \"Failed to read ALU STATIC\\n\");\n\nexit:\n\tmutex_unlock(&dev->alu_mutex);\n\n\treturn ret;\n}\n\nint ksz9477_port_mirror_add(struct ksz_device *dev, int port,\n\t\t\t    struct dsa_mall_mirror_tc_entry *mirror,\n\t\t\t    bool ingress, struct netlink_ext_ack *extack)\n{\n\tu8 data;\n\tint p;\n\n\t \n\tfor (p = 0; p < dev->info->port_cnt; p++) {\n\t\t \n\t\tif (p == mirror->to_local_port)\n\t\t\tcontinue;\n\n\t\tksz_pread8(dev, p, P_MIRROR_CTRL, &data);\n\n\t\tif (data & PORT_MIRROR_SNIFFER) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Sniffer port is already configured, delete existing rules & retry\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tif (ingress)\n\t\tksz_port_cfg(dev, port, P_MIRROR_CTRL, PORT_MIRROR_RX, true);\n\telse\n\t\tksz_port_cfg(dev, port, P_MIRROR_CTRL, PORT_MIRROR_TX, true);\n\n\t \n\tksz_port_cfg(dev, mirror->to_local_port, P_MIRROR_CTRL,\n\t\t     PORT_MIRROR_SNIFFER, true);\n\n\tksz_cfg(dev, S_MIRROR_CTRL, SW_MIRROR_RX_TX, false);\n\n\treturn 0;\n}\n\nvoid ksz9477_port_mirror_del(struct ksz_device *dev, int port,\n\t\t\t     struct dsa_mall_mirror_tc_entry *mirror)\n{\n\tbool in_use = false;\n\tu8 data;\n\tint p;\n\n\tif (mirror->ingress)\n\t\tksz_port_cfg(dev, port, P_MIRROR_CTRL, PORT_MIRROR_RX, false);\n\telse\n\t\tksz_port_cfg(dev, port, P_MIRROR_CTRL, PORT_MIRROR_TX, false);\n\n\n\t \n\tfor (p = 0; p < dev->info->port_cnt; p++) {\n\t\tksz_pread8(dev, p, P_MIRROR_CTRL, &data);\n\n\t\tif ((data & (PORT_MIRROR_RX | PORT_MIRROR_TX))) {\n\t\t\tin_use = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!in_use)\n\t\tksz_port_cfg(dev, mirror->to_local_port, P_MIRROR_CTRL,\n\t\t\t     PORT_MIRROR_SNIFFER, false);\n}\n\nstatic phy_interface_t ksz9477_get_interface(struct ksz_device *dev, int port)\n{\n\tphy_interface_t interface;\n\tbool gbit;\n\n\tif (dev->info->internal_phy[port])\n\t\treturn PHY_INTERFACE_MODE_NA;\n\n\tgbit = ksz_get_gbit(dev, port);\n\n\tinterface = ksz_get_xmii(dev, port, gbit);\n\n\treturn interface;\n}\n\nvoid ksz9477_get_caps(struct ksz_device *dev, int port,\n\t\t      struct phylink_config *config)\n{\n\tconfig->mac_capabilities = MAC_10 | MAC_100 | MAC_ASYM_PAUSE |\n\t\t\t\t   MAC_SYM_PAUSE;\n\n\tif (dev->info->gbit_capable[port])\n\t\tconfig->mac_capabilities |= MAC_1000FD;\n}\n\nint ksz9477_set_ageing_time(struct ksz_device *dev, unsigned int msecs)\n{\n\tu32 secs = msecs / 1000;\n\tu8 value;\n\tu8 data;\n\tint ret;\n\n\tvalue = FIELD_GET(SW_AGE_PERIOD_7_0_M, secs);\n\n\tret = ksz_write8(dev, REG_SW_LUE_CTRL_3, value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata = FIELD_GET(SW_AGE_PERIOD_10_8_M, secs);\n\n\tret = ksz_read8(dev, REG_SW_LUE_CTRL_0, &value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvalue &= ~SW_AGE_CNT_M;\n\tvalue |= FIELD_PREP(SW_AGE_CNT_M, data);\n\n\treturn ksz_write8(dev, REG_SW_LUE_CTRL_0, value);\n}\n\nvoid ksz9477_port_queue_split(struct ksz_device *dev, int port)\n{\n\tu8 data;\n\n\tif (dev->info->num_tx_queues == 8)\n\t\tdata = PORT_EIGHT_QUEUE;\n\telse if (dev->info->num_tx_queues == 4)\n\t\tdata = PORT_FOUR_QUEUE;\n\telse if (dev->info->num_tx_queues == 2)\n\t\tdata = PORT_TWO_QUEUE;\n\telse\n\t\tdata = PORT_SINGLE_QUEUE;\n\n\tksz_prmw8(dev, port, REG_PORT_CTRL_0, PORT_QUEUE_SPLIT_MASK, data);\n}\n\nvoid ksz9477_port_setup(struct ksz_device *dev, int port, bool cpu_port)\n{\n\tstruct dsa_switch *ds = dev->ds;\n\tu16 data16;\n\tu8 member;\n\n\t \n\tif (cpu_port)\n\t\tksz_port_cfg(dev, port, REG_PORT_CTRL_0, PORT_TAIL_TAG_ENABLE,\n\t\t\t     true);\n\n\tksz9477_port_queue_split(dev, port);\n\n\tksz_port_cfg(dev, port, REG_PORT_CTRL_0, PORT_MAC_LOOPBACK, false);\n\n\t \n\tksz_port_cfg(dev, port, REG_PORT_MAC_CTRL_1, PORT_BACK_PRESSURE, true);\n\n\t \n\tksz_port_cfg(dev, port, P_BCAST_STORM_CTRL, PORT_BROADCAST_STORM, true);\n\n\t \n\tksz_port_cfg(dev, port, P_PRIO_CTRL, PORT_DIFFSERV_PRIO_ENABLE, false);\n\n\t \n\tksz_port_cfg(dev, port, REG_PORT_MRI_MAC_CTRL, PORT_USER_PRIO_CEILING,\n\t\t     false);\n\tksz9477_port_cfg32(dev, port, REG_PORT_MTI_QUEUE_CTRL_0__4,\n\t\t\t   MTI_PVID_REPLACE, false);\n\n\t \n\tksz_port_cfg(dev, port, P_PRIO_CTRL, PORT_802_1P_PRIO_ENABLE, true);\n\n\t \n\tksz_port_cfg(dev, port, REG_PORT_CTRL_0,\n\t\t     PORT_FORCE_TX_FLOW_CTRL | PORT_FORCE_RX_FLOW_CTRL,\n\t\t     !dev->info->internal_phy[port]);\n\n\tif (cpu_port)\n\t\tmember = dsa_user_ports(ds);\n\telse\n\t\tmember = BIT(dsa_upstream_port(ds, port));\n\n\tksz9477_cfg_port_member(dev, port, member);\n\n\t \n\tif (dev->info->internal_phy[port])\n\t\tksz_pread16(dev, port, REG_PORT_PHY_INT_ENABLE, &data16);\n}\n\nvoid ksz9477_config_cpu_port(struct dsa_switch *ds)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tstruct ksz_port *p;\n\tint i;\n\n\tfor (i = 0; i < dev->info->port_cnt; i++) {\n\t\tif (dsa_is_cpu_port(ds, i) &&\n\t\t    (dev->info->cpu_ports & (1 << i))) {\n\t\t\tphy_interface_t interface;\n\t\t\tconst char *prev_msg;\n\t\t\tconst char *prev_mode;\n\n\t\t\tdev->cpu_port = i;\n\t\t\tp = &dev->ports[i];\n\n\t\t\t \n\t\t\tinterface = ksz9477_get_interface(dev, i);\n\t\t\tif (!p->interface) {\n\t\t\t\tif (dev->compat_interface) {\n\t\t\t\t\tdev_warn(dev->dev,\n\t\t\t\t\t\t \"Using legacy switch \\\"phy-mode\\\" property, because it is missing on port %d node. \"\n\t\t\t\t\t\t \"Please update your device tree.\\n\",\n\t\t\t\t\t\t i);\n\t\t\t\t\tp->interface = dev->compat_interface;\n\t\t\t\t} else {\n\t\t\t\t\tp->interface = interface;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (interface && interface != p->interface) {\n\t\t\t\tprev_msg = \" instead of \";\n\t\t\t\tprev_mode = phy_modes(interface);\n\t\t\t} else {\n\t\t\t\tprev_msg = \"\";\n\t\t\t\tprev_mode = \"\";\n\t\t\t}\n\t\t\tdev_info(dev->dev,\n\t\t\t\t \"Port%d: using phy mode %s%s%s\\n\",\n\t\t\t\t i,\n\t\t\t\t phy_modes(p->interface),\n\t\t\t\t prev_msg,\n\t\t\t\t prev_mode);\n\n\t\t\t \n\t\t\tksz9477_port_setup(dev, i, true);\n\t\t}\n\t}\n\n\tfor (i = 0; i < dev->info->port_cnt; i++) {\n\t\tif (i == dev->cpu_port)\n\t\t\tcontinue;\n\t\tksz_port_stp_state_set(ds, i, BR_STATE_DISABLED);\n\t}\n}\n\nint ksz9477_enable_stp_addr(struct ksz_device *dev)\n{\n\tconst u32 *masks;\n\tu32 data;\n\tint ret;\n\n\tmasks = dev->info->masks;\n\n\t \n\tksz_cfg(dev, REG_SW_LUE_CTRL_0, SW_RESV_MCAST_ENABLE, true);\n\n\t \n\tret = ksz_write32(dev, REG_SW_ALU_VAL_B,\n\t\t\t  ALU_V_OVERRIDE | BIT(dev->cpu_port));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdata = ALU_STAT_START | ALU_RESV_MCAST_ADDR | masks[ALU_STAT_WRITE];\n\n\tret = ksz_write32(dev, REG_SW_ALU_STAT_CTRL__4, data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ksz9477_wait_alu_sta_ready(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev->dev, \"Failed to update Reserved Multicast table\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint ksz9477_setup(struct dsa_switch *ds)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tint ret = 0;\n\n\tds->mtu_enforcement_ingress = true;\n\n\t \n\tksz9477_cfg32(dev, REG_SW_QM_CTRL__4, UNICAST_VLAN_BOUNDARY,\n\t\t      true);\n\n\t \n\tksz_cfg(dev, REG_SW_MAC_CTRL_0, SW_CHECK_LENGTH, false);\n\n\t \n\tksz_cfg(dev, REG_SW_MAC_CTRL_1, SW_JUMBO_PACKET, true);\n\n\t \n\tret = regmap_update_bits(ksz_regmap_16(dev), REG_SW_MTU__2, REG_SW_MTU_MASK,\n\t\t\t\t VLAN_ETH_FRAME_LEN + ETH_FCS_LEN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tksz_cfg(dev, REG_SW_MAC_CTRL_5, SW_OUT_RATE_LIMIT_QUEUE_BASED, true);\n\n\t \n\tksz_cfg(dev, REG_SW_MAC_CTRL_6, SW_MIB_COUNTER_FREEZE, true);\n\n\treturn 0;\n}\n\nu32 ksz9477_get_port_addr(int port, int offset)\n{\n\treturn PORT_CTRL_ADDR(port, offset);\n}\n\nint ksz9477_tc_cbs_set_cinc(struct ksz_device *dev, int port, u32 val)\n{\n\tval = val >> 8;\n\n\treturn ksz_pwrite16(dev, port, REG_PORT_MTI_CREDIT_INCREMENT, val);\n}\n\nint ksz9477_switch_init(struct ksz_device *dev)\n{\n\tu8 data8;\n\tint ret;\n\n\tdev->port_mask = (1 << dev->info->port_cnt) - 1;\n\n\t \n\tret = ksz_read8(dev, REG_SW_GLOBAL_SERIAL_CTRL_0, &data8);\n\tif (ret)\n\t\treturn ret;\n\n\tdata8 &= ~SPI_AUTO_EDGE_DETECTION;\n\tret = ksz_write8(dev, REG_SW_GLOBAL_SERIAL_CTRL_0, data8);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nvoid ksz9477_switch_exit(struct ksz_device *dev)\n{\n\tksz9477_reset_switch(dev);\n}\n\nMODULE_AUTHOR(\"Woojung Huh <Woojung.Huh@microchip.com>\");\nMODULE_DESCRIPTION(\"Microchip KSZ9477 Series Switch DSA Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}