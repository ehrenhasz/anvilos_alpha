{
  "module_name": "lan937x_main.c",
  "hash_id": "37f2f5e7a8763bb6b734d41122d32676936d0113a51a793e730d0c7e401952bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/microchip/lan937x_main.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/iopoll.h>\n#include <linux/phy.h>\n#include <linux/of_net.h>\n#include <linux/if_bridge.h>\n#include <linux/if_vlan.h>\n#include <linux/math.h>\n#include <net/dsa.h>\n#include <net/switchdev.h>\n\n#include \"lan937x_reg.h\"\n#include \"ksz_common.h\"\n#include \"ksz9477.h\"\n#include \"lan937x.h\"\n\nstatic int lan937x_cfg(struct ksz_device *dev, u32 addr, u8 bits, bool set)\n{\n\treturn regmap_update_bits(ksz_regmap_8(dev), addr, bits, set ? bits : 0);\n}\n\nstatic int lan937x_port_cfg(struct ksz_device *dev, int port, int offset,\n\t\t\t    u8 bits, bool set)\n{\n\treturn regmap_update_bits(ksz_regmap_8(dev), PORT_CTRL_ADDR(port, offset),\n\t\t\t\t  bits, set ? bits : 0);\n}\n\nstatic int lan937x_enable_spi_indirect_access(struct ksz_device *dev)\n{\n\tu16 data16;\n\tint ret;\n\n\t \n\tret = lan937x_cfg(dev, REG_GLOBAL_CTRL_0, SW_PHY_REG_BLOCK, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ksz_read16(dev, REG_VPHY_SPECIAL_CTRL__2, &data16);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tdata16 |= VPHY_SPI_INDIRECT_ENABLE;\n\n\treturn ksz_write16(dev, REG_VPHY_SPECIAL_CTRL__2, data16);\n}\n\nstatic int lan937x_vphy_ind_addr_wr(struct ksz_device *dev, int addr, int reg)\n{\n\tu16 addr_base = REG_PORT_T1_PHY_CTRL_BASE;\n\tu16 temp;\n\n\t \n\ttemp = PORT_CTRL_ADDR(addr, (addr_base + (reg << 2)));\n\n\treturn ksz_write16(dev, REG_VPHY_IND_ADDR__2, temp);\n}\n\nstatic int lan937x_internal_phy_write(struct ksz_device *dev, int addr, int reg,\n\t\t\t\t      u16 val)\n{\n\tunsigned int value;\n\tint ret;\n\n\t \n\tif (!dev->info->internal_phy[addr])\n\t\treturn -EOPNOTSUPP;\n\n\tret = lan937x_vphy_ind_addr_wr(dev, addr, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ksz_write16(dev, REG_VPHY_IND_DATA__2, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ksz_write16(dev, REG_VPHY_IND_CTRL__2,\n\t\t\t  (VPHY_IND_WRITE | VPHY_IND_BUSY));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read_poll_timeout(ksz_regmap_16(dev), REG_VPHY_IND_CTRL__2,\n\t\t\t\t       value, !(value & VPHY_IND_BUSY), 10,\n\t\t\t\t       1000);\n\tif (ret < 0) {\n\t\tdev_err(dev->dev, \"Failed to write phy register\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int lan937x_internal_phy_read(struct ksz_device *dev, int addr, int reg,\n\t\t\t\t     u16 *val)\n{\n\tunsigned int value;\n\tint ret;\n\n\t \n\tif (!dev->info->internal_phy[addr])\n\t\treturn 0xffff;\n\n\tret = lan937x_vphy_ind_addr_wr(dev, addr, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ksz_write16(dev, REG_VPHY_IND_CTRL__2, VPHY_IND_BUSY);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read_poll_timeout(ksz_regmap_16(dev), REG_VPHY_IND_CTRL__2,\n\t\t\t\t       value, !(value & VPHY_IND_BUSY), 10,\n\t\t\t\t       1000);\n\tif (ret < 0) {\n\t\tdev_err(dev->dev, \"Failed to read phy register\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\treturn ksz_read16(dev, REG_VPHY_IND_DATA__2, val);\n}\n\nint lan937x_r_phy(struct ksz_device *dev, u16 addr, u16 reg, u16 *data)\n{\n\treturn lan937x_internal_phy_read(dev, addr, reg, data);\n}\n\nint lan937x_w_phy(struct ksz_device *dev, u16 addr, u16 reg, u16 val)\n{\n\treturn lan937x_internal_phy_write(dev, addr, reg, val);\n}\n\nint lan937x_reset_switch(struct ksz_device *dev)\n{\n\tu32 data32;\n\tint ret;\n\n\t \n\tret = lan937x_cfg(dev, REG_SW_OPERATION, SW_RESET, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = lan937x_cfg(dev, REG_SW_LUE_CTRL_1, SW_LINK_AUTO_AGING, true);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ksz_write32(dev, REG_SW_INT_MASK__4, SWITCH_INT_MASK);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ksz_write32(dev, REG_SW_INT_STATUS__4, POR_READY_INT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ksz_write32(dev, REG_SW_PORT_INT_MASK__4, 0xFF);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ksz_read32(dev, REG_SW_PORT_INT_STATUS__4, &data32);\n}\n\nvoid lan937x_port_setup(struct ksz_device *dev, int port, bool cpu_port)\n{\n\tconst u32 *masks = dev->info->masks;\n\tconst u16 *regs = dev->info->regs;\n\tstruct dsa_switch *ds = dev->ds;\n\tu8 member;\n\n\t \n\tif (cpu_port)\n\t\tlan937x_port_cfg(dev, port, REG_PORT_CTRL_0,\n\t\t\t\t PORT_TAIL_TAG_ENABLE, true);\n\n\t \n\tksz9477_port_queue_split(dev, port);\n\n\t \n\tlan937x_port_cfg(dev, port, REG_PORT_MAC_CTRL_1, PORT_BACK_PRESSURE,\n\t\t\t true);\n\n\t \n\tlan937x_port_cfg(dev, port, P_PRIO_CTRL, PORT_802_1P_PRIO_ENABLE, true);\n\n\tif (!dev->info->internal_phy[port])\n\t\tlan937x_port_cfg(dev, port, regs[P_XMII_CTRL_0],\n\t\t\t\t masks[P_MII_TX_FLOW_CTRL] |\n\t\t\t\t masks[P_MII_RX_FLOW_CTRL],\n\t\t\t\t true);\n\n\tif (cpu_port)\n\t\tmember = dsa_user_ports(ds);\n\telse\n\t\tmember = BIT(dsa_upstream_port(ds, port));\n\n\tdev->dev_ops->cfg_port_member(dev, port, member);\n}\n\nvoid lan937x_config_cpu_port(struct dsa_switch *ds)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tstruct dsa_port *dp;\n\n\tdsa_switch_for_each_cpu_port(dp, ds) {\n\t\tif (dev->info->cpu_ports & (1 << dp->index)) {\n\t\t\tdev->cpu_port = dp->index;\n\n\t\t\t \n\t\t\tlan937x_port_setup(dev, dp->index, true);\n\t\t}\n\t}\n\n\tdsa_switch_for_each_user_port(dp, ds) {\n\t\tksz_port_stp_state_set(ds, dp->index, BR_STATE_DISABLED);\n\t}\n}\n\nint lan937x_change_mtu(struct ksz_device *dev, int port, int new_mtu)\n{\n\tstruct dsa_switch *ds = dev->ds;\n\tint ret;\n\n\tnew_mtu += VLAN_ETH_HLEN + ETH_FCS_LEN;\n\n\tif (dsa_is_cpu_port(ds, port))\n\t\tnew_mtu += LAN937X_TAG_LEN;\n\n\tif (new_mtu >= FR_MIN_SIZE)\n\t\tret = lan937x_port_cfg(dev, port, REG_PORT_MAC_CTRL_0,\n\t\t\t\t       PORT_JUMBO_PACKET, true);\n\telse\n\t\tret = lan937x_port_cfg(dev, port, REG_PORT_MAC_CTRL_0,\n\t\t\t\t       PORT_JUMBO_PACKET, false);\n\tif (ret < 0) {\n\t\tdev_err(ds->dev, \"failed to enable jumbo\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = ksz_pwrite16(dev, port, PORT_MAX_FR_SIZE, new_mtu);\n\tif (ret) {\n\t\tdev_err(ds->dev, \"failed to update mtu for port %d\\n\", port);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint lan937x_set_ageing_time(struct ksz_device *dev, unsigned int msecs)\n{\n\tu32 secs = msecs / 1000;\n\tu32 value;\n\tint ret;\n\n\tvalue = FIELD_GET(SW_AGE_PERIOD_7_0_M, secs);\n\n\tret = ksz_write8(dev, REG_SW_AGE_PERIOD__1, value);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvalue = FIELD_GET(SW_AGE_PERIOD_19_8_M, secs);\n\n\treturn ksz_write16(dev, REG_SW_AGE_PERIOD__2, value);\n}\n\nstatic void lan937x_set_tune_adj(struct ksz_device *dev, int port,\n\t\t\t\t u16 reg, u8 val)\n{\n\tu16 data16;\n\n\tksz_pread16(dev, port, reg, &data16);\n\n\t \n\tdata16 |= FIELD_PREP(PORT_TUNE_ADJ, val);\n\tksz_pwrite16(dev, port, reg, data16);\n\n\t \n\tdata16 |= PORT_DLL_RESET;\n\tksz_pwrite16(dev, port, reg, data16);\n}\n\nstatic void lan937x_set_rgmii_tx_delay(struct ksz_device *dev, int port)\n{\n\tu8 val;\n\n\t \n\tval = (port == LAN937X_RGMII_1_PORT) ? RGMII_1_TX_DELAY_2NS :\n\t\tRGMII_2_TX_DELAY_2NS;\n\n\tlan937x_set_tune_adj(dev, port, REG_PORT_XMII_CTRL_5, val);\n}\n\nstatic void lan937x_set_rgmii_rx_delay(struct ksz_device *dev, int port)\n{\n\tu8 val;\n\n\tval = (port == LAN937X_RGMII_1_PORT) ? RGMII_1_RX_DELAY_2NS :\n\t\tRGMII_2_RX_DELAY_2NS;\n\n\tlan937x_set_tune_adj(dev, port, REG_PORT_XMII_CTRL_4, val);\n}\n\nvoid lan937x_phylink_get_caps(struct ksz_device *dev, int port,\n\t\t\t      struct phylink_config *config)\n{\n\tconfig->mac_capabilities = MAC_100FD;\n\n\tif (dev->info->supports_rgmii[port]) {\n\t\t \n\t\tconfig->mac_capabilities |= MAC_ASYM_PAUSE | MAC_SYM_PAUSE |\n\t\t\t\t\t    MAC_100HD | MAC_10 | MAC_1000FD;\n\t}\n}\n\nvoid lan937x_setup_rgmii_delay(struct ksz_device *dev, int port)\n{\n\tstruct ksz_port *p = &dev->ports[port];\n\n\tif (p->rgmii_tx_val) {\n\t\tlan937x_set_rgmii_tx_delay(dev, port);\n\t\tdev_info(dev->dev, \"Applied rgmii tx delay for the port %d\\n\",\n\t\t\t port);\n\t}\n\n\tif (p->rgmii_rx_val) {\n\t\tlan937x_set_rgmii_rx_delay(dev, port);\n\t\tdev_info(dev->dev, \"Applied rgmii rx delay for the port %d\\n\",\n\t\t\t port);\n\t}\n}\n\nint lan937x_tc_cbs_set_cinc(struct ksz_device *dev, int port, u32 val)\n{\n\treturn ksz_pwrite32(dev, port, REG_PORT_MTI_CREDIT_INCREMENT, val);\n}\n\nint lan937x_switch_init(struct ksz_device *dev)\n{\n\tdev->port_mask = (1 << dev->info->port_cnt) - 1;\n\n\treturn 0;\n}\n\nint lan937x_setup(struct dsa_switch *ds)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tint ret;\n\n\t \n\tret = lan937x_enable_spi_indirect_access(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev->dev, \"failed to enable spi indirect access\");\n\t\treturn ret;\n\t}\n\n\t \n\tds->vlan_filtering_is_global = true;\n\n\t \n\tlan937x_cfg(dev, REG_SW_MAC_CTRL_0,\n\t\t    (SW_PAUSE_UNH_MODE | SW_NEW_BACKOFF | SW_AGGR_BACKOFF),\n\t\t    true);\n\n\t \n\tlan937x_cfg(dev, REG_SW_MAC_CTRL_1, NO_EXC_COLLISION_DROP, true);\n\n\t \n\tlan937x_cfg(dev, REG_SW_MAC_CTRL_6, SW_MIB_COUNTER_FREEZE, true);\n\n\t \n\tlan937x_cfg(dev, REG_SW_GLOBAL_OUTPUT_CTRL__1,\n\t\t    (SW_CLK125_ENB | SW_CLK25_ENB), true);\n\n\treturn 0;\n}\n\nvoid lan937x_teardown(struct dsa_switch *ds)\n{\n\n}\n\nvoid lan937x_switch_exit(struct ksz_device *dev)\n{\n\tlan937x_reset_switch(dev);\n}\n\nMODULE_AUTHOR(\"Arun Ramadoss <arun.ramadoss@microchip.com>\");\nMODULE_DESCRIPTION(\"Microchip LAN937x Series Switch DSA Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}