{
  "module_name": "ksz8795.c",
  "hash_id": "f933b70258fca5426a357e53c216e36809fa057746eb994e74c4bbcb29eece25",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/microchip/ksz8795.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/gpio.h>\n#include <linux/if_vlan.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_data/microchip-ksz.h>\n#include <linux/phy.h>\n#include <linux/etherdevice.h>\n#include <linux/if_bridge.h>\n#include <linux/micrel_phy.h>\n#include <net/dsa.h>\n#include <net/switchdev.h>\n#include <linux/phylink.h>\n\n#include \"ksz_common.h\"\n#include \"ksz8795_reg.h\"\n#include \"ksz8.h\"\n\nstatic void ksz_cfg(struct ksz_device *dev, u32 addr, u8 bits, bool set)\n{\n\tregmap_update_bits(ksz_regmap_8(dev), addr, bits, set ? bits : 0);\n}\n\nstatic void ksz_port_cfg(struct ksz_device *dev, int port, int offset, u8 bits,\n\t\t\t bool set)\n{\n\tregmap_update_bits(ksz_regmap_8(dev), PORT_CTRL_ADDR(port, offset),\n\t\t\t   bits, set ? bits : 0);\n}\n\nstatic int ksz8_ind_write8(struct ksz_device *dev, u8 table, u16 addr, u8 data)\n{\n\tconst u16 *regs;\n\tu16 ctrl_addr;\n\tint ret = 0;\n\n\tregs = dev->info->regs;\n\n\tmutex_lock(&dev->alu_mutex);\n\n\tctrl_addr = IND_ACC_TABLE(table) | addr;\n\tret = ksz_write8(dev, regs[REG_IND_BYTE], data);\n\tif (!ret)\n\t\tret = ksz_write16(dev, regs[REG_IND_CTRL_0], ctrl_addr);\n\n\tmutex_unlock(&dev->alu_mutex);\n\n\treturn ret;\n}\n\nint ksz8_reset_switch(struct ksz_device *dev)\n{\n\tif (ksz_is_ksz88x3(dev)) {\n\t\t \n\t\tksz_cfg(dev, KSZ8863_REG_SW_RESET,\n\t\t\tKSZ8863_GLOBAL_SOFTWARE_RESET | KSZ8863_PCS_RESET, true);\n\t\tksz_cfg(dev, KSZ8863_REG_SW_RESET,\n\t\t\tKSZ8863_GLOBAL_SOFTWARE_RESET | KSZ8863_PCS_RESET, false);\n\t} else {\n\t\t \n\t\tksz_write8(dev, REG_POWER_MANAGEMENT_1,\n\t\t\t   SW_SOFTWARE_POWER_DOWN << SW_POWER_MANAGEMENT_MODE_S);\n\t\tksz_write8(dev, REG_POWER_MANAGEMENT_1, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int ksz8863_change_mtu(struct ksz_device *dev, int frame_size)\n{\n\tu8 ctrl2 = 0;\n\n\tif (frame_size <= KSZ8_LEGAL_PACKET_SIZE)\n\t\tctrl2 |= KSZ8863_LEGAL_PACKET_ENABLE;\n\telse if (frame_size > KSZ8863_NORMAL_PACKET_SIZE)\n\t\tctrl2 |= KSZ8863_HUGE_PACKET_ENABLE;\n\n\treturn ksz_rmw8(dev, REG_SW_CTRL_2, KSZ8863_LEGAL_PACKET_ENABLE |\n\t\t\tKSZ8863_HUGE_PACKET_ENABLE, ctrl2);\n}\n\nstatic int ksz8795_change_mtu(struct ksz_device *dev, int frame_size)\n{\n\tu8 ctrl1 = 0, ctrl2 = 0;\n\tint ret;\n\n\tif (frame_size > KSZ8_LEGAL_PACKET_SIZE)\n\t\tctrl2 |= SW_LEGAL_PACKET_DISABLE;\n\tif (frame_size > KSZ8863_NORMAL_PACKET_SIZE)\n\t\tctrl1 |= SW_HUGE_PACKET;\n\n\tret = ksz_rmw8(dev, REG_SW_CTRL_1, SW_HUGE_PACKET, ctrl1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ksz_rmw8(dev, REG_SW_CTRL_2, SW_LEGAL_PACKET_DISABLE, ctrl2);\n}\n\nint ksz8_change_mtu(struct ksz_device *dev, int port, int mtu)\n{\n\tu16 frame_size;\n\n\tif (!dsa_is_cpu_port(dev->ds, port))\n\t\treturn 0;\n\n\tframe_size = mtu + VLAN_ETH_HLEN + ETH_FCS_LEN;\n\n\tswitch (dev->chip_id) {\n\tcase KSZ8795_CHIP_ID:\n\tcase KSZ8794_CHIP_ID:\n\tcase KSZ8765_CHIP_ID:\n\t\treturn ksz8795_change_mtu(dev, frame_size);\n\tcase KSZ8830_CHIP_ID:\n\t\treturn ksz8863_change_mtu(dev, frame_size);\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic void ksz8795_set_prio_queue(struct ksz_device *dev, int port, int queue)\n{\n\tu8 hi, lo;\n\n\t \n\tswitch (queue) {\n\tcase 4:\n\tcase 3:\n\t\tqueue = PORT_QUEUE_SPLIT_4;\n\t\tbreak;\n\tcase 2:\n\t\tqueue = PORT_QUEUE_SPLIT_2;\n\t\tbreak;\n\tdefault:\n\t\tqueue = PORT_QUEUE_SPLIT_1;\n\t}\n\tksz_pread8(dev, port, REG_PORT_CTRL_0, &lo);\n\tksz_pread8(dev, port, P_DROP_TAG_CTRL, &hi);\n\tlo &= ~PORT_QUEUE_SPLIT_L;\n\tif (queue & PORT_QUEUE_SPLIT_2)\n\t\tlo |= PORT_QUEUE_SPLIT_L;\n\thi &= ~PORT_QUEUE_SPLIT_H;\n\tif (queue & PORT_QUEUE_SPLIT_4)\n\t\thi |= PORT_QUEUE_SPLIT_H;\n\tksz_pwrite8(dev, port, REG_PORT_CTRL_0, lo);\n\tksz_pwrite8(dev, port, P_DROP_TAG_CTRL, hi);\n\n\t \n\tif (queue != PORT_QUEUE_SPLIT_1)\n\t\tksz_cfg(dev, REG_SW_CTRL_19, SW_OUT_RATE_LIMIT_QUEUE_BASED,\n\t\t\ttrue);\n}\n\nvoid ksz8_r_mib_cnt(struct ksz_device *dev, int port, u16 addr, u64 *cnt)\n{\n\tconst u32 *masks;\n\tconst u16 *regs;\n\tu16 ctrl_addr;\n\tu32 data;\n\tu8 check;\n\tint loop;\n\n\tmasks = dev->info->masks;\n\tregs = dev->info->regs;\n\n\tctrl_addr = addr + dev->info->reg_mib_cnt * port;\n\tctrl_addr |= IND_ACC_TABLE(TABLE_MIB | TABLE_READ);\n\n\tmutex_lock(&dev->alu_mutex);\n\tksz_write16(dev, regs[REG_IND_CTRL_0], ctrl_addr);\n\n\t \n\tfor (loop = 2; loop > 0; loop--) {\n\t\tksz_read8(dev, regs[REG_IND_MIB_CHECK], &check);\n\n\t\tif (check & masks[MIB_COUNTER_VALID]) {\n\t\t\tksz_read32(dev, regs[REG_IND_DATA_LO], &data);\n\t\t\tif (check & masks[MIB_COUNTER_OVERFLOW])\n\t\t\t\t*cnt += MIB_COUNTER_VALUE + 1;\n\t\t\t*cnt += data & MIB_COUNTER_VALUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&dev->alu_mutex);\n}\n\nstatic void ksz8795_r_mib_pkt(struct ksz_device *dev, int port, u16 addr,\n\t\t\t      u64 *dropped, u64 *cnt)\n{\n\tconst u32 *masks;\n\tconst u16 *regs;\n\tu16 ctrl_addr;\n\tu32 data;\n\tu8 check;\n\tint loop;\n\n\tmasks = dev->info->masks;\n\tregs = dev->info->regs;\n\n\taddr -= dev->info->reg_mib_cnt;\n\tctrl_addr = (KSZ8795_MIB_TOTAL_RX_1 - KSZ8795_MIB_TOTAL_RX_0) * port;\n\tctrl_addr += addr + KSZ8795_MIB_TOTAL_RX_0;\n\tctrl_addr |= IND_ACC_TABLE(TABLE_MIB | TABLE_READ);\n\n\tmutex_lock(&dev->alu_mutex);\n\tksz_write16(dev, regs[REG_IND_CTRL_0], ctrl_addr);\n\n\t \n\tfor (loop = 2; loop > 0; loop--) {\n\t\tksz_read8(dev, regs[REG_IND_MIB_CHECK], &check);\n\n\t\tif (check & masks[MIB_COUNTER_VALID]) {\n\t\t\tksz_read32(dev, regs[REG_IND_DATA_LO], &data);\n\t\t\tif (addr < 2) {\n\t\t\t\tu64 total;\n\n\t\t\t\ttotal = check & MIB_TOTAL_BYTES_H;\n\t\t\t\ttotal <<= 32;\n\t\t\t\t*cnt += total;\n\t\t\t\t*cnt += data;\n\t\t\t\tif (check & masks[MIB_COUNTER_OVERFLOW]) {\n\t\t\t\t\ttotal = MIB_TOTAL_BYTES_H + 1;\n\t\t\t\t\ttotal <<= 32;\n\t\t\t\t\t*cnt += total;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (check & masks[MIB_COUNTER_OVERFLOW])\n\t\t\t\t\t*cnt += MIB_PACKET_DROPPED + 1;\n\t\t\t\t*cnt += data & MIB_PACKET_DROPPED;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&dev->alu_mutex);\n}\n\nstatic void ksz8863_r_mib_pkt(struct ksz_device *dev, int port, u16 addr,\n\t\t\t      u64 *dropped, u64 *cnt)\n{\n\tu32 *last = (u32 *)dropped;\n\tconst u16 *regs;\n\tu16 ctrl_addr;\n\tu32 data;\n\tu32 cur;\n\n\tregs = dev->info->regs;\n\n\taddr -= dev->info->reg_mib_cnt;\n\tctrl_addr = addr ? KSZ8863_MIB_PACKET_DROPPED_TX_0 :\n\t\t\t   KSZ8863_MIB_PACKET_DROPPED_RX_0;\n\tctrl_addr += port;\n\tctrl_addr |= IND_ACC_TABLE(TABLE_MIB | TABLE_READ);\n\n\tmutex_lock(&dev->alu_mutex);\n\tksz_write16(dev, regs[REG_IND_CTRL_0], ctrl_addr);\n\tksz_read32(dev, regs[REG_IND_DATA_LO], &data);\n\tmutex_unlock(&dev->alu_mutex);\n\n\tdata &= MIB_PACKET_DROPPED;\n\tcur = last[addr];\n\tif (data != cur) {\n\t\tlast[addr] = data;\n\t\tif (data < cur)\n\t\t\tdata += MIB_PACKET_DROPPED + 1;\n\t\tdata -= cur;\n\t\t*cnt += data;\n\t}\n}\n\nvoid ksz8_r_mib_pkt(struct ksz_device *dev, int port, u16 addr,\n\t\t    u64 *dropped, u64 *cnt)\n{\n\tif (ksz_is_ksz88x3(dev))\n\t\tksz8863_r_mib_pkt(dev, port, addr, dropped, cnt);\n\telse\n\t\tksz8795_r_mib_pkt(dev, port, addr, dropped, cnt);\n}\n\nvoid ksz8_freeze_mib(struct ksz_device *dev, int port, bool freeze)\n{\n\tif (ksz_is_ksz88x3(dev))\n\t\treturn;\n\n\t \n\tif (freeze)\n\t\tksz_cfg(dev, REG_SW_CTRL_6, BIT(port), true);\n\tksz_cfg(dev, REG_SW_CTRL_6, SW_MIB_COUNTER_FREEZE, freeze);\n\n\t \n\tif (!freeze)\n\t\tksz_cfg(dev, REG_SW_CTRL_6, BIT(port), false);\n}\n\nvoid ksz8_port_init_cnt(struct ksz_device *dev, int port)\n{\n\tstruct ksz_port_mib *mib = &dev->ports[port].mib;\n\tu64 *dropped;\n\n\tif (!ksz_is_ksz88x3(dev)) {\n\t\t \n\t\tksz_cfg(dev, REG_SW_CTRL_6, BIT(port), true);\n\t\tksz_cfg(dev, REG_SW_CTRL_6, SW_MIB_COUNTER_FLUSH, true);\n\t\tksz_cfg(dev, REG_SW_CTRL_6, BIT(port), false);\n\t}\n\n\tmib->cnt_ptr = 0;\n\n\t \n\twhile (mib->cnt_ptr < dev->info->reg_mib_cnt) {\n\t\tdev->dev_ops->r_mib_cnt(dev, port, mib->cnt_ptr,\n\t\t\t\t\t&mib->counters[mib->cnt_ptr]);\n\t\t++mib->cnt_ptr;\n\t}\n\n\t \n\tdropped = &mib->counters[dev->info->mib_cnt];\n\n\t \n\twhile (mib->cnt_ptr < dev->info->mib_cnt) {\n\t\tdev->dev_ops->r_mib_pkt(dev, port, mib->cnt_ptr,\n\t\t\t\t\tdropped, &mib->counters[mib->cnt_ptr]);\n\t\t++mib->cnt_ptr;\n\t}\n}\n\nstatic int ksz8_r_table(struct ksz_device *dev, int table, u16 addr, u64 *data)\n{\n\tconst u16 *regs;\n\tu16 ctrl_addr;\n\tint ret;\n\n\tregs = dev->info->regs;\n\n\tctrl_addr = IND_ACC_TABLE(table | TABLE_READ) | addr;\n\n\tmutex_lock(&dev->alu_mutex);\n\tret = ksz_write16(dev, regs[REG_IND_CTRL_0], ctrl_addr);\n\tif (ret)\n\t\tgoto unlock_alu;\n\n\tret = ksz_read64(dev, regs[REG_IND_DATA_HI], data);\nunlock_alu:\n\tmutex_unlock(&dev->alu_mutex);\n\n\treturn ret;\n}\n\nstatic int ksz8_w_table(struct ksz_device *dev, int table, u16 addr, u64 data)\n{\n\tconst u16 *regs;\n\tu16 ctrl_addr;\n\tint ret;\n\n\tregs = dev->info->regs;\n\n\tctrl_addr = IND_ACC_TABLE(table) | addr;\n\n\tmutex_lock(&dev->alu_mutex);\n\tret = ksz_write64(dev, regs[REG_IND_DATA_HI], data);\n\tif (ret)\n\t\tgoto unlock_alu;\n\n\tret = ksz_write16(dev, regs[REG_IND_CTRL_0], ctrl_addr);\nunlock_alu:\n\tmutex_unlock(&dev->alu_mutex);\n\n\treturn ret;\n}\n\nstatic int ksz8_valid_dyn_entry(struct ksz_device *dev, u8 *data)\n{\n\tint timeout = 100;\n\tconst u32 *masks;\n\tconst u16 *regs;\n\n\tmasks = dev->info->masks;\n\tregs = dev->info->regs;\n\n\tdo {\n\t\tksz_read8(dev, regs[REG_IND_DATA_CHECK], data);\n\t\ttimeout--;\n\t} while ((*data & masks[DYNAMIC_MAC_TABLE_NOT_READY]) && timeout);\n\n\t \n\tif (*data & masks[DYNAMIC_MAC_TABLE_NOT_READY]) {\n\t\treturn -EAGAIN;\n\t \n\t} else {\n\t\tksz_read8(dev, regs[REG_IND_DATA_8], data);\n\n\t\t \n\t\tif (*data & masks[DYNAMIC_MAC_TABLE_MAC_EMPTY])\n\t\t\treturn -ENXIO;\n\t}\n\treturn 0;\n}\n\nint ksz8_r_dyn_mac_table(struct ksz_device *dev, u16 addr, u8 *mac_addr,\n\t\t\t u8 *fid, u8 *src_port, u8 *timestamp, u16 *entries)\n{\n\tu32 data_hi, data_lo;\n\tconst u8 *shifts;\n\tconst u32 *masks;\n\tconst u16 *regs;\n\tu16 ctrl_addr;\n\tu8 data;\n\tint rc;\n\n\tshifts = dev->info->shifts;\n\tmasks = dev->info->masks;\n\tregs = dev->info->regs;\n\n\tctrl_addr = IND_ACC_TABLE(TABLE_DYNAMIC_MAC | TABLE_READ) | addr;\n\n\tmutex_lock(&dev->alu_mutex);\n\tksz_write16(dev, regs[REG_IND_CTRL_0], ctrl_addr);\n\n\trc = ksz8_valid_dyn_entry(dev, &data);\n\tif (rc == -EAGAIN) {\n\t\tif (addr == 0)\n\t\t\t*entries = 0;\n\t} else if (rc == -ENXIO) {\n\t\t*entries = 0;\n\t \n\t} else {\n\t\tu64 buf = 0;\n\t\tint cnt;\n\n\t\tksz_read64(dev, regs[REG_IND_DATA_HI], &buf);\n\t\tdata_hi = (u32)(buf >> 32);\n\t\tdata_lo = (u32)buf;\n\n\t\t \n\t\tcnt = data & masks[DYNAMIC_MAC_TABLE_ENTRIES_H];\n\t\tcnt <<= shifts[DYNAMIC_MAC_ENTRIES_H];\n\t\tcnt |= (data_hi & masks[DYNAMIC_MAC_TABLE_ENTRIES]) >>\n\t\t\tshifts[DYNAMIC_MAC_ENTRIES];\n\t\t*entries = cnt + 1;\n\n\t\t*fid = (data_hi & masks[DYNAMIC_MAC_TABLE_FID]) >>\n\t\t\tshifts[DYNAMIC_MAC_FID];\n\t\t*src_port = (data_hi & masks[DYNAMIC_MAC_TABLE_SRC_PORT]) >>\n\t\t\tshifts[DYNAMIC_MAC_SRC_PORT];\n\t\t*timestamp = (data_hi & masks[DYNAMIC_MAC_TABLE_TIMESTAMP]) >>\n\t\t\tshifts[DYNAMIC_MAC_TIMESTAMP];\n\n\t\tmac_addr[5] = (u8)data_lo;\n\t\tmac_addr[4] = (u8)(data_lo >> 8);\n\t\tmac_addr[3] = (u8)(data_lo >> 16);\n\t\tmac_addr[2] = (u8)(data_lo >> 24);\n\n\t\tmac_addr[1] = (u8)data_hi;\n\t\tmac_addr[0] = (u8)(data_hi >> 8);\n\t\trc = 0;\n\t}\n\tmutex_unlock(&dev->alu_mutex);\n\n\treturn rc;\n}\n\nstatic int ksz8_r_sta_mac_table(struct ksz_device *dev, u16 addr,\n\t\t\t\tstruct alu_struct *alu, bool *valid)\n{\n\tu32 data_hi, data_lo;\n\tconst u8 *shifts;\n\tconst u32 *masks;\n\tu64 data;\n\tint ret;\n\n\tshifts = dev->info->shifts;\n\tmasks = dev->info->masks;\n\n\tret = ksz8_r_table(dev, TABLE_STATIC_MAC, addr, &data);\n\tif (ret)\n\t\treturn ret;\n\n\tdata_hi = data >> 32;\n\tdata_lo = (u32)data;\n\n\tif (!(data_hi & (masks[STATIC_MAC_TABLE_VALID] |\n\t\t\t masks[STATIC_MAC_TABLE_OVERRIDE]))) {\n\t\t*valid = false;\n\t\treturn 0;\n\t}\n\n\talu->mac[5] = (u8)data_lo;\n\talu->mac[4] = (u8)(data_lo >> 8);\n\talu->mac[3] = (u8)(data_lo >> 16);\n\talu->mac[2] = (u8)(data_lo >> 24);\n\talu->mac[1] = (u8)data_hi;\n\talu->mac[0] = (u8)(data_hi >> 8);\n\talu->port_forward =\n\t\t(data_hi & masks[STATIC_MAC_TABLE_FWD_PORTS]) >>\n\t\t\tshifts[STATIC_MAC_FWD_PORTS];\n\talu->is_override = (data_hi & masks[STATIC_MAC_TABLE_OVERRIDE]) ? 1 : 0;\n\n\t \n\tif (ksz_is_ksz87xx(dev))\n\t\tdata_hi >>= 1;\n\talu->is_static = true;\n\talu->is_use_fid = (data_hi & masks[STATIC_MAC_TABLE_USE_FID]) ? 1 : 0;\n\talu->fid = (data_hi & masks[STATIC_MAC_TABLE_FID]) >>\n\t\tshifts[STATIC_MAC_FID];\n\n\t*valid = true;\n\n\treturn 0;\n}\n\nstatic int ksz8_w_sta_mac_table(struct ksz_device *dev, u16 addr,\n\t\t\t\tstruct alu_struct *alu)\n{\n\tu32 data_hi, data_lo;\n\tconst u8 *shifts;\n\tconst u32 *masks;\n\tu64 data;\n\n\tshifts = dev->info->shifts;\n\tmasks = dev->info->masks;\n\n\tdata_lo = ((u32)alu->mac[2] << 24) |\n\t\t((u32)alu->mac[3] << 16) |\n\t\t((u32)alu->mac[4] << 8) | alu->mac[5];\n\tdata_hi = ((u32)alu->mac[0] << 8) | alu->mac[1];\n\tdata_hi |= (u32)alu->port_forward << shifts[STATIC_MAC_FWD_PORTS];\n\n\tif (alu->is_override)\n\t\tdata_hi |= masks[STATIC_MAC_TABLE_OVERRIDE];\n\tif (alu->is_use_fid) {\n\t\tdata_hi |= masks[STATIC_MAC_TABLE_USE_FID];\n\t\tdata_hi |= (u32)alu->fid << shifts[STATIC_MAC_FID];\n\t}\n\tif (alu->is_static)\n\t\tdata_hi |= masks[STATIC_MAC_TABLE_VALID];\n\telse\n\t\tdata_hi &= ~masks[STATIC_MAC_TABLE_OVERRIDE];\n\n\tdata = (u64)data_hi << 32 | data_lo;\n\n\treturn ksz8_w_table(dev, TABLE_STATIC_MAC, addr, data);\n}\n\nstatic void ksz8_from_vlan(struct ksz_device *dev, u32 vlan, u8 *fid,\n\t\t\t   u8 *member, u8 *valid)\n{\n\tconst u8 *shifts;\n\tconst u32 *masks;\n\n\tshifts = dev->info->shifts;\n\tmasks = dev->info->masks;\n\n\t*fid = vlan & masks[VLAN_TABLE_FID];\n\t*member = (vlan & masks[VLAN_TABLE_MEMBERSHIP]) >>\n\t\t\tshifts[VLAN_TABLE_MEMBERSHIP_S];\n\t*valid = !!(vlan & masks[VLAN_TABLE_VALID]);\n}\n\nstatic void ksz8_to_vlan(struct ksz_device *dev, u8 fid, u8 member, u8 valid,\n\t\t\t u16 *vlan)\n{\n\tconst u8 *shifts;\n\tconst u32 *masks;\n\n\tshifts = dev->info->shifts;\n\tmasks = dev->info->masks;\n\n\t*vlan = fid;\n\t*vlan |= (u16)member << shifts[VLAN_TABLE_MEMBERSHIP_S];\n\tif (valid)\n\t\t*vlan |= masks[VLAN_TABLE_VALID];\n}\n\nstatic void ksz8_r_vlan_entries(struct ksz_device *dev, u16 addr)\n{\n\tconst u8 *shifts;\n\tu64 data;\n\tint i;\n\n\tshifts = dev->info->shifts;\n\n\tksz8_r_table(dev, TABLE_VLAN, addr, &data);\n\taddr *= 4;\n\tfor (i = 0; i < 4; i++) {\n\t\tdev->vlan_cache[addr + i].table[0] = (u16)data;\n\t\tdata >>= shifts[VLAN_TABLE];\n\t}\n}\n\nstatic void ksz8_r_vlan_table(struct ksz_device *dev, u16 vid, u16 *vlan)\n{\n\tint index;\n\tu16 *data;\n\tu16 addr;\n\tu64 buf;\n\n\tdata = (u16 *)&buf;\n\taddr = vid / 4;\n\tindex = vid & 3;\n\tksz8_r_table(dev, TABLE_VLAN, addr, &buf);\n\t*vlan = data[index];\n}\n\nstatic void ksz8_w_vlan_table(struct ksz_device *dev, u16 vid, u16 vlan)\n{\n\tint index;\n\tu16 *data;\n\tu16 addr;\n\tu64 buf;\n\n\tdata = (u16 *)&buf;\n\taddr = vid / 4;\n\tindex = vid & 3;\n\tksz8_r_table(dev, TABLE_VLAN, addr, &buf);\n\tdata[index] = vlan;\n\tdev->vlan_cache[vid].table[0] = vlan;\n\tksz8_w_table(dev, TABLE_VLAN, addr, buf);\n}\n\nint ksz8_r_phy(struct ksz_device *dev, u16 phy, u16 reg, u16 *val)\n{\n\tu8 restart, speed, ctrl, link;\n\tint processed = true;\n\tconst u16 *regs;\n\tu8 val1, val2;\n\tu16 data = 0;\n\tu8 p = phy;\n\tint ret;\n\n\tregs = dev->info->regs;\n\n\tswitch (reg) {\n\tcase MII_BMCR:\n\t\tret = ksz_pread8(dev, p, regs[P_NEG_RESTART_CTRL], &restart);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ksz_pread8(dev, p, regs[P_SPEED_STATUS], &speed);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ksz_pread8(dev, p, regs[P_FORCE_CTRL], &ctrl);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (restart & PORT_PHY_LOOPBACK)\n\t\t\tdata |= BMCR_LOOPBACK;\n\t\tif (ctrl & PORT_FORCE_100_MBIT)\n\t\t\tdata |= BMCR_SPEED100;\n\t\tif (ksz_is_ksz88x3(dev)) {\n\t\t\tif ((ctrl & PORT_AUTO_NEG_ENABLE))\n\t\t\t\tdata |= BMCR_ANENABLE;\n\t\t} else {\n\t\t\tif (!(ctrl & PORT_AUTO_NEG_DISABLE))\n\t\t\t\tdata |= BMCR_ANENABLE;\n\t\t}\n\t\tif (restart & PORT_POWER_DOWN)\n\t\t\tdata |= BMCR_PDOWN;\n\t\tif (restart & PORT_AUTO_NEG_RESTART)\n\t\t\tdata |= BMCR_ANRESTART;\n\t\tif (ctrl & PORT_FORCE_FULL_DUPLEX)\n\t\t\tdata |= BMCR_FULLDPLX;\n\t\tif (speed & PORT_HP_MDIX)\n\t\t\tdata |= KSZ886X_BMCR_HP_MDIX;\n\t\tif (restart & PORT_FORCE_MDIX)\n\t\t\tdata |= KSZ886X_BMCR_FORCE_MDI;\n\t\tif (restart & PORT_AUTO_MDIX_DISABLE)\n\t\t\tdata |= KSZ886X_BMCR_DISABLE_AUTO_MDIX;\n\t\tif (restart & PORT_TX_DISABLE)\n\t\t\tdata |= KSZ886X_BMCR_DISABLE_TRANSMIT;\n\t\tif (restart & PORT_LED_OFF)\n\t\t\tdata |= KSZ886X_BMCR_DISABLE_LED;\n\t\tbreak;\n\tcase MII_BMSR:\n\t\tret = ksz_pread8(dev, p, regs[P_LINK_STATUS], &link);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata = BMSR_100FULL |\n\t\t       BMSR_100HALF |\n\t\t       BMSR_10FULL |\n\t\t       BMSR_10HALF |\n\t\t       BMSR_ANEGCAPABLE;\n\t\tif (link & PORT_AUTO_NEG_COMPLETE)\n\t\t\tdata |= BMSR_ANEGCOMPLETE;\n\t\tif (link & PORT_STAT_LINK_GOOD)\n\t\t\tdata |= BMSR_LSTATUS;\n\t\tbreak;\n\tcase MII_PHYSID1:\n\t\tdata = KSZ8795_ID_HI;\n\t\tbreak;\n\tcase MII_PHYSID2:\n\t\tif (ksz_is_ksz88x3(dev))\n\t\t\tdata = KSZ8863_ID_LO;\n\t\telse\n\t\t\tdata = KSZ8795_ID_LO;\n\t\tbreak;\n\tcase MII_ADVERTISE:\n\t\tret = ksz_pread8(dev, p, regs[P_LOCAL_CTRL], &ctrl);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata = ADVERTISE_CSMA;\n\t\tif (ctrl & PORT_AUTO_NEG_SYM_PAUSE)\n\t\t\tdata |= ADVERTISE_PAUSE_CAP;\n\t\tif (ctrl & PORT_AUTO_NEG_100BTX_FD)\n\t\t\tdata |= ADVERTISE_100FULL;\n\t\tif (ctrl & PORT_AUTO_NEG_100BTX)\n\t\t\tdata |= ADVERTISE_100HALF;\n\t\tif (ctrl & PORT_AUTO_NEG_10BT_FD)\n\t\t\tdata |= ADVERTISE_10FULL;\n\t\tif (ctrl & PORT_AUTO_NEG_10BT)\n\t\t\tdata |= ADVERTISE_10HALF;\n\t\tbreak;\n\tcase MII_LPA:\n\t\tret = ksz_pread8(dev, p, regs[P_REMOTE_STATUS], &link);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata = LPA_SLCT;\n\t\tif (link & PORT_REMOTE_SYM_PAUSE)\n\t\t\tdata |= LPA_PAUSE_CAP;\n\t\tif (link & PORT_REMOTE_100BTX_FD)\n\t\t\tdata |= LPA_100FULL;\n\t\tif (link & PORT_REMOTE_100BTX)\n\t\t\tdata |= LPA_100HALF;\n\t\tif (link & PORT_REMOTE_10BT_FD)\n\t\t\tdata |= LPA_10FULL;\n\t\tif (link & PORT_REMOTE_10BT)\n\t\t\tdata |= LPA_10HALF;\n\t\tif (data & ~LPA_SLCT)\n\t\t\tdata |= LPA_LPACK;\n\t\tbreak;\n\tcase PHY_REG_LINK_MD:\n\t\tret = ksz_pread8(dev, p, REG_PORT_LINK_MD_CTRL, &val1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ksz_pread8(dev, p, REG_PORT_LINK_MD_RESULT, &val2);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (val1 & PORT_START_CABLE_DIAG)\n\t\t\tdata |= PHY_START_CABLE_DIAG;\n\n\t\tif (val1 & PORT_CABLE_10M_SHORT)\n\t\t\tdata |= PHY_CABLE_10M_SHORT;\n\n\t\tdata |= FIELD_PREP(PHY_CABLE_DIAG_RESULT_M,\n\t\t\t\tFIELD_GET(PORT_CABLE_DIAG_RESULT_M, val1));\n\n\t\tdata |= FIELD_PREP(PHY_CABLE_FAULT_COUNTER_M,\n\t\t\t\t(FIELD_GET(PORT_CABLE_FAULT_COUNTER_H, val1) << 8) |\n\t\t\t\tFIELD_GET(PORT_CABLE_FAULT_COUNTER_L, val2));\n\t\tbreak;\n\tcase PHY_REG_PHY_CTRL:\n\t\tret = ksz_pread8(dev, p, regs[P_LINK_STATUS], &link);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (link & PORT_MDIX_STATUS)\n\t\t\tdata |= KSZ886X_CTRL_MDIX_STAT;\n\t\tbreak;\n\tdefault:\n\t\tprocessed = false;\n\t\tbreak;\n\t}\n\tif (processed)\n\t\t*val = data;\n\n\treturn 0;\n}\n\nint ksz8_w_phy(struct ksz_device *dev, u16 phy, u16 reg, u16 val)\n{\n\tu8 restart, speed, ctrl, data;\n\tconst u16 *regs;\n\tu8 p = phy;\n\tint ret;\n\n\tregs = dev->info->regs;\n\n\tswitch (reg) {\n\tcase MII_BMCR:\n\n\t\t \n\t\tif (val & BMCR_RESET)\n\t\t\tbreak;\n\t\tret = ksz_pread8(dev, p, regs[P_SPEED_STATUS], &speed);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata = speed;\n\t\tif (val & KSZ886X_BMCR_HP_MDIX)\n\t\t\tdata |= PORT_HP_MDIX;\n\t\telse\n\t\t\tdata &= ~PORT_HP_MDIX;\n\n\t\tif (data != speed) {\n\t\t\tret = ksz_pwrite8(dev, p, regs[P_SPEED_STATUS], data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tret = ksz_pread8(dev, p, regs[P_FORCE_CTRL], &ctrl);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata = ctrl;\n\t\tif (ksz_is_ksz88x3(dev)) {\n\t\t\tif ((val & BMCR_ANENABLE))\n\t\t\t\tdata |= PORT_AUTO_NEG_ENABLE;\n\t\t\telse\n\t\t\t\tdata &= ~PORT_AUTO_NEG_ENABLE;\n\t\t} else {\n\t\t\tif (!(val & BMCR_ANENABLE))\n\t\t\t\tdata |= PORT_AUTO_NEG_DISABLE;\n\t\t\telse\n\t\t\t\tdata &= ~PORT_AUTO_NEG_DISABLE;\n\n\t\t\t \n\t\t\tif (dev->ports[p].fiber)\n\t\t\t\tdata |= PORT_AUTO_NEG_DISABLE;\n\t\t}\n\n\t\tif (val & BMCR_SPEED100)\n\t\t\tdata |= PORT_FORCE_100_MBIT;\n\t\telse\n\t\t\tdata &= ~PORT_FORCE_100_MBIT;\n\t\tif (val & BMCR_FULLDPLX)\n\t\t\tdata |= PORT_FORCE_FULL_DUPLEX;\n\t\telse\n\t\t\tdata &= ~PORT_FORCE_FULL_DUPLEX;\n\n\t\tif (data != ctrl) {\n\t\t\tret = ksz_pwrite8(dev, p, regs[P_FORCE_CTRL], data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tret = ksz_pread8(dev, p, regs[P_NEG_RESTART_CTRL], &restart);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata = restart;\n\t\tif (val & KSZ886X_BMCR_DISABLE_LED)\n\t\t\tdata |= PORT_LED_OFF;\n\t\telse\n\t\t\tdata &= ~PORT_LED_OFF;\n\t\tif (val & KSZ886X_BMCR_DISABLE_TRANSMIT)\n\t\t\tdata |= PORT_TX_DISABLE;\n\t\telse\n\t\t\tdata &= ~PORT_TX_DISABLE;\n\t\tif (val & BMCR_ANRESTART)\n\t\t\tdata |= PORT_AUTO_NEG_RESTART;\n\t\telse\n\t\t\tdata &= ~(PORT_AUTO_NEG_RESTART);\n\t\tif (val & BMCR_PDOWN)\n\t\t\tdata |= PORT_POWER_DOWN;\n\t\telse\n\t\t\tdata &= ~PORT_POWER_DOWN;\n\t\tif (val & KSZ886X_BMCR_DISABLE_AUTO_MDIX)\n\t\t\tdata |= PORT_AUTO_MDIX_DISABLE;\n\t\telse\n\t\t\tdata &= ~PORT_AUTO_MDIX_DISABLE;\n\t\tif (val & KSZ886X_BMCR_FORCE_MDI)\n\t\t\tdata |= PORT_FORCE_MDIX;\n\t\telse\n\t\t\tdata &= ~PORT_FORCE_MDIX;\n\t\tif (val & BMCR_LOOPBACK)\n\t\t\tdata |= PORT_PHY_LOOPBACK;\n\t\telse\n\t\t\tdata &= ~PORT_PHY_LOOPBACK;\n\n\t\tif (data != restart) {\n\t\t\tret = ksz_pwrite8(dev, p, regs[P_NEG_RESTART_CTRL],\n\t\t\t\t\t  data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase MII_ADVERTISE:\n\t\tret = ksz_pread8(dev, p, regs[P_LOCAL_CTRL], &ctrl);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata = ctrl;\n\t\tdata &= ~(PORT_AUTO_NEG_SYM_PAUSE |\n\t\t\t  PORT_AUTO_NEG_100BTX_FD |\n\t\t\t  PORT_AUTO_NEG_100BTX |\n\t\t\t  PORT_AUTO_NEG_10BT_FD |\n\t\t\t  PORT_AUTO_NEG_10BT);\n\t\tif (val & ADVERTISE_PAUSE_CAP)\n\t\t\tdata |= PORT_AUTO_NEG_SYM_PAUSE;\n\t\tif (val & ADVERTISE_100FULL)\n\t\t\tdata |= PORT_AUTO_NEG_100BTX_FD;\n\t\tif (val & ADVERTISE_100HALF)\n\t\t\tdata |= PORT_AUTO_NEG_100BTX;\n\t\tif (val & ADVERTISE_10FULL)\n\t\t\tdata |= PORT_AUTO_NEG_10BT_FD;\n\t\tif (val & ADVERTISE_10HALF)\n\t\t\tdata |= PORT_AUTO_NEG_10BT;\n\n\t\tif (data != ctrl) {\n\t\t\tret = ksz_pwrite8(dev, p, regs[P_LOCAL_CTRL], data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase PHY_REG_LINK_MD:\n\t\tif (val & PHY_START_CABLE_DIAG)\n\t\t\tksz_port_cfg(dev, p, REG_PORT_LINK_MD_CTRL, PORT_START_CABLE_DIAG, true);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nvoid ksz8_cfg_port_member(struct ksz_device *dev, int port, u8 member)\n{\n\tu8 data;\n\n\tksz_pread8(dev, port, P_MIRROR_CTRL, &data);\n\tdata &= ~PORT_VLAN_MEMBERSHIP;\n\tdata |= (member & dev->port_mask);\n\tksz_pwrite8(dev, port, P_MIRROR_CTRL, data);\n}\n\nvoid ksz8_flush_dyn_mac_table(struct ksz_device *dev, int port)\n{\n\tu8 learn[DSA_MAX_PORTS];\n\tint first, index, cnt;\n\tconst u16 *regs;\n\n\tregs = dev->info->regs;\n\n\tif ((uint)port < dev->info->port_cnt) {\n\t\tfirst = port;\n\t\tcnt = port + 1;\n\t} else {\n\t\t \n\t\tfirst = 0;\n\t\tcnt = dev->info->port_cnt;\n\t}\n\tfor (index = first; index < cnt; index++) {\n\t\tksz_pread8(dev, index, regs[P_STP_CTRL], &learn[index]);\n\t\tif (!(learn[index] & PORT_LEARN_DISABLE))\n\t\t\tksz_pwrite8(dev, index, regs[P_STP_CTRL],\n\t\t\t\t    learn[index] | PORT_LEARN_DISABLE);\n\t}\n\tksz_cfg(dev, S_FLUSH_TABLE_CTRL, SW_FLUSH_DYN_MAC_TABLE, true);\n\tfor (index = first; index < cnt; index++) {\n\t\tif (!(learn[index] & PORT_LEARN_DISABLE))\n\t\t\tksz_pwrite8(dev, index, regs[P_STP_CTRL], learn[index]);\n\t}\n}\n\nint ksz8_fdb_dump(struct ksz_device *dev, int port,\n\t\t  dsa_fdb_dump_cb_t *cb, void *data)\n{\n\tint ret = 0;\n\tu16 i = 0;\n\tu16 entries = 0;\n\tu8 timestamp = 0;\n\tu8 fid;\n\tu8 src_port;\n\tu8 mac[ETH_ALEN];\n\n\tdo {\n\t\tret = ksz8_r_dyn_mac_table(dev, i, mac, &fid, &src_port,\n\t\t\t\t\t   &timestamp, &entries);\n\t\tif (!ret && port == src_port) {\n\t\t\tret = cb(mac, fid, false, data);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t} while (i < entries);\n\tif (i >= entries)\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic int ksz8_add_sta_mac(struct ksz_device *dev, int port,\n\t\t\t    const unsigned char *addr, u16 vid)\n{\n\tstruct alu_struct alu;\n\tint index, ret;\n\tint empty = 0;\n\n\talu.port_forward = 0;\n\tfor (index = 0; index < dev->info->num_statics; index++) {\n\t\tbool valid;\n\n\t\tret = ksz8_r_sta_mac_table(dev, index, &alu, &valid);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (!valid) {\n\t\t\t \n\t\t\tif (!empty)\n\t\t\t\tempty = index + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!memcmp(alu.mac, addr, ETH_ALEN) && alu.fid == vid)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (index == dev->info->num_statics && !empty)\n\t\treturn -ENOSPC;\n\n\t \n\tif (index == dev->info->num_statics) {\n\t\tindex = empty - 1;\n\t\tmemset(&alu, 0, sizeof(alu));\n\t\tmemcpy(alu.mac, addr, ETH_ALEN);\n\t\talu.is_static = true;\n\t}\n\talu.port_forward |= BIT(port);\n\tif (vid) {\n\t\talu.is_use_fid = true;\n\n\t\t \n\t\talu.fid = vid;\n\t}\n\n\treturn ksz8_w_sta_mac_table(dev, index, &alu);\n}\n\nstatic int ksz8_del_sta_mac(struct ksz_device *dev, int port,\n\t\t\t    const unsigned char *addr, u16 vid)\n{\n\tstruct alu_struct alu;\n\tint index, ret;\n\n\tfor (index = 0; index < dev->info->num_statics; index++) {\n\t\tbool valid;\n\n\t\tret = ksz8_r_sta_mac_table(dev, index, &alu, &valid);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (!valid)\n\t\t\tcontinue;\n\n\t\tif (!memcmp(alu.mac, addr, ETH_ALEN) && alu.fid == vid)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (index == dev->info->num_statics)\n\t\treturn 0;\n\n\t \n\talu.port_forward &= ~BIT(port);\n\tif (!alu.port_forward)\n\t\talu.is_static = false;\n\n\treturn ksz8_w_sta_mac_table(dev, index, &alu);\n}\n\nint ksz8_mdb_add(struct ksz_device *dev, int port,\n\t\t const struct switchdev_obj_port_mdb *mdb, struct dsa_db db)\n{\n\treturn ksz8_add_sta_mac(dev, port, mdb->addr, mdb->vid);\n}\n\nint ksz8_mdb_del(struct ksz_device *dev, int port,\n\t\t const struct switchdev_obj_port_mdb *mdb, struct dsa_db db)\n{\n\treturn ksz8_del_sta_mac(dev, port, mdb->addr, mdb->vid);\n}\n\nint ksz8_fdb_add(struct ksz_device *dev, int port, const unsigned char *addr,\n\t\t u16 vid, struct dsa_db db)\n{\n\treturn ksz8_add_sta_mac(dev, port, addr, vid);\n}\n\nint ksz8_fdb_del(struct ksz_device *dev, int port, const unsigned char *addr,\n\t\t u16 vid, struct dsa_db db)\n{\n\treturn ksz8_del_sta_mac(dev, port, addr, vid);\n}\n\nint ksz8_port_vlan_filtering(struct ksz_device *dev, int port, bool flag,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tif (ksz_is_ksz88x3(dev))\n\t\treturn -ENOTSUPP;\n\n\t \n\tksz_cfg(dev, S_MIRROR_CTRL, SW_VLAN_ENABLE, flag);\n\n\t \n\tfor (port = 0; port < dev->phy_port_cnt; ++port)\n\t\tksz_port_cfg(dev, port, REG_PORT_CTRL_2, PORT_INGRESS_FILTER,\n\t\t\t     flag);\n\n\treturn 0;\n}\n\nstatic void ksz8_port_enable_pvid(struct ksz_device *dev, int port, bool state)\n{\n\tif (ksz_is_ksz88x3(dev)) {\n\t\tksz_cfg(dev, REG_SW_INSERT_SRC_PVID,\n\t\t\t0x03 << (4 - 2 * port), state);\n\t} else {\n\t\tksz_pwrite8(dev, port, REG_PORT_CTRL_12, state ? 0x0f : 0x00);\n\t}\n}\n\nint ksz8_port_vlan_add(struct ksz_device *dev, int port,\n\t\t       const struct switchdev_obj_port_vlan *vlan,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tbool untagged = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;\n\tstruct ksz_port *p = &dev->ports[port];\n\tu16 data, new_pvid = 0;\n\tu8 fid, member, valid;\n\n\tif (ksz_is_ksz88x3(dev))\n\t\treturn -ENOTSUPP;\n\n\t \n\tif (untagged != p->remove_tag && vlan->vid != 0 &&\n\t    port != dev->cpu_port) {\n\t\tunsigned int vid;\n\n\t\t \n\t\tfor (vid = 1; vid < dev->info->num_vlans; ++vid) {\n\t\t\t \n\t\t\tif (vid == vlan->vid)\n\t\t\t\tcontinue;\n\n\t\t\tksz8_from_vlan(dev, dev->vlan_cache[vid].table[0],\n\t\t\t\t       &fid, &member, &valid);\n\t\t\tif (valid && (member & BIT(port)))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tksz_port_cfg(dev, port, P_TAG_CTRL, PORT_REMOVE_TAG, untagged);\n\t\tp->remove_tag = untagged;\n\t}\n\n\tksz8_r_vlan_table(dev, vlan->vid, &data);\n\tksz8_from_vlan(dev, data, &fid, &member, &valid);\n\n\t \n\tif (!valid) {\n\t\t \n\t\tfid = 1;\n\t\tvalid = 1;\n\t}\n\tmember |= BIT(port);\n\n\tksz8_to_vlan(dev, fid, member, valid, &data);\n\tksz8_w_vlan_table(dev, vlan->vid, data);\n\n\t \n\tif (vlan->flags & BRIDGE_VLAN_INFO_PVID)\n\t\tnew_pvid = vlan->vid;\n\n\tif (new_pvid) {\n\t\tu16 vid;\n\n\t\tksz_pread16(dev, port, REG_PORT_CTRL_VID, &vid);\n\t\tvid &= ~VLAN_VID_MASK;\n\t\tvid |= new_pvid;\n\t\tksz_pwrite16(dev, port, REG_PORT_CTRL_VID, vid);\n\n\t\tksz8_port_enable_pvid(dev, port, true);\n\t}\n\n\treturn 0;\n}\n\nint ksz8_port_vlan_del(struct ksz_device *dev, int port,\n\t\t       const struct switchdev_obj_port_vlan *vlan)\n{\n\tu16 data, pvid;\n\tu8 fid, member, valid;\n\n\tif (ksz_is_ksz88x3(dev))\n\t\treturn -ENOTSUPP;\n\n\tksz_pread16(dev, port, REG_PORT_CTRL_VID, &pvid);\n\tpvid = pvid & 0xFFF;\n\n\tksz8_r_vlan_table(dev, vlan->vid, &data);\n\tksz8_from_vlan(dev, data, &fid, &member, &valid);\n\n\tmember &= ~BIT(port);\n\n\t \n\tif (!member) {\n\t\tfid = 0;\n\t\tvalid = 0;\n\t}\n\n\tksz8_to_vlan(dev, fid, member, valid, &data);\n\tksz8_w_vlan_table(dev, vlan->vid, data);\n\n\tif (pvid == vlan->vid)\n\t\tksz8_port_enable_pvid(dev, port, false);\n\n\treturn 0;\n}\n\nint ksz8_port_mirror_add(struct ksz_device *dev, int port,\n\t\t\t struct dsa_mall_mirror_tc_entry *mirror,\n\t\t\t bool ingress, struct netlink_ext_ack *extack)\n{\n\tif (ingress) {\n\t\tksz_port_cfg(dev, port, P_MIRROR_CTRL, PORT_MIRROR_RX, true);\n\t\tdev->mirror_rx |= BIT(port);\n\t} else {\n\t\tksz_port_cfg(dev, port, P_MIRROR_CTRL, PORT_MIRROR_TX, true);\n\t\tdev->mirror_tx |= BIT(port);\n\t}\n\n\tksz_port_cfg(dev, port, P_MIRROR_CTRL, PORT_MIRROR_SNIFFER, false);\n\n\t \n\tif (dev->mirror_rx || dev->mirror_tx)\n\t\tksz_port_cfg(dev, mirror->to_local_port, P_MIRROR_CTRL,\n\t\t\t     PORT_MIRROR_SNIFFER, true);\n\n\treturn 0;\n}\n\nvoid ksz8_port_mirror_del(struct ksz_device *dev, int port,\n\t\t\t  struct dsa_mall_mirror_tc_entry *mirror)\n{\n\tu8 data;\n\n\tif (mirror->ingress) {\n\t\tksz_port_cfg(dev, port, P_MIRROR_CTRL, PORT_MIRROR_RX, false);\n\t\tdev->mirror_rx &= ~BIT(port);\n\t} else {\n\t\tksz_port_cfg(dev, port, P_MIRROR_CTRL, PORT_MIRROR_TX, false);\n\t\tdev->mirror_tx &= ~BIT(port);\n\t}\n\n\tksz_pread8(dev, port, P_MIRROR_CTRL, &data);\n\n\tif (!dev->mirror_rx && !dev->mirror_tx)\n\t\tksz_port_cfg(dev, mirror->to_local_port, P_MIRROR_CTRL,\n\t\t\t     PORT_MIRROR_SNIFFER, false);\n}\n\nstatic void ksz8795_cpu_interface_select(struct ksz_device *dev, int port)\n{\n\tstruct ksz_port *p = &dev->ports[port];\n\n\tif (!p->interface && dev->compat_interface) {\n\t\tdev_warn(dev->dev,\n\t\t\t \"Using legacy switch \\\"phy-mode\\\" property, because it is missing on port %d node. \"\n\t\t\t \"Please update your device tree.\\n\",\n\t\t\t port);\n\t\tp->interface = dev->compat_interface;\n\t}\n}\n\nvoid ksz8_port_setup(struct ksz_device *dev, int port, bool cpu_port)\n{\n\tstruct dsa_switch *ds = dev->ds;\n\tconst u32 *masks;\n\tu8 member;\n\n\tmasks = dev->info->masks;\n\n\t \n\tksz_port_cfg(dev, port, P_BCAST_STORM_CTRL, PORT_BROADCAST_STORM, true);\n\n\tif (!ksz_is_ksz88x3(dev))\n\t\tksz8795_set_prio_queue(dev, port, 4);\n\n\t \n\tksz_port_cfg(dev, port, P_PRIO_CTRL, PORT_DIFFSERV_ENABLE, false);\n\n\t \n\tksz_port_cfg(dev, port, P_802_1P_CTRL,\n\t\t     masks[PORT_802_1P_REMAPPING], false);\n\n\t \n\tksz_port_cfg(dev, port, P_PRIO_CTRL, PORT_802_1P_ENABLE, true);\n\n\tif (cpu_port) {\n\t\tif (!ksz_is_ksz88x3(dev))\n\t\t\tksz8795_cpu_interface_select(dev, port);\n\n\t\tmember = dsa_user_ports(ds);\n\t} else {\n\t\tmember = BIT(dsa_upstream_port(ds, port));\n\t}\n\n\tksz8_cfg_port_member(dev, port, member);\n}\n\nvoid ksz8_config_cpu_port(struct dsa_switch *ds)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tstruct ksz_port *p;\n\tconst u32 *masks;\n\tconst u16 *regs;\n\tu8 remote;\n\tint i;\n\n\tmasks = dev->info->masks;\n\tregs = dev->info->regs;\n\n\tksz_cfg(dev, regs[S_TAIL_TAG_CTRL], masks[SW_TAIL_TAG_ENABLE], true);\n\n\tksz8_port_setup(dev, dev->cpu_port, true);\n\n\tfor (i = 0; i < dev->phy_port_cnt; i++) {\n\t\tksz_port_stp_state_set(ds, i, BR_STATE_DISABLED);\n\t}\n\tfor (i = 0; i < dev->phy_port_cnt; i++) {\n\t\tp = &dev->ports[i];\n\n\t\tif (!ksz_is_ksz88x3(dev)) {\n\t\t\tksz_pread8(dev, i, regs[P_REMOTE_STATUS], &remote);\n\t\t\tif (remote & KSZ8_PORT_FIBER_MODE)\n\t\t\t\tp->fiber = 1;\n\t\t}\n\t\tif (p->fiber)\n\t\t\tksz_port_cfg(dev, i, regs[P_STP_CTRL],\n\t\t\t\t     PORT_FORCE_FLOW_CTRL, true);\n\t\telse\n\t\t\tksz_port_cfg(dev, i, regs[P_STP_CTRL],\n\t\t\t\t     PORT_FORCE_FLOW_CTRL, false);\n\t}\n}\n\nstatic int ksz8_handle_global_errata(struct dsa_switch *ds)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tint ret = 0;\n\n\t \n\tif (dev->info->ksz87xx_eee_link_erratum)\n\t\tret = ksz8_ind_write8(dev, TABLE_EEE, REG_IND_EEE_GLOB2_HI, 0);\n\n\treturn ret;\n}\n\nint ksz8_enable_stp_addr(struct ksz_device *dev)\n{\n\tstruct alu_struct alu;\n\n\t \n\tmemset(&alu, 0, sizeof(alu));\n\tether_addr_copy(alu.mac, eth_stp_addr);\n\talu.is_static = true;\n\talu.is_override = true;\n\talu.port_forward = dev->info->cpu_ports;\n\n\treturn ksz8_w_sta_mac_table(dev, 0, &alu);\n}\n\nint ksz8_setup(struct dsa_switch *ds)\n{\n\tstruct ksz_device *dev = ds->priv;\n\tint i;\n\n\tds->mtu_enforcement_ingress = true;\n\n\t \n\tds->untag_bridge_pvid = true;\n\n\t \n\tds->vlan_filtering_is_global = true;\n\n\tksz_cfg(dev, S_REPLACE_VID_CTRL, SW_FLOW_CTRL, true);\n\n\t \n\tksz_cfg(dev, S_LINK_AGING_CTRL, SW_LINK_AUTO_AGING, true);\n\n\t \n\tregmap_update_bits(ksz_regmap_8(dev), REG_SW_CTRL_1,\n\t\t\t   SW_AGGR_BACKOFF, SW_AGGR_BACKOFF);\n\n\t \n\tregmap_update_bits(ksz_regmap_8(dev), REG_SW_CTRL_2,\n\t\t\t   UNICAST_VLAN_BOUNDARY | NO_EXC_COLLISION_DROP,\n\t\t\t   UNICAST_VLAN_BOUNDARY | NO_EXC_COLLISION_DROP);\n\n\tksz_cfg(dev, S_REPLACE_VID_CTRL, SW_REPLACE_VID, false);\n\n\tksz_cfg(dev, S_MIRROR_CTRL, SW_MIRROR_RX_TX, false);\n\n\tif (!ksz_is_ksz88x3(dev))\n\t\tksz_cfg(dev, REG_SW_CTRL_19, SW_INS_TAG_ENABLE, true);\n\n\tfor (i = 0; i < (dev->info->num_vlans / 4); i++)\n\t\tksz8_r_vlan_entries(dev, i);\n\n\treturn ksz8_handle_global_errata(ds);\n}\n\nvoid ksz8_get_caps(struct ksz_device *dev, int port,\n\t\t   struct phylink_config *config)\n{\n\tconfig->mac_capabilities = MAC_10 | MAC_100;\n\n\t \n\tif (!ksz_is_ksz88x3(dev) || port)\n\t\tconfig->mac_capabilities |= MAC_SYM_PAUSE;\n\n\t \n\tif (!ksz_is_ksz88x3(dev))\n\t\tconfig->mac_capabilities |= MAC_ASYM_PAUSE;\n}\n\nu32 ksz8_get_port_addr(int port, int offset)\n{\n\treturn PORT_CTRL_ADDR(port, offset);\n}\n\nint ksz8_switch_init(struct ksz_device *dev)\n{\n\tdev->cpu_port = fls(dev->info->cpu_ports) - 1;\n\tdev->phy_port_cnt = dev->info->port_cnt - 1;\n\tdev->port_mask = (BIT(dev->phy_port_cnt) - 1) | dev->info->cpu_ports;\n\n\treturn 0;\n}\n\nvoid ksz8_switch_exit(struct ksz_device *dev)\n{\n\tksz8_reset_switch(dev);\n}\n\nMODULE_AUTHOR(\"Tristram Ha <Tristram.Ha@microchip.com>\");\nMODULE_DESCRIPTION(\"Microchip KSZ8795 Series Switch DSA Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}