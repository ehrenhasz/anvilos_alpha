{
  "module_name": "ksz8863_smi.c",
  "hash_id": "c30d3297d879e4adfa7cdbe37b7ae3fe158f3d05e254097515bdbfafdf64942c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/microchip/ksz8863_smi.c",
  "human_readable_source": "\n \n\n#include <linux/mod_devicetable.h>\n#include <linux/property.h>\n\n#include \"ksz8.h\"\n#include \"ksz_common.h\"\n\n \n\n#define SMI_KSZ88XX_READ_PHY\tBIT(4)\n\nstatic int ksz8863_mdio_read(void *ctx, const void *reg_buf, size_t reg_len,\n\t\t\t     void *val_buf, size_t val_len)\n{\n\tstruct ksz_device *dev = ctx;\n\tstruct mdio_device *mdev;\n\tu8 reg = *(u8 *)reg_buf;\n\tu8 *val = val_buf;\n\tint i, ret = 0;\n\n\tmdev = dev->priv;\n\n\tmutex_lock_nested(&mdev->bus->mdio_lock, MDIO_MUTEX_NESTED);\n\tfor (i = 0; i < val_len; i++) {\n\t\tint tmp = reg + i;\n\n\t\tret = __mdiobus_read(mdev->bus, ((tmp & 0xE0) >> 5) |\n\t\t\t\t     SMI_KSZ88XX_READ_PHY, tmp);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tval[i] = ret;\n\t}\n\tret = 0;\n\n out:\n\tmutex_unlock(&mdev->bus->mdio_lock);\n\n\treturn ret;\n}\n\nstatic int ksz8863_mdio_write(void *ctx, const void *data, size_t count)\n{\n\tstruct ksz_device *dev = ctx;\n\tstruct mdio_device *mdev;\n\tint i, ret = 0;\n\tu32 reg;\n\tu8 *val;\n\n\tmdev = dev->priv;\n\n\tval = (u8 *)(data + 4);\n\treg = *(u32 *)data;\n\n\tmutex_lock_nested(&mdev->bus->mdio_lock, MDIO_MUTEX_NESTED);\n\tfor (i = 0; i < (count - 4); i++) {\n\t\tint tmp = reg + i;\n\n\t\tret = __mdiobus_write(mdev->bus, ((tmp & 0xE0) >> 5),\n\t\t\t\t      tmp, val[i]);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n out:\n\tmutex_unlock(&mdev->bus->mdio_lock);\n\n\treturn ret;\n}\n\nstatic const struct regmap_bus regmap_smi[] = {\n\t{\n\t\t.read = ksz8863_mdio_read,\n\t\t.write = ksz8863_mdio_write,\n\t},\n\t{\n\t\t.read = ksz8863_mdio_read,\n\t\t.write = ksz8863_mdio_write,\n\t\t.val_format_endian_default = REGMAP_ENDIAN_BIG,\n\t},\n\t{\n\t\t.read = ksz8863_mdio_read,\n\t\t.write = ksz8863_mdio_write,\n\t\t.val_format_endian_default = REGMAP_ENDIAN_BIG,\n\t}\n};\n\nstatic const struct regmap_config ksz8863_regmap_config[] = {\n\t{\n\t\t.name = \"#8\",\n\t\t.reg_bits = 8,\n\t\t.pad_bits = 24,\n\t\t.val_bits = 8,\n\t\t.cache_type = REGCACHE_NONE,\n\t\t.lock = ksz_regmap_lock,\n\t\t.unlock = ksz_regmap_unlock,\n\t\t.max_register = U8_MAX,\n\t},\n\t{\n\t\t.name = \"#16\",\n\t\t.reg_bits = 8,\n\t\t.pad_bits = 24,\n\t\t.val_bits = 16,\n\t\t.cache_type = REGCACHE_NONE,\n\t\t.lock = ksz_regmap_lock,\n\t\t.unlock = ksz_regmap_unlock,\n\t\t.max_register = U8_MAX,\n\t},\n\t{\n\t\t.name = \"#32\",\n\t\t.reg_bits = 8,\n\t\t.pad_bits = 24,\n\t\t.val_bits = 32,\n\t\t.cache_type = REGCACHE_NONE,\n\t\t.lock = ksz_regmap_lock,\n\t\t.unlock = ksz_regmap_unlock,\n\t\t.max_register = U8_MAX,\n\t}\n};\n\nstatic int ksz8863_smi_probe(struct mdio_device *mdiodev)\n{\n\tstruct device *ddev = &mdiodev->dev;\n\tconst struct ksz_chip_data *chip;\n\tstruct regmap_config rc;\n\tstruct ksz_device *dev;\n\tint ret;\n\tint i;\n\n\tdev = ksz_switch_alloc(&mdiodev->dev, mdiodev);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tchip = device_get_match_data(ddev);\n\tif (!chip)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < __KSZ_NUM_REGMAPS; i++) {\n\t\trc = ksz8863_regmap_config[i];\n\t\trc.lock_arg = &dev->regmap_mutex;\n\t\trc.wr_table = chip->wr_table;\n\t\trc.rd_table = chip->rd_table;\n\t\tdev->regmap[i] = devm_regmap_init(&mdiodev->dev,\n\t\t\t\t\t\t  &regmap_smi[i], dev,\n\t\t\t\t\t\t  &rc);\n\t\tif (IS_ERR(dev->regmap[i])) {\n\t\t\treturn dev_err_probe(&mdiodev->dev,\n\t\t\t\t\t     PTR_ERR(dev->regmap[i]),\n\t\t\t\t\t     \"Failed to initialize regmap%i\\n\",\n\t\t\t\t\t     ksz8863_regmap_config[i].val_bits);\n\t\t}\n\t}\n\n\tif (mdiodev->dev.platform_data)\n\t\tdev->pdata = mdiodev->dev.platform_data;\n\n\tret = ksz_switch_register(dev);\n\n\t \n\tif (ret)\n\t\treturn ret;\n\n\tdev_set_drvdata(&mdiodev->dev, dev);\n\n\treturn 0;\n}\n\nstatic void ksz8863_smi_remove(struct mdio_device *mdiodev)\n{\n\tstruct ksz_device *dev = dev_get_drvdata(&mdiodev->dev);\n\n\tif (dev)\n\t\tksz_switch_remove(dev);\n}\n\nstatic void ksz8863_smi_shutdown(struct mdio_device *mdiodev)\n{\n\tstruct ksz_device *dev = dev_get_drvdata(&mdiodev->dev);\n\n\tif (dev)\n\t\tdsa_switch_shutdown(dev->ds);\n\n\tdev_set_drvdata(&mdiodev->dev, NULL);\n}\n\nstatic const struct of_device_id ksz8863_dt_ids[] = {\n\t{\n\t\t.compatible = \"microchip,ksz8863\",\n\t\t.data = &ksz_switch_chips[KSZ8830]\n\t},\n\t{\n\t\t.compatible = \"microchip,ksz8873\",\n\t\t.data = &ksz_switch_chips[KSZ8830]\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ksz8863_dt_ids);\n\nstatic struct mdio_driver ksz8863_driver = {\n\t.probe\t= ksz8863_smi_probe,\n\t.remove\t= ksz8863_smi_remove,\n\t.shutdown = ksz8863_smi_shutdown,\n\t.mdiodrv.driver = {\n\t\t.name\t= \"ksz8863-switch\",\n\t\t.of_match_table = ksz8863_dt_ids,\n\t},\n};\n\nmdio_module_driver(ksz8863_driver);\n\nMODULE_AUTHOR(\"Michael Grzeschik <m.grzeschik@pengutronix.de>\");\nMODULE_DESCRIPTION(\"Microchip KSZ8863 SMI Switch driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}