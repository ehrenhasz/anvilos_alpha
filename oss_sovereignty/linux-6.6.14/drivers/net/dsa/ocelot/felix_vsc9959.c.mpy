{
  "module_name": "felix_vsc9959.c",
  "hash_id": "6599e3a650f63d5bcf50279bccb5daa6b09a0b47c2151e657a824f1e1104bf36",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/ocelot/felix_vsc9959.c",
  "human_readable_source": "\n \n#include <linux/fsl/enetc_mdio.h>\n#include <soc/mscc/ocelot_qsys.h>\n#include <soc/mscc/ocelot_vcap.h>\n#include <soc/mscc/ocelot_ana.h>\n#include <soc/mscc/ocelot_dev.h>\n#include <soc/mscc/ocelot_ptp.h>\n#include <soc/mscc/ocelot_sys.h>\n#include <net/tc_act/tc_gate.h>\n#include <soc/mscc/ocelot.h>\n#include <linux/dsa/ocelot.h>\n#include <linux/pcs-lynx.h>\n#include <net/pkt_sched.h>\n#include <linux/iopoll.h>\n#include <linux/mdio.h>\n#include <linux/of.h>\n#include <linux/pci.h>\n#include <linux/time.h>\n#include \"felix.h\"\n\n#define VSC9959_NUM_PORTS\t\t6\n\n#define VSC9959_TAS_GCL_ENTRY_MAX\t63\n#define VSC9959_TAS_MIN_GATE_LEN_NS\t33\n#define VSC9959_VCAP_POLICER_BASE\t63\n#define VSC9959_VCAP_POLICER_MAX\t383\n#define VSC9959_SWITCH_PCI_BAR\t\t4\n#define VSC9959_IMDIO_PCI_BAR\t\t0\n\n#define VSC9959_PORT_MODE_SERDES\t(OCELOT_PORT_MODE_SGMII | \\\n\t\t\t\t\t OCELOT_PORT_MODE_QSGMII | \\\n\t\t\t\t\t OCELOT_PORT_MODE_1000BASEX | \\\n\t\t\t\t\t OCELOT_PORT_MODE_2500BASEX | \\\n\t\t\t\t\t OCELOT_PORT_MODE_USXGMII)\n\nstatic const u32 vsc9959_port_modes[VSC9959_NUM_PORTS] = {\n\tVSC9959_PORT_MODE_SERDES,\n\tVSC9959_PORT_MODE_SERDES,\n\tVSC9959_PORT_MODE_SERDES,\n\tVSC9959_PORT_MODE_SERDES,\n\tOCELOT_PORT_MODE_INTERNAL,\n\tOCELOT_PORT_MODE_INTERNAL,\n};\n\nstatic const u32 vsc9959_ana_regmap[] = {\n\tREG(ANA_ADVLEARN,\t\t\t0x0089a0),\n\tREG(ANA_VLANMASK,\t\t\t0x0089a4),\n\tREG_RESERVED(ANA_PORT_B_DOMAIN),\n\tREG(ANA_ANAGEFIL,\t\t\t0x0089ac),\n\tREG(ANA_ANEVENTS,\t\t\t0x0089b0),\n\tREG(ANA_STORMLIMIT_BURST,\t\t0x0089b4),\n\tREG(ANA_STORMLIMIT_CFG,\t\t\t0x0089b8),\n\tREG(ANA_ISOLATED_PORTS,\t\t\t0x0089c8),\n\tREG(ANA_COMMUNITY_PORTS,\t\t0x0089cc),\n\tREG(ANA_AUTOAGE,\t\t\t0x0089d0),\n\tREG(ANA_MACTOPTIONS,\t\t\t0x0089d4),\n\tREG(ANA_LEARNDISC,\t\t\t0x0089d8),\n\tREG(ANA_AGENCTRL,\t\t\t0x0089dc),\n\tREG(ANA_MIRRORPORTS,\t\t\t0x0089e0),\n\tREG(ANA_EMIRRORPORTS,\t\t\t0x0089e4),\n\tREG(ANA_FLOODING,\t\t\t0x0089e8),\n\tREG(ANA_FLOODING_IPMC,\t\t\t0x008a08),\n\tREG(ANA_SFLOW_CFG,\t\t\t0x008a0c),\n\tREG(ANA_PORT_MODE,\t\t\t0x008a28),\n\tREG(ANA_CUT_THRU_CFG,\t\t\t0x008a48),\n\tREG(ANA_PGID_PGID,\t\t\t0x008400),\n\tREG(ANA_TABLES_ANMOVED,\t\t\t0x007f1c),\n\tREG(ANA_TABLES_MACHDATA,\t\t0x007f20),\n\tREG(ANA_TABLES_MACLDATA,\t\t0x007f24),\n\tREG(ANA_TABLES_STREAMDATA,\t\t0x007f28),\n\tREG(ANA_TABLES_MACACCESS,\t\t0x007f2c),\n\tREG(ANA_TABLES_MACTINDX,\t\t0x007f30),\n\tREG(ANA_TABLES_VLANACCESS,\t\t0x007f34),\n\tREG(ANA_TABLES_VLANTIDX,\t\t0x007f38),\n\tREG(ANA_TABLES_ISDXACCESS,\t\t0x007f3c),\n\tREG(ANA_TABLES_ISDXTIDX,\t\t0x007f40),\n\tREG(ANA_TABLES_ENTRYLIM,\t\t0x007f00),\n\tREG(ANA_TABLES_PTP_ID_HIGH,\t\t0x007f44),\n\tREG(ANA_TABLES_PTP_ID_LOW,\t\t0x007f48),\n\tREG(ANA_TABLES_STREAMACCESS,\t\t0x007f4c),\n\tREG(ANA_TABLES_STREAMTIDX,\t\t0x007f50),\n\tREG(ANA_TABLES_SEQ_HISTORY,\t\t0x007f54),\n\tREG(ANA_TABLES_SEQ_MASK,\t\t0x007f58),\n\tREG(ANA_TABLES_SFID_MASK,\t\t0x007f5c),\n\tREG(ANA_TABLES_SFIDACCESS,\t\t0x007f60),\n\tREG(ANA_TABLES_SFIDTIDX,\t\t0x007f64),\n\tREG(ANA_MSTI_STATE,\t\t\t0x008600),\n\tREG(ANA_OAM_UPM_LM_CNT,\t\t\t0x008000),\n\tREG(ANA_SG_ACCESS_CTRL,\t\t\t0x008a64),\n\tREG(ANA_SG_CONFIG_REG_1,\t\t0x007fb0),\n\tREG(ANA_SG_CONFIG_REG_2,\t\t0x007fb4),\n\tREG(ANA_SG_CONFIG_REG_3,\t\t0x007fb8),\n\tREG(ANA_SG_CONFIG_REG_4,\t\t0x007fbc),\n\tREG(ANA_SG_CONFIG_REG_5,\t\t0x007fc0),\n\tREG(ANA_SG_GCL_GS_CONFIG,\t\t0x007f80),\n\tREG(ANA_SG_GCL_TI_CONFIG,\t\t0x007f90),\n\tREG(ANA_SG_STATUS_REG_1,\t\t0x008980),\n\tREG(ANA_SG_STATUS_REG_2,\t\t0x008984),\n\tREG(ANA_SG_STATUS_REG_3,\t\t0x008988),\n\tREG(ANA_PORT_VLAN_CFG,\t\t\t0x007800),\n\tREG(ANA_PORT_DROP_CFG,\t\t\t0x007804),\n\tREG(ANA_PORT_QOS_CFG,\t\t\t0x007808),\n\tREG(ANA_PORT_VCAP_CFG,\t\t\t0x00780c),\n\tREG(ANA_PORT_VCAP_S1_KEY_CFG,\t\t0x007810),\n\tREG(ANA_PORT_VCAP_S2_CFG,\t\t0x00781c),\n\tREG(ANA_PORT_PCP_DEI_MAP,\t\t0x007820),\n\tREG(ANA_PORT_CPU_FWD_CFG,\t\t0x007860),\n\tREG(ANA_PORT_CPU_FWD_BPDU_CFG,\t\t0x007864),\n\tREG(ANA_PORT_CPU_FWD_GARP_CFG,\t\t0x007868),\n\tREG(ANA_PORT_CPU_FWD_CCM_CFG,\t\t0x00786c),\n\tREG(ANA_PORT_PORT_CFG,\t\t\t0x007870),\n\tREG(ANA_PORT_POL_CFG,\t\t\t0x007874),\n\tREG(ANA_PORT_PTP_CFG,\t\t\t0x007878),\n\tREG(ANA_PORT_PTP_DLY1_CFG,\t\t0x00787c),\n\tREG(ANA_PORT_PTP_DLY2_CFG,\t\t0x007880),\n\tREG(ANA_PORT_SFID_CFG,\t\t\t0x007884),\n\tREG(ANA_PFC_PFC_CFG,\t\t\t0x008800),\n\tREG_RESERVED(ANA_PFC_PFC_TIMER),\n\tREG_RESERVED(ANA_IPT_OAM_MEP_CFG),\n\tREG_RESERVED(ANA_IPT_IPT),\n\tREG_RESERVED(ANA_PPT_PPT),\n\tREG_RESERVED(ANA_FID_MAP_FID_MAP),\n\tREG(ANA_AGGR_CFG,\t\t\t0x008a68),\n\tREG(ANA_CPUQ_CFG,\t\t\t0x008a6c),\n\tREG_RESERVED(ANA_CPUQ_CFG2),\n\tREG(ANA_CPUQ_8021_CFG,\t\t\t0x008a74),\n\tREG(ANA_DSCP_CFG,\t\t\t0x008ab4),\n\tREG(ANA_DSCP_REWR_CFG,\t\t\t0x008bb4),\n\tREG(ANA_VCAP_RNG_TYPE_CFG,\t\t0x008bf4),\n\tREG(ANA_VCAP_RNG_VAL_CFG,\t\t0x008c14),\n\tREG_RESERVED(ANA_VRAP_CFG),\n\tREG_RESERVED(ANA_VRAP_HDR_DATA),\n\tREG_RESERVED(ANA_VRAP_HDR_MASK),\n\tREG(ANA_DISCARD_CFG,\t\t\t0x008c40),\n\tREG(ANA_FID_CFG,\t\t\t0x008c44),\n\tREG(ANA_POL_PIR_CFG,\t\t\t0x004000),\n\tREG(ANA_POL_CIR_CFG,\t\t\t0x004004),\n\tREG(ANA_POL_MODE_CFG,\t\t\t0x004008),\n\tREG(ANA_POL_PIR_STATE,\t\t\t0x00400c),\n\tREG(ANA_POL_CIR_STATE,\t\t\t0x004010),\n\tREG_RESERVED(ANA_POL_STATE),\n\tREG(ANA_POL_FLOWC,\t\t\t0x008c48),\n\tREG(ANA_POL_HYST,\t\t\t0x008cb4),\n\tREG_RESERVED(ANA_POL_MISC_CFG),\n};\n\nstatic const u32 vsc9959_qs_regmap[] = {\n\tREG(QS_XTR_GRP_CFG,\t\t\t0x000000),\n\tREG(QS_XTR_RD,\t\t\t\t0x000008),\n\tREG(QS_XTR_FRM_PRUNING,\t\t\t0x000010),\n\tREG(QS_XTR_FLUSH,\t\t\t0x000018),\n\tREG(QS_XTR_DATA_PRESENT,\t\t0x00001c),\n\tREG(QS_XTR_CFG,\t\t\t\t0x000020),\n\tREG(QS_INJ_GRP_CFG,\t\t\t0x000024),\n\tREG(QS_INJ_WR,\t\t\t\t0x00002c),\n\tREG(QS_INJ_CTRL,\t\t\t0x000034),\n\tREG(QS_INJ_STATUS,\t\t\t0x00003c),\n\tREG(QS_INJ_ERR,\t\t\t\t0x000040),\n\tREG_RESERVED(QS_INH_DBG),\n};\n\nstatic const u32 vsc9959_vcap_regmap[] = {\n\t \n\tREG(VCAP_CORE_UPDATE_CTRL,\t\t0x000000),\n\tREG(VCAP_CORE_MV_CFG,\t\t\t0x000004),\n\t \n\tREG(VCAP_CACHE_ENTRY_DAT,\t\t0x000008),\n\tREG(VCAP_CACHE_MASK_DAT,\t\t0x000108),\n\tREG(VCAP_CACHE_ACTION_DAT,\t\t0x000208),\n\tREG(VCAP_CACHE_CNT_DAT,\t\t\t0x000308),\n\tREG(VCAP_CACHE_TG_DAT,\t\t\t0x000388),\n\t \n\tREG(VCAP_CONST_VCAP_VER,\t\t0x000398),\n\tREG(VCAP_CONST_ENTRY_WIDTH,\t\t0x00039c),\n\tREG(VCAP_CONST_ENTRY_CNT,\t\t0x0003a0),\n\tREG(VCAP_CONST_ENTRY_SWCNT,\t\t0x0003a4),\n\tREG(VCAP_CONST_ENTRY_TG_WIDTH,\t\t0x0003a8),\n\tREG(VCAP_CONST_ACTION_DEF_CNT,\t\t0x0003ac),\n\tREG(VCAP_CONST_ACTION_WIDTH,\t\t0x0003b0),\n\tREG(VCAP_CONST_CNT_WIDTH,\t\t0x0003b4),\n\tREG(VCAP_CONST_CORE_CNT,\t\t0x0003b8),\n\tREG(VCAP_CONST_IF_CNT,\t\t\t0x0003bc),\n};\n\nstatic const u32 vsc9959_qsys_regmap[] = {\n\tREG(QSYS_PORT_MODE,\t\t\t0x00f460),\n\tREG(QSYS_SWITCH_PORT_MODE,\t\t0x00f480),\n\tREG(QSYS_STAT_CNT_CFG,\t\t\t0x00f49c),\n\tREG(QSYS_EEE_CFG,\t\t\t0x00f4a0),\n\tREG(QSYS_EEE_THRES,\t\t\t0x00f4b8),\n\tREG(QSYS_IGR_NO_SHARING,\t\t0x00f4bc),\n\tREG(QSYS_EGR_NO_SHARING,\t\t0x00f4c0),\n\tREG(QSYS_SW_STATUS,\t\t\t0x00f4c4),\n\tREG(QSYS_EXT_CPU_CFG,\t\t\t0x00f4e0),\n\tREG_RESERVED(QSYS_PAD_CFG),\n\tREG(QSYS_CPU_GROUP_MAP,\t\t\t0x00f4e8),\n\tREG_RESERVED(QSYS_QMAP),\n\tREG_RESERVED(QSYS_ISDX_SGRP),\n\tREG_RESERVED(QSYS_TIMED_FRAME_ENTRY),\n\tREG(QSYS_TFRM_MISC,\t\t\t0x00f50c),\n\tREG(QSYS_TFRM_PORT_DLY,\t\t\t0x00f510),\n\tREG(QSYS_TFRM_TIMER_CFG_1,\t\t0x00f514),\n\tREG(QSYS_TFRM_TIMER_CFG_2,\t\t0x00f518),\n\tREG(QSYS_TFRM_TIMER_CFG_3,\t\t0x00f51c),\n\tREG(QSYS_TFRM_TIMER_CFG_4,\t\t0x00f520),\n\tREG(QSYS_TFRM_TIMER_CFG_5,\t\t0x00f524),\n\tREG(QSYS_TFRM_TIMER_CFG_6,\t\t0x00f528),\n\tREG(QSYS_TFRM_TIMER_CFG_7,\t\t0x00f52c),\n\tREG(QSYS_TFRM_TIMER_CFG_8,\t\t0x00f530),\n\tREG(QSYS_RED_PROFILE,\t\t\t0x00f534),\n\tREG(QSYS_RES_QOS_MODE,\t\t\t0x00f574),\n\tREG(QSYS_RES_CFG,\t\t\t0x00c000),\n\tREG(QSYS_RES_STAT,\t\t\t0x00c004),\n\tREG(QSYS_EGR_DROP_MODE,\t\t\t0x00f578),\n\tREG(QSYS_EQ_CTRL,\t\t\t0x00f57c),\n\tREG_RESERVED(QSYS_EVENTS_CORE),\n\tREG(QSYS_QMAXSDU_CFG_0,\t\t\t0x00f584),\n\tREG(QSYS_QMAXSDU_CFG_1,\t\t\t0x00f5a0),\n\tREG(QSYS_QMAXSDU_CFG_2,\t\t\t0x00f5bc),\n\tREG(QSYS_QMAXSDU_CFG_3,\t\t\t0x00f5d8),\n\tREG(QSYS_QMAXSDU_CFG_4,\t\t\t0x00f5f4),\n\tREG(QSYS_QMAXSDU_CFG_5,\t\t\t0x00f610),\n\tREG(QSYS_QMAXSDU_CFG_6,\t\t\t0x00f62c),\n\tREG(QSYS_QMAXSDU_CFG_7,\t\t\t0x00f648),\n\tREG(QSYS_PREEMPTION_CFG,\t\t0x00f664),\n\tREG(QSYS_CIR_CFG,\t\t\t0x000000),\n\tREG(QSYS_EIR_CFG,\t\t\t0x000004),\n\tREG(QSYS_SE_CFG,\t\t\t0x000008),\n\tREG(QSYS_SE_DWRR_CFG,\t\t\t0x00000c),\n\tREG_RESERVED(QSYS_SE_CONNECT),\n\tREG(QSYS_SE_DLB_SENSE,\t\t\t0x000040),\n\tREG(QSYS_CIR_STATE,\t\t\t0x000044),\n\tREG(QSYS_EIR_STATE,\t\t\t0x000048),\n\tREG_RESERVED(QSYS_SE_STATE),\n\tREG(QSYS_HSCH_MISC_CFG,\t\t\t0x00f67c),\n\tREG(QSYS_TAG_CONFIG,\t\t\t0x00f680),\n\tREG(QSYS_TAS_PARAM_CFG_CTRL,\t\t0x00f698),\n\tREG(QSYS_PORT_MAX_SDU,\t\t\t0x00f69c),\n\tREG(QSYS_PARAM_CFG_REG_1,\t\t0x00f440),\n\tREG(QSYS_PARAM_CFG_REG_2,\t\t0x00f444),\n\tREG(QSYS_PARAM_CFG_REG_3,\t\t0x00f448),\n\tREG(QSYS_PARAM_CFG_REG_4,\t\t0x00f44c),\n\tREG(QSYS_PARAM_CFG_REG_5,\t\t0x00f450),\n\tREG(QSYS_GCL_CFG_REG_1,\t\t\t0x00f454),\n\tREG(QSYS_GCL_CFG_REG_2,\t\t\t0x00f458),\n\tREG(QSYS_PARAM_STATUS_REG_1,\t\t0x00f400),\n\tREG(QSYS_PARAM_STATUS_REG_2,\t\t0x00f404),\n\tREG(QSYS_PARAM_STATUS_REG_3,\t\t0x00f408),\n\tREG(QSYS_PARAM_STATUS_REG_4,\t\t0x00f40c),\n\tREG(QSYS_PARAM_STATUS_REG_5,\t\t0x00f410),\n\tREG(QSYS_PARAM_STATUS_REG_6,\t\t0x00f414),\n\tREG(QSYS_PARAM_STATUS_REG_7,\t\t0x00f418),\n\tREG(QSYS_PARAM_STATUS_REG_8,\t\t0x00f41c),\n\tREG(QSYS_PARAM_STATUS_REG_9,\t\t0x00f420),\n\tREG(QSYS_GCL_STATUS_REG_1,\t\t0x00f424),\n\tREG(QSYS_GCL_STATUS_REG_2,\t\t0x00f428),\n};\n\nstatic const u32 vsc9959_rew_regmap[] = {\n\tREG(REW_PORT_VLAN_CFG,\t\t\t0x000000),\n\tREG(REW_TAG_CFG,\t\t\t0x000004),\n\tREG(REW_PORT_CFG,\t\t\t0x000008),\n\tREG(REW_DSCP_CFG,\t\t\t0x00000c),\n\tREG(REW_PCP_DEI_QOS_MAP_CFG,\t\t0x000010),\n\tREG(REW_PTP_CFG,\t\t\t0x000050),\n\tREG(REW_PTP_DLY1_CFG,\t\t\t0x000054),\n\tREG(REW_RED_TAG_CFG,\t\t\t0x000058),\n\tREG(REW_DSCP_REMAP_DP1_CFG,\t\t0x000410),\n\tREG(REW_DSCP_REMAP_CFG,\t\t\t0x000510),\n\tREG_RESERVED(REW_STAT_CFG),\n\tREG_RESERVED(REW_REW_STICKY),\n\tREG_RESERVED(REW_PPT),\n};\n\nstatic const u32 vsc9959_sys_regmap[] = {\n\tREG(SYS_COUNT_RX_OCTETS,\t\t0x000000),\n\tREG(SYS_COUNT_RX_UNICAST,\t\t0x000004),\n\tREG(SYS_COUNT_RX_MULTICAST,\t\t0x000008),\n\tREG(SYS_COUNT_RX_BROADCAST,\t\t0x00000c),\n\tREG(SYS_COUNT_RX_SHORTS,\t\t0x000010),\n\tREG(SYS_COUNT_RX_FRAGMENTS,\t\t0x000014),\n\tREG(SYS_COUNT_RX_JABBERS,\t\t0x000018),\n\tREG(SYS_COUNT_RX_CRC_ALIGN_ERRS,\t0x00001c),\n\tREG(SYS_COUNT_RX_SYM_ERRS,\t\t0x000020),\n\tREG(SYS_COUNT_RX_64,\t\t\t0x000024),\n\tREG(SYS_COUNT_RX_65_127,\t\t0x000028),\n\tREG(SYS_COUNT_RX_128_255,\t\t0x00002c),\n\tREG(SYS_COUNT_RX_256_511,\t\t0x000030),\n\tREG(SYS_COUNT_RX_512_1023,\t\t0x000034),\n\tREG(SYS_COUNT_RX_1024_1526,\t\t0x000038),\n\tREG(SYS_COUNT_RX_1527_MAX,\t\t0x00003c),\n\tREG(SYS_COUNT_RX_PAUSE,\t\t\t0x000040),\n\tREG(SYS_COUNT_RX_CONTROL,\t\t0x000044),\n\tREG(SYS_COUNT_RX_LONGS,\t\t\t0x000048),\n\tREG(SYS_COUNT_RX_CLASSIFIED_DROPS,\t0x00004c),\n\tREG(SYS_COUNT_RX_RED_PRIO_0,\t\t0x000050),\n\tREG(SYS_COUNT_RX_RED_PRIO_1,\t\t0x000054),\n\tREG(SYS_COUNT_RX_RED_PRIO_2,\t\t0x000058),\n\tREG(SYS_COUNT_RX_RED_PRIO_3,\t\t0x00005c),\n\tREG(SYS_COUNT_RX_RED_PRIO_4,\t\t0x000060),\n\tREG(SYS_COUNT_RX_RED_PRIO_5,\t\t0x000064),\n\tREG(SYS_COUNT_RX_RED_PRIO_6,\t\t0x000068),\n\tREG(SYS_COUNT_RX_RED_PRIO_7,\t\t0x00006c),\n\tREG(SYS_COUNT_RX_YELLOW_PRIO_0,\t\t0x000070),\n\tREG(SYS_COUNT_RX_YELLOW_PRIO_1,\t\t0x000074),\n\tREG(SYS_COUNT_RX_YELLOW_PRIO_2,\t\t0x000078),\n\tREG(SYS_COUNT_RX_YELLOW_PRIO_3,\t\t0x00007c),\n\tREG(SYS_COUNT_RX_YELLOW_PRIO_4,\t\t0x000080),\n\tREG(SYS_COUNT_RX_YELLOW_PRIO_5,\t\t0x000084),\n\tREG(SYS_COUNT_RX_YELLOW_PRIO_6,\t\t0x000088),\n\tREG(SYS_COUNT_RX_YELLOW_PRIO_7,\t\t0x00008c),\n\tREG(SYS_COUNT_RX_GREEN_PRIO_0,\t\t0x000090),\n\tREG(SYS_COUNT_RX_GREEN_PRIO_1,\t\t0x000094),\n\tREG(SYS_COUNT_RX_GREEN_PRIO_2,\t\t0x000098),\n\tREG(SYS_COUNT_RX_GREEN_PRIO_3,\t\t0x00009c),\n\tREG(SYS_COUNT_RX_GREEN_PRIO_4,\t\t0x0000a0),\n\tREG(SYS_COUNT_RX_GREEN_PRIO_5,\t\t0x0000a4),\n\tREG(SYS_COUNT_RX_GREEN_PRIO_6,\t\t0x0000a8),\n\tREG(SYS_COUNT_RX_GREEN_PRIO_7,\t\t0x0000ac),\n\tREG(SYS_COUNT_RX_ASSEMBLY_ERRS,\t\t0x0000b0),\n\tREG(SYS_COUNT_RX_SMD_ERRS,\t\t0x0000b4),\n\tREG(SYS_COUNT_RX_ASSEMBLY_OK,\t\t0x0000b8),\n\tREG(SYS_COUNT_RX_MERGE_FRAGMENTS,\t0x0000bc),\n\tREG(SYS_COUNT_RX_PMAC_OCTETS,\t\t0x0000c0),\n\tREG(SYS_COUNT_RX_PMAC_UNICAST,\t\t0x0000c4),\n\tREG(SYS_COUNT_RX_PMAC_MULTICAST,\t0x0000c8),\n\tREG(SYS_COUNT_RX_PMAC_BROADCAST,\t0x0000cc),\n\tREG(SYS_COUNT_RX_PMAC_SHORTS,\t\t0x0000d0),\n\tREG(SYS_COUNT_RX_PMAC_FRAGMENTS,\t0x0000d4),\n\tREG(SYS_COUNT_RX_PMAC_JABBERS,\t\t0x0000d8),\n\tREG(SYS_COUNT_RX_PMAC_CRC_ALIGN_ERRS,\t0x0000dc),\n\tREG(SYS_COUNT_RX_PMAC_SYM_ERRS,\t\t0x0000e0),\n\tREG(SYS_COUNT_RX_PMAC_64,\t\t0x0000e4),\n\tREG(SYS_COUNT_RX_PMAC_65_127,\t\t0x0000e8),\n\tREG(SYS_COUNT_RX_PMAC_128_255,\t\t0x0000ec),\n\tREG(SYS_COUNT_RX_PMAC_256_511,\t\t0x0000f0),\n\tREG(SYS_COUNT_RX_PMAC_512_1023,\t\t0x0000f4),\n\tREG(SYS_COUNT_RX_PMAC_1024_1526,\t0x0000f8),\n\tREG(SYS_COUNT_RX_PMAC_1527_MAX,\t\t0x0000fc),\n\tREG(SYS_COUNT_RX_PMAC_PAUSE,\t\t0x000100),\n\tREG(SYS_COUNT_RX_PMAC_CONTROL,\t\t0x000104),\n\tREG(SYS_COUNT_RX_PMAC_LONGS,\t\t0x000108),\n\tREG(SYS_COUNT_TX_OCTETS,\t\t0x000200),\n\tREG(SYS_COUNT_TX_UNICAST,\t\t0x000204),\n\tREG(SYS_COUNT_TX_MULTICAST,\t\t0x000208),\n\tREG(SYS_COUNT_TX_BROADCAST,\t\t0x00020c),\n\tREG(SYS_COUNT_TX_COLLISION,\t\t0x000210),\n\tREG(SYS_COUNT_TX_DROPS,\t\t\t0x000214),\n\tREG(SYS_COUNT_TX_PAUSE,\t\t\t0x000218),\n\tREG(SYS_COUNT_TX_64,\t\t\t0x00021c),\n\tREG(SYS_COUNT_TX_65_127,\t\t0x000220),\n\tREG(SYS_COUNT_TX_128_255,\t\t0x000224),\n\tREG(SYS_COUNT_TX_256_511,\t\t0x000228),\n\tREG(SYS_COUNT_TX_512_1023,\t\t0x00022c),\n\tREG(SYS_COUNT_TX_1024_1526,\t\t0x000230),\n\tREG(SYS_COUNT_TX_1527_MAX,\t\t0x000234),\n\tREG(SYS_COUNT_TX_YELLOW_PRIO_0,\t\t0x000238),\n\tREG(SYS_COUNT_TX_YELLOW_PRIO_1,\t\t0x00023c),\n\tREG(SYS_COUNT_TX_YELLOW_PRIO_2,\t\t0x000240),\n\tREG(SYS_COUNT_TX_YELLOW_PRIO_3,\t\t0x000244),\n\tREG(SYS_COUNT_TX_YELLOW_PRIO_4,\t\t0x000248),\n\tREG(SYS_COUNT_TX_YELLOW_PRIO_5,\t\t0x00024c),\n\tREG(SYS_COUNT_TX_YELLOW_PRIO_6,\t\t0x000250),\n\tREG(SYS_COUNT_TX_YELLOW_PRIO_7,\t\t0x000254),\n\tREG(SYS_COUNT_TX_GREEN_PRIO_0,\t\t0x000258),\n\tREG(SYS_COUNT_TX_GREEN_PRIO_1,\t\t0x00025c),\n\tREG(SYS_COUNT_TX_GREEN_PRIO_2,\t\t0x000260),\n\tREG(SYS_COUNT_TX_GREEN_PRIO_3,\t\t0x000264),\n\tREG(SYS_COUNT_TX_GREEN_PRIO_4,\t\t0x000268),\n\tREG(SYS_COUNT_TX_GREEN_PRIO_5,\t\t0x00026c),\n\tREG(SYS_COUNT_TX_GREEN_PRIO_6,\t\t0x000270),\n\tREG(SYS_COUNT_TX_GREEN_PRIO_7,\t\t0x000274),\n\tREG(SYS_COUNT_TX_AGED,\t\t\t0x000278),\n\tREG(SYS_COUNT_TX_MM_HOLD,\t\t0x00027c),\n\tREG(SYS_COUNT_TX_MERGE_FRAGMENTS,\t0x000280),\n\tREG(SYS_COUNT_TX_PMAC_OCTETS,\t\t0x000284),\n\tREG(SYS_COUNT_TX_PMAC_UNICAST,\t\t0x000288),\n\tREG(SYS_COUNT_TX_PMAC_MULTICAST,\t0x00028c),\n\tREG(SYS_COUNT_TX_PMAC_BROADCAST,\t0x000290),\n\tREG(SYS_COUNT_TX_PMAC_PAUSE,\t\t0x000294),\n\tREG(SYS_COUNT_TX_PMAC_64,\t\t0x000298),\n\tREG(SYS_COUNT_TX_PMAC_65_127,\t\t0x00029c),\n\tREG(SYS_COUNT_TX_PMAC_128_255,\t\t0x0002a0),\n\tREG(SYS_COUNT_TX_PMAC_256_511,\t\t0x0002a4),\n\tREG(SYS_COUNT_TX_PMAC_512_1023,\t\t0x0002a8),\n\tREG(SYS_COUNT_TX_PMAC_1024_1526,\t0x0002ac),\n\tREG(SYS_COUNT_TX_PMAC_1527_MAX,\t\t0x0002b0),\n\tREG(SYS_COUNT_DROP_LOCAL,\t\t0x000400),\n\tREG(SYS_COUNT_DROP_TAIL,\t\t0x000404),\n\tREG(SYS_COUNT_DROP_YELLOW_PRIO_0,\t0x000408),\n\tREG(SYS_COUNT_DROP_YELLOW_PRIO_1,\t0x00040c),\n\tREG(SYS_COUNT_DROP_YELLOW_PRIO_2,\t0x000410),\n\tREG(SYS_COUNT_DROP_YELLOW_PRIO_3,\t0x000414),\n\tREG(SYS_COUNT_DROP_YELLOW_PRIO_4,\t0x000418),\n\tREG(SYS_COUNT_DROP_YELLOW_PRIO_5,\t0x00041c),\n\tREG(SYS_COUNT_DROP_YELLOW_PRIO_6,\t0x000420),\n\tREG(SYS_COUNT_DROP_YELLOW_PRIO_7,\t0x000424),\n\tREG(SYS_COUNT_DROP_GREEN_PRIO_0,\t0x000428),\n\tREG(SYS_COUNT_DROP_GREEN_PRIO_1,\t0x00042c),\n\tREG(SYS_COUNT_DROP_GREEN_PRIO_2,\t0x000430),\n\tREG(SYS_COUNT_DROP_GREEN_PRIO_3,\t0x000434),\n\tREG(SYS_COUNT_DROP_GREEN_PRIO_4,\t0x000438),\n\tREG(SYS_COUNT_DROP_GREEN_PRIO_5,\t0x00043c),\n\tREG(SYS_COUNT_DROP_GREEN_PRIO_6,\t0x000440),\n\tREG(SYS_COUNT_DROP_GREEN_PRIO_7,\t0x000444),\n\tREG(SYS_COUNT_SF_MATCHING_FRAMES,\t0x000800),\n\tREG(SYS_COUNT_SF_NOT_PASSING_FRAMES,\t0x000804),\n\tREG(SYS_COUNT_SF_NOT_PASSING_SDU,\t0x000808),\n\tREG(SYS_COUNT_SF_RED_FRAMES,\t\t0x00080c),\n\tREG(SYS_RESET_CFG,\t\t\t0x000e00),\n\tREG(SYS_SR_ETYPE_CFG,\t\t\t0x000e04),\n\tREG(SYS_VLAN_ETYPE_CFG,\t\t\t0x000e08),\n\tREG(SYS_PORT_MODE,\t\t\t0x000e0c),\n\tREG(SYS_FRONT_PORT_MODE,\t\t0x000e2c),\n\tREG(SYS_FRM_AGING,\t\t\t0x000e44),\n\tREG(SYS_STAT_CFG,\t\t\t0x000e48),\n\tREG(SYS_SW_STATUS,\t\t\t0x000e4c),\n\tREG_RESERVED(SYS_MISC_CFG),\n\tREG(SYS_REW_MAC_HIGH_CFG,\t\t0x000e6c),\n\tREG(SYS_REW_MAC_LOW_CFG,\t\t0x000e84),\n\tREG(SYS_TIMESTAMP_OFFSET,\t\t0x000e9c),\n\tREG(SYS_PAUSE_CFG,\t\t\t0x000ea0),\n\tREG(SYS_PAUSE_TOT_CFG,\t\t\t0x000ebc),\n\tREG(SYS_ATOP,\t\t\t\t0x000ec0),\n\tREG(SYS_ATOP_TOT_CFG,\t\t\t0x000edc),\n\tREG(SYS_MAC_FC_CFG,\t\t\t0x000ee0),\n\tREG(SYS_MMGT,\t\t\t\t0x000ef8),\n\tREG_RESERVED(SYS_MMGT_FAST),\n\tREG_RESERVED(SYS_EVENTS_DIF),\n\tREG_RESERVED(SYS_EVENTS_CORE),\n\tREG(SYS_PTP_STATUS,\t\t\t0x000f14),\n\tREG(SYS_PTP_TXSTAMP,\t\t\t0x000f18),\n\tREG(SYS_PTP_NXT,\t\t\t0x000f1c),\n\tREG(SYS_PTP_CFG,\t\t\t0x000f20),\n\tREG(SYS_RAM_INIT,\t\t\t0x000f24),\n\tREG_RESERVED(SYS_CM_ADDR),\n\tREG_RESERVED(SYS_CM_DATA_WR),\n\tREG_RESERVED(SYS_CM_DATA_RD),\n\tREG_RESERVED(SYS_CM_OP),\n\tREG_RESERVED(SYS_CM_DATA),\n};\n\nstatic const u32 vsc9959_ptp_regmap[] = {\n\tREG(PTP_PIN_CFG,\t\t\t0x000000),\n\tREG(PTP_PIN_TOD_SEC_MSB,\t\t0x000004),\n\tREG(PTP_PIN_TOD_SEC_LSB,\t\t0x000008),\n\tREG(PTP_PIN_TOD_NSEC,\t\t\t0x00000c),\n\tREG(PTP_PIN_WF_HIGH_PERIOD,\t\t0x000014),\n\tREG(PTP_PIN_WF_LOW_PERIOD,\t\t0x000018),\n\tREG(PTP_CFG_MISC,\t\t\t0x0000a0),\n\tREG(PTP_CLK_CFG_ADJ_CFG,\t\t0x0000a4),\n\tREG(PTP_CLK_CFG_ADJ_FREQ,\t\t0x0000a8),\n};\n\nstatic const u32 vsc9959_gcb_regmap[] = {\n\tREG(GCB_SOFT_RST,\t\t\t0x000004),\n};\n\nstatic const u32 vsc9959_dev_gmii_regmap[] = {\n\tREG(DEV_CLOCK_CFG,\t\t\t0x0),\n\tREG(DEV_PORT_MISC,\t\t\t0x4),\n\tREG(DEV_EVENTS,\t\t\t\t0x8),\n\tREG(DEV_EEE_CFG,\t\t\t0xc),\n\tREG(DEV_RX_PATH_DELAY,\t\t\t0x10),\n\tREG(DEV_TX_PATH_DELAY,\t\t\t0x14),\n\tREG(DEV_PTP_PREDICT_CFG,\t\t0x18),\n\tREG(DEV_MAC_ENA_CFG,\t\t\t0x1c),\n\tREG(DEV_MAC_MODE_CFG,\t\t\t0x20),\n\tREG(DEV_MAC_MAXLEN_CFG,\t\t\t0x24),\n\tREG(DEV_MAC_TAGS_CFG,\t\t\t0x28),\n\tREG(DEV_MAC_ADV_CHK_CFG,\t\t0x2c),\n\tREG(DEV_MAC_IFG_CFG,\t\t\t0x30),\n\tREG(DEV_MAC_HDX_CFG,\t\t\t0x34),\n\tREG(DEV_MAC_DBG_CFG,\t\t\t0x38),\n\tREG(DEV_MAC_FC_MAC_LOW_CFG,\t\t0x3c),\n\tREG(DEV_MAC_FC_MAC_HIGH_CFG,\t\t0x40),\n\tREG(DEV_MAC_STICKY,\t\t\t0x44),\n\tREG(DEV_MM_ENABLE_CONFIG,\t\t0x48),\n\tREG(DEV_MM_VERIF_CONFIG,\t\t0x4C),\n\tREG(DEV_MM_STATUS,\t\t\t0x50),\n\tREG_RESERVED(PCS1G_CFG),\n\tREG_RESERVED(PCS1G_MODE_CFG),\n\tREG_RESERVED(PCS1G_SD_CFG),\n\tREG_RESERVED(PCS1G_ANEG_CFG),\n\tREG_RESERVED(PCS1G_ANEG_NP_CFG),\n\tREG_RESERVED(PCS1G_LB_CFG),\n\tREG_RESERVED(PCS1G_DBG_CFG),\n\tREG_RESERVED(PCS1G_CDET_CFG),\n\tREG_RESERVED(PCS1G_ANEG_STATUS),\n\tREG_RESERVED(PCS1G_ANEG_NP_STATUS),\n\tREG_RESERVED(PCS1G_LINK_STATUS),\n\tREG_RESERVED(PCS1G_LINK_DOWN_CNT),\n\tREG_RESERVED(PCS1G_STICKY),\n\tREG_RESERVED(PCS1G_DEBUG_STATUS),\n\tREG_RESERVED(PCS1G_LPI_CFG),\n\tREG_RESERVED(PCS1G_LPI_WAKE_ERROR_CNT),\n\tREG_RESERVED(PCS1G_LPI_STATUS),\n\tREG_RESERVED(PCS1G_TSTPAT_MODE_CFG),\n\tREG_RESERVED(PCS1G_TSTPAT_STATUS),\n\tREG_RESERVED(DEV_PCS_FX100_CFG),\n\tREG_RESERVED(DEV_PCS_FX100_STATUS),\n};\n\nstatic const u32 *vsc9959_regmap[TARGET_MAX] = {\n\t[ANA]\t= vsc9959_ana_regmap,\n\t[QS]\t= vsc9959_qs_regmap,\n\t[QSYS]\t= vsc9959_qsys_regmap,\n\t[REW]\t= vsc9959_rew_regmap,\n\t[SYS]\t= vsc9959_sys_regmap,\n\t[S0]\t= vsc9959_vcap_regmap,\n\t[S1]\t= vsc9959_vcap_regmap,\n\t[S2]\t= vsc9959_vcap_regmap,\n\t[PTP]\t= vsc9959_ptp_regmap,\n\t[GCB]\t= vsc9959_gcb_regmap,\n\t[DEV_GMII] = vsc9959_dev_gmii_regmap,\n};\n\n \nstatic const struct resource vsc9959_resources[] = {\n\tDEFINE_RES_MEM_NAMED(0x0010000, 0x0010000, \"sys\"),\n\tDEFINE_RES_MEM_NAMED(0x0030000, 0x0010000, \"rew\"),\n\tDEFINE_RES_MEM_NAMED(0x0040000, 0x0000400, \"s0\"),\n\tDEFINE_RES_MEM_NAMED(0x0050000, 0x0000400, \"s1\"),\n\tDEFINE_RES_MEM_NAMED(0x0060000, 0x0000400, \"s2\"),\n\tDEFINE_RES_MEM_NAMED(0x0070000, 0x0000200, \"devcpu_gcb\"),\n\tDEFINE_RES_MEM_NAMED(0x0080000, 0x0000100, \"qs\"),\n\tDEFINE_RES_MEM_NAMED(0x0090000, 0x00000cc, \"ptp\"),\n\tDEFINE_RES_MEM_NAMED(0x0100000, 0x0010000, \"port0\"),\n\tDEFINE_RES_MEM_NAMED(0x0110000, 0x0010000, \"port1\"),\n\tDEFINE_RES_MEM_NAMED(0x0120000, 0x0010000, \"port2\"),\n\tDEFINE_RES_MEM_NAMED(0x0130000, 0x0010000, \"port3\"),\n\tDEFINE_RES_MEM_NAMED(0x0140000, 0x0010000, \"port4\"),\n\tDEFINE_RES_MEM_NAMED(0x0150000, 0x0010000, \"port5\"),\n\tDEFINE_RES_MEM_NAMED(0x0200000, 0x0020000, \"qsys\"),\n\tDEFINE_RES_MEM_NAMED(0x0280000, 0x0010000, \"ana\"),\n};\n\nstatic const char * const vsc9959_resource_names[TARGET_MAX] = {\n\t[SYS] = \"sys\",\n\t[REW] = \"rew\",\n\t[S0] = \"s0\",\n\t[S1] = \"s1\",\n\t[S2] = \"s2\",\n\t[GCB] = \"devcpu_gcb\",\n\t[QS] = \"qs\",\n\t[PTP] = \"ptp\",\n\t[QSYS] = \"qsys\",\n\t[ANA] = \"ana\",\n};\n\n \nstatic const struct resource vsc9959_imdio_res =\n\tDEFINE_RES_MEM_NAMED(0x8030, 0x10, \"imdio\");\n\nstatic const struct reg_field vsc9959_regfields[REGFIELD_MAX] = {\n\t[ANA_ADVLEARN_VLAN_CHK] = REG_FIELD(ANA_ADVLEARN, 6, 6),\n\t[ANA_ADVLEARN_LEARN_MIRROR] = REG_FIELD(ANA_ADVLEARN, 0, 5),\n\t[ANA_ANEVENTS_FLOOD_DISCARD] = REG_FIELD(ANA_ANEVENTS, 30, 30),\n\t[ANA_ANEVENTS_AUTOAGE] = REG_FIELD(ANA_ANEVENTS, 26, 26),\n\t[ANA_ANEVENTS_STORM_DROP] = REG_FIELD(ANA_ANEVENTS, 24, 24),\n\t[ANA_ANEVENTS_LEARN_DROP] = REG_FIELD(ANA_ANEVENTS, 23, 23),\n\t[ANA_ANEVENTS_AGED_ENTRY] = REG_FIELD(ANA_ANEVENTS, 22, 22),\n\t[ANA_ANEVENTS_CPU_LEARN_FAILED] = REG_FIELD(ANA_ANEVENTS, 21, 21),\n\t[ANA_ANEVENTS_AUTO_LEARN_FAILED] = REG_FIELD(ANA_ANEVENTS, 20, 20),\n\t[ANA_ANEVENTS_LEARN_REMOVE] = REG_FIELD(ANA_ANEVENTS, 19, 19),\n\t[ANA_ANEVENTS_AUTO_LEARNED] = REG_FIELD(ANA_ANEVENTS, 18, 18),\n\t[ANA_ANEVENTS_AUTO_MOVED] = REG_FIELD(ANA_ANEVENTS, 17, 17),\n\t[ANA_ANEVENTS_CLASSIFIED_DROP] = REG_FIELD(ANA_ANEVENTS, 15, 15),\n\t[ANA_ANEVENTS_CLASSIFIED_COPY] = REG_FIELD(ANA_ANEVENTS, 14, 14),\n\t[ANA_ANEVENTS_VLAN_DISCARD] = REG_FIELD(ANA_ANEVENTS, 13, 13),\n\t[ANA_ANEVENTS_FWD_DISCARD] = REG_FIELD(ANA_ANEVENTS, 12, 12),\n\t[ANA_ANEVENTS_MULTICAST_FLOOD] = REG_FIELD(ANA_ANEVENTS, 11, 11),\n\t[ANA_ANEVENTS_UNICAST_FLOOD] = REG_FIELD(ANA_ANEVENTS, 10, 10),\n\t[ANA_ANEVENTS_DEST_KNOWN] = REG_FIELD(ANA_ANEVENTS, 9, 9),\n\t[ANA_ANEVENTS_BUCKET3_MATCH] = REG_FIELD(ANA_ANEVENTS, 8, 8),\n\t[ANA_ANEVENTS_BUCKET2_MATCH] = REG_FIELD(ANA_ANEVENTS, 7, 7),\n\t[ANA_ANEVENTS_BUCKET1_MATCH] = REG_FIELD(ANA_ANEVENTS, 6, 6),\n\t[ANA_ANEVENTS_BUCKET0_MATCH] = REG_FIELD(ANA_ANEVENTS, 5, 5),\n\t[ANA_ANEVENTS_CPU_OPERATION] = REG_FIELD(ANA_ANEVENTS, 4, 4),\n\t[ANA_ANEVENTS_DMAC_LOOKUP] = REG_FIELD(ANA_ANEVENTS, 3, 3),\n\t[ANA_ANEVENTS_SMAC_LOOKUP] = REG_FIELD(ANA_ANEVENTS, 2, 2),\n\t[ANA_ANEVENTS_SEQ_GEN_ERR_0] = REG_FIELD(ANA_ANEVENTS, 1, 1),\n\t[ANA_ANEVENTS_SEQ_GEN_ERR_1] = REG_FIELD(ANA_ANEVENTS, 0, 0),\n\t[ANA_TABLES_MACACCESS_B_DOM] = REG_FIELD(ANA_TABLES_MACACCESS, 16, 16),\n\t[ANA_TABLES_MACTINDX_BUCKET] = REG_FIELD(ANA_TABLES_MACTINDX, 11, 12),\n\t[ANA_TABLES_MACTINDX_M_INDEX] = REG_FIELD(ANA_TABLES_MACTINDX, 0, 10),\n\t[SYS_RESET_CFG_CORE_ENA] = REG_FIELD(SYS_RESET_CFG, 0, 0),\n\t[GCB_SOFT_RST_SWC_RST] = REG_FIELD(GCB_SOFT_RST, 0, 0),\n\t \n\t[QSYS_SWITCH_PORT_MODE_PORT_ENA] = REG_FIELD_ID(QSYS_SWITCH_PORT_MODE, 14, 14, 7, 4),\n\t[QSYS_SWITCH_PORT_MODE_SCH_NEXT_CFG] = REG_FIELD_ID(QSYS_SWITCH_PORT_MODE, 11, 13, 7, 4),\n\t[QSYS_SWITCH_PORT_MODE_YEL_RSRVD] = REG_FIELD_ID(QSYS_SWITCH_PORT_MODE, 10, 10, 7, 4),\n\t[QSYS_SWITCH_PORT_MODE_INGRESS_DROP_MODE] = REG_FIELD_ID(QSYS_SWITCH_PORT_MODE, 9, 9, 7, 4),\n\t[QSYS_SWITCH_PORT_MODE_TX_PFC_ENA] = REG_FIELD_ID(QSYS_SWITCH_PORT_MODE, 1, 8, 7, 4),\n\t[QSYS_SWITCH_PORT_MODE_TX_PFC_MODE] = REG_FIELD_ID(QSYS_SWITCH_PORT_MODE, 0, 0, 7, 4),\n\t[SYS_PORT_MODE_DATA_WO_TS] = REG_FIELD_ID(SYS_PORT_MODE, 5, 6, 7, 4),\n\t[SYS_PORT_MODE_INCL_INJ_HDR] = REG_FIELD_ID(SYS_PORT_MODE, 3, 4, 7, 4),\n\t[SYS_PORT_MODE_INCL_XTR_HDR] = REG_FIELD_ID(SYS_PORT_MODE, 1, 2, 7, 4),\n\t[SYS_PORT_MODE_INCL_HDR_ERR] = REG_FIELD_ID(SYS_PORT_MODE, 0, 0, 7, 4),\n\t[SYS_PAUSE_CFG_PAUSE_START] = REG_FIELD_ID(SYS_PAUSE_CFG, 10, 18, 7, 4),\n\t[SYS_PAUSE_CFG_PAUSE_STOP] = REG_FIELD_ID(SYS_PAUSE_CFG, 1, 9, 7, 4),\n\t[SYS_PAUSE_CFG_PAUSE_ENA] = REG_FIELD_ID(SYS_PAUSE_CFG, 0, 1, 7, 4),\n};\n\nstatic const struct vcap_field vsc9959_vcap_es0_keys[] = {\n\t[VCAP_ES0_EGR_PORT]\t\t\t= {  0,  3},\n\t[VCAP_ES0_IGR_PORT]\t\t\t= {  3,  3},\n\t[VCAP_ES0_RSV]\t\t\t\t= {  6,  2},\n\t[VCAP_ES0_L2_MC]\t\t\t= {  8,  1},\n\t[VCAP_ES0_L2_BC]\t\t\t= {  9,  1},\n\t[VCAP_ES0_VID]\t\t\t\t= { 10, 12},\n\t[VCAP_ES0_DP]\t\t\t\t= { 22,  1},\n\t[VCAP_ES0_PCP]\t\t\t\t= { 23,  3},\n};\n\nstatic const struct vcap_field vsc9959_vcap_es0_actions[] = {\n\t[VCAP_ES0_ACT_PUSH_OUTER_TAG]\t\t= {  0,  2},\n\t[VCAP_ES0_ACT_PUSH_INNER_TAG]\t\t= {  2,  1},\n\t[VCAP_ES0_ACT_TAG_A_TPID_SEL]\t\t= {  3,  2},\n\t[VCAP_ES0_ACT_TAG_A_VID_SEL]\t\t= {  5,  1},\n\t[VCAP_ES0_ACT_TAG_A_PCP_SEL]\t\t= {  6,  2},\n\t[VCAP_ES0_ACT_TAG_A_DEI_SEL]\t\t= {  8,  2},\n\t[VCAP_ES0_ACT_TAG_B_TPID_SEL]\t\t= { 10,  2},\n\t[VCAP_ES0_ACT_TAG_B_VID_SEL]\t\t= { 12,  1},\n\t[VCAP_ES0_ACT_TAG_B_PCP_SEL]\t\t= { 13,  2},\n\t[VCAP_ES0_ACT_TAG_B_DEI_SEL]\t\t= { 15,  2},\n\t[VCAP_ES0_ACT_VID_A_VAL]\t\t= { 17, 12},\n\t[VCAP_ES0_ACT_PCP_A_VAL]\t\t= { 29,  3},\n\t[VCAP_ES0_ACT_DEI_A_VAL]\t\t= { 32,  1},\n\t[VCAP_ES0_ACT_VID_B_VAL]\t\t= { 33, 12},\n\t[VCAP_ES0_ACT_PCP_B_VAL]\t\t= { 45,  3},\n\t[VCAP_ES0_ACT_DEI_B_VAL]\t\t= { 48,  1},\n\t[VCAP_ES0_ACT_RSV]\t\t\t= { 49, 23},\n\t[VCAP_ES0_ACT_HIT_STICKY]\t\t= { 72,  1},\n};\n\nstatic const struct vcap_field vsc9959_vcap_is1_keys[] = {\n\t[VCAP_IS1_HK_TYPE]\t\t\t= {  0,   1},\n\t[VCAP_IS1_HK_LOOKUP]\t\t\t= {  1,   2},\n\t[VCAP_IS1_HK_IGR_PORT_MASK]\t\t= {  3,   7},\n\t[VCAP_IS1_HK_RSV]\t\t\t= { 10,   9},\n\t[VCAP_IS1_HK_OAM_Y1731]\t\t\t= { 19,   1},\n\t[VCAP_IS1_HK_L2_MC]\t\t\t= { 20,   1},\n\t[VCAP_IS1_HK_L2_BC]\t\t\t= { 21,   1},\n\t[VCAP_IS1_HK_IP_MC]\t\t\t= { 22,   1},\n\t[VCAP_IS1_HK_VLAN_TAGGED]\t\t= { 23,   1},\n\t[VCAP_IS1_HK_VLAN_DBL_TAGGED]\t\t= { 24,   1},\n\t[VCAP_IS1_HK_TPID]\t\t\t= { 25,   1},\n\t[VCAP_IS1_HK_VID]\t\t\t= { 26,  12},\n\t[VCAP_IS1_HK_DEI]\t\t\t= { 38,   1},\n\t[VCAP_IS1_HK_PCP]\t\t\t= { 39,   3},\n\t \n\t[VCAP_IS1_HK_L2_SMAC]\t\t\t= { 42,  48},\n\t[VCAP_IS1_HK_ETYPE_LEN]\t\t\t= { 90,   1},\n\t[VCAP_IS1_HK_ETYPE]\t\t\t= { 91,  16},\n\t[VCAP_IS1_HK_IP_SNAP]\t\t\t= {107,   1},\n\t[VCAP_IS1_HK_IP4]\t\t\t= {108,   1},\n\t \n\t[VCAP_IS1_HK_L3_FRAGMENT]\t\t= {109,   1},\n\t[VCAP_IS1_HK_L3_FRAG_OFS_GT0]\t\t= {110,   1},\n\t[VCAP_IS1_HK_L3_OPTIONS]\t\t= {111,   1},\n\t[VCAP_IS1_HK_L3_DSCP]\t\t\t= {112,   6},\n\t[VCAP_IS1_HK_L3_IP4_SIP]\t\t= {118,  32},\n\t \n\t[VCAP_IS1_HK_TCP_UDP]\t\t\t= {150,   1},\n\t[VCAP_IS1_HK_TCP]\t\t\t= {151,   1},\n\t[VCAP_IS1_HK_L4_SPORT]\t\t\t= {152,  16},\n\t[VCAP_IS1_HK_L4_RNG]\t\t\t= {168,   8},\n\t \n\t[VCAP_IS1_HK_IP4_INNER_TPID]            = { 42,   1},\n\t[VCAP_IS1_HK_IP4_INNER_VID]\t\t= { 43,  12},\n\t[VCAP_IS1_HK_IP4_INNER_DEI]\t\t= { 55,   1},\n\t[VCAP_IS1_HK_IP4_INNER_PCP]\t\t= { 56,   3},\n\t[VCAP_IS1_HK_IP4_IP4]\t\t\t= { 59,   1},\n\t[VCAP_IS1_HK_IP4_L3_FRAGMENT]\t\t= { 60,   1},\n\t[VCAP_IS1_HK_IP4_L3_FRAG_OFS_GT0]\t= { 61,   1},\n\t[VCAP_IS1_HK_IP4_L3_OPTIONS]\t\t= { 62,   1},\n\t[VCAP_IS1_HK_IP4_L3_DSCP]\t\t= { 63,   6},\n\t[VCAP_IS1_HK_IP4_L3_IP4_DIP]\t\t= { 69,  32},\n\t[VCAP_IS1_HK_IP4_L3_IP4_SIP]\t\t= {101,  32},\n\t[VCAP_IS1_HK_IP4_L3_PROTO]\t\t= {133,   8},\n\t[VCAP_IS1_HK_IP4_TCP_UDP]\t\t= {141,   1},\n\t[VCAP_IS1_HK_IP4_TCP]\t\t\t= {142,   1},\n\t[VCAP_IS1_HK_IP4_L4_RNG]\t\t= {143,   8},\n\t[VCAP_IS1_HK_IP4_IP_PAYLOAD_S1_5TUPLE]\t= {151,  32},\n};\n\nstatic const struct vcap_field vsc9959_vcap_is1_actions[] = {\n\t[VCAP_IS1_ACT_DSCP_ENA]\t\t\t= {  0,  1},\n\t[VCAP_IS1_ACT_DSCP_VAL]\t\t\t= {  1,  6},\n\t[VCAP_IS1_ACT_QOS_ENA]\t\t\t= {  7,  1},\n\t[VCAP_IS1_ACT_QOS_VAL]\t\t\t= {  8,  3},\n\t[VCAP_IS1_ACT_DP_ENA]\t\t\t= { 11,  1},\n\t[VCAP_IS1_ACT_DP_VAL]\t\t\t= { 12,  1},\n\t[VCAP_IS1_ACT_PAG_OVERRIDE_MASK]\t= { 13,  8},\n\t[VCAP_IS1_ACT_PAG_VAL]\t\t\t= { 21,  8},\n\t[VCAP_IS1_ACT_RSV]\t\t\t= { 29,  9},\n\t \n\t[VCAP_IS1_ACT_VID_REPLACE_ENA]\t\t= { 38,  1},\n\t[VCAP_IS1_ACT_VID_ADD_VAL]\t\t= { 39, 12},\n\t[VCAP_IS1_ACT_FID_SEL]\t\t\t= { 51,  2},\n\t[VCAP_IS1_ACT_FID_VAL]\t\t\t= { 53, 13},\n\t[VCAP_IS1_ACT_PCP_DEI_ENA]\t\t= { 66,  1},\n\t[VCAP_IS1_ACT_PCP_VAL]\t\t\t= { 67,  3},\n\t[VCAP_IS1_ACT_DEI_VAL]\t\t\t= { 70,  1},\n\t[VCAP_IS1_ACT_VLAN_POP_CNT_ENA]\t\t= { 71,  1},\n\t[VCAP_IS1_ACT_VLAN_POP_CNT]\t\t= { 72,  2},\n\t[VCAP_IS1_ACT_CUSTOM_ACE_TYPE_ENA]\t= { 74,  4},\n\t[VCAP_IS1_ACT_HIT_STICKY]\t\t= { 78,  1},\n};\n\nstatic struct vcap_field vsc9959_vcap_is2_keys[] = {\n\t \n\t[VCAP_IS2_TYPE]\t\t\t\t= {  0,   4},\n\t[VCAP_IS2_HK_FIRST]\t\t\t= {  4,   1},\n\t[VCAP_IS2_HK_PAG]\t\t\t= {  5,   8},\n\t[VCAP_IS2_HK_IGR_PORT_MASK]\t\t= { 13,   7},\n\t[VCAP_IS2_HK_RSV2]\t\t\t= { 20,   1},\n\t[VCAP_IS2_HK_HOST_MATCH]\t\t= { 21,   1},\n\t[VCAP_IS2_HK_L2_MC]\t\t\t= { 22,   1},\n\t[VCAP_IS2_HK_L2_BC]\t\t\t= { 23,   1},\n\t[VCAP_IS2_HK_VLAN_TAGGED]\t\t= { 24,   1},\n\t[VCAP_IS2_HK_VID]\t\t\t= { 25,  12},\n\t[VCAP_IS2_HK_DEI]\t\t\t= { 37,   1},\n\t[VCAP_IS2_HK_PCP]\t\t\t= { 38,   3},\n\t \n\t[VCAP_IS2_HK_L2_DMAC]\t\t\t= { 41,  48},\n\t[VCAP_IS2_HK_L2_SMAC]\t\t\t= { 89,  48},\n\t \n\t[VCAP_IS2_HK_MAC_ETYPE_ETYPE]\t\t= {137,  16},\n\t[VCAP_IS2_HK_MAC_ETYPE_L2_PAYLOAD0]\t= {153,  16},\n\t[VCAP_IS2_HK_MAC_ETYPE_L2_PAYLOAD1]\t= {169,   8},\n\t[VCAP_IS2_HK_MAC_ETYPE_L2_PAYLOAD2]\t= {177,   3},\n\t \n\t[VCAP_IS2_HK_MAC_LLC_L2_LLC]\t\t= {137,  40},\n\t \n\t[VCAP_IS2_HK_MAC_SNAP_L2_SNAP]\t\t= {137,  40},\n\t \n\t[VCAP_IS2_HK_MAC_ARP_SMAC]\t\t= { 41,  48},\n\t[VCAP_IS2_HK_MAC_ARP_ADDR_SPACE_OK]\t= { 89,   1},\n\t[VCAP_IS2_HK_MAC_ARP_PROTO_SPACE_OK]\t= { 90,   1},\n\t[VCAP_IS2_HK_MAC_ARP_LEN_OK]\t\t= { 91,   1},\n\t[VCAP_IS2_HK_MAC_ARP_TARGET_MATCH]\t= { 92,   1},\n\t[VCAP_IS2_HK_MAC_ARP_SENDER_MATCH]\t= { 93,   1},\n\t[VCAP_IS2_HK_MAC_ARP_OPCODE_UNKNOWN]\t= { 94,   1},\n\t[VCAP_IS2_HK_MAC_ARP_OPCODE]\t\t= { 95,   2},\n\t[VCAP_IS2_HK_MAC_ARP_L3_IP4_DIP]\t= { 97,  32},\n\t[VCAP_IS2_HK_MAC_ARP_L3_IP4_SIP]\t= {129,  32},\n\t[VCAP_IS2_HK_MAC_ARP_DIP_EQ_SIP]\t= {161,   1},\n\t \n\t[VCAP_IS2_HK_IP4]\t\t\t= { 41,   1},\n\t[VCAP_IS2_HK_L3_FRAGMENT]\t\t= { 42,   1},\n\t[VCAP_IS2_HK_L3_FRAG_OFS_GT0]\t\t= { 43,   1},\n\t[VCAP_IS2_HK_L3_OPTIONS]\t\t= { 44,   1},\n\t[VCAP_IS2_HK_IP4_L3_TTL_GT0]\t\t= { 45,   1},\n\t[VCAP_IS2_HK_L3_TOS]\t\t\t= { 46,   8},\n\t[VCAP_IS2_HK_L3_IP4_DIP]\t\t= { 54,  32},\n\t[VCAP_IS2_HK_L3_IP4_SIP]\t\t= { 86,  32},\n\t[VCAP_IS2_HK_DIP_EQ_SIP]\t\t= {118,   1},\n\t \n\t[VCAP_IS2_HK_TCP]\t\t\t= {119,   1},\n\t[VCAP_IS2_HK_L4_DPORT]\t\t\t= {120,  16},\n\t[VCAP_IS2_HK_L4_SPORT]\t\t\t= {136,  16},\n\t[VCAP_IS2_HK_L4_RNG]\t\t\t= {152,   8},\n\t[VCAP_IS2_HK_L4_SPORT_EQ_DPORT]\t\t= {160,   1},\n\t[VCAP_IS2_HK_L4_SEQUENCE_EQ0]\t\t= {161,   1},\n\t[VCAP_IS2_HK_L4_FIN]\t\t\t= {162,   1},\n\t[VCAP_IS2_HK_L4_SYN]\t\t\t= {163,   1},\n\t[VCAP_IS2_HK_L4_RST]\t\t\t= {164,   1},\n\t[VCAP_IS2_HK_L4_PSH]\t\t\t= {165,   1},\n\t[VCAP_IS2_HK_L4_ACK]\t\t\t= {166,   1},\n\t[VCAP_IS2_HK_L4_URG]\t\t\t= {167,   1},\n\t[VCAP_IS2_HK_L4_1588_DOM]\t\t= {168,   8},\n\t[VCAP_IS2_HK_L4_1588_VER]\t\t= {176,   4},\n\t \n\t[VCAP_IS2_HK_IP4_L3_PROTO]\t\t= {119,   8},\n\t[VCAP_IS2_HK_L3_PAYLOAD]\t\t= {127,  56},\n\t \n\t[VCAP_IS2_HK_IP6_L3_TTL_GT0]\t\t= { 41,   1},\n\t[VCAP_IS2_HK_L3_IP6_SIP]\t\t= { 42, 128},\n\t[VCAP_IS2_HK_IP6_L3_PROTO]\t\t= {170,   8},\n\t \n\t[VCAP_IS2_HK_OAM_MEL_FLAGS]\t\t= {137,   7},\n\t[VCAP_IS2_HK_OAM_VER]\t\t\t= {144,   5},\n\t[VCAP_IS2_HK_OAM_OPCODE]\t\t= {149,   8},\n\t[VCAP_IS2_HK_OAM_FLAGS]\t\t\t= {157,   8},\n\t[VCAP_IS2_HK_OAM_MEPID]\t\t\t= {165,  16},\n\t[VCAP_IS2_HK_OAM_CCM_CNTS_EQ0]\t\t= {181,   1},\n\t[VCAP_IS2_HK_OAM_IS_Y1731]\t\t= {182,   1},\n};\n\nstatic struct vcap_field vsc9959_vcap_is2_actions[] = {\n\t[VCAP_IS2_ACT_HIT_ME_ONCE]\t\t= {  0,  1},\n\t[VCAP_IS2_ACT_CPU_COPY_ENA]\t\t= {  1,  1},\n\t[VCAP_IS2_ACT_CPU_QU_NUM]\t\t= {  2,  3},\n\t[VCAP_IS2_ACT_MASK_MODE]\t\t= {  5,  2},\n\t[VCAP_IS2_ACT_MIRROR_ENA]\t\t= {  7,  1},\n\t[VCAP_IS2_ACT_LRN_DIS]\t\t\t= {  8,  1},\n\t[VCAP_IS2_ACT_POLICE_ENA]\t\t= {  9,  1},\n\t[VCAP_IS2_ACT_POLICE_IDX]\t\t= { 10,  9},\n\t[VCAP_IS2_ACT_POLICE_VCAP_ONLY]\t\t= { 19,  1},\n\t[VCAP_IS2_ACT_PORT_MASK]\t\t= { 20,  6},\n\t[VCAP_IS2_ACT_REW_OP]\t\t\t= { 26,  9},\n\t[VCAP_IS2_ACT_SMAC_REPLACE_ENA]\t\t= { 35,  1},\n\t[VCAP_IS2_ACT_RSV]\t\t\t= { 36,  2},\n\t[VCAP_IS2_ACT_ACL_ID]\t\t\t= { 38,  6},\n\t[VCAP_IS2_ACT_HIT_CNT]\t\t\t= { 44, 32},\n};\n\nstatic struct vcap_props vsc9959_vcap_props[] = {\n\t[VCAP_ES0] = {\n\t\t.action_type_width = 0,\n\t\t.action_table = {\n\t\t\t[ES0_ACTION_TYPE_NORMAL] = {\n\t\t\t\t.width = 72,  \n\t\t\t\t.count = 1,\n\t\t\t},\n\t\t},\n\t\t.target = S0,\n\t\t.keys = vsc9959_vcap_es0_keys,\n\t\t.actions = vsc9959_vcap_es0_actions,\n\t},\n\t[VCAP_IS1] = {\n\t\t.action_type_width = 0,\n\t\t.action_table = {\n\t\t\t[IS1_ACTION_TYPE_NORMAL] = {\n\t\t\t\t.width = 78,  \n\t\t\t\t.count = 4,\n\t\t\t},\n\t\t},\n\t\t.target = S1,\n\t\t.keys = vsc9959_vcap_is1_keys,\n\t\t.actions = vsc9959_vcap_is1_actions,\n\t},\n\t[VCAP_IS2] = {\n\t\t.action_type_width = 1,\n\t\t.action_table = {\n\t\t\t[IS2_ACTION_TYPE_NORMAL] = {\n\t\t\t\t.width = 44,\n\t\t\t\t.count = 2\n\t\t\t},\n\t\t\t[IS2_ACTION_TYPE_SMAC_SIP] = {\n\t\t\t\t.width = 6,\n\t\t\t\t.count = 4\n\t\t\t},\n\t\t},\n\t\t.target = S2,\n\t\t.keys = vsc9959_vcap_is2_keys,\n\t\t.actions = vsc9959_vcap_is2_actions,\n\t},\n};\n\nstatic const struct ptp_clock_info vsc9959_ptp_caps = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"felix ptp\",\n\t.max_adj\t= 0x7fffffff,\n\t.n_alarm\t= 0,\n\t.n_ext_ts\t= 0,\n\t.n_per_out\t= OCELOT_PTP_PINS_NUM,\n\t.n_pins\t\t= OCELOT_PTP_PINS_NUM,\n\t.pps\t\t= 0,\n\t.gettime64\t= ocelot_ptp_gettime64,\n\t.settime64\t= ocelot_ptp_settime64,\n\t.adjtime\t= ocelot_ptp_adjtime,\n\t.adjfine\t= ocelot_ptp_adjfine,\n\t.verify\t\t= ocelot_ptp_verify,\n\t.enable\t\t= ocelot_ptp_enable,\n};\n\n#define VSC9959_INIT_TIMEOUT\t\t\t50000\n#define VSC9959_GCB_RST_SLEEP\t\t\t100\n#define VSC9959_SYS_RAMINIT_SLEEP\t\t80\n\nstatic int vsc9959_gcb_soft_rst_status(struct ocelot *ocelot)\n{\n\tint val;\n\n\tocelot_field_read(ocelot, GCB_SOFT_RST_SWC_RST, &val);\n\n\treturn val;\n}\n\nstatic int vsc9959_sys_ram_init_status(struct ocelot *ocelot)\n{\n\treturn ocelot_read(ocelot, SYS_RAM_INIT);\n}\n\n \nstatic int vsc9959_reset(struct ocelot *ocelot)\n{\n\tint val, err;\n\n\t \n\tocelot_field_write(ocelot, GCB_SOFT_RST_SWC_RST, 1);\n\n\terr = readx_poll_timeout(vsc9959_gcb_soft_rst_status, ocelot, val, !val,\n\t\t\t\t VSC9959_GCB_RST_SLEEP, VSC9959_INIT_TIMEOUT);\n\tif (err) {\n\t\tdev_err(ocelot->dev, \"timeout: switch core reset\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tocelot_write(ocelot, SYS_RAM_INIT_RAM_INIT, SYS_RAM_INIT);\n\terr = readx_poll_timeout(vsc9959_sys_ram_init_status, ocelot, val, !val,\n\t\t\t\t VSC9959_SYS_RAMINIT_SLEEP,\n\t\t\t\t VSC9959_INIT_TIMEOUT);\n\tif (err) {\n\t\tdev_err(ocelot->dev, \"timeout: switch sram init\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tocelot_field_write(ocelot, SYS_RESET_CFG_CORE_ENA, 1);\n\n\treturn 0;\n}\n\n \nstatic u16 vsc9959_wm_enc(u16 value)\n{\n\tWARN_ON(value >= 16 * BIT(8));\n\n\tif (value >= BIT(8))\n\t\treturn BIT(8) | (value / 16);\n\n\treturn value;\n}\n\nstatic u16 vsc9959_wm_dec(u16 wm)\n{\n\tWARN_ON(wm & ~GENMASK(8, 0));\n\n\tif (wm & BIT(8))\n\t\treturn (wm & GENMASK(7, 0)) * 16;\n\n\treturn wm;\n}\n\nstatic void vsc9959_wm_stat(u32 val, u32 *inuse, u32 *maxuse)\n{\n\t*inuse = (val & GENMASK(23, 12)) >> 12;\n\t*maxuse = val & GENMASK(11, 0);\n}\n\nstatic int vsc9959_mdio_bus_alloc(struct ocelot *ocelot)\n{\n\tstruct pci_dev *pdev = to_pci_dev(ocelot->dev);\n\tstruct felix *felix = ocelot_to_felix(ocelot);\n\tstruct enetc_mdio_priv *mdio_priv;\n\tstruct device *dev = ocelot->dev;\n\tresource_size_t imdio_base;\n\tvoid __iomem *imdio_regs;\n\tstruct resource res;\n\tstruct enetc_hw *hw;\n\tstruct mii_bus *bus;\n\tint port;\n\tint rc;\n\n\tfelix->pcs = devm_kcalloc(dev, felix->info->num_ports,\n\t\t\t\t  sizeof(struct phylink_pcs *),\n\t\t\t\t  GFP_KERNEL);\n\tif (!felix->pcs) {\n\t\tdev_err(dev, \"failed to allocate array for PCS PHYs\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\timdio_base = pci_resource_start(pdev, VSC9959_IMDIO_PCI_BAR);\n\n\tmemcpy(&res, &vsc9959_imdio_res, sizeof(res));\n\tres.start += imdio_base;\n\tres.end += imdio_base;\n\n\timdio_regs = devm_ioremap_resource(dev, &res);\n\tif (IS_ERR(imdio_regs))\n\t\treturn PTR_ERR(imdio_regs);\n\n\thw = enetc_hw_alloc(dev, imdio_regs);\n\tif (IS_ERR(hw)) {\n\t\tdev_err(dev, \"failed to allocate ENETC HW structure\\n\");\n\t\treturn PTR_ERR(hw);\n\t}\n\n\tbus = mdiobus_alloc_size(sizeof(*mdio_priv));\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\tbus->name = \"VSC9959 internal MDIO bus\";\n\tbus->read = enetc_mdio_read_c22;\n\tbus->write = enetc_mdio_write_c22;\n\tbus->read_c45 = enetc_mdio_read_c45;\n\tbus->write_c45 = enetc_mdio_write_c45;\n\tbus->parent = dev;\n\tmdio_priv = bus->priv;\n\tmdio_priv->hw = hw;\n\t \n\tmdio_priv->mdio_base = 0;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-imdio\", dev_name(dev));\n\n\t \n\trc = mdiobus_register(bus);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"failed to register MDIO bus\\n\");\n\t\tmdiobus_free(bus);\n\t\treturn rc;\n\t}\n\n\tfelix->imdio = bus;\n\n\tfor (port = 0; port < felix->info->num_ports; port++) {\n\t\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\t\tstruct phylink_pcs *phylink_pcs;\n\n\t\tif (dsa_is_unused_port(felix->ds, port))\n\t\t\tcontinue;\n\n\t\tif (ocelot_port->phy_mode == PHY_INTERFACE_MODE_INTERNAL)\n\t\t\tcontinue;\n\n\t\tphylink_pcs = lynx_pcs_create_mdiodev(felix->imdio, port);\n\t\tif (IS_ERR(phylink_pcs))\n\t\t\tcontinue;\n\n\t\tfelix->pcs[port] = phylink_pcs;\n\n\t\tdev_info(dev, \"Found PCS at internal MDIO address %d\\n\", port);\n\t}\n\n\treturn 0;\n}\n\nstatic void vsc9959_mdio_bus_free(struct ocelot *ocelot)\n{\n\tstruct felix *felix = ocelot_to_felix(ocelot);\n\tint port;\n\n\tfor (port = 0; port < ocelot->num_phys_ports; port++) {\n\t\tstruct phylink_pcs *phylink_pcs = felix->pcs[port];\n\n\t\tif (phylink_pcs)\n\t\t\tlynx_pcs_destroy(phylink_pcs);\n\t}\n\tmdiobus_unregister(felix->imdio);\n\tmdiobus_free(felix->imdio);\n}\n\n \nstatic u64 vsc9959_tas_remaining_gate_len_ps(u64 gate_len_ns)\n{\n\t \n\tif (gate_len_ns == U64_MAX)\n\t\treturn U64_MAX;\n\n\tif (gate_len_ns < VSC9959_TAS_MIN_GATE_LEN_NS)\n\t\treturn 0;\n\n\treturn (gate_len_ns - VSC9959_TAS_MIN_GATE_LEN_NS) * PSEC_PER_NSEC;\n}\n\n \nstatic void vsc9959_tas_min_gate_lengths(struct tc_taprio_qopt_offload *taprio,\n\t\t\t\t\t u64 min_gate_len[OCELOT_NUM_TC])\n{\n\tstruct tc_taprio_sched_entry *entry;\n\tu64 gate_len[OCELOT_NUM_TC];\n\tu8 gates_ever_opened = 0;\n\tint tc, i, n;\n\n\t \n\tfor (tc = 0; tc < OCELOT_NUM_TC; tc++) {\n\t\tmin_gate_len[tc] = U64_MAX;\n\t\tgate_len[tc] = 0;\n\t}\n\n\t \n\tif (!taprio)\n\t\treturn;\n\n\tn = taprio->num_entries;\n\n\t \n\tfor (i = 0; i < 2 * n; i++) {\n\t\tentry = &taprio->entries[i % n];\n\n\t\tfor (tc = 0; tc < OCELOT_NUM_TC; tc++) {\n\t\t\tif (entry->gate_mask & BIT(tc)) {\n\t\t\t\tgate_len[tc] += entry->interval;\n\t\t\t\tgates_ever_opened |= BIT(tc);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (min_gate_len[tc] > gate_len[tc] &&\n\t\t\t\t    gate_len[tc])\n\t\t\t\t\tmin_gate_len[tc] = gate_len[tc];\n\t\t\t\tgate_len[tc] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (tc = 0; tc < OCELOT_NUM_TC; tc++)\n\t\tif (!(gates_ever_opened & BIT(tc)))\n\t\t\tmin_gate_len[tc] = 0;\n}\n\n \nstatic void vsc9959_port_qmaxsdu_set(struct ocelot *ocelot, int port, int tc,\n\t\t\t\t     u32 max_sdu)\n{\n\tswitch (tc) {\n\tcase 0:\n\t\tocelot_write_rix(ocelot, max_sdu, QSYS_QMAXSDU_CFG_0,\n\t\t\t\t port);\n\t\tbreak;\n\tcase 1:\n\t\tocelot_write_rix(ocelot, max_sdu, QSYS_QMAXSDU_CFG_1,\n\t\t\t\t port);\n\t\tbreak;\n\tcase 2:\n\t\tocelot_write_rix(ocelot, max_sdu, QSYS_QMAXSDU_CFG_2,\n\t\t\t\t port);\n\t\tbreak;\n\tcase 3:\n\t\tocelot_write_rix(ocelot, max_sdu, QSYS_QMAXSDU_CFG_3,\n\t\t\t\t port);\n\t\tbreak;\n\tcase 4:\n\t\tocelot_write_rix(ocelot, max_sdu, QSYS_QMAXSDU_CFG_4,\n\t\t\t\t port);\n\t\tbreak;\n\tcase 5:\n\t\tocelot_write_rix(ocelot, max_sdu, QSYS_QMAXSDU_CFG_5,\n\t\t\t\t port);\n\t\tbreak;\n\tcase 6:\n\t\tocelot_write_rix(ocelot, max_sdu, QSYS_QMAXSDU_CFG_6,\n\t\t\t\t port);\n\t\tbreak;\n\tcase 7:\n\t\tocelot_write_rix(ocelot, max_sdu, QSYS_QMAXSDU_CFG_7,\n\t\t\t\t port);\n\t\tbreak;\n\t}\n}\n\nstatic u32 vsc9959_port_qmaxsdu_get(struct ocelot *ocelot, int port, int tc)\n{\n\tswitch (tc) {\n\tcase 0: return ocelot_read_rix(ocelot, QSYS_QMAXSDU_CFG_0, port);\n\tcase 1: return ocelot_read_rix(ocelot, QSYS_QMAXSDU_CFG_1, port);\n\tcase 2: return ocelot_read_rix(ocelot, QSYS_QMAXSDU_CFG_2, port);\n\tcase 3: return ocelot_read_rix(ocelot, QSYS_QMAXSDU_CFG_3, port);\n\tcase 4: return ocelot_read_rix(ocelot, QSYS_QMAXSDU_CFG_4, port);\n\tcase 5: return ocelot_read_rix(ocelot, QSYS_QMAXSDU_CFG_5, port);\n\tcase 6: return ocelot_read_rix(ocelot, QSYS_QMAXSDU_CFG_6, port);\n\tcase 7: return ocelot_read_rix(ocelot, QSYS_QMAXSDU_CFG_7, port);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic u32 vsc9959_tas_tc_max_sdu(struct tc_taprio_qopt_offload *taprio, int tc)\n{\n\tif (!taprio || !taprio->max_sdu[tc])\n\t\treturn 0;\n\n\treturn taprio->max_sdu[tc] + ETH_HLEN + 2 * VLAN_HLEN + ETH_FCS_LEN;\n}\n\n \nstatic void vsc9959_tas_guard_bands_update(struct ocelot *ocelot, int port)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tstruct ocelot_mm_state *mm = &ocelot->mm[port];\n\tstruct tc_taprio_qopt_offload *taprio;\n\tu64 min_gate_len[OCELOT_NUM_TC];\n\tu32 val, maxlen, add_frag_size;\n\tu64 needed_min_frag_time_ps;\n\tint speed, picos_per_byte;\n\tu64 needed_bit_time_ps;\n\tu8 tas_speed;\n\tint tc;\n\n\tlockdep_assert_held(&ocelot->fwd_domain_lock);\n\n\ttaprio = ocelot_port->taprio;\n\n\tval = ocelot_read_rix(ocelot, QSYS_TAG_CONFIG, port);\n\ttas_speed = QSYS_TAG_CONFIG_LINK_SPEED_X(val);\n\n\tswitch (tas_speed) {\n\tcase OCELOT_SPEED_10:\n\t\tspeed = SPEED_10;\n\t\tbreak;\n\tcase OCELOT_SPEED_100:\n\t\tspeed = SPEED_100;\n\t\tbreak;\n\tcase OCELOT_SPEED_1000:\n\t\tspeed = SPEED_1000;\n\t\tbreak;\n\tcase OCELOT_SPEED_2500:\n\t\tspeed = SPEED_2500;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tpicos_per_byte = (USEC_PER_SEC * 8) / speed;\n\n\tval = ocelot_port_readl(ocelot_port, DEV_MAC_MAXLEN_CFG);\n\t \n\tmaxlen = val + 2 * VLAN_HLEN;\n\t \n\tneeded_bit_time_ps = (u64)(maxlen + 24) * picos_per_byte;\n\n\t \n\tval = ocelot_read_rix(ocelot, QSYS_PREEMPTION_CFG, port);\n\tadd_frag_size = QSYS_PREEMPTION_CFG_MM_ADD_FRAG_SIZE_X(val);\n\tneeded_min_frag_time_ps = picos_per_byte *\n\t\t(u64)(24 + 2 * ethtool_mm_frag_size_add_to_min(add_frag_size));\n\n\tdev_dbg(ocelot->dev,\n\t\t\"port %d: max frame size %d needs %llu ps, %llu ps for mPackets at speed %d\\n\",\n\t\tport, maxlen, needed_bit_time_ps, needed_min_frag_time_ps,\n\t\tspeed);\n\n\tvsc9959_tas_min_gate_lengths(taprio, min_gate_len);\n\n\tfor (tc = 0; tc < OCELOT_NUM_TC; tc++) {\n\t\tu32 requested_max_sdu = vsc9959_tas_tc_max_sdu(taprio, tc);\n\t\tu64 remaining_gate_len_ps;\n\t\tu32 max_sdu;\n\n\t\tremaining_gate_len_ps =\n\t\t\tvsc9959_tas_remaining_gate_len_ps(min_gate_len[tc]);\n\n\t\tif ((mm->active_preemptible_tcs & BIT(tc)) ?\n\t\t    remaining_gate_len_ps > needed_min_frag_time_ps :\n\t\t    remaining_gate_len_ps > needed_bit_time_ps) {\n\t\t\t \n\t\t\tmax_sdu = requested_max_sdu;\n\t\t\tdev_dbg(ocelot->dev,\n\t\t\t\t\"port %d tc %d min gate len %llu\"\n\t\t\t\t\", sending all frames\\n\",\n\t\t\t\tport, tc, min_gate_len[tc]);\n\t\t} else {\n\t\t\t \n\t\t\tmax_sdu = div_u64(remaining_gate_len_ps, picos_per_byte);\n\t\t\t \n\t\t\tif (!max_sdu)\n\t\t\t\tmax_sdu = 1;\n\t\t\t \n\t\t\tif (max_sdu > 20)\n\t\t\t\tmax_sdu -= 20;\n\n\t\t\tif (requested_max_sdu && requested_max_sdu < max_sdu)\n\t\t\t\tmax_sdu = requested_max_sdu;\n\n\t\t\tdev_info(ocelot->dev,\n\t\t\t\t \"port %d tc %d min gate length %llu\"\n\t\t\t\t \" ns not enough for max frame size %d at %d\"\n\t\t\t\t \" Mbps, dropping frames over %d\"\n\t\t\t\t \" octets including FCS\\n\",\n\t\t\t\t port, tc, min_gate_len[tc], maxlen, speed,\n\t\t\t\t max_sdu);\n\t\t}\n\n\t\tvsc9959_port_qmaxsdu_set(ocelot, port, tc, max_sdu);\n\t}\n\n\tocelot_write_rix(ocelot, maxlen, QSYS_PORT_MAX_SDU, port);\n\n\tocelot->ops->cut_through_fwd(ocelot);\n}\n\nstatic void vsc9959_sched_speed_set(struct ocelot *ocelot, int port,\n\t\t\t\t    u32 speed)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tu8 tas_speed;\n\n\tswitch (speed) {\n\tcase SPEED_10:\n\t\ttas_speed = OCELOT_SPEED_10;\n\t\tbreak;\n\tcase SPEED_100:\n\t\ttas_speed = OCELOT_SPEED_100;\n\t\tbreak;\n\tcase SPEED_1000:\n\t\ttas_speed = OCELOT_SPEED_1000;\n\t\tbreak;\n\tcase SPEED_2500:\n\t\ttas_speed = OCELOT_SPEED_2500;\n\t\tbreak;\n\tdefault:\n\t\ttas_speed = OCELOT_SPEED_1000;\n\t\tbreak;\n\t}\n\n\tmutex_lock(&ocelot->fwd_domain_lock);\n\n\tocelot_rmw_rix(ocelot,\n\t\t       QSYS_TAG_CONFIG_LINK_SPEED(tas_speed),\n\t\t       QSYS_TAG_CONFIG_LINK_SPEED_M,\n\t\t       QSYS_TAG_CONFIG, port);\n\n\tif (ocelot_port->taprio)\n\t\tvsc9959_tas_guard_bands_update(ocelot, port);\n\n\tmutex_unlock(&ocelot->fwd_domain_lock);\n}\n\nstatic void vsc9959_new_base_time(struct ocelot *ocelot, ktime_t base_time,\n\t\t\t\t  u64 cycle_time,\n\t\t\t\t  struct timespec64 *new_base_ts)\n{\n\tstruct timespec64 ts;\n\tktime_t new_base_time;\n\tktime_t current_time;\n\n\tocelot_ptp_gettime64(&ocelot->ptp_info, &ts);\n\tcurrent_time = timespec64_to_ktime(ts);\n\tnew_base_time = base_time;\n\n\tif (base_time < current_time) {\n\t\tu64 nr_of_cycles = current_time - base_time;\n\n\t\tdo_div(nr_of_cycles, cycle_time);\n\t\tnew_base_time += cycle_time * (nr_of_cycles + 1);\n\t}\n\n\t*new_base_ts = ktime_to_timespec64(new_base_time);\n}\n\nstatic u32 vsc9959_tas_read_cfg_status(struct ocelot *ocelot)\n{\n\treturn ocelot_read(ocelot, QSYS_TAS_PARAM_CFG_CTRL);\n}\n\nstatic void vsc9959_tas_gcl_set(struct ocelot *ocelot, const u32 gcl_ix,\n\t\t\t\tstruct tc_taprio_sched_entry *entry)\n{\n\tocelot_write(ocelot,\n\t\t     QSYS_GCL_CFG_REG_1_GCL_ENTRY_NUM(gcl_ix) |\n\t\t     QSYS_GCL_CFG_REG_1_GATE_STATE(entry->gate_mask),\n\t\t     QSYS_GCL_CFG_REG_1);\n\tocelot_write(ocelot, entry->interval, QSYS_GCL_CFG_REG_2);\n}\n\nstatic int vsc9959_qos_port_tas_set(struct ocelot *ocelot, int port,\n\t\t\t\t    struct tc_taprio_qopt_offload *taprio)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tstruct timespec64 base_ts;\n\tint ret, i;\n\tu32 val;\n\n\tmutex_lock(&ocelot->fwd_domain_lock);\n\n\tif (taprio->cmd == TAPRIO_CMD_DESTROY) {\n\t\tocelot_port_mqprio(ocelot, port, &taprio->mqprio);\n\t\tocelot_rmw_rix(ocelot, 0, QSYS_TAG_CONFIG_ENABLE,\n\t\t\t       QSYS_TAG_CONFIG, port);\n\n\t\ttaprio_offload_free(ocelot_port->taprio);\n\t\tocelot_port->taprio = NULL;\n\n\t\tvsc9959_tas_guard_bands_update(ocelot, port);\n\n\t\tmutex_unlock(&ocelot->fwd_domain_lock);\n\t\treturn 0;\n\t} else if (taprio->cmd != TAPRIO_CMD_REPLACE) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto err_unlock;\n\t}\n\n\tret = ocelot_port_mqprio(ocelot, port, &taprio->mqprio);\n\tif (ret)\n\t\tgoto err_unlock;\n\n\tif (taprio->cycle_time > NSEC_PER_SEC ||\n\t    taprio->cycle_time_extension >= NSEC_PER_SEC) {\n\t\tret = -EINVAL;\n\t\tgoto err_reset_tc;\n\t}\n\n\tif (taprio->num_entries > VSC9959_TAS_GCL_ENTRY_MAX) {\n\t\tret = -ERANGE;\n\t\tgoto err_reset_tc;\n\t}\n\n\t \n\tocelot_rmw(ocelot, QSYS_TAS_PARAM_CFG_CTRL_PORT_NUM(port) |\n\t\t   QSYS_TAS_PARAM_CFG_CTRL_ALWAYS_GUARD_BAND_SCH_Q,\n\t\t   QSYS_TAS_PARAM_CFG_CTRL_PORT_NUM_M |\n\t\t   QSYS_TAS_PARAM_CFG_CTRL_ALWAYS_GUARD_BAND_SCH_Q,\n\t\t   QSYS_TAS_PARAM_CFG_CTRL);\n\n\t \n\tval = ocelot_read(ocelot, QSYS_PARAM_STATUS_REG_8);\n\tif (val & QSYS_PARAM_STATUS_REG_8_CONFIG_PENDING) {\n\t\tret = -EBUSY;\n\t\tgoto err_reset_tc;\n\t}\n\n\tocelot_rmw_rix(ocelot,\n\t\t       QSYS_TAG_CONFIG_ENABLE |\n\t\t       QSYS_TAG_CONFIG_INIT_GATE_STATE(0xFF) |\n\t\t       QSYS_TAG_CONFIG_SCH_TRAFFIC_QUEUES(0xFF),\n\t\t       QSYS_TAG_CONFIG_ENABLE |\n\t\t       QSYS_TAG_CONFIG_INIT_GATE_STATE_M |\n\t\t       QSYS_TAG_CONFIG_SCH_TRAFFIC_QUEUES_M,\n\t\t       QSYS_TAG_CONFIG, port);\n\n\tvsc9959_new_base_time(ocelot, taprio->base_time,\n\t\t\t      taprio->cycle_time, &base_ts);\n\tocelot_write(ocelot, base_ts.tv_nsec, QSYS_PARAM_CFG_REG_1);\n\tocelot_write(ocelot, lower_32_bits(base_ts.tv_sec), QSYS_PARAM_CFG_REG_2);\n\tval = upper_32_bits(base_ts.tv_sec);\n\tocelot_write(ocelot,\n\t\t     QSYS_PARAM_CFG_REG_3_BASE_TIME_SEC_MSB(val) |\n\t\t     QSYS_PARAM_CFG_REG_3_LIST_LENGTH(taprio->num_entries),\n\t\t     QSYS_PARAM_CFG_REG_3);\n\tocelot_write(ocelot, taprio->cycle_time, QSYS_PARAM_CFG_REG_4);\n\tocelot_write(ocelot, taprio->cycle_time_extension, QSYS_PARAM_CFG_REG_5);\n\n\tfor (i = 0; i < taprio->num_entries; i++)\n\t\tvsc9959_tas_gcl_set(ocelot, i, &taprio->entries[i]);\n\n\tocelot_rmw(ocelot, QSYS_TAS_PARAM_CFG_CTRL_CONFIG_CHANGE,\n\t\t   QSYS_TAS_PARAM_CFG_CTRL_CONFIG_CHANGE,\n\t\t   QSYS_TAS_PARAM_CFG_CTRL);\n\n\tret = readx_poll_timeout(vsc9959_tas_read_cfg_status, ocelot, val,\n\t\t\t\t !(val & QSYS_TAS_PARAM_CFG_CTRL_CONFIG_CHANGE),\n\t\t\t\t 10, 100000);\n\tif (ret)\n\t\tgoto err_reset_tc;\n\n\tocelot_port->taprio = taprio_offload_get(taprio);\n\tvsc9959_tas_guard_bands_update(ocelot, port);\n\n\tmutex_unlock(&ocelot->fwd_domain_lock);\n\n\treturn 0;\n\nerr_reset_tc:\n\ttaprio->mqprio.qopt.num_tc = 0;\n\tocelot_port_mqprio(ocelot, port, &taprio->mqprio);\nerr_unlock:\n\tmutex_unlock(&ocelot->fwd_domain_lock);\n\n\treturn ret;\n}\n\nstatic void vsc9959_tas_clock_adjust(struct ocelot *ocelot)\n{\n\tstruct tc_taprio_qopt_offload *taprio;\n\tstruct ocelot_port *ocelot_port;\n\tstruct timespec64 base_ts;\n\tint port;\n\tu32 val;\n\n\tmutex_lock(&ocelot->fwd_domain_lock);\n\n\tfor (port = 0; port < ocelot->num_phys_ports; port++) {\n\t\tocelot_port = ocelot->ports[port];\n\t\ttaprio = ocelot_port->taprio;\n\t\tif (!taprio)\n\t\t\tcontinue;\n\n\t\tocelot_rmw(ocelot,\n\t\t\t   QSYS_TAS_PARAM_CFG_CTRL_PORT_NUM(port),\n\t\t\t   QSYS_TAS_PARAM_CFG_CTRL_PORT_NUM_M,\n\t\t\t   QSYS_TAS_PARAM_CFG_CTRL);\n\n\t\t \n\t\tocelot_rmw_rix(ocelot, 0, QSYS_TAG_CONFIG_ENABLE,\n\t\t\t       QSYS_TAG_CONFIG, port);\n\n\t\tvsc9959_new_base_time(ocelot, taprio->base_time,\n\t\t\t\t      taprio->cycle_time, &base_ts);\n\n\t\tocelot_write(ocelot, base_ts.tv_nsec, QSYS_PARAM_CFG_REG_1);\n\t\tocelot_write(ocelot, lower_32_bits(base_ts.tv_sec),\n\t\t\t     QSYS_PARAM_CFG_REG_2);\n\t\tval = upper_32_bits(base_ts.tv_sec);\n\t\tocelot_rmw(ocelot,\n\t\t\t   QSYS_PARAM_CFG_REG_3_BASE_TIME_SEC_MSB(val),\n\t\t\t   QSYS_PARAM_CFG_REG_3_BASE_TIME_SEC_MSB_M,\n\t\t\t   QSYS_PARAM_CFG_REG_3);\n\n\t\tocelot_rmw(ocelot, QSYS_TAS_PARAM_CFG_CTRL_CONFIG_CHANGE,\n\t\t\t   QSYS_TAS_PARAM_CFG_CTRL_CONFIG_CHANGE,\n\t\t\t   QSYS_TAS_PARAM_CFG_CTRL);\n\n\t\t \n\t\tocelot_rmw_rix(ocelot, QSYS_TAG_CONFIG_ENABLE,\n\t\t\t       QSYS_TAG_CONFIG_ENABLE,\n\t\t\t       QSYS_TAG_CONFIG, port);\n\t}\n\tmutex_unlock(&ocelot->fwd_domain_lock);\n}\n\nstatic int vsc9959_qos_port_cbs_set(struct dsa_switch *ds, int port,\n\t\t\t\t    struct tc_cbs_qopt_offload *cbs_qopt)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tint port_ix = port * 8 + cbs_qopt->queue;\n\tu32 rate, burst;\n\n\tif (cbs_qopt->queue >= ds->num_tx_queues)\n\t\treturn -EINVAL;\n\n\tif (!cbs_qopt->enable) {\n\t\tocelot_write_gix(ocelot, QSYS_CIR_CFG_CIR_RATE(0) |\n\t\t\t\t QSYS_CIR_CFG_CIR_BURST(0),\n\t\t\t\t QSYS_CIR_CFG, port_ix);\n\n\t\tocelot_rmw_gix(ocelot, 0, QSYS_SE_CFG_SE_AVB_ENA,\n\t\t\t       QSYS_SE_CFG, port_ix);\n\n\t\treturn 0;\n\t}\n\n\t \n\trate = DIV_ROUND_UP(cbs_qopt->idleslope, 100);\n\t \n\trate = clamp_t(u32, rate, 1, GENMASK(14, 0));\n\t \n\tburst = DIV_ROUND_UP(cbs_qopt->hicredit, 4096);\n\t \n\tburst = clamp_t(u32, burst, 1, GENMASK(5, 0));\n\tocelot_write_gix(ocelot,\n\t\t\t QSYS_CIR_CFG_CIR_RATE(rate) |\n\t\t\t QSYS_CIR_CFG_CIR_BURST(burst),\n\t\t\t QSYS_CIR_CFG,\n\t\t\t port_ix);\n\n\tocelot_rmw_gix(ocelot,\n\t\t       QSYS_SE_CFG_SE_FRM_MODE(0) |\n\t\t       QSYS_SE_CFG_SE_AVB_ENA,\n\t\t       QSYS_SE_CFG_SE_AVB_ENA |\n\t\t       QSYS_SE_CFG_SE_FRM_MODE_M,\n\t\t       QSYS_SE_CFG,\n\t\t       port_ix);\n\n\treturn 0;\n}\n\nstatic int vsc9959_qos_query_caps(struct tc_query_caps_base *base)\n{\n\tswitch (base->type) {\n\tcase TC_SETUP_QDISC_MQPRIO: {\n\t\tstruct tc_mqprio_caps *caps = base->caps;\n\n\t\tcaps->validate_queue_counts = true;\n\n\t\treturn 0;\n\t}\n\tcase TC_SETUP_QDISC_TAPRIO: {\n\t\tstruct tc_taprio_caps *caps = base->caps;\n\n\t\tcaps->supports_queue_max_sdu = true;\n\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int vsc9959_qos_port_mqprio(struct ocelot *ocelot, int port,\n\t\t\t\t   struct tc_mqprio_qopt_offload *mqprio)\n{\n\tint ret;\n\n\tmutex_lock(&ocelot->fwd_domain_lock);\n\tret = ocelot_port_mqprio(ocelot, port, mqprio);\n\tmutex_unlock(&ocelot->fwd_domain_lock);\n\n\treturn ret;\n}\n\nstatic int vsc9959_port_setup_tc(struct dsa_switch *ds, int port,\n\t\t\t\t enum tc_setup_type type,\n\t\t\t\t void *type_data)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\tswitch (type) {\n\tcase TC_QUERY_CAPS:\n\t\treturn vsc9959_qos_query_caps(type_data);\n\tcase TC_SETUP_QDISC_TAPRIO:\n\t\treturn vsc9959_qos_port_tas_set(ocelot, port, type_data);\n\tcase TC_SETUP_QDISC_MQPRIO:\n\t\treturn vsc9959_qos_port_mqprio(ocelot, port, type_data);\n\tcase TC_SETUP_QDISC_CBS:\n\t\treturn vsc9959_qos_port_cbs_set(ds, port, type_data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n#define VSC9959_PSFP_SFID_MAX\t\t\t175\n#define VSC9959_PSFP_GATE_ID_MAX\t\t183\n#define VSC9959_PSFP_POLICER_BASE\t\t63\n#define VSC9959_PSFP_POLICER_MAX\t\t383\n#define VSC9959_PSFP_GATE_LIST_NUM\t\t4\n#define VSC9959_PSFP_GATE_CYCLETIME_MIN\t\t5000\n\nstruct felix_stream {\n\tstruct list_head list;\n\tunsigned long id;\n\tbool dummy;\n\tint ports;\n\tint port;\n\tu8 dmac[ETH_ALEN];\n\tu16 vid;\n\ts8 prio;\n\tu8 sfid_valid;\n\tu8 ssid_valid;\n\tu32 sfid;\n\tu32 ssid;\n};\n\nstruct felix_stream_filter_counters {\n\tu64 match;\n\tu64 not_pass_gate;\n\tu64 not_pass_sdu;\n\tu64 red;\n};\n\nstruct felix_stream_filter {\n\tstruct felix_stream_filter_counters stats;\n\tstruct list_head list;\n\trefcount_t refcount;\n\tu32 index;\n\tu8 enable;\n\tint portmask;\n\tu8 sg_valid;\n\tu32 sgid;\n\tu8 fm_valid;\n\tu32 fmid;\n\tu8 prio_valid;\n\tu8 prio;\n\tu32 maxsdu;\n};\n\nstruct felix_stream_gate {\n\tu32 index;\n\tu8 enable;\n\tu8 ipv_valid;\n\tu8 init_ipv;\n\tu64 basetime;\n\tu64 cycletime;\n\tu64 cycletime_ext;\n\tu32 num_entries;\n\tstruct action_gate_entry entries[];\n};\n\nstruct felix_stream_gate_entry {\n\tstruct list_head list;\n\trefcount_t refcount;\n\tu32 index;\n};\n\nstatic int vsc9959_stream_identify(struct flow_cls_offload *f,\n\t\t\t\t   struct felix_stream *stream)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(f);\n\tstruct flow_dissector *dissector = rule->match.dissector;\n\n\tif (dissector->used_keys &\n\t    ~(BIT_ULL(FLOW_DISSECTOR_KEY_CONTROL) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_BASIC) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_VLAN) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ETH_ADDRS)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tstruct flow_match_eth_addrs match;\n\n\t\tflow_rule_match_eth_addrs(rule, &match);\n\t\tether_addr_copy(stream->dmac, match.key->dst);\n\t\tif (!is_zero_ether_addr(match.mask->src))\n\t\t\treturn -EOPNOTSUPP;\n\t} else {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_VLAN)) {\n\t\tstruct flow_match_vlan match;\n\n\t\tflow_rule_match_vlan(rule, &match);\n\t\tif (match.mask->vlan_priority)\n\t\t\tstream->prio = match.key->vlan_priority;\n\t\telse\n\t\t\tstream->prio = -1;\n\n\t\tif (!match.mask->vlan_id)\n\t\t\treturn -EOPNOTSUPP;\n\t\tstream->vid = match.key->vlan_id;\n\t} else {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tstream->id = f->cookie;\n\n\treturn 0;\n}\n\nstatic int vsc9959_mact_stream_set(struct ocelot *ocelot,\n\t\t\t\t   struct felix_stream *stream,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tenum macaccess_entry_type type;\n\tint ret, sfid, ssid;\n\tu32 vid, dst_idx;\n\tu8 mac[ETH_ALEN];\n\n\tether_addr_copy(mac, stream->dmac);\n\tvid = stream->vid;\n\n\t \n\tret = ocelot_mact_lookup(ocelot, &dst_idx, mac, vid, &type);\n\tif (ret) {\n\t\tif (extack)\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Stream is not learned in MAC table\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif ((stream->sfid_valid || stream->ssid_valid) &&\n\t    type == ENTRYTYPE_NORMAL)\n\t\ttype = ENTRYTYPE_LOCKED;\n\n\tsfid = stream->sfid_valid ? stream->sfid : -1;\n\tssid = stream->ssid_valid ? stream->ssid : -1;\n\n\tret = ocelot_mact_learn_streamdata(ocelot, dst_idx, mac, vid, type,\n\t\t\t\t\t   sfid, ssid);\n\n\treturn ret;\n}\n\nstatic struct felix_stream *\nvsc9959_stream_table_lookup(struct list_head *stream_list,\n\t\t\t    struct felix_stream *stream)\n{\n\tstruct felix_stream *tmp;\n\n\tlist_for_each_entry(tmp, stream_list, list)\n\t\tif (ether_addr_equal(tmp->dmac, stream->dmac) &&\n\t\t    tmp->vid == stream->vid)\n\t\t\treturn tmp;\n\n\treturn NULL;\n}\n\nstatic int vsc9959_stream_table_add(struct ocelot *ocelot,\n\t\t\t\t    struct list_head *stream_list,\n\t\t\t\t    struct felix_stream *stream,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct felix_stream *stream_entry;\n\tint ret;\n\n\tstream_entry = kmemdup(stream, sizeof(*stream_entry), GFP_KERNEL);\n\tif (!stream_entry)\n\t\treturn -ENOMEM;\n\n\tif (!stream->dummy) {\n\t\tret = vsc9959_mact_stream_set(ocelot, stream_entry, extack);\n\t\tif (ret) {\n\t\t\tkfree(stream_entry);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tlist_add_tail(&stream_entry->list, stream_list);\n\n\treturn 0;\n}\n\nstatic struct felix_stream *\nvsc9959_stream_table_get(struct list_head *stream_list, unsigned long id)\n{\n\tstruct felix_stream *tmp;\n\n\tlist_for_each_entry(tmp, stream_list, list)\n\t\tif (tmp->id == id)\n\t\t\treturn tmp;\n\n\treturn NULL;\n}\n\nstatic void vsc9959_stream_table_del(struct ocelot *ocelot,\n\t\t\t\t     struct felix_stream *stream)\n{\n\tif (!stream->dummy)\n\t\tvsc9959_mact_stream_set(ocelot, stream, NULL);\n\n\tlist_del(&stream->list);\n\tkfree(stream);\n}\n\nstatic u32 vsc9959_sfi_access_status(struct ocelot *ocelot)\n{\n\treturn ocelot_read(ocelot, ANA_TABLES_SFIDACCESS);\n}\n\nstatic int vsc9959_psfp_sfi_set(struct ocelot *ocelot,\n\t\t\t\tstruct felix_stream_filter *sfi)\n{\n\tu32 val;\n\n\tif (sfi->index > VSC9959_PSFP_SFID_MAX)\n\t\treturn -EINVAL;\n\n\tif (!sfi->enable) {\n\t\tocelot_write(ocelot, ANA_TABLES_SFIDTIDX_SFID_INDEX(sfi->index),\n\t\t\t     ANA_TABLES_SFIDTIDX);\n\n\t\tval = ANA_TABLES_SFIDACCESS_SFID_TBL_CMD(SFIDACCESS_CMD_WRITE);\n\t\tocelot_write(ocelot, val, ANA_TABLES_SFIDACCESS);\n\n\t\treturn readx_poll_timeout(vsc9959_sfi_access_status, ocelot, val,\n\t\t\t\t\t  (!ANA_TABLES_SFIDACCESS_SFID_TBL_CMD(val)),\n\t\t\t\t\t  10, 100000);\n\t}\n\n\tif (sfi->sgid > VSC9959_PSFP_GATE_ID_MAX ||\n\t    sfi->fmid > VSC9959_PSFP_POLICER_MAX)\n\t\treturn -EINVAL;\n\n\tocelot_write(ocelot,\n\t\t     (sfi->sg_valid ? ANA_TABLES_SFIDTIDX_SGID_VALID : 0) |\n\t\t     ANA_TABLES_SFIDTIDX_SGID(sfi->sgid) |\n\t\t     (sfi->fm_valid ? ANA_TABLES_SFIDTIDX_POL_ENA : 0) |\n\t\t     ANA_TABLES_SFIDTIDX_POL_IDX(sfi->fmid) |\n\t\t     ANA_TABLES_SFIDTIDX_SFID_INDEX(sfi->index),\n\t\t     ANA_TABLES_SFIDTIDX);\n\n\tocelot_write(ocelot,\n\t\t     (sfi->prio_valid ? ANA_TABLES_SFIDACCESS_IGR_PRIO_MATCH_ENA : 0) |\n\t\t     ANA_TABLES_SFIDACCESS_IGR_PRIO(sfi->prio) |\n\t\t     ANA_TABLES_SFIDACCESS_MAX_SDU_LEN(sfi->maxsdu) |\n\t\t     ANA_TABLES_SFIDACCESS_SFID_TBL_CMD(SFIDACCESS_CMD_WRITE),\n\t\t     ANA_TABLES_SFIDACCESS);\n\n\treturn readx_poll_timeout(vsc9959_sfi_access_status, ocelot, val,\n\t\t\t\t  (!ANA_TABLES_SFIDACCESS_SFID_TBL_CMD(val)),\n\t\t\t\t  10, 100000);\n}\n\nstatic int vsc9959_psfp_sfidmask_set(struct ocelot *ocelot, u32 sfid, int ports)\n{\n\tu32 val;\n\n\tocelot_rmw(ocelot,\n\t\t   ANA_TABLES_SFIDTIDX_SFID_INDEX(sfid),\n\t\t   ANA_TABLES_SFIDTIDX_SFID_INDEX_M,\n\t\t   ANA_TABLES_SFIDTIDX);\n\n\tocelot_write(ocelot,\n\t\t     ANA_TABLES_SFID_MASK_IGR_PORT_MASK(ports) |\n\t\t     ANA_TABLES_SFID_MASK_IGR_SRCPORT_MATCH_ENA,\n\t\t     ANA_TABLES_SFID_MASK);\n\n\tocelot_rmw(ocelot,\n\t\t   ANA_TABLES_SFIDACCESS_SFID_TBL_CMD(SFIDACCESS_CMD_WRITE),\n\t\t   ANA_TABLES_SFIDACCESS_SFID_TBL_CMD_M,\n\t\t   ANA_TABLES_SFIDACCESS);\n\n\treturn readx_poll_timeout(vsc9959_sfi_access_status, ocelot, val,\n\t\t\t\t  (!ANA_TABLES_SFIDACCESS_SFID_TBL_CMD(val)),\n\t\t\t\t  10, 100000);\n}\n\nstatic int vsc9959_psfp_sfi_list_add(struct ocelot *ocelot,\n\t\t\t\t     struct felix_stream_filter *sfi,\n\t\t\t\t     struct list_head *pos)\n{\n\tstruct felix_stream_filter *sfi_entry;\n\tint ret;\n\n\tsfi_entry = kmemdup(sfi, sizeof(*sfi_entry), GFP_KERNEL);\n\tif (!sfi_entry)\n\t\treturn -ENOMEM;\n\n\trefcount_set(&sfi_entry->refcount, 1);\n\n\tret = vsc9959_psfp_sfi_set(ocelot, sfi_entry);\n\tif (ret) {\n\t\tkfree(sfi_entry);\n\t\treturn ret;\n\t}\n\n\tvsc9959_psfp_sfidmask_set(ocelot, sfi->index, sfi->portmask);\n\n\tlist_add(&sfi_entry->list, pos);\n\n\treturn 0;\n}\n\nstatic int vsc9959_psfp_sfi_table_add(struct ocelot *ocelot,\n\t\t\t\t      struct felix_stream_filter *sfi)\n{\n\tstruct list_head *pos, *q, *last;\n\tstruct felix_stream_filter *tmp;\n\tstruct ocelot_psfp_list *psfp;\n\tu32 insert = 0;\n\n\tpsfp = &ocelot->psfp;\n\tlast = &psfp->sfi_list;\n\n\tlist_for_each_safe(pos, q, &psfp->sfi_list) {\n\t\ttmp = list_entry(pos, struct felix_stream_filter, list);\n\t\tif (sfi->sg_valid == tmp->sg_valid &&\n\t\t    sfi->fm_valid == tmp->fm_valid &&\n\t\t    sfi->portmask == tmp->portmask &&\n\t\t    tmp->sgid == sfi->sgid &&\n\t\t    tmp->fmid == sfi->fmid) {\n\t\t\tsfi->index = tmp->index;\n\t\t\trefcount_inc(&tmp->refcount);\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tif (tmp->index == insert) {\n\t\t\tlast = pos;\n\t\t\tinsert++;\n\t\t}\n\t}\n\tsfi->index = insert;\n\n\treturn vsc9959_psfp_sfi_list_add(ocelot, sfi, last);\n}\n\nstatic int vsc9959_psfp_sfi_table_add2(struct ocelot *ocelot,\n\t\t\t\t       struct felix_stream_filter *sfi,\n\t\t\t\t       struct felix_stream_filter *sfi2)\n{\n\tstruct felix_stream_filter *tmp;\n\tstruct list_head *pos, *q, *last;\n\tstruct ocelot_psfp_list *psfp;\n\tu32 insert = 0;\n\tint ret;\n\n\tpsfp = &ocelot->psfp;\n\tlast = &psfp->sfi_list;\n\n\tlist_for_each_safe(pos, q, &psfp->sfi_list) {\n\t\ttmp = list_entry(pos, struct felix_stream_filter, list);\n\t\t \n\t\tif (tmp->index >= insert + 2)\n\t\t\tbreak;\n\n\t\tinsert = tmp->index + 1;\n\t\tlast = pos;\n\t}\n\tsfi->index = insert;\n\n\tret = vsc9959_psfp_sfi_list_add(ocelot, sfi, last);\n\tif (ret)\n\t\treturn ret;\n\n\tsfi2->index = insert + 1;\n\n\treturn vsc9959_psfp_sfi_list_add(ocelot, sfi2, last->next);\n}\n\nstatic struct felix_stream_filter *\nvsc9959_psfp_sfi_table_get(struct list_head *sfi_list, u32 index)\n{\n\tstruct felix_stream_filter *tmp;\n\n\tlist_for_each_entry(tmp, sfi_list, list)\n\t\tif (tmp->index == index)\n\t\t\treturn tmp;\n\n\treturn NULL;\n}\n\nstatic void vsc9959_psfp_sfi_table_del(struct ocelot *ocelot, u32 index)\n{\n\tstruct felix_stream_filter *tmp, *n;\n\tstruct ocelot_psfp_list *psfp;\n\tu8 z;\n\n\tpsfp = &ocelot->psfp;\n\n\tlist_for_each_entry_safe(tmp, n, &psfp->sfi_list, list)\n\t\tif (tmp->index == index) {\n\t\t\tz = refcount_dec_and_test(&tmp->refcount);\n\t\t\tif (z) {\n\t\t\t\ttmp->enable = 0;\n\t\t\t\tvsc9959_psfp_sfi_set(ocelot, tmp);\n\t\t\t\tlist_del(&tmp->list);\n\t\t\t\tkfree(tmp);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n}\n\nstatic void vsc9959_psfp_parse_gate(const struct flow_action_entry *entry,\n\t\t\t\t    struct felix_stream_gate *sgi)\n{\n\tsgi->index = entry->hw_index;\n\tsgi->ipv_valid = (entry->gate.prio < 0) ? 0 : 1;\n\tsgi->init_ipv = (sgi->ipv_valid) ? entry->gate.prio : 0;\n\tsgi->basetime = entry->gate.basetime;\n\tsgi->cycletime = entry->gate.cycletime;\n\tsgi->num_entries = entry->gate.num_entries;\n\tsgi->enable = 1;\n\n\tmemcpy(sgi->entries, entry->gate.entries,\n\t       entry->gate.num_entries * sizeof(struct action_gate_entry));\n}\n\nstatic u32 vsc9959_sgi_cfg_status(struct ocelot *ocelot)\n{\n\treturn ocelot_read(ocelot, ANA_SG_ACCESS_CTRL);\n}\n\nstatic int vsc9959_psfp_sgi_set(struct ocelot *ocelot,\n\t\t\t\tstruct felix_stream_gate *sgi)\n{\n\tstruct action_gate_entry *e;\n\tstruct timespec64 base_ts;\n\tu32 interval_sum = 0;\n\tu32 val;\n\tint i;\n\n\tif (sgi->index > VSC9959_PSFP_GATE_ID_MAX)\n\t\treturn -EINVAL;\n\n\tocelot_write(ocelot, ANA_SG_ACCESS_CTRL_SGID(sgi->index),\n\t\t     ANA_SG_ACCESS_CTRL);\n\n\tif (!sgi->enable) {\n\t\tocelot_rmw(ocelot, ANA_SG_CONFIG_REG_3_INIT_GATE_STATE,\n\t\t\t   ANA_SG_CONFIG_REG_3_INIT_GATE_STATE |\n\t\t\t   ANA_SG_CONFIG_REG_3_GATE_ENABLE,\n\t\t\t   ANA_SG_CONFIG_REG_3);\n\n\t\treturn 0;\n\t}\n\n\tif (sgi->cycletime < VSC9959_PSFP_GATE_CYCLETIME_MIN ||\n\t    sgi->cycletime > NSEC_PER_SEC)\n\t\treturn -EINVAL;\n\n\tif (sgi->num_entries > VSC9959_PSFP_GATE_LIST_NUM)\n\t\treturn -EINVAL;\n\n\tvsc9959_new_base_time(ocelot, sgi->basetime, sgi->cycletime, &base_ts);\n\tocelot_write(ocelot, base_ts.tv_nsec, ANA_SG_CONFIG_REG_1);\n\tval = lower_32_bits(base_ts.tv_sec);\n\tocelot_write(ocelot, val, ANA_SG_CONFIG_REG_2);\n\n\tval = upper_32_bits(base_ts.tv_sec);\n\tocelot_write(ocelot,\n\t\t     (sgi->ipv_valid ? ANA_SG_CONFIG_REG_3_IPV_VALID : 0) |\n\t\t     ANA_SG_CONFIG_REG_3_INIT_IPV(sgi->init_ipv) |\n\t\t     ANA_SG_CONFIG_REG_3_GATE_ENABLE |\n\t\t     ANA_SG_CONFIG_REG_3_LIST_LENGTH(sgi->num_entries) |\n\t\t     ANA_SG_CONFIG_REG_3_INIT_GATE_STATE |\n\t\t     ANA_SG_CONFIG_REG_3_BASE_TIME_SEC_MSB(val),\n\t\t     ANA_SG_CONFIG_REG_3);\n\n\tocelot_write(ocelot, sgi->cycletime, ANA_SG_CONFIG_REG_4);\n\n\te = sgi->entries;\n\tfor (i = 0; i < sgi->num_entries; i++) {\n\t\tu32 ips = (e[i].ipv < 0) ? 0 : (e[i].ipv + 8);\n\n\t\tocelot_write_rix(ocelot, ANA_SG_GCL_GS_CONFIG_IPS(ips) |\n\t\t\t\t (e[i].gate_state ?\n\t\t\t\t  ANA_SG_GCL_GS_CONFIG_GATE_STATE : 0),\n\t\t\t\t ANA_SG_GCL_GS_CONFIG, i);\n\n\t\tinterval_sum += e[i].interval;\n\t\tocelot_write_rix(ocelot, interval_sum, ANA_SG_GCL_TI_CONFIG, i);\n\t}\n\n\tocelot_rmw(ocelot, ANA_SG_ACCESS_CTRL_CONFIG_CHANGE,\n\t\t   ANA_SG_ACCESS_CTRL_CONFIG_CHANGE,\n\t\t   ANA_SG_ACCESS_CTRL);\n\n\treturn readx_poll_timeout(vsc9959_sgi_cfg_status, ocelot, val,\n\t\t\t\t  (!(ANA_SG_ACCESS_CTRL_CONFIG_CHANGE & val)),\n\t\t\t\t  10, 100000);\n}\n\nstatic int vsc9959_psfp_sgi_table_add(struct ocelot *ocelot,\n\t\t\t\t      struct felix_stream_gate *sgi)\n{\n\tstruct felix_stream_gate_entry *tmp;\n\tstruct ocelot_psfp_list *psfp;\n\tint ret;\n\n\tpsfp = &ocelot->psfp;\n\n\tlist_for_each_entry(tmp, &psfp->sgi_list, list)\n\t\tif (tmp->index == sgi->index) {\n\t\t\trefcount_inc(&tmp->refcount);\n\t\t\treturn 0;\n\t\t}\n\n\ttmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tret = vsc9959_psfp_sgi_set(ocelot, sgi);\n\tif (ret) {\n\t\tkfree(tmp);\n\t\treturn ret;\n\t}\n\n\ttmp->index = sgi->index;\n\trefcount_set(&tmp->refcount, 1);\n\tlist_add_tail(&tmp->list, &psfp->sgi_list);\n\n\treturn 0;\n}\n\nstatic void vsc9959_psfp_sgi_table_del(struct ocelot *ocelot,\n\t\t\t\t       u32 index)\n{\n\tstruct felix_stream_gate_entry *tmp, *n;\n\tstruct felix_stream_gate sgi = {0};\n\tstruct ocelot_psfp_list *psfp;\n\tu8 z;\n\n\tpsfp = &ocelot->psfp;\n\n\tlist_for_each_entry_safe(tmp, n, &psfp->sgi_list, list)\n\t\tif (tmp->index == index) {\n\t\t\tz = refcount_dec_and_test(&tmp->refcount);\n\t\t\tif (z) {\n\t\t\t\tsgi.index = index;\n\t\t\t\tsgi.enable = 0;\n\t\t\t\tvsc9959_psfp_sgi_set(ocelot, &sgi);\n\t\t\t\tlist_del(&tmp->list);\n\t\t\t\tkfree(tmp);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n}\n\nstatic int vsc9959_psfp_filter_add(struct ocelot *ocelot, int port,\n\t\t\t\t   struct flow_cls_offload *f)\n{\n\tstruct netlink_ext_ack *extack = f->common.extack;\n\tstruct felix_stream_filter old_sfi, *sfi_entry;\n\tstruct felix_stream_filter sfi = {0};\n\tconst struct flow_action_entry *a;\n\tstruct felix_stream *stream_entry;\n\tstruct felix_stream stream = {0};\n\tstruct felix_stream_gate *sgi;\n\tstruct ocelot_psfp_list *psfp;\n\tstruct ocelot_policer pol;\n\tint ret, i, size;\n\tu64 rate, burst;\n\tu32 index;\n\n\tpsfp = &ocelot->psfp;\n\n\tret = vsc9959_stream_identify(f, &stream);\n\tif (ret) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Only can match on VID, PCP, and dest MAC\");\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&psfp->lock);\n\n\tflow_action_for_each(i, a, &f->rule->action) {\n\t\tswitch (a->id) {\n\t\tcase FLOW_ACTION_GATE:\n\t\t\tsize = struct_size(sgi, entries, a->gate.num_entries);\n\t\t\tsgi = kzalloc(size, GFP_KERNEL);\n\t\t\tif (!sgi) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tvsc9959_psfp_parse_gate(a, sgi);\n\t\t\tret = vsc9959_psfp_sgi_table_add(ocelot, sgi);\n\t\t\tif (ret) {\n\t\t\t\tkfree(sgi);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tsfi.sg_valid = 1;\n\t\t\tsfi.sgid = sgi->index;\n\t\t\tkfree(sgi);\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_POLICE:\n\t\t\tindex = a->hw_index + VSC9959_PSFP_POLICER_BASE;\n\t\t\tif (index > VSC9959_PSFP_POLICER_MAX) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\trate = a->police.rate_bytes_ps;\n\t\t\tburst = rate * PSCHED_NS2TICKS(a->police.burst);\n\t\t\tpol = (struct ocelot_policer) {\n\t\t\t\t.burst = div_u64(burst, PSCHED_TICKS_PER_SEC),\n\t\t\t\t.rate = div_u64(rate, 1000) * 8,\n\t\t\t};\n\t\t\tret = ocelot_vcap_policer_add(ocelot, index, &pol);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\n\t\t\tsfi.fm_valid = 1;\n\t\t\tsfi.fmid = index;\n\t\t\tsfi.maxsdu = a->police.mtu;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmutex_unlock(&psfp->lock);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tstream.ports = BIT(port);\n\tstream.port = port;\n\n\tsfi.portmask = stream.ports;\n\tsfi.prio_valid = (stream.prio < 0 ? 0 : 1);\n\tsfi.prio = (sfi.prio_valid ? stream.prio : 0);\n\tsfi.enable = 1;\n\n\t \n\tstream_entry = vsc9959_stream_table_lookup(&psfp->stream_list, &stream);\n\tif (stream_entry) {\n\t\tif (stream_entry->ports & BIT(port)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"The stream is added on this port\");\n\t\t\tret = -EEXIST;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (stream_entry->ports != BIT(stream_entry->port)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"The stream is added on two ports\");\n\t\t\tret = -EEXIST;\n\t\t\tgoto err;\n\t\t}\n\n\t\tstream_entry->ports |= BIT(port);\n\t\tstream.ports = stream_entry->ports;\n\n\t\tsfi_entry = vsc9959_psfp_sfi_table_get(&psfp->sfi_list,\n\t\t\t\t\t\t       stream_entry->sfid);\n\t\tmemcpy(&old_sfi, sfi_entry, sizeof(old_sfi));\n\n\t\tvsc9959_psfp_sfi_table_del(ocelot, stream_entry->sfid);\n\n\t\told_sfi.portmask = stream_entry->ports;\n\t\tsfi.portmask = stream.ports;\n\n\t\tif (stream_entry->port > port) {\n\t\t\tret = vsc9959_psfp_sfi_table_add2(ocelot, &sfi,\n\t\t\t\t\t\t\t  &old_sfi);\n\t\t\tstream_entry->dummy = true;\n\t\t} else {\n\t\t\tret = vsc9959_psfp_sfi_table_add2(ocelot, &old_sfi,\n\t\t\t\t\t\t\t  &sfi);\n\t\t\tstream.dummy = true;\n\t\t}\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tstream_entry->sfid = old_sfi.index;\n\t} else {\n\t\tret = vsc9959_psfp_sfi_table_add(ocelot, &sfi);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tstream.sfid = sfi.index;\n\tstream.sfid_valid = 1;\n\tret = vsc9959_stream_table_add(ocelot, &psfp->stream_list,\n\t\t\t\t       &stream, extack);\n\tif (ret) {\n\t\tvsc9959_psfp_sfi_table_del(ocelot, stream.sfid);\n\t\tgoto err;\n\t}\n\n\tmutex_unlock(&psfp->lock);\n\n\treturn 0;\n\nerr:\n\tif (sfi.sg_valid)\n\t\tvsc9959_psfp_sgi_table_del(ocelot, sfi.sgid);\n\n\tif (sfi.fm_valid)\n\t\tocelot_vcap_policer_del(ocelot, sfi.fmid);\n\n\tmutex_unlock(&psfp->lock);\n\n\treturn ret;\n}\n\nstatic int vsc9959_psfp_filter_del(struct ocelot *ocelot,\n\t\t\t\t   struct flow_cls_offload *f)\n{\n\tstruct felix_stream *stream, tmp, *stream_entry;\n\tstruct ocelot_psfp_list *psfp = &ocelot->psfp;\n\tstatic struct felix_stream_filter *sfi;\n\n\tmutex_lock(&psfp->lock);\n\n\tstream = vsc9959_stream_table_get(&psfp->stream_list, f->cookie);\n\tif (!stream) {\n\t\tmutex_unlock(&psfp->lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tsfi = vsc9959_psfp_sfi_table_get(&psfp->sfi_list, stream->sfid);\n\tif (!sfi) {\n\t\tmutex_unlock(&psfp->lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (sfi->sg_valid)\n\t\tvsc9959_psfp_sgi_table_del(ocelot, sfi->sgid);\n\n\tif (sfi->fm_valid)\n\t\tocelot_vcap_policer_del(ocelot, sfi->fmid);\n\n\tvsc9959_psfp_sfi_table_del(ocelot, stream->sfid);\n\n\tmemcpy(&tmp, stream, sizeof(tmp));\n\n\tstream->sfid_valid = 0;\n\tvsc9959_stream_table_del(ocelot, stream);\n\n\tstream_entry = vsc9959_stream_table_lookup(&psfp->stream_list, &tmp);\n\tif (stream_entry) {\n\t\tstream_entry->ports = BIT(stream_entry->port);\n\t\tif (stream_entry->dummy) {\n\t\t\tstream_entry->dummy = false;\n\t\t\tvsc9959_mact_stream_set(ocelot, stream_entry, NULL);\n\t\t}\n\t\tvsc9959_psfp_sfidmask_set(ocelot, stream_entry->sfid,\n\t\t\t\t\t  stream_entry->ports);\n\t}\n\n\tmutex_unlock(&psfp->lock);\n\n\treturn 0;\n}\n\nstatic void vsc9959_update_sfid_stats(struct ocelot *ocelot,\n\t\t\t\t      struct felix_stream_filter *sfi)\n{\n\tstruct felix_stream_filter_counters *s = &sfi->stats;\n\tu32 match, not_pass_gate, not_pass_sdu, red;\n\tu32 sfid = sfi->index;\n\n\tlockdep_assert_held(&ocelot->stat_view_lock);\n\n\tocelot_rmw(ocelot, SYS_STAT_CFG_STAT_VIEW(sfid),\n\t\t   SYS_STAT_CFG_STAT_VIEW_M,\n\t\t   SYS_STAT_CFG);\n\n\tmatch = ocelot_read(ocelot, SYS_COUNT_SF_MATCHING_FRAMES);\n\tnot_pass_gate = ocelot_read(ocelot, SYS_COUNT_SF_NOT_PASSING_FRAMES);\n\tnot_pass_sdu = ocelot_read(ocelot, SYS_COUNT_SF_NOT_PASSING_SDU);\n\tred = ocelot_read(ocelot, SYS_COUNT_SF_RED_FRAMES);\n\n\t \n\tocelot_write(ocelot,\n\t\t     SYS_STAT_CFG_STAT_VIEW(sfid) |\n\t\t     SYS_STAT_CFG_STAT_CLEAR_SHOT(0x10),\n\t\t     SYS_STAT_CFG);\n\n\ts->match += match;\n\ts->not_pass_gate += not_pass_gate;\n\ts->not_pass_sdu += not_pass_sdu;\n\ts->red += red;\n}\n\n \nstatic void vsc9959_update_stats(struct ocelot *ocelot)\n{\n\tstruct ocelot_psfp_list *psfp = &ocelot->psfp;\n\tstruct felix_stream_filter *sfi;\n\n\tmutex_lock(&psfp->lock);\n\n\tlist_for_each_entry(sfi, &psfp->sfi_list, list)\n\t\tvsc9959_update_sfid_stats(ocelot, sfi);\n\n\tmutex_unlock(&psfp->lock);\n}\n\nstatic int vsc9959_psfp_stats_get(struct ocelot *ocelot,\n\t\t\t\t  struct flow_cls_offload *f,\n\t\t\t\t  struct flow_stats *stats)\n{\n\tstruct ocelot_psfp_list *psfp = &ocelot->psfp;\n\tstruct felix_stream_filter_counters *s;\n\tstatic struct felix_stream_filter *sfi;\n\tstruct felix_stream *stream;\n\n\tstream = vsc9959_stream_table_get(&psfp->stream_list, f->cookie);\n\tif (!stream)\n\t\treturn -ENOMEM;\n\n\tsfi = vsc9959_psfp_sfi_table_get(&psfp->sfi_list, stream->sfid);\n\tif (!sfi)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ocelot->stat_view_lock);\n\n\tvsc9959_update_sfid_stats(ocelot, sfi);\n\n\ts = &sfi->stats;\n\tstats->pkts = s->match;\n\tstats->drops = s->not_pass_gate + s->not_pass_sdu + s->red;\n\n\tmemset(s, 0, sizeof(*s));\n\n\tmutex_unlock(&ocelot->stat_view_lock);\n\n\treturn 0;\n}\n\nstatic void vsc9959_psfp_init(struct ocelot *ocelot)\n{\n\tstruct ocelot_psfp_list *psfp = &ocelot->psfp;\n\n\tINIT_LIST_HEAD(&psfp->stream_list);\n\tINIT_LIST_HEAD(&psfp->sfi_list);\n\tINIT_LIST_HEAD(&psfp->sgi_list);\n\tmutex_init(&psfp->lock);\n}\n\n \nstatic void vsc9959_cut_through_fwd(struct ocelot *ocelot)\n{\n\tstruct felix *felix = ocelot_to_felix(ocelot);\n\tstruct dsa_switch *ds = felix->ds;\n\tint tc, port, other_port;\n\n\tlockdep_assert_held(&ocelot->fwd_domain_lock);\n\n\tfor (port = 0; port < ocelot->num_phys_ports; port++) {\n\t\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\t\tstruct ocelot_mm_state *mm = &ocelot->mm[port];\n\t\tint min_speed = ocelot_port->speed;\n\t\tunsigned long mask = 0;\n\t\tu32 tmp, val = 0;\n\n\t\t \n\t\tif (ocelot_port->speed <= 0)\n\t\t\tgoto set;\n\n\t\tif (dsa_is_cpu_port(ds, port)) {\n\t\t\t \n\t\t\tmask = dsa_user_ports(ds);\n\t\t} else {\n\t\t\tmask = ocelot_get_bridge_fwd_mask(ocelot, port);\n\t\t\tmask &= ~BIT(port);\n\t\t\tif (ocelot->npi >= 0)\n\t\t\t\tmask |= BIT(ocelot->npi);\n\t\t\telse\n\t\t\t\tmask |= ocelot_port_assigned_dsa_8021q_cpu_mask(ocelot,\n\t\t\t\t\t\t\t\t\t\tport);\n\t\t}\n\n\t\t \n\t\tfor_each_set_bit(other_port, &mask, ocelot->num_phys_ports) {\n\t\t\tstruct ocelot_port *other_ocelot_port;\n\n\t\t\tother_ocelot_port = ocelot->ports[other_port];\n\t\t\tif (other_ocelot_port->speed <= 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (min_speed > other_ocelot_port->speed)\n\t\t\t\tmin_speed = other_ocelot_port->speed;\n\t\t}\n\n\t\t \n\t\tif (ocelot_port->speed == min_speed) {\n\t\t\tval = GENMASK(7, 0) & ~mm->active_preemptible_tcs;\n\n\t\t\tfor (tc = 0; tc < OCELOT_NUM_TC; tc++)\n\t\t\t\tif (vsc9959_port_qmaxsdu_get(ocelot, port, tc))\n\t\t\t\t\tval &= ~BIT(tc);\n\t\t}\n\nset:\n\t\ttmp = ocelot_read_rix(ocelot, ANA_CUT_THRU_CFG, port);\n\t\tif (tmp == val)\n\t\t\tcontinue;\n\n\t\tdev_dbg(ocelot->dev,\n\t\t\t\"port %d fwd mask 0x%lx speed %d min_speed %d, %s cut-through forwarding on TC mask 0x%x\\n\",\n\t\t\tport, mask, ocelot_port->speed, min_speed,\n\t\t\tval ? \"enabling\" : \"disabling\", val);\n\n\t\tocelot_write_rix(ocelot, val, ANA_CUT_THRU_CFG, port);\n\t}\n}\n\nstatic const struct ocelot_ops vsc9959_ops = {\n\t.reset\t\t\t= vsc9959_reset,\n\t.wm_enc\t\t\t= vsc9959_wm_enc,\n\t.wm_dec\t\t\t= vsc9959_wm_dec,\n\t.wm_stat\t\t= vsc9959_wm_stat,\n\t.port_to_netdev\t\t= felix_port_to_netdev,\n\t.netdev_to_port\t\t= felix_netdev_to_port,\n\t.psfp_init\t\t= vsc9959_psfp_init,\n\t.psfp_filter_add\t= vsc9959_psfp_filter_add,\n\t.psfp_filter_del\t= vsc9959_psfp_filter_del,\n\t.psfp_stats_get\t\t= vsc9959_psfp_stats_get,\n\t.cut_through_fwd\t= vsc9959_cut_through_fwd,\n\t.tas_clock_adjust\t= vsc9959_tas_clock_adjust,\n\t.update_stats\t\t= vsc9959_update_stats,\n\t.tas_guard_bands_update\t= vsc9959_tas_guard_bands_update,\n};\n\nstatic const struct felix_info felix_info_vsc9959 = {\n\t.resources\t\t= vsc9959_resources,\n\t.num_resources\t\t= ARRAY_SIZE(vsc9959_resources),\n\t.resource_names\t\t= vsc9959_resource_names,\n\t.regfields\t\t= vsc9959_regfields,\n\t.map\t\t\t= vsc9959_regmap,\n\t.ops\t\t\t= &vsc9959_ops,\n\t.vcap\t\t\t= vsc9959_vcap_props,\n\t.vcap_pol_base\t\t= VSC9959_VCAP_POLICER_BASE,\n\t.vcap_pol_max\t\t= VSC9959_VCAP_POLICER_MAX,\n\t.vcap_pol_base2\t\t= 0,\n\t.vcap_pol_max2\t\t= 0,\n\t.num_mact_rows\t\t= 2048,\n\t.num_ports\t\t= VSC9959_NUM_PORTS,\n\t.num_tx_queues\t\t= OCELOT_NUM_TC,\n\t.quirks\t\t\t= FELIX_MAC_QUIRKS,\n\t.quirk_no_xtr_irq\t= true,\n\t.ptp_caps\t\t= &vsc9959_ptp_caps,\n\t.mdio_bus_alloc\t\t= vsc9959_mdio_bus_alloc,\n\t.mdio_bus_free\t\t= vsc9959_mdio_bus_free,\n\t.port_modes\t\t= vsc9959_port_modes,\n\t.port_setup_tc\t\t= vsc9959_port_setup_tc,\n\t.port_sched_speed_set\t= vsc9959_sched_speed_set,\n};\n\n \nstatic irqreturn_t felix_irq_handler(int irq, void *data)\n{\n\tstruct ocelot *ocelot = (struct ocelot *)data;\n\n\tocelot_get_txtstamp(ocelot);\n\tocelot_mm_irq(ocelot);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int felix_pci_probe(struct pci_dev *pdev,\n\t\t\t   const struct pci_device_id *id)\n{\n\tstruct dsa_switch *ds;\n\tstruct ocelot *ocelot;\n\tstruct felix *felix;\n\tint err;\n\n\tif (pdev->dev.of_node && !of_device_is_available(pdev->dev.of_node)) {\n\t\tdev_info(&pdev->dev, \"device is disabled, skipping\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"device enable failed\\n\");\n\t\tgoto err_pci_enable;\n\t}\n\n\tfelix = kzalloc(sizeof(struct felix), GFP_KERNEL);\n\tif (!felix) {\n\t\terr = -ENOMEM;\n\t\tdev_err(&pdev->dev, \"Failed to allocate driver memory\\n\");\n\t\tgoto err_alloc_felix;\n\t}\n\n\tpci_set_drvdata(pdev, felix);\n\tocelot = &felix->ocelot;\n\tocelot->dev = &pdev->dev;\n\tocelot->num_flooding_pgids = OCELOT_NUM_TC;\n\tfelix->info = &felix_info_vsc9959;\n\tfelix->switch_base = pci_resource_start(pdev, VSC9959_SWITCH_PCI_BAR);\n\n\tpci_set_master(pdev);\n\n\terr = devm_request_threaded_irq(&pdev->dev, pdev->irq, NULL,\n\t\t\t\t\t&felix_irq_handler, IRQF_ONESHOT,\n\t\t\t\t\t\"felix-intb\", ocelot);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to request irq\\n\");\n\t\tgoto err_alloc_irq;\n\t}\n\n\tocelot->ptp = 1;\n\tocelot->mm_supported = true;\n\n\tds = kzalloc(sizeof(struct dsa_switch), GFP_KERNEL);\n\tif (!ds) {\n\t\terr = -ENOMEM;\n\t\tdev_err(&pdev->dev, \"Failed to allocate DSA switch\\n\");\n\t\tgoto err_alloc_ds;\n\t}\n\n\tds->dev = &pdev->dev;\n\tds->num_ports = felix->info->num_ports;\n\tds->num_tx_queues = felix->info->num_tx_queues;\n\tds->ops = &felix_switch_ops;\n\tds->priv = ocelot;\n\tfelix->ds = ds;\n\tfelix->tag_proto = DSA_TAG_PROTO_OCELOT;\n\n\terr = dsa_register_switch(ds);\n\tif (err) {\n\t\tdev_err_probe(&pdev->dev, err, \"Failed to register DSA switch\\n\");\n\t\tgoto err_register_ds;\n\t}\n\n\treturn 0;\n\nerr_register_ds:\n\tkfree(ds);\nerr_alloc_ds:\nerr_alloc_irq:\n\tkfree(felix);\nerr_alloc_felix:\n\tpci_disable_device(pdev);\nerr_pci_enable:\n\treturn err;\n}\n\nstatic void felix_pci_remove(struct pci_dev *pdev)\n{\n\tstruct felix *felix = pci_get_drvdata(pdev);\n\n\tif (!felix)\n\t\treturn;\n\n\tdsa_unregister_switch(felix->ds);\n\n\tkfree(felix->ds);\n\tkfree(felix);\n\n\tpci_disable_device(pdev);\n}\n\nstatic void felix_pci_shutdown(struct pci_dev *pdev)\n{\n\tstruct felix *felix = pci_get_drvdata(pdev);\n\n\tif (!felix)\n\t\treturn;\n\n\tdsa_switch_shutdown(felix->ds);\n\n\tpci_set_drvdata(pdev, NULL);\n}\n\nstatic struct pci_device_id felix_ids[] = {\n\t{\n\t\t \n\t\tPCI_DEVICE(PCI_VENDOR_ID_FREESCALE, 0xEEF0),\n\t},\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, felix_ids);\n\nstatic struct pci_driver felix_vsc9959_pci_driver = {\n\t.name\t\t= \"mscc_felix\",\n\t.id_table\t= felix_ids,\n\t.probe\t\t= felix_pci_probe,\n\t.remove\t\t= felix_pci_remove,\n\t.shutdown\t= felix_pci_shutdown,\n};\nmodule_pci_driver(felix_vsc9959_pci_driver);\n\nMODULE_DESCRIPTION(\"Felix Switch driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}