{
  "module_name": "felix.c",
  "hash_id": "4edecc37f1761bbaffb8b7f725501cf97f9c2103ed30e53fd1b3bec383554476",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/ocelot/felix.c",
  "human_readable_source": "\n \n#include <uapi/linux/if_bridge.h>\n#include <soc/mscc/ocelot_vcap.h>\n#include <soc/mscc/ocelot_qsys.h>\n#include <soc/mscc/ocelot_sys.h>\n#include <soc/mscc/ocelot_dev.h>\n#include <soc/mscc/ocelot_ana.h>\n#include <soc/mscc/ocelot_ptp.h>\n#include <soc/mscc/ocelot.h>\n#include <linux/dsa/8021q.h>\n#include <linux/dsa/ocelot.h>\n#include <linux/platform_device.h>\n#include <linux/ptp_classify.h>\n#include <linux/module.h>\n#include <linux/of_net.h>\n#include <linux/pci.h>\n#include <linux/of.h>\n#include <net/pkt_sched.h>\n#include <net/dsa.h>\n#include \"felix.h\"\n\n \nstatic struct net_device *felix_classify_db(struct dsa_db db)\n{\n\tswitch (db.type) {\n\tcase DSA_DB_PORT:\n\tcase DSA_DB_LAG:\n\t\treturn NULL;\n\tcase DSA_DB_BRIDGE:\n\t\treturn db.bridge.dev;\n\tdefault:\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n}\n\nstatic int felix_cpu_port_for_master(struct dsa_switch *ds,\n\t\t\t\t     struct net_device *master)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tstruct dsa_port *cpu_dp;\n\tint lag;\n\n\tif (netif_is_lag_master(master)) {\n\t\tmutex_lock(&ocelot->fwd_domain_lock);\n\t\tlag = ocelot_bond_get_id(ocelot, master);\n\t\tmutex_unlock(&ocelot->fwd_domain_lock);\n\n\t\treturn lag;\n\t}\n\n\tcpu_dp = master->dsa_ptr;\n\treturn cpu_dp->index;\n}\n\n \nstatic int felix_tag_8021q_vlan_add_rx(struct dsa_switch *ds, int port,\n\t\t\t\t       int upstream, u16 vid)\n{\n\tstruct ocelot_vcap_filter *outer_tagging_rule;\n\tstruct ocelot *ocelot = ds->priv;\n\tunsigned long cookie;\n\tint key_length, err;\n\n\tkey_length = ocelot->vcap[VCAP_ES0].keys[VCAP_ES0_IGR_PORT].length;\n\n\touter_tagging_rule = kzalloc(sizeof(struct ocelot_vcap_filter),\n\t\t\t\t     GFP_KERNEL);\n\tif (!outer_tagging_rule)\n\t\treturn -ENOMEM;\n\n\tcookie = OCELOT_VCAP_ES0_TAG_8021Q_RXVLAN(ocelot, port, upstream);\n\n\touter_tagging_rule->key_type = OCELOT_VCAP_KEY_ANY;\n\touter_tagging_rule->prio = 1;\n\touter_tagging_rule->id.cookie = cookie;\n\touter_tagging_rule->id.tc_offload = false;\n\touter_tagging_rule->block_id = VCAP_ES0;\n\touter_tagging_rule->type = OCELOT_VCAP_FILTER_OFFLOAD;\n\touter_tagging_rule->lookup = 0;\n\touter_tagging_rule->ingress_port.value = port;\n\touter_tagging_rule->ingress_port.mask = GENMASK(key_length - 1, 0);\n\touter_tagging_rule->egress_port.value = upstream;\n\touter_tagging_rule->egress_port.mask = GENMASK(key_length - 1, 0);\n\touter_tagging_rule->action.push_outer_tag = OCELOT_ES0_TAG;\n\touter_tagging_rule->action.tag_a_tpid_sel = OCELOT_TAG_TPID_SEL_8021AD;\n\touter_tagging_rule->action.tag_a_vid_sel = 1;\n\touter_tagging_rule->action.vid_a_val = vid;\n\n\terr = ocelot_vcap_filter_add(ocelot, outer_tagging_rule, NULL);\n\tif (err)\n\t\tkfree(outer_tagging_rule);\n\n\treturn err;\n}\n\nstatic int felix_tag_8021q_vlan_del_rx(struct dsa_switch *ds, int port,\n\t\t\t\t       int upstream, u16 vid)\n{\n\tstruct ocelot_vcap_filter *outer_tagging_rule;\n\tstruct ocelot_vcap_block *block_vcap_es0;\n\tstruct ocelot *ocelot = ds->priv;\n\tunsigned long cookie;\n\n\tblock_vcap_es0 = &ocelot->block[VCAP_ES0];\n\tcookie = OCELOT_VCAP_ES0_TAG_8021Q_RXVLAN(ocelot, port, upstream);\n\n\touter_tagging_rule = ocelot_vcap_block_find_filter_by_id(block_vcap_es0,\n\t\t\t\t\t\t\t\t cookie, false);\n\tif (!outer_tagging_rule)\n\t\treturn -ENOENT;\n\n\treturn ocelot_vcap_filter_del(ocelot, outer_tagging_rule);\n}\n\n \nstatic int felix_tag_8021q_vlan_add_tx(struct dsa_switch *ds, int port,\n\t\t\t\t       u16 vid)\n{\n\tstruct ocelot_vcap_filter *untagging_rule, *redirect_rule;\n\tunsigned long cpu_ports = dsa_cpu_ports(ds);\n\tstruct ocelot *ocelot = ds->priv;\n\tunsigned long cookie;\n\tint err;\n\n\tuntagging_rule = kzalloc(sizeof(struct ocelot_vcap_filter), GFP_KERNEL);\n\tif (!untagging_rule)\n\t\treturn -ENOMEM;\n\n\tredirect_rule = kzalloc(sizeof(struct ocelot_vcap_filter), GFP_KERNEL);\n\tif (!redirect_rule) {\n\t\tkfree(untagging_rule);\n\t\treturn -ENOMEM;\n\t}\n\n\tcookie = OCELOT_VCAP_IS1_TAG_8021Q_TXVLAN(ocelot, port);\n\n\tuntagging_rule->key_type = OCELOT_VCAP_KEY_ANY;\n\tuntagging_rule->ingress_port_mask = cpu_ports;\n\tuntagging_rule->vlan.vid.value = vid;\n\tuntagging_rule->vlan.vid.mask = VLAN_VID_MASK;\n\tuntagging_rule->prio = 1;\n\tuntagging_rule->id.cookie = cookie;\n\tuntagging_rule->id.tc_offload = false;\n\tuntagging_rule->block_id = VCAP_IS1;\n\tuntagging_rule->type = OCELOT_VCAP_FILTER_OFFLOAD;\n\tuntagging_rule->lookup = 0;\n\tuntagging_rule->action.vlan_pop_cnt_ena = true;\n\tuntagging_rule->action.vlan_pop_cnt = 1;\n\tuntagging_rule->action.pag_override_mask = 0xff;\n\tuntagging_rule->action.pag_val = port;\n\n\terr = ocelot_vcap_filter_add(ocelot, untagging_rule, NULL);\n\tif (err) {\n\t\tkfree(untagging_rule);\n\t\tkfree(redirect_rule);\n\t\treturn err;\n\t}\n\n\tcookie = OCELOT_VCAP_IS2_TAG_8021Q_TXVLAN(ocelot, port);\n\n\tredirect_rule->key_type = OCELOT_VCAP_KEY_ANY;\n\tredirect_rule->ingress_port_mask = cpu_ports;\n\tredirect_rule->pag = port;\n\tredirect_rule->prio = 1;\n\tredirect_rule->id.cookie = cookie;\n\tredirect_rule->id.tc_offload = false;\n\tredirect_rule->block_id = VCAP_IS2;\n\tredirect_rule->type = OCELOT_VCAP_FILTER_OFFLOAD;\n\tredirect_rule->lookup = 0;\n\tredirect_rule->action.mask_mode = OCELOT_MASK_MODE_REDIRECT;\n\tredirect_rule->action.port_mask = BIT(port);\n\n\terr = ocelot_vcap_filter_add(ocelot, redirect_rule, NULL);\n\tif (err) {\n\t\tocelot_vcap_filter_del(ocelot, untagging_rule);\n\t\tkfree(redirect_rule);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int felix_tag_8021q_vlan_del_tx(struct dsa_switch *ds, int port, u16 vid)\n{\n\tstruct ocelot_vcap_filter *untagging_rule, *redirect_rule;\n\tstruct ocelot_vcap_block *block_vcap_is1;\n\tstruct ocelot_vcap_block *block_vcap_is2;\n\tstruct ocelot *ocelot = ds->priv;\n\tunsigned long cookie;\n\tint err;\n\n\tblock_vcap_is1 = &ocelot->block[VCAP_IS1];\n\tblock_vcap_is2 = &ocelot->block[VCAP_IS2];\n\n\tcookie = OCELOT_VCAP_IS1_TAG_8021Q_TXVLAN(ocelot, port);\n\tuntagging_rule = ocelot_vcap_block_find_filter_by_id(block_vcap_is1,\n\t\t\t\t\t\t\t     cookie, false);\n\tif (!untagging_rule)\n\t\treturn -ENOENT;\n\n\terr = ocelot_vcap_filter_del(ocelot, untagging_rule);\n\tif (err)\n\t\treturn err;\n\n\tcookie = OCELOT_VCAP_IS2_TAG_8021Q_TXVLAN(ocelot, port);\n\tredirect_rule = ocelot_vcap_block_find_filter_by_id(block_vcap_is2,\n\t\t\t\t\t\t\t    cookie, false);\n\tif (!redirect_rule)\n\t\treturn -ENOENT;\n\n\treturn ocelot_vcap_filter_del(ocelot, redirect_rule);\n}\n\nstatic int felix_tag_8021q_vlan_add(struct dsa_switch *ds, int port, u16 vid,\n\t\t\t\t    u16 flags)\n{\n\tstruct dsa_port *cpu_dp;\n\tint err;\n\n\t \n\tif (!dsa_is_user_port(ds, port))\n\t\treturn 0;\n\n\tdsa_switch_for_each_cpu_port(cpu_dp, ds) {\n\t\terr = felix_tag_8021q_vlan_add_rx(ds, port, cpu_dp->index, vid);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = felix_tag_8021q_vlan_add_tx(ds, port, vid);\n\tif (err)\n\t\tgoto add_tx_failed;\n\n\treturn 0;\n\nadd_tx_failed:\n\tdsa_switch_for_each_cpu_port(cpu_dp, ds)\n\t\tfelix_tag_8021q_vlan_del_rx(ds, port, cpu_dp->index, vid);\n\n\treturn err;\n}\n\nstatic int felix_tag_8021q_vlan_del(struct dsa_switch *ds, int port, u16 vid)\n{\n\tstruct dsa_port *cpu_dp;\n\tint err;\n\n\tif (!dsa_is_user_port(ds, port))\n\t\treturn 0;\n\n\tdsa_switch_for_each_cpu_port(cpu_dp, ds) {\n\t\terr = felix_tag_8021q_vlan_del_rx(ds, port, cpu_dp->index, vid);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = felix_tag_8021q_vlan_del_tx(ds, port, vid);\n\tif (err)\n\t\tgoto del_tx_failed;\n\n\treturn 0;\n\ndel_tx_failed:\n\tdsa_switch_for_each_cpu_port(cpu_dp, ds)\n\t\tfelix_tag_8021q_vlan_add_rx(ds, port, cpu_dp->index, vid);\n\n\treturn err;\n}\n\nstatic int felix_trap_get_cpu_port(struct dsa_switch *ds,\n\t\t\t\t   const struct ocelot_vcap_filter *trap)\n{\n\tstruct dsa_port *dp;\n\tint first_port;\n\n\tif (WARN_ON(!trap->ingress_port_mask))\n\t\treturn -1;\n\n\tfirst_port = __ffs(trap->ingress_port_mask);\n\tdp = dsa_to_port(ds, first_port);\n\n\treturn dp->cpu_dp->index;\n}\n\n \nstatic int felix_update_trapping_destinations(struct dsa_switch *ds,\n\t\t\t\t\t      bool using_tag_8021q)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tstruct felix *felix = ocelot_to_felix(ocelot);\n\tstruct ocelot_vcap_block *block_vcap_is2;\n\tstruct ocelot_vcap_filter *trap;\n\tenum ocelot_mask_mode mask_mode;\n\tunsigned long port_mask;\n\tbool cpu_copy_ena;\n\tint err;\n\n\tif (!felix->info->quirk_no_xtr_irq)\n\t\treturn 0;\n\n\t \n\tblock_vcap_is2 = &ocelot->block[VCAP_IS2];\n\n\t \n\tlist_for_each_entry(trap, &block_vcap_is2->rules, list) {\n\t\tif (!trap->is_trap)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (using_tag_8021q) {\n\t\t\t \n\t\t\tmask_mode = OCELOT_MASK_MODE_REDIRECT;\n\t\t\tport_mask = BIT(felix_trap_get_cpu_port(ds, trap));\n\t\t\tcpu_copy_ena = !!trap->take_ts;\n\t\t} else {\n\t\t\t \n\t\t\tmask_mode = OCELOT_MASK_MODE_PERMIT_DENY;\n\t\t\tport_mask = 0;\n\t\t\tcpu_copy_ena = true;\n\t\t}\n\n\t\tif (trap->action.mask_mode == mask_mode &&\n\t\t    trap->action.port_mask == port_mask &&\n\t\t    trap->action.cpu_copy_ena == cpu_copy_ena)\n\t\t\tcontinue;\n\n\t\ttrap->action.mask_mode = mask_mode;\n\t\ttrap->action.port_mask = port_mask;\n\t\ttrap->action.cpu_copy_ena = cpu_copy_ena;\n\n\t\terr = ocelot_vcap_filter_replace(ocelot, trap);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void felix_npi_port_init(struct ocelot *ocelot, int port)\n{\n\tocelot->npi = port;\n\n\tocelot_write(ocelot, QSYS_EXT_CPU_CFG_EXT_CPUQ_MSK_M |\n\t\t     QSYS_EXT_CPU_CFG_EXT_CPU_PORT(port),\n\t\t     QSYS_EXT_CPU_CFG);\n\n\t \n\tocelot_fields_write(ocelot, port, SYS_PORT_MODE_INCL_XTR_HDR,\n\t\t\t    ocelot->npi_xtr_prefix);\n\tocelot_fields_write(ocelot, port, SYS_PORT_MODE_INCL_INJ_HDR,\n\t\t\t    ocelot->npi_inj_prefix);\n\n\t \n\tocelot_fields_write(ocelot, port, SYS_PAUSE_CFG_PAUSE_ENA, 0);\n}\n\nstatic void felix_npi_port_deinit(struct ocelot *ocelot, int port)\n{\n\t \n\tint unused_port = ocelot->num_phys_ports + 2;\n\n\tocelot->npi = -1;\n\n\tocelot_write(ocelot, QSYS_EXT_CPU_CFG_EXT_CPU_PORT(unused_port),\n\t\t     QSYS_EXT_CPU_CFG);\n\n\tocelot_fields_write(ocelot, port, SYS_PORT_MODE_INCL_XTR_HDR,\n\t\t\t    OCELOT_TAG_PREFIX_DISABLED);\n\tocelot_fields_write(ocelot, port, SYS_PORT_MODE_INCL_INJ_HDR,\n\t\t\t    OCELOT_TAG_PREFIX_DISABLED);\n\n\t \n\tocelot_fields_write(ocelot, port, SYS_PAUSE_CFG_PAUSE_ENA, 1);\n}\n\nstatic int felix_tag_npi_setup(struct dsa_switch *ds)\n{\n\tstruct dsa_port *dp, *first_cpu_dp = NULL;\n\tstruct ocelot *ocelot = ds->priv;\n\n\tdsa_switch_for_each_user_port(dp, ds) {\n\t\tif (first_cpu_dp && dp->cpu_dp != first_cpu_dp) {\n\t\t\tdev_err(ds->dev, \"Multiple NPI ports not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfirst_cpu_dp = dp->cpu_dp;\n\t}\n\n\tif (!first_cpu_dp)\n\t\treturn -EINVAL;\n\n\tfelix_npi_port_init(ocelot, first_cpu_dp->index);\n\n\treturn 0;\n}\n\nstatic void felix_tag_npi_teardown(struct dsa_switch *ds)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\tfelix_npi_port_deinit(ocelot, ocelot->npi);\n}\n\nstatic unsigned long felix_tag_npi_get_host_fwd_mask(struct dsa_switch *ds)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn BIT(ocelot->num_phys_ports);\n}\n\nstatic int felix_tag_npi_change_master(struct dsa_switch *ds, int port,\n\t\t\t\t       struct net_device *master,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct dsa_port *dp = dsa_to_port(ds, port), *other_dp;\n\tstruct ocelot *ocelot = ds->priv;\n\n\tif (netif_is_lag_master(master)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"LAG DSA master only supported using ocelot-8021q\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tdsa_switch_for_each_user_port(other_dp, ds) {\n\t\tstruct net_device *slave = other_dp->slave;\n\n\t\tif (other_dp != dp && (slave->flags & IFF_UP) &&\n\t\t    dsa_port_to_master(other_dp) != master) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Cannot change while old master still has users\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tfelix_npi_port_deinit(ocelot, ocelot->npi);\n\tfelix_npi_port_init(ocelot, felix_cpu_port_for_master(ds, master));\n\n\treturn 0;\n}\n\n \nstatic const struct felix_tag_proto_ops felix_tag_npi_proto_ops = {\n\t.setup\t\t\t= felix_tag_npi_setup,\n\t.teardown\t\t= felix_tag_npi_teardown,\n\t.get_host_fwd_mask\t= felix_tag_npi_get_host_fwd_mask,\n\t.change_master\t\t= felix_tag_npi_change_master,\n};\n\nstatic int felix_tag_8021q_setup(struct dsa_switch *ds)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tstruct dsa_port *dp;\n\tint err;\n\n\terr = dsa_tag_8021q_register(ds, htons(ETH_P_8021AD));\n\tif (err)\n\t\treturn err;\n\n\tdsa_switch_for_each_cpu_port(dp, ds)\n\t\tocelot_port_setup_dsa_8021q_cpu(ocelot, dp->index);\n\n\tdsa_switch_for_each_user_port(dp, ds)\n\t\tocelot_port_assign_dsa_8021q_cpu(ocelot, dp->index,\n\t\t\t\t\t\t dp->cpu_dp->index);\n\n\tdsa_switch_for_each_available_port(dp, ds)\n\t\t \n\t\tocelot_write_gix(ocelot,\n\t\t\t\t ANA_PORT_CPU_FWD_BPDU_CFG_BPDU_REDIR_ENA(0),\n\t\t\t\t ANA_PORT_CPU_FWD_BPDU_CFG, dp->index);\n\n\t \n\tocelot_drain_cpu_queue(ocelot, 0);\n\n\treturn 0;\n}\n\nstatic void felix_tag_8021q_teardown(struct dsa_switch *ds)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tstruct dsa_port *dp;\n\n\tdsa_switch_for_each_available_port(dp, ds)\n\t\t \n\t\tocelot_write_gix(ocelot,\n\t\t\t\t ANA_PORT_CPU_FWD_BPDU_CFG_BPDU_REDIR_ENA(0xffff),\n\t\t\t\t ANA_PORT_CPU_FWD_BPDU_CFG,\n\t\t\t\t dp->index);\n\n\tdsa_switch_for_each_user_port(dp, ds)\n\t\tocelot_port_unassign_dsa_8021q_cpu(ocelot, dp->index);\n\n\tdsa_switch_for_each_cpu_port(dp, ds)\n\t\tocelot_port_teardown_dsa_8021q_cpu(ocelot, dp->index);\n\n\tdsa_tag_8021q_unregister(ds);\n}\n\nstatic unsigned long felix_tag_8021q_get_host_fwd_mask(struct dsa_switch *ds)\n{\n\treturn dsa_cpu_ports(ds);\n}\n\nstatic int felix_tag_8021q_change_master(struct dsa_switch *ds, int port,\n\t\t\t\t\t struct net_device *master,\n\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tint cpu = felix_cpu_port_for_master(ds, master);\n\tstruct ocelot *ocelot = ds->priv;\n\n\tocelot_port_unassign_dsa_8021q_cpu(ocelot, port);\n\tocelot_port_assign_dsa_8021q_cpu(ocelot, port, cpu);\n\n\treturn felix_update_trapping_destinations(ds, true);\n}\n\nstatic const struct felix_tag_proto_ops felix_tag_8021q_proto_ops = {\n\t.setup\t\t\t= felix_tag_8021q_setup,\n\t.teardown\t\t= felix_tag_8021q_teardown,\n\t.get_host_fwd_mask\t= felix_tag_8021q_get_host_fwd_mask,\n\t.change_master\t\t= felix_tag_8021q_change_master,\n};\n\nstatic void felix_set_host_flood(struct dsa_switch *ds, unsigned long mask,\n\t\t\t\t bool uc, bool mc, bool bc)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tunsigned long val;\n\n\tval = uc ? mask : 0;\n\tocelot_rmw_rix(ocelot, val, mask, ANA_PGID_PGID, PGID_UC);\n\n\tval = mc ? mask : 0;\n\tocelot_rmw_rix(ocelot, val, mask, ANA_PGID_PGID, PGID_MC);\n\tocelot_rmw_rix(ocelot, val, mask, ANA_PGID_PGID, PGID_MCIPV4);\n\tocelot_rmw_rix(ocelot, val, mask, ANA_PGID_PGID, PGID_MCIPV6);\n\n\tval = bc ? mask : 0;\n\tocelot_rmw_rix(ocelot, val, mask, ANA_PGID_PGID, PGID_BC);\n}\n\nstatic void\nfelix_migrate_host_flood(struct dsa_switch *ds,\n\t\t\t const struct felix_tag_proto_ops *proto_ops,\n\t\t\t const struct felix_tag_proto_ops *old_proto_ops)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tstruct felix *felix = ocelot_to_felix(ocelot);\n\tunsigned long mask;\n\n\tif (old_proto_ops) {\n\t\tmask = old_proto_ops->get_host_fwd_mask(ds);\n\t\tfelix_set_host_flood(ds, mask, false, false, false);\n\t}\n\n\tmask = proto_ops->get_host_fwd_mask(ds);\n\tfelix_set_host_flood(ds, mask, !!felix->host_flood_uc_mask,\n\t\t\t     !!felix->host_flood_mc_mask, true);\n}\n\nstatic int felix_migrate_mdbs(struct dsa_switch *ds,\n\t\t\t      const struct felix_tag_proto_ops *proto_ops,\n\t\t\t      const struct felix_tag_proto_ops *old_proto_ops)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tunsigned long from, to;\n\n\tif (!old_proto_ops)\n\t\treturn 0;\n\n\tfrom = old_proto_ops->get_host_fwd_mask(ds);\n\tto = proto_ops->get_host_fwd_mask(ds);\n\n\treturn ocelot_migrate_mdbs(ocelot, from, to);\n}\n\n \nstatic int\nfelix_tag_proto_setup_shared(struct dsa_switch *ds,\n\t\t\t     const struct felix_tag_proto_ops *proto_ops,\n\t\t\t     const struct felix_tag_proto_ops *old_proto_ops)\n{\n\tbool using_tag_8021q = (proto_ops == &felix_tag_8021q_proto_ops);\n\tint err;\n\n\terr = felix_migrate_mdbs(ds, proto_ops, old_proto_ops);\n\tif (err)\n\t\treturn err;\n\n\tfelix_update_trapping_destinations(ds, using_tag_8021q);\n\n\tfelix_migrate_host_flood(ds, proto_ops, old_proto_ops);\n\n\treturn 0;\n}\n\n \nstatic int felix_change_tag_protocol(struct dsa_switch *ds,\n\t\t\t\t     enum dsa_tag_protocol proto)\n{\n\tconst struct felix_tag_proto_ops *old_proto_ops, *proto_ops;\n\tstruct ocelot *ocelot = ds->priv;\n\tstruct felix *felix = ocelot_to_felix(ocelot);\n\tint err;\n\n\tswitch (proto) {\n\tcase DSA_TAG_PROTO_SEVILLE:\n\tcase DSA_TAG_PROTO_OCELOT:\n\t\tproto_ops = &felix_tag_npi_proto_ops;\n\t\tbreak;\n\tcase DSA_TAG_PROTO_OCELOT_8021Q:\n\t\tproto_ops = &felix_tag_8021q_proto_ops;\n\t\tbreak;\n\tdefault:\n\t\treturn -EPROTONOSUPPORT;\n\t}\n\n\told_proto_ops = felix->tag_proto_ops;\n\n\tif (proto_ops == old_proto_ops)\n\t\treturn 0;\n\n\terr = proto_ops->setup(ds);\n\tif (err)\n\t\tgoto setup_failed;\n\n\terr = felix_tag_proto_setup_shared(ds, proto_ops, old_proto_ops);\n\tif (err)\n\t\tgoto setup_shared_failed;\n\n\tif (old_proto_ops)\n\t\told_proto_ops->teardown(ds);\n\n\tfelix->tag_proto_ops = proto_ops;\n\tfelix->tag_proto = proto;\n\n\treturn 0;\n\nsetup_shared_failed:\n\tproto_ops->teardown(ds);\nsetup_failed:\n\treturn err;\n}\n\nstatic enum dsa_tag_protocol felix_get_tag_protocol(struct dsa_switch *ds,\n\t\t\t\t\t\t    int port,\n\t\t\t\t\t\t    enum dsa_tag_protocol mp)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tstruct felix *felix = ocelot_to_felix(ocelot);\n\n\treturn felix->tag_proto;\n}\n\nstatic void felix_port_set_host_flood(struct dsa_switch *ds, int port,\n\t\t\t\t      bool uc, bool mc)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tstruct felix *felix = ocelot_to_felix(ocelot);\n\tunsigned long mask;\n\n\tif (uc)\n\t\tfelix->host_flood_uc_mask |= BIT(port);\n\telse\n\t\tfelix->host_flood_uc_mask &= ~BIT(port);\n\n\tif (mc)\n\t\tfelix->host_flood_mc_mask |= BIT(port);\n\telse\n\t\tfelix->host_flood_mc_mask &= ~BIT(port);\n\n\tmask = felix->tag_proto_ops->get_host_fwd_mask(ds);\n\tfelix_set_host_flood(ds, mask, !!felix->host_flood_uc_mask,\n\t\t\t     !!felix->host_flood_mc_mask, true);\n}\n\nstatic int felix_port_change_master(struct dsa_switch *ds, int port,\n\t\t\t\t    struct net_device *master,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tstruct felix *felix = ocelot_to_felix(ocelot);\n\n\treturn felix->tag_proto_ops->change_master(ds, port, master, extack);\n}\n\nstatic int felix_set_ageing_time(struct dsa_switch *ds,\n\t\t\t\t unsigned int ageing_time)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\tocelot_set_ageing_time(ocelot, ageing_time);\n\n\treturn 0;\n}\n\nstatic void felix_port_fast_age(struct dsa_switch *ds, int port)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tint err;\n\n\terr = ocelot_mact_flush(ocelot, port);\n\tif (err)\n\t\tdev_err(ds->dev, \"Flushing MAC table on port %d returned %pe\\n\",\n\t\t\tport, ERR_PTR(err));\n}\n\nstatic int felix_fdb_dump(struct dsa_switch *ds, int port,\n\t\t\t  dsa_fdb_dump_cb_t *cb, void *data)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_fdb_dump(ocelot, port, cb, data);\n}\n\nstatic int felix_fdb_add(struct dsa_switch *ds, int port,\n\t\t\t const unsigned char *addr, u16 vid,\n\t\t\t struct dsa_db db)\n{\n\tstruct net_device *bridge_dev = felix_classify_db(db);\n\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\tstruct ocelot *ocelot = ds->priv;\n\n\tif (IS_ERR(bridge_dev))\n\t\treturn PTR_ERR(bridge_dev);\n\n\tif (dsa_port_is_cpu(dp) && !bridge_dev &&\n\t    dsa_fdb_present_in_other_db(ds, port, addr, vid, db))\n\t\treturn 0;\n\n\tif (dsa_port_is_cpu(dp))\n\t\tport = PGID_CPU;\n\n\treturn ocelot_fdb_add(ocelot, port, addr, vid, bridge_dev);\n}\n\nstatic int felix_fdb_del(struct dsa_switch *ds, int port,\n\t\t\t const unsigned char *addr, u16 vid,\n\t\t\t struct dsa_db db)\n{\n\tstruct net_device *bridge_dev = felix_classify_db(db);\n\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\tstruct ocelot *ocelot = ds->priv;\n\n\tif (IS_ERR(bridge_dev))\n\t\treturn PTR_ERR(bridge_dev);\n\n\tif (dsa_port_is_cpu(dp) && !bridge_dev &&\n\t    dsa_fdb_present_in_other_db(ds, port, addr, vid, db))\n\t\treturn 0;\n\n\tif (dsa_port_is_cpu(dp))\n\t\tport = PGID_CPU;\n\n\treturn ocelot_fdb_del(ocelot, port, addr, vid, bridge_dev);\n}\n\nstatic int felix_lag_fdb_add(struct dsa_switch *ds, struct dsa_lag lag,\n\t\t\t     const unsigned char *addr, u16 vid,\n\t\t\t     struct dsa_db db)\n{\n\tstruct net_device *bridge_dev = felix_classify_db(db);\n\tstruct ocelot *ocelot = ds->priv;\n\n\tif (IS_ERR(bridge_dev))\n\t\treturn PTR_ERR(bridge_dev);\n\n\treturn ocelot_lag_fdb_add(ocelot, lag.dev, addr, vid, bridge_dev);\n}\n\nstatic int felix_lag_fdb_del(struct dsa_switch *ds, struct dsa_lag lag,\n\t\t\t     const unsigned char *addr, u16 vid,\n\t\t\t     struct dsa_db db)\n{\n\tstruct net_device *bridge_dev = felix_classify_db(db);\n\tstruct ocelot *ocelot = ds->priv;\n\n\tif (IS_ERR(bridge_dev))\n\t\treturn PTR_ERR(bridge_dev);\n\n\treturn ocelot_lag_fdb_del(ocelot, lag.dev, addr, vid, bridge_dev);\n}\n\nstatic int felix_mdb_add(struct dsa_switch *ds, int port,\n\t\t\t const struct switchdev_obj_port_mdb *mdb,\n\t\t\t struct dsa_db db)\n{\n\tstruct net_device *bridge_dev = felix_classify_db(db);\n\tstruct ocelot *ocelot = ds->priv;\n\n\tif (IS_ERR(bridge_dev))\n\t\treturn PTR_ERR(bridge_dev);\n\n\tif (dsa_is_cpu_port(ds, port) && !bridge_dev &&\n\t    dsa_mdb_present_in_other_db(ds, port, mdb, db))\n\t\treturn 0;\n\n\tif (port == ocelot->npi)\n\t\tport = ocelot->num_phys_ports;\n\n\treturn ocelot_port_mdb_add(ocelot, port, mdb, bridge_dev);\n}\n\nstatic int felix_mdb_del(struct dsa_switch *ds, int port,\n\t\t\t const struct switchdev_obj_port_mdb *mdb,\n\t\t\t struct dsa_db db)\n{\n\tstruct net_device *bridge_dev = felix_classify_db(db);\n\tstruct ocelot *ocelot = ds->priv;\n\n\tif (IS_ERR(bridge_dev))\n\t\treturn PTR_ERR(bridge_dev);\n\n\tif (dsa_is_cpu_port(ds, port) && !bridge_dev &&\n\t    dsa_mdb_present_in_other_db(ds, port, mdb, db))\n\t\treturn 0;\n\n\tif (port == ocelot->npi)\n\t\tport = ocelot->num_phys_ports;\n\n\treturn ocelot_port_mdb_del(ocelot, port, mdb, bridge_dev);\n}\n\nstatic void felix_bridge_stp_state_set(struct dsa_switch *ds, int port,\n\t\t\t\t       u8 state)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_bridge_stp_state_set(ocelot, port, state);\n}\n\nstatic int felix_pre_bridge_flags(struct dsa_switch *ds, int port,\n\t\t\t\t  struct switchdev_brport_flags val,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_port_pre_bridge_flags(ocelot, port, val);\n}\n\nstatic int felix_bridge_flags(struct dsa_switch *ds, int port,\n\t\t\t      struct switchdev_brport_flags val,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\tif (port == ocelot->npi)\n\t\tport = ocelot->num_phys_ports;\n\n\tocelot_port_bridge_flags(ocelot, port, val);\n\n\treturn 0;\n}\n\nstatic int felix_bridge_join(struct dsa_switch *ds, int port,\n\t\t\t     struct dsa_bridge bridge, bool *tx_fwd_offload,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_port_bridge_join(ocelot, port, bridge.dev, bridge.num,\n\t\t\t\t       extack);\n}\n\nstatic void felix_bridge_leave(struct dsa_switch *ds, int port,\n\t\t\t       struct dsa_bridge bridge)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\tocelot_port_bridge_leave(ocelot, port, bridge.dev);\n}\n\nstatic int felix_lag_join(struct dsa_switch *ds, int port,\n\t\t\t  struct dsa_lag lag,\n\t\t\t  struct netdev_lag_upper_info *info,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tint err;\n\n\terr = ocelot_port_lag_join(ocelot, port, lag.dev, info, extack);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!dsa_is_cpu_port(ds, port))\n\t\treturn 0;\n\n\treturn felix_port_change_master(ds, port, lag.dev, extack);\n}\n\nstatic int felix_lag_leave(struct dsa_switch *ds, int port,\n\t\t\t   struct dsa_lag lag)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\tocelot_port_lag_leave(ocelot, port, lag.dev);\n\n\t \n\tif (!dsa_is_cpu_port(ds, port))\n\t\treturn 0;\n\n\treturn felix_port_change_master(ds, port, lag.dev, NULL);\n}\n\nstatic int felix_lag_change(struct dsa_switch *ds, int port)\n{\n\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\tstruct ocelot *ocelot = ds->priv;\n\n\tocelot_port_lag_change(ocelot, port, dp->lag_tx_enabled);\n\n\treturn 0;\n}\n\nstatic int felix_vlan_prepare(struct dsa_switch *ds, int port,\n\t\t\t      const struct switchdev_obj_port_vlan *vlan,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tu16 flags = vlan->flags;\n\n\t \n\tif (port == ocelot->npi)\n\t\treturn 0;\n\n\treturn ocelot_vlan_prepare(ocelot, port, vlan->vid,\n\t\t\t\t   flags & BRIDGE_VLAN_INFO_PVID,\n\t\t\t\t   flags & BRIDGE_VLAN_INFO_UNTAGGED,\n\t\t\t\t   extack);\n}\n\nstatic int felix_vlan_filtering(struct dsa_switch *ds, int port, bool enabled,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_port_vlan_filtering(ocelot, port, enabled, extack);\n}\n\nstatic int felix_vlan_add(struct dsa_switch *ds, int port,\n\t\t\t  const struct switchdev_obj_port_vlan *vlan,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tu16 flags = vlan->flags;\n\tint err;\n\n\terr = felix_vlan_prepare(ds, port, vlan, extack);\n\tif (err)\n\t\treturn err;\n\n\treturn ocelot_vlan_add(ocelot, port, vlan->vid,\n\t\t\t       flags & BRIDGE_VLAN_INFO_PVID,\n\t\t\t       flags & BRIDGE_VLAN_INFO_UNTAGGED);\n}\n\nstatic int felix_vlan_del(struct dsa_switch *ds, int port,\n\t\t\t  const struct switchdev_obj_port_vlan *vlan)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_vlan_del(ocelot, port, vlan->vid);\n}\n\nstatic void felix_phylink_get_caps(struct dsa_switch *ds, int port,\n\t\t\t\t   struct phylink_config *config)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\tconfig->mac_capabilities = MAC_ASYM_PAUSE | MAC_SYM_PAUSE |\n\t\t\t\t   MAC_10 | MAC_100 | MAC_1000FD |\n\t\t\t\t   MAC_2500FD;\n\n\t__set_bit(ocelot->ports[port]->phy_mode,\n\t\t  config->supported_interfaces);\n}\n\nstatic void felix_phylink_mac_config(struct dsa_switch *ds, int port,\n\t\t\t\t     unsigned int mode,\n\t\t\t\t     const struct phylink_link_state *state)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tstruct felix *felix = ocelot_to_felix(ocelot);\n\n\tif (felix->info->phylink_mac_config)\n\t\tfelix->info->phylink_mac_config(ocelot, port, mode, state);\n}\n\nstatic struct phylink_pcs *felix_phylink_mac_select_pcs(struct dsa_switch *ds,\n\t\t\t\t\t\t\tint port,\n\t\t\t\t\t\t\tphy_interface_t iface)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tstruct felix *felix = ocelot_to_felix(ocelot);\n\tstruct phylink_pcs *pcs = NULL;\n\n\tif (felix->pcs && felix->pcs[port])\n\t\tpcs = felix->pcs[port];\n\n\treturn pcs;\n}\n\nstatic void felix_phylink_mac_link_down(struct dsa_switch *ds, int port,\n\t\t\t\t\tunsigned int link_an_mode,\n\t\t\t\t\tphy_interface_t interface)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tstruct felix *felix;\n\n\tfelix = ocelot_to_felix(ocelot);\n\n\tocelot_phylink_mac_link_down(ocelot, port, link_an_mode, interface,\n\t\t\t\t     felix->info->quirks);\n}\n\nstatic void felix_phylink_mac_link_up(struct dsa_switch *ds, int port,\n\t\t\t\t      unsigned int link_an_mode,\n\t\t\t\t      phy_interface_t interface,\n\t\t\t\t      struct phy_device *phydev,\n\t\t\t\t      int speed, int duplex,\n\t\t\t\t      bool tx_pause, bool rx_pause)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tstruct felix *felix = ocelot_to_felix(ocelot);\n\n\tocelot_phylink_mac_link_up(ocelot, port, phydev, link_an_mode,\n\t\t\t\t   interface, speed, duplex, tx_pause, rx_pause,\n\t\t\t\t   felix->info->quirks);\n\n\tif (felix->info->port_sched_speed_set)\n\t\tfelix->info->port_sched_speed_set(ocelot, port, speed);\n}\n\nstatic int felix_port_enable(struct dsa_switch *ds, int port,\n\t\t\t     struct phy_device *phydev)\n{\n\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\tstruct ocelot *ocelot = ds->priv;\n\n\tif (!dsa_port_is_user(dp))\n\t\treturn 0;\n\n\tif (ocelot->npi >= 0) {\n\t\tstruct net_device *master = dsa_port_to_master(dp);\n\n\t\tif (felix_cpu_port_for_master(ds, master) != ocelot->npi) {\n\t\t\tdev_err(ds->dev, \"Multiple masters are not allowed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void felix_port_qos_map_init(struct ocelot *ocelot, int port)\n{\n\tint i;\n\n\tocelot_rmw_gix(ocelot,\n\t\t       ANA_PORT_QOS_CFG_QOS_PCP_ENA,\n\t\t       ANA_PORT_QOS_CFG_QOS_PCP_ENA,\n\t\t       ANA_PORT_QOS_CFG,\n\t\t       port);\n\n\tfor (i = 0; i < OCELOT_NUM_TC * 2; i++) {\n\t\tocelot_rmw_ix(ocelot,\n\t\t\t      (ANA_PORT_PCP_DEI_MAP_DP_PCP_DEI_VAL & i) |\n\t\t\t      ANA_PORT_PCP_DEI_MAP_QOS_PCP_DEI_VAL(i),\n\t\t\t      ANA_PORT_PCP_DEI_MAP_DP_PCP_DEI_VAL |\n\t\t\t      ANA_PORT_PCP_DEI_MAP_QOS_PCP_DEI_VAL_M,\n\t\t\t      ANA_PORT_PCP_DEI_MAP,\n\t\t\t      port, i);\n\t}\n}\n\nstatic void felix_get_stats64(struct dsa_switch *ds, int port,\n\t\t\t      struct rtnl_link_stats64 *stats)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\tocelot_port_get_stats64(ocelot, port, stats);\n}\n\nstatic void felix_get_pause_stats(struct dsa_switch *ds, int port,\n\t\t\t\t  struct ethtool_pause_stats *pause_stats)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\tocelot_port_get_pause_stats(ocelot, port, pause_stats);\n}\n\nstatic void felix_get_rmon_stats(struct dsa_switch *ds, int port,\n\t\t\t\t struct ethtool_rmon_stats *rmon_stats,\n\t\t\t\t const struct ethtool_rmon_hist_range **ranges)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\tocelot_port_get_rmon_stats(ocelot, port, rmon_stats, ranges);\n}\n\nstatic void felix_get_eth_ctrl_stats(struct dsa_switch *ds, int port,\n\t\t\t\t     struct ethtool_eth_ctrl_stats *ctrl_stats)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\tocelot_port_get_eth_ctrl_stats(ocelot, port, ctrl_stats);\n}\n\nstatic void felix_get_eth_mac_stats(struct dsa_switch *ds, int port,\n\t\t\t\t    struct ethtool_eth_mac_stats *mac_stats)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\tocelot_port_get_eth_mac_stats(ocelot, port, mac_stats);\n}\n\nstatic void felix_get_eth_phy_stats(struct dsa_switch *ds, int port,\n\t\t\t\t    struct ethtool_eth_phy_stats *phy_stats)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\tocelot_port_get_eth_phy_stats(ocelot, port, phy_stats);\n}\n\nstatic void felix_get_strings(struct dsa_switch *ds, int port,\n\t\t\t      u32 stringset, u8 *data)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_get_strings(ocelot, port, stringset, data);\n}\n\nstatic void felix_get_ethtool_stats(struct dsa_switch *ds, int port, u64 *data)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\tocelot_get_ethtool_stats(ocelot, port, data);\n}\n\nstatic int felix_get_sset_count(struct dsa_switch *ds, int port, int sset)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_get_sset_count(ocelot, port, sset);\n}\n\nstatic int felix_get_ts_info(struct dsa_switch *ds, int port,\n\t\t\t     struct ethtool_ts_info *info)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_get_ts_info(ocelot, port, info);\n}\n\nstatic const u32 felix_phy_match_table[PHY_INTERFACE_MODE_MAX] = {\n\t[PHY_INTERFACE_MODE_INTERNAL] = OCELOT_PORT_MODE_INTERNAL,\n\t[PHY_INTERFACE_MODE_SGMII] = OCELOT_PORT_MODE_SGMII,\n\t[PHY_INTERFACE_MODE_QSGMII] = OCELOT_PORT_MODE_QSGMII,\n\t[PHY_INTERFACE_MODE_USXGMII] = OCELOT_PORT_MODE_USXGMII,\n\t[PHY_INTERFACE_MODE_1000BASEX] = OCELOT_PORT_MODE_1000BASEX,\n\t[PHY_INTERFACE_MODE_2500BASEX] = OCELOT_PORT_MODE_2500BASEX,\n};\n\nstatic int felix_validate_phy_mode(struct felix *felix, int port,\n\t\t\t\t   phy_interface_t phy_mode)\n{\n\tu32 modes = felix->info->port_modes[port];\n\n\tif (felix_phy_match_table[phy_mode] & modes)\n\t\treturn 0;\n\treturn -EOPNOTSUPP;\n}\n\nstatic int felix_parse_ports_node(struct felix *felix,\n\t\t\t\t  struct device_node *ports_node,\n\t\t\t\t  phy_interface_t *port_phy_modes)\n{\n\tstruct device *dev = felix->ocelot.dev;\n\tstruct device_node *child;\n\n\tfor_each_available_child_of_node(ports_node, child) {\n\t\tphy_interface_t phy_mode;\n\t\tu32 port;\n\t\tint err;\n\n\t\t \n\t\tif (of_property_read_u32(child, \"reg\", &port) < 0) {\n\t\t\tdev_err(dev, \"Port number not defined in device tree \"\n\t\t\t\t\"(property \\\"reg\\\")\\n\");\n\t\t\tof_node_put(child);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t \n\t\terr = of_get_phy_mode(child, &phy_mode);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Failed to read phy-mode or \"\n\t\t\t\t\"phy-interface-type property for port %d\\n\",\n\t\t\t\tport);\n\t\t\tof_node_put(child);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\terr = felix_validate_phy_mode(felix, port, phy_mode);\n\t\tif (err < 0) {\n\t\t\tdev_info(dev, \"Unsupported PHY mode %s on port %d\\n\",\n\t\t\t\t phy_modes(phy_mode), port);\n\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tport_phy_modes[port] = phy_mode;\n\t}\n\n\treturn 0;\n}\n\nstatic int felix_parse_dt(struct felix *felix, phy_interface_t *port_phy_modes)\n{\n\tstruct device *dev = felix->ocelot.dev;\n\tstruct device_node *switch_node;\n\tstruct device_node *ports_node;\n\tint err;\n\n\tswitch_node = dev->of_node;\n\n\tports_node = of_get_child_by_name(switch_node, \"ports\");\n\tif (!ports_node)\n\t\tports_node = of_get_child_by_name(switch_node, \"ethernet-ports\");\n\tif (!ports_node) {\n\t\tdev_err(dev, \"Incorrect bindings: absent \\\"ports\\\" or \\\"ethernet-ports\\\" node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = felix_parse_ports_node(felix, ports_node, port_phy_modes);\n\tof_node_put(ports_node);\n\n\treturn err;\n}\n\nstatic struct regmap *felix_request_regmap_by_name(struct felix *felix,\n\t\t\t\t\t\t   const char *resource_name)\n{\n\tstruct ocelot *ocelot = &felix->ocelot;\n\tstruct resource res;\n\tint i;\n\n\t \n\tif (!felix->info->resources)\n\t\treturn dev_get_regmap(ocelot->dev->parent, resource_name);\n\n\tfor (i = 0; i < felix->info->num_resources; i++) {\n\t\tif (strcmp(resource_name, felix->info->resources[i].name))\n\t\t\tcontinue;\n\n\t\tmemcpy(&res, &felix->info->resources[i], sizeof(res));\n\t\tres.start += felix->switch_base;\n\t\tres.end += felix->switch_base;\n\n\t\treturn ocelot_regmap_init(ocelot, &res);\n\t}\n\n\treturn ERR_PTR(-ENOENT);\n}\n\nstatic struct regmap *felix_request_regmap(struct felix *felix,\n\t\t\t\t\t   enum ocelot_target target)\n{\n\tconst char *resource_name = felix->info->resource_names[target];\n\n\t \n\tif (!resource_name)\n\t\treturn NULL;\n\n\treturn felix_request_regmap_by_name(felix, resource_name);\n}\n\nstatic struct regmap *felix_request_port_regmap(struct felix *felix, int port)\n{\n\tchar resource_name[32];\n\n\tsprintf(resource_name, \"port%d\", port);\n\n\treturn felix_request_regmap_by_name(felix, resource_name);\n}\n\nstatic int felix_init_structs(struct felix *felix, int num_phys_ports)\n{\n\tstruct ocelot *ocelot = &felix->ocelot;\n\tphy_interface_t *port_phy_modes;\n\tstruct regmap *target;\n\tint port, i, err;\n\n\tocelot->num_phys_ports = num_phys_ports;\n\tocelot->ports = devm_kcalloc(ocelot->dev, num_phys_ports,\n\t\t\t\t     sizeof(struct ocelot_port *), GFP_KERNEL);\n\tif (!ocelot->ports)\n\t\treturn -ENOMEM;\n\n\tocelot->map\t\t= felix->info->map;\n\tocelot->num_mact_rows\t= felix->info->num_mact_rows;\n\tocelot->vcap\t\t= felix->info->vcap;\n\tocelot->vcap_pol.base\t= felix->info->vcap_pol_base;\n\tocelot->vcap_pol.max\t= felix->info->vcap_pol_max;\n\tocelot->vcap_pol.base2\t= felix->info->vcap_pol_base2;\n\tocelot->vcap_pol.max2\t= felix->info->vcap_pol_max2;\n\tocelot->ops\t\t= felix->info->ops;\n\tocelot->npi_inj_prefix\t= OCELOT_TAG_PREFIX_SHORT;\n\tocelot->npi_xtr_prefix\t= OCELOT_TAG_PREFIX_SHORT;\n\tocelot->devlink\t\t= felix->ds->devlink;\n\n\tport_phy_modes = kcalloc(num_phys_ports, sizeof(phy_interface_t),\n\t\t\t\t GFP_KERNEL);\n\tif (!port_phy_modes)\n\t\treturn -ENOMEM;\n\n\terr = felix_parse_dt(felix, port_phy_modes);\n\tif (err) {\n\t\tkfree(port_phy_modes);\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < TARGET_MAX; i++) {\n\t\ttarget = felix_request_regmap(felix, i);\n\t\tif (IS_ERR(target)) {\n\t\t\tdev_err(ocelot->dev,\n\t\t\t\t\"Failed to map device memory space: %pe\\n\",\n\t\t\t\ttarget);\n\t\t\tkfree(port_phy_modes);\n\t\t\treturn PTR_ERR(target);\n\t\t}\n\n\t\tocelot->targets[i] = target;\n\t}\n\n\terr = ocelot_regfields_init(ocelot, felix->info->regfields);\n\tif (err) {\n\t\tdev_err(ocelot->dev, \"failed to init reg fields map\\n\");\n\t\tkfree(port_phy_modes);\n\t\treturn err;\n\t}\n\n\tfor (port = 0; port < num_phys_ports; port++) {\n\t\tstruct ocelot_port *ocelot_port;\n\n\t\tocelot_port = devm_kzalloc(ocelot->dev,\n\t\t\t\t\t   sizeof(struct ocelot_port),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!ocelot_port) {\n\t\t\tdev_err(ocelot->dev,\n\t\t\t\t\"failed to allocate port memory\\n\");\n\t\t\tkfree(port_phy_modes);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\ttarget = felix_request_port_regmap(felix, port);\n\t\tif (IS_ERR(target)) {\n\t\t\tdev_err(ocelot->dev,\n\t\t\t\t\"Failed to map memory space for port %d: %pe\\n\",\n\t\t\t\tport, target);\n\t\t\tkfree(port_phy_modes);\n\t\t\treturn PTR_ERR(target);\n\t\t}\n\n\t\tocelot_port->phy_mode = port_phy_modes[port];\n\t\tocelot_port->ocelot = ocelot;\n\t\tocelot_port->target = target;\n\t\tocelot_port->index = port;\n\t\tocelot->ports[port] = ocelot_port;\n\t}\n\n\tkfree(port_phy_modes);\n\n\tif (felix->info->mdio_bus_alloc) {\n\t\terr = felix->info->mdio_bus_alloc(ocelot);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void ocelot_port_purge_txtstamp_skb(struct ocelot *ocelot, int port,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\tstruct sk_buff *clone = OCELOT_SKB_CB(skb)->clone;\n\tstruct sk_buff *skb_match = NULL, *skb_tmp;\n\tunsigned long flags;\n\n\tif (!clone)\n\t\treturn;\n\n\tspin_lock_irqsave(&ocelot_port->tx_skbs.lock, flags);\n\n\tskb_queue_walk_safe(&ocelot_port->tx_skbs, skb, skb_tmp) {\n\t\tif (skb != clone)\n\t\t\tcontinue;\n\t\t__skb_unlink(skb, &ocelot_port->tx_skbs);\n\t\tskb_match = skb;\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&ocelot_port->tx_skbs.lock, flags);\n\n\tWARN_ONCE(!skb_match,\n\t\t  \"Could not find skb clone in TX timestamping list\\n\");\n}\n\n#define work_to_xmit_work(w) \\\n\t\tcontainer_of((w), struct felix_deferred_xmit_work, work)\n\nstatic void felix_port_deferred_xmit(struct kthread_work *work)\n{\n\tstruct felix_deferred_xmit_work *xmit_work = work_to_xmit_work(work);\n\tstruct dsa_switch *ds = xmit_work->dp->ds;\n\tstruct sk_buff *skb = xmit_work->skb;\n\tu32 rew_op = ocelot_ptp_rew_op(skb);\n\tstruct ocelot *ocelot = ds->priv;\n\tint port = xmit_work->dp->index;\n\tint retries = 10;\n\n\tdo {\n\t\tif (ocelot_can_inject(ocelot, 0))\n\t\t\tbreak;\n\n\t\tcpu_relax();\n\t} while (--retries);\n\n\tif (!retries) {\n\t\tdev_err(ocelot->dev, \"port %d failed to inject skb\\n\",\n\t\t\tport);\n\t\tocelot_port_purge_txtstamp_skb(ocelot, port, skb);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tocelot_port_inject_frame(ocelot, port, 0, rew_op, skb);\n\n\tconsume_skb(skb);\n\tkfree(xmit_work);\n}\n\nstatic int felix_connect_tag_protocol(struct dsa_switch *ds,\n\t\t\t\t      enum dsa_tag_protocol proto)\n{\n\tstruct ocelot_8021q_tagger_data *tagger_data;\n\n\tswitch (proto) {\n\tcase DSA_TAG_PROTO_OCELOT_8021Q:\n\t\ttagger_data = ocelot_8021q_tagger_data(ds);\n\t\ttagger_data->xmit_work_fn = felix_port_deferred_xmit;\n\t\treturn 0;\n\tcase DSA_TAG_PROTO_OCELOT:\n\tcase DSA_TAG_PROTO_SEVILLE:\n\t\treturn 0;\n\tdefault:\n\t\treturn -EPROTONOSUPPORT;\n\t}\n}\n\nstatic int felix_setup(struct dsa_switch *ds)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tstruct felix *felix = ocelot_to_felix(ocelot);\n\tstruct dsa_port *dp;\n\tint err;\n\n\terr = felix_init_structs(felix, ds->num_ports);\n\tif (err)\n\t\treturn err;\n\n\tif (ocelot->targets[HSIO])\n\t\tocelot_pll5_init(ocelot);\n\n\terr = ocelot_init(ocelot);\n\tif (err)\n\t\tgoto out_mdiobus_free;\n\n\tif (ocelot->ptp) {\n\t\terr = ocelot_init_timestamp(ocelot, felix->info->ptp_caps);\n\t\tif (err) {\n\t\t\tdev_err(ocelot->dev,\n\t\t\t\t\"Timestamp initialization failed\\n\");\n\t\t\tocelot->ptp = 0;\n\t\t}\n\t}\n\n\tdsa_switch_for_each_available_port(dp, ds) {\n\t\tocelot_init_port(ocelot, dp->index);\n\n\t\tif (felix->info->configure_serdes)\n\t\t\tfelix->info->configure_serdes(ocelot, dp->index,\n\t\t\t\t\t\t      dp->dn);\n\n\t\t \n\t\tfelix_port_qos_map_init(ocelot, dp->index);\n\t}\n\n\terr = ocelot_devlink_sb_register(ocelot);\n\tif (err)\n\t\tgoto out_deinit_ports;\n\n\t \n\tfelix_change_tag_protocol(ds, felix->tag_proto);\n\n\tds->mtu_enforcement_ingress = true;\n\tds->assisted_learning_on_cpu_port = true;\n\tds->fdb_isolation = true;\n\tds->max_num_bridges = ds->num_ports;\n\n\treturn 0;\n\nout_deinit_ports:\n\tdsa_switch_for_each_available_port(dp, ds)\n\t\tocelot_deinit_port(ocelot, dp->index);\n\n\tocelot_deinit_timestamp(ocelot);\n\tocelot_deinit(ocelot);\n\nout_mdiobus_free:\n\tif (felix->info->mdio_bus_free)\n\t\tfelix->info->mdio_bus_free(ocelot);\n\n\treturn err;\n}\n\nstatic void felix_teardown(struct dsa_switch *ds)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tstruct felix *felix = ocelot_to_felix(ocelot);\n\tstruct dsa_port *dp;\n\n\trtnl_lock();\n\tif (felix->tag_proto_ops)\n\t\tfelix->tag_proto_ops->teardown(ds);\n\trtnl_unlock();\n\n\tdsa_switch_for_each_available_port(dp, ds)\n\t\tocelot_deinit_port(ocelot, dp->index);\n\n\tocelot_devlink_sb_unregister(ocelot);\n\tocelot_deinit_timestamp(ocelot);\n\tocelot_deinit(ocelot);\n\n\tif (felix->info->mdio_bus_free)\n\t\tfelix->info->mdio_bus_free(ocelot);\n}\n\nstatic int felix_hwtstamp_get(struct dsa_switch *ds, int port,\n\t\t\t      struct ifreq *ifr)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_hwstamp_get(ocelot, port, ifr);\n}\n\nstatic int felix_hwtstamp_set(struct dsa_switch *ds, int port,\n\t\t\t      struct ifreq *ifr)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tstruct felix *felix = ocelot_to_felix(ocelot);\n\tbool using_tag_8021q;\n\tint err;\n\n\terr = ocelot_hwstamp_set(ocelot, port, ifr);\n\tif (err)\n\t\treturn err;\n\n\tusing_tag_8021q = felix->tag_proto == DSA_TAG_PROTO_OCELOT_8021Q;\n\n\treturn felix_update_trapping_destinations(ds, using_tag_8021q);\n}\n\nstatic bool felix_check_xtr_pkt(struct ocelot *ocelot)\n{\n\tstruct felix *felix = ocelot_to_felix(ocelot);\n\tint err = 0, grp = 0;\n\n\tif (felix->tag_proto != DSA_TAG_PROTO_OCELOT_8021Q)\n\t\treturn false;\n\n\tif (!felix->info->quirk_no_xtr_irq)\n\t\treturn false;\n\n\twhile (ocelot_read(ocelot, QS_XTR_DATA_PRESENT) & BIT(grp)) {\n\t\tstruct sk_buff *skb;\n\t\tunsigned int type;\n\n\t\terr = ocelot_xtr_poll_frame(ocelot, grp, &skb);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t \n\t\t__skb_push(skb, ETH_HLEN);\n\n\t\ttype = ptp_classify_raw(skb);\n\n\t\t__skb_pull(skb, ETH_HLEN);\n\n\t\tif (type == PTP_CLASS_NONE) {\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnetif_rx(skb);\n\t}\n\nout:\n\tif (err < 0) {\n\t\tdev_err_ratelimited(ocelot->dev,\n\t\t\t\t    \"Error during packet extraction: %pe\\n\",\n\t\t\t\t    ERR_PTR(err));\n\t\tocelot_drain_cpu_queue(ocelot, 0);\n\t}\n\n\treturn true;\n}\n\nstatic bool felix_rxtstamp(struct dsa_switch *ds, int port,\n\t\t\t   struct sk_buff *skb, unsigned int type)\n{\n\tu32 tstamp_lo = OCELOT_SKB_CB(skb)->tstamp_lo;\n\tstruct skb_shared_hwtstamps *shhwtstamps;\n\tstruct ocelot *ocelot = ds->priv;\n\tstruct timespec64 ts;\n\tu32 tstamp_hi;\n\tu64 tstamp;\n\n\tswitch (type & PTP_CLASS_PMASK) {\n\tcase PTP_CLASS_L2:\n\t\tif (!(ocelot->ports[port]->trap_proto & OCELOT_PROTO_PTP_L2))\n\t\t\treturn false;\n\t\tbreak;\n\tcase PTP_CLASS_IPV4:\n\tcase PTP_CLASS_IPV6:\n\t\tif (!(ocelot->ports[port]->trap_proto & OCELOT_PROTO_PTP_L4))\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\n\t \n\tif (felix_check_xtr_pkt(ocelot)) {\n\t\tkfree_skb(skb);\n\t\treturn true;\n\t}\n\n\tocelot_ptp_gettime64(&ocelot->ptp_info, &ts);\n\ttstamp = ktime_set(ts.tv_sec, ts.tv_nsec);\n\n\ttstamp_hi = tstamp >> 32;\n\tif ((tstamp & 0xffffffff) < tstamp_lo)\n\t\ttstamp_hi--;\n\n\ttstamp = ((u64)tstamp_hi << 32) | tstamp_lo;\n\n\tshhwtstamps = skb_hwtstamps(skb);\n\tmemset(shhwtstamps, 0, sizeof(struct skb_shared_hwtstamps));\n\tshhwtstamps->hwtstamp = tstamp;\n\treturn false;\n}\n\nstatic void felix_txtstamp(struct dsa_switch *ds, int port,\n\t\t\t   struct sk_buff *skb)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tstruct sk_buff *clone = NULL;\n\n\tif (!ocelot->ptp)\n\t\treturn;\n\n\tif (ocelot_port_txtstamp_request(ocelot, port, skb, &clone)) {\n\t\tdev_err_ratelimited(ds->dev,\n\t\t\t\t    \"port %d delivering skb without TX timestamp\\n\",\n\t\t\t\t    port);\n\t\treturn;\n\t}\n\n\tif (clone)\n\t\tOCELOT_SKB_CB(skb)->clone = clone;\n}\n\nstatic int felix_change_mtu(struct dsa_switch *ds, int port, int new_mtu)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tstruct ocelot_port *ocelot_port = ocelot->ports[port];\n\n\tocelot_port_set_maxlen(ocelot, port, new_mtu);\n\n\tmutex_lock(&ocelot->fwd_domain_lock);\n\n\tif (ocelot_port->taprio && ocelot->ops->tas_guard_bands_update)\n\t\tocelot->ops->tas_guard_bands_update(ocelot, port);\n\n\tmutex_unlock(&ocelot->fwd_domain_lock);\n\n\treturn 0;\n}\n\nstatic int felix_get_max_mtu(struct dsa_switch *ds, int port)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_get_max_mtu(ocelot, port);\n}\n\nstatic int felix_cls_flower_add(struct dsa_switch *ds, int port,\n\t\t\t\tstruct flow_cls_offload *cls, bool ingress)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tstruct felix *felix = ocelot_to_felix(ocelot);\n\tbool using_tag_8021q;\n\tint err;\n\n\terr = ocelot_cls_flower_replace(ocelot, port, cls, ingress);\n\tif (err)\n\t\treturn err;\n\n\tusing_tag_8021q = felix->tag_proto == DSA_TAG_PROTO_OCELOT_8021Q;\n\n\treturn felix_update_trapping_destinations(ds, using_tag_8021q);\n}\n\nstatic int felix_cls_flower_del(struct dsa_switch *ds, int port,\n\t\t\t\tstruct flow_cls_offload *cls, bool ingress)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_cls_flower_destroy(ocelot, port, cls, ingress);\n}\n\nstatic int felix_cls_flower_stats(struct dsa_switch *ds, int port,\n\t\t\t\t  struct flow_cls_offload *cls, bool ingress)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_cls_flower_stats(ocelot, port, cls, ingress);\n}\n\nstatic int felix_port_policer_add(struct dsa_switch *ds, int port,\n\t\t\t\t  struct dsa_mall_policer_tc_entry *policer)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tstruct ocelot_policer pol = {\n\t\t.rate = div_u64(policer->rate_bytes_per_sec, 1000) * 8,\n\t\t.burst = policer->burst,\n\t};\n\n\treturn ocelot_port_policer_add(ocelot, port, &pol);\n}\n\nstatic void felix_port_policer_del(struct dsa_switch *ds, int port)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\tocelot_port_policer_del(ocelot, port);\n}\n\nstatic int felix_port_mirror_add(struct dsa_switch *ds, int port,\n\t\t\t\t struct dsa_mall_mirror_tc_entry *mirror,\n\t\t\t\t bool ingress, struct netlink_ext_ack *extack)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_port_mirror_add(ocelot, port, mirror->to_local_port,\n\t\t\t\t      ingress, extack);\n}\n\nstatic void felix_port_mirror_del(struct dsa_switch *ds, int port,\n\t\t\t\t  struct dsa_mall_mirror_tc_entry *mirror)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\tocelot_port_mirror_del(ocelot, port, mirror->ingress);\n}\n\nstatic int felix_port_setup_tc(struct dsa_switch *ds, int port,\n\t\t\t       enum tc_setup_type type,\n\t\t\t       void *type_data)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\tstruct felix *felix = ocelot_to_felix(ocelot);\n\n\tif (felix->info->port_setup_tc)\n\t\treturn felix->info->port_setup_tc(ds, port, type, type_data);\n\telse\n\t\treturn -EOPNOTSUPP;\n}\n\nstatic int felix_sb_pool_get(struct dsa_switch *ds, unsigned int sb_index,\n\t\t\t     u16 pool_index,\n\t\t\t     struct devlink_sb_pool_info *pool_info)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_sb_pool_get(ocelot, sb_index, pool_index, pool_info);\n}\n\nstatic int felix_sb_pool_set(struct dsa_switch *ds, unsigned int sb_index,\n\t\t\t     u16 pool_index, u32 size,\n\t\t\t     enum devlink_sb_threshold_type threshold_type,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_sb_pool_set(ocelot, sb_index, pool_index, size,\n\t\t\t\t  threshold_type, extack);\n}\n\nstatic int felix_sb_port_pool_get(struct dsa_switch *ds, int port,\n\t\t\t\t  unsigned int sb_index, u16 pool_index,\n\t\t\t\t  u32 *p_threshold)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_sb_port_pool_get(ocelot, port, sb_index, pool_index,\n\t\t\t\t       p_threshold);\n}\n\nstatic int felix_sb_port_pool_set(struct dsa_switch *ds, int port,\n\t\t\t\t  unsigned int sb_index, u16 pool_index,\n\t\t\t\t  u32 threshold, struct netlink_ext_ack *extack)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_sb_port_pool_set(ocelot, port, sb_index, pool_index,\n\t\t\t\t       threshold, extack);\n}\n\nstatic int felix_sb_tc_pool_bind_get(struct dsa_switch *ds, int port,\n\t\t\t\t     unsigned int sb_index, u16 tc_index,\n\t\t\t\t     enum devlink_sb_pool_type pool_type,\n\t\t\t\t     u16 *p_pool_index, u32 *p_threshold)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_sb_tc_pool_bind_get(ocelot, port, sb_index, tc_index,\n\t\t\t\t\t  pool_type, p_pool_index,\n\t\t\t\t\t  p_threshold);\n}\n\nstatic int felix_sb_tc_pool_bind_set(struct dsa_switch *ds, int port,\n\t\t\t\t     unsigned int sb_index, u16 tc_index,\n\t\t\t\t     enum devlink_sb_pool_type pool_type,\n\t\t\t\t     u16 pool_index, u32 threshold,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_sb_tc_pool_bind_set(ocelot, port, sb_index, tc_index,\n\t\t\t\t\t  pool_type, pool_index, threshold,\n\t\t\t\t\t  extack);\n}\n\nstatic int felix_sb_occ_snapshot(struct dsa_switch *ds,\n\t\t\t\t unsigned int sb_index)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_sb_occ_snapshot(ocelot, sb_index);\n}\n\nstatic int felix_sb_occ_max_clear(struct dsa_switch *ds,\n\t\t\t\t  unsigned int sb_index)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_sb_occ_max_clear(ocelot, sb_index);\n}\n\nstatic int felix_sb_occ_port_pool_get(struct dsa_switch *ds, int port,\n\t\t\t\t      unsigned int sb_index, u16 pool_index,\n\t\t\t\t      u32 *p_cur, u32 *p_max)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_sb_occ_port_pool_get(ocelot, port, sb_index, pool_index,\n\t\t\t\t\t   p_cur, p_max);\n}\n\nstatic int felix_sb_occ_tc_port_bind_get(struct dsa_switch *ds, int port,\n\t\t\t\t\t unsigned int sb_index, u16 tc_index,\n\t\t\t\t\t enum devlink_sb_pool_type pool_type,\n\t\t\t\t\t u32 *p_cur, u32 *p_max)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_sb_occ_tc_port_bind_get(ocelot, port, sb_index, tc_index,\n\t\t\t\t\t      pool_type, p_cur, p_max);\n}\n\nstatic int felix_mrp_add(struct dsa_switch *ds, int port,\n\t\t\t const struct switchdev_obj_mrp *mrp)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_mrp_add(ocelot, port, mrp);\n}\n\nstatic int felix_mrp_del(struct dsa_switch *ds, int port,\n\t\t\t const struct switchdev_obj_mrp *mrp)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_mrp_add(ocelot, port, mrp);\n}\n\nstatic int\nfelix_mrp_add_ring_role(struct dsa_switch *ds, int port,\n\t\t\tconst struct switchdev_obj_ring_role_mrp *mrp)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_mrp_add_ring_role(ocelot, port, mrp);\n}\n\nstatic int\nfelix_mrp_del_ring_role(struct dsa_switch *ds, int port,\n\t\t\tconst struct switchdev_obj_ring_role_mrp *mrp)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_mrp_del_ring_role(ocelot, port, mrp);\n}\n\nstatic int felix_port_get_default_prio(struct dsa_switch *ds, int port)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_port_get_default_prio(ocelot, port);\n}\n\nstatic int felix_port_set_default_prio(struct dsa_switch *ds, int port,\n\t\t\t\t       u8 prio)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_port_set_default_prio(ocelot, port, prio);\n}\n\nstatic int felix_port_get_dscp_prio(struct dsa_switch *ds, int port, u8 dscp)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_port_get_dscp_prio(ocelot, port, dscp);\n}\n\nstatic int felix_port_add_dscp_prio(struct dsa_switch *ds, int port, u8 dscp,\n\t\t\t\t    u8 prio)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_port_add_dscp_prio(ocelot, port, dscp, prio);\n}\n\nstatic int felix_port_del_dscp_prio(struct dsa_switch *ds, int port, u8 dscp,\n\t\t\t\t    u8 prio)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_port_del_dscp_prio(ocelot, port, dscp, prio);\n}\n\nstatic int felix_get_mm(struct dsa_switch *ds, int port,\n\t\t\tstruct ethtool_mm_state *state)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_port_get_mm(ocelot, port, state);\n}\n\nstatic int felix_set_mm(struct dsa_switch *ds, int port,\n\t\t\tstruct ethtool_mm_cfg *cfg,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\treturn ocelot_port_set_mm(ocelot, port, cfg, extack);\n}\n\nstatic void felix_get_mm_stats(struct dsa_switch *ds, int port,\n\t\t\t       struct ethtool_mm_stats *stats)\n{\n\tstruct ocelot *ocelot = ds->priv;\n\n\tocelot_port_get_mm_stats(ocelot, port, stats);\n}\n\nconst struct dsa_switch_ops felix_switch_ops = {\n\t.get_tag_protocol\t\t= felix_get_tag_protocol,\n\t.change_tag_protocol\t\t= felix_change_tag_protocol,\n\t.connect_tag_protocol\t\t= felix_connect_tag_protocol,\n\t.setup\t\t\t\t= felix_setup,\n\t.teardown\t\t\t= felix_teardown,\n\t.set_ageing_time\t\t= felix_set_ageing_time,\n\t.get_mm\t\t\t\t= felix_get_mm,\n\t.set_mm\t\t\t\t= felix_set_mm,\n\t.get_mm_stats\t\t\t= felix_get_mm_stats,\n\t.get_stats64\t\t\t= felix_get_stats64,\n\t.get_pause_stats\t\t= felix_get_pause_stats,\n\t.get_rmon_stats\t\t\t= felix_get_rmon_stats,\n\t.get_eth_ctrl_stats\t\t= felix_get_eth_ctrl_stats,\n\t.get_eth_mac_stats\t\t= felix_get_eth_mac_stats,\n\t.get_eth_phy_stats\t\t= felix_get_eth_phy_stats,\n\t.get_strings\t\t\t= felix_get_strings,\n\t.get_ethtool_stats\t\t= felix_get_ethtool_stats,\n\t.get_sset_count\t\t\t= felix_get_sset_count,\n\t.get_ts_info\t\t\t= felix_get_ts_info,\n\t.phylink_get_caps\t\t= felix_phylink_get_caps,\n\t.phylink_mac_config\t\t= felix_phylink_mac_config,\n\t.phylink_mac_select_pcs\t\t= felix_phylink_mac_select_pcs,\n\t.phylink_mac_link_down\t\t= felix_phylink_mac_link_down,\n\t.phylink_mac_link_up\t\t= felix_phylink_mac_link_up,\n\t.port_enable\t\t\t= felix_port_enable,\n\t.port_fast_age\t\t\t= felix_port_fast_age,\n\t.port_fdb_dump\t\t\t= felix_fdb_dump,\n\t.port_fdb_add\t\t\t= felix_fdb_add,\n\t.port_fdb_del\t\t\t= felix_fdb_del,\n\t.lag_fdb_add\t\t\t= felix_lag_fdb_add,\n\t.lag_fdb_del\t\t\t= felix_lag_fdb_del,\n\t.port_mdb_add\t\t\t= felix_mdb_add,\n\t.port_mdb_del\t\t\t= felix_mdb_del,\n\t.port_pre_bridge_flags\t\t= felix_pre_bridge_flags,\n\t.port_bridge_flags\t\t= felix_bridge_flags,\n\t.port_bridge_join\t\t= felix_bridge_join,\n\t.port_bridge_leave\t\t= felix_bridge_leave,\n\t.port_lag_join\t\t\t= felix_lag_join,\n\t.port_lag_leave\t\t\t= felix_lag_leave,\n\t.port_lag_change\t\t= felix_lag_change,\n\t.port_stp_state_set\t\t= felix_bridge_stp_state_set,\n\t.port_vlan_filtering\t\t= felix_vlan_filtering,\n\t.port_vlan_add\t\t\t= felix_vlan_add,\n\t.port_vlan_del\t\t\t= felix_vlan_del,\n\t.port_hwtstamp_get\t\t= felix_hwtstamp_get,\n\t.port_hwtstamp_set\t\t= felix_hwtstamp_set,\n\t.port_rxtstamp\t\t\t= felix_rxtstamp,\n\t.port_txtstamp\t\t\t= felix_txtstamp,\n\t.port_change_mtu\t\t= felix_change_mtu,\n\t.port_max_mtu\t\t\t= felix_get_max_mtu,\n\t.port_policer_add\t\t= felix_port_policer_add,\n\t.port_policer_del\t\t= felix_port_policer_del,\n\t.port_mirror_add\t\t= felix_port_mirror_add,\n\t.port_mirror_del\t\t= felix_port_mirror_del,\n\t.cls_flower_add\t\t\t= felix_cls_flower_add,\n\t.cls_flower_del\t\t\t= felix_cls_flower_del,\n\t.cls_flower_stats\t\t= felix_cls_flower_stats,\n\t.port_setup_tc\t\t\t= felix_port_setup_tc,\n\t.devlink_sb_pool_get\t\t= felix_sb_pool_get,\n\t.devlink_sb_pool_set\t\t= felix_sb_pool_set,\n\t.devlink_sb_port_pool_get\t= felix_sb_port_pool_get,\n\t.devlink_sb_port_pool_set\t= felix_sb_port_pool_set,\n\t.devlink_sb_tc_pool_bind_get\t= felix_sb_tc_pool_bind_get,\n\t.devlink_sb_tc_pool_bind_set\t= felix_sb_tc_pool_bind_set,\n\t.devlink_sb_occ_snapshot\t= felix_sb_occ_snapshot,\n\t.devlink_sb_occ_max_clear\t= felix_sb_occ_max_clear,\n\t.devlink_sb_occ_port_pool_get\t= felix_sb_occ_port_pool_get,\n\t.devlink_sb_occ_tc_port_bind_get= felix_sb_occ_tc_port_bind_get,\n\t.port_mrp_add\t\t\t= felix_mrp_add,\n\t.port_mrp_del\t\t\t= felix_mrp_del,\n\t.port_mrp_add_ring_role\t\t= felix_mrp_add_ring_role,\n\t.port_mrp_del_ring_role\t\t= felix_mrp_del_ring_role,\n\t.tag_8021q_vlan_add\t\t= felix_tag_8021q_vlan_add,\n\t.tag_8021q_vlan_del\t\t= felix_tag_8021q_vlan_del,\n\t.port_get_default_prio\t\t= felix_port_get_default_prio,\n\t.port_set_default_prio\t\t= felix_port_set_default_prio,\n\t.port_get_dscp_prio\t\t= felix_port_get_dscp_prio,\n\t.port_add_dscp_prio\t\t= felix_port_add_dscp_prio,\n\t.port_del_dscp_prio\t\t= felix_port_del_dscp_prio,\n\t.port_set_host_flood\t\t= felix_port_set_host_flood,\n\t.port_change_master\t\t= felix_port_change_master,\n};\nEXPORT_SYMBOL_GPL(felix_switch_ops);\n\nstruct net_device *felix_port_to_netdev(struct ocelot *ocelot, int port)\n{\n\tstruct felix *felix = ocelot_to_felix(ocelot);\n\tstruct dsa_switch *ds = felix->ds;\n\n\tif (!dsa_is_user_port(ds, port))\n\t\treturn NULL;\n\n\treturn dsa_to_port(ds, port)->slave;\n}\nEXPORT_SYMBOL_GPL(felix_port_to_netdev);\n\nint felix_netdev_to_port(struct net_device *dev)\n{\n\tstruct dsa_port *dp;\n\n\tdp = dsa_port_from_netdev(dev);\n\tif (IS_ERR(dp))\n\t\treturn -EINVAL;\n\n\treturn dp->index;\n}\nEXPORT_SYMBOL_GPL(felix_netdev_to_port);\n\nMODULE_DESCRIPTION(\"Felix DSA library\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}