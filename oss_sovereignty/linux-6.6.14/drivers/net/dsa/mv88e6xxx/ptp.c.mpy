{
  "module_name": "ptp.c",
  "hash_id": "e31f6fa82aa37ea6118c47a81b4e6a8574be959c88ee4fed77cefffa15db5f0e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/mv88e6xxx/ptp.c",
  "human_readable_source": "\n \n\n#include \"chip.h\"\n#include \"global1.h\"\n#include \"global2.h\"\n#include \"hwtstamp.h\"\n#include \"ptp.h\"\n\n#define MV88E6XXX_MAX_ADJ_PPB\t1000000\n\n \n#define MV88E6250_CC_SHIFT\t28\n#define MV88E6250_CC_MULT\t(10 << MV88E6250_CC_SHIFT)\n#define MV88E6250_CC_MULT_NUM\t(1 << 7)\n#define MV88E6250_CC_MULT_DEM\t3125ULL\n\n \n#define MV88E6XXX_CC_SHIFT\t28\n#define MV88E6XXX_CC_MULT\t(8 << MV88E6XXX_CC_SHIFT)\n#define MV88E6XXX_CC_MULT_NUM\t(1 << 9)\n#define MV88E6XXX_CC_MULT_DEM\t15625ULL\n\n#define TAI_EVENT_WORK_INTERVAL msecs_to_jiffies(100)\n\n#define cc_to_chip(cc) container_of(cc, struct mv88e6xxx_chip, tstamp_cc)\n#define dw_overflow_to_chip(dw) container_of(dw, struct mv88e6xxx_chip, \\\n\t\t\t\t\t     overflow_work)\n#define dw_tai_event_to_chip(dw) container_of(dw, struct mv88e6xxx_chip, \\\n\t\t\t\t\t      tai_event_work)\n\nstatic int mv88e6xxx_tai_read(struct mv88e6xxx_chip *chip, int addr,\n\t\t\t      u16 *data, int len)\n{\n\tif (!chip->info->ops->avb_ops->tai_read)\n\t\treturn -EOPNOTSUPP;\n\n\treturn chip->info->ops->avb_ops->tai_read(chip, addr, data, len);\n}\n\nstatic int mv88e6xxx_tai_write(struct mv88e6xxx_chip *chip, int addr, u16 data)\n{\n\tif (!chip->info->ops->avb_ops->tai_write)\n\t\treturn -EOPNOTSUPP;\n\n\treturn chip->info->ops->avb_ops->tai_write(chip, addr, data);\n}\n\n \nstatic int mv88e6352_set_gpio_func(struct mv88e6xxx_chip *chip, int pin,\n\t\t\t\t   int func, int input)\n{\n\tint err;\n\n\tif (!chip->info->ops->gpio_ops)\n\t\treturn -EOPNOTSUPP;\n\n\terr = chip->info->ops->gpio_ops->set_dir(chip, pin, input);\n\tif (err)\n\t\treturn err;\n\n\treturn chip->info->ops->gpio_ops->set_pctl(chip, pin, func);\n}\n\nstatic u64 mv88e6352_ptp_clock_read(const struct cyclecounter *cc)\n{\n\tstruct mv88e6xxx_chip *chip = cc_to_chip(cc);\n\tu16 phc_time[2];\n\tint err;\n\n\terr = mv88e6xxx_tai_read(chip, MV88E6XXX_TAI_TIME_LO, phc_time,\n\t\t\t\t ARRAY_SIZE(phc_time));\n\tif (err)\n\t\treturn 0;\n\telse\n\t\treturn ((u32)phc_time[1] << 16) | phc_time[0];\n}\n\nstatic u64 mv88e6165_ptp_clock_read(const struct cyclecounter *cc)\n{\n\tstruct mv88e6xxx_chip *chip = cc_to_chip(cc);\n\tu16 phc_time[2];\n\tint err;\n\n\terr = mv88e6xxx_tai_read(chip, MV88E6XXX_PTP_GC_TIME_LO, phc_time,\n\t\t\t\t ARRAY_SIZE(phc_time));\n\tif (err)\n\t\treturn 0;\n\telse\n\t\treturn ((u32)phc_time[1] << 16) | phc_time[0];\n}\n\n \nstatic int mv88e6352_config_eventcap(struct mv88e6xxx_chip *chip, int event,\n\t\t\t\t     int rising)\n{\n\tu16 global_config;\n\tu16 cap_config;\n\tint err;\n\n\tchip->evcap_config = MV88E6XXX_TAI_CFG_CAP_OVERWRITE |\n\t\t\t     MV88E6XXX_TAI_CFG_CAP_CTR_START;\n\tif (!rising)\n\t\tchip->evcap_config |= MV88E6XXX_TAI_CFG_EVREQ_FALLING;\n\n\tglobal_config = (chip->evcap_config | chip->trig_config);\n\terr = mv88e6xxx_tai_write(chip, MV88E6XXX_TAI_CFG, global_config);\n\tif (err)\n\t\treturn err;\n\n\tif (event == PTP_CLOCK_PPS) {\n\t\tcap_config = MV88E6XXX_TAI_EVENT_STATUS_CAP_TRIG;\n\t} else if (event == PTP_CLOCK_EXTTS) {\n\t\t \n\t\tcap_config = 0;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\terr = mv88e6xxx_tai_write(chip, MV88E6XXX_TAI_EVENT_STATUS,\n\t\t\t\t  cap_config);\n\n\treturn err;\n}\n\nstatic void mv88e6352_tai_event_work(struct work_struct *ugly)\n{\n\tstruct delayed_work *dw = to_delayed_work(ugly);\n\tstruct mv88e6xxx_chip *chip = dw_tai_event_to_chip(dw);\n\tstruct ptp_clock_event ev;\n\tu16 status[4];\n\tu32 raw_ts;\n\tint err;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = mv88e6xxx_tai_read(chip, MV88E6XXX_TAI_EVENT_STATUS,\n\t\t\t\t status, ARRAY_SIZE(status));\n\tmv88e6xxx_reg_unlock(chip);\n\n\tif (err) {\n\t\tdev_err(chip->dev, \"failed to read TAI status register\\n\");\n\t\treturn;\n\t}\n\tif (status[0] & MV88E6XXX_TAI_EVENT_STATUS_ERROR) {\n\t\tdev_warn(chip->dev, \"missed event capture\\n\");\n\t\treturn;\n\t}\n\tif (!(status[0] & MV88E6XXX_TAI_EVENT_STATUS_VALID))\n\t\tgoto out;\n\n\traw_ts = ((u32)status[2] << 16) | status[1];\n\n\t \n\tstatus[0] &= ~MV88E6XXX_TAI_EVENT_STATUS_VALID;\n\tmv88e6xxx_reg_lock(chip);\n\terr = mv88e6xxx_tai_write(chip, MV88E6XXX_TAI_EVENT_STATUS, status[0]);\n\tmv88e6xxx_reg_unlock(chip);\n\n\t \n\tev.type = PTP_CLOCK_EXTTS;\n\n\t \n\tev.index = 0;\n\tmv88e6xxx_reg_lock(chip);\n\tev.timestamp = timecounter_cyc2time(&chip->tstamp_tc, raw_ts);\n\tmv88e6xxx_reg_unlock(chip);\n\n\tptp_clock_event(chip->ptp_clock, &ev);\nout:\n\tschedule_delayed_work(&chip->tai_event_work, TAI_EVENT_WORK_INTERVAL);\n}\n\nstatic int mv88e6xxx_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct mv88e6xxx_chip *chip = ptp_to_chip(ptp);\n\tconst struct mv88e6xxx_ptp_ops *ptp_ops = chip->info->ops->ptp_ops;\n\tint neg_adj = 0;\n\tu32 diff, mult;\n\tu64 adj;\n\n\tif (scaled_ppm < 0) {\n\t\tneg_adj = 1;\n\t\tscaled_ppm = -scaled_ppm;\n\t}\n\n\tmult = ptp_ops->cc_mult;\n\tadj = ptp_ops->cc_mult_num;\n\tadj *= scaled_ppm;\n\tdiff = div_u64(adj, ptp_ops->cc_mult_dem);\n\n\tmv88e6xxx_reg_lock(chip);\n\n\ttimecounter_read(&chip->tstamp_tc);\n\tchip->tstamp_cc.mult = neg_adj ? mult - diff : mult + diff;\n\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct mv88e6xxx_chip *chip = ptp_to_chip(ptp);\n\n\tmv88e6xxx_reg_lock(chip);\n\ttimecounter_adjtime(&chip->tstamp_tc, delta);\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_ptp_gettime(struct ptp_clock_info *ptp,\n\t\t\t\t struct timespec64 *ts)\n{\n\tstruct mv88e6xxx_chip *chip = ptp_to_chip(ptp);\n\tu64 ns;\n\n\tmv88e6xxx_reg_lock(chip);\n\tns = timecounter_read(&chip->tstamp_tc);\n\tmv88e6xxx_reg_unlock(chip);\n\n\t*ts = ns_to_timespec64(ns);\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_ptp_settime(struct ptp_clock_info *ptp,\n\t\t\t\t const struct timespec64 *ts)\n{\n\tstruct mv88e6xxx_chip *chip = ptp_to_chip(ptp);\n\tu64 ns;\n\n\tns = timespec64_to_ns(ts);\n\n\tmv88e6xxx_reg_lock(chip);\n\ttimecounter_init(&chip->tstamp_tc, &chip->tstamp_cc, ns);\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn 0;\n}\n\nstatic int mv88e6352_ptp_enable_extts(struct mv88e6xxx_chip *chip,\n\t\t\t\t      struct ptp_clock_request *rq, int on)\n{\n\tint rising = (rq->extts.flags & PTP_RISING_EDGE);\n\tint func;\n\tint pin;\n\tint err;\n\n\t \n\tif (rq->extts.flags & ~(PTP_ENABLE_FEATURE |\n\t\t\t\tPTP_RISING_EDGE |\n\t\t\t\tPTP_FALLING_EDGE |\n\t\t\t\tPTP_STRICT_FLAGS))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif ((rq->extts.flags & PTP_STRICT_FLAGS) &&\n\t    (rq->extts.flags & PTP_ENABLE_FEATURE) &&\n\t    (rq->extts.flags & PTP_EXTTS_EDGES) == PTP_EXTTS_EDGES)\n\t\treturn -EOPNOTSUPP;\n\n\tpin = ptp_find_pin(chip->ptp_clock, PTP_PF_EXTTS, rq->extts.index);\n\n\tif (pin < 0)\n\t\treturn -EBUSY;\n\n\tmv88e6xxx_reg_lock(chip);\n\n\tif (on) {\n\t\tfunc = MV88E6352_G2_SCRATCH_GPIO_PCTL_EVREQ;\n\n\t\terr = mv88e6352_set_gpio_func(chip, pin, func, true);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tschedule_delayed_work(&chip->tai_event_work,\n\t\t\t\t      TAI_EVENT_WORK_INTERVAL);\n\n\t\terr = mv88e6352_config_eventcap(chip, PTP_CLOCK_EXTTS, rising);\n\t} else {\n\t\tfunc = MV88E6352_G2_SCRATCH_GPIO_PCTL_GPIO;\n\n\t\terr = mv88e6352_set_gpio_func(chip, pin, func, true);\n\n\t\tcancel_delayed_work_sync(&chip->tai_event_work);\n\t}\n\nout:\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err;\n}\n\nstatic int mv88e6352_ptp_enable(struct ptp_clock_info *ptp,\n\t\t\t\tstruct ptp_clock_request *rq, int on)\n{\n\tstruct mv88e6xxx_chip *chip = ptp_to_chip(ptp);\n\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_EXTTS:\n\t\treturn mv88e6352_ptp_enable_extts(chip, rq, on);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int mv88e6352_ptp_verify(struct ptp_clock_info *ptp, unsigned int pin,\n\t\t\t\tenum ptp_pin_function func, unsigned int chan)\n{\n\tswitch (func) {\n\tcase PTP_PF_NONE:\n\tcase PTP_PF_EXTTS:\n\t\tbreak;\n\tcase PTP_PF_PEROUT:\n\tcase PTP_PF_PHYSYNC:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nconst struct mv88e6xxx_ptp_ops mv88e6165_ptp_ops = {\n\t.clock_read = mv88e6165_ptp_clock_read,\n\t.global_enable = mv88e6165_global_enable,\n\t.global_disable = mv88e6165_global_disable,\n\t.arr0_sts_reg = MV88E6165_PORT_PTP_ARR0_STS,\n\t.arr1_sts_reg = MV88E6165_PORT_PTP_ARR1_STS,\n\t.dep_sts_reg = MV88E6165_PORT_PTP_DEP_STS,\n\t.rx_filters = (1 << HWTSTAMP_FILTER_NONE) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L2_EVENT) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L2_SYNC) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_EVENT) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_SYNC) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_DELAY_REQ),\n\t.cc_shift = MV88E6XXX_CC_SHIFT,\n\t.cc_mult = MV88E6XXX_CC_MULT,\n\t.cc_mult_num = MV88E6XXX_CC_MULT_NUM,\n\t.cc_mult_dem = MV88E6XXX_CC_MULT_DEM,\n};\n\nconst struct mv88e6xxx_ptp_ops mv88e6250_ptp_ops = {\n\t.clock_read = mv88e6352_ptp_clock_read,\n\t.ptp_enable = mv88e6352_ptp_enable,\n\t.ptp_verify = mv88e6352_ptp_verify,\n\t.event_work = mv88e6352_tai_event_work,\n\t.port_enable = mv88e6352_hwtstamp_port_enable,\n\t.port_disable = mv88e6352_hwtstamp_port_disable,\n\t.n_ext_ts = 1,\n\t.arr0_sts_reg = MV88E6XXX_PORT_PTP_ARR0_STS,\n\t.arr1_sts_reg = MV88E6XXX_PORT_PTP_ARR1_STS,\n\t.dep_sts_reg = MV88E6XXX_PORT_PTP_DEP_STS,\n\t.rx_filters = (1 << HWTSTAMP_FILTER_NONE) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L4_SYNC) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L2_EVENT) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L2_SYNC) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_EVENT) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_SYNC) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_DELAY_REQ),\n\t.cc_shift = MV88E6250_CC_SHIFT,\n\t.cc_mult = MV88E6250_CC_MULT,\n\t.cc_mult_num = MV88E6250_CC_MULT_NUM,\n\t.cc_mult_dem = MV88E6250_CC_MULT_DEM,\n};\n\nconst struct mv88e6xxx_ptp_ops mv88e6352_ptp_ops = {\n\t.clock_read = mv88e6352_ptp_clock_read,\n\t.ptp_enable = mv88e6352_ptp_enable,\n\t.ptp_verify = mv88e6352_ptp_verify,\n\t.event_work = mv88e6352_tai_event_work,\n\t.port_enable = mv88e6352_hwtstamp_port_enable,\n\t.port_disable = mv88e6352_hwtstamp_port_disable,\n\t.n_ext_ts = 1,\n\t.arr0_sts_reg = MV88E6XXX_PORT_PTP_ARR0_STS,\n\t.arr1_sts_reg = MV88E6XXX_PORT_PTP_ARR1_STS,\n\t.dep_sts_reg = MV88E6XXX_PORT_PTP_DEP_STS,\n\t.rx_filters = (1 << HWTSTAMP_FILTER_NONE) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L4_SYNC) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L2_EVENT) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L2_SYNC) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_EVENT) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_SYNC) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_DELAY_REQ),\n\t.cc_shift = MV88E6XXX_CC_SHIFT,\n\t.cc_mult = MV88E6XXX_CC_MULT,\n\t.cc_mult_num = MV88E6XXX_CC_MULT_NUM,\n\t.cc_mult_dem = MV88E6XXX_CC_MULT_DEM,\n};\n\nconst struct mv88e6xxx_ptp_ops mv88e6390_ptp_ops = {\n\t.clock_read = mv88e6352_ptp_clock_read,\n\t.ptp_enable = mv88e6352_ptp_enable,\n\t.ptp_verify = mv88e6352_ptp_verify,\n\t.event_work = mv88e6352_tai_event_work,\n\t.port_enable = mv88e6352_hwtstamp_port_enable,\n\t.port_disable = mv88e6352_hwtstamp_port_disable,\n\t.set_ptp_cpu_port = mv88e6390_g1_set_ptp_cpu_port,\n\t.n_ext_ts = 1,\n\t.arr0_sts_reg = MV88E6XXX_PORT_PTP_ARR0_STS,\n\t.arr1_sts_reg = MV88E6XXX_PORT_PTP_ARR1_STS,\n\t.dep_sts_reg = MV88E6XXX_PORT_PTP_DEP_STS,\n\t.rx_filters = (1 << HWTSTAMP_FILTER_NONE) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L4_SYNC) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L2_EVENT) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L2_SYNC) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_EVENT) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_SYNC) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_DELAY_REQ),\n\t.cc_shift = MV88E6XXX_CC_SHIFT,\n\t.cc_mult = MV88E6XXX_CC_MULT,\n\t.cc_mult_num = MV88E6XXX_CC_MULT_NUM,\n\t.cc_mult_dem = MV88E6XXX_CC_MULT_DEM,\n};\n\nstatic u64 mv88e6xxx_ptp_clock_read(const struct cyclecounter *cc)\n{\n\tstruct mv88e6xxx_chip *chip = cc_to_chip(cc);\n\n\tif (chip->info->ops->ptp_ops->clock_read)\n\t\treturn chip->info->ops->ptp_ops->clock_read(cc);\n\n\treturn 0;\n}\n\n \n#define MV88E6XXX_TAI_OVERFLOW_PERIOD (HZ * 16)\nstatic void mv88e6xxx_ptp_overflow_check(struct work_struct *work)\n{\n\tstruct delayed_work *dw = to_delayed_work(work);\n\tstruct mv88e6xxx_chip *chip = dw_overflow_to_chip(dw);\n\tstruct timespec64 ts;\n\n\tmv88e6xxx_ptp_gettime(&chip->ptp_clock_info, &ts);\n\n\tschedule_delayed_work(&chip->overflow_work,\n\t\t\t      MV88E6XXX_TAI_OVERFLOW_PERIOD);\n}\n\nint mv88e6xxx_ptp_setup(struct mv88e6xxx_chip *chip)\n{\n\tconst struct mv88e6xxx_ptp_ops *ptp_ops = chip->info->ops->ptp_ops;\n\tint i;\n\n\t \n\tmemset(&chip->tstamp_cc, 0, sizeof(chip->tstamp_cc));\n\tchip->tstamp_cc.read\t= mv88e6xxx_ptp_clock_read;\n\tchip->tstamp_cc.mask\t= CYCLECOUNTER_MASK(32);\n\tchip->tstamp_cc.mult\t= ptp_ops->cc_mult;\n\tchip->tstamp_cc.shift\t= ptp_ops->cc_shift;\n\n\ttimecounter_init(&chip->tstamp_tc, &chip->tstamp_cc,\n\t\t\t ktime_to_ns(ktime_get_real()));\n\n\tINIT_DELAYED_WORK(&chip->overflow_work, mv88e6xxx_ptp_overflow_check);\n\tif (ptp_ops->event_work)\n\t\tINIT_DELAYED_WORK(&chip->tai_event_work, ptp_ops->event_work);\n\n\tchip->ptp_clock_info.owner = THIS_MODULE;\n\tsnprintf(chip->ptp_clock_info.name, sizeof(chip->ptp_clock_info.name),\n\t\t \"%s\", dev_name(chip->dev));\n\n\tchip->ptp_clock_info.n_ext_ts\t= ptp_ops->n_ext_ts;\n\tchip->ptp_clock_info.n_per_out\t= 0;\n\tchip->ptp_clock_info.n_pins\t= mv88e6xxx_num_gpio(chip);\n\tchip->ptp_clock_info.pps\t= 0;\n\n\tfor (i = 0; i < chip->ptp_clock_info.n_pins; ++i) {\n\t\tstruct ptp_pin_desc *ppd = &chip->pin_config[i];\n\n\t\tsnprintf(ppd->name, sizeof(ppd->name), \"mv88e6xxx_gpio%d\", i);\n\t\tppd->index = i;\n\t\tppd->func = PTP_PF_NONE;\n\t}\n\tchip->ptp_clock_info.pin_config = chip->pin_config;\n\n\tchip->ptp_clock_info.max_adj    = MV88E6XXX_MAX_ADJ_PPB;\n\tchip->ptp_clock_info.adjfine\t= mv88e6xxx_ptp_adjfine;\n\tchip->ptp_clock_info.adjtime\t= mv88e6xxx_ptp_adjtime;\n\tchip->ptp_clock_info.gettime64\t= mv88e6xxx_ptp_gettime;\n\tchip->ptp_clock_info.settime64\t= mv88e6xxx_ptp_settime;\n\tchip->ptp_clock_info.enable\t= ptp_ops->ptp_enable;\n\tchip->ptp_clock_info.verify\t= ptp_ops->ptp_verify;\n\tchip->ptp_clock_info.do_aux_work = mv88e6xxx_hwtstamp_work;\n\n\tif (ptp_ops->set_ptp_cpu_port) {\n\t\tstruct dsa_port *dp;\n\t\tint upstream = 0;\n\t\tint err;\n\n\t\tdsa_switch_for_each_user_port(dp, chip->ds) {\n\t\t\tupstream = dsa_upstream_port(chip->ds, dp->index);\n\t\t\tbreak;\n\t\t}\n\n\t\terr = ptp_ops->set_ptp_cpu_port(chip, upstream);\n\t\tif (err) {\n\t\t\tdev_err(chip->dev, \"Failed to set PTP CPU destination port!\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tchip->ptp_clock = ptp_clock_register(&chip->ptp_clock_info, chip->dev);\n\tif (IS_ERR(chip->ptp_clock))\n\t\treturn PTR_ERR(chip->ptp_clock);\n\n\tschedule_delayed_work(&chip->overflow_work,\n\t\t\t      MV88E6XXX_TAI_OVERFLOW_PERIOD);\n\n\treturn 0;\n}\n\nvoid mv88e6xxx_ptp_free(struct mv88e6xxx_chip *chip)\n{\n\tif (chip->ptp_clock) {\n\t\tcancel_delayed_work_sync(&chip->overflow_work);\n\t\tif (chip->info->ops->ptp_ops->event_work)\n\t\t\tcancel_delayed_work_sync(&chip->tai_event_work);\n\n\t\tptp_clock_unregister(chip->ptp_clock);\n\t\tchip->ptp_clock = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}