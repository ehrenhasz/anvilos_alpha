{
  "module_name": "devlink.c",
  "hash_id": "5fe48e79b7e2ac3f1777862595bb8e67bcb7ec600e83bf130cbd00eec9373d2e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/mv88e6xxx/devlink.c",
  "human_readable_source": "\n#include <net/dsa.h>\n\n#include \"chip.h\"\n#include \"devlink.h\"\n#include \"global1.h\"\n#include \"global2.h\"\n#include \"port.h\"\n\nstatic int mv88e6xxx_atu_get_hash(struct mv88e6xxx_chip *chip, u8 *hash)\n{\n\tif (chip->info->ops->atu_get_hash)\n\t\treturn chip->info->ops->atu_get_hash(chip, hash);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int mv88e6xxx_atu_set_hash(struct mv88e6xxx_chip *chip, u8 hash)\n{\n\tif (chip->info->ops->atu_set_hash)\n\t\treturn chip->info->ops->atu_set_hash(chip, hash);\n\n\treturn -EOPNOTSUPP;\n}\n\nenum mv88e6xxx_devlink_param_id {\n\tMV88E6XXX_DEVLINK_PARAM_ID_BASE = DEVLINK_PARAM_GENERIC_ID_MAX,\n\tMV88E6XXX_DEVLINK_PARAM_ID_ATU_HASH,\n};\n\nint mv88e6xxx_devlink_param_get(struct dsa_switch *ds, u32 id,\n\t\t\t\tstruct devlink_param_gset_ctx *ctx)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err;\n\n\tmv88e6xxx_reg_lock(chip);\n\n\tswitch (id) {\n\tcase MV88E6XXX_DEVLINK_PARAM_ID_ATU_HASH:\n\t\terr = mv88e6xxx_atu_get_hash(chip, &ctx->val.vu8);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err;\n}\n\nint mv88e6xxx_devlink_param_set(struct dsa_switch *ds, u32 id,\n\t\t\t\tstruct devlink_param_gset_ctx *ctx)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err;\n\n\tmv88e6xxx_reg_lock(chip);\n\n\tswitch (id) {\n\tcase MV88E6XXX_DEVLINK_PARAM_ID_ATU_HASH:\n\t\terr = mv88e6xxx_atu_set_hash(chip, ctx->val.vu8);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err;\n}\n\nstatic const struct devlink_param mv88e6xxx_devlink_params[] = {\n\tDSA_DEVLINK_PARAM_DRIVER(MV88E6XXX_DEVLINK_PARAM_ID_ATU_HASH,\n\t\t\t\t \"ATU_hash\", DEVLINK_PARAM_TYPE_U8,\n\t\t\t\t BIT(DEVLINK_PARAM_CMODE_RUNTIME)),\n};\n\nint mv88e6xxx_setup_devlink_params(struct dsa_switch *ds)\n{\n\treturn dsa_devlink_params_register(ds, mv88e6xxx_devlink_params,\n\t\t\t\t\t   ARRAY_SIZE(mv88e6xxx_devlink_params));\n}\n\nvoid mv88e6xxx_teardown_devlink_params(struct dsa_switch *ds)\n{\n\tdsa_devlink_params_unregister(ds, mv88e6xxx_devlink_params,\n\t\t\t\t      ARRAY_SIZE(mv88e6xxx_devlink_params));\n}\n\nenum mv88e6xxx_devlink_resource_id {\n\tMV88E6XXX_RESOURCE_ID_ATU,\n\tMV88E6XXX_RESOURCE_ID_ATU_BIN_0,\n\tMV88E6XXX_RESOURCE_ID_ATU_BIN_1,\n\tMV88E6XXX_RESOURCE_ID_ATU_BIN_2,\n\tMV88E6XXX_RESOURCE_ID_ATU_BIN_3,\n};\n\nstatic u64 mv88e6xxx_devlink_atu_bin_get(struct mv88e6xxx_chip *chip,\n\t\t\t\t\t u16 bin)\n{\n\tu16 occupancy = 0;\n\tint err;\n\n\tmv88e6xxx_reg_lock(chip);\n\n\terr = mv88e6xxx_g2_atu_stats_set(chip, MV88E6XXX_G2_ATU_STATS_MODE_ALL,\n\t\t\t\t\t bin);\n\tif (err) {\n\t\tdev_err(chip->dev, \"failed to set ATU stats kind/bin\\n\");\n\t\tgoto unlock;\n\t}\n\n\terr = mv88e6xxx_g1_atu_get_next(chip, 0);\n\tif (err) {\n\t\tdev_err(chip->dev, \"failed to perform ATU get next\\n\");\n\t\tgoto unlock;\n\t}\n\n\terr = mv88e6xxx_g2_atu_stats_get(chip, &occupancy);\n\tif (err) {\n\t\tdev_err(chip->dev, \"failed to get ATU stats\\n\");\n\t\tgoto unlock;\n\t}\n\n\toccupancy &= MV88E6XXX_G2_ATU_STATS_MASK;\n\nunlock:\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn occupancy;\n}\n\nstatic u64 mv88e6xxx_devlink_atu_bin_0_get(void *priv)\n{\n\tstruct mv88e6xxx_chip *chip = priv;\n\n\treturn mv88e6xxx_devlink_atu_bin_get(chip,\n\t\t\t\t\t     MV88E6XXX_G2_ATU_STATS_BIN_0);\n}\n\nstatic u64 mv88e6xxx_devlink_atu_bin_1_get(void *priv)\n{\n\tstruct mv88e6xxx_chip *chip = priv;\n\n\treturn mv88e6xxx_devlink_atu_bin_get(chip,\n\t\t\t\t\t     MV88E6XXX_G2_ATU_STATS_BIN_1);\n}\n\nstatic u64 mv88e6xxx_devlink_atu_bin_2_get(void *priv)\n{\n\tstruct mv88e6xxx_chip *chip = priv;\n\n\treturn mv88e6xxx_devlink_atu_bin_get(chip,\n\t\t\t\t\t     MV88E6XXX_G2_ATU_STATS_BIN_2);\n}\n\nstatic u64 mv88e6xxx_devlink_atu_bin_3_get(void *priv)\n{\n\tstruct mv88e6xxx_chip *chip = priv;\n\n\treturn mv88e6xxx_devlink_atu_bin_get(chip,\n\t\t\t\t\t     MV88E6XXX_G2_ATU_STATS_BIN_3);\n}\n\nstatic u64 mv88e6xxx_devlink_atu_get(void *priv)\n{\n\treturn mv88e6xxx_devlink_atu_bin_0_get(priv) +\n\t\tmv88e6xxx_devlink_atu_bin_1_get(priv) +\n\t\tmv88e6xxx_devlink_atu_bin_2_get(priv) +\n\t\tmv88e6xxx_devlink_atu_bin_3_get(priv);\n}\n\nint mv88e6xxx_setup_devlink_resources(struct dsa_switch *ds)\n{\n\tstruct devlink_resource_size_params size_params;\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err;\n\n\tdevlink_resource_size_params_init(&size_params,\n\t\t\t\t\t  mv88e6xxx_num_macs(chip),\n\t\t\t\t\t  mv88e6xxx_num_macs(chip),\n\t\t\t\t\t  1, DEVLINK_RESOURCE_UNIT_ENTRY);\n\n\terr = dsa_devlink_resource_register(ds, \"ATU\",\n\t\t\t\t\t    mv88e6xxx_num_macs(chip),\n\t\t\t\t\t    MV88E6XXX_RESOURCE_ID_ATU,\n\t\t\t\t\t    DEVLINK_RESOURCE_ID_PARENT_TOP,\n\t\t\t\t\t    &size_params);\n\tif (err)\n\t\tgoto out;\n\n\tdevlink_resource_size_params_init(&size_params,\n\t\t\t\t\t  mv88e6xxx_num_macs(chip) / 4,\n\t\t\t\t\t  mv88e6xxx_num_macs(chip) / 4,\n\t\t\t\t\t  1, DEVLINK_RESOURCE_UNIT_ENTRY);\n\n\terr = dsa_devlink_resource_register(ds, \"ATU_bin_0\",\n\t\t\t\t\t    mv88e6xxx_num_macs(chip) / 4,\n\t\t\t\t\t    MV88E6XXX_RESOURCE_ID_ATU_BIN_0,\n\t\t\t\t\t    MV88E6XXX_RESOURCE_ID_ATU,\n\t\t\t\t\t    &size_params);\n\tif (err)\n\t\tgoto out;\n\n\terr = dsa_devlink_resource_register(ds, \"ATU_bin_1\",\n\t\t\t\t\t    mv88e6xxx_num_macs(chip) / 4,\n\t\t\t\t\t    MV88E6XXX_RESOURCE_ID_ATU_BIN_1,\n\t\t\t\t\t    MV88E6XXX_RESOURCE_ID_ATU,\n\t\t\t\t\t    &size_params);\n\tif (err)\n\t\tgoto out;\n\n\terr = dsa_devlink_resource_register(ds, \"ATU_bin_2\",\n\t\t\t\t\t    mv88e6xxx_num_macs(chip) / 4,\n\t\t\t\t\t    MV88E6XXX_RESOURCE_ID_ATU_BIN_2,\n\t\t\t\t\t    MV88E6XXX_RESOURCE_ID_ATU,\n\t\t\t\t\t    &size_params);\n\tif (err)\n\t\tgoto out;\n\n\terr = dsa_devlink_resource_register(ds, \"ATU_bin_3\",\n\t\t\t\t\t    mv88e6xxx_num_macs(chip) / 4,\n\t\t\t\t\t    MV88E6XXX_RESOURCE_ID_ATU_BIN_3,\n\t\t\t\t\t    MV88E6XXX_RESOURCE_ID_ATU,\n\t\t\t\t\t    &size_params);\n\tif (err)\n\t\tgoto out;\n\n\tdsa_devlink_resource_occ_get_register(ds,\n\t\t\t\t\t      MV88E6XXX_RESOURCE_ID_ATU,\n\t\t\t\t\t      mv88e6xxx_devlink_atu_get,\n\t\t\t\t\t      chip);\n\n\tdsa_devlink_resource_occ_get_register(ds,\n\t\t\t\t\t      MV88E6XXX_RESOURCE_ID_ATU_BIN_0,\n\t\t\t\t\t      mv88e6xxx_devlink_atu_bin_0_get,\n\t\t\t\t\t      chip);\n\n\tdsa_devlink_resource_occ_get_register(ds,\n\t\t\t\t\t      MV88E6XXX_RESOURCE_ID_ATU_BIN_1,\n\t\t\t\t\t      mv88e6xxx_devlink_atu_bin_1_get,\n\t\t\t\t\t      chip);\n\n\tdsa_devlink_resource_occ_get_register(ds,\n\t\t\t\t\t      MV88E6XXX_RESOURCE_ID_ATU_BIN_2,\n\t\t\t\t\t      mv88e6xxx_devlink_atu_bin_2_get,\n\t\t\t\t\t      chip);\n\n\tdsa_devlink_resource_occ_get_register(ds,\n\t\t\t\t\t      MV88E6XXX_RESOURCE_ID_ATU_BIN_3,\n\t\t\t\t\t      mv88e6xxx_devlink_atu_bin_3_get,\n\t\t\t\t\t      chip);\n\n\treturn 0;\n\nout:\n\tdsa_devlink_resources_unregister(ds);\n\treturn err;\n}\n\nstatic int mv88e6xxx_region_global_snapshot(struct devlink *dl,\n\t\t\t\t\t    const struct devlink_region_ops *ops,\n\t\t\t\t\t    struct netlink_ext_ack *extack,\n\t\t\t\t\t    u8 **data)\n{\n\tstruct mv88e6xxx_region_priv *region_priv = ops->priv;\n\tstruct dsa_switch *ds = dsa_devlink_to_ds(dl);\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tu16 *registers;\n\tint i, err;\n\n\tregisters = kmalloc_array(32, sizeof(u16), GFP_KERNEL);\n\tif (!registers)\n\t\treturn -ENOMEM;\n\n\tmv88e6xxx_reg_lock(chip);\n\tfor (i = 0; i < 32; i++) {\n\t\tswitch (region_priv->id) {\n\t\tcase MV88E6XXX_REGION_GLOBAL1:\n\t\t\terr = mv88e6xxx_g1_read(chip, i, &registers[i]);\n\t\t\tbreak;\n\t\tcase MV88E6XXX_REGION_GLOBAL2:\n\t\t\terr = mv88e6xxx_g2_read(chip, i, &registers[i]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EOPNOTSUPP;\n\t\t}\n\n\t\tif (err) {\n\t\t\tkfree(registers);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t*data = (u8 *)registers;\nout:\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err;\n}\n\n \n\nstruct mv88e6xxx_devlink_atu_entry {\n\t \n\tu16 fid;\n\tu16 atu_op;\n\tu16 atu_data;\n\tu16 atu_01;\n\tu16 atu_23;\n\tu16 atu_45;\n};\n\nstatic int mv88e6xxx_region_atu_snapshot_fid(struct mv88e6xxx_chip *chip,\n\t\t\t\t\t     int fid,\n\t\t\t\t\t     struct mv88e6xxx_devlink_atu_entry *table,\n\t\t\t\t\t     int *count)\n{\n\tu16 atu_op, atu_data, atu_01, atu_23, atu_45;\n\tstruct mv88e6xxx_atu_entry addr;\n\tint err;\n\n\taddr.state = 0;\n\teth_broadcast_addr(addr.mac);\n\n\tdo {\n\t\terr = mv88e6xxx_g1_atu_getnext(chip, fid, &addr);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!addr.state)\n\t\t\tbreak;\n\n\t\terr = mv88e6xxx_g1_read(chip, MV88E6XXX_G1_ATU_OP, &atu_op);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mv88e6xxx_g1_read(chip, MV88E6XXX_G1_ATU_DATA, &atu_data);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mv88e6xxx_g1_read(chip, MV88E6XXX_G1_ATU_MAC01, &atu_01);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mv88e6xxx_g1_read(chip, MV88E6XXX_G1_ATU_MAC23, &atu_23);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mv88e6xxx_g1_read(chip, MV88E6XXX_G1_ATU_MAC45, &atu_45);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttable[*count].fid = fid;\n\t\ttable[*count].atu_op = atu_op;\n\t\ttable[*count].atu_data = atu_data;\n\t\ttable[*count].atu_01 = atu_01;\n\t\ttable[*count].atu_23 = atu_23;\n\t\ttable[*count].atu_45 = atu_45;\n\t\t(*count)++;\n\t} while (!is_broadcast_ether_addr(addr.mac));\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_region_atu_snapshot(struct devlink *dl,\n\t\t\t\t\t const struct devlink_region_ops *ops,\n\t\t\t\t\t struct netlink_ext_ack *extack,\n\t\t\t\t\t u8 **data)\n{\n\tstruct dsa_switch *ds = dsa_devlink_to_ds(dl);\n\tDECLARE_BITMAP(fid_bitmap, MV88E6XXX_N_FID);\n\tstruct mv88e6xxx_devlink_atu_entry *table;\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint fid = -1, count, err;\n\n\ttable = kmalloc_array(mv88e6xxx_num_databases(chip),\n\t\t\t      sizeof(struct mv88e6xxx_devlink_atu_entry),\n\t\t\t      GFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\tmemset(table, 0, mv88e6xxx_num_databases(chip) *\n\t       sizeof(struct mv88e6xxx_devlink_atu_entry));\n\n\tcount = 0;\n\n\tmv88e6xxx_reg_lock(chip);\n\n\terr = mv88e6xxx_fid_map(chip, fid_bitmap);\n\tif (err) {\n\t\tkfree(table);\n\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tfid = find_next_bit(fid_bitmap, MV88E6XXX_N_FID, fid + 1);\n\t\tif (fid == MV88E6XXX_N_FID)\n\t\t\tbreak;\n\n\t\terr =  mv88e6xxx_region_atu_snapshot_fid(chip, fid, table,\n\t\t\t\t\t\t\t &count);\n\t\tif (err) {\n\t\t\tkfree(table);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t*data = (u8 *)table;\nout:\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err;\n}\n\n \nstruct mv88e6xxx_devlink_vtu_entry {\n\tu16 fid;\n\tu16 sid;\n\tu16 op;\n\tu16 vid;\n\tu16 data[3];\n\tu16 resvd;\n};\n\nstatic int mv88e6xxx_region_vtu_snapshot(struct devlink *dl,\n\t\t\t\t\t const struct devlink_region_ops *ops,\n\t\t\t\t\t struct netlink_ext_ack *extack,\n\t\t\t\t\t u8 **data)\n{\n\tstruct mv88e6xxx_devlink_vtu_entry *table, *entry;\n\tstruct dsa_switch *ds = dsa_devlink_to_ds(dl);\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tstruct mv88e6xxx_vtu_entry vlan;\n\tint err;\n\n\ttable = kcalloc(mv88e6xxx_max_vid(chip) + 1,\n\t\t\tsizeof(struct mv88e6xxx_devlink_vtu_entry),\n\t\t\tGFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\tentry = table;\n\tvlan.vid = mv88e6xxx_max_vid(chip);\n\tvlan.valid = false;\n\n\tmv88e6xxx_reg_lock(chip);\n\n\tdo {\n\t\terr = mv88e6xxx_g1_vtu_getnext(chip, &vlan);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tif (!vlan.valid)\n\t\t\tbreak;\n\n\t\terr = err ? : mv88e6xxx_g1_read(chip, MV88E6352_G1_VTU_FID,\n\t\t\t\t\t\t&entry->fid);\n\t\terr = err ? : mv88e6xxx_g1_read(chip, MV88E6352_G1_VTU_SID,\n\t\t\t\t\t\t&entry->sid);\n\t\terr = err ? : mv88e6xxx_g1_read(chip, MV88E6XXX_G1_VTU_OP,\n\t\t\t\t\t\t&entry->op);\n\t\terr = err ? : mv88e6xxx_g1_read(chip, MV88E6XXX_G1_VTU_VID,\n\t\t\t\t\t\t&entry->vid);\n\t\terr = err ? : mv88e6xxx_g1_read(chip, MV88E6XXX_G1_VTU_DATA1,\n\t\t\t\t\t\t&entry->data[0]);\n\t\terr = err ? : mv88e6xxx_g1_read(chip, MV88E6XXX_G1_VTU_DATA2,\n\t\t\t\t\t\t&entry->data[1]);\n\t\terr = err ? : mv88e6xxx_g1_read(chip, MV88E6XXX_G1_VTU_DATA3,\n\t\t\t\t\t\t&entry->data[2]);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tentry++;\n\t} while (vlan.vid < mv88e6xxx_max_vid(chip));\n\n\tmv88e6xxx_reg_unlock(chip);\n\n\tif (err) {\n\t\tkfree(table);\n\t\treturn err;\n\t}\n\n\t*data = (u8 *)table;\n\treturn 0;\n}\n\n \nstruct mv88e6xxx_devlink_stu_entry {\n\tu16 sid;\n\tu16 vid;\n\tu16 data[3];\n\tu16 resvd;\n};\n\nstatic int mv88e6xxx_region_stu_snapshot(struct devlink *dl,\n\t\t\t\t\t const struct devlink_region_ops *ops,\n\t\t\t\t\t struct netlink_ext_ack *extack,\n\t\t\t\t\t u8 **data)\n{\n\tstruct mv88e6xxx_devlink_stu_entry *table, *entry;\n\tstruct dsa_switch *ds = dsa_devlink_to_ds(dl);\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tstruct mv88e6xxx_stu_entry stu;\n\tint err;\n\n\ttable = kcalloc(mv88e6xxx_max_sid(chip) + 1,\n\t\t\tsizeof(struct mv88e6xxx_devlink_stu_entry),\n\t\t\tGFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\tentry = table;\n\tstu.sid = mv88e6xxx_max_sid(chip);\n\tstu.valid = false;\n\n\tmv88e6xxx_reg_lock(chip);\n\n\tdo {\n\t\terr = mv88e6xxx_g1_stu_getnext(chip, &stu);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tif (!stu.valid)\n\t\t\tbreak;\n\n\t\terr = err ? : mv88e6xxx_g1_read(chip, MV88E6352_G1_VTU_SID,\n\t\t\t\t\t\t&entry->sid);\n\t\terr = err ? : mv88e6xxx_g1_read(chip, MV88E6XXX_G1_VTU_VID,\n\t\t\t\t\t\t&entry->vid);\n\t\terr = err ? : mv88e6xxx_g1_read(chip, MV88E6XXX_G1_VTU_DATA1,\n\t\t\t\t\t\t&entry->data[0]);\n\t\terr = err ? : mv88e6xxx_g1_read(chip, MV88E6XXX_G1_VTU_DATA2,\n\t\t\t\t\t\t&entry->data[1]);\n\t\terr = err ? : mv88e6xxx_g1_read(chip, MV88E6XXX_G1_VTU_DATA3,\n\t\t\t\t\t\t&entry->data[2]);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tentry++;\n\t} while (stu.sid < mv88e6xxx_max_sid(chip));\n\n\tmv88e6xxx_reg_unlock(chip);\n\n\tif (err) {\n\t\tkfree(table);\n\t\treturn err;\n\t}\n\n\t*data = (u8 *)table;\n\treturn 0;\n}\n\nstatic int mv88e6xxx_region_pvt_snapshot(struct devlink *dl,\n\t\t\t\t\t const struct devlink_region_ops *ops,\n\t\t\t\t\t struct netlink_ext_ack *extack,\n\t\t\t\t\t u8 **data)\n{\n\tstruct dsa_switch *ds = dsa_devlink_to_ds(dl);\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint dev, port, err;\n\tu16 *pvt, *cur;\n\n\tpvt = kcalloc(MV88E6XXX_MAX_PVT_ENTRIES, sizeof(*pvt), GFP_KERNEL);\n\tif (!pvt)\n\t\treturn -ENOMEM;\n\n\tmv88e6xxx_reg_lock(chip);\n\n\tcur = pvt;\n\tfor (dev = 0; dev < MV88E6XXX_MAX_PVT_SWITCHES; dev++) {\n\t\tfor (port = 0; port < MV88E6XXX_MAX_PVT_PORTS; port++) {\n\t\t\terr = mv88e6xxx_g2_pvt_read(chip, dev, port, cur);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\n\t\t\tcur++;\n\t\t}\n\t}\n\n\tmv88e6xxx_reg_unlock(chip);\n\n\tif (err) {\n\t\tkfree(pvt);\n\t\treturn err;\n\t}\n\n\t*data = (u8 *)pvt;\n\treturn 0;\n}\n\nstatic int mv88e6xxx_region_port_snapshot(struct devlink_port *devlink_port,\n\t\t\t\t\t  const struct devlink_port_region_ops *ops,\n\t\t\t\t\t  struct netlink_ext_ack *extack,\n\t\t\t\t\t  u8 **data)\n{\n\tstruct dsa_switch *ds = dsa_devlink_port_to_ds(devlink_port);\n\tint port = dsa_devlink_port_to_port(devlink_port);\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tu16 *registers;\n\tint i, err;\n\n\tregisters = kmalloc_array(32, sizeof(u16), GFP_KERNEL);\n\tif (!registers)\n\t\treturn -ENOMEM;\n\n\tmv88e6xxx_reg_lock(chip);\n\tfor (i = 0; i < 32; i++) {\n\t\terr = mv88e6xxx_port_read(chip, port, i, &registers[i]);\n\t\tif (err) {\n\t\t\tkfree(registers);\n\t\t\tgoto out;\n\t\t}\n\t}\n\t*data = (u8 *)registers;\nout:\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err;\n}\n\nstatic struct mv88e6xxx_region_priv mv88e6xxx_region_global1_priv = {\n\t.id = MV88E6XXX_REGION_GLOBAL1,\n};\n\nstatic struct devlink_region_ops mv88e6xxx_region_global1_ops = {\n\t.name = \"global1\",\n\t.snapshot = mv88e6xxx_region_global_snapshot,\n\t.destructor = kfree,\n\t.priv = &mv88e6xxx_region_global1_priv,\n};\n\nstatic struct mv88e6xxx_region_priv mv88e6xxx_region_global2_priv = {\n\t.id = MV88E6XXX_REGION_GLOBAL2,\n};\n\nstatic struct devlink_region_ops mv88e6xxx_region_global2_ops = {\n\t.name = \"global2\",\n\t.snapshot = mv88e6xxx_region_global_snapshot,\n\t.destructor = kfree,\n\t.priv = &mv88e6xxx_region_global2_priv,\n};\n\nstatic struct devlink_region_ops mv88e6xxx_region_atu_ops = {\n\t.name = \"atu\",\n\t.snapshot = mv88e6xxx_region_atu_snapshot,\n\t.destructor = kfree,\n};\n\nstatic struct devlink_region_ops mv88e6xxx_region_vtu_ops = {\n\t.name = \"vtu\",\n\t.snapshot = mv88e6xxx_region_vtu_snapshot,\n\t.destructor = kfree,\n};\n\nstatic struct devlink_region_ops mv88e6xxx_region_stu_ops = {\n\t.name = \"stu\",\n\t.snapshot = mv88e6xxx_region_stu_snapshot,\n\t.destructor = kfree,\n};\n\nstatic struct devlink_region_ops mv88e6xxx_region_pvt_ops = {\n\t.name = \"pvt\",\n\t.snapshot = mv88e6xxx_region_pvt_snapshot,\n\t.destructor = kfree,\n};\n\nstatic const struct devlink_port_region_ops mv88e6xxx_region_port_ops = {\n\t.name = \"port\",\n\t.snapshot = mv88e6xxx_region_port_snapshot,\n\t.destructor = kfree,\n};\n\nstruct mv88e6xxx_region {\n\tstruct devlink_region_ops *ops;\n\tu64 size;\n\n\tbool (*cond)(struct mv88e6xxx_chip *chip);\n};\n\nstatic struct mv88e6xxx_region mv88e6xxx_regions[] = {\n\t[MV88E6XXX_REGION_GLOBAL1] = {\n\t\t.ops = &mv88e6xxx_region_global1_ops,\n\t\t.size = 32 * sizeof(u16)\n\t},\n\t[MV88E6XXX_REGION_GLOBAL2] = {\n\t\t.ops = &mv88e6xxx_region_global2_ops,\n\t\t.size = 32 * sizeof(u16) },\n\t[MV88E6XXX_REGION_ATU] = {\n\t\t.ops = &mv88e6xxx_region_atu_ops\n\t   \n\t},\n\t[MV88E6XXX_REGION_VTU] = {\n\t\t.ops = &mv88e6xxx_region_vtu_ops\n\t   \n\t},\n\t[MV88E6XXX_REGION_STU] = {\n\t\t.ops = &mv88e6xxx_region_stu_ops,\n\t\t.cond = mv88e6xxx_has_stu,\n\t   \n\t},\n\t[MV88E6XXX_REGION_PVT] = {\n\t\t.ops = &mv88e6xxx_region_pvt_ops,\n\t\t.size = MV88E6XXX_MAX_PVT_ENTRIES * sizeof(u16),\n\t\t.cond = mv88e6xxx_has_pvt,\n\t},\n};\n\nvoid mv88e6xxx_teardown_devlink_regions_global(struct dsa_switch *ds)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mv88e6xxx_regions); i++)\n\t\tdsa_devlink_region_destroy(chip->regions[i]);\n}\n\nvoid mv88e6xxx_teardown_devlink_regions_port(struct dsa_switch *ds, int port)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\n\tdsa_devlink_region_destroy(chip->ports[port].region);\n}\n\nint mv88e6xxx_setup_devlink_regions_port(struct dsa_switch *ds, int port)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tstruct devlink_region *region;\n\n\tregion = dsa_devlink_port_region_create(ds,\n\t\t\t\t\t\tport,\n\t\t\t\t\t\t&mv88e6xxx_region_port_ops, 1,\n\t\t\t\t\t\t32 * sizeof(u16));\n\tif (IS_ERR(region))\n\t\treturn PTR_ERR(region);\n\n\tchip->ports[port].region = region;\n\n\treturn 0;\n}\n\nint mv88e6xxx_setup_devlink_regions_global(struct dsa_switch *ds)\n{\n\tbool (*cond)(struct mv88e6xxx_chip *chip);\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tstruct devlink_region_ops *ops;\n\tstruct devlink_region *region;\n\tu64 size;\n\tint i, j;\n\n\tfor (i = 0; i < ARRAY_SIZE(mv88e6xxx_regions); i++) {\n\t\tops = mv88e6xxx_regions[i].ops;\n\t\tsize = mv88e6xxx_regions[i].size;\n\t\tcond = mv88e6xxx_regions[i].cond;\n\n\t\tif (cond && !cond(chip))\n\t\t\tcontinue;\n\n\t\tswitch (i) {\n\t\tcase MV88E6XXX_REGION_ATU:\n\t\t\tsize = mv88e6xxx_num_databases(chip) *\n\t\t\t\tsizeof(struct mv88e6xxx_devlink_atu_entry);\n\t\t\tbreak;\n\t\tcase MV88E6XXX_REGION_VTU:\n\t\t\tsize = (mv88e6xxx_max_vid(chip) + 1) *\n\t\t\t\tsizeof(struct mv88e6xxx_devlink_vtu_entry);\n\t\t\tbreak;\n\t\tcase MV88E6XXX_REGION_STU:\n\t\t\tsize = (mv88e6xxx_max_sid(chip) + 1) *\n\t\t\t\tsizeof(struct mv88e6xxx_devlink_stu_entry);\n\t\t\tbreak;\n\t\t}\n\n\t\tregion = dsa_devlink_region_create(ds, ops, 1, size);\n\t\tif (IS_ERR(region))\n\t\t\tgoto out;\n\t\tchip->regions[i] = region;\n\t}\n\treturn 0;\n\nout:\n\tfor (j = 0; j < i; j++)\n\t\tdsa_devlink_region_destroy(chip->regions[j]);\n\n\treturn PTR_ERR(region);\n}\n\nint mv88e6xxx_devlink_info_get(struct dsa_switch *ds,\n\t\t\t       struct devlink_info_req *req,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\n\treturn devlink_info_version_fixed_put(req,\n\t\t\t\t\t      DEVLINK_INFO_VERSION_GENERIC_ASIC_ID,\n\t\t\t\t\t      chip->info->name);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}