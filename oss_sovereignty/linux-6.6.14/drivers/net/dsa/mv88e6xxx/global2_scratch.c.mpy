{
  "module_name": "global2_scratch.c",
  "hash_id": "f2d663fcb26bc04bfd8ac9e91c02e7536548aa73ffef531ceceb002bd1c80f68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/mv88e6xxx/global2_scratch.c",
  "human_readable_source": "\n \n\n#include \"chip.h\"\n#include \"global2.h\"\n\n \nstatic int mv88e6xxx_g2_scratch_read(struct mv88e6xxx_chip *chip, int reg,\n\t\t\t\t     u8 *data)\n{\n\tu16 value;\n\tint err;\n\n\terr = mv88e6xxx_g2_write(chip, MV88E6XXX_G2_SCRATCH_MISC_MISC,\n\t\t\t\t reg << 8);\n\tif (err)\n\t\treturn err;\n\n\terr = mv88e6xxx_g2_read(chip, MV88E6XXX_G2_SCRATCH_MISC_MISC, &value);\n\tif (err)\n\t\treturn err;\n\n\t*data = (value & MV88E6XXX_G2_SCRATCH_MISC_DATA_MASK);\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_g2_scratch_write(struct mv88e6xxx_chip *chip, int reg,\n\t\t\t\t      u8 data)\n{\n\tu16 value = (reg << 8) | data;\n\n\treturn mv88e6xxx_g2_write(chip, MV88E6XXX_G2_SCRATCH_MISC_MISC,\n\t\t\t\t  MV88E6XXX_G2_SCRATCH_MISC_UPDATE | value);\n}\n\n \nstatic int mv88e6xxx_g2_scratch_get_bit(struct mv88e6xxx_chip *chip,\n\t\t\t\t\tint base_reg, unsigned int offset,\n\t\t\t\t\tint *set)\n{\n\tint reg = base_reg + (offset / 8);\n\tu8 mask = (1 << (offset & 0x7));\n\tu8 val;\n\tint err;\n\n\terr = mv88e6xxx_g2_scratch_read(chip, reg, &val);\n\tif (err)\n\t\treturn err;\n\n\t*set = !!(mask & val);\n\n\treturn 0;\n}\n\n \nstatic int mv88e6xxx_g2_scratch_set_bit(struct mv88e6xxx_chip *chip,\n\t\t\t\t\tint base_reg, unsigned int offset,\n\t\t\t\t\tint set)\n{\n\tint reg = base_reg + (offset / 8);\n\tu8 mask = (1 << (offset & 0x7));\n\tu8 val;\n\tint err;\n\n\terr = mv88e6xxx_g2_scratch_read(chip, reg, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (set)\n\t\tval |= mask;\n\telse\n\t\tval &= ~mask;\n\n\treturn mv88e6xxx_g2_scratch_write(chip, reg, val);\n}\n\n \nstatic int mv88e6352_g2_scratch_gpio_get_data(struct mv88e6xxx_chip *chip,\n\t\t\t\t\t      unsigned int pin)\n{\n\tint val = 0;\n\tint err;\n\n\terr = mv88e6xxx_g2_scratch_get_bit(chip,\n\t\t\t\t\t   MV88E6352_G2_SCRATCH_GPIO_DATA0,\n\t\t\t\t\t   pin, &val);\n\tif (err)\n\t\treturn err;\n\n\treturn val;\n}\n\n \nstatic int mv88e6352_g2_scratch_gpio_set_data(struct mv88e6xxx_chip *chip,\n\t\t\t\t\t      unsigned int pin, int value)\n{\n\tu8 mask = (1 << (pin & 0x7));\n\tint offset = (pin / 8);\n\tint reg;\n\n\treg = MV88E6352_G2_SCRATCH_GPIO_DATA0 + offset;\n\n\tif (value)\n\t\tchip->gpio_data[offset] |= mask;\n\telse\n\t\tchip->gpio_data[offset] &= ~mask;\n\n\treturn mv88e6xxx_g2_scratch_write(chip, reg, chip->gpio_data[offset]);\n}\n\n \nstatic int mv88e6352_g2_scratch_gpio_get_dir(struct mv88e6xxx_chip *chip,\n\t\t\t\t\t     unsigned int pin)\n{\n\tint val = 0;\n\tint err;\n\n\terr = mv88e6xxx_g2_scratch_get_bit(chip,\n\t\t\t\t\t   MV88E6352_G2_SCRATCH_GPIO_DIR0,\n\t\t\t\t\t   pin, &val);\n\tif (err)\n\t\treturn err;\n\n\treturn val;\n}\n\n \nstatic int mv88e6352_g2_scratch_gpio_set_dir(struct mv88e6xxx_chip *chip,\n\t\t\t\t\t     unsigned int pin, bool input)\n{\n\tint value = (input ? MV88E6352_G2_SCRATCH_GPIO_DIR_IN :\n\t\t\t     MV88E6352_G2_SCRATCH_GPIO_DIR_OUT);\n\n\treturn mv88e6xxx_g2_scratch_set_bit(chip,\n\t\t\t\t\t    MV88E6352_G2_SCRATCH_GPIO_DIR0,\n\t\t\t\t\t    pin, value);\n}\n\n \nstatic int mv88e6352_g2_scratch_gpio_get_pctl(struct mv88e6xxx_chip *chip,\n\t\t\t\t\t      unsigned int pin, int *func)\n{\n\tint reg = MV88E6352_G2_SCRATCH_GPIO_PCTL0 + (pin / 2);\n\tint offset = (pin & 0x1) ? 4 : 0;\n\tu8 mask = (0x7 << offset);\n\tint err;\n\tu8 val;\n\n\terr = mv88e6xxx_g2_scratch_read(chip, reg, &val);\n\tif (err)\n\t\treturn err;\n\n\t*func = (val & mask) >> offset;\n\n\treturn 0;\n}\n\n \nstatic int mv88e6352_g2_scratch_gpio_set_pctl(struct mv88e6xxx_chip *chip,\n\t\t\t\t\t      unsigned int pin, int func)\n{\n\tint reg = MV88E6352_G2_SCRATCH_GPIO_PCTL0 + (pin / 2);\n\tint offset = (pin & 0x1) ? 4 : 0;\n\tu8 mask = (0x7 << offset);\n\tint err;\n\tu8 val;\n\n\terr = mv88e6xxx_g2_scratch_read(chip, reg, &val);\n\tif (err)\n\t\treturn err;\n\n\tval = (val & ~mask) | ((func & mask) << offset);\n\n\treturn mv88e6xxx_g2_scratch_write(chip, reg, val);\n}\n\nconst struct mv88e6xxx_gpio_ops mv88e6352_gpio_ops = {\n\t.get_data = mv88e6352_g2_scratch_gpio_get_data,\n\t.set_data = mv88e6352_g2_scratch_gpio_set_data,\n\t.get_dir = mv88e6352_g2_scratch_gpio_get_dir,\n\t.set_dir = mv88e6352_g2_scratch_gpio_set_dir,\n\t.get_pctl = mv88e6352_g2_scratch_gpio_get_pctl,\n\t.set_pctl = mv88e6352_g2_scratch_gpio_set_pctl,\n};\n\n \nint mv88e6xxx_g2_scratch_gpio_set_smi(struct mv88e6xxx_chip *chip,\n\t\t\t\t      bool external)\n{\n\tint misc_cfg = MV88E6352_G2_SCRATCH_MISC_CFG;\n\tint config_data1 = MV88E6352_G2_SCRATCH_CONFIG_DATA1;\n\tint config_data2 = MV88E6352_G2_SCRATCH_CONFIG_DATA2;\n\tbool no_cpu;\n\tu8 p0_mode;\n\tint err;\n\tu8 val;\n\n\terr = mv88e6xxx_g2_scratch_read(chip, config_data2, &val);\n\tif (err)\n\t\treturn err;\n\n\tp0_mode = val & MV88E6352_G2_SCRATCH_CONFIG_DATA2_P0_MODE_MASK;\n\n\tif (p0_mode == 0x01 || p0_mode == 0x02)\n\t\treturn -EBUSY;\n\n\terr = mv88e6xxx_g2_scratch_read(chip, config_data1, &val);\n\tif (err)\n\t\treturn err;\n\n\tno_cpu = !!(val & MV88E6352_G2_SCRATCH_CONFIG_DATA1_NO_CPU);\n\n\terr = mv88e6xxx_g2_scratch_read(chip, misc_cfg, &val);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!no_cpu)\n\t\texternal = !external;\n\n\tif (external)\n\t\tval |= MV88E6352_G2_SCRATCH_MISC_CFG_NORMALSMI;\n\telse\n\t\tval &= ~MV88E6352_G2_SCRATCH_MISC_CFG_NORMALSMI;\n\n\treturn mv88e6xxx_g2_scratch_write(chip, misc_cfg, val);\n}\n\n \nint mv88e6352_g2_scratch_port_has_serdes(struct mv88e6xxx_chip *chip, int port)\n{\n\tu8 config3, p;\n\tint err;\n\n\terr = mv88e6xxx_g2_scratch_read(chip, MV88E6352_G2_SCRATCH_CONFIG_DATA3,\n\t\t\t\t\t&config3);\n\tif (err)\n\t\treturn err;\n\n\tif (config3 & MV88E6352_G2_SCRATCH_CONFIG_DATA3_S_SEL)\n\t\tp = 5;\n\telse\n\t\tp = 4;\n\n\treturn port == p;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}