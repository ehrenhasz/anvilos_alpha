{
  "module_name": "global1_atu.c",
  "hash_id": "5917de1295b0f34b06beacc655dbc4d56efcc674b0f8cef3cf6fbcc90df96d98",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/mv88e6xxx/global1_atu.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/interrupt.h>\n#include <linux/irqdomain.h>\n\n#include \"chip.h\"\n#include \"global1.h\"\n#include \"switchdev.h\"\n#include \"trace.h\"\n\n \n\nstatic int mv88e6xxx_g1_atu_fid_write(struct mv88e6xxx_chip *chip, u16 fid)\n{\n\treturn mv88e6xxx_g1_write(chip, MV88E6352_G1_ATU_FID, fid & 0xfff);\n}\n\n \n\nint mv88e6xxx_g1_atu_set_learn2all(struct mv88e6xxx_chip *chip, bool learn2all)\n{\n\tu16 val;\n\tint err;\n\n\terr = mv88e6xxx_g1_read(chip, MV88E6XXX_G1_ATU_CTL, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (learn2all)\n\t\tval |= MV88E6XXX_G1_ATU_CTL_LEARN2ALL;\n\telse\n\t\tval &= ~MV88E6XXX_G1_ATU_CTL_LEARN2ALL;\n\n\treturn mv88e6xxx_g1_write(chip, MV88E6XXX_G1_ATU_CTL, val);\n}\n\nint mv88e6xxx_g1_atu_set_age_time(struct mv88e6xxx_chip *chip,\n\t\t\t\t  unsigned int msecs)\n{\n\tconst unsigned int coeff = chip->info->age_time_coeff;\n\tconst unsigned int min = 0x01 * coeff;\n\tconst unsigned int max = 0xff * coeff;\n\tu8 age_time;\n\tu16 val;\n\tint err;\n\n\tif (msecs < min || msecs > max)\n\t\treturn -ERANGE;\n\n\t \n\tage_time = (msecs + coeff / 2) / coeff;\n\n\terr = mv88e6xxx_g1_read(chip, MV88E6XXX_G1_ATU_CTL, &val);\n\tif (err)\n\t\treturn err;\n\n\t \n\tval &= ~0xff0;\n\tval |= age_time << 4;\n\n\terr = mv88e6xxx_g1_write(chip, MV88E6XXX_G1_ATU_CTL, val);\n\tif (err)\n\t\treturn err;\n\n\tdev_dbg(chip->dev, \"AgeTime set to 0x%02x (%d ms)\\n\", age_time,\n\t\tage_time * coeff);\n\n\treturn 0;\n}\n\nint mv88e6165_g1_atu_get_hash(struct mv88e6xxx_chip *chip, u8 *hash)\n{\n\tint err;\n\tu16 val;\n\n\terr = mv88e6xxx_g1_read(chip, MV88E6XXX_G1_ATU_CTL, &val);\n\tif (err)\n\t\treturn err;\n\n\t*hash = val & MV88E6161_G1_ATU_CTL_HASH_MASK;\n\n\treturn 0;\n}\n\nint mv88e6165_g1_atu_set_hash(struct mv88e6xxx_chip *chip, u8 hash)\n{\n\tint err;\n\tu16 val;\n\n\tif (hash & ~MV88E6161_G1_ATU_CTL_HASH_MASK)\n\t\treturn -EINVAL;\n\n\terr = mv88e6xxx_g1_read(chip, MV88E6XXX_G1_ATU_CTL, &val);\n\tif (err)\n\t\treturn err;\n\n\tval &= ~MV88E6161_G1_ATU_CTL_HASH_MASK;\n\tval |= hash;\n\n\treturn mv88e6xxx_g1_write(chip, MV88E6XXX_G1_ATU_CTL, val);\n}\n\n \n\nstatic int mv88e6xxx_g1_atu_op_wait(struct mv88e6xxx_chip *chip)\n{\n\tint bit = __bf_shf(MV88E6XXX_G1_ATU_OP_BUSY);\n\n\treturn mv88e6xxx_g1_wait_bit(chip, MV88E6XXX_G1_ATU_OP, bit, 0);\n}\n\nstatic int mv88e6xxx_g1_read_atu_violation(struct mv88e6xxx_chip *chip)\n{\n\tint err;\n\n\terr = mv88e6xxx_g1_write(chip, MV88E6XXX_G1_ATU_OP,\n\t\t\t\t MV88E6XXX_G1_ATU_OP_BUSY |\n\t\t\t\t MV88E6XXX_G1_ATU_OP_GET_CLR_VIOLATION);\n\tif (err)\n\t\treturn err;\n\n\treturn mv88e6xxx_g1_atu_op_wait(chip);\n}\n\nstatic int mv88e6xxx_g1_atu_op(struct mv88e6xxx_chip *chip, u16 fid, u16 op)\n{\n\tu16 val;\n\tint err;\n\n\t \n\tif (mv88e6xxx_num_databases(chip) > 256) {\n\t\terr = mv88e6xxx_g1_atu_fid_write(chip, fid);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tif (mv88e6xxx_num_databases(chip) > 64) {\n\t\t\t \n\t\t\terr = mv88e6xxx_g1_read(chip, MV88E6XXX_G1_ATU_CTL,\n\t\t\t\t\t\t&val);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tval = (val & 0x0fff) | ((fid << 8) & 0xf000);\n\t\t\terr = mv88e6xxx_g1_write(chip, MV88E6XXX_G1_ATU_CTL,\n\t\t\t\t\t\t val);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else if (mv88e6xxx_num_databases(chip) > 16) {\n\t\t\t \n\t\t\top |= (fid & 0x30) << 4;\n\t\t}\n\n\t\t \n\t\top |= fid & 0xf;\n\t}\n\n\terr = mv88e6xxx_g1_write(chip, MV88E6XXX_G1_ATU_OP,\n\t\t\t\t MV88E6XXX_G1_ATU_OP_BUSY | op);\n\tif (err)\n\t\treturn err;\n\n\treturn mv88e6xxx_g1_atu_op_wait(chip);\n}\n\nint mv88e6xxx_g1_atu_get_next(struct mv88e6xxx_chip *chip, u16 fid)\n{\n\treturn mv88e6xxx_g1_atu_op(chip, fid, MV88E6XXX_G1_ATU_OP_GET_NEXT_DB);\n}\n\nstatic int mv88e6xxx_g1_atu_fid_read(struct mv88e6xxx_chip *chip, u16 *fid)\n{\n\tu16 val = 0, upper = 0, op = 0;\n\tint err = -EOPNOTSUPP;\n\n\tif (mv88e6xxx_num_databases(chip) > 256) {\n\t\terr = mv88e6xxx_g1_read(chip, MV88E6352_G1_ATU_FID, &val);\n\t\tval &= 0xfff;\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\terr = mv88e6xxx_g1_read(chip, MV88E6XXX_G1_ATU_OP, &op);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (mv88e6xxx_num_databases(chip) > 64) {\n\t\t\t \n\t\t\terr = mv88e6xxx_g1_read(chip, MV88E6XXX_G1_ATU_CTL,\n\t\t\t\t\t\t&upper);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tupper = (upper >> 8) & 0x00f0;\n\t\t} else if (mv88e6xxx_num_databases(chip) > 16) {\n\t\t\t \n\t\t\tupper = (op >> 4) & 0x30;\n\t\t}\n\n\t\t \n\t\tval = (op & 0xf) | upper;\n\t}\n\t*fid = val;\n\n\treturn err;\n}\n\n \n\nstatic int mv88e6xxx_g1_atu_data_read(struct mv88e6xxx_chip *chip,\n\t\t\t\t      struct mv88e6xxx_atu_entry *entry)\n{\n\tu16 val;\n\tint err;\n\n\terr = mv88e6xxx_g1_read(chip, MV88E6XXX_G1_ATU_DATA, &val);\n\tif (err)\n\t\treturn err;\n\n\tentry->state = val & 0xf;\n\tif (entry->state) {\n\t\tentry->trunk = !!(val & MV88E6XXX_G1_ATU_DATA_TRUNK);\n\t\tentry->portvec = (val >> 4) & mv88e6xxx_port_mask(chip);\n\t}\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_g1_atu_data_write(struct mv88e6xxx_chip *chip,\n\t\t\t\t       struct mv88e6xxx_atu_entry *entry)\n{\n\tu16 data = entry->state & 0xf;\n\n\tif (entry->state) {\n\t\tif (entry->trunk)\n\t\t\tdata |= MV88E6XXX_G1_ATU_DATA_TRUNK;\n\n\t\tdata |= (entry->portvec & mv88e6xxx_port_mask(chip)) << 4;\n\t}\n\n\treturn mv88e6xxx_g1_write(chip, MV88E6XXX_G1_ATU_DATA, data);\n}\n\n \n\nstatic int mv88e6xxx_g1_atu_mac_read(struct mv88e6xxx_chip *chip,\n\t\t\t\t     struct mv88e6xxx_atu_entry *entry)\n{\n\tu16 val;\n\tint i, err;\n\n\tfor (i = 0; i < 3; i++) {\n\t\terr = mv88e6xxx_g1_read(chip, MV88E6XXX_G1_ATU_MAC01 + i, &val);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tentry->mac[i * 2] = val >> 8;\n\t\tentry->mac[i * 2 + 1] = val & 0xff;\n\t}\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_g1_atu_mac_write(struct mv88e6xxx_chip *chip,\n\t\t\t\t      struct mv88e6xxx_atu_entry *entry)\n{\n\tu16 val;\n\tint i, err;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tval = (entry->mac[i * 2] << 8) | entry->mac[i * 2 + 1];\n\t\terr = mv88e6xxx_g1_write(chip, MV88E6XXX_G1_ATU_MAC01 + i, val);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \n\nint mv88e6xxx_g1_atu_getnext(struct mv88e6xxx_chip *chip, u16 fid,\n\t\t\t     struct mv88e6xxx_atu_entry *entry)\n{\n\tint err;\n\n\terr = mv88e6xxx_g1_atu_op_wait(chip);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!entry->state) {\n\t\terr = mv88e6xxx_g1_atu_mac_write(chip, entry);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = mv88e6xxx_g1_atu_op(chip, fid, MV88E6XXX_G1_ATU_OP_GET_NEXT_DB);\n\tif (err)\n\t\treturn err;\n\n\terr = mv88e6xxx_g1_atu_data_read(chip, entry);\n\tif (err)\n\t\treturn err;\n\n\treturn mv88e6xxx_g1_atu_mac_read(chip, entry);\n}\n\nint mv88e6xxx_g1_atu_loadpurge(struct mv88e6xxx_chip *chip, u16 fid,\n\t\t\t       struct mv88e6xxx_atu_entry *entry)\n{\n\tint err;\n\n\terr = mv88e6xxx_g1_atu_op_wait(chip);\n\tif (err)\n\t\treturn err;\n\n\terr = mv88e6xxx_g1_atu_mac_write(chip, entry);\n\tif (err)\n\t\treturn err;\n\n\terr = mv88e6xxx_g1_atu_data_write(chip, entry);\n\tif (err)\n\t\treturn err;\n\n\treturn mv88e6xxx_g1_atu_op(chip, fid, MV88E6XXX_G1_ATU_OP_LOAD_DB);\n}\n\nstatic int mv88e6xxx_g1_atu_flushmove(struct mv88e6xxx_chip *chip, u16 fid,\n\t\t\t\t      struct mv88e6xxx_atu_entry *entry,\n\t\t\t\t      bool all)\n{\n\tu16 op;\n\tint err;\n\n\terr = mv88e6xxx_g1_atu_op_wait(chip);\n\tif (err)\n\t\treturn err;\n\n\terr = mv88e6xxx_g1_atu_data_write(chip, entry);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (all && fid)\n\t\top = MV88E6XXX_G1_ATU_OP_FLUSH_MOVE_ALL_DB;\n\telse if (fid)\n\t\top = MV88E6XXX_G1_ATU_OP_FLUSH_MOVE_NON_STATIC_DB;\n\telse if (all)\n\t\top = MV88E6XXX_G1_ATU_OP_FLUSH_MOVE_ALL;\n\telse\n\t\top = MV88E6XXX_G1_ATU_OP_FLUSH_MOVE_NON_STATIC;\n\n\treturn mv88e6xxx_g1_atu_op(chip, fid, op);\n}\n\nint mv88e6xxx_g1_atu_flush(struct mv88e6xxx_chip *chip, u16 fid, bool all)\n{\n\tstruct mv88e6xxx_atu_entry entry = {\n\t\t.state = 0,  \n\t};\n\n\treturn mv88e6xxx_g1_atu_flushmove(chip, fid, &entry, all);\n}\n\nstatic int mv88e6xxx_g1_atu_move(struct mv88e6xxx_chip *chip, u16 fid,\n\t\t\t\t int from_port, int to_port, bool all)\n{\n\tstruct mv88e6xxx_atu_entry entry = { 0 };\n\tunsigned long mask;\n\tint shift;\n\n\tif (!chip->info->atu_move_port_mask)\n\t\treturn -EOPNOTSUPP;\n\n\tmask = chip->info->atu_move_port_mask;\n\tshift = bitmap_weight(&mask, 16);\n\n\tentry.state = 0xf;  \n\tentry.portvec = from_port & mask;\n\tentry.portvec |= (to_port & mask) << shift;\n\n\treturn mv88e6xxx_g1_atu_flushmove(chip, fid, &entry, all);\n}\n\nint mv88e6xxx_g1_atu_remove(struct mv88e6xxx_chip *chip, u16 fid, int port,\n\t\t\t    bool all)\n{\n\tint from_port = port;\n\tint to_port = chip->info->atu_move_port_mask;\n\n\treturn mv88e6xxx_g1_atu_move(chip, fid, from_port, to_port, all);\n}\n\nstatic irqreturn_t mv88e6xxx_g1_atu_prob_irq_thread_fn(int irq, void *dev_id)\n{\n\tstruct mv88e6xxx_chip *chip = dev_id;\n\tstruct mv88e6xxx_atu_entry entry;\n\tint err, spid;\n\tu16 val, fid;\n\n\tmv88e6xxx_reg_lock(chip);\n\n\terr = mv88e6xxx_g1_read_atu_violation(chip);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = mv88e6xxx_g1_read(chip, MV88E6XXX_G1_ATU_OP, &val);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = mv88e6xxx_g1_atu_fid_read(chip, &fid);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = mv88e6xxx_g1_atu_data_read(chip, &entry);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = mv88e6xxx_g1_atu_mac_read(chip, &entry);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tmv88e6xxx_reg_unlock(chip);\n\n\tspid = entry.state;\n\n\tif (val & MV88E6XXX_G1_ATU_OP_MEMBER_VIOLATION) {\n\t\ttrace_mv88e6xxx_atu_member_violation(chip->dev, spid,\n\t\t\t\t\t\t     entry.portvec, entry.mac,\n\t\t\t\t\t\t     fid);\n\t\tchip->ports[spid].atu_member_violation++;\n\t}\n\n\tif (val & MV88E6XXX_G1_ATU_OP_MISS_VIOLATION) {\n\t\ttrace_mv88e6xxx_atu_miss_violation(chip->dev, spid,\n\t\t\t\t\t\t   entry.portvec, entry.mac,\n\t\t\t\t\t\t   fid);\n\t\tchip->ports[spid].atu_miss_violation++;\n\n\t\tif (fid != MV88E6XXX_FID_STANDALONE && chip->ports[spid].mab) {\n\t\t\terr = mv88e6xxx_handle_miss_violation(chip, spid,\n\t\t\t\t\t\t\t      &entry, fid);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (val & MV88E6XXX_G1_ATU_OP_FULL_VIOLATION) {\n\t\ttrace_mv88e6xxx_atu_full_violation(chip->dev, spid,\n\t\t\t\t\t\t   entry.portvec, entry.mac,\n\t\t\t\t\t\t   fid);\n\t\tchip->ports[spid].atu_full_violation++;\n\t}\n\n\treturn IRQ_HANDLED;\n\nout_unlock:\n\tmv88e6xxx_reg_unlock(chip);\n\nout:\n\tdev_err(chip->dev, \"ATU problem: error %d while handling interrupt\\n\",\n\t\terr);\n\treturn IRQ_HANDLED;\n}\n\nint mv88e6xxx_g1_atu_prob_irq_setup(struct mv88e6xxx_chip *chip)\n{\n\tint err;\n\n\tchip->atu_prob_irq = irq_find_mapping(chip->g1_irq.domain,\n\t\t\t\t\t      MV88E6XXX_G1_STS_IRQ_ATU_PROB);\n\tif (chip->atu_prob_irq < 0)\n\t\treturn chip->atu_prob_irq;\n\n\tsnprintf(chip->atu_prob_irq_name, sizeof(chip->atu_prob_irq_name),\n\t\t \"mv88e6xxx-%s-g1-atu-prob\", dev_name(chip->dev));\n\n\terr = request_threaded_irq(chip->atu_prob_irq, NULL,\n\t\t\t\t   mv88e6xxx_g1_atu_prob_irq_thread_fn,\n\t\t\t\t   IRQF_ONESHOT, chip->atu_prob_irq_name,\n\t\t\t\t   chip);\n\tif (err)\n\t\tirq_dispose_mapping(chip->atu_prob_irq);\n\n\treturn err;\n}\n\nvoid mv88e6xxx_g1_atu_prob_irq_free(struct mv88e6xxx_chip *chip)\n{\n\tfree_irq(chip->atu_prob_irq, chip);\n\tirq_dispose_mapping(chip->atu_prob_irq);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}