{
  "module_name": "hwtstamp.c",
  "hash_id": "05c5d1189d5b7548bb72e9bb2234deb6b980845cd48e4af52850a226b5b23be0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/mv88e6xxx/hwtstamp.c",
  "human_readable_source": "\n \n\n#include \"chip.h\"\n#include \"global2.h\"\n#include \"hwtstamp.h\"\n#include \"ptp.h\"\n#include <linux/ptp_classify.h>\n\n#define SKB_PTP_TYPE(__skb) (*(unsigned int *)((__skb)->cb))\n\nstatic int mv88e6xxx_port_ptp_read(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t   int addr, u16 *data, int len)\n{\n\tif (!chip->info->ops->avb_ops->port_ptp_read)\n\t\treturn -EOPNOTSUPP;\n\n\treturn chip->info->ops->avb_ops->port_ptp_read(chip, port, addr,\n\t\t\t\t\t\t       data, len);\n}\n\nstatic int mv88e6xxx_port_ptp_write(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t    int addr, u16 data)\n{\n\tif (!chip->info->ops->avb_ops->port_ptp_write)\n\t\treturn -EOPNOTSUPP;\n\n\treturn chip->info->ops->avb_ops->port_ptp_write(chip, port, addr,\n\t\t\t\t\t\t\tdata);\n}\n\nstatic int mv88e6xxx_ptp_write(struct mv88e6xxx_chip *chip, int addr,\n\t\t\t       u16 data)\n{\n\tif (!chip->info->ops->avb_ops->ptp_write)\n\t\treturn -EOPNOTSUPP;\n\n\treturn chip->info->ops->avb_ops->ptp_write(chip, addr, data);\n}\n\nstatic int mv88e6xxx_ptp_read(struct mv88e6xxx_chip *chip, int addr,\n\t\t\t      u16 *data)\n{\n\tif (!chip->info->ops->avb_ops->ptp_read)\n\t\treturn -EOPNOTSUPP;\n\n\treturn chip->info->ops->avb_ops->ptp_read(chip, addr, data, 1);\n}\n\n \n#define TX_TSTAMP_TIMEOUT\tmsecs_to_jiffies(40)\n\nint mv88e6xxx_get_ts_info(struct dsa_switch *ds, int port,\n\t\t\t  struct ethtool_ts_info *info)\n{\n\tconst struct mv88e6xxx_ptp_ops *ptp_ops;\n\tstruct mv88e6xxx_chip *chip;\n\n\tchip = ds->priv;\n\tptp_ops = chip->info->ops->ptp_ops;\n\n\tif (!chip->info->ptp_support)\n\t\treturn -EOPNOTSUPP;\n\n\tinfo->so_timestamping =\n\t\tSOF_TIMESTAMPING_TX_HARDWARE |\n\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\tinfo->phc_index = ptp_clock_index(chip->ptp_clock);\n\tinfo->tx_types =\n\t\t(1 << HWTSTAMP_TX_OFF) |\n\t\t(1 << HWTSTAMP_TX_ON);\n\tinfo->rx_filters = ptp_ops->rx_filters;\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_set_hwtstamp_config(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t\t struct hwtstamp_config *config)\n{\n\tconst struct mv88e6xxx_ptp_ops *ptp_ops = chip->info->ops->ptp_ops;\n\tstruct mv88e6xxx_port_hwtstamp *ps = &chip->port_hwtstamp[port];\n\tbool tstamp_enable = false;\n\n\t \n\tclear_bit_unlock(MV88E6XXX_HWTSTAMP_ENABLED, &ps->state);\n\n\tswitch (config->tx_type) {\n\tcase HWTSTAMP_TX_OFF:\n\t\ttstamp_enable = false;\n\t\tbreak;\n\tcase HWTSTAMP_TX_ON:\n\t\ttstamp_enable = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\t \n\n\tif (!(BIT(config->rx_filter) & ptp_ops->rx_filters)) {\n\t\tconfig->rx_filter = HWTSTAMP_FILTER_NONE;\n\t\tdev_dbg(chip->dev, \"Unsupported rx_filter %d\\n\",\n\t\t\tconfig->rx_filter);\n\t\treturn -ERANGE;\n\t}\n\n\tswitch (config->rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\ttstamp_enable = false;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\t\tconfig->rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_ALL:\n\tdefault:\n\t\tconfig->rx_filter = HWTSTAMP_FILTER_NONE;\n\t\treturn -ERANGE;\n\t}\n\n\tmv88e6xxx_reg_lock(chip);\n\tif (tstamp_enable) {\n\t\tchip->enable_count += 1;\n\t\tif (chip->enable_count == 1 && ptp_ops->global_enable)\n\t\t\tptp_ops->global_enable(chip);\n\t\tif (ptp_ops->port_enable)\n\t\t\tptp_ops->port_enable(chip, port);\n\t} else {\n\t\tif (ptp_ops->port_disable)\n\t\t\tptp_ops->port_disable(chip, port);\n\t\tchip->enable_count -= 1;\n\t\tif (chip->enable_count == 0 && ptp_ops->global_disable)\n\t\t\tptp_ops->global_disable(chip);\n\t}\n\tmv88e6xxx_reg_unlock(chip);\n\n\t \n\tif (tstamp_enable)\n\t\tset_bit(MV88E6XXX_HWTSTAMP_ENABLED, &ps->state);\n\n\treturn 0;\n}\n\nint mv88e6xxx_port_hwtstamp_set(struct dsa_switch *ds, int port,\n\t\t\t\tstruct ifreq *ifr)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tstruct mv88e6xxx_port_hwtstamp *ps = &chip->port_hwtstamp[port];\n\tstruct hwtstamp_config config;\n\tint err;\n\n\tif (!chip->info->ptp_support)\n\t\treturn -EOPNOTSUPP;\n\n\tif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\n\t\treturn -EFAULT;\n\n\terr = mv88e6xxx_set_hwtstamp_config(chip, port, &config);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmemcpy(&ps->tstamp_config, &config, sizeof(config));\n\n\treturn copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?\n\t\t-EFAULT : 0;\n}\n\nint mv88e6xxx_port_hwtstamp_get(struct dsa_switch *ds, int port,\n\t\t\t\tstruct ifreq *ifr)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tstruct mv88e6xxx_port_hwtstamp *ps = &chip->port_hwtstamp[port];\n\tstruct hwtstamp_config *config = &ps->tstamp_config;\n\n\tif (!chip->info->ptp_support)\n\t\treturn -EOPNOTSUPP;\n\n\treturn copy_to_user(ifr->ifr_data, config, sizeof(*config)) ?\n\t\t-EFAULT : 0;\n}\n\n \nstatic struct ptp_header *mv88e6xxx_should_tstamp(struct mv88e6xxx_chip *chip,\n\t\t\t\t\t\t  int port, struct sk_buff *skb,\n\t\t\t\t\t\t  unsigned int type)\n{\n\tstruct mv88e6xxx_port_hwtstamp *ps = &chip->port_hwtstamp[port];\n\tstruct ptp_header *hdr;\n\n\tif (!chip->info->ptp_support)\n\t\treturn NULL;\n\n\thdr = ptp_parse_header(skb, type);\n\tif (!hdr)\n\t\treturn NULL;\n\n\tif (!test_bit(MV88E6XXX_HWTSTAMP_ENABLED, &ps->state))\n\t\treturn NULL;\n\n\treturn hdr;\n}\n\nstatic int mv88e6xxx_ts_valid(u16 status)\n{\n\tif (!(status & MV88E6XXX_PTP_TS_VALID))\n\t\treturn 0;\n\tif (status & MV88E6XXX_PTP_TS_STATUS_MASK)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int seq_match(struct sk_buff *skb, u16 ts_seqid)\n{\n\tunsigned int type = SKB_PTP_TYPE(skb);\n\tstruct ptp_header *hdr;\n\n\thdr = ptp_parse_header(skb, type);\n\n\treturn ts_seqid == ntohs(hdr->sequence_id);\n}\n\nstatic void mv88e6xxx_get_rxts(struct mv88e6xxx_chip *chip,\n\t\t\t       struct mv88e6xxx_port_hwtstamp *ps,\n\t\t\t       struct sk_buff *skb, u16 reg,\n\t\t\t       struct sk_buff_head *rxq)\n{\n\tu16 buf[4] = { 0 }, status, seq_id;\n\tstruct skb_shared_hwtstamps *shwt;\n\tstruct sk_buff_head received;\n\tu64 ns, timelo, timehi;\n\tunsigned long flags;\n\tint err;\n\n\t \n\t__skb_queue_head_init(&received);\n\tspin_lock_irqsave(&rxq->lock, flags);\n\tskb_queue_splice_tail_init(rxq, &received);\n\tspin_unlock_irqrestore(&rxq->lock, flags);\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = mv88e6xxx_port_ptp_read(chip, ps->port_id,\n\t\t\t\t      reg, buf, ARRAY_SIZE(buf));\n\tmv88e6xxx_reg_unlock(chip);\n\tif (err)\n\t\tpr_err(\"failed to get the receive time stamp\\n\");\n\n\tstatus = buf[0];\n\ttimelo = buf[1];\n\ttimehi = buf[2];\n\tseq_id = buf[3];\n\n\tif (status & MV88E6XXX_PTP_TS_VALID) {\n\t\tmv88e6xxx_reg_lock(chip);\n\t\terr = mv88e6xxx_port_ptp_write(chip, ps->port_id, reg, 0);\n\t\tmv88e6xxx_reg_unlock(chip);\n\t\tif (err)\n\t\t\tpr_err(\"failed to clear the receive status\\n\");\n\t}\n\t \n\tfor ( ; skb; skb = __skb_dequeue(&received)) {\n\t\tif (mv88e6xxx_ts_valid(status) && seq_match(skb, seq_id)) {\n\t\t\tns = timehi << 16 | timelo;\n\n\t\t\tmv88e6xxx_reg_lock(chip);\n\t\t\tns = timecounter_cyc2time(&chip->tstamp_tc, ns);\n\t\t\tmv88e6xxx_reg_unlock(chip);\n\t\t\tshwt = skb_hwtstamps(skb);\n\t\t\tmemset(shwt, 0, sizeof(*shwt));\n\t\t\tshwt->hwtstamp = ns_to_ktime(ns);\n\t\t\tstatus &= ~MV88E6XXX_PTP_TS_VALID;\n\t\t}\n\t\tnetif_rx(skb);\n\t}\n}\n\nstatic void mv88e6xxx_rxtstamp_work(struct mv88e6xxx_chip *chip,\n\t\t\t\t    struct mv88e6xxx_port_hwtstamp *ps)\n{\n\tconst struct mv88e6xxx_ptp_ops *ptp_ops = chip->info->ops->ptp_ops;\n\tstruct sk_buff *skb;\n\n\tskb = skb_dequeue(&ps->rx_queue);\n\n\tif (skb)\n\t\tmv88e6xxx_get_rxts(chip, ps, skb, ptp_ops->arr0_sts_reg,\n\t\t\t\t   &ps->rx_queue);\n\n\tskb = skb_dequeue(&ps->rx_queue2);\n\tif (skb)\n\t\tmv88e6xxx_get_rxts(chip, ps, skb, ptp_ops->arr1_sts_reg,\n\t\t\t\t   &ps->rx_queue2);\n}\n\nstatic int is_pdelay_resp(const struct ptp_header *hdr)\n{\n\treturn (hdr->tsmt & 0xf) == 3;\n}\n\nbool mv88e6xxx_port_rxtstamp(struct dsa_switch *ds, int port,\n\t\t\t     struct sk_buff *skb, unsigned int type)\n{\n\tstruct mv88e6xxx_port_hwtstamp *ps;\n\tstruct mv88e6xxx_chip *chip;\n\tstruct ptp_header *hdr;\n\n\tchip = ds->priv;\n\tps = &chip->port_hwtstamp[port];\n\n\tif (ps->tstamp_config.rx_filter != HWTSTAMP_FILTER_PTP_V2_EVENT)\n\t\treturn false;\n\n\thdr = mv88e6xxx_should_tstamp(chip, port, skb, type);\n\tif (!hdr)\n\t\treturn false;\n\n\tSKB_PTP_TYPE(skb) = type;\n\n\tif (is_pdelay_resp(hdr))\n\t\tskb_queue_tail(&ps->rx_queue2, skb);\n\telse\n\t\tskb_queue_tail(&ps->rx_queue, skb);\n\n\tptp_schedule_worker(chip->ptp_clock, 0);\n\n\treturn true;\n}\n\nstatic int mv88e6xxx_txtstamp_work(struct mv88e6xxx_chip *chip,\n\t\t\t\t   struct mv88e6xxx_port_hwtstamp *ps)\n{\n\tconst struct mv88e6xxx_ptp_ops *ptp_ops = chip->info->ops->ptp_ops;\n\tstruct skb_shared_hwtstamps shhwtstamps;\n\tu16 departure_block[4], status;\n\tstruct sk_buff *tmp_skb;\n\tu32 time_raw;\n\tint err;\n\tu64 ns;\n\n\tif (!ps->tx_skb)\n\t\treturn 0;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = mv88e6xxx_port_ptp_read(chip, ps->port_id,\n\t\t\t\t      ptp_ops->dep_sts_reg,\n\t\t\t\t      departure_block,\n\t\t\t\t      ARRAY_SIZE(departure_block));\n\tmv88e6xxx_reg_unlock(chip);\n\n\tif (err)\n\t\tgoto free_and_clear_skb;\n\n\tif (!(departure_block[0] & MV88E6XXX_PTP_TS_VALID)) {\n\t\tif (time_is_before_jiffies(ps->tx_tstamp_start +\n\t\t\t\t\t   TX_TSTAMP_TIMEOUT)) {\n\t\t\tdev_warn(chip->dev, \"p%d: clearing tx timestamp hang\\n\",\n\t\t\t\t ps->port_id);\n\t\t\tgoto free_and_clear_skb;\n\t\t}\n\t\t \n\t\treturn 1;\n\t}\n\n\t \n\tmv88e6xxx_reg_lock(chip);\n\tmv88e6xxx_port_ptp_write(chip, ps->port_id, ptp_ops->dep_sts_reg, 0);\n\tmv88e6xxx_reg_unlock(chip);\n\n\tstatus = departure_block[0] & MV88E6XXX_PTP_TS_STATUS_MASK;\n\tif (status != MV88E6XXX_PTP_TS_STATUS_NORMAL) {\n\t\tdev_warn(chip->dev, \"p%d: tx timestamp overrun\\n\", ps->port_id);\n\t\tgoto free_and_clear_skb;\n\t}\n\n\tif (departure_block[3] != ps->tx_seq_id) {\n\t\tdev_warn(chip->dev, \"p%d: unexpected seq. id\\n\", ps->port_id);\n\t\tgoto free_and_clear_skb;\n\t}\n\n\tmemset(&shhwtstamps, 0, sizeof(shhwtstamps));\n\ttime_raw = ((u32)departure_block[2] << 16) | departure_block[1];\n\tmv88e6xxx_reg_lock(chip);\n\tns = timecounter_cyc2time(&chip->tstamp_tc, time_raw);\n\tmv88e6xxx_reg_unlock(chip);\n\tshhwtstamps.hwtstamp = ns_to_ktime(ns);\n\n\tdev_dbg(chip->dev,\n\t\t\"p%d: txtstamp %llx status 0x%04x skb ID 0x%04x hw ID 0x%04x\\n\",\n\t\tps->port_id, ktime_to_ns(shhwtstamps.hwtstamp),\n\t\tdeparture_block[0], ps->tx_seq_id, departure_block[3]);\n\n\t \n\n\ttmp_skb = ps->tx_skb;\n\tps->tx_skb = NULL;\n\tclear_bit_unlock(MV88E6XXX_HWTSTAMP_TX_IN_PROGRESS, &ps->state);\n\tskb_complete_tx_timestamp(tmp_skb, &shhwtstamps);\n\n\treturn 0;\n\nfree_and_clear_skb:\n\tdev_kfree_skb_any(ps->tx_skb);\n\tps->tx_skb = NULL;\n\tclear_bit_unlock(MV88E6XXX_HWTSTAMP_TX_IN_PROGRESS, &ps->state);\n\n\treturn 0;\n}\n\nlong mv88e6xxx_hwtstamp_work(struct ptp_clock_info *ptp)\n{\n\tstruct mv88e6xxx_chip *chip = ptp_to_chip(ptp);\n\tstruct dsa_switch *ds = chip->ds;\n\tstruct mv88e6xxx_port_hwtstamp *ps;\n\tint i, restart = 0;\n\n\tfor (i = 0; i < ds->num_ports; i++) {\n\t\tif (!dsa_is_user_port(ds, i))\n\t\t\tcontinue;\n\n\t\tps = &chip->port_hwtstamp[i];\n\t\tif (test_bit(MV88E6XXX_HWTSTAMP_TX_IN_PROGRESS, &ps->state))\n\t\t\trestart |= mv88e6xxx_txtstamp_work(chip, ps);\n\n\t\tmv88e6xxx_rxtstamp_work(chip, ps);\n\t}\n\n\treturn restart ? 1 : -1;\n}\n\nvoid mv88e6xxx_port_txtstamp(struct dsa_switch *ds, int port,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tstruct mv88e6xxx_port_hwtstamp *ps = &chip->port_hwtstamp[port];\n\tstruct ptp_header *hdr;\n\tstruct sk_buff *clone;\n\tunsigned int type;\n\n\ttype = ptp_classify_raw(skb);\n\tif (type == PTP_CLASS_NONE)\n\t\treturn;\n\n\thdr = mv88e6xxx_should_tstamp(chip, port, skb, type);\n\tif (!hdr)\n\t\treturn;\n\n\tclone = skb_clone_sk(skb);\n\tif (!clone)\n\t\treturn;\n\n\tif (test_and_set_bit_lock(MV88E6XXX_HWTSTAMP_TX_IN_PROGRESS,\n\t\t\t\t  &ps->state)) {\n\t\tkfree_skb(clone);\n\t\treturn;\n\t}\n\n\tps->tx_skb = clone;\n\tps->tx_tstamp_start = jiffies;\n\tps->tx_seq_id = be16_to_cpu(hdr->sequence_id);\n\n\tptp_schedule_worker(chip->ptp_clock, 0);\n}\n\nint mv88e6165_global_disable(struct mv88e6xxx_chip *chip)\n{\n\tu16 val;\n\tint err;\n\n\terr = mv88e6xxx_ptp_read(chip, MV88E6165_PTP_CFG, &val);\n\tif (err)\n\t\treturn err;\n\tval |= MV88E6165_PTP_CFG_DISABLE_PTP;\n\n\treturn mv88e6xxx_ptp_write(chip, MV88E6165_PTP_CFG, val);\n}\n\nint mv88e6165_global_enable(struct mv88e6xxx_chip *chip)\n{\n\tu16 val;\n\tint err;\n\n\terr = mv88e6xxx_ptp_read(chip, MV88E6165_PTP_CFG, &val);\n\tif (err)\n\t\treturn err;\n\n\tval &= ~(MV88E6165_PTP_CFG_DISABLE_PTP | MV88E6165_PTP_CFG_TSPEC_MASK);\n\n\treturn mv88e6xxx_ptp_write(chip, MV88E6165_PTP_CFG, val);\n}\n\nint mv88e6352_hwtstamp_port_disable(struct mv88e6xxx_chip *chip, int port)\n{\n\treturn mv88e6xxx_port_ptp_write(chip, port, MV88E6XXX_PORT_PTP_CFG0,\n\t\t\t\t\tMV88E6XXX_PORT_PTP_CFG0_DISABLE_PTP);\n}\n\nint mv88e6352_hwtstamp_port_enable(struct mv88e6xxx_chip *chip, int port)\n{\n\treturn mv88e6xxx_port_ptp_write(chip, port, MV88E6XXX_PORT_PTP_CFG0,\n\t\t\t\t\tMV88E6XXX_PORT_PTP_CFG0_DISABLE_TSPEC_MATCH);\n}\n\nstatic int mv88e6xxx_hwtstamp_port_setup(struct mv88e6xxx_chip *chip, int port)\n{\n\tconst struct mv88e6xxx_ptp_ops *ptp_ops = chip->info->ops->ptp_ops;\n\tstruct mv88e6xxx_port_hwtstamp *ps = &chip->port_hwtstamp[port];\n\n\tps->port_id = port;\n\n\tskb_queue_head_init(&ps->rx_queue);\n\tskb_queue_head_init(&ps->rx_queue2);\n\n\tif (ptp_ops->port_disable)\n\t\treturn ptp_ops->port_disable(chip, port);\n\n\treturn 0;\n}\n\nint mv88e6xxx_hwtstamp_setup(struct mv88e6xxx_chip *chip)\n{\n\tconst struct mv88e6xxx_ptp_ops *ptp_ops = chip->info->ops->ptp_ops;\n\tint err;\n\tint i;\n\n\t \n\tfor (i = 0; i < mv88e6xxx_num_ports(chip); ++i) {\n\t\terr = mv88e6xxx_hwtstamp_port_setup(chip, i);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (ptp_ops->global_disable) {\n\t\terr = ptp_ops->global_disable(chip);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\terr = mv88e6xxx_ptp_write(chip, MV88E6XXX_PTP_GC_ETYPE, ETH_P_1588);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = mv88e6xxx_ptp_write(chip, MV88E6XXX_PTP_MSGTYPE,\n\t\t\t\t  MV88E6XXX_PTP_MSGTYPE_ALL_EVENT);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = mv88e6xxx_ptp_write(chip, MV88E6XXX_PTP_TS_ARRIVAL_PTR,\n\t\t\t\t  MV88E6XXX_PTP_MSGTYPE_PDLAY_RES);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (chip->info->family == MV88E6XXX_FAMILY_6341) {\n\t\tu16 val = MV88E6341_PTP_CFG_UPDATE |\n\t\t\t  MV88E6341_PTP_CFG_MODE_IDX |\n\t\t\t  MV88E6341_PTP_CFG_MODE_TS_AT_MAC;\n\t\terr = mv88e6xxx_ptp_write(chip, MV88E6341_PTP_CFG, val);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nvoid mv88e6xxx_hwtstamp_free(struct mv88e6xxx_chip *chip)\n{\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}