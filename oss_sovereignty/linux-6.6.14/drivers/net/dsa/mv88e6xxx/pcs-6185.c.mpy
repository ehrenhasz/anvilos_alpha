{
  "module_name": "pcs-6185.c",
  "hash_id": "69ec628cb7bdea9c62b8f680d95cc31c64e676a4cb51cfa698155878ae6e4230",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/mv88e6xxx/pcs-6185.c",
  "human_readable_source": "\n \n#include <linux/phylink.h>\n\n#include \"global2.h\"\n#include \"port.h\"\n#include \"serdes.h\"\n\nstruct mv88e6185_pcs {\n\tstruct phylink_pcs phylink_pcs;\n\tunsigned int irq;\n\tchar name[64];\n\n\tstruct mv88e6xxx_chip *chip;\n\tint port;\n};\n\nstatic struct mv88e6185_pcs *pcs_to_mv88e6185_pcs(struct phylink_pcs *pcs)\n{\n\treturn container_of(pcs, struct mv88e6185_pcs, phylink_pcs);\n}\n\nstatic irqreturn_t mv88e6185_pcs_handle_irq(int irq, void *dev_id)\n{\n\tstruct mv88e6185_pcs *mpcs = dev_id;\n\tstruct mv88e6xxx_chip *chip;\n\tirqreturn_t ret = IRQ_NONE;\n\tbool link_up;\n\tu16 status;\n\tint port;\n\tint err;\n\n\tchip = mpcs->chip;\n\tport = mpcs->port;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_STS, &status);\n\tmv88e6xxx_reg_unlock(chip);\n\n\tif (!err) {\n\t\tlink_up = !!(status & MV88E6XXX_PORT_STS_LINK);\n\n\t\tphylink_pcs_change(&mpcs->phylink_pcs, link_up);\n\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\nstatic void mv88e6185_pcs_get_state(struct phylink_pcs *pcs,\n\t\t\t\t    struct phylink_link_state *state)\n{\n\tstruct mv88e6185_pcs *mpcs = pcs_to_mv88e6185_pcs(pcs);\n\tstruct mv88e6xxx_chip *chip = mpcs->chip;\n\tint port = mpcs->port;\n\tu16 status;\n\tint err;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_STS, &status);\n\tmv88e6xxx_reg_unlock(chip);\n\n\tif (err)\n\t\tstatus = 0;\n\n\tstate->link = !!(status & MV88E6XXX_PORT_STS_LINK);\n\tif (state->link) {\n\t\tstate->duplex = status & MV88E6XXX_PORT_STS_DUPLEX ?\n\t\t\tDUPLEX_FULL : DUPLEX_HALF;\n\n\t\tswitch (status & MV88E6XXX_PORT_STS_SPEED_MASK) {\n\t\tcase MV88E6XXX_PORT_STS_SPEED_1000:\n\t\t\tstate->speed = SPEED_1000;\n\t\t\tbreak;\n\n\t\tcase MV88E6XXX_PORT_STS_SPEED_100:\n\t\t\tstate->speed = SPEED_100;\n\t\t\tbreak;\n\n\t\tcase MV88E6XXX_PORT_STS_SPEED_10:\n\t\t\tstate->speed = SPEED_10;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tstate->link = false;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int mv88e6185_pcs_config(struct phylink_pcs *pcs, unsigned int mode,\n\t\t\t\tphy_interface_t interface,\n\t\t\t\tconst unsigned long *advertising,\n\t\t\t\tbool permit_pause_to_mac)\n{\n\treturn 0;\n}\n\nstatic void mv88e6185_pcs_an_restart(struct phylink_pcs *pcs)\n{\n}\n\nstatic const struct phylink_pcs_ops mv88e6185_phylink_pcs_ops = {\n\t.pcs_get_state = mv88e6185_pcs_get_state,\n\t.pcs_config = mv88e6185_pcs_config,\n\t.pcs_an_restart = mv88e6185_pcs_an_restart,\n};\n\nstatic int mv88e6185_pcs_init(struct mv88e6xxx_chip *chip, int port)\n{\n\tstruct mv88e6185_pcs *mpcs;\n\tstruct device *dev;\n\tunsigned int irq;\n\tint err;\n\n\t \n\tif (chip->ports[port].cmode != MV88E6185_PORT_STS_CMODE_SERDES &&\n\t    chip->ports[port].cmode != MV88E6185_PORT_STS_CMODE_1000BASE_X)\n\t\treturn 0;\n\n\tdev = chip->dev;\n\n\tmpcs = kzalloc(sizeof(*mpcs), GFP_KERNEL);\n\tif (!mpcs)\n\t\treturn -ENOMEM;\n\n\tmpcs->chip = chip;\n\tmpcs->port = port;\n\tmpcs->phylink_pcs.ops = &mv88e6185_phylink_pcs_ops;\n\n\tirq = mv88e6xxx_serdes_irq_mapping(chip, port);\n\tif (irq) {\n\t\tsnprintf(mpcs->name, sizeof(mpcs->name),\n\t\t\t \"mv88e6xxx-%s-serdes-%d\", dev_name(dev), port);\n\n\t\terr = request_threaded_irq(irq, NULL, mv88e6185_pcs_handle_irq,\n\t\t\t\t\t   IRQF_ONESHOT, mpcs->name, mpcs);\n\t\tif (err) {\n\t\t\tkfree(mpcs);\n\t\t\treturn err;\n\t\t}\n\n\t\tmpcs->irq = irq;\n\t} else {\n\t\tmpcs->phylink_pcs.poll = true;\n\t}\n\n\tchip->ports[port].pcs_private = &mpcs->phylink_pcs;\n\n\treturn 0;\n}\n\nstatic void mv88e6185_pcs_teardown(struct mv88e6xxx_chip *chip, int port)\n{\n\tstruct mv88e6185_pcs *mpcs;\n\n\tmpcs = chip->ports[port].pcs_private;\n\tif (!mpcs)\n\t\treturn;\n\n\tif (mpcs->irq)\n\t\tfree_irq(mpcs->irq, mpcs);\n\n\tkfree(mpcs);\n\n\tchip->ports[port].pcs_private = NULL;\n}\n\nstatic struct phylink_pcs *mv88e6185_pcs_select(struct mv88e6xxx_chip *chip,\n\t\t\t\t\t\tint port,\n\t\t\t\t\t\tphy_interface_t interface)\n{\n\treturn chip->ports[port].pcs_private;\n}\n\nconst struct mv88e6xxx_pcs_ops mv88e6185_pcs_ops = {\n\t.pcs_init = mv88e6185_pcs_init,\n\t.pcs_teardown = mv88e6185_pcs_teardown,\n\t.pcs_select = mv88e6185_pcs_select,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}