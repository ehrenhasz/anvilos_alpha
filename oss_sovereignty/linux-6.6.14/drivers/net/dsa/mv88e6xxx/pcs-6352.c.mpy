{
  "module_name": "pcs-6352.c",
  "hash_id": "3a04df60a875d81d6d2379963d2c15b36db0bb83126ea16295a5ff20f322f8ae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/mv88e6xxx/pcs-6352.c",
  "human_readable_source": "\n \n#include <linux/phylink.h>\n\n#include \"global2.h\"\n#include \"port.h\"\n#include \"serdes.h\"\n\n \n#define MII_M1011_PHY_STATUS\t\t17\n#define MII_M1011_IMASK\t\t\t18\n#define MII_M1011_IMASK_LINK_CHANGE\tBIT(10)\n#define MII_M1011_IEVENT\t\t19\n#define MII_M1011_IEVENT_LINK_CHANGE\tBIT(10)\n#define MII_MARVELL_PHY_PAGE\t\t22\n#define MII_MARVELL_FIBER_PAGE\t\t1\n\nstruct marvell_c22_pcs {\n\tstruct mdio_device mdio;\n\tstruct phylink_pcs phylink_pcs;\n\tunsigned int irq;\n\tchar name[64];\n\tbool (*link_check)(struct marvell_c22_pcs *mpcs);\n\tstruct mv88e6xxx_port *port;\n};\n\nstatic struct marvell_c22_pcs *pcs_to_marvell_c22_pcs(struct phylink_pcs *pcs)\n{\n\treturn container_of(pcs, struct marvell_c22_pcs, phylink_pcs);\n}\n\nstatic int marvell_c22_pcs_set_fiber_page(struct marvell_c22_pcs *mpcs)\n{\n\tu16 page;\n\tint err;\n\n\tmutex_lock(&mpcs->mdio.bus->mdio_lock);\n\n\terr = __mdiodev_read(&mpcs->mdio, MII_MARVELL_PHY_PAGE);\n\tif (err < 0) {\n\t\tdev_err(mpcs->mdio.dev.parent,\n\t\t\t\"%s: can't read Serdes page register: %pe\\n\",\n\t\t\tmpcs->name, ERR_PTR(err));\n\t\treturn err;\n\t}\n\n\tpage = err;\n\n\terr = __mdiodev_write(&mpcs->mdio, MII_MARVELL_PHY_PAGE,\n\t\t\t      MII_MARVELL_FIBER_PAGE);\n\tif (err) {\n\t\tdev_err(mpcs->mdio.dev.parent,\n\t\t\t\"%s: can't set Serdes page register: %pe\\n\",\n\t\t\tmpcs->name, ERR_PTR(err));\n\t\treturn err;\n\t}\n\n\treturn page;\n}\n\nstatic int marvell_c22_pcs_restore_page(struct marvell_c22_pcs *mpcs,\n\t\t\t\t\tint oldpage, int ret)\n{\n\tint err;\n\n\tif (oldpage >= 0) {\n\t\terr = __mdiodev_write(&mpcs->mdio, MII_MARVELL_PHY_PAGE,\n\t\t\t\t      oldpage);\n\t\tif (err)\n\t\t\tdev_err(mpcs->mdio.dev.parent,\n\t\t\t\t\"%s: can't restore Serdes page register: %pe\\n\",\n\t\t\t\tmpcs->name, ERR_PTR(err));\n\t\tif (!err || ret < 0)\n\t\t\terr = ret;\n\t} else {\n\t\terr = oldpage;\n\t}\n\tmutex_unlock(&mpcs->mdio.bus->mdio_lock);\n\n\treturn err;\n}\n\nstatic irqreturn_t marvell_c22_pcs_handle_irq(int irq, void *dev_id)\n{\n\tstruct marvell_c22_pcs *mpcs = dev_id;\n\tirqreturn_t status = IRQ_NONE;\n\tint err, oldpage;\n\n\toldpage = marvell_c22_pcs_set_fiber_page(mpcs);\n\tif (oldpage < 0)\n\t\tgoto fail;\n\n\terr = __mdiodev_read(&mpcs->mdio, MII_M1011_IEVENT);\n\tif (err >= 0 && err & MII_M1011_IEVENT_LINK_CHANGE) {\n\t\tphylink_pcs_change(&mpcs->phylink_pcs, true);\n\t\tstatus = IRQ_HANDLED;\n\t}\n\nfail:\n\tmarvell_c22_pcs_restore_page(mpcs, oldpage, 0);\n\n\treturn status;\n}\n\nstatic int marvell_c22_pcs_modify(struct marvell_c22_pcs *mpcs, u8 reg,\n\t\t\t\t  u16 mask, u16 val)\n{\n\tint oldpage, err = 0;\n\n\toldpage = marvell_c22_pcs_set_fiber_page(mpcs);\n\tif (oldpage >= 0)\n\t\terr = __mdiodev_modify(&mpcs->mdio, reg, mask, val);\n\n\treturn marvell_c22_pcs_restore_page(mpcs, oldpage, err);\n}\n\nstatic int marvell_c22_pcs_power(struct marvell_c22_pcs *mpcs,\n\t\t\t\t bool on)\n{\n\tu16 val = on ? 0 : BMCR_PDOWN;\n\n\treturn marvell_c22_pcs_modify(mpcs, MII_BMCR, BMCR_PDOWN, val);\n}\n\nstatic int marvell_c22_pcs_control_irq(struct marvell_c22_pcs *mpcs,\n\t\t\t\t       bool enable)\n{\n\tu16 val = enable ? MII_M1011_IMASK_LINK_CHANGE : 0;\n\n\treturn marvell_c22_pcs_modify(mpcs, MII_M1011_IMASK,\n\t\t\t\t      MII_M1011_IMASK_LINK_CHANGE, val);\n}\n\nstatic int marvell_c22_pcs_enable(struct phylink_pcs *pcs)\n{\n\tstruct marvell_c22_pcs *mpcs = pcs_to_marvell_c22_pcs(pcs);\n\tint err;\n\n\terr = marvell_c22_pcs_power(mpcs, true);\n\tif (err)\n\t\treturn err;\n\n\treturn marvell_c22_pcs_control_irq(mpcs, !!mpcs->irq);\n}\n\nstatic void marvell_c22_pcs_disable(struct phylink_pcs *pcs)\n{\n\tstruct marvell_c22_pcs *mpcs = pcs_to_marvell_c22_pcs(pcs);\n\n\tmarvell_c22_pcs_control_irq(mpcs, false);\n\tmarvell_c22_pcs_power(mpcs, false);\n}\n\nstatic void marvell_c22_pcs_get_state(struct phylink_pcs *pcs,\n\t\t\t\t      struct phylink_link_state *state)\n{\n\tstruct marvell_c22_pcs *mpcs = pcs_to_marvell_c22_pcs(pcs);\n\tint oldpage, bmsr, lpa, status;\n\n\tstate->link = false;\n\n\tif (mpcs->link_check && !mpcs->link_check(mpcs))\n\t\treturn;\n\n\toldpage = marvell_c22_pcs_set_fiber_page(mpcs);\n\tif (oldpage >= 0) {\n\t\tbmsr = __mdiodev_read(&mpcs->mdio, MII_BMSR);\n\t\tlpa = __mdiodev_read(&mpcs->mdio, MII_LPA);\n\t\tstatus = __mdiodev_read(&mpcs->mdio, MII_M1011_PHY_STATUS);\n\t}\n\n\tif (marvell_c22_pcs_restore_page(mpcs, oldpage, 0) >= 0 &&\n\t    bmsr >= 0 && lpa >= 0 && status >= 0)\n\t\tmv88e6xxx_pcs_decode_state(mpcs->mdio.dev.parent, bmsr, lpa,\n\t\t\t\t\t   status, state);\n}\n\nstatic int marvell_c22_pcs_config(struct phylink_pcs *pcs,\n\t\t\t\t  unsigned int neg_mode,\n\t\t\t\t  phy_interface_t interface,\n\t\t\t\t  const unsigned long *advertising,\n\t\t\t\t  bool permit_pause_to_mac)\n{\n\tstruct marvell_c22_pcs *mpcs = pcs_to_marvell_c22_pcs(pcs);\n\tint oldpage, adv, err, ret = 0;\n\tu16 bmcr;\n\n\tadv = phylink_mii_c22_pcs_encode_advertisement(interface, advertising);\n\tif (adv < 0)\n\t\treturn 0;\n\n\tbmcr = neg_mode == PHYLINK_PCS_NEG_INBAND_ENABLED ? BMCR_ANENABLE : 0;\n\n\toldpage = marvell_c22_pcs_set_fiber_page(mpcs);\n\tif (oldpage < 0)\n\t\tgoto restore;\n\n\terr = __mdiodev_modify_changed(&mpcs->mdio, MII_ADVERTISE, 0xffff, adv);\n\tret = err;\n\tif (err < 0)\n\t\tgoto restore;\n\n\terr = __mdiodev_modify_changed(&mpcs->mdio, MII_BMCR, BMCR_ANENABLE,\n\t\t\t\t       bmcr);\n\tif (err < 0) {\n\t\tret = err;\n\t\tgoto restore;\n\t}\n\n\t \n\tif (err)\n\t\tret = 0;\n\nrestore:\n\treturn marvell_c22_pcs_restore_page(mpcs, oldpage, ret);\n}\n\nstatic void marvell_c22_pcs_an_restart(struct phylink_pcs *pcs)\n{\n\tstruct marvell_c22_pcs *mpcs = pcs_to_marvell_c22_pcs(pcs);\n\n\tmarvell_c22_pcs_modify(mpcs, MII_BMCR, BMCR_ANRESTART, BMCR_ANRESTART);\n}\n\nstatic void marvell_c22_pcs_link_up(struct phylink_pcs *pcs, unsigned int mode,\n\t\t\t\t    phy_interface_t interface, int speed,\n\t\t\t\t    int duplex)\n{\n\tstruct marvell_c22_pcs *mpcs = pcs_to_marvell_c22_pcs(pcs);\n\tu16 bmcr;\n\tint err;\n\n\tif (phylink_autoneg_inband(mode))\n\t\treturn;\n\n\tbmcr = mii_bmcr_encode_fixed(speed, duplex);\n\n\terr = marvell_c22_pcs_modify(mpcs, MII_BMCR, BMCR_SPEED100 |\n\t\t\t\t     BMCR_FULLDPLX | BMCR_SPEED1000, bmcr);\n\tif (err)\n\t\tdev_err(mpcs->mdio.dev.parent,\n\t\t\t\"%s: failed to configure mpcs: %pe\\n\", mpcs->name,\n\t\t\tERR_PTR(err));\n}\n\nstatic const struct phylink_pcs_ops marvell_c22_pcs_ops = {\n\t.pcs_enable = marvell_c22_pcs_enable,\n\t.pcs_disable = marvell_c22_pcs_disable,\n\t.pcs_get_state = marvell_c22_pcs_get_state,\n\t.pcs_config = marvell_c22_pcs_config,\n\t.pcs_an_restart = marvell_c22_pcs_an_restart,\n\t.pcs_link_up = marvell_c22_pcs_link_up,\n};\n\nstatic struct marvell_c22_pcs *marvell_c22_pcs_alloc(struct device *dev,\n\t\t\t\t\t\t     struct mii_bus *bus,\n\t\t\t\t\t\t     unsigned int addr)\n{\n\tstruct marvell_c22_pcs *mpcs;\n\n\tmpcs = kzalloc(sizeof(*mpcs), GFP_KERNEL);\n\tif (!mpcs)\n\t\treturn NULL;\n\n\tmpcs->mdio.dev.parent = dev;\n\tmpcs->mdio.bus = bus;\n\tmpcs->mdio.addr = addr;\n\tmpcs->phylink_pcs.ops = &marvell_c22_pcs_ops;\n\tmpcs->phylink_pcs.neg_mode = true;\n\n\treturn mpcs;\n}\n\nstatic int marvell_c22_pcs_setup_irq(struct marvell_c22_pcs *mpcs,\n\t\t\t\t     unsigned int irq)\n{\n\tint err;\n\n\tmpcs->phylink_pcs.poll = !irq;\n\tmpcs->irq = irq;\n\n\tif (irq) {\n\t\terr = request_threaded_irq(irq, NULL,\n\t\t\t\t\t   marvell_c22_pcs_handle_irq,\n\t\t\t\t\t   IRQF_ONESHOT, mpcs->name, mpcs);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic bool mv88e6352_pcs_link_check(struct marvell_c22_pcs *mpcs)\n{\n\tstruct mv88e6xxx_port *port = mpcs->port;\n\tstruct mv88e6xxx_chip *chip = port->chip;\n\tu8 cmode;\n\n\t \n\tmv88e6xxx_reg_lock(chip);\n\tchip->info->ops->port_get_cmode(chip, port->port, &cmode);\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn cmode == MV88E6XXX_PORT_STS_CMODE_100BASEX ||\n\t       cmode == MV88E6XXX_PORT_STS_CMODE_1000BASEX ||\n\t       cmode == MV88E6XXX_PORT_STS_CMODE_SGMII;\n}\n\nstatic int mv88e6352_pcs_init(struct mv88e6xxx_chip *chip, int port)\n{\n\tstruct marvell_c22_pcs *mpcs;\n\tstruct mii_bus *bus;\n\tstruct device *dev;\n\tunsigned int irq;\n\tint err;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = mv88e6352_g2_scratch_port_has_serdes(chip, port);\n\tmv88e6xxx_reg_unlock(chip);\n\tif (err <= 0)\n\t\treturn err;\n\n\tirq = mv88e6xxx_serdes_irq_mapping(chip, port);\n\tbus = mv88e6xxx_default_mdio_bus(chip);\n\tdev = chip->dev;\n\n\tmpcs = marvell_c22_pcs_alloc(dev, bus, MV88E6352_ADDR_SERDES);\n\tif (!mpcs)\n\t\treturn -ENOMEM;\n\n\tsnprintf(mpcs->name, sizeof(mpcs->name),\n\t\t \"mv88e6xxx-%s-serdes-%d\", dev_name(dev), port);\n\n\tmpcs->link_check = mv88e6352_pcs_link_check;\n\tmpcs->port = &chip->ports[port];\n\n\terr = marvell_c22_pcs_setup_irq(mpcs, irq);\n\tif (err) {\n\t\tkfree(mpcs);\n\t\treturn err;\n\t}\n\n\tchip->ports[port].pcs_private = &mpcs->phylink_pcs;\n\n\treturn 0;\n}\n\nstatic void mv88e6352_pcs_teardown(struct mv88e6xxx_chip *chip, int port)\n{\n\tstruct marvell_c22_pcs *mpcs;\n\tstruct phylink_pcs *pcs;\n\n\tpcs = chip->ports[port].pcs_private;\n\tif (!pcs)\n\t\treturn;\n\n\tmpcs = pcs_to_marvell_c22_pcs(pcs);\n\n\tif (mpcs->irq)\n\t\tfree_irq(mpcs->irq, mpcs);\n\n\tkfree(mpcs);\n\n\tchip->ports[port].pcs_private = NULL;\n}\n\nstatic struct phylink_pcs *mv88e6352_pcs_select(struct mv88e6xxx_chip *chip,\n\t\t\t\t\t\tint port,\n\t\t\t\t\t\tphy_interface_t interface)\n{\n\treturn chip->ports[port].pcs_private;\n}\n\nconst struct mv88e6xxx_pcs_ops mv88e6352_pcs_ops = {\n\t.pcs_init = mv88e6352_pcs_init,\n\t.pcs_teardown = mv88e6352_pcs_teardown,\n\t.pcs_select = mv88e6352_pcs_select,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}