{
  "module_name": "chip.c",
  "hash_id": "406ad6ed21cd99b11e323a62e4805ec04f01255b9bc9e9944b94f4693e257d4a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/mv88e6xxx/chip.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/dsa/mv88e6xxx.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/if_bridge.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/jiffies.h>\n#include <linux/list.h>\n#include <linux/mdio.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_mdio.h>\n#include <linux/platform_data/mv88e6xxx.h>\n#include <linux/netdevice.h>\n#include <linux/gpio/consumer.h>\n#include <linux/phylink.h>\n#include <net/dsa.h>\n\n#include \"chip.h\"\n#include \"devlink.h\"\n#include \"global1.h\"\n#include \"global2.h\"\n#include \"hwtstamp.h\"\n#include \"phy.h\"\n#include \"port.h\"\n#include \"ptp.h\"\n#include \"serdes.h\"\n#include \"smi.h\"\n\nstatic void assert_reg_lock(struct mv88e6xxx_chip *chip)\n{\n\tif (unlikely(!mutex_is_locked(&chip->reg_lock))) {\n\t\tdev_err(chip->dev, \"Switch registers lock not held!\\n\");\n\t\tdump_stack();\n\t}\n}\n\nint mv88e6xxx_read(struct mv88e6xxx_chip *chip, int addr, int reg, u16 *val)\n{\n\tint err;\n\n\tassert_reg_lock(chip);\n\n\terr = mv88e6xxx_smi_read(chip, addr, reg, val);\n\tif (err)\n\t\treturn err;\n\n\tdev_dbg(chip->dev, \"<- addr: 0x%.2x reg: 0x%.2x val: 0x%.4x\\n\",\n\t\taddr, reg, *val);\n\n\treturn 0;\n}\n\nint mv88e6xxx_write(struct mv88e6xxx_chip *chip, int addr, int reg, u16 val)\n{\n\tint err;\n\n\tassert_reg_lock(chip);\n\n\terr = mv88e6xxx_smi_write(chip, addr, reg, val);\n\tif (err)\n\t\treturn err;\n\n\tdev_dbg(chip->dev, \"-> addr: 0x%.2x reg: 0x%.2x val: 0x%.4x\\n\",\n\t\taddr, reg, val);\n\n\treturn 0;\n}\n\nint mv88e6xxx_wait_mask(struct mv88e6xxx_chip *chip, int addr, int reg,\n\t\t\tu16 mask, u16 val)\n{\n\tconst unsigned long timeout = jiffies + msecs_to_jiffies(50);\n\tu16 data;\n\tint err;\n\tint i;\n\n\t \n\tfor (i = 0; time_before(jiffies, timeout) || (i < 2); i++) {\n\t\terr = mv88e6xxx_read(chip, addr, reg, &data);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif ((data & mask) == val)\n\t\t\treturn 0;\n\n\t\tif (i < 2)\n\t\t\tcpu_relax();\n\t\telse\n\t\t\tusleep_range(1000, 2000);\n\t}\n\n\terr = mv88e6xxx_read(chip, addr, reg, &data);\n\tif (err)\n\t\treturn err;\n\n\tif ((data & mask) == val)\n\t\treturn 0;\n\n\tdev_err(chip->dev, \"Timeout while waiting for switch\\n\");\n\treturn -ETIMEDOUT;\n}\n\nint mv88e6xxx_wait_bit(struct mv88e6xxx_chip *chip, int addr, int reg,\n\t\t       int bit, int val)\n{\n\treturn mv88e6xxx_wait_mask(chip, addr, reg, BIT(bit),\n\t\t\t\t   val ? BIT(bit) : 0x0000);\n}\n\nstruct mii_bus *mv88e6xxx_default_mdio_bus(struct mv88e6xxx_chip *chip)\n{\n\tstruct mv88e6xxx_mdio_bus *mdio_bus;\n\n\tmdio_bus = list_first_entry(&chip->mdios, struct mv88e6xxx_mdio_bus,\n\t\t\t\t    list);\n\tif (!mdio_bus)\n\t\treturn NULL;\n\n\treturn mdio_bus->bus;\n}\n\nstatic void mv88e6xxx_g1_irq_mask(struct irq_data *d)\n{\n\tstruct mv88e6xxx_chip *chip = irq_data_get_irq_chip_data(d);\n\tunsigned int n = d->hwirq;\n\n\tchip->g1_irq.masked |= (1 << n);\n}\n\nstatic void mv88e6xxx_g1_irq_unmask(struct irq_data *d)\n{\n\tstruct mv88e6xxx_chip *chip = irq_data_get_irq_chip_data(d);\n\tunsigned int n = d->hwirq;\n\n\tchip->g1_irq.masked &= ~(1 << n);\n}\n\nstatic irqreturn_t mv88e6xxx_g1_irq_thread_work(struct mv88e6xxx_chip *chip)\n{\n\tunsigned int nhandled = 0;\n\tunsigned int sub_irq;\n\tunsigned int n;\n\tu16 reg;\n\tu16 ctl1;\n\tint err;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = mv88e6xxx_g1_read(chip, MV88E6XXX_G1_STS, &reg);\n\tmv88e6xxx_reg_unlock(chip);\n\n\tif (err)\n\t\tgoto out;\n\n\tdo {\n\t\tfor (n = 0; n < chip->g1_irq.nirqs; ++n) {\n\t\t\tif (reg & (1 << n)) {\n\t\t\t\tsub_irq = irq_find_mapping(chip->g1_irq.domain,\n\t\t\t\t\t\t\t   n);\n\t\t\t\thandle_nested_irq(sub_irq);\n\t\t\t\t++nhandled;\n\t\t\t}\n\t\t}\n\n\t\tmv88e6xxx_reg_lock(chip);\n\t\terr = mv88e6xxx_g1_read(chip, MV88E6XXX_G1_CTL1, &ctl1);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t\terr = mv88e6xxx_g1_read(chip, MV88E6XXX_G1_STS, &reg);\nunlock:\n\t\tmv88e6xxx_reg_unlock(chip);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tctl1 &= GENMASK(chip->g1_irq.nirqs, 0);\n\t} while (reg & ctl1);\n\nout:\n\treturn (nhandled > 0 ? IRQ_HANDLED : IRQ_NONE);\n}\n\nstatic irqreturn_t mv88e6xxx_g1_irq_thread_fn(int irq, void *dev_id)\n{\n\tstruct mv88e6xxx_chip *chip = dev_id;\n\n\treturn mv88e6xxx_g1_irq_thread_work(chip);\n}\n\nstatic void mv88e6xxx_g1_irq_bus_lock(struct irq_data *d)\n{\n\tstruct mv88e6xxx_chip *chip = irq_data_get_irq_chip_data(d);\n\n\tmv88e6xxx_reg_lock(chip);\n}\n\nstatic void mv88e6xxx_g1_irq_bus_sync_unlock(struct irq_data *d)\n{\n\tstruct mv88e6xxx_chip *chip = irq_data_get_irq_chip_data(d);\n\tu16 mask = GENMASK(chip->g1_irq.nirqs, 0);\n\tu16 reg;\n\tint err;\n\n\terr = mv88e6xxx_g1_read(chip, MV88E6XXX_G1_CTL1, &reg);\n\tif (err)\n\t\tgoto out;\n\n\treg &= ~mask;\n\treg |= (~chip->g1_irq.masked & mask);\n\n\terr = mv88e6xxx_g1_write(chip, MV88E6XXX_G1_CTL1, reg);\n\tif (err)\n\t\tgoto out;\n\nout:\n\tmv88e6xxx_reg_unlock(chip);\n}\n\nstatic const struct irq_chip mv88e6xxx_g1_irq_chip = {\n\t.name\t\t\t= \"mv88e6xxx-g1\",\n\t.irq_mask\t\t= mv88e6xxx_g1_irq_mask,\n\t.irq_unmask\t\t= mv88e6xxx_g1_irq_unmask,\n\t.irq_bus_lock\t\t= mv88e6xxx_g1_irq_bus_lock,\n\t.irq_bus_sync_unlock\t= mv88e6xxx_g1_irq_bus_sync_unlock,\n};\n\nstatic int mv88e6xxx_g1_irq_domain_map(struct irq_domain *d,\n\t\t\t\t       unsigned int irq,\n\t\t\t\t       irq_hw_number_t hwirq)\n{\n\tstruct mv88e6xxx_chip *chip = d->host_data;\n\n\tirq_set_chip_data(irq, d->host_data);\n\tirq_set_chip_and_handler(irq, &chip->g1_irq.chip, handle_level_irq);\n\tirq_set_noprobe(irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops mv88e6xxx_g1_irq_domain_ops = {\n\t.map\t= mv88e6xxx_g1_irq_domain_map,\n\t.xlate\t= irq_domain_xlate_twocell,\n};\n\n \nstatic void mv88e6xxx_g1_irq_free_common(struct mv88e6xxx_chip *chip)\n{\n\tint irq, virq;\n\tu16 mask;\n\n\tmv88e6xxx_g1_read(chip, MV88E6XXX_G1_CTL1, &mask);\n\tmask &= ~GENMASK(chip->g1_irq.nirqs, 0);\n\tmv88e6xxx_g1_write(chip, MV88E6XXX_G1_CTL1, mask);\n\n\tfor (irq = 0; irq < chip->g1_irq.nirqs; irq++) {\n\t\tvirq = irq_find_mapping(chip->g1_irq.domain, irq);\n\t\tirq_dispose_mapping(virq);\n\t}\n\n\tirq_domain_remove(chip->g1_irq.domain);\n}\n\nstatic void mv88e6xxx_g1_irq_free(struct mv88e6xxx_chip *chip)\n{\n\t \n\tfree_irq(chip->irq, chip);\n\n\tmv88e6xxx_reg_lock(chip);\n\tmv88e6xxx_g1_irq_free_common(chip);\n\tmv88e6xxx_reg_unlock(chip);\n}\n\nstatic int mv88e6xxx_g1_irq_setup_common(struct mv88e6xxx_chip *chip)\n{\n\tint err, irq, virq;\n\tu16 reg, mask;\n\n\tchip->g1_irq.nirqs = chip->info->g1_irqs;\n\tchip->g1_irq.domain = irq_domain_add_simple(\n\t\tNULL, chip->g1_irq.nirqs, 0,\n\t\t&mv88e6xxx_g1_irq_domain_ops, chip);\n\tif (!chip->g1_irq.domain)\n\t\treturn -ENOMEM;\n\n\tfor (irq = 0; irq < chip->g1_irq.nirqs; irq++)\n\t\tirq_create_mapping(chip->g1_irq.domain, irq);\n\n\tchip->g1_irq.chip = mv88e6xxx_g1_irq_chip;\n\tchip->g1_irq.masked = ~0;\n\n\terr = mv88e6xxx_g1_read(chip, MV88E6XXX_G1_CTL1, &mask);\n\tif (err)\n\t\tgoto out_mapping;\n\n\tmask &= ~GENMASK(chip->g1_irq.nirqs, 0);\n\n\terr = mv88e6xxx_g1_write(chip, MV88E6XXX_G1_CTL1, mask);\n\tif (err)\n\t\tgoto out_disable;\n\n\t \n\terr = mv88e6xxx_g1_read(chip, MV88E6XXX_G1_STS, &reg);\n\tif (err)\n\t\tgoto out_disable;\n\n\treturn 0;\n\nout_disable:\n\tmask &= ~GENMASK(chip->g1_irq.nirqs, 0);\n\tmv88e6xxx_g1_write(chip, MV88E6XXX_G1_CTL1, mask);\n\nout_mapping:\n\tfor (irq = 0; irq < 16; irq++) {\n\t\tvirq = irq_find_mapping(chip->g1_irq.domain, irq);\n\t\tirq_dispose_mapping(virq);\n\t}\n\n\tirq_domain_remove(chip->g1_irq.domain);\n\n\treturn err;\n}\n\nstatic int mv88e6xxx_g1_irq_setup(struct mv88e6xxx_chip *chip)\n{\n\tstatic struct lock_class_key lock_key;\n\tstatic struct lock_class_key request_key;\n\tint err;\n\n\terr = mv88e6xxx_g1_irq_setup_common(chip);\n\tif (err)\n\t\treturn err;\n\n\t \n\tirq_set_lockdep_class(chip->irq, &lock_key, &request_key);\n\n\tsnprintf(chip->irq_name, sizeof(chip->irq_name),\n\t\t \"mv88e6xxx-%s\", dev_name(chip->dev));\n\n\tmv88e6xxx_reg_unlock(chip);\n\terr = request_threaded_irq(chip->irq, NULL,\n\t\t\t\t   mv88e6xxx_g1_irq_thread_fn,\n\t\t\t\t   IRQF_ONESHOT | IRQF_SHARED,\n\t\t\t\t   chip->irq_name, chip);\n\tmv88e6xxx_reg_lock(chip);\n\tif (err)\n\t\tmv88e6xxx_g1_irq_free_common(chip);\n\n\treturn err;\n}\n\nstatic void mv88e6xxx_irq_poll(struct kthread_work *work)\n{\n\tstruct mv88e6xxx_chip *chip = container_of(work,\n\t\t\t\t\t\t   struct mv88e6xxx_chip,\n\t\t\t\t\t\t   irq_poll_work.work);\n\tmv88e6xxx_g1_irq_thread_work(chip);\n\n\tkthread_queue_delayed_work(chip->kworker, &chip->irq_poll_work,\n\t\t\t\t   msecs_to_jiffies(100));\n}\n\nstatic int mv88e6xxx_irq_poll_setup(struct mv88e6xxx_chip *chip)\n{\n\tint err;\n\n\terr = mv88e6xxx_g1_irq_setup_common(chip);\n\tif (err)\n\t\treturn err;\n\n\tkthread_init_delayed_work(&chip->irq_poll_work,\n\t\t\t\t  mv88e6xxx_irq_poll);\n\n\tchip->kworker = kthread_create_worker(0, \"%s\", dev_name(chip->dev));\n\tif (IS_ERR(chip->kworker))\n\t\treturn PTR_ERR(chip->kworker);\n\n\tkthread_queue_delayed_work(chip->kworker, &chip->irq_poll_work,\n\t\t\t\t   msecs_to_jiffies(100));\n\n\treturn 0;\n}\n\nstatic void mv88e6xxx_irq_poll_free(struct mv88e6xxx_chip *chip)\n{\n\tkthread_cancel_delayed_work_sync(&chip->irq_poll_work);\n\tkthread_destroy_worker(chip->kworker);\n\n\tmv88e6xxx_reg_lock(chip);\n\tmv88e6xxx_g1_irq_free_common(chip);\n\tmv88e6xxx_reg_unlock(chip);\n}\n\nstatic int mv88e6xxx_port_config_interface(struct mv88e6xxx_chip *chip,\n\t\t\t\t\t   int port, phy_interface_t interface)\n{\n\tint err;\n\n\tif (chip->info->ops->port_set_rgmii_delay) {\n\t\terr = chip->info->ops->port_set_rgmii_delay(chip, port,\n\t\t\t\t\t\t\t    interface);\n\t\tif (err && err != -EOPNOTSUPP)\n\t\t\treturn err;\n\t}\n\n\tif (chip->info->ops->port_set_cmode) {\n\t\terr = chip->info->ops->port_set_cmode(chip, port,\n\t\t\t\t\t\t      interface);\n\t\tif (err && err != -EOPNOTSUPP)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_port_setup_mac(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t    int link, int speed, int duplex, int pause,\n\t\t\t\t    phy_interface_t mode)\n{\n\tint err;\n\n\tif (!chip->info->ops->port_set_link)\n\t\treturn 0;\n\n\t \n\terr = chip->info->ops->port_set_link(chip, port, LINK_FORCED_DOWN);\n\tif (err)\n\t\treturn err;\n\n\tif (chip->info->ops->port_set_speed_duplex) {\n\t\terr = chip->info->ops->port_set_speed_duplex(chip, port,\n\t\t\t\t\t\t\t     speed, duplex);\n\t\tif (err && err != -EOPNOTSUPP)\n\t\t\tgoto restore_link;\n\t}\n\n\tif (chip->info->ops->port_set_pause) {\n\t\terr = chip->info->ops->port_set_pause(chip, port, pause);\n\t\tif (err)\n\t\t\tgoto restore_link;\n\t}\n\n\terr = mv88e6xxx_port_config_interface(chip, port, mode);\nrestore_link:\n\tif (chip->info->ops->port_set_link(chip, port, link))\n\t\tdev_err(chip->dev, \"p%d: failed to restore MAC's link\\n\", port);\n\n\treturn err;\n}\n\nstatic int mv88e6xxx_phy_is_internal(struct mv88e6xxx_chip *chip, int port)\n{\n\treturn port >= chip->info->internal_phys_offset &&\n\t\tport < chip->info->num_internal_phys +\n\t\t\tchip->info->internal_phys_offset;\n}\n\nstatic int mv88e6xxx_port_ppu_updates(struct mv88e6xxx_chip *chip, int port)\n{\n\tu16 reg;\n\tint err;\n\n\t \n\tif (chip->info->family == MV88E6XXX_FAMILY_6250)\n\t\treturn mv88e6xxx_phy_is_internal(chip, port);\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_STS, &reg);\n\tif (err) {\n\t\tdev_err(chip->dev,\n\t\t\t\"p%d: %s: failed to read port status\\n\",\n\t\t\tport, __func__);\n\t\treturn err;\n\t}\n\n\treturn !!(reg & MV88E6XXX_PORT_STS_PHY_DETECT);\n}\n\nstatic const u8 mv88e6185_phy_interface_modes[] = {\n\t[MV88E6185_PORT_STS_CMODE_GMII_FD]\t = PHY_INTERFACE_MODE_GMII,\n\t[MV88E6185_PORT_STS_CMODE_MII_100_FD_PS] = PHY_INTERFACE_MODE_MII,\n\t[MV88E6185_PORT_STS_CMODE_MII_100]\t = PHY_INTERFACE_MODE_MII,\n\t[MV88E6185_PORT_STS_CMODE_MII_10]\t = PHY_INTERFACE_MODE_MII,\n\t[MV88E6185_PORT_STS_CMODE_SERDES]\t = PHY_INTERFACE_MODE_1000BASEX,\n\t[MV88E6185_PORT_STS_CMODE_1000BASE_X]\t = PHY_INTERFACE_MODE_1000BASEX,\n\t[MV88E6185_PORT_STS_CMODE_PHY]\t\t = PHY_INTERFACE_MODE_SGMII,\n};\n\nstatic void mv88e6095_phylink_get_caps(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t       struct phylink_config *config)\n{\n\tu8 cmode = chip->ports[port].cmode;\n\n\tconfig->mac_capabilities = MAC_SYM_PAUSE | MAC_10 | MAC_100;\n\n\tif (mv88e6xxx_phy_is_internal(chip, port)) {\n\t\t__set_bit(PHY_INTERFACE_MODE_MII, config->supported_interfaces);\n\t} else {\n\t\tif (cmode < ARRAY_SIZE(mv88e6185_phy_interface_modes) &&\n\t\t    mv88e6185_phy_interface_modes[cmode])\n\t\t\t__set_bit(mv88e6185_phy_interface_modes[cmode],\n\t\t\t\t  config->supported_interfaces);\n\n\t\tconfig->mac_capabilities |= MAC_1000FD;\n\t}\n}\n\nstatic void mv88e6185_phylink_get_caps(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t       struct phylink_config *config)\n{\n\tu8 cmode = chip->ports[port].cmode;\n\n\tif (cmode < ARRAY_SIZE(mv88e6185_phy_interface_modes) &&\n\t    mv88e6185_phy_interface_modes[cmode])\n\t\t__set_bit(mv88e6185_phy_interface_modes[cmode],\n\t\t\t  config->supported_interfaces);\n\n\tconfig->mac_capabilities = MAC_SYM_PAUSE | MAC_10 | MAC_100 |\n\t\t\t\t   MAC_1000FD;\n}\n\nstatic const u8 mv88e6xxx_phy_interface_modes[] = {\n\t[MV88E6XXX_PORT_STS_CMODE_MII_PHY]\t= PHY_INTERFACE_MODE_REVMII,\n\t[MV88E6XXX_PORT_STS_CMODE_MII]\t\t= PHY_INTERFACE_MODE_MII,\n\t[MV88E6XXX_PORT_STS_CMODE_GMII]\t\t= PHY_INTERFACE_MODE_GMII,\n\t[MV88E6XXX_PORT_STS_CMODE_RMII_PHY]\t= PHY_INTERFACE_MODE_REVRMII,\n\t[MV88E6XXX_PORT_STS_CMODE_RMII]\t\t= PHY_INTERFACE_MODE_RMII,\n\t[MV88E6XXX_PORT_STS_CMODE_100BASEX]\t= PHY_INTERFACE_MODE_100BASEX,\n\t[MV88E6XXX_PORT_STS_CMODE_1000BASEX]\t= PHY_INTERFACE_MODE_1000BASEX,\n\t[MV88E6XXX_PORT_STS_CMODE_SGMII]\t= PHY_INTERFACE_MODE_SGMII,\n\t \n};\n\nstatic void mv88e6xxx_translate_cmode(u8 cmode, unsigned long *supported)\n{\n\tif (cmode < ARRAY_SIZE(mv88e6xxx_phy_interface_modes) &&\n\t    mv88e6xxx_phy_interface_modes[cmode])\n\t\t__set_bit(mv88e6xxx_phy_interface_modes[cmode], supported);\n\telse if (cmode == MV88E6XXX_PORT_STS_CMODE_RGMII)\n\t\tphy_interface_set_rgmii(supported);\n}\n\nstatic void mv88e6250_phylink_get_caps(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t       struct phylink_config *config)\n{\n\tunsigned long *supported = config->supported_interfaces;\n\n\t \n\tmv88e6xxx_translate_cmode(chip->ports[port].cmode, supported);\n\n\tconfig->mac_capabilities = MAC_SYM_PAUSE | MAC_10 | MAC_100;\n}\n\nstatic void mv88e6351_phylink_get_caps(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t       struct phylink_config *config)\n{\n\tunsigned long *supported = config->supported_interfaces;\n\n\t \n\tmv88e6xxx_translate_cmode(chip->ports[port].cmode, supported);\n\n\tconfig->mac_capabilities = MAC_SYM_PAUSE | MAC_10 | MAC_100 |\n\t\t\t\t   MAC_1000FD;\n}\n\nstatic int mv88e6352_get_port4_serdes_cmode(struct mv88e6xxx_chip *chip)\n{\n\tu16 reg, val;\n\tint err;\n\n\terr = mv88e6xxx_port_read(chip, 4, MV88E6XXX_PORT_STS, &reg);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!(reg & MV88E6XXX_PORT_STS_PHY_DETECT))\n\t\treturn 0xf;\n\n\tval = reg & ~MV88E6XXX_PORT_STS_PHY_DETECT;\n\terr = mv88e6xxx_port_write(chip, 4, MV88E6XXX_PORT_STS, val);\n\tif (err)\n\t\treturn err;\n\n\terr = mv88e6xxx_port_read(chip, 4, MV88E6XXX_PORT_STS, &val);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = mv88e6xxx_port_write(chip, 4, MV88E6XXX_PORT_STS, reg);\n\tif (err)\n\t\treturn err;\n\n\treturn val & MV88E6XXX_PORT_STS_CMODE_MASK;\n}\n\nstatic void mv88e6352_phylink_get_caps(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t       struct phylink_config *config)\n{\n\tunsigned long *supported = config->supported_interfaces;\n\tint err, cmode;\n\n\t \n\tmv88e6xxx_translate_cmode(chip->ports[port].cmode, supported);\n\n\tconfig->mac_capabilities = MAC_SYM_PAUSE | MAC_10 | MAC_100 |\n\t\t\t\t   MAC_1000FD;\n\n\t \n\tif (port == 4) {\n\t\terr = mv88e6352_g2_scratch_port_has_serdes(chip, port);\n\t\tif (err < 0)\n\t\t\tdev_err(chip->dev, \"p%d: failed to read scratch\\n\",\n\t\t\t\tport);\n\t\tif (err <= 0)\n\t\t\treturn;\n\n\t\tcmode = mv88e6352_get_port4_serdes_cmode(chip);\n\t\tif (cmode < 0)\n\t\t\tdev_err(chip->dev, \"p%d: failed to read serdes cmode\\n\",\n\t\t\t\tport);\n\t\telse\n\t\t\tmv88e6xxx_translate_cmode(cmode, supported);\n\t}\n}\n\nstatic void mv88e6341_phylink_get_caps(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t       struct phylink_config *config)\n{\n\tunsigned long *supported = config->supported_interfaces;\n\n\t \n\tmv88e6xxx_translate_cmode(chip->ports[port].cmode, supported);\n\n\t \n\tconfig->mac_capabilities = MAC_SYM_PAUSE | MAC_10 | MAC_100 |\n\t\t\t\t   MAC_1000FD;\n\n\t \n\tif (port == 5) {\n\t\t__set_bit(PHY_INTERFACE_MODE_SGMII, supported);\n\t\t__set_bit(PHY_INTERFACE_MODE_1000BASEX, supported);\n\t\t__set_bit(PHY_INTERFACE_MODE_2500BASEX, supported);\n\n\t\tconfig->mac_capabilities |= MAC_2500FD;\n\t}\n}\n\nstatic void mv88e6390_phylink_get_caps(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t       struct phylink_config *config)\n{\n\tunsigned long *supported = config->supported_interfaces;\n\n\t \n\tmv88e6xxx_translate_cmode(chip->ports[port].cmode, supported);\n\n\t \n\tconfig->mac_capabilities = MAC_SYM_PAUSE | MAC_10 | MAC_100 |\n\t\t\t\t   MAC_1000FD;\n\n\t \n\tif (port == 9 || port == 10) {\n\t\t__set_bit(PHY_INTERFACE_MODE_SGMII, supported);\n\t\t__set_bit(PHY_INTERFACE_MODE_1000BASEX, supported);\n\t\t__set_bit(PHY_INTERFACE_MODE_2500BASEX, supported);\n\n\t\tconfig->mac_capabilities |= MAC_2500FD;\n\t}\n}\n\nstatic void mv88e6390x_phylink_get_caps(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t\tstruct phylink_config *config)\n{\n\tunsigned long *supported = config->supported_interfaces;\n\n\tmv88e6390_phylink_get_caps(chip, port, config);\n\n\t \n\tif (port >= 2 && port <= 7)\n\t\t__set_bit(PHY_INTERFACE_MODE_1000BASEX, supported);\n\n\t \n\tif (port == 9 || port == 10) {\n\t\t__set_bit(PHY_INTERFACE_MODE_XAUI, supported);\n\t\t__set_bit(PHY_INTERFACE_MODE_RXAUI, supported);\n\n\t\tconfig->mac_capabilities |= MAC_10000FD;\n\t}\n}\n\nstatic void mv88e6393x_phylink_get_caps(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t\tstruct phylink_config *config)\n{\n\tunsigned long *supported = config->supported_interfaces;\n\tbool is_6191x =\n\t\tchip->info->prod_num == MV88E6XXX_PORT_SWITCH_ID_PROD_6191X;\n\tbool is_6361 =\n\t\tchip->info->prod_num == MV88E6XXX_PORT_SWITCH_ID_PROD_6361;\n\n\tmv88e6xxx_translate_cmode(chip->ports[port].cmode, supported);\n\n\tconfig->mac_capabilities = MAC_SYM_PAUSE | MAC_10 | MAC_100 |\n\t\t\t\t   MAC_1000FD;\n\n\t \n\tif (port == 0 || port == 9 || port == 10) {\n\t\t__set_bit(PHY_INTERFACE_MODE_SGMII, supported);\n\t\t__set_bit(PHY_INTERFACE_MODE_1000BASEX, supported);\n\n\t\t \n\t\tif (!is_6191x || port == 10) {\n\t\t\t__set_bit(PHY_INTERFACE_MODE_2500BASEX, supported);\n\t\t\tconfig->mac_capabilities |= MAC_2500FD;\n\n\t\t\t \n\t\t\tif (!is_6361) {\n\t\t\t\t__set_bit(PHY_INTERFACE_MODE_5GBASER, supported);\n\t\t\t\t__set_bit(PHY_INTERFACE_MODE_10GBASER, supported);\n\t\t\t\t__set_bit(PHY_INTERFACE_MODE_USXGMII, supported);\n\t\t\t\tconfig->mac_capabilities |= MAC_5000FD |\n\t\t\t\t\tMAC_10000FD;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (port == 0) {\n\t\t__set_bit(PHY_INTERFACE_MODE_RMII, supported);\n\t\t__set_bit(PHY_INTERFACE_MODE_RGMII, supported);\n\t\t__set_bit(PHY_INTERFACE_MODE_RGMII_ID, supported);\n\t\t__set_bit(PHY_INTERFACE_MODE_RGMII_RXID, supported);\n\t\t__set_bit(PHY_INTERFACE_MODE_RGMII_TXID, supported);\n\t}\n}\n\nstatic void mv88e6xxx_get_caps(struct dsa_switch *ds, int port,\n\t\t\t       struct phylink_config *config)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\n\tmv88e6xxx_reg_lock(chip);\n\tchip->info->ops->phylink_get_caps(chip, port, config);\n\tmv88e6xxx_reg_unlock(chip);\n\n\tif (mv88e6xxx_phy_is_internal(chip, port)) {\n\t\t__set_bit(PHY_INTERFACE_MODE_INTERNAL,\n\t\t\t  config->supported_interfaces);\n\t\t \n\t\t__set_bit(PHY_INTERFACE_MODE_GMII,\n\t\t\t  config->supported_interfaces);\n\t}\n}\n\nstatic struct phylink_pcs *mv88e6xxx_mac_select_pcs(struct dsa_switch *ds,\n\t\t\t\t\t\t    int port,\n\t\t\t\t\t\t    phy_interface_t interface)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tstruct phylink_pcs *pcs = ERR_PTR(-EOPNOTSUPP);\n\n\tif (chip->info->ops->pcs_ops)\n\t\tpcs = chip->info->ops->pcs_ops->pcs_select(chip, port,\n\t\t\t\t\t\t\t   interface);\n\n\treturn pcs;\n}\n\nstatic int mv88e6xxx_mac_prepare(struct dsa_switch *ds, int port,\n\t\t\t\t unsigned int mode, phy_interface_t interface)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err = 0;\n\n\t \n\tif (mode == MLO_AN_INBAND &&\n\t    chip->ports[port].interface != interface &&\n\t    chip->info->ops->port_set_link) {\n\t\tmv88e6xxx_reg_lock(chip);\n\t\terr = chip->info->ops->port_set_link(chip, port,\n\t\t\t\t\t\t     LINK_FORCED_DOWN);\n\t\tmv88e6xxx_reg_unlock(chip);\n\t}\n\n\treturn err;\n}\n\nstatic void mv88e6xxx_mac_config(struct dsa_switch *ds, int port,\n\t\t\t\t unsigned int mode,\n\t\t\t\t const struct phylink_link_state *state)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err = 0;\n\n\tmv88e6xxx_reg_lock(chip);\n\n\tif (mode != MLO_AN_PHY || !mv88e6xxx_phy_is_internal(chip, port)) {\n\t\terr = mv88e6xxx_port_config_interface(chip, port,\n\t\t\t\t\t\t      state->interface);\n\t\tif (err && err != -EOPNOTSUPP)\n\t\t\tgoto err_unlock;\n\t}\n\nerr_unlock:\n\tmv88e6xxx_reg_unlock(chip);\n\n\tif (err && err != -EOPNOTSUPP)\n\t\tdev_err(ds->dev, \"p%d: failed to configure MAC/PCS\\n\", port);\n}\n\nstatic int mv88e6xxx_mac_finish(struct dsa_switch *ds, int port,\n\t\t\t\tunsigned int mode, phy_interface_t interface)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err = 0;\n\n\t \n\tmv88e6xxx_reg_lock(chip);\n\n\tif (chip->info->ops->port_set_link &&\n\t    ((mode == MLO_AN_INBAND &&\n\t      chip->ports[port].interface != interface) ||\n\t     (mode == MLO_AN_PHY && mv88e6xxx_port_ppu_updates(chip, port))))\n\t\terr = chip->info->ops->port_set_link(chip, port, LINK_UNFORCED);\n\n\tmv88e6xxx_reg_unlock(chip);\n\n\tchip->ports[port].interface = interface;\n\n\treturn err;\n}\n\nstatic void mv88e6xxx_mac_link_down(struct dsa_switch *ds, int port,\n\t\t\t\t    unsigned int mode,\n\t\t\t\t    phy_interface_t interface)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tconst struct mv88e6xxx_ops *ops;\n\tint err = 0;\n\n\tops = chip->info->ops;\n\n\tmv88e6xxx_reg_lock(chip);\n\t \n\tif ((!mv88e6xxx_port_ppu_updates(chip, port) ||\n\t     mode == MLO_AN_FIXED) && ops->port_sync_link)\n\t\terr = ops->port_sync_link(chip, port, mode, false);\n\n\tif (!err && ops->port_set_speed_duplex)\n\t\terr = ops->port_set_speed_duplex(chip, port, SPEED_UNFORCED,\n\t\t\t\t\t\t DUPLEX_UNFORCED);\n\tmv88e6xxx_reg_unlock(chip);\n\n\tif (err)\n\t\tdev_err(chip->dev,\n\t\t\t\"p%d: failed to force MAC link down\\n\", port);\n}\n\nstatic void mv88e6xxx_mac_link_up(struct dsa_switch *ds, int port,\n\t\t\t\t  unsigned int mode, phy_interface_t interface,\n\t\t\t\t  struct phy_device *phydev,\n\t\t\t\t  int speed, int duplex,\n\t\t\t\t  bool tx_pause, bool rx_pause)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tconst struct mv88e6xxx_ops *ops;\n\tint err = 0;\n\n\tops = chip->info->ops;\n\n\tmv88e6xxx_reg_lock(chip);\n\t \n\tif (!mv88e6xxx_port_ppu_updates(chip, port) ||\n\t    mode == MLO_AN_FIXED) {\n\t\tif (ops->port_set_speed_duplex) {\n\t\t\terr = ops->port_set_speed_duplex(chip, port,\n\t\t\t\t\t\t\t speed, duplex);\n\t\t\tif (err && err != -EOPNOTSUPP)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tif (ops->port_sync_link)\n\t\t\terr = ops->port_sync_link(chip, port, mode, true);\n\t}\nerror:\n\tmv88e6xxx_reg_unlock(chip);\n\n\tif (err && err != -EOPNOTSUPP)\n\t\tdev_err(ds->dev,\n\t\t\t\"p%d: failed to configure MAC link up\\n\", port);\n}\n\nstatic int mv88e6xxx_stats_snapshot(struct mv88e6xxx_chip *chip, int port)\n{\n\tif (!chip->info->ops->stats_snapshot)\n\t\treturn -EOPNOTSUPP;\n\n\treturn chip->info->ops->stats_snapshot(chip, port);\n}\n\nstatic struct mv88e6xxx_hw_stat mv88e6xxx_hw_stats[] = {\n\t{ \"in_good_octets\",\t\t8, 0x00, STATS_TYPE_BANK0, },\n\t{ \"in_bad_octets\",\t\t4, 0x02, STATS_TYPE_BANK0, },\n\t{ \"in_unicast\",\t\t\t4, 0x04, STATS_TYPE_BANK0, },\n\t{ \"in_broadcasts\",\t\t4, 0x06, STATS_TYPE_BANK0, },\n\t{ \"in_multicasts\",\t\t4, 0x07, STATS_TYPE_BANK0, },\n\t{ \"in_pause\",\t\t\t4, 0x16, STATS_TYPE_BANK0, },\n\t{ \"in_undersize\",\t\t4, 0x18, STATS_TYPE_BANK0, },\n\t{ \"in_fragments\",\t\t4, 0x19, STATS_TYPE_BANK0, },\n\t{ \"in_oversize\",\t\t4, 0x1a, STATS_TYPE_BANK0, },\n\t{ \"in_jabber\",\t\t\t4, 0x1b, STATS_TYPE_BANK0, },\n\t{ \"in_rx_error\",\t\t4, 0x1c, STATS_TYPE_BANK0, },\n\t{ \"in_fcs_error\",\t\t4, 0x1d, STATS_TYPE_BANK0, },\n\t{ \"out_octets\",\t\t\t8, 0x0e, STATS_TYPE_BANK0, },\n\t{ \"out_unicast\",\t\t4, 0x10, STATS_TYPE_BANK0, },\n\t{ \"out_broadcasts\",\t\t4, 0x13, STATS_TYPE_BANK0, },\n\t{ \"out_multicasts\",\t\t4, 0x12, STATS_TYPE_BANK0, },\n\t{ \"out_pause\",\t\t\t4, 0x15, STATS_TYPE_BANK0, },\n\t{ \"excessive\",\t\t\t4, 0x11, STATS_TYPE_BANK0, },\n\t{ \"collisions\",\t\t\t4, 0x1e, STATS_TYPE_BANK0, },\n\t{ \"deferred\",\t\t\t4, 0x05, STATS_TYPE_BANK0, },\n\t{ \"single\",\t\t\t4, 0x14, STATS_TYPE_BANK0, },\n\t{ \"multiple\",\t\t\t4, 0x17, STATS_TYPE_BANK0, },\n\t{ \"out_fcs_error\",\t\t4, 0x03, STATS_TYPE_BANK0, },\n\t{ \"late\",\t\t\t4, 0x1f, STATS_TYPE_BANK0, },\n\t{ \"hist_64bytes\",\t\t4, 0x08, STATS_TYPE_BANK0, },\n\t{ \"hist_65_127bytes\",\t\t4, 0x09, STATS_TYPE_BANK0, },\n\t{ \"hist_128_255bytes\",\t\t4, 0x0a, STATS_TYPE_BANK0, },\n\t{ \"hist_256_511bytes\",\t\t4, 0x0b, STATS_TYPE_BANK0, },\n\t{ \"hist_512_1023bytes\",\t\t4, 0x0c, STATS_TYPE_BANK0, },\n\t{ \"hist_1024_max_bytes\",\t4, 0x0d, STATS_TYPE_BANK0, },\n\t{ \"sw_in_discards\",\t\t4, 0x10, STATS_TYPE_PORT, },\n\t{ \"sw_in_filtered\",\t\t2, 0x12, STATS_TYPE_PORT, },\n\t{ \"sw_out_filtered\",\t\t2, 0x13, STATS_TYPE_PORT, },\n\t{ \"in_discards\",\t\t4, 0x00, STATS_TYPE_BANK1, },\n\t{ \"in_filtered\",\t\t4, 0x01, STATS_TYPE_BANK1, },\n\t{ \"in_accepted\",\t\t4, 0x02, STATS_TYPE_BANK1, },\n\t{ \"in_bad_accepted\",\t\t4, 0x03, STATS_TYPE_BANK1, },\n\t{ \"in_good_avb_class_a\",\t4, 0x04, STATS_TYPE_BANK1, },\n\t{ \"in_good_avb_class_b\",\t4, 0x05, STATS_TYPE_BANK1, },\n\t{ \"in_bad_avb_class_a\",\t\t4, 0x06, STATS_TYPE_BANK1, },\n\t{ \"in_bad_avb_class_b\",\t\t4, 0x07, STATS_TYPE_BANK1, },\n\t{ \"tcam_counter_0\",\t\t4, 0x08, STATS_TYPE_BANK1, },\n\t{ \"tcam_counter_1\",\t\t4, 0x09, STATS_TYPE_BANK1, },\n\t{ \"tcam_counter_2\",\t\t4, 0x0a, STATS_TYPE_BANK1, },\n\t{ \"tcam_counter_3\",\t\t4, 0x0b, STATS_TYPE_BANK1, },\n\t{ \"in_da_unknown\",\t\t4, 0x0e, STATS_TYPE_BANK1, },\n\t{ \"in_management\",\t\t4, 0x0f, STATS_TYPE_BANK1, },\n\t{ \"out_queue_0\",\t\t4, 0x10, STATS_TYPE_BANK1, },\n\t{ \"out_queue_1\",\t\t4, 0x11, STATS_TYPE_BANK1, },\n\t{ \"out_queue_2\",\t\t4, 0x12, STATS_TYPE_BANK1, },\n\t{ \"out_queue_3\",\t\t4, 0x13, STATS_TYPE_BANK1, },\n\t{ \"out_queue_4\",\t\t4, 0x14, STATS_TYPE_BANK1, },\n\t{ \"out_queue_5\",\t\t4, 0x15, STATS_TYPE_BANK1, },\n\t{ \"out_queue_6\",\t\t4, 0x16, STATS_TYPE_BANK1, },\n\t{ \"out_queue_7\",\t\t4, 0x17, STATS_TYPE_BANK1, },\n\t{ \"out_cut_through\",\t\t4, 0x18, STATS_TYPE_BANK1, },\n\t{ \"out_octets_a\",\t\t4, 0x1a, STATS_TYPE_BANK1, },\n\t{ \"out_octets_b\",\t\t4, 0x1b, STATS_TYPE_BANK1, },\n\t{ \"out_management\",\t\t4, 0x1f, STATS_TYPE_BANK1, },\n};\n\nstatic uint64_t _mv88e6xxx_get_ethtool_stat(struct mv88e6xxx_chip *chip,\n\t\t\t\t\t    struct mv88e6xxx_hw_stat *s,\n\t\t\t\t\t    int port, u16 bank1_select,\n\t\t\t\t\t    u16 histogram)\n{\n\tu32 low;\n\tu32 high = 0;\n\tu16 reg = 0;\n\tint err;\n\tu64 value;\n\n\tswitch (s->type) {\n\tcase STATS_TYPE_PORT:\n\t\terr = mv88e6xxx_port_read(chip, port, s->reg, &reg);\n\t\tif (err)\n\t\t\treturn U64_MAX;\n\n\t\tlow = reg;\n\t\tif (s->size == 4) {\n\t\t\terr = mv88e6xxx_port_read(chip, port, s->reg + 1, &reg);\n\t\t\tif (err)\n\t\t\t\treturn U64_MAX;\n\t\t\tlow |= ((u32)reg) << 16;\n\t\t}\n\t\tbreak;\n\tcase STATS_TYPE_BANK1:\n\t\treg = bank1_select;\n\t\tfallthrough;\n\tcase STATS_TYPE_BANK0:\n\t\treg |= s->reg | histogram;\n\t\tmv88e6xxx_g1_stats_read(chip, reg, &low);\n\t\tif (s->size == 8)\n\t\t\tmv88e6xxx_g1_stats_read(chip, reg + 1, &high);\n\t\tbreak;\n\tdefault:\n\t\treturn U64_MAX;\n\t}\n\tvalue = (((u64)high) << 32) | low;\n\treturn value;\n}\n\nstatic int mv88e6xxx_stats_get_strings(struct mv88e6xxx_chip *chip,\n\t\t\t\t       uint8_t *data, int types)\n{\n\tstruct mv88e6xxx_hw_stat *stat;\n\tint i, j;\n\n\tfor (i = 0, j = 0; i < ARRAY_SIZE(mv88e6xxx_hw_stats); i++) {\n\t\tstat = &mv88e6xxx_hw_stats[i];\n\t\tif (stat->type & types) {\n\t\t\tmemcpy(data + j * ETH_GSTRING_LEN, stat->string,\n\t\t\t       ETH_GSTRING_LEN);\n\t\t\tj++;\n\t\t}\n\t}\n\n\treturn j;\n}\n\nstatic int mv88e6095_stats_get_strings(struct mv88e6xxx_chip *chip,\n\t\t\t\t       uint8_t *data)\n{\n\treturn mv88e6xxx_stats_get_strings(chip, data,\n\t\t\t\t\t   STATS_TYPE_BANK0 | STATS_TYPE_PORT);\n}\n\nstatic int mv88e6250_stats_get_strings(struct mv88e6xxx_chip *chip,\n\t\t\t\t       uint8_t *data)\n{\n\treturn mv88e6xxx_stats_get_strings(chip, data, STATS_TYPE_BANK0);\n}\n\nstatic int mv88e6320_stats_get_strings(struct mv88e6xxx_chip *chip,\n\t\t\t\t       uint8_t *data)\n{\n\treturn mv88e6xxx_stats_get_strings(chip, data,\n\t\t\t\t\t   STATS_TYPE_BANK0 | STATS_TYPE_BANK1);\n}\n\nstatic const uint8_t *mv88e6xxx_atu_vtu_stats_strings[] = {\n\t\"atu_member_violation\",\n\t\"atu_miss_violation\",\n\t\"atu_full_violation\",\n\t\"vtu_member_violation\",\n\t\"vtu_miss_violation\",\n};\n\nstatic void mv88e6xxx_atu_vtu_get_strings(uint8_t *data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mv88e6xxx_atu_vtu_stats_strings); i++)\n\t\tstrscpy(data + i * ETH_GSTRING_LEN,\n\t\t\tmv88e6xxx_atu_vtu_stats_strings[i],\n\t\t\tETH_GSTRING_LEN);\n}\n\nstatic void mv88e6xxx_get_strings(struct dsa_switch *ds, int port,\n\t\t\t\t  u32 stringset, uint8_t *data)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint count = 0;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tmv88e6xxx_reg_lock(chip);\n\n\tif (chip->info->ops->stats_get_strings)\n\t\tcount = chip->info->ops->stats_get_strings(chip, data);\n\n\tif (chip->info->ops->serdes_get_strings) {\n\t\tdata += count * ETH_GSTRING_LEN;\n\t\tcount = chip->info->ops->serdes_get_strings(chip, port, data);\n\t}\n\n\tdata += count * ETH_GSTRING_LEN;\n\tmv88e6xxx_atu_vtu_get_strings(data);\n\n\tmv88e6xxx_reg_unlock(chip);\n}\n\nstatic int mv88e6xxx_stats_get_sset_count(struct mv88e6xxx_chip *chip,\n\t\t\t\t\t  int types)\n{\n\tstruct mv88e6xxx_hw_stat *stat;\n\tint i, j;\n\n\tfor (i = 0, j = 0; i < ARRAY_SIZE(mv88e6xxx_hw_stats); i++) {\n\t\tstat = &mv88e6xxx_hw_stats[i];\n\t\tif (stat->type & types)\n\t\t\tj++;\n\t}\n\treturn j;\n}\n\nstatic int mv88e6095_stats_get_sset_count(struct mv88e6xxx_chip *chip)\n{\n\treturn mv88e6xxx_stats_get_sset_count(chip, STATS_TYPE_BANK0 |\n\t\t\t\t\t      STATS_TYPE_PORT);\n}\n\nstatic int mv88e6250_stats_get_sset_count(struct mv88e6xxx_chip *chip)\n{\n\treturn mv88e6xxx_stats_get_sset_count(chip, STATS_TYPE_BANK0);\n}\n\nstatic int mv88e6320_stats_get_sset_count(struct mv88e6xxx_chip *chip)\n{\n\treturn mv88e6xxx_stats_get_sset_count(chip, STATS_TYPE_BANK0 |\n\t\t\t\t\t      STATS_TYPE_BANK1);\n}\n\nstatic int mv88e6xxx_get_sset_count(struct dsa_switch *ds, int port, int sset)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint serdes_count = 0;\n\tint count = 0;\n\n\tif (sset != ETH_SS_STATS)\n\t\treturn 0;\n\n\tmv88e6xxx_reg_lock(chip);\n\tif (chip->info->ops->stats_get_sset_count)\n\t\tcount = chip->info->ops->stats_get_sset_count(chip);\n\tif (count < 0)\n\t\tgoto out;\n\n\tif (chip->info->ops->serdes_get_sset_count)\n\t\tserdes_count = chip->info->ops->serdes_get_sset_count(chip,\n\t\t\t\t\t\t\t\t      port);\n\tif (serdes_count < 0) {\n\t\tcount = serdes_count;\n\t\tgoto out;\n\t}\n\tcount += serdes_count;\n\tcount += ARRAY_SIZE(mv88e6xxx_atu_vtu_stats_strings);\n\nout:\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn count;\n}\n\nstatic int mv88e6xxx_stats_get_stats(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t     uint64_t *data, int types,\n\t\t\t\t     u16 bank1_select, u16 histogram)\n{\n\tstruct mv88e6xxx_hw_stat *stat;\n\tint i, j;\n\n\tfor (i = 0, j = 0; i < ARRAY_SIZE(mv88e6xxx_hw_stats); i++) {\n\t\tstat = &mv88e6xxx_hw_stats[i];\n\t\tif (stat->type & types) {\n\t\t\tmv88e6xxx_reg_lock(chip);\n\t\t\tdata[j] = _mv88e6xxx_get_ethtool_stat(chip, stat, port,\n\t\t\t\t\t\t\t      bank1_select,\n\t\t\t\t\t\t\t      histogram);\n\t\t\tmv88e6xxx_reg_unlock(chip);\n\n\t\t\tj++;\n\t\t}\n\t}\n\treturn j;\n}\n\nstatic int mv88e6095_stats_get_stats(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t     uint64_t *data)\n{\n\treturn mv88e6xxx_stats_get_stats(chip, port, data,\n\t\t\t\t\t STATS_TYPE_BANK0 | STATS_TYPE_PORT,\n\t\t\t\t\t 0, MV88E6XXX_G1_STATS_OP_HIST_RX_TX);\n}\n\nstatic int mv88e6250_stats_get_stats(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t     uint64_t *data)\n{\n\treturn mv88e6xxx_stats_get_stats(chip, port, data, STATS_TYPE_BANK0,\n\t\t\t\t\t 0, MV88E6XXX_G1_STATS_OP_HIST_RX_TX);\n}\n\nstatic int mv88e6320_stats_get_stats(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t     uint64_t *data)\n{\n\treturn mv88e6xxx_stats_get_stats(chip, port, data,\n\t\t\t\t\t STATS_TYPE_BANK0 | STATS_TYPE_BANK1,\n\t\t\t\t\t MV88E6XXX_G1_STATS_OP_BANK_1_BIT_9,\n\t\t\t\t\t MV88E6XXX_G1_STATS_OP_HIST_RX_TX);\n}\n\nstatic int mv88e6390_stats_get_stats(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t     uint64_t *data)\n{\n\treturn mv88e6xxx_stats_get_stats(chip, port, data,\n\t\t\t\t\t STATS_TYPE_BANK0 | STATS_TYPE_BANK1,\n\t\t\t\t\t MV88E6XXX_G1_STATS_OP_BANK_1_BIT_10,\n\t\t\t\t\t 0);\n}\n\nstatic void mv88e6xxx_atu_vtu_get_stats(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t\tuint64_t *data)\n{\n\t*data++ = chip->ports[port].atu_member_violation;\n\t*data++ = chip->ports[port].atu_miss_violation;\n\t*data++ = chip->ports[port].atu_full_violation;\n\t*data++ = chip->ports[port].vtu_member_violation;\n\t*data++ = chip->ports[port].vtu_miss_violation;\n}\n\nstatic void mv88e6xxx_get_stats(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\tuint64_t *data)\n{\n\tint count = 0;\n\n\tif (chip->info->ops->stats_get_stats)\n\t\tcount = chip->info->ops->stats_get_stats(chip, port, data);\n\n\tmv88e6xxx_reg_lock(chip);\n\tif (chip->info->ops->serdes_get_stats) {\n\t\tdata += count;\n\t\tcount = chip->info->ops->serdes_get_stats(chip, port, data);\n\t}\n\tdata += count;\n\tmv88e6xxx_atu_vtu_get_stats(chip, port, data);\n\tmv88e6xxx_reg_unlock(chip);\n}\n\nstatic void mv88e6xxx_get_ethtool_stats(struct dsa_switch *ds, int port,\n\t\t\t\t\tuint64_t *data)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint ret;\n\n\tmv88e6xxx_reg_lock(chip);\n\n\tret = mv88e6xxx_stats_snapshot(chip, port);\n\tmv88e6xxx_reg_unlock(chip);\n\n\tif (ret < 0)\n\t\treturn;\n\n\tmv88e6xxx_get_stats(chip, port, data);\n\n}\n\nstatic int mv88e6xxx_get_regs_len(struct dsa_switch *ds, int port)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint len;\n\n\tlen = 32 * sizeof(u16);\n\tif (chip->info->ops->serdes_get_regs_len)\n\t\tlen += chip->info->ops->serdes_get_regs_len(chip, port);\n\n\treturn len;\n}\n\nstatic void mv88e6xxx_get_regs(struct dsa_switch *ds, int port,\n\t\t\t       struct ethtool_regs *regs, void *_p)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err;\n\tu16 reg;\n\tu16 *p = _p;\n\tint i;\n\n\tregs->version = chip->info->prod_num;\n\n\tmemset(p, 0xff, 32 * sizeof(u16));\n\n\tmv88e6xxx_reg_lock(chip);\n\n\tfor (i = 0; i < 32; i++) {\n\n\t\terr = mv88e6xxx_port_read(chip, port, i, &reg);\n\t\tif (!err)\n\t\t\tp[i] = reg;\n\t}\n\n\tif (chip->info->ops->serdes_get_regs)\n\t\tchip->info->ops->serdes_get_regs(chip, port, &p[i]);\n\n\tmv88e6xxx_reg_unlock(chip);\n}\n\nstatic int mv88e6xxx_get_mac_eee(struct dsa_switch *ds, int port,\n\t\t\t\t struct ethtool_eee *e)\n{\n\t \n\treturn 0;\n}\n\nstatic int mv88e6xxx_set_mac_eee(struct dsa_switch *ds, int port,\n\t\t\t\t struct ethtool_eee *e)\n{\n\t \n\treturn 0;\n}\n\n \nstatic u16 mv88e6xxx_port_vlan(struct mv88e6xxx_chip *chip, int dev, int port)\n{\n\tstruct dsa_switch *ds = chip->ds;\n\tstruct dsa_switch_tree *dst = ds->dst;\n\tstruct dsa_port *dp, *other_dp;\n\tbool found = false;\n\tu16 pvlan;\n\n\t \n\tif (dev <= dst->last_switch) {\n\t\tlist_for_each_entry(dp, &dst->ports, list) {\n\t\t\tif (dp->ds->index == dev && dp->index == port) {\n\t\t\t\t \n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t \n\t} else {\n\t\tlist_for_each_entry(dp, &dst->ports, list) {\n\t\t\tunsigned int bridge_num = dsa_port_bridge_num_get(dp);\n\n\t\t\tif (!bridge_num)\n\t\t\t\tcontinue;\n\n\t\t\tif (bridge_num + dst->last_switch != dev)\n\t\t\t\tcontinue;\n\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!found)\n\t\treturn 0;\n\n\t \n\tif (dp->type == DSA_PORT_TYPE_CPU || dp->type == DSA_PORT_TYPE_DSA)\n\t\treturn mv88e6xxx_port_mask(chip);\n\n\tpvlan = 0;\n\n\t \n\tif (!dsa_port_bridge_dev_get(dp))\n\t\treturn BIT(dsa_switch_upstream_port(ds));\n\n\t \n\tdsa_switch_for_each_port(other_dp, ds)\n\t\tif (other_dp->type == DSA_PORT_TYPE_CPU ||\n\t\t    other_dp->type == DSA_PORT_TYPE_DSA ||\n\t\t    dsa_port_bridge_same(dp, other_dp))\n\t\t\tpvlan |= BIT(other_dp->index);\n\n\treturn pvlan;\n}\n\nstatic int mv88e6xxx_port_vlan_map(struct mv88e6xxx_chip *chip, int port)\n{\n\tu16 output_ports = mv88e6xxx_port_vlan(chip, chip->ds->index, port);\n\n\t \n\toutput_ports &= ~BIT(port);\n\n\treturn mv88e6xxx_port_set_vlan_map(chip, port, output_ports);\n}\n\nstatic void mv88e6xxx_port_stp_state_set(struct dsa_switch *ds, int port,\n\t\t\t\t\t u8 state)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = mv88e6xxx_port_set_state(chip, port, state);\n\tmv88e6xxx_reg_unlock(chip);\n\n\tif (err)\n\t\tdev_err(ds->dev, \"p%d: failed to update state\\n\", port);\n}\n\nstatic int mv88e6xxx_pri_setup(struct mv88e6xxx_chip *chip)\n{\n\tint err;\n\n\tif (chip->info->ops->ieee_pri_map) {\n\t\terr = chip->info->ops->ieee_pri_map(chip);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (chip->info->ops->ip_pri_map) {\n\t\terr = chip->info->ops->ip_pri_map(chip);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_devmap_setup(struct mv88e6xxx_chip *chip)\n{\n\tstruct dsa_switch *ds = chip->ds;\n\tint target, port;\n\tint err;\n\n\tif (!chip->info->global2_addr)\n\t\treturn 0;\n\n\t \n\tfor (target = 0; target < 32; target++) {\n\t\tport = dsa_routing_port(ds, target);\n\t\tif (port == ds->num_ports)\n\t\t\tport = 0x1f;\n\n\t\terr = mv88e6xxx_g2_device_mapping_write(chip, target, port);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (chip->info->ops->set_cascade_port) {\n\t\tport = MV88E6XXX_CASCADE_PORT_MULTIPLE;\n\t\terr = chip->info->ops->set_cascade_port(chip, port);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = mv88e6xxx_g1_set_device_number(chip, chip->ds->index);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_trunk_setup(struct mv88e6xxx_chip *chip)\n{\n\t \n\tif (chip->info->global2_addr)\n\t\treturn mv88e6xxx_g2_trunk_clear(chip);\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_rmu_setup(struct mv88e6xxx_chip *chip)\n{\n\tif (chip->info->ops->rmu_disable)\n\t\treturn chip->info->ops->rmu_disable(chip);\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_pot_setup(struct mv88e6xxx_chip *chip)\n{\n\tif (chip->info->ops->pot_clear)\n\t\treturn chip->info->ops->pot_clear(chip);\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_rsvd2cpu_setup(struct mv88e6xxx_chip *chip)\n{\n\tif (chip->info->ops->mgmt_rsvd2cpu)\n\t\treturn chip->info->ops->mgmt_rsvd2cpu(chip);\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_atu_setup(struct mv88e6xxx_chip *chip)\n{\n\tint err;\n\n\terr = mv88e6xxx_g1_atu_flush(chip, 0, true);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (chip->info->ops->port_setup_message_port) {\n\t\terr = mv88e6xxx_g1_atu_set_learn2all(chip, true);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn mv88e6xxx_g1_atu_set_age_time(chip, 300000);\n}\n\nstatic int mv88e6xxx_irl_setup(struct mv88e6xxx_chip *chip)\n{\n\tint port;\n\tint err;\n\n\tif (!chip->info->ops->irl_init_all)\n\t\treturn 0;\n\n\tfor (port = 0; port < mv88e6xxx_num_ports(chip); port++) {\n\t\t \n\t\terr = chip->info->ops->irl_init_all(chip, port);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_mac_setup(struct mv88e6xxx_chip *chip)\n{\n\tif (chip->info->ops->set_switch_mac) {\n\t\tu8 addr[ETH_ALEN];\n\n\t\teth_random_addr(addr);\n\n\t\treturn chip->info->ops->set_switch_mac(chip, addr);\n\t}\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_pvt_map(struct mv88e6xxx_chip *chip, int dev, int port)\n{\n\tstruct dsa_switch_tree *dst = chip->ds->dst;\n\tstruct dsa_switch *ds;\n\tstruct dsa_port *dp;\n\tu16 pvlan = 0;\n\n\tif (!mv88e6xxx_has_pvt(chip))\n\t\treturn 0;\n\n\t \n\tif (dev != chip->ds->index) {\n\t\tpvlan = mv88e6xxx_port_vlan(chip, dev, port);\n\n\t\tds = dsa_switch_find(dst->index, dev);\n\t\tdp = ds ? dsa_to_port(ds, port) : NULL;\n\t\tif (dp && dp->lag) {\n\t\t\t \n\t\t\tdev = MV88E6XXX_G2_PVT_ADDR_DEV_TRUNK;\n\t\t\tport = dsa_port_lag_id_get(dp) - 1;\n\t\t}\n\t}\n\n\treturn mv88e6xxx_g2_pvt_write(chip, dev, port, pvlan);\n}\n\nstatic int mv88e6xxx_pvt_setup(struct mv88e6xxx_chip *chip)\n{\n\tint dev, port;\n\tint err;\n\n\tif (!mv88e6xxx_has_pvt(chip))\n\t\treturn 0;\n\n\t \n\terr = mv88e6xxx_g2_misc_4_bit_port(chip);\n\tif (err)\n\t\treturn err;\n\n\tfor (dev = 0; dev < MV88E6XXX_MAX_PVT_SWITCHES; ++dev) {\n\t\tfor (port = 0; port < MV88E6XXX_MAX_PVT_PORTS; ++port) {\n\t\t\terr = mv88e6xxx_pvt_map(chip, dev, port);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_port_fast_age_fid(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t       u16 fid)\n{\n\tif (dsa_to_port(chip->ds, port)->lag)\n\t\t \n\t\treturn -EOPNOTSUPP;\n\n\treturn mv88e6xxx_g1_atu_remove(chip, fid, port, false);\n}\n\nstatic void mv88e6xxx_port_fast_age(struct dsa_switch *ds, int port)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = mv88e6xxx_port_fast_age_fid(chip, port, 0);\n\tmv88e6xxx_reg_unlock(chip);\n\n\tif (err)\n\t\tdev_err(chip->ds->dev, \"p%d: failed to flush ATU: %d\\n\",\n\t\t\tport, err);\n}\n\nstatic int mv88e6xxx_vtu_setup(struct mv88e6xxx_chip *chip)\n{\n\tif (!mv88e6xxx_max_vid(chip))\n\t\treturn 0;\n\n\treturn mv88e6xxx_g1_vtu_flush(chip);\n}\n\nstatic int mv88e6xxx_vtu_get(struct mv88e6xxx_chip *chip, u16 vid,\n\t\t\t     struct mv88e6xxx_vtu_entry *entry)\n{\n\tint err;\n\n\tif (!chip->info->ops->vtu_getnext)\n\t\treturn -EOPNOTSUPP;\n\n\tentry->vid = vid ? vid - 1 : mv88e6xxx_max_vid(chip);\n\tentry->valid = false;\n\n\terr = chip->info->ops->vtu_getnext(chip, entry);\n\n\tif (entry->vid != vid)\n\t\tentry->valid = false;\n\n\treturn err;\n}\n\nint mv88e6xxx_vtu_walk(struct mv88e6xxx_chip *chip,\n\t\t       int (*cb)(struct mv88e6xxx_chip *chip,\n\t\t\t\t const struct mv88e6xxx_vtu_entry *entry,\n\t\t\t\t void *priv),\n\t\t       void *priv)\n{\n\tstruct mv88e6xxx_vtu_entry entry = {\n\t\t.vid = mv88e6xxx_max_vid(chip),\n\t\t.valid = false,\n\t};\n\tint err;\n\n\tif (!chip->info->ops->vtu_getnext)\n\t\treturn -EOPNOTSUPP;\n\n\tdo {\n\t\terr = chip->info->ops->vtu_getnext(chip, &entry);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!entry.valid)\n\t\t\tbreak;\n\n\t\terr = cb(chip, &entry, priv);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (entry.vid < mv88e6xxx_max_vid(chip));\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_vtu_loadpurge(struct mv88e6xxx_chip *chip,\n\t\t\t\t   struct mv88e6xxx_vtu_entry *entry)\n{\n\tif (!chip->info->ops->vtu_loadpurge)\n\t\treturn -EOPNOTSUPP;\n\n\treturn chip->info->ops->vtu_loadpurge(chip, entry);\n}\n\nstatic int mv88e6xxx_fid_map_vlan(struct mv88e6xxx_chip *chip,\n\t\t\t\t  const struct mv88e6xxx_vtu_entry *entry,\n\t\t\t\t  void *_fid_bitmap)\n{\n\tunsigned long *fid_bitmap = _fid_bitmap;\n\n\tset_bit(entry->fid, fid_bitmap);\n\treturn 0;\n}\n\nint mv88e6xxx_fid_map(struct mv88e6xxx_chip *chip, unsigned long *fid_bitmap)\n{\n\tbitmap_zero(fid_bitmap, MV88E6XXX_N_FID);\n\n\t \n\treturn mv88e6xxx_vtu_walk(chip, mv88e6xxx_fid_map_vlan, fid_bitmap);\n}\n\nstatic int mv88e6xxx_atu_new(struct mv88e6xxx_chip *chip, u16 *fid)\n{\n\tDECLARE_BITMAP(fid_bitmap, MV88E6XXX_N_FID);\n\tint err;\n\n\terr = mv88e6xxx_fid_map(chip, fid_bitmap);\n\tif (err)\n\t\treturn err;\n\n\t*fid = find_first_zero_bit(fid_bitmap, MV88E6XXX_N_FID);\n\tif (unlikely(*fid >= mv88e6xxx_num_databases(chip)))\n\t\treturn -ENOSPC;\n\n\t \n\treturn mv88e6xxx_g1_atu_flush(chip, *fid, true);\n}\n\nstatic int mv88e6xxx_stu_loadpurge(struct mv88e6xxx_chip *chip,\n\t\t\t\t   struct mv88e6xxx_stu_entry *entry)\n{\n\tif (!chip->info->ops->stu_loadpurge)\n\t\treturn -EOPNOTSUPP;\n\n\treturn chip->info->ops->stu_loadpurge(chip, entry);\n}\n\nstatic int mv88e6xxx_stu_setup(struct mv88e6xxx_chip *chip)\n{\n\tstruct mv88e6xxx_stu_entry stu = {\n\t\t.valid = true,\n\t\t.sid = 0\n\t};\n\n\tif (!mv88e6xxx_has_stu(chip))\n\t\treturn 0;\n\n\t \n\treturn mv88e6xxx_stu_loadpurge(chip, &stu);\n}\n\nstatic int mv88e6xxx_sid_get(struct mv88e6xxx_chip *chip, u8 *sid)\n{\n\tDECLARE_BITMAP(busy, MV88E6XXX_N_SID) = { 0 };\n\tstruct mv88e6xxx_mst *mst;\n\n\t__set_bit(0, busy);\n\n\tlist_for_each_entry(mst, &chip->msts, node)\n\t\t__set_bit(mst->stu.sid, busy);\n\n\t*sid = find_first_zero_bit(busy, MV88E6XXX_N_SID);\n\n\treturn (*sid >= mv88e6xxx_max_sid(chip)) ? -ENOSPC : 0;\n}\n\nstatic int mv88e6xxx_mst_put(struct mv88e6xxx_chip *chip, u8 sid)\n{\n\tstruct mv88e6xxx_mst *mst, *tmp;\n\tint err;\n\n\tif (!sid)\n\t\treturn 0;\n\n\tlist_for_each_entry_safe(mst, tmp, &chip->msts, node) {\n\t\tif (mst->stu.sid != sid)\n\t\t\tcontinue;\n\n\t\tif (!refcount_dec_and_test(&mst->refcnt))\n\t\t\treturn 0;\n\n\t\tmst->stu.valid = false;\n\t\terr = mv88e6xxx_stu_loadpurge(chip, &mst->stu);\n\t\tif (err) {\n\t\t\trefcount_set(&mst->refcnt, 1);\n\t\t\treturn err;\n\t\t}\n\n\t\tlist_del(&mst->node);\n\t\tkfree(mst);\n\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int mv88e6xxx_mst_get(struct mv88e6xxx_chip *chip, struct net_device *br,\n\t\t\t     u16 msti, u8 *sid)\n{\n\tstruct mv88e6xxx_mst *mst;\n\tint err, i;\n\n\tif (!mv88e6xxx_has_stu(chip)) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err;\n\t}\n\n\tif (!msti) {\n\t\t*sid = 0;\n\t\treturn 0;\n\t}\n\n\tlist_for_each_entry(mst, &chip->msts, node) {\n\t\tif (mst->br == br && mst->msti == msti) {\n\t\t\trefcount_inc(&mst->refcnt);\n\t\t\t*sid = mst->stu.sid;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\terr = mv88e6xxx_sid_get(chip, sid);\n\tif (err)\n\t\tgoto err;\n\n\tmst = kzalloc(sizeof(*mst), GFP_KERNEL);\n\tif (!mst) {\n\t\terr = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tINIT_LIST_HEAD(&mst->node);\n\trefcount_set(&mst->refcnt, 1);\n\tmst->br = br;\n\tmst->msti = msti;\n\tmst->stu.valid = true;\n\tmst->stu.sid = *sid;\n\n\t \n\tfor (i = 0; i < mv88e6xxx_num_ports(chip); i++)\n\t\tmst->stu.state[i] = dsa_is_user_port(chip->ds, i) ?\n\t\t\tMV88E6XXX_PORT_CTL0_STATE_BLOCKING :\n\t\t\tMV88E6XXX_PORT_CTL0_STATE_DISABLED;\n\n\terr = mv88e6xxx_stu_loadpurge(chip, &mst->stu);\n\tif (err)\n\t\tgoto err_free;\n\n\tlist_add_tail(&mst->node, &chip->msts);\n\treturn 0;\n\nerr_free:\n\tkfree(mst);\nerr:\n\treturn err;\n}\n\nstatic int mv88e6xxx_port_mst_state_set(struct dsa_switch *ds, int port,\n\t\t\t\t\tconst struct switchdev_mst_state *st)\n{\n\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tstruct mv88e6xxx_mst *mst;\n\tu8 state;\n\tint err;\n\n\tif (!mv88e6xxx_has_stu(chip))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (st->state) {\n\tcase BR_STATE_DISABLED:\n\tcase BR_STATE_BLOCKING:\n\tcase BR_STATE_LISTENING:\n\t\tstate = MV88E6XXX_PORT_CTL0_STATE_BLOCKING;\n\t\tbreak;\n\tcase BR_STATE_LEARNING:\n\t\tstate = MV88E6XXX_PORT_CTL0_STATE_LEARNING;\n\t\tbreak;\n\tcase BR_STATE_FORWARDING:\n\t\tstate = MV88E6XXX_PORT_CTL0_STATE_FORWARDING;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tlist_for_each_entry(mst, &chip->msts, node) {\n\t\tif (mst->br == dsa_port_bridge_dev_get(dp) &&\n\t\t    mst->msti == st->msti) {\n\t\t\tif (mst->stu.state[port] == state)\n\t\t\t\treturn 0;\n\n\t\t\tmst->stu.state[port] = state;\n\t\t\tmv88e6xxx_reg_lock(chip);\n\t\t\terr = mv88e6xxx_stu_loadpurge(chip, &mst->stu);\n\t\t\tmv88e6xxx_reg_unlock(chip);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int mv88e6xxx_port_check_hw_vlan(struct dsa_switch *ds, int port,\n\t\t\t\t\tu16 vid)\n{\n\tstruct dsa_port *dp = dsa_to_port(ds, port), *other_dp;\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tstruct mv88e6xxx_vtu_entry vlan;\n\tint err;\n\n\t \n\tif (dsa_port_is_dsa(dp) || dsa_port_is_cpu(dp))\n\t\treturn 0;\n\n\terr = mv88e6xxx_vtu_get(chip, vid, &vlan);\n\tif (err)\n\t\treturn err;\n\n\tif (!vlan.valid)\n\t\treturn 0;\n\n\tdsa_switch_for_each_user_port(other_dp, ds) {\n\t\tstruct net_device *other_br;\n\n\t\tif (vlan.member[other_dp->index] ==\n\t\t    MV88E6XXX_G1_VTU_DATA_MEMBER_TAG_NON_MEMBER)\n\t\t\tcontinue;\n\n\t\tif (dsa_port_bridge_same(dp, other_dp))\n\t\t\tbreak;  \n\n\t\tother_br = dsa_port_bridge_dev_get(other_dp);\n\t\tif (!other_br)\n\t\t\tcontinue;\n\n\t\tdev_err(ds->dev, \"p%d: hw VLAN %d already used by port %d in %s\\n\",\n\t\t\tport, vlan.vid, other_dp->index, netdev_name(other_br));\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_port_commit_pvid(struct mv88e6xxx_chip *chip, int port)\n{\n\tstruct dsa_port *dp = dsa_to_port(chip->ds, port);\n\tstruct net_device *br = dsa_port_bridge_dev_get(dp);\n\tstruct mv88e6xxx_port *p = &chip->ports[port];\n\tu16 pvid = MV88E6XXX_VID_STANDALONE;\n\tbool drop_untagged = false;\n\tint err;\n\n\tif (br) {\n\t\tif (br_vlan_enabled(br)) {\n\t\t\tpvid = p->bridge_pvid.vid;\n\t\t\tdrop_untagged = !p->bridge_pvid.valid;\n\t\t} else {\n\t\t\tpvid = MV88E6XXX_VID_BRIDGED;\n\t\t}\n\t}\n\n\terr = mv88e6xxx_port_set_pvid(chip, port, pvid);\n\tif (err)\n\t\treturn err;\n\n\treturn mv88e6xxx_port_drop_untagged(chip, port, drop_untagged);\n}\n\nstatic int mv88e6xxx_port_vlan_filtering(struct dsa_switch *ds, int port,\n\t\t\t\t\t bool vlan_filtering,\n\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tu16 mode = vlan_filtering ? MV88E6XXX_PORT_CTL2_8021Q_MODE_SECURE :\n\t\tMV88E6XXX_PORT_CTL2_8021Q_MODE_DISABLED;\n\tint err;\n\n\tif (!mv88e6xxx_max_vid(chip))\n\t\treturn -EOPNOTSUPP;\n\n\tmv88e6xxx_reg_lock(chip);\n\n\terr = mv88e6xxx_port_set_8021q_mode(chip, port, mode);\n\tif (err)\n\t\tgoto unlock;\n\n\terr = mv88e6xxx_port_commit_pvid(chip, port);\n\tif (err)\n\t\tgoto unlock;\n\nunlock:\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err;\n}\n\nstatic int\nmv88e6xxx_port_vlan_prepare(struct dsa_switch *ds, int port,\n\t\t\t    const struct switchdev_obj_port_vlan *vlan)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err;\n\n\tif (!mv88e6xxx_max_vid(chip))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tmv88e6xxx_reg_lock(chip);\n\terr = mv88e6xxx_port_check_hw_vlan(ds, port, vlan->vid);\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err;\n}\n\nstatic int mv88e6xxx_port_db_load_purge(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t\tconst unsigned char *addr, u16 vid,\n\t\t\t\t\tu8 state)\n{\n\tstruct mv88e6xxx_atu_entry entry;\n\tstruct mv88e6xxx_vtu_entry vlan;\n\tu16 fid;\n\tint err;\n\n\t \n\tif (vid == 0) {\n\t\tfid = MV88E6XXX_FID_BRIDGED;\n\t} else {\n\t\terr = mv88e6xxx_vtu_get(chip, vid, &vlan);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tif (!vlan.valid)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tfid = vlan.fid;\n\t}\n\n\tentry.state = 0;\n\tether_addr_copy(entry.mac, addr);\n\teth_addr_dec(entry.mac);\n\n\terr = mv88e6xxx_g1_atu_getnext(chip, fid, &entry);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!entry.state || !ether_addr_equal(entry.mac, addr)) {\n\t\tmemset(&entry, 0, sizeof(entry));\n\t\tether_addr_copy(entry.mac, addr);\n\t}\n\n\t \n\tif (!state) {\n\t\tentry.portvec &= ~BIT(port);\n\t\tif (!entry.portvec)\n\t\t\tentry.state = 0;\n\t} else {\n\t\tif (state == MV88E6XXX_G1_ATU_DATA_STATE_UC_STATIC)\n\t\t\tentry.portvec = BIT(port);\n\t\telse\n\t\t\tentry.portvec |= BIT(port);\n\n\t\tentry.state = state;\n\t}\n\n\treturn mv88e6xxx_g1_atu_loadpurge(chip, fid, &entry);\n}\n\nstatic int mv88e6xxx_policy_apply(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t  const struct mv88e6xxx_policy *policy)\n{\n\tenum mv88e6xxx_policy_mapping mapping = policy->mapping;\n\tenum mv88e6xxx_policy_action action = policy->action;\n\tconst u8 *addr = policy->addr;\n\tu16 vid = policy->vid;\n\tu8 state;\n\tint err;\n\tint id;\n\n\tif (!chip->info->ops->port_set_policy)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (mapping) {\n\tcase MV88E6XXX_POLICY_MAPPING_DA:\n\tcase MV88E6XXX_POLICY_MAPPING_SA:\n\t\tif (action == MV88E6XXX_POLICY_ACTION_NORMAL)\n\t\t\tstate = 0;  \n\t\telse if (action == MV88E6XXX_POLICY_ACTION_DISCARD &&\n\t\t\t is_multicast_ether_addr(addr))\n\t\t\tstate = MV88E6XXX_G1_ATU_DATA_STATE_MC_STATIC_POLICY;\n\t\telse if (action == MV88E6XXX_POLICY_ACTION_DISCARD &&\n\t\t\t is_unicast_ether_addr(addr))\n\t\t\tstate = MV88E6XXX_G1_ATU_DATA_STATE_UC_STATIC_POLICY;\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\n\t\terr = mv88e6xxx_port_db_load_purge(chip, port, addr, vid,\n\t\t\t\t\t\t   state);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (action == MV88E6XXX_POLICY_ACTION_NORMAL)\n\t\tidr_for_each_entry(&chip->policies, policy, id)\n\t\t\tif (policy->port == port &&\n\t\t\t    policy->mapping == mapping &&\n\t\t\t    policy->action != action)\n\t\t\t\treturn 0;\n\n\treturn chip->info->ops->port_set_policy(chip, port, mapping, action);\n}\n\nstatic int mv88e6xxx_policy_insert(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t   struct ethtool_rx_flow_spec *fs)\n{\n\tstruct ethhdr *mac_entry = &fs->h_u.ether_spec;\n\tstruct ethhdr *mac_mask = &fs->m_u.ether_spec;\n\tenum mv88e6xxx_policy_mapping mapping;\n\tenum mv88e6xxx_policy_action action;\n\tstruct mv88e6xxx_policy *policy;\n\tu16 vid = 0;\n\tu8 *addr;\n\tint err;\n\tint id;\n\n\tif (fs->location != RX_CLS_LOC_ANY)\n\t\treturn -EINVAL;\n\n\tif (fs->ring_cookie == RX_CLS_FLOW_DISC)\n\t\taction = MV88E6XXX_POLICY_ACTION_DISCARD;\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (fs->flow_type & ~FLOW_EXT) {\n\tcase ETHER_FLOW:\n\t\tif (!is_zero_ether_addr(mac_mask->h_dest) &&\n\t\t    is_zero_ether_addr(mac_mask->h_source)) {\n\t\t\tmapping = MV88E6XXX_POLICY_MAPPING_DA;\n\t\t\taddr = mac_entry->h_dest;\n\t\t} else if (is_zero_ether_addr(mac_mask->h_dest) &&\n\t\t    !is_zero_ether_addr(mac_mask->h_source)) {\n\t\t\tmapping = MV88E6XXX_POLICY_MAPPING_SA;\n\t\t\taddr = mac_entry->h_source;\n\t\t} else {\n\t\t\t \n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif ((fs->flow_type & FLOW_EXT) && fs->m_ext.vlan_tci) {\n\t\tif (fs->m_ext.vlan_tci != htons(0xffff))\n\t\t\treturn -EOPNOTSUPP;\n\t\tvid = be16_to_cpu(fs->h_ext.vlan_tci) & VLAN_VID_MASK;\n\t}\n\n\tidr_for_each_entry(&chip->policies, policy, id) {\n\t\tif (policy->port == port && policy->mapping == mapping &&\n\t\t    policy->action == action && policy->vid == vid &&\n\t\t    ether_addr_equal(policy->addr, addr))\n\t\t\treturn -EEXIST;\n\t}\n\n\tpolicy = devm_kzalloc(chip->dev, sizeof(*policy), GFP_KERNEL);\n\tif (!policy)\n\t\treturn -ENOMEM;\n\n\tfs->location = 0;\n\terr = idr_alloc_u32(&chip->policies, policy, &fs->location, 0xffffffff,\n\t\t\t    GFP_KERNEL);\n\tif (err) {\n\t\tdevm_kfree(chip->dev, policy);\n\t\treturn err;\n\t}\n\n\tmemcpy(&policy->fs, fs, sizeof(*fs));\n\tether_addr_copy(policy->addr, addr);\n\tpolicy->mapping = mapping;\n\tpolicy->action = action;\n\tpolicy->port = port;\n\tpolicy->vid = vid;\n\n\terr = mv88e6xxx_policy_apply(chip, port, policy);\n\tif (err) {\n\t\tidr_remove(&chip->policies, fs->location);\n\t\tdevm_kfree(chip->dev, policy);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_get_rxnfc(struct dsa_switch *ds, int port,\n\t\t\t       struct ethtool_rxnfc *rxnfc, u32 *rule_locs)\n{\n\tstruct ethtool_rx_flow_spec *fs = &rxnfc->fs;\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tstruct mv88e6xxx_policy *policy;\n\tint err;\n\tint id;\n\n\tmv88e6xxx_reg_lock(chip);\n\n\tswitch (rxnfc->cmd) {\n\tcase ETHTOOL_GRXCLSRLCNT:\n\t\trxnfc->data = 0;\n\t\trxnfc->data |= RX_CLS_LOC_SPECIAL;\n\t\trxnfc->rule_cnt = 0;\n\t\tidr_for_each_entry(&chip->policies, policy, id)\n\t\t\tif (policy->port == port)\n\t\t\t\trxnfc->rule_cnt++;\n\t\terr = 0;\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRULE:\n\t\terr = -ENOENT;\n\t\tpolicy = idr_find(&chip->policies, fs->location);\n\t\tif (policy) {\n\t\t\tmemcpy(fs, &policy->fs, sizeof(*fs));\n\t\t\terr = 0;\n\t\t}\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\trxnfc->data = 0;\n\t\trxnfc->rule_cnt = 0;\n\t\tidr_for_each_entry(&chip->policies, policy, id)\n\t\t\tif (policy->port == port)\n\t\t\t\trule_locs[rxnfc->rule_cnt++] = id;\n\t\terr = 0;\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err;\n}\n\nstatic int mv88e6xxx_set_rxnfc(struct dsa_switch *ds, int port,\n\t\t\t       struct ethtool_rxnfc *rxnfc)\n{\n\tstruct ethtool_rx_flow_spec *fs = &rxnfc->fs;\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tstruct mv88e6xxx_policy *policy;\n\tint err;\n\n\tmv88e6xxx_reg_lock(chip);\n\n\tswitch (rxnfc->cmd) {\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\terr = mv88e6xxx_policy_insert(chip, port, fs);\n\t\tbreak;\n\tcase ETHTOOL_SRXCLSRLDEL:\n\t\terr = -ENOENT;\n\t\tpolicy = idr_remove(&chip->policies, fs->location);\n\t\tif (policy) {\n\t\t\tpolicy->action = MV88E6XXX_POLICY_ACTION_NORMAL;\n\t\t\terr = mv88e6xxx_policy_apply(chip, port, policy);\n\t\t\tdevm_kfree(chip->dev, policy);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err;\n}\n\nstatic int mv88e6xxx_port_add_broadcast(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t\tu16 vid)\n{\n\tu8 state = MV88E6XXX_G1_ATU_DATA_STATE_MC_STATIC;\n\tu8 broadcast[ETH_ALEN];\n\n\teth_broadcast_addr(broadcast);\n\n\treturn mv88e6xxx_port_db_load_purge(chip, port, broadcast, vid, state);\n}\n\nstatic int mv88e6xxx_broadcast_setup(struct mv88e6xxx_chip *chip, u16 vid)\n{\n\tint port;\n\tint err;\n\n\tfor (port = 0; port < mv88e6xxx_num_ports(chip); port++) {\n\t\tstruct dsa_port *dp = dsa_to_port(chip->ds, port);\n\t\tstruct net_device *brport;\n\n\t\tif (dsa_is_unused_port(chip->ds, port))\n\t\t\tcontinue;\n\n\t\tbrport = dsa_port_to_bridge_port(dp);\n\t\tif (brport && !br_port_flag_is_set(brport, BR_BCAST_FLOOD))\n\t\t\t \n\t\t\tcontinue;\n\n\t\terr = mv88e6xxx_port_add_broadcast(chip, port, vid);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstruct mv88e6xxx_port_broadcast_sync_ctx {\n\tint port;\n\tbool flood;\n};\n\nstatic int\nmv88e6xxx_port_broadcast_sync_vlan(struct mv88e6xxx_chip *chip,\n\t\t\t\t   const struct mv88e6xxx_vtu_entry *vlan,\n\t\t\t\t   void *_ctx)\n{\n\tstruct mv88e6xxx_port_broadcast_sync_ctx *ctx = _ctx;\n\tu8 broadcast[ETH_ALEN];\n\tu8 state;\n\n\tif (ctx->flood)\n\t\tstate = MV88E6XXX_G1_ATU_DATA_STATE_MC_STATIC;\n\telse\n\t\tstate = MV88E6XXX_G1_ATU_DATA_STATE_MC_UNUSED;\n\n\teth_broadcast_addr(broadcast);\n\n\treturn mv88e6xxx_port_db_load_purge(chip, ctx->port, broadcast,\n\t\t\t\t\t    vlan->vid, state);\n}\n\nstatic int mv88e6xxx_port_broadcast_sync(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t\t bool flood)\n{\n\tstruct mv88e6xxx_port_broadcast_sync_ctx ctx = {\n\t\t.port = port,\n\t\t.flood = flood,\n\t};\n\tstruct mv88e6xxx_vtu_entry vid0 = {\n\t\t.vid = 0,\n\t};\n\tint err;\n\n\t \n\terr = mv88e6xxx_port_broadcast_sync_vlan(chip, &vid0, &ctx);\n\tif (err)\n\t\treturn err;\n\n\t \n\treturn mv88e6xxx_vtu_walk(chip, mv88e6xxx_port_broadcast_sync_vlan,\n\t\t\t\t  &ctx);\n}\n\nstatic int mv88e6xxx_port_vlan_join(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t    u16 vid, u8 member, bool warn)\n{\n\tconst u8 non_member = MV88E6XXX_G1_VTU_DATA_MEMBER_TAG_NON_MEMBER;\n\tstruct mv88e6xxx_vtu_entry vlan;\n\tint i, err;\n\n\terr = mv88e6xxx_vtu_get(chip, vid, &vlan);\n\tif (err)\n\t\treturn err;\n\n\tif (!vlan.valid) {\n\t\tmemset(&vlan, 0, sizeof(vlan));\n\n\t\tif (vid == MV88E6XXX_VID_STANDALONE)\n\t\t\tvlan.policy = true;\n\n\t\terr = mv88e6xxx_atu_new(chip, &vlan.fid);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tfor (i = 0; i < mv88e6xxx_num_ports(chip); ++i)\n\t\t\tif (i == port)\n\t\t\t\tvlan.member[i] = member;\n\t\t\telse\n\t\t\t\tvlan.member[i] = non_member;\n\n\t\tvlan.vid = vid;\n\t\tvlan.valid = true;\n\n\t\terr = mv88e6xxx_vtu_loadpurge(chip, &vlan);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mv88e6xxx_broadcast_setup(chip, vlan.vid);\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (vlan.member[port] != member) {\n\t\tvlan.member[port] = member;\n\n\t\terr = mv88e6xxx_vtu_loadpurge(chip, &vlan);\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (warn) {\n\t\tdev_info(chip->dev, \"p%d: already a member of VLAN %d\\n\",\n\t\t\t port, vid);\n\t}\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_port_vlan_add(struct dsa_switch *ds, int port,\n\t\t\t\t   const struct switchdev_obj_port_vlan *vlan,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tbool untagged = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;\n\tbool pvid = vlan->flags & BRIDGE_VLAN_INFO_PVID;\n\tstruct mv88e6xxx_port *p = &chip->ports[port];\n\tbool warn;\n\tu8 member;\n\tint err;\n\n\tif (!vlan->vid)\n\t\treturn 0;\n\n\terr = mv88e6xxx_port_vlan_prepare(ds, port, vlan);\n\tif (err)\n\t\treturn err;\n\n\tif (dsa_is_dsa_port(ds, port) || dsa_is_cpu_port(ds, port))\n\t\tmember = MV88E6XXX_G1_VTU_DATA_MEMBER_TAG_UNMODIFIED;\n\telse if (untagged)\n\t\tmember = MV88E6XXX_G1_VTU_DATA_MEMBER_TAG_UNTAGGED;\n\telse\n\t\tmember = MV88E6XXX_G1_VTU_DATA_MEMBER_TAG_TAGGED;\n\n\t \n\twarn = !dsa_is_cpu_port(ds, port) && !dsa_is_dsa_port(ds, port);\n\n\tmv88e6xxx_reg_lock(chip);\n\n\terr = mv88e6xxx_port_vlan_join(chip, port, vlan->vid, member, warn);\n\tif (err) {\n\t\tdev_err(ds->dev, \"p%d: failed to add VLAN %d%c\\n\", port,\n\t\t\tvlan->vid, untagged ? 'u' : 't');\n\t\tgoto out;\n\t}\n\n\tif (pvid) {\n\t\tp->bridge_pvid.vid = vlan->vid;\n\t\tp->bridge_pvid.valid = true;\n\n\t\terr = mv88e6xxx_port_commit_pvid(chip, port);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else if (vlan->vid && p->bridge_pvid.vid == vlan->vid) {\n\t\t \n\t\tp->bridge_pvid.valid = false;\n\n\t\terr = mv88e6xxx_port_commit_pvid(chip, port);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\nout:\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err;\n}\n\nstatic int mv88e6xxx_port_vlan_leave(struct mv88e6xxx_chip *chip,\n\t\t\t\t     int port, u16 vid)\n{\n\tstruct mv88e6xxx_vtu_entry vlan;\n\tint i, err;\n\n\tif (!vid)\n\t\treturn 0;\n\n\terr = mv88e6xxx_vtu_get(chip, vid, &vlan);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!vlan.valid ||\n\t    vlan.member[port] == MV88E6XXX_G1_VTU_DATA_MEMBER_TAG_NON_MEMBER)\n\t\treturn -EOPNOTSUPP;\n\n\tvlan.member[port] = MV88E6XXX_G1_VTU_DATA_MEMBER_TAG_NON_MEMBER;\n\n\t \n\tvlan.valid = false;\n\tfor (i = 0; i < mv88e6xxx_num_ports(chip); ++i) {\n\t\tif (vlan.member[i] !=\n\t\t    MV88E6XXX_G1_VTU_DATA_MEMBER_TAG_NON_MEMBER) {\n\t\t\tvlan.valid = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\terr = mv88e6xxx_vtu_loadpurge(chip, &vlan);\n\tif (err)\n\t\treturn err;\n\n\tif (!vlan.valid) {\n\t\terr = mv88e6xxx_mst_put(chip, vlan.sid);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn mv88e6xxx_g1_atu_remove(chip, vlan.fid, port, false);\n}\n\nstatic int mv88e6xxx_port_vlan_del(struct dsa_switch *ds, int port,\n\t\t\t\t   const struct switchdev_obj_port_vlan *vlan)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tstruct mv88e6xxx_port *p = &chip->ports[port];\n\tint err = 0;\n\tu16 pvid;\n\n\tif (!mv88e6xxx_max_vid(chip))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tdsa_flush_workqueue();\n\n\tmv88e6xxx_reg_lock(chip);\n\n\terr = mv88e6xxx_port_get_pvid(chip, port, &pvid);\n\tif (err)\n\t\tgoto unlock;\n\n\terr = mv88e6xxx_port_vlan_leave(chip, port, vlan->vid);\n\tif (err)\n\t\tgoto unlock;\n\n\tif (vlan->vid == pvid) {\n\t\tp->bridge_pvid.valid = false;\n\n\t\terr = mv88e6xxx_port_commit_pvid(chip, port);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\nunlock:\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err;\n}\n\nstatic int mv88e6xxx_port_vlan_fast_age(struct dsa_switch *ds, int port, u16 vid)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tstruct mv88e6xxx_vtu_entry vlan;\n\tint err;\n\n\tmv88e6xxx_reg_lock(chip);\n\n\terr = mv88e6xxx_vtu_get(chip, vid, &vlan);\n\tif (err)\n\t\tgoto unlock;\n\n\terr = mv88e6xxx_port_fast_age_fid(chip, port, vlan.fid);\n\nunlock:\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err;\n}\n\nstatic int mv88e6xxx_vlan_msti_set(struct dsa_switch *ds,\n\t\t\t\t   struct dsa_bridge bridge,\n\t\t\t\t   const struct switchdev_vlan_msti *msti)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tstruct mv88e6xxx_vtu_entry vlan;\n\tu8 old_sid, new_sid;\n\tint err;\n\n\tif (!mv88e6xxx_has_stu(chip))\n\t\treturn -EOPNOTSUPP;\n\n\tmv88e6xxx_reg_lock(chip);\n\n\terr = mv88e6xxx_vtu_get(chip, msti->vid, &vlan);\n\tif (err)\n\t\tgoto unlock;\n\n\tif (!vlan.valid) {\n\t\terr = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\told_sid = vlan.sid;\n\n\terr = mv88e6xxx_mst_get(chip, bridge.dev, msti->msti, &new_sid);\n\tif (err)\n\t\tgoto unlock;\n\n\tif (new_sid != old_sid) {\n\t\tvlan.sid = new_sid;\n\n\t\terr = mv88e6xxx_vtu_loadpurge(chip, &vlan);\n\t\tif (err) {\n\t\t\tmv88e6xxx_mst_put(chip, new_sid);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\terr = mv88e6xxx_mst_put(chip, old_sid);\n\nunlock:\n\tmv88e6xxx_reg_unlock(chip);\n\treturn err;\n}\n\nstatic int mv88e6xxx_port_fdb_add(struct dsa_switch *ds, int port,\n\t\t\t\t  const unsigned char *addr, u16 vid,\n\t\t\t\t  struct dsa_db db)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = mv88e6xxx_port_db_load_purge(chip, port, addr, vid,\n\t\t\t\t\t   MV88E6XXX_G1_ATU_DATA_STATE_UC_STATIC);\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err;\n}\n\nstatic int mv88e6xxx_port_fdb_del(struct dsa_switch *ds, int port,\n\t\t\t\t  const unsigned char *addr, u16 vid,\n\t\t\t\t  struct dsa_db db)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = mv88e6xxx_port_db_load_purge(chip, port, addr, vid, 0);\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err;\n}\n\nstatic int mv88e6xxx_port_db_dump_fid(struct mv88e6xxx_chip *chip,\n\t\t\t\t      u16 fid, u16 vid, int port,\n\t\t\t\t      dsa_fdb_dump_cb_t *cb, void *data)\n{\n\tstruct mv88e6xxx_atu_entry addr;\n\tbool is_static;\n\tint err;\n\n\taddr.state = 0;\n\teth_broadcast_addr(addr.mac);\n\n\tdo {\n\t\terr = mv88e6xxx_g1_atu_getnext(chip, fid, &addr);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (!addr.state)\n\t\t\tbreak;\n\n\t\tif (addr.trunk || (addr.portvec & BIT(port)) == 0)\n\t\t\tcontinue;\n\n\t\tif (!is_unicast_ether_addr(addr.mac))\n\t\t\tcontinue;\n\n\t\tis_static = (addr.state ==\n\t\t\t     MV88E6XXX_G1_ATU_DATA_STATE_UC_STATIC);\n\t\terr = cb(addr.mac, vid, is_static, data);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (!is_broadcast_ether_addr(addr.mac));\n\n\treturn err;\n}\n\nstruct mv88e6xxx_port_db_dump_vlan_ctx {\n\tint port;\n\tdsa_fdb_dump_cb_t *cb;\n\tvoid *data;\n};\n\nstatic int mv88e6xxx_port_db_dump_vlan(struct mv88e6xxx_chip *chip,\n\t\t\t\t       const struct mv88e6xxx_vtu_entry *entry,\n\t\t\t\t       void *_data)\n{\n\tstruct mv88e6xxx_port_db_dump_vlan_ctx *ctx = _data;\n\n\treturn mv88e6xxx_port_db_dump_fid(chip, entry->fid, entry->vid,\n\t\t\t\t\t  ctx->port, ctx->cb, ctx->data);\n}\n\nstatic int mv88e6xxx_port_db_dump(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t  dsa_fdb_dump_cb_t *cb, void *data)\n{\n\tstruct mv88e6xxx_port_db_dump_vlan_ctx ctx = {\n\t\t.port = port,\n\t\t.cb = cb,\n\t\t.data = data,\n\t};\n\tu16 fid;\n\tint err;\n\n\t \n\terr = mv88e6xxx_port_get_fid(chip, port, &fid);\n\tif (err)\n\t\treturn err;\n\n\terr = mv88e6xxx_port_db_dump_fid(chip, fid, 0, port, cb, data);\n\tif (err)\n\t\treturn err;\n\n\treturn mv88e6xxx_vtu_walk(chip, mv88e6xxx_port_db_dump_vlan, &ctx);\n}\n\nstatic int mv88e6xxx_port_fdb_dump(struct dsa_switch *ds, int port,\n\t\t\t\t   dsa_fdb_dump_cb_t *cb, void *data)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = mv88e6xxx_port_db_dump(chip, port, cb, data);\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err;\n}\n\nstatic int mv88e6xxx_bridge_map(struct mv88e6xxx_chip *chip,\n\t\t\t\tstruct dsa_bridge bridge)\n{\n\tstruct dsa_switch *ds = chip->ds;\n\tstruct dsa_switch_tree *dst = ds->dst;\n\tstruct dsa_port *dp;\n\tint err;\n\n\tlist_for_each_entry(dp, &dst->ports, list) {\n\t\tif (dsa_port_offloads_bridge(dp, &bridge)) {\n\t\t\tif (dp->ds == ds) {\n\t\t\t\t \n\t\t\t\terr = mv88e6xxx_port_vlan_map(chip, dp->index);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\terr = mv88e6xxx_pvt_map(chip, dp->ds->index,\n\t\t\t\t\t\t\tdp->index);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mv88e6xxx_map_virtual_bridge_to_pvt(struct dsa_switch *ds,\n\t\t\t\t\t       unsigned int bridge_num)\n{\n\tu8 dev = bridge_num + ds->dst->last_switch;\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\n\treturn mv88e6xxx_pvt_map(chip, dev, 0);\n}\n\nstatic int mv88e6xxx_port_bridge_join(struct dsa_switch *ds, int port,\n\t\t\t\t      struct dsa_bridge bridge,\n\t\t\t\t      bool *tx_fwd_offload,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err;\n\n\tmv88e6xxx_reg_lock(chip);\n\n\terr = mv88e6xxx_bridge_map(chip, bridge);\n\tif (err)\n\t\tgoto unlock;\n\n\terr = mv88e6xxx_port_set_map_da(chip, port, true);\n\tif (err)\n\t\tgoto unlock;\n\n\terr = mv88e6xxx_port_commit_pvid(chip, port);\n\tif (err)\n\t\tgoto unlock;\n\n\tif (mv88e6xxx_has_pvt(chip)) {\n\t\terr = mv88e6xxx_map_virtual_bridge_to_pvt(ds, bridge.num);\n\t\tif (err)\n\t\t\tgoto unlock;\n\n\t\t*tx_fwd_offload = true;\n\t}\n\nunlock:\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err;\n}\n\nstatic void mv88e6xxx_port_bridge_leave(struct dsa_switch *ds, int port,\n\t\t\t\t\tstruct dsa_bridge bridge)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err;\n\n\tmv88e6xxx_reg_lock(chip);\n\n\tif (bridge.tx_fwd_offload &&\n\t    mv88e6xxx_map_virtual_bridge_to_pvt(ds, bridge.num))\n\t\tdev_err(ds->dev, \"failed to remap cross-chip Port VLAN\\n\");\n\n\tif (mv88e6xxx_bridge_map(chip, bridge) ||\n\t    mv88e6xxx_port_vlan_map(chip, port))\n\t\tdev_err(ds->dev, \"failed to remap in-chip Port VLAN\\n\");\n\n\terr = mv88e6xxx_port_set_map_da(chip, port, false);\n\tif (err)\n\t\tdev_err(ds->dev,\n\t\t\t\"port %d failed to restore map-DA: %pe\\n\",\n\t\t\tport, ERR_PTR(err));\n\n\terr = mv88e6xxx_port_commit_pvid(chip, port);\n\tif (err)\n\t\tdev_err(ds->dev,\n\t\t\t\"port %d failed to restore standalone pvid: %pe\\n\",\n\t\t\tport, ERR_PTR(err));\n\n\tmv88e6xxx_reg_unlock(chip);\n}\n\nstatic int mv88e6xxx_crosschip_bridge_join(struct dsa_switch *ds,\n\t\t\t\t\t   int tree_index, int sw_index,\n\t\t\t\t\t   int port, struct dsa_bridge bridge,\n\t\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err;\n\n\tif (tree_index != ds->dst->index)\n\t\treturn 0;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = mv88e6xxx_pvt_map(chip, sw_index, port);\n\terr = err ? : mv88e6xxx_map_virtual_bridge_to_pvt(ds, bridge.num);\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err;\n}\n\nstatic void mv88e6xxx_crosschip_bridge_leave(struct dsa_switch *ds,\n\t\t\t\t\t     int tree_index, int sw_index,\n\t\t\t\t\t     int port, struct dsa_bridge bridge)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\n\tif (tree_index != ds->dst->index)\n\t\treturn;\n\n\tmv88e6xxx_reg_lock(chip);\n\tif (mv88e6xxx_pvt_map(chip, sw_index, port) ||\n\t    mv88e6xxx_map_virtual_bridge_to_pvt(ds, bridge.num))\n\t\tdev_err(ds->dev, \"failed to remap cross-chip Port VLAN\\n\");\n\tmv88e6xxx_reg_unlock(chip);\n}\n\nstatic int mv88e6xxx_software_reset(struct mv88e6xxx_chip *chip)\n{\n\tif (chip->info->ops->reset)\n\t\treturn chip->info->ops->reset(chip);\n\n\treturn 0;\n}\n\nstatic void mv88e6xxx_hardware_reset(struct mv88e6xxx_chip *chip)\n{\n\tstruct gpio_desc *gpiod = chip->reset;\n\n\t \n\tif (gpiod) {\n\t\t \n\t\tif (chip->info->ops->get_eeprom)\n\t\t\tmv88e6xxx_g2_eeprom_wait(chip);\n\n\t\tgpiod_set_value_cansleep(gpiod, 1);\n\t\tusleep_range(10000, 20000);\n\t\tgpiod_set_value_cansleep(gpiod, 0);\n\t\tusleep_range(10000, 20000);\n\n\t\tif (chip->info->ops->get_eeprom)\n\t\t\tmv88e6xxx_g2_eeprom_wait(chip);\n\t}\n}\n\nstatic int mv88e6xxx_disable_ports(struct mv88e6xxx_chip *chip)\n{\n\tint i, err;\n\n\t \n\tfor (i = 0; i < mv88e6xxx_num_ports(chip); i++) {\n\t\terr = mv88e6xxx_port_set_state(chip, i, BR_STATE_DISABLED);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tusleep_range(2000, 4000);\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_switch_reset(struct mv88e6xxx_chip *chip)\n{\n\tint err;\n\n\terr = mv88e6xxx_disable_ports(chip);\n\tif (err)\n\t\treturn err;\n\n\tmv88e6xxx_hardware_reset(chip);\n\n\treturn mv88e6xxx_software_reset(chip);\n}\n\nstatic int mv88e6xxx_set_port_mode(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t   enum mv88e6xxx_frame_mode frame,\n\t\t\t\t   enum mv88e6xxx_egress_mode egress, u16 etype)\n{\n\tint err;\n\n\tif (!chip->info->ops->port_set_frame_mode)\n\t\treturn -EOPNOTSUPP;\n\n\terr = mv88e6xxx_port_set_egress_mode(chip, port, egress);\n\tif (err)\n\t\treturn err;\n\n\terr = chip->info->ops->port_set_frame_mode(chip, port, frame);\n\tif (err)\n\t\treturn err;\n\n\tif (chip->info->ops->port_set_ether_type)\n\t\treturn chip->info->ops->port_set_ether_type(chip, port, etype);\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_set_port_mode_normal(struct mv88e6xxx_chip *chip, int port)\n{\n\treturn mv88e6xxx_set_port_mode(chip, port, MV88E6XXX_FRAME_MODE_NORMAL,\n\t\t\t\t       MV88E6XXX_EGRESS_MODE_UNMODIFIED,\n\t\t\t\t       MV88E6XXX_PORT_ETH_TYPE_DEFAULT);\n}\n\nstatic int mv88e6xxx_set_port_mode_dsa(struct mv88e6xxx_chip *chip, int port)\n{\n\treturn mv88e6xxx_set_port_mode(chip, port, MV88E6XXX_FRAME_MODE_DSA,\n\t\t\t\t       MV88E6XXX_EGRESS_MODE_UNMODIFIED,\n\t\t\t\t       MV88E6XXX_PORT_ETH_TYPE_DEFAULT);\n}\n\nstatic int mv88e6xxx_set_port_mode_edsa(struct mv88e6xxx_chip *chip, int port)\n{\n\treturn mv88e6xxx_set_port_mode(chip, port,\n\t\t\t\t       MV88E6XXX_FRAME_MODE_ETHERTYPE,\n\t\t\t\t       MV88E6XXX_EGRESS_MODE_ETHERTYPE,\n\t\t\t\t       ETH_P_EDSA);\n}\n\nstatic int mv88e6xxx_setup_port_mode(struct mv88e6xxx_chip *chip, int port)\n{\n\tif (dsa_is_dsa_port(chip->ds, port))\n\t\treturn mv88e6xxx_set_port_mode_dsa(chip, port);\n\n\tif (dsa_is_user_port(chip->ds, port))\n\t\treturn mv88e6xxx_set_port_mode_normal(chip, port);\n\n\t \n\tif (chip->tag_protocol == DSA_TAG_PROTO_DSA)\n\t\treturn mv88e6xxx_set_port_mode_dsa(chip, port);\n\n\tif (chip->tag_protocol == DSA_TAG_PROTO_EDSA)\n\t\treturn mv88e6xxx_set_port_mode_edsa(chip, port);\n\n\treturn -EINVAL;\n}\n\nstatic int mv88e6xxx_setup_message_port(struct mv88e6xxx_chip *chip, int port)\n{\n\tbool message = dsa_is_dsa_port(chip->ds, port);\n\n\treturn mv88e6xxx_port_set_message_port(chip, port, message);\n}\n\nstatic int mv88e6xxx_setup_egress_floods(struct mv88e6xxx_chip *chip, int port)\n{\n\tint err;\n\n\tif (chip->info->ops->port_set_ucast_flood) {\n\t\terr = chip->info->ops->port_set_ucast_flood(chip, port, true);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tif (chip->info->ops->port_set_mcast_flood) {\n\t\terr = chip->info->ops->port_set_mcast_flood(chip, port, true);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_set_egress_port(struct mv88e6xxx_chip *chip,\n\t\t\t\t     enum mv88e6xxx_egress_direction direction,\n\t\t\t\t     int port)\n{\n\tint err;\n\n\tif (!chip->info->ops->set_egress_port)\n\t\treturn -EOPNOTSUPP;\n\n\terr = chip->info->ops->set_egress_port(chip, direction, port);\n\tif (err)\n\t\treturn err;\n\n\tif (direction == MV88E6XXX_EGRESS_DIR_INGRESS)\n\t\tchip->ingress_dest_port = port;\n\telse\n\t\tchip->egress_dest_port = port;\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_setup_upstream_port(struct mv88e6xxx_chip *chip, int port)\n{\n\tstruct dsa_switch *ds = chip->ds;\n\tint upstream_port;\n\tint err;\n\n\tupstream_port = dsa_upstream_port(ds, port);\n\tif (chip->info->ops->port_set_upstream_port) {\n\t\terr = chip->info->ops->port_set_upstream_port(chip, port,\n\t\t\t\t\t\t\t      upstream_port);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (port == upstream_port) {\n\t\tif (chip->info->ops->set_cpu_port) {\n\t\t\terr = chip->info->ops->set_cpu_port(chip,\n\t\t\t\t\t\t\t    upstream_port);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\terr = mv88e6xxx_set_egress_port(chip,\n\t\t\t\t\t\tMV88E6XXX_EGRESS_DIR_INGRESS,\n\t\t\t\t\t\tupstream_port);\n\t\tif (err && err != -EOPNOTSUPP)\n\t\t\treturn err;\n\n\t\terr = mv88e6xxx_set_egress_port(chip,\n\t\t\t\t\t\tMV88E6XXX_EGRESS_DIR_EGRESS,\n\t\t\t\t\t\tupstream_port);\n\t\tif (err && err != -EOPNOTSUPP)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_setup_port(struct mv88e6xxx_chip *chip, int port)\n{\n\tstruct device_node *phy_handle = NULL;\n\tstruct dsa_switch *ds = chip->ds;\n\tstruct dsa_port *dp;\n\tint tx_amp;\n\tint err;\n\tu16 reg;\n\n\tchip->ports[port].chip = chip;\n\tchip->ports[port].port = port;\n\n\terr = mv88e6xxx_port_setup_mac(chip, port, LINK_UNFORCED,\n\t\t\t\t       SPEED_UNFORCED, DUPLEX_UNFORCED,\n\t\t\t\t       PAUSE_ON, PHY_INTERFACE_MODE_NA);\n\tif (err)\n\t\treturn err;\n\n\t \n\treg = MV88E6185_PORT_CTL0_USE_TAG | MV88E6185_PORT_CTL0_USE_IP |\n\t\tMV88E6XXX_PORT_CTL0_STATE_FORWARDING;\n\t \n\tif (dsa_is_user_port(ds, port))\n\t\treg |= MV88E6XXX_PORT_CTL0_IGMP_MLD_SNOOP;\n\n\terr = mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_CTL0, reg);\n\tif (err)\n\t\treturn err;\n\n\terr = mv88e6xxx_setup_port_mode(chip, port);\n\tif (err)\n\t\treturn err;\n\n\terr = mv88e6xxx_setup_egress_floods(chip, port);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = mv88e6xxx_port_set_map_da(chip, port, !dsa_is_user_port(ds, port));\n\tif (err)\n\t\treturn err;\n\n\terr = mv88e6xxx_setup_upstream_port(chip, port);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (dsa_is_downstream_port(ds, port) &&\n\t    chip->info->ops->port_set_policy) {\n\t\terr = chip->info->ops->port_set_policy(chip, port,\n\t\t\t\t\t\tMV88E6XXX_POLICY_MAPPING_VTU,\n\t\t\t\t\t\tMV88E6XXX_POLICY_ACTION_TRAP);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\terr = mv88e6xxx_port_set_8021q_mode(chip, port,\n\t\t\t\tdsa_is_user_port(ds, port) ?\n\t\t\t\tMV88E6XXX_PORT_CTL2_8021Q_MODE_DISABLED :\n\t\t\t\tMV88E6XXX_PORT_CTL2_8021Q_MODE_SECURE);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = mv88e6xxx_port_vlan_join(chip, port, MV88E6XXX_VID_STANDALONE,\n\t\t\t\t       MV88E6XXX_G1_VTU_DATA_MEMBER_TAG_UNMODIFIED,\n\t\t\t\t       false);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = mv88e6xxx_port_vlan_join(chip, port, MV88E6XXX_VID_BRIDGED,\n\t\t\t\t       MV88E6XXX_G1_VTU_DATA_MEMBER_TAG_UNMODIFIED,\n\t\t\t\t       false);\n\tif (err)\n\t\treturn err;\n\n\tif (chip->info->ops->port_set_jumbo_size) {\n\t\terr = chip->info->ops->port_set_jumbo_size(chip, port, 10218);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (dsa_is_user_port(ds, port))\n\t\treg = 0;\n\telse\n\t\treg = 1 << port;\n\n\terr = mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_ASSOC_VECTOR,\n\t\t\t\t   reg);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_EGRESS_RATE_CTL2,\n\t\t\t\t   0x0000);\n\tif (err)\n\t\treturn err;\n\n\tif (chip->info->ops->port_pause_limit) {\n\t\terr = chip->info->ops->port_pause_limit(chip, port, 0, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (chip->info->ops->port_disable_learn_limit) {\n\t\terr = chip->info->ops->port_disable_learn_limit(chip, port);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (chip->info->ops->port_disable_pri_override) {\n\t\terr = chip->info->ops->port_disable_pri_override(chip, port);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (chip->info->ops->port_tag_remap) {\n\t\terr = chip->info->ops->port_tag_remap(chip, port);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (chip->info->ops->port_egress_rate_limiting) {\n\t\terr = chip->info->ops->port_egress_rate_limiting(chip, port);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (chip->info->ops->port_setup_message_port) {\n\t\terr = chip->info->ops->port_setup_message_port(chip, port);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (chip->info->ops->serdes_set_tx_amplitude) {\n\t\tdp = dsa_to_port(ds, port);\n\t\tif (dp)\n\t\t\tphy_handle = of_parse_phandle(dp->dn, \"phy-handle\", 0);\n\n\t\tif (phy_handle && !of_property_read_u32(phy_handle,\n\t\t\t\t\t\t\t\"tx-p2p-microvolt\",\n\t\t\t\t\t\t\t&tx_amp))\n\t\t\terr = chip->info->ops->serdes_set_tx_amplitude(chip,\n\t\t\t\t\t\t\t\tport, tx_amp);\n\t\tif (phy_handle) {\n\t\t\tof_node_put(phy_handle);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\terr = mv88e6xxx_port_set_fid(chip, port, MV88E6XXX_FID_STANDALONE);\n\tif (err)\n\t\treturn err;\n\n\terr = mv88e6xxx_port_vlan_map(chip, port);\n\tif (err)\n\t\treturn err;\n\n\t \n\treturn mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_DEFAULT_VLAN, 0);\n}\n\nstatic int mv88e6xxx_get_max_mtu(struct dsa_switch *ds, int port)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\n\tif (chip->info->ops->port_set_jumbo_size)\n\t\treturn 10240 - VLAN_ETH_HLEN - EDSA_HLEN - ETH_FCS_LEN;\n\telse if (chip->info->ops->set_max_frame_size)\n\t\treturn 1632 - VLAN_ETH_HLEN - EDSA_HLEN - ETH_FCS_LEN;\n\treturn ETH_DATA_LEN;\n}\n\nstatic int mv88e6xxx_change_mtu(struct dsa_switch *ds, int port, int new_mtu)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint ret = 0;\n\n\t \n\tif (!chip->info->ops->port_set_jumbo_size &&\n\t    !chip->info->ops->set_max_frame_size) {\n\t\tif (new_mtu > ETH_DATA_LEN)\n\t\t\treturn -EINVAL;\n\n\t\treturn 0;\n\t}\n\n\tif (dsa_is_dsa_port(ds, port) || dsa_is_cpu_port(ds, port))\n\t\tnew_mtu += EDSA_HLEN;\n\n\tmv88e6xxx_reg_lock(chip);\n\tif (chip->info->ops->port_set_jumbo_size)\n\t\tret = chip->info->ops->port_set_jumbo_size(chip, port, new_mtu);\n\telse if (chip->info->ops->set_max_frame_size)\n\t\tret = chip->info->ops->set_max_frame_size(chip, new_mtu);\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn ret;\n}\n\nstatic int mv88e6xxx_set_ageing_time(struct dsa_switch *ds,\n\t\t\t\t     unsigned int ageing_time)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = mv88e6xxx_g1_atu_set_age_time(chip, ageing_time);\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err;\n}\n\nstatic int mv88e6xxx_stats_setup(struct mv88e6xxx_chip *chip)\n{\n\tint err;\n\n\t \n\tif (chip->info->ops->stats_set_histogram) {\n\t\terr = chip->info->ops->stats_set_histogram(chip);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn mv88e6xxx_g1_stats_clear(chip);\n}\n\n \nstatic bool mv88e6390_setup_errata_applied(struct mv88e6xxx_chip *chip)\n{\n\tint port;\n\tint err;\n\tu16 val;\n\n\tfor (port = 0; port < mv88e6xxx_num_ports(chip); port++) {\n\t\terr = mv88e6xxx_port_hidden_read(chip, 0xf, port, 0, &val);\n\t\tif (err) {\n\t\t\tdev_err(chip->dev,\n\t\t\t\t\"Error reading hidden register: %d\\n\", err);\n\t\t\treturn false;\n\t\t}\n\t\tif (val != 0x01c0)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic int mv88e6390_setup_errata(struct mv88e6xxx_chip *chip)\n{\n\tint port;\n\tint err;\n\n\tif (mv88e6390_setup_errata_applied(chip))\n\t\treturn 0;\n\n\t \n\tfor (port = 0; port < mv88e6xxx_num_ports(chip); port++) {\n\t\terr = mv88e6xxx_port_set_state(chip, port, BR_STATE_DISABLED);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor (port = 0; port < mv88e6xxx_num_ports(chip); port++) {\n\t\terr = mv88e6xxx_port_hidden_write(chip, 0xf, port, 0, 0x01c0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn mv88e6xxx_software_reset(chip);\n}\n\n \nstatic const u16 family_prod_id_table[] = {\n\t[MV88E6XXX_FAMILY_6341] = MV88E6XXX_PORT_SWITCH_ID_PROD_6341,\n\t[MV88E6XXX_FAMILY_6390] = MV88E6XXX_PORT_SWITCH_ID_PROD_6390,\n\t[MV88E6XXX_FAMILY_6393] = MV88E6XXX_PORT_SWITCH_ID_PROD_6393X,\n};\n\nstatic int mv88e6xxx_mdio_read(struct mii_bus *bus, int phy, int reg)\n{\n\tstruct mv88e6xxx_mdio_bus *mdio_bus = bus->priv;\n\tstruct mv88e6xxx_chip *chip = mdio_bus->chip;\n\tu16 prod_id;\n\tu16 val;\n\tint err;\n\n\tif (!chip->info->ops->phy_read)\n\t\treturn -EOPNOTSUPP;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = chip->info->ops->phy_read(chip, bus, phy, reg, &val);\n\tmv88e6xxx_reg_unlock(chip);\n\n\t \n\tif (reg == MII_PHYSID2 && !(val & 0x3f0) &&\n\t    chip->info->family < ARRAY_SIZE(family_prod_id_table)) {\n\t\tprod_id = family_prod_id_table[chip->info->family];\n\t\tif (prod_id)\n\t\t\tval |= prod_id >> 4;\n\t}\n\n\treturn err ? err : val;\n}\n\nstatic int mv88e6xxx_mdio_read_c45(struct mii_bus *bus, int phy, int devad,\n\t\t\t\t   int reg)\n{\n\tstruct mv88e6xxx_mdio_bus *mdio_bus = bus->priv;\n\tstruct mv88e6xxx_chip *chip = mdio_bus->chip;\n\tu16 val;\n\tint err;\n\n\tif (!chip->info->ops->phy_read_c45)\n\t\treturn -EOPNOTSUPP;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = chip->info->ops->phy_read_c45(chip, bus, phy, devad, reg, &val);\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err ? err : val;\n}\n\nstatic int mv88e6xxx_mdio_write(struct mii_bus *bus, int phy, int reg, u16 val)\n{\n\tstruct mv88e6xxx_mdio_bus *mdio_bus = bus->priv;\n\tstruct mv88e6xxx_chip *chip = mdio_bus->chip;\n\tint err;\n\n\tif (!chip->info->ops->phy_write)\n\t\treturn -EOPNOTSUPP;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = chip->info->ops->phy_write(chip, bus, phy, reg, val);\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err;\n}\n\nstatic int mv88e6xxx_mdio_write_c45(struct mii_bus *bus, int phy, int devad,\n\t\t\t\t    int reg, u16 val)\n{\n\tstruct mv88e6xxx_mdio_bus *mdio_bus = bus->priv;\n\tstruct mv88e6xxx_chip *chip = mdio_bus->chip;\n\tint err;\n\n\tif (!chip->info->ops->phy_write_c45)\n\t\treturn -EOPNOTSUPP;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = chip->info->ops->phy_write_c45(chip, bus, phy, devad, reg, val);\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err;\n}\n\nstatic int mv88e6xxx_mdio_register(struct mv88e6xxx_chip *chip,\n\t\t\t\t   struct device_node *np,\n\t\t\t\t   bool external)\n{\n\tstatic int index;\n\tstruct mv88e6xxx_mdio_bus *mdio_bus;\n\tstruct mii_bus *bus;\n\tint err;\n\n\tif (external) {\n\t\tmv88e6xxx_reg_lock(chip);\n\t\terr = mv88e6xxx_g2_scratch_gpio_set_smi(chip, true);\n\t\tmv88e6xxx_reg_unlock(chip);\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tbus = mdiobus_alloc_size(sizeof(*mdio_bus));\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\tmdio_bus = bus->priv;\n\tmdio_bus->bus = bus;\n\tmdio_bus->chip = chip;\n\tINIT_LIST_HEAD(&mdio_bus->list);\n\tmdio_bus->external = external;\n\n\tif (np) {\n\t\tbus->name = np->full_name;\n\t\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%pOF\", np);\n\t} else {\n\t\tbus->name = \"mv88e6xxx SMI\";\n\t\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"mv88e6xxx-%d\", index++);\n\t}\n\n\tbus->read = mv88e6xxx_mdio_read;\n\tbus->write = mv88e6xxx_mdio_write;\n\tbus->read_c45 = mv88e6xxx_mdio_read_c45;\n\tbus->write_c45 = mv88e6xxx_mdio_write_c45;\n\tbus->parent = chip->dev;\n\tbus->phy_mask = ~GENMASK(chip->info->phy_base_addr +\n\t\t\t\t mv88e6xxx_num_ports(chip) - 1,\n\t\t\t\t chip->info->phy_base_addr);\n\n\tif (!external) {\n\t\terr = mv88e6xxx_g2_irq_mdio_setup(chip, bus);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = of_mdiobus_register(bus, np);\n\tif (err) {\n\t\tdev_err(chip->dev, \"Cannot register MDIO bus (%d)\\n\", err);\n\t\tmv88e6xxx_g2_irq_mdio_free(chip, bus);\n\t\tgoto out;\n\t}\n\n\tif (external)\n\t\tlist_add_tail(&mdio_bus->list, &chip->mdios);\n\telse\n\t\tlist_add(&mdio_bus->list, &chip->mdios);\n\n\treturn 0;\n\nout:\n\tmdiobus_free(bus);\n\treturn err;\n}\n\nstatic void mv88e6xxx_mdios_unregister(struct mv88e6xxx_chip *chip)\n\n{\n\tstruct mv88e6xxx_mdio_bus *mdio_bus, *p;\n\tstruct mii_bus *bus;\n\n\tlist_for_each_entry_safe(mdio_bus, p, &chip->mdios, list) {\n\t\tbus = mdio_bus->bus;\n\n\t\tif (!mdio_bus->external)\n\t\t\tmv88e6xxx_g2_irq_mdio_free(chip, bus);\n\n\t\tmdiobus_unregister(bus);\n\t\tmdiobus_free(bus);\n\t}\n}\n\nstatic int mv88e6xxx_mdios_register(struct mv88e6xxx_chip *chip)\n{\n\tstruct device_node *np = chip->dev->of_node;\n\tstruct device_node *child;\n\tint err;\n\n\t \n\tchild = of_get_child_by_name(np, \"mdio\");\n\terr = mv88e6xxx_mdio_register(chip, child, false);\n\tof_node_put(child);\n\tif (err)\n\t\treturn err;\n\n\t \n\tfor_each_available_child_of_node(np, child) {\n\t\tif (of_device_is_compatible(\n\t\t\t    child, \"marvell,mv88e6xxx-mdio-external\")) {\n\t\t\terr = mv88e6xxx_mdio_register(chip, child, true);\n\t\t\tif (err) {\n\t\t\t\tmv88e6xxx_mdios_unregister(chip);\n\t\t\t\tof_node_put(child);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void mv88e6xxx_teardown(struct dsa_switch *ds)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\n\tmv88e6xxx_teardown_devlink_params(ds);\n\tdsa_devlink_resources_unregister(ds);\n\tmv88e6xxx_teardown_devlink_regions_global(ds);\n\tmv88e6xxx_mdios_unregister(chip);\n}\n\nstatic int mv88e6xxx_setup(struct dsa_switch *ds)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tu8 cmode;\n\tint err;\n\tint i;\n\n\terr = mv88e6xxx_mdios_register(chip);\n\tif (err)\n\t\treturn err;\n\n\tchip->ds = ds;\n\tds->slave_mii_bus = mv88e6xxx_default_mdio_bus(chip);\n\n\t \n\tif (mv88e6xxx_has_pvt(chip))\n\t\tds->max_num_bridges = MV88E6XXX_MAX_PVT_SWITCHES -\n\t\t\t\t      ds->dst->last_switch - 1;\n\n\tmv88e6xxx_reg_lock(chip);\n\n\tif (chip->info->ops->setup_errata) {\n\t\terr = chip->info->ops->setup_errata(chip);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\t \n\tfor (i = 0; i < mv88e6xxx_num_ports(chip); i++) {\n\t\tif (chip->info->ops->port_get_cmode) {\n\t\t\terr = chip->info->ops->port_get_cmode(chip, i, &cmode);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\n\t\t\tchip->ports[i].cmode = cmode;\n\t\t}\n\t}\n\n\terr = mv88e6xxx_vtu_setup(chip);\n\tif (err)\n\t\tgoto unlock;\n\n\t \n\terr = mv88e6xxx_stu_setup(chip);\n\tif (err)\n\t\tgoto unlock;\n\n\t \n\tfor (i = 0; i < mv88e6xxx_num_ports(chip); i++) {\n\t\tif (dsa_is_unused_port(ds, i))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (mv88e6xxx_is_invalid_port(chip, i)) {\n\t\t\tdev_err(chip->dev, \"port %d is invalid\\n\", i);\n\t\t\terr = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\terr = mv88e6xxx_setup_port(chip, i);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\terr = mv88e6xxx_irl_setup(chip);\n\tif (err)\n\t\tgoto unlock;\n\n\terr = mv88e6xxx_mac_setup(chip);\n\tif (err)\n\t\tgoto unlock;\n\n\terr = mv88e6xxx_phy_setup(chip);\n\tif (err)\n\t\tgoto unlock;\n\n\terr = mv88e6xxx_pvt_setup(chip);\n\tif (err)\n\t\tgoto unlock;\n\n\terr = mv88e6xxx_atu_setup(chip);\n\tif (err)\n\t\tgoto unlock;\n\n\terr = mv88e6xxx_broadcast_setup(chip, 0);\n\tif (err)\n\t\tgoto unlock;\n\n\terr = mv88e6xxx_pot_setup(chip);\n\tif (err)\n\t\tgoto unlock;\n\n\terr = mv88e6xxx_rmu_setup(chip);\n\tif (err)\n\t\tgoto unlock;\n\n\terr = mv88e6xxx_rsvd2cpu_setup(chip);\n\tif (err)\n\t\tgoto unlock;\n\n\terr = mv88e6xxx_trunk_setup(chip);\n\tif (err)\n\t\tgoto unlock;\n\n\terr = mv88e6xxx_devmap_setup(chip);\n\tif (err)\n\t\tgoto unlock;\n\n\terr = mv88e6xxx_pri_setup(chip);\n\tif (err)\n\t\tgoto unlock;\n\n\t \n\tif (chip->info->ptp_support) {\n\t\terr = mv88e6xxx_ptp_setup(chip);\n\t\tif (err)\n\t\t\tgoto unlock;\n\n\t\terr = mv88e6xxx_hwtstamp_setup(chip);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\terr = mv88e6xxx_stats_setup(chip);\n\tif (err)\n\t\tgoto unlock;\n\nunlock:\n\tmv88e6xxx_reg_unlock(chip);\n\n\tif (err)\n\t\tgoto out_mdios;\n\n\t \n\terr = mv88e6xxx_setup_devlink_resources(ds);\n\tif (err)\n\t\tgoto out_mdios;\n\n\terr = mv88e6xxx_setup_devlink_params(ds);\n\tif (err)\n\t\tgoto out_resources;\n\n\terr = mv88e6xxx_setup_devlink_regions_global(ds);\n\tif (err)\n\t\tgoto out_params;\n\n\treturn 0;\n\nout_params:\n\tmv88e6xxx_teardown_devlink_params(ds);\nout_resources:\n\tdsa_devlink_resources_unregister(ds);\nout_mdios:\n\tmv88e6xxx_mdios_unregister(chip);\n\n\treturn err;\n}\n\nstatic int mv88e6xxx_port_setup(struct dsa_switch *ds, int port)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err;\n\n\tif (chip->info->ops->pcs_ops &&\n\t    chip->info->ops->pcs_ops->pcs_init) {\n\t\terr = chip->info->ops->pcs_ops->pcs_init(chip, port);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn mv88e6xxx_setup_devlink_regions_port(ds, port);\n}\n\nstatic void mv88e6xxx_port_teardown(struct dsa_switch *ds, int port)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\n\tmv88e6xxx_teardown_devlink_regions_port(ds, port);\n\n\tif (chip->info->ops->pcs_ops &&\n\t    chip->info->ops->pcs_ops->pcs_teardown)\n\t\tchip->info->ops->pcs_ops->pcs_teardown(chip, port);\n}\n\nstatic int mv88e6xxx_get_eeprom_len(struct dsa_switch *ds)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\n\treturn chip->eeprom_len;\n}\n\nstatic int mv88e6xxx_get_eeprom(struct dsa_switch *ds,\n\t\t\t\tstruct ethtool_eeprom *eeprom, u8 *data)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err;\n\n\tif (!chip->info->ops->get_eeprom)\n\t\treturn -EOPNOTSUPP;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = chip->info->ops->get_eeprom(chip, eeprom, data);\n\tmv88e6xxx_reg_unlock(chip);\n\n\tif (err)\n\t\treturn err;\n\n\teeprom->magic = 0xc3ec4951;\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_set_eeprom(struct dsa_switch *ds,\n\t\t\t\tstruct ethtool_eeprom *eeprom, u8 *data)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err;\n\n\tif (!chip->info->ops->set_eeprom)\n\t\treturn -EOPNOTSUPP;\n\n\tif (eeprom->magic != 0xc3ec4951)\n\t\treturn -EINVAL;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = chip->info->ops->set_eeprom(chip, eeprom, data);\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err;\n}\n\nstatic const struct mv88e6xxx_ops mv88e6085_ops = {\n\t \n\t.ieee_pri_map = mv88e6085_g1_ieee_pri_map,\n\t.ip_pri_map = mv88e6085_g1_ip_pri_map,\n\t.irl_init_all = mv88e6352_g2_irl_init_all,\n\t.set_switch_mac = mv88e6xxx_g1_set_switch_mac,\n\t.phy_read = mv88e6185_phy_ppu_read,\n\t.phy_write = mv88e6185_phy_ppu_write,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6xxx_port_sync_link,\n\t.port_set_speed_duplex = mv88e6185_port_set_speed_duplex,\n\t.port_tag_remap = mv88e6095_port_tag_remap,\n\t.port_set_policy = mv88e6352_port_set_policy,\n\t.port_set_frame_mode = mv88e6351_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6352_port_set_ucast_flood,\n\t.port_set_mcast_flood = mv88e6352_port_set_mcast_flood,\n\t.port_set_ether_type = mv88e6351_port_set_ether_type,\n\t.port_egress_rate_limiting = mv88e6097_port_egress_rate_limiting,\n\t.port_pause_limit = mv88e6097_port_pause_limit,\n\t.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,\n\t.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,\n\t.port_get_cmode = mv88e6185_port_get_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.stats_snapshot = mv88e6xxx_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6095_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6095_stats_get_sset_count,\n\t.stats_get_strings = mv88e6095_stats_get_strings,\n\t.stats_get_stats = mv88e6095_stats_get_stats,\n\t.set_cpu_port = mv88e6095_g1_set_cpu_port,\n\t.set_egress_port = mv88e6095_g1_set_egress_port,\n\t.watchdog_ops = &mv88e6097_watchdog_ops,\n\t.mgmt_rsvd2cpu = mv88e6352_g2_mgmt_rsvd2cpu,\n\t.pot_clear = mv88e6xxx_g2_pot_clear,\n\t.ppu_enable = mv88e6185_g1_ppu_enable,\n\t.ppu_disable = mv88e6185_g1_ppu_disable,\n\t.reset = mv88e6185_g1_reset,\n\t.rmu_disable = mv88e6085_g1_rmu_disable,\n\t.vtu_getnext = mv88e6352_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,\n\t.stu_getnext = mv88e6352_g1_stu_getnext,\n\t.stu_loadpurge = mv88e6352_g1_stu_loadpurge,\n\t.phylink_get_caps = mv88e6185_phylink_get_caps,\n\t.set_max_frame_size = mv88e6185_g1_set_max_frame_size,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6095_ops = {\n\t \n\t.ieee_pri_map = mv88e6085_g1_ieee_pri_map,\n\t.ip_pri_map = mv88e6085_g1_ip_pri_map,\n\t.set_switch_mac = mv88e6xxx_g1_set_switch_mac,\n\t.phy_read = mv88e6185_phy_ppu_read,\n\t.phy_write = mv88e6185_phy_ppu_write,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6185_port_sync_link,\n\t.port_set_speed_duplex = mv88e6185_port_set_speed_duplex,\n\t.port_set_frame_mode = mv88e6085_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6185_port_set_forward_unknown,\n\t.port_set_mcast_flood = mv88e6185_port_set_default_forward,\n\t.port_set_upstream_port = mv88e6095_port_set_upstream_port,\n\t.port_get_cmode = mv88e6185_port_get_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.stats_snapshot = mv88e6xxx_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6095_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6095_stats_get_sset_count,\n\t.stats_get_strings = mv88e6095_stats_get_strings,\n\t.stats_get_stats = mv88e6095_stats_get_stats,\n\t.mgmt_rsvd2cpu = mv88e6185_g2_mgmt_rsvd2cpu,\n\t.ppu_enable = mv88e6185_g1_ppu_enable,\n\t.ppu_disable = mv88e6185_g1_ppu_disable,\n\t.reset = mv88e6185_g1_reset,\n\t.vtu_getnext = mv88e6185_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6185_g1_vtu_loadpurge,\n\t.phylink_get_caps = mv88e6095_phylink_get_caps,\n\t.pcs_ops = &mv88e6185_pcs_ops,\n\t.set_max_frame_size = mv88e6185_g1_set_max_frame_size,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6097_ops = {\n\t \n\t.ieee_pri_map = mv88e6085_g1_ieee_pri_map,\n\t.ip_pri_map = mv88e6085_g1_ip_pri_map,\n\t.irl_init_all = mv88e6352_g2_irl_init_all,\n\t.set_switch_mac = mv88e6xxx_g2_set_switch_mac,\n\t.phy_read = mv88e6xxx_g2_smi_phy_read_c22,\n\t.phy_write = mv88e6xxx_g2_smi_phy_write_c22,\n\t.phy_read_c45 = mv88e6xxx_g2_smi_phy_read_c45,\n\t.phy_write_c45 = mv88e6xxx_g2_smi_phy_write_c45,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6185_port_sync_link,\n\t.port_set_speed_duplex = mv88e6185_port_set_speed_duplex,\n\t.port_tag_remap = mv88e6095_port_tag_remap,\n\t.port_set_policy = mv88e6352_port_set_policy,\n\t.port_set_frame_mode = mv88e6351_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6352_port_set_ucast_flood,\n\t.port_set_mcast_flood = mv88e6352_port_set_mcast_flood,\n\t.port_set_ether_type = mv88e6351_port_set_ether_type,\n\t.port_egress_rate_limiting = mv88e6095_port_egress_rate_limiting,\n\t.port_pause_limit = mv88e6097_port_pause_limit,\n\t.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,\n\t.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,\n\t.port_get_cmode = mv88e6185_port_get_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.stats_snapshot = mv88e6xxx_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6095_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6095_stats_get_sset_count,\n\t.stats_get_strings = mv88e6095_stats_get_strings,\n\t.stats_get_stats = mv88e6095_stats_get_stats,\n\t.set_cpu_port = mv88e6095_g1_set_cpu_port,\n\t.set_egress_port = mv88e6095_g1_set_egress_port,\n\t.watchdog_ops = &mv88e6097_watchdog_ops,\n\t.mgmt_rsvd2cpu = mv88e6352_g2_mgmt_rsvd2cpu,\n\t.serdes_irq_mapping = mv88e6390_serdes_irq_mapping,\n\t.pot_clear = mv88e6xxx_g2_pot_clear,\n\t.reset = mv88e6352_g1_reset,\n\t.rmu_disable = mv88e6085_g1_rmu_disable,\n\t.vtu_getnext = mv88e6352_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,\n\t.phylink_get_caps = mv88e6095_phylink_get_caps,\n\t.pcs_ops = &mv88e6185_pcs_ops,\n\t.stu_getnext = mv88e6352_g1_stu_getnext,\n\t.stu_loadpurge = mv88e6352_g1_stu_loadpurge,\n\t.set_max_frame_size = mv88e6185_g1_set_max_frame_size,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6123_ops = {\n\t \n\t.ieee_pri_map = mv88e6085_g1_ieee_pri_map,\n\t.ip_pri_map = mv88e6085_g1_ip_pri_map,\n\t.irl_init_all = mv88e6352_g2_irl_init_all,\n\t.set_switch_mac = mv88e6xxx_g2_set_switch_mac,\n\t.phy_read = mv88e6xxx_g2_smi_phy_read_c22,\n\t.phy_write = mv88e6xxx_g2_smi_phy_write_c22,\n\t.phy_read_c45 = mv88e6xxx_g2_smi_phy_read_c45,\n\t.phy_write_c45 = mv88e6xxx_g2_smi_phy_write_c45,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6xxx_port_sync_link,\n\t.port_set_speed_duplex = mv88e6185_port_set_speed_duplex,\n\t.port_set_frame_mode = mv88e6085_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6352_port_set_ucast_flood,\n\t.port_set_mcast_flood = mv88e6352_port_set_mcast_flood,\n\t.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,\n\t.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,\n\t.port_get_cmode = mv88e6185_port_get_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.stats_snapshot = mv88e6320_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6095_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6095_stats_get_sset_count,\n\t.stats_get_strings = mv88e6095_stats_get_strings,\n\t.stats_get_stats = mv88e6095_stats_get_stats,\n\t.set_cpu_port = mv88e6095_g1_set_cpu_port,\n\t.set_egress_port = mv88e6095_g1_set_egress_port,\n\t.watchdog_ops = &mv88e6097_watchdog_ops,\n\t.mgmt_rsvd2cpu = mv88e6352_g2_mgmt_rsvd2cpu,\n\t.pot_clear = mv88e6xxx_g2_pot_clear,\n\t.reset = mv88e6352_g1_reset,\n\t.atu_get_hash = mv88e6165_g1_atu_get_hash,\n\t.atu_set_hash = mv88e6165_g1_atu_set_hash,\n\t.vtu_getnext = mv88e6352_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,\n\t.stu_getnext = mv88e6352_g1_stu_getnext,\n\t.stu_loadpurge = mv88e6352_g1_stu_loadpurge,\n\t.phylink_get_caps = mv88e6185_phylink_get_caps,\n\t.set_max_frame_size = mv88e6185_g1_set_max_frame_size,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6131_ops = {\n\t \n\t.ieee_pri_map = mv88e6085_g1_ieee_pri_map,\n\t.ip_pri_map = mv88e6085_g1_ip_pri_map,\n\t.set_switch_mac = mv88e6xxx_g1_set_switch_mac,\n\t.phy_read = mv88e6185_phy_ppu_read,\n\t.phy_write = mv88e6185_phy_ppu_write,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6xxx_port_sync_link,\n\t.port_set_speed_duplex = mv88e6185_port_set_speed_duplex,\n\t.port_tag_remap = mv88e6095_port_tag_remap,\n\t.port_set_frame_mode = mv88e6351_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6185_port_set_forward_unknown,\n\t.port_set_mcast_flood = mv88e6185_port_set_default_forward,\n\t.port_set_ether_type = mv88e6351_port_set_ether_type,\n\t.port_set_upstream_port = mv88e6095_port_set_upstream_port,\n\t.port_set_jumbo_size = mv88e6165_port_set_jumbo_size,\n\t.port_egress_rate_limiting = mv88e6097_port_egress_rate_limiting,\n\t.port_pause_limit = mv88e6097_port_pause_limit,\n\t.port_set_pause = mv88e6185_port_set_pause,\n\t.port_get_cmode = mv88e6185_port_get_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.stats_snapshot = mv88e6xxx_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6095_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6095_stats_get_sset_count,\n\t.stats_get_strings = mv88e6095_stats_get_strings,\n\t.stats_get_stats = mv88e6095_stats_get_stats,\n\t.set_cpu_port = mv88e6095_g1_set_cpu_port,\n\t.set_egress_port = mv88e6095_g1_set_egress_port,\n\t.watchdog_ops = &mv88e6097_watchdog_ops,\n\t.mgmt_rsvd2cpu = mv88e6185_g2_mgmt_rsvd2cpu,\n\t.ppu_enable = mv88e6185_g1_ppu_enable,\n\t.set_cascade_port = mv88e6185_g1_set_cascade_port,\n\t.ppu_disable = mv88e6185_g1_ppu_disable,\n\t.reset = mv88e6185_g1_reset,\n\t.vtu_getnext = mv88e6185_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6185_g1_vtu_loadpurge,\n\t.phylink_get_caps = mv88e6185_phylink_get_caps,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6141_ops = {\n\t \n\t.ieee_pri_map = mv88e6085_g1_ieee_pri_map,\n\t.ip_pri_map = mv88e6085_g1_ip_pri_map,\n\t.irl_init_all = mv88e6352_g2_irl_init_all,\n\t.get_eeprom = mv88e6xxx_g2_get_eeprom8,\n\t.set_eeprom = mv88e6xxx_g2_set_eeprom8,\n\t.set_switch_mac = mv88e6xxx_g2_set_switch_mac,\n\t.phy_read = mv88e6xxx_g2_smi_phy_read_c22,\n\t.phy_write = mv88e6xxx_g2_smi_phy_write_c22,\n\t.phy_read_c45 = mv88e6xxx_g2_smi_phy_read_c45,\n\t.phy_write_c45 = mv88e6xxx_g2_smi_phy_write_c45,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6xxx_port_sync_link,\n\t.port_set_rgmii_delay = mv88e6390_port_set_rgmii_delay,\n\t.port_set_speed_duplex = mv88e6341_port_set_speed_duplex,\n\t.port_max_speed_mode = mv88e6341_port_max_speed_mode,\n\t.port_tag_remap = mv88e6095_port_tag_remap,\n\t.port_set_policy = mv88e6352_port_set_policy,\n\t.port_set_frame_mode = mv88e6351_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6352_port_set_ucast_flood,\n\t.port_set_mcast_flood = mv88e6352_port_set_mcast_flood,\n\t.port_set_ether_type = mv88e6351_port_set_ether_type,\n\t.port_set_jumbo_size = mv88e6165_port_set_jumbo_size,\n\t.port_egress_rate_limiting = mv88e6097_port_egress_rate_limiting,\n\t.port_pause_limit = mv88e6097_port_pause_limit,\n\t.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,\n\t.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,\n\t.port_get_cmode = mv88e6352_port_get_cmode,\n\t.port_set_cmode = mv88e6341_port_set_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.stats_snapshot = mv88e6390_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6390_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6320_stats_get_sset_count,\n\t.stats_get_strings = mv88e6320_stats_get_strings,\n\t.stats_get_stats = mv88e6390_stats_get_stats,\n\t.set_cpu_port = mv88e6390_g1_set_cpu_port,\n\t.set_egress_port = mv88e6390_g1_set_egress_port,\n\t.watchdog_ops = &mv88e6390_watchdog_ops,\n\t.mgmt_rsvd2cpu =  mv88e6390_g1_mgmt_rsvd2cpu,\n\t.pot_clear = mv88e6xxx_g2_pot_clear,\n\t.reset = mv88e6352_g1_reset,\n\t.rmu_disable = mv88e6390_g1_rmu_disable,\n\t.atu_get_hash = mv88e6165_g1_atu_get_hash,\n\t.atu_set_hash = mv88e6165_g1_atu_set_hash,\n\t.vtu_getnext = mv88e6352_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,\n\t.stu_getnext = mv88e6352_g1_stu_getnext,\n\t.stu_loadpurge = mv88e6352_g1_stu_loadpurge,\n\t.serdes_get_lane = mv88e6341_serdes_get_lane,\n\t.serdes_irq_mapping = mv88e6390_serdes_irq_mapping,\n\t.gpio_ops = &mv88e6352_gpio_ops,\n\t.serdes_get_sset_count = mv88e6390_serdes_get_sset_count,\n\t.serdes_get_strings = mv88e6390_serdes_get_strings,\n\t.serdes_get_stats = mv88e6390_serdes_get_stats,\n\t.serdes_get_regs_len = mv88e6390_serdes_get_regs_len,\n\t.serdes_get_regs = mv88e6390_serdes_get_regs,\n\t.phylink_get_caps = mv88e6341_phylink_get_caps,\n\t.pcs_ops = &mv88e6390_pcs_ops,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6161_ops = {\n\t \n\t.ieee_pri_map = mv88e6085_g1_ieee_pri_map,\n\t.ip_pri_map = mv88e6085_g1_ip_pri_map,\n\t.irl_init_all = mv88e6352_g2_irl_init_all,\n\t.set_switch_mac = mv88e6xxx_g2_set_switch_mac,\n\t.phy_read = mv88e6xxx_g2_smi_phy_read_c22,\n\t.phy_write = mv88e6xxx_g2_smi_phy_write_c22,\n\t.phy_read_c45 = mv88e6xxx_g2_smi_phy_read_c45,\n\t.phy_write_c45 = mv88e6xxx_g2_smi_phy_write_c45,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6xxx_port_sync_link,\n\t.port_set_speed_duplex = mv88e6185_port_set_speed_duplex,\n\t.port_tag_remap = mv88e6095_port_tag_remap,\n\t.port_set_policy = mv88e6352_port_set_policy,\n\t.port_set_frame_mode = mv88e6351_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6352_port_set_ucast_flood,\n\t.port_set_mcast_flood = mv88e6352_port_set_mcast_flood,\n\t.port_set_ether_type = mv88e6351_port_set_ether_type,\n\t.port_egress_rate_limiting = mv88e6097_port_egress_rate_limiting,\n\t.port_pause_limit = mv88e6097_port_pause_limit,\n\t.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,\n\t.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,\n\t.port_get_cmode = mv88e6185_port_get_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.stats_snapshot = mv88e6xxx_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6095_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6095_stats_get_sset_count,\n\t.stats_get_strings = mv88e6095_stats_get_strings,\n\t.stats_get_stats = mv88e6095_stats_get_stats,\n\t.set_cpu_port = mv88e6095_g1_set_cpu_port,\n\t.set_egress_port = mv88e6095_g1_set_egress_port,\n\t.watchdog_ops = &mv88e6097_watchdog_ops,\n\t.mgmt_rsvd2cpu = mv88e6352_g2_mgmt_rsvd2cpu,\n\t.pot_clear = mv88e6xxx_g2_pot_clear,\n\t.reset = mv88e6352_g1_reset,\n\t.atu_get_hash = mv88e6165_g1_atu_get_hash,\n\t.atu_set_hash = mv88e6165_g1_atu_set_hash,\n\t.vtu_getnext = mv88e6352_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,\n\t.stu_getnext = mv88e6352_g1_stu_getnext,\n\t.stu_loadpurge = mv88e6352_g1_stu_loadpurge,\n\t.avb_ops = &mv88e6165_avb_ops,\n\t.ptp_ops = &mv88e6165_ptp_ops,\n\t.phylink_get_caps = mv88e6185_phylink_get_caps,\n\t.set_max_frame_size = mv88e6185_g1_set_max_frame_size,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6165_ops = {\n\t \n\t.ieee_pri_map = mv88e6085_g1_ieee_pri_map,\n\t.ip_pri_map = mv88e6085_g1_ip_pri_map,\n\t.irl_init_all = mv88e6352_g2_irl_init_all,\n\t.set_switch_mac = mv88e6xxx_g2_set_switch_mac,\n\t.phy_read = mv88e6165_phy_read,\n\t.phy_write = mv88e6165_phy_write,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6xxx_port_sync_link,\n\t.port_set_speed_duplex = mv88e6185_port_set_speed_duplex,\n\t.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,\n\t.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,\n\t.port_get_cmode = mv88e6185_port_get_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.stats_snapshot = mv88e6xxx_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6095_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6095_stats_get_sset_count,\n\t.stats_get_strings = mv88e6095_stats_get_strings,\n\t.stats_get_stats = mv88e6095_stats_get_stats,\n\t.set_cpu_port = mv88e6095_g1_set_cpu_port,\n\t.set_egress_port = mv88e6095_g1_set_egress_port,\n\t.watchdog_ops = &mv88e6097_watchdog_ops,\n\t.mgmt_rsvd2cpu = mv88e6352_g2_mgmt_rsvd2cpu,\n\t.pot_clear = mv88e6xxx_g2_pot_clear,\n\t.reset = mv88e6352_g1_reset,\n\t.atu_get_hash = mv88e6165_g1_atu_get_hash,\n\t.atu_set_hash = mv88e6165_g1_atu_set_hash,\n\t.vtu_getnext = mv88e6352_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,\n\t.stu_getnext = mv88e6352_g1_stu_getnext,\n\t.stu_loadpurge = mv88e6352_g1_stu_loadpurge,\n\t.avb_ops = &mv88e6165_avb_ops,\n\t.ptp_ops = &mv88e6165_ptp_ops,\n\t.phylink_get_caps = mv88e6185_phylink_get_caps,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6171_ops = {\n\t \n\t.ieee_pri_map = mv88e6085_g1_ieee_pri_map,\n\t.ip_pri_map = mv88e6085_g1_ip_pri_map,\n\t.irl_init_all = mv88e6352_g2_irl_init_all,\n\t.set_switch_mac = mv88e6xxx_g2_set_switch_mac,\n\t.phy_read = mv88e6xxx_g2_smi_phy_read_c22,\n\t.phy_write = mv88e6xxx_g2_smi_phy_write_c22,\n\t.phy_read_c45 = mv88e6xxx_g2_smi_phy_read_c45,\n\t.phy_write_c45 = mv88e6xxx_g2_smi_phy_write_c45,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6xxx_port_sync_link,\n\t.port_set_rgmii_delay = mv88e6352_port_set_rgmii_delay,\n\t.port_set_speed_duplex = mv88e6185_port_set_speed_duplex,\n\t.port_tag_remap = mv88e6095_port_tag_remap,\n\t.port_set_frame_mode = mv88e6351_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6352_port_set_ucast_flood,\n\t.port_set_mcast_flood = mv88e6352_port_set_mcast_flood,\n\t.port_set_ether_type = mv88e6351_port_set_ether_type,\n\t.port_set_jumbo_size = mv88e6165_port_set_jumbo_size,\n\t.port_egress_rate_limiting = mv88e6097_port_egress_rate_limiting,\n\t.port_pause_limit = mv88e6097_port_pause_limit,\n\t.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,\n\t.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,\n\t.port_get_cmode = mv88e6352_port_get_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.stats_snapshot = mv88e6320_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6095_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6095_stats_get_sset_count,\n\t.stats_get_strings = mv88e6095_stats_get_strings,\n\t.stats_get_stats = mv88e6095_stats_get_stats,\n\t.set_cpu_port = mv88e6095_g1_set_cpu_port,\n\t.set_egress_port = mv88e6095_g1_set_egress_port,\n\t.watchdog_ops = &mv88e6097_watchdog_ops,\n\t.mgmt_rsvd2cpu = mv88e6352_g2_mgmt_rsvd2cpu,\n\t.pot_clear = mv88e6xxx_g2_pot_clear,\n\t.reset = mv88e6352_g1_reset,\n\t.atu_get_hash = mv88e6165_g1_atu_get_hash,\n\t.atu_set_hash = mv88e6165_g1_atu_set_hash,\n\t.vtu_getnext = mv88e6352_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,\n\t.stu_getnext = mv88e6352_g1_stu_getnext,\n\t.stu_loadpurge = mv88e6352_g1_stu_loadpurge,\n\t.phylink_get_caps = mv88e6351_phylink_get_caps,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6172_ops = {\n\t \n\t.ieee_pri_map = mv88e6085_g1_ieee_pri_map,\n\t.ip_pri_map = mv88e6085_g1_ip_pri_map,\n\t.irl_init_all = mv88e6352_g2_irl_init_all,\n\t.get_eeprom = mv88e6xxx_g2_get_eeprom16,\n\t.set_eeprom = mv88e6xxx_g2_set_eeprom16,\n\t.set_switch_mac = mv88e6xxx_g2_set_switch_mac,\n\t.phy_read = mv88e6xxx_g2_smi_phy_read_c22,\n\t.phy_write = mv88e6xxx_g2_smi_phy_write_c22,\n\t.phy_read_c45 = mv88e6xxx_g2_smi_phy_read_c45,\n\t.phy_write_c45 = mv88e6xxx_g2_smi_phy_write_c45,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6xxx_port_sync_link,\n\t.port_set_rgmii_delay = mv88e6352_port_set_rgmii_delay,\n\t.port_set_speed_duplex = mv88e6352_port_set_speed_duplex,\n\t.port_tag_remap = mv88e6095_port_tag_remap,\n\t.port_set_policy = mv88e6352_port_set_policy,\n\t.port_set_frame_mode = mv88e6351_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6352_port_set_ucast_flood,\n\t.port_set_mcast_flood = mv88e6352_port_set_mcast_flood,\n\t.port_set_ether_type = mv88e6351_port_set_ether_type,\n\t.port_set_jumbo_size = mv88e6165_port_set_jumbo_size,\n\t.port_egress_rate_limiting = mv88e6097_port_egress_rate_limiting,\n\t.port_pause_limit = mv88e6097_port_pause_limit,\n\t.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,\n\t.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,\n\t.port_get_cmode = mv88e6352_port_get_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.stats_snapshot = mv88e6320_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6095_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6095_stats_get_sset_count,\n\t.stats_get_strings = mv88e6095_stats_get_strings,\n\t.stats_get_stats = mv88e6095_stats_get_stats,\n\t.set_cpu_port = mv88e6095_g1_set_cpu_port,\n\t.set_egress_port = mv88e6095_g1_set_egress_port,\n\t.watchdog_ops = &mv88e6097_watchdog_ops,\n\t.mgmt_rsvd2cpu = mv88e6352_g2_mgmt_rsvd2cpu,\n\t.pot_clear = mv88e6xxx_g2_pot_clear,\n\t.reset = mv88e6352_g1_reset,\n\t.rmu_disable = mv88e6352_g1_rmu_disable,\n\t.atu_get_hash = mv88e6165_g1_atu_get_hash,\n\t.atu_set_hash = mv88e6165_g1_atu_set_hash,\n\t.vtu_getnext = mv88e6352_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,\n\t.stu_getnext = mv88e6352_g1_stu_getnext,\n\t.stu_loadpurge = mv88e6352_g1_stu_loadpurge,\n\t.serdes_get_regs_len = mv88e6352_serdes_get_regs_len,\n\t.serdes_get_regs = mv88e6352_serdes_get_regs,\n\t.gpio_ops = &mv88e6352_gpio_ops,\n\t.phylink_get_caps = mv88e6352_phylink_get_caps,\n\t.pcs_ops = &mv88e6352_pcs_ops,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6175_ops = {\n\t \n\t.ieee_pri_map = mv88e6085_g1_ieee_pri_map,\n\t.ip_pri_map = mv88e6085_g1_ip_pri_map,\n\t.irl_init_all = mv88e6352_g2_irl_init_all,\n\t.set_switch_mac = mv88e6xxx_g2_set_switch_mac,\n\t.phy_read = mv88e6xxx_g2_smi_phy_read_c22,\n\t.phy_write = mv88e6xxx_g2_smi_phy_write_c22,\n\t.phy_read_c45 = mv88e6xxx_g2_smi_phy_read_c45,\n\t.phy_write_c45 = mv88e6xxx_g2_smi_phy_write_c45,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6xxx_port_sync_link,\n\t.port_set_rgmii_delay = mv88e6352_port_set_rgmii_delay,\n\t.port_set_speed_duplex = mv88e6185_port_set_speed_duplex,\n\t.port_tag_remap = mv88e6095_port_tag_remap,\n\t.port_set_frame_mode = mv88e6351_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6352_port_set_ucast_flood,\n\t.port_set_mcast_flood = mv88e6352_port_set_mcast_flood,\n\t.port_set_ether_type = mv88e6351_port_set_ether_type,\n\t.port_set_jumbo_size = mv88e6165_port_set_jumbo_size,\n\t.port_egress_rate_limiting = mv88e6097_port_egress_rate_limiting,\n\t.port_pause_limit = mv88e6097_port_pause_limit,\n\t.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,\n\t.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,\n\t.port_get_cmode = mv88e6352_port_get_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.stats_snapshot = mv88e6320_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6095_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6095_stats_get_sset_count,\n\t.stats_get_strings = mv88e6095_stats_get_strings,\n\t.stats_get_stats = mv88e6095_stats_get_stats,\n\t.set_cpu_port = mv88e6095_g1_set_cpu_port,\n\t.set_egress_port = mv88e6095_g1_set_egress_port,\n\t.watchdog_ops = &mv88e6097_watchdog_ops,\n\t.mgmt_rsvd2cpu = mv88e6352_g2_mgmt_rsvd2cpu,\n\t.pot_clear = mv88e6xxx_g2_pot_clear,\n\t.reset = mv88e6352_g1_reset,\n\t.atu_get_hash = mv88e6165_g1_atu_get_hash,\n\t.atu_set_hash = mv88e6165_g1_atu_set_hash,\n\t.vtu_getnext = mv88e6352_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,\n\t.stu_getnext = mv88e6352_g1_stu_getnext,\n\t.stu_loadpurge = mv88e6352_g1_stu_loadpurge,\n\t.phylink_get_caps = mv88e6351_phylink_get_caps,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6176_ops = {\n\t \n\t.ieee_pri_map = mv88e6085_g1_ieee_pri_map,\n\t.ip_pri_map = mv88e6085_g1_ip_pri_map,\n\t.irl_init_all = mv88e6352_g2_irl_init_all,\n\t.get_eeprom = mv88e6xxx_g2_get_eeprom16,\n\t.set_eeprom = mv88e6xxx_g2_set_eeprom16,\n\t.set_switch_mac = mv88e6xxx_g2_set_switch_mac,\n\t.phy_read = mv88e6xxx_g2_smi_phy_read_c22,\n\t.phy_write = mv88e6xxx_g2_smi_phy_write_c22,\n\t.phy_read_c45 = mv88e6xxx_g2_smi_phy_read_c45,\n\t.phy_write_c45 = mv88e6xxx_g2_smi_phy_write_c45,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6xxx_port_sync_link,\n\t.port_set_rgmii_delay = mv88e6352_port_set_rgmii_delay,\n\t.port_set_speed_duplex = mv88e6352_port_set_speed_duplex,\n\t.port_tag_remap = mv88e6095_port_tag_remap,\n\t.port_set_policy = mv88e6352_port_set_policy,\n\t.port_set_frame_mode = mv88e6351_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6352_port_set_ucast_flood,\n\t.port_set_mcast_flood = mv88e6352_port_set_mcast_flood,\n\t.port_set_ether_type = mv88e6351_port_set_ether_type,\n\t.port_set_jumbo_size = mv88e6165_port_set_jumbo_size,\n\t.port_egress_rate_limiting = mv88e6097_port_egress_rate_limiting,\n\t.port_pause_limit = mv88e6097_port_pause_limit,\n\t.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,\n\t.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,\n\t.port_get_cmode = mv88e6352_port_get_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.stats_snapshot = mv88e6320_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6095_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6095_stats_get_sset_count,\n\t.stats_get_strings = mv88e6095_stats_get_strings,\n\t.stats_get_stats = mv88e6095_stats_get_stats,\n\t.set_cpu_port = mv88e6095_g1_set_cpu_port,\n\t.set_egress_port = mv88e6095_g1_set_egress_port,\n\t.watchdog_ops = &mv88e6097_watchdog_ops,\n\t.mgmt_rsvd2cpu = mv88e6352_g2_mgmt_rsvd2cpu,\n\t.pot_clear = mv88e6xxx_g2_pot_clear,\n\t.reset = mv88e6352_g1_reset,\n\t.rmu_disable = mv88e6352_g1_rmu_disable,\n\t.atu_get_hash = mv88e6165_g1_atu_get_hash,\n\t.atu_set_hash = mv88e6165_g1_atu_set_hash,\n\t.vtu_getnext = mv88e6352_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,\n\t.stu_getnext = mv88e6352_g1_stu_getnext,\n\t.stu_loadpurge = mv88e6352_g1_stu_loadpurge,\n\t.serdes_irq_mapping = mv88e6352_serdes_irq_mapping,\n\t.serdes_get_regs_len = mv88e6352_serdes_get_regs_len,\n\t.serdes_get_regs = mv88e6352_serdes_get_regs,\n\t.serdes_set_tx_amplitude = mv88e6352_serdes_set_tx_amplitude,\n\t.gpio_ops = &mv88e6352_gpio_ops,\n\t.phylink_get_caps = mv88e6352_phylink_get_caps,\n\t.pcs_ops = &mv88e6352_pcs_ops,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6185_ops = {\n\t \n\t.ieee_pri_map = mv88e6085_g1_ieee_pri_map,\n\t.ip_pri_map = mv88e6085_g1_ip_pri_map,\n\t.set_switch_mac = mv88e6xxx_g1_set_switch_mac,\n\t.phy_read = mv88e6185_phy_ppu_read,\n\t.phy_write = mv88e6185_phy_ppu_write,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6185_port_sync_link,\n\t.port_set_speed_duplex = mv88e6185_port_set_speed_duplex,\n\t.port_set_frame_mode = mv88e6085_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6185_port_set_forward_unknown,\n\t.port_set_mcast_flood = mv88e6185_port_set_default_forward,\n\t.port_egress_rate_limiting = mv88e6095_port_egress_rate_limiting,\n\t.port_set_upstream_port = mv88e6095_port_set_upstream_port,\n\t.port_set_pause = mv88e6185_port_set_pause,\n\t.port_get_cmode = mv88e6185_port_get_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.stats_snapshot = mv88e6xxx_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6095_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6095_stats_get_sset_count,\n\t.stats_get_strings = mv88e6095_stats_get_strings,\n\t.stats_get_stats = mv88e6095_stats_get_stats,\n\t.set_cpu_port = mv88e6095_g1_set_cpu_port,\n\t.set_egress_port = mv88e6095_g1_set_egress_port,\n\t.watchdog_ops = &mv88e6097_watchdog_ops,\n\t.mgmt_rsvd2cpu = mv88e6185_g2_mgmt_rsvd2cpu,\n\t.set_cascade_port = mv88e6185_g1_set_cascade_port,\n\t.ppu_enable = mv88e6185_g1_ppu_enable,\n\t.ppu_disable = mv88e6185_g1_ppu_disable,\n\t.reset = mv88e6185_g1_reset,\n\t.vtu_getnext = mv88e6185_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6185_g1_vtu_loadpurge,\n\t.phylink_get_caps = mv88e6185_phylink_get_caps,\n\t.pcs_ops = &mv88e6185_pcs_ops,\n\t.set_max_frame_size = mv88e6185_g1_set_max_frame_size,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6190_ops = {\n\t \n\t.setup_errata = mv88e6390_setup_errata,\n\t.irl_init_all = mv88e6390_g2_irl_init_all,\n\t.get_eeprom = mv88e6xxx_g2_get_eeprom8,\n\t.set_eeprom = mv88e6xxx_g2_set_eeprom8,\n\t.set_switch_mac = mv88e6xxx_g2_set_switch_mac,\n\t.phy_read = mv88e6xxx_g2_smi_phy_read_c22,\n\t.phy_write = mv88e6xxx_g2_smi_phy_write_c22,\n\t.phy_read_c45 = mv88e6xxx_g2_smi_phy_read_c45,\n\t.phy_write_c45 = mv88e6xxx_g2_smi_phy_write_c45,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6xxx_port_sync_link,\n\t.port_set_rgmii_delay = mv88e6390_port_set_rgmii_delay,\n\t.port_set_speed_duplex = mv88e6390_port_set_speed_duplex,\n\t.port_max_speed_mode = mv88e6390_port_max_speed_mode,\n\t.port_tag_remap = mv88e6390_port_tag_remap,\n\t.port_set_policy = mv88e6352_port_set_policy,\n\t.port_set_frame_mode = mv88e6351_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6352_port_set_ucast_flood,\n\t.port_set_mcast_flood = mv88e6352_port_set_mcast_flood,\n\t.port_set_ether_type = mv88e6351_port_set_ether_type,\n\t.port_set_jumbo_size = mv88e6165_port_set_jumbo_size,\n\t.port_pause_limit = mv88e6390_port_pause_limit,\n\t.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,\n\t.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,\n\t.port_get_cmode = mv88e6352_port_get_cmode,\n\t.port_set_cmode = mv88e6390_port_set_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.stats_snapshot = mv88e6390_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6390_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6320_stats_get_sset_count,\n\t.stats_get_strings = mv88e6320_stats_get_strings,\n\t.stats_get_stats = mv88e6390_stats_get_stats,\n\t.set_cpu_port = mv88e6390_g1_set_cpu_port,\n\t.set_egress_port = mv88e6390_g1_set_egress_port,\n\t.watchdog_ops = &mv88e6390_watchdog_ops,\n\t.mgmt_rsvd2cpu = mv88e6390_g1_mgmt_rsvd2cpu,\n\t.pot_clear = mv88e6xxx_g2_pot_clear,\n\t.reset = mv88e6352_g1_reset,\n\t.rmu_disable = mv88e6390_g1_rmu_disable,\n\t.atu_get_hash = mv88e6165_g1_atu_get_hash,\n\t.atu_set_hash = mv88e6165_g1_atu_set_hash,\n\t.vtu_getnext = mv88e6390_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,\n\t.stu_getnext = mv88e6390_g1_stu_getnext,\n\t.stu_loadpurge = mv88e6390_g1_stu_loadpurge,\n\t.serdes_get_lane = mv88e6390_serdes_get_lane,\n\t.serdes_irq_mapping = mv88e6390_serdes_irq_mapping,\n\t.serdes_get_strings = mv88e6390_serdes_get_strings,\n\t.serdes_get_stats = mv88e6390_serdes_get_stats,\n\t.serdes_get_regs_len = mv88e6390_serdes_get_regs_len,\n\t.serdes_get_regs = mv88e6390_serdes_get_regs,\n\t.gpio_ops = &mv88e6352_gpio_ops,\n\t.phylink_get_caps = mv88e6390_phylink_get_caps,\n\t.pcs_ops = &mv88e6390_pcs_ops,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6190x_ops = {\n\t \n\t.setup_errata = mv88e6390_setup_errata,\n\t.irl_init_all = mv88e6390_g2_irl_init_all,\n\t.get_eeprom = mv88e6xxx_g2_get_eeprom8,\n\t.set_eeprom = mv88e6xxx_g2_set_eeprom8,\n\t.set_switch_mac = mv88e6xxx_g2_set_switch_mac,\n\t.phy_read = mv88e6xxx_g2_smi_phy_read_c22,\n\t.phy_write = mv88e6xxx_g2_smi_phy_write_c22,\n\t.phy_read_c45 = mv88e6xxx_g2_smi_phy_read_c45,\n\t.phy_write_c45 = mv88e6xxx_g2_smi_phy_write_c45,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6xxx_port_sync_link,\n\t.port_set_rgmii_delay = mv88e6390_port_set_rgmii_delay,\n\t.port_set_speed_duplex = mv88e6390x_port_set_speed_duplex,\n\t.port_max_speed_mode = mv88e6390x_port_max_speed_mode,\n\t.port_tag_remap = mv88e6390_port_tag_remap,\n\t.port_set_policy = mv88e6352_port_set_policy,\n\t.port_set_frame_mode = mv88e6351_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6352_port_set_ucast_flood,\n\t.port_set_mcast_flood = mv88e6352_port_set_mcast_flood,\n\t.port_set_ether_type = mv88e6351_port_set_ether_type,\n\t.port_set_jumbo_size = mv88e6165_port_set_jumbo_size,\n\t.port_pause_limit = mv88e6390_port_pause_limit,\n\t.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,\n\t.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,\n\t.port_get_cmode = mv88e6352_port_get_cmode,\n\t.port_set_cmode = mv88e6390x_port_set_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.stats_snapshot = mv88e6390_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6390_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6320_stats_get_sset_count,\n\t.stats_get_strings = mv88e6320_stats_get_strings,\n\t.stats_get_stats = mv88e6390_stats_get_stats,\n\t.set_cpu_port = mv88e6390_g1_set_cpu_port,\n\t.set_egress_port = mv88e6390_g1_set_egress_port,\n\t.watchdog_ops = &mv88e6390_watchdog_ops,\n\t.mgmt_rsvd2cpu = mv88e6390_g1_mgmt_rsvd2cpu,\n\t.pot_clear = mv88e6xxx_g2_pot_clear,\n\t.reset = mv88e6352_g1_reset,\n\t.rmu_disable = mv88e6390_g1_rmu_disable,\n\t.atu_get_hash = mv88e6165_g1_atu_get_hash,\n\t.atu_set_hash = mv88e6165_g1_atu_set_hash,\n\t.vtu_getnext = mv88e6390_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,\n\t.stu_getnext = mv88e6390_g1_stu_getnext,\n\t.stu_loadpurge = mv88e6390_g1_stu_loadpurge,\n\t.serdes_get_lane = mv88e6390x_serdes_get_lane,\n\t.serdes_irq_mapping = mv88e6390_serdes_irq_mapping,\n\t.serdes_get_strings = mv88e6390_serdes_get_strings,\n\t.serdes_get_stats = mv88e6390_serdes_get_stats,\n\t.serdes_get_regs_len = mv88e6390_serdes_get_regs_len,\n\t.serdes_get_regs = mv88e6390_serdes_get_regs,\n\t.gpio_ops = &mv88e6352_gpio_ops,\n\t.phylink_get_caps = mv88e6390x_phylink_get_caps,\n\t.pcs_ops = &mv88e6390_pcs_ops,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6191_ops = {\n\t \n\t.setup_errata = mv88e6390_setup_errata,\n\t.irl_init_all = mv88e6390_g2_irl_init_all,\n\t.get_eeprom = mv88e6xxx_g2_get_eeprom8,\n\t.set_eeprom = mv88e6xxx_g2_set_eeprom8,\n\t.set_switch_mac = mv88e6xxx_g2_set_switch_mac,\n\t.phy_read = mv88e6xxx_g2_smi_phy_read_c22,\n\t.phy_write = mv88e6xxx_g2_smi_phy_write_c22,\n\t.phy_read_c45 = mv88e6xxx_g2_smi_phy_read_c45,\n\t.phy_write_c45 = mv88e6xxx_g2_smi_phy_write_c45,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6xxx_port_sync_link,\n\t.port_set_rgmii_delay = mv88e6390_port_set_rgmii_delay,\n\t.port_set_speed_duplex = mv88e6390_port_set_speed_duplex,\n\t.port_max_speed_mode = mv88e6390_port_max_speed_mode,\n\t.port_tag_remap = mv88e6390_port_tag_remap,\n\t.port_set_frame_mode = mv88e6351_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6352_port_set_ucast_flood,\n\t.port_set_mcast_flood = mv88e6352_port_set_mcast_flood,\n\t.port_set_ether_type = mv88e6351_port_set_ether_type,\n\t.port_pause_limit = mv88e6390_port_pause_limit,\n\t.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,\n\t.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,\n\t.port_get_cmode = mv88e6352_port_get_cmode,\n\t.port_set_cmode = mv88e6390_port_set_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.stats_snapshot = mv88e6390_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6390_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6320_stats_get_sset_count,\n\t.stats_get_strings = mv88e6320_stats_get_strings,\n\t.stats_get_stats = mv88e6390_stats_get_stats,\n\t.set_cpu_port = mv88e6390_g1_set_cpu_port,\n\t.set_egress_port = mv88e6390_g1_set_egress_port,\n\t.watchdog_ops = &mv88e6390_watchdog_ops,\n\t.mgmt_rsvd2cpu = mv88e6390_g1_mgmt_rsvd2cpu,\n\t.pot_clear = mv88e6xxx_g2_pot_clear,\n\t.reset = mv88e6352_g1_reset,\n\t.rmu_disable = mv88e6390_g1_rmu_disable,\n\t.atu_get_hash = mv88e6165_g1_atu_get_hash,\n\t.atu_set_hash = mv88e6165_g1_atu_set_hash,\n\t.vtu_getnext = mv88e6390_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,\n\t.stu_getnext = mv88e6390_g1_stu_getnext,\n\t.stu_loadpurge = mv88e6390_g1_stu_loadpurge,\n\t.serdes_get_lane = mv88e6390_serdes_get_lane,\n\t.serdes_irq_mapping = mv88e6390_serdes_irq_mapping,\n\t.serdes_get_strings = mv88e6390_serdes_get_strings,\n\t.serdes_get_stats = mv88e6390_serdes_get_stats,\n\t.serdes_get_regs_len = mv88e6390_serdes_get_regs_len,\n\t.serdes_get_regs = mv88e6390_serdes_get_regs,\n\t.avb_ops = &mv88e6390_avb_ops,\n\t.ptp_ops = &mv88e6352_ptp_ops,\n\t.phylink_get_caps = mv88e6390_phylink_get_caps,\n\t.pcs_ops = &mv88e6390_pcs_ops,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6240_ops = {\n\t \n\t.ieee_pri_map = mv88e6085_g1_ieee_pri_map,\n\t.ip_pri_map = mv88e6085_g1_ip_pri_map,\n\t.irl_init_all = mv88e6352_g2_irl_init_all,\n\t.get_eeprom = mv88e6xxx_g2_get_eeprom16,\n\t.set_eeprom = mv88e6xxx_g2_set_eeprom16,\n\t.set_switch_mac = mv88e6xxx_g2_set_switch_mac,\n\t.phy_read = mv88e6xxx_g2_smi_phy_read_c22,\n\t.phy_write = mv88e6xxx_g2_smi_phy_write_c22,\n\t.phy_read_c45 = mv88e6xxx_g2_smi_phy_read_c45,\n\t.phy_write_c45 = mv88e6xxx_g2_smi_phy_write_c45,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6xxx_port_sync_link,\n\t.port_set_rgmii_delay = mv88e6352_port_set_rgmii_delay,\n\t.port_set_speed_duplex = mv88e6352_port_set_speed_duplex,\n\t.port_tag_remap = mv88e6095_port_tag_remap,\n\t.port_set_policy = mv88e6352_port_set_policy,\n\t.port_set_frame_mode = mv88e6351_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6352_port_set_ucast_flood,\n\t.port_set_mcast_flood = mv88e6352_port_set_mcast_flood,\n\t.port_set_ether_type = mv88e6351_port_set_ether_type,\n\t.port_set_jumbo_size = mv88e6165_port_set_jumbo_size,\n\t.port_egress_rate_limiting = mv88e6097_port_egress_rate_limiting,\n\t.port_pause_limit = mv88e6097_port_pause_limit,\n\t.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,\n\t.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,\n\t.port_get_cmode = mv88e6352_port_get_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.stats_snapshot = mv88e6320_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6095_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6095_stats_get_sset_count,\n\t.stats_get_strings = mv88e6095_stats_get_strings,\n\t.stats_get_stats = mv88e6095_stats_get_stats,\n\t.set_cpu_port = mv88e6095_g1_set_cpu_port,\n\t.set_egress_port = mv88e6095_g1_set_egress_port,\n\t.watchdog_ops = &mv88e6097_watchdog_ops,\n\t.mgmt_rsvd2cpu = mv88e6352_g2_mgmt_rsvd2cpu,\n\t.pot_clear = mv88e6xxx_g2_pot_clear,\n\t.reset = mv88e6352_g1_reset,\n\t.rmu_disable = mv88e6352_g1_rmu_disable,\n\t.atu_get_hash = mv88e6165_g1_atu_get_hash,\n\t.atu_set_hash = mv88e6165_g1_atu_set_hash,\n\t.vtu_getnext = mv88e6352_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,\n\t.stu_getnext = mv88e6352_g1_stu_getnext,\n\t.stu_loadpurge = mv88e6352_g1_stu_loadpurge,\n\t.serdes_irq_mapping = mv88e6352_serdes_irq_mapping,\n\t.serdes_get_regs_len = mv88e6352_serdes_get_regs_len,\n\t.serdes_get_regs = mv88e6352_serdes_get_regs,\n\t.serdes_set_tx_amplitude = mv88e6352_serdes_set_tx_amplitude,\n\t.gpio_ops = &mv88e6352_gpio_ops,\n\t.avb_ops = &mv88e6352_avb_ops,\n\t.ptp_ops = &mv88e6352_ptp_ops,\n\t.phylink_get_caps = mv88e6352_phylink_get_caps,\n\t.pcs_ops = &mv88e6352_pcs_ops,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6250_ops = {\n\t \n\t.ieee_pri_map = mv88e6250_g1_ieee_pri_map,\n\t.ip_pri_map = mv88e6085_g1_ip_pri_map,\n\t.irl_init_all = mv88e6352_g2_irl_init_all,\n\t.get_eeprom = mv88e6xxx_g2_get_eeprom16,\n\t.set_eeprom = mv88e6xxx_g2_set_eeprom16,\n\t.set_switch_mac = mv88e6xxx_g2_set_switch_mac,\n\t.phy_read = mv88e6xxx_g2_smi_phy_read_c22,\n\t.phy_write = mv88e6xxx_g2_smi_phy_write_c22,\n\t.phy_read_c45 = mv88e6xxx_g2_smi_phy_read_c45,\n\t.phy_write_c45 = mv88e6xxx_g2_smi_phy_write_c45,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6xxx_port_sync_link,\n\t.port_set_rgmii_delay = mv88e6352_port_set_rgmii_delay,\n\t.port_set_speed_duplex = mv88e6250_port_set_speed_duplex,\n\t.port_tag_remap = mv88e6095_port_tag_remap,\n\t.port_set_frame_mode = mv88e6351_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6352_port_set_ucast_flood,\n\t.port_set_mcast_flood = mv88e6352_port_set_mcast_flood,\n\t.port_set_ether_type = mv88e6351_port_set_ether_type,\n\t.port_egress_rate_limiting = mv88e6097_port_egress_rate_limiting,\n\t.port_pause_limit = mv88e6097_port_pause_limit,\n\t.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,\n\t.stats_snapshot = mv88e6320_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6095_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6250_stats_get_sset_count,\n\t.stats_get_strings = mv88e6250_stats_get_strings,\n\t.stats_get_stats = mv88e6250_stats_get_stats,\n\t.set_cpu_port = mv88e6095_g1_set_cpu_port,\n\t.set_egress_port = mv88e6095_g1_set_egress_port,\n\t.watchdog_ops = &mv88e6250_watchdog_ops,\n\t.mgmt_rsvd2cpu = mv88e6352_g2_mgmt_rsvd2cpu,\n\t.pot_clear = mv88e6xxx_g2_pot_clear,\n\t.reset = mv88e6250_g1_reset,\n\t.vtu_getnext = mv88e6185_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6185_g1_vtu_loadpurge,\n\t.avb_ops = &mv88e6352_avb_ops,\n\t.ptp_ops = &mv88e6250_ptp_ops,\n\t.phylink_get_caps = mv88e6250_phylink_get_caps,\n\t.set_max_frame_size = mv88e6185_g1_set_max_frame_size,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6290_ops = {\n\t \n\t.setup_errata = mv88e6390_setup_errata,\n\t.irl_init_all = mv88e6390_g2_irl_init_all,\n\t.get_eeprom = mv88e6xxx_g2_get_eeprom8,\n\t.set_eeprom = mv88e6xxx_g2_set_eeprom8,\n\t.set_switch_mac = mv88e6xxx_g2_set_switch_mac,\n\t.phy_read = mv88e6xxx_g2_smi_phy_read_c22,\n\t.phy_write = mv88e6xxx_g2_smi_phy_write_c22,\n\t.phy_read_c45 = mv88e6xxx_g2_smi_phy_read_c45,\n\t.phy_write_c45 = mv88e6xxx_g2_smi_phy_write_c45,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6xxx_port_sync_link,\n\t.port_set_rgmii_delay = mv88e6390_port_set_rgmii_delay,\n\t.port_set_speed_duplex = mv88e6390_port_set_speed_duplex,\n\t.port_max_speed_mode = mv88e6390_port_max_speed_mode,\n\t.port_tag_remap = mv88e6390_port_tag_remap,\n\t.port_set_policy = mv88e6352_port_set_policy,\n\t.port_set_frame_mode = mv88e6351_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6352_port_set_ucast_flood,\n\t.port_set_mcast_flood = mv88e6352_port_set_mcast_flood,\n\t.port_set_ether_type = mv88e6351_port_set_ether_type,\n\t.port_pause_limit = mv88e6390_port_pause_limit,\n\t.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,\n\t.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,\n\t.port_get_cmode = mv88e6352_port_get_cmode,\n\t.port_set_cmode = mv88e6390_port_set_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.stats_snapshot = mv88e6390_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6390_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6320_stats_get_sset_count,\n\t.stats_get_strings = mv88e6320_stats_get_strings,\n\t.stats_get_stats = mv88e6390_stats_get_stats,\n\t.set_cpu_port = mv88e6390_g1_set_cpu_port,\n\t.set_egress_port = mv88e6390_g1_set_egress_port,\n\t.watchdog_ops = &mv88e6390_watchdog_ops,\n\t.mgmt_rsvd2cpu = mv88e6390_g1_mgmt_rsvd2cpu,\n\t.pot_clear = mv88e6xxx_g2_pot_clear,\n\t.reset = mv88e6352_g1_reset,\n\t.rmu_disable = mv88e6390_g1_rmu_disable,\n\t.atu_get_hash = mv88e6165_g1_atu_get_hash,\n\t.atu_set_hash = mv88e6165_g1_atu_set_hash,\n\t.vtu_getnext = mv88e6390_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,\n\t.stu_getnext = mv88e6390_g1_stu_getnext,\n\t.stu_loadpurge = mv88e6390_g1_stu_loadpurge,\n\t.serdes_get_lane = mv88e6390_serdes_get_lane,\n\t.serdes_irq_mapping = mv88e6390_serdes_irq_mapping,\n\t.serdes_get_strings = mv88e6390_serdes_get_strings,\n\t.serdes_get_stats = mv88e6390_serdes_get_stats,\n\t.serdes_get_regs_len = mv88e6390_serdes_get_regs_len,\n\t.serdes_get_regs = mv88e6390_serdes_get_regs,\n\t.gpio_ops = &mv88e6352_gpio_ops,\n\t.avb_ops = &mv88e6390_avb_ops,\n\t.ptp_ops = &mv88e6390_ptp_ops,\n\t.phylink_get_caps = mv88e6390_phylink_get_caps,\n\t.pcs_ops = &mv88e6390_pcs_ops,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6320_ops = {\n\t \n\t.ieee_pri_map = mv88e6085_g1_ieee_pri_map,\n\t.ip_pri_map = mv88e6085_g1_ip_pri_map,\n\t.irl_init_all = mv88e6352_g2_irl_init_all,\n\t.get_eeprom = mv88e6xxx_g2_get_eeprom16,\n\t.set_eeprom = mv88e6xxx_g2_set_eeprom16,\n\t.set_switch_mac = mv88e6xxx_g2_set_switch_mac,\n\t.phy_read = mv88e6xxx_g2_smi_phy_read_c22,\n\t.phy_write = mv88e6xxx_g2_smi_phy_write_c22,\n\t.phy_read_c45 = mv88e6xxx_g2_smi_phy_read_c45,\n\t.phy_write_c45 = mv88e6xxx_g2_smi_phy_write_c45,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6xxx_port_sync_link,\n\t.port_set_rgmii_delay = mv88e6320_port_set_rgmii_delay,\n\t.port_set_speed_duplex = mv88e6185_port_set_speed_duplex,\n\t.port_tag_remap = mv88e6095_port_tag_remap,\n\t.port_set_frame_mode = mv88e6351_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6352_port_set_ucast_flood,\n\t.port_set_mcast_flood = mv88e6352_port_set_mcast_flood,\n\t.port_set_ether_type = mv88e6351_port_set_ether_type,\n\t.port_set_jumbo_size = mv88e6165_port_set_jumbo_size,\n\t.port_egress_rate_limiting = mv88e6097_port_egress_rate_limiting,\n\t.port_pause_limit = mv88e6097_port_pause_limit,\n\t.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,\n\t.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,\n\t.port_get_cmode = mv88e6352_port_get_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.stats_snapshot = mv88e6320_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6095_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6320_stats_get_sset_count,\n\t.stats_get_strings = mv88e6320_stats_get_strings,\n\t.stats_get_stats = mv88e6320_stats_get_stats,\n\t.set_cpu_port = mv88e6095_g1_set_cpu_port,\n\t.set_egress_port = mv88e6095_g1_set_egress_port,\n\t.watchdog_ops = &mv88e6390_watchdog_ops,\n\t.mgmt_rsvd2cpu = mv88e6352_g2_mgmt_rsvd2cpu,\n\t.pot_clear = mv88e6xxx_g2_pot_clear,\n\t.reset = mv88e6352_g1_reset,\n\t.vtu_getnext = mv88e6185_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6185_g1_vtu_loadpurge,\n\t.gpio_ops = &mv88e6352_gpio_ops,\n\t.avb_ops = &mv88e6352_avb_ops,\n\t.ptp_ops = &mv88e6352_ptp_ops,\n\t.phylink_get_caps = mv88e6185_phylink_get_caps,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6321_ops = {\n\t \n\t.ieee_pri_map = mv88e6085_g1_ieee_pri_map,\n\t.ip_pri_map = mv88e6085_g1_ip_pri_map,\n\t.irl_init_all = mv88e6352_g2_irl_init_all,\n\t.get_eeprom = mv88e6xxx_g2_get_eeprom16,\n\t.set_eeprom = mv88e6xxx_g2_set_eeprom16,\n\t.set_switch_mac = mv88e6xxx_g2_set_switch_mac,\n\t.phy_read = mv88e6xxx_g2_smi_phy_read_c22,\n\t.phy_write = mv88e6xxx_g2_smi_phy_write_c22,\n\t.phy_read_c45 = mv88e6xxx_g2_smi_phy_read_c45,\n\t.phy_write_c45 = mv88e6xxx_g2_smi_phy_write_c45,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6xxx_port_sync_link,\n\t.port_set_rgmii_delay = mv88e6320_port_set_rgmii_delay,\n\t.port_set_speed_duplex = mv88e6185_port_set_speed_duplex,\n\t.port_tag_remap = mv88e6095_port_tag_remap,\n\t.port_set_frame_mode = mv88e6351_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6352_port_set_ucast_flood,\n\t.port_set_mcast_flood = mv88e6352_port_set_mcast_flood,\n\t.port_set_ether_type = mv88e6351_port_set_ether_type,\n\t.port_set_jumbo_size = mv88e6165_port_set_jumbo_size,\n\t.port_egress_rate_limiting = mv88e6097_port_egress_rate_limiting,\n\t.port_pause_limit = mv88e6097_port_pause_limit,\n\t.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,\n\t.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,\n\t.port_get_cmode = mv88e6352_port_get_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.stats_snapshot = mv88e6320_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6095_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6320_stats_get_sset_count,\n\t.stats_get_strings = mv88e6320_stats_get_strings,\n\t.stats_get_stats = mv88e6320_stats_get_stats,\n\t.set_cpu_port = mv88e6095_g1_set_cpu_port,\n\t.set_egress_port = mv88e6095_g1_set_egress_port,\n\t.watchdog_ops = &mv88e6390_watchdog_ops,\n\t.mgmt_rsvd2cpu = mv88e6352_g2_mgmt_rsvd2cpu,\n\t.reset = mv88e6352_g1_reset,\n\t.vtu_getnext = mv88e6185_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6185_g1_vtu_loadpurge,\n\t.gpio_ops = &mv88e6352_gpio_ops,\n\t.avb_ops = &mv88e6352_avb_ops,\n\t.ptp_ops = &mv88e6352_ptp_ops,\n\t.phylink_get_caps = mv88e6185_phylink_get_caps,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6341_ops = {\n\t \n\t.ieee_pri_map = mv88e6085_g1_ieee_pri_map,\n\t.ip_pri_map = mv88e6085_g1_ip_pri_map,\n\t.irl_init_all = mv88e6352_g2_irl_init_all,\n\t.get_eeprom = mv88e6xxx_g2_get_eeprom8,\n\t.set_eeprom = mv88e6xxx_g2_set_eeprom8,\n\t.set_switch_mac = mv88e6xxx_g2_set_switch_mac,\n\t.phy_read = mv88e6xxx_g2_smi_phy_read_c22,\n\t.phy_write = mv88e6xxx_g2_smi_phy_write_c22,\n\t.phy_read_c45 = mv88e6xxx_g2_smi_phy_read_c45,\n\t.phy_write_c45 = mv88e6xxx_g2_smi_phy_write_c45,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6xxx_port_sync_link,\n\t.port_set_rgmii_delay = mv88e6390_port_set_rgmii_delay,\n\t.port_set_speed_duplex = mv88e6341_port_set_speed_duplex,\n\t.port_max_speed_mode = mv88e6341_port_max_speed_mode,\n\t.port_tag_remap = mv88e6095_port_tag_remap,\n\t.port_set_policy = mv88e6352_port_set_policy,\n\t.port_set_frame_mode = mv88e6351_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6352_port_set_ucast_flood,\n\t.port_set_mcast_flood = mv88e6352_port_set_mcast_flood,\n\t.port_set_ether_type = mv88e6351_port_set_ether_type,\n\t.port_set_jumbo_size = mv88e6165_port_set_jumbo_size,\n\t.port_egress_rate_limiting = mv88e6097_port_egress_rate_limiting,\n\t.port_pause_limit = mv88e6097_port_pause_limit,\n\t.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,\n\t.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,\n\t.port_get_cmode = mv88e6352_port_get_cmode,\n\t.port_set_cmode = mv88e6341_port_set_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.stats_snapshot = mv88e6390_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6390_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6320_stats_get_sset_count,\n\t.stats_get_strings = mv88e6320_stats_get_strings,\n\t.stats_get_stats = mv88e6390_stats_get_stats,\n\t.set_cpu_port = mv88e6390_g1_set_cpu_port,\n\t.set_egress_port = mv88e6390_g1_set_egress_port,\n\t.watchdog_ops = &mv88e6390_watchdog_ops,\n\t.mgmt_rsvd2cpu =  mv88e6390_g1_mgmt_rsvd2cpu,\n\t.pot_clear = mv88e6xxx_g2_pot_clear,\n\t.reset = mv88e6352_g1_reset,\n\t.rmu_disable = mv88e6390_g1_rmu_disable,\n\t.atu_get_hash = mv88e6165_g1_atu_get_hash,\n\t.atu_set_hash = mv88e6165_g1_atu_set_hash,\n\t.vtu_getnext = mv88e6352_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,\n\t.stu_getnext = mv88e6352_g1_stu_getnext,\n\t.stu_loadpurge = mv88e6352_g1_stu_loadpurge,\n\t.serdes_get_lane = mv88e6341_serdes_get_lane,\n\t.serdes_irq_mapping = mv88e6390_serdes_irq_mapping,\n\t.gpio_ops = &mv88e6352_gpio_ops,\n\t.avb_ops = &mv88e6390_avb_ops,\n\t.ptp_ops = &mv88e6352_ptp_ops,\n\t.serdes_get_sset_count = mv88e6390_serdes_get_sset_count,\n\t.serdes_get_strings = mv88e6390_serdes_get_strings,\n\t.serdes_get_stats = mv88e6390_serdes_get_stats,\n\t.serdes_get_regs_len = mv88e6390_serdes_get_regs_len,\n\t.serdes_get_regs = mv88e6390_serdes_get_regs,\n\t.phylink_get_caps = mv88e6341_phylink_get_caps,\n\t.pcs_ops = &mv88e6390_pcs_ops,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6350_ops = {\n\t \n\t.ieee_pri_map = mv88e6085_g1_ieee_pri_map,\n\t.ip_pri_map = mv88e6085_g1_ip_pri_map,\n\t.irl_init_all = mv88e6352_g2_irl_init_all,\n\t.set_switch_mac = mv88e6xxx_g2_set_switch_mac,\n\t.phy_read = mv88e6xxx_g2_smi_phy_read_c22,\n\t.phy_write = mv88e6xxx_g2_smi_phy_write_c22,\n\t.phy_read_c45 = mv88e6xxx_g2_smi_phy_read_c45,\n\t.phy_write_c45 = mv88e6xxx_g2_smi_phy_write_c45,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6xxx_port_sync_link,\n\t.port_set_rgmii_delay = mv88e6352_port_set_rgmii_delay,\n\t.port_set_speed_duplex = mv88e6185_port_set_speed_duplex,\n\t.port_tag_remap = mv88e6095_port_tag_remap,\n\t.port_set_frame_mode = mv88e6351_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6352_port_set_ucast_flood,\n\t.port_set_mcast_flood = mv88e6352_port_set_mcast_flood,\n\t.port_set_ether_type = mv88e6351_port_set_ether_type,\n\t.port_set_jumbo_size = mv88e6165_port_set_jumbo_size,\n\t.port_egress_rate_limiting = mv88e6097_port_egress_rate_limiting,\n\t.port_pause_limit = mv88e6097_port_pause_limit,\n\t.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,\n\t.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,\n\t.port_get_cmode = mv88e6352_port_get_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.stats_snapshot = mv88e6320_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6095_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6095_stats_get_sset_count,\n\t.stats_get_strings = mv88e6095_stats_get_strings,\n\t.stats_get_stats = mv88e6095_stats_get_stats,\n\t.set_cpu_port = mv88e6095_g1_set_cpu_port,\n\t.set_egress_port = mv88e6095_g1_set_egress_port,\n\t.watchdog_ops = &mv88e6097_watchdog_ops,\n\t.mgmt_rsvd2cpu = mv88e6352_g2_mgmt_rsvd2cpu,\n\t.pot_clear = mv88e6xxx_g2_pot_clear,\n\t.reset = mv88e6352_g1_reset,\n\t.atu_get_hash = mv88e6165_g1_atu_get_hash,\n\t.atu_set_hash = mv88e6165_g1_atu_set_hash,\n\t.vtu_getnext = mv88e6352_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,\n\t.stu_getnext = mv88e6352_g1_stu_getnext,\n\t.stu_loadpurge = mv88e6352_g1_stu_loadpurge,\n\t.phylink_get_caps = mv88e6351_phylink_get_caps,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6351_ops = {\n\t \n\t.ieee_pri_map = mv88e6085_g1_ieee_pri_map,\n\t.ip_pri_map = mv88e6085_g1_ip_pri_map,\n\t.irl_init_all = mv88e6352_g2_irl_init_all,\n\t.set_switch_mac = mv88e6xxx_g2_set_switch_mac,\n\t.phy_read = mv88e6xxx_g2_smi_phy_read_c22,\n\t.phy_write = mv88e6xxx_g2_smi_phy_write_c22,\n\t.phy_read_c45 = mv88e6xxx_g2_smi_phy_read_c45,\n\t.phy_write_c45 = mv88e6xxx_g2_smi_phy_write_c45,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6xxx_port_sync_link,\n\t.port_set_rgmii_delay = mv88e6352_port_set_rgmii_delay,\n\t.port_set_speed_duplex = mv88e6185_port_set_speed_duplex,\n\t.port_tag_remap = mv88e6095_port_tag_remap,\n\t.port_set_frame_mode = mv88e6351_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6352_port_set_ucast_flood,\n\t.port_set_mcast_flood = mv88e6352_port_set_mcast_flood,\n\t.port_set_ether_type = mv88e6351_port_set_ether_type,\n\t.port_set_jumbo_size = mv88e6165_port_set_jumbo_size,\n\t.port_egress_rate_limiting = mv88e6097_port_egress_rate_limiting,\n\t.port_pause_limit = mv88e6097_port_pause_limit,\n\t.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,\n\t.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,\n\t.port_get_cmode = mv88e6352_port_get_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.stats_snapshot = mv88e6320_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6095_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6095_stats_get_sset_count,\n\t.stats_get_strings = mv88e6095_stats_get_strings,\n\t.stats_get_stats = mv88e6095_stats_get_stats,\n\t.set_cpu_port = mv88e6095_g1_set_cpu_port,\n\t.set_egress_port = mv88e6095_g1_set_egress_port,\n\t.watchdog_ops = &mv88e6097_watchdog_ops,\n\t.mgmt_rsvd2cpu = mv88e6352_g2_mgmt_rsvd2cpu,\n\t.pot_clear = mv88e6xxx_g2_pot_clear,\n\t.reset = mv88e6352_g1_reset,\n\t.atu_get_hash = mv88e6165_g1_atu_get_hash,\n\t.atu_set_hash = mv88e6165_g1_atu_set_hash,\n\t.vtu_getnext = mv88e6352_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,\n\t.stu_getnext = mv88e6352_g1_stu_getnext,\n\t.stu_loadpurge = mv88e6352_g1_stu_loadpurge,\n\t.avb_ops = &mv88e6352_avb_ops,\n\t.ptp_ops = &mv88e6352_ptp_ops,\n\t.phylink_get_caps = mv88e6351_phylink_get_caps,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6352_ops = {\n\t \n\t.ieee_pri_map = mv88e6085_g1_ieee_pri_map,\n\t.ip_pri_map = mv88e6085_g1_ip_pri_map,\n\t.irl_init_all = mv88e6352_g2_irl_init_all,\n\t.get_eeprom = mv88e6xxx_g2_get_eeprom16,\n\t.set_eeprom = mv88e6xxx_g2_set_eeprom16,\n\t.set_switch_mac = mv88e6xxx_g2_set_switch_mac,\n\t.phy_read = mv88e6xxx_g2_smi_phy_read_c22,\n\t.phy_write = mv88e6xxx_g2_smi_phy_write_c22,\n\t.phy_read_c45 = mv88e6xxx_g2_smi_phy_read_c45,\n\t.phy_write_c45 = mv88e6xxx_g2_smi_phy_write_c45,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6xxx_port_sync_link,\n\t.port_set_rgmii_delay = mv88e6352_port_set_rgmii_delay,\n\t.port_set_speed_duplex = mv88e6352_port_set_speed_duplex,\n\t.port_tag_remap = mv88e6095_port_tag_remap,\n\t.port_set_policy = mv88e6352_port_set_policy,\n\t.port_set_frame_mode = mv88e6351_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6352_port_set_ucast_flood,\n\t.port_set_mcast_flood = mv88e6352_port_set_mcast_flood,\n\t.port_set_ether_type = mv88e6351_port_set_ether_type,\n\t.port_set_jumbo_size = mv88e6165_port_set_jumbo_size,\n\t.port_egress_rate_limiting = mv88e6097_port_egress_rate_limiting,\n\t.port_pause_limit = mv88e6097_port_pause_limit,\n\t.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,\n\t.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,\n\t.port_get_cmode = mv88e6352_port_get_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.stats_snapshot = mv88e6320_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6095_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6095_stats_get_sset_count,\n\t.stats_get_strings = mv88e6095_stats_get_strings,\n\t.stats_get_stats = mv88e6095_stats_get_stats,\n\t.set_cpu_port = mv88e6095_g1_set_cpu_port,\n\t.set_egress_port = mv88e6095_g1_set_egress_port,\n\t.watchdog_ops = &mv88e6097_watchdog_ops,\n\t.mgmt_rsvd2cpu = mv88e6352_g2_mgmt_rsvd2cpu,\n\t.pot_clear = mv88e6xxx_g2_pot_clear,\n\t.reset = mv88e6352_g1_reset,\n\t.rmu_disable = mv88e6352_g1_rmu_disable,\n\t.atu_get_hash = mv88e6165_g1_atu_get_hash,\n\t.atu_set_hash = mv88e6165_g1_atu_set_hash,\n\t.vtu_getnext = mv88e6352_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6352_g1_vtu_loadpurge,\n\t.stu_getnext = mv88e6352_g1_stu_getnext,\n\t.stu_loadpurge = mv88e6352_g1_stu_loadpurge,\n\t.serdes_irq_mapping = mv88e6352_serdes_irq_mapping,\n\t.gpio_ops = &mv88e6352_gpio_ops,\n\t.avb_ops = &mv88e6352_avb_ops,\n\t.ptp_ops = &mv88e6352_ptp_ops,\n\t.serdes_get_sset_count = mv88e6352_serdes_get_sset_count,\n\t.serdes_get_strings = mv88e6352_serdes_get_strings,\n\t.serdes_get_stats = mv88e6352_serdes_get_stats,\n\t.serdes_get_regs_len = mv88e6352_serdes_get_regs_len,\n\t.serdes_get_regs = mv88e6352_serdes_get_regs,\n\t.serdes_set_tx_amplitude = mv88e6352_serdes_set_tx_amplitude,\n\t.phylink_get_caps = mv88e6352_phylink_get_caps,\n\t.pcs_ops = &mv88e6352_pcs_ops,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6390_ops = {\n\t \n\t.setup_errata = mv88e6390_setup_errata,\n\t.irl_init_all = mv88e6390_g2_irl_init_all,\n\t.get_eeprom = mv88e6xxx_g2_get_eeprom8,\n\t.set_eeprom = mv88e6xxx_g2_set_eeprom8,\n\t.set_switch_mac = mv88e6xxx_g2_set_switch_mac,\n\t.phy_read = mv88e6xxx_g2_smi_phy_read_c22,\n\t.phy_write = mv88e6xxx_g2_smi_phy_write_c22,\n\t.phy_read_c45 = mv88e6xxx_g2_smi_phy_read_c45,\n\t.phy_write_c45 = mv88e6xxx_g2_smi_phy_write_c45,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6xxx_port_sync_link,\n\t.port_set_rgmii_delay = mv88e6390_port_set_rgmii_delay,\n\t.port_set_speed_duplex = mv88e6390_port_set_speed_duplex,\n\t.port_max_speed_mode = mv88e6390_port_max_speed_mode,\n\t.port_tag_remap = mv88e6390_port_tag_remap,\n\t.port_set_policy = mv88e6352_port_set_policy,\n\t.port_set_frame_mode = mv88e6351_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6352_port_set_ucast_flood,\n\t.port_set_mcast_flood = mv88e6352_port_set_mcast_flood,\n\t.port_set_ether_type = mv88e6351_port_set_ether_type,\n\t.port_set_jumbo_size = mv88e6165_port_set_jumbo_size,\n\t.port_egress_rate_limiting = mv88e6097_port_egress_rate_limiting,\n\t.port_pause_limit = mv88e6390_port_pause_limit,\n\t.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,\n\t.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,\n\t.port_get_cmode = mv88e6352_port_get_cmode,\n\t.port_set_cmode = mv88e6390_port_set_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.stats_snapshot = mv88e6390_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6390_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6320_stats_get_sset_count,\n\t.stats_get_strings = mv88e6320_stats_get_strings,\n\t.stats_get_stats = mv88e6390_stats_get_stats,\n\t.set_cpu_port = mv88e6390_g1_set_cpu_port,\n\t.set_egress_port = mv88e6390_g1_set_egress_port,\n\t.watchdog_ops = &mv88e6390_watchdog_ops,\n\t.mgmt_rsvd2cpu = mv88e6390_g1_mgmt_rsvd2cpu,\n\t.pot_clear = mv88e6xxx_g2_pot_clear,\n\t.reset = mv88e6352_g1_reset,\n\t.rmu_disable = mv88e6390_g1_rmu_disable,\n\t.atu_get_hash = mv88e6165_g1_atu_get_hash,\n\t.atu_set_hash = mv88e6165_g1_atu_set_hash,\n\t.vtu_getnext = mv88e6390_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,\n\t.stu_getnext = mv88e6390_g1_stu_getnext,\n\t.stu_loadpurge = mv88e6390_g1_stu_loadpurge,\n\t.serdes_get_lane = mv88e6390_serdes_get_lane,\n\t.serdes_irq_mapping = mv88e6390_serdes_irq_mapping,\n\t.gpio_ops = &mv88e6352_gpio_ops,\n\t.avb_ops = &mv88e6390_avb_ops,\n\t.ptp_ops = &mv88e6390_ptp_ops,\n\t.serdes_get_sset_count = mv88e6390_serdes_get_sset_count,\n\t.serdes_get_strings = mv88e6390_serdes_get_strings,\n\t.serdes_get_stats = mv88e6390_serdes_get_stats,\n\t.serdes_get_regs_len = mv88e6390_serdes_get_regs_len,\n\t.serdes_get_regs = mv88e6390_serdes_get_regs,\n\t.phylink_get_caps = mv88e6390_phylink_get_caps,\n\t.pcs_ops = &mv88e6390_pcs_ops,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6390x_ops = {\n\t \n\t.setup_errata = mv88e6390_setup_errata,\n\t.irl_init_all = mv88e6390_g2_irl_init_all,\n\t.get_eeprom = mv88e6xxx_g2_get_eeprom8,\n\t.set_eeprom = mv88e6xxx_g2_set_eeprom8,\n\t.set_switch_mac = mv88e6xxx_g2_set_switch_mac,\n\t.phy_read = mv88e6xxx_g2_smi_phy_read_c22,\n\t.phy_write = mv88e6xxx_g2_smi_phy_write_c22,\n\t.phy_read_c45 = mv88e6xxx_g2_smi_phy_read_c45,\n\t.phy_write_c45 = mv88e6xxx_g2_smi_phy_write_c45,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6xxx_port_sync_link,\n\t.port_set_rgmii_delay = mv88e6390_port_set_rgmii_delay,\n\t.port_set_speed_duplex = mv88e6390x_port_set_speed_duplex,\n\t.port_max_speed_mode = mv88e6390x_port_max_speed_mode,\n\t.port_tag_remap = mv88e6390_port_tag_remap,\n\t.port_set_policy = mv88e6352_port_set_policy,\n\t.port_set_frame_mode = mv88e6351_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6352_port_set_ucast_flood,\n\t.port_set_mcast_flood = mv88e6352_port_set_mcast_flood,\n\t.port_set_ether_type = mv88e6351_port_set_ether_type,\n\t.port_set_jumbo_size = mv88e6165_port_set_jumbo_size,\n\t.port_egress_rate_limiting = mv88e6097_port_egress_rate_limiting,\n\t.port_pause_limit = mv88e6390_port_pause_limit,\n\t.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,\n\t.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,\n\t.port_get_cmode = mv88e6352_port_get_cmode,\n\t.port_set_cmode = mv88e6390x_port_set_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.stats_snapshot = mv88e6390_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6390_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6320_stats_get_sset_count,\n\t.stats_get_strings = mv88e6320_stats_get_strings,\n\t.stats_get_stats = mv88e6390_stats_get_stats,\n\t.set_cpu_port = mv88e6390_g1_set_cpu_port,\n\t.set_egress_port = mv88e6390_g1_set_egress_port,\n\t.watchdog_ops = &mv88e6390_watchdog_ops,\n\t.mgmt_rsvd2cpu = mv88e6390_g1_mgmt_rsvd2cpu,\n\t.pot_clear = mv88e6xxx_g2_pot_clear,\n\t.reset = mv88e6352_g1_reset,\n\t.rmu_disable = mv88e6390_g1_rmu_disable,\n\t.atu_get_hash = mv88e6165_g1_atu_get_hash,\n\t.atu_set_hash = mv88e6165_g1_atu_set_hash,\n\t.vtu_getnext = mv88e6390_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,\n\t.stu_getnext = mv88e6390_g1_stu_getnext,\n\t.stu_loadpurge = mv88e6390_g1_stu_loadpurge,\n\t.serdes_get_lane = mv88e6390x_serdes_get_lane,\n\t.serdes_irq_mapping = mv88e6390_serdes_irq_mapping,\n\t.serdes_get_sset_count = mv88e6390_serdes_get_sset_count,\n\t.serdes_get_strings = mv88e6390_serdes_get_strings,\n\t.serdes_get_stats = mv88e6390_serdes_get_stats,\n\t.serdes_get_regs_len = mv88e6390_serdes_get_regs_len,\n\t.serdes_get_regs = mv88e6390_serdes_get_regs,\n\t.gpio_ops = &mv88e6352_gpio_ops,\n\t.avb_ops = &mv88e6390_avb_ops,\n\t.ptp_ops = &mv88e6390_ptp_ops,\n\t.phylink_get_caps = mv88e6390x_phylink_get_caps,\n\t.pcs_ops = &mv88e6390_pcs_ops,\n};\n\nstatic const struct mv88e6xxx_ops mv88e6393x_ops = {\n\t \n\t.irl_init_all = mv88e6390_g2_irl_init_all,\n\t.get_eeprom = mv88e6xxx_g2_get_eeprom8,\n\t.set_eeprom = mv88e6xxx_g2_set_eeprom8,\n\t.set_switch_mac = mv88e6xxx_g2_set_switch_mac,\n\t.phy_read = mv88e6xxx_g2_smi_phy_read_c22,\n\t.phy_write = mv88e6xxx_g2_smi_phy_write_c22,\n\t.phy_read_c45 = mv88e6xxx_g2_smi_phy_read_c45,\n\t.phy_write_c45 = mv88e6xxx_g2_smi_phy_write_c45,\n\t.port_set_link = mv88e6xxx_port_set_link,\n\t.port_sync_link = mv88e6xxx_port_sync_link,\n\t.port_set_rgmii_delay = mv88e6390_port_set_rgmii_delay,\n\t.port_set_speed_duplex = mv88e6393x_port_set_speed_duplex,\n\t.port_max_speed_mode = mv88e6393x_port_max_speed_mode,\n\t.port_tag_remap = mv88e6390_port_tag_remap,\n\t.port_set_policy = mv88e6393x_port_set_policy,\n\t.port_set_frame_mode = mv88e6351_port_set_frame_mode,\n\t.port_set_ucast_flood = mv88e6352_port_set_ucast_flood,\n\t.port_set_mcast_flood = mv88e6352_port_set_mcast_flood,\n\t.port_set_ether_type = mv88e6393x_port_set_ether_type,\n\t.port_set_jumbo_size = mv88e6165_port_set_jumbo_size,\n\t.port_egress_rate_limiting = mv88e6097_port_egress_rate_limiting,\n\t.port_pause_limit = mv88e6390_port_pause_limit,\n\t.port_disable_learn_limit = mv88e6xxx_port_disable_learn_limit,\n\t.port_disable_pri_override = mv88e6xxx_port_disable_pri_override,\n\t.port_get_cmode = mv88e6352_port_get_cmode,\n\t.port_set_cmode = mv88e6393x_port_set_cmode,\n\t.port_setup_message_port = mv88e6xxx_setup_message_port,\n\t.port_set_upstream_port = mv88e6393x_port_set_upstream_port,\n\t.stats_snapshot = mv88e6390_g1_stats_snapshot,\n\t.stats_set_histogram = mv88e6390_g1_stats_set_histogram,\n\t.stats_get_sset_count = mv88e6320_stats_get_sset_count,\n\t.stats_get_strings = mv88e6320_stats_get_strings,\n\t.stats_get_stats = mv88e6390_stats_get_stats,\n\t \n\t.set_egress_port = mv88e6393x_set_egress_port,\n\t.watchdog_ops = &mv88e6393x_watchdog_ops,\n\t.mgmt_rsvd2cpu = mv88e6393x_port_mgmt_rsvd2cpu,\n\t.pot_clear = mv88e6xxx_g2_pot_clear,\n\t.reset = mv88e6352_g1_reset,\n\t.rmu_disable = mv88e6390_g1_rmu_disable,\n\t.atu_get_hash = mv88e6165_g1_atu_get_hash,\n\t.atu_set_hash = mv88e6165_g1_atu_set_hash,\n\t.vtu_getnext = mv88e6390_g1_vtu_getnext,\n\t.vtu_loadpurge = mv88e6390_g1_vtu_loadpurge,\n\t.stu_getnext = mv88e6390_g1_stu_getnext,\n\t.stu_loadpurge = mv88e6390_g1_stu_loadpurge,\n\t.serdes_get_lane = mv88e6393x_serdes_get_lane,\n\t.serdes_irq_mapping = mv88e6390_serdes_irq_mapping,\n\t \n\t.gpio_ops = &mv88e6352_gpio_ops,\n\t.avb_ops = &mv88e6390_avb_ops,\n\t.ptp_ops = &mv88e6352_ptp_ops,\n\t.phylink_get_caps = mv88e6393x_phylink_get_caps,\n\t.pcs_ops = &mv88e6393x_pcs_ops,\n};\n\nstatic const struct mv88e6xxx_info mv88e6xxx_table[] = {\n\t[MV88E6020] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6020,\n\t\t.family = MV88E6XXX_FAMILY_6250,\n\t\t.name = \"Marvell 88E6020\",\n\t\t.num_databases = 64,\n\t\t.num_ports = 4,\n\t\t.num_internal_phys = 2,\n\t\t.max_vid = 4095,\n\t\t.port_base_addr = 0x8,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0xf,\n\t\t.global2_addr = 0x7,\n\t\t.age_time_coeff = 15000,\n\t\t.g1_irqs = 9,\n\t\t.g2_irqs = 5,\n\t\t.atu_move_port_mask = 0xf,\n\t\t.dual_chip = true,\n\t\t.ops = &mv88e6250_ops,\n\t},\n\n\t[MV88E6071] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6071,\n\t\t.family = MV88E6XXX_FAMILY_6250,\n\t\t.name = \"Marvell 88E6071\",\n\t\t.num_databases = 64,\n\t\t.num_ports = 7,\n\t\t.num_internal_phys = 5,\n\t\t.max_vid = 4095,\n\t\t.port_base_addr = 0x08,\n\t\t.phy_base_addr = 0x00,\n\t\t.global1_addr = 0x0f,\n\t\t.global2_addr = 0x07,\n\t\t.age_time_coeff = 15000,\n\t\t.g1_irqs = 9,\n\t\t.g2_irqs = 5,\n\t\t.atu_move_port_mask = 0xf,\n\t\t.dual_chip = true,\n\t\t.ops = &mv88e6250_ops,\n\t},\n\n\t[MV88E6085] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6085,\n\t\t.family = MV88E6XXX_FAMILY_6097,\n\t\t.name = \"Marvell 88E6085\",\n\t\t.num_databases = 4096,\n\t\t.num_macs = 8192,\n\t\t.num_ports = 10,\n\t\t.num_internal_phys = 5,\n\t\t.max_vid = 4095,\n\t\t.max_sid = 63,\n\t\t.port_base_addr = 0x10,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 15000,\n\t\t.g1_irqs = 8,\n\t\t.g2_irqs = 10,\n\t\t.atu_move_port_mask = 0xf,\n\t\t.pvt = true,\n\t\t.multi_chip = true,\n\t\t.ops = &mv88e6085_ops,\n\t},\n\n\t[MV88E6095] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6095,\n\t\t.family = MV88E6XXX_FAMILY_6095,\n\t\t.name = \"Marvell 88E6095/88E6095F\",\n\t\t.num_databases = 256,\n\t\t.num_macs = 8192,\n\t\t.num_ports = 11,\n\t\t.num_internal_phys = 0,\n\t\t.max_vid = 4095,\n\t\t.port_base_addr = 0x10,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 15000,\n\t\t.g1_irqs = 8,\n\t\t.atu_move_port_mask = 0xf,\n\t\t.multi_chip = true,\n\t\t.ops = &mv88e6095_ops,\n\t},\n\n\t[MV88E6097] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6097,\n\t\t.family = MV88E6XXX_FAMILY_6097,\n\t\t.name = \"Marvell 88E6097/88E6097F\",\n\t\t.num_databases = 4096,\n\t\t.num_macs = 8192,\n\t\t.num_ports = 11,\n\t\t.num_internal_phys = 8,\n\t\t.max_vid = 4095,\n\t\t.max_sid = 63,\n\t\t.port_base_addr = 0x10,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 15000,\n\t\t.g1_irqs = 8,\n\t\t.g2_irqs = 10,\n\t\t.atu_move_port_mask = 0xf,\n\t\t.pvt = true,\n\t\t.multi_chip = true,\n\t\t.edsa_support = MV88E6XXX_EDSA_SUPPORTED,\n\t\t.ops = &mv88e6097_ops,\n\t},\n\n\t[MV88E6123] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6123,\n\t\t.family = MV88E6XXX_FAMILY_6165,\n\t\t.name = \"Marvell 88E6123\",\n\t\t.num_databases = 4096,\n\t\t.num_macs = 1024,\n\t\t.num_ports = 3,\n\t\t.num_internal_phys = 5,\n\t\t.max_vid = 4095,\n\t\t.max_sid = 63,\n\t\t.port_base_addr = 0x10,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 15000,\n\t\t.g1_irqs = 9,\n\t\t.g2_irqs = 10,\n\t\t.atu_move_port_mask = 0xf,\n\t\t.pvt = true,\n\t\t.multi_chip = true,\n\t\t.edsa_support = MV88E6XXX_EDSA_SUPPORTED,\n\t\t.ops = &mv88e6123_ops,\n\t},\n\n\t[MV88E6131] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6131,\n\t\t.family = MV88E6XXX_FAMILY_6185,\n\t\t.name = \"Marvell 88E6131\",\n\t\t.num_databases = 256,\n\t\t.num_macs = 8192,\n\t\t.num_ports = 8,\n\t\t.num_internal_phys = 0,\n\t\t.max_vid = 4095,\n\t\t.port_base_addr = 0x10,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 15000,\n\t\t.g1_irqs = 9,\n\t\t.atu_move_port_mask = 0xf,\n\t\t.multi_chip = true,\n\t\t.ops = &mv88e6131_ops,\n\t},\n\n\t[MV88E6141] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6141,\n\t\t.family = MV88E6XXX_FAMILY_6341,\n\t\t.name = \"Marvell 88E6141\",\n\t\t.num_databases = 4096,\n\t\t.num_macs = 2048,\n\t\t.num_ports = 6,\n\t\t.num_internal_phys = 5,\n\t\t.num_gpio = 11,\n\t\t.max_vid = 4095,\n\t\t.max_sid = 63,\n\t\t.port_base_addr = 0x10,\n\t\t.phy_base_addr = 0x10,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 3750,\n\t\t.atu_move_port_mask = 0x1f,\n\t\t.g1_irqs = 9,\n\t\t.g2_irqs = 10,\n\t\t.pvt = true,\n\t\t.multi_chip = true,\n\t\t.edsa_support = MV88E6XXX_EDSA_SUPPORTED,\n\t\t.ops = &mv88e6141_ops,\n\t},\n\n\t[MV88E6161] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6161,\n\t\t.family = MV88E6XXX_FAMILY_6165,\n\t\t.name = \"Marvell 88E6161\",\n\t\t.num_databases = 4096,\n\t\t.num_macs = 1024,\n\t\t.num_ports = 6,\n\t\t.num_internal_phys = 5,\n\t\t.max_vid = 4095,\n\t\t.max_sid = 63,\n\t\t.port_base_addr = 0x10,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 15000,\n\t\t.g1_irqs = 9,\n\t\t.g2_irqs = 10,\n\t\t.atu_move_port_mask = 0xf,\n\t\t.pvt = true,\n\t\t.multi_chip = true,\n\t\t.edsa_support = MV88E6XXX_EDSA_SUPPORTED,\n\t\t.ptp_support = true,\n\t\t.ops = &mv88e6161_ops,\n\t},\n\n\t[MV88E6165] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6165,\n\t\t.family = MV88E6XXX_FAMILY_6165,\n\t\t.name = \"Marvell 88E6165\",\n\t\t.num_databases = 4096,\n\t\t.num_macs = 8192,\n\t\t.num_ports = 6,\n\t\t.num_internal_phys = 0,\n\t\t.max_vid = 4095,\n\t\t.max_sid = 63,\n\t\t.port_base_addr = 0x10,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 15000,\n\t\t.g1_irqs = 9,\n\t\t.g2_irqs = 10,\n\t\t.atu_move_port_mask = 0xf,\n\t\t.pvt = true,\n\t\t.multi_chip = true,\n\t\t.ptp_support = true,\n\t\t.ops = &mv88e6165_ops,\n\t},\n\n\t[MV88E6171] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6171,\n\t\t.family = MV88E6XXX_FAMILY_6351,\n\t\t.name = \"Marvell 88E6171\",\n\t\t.num_databases = 4096,\n\t\t.num_macs = 8192,\n\t\t.num_ports = 7,\n\t\t.num_internal_phys = 5,\n\t\t.max_vid = 4095,\n\t\t.max_sid = 63,\n\t\t.port_base_addr = 0x10,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 15000,\n\t\t.g1_irqs = 9,\n\t\t.g2_irqs = 10,\n\t\t.atu_move_port_mask = 0xf,\n\t\t.pvt = true,\n\t\t.multi_chip = true,\n\t\t.edsa_support = MV88E6XXX_EDSA_SUPPORTED,\n\t\t.ops = &mv88e6171_ops,\n\t},\n\n\t[MV88E6172] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6172,\n\t\t.family = MV88E6XXX_FAMILY_6352,\n\t\t.name = \"Marvell 88E6172\",\n\t\t.num_databases = 4096,\n\t\t.num_macs = 8192,\n\t\t.num_ports = 7,\n\t\t.num_internal_phys = 5,\n\t\t.num_gpio = 15,\n\t\t.max_vid = 4095,\n\t\t.max_sid = 63,\n\t\t.port_base_addr = 0x10,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 15000,\n\t\t.g1_irqs = 9,\n\t\t.g2_irqs = 10,\n\t\t.atu_move_port_mask = 0xf,\n\t\t.pvt = true,\n\t\t.multi_chip = true,\n\t\t.edsa_support = MV88E6XXX_EDSA_SUPPORTED,\n\t\t.ops = &mv88e6172_ops,\n\t},\n\n\t[MV88E6175] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6175,\n\t\t.family = MV88E6XXX_FAMILY_6351,\n\t\t.name = \"Marvell 88E6175\",\n\t\t.num_databases = 4096,\n\t\t.num_macs = 8192,\n\t\t.num_ports = 7,\n\t\t.num_internal_phys = 5,\n\t\t.max_vid = 4095,\n\t\t.max_sid = 63,\n\t\t.port_base_addr = 0x10,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 15000,\n\t\t.g1_irqs = 9,\n\t\t.g2_irqs = 10,\n\t\t.atu_move_port_mask = 0xf,\n\t\t.pvt = true,\n\t\t.multi_chip = true,\n\t\t.edsa_support = MV88E6XXX_EDSA_SUPPORTED,\n\t\t.ops = &mv88e6175_ops,\n\t},\n\n\t[MV88E6176] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6176,\n\t\t.family = MV88E6XXX_FAMILY_6352,\n\t\t.name = \"Marvell 88E6176\",\n\t\t.num_databases = 4096,\n\t\t.num_macs = 8192,\n\t\t.num_ports = 7,\n\t\t.num_internal_phys = 5,\n\t\t.num_gpio = 15,\n\t\t.max_vid = 4095,\n\t\t.max_sid = 63,\n\t\t.port_base_addr = 0x10,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 15000,\n\t\t.g1_irqs = 9,\n\t\t.g2_irqs = 10,\n\t\t.atu_move_port_mask = 0xf,\n\t\t.pvt = true,\n\t\t.multi_chip = true,\n\t\t.edsa_support = MV88E6XXX_EDSA_SUPPORTED,\n\t\t.ops = &mv88e6176_ops,\n\t},\n\n\t[MV88E6185] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6185,\n\t\t.family = MV88E6XXX_FAMILY_6185,\n\t\t.name = \"Marvell 88E6185\",\n\t\t.num_databases = 256,\n\t\t.num_macs = 8192,\n\t\t.num_ports = 10,\n\t\t.num_internal_phys = 0,\n\t\t.max_vid = 4095,\n\t\t.port_base_addr = 0x10,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 15000,\n\t\t.g1_irqs = 8,\n\t\t.atu_move_port_mask = 0xf,\n\t\t.multi_chip = true,\n\t\t.edsa_support = MV88E6XXX_EDSA_SUPPORTED,\n\t\t.ops = &mv88e6185_ops,\n\t},\n\n\t[MV88E6190] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6190,\n\t\t.family = MV88E6XXX_FAMILY_6390,\n\t\t.name = \"Marvell 88E6190\",\n\t\t.num_databases = 4096,\n\t\t.num_macs = 16384,\n\t\t.num_ports = 11,\t \n\t\t.num_internal_phys = 9,\n\t\t.num_gpio = 16,\n\t\t.max_vid = 8191,\n\t\t.max_sid = 63,\n\t\t.port_base_addr = 0x0,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 3750,\n\t\t.g1_irqs = 9,\n\t\t.g2_irqs = 14,\n\t\t.pvt = true,\n\t\t.multi_chip = true,\n\t\t.atu_move_port_mask = 0x1f,\n\t\t.ops = &mv88e6190_ops,\n\t},\n\n\t[MV88E6190X] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6190X,\n\t\t.family = MV88E6XXX_FAMILY_6390,\n\t\t.name = \"Marvell 88E6190X\",\n\t\t.num_databases = 4096,\n\t\t.num_macs = 16384,\n\t\t.num_ports = 11,\t \n\t\t.num_internal_phys = 9,\n\t\t.num_gpio = 16,\n\t\t.max_vid = 8191,\n\t\t.max_sid = 63,\n\t\t.port_base_addr = 0x0,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 3750,\n\t\t.g1_irqs = 9,\n\t\t.g2_irqs = 14,\n\t\t.atu_move_port_mask = 0x1f,\n\t\t.pvt = true,\n\t\t.multi_chip = true,\n\t\t.ops = &mv88e6190x_ops,\n\t},\n\n\t[MV88E6191] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6191,\n\t\t.family = MV88E6XXX_FAMILY_6390,\n\t\t.name = \"Marvell 88E6191\",\n\t\t.num_databases = 4096,\n\t\t.num_macs = 16384,\n\t\t.num_ports = 11,\t \n\t\t.num_internal_phys = 9,\n\t\t.max_vid = 8191,\n\t\t.max_sid = 63,\n\t\t.port_base_addr = 0x0,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 3750,\n\t\t.g1_irqs = 9,\n\t\t.g2_irqs = 14,\n\t\t.atu_move_port_mask = 0x1f,\n\t\t.pvt = true,\n\t\t.multi_chip = true,\n\t\t.ptp_support = true,\n\t\t.ops = &mv88e6191_ops,\n\t},\n\n\t[MV88E6191X] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6191X,\n\t\t.family = MV88E6XXX_FAMILY_6393,\n\t\t.name = \"Marvell 88E6191X\",\n\t\t.num_databases = 4096,\n\t\t.num_ports = 11,\t \n\t\t.num_internal_phys = 8,\n\t\t.internal_phys_offset = 1,\n\t\t.max_vid = 8191,\n\t\t.max_sid = 63,\n\t\t.port_base_addr = 0x0,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 3750,\n\t\t.g1_irqs = 10,\n\t\t.g2_irqs = 14,\n\t\t.atu_move_port_mask = 0x1f,\n\t\t.pvt = true,\n\t\t.multi_chip = true,\n\t\t.ptp_support = true,\n\t\t.ops = &mv88e6393x_ops,\n\t},\n\n\t[MV88E6193X] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6193X,\n\t\t.family = MV88E6XXX_FAMILY_6393,\n\t\t.name = \"Marvell 88E6193X\",\n\t\t.num_databases = 4096,\n\t\t.num_ports = 11,\t \n\t\t.num_internal_phys = 8,\n\t\t.internal_phys_offset = 1,\n\t\t.max_vid = 8191,\n\t\t.max_sid = 63,\n\t\t.port_base_addr = 0x0,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 3750,\n\t\t.g1_irqs = 10,\n\t\t.g2_irqs = 14,\n\t\t.atu_move_port_mask = 0x1f,\n\t\t.pvt = true,\n\t\t.multi_chip = true,\n\t\t.ptp_support = true,\n\t\t.ops = &mv88e6393x_ops,\n\t},\n\n\t[MV88E6220] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6220,\n\t\t.family = MV88E6XXX_FAMILY_6250,\n\t\t.name = \"Marvell 88E6220\",\n\t\t.num_databases = 64,\n\n\t\t \n\t\t.num_ports = 7,\n\t\t.num_internal_phys = 2,\n\t\t.invalid_port_mask = BIT(2) | BIT(3) | BIT(4),\n\t\t.max_vid = 4095,\n\t\t.port_base_addr = 0x08,\n\t\t.phy_base_addr = 0x00,\n\t\t.global1_addr = 0x0f,\n\t\t.global2_addr = 0x07,\n\t\t.age_time_coeff = 15000,\n\t\t.g1_irqs = 9,\n\t\t.g2_irqs = 10,\n\t\t.atu_move_port_mask = 0xf,\n\t\t.dual_chip = true,\n\t\t.ptp_support = true,\n\t\t.ops = &mv88e6250_ops,\n\t},\n\n\t[MV88E6240] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6240,\n\t\t.family = MV88E6XXX_FAMILY_6352,\n\t\t.name = \"Marvell 88E6240\",\n\t\t.num_databases = 4096,\n\t\t.num_macs = 8192,\n\t\t.num_ports = 7,\n\t\t.num_internal_phys = 5,\n\t\t.num_gpio = 15,\n\t\t.max_vid = 4095,\n\t\t.max_sid = 63,\n\t\t.port_base_addr = 0x10,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 15000,\n\t\t.g1_irqs = 9,\n\t\t.g2_irqs = 10,\n\t\t.atu_move_port_mask = 0xf,\n\t\t.pvt = true,\n\t\t.multi_chip = true,\n\t\t.edsa_support = MV88E6XXX_EDSA_SUPPORTED,\n\t\t.ptp_support = true,\n\t\t.ops = &mv88e6240_ops,\n\t},\n\n\t[MV88E6250] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6250,\n\t\t.family = MV88E6XXX_FAMILY_6250,\n\t\t.name = \"Marvell 88E6250\",\n\t\t.num_databases = 64,\n\t\t.num_ports = 7,\n\t\t.num_internal_phys = 5,\n\t\t.max_vid = 4095,\n\t\t.port_base_addr = 0x08,\n\t\t.phy_base_addr = 0x00,\n\t\t.global1_addr = 0x0f,\n\t\t.global2_addr = 0x07,\n\t\t.age_time_coeff = 15000,\n\t\t.g1_irqs = 9,\n\t\t.g2_irqs = 10,\n\t\t.atu_move_port_mask = 0xf,\n\t\t.dual_chip = true,\n\t\t.ptp_support = true,\n\t\t.ops = &mv88e6250_ops,\n\t},\n\n\t[MV88E6290] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6290,\n\t\t.family = MV88E6XXX_FAMILY_6390,\n\t\t.name = \"Marvell 88E6290\",\n\t\t.num_databases = 4096,\n\t\t.num_ports = 11,\t \n\t\t.num_internal_phys = 9,\n\t\t.num_gpio = 16,\n\t\t.max_vid = 8191,\n\t\t.max_sid = 63,\n\t\t.port_base_addr = 0x0,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 3750,\n\t\t.g1_irqs = 9,\n\t\t.g2_irqs = 14,\n\t\t.atu_move_port_mask = 0x1f,\n\t\t.pvt = true,\n\t\t.multi_chip = true,\n\t\t.ptp_support = true,\n\t\t.ops = &mv88e6290_ops,\n\t},\n\n\t[MV88E6320] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6320,\n\t\t.family = MV88E6XXX_FAMILY_6320,\n\t\t.name = \"Marvell 88E6320\",\n\t\t.num_databases = 4096,\n\t\t.num_macs = 8192,\n\t\t.num_ports = 7,\n\t\t.num_internal_phys = 5,\n\t\t.num_gpio = 15,\n\t\t.max_vid = 4095,\n\t\t.port_base_addr = 0x10,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 15000,\n\t\t.g1_irqs = 8,\n\t\t.g2_irqs = 10,\n\t\t.atu_move_port_mask = 0xf,\n\t\t.pvt = true,\n\t\t.multi_chip = true,\n\t\t.edsa_support = MV88E6XXX_EDSA_SUPPORTED,\n\t\t.ptp_support = true,\n\t\t.ops = &mv88e6320_ops,\n\t},\n\n\t[MV88E6321] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6321,\n\t\t.family = MV88E6XXX_FAMILY_6320,\n\t\t.name = \"Marvell 88E6321\",\n\t\t.num_databases = 4096,\n\t\t.num_macs = 8192,\n\t\t.num_ports = 7,\n\t\t.num_internal_phys = 5,\n\t\t.num_gpio = 15,\n\t\t.max_vid = 4095,\n\t\t.port_base_addr = 0x10,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 15000,\n\t\t.g1_irqs = 8,\n\t\t.g2_irqs = 10,\n\t\t.atu_move_port_mask = 0xf,\n\t\t.multi_chip = true,\n\t\t.edsa_support = MV88E6XXX_EDSA_SUPPORTED,\n\t\t.ptp_support = true,\n\t\t.ops = &mv88e6321_ops,\n\t},\n\n\t[MV88E6341] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6341,\n\t\t.family = MV88E6XXX_FAMILY_6341,\n\t\t.name = \"Marvell 88E6341\",\n\t\t.num_databases = 4096,\n\t\t.num_macs = 2048,\n\t\t.num_internal_phys = 5,\n\t\t.num_ports = 6,\n\t\t.num_gpio = 11,\n\t\t.max_vid = 4095,\n\t\t.max_sid = 63,\n\t\t.port_base_addr = 0x10,\n\t\t.phy_base_addr = 0x10,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 3750,\n\t\t.atu_move_port_mask = 0x1f,\n\t\t.g1_irqs = 9,\n\t\t.g2_irqs = 10,\n\t\t.pvt = true,\n\t\t.multi_chip = true,\n\t\t.edsa_support = MV88E6XXX_EDSA_SUPPORTED,\n\t\t.ptp_support = true,\n\t\t.ops = &mv88e6341_ops,\n\t},\n\n\t[MV88E6350] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6350,\n\t\t.family = MV88E6XXX_FAMILY_6351,\n\t\t.name = \"Marvell 88E6350\",\n\t\t.num_databases = 4096,\n\t\t.num_macs = 8192,\n\t\t.num_ports = 7,\n\t\t.num_internal_phys = 5,\n\t\t.max_vid = 4095,\n\t\t.max_sid = 63,\n\t\t.port_base_addr = 0x10,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 15000,\n\t\t.g1_irqs = 9,\n\t\t.g2_irqs = 10,\n\t\t.atu_move_port_mask = 0xf,\n\t\t.pvt = true,\n\t\t.multi_chip = true,\n\t\t.edsa_support = MV88E6XXX_EDSA_SUPPORTED,\n\t\t.ops = &mv88e6350_ops,\n\t},\n\n\t[MV88E6351] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6351,\n\t\t.family = MV88E6XXX_FAMILY_6351,\n\t\t.name = \"Marvell 88E6351\",\n\t\t.num_databases = 4096,\n\t\t.num_macs = 8192,\n\t\t.num_ports = 7,\n\t\t.num_internal_phys = 5,\n\t\t.max_vid = 4095,\n\t\t.max_sid = 63,\n\t\t.port_base_addr = 0x10,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 15000,\n\t\t.g1_irqs = 9,\n\t\t.g2_irqs = 10,\n\t\t.atu_move_port_mask = 0xf,\n\t\t.pvt = true,\n\t\t.multi_chip = true,\n\t\t.edsa_support = MV88E6XXX_EDSA_SUPPORTED,\n\t\t.ops = &mv88e6351_ops,\n\t},\n\n\t[MV88E6352] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6352,\n\t\t.family = MV88E6XXX_FAMILY_6352,\n\t\t.name = \"Marvell 88E6352\",\n\t\t.num_databases = 4096,\n\t\t.num_macs = 8192,\n\t\t.num_ports = 7,\n\t\t.num_internal_phys = 5,\n\t\t.num_gpio = 15,\n\t\t.max_vid = 4095,\n\t\t.max_sid = 63,\n\t\t.port_base_addr = 0x10,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 15000,\n\t\t.g1_irqs = 9,\n\t\t.g2_irqs = 10,\n\t\t.atu_move_port_mask = 0xf,\n\t\t.pvt = true,\n\t\t.multi_chip = true,\n\t\t.edsa_support = MV88E6XXX_EDSA_SUPPORTED,\n\t\t.ptp_support = true,\n\t\t.ops = &mv88e6352_ops,\n\t},\n\t[MV88E6361] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6361,\n\t\t.family = MV88E6XXX_FAMILY_6393,\n\t\t.name = \"Marvell 88E6361\",\n\t\t.num_databases = 4096,\n\t\t.num_macs = 16384,\n\t\t.num_ports = 11,\n\t\t \n\t\t.invalid_port_mask = BIT(1) | BIT(2) | BIT(8),\n\t\t.num_internal_phys = 5,\n\t\t.internal_phys_offset = 3,\n\t\t.max_vid = 4095,\n\t\t.max_sid = 63,\n\t\t.port_base_addr = 0x0,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 3750,\n\t\t.g1_irqs = 10,\n\t\t.g2_irqs = 14,\n\t\t.atu_move_port_mask = 0x1f,\n\t\t.pvt = true,\n\t\t.multi_chip = true,\n\t\t.ptp_support = true,\n\t\t.ops = &mv88e6393x_ops,\n\t},\n\t[MV88E6390] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6390,\n\t\t.family = MV88E6XXX_FAMILY_6390,\n\t\t.name = \"Marvell 88E6390\",\n\t\t.num_databases = 4096,\n\t\t.num_macs = 16384,\n\t\t.num_ports = 11,\t \n\t\t.num_internal_phys = 9,\n\t\t.num_gpio = 16,\n\t\t.max_vid = 8191,\n\t\t.max_sid = 63,\n\t\t.port_base_addr = 0x0,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 3750,\n\t\t.g1_irqs = 9,\n\t\t.g2_irqs = 14,\n\t\t.atu_move_port_mask = 0x1f,\n\t\t.pvt = true,\n\t\t.multi_chip = true,\n\t\t.edsa_support = MV88E6XXX_EDSA_UNDOCUMENTED,\n\t\t.ptp_support = true,\n\t\t.ops = &mv88e6390_ops,\n\t},\n\t[MV88E6390X] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6390X,\n\t\t.family = MV88E6XXX_FAMILY_6390,\n\t\t.name = \"Marvell 88E6390X\",\n\t\t.num_databases = 4096,\n\t\t.num_macs = 16384,\n\t\t.num_ports = 11,\t \n\t\t.num_internal_phys = 9,\n\t\t.num_gpio = 16,\n\t\t.max_vid = 8191,\n\t\t.max_sid = 63,\n\t\t.port_base_addr = 0x0,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 3750,\n\t\t.g1_irqs = 9,\n\t\t.g2_irqs = 14,\n\t\t.atu_move_port_mask = 0x1f,\n\t\t.pvt = true,\n\t\t.multi_chip = true,\n\t\t.edsa_support = MV88E6XXX_EDSA_UNDOCUMENTED,\n\t\t.ptp_support = true,\n\t\t.ops = &mv88e6390x_ops,\n\t},\n\n\t[MV88E6393X] = {\n\t\t.prod_num = MV88E6XXX_PORT_SWITCH_ID_PROD_6393X,\n\t\t.family = MV88E6XXX_FAMILY_6393,\n\t\t.name = \"Marvell 88E6393X\",\n\t\t.num_databases = 4096,\n\t\t.num_ports = 11,\t \n\t\t.num_internal_phys = 8,\n\t\t.internal_phys_offset = 1,\n\t\t.max_vid = 8191,\n\t\t.max_sid = 63,\n\t\t.port_base_addr = 0x0,\n\t\t.phy_base_addr = 0x0,\n\t\t.global1_addr = 0x1b,\n\t\t.global2_addr = 0x1c,\n\t\t.age_time_coeff = 3750,\n\t\t.g1_irqs = 10,\n\t\t.g2_irqs = 14,\n\t\t.atu_move_port_mask = 0x1f,\n\t\t.pvt = true,\n\t\t.multi_chip = true,\n\t\t.ptp_support = true,\n\t\t.ops = &mv88e6393x_ops,\n\t},\n};\n\nstatic const struct mv88e6xxx_info *mv88e6xxx_lookup_info(unsigned int prod_num)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mv88e6xxx_table); ++i)\n\t\tif (mv88e6xxx_table[i].prod_num == prod_num)\n\t\t\treturn &mv88e6xxx_table[i];\n\n\treturn NULL;\n}\n\nstatic int mv88e6xxx_detect(struct mv88e6xxx_chip *chip)\n{\n\tconst struct mv88e6xxx_info *info;\n\tunsigned int prod_num, rev;\n\tu16 id;\n\tint err;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = mv88e6xxx_port_read(chip, 0, MV88E6XXX_PORT_SWITCH_ID, &id);\n\tmv88e6xxx_reg_unlock(chip);\n\tif (err)\n\t\treturn err;\n\n\tprod_num = id & MV88E6XXX_PORT_SWITCH_ID_PROD_MASK;\n\trev = id & MV88E6XXX_PORT_SWITCH_ID_REV_MASK;\n\n\tinfo = mv88e6xxx_lookup_info(prod_num);\n\tif (!info)\n\t\treturn -ENODEV;\n\n\t \n\tchip->info = info;\n\n\tdev_info(chip->dev, \"switch 0x%x detected: %s, revision %u\\n\",\n\t\t chip->info->prod_num, chip->info->name, rev);\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_single_chip_detect(struct mv88e6xxx_chip *chip,\n\t\t\t\t\tstruct mdio_device *mdiodev)\n{\n\tint err;\n\n\t \n\tif (chip->info->dual_chip)\n\t\treturn -EINVAL;\n\n\t \n\tif (mdiodev->addr != 16)\n\t\treturn -EINVAL;\n\n\terr = mv88e6xxx_smi_init(chip, mdiodev->bus, 0);\n\tif (err)\n\t\treturn err;\n\n\treturn mv88e6xxx_detect(chip);\n}\n\nstatic struct mv88e6xxx_chip *mv88e6xxx_alloc_chip(struct device *dev)\n{\n\tstruct mv88e6xxx_chip *chip;\n\n\tchip = devm_kzalloc(dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn NULL;\n\n\tchip->dev = dev;\n\n\tmutex_init(&chip->reg_lock);\n\tINIT_LIST_HEAD(&chip->mdios);\n\tidr_init(&chip->policies);\n\tINIT_LIST_HEAD(&chip->msts);\n\n\treturn chip;\n}\n\nstatic enum dsa_tag_protocol mv88e6xxx_get_tag_protocol(struct dsa_switch *ds,\n\t\t\t\t\t\t\tint port,\n\t\t\t\t\t\t\tenum dsa_tag_protocol m)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\n\treturn chip->tag_protocol;\n}\n\nstatic int mv88e6xxx_change_tag_protocol(struct dsa_switch *ds,\n\t\t\t\t\t enum dsa_tag_protocol proto)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tenum dsa_tag_protocol old_protocol;\n\tstruct dsa_port *cpu_dp;\n\tint err;\n\n\tswitch (proto) {\n\tcase DSA_TAG_PROTO_EDSA:\n\t\tswitch (chip->info->edsa_support) {\n\t\tcase MV88E6XXX_EDSA_UNSUPPORTED:\n\t\t\treturn -EPROTONOSUPPORT;\n\t\tcase MV88E6XXX_EDSA_UNDOCUMENTED:\n\t\t\tdev_warn(chip->dev, \"Relying on undocumented EDSA tagging behavior\\n\");\n\t\t\tfallthrough;\n\t\tcase MV88E6XXX_EDSA_SUPPORTED:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DSA_TAG_PROTO_DSA:\n\t\tbreak;\n\tdefault:\n\t\treturn -EPROTONOSUPPORT;\n\t}\n\n\told_protocol = chip->tag_protocol;\n\tchip->tag_protocol = proto;\n\n\tmv88e6xxx_reg_lock(chip);\n\tdsa_switch_for_each_cpu_port(cpu_dp, ds) {\n\t\terr = mv88e6xxx_setup_port_mode(chip, cpu_dp->index);\n\t\tif (err) {\n\t\t\tmv88e6xxx_reg_unlock(chip);\n\t\t\tgoto unwind;\n\t\t}\n\t}\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn 0;\n\nunwind:\n\tchip->tag_protocol = old_protocol;\n\n\tmv88e6xxx_reg_lock(chip);\n\tdsa_switch_for_each_cpu_port_continue_reverse(cpu_dp, ds)\n\t\tmv88e6xxx_setup_port_mode(chip, cpu_dp->index);\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err;\n}\n\nstatic int mv88e6xxx_port_mdb_add(struct dsa_switch *ds, int port,\n\t\t\t\t  const struct switchdev_obj_port_mdb *mdb,\n\t\t\t\t  struct dsa_db db)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = mv88e6xxx_port_db_load_purge(chip, port, mdb->addr, mdb->vid,\n\t\t\t\t\t   MV88E6XXX_G1_ATU_DATA_STATE_MC_STATIC);\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err;\n}\n\nstatic int mv88e6xxx_port_mdb_del(struct dsa_switch *ds, int port,\n\t\t\t\t  const struct switchdev_obj_port_mdb *mdb,\n\t\t\t\t  struct dsa_db db)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = mv88e6xxx_port_db_load_purge(chip, port, mdb->addr, mdb->vid, 0);\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err;\n}\n\nstatic int mv88e6xxx_port_mirror_add(struct dsa_switch *ds, int port,\n\t\t\t\t     struct dsa_mall_mirror_tc_entry *mirror,\n\t\t\t\t     bool ingress,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tenum mv88e6xxx_egress_direction direction = ingress ?\n\t\t\t\t\t\tMV88E6XXX_EGRESS_DIR_INGRESS :\n\t\t\t\t\t\tMV88E6XXX_EGRESS_DIR_EGRESS;\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tbool other_mirrors = false;\n\tint i;\n\tint err;\n\n\tmutex_lock(&chip->reg_lock);\n\tif ((ingress ? chip->ingress_dest_port : chip->egress_dest_port) !=\n\t    mirror->to_local_port) {\n\t\tfor (i = 0; i < mv88e6xxx_num_ports(chip); i++)\n\t\t\tother_mirrors |= ingress ?\n\t\t\t\t\t chip->ports[i].mirror_ingress :\n\t\t\t\t\t chip->ports[i].mirror_egress;\n\n\t\t \n\t\tif (other_mirrors) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = mv88e6xxx_set_egress_port(chip, direction,\n\t\t\t\t\t\tmirror->to_local_port);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = mv88e6xxx_port_set_mirror(chip, port, direction, true);\nout:\n\tmutex_unlock(&chip->reg_lock);\n\n\treturn err;\n}\n\nstatic void mv88e6xxx_port_mirror_del(struct dsa_switch *ds, int port,\n\t\t\t\t      struct dsa_mall_mirror_tc_entry *mirror)\n{\n\tenum mv88e6xxx_egress_direction direction = mirror->ingress ?\n\t\t\t\t\t\tMV88E6XXX_EGRESS_DIR_INGRESS :\n\t\t\t\t\t\tMV88E6XXX_EGRESS_DIR_EGRESS;\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tbool other_mirrors = false;\n\tint i;\n\n\tmutex_lock(&chip->reg_lock);\n\tif (mv88e6xxx_port_set_mirror(chip, port, direction, false))\n\t\tdev_err(ds->dev, \"p%d: failed to disable mirroring\\n\", port);\n\n\tfor (i = 0; i < mv88e6xxx_num_ports(chip); i++)\n\t\tother_mirrors |= mirror->ingress ?\n\t\t\t\t chip->ports[i].mirror_ingress :\n\t\t\t\t chip->ports[i].mirror_egress;\n\n\t \n\tif (!other_mirrors) {\n\t\tif (mv88e6xxx_set_egress_port(chip, direction,\n\t\t\t\t\t      dsa_upstream_port(ds, port)))\n\t\t\tdev_err(ds->dev, \"failed to set egress port\\n\");\n\t}\n\n\tmutex_unlock(&chip->reg_lock);\n}\n\nstatic int mv88e6xxx_port_pre_bridge_flags(struct dsa_switch *ds, int port,\n\t\t\t\t\t   struct switchdev_brport_flags flags,\n\t\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tconst struct mv88e6xxx_ops *ops;\n\n\tif (flags.mask & ~(BR_LEARNING | BR_FLOOD | BR_MCAST_FLOOD |\n\t\t\t   BR_BCAST_FLOOD | BR_PORT_LOCKED | BR_PORT_MAB))\n\t\treturn -EINVAL;\n\n\tops = chip->info->ops;\n\n\tif ((flags.mask & BR_FLOOD) && !ops->port_set_ucast_flood)\n\t\treturn -EINVAL;\n\n\tif ((flags.mask & BR_MCAST_FLOOD) && !ops->port_set_mcast_flood)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_port_bridge_flags(struct dsa_switch *ds, int port,\n\t\t\t\t       struct switchdev_brport_flags flags,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err = 0;\n\n\tmv88e6xxx_reg_lock(chip);\n\n\tif (flags.mask & BR_LEARNING) {\n\t\tbool learning = !!(flags.val & BR_LEARNING);\n\t\tu16 pav = learning ? (1 << port) : 0;\n\n\t\terr = mv88e6xxx_port_set_assoc_vector(chip, port, pav);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (flags.mask & BR_FLOOD) {\n\t\tbool unicast = !!(flags.val & BR_FLOOD);\n\n\t\terr = chip->info->ops->port_set_ucast_flood(chip, port,\n\t\t\t\t\t\t\t    unicast);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (flags.mask & BR_MCAST_FLOOD) {\n\t\tbool multicast = !!(flags.val & BR_MCAST_FLOOD);\n\n\t\terr = chip->info->ops->port_set_mcast_flood(chip, port,\n\t\t\t\t\t\t\t    multicast);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (flags.mask & BR_BCAST_FLOOD) {\n\t\tbool broadcast = !!(flags.val & BR_BCAST_FLOOD);\n\n\t\terr = mv88e6xxx_port_broadcast_sync(chip, port, broadcast);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (flags.mask & BR_PORT_MAB) {\n\t\tbool mab = !!(flags.val & BR_PORT_MAB);\n\n\t\tmv88e6xxx_port_set_mab(chip, port, mab);\n\t}\n\n\tif (flags.mask & BR_PORT_LOCKED) {\n\t\tbool locked = !!(flags.val & BR_PORT_LOCKED);\n\n\t\terr = mv88e6xxx_port_set_lock(chip, port, locked);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\nout:\n\tmv88e6xxx_reg_unlock(chip);\n\n\treturn err;\n}\n\nstatic bool mv88e6xxx_lag_can_offload(struct dsa_switch *ds,\n\t\t\t\t      struct dsa_lag lag,\n\t\t\t\t      struct netdev_lag_upper_info *info,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tstruct dsa_port *dp;\n\tint members = 0;\n\n\tif (!mv88e6xxx_has_lag(chip)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Chip does not support LAG offload\");\n\t\treturn false;\n\t}\n\n\tif (!lag.id)\n\t\treturn false;\n\n\tdsa_lag_foreach_port(dp, ds->dst, &lag)\n\t\t \n\t\tmembers++;\n\n\tif (members > 8) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Cannot offload more than 8 LAG ports\");\n\t\treturn false;\n\t}\n\n\t \n\tif (info->tx_type != NETDEV_LAG_TX_TYPE_HASH) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Can only offload LAG using hash TX type\");\n\t\treturn false;\n\t}\n\n\t \n\treturn true;\n}\n\nstatic int mv88e6xxx_lag_sync_map(struct dsa_switch *ds, struct dsa_lag lag)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tstruct dsa_port *dp;\n\tu16 map = 0;\n\tint id;\n\n\t \n\tid = lag.id - 1;\n\n\t \n\tdsa_lag_foreach_port(dp, ds->dst, &lag)\n\t\tmap |= BIT(dsa_towards_port(ds, dp->ds->index, dp->index));\n\n\treturn mv88e6xxx_g2_trunk_mapping_write(chip, id, map);\n}\n\nstatic const u8 mv88e6xxx_lag_mask_table[8][8] = {\n\t \n\t{ 0xff,    0,    0,    0,    0,    0,    0,    0 },\n\t{ 0x0f, 0xf0,    0,    0,    0,    0,    0,    0 },\n\t{ 0x07, 0x38, 0xc0,    0,    0,    0,    0,    0 },\n\t{ 0x03, 0x0c, 0x30, 0xc0,    0,    0,    0,    0 },\n\t{ 0x03, 0x0c, 0x30, 0x40, 0x80,    0,    0,    0 },\n\t{ 0x03, 0x0c, 0x10, 0x20, 0x40, 0x80,    0,    0 },\n\t{ 0x03, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,    0 },\n\t{ 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 },\n};\n\nstatic void mv88e6xxx_lag_set_port_mask(u16 *mask, int port,\n\t\t\t\t\tint num_tx, int nth)\n{\n\tu8 active = 0;\n\tint i;\n\n\tnum_tx = num_tx <= 8 ? num_tx : 8;\n\tif (nth < num_tx)\n\t\tactive = mv88e6xxx_lag_mask_table[num_tx - 1][nth];\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (BIT(i) & active)\n\t\t\tmask[i] |= BIT(port);\n\t}\n}\n\nstatic int mv88e6xxx_lag_sync_masks(struct dsa_switch *ds)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tunsigned int id, num_tx;\n\tstruct dsa_port *dp;\n\tstruct dsa_lag *lag;\n\tint i, err, nth;\n\tu16 mask[8];\n\tu16 ivec;\n\n\t \n\tivec = BIT(mv88e6xxx_num_ports(chip)) - 1;\n\n\t \n\tdsa_switch_for_each_port(dp, ds) {\n\t\tif (!dp->lag)\n\t\t\tcontinue;\n\n\t\tivec &= ~BIT(dp->index);\n\t}\n\n\tfor (i = 0; i < 8; i++)\n\t\tmask[i] = ivec;\n\n\t \n\tdsa_lags_foreach_id(id, ds->dst) {\n\t\tlag = dsa_lag_by_id(ds->dst, id);\n\t\tif (!lag)\n\t\t\tcontinue;\n\n\t\tnum_tx = 0;\n\t\tdsa_lag_foreach_port(dp, ds->dst, lag) {\n\t\t\tif (dp->lag_tx_enabled)\n\t\t\t\tnum_tx++;\n\t\t}\n\n\t\tif (!num_tx)\n\t\t\tcontinue;\n\n\t\tnth = 0;\n\t\tdsa_lag_foreach_port(dp, ds->dst, lag) {\n\t\t\tif (!dp->lag_tx_enabled)\n\t\t\t\tcontinue;\n\n\t\t\tif (dp->ds == ds)\n\t\t\t\tmv88e6xxx_lag_set_port_mask(mask, dp->index,\n\t\t\t\t\t\t\t    num_tx, nth);\n\n\t\t\tnth++;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\terr = mv88e6xxx_g2_trunk_mask_write(chip, i, true, mask[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int mv88e6xxx_lag_sync_masks_map(struct dsa_switch *ds,\n\t\t\t\t\tstruct dsa_lag lag)\n{\n\tint err;\n\n\terr = mv88e6xxx_lag_sync_masks(ds);\n\n\tif (!err)\n\t\terr = mv88e6xxx_lag_sync_map(ds, lag);\n\n\treturn err;\n}\n\nstatic int mv88e6xxx_port_lag_change(struct dsa_switch *ds, int port)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = mv88e6xxx_lag_sync_masks(ds);\n\tmv88e6xxx_reg_unlock(chip);\n\treturn err;\n}\n\nstatic int mv88e6xxx_port_lag_join(struct dsa_switch *ds, int port,\n\t\t\t\t   struct dsa_lag lag,\n\t\t\t\t   struct netdev_lag_upper_info *info,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err, id;\n\n\tif (!mv88e6xxx_lag_can_offload(ds, lag, info, extack))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tid = lag.id - 1;\n\n\tmv88e6xxx_reg_lock(chip);\n\n\terr = mv88e6xxx_port_set_trunk(chip, port, true, id);\n\tif (err)\n\t\tgoto err_unlock;\n\n\terr = mv88e6xxx_lag_sync_masks_map(ds, lag);\n\tif (err)\n\t\tgoto err_clear_trunk;\n\n\tmv88e6xxx_reg_unlock(chip);\n\treturn 0;\n\nerr_clear_trunk:\n\tmv88e6xxx_port_set_trunk(chip, port, false, 0);\nerr_unlock:\n\tmv88e6xxx_reg_unlock(chip);\n\treturn err;\n}\n\nstatic int mv88e6xxx_port_lag_leave(struct dsa_switch *ds, int port,\n\t\t\t\t    struct dsa_lag lag)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err_sync, err_trunk;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr_sync = mv88e6xxx_lag_sync_masks_map(ds, lag);\n\terr_trunk = mv88e6xxx_port_set_trunk(chip, port, false, 0);\n\tmv88e6xxx_reg_unlock(chip);\n\treturn err_sync ? : err_trunk;\n}\n\nstatic int mv88e6xxx_crosschip_lag_change(struct dsa_switch *ds, int sw_index,\n\t\t\t\t\t  int port)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = mv88e6xxx_lag_sync_masks(ds);\n\tmv88e6xxx_reg_unlock(chip);\n\treturn err;\n}\n\nstatic int mv88e6xxx_crosschip_lag_join(struct dsa_switch *ds, int sw_index,\n\t\t\t\t\tint port, struct dsa_lag lag,\n\t\t\t\t\tstruct netdev_lag_upper_info *info,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err;\n\n\tif (!mv88e6xxx_lag_can_offload(ds, lag, info, extack))\n\t\treturn -EOPNOTSUPP;\n\n\tmv88e6xxx_reg_lock(chip);\n\n\terr = mv88e6xxx_lag_sync_masks_map(ds, lag);\n\tif (err)\n\t\tgoto unlock;\n\n\terr = mv88e6xxx_pvt_map(chip, sw_index, port);\n\nunlock:\n\tmv88e6xxx_reg_unlock(chip);\n\treturn err;\n}\n\nstatic int mv88e6xxx_crosschip_lag_leave(struct dsa_switch *ds, int sw_index,\n\t\t\t\t\t int port, struct dsa_lag lag)\n{\n\tstruct mv88e6xxx_chip *chip = ds->priv;\n\tint err_sync, err_pvt;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr_sync = mv88e6xxx_lag_sync_masks_map(ds, lag);\n\terr_pvt = mv88e6xxx_pvt_map(chip, sw_index, port);\n\tmv88e6xxx_reg_unlock(chip);\n\treturn err_sync ? : err_pvt;\n}\n\nstatic const struct dsa_switch_ops mv88e6xxx_switch_ops = {\n\t.get_tag_protocol\t= mv88e6xxx_get_tag_protocol,\n\t.change_tag_protocol\t= mv88e6xxx_change_tag_protocol,\n\t.setup\t\t\t= mv88e6xxx_setup,\n\t.teardown\t\t= mv88e6xxx_teardown,\n\t.port_setup\t\t= mv88e6xxx_port_setup,\n\t.port_teardown\t\t= mv88e6xxx_port_teardown,\n\t.phylink_get_caps\t= mv88e6xxx_get_caps,\n\t.phylink_mac_select_pcs\t= mv88e6xxx_mac_select_pcs,\n\t.phylink_mac_prepare\t= mv88e6xxx_mac_prepare,\n\t.phylink_mac_config\t= mv88e6xxx_mac_config,\n\t.phylink_mac_finish\t= mv88e6xxx_mac_finish,\n\t.phylink_mac_link_down\t= mv88e6xxx_mac_link_down,\n\t.phylink_mac_link_up\t= mv88e6xxx_mac_link_up,\n\t.get_strings\t\t= mv88e6xxx_get_strings,\n\t.get_ethtool_stats\t= mv88e6xxx_get_ethtool_stats,\n\t.get_sset_count\t\t= mv88e6xxx_get_sset_count,\n\t.port_max_mtu\t\t= mv88e6xxx_get_max_mtu,\n\t.port_change_mtu\t= mv88e6xxx_change_mtu,\n\t.get_mac_eee\t\t= mv88e6xxx_get_mac_eee,\n\t.set_mac_eee\t\t= mv88e6xxx_set_mac_eee,\n\t.get_eeprom_len\t\t= mv88e6xxx_get_eeprom_len,\n\t.get_eeprom\t\t= mv88e6xxx_get_eeprom,\n\t.set_eeprom\t\t= mv88e6xxx_set_eeprom,\n\t.get_regs_len\t\t= mv88e6xxx_get_regs_len,\n\t.get_regs\t\t= mv88e6xxx_get_regs,\n\t.get_rxnfc\t\t= mv88e6xxx_get_rxnfc,\n\t.set_rxnfc\t\t= mv88e6xxx_set_rxnfc,\n\t.set_ageing_time\t= mv88e6xxx_set_ageing_time,\n\t.port_bridge_join\t= mv88e6xxx_port_bridge_join,\n\t.port_bridge_leave\t= mv88e6xxx_port_bridge_leave,\n\t.port_pre_bridge_flags\t= mv88e6xxx_port_pre_bridge_flags,\n\t.port_bridge_flags\t= mv88e6xxx_port_bridge_flags,\n\t.port_stp_state_set\t= mv88e6xxx_port_stp_state_set,\n\t.port_mst_state_set\t= mv88e6xxx_port_mst_state_set,\n\t.port_fast_age\t\t= mv88e6xxx_port_fast_age,\n\t.port_vlan_fast_age\t= mv88e6xxx_port_vlan_fast_age,\n\t.port_vlan_filtering\t= mv88e6xxx_port_vlan_filtering,\n\t.port_vlan_add\t\t= mv88e6xxx_port_vlan_add,\n\t.port_vlan_del\t\t= mv88e6xxx_port_vlan_del,\n\t.vlan_msti_set\t\t= mv88e6xxx_vlan_msti_set,\n\t.port_fdb_add\t\t= mv88e6xxx_port_fdb_add,\n\t.port_fdb_del\t\t= mv88e6xxx_port_fdb_del,\n\t.port_fdb_dump\t\t= mv88e6xxx_port_fdb_dump,\n\t.port_mdb_add\t\t= mv88e6xxx_port_mdb_add,\n\t.port_mdb_del\t\t= mv88e6xxx_port_mdb_del,\n\t.port_mirror_add\t= mv88e6xxx_port_mirror_add,\n\t.port_mirror_del\t= mv88e6xxx_port_mirror_del,\n\t.crosschip_bridge_join\t= mv88e6xxx_crosschip_bridge_join,\n\t.crosschip_bridge_leave\t= mv88e6xxx_crosschip_bridge_leave,\n\t.port_hwtstamp_set\t= mv88e6xxx_port_hwtstamp_set,\n\t.port_hwtstamp_get\t= mv88e6xxx_port_hwtstamp_get,\n\t.port_txtstamp\t\t= mv88e6xxx_port_txtstamp,\n\t.port_rxtstamp\t\t= mv88e6xxx_port_rxtstamp,\n\t.get_ts_info\t\t= mv88e6xxx_get_ts_info,\n\t.devlink_param_get\t= mv88e6xxx_devlink_param_get,\n\t.devlink_param_set\t= mv88e6xxx_devlink_param_set,\n\t.devlink_info_get\t= mv88e6xxx_devlink_info_get,\n\t.port_lag_change\t= mv88e6xxx_port_lag_change,\n\t.port_lag_join\t\t= mv88e6xxx_port_lag_join,\n\t.port_lag_leave\t\t= mv88e6xxx_port_lag_leave,\n\t.crosschip_lag_change\t= mv88e6xxx_crosschip_lag_change,\n\t.crosschip_lag_join\t= mv88e6xxx_crosschip_lag_join,\n\t.crosschip_lag_leave\t= mv88e6xxx_crosschip_lag_leave,\n};\n\nstatic int mv88e6xxx_register_switch(struct mv88e6xxx_chip *chip)\n{\n\tstruct device *dev = chip->dev;\n\tstruct dsa_switch *ds;\n\n\tds = devm_kzalloc(dev, sizeof(*ds), GFP_KERNEL);\n\tif (!ds)\n\t\treturn -ENOMEM;\n\n\tds->dev = dev;\n\tds->num_ports = mv88e6xxx_num_ports(chip);\n\tds->priv = chip;\n\tds->dev = dev;\n\tds->ops = &mv88e6xxx_switch_ops;\n\tds->ageing_time_min = chip->info->age_time_coeff;\n\tds->ageing_time_max = chip->info->age_time_coeff * U8_MAX;\n\n\t \n\tds->num_lag_ids = mv88e6xxx_has_lag(chip) ? 16 : 0;\n\n\tdev_set_drvdata(dev, ds);\n\n\treturn dsa_register_switch(ds);\n}\n\nstatic void mv88e6xxx_unregister_switch(struct mv88e6xxx_chip *chip)\n{\n\tdsa_unregister_switch(chip->ds);\n}\n\nstatic const void *pdata_device_get_match_data(struct device *dev)\n{\n\tconst struct of_device_id *matches = dev->driver->of_match_table;\n\tconst struct dsa_mv88e6xxx_pdata *pdata = dev->platform_data;\n\n\tfor (; matches->name[0] || matches->type[0] || matches->compatible[0];\n\t     matches++) {\n\t\tif (!strcmp(pdata->compatible, matches->compatible))\n\t\t\treturn matches->data;\n\t}\n\treturn NULL;\n}\n\n \nstatic int __maybe_unused mv88e6xxx_suspend(struct device *dev)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int __maybe_unused mv88e6xxx_resume(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(mv88e6xxx_pm_ops, mv88e6xxx_suspend, mv88e6xxx_resume);\n\nstatic int mv88e6xxx_probe(struct mdio_device *mdiodev)\n{\n\tstruct dsa_mv88e6xxx_pdata *pdata = mdiodev->dev.platform_data;\n\tconst struct mv88e6xxx_info *compat_info = NULL;\n\tstruct device *dev = &mdiodev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct mv88e6xxx_chip *chip;\n\tint port;\n\tint err;\n\n\tif (!np && !pdata)\n\t\treturn -EINVAL;\n\n\tif (np)\n\t\tcompat_info = of_device_get_match_data(dev);\n\n\tif (pdata) {\n\t\tcompat_info = pdata_device_get_match_data(dev);\n\n\t\tif (!pdata->netdev)\n\t\t\treturn -EINVAL;\n\n\t\tfor (port = 0; port < DSA_MAX_PORTS; port++) {\n\t\t\tif (!(pdata->enabled_ports & (1 << port)))\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(pdata->cd.port_names[port], \"cpu\"))\n\t\t\t\tcontinue;\n\t\t\tpdata->cd.netdev[port] = &pdata->netdev->dev;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!compat_info)\n\t\treturn -EINVAL;\n\n\tchip = mv88e6xxx_alloc_chip(dev);\n\tif (!chip) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tchip->info = compat_info;\n\n\tchip->reset = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(chip->reset)) {\n\t\terr = PTR_ERR(chip->reset);\n\t\tgoto out;\n\t}\n\tif (chip->reset)\n\t\tusleep_range(10000, 20000);\n\n\t \n\terr = mv88e6xxx_single_chip_detect(chip, mdiodev);\n\tif (err) {\n\t\terr = mv88e6xxx_smi_init(chip, mdiodev->bus, mdiodev->addr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = mv88e6xxx_detect(chip);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (chip->info->edsa_support == MV88E6XXX_EDSA_SUPPORTED)\n\t\tchip->tag_protocol = DSA_TAG_PROTO_EDSA;\n\telse\n\t\tchip->tag_protocol = DSA_TAG_PROTO_DSA;\n\n\tmv88e6xxx_phy_init(chip);\n\n\tif (chip->info->ops->get_eeprom) {\n\t\tif (np)\n\t\t\tof_property_read_u32(np, \"eeprom-length\",\n\t\t\t\t\t     &chip->eeprom_len);\n\t\telse\n\t\t\tchip->eeprom_len = pdata->eeprom_len;\n\t}\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = mv88e6xxx_switch_reset(chip);\n\tmv88e6xxx_reg_unlock(chip);\n\tif (err)\n\t\tgoto out;\n\n\tif (np) {\n\t\tchip->irq = of_irq_get(np, 0);\n\t\tif (chip->irq == -EPROBE_DEFER) {\n\t\t\terr = chip->irq;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (pdata)\n\t\tchip->irq = pdata->irq;\n\n\t \n\tmv88e6xxx_reg_lock(chip);\n\tif (chip->irq > 0)\n\t\terr = mv88e6xxx_g1_irq_setup(chip);\n\telse\n\t\terr = mv88e6xxx_irq_poll_setup(chip);\n\tmv88e6xxx_reg_unlock(chip);\n\n\tif (err)\n\t\tgoto out;\n\n\tif (chip->info->g2_irqs > 0) {\n\t\terr = mv88e6xxx_g2_irq_setup(chip);\n\t\tif (err)\n\t\t\tgoto out_g1_irq;\n\t}\n\n\terr = mv88e6xxx_g1_atu_prob_irq_setup(chip);\n\tif (err)\n\t\tgoto out_g2_irq;\n\n\terr = mv88e6xxx_g1_vtu_prob_irq_setup(chip);\n\tif (err)\n\t\tgoto out_g1_atu_prob_irq;\n\n\terr = mv88e6xxx_register_switch(chip);\n\tif (err)\n\t\tgoto out_g1_vtu_prob_irq;\n\n\treturn 0;\n\nout_g1_vtu_prob_irq:\n\tmv88e6xxx_g1_vtu_prob_irq_free(chip);\nout_g1_atu_prob_irq:\n\tmv88e6xxx_g1_atu_prob_irq_free(chip);\nout_g2_irq:\n\tif (chip->info->g2_irqs > 0)\n\t\tmv88e6xxx_g2_irq_free(chip);\nout_g1_irq:\n\tif (chip->irq > 0)\n\t\tmv88e6xxx_g1_irq_free(chip);\n\telse\n\t\tmv88e6xxx_irq_poll_free(chip);\nout:\n\tif (pdata)\n\t\tdev_put(pdata->netdev);\n\n\treturn err;\n}\n\nstatic void mv88e6xxx_remove(struct mdio_device *mdiodev)\n{\n\tstruct dsa_switch *ds = dev_get_drvdata(&mdiodev->dev);\n\tstruct mv88e6xxx_chip *chip;\n\n\tif (!ds)\n\t\treturn;\n\n\tchip = ds->priv;\n\n\tif (chip->info->ptp_support) {\n\t\tmv88e6xxx_hwtstamp_free(chip);\n\t\tmv88e6xxx_ptp_free(chip);\n\t}\n\n\tmv88e6xxx_phy_destroy(chip);\n\tmv88e6xxx_unregister_switch(chip);\n\n\tmv88e6xxx_g1_vtu_prob_irq_free(chip);\n\tmv88e6xxx_g1_atu_prob_irq_free(chip);\n\n\tif (chip->info->g2_irqs > 0)\n\t\tmv88e6xxx_g2_irq_free(chip);\n\n\tif (chip->irq > 0)\n\t\tmv88e6xxx_g1_irq_free(chip);\n\telse\n\t\tmv88e6xxx_irq_poll_free(chip);\n}\n\nstatic void mv88e6xxx_shutdown(struct mdio_device *mdiodev)\n{\n\tstruct dsa_switch *ds = dev_get_drvdata(&mdiodev->dev);\n\n\tif (!ds)\n\t\treturn;\n\n\tdsa_switch_shutdown(ds);\n\n\tdev_set_drvdata(&mdiodev->dev, NULL);\n}\n\nstatic const struct of_device_id mv88e6xxx_of_match[] = {\n\t{\n\t\t.compatible = \"marvell,mv88e6085\",\n\t\t.data = &mv88e6xxx_table[MV88E6085],\n\t},\n\t{\n\t\t.compatible = \"marvell,mv88e6190\",\n\t\t.data = &mv88e6xxx_table[MV88E6190],\n\t},\n\t{\n\t\t.compatible = \"marvell,mv88e6250\",\n\t\t.data = &mv88e6xxx_table[MV88E6250],\n\t},\n\t{   },\n};\n\nMODULE_DEVICE_TABLE(of, mv88e6xxx_of_match);\n\nstatic struct mdio_driver mv88e6xxx_driver = {\n\t.probe\t= mv88e6xxx_probe,\n\t.remove = mv88e6xxx_remove,\n\t.shutdown = mv88e6xxx_shutdown,\n\t.mdiodrv.driver = {\n\t\t.name = \"mv88e6085\",\n\t\t.of_match_table = mv88e6xxx_of_match,\n\t\t.pm = &mv88e6xxx_pm_ops,\n\t},\n};\n\nmdio_module_driver(mv88e6xxx_driver);\n\nMODULE_AUTHOR(\"Lennert Buytenhek <buytenh@wantstofly.org>\");\nMODULE_DESCRIPTION(\"Driver for Marvell 88E6XXX ethernet switch chips\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}