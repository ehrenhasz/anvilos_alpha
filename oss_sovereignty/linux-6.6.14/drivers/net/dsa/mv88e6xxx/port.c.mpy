{
  "module_name": "port.c",
  "hash_id": "d6e12a41a1dae6f470162476f2480cb486f852b98704afb303d6317a4310c1e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/mv88e6xxx/port.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/if_bridge.h>\n#include <linux/phy.h>\n#include <linux/phylink.h>\n\n#include \"chip.h\"\n#include \"global2.h\"\n#include \"port.h\"\n#include \"serdes.h\"\n\nint mv88e6xxx_port_read(struct mv88e6xxx_chip *chip, int port, int reg,\n\t\t\tu16 *val)\n{\n\tint addr = chip->info->port_base_addr + port;\n\n\treturn mv88e6xxx_read(chip, addr, reg, val);\n}\n\nint mv88e6xxx_port_wait_bit(struct mv88e6xxx_chip *chip, int port, int reg,\n\t\t\t    int bit, int val)\n{\n\tint addr = chip->info->port_base_addr + port;\n\n\treturn mv88e6xxx_wait_bit(chip, addr, reg, bit, val);\n}\n\nint mv88e6xxx_port_write(struct mv88e6xxx_chip *chip, int port, int reg,\n\t\t\t u16 val)\n{\n\tint addr = chip->info->port_base_addr + port;\n\n\treturn mv88e6xxx_write(chip, addr, reg, val);\n}\n\n \nint mv88e6185_port_set_pause(struct mv88e6xxx_chip *chip, int port,\n\t\t\t     int pause)\n{\n\tu16 reg;\n\tint err;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_STS, &reg);\n\tif (err)\n\t\treturn err;\n\n\tif (pause)\n\t\treg |= MV88E6XXX_PORT_STS_MY_PAUSE;\n\telse\n\t\treg &= ~MV88E6XXX_PORT_STS_MY_PAUSE;\n\n\treturn mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_STS, reg);\n}\n\n \n\nstatic int mv88e6xxx_port_set_rgmii_delay(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t\t  phy_interface_t mode)\n{\n\tu16 reg;\n\tint err;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_MAC_CTL, &reg);\n\tif (err)\n\t\treturn err;\n\n\treg &= ~(MV88E6XXX_PORT_MAC_CTL_RGMII_DELAY_RXCLK |\n\t\t MV88E6XXX_PORT_MAC_CTL_RGMII_DELAY_TXCLK);\n\n\tswitch (mode) {\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\treg |= MV88E6XXX_PORT_MAC_CTL_RGMII_DELAY_RXCLK;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\treg |= MV88E6XXX_PORT_MAC_CTL_RGMII_DELAY_TXCLK;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\t\treg |= MV88E6XXX_PORT_MAC_CTL_RGMII_DELAY_RXCLK |\n\t\t\tMV88E6XXX_PORT_MAC_CTL_RGMII_DELAY_TXCLK;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII:\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\terr = mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_MAC_CTL, reg);\n\tif (err)\n\t\treturn err;\n\n\tdev_dbg(chip->dev, \"p%d: delay RXCLK %s, TXCLK %s\\n\", port,\n\t\treg & MV88E6XXX_PORT_MAC_CTL_RGMII_DELAY_RXCLK ? \"yes\" : \"no\",\n\t\treg & MV88E6XXX_PORT_MAC_CTL_RGMII_DELAY_TXCLK ? \"yes\" : \"no\");\n\n\treturn 0;\n}\n\nint mv88e6352_port_set_rgmii_delay(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t   phy_interface_t mode)\n{\n\tif (port < 5)\n\t\treturn -EOPNOTSUPP;\n\n\treturn mv88e6xxx_port_set_rgmii_delay(chip, port, mode);\n}\n\nint mv88e6390_port_set_rgmii_delay(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t   phy_interface_t mode)\n{\n\tif (port != 0)\n\t\treturn -EOPNOTSUPP;\n\n\treturn mv88e6xxx_port_set_rgmii_delay(chip, port, mode);\n}\n\nint mv88e6320_port_set_rgmii_delay(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t   phy_interface_t mode)\n{\n\tif (port != 2 && port != 5 && port != 6)\n\t\treturn -EOPNOTSUPP;\n\n\treturn mv88e6xxx_port_set_rgmii_delay(chip, port, mode);\n}\n\nint mv88e6xxx_port_set_link(struct mv88e6xxx_chip *chip, int port, int link)\n{\n\tu16 reg;\n\tint err;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_MAC_CTL, &reg);\n\tif (err)\n\t\treturn err;\n\n\treg &= ~(MV88E6XXX_PORT_MAC_CTL_FORCE_LINK |\n\t\t MV88E6XXX_PORT_MAC_CTL_LINK_UP);\n\n\tswitch (link) {\n\tcase LINK_FORCED_DOWN:\n\t\treg |= MV88E6XXX_PORT_MAC_CTL_FORCE_LINK;\n\t\tbreak;\n\tcase LINK_FORCED_UP:\n\t\treg |= MV88E6XXX_PORT_MAC_CTL_FORCE_LINK |\n\t\t\tMV88E6XXX_PORT_MAC_CTL_LINK_UP;\n\t\tbreak;\n\tcase LINK_UNFORCED:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\terr = mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_MAC_CTL, reg);\n\tif (err)\n\t\treturn err;\n\n\tdev_dbg(chip->dev, \"p%d: %s link %s\\n\", port,\n\t\treg & MV88E6XXX_PORT_MAC_CTL_FORCE_LINK ? \"Force\" : \"Unforce\",\n\t\treg & MV88E6XXX_PORT_MAC_CTL_LINK_UP ? \"up\" : \"down\");\n\n\treturn 0;\n}\n\nint mv88e6xxx_port_sync_link(struct mv88e6xxx_chip *chip, int port, unsigned int mode, bool isup)\n{\n\tconst struct mv88e6xxx_ops *ops = chip->info->ops;\n\tint err = 0;\n\tint link;\n\n\tif (isup)\n\t\tlink = LINK_FORCED_UP;\n\telse\n\t\tlink = LINK_FORCED_DOWN;\n\n\tif (ops->port_set_link)\n\t\terr = ops->port_set_link(chip, port, link);\n\n\treturn err;\n}\n\nint mv88e6185_port_sync_link(struct mv88e6xxx_chip *chip, int port, unsigned int mode, bool isup)\n{\n\tconst struct mv88e6xxx_ops *ops = chip->info->ops;\n\tint err = 0;\n\tint link;\n\n\tif (mode == MLO_AN_INBAND)\n\t\tlink = LINK_UNFORCED;\n\telse if (isup)\n\t\tlink = LINK_FORCED_UP;\n\telse\n\t\tlink = LINK_FORCED_DOWN;\n\n\tif (ops->port_set_link)\n\t\terr = ops->port_set_link(chip, port, link);\n\n\treturn err;\n}\n\nstatic int mv88e6xxx_port_set_speed_duplex(struct mv88e6xxx_chip *chip,\n\t\t\t\t\t   int port, int speed, bool alt_bit,\n\t\t\t\t\t   bool force_bit, int duplex)\n{\n\tu16 reg, ctrl;\n\tint err;\n\n\tswitch (speed) {\n\tcase 10:\n\t\tctrl = MV88E6XXX_PORT_MAC_CTL_SPEED_10;\n\t\tbreak;\n\tcase 100:\n\t\tctrl = MV88E6XXX_PORT_MAC_CTL_SPEED_100;\n\t\tbreak;\n\tcase 200:\n\t\tif (alt_bit)\n\t\t\tctrl = MV88E6XXX_PORT_MAC_CTL_SPEED_100 |\n\t\t\t\tMV88E6390_PORT_MAC_CTL_ALTSPEED;\n\t\telse\n\t\t\tctrl = MV88E6065_PORT_MAC_CTL_SPEED_200;\n\t\tbreak;\n\tcase 1000:\n\t\tctrl = MV88E6XXX_PORT_MAC_CTL_SPEED_1000;\n\t\tbreak;\n\tcase 2500:\n\t\tif (alt_bit)\n\t\t\tctrl = MV88E6390_PORT_MAC_CTL_SPEED_10000 |\n\t\t\t\tMV88E6390_PORT_MAC_CTL_ALTSPEED;\n\t\telse\n\t\t\tctrl = MV88E6390_PORT_MAC_CTL_SPEED_10000;\n\t\tbreak;\n\tcase 10000:\n\t\t \n\tcase SPEED_UNFORCED:\n\t\tctrl = MV88E6XXX_PORT_MAC_CTL_SPEED_UNFORCED;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (duplex) {\n\tcase DUPLEX_HALF:\n\t\tctrl |= MV88E6XXX_PORT_MAC_CTL_FORCE_DUPLEX;\n\t\tbreak;\n\tcase DUPLEX_FULL:\n\t\tctrl |= MV88E6XXX_PORT_MAC_CTL_FORCE_DUPLEX |\n\t\t\tMV88E6XXX_PORT_MAC_CTL_DUPLEX_FULL;\n\t\tbreak;\n\tcase DUPLEX_UNFORCED:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_MAC_CTL, &reg);\n\tif (err)\n\t\treturn err;\n\n\treg &= ~(MV88E6XXX_PORT_MAC_CTL_SPEED_MASK |\n\t\t MV88E6XXX_PORT_MAC_CTL_FORCE_DUPLEX |\n\t\t MV88E6XXX_PORT_MAC_CTL_DUPLEX_FULL);\n\n\tif (alt_bit)\n\t\treg &= ~MV88E6390_PORT_MAC_CTL_ALTSPEED;\n\tif (force_bit) {\n\t\treg &= ~MV88E6390_PORT_MAC_CTL_FORCE_SPEED;\n\t\tif (speed != SPEED_UNFORCED)\n\t\t\tctrl |= MV88E6390_PORT_MAC_CTL_FORCE_SPEED;\n\t}\n\treg |= ctrl;\n\n\terr = mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_MAC_CTL, reg);\n\tif (err)\n\t\treturn err;\n\n\tif (speed != SPEED_UNFORCED)\n\t\tdev_dbg(chip->dev, \"p%d: Speed set to %d Mbps\\n\", port, speed);\n\telse\n\t\tdev_dbg(chip->dev, \"p%d: Speed unforced\\n\", port);\n\tdev_dbg(chip->dev, \"p%d: %s %s duplex\\n\", port,\n\t\treg & MV88E6XXX_PORT_MAC_CTL_FORCE_DUPLEX ? \"Force\" : \"Unforce\",\n\t\treg & MV88E6XXX_PORT_MAC_CTL_DUPLEX_FULL ? \"full\" : \"half\");\n\n\treturn 0;\n}\n\n \nint mv88e6185_port_set_speed_duplex(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t    int speed, int duplex)\n{\n\tif (speed == 200 || speed > 1000)\n\t\treturn -EOPNOTSUPP;\n\n\treturn mv88e6xxx_port_set_speed_duplex(chip, port, speed, false, false,\n\t\t\t\t\t       duplex);\n}\n\n \nint mv88e6250_port_set_speed_duplex(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t    int speed, int duplex)\n{\n\tif (speed > 100)\n\t\treturn -EOPNOTSUPP;\n\n\treturn mv88e6xxx_port_set_speed_duplex(chip, port, speed, false, false,\n\t\t\t\t\t       duplex);\n}\n\n \nint mv88e6341_port_set_speed_duplex(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t    int speed, int duplex)\n{\n\tif (speed > 2500)\n\t\treturn -EOPNOTSUPP;\n\n\tif (speed == 200 && port != 0)\n\t\treturn -EOPNOTSUPP;\n\n\tif (speed == 2500 && port < 5)\n\t\treturn -EOPNOTSUPP;\n\n\treturn mv88e6xxx_port_set_speed_duplex(chip, port, speed, !port, true,\n\t\t\t\t\t       duplex);\n}\n\nphy_interface_t mv88e6341_port_max_speed_mode(struct mv88e6xxx_chip *chip,\n\t\t\t\t\t      int port)\n{\n\tif (port == 5)\n\t\treturn PHY_INTERFACE_MODE_2500BASEX;\n\n\treturn PHY_INTERFACE_MODE_NA;\n}\n\n \nint mv88e6352_port_set_speed_duplex(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t    int speed, int duplex)\n{\n\tif (speed > 1000)\n\t\treturn -EOPNOTSUPP;\n\n\tif (speed == 200 && port < 5)\n\t\treturn -EOPNOTSUPP;\n\n\treturn mv88e6xxx_port_set_speed_duplex(chip, port, speed, true, false,\n\t\t\t\t\t       duplex);\n}\n\n \nint mv88e6390_port_set_speed_duplex(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t    int speed, int duplex)\n{\n\tif (speed > 2500)\n\t\treturn -EOPNOTSUPP;\n\n\tif (speed == 200 && port != 0)\n\t\treturn -EOPNOTSUPP;\n\n\tif (speed == 2500 && port < 9)\n\t\treturn -EOPNOTSUPP;\n\n\treturn mv88e6xxx_port_set_speed_duplex(chip, port, speed, true, true,\n\t\t\t\t\t       duplex);\n}\n\nphy_interface_t mv88e6390_port_max_speed_mode(struct mv88e6xxx_chip *chip,\n\t\t\t\t\t      int port)\n{\n\tif (port == 9 || port == 10)\n\t\treturn PHY_INTERFACE_MODE_2500BASEX;\n\n\treturn PHY_INTERFACE_MODE_NA;\n}\n\n \nint mv88e6390x_port_set_speed_duplex(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t     int speed, int duplex)\n{\n\tif (speed == 200 && port != 0)\n\t\treturn -EOPNOTSUPP;\n\n\tif (speed >= 2500 && port < 9)\n\t\treturn -EOPNOTSUPP;\n\n\treturn mv88e6xxx_port_set_speed_duplex(chip, port, speed, true, true,\n\t\t\t\t\t       duplex);\n}\n\nphy_interface_t mv88e6390x_port_max_speed_mode(struct mv88e6xxx_chip *chip,\n\t\t\t\t\t       int port)\n{\n\tif (port == 9 || port == 10)\n\t\treturn PHY_INTERFACE_MODE_XAUI;\n\n\treturn PHY_INTERFACE_MODE_NA;\n}\n\n \nint mv88e6393x_port_set_speed_duplex(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t     int speed, int duplex)\n{\n\tu16 reg, ctrl;\n\tint err;\n\n\tif (chip->info->prod_num == MV88E6XXX_PORT_SWITCH_ID_PROD_6361 &&\n\t    speed > 2500)\n\t\treturn -EOPNOTSUPP;\n\n\tif (speed == 200 && port != 0)\n\t\treturn -EOPNOTSUPP;\n\n\tif (speed >= 2500 && port > 0 && port < 9)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (speed) {\n\tcase 10:\n\t\tctrl = MV88E6XXX_PORT_MAC_CTL_SPEED_10;\n\t\tbreak;\n\tcase 100:\n\t\tctrl = MV88E6XXX_PORT_MAC_CTL_SPEED_100;\n\t\tbreak;\n\tcase 200:\n\t\tctrl = MV88E6XXX_PORT_MAC_CTL_SPEED_100 |\n\t\t\tMV88E6390_PORT_MAC_CTL_ALTSPEED;\n\t\tbreak;\n\tcase 1000:\n\t\tctrl = MV88E6XXX_PORT_MAC_CTL_SPEED_1000;\n\t\tbreak;\n\tcase 2500:\n\t\tctrl = MV88E6XXX_PORT_MAC_CTL_SPEED_1000 |\n\t\t\tMV88E6390_PORT_MAC_CTL_ALTSPEED;\n\t\tbreak;\n\tcase 5000:\n\t\tctrl = MV88E6390_PORT_MAC_CTL_SPEED_10000 |\n\t\t\tMV88E6390_PORT_MAC_CTL_ALTSPEED;\n\t\tbreak;\n\tcase 10000:\n\tcase SPEED_UNFORCED:\n\t\tctrl = MV88E6XXX_PORT_MAC_CTL_SPEED_UNFORCED;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (duplex) {\n\tcase DUPLEX_HALF:\n\t\tctrl |= MV88E6XXX_PORT_MAC_CTL_FORCE_DUPLEX;\n\t\tbreak;\n\tcase DUPLEX_FULL:\n\t\tctrl |= MV88E6XXX_PORT_MAC_CTL_FORCE_DUPLEX |\n\t\t\tMV88E6XXX_PORT_MAC_CTL_DUPLEX_FULL;\n\t\tbreak;\n\tcase DUPLEX_UNFORCED:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_MAC_CTL, &reg);\n\tif (err)\n\t\treturn err;\n\n\treg &= ~(MV88E6XXX_PORT_MAC_CTL_SPEED_MASK |\n\t\t MV88E6390_PORT_MAC_CTL_ALTSPEED |\n\t\t MV88E6390_PORT_MAC_CTL_FORCE_SPEED);\n\n\tif (speed != SPEED_UNFORCED)\n\t\treg |= MV88E6390_PORT_MAC_CTL_FORCE_SPEED;\n\n\treg |= ctrl;\n\n\terr = mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_MAC_CTL, reg);\n\tif (err)\n\t\treturn err;\n\n\tif (speed != SPEED_UNFORCED)\n\t\tdev_dbg(chip->dev, \"p%d: Speed set to %d Mbps\\n\", port, speed);\n\telse\n\t\tdev_dbg(chip->dev, \"p%d: Speed unforced\\n\", port);\n\tdev_dbg(chip->dev, \"p%d: %s %s duplex\\n\", port,\n\t\treg & MV88E6XXX_PORT_MAC_CTL_FORCE_DUPLEX ? \"Force\" : \"Unforce\",\n\t\treg & MV88E6XXX_PORT_MAC_CTL_DUPLEX_FULL ? \"full\" : \"half\");\n\n\treturn 0;\n}\n\nphy_interface_t mv88e6393x_port_max_speed_mode(struct mv88e6xxx_chip *chip,\n\t\t\t\t\t       int port)\n{\n\n\tif (port != 0 && port != 9 && port != 10)\n\t\treturn PHY_INTERFACE_MODE_NA;\n\n\tif (chip->info->prod_num == MV88E6XXX_PORT_SWITCH_ID_PROD_6361)\n\t\treturn PHY_INTERFACE_MODE_2500BASEX;\n\n\treturn PHY_INTERFACE_MODE_10GBASER;\n}\n\nstatic int mv88e6xxx_port_set_cmode(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t    phy_interface_t mode, bool force)\n{\n\tu16 cmode;\n\tu16 reg;\n\tint err;\n\n\t \n\tif (mode == PHY_INTERFACE_MODE_NA)\n\t\tmode = PHY_INTERFACE_MODE_1000BASEX;\n\n\tswitch (mode) {\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tcmode = MV88E6XXX_PORT_STS_CMODE_RMII;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tcmode = MV88E6XXX_PORT_STS_CMODE_RGMII;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\t\tcmode = MV88E6XXX_PORT_STS_CMODE_1000BASEX;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_SGMII:\n\t\tcmode = MV88E6XXX_PORT_STS_CMODE_SGMII;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_2500BASEX:\n\t\tcmode = MV88E6XXX_PORT_STS_CMODE_2500BASEX;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_5GBASER:\n\t\tcmode = MV88E6393X_PORT_STS_CMODE_5GBASER;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_XGMII:\n\tcase PHY_INTERFACE_MODE_XAUI:\n\t\tcmode = MV88E6XXX_PORT_STS_CMODE_XAUI;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RXAUI:\n\t\tcmode = MV88E6XXX_PORT_STS_CMODE_RXAUI;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_10GBASER:\n\t\tcmode = MV88E6393X_PORT_STS_CMODE_10GBASER;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_USXGMII:\n\t\tcmode = MV88E6393X_PORT_STS_CMODE_USXGMII;\n\t\tbreak;\n\tdefault:\n\t\tcmode = 0;\n\t}\n\n\t \n\tif (cmode == chip->ports[port].cmode && !force)\n\t\treturn 0;\n\n\tchip->ports[port].cmode = 0;\n\n\tif (cmode) {\n\t\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_STS, &reg);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treg &= ~MV88E6XXX_PORT_STS_CMODE_MASK;\n\t\treg |= cmode;\n\n\t\terr = mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_STS, reg);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tchip->ports[port].cmode = cmode;\n\t}\n\n\treturn 0;\n}\n\nint mv88e6390x_port_set_cmode(struct mv88e6xxx_chip *chip, int port,\n\t\t\t      phy_interface_t mode)\n{\n\tif (port != 9 && port != 10)\n\t\treturn -EOPNOTSUPP;\n\n\treturn mv88e6xxx_port_set_cmode(chip, port, mode, false);\n}\n\nint mv88e6390_port_set_cmode(struct mv88e6xxx_chip *chip, int port,\n\t\t\t     phy_interface_t mode)\n{\n\tif (port != 9 && port != 10)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (mode) {\n\tcase PHY_INTERFACE_MODE_NA:\n\t\treturn 0;\n\tcase PHY_INTERFACE_MODE_XGMII:\n\tcase PHY_INTERFACE_MODE_XAUI:\n\tcase PHY_INTERFACE_MODE_RXAUI:\n\t\treturn -EINVAL;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn mv88e6xxx_port_set_cmode(chip, port, mode, false);\n}\n\nint mv88e6393x_port_set_cmode(struct mv88e6xxx_chip *chip, int port,\n\t\t\t      phy_interface_t mode)\n{\n\tint err;\n\tu16 reg;\n\n\tif (port != 0 && port != 9 && port != 10)\n\t\treturn -EOPNOTSUPP;\n\n\tif (port == 9 || port == 10) {\n\t\tswitch (mode) {\n\t\tcase PHY_INTERFACE_MODE_RMII:\n\t\tcase PHY_INTERFACE_MODE_RGMII:\n\t\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\t\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\t\treturn -EINVAL;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_MAC_CTL, &reg);\n\tif (err)\n\t\treturn err;\n\n\treg &= ~MV88E6XXX_PORT_MAC_CTL_EEE;\n\treg |= MV88E6XXX_PORT_MAC_CTL_FORCE_EEE;\n\terr = mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_MAC_CTL, reg);\n\tif (err)\n\t\treturn err;\n\n\treturn mv88e6xxx_port_set_cmode(chip, port, mode, false);\n}\n\nstatic int mv88e6341_port_set_cmode_writable(struct mv88e6xxx_chip *chip,\n\t\t\t\t\t     int port)\n{\n\tint err, addr;\n\tu16 reg, bits;\n\n\tif (port != 5)\n\t\treturn -EOPNOTSUPP;\n\n\taddr = chip->info->port_base_addr + port;\n\n\terr = mv88e6xxx_port_hidden_read(chip, 0x7, addr, 0, &reg);\n\tif (err)\n\t\treturn err;\n\n\tbits = MV88E6341_PORT_RESERVED_1A_FORCE_CMODE |\n\t       MV88E6341_PORT_RESERVED_1A_SGMII_AN;\n\n\tif ((reg & bits) == bits)\n\t\treturn 0;\n\n\treg |= bits;\n\treturn mv88e6xxx_port_hidden_write(chip, 0x7, addr, 0, reg);\n}\n\nint mv88e6341_port_set_cmode(struct mv88e6xxx_chip *chip, int port,\n\t\t\t     phy_interface_t mode)\n{\n\tint err;\n\n\tif (port != 5)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (mode) {\n\tcase PHY_INTERFACE_MODE_NA:\n\t\treturn 0;\n\tcase PHY_INTERFACE_MODE_XGMII:\n\tcase PHY_INTERFACE_MODE_XAUI:\n\tcase PHY_INTERFACE_MODE_RXAUI:\n\t\treturn -EINVAL;\n\tdefault:\n\t\tbreak;\n\t}\n\n\terr = mv88e6341_port_set_cmode_writable(chip, port);\n\tif (err)\n\t\treturn err;\n\n\treturn mv88e6xxx_port_set_cmode(chip, port, mode, true);\n}\n\nint mv88e6185_port_get_cmode(struct mv88e6xxx_chip *chip, int port, u8 *cmode)\n{\n\tint err;\n\tu16 reg;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_STS, &reg);\n\tif (err)\n\t\treturn err;\n\n\t*cmode = reg & MV88E6185_PORT_STS_CMODE_MASK;\n\n\treturn 0;\n}\n\nint mv88e6352_port_get_cmode(struct mv88e6xxx_chip *chip, int port, u8 *cmode)\n{\n\tint err;\n\tu16 reg;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_STS, &reg);\n\tif (err)\n\t\treturn err;\n\n\t*cmode = reg & MV88E6XXX_PORT_STS_CMODE_MASK;\n\n\treturn 0;\n}\n\n \nint mv88e6097_port_pause_limit(struct mv88e6xxx_chip *chip, int port, u8 in,\n\t\t\t       u8 out)\n{\n\treturn mv88e6xxx_port_write(chip, port, MV88E6097_PORT_JAM_CTL,\n\t\t\t\t    out << 8 | in);\n}\n\nint mv88e6390_port_pause_limit(struct mv88e6xxx_chip *chip, int port, u8 in,\n\t\t\t       u8 out)\n{\n\tint err;\n\n\terr = mv88e6xxx_port_write(chip, port, MV88E6390_PORT_FLOW_CTL,\n\t\t\t\t   MV88E6390_PORT_FLOW_CTL_UPDATE |\n\t\t\t\t   MV88E6390_PORT_FLOW_CTL_LIMIT_IN | in);\n\tif (err)\n\t\treturn err;\n\n\treturn mv88e6xxx_port_write(chip, port, MV88E6390_PORT_FLOW_CTL,\n\t\t\t\t    MV88E6390_PORT_FLOW_CTL_UPDATE |\n\t\t\t\t    MV88E6390_PORT_FLOW_CTL_LIMIT_OUT | out);\n}\n\n \n\nstatic const char * const mv88e6xxx_port_state_names[] = {\n\t[MV88E6XXX_PORT_CTL0_STATE_DISABLED] = \"Disabled\",\n\t[MV88E6XXX_PORT_CTL0_STATE_BLOCKING] = \"Blocking/Listening\",\n\t[MV88E6XXX_PORT_CTL0_STATE_LEARNING] = \"Learning\",\n\t[MV88E6XXX_PORT_CTL0_STATE_FORWARDING] = \"Forwarding\",\n};\n\nint mv88e6xxx_port_set_state(struct mv88e6xxx_chip *chip, int port, u8 state)\n{\n\tu16 reg;\n\tint err;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_CTL0, &reg);\n\tif (err)\n\t\treturn err;\n\n\treg &= ~MV88E6XXX_PORT_CTL0_STATE_MASK;\n\n\tswitch (state) {\n\tcase BR_STATE_DISABLED:\n\t\tstate = MV88E6XXX_PORT_CTL0_STATE_DISABLED;\n\t\tbreak;\n\tcase BR_STATE_BLOCKING:\n\tcase BR_STATE_LISTENING:\n\t\tstate = MV88E6XXX_PORT_CTL0_STATE_BLOCKING;\n\t\tbreak;\n\tcase BR_STATE_LEARNING:\n\t\tstate = MV88E6XXX_PORT_CTL0_STATE_LEARNING;\n\t\tbreak;\n\tcase BR_STATE_FORWARDING:\n\t\tstate = MV88E6XXX_PORT_CTL0_STATE_FORWARDING;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treg |= state;\n\n\terr = mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_CTL0, reg);\n\tif (err)\n\t\treturn err;\n\n\tdev_dbg(chip->dev, \"p%d: PortState set to %s\\n\", port,\n\t\tmv88e6xxx_port_state_names[state]);\n\n\treturn 0;\n}\n\nint mv88e6xxx_port_set_egress_mode(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t   enum mv88e6xxx_egress_mode mode)\n{\n\tint err;\n\tu16 reg;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_CTL0, &reg);\n\tif (err)\n\t\treturn err;\n\n\treg &= ~MV88E6XXX_PORT_CTL0_EGRESS_MODE_MASK;\n\n\tswitch (mode) {\n\tcase MV88E6XXX_EGRESS_MODE_UNMODIFIED:\n\t\treg |= MV88E6XXX_PORT_CTL0_EGRESS_MODE_UNMODIFIED;\n\t\tbreak;\n\tcase MV88E6XXX_EGRESS_MODE_UNTAGGED:\n\t\treg |= MV88E6XXX_PORT_CTL0_EGRESS_MODE_UNTAGGED;\n\t\tbreak;\n\tcase MV88E6XXX_EGRESS_MODE_TAGGED:\n\t\treg |= MV88E6XXX_PORT_CTL0_EGRESS_MODE_TAGGED;\n\t\tbreak;\n\tcase MV88E6XXX_EGRESS_MODE_ETHERTYPE:\n\t\treg |= MV88E6XXX_PORT_CTL0_EGRESS_MODE_ETHER_TYPE_DSA;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_CTL0, reg);\n}\n\nint mv88e6085_port_set_frame_mode(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t  enum mv88e6xxx_frame_mode mode)\n{\n\tint err;\n\tu16 reg;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_CTL0, &reg);\n\tif (err)\n\t\treturn err;\n\n\treg &= ~MV88E6XXX_PORT_CTL0_FRAME_MODE_MASK;\n\n\tswitch (mode) {\n\tcase MV88E6XXX_FRAME_MODE_NORMAL:\n\t\treg |= MV88E6XXX_PORT_CTL0_FRAME_MODE_NORMAL;\n\t\tbreak;\n\tcase MV88E6XXX_FRAME_MODE_DSA:\n\t\treg |= MV88E6XXX_PORT_CTL0_FRAME_MODE_DSA;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_CTL0, reg);\n}\n\nint mv88e6351_port_set_frame_mode(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t  enum mv88e6xxx_frame_mode mode)\n{\n\tint err;\n\tu16 reg;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_CTL0, &reg);\n\tif (err)\n\t\treturn err;\n\n\treg &= ~MV88E6XXX_PORT_CTL0_FRAME_MODE_MASK;\n\n\tswitch (mode) {\n\tcase MV88E6XXX_FRAME_MODE_NORMAL:\n\t\treg |= MV88E6XXX_PORT_CTL0_FRAME_MODE_NORMAL;\n\t\tbreak;\n\tcase MV88E6XXX_FRAME_MODE_DSA:\n\t\treg |= MV88E6XXX_PORT_CTL0_FRAME_MODE_DSA;\n\t\tbreak;\n\tcase MV88E6XXX_FRAME_MODE_PROVIDER:\n\t\treg |= MV88E6XXX_PORT_CTL0_FRAME_MODE_PROVIDER;\n\t\tbreak;\n\tcase MV88E6XXX_FRAME_MODE_ETHERTYPE:\n\t\treg |= MV88E6XXX_PORT_CTL0_FRAME_MODE_ETHER_TYPE_DSA;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_CTL0, reg);\n}\n\nint mv88e6185_port_set_forward_unknown(struct mv88e6xxx_chip *chip,\n\t\t\t\t       int port, bool unicast)\n{\n\tint err;\n\tu16 reg;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_CTL0, &reg);\n\tif (err)\n\t\treturn err;\n\n\tif (unicast)\n\t\treg |= MV88E6185_PORT_CTL0_FORWARD_UNKNOWN;\n\telse\n\t\treg &= ~MV88E6185_PORT_CTL0_FORWARD_UNKNOWN;\n\n\treturn mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_CTL0, reg);\n}\n\nint mv88e6352_port_set_ucast_flood(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t   bool unicast)\n{\n\tint err;\n\tu16 reg;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_CTL0, &reg);\n\tif (err)\n\t\treturn err;\n\n\tif (unicast)\n\t\treg |= MV88E6352_PORT_CTL0_EGRESS_FLOODS_UC;\n\telse\n\t\treg &= ~MV88E6352_PORT_CTL0_EGRESS_FLOODS_UC;\n\n\treturn mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_CTL0, reg);\n}\n\nint mv88e6352_port_set_mcast_flood(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t   bool multicast)\n{\n\tint err;\n\tu16 reg;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_CTL0, &reg);\n\tif (err)\n\t\treturn err;\n\n\tif (multicast)\n\t\treg |= MV88E6352_PORT_CTL0_EGRESS_FLOODS_MC;\n\telse\n\t\treg &= ~MV88E6352_PORT_CTL0_EGRESS_FLOODS_MC;\n\n\treturn mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_CTL0, reg);\n}\n\n \n\nint mv88e6xxx_port_set_message_port(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t    bool message_port)\n{\n\tu16 val;\n\tint err;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_CTL1, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (message_port)\n\t\tval |= MV88E6XXX_PORT_CTL1_MESSAGE_PORT;\n\telse\n\t\tval &= ~MV88E6XXX_PORT_CTL1_MESSAGE_PORT;\n\n\treturn mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_CTL1, val);\n}\n\nint mv88e6xxx_port_set_trunk(struct mv88e6xxx_chip *chip, int port,\n\t\t\t     bool trunk, u8 id)\n{\n\tu16 val;\n\tint err;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_CTL1, &val);\n\tif (err)\n\t\treturn err;\n\n\tval &= ~MV88E6XXX_PORT_CTL1_TRUNK_ID_MASK;\n\n\tif (trunk)\n\t\tval |= MV88E6XXX_PORT_CTL1_TRUNK_PORT |\n\t\t\t(id << MV88E6XXX_PORT_CTL1_TRUNK_ID_SHIFT);\n\telse\n\t\tval &= ~MV88E6XXX_PORT_CTL1_TRUNK_PORT;\n\n\treturn mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_CTL1, val);\n}\n\n \n\nint mv88e6xxx_port_set_vlan_map(struct mv88e6xxx_chip *chip, int port, u16 map)\n{\n\tconst u16 mask = mv88e6xxx_port_mask(chip);\n\tu16 reg;\n\tint err;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_BASE_VLAN, &reg);\n\tif (err)\n\t\treturn err;\n\n\treg &= ~mask;\n\treg |= map & mask;\n\n\terr = mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_BASE_VLAN, reg);\n\tif (err)\n\t\treturn err;\n\n\tdev_dbg(chip->dev, \"p%d: VLANTable set to %.3x\\n\", port, map);\n\n\treturn 0;\n}\n\nint mv88e6xxx_port_get_fid(struct mv88e6xxx_chip *chip, int port, u16 *fid)\n{\n\tconst u16 upper_mask = (mv88e6xxx_num_databases(chip) - 1) >> 4;\n\tu16 reg;\n\tint err;\n\n\t \n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_BASE_VLAN, &reg);\n\tif (err)\n\t\treturn err;\n\n\t*fid = (reg & 0xf000) >> 12;\n\n\t \n\tif (upper_mask) {\n\t\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_CTL1,\n\t\t\t\t\t  &reg);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t*fid |= (reg & upper_mask) << 4;\n\t}\n\n\treturn 0;\n}\n\nint mv88e6xxx_port_set_fid(struct mv88e6xxx_chip *chip, int port, u16 fid)\n{\n\tconst u16 upper_mask = (mv88e6xxx_num_databases(chip) - 1) >> 4;\n\tu16 reg;\n\tint err;\n\n\tif (fid >= mv88e6xxx_num_databases(chip))\n\t\treturn -EINVAL;\n\n\t \n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_BASE_VLAN, &reg);\n\tif (err)\n\t\treturn err;\n\n\treg &= 0x0fff;\n\treg |= (fid & 0x000f) << 12;\n\n\terr = mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_BASE_VLAN, reg);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (upper_mask) {\n\t\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_CTL1,\n\t\t\t\t\t  &reg);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treg &= ~upper_mask;\n\t\treg |= (fid >> 4) & upper_mask;\n\n\t\terr = mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_CTL1,\n\t\t\t\t\t   reg);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tdev_dbg(chip->dev, \"p%d: FID set to %u\\n\", port, fid);\n\n\treturn 0;\n}\n\n \n\nint mv88e6xxx_port_get_pvid(struct mv88e6xxx_chip *chip, int port, u16 *pvid)\n{\n\tu16 reg;\n\tint err;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_DEFAULT_VLAN,\n\t\t\t\t  &reg);\n\tif (err)\n\t\treturn err;\n\n\t*pvid = reg & MV88E6XXX_PORT_DEFAULT_VLAN_MASK;\n\n\treturn 0;\n}\n\nint mv88e6xxx_port_set_pvid(struct mv88e6xxx_chip *chip, int port, u16 pvid)\n{\n\tu16 reg;\n\tint err;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_DEFAULT_VLAN,\n\t\t\t\t  &reg);\n\tif (err)\n\t\treturn err;\n\n\treg &= ~MV88E6XXX_PORT_DEFAULT_VLAN_MASK;\n\treg |= pvid & MV88E6XXX_PORT_DEFAULT_VLAN_MASK;\n\n\terr = mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_DEFAULT_VLAN,\n\t\t\t\t   reg);\n\tif (err)\n\t\treturn err;\n\n\tdev_dbg(chip->dev, \"p%d: DefaultVID set to %u\\n\", port, pvid);\n\n\treturn 0;\n}\n\n \n\nstatic const char * const mv88e6xxx_port_8021q_mode_names[] = {\n\t[MV88E6XXX_PORT_CTL2_8021Q_MODE_DISABLED] = \"Disabled\",\n\t[MV88E6XXX_PORT_CTL2_8021Q_MODE_FALLBACK] = \"Fallback\",\n\t[MV88E6XXX_PORT_CTL2_8021Q_MODE_CHECK] = \"Check\",\n\t[MV88E6XXX_PORT_CTL2_8021Q_MODE_SECURE] = \"Secure\",\n};\n\nint mv88e6185_port_set_default_forward(struct mv88e6xxx_chip *chip,\n\t\t\t\t       int port, bool multicast)\n{\n\tint err;\n\tu16 reg;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_CTL2, &reg);\n\tif (err)\n\t\treturn err;\n\n\tif (multicast)\n\t\treg |= MV88E6XXX_PORT_CTL2_DEFAULT_FORWARD;\n\telse\n\t\treg &= ~MV88E6XXX_PORT_CTL2_DEFAULT_FORWARD;\n\n\treturn mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_CTL2, reg);\n}\n\nint mv88e6095_port_set_upstream_port(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t     int upstream_port)\n{\n\tint err;\n\tu16 reg;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_CTL2, &reg);\n\tif (err)\n\t\treturn err;\n\n\treg &= ~MV88E6095_PORT_CTL2_CPU_PORT_MASK;\n\treg |= upstream_port;\n\n\treturn mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_CTL2, reg);\n}\n\nint mv88e6xxx_port_set_mirror(struct mv88e6xxx_chip *chip, int port,\n\t\t\t      enum mv88e6xxx_egress_direction direction,\n\t\t\t      bool mirror)\n{\n\tbool *mirror_port;\n\tu16 reg;\n\tu16 bit;\n\tint err;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_CTL2, &reg);\n\tif (err)\n\t\treturn err;\n\n\tswitch (direction) {\n\tcase MV88E6XXX_EGRESS_DIR_INGRESS:\n\t\tbit = MV88E6XXX_PORT_CTL2_INGRESS_MONITOR;\n\t\tmirror_port = &chip->ports[port].mirror_ingress;\n\t\tbreak;\n\tcase MV88E6XXX_EGRESS_DIR_EGRESS:\n\t\tbit = MV88E6XXX_PORT_CTL2_EGRESS_MONITOR;\n\t\tmirror_port = &chip->ports[port].mirror_egress;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treg &= ~bit;\n\tif (mirror)\n\t\treg |= bit;\n\n\terr = mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_CTL2, reg);\n\tif (!err)\n\t\t*mirror_port = mirror;\n\n\treturn err;\n}\n\nint mv88e6xxx_port_set_lock(struct mv88e6xxx_chip *chip, int port,\n\t\t\t    bool locked)\n{\n\tu16 reg;\n\tint err;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_CTL0, &reg);\n\tif (err)\n\t\treturn err;\n\n\treg &= ~MV88E6XXX_PORT_CTL0_SA_FILT_MASK;\n\tif (locked)\n\t\treg |= MV88E6XXX_PORT_CTL0_SA_FILT_DROP_ON_LOCK;\n\n\terr = mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_CTL0, reg);\n\tif (err)\n\t\treturn err;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_ASSOC_VECTOR, &reg);\n\tif (err)\n\t\treturn err;\n\n\treg &= ~MV88E6XXX_PORT_ASSOC_VECTOR_LOCKED_PORT;\n\tif (locked)\n\t\treg |= MV88E6XXX_PORT_ASSOC_VECTOR_LOCKED_PORT;\n\n\treturn mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_ASSOC_VECTOR, reg);\n}\n\nint mv88e6xxx_port_set_8021q_mode(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t  u16 mode)\n{\n\tu16 reg;\n\tint err;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_CTL2, &reg);\n\tif (err)\n\t\treturn err;\n\n\treg &= ~MV88E6XXX_PORT_CTL2_8021Q_MODE_MASK;\n\treg |= mode & MV88E6XXX_PORT_CTL2_8021Q_MODE_MASK;\n\n\terr = mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_CTL2, reg);\n\tif (err)\n\t\treturn err;\n\n\tdev_dbg(chip->dev, \"p%d: 802.1QMode set to %s\\n\", port,\n\t\tmv88e6xxx_port_8021q_mode_names[mode]);\n\n\treturn 0;\n}\n\nint mv88e6xxx_port_drop_untagged(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t bool drop_untagged)\n{\n\tu16 old, new;\n\tint err;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_CTL2, &old);\n\tif (err)\n\t\treturn err;\n\n\tif (drop_untagged)\n\t\tnew = old | MV88E6XXX_PORT_CTL2_DISCARD_UNTAGGED;\n\telse\n\t\tnew = old & ~MV88E6XXX_PORT_CTL2_DISCARD_UNTAGGED;\n\n\tif (new == old)\n\t\treturn 0;\n\n\treturn mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_CTL2, new);\n}\n\nint mv88e6xxx_port_set_map_da(struct mv88e6xxx_chip *chip, int port, bool map)\n{\n\tu16 reg;\n\tint err;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_CTL2, &reg);\n\tif (err)\n\t\treturn err;\n\n\tif (map)\n\t\treg |= MV88E6XXX_PORT_CTL2_MAP_DA;\n\telse\n\t\treg &= ~MV88E6XXX_PORT_CTL2_MAP_DA;\n\n\treturn mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_CTL2, reg);\n}\n\nint mv88e6165_port_set_jumbo_size(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t  size_t size)\n{\n\tu16 reg;\n\tint err;\n\n\tsize += VLAN_ETH_HLEN + ETH_FCS_LEN;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_CTL2, &reg);\n\tif (err)\n\t\treturn err;\n\n\treg &= ~MV88E6XXX_PORT_CTL2_JUMBO_MODE_MASK;\n\n\tif (size <= 1522)\n\t\treg |= MV88E6XXX_PORT_CTL2_JUMBO_MODE_1522;\n\telse if (size <= 2048)\n\t\treg |= MV88E6XXX_PORT_CTL2_JUMBO_MODE_2048;\n\telse if (size <= 10240)\n\t\treg |= MV88E6XXX_PORT_CTL2_JUMBO_MODE_10240;\n\telse\n\t\treturn -ERANGE;\n\n\treturn mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_CTL2, reg);\n}\n\n \n\nint mv88e6095_port_egress_rate_limiting(struct mv88e6xxx_chip *chip, int port)\n{\n\treturn mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_EGRESS_RATE_CTL1,\n\t\t\t\t    0x0000);\n}\n\nint mv88e6097_port_egress_rate_limiting(struct mv88e6xxx_chip *chip, int port)\n{\n\treturn mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_EGRESS_RATE_CTL1,\n\t\t\t\t    0x0001);\n}\n\n \n\nint mv88e6xxx_port_set_assoc_vector(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t    u16 pav)\n{\n\tu16 reg, mask;\n\tint err;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_ASSOC_VECTOR,\n\t\t\t\t  &reg);\n\tif (err)\n\t\treturn err;\n\n\tmask = mv88e6xxx_port_mask(chip);\n\treg &= ~mask;\n\treg |= pav & mask;\n\n\treturn mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_ASSOC_VECTOR,\n\t\t\t\t    reg);\n}\n\n \n\nint mv88e6xxx_port_disable_learn_limit(struct mv88e6xxx_chip *chip, int port)\n{\n\treturn mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_ATU_CTL, 0);\n}\n\n \n\nint mv88e6xxx_port_disable_pri_override(struct mv88e6xxx_chip *chip, int port)\n{\n\treturn mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_PRI_OVERRIDE, 0);\n}\n\n \n\nstatic int mv88e6393x_port_policy_read(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t       u16 pointer, u8 *data)\n{\n\tu16 reg;\n\tint err;\n\n\terr = mv88e6xxx_port_write(chip, port, MV88E6393X_PORT_POLICY_MGMT_CTL,\n\t\t\t\t   pointer);\n\tif (err)\n\t\treturn err;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6393X_PORT_POLICY_MGMT_CTL,\n\t\t\t\t  &reg);\n\tif (err)\n\t\treturn err;\n\n\t*data = reg;\n\n\treturn 0;\n}\n\nstatic int mv88e6393x_port_policy_write(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t\tu16 pointer, u8 data)\n{\n\tu16 reg;\n\n\treg = MV88E6393X_PORT_POLICY_MGMT_CTL_UPDATE | pointer | data;\n\n\treturn mv88e6xxx_port_write(chip, port, MV88E6393X_PORT_POLICY_MGMT_CTL,\n\t\t\t\t    reg);\n}\n\nstatic int mv88e6393x_port_policy_write_all(struct mv88e6xxx_chip *chip,\n\t\t\t\t\t    u16 pointer, u8 data)\n{\n\tint err, port;\n\n\tfor (port = 0; port < mv88e6xxx_num_ports(chip); port++) {\n\t\tif (dsa_is_unused_port(chip->ds, port))\n\t\t\tcontinue;\n\n\t\terr = mv88e6393x_port_policy_write(chip, port, pointer, data);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nint mv88e6393x_set_egress_port(struct mv88e6xxx_chip *chip,\n\t\t\t       enum mv88e6xxx_egress_direction direction,\n\t\t\t       int port)\n{\n\tu16 ptr;\n\tint err;\n\n\tswitch (direction) {\n\tcase MV88E6XXX_EGRESS_DIR_INGRESS:\n\t\tptr = MV88E6393X_PORT_POLICY_MGMT_CTL_PTR_INGRESS_DEST;\n\t\terr = mv88e6393x_port_policy_write_all(chip, ptr, port);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase MV88E6XXX_EGRESS_DIR_EGRESS:\n\t\tptr = MV88E6393X_G2_EGRESS_MONITOR_DEST;\n\t\terr = mv88e6xxx_g2_write(chip, ptr, port);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint mv88e6393x_port_set_upstream_port(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t      int upstream_port)\n{\n\tu16 ptr = MV88E6393X_PORT_POLICY_MGMT_CTL_PTR_CPU_DEST;\n\tu8 data = MV88E6393X_PORT_POLICY_MGMT_CTL_CPU_DEST_MGMTPRI |\n\t\t  upstream_port;\n\n\treturn mv88e6393x_port_policy_write(chip, port, ptr, data);\n}\n\nint mv88e6393x_port_mgmt_rsvd2cpu(struct mv88e6xxx_chip *chip)\n{\n\tu16 ptr;\n\tint err;\n\n\t \n\tptr = MV88E6393X_PORT_POLICY_MGMT_CTL_PTR_01C280000000XLO;\n\terr = mv88e6393x_port_policy_write_all(chip, ptr, 0xff);\n\tif (err)\n\t\treturn err;\n\n\tptr = MV88E6393X_PORT_POLICY_MGMT_CTL_PTR_01C280000000XHI;\n\terr = mv88e6393x_port_policy_write_all(chip, ptr, 0xff);\n\tif (err)\n\t\treturn err;\n\n\tptr = MV88E6393X_PORT_POLICY_MGMT_CTL_PTR_01C280000002XLO;\n\terr = mv88e6393x_port_policy_write_all(chip, ptr, 0xff);\n\tif (err)\n\t\treturn err;\n\n\tptr = MV88E6393X_PORT_POLICY_MGMT_CTL_PTR_01C280000002XHI;\n\terr = mv88e6393x_port_policy_write_all(chip, ptr, 0xff);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n \n\nstatic int mv88e6393x_port_epc_wait_ready(struct mv88e6xxx_chip *chip, int port)\n{\n\tint bit = __bf_shf(MV88E6393X_PORT_EPC_CMD_BUSY);\n\n\treturn mv88e6xxx_port_wait_bit(chip, port, MV88E6393X_PORT_EPC_CMD, bit, 0);\n}\n\n \n\nint mv88e6393x_port_set_ether_type(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t   u16 etype)\n{\n\tu16 val;\n\tint err;\n\n\terr = mv88e6393x_port_epc_wait_ready(chip, port);\n\tif (err)\n\t\treturn err;\n\n\terr = mv88e6xxx_port_write(chip, port, MV88E6393X_PORT_EPC_DATA, etype);\n\tif (err)\n\t\treturn err;\n\n\tval = MV88E6393X_PORT_EPC_CMD_BUSY |\n\t      MV88E6393X_PORT_EPC_CMD_WRITE |\n\t      MV88E6393X_PORT_EPC_INDEX_PORT_ETYPE;\n\n\treturn mv88e6xxx_port_write(chip, port, MV88E6393X_PORT_EPC_CMD, val);\n}\n\n \n\nint mv88e6351_port_set_ether_type(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t  u16 etype)\n{\n\treturn mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_ETH_TYPE, etype);\n}\n\n \n\nint mv88e6095_port_tag_remap(struct mv88e6xxx_chip *chip, int port)\n{\n\tint err;\n\n\t \n\terr = mv88e6xxx_port_write(chip, port,\n\t\t\t\t   MV88E6095_PORT_IEEE_PRIO_REMAP_0123,\n\t\t\t\t   0x3210);\n\tif (err)\n\t\treturn err;\n\n\treturn mv88e6xxx_port_write(chip, port,\n\t\t\t\t    MV88E6095_PORT_IEEE_PRIO_REMAP_4567,\n\t\t\t\t    0x7654);\n}\n\nstatic int mv88e6xxx_port_ieeepmt_write(struct mv88e6xxx_chip *chip,\n\t\t\t\t\tint port, u16 table, u8 ptr, u16 data)\n{\n\tu16 reg;\n\n\treg = MV88E6390_PORT_IEEE_PRIO_MAP_TABLE_UPDATE | table |\n\t\t(ptr << __bf_shf(MV88E6390_PORT_IEEE_PRIO_MAP_TABLE_PTR_MASK)) |\n\t\t(data & MV88E6390_PORT_IEEE_PRIO_MAP_TABLE_DATA_MASK);\n\n\treturn mv88e6xxx_port_write(chip, port,\n\t\t\t\t    MV88E6390_PORT_IEEE_PRIO_MAP_TABLE, reg);\n}\n\nint mv88e6390_port_tag_remap(struct mv88e6xxx_chip *chip, int port)\n{\n\tint err, i;\n\tu16 table;\n\n\tfor (i = 0; i <= 7; i++) {\n\t\ttable = MV88E6390_PORT_IEEE_PRIO_MAP_TABLE_INGRESS_PCP;\n\t\terr = mv88e6xxx_port_ieeepmt_write(chip, port, table, i,\n\t\t\t\t\t\t   (i | i << 4));\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttable = MV88E6390_PORT_IEEE_PRIO_MAP_TABLE_EGRESS_GREEN_PCP;\n\t\terr = mv88e6xxx_port_ieeepmt_write(chip, port, table, i, i);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttable = MV88E6390_PORT_IEEE_PRIO_MAP_TABLE_EGRESS_YELLOW_PCP;\n\t\terr = mv88e6xxx_port_ieeepmt_write(chip, port, table, i, i);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttable = MV88E6390_PORT_IEEE_PRIO_MAP_TABLE_EGRESS_AVB_PCP;\n\t\terr = mv88e6xxx_port_ieeepmt_write(chip, port, table, i, i);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int\nmv88e6xxx_port_policy_mapping_get_pos(enum mv88e6xxx_policy_mapping mapping,\n\t\t\t\t      enum mv88e6xxx_policy_action action,\n\t\t\t\t      u16 *mask, u16 *val, int *shift)\n{\n\tswitch (mapping) {\n\tcase MV88E6XXX_POLICY_MAPPING_DA:\n\t\t*shift = __bf_shf(MV88E6XXX_PORT_POLICY_CTL_DA_MASK);\n\t\t*mask = MV88E6XXX_PORT_POLICY_CTL_DA_MASK;\n\t\tbreak;\n\tcase MV88E6XXX_POLICY_MAPPING_SA:\n\t\t*shift = __bf_shf(MV88E6XXX_PORT_POLICY_CTL_SA_MASK);\n\t\t*mask = MV88E6XXX_PORT_POLICY_CTL_SA_MASK;\n\t\tbreak;\n\tcase MV88E6XXX_POLICY_MAPPING_VTU:\n\t\t*shift = __bf_shf(MV88E6XXX_PORT_POLICY_CTL_VTU_MASK);\n\t\t*mask = MV88E6XXX_PORT_POLICY_CTL_VTU_MASK;\n\t\tbreak;\n\tcase MV88E6XXX_POLICY_MAPPING_ETYPE:\n\t\t*shift = __bf_shf(MV88E6XXX_PORT_POLICY_CTL_ETYPE_MASK);\n\t\t*mask = MV88E6XXX_PORT_POLICY_CTL_ETYPE_MASK;\n\t\tbreak;\n\tcase MV88E6XXX_POLICY_MAPPING_PPPOE:\n\t\t*shift = __bf_shf(MV88E6XXX_PORT_POLICY_CTL_PPPOE_MASK);\n\t\t*mask = MV88E6XXX_PORT_POLICY_CTL_PPPOE_MASK;\n\t\tbreak;\n\tcase MV88E6XXX_POLICY_MAPPING_VBAS:\n\t\t*shift = __bf_shf(MV88E6XXX_PORT_POLICY_CTL_VBAS_MASK);\n\t\t*mask = MV88E6XXX_PORT_POLICY_CTL_VBAS_MASK;\n\t\tbreak;\n\tcase MV88E6XXX_POLICY_MAPPING_OPT82:\n\t\t*shift = __bf_shf(MV88E6XXX_PORT_POLICY_CTL_OPT82_MASK);\n\t\t*mask = MV88E6XXX_PORT_POLICY_CTL_OPT82_MASK;\n\t\tbreak;\n\tcase MV88E6XXX_POLICY_MAPPING_UDP:\n\t\t*shift = __bf_shf(MV88E6XXX_PORT_POLICY_CTL_UDP_MASK);\n\t\t*mask = MV88E6XXX_PORT_POLICY_CTL_UDP_MASK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (action) {\n\tcase MV88E6XXX_POLICY_ACTION_NORMAL:\n\t\t*val = MV88E6XXX_PORT_POLICY_CTL_NORMAL;\n\t\tbreak;\n\tcase MV88E6XXX_POLICY_ACTION_MIRROR:\n\t\t*val = MV88E6XXX_PORT_POLICY_CTL_MIRROR;\n\t\tbreak;\n\tcase MV88E6XXX_POLICY_ACTION_TRAP:\n\t\t*val = MV88E6XXX_PORT_POLICY_CTL_TRAP;\n\t\tbreak;\n\tcase MV88E6XXX_POLICY_ACTION_DISCARD:\n\t\t*val = MV88E6XXX_PORT_POLICY_CTL_DISCARD;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nint mv88e6352_port_set_policy(struct mv88e6xxx_chip *chip, int port,\n\t\t\t      enum mv88e6xxx_policy_mapping mapping,\n\t\t\t      enum mv88e6xxx_policy_action action)\n{\n\tu16 reg, mask, val;\n\tint shift;\n\tint err;\n\n\terr = mv88e6xxx_port_policy_mapping_get_pos(mapping, action, &mask,\n\t\t\t\t\t\t    &val, &shift);\n\tif (err)\n\t\treturn err;\n\n\terr = mv88e6xxx_port_read(chip, port, MV88E6XXX_PORT_POLICY_CTL, &reg);\n\tif (err)\n\t\treturn err;\n\n\treg &= ~mask;\n\treg |= (val << shift) & mask;\n\n\treturn mv88e6xxx_port_write(chip, port, MV88E6XXX_PORT_POLICY_CTL, reg);\n}\n\nint mv88e6393x_port_set_policy(struct mv88e6xxx_chip *chip, int port,\n\t\t\t       enum mv88e6xxx_policy_mapping mapping,\n\t\t\t       enum mv88e6xxx_policy_action action)\n{\n\tu16 mask, val;\n\tint shift;\n\tint err;\n\tu16 ptr;\n\tu8 reg;\n\n\terr = mv88e6xxx_port_policy_mapping_get_pos(mapping, action, &mask,\n\t\t\t\t\t\t    &val, &shift);\n\tif (err)\n\t\treturn err;\n\n\t \n\tptr = shift / 8;\n\tshift %= 8;\n\tmask >>= ptr * 8;\n\n\terr = mv88e6393x_port_policy_read(chip, port, ptr, &reg);\n\tif (err)\n\t\treturn err;\n\n\treg &= ~mask;\n\treg |= (val << shift) & mask;\n\n\treturn mv88e6393x_port_policy_write(chip, port, ptr, reg);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}