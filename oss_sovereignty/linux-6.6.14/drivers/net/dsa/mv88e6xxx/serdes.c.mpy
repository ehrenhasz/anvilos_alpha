{
  "module_name": "serdes.c",
  "hash_id": "cb30995d8b7014129ffe7cb8dceb98286c65aee37da76ae3ef7f678d68bb68d0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/mv88e6xxx/serdes.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/irqdomain.h>\n#include <linux/mii.h>\n\n#include \"chip.h\"\n#include \"global2.h\"\n#include \"phy.h\"\n#include \"port.h\"\n#include \"serdes.h\"\n\nstatic int mv88e6352_serdes_read(struct mv88e6xxx_chip *chip, int reg,\n\t\t\t\t u16 *val)\n{\n\treturn mv88e6xxx_phy_page_read(chip, MV88E6352_ADDR_SERDES,\n\t\t\t\t       MV88E6352_SERDES_PAGE_FIBER,\n\t\t\t\t       reg, val);\n}\n\nstatic int mv88e6352_serdes_write(struct mv88e6xxx_chip *chip, int reg,\n\t\t\t\t  u16 val)\n{\n\treturn mv88e6xxx_phy_page_write(chip, MV88E6352_ADDR_SERDES,\n\t\t\t\t\tMV88E6352_SERDES_PAGE_FIBER,\n\t\t\t\t\treg, val);\n}\n\nstatic int mv88e6390_serdes_read(struct mv88e6xxx_chip *chip,\n\t\t\t\t int lane, int device, int reg, u16 *val)\n{\n\treturn mv88e6xxx_phy_read_c45(chip, lane, device, reg, val);\n}\n\nint mv88e6xxx_pcs_decode_state(struct device *dev, u16 bmsr, u16 lpa,\n\t\t\t       u16 status, struct phylink_link_state *state)\n{\n\tstate->link = false;\n\n\t \n\tif (!(bmsr & BMSR_LSTATUS))\n\t\treturn 0;\n\n\tstate->link = !!(status & MV88E6390_SGMII_PHY_STATUS_LINK);\n\tstate->an_complete = !!(bmsr & BMSR_ANEGCOMPLETE);\n\n\tif (status & MV88E6390_SGMII_PHY_STATUS_SPD_DPL_VALID) {\n\t\t \n\t\tstate->duplex = status &\n\t\t\t\tMV88E6390_SGMII_PHY_STATUS_DUPLEX_FULL ?\n\t\t\t                         DUPLEX_FULL : DUPLEX_HALF;\n\n\t\tif (status & MV88E6390_SGMII_PHY_STATUS_TX_PAUSE)\n\t\t\tstate->pause |= MLO_PAUSE_TX;\n\t\tif (status & MV88E6390_SGMII_PHY_STATUS_RX_PAUSE)\n\t\t\tstate->pause |= MLO_PAUSE_RX;\n\n\t\tswitch (status & MV88E6390_SGMII_PHY_STATUS_SPEED_MASK) {\n\t\tcase MV88E6390_SGMII_PHY_STATUS_SPEED_1000:\n\t\t\tif (state->interface == PHY_INTERFACE_MODE_2500BASEX)\n\t\t\t\tstate->speed = SPEED_2500;\n\t\t\telse\n\t\t\t\tstate->speed = SPEED_1000;\n\t\t\tbreak;\n\t\tcase MV88E6390_SGMII_PHY_STATUS_SPEED_100:\n\t\t\tstate->speed = SPEED_100;\n\t\t\tbreak;\n\t\tcase MV88E6390_SGMII_PHY_STATUS_SPEED_10:\n\t\t\tstate->speed = SPEED_10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"invalid PHY speed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (state->link &&\n\t\t   state->interface != PHY_INTERFACE_MODE_SGMII) {\n\t\t \n\t\tstate->duplex = DUPLEX_FULL;\n\t\tif (state->interface == PHY_INTERFACE_MODE_2500BASEX)\n\t\t\tstate->speed = SPEED_2500;\n\t\telse\n\t\t\tstate->speed = SPEED_1000;\n\t} else {\n\t\tstate->link = false;\n\t}\n\n\tif (state->interface == PHY_INTERFACE_MODE_2500BASEX)\n\t\tmii_lpa_mod_linkmode_x(state->lp_advertising, lpa,\n\t\t\t\t       ETHTOOL_LINK_MODE_2500baseX_Full_BIT);\n\telse if (state->interface == PHY_INTERFACE_MODE_1000BASEX)\n\t\tmii_lpa_mod_linkmode_x(state->lp_advertising, lpa,\n\t\t\t\t       ETHTOOL_LINK_MODE_1000baseX_Full_BIT);\n\n\treturn 0;\n}\n\nstruct mv88e6352_serdes_hw_stat {\n\tchar string[ETH_GSTRING_LEN];\n\tint sizeof_stat;\n\tint reg;\n};\n\nstatic struct mv88e6352_serdes_hw_stat mv88e6352_serdes_hw_stats[] = {\n\t{ \"serdes_fibre_rx_error\", 16, 21 },\n\t{ \"serdes_PRBS_error\", 32, 24 },\n};\n\nint mv88e6352_serdes_get_sset_count(struct mv88e6xxx_chip *chip, int port)\n{\n\tint err;\n\n\terr = mv88e6352_g2_scratch_port_has_serdes(chip, port);\n\tif (err <= 0)\n\t\treturn err;\n\n\treturn ARRAY_SIZE(mv88e6352_serdes_hw_stats);\n}\n\nint mv88e6352_serdes_get_strings(struct mv88e6xxx_chip *chip,\n\t\t\t\t int port, uint8_t *data)\n{\n\tstruct mv88e6352_serdes_hw_stat *stat;\n\tint err, i;\n\n\terr = mv88e6352_g2_scratch_port_has_serdes(chip, port);\n\tif (err <= 0)\n\t\treturn err;\n\n\tfor (i = 0; i < ARRAY_SIZE(mv88e6352_serdes_hw_stats); i++) {\n\t\tstat = &mv88e6352_serdes_hw_stats[i];\n\t\tmemcpy(data + i * ETH_GSTRING_LEN, stat->string,\n\t\t       ETH_GSTRING_LEN);\n\t}\n\treturn ARRAY_SIZE(mv88e6352_serdes_hw_stats);\n}\n\nstatic uint64_t mv88e6352_serdes_get_stat(struct mv88e6xxx_chip *chip,\n\t\t\t\t\t  struct mv88e6352_serdes_hw_stat *stat)\n{\n\tu64 val = 0;\n\tu16 reg;\n\tint err;\n\n\terr = mv88e6352_serdes_read(chip, stat->reg, &reg);\n\tif (err) {\n\t\tdev_err(chip->dev, \"failed to read statistic\\n\");\n\t\treturn 0;\n\t}\n\n\tval = reg;\n\n\tif (stat->sizeof_stat == 32) {\n\t\terr = mv88e6352_serdes_read(chip, stat->reg + 1, &reg);\n\t\tif (err) {\n\t\t\tdev_err(chip->dev, \"failed to read statistic\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tval = val << 16 | reg;\n\t}\n\n\treturn val;\n}\n\nint mv88e6352_serdes_get_stats(struct mv88e6xxx_chip *chip, int port,\n\t\t\t       uint64_t *data)\n{\n\tstruct mv88e6xxx_port *mv88e6xxx_port = &chip->ports[port];\n\tstruct mv88e6352_serdes_hw_stat *stat;\n\tint i, err;\n\tu64 value;\n\n\terr = mv88e6352_g2_scratch_port_has_serdes(chip, port);\n\tif (err <= 0)\n\t\treturn err;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(mv88e6352_serdes_hw_stats) >\n\t\t     ARRAY_SIZE(mv88e6xxx_port->serdes_stats));\n\n\tfor (i = 0; i < ARRAY_SIZE(mv88e6352_serdes_hw_stats); i++) {\n\t\tstat = &mv88e6352_serdes_hw_stats[i];\n\t\tvalue = mv88e6352_serdes_get_stat(chip, stat);\n\t\tmv88e6xxx_port->serdes_stats[i] += value;\n\t\tdata[i] = mv88e6xxx_port->serdes_stats[i];\n\t}\n\n\treturn ARRAY_SIZE(mv88e6352_serdes_hw_stats);\n}\n\nunsigned int mv88e6352_serdes_irq_mapping(struct mv88e6xxx_chip *chip, int port)\n{\n\treturn irq_find_mapping(chip->g2_irq.domain, MV88E6352_SERDES_IRQ);\n}\n\nint mv88e6352_serdes_get_regs_len(struct mv88e6xxx_chip *chip, int port)\n{\n\tint err;\n\n\tmv88e6xxx_reg_lock(chip);\n\terr = mv88e6352_g2_scratch_port_has_serdes(chip, port);\n\tmv88e6xxx_reg_unlock(chip);\n\tif (err <= 0)\n\t\treturn err;\n\n\treturn 32 * sizeof(u16);\n}\n\nvoid mv88e6352_serdes_get_regs(struct mv88e6xxx_chip *chip, int port, void *_p)\n{\n\tu16 *p = _p;\n\tu16 reg;\n\tint err;\n\tint i;\n\n\terr = mv88e6352_g2_scratch_port_has_serdes(chip, port);\n\tif (err <= 0)\n\t\treturn;\n\n\tfor (i = 0 ; i < 32; i++) {\n\t\terr = mv88e6352_serdes_read(chip, i, &reg);\n\t\tif (!err)\n\t\t\tp[i] = reg;\n\t}\n}\n\nint mv88e6341_serdes_get_lane(struct mv88e6xxx_chip *chip, int port)\n{\n\tu8 cmode = chip->ports[port].cmode;\n\tint lane = -ENODEV;\n\n\tswitch (port) {\n\tcase 5:\n\t\tif (cmode == MV88E6XXX_PORT_STS_CMODE_1000BASEX ||\n\t\t    cmode == MV88E6XXX_PORT_STS_CMODE_SGMII ||\n\t\t    cmode == MV88E6XXX_PORT_STS_CMODE_2500BASEX)\n\t\t\tlane = MV88E6341_PORT5_LANE;\n\t\tbreak;\n\t}\n\n\treturn lane;\n}\n\nint mv88e6390_serdes_get_lane(struct mv88e6xxx_chip *chip, int port)\n{\n\tu8 cmode = chip->ports[port].cmode;\n\tint lane = -ENODEV;\n\n\tswitch (port) {\n\tcase 9:\n\t\tif (cmode == MV88E6XXX_PORT_STS_CMODE_1000BASEX ||\n\t\t    cmode == MV88E6XXX_PORT_STS_CMODE_SGMII ||\n\t\t    cmode == MV88E6XXX_PORT_STS_CMODE_2500BASEX)\n\t\t\tlane = MV88E6390_PORT9_LANE0;\n\t\tbreak;\n\tcase 10:\n\t\tif (cmode == MV88E6XXX_PORT_STS_CMODE_1000BASEX ||\n\t\t    cmode == MV88E6XXX_PORT_STS_CMODE_SGMII ||\n\t\t    cmode == MV88E6XXX_PORT_STS_CMODE_2500BASEX)\n\t\t\tlane = MV88E6390_PORT10_LANE0;\n\t\tbreak;\n\t}\n\n\treturn lane;\n}\n\nint mv88e6390x_serdes_get_lane(struct mv88e6xxx_chip *chip, int port)\n{\n\tu8 cmode_port = chip->ports[port].cmode;\n\tu8 cmode_port10 = chip->ports[10].cmode;\n\tu8 cmode_port9 = chip->ports[9].cmode;\n\tint lane = -ENODEV;\n\n\tswitch (port) {\n\tcase 2:\n\t\tif (cmode_port9 == MV88E6XXX_PORT_STS_CMODE_1000BASEX ||\n\t\t    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_SGMII ||\n\t\t    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_2500BASEX)\n\t\t\tif (cmode_port == MV88E6XXX_PORT_STS_CMODE_1000BASEX)\n\t\t\t\tlane = MV88E6390_PORT9_LANE1;\n\t\tbreak;\n\tcase 3:\n\t\tif (cmode_port9 == MV88E6XXX_PORT_STS_CMODE_1000BASEX ||\n\t\t    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_SGMII ||\n\t\t    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_2500BASEX ||\n\t\t    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_RXAUI)\n\t\t\tif (cmode_port == MV88E6XXX_PORT_STS_CMODE_1000BASEX)\n\t\t\t\tlane = MV88E6390_PORT9_LANE2;\n\t\tbreak;\n\tcase 4:\n\t\tif (cmode_port9 == MV88E6XXX_PORT_STS_CMODE_1000BASEX ||\n\t\t    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_SGMII ||\n\t\t    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_2500BASEX ||\n\t\t    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_RXAUI)\n\t\t\tif (cmode_port == MV88E6XXX_PORT_STS_CMODE_1000BASEX)\n\t\t\t\tlane = MV88E6390_PORT9_LANE3;\n\t\tbreak;\n\tcase 5:\n\t\tif (cmode_port10 == MV88E6XXX_PORT_STS_CMODE_1000BASEX ||\n\t\t    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_SGMII ||\n\t\t    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_2500BASEX)\n\t\t\tif (cmode_port == MV88E6XXX_PORT_STS_CMODE_1000BASEX)\n\t\t\t\tlane = MV88E6390_PORT10_LANE1;\n\t\tbreak;\n\tcase 6:\n\t\tif (cmode_port10 == MV88E6XXX_PORT_STS_CMODE_1000BASEX ||\n\t\t    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_SGMII ||\n\t\t    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_2500BASEX ||\n\t\t    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_RXAUI)\n\t\t\tif (cmode_port == MV88E6XXX_PORT_STS_CMODE_1000BASEX)\n\t\t\t\tlane = MV88E6390_PORT10_LANE2;\n\t\tbreak;\n\tcase 7:\n\t\tif (cmode_port10 == MV88E6XXX_PORT_STS_CMODE_1000BASEX ||\n\t\t    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_SGMII ||\n\t\t    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_2500BASEX ||\n\t\t    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_RXAUI)\n\t\t\tif (cmode_port == MV88E6XXX_PORT_STS_CMODE_1000BASEX)\n\t\t\t\tlane = MV88E6390_PORT10_LANE3;\n\t\tbreak;\n\tcase 9:\n\t\tif (cmode_port9 == MV88E6XXX_PORT_STS_CMODE_1000BASEX ||\n\t\t    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_SGMII ||\n\t\t    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_2500BASEX ||\n\t\t    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_XAUI ||\n\t\t    cmode_port9 == MV88E6XXX_PORT_STS_CMODE_RXAUI)\n\t\t\tlane = MV88E6390_PORT9_LANE0;\n\t\tbreak;\n\tcase 10:\n\t\tif (cmode_port10 == MV88E6XXX_PORT_STS_CMODE_1000BASEX ||\n\t\t    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_SGMII ||\n\t\t    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_2500BASEX ||\n\t\t    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_XAUI ||\n\t\t    cmode_port10 == MV88E6XXX_PORT_STS_CMODE_RXAUI)\n\t\t\tlane = MV88E6390_PORT10_LANE0;\n\t\tbreak;\n\t}\n\n\treturn lane;\n}\n\n \nint mv88e6393x_serdes_get_lane(struct mv88e6xxx_chip *chip, int port)\n{\n\tu8 cmode = chip->ports[port].cmode;\n\tint lane = -ENODEV;\n\n\tif (port != 0 && port != 9 && port != 10)\n\t\treturn -EOPNOTSUPP;\n\n\tif (cmode == MV88E6XXX_PORT_STS_CMODE_1000BASEX ||\n\t    cmode == MV88E6XXX_PORT_STS_CMODE_SGMII ||\n\t    cmode == MV88E6XXX_PORT_STS_CMODE_2500BASEX ||\n\t    cmode == MV88E6393X_PORT_STS_CMODE_5GBASER ||\n\t    cmode == MV88E6393X_PORT_STS_CMODE_10GBASER ||\n\t    cmode == MV88E6393X_PORT_STS_CMODE_USXGMII)\n\t\tlane = port;\n\n\treturn lane;\n}\n\nstruct mv88e6390_serdes_hw_stat {\n\tchar string[ETH_GSTRING_LEN];\n\tint reg;\n};\n\nstatic struct mv88e6390_serdes_hw_stat mv88e6390_serdes_hw_stats[] = {\n\t{ \"serdes_rx_pkts\", 0xf021 },\n\t{ \"serdes_rx_bytes\", 0xf024 },\n\t{ \"serdes_rx_pkts_error\", 0xf027 },\n};\n\nint mv88e6390_serdes_get_sset_count(struct mv88e6xxx_chip *chip, int port)\n{\n\tif (mv88e6xxx_serdes_get_lane(chip, port) < 0)\n\t\treturn 0;\n\n\treturn ARRAY_SIZE(mv88e6390_serdes_hw_stats);\n}\n\nint mv88e6390_serdes_get_strings(struct mv88e6xxx_chip *chip,\n\t\t\t\t int port, uint8_t *data)\n{\n\tstruct mv88e6390_serdes_hw_stat *stat;\n\tint i;\n\n\tif (mv88e6xxx_serdes_get_lane(chip, port) < 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(mv88e6390_serdes_hw_stats); i++) {\n\t\tstat = &mv88e6390_serdes_hw_stats[i];\n\t\tmemcpy(data + i * ETH_GSTRING_LEN, stat->string,\n\t\t       ETH_GSTRING_LEN);\n\t}\n\treturn ARRAY_SIZE(mv88e6390_serdes_hw_stats);\n}\n\nstatic uint64_t mv88e6390_serdes_get_stat(struct mv88e6xxx_chip *chip, int lane,\n\t\t\t\t\t  struct mv88e6390_serdes_hw_stat *stat)\n{\n\tu16 reg[3];\n\tint err, i;\n\n\tfor (i = 0; i < 3; i++) {\n\t\terr = mv88e6390_serdes_read(chip, lane, MDIO_MMD_PHYXS,\n\t\t\t\t\t    stat->reg + i, &reg[i]);\n\t\tif (err) {\n\t\t\tdev_err(chip->dev, \"failed to read statistic\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn reg[0] | ((u64)reg[1] << 16) | ((u64)reg[2] << 32);\n}\n\nint mv88e6390_serdes_get_stats(struct mv88e6xxx_chip *chip, int port,\n\t\t\t       uint64_t *data)\n{\n\tstruct mv88e6390_serdes_hw_stat *stat;\n\tint lane;\n\tint i;\n\n\tlane = mv88e6xxx_serdes_get_lane(chip, port);\n\tif (lane < 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(mv88e6390_serdes_hw_stats); i++) {\n\t\tstat = &mv88e6390_serdes_hw_stats[i];\n\t\tdata[i] = mv88e6390_serdes_get_stat(chip, lane, stat);\n\t}\n\n\treturn ARRAY_SIZE(mv88e6390_serdes_hw_stats);\n}\n\nunsigned int mv88e6390_serdes_irq_mapping(struct mv88e6xxx_chip *chip, int port)\n{\n\treturn irq_find_mapping(chip->g2_irq.domain, port);\n}\n\nstatic const u16 mv88e6390_serdes_regs[] = {\n\t \n\t0xf00a, 0xf00b, 0xf00c,\n\t0xf010, 0xf011, 0xf012, 0xf013,\n\t0xf016, 0xf017, 0xf018,\n\t0xf01b, 0xf01c, 0xf01d, 0xf01e, 0xf01f,\n\t0xf020, 0xf021, 0xf022, 0xf023, 0xf024, 0xf025, 0xf026, 0xf027,\n\t0xf028, 0xf029,\n\t0xf030, 0xf031, 0xf032, 0xf033, 0xf034, 0xf035, 0xf036, 0xf037,\n\t0xf038, 0xf039,\n\t \n\t0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007,\n\t0x2008,\n\t0x200f,\n\t0xa000, 0xa001, 0xa002, 0xa003,\n\t \n\t0x1000, 0x1001, 0x1002, 0x1003, 0x1004, 0x1005, 0x1006, 0x1007,\n\t0x1008,\n\t0x100e, 0x100f,\n\t0x1018, 0x1019,\n\t0x9000, 0x9001, 0x9002, 0x9003, 0x9004,\n\t0x9006,\n\t0x9010, 0x9011, 0x9012, 0x9013, 0x9014, 0x9015, 0x9016,\n\t \n\t0x1020, 0x1021, 0x1022, 0x1023, 0x1024, 0x1025, 0x1026, 0x1027,\n\t0x1028, 0x1029, 0x102a, 0x102b,\n};\n\nint mv88e6390_serdes_get_regs_len(struct mv88e6xxx_chip *chip, int port)\n{\n\tif (mv88e6xxx_serdes_get_lane(chip, port) < 0)\n\t\treturn 0;\n\n\treturn ARRAY_SIZE(mv88e6390_serdes_regs) * sizeof(u16);\n}\n\nvoid mv88e6390_serdes_get_regs(struct mv88e6xxx_chip *chip, int port, void *_p)\n{\n\tu16 *p = _p;\n\tint lane;\n\tu16 reg;\n\tint err;\n\tint i;\n\n\tlane = mv88e6xxx_serdes_get_lane(chip, port);\n\tif (lane < 0)\n\t\treturn;\n\n\tfor (i = 0 ; i < ARRAY_SIZE(mv88e6390_serdes_regs); i++) {\n\t\terr = mv88e6390_serdes_read(chip, lane, MDIO_MMD_PHYXS,\n\t\t\t\t\t    mv88e6390_serdes_regs[i], &reg);\n\t\tif (!err)\n\t\t\tp[i] = reg;\n\t}\n}\n\nstatic const int mv88e6352_serdes_p2p_to_reg[] = {\n\t \n\t14000, 112000, 210000, 308000, 406000, 504000, 602000, 700000,\n};\n\nint mv88e6352_serdes_set_tx_amplitude(struct mv88e6xxx_chip *chip, int port,\n\t\t\t\t      int val)\n{\n\tbool found = false;\n\tu16 ctrl, reg;\n\tint err;\n\tint i;\n\n\terr = mv88e6352_g2_scratch_port_has_serdes(chip, port);\n\tif (err <= 0)\n\t\treturn err;\n\n\tfor (i = 0; i < ARRAY_SIZE(mv88e6352_serdes_p2p_to_reg); ++i) {\n\t\tif (mv88e6352_serdes_p2p_to_reg[i] == val) {\n\t\t\treg = i;\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found)\n\t\treturn -EINVAL;\n\n\terr = mv88e6352_serdes_read(chip, MV88E6352_SERDES_SPEC_CTRL2, &ctrl);\n\tif (err)\n\t\treturn err;\n\n\tctrl &= ~MV88E6352_SERDES_OUT_AMP_MASK;\n\tctrl |= reg;\n\n\treturn mv88e6352_serdes_write(chip, MV88E6352_SERDES_SPEC_CTRL2, ctrl);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}