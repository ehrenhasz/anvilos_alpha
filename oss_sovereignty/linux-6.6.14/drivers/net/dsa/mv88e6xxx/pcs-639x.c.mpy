{
  "module_name": "pcs-639x.c",
  "hash_id": "484559d1b68f1b132f09935887855e07ab869008e6b34eeee3f2aa84c2466780",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/mv88e6xxx/pcs-639x.c",
  "human_readable_source": "\n \n#include <linux/interrupt.h>\n#include <linux/irqdomain.h>\n#include <linux/mii.h>\n\n#include \"chip.h\"\n#include \"global2.h\"\n#include \"phy.h\"\n#include \"port.h\"\n#include \"serdes.h\"\n\nstruct mv88e639x_pcs {\n\tstruct mdio_device mdio;\n\tstruct phylink_pcs sgmii_pcs;\n\tstruct phylink_pcs xg_pcs;\n\tbool erratum_3_14;\n\tbool supports_5g;\n\tphy_interface_t interface;\n\tunsigned int irq;\n\tchar name[64];\n\tirqreturn_t (*handle_irq)(struct mv88e639x_pcs *mpcs);\n};\n\nstatic int mv88e639x_read(struct mv88e639x_pcs *mpcs, u16 regnum, u16 *val)\n{\n\tint err;\n\n\terr = mdiodev_c45_read(&mpcs->mdio, MDIO_MMD_PHYXS, regnum);\n\tif (err < 0)\n\t\treturn err;\n\n\t*val = err;\n\n\treturn 0;\n}\n\nstatic int mv88e639x_write(struct mv88e639x_pcs *mpcs, u16 regnum, u16 val)\n{\n\treturn mdiodev_c45_write(&mpcs->mdio, MDIO_MMD_PHYXS, regnum, val);\n}\n\nstatic int mv88e639x_modify(struct mv88e639x_pcs *mpcs, u16 regnum, u16 mask,\n\t\t\t    u16 val)\n{\n\treturn mdiodev_c45_modify(&mpcs->mdio, MDIO_MMD_PHYXS, regnum, mask,\n\t\t\t\t  val);\n}\n\nstatic int mv88e639x_modify_changed(struct mv88e639x_pcs *mpcs, u16 regnum,\n\t\t\t\t    u16 mask, u16 set)\n{\n\treturn mdiodev_c45_modify_changed(&mpcs->mdio, MDIO_MMD_PHYXS, regnum,\n\t\t\t\t\t  mask, set);\n}\n\nstatic struct mv88e639x_pcs *\nmv88e639x_pcs_alloc(struct device *dev, struct mii_bus *bus, unsigned int addr,\n\t\t    int port)\n{\n\tstruct mv88e639x_pcs *mpcs;\n\n\tmpcs = kzalloc(sizeof(*mpcs), GFP_KERNEL);\n\tif (!mpcs)\n\t\treturn NULL;\n\n\tmpcs->mdio.dev.parent = dev;\n\tmpcs->mdio.bus = bus;\n\tmpcs->mdio.addr = addr;\n\n\tsnprintf(mpcs->name, sizeof(mpcs->name),\n\t\t \"mv88e6xxx-%s-serdes-%d\", dev_name(dev), port);\n\n\treturn mpcs;\n}\n\nstatic irqreturn_t mv88e639x_pcs_handle_irq(int irq, void *dev_id)\n{\n\tstruct mv88e639x_pcs *mpcs = dev_id;\n\tirqreturn_t (*handler)(struct mv88e639x_pcs *);\n\n\thandler = READ_ONCE(mpcs->handle_irq);\n\tif (!handler)\n\t\treturn IRQ_NONE;\n\n\treturn handler(mpcs);\n}\n\nstatic int mv88e639x_pcs_setup_irq(struct mv88e639x_pcs *mpcs,\n\t\t\t\t   struct mv88e6xxx_chip *chip, int port)\n{\n\tunsigned int irq;\n\n\tirq = mv88e6xxx_serdes_irq_mapping(chip, port);\n\tif (!irq) {\n\t\t \n\t\tmpcs->sgmii_pcs.poll = true;\n\t\tmpcs->xg_pcs.poll = true;\n\t\treturn 0;\n\t}\n\n\tmpcs->irq = irq;\n\n\treturn request_threaded_irq(irq, NULL, mv88e639x_pcs_handle_irq,\n\t\t\t\t    IRQF_ONESHOT, mpcs->name, mpcs);\n}\n\nstatic void mv88e639x_pcs_teardown(struct mv88e6xxx_chip *chip, int port)\n{\n\tstruct mv88e639x_pcs *mpcs = chip->ports[port].pcs_private;\n\n\tif (!mpcs)\n\t\treturn;\n\n\tif (mpcs->irq)\n\t\tfree_irq(mpcs->irq, mpcs);\n\n\tkfree(mpcs);\n\n\tchip->ports[port].pcs_private = NULL;\n}\n\nstatic struct mv88e639x_pcs *sgmii_pcs_to_mv88e639x_pcs(struct phylink_pcs *pcs)\n{\n\treturn container_of(pcs, struct mv88e639x_pcs, sgmii_pcs);\n}\n\nstatic irqreturn_t mv88e639x_sgmii_handle_irq(struct mv88e639x_pcs *mpcs)\n{\n\tu16 int_status;\n\tint err;\n\n\terr = mv88e639x_read(mpcs, MV88E6390_SGMII_INT_STATUS, &int_status);\n\tif (err)\n\t\treturn IRQ_NONE;\n\n\tif (int_status & (MV88E6390_SGMII_INT_LINK_DOWN |\n\t\t\t  MV88E6390_SGMII_INT_LINK_UP)) {\n\t\tphylink_pcs_change(&mpcs->sgmii_pcs,\n\t\t\t\t   int_status & MV88E6390_SGMII_INT_LINK_UP);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int mv88e639x_sgmii_pcs_control_irq(struct mv88e639x_pcs *mpcs,\n\t\t\t\t\t   bool enable)\n{\n\tu16 val = 0;\n\n\tif (enable)\n\t\tval |= MV88E6390_SGMII_INT_LINK_DOWN |\n\t\t       MV88E6390_SGMII_INT_LINK_UP;\n\n\treturn mv88e639x_modify(mpcs, MV88E6390_SGMII_INT_ENABLE,\n\t\t\t\tMV88E6390_SGMII_INT_LINK_DOWN |\n\t\t\t\tMV88E6390_SGMII_INT_LINK_UP, val);\n}\n\nstatic int mv88e639x_sgmii_pcs_control_pwr(struct mv88e639x_pcs *mpcs,\n\t\t\t\t\t   bool enable)\n{\n\tu16 mask, val;\n\n\tif (enable) {\n\t\tmask = BMCR_RESET | BMCR_LOOPBACK | BMCR_PDOWN;\n\t\tval = 0;\n\t} else {\n\t\tmask = val = BMCR_PDOWN;\n\t}\n\n\treturn mv88e639x_modify(mpcs, MV88E6390_SGMII_BMCR, mask, val);\n}\n\nstatic int mv88e639x_sgmii_pcs_enable(struct phylink_pcs *pcs)\n{\n\tstruct mv88e639x_pcs *mpcs = sgmii_pcs_to_mv88e639x_pcs(pcs);\n\n\t \n\tmpcs->handle_irq = mv88e639x_sgmii_handle_irq;\n\n\treturn mv88e639x_sgmii_pcs_control_irq(mpcs, !!mpcs->irq);\n}\n\nstatic void mv88e639x_sgmii_pcs_disable(struct phylink_pcs *pcs)\n{\n\tstruct mv88e639x_pcs *mpcs = sgmii_pcs_to_mv88e639x_pcs(pcs);\n\n\tmv88e639x_sgmii_pcs_control_irq(mpcs, false);\n\tmv88e639x_sgmii_pcs_control_pwr(mpcs, false);\n}\n\nstatic void mv88e639x_sgmii_pcs_pre_config(struct phylink_pcs *pcs,\n\t\t\t\t\t   phy_interface_t interface)\n{\n\tstruct mv88e639x_pcs *mpcs = sgmii_pcs_to_mv88e639x_pcs(pcs);\n\n\tmv88e639x_sgmii_pcs_control_pwr(mpcs, false);\n}\n\nstatic int mv88e6390_erratum_3_14(struct mv88e639x_pcs *mpcs)\n{\n\tconst int lanes[] = { MV88E6390_PORT9_LANE0, MV88E6390_PORT9_LANE1,\n\t\tMV88E6390_PORT9_LANE2, MV88E6390_PORT9_LANE3,\n\t\tMV88E6390_PORT10_LANE0, MV88E6390_PORT10_LANE1,\n\t\tMV88E6390_PORT10_LANE2, MV88E6390_PORT10_LANE3 };\n\tint err, i;\n\n\t \n\n\tfor (i = 0; i < ARRAY_SIZE(lanes); i++) {\n\t\terr = mdiobus_c45_write(mpcs->mdio.bus, lanes[i],\n\t\t\t\t\tMDIO_MMD_PHYXS,\n\t\t\t\t\t0xf054, 0x400C);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mdiobus_c45_write(mpcs->mdio.bus, lanes[i],\n\t\t\t\t\tMDIO_MMD_PHYXS,\n\t\t\t\t\t0xf054, 0x4000);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int mv88e639x_sgmii_pcs_post_config(struct phylink_pcs *pcs,\n\t\t\t\t\t   phy_interface_t interface)\n{\n\tstruct mv88e639x_pcs *mpcs = sgmii_pcs_to_mv88e639x_pcs(pcs);\n\tint err;\n\n\tmv88e639x_sgmii_pcs_control_pwr(mpcs, true);\n\n\tif (mpcs->erratum_3_14) {\n\t\terr = mv88e6390_erratum_3_14(mpcs);\n\t\tif (err)\n\t\t\tdev_err(mpcs->mdio.dev.parent,\n\t\t\t\t\"failed to apply erratum 3.14: %pe\\n\",\n\t\t\t\tERR_PTR(err));\n\t}\n\n\treturn 0;\n}\n\nstatic void mv88e639x_sgmii_pcs_get_state(struct phylink_pcs *pcs,\n\t\t\t\t\t  struct phylink_link_state *state)\n{\n\tstruct mv88e639x_pcs *mpcs = sgmii_pcs_to_mv88e639x_pcs(pcs);\n\tu16 bmsr, lpa, status;\n\tint err;\n\n\terr = mv88e639x_read(mpcs, MV88E6390_SGMII_BMSR, &bmsr);\n\tif (err) {\n\t\tdev_err(mpcs->mdio.dev.parent,\n\t\t\t\"can't read Serdes PHY %s: %pe\\n\",\n\t\t\t\"BMSR\", ERR_PTR(err));\n\t\tstate->link = false;\n\t\treturn;\n\t}\n\n\terr = mv88e639x_read(mpcs, MV88E6390_SGMII_LPA, &lpa);\n\tif (err) {\n\t\tdev_err(mpcs->mdio.dev.parent,\n\t\t\t\"can't read Serdes PHY %s: %pe\\n\",\n\t\t\t\"LPA\", ERR_PTR(err));\n\t\tstate->link = false;\n\t\treturn;\n\t}\n\n\terr = mv88e639x_read(mpcs, MV88E6390_SGMII_PHY_STATUS, &status);\n\tif (err) {\n\t\tdev_err(mpcs->mdio.dev.parent,\n\t\t\t\"can't read Serdes PHY %s: %pe\\n\",\n\t\t\t\"status\", ERR_PTR(err));\n\t\tstate->link = false;\n\t\treturn;\n\t}\n\n\tmv88e6xxx_pcs_decode_state(mpcs->mdio.dev.parent, bmsr, lpa, status,\n\t\t\t\t   state);\n}\n\nstatic int mv88e639x_sgmii_pcs_config(struct phylink_pcs *pcs,\n\t\t\t\t      unsigned int neg_mode,\n\t\t\t\t      phy_interface_t interface,\n\t\t\t\t      const unsigned long *advertising,\n\t\t\t\t      bool permit_pause_to_mac)\n{\n\tstruct mv88e639x_pcs *mpcs = sgmii_pcs_to_mv88e639x_pcs(pcs);\n\tu16 val, bmcr;\n\tbool changed;\n\tint adv, err;\n\n\tadv = phylink_mii_c22_pcs_encode_advertisement(interface, advertising);\n\tif (adv < 0)\n\t\treturn 0;\n\n\tmpcs->interface = interface;\n\n\terr = mv88e639x_modify_changed(mpcs, MV88E6390_SGMII_ADVERTISE,\n\t\t\t\t       0xffff, adv);\n\tif (err < 0)\n\t\treturn err;\n\n\tchanged = err > 0;\n\n\terr = mv88e639x_read(mpcs, MV88E6390_SGMII_BMCR, &val);\n\tif (err)\n\t\treturn err;\n\n\tif (neg_mode == PHYLINK_PCS_NEG_INBAND_ENABLED)\n\t\tbmcr = val | BMCR_ANENABLE;\n\telse\n\t\tbmcr = val & ~BMCR_ANENABLE;\n\n\t \n\tif (bmcr == val)\n\t\treturn changed;\n\n\treturn mv88e639x_write(mpcs, MV88E6390_SGMII_BMCR, bmcr);\n}\n\nstatic void mv88e639x_sgmii_pcs_an_restart(struct phylink_pcs *pcs)\n{\n\tstruct mv88e639x_pcs *mpcs = sgmii_pcs_to_mv88e639x_pcs(pcs);\n\n\tmv88e639x_modify(mpcs, MV88E6390_SGMII_BMCR,\n\t\t\t BMCR_ANRESTART, BMCR_ANRESTART);\n}\n\nstatic void mv88e639x_sgmii_pcs_link_up(struct phylink_pcs *pcs,\n\t\t\t\t\tunsigned int mode,\n\t\t\t\t\tphy_interface_t interface,\n\t\t\t\t\tint speed, int duplex)\n{\n\tstruct mv88e639x_pcs *mpcs = sgmii_pcs_to_mv88e639x_pcs(pcs);\n\tu16 bmcr;\n\tint err;\n\n\tif (phylink_autoneg_inband(mode))\n\t\treturn;\n\n\tbmcr = mii_bmcr_encode_fixed(speed, duplex);\n\n\terr = mv88e639x_modify(mpcs, MV88E6390_SGMII_BMCR,\n\t\t\t       BMCR_SPEED1000 | BMCR_SPEED100 | BMCR_FULLDPLX,\n\t\t\t       bmcr);\n\tif (err)\n\t\tdev_err(mpcs->mdio.dev.parent,\n\t\t\t\"can't access Serdes PHY %s: %pe\\n\",\n\t\t\t\"BMCR\", ERR_PTR(err));\n}\n\nstatic const struct phylink_pcs_ops mv88e639x_sgmii_pcs_ops = {\n\t.pcs_enable = mv88e639x_sgmii_pcs_enable,\n\t.pcs_disable = mv88e639x_sgmii_pcs_disable,\n\t.pcs_pre_config = mv88e639x_sgmii_pcs_pre_config,\n\t.pcs_post_config = mv88e639x_sgmii_pcs_post_config,\n\t.pcs_get_state = mv88e639x_sgmii_pcs_get_state,\n\t.pcs_an_restart = mv88e639x_sgmii_pcs_an_restart,\n\t.pcs_config = mv88e639x_sgmii_pcs_config,\n\t.pcs_link_up = mv88e639x_sgmii_pcs_link_up,\n};\n\nstatic struct mv88e639x_pcs *xg_pcs_to_mv88e639x_pcs(struct phylink_pcs *pcs)\n{\n\treturn container_of(pcs, struct mv88e639x_pcs, xg_pcs);\n}\n\nstatic int mv88e639x_xg_pcs_enable(struct mv88e639x_pcs *mpcs)\n{\n\treturn mv88e639x_modify(mpcs, MV88E6390_10G_CTRL1,\n\t\t\t\tMDIO_CTRL1_RESET | MDIO_PCS_CTRL1_LOOPBACK |\n\t\t\t\tMDIO_CTRL1_LPOWER, 0);\n}\n\nstatic void mv88e639x_xg_pcs_disable(struct mv88e639x_pcs *mpcs)\n{\n\tmv88e639x_modify(mpcs, MV88E6390_10G_CTRL1, MDIO_CTRL1_LPOWER,\n\t\t\t MDIO_CTRL1_LPOWER);\n}\n\nstatic void mv88e639x_xg_pcs_get_state(struct phylink_pcs *pcs,\n\t\t\t\t       struct phylink_link_state *state)\n{\n\tstruct mv88e639x_pcs *mpcs = xg_pcs_to_mv88e639x_pcs(pcs);\n\tu16 status;\n\tint err;\n\n\tstate->link = false;\n\n\terr = mv88e639x_read(mpcs, MV88E6390_10G_STAT1, &status);\n\tif (err) {\n\t\tdev_err(mpcs->mdio.dev.parent,\n\t\t\t\"can't read Serdes PHY %s: %pe\\n\",\n\t\t\t\"STAT1\", ERR_PTR(err));\n\t\treturn;\n\t}\n\n\tstate->link = !!(status & MDIO_STAT1_LSTATUS);\n\tif (state->link) {\n\t\tswitch (state->interface) {\n\t\tcase PHY_INTERFACE_MODE_5GBASER:\n\t\t\tstate->speed = SPEED_5000;\n\t\t\tbreak;\n\n\t\tcase PHY_INTERFACE_MODE_10GBASER:\n\t\tcase PHY_INTERFACE_MODE_RXAUI:\n\t\tcase PHY_INTERFACE_MODE_XAUI:\n\t\t\tstate->speed = SPEED_10000;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tstate->link = false;\n\t\t\treturn;\n\t\t}\n\n\t\tstate->duplex = DUPLEX_FULL;\n\t}\n}\n\nstatic int mv88e639x_xg_pcs_config(struct phylink_pcs *pcs,\n\t\t\t\t   unsigned int neg_mode,\n\t\t\t\t   phy_interface_t interface,\n\t\t\t\t   const unsigned long *advertising,\n\t\t\t\t   bool permit_pause_to_mac)\n{\n\treturn 0;\n}\n\nstatic struct phylink_pcs *\nmv88e639x_pcs_select(struct mv88e6xxx_chip *chip, int port,\n\t\t     phy_interface_t mode)\n{\n\tstruct mv88e639x_pcs *mpcs;\n\n\tmpcs = chip->ports[port].pcs_private;\n\tif (!mpcs)\n\t\treturn NULL;\n\n\tswitch (mode) {\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\tcase PHY_INTERFACE_MODE_2500BASEX:\n\t\treturn &mpcs->sgmii_pcs;\n\n\tcase PHY_INTERFACE_MODE_5GBASER:\n\t\tif (!mpcs->supports_5g)\n\t\t\treturn NULL;\n\t\tfallthrough;\n\tcase PHY_INTERFACE_MODE_10GBASER:\n\tcase PHY_INTERFACE_MODE_XAUI:\n\tcase PHY_INTERFACE_MODE_RXAUI:\n\tcase PHY_INTERFACE_MODE_USXGMII:\n\t\treturn &mpcs->xg_pcs;\n\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\n \n\nstatic irqreturn_t mv88e6390_xg_handle_irq(struct mv88e639x_pcs *mpcs)\n{\n\tu16 int_status;\n\tint err;\n\n\terr = mv88e639x_read(mpcs, MV88E6390_10G_INT_STATUS, &int_status);\n\tif (err)\n\t\treturn IRQ_NONE;\n\n\tif (int_status & (MV88E6390_10G_INT_LINK_DOWN |\n\t\t\t  MV88E6390_10G_INT_LINK_UP)) {\n\t\tphylink_pcs_change(&mpcs->xg_pcs,\n\t\t\t\t   int_status & MV88E6390_10G_INT_LINK_UP);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int mv88e6390_xg_control_irq(struct mv88e639x_pcs *mpcs, bool enable)\n{\n\tu16 val = 0;\n\n\tif (enable)\n\t\tval = MV88E6390_10G_INT_LINK_DOWN | MV88E6390_10G_INT_LINK_UP;\n\n\treturn mv88e639x_modify(mpcs, MV88E6390_10G_INT_ENABLE,\n\t\t\t\tMV88E6390_10G_INT_LINK_DOWN |\n\t\t\t\tMV88E6390_10G_INT_LINK_UP, val);\n}\n\nstatic int mv88e6390_xg_pcs_enable(struct phylink_pcs *pcs)\n{\n\tstruct mv88e639x_pcs *mpcs = xg_pcs_to_mv88e639x_pcs(pcs);\n\tint err;\n\n\terr = mv88e639x_xg_pcs_enable(mpcs);\n\tif (err)\n\t\treturn err;\n\n\tmpcs->handle_irq = mv88e6390_xg_handle_irq;\n\n\treturn mv88e6390_xg_control_irq(mpcs, !!mpcs->irq);\n}\n\nstatic void mv88e6390_xg_pcs_disable(struct phylink_pcs *pcs)\n{\n\tstruct mv88e639x_pcs *mpcs = xg_pcs_to_mv88e639x_pcs(pcs);\n\n\tmv88e6390_xg_control_irq(mpcs, false);\n\tmv88e639x_xg_pcs_disable(mpcs);\n}\n\nstatic const struct phylink_pcs_ops mv88e6390_xg_pcs_ops = {\n\t.pcs_enable = mv88e6390_xg_pcs_enable,\n\t.pcs_disable = mv88e6390_xg_pcs_disable,\n\t.pcs_get_state = mv88e639x_xg_pcs_get_state,\n\t.pcs_config = mv88e639x_xg_pcs_config,\n};\n\nstatic int mv88e6390_pcs_enable_checker(struct mv88e639x_pcs *mpcs)\n{\n\treturn mv88e639x_modify(mpcs, MV88E6390_PG_CONTROL,\n\t\t\t\tMV88E6390_PG_CONTROL_ENABLE_PC,\n\t\t\t\tMV88E6390_PG_CONTROL_ENABLE_PC);\n}\n\nstatic int mv88e6390_pcs_init(struct mv88e6xxx_chip *chip, int port)\n{\n\tstruct mv88e639x_pcs *mpcs;\n\tstruct mii_bus *bus;\n\tstruct device *dev;\n\tint lane, err;\n\n\tlane = mv88e6xxx_serdes_get_lane(chip, port);\n\tif (lane < 0)\n\t\treturn 0;\n\n\tbus = mv88e6xxx_default_mdio_bus(chip);\n\tdev = chip->dev;\n\n\tmpcs = mv88e639x_pcs_alloc(dev, bus, lane, port);\n\tif (!mpcs)\n\t\treturn -ENOMEM;\n\n\tmpcs->sgmii_pcs.ops = &mv88e639x_sgmii_pcs_ops;\n\tmpcs->sgmii_pcs.neg_mode = true;\n\tmpcs->xg_pcs.ops = &mv88e6390_xg_pcs_ops;\n\tmpcs->xg_pcs.neg_mode = true;\n\n\tif (chip->info->prod_num == MV88E6XXX_PORT_SWITCH_ID_PROD_6190X ||\n\t    chip->info->prod_num == MV88E6XXX_PORT_SWITCH_ID_PROD_6390X)\n\t\tmpcs->erratum_3_14 = true;\n\n\terr = mv88e639x_pcs_setup_irq(mpcs, chip, port);\n\tif (err)\n\t\tgoto err_free;\n\n\t \n\t \n\terr = mv88e6390_pcs_enable_checker(mpcs);\n\tif (err)\n\t\tgoto err_free;\n\n\tchip->ports[port].pcs_private = mpcs;\n\n\treturn 0;\n\nerr_free:\n\tkfree(mpcs);\n\treturn err;\n}\n\nconst struct mv88e6xxx_pcs_ops mv88e6390_pcs_ops = {\n\t.pcs_init = mv88e6390_pcs_init,\n\t.pcs_teardown = mv88e639x_pcs_teardown,\n\t.pcs_select = mv88e639x_pcs_select,\n};\n\n \n\nstatic int mv88e6393x_power_lane(struct mv88e639x_pcs *mpcs, bool enable)\n{\n\tu16 val = MV88E6393X_SERDES_CTRL1_TX_PDOWN |\n\t\t  MV88E6393X_SERDES_CTRL1_RX_PDOWN;\n\n\treturn mv88e639x_modify(mpcs, MV88E6393X_SERDES_CTRL1, val,\n\t\t\t\tenable ? 0 : val);\n}\n\n \nstatic int mv88e6393x_erratum_4_6(struct mv88e639x_pcs *mpcs)\n{\n\tint err;\n\n\terr = mv88e639x_modify(mpcs, MV88E6393X_SERDES_POC,\n\t\t\t       MV88E6393X_SERDES_POC_PDOWN |\n\t\t\t       MV88E6393X_SERDES_POC_RESET,\n\t\t\t       MV88E6393X_SERDES_POC_RESET);\n\tif (err)\n\t\treturn err;\n\n\terr = mv88e639x_modify(mpcs, MV88E6390_SGMII_BMCR,\n\t\t\t       BMCR_PDOWN, BMCR_PDOWN);\n\tif (err)\n\t\treturn err;\n\n\terr = mv88e639x_sgmii_pcs_control_pwr(mpcs, false);\n\tif (err)\n\t\treturn err;\n\n\treturn mv88e6393x_power_lane(mpcs, false);\n}\n\n \nstatic int mv88e6393x_erratum_4_8(struct mv88e639x_pcs *mpcs)\n{\n\tu16 reg, poc;\n\tint err;\n\n\terr = mv88e639x_read(mpcs, MV88E6393X_SERDES_POC, &poc);\n\tif (err)\n\t\treturn err;\n\n\tpoc &= MV88E6393X_SERDES_POC_PCS_MASK;\n\tif (poc == MV88E6393X_SERDES_POC_PCS_1000BASEX ||\n\t    poc == MV88E6393X_SERDES_POC_PCS_SGMII_PHY ||\n\t    poc == MV88E6393X_SERDES_POC_PCS_SGMII_MAC)\n\t\treg = MV88E6393X_ERRATA_4_8_BIT;\n\telse\n\t\treg = 0;\n\n\treturn mv88e639x_modify(mpcs, MV88E6393X_ERRATA_4_8_REG,\n\t\t\t\tMV88E6393X_ERRATA_4_8_BIT, reg);\n}\n\n \nstatic int mv88e6393x_erratum_5_2(struct mv88e639x_pcs *mpcs)\n{\n\tstatic const struct {\n\t\tu16 dev, reg, val, mask;\n\t} fixes[] = {\n\t\t{ MDIO_MMD_VEND1, 0x8093, 0xcb5a, 0xffff },\n\t\t{ MDIO_MMD_VEND1, 0x8171, 0x7088, 0xffff },\n\t\t{ MDIO_MMD_VEND1, 0x80c9, 0x311a, 0xffff },\n\t\t{ MDIO_MMD_VEND1, 0x80a2, 0x8000, 0xff7f },\n\t\t{ MDIO_MMD_VEND1, 0x80a9, 0x0000, 0xfff0 },\n\t\t{ MDIO_MMD_VEND1, 0x80a3, 0x0000, 0xf8ff },\n\t\t{ MDIO_MMD_PHYXS, MV88E6393X_SERDES_POC,\n\t\t  MV88E6393X_SERDES_POC_RESET, MV88E6393X_SERDES_POC_RESET },\n\t};\n\tint err, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fixes); ++i) {\n\t\terr = mdiodev_c45_modify(&mpcs->mdio, fixes[i].dev,\n\t\t\t\t\t fixes[i].reg, fixes[i].mask,\n\t\t\t\t\t fixes[i].val);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mv88e6393x_fix_2500basex_an(struct mv88e639x_pcs *mpcs, bool on)\n{\n\tu16 reg;\n\tint err;\n\n\tif (on)\n\t\treg = MV88E6393X_SERDES_POC_PCS_1000BASEX |\n\t\t      MV88E6393X_SERDES_POC_AN;\n\telse\n\t\treg = MV88E6393X_SERDES_POC_PCS_2500BASEX;\n\n\treg |= MV88E6393X_SERDES_POC_RESET;\n\n\terr = mv88e639x_modify(mpcs, MV88E6393X_SERDES_POC,\n\t\t\t       MV88E6393X_SERDES_POC_PCS_MASK |\n\t\t\t       MV88E6393X_SERDES_POC_AN |\n\t\t\t       MV88E6393X_SERDES_POC_RESET, reg);\n\tif (err)\n\t\treturn err;\n\n\treturn mdiodev_c45_write(&mpcs->mdio, MDIO_MMD_VEND1, 0x8000, 0x58);\n}\n\nstatic int mv88e6393x_sgmii_apply_2500basex_an(struct mv88e639x_pcs *mpcs,\n\t\t\t\t\t       phy_interface_t interface,\n\t\t\t\t\t       bool enable)\n{\n\tint err;\n\n\tif (interface != PHY_INTERFACE_MODE_2500BASEX)\n\t\treturn 0;\n\n\terr = mv88e6393x_fix_2500basex_an(mpcs, enable);\n\tif (err)\n\t\tdev_err(mpcs->mdio.dev.parent,\n\t\t\t\"failed to %s 2500basex fix: %pe\\n\",\n\t\t\tenable ? \"enable\" : \"disable\", ERR_PTR(err));\n\n\treturn err;\n}\n\nstatic void mv88e6393x_sgmii_pcs_disable(struct phylink_pcs *pcs)\n{\n\tstruct mv88e639x_pcs *mpcs = sgmii_pcs_to_mv88e639x_pcs(pcs);\n\n\tmv88e639x_sgmii_pcs_disable(pcs);\n\tmv88e6393x_power_lane(mpcs, false);\n\tmv88e6393x_sgmii_apply_2500basex_an(mpcs, mpcs->interface, false);\n}\n\nstatic void mv88e6393x_sgmii_pcs_pre_config(struct phylink_pcs *pcs,\n\t\t\t\t\t    phy_interface_t interface)\n{\n\tstruct mv88e639x_pcs *mpcs = sgmii_pcs_to_mv88e639x_pcs(pcs);\n\n\tmv88e639x_sgmii_pcs_pre_config(pcs, interface);\n\tmv88e6393x_power_lane(mpcs, false);\n\tmv88e6393x_sgmii_apply_2500basex_an(mpcs, mpcs->interface, false);\n}\n\nstatic int mv88e6393x_sgmii_pcs_post_config(struct phylink_pcs *pcs,\n\t\t\t\t\t    phy_interface_t interface)\n{\n\tstruct mv88e639x_pcs *mpcs = sgmii_pcs_to_mv88e639x_pcs(pcs);\n\tint err;\n\n\terr = mv88e6393x_erratum_4_8(mpcs);\n\tif (err)\n\t\treturn err;\n\n\terr = mv88e6393x_sgmii_apply_2500basex_an(mpcs, interface, true);\n\tif (err)\n\t\treturn err;\n\n\terr = mv88e6393x_power_lane(mpcs, true);\n\tif (err)\n\t\treturn err;\n\n\treturn mv88e639x_sgmii_pcs_post_config(pcs, interface);\n}\n\nstatic const struct phylink_pcs_ops mv88e6393x_sgmii_pcs_ops = {\n\t.pcs_enable = mv88e639x_sgmii_pcs_enable,\n\t.pcs_disable = mv88e6393x_sgmii_pcs_disable,\n\t.pcs_pre_config = mv88e6393x_sgmii_pcs_pre_config,\n\t.pcs_post_config = mv88e6393x_sgmii_pcs_post_config,\n\t.pcs_get_state = mv88e639x_sgmii_pcs_get_state,\n\t.pcs_an_restart = mv88e639x_sgmii_pcs_an_restart,\n\t.pcs_config = mv88e639x_sgmii_pcs_config,\n\t.pcs_link_up = mv88e639x_sgmii_pcs_link_up,\n};\n\nstatic irqreturn_t mv88e6393x_xg_handle_irq(struct mv88e639x_pcs *mpcs)\n{\n\tu16 int_status, stat1;\n\tbool link_down;\n\tint err;\n\n\terr = mv88e639x_read(mpcs, MV88E6393X_10G_INT_STATUS, &int_status);\n\tif (err)\n\t\treturn IRQ_NONE;\n\n\tif (int_status & MV88E6393X_10G_INT_LINK_CHANGE) {\n\t\terr = mv88e639x_read(mpcs, MV88E6390_10G_STAT1, &stat1);\n\t\tif (err)\n\t\t\treturn IRQ_NONE;\n\n\t\tlink_down = !(stat1 & MDIO_STAT1_LSTATUS);\n\n\t\tphylink_pcs_change(&mpcs->xg_pcs, !link_down);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic int mv88e6393x_xg_control_irq(struct mv88e639x_pcs *mpcs, bool enable)\n{\n\tu16 val = 0;\n\n\tif (enable)\n\t\tval = MV88E6393X_10G_INT_LINK_CHANGE;\n\n\treturn mv88e639x_modify(mpcs, MV88E6393X_10G_INT_ENABLE,\n\t\t\t\tMV88E6393X_10G_INT_LINK_CHANGE, val);\n}\n\nstatic int mv88e6393x_xg_pcs_enable(struct phylink_pcs *pcs)\n{\n\tstruct mv88e639x_pcs *mpcs = xg_pcs_to_mv88e639x_pcs(pcs);\n\n\tmpcs->handle_irq = mv88e6393x_xg_handle_irq;\n\n\treturn mv88e6393x_xg_control_irq(mpcs, !!mpcs->irq);\n}\n\nstatic void mv88e6393x_xg_pcs_disable(struct phylink_pcs *pcs)\n{\n\tstruct mv88e639x_pcs *mpcs = xg_pcs_to_mv88e639x_pcs(pcs);\n\n\tmv88e6393x_xg_control_irq(mpcs, false);\n\tmv88e639x_xg_pcs_disable(mpcs);\n\tmv88e6393x_power_lane(mpcs, false);\n}\n\n \nstatic void mv88e6393x_xg_pcs_pre_config(struct phylink_pcs *pcs,\n\t\t\t\t\t phy_interface_t interface)\n{\n\tstruct mv88e639x_pcs *mpcs = xg_pcs_to_mv88e639x_pcs(pcs);\n\n\tmv88e639x_xg_pcs_disable(mpcs);\n\tmv88e6393x_power_lane(mpcs, false);\n}\n\nstatic int mv88e6393x_xg_pcs_post_config(struct phylink_pcs *pcs,\n\t\t\t\t\t phy_interface_t interface)\n{\n\tstruct mv88e639x_pcs *mpcs = xg_pcs_to_mv88e639x_pcs(pcs);\n\tint err;\n\n\tif (interface == PHY_INTERFACE_MODE_10GBASER ||\n\t    interface == PHY_INTERFACE_MODE_USXGMII) {\n\t\terr = mv88e6393x_erratum_5_2(mpcs);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = mv88e6393x_power_lane(mpcs, true);\n\tif (err)\n\t\treturn err;\n\n\treturn mv88e639x_xg_pcs_enable(mpcs);\n}\n\nstatic void mv88e6393x_xg_pcs_get_state(struct phylink_pcs *pcs,\n\t\t\t\t\tstruct phylink_link_state *state)\n{\n\tstruct mv88e639x_pcs *mpcs = xg_pcs_to_mv88e639x_pcs(pcs);\n\tu16 status, lp_status;\n\tint err;\n\n\tif (state->interface != PHY_INTERFACE_MODE_USXGMII)\n\t\treturn mv88e639x_xg_pcs_get_state(pcs, state);\n\n\tstate->link = false;\n\n\terr = mv88e639x_read(mpcs, MV88E6390_USXGMII_PHY_STATUS, &status);\n\terr = err ? : mv88e639x_read(mpcs, MV88E6390_USXGMII_LP_STATUS, &lp_status);\n\tif (err) {\n\t\tdev_err(mpcs->mdio.dev.parent,\n\t\t\t\"can't read USXGMII status: %pe\\n\", ERR_PTR(err));\n\t\treturn;\n\t}\n\n\tstate->link = !!(status & MDIO_USXGMII_LINK);\n\tstate->an_complete = state->link;\n\tphylink_decode_usxgmii_word(state, lp_status);\n}\n\nstatic const struct phylink_pcs_ops mv88e6393x_xg_pcs_ops = {\n\t.pcs_enable = mv88e6393x_xg_pcs_enable,\n\t.pcs_disable = mv88e6393x_xg_pcs_disable,\n\t.pcs_pre_config = mv88e6393x_xg_pcs_pre_config,\n\t.pcs_post_config = mv88e6393x_xg_pcs_post_config,\n\t.pcs_get_state = mv88e6393x_xg_pcs_get_state,\n\t.pcs_config = mv88e639x_xg_pcs_config,\n};\n\nstatic int mv88e6393x_pcs_init(struct mv88e6xxx_chip *chip, int port)\n{\n\tstruct mv88e639x_pcs *mpcs;\n\tstruct mii_bus *bus;\n\tstruct device *dev;\n\tint lane, err;\n\n\tlane = mv88e6xxx_serdes_get_lane(chip, port);\n\tif (lane < 0)\n\t\treturn 0;\n\n\tbus = mv88e6xxx_default_mdio_bus(chip);\n\tdev = chip->dev;\n\n\tmpcs = mv88e639x_pcs_alloc(dev, bus, lane, port);\n\tif (!mpcs)\n\t\treturn -ENOMEM;\n\n\tmpcs->sgmii_pcs.ops = &mv88e6393x_sgmii_pcs_ops;\n\tmpcs->sgmii_pcs.neg_mode = true;\n\tmpcs->xg_pcs.ops = &mv88e6393x_xg_pcs_ops;\n\tmpcs->xg_pcs.neg_mode = true;\n\tmpcs->supports_5g = true;\n\n\terr = mv88e6393x_erratum_4_6(mpcs);\n\tif (err)\n\t\tgoto err_free;\n\n\terr = mv88e639x_pcs_setup_irq(mpcs, chip, port);\n\tif (err)\n\t\tgoto err_free;\n\n\tchip->ports[port].pcs_private = mpcs;\n\n\treturn 0;\n\nerr_free:\n\tkfree(mpcs);\n\treturn err;\n}\n\nconst struct mv88e6xxx_pcs_ops mv88e6393x_pcs_ops = {\n\t.pcs_init = mv88e6393x_pcs_init,\n\t.pcs_teardown = mv88e639x_pcs_teardown,\n\t.pcs_select = mv88e639x_pcs_select,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}