{
  "module_name": "bcm_sf2.c",
  "hash_id": "dc189a0f80a9c874e27b673e58afa651a450f4117bb80522a0c4ea702b3816ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/bcm_sf2.c",
  "human_readable_source": "\n \n\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/phy.h>\n#include <linux/phy_fixed.h>\n#include <linux/phylink.h>\n#include <linux/mii.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of_net.h>\n#include <linux/of_mdio.h>\n#include <net/dsa.h>\n#include <linux/ethtool.h>\n#include <linux/if_bridge.h>\n#include <linux/brcmphy.h>\n#include <linux/etherdevice.h>\n#include <linux/platform_data/b53.h>\n\n#include \"bcm_sf2.h\"\n#include \"bcm_sf2_regs.h\"\n#include \"b53/b53_priv.h\"\n#include \"b53/b53_regs.h\"\n\nstatic u16 bcm_sf2_reg_rgmii_cntrl(struct bcm_sf2_priv *priv, int port)\n{\n\tswitch (priv->type) {\n\tcase BCM4908_DEVICE_ID:\n\t\tswitch (port) {\n\t\tcase 7:\n\t\t\treturn REG_RGMII_11_CNTRL;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tswitch (port) {\n\t\tcase 0:\n\t\t\treturn REG_RGMII_0_CNTRL;\n\t\tcase 1:\n\t\t\treturn REG_RGMII_1_CNTRL;\n\t\tcase 2:\n\t\t\treturn REG_RGMII_2_CNTRL;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tWARN_ONCE(1, \"Unsupported port %d\\n\", port);\n\n\t \n\treturn REG_SWITCH_STATUS;\n}\n\nstatic u16 bcm_sf2_reg_led_base(struct bcm_sf2_priv *priv, int port)\n{\n\tswitch (port) {\n\tcase 0:\n\t\treturn REG_LED_0_CNTRL;\n\tcase 1:\n\t\treturn REG_LED_1_CNTRL;\n\tcase 2:\n\t\treturn REG_LED_2_CNTRL;\n\t}\n\n\tswitch (priv->type) {\n\tcase BCM4908_DEVICE_ID:\n\t\tswitch (port) {\n\t\tcase 3:\n\t\t\treturn REG_LED_3_CNTRL;\n\t\tcase 7:\n\t\t\treturn REG_LED_4_CNTRL;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tWARN_ONCE(1, \"Unsupported port %d\\n\", port);\n\n\t \n\treturn REG_SWITCH_STATUS;\n}\n\nstatic u32 bcm_sf2_port_override_offset(struct bcm_sf2_priv *priv, int port)\n{\n\tswitch (priv->type) {\n\tcase BCM4908_DEVICE_ID:\n\tcase BCM7445_DEVICE_ID:\n\t\treturn port == 8 ? CORE_STS_OVERRIDE_IMP :\n\t\t\t\t   CORE_STS_OVERRIDE_GMIIP_PORT(port);\n\tcase BCM7278_DEVICE_ID:\n\t\treturn port == 8 ? CORE_STS_OVERRIDE_IMP2 :\n\t\t\t\t   CORE_STS_OVERRIDE_GMIIP2_PORT(port);\n\tdefault:\n\t\tWARN_ONCE(1, \"Unsupported device: %d\\n\", priv->type);\n\t}\n\n\t \n\treturn REG_SWITCH_STATUS;\n}\n\n \nstatic unsigned int bcm_sf2_num_active_ports(struct dsa_switch *ds)\n{\n\tstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\n\tunsigned int port, count = 0;\n\n\tfor (port = 0; port < ds->num_ports; port++) {\n\t\tif (dsa_is_cpu_port(ds, port))\n\t\t\tcontinue;\n\t\tif (priv->port_sts[port].enabled)\n\t\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nstatic void bcm_sf2_recalc_clock(struct dsa_switch *ds)\n{\n\tstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\n\tunsigned long new_rate;\n\tunsigned int ports_active;\n\t \n\tstatic const unsigned long rate_table[] = {\n\t\t59220000,\n\t\t60820000,\n\t\t62500000,\n\t\t62500000,\n\t};\n\n\tports_active = bcm_sf2_num_active_ports(ds);\n\tif (ports_active == 0 || !priv->clk_mdiv)\n\t\treturn;\n\n\t \n\tif (ports_active > ARRAY_SIZE(rate_table))\n\t\tnew_rate = 90000000;\n\telse\n\t\tnew_rate = rate_table[ports_active - 1];\n\tclk_set_rate(priv->clk_mdiv, new_rate);\n}\n\nstatic void bcm_sf2_imp_setup(struct dsa_switch *ds, int port)\n{\n\tstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\n\tunsigned int i;\n\tu32 reg;\n\n\t \n\treg = core_readl(priv, CORE_MEM_PSM_VDD_CTRL);\n\treg &= ~P_TXQ_PSM_VDD(port);\n\tcore_writel(priv, reg, CORE_MEM_PSM_VDD_CTRL);\n\n\t \n\tcore_writel(priv, SW_FWDG_EN, CORE_SWMODE);\n\n\t \n\treg = core_readl(priv, CORE_SWITCH_CTRL);\n\treg |= MII_DUMB_FWDG_EN;\n\tcore_writel(priv, reg, CORE_SWITCH_CTRL);\n\n\t \n\treg = core_readl(priv, CORE_PORT_TC2_QOS_MAP_PORT(port));\n\tfor (i = 0; i < SF2_NUM_EGRESS_QUEUES; i++)\n\t\treg |= i << (PRT_TO_QID_SHIFT * i);\n\tcore_writel(priv, reg, CORE_PORT_TC2_QOS_MAP_PORT(port));\n\n\tb53_brcm_hdr_setup(ds, port);\n\n\tif (port == 8) {\n\t\t \n\t\treg = core_readl(priv, CORE_IMP_CTL);\n\t\treg |= (RX_BCST_EN | RX_MCST_EN | RX_UCST_EN);\n\t\treg &= ~(RX_DIS | TX_DIS);\n\t\tcore_writel(priv, reg, CORE_IMP_CTL);\n\t} else {\n\t\treg = core_readl(priv, CORE_G_PCTL_PORT(port));\n\t\treg &= ~(RX_DIS | TX_DIS);\n\t\tcore_writel(priv, reg, CORE_G_PCTL_PORT(port));\n\t}\n\n\tpriv->port_sts[port].enabled = true;\n}\n\nstatic void bcm_sf2_gphy_enable_set(struct dsa_switch *ds, bool enable)\n{\n\tstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\n\tu32 reg;\n\n\treg = reg_readl(priv, REG_SPHY_CNTRL);\n\tif (enable) {\n\t\treg |= PHY_RESET;\n\t\treg &= ~(EXT_PWR_DOWN | IDDQ_BIAS | IDDQ_GLOBAL_PWR | CK25_DIS);\n\t\treg_writel(priv, reg, REG_SPHY_CNTRL);\n\t\tudelay(21);\n\t\treg = reg_readl(priv, REG_SPHY_CNTRL);\n\t\treg &= ~PHY_RESET;\n\t} else {\n\t\treg |= EXT_PWR_DOWN | IDDQ_BIAS | PHY_RESET;\n\t\treg_writel(priv, reg, REG_SPHY_CNTRL);\n\t\tmdelay(1);\n\t\treg |= CK25_DIS;\n\t}\n\treg_writel(priv, reg, REG_SPHY_CNTRL);\n\n\t \n\tif (!enable) {\n\t\tu16 led_ctrl = bcm_sf2_reg_led_base(priv, 0);\n\n\t\tif (priv->type == BCM7278_DEVICE_ID ||\n\t\t    priv->type == BCM7445_DEVICE_ID) {\n\t\t\treg = reg_led_readl(priv, led_ctrl, 0);\n\t\t\treg |= LED_CNTRL_SPDLNK_SRC_SEL;\n\t\t\treg_led_writel(priv, reg, led_ctrl, 0);\n\t\t}\n\t}\n}\n\nstatic inline void bcm_sf2_port_intr_enable(struct bcm_sf2_priv *priv,\n\t\t\t\t\t    int port)\n{\n\tunsigned int off;\n\n\tswitch (port) {\n\tcase 7:\n\t\toff = P7_IRQ_OFF;\n\t\tbreak;\n\tcase 0:\n\t\t \n\t\tintrl2_0_mask_clear(priv, P_IRQ_MASK(P0_IRQ_OFF));\n\t\treturn;\n\tdefault:\n\t\toff = P_IRQ_OFF(port);\n\t\tbreak;\n\t}\n\n\tintrl2_1_mask_clear(priv, P_IRQ_MASK(off));\n}\n\nstatic inline void bcm_sf2_port_intr_disable(struct bcm_sf2_priv *priv,\n\t\t\t\t\t     int port)\n{\n\tunsigned int off;\n\n\tswitch (port) {\n\tcase 7:\n\t\toff = P7_IRQ_OFF;\n\t\tbreak;\n\tcase 0:\n\t\t \n\t\tintrl2_0_mask_set(priv, P_IRQ_MASK(P0_IRQ_OFF));\n\t\tintrl2_0_writel(priv, P_IRQ_MASK(P0_IRQ_OFF), INTRL2_CPU_CLEAR);\n\t\treturn;\n\tdefault:\n\t\toff = P_IRQ_OFF(port);\n\t\tbreak;\n\t}\n\n\tintrl2_1_mask_set(priv, P_IRQ_MASK(off));\n\tintrl2_1_writel(priv, P_IRQ_MASK(off), INTRL2_CPU_CLEAR);\n}\n\nstatic int bcm_sf2_port_setup(struct dsa_switch *ds, int port,\n\t\t\t      struct phy_device *phy)\n{\n\tstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\n\tunsigned int i;\n\tu32 reg;\n\n\tif (!dsa_is_user_port(ds, port))\n\t\treturn 0;\n\n\tpriv->port_sts[port].enabled = true;\n\n\tbcm_sf2_recalc_clock(ds);\n\n\t \n\treg = core_readl(priv, CORE_MEM_PSM_VDD_CTRL);\n\treg &= ~P_TXQ_PSM_VDD(port);\n\tcore_writel(priv, reg, CORE_MEM_PSM_VDD_CTRL);\n\n\t \n\tif (priv->brcm_tag_mask & BIT(port))\n\t\tb53_brcm_hdr_setup(ds, port);\n\n\t \n\treg = core_readl(priv, CORE_PORT_TC2_QOS_MAP_PORT(port));\n\tfor (i = 0; i < SF2_NUM_EGRESS_QUEUES; i++)\n\t\treg |= i << (PRT_TO_QID_SHIFT * i);\n\tcore_writel(priv, reg, CORE_PORT_TC2_QOS_MAP_PORT(port));\n\n\t \n\tif (priv->int_phy_mask & 1 << port && priv->hw_params.num_gphy == 1) {\n\t\tbcm_sf2_gphy_enable_set(ds, true);\n\t\tif (phy) {\n\t\t\t \n\t\t\tphy->state = PHY_READY;\n\t\t\tphy_init_hw(phy);\n\t\t}\n\t}\n\n\t \n\tif (port == priv->moca_port)\n\t\tbcm_sf2_port_intr_enable(priv, port);\n\n\t \n\tcore_writel(priv, 32, CORE_TXQ_THD_PAUSE_QN_PORT(port));\n\n\t \n\tfor (i = 0; i < SF2_NUM_EGRESS_QUEUES; i++) {\n\t\treg = acb_readl(priv, ACB_QUEUE_CFG(port *\n\t\t\t\t\t\t    SF2_NUM_EGRESS_QUEUES + i));\n\t\treg &= ~XOFF_THRESHOLD_MASK;\n\t\treg |= 24;\n\t\tacb_writel(priv, reg, ACB_QUEUE_CFG(port *\n\t\t\t\t\t\t    SF2_NUM_EGRESS_QUEUES + i));\n\t}\n\n\treturn b53_enable_port(ds, port, phy);\n}\n\nstatic void bcm_sf2_port_disable(struct dsa_switch *ds, int port)\n{\n\tstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\n\tu32 reg;\n\n\t \n\tif (priv->wol_ports_mask & (1 << port)) {\n\t\treg = core_readl(priv, CORE_DIS_LEARN);\n\t\treg |= BIT(port);\n\t\tcore_writel(priv, reg, CORE_DIS_LEARN);\n\t\treturn;\n\t}\n\n\tif (port == priv->moca_port)\n\t\tbcm_sf2_port_intr_disable(priv, port);\n\n\tif (priv->int_phy_mask & 1 << port && priv->hw_params.num_gphy == 1)\n\t\tbcm_sf2_gphy_enable_set(ds, false);\n\n\tb53_disable_port(ds, port);\n\n\t \n\treg = core_readl(priv, CORE_MEM_PSM_VDD_CTRL);\n\treg |= P_TXQ_PSM_VDD(port);\n\tcore_writel(priv, reg, CORE_MEM_PSM_VDD_CTRL);\n\n\tpriv->port_sts[port].enabled = false;\n\n\tbcm_sf2_recalc_clock(ds);\n}\n\n\nstatic int bcm_sf2_sw_indir_rw(struct bcm_sf2_priv *priv, int op, int addr,\n\t\t\t       int regnum, u16 val)\n{\n\tint ret = 0;\n\tu32 reg;\n\n\treg = reg_readl(priv, REG_SWITCH_CNTRL);\n\treg |= MDIO_MASTER_SEL;\n\treg_writel(priv, reg, REG_SWITCH_CNTRL);\n\n\t \n\treg = 0x70;\n\treg <<= 2;\n\tcore_writel(priv, addr, reg);\n\n\t \n\treg = 0x80 << 8 | regnum << 1;\n\treg <<= 2;\n\n\tif (op)\n\t\tret = core_readl(priv, reg);\n\telse\n\t\tcore_writel(priv, val, reg);\n\n\treg = reg_readl(priv, REG_SWITCH_CNTRL);\n\treg &= ~MDIO_MASTER_SEL;\n\treg_writel(priv, reg, REG_SWITCH_CNTRL);\n\n\treturn ret & 0xffff;\n}\n\nstatic int bcm_sf2_sw_mdio_read(struct mii_bus *bus, int addr, int regnum)\n{\n\tstruct bcm_sf2_priv *priv = bus->priv;\n\n\t \n\tif (addr == BRCM_PSEUDO_PHY_ADDR && priv->indir_phy_mask & BIT(addr))\n\t\treturn bcm_sf2_sw_indir_rw(priv, 1, addr, regnum, 0);\n\telse\n\t\treturn mdiobus_read_nested(priv->master_mii_bus, addr, regnum);\n}\n\nstatic int bcm_sf2_sw_mdio_write(struct mii_bus *bus, int addr, int regnum,\n\t\t\t\t u16 val)\n{\n\tstruct bcm_sf2_priv *priv = bus->priv;\n\n\t \n\tif (addr == BRCM_PSEUDO_PHY_ADDR && priv->indir_phy_mask & BIT(addr))\n\t\treturn bcm_sf2_sw_indir_rw(priv, 0, addr, regnum, val);\n\telse\n\t\treturn mdiobus_write_nested(priv->master_mii_bus, addr,\n\t\t\t\tregnum, val);\n}\n\nstatic irqreturn_t bcm_sf2_switch_0_isr(int irq, void *dev_id)\n{\n\tstruct dsa_switch *ds = dev_id;\n\tstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\n\n\tpriv->irq0_stat = intrl2_0_readl(priv, INTRL2_CPU_STATUS) &\n\t\t\t\t~priv->irq0_mask;\n\tintrl2_0_writel(priv, priv->irq0_stat, INTRL2_CPU_CLEAR);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t bcm_sf2_switch_1_isr(int irq, void *dev_id)\n{\n\tstruct dsa_switch *ds = dev_id;\n\tstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\n\n\tpriv->irq1_stat = intrl2_1_readl(priv, INTRL2_CPU_STATUS) &\n\t\t\t\t~priv->irq1_mask;\n\tintrl2_1_writel(priv, priv->irq1_stat, INTRL2_CPU_CLEAR);\n\n\tif (priv->irq1_stat & P_LINK_UP_IRQ(P7_IRQ_OFF)) {\n\t\tpriv->port_sts[7].link = true;\n\t\tdsa_port_phylink_mac_change(ds, 7, true);\n\t}\n\tif (priv->irq1_stat & P_LINK_DOWN_IRQ(P7_IRQ_OFF)) {\n\t\tpriv->port_sts[7].link = false;\n\t\tdsa_port_phylink_mac_change(ds, 7, false);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bcm_sf2_sw_rst(struct bcm_sf2_priv *priv)\n{\n\tunsigned int timeout = 1000;\n\tu32 reg;\n\tint ret;\n\n\t \n\tif (priv->type == BCM7278_DEVICE_ID) {\n\t\tret = reset_control_assert(priv->rcdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn reset_control_deassert(priv->rcdev);\n\t}\n\n\treg = core_readl(priv, CORE_WATCHDOG_CTRL);\n\treg |= SOFTWARE_RESET | EN_CHIP_RST | EN_SW_RESET;\n\tcore_writel(priv, reg, CORE_WATCHDOG_CTRL);\n\n\tdo {\n\t\treg = core_readl(priv, CORE_WATCHDOG_CTRL);\n\t\tif (!(reg & SOFTWARE_RESET))\n\t\t\tbreak;\n\n\t\tusleep_range(1000, 2000);\n\t} while (timeout-- > 0);\n\n\tif (timeout == 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic void bcm_sf2_crossbar_setup(struct bcm_sf2_priv *priv)\n{\n\tstruct device *dev = priv->dev->ds->dev;\n\tint shift;\n\tu32 mask;\n\tu32 reg;\n\tint i;\n\n\tmask = BIT(priv->num_crossbar_int_ports) - 1;\n\n\treg = reg_readl(priv, REG_CROSSBAR);\n\tswitch (priv->type) {\n\tcase BCM4908_DEVICE_ID:\n\t\tshift = CROSSBAR_BCM4908_INT_P7 * priv->num_crossbar_int_ports;\n\t\treg &= ~(mask << shift);\n\t\tif (0)  \n\t\t\treg |= CROSSBAR_BCM4908_EXT_SERDES << shift;\n\t\telse if (priv->int_phy_mask & BIT(7))\n\t\t\treg |= CROSSBAR_BCM4908_EXT_GPHY4 << shift;\n\t\telse if (phy_interface_mode_is_rgmii(priv->port_sts[7].mode))\n\t\t\treg |= CROSSBAR_BCM4908_EXT_RGMII << shift;\n\t\telse if (WARN(1, \"Invalid port mode\\n\"))\n\t\t\treturn;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\treg_writel(priv, reg, REG_CROSSBAR);\n\n\treg = reg_readl(priv, REG_CROSSBAR);\n\tfor (i = 0; i < priv->num_crossbar_int_ports; i++) {\n\t\tshift = i * priv->num_crossbar_int_ports;\n\n\t\tdev_dbg(dev, \"crossbar int port #%d - ext port #%d\\n\", i,\n\t\t\t(reg >> shift) & mask);\n\t}\n}\n\nstatic void bcm_sf2_intr_disable(struct bcm_sf2_priv *priv)\n{\n\tintrl2_0_mask_set(priv, 0xffffffff);\n\tintrl2_0_writel(priv, 0xffffffff, INTRL2_CPU_CLEAR);\n\tintrl2_1_mask_set(priv, 0xffffffff);\n\tintrl2_1_writel(priv, 0xffffffff, INTRL2_CPU_CLEAR);\n}\n\nstatic void bcm_sf2_identify_ports(struct bcm_sf2_priv *priv,\n\t\t\t\t   struct device_node *dn)\n{\n\tstruct device *dev = priv->dev->ds->dev;\n\tstruct bcm_sf2_port_status *port_st;\n\tstruct device_node *port;\n\tunsigned int port_num;\n\tstruct property *prop;\n\tint err;\n\n\tpriv->moca_port = -1;\n\n\tfor_each_available_child_of_node(dn, port) {\n\t\tif (of_property_read_u32(port, \"reg\", &port_num))\n\t\t\tcontinue;\n\n\t\tif (port_num >= DSA_MAX_PORTS) {\n\t\t\tdev_err(dev, \"Invalid port number %d\\n\", port_num);\n\t\t\tcontinue;\n\t\t}\n\n\t\tport_st = &priv->port_sts[port_num];\n\n\t\t \n\t\terr = of_get_phy_mode(port, &port_st->mode);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\tif (port_st->mode == PHY_INTERFACE_MODE_INTERNAL)\n\t\t\tpriv->int_phy_mask |= 1 << port_num;\n\n\t\tif (port_st->mode == PHY_INTERFACE_MODE_MOCA)\n\t\t\tpriv->moca_port = port_num;\n\n\t\tif (of_property_read_bool(port, \"brcm,use-bcm-hdr\"))\n\t\t\tpriv->brcm_tag_mask |= 1 << port_num;\n\n\t\t \n\t\tif (port_num == 5 && priv->type == BCM7278_DEVICE_ID) {\n\t\t\tprop = of_find_property(port, \"ethernet\", NULL);\n\t\t\tif (prop)\n\t\t\t\tof_remove_property(port, prop);\n\t\t}\n\t}\n}\n\nstatic int bcm_sf2_mdio_register(struct dsa_switch *ds)\n{\n\tstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\n\tstruct device_node *dn, *child;\n\tstruct phy_device *phydev;\n\tstruct property *prop;\n\tstatic int index;\n\tint err, reg;\n\n\t \n\tdn = of_find_compatible_node(NULL, NULL, \"brcm,unimac-mdio\");\n\tpriv->master_mii_bus = of_mdio_find_bus(dn);\n\tif (!priv->master_mii_bus) {\n\t\terr = -EPROBE_DEFER;\n\t\tgoto err_of_node_put;\n\t}\n\n\tpriv->master_mii_dn = dn;\n\n\tpriv->slave_mii_bus = mdiobus_alloc();\n\tif (!priv->slave_mii_bus) {\n\t\terr = -ENOMEM;\n\t\tgoto err_put_master_mii_bus_dev;\n\t}\n\n\tpriv->slave_mii_bus->priv = priv;\n\tpriv->slave_mii_bus->name = \"sf2 slave mii\";\n\tpriv->slave_mii_bus->read = bcm_sf2_sw_mdio_read;\n\tpriv->slave_mii_bus->write = bcm_sf2_sw_mdio_write;\n\tsnprintf(priv->slave_mii_bus->id, MII_BUS_ID_SIZE, \"sf2-%d\",\n\t\t index++);\n\tpriv->slave_mii_bus->dev.of_node = dn;\n\n\t \n\tif (of_machine_is_compatible(\"brcm,bcm7445d0\"))\n\t\tpriv->indir_phy_mask |= (1 << BRCM_PSEUDO_PHY_ADDR) | (1 << 0);\n\telse\n\t\tpriv->indir_phy_mask = 0;\n\n\tds->phys_mii_mask = priv->indir_phy_mask;\n\tds->slave_mii_bus = priv->slave_mii_bus;\n\tpriv->slave_mii_bus->parent = ds->dev->parent;\n\tpriv->slave_mii_bus->phy_mask = ~priv->indir_phy_mask;\n\n\t \n\tfor_each_available_child_of_node(dn, child) {\n\t\tif (of_property_read_u32(child, \"reg\", &reg) ||\n\t\t    reg >= PHY_MAX_ADDR)\n\t\t\tcontinue;\n\n\t\tif (!(priv->indir_phy_mask & BIT(reg)))\n\t\t\tcontinue;\n\n\t\tprop = of_find_property(child, \"phandle\", NULL);\n\t\tif (prop)\n\t\t\tof_remove_property(child, prop);\n\n\t\tprop = of_find_property(child, \"linux,phandle\", NULL);\n\t\tif (prop)\n\t\t\tof_remove_property(child, prop);\n\n\t\tphydev = of_phy_find_device(child);\n\t\tif (phydev)\n\t\t\tphy_device_remove(phydev);\n\t}\n\n\terr = mdiobus_register(priv->slave_mii_bus);\n\tif (err && dn)\n\t\tgoto err_free_slave_mii_bus;\n\n\treturn 0;\n\nerr_free_slave_mii_bus:\n\tmdiobus_free(priv->slave_mii_bus);\nerr_put_master_mii_bus_dev:\n\tput_device(&priv->master_mii_bus->dev);\nerr_of_node_put:\n\tof_node_put(dn);\n\treturn err;\n}\n\nstatic void bcm_sf2_mdio_unregister(struct bcm_sf2_priv *priv)\n{\n\tmdiobus_unregister(priv->slave_mii_bus);\n\tmdiobus_free(priv->slave_mii_bus);\n\tput_device(&priv->master_mii_bus->dev);\n\tof_node_put(priv->master_mii_dn);\n}\n\nstatic u32 bcm_sf2_sw_get_phy_flags(struct dsa_switch *ds, int port)\n{\n\tstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\n\n\t \n\tif (priv->int_phy_mask & BIT(port))\n\t\treturn priv->hw_params.gphy_rev;\n\telse\n\t\treturn PHY_BRCM_AUTO_PWRDWN_ENABLE |\n\t\t       PHY_BRCM_DIS_TXCRXC_NOENRGY |\n\t\t       PHY_BRCM_IDDQ_SUSPEND;\n}\n\nstatic void bcm_sf2_sw_get_caps(struct dsa_switch *ds, int port,\n\t\t\t\tstruct phylink_config *config)\n{\n\tunsigned long *interfaces = config->supported_interfaces;\n\tstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\n\n\tif (priv->int_phy_mask & BIT(port)) {\n\t\t__set_bit(PHY_INTERFACE_MODE_INTERNAL, interfaces);\n\t} else if (priv->moca_port == port) {\n\t\t__set_bit(PHY_INTERFACE_MODE_MOCA, interfaces);\n\t} else {\n\t\t__set_bit(PHY_INTERFACE_MODE_MII, interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_REVMII, interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_GMII, interfaces);\n\t\tphy_interface_set_rgmii(interfaces);\n\t}\n\n\tconfig->mac_capabilities = MAC_ASYM_PAUSE | MAC_SYM_PAUSE |\n\t\tMAC_10 | MAC_100 | MAC_1000;\n}\n\nstatic void bcm_sf2_sw_mac_config(struct dsa_switch *ds, int port,\n\t\t\t\t  unsigned int mode,\n\t\t\t\t  const struct phylink_link_state *state)\n{\n\tstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\n\tu32 id_mode_dis = 0, port_mode;\n\tu32 reg_rgmii_ctrl;\n\tu32 reg;\n\n\tif (port == core_readl(priv, CORE_IMP0_PRT_ID))\n\t\treturn;\n\n\tswitch (state->interface) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\t\tid_mode_dis = 1;\n\t\tfallthrough;\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tport_mode = EXT_GPHY;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_MII:\n\t\tport_mode = EXT_EPHY;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_REVMII:\n\t\tport_mode = EXT_REVMII;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn;\n\t}\n\n\treg_rgmii_ctrl = bcm_sf2_reg_rgmii_cntrl(priv, port);\n\n\t \n\treg = reg_readl(priv, reg_rgmii_ctrl);\n\treg &= ~ID_MODE_DIS;\n\treg &= ~(PORT_MODE_MASK << PORT_MODE_SHIFT);\n\n\treg |= port_mode;\n\tif (id_mode_dis)\n\t\treg |= ID_MODE_DIS;\n\n\treg_writel(priv, reg, reg_rgmii_ctrl);\n}\n\nstatic void bcm_sf2_sw_mac_link_set(struct dsa_switch *ds, int port,\n\t\t\t\t    phy_interface_t interface, bool link)\n{\n\tstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\n\tu32 reg_rgmii_ctrl;\n\tu32 reg;\n\n\tif (!phy_interface_mode_is_rgmii(interface) &&\n\t    interface != PHY_INTERFACE_MODE_MII &&\n\t    interface != PHY_INTERFACE_MODE_REVMII)\n\t\treturn;\n\n\treg_rgmii_ctrl = bcm_sf2_reg_rgmii_cntrl(priv, port);\n\n\t \n\treg = reg_readl(priv, reg_rgmii_ctrl);\n\tif (link)\n\t\treg |= RGMII_MODE_EN;\n\telse\n\t\treg &= ~RGMII_MODE_EN;\n\treg_writel(priv, reg, reg_rgmii_ctrl);\n}\n\nstatic void bcm_sf2_sw_mac_link_down(struct dsa_switch *ds, int port,\n\t\t\t\t     unsigned int mode,\n\t\t\t\t     phy_interface_t interface)\n{\n\tstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\n\tu32 reg, offset;\n\n\tif (priv->wol_ports_mask & BIT(port))\n\t\treturn;\n\n\toffset = bcm_sf2_port_override_offset(priv, port);\n\treg = core_readl(priv, offset);\n\treg &= ~LINK_STS;\n\tcore_writel(priv, reg, offset);\n\n\tbcm_sf2_sw_mac_link_set(ds, port, interface, false);\n}\n\nstatic void bcm_sf2_sw_mac_link_up(struct dsa_switch *ds, int port,\n\t\t\t\t   unsigned int mode,\n\t\t\t\t   phy_interface_t interface,\n\t\t\t\t   struct phy_device *phydev,\n\t\t\t\t   int speed, int duplex,\n\t\t\t\t   bool tx_pause, bool rx_pause)\n{\n\tstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\n\tstruct ethtool_eee *p = &priv->dev->ports[port].eee;\n\tu32 reg_rgmii_ctrl = 0;\n\tu32 reg, offset;\n\n\tbcm_sf2_sw_mac_link_set(ds, port, interface, true);\n\n\toffset = bcm_sf2_port_override_offset(priv, port);\n\n\tif (phy_interface_mode_is_rgmii(interface) ||\n\t    interface == PHY_INTERFACE_MODE_MII ||\n\t    interface == PHY_INTERFACE_MODE_REVMII) {\n\t\treg_rgmii_ctrl = bcm_sf2_reg_rgmii_cntrl(priv, port);\n\t\treg = reg_readl(priv, reg_rgmii_ctrl);\n\t\treg &= ~(RX_PAUSE_EN | TX_PAUSE_EN);\n\n\t\tif (tx_pause)\n\t\t\treg |= TX_PAUSE_EN;\n\t\tif (rx_pause)\n\t\t\treg |= RX_PAUSE_EN;\n\n\t\treg_writel(priv, reg, reg_rgmii_ctrl);\n\t}\n\n\treg = LINK_STS;\n\tif (port == 8) {\n\t\tif (priv->type == BCM4908_DEVICE_ID)\n\t\t\treg |= GMII_SPEED_UP_2G;\n\t\treg |= MII_SW_OR;\n\t} else {\n\t\treg |= SW_OVERRIDE;\n\t}\n\n\tswitch (speed) {\n\tcase SPEED_1000:\n\t\treg |= SPDSTS_1000 << SPEED_SHIFT;\n\t\tbreak;\n\tcase SPEED_100:\n\t\treg |= SPDSTS_100 << SPEED_SHIFT;\n\t\tbreak;\n\t}\n\n\tif (duplex == DUPLEX_FULL)\n\t\treg |= DUPLX_MODE;\n\n\tif (tx_pause)\n\t\treg |= TXFLOW_CNTL;\n\tif (rx_pause)\n\t\treg |= RXFLOW_CNTL;\n\n\tcore_writel(priv, reg, offset);\n\n\tif (mode == MLO_AN_PHY && phydev)\n\t\tp->eee_enabled = b53_eee_init(ds, port, phydev);\n}\n\nstatic void bcm_sf2_sw_fixed_state(struct dsa_switch *ds, int port,\n\t\t\t\t   struct phylink_link_state *status)\n{\n\tstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\n\n\tstatus->link = false;\n\n\t \n\tif (port == priv->moca_port) {\n\t\tstatus->link = priv->port_sts[port].link;\n\t\t \n\t\tif (!status->link)\n\t\t\tnetif_carrier_off(dsa_to_port(ds, port)->slave);\n\t\tstatus->duplex = DUPLEX_FULL;\n\t} else {\n\t\tstatus->link = true;\n\t}\n}\n\nstatic void bcm_sf2_enable_acb(struct dsa_switch *ds)\n{\n\tstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\n\tu32 reg;\n\n\t \n\treg = acb_readl(priv, ACB_CONTROL);\n\treg |= (ACB_FLUSH_MASK << ACB_FLUSH_SHIFT);\n\tacb_writel(priv, reg, ACB_CONTROL);\n\treg &= ~(ACB_FLUSH_MASK << ACB_FLUSH_SHIFT);\n\treg |= ACB_EN | ACB_ALGORITHM;\n\tacb_writel(priv, reg, ACB_CONTROL);\n}\n\nstatic int bcm_sf2_sw_suspend(struct dsa_switch *ds)\n{\n\tstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\n\tunsigned int port;\n\n\tbcm_sf2_intr_disable(priv);\n\n\t \n\tfor (port = 0; port < ds->num_ports; port++) {\n\t\tif (dsa_is_user_port(ds, port) || dsa_is_cpu_port(ds, port))\n\t\t\tbcm_sf2_port_disable(ds, port);\n\t}\n\n\tif (!priv->wol_ports_mask)\n\t\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n}\n\nstatic int bcm_sf2_sw_resume(struct dsa_switch *ds)\n{\n\tstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\n\tint ret;\n\n\tif (!priv->wol_ports_mask)\n\t\tclk_prepare_enable(priv->clk);\n\n\tret = bcm_sf2_sw_rst(priv);\n\tif (ret) {\n\t\tpr_err(\"%s: failed to software reset switch\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tbcm_sf2_crossbar_setup(priv);\n\n\tret = bcm_sf2_cfp_resume(ds);\n\tif (ret)\n\t\treturn ret;\n\n\tif (priv->hw_params.num_gphy == 1)\n\t\tbcm_sf2_gphy_enable_set(ds, true);\n\n\tds->ops->setup(ds);\n\n\treturn 0;\n}\n\nstatic void bcm_sf2_sw_get_wol(struct dsa_switch *ds, int port,\n\t\t\t       struct ethtool_wolinfo *wol)\n{\n\tstruct net_device *p = dsa_port_to_master(dsa_to_port(ds, port));\n\tstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\n\tstruct ethtool_wolinfo pwol = { };\n\n\t \n\tif (p->ethtool_ops->get_wol)\n\t\tp->ethtool_ops->get_wol(p, &pwol);\n\n\t \n\twol->supported = pwol.supported;\n\tmemset(&wol->sopass, 0, sizeof(wol->sopass));\n\n\tif (pwol.wolopts & WAKE_MAGICSECURE)\n\t\tmemcpy(&wol->sopass, pwol.sopass, sizeof(wol->sopass));\n\n\tif (priv->wol_ports_mask & (1 << port))\n\t\twol->wolopts = pwol.wolopts;\n\telse\n\t\twol->wolopts = 0;\n}\n\nstatic int bcm_sf2_sw_set_wol(struct dsa_switch *ds, int port,\n\t\t\t      struct ethtool_wolinfo *wol)\n{\n\tstruct net_device *p = dsa_port_to_master(dsa_to_port(ds, port));\n\tstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\n\ts8 cpu_port = dsa_to_port(ds, port)->cpu_dp->index;\n\tstruct ethtool_wolinfo pwol =  { };\n\n\tif (p->ethtool_ops->get_wol)\n\t\tp->ethtool_ops->get_wol(p, &pwol);\n\tif (wol->wolopts & ~pwol.supported)\n\t\treturn -EINVAL;\n\n\tif (wol->wolopts)\n\t\tpriv->wol_ports_mask |= (1 << port);\n\telse\n\t\tpriv->wol_ports_mask &= ~(1 << port);\n\n\t \n\tif (priv->wol_ports_mask && priv->wol_ports_mask != (1 << cpu_port))\n\t\tpriv->wol_ports_mask |= (1 << cpu_port);\n\telse\n\t\tpriv->wol_ports_mask &= ~(1 << cpu_port);\n\n\treturn p->ethtool_ops->set_wol(p, wol);\n}\n\nstatic int bcm_sf2_sw_setup(struct dsa_switch *ds)\n{\n\tstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\n\tunsigned int port;\n\n\t \n\tfor (port = 0; port < priv->hw_params.num_ports; port++) {\n\t\t \n\t\tif (dsa_is_user_port(ds, port))\n\t\t\tbcm_sf2_port_setup(ds, port, NULL);\n\t\telse if (dsa_is_cpu_port(ds, port))\n\t\t\tbcm_sf2_imp_setup(ds, port);\n\t\telse\n\t\t\tbcm_sf2_port_disable(ds, port);\n\t}\n\n\tb53_configure_vlan(ds);\n\tbcm_sf2_enable_acb(ds);\n\n\treturn b53_setup_devlink_resources(ds);\n}\n\nstatic void bcm_sf2_sw_teardown(struct dsa_switch *ds)\n{\n\tdsa_devlink_resources_unregister(ds);\n}\n\n \n#define SF2_PAGE_REG_MKADDR(page, reg)\t((page) << 10 | (reg) << 2)\n\nstatic int bcm_sf2_core_read8(struct b53_device *dev, u8 page, u8 reg,\n\t\t\t      u8 *val)\n{\n\tstruct bcm_sf2_priv *priv = dev->priv;\n\n\t*val = core_readl(priv, SF2_PAGE_REG_MKADDR(page, reg));\n\n\treturn 0;\n}\n\nstatic int bcm_sf2_core_read16(struct b53_device *dev, u8 page, u8 reg,\n\t\t\t       u16 *val)\n{\n\tstruct bcm_sf2_priv *priv = dev->priv;\n\n\t*val = core_readl(priv, SF2_PAGE_REG_MKADDR(page, reg));\n\n\treturn 0;\n}\n\nstatic int bcm_sf2_core_read32(struct b53_device *dev, u8 page, u8 reg,\n\t\t\t       u32 *val)\n{\n\tstruct bcm_sf2_priv *priv = dev->priv;\n\n\t*val = core_readl(priv, SF2_PAGE_REG_MKADDR(page, reg));\n\n\treturn 0;\n}\n\nstatic int bcm_sf2_core_read64(struct b53_device *dev, u8 page, u8 reg,\n\t\t\t       u64 *val)\n{\n\tstruct bcm_sf2_priv *priv = dev->priv;\n\n\t*val = core_readq(priv, SF2_PAGE_REG_MKADDR(page, reg));\n\n\treturn 0;\n}\n\nstatic int bcm_sf2_core_write8(struct b53_device *dev, u8 page, u8 reg,\n\t\t\t       u8 value)\n{\n\tstruct bcm_sf2_priv *priv = dev->priv;\n\n\tcore_writel(priv, value, SF2_PAGE_REG_MKADDR(page, reg));\n\n\treturn 0;\n}\n\nstatic int bcm_sf2_core_write16(struct b53_device *dev, u8 page, u8 reg,\n\t\t\t\tu16 value)\n{\n\tstruct bcm_sf2_priv *priv = dev->priv;\n\n\tcore_writel(priv, value, SF2_PAGE_REG_MKADDR(page, reg));\n\n\treturn 0;\n}\n\nstatic int bcm_sf2_core_write32(struct b53_device *dev, u8 page, u8 reg,\n\t\t\t\tu32 value)\n{\n\tstruct bcm_sf2_priv *priv = dev->priv;\n\n\tcore_writel(priv, value, SF2_PAGE_REG_MKADDR(page, reg));\n\n\treturn 0;\n}\n\nstatic int bcm_sf2_core_write64(struct b53_device *dev, u8 page, u8 reg,\n\t\t\t\tu64 value)\n{\n\tstruct bcm_sf2_priv *priv = dev->priv;\n\n\tcore_writeq(priv, value, SF2_PAGE_REG_MKADDR(page, reg));\n\n\treturn 0;\n}\n\nstatic const struct b53_io_ops bcm_sf2_io_ops = {\n\t.read8\t= bcm_sf2_core_read8,\n\t.read16\t= bcm_sf2_core_read16,\n\t.read32\t= bcm_sf2_core_read32,\n\t.read48\t= bcm_sf2_core_read64,\n\t.read64\t= bcm_sf2_core_read64,\n\t.write8\t= bcm_sf2_core_write8,\n\t.write16 = bcm_sf2_core_write16,\n\t.write32 = bcm_sf2_core_write32,\n\t.write48 = bcm_sf2_core_write64,\n\t.write64 = bcm_sf2_core_write64,\n};\n\nstatic void bcm_sf2_sw_get_strings(struct dsa_switch *ds, int port,\n\t\t\t\t   u32 stringset, uint8_t *data)\n{\n\tint cnt = b53_get_sset_count(ds, port, stringset);\n\n\tb53_get_strings(ds, port, stringset, data);\n\tbcm_sf2_cfp_get_strings(ds, port, stringset,\n\t\t\t\tdata + cnt * ETH_GSTRING_LEN);\n}\n\nstatic void bcm_sf2_sw_get_ethtool_stats(struct dsa_switch *ds, int port,\n\t\t\t\t\t uint64_t *data)\n{\n\tint cnt = b53_get_sset_count(ds, port, ETH_SS_STATS);\n\n\tb53_get_ethtool_stats(ds, port, data);\n\tbcm_sf2_cfp_get_ethtool_stats(ds, port, data + cnt);\n}\n\nstatic int bcm_sf2_sw_get_sset_count(struct dsa_switch *ds, int port,\n\t\t\t\t     int sset)\n{\n\tint cnt = b53_get_sset_count(ds, port, sset);\n\n\tif (cnt < 0)\n\t\treturn cnt;\n\n\tcnt += bcm_sf2_cfp_get_sset_count(ds, port, sset);\n\n\treturn cnt;\n}\n\nstatic const struct dsa_switch_ops bcm_sf2_ops = {\n\t.get_tag_protocol\t= b53_get_tag_protocol,\n\t.setup\t\t\t= bcm_sf2_sw_setup,\n\t.teardown\t\t= bcm_sf2_sw_teardown,\n\t.get_strings\t\t= bcm_sf2_sw_get_strings,\n\t.get_ethtool_stats\t= bcm_sf2_sw_get_ethtool_stats,\n\t.get_sset_count\t\t= bcm_sf2_sw_get_sset_count,\n\t.get_ethtool_phy_stats\t= b53_get_ethtool_phy_stats,\n\t.get_phy_flags\t\t= bcm_sf2_sw_get_phy_flags,\n\t.phylink_get_caps\t= bcm_sf2_sw_get_caps,\n\t.phylink_mac_config\t= bcm_sf2_sw_mac_config,\n\t.phylink_mac_link_down\t= bcm_sf2_sw_mac_link_down,\n\t.phylink_mac_link_up\t= bcm_sf2_sw_mac_link_up,\n\t.phylink_fixed_state\t= bcm_sf2_sw_fixed_state,\n\t.suspend\t\t= bcm_sf2_sw_suspend,\n\t.resume\t\t\t= bcm_sf2_sw_resume,\n\t.get_wol\t\t= bcm_sf2_sw_get_wol,\n\t.set_wol\t\t= bcm_sf2_sw_set_wol,\n\t.port_enable\t\t= bcm_sf2_port_setup,\n\t.port_disable\t\t= bcm_sf2_port_disable,\n\t.get_mac_eee\t\t= b53_get_mac_eee,\n\t.set_mac_eee\t\t= b53_set_mac_eee,\n\t.port_bridge_join\t= b53_br_join,\n\t.port_bridge_leave\t= b53_br_leave,\n\t.port_pre_bridge_flags\t= b53_br_flags_pre,\n\t.port_bridge_flags\t= b53_br_flags,\n\t.port_stp_state_set\t= b53_br_set_stp_state,\n\t.port_fast_age\t\t= b53_br_fast_age,\n\t.port_vlan_filtering\t= b53_vlan_filtering,\n\t.port_vlan_add\t\t= b53_vlan_add,\n\t.port_vlan_del\t\t= b53_vlan_del,\n\t.port_fdb_dump\t\t= b53_fdb_dump,\n\t.port_fdb_add\t\t= b53_fdb_add,\n\t.port_fdb_del\t\t= b53_fdb_del,\n\t.get_rxnfc\t\t= bcm_sf2_get_rxnfc,\n\t.set_rxnfc\t\t= bcm_sf2_set_rxnfc,\n\t.port_mirror_add\t= b53_mirror_add,\n\t.port_mirror_del\t= b53_mirror_del,\n\t.port_mdb_add\t\t= b53_mdb_add,\n\t.port_mdb_del\t\t= b53_mdb_del,\n};\n\nstruct bcm_sf2_of_data {\n\tu32 type;\n\tconst u16 *reg_offsets;\n\tunsigned int core_reg_align;\n\tunsigned int num_cfp_rules;\n\tunsigned int num_crossbar_int_ports;\n};\n\nstatic const u16 bcm_sf2_4908_reg_offsets[] = {\n\t[REG_SWITCH_CNTRL]\t= 0x00,\n\t[REG_SWITCH_STATUS]\t= 0x04,\n\t[REG_DIR_DATA_WRITE]\t= 0x08,\n\t[REG_DIR_DATA_READ]\t= 0x0c,\n\t[REG_SWITCH_REVISION]\t= 0x10,\n\t[REG_PHY_REVISION]\t= 0x14,\n\t[REG_SPHY_CNTRL]\t= 0x24,\n\t[REG_CROSSBAR]\t\t= 0xc8,\n\t[REG_RGMII_11_CNTRL]\t= 0x014c,\n\t[REG_LED_0_CNTRL]\t\t= 0x40,\n\t[REG_LED_1_CNTRL]\t\t= 0x4c,\n\t[REG_LED_2_CNTRL]\t\t= 0x58,\n\t[REG_LED_3_CNTRL]\t\t= 0x64,\n\t[REG_LED_4_CNTRL]\t\t= 0x88,\n\t[REG_LED_5_CNTRL]\t\t= 0xa0,\n\t[REG_LED_AGGREGATE_CTRL]\t= 0xb8,\n\n};\n\nstatic const struct bcm_sf2_of_data bcm_sf2_4908_data = {\n\t.type\t\t= BCM4908_DEVICE_ID,\n\t.core_reg_align\t= 0,\n\t.reg_offsets\t= bcm_sf2_4908_reg_offsets,\n\t.num_cfp_rules\t= 256,\n\t.num_crossbar_int_ports = 2,\n};\n\n \nstatic const u16 bcm_sf2_7445_reg_offsets[] = {\n\t[REG_SWITCH_CNTRL]\t= 0x00,\n\t[REG_SWITCH_STATUS]\t= 0x04,\n\t[REG_DIR_DATA_WRITE]\t= 0x08,\n\t[REG_DIR_DATA_READ]\t= 0x0C,\n\t[REG_SWITCH_REVISION]\t= 0x18,\n\t[REG_PHY_REVISION]\t= 0x1C,\n\t[REG_SPHY_CNTRL]\t= 0x2C,\n\t[REG_RGMII_0_CNTRL]\t= 0x34,\n\t[REG_RGMII_1_CNTRL]\t= 0x40,\n\t[REG_RGMII_2_CNTRL]\t= 0x4c,\n\t[REG_LED_0_CNTRL]\t= 0x90,\n\t[REG_LED_1_CNTRL]\t= 0x94,\n\t[REG_LED_2_CNTRL]\t= 0x98,\n};\n\nstatic const struct bcm_sf2_of_data bcm_sf2_7445_data = {\n\t.type\t\t= BCM7445_DEVICE_ID,\n\t.core_reg_align\t= 0,\n\t.reg_offsets\t= bcm_sf2_7445_reg_offsets,\n\t.num_cfp_rules\t= 256,\n};\n\nstatic const u16 bcm_sf2_7278_reg_offsets[] = {\n\t[REG_SWITCH_CNTRL]\t= 0x00,\n\t[REG_SWITCH_STATUS]\t= 0x04,\n\t[REG_DIR_DATA_WRITE]\t= 0x08,\n\t[REG_DIR_DATA_READ]\t= 0x0c,\n\t[REG_SWITCH_REVISION]\t= 0x10,\n\t[REG_PHY_REVISION]\t= 0x14,\n\t[REG_SPHY_CNTRL]\t= 0x24,\n\t[REG_RGMII_0_CNTRL]\t= 0xe0,\n\t[REG_RGMII_1_CNTRL]\t= 0xec,\n\t[REG_RGMII_2_CNTRL]\t= 0xf8,\n\t[REG_LED_0_CNTRL]\t= 0x40,\n\t[REG_LED_1_CNTRL]\t= 0x4c,\n\t[REG_LED_2_CNTRL]\t= 0x58,\n};\n\nstatic const struct bcm_sf2_of_data bcm_sf2_7278_data = {\n\t.type\t\t= BCM7278_DEVICE_ID,\n\t.core_reg_align\t= 1,\n\t.reg_offsets\t= bcm_sf2_7278_reg_offsets,\n\t.num_cfp_rules\t= 128,\n};\n\nstatic const struct of_device_id bcm_sf2_of_match[] = {\n\t{ .compatible = \"brcm,bcm4908-switch\",\n\t  .data = &bcm_sf2_4908_data\n\t},\n\t{ .compatible = \"brcm,bcm7445-switch-v4.0\",\n\t  .data = &bcm_sf2_7445_data\n\t},\n\t{ .compatible = \"brcm,bcm7278-switch-v4.0\",\n\t  .data = &bcm_sf2_7278_data\n\t},\n\t{ .compatible = \"brcm,bcm7278-switch-v4.8\",\n\t  .data = &bcm_sf2_7278_data\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, bcm_sf2_of_match);\n\nstatic int bcm_sf2_sw_probe(struct platform_device *pdev)\n{\n\tconst char *reg_names[BCM_SF2_REGS_NUM] = BCM_SF2_REGS_NAME;\n\tstruct device_node *dn = pdev->dev.of_node;\n\tconst struct of_device_id *of_id = NULL;\n\tconst struct bcm_sf2_of_data *data;\n\tstruct b53_platform_data *pdata;\n\tstruct dsa_switch_ops *ops;\n\tstruct device_node *ports;\n\tstruct bcm_sf2_priv *priv;\n\tstruct b53_device *dev;\n\tstruct dsa_switch *ds;\n\tvoid __iomem **base;\n\tunsigned int i;\n\tu32 reg, rev;\n\tint ret;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tops = devm_kzalloc(&pdev->dev, sizeof(*ops), GFP_KERNEL);\n\tif (!ops)\n\t\treturn -ENOMEM;\n\n\tdev = b53_switch_alloc(&pdev->dev, &bcm_sf2_io_ops, priv);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tof_id = of_match_node(bcm_sf2_of_match, dn);\n\tif (!of_id || !of_id->data)\n\t\treturn -EINVAL;\n\n\tdata = of_id->data;\n\n\t \n\tpriv->type = data->type;\n\tpriv->reg_offsets = data->reg_offsets;\n\tpriv->core_reg_align = data->core_reg_align;\n\tpriv->num_cfp_rules = data->num_cfp_rules;\n\tpriv->num_crossbar_int_ports = data->num_crossbar_int_ports;\n\n\tpriv->rcdev = devm_reset_control_get_optional_exclusive(&pdev->dev,\n\t\t\t\t\t\t\t\t\"switch\");\n\tif (IS_ERR(priv->rcdev))\n\t\treturn PTR_ERR(priv->rcdev);\n\n\t \n\tpdata->chip_id = priv->type;\n\tdev->pdata = pdata;\n\n\tpriv->dev = dev;\n\tds = dev->ds;\n\tds->ops = &bcm_sf2_ops;\n\n\t \n\tds->num_tx_queues = SF2_NUM_EGRESS_QUEUES;\n\n\tdev_set_drvdata(&pdev->dev, priv);\n\n\tspin_lock_init(&priv->indir_lock);\n\tmutex_init(&priv->cfp.lock);\n\tINIT_LIST_HEAD(&priv->cfp.rules_list);\n\n\t \n\tset_bit(0, priv->cfp.used);\n\tset_bit(0, priv->cfp.unique);\n\n\t \n\tof_node_get(dn);\n\tports = of_find_node_by_name(dn, \"ports\");\n\tif (ports) {\n\t\tbcm_sf2_identify_ports(priv, ports);\n\t\tof_node_put(ports);\n\t}\n\n\tpriv->irq0 = irq_of_parse_and_map(dn, 0);\n\tpriv->irq1 = irq_of_parse_and_map(dn, 1);\n\n\tbase = &priv->core;\n\tfor (i = 0; i < BCM_SF2_REGS_NUM; i++) {\n\t\t*base = devm_platform_ioremap_resource(pdev, i);\n\t\tif (IS_ERR(*base)) {\n\t\t\tpr_err(\"unable to find register: %s\\n\", reg_names[i]);\n\t\t\treturn PTR_ERR(*base);\n\t\t}\n\t\tbase++;\n\t}\n\n\tpriv->clk = devm_clk_get_optional(&pdev->dev, \"sw_switch\");\n\tif (IS_ERR(priv->clk))\n\t\treturn PTR_ERR(priv->clk);\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->clk_mdiv = devm_clk_get_optional(&pdev->dev, \"sw_switch_mdiv\");\n\tif (IS_ERR(priv->clk_mdiv)) {\n\t\tret = PTR_ERR(priv->clk_mdiv);\n\t\tgoto out_clk;\n\t}\n\n\tret = clk_prepare_enable(priv->clk_mdiv);\n\tif (ret)\n\t\tgoto out_clk;\n\n\tret = bcm_sf2_sw_rst(priv);\n\tif (ret) {\n\t\tpr_err(\"unable to software reset switch: %d\\n\", ret);\n\t\tgoto out_clk_mdiv;\n\t}\n\n\tbcm_sf2_crossbar_setup(priv);\n\n\tbcm_sf2_gphy_enable_set(priv->dev->ds, true);\n\n\tret = bcm_sf2_mdio_register(ds);\n\tif (ret) {\n\t\tpr_err(\"failed to register MDIO bus\\n\");\n\t\tgoto out_clk_mdiv;\n\t}\n\n\tbcm_sf2_gphy_enable_set(priv->dev->ds, false);\n\n\tret = bcm_sf2_cfp_rst(priv);\n\tif (ret) {\n\t\tpr_err(\"failed to reset CFP\\n\");\n\t\tgoto out_mdio;\n\t}\n\n\t \n\tbcm_sf2_intr_disable(priv);\n\n\tret = devm_request_irq(&pdev->dev, priv->irq0, bcm_sf2_switch_0_isr, 0,\n\t\t\t       \"switch_0\", ds);\n\tif (ret < 0) {\n\t\tpr_err(\"failed to request switch_0 IRQ\\n\");\n\t\tgoto out_mdio;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, priv->irq1, bcm_sf2_switch_1_isr, 0,\n\t\t\t       \"switch_1\", ds);\n\tif (ret < 0) {\n\t\tpr_err(\"failed to request switch_1 IRQ\\n\");\n\t\tgoto out_mdio;\n\t}\n\n\t \n\treg = core_readl(priv, CORE_GMNCFGCFG);\n\treg |= RST_MIB_CNT;\n\tcore_writel(priv, reg, CORE_GMNCFGCFG);\n\treg &= ~RST_MIB_CNT;\n\tcore_writel(priv, reg, CORE_GMNCFGCFG);\n\n\t \n\tpriv->hw_params.num_ports = core_readl(priv, CORE_IMP0_PRT_ID) + 1;\n\tif (priv->hw_params.num_ports > DSA_MAX_PORTS)\n\t\tpriv->hw_params.num_ports = DSA_MAX_PORTS;\n\n\t \n\tif (of_property_read_u32(dn, \"brcm,num-gphy\",\n\t\t\t\t &priv->hw_params.num_gphy))\n\t\tpriv->hw_params.num_gphy = 1;\n\n\trev = reg_readl(priv, REG_SWITCH_REVISION);\n\tpriv->hw_params.top_rev = (rev >> SWITCH_TOP_REV_SHIFT) &\n\t\t\t\t\tSWITCH_TOP_REV_MASK;\n\tpriv->hw_params.core_rev = (rev & SF2_REV_MASK);\n\n\trev = reg_readl(priv, REG_PHY_REVISION);\n\tpriv->hw_params.gphy_rev = rev & PHY_REVISION_MASK;\n\n\tret = b53_switch_register(dev);\n\tif (ret)\n\t\tgoto out_mdio;\n\n\tdev_info(&pdev->dev,\n\t\t \"Starfighter 2 top: %x.%02x, core: %x.%02x, IRQs: %d, %d\\n\",\n\t\t priv->hw_params.top_rev >> 8, priv->hw_params.top_rev & 0xff,\n\t\t priv->hw_params.core_rev >> 8, priv->hw_params.core_rev & 0xff,\n\t\t priv->irq0, priv->irq1);\n\n\treturn 0;\n\nout_mdio:\n\tbcm_sf2_mdio_unregister(priv);\nout_clk_mdiv:\n\tclk_disable_unprepare(priv->clk_mdiv);\nout_clk:\n\tclk_disable_unprepare(priv->clk);\n\treturn ret;\n}\n\nstatic int bcm_sf2_sw_remove(struct platform_device *pdev)\n{\n\tstruct bcm_sf2_priv *priv = platform_get_drvdata(pdev);\n\n\tif (!priv)\n\t\treturn 0;\n\n\tpriv->wol_ports_mask = 0;\n\t \n\tbcm_sf2_intr_disable(priv);\n\tdsa_unregister_switch(priv->dev->ds);\n\tbcm_sf2_cfp_exit(priv->dev->ds);\n\tbcm_sf2_mdio_unregister(priv);\n\tclk_disable_unprepare(priv->clk_mdiv);\n\tclk_disable_unprepare(priv->clk);\n\tif (priv->type == BCM7278_DEVICE_ID)\n\t\treset_control_assert(priv->rcdev);\n\n\treturn 0;\n}\n\nstatic void bcm_sf2_sw_shutdown(struct platform_device *pdev)\n{\n\tstruct bcm_sf2_priv *priv = platform_get_drvdata(pdev);\n\n\tif (!priv)\n\t\treturn;\n\n\t \n\tif (priv->hw_params.num_gphy == 1)\n\t\tbcm_sf2_gphy_enable_set(priv->dev->ds, true);\n\n\tdsa_switch_shutdown(priv->dev->ds);\n\n\tplatform_set_drvdata(pdev, NULL);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int bcm_sf2_suspend(struct device *dev)\n{\n\tstruct bcm_sf2_priv *priv = dev_get_drvdata(dev);\n\n\treturn dsa_switch_suspend(priv->dev->ds);\n}\n\nstatic int bcm_sf2_resume(struct device *dev)\n{\n\tstruct bcm_sf2_priv *priv = dev_get_drvdata(dev);\n\n\treturn dsa_switch_resume(priv->dev->ds);\n}\n#endif  \n\nstatic SIMPLE_DEV_PM_OPS(bcm_sf2_pm_ops,\n\t\t\t bcm_sf2_suspend, bcm_sf2_resume);\n\n\nstatic struct platform_driver bcm_sf2_driver = {\n\t.probe\t= bcm_sf2_sw_probe,\n\t.remove\t= bcm_sf2_sw_remove,\n\t.shutdown = bcm_sf2_sw_shutdown,\n\t.driver = {\n\t\t.name = \"brcm-sf2\",\n\t\t.of_match_table = bcm_sf2_of_match,\n\t\t.pm = &bcm_sf2_pm_ops,\n\t},\n};\nmodule_platform_driver(bcm_sf2_driver);\n\nMODULE_AUTHOR(\"Broadcom Corporation\");\nMODULE_DESCRIPTION(\"Driver for Broadcom Starfighter 2 ethernet switch chip\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:brcm-sf2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}