{
  "module_name": "sja1105_clocking.c",
  "hash_id": "36e656ad092542267ca7c27bf6f9a7a4b3db12823929340bb30c9efcc36e9154",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/sja1105/sja1105_clocking.c",
  "human_readable_source": "\n \n#include <linux/packing.h>\n#include \"sja1105.h\"\n\n#define SJA1105_SIZE_CGU_CMD\t4\n#define SJA1110_BASE_MCSS_CLK\tSJA1110_CGU_ADDR(0x70)\n#define SJA1110_BASE_TIMER_CLK\tSJA1110_CGU_ADDR(0x74)\n\n \nstruct sja1105_cfg_pad_mii {\n\tu64 d32_os;\n\tu64 d32_ih;\n\tu64 d32_ipud;\n\tu64 d10_ih;\n\tu64 d10_os;\n\tu64 d10_ipud;\n\tu64 ctrl_os;\n\tu64 ctrl_ih;\n\tu64 ctrl_ipud;\n\tu64 clk_os;\n\tu64 clk_ih;\n\tu64 clk_ipud;\n};\n\nstruct sja1105_cfg_pad_mii_id {\n\tu64 rxc_stable_ovr;\n\tu64 rxc_delay;\n\tu64 rxc_bypass;\n\tu64 rxc_pd;\n\tu64 txc_stable_ovr;\n\tu64 txc_delay;\n\tu64 txc_bypass;\n\tu64 txc_pd;\n};\n\n \nstruct sja1105_cgu_idiv {\n\tu64 clksrc;\n\tu64 autoblock;\n\tu64 idiv;\n\tu64 pd;\n};\n\n \nstruct sja1105_cgu_pll_ctrl {\n\tu64 pllclksrc;\n\tu64 msel;\n\tu64 autoblock;\n\tu64 psel;\n\tu64 direct;\n\tu64 fbsel;\n\tu64 bypass;\n\tu64 pd;\n};\n\nstruct sja1110_cgu_outclk {\n\tu64 clksrc;\n\tu64 autoblock;\n\tu64 pd;\n};\n\nenum {\n\tCLKSRC_MII0_TX_CLK\t= 0x00,\n\tCLKSRC_MII0_RX_CLK\t= 0x01,\n\tCLKSRC_MII1_TX_CLK\t= 0x02,\n\tCLKSRC_MII1_RX_CLK\t= 0x03,\n\tCLKSRC_MII2_TX_CLK\t= 0x04,\n\tCLKSRC_MII2_RX_CLK\t= 0x05,\n\tCLKSRC_MII3_TX_CLK\t= 0x06,\n\tCLKSRC_MII3_RX_CLK\t= 0x07,\n\tCLKSRC_MII4_TX_CLK\t= 0x08,\n\tCLKSRC_MII4_RX_CLK\t= 0x09,\n\tCLKSRC_PLL0\t\t= 0x0B,\n\tCLKSRC_PLL1\t\t= 0x0E,\n\tCLKSRC_IDIV0\t\t= 0x11,\n\tCLKSRC_IDIV1\t\t= 0x12,\n\tCLKSRC_IDIV2\t\t= 0x13,\n\tCLKSRC_IDIV3\t\t= 0x14,\n\tCLKSRC_IDIV4\t\t= 0x15,\n};\n\n \nstruct sja1105_cgu_mii_ctrl {\n\tu64 clksrc;\n\tu64 autoblock;\n\tu64 pd;\n};\n\nstatic void sja1105_cgu_idiv_packing(void *buf, struct sja1105_cgu_idiv *idiv,\n\t\t\t\t     enum packing_op op)\n{\n\tconst int size = 4;\n\n\tsja1105_packing(buf, &idiv->clksrc,    28, 24, size, op);\n\tsja1105_packing(buf, &idiv->autoblock, 11, 11, size, op);\n\tsja1105_packing(buf, &idiv->idiv,       5,  2, size, op);\n\tsja1105_packing(buf, &idiv->pd,         0,  0, size, op);\n}\n\nstatic int sja1105_cgu_idiv_config(struct sja1105_private *priv, int port,\n\t\t\t\t   bool enabled, int factor)\n{\n\tconst struct sja1105_regs *regs = priv->info->regs;\n\tstruct device *dev = priv->ds->dev;\n\tstruct sja1105_cgu_idiv idiv;\n\tu8 packed_buf[SJA1105_SIZE_CGU_CMD] = {0};\n\n\tif (regs->cgu_idiv[port] == SJA1105_RSV_ADDR)\n\t\treturn 0;\n\n\tif (enabled && factor != 1 && factor != 10) {\n\t\tdev_err(dev, \"idiv factor must be 1 or 10\\n\");\n\t\treturn -ERANGE;\n\t}\n\n\t \n\tidiv.clksrc    = 0x0A;             \n\tidiv.autoblock = 1;                \n\tidiv.idiv      = factor - 1;       \n\tidiv.pd        = enabled ? 0 : 1;  \n\tsja1105_cgu_idiv_packing(packed_buf, &idiv, PACK);\n\n\treturn sja1105_xfer_buf(priv, SPI_WRITE, regs->cgu_idiv[port],\n\t\t\t\tpacked_buf, SJA1105_SIZE_CGU_CMD);\n}\n\nstatic void\nsja1105_cgu_mii_control_packing(void *buf, struct sja1105_cgu_mii_ctrl *cmd,\n\t\t\t\tenum packing_op op)\n{\n\tconst int size = 4;\n\n\tsja1105_packing(buf, &cmd->clksrc,    28, 24, size, op);\n\tsja1105_packing(buf, &cmd->autoblock, 11, 11, size, op);\n\tsja1105_packing(buf, &cmd->pd,         0,  0, size, op);\n}\n\nstatic int sja1105_cgu_mii_tx_clk_config(struct sja1105_private *priv,\n\t\t\t\t\t int port, sja1105_mii_role_t role)\n{\n\tconst struct sja1105_regs *regs = priv->info->regs;\n\tstruct sja1105_cgu_mii_ctrl mii_tx_clk;\n\tconst int mac_clk_sources[] = {\n\t\tCLKSRC_MII0_TX_CLK,\n\t\tCLKSRC_MII1_TX_CLK,\n\t\tCLKSRC_MII2_TX_CLK,\n\t\tCLKSRC_MII3_TX_CLK,\n\t\tCLKSRC_MII4_TX_CLK,\n\t};\n\tconst int phy_clk_sources[] = {\n\t\tCLKSRC_IDIV0,\n\t\tCLKSRC_IDIV1,\n\t\tCLKSRC_IDIV2,\n\t\tCLKSRC_IDIV3,\n\t\tCLKSRC_IDIV4,\n\t};\n\tu8 packed_buf[SJA1105_SIZE_CGU_CMD] = {0};\n\tint clksrc;\n\n\tif (regs->mii_tx_clk[port] == SJA1105_RSV_ADDR)\n\t\treturn 0;\n\n\tif (role == XMII_MAC)\n\t\tclksrc = mac_clk_sources[port];\n\telse\n\t\tclksrc = phy_clk_sources[port];\n\n\t \n\tmii_tx_clk.clksrc    = clksrc;\n\tmii_tx_clk.autoblock = 1;   \n\tmii_tx_clk.pd        = 0;   \n\tsja1105_cgu_mii_control_packing(packed_buf, &mii_tx_clk, PACK);\n\n\treturn sja1105_xfer_buf(priv, SPI_WRITE, regs->mii_tx_clk[port],\n\t\t\t\tpacked_buf, SJA1105_SIZE_CGU_CMD);\n}\n\nstatic int\nsja1105_cgu_mii_rx_clk_config(struct sja1105_private *priv, int port)\n{\n\tconst struct sja1105_regs *regs = priv->info->regs;\n\tstruct sja1105_cgu_mii_ctrl mii_rx_clk;\n\tu8 packed_buf[SJA1105_SIZE_CGU_CMD] = {0};\n\tconst int clk_sources[] = {\n\t\tCLKSRC_MII0_RX_CLK,\n\t\tCLKSRC_MII1_RX_CLK,\n\t\tCLKSRC_MII2_RX_CLK,\n\t\tCLKSRC_MII3_RX_CLK,\n\t\tCLKSRC_MII4_RX_CLK,\n\t};\n\n\tif (regs->mii_rx_clk[port] == SJA1105_RSV_ADDR)\n\t\treturn 0;\n\n\t \n\tmii_rx_clk.clksrc    = clk_sources[port];\n\tmii_rx_clk.autoblock = 1;   \n\tmii_rx_clk.pd        = 0;   \n\tsja1105_cgu_mii_control_packing(packed_buf, &mii_rx_clk, PACK);\n\n\treturn sja1105_xfer_buf(priv, SPI_WRITE, regs->mii_rx_clk[port],\n\t\t\t\tpacked_buf, SJA1105_SIZE_CGU_CMD);\n}\n\nstatic int\nsja1105_cgu_mii_ext_tx_clk_config(struct sja1105_private *priv, int port)\n{\n\tconst struct sja1105_regs *regs = priv->info->regs;\n\tstruct sja1105_cgu_mii_ctrl mii_ext_tx_clk;\n\tu8 packed_buf[SJA1105_SIZE_CGU_CMD] = {0};\n\tconst int clk_sources[] = {\n\t\tCLKSRC_IDIV0,\n\t\tCLKSRC_IDIV1,\n\t\tCLKSRC_IDIV2,\n\t\tCLKSRC_IDIV3,\n\t\tCLKSRC_IDIV4,\n\t};\n\n\tif (regs->mii_ext_tx_clk[port] == SJA1105_RSV_ADDR)\n\t\treturn 0;\n\n\t \n\tmii_ext_tx_clk.clksrc    = clk_sources[port];\n\tmii_ext_tx_clk.autoblock = 1;  \n\tmii_ext_tx_clk.pd        = 0;  \n\tsja1105_cgu_mii_control_packing(packed_buf, &mii_ext_tx_clk, PACK);\n\n\treturn sja1105_xfer_buf(priv, SPI_WRITE, regs->mii_ext_tx_clk[port],\n\t\t\t\tpacked_buf, SJA1105_SIZE_CGU_CMD);\n}\n\nstatic int\nsja1105_cgu_mii_ext_rx_clk_config(struct sja1105_private *priv, int port)\n{\n\tconst struct sja1105_regs *regs = priv->info->regs;\n\tstruct sja1105_cgu_mii_ctrl mii_ext_rx_clk;\n\tu8 packed_buf[SJA1105_SIZE_CGU_CMD] = {0};\n\tconst int clk_sources[] = {\n\t\tCLKSRC_IDIV0,\n\t\tCLKSRC_IDIV1,\n\t\tCLKSRC_IDIV2,\n\t\tCLKSRC_IDIV3,\n\t\tCLKSRC_IDIV4,\n\t};\n\n\tif (regs->mii_ext_rx_clk[port] == SJA1105_RSV_ADDR)\n\t\treturn 0;\n\n\t \n\tmii_ext_rx_clk.clksrc    = clk_sources[port];\n\tmii_ext_rx_clk.autoblock = 1;  \n\tmii_ext_rx_clk.pd        = 0;  \n\tsja1105_cgu_mii_control_packing(packed_buf, &mii_ext_rx_clk, PACK);\n\n\treturn sja1105_xfer_buf(priv, SPI_WRITE, regs->mii_ext_rx_clk[port],\n\t\t\t\tpacked_buf, SJA1105_SIZE_CGU_CMD);\n}\n\nstatic int sja1105_mii_clocking_setup(struct sja1105_private *priv, int port,\n\t\t\t\t      sja1105_mii_role_t role)\n{\n\tstruct device *dev = priv->ds->dev;\n\tint rc;\n\n\tdev_dbg(dev, \"Configuring MII-%s clocking\\n\",\n\t\t(role == XMII_MAC) ? \"MAC\" : \"PHY\");\n\t \n\trc = sja1105_cgu_idiv_config(priv, port, (role == XMII_PHY), 1);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = sja1105_cgu_mii_tx_clk_config(priv, port, role);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = sja1105_cgu_mii_rx_clk_config(priv, port);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (role == XMII_PHY) {\n\t\t \n\n\t\t \n\t\trc = sja1105_cgu_mii_ext_tx_clk_config(priv, port);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t \n\t\trc = sja1105_cgu_mii_ext_rx_clk_config(priv, port);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic void\nsja1105_cgu_pll_control_packing(void *buf, struct sja1105_cgu_pll_ctrl *cmd,\n\t\t\t\tenum packing_op op)\n{\n\tconst int size = 4;\n\n\tsja1105_packing(buf, &cmd->pllclksrc, 28, 24, size, op);\n\tsja1105_packing(buf, &cmd->msel,      23, 16, size, op);\n\tsja1105_packing(buf, &cmd->autoblock, 11, 11, size, op);\n\tsja1105_packing(buf, &cmd->psel,       9,  8, size, op);\n\tsja1105_packing(buf, &cmd->direct,     7,  7, size, op);\n\tsja1105_packing(buf, &cmd->fbsel,      6,  6, size, op);\n\tsja1105_packing(buf, &cmd->bypass,     1,  1, size, op);\n\tsja1105_packing(buf, &cmd->pd,         0,  0, size, op);\n}\n\nstatic int sja1105_cgu_rgmii_tx_clk_config(struct sja1105_private *priv,\n\t\t\t\t\t   int port, u64 speed)\n{\n\tconst struct sja1105_regs *regs = priv->info->regs;\n\tstruct sja1105_cgu_mii_ctrl txc;\n\tu8 packed_buf[SJA1105_SIZE_CGU_CMD] = {0};\n\tint clksrc;\n\n\tif (regs->rgmii_tx_clk[port] == SJA1105_RSV_ADDR)\n\t\treturn 0;\n\n\tif (speed == priv->info->port_speed[SJA1105_SPEED_1000MBPS]) {\n\t\tclksrc = CLKSRC_PLL0;\n\t} else {\n\t\tint clk_sources[] = {CLKSRC_IDIV0, CLKSRC_IDIV1, CLKSRC_IDIV2,\n\t\t\t\t     CLKSRC_IDIV3, CLKSRC_IDIV4};\n\t\tclksrc = clk_sources[port];\n\t}\n\n\t \n\ttxc.clksrc = clksrc;\n\t \n\ttxc.autoblock = 1;\n\t \n\ttxc.pd = 0;\n\tsja1105_cgu_mii_control_packing(packed_buf, &txc, PACK);\n\n\treturn sja1105_xfer_buf(priv, SPI_WRITE, regs->rgmii_tx_clk[port],\n\t\t\t\tpacked_buf, SJA1105_SIZE_CGU_CMD);\n}\n\n \nstatic void\nsja1105_cfg_pad_mii_packing(void *buf, struct sja1105_cfg_pad_mii *cmd,\n\t\t\t    enum packing_op op)\n{\n\tconst int size = 4;\n\n\tsja1105_packing(buf, &cmd->d32_os,   28, 27, size, op);\n\tsja1105_packing(buf, &cmd->d32_ih,   26, 26, size, op);\n\tsja1105_packing(buf, &cmd->d32_ipud, 25, 24, size, op);\n\tsja1105_packing(buf, &cmd->d10_os,   20, 19, size, op);\n\tsja1105_packing(buf, &cmd->d10_ih,   18, 18, size, op);\n\tsja1105_packing(buf, &cmd->d10_ipud, 17, 16, size, op);\n\tsja1105_packing(buf, &cmd->ctrl_os,  12, 11, size, op);\n\tsja1105_packing(buf, &cmd->ctrl_ih,  10, 10, size, op);\n\tsja1105_packing(buf, &cmd->ctrl_ipud, 9,  8, size, op);\n\tsja1105_packing(buf, &cmd->clk_os,    4,  3, size, op);\n\tsja1105_packing(buf, &cmd->clk_ih,    2,  2, size, op);\n\tsja1105_packing(buf, &cmd->clk_ipud,  1,  0, size, op);\n}\n\nstatic int sja1105_rgmii_cfg_pad_tx_config(struct sja1105_private *priv,\n\t\t\t\t\t   int port)\n{\n\tconst struct sja1105_regs *regs = priv->info->regs;\n\tstruct sja1105_cfg_pad_mii pad_mii_tx = {0};\n\tu8 packed_buf[SJA1105_SIZE_CGU_CMD] = {0};\n\n\tif (regs->pad_mii_tx[port] == SJA1105_RSV_ADDR)\n\t\treturn 0;\n\n\t \n\tpad_mii_tx.d32_os    = 3;  \n\t\t\t\t   \n\tpad_mii_tx.d10_os    = 3;  \n\t\t\t\t   \n\tpad_mii_tx.d32_ipud  = 2;  \n\t\t\t\t   \n\tpad_mii_tx.d10_ipud  = 2;  \n\t\t\t\t   \n\tpad_mii_tx.ctrl_os   = 3;  \n\tpad_mii_tx.ctrl_ipud = 2;  \n\tpad_mii_tx.clk_os    = 3;  \n\tpad_mii_tx.clk_ih    = 0;  \n\tpad_mii_tx.clk_ipud  = 2;  \n\tsja1105_cfg_pad_mii_packing(packed_buf, &pad_mii_tx, PACK);\n\n\treturn sja1105_xfer_buf(priv, SPI_WRITE, regs->pad_mii_tx[port],\n\t\t\t\tpacked_buf, SJA1105_SIZE_CGU_CMD);\n}\n\nstatic int sja1105_cfg_pad_rx_config(struct sja1105_private *priv, int port)\n{\n\tconst struct sja1105_regs *regs = priv->info->regs;\n\tstruct sja1105_cfg_pad_mii pad_mii_rx = {0};\n\tu8 packed_buf[SJA1105_SIZE_CGU_CMD] = {0};\n\n\tif (regs->pad_mii_rx[port] == SJA1105_RSV_ADDR)\n\t\treturn 0;\n\n\t \n\tpad_mii_rx.d32_ih    = 0;  \n\t\t\t\t   \n\tpad_mii_rx.d32_ipud  = 2;  \n\t\t\t\t   \n\tpad_mii_rx.d10_ih    = 0;  \n\t\t\t\t   \n\tpad_mii_rx.d10_ipud  = 2;  \n\t\t\t\t   \n\tpad_mii_rx.ctrl_ih   = 0;  \n\t\t\t\t   \n\t\t\t\t   \n\tpad_mii_rx.ctrl_ipud = 3;  \n\t\t\t\t   \n\t\t\t\t   \n\tpad_mii_rx.clk_os    = 2;  \n\t\t\t\t   \n\tpad_mii_rx.clk_ih    = 0;  \n\t\t\t\t   \n\tpad_mii_rx.clk_ipud  = 2;  \n\t\t\t\t   \n\tsja1105_cfg_pad_mii_packing(packed_buf, &pad_mii_rx, PACK);\n\n\treturn sja1105_xfer_buf(priv, SPI_WRITE, regs->pad_mii_rx[port],\n\t\t\t\tpacked_buf, SJA1105_SIZE_CGU_CMD);\n}\n\nstatic void\nsja1105_cfg_pad_mii_id_packing(void *buf, struct sja1105_cfg_pad_mii_id *cmd,\n\t\t\t       enum packing_op op)\n{\n\tconst int size = SJA1105_SIZE_CGU_CMD;\n\n\tsja1105_packing(buf, &cmd->rxc_stable_ovr, 15, 15, size, op);\n\tsja1105_packing(buf, &cmd->rxc_delay,      14, 10, size, op);\n\tsja1105_packing(buf, &cmd->rxc_bypass,      9,  9, size, op);\n\tsja1105_packing(buf, &cmd->rxc_pd,          8,  8, size, op);\n\tsja1105_packing(buf, &cmd->txc_stable_ovr,  7,  7, size, op);\n\tsja1105_packing(buf, &cmd->txc_delay,       6,  2, size, op);\n\tsja1105_packing(buf, &cmd->txc_bypass,      1,  1, size, op);\n\tsja1105_packing(buf, &cmd->txc_pd,          0,  0, size, op);\n}\n\nstatic void\nsja1110_cfg_pad_mii_id_packing(void *buf, struct sja1105_cfg_pad_mii_id *cmd,\n\t\t\t       enum packing_op op)\n{\n\tconst int size = SJA1105_SIZE_CGU_CMD;\n\tu64 range = 4;\n\n\t \n\tsja1105_packing(buf, &cmd->rxc_stable_ovr, 26, 26, size, op);\n\tsja1105_packing(buf, &cmd->rxc_delay,      25, 21, size, op);\n\tsja1105_packing(buf, &range,               20, 18, size, op);\n\tsja1105_packing(buf, &cmd->rxc_bypass,     17, 17, size, op);\n\tsja1105_packing(buf, &cmd->rxc_pd,         16, 16, size, op);\n\tsja1105_packing(buf, &cmd->txc_stable_ovr, 10, 10, size, op);\n\tsja1105_packing(buf, &cmd->txc_delay,       9,  5, size, op);\n\tsja1105_packing(buf, &range,                4,  2, size, op);\n\tsja1105_packing(buf, &cmd->txc_bypass,      1,  1, size, op);\n\tsja1105_packing(buf, &cmd->txc_pd,          0,  0, size, op);\n}\n\n \nint sja1105pqrs_setup_rgmii_delay(const void *ctx, int port)\n{\n\tconst struct sja1105_private *priv = ctx;\n\tconst struct sja1105_regs *regs = priv->info->regs;\n\tstruct sja1105_cfg_pad_mii_id pad_mii_id = {0};\n\tint rx_delay = priv->rgmii_rx_delay_ps[port];\n\tint tx_delay = priv->rgmii_tx_delay_ps[port];\n\tu8 packed_buf[SJA1105_SIZE_CGU_CMD] = {0};\n\tint rc;\n\n\tif (rx_delay)\n\t\tpad_mii_id.rxc_delay = SJA1105_RGMII_DELAY_PS_TO_HW(rx_delay);\n\tif (tx_delay)\n\t\tpad_mii_id.txc_delay = SJA1105_RGMII_DELAY_PS_TO_HW(tx_delay);\n\n\t \n\tpad_mii_id.rxc_bypass = 1;\n\tpad_mii_id.rxc_pd = 1;\n\tpad_mii_id.txc_bypass = 1;\n\tpad_mii_id.txc_pd = 1;\n\tsja1105_cfg_pad_mii_id_packing(packed_buf, &pad_mii_id, PACK);\n\n\trc = sja1105_xfer_buf(priv, SPI_WRITE, regs->pad_mii_id[port],\n\t\t\t      packed_buf, SJA1105_SIZE_CGU_CMD);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tif (rx_delay) {\n\t\tpad_mii_id.rxc_bypass = 0;\n\t\tpad_mii_id.rxc_pd = 0;\n\t}\n\tif (tx_delay) {\n\t\tpad_mii_id.txc_bypass = 0;\n\t\tpad_mii_id.txc_pd = 0;\n\t}\n\tsja1105_cfg_pad_mii_id_packing(packed_buf, &pad_mii_id, PACK);\n\n\treturn sja1105_xfer_buf(priv, SPI_WRITE, regs->pad_mii_id[port],\n\t\t\t\tpacked_buf, SJA1105_SIZE_CGU_CMD);\n}\n\nint sja1110_setup_rgmii_delay(const void *ctx, int port)\n{\n\tconst struct sja1105_private *priv = ctx;\n\tconst struct sja1105_regs *regs = priv->info->regs;\n\tstruct sja1105_cfg_pad_mii_id pad_mii_id = {0};\n\tint rx_delay = priv->rgmii_rx_delay_ps[port];\n\tint tx_delay = priv->rgmii_tx_delay_ps[port];\n\tu8 packed_buf[SJA1105_SIZE_CGU_CMD] = {0};\n\n\tpad_mii_id.rxc_pd = 1;\n\tpad_mii_id.txc_pd = 1;\n\n\tif (rx_delay) {\n\t\tpad_mii_id.rxc_delay = SJA1105_RGMII_DELAY_PS_TO_HW(rx_delay);\n\t\t \n\t\tpad_mii_id.rxc_bypass = 1;\n\t\tpad_mii_id.rxc_pd = 0;\n\t}\n\n\tif (tx_delay) {\n\t\tpad_mii_id.txc_delay = SJA1105_RGMII_DELAY_PS_TO_HW(tx_delay);\n\t\tpad_mii_id.txc_bypass = 1;\n\t\tpad_mii_id.txc_pd = 0;\n\t}\n\n\tsja1110_cfg_pad_mii_id_packing(packed_buf, &pad_mii_id, PACK);\n\n\treturn sja1105_xfer_buf(priv, SPI_WRITE, regs->pad_mii_id[port],\n\t\t\t\tpacked_buf, SJA1105_SIZE_CGU_CMD);\n}\n\nstatic int sja1105_rgmii_clocking_setup(struct sja1105_private *priv, int port,\n\t\t\t\t\tsja1105_mii_role_t role)\n{\n\tstruct device *dev = priv->ds->dev;\n\tstruct sja1105_mac_config_entry *mac;\n\tu64 speed;\n\tint rc;\n\n\tmac = priv->static_config.tables[BLK_IDX_MAC_CONFIG].entries;\n\tspeed = mac[port].speed;\n\n\tdev_dbg(dev, \"Configuring port %d RGMII at speed %lldMbps\\n\",\n\t\tport, speed);\n\n\tif (speed == priv->info->port_speed[SJA1105_SPEED_1000MBPS]) {\n\t\t \n\t\trc = sja1105_cgu_idiv_config(priv, port, false, 1);\n\t} else if (speed == priv->info->port_speed[SJA1105_SPEED_100MBPS]) {\n\t\t \n\t\trc = sja1105_cgu_idiv_config(priv, port, true, 1);\n\t} else if (speed == priv->info->port_speed[SJA1105_SPEED_10MBPS]) {\n\t\t \n\t\trc = sja1105_cgu_idiv_config(priv, port, true, 10);\n\t} else if (speed == priv->info->port_speed[SJA1105_SPEED_AUTO]) {\n\t\t \n\t\tdev_dbg(dev, \"Speed not available, skipping CGU config\\n\");\n\t\treturn 0;\n\t} else {\n\t\trc = -EINVAL;\n\t}\n\n\tif (rc < 0) {\n\t\tdev_err(dev, \"Failed to configure idiv\\n\");\n\t\treturn rc;\n\t}\n\trc = sja1105_cgu_rgmii_tx_clk_config(priv, port, speed);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"Failed to configure RGMII Tx clock\\n\");\n\t\treturn rc;\n\t}\n\trc = sja1105_rgmii_cfg_pad_tx_config(priv, port);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"Failed to configure Tx pad registers\\n\");\n\t\treturn rc;\n\t}\n\n\tif (!priv->info->setup_rgmii_delay)\n\t\treturn 0;\n\n\treturn priv->info->setup_rgmii_delay(priv, port);\n}\n\nstatic int sja1105_cgu_rmii_ref_clk_config(struct sja1105_private *priv,\n\t\t\t\t\t   int port)\n{\n\tconst struct sja1105_regs *regs = priv->info->regs;\n\tstruct sja1105_cgu_mii_ctrl ref_clk;\n\tu8 packed_buf[SJA1105_SIZE_CGU_CMD] = {0};\n\tconst int clk_sources[] = {\n\t\tCLKSRC_MII0_TX_CLK,\n\t\tCLKSRC_MII1_TX_CLK,\n\t\tCLKSRC_MII2_TX_CLK,\n\t\tCLKSRC_MII3_TX_CLK,\n\t\tCLKSRC_MII4_TX_CLK,\n\t};\n\n\tif (regs->rmii_ref_clk[port] == SJA1105_RSV_ADDR)\n\t\treturn 0;\n\n\t \n\tref_clk.clksrc    = clk_sources[port];\n\tref_clk.autoblock = 1;       \n\tref_clk.pd        = 0;       \n\tsja1105_cgu_mii_control_packing(packed_buf, &ref_clk, PACK);\n\n\treturn sja1105_xfer_buf(priv, SPI_WRITE, regs->rmii_ref_clk[port],\n\t\t\t\tpacked_buf, SJA1105_SIZE_CGU_CMD);\n}\n\nstatic int\nsja1105_cgu_rmii_ext_tx_clk_config(struct sja1105_private *priv, int port)\n{\n\tconst struct sja1105_regs *regs = priv->info->regs;\n\tstruct sja1105_cgu_mii_ctrl ext_tx_clk;\n\tu8 packed_buf[SJA1105_SIZE_CGU_CMD] = {0};\n\n\tif (regs->rmii_ext_tx_clk[port] == SJA1105_RSV_ADDR)\n\t\treturn 0;\n\n\t \n\text_tx_clk.clksrc    = CLKSRC_PLL1;\n\text_tx_clk.autoblock = 1;    \n\text_tx_clk.pd        = 0;    \n\tsja1105_cgu_mii_control_packing(packed_buf, &ext_tx_clk, PACK);\n\n\treturn sja1105_xfer_buf(priv, SPI_WRITE, regs->rmii_ext_tx_clk[port],\n\t\t\t\tpacked_buf, SJA1105_SIZE_CGU_CMD);\n}\n\nstatic int sja1105_cgu_rmii_pll_config(struct sja1105_private *priv)\n{\n\tconst struct sja1105_regs *regs = priv->info->regs;\n\tu8 packed_buf[SJA1105_SIZE_CGU_CMD] = {0};\n\tstruct sja1105_cgu_pll_ctrl pll = {0};\n\tstruct device *dev = priv->ds->dev;\n\tint rc;\n\n\tif (regs->rmii_pll1 == SJA1105_RSV_ADDR)\n\t\treturn 0;\n\n\t \n\n\t \n\tpll.pllclksrc = 0xA;\n\tpll.msel      = 0x1;\n\tpll.autoblock = 0x1;\n\tpll.psel      = 0x1;\n\tpll.direct    = 0x0;\n\tpll.fbsel     = 0x1;\n\tpll.bypass    = 0x0;\n\tpll.pd        = 0x1;\n\n\tsja1105_cgu_pll_control_packing(packed_buf, &pll, PACK);\n\trc = sja1105_xfer_buf(priv, SPI_WRITE, regs->rmii_pll1, packed_buf,\n\t\t\t      SJA1105_SIZE_CGU_CMD);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"failed to configure PLL1 for 50MHz\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\tpll.pd = 0x0;\n\n\tsja1105_cgu_pll_control_packing(packed_buf, &pll, PACK);\n\trc = sja1105_xfer_buf(priv, SPI_WRITE, regs->rmii_pll1, packed_buf,\n\t\t\t      SJA1105_SIZE_CGU_CMD);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"failed to enable PLL1\\n\");\n\t\treturn rc;\n\t}\n\treturn rc;\n}\n\nstatic int sja1105_rmii_clocking_setup(struct sja1105_private *priv, int port,\n\t\t\t\t       sja1105_mii_role_t role)\n{\n\tstruct device *dev = priv->ds->dev;\n\tint rc;\n\n\tdev_dbg(dev, \"Configuring RMII-%s clocking\\n\",\n\t\t(role == XMII_MAC) ? \"MAC\" : \"PHY\");\n\t \n\tif (role == XMII_MAC) {\n\t\t \n\t\trc = sja1105_cgu_rmii_pll_config(priv);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\t \n\trc = sja1105_cgu_idiv_config(priv, port, false, 1);\n\tif (rc < 0)\n\t\treturn rc;\n\t \n\trc = sja1105_cgu_rmii_ref_clk_config(priv, port);\n\tif (rc < 0)\n\t\treturn rc;\n\tif (role == XMII_MAC) {\n\t\trc = sja1105_cgu_rmii_ext_tx_clk_config(priv, port);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nint sja1105_clocking_setup_port(struct sja1105_private *priv, int port)\n{\n\tstruct sja1105_xmii_params_entry *mii;\n\tstruct device *dev = priv->ds->dev;\n\tsja1105_phy_interface_t phy_mode;\n\tsja1105_mii_role_t role;\n\tint rc;\n\n\tmii = priv->static_config.tables[BLK_IDX_XMII_PARAMS].entries;\n\n\t \n\tphy_mode = mii->xmii_mode[port];\n\t \n\trole = mii->phy_mac[port];\n\n\tswitch (phy_mode) {\n\tcase XMII_MODE_MII:\n\t\trc = sja1105_mii_clocking_setup(priv, port, role);\n\t\tbreak;\n\tcase XMII_MODE_RMII:\n\t\trc = sja1105_rmii_clocking_setup(priv, port, role);\n\t\tbreak;\n\tcase XMII_MODE_RGMII:\n\t\trc = sja1105_rgmii_clocking_setup(priv, port, role);\n\t\tbreak;\n\tcase XMII_MODE_SGMII:\n\t\t \n\t\trc = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Invalid interface mode specified: %d\\n\",\n\t\t\tphy_mode);\n\t\treturn -EINVAL;\n\t}\n\tif (rc) {\n\t\tdev_err(dev, \"Clocking setup for port %d failed: %d\\n\",\n\t\t\tport, rc);\n\t\treturn rc;\n\t}\n\n\t \n\treturn sja1105_cfg_pad_rx_config(priv, port);\n}\n\nint sja1105_clocking_setup(struct sja1105_private *priv)\n{\n\tstruct dsa_switch *ds = priv->ds;\n\tint port, rc;\n\n\tfor (port = 0; port < ds->num_ports; port++) {\n\t\trc = sja1105_clocking_setup_port(priv, port);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic void\nsja1110_cgu_outclk_packing(void *buf, struct sja1110_cgu_outclk *outclk,\n\t\t\t   enum packing_op op)\n{\n\tconst int size = 4;\n\n\tsja1105_packing(buf, &outclk->clksrc,    27, 24, size, op);\n\tsja1105_packing(buf, &outclk->autoblock, 11, 11, size, op);\n\tsja1105_packing(buf, &outclk->pd,         0,  0, size, op);\n}\n\nint sja1110_disable_microcontroller(struct sja1105_private *priv)\n{\n\tu8 packed_buf[SJA1105_SIZE_CGU_CMD] = {0};\n\tstruct sja1110_cgu_outclk outclk_6_c = {\n\t\t.clksrc = 0x3,\n\t\t.pd = true,\n\t};\n\tstruct sja1110_cgu_outclk outclk_7_c = {\n\t\t.clksrc = 0x5,\n\t\t.pd = true,\n\t};\n\tint rc;\n\n\t \n\tsja1110_cgu_outclk_packing(packed_buf, &outclk_7_c, PACK);\n\n\trc = sja1105_xfer_buf(priv, SPI_WRITE, SJA1110_BASE_TIMER_CLK,\n\t\t\t      packed_buf, SJA1105_SIZE_CGU_CMD);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tsja1110_cgu_outclk_packing(packed_buf, &outclk_6_c, PACK);\n\n\treturn sja1105_xfer_buf(priv, SPI_WRITE, SJA1110_BASE_MCSS_CLK,\n\t\t\t\tpacked_buf, SJA1105_SIZE_CGU_CMD);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}