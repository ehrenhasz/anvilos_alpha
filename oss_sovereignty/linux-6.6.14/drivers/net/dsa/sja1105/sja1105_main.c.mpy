{
  "module_name": "sja1105_main.c",
  "hash_id": "a1479a1aae05caafd1efc6b69d8be1869b20aa0db98c025a78ca19cb65700c3b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/sja1105/sja1105_main.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/printk.h>\n#include <linux/spi/spi.h>\n#include <linux/errno.h>\n#include <linux/gpio/consumer.h>\n#include <linux/phylink.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n#include <linux/of_mdio.h>\n#include <linux/pcs/pcs-xpcs.h>\n#include <linux/netdev_features.h>\n#include <linux/netdevice.h>\n#include <linux/if_bridge.h>\n#include <linux/if_ether.h>\n#include <linux/dsa/8021q.h>\n#include \"sja1105.h\"\n#include \"sja1105_tas.h\"\n\n#define SJA1105_UNKNOWN_MULTICAST\t0x010000000000ull\n\n \nstatic int sja1105_hw_reset(struct device *dev, unsigned int pulse_len,\n\t\t\t    unsigned int startup_delay)\n{\n\tstruct gpio_desc *gpio;\n\n\tgpio = gpiod_get_optional(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(gpio))\n\t\treturn PTR_ERR(gpio);\n\n\tif (!gpio)\n\t\treturn 0;\n\n\tgpiod_set_value_cansleep(gpio, 1);\n\t \n\tmsleep(pulse_len);\n\tgpiod_set_value_cansleep(gpio, 0);\n\t \n\tmsleep(startup_delay);\n\n\tgpiod_put(gpio);\n\n\treturn 0;\n}\n\nstatic void\nsja1105_port_allow_traffic(struct sja1105_l2_forwarding_entry *l2_fwd,\n\t\t\t   int from, int to, bool allow)\n{\n\tif (allow)\n\t\tl2_fwd[from].reach_port |= BIT(to);\n\telse\n\t\tl2_fwd[from].reach_port &= ~BIT(to);\n}\n\nstatic bool sja1105_can_forward(struct sja1105_l2_forwarding_entry *l2_fwd,\n\t\t\t\tint from, int to)\n{\n\treturn !!(l2_fwd[from].reach_port & BIT(to));\n}\n\nstatic int sja1105_is_vlan_configured(struct sja1105_private *priv, u16 vid)\n{\n\tstruct sja1105_vlan_lookup_entry *vlan;\n\tint count, i;\n\n\tvlan = priv->static_config.tables[BLK_IDX_VLAN_LOOKUP].entries;\n\tcount = priv->static_config.tables[BLK_IDX_VLAN_LOOKUP].entry_count;\n\n\tfor (i = 0; i < count; i++)\n\t\tif (vlan[i].vlanid == vid)\n\t\t\treturn i;\n\n\t \n\treturn -1;\n}\n\nstatic int sja1105_drop_untagged(struct dsa_switch *ds, int port, bool drop)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct sja1105_mac_config_entry *mac;\n\n\tmac = priv->static_config.tables[BLK_IDX_MAC_CONFIG].entries;\n\n\tif (mac[port].drpuntag == drop)\n\t\treturn 0;\n\n\tmac[port].drpuntag = drop;\n\n\treturn sja1105_dynamic_config_write(priv, BLK_IDX_MAC_CONFIG, port,\n\t\t\t\t\t    &mac[port], true);\n}\n\nstatic int sja1105_pvid_apply(struct sja1105_private *priv, int port, u16 pvid)\n{\n\tstruct sja1105_mac_config_entry *mac;\n\n\tmac = priv->static_config.tables[BLK_IDX_MAC_CONFIG].entries;\n\n\tif (mac[port].vlanid == pvid)\n\t\treturn 0;\n\n\tmac[port].vlanid = pvid;\n\n\treturn sja1105_dynamic_config_write(priv, BLK_IDX_MAC_CONFIG, port,\n\t\t\t\t\t    &mac[port], true);\n}\n\nstatic int sja1105_commit_pvid(struct dsa_switch *ds, int port)\n{\n\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\tstruct net_device *br = dsa_port_bridge_dev_get(dp);\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct sja1105_vlan_lookup_entry *vlan;\n\tbool drop_untagged = false;\n\tint match, rc;\n\tu16 pvid;\n\n\tif (br && br_vlan_enabled(br))\n\t\tpvid = priv->bridge_pvid[port];\n\telse\n\t\tpvid = priv->tag_8021q_pvid[port];\n\n\trc = sja1105_pvid_apply(priv, port, pvid);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (pvid == priv->bridge_pvid[port]) {\n\t\tvlan = priv->static_config.tables[BLK_IDX_VLAN_LOOKUP].entries;\n\n\t\tmatch = sja1105_is_vlan_configured(priv, pvid);\n\n\t\tif (match < 0 || !(vlan[match].vmemb_port & BIT(port)))\n\t\t\tdrop_untagged = true;\n\t}\n\n\tif (dsa_is_cpu_port(ds, port) || dsa_is_dsa_port(ds, port))\n\t\tdrop_untagged = true;\n\n\treturn sja1105_drop_untagged(ds, port, drop_untagged);\n}\n\nstatic int sja1105_init_mac_settings(struct sja1105_private *priv)\n{\n\tstruct sja1105_mac_config_entry default_mac = {\n\t\t \n\t\t.top  = {0x3F, 0x7F, 0xBF, 0xFF, 0x13F, 0x17F, 0x1BF, 0x1FF},\n\t\t.base = {0x0, 0x40, 0x80, 0xC0, 0x100, 0x140, 0x180, 0x1C0},\n\t\t.enabled = {true, true, true, true, true, true, true, true},\n\t\t \n\t\t.ifg = 0,\n\t\t \n\t\t.speed = priv->info->port_speed[SJA1105_SPEED_AUTO],\n\t\t \n\t\t.tp_delin = 0,\n\t\t.tp_delout = 0,\n\t\t \n\t\t.maxage = 0xFF,\n\t\t \n\t\t.vlanprio = 0,\n\t\t.vlanid = 1,\n\t\t.ing_mirr = false,\n\t\t.egr_mirr = false,\n\t\t \n\t\t.drpnona664 = false,\n\t\t \n\t\t.drpdtag = false,\n\t\t \n\t\t.drpuntag = false,\n\t\t \n\t\t.retag = false,\n\t\t \n\t\t.dyn_learn = false,\n\t\t.egress = false,\n\t\t.ingress = false,\n\t};\n\tstruct sja1105_mac_config_entry *mac;\n\tstruct dsa_switch *ds = priv->ds;\n\tstruct sja1105_table *table;\n\tstruct dsa_port *dp;\n\n\ttable = &priv->static_config.tables[BLK_IDX_MAC_CONFIG];\n\n\t \n\tif (table->entry_count) {\n\t\tkfree(table->entries);\n\t\ttable->entry_count = 0;\n\t}\n\n\ttable->entries = kcalloc(table->ops->max_entry_count,\n\t\t\t\t table->ops->unpacked_entry_size, GFP_KERNEL);\n\tif (!table->entries)\n\t\treturn -ENOMEM;\n\n\ttable->entry_count = table->ops->max_entry_count;\n\n\tmac = table->entries;\n\n\tlist_for_each_entry(dp, &ds->dst->ports, list) {\n\t\tif (dp->ds != ds)\n\t\t\tcontinue;\n\n\t\tmac[dp->index] = default_mac;\n\n\t\t \n\t\tif (dsa_port_is_dsa(dp))\n\t\t\tdp->learning = true;\n\n\t\t \n\t\tif (dsa_port_is_cpu(dp) || dsa_port_is_dsa(dp))\n\t\t\tmac[dp->index].drpuntag = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int sja1105_init_mii_settings(struct sja1105_private *priv)\n{\n\tstruct device *dev = &priv->spidev->dev;\n\tstruct sja1105_xmii_params_entry *mii;\n\tstruct dsa_switch *ds = priv->ds;\n\tstruct sja1105_table *table;\n\tint i;\n\n\ttable = &priv->static_config.tables[BLK_IDX_XMII_PARAMS];\n\n\t \n\tif (table->entry_count) {\n\t\tkfree(table->entries);\n\t\ttable->entry_count = 0;\n\t}\n\n\ttable->entries = kcalloc(table->ops->max_entry_count,\n\t\t\t\t table->ops->unpacked_entry_size, GFP_KERNEL);\n\tif (!table->entries)\n\t\treturn -ENOMEM;\n\n\t \n\ttable->entry_count = table->ops->max_entry_count;\n\n\tmii = table->entries;\n\n\tfor (i = 0; i < ds->num_ports; i++) {\n\t\tsja1105_mii_role_t role = XMII_MAC;\n\n\t\tif (dsa_is_unused_port(priv->ds, i))\n\t\t\tcontinue;\n\n\t\tswitch (priv->phy_mode[i]) {\n\t\tcase PHY_INTERFACE_MODE_INTERNAL:\n\t\t\tif (priv->info->internal_phy[i] == SJA1105_NO_PHY)\n\t\t\t\tgoto unsupported;\n\n\t\t\tmii->xmii_mode[i] = XMII_MODE_MII;\n\t\t\tif (priv->info->internal_phy[i] == SJA1105_PHY_BASE_TX)\n\t\t\t\tmii->special[i] = true;\n\n\t\t\tbreak;\n\t\tcase PHY_INTERFACE_MODE_REVMII:\n\t\t\trole = XMII_PHY;\n\t\t\tfallthrough;\n\t\tcase PHY_INTERFACE_MODE_MII:\n\t\t\tif (!priv->info->supports_mii[i])\n\t\t\t\tgoto unsupported;\n\n\t\t\tmii->xmii_mode[i] = XMII_MODE_MII;\n\t\t\tbreak;\n\t\tcase PHY_INTERFACE_MODE_REVRMII:\n\t\t\trole = XMII_PHY;\n\t\t\tfallthrough;\n\t\tcase PHY_INTERFACE_MODE_RMII:\n\t\t\tif (!priv->info->supports_rmii[i])\n\t\t\t\tgoto unsupported;\n\n\t\t\tmii->xmii_mode[i] = XMII_MODE_RMII;\n\t\t\tbreak;\n\t\tcase PHY_INTERFACE_MODE_RGMII:\n\t\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\t\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\t\tif (!priv->info->supports_rgmii[i])\n\t\t\t\tgoto unsupported;\n\n\t\t\tmii->xmii_mode[i] = XMII_MODE_RGMII;\n\t\t\tbreak;\n\t\tcase PHY_INTERFACE_MODE_SGMII:\n\t\t\tif (!priv->info->supports_sgmii[i])\n\t\t\t\tgoto unsupported;\n\n\t\t\tmii->xmii_mode[i] = XMII_MODE_SGMII;\n\t\t\tmii->special[i] = true;\n\t\t\tbreak;\n\t\tcase PHY_INTERFACE_MODE_2500BASEX:\n\t\t\tif (!priv->info->supports_2500basex[i])\n\t\t\t\tgoto unsupported;\n\n\t\t\tmii->xmii_mode[i] = XMII_MODE_SGMII;\n\t\t\tmii->special[i] = true;\n\t\t\tbreak;\nunsupported:\n\t\tdefault:\n\t\t\tdev_err(dev, \"Unsupported PHY mode %s on port %d!\\n\",\n\t\t\t\tphy_modes(priv->phy_mode[i]), i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmii->phy_mac[i] = role;\n\t}\n\treturn 0;\n}\n\nstatic int sja1105_init_static_fdb(struct sja1105_private *priv)\n{\n\tstruct sja1105_l2_lookup_entry *l2_lookup;\n\tstruct sja1105_table *table;\n\tint port;\n\n\ttable = &priv->static_config.tables[BLK_IDX_L2_LOOKUP];\n\n\t \n\tif (table->entry_count) {\n\t\tkfree(table->entries);\n\t\ttable->entry_count = 0;\n\t}\n\n\tif (!priv->info->can_limit_mcast_flood)\n\t\treturn 0;\n\n\ttable->entries = kcalloc(1, table->ops->unpacked_entry_size,\n\t\t\t\t GFP_KERNEL);\n\tif (!table->entries)\n\t\treturn -ENOMEM;\n\n\ttable->entry_count = 1;\n\tl2_lookup = table->entries;\n\n\t \n\tl2_lookup[0].macaddr = SJA1105_UNKNOWN_MULTICAST;\n\tl2_lookup[0].mask_macaddr = SJA1105_UNKNOWN_MULTICAST;\n\tl2_lookup[0].lockeds = true;\n\tl2_lookup[0].index = SJA1105_MAX_L2_LOOKUP_COUNT - 1;\n\n\t \n\tfor (port = 0; port < priv->ds->num_ports; port++)\n\t\tif (!dsa_is_unused_port(priv->ds, port))\n\t\t\tl2_lookup[0].destports |= BIT(port);\n\n\treturn 0;\n}\n\nstatic int sja1105_init_l2_lookup_params(struct sja1105_private *priv)\n{\n\tstruct sja1105_l2_lookup_params_entry default_l2_lookup_params = {\n\t\t \n\t\t.maxage = SJA1105_AGEING_TIME_MS(300000),\n\t\t \n\t\t.dyn_tbsz = SJA1105ET_FDB_BIN_SIZE,\n\t\t \n\t\t.start_dynspc = 0,\n\t\t \n\t\t.poly = 0x97,\n\t\t \n\t\t.shared_learn = false,\n\t\t \n\t\t.no_enf_hostprt = false,\n\t\t \n\t\t.no_mgmt_learn = true,\n\t\t \n\t\t.use_static = true,\n\t\t \n\t\t.owr_dyn = true,\n\t\t.drpnolearn = true,\n\t};\n\tstruct dsa_switch *ds = priv->ds;\n\tint port, num_used_ports = 0;\n\tstruct sja1105_table *table;\n\tu64 max_fdb_entries;\n\n\tfor (port = 0; port < ds->num_ports; port++)\n\t\tif (!dsa_is_unused_port(ds, port))\n\t\t\tnum_used_ports++;\n\n\tmax_fdb_entries = SJA1105_MAX_L2_LOOKUP_COUNT / num_used_ports;\n\n\tfor (port = 0; port < ds->num_ports; port++) {\n\t\tif (dsa_is_unused_port(ds, port))\n\t\t\tcontinue;\n\n\t\tdefault_l2_lookup_params.maxaddrp[port] = max_fdb_entries;\n\t}\n\n\ttable = &priv->static_config.tables[BLK_IDX_L2_LOOKUP_PARAMS];\n\n\tif (table->entry_count) {\n\t\tkfree(table->entries);\n\t\ttable->entry_count = 0;\n\t}\n\n\ttable->entries = kcalloc(table->ops->max_entry_count,\n\t\t\t\t table->ops->unpacked_entry_size, GFP_KERNEL);\n\tif (!table->entries)\n\t\treturn -ENOMEM;\n\n\ttable->entry_count = table->ops->max_entry_count;\n\n\t \n\t((struct sja1105_l2_lookup_params_entry *)table->entries)[0] =\n\t\t\t\tdefault_l2_lookup_params;\n\n\treturn 0;\n}\n\n \nstatic int sja1105_init_static_vlan(struct sja1105_private *priv)\n{\n\tstruct sja1105_table *table;\n\tstruct sja1105_vlan_lookup_entry pvid = {\n\t\t.type_entry = SJA1110_VLAN_D_TAG,\n\t\t.ving_mirr = 0,\n\t\t.vegr_mirr = 0,\n\t\t.vmemb_port = 0,\n\t\t.vlan_bc = 0,\n\t\t.tag_port = 0,\n\t\t.vlanid = SJA1105_DEFAULT_VLAN,\n\t};\n\tstruct dsa_switch *ds = priv->ds;\n\tint port;\n\n\ttable = &priv->static_config.tables[BLK_IDX_VLAN_LOOKUP];\n\n\tif (table->entry_count) {\n\t\tkfree(table->entries);\n\t\ttable->entry_count = 0;\n\t}\n\n\ttable->entries = kzalloc(table->ops->unpacked_entry_size,\n\t\t\t\t GFP_KERNEL);\n\tif (!table->entries)\n\t\treturn -ENOMEM;\n\n\ttable->entry_count = 1;\n\n\tfor (port = 0; port < ds->num_ports; port++) {\n\t\tif (dsa_is_unused_port(ds, port))\n\t\t\tcontinue;\n\n\t\tpvid.vmemb_port |= BIT(port);\n\t\tpvid.vlan_bc |= BIT(port);\n\t\tpvid.tag_port &= ~BIT(port);\n\n\t\tif (dsa_is_cpu_port(ds, port) || dsa_is_dsa_port(ds, port)) {\n\t\t\tpriv->tag_8021q_pvid[port] = SJA1105_DEFAULT_VLAN;\n\t\t\tpriv->bridge_pvid[port] = SJA1105_DEFAULT_VLAN;\n\t\t}\n\t}\n\n\t((struct sja1105_vlan_lookup_entry *)table->entries)[0] = pvid;\n\treturn 0;\n}\n\nstatic int sja1105_init_l2_forwarding(struct sja1105_private *priv)\n{\n\tstruct sja1105_l2_forwarding_entry *l2fwd;\n\tstruct dsa_switch *ds = priv->ds;\n\tstruct dsa_switch_tree *dst;\n\tstruct sja1105_table *table;\n\tstruct dsa_link *dl;\n\tint port, tc;\n\tint from, to;\n\n\ttable = &priv->static_config.tables[BLK_IDX_L2_FORWARDING];\n\n\tif (table->entry_count) {\n\t\tkfree(table->entries);\n\t\ttable->entry_count = 0;\n\t}\n\n\ttable->entries = kcalloc(table->ops->max_entry_count,\n\t\t\t\t table->ops->unpacked_entry_size, GFP_KERNEL);\n\tif (!table->entries)\n\t\treturn -ENOMEM;\n\n\ttable->entry_count = table->ops->max_entry_count;\n\n\tl2fwd = table->entries;\n\n\t \n\tfor (port = 0; port < ds->num_ports; port++) {\n\t\tif (dsa_is_unused_port(ds, port))\n\t\t\tcontinue;\n\n\t\tfor (tc = 0; tc < SJA1105_NUM_TC; tc++)\n\t\t\tl2fwd[port].vlan_pmap[tc] = tc;\n\t}\n\n\t \n\tfor (from = 0; from < ds->num_ports; from++) {\n\t\tif (!dsa_is_user_port(ds, from))\n\t\t\tcontinue;\n\n\t\tfor (to = 0; to < ds->num_ports; to++) {\n\t\t\tif (!dsa_is_cpu_port(ds, to) &&\n\t\t\t    !dsa_is_dsa_port(ds, to))\n\t\t\t\tcontinue;\n\n\t\t\tl2fwd[from].bc_domain |= BIT(to);\n\t\t\tl2fwd[from].fl_domain |= BIT(to);\n\n\t\t\tsja1105_port_allow_traffic(l2fwd, from, to, true);\n\t\t}\n\t}\n\n\t \n\tfor (from = 0; from < ds->num_ports; from++) {\n\t\tif (!dsa_is_cpu_port(ds, from) && !dsa_is_dsa_port(ds, from))\n\t\t\tcontinue;\n\n\t\tfor (to = 0; to < ds->num_ports; to++) {\n\t\t\tif (dsa_is_unused_port(ds, to))\n\t\t\t\tcontinue;\n\n\t\t\tif (from == to)\n\t\t\t\tcontinue;\n\n\t\t\tl2fwd[from].bc_domain |= BIT(to);\n\t\t\tl2fwd[from].fl_domain |= BIT(to);\n\n\t\t\tsja1105_port_allow_traffic(l2fwd, from, to, true);\n\t\t}\n\t}\n\n\t \n\tdst = ds->dst;\n\n\tlist_for_each_entry(dl, &dst->rtable, list) {\n\t\tif (dl->dp->ds != ds || dl->link_dp->cpu_dp == dl->dp->cpu_dp)\n\t\t\tcontinue;\n\n\t\tfrom = dl->dp->index;\n\t\tto = dsa_upstream_port(ds, from);\n\n\t\tdev_warn(ds->dev,\n\t\t\t \"H topology detected, cutting RX from DSA link %d to CPU port %d to prevent TX packet loops\\n\",\n\t\t\t from, to);\n\n\t\tsja1105_port_allow_traffic(l2fwd, from, to, false);\n\n\t\tl2fwd[from].bc_domain &= ~BIT(to);\n\t\tl2fwd[from].fl_domain &= ~BIT(to);\n\t}\n\n\t \n\tfor (port = 0; port < ds->num_ports; port++) {\n\t\tif (dsa_is_unused_port(ds, port))\n\t\t\tcontinue;\n\n\t\tpriv->ucast_egress_floods |= BIT(port);\n\t\tpriv->bcast_egress_floods |= BIT(port);\n\t}\n\n\t \n\tfor (tc = 0; tc < SJA1105_NUM_TC; tc++) {\n\t\tfor (port = 0; port < ds->num_ports; port++) {\n\t\t\tif (dsa_is_unused_port(ds, port))\n\t\t\t\tcontinue;\n\n\t\t\tl2fwd[ds->num_ports + tc].vlan_pmap[port] = tc;\n\t\t}\n\n\t\tl2fwd[ds->num_ports + tc].type_egrpcp2outputq = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int sja1110_init_pcp_remapping(struct sja1105_private *priv)\n{\n\tstruct sja1110_pcp_remapping_entry *pcp_remap;\n\tstruct dsa_switch *ds = priv->ds;\n\tstruct sja1105_table *table;\n\tint port, tc;\n\n\ttable = &priv->static_config.tables[BLK_IDX_PCP_REMAPPING];\n\n\t \n\tif (!table->ops->max_entry_count)\n\t\treturn 0;\n\n\tif (table->entry_count) {\n\t\tkfree(table->entries);\n\t\ttable->entry_count = 0;\n\t}\n\n\ttable->entries = kcalloc(table->ops->max_entry_count,\n\t\t\t\t table->ops->unpacked_entry_size, GFP_KERNEL);\n\tif (!table->entries)\n\t\treturn -ENOMEM;\n\n\ttable->entry_count = table->ops->max_entry_count;\n\n\tpcp_remap = table->entries;\n\n\t \n\tfor (port = 0; port < ds->num_ports; port++) {\n\t\tif (dsa_is_unused_port(ds, port))\n\t\t\tcontinue;\n\n\t\tfor (tc = 0; tc < SJA1105_NUM_TC; tc++)\n\t\t\tpcp_remap[port].egrpcp[tc] = tc;\n\t}\n\n\treturn 0;\n}\n\nstatic int sja1105_init_l2_forwarding_params(struct sja1105_private *priv)\n{\n\tstruct sja1105_l2_forwarding_params_entry *l2fwd_params;\n\tstruct sja1105_table *table;\n\n\ttable = &priv->static_config.tables[BLK_IDX_L2_FORWARDING_PARAMS];\n\n\tif (table->entry_count) {\n\t\tkfree(table->entries);\n\t\ttable->entry_count = 0;\n\t}\n\n\ttable->entries = kcalloc(table->ops->max_entry_count,\n\t\t\t\t table->ops->unpacked_entry_size, GFP_KERNEL);\n\tif (!table->entries)\n\t\treturn -ENOMEM;\n\n\ttable->entry_count = table->ops->max_entry_count;\n\n\t \n\tl2fwd_params = table->entries;\n\n\t \n\tl2fwd_params->max_dynp = 0;\n\t \n\tl2fwd_params->part_spc[0] = priv->info->max_frame_mem;\n\n\treturn 0;\n}\n\nvoid sja1105_frame_memory_partitioning(struct sja1105_private *priv)\n{\n\tstruct sja1105_l2_forwarding_params_entry *l2_fwd_params;\n\tstruct sja1105_vl_forwarding_params_entry *vl_fwd_params;\n\tstruct sja1105_table *table;\n\n\ttable = &priv->static_config.tables[BLK_IDX_L2_FORWARDING_PARAMS];\n\tl2_fwd_params = table->entries;\n\tl2_fwd_params->part_spc[0] = SJA1105_MAX_FRAME_MEMORY;\n\n\t \n\tif (!priv->static_config.tables[BLK_IDX_VL_FORWARDING].entry_count)\n\t\treturn;\n\n\ttable = &priv->static_config.tables[BLK_IDX_VL_FORWARDING_PARAMS];\n\tvl_fwd_params = table->entries;\n\n\tl2_fwd_params->part_spc[0] -= SJA1105_VL_FRAME_MEMORY;\n\tvl_fwd_params->partspc[0] = SJA1105_VL_FRAME_MEMORY;\n}\n\n \nstatic void sja1110_select_tdmaconfigidx(struct sja1105_private *priv)\n{\n\tstruct sja1105_general_params_entry *general_params;\n\tstruct sja1105_table *table;\n\tbool port_1_is_base_tx;\n\tbool port_3_is_2500;\n\tbool port_4_is_2500;\n\tu64 tdmaconfigidx;\n\n\tif (priv->info->device_id != SJA1110_DEVICE_ID)\n\t\treturn;\n\n\ttable = &priv->static_config.tables[BLK_IDX_GENERAL_PARAMS];\n\tgeneral_params = table->entries;\n\n\t \n\tport_1_is_base_tx = priv->phy_mode[1] == PHY_INTERFACE_MODE_INTERNAL;\n\tport_3_is_2500 = priv->phy_mode[3] == PHY_INTERFACE_MODE_2500BASEX;\n\tport_4_is_2500 = priv->phy_mode[4] == PHY_INTERFACE_MODE_2500BASEX;\n\n\tif (port_1_is_base_tx)\n\t\t \n\t\ttdmaconfigidx = 5;\n\telse if (port_3_is_2500 && port_4_is_2500)\n\t\t \n\t\ttdmaconfigidx = 1;\n\telse if (port_3_is_2500)\n\t\t \n\t\ttdmaconfigidx = 3;\n\telse if (port_4_is_2500)\n\t\t \n\t\ttdmaconfigidx = 2;\n\telse\n\t\t \n\t\ttdmaconfigidx = 14;\n\n\tgeneral_params->tdmaconfigidx = tdmaconfigidx;\n}\n\nstatic int sja1105_init_topology(struct sja1105_private *priv,\n\t\t\t\t struct sja1105_general_params_entry *general_params)\n{\n\tstruct dsa_switch *ds = priv->ds;\n\tint port;\n\n\t \n\tgeneral_params->host_port = ds->num_ports;\n\n\t \n\tif (!priv->info->multiple_cascade_ports)\n\t\tgeneral_params->casc_port = ds->num_ports;\n\n\tfor (port = 0; port < ds->num_ports; port++) {\n\t\tbool is_upstream = dsa_is_upstream_port(ds, port);\n\t\tbool is_dsa_link = dsa_is_dsa_port(ds, port);\n\n\t\t \n\t\tif (is_upstream) {\n\t\t\tif (general_params->host_port == ds->num_ports) {\n\t\t\t\tgeneral_params->host_port = port;\n\t\t\t} else {\n\t\t\t\tdev_err(ds->dev,\n\t\t\t\t\t\"Port %llu is already a host port, configuring %d as one too is not supported\\n\",\n\t\t\t\t\tgeneral_params->host_port, port);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (is_dsa_link && !is_upstream) {\n\t\t\tif (priv->info->multiple_cascade_ports) {\n\t\t\t\tgeneral_params->casc_port |= BIT(port);\n\t\t\t} else if (general_params->casc_port == ds->num_ports) {\n\t\t\t\tgeneral_params->casc_port = port;\n\t\t\t} else {\n\t\t\t\tdev_err(ds->dev,\n\t\t\t\t\t\"Port %llu is already a cascade port, configuring %d as one too is not supported\\n\",\n\t\t\t\t\tgeneral_params->casc_port, port);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (general_params->host_port == ds->num_ports) {\n\t\tdev_err(ds->dev, \"No host port configured\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int sja1105_init_general_params(struct sja1105_private *priv)\n{\n\tstruct sja1105_general_params_entry default_general_params = {\n\t\t \n\t\t.mirr_ptacu = true,\n\t\t.switchid = priv->ds->index,\n\t\t \n\t\t.hostprio = 7,\n\t\t.mac_fltres1 = SJA1105_LINKLOCAL_FILTER_A,\n\t\t.mac_flt1    = SJA1105_LINKLOCAL_FILTER_A_MASK,\n\t\t.incl_srcpt1 = true,\n\t\t.send_meta1  = true,\n\t\t.mac_fltres0 = SJA1105_LINKLOCAL_FILTER_B,\n\t\t.mac_flt0    = SJA1105_LINKLOCAL_FILTER_B_MASK,\n\t\t.incl_srcpt0 = true,\n\t\t.send_meta0  = true,\n\t\t \n\t\t.mirr_port = priv->ds->num_ports,\n\t\t \n\t\t.vllupformat = SJA1105_VL_FORMAT_PSFP,\n\t\t.vlmarker = 0,\n\t\t.vlmask = 0,\n\t\t \n\t\t.ignore2stf = 0,\n\t\t \n\t\t.tpid = ETH_P_SJA1105,\n\t\t.tpid2 = ETH_P_SJA1105,\n\t\t \n\t\t.tte_en = true,\n\t\t \n\t\t.header_type = ETH_P_SJA1110,\n\t};\n\tstruct sja1105_general_params_entry *general_params;\n\tstruct sja1105_table *table;\n\tint rc;\n\n\trc = sja1105_init_topology(priv, &default_general_params);\n\tif (rc)\n\t\treturn rc;\n\n\ttable = &priv->static_config.tables[BLK_IDX_GENERAL_PARAMS];\n\n\tif (table->entry_count) {\n\t\tkfree(table->entries);\n\t\ttable->entry_count = 0;\n\t}\n\n\ttable->entries = kcalloc(table->ops->max_entry_count,\n\t\t\t\t table->ops->unpacked_entry_size, GFP_KERNEL);\n\tif (!table->entries)\n\t\treturn -ENOMEM;\n\n\ttable->entry_count = table->ops->max_entry_count;\n\n\tgeneral_params = table->entries;\n\n\t \n\tgeneral_params[0] = default_general_params;\n\n\tsja1110_select_tdmaconfigidx(priv);\n\n\treturn 0;\n}\n\nstatic int sja1105_init_avb_params(struct sja1105_private *priv)\n{\n\tstruct sja1105_avb_params_entry *avb;\n\tstruct sja1105_table *table;\n\n\ttable = &priv->static_config.tables[BLK_IDX_AVB_PARAMS];\n\n\t \n\tif (table->entry_count) {\n\t\tkfree(table->entries);\n\t\ttable->entry_count = 0;\n\t}\n\n\ttable->entries = kcalloc(table->ops->max_entry_count,\n\t\t\t\t table->ops->unpacked_entry_size, GFP_KERNEL);\n\tif (!table->entries)\n\t\treturn -ENOMEM;\n\n\ttable->entry_count = table->ops->max_entry_count;\n\n\tavb = table->entries;\n\n\t \n\tavb->destmeta = SJA1105_META_DMAC;\n\tavb->srcmeta  = SJA1105_META_SMAC;\n\t \n\tavb->cas_master = false;\n\n\treturn 0;\n}\n\n \n#define SJA1105_RATE_MBPS(speed) (((speed) * 64000) / 1000)\n\nstatic int sja1105_init_l2_policing(struct sja1105_private *priv)\n{\n\tstruct sja1105_l2_policing_entry *policing;\n\tstruct dsa_switch *ds = priv->ds;\n\tstruct sja1105_table *table;\n\tint port, tc;\n\n\ttable = &priv->static_config.tables[BLK_IDX_L2_POLICING];\n\n\t \n\tif (table->entry_count) {\n\t\tkfree(table->entries);\n\t\ttable->entry_count = 0;\n\t}\n\n\ttable->entries = kcalloc(table->ops->max_entry_count,\n\t\t\t\t table->ops->unpacked_entry_size, GFP_KERNEL);\n\tif (!table->entries)\n\t\treturn -ENOMEM;\n\n\ttable->entry_count = table->ops->max_entry_count;\n\n\tpolicing = table->entries;\n\n\t \n\tfor (port = 0; port < ds->num_ports; port++) {\n\t\tint mcast = (ds->num_ports * (SJA1105_NUM_TC + 1)) + port;\n\t\tint bcast = (ds->num_ports * SJA1105_NUM_TC) + port;\n\n\t\tfor (tc = 0; tc < SJA1105_NUM_TC; tc++)\n\t\t\tpolicing[port * SJA1105_NUM_TC + tc].sharindx = port;\n\n\t\tpolicing[bcast].sharindx = port;\n\t\t \n\t\tif (mcast < table->ops->max_entry_count)\n\t\t\tpolicing[mcast].sharindx = port;\n\t}\n\n\t \n\tfor (port = 0; port < ds->num_ports; port++) {\n\t\tint mtu = VLAN_ETH_FRAME_LEN + ETH_FCS_LEN;\n\n\t\tif (dsa_is_cpu_port(ds, port) || dsa_is_dsa_port(ds, port))\n\t\t\tmtu += VLAN_HLEN;\n\n\t\tpolicing[port].smax = 65535;  \n\t\tpolicing[port].rate = SJA1105_RATE_MBPS(1000);\n\t\tpolicing[port].maxlen = mtu;\n\t\tpolicing[port].partition = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int sja1105_static_config_load(struct sja1105_private *priv)\n{\n\tint rc;\n\n\tsja1105_static_config_free(&priv->static_config);\n\trc = sja1105_static_config_init(&priv->static_config,\n\t\t\t\t\tpriv->info->static_ops,\n\t\t\t\t\tpriv->info->device_id);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = sja1105_init_mac_settings(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = sja1105_init_mii_settings(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = sja1105_init_static_fdb(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = sja1105_init_static_vlan(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = sja1105_init_l2_lookup_params(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = sja1105_init_l2_forwarding(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = sja1105_init_l2_forwarding_params(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = sja1105_init_l2_policing(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = sja1105_init_general_params(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = sja1105_init_avb_params(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = sja1110_init_pcp_remapping(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\treturn sja1105_static_config_upload(priv);\n}\n\n \nstatic int sja1105_parse_rgmii_delays(struct sja1105_private *priv, int port,\n\t\t\t\t      struct device_node *port_dn)\n{\n\tphy_interface_t phy_mode = priv->phy_mode[port];\n\tstruct device *dev = &priv->spidev->dev;\n\tint rx_delay = -1, tx_delay = -1;\n\n\tif (!phy_interface_mode_is_rgmii(phy_mode))\n\t\treturn 0;\n\n\tof_property_read_u32(port_dn, \"rx-internal-delay-ps\", &rx_delay);\n\tof_property_read_u32(port_dn, \"tx-internal-delay-ps\", &tx_delay);\n\n\tif (rx_delay == -1 && tx_delay == -1 && priv->fixed_link[port]) {\n\t\tdev_warn(dev,\n\t\t\t \"Port %d interpreting RGMII delay settings based on \\\"phy-mode\\\" property, \"\n\t\t\t \"please update device tree to specify \\\"rx-internal-delay-ps\\\" and \"\n\t\t\t \"\\\"tx-internal-delay-ps\\\"\",\n\t\t\t port);\n\n\t\tif (phy_mode == PHY_INTERFACE_MODE_RGMII_RXID ||\n\t\t    phy_mode == PHY_INTERFACE_MODE_RGMII_ID)\n\t\t\trx_delay = 2000;\n\n\t\tif (phy_mode == PHY_INTERFACE_MODE_RGMII_TXID ||\n\t\t    phy_mode == PHY_INTERFACE_MODE_RGMII_ID)\n\t\t\ttx_delay = 2000;\n\t}\n\n\tif (rx_delay < 0)\n\t\trx_delay = 0;\n\tif (tx_delay < 0)\n\t\ttx_delay = 0;\n\n\tif ((rx_delay || tx_delay) && !priv->info->setup_rgmii_delay) {\n\t\tdev_err(dev, \"Chip cannot apply RGMII delays\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((rx_delay && rx_delay < SJA1105_RGMII_DELAY_MIN_PS) ||\n\t    (tx_delay && tx_delay < SJA1105_RGMII_DELAY_MIN_PS) ||\n\t    (rx_delay > SJA1105_RGMII_DELAY_MAX_PS) ||\n\t    (tx_delay > SJA1105_RGMII_DELAY_MAX_PS)) {\n\t\tdev_err(dev,\n\t\t\t\"port %d RGMII delay values out of range, must be between %d and %d ps\\n\",\n\t\t\tport, SJA1105_RGMII_DELAY_MIN_PS, SJA1105_RGMII_DELAY_MAX_PS);\n\t\treturn -ERANGE;\n\t}\n\n\tpriv->rgmii_rx_delay_ps[port] = rx_delay;\n\tpriv->rgmii_tx_delay_ps[port] = tx_delay;\n\n\treturn 0;\n}\n\nstatic int sja1105_parse_ports_node(struct sja1105_private *priv,\n\t\t\t\t    struct device_node *ports_node)\n{\n\tstruct device *dev = &priv->spidev->dev;\n\tstruct device_node *child;\n\n\tfor_each_available_child_of_node(ports_node, child) {\n\t\tstruct device_node *phy_node;\n\t\tphy_interface_t phy_mode;\n\t\tu32 index;\n\t\tint err;\n\n\t\t \n\t\tif (of_property_read_u32(child, \"reg\", &index) < 0) {\n\t\t\tdev_err(dev, \"Port number not defined in device tree \"\n\t\t\t\t\"(property \\\"reg\\\")\\n\");\n\t\t\tof_node_put(child);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t \n\t\terr = of_get_phy_mode(child, &phy_mode);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Failed to read phy-mode or \"\n\t\t\t\t\"phy-interface-type property for port %d\\n\",\n\t\t\t\tindex);\n\t\t\tof_node_put(child);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tphy_node = of_parse_phandle(child, \"phy-handle\", 0);\n\t\tif (!phy_node) {\n\t\t\tif (!of_phy_is_fixed_link(child)) {\n\t\t\t\tdev_err(dev, \"phy-handle or fixed-link \"\n\t\t\t\t\t\"properties missing!\\n\");\n\t\t\t\tof_node_put(child);\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t\t \n\t\t\tpriv->fixed_link[index] = true;\n\t\t} else {\n\t\t\tof_node_put(phy_node);\n\t\t}\n\n\t\tpriv->phy_mode[index] = phy_mode;\n\n\t\terr = sja1105_parse_rgmii_delays(priv, index, child);\n\t\tif (err) {\n\t\t\tof_node_put(child);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sja1105_parse_dt(struct sja1105_private *priv)\n{\n\tstruct device *dev = &priv->spidev->dev;\n\tstruct device_node *switch_node = dev->of_node;\n\tstruct device_node *ports_node;\n\tint rc;\n\n\tports_node = of_get_child_by_name(switch_node, \"ports\");\n\tif (!ports_node)\n\t\tports_node = of_get_child_by_name(switch_node, \"ethernet-ports\");\n\tif (!ports_node) {\n\t\tdev_err(dev, \"Incorrect bindings: absent \\\"ports\\\" node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trc = sja1105_parse_ports_node(priv, ports_node);\n\tof_node_put(ports_node);\n\n\treturn rc;\n}\n\n \nstatic int sja1105_port_speed_to_ethtool(struct sja1105_private *priv,\n\t\t\t\t\t u64 speed)\n{\n\tif (speed == priv->info->port_speed[SJA1105_SPEED_10MBPS])\n\t\treturn SPEED_10;\n\tif (speed == priv->info->port_speed[SJA1105_SPEED_100MBPS])\n\t\treturn SPEED_100;\n\tif (speed == priv->info->port_speed[SJA1105_SPEED_1000MBPS])\n\t\treturn SPEED_1000;\n\tif (speed == priv->info->port_speed[SJA1105_SPEED_2500MBPS])\n\t\treturn SPEED_2500;\n\treturn SPEED_UNKNOWN;\n}\n\n \nstatic int sja1105_adjust_port_config(struct sja1105_private *priv, int port,\n\t\t\t\t      int speed_mbps)\n{\n\tstruct sja1105_mac_config_entry *mac;\n\tstruct device *dev = priv->ds->dev;\n\tu64 speed;\n\tint rc;\n\n\t \n\tmac = priv->static_config.tables[BLK_IDX_MAC_CONFIG].entries;\n\n\tswitch (speed_mbps) {\n\tcase SPEED_UNKNOWN:\n\t\t \n\t\tspeed = priv->info->port_speed[SJA1105_SPEED_AUTO];\n\t\tbreak;\n\tcase SPEED_10:\n\t\tspeed = priv->info->port_speed[SJA1105_SPEED_10MBPS];\n\t\tbreak;\n\tcase SPEED_100:\n\t\tspeed = priv->info->port_speed[SJA1105_SPEED_100MBPS];\n\t\tbreak;\n\tcase SPEED_1000:\n\t\tspeed = priv->info->port_speed[SJA1105_SPEED_1000MBPS];\n\t\tbreak;\n\tcase SPEED_2500:\n\t\tspeed = priv->info->port_speed[SJA1105_SPEED_2500MBPS];\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Invalid speed %iMbps\\n\", speed_mbps);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (priv->phy_mode[port] == PHY_INTERFACE_MODE_SGMII)\n\t\tmac[port].speed = priv->info->port_speed[SJA1105_SPEED_1000MBPS];\n\telse if (priv->phy_mode[port] == PHY_INTERFACE_MODE_2500BASEX)\n\t\tmac[port].speed = priv->info->port_speed[SJA1105_SPEED_2500MBPS];\n\telse\n\t\tmac[port].speed = speed;\n\n\t \n\trc = sja1105_dynamic_config_write(priv, BLK_IDX_MAC_CONFIG, port,\n\t\t\t\t\t  &mac[port], true);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"Failed to write MAC config: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t \n\tif (!phy_interface_mode_is_rgmii(priv->phy_mode[port]))\n\t\treturn 0;\n\n\treturn sja1105_clocking_setup_port(priv, port);\n}\n\nstatic struct phylink_pcs *\nsja1105_mac_select_pcs(struct dsa_switch *ds, int port, phy_interface_t iface)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct dw_xpcs *xpcs = priv->xpcs[port];\n\n\tif (xpcs)\n\t\treturn &xpcs->pcs;\n\n\treturn NULL;\n}\n\nstatic void sja1105_mac_link_down(struct dsa_switch *ds, int port,\n\t\t\t\t  unsigned int mode,\n\t\t\t\t  phy_interface_t interface)\n{\n\tsja1105_inhibit_tx(ds->priv, BIT(port), true);\n}\n\nstatic void sja1105_mac_link_up(struct dsa_switch *ds, int port,\n\t\t\t\tunsigned int mode,\n\t\t\t\tphy_interface_t interface,\n\t\t\t\tstruct phy_device *phydev,\n\t\t\t\tint speed, int duplex,\n\t\t\t\tbool tx_pause, bool rx_pause)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\n\tsja1105_adjust_port_config(priv, port, speed);\n\n\tsja1105_inhibit_tx(priv, BIT(port), false);\n}\n\nstatic void sja1105_phylink_get_caps(struct dsa_switch *ds, int port,\n\t\t\t\t     struct phylink_config *config)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct sja1105_xmii_params_entry *mii;\n\tphy_interface_t phy_mode;\n\n\tphy_mode = priv->phy_mode[port];\n\tif (phy_mode == PHY_INTERFACE_MODE_SGMII ||\n\t    phy_mode == PHY_INTERFACE_MODE_2500BASEX) {\n\t\t \n\t\tif (priv->info->supports_sgmii[port])\n\t\t\t__set_bit(PHY_INTERFACE_MODE_SGMII,\n\t\t\t\t  config->supported_interfaces);\n\n\t\tif (priv->info->supports_2500basex[port])\n\t\t\t__set_bit(PHY_INTERFACE_MODE_2500BASEX,\n\t\t\t\t  config->supported_interfaces);\n\t} else {\n\t\t \n\t\t__set_bit(phy_mode, config->supported_interfaces);\n\t}\n\n\t \n\tconfig->mac_capabilities = MAC_10FD | MAC_100FD;\n\n\tmii = priv->static_config.tables[BLK_IDX_XMII_PARAMS].entries;\n\tif (mii->xmii_mode[port] == XMII_MODE_RGMII ||\n\t    mii->xmii_mode[port] == XMII_MODE_SGMII)\n\t\tconfig->mac_capabilities |= MAC_1000FD;\n\n\tif (priv->info->supports_2500basex[port])\n\t\tconfig->mac_capabilities |= MAC_2500FD;\n}\n\nstatic int\nsja1105_find_static_fdb_entry(struct sja1105_private *priv, int port,\n\t\t\t      const struct sja1105_l2_lookup_entry *requested)\n{\n\tstruct sja1105_l2_lookup_entry *l2_lookup;\n\tstruct sja1105_table *table;\n\tint i;\n\n\ttable = &priv->static_config.tables[BLK_IDX_L2_LOOKUP];\n\tl2_lookup = table->entries;\n\n\tfor (i = 0; i < table->entry_count; i++)\n\t\tif (l2_lookup[i].macaddr == requested->macaddr &&\n\t\t    l2_lookup[i].vlanid == requested->vlanid &&\n\t\t    l2_lookup[i].destports & BIT(port))\n\t\t\treturn i;\n\n\treturn -1;\n}\n\n \nstatic int\nsja1105_static_fdb_change(struct sja1105_private *priv, int port,\n\t\t\t  const struct sja1105_l2_lookup_entry *requested,\n\t\t\t  bool keep)\n{\n\tstruct sja1105_l2_lookup_entry *l2_lookup;\n\tstruct sja1105_table *table;\n\tint rc, match;\n\n\ttable = &priv->static_config.tables[BLK_IDX_L2_LOOKUP];\n\n\tmatch = sja1105_find_static_fdb_entry(priv, port, requested);\n\tif (match < 0) {\n\t\t \n\t\tif (!keep)\n\t\t\treturn 0;\n\n\t\t \n\t\trc = sja1105_table_resize(table, table->entry_count + 1);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tmatch = table->entry_count - 1;\n\t}\n\n\t \n\tl2_lookup = table->entries;\n\n\t \n\tif (keep) {\n\t\tl2_lookup[match] = *requested;\n\t\treturn 0;\n\t}\n\n\t \n\tl2_lookup[match] = l2_lookup[table->entry_count - 1];\n\treturn sja1105_table_resize(table, table->entry_count - 1);\n}\n\n \nstatic int sja1105et_fdb_index(int bin, int way)\n{\n\treturn bin * SJA1105ET_FDB_BIN_SIZE + way;\n}\n\nstatic int sja1105et_is_fdb_entry_in_bin(struct sja1105_private *priv, int bin,\n\t\t\t\t\t const u8 *addr, u16 vid,\n\t\t\t\t\t struct sja1105_l2_lookup_entry *match,\n\t\t\t\t\t int *last_unused)\n{\n\tint way;\n\n\tfor (way = 0; way < SJA1105ET_FDB_BIN_SIZE; way++) {\n\t\tstruct sja1105_l2_lookup_entry l2_lookup = {0};\n\t\tint index = sja1105et_fdb_index(bin, way);\n\n\t\t \n\t\tif (sja1105_dynamic_config_read(priv, BLK_IDX_L2_LOOKUP,\n\t\t\t\t\t\tindex, &l2_lookup)) {\n\t\t\tif (last_unused)\n\t\t\t\t*last_unused = way;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (l2_lookup.macaddr == ether_addr_to_u64(addr) &&\n\t\t    l2_lookup.vlanid == vid) {\n\t\t\tif (match)\n\t\t\t\t*match = l2_lookup;\n\t\t\treturn way;\n\t\t}\n\t}\n\t \n\treturn -1;\n}\n\nint sja1105et_fdb_add(struct dsa_switch *ds, int port,\n\t\t      const unsigned char *addr, u16 vid)\n{\n\tstruct sja1105_l2_lookup_entry l2_lookup = {0}, tmp;\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct device *dev = ds->dev;\n\tint last_unused = -1;\n\tint start, end, i;\n\tint bin, way, rc;\n\n\tbin = sja1105et_fdb_hash(priv, addr, vid);\n\n\tway = sja1105et_is_fdb_entry_in_bin(priv, bin, addr, vid,\n\t\t\t\t\t    &l2_lookup, &last_unused);\n\tif (way >= 0) {\n\t\t \n\t\tif ((l2_lookup.destports & BIT(port)) && l2_lookup.lockeds)\n\t\t\treturn 0;\n\t\tl2_lookup.destports |= BIT(port);\n\t} else {\n\t\tint index = sja1105et_fdb_index(bin, way);\n\n\t\t \n\t\tl2_lookup.macaddr = ether_addr_to_u64(addr);\n\t\tl2_lookup.destports = BIT(port);\n\t\tl2_lookup.vlanid = vid;\n\n\t\tif (last_unused >= 0) {\n\t\t\tway = last_unused;\n\t\t} else {\n\t\t\t \n\t\t\tget_random_bytes(&way, sizeof(u8));\n\t\t\tway %= SJA1105ET_FDB_BIN_SIZE;\n\t\t\tdev_warn(dev, \"Warning, FDB bin %d full while adding entry for %pM. Evicting entry %u.\\n\",\n\t\t\t\t bin, addr, way);\n\t\t\t \n\t\t\tsja1105_dynamic_config_write(priv, BLK_IDX_L2_LOOKUP,\n\t\t\t\t\t\t     index, NULL, false);\n\t\t}\n\t}\n\tl2_lookup.lockeds = true;\n\tl2_lookup.index = sja1105et_fdb_index(bin, way);\n\n\trc = sja1105_dynamic_config_write(priv, BLK_IDX_L2_LOOKUP,\n\t\t\t\t\t  l2_lookup.index, &l2_lookup,\n\t\t\t\t\t  true);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tstart = sja1105et_fdb_index(bin, 0);\n\tend = sja1105et_fdb_index(bin, way);\n\n\tfor (i = start; i < end; i++) {\n\t\trc = sja1105_dynamic_config_read(priv, BLK_IDX_L2_LOOKUP,\n\t\t\t\t\t\t i, &tmp);\n\t\tif (rc == -ENOENT)\n\t\t\tcontinue;\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tif (tmp.macaddr != ether_addr_to_u64(addr) || tmp.vlanid != vid)\n\t\t\tcontinue;\n\n\t\trc = sja1105_dynamic_config_write(priv, BLK_IDX_L2_LOOKUP,\n\t\t\t\t\t\t  i, NULL, false);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tbreak;\n\t}\n\n\treturn sja1105_static_fdb_change(priv, port, &l2_lookup, true);\n}\n\nint sja1105et_fdb_del(struct dsa_switch *ds, int port,\n\t\t      const unsigned char *addr, u16 vid)\n{\n\tstruct sja1105_l2_lookup_entry l2_lookup = {0};\n\tstruct sja1105_private *priv = ds->priv;\n\tint index, bin, way, rc;\n\tbool keep;\n\n\tbin = sja1105et_fdb_hash(priv, addr, vid);\n\tway = sja1105et_is_fdb_entry_in_bin(priv, bin, addr, vid,\n\t\t\t\t\t    &l2_lookup, NULL);\n\tif (way < 0)\n\t\treturn 0;\n\tindex = sja1105et_fdb_index(bin, way);\n\n\t \n\tl2_lookup.destports &= ~BIT(port);\n\n\tif (l2_lookup.destports)\n\t\tkeep = true;\n\telse\n\t\tkeep = false;\n\n\trc = sja1105_dynamic_config_write(priv, BLK_IDX_L2_LOOKUP,\n\t\t\t\t\t  index, &l2_lookup, keep);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn sja1105_static_fdb_change(priv, port, &l2_lookup, keep);\n}\n\nint sja1105pqrs_fdb_add(struct dsa_switch *ds, int port,\n\t\t\tconst unsigned char *addr, u16 vid)\n{\n\tstruct sja1105_l2_lookup_entry l2_lookup = {0}, tmp;\n\tstruct sja1105_private *priv = ds->priv;\n\tint rc, i;\n\n\t \n\tl2_lookup.macaddr = ether_addr_to_u64(addr);\n\tl2_lookup.vlanid = vid;\n\tl2_lookup.mask_macaddr = GENMASK_ULL(ETH_ALEN * 8 - 1, 0);\n\tl2_lookup.mask_vlanid = VLAN_VID_MASK;\n\tl2_lookup.destports = BIT(port);\n\n\ttmp = l2_lookup;\n\n\trc = sja1105_dynamic_config_read(priv, BLK_IDX_L2_LOOKUP,\n\t\t\t\t\t SJA1105_SEARCH, &tmp);\n\tif (rc == 0 && tmp.index != SJA1105_MAX_L2_LOOKUP_COUNT - 1) {\n\t\t \n\t\tif ((tmp.destports & BIT(port)) && tmp.lockeds)\n\t\t\treturn 0;\n\n\t\tl2_lookup = tmp;\n\n\t\t \n\t\tl2_lookup.destports |= BIT(port);\n\t\tgoto skip_finding_an_index;\n\t}\n\n\t \n\tfor (i = 0; i < SJA1105_MAX_L2_LOOKUP_COUNT; i++) {\n\t\trc = sja1105_dynamic_config_read(priv, BLK_IDX_L2_LOOKUP,\n\t\t\t\t\t\t i, NULL);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\t}\n\tif (i == SJA1105_MAX_L2_LOOKUP_COUNT) {\n\t\tdev_err(ds->dev, \"FDB is full, cannot add entry.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tl2_lookup.index = i;\n\nskip_finding_an_index:\n\tl2_lookup.lockeds = true;\n\n\trc = sja1105_dynamic_config_write(priv, BLK_IDX_L2_LOOKUP,\n\t\t\t\t\t  l2_lookup.index, &l2_lookup,\n\t\t\t\t\t  true);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\ttmp = l2_lookup;\n\n\trc = sja1105_dynamic_config_read(priv, BLK_IDX_L2_LOOKUP,\n\t\t\t\t\t SJA1105_SEARCH, &tmp);\n\tif (rc < 0) {\n\t\tdev_err(ds->dev,\n\t\t\t\"port %d failed to read back entry for %pM vid %d: %pe\\n\",\n\t\t\tport, addr, vid, ERR_PTR(rc));\n\t\treturn rc;\n\t}\n\n\tif (tmp.index < l2_lookup.index) {\n\t\trc = sja1105_dynamic_config_write(priv, BLK_IDX_L2_LOOKUP,\n\t\t\t\t\t\t  tmp.index, NULL, false);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\n\treturn sja1105_static_fdb_change(priv, port, &l2_lookup, true);\n}\n\nint sja1105pqrs_fdb_del(struct dsa_switch *ds, int port,\n\t\t\tconst unsigned char *addr, u16 vid)\n{\n\tstruct sja1105_l2_lookup_entry l2_lookup = {0};\n\tstruct sja1105_private *priv = ds->priv;\n\tbool keep;\n\tint rc;\n\n\tl2_lookup.macaddr = ether_addr_to_u64(addr);\n\tl2_lookup.vlanid = vid;\n\tl2_lookup.mask_macaddr = GENMASK_ULL(ETH_ALEN * 8 - 1, 0);\n\tl2_lookup.mask_vlanid = VLAN_VID_MASK;\n\tl2_lookup.destports = BIT(port);\n\n\trc = sja1105_dynamic_config_read(priv, BLK_IDX_L2_LOOKUP,\n\t\t\t\t\t SJA1105_SEARCH, &l2_lookup);\n\tif (rc < 0)\n\t\treturn 0;\n\n\tl2_lookup.destports &= ~BIT(port);\n\n\t \n\tif (l2_lookup.destports)\n\t\tkeep = true;\n\telse\n\t\tkeep = false;\n\n\trc = sja1105_dynamic_config_write(priv, BLK_IDX_L2_LOOKUP,\n\t\t\t\t\t  l2_lookup.index, &l2_lookup, keep);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn sja1105_static_fdb_change(priv, port, &l2_lookup, keep);\n}\n\nstatic int sja1105_fdb_add(struct dsa_switch *ds, int port,\n\t\t\t   const unsigned char *addr, u16 vid,\n\t\t\t   struct dsa_db db)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tint rc;\n\n\tif (!vid) {\n\t\tswitch (db.type) {\n\t\tcase DSA_DB_PORT:\n\t\t\tvid = dsa_tag_8021q_standalone_vid(db.dp);\n\t\t\tbreak;\n\t\tcase DSA_DB_BRIDGE:\n\t\t\tvid = dsa_tag_8021q_bridge_vid(db.bridge.num);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tmutex_lock(&priv->fdb_lock);\n\trc = priv->info->fdb_add_cmd(ds, port, addr, vid);\n\tmutex_unlock(&priv->fdb_lock);\n\n\treturn rc;\n}\n\nstatic int __sja1105_fdb_del(struct dsa_switch *ds, int port,\n\t\t\t     const unsigned char *addr, u16 vid,\n\t\t\t     struct dsa_db db)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\n\tif (!vid) {\n\t\tswitch (db.type) {\n\t\tcase DSA_DB_PORT:\n\t\t\tvid = dsa_tag_8021q_standalone_vid(db.dp);\n\t\t\tbreak;\n\t\tcase DSA_DB_BRIDGE:\n\t\t\tvid = dsa_tag_8021q_bridge_vid(db.bridge.num);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\treturn priv->info->fdb_del_cmd(ds, port, addr, vid);\n}\n\nstatic int sja1105_fdb_del(struct dsa_switch *ds, int port,\n\t\t\t   const unsigned char *addr, u16 vid,\n\t\t\t   struct dsa_db db)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tint rc;\n\n\tmutex_lock(&priv->fdb_lock);\n\trc = __sja1105_fdb_del(ds, port, addr, vid, db);\n\tmutex_unlock(&priv->fdb_lock);\n\n\treturn rc;\n}\n\nstatic int sja1105_fdb_dump(struct dsa_switch *ds, int port,\n\t\t\t    dsa_fdb_dump_cb_t *cb, void *data)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct device *dev = ds->dev;\n\tint i;\n\n\tfor (i = 0; i < SJA1105_MAX_L2_LOOKUP_COUNT; i++) {\n\t\tstruct sja1105_l2_lookup_entry l2_lookup = {0};\n\t\tu8 macaddr[ETH_ALEN];\n\t\tint rc;\n\n\t\trc = sja1105_dynamic_config_read(priv, BLK_IDX_L2_LOOKUP,\n\t\t\t\t\t\t i, &l2_lookup);\n\t\t \n\t\tif (rc == -ENOENT)\n\t\t\tcontinue;\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"Failed to dump FDB: %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\t \n\t\tif (!(l2_lookup.destports & BIT(port)))\n\t\t\tcontinue;\n\n\t\tu64_to_ether_addr(l2_lookup.macaddr, macaddr);\n\n\t\t \n\t\tif (is_multicast_ether_addr(macaddr))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (vid_is_dsa_8021q(l2_lookup.vlanid))\n\t\t\tl2_lookup.vlanid = 0;\n\t\trc = cb(macaddr, l2_lookup.vlanid, l2_lookup.lockeds, data);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic void sja1105_fast_age(struct dsa_switch *ds, int port)\n{\n\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct dsa_db db = {\n\t\t.type = DSA_DB_BRIDGE,\n\t\t.bridge = {\n\t\t\t.dev = dsa_port_bridge_dev_get(dp),\n\t\t\t.num = dsa_port_bridge_num_get(dp),\n\t\t},\n\t};\n\tint i;\n\n\tmutex_lock(&priv->fdb_lock);\n\n\tfor (i = 0; i < SJA1105_MAX_L2_LOOKUP_COUNT; i++) {\n\t\tstruct sja1105_l2_lookup_entry l2_lookup = {0};\n\t\tu8 macaddr[ETH_ALEN];\n\t\tint rc;\n\n\t\trc = sja1105_dynamic_config_read(priv, BLK_IDX_L2_LOOKUP,\n\t\t\t\t\t\t i, &l2_lookup);\n\t\t \n\t\tif (rc == -ENOENT)\n\t\t\tcontinue;\n\t\tif (rc) {\n\t\t\tdev_err(ds->dev, \"Failed to read FDB: %pe\\n\",\n\t\t\t\tERR_PTR(rc));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(l2_lookup.destports & BIT(port)))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (l2_lookup.lockeds)\n\t\t\tcontinue;\n\n\t\tu64_to_ether_addr(l2_lookup.macaddr, macaddr);\n\n\t\trc = __sja1105_fdb_del(ds, port, macaddr, l2_lookup.vlanid, db);\n\t\tif (rc) {\n\t\t\tdev_err(ds->dev,\n\t\t\t\t\"Failed to delete FDB entry %pM vid %lld: %pe\\n\",\n\t\t\t\tmacaddr, l2_lookup.vlanid, ERR_PTR(rc));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&priv->fdb_lock);\n}\n\nstatic int sja1105_mdb_add(struct dsa_switch *ds, int port,\n\t\t\t   const struct switchdev_obj_port_mdb *mdb,\n\t\t\t   struct dsa_db db)\n{\n\treturn sja1105_fdb_add(ds, port, mdb->addr, mdb->vid, db);\n}\n\nstatic int sja1105_mdb_del(struct dsa_switch *ds, int port,\n\t\t\t   const struct switchdev_obj_port_mdb *mdb,\n\t\t\t   struct dsa_db db)\n{\n\treturn sja1105_fdb_del(ds, port, mdb->addr, mdb->vid, db);\n}\n\n \nstatic int sja1105_manage_flood_domains(struct sja1105_private *priv)\n{\n\tstruct sja1105_l2_forwarding_entry *l2_fwd;\n\tstruct dsa_switch *ds = priv->ds;\n\tint from, to, rc;\n\n\tl2_fwd = priv->static_config.tables[BLK_IDX_L2_FORWARDING].entries;\n\n\tfor (from = 0; from < ds->num_ports; from++) {\n\t\tu64 fl_domain = 0, bc_domain = 0;\n\n\t\tfor (to = 0; to < priv->ds->num_ports; to++) {\n\t\t\tif (!sja1105_can_forward(l2_fwd, from, to))\n\t\t\t\tcontinue;\n\n\t\t\tif (priv->ucast_egress_floods & BIT(to))\n\t\t\t\tfl_domain |= BIT(to);\n\t\t\tif (priv->bcast_egress_floods & BIT(to))\n\t\t\t\tbc_domain |= BIT(to);\n\t\t}\n\n\t\t \n\t\tif (l2_fwd[from].fl_domain == fl_domain &&\n\t\t    l2_fwd[from].bc_domain == bc_domain)\n\t\t\tcontinue;\n\n\t\tl2_fwd[from].fl_domain = fl_domain;\n\t\tl2_fwd[from].bc_domain = bc_domain;\n\n\t\trc = sja1105_dynamic_config_write(priv, BLK_IDX_L2_FORWARDING,\n\t\t\t\t\t\t  from, &l2_fwd[from], true);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int sja1105_bridge_member(struct dsa_switch *ds, int port,\n\t\t\t\t struct dsa_bridge bridge, bool member)\n{\n\tstruct sja1105_l2_forwarding_entry *l2_fwd;\n\tstruct sja1105_private *priv = ds->priv;\n\tint i, rc;\n\n\tl2_fwd = priv->static_config.tables[BLK_IDX_L2_FORWARDING].entries;\n\n\tfor (i = 0; i < ds->num_ports; i++) {\n\t\t \n\t\tif (!dsa_is_user_port(ds, i))\n\t\t\tcontinue;\n\t\t \n\t\tif (i == port)\n\t\t\tcontinue;\n\t\tif (!dsa_port_offloads_bridge(dsa_to_port(ds, i), &bridge))\n\t\t\tcontinue;\n\t\tsja1105_port_allow_traffic(l2_fwd, i, port, member);\n\t\tsja1105_port_allow_traffic(l2_fwd, port, i, member);\n\n\t\trc = sja1105_dynamic_config_write(priv, BLK_IDX_L2_FORWARDING,\n\t\t\t\t\t\t  i, &l2_fwd[i], true);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\n\trc = sja1105_dynamic_config_write(priv, BLK_IDX_L2_FORWARDING,\n\t\t\t\t\t  port, &l2_fwd[port], true);\n\tif (rc)\n\t\treturn rc;\n\n\trc = sja1105_commit_pvid(ds, port);\n\tif (rc)\n\t\treturn rc;\n\n\treturn sja1105_manage_flood_domains(priv);\n}\n\nstatic void sja1105_bridge_stp_state_set(struct dsa_switch *ds, int port,\n\t\t\t\t\t u8 state)\n{\n\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct sja1105_mac_config_entry *mac;\n\n\tmac = priv->static_config.tables[BLK_IDX_MAC_CONFIG].entries;\n\n\tswitch (state) {\n\tcase BR_STATE_DISABLED:\n\tcase BR_STATE_BLOCKING:\n\t\t \n\t\tmac[port].ingress   = false;\n\t\tmac[port].egress    = false;\n\t\tmac[port].dyn_learn = false;\n\t\tbreak;\n\tcase BR_STATE_LISTENING:\n\t\tmac[port].ingress   = true;\n\t\tmac[port].egress    = false;\n\t\tmac[port].dyn_learn = false;\n\t\tbreak;\n\tcase BR_STATE_LEARNING:\n\t\tmac[port].ingress   = true;\n\t\tmac[port].egress    = false;\n\t\tmac[port].dyn_learn = dp->learning;\n\t\tbreak;\n\tcase BR_STATE_FORWARDING:\n\t\tmac[port].ingress   = true;\n\t\tmac[port].egress    = true;\n\t\tmac[port].dyn_learn = dp->learning;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(ds->dev, \"invalid STP state: %d\\n\", state);\n\t\treturn;\n\t}\n\n\tsja1105_dynamic_config_write(priv, BLK_IDX_MAC_CONFIG, port,\n\t\t\t\t     &mac[port], true);\n}\n\nstatic int sja1105_bridge_join(struct dsa_switch *ds, int port,\n\t\t\t       struct dsa_bridge bridge,\n\t\t\t       bool *tx_fwd_offload,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tint rc;\n\n\trc = sja1105_bridge_member(ds, port, bridge, true);\n\tif (rc)\n\t\treturn rc;\n\n\trc = dsa_tag_8021q_bridge_join(ds, port, bridge);\n\tif (rc) {\n\t\tsja1105_bridge_member(ds, port, bridge, false);\n\t\treturn rc;\n\t}\n\n\t*tx_fwd_offload = true;\n\n\treturn 0;\n}\n\nstatic void sja1105_bridge_leave(struct dsa_switch *ds, int port,\n\t\t\t\t struct dsa_bridge bridge)\n{\n\tdsa_tag_8021q_bridge_leave(ds, port, bridge);\n\tsja1105_bridge_member(ds, port, bridge, false);\n}\n\n#define BYTES_PER_KBIT (1000LL / 8)\n \n#define SJA1110_FIXED_CBS(port, prio) ((((port) - 1) * SJA1105_NUM_TC) + (prio))\n\nstatic int sja1105_find_cbs_shaper(struct sja1105_private *priv,\n\t\t\t\t   int port, int prio)\n{\n\tint i;\n\n\tif (priv->info->fixed_cbs_mapping) {\n\t\ti = SJA1110_FIXED_CBS(port, prio);\n\t\tif (i >= 0 && i < priv->info->num_cbs_shapers)\n\t\t\treturn i;\n\n\t\treturn -1;\n\t}\n\n\tfor (i = 0; i < priv->info->num_cbs_shapers; i++)\n\t\tif (priv->cbs[i].port == port && priv->cbs[i].prio == prio)\n\t\t\treturn i;\n\n\treturn -1;\n}\n\nstatic int sja1105_find_unused_cbs_shaper(struct sja1105_private *priv)\n{\n\tint i;\n\n\tif (priv->info->fixed_cbs_mapping)\n\t\treturn -1;\n\n\tfor (i = 0; i < priv->info->num_cbs_shapers; i++)\n\t\tif (!priv->cbs[i].idle_slope && !priv->cbs[i].send_slope)\n\t\t\treturn i;\n\n\treturn -1;\n}\n\nstatic int sja1105_delete_cbs_shaper(struct sja1105_private *priv, int port,\n\t\t\t\t     int prio)\n{\n\tint i;\n\n\tfor (i = 0; i < priv->info->num_cbs_shapers; i++) {\n\t\tstruct sja1105_cbs_entry *cbs = &priv->cbs[i];\n\n\t\tif (cbs->port == port && cbs->prio == prio) {\n\t\t\tmemset(cbs, 0, sizeof(*cbs));\n\t\t\treturn sja1105_dynamic_config_write(priv, BLK_IDX_CBS,\n\t\t\t\t\t\t\t    i, cbs, true);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sja1105_setup_tc_cbs(struct dsa_switch *ds, int port,\n\t\t\t\tstruct tc_cbs_qopt_offload *offload)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct sja1105_cbs_entry *cbs;\n\ts64 port_transmit_rate_kbps;\n\tint index;\n\n\tif (!offload->enable)\n\t\treturn sja1105_delete_cbs_shaper(priv, port, offload->queue);\n\n\t \n\tindex = sja1105_find_cbs_shaper(priv, port, offload->queue);\n\tif (index < 0) {\n\t\t \n\t\tindex = sja1105_find_unused_cbs_shaper(priv);\n\t\tif (index < 0)\n\t\t\treturn -ENOSPC;\n\t}\n\n\tcbs = &priv->cbs[index];\n\tcbs->port = port;\n\tcbs->prio = offload->queue;\n\t \n\tcbs->credit_hi = offload->hicredit;\n\tcbs->credit_lo = abs(offload->locredit);\n\t \n\tport_transmit_rate_kbps = offload->idleslope - offload->sendslope;\n\tcbs->idle_slope = div_s64(offload->idleslope * BYTES_PER_KBIT,\n\t\t\t\t  port_transmit_rate_kbps);\n\tcbs->send_slope = div_s64(abs(offload->sendslope * BYTES_PER_KBIT),\n\t\t\t\t  port_transmit_rate_kbps);\n\t \n\tcbs->credit_lo &= GENMASK_ULL(31, 0);\n\tcbs->send_slope &= GENMASK_ULL(31, 0);\n\n\treturn sja1105_dynamic_config_write(priv, BLK_IDX_CBS, index, cbs,\n\t\t\t\t\t    true);\n}\n\nstatic int sja1105_reload_cbs(struct sja1105_private *priv)\n{\n\tint rc = 0, i;\n\n\t \n\tif (!priv->cbs)\n\t\treturn 0;\n\n\tfor (i = 0; i < priv->info->num_cbs_shapers; i++) {\n\t\tstruct sja1105_cbs_entry *cbs = &priv->cbs[i];\n\n\t\tif (!cbs->idle_slope && !cbs->send_slope)\n\t\t\tcontinue;\n\n\t\trc = sja1105_dynamic_config_write(priv, BLK_IDX_CBS, i, cbs,\n\t\t\t\t\t\t  true);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic const char * const sja1105_reset_reasons[] = {\n\t[SJA1105_VLAN_FILTERING] = \"VLAN filtering\",\n\t[SJA1105_AGEING_TIME] = \"Ageing time\",\n\t[SJA1105_SCHEDULING] = \"Time-aware scheduling\",\n\t[SJA1105_BEST_EFFORT_POLICING] = \"Best-effort policing\",\n\t[SJA1105_VIRTUAL_LINKS] = \"Virtual links\",\n};\n\n \nint sja1105_static_config_reload(struct sja1105_private *priv,\n\t\t\t\t enum sja1105_reset_reason reason)\n{\n\tstruct ptp_system_timestamp ptp_sts_before;\n\tstruct ptp_system_timestamp ptp_sts_after;\n\tint speed_mbps[SJA1105_MAX_NUM_PORTS];\n\tu16 bmcr[SJA1105_MAX_NUM_PORTS] = {0};\n\tstruct sja1105_mac_config_entry *mac;\n\tstruct dsa_switch *ds = priv->ds;\n\ts64 t1, t2, t3, t4;\n\ts64 t12, t34;\n\tint rc, i;\n\ts64 now;\n\n\tmutex_lock(&priv->fdb_lock);\n\tmutex_lock(&priv->mgmt_lock);\n\n\tmac = priv->static_config.tables[BLK_IDX_MAC_CONFIG].entries;\n\n\t \n\tfor (i = 0; i < ds->num_ports; i++) {\n\t\tspeed_mbps[i] = sja1105_port_speed_to_ethtool(priv,\n\t\t\t\t\t\t\t      mac[i].speed);\n\t\tmac[i].speed = priv->info->port_speed[SJA1105_SPEED_AUTO];\n\n\t\tif (priv->xpcs[i])\n\t\t\tbmcr[i] = mdiobus_c45_read(priv->mdio_pcs, i,\n\t\t\t\t\t\t   MDIO_MMD_VEND2, MDIO_CTRL1);\n\t}\n\n\t \n\tmutex_lock(&priv->ptp_data.lock);\n\n\trc = __sja1105_ptp_gettimex(ds, &now, &ptp_sts_before);\n\tif (rc < 0) {\n\t\tmutex_unlock(&priv->ptp_data.lock);\n\t\tgoto out;\n\t}\n\n\t \n\trc = sja1105_static_config_upload(priv);\n\tif (rc < 0) {\n\t\tmutex_unlock(&priv->ptp_data.lock);\n\t\tgoto out;\n\t}\n\n\trc = __sja1105_ptp_settime(ds, 0, &ptp_sts_after);\n\tif (rc < 0) {\n\t\tmutex_unlock(&priv->ptp_data.lock);\n\t\tgoto out;\n\t}\n\n\tt1 = timespec64_to_ns(&ptp_sts_before.pre_ts);\n\tt2 = timespec64_to_ns(&ptp_sts_before.post_ts);\n\tt3 = timespec64_to_ns(&ptp_sts_after.pre_ts);\n\tt4 = timespec64_to_ns(&ptp_sts_after.post_ts);\n\t \n\tt12 = t1 + (t2 - t1) / 2;\n\t \n\tt34 = t3 + (t4 - t3) / 2;\n\t \n\tnow += (t34 - t12);\n\n\t__sja1105_ptp_adjtime(ds, now);\n\n\tmutex_unlock(&priv->ptp_data.lock);\n\n\tdev_info(priv->ds->dev,\n\t\t \"Reset switch and programmed static config. Reason: %s\\n\",\n\t\t sja1105_reset_reasons[reason]);\n\n\t \n\tif (priv->info->clocking_setup) {\n\t\trc = priv->info->clocking_setup(priv);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < ds->num_ports; i++) {\n\t\tstruct dw_xpcs *xpcs = priv->xpcs[i];\n\t\tunsigned int neg_mode;\n\n\t\trc = sja1105_adjust_port_config(priv, i, speed_mbps[i]);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\n\t\tif (!xpcs)\n\t\t\tcontinue;\n\n\t\tif (bmcr[i] & BMCR_ANENABLE)\n\t\t\tneg_mode = PHYLINK_PCS_NEG_INBAND_ENABLED;\n\t\telse\n\t\t\tneg_mode = PHYLINK_PCS_NEG_OUTBAND;\n\n\t\trc = xpcs_do_config(xpcs, priv->phy_mode[i], NULL, neg_mode);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\n\t\tif (neg_mode == PHYLINK_PCS_NEG_OUTBAND) {\n\t\t\tint speed = SPEED_UNKNOWN;\n\n\t\t\tif (priv->phy_mode[i] == PHY_INTERFACE_MODE_2500BASEX)\n\t\t\t\tspeed = SPEED_2500;\n\t\t\telse if (bmcr[i] & BMCR_SPEED1000)\n\t\t\t\tspeed = SPEED_1000;\n\t\t\telse if (bmcr[i] & BMCR_SPEED100)\n\t\t\t\tspeed = SPEED_100;\n\t\t\telse\n\t\t\t\tspeed = SPEED_10;\n\n\t\t\txpcs_link_up(&xpcs->pcs, neg_mode, priv->phy_mode[i],\n\t\t\t\t     speed, DUPLEX_FULL);\n\t\t}\n\t}\n\n\trc = sja1105_reload_cbs(priv);\n\tif (rc < 0)\n\t\tgoto out;\nout:\n\tmutex_unlock(&priv->mgmt_lock);\n\tmutex_unlock(&priv->fdb_lock);\n\n\treturn rc;\n}\n\nstatic enum dsa_tag_protocol\nsja1105_get_tag_protocol(struct dsa_switch *ds, int port,\n\t\t\t enum dsa_tag_protocol mp)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\n\treturn priv->info->tag_proto;\n}\n\n \nint sja1105_vlan_filtering(struct dsa_switch *ds, int port, bool enabled,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct sja1105_general_params_entry *general_params;\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct sja1105_table *table;\n\tstruct sja1105_rule *rule;\n\tu16 tpid, tpid2;\n\tint rc;\n\n\tlist_for_each_entry(rule, &priv->flow_block.rules, list) {\n\t\tif (rule->type == SJA1105_RULE_VL) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Cannot change VLAN filtering with active VL rules\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tif (enabled) {\n\t\t \n\t\ttpid  = ETH_P_8021Q;\n\t\ttpid2 = ETH_P_8021AD;\n\t} else {\n\t\t \n\t\ttpid  = ETH_P_SJA1105;\n\t\ttpid2 = ETH_P_SJA1105;\n\t}\n\n\ttable = &priv->static_config.tables[BLK_IDX_GENERAL_PARAMS];\n\tgeneral_params = table->entries;\n\t \n\tgeneral_params->tpid = tpid;\n\t \n\tgeneral_params->tpid2 = tpid2;\n\n\tfor (port = 0; port < ds->num_ports; port++) {\n\t\tif (dsa_is_unused_port(ds, port))\n\t\t\tcontinue;\n\n\t\trc = sja1105_commit_pvid(ds, port);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = sja1105_static_config_reload(priv, SJA1105_VLAN_FILTERING);\n\tif (rc)\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to change VLAN Ethertype\");\n\n\treturn rc;\n}\n\nstatic int sja1105_vlan_add(struct sja1105_private *priv, int port, u16 vid,\n\t\t\t    u16 flags, bool allowed_ingress)\n{\n\tstruct sja1105_vlan_lookup_entry *vlan;\n\tstruct sja1105_table *table;\n\tint match, rc;\n\n\ttable = &priv->static_config.tables[BLK_IDX_VLAN_LOOKUP];\n\n\tmatch = sja1105_is_vlan_configured(priv, vid);\n\tif (match < 0) {\n\t\trc = sja1105_table_resize(table, table->entry_count + 1);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tmatch = table->entry_count - 1;\n\t}\n\n\t \n\tvlan = table->entries;\n\n\tvlan[match].type_entry = SJA1110_VLAN_D_TAG;\n\tvlan[match].vlanid = vid;\n\tvlan[match].vlan_bc |= BIT(port);\n\n\tif (allowed_ingress)\n\t\tvlan[match].vmemb_port |= BIT(port);\n\telse\n\t\tvlan[match].vmemb_port &= ~BIT(port);\n\n\tif (flags & BRIDGE_VLAN_INFO_UNTAGGED)\n\t\tvlan[match].tag_port &= ~BIT(port);\n\telse\n\t\tvlan[match].tag_port |= BIT(port);\n\n\treturn sja1105_dynamic_config_write(priv, BLK_IDX_VLAN_LOOKUP, vid,\n\t\t\t\t\t    &vlan[match], true);\n}\n\nstatic int sja1105_vlan_del(struct sja1105_private *priv, int port, u16 vid)\n{\n\tstruct sja1105_vlan_lookup_entry *vlan;\n\tstruct sja1105_table *table;\n\tbool keep = true;\n\tint match, rc;\n\n\ttable = &priv->static_config.tables[BLK_IDX_VLAN_LOOKUP];\n\n\tmatch = sja1105_is_vlan_configured(priv, vid);\n\t \n\tif (match < 0)\n\t\treturn 0;\n\n\t \n\tvlan = table->entries;\n\n\tvlan[match].vlanid = vid;\n\tvlan[match].vlan_bc &= ~BIT(port);\n\tvlan[match].vmemb_port &= ~BIT(port);\n\t \n\tvlan[match].tag_port &= ~BIT(port);\n\n\t \n\tif (!vlan[match].vmemb_port)\n\t\tkeep = false;\n\n\trc = sja1105_dynamic_config_write(priv, BLK_IDX_VLAN_LOOKUP, vid,\n\t\t\t\t\t  &vlan[match], keep);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (!keep)\n\t\treturn sja1105_table_delete_entry(table, match);\n\n\treturn 0;\n}\n\nstatic int sja1105_bridge_vlan_add(struct dsa_switch *ds, int port,\n\t\t\t\t   const struct switchdev_obj_port_vlan *vlan,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tu16 flags = vlan->flags;\n\tint rc;\n\n\t \n\tif (vid_is_dsa_8021q(vlan->vid)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Range 3072-4095 reserved for dsa_8021q operation\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (dsa_is_cpu_port(ds, port) || dsa_is_dsa_port(ds, port))\n\t\tflags = 0;\n\n\trc = sja1105_vlan_add(priv, port, vlan->vid, flags, true);\n\tif (rc)\n\t\treturn rc;\n\n\tif (vlan->flags & BRIDGE_VLAN_INFO_PVID)\n\t\tpriv->bridge_pvid[port] = vlan->vid;\n\n\treturn sja1105_commit_pvid(ds, port);\n}\n\nstatic int sja1105_bridge_vlan_del(struct dsa_switch *ds, int port,\n\t\t\t\t   const struct switchdev_obj_port_vlan *vlan)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tint rc;\n\n\trc = sja1105_vlan_del(priv, port, vlan->vid);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\treturn sja1105_commit_pvid(ds, port);\n}\n\nstatic int sja1105_dsa_8021q_vlan_add(struct dsa_switch *ds, int port, u16 vid,\n\t\t\t\t      u16 flags)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tbool allowed_ingress = true;\n\tint rc;\n\n\t \n\tif (dsa_is_user_port(ds, port))\n\t\tallowed_ingress = false;\n\n\trc = sja1105_vlan_add(priv, port, vid, flags, allowed_ingress);\n\tif (rc)\n\t\treturn rc;\n\n\tif (flags & BRIDGE_VLAN_INFO_PVID)\n\t\tpriv->tag_8021q_pvid[port] = vid;\n\n\treturn sja1105_commit_pvid(ds, port);\n}\n\nstatic int sja1105_dsa_8021q_vlan_del(struct dsa_switch *ds, int port, u16 vid)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\n\treturn sja1105_vlan_del(priv, port, vid);\n}\n\nstatic int sja1105_prechangeupper(struct dsa_switch *ds, int port,\n\t\t\t\t  struct netdev_notifier_changeupper_info *info)\n{\n\tstruct netlink_ext_ack *extack = info->info.extack;\n\tstruct net_device *upper = info->upper_dev;\n\tstruct dsa_switch_tree *dst = ds->dst;\n\tstruct dsa_port *dp;\n\n\tif (is_vlan_dev(upper)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"8021q uppers are not supported\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (netif_is_bridge_master(upper)) {\n\t\tlist_for_each_entry(dp, &dst->ports, list) {\n\t\t\tstruct net_device *br = dsa_port_bridge_dev_get(dp);\n\n\t\t\tif (br && br != upper && br_vlan_enabled(br)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Only one VLAN-aware bridge is supported\");\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sja1105_mgmt_xmit(struct dsa_switch *ds, int port, int slot,\n\t\t\t     struct sk_buff *skb, bool takets)\n{\n\tstruct sja1105_mgmt_entry mgmt_route = {0};\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct ethhdr *hdr;\n\tint timeout = 10;\n\tint rc;\n\n\thdr = eth_hdr(skb);\n\n\tmgmt_route.macaddr = ether_addr_to_u64(hdr->h_dest);\n\tmgmt_route.destports = BIT(port);\n\tmgmt_route.enfport = 1;\n\tmgmt_route.tsreg = 0;\n\tmgmt_route.takets = takets;\n\n\trc = sja1105_dynamic_config_write(priv, BLK_IDX_MGMT_ROUTE,\n\t\t\t\t\t  slot, &mgmt_route, true);\n\tif (rc < 0) {\n\t\tkfree_skb(skb);\n\t\treturn rc;\n\t}\n\n\t \n\tdsa_enqueue_skb(skb, dsa_to_port(ds, port)->slave);\n\n\t \n\tdo {\n\t\trc = sja1105_dynamic_config_read(priv, BLK_IDX_MGMT_ROUTE,\n\t\t\t\t\t\t slot, &mgmt_route);\n\t\tif (rc < 0) {\n\t\t\tdev_err_ratelimited(priv->ds->dev,\n\t\t\t\t\t    \"failed to poll for mgmt route\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tcpu_relax();\n\t} while (mgmt_route.enfport && --timeout);\n\n\tif (!timeout) {\n\t\t \n\t\tsja1105_dynamic_config_write(priv, BLK_IDX_MGMT_ROUTE,\n\t\t\t\t\t     slot, &mgmt_route, false);\n\t\tdev_err_ratelimited(priv->ds->dev, \"xmit timed out\\n\");\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\n#define work_to_xmit_work(w) \\\n\t\tcontainer_of((w), struct sja1105_deferred_xmit_work, work)\n\n \nstatic void sja1105_port_deferred_xmit(struct kthread_work *work)\n{\n\tstruct sja1105_deferred_xmit_work *xmit_work = work_to_xmit_work(work);\n\tstruct sk_buff *clone, *skb = xmit_work->skb;\n\tstruct dsa_switch *ds = xmit_work->dp->ds;\n\tstruct sja1105_private *priv = ds->priv;\n\tint port = xmit_work->dp->index;\n\n\tclone = SJA1105_SKB_CB(skb)->clone;\n\n\tmutex_lock(&priv->mgmt_lock);\n\n\tsja1105_mgmt_xmit(ds, port, 0, skb, !!clone);\n\n\t \n\tif (clone)\n\t\tsja1105_ptp_txtstamp_skb(ds, port, clone);\n\n\tmutex_unlock(&priv->mgmt_lock);\n\n\tkfree(xmit_work);\n}\n\nstatic int sja1105_connect_tag_protocol(struct dsa_switch *ds,\n\t\t\t\t\tenum dsa_tag_protocol proto)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct sja1105_tagger_data *tagger_data;\n\n\tif (proto != priv->info->tag_proto)\n\t\treturn -EPROTONOSUPPORT;\n\n\ttagger_data = sja1105_tagger_data(ds);\n\ttagger_data->xmit_work_fn = sja1105_port_deferred_xmit;\n\ttagger_data->meta_tstamp_handler = sja1110_process_meta_tstamp;\n\n\treturn 0;\n}\n\n \nstatic int sja1105_set_ageing_time(struct dsa_switch *ds,\n\t\t\t\t   unsigned int ageing_time)\n{\n\tstruct sja1105_l2_lookup_params_entry *l2_lookup_params;\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct sja1105_table *table;\n\tunsigned int maxage;\n\n\ttable = &priv->static_config.tables[BLK_IDX_L2_LOOKUP_PARAMS];\n\tl2_lookup_params = table->entries;\n\n\tmaxage = SJA1105_AGEING_TIME_MS(ageing_time);\n\n\tif (l2_lookup_params->maxage == maxage)\n\t\treturn 0;\n\n\tl2_lookup_params->maxage = maxage;\n\n\treturn sja1105_static_config_reload(priv, SJA1105_AGEING_TIME);\n}\n\nstatic int sja1105_change_mtu(struct dsa_switch *ds, int port, int new_mtu)\n{\n\tstruct sja1105_l2_policing_entry *policing;\n\tstruct sja1105_private *priv = ds->priv;\n\n\tnew_mtu += VLAN_ETH_HLEN + ETH_FCS_LEN;\n\n\tif (dsa_is_cpu_port(ds, port) || dsa_is_dsa_port(ds, port))\n\t\tnew_mtu += VLAN_HLEN;\n\n\tpolicing = priv->static_config.tables[BLK_IDX_L2_POLICING].entries;\n\n\tif (policing[port].maxlen == new_mtu)\n\t\treturn 0;\n\n\tpolicing[port].maxlen = new_mtu;\n\n\treturn sja1105_static_config_reload(priv, SJA1105_BEST_EFFORT_POLICING);\n}\n\nstatic int sja1105_get_max_mtu(struct dsa_switch *ds, int port)\n{\n\treturn 2043 - VLAN_ETH_HLEN - ETH_FCS_LEN;\n}\n\nstatic int sja1105_port_setup_tc(struct dsa_switch *ds, int port,\n\t\t\t\t enum tc_setup_type type,\n\t\t\t\t void *type_data)\n{\n\tswitch (type) {\n\tcase TC_SETUP_QDISC_TAPRIO:\n\t\treturn sja1105_setup_tc_taprio(ds, port, type_data);\n\tcase TC_SETUP_QDISC_CBS:\n\t\treturn sja1105_setup_tc_cbs(ds, port, type_data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n \nstatic int sja1105_mirror_apply(struct sja1105_private *priv, int from, int to,\n\t\t\t\tbool ingress, bool enabled)\n{\n\tstruct sja1105_general_params_entry *general_params;\n\tstruct sja1105_mac_config_entry *mac;\n\tstruct dsa_switch *ds = priv->ds;\n\tstruct sja1105_table *table;\n\tbool already_enabled;\n\tu64 new_mirr_port;\n\tint rc;\n\n\ttable = &priv->static_config.tables[BLK_IDX_GENERAL_PARAMS];\n\tgeneral_params = table->entries;\n\n\tmac = priv->static_config.tables[BLK_IDX_MAC_CONFIG].entries;\n\n\talready_enabled = (general_params->mirr_port != ds->num_ports);\n\tif (already_enabled && enabled && general_params->mirr_port != to) {\n\t\tdev_err(priv->ds->dev,\n\t\t\t\"Delete mirroring rules towards port %llu first\\n\",\n\t\t\tgeneral_params->mirr_port);\n\t\treturn -EBUSY;\n\t}\n\n\tnew_mirr_port = to;\n\tif (!enabled) {\n\t\tbool keep = false;\n\t\tint port;\n\n\t\t \n\t\tfor (port = 0; port < ds->num_ports; port++) {\n\t\t\tif (mac[port].ing_mirr || mac[port].egr_mirr) {\n\t\t\t\tkeep = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (!keep)\n\t\t\tnew_mirr_port = ds->num_ports;\n\t}\n\tif (new_mirr_port != general_params->mirr_port) {\n\t\tgeneral_params->mirr_port = new_mirr_port;\n\n\t\trc = sja1105_dynamic_config_write(priv, BLK_IDX_GENERAL_PARAMS,\n\t\t\t\t\t\t  0, general_params, true);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\n\tif (ingress)\n\t\tmac[from].ing_mirr = enabled;\n\telse\n\t\tmac[from].egr_mirr = enabled;\n\n\treturn sja1105_dynamic_config_write(priv, BLK_IDX_MAC_CONFIG, from,\n\t\t\t\t\t    &mac[from], true);\n}\n\nstatic int sja1105_mirror_add(struct dsa_switch *ds, int port,\n\t\t\t      struct dsa_mall_mirror_tc_entry *mirror,\n\t\t\t      bool ingress, struct netlink_ext_ack *extack)\n{\n\treturn sja1105_mirror_apply(ds->priv, port, mirror->to_local_port,\n\t\t\t\t    ingress, true);\n}\n\nstatic void sja1105_mirror_del(struct dsa_switch *ds, int port,\n\t\t\t       struct dsa_mall_mirror_tc_entry *mirror)\n{\n\tsja1105_mirror_apply(ds->priv, port, mirror->to_local_port,\n\t\t\t     mirror->ingress, false);\n}\n\nstatic int sja1105_port_policer_add(struct dsa_switch *ds, int port,\n\t\t\t\t    struct dsa_mall_policer_tc_entry *policer)\n{\n\tstruct sja1105_l2_policing_entry *policing;\n\tstruct sja1105_private *priv = ds->priv;\n\n\tpolicing = priv->static_config.tables[BLK_IDX_L2_POLICING].entries;\n\n\t \n\tpolicing[port].rate = div_u64(512 * policer->rate_bytes_per_sec,\n\t\t\t\t      1000000);\n\tpolicing[port].smax = policer->burst;\n\n\treturn sja1105_static_config_reload(priv, SJA1105_BEST_EFFORT_POLICING);\n}\n\nstatic void sja1105_port_policer_del(struct dsa_switch *ds, int port)\n{\n\tstruct sja1105_l2_policing_entry *policing;\n\tstruct sja1105_private *priv = ds->priv;\n\n\tpolicing = priv->static_config.tables[BLK_IDX_L2_POLICING].entries;\n\n\tpolicing[port].rate = SJA1105_RATE_MBPS(1000);\n\tpolicing[port].smax = 65535;\n\n\tsja1105_static_config_reload(priv, SJA1105_BEST_EFFORT_POLICING);\n}\n\nstatic int sja1105_port_set_learning(struct sja1105_private *priv, int port,\n\t\t\t\t     bool enabled)\n{\n\tstruct sja1105_mac_config_entry *mac;\n\n\tmac = priv->static_config.tables[BLK_IDX_MAC_CONFIG].entries;\n\n\tmac[port].dyn_learn = enabled;\n\n\treturn sja1105_dynamic_config_write(priv, BLK_IDX_MAC_CONFIG, port,\n\t\t\t\t\t    &mac[port], true);\n}\n\nstatic int sja1105_port_ucast_bcast_flood(struct sja1105_private *priv, int to,\n\t\t\t\t\t  struct switchdev_brport_flags flags)\n{\n\tif (flags.mask & BR_FLOOD) {\n\t\tif (flags.val & BR_FLOOD)\n\t\t\tpriv->ucast_egress_floods |= BIT(to);\n\t\telse\n\t\t\tpriv->ucast_egress_floods &= ~BIT(to);\n\t}\n\n\tif (flags.mask & BR_BCAST_FLOOD) {\n\t\tif (flags.val & BR_BCAST_FLOOD)\n\t\t\tpriv->bcast_egress_floods |= BIT(to);\n\t\telse\n\t\t\tpriv->bcast_egress_floods &= ~BIT(to);\n\t}\n\n\treturn sja1105_manage_flood_domains(priv);\n}\n\nstatic int sja1105_port_mcast_flood(struct sja1105_private *priv, int to,\n\t\t\t\t    struct switchdev_brport_flags flags,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct sja1105_l2_lookup_entry *l2_lookup;\n\tstruct sja1105_table *table;\n\tint match, rc;\n\n\tmutex_lock(&priv->fdb_lock);\n\n\ttable = &priv->static_config.tables[BLK_IDX_L2_LOOKUP];\n\tl2_lookup = table->entries;\n\n\tfor (match = 0; match < table->entry_count; match++)\n\t\tif (l2_lookup[match].macaddr == SJA1105_UNKNOWN_MULTICAST &&\n\t\t    l2_lookup[match].mask_macaddr == SJA1105_UNKNOWN_MULTICAST)\n\t\t\tbreak;\n\n\tif (match == table->entry_count) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Could not find FDB entry for unknown multicast\");\n\t\trc = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tif (flags.val & BR_MCAST_FLOOD)\n\t\tl2_lookup[match].destports |= BIT(to);\n\telse\n\t\tl2_lookup[match].destports &= ~BIT(to);\n\n\trc = sja1105_dynamic_config_write(priv, BLK_IDX_L2_LOOKUP,\n\t\t\t\t\t  l2_lookup[match].index,\n\t\t\t\t\t  &l2_lookup[match], true);\nout:\n\tmutex_unlock(&priv->fdb_lock);\n\n\treturn rc;\n}\n\nstatic int sja1105_port_pre_bridge_flags(struct dsa_switch *ds, int port,\n\t\t\t\t\t struct switchdev_brport_flags flags,\n\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\n\tif (flags.mask & ~(BR_LEARNING | BR_FLOOD | BR_MCAST_FLOOD |\n\t\t\t   BR_BCAST_FLOOD))\n\t\treturn -EINVAL;\n\n\tif (flags.mask & (BR_FLOOD | BR_MCAST_FLOOD) &&\n\t    !priv->info->can_limit_mcast_flood) {\n\t\tbool multicast = !!(flags.val & BR_MCAST_FLOOD);\n\t\tbool unicast = !!(flags.val & BR_FLOOD);\n\n\t\tif (unicast != multicast) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"This chip cannot configure multicast flooding independently of unicast\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sja1105_port_bridge_flags(struct dsa_switch *ds, int port,\n\t\t\t\t     struct switchdev_brport_flags flags,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tint rc;\n\n\tif (flags.mask & BR_LEARNING) {\n\t\tbool learn_ena = !!(flags.val & BR_LEARNING);\n\n\t\trc = sja1105_port_set_learning(priv, port, learn_ena);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (flags.mask & (BR_FLOOD | BR_BCAST_FLOOD)) {\n\t\trc = sja1105_port_ucast_bcast_flood(priv, port, flags);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\t \n\tif (flags.mask & BR_MCAST_FLOOD && priv->info->can_limit_mcast_flood) {\n\t\trc = sja1105_port_mcast_flood(priv, port, flags,\n\t\t\t\t\t      extack);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sja1105_setup(struct dsa_switch *ds)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tint rc;\n\n\tif (priv->info->disable_microcontroller) {\n\t\trc = priv->info->disable_microcontroller(priv);\n\t\tif (rc < 0) {\n\t\t\tdev_err(ds->dev,\n\t\t\t\t\"Failed to disable microcontroller: %pe\\n\",\n\t\t\t\tERR_PTR(rc));\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t \n\trc = sja1105_static_config_load(priv);\n\tif (rc < 0) {\n\t\tdev_err(ds->dev, \"Failed to load static config: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t \n\tif (priv->info->clocking_setup) {\n\t\trc = priv->info->clocking_setup(priv);\n\t\tif (rc < 0) {\n\t\t\tdev_err(ds->dev,\n\t\t\t\t\"Failed to configure MII clocking: %pe\\n\",\n\t\t\t\tERR_PTR(rc));\n\t\t\tgoto out_static_config_free;\n\t\t}\n\t}\n\n\tsja1105_tas_setup(ds);\n\tsja1105_flower_setup(ds);\n\n\trc = sja1105_ptp_clock_register(ds);\n\tif (rc < 0) {\n\t\tdev_err(ds->dev, \"Failed to register PTP clock: %d\\n\", rc);\n\t\tgoto out_flower_teardown;\n\t}\n\n\trc = sja1105_mdiobus_register(ds);\n\tif (rc < 0) {\n\t\tdev_err(ds->dev, \"Failed to register MDIO bus: %pe\\n\",\n\t\t\tERR_PTR(rc));\n\t\tgoto out_ptp_clock_unregister;\n\t}\n\n\trc = sja1105_devlink_setup(ds);\n\tif (rc < 0)\n\t\tgoto out_mdiobus_unregister;\n\n\trtnl_lock();\n\trc = dsa_tag_8021q_register(ds, htons(ETH_P_8021Q));\n\trtnl_unlock();\n\tif (rc)\n\t\tgoto out_devlink_teardown;\n\n\t \n\tds->vlan_filtering_is_global = true;\n\tds->untag_bridge_pvid = true;\n\tds->fdb_isolation = true;\n\t \n\tds->max_num_bridges = 7;\n\n\t \n\tds->num_tx_queues = SJA1105_NUM_TC;\n\n\tds->mtu_enforcement_ingress = true;\n\tds->assisted_learning_on_cpu_port = true;\n\n\treturn 0;\n\nout_devlink_teardown:\n\tsja1105_devlink_teardown(ds);\nout_mdiobus_unregister:\n\tsja1105_mdiobus_unregister(ds);\nout_ptp_clock_unregister:\n\tsja1105_ptp_clock_unregister(ds);\nout_flower_teardown:\n\tsja1105_flower_teardown(ds);\n\tsja1105_tas_teardown(ds);\nout_static_config_free:\n\tsja1105_static_config_free(&priv->static_config);\n\n\treturn rc;\n}\n\nstatic void sja1105_teardown(struct dsa_switch *ds)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\n\trtnl_lock();\n\tdsa_tag_8021q_unregister(ds);\n\trtnl_unlock();\n\n\tsja1105_devlink_teardown(ds);\n\tsja1105_mdiobus_unregister(ds);\n\tsja1105_ptp_clock_unregister(ds);\n\tsja1105_flower_teardown(ds);\n\tsja1105_tas_teardown(ds);\n\tsja1105_static_config_free(&priv->static_config);\n}\n\nstatic const struct dsa_switch_ops sja1105_switch_ops = {\n\t.get_tag_protocol\t= sja1105_get_tag_protocol,\n\t.connect_tag_protocol\t= sja1105_connect_tag_protocol,\n\t.setup\t\t\t= sja1105_setup,\n\t.teardown\t\t= sja1105_teardown,\n\t.set_ageing_time\t= sja1105_set_ageing_time,\n\t.port_change_mtu\t= sja1105_change_mtu,\n\t.port_max_mtu\t\t= sja1105_get_max_mtu,\n\t.phylink_get_caps\t= sja1105_phylink_get_caps,\n\t.phylink_mac_select_pcs\t= sja1105_mac_select_pcs,\n\t.phylink_mac_link_up\t= sja1105_mac_link_up,\n\t.phylink_mac_link_down\t= sja1105_mac_link_down,\n\t.get_strings\t\t= sja1105_get_strings,\n\t.get_ethtool_stats\t= sja1105_get_ethtool_stats,\n\t.get_sset_count\t\t= sja1105_get_sset_count,\n\t.get_ts_info\t\t= sja1105_get_ts_info,\n\t.port_fdb_dump\t\t= sja1105_fdb_dump,\n\t.port_fdb_add\t\t= sja1105_fdb_add,\n\t.port_fdb_del\t\t= sja1105_fdb_del,\n\t.port_fast_age\t\t= sja1105_fast_age,\n\t.port_bridge_join\t= sja1105_bridge_join,\n\t.port_bridge_leave\t= sja1105_bridge_leave,\n\t.port_pre_bridge_flags\t= sja1105_port_pre_bridge_flags,\n\t.port_bridge_flags\t= sja1105_port_bridge_flags,\n\t.port_stp_state_set\t= sja1105_bridge_stp_state_set,\n\t.port_vlan_filtering\t= sja1105_vlan_filtering,\n\t.port_vlan_add\t\t= sja1105_bridge_vlan_add,\n\t.port_vlan_del\t\t= sja1105_bridge_vlan_del,\n\t.port_mdb_add\t\t= sja1105_mdb_add,\n\t.port_mdb_del\t\t= sja1105_mdb_del,\n\t.port_hwtstamp_get\t= sja1105_hwtstamp_get,\n\t.port_hwtstamp_set\t= sja1105_hwtstamp_set,\n\t.port_rxtstamp\t\t= sja1105_port_rxtstamp,\n\t.port_txtstamp\t\t= sja1105_port_txtstamp,\n\t.port_setup_tc\t\t= sja1105_port_setup_tc,\n\t.port_mirror_add\t= sja1105_mirror_add,\n\t.port_mirror_del\t= sja1105_mirror_del,\n\t.port_policer_add\t= sja1105_port_policer_add,\n\t.port_policer_del\t= sja1105_port_policer_del,\n\t.cls_flower_add\t\t= sja1105_cls_flower_add,\n\t.cls_flower_del\t\t= sja1105_cls_flower_del,\n\t.cls_flower_stats\t= sja1105_cls_flower_stats,\n\t.devlink_info_get\t= sja1105_devlink_info_get,\n\t.tag_8021q_vlan_add\t= sja1105_dsa_8021q_vlan_add,\n\t.tag_8021q_vlan_del\t= sja1105_dsa_8021q_vlan_del,\n\t.port_prechangeupper\t= sja1105_prechangeupper,\n};\n\nstatic const struct of_device_id sja1105_dt_ids[];\n\nstatic int sja1105_check_device_id(struct sja1105_private *priv)\n{\n\tconst struct sja1105_regs *regs = priv->info->regs;\n\tu8 prod_id[SJA1105_SIZE_DEVICE_ID] = {0};\n\tstruct device *dev = &priv->spidev->dev;\n\tconst struct of_device_id *match;\n\tu32 device_id;\n\tu64 part_no;\n\tint rc;\n\n\trc = sja1105_xfer_u32(priv, SPI_READ, regs->device_id, &device_id,\n\t\t\t      NULL);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = sja1105_xfer_buf(priv, SPI_READ, regs->prod_id, prod_id,\n\t\t\t      SJA1105_SIZE_DEVICE_ID);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tsja1105_unpack(prod_id, &part_no, 19, 4, SJA1105_SIZE_DEVICE_ID);\n\n\tfor (match = sja1105_dt_ids; match->compatible[0]; match++) {\n\t\tconst struct sja1105_info *info = match->data;\n\n\t\t \n\t\tif (info->device_id != device_id || info->part_no != part_no)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (priv->info->device_id != device_id ||\n\t\t    priv->info->part_no != part_no) {\n\t\t\tdev_warn(dev, \"Device tree specifies chip %s but found %s, please fix it!\\n\",\n\t\t\t\t priv->info->name, info->name);\n\t\t\t \n\t\t\tpriv->info = info;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tdev_err(dev, \"Unexpected {device ID, part number}: 0x%x 0x%llx\\n\",\n\t\tdevice_id, part_no);\n\n\treturn -ENODEV;\n}\n\nstatic int sja1105_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct sja1105_private *priv;\n\tsize_t max_xfer, max_msg;\n\tstruct dsa_switch *ds;\n\tint rc;\n\n\tif (!dev->of_node) {\n\t\tdev_err(dev, \"No DTS bindings for SJA1105 driver\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = sja1105_hw_reset(dev, 1, 1);\n\tif (rc)\n\t\treturn rc;\n\n\tpriv = devm_kzalloc(dev, sizeof(struct sja1105_private), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t \n\tpriv->spidev = spi;\n\tspi_set_drvdata(spi, priv);\n\n\t \n\tspi->bits_per_word = 8;\n\trc = spi_setup(spi);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"Could not init SPI\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\tmax_xfer = spi_max_transfer_size(spi);\n\tmax_msg = spi_max_message_size(spi);\n\n\t \n\tif (max_msg < SJA1105_SIZE_SPI_MSG_HEADER + 8) {\n\t\tdev_err(dev, \"SPI master cannot send large enough buffers, aborting\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->max_xfer_len = SJA1105_SIZE_SPI_MSG_MAXLEN;\n\tif (priv->max_xfer_len > max_xfer)\n\t\tpriv->max_xfer_len = max_xfer;\n\tif (priv->max_xfer_len > max_msg - SJA1105_SIZE_SPI_MSG_HEADER)\n\t\tpriv->max_xfer_len = max_msg - SJA1105_SIZE_SPI_MSG_HEADER;\n\n\tpriv->info = of_device_get_match_data(dev);\n\n\t \n\trc = sja1105_check_device_id(priv);\n\tif (rc < 0) {\n\t\tdev_err(dev, \"Device ID check failed: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tdev_info(dev, \"Probed switch chip: %s\\n\", priv->info->name);\n\n\tds = devm_kzalloc(dev, sizeof(*ds), GFP_KERNEL);\n\tif (!ds)\n\t\treturn -ENOMEM;\n\n\tds->dev = dev;\n\tds->num_ports = priv->info->num_ports;\n\tds->ops = &sja1105_switch_ops;\n\tds->priv = priv;\n\tpriv->ds = ds;\n\n\tmutex_init(&priv->ptp_data.lock);\n\tmutex_init(&priv->dynamic_config_lock);\n\tmutex_init(&priv->mgmt_lock);\n\tmutex_init(&priv->fdb_lock);\n\tspin_lock_init(&priv->ts_id_lock);\n\n\trc = sja1105_parse_dt(priv);\n\tif (rc < 0) {\n\t\tdev_err(ds->dev, \"Failed to parse DT: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (IS_ENABLED(CONFIG_NET_SCH_CBS)) {\n\t\tpriv->cbs = devm_kcalloc(dev, priv->info->num_cbs_shapers,\n\t\t\t\t\t sizeof(struct sja1105_cbs_entry),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!priv->cbs)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn dsa_register_switch(priv->ds);\n}\n\nstatic void sja1105_remove(struct spi_device *spi)\n{\n\tstruct sja1105_private *priv = spi_get_drvdata(spi);\n\n\tif (!priv)\n\t\treturn;\n\n\tdsa_unregister_switch(priv->ds);\n}\n\nstatic void sja1105_shutdown(struct spi_device *spi)\n{\n\tstruct sja1105_private *priv = spi_get_drvdata(spi);\n\n\tif (!priv)\n\t\treturn;\n\n\tdsa_switch_shutdown(priv->ds);\n\n\tspi_set_drvdata(spi, NULL);\n}\n\nstatic const struct of_device_id sja1105_dt_ids[] = {\n\t{ .compatible = \"nxp,sja1105e\", .data = &sja1105e_info },\n\t{ .compatible = \"nxp,sja1105t\", .data = &sja1105t_info },\n\t{ .compatible = \"nxp,sja1105p\", .data = &sja1105p_info },\n\t{ .compatible = \"nxp,sja1105q\", .data = &sja1105q_info },\n\t{ .compatible = \"nxp,sja1105r\", .data = &sja1105r_info },\n\t{ .compatible = \"nxp,sja1105s\", .data = &sja1105s_info },\n\t{ .compatible = \"nxp,sja1110a\", .data = &sja1110a_info },\n\t{ .compatible = \"nxp,sja1110b\", .data = &sja1110b_info },\n\t{ .compatible = \"nxp,sja1110c\", .data = &sja1110c_info },\n\t{ .compatible = \"nxp,sja1110d\", .data = &sja1110d_info },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, sja1105_dt_ids);\n\nstatic const struct spi_device_id sja1105_spi_ids[] = {\n\t{ \"sja1105e\" },\n\t{ \"sja1105t\" },\n\t{ \"sja1105p\" },\n\t{ \"sja1105q\" },\n\t{ \"sja1105r\" },\n\t{ \"sja1105s\" },\n\t{ \"sja1110a\" },\n\t{ \"sja1110b\" },\n\t{ \"sja1110c\" },\n\t{ \"sja1110d\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(spi, sja1105_spi_ids);\n\nstatic struct spi_driver sja1105_driver = {\n\t.driver = {\n\t\t.name  = \"sja1105\",\n\t\t.owner = THIS_MODULE,\n\t\t.of_match_table = of_match_ptr(sja1105_dt_ids),\n\t},\n\t.id_table = sja1105_spi_ids,\n\t.probe  = sja1105_probe,\n\t.remove = sja1105_remove,\n\t.shutdown = sja1105_shutdown,\n};\n\nmodule_spi_driver(sja1105_driver);\n\nMODULE_AUTHOR(\"Vladimir Oltean <olteanv@gmail.com>\");\nMODULE_AUTHOR(\"Georg Waibel <georg.waibel@sensor-technik.de>\");\nMODULE_DESCRIPTION(\"SJA1105 Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}