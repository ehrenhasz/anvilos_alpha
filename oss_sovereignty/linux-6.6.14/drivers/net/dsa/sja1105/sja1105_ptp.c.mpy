{
  "module_name": "sja1105_ptp.c",
  "hash_id": "722376ae73baef7cc2d687f79362ccde894a734985b8f5d16e19ed93b9941cee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/sja1105/sja1105_ptp.c",
  "human_readable_source": "\n \n#include <linux/spi/spi.h>\n#include \"sja1105.h\"\n\n \n#define SJA1105_MAX_ADJ_PPB\t\t32000000\n#define SJA1105_SIZE_PTP_CMD\t\t4\n\n \n#define SJA1105_EXTTS_INTERVAL\t\t(HZ / 6)\n\n \n#define SJA1105_CC_MULT_NUM\t\t(1 << 9)\n#define SJA1105_CC_MULT_DEM\t\t15625\n#define SJA1105_CC_MULT\t\t\t0x80000000\n\nenum sja1105_ptp_clk_mode {\n\tPTP_ADD_MODE = 1,\n\tPTP_SET_MODE = 0,\n};\n\n#define extts_to_data(t) \\\n\t\tcontainer_of((t), struct sja1105_ptp_data, extts_timer)\n#define ptp_caps_to_data(d) \\\n\t\tcontainer_of((d), struct sja1105_ptp_data, caps)\n#define ptp_data_to_sja1105(d) \\\n\t\tcontainer_of((d), struct sja1105_private, ptp_data)\n\nint sja1105_hwtstamp_set(struct dsa_switch *ds, int port, struct ifreq *ifr)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct hwtstamp_config config;\n\n\tif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\n\t\treturn -EFAULT;\n\n\tswitch (config.tx_type) {\n\tcase HWTSTAMP_TX_OFF:\n\t\tpriv->hwts_tx_en &= ~BIT(port);\n\t\tbreak;\n\tcase HWTSTAMP_TX_ON:\n\t\tpriv->hwts_tx_en |= BIT(port);\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tswitch (config.rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tpriv->hwts_rx_en &= ~BIT(port);\n\t\tbreak;\n\tdefault:\n\t\tpriv->hwts_rx_en |= BIT(port);\n\t\tbreak;\n\t}\n\n\tif (copy_to_user(ifr->ifr_data, &config, sizeof(config)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nint sja1105_hwtstamp_get(struct dsa_switch *ds, int port, struct ifreq *ifr)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct hwtstamp_config config;\n\n\tconfig.flags = 0;\n\tif (priv->hwts_tx_en & BIT(port))\n\t\tconfig.tx_type = HWTSTAMP_TX_ON;\n\telse\n\t\tconfig.tx_type = HWTSTAMP_TX_OFF;\n\tif (priv->hwts_rx_en & BIT(port))\n\t\tconfig.rx_filter = HWTSTAMP_FILTER_PTP_V2_L2_EVENT;\n\telse\n\t\tconfig.rx_filter = HWTSTAMP_FILTER_NONE;\n\n\treturn copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?\n\t\t-EFAULT : 0;\n}\n\nint sja1105_get_ts_info(struct dsa_switch *ds, int port,\n\t\t\tstruct ethtool_ts_info *info)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct sja1105_ptp_data *ptp_data = &priv->ptp_data;\n\n\t \n\tif (!ptp_data->clock)\n\t\treturn -ENODEV;\n\n\tinfo->so_timestamping = SOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\tinfo->tx_types = (1 << HWTSTAMP_TX_OFF) |\n\t\t\t (1 << HWTSTAMP_TX_ON);\n\tinfo->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |\n\t\t\t   (1 << HWTSTAMP_FILTER_PTP_V2_L2_EVENT);\n\tinfo->phc_index = ptp_clock_index(ptp_data->clock);\n\treturn 0;\n}\n\nvoid sja1105et_ptp_cmd_packing(u8 *buf, struct sja1105_ptp_cmd *cmd,\n\t\t\t       enum packing_op op)\n{\n\tconst int size = SJA1105_SIZE_PTP_CMD;\n\t \n\tu64 valid = 1;\n\n\tsja1105_packing(buf, &valid,           31, 31, size, op);\n\tsja1105_packing(buf, &cmd->ptpstrtsch, 30, 30, size, op);\n\tsja1105_packing(buf, &cmd->ptpstopsch, 29, 29, size, op);\n\tsja1105_packing(buf, &cmd->startptpcp, 28, 28, size, op);\n\tsja1105_packing(buf, &cmd->stopptpcp,  27, 27, size, op);\n\tsja1105_packing(buf, &cmd->resptp,      2,  2, size, op);\n\tsja1105_packing(buf, &cmd->corrclk4ts,  1,  1, size, op);\n\tsja1105_packing(buf, &cmd->ptpclkadd,   0,  0, size, op);\n}\n\nvoid sja1105pqrs_ptp_cmd_packing(u8 *buf, struct sja1105_ptp_cmd *cmd,\n\t\t\t\t enum packing_op op)\n{\n\tconst int size = SJA1105_SIZE_PTP_CMD;\n\t \n\tu64 valid = 1;\n\n\tsja1105_packing(buf, &valid,           31, 31, size, op);\n\tsja1105_packing(buf, &cmd->ptpstrtsch, 30, 30, size, op);\n\tsja1105_packing(buf, &cmd->ptpstopsch, 29, 29, size, op);\n\tsja1105_packing(buf, &cmd->startptpcp, 28, 28, size, op);\n\tsja1105_packing(buf, &cmd->stopptpcp,  27, 27, size, op);\n\tsja1105_packing(buf, &cmd->resptp,      3,  3, size, op);\n\tsja1105_packing(buf, &cmd->corrclk4ts,  2,  2, size, op);\n\tsja1105_packing(buf, &cmd->ptpclkadd,   0,  0, size, op);\n}\n\nint sja1105_ptp_commit(struct dsa_switch *ds, struct sja1105_ptp_cmd *cmd,\n\t\t       sja1105_spi_rw_mode_t rw)\n{\n\tconst struct sja1105_private *priv = ds->priv;\n\tconst struct sja1105_regs *regs = priv->info->regs;\n\tu8 buf[SJA1105_SIZE_PTP_CMD] = {0};\n\tint rc;\n\n\tif (rw == SPI_WRITE)\n\t\tpriv->info->ptp_cmd_packing(buf, cmd, PACK);\n\n\trc = sja1105_xfer_buf(priv, rw, regs->ptp_control, buf,\n\t\t\t      SJA1105_SIZE_PTP_CMD);\n\n\tif (rw == SPI_READ)\n\t\tpriv->info->ptp_cmd_packing(buf, cmd, UNPACK);\n\n\treturn rc;\n}\n\n \nstatic u64 sja1105_tstamp_reconstruct(struct dsa_switch *ds, u64 now,\n\t\t\t\t      u64 ts_partial)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tu64 partial_tstamp_mask = CYCLECOUNTER_MASK(priv->info->ptp_ts_bits);\n\tu64 ts_reconstructed;\n\n\tts_reconstructed = (now & ~partial_tstamp_mask) | ts_partial;\n\n\t \n\tif ((now & partial_tstamp_mask) <= ts_partial)\n\t\tts_reconstructed -= (partial_tstamp_mask + 1);\n\n\treturn ts_reconstructed;\n}\n\n \nstatic int sja1105_ptpegr_ts_poll(struct dsa_switch *ds, int port, u64 *ts)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tconst struct sja1105_regs *regs = priv->info->regs;\n\tint tstamp_bit_start, tstamp_bit_end;\n\tint timeout = 10;\n\tu8 packed_buf[8];\n\tu64 update;\n\tint rc;\n\n\tdo {\n\t\trc = sja1105_xfer_buf(priv, SPI_READ, regs->ptpegr_ts[port],\n\t\t\t\t      packed_buf, priv->info->ptpegr_ts_bytes);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\tsja1105_unpack(packed_buf, &update, 0, 0,\n\t\t\t       priv->info->ptpegr_ts_bytes);\n\t\tif (update)\n\t\t\tbreak;\n\n\t\tusleep_range(10, 50);\n\t} while (--timeout);\n\n\tif (!timeout)\n\t\treturn -ETIMEDOUT;\n\n\t \n\ttstamp_bit_end = (priv->info->ptpegr_ts_bytes - 4) * 8;\n\t \n\ttstamp_bit_end += 32 - priv->info->ptp_ts_bits;\n\ttstamp_bit_start = tstamp_bit_end + priv->info->ptp_ts_bits - 1;\n\n\t*ts = 0;\n\n\tsja1105_unpack(packed_buf, ts, tstamp_bit_start, tstamp_bit_end,\n\t\t       priv->info->ptpegr_ts_bytes);\n\n\treturn 0;\n}\n\n \nstatic int sja1105_ptpclkval_read(struct sja1105_private *priv, u64 *ticks,\n\t\t\t\t  struct ptp_system_timestamp *ptp_sts)\n{\n\tconst struct sja1105_regs *regs = priv->info->regs;\n\n\treturn sja1105_xfer_u64(priv, SPI_READ, regs->ptpclkval, ticks,\n\t\t\t\tptp_sts);\n}\n\n \nstatic int sja1105_ptpclkval_write(struct sja1105_private *priv, u64 ticks,\n\t\t\t\t   struct ptp_system_timestamp *ptp_sts)\n{\n\tconst struct sja1105_regs *regs = priv->info->regs;\n\n\treturn sja1105_xfer_u64(priv, SPI_WRITE, regs->ptpclkval, &ticks,\n\t\t\t\tptp_sts);\n}\n\nstatic void sja1105_extts_poll(struct sja1105_private *priv)\n{\n\tstruct sja1105_ptp_data *ptp_data = &priv->ptp_data;\n\tconst struct sja1105_regs *regs = priv->info->regs;\n\tstruct ptp_clock_event event;\n\tu64 ptpsyncts = 0;\n\tint rc;\n\n\trc = sja1105_xfer_u64(priv, SPI_READ, regs->ptpsyncts, &ptpsyncts,\n\t\t\t      NULL);\n\tif (rc < 0)\n\t\tdev_err_ratelimited(priv->ds->dev,\n\t\t\t\t    \"Failed to read PTPSYNCTS: %d\\n\", rc);\n\n\tif (ptpsyncts && ptp_data->ptpsyncts != ptpsyncts) {\n\t\tevent.index = 0;\n\t\tevent.type = PTP_CLOCK_EXTTS;\n\t\tevent.timestamp = ns_to_ktime(sja1105_ticks_to_ns(ptpsyncts));\n\t\tptp_clock_event(ptp_data->clock, &event);\n\n\t\tptp_data->ptpsyncts = ptpsyncts;\n\t}\n}\n\nstatic long sja1105_rxtstamp_work(struct ptp_clock_info *ptp)\n{\n\tstruct sja1105_ptp_data *ptp_data = ptp_caps_to_data(ptp);\n\tstruct sja1105_private *priv = ptp_data_to_sja1105(ptp_data);\n\tstruct dsa_switch *ds = priv->ds;\n\tstruct sk_buff *skb;\n\n\tmutex_lock(&ptp_data->lock);\n\n\twhile ((skb = skb_dequeue(&ptp_data->skb_rxtstamp_queue)) != NULL) {\n\t\tstruct skb_shared_hwtstamps *shwt = skb_hwtstamps(skb);\n\t\tu64 ticks, ts;\n\t\tint rc;\n\n\t\trc = sja1105_ptpclkval_read(priv, &ticks, NULL);\n\t\tif (rc < 0) {\n\t\t\tdev_err(ds->dev, \"Failed to read PTP clock: %d\\n\", rc);\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\t*shwt = (struct skb_shared_hwtstamps) {0};\n\n\t\tts = SJA1105_SKB_CB(skb)->tstamp;\n\t\tts = sja1105_tstamp_reconstruct(ds, ticks, ts);\n\n\t\tshwt->hwtstamp = ns_to_ktime(sja1105_ticks_to_ns(ts));\n\t\tnetif_rx(skb);\n\t}\n\n\tif (ptp_data->extts_enabled)\n\t\tsja1105_extts_poll(priv);\n\n\tmutex_unlock(&ptp_data->lock);\n\n\t \n\treturn -1;\n}\n\nbool sja1105_rxtstamp(struct dsa_switch *ds, int port, struct sk_buff *skb)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct sja1105_ptp_data *ptp_data = &priv->ptp_data;\n\n\tif (!(priv->hwts_rx_en & BIT(port)))\n\t\treturn false;\n\n\t \n\tskb_queue_tail(&ptp_data->skb_rxtstamp_queue, skb);\n\tptp_schedule_worker(ptp_data->clock, 0);\n\treturn true;\n}\n\nbool sja1110_rxtstamp(struct dsa_switch *ds, int port, struct sk_buff *skb)\n{\n\tstruct skb_shared_hwtstamps *shwt = skb_hwtstamps(skb);\n\tu64 ts = SJA1105_SKB_CB(skb)->tstamp;\n\n\t*shwt = (struct skb_shared_hwtstamps) {0};\n\n\tshwt->hwtstamp = ns_to_ktime(sja1105_ticks_to_ns(ts));\n\n\t \n\treturn false;\n}\n\n \nbool sja1105_port_rxtstamp(struct dsa_switch *ds, int port,\n\t\t\t   struct sk_buff *skb, unsigned int type)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\n\treturn priv->info->rxtstamp(ds, port, skb);\n}\n\nvoid sja1110_process_meta_tstamp(struct dsa_switch *ds, int port, u8 ts_id,\n\t\t\t\t enum sja1110_meta_tstamp dir, u64 tstamp)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct sja1105_ptp_data *ptp_data = &priv->ptp_data;\n\tstruct sk_buff *skb, *skb_tmp, *skb_match = NULL;\n\tstruct skb_shared_hwtstamps shwt = {0};\n\n\t \n\tif (dir == SJA1110_META_TSTAMP_RX)\n\t\treturn;\n\n\tspin_lock(&ptp_data->skb_txtstamp_queue.lock);\n\n\tskb_queue_walk_safe(&ptp_data->skb_txtstamp_queue, skb, skb_tmp) {\n\t\tif (SJA1105_SKB_CB(skb)->ts_id != ts_id)\n\t\t\tcontinue;\n\n\t\t__skb_unlink(skb, &ptp_data->skb_txtstamp_queue);\n\t\tskb_match = skb;\n\n\t\tbreak;\n\t}\n\n\tspin_unlock(&ptp_data->skb_txtstamp_queue.lock);\n\n\tif (WARN_ON(!skb_match))\n\t\treturn;\n\n\tshwt.hwtstamp = ns_to_ktime(sja1105_ticks_to_ns(tstamp));\n\tskb_complete_tx_timestamp(skb_match, &shwt);\n}\n\n \nvoid sja1110_txtstamp(struct dsa_switch *ds, int port, struct sk_buff *skb)\n{\n\tstruct sk_buff *clone = SJA1105_SKB_CB(skb)->clone;\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct sja1105_ptp_data *ptp_data = &priv->ptp_data;\n\tu8 ts_id;\n\n\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\n\tspin_lock(&priv->ts_id_lock);\n\n\tts_id = priv->ts_id;\n\t \n\tpriv->ts_id++;\n\n\tSJA1105_SKB_CB(clone)->ts_id = ts_id;\n\n\tspin_unlock(&priv->ts_id_lock);\n\n\tskb_queue_tail(&ptp_data->skb_txtstamp_queue, clone);\n}\n\n \nvoid sja1105_port_txtstamp(struct dsa_switch *ds, int port, struct sk_buff *skb)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct sk_buff *clone;\n\n\tif (!(priv->hwts_tx_en & BIT(port)))\n\t\treturn;\n\n\tclone = skb_clone_sk(skb);\n\tif (!clone)\n\t\treturn;\n\n\tSJA1105_SKB_CB(skb)->clone = clone;\n\n\tif (priv->info->txtstamp)\n\t\tpriv->info->txtstamp(ds, port, skb);\n}\n\nstatic int sja1105_ptp_reset(struct dsa_switch *ds)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct sja1105_ptp_data *ptp_data = &priv->ptp_data;\n\tstruct sja1105_ptp_cmd cmd = ptp_data->cmd;\n\tint rc;\n\n\tmutex_lock(&ptp_data->lock);\n\n\tcmd.resptp = 1;\n\n\tdev_dbg(ds->dev, \"Resetting PTP clock\\n\");\n\trc = sja1105_ptp_commit(ds, &cmd, SPI_WRITE);\n\n\tsja1105_tas_clockstep(priv->ds);\n\n\tmutex_unlock(&ptp_data->lock);\n\n\treturn rc;\n}\n\n \nint __sja1105_ptp_gettimex(struct dsa_switch *ds, u64 *ns,\n\t\t\t   struct ptp_system_timestamp *ptp_sts)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tu64 ticks;\n\tint rc;\n\n\trc = sja1105_ptpclkval_read(priv, &ticks, ptp_sts);\n\tif (rc < 0) {\n\t\tdev_err(ds->dev, \"Failed to read PTP clock: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t*ns = sja1105_ticks_to_ns(ticks);\n\n\treturn 0;\n}\n\nstatic int sja1105_ptp_gettimex(struct ptp_clock_info *ptp,\n\t\t\t\tstruct timespec64 *ts,\n\t\t\t\tstruct ptp_system_timestamp *ptp_sts)\n{\n\tstruct sja1105_ptp_data *ptp_data = ptp_caps_to_data(ptp);\n\tstruct sja1105_private *priv = ptp_data_to_sja1105(ptp_data);\n\tu64 now = 0;\n\tint rc;\n\n\tmutex_lock(&ptp_data->lock);\n\n\trc = __sja1105_ptp_gettimex(priv->ds, &now, ptp_sts);\n\t*ts = ns_to_timespec64(now);\n\n\tmutex_unlock(&ptp_data->lock);\n\n\treturn rc;\n}\n\n \nstatic int sja1105_ptp_mode_set(struct sja1105_private *priv,\n\t\t\t\tenum sja1105_ptp_clk_mode mode)\n{\n\tstruct sja1105_ptp_data *ptp_data = &priv->ptp_data;\n\n\tif (ptp_data->cmd.ptpclkadd == mode)\n\t\treturn 0;\n\n\tptp_data->cmd.ptpclkadd = mode;\n\n\treturn sja1105_ptp_commit(priv->ds, &ptp_data->cmd, SPI_WRITE);\n}\n\n \nint __sja1105_ptp_settime(struct dsa_switch *ds, u64 ns,\n\t\t\t  struct ptp_system_timestamp *ptp_sts)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tu64 ticks = ns_to_sja1105_ticks(ns);\n\tint rc;\n\n\trc = sja1105_ptp_mode_set(priv, PTP_SET_MODE);\n\tif (rc < 0) {\n\t\tdev_err(priv->ds->dev, \"Failed to put PTPCLK in set mode\\n\");\n\t\treturn rc;\n\t}\n\n\trc = sja1105_ptpclkval_write(priv, ticks, ptp_sts);\n\n\tsja1105_tas_clockstep(priv->ds);\n\n\treturn rc;\n}\n\nstatic int sja1105_ptp_settime(struct ptp_clock_info *ptp,\n\t\t\t       const struct timespec64 *ts)\n{\n\tstruct sja1105_ptp_data *ptp_data = ptp_caps_to_data(ptp);\n\tstruct sja1105_private *priv = ptp_data_to_sja1105(ptp_data);\n\tu64 ns = timespec64_to_ns(ts);\n\tint rc;\n\n\tmutex_lock(&ptp_data->lock);\n\n\trc = __sja1105_ptp_settime(priv->ds, ns, NULL);\n\n\tmutex_unlock(&ptp_data->lock);\n\n\treturn rc;\n}\n\nstatic int sja1105_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct sja1105_ptp_data *ptp_data = ptp_caps_to_data(ptp);\n\tstruct sja1105_private *priv = ptp_data_to_sja1105(ptp_data);\n\tconst struct sja1105_regs *regs = priv->info->regs;\n\tu32 clkrate32;\n\ts64 clkrate;\n\tint rc;\n\n\tclkrate = (s64)scaled_ppm * SJA1105_CC_MULT_NUM;\n\tclkrate = div_s64(clkrate, SJA1105_CC_MULT_DEM);\n\n\t \n\tclkrate = SJA1105_CC_MULT + clkrate;\n\tWARN_ON(abs(clkrate) >= GENMASK_ULL(31, 0));\n\tclkrate32 = clkrate;\n\n\tmutex_lock(&ptp_data->lock);\n\n\trc = sja1105_xfer_u32(priv, SPI_WRITE, regs->ptpclkrate, &clkrate32,\n\t\t\t      NULL);\n\n\tsja1105_tas_adjfreq(priv->ds);\n\n\tmutex_unlock(&ptp_data->lock);\n\n\treturn rc;\n}\n\n \nint __sja1105_ptp_adjtime(struct dsa_switch *ds, s64 delta)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\ts64 ticks = ns_to_sja1105_ticks(delta);\n\tint rc;\n\n\trc = sja1105_ptp_mode_set(priv, PTP_ADD_MODE);\n\tif (rc < 0) {\n\t\tdev_err(priv->ds->dev, \"Failed to put PTPCLK in add mode\\n\");\n\t\treturn rc;\n\t}\n\n\trc = sja1105_ptpclkval_write(priv, ticks, NULL);\n\n\tsja1105_tas_clockstep(priv->ds);\n\n\treturn rc;\n}\n\nstatic int sja1105_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct sja1105_ptp_data *ptp_data = ptp_caps_to_data(ptp);\n\tstruct sja1105_private *priv = ptp_data_to_sja1105(ptp_data);\n\tint rc;\n\n\tmutex_lock(&ptp_data->lock);\n\n\trc = __sja1105_ptp_adjtime(priv->ds, delta);\n\n\tmutex_unlock(&ptp_data->lock);\n\n\treturn rc;\n}\n\nstatic void sja1105_ptp_extts_setup_timer(struct sja1105_ptp_data *ptp_data)\n{\n\tunsigned long expires = ((jiffies / SJA1105_EXTTS_INTERVAL) + 1) *\n\t\t\t\tSJA1105_EXTTS_INTERVAL;\n\n\tmod_timer(&ptp_data->extts_timer, expires);\n}\n\nstatic void sja1105_ptp_extts_timer(struct timer_list *t)\n{\n\tstruct sja1105_ptp_data *ptp_data = extts_to_data(t);\n\n\tptp_schedule_worker(ptp_data->clock, 0);\n\n\tsja1105_ptp_extts_setup_timer(ptp_data);\n}\n\nstatic int sja1105_change_ptp_clk_pin_func(struct sja1105_private *priv,\n\t\t\t\t\t   enum ptp_pin_function func)\n{\n\tstruct sja1105_avb_params_entry *avb;\n\tenum ptp_pin_function old_func;\n\n\tavb = priv->static_config.tables[BLK_IDX_AVB_PARAMS].entries;\n\n\tif (priv->info->device_id == SJA1105E_DEVICE_ID ||\n\t    priv->info->device_id == SJA1105T_DEVICE_ID ||\n\t    avb->cas_master)\n\t\told_func = PTP_PF_PEROUT;\n\telse\n\t\told_func = PTP_PF_EXTTS;\n\n\tif (func == old_func)\n\t\treturn 0;\n\n\tavb->cas_master = (func == PTP_PF_PEROUT);\n\n\treturn sja1105_dynamic_config_write(priv, BLK_IDX_AVB_PARAMS, 0, avb,\n\t\t\t\t\t    true);\n}\n\n \nstatic int sja1105_per_out_enable(struct sja1105_private *priv,\n\t\t\t\t  struct ptp_perout_request *perout,\n\t\t\t\t  bool on)\n{\n\tstruct sja1105_ptp_data *ptp_data = &priv->ptp_data;\n\tconst struct sja1105_regs *regs = priv->info->regs;\n\tstruct sja1105_ptp_cmd cmd = ptp_data->cmd;\n\tint rc;\n\n\t \n\tif (perout->index != 0)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (perout->flags)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&ptp_data->lock);\n\n\trc = sja1105_change_ptp_clk_pin_func(priv, PTP_PF_PEROUT);\n\tif (rc)\n\t\tgoto out;\n\n\tif (on) {\n\t\tstruct timespec64 pin_duration_ts = {\n\t\t\t.tv_sec = perout->period.sec,\n\t\t\t.tv_nsec = perout->period.nsec,\n\t\t};\n\t\tstruct timespec64 pin_start_ts = {\n\t\t\t.tv_sec = perout->start.sec,\n\t\t\t.tv_nsec = perout->start.nsec,\n\t\t};\n\t\tu64 pin_duration = timespec64_to_ns(&pin_duration_ts);\n\t\tu64 pin_start = timespec64_to_ns(&pin_start_ts);\n\t\tu32 pin_duration32;\n\t\tu64 now;\n\n\t\t \n\t\tpin_duration = ns_to_sja1105_ticks(pin_duration / 2);\n\t\tif (pin_duration > U32_MAX) {\n\t\t\trc = -ERANGE;\n\t\t\tgoto out;\n\t\t}\n\t\tpin_duration32 = pin_duration;\n\n\t\t \n\t\trc = __sja1105_ptp_gettimex(priv->ds, &now, NULL);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\n\t\tpin_start = future_base_time(pin_start, pin_duration,\n\t\t\t\t\t     now + 1ull * NSEC_PER_SEC);\n\t\tpin_start = ns_to_sja1105_ticks(pin_start);\n\n\t\trc = sja1105_xfer_u64(priv, SPI_WRITE, regs->ptppinst,\n\t\t\t\t      &pin_start, NULL);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\n\t\trc = sja1105_xfer_u32(priv, SPI_WRITE, regs->ptppindur,\n\t\t\t\t      &pin_duration32, NULL);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (on)\n\t\tcmd.startptpcp = true;\n\telse\n\t\tcmd.stopptpcp = true;\n\n\trc = sja1105_ptp_commit(priv->ds, &cmd, SPI_WRITE);\n\nout:\n\tmutex_unlock(&ptp_data->lock);\n\n\treturn rc;\n}\n\nstatic int sja1105_extts_enable(struct sja1105_private *priv,\n\t\t\t\tstruct ptp_extts_request *extts,\n\t\t\t\tbool on)\n{\n\tint rc;\n\n\t \n\tif (extts->index != 0)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (extts->flags & ~(PTP_ENABLE_FEATURE |\n\t\t\t     PTP_RISING_EDGE |\n\t\t\t     PTP_FALLING_EDGE |\n\t\t\t     PTP_STRICT_FLAGS))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif ((extts->flags & PTP_STRICT_FLAGS) &&\n\t    (extts->flags & PTP_ENABLE_FEATURE) &&\n\t    (extts->flags & PTP_EXTTS_EDGES) != PTP_EXTTS_EDGES)\n\t\treturn -EOPNOTSUPP;\n\n\trc = sja1105_change_ptp_clk_pin_func(priv, PTP_PF_EXTTS);\n\tif (rc)\n\t\treturn rc;\n\n\tpriv->ptp_data.extts_enabled = on;\n\n\tif (on)\n\t\tsja1105_ptp_extts_setup_timer(&priv->ptp_data);\n\telse\n\t\tdel_timer_sync(&priv->ptp_data.extts_timer);\n\n\treturn 0;\n}\n\nstatic int sja1105_ptp_enable(struct ptp_clock_info *ptp,\n\t\t\t      struct ptp_clock_request *req, int on)\n{\n\tstruct sja1105_ptp_data *ptp_data = ptp_caps_to_data(ptp);\n\tstruct sja1105_private *priv = ptp_data_to_sja1105(ptp_data);\n\tint rc = -EOPNOTSUPP;\n\n\tif (req->type == PTP_CLK_REQ_PEROUT)\n\t\trc = sja1105_per_out_enable(priv, &req->perout, on);\n\telse if (req->type == PTP_CLK_REQ_EXTTS)\n\t\trc = sja1105_extts_enable(priv, &req->extts, on);\n\n\treturn rc;\n}\n\nstatic int sja1105_ptp_verify_pin(struct ptp_clock_info *ptp, unsigned int pin,\n\t\t\t\t  enum ptp_pin_function func, unsigned int chan)\n{\n\tstruct sja1105_ptp_data *ptp_data = ptp_caps_to_data(ptp);\n\tstruct sja1105_private *priv = ptp_data_to_sja1105(ptp_data);\n\n\tif (chan != 0 || pin != 0)\n\t\treturn -1;\n\n\tswitch (func) {\n\tcase PTP_PF_NONE:\n\tcase PTP_PF_PEROUT:\n\t\tbreak;\n\tcase PTP_PF_EXTTS:\n\t\tif (priv->info->device_id == SJA1105E_DEVICE_ID ||\n\t\t    priv->info->device_id == SJA1105T_DEVICE_ID)\n\t\t\treturn -1;\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic struct ptp_pin_desc sja1105_ptp_pin = {\n\t.name = \"ptp_clk\",\n\t.index = 0,\n\t.func = PTP_PF_NONE,\n};\n\nint sja1105_ptp_clock_register(struct dsa_switch *ds)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct sja1105_ptp_data *ptp_data = &priv->ptp_data;\n\n\tptp_data->caps = (struct ptp_clock_info) {\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.name\t\t= \"SJA1105 PHC\",\n\t\t.adjfine\t= sja1105_ptp_adjfine,\n\t\t.adjtime\t= sja1105_ptp_adjtime,\n\t\t.gettimex64\t= sja1105_ptp_gettimex,\n\t\t.settime64\t= sja1105_ptp_settime,\n\t\t.enable\t\t= sja1105_ptp_enable,\n\t\t.verify\t\t= sja1105_ptp_verify_pin,\n\t\t.do_aux_work\t= sja1105_rxtstamp_work,\n\t\t.max_adj\t= SJA1105_MAX_ADJ_PPB,\n\t\t.pin_config\t= &sja1105_ptp_pin,\n\t\t.n_pins\t\t= 1,\n\t\t.n_ext_ts\t= 1,\n\t\t.n_per_out\t= 1,\n\t};\n\n\t \n\tskb_queue_head_init(&ptp_data->skb_rxtstamp_queue);\n\t \n\tskb_queue_head_init(&ptp_data->skb_txtstamp_queue);\n\n\tptp_data->clock = ptp_clock_register(&ptp_data->caps, ds->dev);\n\tif (IS_ERR_OR_NULL(ptp_data->clock))\n\t\treturn PTR_ERR(ptp_data->clock);\n\n\tptp_data->cmd.corrclk4ts = true;\n\tptp_data->cmd.ptpclkadd = PTP_SET_MODE;\n\n\ttimer_setup(&ptp_data->extts_timer, sja1105_ptp_extts_timer, 0);\n\n\treturn sja1105_ptp_reset(ds);\n}\n\nvoid sja1105_ptp_clock_unregister(struct dsa_switch *ds)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct sja1105_ptp_data *ptp_data = &priv->ptp_data;\n\n\tif (IS_ERR_OR_NULL(ptp_data->clock))\n\t\treturn;\n\n\tdel_timer_sync(&ptp_data->extts_timer);\n\tptp_cancel_worker_sync(ptp_data->clock);\n\tskb_queue_purge(&ptp_data->skb_txtstamp_queue);\n\tskb_queue_purge(&ptp_data->skb_rxtstamp_queue);\n\tptp_clock_unregister(ptp_data->clock);\n\tptp_data->clock = NULL;\n}\n\nvoid sja1105_ptp_txtstamp_skb(struct dsa_switch *ds, int port,\n\t\t\t      struct sk_buff *skb)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct sja1105_ptp_data *ptp_data = &priv->ptp_data;\n\tstruct skb_shared_hwtstamps shwt = {0};\n\tu64 ticks, ts;\n\tint rc;\n\n\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\n\tmutex_lock(&ptp_data->lock);\n\n\trc = sja1105_ptpegr_ts_poll(ds, port, &ts);\n\tif (rc < 0) {\n\t\tdev_err(ds->dev, \"timed out polling for tstamp\\n\");\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\trc = sja1105_ptpclkval_read(priv, &ticks, NULL);\n\tif (rc < 0) {\n\t\tdev_err(ds->dev, \"Failed to read PTP clock: %d\\n\", rc);\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tts = sja1105_tstamp_reconstruct(ds, ticks, ts);\n\n\tshwt.hwtstamp = ns_to_ktime(sja1105_ticks_to_ns(ts));\n\tskb_complete_tx_timestamp(skb, &shwt);\n\nout:\n\tmutex_unlock(&ptp_data->lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}