{
  "module_name": "sja1105_vl.c",
  "hash_id": "1d35423c32d884d8e4a226a91a486baa725d3848eb0efaafea517b2d16ae831e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/sja1105/sja1105_vl.c",
  "human_readable_source": "\n \n#include <net/tc_act/tc_gate.h>\n#include <linux/dsa/8021q.h>\n#include \"sja1105_vl.h\"\n\n#define SJA1105_SIZE_VL_STATUS\t\t\t8\n\n \nstatic int sja1105_insert_gate_entry(struct sja1105_gating_config *gating_cfg,\n\t\t\t\t     struct sja1105_rule *rule,\n\t\t\t\t     u8 gate_state, s64 entry_time,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct sja1105_gate_entry *e;\n\tint rc;\n\n\te = kzalloc(sizeof(*e), GFP_KERNEL);\n\tif (!e)\n\t\treturn -ENOMEM;\n\n\te->rule = rule;\n\te->gate_state = gate_state;\n\te->interval = entry_time;\n\n\tif (list_empty(&gating_cfg->entries)) {\n\t\tlist_add(&e->list, &gating_cfg->entries);\n\t} else {\n\t\tstruct sja1105_gate_entry *p;\n\n\t\tlist_for_each_entry(p, &gating_cfg->entries, list) {\n\t\t\tif (p->interval == e->interval) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Gate conflict\");\n\t\t\t\trc = -EBUSY;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tif (e->interval < p->interval)\n\t\t\t\tbreak;\n\t\t}\n\t\tlist_add(&e->list, p->list.prev);\n\t}\n\n\tgating_cfg->num_entries++;\n\n\treturn 0;\nerr:\n\tkfree(e);\n\treturn rc;\n}\n\n \nstatic void\nsja1105_gating_cfg_time_to_interval(struct sja1105_gating_config *gating_cfg,\n\t\t\t\t    u64 cycle_time)\n{\n\tstruct sja1105_gate_entry *last_e;\n\tstruct sja1105_gate_entry *e;\n\tstruct list_head *prev;\n\n\tlist_for_each_entry(e, &gating_cfg->entries, list) {\n\t\tstruct sja1105_gate_entry *p;\n\n\t\tprev = e->list.prev;\n\n\t\tif (prev == &gating_cfg->entries)\n\t\t\tcontinue;\n\n\t\tp = list_entry(prev, struct sja1105_gate_entry, list);\n\t\tp->interval = e->interval - p->interval;\n\t}\n\tlast_e = list_last_entry(&gating_cfg->entries,\n\t\t\t\t struct sja1105_gate_entry, list);\n\tlast_e->interval = cycle_time - last_e->interval;\n}\n\nstatic void sja1105_free_gating_config(struct sja1105_gating_config *gating_cfg)\n{\n\tstruct sja1105_gate_entry *e, *n;\n\n\tlist_for_each_entry_safe(e, n, &gating_cfg->entries, list) {\n\t\tlist_del(&e->list);\n\t\tkfree(e);\n\t}\n}\n\nstatic int sja1105_compose_gating_subschedule(struct sja1105_private *priv,\n\t\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct sja1105_gating_config *gating_cfg = &priv->tas_data.gating_cfg;\n\tstruct sja1105_rule *rule;\n\ts64 max_cycle_time = 0;\n\ts64 its_base_time = 0;\n\tint i, rc = 0;\n\n\tsja1105_free_gating_config(gating_cfg);\n\n\tlist_for_each_entry(rule, &priv->flow_block.rules, list) {\n\t\tif (rule->type != SJA1105_RULE_VL)\n\t\t\tcontinue;\n\t\tif (rule->vl.type != SJA1105_VL_TIME_TRIGGERED)\n\t\t\tcontinue;\n\n\t\tif (max_cycle_time < rule->vl.cycle_time) {\n\t\t\tmax_cycle_time = rule->vl.cycle_time;\n\t\t\tits_base_time = rule->vl.base_time;\n\t\t}\n\t}\n\n\tif (!max_cycle_time)\n\t\treturn 0;\n\n\tdev_dbg(priv->ds->dev, \"max_cycle_time %lld its_base_time %lld\\n\",\n\t\tmax_cycle_time, its_base_time);\n\n\tgating_cfg->base_time = its_base_time;\n\tgating_cfg->cycle_time = max_cycle_time;\n\tgating_cfg->num_entries = 0;\n\n\tlist_for_each_entry(rule, &priv->flow_block.rules, list) {\n\t\ts64 time;\n\t\ts64 rbt;\n\n\t\tif (rule->type != SJA1105_RULE_VL)\n\t\t\tcontinue;\n\t\tif (rule->vl.type != SJA1105_VL_TIME_TRIGGERED)\n\t\t\tcontinue;\n\n\t\t \n\t\trbt = future_base_time(rule->vl.base_time, rule->vl.cycle_time,\n\t\t\t\t       its_base_time);\n\t\trbt -= its_base_time;\n\n\t\ttime = rbt;\n\n\t\tfor (i = 0; i < rule->vl.num_entries; i++) {\n\t\t\tu8 gate_state = rule->vl.entries[i].gate_state;\n\t\t\ts64 entry_time = time;\n\n\t\t\twhile (entry_time < max_cycle_time) {\n\t\t\t\trc = sja1105_insert_gate_entry(gating_cfg, rule,\n\t\t\t\t\t\t\t       gate_state,\n\t\t\t\t\t\t\t       entry_time,\n\t\t\t\t\t\t\t       extack);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tentry_time += rule->vl.cycle_time;\n\t\t\t}\n\t\t\ttime += rule->vl.entries[i].interval;\n\t\t}\n\t}\n\n\tsja1105_gating_cfg_time_to_interval(gating_cfg, max_cycle_time);\n\n\treturn 0;\nerr:\n\tsja1105_free_gating_config(gating_cfg);\n\treturn rc;\n}\n\n \n\nstatic bool sja1105_vl_key_lower(struct sja1105_vl_lookup_entry *a,\n\t\t\t\t struct sja1105_vl_lookup_entry *b)\n{\n\tif (a->macaddr < b->macaddr)\n\t\treturn true;\n\tif (a->macaddr > b->macaddr)\n\t\treturn false;\n\tif (a->vlanid < b->vlanid)\n\t\treturn true;\n\tif (a->vlanid > b->vlanid)\n\t\treturn false;\n\tif (a->port < b->port)\n\t\treturn true;\n\tif (a->port > b->port)\n\t\treturn false;\n\tif (a->vlanprior < b->vlanprior)\n\t\treturn true;\n\tif (a->vlanprior > b->vlanprior)\n\t\treturn false;\n\t \n\treturn false;\n}\n\n \nstatic u16 sja1105_port_get_tag_8021q_vid(struct dsa_port *dp)\n{\n\tunsigned long bridge_num;\n\n\tif (!dp->bridge)\n\t\treturn dsa_tag_8021q_standalone_vid(dp);\n\n\tbridge_num = dsa_port_bridge_num_get(dp);\n\n\treturn dsa_tag_8021q_bridge_vid(bridge_num);\n}\n\nstatic int sja1105_init_virtual_links(struct sja1105_private *priv,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct sja1105_vl_policing_entry *vl_policing;\n\tstruct sja1105_vl_forwarding_entry *vl_fwd;\n\tstruct sja1105_vl_lookup_entry *vl_lookup;\n\tbool have_critical_virtual_links = false;\n\tstruct sja1105_table *table;\n\tstruct sja1105_rule *rule;\n\tint num_virtual_links = 0;\n\tint max_sharindx = 0;\n\tint i, j, k;\n\n\t \n\tlist_for_each_entry(rule, &priv->flow_block.rules, list) {\n\t\tif (rule->type != SJA1105_RULE_VL)\n\t\t\tcontinue;\n\t\t \n\t\tnum_virtual_links += hweight_long(rule->port_mask);\n\n\t\tif (rule->vl.type != SJA1105_VL_NONCRITICAL)\n\t\t\thave_critical_virtual_links = true;\n\t\tif (max_sharindx < rule->vl.sharindx)\n\t\t\tmax_sharindx = rule->vl.sharindx;\n\t}\n\n\tif (num_virtual_links > SJA1105_MAX_VL_LOOKUP_COUNT) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Not enough VL entries available\");\n\t\treturn -ENOSPC;\n\t}\n\n\tif (max_sharindx + 1 > SJA1105_MAX_VL_LOOKUP_COUNT) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Policer index out of range\");\n\t\treturn -ENOSPC;\n\t}\n\n\tmax_sharindx = max_t(int, num_virtual_links, max_sharindx) + 1;\n\n\t \n\ttable = &priv->static_config.tables[BLK_IDX_VL_LOOKUP];\n\tif (table->entry_count) {\n\t\tkfree(table->entries);\n\t\ttable->entry_count = 0;\n\t}\n\n\t \n\ttable = &priv->static_config.tables[BLK_IDX_VL_POLICING];\n\tif (table->entry_count) {\n\t\tkfree(table->entries);\n\t\ttable->entry_count = 0;\n\t}\n\n\t \n\ttable = &priv->static_config.tables[BLK_IDX_VL_FORWARDING];\n\tif (table->entry_count) {\n\t\tkfree(table->entries);\n\t\ttable->entry_count = 0;\n\t}\n\n\t \n\ttable = &priv->static_config.tables[BLK_IDX_VL_FORWARDING_PARAMS];\n\tif (table->entry_count) {\n\t\tkfree(table->entries);\n\t\ttable->entry_count = 0;\n\t}\n\n\t \n\tif (!num_virtual_links)\n\t\treturn 0;\n\n\t \n\n\t \n\ttable = &priv->static_config.tables[BLK_IDX_VL_LOOKUP];\n\ttable->entries = kcalloc(num_virtual_links,\n\t\t\t\t table->ops->unpacked_entry_size,\n\t\t\t\t GFP_KERNEL);\n\tif (!table->entries)\n\t\treturn -ENOMEM;\n\ttable->entry_count = num_virtual_links;\n\tvl_lookup = table->entries;\n\n\tk = 0;\n\n\tlist_for_each_entry(rule, &priv->flow_block.rules, list) {\n\t\tunsigned long port;\n\n\t\tif (rule->type != SJA1105_RULE_VL)\n\t\t\tcontinue;\n\n\t\tfor_each_set_bit(port, &rule->port_mask, SJA1105_MAX_NUM_PORTS) {\n\t\t\tvl_lookup[k].format = SJA1105_VL_FORMAT_PSFP;\n\t\t\tvl_lookup[k].port = port;\n\t\t\tvl_lookup[k].macaddr = rule->key.vl.dmac;\n\t\t\tif (rule->key.type == SJA1105_KEY_VLAN_AWARE_VL) {\n\t\t\t\tvl_lookup[k].vlanid = rule->key.vl.vid;\n\t\t\t\tvl_lookup[k].vlanprior = rule->key.vl.pcp;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tstruct dsa_port *dp = dsa_to_port(priv->ds, port);\n\t\t\t\tu16 vid = sja1105_port_get_tag_8021q_vid(dp);\n\n\t\t\t\tvl_lookup[k].vlanid = vid;\n\t\t\t\tvl_lookup[k].vlanprior = 0;\n\t\t\t}\n\t\t\t \n\t\t\tif (rule->vl.type == SJA1105_VL_NONCRITICAL)\n\t\t\t\tvl_lookup[k].destports = rule->vl.destports;\n\t\t\telse\n\t\t\t\tvl_lookup[k].iscritical = true;\n\t\t\tvl_lookup[k].flow_cookie = rule->cookie;\n\t\t\tk++;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < num_virtual_links; i++) {\n\t\tstruct sja1105_vl_lookup_entry *a = &vl_lookup[i];\n\n\t\tfor (j = i + 1; j < num_virtual_links; j++) {\n\t\t\tstruct sja1105_vl_lookup_entry *b = &vl_lookup[j];\n\n\t\t\tif (sja1105_vl_key_lower(b, a)) {\n\t\t\t\tstruct sja1105_vl_lookup_entry tmp = *a;\n\n\t\t\t\t*a = *b;\n\t\t\t\t*b = tmp;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!have_critical_virtual_links)\n\t\treturn 0;\n\n\t \n\ttable = &priv->static_config.tables[BLK_IDX_VL_POLICING];\n\ttable->entries = kcalloc(max_sharindx, table->ops->unpacked_entry_size,\n\t\t\t\t GFP_KERNEL);\n\tif (!table->entries)\n\t\treturn -ENOMEM;\n\ttable->entry_count = max_sharindx;\n\tvl_policing = table->entries;\n\n\t \n\ttable = &priv->static_config.tables[BLK_IDX_VL_FORWARDING];\n\ttable->entries = kcalloc(max_sharindx, table->ops->unpacked_entry_size,\n\t\t\t\t GFP_KERNEL);\n\tif (!table->entries)\n\t\treturn -ENOMEM;\n\ttable->entry_count = max_sharindx;\n\tvl_fwd = table->entries;\n\n\t \n\ttable = &priv->static_config.tables[BLK_IDX_VL_FORWARDING_PARAMS];\n\ttable->entries = kcalloc(1, table->ops->unpacked_entry_size,\n\t\t\t\t GFP_KERNEL);\n\tif (!table->entries)\n\t\treturn -ENOMEM;\n\ttable->entry_count = 1;\n\n\tfor (i = 0; i < num_virtual_links; i++) {\n\t\tunsigned long cookie = vl_lookup[i].flow_cookie;\n\t\tstruct sja1105_rule *rule = sja1105_rule_find(priv, cookie);\n\n\t\tif (rule->vl.type == SJA1105_VL_NONCRITICAL)\n\t\t\tcontinue;\n\t\tif (rule->vl.type == SJA1105_VL_TIME_TRIGGERED) {\n\t\t\tint sharindx = rule->vl.sharindx;\n\n\t\t\tvl_policing[i].type = 1;\n\t\t\tvl_policing[i].sharindx = sharindx;\n\t\t\tvl_policing[i].maxlen = rule->vl.maxlen;\n\t\t\tvl_policing[sharindx].type = 1;\n\n\t\t\tvl_fwd[i].type = 1;\n\t\t\tvl_fwd[sharindx].type = 1;\n\t\t\tvl_fwd[sharindx].priority = rule->vl.ipv;\n\t\t\tvl_fwd[sharindx].partition = 0;\n\t\t\tvl_fwd[sharindx].destports = rule->vl.destports;\n\t\t}\n\t}\n\n\tsja1105_frame_memory_partitioning(priv);\n\n\treturn 0;\n}\n\nint sja1105_vl_redirect(struct sja1105_private *priv, int port,\n\t\t\tstruct netlink_ext_ack *extack, unsigned long cookie,\n\t\t\tstruct sja1105_key *key, unsigned long destports,\n\t\t\tbool append)\n{\n\tstruct sja1105_rule *rule = sja1105_rule_find(priv, cookie);\n\tstruct dsa_port *dp = dsa_to_port(priv->ds, port);\n\tbool vlan_aware = dsa_port_is_vlan_filtering(dp);\n\tint rc;\n\n\tif (!vlan_aware && key->type != SJA1105_KEY_VLAN_UNAWARE_VL) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Can only redirect based on DMAC\");\n\t\treturn -EOPNOTSUPP;\n\t} else if (vlan_aware && key->type != SJA1105_KEY_VLAN_AWARE_VL) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Can only redirect based on {DMAC, VID, PCP}\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!rule) {\n\t\trule = kzalloc(sizeof(*rule), GFP_KERNEL);\n\t\tif (!rule)\n\t\t\treturn -ENOMEM;\n\n\t\trule->cookie = cookie;\n\t\trule->type = SJA1105_RULE_VL;\n\t\trule->key = *key;\n\t\tlist_add(&rule->list, &priv->flow_block.rules);\n\t}\n\n\trule->port_mask |= BIT(port);\n\tif (append)\n\t\trule->vl.destports |= destports;\n\telse\n\t\trule->vl.destports = destports;\n\n\trc = sja1105_init_virtual_links(priv, extack);\n\tif (rc) {\n\t\trule->port_mask &= ~BIT(port);\n\t\tif (!rule->port_mask) {\n\t\t\tlist_del(&rule->list);\n\t\t\tkfree(rule);\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nint sja1105_vl_delete(struct sja1105_private *priv, int port,\n\t\t      struct sja1105_rule *rule, struct netlink_ext_ack *extack)\n{\n\tint rc;\n\n\trule->port_mask &= ~BIT(port);\n\tif (!rule->port_mask) {\n\t\tlist_del(&rule->list);\n\t\tkfree(rule);\n\t}\n\n\trc = sja1105_compose_gating_subschedule(priv, extack);\n\tif (rc)\n\t\treturn rc;\n\n\trc = sja1105_init_virtual_links(priv, extack);\n\tif (rc)\n\t\treturn rc;\n\n\trc = sja1105_init_scheduling(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn sja1105_static_config_reload(priv, SJA1105_VIRTUAL_LINKS);\n}\n\nint sja1105_vl_gate(struct sja1105_private *priv, int port,\n\t\t    struct netlink_ext_ack *extack, unsigned long cookie,\n\t\t    struct sja1105_key *key, u32 index, s32 prio,\n\t\t    u64 base_time, u64 cycle_time, u64 cycle_time_ext,\n\t\t    u32 num_entries, struct action_gate_entry *entries)\n{\n\tstruct sja1105_rule *rule = sja1105_rule_find(priv, cookie);\n\tstruct dsa_port *dp = dsa_to_port(priv->ds, port);\n\tbool vlan_aware = dsa_port_is_vlan_filtering(dp);\n\tint ipv = -1;\n\tint i, rc;\n\ts32 rem;\n\n\tif (cycle_time_ext) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Cycle time extension not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tdiv_s64_rem(base_time, sja1105_delta_to_ns(1), &rem);\n\tif (rem) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Base time must be multiple of 200 ns\");\n\t\treturn -ERANGE;\n\t}\n\n\tdiv_s64_rem(cycle_time, sja1105_delta_to_ns(1), &rem);\n\tif (rem) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Cycle time must be multiple of 200 ns\");\n\t\treturn -ERANGE;\n\t}\n\n\tif (!vlan_aware && key->type != SJA1105_KEY_VLAN_UNAWARE_VL) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Can only gate based on DMAC\");\n\t\treturn -EOPNOTSUPP;\n\t} else if (vlan_aware && key->type != SJA1105_KEY_VLAN_AWARE_VL) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Can only gate based on {DMAC, VID, PCP}\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!rule) {\n\t\trule = kzalloc(sizeof(*rule), GFP_KERNEL);\n\t\tif (!rule)\n\t\t\treturn -ENOMEM;\n\n\t\tlist_add(&rule->list, &priv->flow_block.rules);\n\t\trule->cookie = cookie;\n\t\trule->type = SJA1105_RULE_VL;\n\t\trule->key = *key;\n\t\trule->vl.type = SJA1105_VL_TIME_TRIGGERED;\n\t\trule->vl.sharindx = index;\n\t\trule->vl.base_time = base_time;\n\t\trule->vl.cycle_time = cycle_time;\n\t\trule->vl.num_entries = num_entries;\n\t\trule->vl.entries = kcalloc(num_entries,\n\t\t\t\t\t   sizeof(struct action_gate_entry),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!rule->vl.entries) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < num_entries; i++) {\n\t\t\tdiv_s64_rem(entries[i].interval,\n\t\t\t\t    sja1105_delta_to_ns(1), &rem);\n\t\t\tif (rem) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Interval must be multiple of 200 ns\");\n\t\t\t\trc = -ERANGE;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (!entries[i].interval) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Interval cannot be zero\");\n\t\t\t\trc = -ERANGE;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (ns_to_sja1105_delta(entries[i].interval) >\n\t\t\t    SJA1105_TAS_MAX_DELTA) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Maximum interval is 52 ms\");\n\t\t\t\trc = -ERANGE;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (entries[i].maxoctets != -1) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Cannot offload IntervalOctetMax\");\n\t\t\t\trc = -EOPNOTSUPP;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (ipv == -1) {\n\t\t\t\tipv = entries[i].ipv;\n\t\t\t} else if (ipv != entries[i].ipv) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Only support a single IPV per VL\");\n\t\t\t\trc = -EOPNOTSUPP;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\trule->vl.entries[i] = entries[i];\n\t\t}\n\n\t\tif (ipv == -1) {\n\t\t\tif (key->type == SJA1105_KEY_VLAN_AWARE_VL)\n\t\t\t\tipv = key->vl.pcp;\n\t\t\telse\n\t\t\t\tipv = 0;\n\t\t}\n\n\t\t \n\t\trule->vl.maxlen = VLAN_ETH_FRAME_LEN + ETH_FCS_LEN;\n\t\trule->vl.ipv = ipv;\n\t}\n\n\trule->port_mask |= BIT(port);\n\n\trc = sja1105_compose_gating_subschedule(priv, extack);\n\tif (rc)\n\t\tgoto out;\n\n\trc = sja1105_init_virtual_links(priv, extack);\n\tif (rc)\n\t\tgoto out;\n\n\tif (sja1105_gating_check_conflicts(priv, -1, extack)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Conflict with tc-taprio schedule\");\n\t\trc = -ERANGE;\n\t\tgoto out;\n\t}\n\nout:\n\tif (rc) {\n\t\trule->port_mask &= ~BIT(port);\n\t\tif (!rule->port_mask) {\n\t\t\tlist_del(&rule->list);\n\t\t\tkfree(rule->vl.entries);\n\t\t\tkfree(rule);\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nstatic int sja1105_find_vlid(struct sja1105_private *priv, int port,\n\t\t\t     struct sja1105_key *key)\n{\n\tstruct sja1105_vl_lookup_entry *vl_lookup;\n\tstruct sja1105_table *table;\n\tint i;\n\n\tif (WARN_ON(key->type != SJA1105_KEY_VLAN_AWARE_VL &&\n\t\t    key->type != SJA1105_KEY_VLAN_UNAWARE_VL))\n\t\treturn -1;\n\n\ttable = &priv->static_config.tables[BLK_IDX_VL_LOOKUP];\n\tvl_lookup = table->entries;\n\n\tfor (i = 0; i < table->entry_count; i++) {\n\t\tif (key->type == SJA1105_KEY_VLAN_AWARE_VL) {\n\t\t\tif (vl_lookup[i].port == port &&\n\t\t\t    vl_lookup[i].macaddr == key->vl.dmac &&\n\t\t\t    vl_lookup[i].vlanid == key->vl.vid &&\n\t\t\t    vl_lookup[i].vlanprior == key->vl.pcp)\n\t\t\t\treturn i;\n\t\t} else {\n\t\t\tif (vl_lookup[i].port == port &&\n\t\t\t    vl_lookup[i].macaddr == key->vl.dmac)\n\t\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint sja1105_vl_stats(struct sja1105_private *priv, int port,\n\t\t     struct sja1105_rule *rule, struct flow_stats *stats,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tconst struct sja1105_regs *regs = priv->info->regs;\n\tu8 buf[SJA1105_SIZE_VL_STATUS] = {0};\n\tu64 unreleased;\n\tu64 timingerr;\n\tu64 lengtherr;\n\tint vlid, rc;\n\tu64 pkts;\n\n\tif (rule->vl.type != SJA1105_VL_TIME_TRIGGERED)\n\t\treturn 0;\n\n\tvlid = sja1105_find_vlid(priv, port, &rule->key);\n\tif (vlid < 0)\n\t\treturn 0;\n\n\trc = sja1105_xfer_buf(priv, SPI_READ, regs->vl_status + 2 * vlid, buf,\n\t\t\t      SJA1105_SIZE_VL_STATUS);\n\tif (rc) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"SPI access failed\");\n\t\treturn rc;\n\t}\n\n\tsja1105_unpack(buf, &timingerr,  31, 16, SJA1105_SIZE_VL_STATUS);\n\tsja1105_unpack(buf, &unreleased, 15,  0, SJA1105_SIZE_VL_STATUS);\n\tsja1105_unpack(buf, &lengtherr,  47, 32, SJA1105_SIZE_VL_STATUS);\n\n\tpkts = timingerr + unreleased + lengtherr;\n\n\tflow_stats_update(stats, 0, pkts - rule->vl.stats.pkts, 0,\n\t\t\t  jiffies - rule->vl.stats.lastused,\n\t\t\t  FLOW_ACTION_HW_STATS_IMMEDIATE);\n\n\trule->vl.stats.pkts = pkts;\n\trule->vl.stats.lastused = jiffies;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}