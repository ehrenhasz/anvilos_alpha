{
  "module_name": "sja1105_tas.c",
  "hash_id": "523e22773558cf8762132b51e758a32d36402395f75b5cf3bdda6afca45684bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/sja1105/sja1105_tas.c",
  "human_readable_source": "\n \n#include \"sja1105.h\"\n\n#define SJA1105_TAS_CLKSRC_DISABLED\t0\n#define SJA1105_TAS_CLKSRC_STANDALONE\t1\n#define SJA1105_TAS_CLKSRC_AS6802\t2\n#define SJA1105_TAS_CLKSRC_PTP\t\t3\n#define SJA1105_GATE_MASK\t\tGENMASK_ULL(SJA1105_NUM_TC - 1, 0)\n\n#define work_to_sja1105_tas(d) \\\n\tcontainer_of((d), struct sja1105_tas_data, tas_work)\n#define tas_to_sja1105(d) \\\n\tcontainer_of((d), struct sja1105_private, tas_data)\n\nstatic int sja1105_tas_set_runtime_params(struct sja1105_private *priv)\n{\n\tstruct sja1105_tas_data *tas_data = &priv->tas_data;\n\tstruct sja1105_gating_config *gating_cfg = &tas_data->gating_cfg;\n\tstruct dsa_switch *ds = priv->ds;\n\ts64 earliest_base_time = S64_MAX;\n\ts64 latest_base_time = 0;\n\ts64 its_cycle_time = 0;\n\ts64 max_cycle_time = 0;\n\tint port;\n\n\ttas_data->enabled = false;\n\n\tfor (port = 0; port < ds->num_ports; port++) {\n\t\tconst struct tc_taprio_qopt_offload *offload;\n\n\t\toffload = tas_data->offload[port];\n\t\tif (!offload)\n\t\t\tcontinue;\n\n\t\ttas_data->enabled = true;\n\n\t\tif (max_cycle_time < offload->cycle_time)\n\t\t\tmax_cycle_time = offload->cycle_time;\n\t\tif (latest_base_time < offload->base_time)\n\t\t\tlatest_base_time = offload->base_time;\n\t\tif (earliest_base_time > offload->base_time) {\n\t\t\tearliest_base_time = offload->base_time;\n\t\t\tits_cycle_time = offload->cycle_time;\n\t\t}\n\t}\n\n\tif (!list_empty(&gating_cfg->entries)) {\n\t\ttas_data->enabled = true;\n\n\t\tif (max_cycle_time < gating_cfg->cycle_time)\n\t\t\tmax_cycle_time = gating_cfg->cycle_time;\n\t\tif (latest_base_time < gating_cfg->base_time)\n\t\t\tlatest_base_time = gating_cfg->base_time;\n\t\tif (earliest_base_time > gating_cfg->base_time) {\n\t\t\tearliest_base_time = gating_cfg->base_time;\n\t\t\tits_cycle_time = gating_cfg->cycle_time;\n\t\t}\n\t}\n\n\tif (!tas_data->enabled)\n\t\treturn 0;\n\n\t \n\tearliest_base_time = future_base_time(earliest_base_time,\n\t\t\t\t\t      its_cycle_time,\n\t\t\t\t\t      latest_base_time);\n\twhile (earliest_base_time > latest_base_time)\n\t\tearliest_base_time -= its_cycle_time;\n\tif (latest_base_time - earliest_base_time >\n\t    sja1105_delta_to_ns(SJA1105_TAS_MAX_DELTA)) {\n\t\tdev_err(ds->dev,\n\t\t\t\"Base times too far apart: min %llu max %llu\\n\",\n\t\t\tearliest_base_time, latest_base_time);\n\t\treturn -ERANGE;\n\t}\n\n\ttas_data->earliest_base_time = earliest_base_time;\n\ttas_data->max_cycle_time = max_cycle_time;\n\n\tdev_dbg(ds->dev, \"earliest base time %lld ns\\n\", earliest_base_time);\n\tdev_dbg(ds->dev, \"latest base time %lld ns\\n\", latest_base_time);\n\tdev_dbg(ds->dev, \"longest cycle time %lld ns\\n\", max_cycle_time);\n\n\treturn 0;\n}\n\n \nint sja1105_init_scheduling(struct sja1105_private *priv)\n{\n\tstruct sja1105_schedule_entry_points_entry *schedule_entry_points;\n\tstruct sja1105_schedule_entry_points_params_entry\n\t\t\t\t\t*schedule_entry_points_params;\n\tstruct sja1105_schedule_params_entry *schedule_params;\n\tstruct sja1105_tas_data *tas_data = &priv->tas_data;\n\tstruct sja1105_gating_config *gating_cfg = &tas_data->gating_cfg;\n\tstruct sja1105_schedule_entry *schedule;\n\tstruct dsa_switch *ds = priv->ds;\n\tstruct sja1105_table *table;\n\tint schedule_start_idx;\n\ts64 entry_point_delta;\n\tint schedule_end_idx;\n\tint num_entries = 0;\n\tint num_cycles = 0;\n\tint cycle = 0;\n\tint i, k = 0;\n\tint port, rc;\n\n\trc = sja1105_tas_set_runtime_params(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\ttable = &priv->static_config.tables[BLK_IDX_SCHEDULE];\n\tif (table->entry_count) {\n\t\tkfree(table->entries);\n\t\ttable->entry_count = 0;\n\t}\n\n\t \n\ttable = &priv->static_config.tables[BLK_IDX_SCHEDULE_ENTRY_POINTS_PARAMS];\n\tif (table->entry_count) {\n\t\tkfree(table->entries);\n\t\ttable->entry_count = 0;\n\t}\n\n\t \n\ttable = &priv->static_config.tables[BLK_IDX_SCHEDULE_PARAMS];\n\tif (table->entry_count) {\n\t\tkfree(table->entries);\n\t\ttable->entry_count = 0;\n\t}\n\n\t \n\ttable = &priv->static_config.tables[BLK_IDX_SCHEDULE_ENTRY_POINTS];\n\tif (table->entry_count) {\n\t\tkfree(table->entries);\n\t\ttable->entry_count = 0;\n\t}\n\n\t \n\tfor (port = 0; port < ds->num_ports; port++) {\n\t\tif (tas_data->offload[port]) {\n\t\t\tnum_entries += tas_data->offload[port]->num_entries;\n\t\t\tnum_cycles++;\n\t\t}\n\t}\n\n\tif (!list_empty(&gating_cfg->entries)) {\n\t\tnum_entries += gating_cfg->num_entries;\n\t\tnum_cycles++;\n\t}\n\n\t \n\tif (!num_cycles)\n\t\treturn 0;\n\n\t \n\n\t \n\ttable = &priv->static_config.tables[BLK_IDX_SCHEDULE];\n\ttable->entries = kcalloc(num_entries, table->ops->unpacked_entry_size,\n\t\t\t\t GFP_KERNEL);\n\tif (!table->entries)\n\t\treturn -ENOMEM;\n\ttable->entry_count = num_entries;\n\tschedule = table->entries;\n\n\t \n\ttable = &priv->static_config.tables[BLK_IDX_SCHEDULE_ENTRY_POINTS_PARAMS];\n\ttable->entries = kcalloc(SJA1105_MAX_SCHEDULE_ENTRY_POINTS_PARAMS_COUNT,\n\t\t\t\t table->ops->unpacked_entry_size, GFP_KERNEL);\n\tif (!table->entries)\n\t\t \n\t\treturn -ENOMEM;\n\ttable->entry_count = SJA1105_MAX_SCHEDULE_ENTRY_POINTS_PARAMS_COUNT;\n\tschedule_entry_points_params = table->entries;\n\n\t \n\ttable = &priv->static_config.tables[BLK_IDX_SCHEDULE_PARAMS];\n\ttable->entries = kcalloc(SJA1105_MAX_SCHEDULE_PARAMS_COUNT,\n\t\t\t\t table->ops->unpacked_entry_size, GFP_KERNEL);\n\tif (!table->entries)\n\t\treturn -ENOMEM;\n\ttable->entry_count = SJA1105_MAX_SCHEDULE_PARAMS_COUNT;\n\tschedule_params = table->entries;\n\n\t \n\ttable = &priv->static_config.tables[BLK_IDX_SCHEDULE_ENTRY_POINTS];\n\ttable->entries = kcalloc(num_cycles, table->ops->unpacked_entry_size,\n\t\t\t\t GFP_KERNEL);\n\tif (!table->entries)\n\t\treturn -ENOMEM;\n\ttable->entry_count = num_cycles;\n\tschedule_entry_points = table->entries;\n\n\t \n\tschedule_entry_points_params->clksrc = SJA1105_TAS_CLKSRC_PTP;\n\tschedule_entry_points_params->actsubsch = num_cycles - 1;\n\n\tfor (port = 0; port < ds->num_ports; port++) {\n\t\tconst struct tc_taprio_qopt_offload *offload;\n\t\t \n\t\ts64 rbt;\n\n\t\toffload = tas_data->offload[port];\n\t\tif (!offload)\n\t\t\tcontinue;\n\n\t\tschedule_start_idx = k;\n\t\tschedule_end_idx = k + offload->num_entries - 1;\n\t\t \n\t\trbt = future_base_time(offload->base_time,\n\t\t\t\t       offload->cycle_time,\n\t\t\t\t       tas_data->earliest_base_time);\n\t\trbt -= tas_data->earliest_base_time;\n\t\t \n\t\tentry_point_delta = ns_to_sja1105_delta(rbt) + 1;\n\n\t\tschedule_entry_points[cycle].subschindx = cycle;\n\t\tschedule_entry_points[cycle].delta = entry_point_delta;\n\t\tschedule_entry_points[cycle].address = schedule_start_idx;\n\n\t\t \n\t\tfor (i = cycle; i < 8; i++)\n\t\t\tschedule_params->subscheind[i] = schedule_end_idx;\n\n\t\tfor (i = 0; i < offload->num_entries; i++, k++) {\n\t\t\ts64 delta_ns = offload->entries[i].interval;\n\n\t\t\tschedule[k].delta = ns_to_sja1105_delta(delta_ns);\n\t\t\tschedule[k].destports = BIT(port);\n\t\t\tschedule[k].resmedia_en = true;\n\t\t\tschedule[k].resmedia = SJA1105_GATE_MASK &\n\t\t\t\t\t~offload->entries[i].gate_mask;\n\t\t}\n\t\tcycle++;\n\t}\n\n\tif (!list_empty(&gating_cfg->entries)) {\n\t\tstruct sja1105_gate_entry *e;\n\n\t\t \n\t\ts64 rbt;\n\n\t\tschedule_start_idx = k;\n\t\tschedule_end_idx = k + gating_cfg->num_entries - 1;\n\t\trbt = future_base_time(gating_cfg->base_time,\n\t\t\t\t       gating_cfg->cycle_time,\n\t\t\t\t       tas_data->earliest_base_time);\n\t\trbt -= tas_data->earliest_base_time;\n\t\tentry_point_delta = ns_to_sja1105_delta(rbt) + 1;\n\n\t\tschedule_entry_points[cycle].subschindx = cycle;\n\t\tschedule_entry_points[cycle].delta = entry_point_delta;\n\t\tschedule_entry_points[cycle].address = schedule_start_idx;\n\n\t\tfor (i = cycle; i < 8; i++)\n\t\t\tschedule_params->subscheind[i] = schedule_end_idx;\n\n\t\tlist_for_each_entry(e, &gating_cfg->entries, list) {\n\t\t\tschedule[k].delta = ns_to_sja1105_delta(e->interval);\n\t\t\tschedule[k].destports = e->rule->vl.destports;\n\t\t\tschedule[k].setvalid = true;\n\t\t\tschedule[k].txen = true;\n\t\t\tschedule[k].vlindex = e->rule->vl.sharindx;\n\t\t\tschedule[k].winstindex = e->rule->vl.sharindx;\n\t\t\tif (e->gate_state)  \n\t\t\t\tschedule[k].winst = true;\n\t\t\telse  \n\t\t\t\tschedule[k].winend = true;\n\t\t\tk++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic bool\nsja1105_tas_check_conflicts(struct sja1105_private *priv, int port,\n\t\t\t    const struct tc_taprio_qopt_offload *admin)\n{\n\tstruct sja1105_tas_data *tas_data = &priv->tas_data;\n\tconst struct tc_taprio_qopt_offload *offload;\n\ts64 max_cycle_time, min_cycle_time;\n\ts64 delta1, delta2;\n\ts64 rbt1, rbt2;\n\ts64 stop_time;\n\ts64 t1, t2;\n\tint i, j;\n\ts32 rem;\n\n\toffload = tas_data->offload[port];\n\tif (!offload)\n\t\treturn false;\n\n\t \n\tmax_cycle_time = max(offload->cycle_time, admin->cycle_time);\n\tmin_cycle_time = min(offload->cycle_time, admin->cycle_time);\n\tdiv_s64_rem(max_cycle_time, min_cycle_time, &rem);\n\tif (rem)\n\t\treturn true;\n\n\t \n\tdiv_s64_rem(offload->base_time, offload->cycle_time, &rem);\n\trbt1 = rem;\n\n\tdiv_s64_rem(admin->base_time, admin->cycle_time, &rem);\n\trbt2 = rem;\n\n\tstop_time = max_cycle_time + max(rbt1, rbt2);\n\n\t \n\tfor (i = 0, delta1 = 0;\n\t     i < offload->num_entries;\n\t     delta1 += offload->entries[i].interval, i++) {\n\t\t \n\t\tfor (j = 0, delta2 = 0;\n\t\t     j < admin->num_entries;\n\t\t     delta2 += admin->entries[j].interval, j++) {\n\t\t\t \n\t\t\tfor (t1 = rbt1 + delta1;\n\t\t\t     t1 <= stop_time;\n\t\t\t     t1 += offload->cycle_time) {\n\t\t\t\t \n\t\t\t\tfor (t2 = rbt2 + delta2;\n\t\t\t\t     t2 <= stop_time;\n\t\t\t\t     t2 += admin->cycle_time) {\n\t\t\t\t\tif (t1 == t2) {\n\t\t\t\t\t\tdev_warn(priv->ds->dev,\n\t\t\t\t\t\t\t \"GCL entry %d collides with entry %d of port %d\\n\",\n\t\t\t\t\t\t\t j, i, port);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\n \nbool sja1105_gating_check_conflicts(struct sja1105_private *priv, int port,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct sja1105_gating_config *gating_cfg = &priv->tas_data.gating_cfg;\n\tsize_t num_entries = gating_cfg->num_entries;\n\tstruct tc_taprio_qopt_offload *dummy;\n\tstruct dsa_switch *ds = priv->ds;\n\tstruct sja1105_gate_entry *e;\n\tbool conflict;\n\tint i = 0;\n\n\tif (list_empty(&gating_cfg->entries))\n\t\treturn false;\n\n\tdummy = kzalloc(struct_size(dummy, entries, num_entries), GFP_KERNEL);\n\tif (!dummy) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to allocate memory\");\n\t\treturn true;\n\t}\n\n\tdummy->num_entries = num_entries;\n\tdummy->base_time = gating_cfg->base_time;\n\tdummy->cycle_time = gating_cfg->cycle_time;\n\n\tlist_for_each_entry(e, &gating_cfg->entries, list)\n\t\tdummy->entries[i++].interval = e->interval;\n\n\tif (port != -1) {\n\t\tconflict = sja1105_tas_check_conflicts(priv, port, dummy);\n\t} else {\n\t\tfor (port = 0; port < ds->num_ports; port++) {\n\t\t\tconflict = sja1105_tas_check_conflicts(priv, port,\n\t\t\t\t\t\t\t       dummy);\n\t\t\tif (conflict)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tkfree(dummy);\n\n\treturn conflict;\n}\n\nint sja1105_setup_tc_taprio(struct dsa_switch *ds, int port,\n\t\t\t    struct tc_taprio_qopt_offload *admin)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct sja1105_tas_data *tas_data = &priv->tas_data;\n\tint other_port, rc, i;\n\n\t \n\tif ((!!tas_data->offload[port] && admin->cmd == TAPRIO_CMD_REPLACE) ||\n\t    (!tas_data->offload[port] && admin->cmd == TAPRIO_CMD_DESTROY))\n\t\treturn -EINVAL;\n\n\tif (admin->cmd == TAPRIO_CMD_DESTROY) {\n\t\ttaprio_offload_free(tas_data->offload[port]);\n\t\ttas_data->offload[port] = NULL;\n\n\t\trc = sja1105_init_scheduling(priv);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\treturn sja1105_static_config_reload(priv, SJA1105_SCHEDULING);\n\t} else if (admin->cmd != TAPRIO_CMD_REPLACE) {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (admin->cycle_time_extension)\n\t\treturn -ENOTSUPP;\n\n\tfor (i = 0; i < admin->num_entries; i++) {\n\t\ts64 delta_ns = admin->entries[i].interval;\n\t\ts64 delta_cycles = ns_to_sja1105_delta(delta_ns);\n\t\tbool too_long, too_short;\n\n\t\ttoo_long = (delta_cycles >= SJA1105_TAS_MAX_DELTA);\n\t\ttoo_short = (delta_cycles == 0);\n\t\tif (too_long || too_short) {\n\t\t\tdev_err(priv->ds->dev,\n\t\t\t\t\"Interval %llu too %s for GCL entry %d\\n\",\n\t\t\t\tdelta_ns, too_long ? \"long\" : \"short\", i);\n\t\t\treturn -ERANGE;\n\t\t}\n\t}\n\n\tfor (other_port = 0; other_port < ds->num_ports; other_port++) {\n\t\tif (other_port == port)\n\t\t\tcontinue;\n\n\t\tif (sja1105_tas_check_conflicts(priv, other_port, admin))\n\t\t\treturn -ERANGE;\n\t}\n\n\tif (sja1105_gating_check_conflicts(priv, port, NULL)) {\n\t\tdev_err(ds->dev, \"Conflict with tc-gate schedule\\n\");\n\t\treturn -ERANGE;\n\t}\n\n\ttas_data->offload[port] = taprio_offload_get(admin);\n\n\trc = sja1105_init_scheduling(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn sja1105_static_config_reload(priv, SJA1105_SCHEDULING);\n}\n\nstatic int sja1105_tas_check_running(struct sja1105_private *priv)\n{\n\tstruct sja1105_tas_data *tas_data = &priv->tas_data;\n\tstruct dsa_switch *ds = priv->ds;\n\tstruct sja1105_ptp_cmd cmd = {0};\n\tint rc;\n\n\trc = sja1105_ptp_commit(ds, &cmd, SPI_READ);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (cmd.ptpstrtsch == 1)\n\t\t \n\t\ttas_data->state = SJA1105_TAS_STATE_RUNNING;\n\telse if (cmd.ptpstopsch == 1)\n\t\t \n\t\ttas_data->state = SJA1105_TAS_STATE_DISABLED;\n\telse\n\t\t \n\t\trc = -EINVAL;\n\n\treturn rc;\n}\n\n \nstatic int sja1105_tas_adjust_drift(struct sja1105_private *priv,\n\t\t\t\t    u64 correction)\n{\n\tconst struct sja1105_regs *regs = priv->info->regs;\n\tu32 ptpclkcorp = ns_to_sja1105_ticks(correction);\n\n\treturn sja1105_xfer_u32(priv, SPI_WRITE, regs->ptpclkcorp,\n\t\t\t\t&ptpclkcorp, NULL);\n}\n\n \nstatic int sja1105_tas_set_base_time(struct sja1105_private *priv,\n\t\t\t\t     u64 base_time)\n{\n\tconst struct sja1105_regs *regs = priv->info->regs;\n\tu64 ptpschtm = ns_to_sja1105_ticks(base_time);\n\n\treturn sja1105_xfer_u64(priv, SPI_WRITE, regs->ptpschtm,\n\t\t\t\t&ptpschtm, NULL);\n}\n\nstatic int sja1105_tas_start(struct sja1105_private *priv)\n{\n\tstruct sja1105_tas_data *tas_data = &priv->tas_data;\n\tstruct sja1105_ptp_cmd *cmd = &priv->ptp_data.cmd;\n\tstruct dsa_switch *ds = priv->ds;\n\tint rc;\n\n\tdev_dbg(ds->dev, \"Starting the TAS\\n\");\n\n\tif (tas_data->state == SJA1105_TAS_STATE_ENABLED_NOT_RUNNING ||\n\t    tas_data->state == SJA1105_TAS_STATE_RUNNING) {\n\t\tdev_err(ds->dev, \"TAS already started\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcmd->ptpstrtsch = 1;\n\tcmd->ptpstopsch = 0;\n\n\trc = sja1105_ptp_commit(ds, cmd, SPI_WRITE);\n\tif (rc < 0)\n\t\treturn rc;\n\n\ttas_data->state = SJA1105_TAS_STATE_ENABLED_NOT_RUNNING;\n\n\treturn 0;\n}\n\nstatic int sja1105_tas_stop(struct sja1105_private *priv)\n{\n\tstruct sja1105_tas_data *tas_data = &priv->tas_data;\n\tstruct sja1105_ptp_cmd *cmd = &priv->ptp_data.cmd;\n\tstruct dsa_switch *ds = priv->ds;\n\tint rc;\n\n\tdev_dbg(ds->dev, \"Stopping the TAS\\n\");\n\n\tif (tas_data->state == SJA1105_TAS_STATE_DISABLED) {\n\t\tdev_err(ds->dev, \"TAS already disabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcmd->ptpstopsch = 1;\n\tcmd->ptpstrtsch = 0;\n\n\trc = sja1105_ptp_commit(ds, cmd, SPI_WRITE);\n\tif (rc < 0)\n\t\treturn rc;\n\n\ttas_data->state = SJA1105_TAS_STATE_DISABLED;\n\n\treturn 0;\n}\n\n \nstatic void sja1105_tas_state_machine(struct work_struct *work)\n{\n\tstruct sja1105_tas_data *tas_data = work_to_sja1105_tas(work);\n\tstruct sja1105_private *priv = tas_to_sja1105(tas_data);\n\tstruct sja1105_ptp_data *ptp_data = &priv->ptp_data;\n\tstruct timespec64 base_time_ts, now_ts;\n\tstruct dsa_switch *ds = priv->ds;\n\tstruct timespec64 diff;\n\ts64 base_time, now;\n\tint rc = 0;\n\n\tmutex_lock(&ptp_data->lock);\n\n\tswitch (tas_data->state) {\n\tcase SJA1105_TAS_STATE_DISABLED:\n\t\t \n\t\tif (tas_data->last_op != SJA1105_PTP_ADJUSTFREQ)\n\t\t\tbreak;\n\n\t\trc = sja1105_tas_adjust_drift(priv, tas_data->max_cycle_time);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\trc = __sja1105_ptp_gettimex(ds, &now, NULL);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\t \n\t\tbase_time = future_base_time(tas_data->earliest_base_time,\n\t\t\t\t\t     tas_data->max_cycle_time,\n\t\t\t\t\t     now + 1ull * NSEC_PER_SEC);\n\t\tbase_time -= sja1105_delta_to_ns(1);\n\n\t\trc = sja1105_tas_set_base_time(priv, base_time);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\ttas_data->oper_base_time = base_time;\n\n\t\trc = sja1105_tas_start(priv);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\tbase_time_ts = ns_to_timespec64(base_time);\n\t\tnow_ts = ns_to_timespec64(now);\n\n\t\tdev_dbg(ds->dev, \"OPER base time %lld.%09ld (now %lld.%09ld)\\n\",\n\t\t\tbase_time_ts.tv_sec, base_time_ts.tv_nsec,\n\t\t\tnow_ts.tv_sec, now_ts.tv_nsec);\n\n\t\tbreak;\n\n\tcase SJA1105_TAS_STATE_ENABLED_NOT_RUNNING:\n\t\tif (tas_data->last_op != SJA1105_PTP_ADJUSTFREQ) {\n\t\t\t \n\t\t\tsja1105_tas_stop(priv);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\trc = __sja1105_ptp_gettimex(ds, &now, NULL);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\tif (now < tas_data->oper_base_time) {\n\t\t\t \n\t\t\tdiff = ns_to_timespec64(tas_data->oper_base_time - now);\n\t\t\tdev_dbg(ds->dev, \"time to start: [%lld.%09ld]\",\n\t\t\t\tdiff.tv_sec, diff.tv_nsec);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\trc = sja1105_tas_check_running(priv);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\tif (tas_data->state != SJA1105_TAS_STATE_RUNNING)\n\t\t\t \n\t\t\tdev_err(ds->dev,\n\t\t\t\t\"TAS not started despite time elapsed\\n\");\n\n\t\tbreak;\n\n\tcase SJA1105_TAS_STATE_RUNNING:\n\t\t \n\t\tif (tas_data->last_op != SJA1105_PTP_ADJUSTFREQ) {\n\t\t\tsja1105_tas_stop(priv);\n\t\t\tbreak;\n\t\t}\n\n\t\trc = sja1105_tas_check_running(priv);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\n\t\tif (tas_data->state != SJA1105_TAS_STATE_RUNNING)\n\t\t\tdev_err(ds->dev, \"TAS surprisingly stopped\\n\");\n\n\t\tbreak;\n\n\tdefault:\n\t\tif (net_ratelimit())\n\t\t\tdev_err(ds->dev, \"TAS in an invalid state (incorrect use of API)!\\n\");\n\t}\n\n\tif (rc && net_ratelimit())\n\t\tdev_err(ds->dev, \"An operation returned %d\\n\", rc);\n\n\tmutex_unlock(&ptp_data->lock);\n}\n\nvoid sja1105_tas_clockstep(struct dsa_switch *ds)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct sja1105_tas_data *tas_data = &priv->tas_data;\n\n\tif (!tas_data->enabled)\n\t\treturn;\n\n\ttas_data->last_op = SJA1105_PTP_CLOCKSTEP;\n\tschedule_work(&tas_data->tas_work);\n}\n\nvoid sja1105_tas_adjfreq(struct dsa_switch *ds)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct sja1105_tas_data *tas_data = &priv->tas_data;\n\n\tif (!tas_data->enabled)\n\t\treturn;\n\n\t \n\tif (tas_data->state == SJA1105_TAS_STATE_RUNNING)\n\t\treturn;\n\n\ttas_data->last_op = SJA1105_PTP_ADJUSTFREQ;\n\tschedule_work(&tas_data->tas_work);\n}\n\nvoid sja1105_tas_setup(struct dsa_switch *ds)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct sja1105_tas_data *tas_data = &priv->tas_data;\n\n\tINIT_WORK(&tas_data->tas_work, sja1105_tas_state_machine);\n\ttas_data->state = SJA1105_TAS_STATE_DISABLED;\n\ttas_data->last_op = SJA1105_PTP_NONE;\n\n\tINIT_LIST_HEAD(&tas_data->gating_cfg.entries);\n}\n\nvoid sja1105_tas_teardown(struct dsa_switch *ds)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct tc_taprio_qopt_offload *offload;\n\tint port;\n\n\tcancel_work_sync(&priv->tas_data.tas_work);\n\n\tfor (port = 0; port < ds->num_ports; port++) {\n\t\toffload = priv->tas_data.offload[port];\n\t\tif (!offload)\n\t\t\tcontinue;\n\n\t\ttaprio_offload_free(offload);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}