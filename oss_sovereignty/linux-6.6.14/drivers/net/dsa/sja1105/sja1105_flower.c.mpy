{
  "module_name": "sja1105_flower.c",
  "hash_id": "533a91e3963ae93c6fcd3a72d04a1ebe2e015f381c99d8fe1b187ec7d19b6317",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/sja1105/sja1105_flower.c",
  "human_readable_source": "\n \n#include \"sja1105.h\"\n#include \"sja1105_vl.h\"\n\nstruct sja1105_rule *sja1105_rule_find(struct sja1105_private *priv,\n\t\t\t\t       unsigned long cookie)\n{\n\tstruct sja1105_rule *rule;\n\n\tlist_for_each_entry(rule, &priv->flow_block.rules, list)\n\t\tif (rule->cookie == cookie)\n\t\t\treturn rule;\n\n\treturn NULL;\n}\n\nstatic int sja1105_find_free_l2_policer(struct sja1105_private *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < SJA1105_NUM_L2_POLICERS; i++)\n\t\tif (!priv->flow_block.l2_policer_used[i])\n\t\t\treturn i;\n\n\treturn -1;\n}\n\nstatic int sja1105_setup_bcast_policer(struct sja1105_private *priv,\n\t\t\t\t       struct netlink_ext_ack *extack,\n\t\t\t\t       unsigned long cookie, int port,\n\t\t\t\t       u64 rate_bytes_per_sec,\n\t\t\t\t       u32 burst)\n{\n\tstruct sja1105_rule *rule = sja1105_rule_find(priv, cookie);\n\tstruct sja1105_l2_policing_entry *policing;\n\tstruct dsa_switch *ds = priv->ds;\n\tbool new_rule = false;\n\tunsigned long p;\n\tint rc;\n\n\tif (!rule) {\n\t\trule = kzalloc(sizeof(*rule), GFP_KERNEL);\n\t\tif (!rule)\n\t\t\treturn -ENOMEM;\n\n\t\trule->cookie = cookie;\n\t\trule->type = SJA1105_RULE_BCAST_POLICER;\n\t\trule->bcast_pol.sharindx = sja1105_find_free_l2_policer(priv);\n\t\trule->key.type = SJA1105_KEY_BCAST;\n\t\tnew_rule = true;\n\t}\n\n\tif (rule->bcast_pol.sharindx == -1) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"No more L2 policers free\");\n\t\trc = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tpolicing = priv->static_config.tables[BLK_IDX_L2_POLICING].entries;\n\n\tif (policing[(ds->num_ports * SJA1105_NUM_TC) + port].sharindx != port) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Port already has a broadcast policer\");\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\trule->port_mask |= BIT(port);\n\n\t \n\tfor_each_set_bit(p, &rule->port_mask, SJA1105_MAX_NUM_PORTS) {\n\t\tint bcast = (ds->num_ports * SJA1105_NUM_TC) + p;\n\n\t\tpolicing[bcast].sharindx = rule->bcast_pol.sharindx;\n\t}\n\n\tpolicing[rule->bcast_pol.sharindx].rate = div_u64(rate_bytes_per_sec *\n\t\t\t\t\t\t\t  512, 1000000);\n\tpolicing[rule->bcast_pol.sharindx].smax = burst;\n\n\t \n\tpolicing[rule->bcast_pol.sharindx].maxlen = VLAN_ETH_FRAME_LEN +\n\t\t\t\t\t\t    ETH_FCS_LEN;\n\n\trc = sja1105_static_config_reload(priv, SJA1105_BEST_EFFORT_POLICING);\n\nout:\n\tif (rc == 0 && new_rule) {\n\t\tpriv->flow_block.l2_policer_used[rule->bcast_pol.sharindx] = true;\n\t\tlist_add(&rule->list, &priv->flow_block.rules);\n\t} else if (new_rule) {\n\t\tkfree(rule);\n\t}\n\n\treturn rc;\n}\n\nstatic int sja1105_setup_tc_policer(struct sja1105_private *priv,\n\t\t\t\t    struct netlink_ext_ack *extack,\n\t\t\t\t    unsigned long cookie, int port, int tc,\n\t\t\t\t    u64 rate_bytes_per_sec,\n\t\t\t\t    u32 burst)\n{\n\tstruct sja1105_rule *rule = sja1105_rule_find(priv, cookie);\n\tstruct sja1105_l2_policing_entry *policing;\n\tbool new_rule = false;\n\tunsigned long p;\n\tint rc;\n\n\tif (!rule) {\n\t\trule = kzalloc(sizeof(*rule), GFP_KERNEL);\n\t\tif (!rule)\n\t\t\treturn -ENOMEM;\n\n\t\trule->cookie = cookie;\n\t\trule->type = SJA1105_RULE_TC_POLICER;\n\t\trule->tc_pol.sharindx = sja1105_find_free_l2_policer(priv);\n\t\trule->key.type = SJA1105_KEY_TC;\n\t\trule->key.tc.pcp = tc;\n\t\tnew_rule = true;\n\t}\n\n\tif (rule->tc_pol.sharindx == -1) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"No more L2 policers free\");\n\t\trc = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tpolicing = priv->static_config.tables[BLK_IDX_L2_POLICING].entries;\n\n\tif (policing[(port * SJA1105_NUM_TC) + tc].sharindx != port) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Port-TC pair already has an L2 policer\");\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\trule->port_mask |= BIT(port);\n\n\t \n\tfor_each_set_bit(p, &rule->port_mask, SJA1105_MAX_NUM_PORTS) {\n\t\tint index = (p * SJA1105_NUM_TC) + tc;\n\n\t\tpolicing[index].sharindx = rule->tc_pol.sharindx;\n\t}\n\n\tpolicing[rule->tc_pol.sharindx].rate = div_u64(rate_bytes_per_sec *\n\t\t\t\t\t\t       512, 1000000);\n\tpolicing[rule->tc_pol.sharindx].smax = burst;\n\n\t \n\tpolicing[rule->tc_pol.sharindx].maxlen = VLAN_ETH_FRAME_LEN +\n\t\t\t\t\t\t ETH_FCS_LEN;\n\n\trc = sja1105_static_config_reload(priv, SJA1105_BEST_EFFORT_POLICING);\n\nout:\n\tif (rc == 0 && new_rule) {\n\t\tpriv->flow_block.l2_policer_used[rule->tc_pol.sharindx] = true;\n\t\tlist_add(&rule->list, &priv->flow_block.rules);\n\t} else if (new_rule) {\n\t\tkfree(rule);\n\t}\n\n\treturn rc;\n}\n\nstatic int sja1105_flower_policer(struct sja1105_private *priv, int port,\n\t\t\t\t  struct netlink_ext_ack *extack,\n\t\t\t\t  unsigned long cookie,\n\t\t\t\t  struct sja1105_key *key,\n\t\t\t\t  u64 rate_bytes_per_sec,\n\t\t\t\t  u32 burst)\n{\n\tswitch (key->type) {\n\tcase SJA1105_KEY_BCAST:\n\t\treturn sja1105_setup_bcast_policer(priv, extack, cookie, port,\n\t\t\t\t\t\t   rate_bytes_per_sec, burst);\n\tcase SJA1105_KEY_TC:\n\t\treturn sja1105_setup_tc_policer(priv, extack, cookie, port,\n\t\t\t\t\t\tkey->tc.pcp, rate_bytes_per_sec,\n\t\t\t\t\t\tburst);\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unknown keys for policing\");\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int sja1105_flower_parse_key(struct sja1105_private *priv,\n\t\t\t\t    struct netlink_ext_ack *extack,\n\t\t\t\t    struct flow_cls_offload *cls,\n\t\t\t\t    struct sja1105_key *key)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(cls);\n\tstruct flow_dissector *dissector = rule->match.dissector;\n\tbool is_bcast_dmac = false;\n\tu64 dmac = U64_MAX;\n\tu16 vid = U16_MAX;\n\tu16 pcp = U16_MAX;\n\n\tif (dissector->used_keys &\n\t    ~(BIT_ULL(FLOW_DISSECTOR_KEY_BASIC) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_CONTROL) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_VLAN) |\n\t      BIT_ULL(FLOW_DISSECTOR_KEY_ETH_ADDRS))) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Unsupported keys used\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_BASIC)) {\n\t\tstruct flow_match_basic match;\n\n\t\tflow_rule_match_basic(rule, &match);\n\t\tif (match.key->n_proto) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Matching on protocol not supported\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_ETH_ADDRS)) {\n\t\tu8 bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\t\tu8 null[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\t\tstruct flow_match_eth_addrs match;\n\n\t\tflow_rule_match_eth_addrs(rule, &match);\n\n\t\tif (!ether_addr_equal_masked(match.key->src, null,\n\t\t\t\t\t     match.mask->src)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Matching on source MAC not supported\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (!ether_addr_equal(match.mask->dst, bcast)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Masked matching on MAC not supported\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tdmac = ether_addr_to_u64(match.key->dst);\n\t\tis_bcast_dmac = ether_addr_equal(match.key->dst, bcast);\n\t}\n\n\tif (flow_rule_match_key(rule, FLOW_DISSECTOR_KEY_VLAN)) {\n\t\tstruct flow_match_vlan match;\n\n\t\tflow_rule_match_vlan(rule, &match);\n\n\t\tif (match.mask->vlan_id &&\n\t\t    match.mask->vlan_id != VLAN_VID_MASK) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Masked matching on VID is not supported\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (match.mask->vlan_priority &&\n\t\t    match.mask->vlan_priority != 0x7) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Masked matching on PCP is not supported\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tif (match.mask->vlan_id)\n\t\t\tvid = match.key->vlan_id;\n\t\tif (match.mask->vlan_priority)\n\t\t\tpcp = match.key->vlan_priority;\n\t}\n\n\tif (is_bcast_dmac && vid == U16_MAX && pcp == U16_MAX) {\n\t\tkey->type = SJA1105_KEY_BCAST;\n\t\treturn 0;\n\t}\n\tif (dmac == U64_MAX && vid == U16_MAX && pcp != U16_MAX) {\n\t\tkey->type = SJA1105_KEY_TC;\n\t\tkey->tc.pcp = pcp;\n\t\treturn 0;\n\t}\n\tif (dmac != U64_MAX && vid != U16_MAX && pcp != U16_MAX) {\n\t\tkey->type = SJA1105_KEY_VLAN_AWARE_VL;\n\t\tkey->vl.dmac = dmac;\n\t\tkey->vl.vid = vid;\n\t\tkey->vl.pcp = pcp;\n\t\treturn 0;\n\t}\n\tif (dmac != U64_MAX) {\n\t\tkey->type = SJA1105_KEY_VLAN_UNAWARE_VL;\n\t\tkey->vl.dmac = dmac;\n\t\treturn 0;\n\t}\n\n\tNL_SET_ERR_MSG_MOD(extack, \"Not matching on any known key\");\n\treturn -EOPNOTSUPP;\n}\n\nstatic int sja1105_policer_validate(const struct flow_action *action,\n\t\t\t\t    const struct flow_action_entry *act,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tif (act->police.exceed.act_id != FLOW_ACTION_DROP) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when exceed action is not drop\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (act->police.notexceed.act_id != FLOW_ACTION_PIPE &&\n\t    act->police.notexceed.act_id != FLOW_ACTION_ACCEPT) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when conform action is not pipe or ok\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (act->police.notexceed.act_id == FLOW_ACTION_ACCEPT &&\n\t    !flow_action_is_last_entry(action, act)) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when conform action is ok, but action is not last\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (act->police.peakrate_bytes_ps ||\n\t    act->police.avrate || act->police.overhead) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Offload not supported when peakrate/avrate/overhead is configured\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (act->police.rate_pkt_ps) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"QoS offload not support packets per second\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nint sja1105_cls_flower_add(struct dsa_switch *ds, int port,\n\t\t\t   struct flow_cls_offload *cls, bool ingress)\n{\n\tstruct flow_rule *rule = flow_cls_offload_flow_rule(cls);\n\tstruct netlink_ext_ack *extack = cls->common.extack;\n\tstruct sja1105_private *priv = ds->priv;\n\tconst struct flow_action_entry *act;\n\tunsigned long cookie = cls->cookie;\n\tbool routing_rule = false;\n\tstruct sja1105_key key;\n\tbool gate_rule = false;\n\tbool vl_rule = false;\n\tint rc, i;\n\n\trc = sja1105_flower_parse_key(priv, extack, cls, &key);\n\tif (rc)\n\t\treturn rc;\n\n\tflow_action_for_each(i, act, &rule->action) {\n\t\tswitch (act->id) {\n\t\tcase FLOW_ACTION_POLICE:\n\t\t\trc = sja1105_policer_validate(&rule->action, act, extack);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\n\t\t\trc = sja1105_flower_policer(priv, port, extack, cookie,\n\t\t\t\t\t\t    &key,\n\t\t\t\t\t\t    act->police.rate_bytes_ps,\n\t\t\t\t\t\t    act->police.burst);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_TRAP: {\n\t\t\tint cpu = dsa_upstream_port(ds, port);\n\n\t\t\trouting_rule = true;\n\t\t\tvl_rule = true;\n\n\t\t\trc = sja1105_vl_redirect(priv, port, extack, cookie,\n\t\t\t\t\t\t &key, BIT(cpu), true);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\t}\n\t\tcase FLOW_ACTION_REDIRECT: {\n\t\t\tstruct dsa_port *to_dp;\n\n\t\t\tto_dp = dsa_port_from_netdev(act->dev);\n\t\t\tif (IS_ERR(to_dp)) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Destination not a switch port\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\trouting_rule = true;\n\t\t\tvl_rule = true;\n\n\t\t\trc = sja1105_vl_redirect(priv, port, extack, cookie,\n\t\t\t\t\t\t &key, BIT(to_dp->index), true);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\t}\n\t\tcase FLOW_ACTION_DROP:\n\t\t\tvl_rule = true;\n\n\t\t\trc = sja1105_vl_redirect(priv, port, extack, cookie,\n\t\t\t\t\t\t &key, 0, false);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase FLOW_ACTION_GATE:\n\t\t\tgate_rule = true;\n\t\t\tvl_rule = true;\n\n\t\t\trc = sja1105_vl_gate(priv, port, extack, cookie,\n\t\t\t\t\t     &key, act->hw_index,\n\t\t\t\t\t     act->gate.prio,\n\t\t\t\t\t     act->gate.basetime,\n\t\t\t\t\t     act->gate.cycletime,\n\t\t\t\t\t     act->gate.cycletimeext,\n\t\t\t\t\t     act->gate.num_entries,\n\t\t\t\t\t     act->gate.entries);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t   \"Action not supported\");\n\t\t\trc = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (vl_rule && !rc) {\n\t\t \n\t\tif (gate_rule) {\n\t\t\tif (!routing_rule) {\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t\t\t   \"Can only offload gate action together with redirect or trap\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t\trc = sja1105_init_scheduling(priv);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\trc = sja1105_static_config_reload(priv, SJA1105_VIRTUAL_LINKS);\n\t}\n\nout:\n\treturn rc;\n}\n\nint sja1105_cls_flower_del(struct dsa_switch *ds, int port,\n\t\t\t   struct flow_cls_offload *cls, bool ingress)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct sja1105_rule *rule = sja1105_rule_find(priv, cls->cookie);\n\tstruct sja1105_l2_policing_entry *policing;\n\tint old_sharindx;\n\n\tif (!rule)\n\t\treturn 0;\n\n\tif (rule->type == SJA1105_RULE_VL)\n\t\treturn sja1105_vl_delete(priv, port, rule, cls->common.extack);\n\n\tpolicing = priv->static_config.tables[BLK_IDX_L2_POLICING].entries;\n\n\tif (rule->type == SJA1105_RULE_BCAST_POLICER) {\n\t\tint bcast = (ds->num_ports * SJA1105_NUM_TC) + port;\n\n\t\told_sharindx = policing[bcast].sharindx;\n\t\tpolicing[bcast].sharindx = port;\n\t} else if (rule->type == SJA1105_RULE_TC_POLICER) {\n\t\tint index = (port * SJA1105_NUM_TC) + rule->key.tc.pcp;\n\n\t\told_sharindx = policing[index].sharindx;\n\t\tpolicing[index].sharindx = port;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\trule->port_mask &= ~BIT(port);\n\tif (!rule->port_mask) {\n\t\tpriv->flow_block.l2_policer_used[old_sharindx] = false;\n\t\tlist_del(&rule->list);\n\t\tkfree(rule);\n\t}\n\n\treturn sja1105_static_config_reload(priv, SJA1105_BEST_EFFORT_POLICING);\n}\n\nint sja1105_cls_flower_stats(struct dsa_switch *ds, int port,\n\t\t\t     struct flow_cls_offload *cls, bool ingress)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct sja1105_rule *rule = sja1105_rule_find(priv, cls->cookie);\n\tint rc;\n\n\tif (!rule)\n\t\treturn 0;\n\n\tif (rule->type != SJA1105_RULE_VL)\n\t\treturn 0;\n\n\trc = sja1105_vl_stats(priv, port, rule, &cls->stats,\n\t\t\t      cls->common.extack);\n\tif (rc)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nvoid sja1105_flower_setup(struct dsa_switch *ds)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tint port;\n\n\tINIT_LIST_HEAD(&priv->flow_block.rules);\n\n\tfor (port = 0; port < ds->num_ports; port++)\n\t\tpriv->flow_block.l2_policer_used[port] = true;\n}\n\nvoid sja1105_flower_teardown(struct dsa_switch *ds)\n{\n\tstruct sja1105_private *priv = ds->priv;\n\tstruct sja1105_rule *rule;\n\tstruct list_head *pos, *n;\n\n\tlist_for_each_safe(pos, n, &priv->flow_block.rules) {\n\t\trule = list_entry(pos, struct sja1105_rule, list);\n\t\tlist_del(&rule->list);\n\t\tkfree(rule);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}