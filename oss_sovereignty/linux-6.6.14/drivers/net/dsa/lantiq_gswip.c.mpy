{
  "module_name": "lantiq_gswip.c",
  "hash_id": "956383350895faa20c318024d7b2c8ef315aafb5d7dca334bef4cb705b5394d5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/lantiq_gswip.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/etherdevice.h>\n#include <linux/firmware.h>\n#include <linux/if_bridge.h>\n#include <linux/if_vlan.h>\n#include <linux/iopoll.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/of_platform.h>\n#include <linux/phy.h>\n#include <linux/phylink.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <net/dsa.h>\n#include <dt-bindings/mips/lantiq_rcu_gphy.h>\n\n#include \"lantiq_pce.h\"\n\n \n#define GSWIP_MDIO_GLOB\t\t\t0x00\n#define  GSWIP_MDIO_GLOB_ENABLE\t\tBIT(15)\n#define GSWIP_MDIO_CTRL\t\t\t0x08\n#define  GSWIP_MDIO_CTRL_BUSY\t\tBIT(12)\n#define  GSWIP_MDIO_CTRL_RD\t\tBIT(11)\n#define  GSWIP_MDIO_CTRL_WR\t\tBIT(10)\n#define  GSWIP_MDIO_CTRL_PHYAD_MASK\t0x1f\n#define  GSWIP_MDIO_CTRL_PHYAD_SHIFT\t5\n#define  GSWIP_MDIO_CTRL_REGAD_MASK\t0x1f\n#define GSWIP_MDIO_READ\t\t\t0x09\n#define GSWIP_MDIO_WRITE\t\t0x0A\n#define GSWIP_MDIO_MDC_CFG0\t\t0x0B\n#define GSWIP_MDIO_MDC_CFG1\t\t0x0C\n#define GSWIP_MDIO_PHYp(p)\t\t(0x15 - (p))\n#define  GSWIP_MDIO_PHY_LINK_MASK\t0x6000\n#define  GSWIP_MDIO_PHY_LINK_AUTO\t0x0000\n#define  GSWIP_MDIO_PHY_LINK_DOWN\t0x4000\n#define  GSWIP_MDIO_PHY_LINK_UP\t\t0x2000\n#define  GSWIP_MDIO_PHY_SPEED_MASK\t0x1800\n#define  GSWIP_MDIO_PHY_SPEED_AUTO\t0x1800\n#define  GSWIP_MDIO_PHY_SPEED_M10\t0x0000\n#define  GSWIP_MDIO_PHY_SPEED_M100\t0x0800\n#define  GSWIP_MDIO_PHY_SPEED_G1\t0x1000\n#define  GSWIP_MDIO_PHY_FDUP_MASK\t0x0600\n#define  GSWIP_MDIO_PHY_FDUP_AUTO\t0x0000\n#define  GSWIP_MDIO_PHY_FDUP_EN\t\t0x0200\n#define  GSWIP_MDIO_PHY_FDUP_DIS\t0x0600\n#define  GSWIP_MDIO_PHY_FCONTX_MASK\t0x0180\n#define  GSWIP_MDIO_PHY_FCONTX_AUTO\t0x0000\n#define  GSWIP_MDIO_PHY_FCONTX_EN\t0x0100\n#define  GSWIP_MDIO_PHY_FCONTX_DIS\t0x0180\n#define  GSWIP_MDIO_PHY_FCONRX_MASK\t0x0060\n#define  GSWIP_MDIO_PHY_FCONRX_AUTO\t0x0000\n#define  GSWIP_MDIO_PHY_FCONRX_EN\t0x0020\n#define  GSWIP_MDIO_PHY_FCONRX_DIS\t0x0060\n#define  GSWIP_MDIO_PHY_ADDR_MASK\t0x001f\n#define  GSWIP_MDIO_PHY_MASK\t\t(GSWIP_MDIO_PHY_ADDR_MASK | \\\n\t\t\t\t\t GSWIP_MDIO_PHY_FCONRX_MASK | \\\n\t\t\t\t\t GSWIP_MDIO_PHY_FCONTX_MASK | \\\n\t\t\t\t\t GSWIP_MDIO_PHY_LINK_MASK | \\\n\t\t\t\t\t GSWIP_MDIO_PHY_SPEED_MASK | \\\n\t\t\t\t\t GSWIP_MDIO_PHY_FDUP_MASK)\n\n \n#define GSWIP_MII_CFGp(p)\t\t(0x2 * (p))\n#define  GSWIP_MII_CFG_RESET\t\tBIT(15)\n#define  GSWIP_MII_CFG_EN\t\tBIT(14)\n#define  GSWIP_MII_CFG_ISOLATE\t\tBIT(13)\n#define  GSWIP_MII_CFG_LDCLKDIS\t\tBIT(12)\n#define  GSWIP_MII_CFG_RGMII_IBS\tBIT(8)\n#define  GSWIP_MII_CFG_RMII_CLK\t\tBIT(7)\n#define  GSWIP_MII_CFG_MODE_MIIP\t0x0\n#define  GSWIP_MII_CFG_MODE_MIIM\t0x1\n#define  GSWIP_MII_CFG_MODE_RMIIP\t0x2\n#define  GSWIP_MII_CFG_MODE_RMIIM\t0x3\n#define  GSWIP_MII_CFG_MODE_RGMII\t0x4\n#define  GSWIP_MII_CFG_MODE_GMII\t0x9\n#define  GSWIP_MII_CFG_MODE_MASK\t0xf\n#define  GSWIP_MII_CFG_RATE_M2P5\t0x00\n#define  GSWIP_MII_CFG_RATE_M25\t0x10\n#define  GSWIP_MII_CFG_RATE_M125\t0x20\n#define  GSWIP_MII_CFG_RATE_M50\t0x30\n#define  GSWIP_MII_CFG_RATE_AUTO\t0x40\n#define  GSWIP_MII_CFG_RATE_MASK\t0x70\n#define GSWIP_MII_PCDU0\t\t\t0x01\n#define GSWIP_MII_PCDU1\t\t\t0x03\n#define GSWIP_MII_PCDU5\t\t\t0x05\n#define  GSWIP_MII_PCDU_TXDLY_MASK\tGENMASK(2, 0)\n#define  GSWIP_MII_PCDU_RXDLY_MASK\tGENMASK(9, 7)\n\n \n#define GSWIP_SWRES\t\t\t0x000\n#define  GSWIP_SWRES_R1\t\t\tBIT(1)\t \n#define  GSWIP_SWRES_R0\t\t\tBIT(0)\t \n#define GSWIP_VERSION\t\t\t0x013\n#define  GSWIP_VERSION_REV_SHIFT\t0\n#define  GSWIP_VERSION_REV_MASK\t\tGENMASK(7, 0)\n#define  GSWIP_VERSION_MOD_SHIFT\t8\n#define  GSWIP_VERSION_MOD_MASK\t\tGENMASK(15, 8)\n#define   GSWIP_VERSION_2_0\t\t0x100\n#define   GSWIP_VERSION_2_1\t\t0x021\n#define   GSWIP_VERSION_2_2\t\t0x122\n#define   GSWIP_VERSION_2_2_ETC\t\t0x022\n\n#define GSWIP_BM_RAM_VAL(x)\t\t(0x043 - (x))\n#define GSWIP_BM_RAM_ADDR\t\t0x044\n#define GSWIP_BM_RAM_CTRL\t\t0x045\n#define  GSWIP_BM_RAM_CTRL_BAS\t\tBIT(15)\n#define  GSWIP_BM_RAM_CTRL_OPMOD\tBIT(5)\n#define  GSWIP_BM_RAM_CTRL_ADDR_MASK\tGENMASK(4, 0)\n#define GSWIP_BM_QUEUE_GCTRL\t\t0x04A\n#define  GSWIP_BM_QUEUE_GCTRL_GL_MOD\tBIT(10)\n \n#define GSWIP_BM_PCFGp(p)\t\t(0x080 + ((p) * 2))\n#define  GSWIP_BM_PCFG_CNTEN\t\tBIT(0)\t \n#define  GSWIP_BM_PCFG_IGCNT\t\tBIT(1)\t \n \n#define GSWIP_BM_RMON_CTRLp(p)\t\t(0x81 + ((p) * 2))\n#define  GSWIP_BM_CTRL_RMON_RAM1_RES\tBIT(0)\t \n#define  GSWIP_BM_CTRL_RMON_RAM2_RES\tBIT(1)\t \n\n \n#define GSWIP_PCE_TBL_KEY(x)\t\t(0x447 - (x))\n#define GSWIP_PCE_TBL_MASK\t\t0x448\n#define GSWIP_PCE_TBL_VAL(x)\t\t(0x44D - (x))\n#define GSWIP_PCE_TBL_ADDR\t\t0x44E\n#define GSWIP_PCE_TBL_CTRL\t\t0x44F\n#define  GSWIP_PCE_TBL_CTRL_BAS\t\tBIT(15)\n#define  GSWIP_PCE_TBL_CTRL_TYPE\tBIT(13)\n#define  GSWIP_PCE_TBL_CTRL_VLD\t\tBIT(12)\n#define  GSWIP_PCE_TBL_CTRL_KEYFORM\tBIT(11)\n#define  GSWIP_PCE_TBL_CTRL_GMAP_MASK\tGENMASK(10, 7)\n#define  GSWIP_PCE_TBL_CTRL_OPMOD_MASK\tGENMASK(6, 5)\n#define  GSWIP_PCE_TBL_CTRL_OPMOD_ADRD\t0x00\n#define  GSWIP_PCE_TBL_CTRL_OPMOD_ADWR\t0x20\n#define  GSWIP_PCE_TBL_CTRL_OPMOD_KSRD\t0x40\n#define  GSWIP_PCE_TBL_CTRL_OPMOD_KSWR\t0x60\n#define  GSWIP_PCE_TBL_CTRL_ADDR_MASK\tGENMASK(4, 0)\n#define GSWIP_PCE_PMAP1\t\t\t0x453\t \n#define GSWIP_PCE_PMAP2\t\t\t0x454\t \n#define GSWIP_PCE_PMAP3\t\t\t0x455\t \n#define GSWIP_PCE_GCTRL_0\t\t0x456\n#define  GSWIP_PCE_GCTRL_0_MTFL\t\tBIT(0)   \n#define  GSWIP_PCE_GCTRL_0_MC_VALID\tBIT(3)\n#define  GSWIP_PCE_GCTRL_0_VLAN\t\tBIT(14)  \n#define GSWIP_PCE_GCTRL_1\t\t0x457\n#define  GSWIP_PCE_GCTRL_1_MAC_GLOCK\tBIT(2)\t \n#define  GSWIP_PCE_GCTRL_1_MAC_GLOCK_MOD\tBIT(3)  \n#define GSWIP_PCE_PCTRL_0p(p)\t\t(0x480 + ((p) * 0xA))\n#define  GSWIP_PCE_PCTRL_0_TVM\t\tBIT(5)\t \n#define  GSWIP_PCE_PCTRL_0_VREP\t\tBIT(6)\t \n#define  GSWIP_PCE_PCTRL_0_INGRESS\tBIT(11)\t \n#define  GSWIP_PCE_PCTRL_0_PSTATE_LISTEN\t0x0\n#define  GSWIP_PCE_PCTRL_0_PSTATE_RX\t\t0x1\n#define  GSWIP_PCE_PCTRL_0_PSTATE_TX\t\t0x2\n#define  GSWIP_PCE_PCTRL_0_PSTATE_LEARNING\t0x3\n#define  GSWIP_PCE_PCTRL_0_PSTATE_FORWARDING\t0x7\n#define  GSWIP_PCE_PCTRL_0_PSTATE_MASK\tGENMASK(2, 0)\n#define GSWIP_PCE_VCTRL(p)\t\t(0x485 + ((p) * 0xA))\n#define  GSWIP_PCE_VCTRL_UVR\t\tBIT(0)\t \n#define  GSWIP_PCE_VCTRL_VIMR\t\tBIT(3)\t \n#define  GSWIP_PCE_VCTRL_VEMR\t\tBIT(4)\t \n#define  GSWIP_PCE_VCTRL_VSR\t\tBIT(5)\t \n#define  GSWIP_PCE_VCTRL_VID0\t\tBIT(6)\t \n#define GSWIP_PCE_DEFPVID(p)\t\t(0x486 + ((p) * 0xA))\n\n#define GSWIP_MAC_FLEN\t\t\t0x8C5\n#define GSWIP_MAC_CTRL_0p(p)\t\t(0x903 + ((p) * 0xC))\n#define  GSWIP_MAC_CTRL_0_PADEN\t\tBIT(8)\n#define  GSWIP_MAC_CTRL_0_FCS_EN\tBIT(7)\n#define  GSWIP_MAC_CTRL_0_FCON_MASK\t0x0070\n#define  GSWIP_MAC_CTRL_0_FCON_AUTO\t0x0000\n#define  GSWIP_MAC_CTRL_0_FCON_RX\t0x0010\n#define  GSWIP_MAC_CTRL_0_FCON_TX\t0x0020\n#define  GSWIP_MAC_CTRL_0_FCON_RXTX\t0x0030\n#define  GSWIP_MAC_CTRL_0_FCON_NONE\t0x0040\n#define  GSWIP_MAC_CTRL_0_FDUP_MASK\t0x000C\n#define  GSWIP_MAC_CTRL_0_FDUP_AUTO\t0x0000\n#define  GSWIP_MAC_CTRL_0_FDUP_EN\t0x0004\n#define  GSWIP_MAC_CTRL_0_FDUP_DIS\t0x000C\n#define  GSWIP_MAC_CTRL_0_GMII_MASK\t0x0003\n#define  GSWIP_MAC_CTRL_0_GMII_AUTO\t0x0000\n#define  GSWIP_MAC_CTRL_0_GMII_MII\t0x0001\n#define  GSWIP_MAC_CTRL_0_GMII_RGMII\t0x0002\n#define GSWIP_MAC_CTRL_2p(p)\t\t(0x905 + ((p) * 0xC))\n#define GSWIP_MAC_CTRL_2_LCHKL\t\tBIT(2)  \n#define GSWIP_MAC_CTRL_2_MLEN\t\tBIT(3)  \n\n \n#define GSWIP_FDMA_PCTRLp(p)\t\t(0xA80 + ((p) * 0x6))\n#define  GSWIP_FDMA_PCTRL_EN\t\tBIT(0)\t \n#define  GSWIP_FDMA_PCTRL_STEN\t\tBIT(1)\t \n#define  GSWIP_FDMA_PCTRL_VLANMOD_MASK\tGENMASK(4, 3)\t \n#define  GSWIP_FDMA_PCTRL_VLANMOD_SHIFT\t3\t \n#define  GSWIP_FDMA_PCTRL_VLANMOD_DIS\t(0x0 << GSWIP_FDMA_PCTRL_VLANMOD_SHIFT)\n#define  GSWIP_FDMA_PCTRL_VLANMOD_PRIO\t(0x1 << GSWIP_FDMA_PCTRL_VLANMOD_SHIFT)\n#define  GSWIP_FDMA_PCTRL_VLANMOD_ID\t(0x2 << GSWIP_FDMA_PCTRL_VLANMOD_SHIFT)\n#define  GSWIP_FDMA_PCTRL_VLANMOD_BOTH\t(0x3 << GSWIP_FDMA_PCTRL_VLANMOD_SHIFT)\n\n \n#define GSWIP_SDMA_PCTRLp(p)\t\t(0xBC0 + ((p) * 0x6))\n#define  GSWIP_SDMA_PCTRL_EN\t\tBIT(0)\t \n#define  GSWIP_SDMA_PCTRL_FCEN\t\tBIT(1)\t \n#define  GSWIP_SDMA_PCTRL_PAUFWD\tBIT(3)\t \n\n#define GSWIP_TABLE_ACTIVE_VLAN\t\t0x01\n#define GSWIP_TABLE_VLAN_MAPPING\t0x02\n#define GSWIP_TABLE_MAC_BRIDGE\t\t0x0b\n#define  GSWIP_TABLE_MAC_BRIDGE_STATIC\t0x01\t \n\n#define XRX200_GPHY_FW_ALIGN\t(16 * 1024)\n\n \n#define GSWIP_MAX_PACKET_LENGTH\t2400\n\nstruct gswip_hw_info {\n\tint max_ports;\n\tint cpu_port;\n\tconst struct dsa_switch_ops *ops;\n};\n\nstruct xway_gphy_match_data {\n\tchar *fe_firmware_name;\n\tchar *ge_firmware_name;\n};\n\nstruct gswip_gphy_fw {\n\tstruct clk *clk_gate;\n\tstruct reset_control *reset;\n\tu32 fw_addr_offset;\n\tchar *fw_name;\n};\n\nstruct gswip_vlan {\n\tstruct net_device *bridge;\n\tu16 vid;\n\tu8 fid;\n};\n\nstruct gswip_priv {\n\t__iomem void *gswip;\n\t__iomem void *mdio;\n\t__iomem void *mii;\n\tconst struct gswip_hw_info *hw_info;\n\tconst struct xway_gphy_match_data *gphy_fw_name_cfg;\n\tstruct dsa_switch *ds;\n\tstruct device *dev;\n\tstruct regmap *rcu_regmap;\n\tstruct gswip_vlan vlans[64];\n\tint num_gphy_fw;\n\tstruct gswip_gphy_fw *gphy_fw;\n\tu32 port_vlan_filter;\n\tstruct mutex pce_table_lock;\n};\n\nstruct gswip_pce_table_entry {\n\tu16 index;      \n\tu16 table;      \n\tu16 key[8];\n\tu16 val[5];\n\tu16 mask;\n\tu8 gmap;\n\tbool type;\n\tbool valid;\n\tbool key_mode;\n};\n\nstruct gswip_rmon_cnt_desc {\n\tunsigned int size;\n\tunsigned int offset;\n\tconst char *name;\n};\n\n#define MIB_DESC(_size, _offset, _name) {.size = _size, .offset = _offset, .name = _name}\n\nstatic const struct gswip_rmon_cnt_desc gswip_rmon_cnt[] = {\n\t \n\tMIB_DESC(1, 0x1F, \"RxGoodPkts\"),\n\tMIB_DESC(1, 0x23, \"RxUnicastPkts\"),\n\tMIB_DESC(1, 0x22, \"RxMulticastPkts\"),\n\tMIB_DESC(1, 0x21, \"RxFCSErrorPkts\"),\n\tMIB_DESC(1, 0x1D, \"RxUnderSizeGoodPkts\"),\n\tMIB_DESC(1, 0x1E, \"RxUnderSizeErrorPkts\"),\n\tMIB_DESC(1, 0x1B, \"RxOversizeGoodPkts\"),\n\tMIB_DESC(1, 0x1C, \"RxOversizeErrorPkts\"),\n\tMIB_DESC(1, 0x20, \"RxGoodPausePkts\"),\n\tMIB_DESC(1, 0x1A, \"RxAlignErrorPkts\"),\n\tMIB_DESC(1, 0x12, \"Rx64BytePkts\"),\n\tMIB_DESC(1, 0x13, \"Rx127BytePkts\"),\n\tMIB_DESC(1, 0x14, \"Rx255BytePkts\"),\n\tMIB_DESC(1, 0x15, \"Rx511BytePkts\"),\n\tMIB_DESC(1, 0x16, \"Rx1023BytePkts\"),\n\t \n\tMIB_DESC(1, 0x17, \"RxMaxBytePkts\"),\n\tMIB_DESC(1, 0x18, \"RxDroppedPkts\"),\n\tMIB_DESC(1, 0x19, \"RxFilteredPkts\"),\n\tMIB_DESC(2, 0x24, \"RxGoodBytes\"),\n\tMIB_DESC(2, 0x26, \"RxBadBytes\"),\n\tMIB_DESC(1, 0x11, \"TxAcmDroppedPkts\"),\n\tMIB_DESC(1, 0x0C, \"TxGoodPkts\"),\n\tMIB_DESC(1, 0x06, \"TxUnicastPkts\"),\n\tMIB_DESC(1, 0x07, \"TxMulticastPkts\"),\n\tMIB_DESC(1, 0x00, \"Tx64BytePkts\"),\n\tMIB_DESC(1, 0x01, \"Tx127BytePkts\"),\n\tMIB_DESC(1, 0x02, \"Tx255BytePkts\"),\n\tMIB_DESC(1, 0x03, \"Tx511BytePkts\"),\n\tMIB_DESC(1, 0x04, \"Tx1023BytePkts\"),\n\t \n\tMIB_DESC(1, 0x05, \"TxMaxBytePkts\"),\n\tMIB_DESC(1, 0x08, \"TxSingleCollCount\"),\n\tMIB_DESC(1, 0x09, \"TxMultCollCount\"),\n\tMIB_DESC(1, 0x0A, \"TxLateCollCount\"),\n\tMIB_DESC(1, 0x0B, \"TxExcessCollCount\"),\n\tMIB_DESC(1, 0x0D, \"TxPauseCount\"),\n\tMIB_DESC(1, 0x10, \"TxDroppedPkts\"),\n\tMIB_DESC(2, 0x0E, \"TxGoodBytes\"),\n};\n\nstatic u32 gswip_switch_r(struct gswip_priv *priv, u32 offset)\n{\n\treturn __raw_readl(priv->gswip + (offset * 4));\n}\n\nstatic void gswip_switch_w(struct gswip_priv *priv, u32 val, u32 offset)\n{\n\t__raw_writel(val, priv->gswip + (offset * 4));\n}\n\nstatic void gswip_switch_mask(struct gswip_priv *priv, u32 clear, u32 set,\n\t\t\t      u32 offset)\n{\n\tu32 val = gswip_switch_r(priv, offset);\n\n\tval &= ~(clear);\n\tval |= set;\n\tgswip_switch_w(priv, val, offset);\n}\n\nstatic u32 gswip_switch_r_timeout(struct gswip_priv *priv, u32 offset,\n\t\t\t\t  u32 cleared)\n{\n\tu32 val;\n\n\treturn readx_poll_timeout(__raw_readl, priv->gswip + (offset * 4), val,\n\t\t\t\t  (val & cleared) == 0, 20, 50000);\n}\n\nstatic u32 gswip_mdio_r(struct gswip_priv *priv, u32 offset)\n{\n\treturn __raw_readl(priv->mdio + (offset * 4));\n}\n\nstatic void gswip_mdio_w(struct gswip_priv *priv, u32 val, u32 offset)\n{\n\t__raw_writel(val, priv->mdio + (offset * 4));\n}\n\nstatic void gswip_mdio_mask(struct gswip_priv *priv, u32 clear, u32 set,\n\t\t\t    u32 offset)\n{\n\tu32 val = gswip_mdio_r(priv, offset);\n\n\tval &= ~(clear);\n\tval |= set;\n\tgswip_mdio_w(priv, val, offset);\n}\n\nstatic u32 gswip_mii_r(struct gswip_priv *priv, u32 offset)\n{\n\treturn __raw_readl(priv->mii + (offset * 4));\n}\n\nstatic void gswip_mii_w(struct gswip_priv *priv, u32 val, u32 offset)\n{\n\t__raw_writel(val, priv->mii + (offset * 4));\n}\n\nstatic void gswip_mii_mask(struct gswip_priv *priv, u32 clear, u32 set,\n\t\t\t   u32 offset)\n{\n\tu32 val = gswip_mii_r(priv, offset);\n\n\tval &= ~(clear);\n\tval |= set;\n\tgswip_mii_w(priv, val, offset);\n}\n\nstatic void gswip_mii_mask_cfg(struct gswip_priv *priv, u32 clear, u32 set,\n\t\t\t       int port)\n{\n\t \n\tif (!dsa_is_cpu_port(priv->ds, port))\n\t\tgswip_mii_mask(priv, clear, set, GSWIP_MII_CFGp(port));\n}\n\nstatic void gswip_mii_mask_pcdu(struct gswip_priv *priv, u32 clear, u32 set,\n\t\t\t\tint port)\n{\n\tswitch (port) {\n\tcase 0:\n\t\tgswip_mii_mask(priv, clear, set, GSWIP_MII_PCDU0);\n\t\tbreak;\n\tcase 1:\n\t\tgswip_mii_mask(priv, clear, set, GSWIP_MII_PCDU1);\n\t\tbreak;\n\tcase 5:\n\t\tgswip_mii_mask(priv, clear, set, GSWIP_MII_PCDU5);\n\t\tbreak;\n\t}\n}\n\nstatic int gswip_mdio_poll(struct gswip_priv *priv)\n{\n\tint cnt = 100;\n\n\twhile (likely(cnt--)) {\n\t\tu32 ctrl = gswip_mdio_r(priv, GSWIP_MDIO_CTRL);\n\n\t\tif ((ctrl & GSWIP_MDIO_CTRL_BUSY) == 0)\n\t\t\treturn 0;\n\t\tusleep_range(20, 40);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int gswip_mdio_wr(struct mii_bus *bus, int addr, int reg, u16 val)\n{\n\tstruct gswip_priv *priv = bus->priv;\n\tint err;\n\n\terr = gswip_mdio_poll(priv);\n\tif (err) {\n\t\tdev_err(&bus->dev, \"waiting for MDIO bus busy timed out\\n\");\n\t\treturn err;\n\t}\n\n\tgswip_mdio_w(priv, val, GSWIP_MDIO_WRITE);\n\tgswip_mdio_w(priv, GSWIP_MDIO_CTRL_BUSY | GSWIP_MDIO_CTRL_WR |\n\t\t((addr & GSWIP_MDIO_CTRL_PHYAD_MASK) << GSWIP_MDIO_CTRL_PHYAD_SHIFT) |\n\t\t(reg & GSWIP_MDIO_CTRL_REGAD_MASK),\n\t\tGSWIP_MDIO_CTRL);\n\n\treturn 0;\n}\n\nstatic int gswip_mdio_rd(struct mii_bus *bus, int addr, int reg)\n{\n\tstruct gswip_priv *priv = bus->priv;\n\tint err;\n\n\terr = gswip_mdio_poll(priv);\n\tif (err) {\n\t\tdev_err(&bus->dev, \"waiting for MDIO bus busy timed out\\n\");\n\t\treturn err;\n\t}\n\n\tgswip_mdio_w(priv, GSWIP_MDIO_CTRL_BUSY | GSWIP_MDIO_CTRL_RD |\n\t\t((addr & GSWIP_MDIO_CTRL_PHYAD_MASK) << GSWIP_MDIO_CTRL_PHYAD_SHIFT) |\n\t\t(reg & GSWIP_MDIO_CTRL_REGAD_MASK),\n\t\tGSWIP_MDIO_CTRL);\n\n\terr = gswip_mdio_poll(priv);\n\tif (err) {\n\t\tdev_err(&bus->dev, \"waiting for MDIO bus busy timed out\\n\");\n\t\treturn err;\n\t}\n\n\treturn gswip_mdio_r(priv, GSWIP_MDIO_READ);\n}\n\nstatic int gswip_mdio(struct gswip_priv *priv, struct device_node *mdio_np)\n{\n\tstruct dsa_switch *ds = priv->ds;\n\tint err;\n\n\tds->slave_mii_bus = mdiobus_alloc();\n\tif (!ds->slave_mii_bus)\n\t\treturn -ENOMEM;\n\n\tds->slave_mii_bus->priv = priv;\n\tds->slave_mii_bus->read = gswip_mdio_rd;\n\tds->slave_mii_bus->write = gswip_mdio_wr;\n\tds->slave_mii_bus->name = \"lantiq,xrx200-mdio\";\n\tsnprintf(ds->slave_mii_bus->id, MII_BUS_ID_SIZE, \"%s-mii\",\n\t\t dev_name(priv->dev));\n\tds->slave_mii_bus->parent = priv->dev;\n\tds->slave_mii_bus->phy_mask = ~ds->phys_mii_mask;\n\n\terr = of_mdiobus_register(ds->slave_mii_bus, mdio_np);\n\tif (err)\n\t\tmdiobus_free(ds->slave_mii_bus);\n\n\treturn err;\n}\n\nstatic int gswip_pce_table_entry_read(struct gswip_priv *priv,\n\t\t\t\t      struct gswip_pce_table_entry *tbl)\n{\n\tint i;\n\tint err;\n\tu16 crtl;\n\tu16 addr_mode = tbl->key_mode ? GSWIP_PCE_TBL_CTRL_OPMOD_KSRD :\n\t\t\t\t\tGSWIP_PCE_TBL_CTRL_OPMOD_ADRD;\n\n\tmutex_lock(&priv->pce_table_lock);\n\n\terr = gswip_switch_r_timeout(priv, GSWIP_PCE_TBL_CTRL,\n\t\t\t\t     GSWIP_PCE_TBL_CTRL_BAS);\n\tif (err) {\n\t\tmutex_unlock(&priv->pce_table_lock);\n\t\treturn err;\n\t}\n\n\tgswip_switch_w(priv, tbl->index, GSWIP_PCE_TBL_ADDR);\n\tgswip_switch_mask(priv, GSWIP_PCE_TBL_CTRL_ADDR_MASK |\n\t\t\t\tGSWIP_PCE_TBL_CTRL_OPMOD_MASK,\n\t\t\t  tbl->table | addr_mode | GSWIP_PCE_TBL_CTRL_BAS,\n\t\t\t  GSWIP_PCE_TBL_CTRL);\n\n\terr = gswip_switch_r_timeout(priv, GSWIP_PCE_TBL_CTRL,\n\t\t\t\t     GSWIP_PCE_TBL_CTRL_BAS);\n\tif (err) {\n\t\tmutex_unlock(&priv->pce_table_lock);\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(tbl->key); i++)\n\t\ttbl->key[i] = gswip_switch_r(priv, GSWIP_PCE_TBL_KEY(i));\n\n\tfor (i = 0; i < ARRAY_SIZE(tbl->val); i++)\n\t\ttbl->val[i] = gswip_switch_r(priv, GSWIP_PCE_TBL_VAL(i));\n\n\ttbl->mask = gswip_switch_r(priv, GSWIP_PCE_TBL_MASK);\n\n\tcrtl = gswip_switch_r(priv, GSWIP_PCE_TBL_CTRL);\n\n\ttbl->type = !!(crtl & GSWIP_PCE_TBL_CTRL_TYPE);\n\ttbl->valid = !!(crtl & GSWIP_PCE_TBL_CTRL_VLD);\n\ttbl->gmap = (crtl & GSWIP_PCE_TBL_CTRL_GMAP_MASK) >> 7;\n\n\tmutex_unlock(&priv->pce_table_lock);\n\n\treturn 0;\n}\n\nstatic int gswip_pce_table_entry_write(struct gswip_priv *priv,\n\t\t\t\t       struct gswip_pce_table_entry *tbl)\n{\n\tint i;\n\tint err;\n\tu16 crtl;\n\tu16 addr_mode = tbl->key_mode ? GSWIP_PCE_TBL_CTRL_OPMOD_KSWR :\n\t\t\t\t\tGSWIP_PCE_TBL_CTRL_OPMOD_ADWR;\n\n\tmutex_lock(&priv->pce_table_lock);\n\n\terr = gswip_switch_r_timeout(priv, GSWIP_PCE_TBL_CTRL,\n\t\t\t\t     GSWIP_PCE_TBL_CTRL_BAS);\n\tif (err) {\n\t\tmutex_unlock(&priv->pce_table_lock);\n\t\treturn err;\n\t}\n\n\tgswip_switch_w(priv, tbl->index, GSWIP_PCE_TBL_ADDR);\n\tgswip_switch_mask(priv, GSWIP_PCE_TBL_CTRL_ADDR_MASK |\n\t\t\t\tGSWIP_PCE_TBL_CTRL_OPMOD_MASK,\n\t\t\t  tbl->table | addr_mode,\n\t\t\t  GSWIP_PCE_TBL_CTRL);\n\n\tfor (i = 0; i < ARRAY_SIZE(tbl->key); i++)\n\t\tgswip_switch_w(priv, tbl->key[i], GSWIP_PCE_TBL_KEY(i));\n\n\tfor (i = 0; i < ARRAY_SIZE(tbl->val); i++)\n\t\tgswip_switch_w(priv, tbl->val[i], GSWIP_PCE_TBL_VAL(i));\n\n\tgswip_switch_mask(priv, GSWIP_PCE_TBL_CTRL_ADDR_MASK |\n\t\t\t\tGSWIP_PCE_TBL_CTRL_OPMOD_MASK,\n\t\t\t  tbl->table | addr_mode,\n\t\t\t  GSWIP_PCE_TBL_CTRL);\n\n\tgswip_switch_w(priv, tbl->mask, GSWIP_PCE_TBL_MASK);\n\n\tcrtl = gswip_switch_r(priv, GSWIP_PCE_TBL_CTRL);\n\tcrtl &= ~(GSWIP_PCE_TBL_CTRL_TYPE | GSWIP_PCE_TBL_CTRL_VLD |\n\t\t  GSWIP_PCE_TBL_CTRL_GMAP_MASK);\n\tif (tbl->type)\n\t\tcrtl |= GSWIP_PCE_TBL_CTRL_TYPE;\n\tif (tbl->valid)\n\t\tcrtl |= GSWIP_PCE_TBL_CTRL_VLD;\n\tcrtl |= (tbl->gmap << 7) & GSWIP_PCE_TBL_CTRL_GMAP_MASK;\n\tcrtl |= GSWIP_PCE_TBL_CTRL_BAS;\n\tgswip_switch_w(priv, crtl, GSWIP_PCE_TBL_CTRL);\n\n\terr = gswip_switch_r_timeout(priv, GSWIP_PCE_TBL_CTRL,\n\t\t\t\t     GSWIP_PCE_TBL_CTRL_BAS);\n\n\tmutex_unlock(&priv->pce_table_lock);\n\n\treturn err;\n}\n\n \nstatic int gswip_add_single_port_br(struct gswip_priv *priv, int port, bool add)\n{\n\tstruct gswip_pce_table_entry vlan_active = {0,};\n\tstruct gswip_pce_table_entry vlan_mapping = {0,};\n\tunsigned int cpu_port = priv->hw_info->cpu_port;\n\tunsigned int max_ports = priv->hw_info->max_ports;\n\tint err;\n\n\tif (port >= max_ports) {\n\t\tdev_err(priv->dev, \"single port for %i supported\\n\", port);\n\t\treturn -EIO;\n\t}\n\n\tvlan_active.index = port + 1;\n\tvlan_active.table = GSWIP_TABLE_ACTIVE_VLAN;\n\tvlan_active.key[0] = 0;  \n\tvlan_active.val[0] = port + 1  ;\n\tvlan_active.valid = add;\n\terr = gswip_pce_table_entry_write(priv, &vlan_active);\n\tif (err) {\n\t\tdev_err(priv->dev, \"failed to write active VLAN: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (!add)\n\t\treturn 0;\n\n\tvlan_mapping.index = port + 1;\n\tvlan_mapping.table = GSWIP_TABLE_VLAN_MAPPING;\n\tvlan_mapping.val[0] = 0  ;\n\tvlan_mapping.val[1] = BIT(port) | BIT(cpu_port);\n\tvlan_mapping.val[2] = 0;\n\terr = gswip_pce_table_entry_write(priv, &vlan_mapping);\n\tif (err) {\n\t\tdev_err(priv->dev, \"failed to write VLAN mapping: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int gswip_port_enable(struct dsa_switch *ds, int port,\n\t\t\t     struct phy_device *phydev)\n{\n\tstruct gswip_priv *priv = ds->priv;\n\tint err;\n\n\tif (!dsa_is_user_port(ds, port))\n\t\treturn 0;\n\n\tif (!dsa_is_cpu_port(ds, port)) {\n\t\terr = gswip_add_single_port_br(priv, port, true);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tgswip_switch_w(priv, GSWIP_BM_PCFG_CNTEN, GSWIP_BM_PCFGp(port));\n\n\t \n\tgswip_switch_mask(priv, 0, GSWIP_FDMA_PCTRL_EN |\n\t\t\t\t   GSWIP_FDMA_PCTRL_VLANMOD_BOTH,\n\t\t\t GSWIP_FDMA_PCTRLp(port));\n\tgswip_switch_mask(priv, 0, GSWIP_SDMA_PCTRL_EN,\n\t\t\t  GSWIP_SDMA_PCTRLp(port));\n\n\tif (!dsa_is_cpu_port(ds, port)) {\n\t\tu32 mdio_phy = 0;\n\n\t\tif (phydev)\n\t\t\tmdio_phy = phydev->mdio.addr & GSWIP_MDIO_PHY_ADDR_MASK;\n\n\t\tgswip_mdio_mask(priv, GSWIP_MDIO_PHY_ADDR_MASK, mdio_phy,\n\t\t\t\tGSWIP_MDIO_PHYp(port));\n\t}\n\n\treturn 0;\n}\n\nstatic void gswip_port_disable(struct dsa_switch *ds, int port)\n{\n\tstruct gswip_priv *priv = ds->priv;\n\n\tif (!dsa_is_user_port(ds, port))\n\t\treturn;\n\n\tgswip_switch_mask(priv, GSWIP_FDMA_PCTRL_EN, 0,\n\t\t\t  GSWIP_FDMA_PCTRLp(port));\n\tgswip_switch_mask(priv, GSWIP_SDMA_PCTRL_EN, 0,\n\t\t\t  GSWIP_SDMA_PCTRLp(port));\n}\n\nstatic int gswip_pce_load_microcode(struct gswip_priv *priv)\n{\n\tint i;\n\tint err;\n\n\tgswip_switch_mask(priv, GSWIP_PCE_TBL_CTRL_ADDR_MASK |\n\t\t\t\tGSWIP_PCE_TBL_CTRL_OPMOD_MASK,\n\t\t\t  GSWIP_PCE_TBL_CTRL_OPMOD_ADWR, GSWIP_PCE_TBL_CTRL);\n\tgswip_switch_w(priv, 0, GSWIP_PCE_TBL_MASK);\n\n\tfor (i = 0; i < ARRAY_SIZE(gswip_pce_microcode); i++) {\n\t\tgswip_switch_w(priv, i, GSWIP_PCE_TBL_ADDR);\n\t\tgswip_switch_w(priv, gswip_pce_microcode[i].val_0,\n\t\t\t       GSWIP_PCE_TBL_VAL(0));\n\t\tgswip_switch_w(priv, gswip_pce_microcode[i].val_1,\n\t\t\t       GSWIP_PCE_TBL_VAL(1));\n\t\tgswip_switch_w(priv, gswip_pce_microcode[i].val_2,\n\t\t\t       GSWIP_PCE_TBL_VAL(2));\n\t\tgswip_switch_w(priv, gswip_pce_microcode[i].val_3,\n\t\t\t       GSWIP_PCE_TBL_VAL(3));\n\n\t\t \n\t\tgswip_switch_mask(priv, 0, GSWIP_PCE_TBL_CTRL_BAS,\n\t\t\t\t  GSWIP_PCE_TBL_CTRL);\n\t\terr = gswip_switch_r_timeout(priv, GSWIP_PCE_TBL_CTRL,\n\t\t\t\t\t     GSWIP_PCE_TBL_CTRL_BAS);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tgswip_switch_mask(priv, 0, GSWIP_PCE_GCTRL_0_MC_VALID,\n\t\t\t  GSWIP_PCE_GCTRL_0);\n\n\treturn 0;\n}\n\nstatic int gswip_port_vlan_filtering(struct dsa_switch *ds, int port,\n\t\t\t\t     bool vlan_filtering,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net_device *bridge = dsa_port_bridge_dev_get(dsa_to_port(ds, port));\n\tstruct gswip_priv *priv = ds->priv;\n\n\t \n\tif (bridge && !!(priv->port_vlan_filter & BIT(port)) != vlan_filtering) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Dynamic toggling of vlan_filtering not supported\");\n\t\treturn -EIO;\n\t}\n\n\tif (vlan_filtering) {\n\t\t \n\t\tgswip_switch_mask(priv,\n\t\t\t\t  GSWIP_PCE_VCTRL_VSR,\n\t\t\t\t  GSWIP_PCE_VCTRL_UVR | GSWIP_PCE_VCTRL_VIMR |\n\t\t\t\t  GSWIP_PCE_VCTRL_VEMR,\n\t\t\t\t  GSWIP_PCE_VCTRL(port));\n\t\tgswip_switch_mask(priv, GSWIP_PCE_PCTRL_0_TVM, 0,\n\t\t\t\t  GSWIP_PCE_PCTRL_0p(port));\n\t} else {\n\t\t \n\t\tgswip_switch_mask(priv,\n\t\t\t\t  GSWIP_PCE_VCTRL_UVR | GSWIP_PCE_VCTRL_VIMR |\n\t\t\t\t  GSWIP_PCE_VCTRL_VEMR,\n\t\t\t\t  GSWIP_PCE_VCTRL_VSR,\n\t\t\t\t  GSWIP_PCE_VCTRL(port));\n\t\tgswip_switch_mask(priv, 0, GSWIP_PCE_PCTRL_0_TVM,\n\t\t\t\t  GSWIP_PCE_PCTRL_0p(port));\n\t}\n\n\treturn 0;\n}\n\nstatic int gswip_setup(struct dsa_switch *ds)\n{\n\tstruct gswip_priv *priv = ds->priv;\n\tunsigned int cpu_port = priv->hw_info->cpu_port;\n\tint i;\n\tint err;\n\n\tgswip_switch_w(priv, GSWIP_SWRES_R0, GSWIP_SWRES);\n\tusleep_range(5000, 10000);\n\tgswip_switch_w(priv, 0, GSWIP_SWRES);\n\n\t \n\tfor (i = 0; i < priv->hw_info->max_ports; i++) {\n\t\tgswip_port_disable(ds, i);\n\t\tgswip_port_vlan_filtering(ds, i, false, NULL);\n\t}\n\n\t \n\tgswip_mdio_mask(priv, 0, GSWIP_MDIO_GLOB_ENABLE, GSWIP_MDIO_GLOB);\n\n\terr = gswip_pce_load_microcode(priv);\n\tif (err) {\n\t\tdev_err(priv->dev, \"writing PCE microcode failed, %i\", err);\n\t\treturn err;\n\t}\n\n\t \n\tgswip_switch_w(priv, BIT(cpu_port), GSWIP_PCE_PMAP1);\n\tgswip_switch_w(priv, BIT(cpu_port), GSWIP_PCE_PMAP2);\n\tgswip_switch_w(priv, BIT(cpu_port), GSWIP_PCE_PMAP3);\n\n\t \n\tgswip_mdio_w(priv, 0x0, GSWIP_MDIO_MDC_CFG0);\n\n\t \n\tgswip_mdio_mask(priv, 0xff, 0x09, GSWIP_MDIO_MDC_CFG1);\n\n\t \n\tfor (i = 0; i < priv->hw_info->max_ports; i++)\n\t\tgswip_mii_mask_cfg(priv,\n\t\t\t\t   GSWIP_MII_CFG_EN | GSWIP_MII_CFG_ISOLATE,\n\t\t\t\t   0, i);\n\n\t \n\tgswip_switch_mask(priv, 0, GSWIP_FDMA_PCTRL_STEN,\n\t\t\t  GSWIP_FDMA_PCTRLp(cpu_port));\n\n\t \n\tgswip_switch_mask(priv, 0, GSWIP_PCE_PCTRL_0_INGRESS,\n\t\t\t  GSWIP_PCE_PCTRL_0p(cpu_port));\n\n\tgswip_switch_mask(priv, 0, GSWIP_BM_QUEUE_GCTRL_GL_MOD,\n\t\t\t  GSWIP_BM_QUEUE_GCTRL);\n\n\t \n\tgswip_switch_mask(priv, 0, GSWIP_PCE_GCTRL_0_VLAN, GSWIP_PCE_GCTRL_0);\n\n\t \n\tgswip_switch_mask(priv, 0, GSWIP_PCE_GCTRL_0_MTFL, GSWIP_PCE_GCTRL_0);\n\n\terr = gswip_switch_r_timeout(priv, GSWIP_PCE_GCTRL_0,\n\t\t\t\t     GSWIP_PCE_GCTRL_0_MTFL);\n\tif (err) {\n\t\tdev_err(priv->dev, \"MAC flushing didn't finish\\n\");\n\t\treturn err;\n\t}\n\n\tds->mtu_enforcement_ingress = true;\n\n\tgswip_port_enable(ds, cpu_port, NULL);\n\n\tds->configure_vlan_while_not_filtering = false;\n\n\treturn 0;\n}\n\nstatic enum dsa_tag_protocol gswip_get_tag_protocol(struct dsa_switch *ds,\n\t\t\t\t\t\t    int port,\n\t\t\t\t\t\t    enum dsa_tag_protocol mp)\n{\n\treturn DSA_TAG_PROTO_GSWIP;\n}\n\nstatic int gswip_vlan_active_create(struct gswip_priv *priv,\n\t\t\t\t    struct net_device *bridge,\n\t\t\t\t    int fid, u16 vid)\n{\n\tstruct gswip_pce_table_entry vlan_active = {0,};\n\tunsigned int max_ports = priv->hw_info->max_ports;\n\tint idx = -1;\n\tint err;\n\tint i;\n\n\t \n\tfor (i = max_ports; i < ARRAY_SIZE(priv->vlans); i++) {\n\t\tif (!priv->vlans[i].bridge) {\n\t\t\tidx = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (idx == -1)\n\t\treturn -ENOSPC;\n\n\tif (fid == -1)\n\t\tfid = idx;\n\n\tvlan_active.index = idx;\n\tvlan_active.table = GSWIP_TABLE_ACTIVE_VLAN;\n\tvlan_active.key[0] = vid;\n\tvlan_active.val[0] = fid;\n\tvlan_active.valid = true;\n\n\terr = gswip_pce_table_entry_write(priv, &vlan_active);\n\tif (err) {\n\t\tdev_err(priv->dev, \"failed to write active VLAN: %d\\n\",\terr);\n\t\treturn err;\n\t}\n\n\tpriv->vlans[idx].bridge = bridge;\n\tpriv->vlans[idx].vid = vid;\n\tpriv->vlans[idx].fid = fid;\n\n\treturn idx;\n}\n\nstatic int gswip_vlan_active_remove(struct gswip_priv *priv, int idx)\n{\n\tstruct gswip_pce_table_entry vlan_active = {0,};\n\tint err;\n\n\tvlan_active.index = idx;\n\tvlan_active.table = GSWIP_TABLE_ACTIVE_VLAN;\n\tvlan_active.valid = false;\n\terr = gswip_pce_table_entry_write(priv, &vlan_active);\n\tif (err)\n\t\tdev_err(priv->dev, \"failed to delete active VLAN: %d\\n\", err);\n\tpriv->vlans[idx].bridge = NULL;\n\n\treturn err;\n}\n\nstatic int gswip_vlan_add_unaware(struct gswip_priv *priv,\n\t\t\t\t  struct net_device *bridge, int port)\n{\n\tstruct gswip_pce_table_entry vlan_mapping = {0,};\n\tunsigned int max_ports = priv->hw_info->max_ports;\n\tunsigned int cpu_port = priv->hw_info->cpu_port;\n\tbool active_vlan_created = false;\n\tint idx = -1;\n\tint i;\n\tint err;\n\n\t \n\tfor (i = max_ports; i < ARRAY_SIZE(priv->vlans); i++) {\n\t\tif (priv->vlans[i].bridge == bridge) {\n\t\t\tidx = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (idx == -1) {\n\t\tidx = gswip_vlan_active_create(priv, bridge, -1, 0);\n\t\tif (idx < 0)\n\t\t\treturn idx;\n\t\tactive_vlan_created = true;\n\n\t\tvlan_mapping.index = idx;\n\t\tvlan_mapping.table = GSWIP_TABLE_VLAN_MAPPING;\n\t\t \n\t\tvlan_mapping.val[0] = 0;\n\t} else {\n\t\t \n\t\tvlan_mapping.index = idx;\n\t\tvlan_mapping.table = GSWIP_TABLE_VLAN_MAPPING;\n\t\terr = gswip_pce_table_entry_read(priv, &vlan_mapping);\n\t\tif (err) {\n\t\t\tdev_err(priv->dev, \"failed to read VLAN mapping: %d\\n\",\n\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tvlan_mapping.val[1] |= BIT(cpu_port);\n\tvlan_mapping.val[1] |= BIT(port);\n\terr = gswip_pce_table_entry_write(priv, &vlan_mapping);\n\tif (err) {\n\t\tdev_err(priv->dev, \"failed to write VLAN mapping: %d\\n\", err);\n\t\t \n\t\tif (active_vlan_created)\n\t\t\tgswip_vlan_active_remove(priv, idx);\n\t\treturn err;\n\t}\n\n\tgswip_switch_w(priv, 0, GSWIP_PCE_DEFPVID(port));\n\treturn 0;\n}\n\nstatic int gswip_vlan_add_aware(struct gswip_priv *priv,\n\t\t\t\tstruct net_device *bridge, int port,\n\t\t\t\tu16 vid, bool untagged,\n\t\t\t\tbool pvid)\n{\n\tstruct gswip_pce_table_entry vlan_mapping = {0,};\n\tunsigned int max_ports = priv->hw_info->max_ports;\n\tunsigned int cpu_port = priv->hw_info->cpu_port;\n\tbool active_vlan_created = false;\n\tint idx = -1;\n\tint fid = -1;\n\tint i;\n\tint err;\n\n\t \n\tfor (i = max_ports; i < ARRAY_SIZE(priv->vlans); i++) {\n\t\tif (priv->vlans[i].bridge == bridge) {\n\t\t\tif (fid != -1 && fid != priv->vlans[i].fid)\n\t\t\t\tdev_err(priv->dev, \"one bridge with multiple flow ids\\n\");\n\t\t\tfid = priv->vlans[i].fid;\n\t\t\tif (priv->vlans[i].vid == vid) {\n\t\t\t\tidx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (idx == -1) {\n\t\tidx = gswip_vlan_active_create(priv, bridge, fid, vid);\n\t\tif (idx < 0)\n\t\t\treturn idx;\n\t\tactive_vlan_created = true;\n\n\t\tvlan_mapping.index = idx;\n\t\tvlan_mapping.table = GSWIP_TABLE_VLAN_MAPPING;\n\t\t \n\t\tvlan_mapping.val[0] = vid;\n\t} else {\n\t\t \n\t\tvlan_mapping.index = idx;\n\t\tvlan_mapping.table = GSWIP_TABLE_VLAN_MAPPING;\n\t\terr = gswip_pce_table_entry_read(priv, &vlan_mapping);\n\t\tif (err) {\n\t\t\tdev_err(priv->dev, \"failed to read VLAN mapping: %d\\n\",\n\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tvlan_mapping.val[0] = vid;\n\t \n\tvlan_mapping.val[1] |= BIT(cpu_port);\n\tvlan_mapping.val[2] |= BIT(cpu_port);\n\tvlan_mapping.val[1] |= BIT(port);\n\tif (untagged)\n\t\tvlan_mapping.val[2] &= ~BIT(port);\n\telse\n\t\tvlan_mapping.val[2] |= BIT(port);\n\terr = gswip_pce_table_entry_write(priv, &vlan_mapping);\n\tif (err) {\n\t\tdev_err(priv->dev, \"failed to write VLAN mapping: %d\\n\", err);\n\t\t \n\t\tif (active_vlan_created)\n\t\t\tgswip_vlan_active_remove(priv, idx);\n\t\treturn err;\n\t}\n\n\tif (pvid)\n\t\tgswip_switch_w(priv, idx, GSWIP_PCE_DEFPVID(port));\n\n\treturn 0;\n}\n\nstatic int gswip_vlan_remove(struct gswip_priv *priv,\n\t\t\t     struct net_device *bridge, int port,\n\t\t\t     u16 vid, bool pvid, bool vlan_aware)\n{\n\tstruct gswip_pce_table_entry vlan_mapping = {0,};\n\tunsigned int max_ports = priv->hw_info->max_ports;\n\tunsigned int cpu_port = priv->hw_info->cpu_port;\n\tint idx = -1;\n\tint i;\n\tint err;\n\n\t \n\tfor (i = max_ports; i < ARRAY_SIZE(priv->vlans); i++) {\n\t\tif (priv->vlans[i].bridge == bridge &&\n\t\t    (!vlan_aware || priv->vlans[i].vid == vid)) {\n\t\t\tidx = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (idx == -1) {\n\t\tdev_err(priv->dev, \"bridge to leave does not exists\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tvlan_mapping.index = idx;\n\tvlan_mapping.table = GSWIP_TABLE_VLAN_MAPPING;\n\terr = gswip_pce_table_entry_read(priv, &vlan_mapping);\n\tif (err) {\n\t\tdev_err(priv->dev, \"failed to read VLAN mapping: %d\\n\",\terr);\n\t\treturn err;\n\t}\n\n\tvlan_mapping.val[1] &= ~BIT(port);\n\tvlan_mapping.val[2] &= ~BIT(port);\n\terr = gswip_pce_table_entry_write(priv, &vlan_mapping);\n\tif (err) {\n\t\tdev_err(priv->dev, \"failed to write VLAN mapping: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tif ((vlan_mapping.val[1] & ~BIT(cpu_port)) == 0) {\n\t\terr = gswip_vlan_active_remove(priv, idx);\n\t\tif (err) {\n\t\t\tdev_err(priv->dev, \"failed to write active VLAN: %d\\n\",\n\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tif (pvid)\n\t\tgswip_switch_w(priv, 0, GSWIP_PCE_DEFPVID(port));\n\n\treturn 0;\n}\n\nstatic int gswip_port_bridge_join(struct dsa_switch *ds, int port,\n\t\t\t\t  struct dsa_bridge bridge,\n\t\t\t\t  bool *tx_fwd_offload,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct net_device *br = bridge.dev;\n\tstruct gswip_priv *priv = ds->priv;\n\tint err;\n\n\t \n\tif (!br_vlan_enabled(br)) {\n\t\terr = gswip_vlan_add_unaware(priv, br, port);\n\t\tif (err)\n\t\t\treturn err;\n\t\tpriv->port_vlan_filter &= ~BIT(port);\n\t} else {\n\t\tpriv->port_vlan_filter |= BIT(port);\n\t}\n\treturn gswip_add_single_port_br(priv, port, false);\n}\n\nstatic void gswip_port_bridge_leave(struct dsa_switch *ds, int port,\n\t\t\t\t    struct dsa_bridge bridge)\n{\n\tstruct net_device *br = bridge.dev;\n\tstruct gswip_priv *priv = ds->priv;\n\n\tgswip_add_single_port_br(priv, port, true);\n\n\t \n\tif (!br_vlan_enabled(br))\n\t\tgswip_vlan_remove(priv, br, port, 0, true, false);\n}\n\nstatic int gswip_port_vlan_prepare(struct dsa_switch *ds, int port,\n\t\t\t\t   const struct switchdev_obj_port_vlan *vlan,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct net_device *bridge = dsa_port_bridge_dev_get(dsa_to_port(ds, port));\n\tstruct gswip_priv *priv = ds->priv;\n\tunsigned int max_ports = priv->hw_info->max_ports;\n\tint pos = max_ports;\n\tint i, idx = -1;\n\n\t \n\tif (!dsa_is_cpu_port(ds, port) && !bridge)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tfor (i = max_ports; i < ARRAY_SIZE(priv->vlans); i++) {\n\t\tif (priv->vlans[i].bridge == bridge &&\n\t\t    priv->vlans[i].vid == vlan->vid) {\n\t\t\tidx = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (idx == -1) {\n\t\t \n\t\tfor (; pos < ARRAY_SIZE(priv->vlans); pos++) {\n\t\t\tif (!priv->vlans[pos].bridge) {\n\t\t\t\tidx = pos;\n\t\t\t\tpos++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (idx == -1) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"No slot in VLAN table\");\n\t\t\treturn -ENOSPC;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int gswip_port_vlan_add(struct dsa_switch *ds, int port,\n\t\t\t       const struct switchdev_obj_port_vlan *vlan,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct net_device *bridge = dsa_port_bridge_dev_get(dsa_to_port(ds, port));\n\tstruct gswip_priv *priv = ds->priv;\n\tbool untagged = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;\n\tbool pvid = vlan->flags & BRIDGE_VLAN_INFO_PVID;\n\tint err;\n\n\terr = gswip_port_vlan_prepare(ds, port, vlan, extack);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (dsa_is_cpu_port(ds, port))\n\t\treturn 0;\n\n\treturn gswip_vlan_add_aware(priv, bridge, port, vlan->vid,\n\t\t\t\t    untagged, pvid);\n}\n\nstatic int gswip_port_vlan_del(struct dsa_switch *ds, int port,\n\t\t\t       const struct switchdev_obj_port_vlan *vlan)\n{\n\tstruct net_device *bridge = dsa_port_bridge_dev_get(dsa_to_port(ds, port));\n\tstruct gswip_priv *priv = ds->priv;\n\tbool pvid = vlan->flags & BRIDGE_VLAN_INFO_PVID;\n\n\t \n\tif (dsa_is_cpu_port(ds, port))\n\t\treturn 0;\n\n\treturn gswip_vlan_remove(priv, bridge, port, vlan->vid, pvid, true);\n}\n\nstatic void gswip_port_fast_age(struct dsa_switch *ds, int port)\n{\n\tstruct gswip_priv *priv = ds->priv;\n\tstruct gswip_pce_table_entry mac_bridge = {0,};\n\tint i;\n\tint err;\n\n\tfor (i = 0; i < 2048; i++) {\n\t\tmac_bridge.table = GSWIP_TABLE_MAC_BRIDGE;\n\t\tmac_bridge.index = i;\n\n\t\terr = gswip_pce_table_entry_read(priv, &mac_bridge);\n\t\tif (err) {\n\t\t\tdev_err(priv->dev, \"failed to read mac bridge: %d\\n\",\n\t\t\t\terr);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!mac_bridge.valid)\n\t\t\tcontinue;\n\n\t\tif (mac_bridge.val[1] & GSWIP_TABLE_MAC_BRIDGE_STATIC)\n\t\t\tcontinue;\n\n\t\tif (((mac_bridge.val[0] & GENMASK(7, 4)) >> 4) != port)\n\t\t\tcontinue;\n\n\t\tmac_bridge.valid = false;\n\t\terr = gswip_pce_table_entry_write(priv, &mac_bridge);\n\t\tif (err) {\n\t\t\tdev_err(priv->dev, \"failed to write mac bridge: %d\\n\",\n\t\t\t\terr);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void gswip_port_stp_state_set(struct dsa_switch *ds, int port, u8 state)\n{\n\tstruct gswip_priv *priv = ds->priv;\n\tu32 stp_state;\n\n\tswitch (state) {\n\tcase BR_STATE_DISABLED:\n\t\tgswip_switch_mask(priv, GSWIP_SDMA_PCTRL_EN, 0,\n\t\t\t\t  GSWIP_SDMA_PCTRLp(port));\n\t\treturn;\n\tcase BR_STATE_BLOCKING:\n\tcase BR_STATE_LISTENING:\n\t\tstp_state = GSWIP_PCE_PCTRL_0_PSTATE_LISTEN;\n\t\tbreak;\n\tcase BR_STATE_LEARNING:\n\t\tstp_state = GSWIP_PCE_PCTRL_0_PSTATE_LEARNING;\n\t\tbreak;\n\tcase BR_STATE_FORWARDING:\n\t\tstp_state = GSWIP_PCE_PCTRL_0_PSTATE_FORWARDING;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(priv->dev, \"invalid STP state: %d\\n\", state);\n\t\treturn;\n\t}\n\n\tgswip_switch_mask(priv, 0, GSWIP_SDMA_PCTRL_EN,\n\t\t\t  GSWIP_SDMA_PCTRLp(port));\n\tgswip_switch_mask(priv, GSWIP_PCE_PCTRL_0_PSTATE_MASK, stp_state,\n\t\t\t  GSWIP_PCE_PCTRL_0p(port));\n}\n\nstatic int gswip_port_fdb(struct dsa_switch *ds, int port,\n\t\t\t  const unsigned char *addr, u16 vid, bool add)\n{\n\tstruct net_device *bridge = dsa_port_bridge_dev_get(dsa_to_port(ds, port));\n\tstruct gswip_priv *priv = ds->priv;\n\tstruct gswip_pce_table_entry mac_bridge = {0,};\n\tunsigned int max_ports = priv->hw_info->max_ports;\n\tint fid = -1;\n\tint i;\n\tint err;\n\n\tif (!bridge)\n\t\treturn -EINVAL;\n\n\tfor (i = max_ports; i < ARRAY_SIZE(priv->vlans); i++) {\n\t\tif (priv->vlans[i].bridge == bridge) {\n\t\t\tfid = priv->vlans[i].fid;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (fid == -1) {\n\t\tdev_err(priv->dev, \"Port not part of a bridge\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmac_bridge.table = GSWIP_TABLE_MAC_BRIDGE;\n\tmac_bridge.key_mode = true;\n\tmac_bridge.key[0] = addr[5] | (addr[4] << 8);\n\tmac_bridge.key[1] = addr[3] | (addr[2] << 8);\n\tmac_bridge.key[2] = addr[1] | (addr[0] << 8);\n\tmac_bridge.key[3] = fid;\n\tmac_bridge.val[0] = add ? BIT(port) : 0;  \n\tmac_bridge.val[1] = GSWIP_TABLE_MAC_BRIDGE_STATIC;\n\tmac_bridge.valid = add;\n\n\terr = gswip_pce_table_entry_write(priv, &mac_bridge);\n\tif (err)\n\t\tdev_err(priv->dev, \"failed to write mac bridge: %d\\n\", err);\n\n\treturn err;\n}\n\nstatic int gswip_port_fdb_add(struct dsa_switch *ds, int port,\n\t\t\t      const unsigned char *addr, u16 vid,\n\t\t\t      struct dsa_db db)\n{\n\treturn gswip_port_fdb(ds, port, addr, vid, true);\n}\n\nstatic int gswip_port_fdb_del(struct dsa_switch *ds, int port,\n\t\t\t      const unsigned char *addr, u16 vid,\n\t\t\t      struct dsa_db db)\n{\n\treturn gswip_port_fdb(ds, port, addr, vid, false);\n}\n\nstatic int gswip_port_fdb_dump(struct dsa_switch *ds, int port,\n\t\t\t       dsa_fdb_dump_cb_t *cb, void *data)\n{\n\tstruct gswip_priv *priv = ds->priv;\n\tstruct gswip_pce_table_entry mac_bridge = {0,};\n\tunsigned char addr[6];\n\tint i;\n\tint err;\n\n\tfor (i = 0; i < 2048; i++) {\n\t\tmac_bridge.table = GSWIP_TABLE_MAC_BRIDGE;\n\t\tmac_bridge.index = i;\n\n\t\terr = gswip_pce_table_entry_read(priv, &mac_bridge);\n\t\tif (err) {\n\t\t\tdev_err(priv->dev,\n\t\t\t\t\"failed to read mac bridge entry %d: %d\\n\",\n\t\t\t\ti, err);\n\t\t\treturn err;\n\t\t}\n\n\t\tif (!mac_bridge.valid)\n\t\t\tcontinue;\n\n\t\taddr[5] = mac_bridge.key[0] & 0xff;\n\t\taddr[4] = (mac_bridge.key[0] >> 8) & 0xff;\n\t\taddr[3] = mac_bridge.key[1] & 0xff;\n\t\taddr[2] = (mac_bridge.key[1] >> 8) & 0xff;\n\t\taddr[1] = mac_bridge.key[2] & 0xff;\n\t\taddr[0] = (mac_bridge.key[2] >> 8) & 0xff;\n\t\tif (mac_bridge.val[1] & GSWIP_TABLE_MAC_BRIDGE_STATIC) {\n\t\t\tif (mac_bridge.val[0] & BIT(port)) {\n\t\t\t\terr = cb(addr, 0, true, data);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t} else {\n\t\t\tif (((mac_bridge.val[0] & GENMASK(7, 4)) >> 4) == port) {\n\t\t\t\terr = cb(addr, 0, false, data);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int gswip_port_max_mtu(struct dsa_switch *ds, int port)\n{\n\t \n\treturn GSWIP_MAX_PACKET_LENGTH - VLAN_ETH_HLEN - ETH_FCS_LEN;\n}\n\nstatic int gswip_port_change_mtu(struct dsa_switch *ds, int port, int new_mtu)\n{\n\tstruct gswip_priv *priv = ds->priv;\n\tint cpu_port = priv->hw_info->cpu_port;\n\n\t \n\tif (port == cpu_port) {\n\t\tnew_mtu += 8;\n\t\tgswip_switch_w(priv, VLAN_ETH_HLEN + new_mtu + ETH_FCS_LEN,\n\t\t\t       GSWIP_MAC_FLEN);\n\t}\n\n\t \n\tif (new_mtu != ETH_DATA_LEN)\n\t\tgswip_switch_mask(priv, 0, GSWIP_MAC_CTRL_2_MLEN,\n\t\t\t\t  GSWIP_MAC_CTRL_2p(port));\n\telse\n\t\tgswip_switch_mask(priv, GSWIP_MAC_CTRL_2_MLEN, 0,\n\t\t\t\t  GSWIP_MAC_CTRL_2p(port));\n\n\treturn 0;\n}\n\nstatic void gswip_xrx200_phylink_get_caps(struct dsa_switch *ds, int port,\n\t\t\t\t\t  struct phylink_config *config)\n{\n\tswitch (port) {\n\tcase 0:\n\tcase 1:\n\t\tphy_interface_set_rgmii(config->supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_MII,\n\t\t\t  config->supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_REVMII,\n\t\t\t  config->supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_RMII,\n\t\t\t  config->supported_interfaces);\n\t\tbreak;\n\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\t\t__set_bit(PHY_INTERFACE_MODE_INTERNAL,\n\t\t\t  config->supported_interfaces);\n\t\tbreak;\n\n\tcase 5:\n\t\tphy_interface_set_rgmii(config->supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_INTERNAL,\n\t\t\t  config->supported_interfaces);\n\t\tbreak;\n\t}\n\n\tconfig->mac_capabilities = MAC_ASYM_PAUSE | MAC_SYM_PAUSE |\n\t\tMAC_10 | MAC_100 | MAC_1000;\n}\n\nstatic void gswip_xrx300_phylink_get_caps(struct dsa_switch *ds, int port,\n\t\t\t\t\t  struct phylink_config *config)\n{\n\tswitch (port) {\n\tcase 0:\n\t\tphy_interface_set_rgmii(config->supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_GMII,\n\t\t\t  config->supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_RMII,\n\t\t\t  config->supported_interfaces);\n\t\tbreak;\n\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\t\t__set_bit(PHY_INTERFACE_MODE_INTERNAL,\n\t\t\t  config->supported_interfaces);\n\t\tbreak;\n\n\tcase 5:\n\t\tphy_interface_set_rgmii(config->supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_INTERNAL,\n\t\t\t  config->supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_RMII,\n\t\t\t  config->supported_interfaces);\n\t\tbreak;\n\t}\n\n\tconfig->mac_capabilities = MAC_ASYM_PAUSE | MAC_SYM_PAUSE |\n\t\tMAC_10 | MAC_100 | MAC_1000;\n}\n\nstatic void gswip_port_set_link(struct gswip_priv *priv, int port, bool link)\n{\n\tu32 mdio_phy;\n\n\tif (link)\n\t\tmdio_phy = GSWIP_MDIO_PHY_LINK_UP;\n\telse\n\t\tmdio_phy = GSWIP_MDIO_PHY_LINK_DOWN;\n\n\tgswip_mdio_mask(priv, GSWIP_MDIO_PHY_LINK_MASK, mdio_phy,\n\t\t\tGSWIP_MDIO_PHYp(port));\n}\n\nstatic void gswip_port_set_speed(struct gswip_priv *priv, int port, int speed,\n\t\t\t\t phy_interface_t interface)\n{\n\tu32 mdio_phy = 0, mii_cfg = 0, mac_ctrl_0 = 0;\n\n\tswitch (speed) {\n\tcase SPEED_10:\n\t\tmdio_phy = GSWIP_MDIO_PHY_SPEED_M10;\n\n\t\tif (interface == PHY_INTERFACE_MODE_RMII)\n\t\t\tmii_cfg = GSWIP_MII_CFG_RATE_M50;\n\t\telse\n\t\t\tmii_cfg = GSWIP_MII_CFG_RATE_M2P5;\n\n\t\tmac_ctrl_0 = GSWIP_MAC_CTRL_0_GMII_MII;\n\t\tbreak;\n\n\tcase SPEED_100:\n\t\tmdio_phy = GSWIP_MDIO_PHY_SPEED_M100;\n\n\t\tif (interface == PHY_INTERFACE_MODE_RMII)\n\t\t\tmii_cfg = GSWIP_MII_CFG_RATE_M50;\n\t\telse\n\t\t\tmii_cfg = GSWIP_MII_CFG_RATE_M25;\n\n\t\tmac_ctrl_0 = GSWIP_MAC_CTRL_0_GMII_MII;\n\t\tbreak;\n\n\tcase SPEED_1000:\n\t\tmdio_phy = GSWIP_MDIO_PHY_SPEED_G1;\n\n\t\tmii_cfg = GSWIP_MII_CFG_RATE_M125;\n\n\t\tmac_ctrl_0 = GSWIP_MAC_CTRL_0_GMII_RGMII;\n\t\tbreak;\n\t}\n\n\tgswip_mdio_mask(priv, GSWIP_MDIO_PHY_SPEED_MASK, mdio_phy,\n\t\t\tGSWIP_MDIO_PHYp(port));\n\tgswip_mii_mask_cfg(priv, GSWIP_MII_CFG_RATE_MASK, mii_cfg, port);\n\tgswip_switch_mask(priv, GSWIP_MAC_CTRL_0_GMII_MASK, mac_ctrl_0,\n\t\t\t  GSWIP_MAC_CTRL_0p(port));\n}\n\nstatic void gswip_port_set_duplex(struct gswip_priv *priv, int port, int duplex)\n{\n\tu32 mac_ctrl_0, mdio_phy;\n\n\tif (duplex == DUPLEX_FULL) {\n\t\tmac_ctrl_0 = GSWIP_MAC_CTRL_0_FDUP_EN;\n\t\tmdio_phy = GSWIP_MDIO_PHY_FDUP_EN;\n\t} else {\n\t\tmac_ctrl_0 = GSWIP_MAC_CTRL_0_FDUP_DIS;\n\t\tmdio_phy = GSWIP_MDIO_PHY_FDUP_DIS;\n\t}\n\n\tgswip_switch_mask(priv, GSWIP_MAC_CTRL_0_FDUP_MASK, mac_ctrl_0,\n\t\t\t  GSWIP_MAC_CTRL_0p(port));\n\tgswip_mdio_mask(priv, GSWIP_MDIO_PHY_FDUP_MASK, mdio_phy,\n\t\t\tGSWIP_MDIO_PHYp(port));\n}\n\nstatic void gswip_port_set_pause(struct gswip_priv *priv, int port,\n\t\t\t\t bool tx_pause, bool rx_pause)\n{\n\tu32 mac_ctrl_0, mdio_phy;\n\n\tif (tx_pause && rx_pause) {\n\t\tmac_ctrl_0 = GSWIP_MAC_CTRL_0_FCON_RXTX;\n\t\tmdio_phy = GSWIP_MDIO_PHY_FCONTX_EN |\n\t\t\t   GSWIP_MDIO_PHY_FCONRX_EN;\n\t} else if (tx_pause) {\n\t\tmac_ctrl_0 = GSWIP_MAC_CTRL_0_FCON_TX;\n\t\tmdio_phy = GSWIP_MDIO_PHY_FCONTX_EN |\n\t\t\t   GSWIP_MDIO_PHY_FCONRX_DIS;\n\t} else if (rx_pause) {\n\t\tmac_ctrl_0 = GSWIP_MAC_CTRL_0_FCON_RX;\n\t\tmdio_phy = GSWIP_MDIO_PHY_FCONTX_DIS |\n\t\t\t   GSWIP_MDIO_PHY_FCONRX_EN;\n\t} else {\n\t\tmac_ctrl_0 = GSWIP_MAC_CTRL_0_FCON_NONE;\n\t\tmdio_phy = GSWIP_MDIO_PHY_FCONTX_DIS |\n\t\t\t   GSWIP_MDIO_PHY_FCONRX_DIS;\n\t}\n\n\tgswip_switch_mask(priv, GSWIP_MAC_CTRL_0_FCON_MASK,\n\t\t\t  mac_ctrl_0, GSWIP_MAC_CTRL_0p(port));\n\tgswip_mdio_mask(priv,\n\t\t\tGSWIP_MDIO_PHY_FCONTX_MASK |\n\t\t\tGSWIP_MDIO_PHY_FCONRX_MASK,\n\t\t\tmdio_phy, GSWIP_MDIO_PHYp(port));\n}\n\nstatic void gswip_phylink_mac_config(struct dsa_switch *ds, int port,\n\t\t\t\t     unsigned int mode,\n\t\t\t\t     const struct phylink_link_state *state)\n{\n\tstruct gswip_priv *priv = ds->priv;\n\tu32 miicfg = 0;\n\n\tmiicfg |= GSWIP_MII_CFG_LDCLKDIS;\n\n\tswitch (state->interface) {\n\tcase PHY_INTERFACE_MODE_MII:\n\tcase PHY_INTERFACE_MODE_INTERNAL:\n\t\tmiicfg |= GSWIP_MII_CFG_MODE_MIIM;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_REVMII:\n\t\tmiicfg |= GSWIP_MII_CFG_MODE_MIIP;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tmiicfg |= GSWIP_MII_CFG_MODE_RMIIM;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tmiicfg |= GSWIP_MII_CFG_MODE_RGMII;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_GMII:\n\t\tmiicfg |= GSWIP_MII_CFG_MODE_GMII;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(ds->dev,\n\t\t\t\"Unsupported interface: %d\\n\", state->interface);\n\t\treturn;\n\t}\n\n\tgswip_mii_mask_cfg(priv,\n\t\t\t   GSWIP_MII_CFG_MODE_MASK | GSWIP_MII_CFG_RMII_CLK |\n\t\t\t   GSWIP_MII_CFG_RGMII_IBS | GSWIP_MII_CFG_LDCLKDIS,\n\t\t\t   miicfg, port);\n\n\tswitch (state->interface) {\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\t\tgswip_mii_mask_pcdu(priv, GSWIP_MII_PCDU_TXDLY_MASK |\n\t\t\t\t\t  GSWIP_MII_PCDU_RXDLY_MASK, 0, port);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\tgswip_mii_mask_pcdu(priv, GSWIP_MII_PCDU_RXDLY_MASK, 0, port);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tgswip_mii_mask_pcdu(priv, GSWIP_MII_PCDU_TXDLY_MASK, 0, port);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void gswip_phylink_mac_link_down(struct dsa_switch *ds, int port,\n\t\t\t\t\tunsigned int mode,\n\t\t\t\t\tphy_interface_t interface)\n{\n\tstruct gswip_priv *priv = ds->priv;\n\n\tgswip_mii_mask_cfg(priv, GSWIP_MII_CFG_EN, 0, port);\n\n\tif (!dsa_is_cpu_port(ds, port))\n\t\tgswip_port_set_link(priv, port, false);\n}\n\nstatic void gswip_phylink_mac_link_up(struct dsa_switch *ds, int port,\n\t\t\t\t      unsigned int mode,\n\t\t\t\t      phy_interface_t interface,\n\t\t\t\t      struct phy_device *phydev,\n\t\t\t\t      int speed, int duplex,\n\t\t\t\t      bool tx_pause, bool rx_pause)\n{\n\tstruct gswip_priv *priv = ds->priv;\n\n\tif (!dsa_is_cpu_port(ds, port)) {\n\t\tgswip_port_set_link(priv, port, true);\n\t\tgswip_port_set_speed(priv, port, speed, interface);\n\t\tgswip_port_set_duplex(priv, port, duplex);\n\t\tgswip_port_set_pause(priv, port, tx_pause, rx_pause);\n\t}\n\n\tgswip_mii_mask_cfg(priv, 0, GSWIP_MII_CFG_EN, port);\n}\n\nstatic void gswip_get_strings(struct dsa_switch *ds, int port, u32 stringset,\n\t\t\t      uint8_t *data)\n{\n\tint i;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(gswip_rmon_cnt); i++)\n\t\tstrncpy(data + i * ETH_GSTRING_LEN, gswip_rmon_cnt[i].name,\n\t\t\tETH_GSTRING_LEN);\n}\n\nstatic u32 gswip_bcm_ram_entry_read(struct gswip_priv *priv, u32 table,\n\t\t\t\t    u32 index)\n{\n\tu32 result;\n\tint err;\n\n\tgswip_switch_w(priv, index, GSWIP_BM_RAM_ADDR);\n\tgswip_switch_mask(priv, GSWIP_BM_RAM_CTRL_ADDR_MASK |\n\t\t\t\tGSWIP_BM_RAM_CTRL_OPMOD,\n\t\t\t      table | GSWIP_BM_RAM_CTRL_BAS,\n\t\t\t      GSWIP_BM_RAM_CTRL);\n\n\terr = gswip_switch_r_timeout(priv, GSWIP_BM_RAM_CTRL,\n\t\t\t\t     GSWIP_BM_RAM_CTRL_BAS);\n\tif (err) {\n\t\tdev_err(priv->dev, \"timeout while reading table: %u, index: %u\",\n\t\t\ttable, index);\n\t\treturn 0;\n\t}\n\n\tresult = gswip_switch_r(priv, GSWIP_BM_RAM_VAL(0));\n\tresult |= gswip_switch_r(priv, GSWIP_BM_RAM_VAL(1)) << 16;\n\n\treturn result;\n}\n\nstatic void gswip_get_ethtool_stats(struct dsa_switch *ds, int port,\n\t\t\t\t    uint64_t *data)\n{\n\tstruct gswip_priv *priv = ds->priv;\n\tconst struct gswip_rmon_cnt_desc *rmon_cnt;\n\tint i;\n\tu64 high;\n\n\tfor (i = 0; i < ARRAY_SIZE(gswip_rmon_cnt); i++) {\n\t\trmon_cnt = &gswip_rmon_cnt[i];\n\n\t\tdata[i] = gswip_bcm_ram_entry_read(priv, port,\n\t\t\t\t\t\t   rmon_cnt->offset);\n\t\tif (rmon_cnt->size == 2) {\n\t\t\thigh = gswip_bcm_ram_entry_read(priv, port,\n\t\t\t\t\t\t\trmon_cnt->offset + 1);\n\t\t\tdata[i] |= high << 32;\n\t\t}\n\t}\n}\n\nstatic int gswip_get_sset_count(struct dsa_switch *ds, int port, int sset)\n{\n\tif (sset != ETH_SS_STATS)\n\t\treturn 0;\n\n\treturn ARRAY_SIZE(gswip_rmon_cnt);\n}\n\nstatic const struct dsa_switch_ops gswip_xrx200_switch_ops = {\n\t.get_tag_protocol\t= gswip_get_tag_protocol,\n\t.setup\t\t\t= gswip_setup,\n\t.port_enable\t\t= gswip_port_enable,\n\t.port_disable\t\t= gswip_port_disable,\n\t.port_bridge_join\t= gswip_port_bridge_join,\n\t.port_bridge_leave\t= gswip_port_bridge_leave,\n\t.port_fast_age\t\t= gswip_port_fast_age,\n\t.port_vlan_filtering\t= gswip_port_vlan_filtering,\n\t.port_vlan_add\t\t= gswip_port_vlan_add,\n\t.port_vlan_del\t\t= gswip_port_vlan_del,\n\t.port_stp_state_set\t= gswip_port_stp_state_set,\n\t.port_fdb_add\t\t= gswip_port_fdb_add,\n\t.port_fdb_del\t\t= gswip_port_fdb_del,\n\t.port_fdb_dump\t\t= gswip_port_fdb_dump,\n\t.port_change_mtu\t= gswip_port_change_mtu,\n\t.port_max_mtu\t\t= gswip_port_max_mtu,\n\t.phylink_get_caps\t= gswip_xrx200_phylink_get_caps,\n\t.phylink_mac_config\t= gswip_phylink_mac_config,\n\t.phylink_mac_link_down\t= gswip_phylink_mac_link_down,\n\t.phylink_mac_link_up\t= gswip_phylink_mac_link_up,\n\t.get_strings\t\t= gswip_get_strings,\n\t.get_ethtool_stats\t= gswip_get_ethtool_stats,\n\t.get_sset_count\t\t= gswip_get_sset_count,\n};\n\nstatic const struct dsa_switch_ops gswip_xrx300_switch_ops = {\n\t.get_tag_protocol\t= gswip_get_tag_protocol,\n\t.setup\t\t\t= gswip_setup,\n\t.port_enable\t\t= gswip_port_enable,\n\t.port_disable\t\t= gswip_port_disable,\n\t.port_bridge_join\t= gswip_port_bridge_join,\n\t.port_bridge_leave\t= gswip_port_bridge_leave,\n\t.port_fast_age\t\t= gswip_port_fast_age,\n\t.port_vlan_filtering\t= gswip_port_vlan_filtering,\n\t.port_vlan_add\t\t= gswip_port_vlan_add,\n\t.port_vlan_del\t\t= gswip_port_vlan_del,\n\t.port_stp_state_set\t= gswip_port_stp_state_set,\n\t.port_fdb_add\t\t= gswip_port_fdb_add,\n\t.port_fdb_del\t\t= gswip_port_fdb_del,\n\t.port_fdb_dump\t\t= gswip_port_fdb_dump,\n\t.port_change_mtu\t= gswip_port_change_mtu,\n\t.port_max_mtu\t\t= gswip_port_max_mtu,\n\t.phylink_get_caps\t= gswip_xrx300_phylink_get_caps,\n\t.phylink_mac_config\t= gswip_phylink_mac_config,\n\t.phylink_mac_link_down\t= gswip_phylink_mac_link_down,\n\t.phylink_mac_link_up\t= gswip_phylink_mac_link_up,\n\t.get_strings\t\t= gswip_get_strings,\n\t.get_ethtool_stats\t= gswip_get_ethtool_stats,\n\t.get_sset_count\t\t= gswip_get_sset_count,\n};\n\nstatic const struct xway_gphy_match_data xrx200a1x_gphy_data = {\n\t.fe_firmware_name = \"lantiq/xrx200_phy22f_a14.bin\",\n\t.ge_firmware_name = \"lantiq/xrx200_phy11g_a14.bin\",\n};\n\nstatic const struct xway_gphy_match_data xrx200a2x_gphy_data = {\n\t.fe_firmware_name = \"lantiq/xrx200_phy22f_a22.bin\",\n\t.ge_firmware_name = \"lantiq/xrx200_phy11g_a22.bin\",\n};\n\nstatic const struct xway_gphy_match_data xrx300_gphy_data = {\n\t.fe_firmware_name = \"lantiq/xrx300_phy22f_a21.bin\",\n\t.ge_firmware_name = \"lantiq/xrx300_phy11g_a21.bin\",\n};\n\nstatic const struct of_device_id xway_gphy_match[] __maybe_unused = {\n\t{ .compatible = \"lantiq,xrx200-gphy-fw\", .data = NULL },\n\t{ .compatible = \"lantiq,xrx200a1x-gphy-fw\", .data = &xrx200a1x_gphy_data },\n\t{ .compatible = \"lantiq,xrx200a2x-gphy-fw\", .data = &xrx200a2x_gphy_data },\n\t{ .compatible = \"lantiq,xrx300-gphy-fw\", .data = &xrx300_gphy_data },\n\t{ .compatible = \"lantiq,xrx330-gphy-fw\", .data = &xrx300_gphy_data },\n\t{},\n};\n\nstatic int gswip_gphy_fw_load(struct gswip_priv *priv, struct gswip_gphy_fw *gphy_fw)\n{\n\tstruct device *dev = priv->dev;\n\tconst struct firmware *fw;\n\tvoid *fw_addr;\n\tdma_addr_t dma_addr;\n\tdma_addr_t dev_addr;\n\tsize_t size;\n\tint ret;\n\n\tret = clk_prepare_enable(gphy_fw->clk_gate);\n\tif (ret)\n\t\treturn ret;\n\n\treset_control_assert(gphy_fw->reset);\n\n\t \n\tmsleep(200);\n\n\tret = request_firmware(&fw, gphy_fw->fw_name, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to load firmware: %s, error: %i\\n\",\n\t\t\tgphy_fw->fw_name, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tsize = fw->size + XRX200_GPHY_FW_ALIGN;\n\n\tfw_addr = dmam_alloc_coherent(dev, size, &dma_addr, GFP_KERNEL);\n\tif (fw_addr) {\n\t\tfw_addr = PTR_ALIGN(fw_addr, XRX200_GPHY_FW_ALIGN);\n\t\tdev_addr = ALIGN(dma_addr, XRX200_GPHY_FW_ALIGN);\n\t\tmemcpy(fw_addr, fw->data, fw->size);\n\t} else {\n\t\tdev_err(dev, \"failed to alloc firmware memory\\n\");\n\t\trelease_firmware(fw);\n\t\treturn -ENOMEM;\n\t}\n\n\trelease_firmware(fw);\n\n\tret = regmap_write(priv->rcu_regmap, gphy_fw->fw_addr_offset, dev_addr);\n\tif (ret)\n\t\treturn ret;\n\n\treset_control_deassert(gphy_fw->reset);\n\n\treturn ret;\n}\n\nstatic int gswip_gphy_fw_probe(struct gswip_priv *priv,\n\t\t\t       struct gswip_gphy_fw *gphy_fw,\n\t\t\t       struct device_node *gphy_fw_np, int i)\n{\n\tstruct device *dev = priv->dev;\n\tu32 gphy_mode;\n\tint ret;\n\tchar gphyname[10];\n\n\tsnprintf(gphyname, sizeof(gphyname), \"gphy%d\", i);\n\n\tgphy_fw->clk_gate = devm_clk_get(dev, gphyname);\n\tif (IS_ERR(gphy_fw->clk_gate)) {\n\t\tdev_err(dev, \"Failed to lookup gate clock\\n\");\n\t\treturn PTR_ERR(gphy_fw->clk_gate);\n\t}\n\n\tret = of_property_read_u32(gphy_fw_np, \"reg\", &gphy_fw->fw_addr_offset);\n\tif (ret)\n\t\treturn ret;\n\n\tret = of_property_read_u32(gphy_fw_np, \"lantiq,gphy-mode\", &gphy_mode);\n\t \n\tif (ret)\n\t\tgphy_mode = GPHY_MODE_GE;\n\n\tswitch (gphy_mode) {\n\tcase GPHY_MODE_FE:\n\t\tgphy_fw->fw_name = priv->gphy_fw_name_cfg->fe_firmware_name;\n\t\tbreak;\n\tcase GPHY_MODE_GE:\n\t\tgphy_fw->fw_name = priv->gphy_fw_name_cfg->ge_firmware_name;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unknown GPHY mode %d\\n\", gphy_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tgphy_fw->reset = of_reset_control_array_get_exclusive(gphy_fw_np);\n\tif (IS_ERR(gphy_fw->reset))\n\t\treturn dev_err_probe(dev, PTR_ERR(gphy_fw->reset),\n\t\t\t\t     \"Failed to lookup gphy reset\\n\");\n\n\treturn gswip_gphy_fw_load(priv, gphy_fw);\n}\n\nstatic void gswip_gphy_fw_remove(struct gswip_priv *priv,\n\t\t\t\t struct gswip_gphy_fw *gphy_fw)\n{\n\tint ret;\n\n\t \n\tif (!gphy_fw->fw_name)\n\t\treturn;\n\n\tret = regmap_write(priv->rcu_regmap, gphy_fw->fw_addr_offset, 0);\n\tif (ret)\n\t\tdev_err(priv->dev, \"can not reset GPHY FW pointer\");\n\n\tclk_disable_unprepare(gphy_fw->clk_gate);\n\n\treset_control_put(gphy_fw->reset);\n}\n\nstatic int gswip_gphy_fw_list(struct gswip_priv *priv,\n\t\t\t      struct device_node *gphy_fw_list_np, u32 version)\n{\n\tstruct device *dev = priv->dev;\n\tstruct device_node *gphy_fw_np;\n\tconst struct of_device_id *match;\n\tint err;\n\tint i = 0;\n\n\t \n\tif (of_device_is_compatible(gphy_fw_list_np, \"lantiq,xrx200-gphy-fw\")) {\n\t\tswitch (version) {\n\t\tcase GSWIP_VERSION_2_0:\n\t\t\tpriv->gphy_fw_name_cfg = &xrx200a1x_gphy_data;\n\t\t\tbreak;\n\t\tcase GSWIP_VERSION_2_1:\n\t\t\tpriv->gphy_fw_name_cfg = &xrx200a2x_gphy_data;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"unknown GSWIP version: 0x%x\", version);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tmatch = of_match_node(xway_gphy_match, gphy_fw_list_np);\n\tif (match && match->data)\n\t\tpriv->gphy_fw_name_cfg = match->data;\n\n\tif (!priv->gphy_fw_name_cfg) {\n\t\tdev_err(dev, \"GPHY compatible type not supported\");\n\t\treturn -ENOENT;\n\t}\n\n\tpriv->num_gphy_fw = of_get_available_child_count(gphy_fw_list_np);\n\tif (!priv->num_gphy_fw)\n\t\treturn -ENOENT;\n\n\tpriv->rcu_regmap = syscon_regmap_lookup_by_phandle(gphy_fw_list_np,\n\t\t\t\t\t\t\t   \"lantiq,rcu\");\n\tif (IS_ERR(priv->rcu_regmap))\n\t\treturn PTR_ERR(priv->rcu_regmap);\n\n\tpriv->gphy_fw = devm_kmalloc_array(dev, priv->num_gphy_fw,\n\t\t\t\t\t   sizeof(*priv->gphy_fw),\n\t\t\t\t\t   GFP_KERNEL | __GFP_ZERO);\n\tif (!priv->gphy_fw)\n\t\treturn -ENOMEM;\n\n\tfor_each_available_child_of_node(gphy_fw_list_np, gphy_fw_np) {\n\t\terr = gswip_gphy_fw_probe(priv, &priv->gphy_fw[i],\n\t\t\t\t\t  gphy_fw_np, i);\n\t\tif (err) {\n\t\t\tof_node_put(gphy_fw_np);\n\t\t\tgoto remove_gphy;\n\t\t}\n\t\ti++;\n\t}\n\n\t \n\tmsleep(300);\n\n\treturn 0;\n\nremove_gphy:\n\tfor (i = 0; i < priv->num_gphy_fw; i++)\n\t\tgswip_gphy_fw_remove(priv, &priv->gphy_fw[i]);\n\treturn err;\n}\n\nstatic int gswip_probe(struct platform_device *pdev)\n{\n\tstruct gswip_priv *priv;\n\tstruct device_node *np, *mdio_np, *gphy_fw_np;\n\tstruct device *dev = &pdev->dev;\n\tint err;\n\tint i;\n\tu32 version;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->gswip = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->gswip))\n\t\treturn PTR_ERR(priv->gswip);\n\n\tpriv->mdio = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(priv->mdio))\n\t\treturn PTR_ERR(priv->mdio);\n\n\tpriv->mii = devm_platform_ioremap_resource(pdev, 2);\n\tif (IS_ERR(priv->mii))\n\t\treturn PTR_ERR(priv->mii);\n\n\tpriv->hw_info = of_device_get_match_data(dev);\n\tif (!priv->hw_info)\n\t\treturn -EINVAL;\n\n\tpriv->ds = devm_kzalloc(dev, sizeof(*priv->ds), GFP_KERNEL);\n\tif (!priv->ds)\n\t\treturn -ENOMEM;\n\n\tpriv->ds->dev = dev;\n\tpriv->ds->num_ports = priv->hw_info->max_ports;\n\tpriv->ds->priv = priv;\n\tpriv->ds->ops = priv->hw_info->ops;\n\tpriv->dev = dev;\n\tmutex_init(&priv->pce_table_lock);\n\tversion = gswip_switch_r(priv, GSWIP_VERSION);\n\n\tnp = dev->of_node;\n\tswitch (version) {\n\tcase GSWIP_VERSION_2_0:\n\tcase GSWIP_VERSION_2_1:\n\t\tif (!of_device_is_compatible(np, \"lantiq,xrx200-gswip\"))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase GSWIP_VERSION_2_2:\n\tcase GSWIP_VERSION_2_2_ETC:\n\t\tif (!of_device_is_compatible(np, \"lantiq,xrx300-gswip\") &&\n\t\t    !of_device_is_compatible(np, \"lantiq,xrx330-gswip\"))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unknown GSWIP version: 0x%x\", version);\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tgphy_fw_np = of_get_compatible_child(dev->of_node, \"lantiq,gphy-fw\");\n\tif (gphy_fw_np) {\n\t\terr = gswip_gphy_fw_list(priv, gphy_fw_np, version);\n\t\tof_node_put(gphy_fw_np);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"gphy fw probe failed\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tmdio_np = of_get_compatible_child(dev->of_node, \"lantiq,xrx200-mdio\");\n\tif (mdio_np) {\n\t\terr = gswip_mdio(priv, mdio_np);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"mdio probe failed\\n\");\n\t\t\tgoto put_mdio_node;\n\t\t}\n\t}\n\n\terr = dsa_register_switch(priv->ds);\n\tif (err) {\n\t\tdev_err(dev, \"dsa switch register failed: %i\\n\", err);\n\t\tgoto mdio_bus;\n\t}\n\tif (!dsa_is_cpu_port(priv->ds, priv->hw_info->cpu_port)) {\n\t\tdev_err(dev, \"wrong CPU port defined, HW only supports port: %i\",\n\t\t\tpriv->hw_info->cpu_port);\n\t\terr = -EINVAL;\n\t\tgoto disable_switch;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tdev_info(dev, \"probed GSWIP version %lx mod %lx\\n\",\n\t\t (version & GSWIP_VERSION_REV_MASK) >> GSWIP_VERSION_REV_SHIFT,\n\t\t (version & GSWIP_VERSION_MOD_MASK) >> GSWIP_VERSION_MOD_SHIFT);\n\treturn 0;\n\ndisable_switch:\n\tgswip_mdio_mask(priv, GSWIP_MDIO_GLOB_ENABLE, 0, GSWIP_MDIO_GLOB);\n\tdsa_unregister_switch(priv->ds);\nmdio_bus:\n\tif (mdio_np) {\n\t\tmdiobus_unregister(priv->ds->slave_mii_bus);\n\t\tmdiobus_free(priv->ds->slave_mii_bus);\n\t}\nput_mdio_node:\n\tof_node_put(mdio_np);\n\tfor (i = 0; i < priv->num_gphy_fw; i++)\n\t\tgswip_gphy_fw_remove(priv, &priv->gphy_fw[i]);\n\treturn err;\n}\n\nstatic int gswip_remove(struct platform_device *pdev)\n{\n\tstruct gswip_priv *priv = platform_get_drvdata(pdev);\n\tint i;\n\n\tif (!priv)\n\t\treturn 0;\n\n\t \n\tgswip_mdio_mask(priv, GSWIP_MDIO_GLOB_ENABLE, 0, GSWIP_MDIO_GLOB);\n\n\tdsa_unregister_switch(priv->ds);\n\n\tif (priv->ds->slave_mii_bus) {\n\t\tmdiobus_unregister(priv->ds->slave_mii_bus);\n\t\tof_node_put(priv->ds->slave_mii_bus->dev.of_node);\n\t\tmdiobus_free(priv->ds->slave_mii_bus);\n\t}\n\n\tfor (i = 0; i < priv->num_gphy_fw; i++)\n\t\tgswip_gphy_fw_remove(priv, &priv->gphy_fw[i]);\n\n\treturn 0;\n}\n\nstatic void gswip_shutdown(struct platform_device *pdev)\n{\n\tstruct gswip_priv *priv = platform_get_drvdata(pdev);\n\n\tif (!priv)\n\t\treturn;\n\n\tdsa_switch_shutdown(priv->ds);\n\n\tplatform_set_drvdata(pdev, NULL);\n}\n\nstatic const struct gswip_hw_info gswip_xrx200 = {\n\t.max_ports = 7,\n\t.cpu_port = 6,\n\t.ops = &gswip_xrx200_switch_ops,\n};\n\nstatic const struct gswip_hw_info gswip_xrx300 = {\n\t.max_ports = 7,\n\t.cpu_port = 6,\n\t.ops = &gswip_xrx300_switch_ops,\n};\n\nstatic const struct of_device_id gswip_of_match[] = {\n\t{ .compatible = \"lantiq,xrx200-gswip\", .data = &gswip_xrx200 },\n\t{ .compatible = \"lantiq,xrx300-gswip\", .data = &gswip_xrx300 },\n\t{ .compatible = \"lantiq,xrx330-gswip\", .data = &gswip_xrx300 },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, gswip_of_match);\n\nstatic struct platform_driver gswip_driver = {\n\t.probe = gswip_probe,\n\t.remove = gswip_remove,\n\t.shutdown = gswip_shutdown,\n\t.driver = {\n\t\t.name = \"gswip\",\n\t\t.of_match_table = gswip_of_match,\n\t},\n};\n\nmodule_platform_driver(gswip_driver);\n\nMODULE_FIRMWARE(\"lantiq/xrx300_phy11g_a21.bin\");\nMODULE_FIRMWARE(\"lantiq/xrx300_phy22f_a21.bin\");\nMODULE_FIRMWARE(\"lantiq/xrx200_phy11g_a14.bin\");\nMODULE_FIRMWARE(\"lantiq/xrx200_phy11g_a22.bin\");\nMODULE_FIRMWARE(\"lantiq/xrx200_phy22f_a14.bin\");\nMODULE_FIRMWARE(\"lantiq/xrx200_phy22f_a22.bin\");\nMODULE_AUTHOR(\"Hauke Mehrtens <hauke@hauke-m.de>\");\nMODULE_DESCRIPTION(\"Lantiq / Intel GSWIP driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}