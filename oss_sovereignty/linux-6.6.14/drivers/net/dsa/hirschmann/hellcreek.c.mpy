{
  "module_name": "hellcreek.c",
  "hash_id": "a094f75d1f9be6c62ae06023a91363411443dfdd7aba68fd3e62f46080e78031",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/hirschmann/hellcreek.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/of_mdio.h>\n#include <linux/platform_device.h>\n#include <linux/bitops.h>\n#include <linux/if_bridge.h>\n#include <linux/if_vlan.h>\n#include <linux/etherdevice.h>\n#include <linux/random.h>\n#include <linux/iopoll.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <net/dsa.h>\n\n#include \"hellcreek.h\"\n#include \"hellcreek_ptp.h\"\n#include \"hellcreek_hwtstamp.h\"\n\nstatic const struct hellcreek_counter hellcreek_counter[] = {\n\t{ 0x00, \"RxFiltered\", },\n\t{ 0x01, \"RxOctets1k\", },\n\t{ 0x02, \"RxVTAG\", },\n\t{ 0x03, \"RxL2BAD\", },\n\t{ 0x04, \"RxOverloadDrop\", },\n\t{ 0x05, \"RxUC\", },\n\t{ 0x06, \"RxMC\", },\n\t{ 0x07, \"RxBC\", },\n\t{ 0x08, \"RxRS<64\", },\n\t{ 0x09, \"RxRS64\", },\n\t{ 0x0a, \"RxRS65_127\", },\n\t{ 0x0b, \"RxRS128_255\", },\n\t{ 0x0c, \"RxRS256_511\", },\n\t{ 0x0d, \"RxRS512_1023\", },\n\t{ 0x0e, \"RxRS1024_1518\", },\n\t{ 0x0f, \"RxRS>1518\", },\n\t{ 0x10, \"TxTailDropQueue0\", },\n\t{ 0x11, \"TxTailDropQueue1\", },\n\t{ 0x12, \"TxTailDropQueue2\", },\n\t{ 0x13, \"TxTailDropQueue3\", },\n\t{ 0x14, \"TxTailDropQueue4\", },\n\t{ 0x15, \"TxTailDropQueue5\", },\n\t{ 0x16, \"TxTailDropQueue6\", },\n\t{ 0x17, \"TxTailDropQueue7\", },\n\t{ 0x18, \"RxTrafficClass0\", },\n\t{ 0x19, \"RxTrafficClass1\", },\n\t{ 0x1a, \"RxTrafficClass2\", },\n\t{ 0x1b, \"RxTrafficClass3\", },\n\t{ 0x1c, \"RxTrafficClass4\", },\n\t{ 0x1d, \"RxTrafficClass5\", },\n\t{ 0x1e, \"RxTrafficClass6\", },\n\t{ 0x1f, \"RxTrafficClass7\", },\n\t{ 0x21, \"TxOctets1k\", },\n\t{ 0x22, \"TxVTAG\", },\n\t{ 0x23, \"TxL2BAD\", },\n\t{ 0x25, \"TxUC\", },\n\t{ 0x26, \"TxMC\", },\n\t{ 0x27, \"TxBC\", },\n\t{ 0x28, \"TxTS<64\", },\n\t{ 0x29, \"TxTS64\", },\n\t{ 0x2a, \"TxTS65_127\", },\n\t{ 0x2b, \"TxTS128_255\", },\n\t{ 0x2c, \"TxTS256_511\", },\n\t{ 0x2d, \"TxTS512_1023\", },\n\t{ 0x2e, \"TxTS1024_1518\", },\n\t{ 0x2f, \"TxTS>1518\", },\n\t{ 0x30, \"TxTrafficClassOverrun0\", },\n\t{ 0x31, \"TxTrafficClassOverrun1\", },\n\t{ 0x32, \"TxTrafficClassOverrun2\", },\n\t{ 0x33, \"TxTrafficClassOverrun3\", },\n\t{ 0x34, \"TxTrafficClassOverrun4\", },\n\t{ 0x35, \"TxTrafficClassOverrun5\", },\n\t{ 0x36, \"TxTrafficClassOverrun6\", },\n\t{ 0x37, \"TxTrafficClassOverrun7\", },\n\t{ 0x38, \"TxTrafficClass0\", },\n\t{ 0x39, \"TxTrafficClass1\", },\n\t{ 0x3a, \"TxTrafficClass2\", },\n\t{ 0x3b, \"TxTrafficClass3\", },\n\t{ 0x3c, \"TxTrafficClass4\", },\n\t{ 0x3d, \"TxTrafficClass5\", },\n\t{ 0x3e, \"TxTrafficClass6\", },\n\t{ 0x3f, \"TxTrafficClass7\", },\n};\n\nstatic u16 hellcreek_read(struct hellcreek *hellcreek, unsigned int offset)\n{\n\treturn readw(hellcreek->base + offset);\n}\n\nstatic u16 hellcreek_read_ctrl(struct hellcreek *hellcreek)\n{\n\treturn readw(hellcreek->base + HR_CTRL_C);\n}\n\nstatic u16 hellcreek_read_stat(struct hellcreek *hellcreek)\n{\n\treturn readw(hellcreek->base + HR_SWSTAT);\n}\n\nstatic void hellcreek_write(struct hellcreek *hellcreek, u16 data,\n\t\t\t    unsigned int offset)\n{\n\twritew(data, hellcreek->base + offset);\n}\n\nstatic void hellcreek_select_port(struct hellcreek *hellcreek, int port)\n{\n\tu16 val = port << HR_PSEL_PTWSEL_SHIFT;\n\n\thellcreek_write(hellcreek, val, HR_PSEL);\n}\n\nstatic void hellcreek_select_prio(struct hellcreek *hellcreek, int prio)\n{\n\tu16 val = prio << HR_PSEL_PRTCWSEL_SHIFT;\n\n\thellcreek_write(hellcreek, val, HR_PSEL);\n}\n\nstatic void hellcreek_select_port_prio(struct hellcreek *hellcreek, int port,\n\t\t\t\t       int prio)\n{\n\tu16 val = port << HR_PSEL_PTWSEL_SHIFT;\n\n\tval |= prio << HR_PSEL_PRTCWSEL_SHIFT;\n\n\thellcreek_write(hellcreek, val, HR_PSEL);\n}\n\nstatic void hellcreek_select_counter(struct hellcreek *hellcreek, int counter)\n{\n\tu16 val = counter << HR_CSEL_SHIFT;\n\n\thellcreek_write(hellcreek, val, HR_CSEL);\n\n\t \n\tndelay(200);\n}\n\nstatic void hellcreek_select_vlan(struct hellcreek *hellcreek, int vid,\n\t\t\t\t  bool pvid)\n{\n\tu16 val = 0;\n\n\t \n\tif (pvid)\n\t\tval |= HR_VIDCFG_PVID;\n\thellcreek_write(hellcreek, val, HR_VIDCFG);\n\n\t \n\tval |= vid << HR_VIDCFG_VID_SHIFT;\n\thellcreek_write(hellcreek, val, HR_VIDCFG);\n}\n\nstatic void hellcreek_select_tgd(struct hellcreek *hellcreek, int port)\n{\n\tu16 val = port << TR_TGDSEL_TDGSEL_SHIFT;\n\n\thellcreek_write(hellcreek, val, TR_TGDSEL);\n}\n\nstatic int hellcreek_wait_until_ready(struct hellcreek *hellcreek)\n{\n\tu16 val;\n\n\t \n\treturn readx_poll_timeout(hellcreek_read_ctrl, hellcreek,\n\t\t\t\t  val, val & HR_CTRL_C_READY,\n\t\t\t\t  3, 1000);\n}\n\nstatic int hellcreek_wait_until_transitioned(struct hellcreek *hellcreek)\n{\n\tu16 val;\n\n\treturn readx_poll_timeout_atomic(hellcreek_read_ctrl, hellcreek,\n\t\t\t\t\t val, !(val & HR_CTRL_C_TRANSITION),\n\t\t\t\t\t 1, 1000);\n}\n\nstatic int hellcreek_wait_fdb_ready(struct hellcreek *hellcreek)\n{\n\tu16 val;\n\n\treturn readx_poll_timeout_atomic(hellcreek_read_stat, hellcreek,\n\t\t\t\t\t val, !(val & HR_SWSTAT_BUSY),\n\t\t\t\t\t 1, 1000);\n}\n\nstatic int hellcreek_detect(struct hellcreek *hellcreek)\n{\n\tu16 id, rel_low, rel_high, date_low, date_high, tgd_ver;\n\tu8 tgd_maj, tgd_min;\n\tu32 rel, date;\n\n\tid\t  = hellcreek_read(hellcreek, HR_MODID_C);\n\trel_low\t  = hellcreek_read(hellcreek, HR_REL_L_C);\n\trel_high  = hellcreek_read(hellcreek, HR_REL_H_C);\n\tdate_low  = hellcreek_read(hellcreek, HR_BLD_L_C);\n\tdate_high = hellcreek_read(hellcreek, HR_BLD_H_C);\n\ttgd_ver   = hellcreek_read(hellcreek, TR_TGDVER);\n\n\tif (id != hellcreek->pdata->module_id)\n\t\treturn -ENODEV;\n\n\trel\t= rel_low | (rel_high << 16);\n\tdate\t= date_low | (date_high << 16);\n\ttgd_maj = (tgd_ver & TR_TGDVER_REV_MAJ_MASK) >> TR_TGDVER_REV_MAJ_SHIFT;\n\ttgd_min = (tgd_ver & TR_TGDVER_REV_MIN_MASK) >> TR_TGDVER_REV_MIN_SHIFT;\n\n\tdev_info(hellcreek->dev, \"Module ID=%02x Release=%04x Date=%04x TGD Version=%02x.%02x\\n\",\n\t\t id, rel, date, tgd_maj, tgd_min);\n\n\treturn 0;\n}\n\nstatic void hellcreek_feature_detect(struct hellcreek *hellcreek)\n{\n\tu16 features;\n\n\tfeatures = hellcreek_read(hellcreek, HR_FEABITS0);\n\n\t \n\thellcreek->fdb_entries = ((features & HR_FEABITS0_FDBBINS_MASK) >>\n\t\t\t       HR_FEABITS0_FDBBINS_SHIFT) * 32;\n}\n\nstatic enum dsa_tag_protocol hellcreek_get_tag_protocol(struct dsa_switch *ds,\n\t\t\t\t\t\t\tint port,\n\t\t\t\t\t\t\tenum dsa_tag_protocol mp)\n{\n\treturn DSA_TAG_PROTO_HELLCREEK;\n}\n\nstatic int hellcreek_port_enable(struct dsa_switch *ds, int port,\n\t\t\t\t struct phy_device *phy)\n{\n\tstruct hellcreek *hellcreek = ds->priv;\n\tstruct hellcreek_port *hellcreek_port;\n\tu16 val;\n\n\thellcreek_port = &hellcreek->ports[port];\n\n\tdev_dbg(hellcreek->dev, \"Enable port %d\\n\", port);\n\n\tmutex_lock(&hellcreek->reg_lock);\n\n\thellcreek_select_port(hellcreek, port);\n\tval = hellcreek_port->ptcfg;\n\tval |= HR_PTCFG_ADMIN_EN;\n\thellcreek_write(hellcreek, val, HR_PTCFG);\n\thellcreek_port->ptcfg = val;\n\n\tmutex_unlock(&hellcreek->reg_lock);\n\n\treturn 0;\n}\n\nstatic void hellcreek_port_disable(struct dsa_switch *ds, int port)\n{\n\tstruct hellcreek *hellcreek = ds->priv;\n\tstruct hellcreek_port *hellcreek_port;\n\tu16 val;\n\n\thellcreek_port = &hellcreek->ports[port];\n\n\tdev_dbg(hellcreek->dev, \"Disable port %d\\n\", port);\n\n\tmutex_lock(&hellcreek->reg_lock);\n\n\thellcreek_select_port(hellcreek, port);\n\tval = hellcreek_port->ptcfg;\n\tval &= ~HR_PTCFG_ADMIN_EN;\n\thellcreek_write(hellcreek, val, HR_PTCFG);\n\thellcreek_port->ptcfg = val;\n\n\tmutex_unlock(&hellcreek->reg_lock);\n}\n\nstatic void hellcreek_get_strings(struct dsa_switch *ds, int port,\n\t\t\t\t  u32 stringset, uint8_t *data)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hellcreek_counter); ++i) {\n\t\tconst struct hellcreek_counter *counter = &hellcreek_counter[i];\n\n\t\tstrscpy(data + i * ETH_GSTRING_LEN,\n\t\t\tcounter->name, ETH_GSTRING_LEN);\n\t}\n}\n\nstatic int hellcreek_get_sset_count(struct dsa_switch *ds, int port, int sset)\n{\n\tif (sset != ETH_SS_STATS)\n\t\treturn 0;\n\n\treturn ARRAY_SIZE(hellcreek_counter);\n}\n\nstatic void hellcreek_get_ethtool_stats(struct dsa_switch *ds, int port,\n\t\t\t\t\tuint64_t *data)\n{\n\tstruct hellcreek *hellcreek = ds->priv;\n\tstruct hellcreek_port *hellcreek_port;\n\tint i;\n\n\thellcreek_port = &hellcreek->ports[port];\n\n\tfor (i = 0; i < ARRAY_SIZE(hellcreek_counter); ++i) {\n\t\tconst struct hellcreek_counter *counter = &hellcreek_counter[i];\n\t\tu8 offset = counter->offset + port * 64;\n\t\tu16 high, low;\n\t\tu64 value;\n\n\t\tmutex_lock(&hellcreek->reg_lock);\n\n\t\thellcreek_select_counter(hellcreek, offset);\n\n\t\t \n\t\thigh  = hellcreek_read(hellcreek, HR_CRDH);\n\t\tlow   = hellcreek_read(hellcreek, HR_CRDL);\n\t\tvalue = ((u64)high << 16) | low;\n\n\t\thellcreek_port->counter_values[i] += value;\n\t\tdata[i] = hellcreek_port->counter_values[i];\n\n\t\tmutex_unlock(&hellcreek->reg_lock);\n\t}\n}\n\nstatic u16 hellcreek_private_vid(int port)\n{\n\treturn VLAN_N_VID - port + 1;\n}\n\nstatic int hellcreek_vlan_prepare(struct dsa_switch *ds, int port,\n\t\t\t\t  const struct switchdev_obj_port_vlan *vlan,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct hellcreek *hellcreek = ds->priv;\n\tint i;\n\n\tdev_dbg(hellcreek->dev, \"VLAN prepare for port %d\\n\", port);\n\n\t \n\tfor (i = 0; i < hellcreek->pdata->num_ports; ++i) {\n\t\tconst u16 restricted_vid = hellcreek_private_vid(i);\n\n\t\tif (!dsa_is_user_port(ds, i))\n\t\t\tcontinue;\n\n\t\tif (vlan->vid == restricted_vid) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"VID restricted by driver\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void hellcreek_select_vlan_params(struct hellcreek *hellcreek, int port,\n\t\t\t\t\t int *shift, int *mask)\n{\n\tswitch (port) {\n\tcase 0:\n\t\t*shift = HR_VIDMBRCFG_P0MBR_SHIFT;\n\t\t*mask  = HR_VIDMBRCFG_P0MBR_MASK;\n\t\tbreak;\n\tcase 1:\n\t\t*shift = HR_VIDMBRCFG_P1MBR_SHIFT;\n\t\t*mask  = HR_VIDMBRCFG_P1MBR_MASK;\n\t\tbreak;\n\tcase 2:\n\t\t*shift = HR_VIDMBRCFG_P2MBR_SHIFT;\n\t\t*mask  = HR_VIDMBRCFG_P2MBR_MASK;\n\t\tbreak;\n\tcase 3:\n\t\t*shift = HR_VIDMBRCFG_P3MBR_SHIFT;\n\t\t*mask  = HR_VIDMBRCFG_P3MBR_MASK;\n\t\tbreak;\n\tdefault:\n\t\t*shift = *mask = 0;\n\t\tdev_err(hellcreek->dev, \"Unknown port %d selected!\\n\", port);\n\t}\n}\n\nstatic void hellcreek_apply_vlan(struct hellcreek *hellcreek, int port, u16 vid,\n\t\t\t\t bool pvid, bool untagged)\n{\n\tint shift, mask;\n\tu16 val;\n\n\tdev_dbg(hellcreek->dev, \"Apply VLAN: port=%d vid=%u pvid=%d untagged=%d\",\n\t\tport, vid, pvid, untagged);\n\n\tmutex_lock(&hellcreek->reg_lock);\n\n\thellcreek_select_port(hellcreek, port);\n\thellcreek_select_vlan(hellcreek, vid, pvid);\n\n\t \n\thellcreek_select_vlan_params(hellcreek, port, &shift, &mask);\n\tval = hellcreek->vidmbrcfg[vid];\n\tval &= ~mask;\n\tif (untagged)\n\t\tval |= HELLCREEK_VLAN_UNTAGGED_MEMBER << shift;\n\telse\n\t\tval |= HELLCREEK_VLAN_TAGGED_MEMBER << shift;\n\n\thellcreek_write(hellcreek, val, HR_VIDMBRCFG);\n\thellcreek->vidmbrcfg[vid] = val;\n\n\tmutex_unlock(&hellcreek->reg_lock);\n}\n\nstatic void hellcreek_unapply_vlan(struct hellcreek *hellcreek, int port,\n\t\t\t\t   u16 vid)\n{\n\tint shift, mask;\n\tu16 val;\n\n\tdev_dbg(hellcreek->dev, \"Unapply VLAN: port=%d vid=%u\\n\", port, vid);\n\n\tmutex_lock(&hellcreek->reg_lock);\n\n\thellcreek_select_vlan(hellcreek, vid, false);\n\n\t \n\thellcreek_select_vlan_params(hellcreek, port, &shift, &mask);\n\tval = hellcreek->vidmbrcfg[vid];\n\tval &= ~mask;\n\tval |= HELLCREEK_VLAN_NO_MEMBER << shift;\n\n\thellcreek_write(hellcreek, val, HR_VIDMBRCFG);\n\thellcreek->vidmbrcfg[vid] = val;\n\n\tmutex_unlock(&hellcreek->reg_lock);\n}\n\nstatic int hellcreek_vlan_add(struct dsa_switch *ds, int port,\n\t\t\t      const struct switchdev_obj_port_vlan *vlan,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tbool untagged = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;\n\tbool pvid = vlan->flags & BRIDGE_VLAN_INFO_PVID;\n\tstruct hellcreek *hellcreek = ds->priv;\n\tint err;\n\n\terr = hellcreek_vlan_prepare(ds, port, vlan, extack);\n\tif (err)\n\t\treturn err;\n\n\tdev_dbg(hellcreek->dev, \"Add VLAN %d on port %d, %s, %s\\n\",\n\t\tvlan->vid, port, untagged ? \"untagged\" : \"tagged\",\n\t\tpvid ? \"PVID\" : \"no PVID\");\n\n\thellcreek_apply_vlan(hellcreek, port, vlan->vid, pvid, untagged);\n\n\treturn 0;\n}\n\nstatic int hellcreek_vlan_del(struct dsa_switch *ds, int port,\n\t\t\t      const struct switchdev_obj_port_vlan *vlan)\n{\n\tstruct hellcreek *hellcreek = ds->priv;\n\n\tdev_dbg(hellcreek->dev, \"Remove VLAN %d on port %d\\n\", vlan->vid, port);\n\n\thellcreek_unapply_vlan(hellcreek, port, vlan->vid);\n\n\treturn 0;\n}\n\nstatic void hellcreek_port_stp_state_set(struct dsa_switch *ds, int port,\n\t\t\t\t\t u8 state)\n{\n\tstruct hellcreek *hellcreek = ds->priv;\n\tstruct hellcreek_port *hellcreek_port;\n\tconst char *new_state;\n\tu16 val;\n\n\tmutex_lock(&hellcreek->reg_lock);\n\n\thellcreek_port = &hellcreek->ports[port];\n\tval = hellcreek_port->ptcfg;\n\n\tswitch (state) {\n\tcase BR_STATE_DISABLED:\n\t\tnew_state = \"DISABLED\";\n\t\tval |= HR_PTCFG_BLOCKED;\n\t\tval &= ~HR_PTCFG_LEARNING_EN;\n\t\tbreak;\n\tcase BR_STATE_BLOCKING:\n\t\tnew_state = \"BLOCKING\";\n\t\tval |= HR_PTCFG_BLOCKED;\n\t\tval &= ~HR_PTCFG_LEARNING_EN;\n\t\tbreak;\n\tcase BR_STATE_LISTENING:\n\t\tnew_state = \"LISTENING\";\n\t\tval |= HR_PTCFG_BLOCKED;\n\t\tval &= ~HR_PTCFG_LEARNING_EN;\n\t\tbreak;\n\tcase BR_STATE_LEARNING:\n\t\tnew_state = \"LEARNING\";\n\t\tval |= HR_PTCFG_BLOCKED;\n\t\tval |= HR_PTCFG_LEARNING_EN;\n\t\tbreak;\n\tcase BR_STATE_FORWARDING:\n\t\tnew_state = \"FORWARDING\";\n\t\tval &= ~HR_PTCFG_BLOCKED;\n\t\tval |= HR_PTCFG_LEARNING_EN;\n\t\tbreak;\n\tdefault:\n\t\tnew_state = \"UNKNOWN\";\n\t}\n\n\thellcreek_select_port(hellcreek, port);\n\thellcreek_write(hellcreek, val, HR_PTCFG);\n\thellcreek_port->ptcfg = val;\n\n\tmutex_unlock(&hellcreek->reg_lock);\n\n\tdev_dbg(hellcreek->dev, \"Configured STP state for port %d: %s\\n\",\n\t\tport, new_state);\n}\n\nstatic void hellcreek_setup_ingressflt(struct hellcreek *hellcreek, int port,\n\t\t\t\t       bool enable)\n{\n\tstruct hellcreek_port *hellcreek_port = &hellcreek->ports[port];\n\tu16 ptcfg;\n\n\tmutex_lock(&hellcreek->reg_lock);\n\n\tptcfg = hellcreek_port->ptcfg;\n\n\tif (enable)\n\t\tptcfg |= HR_PTCFG_INGRESSFLT;\n\telse\n\t\tptcfg &= ~HR_PTCFG_INGRESSFLT;\n\n\thellcreek_select_port(hellcreek, port);\n\thellcreek_write(hellcreek, ptcfg, HR_PTCFG);\n\thellcreek_port->ptcfg = ptcfg;\n\n\tmutex_unlock(&hellcreek->reg_lock);\n}\n\nstatic void hellcreek_setup_vlan_awareness(struct hellcreek *hellcreek,\n\t\t\t\t\t   bool enable)\n{\n\tu16 swcfg;\n\n\tmutex_lock(&hellcreek->reg_lock);\n\n\tswcfg = hellcreek->swcfg;\n\n\tif (enable)\n\t\tswcfg |= HR_SWCFG_VLAN_UNAWARE;\n\telse\n\t\tswcfg &= ~HR_SWCFG_VLAN_UNAWARE;\n\n\thellcreek_write(hellcreek, swcfg, HR_SWCFG);\n\n\tmutex_unlock(&hellcreek->reg_lock);\n}\n\n \nstatic void hellcreek_setup_vlan_membership(struct dsa_switch *ds, int port,\n\t\t\t\t\t    bool enabled)\n{\n\tconst u16 vid = hellcreek_private_vid(port);\n\tint upstream = dsa_upstream_port(ds, port);\n\tstruct hellcreek *hellcreek = ds->priv;\n\n\t \n\tif (enabled)\n\t\thellcreek_apply_vlan(hellcreek, port, vid, true, true);\n\telse\n\t\thellcreek_unapply_vlan(hellcreek, port, vid);\n\n\t \n\tif (enabled)\n\t\thellcreek_apply_vlan(hellcreek, upstream, vid, false, true);\n\telse\n\t\thellcreek_unapply_vlan(hellcreek, upstream, vid);\n}\n\nstatic void hellcreek_port_set_ucast_flood(struct hellcreek *hellcreek,\n\t\t\t\t\t   int port, bool enable)\n{\n\tstruct hellcreek_port *hellcreek_port;\n\tu16 val;\n\n\thellcreek_port = &hellcreek->ports[port];\n\n\tdev_dbg(hellcreek->dev, \"%s unicast flooding on port %d\\n\",\n\t\tenable ? \"Enable\" : \"Disable\", port);\n\n\tmutex_lock(&hellcreek->reg_lock);\n\n\thellcreek_select_port(hellcreek, port);\n\tval = hellcreek_port->ptcfg;\n\tif (enable)\n\t\tval &= ~HR_PTCFG_UUC_FLT;\n\telse\n\t\tval |= HR_PTCFG_UUC_FLT;\n\thellcreek_write(hellcreek, val, HR_PTCFG);\n\thellcreek_port->ptcfg = val;\n\n\tmutex_unlock(&hellcreek->reg_lock);\n}\n\nstatic void hellcreek_port_set_mcast_flood(struct hellcreek *hellcreek,\n\t\t\t\t\t   int port, bool enable)\n{\n\tstruct hellcreek_port *hellcreek_port;\n\tu16 val;\n\n\thellcreek_port = &hellcreek->ports[port];\n\n\tdev_dbg(hellcreek->dev, \"%s multicast flooding on port %d\\n\",\n\t\tenable ? \"Enable\" : \"Disable\", port);\n\n\tmutex_lock(&hellcreek->reg_lock);\n\n\thellcreek_select_port(hellcreek, port);\n\tval = hellcreek_port->ptcfg;\n\tif (enable)\n\t\tval &= ~HR_PTCFG_UMC_FLT;\n\telse\n\t\tval |= HR_PTCFG_UMC_FLT;\n\thellcreek_write(hellcreek, val, HR_PTCFG);\n\thellcreek_port->ptcfg = val;\n\n\tmutex_unlock(&hellcreek->reg_lock);\n}\n\nstatic int hellcreek_pre_bridge_flags(struct dsa_switch *ds, int port,\n\t\t\t\t      struct switchdev_brport_flags flags,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tif (flags.mask & ~(BR_FLOOD | BR_MCAST_FLOOD))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int hellcreek_bridge_flags(struct dsa_switch *ds, int port,\n\t\t\t\t  struct switchdev_brport_flags flags,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct hellcreek *hellcreek = ds->priv;\n\n\tif (flags.mask & BR_FLOOD)\n\t\thellcreek_port_set_ucast_flood(hellcreek, port,\n\t\t\t\t\t       !!(flags.val & BR_FLOOD));\n\n\tif (flags.mask & BR_MCAST_FLOOD)\n\t\thellcreek_port_set_mcast_flood(hellcreek, port,\n\t\t\t\t\t       !!(flags.val & BR_MCAST_FLOOD));\n\n\treturn 0;\n}\n\nstatic int hellcreek_port_bridge_join(struct dsa_switch *ds, int port,\n\t\t\t\t      struct dsa_bridge bridge,\n\t\t\t\t      bool *tx_fwd_offload,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct hellcreek *hellcreek = ds->priv;\n\n\tdev_dbg(hellcreek->dev, \"Port %d joins a bridge\\n\", port);\n\n\t \n\tif (!ds->vlan_filtering)\n\t\thellcreek_setup_vlan_awareness(hellcreek, false);\n\n\t \n\thellcreek_setup_vlan_membership(ds, port, false);\n\n\treturn 0;\n}\n\nstatic void hellcreek_port_bridge_leave(struct dsa_switch *ds, int port,\n\t\t\t\t\tstruct dsa_bridge bridge)\n{\n\tstruct hellcreek *hellcreek = ds->priv;\n\n\tdev_dbg(hellcreek->dev, \"Port %d leaves a bridge\\n\", port);\n\n\t \n\thellcreek_setup_vlan_awareness(hellcreek, true);\n\n\t \n\thellcreek_setup_vlan_membership(ds, port, true);\n}\n\nstatic int __hellcreek_fdb_add(struct hellcreek *hellcreek,\n\t\t\t       const struct hellcreek_fdb_entry *entry)\n{\n\tu16 meta = 0;\n\n\tdev_dbg(hellcreek->dev, \"Add static FDB entry: MAC=%pM, MASK=0x%02x, \"\n\t\t\"OBT=%d, PASS_BLOCKED=%d, REPRIO_EN=%d, PRIO=%d\\n\", entry->mac,\n\t\tentry->portmask, entry->is_obt, entry->pass_blocked,\n\t\tentry->reprio_en, entry->reprio_tc);\n\n\t \n\thellcreek_write(hellcreek, entry->mac[1] | (entry->mac[0] << 8), HR_FDBWDH);\n\thellcreek_write(hellcreek, entry->mac[3] | (entry->mac[2] << 8), HR_FDBWDM);\n\thellcreek_write(hellcreek, entry->mac[5] | (entry->mac[4] << 8), HR_FDBWDL);\n\n\t \n\tmeta |= entry->portmask << HR_FDBWRM0_PORTMASK_SHIFT;\n\tif (entry->is_obt)\n\t\tmeta |= HR_FDBWRM0_OBT;\n\tif (entry->pass_blocked)\n\t\tmeta |= HR_FDBWRM0_PASS_BLOCKED;\n\tif (entry->reprio_en) {\n\t\tmeta |= HR_FDBWRM0_REPRIO_EN;\n\t\tmeta |= entry->reprio_tc << HR_FDBWRM0_REPRIO_TC_SHIFT;\n\t}\n\thellcreek_write(hellcreek, meta, HR_FDBWRM0);\n\n\t \n\thellcreek_write(hellcreek, 0x00, HR_FDBWRCMD);\n\n\t \n\treturn hellcreek_wait_fdb_ready(hellcreek);\n}\n\nstatic int __hellcreek_fdb_del(struct hellcreek *hellcreek,\n\t\t\t       const struct hellcreek_fdb_entry *entry)\n{\n\tdev_dbg(hellcreek->dev, \"Delete FDB entry: MAC=%pM!\\n\", entry->mac);\n\n\t \n\thellcreek_write(hellcreek, entry->idx | HR_FDBWRCMD_FDBDEL, HR_FDBWRCMD);\n\n\t \n\treturn hellcreek_wait_fdb_ready(hellcreek);\n}\n\nstatic void hellcreek_populate_fdb_entry(struct hellcreek *hellcreek,\n\t\t\t\t\t struct hellcreek_fdb_entry *entry,\n\t\t\t\t\t size_t idx)\n{\n\tunsigned char addr[ETH_ALEN];\n\tu16 meta, mac;\n\n\t \n\tmeta\t= hellcreek_read(hellcreek, HR_FDBMDRD);\n\tmac\t= hellcreek_read(hellcreek, HR_FDBRDL);\n\taddr[5] = mac & 0xff;\n\taddr[4] = (mac & 0xff00) >> 8;\n\tmac\t= hellcreek_read(hellcreek, HR_FDBRDM);\n\taddr[3] = mac & 0xff;\n\taddr[2] = (mac & 0xff00) >> 8;\n\tmac\t= hellcreek_read(hellcreek, HR_FDBRDH);\n\taddr[1] = mac & 0xff;\n\taddr[0] = (mac & 0xff00) >> 8;\n\n\t \n\tmemcpy(entry->mac, addr, sizeof(addr));\n\tentry->idx\t    = idx;\n\tentry->portmask\t    = (meta & HR_FDBMDRD_PORTMASK_MASK) >>\n\t\tHR_FDBMDRD_PORTMASK_SHIFT;\n\tentry->age\t    = (meta & HR_FDBMDRD_AGE_MASK) >>\n\t\tHR_FDBMDRD_AGE_SHIFT;\n\tentry->is_obt\t    = !!(meta & HR_FDBMDRD_OBT);\n\tentry->pass_blocked = !!(meta & HR_FDBMDRD_PASS_BLOCKED);\n\tentry->is_static    = !!(meta & HR_FDBMDRD_STATIC);\n\tentry->reprio_tc    = (meta & HR_FDBMDRD_REPRIO_TC_MASK) >>\n\t\tHR_FDBMDRD_REPRIO_TC_SHIFT;\n\tentry->reprio_en    = !!(meta & HR_FDBMDRD_REPRIO_EN);\n}\n\n \nstatic int hellcreek_fdb_get(struct hellcreek *hellcreek,\n\t\t\t     const unsigned char *dest,\n\t\t\t     struct hellcreek_fdb_entry *entry)\n{\n\tsize_t i;\n\n\t \n\thellcreek_read(hellcreek, HR_FDBMAX);\n\thellcreek_write(hellcreek, 0x00, HR_FDBMAX);\n\n\t \n\tfor (i = 0; i < hellcreek->fdb_entries; ++i) {\n\t\tstruct hellcreek_fdb_entry tmp = { 0 };\n\n\t\t \n\t\thellcreek_populate_fdb_entry(hellcreek, &tmp, i);\n\n\t\t \n\t\thellcreek_write(hellcreek, 0x00, HR_FDBRDH);\n\n\t\tif (memcmp(tmp.mac, dest, ETH_ALEN))\n\t\t\tcontinue;\n\n\t\t \n\t\tmemcpy(entry, &tmp, sizeof(*entry));\n\n\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int hellcreek_fdb_add(struct dsa_switch *ds, int port,\n\t\t\t     const unsigned char *addr, u16 vid,\n\t\t\t     struct dsa_db db)\n{\n\tstruct hellcreek_fdb_entry entry = { 0 };\n\tstruct hellcreek *hellcreek = ds->priv;\n\tint ret;\n\n\tdev_dbg(hellcreek->dev, \"Add FDB entry for MAC=%pM\\n\", addr);\n\n\tmutex_lock(&hellcreek->reg_lock);\n\n\tret = hellcreek_fdb_get(hellcreek, addr, &entry);\n\tif (ret) {\n\t\t \n\t\tmemcpy(entry.mac, addr, sizeof(entry.mac));\n\t\tentry.portmask = BIT(port);\n\n\t\tret = __hellcreek_fdb_add(hellcreek, &entry);\n\t\tif (ret) {\n\t\t\tdev_err(hellcreek->dev, \"Failed to add FDB entry!\\n\");\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t \n\t\tret = __hellcreek_fdb_del(hellcreek, &entry);\n\t\tif (ret) {\n\t\t\tdev_err(hellcreek->dev, \"Failed to delete FDB entry!\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tentry.portmask |= BIT(port);\n\n\t\tret = __hellcreek_fdb_add(hellcreek, &entry);\n\t\tif (ret) {\n\t\t\tdev_err(hellcreek->dev, \"Failed to add FDB entry!\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(&hellcreek->reg_lock);\n\n\treturn ret;\n}\n\nstatic int hellcreek_fdb_del(struct dsa_switch *ds, int port,\n\t\t\t     const unsigned char *addr, u16 vid,\n\t\t\t     struct dsa_db db)\n{\n\tstruct hellcreek_fdb_entry entry = { 0 };\n\tstruct hellcreek *hellcreek = ds->priv;\n\tint ret;\n\n\tdev_dbg(hellcreek->dev, \"Delete FDB entry for MAC=%pM\\n\", addr);\n\n\tmutex_lock(&hellcreek->reg_lock);\n\n\tret = hellcreek_fdb_get(hellcreek, addr, &entry);\n\tif (ret) {\n\t\t \n\t\tdev_err(hellcreek->dev, \"FDB entry for deletion not found!\\n\");\n\t} else {\n\t\t \n\t\tret = __hellcreek_fdb_del(hellcreek, &entry);\n\t\tif (ret) {\n\t\t\tdev_err(hellcreek->dev, \"Failed to delete FDB entry!\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tentry.portmask &= ~BIT(port);\n\n\t\tif (entry.portmask != 0x00) {\n\t\t\tret = __hellcreek_fdb_add(hellcreek, &entry);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(hellcreek->dev, \"Failed to add FDB entry!\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(&hellcreek->reg_lock);\n\n\treturn ret;\n}\n\nstatic int hellcreek_fdb_dump(struct dsa_switch *ds, int port,\n\t\t\t      dsa_fdb_dump_cb_t *cb, void *data)\n{\n\tstruct hellcreek *hellcreek = ds->priv;\n\tu16 entries;\n\tint ret = 0;\n\tsize_t i;\n\n\tmutex_lock(&hellcreek->reg_lock);\n\n\t \n\tentries = hellcreek_read(hellcreek, HR_FDBMAX);\n\thellcreek_write(hellcreek, 0x00, HR_FDBMAX);\n\n\tdev_dbg(hellcreek->dev, \"FDB dump for port %d, entries=%d!\\n\", port, entries);\n\n\t \n\tfor (i = 0; i < hellcreek->fdb_entries; ++i) {\n\t\tstruct hellcreek_fdb_entry entry = { 0 };\n\n\t\t \n\t\thellcreek_populate_fdb_entry(hellcreek, &entry, i);\n\n\t\t \n\t\thellcreek_write(hellcreek, 0x00, HR_FDBRDH);\n\n\t\t \n\t\tif (is_zero_ether_addr(entry.mac))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!(entry.portmask & BIT(port)))\n\t\t\tcontinue;\n\n\t\tret = cb(entry.mac, 0, entry.is_static, data);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&hellcreek->reg_lock);\n\n\treturn ret;\n}\n\nstatic int hellcreek_vlan_filtering(struct dsa_switch *ds, int port,\n\t\t\t\t    bool vlan_filtering,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct hellcreek *hellcreek = ds->priv;\n\n\tdev_dbg(hellcreek->dev, \"%s VLAN filtering on port %d\\n\",\n\t\tvlan_filtering ? \"Enable\" : \"Disable\", port);\n\n\t \n\thellcreek_setup_ingressflt(hellcreek, port, vlan_filtering);\n\n\t \n\thellcreek_setup_vlan_awareness(hellcreek, vlan_filtering);\n\n\treturn 0;\n}\n\nstatic int hellcreek_enable_ip_core(struct hellcreek *hellcreek)\n{\n\tint ret;\n\tu16 val;\n\n\tmutex_lock(&hellcreek->reg_lock);\n\n\tval = hellcreek_read(hellcreek, HR_CTRL_C);\n\tval |= HR_CTRL_C_ENABLE;\n\thellcreek_write(hellcreek, val, HR_CTRL_C);\n\tret = hellcreek_wait_until_transitioned(hellcreek);\n\n\tmutex_unlock(&hellcreek->reg_lock);\n\n\treturn ret;\n}\n\nstatic void hellcreek_setup_cpu_and_tunnel_port(struct hellcreek *hellcreek)\n{\n\tstruct hellcreek_port *tunnel_port = &hellcreek->ports[TUNNEL_PORT];\n\tstruct hellcreek_port *cpu_port = &hellcreek->ports[CPU_PORT];\n\tu16 ptcfg = 0;\n\n\tptcfg |= HR_PTCFG_LEARNING_EN | HR_PTCFG_ADMIN_EN;\n\n\tmutex_lock(&hellcreek->reg_lock);\n\n\thellcreek_select_port(hellcreek, CPU_PORT);\n\thellcreek_write(hellcreek, ptcfg, HR_PTCFG);\n\n\thellcreek_select_port(hellcreek, TUNNEL_PORT);\n\thellcreek_write(hellcreek, ptcfg, HR_PTCFG);\n\n\tcpu_port->ptcfg\t   = ptcfg;\n\ttunnel_port->ptcfg = ptcfg;\n\n\tmutex_unlock(&hellcreek->reg_lock);\n}\n\nstatic void hellcreek_setup_tc_identity_mapping(struct hellcreek *hellcreek)\n{\n\tint i;\n\n\t \n\n\tfor (i = 0; i < 8; ++i) {\n\t\tmutex_lock(&hellcreek->reg_lock);\n\n\t\thellcreek_select_prio(hellcreek, i);\n\t\thellcreek_write(hellcreek,\n\t\t\t\ti << HR_PRTCCFG_PCP_TC_MAP_SHIFT,\n\t\t\t\tHR_PRTCCFG);\n\n\t\tmutex_unlock(&hellcreek->reg_lock);\n\t}\n}\n\nstatic int hellcreek_setup_fdb(struct hellcreek *hellcreek)\n{\n\tstatic struct hellcreek_fdb_entry l2_ptp = {\n\t\t \n\t\t.mac\t      = { 0x01, 0x1b, 0x19, 0x00, 0x00, 0x00 },\n\t\t.portmask     = 0x03,\t \n\t\t.age\t      = 0,\n\t\t.is_obt\t      = 0,\n\t\t.pass_blocked = 0,\n\t\t.is_static    = 1,\n\t\t.reprio_tc    = 6,\t \n\t\t.reprio_en    = 1,\n\t};\n\tstatic struct hellcreek_fdb_entry udp4_ptp = {\n\t\t \n\t\t.mac\t      = { 0x01, 0x00, 0x5e, 0x00, 0x01, 0x81 },\n\t\t.portmask     = 0x03,\t \n\t\t.age\t      = 0,\n\t\t.is_obt\t      = 0,\n\t\t.pass_blocked = 0,\n\t\t.is_static    = 1,\n\t\t.reprio_tc    = 6,\n\t\t.reprio_en    = 1,\n\t};\n\tstatic struct hellcreek_fdb_entry udp6_ptp = {\n\t\t \n\t\t.mac\t      = { 0x33, 0x33, 0x00, 0x00, 0x01, 0x81 },\n\t\t.portmask     = 0x03,\t \n\t\t.age\t      = 0,\n\t\t.is_obt\t      = 0,\n\t\t.pass_blocked = 0,\n\t\t.is_static    = 1,\n\t\t.reprio_tc    = 6,\n\t\t.reprio_en    = 1,\n\t};\n\tstatic struct hellcreek_fdb_entry l2_p2p = {\n\t\t \n\t\t.mac\t      = { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x0e },\n\t\t.portmask     = 0x03,\t \n\t\t.age\t      = 0,\n\t\t.is_obt\t      = 0,\n\t\t.pass_blocked = 1,\n\t\t.is_static    = 1,\n\t\t.reprio_tc    = 6,\t \n\t\t.reprio_en    = 1,\n\t};\n\tstatic struct hellcreek_fdb_entry udp4_p2p = {\n\t\t \n\t\t.mac\t      = { 0x01, 0x00, 0x5e, 0x00, 0x00, 0x6b },\n\t\t.portmask     = 0x03,\t \n\t\t.age\t      = 0,\n\t\t.is_obt\t      = 0,\n\t\t.pass_blocked = 1,\n\t\t.is_static    = 1,\n\t\t.reprio_tc    = 6,\n\t\t.reprio_en    = 1,\n\t};\n\tstatic struct hellcreek_fdb_entry udp6_p2p = {\n\t\t \n\t\t.mac\t      = { 0x33, 0x33, 0x00, 0x00, 0x00, 0x6b },\n\t\t.portmask     = 0x03,\t \n\t\t.age\t      = 0,\n\t\t.is_obt\t      = 0,\n\t\t.pass_blocked = 1,\n\t\t.is_static    = 1,\n\t\t.reprio_tc    = 6,\n\t\t.reprio_en    = 1,\n\t};\n\tstatic struct hellcreek_fdb_entry stp = {\n\t\t \n\t\t.mac\t      = { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x00 },\n\t\t.portmask     = 0x03,\t \n\t\t.age\t      = 0,\n\t\t.is_obt\t      = 0,\n\t\t.pass_blocked = 1,\n\t\t.is_static    = 1,\n\t\t.reprio_tc    = 6,\n\t\t.reprio_en    = 1,\n\t};\n\tint ret;\n\n\tmutex_lock(&hellcreek->reg_lock);\n\tret = __hellcreek_fdb_add(hellcreek, &l2_ptp);\n\tif (ret)\n\t\tgoto out;\n\tret = __hellcreek_fdb_add(hellcreek, &udp4_ptp);\n\tif (ret)\n\t\tgoto out;\n\tret = __hellcreek_fdb_add(hellcreek, &udp6_ptp);\n\tif (ret)\n\t\tgoto out;\n\tret = __hellcreek_fdb_add(hellcreek, &l2_p2p);\n\tif (ret)\n\t\tgoto out;\n\tret = __hellcreek_fdb_add(hellcreek, &udp4_p2p);\n\tif (ret)\n\t\tgoto out;\n\tret = __hellcreek_fdb_add(hellcreek, &udp6_p2p);\n\tif (ret)\n\t\tgoto out;\n\tret = __hellcreek_fdb_add(hellcreek, &stp);\nout:\n\tmutex_unlock(&hellcreek->reg_lock);\n\n\treturn ret;\n}\n\nstatic int hellcreek_devlink_info_get(struct dsa_switch *ds,\n\t\t\t\t      struct devlink_info_req *req,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct hellcreek *hellcreek = ds->priv;\n\n\treturn devlink_info_version_fixed_put(req,\n\t\t\t\t\t      DEVLINK_INFO_VERSION_GENERIC_ASIC_ID,\n\t\t\t\t\t      hellcreek->pdata->name);\n}\n\nstatic u64 hellcreek_devlink_vlan_table_get(void *priv)\n{\n\tstruct hellcreek *hellcreek = priv;\n\tu64 count = 0;\n\tint i;\n\n\tmutex_lock(&hellcreek->reg_lock);\n\tfor (i = 0; i < VLAN_N_VID; ++i)\n\t\tif (hellcreek->vidmbrcfg[i])\n\t\t\tcount++;\n\tmutex_unlock(&hellcreek->reg_lock);\n\n\treturn count;\n}\n\nstatic u64 hellcreek_devlink_fdb_table_get(void *priv)\n{\n\tstruct hellcreek *hellcreek = priv;\n\tu64 count = 0;\n\n\t \n\tmutex_lock(&hellcreek->reg_lock);\n\tcount = hellcreek_read(hellcreek, HR_FDBMAX);\n\tmutex_unlock(&hellcreek->reg_lock);\n\n\treturn count;\n}\n\nstatic int hellcreek_setup_devlink_resources(struct dsa_switch *ds)\n{\n\tstruct devlink_resource_size_params size_vlan_params;\n\tstruct devlink_resource_size_params size_fdb_params;\n\tstruct hellcreek *hellcreek = ds->priv;\n\tint err;\n\n\tdevlink_resource_size_params_init(&size_vlan_params, VLAN_N_VID,\n\t\t\t\t\t  VLAN_N_VID,\n\t\t\t\t\t  1, DEVLINK_RESOURCE_UNIT_ENTRY);\n\n\tdevlink_resource_size_params_init(&size_fdb_params,\n\t\t\t\t\t  hellcreek->fdb_entries,\n\t\t\t\t\t  hellcreek->fdb_entries,\n\t\t\t\t\t  1, DEVLINK_RESOURCE_UNIT_ENTRY);\n\n\terr = dsa_devlink_resource_register(ds, \"VLAN\", VLAN_N_VID,\n\t\t\t\t\t    HELLCREEK_DEVLINK_PARAM_ID_VLAN_TABLE,\n\t\t\t\t\t    DEVLINK_RESOURCE_ID_PARENT_TOP,\n\t\t\t\t\t    &size_vlan_params);\n\tif (err)\n\t\tgoto out;\n\n\terr = dsa_devlink_resource_register(ds, \"FDB\", hellcreek->fdb_entries,\n\t\t\t\t\t    HELLCREEK_DEVLINK_PARAM_ID_FDB_TABLE,\n\t\t\t\t\t    DEVLINK_RESOURCE_ID_PARENT_TOP,\n\t\t\t\t\t    &size_fdb_params);\n\tif (err)\n\t\tgoto out;\n\n\tdsa_devlink_resource_occ_get_register(ds,\n\t\t\t\t\t      HELLCREEK_DEVLINK_PARAM_ID_VLAN_TABLE,\n\t\t\t\t\t      hellcreek_devlink_vlan_table_get,\n\t\t\t\t\t      hellcreek);\n\n\tdsa_devlink_resource_occ_get_register(ds,\n\t\t\t\t\t      HELLCREEK_DEVLINK_PARAM_ID_FDB_TABLE,\n\t\t\t\t\t      hellcreek_devlink_fdb_table_get,\n\t\t\t\t\t      hellcreek);\n\n\treturn 0;\n\nout:\n\tdsa_devlink_resources_unregister(ds);\n\n\treturn err;\n}\n\nstatic int hellcreek_devlink_region_vlan_snapshot(struct devlink *dl,\n\t\t\t\t\t\t  const struct devlink_region_ops *ops,\n\t\t\t\t\t\t  struct netlink_ext_ack *extack,\n\t\t\t\t\t\t  u8 **data)\n{\n\tstruct hellcreek_devlink_vlan_entry *table, *entry;\n\tstruct dsa_switch *ds = dsa_devlink_to_ds(dl);\n\tstruct hellcreek *hellcreek = ds->priv;\n\tint i;\n\n\ttable = kcalloc(VLAN_N_VID, sizeof(*entry), GFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\tentry = table;\n\n\tmutex_lock(&hellcreek->reg_lock);\n\tfor (i = 0; i < VLAN_N_VID; ++i, ++entry) {\n\t\tentry->member = hellcreek->vidmbrcfg[i];\n\t\tentry->vid    = i;\n\t}\n\tmutex_unlock(&hellcreek->reg_lock);\n\n\t*data = (u8 *)table;\n\n\treturn 0;\n}\n\nstatic int hellcreek_devlink_region_fdb_snapshot(struct devlink *dl,\n\t\t\t\t\t\t const struct devlink_region_ops *ops,\n\t\t\t\t\t\t struct netlink_ext_ack *extack,\n\t\t\t\t\t\t u8 **data)\n{\n\tstruct dsa_switch *ds = dsa_devlink_to_ds(dl);\n\tstruct hellcreek_fdb_entry *table, *entry;\n\tstruct hellcreek *hellcreek = ds->priv;\n\tsize_t i;\n\n\ttable = kcalloc(hellcreek->fdb_entries, sizeof(*entry), GFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\tentry = table;\n\n\tmutex_lock(&hellcreek->reg_lock);\n\n\t \n\thellcreek_read(hellcreek, HR_FDBMAX);\n\thellcreek_write(hellcreek, 0x00, HR_FDBMAX);\n\n\tfor (i = 0; i < hellcreek->fdb_entries; ++i, ++entry) {\n\t\t \n\t\thellcreek_populate_fdb_entry(hellcreek, entry, i);\n\n\t\t \n\t\thellcreek_write(hellcreek, 0x00, HR_FDBRDH);\n\t}\n\n\tmutex_unlock(&hellcreek->reg_lock);\n\n\t*data = (u8 *)table;\n\n\treturn 0;\n}\n\nstatic struct devlink_region_ops hellcreek_region_vlan_ops = {\n\t.name\t    = \"vlan\",\n\t.snapshot   = hellcreek_devlink_region_vlan_snapshot,\n\t.destructor = kfree,\n};\n\nstatic struct devlink_region_ops hellcreek_region_fdb_ops = {\n\t.name\t    = \"fdb\",\n\t.snapshot   = hellcreek_devlink_region_fdb_snapshot,\n\t.destructor = kfree,\n};\n\nstatic int hellcreek_setup_devlink_regions(struct dsa_switch *ds)\n{\n\tstruct hellcreek *hellcreek = ds->priv;\n\tstruct devlink_region_ops *ops;\n\tstruct devlink_region *region;\n\tu64 size;\n\tint ret;\n\n\t \n\tsize = VLAN_N_VID * sizeof(struct hellcreek_devlink_vlan_entry);\n\tops  = &hellcreek_region_vlan_ops;\n\n\tregion = dsa_devlink_region_create(ds, ops, 1, size);\n\tif (IS_ERR(region))\n\t\treturn PTR_ERR(region);\n\n\thellcreek->vlan_region = region;\n\n\t \n\tsize = hellcreek->fdb_entries * sizeof(struct hellcreek_fdb_entry);\n\tops  = &hellcreek_region_fdb_ops;\n\n\tregion = dsa_devlink_region_create(ds, ops, 1, size);\n\tif (IS_ERR(region)) {\n\t\tret = PTR_ERR(region);\n\t\tgoto err_fdb;\n\t}\n\n\thellcreek->fdb_region = region;\n\n\treturn 0;\n\nerr_fdb:\n\tdsa_devlink_region_destroy(hellcreek->vlan_region);\n\n\treturn ret;\n}\n\nstatic void hellcreek_teardown_devlink_regions(struct dsa_switch *ds)\n{\n\tstruct hellcreek *hellcreek = ds->priv;\n\n\tdsa_devlink_region_destroy(hellcreek->fdb_region);\n\tdsa_devlink_region_destroy(hellcreek->vlan_region);\n}\n\nstatic int hellcreek_setup(struct dsa_switch *ds)\n{\n\tstruct hellcreek *hellcreek = ds->priv;\n\tu16 swcfg = 0;\n\tint ret, i;\n\n\tdev_dbg(hellcreek->dev, \"Set up the switch\\n\");\n\n\t \n\tret = hellcreek_enable_ip_core(hellcreek);\n\tif (ret) {\n\t\tdev_err(hellcreek->dev, \"Failed to enable IP core!\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\thellcreek_setup_cpu_and_tunnel_port(hellcreek);\n\n\t \n\tswcfg |= HR_SWCFG_FDBAGE_EN |\n\t\tHR_SWCFG_FDBLRN_EN  |\n\t\tHR_SWCFG_ALWAYS_OBT |\n\t\t(HR_SWCFG_LAS_ON << HR_SWCFG_LAS_MODE_SHIFT);\n\thellcreek->swcfg = swcfg;\n\thellcreek_write(hellcreek, swcfg, HR_SWCFG);\n\n\t \n\tfor (i = 0; i < ds->num_ports; ++i) {\n\t\tif (!dsa_is_user_port(ds, i))\n\t\t\tcontinue;\n\n\t\thellcreek_setup_vlan_membership(ds, i, true);\n\t}\n\n\t \n\thellcreek_setup_tc_identity_mapping(hellcreek);\n\n\t \n\tds->vlan_filtering_is_global = true;\n\tds->needs_standalone_vlan_filtering = true;\n\n\t \n\tret = hellcreek_setup_fdb(hellcreek);\n\tif (ret) {\n\t\tdev_err(hellcreek->dev,\n\t\t\t\"Failed to insert static PTP FDB entries\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = hellcreek_setup_devlink_resources(ds);\n\tif (ret) {\n\t\tdev_err(hellcreek->dev,\n\t\t\t\"Failed to setup devlink resources!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hellcreek_setup_devlink_regions(ds);\n\tif (ret) {\n\t\tdev_err(hellcreek->dev,\n\t\t\t\"Failed to setup devlink regions!\\n\");\n\t\tgoto err_regions;\n\t}\n\n\treturn 0;\n\nerr_regions:\n\tdsa_devlink_resources_unregister(ds);\n\n\treturn ret;\n}\n\nstatic void hellcreek_teardown(struct dsa_switch *ds)\n{\n\thellcreek_teardown_devlink_regions(ds);\n\tdsa_devlink_resources_unregister(ds);\n}\n\nstatic void hellcreek_phylink_get_caps(struct dsa_switch *ds, int port,\n\t\t\t\t       struct phylink_config *config)\n{\n\tstruct hellcreek *hellcreek = ds->priv;\n\n\t__set_bit(PHY_INTERFACE_MODE_MII, config->supported_interfaces);\n\t__set_bit(PHY_INTERFACE_MODE_RGMII, config->supported_interfaces);\n\n\t \n\t__set_bit(PHY_INTERFACE_MODE_GMII, config->supported_interfaces);\n\n\t \n\tif (hellcreek->pdata->is_100_mbits)\n\t\tconfig->mac_capabilities = MAC_100FD;\n\telse\n\t\tconfig->mac_capabilities = MAC_1000FD;\n}\n\nstatic int\nhellcreek_port_prechangeupper(struct dsa_switch *ds, int port,\n\t\t\t      struct netdev_notifier_changeupper_info *info)\n{\n\tstruct hellcreek *hellcreek = ds->priv;\n\tbool used = true;\n\tint ret = -EBUSY;\n\tu16 vid;\n\tint i;\n\n\tdev_dbg(hellcreek->dev, \"Pre change upper for port %d\\n\", port);\n\n\t \n\n\tif (!is_vlan_dev(info->upper_dev))\n\t\treturn 0;\n\n\tvid = vlan_dev_vlan_id(info->upper_dev);\n\n\t \n\tmutex_lock(&hellcreek->vlan_lock);\n\tfor (i = 0; i < hellcreek->pdata->num_ports; ++i) {\n\t\tif (!dsa_is_user_port(ds, i))\n\t\t\tcontinue;\n\n\t\tif (port == i)\n\t\t\tcontinue;\n\n\t\tused = used && test_bit(vid, hellcreek->ports[i].vlan_dev_bitmap);\n\t}\n\n\tif (used)\n\t\tgoto out;\n\n\t \n\tset_bit(vid, hellcreek->ports[port].vlan_dev_bitmap);\n\n\tret = 0;\n\nout:\n\tmutex_unlock(&hellcreek->vlan_lock);\n\n\treturn ret;\n}\n\nstatic void hellcreek_setup_maxsdu(struct hellcreek *hellcreek, int port,\n\t\t\t\t   const struct tc_taprio_qopt_offload *schedule)\n{\n\tint tc;\n\n\tfor (tc = 0; tc < 8; ++tc) {\n\t\tu32 max_sdu = schedule->max_sdu[tc] + VLAN_ETH_HLEN - ETH_FCS_LEN;\n\t\tu16 val;\n\n\t\tif (!schedule->max_sdu[tc])\n\t\t\tcontinue;\n\n\t\tdev_dbg(hellcreek->dev, \"Configure max-sdu %u for tc %d on port %d\\n\",\n\t\t\tmax_sdu, tc, port);\n\n\t\thellcreek_select_port_prio(hellcreek, port, tc);\n\n\t\tval = (max_sdu & HR_PTPRTCCFG_MAXSDU_MASK) << HR_PTPRTCCFG_MAXSDU_SHIFT;\n\n\t\thellcreek_write(hellcreek, val, HR_PTPRTCCFG);\n\t}\n}\n\nstatic void hellcreek_reset_maxsdu(struct hellcreek *hellcreek, int port)\n{\n\tint tc;\n\n\tfor (tc = 0; tc < 8; ++tc) {\n\t\tu16 val;\n\n\t\thellcreek_select_port_prio(hellcreek, port, tc);\n\n\t\tval = (HELLCREEK_DEFAULT_MAX_SDU & HR_PTPRTCCFG_MAXSDU_MASK)\n\t\t\t<< HR_PTPRTCCFG_MAXSDU_SHIFT;\n\n\t\thellcreek_write(hellcreek, val, HR_PTPRTCCFG);\n\t}\n}\n\nstatic void hellcreek_setup_gcl(struct hellcreek *hellcreek, int port,\n\t\t\t\tconst struct tc_taprio_qopt_offload *schedule)\n{\n\tconst struct tc_taprio_sched_entry *cur, *initial, *next;\n\tsize_t i;\n\n\tcur = initial = &schedule->entries[0];\n\tnext = cur + 1;\n\n\tfor (i = 1; i <= schedule->num_entries; ++i) {\n\t\tu16 data;\n\t\tu8 gates;\n\n\t\tif (i == schedule->num_entries)\n\t\t\tgates = initial->gate_mask ^\n\t\t\t\tcur->gate_mask;\n\t\telse\n\t\t\tgates = next->gate_mask ^\n\t\t\t\tcur->gate_mask;\n\n\t\tdata = gates;\n\n\t\tif (i == schedule->num_entries)\n\t\t\tdata |= TR_GCLDAT_GCLWRLAST;\n\n\t\t \n\t\thellcreek_write(hellcreek, data, TR_GCLDAT);\n\n\t\t \n\t\thellcreek_write(hellcreek,\n\t\t\t\tcur->interval & 0x0000ffff,\n\t\t\t\tTR_GCLTIL);\n\t\thellcreek_write(hellcreek,\n\t\t\t\t(cur->interval & 0xffff0000) >> 16,\n\t\t\t\tTR_GCLTIH);\n\n\t\t \n\t\tdata = ((i - 1) << TR_GCLCMD_GCLWRADR_SHIFT) |\n\t\t\t(initial->gate_mask <<\n\t\t\t TR_GCLCMD_INIT_GATE_STATES_SHIFT);\n\t\thellcreek_write(hellcreek, data, TR_GCLCMD);\n\n\t\tcur++;\n\t\tnext++;\n\t}\n}\n\nstatic void hellcreek_set_cycle_time(struct hellcreek *hellcreek,\n\t\t\t\t     const struct tc_taprio_qopt_offload *schedule)\n{\n\tu32 cycle_time = schedule->cycle_time;\n\n\thellcreek_write(hellcreek, cycle_time & 0x0000ffff, TR_CTWRL);\n\thellcreek_write(hellcreek, (cycle_time & 0xffff0000) >> 16, TR_CTWRH);\n}\n\nstatic void hellcreek_switch_schedule(struct hellcreek *hellcreek,\n\t\t\t\t      ktime_t start_time)\n{\n\tstruct timespec64 ts = ktime_to_timespec64(start_time);\n\n\t \n\thellcreek_write(hellcreek, ts.tv_nsec & 0x0000ffff, TR_ESTWRL);\n\thellcreek_write(hellcreek, (ts.tv_nsec & 0xffff0000) >> 16, TR_ESTWRH);\n\n\t \n\thellcreek_write(hellcreek, TR_ESTCMD_ESTARM | TR_ESTCMD_ESTSWCFG |\n\t\t\t((ts.tv_sec & TR_ESTCMD_ESTSEC_MASK) <<\n\t\t\t TR_ESTCMD_ESTSEC_SHIFT), TR_ESTCMD);\n}\n\nstatic bool hellcreek_schedule_startable(struct hellcreek *hellcreek, int port)\n{\n\tstruct hellcreek_port *hellcreek_port = &hellcreek->ports[port];\n\ts64 base_time_ns, current_ns;\n\n\t \n\n\t \n\tmutex_lock(&hellcreek->ptp_lock);\n\tcurrent_ns = hellcreek->seconds * NSEC_PER_SEC + hellcreek->last_ts;\n\tmutex_unlock(&hellcreek->ptp_lock);\n\n\t \n\tbase_time_ns = ktime_to_ns(hellcreek_port->current_schedule->base_time);\n\n\treturn base_time_ns - current_ns < (s64)4 * NSEC_PER_SEC;\n}\n\nstatic void hellcreek_start_schedule(struct hellcreek *hellcreek, int port)\n{\n\tstruct hellcreek_port *hellcreek_port = &hellcreek->ports[port];\n\tktime_t base_time, current_time;\n\ts64 current_ns;\n\tu32 cycle_time;\n\n\t \n\thellcreek_select_tgd(hellcreek, port);\n\n\t \n\tmutex_lock(&hellcreek->ptp_lock);\n\tcurrent_ns = hellcreek->seconds * NSEC_PER_SEC + hellcreek->last_ts;\n\tmutex_unlock(&hellcreek->ptp_lock);\n\n\tcurrent_time = ns_to_ktime(current_ns);\n\tbase_time    = hellcreek_port->current_schedule->base_time;\n\tcycle_time   = hellcreek_port->current_schedule->cycle_time;\n\n\tif (ktime_compare(current_time, base_time) > 0) {\n\t\ts64 n;\n\n\t\tn = div64_s64(ktime_sub_ns(current_time, base_time),\n\t\t\t      cycle_time);\n\t\tbase_time = ktime_add_ns(base_time, (n + 1) * cycle_time);\n\t}\n\n\t \n\thellcreek_switch_schedule(hellcreek, base_time);\n\n\ttaprio_offload_free(hellcreek_port->current_schedule);\n\thellcreek_port->current_schedule = NULL;\n\n\tdev_dbg(hellcreek->dev, \"Armed EST timer for port %d\\n\",\n\t\thellcreek_port->port);\n}\n\nstatic void hellcreek_check_schedule(struct work_struct *work)\n{\n\tstruct delayed_work *dw = to_delayed_work(work);\n\tstruct hellcreek_port *hellcreek_port;\n\tstruct hellcreek *hellcreek;\n\tbool startable;\n\n\thellcreek_port = dw_to_hellcreek_port(dw);\n\thellcreek = hellcreek_port->hellcreek;\n\n\tmutex_lock(&hellcreek->reg_lock);\n\n\t \n\tstartable = hellcreek_schedule_startable(hellcreek,\n\t\t\t\t\t\t hellcreek_port->port);\n\tif (startable) {\n\t\thellcreek_start_schedule(hellcreek, hellcreek_port->port);\n\t\tmutex_unlock(&hellcreek->reg_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&hellcreek->reg_lock);\n\n\t \n\tschedule_delayed_work(&hellcreek_port->schedule_work,\n\t\t\t      HELLCREEK_SCHEDULE_PERIOD);\n}\n\nstatic int hellcreek_port_set_schedule(struct dsa_switch *ds, int port,\n\t\t\t\t       struct tc_taprio_qopt_offload *taprio)\n{\n\tstruct hellcreek *hellcreek = ds->priv;\n\tstruct hellcreek_port *hellcreek_port;\n\tbool startable;\n\tu16 ctrl;\n\n\thellcreek_port = &hellcreek->ports[port];\n\n\tdev_dbg(hellcreek->dev, \"Configure traffic schedule on port %d\\n\",\n\t\tport);\n\n\t \n\tcancel_delayed_work_sync(&hellcreek_port->schedule_work);\n\n\tmutex_lock(&hellcreek->reg_lock);\n\n\tif (hellcreek_port->current_schedule) {\n\t\ttaprio_offload_free(hellcreek_port->current_schedule);\n\t\thellcreek_port->current_schedule = NULL;\n\t}\n\thellcreek_port->current_schedule = taprio_offload_get(taprio);\n\n\t \n\thellcreek_setup_maxsdu(hellcreek, port, hellcreek_port->current_schedule);\n\n\t \n\thellcreek_select_tgd(hellcreek, port);\n\n\t \n\tctrl = (0xff << TR_TGDCTRL_ADMINGATESTATES_SHIFT) | TR_TGDCTRL_GATE_EN;\n\thellcreek_write(hellcreek, ctrl, TR_TGDCTRL);\n\n\t \n\thellcreek_write(hellcreek, 0x00, TR_ESTCMD);\n\n\t \n\thellcreek_setup_gcl(hellcreek, port, hellcreek_port->current_schedule);\n\n\t \n\thellcreek_set_cycle_time(hellcreek, hellcreek_port->current_schedule);\n\n\t \n\tstartable = hellcreek_schedule_startable(hellcreek, port);\n\tif (startable) {\n\t\thellcreek_start_schedule(hellcreek, port);\n\t\tmutex_unlock(&hellcreek->reg_lock);\n\t\treturn 0;\n\t}\n\n\tmutex_unlock(&hellcreek->reg_lock);\n\n\t \n\tschedule_delayed_work(&hellcreek_port->schedule_work,\n\t\t\t      HELLCREEK_SCHEDULE_PERIOD);\n\n\treturn 0;\n}\n\nstatic int hellcreek_port_del_schedule(struct dsa_switch *ds, int port)\n{\n\tstruct hellcreek *hellcreek = ds->priv;\n\tstruct hellcreek_port *hellcreek_port;\n\n\thellcreek_port = &hellcreek->ports[port];\n\n\tdev_dbg(hellcreek->dev, \"Remove traffic schedule on port %d\\n\", port);\n\n\t \n\tcancel_delayed_work_sync(&hellcreek_port->schedule_work);\n\n\tmutex_lock(&hellcreek->reg_lock);\n\n\tif (hellcreek_port->current_schedule) {\n\t\ttaprio_offload_free(hellcreek_port->current_schedule);\n\t\thellcreek_port->current_schedule = NULL;\n\t}\n\n\t \n\thellcreek_reset_maxsdu(hellcreek, port);\n\n\t \n\thellcreek_select_tgd(hellcreek, port);\n\n\t \n\thellcreek_write(hellcreek, 0xff << TR_TGDCTRL_ADMINGATESTATES_SHIFT,\n\t\t\tTR_TGDCTRL);\n\n\tmutex_unlock(&hellcreek->reg_lock);\n\n\treturn 0;\n}\n\nstatic bool hellcreek_validate_schedule(struct hellcreek *hellcreek,\n\t\t\t\t\tstruct tc_taprio_qopt_offload *schedule)\n{\n\tsize_t i;\n\n\t \n\tif (!hellcreek->pdata->qbv_support)\n\t\treturn false;\n\n\t \n\tif (schedule->cycle_time > (u32)-1)\n\t\treturn false;\n\n\t \n\tif (schedule->cycle_time_extension)\n\t\treturn false;\n\n\t \n\tfor (i = 0; i < schedule->num_entries; ++i)\n\t\tif (schedule->entries[i].command != TC_TAPRIO_CMD_SET_GATES)\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic int hellcreek_tc_query_caps(struct tc_query_caps_base *base)\n{\n\tswitch (base->type) {\n\tcase TC_SETUP_QDISC_TAPRIO: {\n\t\tstruct tc_taprio_caps *caps = base->caps;\n\n\t\tcaps->supports_queue_max_sdu = true;\n\n\t\treturn 0;\n\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int hellcreek_port_setup_tc(struct dsa_switch *ds, int port,\n\t\t\t\t   enum tc_setup_type type, void *type_data)\n{\n\tstruct hellcreek *hellcreek = ds->priv;\n\n\tswitch (type) {\n\tcase TC_QUERY_CAPS:\n\t\treturn hellcreek_tc_query_caps(type_data);\n\tcase TC_SETUP_QDISC_TAPRIO: {\n\t\tstruct tc_taprio_qopt_offload *taprio = type_data;\n\n\t\tswitch (taprio->cmd) {\n\t\tcase TAPRIO_CMD_REPLACE:\n\t\t\tif (!hellcreek_validate_schedule(hellcreek, taprio))\n\t\t\t\treturn -EOPNOTSUPP;\n\n\t\t\treturn hellcreek_port_set_schedule(ds, port, taprio);\n\t\tcase TAPRIO_CMD_DESTROY:\n\t\t\treturn hellcreek_port_del_schedule(ds, port);\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct dsa_switch_ops hellcreek_ds_ops = {\n\t.devlink_info_get      = hellcreek_devlink_info_get,\n\t.get_ethtool_stats     = hellcreek_get_ethtool_stats,\n\t.get_sset_count\t       = hellcreek_get_sset_count,\n\t.get_strings\t       = hellcreek_get_strings,\n\t.get_tag_protocol      = hellcreek_get_tag_protocol,\n\t.get_ts_info\t       = hellcreek_get_ts_info,\n\t.phylink_get_caps      = hellcreek_phylink_get_caps,\n\t.port_bridge_flags     = hellcreek_bridge_flags,\n\t.port_bridge_join      = hellcreek_port_bridge_join,\n\t.port_bridge_leave     = hellcreek_port_bridge_leave,\n\t.port_disable\t       = hellcreek_port_disable,\n\t.port_enable\t       = hellcreek_port_enable,\n\t.port_fdb_add\t       = hellcreek_fdb_add,\n\t.port_fdb_del\t       = hellcreek_fdb_del,\n\t.port_fdb_dump\t       = hellcreek_fdb_dump,\n\t.port_hwtstamp_set     = hellcreek_port_hwtstamp_set,\n\t.port_hwtstamp_get     = hellcreek_port_hwtstamp_get,\n\t.port_pre_bridge_flags = hellcreek_pre_bridge_flags,\n\t.port_prechangeupper   = hellcreek_port_prechangeupper,\n\t.port_rxtstamp\t       = hellcreek_port_rxtstamp,\n\t.port_setup_tc\t       = hellcreek_port_setup_tc,\n\t.port_stp_state_set    = hellcreek_port_stp_state_set,\n\t.port_txtstamp\t       = hellcreek_port_txtstamp,\n\t.port_vlan_add\t       = hellcreek_vlan_add,\n\t.port_vlan_del\t       = hellcreek_vlan_del,\n\t.port_vlan_filtering   = hellcreek_vlan_filtering,\n\t.setup\t\t       = hellcreek_setup,\n\t.teardown\t       = hellcreek_teardown,\n};\n\nstatic int hellcreek_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct hellcreek *hellcreek;\n\tstruct resource *res;\n\tint ret, i;\n\n\thellcreek = devm_kzalloc(dev, sizeof(*hellcreek), GFP_KERNEL);\n\tif (!hellcreek)\n\t\treturn -ENOMEM;\n\n\thellcreek->vidmbrcfg = devm_kcalloc(dev, VLAN_N_VID,\n\t\t\t\t\t    sizeof(*hellcreek->vidmbrcfg),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!hellcreek->vidmbrcfg)\n\t\treturn -ENOMEM;\n\n\thellcreek->pdata = of_device_get_match_data(dev);\n\n\thellcreek->ports = devm_kcalloc(dev, hellcreek->pdata->num_ports,\n\t\t\t\t\tsizeof(*hellcreek->ports),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!hellcreek->ports)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < hellcreek->pdata->num_ports; ++i) {\n\t\tstruct hellcreek_port *port = &hellcreek->ports[i];\n\n\t\tport->counter_values =\n\t\t\tdevm_kcalloc(dev,\n\t\t\t\t     ARRAY_SIZE(hellcreek_counter),\n\t\t\t\t     sizeof(*port->counter_values),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!port->counter_values)\n\t\t\treturn -ENOMEM;\n\n\t\tport->vlan_dev_bitmap = devm_bitmap_zalloc(dev, VLAN_N_VID,\n\t\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!port->vlan_dev_bitmap)\n\t\t\treturn -ENOMEM;\n\n\t\tport->hellcreek\t= hellcreek;\n\t\tport->port\t= i;\n\n\t\tINIT_DELAYED_WORK(&port->schedule_work,\n\t\t\t\t  hellcreek_check_schedule);\n\t}\n\n\tmutex_init(&hellcreek->reg_lock);\n\tmutex_init(&hellcreek->vlan_lock);\n\tmutex_init(&hellcreek->ptp_lock);\n\n\thellcreek->dev = dev;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"tsn\");\n\tif (!res) {\n\t\tdev_err(dev, \"No memory region provided!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\thellcreek->base = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(hellcreek->base))\n\t\treturn PTR_ERR(hellcreek->base);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"ptp\");\n\tif (!res) {\n\t\tdev_err(dev, \"No PTP memory region provided!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\thellcreek->ptp_base = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(hellcreek->ptp_base))\n\t\treturn PTR_ERR(hellcreek->ptp_base);\n\n\tret = hellcreek_detect(hellcreek);\n\tif (ret) {\n\t\tdev_err(dev, \"No (known) chip found!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hellcreek_wait_until_ready(hellcreek);\n\tif (ret) {\n\t\tdev_err(dev, \"Switch didn't become ready!\\n\");\n\t\treturn ret;\n\t}\n\n\thellcreek_feature_detect(hellcreek);\n\n\thellcreek->ds = devm_kzalloc(dev, sizeof(*hellcreek->ds), GFP_KERNEL);\n\tif (!hellcreek->ds)\n\t\treturn -ENOMEM;\n\n\thellcreek->ds->dev\t     = dev;\n\thellcreek->ds->priv\t     = hellcreek;\n\thellcreek->ds->ops\t     = &hellcreek_ds_ops;\n\thellcreek->ds->num_ports     = hellcreek->pdata->num_ports;\n\thellcreek->ds->num_tx_queues = HELLCREEK_NUM_EGRESS_QUEUES;\n\n\tret = dsa_register_switch(hellcreek->ds);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"Unable to register switch\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hellcreek_ptp_setup(hellcreek);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to setup PTP!\\n\");\n\t\tgoto err_ptp_setup;\n\t}\n\n\tret = hellcreek_hwtstamp_setup(hellcreek);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to setup hardware timestamping!\\n\");\n\t\tgoto err_tstamp_setup;\n\t}\n\n\tplatform_set_drvdata(pdev, hellcreek);\n\n\treturn 0;\n\nerr_tstamp_setup:\n\thellcreek_ptp_free(hellcreek);\nerr_ptp_setup:\n\tdsa_unregister_switch(hellcreek->ds);\n\n\treturn ret;\n}\n\nstatic int hellcreek_remove(struct platform_device *pdev)\n{\n\tstruct hellcreek *hellcreek = platform_get_drvdata(pdev);\n\n\tif (!hellcreek)\n\t\treturn 0;\n\n\thellcreek_hwtstamp_free(hellcreek);\n\thellcreek_ptp_free(hellcreek);\n\tdsa_unregister_switch(hellcreek->ds);\n\n\treturn 0;\n}\n\nstatic void hellcreek_shutdown(struct platform_device *pdev)\n{\n\tstruct hellcreek *hellcreek = platform_get_drvdata(pdev);\n\n\tif (!hellcreek)\n\t\treturn;\n\n\tdsa_switch_shutdown(hellcreek->ds);\n\n\tplatform_set_drvdata(pdev, NULL);\n}\n\nstatic const struct hellcreek_platform_data de1soc_r1_pdata = {\n\t.name\t\t = \"r4c30\",\n\t.num_ports\t = 4,\n\t.is_100_mbits\t = 1,\n\t.qbv_support\t = 1,\n\t.qbv_on_cpu_port = 1,\n\t.qbu_support\t = 0,\n\t.module_id\t = 0x4c30,\n};\n\nstatic const struct of_device_id hellcreek_of_match[] = {\n\t{\n\t\t.compatible = \"hirschmann,hellcreek-de1soc-r1\",\n\t\t.data\t    = &de1soc_r1_pdata,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, hellcreek_of_match);\n\nstatic struct platform_driver hellcreek_driver = {\n\t.probe\t= hellcreek_probe,\n\t.remove = hellcreek_remove,\n\t.shutdown = hellcreek_shutdown,\n\t.driver = {\n\t\t.name = \"hellcreek\",\n\t\t.of_match_table = hellcreek_of_match,\n\t},\n};\nmodule_platform_driver(hellcreek_driver);\n\nMODULE_AUTHOR(\"Kurt Kanzenbach <kurt@linutronix.de>\");\nMODULE_DESCRIPTION(\"Hirschmann Hellcreek driver\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}