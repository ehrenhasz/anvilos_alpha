{
  "module_name": "hellcreek_ptp.c",
  "hash_id": "0bba239b018a44ed96216399f8e7f37b2356315b708a27d7999b8baaaa6675f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/hirschmann/hellcreek_ptp.c",
  "human_readable_source": "\n \n\n#include <linux/of.h>\n#include <linux/ptp_clock_kernel.h>\n#include \"hellcreek.h\"\n#include \"hellcreek_ptp.h\"\n#include \"hellcreek_hwtstamp.h\"\n\nu16 hellcreek_ptp_read(struct hellcreek *hellcreek, unsigned int offset)\n{\n\treturn readw(hellcreek->ptp_base + offset);\n}\n\nvoid hellcreek_ptp_write(struct hellcreek *hellcreek, u16 data,\n\t\t\t unsigned int offset)\n{\n\twritew(data, hellcreek->ptp_base + offset);\n}\n\n \nstatic u64 hellcreek_ptp_clock_read(struct hellcreek *hellcreek)\n{\n\tu16 nsl, nsh;\n\n\t \n\thellcreek_ptp_write(hellcreek, PR_COMMAND_C_SS, PR_COMMAND_C);\n\n\t \n\tnsh = hellcreek_ptp_read(hellcreek, PR_SS_SYNC_DATA_C);\n\tnsh = hellcreek_ptp_read(hellcreek, PR_SS_SYNC_DATA_C);\n\tnsh = hellcreek_ptp_read(hellcreek, PR_SS_SYNC_DATA_C);\n\tnsh = hellcreek_ptp_read(hellcreek, PR_SS_SYNC_DATA_C);\n\tnsl = hellcreek_ptp_read(hellcreek, PR_SS_SYNC_DATA_C);\n\n\treturn (u64)nsl | ((u64)nsh << 16);\n}\n\nstatic u64 __hellcreek_ptp_gettime(struct hellcreek *hellcreek)\n{\n\tu64 ns;\n\n\tns = hellcreek_ptp_clock_read(hellcreek);\n\tif (ns < hellcreek->last_ts)\n\t\thellcreek->seconds++;\n\thellcreek->last_ts = ns;\n\tns += hellcreek->seconds * NSEC_PER_SEC;\n\n\treturn ns;\n}\n\n \nu64 hellcreek_ptp_gettime_seconds(struct hellcreek *hellcreek, u64 ns)\n{\n\tu64 s;\n\n\t__hellcreek_ptp_gettime(hellcreek);\n\tif (hellcreek->last_ts > ns)\n\t\ts = hellcreek->seconds * NSEC_PER_SEC;\n\telse\n\t\ts = (hellcreek->seconds - 1) * NSEC_PER_SEC;\n\n\treturn s;\n}\n\nstatic int hellcreek_ptp_gettime(struct ptp_clock_info *ptp,\n\t\t\t\t struct timespec64 *ts)\n{\n\tstruct hellcreek *hellcreek = ptp_to_hellcreek(ptp);\n\tu64 ns;\n\n\tmutex_lock(&hellcreek->ptp_lock);\n\tns = __hellcreek_ptp_gettime(hellcreek);\n\tmutex_unlock(&hellcreek->ptp_lock);\n\n\t*ts = ns_to_timespec64(ns);\n\n\treturn 0;\n}\n\nstatic int hellcreek_ptp_settime(struct ptp_clock_info *ptp,\n\t\t\t\t const struct timespec64 *ts)\n{\n\tstruct hellcreek *hellcreek = ptp_to_hellcreek(ptp);\n\tu16 secl, nsh, nsl;\n\n\tsecl = ts->tv_sec & 0xffff;\n\tnsh  = ((u32)ts->tv_nsec & 0xffff0000) >> 16;\n\tnsl  = ts->tv_nsec & 0xffff;\n\n\tmutex_lock(&hellcreek->ptp_lock);\n\n\t \n\thellcreek->seconds = ts->tv_sec;\n\thellcreek->last_ts = ts->tv_nsec;\n\n\t \n\thellcreek_ptp_write(hellcreek, 0x00, PR_CLOCK_WRITE_C);\n\thellcreek_ptp_write(hellcreek, 0x00, PR_CLOCK_WRITE_C);\n\thellcreek_ptp_write(hellcreek, secl, PR_CLOCK_WRITE_C);\n\thellcreek_ptp_write(hellcreek, nsh,  PR_CLOCK_WRITE_C);\n\thellcreek_ptp_write(hellcreek, nsl,  PR_CLOCK_WRITE_C);\n\n\tmutex_unlock(&hellcreek->ptp_lock);\n\n\treturn 0;\n}\n\nstatic int hellcreek_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct hellcreek *hellcreek = ptp_to_hellcreek(ptp);\n\tu16 negative = 0, addendh, addendl;\n\tu32 addend;\n\tu64 adj;\n\n\tif (scaled_ppm < 0) {\n\t\tnegative = 1;\n\t\tscaled_ppm = -scaled_ppm;\n\t}\n\n\t \n\tadj = scaled_ppm;\n\tadj <<= 11;\n\taddend = (u32)div_u64(adj, 15625);\n\n\taddendh = (addend & 0xffff0000) >> 16;\n\taddendl = addend & 0xffff;\n\n\tnegative = (negative << 15) & 0x8000;\n\n\tmutex_lock(&hellcreek->ptp_lock);\n\n\t \n\thellcreek_ptp_write(hellcreek, negative, PR_CLOCK_DRIFT_C);\n\thellcreek_ptp_write(hellcreek, 0x00, PR_CLOCK_DRIFT_C);\n\thellcreek_ptp_write(hellcreek, 0x00, PR_CLOCK_DRIFT_C);\n\thellcreek_ptp_write(hellcreek, addendh,  PR_CLOCK_DRIFT_C);\n\thellcreek_ptp_write(hellcreek, addendl,  PR_CLOCK_DRIFT_C);\n\n\tmutex_unlock(&hellcreek->ptp_lock);\n\n\treturn 0;\n}\n\nstatic int hellcreek_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct hellcreek *hellcreek = ptp_to_hellcreek(ptp);\n\tu16 negative = 0, counth, countl;\n\tu32 count_val;\n\n\t \n\tif (abs(delta) > MAX_SLOW_OFFSET_ADJ) {\n\t\tstruct timespec64 now, then = ns_to_timespec64(delta);\n\n\t\thellcreek_ptp_gettime(ptp, &now);\n\t\tnow = timespec64_add(now, then);\n\t\thellcreek_ptp_settime(ptp, &now);\n\n\t\treturn 0;\n\t}\n\n\tif (delta < 0) {\n\t\tnegative = 1;\n\t\tdelta = -delta;\n\t}\n\n\t \n\tcount_val = div_s64(delta, MAX_NS_PER_STEP);\n\n\tcounth = (count_val & 0xffff0000) >> 16;\n\tcountl = count_val & 0xffff;\n\n\tnegative = (negative << 15) & 0x8000;\n\n\tmutex_lock(&hellcreek->ptp_lock);\n\n\t \n\thellcreek_ptp_write(hellcreek, negative, PR_CLOCK_OFFSET_C);\n\thellcreek_ptp_write(hellcreek, MAX_NS_PER_STEP, PR_CLOCK_OFFSET_C);\n\thellcreek_ptp_write(hellcreek, MIN_CLK_CYCLES_BETWEEN_STEPS,\n\t\t\t    PR_CLOCK_OFFSET_C);\n\thellcreek_ptp_write(hellcreek, countl,  PR_CLOCK_OFFSET_C);\n\thellcreek_ptp_write(hellcreek, counth,  PR_CLOCK_OFFSET_C);\n\n\tmutex_unlock(&hellcreek->ptp_lock);\n\n\treturn 0;\n}\n\nstatic int hellcreek_ptp_enable(struct ptp_clock_info *ptp,\n\t\t\t\tstruct ptp_clock_request *rq, int on)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic void hellcreek_ptp_overflow_check(struct work_struct *work)\n{\n\tstruct delayed_work *dw = to_delayed_work(work);\n\tstruct hellcreek *hellcreek;\n\n\thellcreek = dw_overflow_to_hellcreek(dw);\n\n\tmutex_lock(&hellcreek->ptp_lock);\n\t__hellcreek_ptp_gettime(hellcreek);\n\tmutex_unlock(&hellcreek->ptp_lock);\n\n\tschedule_delayed_work(&hellcreek->overflow_work,\n\t\t\t      HELLCREEK_OVERFLOW_PERIOD);\n}\n\nstatic enum led_brightness hellcreek_get_brightness(struct hellcreek *hellcreek,\n\t\t\t\t\t\t    int led)\n{\n\treturn (hellcreek->status_out & led) ? 1 : 0;\n}\n\nstatic void hellcreek_set_brightness(struct hellcreek *hellcreek, int led,\n\t\t\t\t     enum led_brightness b)\n{\n\tmutex_lock(&hellcreek->ptp_lock);\n\n\tif (b)\n\t\thellcreek->status_out |= led;\n\telse\n\t\thellcreek->status_out &= ~led;\n\n\thellcreek_ptp_write(hellcreek, hellcreek->status_out, STATUS_OUT);\n\n\tmutex_unlock(&hellcreek->ptp_lock);\n}\n\nstatic void hellcreek_led_sync_good_set(struct led_classdev *ldev,\n\t\t\t\t\tenum led_brightness b)\n{\n\tstruct hellcreek *hellcreek = led_to_hellcreek(ldev, led_sync_good);\n\n\thellcreek_set_brightness(hellcreek, STATUS_OUT_SYNC_GOOD, b);\n}\n\nstatic enum led_brightness hellcreek_led_sync_good_get(struct led_classdev *ldev)\n{\n\tstruct hellcreek *hellcreek = led_to_hellcreek(ldev, led_sync_good);\n\n\treturn hellcreek_get_brightness(hellcreek, STATUS_OUT_SYNC_GOOD);\n}\n\nstatic void hellcreek_led_is_gm_set(struct led_classdev *ldev,\n\t\t\t\t    enum led_brightness b)\n{\n\tstruct hellcreek *hellcreek = led_to_hellcreek(ldev, led_is_gm);\n\n\thellcreek_set_brightness(hellcreek, STATUS_OUT_IS_GM, b);\n}\n\nstatic enum led_brightness hellcreek_led_is_gm_get(struct led_classdev *ldev)\n{\n\tstruct hellcreek *hellcreek = led_to_hellcreek(ldev, led_is_gm);\n\n\treturn hellcreek_get_brightness(hellcreek, STATUS_OUT_IS_GM);\n}\n\n \nstatic int hellcreek_led_setup(struct hellcreek *hellcreek)\n{\n\tstruct device_node *leds, *led = NULL;\n\tenum led_default_state state;\n\tconst char *label;\n\tint ret = -EINVAL;\n\n\tof_node_get(hellcreek->dev->of_node);\n\tleds = of_find_node_by_name(hellcreek->dev->of_node, \"leds\");\n\tif (!leds) {\n\t\tdev_err(hellcreek->dev, \"No LEDs specified in device tree!\\n\");\n\t\treturn ret;\n\t}\n\n\thellcreek->status_out = 0;\n\n\tled = of_get_next_available_child(leds, led);\n\tif (!led) {\n\t\tdev_err(hellcreek->dev, \"First LED not specified!\\n\");\n\t\tgoto out;\n\t}\n\n\tret = of_property_read_string(led, \"label\", &label);\n\thellcreek->led_sync_good.name = ret ? \"sync_good\" : label;\n\n\tstate = led_init_default_state_get(of_fwnode_handle(led));\n\tswitch (state) {\n\tcase LEDS_DEFSTATE_ON:\n\t\thellcreek->led_sync_good.brightness = 1;\n\t\tbreak;\n\tcase LEDS_DEFSTATE_KEEP:\n\t\thellcreek->led_sync_good.brightness =\n\t\t\thellcreek_get_brightness(hellcreek, STATUS_OUT_SYNC_GOOD);\n\t\tbreak;\n\tdefault:\n\t\thellcreek->led_sync_good.brightness = 0;\n\t}\n\n\thellcreek->led_sync_good.max_brightness = 1;\n\thellcreek->led_sync_good.brightness_set = hellcreek_led_sync_good_set;\n\thellcreek->led_sync_good.brightness_get = hellcreek_led_sync_good_get;\n\n\tled = of_get_next_available_child(leds, led);\n\tif (!led) {\n\t\tdev_err(hellcreek->dev, \"Second LED not specified!\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = of_property_read_string(led, \"label\", &label);\n\thellcreek->led_is_gm.name = ret ? \"is_gm\" : label;\n\n\tstate = led_init_default_state_get(of_fwnode_handle(led));\n\tswitch (state) {\n\tcase LEDS_DEFSTATE_ON:\n\t\thellcreek->led_is_gm.brightness = 1;\n\t\tbreak;\n\tcase LEDS_DEFSTATE_KEEP:\n\t\thellcreek->led_is_gm.brightness =\n\t\t\thellcreek_get_brightness(hellcreek, STATUS_OUT_IS_GM);\n\t\tbreak;\n\tdefault:\n\t\thellcreek->led_is_gm.brightness = 0;\n\t}\n\n\thellcreek->led_is_gm.max_brightness = 1;\n\thellcreek->led_is_gm.brightness_set = hellcreek_led_is_gm_set;\n\thellcreek->led_is_gm.brightness_get = hellcreek_led_is_gm_get;\n\n\t \n\tif (hellcreek->led_sync_good.brightness == 1)\n\t\thellcreek_set_brightness(hellcreek, STATUS_OUT_SYNC_GOOD, 1);\n\tif (hellcreek->led_is_gm.brightness == 1)\n\t\thellcreek_set_brightness(hellcreek, STATUS_OUT_IS_GM, 1);\n\n\t \n\tled_classdev_register(hellcreek->dev, &hellcreek->led_sync_good);\n\tled_classdev_register(hellcreek->dev, &hellcreek->led_is_gm);\n\n\tret = 0;\n\nout:\n\tof_node_put(leds);\n\n\treturn ret;\n}\n\nint hellcreek_ptp_setup(struct hellcreek *hellcreek)\n{\n\tu16 status;\n\tint ret;\n\n\t \n\tINIT_DELAYED_WORK(&hellcreek->overflow_work,\n\t\t\t  hellcreek_ptp_overflow_check);\n\n\t \n\thellcreek->ptp_clock_info.owner = THIS_MODULE;\n\tsnprintf(hellcreek->ptp_clock_info.name,\n\t\t sizeof(hellcreek->ptp_clock_info.name),\n\t\t dev_name(hellcreek->dev));\n\n\t \n\thellcreek->ptp_clock_info.max_adj     = 62500000;\n\thellcreek->ptp_clock_info.n_alarm     = 0;\n\thellcreek->ptp_clock_info.n_pins      = 0;\n\thellcreek->ptp_clock_info.n_ext_ts    = 0;\n\thellcreek->ptp_clock_info.n_per_out   = 0;\n\thellcreek->ptp_clock_info.pps\t      = 0;\n\thellcreek->ptp_clock_info.adjfine     = hellcreek_ptp_adjfine;\n\thellcreek->ptp_clock_info.adjtime     = hellcreek_ptp_adjtime;\n\thellcreek->ptp_clock_info.gettime64   = hellcreek_ptp_gettime;\n\thellcreek->ptp_clock_info.settime64   = hellcreek_ptp_settime;\n\thellcreek->ptp_clock_info.enable      = hellcreek_ptp_enable;\n\thellcreek->ptp_clock_info.do_aux_work = hellcreek_hwtstamp_work;\n\n\thellcreek->ptp_clock = ptp_clock_register(&hellcreek->ptp_clock_info,\n\t\t\t\t\t\t  hellcreek->dev);\n\tif (IS_ERR(hellcreek->ptp_clock))\n\t\treturn PTR_ERR(hellcreek->ptp_clock);\n\n\t \n\tstatus = hellcreek_ptp_read(hellcreek, PR_CLOCK_STATUS_C);\n\tif (!(status & PR_CLOCK_STATUS_C_OFS_ACT))\n\t\thellcreek_ptp_write(hellcreek,\n\t\t\t\t    status | PR_CLOCK_STATUS_C_ENA_OFS,\n\t\t\t\t    PR_CLOCK_STATUS_C);\n\n\t \n\thellcreek_ptp_write(hellcreek, status | PR_CLOCK_STATUS_C_ENA_DRIFT,\n\t\t\t    PR_CLOCK_STATUS_C);\n\n\t \n\tret = hellcreek_led_setup(hellcreek);\n\tif (ret) {\n\t\tif (hellcreek->ptp_clock)\n\t\t\tptp_clock_unregister(hellcreek->ptp_clock);\n\t\treturn ret;\n\t}\n\n\tschedule_delayed_work(&hellcreek->overflow_work,\n\t\t\t      HELLCREEK_OVERFLOW_PERIOD);\n\n\treturn 0;\n}\n\nvoid hellcreek_ptp_free(struct hellcreek *hellcreek)\n{\n\tled_classdev_unregister(&hellcreek->led_is_gm);\n\tled_classdev_unregister(&hellcreek->led_sync_good);\n\tcancel_delayed_work_sync(&hellcreek->overflow_work);\n\tif (hellcreek->ptp_clock)\n\t\tptp_clock_unregister(hellcreek->ptp_clock);\n\thellcreek->ptp_clock = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}