{
  "module_name": "hellcreek_hwtstamp.c",
  "hash_id": "a09bbca00b331d7083c79fef01237a78cad27baa8dc23266ffb645fe8db9bc50",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/hirschmann/hellcreek_hwtstamp.c",
  "human_readable_source": "\n \n\n#include <linux/ptp_classify.h>\n\n#include \"hellcreek.h\"\n#include \"hellcreek_hwtstamp.h\"\n#include \"hellcreek_ptp.h\"\n\nint hellcreek_get_ts_info(struct dsa_switch *ds, int port,\n\t\t\t  struct ethtool_ts_info *info)\n{\n\tstruct hellcreek *hellcreek = ds->priv;\n\n\tinfo->phc_index = hellcreek->ptp_clock ?\n\t\tptp_clock_index(hellcreek->ptp_clock) : -1;\n\tinfo->so_timestamping = SOF_TIMESTAMPING_TX_HARDWARE |\n\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\n\t \n\tinfo->tx_types = BIT(HWTSTAMP_TX_ON);\n\n\t \n\tinfo->rx_filters = BIT(HWTSTAMP_FILTER_PTP_V2_EVENT);\n\n\treturn 0;\n}\n\n \nstatic int hellcreek_set_hwtstamp_config(struct hellcreek *hellcreek, int port,\n\t\t\t\t\t struct hwtstamp_config *config)\n{\n\tstruct hellcreek_port_hwtstamp *ps =\n\t\t&hellcreek->ports[port].port_hwtstamp;\n\tbool tx_tstamp_enable = false;\n\tbool rx_tstamp_enable = false;\n\n\t \n\tclear_bit_unlock(HELLCREEK_HWTSTAMP_ENABLED, &ps->state);\n\n\tswitch (config->tx_type) {\n\tcase HWTSTAMP_TX_ON:\n\t\ttx_tstamp_enable = true;\n\t\tbreak;\n\n\t \n\tcase HWTSTAMP_TX_OFF:\n\t\tconfig->tx_type = HWTSTAMP_TX_ON;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tswitch (config->rx_filter) {\n\t \n\tcase HWTSTAMP_FILTER_NONE:\n\t\tconfig->rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\n\t\tbreak;\n\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\t\tconfig->rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\n\t\trx_tstamp_enable = true;\n\t\tbreak;\n\n\t \n\tcase HWTSTAMP_FILTER_ALL:\n\t\tconfig->rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tif (!tx_tstamp_enable)\n\t\treturn -ERANGE;\n\n\tif (!rx_tstamp_enable)\n\t\treturn -ERANGE;\n\n\t \n\tset_bit(HELLCREEK_HWTSTAMP_ENABLED, &ps->state);\n\n\treturn 0;\n}\n\nint hellcreek_port_hwtstamp_set(struct dsa_switch *ds, int port,\n\t\t\t\tstruct ifreq *ifr)\n{\n\tstruct hellcreek *hellcreek = ds->priv;\n\tstruct hellcreek_port_hwtstamp *ps;\n\tstruct hwtstamp_config config;\n\tint err;\n\n\tps = &hellcreek->ports[port].port_hwtstamp;\n\n\tif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\n\t\treturn -EFAULT;\n\n\terr = hellcreek_set_hwtstamp_config(hellcreek, port, &config);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmemcpy(&ps->tstamp_config, &config, sizeof(config));\n\n\treturn copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?\n\t\t-EFAULT : 0;\n}\n\nint hellcreek_port_hwtstamp_get(struct dsa_switch *ds, int port,\n\t\t\t\tstruct ifreq *ifr)\n{\n\tstruct hellcreek *hellcreek = ds->priv;\n\tstruct hellcreek_port_hwtstamp *ps;\n\tstruct hwtstamp_config *config;\n\n\tps = &hellcreek->ports[port].port_hwtstamp;\n\tconfig = &ps->tstamp_config;\n\n\treturn copy_to_user(ifr->ifr_data, config, sizeof(*config)) ?\n\t\t-EFAULT : 0;\n}\n\n \nstatic struct ptp_header *hellcreek_should_tstamp(struct hellcreek *hellcreek,\n\t\t\t\t\t\t  int port, struct sk_buff *skb,\n\t\t\t\t\t\t  unsigned int type)\n{\n\tstruct hellcreek_port_hwtstamp *ps =\n\t\t&hellcreek->ports[port].port_hwtstamp;\n\tstruct ptp_header *hdr;\n\n\thdr = ptp_parse_header(skb, type);\n\tif (!hdr)\n\t\treturn NULL;\n\n\tif (!test_bit(HELLCREEK_HWTSTAMP_ENABLED, &ps->state))\n\t\treturn NULL;\n\n\treturn hdr;\n}\n\nstatic u64 hellcreek_get_reserved_field(const struct ptp_header *hdr)\n{\n\treturn be32_to_cpu(hdr->reserved2);\n}\n\nstatic void hellcreek_clear_reserved_field(struct ptp_header *hdr)\n{\n\thdr->reserved2 = 0;\n}\n\nstatic int hellcreek_ptp_hwtstamp_available(struct hellcreek *hellcreek,\n\t\t\t\t\t    unsigned int ts_reg)\n{\n\tu16 status;\n\n\tstatus = hellcreek_ptp_read(hellcreek, ts_reg);\n\n\tif (status & PR_TS_STATUS_TS_LOST)\n\t\tdev_err(hellcreek->dev,\n\t\t\t\"Tx time stamp lost! This should never happen!\\n\");\n\n\t \n\treturn (status & PR_TS_STATUS_TS_AVAIL) ? 1 : 0;\n}\n\n \nstatic u64 hellcreek_ptp_hwtstamp_read(struct hellcreek *hellcreek,\n\t\t\t\t       unsigned int ts_reg)\n{\n\tu16 nsl, nsh;\n\n\tnsh = hellcreek_ptp_read(hellcreek, ts_reg);\n\tnsh = hellcreek_ptp_read(hellcreek, ts_reg);\n\tnsh = hellcreek_ptp_read(hellcreek, ts_reg);\n\tnsh = hellcreek_ptp_read(hellcreek, ts_reg);\n\tnsl = hellcreek_ptp_read(hellcreek, ts_reg);\n\n\treturn (u64)nsl | ((u64)nsh << 16);\n}\n\nstatic int hellcreek_txtstamp_work(struct hellcreek *hellcreek,\n\t\t\t\t   struct hellcreek_port_hwtstamp *ps, int port)\n{\n\tstruct skb_shared_hwtstamps shhwtstamps;\n\tunsigned int status_reg, data_reg;\n\tstruct sk_buff *tmp_skb;\n\tint ts_status;\n\tu64 ns = 0;\n\n\tif (!ps->tx_skb)\n\t\treturn 0;\n\n\tswitch (port) {\n\tcase 2:\n\t\tstatus_reg = PR_TS_TX_P1_STATUS_C;\n\t\tdata_reg   = PR_TS_TX_P1_DATA_C;\n\t\tbreak;\n\tcase 3:\n\t\tstatus_reg = PR_TS_TX_P2_STATUS_C;\n\t\tdata_reg   = PR_TS_TX_P2_DATA_C;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hellcreek->dev, \"Wrong port for timestamping!\\n\");\n\t\treturn 0;\n\t}\n\n\tts_status = hellcreek_ptp_hwtstamp_available(hellcreek, status_reg);\n\n\t \n\tif (ts_status == 0) {\n\t\t \n\t\tif (time_is_before_jiffies(ps->tx_tstamp_start +\n\t\t\t\t\t   TX_TSTAMP_TIMEOUT)) {\n\t\t\tdev_err(hellcreek->dev,\n\t\t\t\t\"Timeout while waiting for Tx timestamp!\\n\");\n\t\t\tgoto free_and_clear_skb;\n\t\t}\n\n\t\t \n\t\treturn 1;\n\t}\n\n\tmutex_lock(&hellcreek->ptp_lock);\n\tns  = hellcreek_ptp_hwtstamp_read(hellcreek, data_reg);\n\tns += hellcreek_ptp_gettime_seconds(hellcreek, ns);\n\tmutex_unlock(&hellcreek->ptp_lock);\n\n\t \n\tmemset(&shhwtstamps, 0, sizeof(shhwtstamps));\n\tshhwtstamps.hwtstamp = ns_to_ktime(ns);\n\n\ttmp_skb = ps->tx_skb;\n\tps->tx_skb = NULL;\n\n\t \n\tclear_bit_unlock(HELLCREEK_HWTSTAMP_TX_IN_PROGRESS, &ps->state);\n\n\t \n\tskb_complete_tx_timestamp(tmp_skb, &shhwtstamps);\n\n\treturn 0;\n\nfree_and_clear_skb:\n\tdev_kfree_skb_any(ps->tx_skb);\n\tps->tx_skb = NULL;\n\tclear_bit_unlock(HELLCREEK_HWTSTAMP_TX_IN_PROGRESS, &ps->state);\n\n\treturn 0;\n}\n\nstatic void hellcreek_get_rxts(struct hellcreek *hellcreek,\n\t\t\t       struct hellcreek_port_hwtstamp *ps,\n\t\t\t       struct sk_buff *skb, struct sk_buff_head *rxq,\n\t\t\t       int port)\n{\n\tstruct skb_shared_hwtstamps *shwt;\n\tstruct sk_buff_head received;\n\tunsigned long flags;\n\n\t \n\t__skb_queue_head_init(&received);\n\tspin_lock_irqsave(&rxq->lock, flags);\n\tskb_queue_splice_tail_init(rxq, &received);\n\tspin_unlock_irqrestore(&rxq->lock, flags);\n\n\tfor (; skb; skb = __skb_dequeue(&received)) {\n\t\tstruct ptp_header *hdr;\n\t\tunsigned int type;\n\t\tu64 ns;\n\n\t\t \n\t\ttype = SKB_PTP_TYPE(skb);\n\t\thdr  = ptp_parse_header(skb, type);\n\t\tns   = hellcreek_get_reserved_field(hdr);\n\t\thellcreek_clear_reserved_field(hdr);\n\n\t\t \n\t\tmutex_lock(&hellcreek->ptp_lock);\n\t\tns += hellcreek_ptp_gettime_seconds(hellcreek, ns);\n\t\tmutex_unlock(&hellcreek->ptp_lock);\n\n\t\t \n\t\tshwt = skb_hwtstamps(skb);\n\t\tmemset(shwt, 0, sizeof(*shwt));\n\t\tshwt->hwtstamp = ns_to_ktime(ns);\n\t\tnetif_rx(skb);\n\t}\n}\n\nstatic void hellcreek_rxtstamp_work(struct hellcreek *hellcreek,\n\t\t\t\t    struct hellcreek_port_hwtstamp *ps,\n\t\t\t\t    int port)\n{\n\tstruct sk_buff *skb;\n\n\tskb = skb_dequeue(&ps->rx_queue);\n\tif (skb)\n\t\thellcreek_get_rxts(hellcreek, ps, skb, &ps->rx_queue, port);\n}\n\nlong hellcreek_hwtstamp_work(struct ptp_clock_info *ptp)\n{\n\tstruct hellcreek *hellcreek = ptp_to_hellcreek(ptp);\n\tstruct dsa_switch *ds = hellcreek->ds;\n\tint i, restart = 0;\n\n\tfor (i = 0; i < ds->num_ports; i++) {\n\t\tstruct hellcreek_port_hwtstamp *ps;\n\n\t\tif (!dsa_is_user_port(ds, i))\n\t\t\tcontinue;\n\n\t\tps = &hellcreek->ports[i].port_hwtstamp;\n\n\t\tif (test_bit(HELLCREEK_HWTSTAMP_TX_IN_PROGRESS, &ps->state))\n\t\t\trestart |= hellcreek_txtstamp_work(hellcreek, ps, i);\n\n\t\thellcreek_rxtstamp_work(hellcreek, ps, i);\n\t}\n\n\treturn restart ? 1 : -1;\n}\n\nvoid hellcreek_port_txtstamp(struct dsa_switch *ds, int port,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct hellcreek *hellcreek = ds->priv;\n\tstruct hellcreek_port_hwtstamp *ps;\n\tstruct ptp_header *hdr;\n\tstruct sk_buff *clone;\n\tunsigned int type;\n\n\tps = &hellcreek->ports[port].port_hwtstamp;\n\n\ttype = ptp_classify_raw(skb);\n\tif (type == PTP_CLASS_NONE)\n\t\treturn;\n\n\t \n\thdr = hellcreek_should_tstamp(hellcreek, port, skb, type);\n\tif (!hdr)\n\t\treturn;\n\n\tclone = skb_clone_sk(skb);\n\tif (!clone)\n\t\treturn;\n\n\tif (test_and_set_bit_lock(HELLCREEK_HWTSTAMP_TX_IN_PROGRESS,\n\t\t\t\t  &ps->state)) {\n\t\tkfree_skb(clone);\n\t\treturn;\n\t}\n\n\tps->tx_skb = clone;\n\n\t \n\tps->tx_tstamp_start = jiffies;\n\n\tptp_schedule_worker(hellcreek->ptp_clock, 0);\n}\n\nbool hellcreek_port_rxtstamp(struct dsa_switch *ds, int port,\n\t\t\t     struct sk_buff *skb, unsigned int type)\n{\n\tstruct hellcreek *hellcreek = ds->priv;\n\tstruct hellcreek_port_hwtstamp *ps;\n\tstruct ptp_header *hdr;\n\n\tps = &hellcreek->ports[port].port_hwtstamp;\n\n\t \n\tif (ps->tstamp_config.rx_filter != HWTSTAMP_FILTER_PTP_V2_EVENT)\n\t\treturn false;\n\n\t \n\thdr = hellcreek_should_tstamp(hellcreek, port, skb, type);\n\tif (!hdr)\n\t\treturn false;\n\n\tSKB_PTP_TYPE(skb) = type;\n\n\tskb_queue_tail(&ps->rx_queue, skb);\n\n\tptp_schedule_worker(hellcreek->ptp_clock, 0);\n\n\treturn true;\n}\n\nstatic void hellcreek_hwtstamp_port_setup(struct hellcreek *hellcreek, int port)\n{\n\tstruct hellcreek_port_hwtstamp *ps =\n\t\t&hellcreek->ports[port].port_hwtstamp;\n\n\tskb_queue_head_init(&ps->rx_queue);\n}\n\nint hellcreek_hwtstamp_setup(struct hellcreek *hellcreek)\n{\n\tstruct dsa_switch *ds = hellcreek->ds;\n\tint i;\n\n\t \n\tfor (i = 0; i < ds->num_ports; ++i) {\n\t\tif (!dsa_is_user_port(ds, i))\n\t\t\tcontinue;\n\n\t\thellcreek_hwtstamp_port_setup(hellcreek, i);\n\t}\n\n\t \n\thellcreek_ptp_write(hellcreek, PR_SETTINGS_C_TS_SRC_TK_MASK |\n\t\t\t    PR_SETTINGS_C_RES3TS,\n\t\t\t    PR_SETTINGS_C);\n\n\treturn 0;\n}\n\nvoid hellcreek_hwtstamp_free(struct hellcreek *hellcreek)\n{\n\t \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}