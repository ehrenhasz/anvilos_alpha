{
  "module_name": "mt7530-mdio.c",
  "hash_id": "d468e5c24004a8db2707bc1118ff1a793911c7d80323d7456e4ca1cc889dd035",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/mt7530-mdio.c",
  "human_readable_source": "\n\n#include <linux/gpio/consumer.h>\n#include <linux/mdio.h>\n#include <linux/module.h>\n#include <linux/pcs/pcs-mtk-lynxi.h>\n#include <linux/of_irq.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/of_platform.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/regulator/consumer.h>\n#include <net/dsa.h>\n\n#include \"mt7530.h\"\n\nstatic int\nmt7530_regmap_write(void *context, unsigned int reg, unsigned int val)\n{\n\tstruct mii_bus *bus = context;\n\tu16 page, r, lo, hi;\n\tint ret;\n\n\tpage = (reg >> 6) & 0x3ff;\n\tr  = (reg >> 2) & 0xf;\n\tlo = val & 0xffff;\n\thi = val >> 16;\n\n\t \n\tret = bus->write(bus, 0x1f, 0x1f, page);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = bus->write(bus, 0x1f, r,  lo);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = bus->write(bus, 0x1f, 0x10, hi);\n\treturn ret;\n}\n\nstatic int\nmt7530_regmap_read(void *context, unsigned int reg, unsigned int *val)\n{\n\tstruct mii_bus *bus = context;\n\tu16 page, r, lo, hi;\n\tint ret;\n\n\tpage = (reg >> 6) & 0x3ff;\n\tr = (reg >> 2) & 0xf;\n\n\t \n\tret = bus->write(bus, 0x1f, 0x1f, page);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlo = bus->read(bus, 0x1f, r);\n\thi = bus->read(bus, 0x1f, 0x10);\n\n\t*val = (hi << 16) | (lo & 0xffff);\n\n\treturn 0;\n}\n\nstatic void\nmt7530_mdio_regmap_lock(void *mdio_lock)\n{\n\tmutex_lock_nested(mdio_lock, MDIO_MUTEX_NESTED);\n}\n\nstatic void\nmt7530_mdio_regmap_unlock(void *mdio_lock)\n{\n\tmutex_unlock(mdio_lock);\n}\n\nstatic const struct regmap_bus mt7530_regmap_bus = {\n\t.reg_write = mt7530_regmap_write,\n\t.reg_read = mt7530_regmap_read,\n};\n\nstatic int\nmt7531_create_sgmii(struct mt7530_priv *priv, bool dual_sgmii)\n{\n\tstruct regmap_config *mt7531_pcs_config[2] = {};\n\tstruct phylink_pcs *pcs;\n\tstruct regmap *regmap;\n\tint i, ret = 0;\n\n\t \n\tfor (i = dual_sgmii ? 0 : 1; i < 2; i++) {\n\t\tmt7531_pcs_config[i] = devm_kzalloc(priv->dev,\n\t\t\t\t\t\t    sizeof(struct regmap_config),\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!mt7531_pcs_config[i]) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tmt7531_pcs_config[i]->name = i ? \"port6\" : \"port5\";\n\t\tmt7531_pcs_config[i]->reg_bits = 16;\n\t\tmt7531_pcs_config[i]->val_bits = 32;\n\t\tmt7531_pcs_config[i]->reg_stride = 4;\n\t\tmt7531_pcs_config[i]->reg_base = MT7531_SGMII_REG_BASE(5 + i);\n\t\tmt7531_pcs_config[i]->max_register = 0x17c;\n\t\tmt7531_pcs_config[i]->lock = mt7530_mdio_regmap_lock;\n\t\tmt7531_pcs_config[i]->unlock = mt7530_mdio_regmap_unlock;\n\t\tmt7531_pcs_config[i]->lock_arg = &priv->bus->mdio_lock;\n\n\t\tregmap = devm_regmap_init(priv->dev,\n\t\t\t\t\t  &mt7530_regmap_bus, priv->bus,\n\t\t\t\t\t  mt7531_pcs_config[i]);\n\t\tif (IS_ERR(regmap)) {\n\t\t\tret = PTR_ERR(regmap);\n\t\t\tbreak;\n\t\t}\n\t\tpcs = mtk_pcs_lynxi_create(priv->dev, regmap,\n\t\t\t\t\t   MT7531_PHYA_CTRL_SIGNAL3, 0);\n\t\tif (!pcs) {\n\t\t\tret = -ENXIO;\n\t\t\tbreak;\n\t\t}\n\t\tpriv->ports[5 + i].sgmii_pcs = pcs;\n\t}\n\n\tif (ret && i)\n\t\tmtk_pcs_lynxi_destroy(priv->ports[5].sgmii_pcs);\n\n\treturn ret;\n}\n\nstatic const struct of_device_id mt7530_of_match[] = {\n\t{ .compatible = \"mediatek,mt7621\", .data = &mt753x_table[ID_MT7621], },\n\t{ .compatible = \"mediatek,mt7530\", .data = &mt753x_table[ID_MT7530], },\n\t{ .compatible = \"mediatek,mt7531\", .data = &mt753x_table[ID_MT7531], },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, mt7530_of_match);\n\nstatic int\nmt7530_probe(struct mdio_device *mdiodev)\n{\n\tstatic struct regmap_config *regmap_config;\n\tstruct mt7530_priv *priv;\n\tstruct device_node *dn;\n\tint ret;\n\n\tdn = mdiodev->dev.of_node;\n\n\tpriv = devm_kzalloc(&mdiodev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->bus = mdiodev->bus;\n\tpriv->dev = &mdiodev->dev;\n\n\tret = mt7530_probe_common(priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpriv->mcm = of_property_read_bool(dn, \"mediatek,mcm\");\n\tif (priv->mcm) {\n\t\tdev_info(&mdiodev->dev, \"MT7530 adapts as multi-chip module\\n\");\n\n\t\tpriv->rstc = devm_reset_control_get(&mdiodev->dev, \"mcm\");\n\t\tif (IS_ERR(priv->rstc)) {\n\t\t\tdev_err(&mdiodev->dev, \"Couldn't get our reset line\\n\");\n\t\t\treturn PTR_ERR(priv->rstc);\n\t\t}\n\t} else {\n\t\tpriv->reset = devm_gpiod_get_optional(&mdiodev->dev, \"reset\",\n\t\t\t\t\t\t      GPIOD_OUT_LOW);\n\t\tif (IS_ERR(priv->reset)) {\n\t\t\tdev_err(&mdiodev->dev, \"Couldn't get our reset line\\n\");\n\t\t\treturn PTR_ERR(priv->reset);\n\t\t}\n\t}\n\n\tif (priv->id == ID_MT7530) {\n\t\tpriv->core_pwr = devm_regulator_get(&mdiodev->dev, \"core\");\n\t\tif (IS_ERR(priv->core_pwr))\n\t\t\treturn PTR_ERR(priv->core_pwr);\n\n\t\tpriv->io_pwr = devm_regulator_get(&mdiodev->dev, \"io\");\n\t\tif (IS_ERR(priv->io_pwr))\n\t\t\treturn PTR_ERR(priv->io_pwr);\n\t}\n\n\tregmap_config = devm_kzalloc(&mdiodev->dev, sizeof(*regmap_config),\n\t\t\t\t     GFP_KERNEL);\n\tif (!regmap_config)\n\t\treturn -ENOMEM;\n\n\tregmap_config->reg_bits = 16;\n\tregmap_config->val_bits = 32;\n\tregmap_config->reg_stride = 4;\n\tregmap_config->max_register = MT7530_CREV;\n\tregmap_config->disable_locking = true;\n\tpriv->regmap = devm_regmap_init(priv->dev, &mt7530_regmap_bus,\n\t\t\t\t\tpriv->bus, regmap_config);\n\tif (IS_ERR(priv->regmap))\n\t\treturn PTR_ERR(priv->regmap);\n\n\tif (priv->id == ID_MT7531)\n\t\tpriv->create_sgmii = mt7531_create_sgmii;\n\n\treturn dsa_register_switch(priv->ds);\n}\n\nstatic void\nmt7530_remove(struct mdio_device *mdiodev)\n{\n\tstruct mt7530_priv *priv = dev_get_drvdata(&mdiodev->dev);\n\tint ret = 0, i;\n\n\tif (!priv)\n\t\treturn;\n\n\tret = regulator_disable(priv->core_pwr);\n\tif (ret < 0)\n\t\tdev_err(priv->dev,\n\t\t\t\"Failed to disable core power: %d\\n\", ret);\n\n\tret = regulator_disable(priv->io_pwr);\n\tif (ret < 0)\n\t\tdev_err(priv->dev, \"Failed to disable io pwr: %d\\n\",\n\t\t\tret);\n\n\tmt7530_remove_common(priv);\n\n\tfor (i = 0; i < 2; ++i)\n\t\tmtk_pcs_lynxi_destroy(priv->ports[5 + i].sgmii_pcs);\n}\n\nstatic void mt7530_shutdown(struct mdio_device *mdiodev)\n{\n\tstruct mt7530_priv *priv = dev_get_drvdata(&mdiodev->dev);\n\n\tif (!priv)\n\t\treturn;\n\n\tdsa_switch_shutdown(priv->ds);\n\n\tdev_set_drvdata(&mdiodev->dev, NULL);\n}\n\nstatic struct mdio_driver mt7530_mdio_driver = {\n\t.probe  = mt7530_probe,\n\t.remove = mt7530_remove,\n\t.shutdown = mt7530_shutdown,\n\t.mdiodrv.driver = {\n\t\t.name = \"mt7530-mdio\",\n\t\t.of_match_table = mt7530_of_match,\n\t},\n};\n\nmdio_module_driver(mt7530_mdio_driver);\n\nMODULE_AUTHOR(\"Sean Wang <sean.wang@mediatek.com>\");\nMODULE_DESCRIPTION(\"Driver for Mediatek MT7530 Switch (MDIO)\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}