{
  "module_name": "dsa_loop.c",
  "hash_id": "b8fe6d533070dbdbc41f23ae6ff74e36c411fa561b751760138ce465bb0369ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/dsa_loop.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/netdevice.h>\n#include <linux/phy.h>\n#include <linux/phy_fixed.h>\n#include <linux/export.h>\n#include <linux/ethtool.h>\n#include <linux/workqueue.h>\n#include <linux/module.h>\n#include <linux/if_bridge.h>\n#include <linux/dsa/loop.h>\n#include <net/dsa.h>\n\n#include \"dsa_loop.h\"\n\nstatic struct dsa_loop_mib_entry dsa_loop_mibs[] = {\n\t[DSA_LOOP_PHY_READ_OK]\t= { \"phy_read_ok\", },\n\t[DSA_LOOP_PHY_READ_ERR]\t= { \"phy_read_err\", },\n\t[DSA_LOOP_PHY_WRITE_OK] = { \"phy_write_ok\", },\n\t[DSA_LOOP_PHY_WRITE_ERR] = { \"phy_write_err\", },\n};\n\nstatic struct phy_device *phydevs[PHY_MAX_ADDR];\n\nenum dsa_loop_devlink_resource_id {\n\tDSA_LOOP_DEVLINK_PARAM_ID_VTU,\n};\n\nstatic u64 dsa_loop_devlink_vtu_get(void *priv)\n{\n\tstruct dsa_loop_priv *ps = priv;\n\tunsigned int i, count = 0;\n\tstruct dsa_loop_vlan *vl;\n\n\tfor (i = 0; i < ARRAY_SIZE(ps->vlans); i++) {\n\t\tvl = &ps->vlans[i];\n\t\tif (vl->members)\n\t\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nstatic int dsa_loop_setup_devlink_resources(struct dsa_switch *ds)\n{\n\tstruct devlink_resource_size_params size_params;\n\tstruct dsa_loop_priv *ps = ds->priv;\n\tint err;\n\n\tdevlink_resource_size_params_init(&size_params, ARRAY_SIZE(ps->vlans),\n\t\t\t\t\t  ARRAY_SIZE(ps->vlans),\n\t\t\t\t\t  1, DEVLINK_RESOURCE_UNIT_ENTRY);\n\n\terr = dsa_devlink_resource_register(ds, \"VTU\", ARRAY_SIZE(ps->vlans),\n\t\t\t\t\t    DSA_LOOP_DEVLINK_PARAM_ID_VTU,\n\t\t\t\t\t    DEVLINK_RESOURCE_ID_PARENT_TOP,\n\t\t\t\t\t    &size_params);\n\tif (err)\n\t\tgoto out;\n\n\tdsa_devlink_resource_occ_get_register(ds,\n\t\t\t\t\t      DSA_LOOP_DEVLINK_PARAM_ID_VTU,\n\t\t\t\t\t      dsa_loop_devlink_vtu_get, ps);\n\n\treturn 0;\n\nout:\n\tdsa_devlink_resources_unregister(ds);\n\treturn err;\n}\n\nstatic enum dsa_tag_protocol dsa_loop_get_protocol(struct dsa_switch *ds,\n\t\t\t\t\t\t   int port,\n\t\t\t\t\t\t   enum dsa_tag_protocol mp)\n{\n\tdev_dbg(ds->dev, \"%s: port: %d\\n\", __func__, port);\n\n\treturn DSA_TAG_PROTO_NONE;\n}\n\nstatic int dsa_loop_setup(struct dsa_switch *ds)\n{\n\tstruct dsa_loop_priv *ps = ds->priv;\n\tunsigned int i;\n\n\tfor (i = 0; i < ds->num_ports; i++)\n\t\tmemcpy(ps->ports[i].mib, dsa_loop_mibs,\n\t\t       sizeof(dsa_loop_mibs));\n\n\tdev_dbg(ds->dev, \"%s\\n\", __func__);\n\n\treturn dsa_loop_setup_devlink_resources(ds);\n}\n\nstatic void dsa_loop_teardown(struct dsa_switch *ds)\n{\n\tdsa_devlink_resources_unregister(ds);\n}\n\nstatic int dsa_loop_get_sset_count(struct dsa_switch *ds, int port, int sset)\n{\n\tif (sset != ETH_SS_STATS && sset != ETH_SS_PHY_STATS)\n\t\treturn 0;\n\n\treturn __DSA_LOOP_CNT_MAX;\n}\n\nstatic void dsa_loop_get_strings(struct dsa_switch *ds, int port,\n\t\t\t\t u32 stringset, uint8_t *data)\n{\n\tstruct dsa_loop_priv *ps = ds->priv;\n\tunsigned int i;\n\n\tif (stringset != ETH_SS_STATS && stringset != ETH_SS_PHY_STATS)\n\t\treturn;\n\n\tfor (i = 0; i < __DSA_LOOP_CNT_MAX; i++)\n\t\tmemcpy(data + i * ETH_GSTRING_LEN,\n\t\t       ps->ports[port].mib[i].name, ETH_GSTRING_LEN);\n}\n\nstatic void dsa_loop_get_ethtool_stats(struct dsa_switch *ds, int port,\n\t\t\t\t       uint64_t *data)\n{\n\tstruct dsa_loop_priv *ps = ds->priv;\n\tunsigned int i;\n\n\tfor (i = 0; i < __DSA_LOOP_CNT_MAX; i++)\n\t\tdata[i] = ps->ports[port].mib[i].val;\n}\n\nstatic int dsa_loop_phy_read(struct dsa_switch *ds, int port, int regnum)\n{\n\tstruct dsa_loop_priv *ps = ds->priv;\n\tstruct mii_bus *bus = ps->bus;\n\tint ret;\n\n\tret = mdiobus_read_nested(bus, ps->port_base + port, regnum);\n\tif (ret < 0)\n\t\tps->ports[port].mib[DSA_LOOP_PHY_READ_ERR].val++;\n\telse\n\t\tps->ports[port].mib[DSA_LOOP_PHY_READ_OK].val++;\n\n\treturn ret;\n}\n\nstatic int dsa_loop_phy_write(struct dsa_switch *ds, int port,\n\t\t\t      int regnum, u16 value)\n{\n\tstruct dsa_loop_priv *ps = ds->priv;\n\tstruct mii_bus *bus = ps->bus;\n\tint ret;\n\n\tret = mdiobus_write_nested(bus, ps->port_base + port, regnum, value);\n\tif (ret < 0)\n\t\tps->ports[port].mib[DSA_LOOP_PHY_WRITE_ERR].val++;\n\telse\n\t\tps->ports[port].mib[DSA_LOOP_PHY_WRITE_OK].val++;\n\n\treturn ret;\n}\n\nstatic int dsa_loop_port_bridge_join(struct dsa_switch *ds, int port,\n\t\t\t\t     struct dsa_bridge bridge,\n\t\t\t\t     bool *tx_fwd_offload,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tdev_dbg(ds->dev, \"%s: port: %d, bridge: %s\\n\",\n\t\t__func__, port, bridge.dev->name);\n\n\treturn 0;\n}\n\nstatic void dsa_loop_port_bridge_leave(struct dsa_switch *ds, int port,\n\t\t\t\t       struct dsa_bridge bridge)\n{\n\tdev_dbg(ds->dev, \"%s: port: %d, bridge: %s\\n\",\n\t\t__func__, port, bridge.dev->name);\n}\n\nstatic void dsa_loop_port_stp_state_set(struct dsa_switch *ds, int port,\n\t\t\t\t\tu8 state)\n{\n\tdev_dbg(ds->dev, \"%s: port: %d, state: %d\\n\",\n\t\t__func__, port, state);\n}\n\nstatic int dsa_loop_port_vlan_filtering(struct dsa_switch *ds, int port,\n\t\t\t\t\tbool vlan_filtering,\n\t\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tdev_dbg(ds->dev, \"%s: port: %d, vlan_filtering: %d\\n\",\n\t\t__func__, port, vlan_filtering);\n\n\treturn 0;\n}\n\nstatic int dsa_loop_port_vlan_add(struct dsa_switch *ds, int port,\n\t\t\t\t  const struct switchdev_obj_port_vlan *vlan,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tbool untagged = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;\n\tbool pvid = vlan->flags & BRIDGE_VLAN_INFO_PVID;\n\tstruct dsa_loop_priv *ps = ds->priv;\n\tstruct mii_bus *bus = ps->bus;\n\tstruct dsa_loop_vlan *vl;\n\n\tif (vlan->vid >= ARRAY_SIZE(ps->vlans))\n\t\treturn -ERANGE;\n\n\t \n\tmdiobus_read(bus, ps->port_base + port, MII_BMSR);\n\n\tvl = &ps->vlans[vlan->vid];\n\n\tvl->members |= BIT(port);\n\tif (untagged)\n\t\tvl->untagged |= BIT(port);\n\telse\n\t\tvl->untagged &= ~BIT(port);\n\n\tdev_dbg(ds->dev, \"%s: port: %d vlan: %d, %stagged, pvid: %d\\n\",\n\t\t__func__, port, vlan->vid, untagged ? \"un\" : \"\", pvid);\n\n\tif (pvid)\n\t\tps->ports[port].pvid = vlan->vid;\n\n\treturn 0;\n}\n\nstatic int dsa_loop_port_vlan_del(struct dsa_switch *ds, int port,\n\t\t\t\t  const struct switchdev_obj_port_vlan *vlan)\n{\n\tbool untagged = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;\n\tstruct dsa_loop_priv *ps = ds->priv;\n\tu16 pvid = ps->ports[port].pvid;\n\tstruct mii_bus *bus = ps->bus;\n\tstruct dsa_loop_vlan *vl;\n\n\t \n\tmdiobus_read(bus, ps->port_base + port, MII_BMSR);\n\n\tvl = &ps->vlans[vlan->vid];\n\n\tvl->members &= ~BIT(port);\n\tif (untagged)\n\t\tvl->untagged &= ~BIT(port);\n\n\tif (pvid == vlan->vid)\n\t\tpvid = 1;\n\n\tdev_dbg(ds->dev, \"%s: port: %d vlan: %d, %stagged, pvid: %d\\n\",\n\t\t__func__, port, vlan->vid, untagged ? \"un\" : \"\", pvid);\n\tps->ports[port].pvid = pvid;\n\n\treturn 0;\n}\n\nstatic int dsa_loop_port_change_mtu(struct dsa_switch *ds, int port,\n\t\t\t\t    int new_mtu)\n{\n\tstruct dsa_loop_priv *priv = ds->priv;\n\n\tpriv->ports[port].mtu = new_mtu;\n\n\treturn 0;\n}\n\nstatic int dsa_loop_port_max_mtu(struct dsa_switch *ds, int port)\n{\n\treturn ETH_MAX_MTU;\n}\n\nstatic const struct dsa_switch_ops dsa_loop_driver = {\n\t.get_tag_protocol\t= dsa_loop_get_protocol,\n\t.setup\t\t\t= dsa_loop_setup,\n\t.teardown\t\t= dsa_loop_teardown,\n\t.get_strings\t\t= dsa_loop_get_strings,\n\t.get_ethtool_stats\t= dsa_loop_get_ethtool_stats,\n\t.get_sset_count\t\t= dsa_loop_get_sset_count,\n\t.get_ethtool_phy_stats\t= dsa_loop_get_ethtool_stats,\n\t.phy_read\t\t= dsa_loop_phy_read,\n\t.phy_write\t\t= dsa_loop_phy_write,\n\t.port_bridge_join\t= dsa_loop_port_bridge_join,\n\t.port_bridge_leave\t= dsa_loop_port_bridge_leave,\n\t.port_stp_state_set\t= dsa_loop_port_stp_state_set,\n\t.port_vlan_filtering\t= dsa_loop_port_vlan_filtering,\n\t.port_vlan_add\t\t= dsa_loop_port_vlan_add,\n\t.port_vlan_del\t\t= dsa_loop_port_vlan_del,\n\t.port_change_mtu\t= dsa_loop_port_change_mtu,\n\t.port_max_mtu\t\t= dsa_loop_port_max_mtu,\n};\n\nstatic int dsa_loop_drv_probe(struct mdio_device *mdiodev)\n{\n\tstruct dsa_loop_pdata *pdata = mdiodev->dev.platform_data;\n\tstruct dsa_loop_priv *ps;\n\tstruct dsa_switch *ds;\n\tint ret;\n\n\tif (!pdata)\n\t\treturn -ENODEV;\n\n\tds = devm_kzalloc(&mdiodev->dev, sizeof(*ds), GFP_KERNEL);\n\tif (!ds)\n\t\treturn -ENOMEM;\n\n\tds->dev = &mdiodev->dev;\n\tds->num_ports = DSA_LOOP_NUM_PORTS;\n\n\tps = devm_kzalloc(&mdiodev->dev, sizeof(*ps), GFP_KERNEL);\n\tif (!ps)\n\t\treturn -ENOMEM;\n\n\tps->netdev = dev_get_by_name(&init_net, pdata->netdev);\n\tif (!ps->netdev)\n\t\treturn -EPROBE_DEFER;\n\n\tpdata->cd.netdev[DSA_LOOP_CPU_PORT] = &ps->netdev->dev;\n\n\tds->dev = &mdiodev->dev;\n\tds->ops = &dsa_loop_driver;\n\tds->priv = ps;\n\tps->bus = mdiodev->bus;\n\n\tdev_set_drvdata(&mdiodev->dev, ds);\n\n\tret = dsa_register_switch(ds);\n\tif (!ret)\n\t\tdev_info(&mdiodev->dev, \"%s: 0x%0x\\n\",\n\t\t\t pdata->name, pdata->enabled_ports);\n\n\treturn ret;\n}\n\nstatic void dsa_loop_drv_remove(struct mdio_device *mdiodev)\n{\n\tstruct dsa_switch *ds = dev_get_drvdata(&mdiodev->dev);\n\tstruct dsa_loop_priv *ps;\n\n\tif (!ds)\n\t\treturn;\n\n\tps = ds->priv;\n\n\tdsa_unregister_switch(ds);\n\tdev_put(ps->netdev);\n}\n\nstatic void dsa_loop_drv_shutdown(struct mdio_device *mdiodev)\n{\n\tstruct dsa_switch *ds = dev_get_drvdata(&mdiodev->dev);\n\n\tif (!ds)\n\t\treturn;\n\n\tdsa_switch_shutdown(ds);\n\n\tdev_set_drvdata(&mdiodev->dev, NULL);\n}\n\nstatic struct mdio_driver dsa_loop_drv = {\n\t.mdiodrv.driver\t= {\n\t\t.name\t= \"dsa-loop\",\n\t},\n\t.probe\t= dsa_loop_drv_probe,\n\t.remove\t= dsa_loop_drv_remove,\n\t.shutdown = dsa_loop_drv_shutdown,\n};\n\n#define NUM_FIXED_PHYS\t(DSA_LOOP_NUM_PORTS - 2)\n\nstatic void dsa_loop_phydevs_unregister(void)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < NUM_FIXED_PHYS; i++)\n\t\tif (!IS_ERR(phydevs[i])) {\n\t\t\tfixed_phy_unregister(phydevs[i]);\n\t\t\tphy_device_free(phydevs[i]);\n\t\t}\n}\n\nstatic int __init dsa_loop_init(void)\n{\n\tstruct fixed_phy_status status = {\n\t\t.link = 1,\n\t\t.speed = SPEED_100,\n\t\t.duplex = DUPLEX_FULL,\n\t};\n\tunsigned int i, ret;\n\n\tfor (i = 0; i < NUM_FIXED_PHYS; i++)\n\t\tphydevs[i] = fixed_phy_register(PHY_POLL, &status, NULL);\n\n\tret = mdio_driver_register(&dsa_loop_drv);\n\tif (ret)\n\t\tdsa_loop_phydevs_unregister();\n\n\treturn ret;\n}\nmodule_init(dsa_loop_init);\n\nstatic void __exit dsa_loop_exit(void)\n{\n\tmdio_driver_unregister(&dsa_loop_drv);\n\tdsa_loop_phydevs_unregister();\n}\nmodule_exit(dsa_loop_exit);\n\nMODULE_SOFTDEP(\"pre: dsa_loop_bdinfo\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Florian Fainelli\");\nMODULE_DESCRIPTION(\"DSA loopback driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}