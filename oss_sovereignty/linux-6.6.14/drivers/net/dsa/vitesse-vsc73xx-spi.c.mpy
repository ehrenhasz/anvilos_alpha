{
  "module_name": "vitesse-vsc73xx-spi.c",
  "hash_id": "6cffacc987050c6dd7bfdf839af60fc439be5167a64118eeeb7be1070e415007",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/vitesse-vsc73xx-spi.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/spi/spi.h>\n\n#include \"vitesse-vsc73xx.h\"\n\n#define VSC73XX_CMD_SPI_MODE_READ\t\t0\n#define VSC73XX_CMD_SPI_MODE_WRITE\t\t1\n#define VSC73XX_CMD_SPI_MODE_SHIFT\t\t4\n#define VSC73XX_CMD_SPI_BLOCK_SHIFT\t\t5\n#define VSC73XX_CMD_SPI_BLOCK_MASK\t\t0x7\n#define VSC73XX_CMD_SPI_SUBBLOCK_MASK\t\t0xf\n\n \nstruct vsc73xx_spi {\n\tstruct spi_device\t*spi;\n\tstruct mutex\t\tlock;  \n\tstruct vsc73xx\t\tvsc;\n};\n\nstatic const struct vsc73xx_ops vsc73xx_spi_ops;\n\nstatic u8 vsc73xx_make_addr(u8 mode, u8 block, u8 subblock)\n{\n\tu8 ret;\n\n\tret =\n\t    (block & VSC73XX_CMD_SPI_BLOCK_MASK) << VSC73XX_CMD_SPI_BLOCK_SHIFT;\n\tret |= (mode & 1) << VSC73XX_CMD_SPI_MODE_SHIFT;\n\tret |= subblock & VSC73XX_CMD_SPI_SUBBLOCK_MASK;\n\n\treturn ret;\n}\n\nstatic int vsc73xx_spi_read(struct vsc73xx *vsc, u8 block, u8 subblock, u8 reg,\n\t\t\t    u32 *val)\n{\n\tstruct vsc73xx_spi *vsc_spi = vsc->priv;\n\tstruct spi_transfer t[2];\n\tstruct spi_message m;\n\tu8 cmd[4];\n\tu8 buf[4];\n\tint ret;\n\n\tif (!vsc73xx_is_addr_valid(block, subblock))\n\t\treturn -EINVAL;\n\n\tspi_message_init(&m);\n\n\tmemset(&t, 0, sizeof(t));\n\n\tt[0].tx_buf = cmd;\n\tt[0].len = sizeof(cmd);\n\tspi_message_add_tail(&t[0], &m);\n\n\tt[1].rx_buf = buf;\n\tt[1].len = sizeof(buf);\n\tspi_message_add_tail(&t[1], &m);\n\n\tcmd[0] = vsc73xx_make_addr(VSC73XX_CMD_SPI_MODE_READ, block, subblock);\n\tcmd[1] = reg;\n\tcmd[2] = 0;\n\tcmd[3] = 0;\n\n\tmutex_lock(&vsc_spi->lock);\n\tret = spi_sync(vsc_spi->spi, &m);\n\tmutex_unlock(&vsc_spi->lock);\n\n\tif (ret)\n\t\treturn ret;\n\n\t*val = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];\n\n\treturn 0;\n}\n\nstatic int vsc73xx_spi_write(struct vsc73xx *vsc, u8 block, u8 subblock, u8 reg,\n\t\t\t     u32 val)\n{\n\tstruct vsc73xx_spi *vsc_spi = vsc->priv;\n\tstruct spi_transfer t[2];\n\tstruct spi_message m;\n\tu8 cmd[2];\n\tu8 buf[4];\n\tint ret;\n\n\tif (!vsc73xx_is_addr_valid(block, subblock))\n\t\treturn -EINVAL;\n\n\tspi_message_init(&m);\n\n\tmemset(&t, 0, sizeof(t));\n\n\tt[0].tx_buf = cmd;\n\tt[0].len = sizeof(cmd);\n\tspi_message_add_tail(&t[0], &m);\n\n\tt[1].tx_buf = buf;\n\tt[1].len = sizeof(buf);\n\tspi_message_add_tail(&t[1], &m);\n\n\tcmd[0] = vsc73xx_make_addr(VSC73XX_CMD_SPI_MODE_WRITE, block, subblock);\n\tcmd[1] = reg;\n\n\tbuf[0] = (val >> 24) & 0xff;\n\tbuf[1] = (val >> 16) & 0xff;\n\tbuf[2] = (val >> 8) & 0xff;\n\tbuf[3] = val & 0xff;\n\n\tmutex_lock(&vsc_spi->lock);\n\tret = spi_sync(vsc_spi->spi, &m);\n\tmutex_unlock(&vsc_spi->lock);\n\n\treturn ret;\n}\n\nstatic int vsc73xx_spi_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct vsc73xx_spi *vsc_spi;\n\tint ret;\n\n\tvsc_spi = devm_kzalloc(dev, sizeof(*vsc_spi), GFP_KERNEL);\n\tif (!vsc_spi)\n\t\treturn -ENOMEM;\n\n\tspi_set_drvdata(spi, vsc_spi);\n\tvsc_spi->spi = spi_dev_get(spi);\n\tvsc_spi->vsc.dev = dev;\n\tvsc_spi->vsc.priv = vsc_spi;\n\tvsc_spi->vsc.ops = &vsc73xx_spi_ops;\n\tmutex_init(&vsc_spi->lock);\n\n\tspi->mode = SPI_MODE_0;\n\tspi->bits_per_word = 8;\n\tret = spi_setup(spi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"spi setup failed.\\n\");\n\t\treturn ret;\n\t}\n\n\treturn vsc73xx_probe(&vsc_spi->vsc);\n}\n\nstatic void vsc73xx_spi_remove(struct spi_device *spi)\n{\n\tstruct vsc73xx_spi *vsc_spi = spi_get_drvdata(spi);\n\n\tif (!vsc_spi)\n\t\treturn;\n\n\tvsc73xx_remove(&vsc_spi->vsc);\n}\n\nstatic void vsc73xx_spi_shutdown(struct spi_device *spi)\n{\n\tstruct vsc73xx_spi *vsc_spi = spi_get_drvdata(spi);\n\n\tif (!vsc_spi)\n\t\treturn;\n\n\tvsc73xx_shutdown(&vsc_spi->vsc);\n\n\tspi_set_drvdata(spi, NULL);\n}\n\nstatic const struct vsc73xx_ops vsc73xx_spi_ops = {\n\t.read = vsc73xx_spi_read,\n\t.write = vsc73xx_spi_write,\n};\n\nstatic const struct of_device_id vsc73xx_of_match[] = {\n\t{\n\t\t.compatible = \"vitesse,vsc7385\",\n\t},\n\t{\n\t\t.compatible = \"vitesse,vsc7388\",\n\t},\n\t{\n\t\t.compatible = \"vitesse,vsc7395\",\n\t},\n\t{\n\t\t.compatible = \"vitesse,vsc7398\",\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, vsc73xx_of_match);\n\nstatic const struct spi_device_id vsc73xx_spi_ids[] = {\n\t{ \"vsc7385\" },\n\t{ \"vsc7388\" },\n\t{ \"vsc7395\" },\n\t{ \"vsc7398\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(spi, vsc73xx_spi_ids);\n\nstatic struct spi_driver vsc73xx_spi_driver = {\n\t.probe = vsc73xx_spi_probe,\n\t.remove = vsc73xx_spi_remove,\n\t.shutdown = vsc73xx_spi_shutdown,\n\t.id_table = vsc73xx_spi_ids,\n\t.driver = {\n\t\t.name = \"vsc73xx-spi\",\n\t\t.of_match_table = vsc73xx_of_match,\n\t},\n};\nmodule_spi_driver(vsc73xx_spi_driver);\n\nMODULE_AUTHOR(\"Linus Walleij <linus.walleij@linaro.org>\");\nMODULE_DESCRIPTION(\"Vitesse VSC7385/7388/7395/7398 SPI driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}