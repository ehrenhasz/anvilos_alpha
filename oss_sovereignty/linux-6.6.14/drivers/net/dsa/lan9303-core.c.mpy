{
  "module_name": "lan9303-core.c",
  "hash_id": "5aa1e695c7c0cb4f86923a85bd99299dfc06bc8834a33b954f1a69c4e0c178e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/lan9303-core.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/gpio/consumer.h>\n#include <linux/regmap.h>\n#include <linux/mutex.h>\n#include <linux/mii.h>\n#include <linux/of.h>\n#include <linux/phy.h>\n#include <linux/if_bridge.h>\n#include <linux/if_vlan.h>\n#include <linux/etherdevice.h>\n\n#include \"lan9303.h\"\n\n \n#define IS_PORT_XMII(port)\t((port) == 0)\n\n#define LAN9303_NUM_PORTS 3\n\n \n#define LAN9303_CHIP_REV 0x14\n# define LAN9303_CHIP_ID 0x9303\n# define LAN9352_CHIP_ID 0x9352\n# define LAN9353_CHIP_ID 0x9353\n# define LAN9354_CHIP_ID 0x9354\n# define LAN9355_CHIP_ID 0x9355\n#define LAN9303_IRQ_CFG 0x15\n# define LAN9303_IRQ_CFG_IRQ_ENABLE BIT(8)\n# define LAN9303_IRQ_CFG_IRQ_POL BIT(4)\n# define LAN9303_IRQ_CFG_IRQ_TYPE BIT(0)\n#define LAN9303_INT_STS 0x16\n# define LAN9303_INT_STS_PHY_INT2 BIT(27)\n# define LAN9303_INT_STS_PHY_INT1 BIT(26)\n#define LAN9303_INT_EN 0x17\n# define LAN9303_INT_EN_PHY_INT2_EN BIT(27)\n# define LAN9303_INT_EN_PHY_INT1_EN BIT(26)\n#define LAN9303_BYTE_ORDER 0x19\n#define LAN9303_HW_CFG 0x1D\n# define LAN9303_HW_CFG_READY BIT(27)\n# define LAN9303_HW_CFG_AMDX_EN_PORT2 BIT(26)\n# define LAN9303_HW_CFG_AMDX_EN_PORT1 BIT(25)\n#define LAN9303_PMI_DATA 0x29\n#define LAN9303_PMI_ACCESS 0x2A\n# define LAN9303_PMI_ACCESS_PHY_ADDR(x) (((x) & 0x1f) << 11)\n# define LAN9303_PMI_ACCESS_MIIRINDA(x) (((x) & 0x1f) << 6)\n# define LAN9303_PMI_ACCESS_MII_BUSY BIT(0)\n# define LAN9303_PMI_ACCESS_MII_WRITE BIT(1)\n#define LAN9303_MANUAL_FC_1 0x68\n#define LAN9303_MANUAL_FC_2 0x69\n#define LAN9303_MANUAL_FC_0 0x6a\n# define LAN9303_BP_EN BIT(6)\n# define LAN9303_RX_FC_EN BIT(2)\n# define LAN9303_TX_FC_EN BIT(1)\n#define LAN9303_SWITCH_CSR_DATA 0x6b\n#define LAN9303_SWITCH_CSR_CMD 0x6c\n#define LAN9303_SWITCH_CSR_CMD_BUSY BIT(31)\n#define LAN9303_SWITCH_CSR_CMD_RW BIT(30)\n#define LAN9303_SWITCH_CSR_CMD_LANES (BIT(19) | BIT(18) | BIT(17) | BIT(16))\n#define LAN9303_VIRT_PHY_BASE 0x70\n#define LAN9303_VIRT_SPECIAL_CTRL 0x77\n#define  LAN9303_VIRT_SPECIAL_TURBO BIT(10)  \n\n \n#define LAN9303_SW_DEV_ID 0x0000\n#define LAN9303_SW_RESET 0x0001\n#define LAN9303_SW_RESET_RESET BIT(0)\n#define LAN9303_SW_IMR 0x0004\n#define LAN9303_SW_IPR 0x0005\n#define LAN9303_MAC_VER_ID_0 0x0400\n#define LAN9303_MAC_RX_CFG_0 0x0401\n# define LAN9303_MAC_RX_CFG_X_REJECT_MAC_TYPES BIT(1)\n# define LAN9303_MAC_RX_CFG_X_RX_ENABLE BIT(0)\n#define LAN9303_MAC_RX_UNDSZE_CNT_0 0x0410\n#define LAN9303_MAC_RX_64_CNT_0 0x0411\n#define LAN9303_MAC_RX_127_CNT_0 0x0412\n#define LAN9303_MAC_RX_255_CNT_0 0x413\n#define LAN9303_MAC_RX_511_CNT_0 0x0414\n#define LAN9303_MAC_RX_1023_CNT_0 0x0415\n#define LAN9303_MAC_RX_MAX_CNT_0 0x0416\n#define LAN9303_MAC_RX_OVRSZE_CNT_0 0x0417\n#define LAN9303_MAC_RX_PKTOK_CNT_0 0x0418\n#define LAN9303_MAC_RX_CRCERR_CNT_0 0x0419\n#define LAN9303_MAC_RX_MULCST_CNT_0 0x041a\n#define LAN9303_MAC_RX_BRDCST_CNT_0 0x041b\n#define LAN9303_MAC_RX_PAUSE_CNT_0 0x041c\n#define LAN9303_MAC_RX_FRAG_CNT_0 0x041d\n#define LAN9303_MAC_RX_JABB_CNT_0 0x041e\n#define LAN9303_MAC_RX_ALIGN_CNT_0 0x041f\n#define LAN9303_MAC_RX_PKTLEN_CNT_0 0x0420\n#define LAN9303_MAC_RX_GOODPKTLEN_CNT_0 0x0421\n#define LAN9303_MAC_RX_SYMBL_CNT_0 0x0422\n#define LAN9303_MAC_RX_CTLFRM_CNT_0 0x0423\n\n#define LAN9303_MAC_TX_CFG_0 0x0440\n# define LAN9303_MAC_TX_CFG_X_TX_IFG_CONFIG_DEFAULT (21 << 2)\n# define LAN9303_MAC_TX_CFG_X_TX_PAD_ENABLE BIT(1)\n# define LAN9303_MAC_TX_CFG_X_TX_ENABLE BIT(0)\n#define LAN9303_MAC_TX_DEFER_CNT_0 0x0451\n#define LAN9303_MAC_TX_PAUSE_CNT_0 0x0452\n#define LAN9303_MAC_TX_PKTOK_CNT_0 0x0453\n#define LAN9303_MAC_TX_64_CNT_0 0x0454\n#define LAN9303_MAC_TX_127_CNT_0 0x0455\n#define LAN9303_MAC_TX_255_CNT_0 0x0456\n#define LAN9303_MAC_TX_511_CNT_0 0x0457\n#define LAN9303_MAC_TX_1023_CNT_0 0x0458\n#define LAN9303_MAC_TX_MAX_CNT_0 0x0459\n#define LAN9303_MAC_TX_UNDSZE_CNT_0 0x045a\n#define LAN9303_MAC_TX_PKTLEN_CNT_0 0x045c\n#define LAN9303_MAC_TX_BRDCST_CNT_0 0x045d\n#define LAN9303_MAC_TX_MULCST_CNT_0 0x045e\n#define LAN9303_MAC_TX_LATECOL_0 0x045f\n#define LAN9303_MAC_TX_EXCOL_CNT_0 0x0460\n#define LAN9303_MAC_TX_SNGLECOL_CNT_0 0x0461\n#define LAN9303_MAC_TX_MULTICOL_CNT_0 0x0462\n#define LAN9303_MAC_TX_TOTALCOL_CNT_0 0x0463\n\n#define LAN9303_MAC_VER_ID_1 0x0800\n#define LAN9303_MAC_RX_CFG_1 0x0801\n#define LAN9303_MAC_TX_CFG_1 0x0840\n#define LAN9303_MAC_VER_ID_2 0x0c00\n#define LAN9303_MAC_RX_CFG_2 0x0c01\n#define LAN9303_MAC_TX_CFG_2 0x0c40\n#define LAN9303_SWE_ALR_CMD 0x1800\n# define LAN9303_ALR_CMD_MAKE_ENTRY    BIT(2)\n# define LAN9303_ALR_CMD_GET_FIRST     BIT(1)\n# define LAN9303_ALR_CMD_GET_NEXT      BIT(0)\n#define LAN9303_SWE_ALR_WR_DAT_0 0x1801\n#define LAN9303_SWE_ALR_WR_DAT_1 0x1802\n# define LAN9303_ALR_DAT1_VALID        BIT(26)\n# define LAN9303_ALR_DAT1_END_OF_TABL  BIT(25)\n# define LAN9303_ALR_DAT1_AGE_OVERRID  BIT(25)\n# define LAN9303_ALR_DAT1_STATIC       BIT(24)\n# define LAN9303_ALR_DAT1_PORT_BITOFFS  16\n# define LAN9303_ALR_DAT1_PORT_MASK    (7 << LAN9303_ALR_DAT1_PORT_BITOFFS)\n#define LAN9303_SWE_ALR_RD_DAT_0 0x1805\n#define LAN9303_SWE_ALR_RD_DAT_1 0x1806\n#define LAN9303_SWE_ALR_CMD_STS 0x1808\n# define ALR_STS_MAKE_PEND     BIT(0)\n#define LAN9303_SWE_VLAN_CMD 0x180b\n# define LAN9303_SWE_VLAN_CMD_RNW BIT(5)\n# define LAN9303_SWE_VLAN_CMD_PVIDNVLAN BIT(4)\n#define LAN9303_SWE_VLAN_WR_DATA 0x180c\n#define LAN9303_SWE_VLAN_RD_DATA 0x180e\n# define LAN9303_SWE_VLAN_MEMBER_PORT2 BIT(17)\n# define LAN9303_SWE_VLAN_UNTAG_PORT2 BIT(16)\n# define LAN9303_SWE_VLAN_MEMBER_PORT1 BIT(15)\n# define LAN9303_SWE_VLAN_UNTAG_PORT1 BIT(14)\n# define LAN9303_SWE_VLAN_MEMBER_PORT0 BIT(13)\n# define LAN9303_SWE_VLAN_UNTAG_PORT0 BIT(12)\n#define LAN9303_SWE_VLAN_CMD_STS 0x1810\n#define LAN9303_SWE_GLB_INGRESS_CFG 0x1840\n# define LAN9303_SWE_GLB_INGR_IGMP_TRAP BIT(7)\n# define LAN9303_SWE_GLB_INGR_IGMP_PORT(p) BIT(10 + p)\n#define LAN9303_SWE_PORT_STATE 0x1843\n# define LAN9303_SWE_PORT_STATE_FORWARDING_PORT2 (0)\n# define LAN9303_SWE_PORT_STATE_LEARNING_PORT2 BIT(5)\n# define LAN9303_SWE_PORT_STATE_BLOCKING_PORT2 BIT(4)\n# define LAN9303_SWE_PORT_STATE_FORWARDING_PORT1 (0)\n# define LAN9303_SWE_PORT_STATE_LEARNING_PORT1 BIT(3)\n# define LAN9303_SWE_PORT_STATE_BLOCKING_PORT1 BIT(2)\n# define LAN9303_SWE_PORT_STATE_FORWARDING_PORT0 (0)\n# define LAN9303_SWE_PORT_STATE_LEARNING_PORT0 BIT(1)\n# define LAN9303_SWE_PORT_STATE_BLOCKING_PORT0 BIT(0)\n# define LAN9303_SWE_PORT_STATE_DISABLED_PORT0 (3)\n#define LAN9303_SWE_PORT_MIRROR 0x1846\n# define LAN9303_SWE_PORT_MIRROR_SNIFF_ALL BIT(8)\n# define LAN9303_SWE_PORT_MIRROR_SNIFFER_PORT2 BIT(7)\n# define LAN9303_SWE_PORT_MIRROR_SNIFFER_PORT1 BIT(6)\n# define LAN9303_SWE_PORT_MIRROR_SNIFFER_PORT0 BIT(5)\n# define LAN9303_SWE_PORT_MIRROR_MIRRORED_PORT2 BIT(4)\n# define LAN9303_SWE_PORT_MIRROR_MIRRORED_PORT1 BIT(3)\n# define LAN9303_SWE_PORT_MIRROR_MIRRORED_PORT0 BIT(2)\n# define LAN9303_SWE_PORT_MIRROR_ENABLE_RX_MIRRORING BIT(1)\n# define LAN9303_SWE_PORT_MIRROR_ENABLE_TX_MIRRORING BIT(0)\n# define LAN9303_SWE_PORT_MIRROR_DISABLED 0\n#define LAN9303_SWE_INGRESS_PORT_TYPE 0x1847\n#define  LAN9303_SWE_INGRESS_PORT_TYPE_VLAN 3\n#define LAN9303_BM_CFG 0x1c00\n#define LAN9303_BM_EGRSS_PORT_TYPE 0x1c0c\n# define LAN9303_BM_EGRSS_PORT_TYPE_SPECIAL_TAG_PORT2 (BIT(17) | BIT(16))\n# define LAN9303_BM_EGRSS_PORT_TYPE_SPECIAL_TAG_PORT1 (BIT(9) | BIT(8))\n# define LAN9303_BM_EGRSS_PORT_TYPE_SPECIAL_TAG_PORT0 (BIT(1) | BIT(0))\n\n#define LAN9303_SWITCH_PORT_REG(port, reg0) (0x400 * (port) + (reg0))\n\n \n#define MII_LAN911X_SPECIAL_MODES 0x12\n#define MII_LAN911X_SPECIAL_CONTROL_STATUS 0x1f\n\nstatic const struct regmap_range lan9303_valid_regs[] = {\n\tregmap_reg_range(0x14, 0x17),  \n\tregmap_reg_range(0x19, 0x19),  \n\tregmap_reg_range(0x1d, 0x1d),  \n\tregmap_reg_range(0x23, 0x24),  \n\tregmap_reg_range(0x27, 0x27),  \n\tregmap_reg_range(0x29, 0x2a),  \n\tregmap_reg_range(0x68, 0x6a),  \n\tregmap_reg_range(0x6b, 0x6c),  \n\tregmap_reg_range(0x6d, 0x6f),  \n\tregmap_reg_range(0x70, 0x77),  \n\tregmap_reg_range(0x78, 0x7a),  \n\tregmap_reg_range(0x7c, 0x7e),  \n\tregmap_reg_range(0x80, 0xb7),  \n};\n\nstatic const struct regmap_range lan9303_reserved_ranges[] = {\n\tregmap_reg_range(0x00, 0x13),\n\tregmap_reg_range(0x18, 0x18),\n\tregmap_reg_range(0x1a, 0x1c),\n\tregmap_reg_range(0x1e, 0x22),\n\tregmap_reg_range(0x25, 0x26),\n\tregmap_reg_range(0x28, 0x28),\n\tregmap_reg_range(0x2b, 0x67),\n\tregmap_reg_range(0x7b, 0x7b),\n\tregmap_reg_range(0x7f, 0x7f),\n\tregmap_reg_range(0xb8, 0xff),\n};\n\nconst struct regmap_access_table lan9303_register_set = {\n\t.yes_ranges = lan9303_valid_regs,\n\t.n_yes_ranges = ARRAY_SIZE(lan9303_valid_regs),\n\t.no_ranges = lan9303_reserved_ranges,\n\t.n_no_ranges = ARRAY_SIZE(lan9303_reserved_ranges),\n};\nEXPORT_SYMBOL(lan9303_register_set);\n\n \nstatic unsigned int flow_ctl_reg[] = {\n\tLAN9303_MANUAL_FC_0,\n\tLAN9303_MANUAL_FC_1,\n\tLAN9303_MANUAL_FC_2\n};\n\nstatic int lan9303_read(struct regmap *regmap, unsigned int offset, u32 *reg)\n{\n\tint ret, i;\n\n\t \n\tfor (i = 0; i < 5; i++) {\n\t\tret = regmap_read(regmap, offset, reg);\n\t\tif (!ret)\n\t\t\treturn 0;\n\t\tif (ret != -EAGAIN)\n\t\t\tbreak;\n\t\tmsleep(500);\n\t}\n\n\treturn -EIO;\n}\n\nstatic int lan9303_read_wait(struct lan9303 *chip, int offset, u32 mask)\n{\n\tint i;\n\n\tfor (i = 0; i < 25; i++) {\n\t\tu32 reg;\n\t\tint ret;\n\n\t\tret = lan9303_read(chip->regmap, offset, &reg);\n\t\tif (ret) {\n\t\t\tdev_err(chip->dev, \"%s failed to read offset %d: %d\\n\",\n\t\t\t\t__func__, offset, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(reg & mask))\n\t\t\treturn 0;\n\t\tusleep_range(1000, 2000);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int lan9303_virt_phy_reg_read(struct lan9303 *chip, int regnum)\n{\n\tint ret;\n\tu32 val;\n\n\tif (regnum > MII_EXPANSION)\n\t\treturn -EINVAL;\n\n\tret = lan9303_read(chip->regmap, LAN9303_VIRT_PHY_BASE + regnum, &val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn val & 0xffff;\n}\n\nstatic int lan9303_virt_phy_reg_write(struct lan9303 *chip, int regnum, u16 val)\n{\n\tif (regnum > MII_EXPANSION)\n\t\treturn -EINVAL;\n\n\treturn regmap_write(chip->regmap, LAN9303_VIRT_PHY_BASE + regnum, val);\n}\n\nstatic int lan9303_indirect_phy_wait_for_completion(struct lan9303 *chip)\n{\n\treturn lan9303_read_wait(chip, LAN9303_PMI_ACCESS,\n\t\t\t\t LAN9303_PMI_ACCESS_MII_BUSY);\n}\n\nstatic int lan9303_indirect_phy_read(struct lan9303 *chip, int addr, int regnum)\n{\n\tint ret;\n\tu32 val;\n\n\tval = LAN9303_PMI_ACCESS_PHY_ADDR(addr);\n\tval |= LAN9303_PMI_ACCESS_MIIRINDA(regnum);\n\n\tmutex_lock(&chip->indirect_mutex);\n\n\tret = lan9303_indirect_phy_wait_for_completion(chip);\n\tif (ret)\n\t\tgoto on_error;\n\n\t \n\tret = regmap_write(chip->regmap, LAN9303_PMI_ACCESS, val);\n\tif (ret)\n\t\tgoto on_error;\n\n\tret = lan9303_indirect_phy_wait_for_completion(chip);\n\tif (ret)\n\t\tgoto on_error;\n\n\t \n\tret = lan9303_read(chip->regmap, LAN9303_PMI_DATA, &val);\n\tif (ret)\n\t\tgoto on_error;\n\n\tmutex_unlock(&chip->indirect_mutex);\n\n\treturn val & 0xffff;\n\non_error:\n\tmutex_unlock(&chip->indirect_mutex);\n\treturn ret;\n}\n\nstatic int lan9303_indirect_phy_write(struct lan9303 *chip, int addr,\n\t\t\t\t      int regnum, u16 val)\n{\n\tint ret;\n\tu32 reg;\n\n\treg = LAN9303_PMI_ACCESS_PHY_ADDR(addr);\n\treg |= LAN9303_PMI_ACCESS_MIIRINDA(regnum);\n\treg |= LAN9303_PMI_ACCESS_MII_WRITE;\n\n\tmutex_lock(&chip->indirect_mutex);\n\n\tret = lan9303_indirect_phy_wait_for_completion(chip);\n\tif (ret)\n\t\tgoto on_error;\n\n\t \n\tret = regmap_write(chip->regmap, LAN9303_PMI_DATA, val);\n\tif (ret)\n\t\tgoto on_error;\n\n\t \n\tret = regmap_write(chip->regmap, LAN9303_PMI_ACCESS, reg);\n\non_error:\n\tmutex_unlock(&chip->indirect_mutex);\n\treturn ret;\n}\n\nconst struct lan9303_phy_ops lan9303_indirect_phy_ops = {\n\t.phy_read = lan9303_indirect_phy_read,\n\t.phy_write = lan9303_indirect_phy_write,\n};\nEXPORT_SYMBOL_GPL(lan9303_indirect_phy_ops);\n\nstatic int lan9303_switch_wait_for_completion(struct lan9303 *chip)\n{\n\treturn lan9303_read_wait(chip, LAN9303_SWITCH_CSR_CMD,\n\t\t\t\t LAN9303_SWITCH_CSR_CMD_BUSY);\n}\n\nstatic int lan9303_write_switch_reg(struct lan9303 *chip, u16 regnum, u32 val)\n{\n\tu32 reg;\n\tint ret;\n\n\treg = regnum;\n\treg |= LAN9303_SWITCH_CSR_CMD_LANES;\n\treg |= LAN9303_SWITCH_CSR_CMD_BUSY;\n\n\tmutex_lock(&chip->indirect_mutex);\n\n\tret = lan9303_switch_wait_for_completion(chip);\n\tif (ret)\n\t\tgoto on_error;\n\n\tret = regmap_write(chip->regmap, LAN9303_SWITCH_CSR_DATA, val);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"Failed to write csr data reg: %d\\n\", ret);\n\t\tgoto on_error;\n\t}\n\n\t \n\tret = regmap_write(chip->regmap, LAN9303_SWITCH_CSR_CMD, reg);\n\tif (ret)\n\t\tdev_err(chip->dev, \"Failed to write csr command reg: %d\\n\",\n\t\t\tret);\n\non_error:\n\tmutex_unlock(&chip->indirect_mutex);\n\treturn ret;\n}\n\nstatic int lan9303_read_switch_reg(struct lan9303 *chip, u16 regnum, u32 *val)\n{\n\tu32 reg;\n\tint ret;\n\n\treg = regnum;\n\treg |= LAN9303_SWITCH_CSR_CMD_LANES;\n\treg |= LAN9303_SWITCH_CSR_CMD_RW;\n\treg |= LAN9303_SWITCH_CSR_CMD_BUSY;\n\n\tmutex_lock(&chip->indirect_mutex);\n\n\tret = lan9303_switch_wait_for_completion(chip);\n\tif (ret)\n\t\tgoto on_error;\n\n\t \n\tret = regmap_write(chip->regmap, LAN9303_SWITCH_CSR_CMD, reg);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"Failed to write csr command reg: %d\\n\",\n\t\t\tret);\n\t\tgoto on_error;\n\t}\n\n\tret = lan9303_switch_wait_for_completion(chip);\n\tif (ret)\n\t\tgoto on_error;\n\n\tret = lan9303_read(chip->regmap, LAN9303_SWITCH_CSR_DATA, val);\n\tif (ret)\n\t\tdev_err(chip->dev, \"Failed to read csr data reg: %d\\n\", ret);\non_error:\n\tmutex_unlock(&chip->indirect_mutex);\n\treturn ret;\n}\n\nstatic int lan9303_write_switch_reg_mask(struct lan9303 *chip, u16 regnum,\n\t\t\t\t\t u32 val, u32 mask)\n{\n\tint ret;\n\tu32 reg;\n\n\tret = lan9303_read_switch_reg(chip, regnum, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\treg = (reg & ~mask) | val;\n\n\treturn lan9303_write_switch_reg(chip, regnum, reg);\n}\n\nstatic int lan9303_write_switch_port(struct lan9303 *chip, int port,\n\t\t\t\t     u16 regnum, u32 val)\n{\n\treturn lan9303_write_switch_reg(\n\t\tchip, LAN9303_SWITCH_PORT_REG(port, regnum), val);\n}\n\nstatic int lan9303_read_switch_port(struct lan9303 *chip, int port,\n\t\t\t\t    u16 regnum, u32 *val)\n{\n\treturn lan9303_read_switch_reg(\n\t\tchip, LAN9303_SWITCH_PORT_REG(port, regnum), val);\n}\n\nstatic int lan9303_detect_phy_setup(struct lan9303 *chip)\n{\n\tint reg;\n\n\t \n\treg = chip->ops->phy_read(chip, 3, MII_LAN911X_SPECIAL_MODES);\n\tif (reg < 0) {\n\t\tdev_err(chip->dev, \"Failed to detect phy config: %d\\n\", reg);\n\t\treturn reg;\n\t}\n\n\tchip->phy_addr_base = reg != 0 && reg != 0xffff;\n\n\tdev_dbg(chip->dev, \"Phy setup '%s' detected\\n\",\n\t\tchip->phy_addr_base ? \"1-2-3\" : \"0-1-2\");\n\n\treturn 0;\n}\n\n \nstatic const int alrport_2_portmap[] = {1, 2, 4, 0, 3, 5, 6, 7 };\nstatic const int portmap_2_alrport[] = {3, 0, 1, 4, 2, 5, 6, 7 };\n\n \nstatic struct lan9303_alr_cache_entry *\nlan9303_alr_cache_find_free(struct lan9303 *chip)\n{\n\tint i;\n\tstruct lan9303_alr_cache_entry *entr = chip->alr_cache;\n\n\tfor (i = 0; i < LAN9303_NUM_ALR_RECORDS; i++, entr++)\n\t\tif (entr->port_map == 0)\n\t\t\treturn entr;\n\n\treturn NULL;\n}\n\n \nstatic struct lan9303_alr_cache_entry *\nlan9303_alr_cache_find_mac(struct lan9303 *chip, const u8 *mac_addr)\n{\n\tint i;\n\tstruct lan9303_alr_cache_entry *entr = chip->alr_cache;\n\n\tBUILD_BUG_ON_MSG(sizeof(struct lan9303_alr_cache_entry) & 1,\n\t\t\t \"ether_addr_equal require u16 alignment\");\n\n\tfor (i = 0; i < LAN9303_NUM_ALR_RECORDS; i++, entr++)\n\t\tif (ether_addr_equal(entr->mac_addr, mac_addr))\n\t\t\treturn entr;\n\n\treturn NULL;\n}\n\nstatic int lan9303_csr_reg_wait(struct lan9303 *chip, int regno, u32 mask)\n{\n\tint i;\n\n\tfor (i = 0; i < 25; i++) {\n\t\tu32 reg;\n\n\t\tlan9303_read_switch_reg(chip, regno, &reg);\n\t\tif (!(reg & mask))\n\t\t\treturn 0;\n\t\tusleep_range(1000, 2000);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int lan9303_alr_make_entry_raw(struct lan9303 *chip, u32 dat0, u32 dat1)\n{\n\tlan9303_write_switch_reg(chip, LAN9303_SWE_ALR_WR_DAT_0, dat0);\n\tlan9303_write_switch_reg(chip, LAN9303_SWE_ALR_WR_DAT_1, dat1);\n\tlan9303_write_switch_reg(chip, LAN9303_SWE_ALR_CMD,\n\t\t\t\t LAN9303_ALR_CMD_MAKE_ENTRY);\n\tlan9303_csr_reg_wait(chip, LAN9303_SWE_ALR_CMD_STS, ALR_STS_MAKE_PEND);\n\tlan9303_write_switch_reg(chip, LAN9303_SWE_ALR_CMD, 0);\n\n\treturn 0;\n}\n\ntypedef int alr_loop_cb_t(struct lan9303 *chip, u32 dat0, u32 dat1,\n\t\t\t  int portmap, void *ctx);\n\nstatic int lan9303_alr_loop(struct lan9303 *chip, alr_loop_cb_t *cb, void *ctx)\n{\n\tint ret = 0, i;\n\n\tmutex_lock(&chip->alr_mutex);\n\tlan9303_write_switch_reg(chip, LAN9303_SWE_ALR_CMD,\n\t\t\t\t LAN9303_ALR_CMD_GET_FIRST);\n\tlan9303_write_switch_reg(chip, LAN9303_SWE_ALR_CMD, 0);\n\n\tfor (i = 1; i < LAN9303_NUM_ALR_RECORDS; i++) {\n\t\tu32 dat0, dat1;\n\t\tint alrport, portmap;\n\n\t\tlan9303_read_switch_reg(chip, LAN9303_SWE_ALR_RD_DAT_0, &dat0);\n\t\tlan9303_read_switch_reg(chip, LAN9303_SWE_ALR_RD_DAT_1, &dat1);\n\t\tif (dat1 & LAN9303_ALR_DAT1_END_OF_TABL)\n\t\t\tbreak;\n\n\t\talrport = (dat1 & LAN9303_ALR_DAT1_PORT_MASK) >>\n\t\t\t\t\t\tLAN9303_ALR_DAT1_PORT_BITOFFS;\n\t\tportmap = alrport_2_portmap[alrport];\n\n\t\tret = cb(chip, dat0, dat1, portmap, ctx);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tlan9303_write_switch_reg(chip, LAN9303_SWE_ALR_CMD,\n\t\t\t\t\t LAN9303_ALR_CMD_GET_NEXT);\n\t\tlan9303_write_switch_reg(chip, LAN9303_SWE_ALR_CMD, 0);\n\t}\n\tmutex_unlock(&chip->alr_mutex);\n\n\treturn ret;\n}\n\nstatic void alr_reg_to_mac(u32 dat0, u32 dat1, u8 mac[6])\n{\n\tmac[0] = (dat0 >>  0) & 0xff;\n\tmac[1] = (dat0 >>  8) & 0xff;\n\tmac[2] = (dat0 >> 16) & 0xff;\n\tmac[3] = (dat0 >> 24) & 0xff;\n\tmac[4] = (dat1 >>  0) & 0xff;\n\tmac[5] = (dat1 >>  8) & 0xff;\n}\n\nstruct del_port_learned_ctx {\n\tint port;\n};\n\n \nstatic int alr_loop_cb_del_port_learned(struct lan9303 *chip, u32 dat0,\n\t\t\t\t\tu32 dat1, int portmap, void *ctx)\n{\n\tstruct del_port_learned_ctx *del_ctx = ctx;\n\tint port = del_ctx->port;\n\n\tif (((BIT(port) & portmap) == 0) || (dat1 & LAN9303_ALR_DAT1_STATIC))\n\t\treturn 0;\n\n\t \n\tdat1 &= ~LAN9303_ALR_DAT1_VALID;  \n\tlan9303_alr_make_entry_raw(chip, dat0, dat1);\n\n\treturn 0;\n}\n\nstruct port_fdb_dump_ctx {\n\tint port;\n\tvoid *data;\n\tdsa_fdb_dump_cb_t *cb;\n};\n\nstatic int alr_loop_cb_fdb_port_dump(struct lan9303 *chip, u32 dat0,\n\t\t\t\t     u32 dat1, int portmap, void *ctx)\n{\n\tstruct port_fdb_dump_ctx *dump_ctx = ctx;\n\tu8 mac[ETH_ALEN];\n\tbool is_static;\n\n\tif ((BIT(dump_ctx->port) & portmap) == 0)\n\t\treturn 0;\n\n\talr_reg_to_mac(dat0, dat1, mac);\n\tis_static = !!(dat1 & LAN9303_ALR_DAT1_STATIC);\n\treturn dump_ctx->cb(mac, 0, is_static, dump_ctx->data);\n}\n\n \nstatic void lan9303_alr_set_entry(struct lan9303 *chip, const u8 *mac,\n\t\t\t\t  u8 port_map, bool stp_override)\n{\n\tu32 dat0, dat1, alr_port;\n\n\tdev_dbg(chip->dev, \"%s(%pM, %d)\\n\", __func__, mac, port_map);\n\tdat1 = LAN9303_ALR_DAT1_STATIC;\n\tif (port_map)\n\t\tdat1 |= LAN9303_ALR_DAT1_VALID;\n\t \n\tif (stp_override)\n\t\tdat1 |= LAN9303_ALR_DAT1_AGE_OVERRID;\n\n\talr_port = portmap_2_alrport[port_map & 7];\n\tdat1 &= ~LAN9303_ALR_DAT1_PORT_MASK;\n\tdat1 |= alr_port << LAN9303_ALR_DAT1_PORT_BITOFFS;\n\n\tdat0 = 0;\n\tdat0 |= (mac[0] << 0);\n\tdat0 |= (mac[1] << 8);\n\tdat0 |= (mac[2] << 16);\n\tdat0 |= (mac[3] << 24);\n\n\tdat1 |= (mac[4] << 0);\n\tdat1 |= (mac[5] << 8);\n\n\tlan9303_alr_make_entry_raw(chip, dat0, dat1);\n}\n\n \nstatic int lan9303_alr_add_port(struct lan9303 *chip, const u8 *mac, int port,\n\t\t\t\tbool stp_override)\n{\n\tstruct lan9303_alr_cache_entry *entr;\n\n\tmutex_lock(&chip->alr_mutex);\n\tentr = lan9303_alr_cache_find_mac(chip, mac);\n\tif (!entr) {  \n\t\tentr = lan9303_alr_cache_find_free(chip);\n\t\tif (!entr) {\n\t\t\tmutex_unlock(&chip->alr_mutex);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tether_addr_copy(entr->mac_addr, mac);\n\t}\n\tentr->port_map |= BIT(port);\n\tentr->stp_override = stp_override;\n\tlan9303_alr_set_entry(chip, mac, entr->port_map, stp_override);\n\tmutex_unlock(&chip->alr_mutex);\n\n\treturn 0;\n}\n\n \nstatic int lan9303_alr_del_port(struct lan9303 *chip, const u8 *mac, int port)\n{\n\tstruct lan9303_alr_cache_entry *entr;\n\n\tmutex_lock(&chip->alr_mutex);\n\tentr = lan9303_alr_cache_find_mac(chip, mac);\n\tif (!entr)\n\t\tgoto out;   \n\n\tentr->port_map &= ~BIT(port);\n\tif (entr->port_map == 0)  \n\t\teth_zero_addr(entr->mac_addr);\n\tlan9303_alr_set_entry(chip, mac, entr->port_map, entr->stp_override);\n\nout:\n\tmutex_unlock(&chip->alr_mutex);\n\treturn 0;\n}\n\nstatic int lan9303_disable_processing_port(struct lan9303 *chip,\n\t\t\t\t\t   unsigned int port)\n{\n\tint ret;\n\n\t \n\tret = lan9303_write_switch_port(chip, port, LAN9303_MAC_RX_CFG_0,\n\t\t\t\t\tLAN9303_MAC_RX_CFG_X_REJECT_MAC_TYPES);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn lan9303_write_switch_port(chip, port, LAN9303_MAC_TX_CFG_0,\n\t\t\t\tLAN9303_MAC_TX_CFG_X_TX_IFG_CONFIG_DEFAULT |\n\t\t\t\tLAN9303_MAC_TX_CFG_X_TX_PAD_ENABLE);\n}\n\nstatic int lan9303_enable_processing_port(struct lan9303 *chip,\n\t\t\t\t\t  unsigned int port)\n{\n\tint ret;\n\n\t \n\tret = lan9303_write_switch_port(chip, port, LAN9303_MAC_RX_CFG_0,\n\t\t\t\t\tLAN9303_MAC_RX_CFG_X_REJECT_MAC_TYPES |\n\t\t\t\t\tLAN9303_MAC_RX_CFG_X_RX_ENABLE);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn lan9303_write_switch_port(chip, port, LAN9303_MAC_TX_CFG_0,\n\t\t\t\tLAN9303_MAC_TX_CFG_X_TX_IFG_CONFIG_DEFAULT |\n\t\t\t\tLAN9303_MAC_TX_CFG_X_TX_PAD_ENABLE |\n\t\t\t\tLAN9303_MAC_TX_CFG_X_TX_ENABLE);\n}\n\n \nstatic int lan9303_setup_tagging(struct lan9303 *chip)\n{\n\tint ret;\n\tu32 val;\n\t \n\tret = lan9303_write_switch_reg(chip, LAN9303_SWE_INGRESS_PORT_TYPE,\n\t\t\t\t       LAN9303_SWE_INGRESS_PORT_TYPE_VLAN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tval = LAN9303_BM_EGRSS_PORT_TYPE_SPECIAL_TAG_PORT0;\n\treturn lan9303_write_switch_reg(chip, LAN9303_BM_EGRSS_PORT_TYPE, val);\n}\n\n \nstatic int lan9303_separate_ports(struct lan9303 *chip)\n{\n\tint ret;\n\n\tlan9303_alr_del_port(chip, eth_stp_addr, 0);\n\tret = lan9303_write_switch_reg(chip, LAN9303_SWE_PORT_MIRROR,\n\t\t\t\tLAN9303_SWE_PORT_MIRROR_SNIFFER_PORT0 |\n\t\t\t\tLAN9303_SWE_PORT_MIRROR_MIRRORED_PORT1 |\n\t\t\t\tLAN9303_SWE_PORT_MIRROR_MIRRORED_PORT2 |\n\t\t\t\tLAN9303_SWE_PORT_MIRROR_ENABLE_RX_MIRRORING |\n\t\t\t\tLAN9303_SWE_PORT_MIRROR_SNIFF_ALL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn lan9303_write_switch_reg(chip, LAN9303_SWE_PORT_STATE,\n\t\t\t\tLAN9303_SWE_PORT_STATE_FORWARDING_PORT0 |\n\t\t\t\tLAN9303_SWE_PORT_STATE_BLOCKING_PORT1 |\n\t\t\t\tLAN9303_SWE_PORT_STATE_BLOCKING_PORT2);\n}\n\nstatic void lan9303_bridge_ports(struct lan9303 *chip)\n{\n\t \n\tlan9303_write_switch_reg(chip, LAN9303_SWE_PORT_MIRROR,\n\t\t\t\t LAN9303_SWE_PORT_MIRROR_DISABLED);\n\n\tlan9303_write_switch_reg(chip, LAN9303_SWE_PORT_STATE,\n\t\t\t\t chip->swe_port_state);\n\tlan9303_alr_add_port(chip, eth_stp_addr, 0, true);\n}\n\nstatic void lan9303_handle_reset(struct lan9303 *chip)\n{\n\tif (!chip->reset_gpio)\n\t\treturn;\n\n\tif (chip->reset_duration != 0)\n\t\tmsleep(chip->reset_duration);\n\n\t \n\tgpiod_set_value_cansleep(chip->reset_gpio, 0);\n}\n\n \nstatic int lan9303_disable_processing(struct lan9303 *chip)\n{\n\tint p;\n\n\tfor (p = 1; p < LAN9303_NUM_PORTS; p++) {\n\t\tint ret = lan9303_disable_processing_port(chip, p);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int lan9303_check_device(struct lan9303 *chip)\n{\n\tint ret;\n\tu32 reg;\n\n\tret = lan9303_read(chip->regmap, LAN9303_CHIP_REV, &reg);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"failed to read chip revision register: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tif (((reg >> 16) != LAN9303_CHIP_ID) &&\n\t    ((reg >> 16) != LAN9354_CHIP_ID)) {\n\t\tdev_err(chip->dev, \"unexpected device found: LAN%4.4X\\n\",\n\t\t\treg >> 16);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tret = lan9303_disable_processing(chip);\n\tif (ret)\n\t\tdev_warn(chip->dev, \"failed to disable switching %d\\n\", ret);\n\n\tdev_info(chip->dev, \"Found LAN%4.4X rev. %u\\n\", (reg >> 16), reg & 0xffff);\n\n\tret = lan9303_detect_phy_setup(chip);\n\tif (ret) {\n\t\tdev_err(chip->dev,\n\t\t\t\"failed to discover phy bootstrap setup: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic enum dsa_tag_protocol lan9303_get_tag_protocol(struct dsa_switch *ds,\n\t\t\t\t\t\t      int port,\n\t\t\t\t\t\t      enum dsa_tag_protocol mp)\n{\n\treturn DSA_TAG_PROTO_LAN9303;\n}\n\nstatic int lan9303_setup(struct dsa_switch *ds)\n{\n\tstruct lan9303 *chip = ds->priv;\n\tint ret;\n\tu32 reg;\n\n\t \n\tif (!dsa_is_cpu_port(ds, 0)) {\n\t\tdev_err(chip->dev, \"port 0 is not the CPU port\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = lan9303_read(chip->regmap, LAN9303_VIRT_SPECIAL_CTRL, &reg);\n\tif (ret)\n\t\treturn (ret);\n\n\t \n\tif (reg & LAN9303_VIRT_SPECIAL_TURBO) {\n\t\treg &= ~LAN9303_VIRT_SPECIAL_TURBO;\n\t\tregmap_write(chip->regmap, LAN9303_VIRT_SPECIAL_CTRL, reg);\n\t}\n\n\tret = lan9303_setup_tagging(chip);\n\tif (ret)\n\t\tdev_err(chip->dev, \"failed to setup port tagging %d\\n\", ret);\n\n\tret = lan9303_separate_ports(chip);\n\tif (ret)\n\t\tdev_err(chip->dev, \"failed to separate ports %d\\n\", ret);\n\n\tret = lan9303_enable_processing_port(chip, 0);\n\tif (ret)\n\t\tdev_err(chip->dev, \"failed to re-enable switching %d\\n\", ret);\n\n\t \n\tret = lan9303_write_switch_reg_mask(chip, LAN9303_SWE_GLB_INGRESS_CFG,\n\t\t\t\t\t    LAN9303_SWE_GLB_INGR_IGMP_TRAP |\n\t\t\t\t\t    LAN9303_SWE_GLB_INGR_IGMP_PORT(0),\n\t\t\t\t\t    LAN9303_SWE_GLB_INGR_IGMP_PORT(1) |\n\t\t\t\t\t    LAN9303_SWE_GLB_INGR_IGMP_PORT(2));\n\tif (ret)\n\t\tdev_err(chip->dev, \"failed to setup IGMP trap %d\\n\", ret);\n\n\treturn 0;\n}\n\nstruct lan9303_mib_desc {\n\tunsigned int offset;  \n\tconst char *name;\n};\n\nstatic const struct lan9303_mib_desc lan9303_mib[] = {\n\t{ .offset = LAN9303_MAC_RX_BRDCST_CNT_0, .name = \"RxBroad\", },\n\t{ .offset = LAN9303_MAC_RX_PAUSE_CNT_0, .name = \"RxPause\", },\n\t{ .offset = LAN9303_MAC_RX_MULCST_CNT_0, .name = \"RxMulti\", },\n\t{ .offset = LAN9303_MAC_RX_PKTOK_CNT_0, .name = \"RxOk\", },\n\t{ .offset = LAN9303_MAC_RX_CRCERR_CNT_0, .name = \"RxCrcErr\", },\n\t{ .offset = LAN9303_MAC_RX_ALIGN_CNT_0, .name = \"RxAlignErr\", },\n\t{ .offset = LAN9303_MAC_RX_JABB_CNT_0, .name = \"RxJabber\", },\n\t{ .offset = LAN9303_MAC_RX_FRAG_CNT_0, .name = \"RxFragment\", },\n\t{ .offset = LAN9303_MAC_RX_64_CNT_0, .name = \"Rx64Byte\", },\n\t{ .offset = LAN9303_MAC_RX_127_CNT_0, .name = \"Rx128Byte\", },\n\t{ .offset = LAN9303_MAC_RX_255_CNT_0, .name = \"Rx256Byte\", },\n\t{ .offset = LAN9303_MAC_RX_511_CNT_0, .name = \"Rx512Byte\", },\n\t{ .offset = LAN9303_MAC_RX_1023_CNT_0, .name = \"Rx1024Byte\", },\n\t{ .offset = LAN9303_MAC_RX_MAX_CNT_0, .name = \"RxMaxByte\", },\n\t{ .offset = LAN9303_MAC_RX_PKTLEN_CNT_0, .name = \"RxByteCnt\", },\n\t{ .offset = LAN9303_MAC_RX_SYMBL_CNT_0, .name = \"RxSymbolCnt\", },\n\t{ .offset = LAN9303_MAC_RX_CTLFRM_CNT_0, .name = \"RxCfs\", },\n\t{ .offset = LAN9303_MAC_RX_OVRSZE_CNT_0, .name = \"RxOverFlow\", },\n\t{ .offset = LAN9303_MAC_TX_UNDSZE_CNT_0, .name = \"TxShort\", },\n\t{ .offset = LAN9303_MAC_TX_BRDCST_CNT_0, .name = \"TxBroad\", },\n\t{ .offset = LAN9303_MAC_TX_PAUSE_CNT_0, .name = \"TxPause\", },\n\t{ .offset = LAN9303_MAC_TX_MULCST_CNT_0, .name = \"TxMulti\", },\n\t{ .offset = LAN9303_MAC_RX_UNDSZE_CNT_0, .name = \"RxShort\", },\n\t{ .offset = LAN9303_MAC_TX_64_CNT_0, .name = \"Tx64Byte\", },\n\t{ .offset = LAN9303_MAC_TX_127_CNT_0, .name = \"Tx128Byte\", },\n\t{ .offset = LAN9303_MAC_TX_255_CNT_0, .name = \"Tx256Byte\", },\n\t{ .offset = LAN9303_MAC_TX_511_CNT_0, .name = \"Tx512Byte\", },\n\t{ .offset = LAN9303_MAC_TX_1023_CNT_0, .name = \"Tx1024Byte\", },\n\t{ .offset = LAN9303_MAC_TX_MAX_CNT_0, .name = \"TxMaxByte\", },\n\t{ .offset = LAN9303_MAC_TX_PKTLEN_CNT_0, .name = \"TxByteCnt\", },\n\t{ .offset = LAN9303_MAC_TX_PKTOK_CNT_0, .name = \"TxOk\", },\n\t{ .offset = LAN9303_MAC_TX_TOTALCOL_CNT_0, .name = \"TxCollision\", },\n\t{ .offset = LAN9303_MAC_TX_MULTICOL_CNT_0, .name = \"TxMultiCol\", },\n\t{ .offset = LAN9303_MAC_TX_SNGLECOL_CNT_0, .name = \"TxSingleCol\", },\n\t{ .offset = LAN9303_MAC_TX_EXCOL_CNT_0, .name = \"TxExcCol\", },\n\t{ .offset = LAN9303_MAC_TX_DEFER_CNT_0, .name = \"TxDefer\", },\n\t{ .offset = LAN9303_MAC_TX_LATECOL_0, .name = \"TxLateCol\", },\n};\n\nstatic void lan9303_get_strings(struct dsa_switch *ds, int port,\n\t\t\t\tu32 stringset, uint8_t *data)\n{\n\tunsigned int u;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tfor (u = 0; u < ARRAY_SIZE(lan9303_mib); u++) {\n\t\tstrncpy(data + u * ETH_GSTRING_LEN, lan9303_mib[u].name,\n\t\t\tETH_GSTRING_LEN);\n\t}\n}\n\nstatic void lan9303_get_ethtool_stats(struct dsa_switch *ds, int port,\n\t\t\t\t      uint64_t *data)\n{\n\tstruct lan9303 *chip = ds->priv;\n\tunsigned int u;\n\n\tfor (u = 0; u < ARRAY_SIZE(lan9303_mib); u++) {\n\t\tu32 reg;\n\t\tint ret;\n\n\t\tret = lan9303_read_switch_port(\n\t\t\tchip, port, lan9303_mib[u].offset, &reg);\n\n\t\tif (ret) {\n\t\t\tdev_warn(chip->dev, \"Reading status port %d reg %u failed\\n\",\n\t\t\t\t port, lan9303_mib[u].offset);\n\t\t\treg = 0;\n\t\t}\n\t\tdata[u] = reg;\n\t}\n}\n\nstatic int lan9303_get_sset_count(struct dsa_switch *ds, int port, int sset)\n{\n\tif (sset != ETH_SS_STATS)\n\t\treturn 0;\n\n\treturn ARRAY_SIZE(lan9303_mib);\n}\n\nstatic int lan9303_phy_read(struct dsa_switch *ds, int phy, int regnum)\n{\n\tstruct lan9303 *chip = ds->priv;\n\tint phy_base = chip->phy_addr_base;\n\n\tif (phy == phy_base)\n\t\treturn lan9303_virt_phy_reg_read(chip, regnum);\n\tif (phy > phy_base + 2)\n\t\treturn -ENODEV;\n\n\treturn chip->ops->phy_read(chip, phy, regnum);\n}\n\nstatic int lan9303_phy_write(struct dsa_switch *ds, int phy, int regnum,\n\t\t\t     u16 val)\n{\n\tstruct lan9303 *chip = ds->priv;\n\tint phy_base = chip->phy_addr_base;\n\n\tif (phy == phy_base)\n\t\treturn lan9303_virt_phy_reg_write(chip, regnum, val);\n\tif (phy > phy_base + 2)\n\t\treturn -ENODEV;\n\n\treturn chip->ops->phy_write(chip, phy, regnum, val);\n}\n\nstatic int lan9303_port_enable(struct dsa_switch *ds, int port,\n\t\t\t       struct phy_device *phy)\n{\n\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\tstruct lan9303 *chip = ds->priv;\n\n\tif (!dsa_port_is_user(dp))\n\t\treturn 0;\n\n\tvlan_vid_add(dsa_port_to_master(dp), htons(ETH_P_8021Q), port);\n\n\treturn lan9303_enable_processing_port(chip, port);\n}\n\nstatic void lan9303_port_disable(struct dsa_switch *ds, int port)\n{\n\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\tstruct lan9303 *chip = ds->priv;\n\n\tif (!dsa_port_is_user(dp))\n\t\treturn;\n\n\tvlan_vid_del(dsa_port_to_master(dp), htons(ETH_P_8021Q), port);\n\n\tlan9303_disable_processing_port(chip, port);\n\tlan9303_phy_write(ds, chip->phy_addr_base + port, MII_BMCR, BMCR_PDOWN);\n}\n\nstatic int lan9303_port_bridge_join(struct dsa_switch *ds, int port,\n\t\t\t\t    struct dsa_bridge bridge,\n\t\t\t\t    bool *tx_fwd_offload,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct lan9303 *chip = ds->priv;\n\n\tdev_dbg(chip->dev, \"%s(port %d)\\n\", __func__, port);\n\tif (dsa_port_bridge_same(dsa_to_port(ds, 1), dsa_to_port(ds, 2))) {\n\t\tlan9303_bridge_ports(chip);\n\t\tchip->is_bridged = true;   \n\t}\n\n\treturn 0;\n}\n\nstatic void lan9303_port_bridge_leave(struct dsa_switch *ds, int port,\n\t\t\t\t      struct dsa_bridge bridge)\n{\n\tstruct lan9303 *chip = ds->priv;\n\n\tdev_dbg(chip->dev, \"%s(port %d)\\n\", __func__, port);\n\tif (chip->is_bridged) {\n\t\tlan9303_separate_ports(chip);\n\t\tchip->is_bridged = false;\n\t}\n}\n\nstatic void lan9303_port_stp_state_set(struct dsa_switch *ds, int port,\n\t\t\t\t       u8 state)\n{\n\tint portmask, portstate;\n\tstruct lan9303 *chip = ds->priv;\n\n\tdev_dbg(chip->dev, \"%s(port %d, state %d)\\n\",\n\t\t__func__, port, state);\n\n\tswitch (state) {\n\tcase BR_STATE_DISABLED:\n\t\tportstate = LAN9303_SWE_PORT_STATE_DISABLED_PORT0;\n\t\tbreak;\n\tcase BR_STATE_BLOCKING:\n\tcase BR_STATE_LISTENING:\n\t\tportstate = LAN9303_SWE_PORT_STATE_BLOCKING_PORT0;\n\t\tbreak;\n\tcase BR_STATE_LEARNING:\n\t\tportstate = LAN9303_SWE_PORT_STATE_LEARNING_PORT0;\n\t\tbreak;\n\tcase BR_STATE_FORWARDING:\n\t\tportstate = LAN9303_SWE_PORT_STATE_FORWARDING_PORT0;\n\t\tbreak;\n\tdefault:\n\t\tportstate = LAN9303_SWE_PORT_STATE_DISABLED_PORT0;\n\t\tdev_err(chip->dev, \"unknown stp state: port %d, state %d\\n\",\n\t\t\tport, state);\n\t}\n\n\tportmask = 0x3 << (port * 2);\n\tportstate <<= (port * 2);\n\n\tchip->swe_port_state = (chip->swe_port_state & ~portmask) | portstate;\n\n\tif (chip->is_bridged)\n\t\tlan9303_write_switch_reg(chip, LAN9303_SWE_PORT_STATE,\n\t\t\t\t\t chip->swe_port_state);\n\t \n}\n\nstatic void lan9303_port_fast_age(struct dsa_switch *ds, int port)\n{\n\tstruct lan9303 *chip = ds->priv;\n\tstruct del_port_learned_ctx del_ctx = {\n\t\t.port = port,\n\t};\n\n\tdev_dbg(chip->dev, \"%s(%d)\\n\", __func__, port);\n\tlan9303_alr_loop(chip, alr_loop_cb_del_port_learned, &del_ctx);\n}\n\nstatic int lan9303_port_fdb_add(struct dsa_switch *ds, int port,\n\t\t\t\tconst unsigned char *addr, u16 vid,\n\t\t\t\tstruct dsa_db db)\n{\n\tstruct lan9303 *chip = ds->priv;\n\n\tdev_dbg(chip->dev, \"%s(%d, %pM, %d)\\n\", __func__, port, addr, vid);\n\n\treturn lan9303_alr_add_port(chip, addr, port, false);\n}\n\nstatic int lan9303_port_fdb_del(struct dsa_switch *ds, int port,\n\t\t\t\tconst unsigned char *addr, u16 vid,\n\t\t\t\tstruct dsa_db db)\n{\n\tstruct lan9303 *chip = ds->priv;\n\n\tdev_dbg(chip->dev, \"%s(%d, %pM, %d)\\n\", __func__, port, addr, vid);\n\tlan9303_alr_del_port(chip, addr, port);\n\n\treturn 0;\n}\n\nstatic int lan9303_port_fdb_dump(struct dsa_switch *ds, int port,\n\t\t\t\t dsa_fdb_dump_cb_t *cb, void *data)\n{\n\tstruct lan9303 *chip = ds->priv;\n\tstruct port_fdb_dump_ctx dump_ctx = {\n\t\t.port = port,\n\t\t.data = data,\n\t\t.cb   = cb,\n\t};\n\n\tdev_dbg(chip->dev, \"%s(%d)\\n\", __func__, port);\n\treturn lan9303_alr_loop(chip, alr_loop_cb_fdb_port_dump, &dump_ctx);\n}\n\nstatic int lan9303_port_mdb_prepare(struct dsa_switch *ds, int port,\n\t\t\t\t    const struct switchdev_obj_port_mdb *mdb)\n{\n\tstruct lan9303 *chip = ds->priv;\n\n\tdev_dbg(chip->dev, \"%s(%d, %pM, %d)\\n\", __func__, port, mdb->addr,\n\t\tmdb->vid);\n\tif (mdb->vid)\n\t\treturn -EOPNOTSUPP;\n\tif (lan9303_alr_cache_find_mac(chip, mdb->addr))\n\t\treturn 0;\n\tif (!lan9303_alr_cache_find_free(chip))\n\t\treturn -ENOSPC;\n\n\treturn 0;\n}\n\nstatic int lan9303_port_mdb_add(struct dsa_switch *ds, int port,\n\t\t\t\tconst struct switchdev_obj_port_mdb *mdb,\n\t\t\t\tstruct dsa_db db)\n{\n\tstruct lan9303 *chip = ds->priv;\n\tint err;\n\n\terr = lan9303_port_mdb_prepare(ds, port, mdb);\n\tif (err)\n\t\treturn err;\n\n\tdev_dbg(chip->dev, \"%s(%d, %pM, %d)\\n\", __func__, port, mdb->addr,\n\t\tmdb->vid);\n\treturn lan9303_alr_add_port(chip, mdb->addr, port, false);\n}\n\nstatic int lan9303_port_mdb_del(struct dsa_switch *ds, int port,\n\t\t\t\tconst struct switchdev_obj_port_mdb *mdb,\n\t\t\t\tstruct dsa_db db)\n{\n\tstruct lan9303 *chip = ds->priv;\n\n\tdev_dbg(chip->dev, \"%s(%d, %pM, %d)\\n\", __func__, port, mdb->addr,\n\t\tmdb->vid);\n\tif (mdb->vid)\n\t\treturn -EOPNOTSUPP;\n\tlan9303_alr_del_port(chip, mdb->addr, port);\n\n\treturn 0;\n}\n\nstatic void lan9303_phylink_get_caps(struct dsa_switch *ds, int port,\n\t\t\t\t     struct phylink_config *config)\n{\n\tstruct lan9303 *chip = ds->priv;\n\n\tdev_dbg(chip->dev, \"%s(%d) entered.\", __func__, port);\n\n\tconfig->mac_capabilities = MAC_10 | MAC_100 | MAC_ASYM_PAUSE |\n\t\t\t\t   MAC_SYM_PAUSE;\n\n\tif (port == 0) {\n\t\t__set_bit(PHY_INTERFACE_MODE_RMII,\n\t\t\t  config->supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_MII,\n\t\t\t  config->supported_interfaces);\n\t} else {\n\t\t__set_bit(PHY_INTERFACE_MODE_INTERNAL,\n\t\t\t  config->supported_interfaces);\n\t\t \n\t\t__set_bit(PHY_INTERFACE_MODE_GMII,\n\t\t\t  config->supported_interfaces);\n\t}\n}\n\nstatic void lan9303_phylink_mac_link_up(struct dsa_switch *ds, int port,\n\t\t\t\t\tunsigned int mode,\n\t\t\t\t\tphy_interface_t interface,\n\t\t\t\t\tstruct phy_device *phydev, int speed,\n\t\t\t\t\tint duplex, bool tx_pause,\n\t\t\t\t\tbool rx_pause)\n{\n\tstruct lan9303 *chip = ds->priv;\n\tu32 ctl;\n\tu32 reg;\n\n\t \n\tif (!IS_PORT_XMII(port))\n\t\treturn;\n\n\t \n\tctl = lan9303_phy_read(ds, port, MII_BMCR);\n\tctl &= ~(BMCR_ANENABLE | BMCR_SPEED100 | BMCR_FULLDPLX);\n\tif (speed == SPEED_100)\n\t\tctl |= BMCR_SPEED100;\n\tif (duplex == DUPLEX_FULL)\n\t\tctl |= BMCR_FULLDPLX;\n\tlan9303_phy_write(ds, port, MII_BMCR, ctl);\n\n\t \n\tlan9303_read(chip->regmap, flow_ctl_reg[port], &reg);\n\treg &= ~(LAN9303_BP_EN | LAN9303_RX_FC_EN | LAN9303_TX_FC_EN);\n\tif (rx_pause)\n\t\treg |= (LAN9303_RX_FC_EN | LAN9303_BP_EN);\n\tif (tx_pause)\n\t\treg |= LAN9303_TX_FC_EN;\n\tregmap_write(chip->regmap, flow_ctl_reg[port], reg);\n}\n\nstatic const struct dsa_switch_ops lan9303_switch_ops = {\n\t.get_tag_protocol\t= lan9303_get_tag_protocol,\n\t.setup\t\t\t= lan9303_setup,\n\t.get_strings\t\t= lan9303_get_strings,\n\t.phy_read\t\t= lan9303_phy_read,\n\t.phy_write\t\t= lan9303_phy_write,\n\t.phylink_get_caps\t= lan9303_phylink_get_caps,\n\t.phylink_mac_link_up\t= lan9303_phylink_mac_link_up,\n\t.get_ethtool_stats\t= lan9303_get_ethtool_stats,\n\t.get_sset_count\t\t= lan9303_get_sset_count,\n\t.port_enable\t\t= lan9303_port_enable,\n\t.port_disable\t\t= lan9303_port_disable,\n\t.port_bridge_join\t= lan9303_port_bridge_join,\n\t.port_bridge_leave\t= lan9303_port_bridge_leave,\n\t.port_stp_state_set\t= lan9303_port_stp_state_set,\n\t.port_fast_age\t\t= lan9303_port_fast_age,\n\t.port_fdb_add\t\t= lan9303_port_fdb_add,\n\t.port_fdb_del\t\t= lan9303_port_fdb_del,\n\t.port_fdb_dump\t\t= lan9303_port_fdb_dump,\n\t.port_mdb_add\t\t= lan9303_port_mdb_add,\n\t.port_mdb_del\t\t= lan9303_port_mdb_del,\n};\n\nstatic int lan9303_register_switch(struct lan9303 *chip)\n{\n\tint base;\n\n\tchip->ds = devm_kzalloc(chip->dev, sizeof(*chip->ds), GFP_KERNEL);\n\tif (!chip->ds)\n\t\treturn -ENOMEM;\n\n\tchip->ds->dev = chip->dev;\n\tchip->ds->num_ports = LAN9303_NUM_PORTS;\n\tchip->ds->priv = chip;\n\tchip->ds->ops = &lan9303_switch_ops;\n\tbase = chip->phy_addr_base;\n\tchip->ds->phys_mii_mask = GENMASK(LAN9303_NUM_PORTS - 1 + base, base);\n\n\treturn dsa_register_switch(chip->ds);\n}\n\nstatic int lan9303_probe_reset_gpio(struct lan9303 *chip,\n\t\t\t\t     struct device_node *np)\n{\n\tchip->reset_gpio = devm_gpiod_get_optional(chip->dev, \"reset\",\n\t\t\t\t\t\t   GPIOD_OUT_HIGH);\n\tif (IS_ERR(chip->reset_gpio))\n\t\treturn PTR_ERR(chip->reset_gpio);\n\n\tif (!chip->reset_gpio) {\n\t\tdev_dbg(chip->dev, \"No reset GPIO defined\\n\");\n\t\treturn 0;\n\t}\n\n\tchip->reset_duration = 200;\n\n\tif (np) {\n\t\tof_property_read_u32(np, \"reset-duration\",\n\t\t\t\t     &chip->reset_duration);\n\t} else {\n\t\tdev_dbg(chip->dev, \"reset duration defaults to 200 ms\\n\");\n\t}\n\n\t \n\tif (chip->reset_duration > 1000)\n\t\tchip->reset_duration = 1000;\n\n\treturn 0;\n}\n\nint lan9303_probe(struct lan9303 *chip, struct device_node *np)\n{\n\tint ret;\n\tu32 reg;\n\n\tmutex_init(&chip->indirect_mutex);\n\tmutex_init(&chip->alr_mutex);\n\n\tret = lan9303_probe_reset_gpio(chip, np);\n\tif (ret)\n\t\treturn ret;\n\n\tlan9303_handle_reset(chip);\n\n\t \n\t \n\tret = lan9303_read(chip->regmap, LAN9303_BYTE_ORDER, &reg);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"failed to access the device: %d\\n\",\n\t\t\tret);\n\t\tif (!chip->reset_gpio) {\n\t\t\tdev_dbg(chip->dev,\n\t\t\t\t\"hint: maybe failed due to missing reset GPIO\\n\");\n\t\t}\n\t\treturn ret;\n\t}\n\n\tret = lan9303_check_device(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tret = lan9303_register_switch(chip);\n\tif (ret) {\n\t\tdev_dbg(chip->dev, \"Failed to register switch: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(lan9303_probe);\n\nint lan9303_remove(struct lan9303 *chip)\n{\n\tint rc;\n\n\trc = lan9303_disable_processing(chip);\n\tif (rc != 0)\n\t\tdev_warn(chip->dev, \"shutting down failed\\n\");\n\n\tdsa_unregister_switch(chip->ds);\n\n\t \n\tgpiod_set_value_cansleep(chip->reset_gpio, 1);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(lan9303_remove);\n\nvoid lan9303_shutdown(struct lan9303 *chip)\n{\n\tdsa_switch_shutdown(chip->ds);\n}\nEXPORT_SYMBOL(lan9303_shutdown);\n\nMODULE_AUTHOR(\"Juergen Borleis <kernel@pengutronix.de>\");\nMODULE_DESCRIPTION(\"Core driver for SMSC/Microchip LAN9303 three port ethernet switch\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}