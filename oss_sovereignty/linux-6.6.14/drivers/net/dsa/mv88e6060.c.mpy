{
  "module_name": "mv88e6060.c",
  "hash_id": "d9548d4e908ca4e711c219e30c1fff95c5e6bc980eed9d1329a7106656f43860",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/mv88e6060.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/etherdevice.h>\n#include <linux/jiffies.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/phy.h>\n#include <net/dsa.h>\n#include \"mv88e6060.h\"\n\nstatic int reg_read(struct mv88e6060_priv *priv, int addr, int reg)\n{\n\treturn mdiobus_read_nested(priv->bus, priv->sw_addr + addr, reg);\n}\n\nstatic int reg_write(struct mv88e6060_priv *priv, int addr, int reg, u16 val)\n{\n\treturn mdiobus_write_nested(priv->bus, priv->sw_addr + addr, reg, val);\n}\n\nstatic const char *mv88e6060_get_name(struct mii_bus *bus, int sw_addr)\n{\n\tint ret;\n\n\tret = mdiobus_read(bus, sw_addr + REG_PORT(0), PORT_SWITCH_ID);\n\tif (ret >= 0) {\n\t\tif (ret == PORT_SWITCH_ID_6060)\n\t\t\treturn \"Marvell 88E6060 (A0)\";\n\t\tif (ret == PORT_SWITCH_ID_6060_R1 ||\n\t\t    ret == PORT_SWITCH_ID_6060_R2)\n\t\t\treturn \"Marvell 88E6060 (B0)\";\n\t\tif ((ret & PORT_SWITCH_ID_6060_MASK) == PORT_SWITCH_ID_6060)\n\t\t\treturn \"Marvell 88E6060\";\n\t}\n\n\treturn NULL;\n}\n\nstatic enum dsa_tag_protocol mv88e6060_get_tag_protocol(struct dsa_switch *ds,\n\t\t\t\t\t\t\tint port,\n\t\t\t\t\t\t\tenum dsa_tag_protocol m)\n{\n\treturn DSA_TAG_PROTO_TRAILER;\n}\n\nstatic int mv88e6060_switch_reset(struct mv88e6060_priv *priv)\n{\n\tint i;\n\tint ret;\n\tunsigned long timeout;\n\n\t \n\tfor (i = 0; i < MV88E6060_PORTS; i++) {\n\t\tret = reg_read(priv, REG_PORT(i), PORT_CONTROL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = reg_write(priv, REG_PORT(i), PORT_CONTROL,\n\t\t\t\tret & ~PORT_CONTROL_STATE_MASK);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tusleep_range(2000, 4000);\n\n\t \n\tret = reg_write(priv, REG_GLOBAL, GLOBAL_ATU_CONTROL,\n\t\t\tGLOBAL_ATU_CONTROL_SWRESET |\n\t\t\tGLOBAL_ATU_CONTROL_LEARNDIS);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttimeout = jiffies + 1 * HZ;\n\twhile (time_before(jiffies, timeout)) {\n\t\tret = reg_read(priv, REG_GLOBAL, GLOBAL_STATUS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (ret & GLOBAL_STATUS_INIT_READY)\n\t\t\tbreak;\n\n\t\tusleep_range(1000, 2000);\n\t}\n\tif (time_after(jiffies, timeout))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int mv88e6060_setup_global(struct mv88e6060_priv *priv)\n{\n\tint ret;\n\n\t \n\tret = reg_write(priv, REG_GLOBAL, GLOBAL_CONTROL,\n\t\t\tGLOBAL_CONTROL_MAX_FRAME_1536);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn reg_write(priv, REG_GLOBAL, GLOBAL_ATU_CONTROL,\n\t\t\t GLOBAL_ATU_CONTROL_LEARNDIS);\n}\n\nstatic int mv88e6060_setup_port(struct mv88e6060_priv *priv, int p)\n{\n\tint addr = REG_PORT(p);\n\tint ret;\n\n\tif (dsa_is_unused_port(priv->ds, p))\n\t\treturn 0;\n\n\t \n\tret = reg_write(priv, addr, PORT_CONTROL,\n\t\t\tdsa_is_cpu_port(priv->ds, p) ?\n\t\t\tPORT_CONTROL_TRAILER |\n\t\t\tPORT_CONTROL_INGRESS_MODE |\n\t\t\tPORT_CONTROL_STATE_FORWARDING :\n\t\t\tPORT_CONTROL_STATE_FORWARDING);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = reg_write(priv, addr, PORT_VLAN_MAP,\n\t\t\t((p & 0xf) << PORT_VLAN_MAP_DBNUM_SHIFT) |\n\t\t\t(dsa_is_cpu_port(priv->ds, p) ?\n\t\t\t dsa_user_ports(priv->ds) :\n\t\t\t BIT(dsa_to_port(priv->ds, p)->cpu_dp->index)));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn reg_write(priv, addr, PORT_ASSOC_VECTOR, BIT(p));\n}\n\nstatic int mv88e6060_setup_addr(struct mv88e6060_priv *priv)\n{\n\tu8 addr[ETH_ALEN];\n\tint ret;\n\tu16 val;\n\n\teth_random_addr(addr);\n\n\tval = addr[0] << 8 | addr[1];\n\n\t \n\tval &= 0xfeff;\n\n\tret = reg_write(priv, REG_GLOBAL, GLOBAL_MAC_01, val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = reg_write(priv, REG_GLOBAL, GLOBAL_MAC_23,\n\t\t\t(addr[2] << 8) | addr[3]);\n\tif (ret)\n\t\treturn ret;\n\n\treturn reg_write(priv, REG_GLOBAL, GLOBAL_MAC_45,\n\t\t\t (addr[4] << 8) | addr[5]);\n}\n\nstatic int mv88e6060_setup(struct dsa_switch *ds)\n{\n\tstruct mv88e6060_priv *priv = ds->priv;\n\tint ret;\n\tint i;\n\n\tpriv->ds = ds;\n\n\tret = mv88e6060_switch_reset(priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\n\tret = mv88e6060_setup_global(priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mv88e6060_setup_addr(priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < MV88E6060_PORTS; i++) {\n\t\tret = mv88e6060_setup_port(priv, i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mv88e6060_port_to_phy_addr(int port)\n{\n\tif (port >= 0 && port < MV88E6060_PORTS)\n\t\treturn port;\n\treturn -1;\n}\n\nstatic int mv88e6060_phy_read(struct dsa_switch *ds, int port, int regnum)\n{\n\tstruct mv88e6060_priv *priv = ds->priv;\n\tint addr;\n\n\taddr = mv88e6060_port_to_phy_addr(port);\n\tif (addr == -1)\n\t\treturn 0xffff;\n\n\treturn reg_read(priv, addr, regnum);\n}\n\nstatic int\nmv88e6060_phy_write(struct dsa_switch *ds, int port, int regnum, u16 val)\n{\n\tstruct mv88e6060_priv *priv = ds->priv;\n\tint addr;\n\n\taddr = mv88e6060_port_to_phy_addr(port);\n\tif (addr == -1)\n\t\treturn 0xffff;\n\n\treturn reg_write(priv, addr, regnum, val);\n}\n\nstatic void mv88e6060_phylink_get_caps(struct dsa_switch *ds, int port,\n\t\t\t\t       struct phylink_config *config)\n{\n\tunsigned long *interfaces = config->supported_interfaces;\n\tstruct mv88e6060_priv *priv = ds->priv;\n\tint addr = REG_PORT(port);\n\tint ret;\n\n\tret = reg_read(priv, addr, PORT_STATUS);\n\tif (ret < 0) {\n\t\tdev_err(ds->dev,\n\t\t\t\"port %d: unable to read status register: %pe\\n\",\n\t\t\tport, ERR_PTR(ret));\n\t\treturn;\n\t}\n\n\t \n\tif (!(ret & PORT_STATUS_PORTMODE)) {\n\t\tdev_warn(ds->dev, \"port %d: SNI mode not supported\\n\", port);\n\t\treturn;\n\t}\n\n\tconfig->mac_capabilities = MAC_100 | MAC_10 | MAC_SYM_PAUSE;\n\n\tif (port >= 4) {\n\t\t \n\t\t__set_bit(PHY_INTERFACE_MODE_MII, interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_REVMII, interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_REVRMII, interfaces);\n\t}\n\tif (port <= 4) {\n\t\t \n\t\t \n\t\t__set_bit(PHY_INTERFACE_MODE_INTERNAL, interfaces);\n\t\t \n\t\t__set_bit(PHY_INTERFACE_MODE_GMII, interfaces);\n\t}\n}\n\nstatic const struct dsa_switch_ops mv88e6060_switch_ops = {\n\t.get_tag_protocol = mv88e6060_get_tag_protocol,\n\t.setup\t\t= mv88e6060_setup,\n\t.phy_read\t= mv88e6060_phy_read,\n\t.phy_write\t= mv88e6060_phy_write,\n\t.phylink_get_caps = mv88e6060_phylink_get_caps,\n};\n\nstatic int mv88e6060_probe(struct mdio_device *mdiodev)\n{\n\tstruct device *dev = &mdiodev->dev;\n\tstruct mv88e6060_priv *priv;\n\tstruct dsa_switch *ds;\n\tconst char *name;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->bus = mdiodev->bus;\n\tpriv->sw_addr = mdiodev->addr;\n\n\tname = mv88e6060_get_name(priv->bus, priv->sw_addr);\n\tif (!name)\n\t\treturn -ENODEV;\n\n\tdev_info(dev, \"switch %s detected\\n\", name);\n\n\tds = devm_kzalloc(dev, sizeof(*ds), GFP_KERNEL);\n\tif (!ds)\n\t\treturn -ENOMEM;\n\n\tds->dev = dev;\n\tds->num_ports = MV88E6060_PORTS;\n\tds->priv = priv;\n\tds->dev = dev;\n\tds->ops = &mv88e6060_switch_ops;\n\n\tdev_set_drvdata(dev, ds);\n\n\treturn dsa_register_switch(ds);\n}\n\nstatic void mv88e6060_remove(struct mdio_device *mdiodev)\n{\n\tstruct dsa_switch *ds = dev_get_drvdata(&mdiodev->dev);\n\n\tif (!ds)\n\t\treturn;\n\n\tdsa_unregister_switch(ds);\n}\n\nstatic void mv88e6060_shutdown(struct mdio_device *mdiodev)\n{\n\tstruct dsa_switch *ds = dev_get_drvdata(&mdiodev->dev);\n\n\tif (!ds)\n\t\treturn;\n\n\tdsa_switch_shutdown(ds);\n\n\tdev_set_drvdata(&mdiodev->dev, NULL);\n}\n\nstatic const struct of_device_id mv88e6060_of_match[] = {\n\t{\n\t\t.compatible = \"marvell,mv88e6060\",\n\t},\n\t{   },\n};\n\nstatic struct mdio_driver mv88e6060_driver = {\n\t.probe\t= mv88e6060_probe,\n\t.remove = mv88e6060_remove,\n\t.shutdown = mv88e6060_shutdown,\n\t.mdiodrv.driver = {\n\t\t.name = \"mv88e6060\",\n\t\t.of_match_table = mv88e6060_of_match,\n\t},\n};\n\nmdio_module_driver(mv88e6060_driver);\n\nMODULE_AUTHOR(\"Lennert Buytenhek <buytenh@wantstofly.org>\");\nMODULE_DESCRIPTION(\"Driver for Marvell 88E6060 ethernet switch chip\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:mv88e6060\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}