{
  "module_name": "rzn1_a5psw.c",
  "hash_id": "fbaf099a19b79a69a5981b0dee63e178f458527932b62ab63844e686cf7429a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/rzn1_a5psw.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/etherdevice.h>\n#include <linux/if_bridge.h>\n#include <linux/if_ether.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_mdio.h>\n#include <net/dsa.h>\n\n#include \"rzn1_a5psw.h\"\n\nstruct a5psw_stats {\n\tu16 offset;\n\tconst char name[ETH_GSTRING_LEN];\n};\n\n#define STAT_DESC(_offset) {\t\\\n\t.offset = A5PSW_##_offset,\t\\\n\t.name = __stringify(_offset),\t\\\n}\n\nstatic const struct a5psw_stats a5psw_stats[] = {\n\tSTAT_DESC(aFramesTransmittedOK),\n\tSTAT_DESC(aFramesReceivedOK),\n\tSTAT_DESC(aFrameCheckSequenceErrors),\n\tSTAT_DESC(aAlignmentErrors),\n\tSTAT_DESC(aOctetsTransmittedOK),\n\tSTAT_DESC(aOctetsReceivedOK),\n\tSTAT_DESC(aTxPAUSEMACCtrlFrames),\n\tSTAT_DESC(aRxPAUSEMACCtrlFrames),\n\tSTAT_DESC(ifInErrors),\n\tSTAT_DESC(ifOutErrors),\n\tSTAT_DESC(ifInUcastPkts),\n\tSTAT_DESC(ifInMulticastPkts),\n\tSTAT_DESC(ifInBroadcastPkts),\n\tSTAT_DESC(ifOutDiscards),\n\tSTAT_DESC(ifOutUcastPkts),\n\tSTAT_DESC(ifOutMulticastPkts),\n\tSTAT_DESC(ifOutBroadcastPkts),\n\tSTAT_DESC(etherStatsDropEvents),\n\tSTAT_DESC(etherStatsOctets),\n\tSTAT_DESC(etherStatsPkts),\n\tSTAT_DESC(etherStatsUndersizePkts),\n\tSTAT_DESC(etherStatsOversizePkts),\n\tSTAT_DESC(etherStatsPkts64Octets),\n\tSTAT_DESC(etherStatsPkts65to127Octets),\n\tSTAT_DESC(etherStatsPkts128to255Octets),\n\tSTAT_DESC(etherStatsPkts256to511Octets),\n\tSTAT_DESC(etherStatsPkts1024to1518Octets),\n\tSTAT_DESC(etherStatsPkts1519toXOctets),\n\tSTAT_DESC(etherStatsJabbers),\n\tSTAT_DESC(etherStatsFragments),\n\tSTAT_DESC(VLANReceived),\n\tSTAT_DESC(VLANTransmitted),\n\tSTAT_DESC(aDeferred),\n\tSTAT_DESC(aMultipleCollisions),\n\tSTAT_DESC(aSingleCollisions),\n\tSTAT_DESC(aLateCollisions),\n\tSTAT_DESC(aExcessiveCollisions),\n\tSTAT_DESC(aCarrierSenseErrors),\n};\n\nstatic void a5psw_reg_writel(struct a5psw *a5psw, int offset, u32 value)\n{\n\twritel(value, a5psw->base + offset);\n}\n\nstatic u32 a5psw_reg_readl(struct a5psw *a5psw, int offset)\n{\n\treturn readl(a5psw->base + offset);\n}\n\nstatic void a5psw_reg_rmw(struct a5psw *a5psw, int offset, u32 mask, u32 val)\n{\n\tu32 reg;\n\n\tspin_lock(&a5psw->reg_lock);\n\n\treg = a5psw_reg_readl(a5psw, offset);\n\treg &= ~mask;\n\treg |= val;\n\ta5psw_reg_writel(a5psw, offset, reg);\n\n\tspin_unlock(&a5psw->reg_lock);\n}\n\nstatic enum dsa_tag_protocol a5psw_get_tag_protocol(struct dsa_switch *ds,\n\t\t\t\t\t\t    int port,\n\t\t\t\t\t\t    enum dsa_tag_protocol mp)\n{\n\treturn DSA_TAG_PROTO_RZN1_A5PSW;\n}\n\nstatic void a5psw_port_pattern_set(struct a5psw *a5psw, int port, int pattern,\n\t\t\t\t   bool enable)\n{\n\tu32 rx_match = 0;\n\n\tif (enable)\n\t\trx_match |= A5PSW_RXMATCH_CONFIG_PATTERN(pattern);\n\n\ta5psw_reg_rmw(a5psw, A5PSW_RXMATCH_CONFIG(port),\n\t\t      A5PSW_RXMATCH_CONFIG_PATTERN(pattern), rx_match);\n}\n\nstatic void a5psw_port_mgmtfwd_set(struct a5psw *a5psw, int port, bool enable)\n{\n\t \n\ta5psw_port_pattern_set(a5psw, port, A5PSW_PATTERN_MGMTFWD, enable);\n}\n\nstatic void a5psw_port_tx_enable(struct a5psw *a5psw, int port, bool enable)\n{\n\tu32 mask = A5PSW_PORT_ENA_TX(port);\n\tu32 reg = enable ? mask : 0;\n\n\t \n\ta5psw_reg_rmw(a5psw, A5PSW_PORT_ENA, mask, reg);\n}\n\nstatic void a5psw_port_enable_set(struct a5psw *a5psw, int port, bool enable)\n{\n\tu32 port_ena = 0;\n\n\tif (enable)\n\t\tport_ena |= A5PSW_PORT_ENA_TX_RX(port);\n\n\ta5psw_reg_rmw(a5psw, A5PSW_PORT_ENA, A5PSW_PORT_ENA_TX_RX(port),\n\t\t      port_ena);\n}\n\nstatic int a5psw_lk_execute_ctrl(struct a5psw *a5psw, u32 *ctrl)\n{\n\tint ret;\n\n\ta5psw_reg_writel(a5psw, A5PSW_LK_ADDR_CTRL, *ctrl);\n\n\tret = readl_poll_timeout(a5psw->base + A5PSW_LK_ADDR_CTRL, *ctrl,\n\t\t\t\t !(*ctrl & A5PSW_LK_ADDR_CTRL_BUSY),\n\t\t\t\t A5PSW_LK_BUSY_USEC_POLL, A5PSW_CTRL_TIMEOUT);\n\tif (ret)\n\t\tdev_err(a5psw->dev, \"LK_CTRL timeout waiting for BUSY bit\\n\");\n\n\treturn ret;\n}\n\nstatic void a5psw_port_fdb_flush(struct a5psw *a5psw, int port)\n{\n\tu32 ctrl = A5PSW_LK_ADDR_CTRL_DELETE_PORT | BIT(port);\n\n\tmutex_lock(&a5psw->lk_lock);\n\ta5psw_lk_execute_ctrl(a5psw, &ctrl);\n\tmutex_unlock(&a5psw->lk_lock);\n}\n\nstatic void a5psw_port_authorize_set(struct a5psw *a5psw, int port,\n\t\t\t\t     bool authorize)\n{\n\tu32 reg = a5psw_reg_readl(a5psw, A5PSW_AUTH_PORT(port));\n\n\tif (authorize)\n\t\treg |= A5PSW_AUTH_PORT_AUTHORIZED;\n\telse\n\t\treg &= ~A5PSW_AUTH_PORT_AUTHORIZED;\n\n\ta5psw_reg_writel(a5psw, A5PSW_AUTH_PORT(port), reg);\n}\n\nstatic void a5psw_port_disable(struct dsa_switch *ds, int port)\n{\n\tstruct a5psw *a5psw = ds->priv;\n\n\ta5psw_port_authorize_set(a5psw, port, false);\n\ta5psw_port_enable_set(a5psw, port, false);\n}\n\nstatic int a5psw_port_enable(struct dsa_switch *ds, int port,\n\t\t\t     struct phy_device *phy)\n{\n\tstruct a5psw *a5psw = ds->priv;\n\n\ta5psw_port_authorize_set(a5psw, port, true);\n\ta5psw_port_enable_set(a5psw, port, true);\n\n\treturn 0;\n}\n\nstatic int a5psw_port_change_mtu(struct dsa_switch *ds, int port, int new_mtu)\n{\n\tstruct a5psw *a5psw = ds->priv;\n\n\tnew_mtu += ETH_HLEN + A5PSW_EXTRA_MTU_LEN + ETH_FCS_LEN;\n\ta5psw_reg_writel(a5psw, A5PSW_FRM_LENGTH(port), new_mtu);\n\n\treturn 0;\n}\n\nstatic int a5psw_port_max_mtu(struct dsa_switch *ds, int port)\n{\n\treturn A5PSW_MAX_MTU;\n}\n\nstatic void a5psw_phylink_get_caps(struct dsa_switch *ds, int port,\n\t\t\t\t   struct phylink_config *config)\n{\n\tunsigned long *intf = config->supported_interfaces;\n\n\tconfig->mac_capabilities = MAC_1000FD;\n\n\tif (dsa_is_cpu_port(ds, port)) {\n\t\t \n\t\t__set_bit(PHY_INTERFACE_MODE_GMII, intf);\n\t} else {\n\t\tconfig->mac_capabilities |= MAC_100 | MAC_10;\n\t\tphy_interface_set_rgmii(intf);\n\t\t__set_bit(PHY_INTERFACE_MODE_RMII, intf);\n\t\t__set_bit(PHY_INTERFACE_MODE_MII, intf);\n\t}\n}\n\nstatic struct phylink_pcs *\na5psw_phylink_mac_select_pcs(struct dsa_switch *ds, int port,\n\t\t\t     phy_interface_t interface)\n{\n\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\tstruct a5psw *a5psw = ds->priv;\n\n\tif (!dsa_port_is_cpu(dp) && a5psw->pcs[port])\n\t\treturn a5psw->pcs[port];\n\n\treturn NULL;\n}\n\nstatic void a5psw_phylink_mac_link_down(struct dsa_switch *ds, int port,\n\t\t\t\t\tunsigned int mode,\n\t\t\t\t\tphy_interface_t interface)\n{\n\tstruct a5psw *a5psw = ds->priv;\n\tu32 cmd_cfg;\n\n\tcmd_cfg = a5psw_reg_readl(a5psw, A5PSW_CMD_CFG(port));\n\tcmd_cfg &= ~(A5PSW_CMD_CFG_RX_ENA | A5PSW_CMD_CFG_TX_ENA);\n\ta5psw_reg_writel(a5psw, A5PSW_CMD_CFG(port), cmd_cfg);\n}\n\nstatic void a5psw_phylink_mac_link_up(struct dsa_switch *ds, int port,\n\t\t\t\t      unsigned int mode,\n\t\t\t\t      phy_interface_t interface,\n\t\t\t\t      struct phy_device *phydev, int speed,\n\t\t\t\t      int duplex, bool tx_pause, bool rx_pause)\n{\n\tu32 cmd_cfg = A5PSW_CMD_CFG_RX_ENA | A5PSW_CMD_CFG_TX_ENA |\n\t\t      A5PSW_CMD_CFG_TX_CRC_APPEND;\n\tstruct a5psw *a5psw = ds->priv;\n\n\tif (speed == SPEED_1000)\n\t\tcmd_cfg |= A5PSW_CMD_CFG_ETH_SPEED;\n\n\tif (duplex == DUPLEX_HALF)\n\t\tcmd_cfg |= A5PSW_CMD_CFG_HD_ENA;\n\n\tcmd_cfg |= A5PSW_CMD_CFG_CNTL_FRM_ENA;\n\n\tif (!rx_pause)\n\t\tcmd_cfg &= ~A5PSW_CMD_CFG_PAUSE_IGNORE;\n\n\ta5psw_reg_writel(a5psw, A5PSW_CMD_CFG(port), cmd_cfg);\n}\n\nstatic int a5psw_set_ageing_time(struct dsa_switch *ds, unsigned int msecs)\n{\n\tstruct a5psw *a5psw = ds->priv;\n\tunsigned long rate;\n\tu64 max, tmp;\n\tu32 agetime;\n\n\trate = clk_get_rate(a5psw->clk);\n\tmax = div64_ul(((u64)A5PSW_LK_AGETIME_MASK * A5PSW_TABLE_ENTRIES * 1024),\n\t\t       rate) * 1000;\n\tif (msecs > max)\n\t\treturn -EINVAL;\n\n\ttmp = div_u64(rate, MSEC_PER_SEC);\n\tagetime = div_u64(msecs * tmp, 1024 * A5PSW_TABLE_ENTRIES);\n\n\ta5psw_reg_writel(a5psw, A5PSW_LK_AGETIME, agetime);\n\n\treturn 0;\n}\n\nstatic void a5psw_port_learning_set(struct a5psw *a5psw, int port, bool learn)\n{\n\tu32 mask = A5PSW_INPUT_LEARN_DIS(port);\n\tu32 reg = !learn ? mask : 0;\n\n\ta5psw_reg_rmw(a5psw, A5PSW_INPUT_LEARN, mask, reg);\n}\n\nstatic void a5psw_port_rx_block_set(struct a5psw *a5psw, int port, bool block)\n{\n\tu32 mask = A5PSW_INPUT_LEARN_BLOCK(port);\n\tu32 reg = block ? mask : 0;\n\n\ta5psw_reg_rmw(a5psw, A5PSW_INPUT_LEARN, mask, reg);\n}\n\nstatic void a5psw_flooding_set_resolution(struct a5psw *a5psw, int port,\n\t\t\t\t\t  bool set)\n{\n\tu8 offsets[] = {A5PSW_UCAST_DEF_MASK, A5PSW_BCAST_DEF_MASK,\n\t\t\tA5PSW_MCAST_DEF_MASK};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(offsets); i++)\n\t\ta5psw_reg_rmw(a5psw, offsets[i], BIT(port),\n\t\t\t      set ? BIT(port) : 0);\n}\n\nstatic void a5psw_port_set_standalone(struct a5psw *a5psw, int port,\n\t\t\t\t      bool standalone)\n{\n\ta5psw_port_learning_set(a5psw, port, !standalone);\n\ta5psw_flooding_set_resolution(a5psw, port, !standalone);\n\ta5psw_port_mgmtfwd_set(a5psw, port, standalone);\n}\n\nstatic int a5psw_port_bridge_join(struct dsa_switch *ds, int port,\n\t\t\t\t  struct dsa_bridge bridge,\n\t\t\t\t  bool *tx_fwd_offload,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct a5psw *a5psw = ds->priv;\n\n\t \n\tif (a5psw->br_dev && bridge.dev != a5psw->br_dev) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Forwarding offload supported for a single bridge\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\ta5psw->br_dev = bridge.dev;\n\ta5psw_port_set_standalone(a5psw, port, false);\n\n\ta5psw->bridged_ports |= BIT(port);\n\n\treturn 0;\n}\n\nstatic void a5psw_port_bridge_leave(struct dsa_switch *ds, int port,\n\t\t\t\t    struct dsa_bridge bridge)\n{\n\tstruct a5psw *a5psw = ds->priv;\n\n\ta5psw->bridged_ports &= ~BIT(port);\n\n\ta5psw_port_set_standalone(a5psw, port, true);\n\n\t \n\tif (a5psw->bridged_ports == BIT(A5PSW_CPU_PORT))\n\t\ta5psw->br_dev = NULL;\n}\n\nstatic int a5psw_port_pre_bridge_flags(struct dsa_switch *ds, int port,\n\t\t\t\t       struct switchdev_brport_flags flags,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tif (flags.mask & ~(BR_LEARNING | BR_FLOOD | BR_MCAST_FLOOD |\n\t\t\t   BR_BCAST_FLOOD))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int\na5psw_port_bridge_flags(struct dsa_switch *ds, int port,\n\t\t\tstruct switchdev_brport_flags flags,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct a5psw *a5psw = ds->priv;\n\tu32 val;\n\n\t \n\tif (!(a5psw->bridged_ports & BIT(port)))\n\t\treturn 0;\n\n\tif (flags.mask & BR_LEARNING) {\n\t\tval = flags.val & BR_LEARNING ? 0 : A5PSW_INPUT_LEARN_DIS(port);\n\t\ta5psw_reg_rmw(a5psw, A5PSW_INPUT_LEARN,\n\t\t\t      A5PSW_INPUT_LEARN_DIS(port), val);\n\t}\n\n\tif (flags.mask & BR_FLOOD) {\n\t\tval = flags.val & BR_FLOOD ? BIT(port) : 0;\n\t\ta5psw_reg_rmw(a5psw, A5PSW_UCAST_DEF_MASK, BIT(port), val);\n\t}\n\n\tif (flags.mask & BR_MCAST_FLOOD) {\n\t\tval = flags.val & BR_MCAST_FLOOD ? BIT(port) : 0;\n\t\ta5psw_reg_rmw(a5psw, A5PSW_MCAST_DEF_MASK, BIT(port), val);\n\t}\n\n\tif (flags.mask & BR_BCAST_FLOOD) {\n\t\tval = flags.val & BR_BCAST_FLOOD ? BIT(port) : 0;\n\t\ta5psw_reg_rmw(a5psw, A5PSW_BCAST_DEF_MASK, BIT(port), val);\n\t}\n\n\treturn 0;\n}\n\nstatic void a5psw_port_stp_state_set(struct dsa_switch *ds, int port, u8 state)\n{\n\tbool learning_enabled, rx_enabled, tx_enabled;\n\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\tstruct a5psw *a5psw = ds->priv;\n\n\tswitch (state) {\n\tcase BR_STATE_DISABLED:\n\tcase BR_STATE_BLOCKING:\n\tcase BR_STATE_LISTENING:\n\t\trx_enabled = false;\n\t\ttx_enabled = false;\n\t\tlearning_enabled = false;\n\t\tbreak;\n\tcase BR_STATE_LEARNING:\n\t\trx_enabled = false;\n\t\ttx_enabled = false;\n\t\tlearning_enabled = dp->learning;\n\t\tbreak;\n\tcase BR_STATE_FORWARDING:\n\t\trx_enabled = true;\n\t\ttx_enabled = true;\n\t\tlearning_enabled = dp->learning;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(ds->dev, \"invalid STP state: %d\\n\", state);\n\t\treturn;\n\t}\n\n\ta5psw_port_learning_set(a5psw, port, learning_enabled);\n\ta5psw_port_rx_block_set(a5psw, port, !rx_enabled);\n\ta5psw_port_tx_enable(a5psw, port, tx_enabled);\n}\n\nstatic void a5psw_port_fast_age(struct dsa_switch *ds, int port)\n{\n\tstruct a5psw *a5psw = ds->priv;\n\n\ta5psw_port_fdb_flush(a5psw, port);\n}\n\nstatic int a5psw_lk_execute_lookup(struct a5psw *a5psw, union lk_data *lk_data,\n\t\t\t\t   u16 *entry)\n{\n\tu32 ctrl;\n\tint ret;\n\n\ta5psw_reg_writel(a5psw, A5PSW_LK_DATA_LO, lk_data->lo);\n\ta5psw_reg_writel(a5psw, A5PSW_LK_DATA_HI, lk_data->hi);\n\n\tctrl = A5PSW_LK_ADDR_CTRL_LOOKUP;\n\tret = a5psw_lk_execute_ctrl(a5psw, &ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\t*entry = ctrl & A5PSW_LK_ADDR_CTRL_ADDRESS;\n\n\treturn 0;\n}\n\nstatic int a5psw_port_fdb_add(struct dsa_switch *ds, int port,\n\t\t\t      const unsigned char *addr, u16 vid,\n\t\t\t      struct dsa_db db)\n{\n\tstruct a5psw *a5psw = ds->priv;\n\tunion lk_data lk_data = {0};\n\tbool inc_learncount = false;\n\tint ret = 0;\n\tu16 entry;\n\tu32 reg;\n\n\tether_addr_copy(lk_data.entry.mac, addr);\n\tlk_data.entry.port_mask = BIT(port);\n\n\tmutex_lock(&a5psw->lk_lock);\n\n\t \n\tret = a5psw_lk_execute_lookup(a5psw, &lk_data, &entry);\n\tif (ret)\n\t\tgoto lk_unlock;\n\n\tlk_data.hi = a5psw_reg_readl(a5psw, A5PSW_LK_DATA_HI);\n\tif (!lk_data.entry.valid) {\n\t\tinc_learncount = true;\n\t\t \n\t\tlk_data.entry.port_mask = 0;\n\t\tlk_data.entry.prio = 0;\n\t}\n\n\tlk_data.entry.port_mask |= BIT(port);\n\tlk_data.entry.is_static = 1;\n\tlk_data.entry.valid = 1;\n\n\ta5psw_reg_writel(a5psw, A5PSW_LK_DATA_HI, lk_data.hi);\n\n\treg = A5PSW_LK_ADDR_CTRL_WRITE | entry;\n\tret = a5psw_lk_execute_ctrl(a5psw, &reg);\n\tif (ret)\n\t\tgoto lk_unlock;\n\n\tif (inc_learncount) {\n\t\treg = A5PSW_LK_LEARNCOUNT_MODE_INC;\n\t\ta5psw_reg_writel(a5psw, A5PSW_LK_LEARNCOUNT, reg);\n\t}\n\nlk_unlock:\n\tmutex_unlock(&a5psw->lk_lock);\n\n\treturn ret;\n}\n\nstatic int a5psw_port_fdb_del(struct dsa_switch *ds, int port,\n\t\t\t      const unsigned char *addr, u16 vid,\n\t\t\t      struct dsa_db db)\n{\n\tstruct a5psw *a5psw = ds->priv;\n\tunion lk_data lk_data = {0};\n\tbool clear = false;\n\tu16 entry;\n\tu32 reg;\n\tint ret;\n\n\tether_addr_copy(lk_data.entry.mac, addr);\n\n\tmutex_lock(&a5psw->lk_lock);\n\n\tret = a5psw_lk_execute_lookup(a5psw, &lk_data, &entry);\n\tif (ret)\n\t\tgoto lk_unlock;\n\n\tlk_data.hi = a5psw_reg_readl(a5psw, A5PSW_LK_DATA_HI);\n\n\t \n\tif (!lk_data.entry.valid)\n\t\tgoto lk_unlock;\n\n\tlk_data.entry.port_mask &= ~BIT(port);\n\t \n\tif (lk_data.entry.port_mask == 0)\n\t\tclear = true;\n\n\ta5psw_reg_writel(a5psw, A5PSW_LK_DATA_HI, lk_data.hi);\n\n\treg = entry;\n\tif (clear)\n\t\treg |= A5PSW_LK_ADDR_CTRL_CLEAR;\n\telse\n\t\treg |= A5PSW_LK_ADDR_CTRL_WRITE;\n\n\tret = a5psw_lk_execute_ctrl(a5psw, &reg);\n\tif (ret)\n\t\tgoto lk_unlock;\n\n\t \n\tif (clear) {\n\t\treg = A5PSW_LK_LEARNCOUNT_MODE_DEC;\n\t\ta5psw_reg_writel(a5psw, A5PSW_LK_LEARNCOUNT, reg);\n\t}\n\nlk_unlock:\n\tmutex_unlock(&a5psw->lk_lock);\n\n\treturn ret;\n}\n\nstatic int a5psw_port_fdb_dump(struct dsa_switch *ds, int port,\n\t\t\t       dsa_fdb_dump_cb_t *cb, void *data)\n{\n\tstruct a5psw *a5psw = ds->priv;\n\tunion lk_data lk_data;\n\tint i = 0, ret = 0;\n\tu32 reg;\n\n\tmutex_lock(&a5psw->lk_lock);\n\n\tfor (i = 0; i < A5PSW_TABLE_ENTRIES; i++) {\n\t\treg = A5PSW_LK_ADDR_CTRL_READ | A5PSW_LK_ADDR_CTRL_WAIT | i;\n\n\t\tret = a5psw_lk_execute_ctrl(a5psw, &reg);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\n\t\tlk_data.hi = a5psw_reg_readl(a5psw, A5PSW_LK_DATA_HI);\n\t\t \n\t\tif (!lk_data.entry.valid ||\n\t\t    !(lk_data.entry.port_mask & BIT(port)))\n\t\t\tcontinue;\n\n\t\tlk_data.lo = a5psw_reg_readl(a5psw, A5PSW_LK_DATA_LO);\n\n\t\tret = cb(lk_data.entry.mac, 0, lk_data.entry.is_static, data);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\nout_unlock:\n\tmutex_unlock(&a5psw->lk_lock);\n\n\treturn ret;\n}\n\nstatic int a5psw_port_vlan_filtering(struct dsa_switch *ds, int port,\n\t\t\t\t     bool vlan_filtering,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tu32 mask = BIT(port + A5PSW_VLAN_VERI_SHIFT) |\n\t\t   BIT(port + A5PSW_VLAN_DISC_SHIFT);\n\tu32 val = vlan_filtering ? mask : 0;\n\tstruct a5psw *a5psw = ds->priv;\n\n\t \n\ta5psw_reg_rmw(a5psw, A5PSW_VLAN_IN_MODE_ENA, BIT(port),\n\t\t      vlan_filtering ? BIT(port) : 0);\n\n\t \n\ta5psw_reg_rmw(a5psw, A5PSW_VLAN_VERIFY, mask, val);\n\n\treturn 0;\n}\n\nstatic int a5psw_find_vlan_entry(struct a5psw *a5psw, u16 vid)\n{\n\tu32 vlan_res;\n\tint i;\n\n\t \n\tfor (i = 0; i < A5PSW_VLAN_COUNT; i++) {\n\t\tvlan_res = a5psw_reg_readl(a5psw, A5PSW_VLAN_RES(i));\n\t\tif (FIELD_GET(A5PSW_VLAN_RES_VLANID, vlan_res) == vid)\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}\n\nstatic int a5psw_new_vlan_res_entry(struct a5psw *a5psw, u16 newvid)\n{\n\tu32 vlan_res;\n\tint i;\n\n\t \n\tfor (i = 0; i < A5PSW_VLAN_COUNT; i++) {\n\t\tvlan_res = a5psw_reg_readl(a5psw, A5PSW_VLAN_RES(i));\n\t\tif (!(FIELD_GET(A5PSW_VLAN_RES_PORTMASK, vlan_res))) {\n\t\t\tvlan_res = FIELD_PREP(A5PSW_VLAN_RES_VLANID, newvid);\n\t\t\ta5psw_reg_writel(a5psw, A5PSW_VLAN_RES(i), vlan_res);\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nstatic void a5psw_port_vlan_tagged_cfg(struct a5psw *a5psw,\n\t\t\t\t       unsigned int vlan_res_id, int port,\n\t\t\t\t       bool set)\n{\n\tu32 mask = A5PSW_VLAN_RES_WR_PORTMASK | A5PSW_VLAN_RES_RD_TAGMASK |\n\t\t   BIT(port);\n\tu32 vlan_res_off = A5PSW_VLAN_RES(vlan_res_id);\n\tu32 val = A5PSW_VLAN_RES_WR_TAGMASK, reg;\n\n\tif (set)\n\t\tval |= BIT(port);\n\n\t \n\ta5psw_reg_writel(a5psw, vlan_res_off, A5PSW_VLAN_RES_RD_TAGMASK);\n\treg = a5psw_reg_readl(a5psw, vlan_res_off);\n\ta5psw_reg_writel(a5psw, vlan_res_off, A5PSW_VLAN_RES_RD_TAGMASK);\n\n\treg &= ~mask;\n\treg |= val;\n\ta5psw_reg_writel(a5psw, vlan_res_off, reg);\n}\n\nstatic void a5psw_port_vlan_cfg(struct a5psw *a5psw, unsigned int vlan_res_id,\n\t\t\t\tint port, bool set)\n{\n\tu32 mask = A5PSW_VLAN_RES_WR_TAGMASK | BIT(port);\n\tu32 reg = A5PSW_VLAN_RES_WR_PORTMASK;\n\n\tif (set)\n\t\treg |= BIT(port);\n\n\ta5psw_reg_rmw(a5psw, A5PSW_VLAN_RES(vlan_res_id), mask, reg);\n}\n\nstatic int a5psw_port_vlan_add(struct dsa_switch *ds, int port,\n\t\t\t       const struct switchdev_obj_port_vlan *vlan,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tbool tagged = !(vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED);\n\tbool pvid = vlan->flags & BRIDGE_VLAN_INFO_PVID;\n\tstruct a5psw *a5psw = ds->priv;\n\tu16 vid = vlan->vid;\n\tint vlan_res_id;\n\n\tvlan_res_id = a5psw_find_vlan_entry(a5psw, vid);\n\tif (vlan_res_id < 0) {\n\t\tvlan_res_id = a5psw_new_vlan_res_entry(a5psw, vid);\n\t\tif (vlan_res_id < 0)\n\t\t\treturn -ENOSPC;\n\t}\n\n\ta5psw_port_vlan_cfg(a5psw, vlan_res_id, port, true);\n\tif (tagged)\n\t\ta5psw_port_vlan_tagged_cfg(a5psw, vlan_res_id, port, true);\n\n\t \n\tif (pvid)\n\t\ta5psw_reg_writel(a5psw, A5PSW_SYSTEM_TAGINFO(port), vid);\n\n\treturn 0;\n}\n\nstatic int a5psw_port_vlan_del(struct dsa_switch *ds, int port,\n\t\t\t       const struct switchdev_obj_port_vlan *vlan)\n{\n\tstruct a5psw *a5psw = ds->priv;\n\tu16 vid = vlan->vid;\n\tint vlan_res_id;\n\n\tvlan_res_id = a5psw_find_vlan_entry(a5psw, vid);\n\tif (vlan_res_id < 0)\n\t\treturn -EINVAL;\n\n\ta5psw_port_vlan_cfg(a5psw, vlan_res_id, port, false);\n\ta5psw_port_vlan_tagged_cfg(a5psw, vlan_res_id, port, false);\n\n\treturn 0;\n}\n\nstatic u64 a5psw_read_stat(struct a5psw *a5psw, u32 offset, int port)\n{\n\tu32 reg_lo, reg_hi;\n\n\treg_lo = a5psw_reg_readl(a5psw, offset + A5PSW_PORT_OFFSET(port));\n\t \n\treg_hi = a5psw_reg_readl(a5psw, A5PSW_STATS_HIWORD);\n\n\treturn ((u64)reg_hi << 32) | reg_lo;\n}\n\nstatic void a5psw_get_strings(struct dsa_switch *ds, int port, u32 stringset,\n\t\t\t      uint8_t *data)\n{\n\tunsigned int u;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tfor (u = 0; u < ARRAY_SIZE(a5psw_stats); u++) {\n\t\tmemcpy(data + u * ETH_GSTRING_LEN, a5psw_stats[u].name,\n\t\t       ETH_GSTRING_LEN);\n\t}\n}\n\nstatic void a5psw_get_ethtool_stats(struct dsa_switch *ds, int port,\n\t\t\t\t    uint64_t *data)\n{\n\tstruct a5psw *a5psw = ds->priv;\n\tunsigned int u;\n\n\tfor (u = 0; u < ARRAY_SIZE(a5psw_stats); u++)\n\t\tdata[u] = a5psw_read_stat(a5psw, a5psw_stats[u].offset, port);\n}\n\nstatic int a5psw_get_sset_count(struct dsa_switch *ds, int port, int sset)\n{\n\tif (sset != ETH_SS_STATS)\n\t\treturn 0;\n\n\treturn ARRAY_SIZE(a5psw_stats);\n}\n\nstatic void a5psw_get_eth_mac_stats(struct dsa_switch *ds, int port,\n\t\t\t\t    struct ethtool_eth_mac_stats *mac_stats)\n{\n\tstruct a5psw *a5psw = ds->priv;\n\n#define RD(name) a5psw_read_stat(a5psw, A5PSW_##name, port)\n\tmac_stats->FramesTransmittedOK = RD(aFramesTransmittedOK);\n\tmac_stats->SingleCollisionFrames = RD(aSingleCollisions);\n\tmac_stats->MultipleCollisionFrames = RD(aMultipleCollisions);\n\tmac_stats->FramesReceivedOK = RD(aFramesReceivedOK);\n\tmac_stats->FrameCheckSequenceErrors = RD(aFrameCheckSequenceErrors);\n\tmac_stats->AlignmentErrors = RD(aAlignmentErrors);\n\tmac_stats->OctetsTransmittedOK = RD(aOctetsTransmittedOK);\n\tmac_stats->FramesWithDeferredXmissions = RD(aDeferred);\n\tmac_stats->LateCollisions = RD(aLateCollisions);\n\tmac_stats->FramesAbortedDueToXSColls = RD(aExcessiveCollisions);\n\tmac_stats->FramesLostDueToIntMACXmitError = RD(ifOutErrors);\n\tmac_stats->CarrierSenseErrors = RD(aCarrierSenseErrors);\n\tmac_stats->OctetsReceivedOK = RD(aOctetsReceivedOK);\n\tmac_stats->FramesLostDueToIntMACRcvError = RD(ifInErrors);\n\tmac_stats->MulticastFramesXmittedOK = RD(ifOutMulticastPkts);\n\tmac_stats->BroadcastFramesXmittedOK = RD(ifOutBroadcastPkts);\n\tmac_stats->FramesWithExcessiveDeferral = RD(aDeferred);\n\tmac_stats->MulticastFramesReceivedOK = RD(ifInMulticastPkts);\n\tmac_stats->BroadcastFramesReceivedOK = RD(ifInBroadcastPkts);\n#undef RD\n}\n\nstatic const struct ethtool_rmon_hist_range a5psw_rmon_ranges[] = {\n\t{ 0, 64 },\n\t{ 65, 127 },\n\t{ 128, 255 },\n\t{ 256, 511 },\n\t{ 512, 1023 },\n\t{ 1024, 1518 },\n\t{ 1519, A5PSW_MAX_MTU },\n\t{}\n};\n\nstatic void a5psw_get_rmon_stats(struct dsa_switch *ds, int port,\n\t\t\t\t struct ethtool_rmon_stats *rmon_stats,\n\t\t\t\t const struct ethtool_rmon_hist_range **ranges)\n{\n\tstruct a5psw *a5psw = ds->priv;\n\n#define RD(name) a5psw_read_stat(a5psw, A5PSW_##name, port)\n\trmon_stats->undersize_pkts = RD(etherStatsUndersizePkts);\n\trmon_stats->oversize_pkts = RD(etherStatsOversizePkts);\n\trmon_stats->fragments = RD(etherStatsFragments);\n\trmon_stats->jabbers = RD(etherStatsJabbers);\n\trmon_stats->hist[0] = RD(etherStatsPkts64Octets);\n\trmon_stats->hist[1] = RD(etherStatsPkts65to127Octets);\n\trmon_stats->hist[2] = RD(etherStatsPkts128to255Octets);\n\trmon_stats->hist[3] = RD(etherStatsPkts256to511Octets);\n\trmon_stats->hist[4] = RD(etherStatsPkts512to1023Octets);\n\trmon_stats->hist[5] = RD(etherStatsPkts1024to1518Octets);\n\trmon_stats->hist[6] = RD(etherStatsPkts1519toXOctets);\n#undef RD\n\n\t*ranges = a5psw_rmon_ranges;\n}\n\nstatic void a5psw_get_eth_ctrl_stats(struct dsa_switch *ds, int port,\n\t\t\t\t     struct ethtool_eth_ctrl_stats *ctrl_stats)\n{\n\tstruct a5psw *a5psw = ds->priv;\n\tu64 stat;\n\n\tstat = a5psw_read_stat(a5psw, A5PSW_aTxPAUSEMACCtrlFrames, port);\n\tctrl_stats->MACControlFramesTransmitted = stat;\n\tstat = a5psw_read_stat(a5psw, A5PSW_aRxPAUSEMACCtrlFrames, port);\n\tctrl_stats->MACControlFramesReceived = stat;\n}\n\nstatic void a5psw_vlan_setup(struct a5psw *a5psw, int port)\n{\n\tu32 reg;\n\n\t \n\treg = A5PSW_VLAN_IN_MODE_TAG_ALWAYS;\n\treg <<= A5PSW_VLAN_IN_MODE_PORT_SHIFT(port);\n\ta5psw_reg_rmw(a5psw, A5PSW_VLAN_IN_MODE, A5PSW_VLAN_IN_MODE_PORT(port),\n\t\t      reg);\n\n\t \n\treg = A5PSW_VLAN_OUT_MODE_TRANSPARENT;\n\treg <<= A5PSW_VLAN_OUT_MODE_PORT_SHIFT(port);\n\ta5psw_reg_rmw(a5psw, A5PSW_VLAN_OUT_MODE,\n\t\t      A5PSW_VLAN_OUT_MODE_PORT(port), reg);\n}\n\nstatic int a5psw_setup(struct dsa_switch *ds)\n{\n\tstruct a5psw *a5psw = ds->priv;\n\tint port, vlan, ret;\n\tstruct dsa_port *dp;\n\tu32 reg;\n\n\t \n\tdsa_switch_for_each_cpu_port(dp, ds) {\n\t\tif (dp->index != A5PSW_CPU_PORT) {\n\t\t\tdev_err(a5psw->dev, \"Invalid CPU port\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\treg = A5PSW_CPU_PORT | A5PSW_MGMT_CFG_ENABLE;\n\ta5psw_reg_writel(a5psw, A5PSW_MGMT_CFG, reg);\n\n\t \n\ta5psw_reg_writel(a5psw, A5PSW_PATTERN_CTRL(A5PSW_PATTERN_MGMTFWD),\n\t\t\t A5PSW_PATTERN_CTRL_MGMTFWD);\n\n\t \n\treg = FIELD_PREP(A5PSW_MGMT_TAG_CFG_TAGFIELD, ETH_P_DSA_A5PSW);\n\treg |= A5PSW_MGMT_TAG_CFG_ENABLE | A5PSW_MGMT_TAG_CFG_ALL_FRAMES;\n\ta5psw_reg_writel(a5psw, A5PSW_MGMT_TAG_CFG, reg);\n\n\t \n\treg = A5PSW_LK_ADDR_CTRL_BLOCKING | A5PSW_LK_ADDR_CTRL_LEARNING |\n\t      A5PSW_LK_ADDR_CTRL_AGEING | A5PSW_LK_ADDR_CTRL_ALLOW_MIGR |\n\t      A5PSW_LK_ADDR_CTRL_CLEAR_TABLE;\n\ta5psw_reg_writel(a5psw, A5PSW_LK_CTRL, reg);\n\n\tret = readl_poll_timeout(a5psw->base + A5PSW_LK_CTRL, reg,\n\t\t\t\t !(reg & A5PSW_LK_ADDR_CTRL_CLEAR_TABLE),\n\t\t\t\t A5PSW_LK_BUSY_USEC_POLL, A5PSW_CTRL_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(a5psw->dev, \"Failed to clear lookup table\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\treg = A5PSW_LK_LEARNCOUNT_MODE_SET;\n\ta5psw_reg_writel(a5psw, A5PSW_LK_LEARNCOUNT, reg);\n\n\t \n\treg = A5PSW_VLAN_RES_WR_PORTMASK | A5PSW_VLAN_RES_WR_TAGMASK;\n\tfor (vlan = 0; vlan < A5PSW_VLAN_COUNT; vlan++)\n\t\ta5psw_reg_writel(a5psw, A5PSW_VLAN_RES(vlan), reg);\n\n\t \n\tdsa_switch_for_each_port(dp, ds) {\n\t\tport = dp->index;\n\n\t\t \n\t\ta5psw_reg_writel(a5psw, A5PSW_CMD_CFG(port),\n\t\t\t\t A5PSW_CMD_CFG_SW_RESET);\n\n\t\t \n\t\ta5psw_port_enable_set(a5psw, port, dsa_port_is_cpu(dp));\n\n\t\tif (dsa_port_is_unused(dp))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (dsa_port_is_cpu(dp)) {\n\t\t\ta5psw_flooding_set_resolution(a5psw, port, true);\n\t\t\ta5psw_port_learning_set(a5psw, port, true);\n\t\t}\n\n\t\t \n\t\tif (dsa_port_is_user(dp))\n\t\t\ta5psw_port_set_standalone(a5psw, port, true);\n\n\t\ta5psw_vlan_setup(a5psw, port);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dsa_switch_ops a5psw_switch_ops = {\n\t.get_tag_protocol = a5psw_get_tag_protocol,\n\t.setup = a5psw_setup,\n\t.port_disable = a5psw_port_disable,\n\t.port_enable = a5psw_port_enable,\n\t.phylink_get_caps = a5psw_phylink_get_caps,\n\t.phylink_mac_select_pcs = a5psw_phylink_mac_select_pcs,\n\t.phylink_mac_link_down = a5psw_phylink_mac_link_down,\n\t.phylink_mac_link_up = a5psw_phylink_mac_link_up,\n\t.port_change_mtu = a5psw_port_change_mtu,\n\t.port_max_mtu = a5psw_port_max_mtu,\n\t.get_sset_count = a5psw_get_sset_count,\n\t.get_strings = a5psw_get_strings,\n\t.get_ethtool_stats = a5psw_get_ethtool_stats,\n\t.get_eth_mac_stats = a5psw_get_eth_mac_stats,\n\t.get_eth_ctrl_stats = a5psw_get_eth_ctrl_stats,\n\t.get_rmon_stats = a5psw_get_rmon_stats,\n\t.set_ageing_time = a5psw_set_ageing_time,\n\t.port_bridge_join = a5psw_port_bridge_join,\n\t.port_bridge_leave = a5psw_port_bridge_leave,\n\t.port_pre_bridge_flags = a5psw_port_pre_bridge_flags,\n\t.port_bridge_flags = a5psw_port_bridge_flags,\n\t.port_stp_state_set = a5psw_port_stp_state_set,\n\t.port_fast_age = a5psw_port_fast_age,\n\t.port_vlan_filtering = a5psw_port_vlan_filtering,\n\t.port_vlan_add = a5psw_port_vlan_add,\n\t.port_vlan_del = a5psw_port_vlan_del,\n\t.port_fdb_add = a5psw_port_fdb_add,\n\t.port_fdb_del = a5psw_port_fdb_del,\n\t.port_fdb_dump = a5psw_port_fdb_dump,\n};\n\nstatic int a5psw_mdio_wait_busy(struct a5psw *a5psw)\n{\n\tu32 status;\n\tint err;\n\n\terr = readl_poll_timeout(a5psw->base + A5PSW_MDIO_CFG_STATUS, status,\n\t\t\t\t !(status & A5PSW_MDIO_CFG_STATUS_BUSY), 10,\n\t\t\t\t 1000 * USEC_PER_MSEC);\n\tif (err)\n\t\tdev_err(a5psw->dev, \"MDIO command timeout\\n\");\n\n\treturn err;\n}\n\nstatic int a5psw_mdio_read(struct mii_bus *bus, int phy_id, int phy_reg)\n{\n\tstruct a5psw *a5psw = bus->priv;\n\tu32 cmd, status;\n\tint ret;\n\n\tcmd = A5PSW_MDIO_COMMAND_READ;\n\tcmd |= FIELD_PREP(A5PSW_MDIO_COMMAND_REG_ADDR, phy_reg);\n\tcmd |= FIELD_PREP(A5PSW_MDIO_COMMAND_PHY_ADDR, phy_id);\n\n\ta5psw_reg_writel(a5psw, A5PSW_MDIO_COMMAND, cmd);\n\n\tret = a5psw_mdio_wait_busy(a5psw);\n\tif (ret)\n\t\treturn ret;\n\n\tret = a5psw_reg_readl(a5psw, A5PSW_MDIO_DATA) & A5PSW_MDIO_DATA_MASK;\n\n\tstatus = a5psw_reg_readl(a5psw, A5PSW_MDIO_CFG_STATUS);\n\tif (status & A5PSW_MDIO_CFG_STATUS_READERR)\n\t\treturn -EIO;\n\n\treturn ret;\n}\n\nstatic int a5psw_mdio_write(struct mii_bus *bus, int phy_id, int phy_reg,\n\t\t\t    u16 phy_data)\n{\n\tstruct a5psw *a5psw = bus->priv;\n\tu32 cmd;\n\n\tcmd = FIELD_PREP(A5PSW_MDIO_COMMAND_REG_ADDR, phy_reg);\n\tcmd |= FIELD_PREP(A5PSW_MDIO_COMMAND_PHY_ADDR, phy_id);\n\n\ta5psw_reg_writel(a5psw, A5PSW_MDIO_COMMAND, cmd);\n\ta5psw_reg_writel(a5psw, A5PSW_MDIO_DATA, phy_data);\n\n\treturn a5psw_mdio_wait_busy(a5psw);\n}\n\nstatic int a5psw_mdio_config(struct a5psw *a5psw, u32 mdio_freq)\n{\n\tunsigned long rate;\n\tunsigned long div;\n\tu32 cfgstatus;\n\n\trate = clk_get_rate(a5psw->hclk);\n\tdiv = ((rate / mdio_freq) / 2);\n\tif (div > FIELD_MAX(A5PSW_MDIO_CFG_STATUS_CLKDIV) ||\n\t    div < A5PSW_MDIO_CLK_DIV_MIN) {\n\t\tdev_err(a5psw->dev, \"MDIO clock div %ld out of range\\n\", div);\n\t\treturn -ERANGE;\n\t}\n\n\tcfgstatus = FIELD_PREP(A5PSW_MDIO_CFG_STATUS_CLKDIV, div);\n\n\ta5psw_reg_writel(a5psw, A5PSW_MDIO_CFG_STATUS, cfgstatus);\n\n\treturn 0;\n}\n\nstatic int a5psw_probe_mdio(struct a5psw *a5psw, struct device_node *node)\n{\n\tstruct device *dev = a5psw->dev;\n\tstruct mii_bus *bus;\n\tu32 mdio_freq;\n\tint ret;\n\n\tif (of_property_read_u32(node, \"clock-frequency\", &mdio_freq))\n\t\tmdio_freq = A5PSW_MDIO_DEF_FREQ;\n\n\tret = a5psw_mdio_config(a5psw, mdio_freq);\n\tif (ret)\n\t\treturn ret;\n\n\tbus = devm_mdiobus_alloc(dev);\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\tbus->name = \"a5psw_mdio\";\n\tbus->read = a5psw_mdio_read;\n\tbus->write = a5psw_mdio_write;\n\tbus->priv = a5psw;\n\tbus->parent = dev;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s\", dev_name(dev));\n\n\ta5psw->mii_bus = bus;\n\n\treturn devm_of_mdiobus_register(dev, bus, node);\n}\n\nstatic void a5psw_pcs_free(struct a5psw *a5psw)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(a5psw->pcs); i++) {\n\t\tif (a5psw->pcs[i])\n\t\t\tmiic_destroy(a5psw->pcs[i]);\n\t}\n}\n\nstatic int a5psw_pcs_get(struct a5psw *a5psw)\n{\n\tstruct device_node *ports, *port, *pcs_node;\n\tstruct phylink_pcs *pcs;\n\tint ret;\n\tu32 reg;\n\n\tports = of_get_child_by_name(a5psw->dev->of_node, \"ethernet-ports\");\n\tif (!ports)\n\t\treturn -EINVAL;\n\n\tfor_each_available_child_of_node(ports, port) {\n\t\tpcs_node = of_parse_phandle(port, \"pcs-handle\", 0);\n\t\tif (!pcs_node)\n\t\t\tcontinue;\n\n\t\tif (of_property_read_u32(port, \"reg\", &reg)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_pcs;\n\t\t}\n\n\t\tif (reg >= ARRAY_SIZE(a5psw->pcs)) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto free_pcs;\n\t\t}\n\n\t\tpcs = miic_create(a5psw->dev, pcs_node);\n\t\tif (IS_ERR(pcs)) {\n\t\t\tdev_err(a5psw->dev, \"Failed to create PCS for port %d\\n\",\n\t\t\t\treg);\n\t\t\tret = PTR_ERR(pcs);\n\t\t\tgoto free_pcs;\n\t\t}\n\n\t\ta5psw->pcs[reg] = pcs;\n\t\tof_node_put(pcs_node);\n\t}\n\tof_node_put(ports);\n\n\treturn 0;\n\nfree_pcs:\n\tof_node_put(pcs_node);\n\tof_node_put(port);\n\tof_node_put(ports);\n\ta5psw_pcs_free(a5psw);\n\n\treturn ret;\n}\n\nstatic int a5psw_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *mdio;\n\tstruct dsa_switch *ds;\n\tstruct a5psw *a5psw;\n\tint ret;\n\n\ta5psw = devm_kzalloc(dev, sizeof(*a5psw), GFP_KERNEL);\n\tif (!a5psw)\n\t\treturn -ENOMEM;\n\n\ta5psw->dev = dev;\n\tmutex_init(&a5psw->lk_lock);\n\tspin_lock_init(&a5psw->reg_lock);\n\ta5psw->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(a5psw->base))\n\t\treturn PTR_ERR(a5psw->base);\n\n\ta5psw->bridged_ports = BIT(A5PSW_CPU_PORT);\n\n\tret = a5psw_pcs_get(a5psw);\n\tif (ret)\n\t\treturn ret;\n\n\ta5psw->hclk = devm_clk_get(dev, \"hclk\");\n\tif (IS_ERR(a5psw->hclk)) {\n\t\tdev_err(dev, \"failed get hclk clock\\n\");\n\t\tret = PTR_ERR(a5psw->hclk);\n\t\tgoto free_pcs;\n\t}\n\n\ta5psw->clk = devm_clk_get(dev, \"clk\");\n\tif (IS_ERR(a5psw->clk)) {\n\t\tdev_err(dev, \"failed get clk_switch clock\\n\");\n\t\tret = PTR_ERR(a5psw->clk);\n\t\tgoto free_pcs;\n\t}\n\n\tret = clk_prepare_enable(a5psw->clk);\n\tif (ret)\n\t\tgoto free_pcs;\n\n\tret = clk_prepare_enable(a5psw->hclk);\n\tif (ret)\n\t\tgoto clk_disable;\n\n\tmdio = of_get_child_by_name(dev->of_node, \"mdio\");\n\tif (of_device_is_available(mdio)) {\n\t\tret = a5psw_probe_mdio(a5psw, mdio);\n\t\tif (ret) {\n\t\t\tof_node_put(mdio);\n\t\t\tdev_err(dev, \"Failed to register MDIO: %d\\n\", ret);\n\t\t\tgoto hclk_disable;\n\t\t}\n\t}\n\n\tof_node_put(mdio);\n\n\tds = &a5psw->ds;\n\tds->dev = dev;\n\tds->num_ports = A5PSW_PORTS_NUM;\n\tds->ops = &a5psw_switch_ops;\n\tds->priv = a5psw;\n\n\tret = dsa_register_switch(ds);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register DSA switch: %d\\n\", ret);\n\t\tgoto hclk_disable;\n\t}\n\n\treturn 0;\n\nhclk_disable:\n\tclk_disable_unprepare(a5psw->hclk);\nclk_disable:\n\tclk_disable_unprepare(a5psw->clk);\nfree_pcs:\n\ta5psw_pcs_free(a5psw);\n\n\treturn ret;\n}\n\nstatic int a5psw_remove(struct platform_device *pdev)\n{\n\tstruct a5psw *a5psw = platform_get_drvdata(pdev);\n\n\tif (!a5psw)\n\t\treturn 0;\n\n\tdsa_unregister_switch(&a5psw->ds);\n\ta5psw_pcs_free(a5psw);\n\tclk_disable_unprepare(a5psw->hclk);\n\tclk_disable_unprepare(a5psw->clk);\n\n\treturn 0;\n}\n\nstatic void a5psw_shutdown(struct platform_device *pdev)\n{\n\tstruct a5psw *a5psw = platform_get_drvdata(pdev);\n\n\tif (!a5psw)\n\t\treturn;\n\n\tdsa_switch_shutdown(&a5psw->ds);\n\n\tplatform_set_drvdata(pdev, NULL);\n}\n\nstatic const struct of_device_id a5psw_of_mtable[] = {\n\t{ .compatible = \"renesas,rzn1-a5psw\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, a5psw_of_mtable);\n\nstatic struct platform_driver a5psw_driver = {\n\t.driver = {\n\t\t.name\t = \"rzn1_a5psw\",\n\t\t.of_match_table = a5psw_of_mtable,\n\t},\n\t.probe = a5psw_probe,\n\t.remove = a5psw_remove,\n\t.shutdown = a5psw_shutdown,\n};\nmodule_platform_driver(a5psw_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Renesas RZ/N1 Advanced 5-port Switch driver\");\nMODULE_AUTHOR(\"Cl\u00e9ment L\u00e9ger <clement.leger@bootlin.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}