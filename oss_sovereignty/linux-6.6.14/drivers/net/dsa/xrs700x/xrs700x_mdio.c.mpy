{
  "module_name": "xrs700x_mdio.c",
  "hash_id": "36c76ba39487c79e7382895d2fed4db1fbf5fd264ce6967452cadba0e3c9f398",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/xrs700x/xrs700x_mdio.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/mdio.h>\n#include <linux/module.h>\n#include <linux/phy.h>\n#include <linux/if_vlan.h>\n#include <linux/of.h>\n#include \"xrs700x.h\"\n#include \"xrs700x_reg.h\"\n\n#define XRS_MDIO_IBA0\t0x10\n#define XRS_MDIO_IBA1\t0x11\n#define XRS_MDIO_IBD\t0x14\n\n#define XRS_IB_READ\t0x0\n#define XRS_IB_WRITE\t0x1\n\nstatic int xrs700x_mdio_reg_read(void *context, unsigned int reg,\n\t\t\t\t unsigned int *val)\n{\n\tstruct mdio_device *mdiodev = context;\n\tstruct device *dev = &mdiodev->dev;\n\tu16 uval;\n\tint ret;\n\n\tuval = (u16)FIELD_GET(GENMASK(31, 16), reg);\n\n\tret = mdiodev_write(mdiodev, XRS_MDIO_IBA1, uval);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"xrs mdiobus_write returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tuval = (u16)((reg & GENMASK(15, 1)) | XRS_IB_READ);\n\n\tret = mdiodev_write(mdiodev, XRS_MDIO_IBA0, uval);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"xrs mdiobus_write returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = mdiodev_read(mdiodev, XRS_MDIO_IBD);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"xrs mdiobus_read returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*val = (unsigned int)ret;\n\n\treturn 0;\n}\n\nstatic int xrs700x_mdio_reg_write(void *context, unsigned int reg,\n\t\t\t\t  unsigned int val)\n{\n\tstruct mdio_device *mdiodev = context;\n\tstruct device *dev = &mdiodev->dev;\n\tu16 uval;\n\tint ret;\n\n\tret = mdiodev_write(mdiodev, XRS_MDIO_IBD, (u16)val);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"xrs mdiobus_write returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tuval = (u16)FIELD_GET(GENMASK(31, 16), reg);\n\n\tret = mdiodev_write(mdiodev, XRS_MDIO_IBA1, uval);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"xrs mdiobus_write returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tuval = (u16)((reg & GENMASK(15, 1)) | XRS_IB_WRITE);\n\n\tret = mdiodev_write(mdiodev, XRS_MDIO_IBA0, uval);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"xrs mdiobus_write returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct regmap_config xrs700x_mdio_regmap_config = {\n\t.val_bits = 16,\n\t.reg_stride = 2,\n\t.reg_bits = 32,\n\t.pad_bits = 0,\n\t.write_flag_mask = 0,\n\t.read_flag_mask = 0,\n\t.reg_read = xrs700x_mdio_reg_read,\n\t.reg_write = xrs700x_mdio_reg_write,\n\t.max_register = XRS_VLAN(VLAN_N_VID - 1),\n\t.cache_type = REGCACHE_NONE,\n\t.reg_format_endian = REGMAP_ENDIAN_BIG,\n\t.val_format_endian = REGMAP_ENDIAN_BIG\n};\n\nstatic int xrs700x_mdio_probe(struct mdio_device *mdiodev)\n{\n\tstruct xrs700x *priv;\n\tint ret;\n\n\tpriv = xrs700x_switch_alloc(&mdiodev->dev, mdiodev);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->regmap = devm_regmap_init(&mdiodev->dev, NULL, mdiodev,\n\t\t\t\t\t&xrs700x_mdio_regmap_config);\n\tif (IS_ERR(priv->regmap)) {\n\t\tret = PTR_ERR(priv->regmap);\n\t\tdev_err(&mdiodev->dev, \"Failed to initialize regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdev_set_drvdata(&mdiodev->dev, priv);\n\n\tret = xrs700x_switch_register(priv);\n\n\t \n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void xrs700x_mdio_remove(struct mdio_device *mdiodev)\n{\n\tstruct xrs700x *priv = dev_get_drvdata(&mdiodev->dev);\n\n\tif (!priv)\n\t\treturn;\n\n\txrs700x_switch_remove(priv);\n}\n\nstatic void xrs700x_mdio_shutdown(struct mdio_device *mdiodev)\n{\n\tstruct xrs700x *priv = dev_get_drvdata(&mdiodev->dev);\n\n\tif (!priv)\n\t\treturn;\n\n\txrs700x_switch_shutdown(priv);\n\n\tdev_set_drvdata(&mdiodev->dev, NULL);\n}\n\nstatic const struct of_device_id __maybe_unused xrs700x_mdio_dt_ids[] = {\n\t{ .compatible = \"arrow,xrs7003e\", .data = &xrs7003e_info },\n\t{ .compatible = \"arrow,xrs7003f\", .data = &xrs7003f_info },\n\t{ .compatible = \"arrow,xrs7004e\", .data = &xrs7004e_info },\n\t{ .compatible = \"arrow,xrs7004f\", .data = &xrs7004f_info },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, xrs700x_mdio_dt_ids);\n\nstatic struct mdio_driver xrs700x_mdio_driver = {\n\t.mdiodrv.driver = {\n\t\t.name\t= \"xrs700x-mdio\",\n\t\t.of_match_table = of_match_ptr(xrs700x_mdio_dt_ids),\n\t},\n\t.probe\t= xrs700x_mdio_probe,\n\t.remove\t= xrs700x_mdio_remove,\n\t.shutdown = xrs700x_mdio_shutdown,\n};\n\nmdio_module_driver(xrs700x_mdio_driver);\n\nMODULE_AUTHOR(\"George McCollister <george.mccollister@gmail.com>\");\nMODULE_DESCRIPTION(\"Arrow SpeedChips XRS700x DSA MDIO driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}