{
  "module_name": "xrs700x_i2c.c",
  "hash_id": "65db01db713b3bd517b9b2fa3c8ed026b5aba4eec7d0538d1b0e652b876340c6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/xrs700x/xrs700x_i2c.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include \"xrs700x.h\"\n#include \"xrs700x_reg.h\"\n\nstruct xrs700x_i2c_cmd {\n\t__be32 reg;\n\t__be16 val;\n} __packed;\n\nstatic int xrs700x_i2c_reg_read(void *context, unsigned int reg,\n\t\t\t\tunsigned int *val)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct xrs700x_i2c_cmd cmd;\n\tint ret;\n\n\tcmd.reg = cpu_to_be32(reg | 1);\n\n\tret = i2c_master_send(i2c, (char *)&cmd.reg, sizeof(cmd.reg));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"xrs i2c_master_send returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = i2c_master_recv(i2c, (char *)&cmd.val, sizeof(cmd.val));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"xrs i2c_master_recv returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*val = be16_to_cpu(cmd.val);\n\treturn 0;\n}\n\nstatic int xrs700x_i2c_reg_write(void *context, unsigned int reg,\n\t\t\t\t unsigned int val)\n{\n\tstruct device *dev = context;\n\tstruct i2c_client *i2c = to_i2c_client(dev);\n\tstruct xrs700x_i2c_cmd cmd;\n\tint ret;\n\n\tcmd.reg = cpu_to_be32(reg);\n\tcmd.val = cpu_to_be16(val);\n\n\tret = i2c_master_send(i2c, (char *)&cmd, sizeof(cmd));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"xrs i2c_master_send returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct regmap_config xrs700x_i2c_regmap_config = {\n\t.val_bits = 16,\n\t.reg_stride = 2,\n\t.reg_bits = 32,\n\t.pad_bits = 0,\n\t.write_flag_mask = 0,\n\t.read_flag_mask = 0,\n\t.reg_read = xrs700x_i2c_reg_read,\n\t.reg_write = xrs700x_i2c_reg_write,\n\t.max_register = 0,\n\t.cache_type = REGCACHE_NONE,\n\t.reg_format_endian = REGMAP_ENDIAN_BIG,\n\t.val_format_endian = REGMAP_ENDIAN_BIG\n};\n\nstatic int xrs700x_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct xrs700x *priv;\n\tint ret;\n\n\tpriv = xrs700x_switch_alloc(&i2c->dev, i2c);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->regmap = devm_regmap_init(&i2c->dev, NULL, &i2c->dev,\n\t\t\t\t\t&xrs700x_i2c_regmap_config);\n\tif (IS_ERR(priv->regmap)) {\n\t\tret = PTR_ERR(priv->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to initialize regmap: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ti2c_set_clientdata(i2c, priv);\n\n\tret = xrs700x_switch_register(priv);\n\n\t \n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void xrs700x_i2c_remove(struct i2c_client *i2c)\n{\n\tstruct xrs700x *priv = i2c_get_clientdata(i2c);\n\n\tif (!priv)\n\t\treturn;\n\n\txrs700x_switch_remove(priv);\n}\n\nstatic void xrs700x_i2c_shutdown(struct i2c_client *i2c)\n{\n\tstruct xrs700x *priv = i2c_get_clientdata(i2c);\n\n\tif (!priv)\n\t\treturn;\n\n\txrs700x_switch_shutdown(priv);\n\n\ti2c_set_clientdata(i2c, NULL);\n}\n\nstatic const struct i2c_device_id xrs700x_i2c_id[] = {\n\t{ \"xrs700x-switch\", 0 },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(i2c, xrs700x_i2c_id);\n\nstatic const struct of_device_id __maybe_unused xrs700x_i2c_dt_ids[] = {\n\t{ .compatible = \"arrow,xrs7003e\", .data = &xrs7003e_info },\n\t{ .compatible = \"arrow,xrs7003f\", .data = &xrs7003f_info },\n\t{ .compatible = \"arrow,xrs7004e\", .data = &xrs7004e_info },\n\t{ .compatible = \"arrow,xrs7004f\", .data = &xrs7004f_info },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, xrs700x_i2c_dt_ids);\n\nstatic struct i2c_driver xrs700x_i2c_driver = {\n\t.driver = {\n\t\t.name\t= \"xrs700x-i2c\",\n\t\t.of_match_table = of_match_ptr(xrs700x_i2c_dt_ids),\n\t},\n\t.probe = xrs700x_i2c_probe,\n\t.remove\t= xrs700x_i2c_remove,\n\t.shutdown = xrs700x_i2c_shutdown,\n\t.id_table = xrs700x_i2c_id,\n};\n\nmodule_i2c_driver(xrs700x_i2c_driver);\n\nMODULE_AUTHOR(\"George McCollister <george.mccollister@gmail.com>\");\nMODULE_DESCRIPTION(\"Arrow SpeedChips XRS700x DSA I2C driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}