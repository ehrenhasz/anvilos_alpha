{
  "module_name": "xrs700x.c",
  "hash_id": "ba93a5e18f6fae1c1d9fa363949cc4c5ca9d5b63cf3db38d4348a9c0c8c1ee85",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/xrs700x/xrs700x.c",
  "human_readable_source": "\n \n\n#include <net/dsa.h>\n#include <linux/etherdevice.h>\n#include <linux/if_bridge.h>\n#include <linux/of.h>\n#include <linux/netdev_features.h>\n#include <linux/if_hsr.h>\n#include \"xrs700x.h\"\n#include \"xrs700x_reg.h\"\n\n#define XRS700X_MIB_INTERVAL msecs_to_jiffies(3000)\n\n#define XRS7000X_SUPPORTED_HSR_FEATURES \\\n\t(NETIF_F_HW_HSR_TAG_INS | NETIF_F_HW_HSR_TAG_RM | \\\n\t NETIF_F_HW_HSR_FWD | NETIF_F_HW_HSR_DUP)\n\n#define XRS7003E_ID\t0x100\n#define XRS7003F_ID\t0x101\n#define XRS7004E_ID\t0x200\n#define XRS7004F_ID\t0x201\n\nconst struct xrs700x_info xrs7003e_info = {XRS7003E_ID, \"XRS7003E\", 3};\nEXPORT_SYMBOL(xrs7003e_info);\n\nconst struct xrs700x_info xrs7003f_info = {XRS7003F_ID, \"XRS7003F\", 3};\nEXPORT_SYMBOL(xrs7003f_info);\n\nconst struct xrs700x_info xrs7004e_info = {XRS7004E_ID, \"XRS7004E\", 4};\nEXPORT_SYMBOL(xrs7004e_info);\n\nconst struct xrs700x_info xrs7004f_info = {XRS7004F_ID, \"XRS7004F\", 4};\nEXPORT_SYMBOL(xrs7004f_info);\n\nstruct xrs700x_regfield {\n\tstruct reg_field rf;\n\tstruct regmap_field **rmf;\n};\n\nstruct xrs700x_mib {\n\tunsigned int offset;\n\tconst char *name;\n\tint stats64_offset;\n};\n\n#define XRS700X_MIB_ETHTOOL_ONLY(o, n) {o, n, -1}\n#define XRS700X_MIB(o, n, m) {o, n, offsetof(struct rtnl_link_stats64, m)}\n\nstatic const struct xrs700x_mib xrs700x_mibs[] = {\n\tXRS700X_MIB(XRS_RX_GOOD_OCTETS_L, \"rx_good_octets\", rx_bytes),\n\tXRS700X_MIB_ETHTOOL_ONLY(XRS_RX_BAD_OCTETS_L, \"rx_bad_octets\"),\n\tXRS700X_MIB(XRS_RX_UNICAST_L, \"rx_unicast\", rx_packets),\n\tXRS700X_MIB(XRS_RX_BROADCAST_L, \"rx_broadcast\", rx_packets),\n\tXRS700X_MIB(XRS_RX_MULTICAST_L, \"rx_multicast\", multicast),\n\tXRS700X_MIB(XRS_RX_UNDERSIZE_L, \"rx_undersize\", rx_length_errors),\n\tXRS700X_MIB(XRS_RX_FRAGMENTS_L, \"rx_fragments\", rx_length_errors),\n\tXRS700X_MIB(XRS_RX_OVERSIZE_L, \"rx_oversize\", rx_length_errors),\n\tXRS700X_MIB(XRS_RX_JABBER_L, \"rx_jabber\", rx_length_errors),\n\tXRS700X_MIB(XRS_RX_ERR_L, \"rx_err\", rx_errors),\n\tXRS700X_MIB(XRS_RX_CRC_L, \"rx_crc\", rx_crc_errors),\n\tXRS700X_MIB_ETHTOOL_ONLY(XRS_RX_64_L, \"rx_64\"),\n\tXRS700X_MIB_ETHTOOL_ONLY(XRS_RX_65_127_L, \"rx_65_127\"),\n\tXRS700X_MIB_ETHTOOL_ONLY(XRS_RX_128_255_L, \"rx_128_255\"),\n\tXRS700X_MIB_ETHTOOL_ONLY(XRS_RX_256_511_L, \"rx_256_511\"),\n\tXRS700X_MIB_ETHTOOL_ONLY(XRS_RX_512_1023_L, \"rx_512_1023\"),\n\tXRS700X_MIB_ETHTOOL_ONLY(XRS_RX_1024_1536_L, \"rx_1024_1536\"),\n\tXRS700X_MIB_ETHTOOL_ONLY(XRS_RX_HSR_PRP_L, \"rx_hsr_prp\"),\n\tXRS700X_MIB_ETHTOOL_ONLY(XRS_RX_WRONGLAN_L, \"rx_wronglan\"),\n\tXRS700X_MIB_ETHTOOL_ONLY(XRS_RX_DUPLICATE_L, \"rx_duplicate\"),\n\tXRS700X_MIB(XRS_TX_OCTETS_L, \"tx_octets\", tx_bytes),\n\tXRS700X_MIB(XRS_TX_UNICAST_L, \"tx_unicast\", tx_packets),\n\tXRS700X_MIB(XRS_TX_BROADCAST_L, \"tx_broadcast\", tx_packets),\n\tXRS700X_MIB(XRS_TX_MULTICAST_L, \"tx_multicast\", tx_packets),\n\tXRS700X_MIB_ETHTOOL_ONLY(XRS_TX_HSR_PRP_L, \"tx_hsr_prp\"),\n\tXRS700X_MIB(XRS_PRIQ_DROP_L, \"priq_drop\", tx_dropped),\n\tXRS700X_MIB(XRS_EARLY_DROP_L, \"early_drop\", tx_dropped),\n};\n\nstatic const u8 eth_hsrsup_addr[ETH_ALEN] = {\n\t0x01, 0x15, 0x4e, 0x00, 0x01, 0x00};\n\nstatic void xrs700x_get_strings(struct dsa_switch *ds, int port,\n\t\t\t\tu32 stringset, u8 *data)\n{\n\tint i;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(xrs700x_mibs); i++) {\n\t\tstrscpy(data, xrs700x_mibs[i].name, ETH_GSTRING_LEN);\n\t\tdata += ETH_GSTRING_LEN;\n\t}\n}\n\nstatic int xrs700x_get_sset_count(struct dsa_switch *ds, int port, int sset)\n{\n\tif (sset != ETH_SS_STATS)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ARRAY_SIZE(xrs700x_mibs);\n}\n\nstatic void xrs700x_read_port_counters(struct xrs700x *priv, int port)\n{\n\tstruct xrs700x_port *p = &priv->ports[port];\n\tstruct rtnl_link_stats64 stats;\n\tunsigned long flags;\n\tint i;\n\n\tmemset(&stats, 0, sizeof(stats));\n\n\tmutex_lock(&p->mib_mutex);\n\n\t \n\tregmap_write(priv->regmap, XRS_CNT_CTRL(port), 1);\n\n\tfor (i = 0; i < ARRAY_SIZE(xrs700x_mibs); i++) {\n\t\tunsigned int high = 0, low = 0, reg;\n\n\t\treg = xrs700x_mibs[i].offset + XRS_PORT_OFFSET * port;\n\t\tregmap_read(priv->regmap, reg, &low);\n\t\tregmap_read(priv->regmap, reg + 2, &high);\n\n\t\tp->mib_data[i] += (high << 16) | low;\n\n\t\tif (xrs700x_mibs[i].stats64_offset >= 0) {\n\t\t\tu8 *s = (u8 *)&stats + xrs700x_mibs[i].stats64_offset;\n\t\t\t*(u64 *)s += p->mib_data[i];\n\t\t}\n\t}\n\n\t \n\tstats.rx_packets += stats.multicast;\n\n\tflags = u64_stats_update_begin_irqsave(&p->syncp);\n\tp->stats64 = stats;\n\tu64_stats_update_end_irqrestore(&p->syncp, flags);\n\n\tmutex_unlock(&p->mib_mutex);\n}\n\nstatic void xrs700x_mib_work(struct work_struct *work)\n{\n\tstruct xrs700x *priv = container_of(work, struct xrs700x,\n\t\t\t\t\t    mib_work.work);\n\tint i;\n\n\tfor (i = 0; i < priv->ds->num_ports; i++)\n\t\txrs700x_read_port_counters(priv, i);\n\n\tschedule_delayed_work(&priv->mib_work, XRS700X_MIB_INTERVAL);\n}\n\nstatic void xrs700x_get_ethtool_stats(struct dsa_switch *ds, int port,\n\t\t\t\t      u64 *data)\n{\n\tstruct xrs700x *priv = ds->priv;\n\tstruct xrs700x_port *p = &priv->ports[port];\n\n\txrs700x_read_port_counters(priv, port);\n\n\tmutex_lock(&p->mib_mutex);\n\tmemcpy(data, p->mib_data, sizeof(*data) * ARRAY_SIZE(xrs700x_mibs));\n\tmutex_unlock(&p->mib_mutex);\n}\n\nstatic void xrs700x_get_stats64(struct dsa_switch *ds, int port,\n\t\t\t\tstruct rtnl_link_stats64 *s)\n{\n\tstruct xrs700x *priv = ds->priv;\n\tstruct xrs700x_port *p = &priv->ports[port];\n\tunsigned int start;\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin(&p->syncp);\n\t\t*s = p->stats64;\n\t} while (u64_stats_fetch_retry(&p->syncp, start));\n}\n\nstatic int xrs700x_setup_regmap_range(struct xrs700x *priv)\n{\n\tstruct xrs700x_regfield regfields[] = {\n\t\t{\n\t\t\t.rf = REG_FIELD_ID(XRS_PORT_STATE(0), 0, 1,\n\t\t\t\t\t   priv->ds->num_ports,\n\t\t\t\t\t   XRS_PORT_OFFSET),\n\t\t\t.rmf = &priv->ps_forward\n\t\t},\n\t\t{\n\t\t\t.rf = REG_FIELD_ID(XRS_PORT_STATE(0), 2, 3,\n\t\t\t\t\t   priv->ds->num_ports,\n\t\t\t\t\t   XRS_PORT_OFFSET),\n\t\t\t.rmf = &priv->ps_management\n\t\t},\n\t\t{\n\t\t\t.rf = REG_FIELD_ID(XRS_PORT_STATE(0), 4, 9,\n\t\t\t\t\t   priv->ds->num_ports,\n\t\t\t\t\t   XRS_PORT_OFFSET),\n\t\t\t.rmf = &priv->ps_sel_speed\n\t\t},\n\t\t{\n\t\t\t.rf = REG_FIELD_ID(XRS_PORT_STATE(0), 10, 11,\n\t\t\t\t\t   priv->ds->num_ports,\n\t\t\t\t\t   XRS_PORT_OFFSET),\n\t\t\t.rmf = &priv->ps_cur_speed\n\t\t}\n\t};\n\tint i = 0;\n\n\tfor (; i < ARRAY_SIZE(regfields); i++) {\n\t\t*regfields[i].rmf = devm_regmap_field_alloc(priv->dev,\n\t\t\t\t\t\t\t    priv->regmap,\n\t\t\t\t\t\t\t    regfields[i].rf);\n\t\tif (IS_ERR(*regfields[i].rmf))\n\t\t\treturn PTR_ERR(*regfields[i].rmf);\n\t}\n\n\treturn 0;\n}\n\nstatic enum dsa_tag_protocol xrs700x_get_tag_protocol(struct dsa_switch *ds,\n\t\t\t\t\t\t      int port,\n\t\t\t\t\t\t      enum dsa_tag_protocol m)\n{\n\treturn DSA_TAG_PROTO_XRS700X;\n}\n\nstatic int xrs700x_reset(struct dsa_switch *ds)\n{\n\tstruct xrs700x *priv = ds->priv;\n\tunsigned int val;\n\tint ret;\n\n\tret = regmap_write(priv->regmap, XRS_GENERAL, XRS_GENERAL_RESET);\n\tif (ret)\n\t\tgoto error;\n\n\tret = regmap_read_poll_timeout(priv->regmap, XRS_GENERAL,\n\t\t\t\t       val, !(val & XRS_GENERAL_RESET),\n\t\t\t\t       10, 1000);\nerror:\n\tif (ret) {\n\t\tdev_err_ratelimited(priv->dev, \"error resetting switch: %d\\n\",\n\t\t\t\t    ret);\n\t}\n\n\treturn ret;\n}\n\nstatic void xrs700x_port_stp_state_set(struct dsa_switch *ds, int port,\n\t\t\t\t       u8 state)\n{\n\tstruct xrs700x *priv = ds->priv;\n\tunsigned int bpdus = 1;\n\tunsigned int val;\n\n\tswitch (state) {\n\tcase BR_STATE_DISABLED:\n\t\tbpdus = 0;\n\t\tfallthrough;\n\tcase BR_STATE_BLOCKING:\n\tcase BR_STATE_LISTENING:\n\t\tval = XRS_PORT_DISABLED;\n\t\tbreak;\n\tcase BR_STATE_LEARNING:\n\t\tval = XRS_PORT_LEARNING;\n\t\tbreak;\n\tcase BR_STATE_FORWARDING:\n\t\tval = XRS_PORT_FORWARDING;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(ds->dev, \"invalid STP state: %d\\n\", state);\n\t\treturn;\n\t}\n\n\tregmap_fields_write(priv->ps_forward, port, val);\n\n\t \n\tregmap_update_bits(priv->regmap, XRS_ETH_ADDR_CFG(port, 0), 1, bpdus);\n\n\tdev_dbg_ratelimited(priv->dev, \"%s - port: %d, state: %u, val: 0x%x\\n\",\n\t\t\t    __func__, port, state, val);\n}\n\n \nstatic int xrs700x_port_add_bpdu_ipf(struct dsa_switch *ds, int port)\n{\n\tstruct xrs700x *priv = ds->priv;\n\tunsigned int val = 0;\n\tint i = 0;\n\tint ret;\n\n\t \n\tret = regmap_write(priv->regmap, XRS_ETH_ADDR_CFG(port, 0), 48 << 2);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < sizeof(eth_stp_addr); i += 2) {\n\t\tret = regmap_write(priv->regmap, XRS_ETH_ADDR_0(port, 0) + i,\n\t\t\t\t   eth_stp_addr[i] |\n\t\t\t\t   (eth_stp_addr[i + 1] << 8));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < ds->num_ports; i++) {\n\t\tif (dsa_is_cpu_port(ds, i))\n\t\t\tval |= BIT(i);\n\t}\n\n\tret = regmap_write(priv->regmap, XRS_ETH_ADDR_FWD_MIRROR(port, 0), val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(priv->regmap, XRS_ETH_ADDR_FWD_ALLOW(port, 0), 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic int xrs700x_port_add_hsrsup_ipf(struct dsa_switch *ds, int port,\n\t\t\t\t       int fwdport)\n{\n\tstruct xrs700x *priv = ds->priv;\n\tunsigned int val = 0;\n\tint i = 0;\n\tint ret;\n\n\t \n\tret = regmap_write(priv->regmap, XRS_ETH_ADDR_CFG(port, 1), 40 << 2);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < sizeof(eth_hsrsup_addr); i += 2) {\n\t\tret = regmap_write(priv->regmap, XRS_ETH_ADDR_0(port, 1) + i,\n\t\t\t\t   eth_hsrsup_addr[i] |\n\t\t\t\t   (eth_hsrsup_addr[i + 1] << 8));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < ds->num_ports; i++) {\n\t\tif (dsa_is_cpu_port(ds, i))\n\t\t\tval |= BIT(i);\n\t}\n\n\tret = regmap_write(priv->regmap, XRS_ETH_ADDR_FWD_MIRROR(port, 1), val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (fwdport >= 0)\n\t\tval |= BIT(fwdport);\n\n\t \n\tret = regmap_write(priv->regmap, XRS_ETH_ADDR_FWD_ALLOW(port, 1), val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int xrs700x_port_setup(struct dsa_switch *ds, int port)\n{\n\tbool cpu_port = dsa_is_cpu_port(ds, port);\n\tstruct xrs700x *priv = ds->priv;\n\tunsigned int val = 0;\n\tint ret, i;\n\n\txrs700x_port_stp_state_set(ds, port, BR_STATE_DISABLED);\n\n\t \n\tfor (i = 0; i < ds->num_ports; i++) {\n\t\tif (!dsa_is_cpu_port(ds, i))\n\t\t\tval |= BIT(i);\n\t}\n\n\t \n\tret = regmap_write(priv->regmap, XRS_PORT_FWD_MASK(port), val);\n\tif (ret)\n\t\treturn ret;\n\n\tval = cpu_port ? XRS_PORT_MODE_MANAGEMENT : XRS_PORT_MODE_NORMAL;\n\tret = regmap_fields_write(priv->ps_management, port, val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!cpu_port) {\n\t\tret = xrs700x_port_add_bpdu_ipf(ds, port);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int xrs700x_setup(struct dsa_switch *ds)\n{\n\tstruct xrs700x *priv = ds->priv;\n\tint ret, i;\n\n\tret = xrs700x_reset(ds);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < ds->num_ports; i++) {\n\t\tret = xrs700x_port_setup(ds, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tschedule_delayed_work(&priv->mib_work, XRS700X_MIB_INTERVAL);\n\n\treturn 0;\n}\n\nstatic void xrs700x_teardown(struct dsa_switch *ds)\n{\n\tstruct xrs700x *priv = ds->priv;\n\n\tcancel_delayed_work_sync(&priv->mib_work);\n}\n\nstatic void xrs700x_phylink_get_caps(struct dsa_switch *ds, int port,\n\t\t\t\t     struct phylink_config *config)\n{\n\tswitch (port) {\n\tcase 0:\n\t\t__set_bit(PHY_INTERFACE_MODE_RMII,\n\t\t\t  config->supported_interfaces);\n\t\tconfig->mac_capabilities = MAC_10FD | MAC_100FD;\n\t\tbreak;\n\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\t\tphy_interface_set_rgmii(config->supported_interfaces);\n\t\tconfig->mac_capabilities = MAC_10FD | MAC_100FD | MAC_1000FD;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(ds->dev, \"Unsupported port: %i\\n\", port);\n\t\tbreak;\n\t}\n}\n\nstatic void xrs700x_mac_link_up(struct dsa_switch *ds, int port,\n\t\t\t\tunsigned int mode, phy_interface_t interface,\n\t\t\t\tstruct phy_device *phydev,\n\t\t\t\tint speed, int duplex,\n\t\t\t\tbool tx_pause, bool rx_pause)\n{\n\tstruct xrs700x *priv = ds->priv;\n\tunsigned int val;\n\n\tswitch (speed) {\n\tcase SPEED_1000:\n\t\tval = XRS_PORT_SPEED_1000;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tval = XRS_PORT_SPEED_100;\n\t\tbreak;\n\tcase SPEED_10:\n\t\tval = XRS_PORT_SPEED_10;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tregmap_fields_write(priv->ps_sel_speed, port, val);\n\n\tdev_dbg_ratelimited(priv->dev, \"%s: port: %d mode: %u speed: %u\\n\",\n\t\t\t    __func__, port, mode, speed);\n}\n\nstatic int xrs700x_bridge_common(struct dsa_switch *ds, int port,\n\t\t\t\t struct dsa_bridge bridge, bool join)\n{\n\tunsigned int i, cpu_mask = 0, mask = 0;\n\tstruct xrs700x *priv = ds->priv;\n\tint ret;\n\n\tfor (i = 0; i < ds->num_ports; i++) {\n\t\tif (dsa_is_cpu_port(ds, i))\n\t\t\tcontinue;\n\n\t\tcpu_mask |= BIT(i);\n\n\t\tif (dsa_port_offloads_bridge(dsa_to_port(ds, i), &bridge))\n\t\t\tcontinue;\n\n\t\tmask |= BIT(i);\n\t}\n\n\tfor (i = 0; i < ds->num_ports; i++) {\n\t\tif (!dsa_port_offloads_bridge(dsa_to_port(ds, i), &bridge))\n\t\t\tcontinue;\n\n\t\t \n\t\tret = regmap_write(priv->regmap, XRS_PORT_FWD_MASK(i), mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!join) {\n\t\tret = regmap_write(priv->regmap, XRS_PORT_FWD_MASK(port),\n\t\t\t\t   cpu_mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int xrs700x_bridge_join(struct dsa_switch *ds, int port,\n\t\t\t       struct dsa_bridge bridge, bool *tx_fwd_offload,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\treturn xrs700x_bridge_common(ds, port, bridge, true);\n}\n\nstatic void xrs700x_bridge_leave(struct dsa_switch *ds, int port,\n\t\t\t\t struct dsa_bridge bridge)\n{\n\txrs700x_bridge_common(ds, port, bridge, false);\n}\n\nstatic int xrs700x_hsr_join(struct dsa_switch *ds, int port,\n\t\t\t    struct net_device *hsr)\n{\n\tunsigned int val = XRS_HSR_CFG_HSR_PRP;\n\tstruct dsa_port *partner = NULL, *dp;\n\tstruct xrs700x *priv = ds->priv;\n\tstruct net_device *slave;\n\tint ret, i, hsr_pair[2];\n\tenum hsr_version ver;\n\tbool fwd = false;\n\n\tret = hsr_get_version(hsr, &ver);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (port != 1 && port != 2)\n\t\treturn -EOPNOTSUPP;\n\n\tif (ver == HSR_V1)\n\t\tval |= XRS_HSR_CFG_HSR;\n\telse if (ver == PRP_V1)\n\t\tval |= XRS_HSR_CFG_PRP;\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\tdsa_hsr_foreach_port(dp, ds, hsr) {\n\t\tif (dp->index != port) {\n\t\t\tpartner = dp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!partner)\n\t\treturn 0;\n\n\tregmap_fields_write(priv->ps_forward, partner->index,\n\t\t\t    XRS_PORT_DISABLED);\n\tregmap_fields_write(priv->ps_forward, port, XRS_PORT_DISABLED);\n\n\tregmap_write(priv->regmap, XRS_HSR_CFG(partner->index),\n\t\t     val | XRS_HSR_CFG_LANID_A);\n\tregmap_write(priv->regmap, XRS_HSR_CFG(port),\n\t\t     val | XRS_HSR_CFG_LANID_B);\n\n\t \n\tval = GENMASK(ds->num_ports - 1, 0);\n\tif (ver == HSR_V1) {\n\t\tval &= ~BIT(partner->index);\n\t\tval &= ~BIT(port);\n\t\tfwd = true;\n\t}\n\tval &= ~BIT(dsa_upstream_port(ds, port));\n\tregmap_write(priv->regmap, XRS_PORT_FWD_MASK(partner->index), val);\n\tregmap_write(priv->regmap, XRS_PORT_FWD_MASK(port), val);\n\n\tregmap_fields_write(priv->ps_forward, partner->index,\n\t\t\t    XRS_PORT_FORWARDING);\n\tregmap_fields_write(priv->ps_forward, port, XRS_PORT_FORWARDING);\n\n\t \n\tret = xrs700x_port_add_hsrsup_ipf(ds, partner->index, fwd ? port : -1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xrs700x_port_add_hsrsup_ipf(ds, port, fwd ? partner->index : -1);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_update_bits(priv->regmap,\n\t\t\t   XRS_ETH_ADDR_CFG(partner->index, 1), 1, 1);\n\tregmap_update_bits(priv->regmap, XRS_ETH_ADDR_CFG(port, 1), 1, 1);\n\n\thsr_pair[0] = port;\n\thsr_pair[1] = partner->index;\n\tfor (i = 0; i < ARRAY_SIZE(hsr_pair); i++) {\n\t\tslave = dsa_to_port(ds, hsr_pair[i])->slave;\n\t\tslave->features |= XRS7000X_SUPPORTED_HSR_FEATURES;\n\t}\n\n\treturn 0;\n}\n\nstatic int xrs700x_hsr_leave(struct dsa_switch *ds, int port,\n\t\t\t     struct net_device *hsr)\n{\n\tstruct dsa_port *partner = NULL, *dp;\n\tstruct xrs700x *priv = ds->priv;\n\tstruct net_device *slave;\n\tint i, hsr_pair[2];\n\tunsigned int val;\n\n\tdsa_hsr_foreach_port(dp, ds, hsr) {\n\t\tif (dp->index != port) {\n\t\t\tpartner = dp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!partner)\n\t\treturn 0;\n\n\tregmap_fields_write(priv->ps_forward, partner->index,\n\t\t\t    XRS_PORT_DISABLED);\n\tregmap_fields_write(priv->ps_forward, port, XRS_PORT_DISABLED);\n\n\tregmap_write(priv->regmap, XRS_HSR_CFG(partner->index), 0);\n\tregmap_write(priv->regmap, XRS_HSR_CFG(port), 0);\n\n\t \n\tval = GENMASK(ds->num_ports - 1, 0);\n\tval &= ~BIT(dsa_upstream_port(ds, port));\n\tregmap_write(priv->regmap, XRS_PORT_FWD_MASK(partner->index), val);\n\tregmap_write(priv->regmap, XRS_PORT_FWD_MASK(port), val);\n\n\tregmap_fields_write(priv->ps_forward, partner->index,\n\t\t\t    XRS_PORT_FORWARDING);\n\tregmap_fields_write(priv->ps_forward, port, XRS_PORT_FORWARDING);\n\n\t \n\tregmap_update_bits(priv->regmap,\n\t\t\t   XRS_ETH_ADDR_CFG(partner->index, 1), 1, 0);\n\tregmap_update_bits(priv->regmap, XRS_ETH_ADDR_CFG(port, 1), 1, 0);\n\n\thsr_pair[0] = port;\n\thsr_pair[1] = partner->index;\n\tfor (i = 0; i < ARRAY_SIZE(hsr_pair); i++) {\n\t\tslave = dsa_to_port(ds, hsr_pair[i])->slave;\n\t\tslave->features &= ~XRS7000X_SUPPORTED_HSR_FEATURES;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dsa_switch_ops xrs700x_ops = {\n\t.get_tag_protocol\t= xrs700x_get_tag_protocol,\n\t.setup\t\t\t= xrs700x_setup,\n\t.teardown\t\t= xrs700x_teardown,\n\t.port_stp_state_set\t= xrs700x_port_stp_state_set,\n\t.phylink_get_caps\t= xrs700x_phylink_get_caps,\n\t.phylink_mac_link_up\t= xrs700x_mac_link_up,\n\t.get_strings\t\t= xrs700x_get_strings,\n\t.get_sset_count\t\t= xrs700x_get_sset_count,\n\t.get_ethtool_stats\t= xrs700x_get_ethtool_stats,\n\t.get_stats64\t\t= xrs700x_get_stats64,\n\t.port_bridge_join\t= xrs700x_bridge_join,\n\t.port_bridge_leave\t= xrs700x_bridge_leave,\n\t.port_hsr_join\t\t= xrs700x_hsr_join,\n\t.port_hsr_leave\t\t= xrs700x_hsr_leave,\n};\n\nstatic int xrs700x_detect(struct xrs700x *priv)\n{\n\tconst struct xrs700x_info *info;\n\tunsigned int id;\n\tint ret;\n\n\tret = regmap_read(priv->regmap, XRS_DEV_ID0, &id);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"error %d while reading switch id.\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tinfo = of_device_get_match_data(priv->dev);\n\tif (!info)\n\t\treturn -EINVAL;\n\n\tif (info->id == id) {\n\t\tpriv->ds->num_ports = info->num_ports;\n\t\tdev_info(priv->dev, \"%s detected.\\n\", info->name);\n\t\treturn 0;\n\t}\n\n\tdev_err(priv->dev, \"expected switch id 0x%x but found 0x%x.\\n\",\n\t\tinfo->id, id);\n\n\treturn -ENODEV;\n}\n\nstruct xrs700x *xrs700x_switch_alloc(struct device *base, void *devpriv)\n{\n\tstruct dsa_switch *ds;\n\tstruct xrs700x *priv;\n\n\tds = devm_kzalloc(base, sizeof(*ds), GFP_KERNEL);\n\tif (!ds)\n\t\treturn NULL;\n\n\tds->dev = base;\n\n\tpriv = devm_kzalloc(base, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn NULL;\n\n\tINIT_DELAYED_WORK(&priv->mib_work, xrs700x_mib_work);\n\n\tds->ops = &xrs700x_ops;\n\tds->priv = priv;\n\tpriv->dev = base;\n\n\tpriv->ds = ds;\n\tpriv->priv = devpriv;\n\n\treturn priv;\n}\nEXPORT_SYMBOL(xrs700x_switch_alloc);\n\nstatic int xrs700x_alloc_port_mib(struct xrs700x *priv, int port)\n{\n\tstruct xrs700x_port *p = &priv->ports[port];\n\n\tp->mib_data = devm_kcalloc(priv->dev, ARRAY_SIZE(xrs700x_mibs),\n\t\t\t\t   sizeof(*p->mib_data), GFP_KERNEL);\n\tif (!p->mib_data)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&p->mib_mutex);\n\tu64_stats_init(&p->syncp);\n\n\treturn 0;\n}\n\nint xrs700x_switch_register(struct xrs700x *priv)\n{\n\tint ret;\n\tint i;\n\n\tret = xrs700x_detect(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xrs700x_setup_regmap_range(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->ports = devm_kcalloc(priv->dev, priv->ds->num_ports,\n\t\t\t\t   sizeof(*priv->ports), GFP_KERNEL);\n\tif (!priv->ports)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < priv->ds->num_ports; i++) {\n\t\tret = xrs700x_alloc_port_mib(priv, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn dsa_register_switch(priv->ds);\n}\nEXPORT_SYMBOL(xrs700x_switch_register);\n\nvoid xrs700x_switch_remove(struct xrs700x *priv)\n{\n\tdsa_unregister_switch(priv->ds);\n}\nEXPORT_SYMBOL(xrs700x_switch_remove);\n\nvoid xrs700x_switch_shutdown(struct xrs700x *priv)\n{\n\tdsa_switch_shutdown(priv->ds);\n}\nEXPORT_SYMBOL(xrs700x_switch_shutdown);\n\nMODULE_AUTHOR(\"George McCollister <george.mccollister@gmail.com>\");\nMODULE_DESCRIPTION(\"Arrow SpeedChips XRS700x DSA driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}