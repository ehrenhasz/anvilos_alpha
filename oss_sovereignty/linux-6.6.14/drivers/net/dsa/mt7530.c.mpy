{
  "module_name": "mt7530.c",
  "hash_id": "f5e81655a6307ada388db2aa1c66a468279f511f07fa35507f77ad4eb95dba0b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/mt7530.c",
  "human_readable_source": "\n \n#include <linux/etherdevice.h>\n#include <linux/if_bridge.h>\n#include <linux/iopoll.h>\n#include <linux/mdio.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/of_irq.h>\n#include <linux/of_mdio.h>\n#include <linux/of_net.h>\n#include <linux/of_platform.h>\n#include <linux/phylink.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/driver.h>\n#include <net/dsa.h>\n\n#include \"mt7530.h\"\n\nstatic struct mt753x_pcs *pcs_to_mt753x_pcs(struct phylink_pcs *pcs)\n{\n\treturn container_of(pcs, struct mt753x_pcs, pcs);\n}\n\n \nstatic const struct mt7530_mib_desc mt7530_mib[] = {\n\tMIB_DESC(1, 0x00, \"TxDrop\"),\n\tMIB_DESC(1, 0x04, \"TxCrcErr\"),\n\tMIB_DESC(1, 0x08, \"TxUnicast\"),\n\tMIB_DESC(1, 0x0c, \"TxMulticast\"),\n\tMIB_DESC(1, 0x10, \"TxBroadcast\"),\n\tMIB_DESC(1, 0x14, \"TxCollision\"),\n\tMIB_DESC(1, 0x18, \"TxSingleCollision\"),\n\tMIB_DESC(1, 0x1c, \"TxMultipleCollision\"),\n\tMIB_DESC(1, 0x20, \"TxDeferred\"),\n\tMIB_DESC(1, 0x24, \"TxLateCollision\"),\n\tMIB_DESC(1, 0x28, \"TxExcessiveCollistion\"),\n\tMIB_DESC(1, 0x2c, \"TxPause\"),\n\tMIB_DESC(1, 0x30, \"TxPktSz64\"),\n\tMIB_DESC(1, 0x34, \"TxPktSz65To127\"),\n\tMIB_DESC(1, 0x38, \"TxPktSz128To255\"),\n\tMIB_DESC(1, 0x3c, \"TxPktSz256To511\"),\n\tMIB_DESC(1, 0x40, \"TxPktSz512To1023\"),\n\tMIB_DESC(1, 0x44, \"Tx1024ToMax\"),\n\tMIB_DESC(2, 0x48, \"TxBytes\"),\n\tMIB_DESC(1, 0x60, \"RxDrop\"),\n\tMIB_DESC(1, 0x64, \"RxFiltering\"),\n\tMIB_DESC(1, 0x68, \"RxUnicast\"),\n\tMIB_DESC(1, 0x6c, \"RxMulticast\"),\n\tMIB_DESC(1, 0x70, \"RxBroadcast\"),\n\tMIB_DESC(1, 0x74, \"RxAlignErr\"),\n\tMIB_DESC(1, 0x78, \"RxCrcErr\"),\n\tMIB_DESC(1, 0x7c, \"RxUnderSizeErr\"),\n\tMIB_DESC(1, 0x80, \"RxFragErr\"),\n\tMIB_DESC(1, 0x84, \"RxOverSzErr\"),\n\tMIB_DESC(1, 0x88, \"RxJabberErr\"),\n\tMIB_DESC(1, 0x8c, \"RxPause\"),\n\tMIB_DESC(1, 0x90, \"RxPktSz64\"),\n\tMIB_DESC(1, 0x94, \"RxPktSz65To127\"),\n\tMIB_DESC(1, 0x98, \"RxPktSz128To255\"),\n\tMIB_DESC(1, 0x9c, \"RxPktSz256To511\"),\n\tMIB_DESC(1, 0xa0, \"RxPktSz512To1023\"),\n\tMIB_DESC(1, 0xa4, \"RxPktSz1024ToMax\"),\n\tMIB_DESC(2, 0xa8, \"RxBytes\"),\n\tMIB_DESC(1, 0xb0, \"RxCtrlDrop\"),\n\tMIB_DESC(1, 0xb4, \"RxIngressDrop\"),\n\tMIB_DESC(1, 0xb8, \"RxArlDrop\"),\n};\n\n \nstatic int\ncore_read_mmd_indirect(struct mt7530_priv *priv, int prtad, int devad)\n{\n\tstruct mii_bus *bus = priv->bus;\n\tint value, ret;\n\n\t \n\tret = bus->write(bus, 0, MII_MMD_CTRL, devad);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tret = bus->write(bus, 0, MII_MMD_DATA, prtad);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tret = bus->write(bus, 0, MII_MMD_CTRL, (devad | MII_MMD_CTRL_NOINCR));\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tvalue = bus->read(bus, 0, MII_MMD_DATA);\n\n\treturn value;\nerr:\n\tdev_err(&bus->dev,  \"failed to read mmd register\\n\");\n\n\treturn ret;\n}\n\nstatic int\ncore_write_mmd_indirect(struct mt7530_priv *priv, int prtad,\n\t\t\tint devad, u32 data)\n{\n\tstruct mii_bus *bus = priv->bus;\n\tint ret;\n\n\t \n\tret = bus->write(bus, 0, MII_MMD_CTRL, devad);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tret = bus->write(bus, 0, MII_MMD_DATA, prtad);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tret = bus->write(bus, 0, MII_MMD_CTRL, (devad | MII_MMD_CTRL_NOINCR));\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tret = bus->write(bus, 0, MII_MMD_DATA, data);\nerr:\n\tif (ret < 0)\n\t\tdev_err(&bus->dev,\n\t\t\t\"failed to write mmd register\\n\");\n\treturn ret;\n}\n\nstatic void\nmt7530_mutex_lock(struct mt7530_priv *priv)\n{\n\tif (priv->bus)\n\t\tmutex_lock_nested(&priv->bus->mdio_lock, MDIO_MUTEX_NESTED);\n}\n\nstatic void\nmt7530_mutex_unlock(struct mt7530_priv *priv)\n{\n\tif (priv->bus)\n\t\tmutex_unlock(&priv->bus->mdio_lock);\n}\n\nstatic void\ncore_write(struct mt7530_priv *priv, u32 reg, u32 val)\n{\n\tmt7530_mutex_lock(priv);\n\n\tcore_write_mmd_indirect(priv, reg, MDIO_MMD_VEND2, val);\n\n\tmt7530_mutex_unlock(priv);\n}\n\nstatic void\ncore_rmw(struct mt7530_priv *priv, u32 reg, u32 mask, u32 set)\n{\n\tu32 val;\n\n\tmt7530_mutex_lock(priv);\n\n\tval = core_read_mmd_indirect(priv, reg, MDIO_MMD_VEND2);\n\tval &= ~mask;\n\tval |= set;\n\tcore_write_mmd_indirect(priv, reg, MDIO_MMD_VEND2, val);\n\n\tmt7530_mutex_unlock(priv);\n}\n\nstatic void\ncore_set(struct mt7530_priv *priv, u32 reg, u32 val)\n{\n\tcore_rmw(priv, reg, 0, val);\n}\n\nstatic void\ncore_clear(struct mt7530_priv *priv, u32 reg, u32 val)\n{\n\tcore_rmw(priv, reg, val, 0);\n}\n\nstatic int\nmt7530_mii_write(struct mt7530_priv *priv, u32 reg, u32 val)\n{\n\tint ret;\n\n\tret = regmap_write(priv->regmap, reg, val);\n\n\tif (ret < 0)\n\t\tdev_err(priv->dev,\n\t\t\t\"failed to write mt7530 register\\n\");\n\n\treturn ret;\n}\n\nstatic u32\nmt7530_mii_read(struct mt7530_priv *priv, u32 reg)\n{\n\tint ret;\n\tu32 val;\n\n\tret = regmap_read(priv->regmap, reg, &val);\n\tif (ret) {\n\t\tWARN_ON_ONCE(1);\n\t\tdev_err(priv->dev,\n\t\t\t\"failed to read mt7530 register\\n\");\n\t\treturn 0;\n\t}\n\n\treturn val;\n}\n\nstatic void\nmt7530_write(struct mt7530_priv *priv, u32 reg, u32 val)\n{\n\tmt7530_mutex_lock(priv);\n\n\tmt7530_mii_write(priv, reg, val);\n\n\tmt7530_mutex_unlock(priv);\n}\n\nstatic u32\n_mt7530_unlocked_read(struct mt7530_dummy_poll *p)\n{\n\treturn mt7530_mii_read(p->priv, p->reg);\n}\n\nstatic u32\n_mt7530_read(struct mt7530_dummy_poll *p)\n{\n\tu32 val;\n\n\tmt7530_mutex_lock(p->priv);\n\n\tval = mt7530_mii_read(p->priv, p->reg);\n\n\tmt7530_mutex_unlock(p->priv);\n\n\treturn val;\n}\n\nstatic u32\nmt7530_read(struct mt7530_priv *priv, u32 reg)\n{\n\tstruct mt7530_dummy_poll p;\n\n\tINIT_MT7530_DUMMY_POLL(&p, priv, reg);\n\treturn _mt7530_read(&p);\n}\n\nstatic void\nmt7530_rmw(struct mt7530_priv *priv, u32 reg,\n\t   u32 mask, u32 set)\n{\n\tmt7530_mutex_lock(priv);\n\n\tregmap_update_bits(priv->regmap, reg, mask, set);\n\n\tmt7530_mutex_unlock(priv);\n}\n\nstatic void\nmt7530_set(struct mt7530_priv *priv, u32 reg, u32 val)\n{\n\tmt7530_rmw(priv, reg, val, val);\n}\n\nstatic void\nmt7530_clear(struct mt7530_priv *priv, u32 reg, u32 val)\n{\n\tmt7530_rmw(priv, reg, val, 0);\n}\n\nstatic int\nmt7530_fdb_cmd(struct mt7530_priv *priv, enum mt7530_fdb_cmd cmd, u32 *rsp)\n{\n\tu32 val;\n\tint ret;\n\tstruct mt7530_dummy_poll p;\n\n\t \n\tval = ATC_BUSY | ATC_MAT(0) | cmd;\n\tmt7530_write(priv, MT7530_ATC, val);\n\n\tINIT_MT7530_DUMMY_POLL(&p, priv, MT7530_ATC);\n\tret = readx_poll_timeout(_mt7530_read, &p, val,\n\t\t\t\t !(val & ATC_BUSY), 20, 20000);\n\tif (ret < 0) {\n\t\tdev_err(priv->dev, \"reset timeout\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tval = mt7530_read(priv, MT7530_ATC);\n\tif ((cmd == MT7530_FDB_READ) && (val & ATC_INVALID))\n\t\treturn -EINVAL;\n\n\tif (rsp)\n\t\t*rsp = val;\n\n\treturn 0;\n}\n\nstatic void\nmt7530_fdb_read(struct mt7530_priv *priv, struct mt7530_fdb *fdb)\n{\n\tu32 reg[3];\n\tint i;\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\treg[i] = mt7530_read(priv, MT7530_TSRA1 + (i * 4));\n\n\t\tdev_dbg(priv->dev, \"%s(%d) reg[%d]=0x%x\\n\",\n\t\t\t__func__, __LINE__, i, reg[i]);\n\t}\n\n\tfdb->vid = (reg[1] >> CVID) & CVID_MASK;\n\tfdb->aging = (reg[2] >> AGE_TIMER) & AGE_TIMER_MASK;\n\tfdb->port_mask = (reg[2] >> PORT_MAP) & PORT_MAP_MASK;\n\tfdb->mac[0] = (reg[0] >> MAC_BYTE_0) & MAC_BYTE_MASK;\n\tfdb->mac[1] = (reg[0] >> MAC_BYTE_1) & MAC_BYTE_MASK;\n\tfdb->mac[2] = (reg[0] >> MAC_BYTE_2) & MAC_BYTE_MASK;\n\tfdb->mac[3] = (reg[0] >> MAC_BYTE_3) & MAC_BYTE_MASK;\n\tfdb->mac[4] = (reg[1] >> MAC_BYTE_4) & MAC_BYTE_MASK;\n\tfdb->mac[5] = (reg[1] >> MAC_BYTE_5) & MAC_BYTE_MASK;\n\tfdb->noarp = ((reg[2] >> ENT_STATUS) & ENT_STATUS_MASK) == STATIC_ENT;\n}\n\nstatic void\nmt7530_fdb_write(struct mt7530_priv *priv, u16 vid,\n\t\t u8 port_mask, const u8 *mac,\n\t\t u8 aging, u8 type)\n{\n\tu32 reg[3] = { 0 };\n\tint i;\n\n\treg[1] |= vid & CVID_MASK;\n\treg[1] |= ATA2_IVL;\n\treg[1] |= ATA2_FID(FID_BRIDGED);\n\treg[2] |= (aging & AGE_TIMER_MASK) << AGE_TIMER;\n\treg[2] |= (port_mask & PORT_MAP_MASK) << PORT_MAP;\n\t \n\treg[2] |= (type & ENT_STATUS_MASK) << ENT_STATUS;\n\treg[1] |= mac[5] << MAC_BYTE_5;\n\treg[1] |= mac[4] << MAC_BYTE_4;\n\treg[0] |= mac[3] << MAC_BYTE_3;\n\treg[0] |= mac[2] << MAC_BYTE_2;\n\treg[0] |= mac[1] << MAC_BYTE_1;\n\treg[0] |= mac[0] << MAC_BYTE_0;\n\n\t \n\tfor (i = 0; i < 3; i++)\n\t\tmt7530_write(priv, MT7530_ATA1 + (i * 4), reg[i]);\n}\n\n \nstatic void mt7530_pll_setup(struct mt7530_priv *priv)\n{\n\t \n\tcore_clear(priv, CORE_TRGMII_GSW_CLK_CG, REG_GSWCK_EN);\n\n\t \n\tcore_write(priv, CORE_GSWPLL_GRP1, 0);\n\n\t \n\tcore_write(priv, CORE_GSWPLL_GRP2,\n\t\t   RG_GSWPLL_POSDIV_500M(1) |\n\t\t   RG_GSWPLL_FBKDIV_500M(25));\n\n\t \n\tcore_write(priv, CORE_GSWPLL_GRP1,\n\t\t   RG_GSWPLL_EN_PRE |\n\t\t   RG_GSWPLL_POSDIV_200M(2) |\n\t\t   RG_GSWPLL_FBKDIV_200M(32));\n\n\tudelay(20);\n\n\t \n\tcore_set(priv, CORE_TRGMII_GSW_CLK_CG, REG_GSWCK_EN);\n}\n\n \nstatic struct dsa_port *\nmt753x_preferred_default_local_cpu_port(struct dsa_switch *ds)\n{\n\tstruct dsa_port *cpu_dp = dsa_to_port(ds, 6);\n\n\tif (dsa_port_is_cpu(cpu_dp))\n\t\treturn cpu_dp;\n\n\treturn NULL;\n}\n\n \nstatic int\nmt7530_pad_clk_setup(struct dsa_switch *ds, phy_interface_t interface)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\tu32 ncpo1, ssc_delta, trgint, xtal;\n\n\txtal = mt7530_read(priv, MT7530_MHWTRAP) & HWTRAP_XTAL_MASK;\n\n\tif (xtal == HWTRAP_XTAL_20MHZ) {\n\t\tdev_err(priv->dev,\n\t\t\t\"%s: MT7530 with a 20MHz XTAL is not supported!\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (interface) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\t\ttrgint = 0;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_TRGMII:\n\t\ttrgint = 1;\n\t\tif (xtal == HWTRAP_XTAL_25MHZ)\n\t\t\tssc_delta = 0x57;\n\t\telse\n\t\t\tssc_delta = 0x87;\n\t\tif (priv->id == ID_MT7621) {\n\t\t\t \n\t\t\tif (xtal == HWTRAP_XTAL_40MHZ)\n\t\t\t\tncpo1 = 0x0640;\n\t\t\tif (xtal == HWTRAP_XTAL_25MHZ)\n\t\t\t\tncpo1 = 0x0a00;\n\t\t} else {  \n\t\t\tif (xtal == HWTRAP_XTAL_40MHZ)\n\t\t\t\tncpo1 = 0x0c80;\n\t\t\tif (xtal == HWTRAP_XTAL_25MHZ)\n\t\t\t\tncpo1 = 0x1400;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(priv->dev, \"xMII interface %d not supported\\n\",\n\t\t\tinterface);\n\t\treturn -EINVAL;\n\t}\n\n\tmt7530_rmw(priv, MT7530_P6ECR, P6_INTF_MODE_MASK,\n\t\t   P6_INTF_MODE(trgint));\n\n\tif (trgint) {\n\t\t \n\t\tcore_clear(priv, CORE_TRGMII_GSW_CLK_CG, REG_TRGMIICK_EN);\n\n\t\t \n\t\tcore_write(priv, CORE_PLL_GROUP5, RG_LCDDS_PCW_NCPO1(ncpo1));\n\t\tcore_write(priv, CORE_PLL_GROUP6, RG_LCDDS_PCW_NCPO0(0));\n\t\tcore_write(priv, CORE_PLL_GROUP10, RG_LCDDS_SSC_DELTA(ssc_delta));\n\t\tcore_write(priv, CORE_PLL_GROUP11, RG_LCDDS_SSC_DELTA1(ssc_delta));\n\t\tcore_write(priv, CORE_PLL_GROUP4,\n\t\t\t   RG_SYSPLL_DDSFBK_EN | RG_SYSPLL_BIAS_EN |\n\t\t\t   RG_SYSPLL_BIAS_LPF_EN);\n\t\tcore_write(priv, CORE_PLL_GROUP2,\n\t\t\t   RG_SYSPLL_EN_NORMAL | RG_SYSPLL_VODEN |\n\t\t\t   RG_SYSPLL_POSDIV(1));\n\t\tcore_write(priv, CORE_PLL_GROUP7,\n\t\t\t   RG_LCDDS_PCW_NCPO_CHG | RG_LCCDS_C(3) |\n\t\t\t   RG_LCDDS_PWDB | RG_LCDDS_ISO_EN);\n\n\t\t \n\t\tcore_set(priv, CORE_TRGMII_GSW_CLK_CG, REG_TRGMIICK_EN);\n\t}\n\n\treturn 0;\n}\n\nstatic bool mt7531_dual_sgmii_supported(struct mt7530_priv *priv)\n{\n\tu32 val;\n\n\tval = mt7530_read(priv, MT7531_TOP_SIG_SR);\n\n\treturn (val & PAD_DUAL_SGMII_EN) != 0;\n}\n\nstatic int\nmt7531_pad_setup(struct dsa_switch *ds, phy_interface_t interface)\n{\n\treturn 0;\n}\n\nstatic void\nmt7531_pll_setup(struct mt7530_priv *priv)\n{\n\tu32 top_sig;\n\tu32 hwstrap;\n\tu32 xtal;\n\tu32 val;\n\n\tif (mt7531_dual_sgmii_supported(priv))\n\t\treturn;\n\n\tval = mt7530_read(priv, MT7531_CREV);\n\ttop_sig = mt7530_read(priv, MT7531_TOP_SIG_SR);\n\thwstrap = mt7530_read(priv, MT7531_HWTRAP);\n\tif ((val & CHIP_REV_M) > 0)\n\t\txtal = (top_sig & PAD_MCM_SMI_EN) ? HWTRAP_XTAL_FSEL_40MHZ :\n\t\t\t\t\t\t    HWTRAP_XTAL_FSEL_25MHZ;\n\telse\n\t\txtal = hwstrap & HWTRAP_XTAL_FSEL_MASK;\n\n\t \n\tval = mt7530_read(priv, MT7531_PLLGP_EN);\n\tval &= ~EN_COREPLL;\n\tmt7530_write(priv, MT7531_PLLGP_EN, val);\n\n\t \n\tval = mt7530_read(priv, MT7531_PLLGP_EN);\n\tval |= SW_CLKSW;\n\tmt7530_write(priv, MT7531_PLLGP_EN, val);\n\n\tval = mt7530_read(priv, MT7531_PLLGP_CR0);\n\tval &= ~RG_COREPLL_EN;\n\tmt7530_write(priv, MT7531_PLLGP_CR0, val);\n\n\t \n\tval = mt7530_read(priv, MT7531_PLLGP_EN);\n\tval |= SW_PLLGP;\n\tmt7530_write(priv, MT7531_PLLGP_EN, val);\n\n\t \n\tval = mt7530_read(priv, MT7531_PLLGP_CR0);\n\tval &= ~RG_COREPLL_POSDIV_M;\n\tval |= 2 << RG_COREPLL_POSDIV_S;\n\tmt7530_write(priv, MT7531_PLLGP_CR0, val);\n\tusleep_range(25, 35);\n\n\tswitch (xtal) {\n\tcase HWTRAP_XTAL_FSEL_25MHZ:\n\t\tval = mt7530_read(priv, MT7531_PLLGP_CR0);\n\t\tval &= ~RG_COREPLL_SDM_PCW_M;\n\t\tval |= 0x140000 << RG_COREPLL_SDM_PCW_S;\n\t\tmt7530_write(priv, MT7531_PLLGP_CR0, val);\n\t\tbreak;\n\tcase HWTRAP_XTAL_FSEL_40MHZ:\n\t\tval = mt7530_read(priv, MT7531_PLLGP_CR0);\n\t\tval &= ~RG_COREPLL_SDM_PCW_M;\n\t\tval |= 0x190000 << RG_COREPLL_SDM_PCW_S;\n\t\tmt7530_write(priv, MT7531_PLLGP_CR0, val);\n\t\tbreak;\n\t}\n\n\t \n\tval = mt7530_read(priv, MT7531_PLLGP_CR0);\n\tval |= RG_COREPLL_SDM_PCW_CHG;\n\tmt7530_write(priv, MT7531_PLLGP_CR0, val);\n\t \n\tusleep_range(10, 20);\n\n\t \n\tval = mt7530_read(priv, MT7531_PLLGP_CR0);\n\tval &= ~RG_COREPLL_SDM_PCW_CHG;\n\tmt7530_write(priv, MT7531_PLLGP_CR0, val);\n\n\t \n\tmt7530_write(priv, MT7531_ANA_PLLGP_CR5, 0xad0000);\n\n\t \n\tmt7530_write(priv, MT7531_ANA_PLLGP_CR2, 0x4f40000);\n\n\t \n\tval = mt7530_read(priv, MT7531_PLLGP_CR0);\n\tval |= RG_COREPLL_EN;\n\tmt7530_write(priv, MT7531_PLLGP_CR0, val);\n\n\tval = mt7530_read(priv, MT7531_PLLGP_EN);\n\tval |= EN_COREPLL;\n\tmt7530_write(priv, MT7531_PLLGP_EN, val);\n\tusleep_range(25, 35);\n}\n\nstatic void\nmt7530_mib_reset(struct dsa_switch *ds)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\n\tmt7530_write(priv, MT7530_MIB_CCR, CCR_MIB_FLUSH);\n\tmt7530_write(priv, MT7530_MIB_CCR, CCR_MIB_ACTIVATE);\n}\n\nstatic int mt7530_phy_read_c22(struct mt7530_priv *priv, int port, int regnum)\n{\n\treturn mdiobus_read_nested(priv->bus, port, regnum);\n}\n\nstatic int mt7530_phy_write_c22(struct mt7530_priv *priv, int port, int regnum,\n\t\t\t\tu16 val)\n{\n\treturn mdiobus_write_nested(priv->bus, port, regnum, val);\n}\n\nstatic int mt7530_phy_read_c45(struct mt7530_priv *priv, int port,\n\t\t\t       int devad, int regnum)\n{\n\treturn mdiobus_c45_read_nested(priv->bus, port, devad, regnum);\n}\n\nstatic int mt7530_phy_write_c45(struct mt7530_priv *priv, int port, int devad,\n\t\t\t\tint regnum, u16 val)\n{\n\treturn mdiobus_c45_write_nested(priv->bus, port, devad, regnum, val);\n}\n\nstatic int\nmt7531_ind_c45_phy_read(struct mt7530_priv *priv, int port, int devad,\n\t\t\tint regnum)\n{\n\tstruct mt7530_dummy_poll p;\n\tu32 reg, val;\n\tint ret;\n\n\tINIT_MT7530_DUMMY_POLL(&p, priv, MT7531_PHY_IAC);\n\n\tmt7530_mutex_lock(priv);\n\n\tret = readx_poll_timeout(_mt7530_unlocked_read, &p, val,\n\t\t\t\t !(val & MT7531_PHY_ACS_ST), 20, 100000);\n\tif (ret < 0) {\n\t\tdev_err(priv->dev, \"poll timeout\\n\");\n\t\tgoto out;\n\t}\n\n\treg = MT7531_MDIO_CL45_ADDR | MT7531_MDIO_PHY_ADDR(port) |\n\t      MT7531_MDIO_DEV_ADDR(devad) | regnum;\n\tmt7530_mii_write(priv, MT7531_PHY_IAC, reg | MT7531_PHY_ACS_ST);\n\n\tret = readx_poll_timeout(_mt7530_unlocked_read, &p, val,\n\t\t\t\t !(val & MT7531_PHY_ACS_ST), 20, 100000);\n\tif (ret < 0) {\n\t\tdev_err(priv->dev, \"poll timeout\\n\");\n\t\tgoto out;\n\t}\n\n\treg = MT7531_MDIO_CL45_READ | MT7531_MDIO_PHY_ADDR(port) |\n\t      MT7531_MDIO_DEV_ADDR(devad);\n\tmt7530_mii_write(priv, MT7531_PHY_IAC, reg | MT7531_PHY_ACS_ST);\n\n\tret = readx_poll_timeout(_mt7530_unlocked_read, &p, val,\n\t\t\t\t !(val & MT7531_PHY_ACS_ST), 20, 100000);\n\tif (ret < 0) {\n\t\tdev_err(priv->dev, \"poll timeout\\n\");\n\t\tgoto out;\n\t}\n\n\tret = val & MT7531_MDIO_RW_DATA_MASK;\nout:\n\tmt7530_mutex_unlock(priv);\n\n\treturn ret;\n}\n\nstatic int\nmt7531_ind_c45_phy_write(struct mt7530_priv *priv, int port, int devad,\n\t\t\t int regnum, u16 data)\n{\n\tstruct mt7530_dummy_poll p;\n\tu32 val, reg;\n\tint ret;\n\n\tINIT_MT7530_DUMMY_POLL(&p, priv, MT7531_PHY_IAC);\n\n\tmt7530_mutex_lock(priv);\n\n\tret = readx_poll_timeout(_mt7530_unlocked_read, &p, val,\n\t\t\t\t !(val & MT7531_PHY_ACS_ST), 20, 100000);\n\tif (ret < 0) {\n\t\tdev_err(priv->dev, \"poll timeout\\n\");\n\t\tgoto out;\n\t}\n\n\treg = MT7531_MDIO_CL45_ADDR | MT7531_MDIO_PHY_ADDR(port) |\n\t      MT7531_MDIO_DEV_ADDR(devad) | regnum;\n\tmt7530_mii_write(priv, MT7531_PHY_IAC, reg | MT7531_PHY_ACS_ST);\n\n\tret = readx_poll_timeout(_mt7530_unlocked_read, &p, val,\n\t\t\t\t !(val & MT7531_PHY_ACS_ST), 20, 100000);\n\tif (ret < 0) {\n\t\tdev_err(priv->dev, \"poll timeout\\n\");\n\t\tgoto out;\n\t}\n\n\treg = MT7531_MDIO_CL45_WRITE | MT7531_MDIO_PHY_ADDR(port) |\n\t      MT7531_MDIO_DEV_ADDR(devad) | data;\n\tmt7530_mii_write(priv, MT7531_PHY_IAC, reg | MT7531_PHY_ACS_ST);\n\n\tret = readx_poll_timeout(_mt7530_unlocked_read, &p, val,\n\t\t\t\t !(val & MT7531_PHY_ACS_ST), 20, 100000);\n\tif (ret < 0) {\n\t\tdev_err(priv->dev, \"poll timeout\\n\");\n\t\tgoto out;\n\t}\n\nout:\n\tmt7530_mutex_unlock(priv);\n\n\treturn ret;\n}\n\nstatic int\nmt7531_ind_c22_phy_read(struct mt7530_priv *priv, int port, int regnum)\n{\n\tstruct mt7530_dummy_poll p;\n\tint ret;\n\tu32 val;\n\n\tINIT_MT7530_DUMMY_POLL(&p, priv, MT7531_PHY_IAC);\n\n\tmt7530_mutex_lock(priv);\n\n\tret = readx_poll_timeout(_mt7530_unlocked_read, &p, val,\n\t\t\t\t !(val & MT7531_PHY_ACS_ST), 20, 100000);\n\tif (ret < 0) {\n\t\tdev_err(priv->dev, \"poll timeout\\n\");\n\t\tgoto out;\n\t}\n\n\tval = MT7531_MDIO_CL22_READ | MT7531_MDIO_PHY_ADDR(port) |\n\t      MT7531_MDIO_REG_ADDR(regnum);\n\n\tmt7530_mii_write(priv, MT7531_PHY_IAC, val | MT7531_PHY_ACS_ST);\n\n\tret = readx_poll_timeout(_mt7530_unlocked_read, &p, val,\n\t\t\t\t !(val & MT7531_PHY_ACS_ST), 20, 100000);\n\tif (ret < 0) {\n\t\tdev_err(priv->dev, \"poll timeout\\n\");\n\t\tgoto out;\n\t}\n\n\tret = val & MT7531_MDIO_RW_DATA_MASK;\nout:\n\tmt7530_mutex_unlock(priv);\n\n\treturn ret;\n}\n\nstatic int\nmt7531_ind_c22_phy_write(struct mt7530_priv *priv, int port, int regnum,\n\t\t\t u16 data)\n{\n\tstruct mt7530_dummy_poll p;\n\tint ret;\n\tu32 reg;\n\n\tINIT_MT7530_DUMMY_POLL(&p, priv, MT7531_PHY_IAC);\n\n\tmt7530_mutex_lock(priv);\n\n\tret = readx_poll_timeout(_mt7530_unlocked_read, &p, reg,\n\t\t\t\t !(reg & MT7531_PHY_ACS_ST), 20, 100000);\n\tif (ret < 0) {\n\t\tdev_err(priv->dev, \"poll timeout\\n\");\n\t\tgoto out;\n\t}\n\n\treg = MT7531_MDIO_CL22_WRITE | MT7531_MDIO_PHY_ADDR(port) |\n\t      MT7531_MDIO_REG_ADDR(regnum) | data;\n\n\tmt7530_mii_write(priv, MT7531_PHY_IAC, reg | MT7531_PHY_ACS_ST);\n\n\tret = readx_poll_timeout(_mt7530_unlocked_read, &p, reg,\n\t\t\t\t !(reg & MT7531_PHY_ACS_ST), 20, 100000);\n\tif (ret < 0) {\n\t\tdev_err(priv->dev, \"poll timeout\\n\");\n\t\tgoto out;\n\t}\n\nout:\n\tmt7530_mutex_unlock(priv);\n\n\treturn ret;\n}\n\nstatic int\nmt753x_phy_read_c22(struct mii_bus *bus, int port, int regnum)\n{\n\tstruct mt7530_priv *priv = bus->priv;\n\n\treturn priv->info->phy_read_c22(priv, port, regnum);\n}\n\nstatic int\nmt753x_phy_read_c45(struct mii_bus *bus, int port, int devad, int regnum)\n{\n\tstruct mt7530_priv *priv = bus->priv;\n\n\treturn priv->info->phy_read_c45(priv, port, devad, regnum);\n}\n\nstatic int\nmt753x_phy_write_c22(struct mii_bus *bus, int port, int regnum, u16 val)\n{\n\tstruct mt7530_priv *priv = bus->priv;\n\n\treturn priv->info->phy_write_c22(priv, port, regnum, val);\n}\n\nstatic int\nmt753x_phy_write_c45(struct mii_bus *bus, int port, int devad, int regnum,\n\t\t     u16 val)\n{\n\tstruct mt7530_priv *priv = bus->priv;\n\n\treturn priv->info->phy_write_c45(priv, port, devad, regnum, val);\n}\n\nstatic void\nmt7530_get_strings(struct dsa_switch *ds, int port, u32 stringset,\n\t\t   uint8_t *data)\n{\n\tint i;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(mt7530_mib); i++)\n\t\tstrncpy(data + i * ETH_GSTRING_LEN, mt7530_mib[i].name,\n\t\t\tETH_GSTRING_LEN);\n}\n\nstatic void\nmt7530_get_ethtool_stats(struct dsa_switch *ds, int port,\n\t\t\t uint64_t *data)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\tconst struct mt7530_mib_desc *mib;\n\tu32 reg, i;\n\tu64 hi;\n\n\tfor (i = 0; i < ARRAY_SIZE(mt7530_mib); i++) {\n\t\tmib = &mt7530_mib[i];\n\t\treg = MT7530_PORT_MIB_COUNTER(port) + mib->offset;\n\n\t\tdata[i] = mt7530_read(priv, reg);\n\t\tif (mib->size == 2) {\n\t\t\thi = mt7530_read(priv, reg + 4);\n\t\t\tdata[i] |= hi << 32;\n\t\t}\n\t}\n}\n\nstatic int\nmt7530_get_sset_count(struct dsa_switch *ds, int port, int sset)\n{\n\tif (sset != ETH_SS_STATS)\n\t\treturn 0;\n\n\treturn ARRAY_SIZE(mt7530_mib);\n}\n\nstatic int\nmt7530_set_ageing_time(struct dsa_switch *ds, unsigned int msecs)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\tunsigned int secs = msecs / 1000;\n\tunsigned int tmp_age_count;\n\tunsigned int error = -1;\n\tunsigned int age_count;\n\tunsigned int age_unit;\n\n\t \n\tif (secs < 1 || secs > (AGE_CNT_MAX + 1) * (AGE_UNIT_MAX + 1))\n\t\treturn -ERANGE;\n\n\t \n\tfor (tmp_age_count = 0; tmp_age_count <= AGE_CNT_MAX; ++tmp_age_count) {\n\t\tunsigned int tmp_age_unit = secs / (tmp_age_count + 1) - 1;\n\n\t\tif (tmp_age_unit <= AGE_UNIT_MAX) {\n\t\t\tunsigned int tmp_error = secs -\n\t\t\t\t(tmp_age_count + 1) * (tmp_age_unit + 1);\n\n\t\t\t \n\t\t\tif (error > tmp_error) {\n\t\t\t\terror = tmp_error;\n\t\t\t\tage_count = tmp_age_count;\n\t\t\t\tage_unit = tmp_age_unit;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!error)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tmt7530_write(priv, MT7530_AAC, AGE_CNT(age_count) | AGE_UNIT(age_unit));\n\n\treturn 0;\n}\n\nstatic const char *p5_intf_modes(unsigned int p5_interface)\n{\n\tswitch (p5_interface) {\n\tcase P5_DISABLED:\n\t\treturn \"DISABLED\";\n\tcase P5_INTF_SEL_PHY_P0:\n\t\treturn \"PHY P0\";\n\tcase P5_INTF_SEL_PHY_P4:\n\t\treturn \"PHY P4\";\n\tcase P5_INTF_SEL_GMAC5:\n\t\treturn \"GMAC5\";\n\tcase P5_INTF_SEL_GMAC5_SGMII:\n\t\treturn \"GMAC5_SGMII\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic void mt7530_setup_port5(struct dsa_switch *ds, phy_interface_t interface)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\tu8 tx_delay = 0;\n\tint val;\n\n\tmutex_lock(&priv->reg_mutex);\n\n\tval = mt7530_read(priv, MT7530_MHWTRAP);\n\n\tval |= MHWTRAP_MANUAL | MHWTRAP_P5_MAC_SEL | MHWTRAP_P5_DIS;\n\tval &= ~MHWTRAP_P5_RGMII_MODE & ~MHWTRAP_PHY0_SEL;\n\n\tswitch (priv->p5_intf_sel) {\n\tcase P5_INTF_SEL_PHY_P0:\n\t\t \n\t\tval |= MHWTRAP_PHY0_SEL;\n\t\tfallthrough;\n\tcase P5_INTF_SEL_PHY_P4:\n\t\t \n\t\tval &= ~MHWTRAP_P5_MAC_SEL & ~MHWTRAP_P5_DIS;\n\n\t\t \n\t\tmt7530_write(priv, MT7530_PMCR_P(5), 0x56300);\n\t\tbreak;\n\tcase P5_INTF_SEL_GMAC5:\n\t\t \n\t\tval &= ~MHWTRAP_P5_DIS;\n\t\tbreak;\n\tcase P5_DISABLED:\n\t\tinterface = PHY_INTERFACE_MODE_NA;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(ds->dev, \"Unsupported p5_intf_sel %d\\n\",\n\t\t\tpriv->p5_intf_sel);\n\t\tgoto unlock_exit;\n\t}\n\n\t \n\tif (phy_interface_mode_is_rgmii(interface)) {\n\t\tval |= MHWTRAP_P5_RGMII_MODE;\n\n\t\t \n\t\tmt7530_write(priv, MT7530_P5RGMIIRXCR, CSR_RGMII_EDGE_ALIGN);\n\n\t\t \n\t\tif (!dsa_is_dsa_port(priv->ds, 5) &&\n\t\t    (interface == PHY_INTERFACE_MODE_RGMII_TXID ||\n\t\t     interface == PHY_INTERFACE_MODE_RGMII_ID))\n\t\t\ttx_delay = 4;  \n\n\t\t \n\t\tmt7530_write(priv, MT7530_P5RGMIITXCR,\n\t\t\t     CSR_RGMII_TXC_CFG(0x10 + tx_delay));\n\n\t\t \n\t\tmt7530_write(priv, MT7530_IO_DRV_CR,\n\t\t\t     P5_IO_CLK_DRV(1) | P5_IO_DATA_DRV(1));\n\t}\n\n\tmt7530_write(priv, MT7530_MHWTRAP, val);\n\n\tdev_dbg(ds->dev, \"Setup P5, HWTRAP=0x%x, intf_sel=%s, phy-mode=%s\\n\",\n\t\tval, p5_intf_modes(priv->p5_intf_sel), phy_modes(interface));\n\n\tpriv->p5_interface = interface;\n\nunlock_exit:\n\tmutex_unlock(&priv->reg_mutex);\n}\n\nstatic void\nmt753x_trap_frames(struct mt7530_priv *priv)\n{\n\t \n\tmt7530_rmw(priv, MT753X_BPC, MT753X_BPDU_PORT_FW_MASK,\n\t\t   MT753X_BPDU_CPU_ONLY);\n\n\t \n\tmt7530_rmw(priv, MT753X_BPC, MT753X_PAE_PORT_FW_MASK,\n\t\t   MT753X_PAE_PORT_FW(MT753X_BPDU_CPU_ONLY));\n\n\t \n\tmt7530_rmw(priv, MT753X_RGAC2, MT753X_R0E_PORT_FW_MASK,\n\t\t   MT753X_R0E_PORT_FW(MT753X_BPDU_CPU_ONLY));\n}\n\nstatic int\nmt753x_cpu_port_enable(struct dsa_switch *ds, int port)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\tint ret;\n\n\t \n\tif (priv->info->cpu_port_config) {\n\t\tret = priv->info->cpu_port_config(ds, port);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tmt7530_write(priv, MT7530_PVC_P(port),\n\t\t     PORT_SPEC_TAG);\n\n\t \n\tmt7530_set(priv, MT7530_MFC, BC_FFP(BIT(port)) | UNM_FFP(BIT(port)) |\n\t\t   UNU_FFP(BIT(port)));\n\n\t \n\tif (priv->id == ID_MT7530 || priv->id == ID_MT7621)\n\t\tmt7530_rmw(priv, MT7530_MFC, CPU_MASK, CPU_EN | CPU_PORT(port));\n\n\t \n\tif (priv->id == ID_MT7531 || priv->id == ID_MT7988)\n\t\tmt7530_set(priv, MT7531_CFC, MT7531_CPU_PMAP(BIT(port)));\n\n\t \n\tmt7530_write(priv, MT7530_PCR_P(port),\n\t\t     PCR_MATRIX(dsa_user_ports(priv->ds)));\n\n\t \n\tmt7530_rmw(priv, MT7530_PCR_P(port), PCR_PORT_VLAN_MASK,\n\t\t   MT7530_PORT_FALLBACK_MODE);\n\n\treturn 0;\n}\n\nstatic int\nmt7530_port_enable(struct dsa_switch *ds, int port,\n\t\t   struct phy_device *phy)\n{\n\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\tstruct mt7530_priv *priv = ds->priv;\n\n\tmutex_lock(&priv->reg_mutex);\n\n\t \n\tif (dsa_port_is_user(dp)) {\n\t\tstruct dsa_port *cpu_dp = dp->cpu_dp;\n\n\t\tpriv->ports[port].pm |= PCR_MATRIX(BIT(cpu_dp->index));\n\t}\n\tpriv->ports[port].enable = true;\n\tmt7530_rmw(priv, MT7530_PCR_P(port), PCR_MATRIX_MASK,\n\t\t   priv->ports[port].pm);\n\tmt7530_clear(priv, MT7530_PMCR_P(port), PMCR_LINK_SETTINGS_MASK);\n\n\tmutex_unlock(&priv->reg_mutex);\n\n\treturn 0;\n}\n\nstatic void\nmt7530_port_disable(struct dsa_switch *ds, int port)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\n\tmutex_lock(&priv->reg_mutex);\n\n\t \n\tpriv->ports[port].enable = false;\n\tmt7530_rmw(priv, MT7530_PCR_P(port), PCR_MATRIX_MASK,\n\t\t   PCR_MATRIX_CLR);\n\tmt7530_clear(priv, MT7530_PMCR_P(port), PMCR_LINK_SETTINGS_MASK);\n\n\tmutex_unlock(&priv->reg_mutex);\n}\n\nstatic int\nmt7530_port_change_mtu(struct dsa_switch *ds, int port, int new_mtu)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\tint length;\n\tu32 val;\n\n\t \n\tif (!dsa_is_cpu_port(ds, port))\n\t\treturn 0;\n\n\tmt7530_mutex_lock(priv);\n\n\tval = mt7530_mii_read(priv, MT7530_GMACCR);\n\tval &= ~MAX_RX_PKT_LEN_MASK;\n\n\t \n\tlength = new_mtu + ETH_HLEN + MTK_HDR_LEN + ETH_FCS_LEN;\n\tif (length <= 1522) {\n\t\tval |= MAX_RX_PKT_LEN_1522;\n\t} else if (length <= 1536) {\n\t\tval |= MAX_RX_PKT_LEN_1536;\n\t} else if (length <= 1552) {\n\t\tval |= MAX_RX_PKT_LEN_1552;\n\t} else {\n\t\tval &= ~MAX_RX_JUMBO_MASK;\n\t\tval |= MAX_RX_JUMBO(DIV_ROUND_UP(length, 1024));\n\t\tval |= MAX_RX_PKT_LEN_JUMBO;\n\t}\n\n\tmt7530_mii_write(priv, MT7530_GMACCR, val);\n\n\tmt7530_mutex_unlock(priv);\n\n\treturn 0;\n}\n\nstatic int\nmt7530_port_max_mtu(struct dsa_switch *ds, int port)\n{\n\treturn MT7530_MAX_MTU;\n}\n\nstatic void\nmt7530_stp_state_set(struct dsa_switch *ds, int port, u8 state)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\tu32 stp_state;\n\n\tswitch (state) {\n\tcase BR_STATE_DISABLED:\n\t\tstp_state = MT7530_STP_DISABLED;\n\t\tbreak;\n\tcase BR_STATE_BLOCKING:\n\t\tstp_state = MT7530_STP_BLOCKING;\n\t\tbreak;\n\tcase BR_STATE_LISTENING:\n\t\tstp_state = MT7530_STP_LISTENING;\n\t\tbreak;\n\tcase BR_STATE_LEARNING:\n\t\tstp_state = MT7530_STP_LEARNING;\n\t\tbreak;\n\tcase BR_STATE_FORWARDING:\n\tdefault:\n\t\tstp_state = MT7530_STP_FORWARDING;\n\t\tbreak;\n\t}\n\n\tmt7530_rmw(priv, MT7530_SSP_P(port), FID_PST_MASK(FID_BRIDGED),\n\t\t   FID_PST(FID_BRIDGED, stp_state));\n}\n\nstatic int\nmt7530_port_pre_bridge_flags(struct dsa_switch *ds, int port,\n\t\t\t     struct switchdev_brport_flags flags,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tif (flags.mask & ~(BR_LEARNING | BR_FLOOD | BR_MCAST_FLOOD |\n\t\t\t   BR_BCAST_FLOOD))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int\nmt7530_port_bridge_flags(struct dsa_switch *ds, int port,\n\t\t\t struct switchdev_brport_flags flags,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\n\tif (flags.mask & BR_LEARNING)\n\t\tmt7530_rmw(priv, MT7530_PSC_P(port), SA_DIS,\n\t\t\t   flags.val & BR_LEARNING ? 0 : SA_DIS);\n\n\tif (flags.mask & BR_FLOOD)\n\t\tmt7530_rmw(priv, MT7530_MFC, UNU_FFP(BIT(port)),\n\t\t\t   flags.val & BR_FLOOD ? UNU_FFP(BIT(port)) : 0);\n\n\tif (flags.mask & BR_MCAST_FLOOD)\n\t\tmt7530_rmw(priv, MT7530_MFC, UNM_FFP(BIT(port)),\n\t\t\t   flags.val & BR_MCAST_FLOOD ? UNM_FFP(BIT(port)) : 0);\n\n\tif (flags.mask & BR_BCAST_FLOOD)\n\t\tmt7530_rmw(priv, MT7530_MFC, BC_FFP(BIT(port)),\n\t\t\t   flags.val & BR_BCAST_FLOOD ? BC_FFP(BIT(port)) : 0);\n\n\treturn 0;\n}\n\nstatic int\nmt7530_port_bridge_join(struct dsa_switch *ds, int port,\n\t\t\tstruct dsa_bridge bridge, bool *tx_fwd_offload,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct dsa_port *dp = dsa_to_port(ds, port), *other_dp;\n\tstruct dsa_port *cpu_dp = dp->cpu_dp;\n\tu32 port_bitmap = BIT(cpu_dp->index);\n\tstruct mt7530_priv *priv = ds->priv;\n\n\tmutex_lock(&priv->reg_mutex);\n\n\tdsa_switch_for_each_user_port(other_dp, ds) {\n\t\tint other_port = other_dp->index;\n\n\t\tif (dp == other_dp)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!dsa_port_offloads_bridge(other_dp, &bridge))\n\t\t\tcontinue;\n\n\t\tif (priv->ports[other_port].enable)\n\t\t\tmt7530_set(priv, MT7530_PCR_P(other_port),\n\t\t\t\t   PCR_MATRIX(BIT(port)));\n\t\tpriv->ports[other_port].pm |= PCR_MATRIX(BIT(port));\n\n\t\tport_bitmap |= BIT(other_port);\n\t}\n\n\t \n\tif (priv->ports[port].enable)\n\t\tmt7530_rmw(priv, MT7530_PCR_P(port),\n\t\t\t   PCR_MATRIX_MASK, PCR_MATRIX(port_bitmap));\n\tpriv->ports[port].pm |= PCR_MATRIX(port_bitmap);\n\n\t \n\tmt7530_rmw(priv, MT7530_PCR_P(port), PCR_PORT_VLAN_MASK,\n\t\t   MT7530_PORT_FALLBACK_MODE);\n\n\tmutex_unlock(&priv->reg_mutex);\n\n\treturn 0;\n}\n\nstatic void\nmt7530_port_set_vlan_unaware(struct dsa_switch *ds, int port)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\tbool all_user_ports_removed = true;\n\tint i;\n\n\t \n\tif (dsa_port_bridge_dev_get(dsa_to_port(ds, port)))\n\t\tmt7530_rmw(priv, MT7530_PCR_P(port), PCR_PORT_VLAN_MASK,\n\t\t\t   MT7530_PORT_FALLBACK_MODE);\n\n\tmt7530_rmw(priv, MT7530_PVC_P(port),\n\t\t   VLAN_ATTR_MASK | PVC_EG_TAG_MASK | ACC_FRM_MASK,\n\t\t   VLAN_ATTR(MT7530_VLAN_TRANSPARENT) |\n\t\t   PVC_EG_TAG(MT7530_VLAN_EG_CONSISTENT) |\n\t\t   MT7530_VLAN_ACC_ALL);\n\n\t \n\tmt7530_rmw(priv, MT7530_PPBV1_P(port), G0_PORT_VID_MASK,\n\t\t   G0_PORT_VID_DEF);\n\n\tfor (i = 0; i < MT7530_NUM_PORTS; i++) {\n\t\tif (dsa_is_user_port(ds, i) &&\n\t\t    dsa_port_is_vlan_filtering(dsa_to_port(ds, i))) {\n\t\t\tall_user_ports_removed = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (all_user_ports_removed) {\n\t\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\t\tstruct dsa_port *cpu_dp = dp->cpu_dp;\n\n\t\tmt7530_write(priv, MT7530_PCR_P(cpu_dp->index),\n\t\t\t     PCR_MATRIX(dsa_user_ports(priv->ds)));\n\t\tmt7530_write(priv, MT7530_PVC_P(cpu_dp->index), PORT_SPEC_TAG\n\t\t\t     | PVC_EG_TAG(MT7530_VLAN_EG_CONSISTENT));\n\t}\n}\n\nstatic void\nmt7530_port_set_vlan_aware(struct dsa_switch *ds, int port)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\n\t \n\tif (dsa_is_user_port(ds, port)) {\n\t\tmt7530_rmw(priv, MT7530_PCR_P(port), PCR_PORT_VLAN_MASK,\n\t\t\t   MT7530_PORT_SECURITY_MODE);\n\t\tmt7530_rmw(priv, MT7530_PPBV1_P(port), G0_PORT_VID_MASK,\n\t\t\t   G0_PORT_VID(priv->ports[port].pvid));\n\n\t\t \n\t\tif (!priv->ports[port].pvid)\n\t\t\tmt7530_rmw(priv, MT7530_PVC_P(port), ACC_FRM_MASK,\n\t\t\t\t   MT7530_VLAN_ACC_TAGGED);\n\n\t\t \n\t\tmt7530_rmw(priv, MT7530_PVC_P(port),\n\t\t\t   VLAN_ATTR_MASK | PVC_EG_TAG_MASK,\n\t\t\t   VLAN_ATTR(MT7530_VLAN_USER) |\n\t\t\t   PVC_EG_TAG(MT7530_VLAN_EG_DISABLED));\n\t} else {\n\t\t \n\t\tmt7530_rmw(priv, MT7530_PVC_P(port), VLAN_ATTR_MASK,\n\t\t\t   VLAN_ATTR(MT7530_VLAN_USER));\n\t}\n}\n\nstatic void\nmt7530_port_bridge_leave(struct dsa_switch *ds, int port,\n\t\t\t struct dsa_bridge bridge)\n{\n\tstruct dsa_port *dp = dsa_to_port(ds, port), *other_dp;\n\tstruct dsa_port *cpu_dp = dp->cpu_dp;\n\tstruct mt7530_priv *priv = ds->priv;\n\n\tmutex_lock(&priv->reg_mutex);\n\n\tdsa_switch_for_each_user_port(other_dp, ds) {\n\t\tint other_port = other_dp->index;\n\n\t\tif (dp == other_dp)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!dsa_port_offloads_bridge(other_dp, &bridge))\n\t\t\tcontinue;\n\n\t\tif (priv->ports[other_port].enable)\n\t\t\tmt7530_clear(priv, MT7530_PCR_P(other_port),\n\t\t\t\t     PCR_MATRIX(BIT(port)));\n\t\tpriv->ports[other_port].pm &= ~PCR_MATRIX(BIT(port));\n\t}\n\n\t \n\tif (priv->ports[port].enable)\n\t\tmt7530_rmw(priv, MT7530_PCR_P(port), PCR_MATRIX_MASK,\n\t\t\t   PCR_MATRIX(BIT(cpu_dp->index)));\n\tpriv->ports[port].pm = PCR_MATRIX(BIT(cpu_dp->index));\n\n\t \n\tmt7530_rmw(priv, MT7530_PCR_P(port), PCR_PORT_VLAN_MASK,\n\t\t   MT7530_PORT_MATRIX_MODE);\n\n\tmutex_unlock(&priv->reg_mutex);\n}\n\nstatic int\nmt7530_port_fdb_add(struct dsa_switch *ds, int port,\n\t\t    const unsigned char *addr, u16 vid,\n\t\t    struct dsa_db db)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\tint ret;\n\tu8 port_mask = BIT(port);\n\n\tmutex_lock(&priv->reg_mutex);\n\tmt7530_fdb_write(priv, vid, port_mask, addr, -1, STATIC_ENT);\n\tret = mt7530_fdb_cmd(priv, MT7530_FDB_WRITE, NULL);\n\tmutex_unlock(&priv->reg_mutex);\n\n\treturn ret;\n}\n\nstatic int\nmt7530_port_fdb_del(struct dsa_switch *ds, int port,\n\t\t    const unsigned char *addr, u16 vid,\n\t\t    struct dsa_db db)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\tint ret;\n\tu8 port_mask = BIT(port);\n\n\tmutex_lock(&priv->reg_mutex);\n\tmt7530_fdb_write(priv, vid, port_mask, addr, -1, STATIC_EMP);\n\tret = mt7530_fdb_cmd(priv, MT7530_FDB_WRITE, NULL);\n\tmutex_unlock(&priv->reg_mutex);\n\n\treturn ret;\n}\n\nstatic int\nmt7530_port_fdb_dump(struct dsa_switch *ds, int port,\n\t\t     dsa_fdb_dump_cb_t *cb, void *data)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\tstruct mt7530_fdb _fdb = { 0 };\n\tint cnt = MT7530_NUM_FDB_RECORDS;\n\tint ret = 0;\n\tu32 rsp = 0;\n\n\tmutex_lock(&priv->reg_mutex);\n\n\tret = mt7530_fdb_cmd(priv, MT7530_FDB_START, &rsp);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tdo {\n\t\tif (rsp & ATC_SRCH_HIT) {\n\t\t\tmt7530_fdb_read(priv, &_fdb);\n\t\t\tif (_fdb.port_mask & BIT(port)) {\n\t\t\t\tret = cb(_fdb.mac, _fdb.vid, _fdb.noarp,\n\t\t\t\t\t data);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (--cnt &&\n\t\t !(rsp & ATC_SRCH_END) &&\n\t\t !mt7530_fdb_cmd(priv, MT7530_FDB_NEXT, &rsp));\nerr:\n\tmutex_unlock(&priv->reg_mutex);\n\n\treturn 0;\n}\n\nstatic int\nmt7530_port_mdb_add(struct dsa_switch *ds, int port,\n\t\t    const struct switchdev_obj_port_mdb *mdb,\n\t\t    struct dsa_db db)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\tconst u8 *addr = mdb->addr;\n\tu16 vid = mdb->vid;\n\tu8 port_mask = 0;\n\tint ret;\n\n\tmutex_lock(&priv->reg_mutex);\n\n\tmt7530_fdb_write(priv, vid, 0, addr, 0, STATIC_EMP);\n\tif (!mt7530_fdb_cmd(priv, MT7530_FDB_READ, NULL))\n\t\tport_mask = (mt7530_read(priv, MT7530_ATRD) >> PORT_MAP)\n\t\t\t    & PORT_MAP_MASK;\n\n\tport_mask |= BIT(port);\n\tmt7530_fdb_write(priv, vid, port_mask, addr, -1, STATIC_ENT);\n\tret = mt7530_fdb_cmd(priv, MT7530_FDB_WRITE, NULL);\n\n\tmutex_unlock(&priv->reg_mutex);\n\n\treturn ret;\n}\n\nstatic int\nmt7530_port_mdb_del(struct dsa_switch *ds, int port,\n\t\t    const struct switchdev_obj_port_mdb *mdb,\n\t\t    struct dsa_db db)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\tconst u8 *addr = mdb->addr;\n\tu16 vid = mdb->vid;\n\tu8 port_mask = 0;\n\tint ret;\n\n\tmutex_lock(&priv->reg_mutex);\n\n\tmt7530_fdb_write(priv, vid, 0, addr, 0, STATIC_EMP);\n\tif (!mt7530_fdb_cmd(priv, MT7530_FDB_READ, NULL))\n\t\tport_mask = (mt7530_read(priv, MT7530_ATRD) >> PORT_MAP)\n\t\t\t    & PORT_MAP_MASK;\n\n\tport_mask &= ~BIT(port);\n\tmt7530_fdb_write(priv, vid, port_mask, addr, -1,\n\t\t\t port_mask ? STATIC_ENT : STATIC_EMP);\n\tret = mt7530_fdb_cmd(priv, MT7530_FDB_WRITE, NULL);\n\n\tmutex_unlock(&priv->reg_mutex);\n\n\treturn ret;\n}\n\nstatic int\nmt7530_vlan_cmd(struct mt7530_priv *priv, enum mt7530_vlan_cmd cmd, u16 vid)\n{\n\tstruct mt7530_dummy_poll p;\n\tu32 val;\n\tint ret;\n\n\tval = VTCR_BUSY | VTCR_FUNC(cmd) | vid;\n\tmt7530_write(priv, MT7530_VTCR, val);\n\n\tINIT_MT7530_DUMMY_POLL(&p, priv, MT7530_VTCR);\n\tret = readx_poll_timeout(_mt7530_read, &p, val,\n\t\t\t\t !(val & VTCR_BUSY), 20, 20000);\n\tif (ret < 0) {\n\t\tdev_err(priv->dev, \"poll timeout\\n\");\n\t\treturn ret;\n\t}\n\n\tval = mt7530_read(priv, MT7530_VTCR);\n\tif (val & VTCR_INVALID) {\n\t\tdev_err(priv->dev, \"read VTCR invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmt7530_port_vlan_filtering(struct dsa_switch *ds, int port, bool vlan_filtering,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\tstruct dsa_port *cpu_dp = dp->cpu_dp;\n\n\tif (vlan_filtering) {\n\t\t \n\t\tmt7530_port_set_vlan_aware(ds, port);\n\t\tmt7530_port_set_vlan_aware(ds, cpu_dp->index);\n\t} else {\n\t\tmt7530_port_set_vlan_unaware(ds, port);\n\t}\n\n\treturn 0;\n}\n\nstatic void\nmt7530_hw_vlan_add(struct mt7530_priv *priv,\n\t\t   struct mt7530_hw_vlan_entry *entry)\n{\n\tstruct dsa_port *dp = dsa_to_port(priv->ds, entry->port);\n\tu8 new_members;\n\tu32 val;\n\n\tnew_members = entry->old_members | BIT(entry->port);\n\n\t \n\tval = IVL_MAC | VTAG_EN | PORT_MEM(new_members) | FID(FID_BRIDGED) |\n\t      VLAN_VALID;\n\tmt7530_write(priv, MT7530_VAWD1, val);\n\n\t \n\tif (dsa_port_is_cpu(dp))\n\t\tval = MT7530_VLAN_EGRESS_STACK;\n\telse if (entry->untagged)\n\t\tval = MT7530_VLAN_EGRESS_UNTAG;\n\telse\n\t\tval = MT7530_VLAN_EGRESS_TAG;\n\tmt7530_rmw(priv, MT7530_VAWD2,\n\t\t   ETAG_CTRL_P_MASK(entry->port),\n\t\t   ETAG_CTRL_P(entry->port, val));\n}\n\nstatic void\nmt7530_hw_vlan_del(struct mt7530_priv *priv,\n\t\t   struct mt7530_hw_vlan_entry *entry)\n{\n\tu8 new_members;\n\tu32 val;\n\n\tnew_members = entry->old_members & ~BIT(entry->port);\n\n\tval = mt7530_read(priv, MT7530_VAWD1);\n\tif (!(val & VLAN_VALID)) {\n\t\tdev_err(priv->dev,\n\t\t\t\"Cannot be deleted due to invalid entry\\n\");\n\t\treturn;\n\t}\n\n\tif (new_members) {\n\t\tval = IVL_MAC | VTAG_EN | PORT_MEM(new_members) |\n\t\t      VLAN_VALID;\n\t\tmt7530_write(priv, MT7530_VAWD1, val);\n\t} else {\n\t\tmt7530_write(priv, MT7530_VAWD1, 0);\n\t\tmt7530_write(priv, MT7530_VAWD2, 0);\n\t}\n}\n\nstatic void\nmt7530_hw_vlan_update(struct mt7530_priv *priv, u16 vid,\n\t\t      struct mt7530_hw_vlan_entry *entry,\n\t\t      mt7530_vlan_op vlan_op)\n{\n\tu32 val;\n\n\t \n\tmt7530_vlan_cmd(priv, MT7530_VTCR_RD_VID, vid);\n\n\tval = mt7530_read(priv, MT7530_VAWD1);\n\n\tentry->old_members = (val >> PORT_MEM_SHFT) & PORT_MEM_MASK;\n\n\t \n\tvlan_op(priv, entry);\n\n\t \n\tmt7530_vlan_cmd(priv, MT7530_VTCR_WR_VID, vid);\n}\n\nstatic int\nmt7530_setup_vlan0(struct mt7530_priv *priv)\n{\n\tu32 val;\n\n\t \n\tval = IVL_MAC | EG_CON | PORT_MEM(MT7530_ALL_MEMBERS) | FID(FID_BRIDGED) |\n\t      VLAN_VALID;\n\tmt7530_write(priv, MT7530_VAWD1, val);\n\n\treturn mt7530_vlan_cmd(priv, MT7530_VTCR_WR_VID, 0);\n}\n\nstatic int\nmt7530_port_vlan_add(struct dsa_switch *ds, int port,\n\t\t     const struct switchdev_obj_port_vlan *vlan,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tbool untagged = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;\n\tbool pvid = vlan->flags & BRIDGE_VLAN_INFO_PVID;\n\tstruct mt7530_hw_vlan_entry new_entry;\n\tstruct mt7530_priv *priv = ds->priv;\n\n\tmutex_lock(&priv->reg_mutex);\n\n\tmt7530_hw_vlan_entry_init(&new_entry, port, untagged);\n\tmt7530_hw_vlan_update(priv, vlan->vid, &new_entry, mt7530_hw_vlan_add);\n\n\tif (pvid) {\n\t\tpriv->ports[port].pvid = vlan->vid;\n\n\t\t \n\t\tmt7530_rmw(priv, MT7530_PVC_P(port), ACC_FRM_MASK,\n\t\t\t   MT7530_VLAN_ACC_ALL);\n\n\t\t \n\t\tif (dsa_port_is_vlan_filtering(dsa_to_port(ds, port)))\n\t\t\tmt7530_rmw(priv, MT7530_PPBV1_P(port),\n\t\t\t\t   G0_PORT_VID_MASK,\n\t\t\t\t   G0_PORT_VID(vlan->vid));\n\t} else if (vlan->vid && priv->ports[port].pvid == vlan->vid) {\n\t\t \n\t\tpriv->ports[port].pvid = G0_PORT_VID_DEF;\n\n\t\t \n\t\tif (dsa_port_is_vlan_filtering(dsa_to_port(ds, port)))\n\t\t\tmt7530_rmw(priv, MT7530_PVC_P(port), ACC_FRM_MASK,\n\t\t\t\t   MT7530_VLAN_ACC_TAGGED);\n\n\t\tmt7530_rmw(priv, MT7530_PPBV1_P(port), G0_PORT_VID_MASK,\n\t\t\t   G0_PORT_VID_DEF);\n\t}\n\n\tmutex_unlock(&priv->reg_mutex);\n\n\treturn 0;\n}\n\nstatic int\nmt7530_port_vlan_del(struct dsa_switch *ds, int port,\n\t\t     const struct switchdev_obj_port_vlan *vlan)\n{\n\tstruct mt7530_hw_vlan_entry target_entry;\n\tstruct mt7530_priv *priv = ds->priv;\n\n\tmutex_lock(&priv->reg_mutex);\n\n\tmt7530_hw_vlan_entry_init(&target_entry, port, 0);\n\tmt7530_hw_vlan_update(priv, vlan->vid, &target_entry,\n\t\t\t      mt7530_hw_vlan_del);\n\n\t \n\tif (priv->ports[port].pvid == vlan->vid) {\n\t\tpriv->ports[port].pvid = G0_PORT_VID_DEF;\n\n\t\t \n\t\tif (dsa_port_is_vlan_filtering(dsa_to_port(ds, port)))\n\t\t\tmt7530_rmw(priv, MT7530_PVC_P(port), ACC_FRM_MASK,\n\t\t\t\t   MT7530_VLAN_ACC_TAGGED);\n\n\t\tmt7530_rmw(priv, MT7530_PPBV1_P(port), G0_PORT_VID_MASK,\n\t\t\t   G0_PORT_VID_DEF);\n\t}\n\n\n\tmutex_unlock(&priv->reg_mutex);\n\n\treturn 0;\n}\n\nstatic int mt753x_mirror_port_get(unsigned int id, u32 val)\n{\n\treturn (id == ID_MT7531) ? MT7531_MIRROR_PORT_GET(val) :\n\t\t\t\t   MIRROR_PORT(val);\n}\n\nstatic int mt753x_mirror_port_set(unsigned int id, u32 val)\n{\n\treturn (id == ID_MT7531) ? MT7531_MIRROR_PORT_SET(val) :\n\t\t\t\t   MIRROR_PORT(val);\n}\n\nstatic int mt753x_port_mirror_add(struct dsa_switch *ds, int port,\n\t\t\t\t  struct dsa_mall_mirror_tc_entry *mirror,\n\t\t\t\t  bool ingress, struct netlink_ext_ack *extack)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\tint monitor_port;\n\tu32 val;\n\n\t \n\tif ((ingress ? priv->mirror_rx : priv->mirror_tx) & BIT(port))\n\t\treturn -EEXIST;\n\n\tval = mt7530_read(priv, MT753X_MIRROR_REG(priv->id));\n\n\t \n\tmonitor_port = mt753x_mirror_port_get(priv->id, val);\n\tif (val & MT753X_MIRROR_EN(priv->id) &&\n\t    monitor_port != mirror->to_local_port)\n\t\treturn -EEXIST;\n\n\tval |= MT753X_MIRROR_EN(priv->id);\n\tval &= ~MT753X_MIRROR_MASK(priv->id);\n\tval |= mt753x_mirror_port_set(priv->id, mirror->to_local_port);\n\tmt7530_write(priv, MT753X_MIRROR_REG(priv->id), val);\n\n\tval = mt7530_read(priv, MT7530_PCR_P(port));\n\tif (ingress) {\n\t\tval |= PORT_RX_MIR;\n\t\tpriv->mirror_rx |= BIT(port);\n\t} else {\n\t\tval |= PORT_TX_MIR;\n\t\tpriv->mirror_tx |= BIT(port);\n\t}\n\tmt7530_write(priv, MT7530_PCR_P(port), val);\n\n\treturn 0;\n}\n\nstatic void mt753x_port_mirror_del(struct dsa_switch *ds, int port,\n\t\t\t\t   struct dsa_mall_mirror_tc_entry *mirror)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\tu32 val;\n\n\tval = mt7530_read(priv, MT7530_PCR_P(port));\n\tif (mirror->ingress) {\n\t\tval &= ~PORT_RX_MIR;\n\t\tpriv->mirror_rx &= ~BIT(port);\n\t} else {\n\t\tval &= ~PORT_TX_MIR;\n\t\tpriv->mirror_tx &= ~BIT(port);\n\t}\n\tmt7530_write(priv, MT7530_PCR_P(port), val);\n\n\tif (!priv->mirror_rx && !priv->mirror_tx) {\n\t\tval = mt7530_read(priv, MT753X_MIRROR_REG(priv->id));\n\t\tval &= ~MT753X_MIRROR_EN(priv->id);\n\t\tmt7530_write(priv, MT753X_MIRROR_REG(priv->id), val);\n\t}\n}\n\nstatic enum dsa_tag_protocol\nmtk_get_tag_protocol(struct dsa_switch *ds, int port,\n\t\t     enum dsa_tag_protocol mp)\n{\n\treturn DSA_TAG_PROTO_MTK;\n}\n\n#ifdef CONFIG_GPIOLIB\nstatic inline u32\nmt7530_gpio_to_bit(unsigned int offset)\n{\n\t \n\treturn BIT(offset + offset / 3);\n}\n\nstatic int\nmt7530_gpio_get(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct mt7530_priv *priv = gpiochip_get_data(gc);\n\tu32 bit = mt7530_gpio_to_bit(offset);\n\n\treturn !!(mt7530_read(priv, MT7530_LED_GPIO_DATA) & bit);\n}\n\nstatic void\nmt7530_gpio_set(struct gpio_chip *gc, unsigned int offset, int value)\n{\n\tstruct mt7530_priv *priv = gpiochip_get_data(gc);\n\tu32 bit = mt7530_gpio_to_bit(offset);\n\n\tif (value)\n\t\tmt7530_set(priv, MT7530_LED_GPIO_DATA, bit);\n\telse\n\t\tmt7530_clear(priv, MT7530_LED_GPIO_DATA, bit);\n}\n\nstatic int\nmt7530_gpio_get_direction(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct mt7530_priv *priv = gpiochip_get_data(gc);\n\tu32 bit = mt7530_gpio_to_bit(offset);\n\n\treturn (mt7530_read(priv, MT7530_LED_GPIO_DIR) & bit) ?\n\t\tGPIO_LINE_DIRECTION_OUT : GPIO_LINE_DIRECTION_IN;\n}\n\nstatic int\nmt7530_gpio_direction_input(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct mt7530_priv *priv = gpiochip_get_data(gc);\n\tu32 bit = mt7530_gpio_to_bit(offset);\n\n\tmt7530_clear(priv, MT7530_LED_GPIO_OE, bit);\n\tmt7530_clear(priv, MT7530_LED_GPIO_DIR, bit);\n\n\treturn 0;\n}\n\nstatic int\nmt7530_gpio_direction_output(struct gpio_chip *gc, unsigned int offset, int value)\n{\n\tstruct mt7530_priv *priv = gpiochip_get_data(gc);\n\tu32 bit = mt7530_gpio_to_bit(offset);\n\n\tmt7530_set(priv, MT7530_LED_GPIO_DIR, bit);\n\n\tif (value)\n\t\tmt7530_set(priv, MT7530_LED_GPIO_DATA, bit);\n\telse\n\t\tmt7530_clear(priv, MT7530_LED_GPIO_DATA, bit);\n\n\tmt7530_set(priv, MT7530_LED_GPIO_OE, bit);\n\n\treturn 0;\n}\n\nstatic int\nmt7530_setup_gpio(struct mt7530_priv *priv)\n{\n\tstruct device *dev = priv->dev;\n\tstruct gpio_chip *gc;\n\n\tgc = devm_kzalloc(dev, sizeof(*gc), GFP_KERNEL);\n\tif (!gc)\n\t\treturn -ENOMEM;\n\n\tmt7530_write(priv, MT7530_LED_GPIO_OE, 0);\n\tmt7530_write(priv, MT7530_LED_GPIO_DIR, 0);\n\tmt7530_write(priv, MT7530_LED_IO_MODE, 0);\n\n\tgc->label = \"mt7530\";\n\tgc->parent = dev;\n\tgc->owner = THIS_MODULE;\n\tgc->get_direction = mt7530_gpio_get_direction;\n\tgc->direction_input = mt7530_gpio_direction_input;\n\tgc->direction_output = mt7530_gpio_direction_output;\n\tgc->get = mt7530_gpio_get;\n\tgc->set = mt7530_gpio_set;\n\tgc->base = -1;\n\tgc->ngpio = 15;\n\tgc->can_sleep = true;\n\n\treturn devm_gpiochip_add_data(dev, gc, priv);\n}\n#endif  \n\nstatic irqreturn_t\nmt7530_irq_thread_fn(int irq, void *dev_id)\n{\n\tstruct mt7530_priv *priv = dev_id;\n\tbool handled = false;\n\tu32 val;\n\tint p;\n\n\tmt7530_mutex_lock(priv);\n\tval = mt7530_mii_read(priv, MT7530_SYS_INT_STS);\n\tmt7530_mii_write(priv, MT7530_SYS_INT_STS, val);\n\tmt7530_mutex_unlock(priv);\n\n\tfor (p = 0; p < MT7530_NUM_PHYS; p++) {\n\t\tif (BIT(p) & val) {\n\t\t\tunsigned int irq;\n\n\t\t\tirq = irq_find_mapping(priv->irq_domain, p);\n\t\t\thandle_nested_irq(irq);\n\t\t\thandled = true;\n\t\t}\n\t}\n\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void\nmt7530_irq_mask(struct irq_data *d)\n{\n\tstruct mt7530_priv *priv = irq_data_get_irq_chip_data(d);\n\n\tpriv->irq_enable &= ~BIT(d->hwirq);\n}\n\nstatic void\nmt7530_irq_unmask(struct irq_data *d)\n{\n\tstruct mt7530_priv *priv = irq_data_get_irq_chip_data(d);\n\n\tpriv->irq_enable |= BIT(d->hwirq);\n}\n\nstatic void\nmt7530_irq_bus_lock(struct irq_data *d)\n{\n\tstruct mt7530_priv *priv = irq_data_get_irq_chip_data(d);\n\n\tmt7530_mutex_lock(priv);\n}\n\nstatic void\nmt7530_irq_bus_sync_unlock(struct irq_data *d)\n{\n\tstruct mt7530_priv *priv = irq_data_get_irq_chip_data(d);\n\n\tmt7530_mii_write(priv, MT7530_SYS_INT_EN, priv->irq_enable);\n\tmt7530_mutex_unlock(priv);\n}\n\nstatic struct irq_chip mt7530_irq_chip = {\n\t.name = KBUILD_MODNAME,\n\t.irq_mask = mt7530_irq_mask,\n\t.irq_unmask = mt7530_irq_unmask,\n\t.irq_bus_lock = mt7530_irq_bus_lock,\n\t.irq_bus_sync_unlock = mt7530_irq_bus_sync_unlock,\n};\n\nstatic int\nmt7530_irq_map(struct irq_domain *domain, unsigned int irq,\n\t       irq_hw_number_t hwirq)\n{\n\tirq_set_chip_data(irq, domain->host_data);\n\tirq_set_chip_and_handler(irq, &mt7530_irq_chip, handle_simple_irq);\n\tirq_set_nested_thread(irq, true);\n\tirq_set_noprobe(irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops mt7530_irq_domain_ops = {\n\t.map = mt7530_irq_map,\n\t.xlate = irq_domain_xlate_onecell,\n};\n\nstatic void\nmt7988_irq_mask(struct irq_data *d)\n{\n\tstruct mt7530_priv *priv = irq_data_get_irq_chip_data(d);\n\n\tpriv->irq_enable &= ~BIT(d->hwirq);\n\tmt7530_mii_write(priv, MT7530_SYS_INT_EN, priv->irq_enable);\n}\n\nstatic void\nmt7988_irq_unmask(struct irq_data *d)\n{\n\tstruct mt7530_priv *priv = irq_data_get_irq_chip_data(d);\n\n\tpriv->irq_enable |= BIT(d->hwirq);\n\tmt7530_mii_write(priv, MT7530_SYS_INT_EN, priv->irq_enable);\n}\n\nstatic struct irq_chip mt7988_irq_chip = {\n\t.name = KBUILD_MODNAME,\n\t.irq_mask = mt7988_irq_mask,\n\t.irq_unmask = mt7988_irq_unmask,\n};\n\nstatic int\nmt7988_irq_map(struct irq_domain *domain, unsigned int irq,\n\t       irq_hw_number_t hwirq)\n{\n\tirq_set_chip_data(irq, domain->host_data);\n\tirq_set_chip_and_handler(irq, &mt7988_irq_chip, handle_simple_irq);\n\tirq_set_nested_thread(irq, true);\n\tirq_set_noprobe(irq);\n\n\treturn 0;\n}\n\nstatic const struct irq_domain_ops mt7988_irq_domain_ops = {\n\t.map = mt7988_irq_map,\n\t.xlate = irq_domain_xlate_onecell,\n};\n\nstatic void\nmt7530_setup_mdio_irq(struct mt7530_priv *priv)\n{\n\tstruct dsa_switch *ds = priv->ds;\n\tint p;\n\n\tfor (p = 0; p < MT7530_NUM_PHYS; p++) {\n\t\tif (BIT(p) & ds->phys_mii_mask) {\n\t\t\tunsigned int irq;\n\n\t\t\tirq = irq_create_mapping(priv->irq_domain, p);\n\t\t\tds->slave_mii_bus->irq[p] = irq;\n\t\t}\n\t}\n}\n\nstatic int\nmt7530_setup_irq(struct mt7530_priv *priv)\n{\n\tstruct device *dev = priv->dev;\n\tstruct device_node *np = dev->of_node;\n\tint ret;\n\n\tif (!of_property_read_bool(np, \"interrupt-controller\")) {\n\t\tdev_info(dev, \"no interrupt support\\n\");\n\t\treturn 0;\n\t}\n\n\tpriv->irq = of_irq_get(np, 0);\n\tif (priv->irq <= 0) {\n\t\tdev_err(dev, \"failed to get parent IRQ: %d\\n\", priv->irq);\n\t\treturn priv->irq ? : -EINVAL;\n\t}\n\n\tif (priv->id == ID_MT7988)\n\t\tpriv->irq_domain = irq_domain_add_linear(np, MT7530_NUM_PHYS,\n\t\t\t\t\t\t\t &mt7988_irq_domain_ops,\n\t\t\t\t\t\t\t priv);\n\telse\n\t\tpriv->irq_domain = irq_domain_add_linear(np, MT7530_NUM_PHYS,\n\t\t\t\t\t\t\t &mt7530_irq_domain_ops,\n\t\t\t\t\t\t\t priv);\n\n\tif (!priv->irq_domain) {\n\t\tdev_err(dev, \"failed to create IRQ domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (priv->id != ID_MT7531)\n\t\tmt7530_set(priv, MT7530_TOP_SIG_CTRL, TOP_SIG_CTRL_NORMAL);\n\n\tret = request_threaded_irq(priv->irq, NULL, mt7530_irq_thread_fn,\n\t\t\t\t   IRQF_ONESHOT, KBUILD_MODNAME, priv);\n\tif (ret) {\n\t\tirq_domain_remove(priv->irq_domain);\n\t\tdev_err(dev, \"failed to request IRQ: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nmt7530_free_mdio_irq(struct mt7530_priv *priv)\n{\n\tint p;\n\n\tfor (p = 0; p < MT7530_NUM_PHYS; p++) {\n\t\tif (BIT(p) & priv->ds->phys_mii_mask) {\n\t\t\tunsigned int irq;\n\n\t\t\tirq = irq_find_mapping(priv->irq_domain, p);\n\t\t\tirq_dispose_mapping(irq);\n\t\t}\n\t}\n}\n\nstatic void\nmt7530_free_irq_common(struct mt7530_priv *priv)\n{\n\tfree_irq(priv->irq, priv);\n\tirq_domain_remove(priv->irq_domain);\n}\n\nstatic void\nmt7530_free_irq(struct mt7530_priv *priv)\n{\n\tmt7530_free_mdio_irq(priv);\n\tmt7530_free_irq_common(priv);\n}\n\nstatic int\nmt7530_setup_mdio(struct mt7530_priv *priv)\n{\n\tstruct dsa_switch *ds = priv->ds;\n\tstruct device *dev = priv->dev;\n\tstruct mii_bus *bus;\n\tstatic int idx;\n\tint ret;\n\n\tbus = devm_mdiobus_alloc(dev);\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\tds->slave_mii_bus = bus;\n\tbus->priv = priv;\n\tbus->name = KBUILD_MODNAME \"-mii\";\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, KBUILD_MODNAME \"-%d\", idx++);\n\tbus->read = mt753x_phy_read_c22;\n\tbus->write = mt753x_phy_write_c22;\n\tbus->read_c45 = mt753x_phy_read_c45;\n\tbus->write_c45 = mt753x_phy_write_c45;\n\tbus->parent = dev;\n\tbus->phy_mask = ~ds->phys_mii_mask;\n\n\tif (priv->irq)\n\t\tmt7530_setup_mdio_irq(priv);\n\n\tret = devm_mdiobus_register(dev, bus);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register MDIO bus: %d\\n\", ret);\n\t\tif (priv->irq)\n\t\t\tmt7530_free_mdio_irq(priv);\n\t}\n\n\treturn ret;\n}\n\nstatic int\nmt7530_setup(struct dsa_switch *ds)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\tstruct device_node *dn = NULL;\n\tstruct device_node *phy_node;\n\tstruct device_node *mac_np;\n\tstruct mt7530_dummy_poll p;\n\tphy_interface_t interface;\n\tstruct dsa_port *cpu_dp;\n\tu32 id, val;\n\tint ret, i;\n\n\t \n\tdsa_switch_for_each_cpu_port(cpu_dp, ds) {\n\t\tdn = cpu_dp->master->dev.of_node->parent;\n\t\t \n\t\tbreak;\n\t}\n\n\tif (!dn) {\n\t\tdev_err(ds->dev, \"parent OF node of DSA master not found\");\n\t\treturn -EINVAL;\n\t}\n\n\tds->assisted_learning_on_cpu_port = true;\n\tds->mtu_enforcement_ingress = true;\n\n\tif (priv->id == ID_MT7530) {\n\t\tregulator_set_voltage(priv->core_pwr, 1000000, 1000000);\n\t\tret = regulator_enable(priv->core_pwr);\n\t\tif (ret < 0) {\n\t\t\tdev_err(priv->dev,\n\t\t\t\t\"Failed to enable core power: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tregulator_set_voltage(priv->io_pwr, 3300000, 3300000);\n\t\tret = regulator_enable(priv->io_pwr);\n\t\tif (ret < 0) {\n\t\t\tdev_err(priv->dev, \"Failed to enable io pwr: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (priv->mcm) {\n\t\treset_control_assert(priv->rstc);\n\t\tusleep_range(1000, 1100);\n\t\treset_control_deassert(priv->rstc);\n\t} else {\n\t\tgpiod_set_value_cansleep(priv->reset, 0);\n\t\tusleep_range(1000, 1100);\n\t\tgpiod_set_value_cansleep(priv->reset, 1);\n\t}\n\n\t \n\tINIT_MT7530_DUMMY_POLL(&p, priv, MT7530_HWTRAP);\n\tret = readx_poll_timeout(_mt7530_read, &p, val, val != 0,\n\t\t\t\t 20, 1000000);\n\tif (ret < 0) {\n\t\tdev_err(priv->dev, \"reset timeout\\n\");\n\t\treturn ret;\n\t}\n\n\tid = mt7530_read(priv, MT7530_CREV);\n\tid >>= CHIP_NAME_SHIFT;\n\tif (id != MT7530_ID) {\n\t\tdev_err(priv->dev, \"chip %x can't be supported\\n\", id);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tmt7530_write(priv, MT7530_SYS_CTRL,\n\t\t     SYS_CTRL_PHY_RST | SYS_CTRL_SW_RST |\n\t\t     SYS_CTRL_REG_RST);\n\n\tmt7530_pll_setup(priv);\n\n\t \n\tfor (i = 0; i < NUM_TRGMII_CTRL; i++)\n\t\tmt7530_write(priv, MT7530_TRGMII_TD_ODT(i),\n\t\t\t     TD_DM_DRVP(8) | TD_DM_DRVN(8));\n\n\tfor (i = 0; i < NUM_TRGMII_CTRL; i++)\n\t\tmt7530_rmw(priv, MT7530_TRGMII_RD(i),\n\t\t\t   RD_TAP_MASK, RD_TAP(16));\n\n\t \n\tval = mt7530_read(priv, MT7530_MHWTRAP);\n\tval &= ~MHWTRAP_P6_DIS & ~MHWTRAP_PHY_ACCESS;\n\tval |= MHWTRAP_MANUAL;\n\tmt7530_write(priv, MT7530_MHWTRAP, val);\n\n\tpriv->p6_interface = PHY_INTERFACE_MODE_NA;\n\n\tmt753x_trap_frames(priv);\n\n\t \n\tmt7530_mib_reset(ds);\n\n\tfor (i = 0; i < MT7530_NUM_PORTS; i++) {\n\t\t \n\t\tmt7530_rmw(priv, MT7530_PCR_P(i), PCR_MATRIX_MASK,\n\t\t\t   PCR_MATRIX_CLR);\n\n\t\t \n\t\tmt7530_set(priv, MT7530_PSC_P(i), SA_DIS);\n\n\t\tif (dsa_is_cpu_port(ds, i)) {\n\t\t\tret = mt753x_cpu_port_enable(ds, i);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tmt7530_port_disable(ds, i);\n\n\t\t\t \n\t\t\tmt7530_rmw(priv, MT7530_PPBV1_P(i), G0_PORT_VID_MASK,\n\t\t\t\t   G0_PORT_VID_DEF);\n\t\t}\n\t\t \n\t\tmt7530_rmw(priv, MT7530_PVC_P(i), PVC_EG_TAG_MASK,\n\t\t\t   PVC_EG_TAG(MT7530_VLAN_EG_CONSISTENT));\n\t}\n\n\t \n\tret = mt7530_setup_vlan0(priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpriv->p5_intf_sel = P5_DISABLED;\n\tinterface = PHY_INTERFACE_MODE_NA;\n\n\tif (!dsa_is_unused_port(ds, 5)) {\n\t\tpriv->p5_intf_sel = P5_INTF_SEL_GMAC5;\n\t\tret = of_get_phy_mode(dsa_to_port(ds, 5)->dn, &interface);\n\t\tif (ret && ret != -ENODEV)\n\t\t\treturn ret;\n\t} else {\n\t\t \n\t\tfor_each_child_of_node(dn, mac_np) {\n\t\t\tif (!of_device_is_compatible(mac_np,\n\t\t\t\t\t\t     \"mediatek,eth-mac\"))\n\t\t\t\tcontinue;\n\n\t\t\tret = of_property_read_u32(mac_np, \"reg\", &id);\n\t\t\tif (ret < 0 || id != 1)\n\t\t\t\tcontinue;\n\n\t\t\tphy_node = of_parse_phandle(mac_np, \"phy-handle\", 0);\n\t\t\tif (!phy_node)\n\t\t\t\tcontinue;\n\n\t\t\tif (phy_node->parent == priv->dev->of_node->parent) {\n\t\t\t\tret = of_get_phy_mode(mac_np, &interface);\n\t\t\t\tif (ret && ret != -ENODEV) {\n\t\t\t\t\tof_node_put(mac_np);\n\t\t\t\t\tof_node_put(phy_node);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tid = of_mdio_parse_addr(ds->dev, phy_node);\n\t\t\t\tif (id == 0)\n\t\t\t\t\tpriv->p5_intf_sel = P5_INTF_SEL_PHY_P0;\n\t\t\t\tif (id == 4)\n\t\t\t\t\tpriv->p5_intf_sel = P5_INTF_SEL_PHY_P4;\n\t\t\t}\n\t\t\tof_node_put(mac_np);\n\t\t\tof_node_put(phy_node);\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef CONFIG_GPIOLIB\n\tif (of_property_read_bool(priv->dev->of_node, \"gpio-controller\")) {\n\t\tret = mt7530_setup_gpio(priv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n#endif  \n\n\tmt7530_setup_port5(ds, interface);\n\n\t \n\tret = mt7530_fdb_cmd(priv, MT7530_FDB_FLUSH, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int\nmt7531_setup_common(struct dsa_switch *ds)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\tint ret, i;\n\n\tmt753x_trap_frames(priv);\n\n\t \n\tmt7530_mib_reset(ds);\n\n\t \n\tmt7530_clear(priv, MT7530_MFC, BC_FFP_MASK | UNM_FFP_MASK |\n\t\t     UNU_FFP_MASK);\n\n\tfor (i = 0; i < MT7530_NUM_PORTS; i++) {\n\t\t \n\t\tmt7530_rmw(priv, MT7530_PCR_P(i), PCR_MATRIX_MASK,\n\t\t\t   PCR_MATRIX_CLR);\n\n\t\t \n\t\tmt7530_set(priv, MT7530_PSC_P(i), SA_DIS);\n\n\t\tmt7530_set(priv, MT7531_DBG_CNT(i), MT7531_DIS_CLR);\n\n\t\tif (dsa_is_cpu_port(ds, i)) {\n\t\t\tret = mt753x_cpu_port_enable(ds, i);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tmt7530_port_disable(ds, i);\n\n\t\t\t \n\t\t\tmt7530_rmw(priv, MT7530_PPBV1_P(i), G0_PORT_VID_MASK,\n\t\t\t\t   G0_PORT_VID_DEF);\n\t\t}\n\n\t\t \n\t\tmt7530_rmw(priv, MT7530_PVC_P(i), PVC_EG_TAG_MASK,\n\t\t\t   PVC_EG_TAG(MT7530_VLAN_EG_CONSISTENT));\n\t}\n\n\t \n\tret = mt7530_fdb_cmd(priv, MT7530_FDB_FLUSH, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int\nmt7531_setup(struct dsa_switch *ds)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\tstruct mt7530_dummy_poll p;\n\tu32 val, id;\n\tint ret, i;\n\n\t \n\tif (priv->mcm) {\n\t\treset_control_assert(priv->rstc);\n\t\tusleep_range(1000, 1100);\n\t\treset_control_deassert(priv->rstc);\n\t} else {\n\t\tgpiod_set_value_cansleep(priv->reset, 0);\n\t\tusleep_range(1000, 1100);\n\t\tgpiod_set_value_cansleep(priv->reset, 1);\n\t}\n\n\t \n\tINIT_MT7530_DUMMY_POLL(&p, priv, MT7530_HWTRAP);\n\tret = readx_poll_timeout(_mt7530_read, &p, val, val != 0,\n\t\t\t\t 20, 1000000);\n\tif (ret < 0) {\n\t\tdev_err(priv->dev, \"reset timeout\\n\");\n\t\treturn ret;\n\t}\n\n\tid = mt7530_read(priv, MT7531_CREV);\n\tid >>= CHIP_NAME_SHIFT;\n\n\tif (id != MT7531_ID) {\n\t\tdev_err(priv->dev, \"chip %x can't be supported\\n\", id);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tfor (i = 0; i < MT7530_NUM_PORTS; i++)\n\t\tmt7530_write(priv, MT7530_PMCR_P(i), MT7531_FORCE_LNK);\n\n\t \n\tmt7530_write(priv, MT7530_SYS_CTRL,\n\t\t     SYS_CTRL_PHY_RST | SYS_CTRL_SW_RST |\n\t\t     SYS_CTRL_REG_RST);\n\n\tmt7531_pll_setup(priv);\n\n\tif (mt7531_dual_sgmii_supported(priv)) {\n\t\tpriv->p5_intf_sel = P5_INTF_SEL_GMAC5_SGMII;\n\n\t\t \n\t\tmt7530_rmw(priv, MT7531_GPIO_MODE1, MT7531_GPIO11_RG_RXD2_MASK,\n\t\t\t   MT7531_EXT_P_MDC_11);\n\t\tmt7530_rmw(priv, MT7531_GPIO_MODE1, MT7531_GPIO12_RG_RXD3_MASK,\n\t\t\t   MT7531_EXT_P_MDIO_12);\n\t} else {\n\t\tpriv->p5_intf_sel = P5_INTF_SEL_GMAC5;\n\t}\n\tdev_dbg(ds->dev, \"P5 support %s interface\\n\",\n\t\tp5_intf_modes(priv->p5_intf_sel));\n\n\tmt7530_rmw(priv, MT7531_GPIO_MODE0, MT7531_GPIO0_MASK,\n\t\t   MT7531_GPIO0_INTERRUPT);\n\n\t \n\tpriv->p5_interface = PHY_INTERFACE_MODE_NA;\n\tpriv->p6_interface = PHY_INTERFACE_MODE_NA;\n\n\t \n\tval = mt7531_ind_c45_phy_read(priv, MT753X_CTRL_PHY_ADDR,\n\t\t\t\t      MDIO_MMD_VEND2, CORE_PLL_GROUP4);\n\tval |= MT7531_PHY_PLL_BYPASS_MODE;\n\tval &= ~MT7531_PHY_PLL_OFF;\n\tmt7531_ind_c45_phy_write(priv, MT753X_CTRL_PHY_ADDR, MDIO_MMD_VEND2,\n\t\t\t\t CORE_PLL_GROUP4, val);\n\n\tmt7531_setup_common(ds);\n\n\t \n\tret = mt7530_setup_vlan0(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tds->assisted_learning_on_cpu_port = true;\n\tds->mtu_enforcement_ingress = true;\n\n\treturn 0;\n}\n\nstatic void mt7530_mac_port_get_caps(struct dsa_switch *ds, int port,\n\t\t\t\t     struct phylink_config *config)\n{\n\tswitch (port) {\n\tcase 0 ... 4:  \n\t\t__set_bit(PHY_INTERFACE_MODE_GMII,\n\t\t\t  config->supported_interfaces);\n\t\tbreak;\n\n\tcase 5:  \n\t\tphy_interface_set_rgmii(config->supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_MII,\n\t\t\t  config->supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_GMII,\n\t\t\t  config->supported_interfaces);\n\t\tbreak;\n\n\tcase 6:  \n\t\t__set_bit(PHY_INTERFACE_MODE_RGMII,\n\t\t\t  config->supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_TRGMII,\n\t\t\t  config->supported_interfaces);\n\t\tbreak;\n\t}\n}\n\nstatic bool mt7531_is_rgmii_port(struct mt7530_priv *priv, u32 port)\n{\n\treturn (port == 5) && (priv->p5_intf_sel != P5_INTF_SEL_GMAC5_SGMII);\n}\n\nstatic void mt7531_mac_port_get_caps(struct dsa_switch *ds, int port,\n\t\t\t\t     struct phylink_config *config)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\n\tswitch (port) {\n\tcase 0 ... 4:  \n\t\t__set_bit(PHY_INTERFACE_MODE_GMII,\n\t\t\t  config->supported_interfaces);\n\t\tbreak;\n\n\tcase 5:  \n\t\tif (mt7531_is_rgmii_port(priv, port)) {\n\t\t\tphy_interface_set_rgmii(config->supported_interfaces);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\n\tcase 6:  \n\t\t__set_bit(PHY_INTERFACE_MODE_SGMII,\n\t\t\t  config->supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_1000BASEX,\n\t\t\t  config->supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_2500BASEX,\n\t\t\t  config->supported_interfaces);\n\n\t\tconfig->mac_capabilities |= MAC_2500FD;\n\t\tbreak;\n\t}\n}\n\nstatic void mt7988_mac_port_get_caps(struct dsa_switch *ds, int port,\n\t\t\t\t     struct phylink_config *config)\n{\n\tphy_interface_zero(config->supported_interfaces);\n\n\tswitch (port) {\n\tcase 0 ... 4:  \n\t\t__set_bit(PHY_INTERFACE_MODE_INTERNAL,\n\t\t\t  config->supported_interfaces);\n\t\tbreak;\n\n\tcase 6:\n\t\t__set_bit(PHY_INTERFACE_MODE_INTERNAL,\n\t\t\t  config->supported_interfaces);\n\t\tconfig->mac_capabilities = MAC_ASYM_PAUSE | MAC_SYM_PAUSE |\n\t\t\t\t\t   MAC_10000FD;\n\t}\n}\n\nstatic int\nmt753x_pad_setup(struct dsa_switch *ds, const struct phylink_link_state *state)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\n\treturn priv->info->pad_setup(ds, state->interface);\n}\n\nstatic int\nmt7530_mac_config(struct dsa_switch *ds, int port, unsigned int mode,\n\t\t  phy_interface_t interface)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\n\t \n\tif (port != 5)\n\t\treturn 0;\n\n\tmt7530_setup_port5(priv->ds, interface);\n\n\treturn 0;\n}\n\nstatic int mt7531_rgmii_setup(struct mt7530_priv *priv, u32 port,\n\t\t\t      phy_interface_t interface,\n\t\t\t      struct phy_device *phydev)\n{\n\tu32 val;\n\n\tif (!mt7531_is_rgmii_port(priv, port)) {\n\t\tdev_err(priv->dev, \"RGMII mode is not available for port %d\\n\",\n\t\t\tport);\n\t\treturn -EINVAL;\n\t}\n\n\tval = mt7530_read(priv, MT7531_CLKGEN_CTRL);\n\tval |= GP_CLK_EN;\n\tval &= ~GP_MODE_MASK;\n\tval |= GP_MODE(MT7531_GP_MODE_RGMII);\n\tval &= ~CLK_SKEW_IN_MASK;\n\tval |= CLK_SKEW_IN(MT7531_CLK_SKEW_NO_CHG);\n\tval &= ~CLK_SKEW_OUT_MASK;\n\tval |= CLK_SKEW_OUT(MT7531_CLK_SKEW_NO_CHG);\n\tval |= TXCLK_NO_REVERSE | RXCLK_NO_DELAY;\n\n\t \n\tif (!phydev || phy_driver_is_genphy(phydev)) {\n\t\tval &= ~(TXCLK_NO_REVERSE | RXCLK_NO_DELAY);\n\t\tswitch (interface) {\n\t\tcase PHY_INTERFACE_MODE_RGMII:\n\t\t\tval |= TXCLK_NO_REVERSE;\n\t\t\tval |= RXCLK_NO_DELAY;\n\t\t\tbreak;\n\t\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\t\tval |= TXCLK_NO_REVERSE;\n\t\t\tbreak;\n\t\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\t\tval |= RXCLK_NO_DELAY;\n\t\t\tbreak;\n\t\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tmt7530_write(priv, MT7531_CLKGEN_CTRL, val);\n\n\treturn 0;\n}\n\nstatic bool mt753x_is_mac_port(u32 port)\n{\n\treturn (port == 5 || port == 6);\n}\n\nstatic int\nmt7988_mac_config(struct dsa_switch *ds, int port, unsigned int mode,\n\t\t  phy_interface_t interface)\n{\n\tif (dsa_is_cpu_port(ds, port) &&\n\t    interface == PHY_INTERFACE_MODE_INTERNAL)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic int\nmt7531_mac_config(struct dsa_switch *ds, int port, unsigned int mode,\n\t\t  phy_interface_t interface)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\tstruct phy_device *phydev;\n\tstruct dsa_port *dp;\n\n\tif (!mt753x_is_mac_port(port)) {\n\t\tdev_err(priv->dev, \"port %d is not a MAC port\\n\", port);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (interface) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tdp = dsa_to_port(ds, port);\n\t\tphydev = dp->slave->phydev;\n\t\treturn mt7531_rgmii_setup(priv, port, interface, phydev);\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_NA:\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\tcase PHY_INTERFACE_MODE_2500BASEX:\n\t\t \n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\nmt753x_mac_config(struct dsa_switch *ds, int port, unsigned int mode,\n\t\t  const struct phylink_link_state *state)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\n\treturn priv->info->mac_port_config(ds, port, mode, state->interface);\n}\n\nstatic struct phylink_pcs *\nmt753x_phylink_mac_select_pcs(struct dsa_switch *ds, int port,\n\t\t\t      phy_interface_t interface)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\n\tswitch (interface) {\n\tcase PHY_INTERFACE_MODE_TRGMII:\n\t\treturn &priv->pcs[port].pcs;\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\tcase PHY_INTERFACE_MODE_2500BASEX:\n\t\treturn priv->ports[port].sgmii_pcs;\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic void\nmt753x_phylink_mac_config(struct dsa_switch *ds, int port, unsigned int mode,\n\t\t\t  const struct phylink_link_state *state)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\tu32 mcr_cur, mcr_new;\n\n\tswitch (port) {\n\tcase 0 ... 4:  \n\t\tif (state->interface != PHY_INTERFACE_MODE_GMII &&\n\t\t    state->interface != PHY_INTERFACE_MODE_INTERNAL)\n\t\t\tgoto unsupported;\n\t\tbreak;\n\tcase 5:  \n\t\tif (priv->p5_interface == state->interface)\n\t\t\tbreak;\n\n\t\tif (mt753x_mac_config(ds, port, mode, state) < 0)\n\t\t\tgoto unsupported;\n\n\t\tif (priv->p5_intf_sel != P5_DISABLED)\n\t\t\tpriv->p5_interface = state->interface;\n\t\tbreak;\n\tcase 6:  \n\t\tif (priv->p6_interface == state->interface)\n\t\t\tbreak;\n\n\t\tmt753x_pad_setup(ds, state);\n\n\t\tif (mt753x_mac_config(ds, port, mode, state) < 0)\n\t\t\tgoto unsupported;\n\n\t\tpriv->p6_interface = state->interface;\n\t\tbreak;\n\tdefault:\nunsupported:\n\t\tdev_err(ds->dev, \"%s: unsupported %s port: %i\\n\",\n\t\t\t__func__, phy_modes(state->interface), port);\n\t\treturn;\n\t}\n\n\tmcr_cur = mt7530_read(priv, MT7530_PMCR_P(port));\n\tmcr_new = mcr_cur;\n\tmcr_new &= ~PMCR_LINK_SETTINGS_MASK;\n\tmcr_new |= PMCR_IFG_XMIT(1) | PMCR_MAC_MODE | PMCR_BACKOFF_EN |\n\t\t   PMCR_BACKPR_EN | PMCR_FORCE_MODE_ID(priv->id);\n\n\t \n\tif (port == 5 && dsa_is_user_port(ds, 5))\n\t\tmcr_new |= PMCR_EXT_PHY;\n\n\tif (mcr_new != mcr_cur)\n\t\tmt7530_write(priv, MT7530_PMCR_P(port), mcr_new);\n}\n\nstatic void mt753x_phylink_mac_link_down(struct dsa_switch *ds, int port,\n\t\t\t\t\t unsigned int mode,\n\t\t\t\t\t phy_interface_t interface)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\n\tmt7530_clear(priv, MT7530_PMCR_P(port), PMCR_LINK_SETTINGS_MASK);\n}\n\nstatic void mt753x_phylink_pcs_link_up(struct phylink_pcs *pcs,\n\t\t\t\t       unsigned int mode,\n\t\t\t\t       phy_interface_t interface,\n\t\t\t\t       int speed, int duplex)\n{\n\tif (pcs->ops->pcs_link_up)\n\t\tpcs->ops->pcs_link_up(pcs, mode, interface, speed, duplex);\n}\n\nstatic void mt753x_phylink_mac_link_up(struct dsa_switch *ds, int port,\n\t\t\t\t       unsigned int mode,\n\t\t\t\t       phy_interface_t interface,\n\t\t\t\t       struct phy_device *phydev,\n\t\t\t\t       int speed, int duplex,\n\t\t\t\t       bool tx_pause, bool rx_pause)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\tu32 mcr;\n\n\tmcr = PMCR_RX_EN | PMCR_TX_EN | PMCR_FORCE_LNK;\n\n\t \n\tif (interface == PHY_INTERFACE_MODE_INTERNAL ||\n\t    interface == PHY_INTERFACE_MODE_TRGMII ||\n\t    (phy_interface_mode_is_8023z(interface))) {\n\t\tspeed = SPEED_1000;\n\t\tduplex = DUPLEX_FULL;\n\t}\n\n\tswitch (speed) {\n\tcase SPEED_1000:\n\t\tmcr |= PMCR_FORCE_SPEED_1000;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tmcr |= PMCR_FORCE_SPEED_100;\n\t\tbreak;\n\t}\n\tif (duplex == DUPLEX_FULL) {\n\t\tmcr |= PMCR_FORCE_FDX;\n\t\tif (tx_pause)\n\t\t\tmcr |= PMCR_TX_FC_EN;\n\t\tif (rx_pause)\n\t\t\tmcr |= PMCR_RX_FC_EN;\n\t}\n\n\tif (mode == MLO_AN_PHY && phydev && phy_init_eee(phydev, false) >= 0) {\n\t\tswitch (speed) {\n\t\tcase SPEED_1000:\n\t\t\tmcr |= PMCR_FORCE_EEE1G;\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\tmcr |= PMCR_FORCE_EEE100;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmt7530_set(priv, MT7530_PMCR_P(port), mcr);\n}\n\nstatic int\nmt7531_cpu_port_config(struct dsa_switch *ds, int port)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\tphy_interface_t interface;\n\tint speed;\n\tint ret;\n\n\tswitch (port) {\n\tcase 5:\n\t\tif (mt7531_is_rgmii_port(priv, port))\n\t\t\tinterface = PHY_INTERFACE_MODE_RGMII;\n\t\telse\n\t\t\tinterface = PHY_INTERFACE_MODE_2500BASEX;\n\n\t\tpriv->p5_interface = interface;\n\t\tbreak;\n\tcase 6:\n\t\tinterface = PHY_INTERFACE_MODE_2500BASEX;\n\n\t\tpriv->p6_interface = interface;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (interface == PHY_INTERFACE_MODE_2500BASEX)\n\t\tspeed = SPEED_2500;\n\telse\n\t\tspeed = SPEED_1000;\n\n\tret = mt7531_mac_config(ds, port, MLO_AN_FIXED, interface);\n\tif (ret)\n\t\treturn ret;\n\tmt7530_write(priv, MT7530_PMCR_P(port),\n\t\t     PMCR_CPU_PORT_SETTING(priv->id));\n\tmt753x_phylink_pcs_link_up(&priv->pcs[port].pcs, MLO_AN_FIXED,\n\t\t\t\t   interface, speed, DUPLEX_FULL);\n\tmt753x_phylink_mac_link_up(ds, port, MLO_AN_FIXED, interface, NULL,\n\t\t\t\t   speed, DUPLEX_FULL, true, true);\n\n\treturn 0;\n}\n\nstatic int\nmt7988_cpu_port_config(struct dsa_switch *ds, int port)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\n\tmt7530_write(priv, MT7530_PMCR_P(port),\n\t\t     PMCR_CPU_PORT_SETTING(priv->id));\n\n\tmt753x_phylink_mac_link_up(ds, port, MLO_AN_FIXED,\n\t\t\t\t   PHY_INTERFACE_MODE_INTERNAL, NULL,\n\t\t\t\t   SPEED_10000, DUPLEX_FULL, true, true);\n\n\treturn 0;\n}\n\nstatic void mt753x_phylink_get_caps(struct dsa_switch *ds, int port,\n\t\t\t\t    struct phylink_config *config)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\n\t \n\tconfig->mac_capabilities = MAC_ASYM_PAUSE | MAC_SYM_PAUSE |\n\t\t\t\t   MAC_10 | MAC_100 | MAC_1000FD;\n\n\tpriv->info->mac_port_get_caps(ds, port, config);\n}\n\nstatic int mt753x_pcs_validate(struct phylink_pcs *pcs,\n\t\t\t       unsigned long *supported,\n\t\t\t       const struct phylink_link_state *state)\n{\n\t \n\tif (state->interface == PHY_INTERFACE_MODE_TRGMII ||\n\t    phy_interface_mode_is_8023z(state->interface))\n\t\tphylink_clear(supported, Autoneg);\n\n\treturn 0;\n}\n\nstatic void mt7530_pcs_get_state(struct phylink_pcs *pcs,\n\t\t\t\t struct phylink_link_state *state)\n{\n\tstruct mt7530_priv *priv = pcs_to_mt753x_pcs(pcs)->priv;\n\tint port = pcs_to_mt753x_pcs(pcs)->port;\n\tu32 pmsr;\n\n\tpmsr = mt7530_read(priv, MT7530_PMSR_P(port));\n\n\tstate->link = (pmsr & PMSR_LINK);\n\tstate->an_complete = state->link;\n\tstate->duplex = !!(pmsr & PMSR_DPX);\n\n\tswitch (pmsr & PMSR_SPEED_MASK) {\n\tcase PMSR_SPEED_10:\n\t\tstate->speed = SPEED_10;\n\t\tbreak;\n\tcase PMSR_SPEED_100:\n\t\tstate->speed = SPEED_100;\n\t\tbreak;\n\tcase PMSR_SPEED_1000:\n\t\tstate->speed = SPEED_1000;\n\t\tbreak;\n\tdefault:\n\t\tstate->speed = SPEED_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tstate->pause &= ~(MLO_PAUSE_RX | MLO_PAUSE_TX);\n\tif (pmsr & PMSR_RX_FC)\n\t\tstate->pause |= MLO_PAUSE_RX;\n\tif (pmsr & PMSR_TX_FC)\n\t\tstate->pause |= MLO_PAUSE_TX;\n}\n\nstatic int mt753x_pcs_config(struct phylink_pcs *pcs, unsigned int neg_mode,\n\t\t\t     phy_interface_t interface,\n\t\t\t     const unsigned long *advertising,\n\t\t\t     bool permit_pause_to_mac)\n{\n\treturn 0;\n}\n\nstatic void mt7530_pcs_an_restart(struct phylink_pcs *pcs)\n{\n}\n\nstatic const struct phylink_pcs_ops mt7530_pcs_ops = {\n\t.pcs_validate = mt753x_pcs_validate,\n\t.pcs_get_state = mt7530_pcs_get_state,\n\t.pcs_config = mt753x_pcs_config,\n\t.pcs_an_restart = mt7530_pcs_an_restart,\n};\n\nstatic int\nmt753x_setup(struct dsa_switch *ds)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\tint i, ret;\n\n\t \n\tfor (i = 0; i < priv->ds->num_ports; i++) {\n\t\tpriv->pcs[i].pcs.ops = priv->info->pcs_ops;\n\t\tpriv->pcs[i].pcs.neg_mode = true;\n\t\tpriv->pcs[i].priv = priv;\n\t\tpriv->pcs[i].port = i;\n\t}\n\n\tret = priv->info->sw_setup(ds);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7530_setup_irq(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mt7530_setup_mdio(priv);\n\tif (ret && priv->irq)\n\t\tmt7530_free_irq_common(priv);\n\n\tif (priv->create_sgmii) {\n\t\tret = priv->create_sgmii(priv, mt7531_dual_sgmii_supported(priv));\n\t\tif (ret && priv->irq)\n\t\t\tmt7530_free_irq(priv);\n\t}\n\n\treturn ret;\n}\n\nstatic int mt753x_get_mac_eee(struct dsa_switch *ds, int port,\n\t\t\t      struct ethtool_eee *e)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\tu32 eeecr = mt7530_read(priv, MT7530_PMEEECR_P(port));\n\n\te->tx_lpi_enabled = !(eeecr & LPI_MODE_EN);\n\te->tx_lpi_timer = GET_LPI_THRESH(eeecr);\n\n\treturn 0;\n}\n\nstatic int mt753x_set_mac_eee(struct dsa_switch *ds, int port,\n\t\t\t      struct ethtool_eee *e)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\tu32 set, mask = LPI_THRESH_MASK | LPI_MODE_EN;\n\n\tif (e->tx_lpi_timer > 0xFFF)\n\t\treturn -EINVAL;\n\n\tset = SET_LPI_THRESH(e->tx_lpi_timer);\n\tif (!e->tx_lpi_enabled)\n\t\t \n\t\tset |= LPI_MODE_EN;\n\tmt7530_rmw(priv, MT7530_PMEEECR_P(port), mask, set);\n\n\treturn 0;\n}\n\nstatic int mt7988_pad_setup(struct dsa_switch *ds, phy_interface_t interface)\n{\n\treturn 0;\n}\n\nstatic int mt7988_setup(struct dsa_switch *ds)\n{\n\tstruct mt7530_priv *priv = ds->priv;\n\n\t \n\treset_control_assert(priv->rstc);\n\tusleep_range(20, 50);\n\treset_control_deassert(priv->rstc);\n\tusleep_range(20, 50);\n\n\t \n\tmt7530_write(priv, MT7530_SYS_CTRL, SYS_CTRL_PHY_RST);\n\n\treturn mt7531_setup_common(ds);\n}\n\nconst struct dsa_switch_ops mt7530_switch_ops = {\n\t.get_tag_protocol\t= mtk_get_tag_protocol,\n\t.setup\t\t\t= mt753x_setup,\n\t.preferred_default_local_cpu_port = mt753x_preferred_default_local_cpu_port,\n\t.get_strings\t\t= mt7530_get_strings,\n\t.get_ethtool_stats\t= mt7530_get_ethtool_stats,\n\t.get_sset_count\t\t= mt7530_get_sset_count,\n\t.set_ageing_time\t= mt7530_set_ageing_time,\n\t.port_enable\t\t= mt7530_port_enable,\n\t.port_disable\t\t= mt7530_port_disable,\n\t.port_change_mtu\t= mt7530_port_change_mtu,\n\t.port_max_mtu\t\t= mt7530_port_max_mtu,\n\t.port_stp_state_set\t= mt7530_stp_state_set,\n\t.port_pre_bridge_flags\t= mt7530_port_pre_bridge_flags,\n\t.port_bridge_flags\t= mt7530_port_bridge_flags,\n\t.port_bridge_join\t= mt7530_port_bridge_join,\n\t.port_bridge_leave\t= mt7530_port_bridge_leave,\n\t.port_fdb_add\t\t= mt7530_port_fdb_add,\n\t.port_fdb_del\t\t= mt7530_port_fdb_del,\n\t.port_fdb_dump\t\t= mt7530_port_fdb_dump,\n\t.port_mdb_add\t\t= mt7530_port_mdb_add,\n\t.port_mdb_del\t\t= mt7530_port_mdb_del,\n\t.port_vlan_filtering\t= mt7530_port_vlan_filtering,\n\t.port_vlan_add\t\t= mt7530_port_vlan_add,\n\t.port_vlan_del\t\t= mt7530_port_vlan_del,\n\t.port_mirror_add\t= mt753x_port_mirror_add,\n\t.port_mirror_del\t= mt753x_port_mirror_del,\n\t.phylink_get_caps\t= mt753x_phylink_get_caps,\n\t.phylink_mac_select_pcs\t= mt753x_phylink_mac_select_pcs,\n\t.phylink_mac_config\t= mt753x_phylink_mac_config,\n\t.phylink_mac_link_down\t= mt753x_phylink_mac_link_down,\n\t.phylink_mac_link_up\t= mt753x_phylink_mac_link_up,\n\t.get_mac_eee\t\t= mt753x_get_mac_eee,\n\t.set_mac_eee\t\t= mt753x_set_mac_eee,\n};\nEXPORT_SYMBOL_GPL(mt7530_switch_ops);\n\nconst struct mt753x_info mt753x_table[] = {\n\t[ID_MT7621] = {\n\t\t.id = ID_MT7621,\n\t\t.pcs_ops = &mt7530_pcs_ops,\n\t\t.sw_setup = mt7530_setup,\n\t\t.phy_read_c22 = mt7530_phy_read_c22,\n\t\t.phy_write_c22 = mt7530_phy_write_c22,\n\t\t.phy_read_c45 = mt7530_phy_read_c45,\n\t\t.phy_write_c45 = mt7530_phy_write_c45,\n\t\t.pad_setup = mt7530_pad_clk_setup,\n\t\t.mac_port_get_caps = mt7530_mac_port_get_caps,\n\t\t.mac_port_config = mt7530_mac_config,\n\t},\n\t[ID_MT7530] = {\n\t\t.id = ID_MT7530,\n\t\t.pcs_ops = &mt7530_pcs_ops,\n\t\t.sw_setup = mt7530_setup,\n\t\t.phy_read_c22 = mt7530_phy_read_c22,\n\t\t.phy_write_c22 = mt7530_phy_write_c22,\n\t\t.phy_read_c45 = mt7530_phy_read_c45,\n\t\t.phy_write_c45 = mt7530_phy_write_c45,\n\t\t.pad_setup = mt7530_pad_clk_setup,\n\t\t.mac_port_get_caps = mt7530_mac_port_get_caps,\n\t\t.mac_port_config = mt7530_mac_config,\n\t},\n\t[ID_MT7531] = {\n\t\t.id = ID_MT7531,\n\t\t.pcs_ops = &mt7530_pcs_ops,\n\t\t.sw_setup = mt7531_setup,\n\t\t.phy_read_c22 = mt7531_ind_c22_phy_read,\n\t\t.phy_write_c22 = mt7531_ind_c22_phy_write,\n\t\t.phy_read_c45 = mt7531_ind_c45_phy_read,\n\t\t.phy_write_c45 = mt7531_ind_c45_phy_write,\n\t\t.pad_setup = mt7531_pad_setup,\n\t\t.cpu_port_config = mt7531_cpu_port_config,\n\t\t.mac_port_get_caps = mt7531_mac_port_get_caps,\n\t\t.mac_port_config = mt7531_mac_config,\n\t},\n\t[ID_MT7988] = {\n\t\t.id = ID_MT7988,\n\t\t.pcs_ops = &mt7530_pcs_ops,\n\t\t.sw_setup = mt7988_setup,\n\t\t.phy_read_c22 = mt7531_ind_c22_phy_read,\n\t\t.phy_write_c22 = mt7531_ind_c22_phy_write,\n\t\t.phy_read_c45 = mt7531_ind_c45_phy_read,\n\t\t.phy_write_c45 = mt7531_ind_c45_phy_write,\n\t\t.pad_setup = mt7988_pad_setup,\n\t\t.cpu_port_config = mt7988_cpu_port_config,\n\t\t.mac_port_get_caps = mt7988_mac_port_get_caps,\n\t\t.mac_port_config = mt7988_mac_config,\n\t},\n};\nEXPORT_SYMBOL_GPL(mt753x_table);\n\nint\nmt7530_probe_common(struct mt7530_priv *priv)\n{\n\tstruct device *dev = priv->dev;\n\n\tpriv->ds = devm_kzalloc(dev, sizeof(*priv->ds), GFP_KERNEL);\n\tif (!priv->ds)\n\t\treturn -ENOMEM;\n\n\tpriv->ds->dev = dev;\n\tpriv->ds->num_ports = MT7530_NUM_PORTS;\n\n\t \n\tpriv->info = of_device_get_match_data(dev);\n\tif (!priv->info)\n\t\treturn -EINVAL;\n\n\t \n\tif (!priv->info->sw_setup || !priv->info->pad_setup ||\n\t    !priv->info->phy_read_c22 || !priv->info->phy_write_c22 ||\n\t    !priv->info->mac_port_get_caps ||\n\t    !priv->info->mac_port_config)\n\t\treturn -EINVAL;\n\n\tpriv->id = priv->info->id;\n\tpriv->dev = dev;\n\tpriv->ds->priv = priv;\n\tpriv->ds->ops = &mt7530_switch_ops;\n\tmutex_init(&priv->reg_mutex);\n\tdev_set_drvdata(dev, priv);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mt7530_probe_common);\n\nvoid\nmt7530_remove_common(struct mt7530_priv *priv)\n{\n\tif (priv->irq)\n\t\tmt7530_free_irq(priv);\n\n\tdsa_unregister_switch(priv->ds);\n\n\tmutex_destroy(&priv->reg_mutex);\n}\nEXPORT_SYMBOL_GPL(mt7530_remove_common);\n\nMODULE_AUTHOR(\"Sean Wang <sean.wang@mediatek.com>\");\nMODULE_DESCRIPTION(\"Driver for Mediatek MT7530 Switch\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}