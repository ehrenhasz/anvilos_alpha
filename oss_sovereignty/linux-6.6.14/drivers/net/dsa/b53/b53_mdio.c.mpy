{
  "module_name": "b53_mdio.c",
  "hash_id": "6414f7733842aa998e734b3e60ff913a6f253a7a3ae91e00dcd338ad57ed3f7b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/b53/b53_mdio.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/phy.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/delay.h>\n#include <linux/brcmphy.h>\n#include <linux/rtnetlink.h>\n#include <net/dsa.h>\n\n#include \"b53_priv.h\"\n\n \n#define REG_MII_PAGE    0x10     \n#define REG_MII_ADDR    0x11     \n#define REG_MII_DATA0   0x18     \n#define REG_MII_DATA1   0x19     \n#define REG_MII_DATA2   0x1a     \n#define REG_MII_DATA3   0x1b     \n\n#define REG_MII_PAGE_ENABLE     BIT(0)\n#define REG_MII_ADDR_WRITE      BIT(0)\n#define REG_MII_ADDR_READ       BIT(1)\n\nstatic int b53_mdio_op(struct b53_device *dev, u8 page, u8 reg, u16 op)\n{\n\tint i;\n\tu16 v;\n\tint ret;\n\tstruct mii_bus *bus = dev->priv;\n\n\tif (dev->current_page != page) {\n\t\t \n\t\tv = (page << 8) | REG_MII_PAGE_ENABLE;\n\t\tret = mdiobus_write_nested(bus, BRCM_PSEUDO_PHY_ADDR,\n\t\t\t\t\t   REG_MII_PAGE, v);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdev->current_page = page;\n\t}\n\n\t \n\tv = (reg << 8) | op;\n\tret = mdiobus_write_nested(bus, BRCM_PSEUDO_PHY_ADDR, REG_MII_ADDR, v);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < 5; ++i) {\n\t\tv = mdiobus_read_nested(bus, BRCM_PSEUDO_PHY_ADDR,\n\t\t\t\t\tREG_MII_ADDR);\n\t\tif (!(v & (REG_MII_ADDR_WRITE | REG_MII_ADDR_READ)))\n\t\t\tbreak;\n\t\tusleep_range(10, 100);\n\t}\n\n\tif (WARN_ON(i == 5))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int b53_mdio_read8(struct b53_device *dev, u8 page, u8 reg, u8 *val)\n{\n\tstruct mii_bus *bus = dev->priv;\n\tint ret;\n\n\tret = b53_mdio_op(dev, page, reg, REG_MII_ADDR_READ);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = mdiobus_read_nested(bus, BRCM_PSEUDO_PHY_ADDR,\n\t\t\t\t   REG_MII_DATA0) & 0xff;\n\n\treturn 0;\n}\n\nstatic int b53_mdio_read16(struct b53_device *dev, u8 page, u8 reg, u16 *val)\n{\n\tstruct mii_bus *bus = dev->priv;\n\tint ret;\n\n\tret = b53_mdio_op(dev, page, reg, REG_MII_ADDR_READ);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = mdiobus_read_nested(bus, BRCM_PSEUDO_PHY_ADDR, REG_MII_DATA0);\n\n\treturn 0;\n}\n\nstatic int b53_mdio_read32(struct b53_device *dev, u8 page, u8 reg, u32 *val)\n{\n\tstruct mii_bus *bus = dev->priv;\n\tint ret;\n\n\tret = b53_mdio_op(dev, page, reg, REG_MII_ADDR_READ);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = mdiobus_read_nested(bus, BRCM_PSEUDO_PHY_ADDR, REG_MII_DATA0);\n\t*val |= mdiobus_read_nested(bus, BRCM_PSEUDO_PHY_ADDR,\n\t\t\t\t    REG_MII_DATA1) << 16;\n\n\treturn 0;\n}\n\nstatic int b53_mdio_read48(struct b53_device *dev, u8 page, u8 reg, u64 *val)\n{\n\tstruct mii_bus *bus = dev->priv;\n\tu64 temp = 0;\n\tint i;\n\tint ret;\n\n\tret = b53_mdio_op(dev, page, reg, REG_MII_ADDR_READ);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 2; i >= 0; i--) {\n\t\ttemp <<= 16;\n\t\ttemp |= mdiobus_read_nested(bus, BRCM_PSEUDO_PHY_ADDR,\n\t\t\t\t     REG_MII_DATA0 + i);\n\t}\n\n\t*val = temp;\n\n\treturn 0;\n}\n\nstatic int b53_mdio_read64(struct b53_device *dev, u8 page, u8 reg, u64 *val)\n{\n\tstruct mii_bus *bus = dev->priv;\n\tu64 temp = 0;\n\tint i;\n\tint ret;\n\n\tret = b53_mdio_op(dev, page, reg, REG_MII_ADDR_READ);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 3; i >= 0; i--) {\n\t\ttemp <<= 16;\n\t\ttemp |= mdiobus_read_nested(bus, BRCM_PSEUDO_PHY_ADDR,\n\t\t\t\t\t    REG_MII_DATA0 + i);\n\t}\n\n\t*val = temp;\n\n\treturn 0;\n}\n\nstatic int b53_mdio_write8(struct b53_device *dev, u8 page, u8 reg, u8 value)\n{\n\tstruct mii_bus *bus = dev->priv;\n\tint ret;\n\n\tret = mdiobus_write_nested(bus, BRCM_PSEUDO_PHY_ADDR,\n\t\t\t\t   REG_MII_DATA0, value);\n\tif (ret)\n\t\treturn ret;\n\n\treturn b53_mdio_op(dev, page, reg, REG_MII_ADDR_WRITE);\n}\n\nstatic int b53_mdio_write16(struct b53_device *dev, u8 page, u8 reg,\n\t\t\t    u16 value)\n{\n\tstruct mii_bus *bus = dev->priv;\n\tint ret;\n\n\tret = mdiobus_write_nested(bus, BRCM_PSEUDO_PHY_ADDR,\n\t\t\t\t   REG_MII_DATA0, value);\n\tif (ret)\n\t\treturn ret;\n\n\treturn b53_mdio_op(dev, page, reg, REG_MII_ADDR_WRITE);\n}\n\nstatic int b53_mdio_write32(struct b53_device *dev, u8 page, u8 reg,\n\t\t\t    u32 value)\n{\n\tstruct mii_bus *bus = dev->priv;\n\tunsigned int i;\n\tu32 temp = value;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tint ret = mdiobus_write_nested(bus, BRCM_PSEUDO_PHY_ADDR,\n\t\t\t\t\t       REG_MII_DATA0 + i,\n\t\t\t\t\t       temp & 0xffff);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\ttemp >>= 16;\n\t}\n\n\treturn b53_mdio_op(dev, page, reg, REG_MII_ADDR_WRITE);\n}\n\nstatic int b53_mdio_write48(struct b53_device *dev, u8 page, u8 reg,\n\t\t\t    u64 value)\n{\n\tstruct mii_bus *bus = dev->priv;\n\tunsigned int i;\n\tu64 temp = value;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tint ret = mdiobus_write_nested(bus, BRCM_PSEUDO_PHY_ADDR,\n\t\t\t\t\t       REG_MII_DATA0 + i,\n\t\t\t\t\t       temp & 0xffff);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\ttemp >>= 16;\n\t}\n\n\treturn b53_mdio_op(dev, page, reg, REG_MII_ADDR_WRITE);\n}\n\nstatic int b53_mdio_write64(struct b53_device *dev, u8 page, u8 reg,\n\t\t\t    u64 value)\n{\n\tstruct mii_bus *bus = dev->priv;\n\tunsigned int i;\n\tu64 temp = value;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tint ret = mdiobus_write_nested(bus, BRCM_PSEUDO_PHY_ADDR,\n\t\t\t\t\t       REG_MII_DATA0 + i,\n\t\t\t\t\t       temp & 0xffff);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\ttemp >>= 16;\n\t}\n\n\treturn b53_mdio_op(dev, page, reg, REG_MII_ADDR_WRITE);\n}\n\nstatic int b53_mdio_phy_read16(struct b53_device *dev, int addr, int reg,\n\t\t\t       u16 *value)\n{\n\tstruct mii_bus *bus = dev->priv;\n\n\t*value = mdiobus_read_nested(bus, addr, reg);\n\n\treturn 0;\n}\n\nstatic int b53_mdio_phy_write16(struct b53_device *dev, int addr, int reg,\n\t\t\t\tu16 value)\n{\n\tstruct mii_bus *bus = dev->bus;\n\n\treturn mdiobus_write_nested(bus, addr, reg, value);\n}\n\nstatic const struct b53_io_ops b53_mdio_ops = {\n\t.read8 = b53_mdio_read8,\n\t.read16 = b53_mdio_read16,\n\t.read32 = b53_mdio_read32,\n\t.read48 = b53_mdio_read48,\n\t.read64 = b53_mdio_read64,\n\t.write8 = b53_mdio_write8,\n\t.write16 = b53_mdio_write16,\n\t.write32 = b53_mdio_write32,\n\t.write48 = b53_mdio_write48,\n\t.write64 = b53_mdio_write64,\n\t.phy_read16 = b53_mdio_phy_read16,\n\t.phy_write16 = b53_mdio_phy_write16,\n};\n\n#define B53_BRCM_OUI_1\t0x0143bc00\n#define B53_BRCM_OUI_2\t0x03625c00\n#define B53_BRCM_OUI_3\t0x00406000\n#define B53_BRCM_OUI_4\t0x01410c00\n#define B53_BRCM_OUI_5\t0xae025000\n\nstatic int b53_mdio_probe(struct mdio_device *mdiodev)\n{\n\tstruct b53_device *dev;\n\tu32 phy_id;\n\tint ret;\n\n\t \n\tif (mdiodev->addr != BRCM_PSEUDO_PHY_ADDR && mdiodev->addr != 0) {\n\t\tdev_err(&mdiodev->dev, \"leaving address %d to PHY\\n\",\n\t\t\tmdiodev->addr);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tphy_id = mdiobus_read(mdiodev->bus, 0, 2) << 16;\n\tphy_id |= mdiobus_read(mdiodev->bus, 0, 3);\n\n\t \n\tif ((phy_id & 0xfffffc00) != B53_BRCM_OUI_1 &&\n\t    (phy_id & 0xfffffc00) != B53_BRCM_OUI_2 &&\n\t    (phy_id & 0xfffffc00) != B53_BRCM_OUI_3 &&\n\t    (phy_id & 0xfffffc00) != B53_BRCM_OUI_4 &&\n\t    (phy_id & 0xfffffc00) != B53_BRCM_OUI_5) {\n\t\tdev_err(&mdiodev->dev, \"Unsupported device: 0x%08x\\n\", phy_id);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (of_machine_is_compatible(\"brcm,bcm7445d0\") &&\n\t    strcmp(mdiodev->bus->name, \"sf2 slave mii\"))\n\t\treturn -EPROBE_DEFER;\n\n\tdev = b53_switch_alloc(&mdiodev->dev, &b53_mdio_ops, mdiodev->bus);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\t \n\tdev->current_page = 0xff;\n\tdev->bus = mdiodev->bus;\n\n\tdev_set_drvdata(&mdiodev->dev, dev);\n\n\tret = b53_switch_register(dev);\n\tif (ret) {\n\t\tdev_err(&mdiodev->dev, \"failed to register switch: %i\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void b53_mdio_remove(struct mdio_device *mdiodev)\n{\n\tstruct b53_device *dev = dev_get_drvdata(&mdiodev->dev);\n\n\tif (!dev)\n\t\treturn;\n\n\tb53_switch_remove(dev);\n}\n\nstatic void b53_mdio_shutdown(struct mdio_device *mdiodev)\n{\n\tstruct b53_device *dev = dev_get_drvdata(&mdiodev->dev);\n\n\tif (!dev)\n\t\treturn;\n\n\tb53_switch_shutdown(dev);\n\n\tdev_set_drvdata(&mdiodev->dev, NULL);\n}\n\nstatic const struct of_device_id b53_of_match[] = {\n\t{ .compatible = \"brcm,bcm5325\" },\n\t{ .compatible = \"brcm,bcm53115\" },\n\t{ .compatible = \"brcm,bcm53125\" },\n\t{ .compatible = \"brcm,bcm53128\" },\n\t{ .compatible = \"brcm,bcm53134\" },\n\t{ .compatible = \"brcm,bcm5365\" },\n\t{ .compatible = \"brcm,bcm5389\" },\n\t{ .compatible = \"brcm,bcm5395\" },\n\t{ .compatible = \"brcm,bcm5397\" },\n\t{ .compatible = \"brcm,bcm5398\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, b53_of_match);\n\nstatic struct mdio_driver b53_mdio_driver = {\n\t.probe\t= b53_mdio_probe,\n\t.remove\t= b53_mdio_remove,\n\t.shutdown = b53_mdio_shutdown,\n\t.mdiodrv.driver = {\n\t\t.name = \"bcm53xx\",\n\t\t.of_match_table = b53_of_match,\n\t},\n};\nmdio_module_driver(b53_mdio_driver);\n\nMODULE_DESCRIPTION(\"B53 MDIO access driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}