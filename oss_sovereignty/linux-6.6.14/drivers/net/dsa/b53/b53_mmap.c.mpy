{
  "module_name": "b53_mmap.c",
  "hash_id": "6c2df7bcb4b4f514ff7717c04afb4cc12181a3647d7af0f36ecf6a54c4fb5f01",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/b53/b53_mmap.c",
  "human_readable_source": " \n\n#include <linux/bits.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/b53.h>\n\n#include \"b53_priv.h\"\n\nstruct b53_mmap_priv {\n\tvoid __iomem *regs;\n};\n\nstatic int b53_mmap_read8(struct b53_device *dev, u8 page, u8 reg, u8 *val)\n{\n\tstruct b53_mmap_priv *priv = dev->priv;\n\tvoid __iomem *regs = priv->regs;\n\n\t*val = readb(regs + (page << 8) + reg);\n\n\treturn 0;\n}\n\nstatic int b53_mmap_read16(struct b53_device *dev, u8 page, u8 reg, u16 *val)\n{\n\tstruct b53_mmap_priv *priv = dev->priv;\n\tvoid __iomem *regs = priv->regs;\n\n\tif (WARN_ON(reg % 2))\n\t\treturn -EINVAL;\n\n\tif (dev->pdata && dev->pdata->big_endian)\n\t\t*val = ioread16be(regs + (page << 8) + reg);\n\telse\n\t\t*val = readw(regs + (page << 8) + reg);\n\n\treturn 0;\n}\n\nstatic int b53_mmap_read32(struct b53_device *dev, u8 page, u8 reg, u32 *val)\n{\n\tstruct b53_mmap_priv *priv = dev->priv;\n\tvoid __iomem *regs = priv->regs;\n\n\tif (WARN_ON(reg % 4))\n\t\treturn -EINVAL;\n\n\tif (dev->pdata && dev->pdata->big_endian)\n\t\t*val = ioread32be(regs + (page << 8) + reg);\n\telse\n\t\t*val = readl(regs + (page << 8) + reg);\n\n\treturn 0;\n}\n\nstatic int b53_mmap_read48(struct b53_device *dev, u8 page, u8 reg, u64 *val)\n{\n\tstruct b53_mmap_priv *priv = dev->priv;\n\tvoid __iomem *regs = priv->regs;\n\n\tif (WARN_ON(reg % 2))\n\t\treturn -EINVAL;\n\n\tif (reg % 4) {\n\t\tu16 lo;\n\t\tu32 hi;\n\n\t\tif (dev->pdata && dev->pdata->big_endian) {\n\t\t\tlo = ioread16be(regs + (page << 8) + reg);\n\t\t\thi = ioread32be(regs + (page << 8) + reg + 2);\n\t\t} else {\n\t\t\tlo = readw(regs + (page << 8) + reg);\n\t\t\thi = readl(regs + (page << 8) + reg + 2);\n\t\t}\n\n\t\t*val = ((u64)hi << 16) | lo;\n\t} else {\n\t\tu32 lo;\n\t\tu16 hi;\n\n\t\tif (dev->pdata && dev->pdata->big_endian) {\n\t\t\tlo = ioread32be(regs + (page << 8) + reg);\n\t\t\thi = ioread16be(regs + (page << 8) + reg + 4);\n\t\t} else {\n\t\t\tlo = readl(regs + (page << 8) + reg);\n\t\t\thi = readw(regs + (page << 8) + reg + 4);\n\t\t}\n\n\t\t*val = ((u64)hi << 32) | lo;\n\t}\n\n\treturn 0;\n}\n\nstatic int b53_mmap_read64(struct b53_device *dev, u8 page, u8 reg, u64 *val)\n{\n\tstruct b53_mmap_priv *priv = dev->priv;\n\tvoid __iomem *regs = priv->regs;\n\tu32 hi, lo;\n\n\tif (WARN_ON(reg % 4))\n\t\treturn -EINVAL;\n\n\tif (dev->pdata && dev->pdata->big_endian) {\n\t\tlo = ioread32be(regs + (page << 8) + reg);\n\t\thi = ioread32be(regs + (page << 8) + reg + 4);\n\t} else {\n\t\tlo = readl(regs + (page << 8) + reg);\n\t\thi = readl(regs + (page << 8) + reg + 4);\n\t}\n\n\t*val = ((u64)hi << 32) | lo;\n\n\treturn 0;\n}\n\nstatic int b53_mmap_write8(struct b53_device *dev, u8 page, u8 reg, u8 value)\n{\n\tstruct b53_mmap_priv *priv = dev->priv;\n\tvoid __iomem *regs = priv->regs;\n\n\twriteb(value, regs + (page << 8) + reg);\n\n\treturn 0;\n}\n\nstatic int b53_mmap_write16(struct b53_device *dev, u8 page, u8 reg,\n\t\t\t    u16 value)\n{\n\tstruct b53_mmap_priv *priv = dev->priv;\n\tvoid __iomem *regs = priv->regs;\n\n\tif (WARN_ON(reg % 2))\n\t\treturn -EINVAL;\n\n\tif (dev->pdata && dev->pdata->big_endian)\n\t\tiowrite16be(value, regs + (page << 8) + reg);\n\telse\n\t\twritew(value, regs + (page << 8) + reg);\n\n\treturn 0;\n}\n\nstatic int b53_mmap_write32(struct b53_device *dev, u8 page, u8 reg,\n\t\t\t    u32 value)\n{\n\tstruct b53_mmap_priv *priv = dev->priv;\n\tvoid __iomem *regs = priv->regs;\n\n\tif (WARN_ON(reg % 4))\n\t\treturn -EINVAL;\n\n\tif (dev->pdata && dev->pdata->big_endian)\n\t\tiowrite32be(value, regs + (page << 8) + reg);\n\telse\n\t\twritel(value, regs + (page << 8) + reg);\n\n\treturn 0;\n}\n\nstatic int b53_mmap_write48(struct b53_device *dev, u8 page, u8 reg,\n\t\t\t    u64 value)\n{\n\tif (WARN_ON(reg % 2))\n\t\treturn -EINVAL;\n\n\tif (reg % 4) {\n\t\tu32 hi = (u32)(value >> 16);\n\t\tu16 lo = (u16)value;\n\n\t\tb53_mmap_write16(dev, page, reg, lo);\n\t\tb53_mmap_write32(dev, page, reg + 2, hi);\n\t} else {\n\t\tu16 hi = (u16)(value >> 32);\n\t\tu32 lo = (u32)value;\n\n\t\tb53_mmap_write32(dev, page, reg, lo);\n\t\tb53_mmap_write16(dev, page, reg + 4, hi);\n\t}\n\n\treturn 0;\n}\n\nstatic int b53_mmap_write64(struct b53_device *dev, u8 page, u8 reg,\n\t\t\t    u64 value)\n{\n\tu32 hi, lo;\n\n\thi = upper_32_bits(value);\n\tlo = lower_32_bits(value);\n\n\tif (WARN_ON(reg % 4))\n\t\treturn -EINVAL;\n\n\tb53_mmap_write32(dev, page, reg, lo);\n\tb53_mmap_write32(dev, page, reg + 4, hi);\n\n\treturn 0;\n}\n\nstatic int b53_mmap_phy_read16(struct b53_device *dev, int addr, int reg,\n\t\t\t       u16 *value)\n{\n\treturn -EIO;\n}\n\nstatic int b53_mmap_phy_write16(struct b53_device *dev, int addr, int reg,\n\t\t\t\tu16 value)\n{\n\treturn -EIO;\n}\n\nstatic const struct b53_io_ops b53_mmap_ops = {\n\t.read8 = b53_mmap_read8,\n\t.read16 = b53_mmap_read16,\n\t.read32 = b53_mmap_read32,\n\t.read48 = b53_mmap_read48,\n\t.read64 = b53_mmap_read64,\n\t.write8 = b53_mmap_write8,\n\t.write16 = b53_mmap_write16,\n\t.write32 = b53_mmap_write32,\n\t.write48 = b53_mmap_write48,\n\t.write64 = b53_mmap_write64,\n\t.phy_read16 = b53_mmap_phy_read16,\n\t.phy_write16 = b53_mmap_phy_write16,\n};\n\nstatic int b53_mmap_probe_of(struct platform_device *pdev,\n\t\t\t     struct b53_platform_data **ppdata)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *of_ports, *of_port;\n\tstruct device *dev = &pdev->dev;\n\tstruct b53_platform_data *pdata;\n\tvoid __iomem *mem;\n\n\tmem = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(mem))\n\t\treturn PTR_ERR(mem);\n\n\tpdata = devm_kzalloc(dev, sizeof(struct b53_platform_data),\n\t\t\t     GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tpdata->regs = mem;\n\tpdata->chip_id = (u32)(unsigned long)device_get_match_data(dev);\n\tpdata->big_endian = of_property_read_bool(np, \"big-endian\");\n\n\tof_ports = of_get_child_by_name(np, \"ports\");\n\tif (!of_ports) {\n\t\tdev_err(dev, \"no ports child node found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor_each_available_child_of_node(of_ports, of_port) {\n\t\tu32 reg;\n\n\t\tif (of_property_read_u32(of_port, \"reg\", &reg))\n\t\t\tcontinue;\n\n\t\tif (reg < B53_N_PORTS)\n\t\t\tpdata->enabled_ports |= BIT(reg);\n\t}\n\n\tof_node_put(of_ports);\n\t*ppdata = pdata;\n\n\treturn 0;\n}\n\nstatic int b53_mmap_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct b53_platform_data *pdata = pdev->dev.platform_data;\n\tstruct b53_mmap_priv *priv;\n\tstruct b53_device *dev;\n\tint ret;\n\n\tif (!pdata && np) {\n\t\tret = b53_mmap_probe_of(pdev, &pdata);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"OF probe error\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->regs = pdata->regs;\n\n\tdev = b53_switch_alloc(&pdev->dev, &b53_mmap_ops, priv);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->pdata = pdata;\n\n\tplatform_set_drvdata(pdev, dev);\n\n\treturn b53_switch_register(dev);\n}\n\nstatic int b53_mmap_remove(struct platform_device *pdev)\n{\n\tstruct b53_device *dev = platform_get_drvdata(pdev);\n\n\tif (dev)\n\t\tb53_switch_remove(dev);\n\n\treturn 0;\n}\n\nstatic void b53_mmap_shutdown(struct platform_device *pdev)\n{\n\tstruct b53_device *dev = platform_get_drvdata(pdev);\n\n\tif (dev)\n\t\tb53_switch_shutdown(dev);\n\n\tplatform_set_drvdata(pdev, NULL);\n}\n\nstatic const struct of_device_id b53_mmap_of_table[] = {\n\t{\n\t\t.compatible = \"brcm,bcm3384-switch\",\n\t\t.data = (void *)BCM63XX_DEVICE_ID,\n\t}, {\n\t\t.compatible = \"brcm,bcm6318-switch\",\n\t\t.data = (void *)BCM63268_DEVICE_ID,\n\t}, {\n\t\t.compatible = \"brcm,bcm6328-switch\",\n\t\t.data = (void *)BCM63XX_DEVICE_ID,\n\t}, {\n\t\t.compatible = \"brcm,bcm6362-switch\",\n\t\t.data = (void *)BCM63XX_DEVICE_ID,\n\t}, {\n\t\t.compatible = \"brcm,bcm6368-switch\",\n\t\t.data = (void *)BCM63XX_DEVICE_ID,\n\t}, {\n\t\t.compatible = \"brcm,bcm63268-switch\",\n\t\t.data = (void *)BCM63268_DEVICE_ID,\n\t}, {\n\t\t.compatible = \"brcm,bcm63xx-switch\",\n\t\t.data = (void *)BCM63XX_DEVICE_ID,\n\t}, {   }\n};\nMODULE_DEVICE_TABLE(of, b53_mmap_of_table);\n\nstatic struct platform_driver b53_mmap_driver = {\n\t.probe = b53_mmap_probe,\n\t.remove = b53_mmap_remove,\n\t.shutdown = b53_mmap_shutdown,\n\t.driver = {\n\t\t.name = \"b53-switch\",\n\t\t.of_match_table = b53_mmap_of_table,\n\t},\n};\n\nmodule_platform_driver(b53_mmap_driver);\nMODULE_AUTHOR(\"Jonas Gorski <jogo@openwrt.org>\");\nMODULE_DESCRIPTION(\"B53 MMAP access driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}