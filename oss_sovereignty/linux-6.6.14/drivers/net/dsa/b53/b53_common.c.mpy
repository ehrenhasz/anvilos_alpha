{
  "module_name": "b53_common.c",
  "hash_id": "6cf7ebaaeb52b0f667024491e072f78591f77c6aeaeb1765fc79869c27518d19",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/b53/b53_common.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/gpio.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_data/b53.h>\n#include <linux/phy.h>\n#include <linux/phylink.h>\n#include <linux/etherdevice.h>\n#include <linux/if_bridge.h>\n#include <net/dsa.h>\n\n#include \"b53_regs.h\"\n#include \"b53_priv.h\"\n\nstruct b53_mib_desc {\n\tu8 size;\n\tu8 offset;\n\tconst char *name;\n};\n\n \nstatic const struct b53_mib_desc b53_mibs_65[] = {\n\t{ 8, 0x00, \"TxOctets\" },\n\t{ 4, 0x08, \"TxDropPkts\" },\n\t{ 4, 0x10, \"TxBroadcastPkts\" },\n\t{ 4, 0x14, \"TxMulticastPkts\" },\n\t{ 4, 0x18, \"TxUnicastPkts\" },\n\t{ 4, 0x1c, \"TxCollisions\" },\n\t{ 4, 0x20, \"TxSingleCollision\" },\n\t{ 4, 0x24, \"TxMultipleCollision\" },\n\t{ 4, 0x28, \"TxDeferredTransmit\" },\n\t{ 4, 0x2c, \"TxLateCollision\" },\n\t{ 4, 0x30, \"TxExcessiveCollision\" },\n\t{ 4, 0x38, \"TxPausePkts\" },\n\t{ 8, 0x44, \"RxOctets\" },\n\t{ 4, 0x4c, \"RxUndersizePkts\" },\n\t{ 4, 0x50, \"RxPausePkts\" },\n\t{ 4, 0x54, \"Pkts64Octets\" },\n\t{ 4, 0x58, \"Pkts65to127Octets\" },\n\t{ 4, 0x5c, \"Pkts128to255Octets\" },\n\t{ 4, 0x60, \"Pkts256to511Octets\" },\n\t{ 4, 0x64, \"Pkts512to1023Octets\" },\n\t{ 4, 0x68, \"Pkts1024to1522Octets\" },\n\t{ 4, 0x6c, \"RxOversizePkts\" },\n\t{ 4, 0x70, \"RxJabbers\" },\n\t{ 4, 0x74, \"RxAlignmentErrors\" },\n\t{ 4, 0x78, \"RxFCSErrors\" },\n\t{ 8, 0x7c, \"RxGoodOctets\" },\n\t{ 4, 0x84, \"RxDropPkts\" },\n\t{ 4, 0x88, \"RxUnicastPkts\" },\n\t{ 4, 0x8c, \"RxMulticastPkts\" },\n\t{ 4, 0x90, \"RxBroadcastPkts\" },\n\t{ 4, 0x94, \"RxSAChanges\" },\n\t{ 4, 0x98, \"RxFragments\" },\n};\n\n#define B53_MIBS_65_SIZE\tARRAY_SIZE(b53_mibs_65)\n\n \nstatic const struct b53_mib_desc b53_mibs_63xx[] = {\n\t{ 8, 0x00, \"TxOctets\" },\n\t{ 4, 0x08, \"TxDropPkts\" },\n\t{ 4, 0x0c, \"TxQoSPkts\" },\n\t{ 4, 0x10, \"TxBroadcastPkts\" },\n\t{ 4, 0x14, \"TxMulticastPkts\" },\n\t{ 4, 0x18, \"TxUnicastPkts\" },\n\t{ 4, 0x1c, \"TxCollisions\" },\n\t{ 4, 0x20, \"TxSingleCollision\" },\n\t{ 4, 0x24, \"TxMultipleCollision\" },\n\t{ 4, 0x28, \"TxDeferredTransmit\" },\n\t{ 4, 0x2c, \"TxLateCollision\" },\n\t{ 4, 0x30, \"TxExcessiveCollision\" },\n\t{ 4, 0x38, \"TxPausePkts\" },\n\t{ 8, 0x3c, \"TxQoSOctets\" },\n\t{ 8, 0x44, \"RxOctets\" },\n\t{ 4, 0x4c, \"RxUndersizePkts\" },\n\t{ 4, 0x50, \"RxPausePkts\" },\n\t{ 4, 0x54, \"Pkts64Octets\" },\n\t{ 4, 0x58, \"Pkts65to127Octets\" },\n\t{ 4, 0x5c, \"Pkts128to255Octets\" },\n\t{ 4, 0x60, \"Pkts256to511Octets\" },\n\t{ 4, 0x64, \"Pkts512to1023Octets\" },\n\t{ 4, 0x68, \"Pkts1024to1522Octets\" },\n\t{ 4, 0x6c, \"RxOversizePkts\" },\n\t{ 4, 0x70, \"RxJabbers\" },\n\t{ 4, 0x74, \"RxAlignmentErrors\" },\n\t{ 4, 0x78, \"RxFCSErrors\" },\n\t{ 8, 0x7c, \"RxGoodOctets\" },\n\t{ 4, 0x84, \"RxDropPkts\" },\n\t{ 4, 0x88, \"RxUnicastPkts\" },\n\t{ 4, 0x8c, \"RxMulticastPkts\" },\n\t{ 4, 0x90, \"RxBroadcastPkts\" },\n\t{ 4, 0x94, \"RxSAChanges\" },\n\t{ 4, 0x98, \"RxFragments\" },\n\t{ 4, 0xa0, \"RxSymbolErrors\" },\n\t{ 4, 0xa4, \"RxQoSPkts\" },\n\t{ 8, 0xa8, \"RxQoSOctets\" },\n\t{ 4, 0xb0, \"Pkts1523to2047Octets\" },\n\t{ 4, 0xb4, \"Pkts2048to4095Octets\" },\n\t{ 4, 0xb8, \"Pkts4096to8191Octets\" },\n\t{ 4, 0xbc, \"Pkts8192to9728Octets\" },\n\t{ 4, 0xc0, \"RxDiscarded\" },\n};\n\n#define B53_MIBS_63XX_SIZE\tARRAY_SIZE(b53_mibs_63xx)\n\n \nstatic const struct b53_mib_desc b53_mibs[] = {\n\t{ 8, 0x00, \"TxOctets\" },\n\t{ 4, 0x08, \"TxDropPkts\" },\n\t{ 4, 0x10, \"TxBroadcastPkts\" },\n\t{ 4, 0x14, \"TxMulticastPkts\" },\n\t{ 4, 0x18, \"TxUnicastPkts\" },\n\t{ 4, 0x1c, \"TxCollisions\" },\n\t{ 4, 0x20, \"TxSingleCollision\" },\n\t{ 4, 0x24, \"TxMultipleCollision\" },\n\t{ 4, 0x28, \"TxDeferredTransmit\" },\n\t{ 4, 0x2c, \"TxLateCollision\" },\n\t{ 4, 0x30, \"TxExcessiveCollision\" },\n\t{ 4, 0x38, \"TxPausePkts\" },\n\t{ 8, 0x50, \"RxOctets\" },\n\t{ 4, 0x58, \"RxUndersizePkts\" },\n\t{ 4, 0x5c, \"RxPausePkts\" },\n\t{ 4, 0x60, \"Pkts64Octets\" },\n\t{ 4, 0x64, \"Pkts65to127Octets\" },\n\t{ 4, 0x68, \"Pkts128to255Octets\" },\n\t{ 4, 0x6c, \"Pkts256to511Octets\" },\n\t{ 4, 0x70, \"Pkts512to1023Octets\" },\n\t{ 4, 0x74, \"Pkts1024to1522Octets\" },\n\t{ 4, 0x78, \"RxOversizePkts\" },\n\t{ 4, 0x7c, \"RxJabbers\" },\n\t{ 4, 0x80, \"RxAlignmentErrors\" },\n\t{ 4, 0x84, \"RxFCSErrors\" },\n\t{ 8, 0x88, \"RxGoodOctets\" },\n\t{ 4, 0x90, \"RxDropPkts\" },\n\t{ 4, 0x94, \"RxUnicastPkts\" },\n\t{ 4, 0x98, \"RxMulticastPkts\" },\n\t{ 4, 0x9c, \"RxBroadcastPkts\" },\n\t{ 4, 0xa0, \"RxSAChanges\" },\n\t{ 4, 0xa4, \"RxFragments\" },\n\t{ 4, 0xa8, \"RxJumboPkts\" },\n\t{ 4, 0xac, \"RxSymbolErrors\" },\n\t{ 4, 0xc0, \"RxDiscarded\" },\n};\n\n#define B53_MIBS_SIZE\tARRAY_SIZE(b53_mibs)\n\nstatic const struct b53_mib_desc b53_mibs_58xx[] = {\n\t{ 8, 0x00, \"TxOctets\" },\n\t{ 4, 0x08, \"TxDropPkts\" },\n\t{ 4, 0x0c, \"TxQPKTQ0\" },\n\t{ 4, 0x10, \"TxBroadcastPkts\" },\n\t{ 4, 0x14, \"TxMulticastPkts\" },\n\t{ 4, 0x18, \"TxUnicastPKts\" },\n\t{ 4, 0x1c, \"TxCollisions\" },\n\t{ 4, 0x20, \"TxSingleCollision\" },\n\t{ 4, 0x24, \"TxMultipleCollision\" },\n\t{ 4, 0x28, \"TxDeferredCollision\" },\n\t{ 4, 0x2c, \"TxLateCollision\" },\n\t{ 4, 0x30, \"TxExcessiveCollision\" },\n\t{ 4, 0x34, \"TxFrameInDisc\" },\n\t{ 4, 0x38, \"TxPausePkts\" },\n\t{ 4, 0x3c, \"TxQPKTQ1\" },\n\t{ 4, 0x40, \"TxQPKTQ2\" },\n\t{ 4, 0x44, \"TxQPKTQ3\" },\n\t{ 4, 0x48, \"TxQPKTQ4\" },\n\t{ 4, 0x4c, \"TxQPKTQ5\" },\n\t{ 8, 0x50, \"RxOctets\" },\n\t{ 4, 0x58, \"RxUndersizePkts\" },\n\t{ 4, 0x5c, \"RxPausePkts\" },\n\t{ 4, 0x60, \"RxPkts64Octets\" },\n\t{ 4, 0x64, \"RxPkts65to127Octets\" },\n\t{ 4, 0x68, \"RxPkts128to255Octets\" },\n\t{ 4, 0x6c, \"RxPkts256to511Octets\" },\n\t{ 4, 0x70, \"RxPkts512to1023Octets\" },\n\t{ 4, 0x74, \"RxPkts1024toMaxPktsOctets\" },\n\t{ 4, 0x78, \"RxOversizePkts\" },\n\t{ 4, 0x7c, \"RxJabbers\" },\n\t{ 4, 0x80, \"RxAlignmentErrors\" },\n\t{ 4, 0x84, \"RxFCSErrors\" },\n\t{ 8, 0x88, \"RxGoodOctets\" },\n\t{ 4, 0x90, \"RxDropPkts\" },\n\t{ 4, 0x94, \"RxUnicastPkts\" },\n\t{ 4, 0x98, \"RxMulticastPkts\" },\n\t{ 4, 0x9c, \"RxBroadcastPkts\" },\n\t{ 4, 0xa0, \"RxSAChanges\" },\n\t{ 4, 0xa4, \"RxFragments\" },\n\t{ 4, 0xa8, \"RxJumboPkt\" },\n\t{ 4, 0xac, \"RxSymblErr\" },\n\t{ 4, 0xb0, \"InRangeErrCount\" },\n\t{ 4, 0xb4, \"OutRangeErrCount\" },\n\t{ 4, 0xb8, \"EEELpiEvent\" },\n\t{ 4, 0xbc, \"EEELpiDuration\" },\n\t{ 4, 0xc0, \"RxDiscard\" },\n\t{ 4, 0xc8, \"TxQPKTQ6\" },\n\t{ 4, 0xcc, \"TxQPKTQ7\" },\n\t{ 4, 0xd0, \"TxPkts64Octets\" },\n\t{ 4, 0xd4, \"TxPkts65to127Octets\" },\n\t{ 4, 0xd8, \"TxPkts128to255Octets\" },\n\t{ 4, 0xdc, \"TxPkts256to511Ocets\" },\n\t{ 4, 0xe0, \"TxPkts512to1023Ocets\" },\n\t{ 4, 0xe4, \"TxPkts1024toMaxPktOcets\" },\n};\n\n#define B53_MIBS_58XX_SIZE\tARRAY_SIZE(b53_mibs_58xx)\n\nstatic int b53_do_vlan_op(struct b53_device *dev, u8 op)\n{\n\tunsigned int i;\n\n\tb53_write8(dev, B53_ARLIO_PAGE, dev->vta_regs[0], VTA_START_CMD | op);\n\n\tfor (i = 0; i < 10; i++) {\n\t\tu8 vta;\n\n\t\tb53_read8(dev, B53_ARLIO_PAGE, dev->vta_regs[0], &vta);\n\t\tif (!(vta & VTA_START_CMD))\n\t\t\treturn 0;\n\n\t\tusleep_range(100, 200);\n\t}\n\n\treturn -EIO;\n}\n\nstatic void b53_set_vlan_entry(struct b53_device *dev, u16 vid,\n\t\t\t       struct b53_vlan *vlan)\n{\n\tif (is5325(dev)) {\n\t\tu32 entry = 0;\n\n\t\tif (vlan->members) {\n\t\t\tentry = ((vlan->untag & VA_UNTAG_MASK_25) <<\n\t\t\t\t VA_UNTAG_S_25) | vlan->members;\n\t\t\tif (dev->core_rev >= 3)\n\t\t\t\tentry |= VA_VALID_25_R4 | vid << VA_VID_HIGH_S;\n\t\t\telse\n\t\t\t\tentry |= VA_VALID_25;\n\t\t}\n\n\t\tb53_write32(dev, B53_VLAN_PAGE, B53_VLAN_WRITE_25, entry);\n\t\tb53_write16(dev, B53_VLAN_PAGE, B53_VLAN_TABLE_ACCESS_25, vid |\n\t\t\t    VTA_RW_STATE_WR | VTA_RW_OP_EN);\n\t} else if (is5365(dev)) {\n\t\tu16 entry = 0;\n\n\t\tif (vlan->members)\n\t\t\tentry = ((vlan->untag & VA_UNTAG_MASK_65) <<\n\t\t\t\t VA_UNTAG_S_65) | vlan->members | VA_VALID_65;\n\n\t\tb53_write16(dev, B53_VLAN_PAGE, B53_VLAN_WRITE_65, entry);\n\t\tb53_write16(dev, B53_VLAN_PAGE, B53_VLAN_TABLE_ACCESS_65, vid |\n\t\t\t    VTA_RW_STATE_WR | VTA_RW_OP_EN);\n\t} else {\n\t\tb53_write16(dev, B53_ARLIO_PAGE, dev->vta_regs[1], vid);\n\t\tb53_write32(dev, B53_ARLIO_PAGE, dev->vta_regs[2],\n\t\t\t    (vlan->untag << VTE_UNTAG_S) | vlan->members);\n\n\t\tb53_do_vlan_op(dev, VTA_CMD_WRITE);\n\t}\n\n\tdev_dbg(dev->ds->dev, \"VID: %d, members: 0x%04x, untag: 0x%04x\\n\",\n\t\tvid, vlan->members, vlan->untag);\n}\n\nstatic void b53_get_vlan_entry(struct b53_device *dev, u16 vid,\n\t\t\t       struct b53_vlan *vlan)\n{\n\tif (is5325(dev)) {\n\t\tu32 entry = 0;\n\n\t\tb53_write16(dev, B53_VLAN_PAGE, B53_VLAN_TABLE_ACCESS_25, vid |\n\t\t\t    VTA_RW_STATE_RD | VTA_RW_OP_EN);\n\t\tb53_read32(dev, B53_VLAN_PAGE, B53_VLAN_WRITE_25, &entry);\n\n\t\tif (dev->core_rev >= 3)\n\t\t\tvlan->valid = !!(entry & VA_VALID_25_R4);\n\t\telse\n\t\t\tvlan->valid = !!(entry & VA_VALID_25);\n\t\tvlan->members = entry & VA_MEMBER_MASK;\n\t\tvlan->untag = (entry >> VA_UNTAG_S_25) & VA_UNTAG_MASK_25;\n\n\t} else if (is5365(dev)) {\n\t\tu16 entry = 0;\n\n\t\tb53_write16(dev, B53_VLAN_PAGE, B53_VLAN_TABLE_ACCESS_65, vid |\n\t\t\t    VTA_RW_STATE_WR | VTA_RW_OP_EN);\n\t\tb53_read16(dev, B53_VLAN_PAGE, B53_VLAN_WRITE_65, &entry);\n\n\t\tvlan->valid = !!(entry & VA_VALID_65);\n\t\tvlan->members = entry & VA_MEMBER_MASK;\n\t\tvlan->untag = (entry >> VA_UNTAG_S_65) & VA_UNTAG_MASK_65;\n\t} else {\n\t\tu32 entry = 0;\n\n\t\tb53_write16(dev, B53_ARLIO_PAGE, dev->vta_regs[1], vid);\n\t\tb53_do_vlan_op(dev, VTA_CMD_READ);\n\t\tb53_read32(dev, B53_ARLIO_PAGE, dev->vta_regs[2], &entry);\n\t\tvlan->members = entry & VTE_MEMBERS;\n\t\tvlan->untag = (entry >> VTE_UNTAG_S) & VTE_MEMBERS;\n\t\tvlan->valid = true;\n\t}\n}\n\nstatic void b53_set_forwarding(struct b53_device *dev, int enable)\n{\n\tu8 mgmt;\n\n\tb53_read8(dev, B53_CTRL_PAGE, B53_SWITCH_MODE, &mgmt);\n\n\tif (enable)\n\t\tmgmt |= SM_SW_FWD_EN;\n\telse\n\t\tmgmt &= ~SM_SW_FWD_EN;\n\n\tb53_write8(dev, B53_CTRL_PAGE, B53_SWITCH_MODE, mgmt);\n\n\t \n\tb53_read8(dev, B53_CTRL_PAGE, B53_SWITCH_CTRL, &mgmt);\n\tmgmt |= B53_MII_DUMB_FWDG_EN;\n\tb53_write8(dev, B53_CTRL_PAGE, B53_SWITCH_CTRL, mgmt);\n\n\t \n\tb53_read8(dev, B53_CTRL_PAGE, B53_IP_MULTICAST_CTRL, &mgmt);\n\tmgmt |= B53_UC_FWD_EN | B53_MC_FWD_EN | B53_IPMC_FWD_EN;\n\tb53_write8(dev, B53_CTRL_PAGE, B53_IP_MULTICAST_CTRL, mgmt);\n}\n\nstatic void b53_enable_vlan(struct b53_device *dev, int port, bool enable,\n\t\t\t    bool enable_filtering)\n{\n\tu8 mgmt, vc0, vc1, vc4 = 0, vc5;\n\n\tb53_read8(dev, B53_CTRL_PAGE, B53_SWITCH_MODE, &mgmt);\n\tb53_read8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL0, &vc0);\n\tb53_read8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL1, &vc1);\n\n\tif (is5325(dev) || is5365(dev)) {\n\t\tb53_read8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL4_25, &vc4);\n\t\tb53_read8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL5_25, &vc5);\n\t} else if (is63xx(dev)) {\n\t\tb53_read8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL4_63XX, &vc4);\n\t\tb53_read8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL5_63XX, &vc5);\n\t} else {\n\t\tb53_read8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL4, &vc4);\n\t\tb53_read8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL5, &vc5);\n\t}\n\n\tif (enable) {\n\t\tvc0 |= VC0_VLAN_EN | VC0_VID_CHK_EN | VC0_VID_HASH_VID;\n\t\tvc1 |= VC1_RX_MCST_UNTAG_EN | VC1_RX_MCST_FWD_EN;\n\t\tvc4 &= ~VC4_ING_VID_CHECK_MASK;\n\t\tif (enable_filtering) {\n\t\t\tvc4 |= VC4_ING_VID_VIO_DROP << VC4_ING_VID_CHECK_S;\n\t\t\tvc5 |= VC5_DROP_VTABLE_MISS;\n\t\t} else {\n\t\t\tvc4 |= VC4_ING_VID_VIO_FWD << VC4_ING_VID_CHECK_S;\n\t\t\tvc5 &= ~VC5_DROP_VTABLE_MISS;\n\t\t}\n\n\t\tif (is5325(dev))\n\t\t\tvc0 &= ~VC0_RESERVED_1;\n\n\t\tif (is5325(dev) || is5365(dev))\n\t\t\tvc1 |= VC1_RX_MCST_TAG_EN;\n\n\t} else {\n\t\tvc0 &= ~(VC0_VLAN_EN | VC0_VID_CHK_EN | VC0_VID_HASH_VID);\n\t\tvc1 &= ~(VC1_RX_MCST_UNTAG_EN | VC1_RX_MCST_FWD_EN);\n\t\tvc4 &= ~VC4_ING_VID_CHECK_MASK;\n\t\tvc5 &= ~VC5_DROP_VTABLE_MISS;\n\n\t\tif (is5325(dev) || is5365(dev))\n\t\t\tvc4 |= VC4_ING_VID_VIO_FWD << VC4_ING_VID_CHECK_S;\n\t\telse\n\t\t\tvc4 |= VC4_ING_VID_VIO_TO_IMP << VC4_ING_VID_CHECK_S;\n\n\t\tif (is5325(dev) || is5365(dev))\n\t\t\tvc1 &= ~VC1_RX_MCST_TAG_EN;\n\t}\n\n\tif (!is5325(dev) && !is5365(dev))\n\t\tvc5 &= ~VC5_VID_FFF_EN;\n\n\tb53_write8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL0, vc0);\n\tb53_write8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL1, vc1);\n\n\tif (is5325(dev) || is5365(dev)) {\n\t\t \n\t\tif (is5325(dev) && enable)\n\t\t\tb53_write8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL3,\n\t\t\t\t   VC3_HIGH_8BIT_EN);\n\t\telse\n\t\t\tb53_write8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL3, 0);\n\n\t\tb53_write8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL4_25, vc4);\n\t\tb53_write8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL5_25, vc5);\n\t} else if (is63xx(dev)) {\n\t\tb53_write16(dev, B53_VLAN_PAGE, B53_VLAN_CTRL3_63XX, 0);\n\t\tb53_write8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL4_63XX, vc4);\n\t\tb53_write8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL5_63XX, vc5);\n\t} else {\n\t\tb53_write16(dev, B53_VLAN_PAGE, B53_VLAN_CTRL3, 0);\n\t\tb53_write8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL4, vc4);\n\t\tb53_write8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL5, vc5);\n\t}\n\n\tb53_write8(dev, B53_CTRL_PAGE, B53_SWITCH_MODE, mgmt);\n\n\tdev->vlan_enabled = enable;\n\n\tdev_dbg(dev->dev, \"Port %d VLAN enabled: %d, filtering: %d\\n\",\n\t\tport, enable, enable_filtering);\n}\n\nstatic int b53_set_jumbo(struct b53_device *dev, bool enable, bool allow_10_100)\n{\n\tu32 port_mask = 0;\n\tu16 max_size = JMS_MIN_SIZE;\n\n\tif (is5325(dev) || is5365(dev))\n\t\treturn -EINVAL;\n\n\tif (enable) {\n\t\tport_mask = dev->enabled_ports;\n\t\tmax_size = JMS_MAX_SIZE;\n\t\tif (allow_10_100)\n\t\t\tport_mask |= JPM_10_100_JUMBO_EN;\n\t}\n\n\tb53_write32(dev, B53_JUMBO_PAGE, dev->jumbo_pm_reg, port_mask);\n\treturn b53_write16(dev, B53_JUMBO_PAGE, dev->jumbo_size_reg, max_size);\n}\n\nstatic int b53_flush_arl(struct b53_device *dev, u8 mask)\n{\n\tunsigned int i;\n\n\tb53_write8(dev, B53_CTRL_PAGE, B53_FAST_AGE_CTRL,\n\t\t   FAST_AGE_DONE | FAST_AGE_DYNAMIC | mask);\n\n\tfor (i = 0; i < 10; i++) {\n\t\tu8 fast_age_ctrl;\n\n\t\tb53_read8(dev, B53_CTRL_PAGE, B53_FAST_AGE_CTRL,\n\t\t\t  &fast_age_ctrl);\n\n\t\tif (!(fast_age_ctrl & FAST_AGE_DONE))\n\t\t\tgoto out;\n\n\t\tmsleep(1);\n\t}\n\n\treturn -ETIMEDOUT;\nout:\n\t \n\tb53_write8(dev, B53_CTRL_PAGE, B53_FAST_AGE_CTRL, FAST_AGE_DYNAMIC);\n\treturn 0;\n}\n\nstatic int b53_fast_age_port(struct b53_device *dev, int port)\n{\n\tb53_write8(dev, B53_CTRL_PAGE, B53_FAST_AGE_PORT_CTRL, port);\n\n\treturn b53_flush_arl(dev, FAST_AGE_PORT);\n}\n\nstatic int b53_fast_age_vlan(struct b53_device *dev, u16 vid)\n{\n\tb53_write16(dev, B53_CTRL_PAGE, B53_FAST_AGE_VID_CTRL, vid);\n\n\treturn b53_flush_arl(dev, FAST_AGE_VLAN);\n}\n\nvoid b53_imp_vlan_setup(struct dsa_switch *ds, int cpu_port)\n{\n\tstruct b53_device *dev = ds->priv;\n\tunsigned int i;\n\tu16 pvlan;\n\n\t \n\tb53_for_each_port(dev, i) {\n\t\tb53_read16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(i), &pvlan);\n\t\tpvlan |= BIT(cpu_port);\n\t\tb53_write16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(i), pvlan);\n\t}\n}\nEXPORT_SYMBOL(b53_imp_vlan_setup);\n\nstatic void b53_port_set_ucast_flood(struct b53_device *dev, int port,\n\t\t\t\t     bool unicast)\n{\n\tu16 uc;\n\n\tb53_read16(dev, B53_CTRL_PAGE, B53_UC_FLOOD_MASK, &uc);\n\tif (unicast)\n\t\tuc |= BIT(port);\n\telse\n\t\tuc &= ~BIT(port);\n\tb53_write16(dev, B53_CTRL_PAGE, B53_UC_FLOOD_MASK, uc);\n}\n\nstatic void b53_port_set_mcast_flood(struct b53_device *dev, int port,\n\t\t\t\t     bool multicast)\n{\n\tu16 mc;\n\n\tb53_read16(dev, B53_CTRL_PAGE, B53_MC_FLOOD_MASK, &mc);\n\tif (multicast)\n\t\tmc |= BIT(port);\n\telse\n\t\tmc &= ~BIT(port);\n\tb53_write16(dev, B53_CTRL_PAGE, B53_MC_FLOOD_MASK, mc);\n\n\tb53_read16(dev, B53_CTRL_PAGE, B53_IPMC_FLOOD_MASK, &mc);\n\tif (multicast)\n\t\tmc |= BIT(port);\n\telse\n\t\tmc &= ~BIT(port);\n\tb53_write16(dev, B53_CTRL_PAGE, B53_IPMC_FLOOD_MASK, mc);\n}\n\nstatic void b53_port_set_learning(struct b53_device *dev, int port,\n\t\t\t\t  bool learning)\n{\n\tu16 reg;\n\n\tb53_read16(dev, B53_CTRL_PAGE, B53_DIS_LEARNING, &reg);\n\tif (learning)\n\t\treg &= ~BIT(port);\n\telse\n\t\treg |= BIT(port);\n\tb53_write16(dev, B53_CTRL_PAGE, B53_DIS_LEARNING, reg);\n}\n\nint b53_enable_port(struct dsa_switch *ds, int port, struct phy_device *phy)\n{\n\tstruct b53_device *dev = ds->priv;\n\tunsigned int cpu_port;\n\tint ret = 0;\n\tu16 pvlan;\n\n\tif (!dsa_is_user_port(ds, port))\n\t\treturn 0;\n\n\tcpu_port = dsa_to_port(ds, port)->cpu_dp->index;\n\n\tb53_port_set_ucast_flood(dev, port, true);\n\tb53_port_set_mcast_flood(dev, port, true);\n\tb53_port_set_learning(dev, port, false);\n\n\tif (dev->ops->irq_enable)\n\t\tret = dev->ops->irq_enable(dev, port);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tb53_write8(dev, B53_CTRL_PAGE, B53_PORT_CTRL(port), 0);\n\n\t \n\tb53_read16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(port), &pvlan);\n\tpvlan &= ~0x1ff;\n\tpvlan |= BIT(port);\n\tpvlan |= dev->ports[port].vlan_ctl_mask;\n\tb53_write16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(port), pvlan);\n\n\tb53_imp_vlan_setup(ds, cpu_port);\n\n\t \n\tif (dev->ports[port].eee.eee_enabled)\n\t\tb53_eee_enable_set(ds, port, true);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(b53_enable_port);\n\nvoid b53_disable_port(struct dsa_switch *ds, int port)\n{\n\tstruct b53_device *dev = ds->priv;\n\tu8 reg;\n\n\t \n\tb53_read8(dev, B53_CTRL_PAGE, B53_PORT_CTRL(port), &reg);\n\treg |= PORT_CTRL_RX_DISABLE | PORT_CTRL_TX_DISABLE;\n\tb53_write8(dev, B53_CTRL_PAGE, B53_PORT_CTRL(port), reg);\n\n\tif (dev->ops->irq_disable)\n\t\tdev->ops->irq_disable(dev, port);\n}\nEXPORT_SYMBOL(b53_disable_port);\n\nvoid b53_brcm_hdr_setup(struct dsa_switch *ds, int port)\n{\n\tstruct b53_device *dev = ds->priv;\n\tbool tag_en = !(dev->tag_protocol == DSA_TAG_PROTO_NONE);\n\tu8 hdr_ctl, val;\n\tu16 reg;\n\n\t \n\tswitch (port) {\n\tcase 8:\n\t\tval = BRCM_HDR_P8_EN;\n\t\tbreak;\n\tcase 7:\n\t\tval = BRCM_HDR_P7_EN;\n\t\tbreak;\n\tcase 5:\n\t\tval = BRCM_HDR_P5_EN;\n\t\tbreak;\n\tdefault:\n\t\tval = 0;\n\t\tbreak;\n\t}\n\n\t \n\tb53_read8(dev, B53_CTRL_PAGE, B53_SWITCH_MODE, &hdr_ctl);\n\tif (tag_en)\n\t\thdr_ctl |= SM_SW_FWD_MODE;\n\telse\n\t\thdr_ctl &= ~SM_SW_FWD_MODE;\n\tb53_write8(dev, B53_CTRL_PAGE, B53_SWITCH_MODE, hdr_ctl);\n\n\t \n\tb53_read8(dev, B53_MGMT_PAGE, B53_GLOBAL_CONFIG, &hdr_ctl);\n\tif (port == 8)\n\t\thdr_ctl |= GC_FRM_MGMT_PORT_MII;\n\telse if (port == 5)\n\t\thdr_ctl |= GC_FRM_MGMT_PORT_M;\n\tb53_write8(dev, B53_MGMT_PAGE, B53_GLOBAL_CONFIG, hdr_ctl);\n\n\t \n\tb53_read8(dev, B53_MGMT_PAGE, B53_BRCM_HDR, &hdr_ctl);\n\tif (tag_en)\n\t\thdr_ctl |= val;\n\telse\n\t\thdr_ctl &= ~val;\n\tb53_write8(dev, B53_MGMT_PAGE, B53_BRCM_HDR, hdr_ctl);\n\n\t \n\tif (!is58xx(dev))\n\t\treturn;\n\n\t \n\tb53_read16(dev, B53_MGMT_PAGE, B53_BRCM_HDR_RX_DIS, &reg);\n\tif (tag_en)\n\t\treg &= ~BIT(port);\n\telse\n\t\treg |= BIT(port);\n\tb53_write16(dev, B53_MGMT_PAGE, B53_BRCM_HDR_RX_DIS, reg);\n\n\t \n\tb53_read16(dev, B53_MGMT_PAGE, B53_BRCM_HDR_TX_DIS, &reg);\n\tif (tag_en)\n\t\treg &= ~BIT(port);\n\telse\n\t\treg |= BIT(port);\n\tb53_write16(dev, B53_MGMT_PAGE, B53_BRCM_HDR_TX_DIS, reg);\n}\nEXPORT_SYMBOL(b53_brcm_hdr_setup);\n\nstatic void b53_enable_cpu_port(struct b53_device *dev, int port)\n{\n\tu8 port_ctrl;\n\n\t \n\tif ((is5325(dev) || is5365(dev)) && port == B53_CPU_PORT_25)\n\t\tport = B53_CPU_PORT;\n\n\tport_ctrl = PORT_CTRL_RX_BCST_EN |\n\t\t    PORT_CTRL_RX_MCST_EN |\n\t\t    PORT_CTRL_RX_UCST_EN;\n\tb53_write8(dev, B53_CTRL_PAGE, B53_PORT_CTRL(port), port_ctrl);\n\n\tb53_brcm_hdr_setup(dev->ds, port);\n\n\tb53_port_set_ucast_flood(dev, port, true);\n\tb53_port_set_mcast_flood(dev, port, true);\n\tb53_port_set_learning(dev, port, false);\n}\n\nstatic void b53_enable_mib(struct b53_device *dev)\n{\n\tu8 gc;\n\n\tb53_read8(dev, B53_MGMT_PAGE, B53_GLOBAL_CONFIG, &gc);\n\tgc &= ~(GC_RESET_MIB | GC_MIB_AC_EN);\n\tb53_write8(dev, B53_MGMT_PAGE, B53_GLOBAL_CONFIG, gc);\n}\n\nstatic u16 b53_default_pvid(struct b53_device *dev)\n{\n\tif (is5325(dev) || is5365(dev))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic bool b53_vlan_port_needs_forced_tagged(struct dsa_switch *ds, int port)\n{\n\tstruct b53_device *dev = ds->priv;\n\n\treturn dev->tag_protocol == DSA_TAG_PROTO_NONE && dsa_is_cpu_port(ds, port);\n}\n\nint b53_configure_vlan(struct dsa_switch *ds)\n{\n\tstruct b53_device *dev = ds->priv;\n\tstruct b53_vlan vl = { 0 };\n\tstruct b53_vlan *v;\n\tint i, def_vid;\n\tu16 vid;\n\n\tdef_vid = b53_default_pvid(dev);\n\n\t \n\tif (is5325(dev) || is5365(dev)) {\n\t\tfor (i = def_vid; i < dev->num_vlans; i++)\n\t\t\tb53_set_vlan_entry(dev, i, &vl);\n\t} else {\n\t\tb53_do_vlan_op(dev, VTA_CMD_CLEAR);\n\t}\n\n\tb53_enable_vlan(dev, -1, dev->vlan_enabled, ds->vlan_filtering);\n\n\t \n\tb53_for_each_port(dev, i) {\n\t\tv = &dev->vlans[def_vid];\n\t\tv->members |= BIT(i);\n\t\tif (!b53_vlan_port_needs_forced_tagged(ds, i))\n\t\t\tv->untag = v->members;\n\t\tb53_write16(dev, B53_VLAN_PAGE,\n\t\t\t    B53_VLAN_PORT_DEF_TAG(i), def_vid);\n\t}\n\n\t \n\tfor (vid = def_vid; vid < dev->num_vlans; vid++) {\n\t\tv = &dev->vlans[vid];\n\n\t\tif (!v->members)\n\t\t\tcontinue;\n\n\t\tb53_set_vlan_entry(dev, vid, v);\n\t\tb53_fast_age_vlan(dev, vid);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(b53_configure_vlan);\n\nstatic void b53_switch_reset_gpio(struct b53_device *dev)\n{\n\tint gpio = dev->reset_gpio;\n\n\tif (gpio < 0)\n\t\treturn;\n\n\t \n\tgpio_set_value(gpio, 0);\n\tmdelay(50);\n\n\tgpio_set_value(gpio, 1);\n\tmdelay(20);\n\n\tdev->current_page = 0xff;\n}\n\nstatic int b53_switch_reset(struct b53_device *dev)\n{\n\tunsigned int timeout = 1000;\n\tu8 mgmt, reg;\n\n\tb53_switch_reset_gpio(dev);\n\n\tif (is539x(dev)) {\n\t\tb53_write8(dev, B53_CTRL_PAGE, B53_SOFTRESET, 0x83);\n\t\tb53_write8(dev, B53_CTRL_PAGE, B53_SOFTRESET, 0x00);\n\t}\n\n\t \n\tif (dev->chip_id == BCM58XX_DEVICE_ID ||\n\t    dev->chip_id == BCM583XX_DEVICE_ID) {\n\t\tb53_read8(dev, B53_CTRL_PAGE, B53_SOFTRESET, &reg);\n\t\treg |= SW_RST | EN_SW_RST | EN_CH_RST;\n\t\tb53_write8(dev, B53_CTRL_PAGE, B53_SOFTRESET, reg);\n\n\t\tdo {\n\t\t\tb53_read8(dev, B53_CTRL_PAGE, B53_SOFTRESET, &reg);\n\t\t\tif (!(reg & SW_RST))\n\t\t\t\tbreak;\n\n\t\t\tusleep_range(1000, 2000);\n\t\t} while (timeout-- > 0);\n\n\t\tif (timeout == 0) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"Timeout waiting for SW_RST to clear!\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\tb53_read8(dev, B53_CTRL_PAGE, B53_SWITCH_MODE, &mgmt);\n\n\tif (!(mgmt & SM_SW_FWD_EN)) {\n\t\tmgmt &= ~SM_SW_FWD_MODE;\n\t\tmgmt |= SM_SW_FWD_EN;\n\n\t\tb53_write8(dev, B53_CTRL_PAGE, B53_SWITCH_MODE, mgmt);\n\t\tb53_read8(dev, B53_CTRL_PAGE, B53_SWITCH_MODE, &mgmt);\n\n\t\tif (!(mgmt & SM_SW_FWD_EN)) {\n\t\t\tdev_err(dev->dev, \"Failed to enable switch!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tb53_enable_mib(dev);\n\n\treturn b53_flush_arl(dev, FAST_AGE_STATIC);\n}\n\nstatic int b53_phy_read16(struct dsa_switch *ds, int addr, int reg)\n{\n\tstruct b53_device *priv = ds->priv;\n\tu16 value = 0;\n\tint ret;\n\n\tif (priv->ops->phy_read16)\n\t\tret = priv->ops->phy_read16(priv, addr, reg, &value);\n\telse\n\t\tret = b53_read16(priv, B53_PORT_MII_PAGE(addr),\n\t\t\t\t reg * 2, &value);\n\n\treturn ret ? ret : value;\n}\n\nstatic int b53_phy_write16(struct dsa_switch *ds, int addr, int reg, u16 val)\n{\n\tstruct b53_device *priv = ds->priv;\n\n\tif (priv->ops->phy_write16)\n\t\treturn priv->ops->phy_write16(priv, addr, reg, val);\n\n\treturn b53_write16(priv, B53_PORT_MII_PAGE(addr), reg * 2, val);\n}\n\nstatic int b53_reset_switch(struct b53_device *priv)\n{\n\t \n\tmemset(priv->vlans, 0, sizeof(*priv->vlans) * priv->num_vlans);\n\tmemset(priv->ports, 0, sizeof(*priv->ports) * priv->num_ports);\n\n\tpriv->serdes_lane = B53_INVALID_LANE;\n\n\treturn b53_switch_reset(priv);\n}\n\nstatic int b53_apply_config(struct b53_device *priv)\n{\n\t \n\tb53_set_forwarding(priv, 0);\n\n\tb53_configure_vlan(priv->ds);\n\n\t \n\tb53_set_forwarding(priv, 1);\n\n\treturn 0;\n}\n\nstatic void b53_reset_mib(struct b53_device *priv)\n{\n\tu8 gc;\n\n\tb53_read8(priv, B53_MGMT_PAGE, B53_GLOBAL_CONFIG, &gc);\n\n\tb53_write8(priv, B53_MGMT_PAGE, B53_GLOBAL_CONFIG, gc | GC_RESET_MIB);\n\tmsleep(1);\n\tb53_write8(priv, B53_MGMT_PAGE, B53_GLOBAL_CONFIG, gc & ~GC_RESET_MIB);\n\tmsleep(1);\n}\n\nstatic const struct b53_mib_desc *b53_get_mib(struct b53_device *dev)\n{\n\tif (is5365(dev))\n\t\treturn b53_mibs_65;\n\telse if (is63xx(dev))\n\t\treturn b53_mibs_63xx;\n\telse if (is58xx(dev))\n\t\treturn b53_mibs_58xx;\n\telse\n\t\treturn b53_mibs;\n}\n\nstatic unsigned int b53_get_mib_size(struct b53_device *dev)\n{\n\tif (is5365(dev))\n\t\treturn B53_MIBS_65_SIZE;\n\telse if (is63xx(dev))\n\t\treturn B53_MIBS_63XX_SIZE;\n\telse if (is58xx(dev))\n\t\treturn B53_MIBS_58XX_SIZE;\n\telse\n\t\treturn B53_MIBS_SIZE;\n}\n\nstatic struct phy_device *b53_get_phy_device(struct dsa_switch *ds, int port)\n{\n\t \n\tswitch (port) {\n\tcase B53_CPU_PORT_25:\n\tcase 7:\n\tcase B53_CPU_PORT:\n\t\treturn NULL;\n\t}\n\n\treturn mdiobus_get_phy(ds->slave_mii_bus, port);\n}\n\nvoid b53_get_strings(struct dsa_switch *ds, int port, u32 stringset,\n\t\t     uint8_t *data)\n{\n\tstruct b53_device *dev = ds->priv;\n\tconst struct b53_mib_desc *mibs = b53_get_mib(dev);\n\tunsigned int mib_size = b53_get_mib_size(dev);\n\tstruct phy_device *phydev;\n\tunsigned int i;\n\n\tif (stringset == ETH_SS_STATS) {\n\t\tfor (i = 0; i < mib_size; i++)\n\t\t\tstrscpy(data + i * ETH_GSTRING_LEN,\n\t\t\t\tmibs[i].name, ETH_GSTRING_LEN);\n\t} else if (stringset == ETH_SS_PHY_STATS) {\n\t\tphydev = b53_get_phy_device(ds, port);\n\t\tif (!phydev)\n\t\t\treturn;\n\n\t\tphy_ethtool_get_strings(phydev, data);\n\t}\n}\nEXPORT_SYMBOL(b53_get_strings);\n\nvoid b53_get_ethtool_stats(struct dsa_switch *ds, int port, uint64_t *data)\n{\n\tstruct b53_device *dev = ds->priv;\n\tconst struct b53_mib_desc *mibs = b53_get_mib(dev);\n\tunsigned int mib_size = b53_get_mib_size(dev);\n\tconst struct b53_mib_desc *s;\n\tunsigned int i;\n\tu64 val = 0;\n\n\tif (is5365(dev) && port == 5)\n\t\tport = 8;\n\n\tmutex_lock(&dev->stats_mutex);\n\n\tfor (i = 0; i < mib_size; i++) {\n\t\ts = &mibs[i];\n\n\t\tif (s->size == 8) {\n\t\t\tb53_read64(dev, B53_MIB_PAGE(port), s->offset, &val);\n\t\t} else {\n\t\t\tu32 val32;\n\n\t\t\tb53_read32(dev, B53_MIB_PAGE(port), s->offset,\n\t\t\t\t   &val32);\n\t\t\tval = val32;\n\t\t}\n\t\tdata[i] = (u64)val;\n\t}\n\n\tmutex_unlock(&dev->stats_mutex);\n}\nEXPORT_SYMBOL(b53_get_ethtool_stats);\n\nvoid b53_get_ethtool_phy_stats(struct dsa_switch *ds, int port, uint64_t *data)\n{\n\tstruct phy_device *phydev;\n\n\tphydev = b53_get_phy_device(ds, port);\n\tif (!phydev)\n\t\treturn;\n\n\tphy_ethtool_get_stats(phydev, NULL, data);\n}\nEXPORT_SYMBOL(b53_get_ethtool_phy_stats);\n\nint b53_get_sset_count(struct dsa_switch *ds, int port, int sset)\n{\n\tstruct b53_device *dev = ds->priv;\n\tstruct phy_device *phydev;\n\n\tif (sset == ETH_SS_STATS) {\n\t\treturn b53_get_mib_size(dev);\n\t} else if (sset == ETH_SS_PHY_STATS) {\n\t\tphydev = b53_get_phy_device(ds, port);\n\t\tif (!phydev)\n\t\t\treturn 0;\n\n\t\treturn phy_ethtool_get_sset_count(phydev);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(b53_get_sset_count);\n\nenum b53_devlink_resource_id {\n\tB53_DEVLINK_PARAM_ID_VLAN_TABLE,\n};\n\nstatic u64 b53_devlink_vlan_table_get(void *priv)\n{\n\tstruct b53_device *dev = priv;\n\tstruct b53_vlan *vl;\n\tunsigned int i;\n\tu64 count = 0;\n\n\tfor (i = 0; i < dev->num_vlans; i++) {\n\t\tvl = &dev->vlans[i];\n\t\tif (vl->members)\n\t\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nint b53_setup_devlink_resources(struct dsa_switch *ds)\n{\n\tstruct devlink_resource_size_params size_params;\n\tstruct b53_device *dev = ds->priv;\n\tint err;\n\n\tdevlink_resource_size_params_init(&size_params, dev->num_vlans,\n\t\t\t\t\t  dev->num_vlans,\n\t\t\t\t\t  1, DEVLINK_RESOURCE_UNIT_ENTRY);\n\n\terr = dsa_devlink_resource_register(ds, \"VLAN\", dev->num_vlans,\n\t\t\t\t\t    B53_DEVLINK_PARAM_ID_VLAN_TABLE,\n\t\t\t\t\t    DEVLINK_RESOURCE_ID_PARENT_TOP,\n\t\t\t\t\t    &size_params);\n\tif (err)\n\t\tgoto out;\n\n\tdsa_devlink_resource_occ_get_register(ds,\n\t\t\t\t\t      B53_DEVLINK_PARAM_ID_VLAN_TABLE,\n\t\t\t\t\t      b53_devlink_vlan_table_get, dev);\n\n\treturn 0;\nout:\n\tdsa_devlink_resources_unregister(ds);\n\treturn err;\n}\nEXPORT_SYMBOL(b53_setup_devlink_resources);\n\nstatic int b53_setup(struct dsa_switch *ds)\n{\n\tstruct b53_device *dev = ds->priv;\n\tunsigned int port;\n\tint ret;\n\n\t \n\tds->untag_bridge_pvid = dev->tag_protocol == DSA_TAG_PROTO_NONE;\n\n\tret = b53_reset_switch(dev);\n\tif (ret) {\n\t\tdev_err(ds->dev, \"failed to reset switch\\n\");\n\t\treturn ret;\n\t}\n\n\tb53_reset_mib(dev);\n\n\tret = b53_apply_config(dev);\n\tif (ret) {\n\t\tdev_err(ds->dev, \"failed to apply configuration\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tfor (port = 0; port < dev->num_ports; port++) {\n\t\tif (dsa_is_cpu_port(ds, port))\n\t\t\tb53_enable_cpu_port(dev, port);\n\t\telse\n\t\t\tb53_disable_port(ds, port);\n\t}\n\n\treturn b53_setup_devlink_resources(ds);\n}\n\nstatic void b53_teardown(struct dsa_switch *ds)\n{\n\tdsa_devlink_resources_unregister(ds);\n}\n\nstatic void b53_force_link(struct b53_device *dev, int port, int link)\n{\n\tu8 reg, val, off;\n\n\t \n\tif (port == dev->imp_port) {\n\t\toff = B53_PORT_OVERRIDE_CTRL;\n\t\tval = PORT_OVERRIDE_EN;\n\t} else {\n\t\toff = B53_GMII_PORT_OVERRIDE_CTRL(port);\n\t\tval = GMII_PO_EN;\n\t}\n\n\tb53_read8(dev, B53_CTRL_PAGE, off, &reg);\n\treg |= val;\n\tif (link)\n\t\treg |= PORT_OVERRIDE_LINK;\n\telse\n\t\treg &= ~PORT_OVERRIDE_LINK;\n\tb53_write8(dev, B53_CTRL_PAGE, off, reg);\n}\n\nstatic void b53_force_port_config(struct b53_device *dev, int port,\n\t\t\t\t  int speed, int duplex,\n\t\t\t\t  bool tx_pause, bool rx_pause)\n{\n\tu8 reg, val, off;\n\n\t \n\tif (port == dev->imp_port) {\n\t\toff = B53_PORT_OVERRIDE_CTRL;\n\t\tval = PORT_OVERRIDE_EN;\n\t} else {\n\t\toff = B53_GMII_PORT_OVERRIDE_CTRL(port);\n\t\tval = GMII_PO_EN;\n\t}\n\n\tb53_read8(dev, B53_CTRL_PAGE, off, &reg);\n\treg |= val;\n\tif (duplex == DUPLEX_FULL)\n\t\treg |= PORT_OVERRIDE_FULL_DUPLEX;\n\telse\n\t\treg &= ~PORT_OVERRIDE_FULL_DUPLEX;\n\n\tswitch (speed) {\n\tcase 2000:\n\t\treg |= PORT_OVERRIDE_SPEED_2000M;\n\t\tfallthrough;\n\tcase SPEED_1000:\n\t\treg |= PORT_OVERRIDE_SPEED_1000M;\n\t\tbreak;\n\tcase SPEED_100:\n\t\treg |= PORT_OVERRIDE_SPEED_100M;\n\t\tbreak;\n\tcase SPEED_10:\n\t\treg |= PORT_OVERRIDE_SPEED_10M;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev->dev, \"unknown speed: %d\\n\", speed);\n\t\treturn;\n\t}\n\n\tif (rx_pause)\n\t\treg |= PORT_OVERRIDE_RX_FLOW;\n\tif (tx_pause)\n\t\treg |= PORT_OVERRIDE_TX_FLOW;\n\n\tb53_write8(dev, B53_CTRL_PAGE, off, reg);\n}\n\nstatic void b53_adjust_63xx_rgmii(struct dsa_switch *ds, int port,\n\t\t\t\t  phy_interface_t interface)\n{\n\tstruct b53_device *dev = ds->priv;\n\tu8 rgmii_ctrl = 0, off;\n\n\tif (port == dev->imp_port)\n\t\toff = B53_RGMII_CTRL_IMP;\n\telse\n\t\toff = B53_RGMII_CTRL_P(port);\n\n\tb53_read8(dev, B53_CTRL_PAGE, off, &rgmii_ctrl);\n\n\tswitch (interface) {\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\t\trgmii_ctrl |= (RGMII_CTRL_DLL_RXC | RGMII_CTRL_DLL_TXC);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\trgmii_ctrl &= ~(RGMII_CTRL_DLL_TXC);\n\t\trgmii_ctrl |= RGMII_CTRL_DLL_RXC;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\trgmii_ctrl &= ~(RGMII_CTRL_DLL_RXC);\n\t\trgmii_ctrl |= RGMII_CTRL_DLL_TXC;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tdefault:\n\t\trgmii_ctrl &= ~(RGMII_CTRL_DLL_RXC | RGMII_CTRL_DLL_TXC);\n\t\tbreak;\n\t}\n\n\tif (port != dev->imp_port) {\n\t\tif (is63268(dev))\n\t\t\trgmii_ctrl |= RGMII_CTRL_MII_OVERRIDE;\n\n\t\trgmii_ctrl |= RGMII_CTRL_ENABLE_GMII;\n\t}\n\n\tb53_write8(dev, B53_CTRL_PAGE, off, rgmii_ctrl);\n\n\tdev_dbg(ds->dev, \"Configured port %d for %s\\n\", port,\n\t\tphy_modes(interface));\n}\n\nstatic void b53_adjust_link(struct dsa_switch *ds, int port,\n\t\t\t    struct phy_device *phydev)\n{\n\tstruct b53_device *dev = ds->priv;\n\tstruct ethtool_eee *p = &dev->ports[port].eee;\n\tu8 rgmii_ctrl = 0, reg = 0, off;\n\tbool tx_pause = false;\n\tbool rx_pause = false;\n\n\tif (!phy_is_pseudo_fixed_link(phydev))\n\t\treturn;\n\n\t \n\tif (is5301x(dev) && dsa_is_cpu_port(ds, port))\n\t\ttx_pause = rx_pause = true;\n\n\tif (phydev->pause) {\n\t\tif (phydev->asym_pause)\n\t\t\ttx_pause = true;\n\t\trx_pause = true;\n\t}\n\n\tb53_force_port_config(dev, port, phydev->speed, phydev->duplex,\n\t\t\t      tx_pause, rx_pause);\n\tb53_force_link(dev, port, phydev->link);\n\n\tif (is63xx(dev) && port >= B53_63XX_RGMII0)\n\t\tb53_adjust_63xx_rgmii(ds, port, phydev->interface);\n\n\tif (is531x5(dev) && phy_interface_is_rgmii(phydev)) {\n\t\tif (port == dev->imp_port)\n\t\t\toff = B53_RGMII_CTRL_IMP;\n\t\telse\n\t\t\toff = B53_RGMII_CTRL_P(port);\n\n\t\t \n\t\tb53_read8(dev, B53_CTRL_PAGE, off, &rgmii_ctrl);\n\t\trgmii_ctrl &= ~(RGMII_CTRL_DLL_RXC | RGMII_CTRL_DLL_TXC |\n\t\t\t\tRGMII_CTRL_TIMING_SEL);\n\n\t\t \n\t\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID)\n\t\t\trgmii_ctrl |= RGMII_CTRL_DLL_TXC;\n\t\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII)\n\t\t\trgmii_ctrl |= RGMII_CTRL_DLL_TXC | RGMII_CTRL_DLL_RXC;\n\t\trgmii_ctrl |= RGMII_CTRL_TIMING_SEL;\n\t\tb53_write8(dev, B53_CTRL_PAGE, off, rgmii_ctrl);\n\n\t\tdev_info(ds->dev, \"Configured port %d for %s\\n\", port,\n\t\t\t phy_modes(phydev->interface));\n\t}\n\n\t \n\tif (is5325(dev)) {\n\t\tb53_read8(dev, B53_CTRL_PAGE, B53_PORT_OVERRIDE_CTRL,\n\t\t\t  &reg);\n\n\t\t \n\t\tif (!(reg & PORT_OVERRIDE_RV_MII_25)) {\n\t\t\tb53_write8(dev, B53_CTRL_PAGE, B53_PORT_OVERRIDE_CTRL,\n\t\t\t\t   reg | PORT_OVERRIDE_RV_MII_25);\n\t\t\tb53_read8(dev, B53_CTRL_PAGE, B53_PORT_OVERRIDE_CTRL,\n\t\t\t\t  &reg);\n\n\t\t\tif (!(reg & PORT_OVERRIDE_RV_MII_25)) {\n\t\t\t\tdev_err(ds->dev,\n\t\t\t\t\t\"Failed to enable reverse MII mode\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tp->eee_enabled = b53_eee_init(ds, port, phydev);\n}\n\nvoid b53_port_event(struct dsa_switch *ds, int port)\n{\n\tstruct b53_device *dev = ds->priv;\n\tbool link;\n\tu16 sts;\n\n\tb53_read16(dev, B53_STAT_PAGE, B53_LINK_STAT, &sts);\n\tlink = !!(sts & BIT(port));\n\tdsa_port_phylink_mac_change(ds, port, link);\n}\nEXPORT_SYMBOL(b53_port_event);\n\nstatic void b53_phylink_get_caps(struct dsa_switch *ds, int port,\n\t\t\t\t struct phylink_config *config)\n{\n\tstruct b53_device *dev = ds->priv;\n\n\t \n\t__set_bit(PHY_INTERFACE_MODE_GMII, config->supported_interfaces);\n\n\t \n\t__set_bit(PHY_INTERFACE_MODE_MII, config->supported_interfaces);\n\t__set_bit(PHY_INTERFACE_MODE_REVMII, config->supported_interfaces);\n\n\tconfig->mac_capabilities = MAC_ASYM_PAUSE | MAC_SYM_PAUSE |\n\t\tMAC_10 | MAC_100;\n\n\t \n\tif (!(is5325(dev) || is5365(dev)))\n\t\tconfig->mac_capabilities |= MAC_1000;\n\n\t \n\tif (dev->ops->phylink_get_caps)\n\t\tdev->ops->phylink_get_caps(dev, port, config);\n}\n\nstatic struct phylink_pcs *b53_phylink_mac_select_pcs(struct dsa_switch *ds,\n\t\t\t\t\t\t      int port,\n\t\t\t\t\t\t      phy_interface_t interface)\n{\n\tstruct b53_device *dev = ds->priv;\n\n\tif (!dev->ops->phylink_mac_select_pcs)\n\t\treturn NULL;\n\n\treturn dev->ops->phylink_mac_select_pcs(dev, port, interface);\n}\n\nvoid b53_phylink_mac_config(struct dsa_switch *ds, int port,\n\t\t\t    unsigned int mode,\n\t\t\t    const struct phylink_link_state *state)\n{\n}\nEXPORT_SYMBOL(b53_phylink_mac_config);\n\nvoid b53_phylink_mac_link_down(struct dsa_switch *ds, int port,\n\t\t\t       unsigned int mode,\n\t\t\t       phy_interface_t interface)\n{\n\tstruct b53_device *dev = ds->priv;\n\n\tif (mode == MLO_AN_PHY)\n\t\treturn;\n\n\tif (mode == MLO_AN_FIXED) {\n\t\tb53_force_link(dev, port, false);\n\t\treturn;\n\t}\n\n\tif (phy_interface_mode_is_8023z(interface) &&\n\t    dev->ops->serdes_link_set)\n\t\tdev->ops->serdes_link_set(dev, port, mode, interface, false);\n}\nEXPORT_SYMBOL(b53_phylink_mac_link_down);\n\nvoid b53_phylink_mac_link_up(struct dsa_switch *ds, int port,\n\t\t\t     unsigned int mode,\n\t\t\t     phy_interface_t interface,\n\t\t\t     struct phy_device *phydev,\n\t\t\t     int speed, int duplex,\n\t\t\t     bool tx_pause, bool rx_pause)\n{\n\tstruct b53_device *dev = ds->priv;\n\n\tif (is63xx(dev) && port >= B53_63XX_RGMII0)\n\t\tb53_adjust_63xx_rgmii(ds, port, interface);\n\n\tif (mode == MLO_AN_PHY)\n\t\treturn;\n\n\tif (mode == MLO_AN_FIXED) {\n\t\tb53_force_port_config(dev, port, speed, duplex,\n\t\t\t\t      tx_pause, rx_pause);\n\t\tb53_force_link(dev, port, true);\n\t\treturn;\n\t}\n\n\tif (phy_interface_mode_is_8023z(interface) &&\n\t    dev->ops->serdes_link_set)\n\t\tdev->ops->serdes_link_set(dev, port, mode, interface, true);\n}\nEXPORT_SYMBOL(b53_phylink_mac_link_up);\n\nint b53_vlan_filtering(struct dsa_switch *ds, int port, bool vlan_filtering,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct b53_device *dev = ds->priv;\n\n\tb53_enable_vlan(dev, port, dev->vlan_enabled, vlan_filtering);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(b53_vlan_filtering);\n\nstatic int b53_vlan_prepare(struct dsa_switch *ds, int port,\n\t\t\t    const struct switchdev_obj_port_vlan *vlan)\n{\n\tstruct b53_device *dev = ds->priv;\n\n\tif ((is5325(dev) || is5365(dev)) && vlan->vid == 0)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (dev->chip_id == BCM7278_DEVICE_ID && port == 7 &&\n\t    !(vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED))\n\t\treturn -EINVAL;\n\n\tif (vlan->vid >= dev->num_vlans)\n\t\treturn -ERANGE;\n\n\tb53_enable_vlan(dev, port, true, ds->vlan_filtering);\n\n\treturn 0;\n}\n\nint b53_vlan_add(struct dsa_switch *ds, int port,\n\t\t const struct switchdev_obj_port_vlan *vlan,\n\t\t struct netlink_ext_ack *extack)\n{\n\tstruct b53_device *dev = ds->priv;\n\tbool untagged = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;\n\tbool pvid = vlan->flags & BRIDGE_VLAN_INFO_PVID;\n\tstruct b53_vlan *vl;\n\tint err;\n\n\terr = b53_vlan_prepare(ds, port, vlan);\n\tif (err)\n\t\treturn err;\n\n\tvl = &dev->vlans[vlan->vid];\n\n\tb53_get_vlan_entry(dev, vlan->vid, vl);\n\n\tif (vlan->vid == 0 && vlan->vid == b53_default_pvid(dev))\n\t\tuntagged = true;\n\n\tvl->members |= BIT(port);\n\tif (untagged && !b53_vlan_port_needs_forced_tagged(ds, port))\n\t\tvl->untag |= BIT(port);\n\telse\n\t\tvl->untag &= ~BIT(port);\n\n\tb53_set_vlan_entry(dev, vlan->vid, vl);\n\tb53_fast_age_vlan(dev, vlan->vid);\n\n\tif (pvid && !dsa_is_cpu_port(ds, port)) {\n\t\tb53_write16(dev, B53_VLAN_PAGE, B53_VLAN_PORT_DEF_TAG(port),\n\t\t\t    vlan->vid);\n\t\tb53_fast_age_vlan(dev, vlan->vid);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(b53_vlan_add);\n\nint b53_vlan_del(struct dsa_switch *ds, int port,\n\t\t const struct switchdev_obj_port_vlan *vlan)\n{\n\tstruct b53_device *dev = ds->priv;\n\tbool untagged = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;\n\tstruct b53_vlan *vl;\n\tu16 pvid;\n\n\tb53_read16(dev, B53_VLAN_PAGE, B53_VLAN_PORT_DEF_TAG(port), &pvid);\n\n\tvl = &dev->vlans[vlan->vid];\n\n\tb53_get_vlan_entry(dev, vlan->vid, vl);\n\n\tvl->members &= ~BIT(port);\n\n\tif (pvid == vlan->vid)\n\t\tpvid = b53_default_pvid(dev);\n\n\tif (untagged && !b53_vlan_port_needs_forced_tagged(ds, port))\n\t\tvl->untag &= ~(BIT(port));\n\n\tb53_set_vlan_entry(dev, vlan->vid, vl);\n\tb53_fast_age_vlan(dev, vlan->vid);\n\n\tb53_write16(dev, B53_VLAN_PAGE, B53_VLAN_PORT_DEF_TAG(port), pvid);\n\tb53_fast_age_vlan(dev, pvid);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(b53_vlan_del);\n\n \nstatic int b53_arl_op_wait(struct b53_device *dev)\n{\n\tunsigned int timeout = 10;\n\tu8 reg;\n\n\tdo {\n\t\tb53_read8(dev, B53_ARLIO_PAGE, B53_ARLTBL_RW_CTRL, &reg);\n\t\tif (!(reg & ARLTBL_START_DONE))\n\t\t\treturn 0;\n\n\t\tusleep_range(1000, 2000);\n\t} while (timeout--);\n\n\tdev_warn(dev->dev, \"timeout waiting for ARL to finish: 0x%02x\\n\", reg);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int b53_arl_rw_op(struct b53_device *dev, unsigned int op)\n{\n\tu8 reg;\n\n\tif (op > ARLTBL_RW)\n\t\treturn -EINVAL;\n\n\tb53_read8(dev, B53_ARLIO_PAGE, B53_ARLTBL_RW_CTRL, &reg);\n\treg |= ARLTBL_START_DONE;\n\tif (op)\n\t\treg |= ARLTBL_RW;\n\telse\n\t\treg &= ~ARLTBL_RW;\n\tif (dev->vlan_enabled)\n\t\treg &= ~ARLTBL_IVL_SVL_SELECT;\n\telse\n\t\treg |= ARLTBL_IVL_SVL_SELECT;\n\tb53_write8(dev, B53_ARLIO_PAGE, B53_ARLTBL_RW_CTRL, reg);\n\n\treturn b53_arl_op_wait(dev);\n}\n\nstatic int b53_arl_read(struct b53_device *dev, u64 mac,\n\t\t\tu16 vid, struct b53_arl_entry *ent, u8 *idx)\n{\n\tDECLARE_BITMAP(free_bins, B53_ARLTBL_MAX_BIN_ENTRIES);\n\tunsigned int i;\n\tint ret;\n\n\tret = b53_arl_op_wait(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tbitmap_zero(free_bins, dev->num_arl_bins);\n\n\t \n\tfor (i = 0; i < dev->num_arl_bins; i++) {\n\t\tu64 mac_vid;\n\t\tu32 fwd_entry;\n\n\t\tb53_read64(dev, B53_ARLIO_PAGE,\n\t\t\t   B53_ARLTBL_MAC_VID_ENTRY(i), &mac_vid);\n\t\tb53_read32(dev, B53_ARLIO_PAGE,\n\t\t\t   B53_ARLTBL_DATA_ENTRY(i), &fwd_entry);\n\t\tb53_arl_to_entry(ent, mac_vid, fwd_entry);\n\n\t\tif (!(fwd_entry & ARLTBL_VALID)) {\n\t\t\tset_bit(i, free_bins);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((mac_vid & ARLTBL_MAC_MASK) != mac)\n\t\t\tcontinue;\n\t\tif (dev->vlan_enabled &&\n\t\t    ((mac_vid >> ARLTBL_VID_S) & ARLTBL_VID_MASK) != vid)\n\t\t\tcontinue;\n\t\t*idx = i;\n\t\treturn 0;\n\t}\n\n\t*idx = find_first_bit(free_bins, dev->num_arl_bins);\n\treturn *idx >= dev->num_arl_bins ? -ENOSPC : -ENOENT;\n}\n\nstatic int b53_arl_op(struct b53_device *dev, int op, int port,\n\t\t      const unsigned char *addr, u16 vid, bool is_valid)\n{\n\tstruct b53_arl_entry ent;\n\tu32 fwd_entry;\n\tu64 mac, mac_vid = 0;\n\tu8 idx = 0;\n\tint ret;\n\n\t \n\tmac = ether_addr_to_u64(addr);\n\n\t \n\tb53_write48(dev, B53_ARLIO_PAGE, B53_MAC_ADDR_IDX, mac);\n\tb53_write16(dev, B53_ARLIO_PAGE, B53_VLAN_ID_IDX, vid);\n\n\t \n\tret = b53_arl_rw_op(dev, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = b53_arl_read(dev, mac, vid, &ent, &idx);\n\n\t \n\tif (op)\n\t\treturn ret;\n\n\tswitch (ret) {\n\tcase -ETIMEDOUT:\n\t\treturn ret;\n\tcase -ENOSPC:\n\t\tdev_dbg(dev->dev, \"{%pM,%.4d} no space left in ARL\\n\",\n\t\t\taddr, vid);\n\t\treturn is_valid ? ret : 0;\n\tcase -ENOENT:\n\t\t \n\t\tdev_dbg(dev->dev, \"{%pM,%.4d} not found, using idx: %d\\n\",\n\t\t\taddr, vid, idx);\n\t\tfwd_entry = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev->dev, \"{%pM,%.4d} found, using idx: %d\\n\",\n\t\t\taddr, vid, idx);\n\t\tbreak;\n\t}\n\n\t \n\tif (!is_multicast_ether_addr(addr)) {\n\t\tent.port = port;\n\t\tent.is_valid = is_valid;\n\t} else {\n\t\tif (is_valid)\n\t\t\tent.port |= BIT(port);\n\t\telse\n\t\t\tent.port &= ~BIT(port);\n\n\t\tent.is_valid = !!(ent.port);\n\t}\n\n\tent.vid = vid;\n\tent.is_static = true;\n\tent.is_age = false;\n\tmemcpy(ent.mac, addr, ETH_ALEN);\n\tb53_arl_from_entry(&mac_vid, &fwd_entry, &ent);\n\n\tb53_write64(dev, B53_ARLIO_PAGE,\n\t\t    B53_ARLTBL_MAC_VID_ENTRY(idx), mac_vid);\n\tb53_write32(dev, B53_ARLIO_PAGE,\n\t\t    B53_ARLTBL_DATA_ENTRY(idx), fwd_entry);\n\n\treturn b53_arl_rw_op(dev, 0);\n}\n\nint b53_fdb_add(struct dsa_switch *ds, int port,\n\t\tconst unsigned char *addr, u16 vid,\n\t\tstruct dsa_db db)\n{\n\tstruct b53_device *priv = ds->priv;\n\tint ret;\n\n\t \n\tif (is5325(priv) || is5365(priv))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&priv->arl_mutex);\n\tret = b53_arl_op(priv, 0, port, addr, vid, true);\n\tmutex_unlock(&priv->arl_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(b53_fdb_add);\n\nint b53_fdb_del(struct dsa_switch *ds, int port,\n\t\tconst unsigned char *addr, u16 vid,\n\t\tstruct dsa_db db)\n{\n\tstruct b53_device *priv = ds->priv;\n\tint ret;\n\n\tmutex_lock(&priv->arl_mutex);\n\tret = b53_arl_op(priv, 0, port, addr, vid, false);\n\tmutex_unlock(&priv->arl_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(b53_fdb_del);\n\nstatic int b53_arl_search_wait(struct b53_device *dev)\n{\n\tunsigned int timeout = 1000;\n\tu8 reg;\n\n\tdo {\n\t\tb53_read8(dev, B53_ARLIO_PAGE, B53_ARL_SRCH_CTL, &reg);\n\t\tif (!(reg & ARL_SRCH_STDN))\n\t\t\treturn 0;\n\n\t\tif (reg & ARL_SRCH_VLID)\n\t\t\treturn 0;\n\n\t\tusleep_range(1000, 2000);\n\t} while (timeout--);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void b53_arl_search_rd(struct b53_device *dev, u8 idx,\n\t\t\t      struct b53_arl_entry *ent)\n{\n\tu64 mac_vid;\n\tu32 fwd_entry;\n\n\tb53_read64(dev, B53_ARLIO_PAGE,\n\t\t   B53_ARL_SRCH_RSTL_MACVID(idx), &mac_vid);\n\tb53_read32(dev, B53_ARLIO_PAGE,\n\t\t   B53_ARL_SRCH_RSTL(idx), &fwd_entry);\n\tb53_arl_to_entry(ent, mac_vid, fwd_entry);\n}\n\nstatic int b53_fdb_copy(int port, const struct b53_arl_entry *ent,\n\t\t\tdsa_fdb_dump_cb_t *cb, void *data)\n{\n\tif (!ent->is_valid)\n\t\treturn 0;\n\n\tif (port != ent->port)\n\t\treturn 0;\n\n\treturn cb(ent->mac, ent->vid, ent->is_static, data);\n}\n\nint b53_fdb_dump(struct dsa_switch *ds, int port,\n\t\t dsa_fdb_dump_cb_t *cb, void *data)\n{\n\tstruct b53_device *priv = ds->priv;\n\tstruct b53_arl_entry results[2];\n\tunsigned int count = 0;\n\tint ret;\n\tu8 reg;\n\n\tmutex_lock(&priv->arl_mutex);\n\n\t \n\treg = ARL_SRCH_STDN;\n\tb53_write8(priv, B53_ARLIO_PAGE, B53_ARL_SRCH_CTL, reg);\n\n\tdo {\n\t\tret = b53_arl_search_wait(priv);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tb53_arl_search_rd(priv, 0, &results[0]);\n\t\tret = b53_fdb_copy(port, &results[0], cb, data);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (priv->num_arl_bins > 2) {\n\t\t\tb53_arl_search_rd(priv, 1, &results[1]);\n\t\t\tret = b53_fdb_copy(port, &results[1], cb, data);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tif (!results[0].is_valid && !results[1].is_valid)\n\t\t\t\tbreak;\n\t\t}\n\n\t} while (count++ < b53_max_arl_entries(priv) / 2);\n\n\tmutex_unlock(&priv->arl_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(b53_fdb_dump);\n\nint b53_mdb_add(struct dsa_switch *ds, int port,\n\t\tconst struct switchdev_obj_port_mdb *mdb,\n\t\tstruct dsa_db db)\n{\n\tstruct b53_device *priv = ds->priv;\n\tint ret;\n\n\t \n\tif (is5325(priv) || is5365(priv))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&priv->arl_mutex);\n\tret = b53_arl_op(priv, 0, port, mdb->addr, mdb->vid, true);\n\tmutex_unlock(&priv->arl_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(b53_mdb_add);\n\nint b53_mdb_del(struct dsa_switch *ds, int port,\n\t\tconst struct switchdev_obj_port_mdb *mdb,\n\t\tstruct dsa_db db)\n{\n\tstruct b53_device *priv = ds->priv;\n\tint ret;\n\n\tmutex_lock(&priv->arl_mutex);\n\tret = b53_arl_op(priv, 0, port, mdb->addr, mdb->vid, false);\n\tmutex_unlock(&priv->arl_mutex);\n\tif (ret)\n\t\tdev_err(ds->dev, \"failed to delete MDB entry\\n\");\n\n\treturn ret;\n}\nEXPORT_SYMBOL(b53_mdb_del);\n\nint b53_br_join(struct dsa_switch *ds, int port, struct dsa_bridge bridge,\n\t\tbool *tx_fwd_offload, struct netlink_ext_ack *extack)\n{\n\tstruct b53_device *dev = ds->priv;\n\ts8 cpu_port = dsa_to_port(ds, port)->cpu_dp->index;\n\tu16 pvlan, reg;\n\tunsigned int i;\n\n\t \n\tif (dev->chip_id == BCM7278_DEVICE_ID && port == 7)\n\t\treturn -EINVAL;\n\n\t \n\tif (is58xx(dev)) {\n\t\tb53_read16(dev, B53_VLAN_PAGE, B53_JOIN_ALL_VLAN_EN, &reg);\n\t\treg &= ~BIT(port);\n\t\tif ((reg & BIT(cpu_port)) == BIT(cpu_port))\n\t\t\treg &= ~BIT(cpu_port);\n\t\tb53_write16(dev, B53_VLAN_PAGE, B53_JOIN_ALL_VLAN_EN, reg);\n\t}\n\n\tb53_read16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(port), &pvlan);\n\n\tb53_for_each_port(dev, i) {\n\t\tif (!dsa_port_offloads_bridge(dsa_to_port(ds, i), &bridge))\n\t\t\tcontinue;\n\n\t\t \n\t\tb53_read16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(i), &reg);\n\t\treg |= BIT(port);\n\t\tb53_write16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(i), reg);\n\t\tdev->ports[i].vlan_ctl_mask = reg;\n\n\t\tpvlan |= BIT(i);\n\t}\n\n\t \n\tb53_write16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(port), pvlan);\n\tdev->ports[port].vlan_ctl_mask = pvlan;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(b53_br_join);\n\nvoid b53_br_leave(struct dsa_switch *ds, int port, struct dsa_bridge bridge)\n{\n\tstruct b53_device *dev = ds->priv;\n\tstruct b53_vlan *vl = &dev->vlans[0];\n\ts8 cpu_port = dsa_to_port(ds, port)->cpu_dp->index;\n\tunsigned int i;\n\tu16 pvlan, reg, pvid;\n\n\tb53_read16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(port), &pvlan);\n\n\tb53_for_each_port(dev, i) {\n\t\t \n\t\tif (!dsa_port_offloads_bridge(dsa_to_port(ds, i), &bridge))\n\t\t\tcontinue;\n\n\t\tb53_read16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(i), &reg);\n\t\treg &= ~BIT(port);\n\t\tb53_write16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(i), reg);\n\t\tdev->ports[port].vlan_ctl_mask = reg;\n\n\t\t \n\t\tif (port != i)\n\t\t\tpvlan &= ~BIT(i);\n\t}\n\n\tb53_write16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(port), pvlan);\n\tdev->ports[port].vlan_ctl_mask = pvlan;\n\n\tpvid = b53_default_pvid(dev);\n\n\t \n\tif (is58xx(dev)) {\n\t\tb53_read16(dev, B53_VLAN_PAGE, B53_JOIN_ALL_VLAN_EN, &reg);\n\t\treg |= BIT(port);\n\t\tif (!(reg & BIT(cpu_port)))\n\t\t\treg |= BIT(cpu_port);\n\t\tb53_write16(dev, B53_VLAN_PAGE, B53_JOIN_ALL_VLAN_EN, reg);\n\t} else {\n\t\tb53_get_vlan_entry(dev, pvid, vl);\n\t\tvl->members |= BIT(port) | BIT(cpu_port);\n\t\tvl->untag |= BIT(port) | BIT(cpu_port);\n\t\tb53_set_vlan_entry(dev, pvid, vl);\n\t}\n}\nEXPORT_SYMBOL(b53_br_leave);\n\nvoid b53_br_set_stp_state(struct dsa_switch *ds, int port, u8 state)\n{\n\tstruct b53_device *dev = ds->priv;\n\tu8 hw_state;\n\tu8 reg;\n\n\tswitch (state) {\n\tcase BR_STATE_DISABLED:\n\t\thw_state = PORT_CTRL_DIS_STATE;\n\t\tbreak;\n\tcase BR_STATE_LISTENING:\n\t\thw_state = PORT_CTRL_LISTEN_STATE;\n\t\tbreak;\n\tcase BR_STATE_LEARNING:\n\t\thw_state = PORT_CTRL_LEARN_STATE;\n\t\tbreak;\n\tcase BR_STATE_FORWARDING:\n\t\thw_state = PORT_CTRL_FWD_STATE;\n\t\tbreak;\n\tcase BR_STATE_BLOCKING:\n\t\thw_state = PORT_CTRL_BLOCK_STATE;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(ds->dev, \"invalid STP state: %d\\n\", state);\n\t\treturn;\n\t}\n\n\tb53_read8(dev, B53_CTRL_PAGE, B53_PORT_CTRL(port), &reg);\n\treg &= ~PORT_CTRL_STP_STATE_MASK;\n\treg |= hw_state;\n\tb53_write8(dev, B53_CTRL_PAGE, B53_PORT_CTRL(port), reg);\n}\nEXPORT_SYMBOL(b53_br_set_stp_state);\n\nvoid b53_br_fast_age(struct dsa_switch *ds, int port)\n{\n\tstruct b53_device *dev = ds->priv;\n\n\tif (b53_fast_age_port(dev, port))\n\t\tdev_err(ds->dev, \"fast ageing failed\\n\");\n}\nEXPORT_SYMBOL(b53_br_fast_age);\n\nint b53_br_flags_pre(struct dsa_switch *ds, int port,\n\t\t     struct switchdev_brport_flags flags,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tif (flags.mask & ~(BR_FLOOD | BR_MCAST_FLOOD | BR_LEARNING))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(b53_br_flags_pre);\n\nint b53_br_flags(struct dsa_switch *ds, int port,\n\t\t struct switchdev_brport_flags flags,\n\t\t struct netlink_ext_ack *extack)\n{\n\tif (flags.mask & BR_FLOOD)\n\t\tb53_port_set_ucast_flood(ds->priv, port,\n\t\t\t\t\t !!(flags.val & BR_FLOOD));\n\tif (flags.mask & BR_MCAST_FLOOD)\n\t\tb53_port_set_mcast_flood(ds->priv, port,\n\t\t\t\t\t !!(flags.val & BR_MCAST_FLOOD));\n\tif (flags.mask & BR_LEARNING)\n\t\tb53_port_set_learning(ds->priv, port,\n\t\t\t\t      !!(flags.val & BR_LEARNING));\n\n\treturn 0;\n}\nEXPORT_SYMBOL(b53_br_flags);\n\nstatic bool b53_possible_cpu_port(struct dsa_switch *ds, int port)\n{\n\t \n\tswitch (port) {\n\tcase B53_CPU_PORT_25:\n\tcase 7:\n\tcase B53_CPU_PORT:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool b53_can_enable_brcm_tags(struct dsa_switch *ds, int port,\n\t\t\t\t     enum dsa_tag_protocol tag_protocol)\n{\n\tbool ret = b53_possible_cpu_port(ds, port);\n\n\tif (!ret) {\n\t\tdev_warn(ds->dev, \"Port %d is not Broadcom tag capable\\n\",\n\t\t\t port);\n\t\treturn ret;\n\t}\n\n\tswitch (tag_protocol) {\n\tcase DSA_TAG_PROTO_BRCM:\n\tcase DSA_TAG_PROTO_BRCM_PREPEND:\n\t\tdev_warn(ds->dev,\n\t\t\t \"Port %d is stacked to Broadcom tag switch\\n\", port);\n\t\tret = false;\n\t\tbreak;\n\tdefault:\n\t\tret = true;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nenum dsa_tag_protocol b53_get_tag_protocol(struct dsa_switch *ds, int port,\n\t\t\t\t\t   enum dsa_tag_protocol mprot)\n{\n\tstruct b53_device *dev = ds->priv;\n\n\tif (!b53_can_enable_brcm_tags(ds, port, mprot)) {\n\t\tdev->tag_protocol = DSA_TAG_PROTO_NONE;\n\t\tgoto out;\n\t}\n\n\t \n\tif (is5325(dev) || is5365(dev) || is63xx(dev)) {\n\t\tdev->tag_protocol = DSA_TAG_PROTO_BRCM_LEGACY;\n\t\tgoto out;\n\t}\n\n\t \n\tif (dev->chip_id == BCM58XX_DEVICE_ID && port == B53_CPU_PORT) {\n\t\tdev->tag_protocol = DSA_TAG_PROTO_BRCM_PREPEND;\n\t\tgoto out;\n\t}\n\n\tdev->tag_protocol = DSA_TAG_PROTO_BRCM;\nout:\n\treturn dev->tag_protocol;\n}\nEXPORT_SYMBOL(b53_get_tag_protocol);\n\nint b53_mirror_add(struct dsa_switch *ds, int port,\n\t\t   struct dsa_mall_mirror_tc_entry *mirror, bool ingress,\n\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct b53_device *dev = ds->priv;\n\tu16 reg, loc;\n\n\tif (ingress)\n\t\tloc = B53_IG_MIR_CTL;\n\telse\n\t\tloc = B53_EG_MIR_CTL;\n\n\tb53_read16(dev, B53_MGMT_PAGE, loc, &reg);\n\treg |= BIT(port);\n\tb53_write16(dev, B53_MGMT_PAGE, loc, reg);\n\n\tb53_read16(dev, B53_MGMT_PAGE, B53_MIR_CAP_CTL, &reg);\n\treg &= ~CAP_PORT_MASK;\n\treg |= mirror->to_local_port;\n\treg |= MIRROR_EN;\n\tb53_write16(dev, B53_MGMT_PAGE, B53_MIR_CAP_CTL, reg);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(b53_mirror_add);\n\nvoid b53_mirror_del(struct dsa_switch *ds, int port,\n\t\t    struct dsa_mall_mirror_tc_entry *mirror)\n{\n\tstruct b53_device *dev = ds->priv;\n\tbool loc_disable = false, other_loc_disable = false;\n\tu16 reg, loc;\n\n\tif (mirror->ingress)\n\t\tloc = B53_IG_MIR_CTL;\n\telse\n\t\tloc = B53_EG_MIR_CTL;\n\n\t \n\tb53_read16(dev, B53_MGMT_PAGE, loc, &reg);\n\treg &= ~BIT(port);\n\tif (!(reg & MIRROR_MASK))\n\t\tloc_disable = true;\n\tb53_write16(dev, B53_MGMT_PAGE, loc, reg);\n\n\t \n\tif (mirror->ingress)\n\t\tb53_read16(dev, B53_MGMT_PAGE, B53_EG_MIR_CTL, &reg);\n\telse\n\t\tb53_read16(dev, B53_MGMT_PAGE, B53_IG_MIR_CTL, &reg);\n\tif (!(reg & MIRROR_MASK))\n\t\tother_loc_disable = true;\n\n\tb53_read16(dev, B53_MGMT_PAGE, B53_MIR_CAP_CTL, &reg);\n\t \n\tif (loc_disable && other_loc_disable) {\n\t\treg &= ~MIRROR_EN;\n\t\treg &= ~mirror->to_local_port;\n\t}\n\tb53_write16(dev, B53_MGMT_PAGE, B53_MIR_CAP_CTL, reg);\n}\nEXPORT_SYMBOL(b53_mirror_del);\n\nvoid b53_eee_enable_set(struct dsa_switch *ds, int port, bool enable)\n{\n\tstruct b53_device *dev = ds->priv;\n\tu16 reg;\n\n\tb53_read16(dev, B53_EEE_PAGE, B53_EEE_EN_CTRL, &reg);\n\tif (enable)\n\t\treg |= BIT(port);\n\telse\n\t\treg &= ~BIT(port);\n\tb53_write16(dev, B53_EEE_PAGE, B53_EEE_EN_CTRL, reg);\n}\nEXPORT_SYMBOL(b53_eee_enable_set);\n\n\n \nint b53_eee_init(struct dsa_switch *ds, int port, struct phy_device *phy)\n{\n\tint ret;\n\n\tret = phy_init_eee(phy, false);\n\tif (ret)\n\t\treturn 0;\n\n\tb53_eee_enable_set(ds, port, true);\n\n\treturn 1;\n}\nEXPORT_SYMBOL(b53_eee_init);\n\nint b53_get_mac_eee(struct dsa_switch *ds, int port, struct ethtool_eee *e)\n{\n\tstruct b53_device *dev = ds->priv;\n\tstruct ethtool_eee *p = &dev->ports[port].eee;\n\tu16 reg;\n\n\tif (is5325(dev) || is5365(dev))\n\t\treturn -EOPNOTSUPP;\n\n\tb53_read16(dev, B53_EEE_PAGE, B53_EEE_LPI_INDICATE, &reg);\n\te->eee_enabled = p->eee_enabled;\n\te->eee_active = !!(reg & BIT(port));\n\n\treturn 0;\n}\nEXPORT_SYMBOL(b53_get_mac_eee);\n\nint b53_set_mac_eee(struct dsa_switch *ds, int port, struct ethtool_eee *e)\n{\n\tstruct b53_device *dev = ds->priv;\n\tstruct ethtool_eee *p = &dev->ports[port].eee;\n\n\tif (is5325(dev) || is5365(dev))\n\t\treturn -EOPNOTSUPP;\n\n\tp->eee_enabled = e->eee_enabled;\n\tb53_eee_enable_set(ds, port, e->eee_enabled);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(b53_set_mac_eee);\n\nstatic int b53_change_mtu(struct dsa_switch *ds, int port, int mtu)\n{\n\tstruct b53_device *dev = ds->priv;\n\tbool enable_jumbo;\n\tbool allow_10_100;\n\n\tif (is5325(dev) || is5365(dev))\n\t\treturn -EOPNOTSUPP;\n\n\tenable_jumbo = (mtu >= JMS_MIN_SIZE);\n\tallow_10_100 = (dev->chip_id == BCM583XX_DEVICE_ID);\n\n\treturn b53_set_jumbo(dev, enable_jumbo, allow_10_100);\n}\n\nstatic int b53_get_max_mtu(struct dsa_switch *ds, int port)\n{\n\treturn JMS_MAX_SIZE;\n}\n\nstatic const struct dsa_switch_ops b53_switch_ops = {\n\t.get_tag_protocol\t= b53_get_tag_protocol,\n\t.setup\t\t\t= b53_setup,\n\t.teardown\t\t= b53_teardown,\n\t.get_strings\t\t= b53_get_strings,\n\t.get_ethtool_stats\t= b53_get_ethtool_stats,\n\t.get_sset_count\t\t= b53_get_sset_count,\n\t.get_ethtool_phy_stats\t= b53_get_ethtool_phy_stats,\n\t.phy_read\t\t= b53_phy_read16,\n\t.phy_write\t\t= b53_phy_write16,\n\t.adjust_link\t\t= b53_adjust_link,\n\t.phylink_get_caps\t= b53_phylink_get_caps,\n\t.phylink_mac_select_pcs\t= b53_phylink_mac_select_pcs,\n\t.phylink_mac_config\t= b53_phylink_mac_config,\n\t.phylink_mac_link_down\t= b53_phylink_mac_link_down,\n\t.phylink_mac_link_up\t= b53_phylink_mac_link_up,\n\t.port_enable\t\t= b53_enable_port,\n\t.port_disable\t\t= b53_disable_port,\n\t.get_mac_eee\t\t= b53_get_mac_eee,\n\t.set_mac_eee\t\t= b53_set_mac_eee,\n\t.port_bridge_join\t= b53_br_join,\n\t.port_bridge_leave\t= b53_br_leave,\n\t.port_pre_bridge_flags\t= b53_br_flags_pre,\n\t.port_bridge_flags\t= b53_br_flags,\n\t.port_stp_state_set\t= b53_br_set_stp_state,\n\t.port_fast_age\t\t= b53_br_fast_age,\n\t.port_vlan_filtering\t= b53_vlan_filtering,\n\t.port_vlan_add\t\t= b53_vlan_add,\n\t.port_vlan_del\t\t= b53_vlan_del,\n\t.port_fdb_dump\t\t= b53_fdb_dump,\n\t.port_fdb_add\t\t= b53_fdb_add,\n\t.port_fdb_del\t\t= b53_fdb_del,\n\t.port_mirror_add\t= b53_mirror_add,\n\t.port_mirror_del\t= b53_mirror_del,\n\t.port_mdb_add\t\t= b53_mdb_add,\n\t.port_mdb_del\t\t= b53_mdb_del,\n\t.port_max_mtu\t\t= b53_get_max_mtu,\n\t.port_change_mtu\t= b53_change_mtu,\n};\n\nstruct b53_chip_data {\n\tu32 chip_id;\n\tconst char *dev_name;\n\tu16 vlans;\n\tu16 enabled_ports;\n\tu8 imp_port;\n\tu8 cpu_port;\n\tu8 vta_regs[3];\n\tu8 arl_bins;\n\tu16 arl_buckets;\n\tu8 duplex_reg;\n\tu8 jumbo_pm_reg;\n\tu8 jumbo_size_reg;\n};\n\n#define B53_VTA_REGS\t\\\n\t{ B53_VT_ACCESS, B53_VT_INDEX, B53_VT_ENTRY }\n#define B53_VTA_REGS_9798 \\\n\t{ B53_VT_ACCESS_9798, B53_VT_INDEX_9798, B53_VT_ENTRY_9798 }\n#define B53_VTA_REGS_63XX \\\n\t{ B53_VT_ACCESS_63XX, B53_VT_INDEX_63XX, B53_VT_ENTRY_63XX }\n\nstatic const struct b53_chip_data b53_switch_chips[] = {\n\t{\n\t\t.chip_id = BCM5325_DEVICE_ID,\n\t\t.dev_name = \"BCM5325\",\n\t\t.vlans = 16,\n\t\t.enabled_ports = 0x3f,\n\t\t.arl_bins = 2,\n\t\t.arl_buckets = 1024,\n\t\t.imp_port = 5,\n\t\t.duplex_reg = B53_DUPLEX_STAT_FE,\n\t},\n\t{\n\t\t.chip_id = BCM5365_DEVICE_ID,\n\t\t.dev_name = \"BCM5365\",\n\t\t.vlans = 256,\n\t\t.enabled_ports = 0x3f,\n\t\t.arl_bins = 2,\n\t\t.arl_buckets = 1024,\n\t\t.imp_port = 5,\n\t\t.duplex_reg = B53_DUPLEX_STAT_FE,\n\t},\n\t{\n\t\t.chip_id = BCM5389_DEVICE_ID,\n\t\t.dev_name = \"BCM5389\",\n\t\t.vlans = 4096,\n\t\t.enabled_ports = 0x11f,\n\t\t.arl_bins = 4,\n\t\t.arl_buckets = 1024,\n\t\t.imp_port = 8,\n\t\t.vta_regs = B53_VTA_REGS,\n\t\t.duplex_reg = B53_DUPLEX_STAT_GE,\n\t\t.jumbo_pm_reg = B53_JUMBO_PORT_MASK,\n\t\t.jumbo_size_reg = B53_JUMBO_MAX_SIZE,\n\t},\n\t{\n\t\t.chip_id = BCM5395_DEVICE_ID,\n\t\t.dev_name = \"BCM5395\",\n\t\t.vlans = 4096,\n\t\t.enabled_ports = 0x11f,\n\t\t.arl_bins = 4,\n\t\t.arl_buckets = 1024,\n\t\t.imp_port = 8,\n\t\t.vta_regs = B53_VTA_REGS,\n\t\t.duplex_reg = B53_DUPLEX_STAT_GE,\n\t\t.jumbo_pm_reg = B53_JUMBO_PORT_MASK,\n\t\t.jumbo_size_reg = B53_JUMBO_MAX_SIZE,\n\t},\n\t{\n\t\t.chip_id = BCM5397_DEVICE_ID,\n\t\t.dev_name = \"BCM5397\",\n\t\t.vlans = 4096,\n\t\t.enabled_ports = 0x11f,\n\t\t.arl_bins = 4,\n\t\t.arl_buckets = 1024,\n\t\t.imp_port = 8,\n\t\t.vta_regs = B53_VTA_REGS_9798,\n\t\t.duplex_reg = B53_DUPLEX_STAT_GE,\n\t\t.jumbo_pm_reg = B53_JUMBO_PORT_MASK,\n\t\t.jumbo_size_reg = B53_JUMBO_MAX_SIZE,\n\t},\n\t{\n\t\t.chip_id = BCM5398_DEVICE_ID,\n\t\t.dev_name = \"BCM5398\",\n\t\t.vlans = 4096,\n\t\t.enabled_ports = 0x17f,\n\t\t.arl_bins = 4,\n\t\t.arl_buckets = 1024,\n\t\t.imp_port = 8,\n\t\t.vta_regs = B53_VTA_REGS_9798,\n\t\t.duplex_reg = B53_DUPLEX_STAT_GE,\n\t\t.jumbo_pm_reg = B53_JUMBO_PORT_MASK,\n\t\t.jumbo_size_reg = B53_JUMBO_MAX_SIZE,\n\t},\n\t{\n\t\t.chip_id = BCM53115_DEVICE_ID,\n\t\t.dev_name = \"BCM53115\",\n\t\t.vlans = 4096,\n\t\t.enabled_ports = 0x11f,\n\t\t.arl_bins = 4,\n\t\t.arl_buckets = 1024,\n\t\t.vta_regs = B53_VTA_REGS,\n\t\t.imp_port = 8,\n\t\t.duplex_reg = B53_DUPLEX_STAT_GE,\n\t\t.jumbo_pm_reg = B53_JUMBO_PORT_MASK,\n\t\t.jumbo_size_reg = B53_JUMBO_MAX_SIZE,\n\t},\n\t{\n\t\t.chip_id = BCM53125_DEVICE_ID,\n\t\t.dev_name = \"BCM53125\",\n\t\t.vlans = 4096,\n\t\t.enabled_ports = 0x1ff,\n\t\t.arl_bins = 4,\n\t\t.arl_buckets = 1024,\n\t\t.imp_port = 8,\n\t\t.vta_regs = B53_VTA_REGS,\n\t\t.duplex_reg = B53_DUPLEX_STAT_GE,\n\t\t.jumbo_pm_reg = B53_JUMBO_PORT_MASK,\n\t\t.jumbo_size_reg = B53_JUMBO_MAX_SIZE,\n\t},\n\t{\n\t\t.chip_id = BCM53128_DEVICE_ID,\n\t\t.dev_name = \"BCM53128\",\n\t\t.vlans = 4096,\n\t\t.enabled_ports = 0x1ff,\n\t\t.arl_bins = 4,\n\t\t.arl_buckets = 1024,\n\t\t.imp_port = 8,\n\t\t.vta_regs = B53_VTA_REGS,\n\t\t.duplex_reg = B53_DUPLEX_STAT_GE,\n\t\t.jumbo_pm_reg = B53_JUMBO_PORT_MASK,\n\t\t.jumbo_size_reg = B53_JUMBO_MAX_SIZE,\n\t},\n\t{\n\t\t.chip_id = BCM63XX_DEVICE_ID,\n\t\t.dev_name = \"BCM63xx\",\n\t\t.vlans = 4096,\n\t\t.enabled_ports = 0,  \n\t\t.arl_bins = 4,\n\t\t.arl_buckets = 1024,\n\t\t.imp_port = 8,\n\t\t.vta_regs = B53_VTA_REGS_63XX,\n\t\t.duplex_reg = B53_DUPLEX_STAT_63XX,\n\t\t.jumbo_pm_reg = B53_JUMBO_PORT_MASK_63XX,\n\t\t.jumbo_size_reg = B53_JUMBO_MAX_SIZE_63XX,\n\t},\n\t{\n\t\t.chip_id = BCM63268_DEVICE_ID,\n\t\t.dev_name = \"BCM63268\",\n\t\t.vlans = 4096,\n\t\t.enabled_ports = 0,  \n\t\t.arl_bins = 4,\n\t\t.arl_buckets = 1024,\n\t\t.imp_port = 8,\n\t\t.vta_regs = B53_VTA_REGS_63XX,\n\t\t.duplex_reg = B53_DUPLEX_STAT_63XX,\n\t\t.jumbo_pm_reg = B53_JUMBO_PORT_MASK_63XX,\n\t\t.jumbo_size_reg = B53_JUMBO_MAX_SIZE_63XX,\n\t},\n\t{\n\t\t.chip_id = BCM53010_DEVICE_ID,\n\t\t.dev_name = \"BCM53010\",\n\t\t.vlans = 4096,\n\t\t.enabled_ports = 0x1bf,\n\t\t.arl_bins = 4,\n\t\t.arl_buckets = 1024,\n\t\t.imp_port = 8,\n\t\t.vta_regs = B53_VTA_REGS,\n\t\t.duplex_reg = B53_DUPLEX_STAT_GE,\n\t\t.jumbo_pm_reg = B53_JUMBO_PORT_MASK,\n\t\t.jumbo_size_reg = B53_JUMBO_MAX_SIZE,\n\t},\n\t{\n\t\t.chip_id = BCM53011_DEVICE_ID,\n\t\t.dev_name = \"BCM53011\",\n\t\t.vlans = 4096,\n\t\t.enabled_ports = 0x1bf,\n\t\t.arl_bins = 4,\n\t\t.arl_buckets = 1024,\n\t\t.imp_port = 8,\n\t\t.vta_regs = B53_VTA_REGS,\n\t\t.duplex_reg = B53_DUPLEX_STAT_GE,\n\t\t.jumbo_pm_reg = B53_JUMBO_PORT_MASK,\n\t\t.jumbo_size_reg = B53_JUMBO_MAX_SIZE,\n\t},\n\t{\n\t\t.chip_id = BCM53012_DEVICE_ID,\n\t\t.dev_name = \"BCM53012\",\n\t\t.vlans = 4096,\n\t\t.enabled_ports = 0x1bf,\n\t\t.arl_bins = 4,\n\t\t.arl_buckets = 1024,\n\t\t.imp_port = 8,\n\t\t.vta_regs = B53_VTA_REGS,\n\t\t.duplex_reg = B53_DUPLEX_STAT_GE,\n\t\t.jumbo_pm_reg = B53_JUMBO_PORT_MASK,\n\t\t.jumbo_size_reg = B53_JUMBO_MAX_SIZE,\n\t},\n\t{\n\t\t.chip_id = BCM53018_DEVICE_ID,\n\t\t.dev_name = \"BCM53018\",\n\t\t.vlans = 4096,\n\t\t.enabled_ports = 0x1bf,\n\t\t.arl_bins = 4,\n\t\t.arl_buckets = 1024,\n\t\t.imp_port = 8,\n\t\t.vta_regs = B53_VTA_REGS,\n\t\t.duplex_reg = B53_DUPLEX_STAT_GE,\n\t\t.jumbo_pm_reg = B53_JUMBO_PORT_MASK,\n\t\t.jumbo_size_reg = B53_JUMBO_MAX_SIZE,\n\t},\n\t{\n\t\t.chip_id = BCM53019_DEVICE_ID,\n\t\t.dev_name = \"BCM53019\",\n\t\t.vlans = 4096,\n\t\t.enabled_ports = 0x1bf,\n\t\t.arl_bins = 4,\n\t\t.arl_buckets = 1024,\n\t\t.imp_port = 8,\n\t\t.vta_regs = B53_VTA_REGS,\n\t\t.duplex_reg = B53_DUPLEX_STAT_GE,\n\t\t.jumbo_pm_reg = B53_JUMBO_PORT_MASK,\n\t\t.jumbo_size_reg = B53_JUMBO_MAX_SIZE,\n\t},\n\t{\n\t\t.chip_id = BCM58XX_DEVICE_ID,\n\t\t.dev_name = \"BCM585xx/586xx/88312\",\n\t\t.vlans\t= 4096,\n\t\t.enabled_ports = 0x1ff,\n\t\t.arl_bins = 4,\n\t\t.arl_buckets = 1024,\n\t\t.imp_port = 8,\n\t\t.vta_regs = B53_VTA_REGS,\n\t\t.duplex_reg = B53_DUPLEX_STAT_GE,\n\t\t.jumbo_pm_reg = B53_JUMBO_PORT_MASK,\n\t\t.jumbo_size_reg = B53_JUMBO_MAX_SIZE,\n\t},\n\t{\n\t\t.chip_id = BCM583XX_DEVICE_ID,\n\t\t.dev_name = \"BCM583xx/11360\",\n\t\t.vlans = 4096,\n\t\t.enabled_ports = 0x103,\n\t\t.arl_bins = 4,\n\t\t.arl_buckets = 1024,\n\t\t.imp_port = 8,\n\t\t.vta_regs = B53_VTA_REGS,\n\t\t.duplex_reg = B53_DUPLEX_STAT_GE,\n\t\t.jumbo_pm_reg = B53_JUMBO_PORT_MASK,\n\t\t.jumbo_size_reg = B53_JUMBO_MAX_SIZE,\n\t},\n\t \n\t{\n\t\t.chip_id = BCM4908_DEVICE_ID,\n\t\t.dev_name = \"BCM4908\",\n\t\t.vlans = 4096,\n\t\t.enabled_ports = 0x1bf,\n\t\t.arl_bins = 4,\n\t\t.arl_buckets = 256,\n\t\t.imp_port = 8,\n\t\t.vta_regs = B53_VTA_REGS,\n\t\t.duplex_reg = B53_DUPLEX_STAT_GE,\n\t\t.jumbo_pm_reg = B53_JUMBO_PORT_MASK,\n\t\t.jumbo_size_reg = B53_JUMBO_MAX_SIZE,\n\t},\n\t{\n\t\t.chip_id = BCM7445_DEVICE_ID,\n\t\t.dev_name = \"BCM7445\",\n\t\t.vlans\t= 4096,\n\t\t.enabled_ports = 0x1ff,\n\t\t.arl_bins = 4,\n\t\t.arl_buckets = 1024,\n\t\t.imp_port = 8,\n\t\t.vta_regs = B53_VTA_REGS,\n\t\t.duplex_reg = B53_DUPLEX_STAT_GE,\n\t\t.jumbo_pm_reg = B53_JUMBO_PORT_MASK,\n\t\t.jumbo_size_reg = B53_JUMBO_MAX_SIZE,\n\t},\n\t{\n\t\t.chip_id = BCM7278_DEVICE_ID,\n\t\t.dev_name = \"BCM7278\",\n\t\t.vlans = 4096,\n\t\t.enabled_ports = 0x1ff,\n\t\t.arl_bins = 4,\n\t\t.arl_buckets = 256,\n\t\t.imp_port = 8,\n\t\t.vta_regs = B53_VTA_REGS,\n\t\t.duplex_reg = B53_DUPLEX_STAT_GE,\n\t\t.jumbo_pm_reg = B53_JUMBO_PORT_MASK,\n\t\t.jumbo_size_reg = B53_JUMBO_MAX_SIZE,\n\t},\n\t{\n\t\t.chip_id = BCM53134_DEVICE_ID,\n\t\t.dev_name = \"BCM53134\",\n\t\t.vlans = 4096,\n\t\t.enabled_ports = 0x12f,\n\t\t.imp_port = 8,\n\t\t.cpu_port = B53_CPU_PORT,\n\t\t.vta_regs = B53_VTA_REGS,\n\t\t.arl_bins = 4,\n\t\t.arl_buckets = 1024,\n\t\t.duplex_reg = B53_DUPLEX_STAT_GE,\n\t\t.jumbo_pm_reg = B53_JUMBO_PORT_MASK,\n\t\t.jumbo_size_reg = B53_JUMBO_MAX_SIZE,\n\t},\n};\n\nstatic int b53_switch_init(struct b53_device *dev)\n{\n\tunsigned int i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(b53_switch_chips); i++) {\n\t\tconst struct b53_chip_data *chip = &b53_switch_chips[i];\n\n\t\tif (chip->chip_id == dev->chip_id) {\n\t\t\tif (!dev->enabled_ports)\n\t\t\t\tdev->enabled_ports = chip->enabled_ports;\n\t\t\tdev->name = chip->dev_name;\n\t\t\tdev->duplex_reg = chip->duplex_reg;\n\t\t\tdev->vta_regs[0] = chip->vta_regs[0];\n\t\t\tdev->vta_regs[1] = chip->vta_regs[1];\n\t\t\tdev->vta_regs[2] = chip->vta_regs[2];\n\t\t\tdev->jumbo_pm_reg = chip->jumbo_pm_reg;\n\t\t\tdev->imp_port = chip->imp_port;\n\t\t\tdev->num_vlans = chip->vlans;\n\t\t\tdev->num_arl_bins = chip->arl_bins;\n\t\t\tdev->num_arl_buckets = chip->arl_buckets;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (is5325(dev)) {\n\t\tu8 vc4;\n\n\t\tb53_read8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL4_25, &vc4);\n\n\t\t \n\t\tswitch (vc4 & 3) {\n\t\tcase 1:\n\t\t\t \n\t\t\tbreak;\n\t\tcase 3:\n\t\t\t \n\t\t\tdev->enabled_ports &= ~BIT(4);\n\t\t\tbreak;\n\t\tdefault:\n \n#ifndef CONFIG_BCM47XX\n\t\t\t \n\t\t\treturn -EINVAL;\n#else\n\t\t\tbreak;\n#endif\n\t\t}\n\t}\n\n\tdev->num_ports = fls(dev->enabled_ports);\n\n\tdev->ds->num_ports = min_t(unsigned int, dev->num_ports, DSA_MAX_PORTS);\n\n\t \n\tif (is539x(dev) || is531x5(dev)) {\n\t\tfor (i = 0; i < dev->num_ports; i++) {\n\t\t\tif (!(dev->ds->phys_mii_mask & BIT(i)) &&\n\t\t\t    !b53_possible_cpu_port(dev->ds, i))\n\t\t\t\tdev->ds->phys_mii_mask |= BIT(i);\n\t\t}\n\t}\n\n\tdev->ports = devm_kcalloc(dev->dev,\n\t\t\t\t  dev->num_ports, sizeof(struct b53_port),\n\t\t\t\t  GFP_KERNEL);\n\tif (!dev->ports)\n\t\treturn -ENOMEM;\n\n\tdev->vlans = devm_kcalloc(dev->dev,\n\t\t\t\t  dev->num_vlans, sizeof(struct b53_vlan),\n\t\t\t\t  GFP_KERNEL);\n\tif (!dev->vlans)\n\t\treturn -ENOMEM;\n\n\tdev->reset_gpio = b53_switch_get_reset_gpio(dev);\n\tif (dev->reset_gpio >= 0) {\n\t\tret = devm_gpio_request_one(dev->dev, dev->reset_gpio,\n\t\t\t\t\t    GPIOF_OUT_INIT_HIGH, \"robo_reset\");\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstruct b53_device *b53_switch_alloc(struct device *base,\n\t\t\t\t    const struct b53_io_ops *ops,\n\t\t\t\t    void *priv)\n{\n\tstruct dsa_switch *ds;\n\tstruct b53_device *dev;\n\n\tds = devm_kzalloc(base, sizeof(*ds), GFP_KERNEL);\n\tif (!ds)\n\t\treturn NULL;\n\n\tds->dev = base;\n\n\tdev = devm_kzalloc(base, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn NULL;\n\n\tds->priv = dev;\n\tdev->dev = base;\n\n\tdev->ds = ds;\n\tdev->priv = priv;\n\tdev->ops = ops;\n\tds->ops = &b53_switch_ops;\n\tdev->vlan_enabled = true;\n\t \n\tds->vlan_filtering_is_global = true;\n\n\tmutex_init(&dev->reg_mutex);\n\tmutex_init(&dev->stats_mutex);\n\tmutex_init(&dev->arl_mutex);\n\n\treturn dev;\n}\nEXPORT_SYMBOL(b53_switch_alloc);\n\nint b53_switch_detect(struct b53_device *dev)\n{\n\tu32 id32;\n\tu16 tmp;\n\tu8 id8;\n\tint ret;\n\n\tret = b53_read8(dev, B53_MGMT_PAGE, B53_DEVICE_ID, &id8);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (id8) {\n\tcase 0:\n\t\t \n\t\tb53_write16(dev, B53_VLAN_PAGE, B53_VLAN_TABLE_ACCESS_25, 0xf);\n\t\tb53_read16(dev, B53_VLAN_PAGE, B53_VLAN_TABLE_ACCESS_25, &tmp);\n\n\t\tif (tmp == 0xf)\n\t\t\tdev->chip_id = BCM5325_DEVICE_ID;\n\t\telse\n\t\t\tdev->chip_id = BCM5365_DEVICE_ID;\n\t\tbreak;\n\tcase BCM5389_DEVICE_ID:\n\tcase BCM5395_DEVICE_ID:\n\tcase BCM5397_DEVICE_ID:\n\tcase BCM5398_DEVICE_ID:\n\t\tdev->chip_id = id8;\n\t\tbreak;\n\tdefault:\n\t\tret = b53_read32(dev, B53_MGMT_PAGE, B53_DEVICE_ID, &id32);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tswitch (id32) {\n\t\tcase BCM53115_DEVICE_ID:\n\t\tcase BCM53125_DEVICE_ID:\n\t\tcase BCM53128_DEVICE_ID:\n\t\tcase BCM53010_DEVICE_ID:\n\t\tcase BCM53011_DEVICE_ID:\n\t\tcase BCM53012_DEVICE_ID:\n\t\tcase BCM53018_DEVICE_ID:\n\t\tcase BCM53019_DEVICE_ID:\n\t\tcase BCM53134_DEVICE_ID:\n\t\t\tdev->chip_id = id32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"unsupported switch detected (BCM53%02x/BCM%x)\\n\",\n\t\t\t\tid8, id32);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tif (dev->chip_id == BCM5325_DEVICE_ID)\n\t\treturn b53_read8(dev, B53_STAT_PAGE, B53_REV_ID_25,\n\t\t\t\t &dev->core_rev);\n\telse\n\t\treturn b53_read8(dev, B53_MGMT_PAGE, B53_REV_ID,\n\t\t\t\t &dev->core_rev);\n}\nEXPORT_SYMBOL(b53_switch_detect);\n\nint b53_switch_register(struct b53_device *dev)\n{\n\tint ret;\n\n\tif (dev->pdata) {\n\t\tdev->chip_id = dev->pdata->chip_id;\n\t\tdev->enabled_ports = dev->pdata->enabled_ports;\n\t}\n\n\tif (!dev->chip_id && b53_switch_detect(dev))\n\t\treturn -EINVAL;\n\n\tret = b53_switch_init(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(dev->dev, \"found switch: %s, rev %i\\n\",\n\t\t dev->name, dev->core_rev);\n\n\treturn dsa_register_switch(dev->ds);\n}\nEXPORT_SYMBOL(b53_switch_register);\n\nMODULE_AUTHOR(\"Jonas Gorski <jogo@openwrt.org>\");\nMODULE_DESCRIPTION(\"B53 switch library\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}