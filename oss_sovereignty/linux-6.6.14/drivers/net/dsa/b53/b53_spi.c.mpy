{
  "module_name": "b53_spi.c",
  "hash_id": "95f35001de8d1e10c0b13023cc45ab14b3e2e439b5f56a8bd4e0c5a2bfe7c0a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/b53/b53_spi.c",
  "human_readable_source": " \n\n#include <asm/unaligned.h>\n\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/spi/spi.h>\n#include <linux/platform_data/b53.h>\n\n#include \"b53_priv.h\"\n\n#define B53_SPI_DATA\t\t0xf0\n\n#define B53_SPI_STATUS\t\t0xfe\n#define B53_SPI_CMD_SPIF\tBIT(7)\n#define B53_SPI_CMD_RACK\tBIT(5)\n\n#define B53_SPI_CMD_READ\t0x00\n#define B53_SPI_CMD_WRITE\t0x01\n#define B53_SPI_CMD_NORMAL\t0x60\n#define B53_SPI_CMD_FAST\t0x10\n\n#define B53_SPI_PAGE_SELECT\t0xff\n\nstatic inline int b53_spi_read_reg(struct spi_device *spi, u8 reg, u8 *val,\n\t\t\t\t   unsigned int len)\n{\n\tu8 txbuf[2];\n\n\ttxbuf[0] = B53_SPI_CMD_NORMAL | B53_SPI_CMD_READ;\n\ttxbuf[1] = reg;\n\n\treturn spi_write_then_read(spi, txbuf, 2, val, len);\n}\n\nstatic inline int b53_spi_clear_status(struct spi_device *spi)\n{\n\tunsigned int i;\n\tu8 rxbuf;\n\tint ret;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tret = b53_spi_read_reg(spi, B53_SPI_STATUS, &rxbuf, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!(rxbuf & B53_SPI_CMD_SPIF))\n\t\t\tbreak;\n\n\t\tmdelay(1);\n\t}\n\n\tif (i == 10)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic inline int b53_spi_set_page(struct spi_device *spi, u8 page)\n{\n\tu8 txbuf[3];\n\n\ttxbuf[0] = B53_SPI_CMD_NORMAL | B53_SPI_CMD_WRITE;\n\ttxbuf[1] = B53_SPI_PAGE_SELECT;\n\ttxbuf[2] = page;\n\n\treturn spi_write(spi, txbuf, sizeof(txbuf));\n}\n\nstatic inline int b53_prepare_reg_access(struct spi_device *spi, u8 page)\n{\n\tint ret = b53_spi_clear_status(spi);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn b53_spi_set_page(spi, page);\n}\n\nstatic int b53_spi_prepare_reg_read(struct spi_device *spi, u8 reg)\n{\n\tu8 rxbuf;\n\tint retry_count;\n\tint ret;\n\n\tret = b53_spi_read_reg(spi, reg, &rxbuf, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (retry_count = 0; retry_count < 10; retry_count++) {\n\t\tret = b53_spi_read_reg(spi, B53_SPI_STATUS, &rxbuf, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (rxbuf & B53_SPI_CMD_RACK)\n\t\t\tbreak;\n\n\t\tmdelay(1);\n\t}\n\n\tif (retry_count == 10)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int b53_spi_read(struct b53_device *dev, u8 page, u8 reg, u8 *data,\n\t\t\tunsigned int len)\n{\n\tstruct spi_device *spi = dev->priv;\n\tint ret;\n\n\tret = b53_prepare_reg_access(spi, page);\n\tif (ret)\n\t\treturn ret;\n\n\tret = b53_spi_prepare_reg_read(spi, reg);\n\tif (ret)\n\t\treturn ret;\n\n\treturn b53_spi_read_reg(spi, B53_SPI_DATA, data, len);\n}\n\nstatic int b53_spi_read8(struct b53_device *dev, u8 page, u8 reg, u8 *val)\n{\n\treturn b53_spi_read(dev, page, reg, val, 1);\n}\n\nstatic int b53_spi_read16(struct b53_device *dev, u8 page, u8 reg, u16 *val)\n{\n\t__le16 value;\n\tint ret;\n\n\tret = b53_spi_read(dev, page, reg, (u8 *)&value, 2);\n\n\tif (!ret)\n\t\t*val = le16_to_cpu(value);\n\n\treturn ret;\n}\n\nstatic int b53_spi_read32(struct b53_device *dev, u8 page, u8 reg, u32 *val)\n{\n\t__le32 value;\n\tint ret;\n\n\tret = b53_spi_read(dev, page, reg, (u8 *)&value, 4);\n\n\tif (!ret)\n\t\t*val = le32_to_cpu(value);\n\n\treturn ret;\n}\n\nstatic int b53_spi_read48(struct b53_device *dev, u8 page, u8 reg, u64 *val)\n{\n\t__le64 value;\n\tint ret;\n\n\t*val = 0;\n\tret = b53_spi_read(dev, page, reg, (u8 *)&value, 6);\n\tif (!ret)\n\t\t*val = le64_to_cpu(value);\n\n\treturn ret;\n}\n\nstatic int b53_spi_read64(struct b53_device *dev, u8 page, u8 reg, u64 *val)\n{\n\t__le64 value;\n\tint ret;\n\n\tret = b53_spi_read(dev, page, reg, (u8 *)&value, 8);\n\n\tif (!ret)\n\t\t*val = le64_to_cpu(value);\n\n\treturn ret;\n}\n\nstatic int b53_spi_write8(struct b53_device *dev, u8 page, u8 reg, u8 value)\n{\n\tstruct spi_device *spi = dev->priv;\n\tint ret;\n\tu8 txbuf[3];\n\n\tret = b53_prepare_reg_access(spi, page);\n\tif (ret)\n\t\treturn ret;\n\n\ttxbuf[0] = B53_SPI_CMD_NORMAL | B53_SPI_CMD_WRITE;\n\ttxbuf[1] = reg;\n\ttxbuf[2] = value;\n\n\treturn spi_write(spi, txbuf, sizeof(txbuf));\n}\n\nstatic int b53_spi_write16(struct b53_device *dev, u8 page, u8 reg, u16 value)\n{\n\tstruct spi_device *spi = dev->priv;\n\tint ret;\n\tu8 txbuf[4];\n\n\tret = b53_prepare_reg_access(spi, page);\n\tif (ret)\n\t\treturn ret;\n\n\ttxbuf[0] = B53_SPI_CMD_NORMAL | B53_SPI_CMD_WRITE;\n\ttxbuf[1] = reg;\n\tput_unaligned_le16(value, &txbuf[2]);\n\n\treturn spi_write(spi, txbuf, sizeof(txbuf));\n}\n\nstatic int b53_spi_write32(struct b53_device *dev, u8 page, u8 reg, u32 value)\n{\n\tstruct spi_device *spi = dev->priv;\n\tint ret;\n\tu8 txbuf[6];\n\n\tret = b53_prepare_reg_access(spi, page);\n\tif (ret)\n\t\treturn ret;\n\n\ttxbuf[0] = B53_SPI_CMD_NORMAL | B53_SPI_CMD_WRITE;\n\ttxbuf[1] = reg;\n\tput_unaligned_le32(value, &txbuf[2]);\n\n\treturn spi_write(spi, txbuf, sizeof(txbuf));\n}\n\nstatic int b53_spi_write48(struct b53_device *dev, u8 page, u8 reg, u64 value)\n{\n\tstruct spi_device *spi = dev->priv;\n\tint ret;\n\tu8 txbuf[10];\n\n\tret = b53_prepare_reg_access(spi, page);\n\tif (ret)\n\t\treturn ret;\n\n\ttxbuf[0] = B53_SPI_CMD_NORMAL | B53_SPI_CMD_WRITE;\n\ttxbuf[1] = reg;\n\tput_unaligned_le64(value, &txbuf[2]);\n\n\treturn spi_write(spi, txbuf, sizeof(txbuf) - 2);\n}\n\nstatic int b53_spi_write64(struct b53_device *dev, u8 page, u8 reg, u64 value)\n{\n\tstruct spi_device *spi = dev->priv;\n\tint ret;\n\tu8 txbuf[10];\n\n\tret = b53_prepare_reg_access(spi, page);\n\tif (ret)\n\t\treturn ret;\n\n\ttxbuf[0] = B53_SPI_CMD_NORMAL | B53_SPI_CMD_WRITE;\n\ttxbuf[1] = reg;\n\tput_unaligned_le64(value, &txbuf[2]);\n\n\treturn spi_write(spi, txbuf, sizeof(txbuf));\n}\n\nstatic const struct b53_io_ops b53_spi_ops = {\n\t.read8 = b53_spi_read8,\n\t.read16 = b53_spi_read16,\n\t.read32 = b53_spi_read32,\n\t.read48 = b53_spi_read48,\n\t.read64 = b53_spi_read64,\n\t.write8 = b53_spi_write8,\n\t.write16 = b53_spi_write16,\n\t.write32 = b53_spi_write32,\n\t.write48 = b53_spi_write48,\n\t.write64 = b53_spi_write64,\n};\n\nstatic int b53_spi_probe(struct spi_device *spi)\n{\n\tstruct b53_device *dev;\n\tint ret;\n\n\tdev = b53_switch_alloc(&spi->dev, &b53_spi_ops, spi);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tif (spi->dev.platform_data)\n\t\tdev->pdata = spi->dev.platform_data;\n\n\tret = b53_switch_register(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tspi_set_drvdata(spi, dev);\n\n\treturn 0;\n}\n\nstatic void b53_spi_remove(struct spi_device *spi)\n{\n\tstruct b53_device *dev = spi_get_drvdata(spi);\n\n\tif (dev)\n\t\tb53_switch_remove(dev);\n}\n\nstatic void b53_spi_shutdown(struct spi_device *spi)\n{\n\tstruct b53_device *dev = spi_get_drvdata(spi);\n\n\tif (dev)\n\t\tb53_switch_shutdown(dev);\n\n\tspi_set_drvdata(spi, NULL);\n}\n\nstatic const struct of_device_id b53_spi_of_match[] = {\n\t{ .compatible = \"brcm,bcm5325\" },\n\t{ .compatible = \"brcm,bcm5365\" },\n\t{ .compatible = \"brcm,bcm5395\" },\n\t{ .compatible = \"brcm,bcm5397\" },\n\t{ .compatible = \"brcm,bcm5398\" },\n\t{ .compatible = \"brcm,bcm53115\" },\n\t{ .compatible = \"brcm,bcm53125\" },\n\t{ .compatible = \"brcm,bcm53128\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, b53_spi_of_match);\n\nstatic const struct spi_device_id b53_spi_ids[] = {\n\t{ .name = \"bcm5325\" },\n\t{ .name = \"bcm5365\" },\n\t{ .name = \"bcm5395\" },\n\t{ .name = \"bcm5397\" },\n\t{ .name = \"bcm5398\" },\n\t{ .name = \"bcm53115\" },\n\t{ .name = \"bcm53125\" },\n\t{ .name = \"bcm53128\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(spi, b53_spi_ids);\n\nstatic struct spi_driver b53_spi_driver = {\n\t.driver = {\n\t\t.name\t= \"b53-switch\",\n\t\t.of_match_table = b53_spi_of_match,\n\t},\n\t.probe\t= b53_spi_probe,\n\t.remove\t= b53_spi_remove,\n\t.shutdown = b53_spi_shutdown,\n\t.id_table = b53_spi_ids,\n};\n\nmodule_spi_driver(b53_spi_driver);\n\nMODULE_AUTHOR(\"Jonas Gorski <jogo@openwrt.org>\");\nMODULE_DESCRIPTION(\"B53 SPI access driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}