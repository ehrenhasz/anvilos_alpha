{
  "module_name": "b53_serdes.c",
  "hash_id": "b534d14ee29e5802f02d47320e1278787a70a6a3e488d436e6fb2eba0eedf3f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/b53/b53_serdes.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/phy.h>\n#include <linux/phylink.h>\n#include <net/dsa.h>\n\n#include \"b53_priv.h\"\n#include \"b53_serdes.h\"\n#include \"b53_regs.h\"\n\nstatic inline struct b53_pcs *pcs_to_b53_pcs(struct phylink_pcs *pcs)\n{\n\treturn container_of(pcs, struct b53_pcs, pcs);\n}\n\nstatic void b53_serdes_write_blk(struct b53_device *dev, u8 offset, u16 block,\n\t\t\t\t u16 value)\n{\n\tb53_write16(dev, B53_SERDES_PAGE, B53_SERDES_BLKADDR, block);\n\tb53_write16(dev, B53_SERDES_PAGE, offset, value);\n}\n\nstatic u16 b53_serdes_read_blk(struct b53_device *dev, u8 offset, u16 block)\n{\n\tu16 value;\n\n\tb53_write16(dev, B53_SERDES_PAGE, B53_SERDES_BLKADDR, block);\n\tb53_read16(dev, B53_SERDES_PAGE, offset, &value);\n\n\treturn value;\n}\n\nstatic void b53_serdes_set_lane(struct b53_device *dev, u8 lane)\n{\n\tif (dev->serdes_lane == lane)\n\t\treturn;\n\n\tWARN_ON(lane > 1);\n\n\tb53_serdes_write_blk(dev, B53_SERDES_LANE,\n\t\t\t     SERDES_XGXSBLK0_BLOCKADDRESS, lane);\n\tdev->serdes_lane = lane;\n}\n\nstatic void b53_serdes_write(struct b53_device *dev, u8 lane,\n\t\t\t     u8 offset, u16 block, u16 value)\n{\n\tb53_serdes_set_lane(dev, lane);\n\tb53_serdes_write_blk(dev, offset, block, value);\n}\n\nstatic u16 b53_serdes_read(struct b53_device *dev, u8 lane,\n\t\t\t   u8 offset, u16 block)\n{\n\tb53_serdes_set_lane(dev, lane);\n\treturn b53_serdes_read_blk(dev, offset, block);\n}\n\nstatic int b53_serdes_config(struct phylink_pcs *pcs, unsigned int neg_mode,\n\t\t\t     phy_interface_t interface,\n\t\t\t     const unsigned long *advertising,\n\t\t\t     bool permit_pause_to_mac)\n{\n\tstruct b53_device *dev = pcs_to_b53_pcs(pcs)->dev;\n\tu8 lane = pcs_to_b53_pcs(pcs)->lane;\n\tu16 reg;\n\n\treg = b53_serdes_read(dev, lane, B53_SERDES_DIGITAL_CONTROL(1),\n\t\t\t      SERDES_DIGITAL_BLK);\n\tif (interface == PHY_INTERFACE_MODE_1000BASEX)\n\t\treg |= FIBER_MODE_1000X;\n\telse\n\t\treg &= ~FIBER_MODE_1000X;\n\tb53_serdes_write(dev, lane, B53_SERDES_DIGITAL_CONTROL(1),\n\t\t\t SERDES_DIGITAL_BLK, reg);\n\n\treturn 0;\n}\n\nstatic void b53_serdes_an_restart(struct phylink_pcs *pcs)\n{\n\tstruct b53_device *dev = pcs_to_b53_pcs(pcs)->dev;\n\tu8 lane = pcs_to_b53_pcs(pcs)->lane;\n\tu16 reg;\n\n\treg = b53_serdes_read(dev, lane, B53_SERDES_MII_REG(MII_BMCR),\n\t\t\t      SERDES_MII_BLK);\n\treg |= BMCR_ANRESTART;\n\tb53_serdes_write(dev, lane, B53_SERDES_MII_REG(MII_BMCR),\n\t\t\t SERDES_MII_BLK, reg);\n}\n\nstatic void b53_serdes_get_state(struct phylink_pcs *pcs,\n\t\t\t\t  struct phylink_link_state *state)\n{\n\tstruct b53_device *dev = pcs_to_b53_pcs(pcs)->dev;\n\tu8 lane = pcs_to_b53_pcs(pcs)->lane;\n\tu16 dig, bmsr;\n\n\tdig = b53_serdes_read(dev, lane, B53_SERDES_DIGITAL_STATUS,\n\t\t\t      SERDES_DIGITAL_BLK);\n\tbmsr = b53_serdes_read(dev, lane, B53_SERDES_MII_REG(MII_BMSR),\n\t\t\t       SERDES_MII_BLK);\n\n\tswitch ((dig >> SPEED_STATUS_SHIFT) & SPEED_STATUS_MASK) {\n\tcase SPEED_STATUS_10:\n\t\tstate->speed = SPEED_10;\n\t\tbreak;\n\tcase SPEED_STATUS_100:\n\t\tstate->speed = SPEED_100;\n\t\tbreak;\n\tcase SPEED_STATUS_1000:\n\t\tstate->speed = SPEED_1000;\n\t\tbreak;\n\tdefault:\n\tcase SPEED_STATUS_2500:\n\t\tstate->speed = SPEED_2500;\n\t\tbreak;\n\t}\n\n\tstate->duplex = dig & DUPLEX_STATUS ? DUPLEX_FULL : DUPLEX_HALF;\n\tstate->an_complete = !!(bmsr & BMSR_ANEGCOMPLETE);\n\tstate->link = !!(dig & LINK_STATUS);\n\tif (dig & PAUSE_RESOLUTION_RX_SIDE)\n\t\tstate->pause |= MLO_PAUSE_RX;\n\tif (dig & PAUSE_RESOLUTION_TX_SIDE)\n\t\tstate->pause |= MLO_PAUSE_TX;\n}\n\nvoid b53_serdes_link_set(struct b53_device *dev, int port, unsigned int mode,\n\t\t\t phy_interface_t interface, bool link_up)\n{\n\tu8 lane = b53_serdes_map_lane(dev, port);\n\tu16 reg;\n\n\tif (lane == B53_INVALID_LANE)\n\t\treturn;\n\n\treg = b53_serdes_read(dev, lane, B53_SERDES_MII_REG(MII_BMCR),\n\t\t\t      SERDES_MII_BLK);\n\tif (link_up)\n\t\treg &= ~BMCR_PDOWN;\n\telse\n\t\treg |= BMCR_PDOWN;\n\tb53_serdes_write(dev, lane, B53_SERDES_MII_REG(MII_BMCR),\n\t\t\t SERDES_MII_BLK, reg);\n}\nEXPORT_SYMBOL(b53_serdes_link_set);\n\nstatic const struct phylink_pcs_ops b53_pcs_ops = {\n\t.pcs_get_state = b53_serdes_get_state,\n\t.pcs_config = b53_serdes_config,\n\t.pcs_an_restart = b53_serdes_an_restart,\n};\n\nvoid b53_serdes_phylink_get_caps(struct b53_device *dev, int port,\n\t\t\t\t struct phylink_config *config)\n{\n\tu8 lane = b53_serdes_map_lane(dev, port);\n\n\tif (lane == B53_INVALID_LANE)\n\t\treturn;\n\n\tswitch (lane) {\n\tcase 0:\n\t\t \n\t\t__set_bit(PHY_INTERFACE_MODE_2500BASEX,\n\t\t\t  config->supported_interfaces);\n\t\tconfig->mac_capabilities |= MAC_2500FD;\n\t\tfallthrough;\n\tcase 1:\n\t\t \n\t\t__set_bit(PHY_INTERFACE_MODE_1000BASEX,\n\t\t\t  config->supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_SGMII,\n\t\t\t  config->supported_interfaces);\n\t\tconfig->mac_capabilities |= MAC_1000FD;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(b53_serdes_phylink_get_caps);\n\nstruct phylink_pcs *b53_serdes_phylink_mac_select_pcs(struct b53_device *dev,\n\t\t\t\t\t\t      int port,\n\t\t\t\t\t\t      phy_interface_t interface)\n{\n\tu8 lane = b53_serdes_map_lane(dev, port);\n\n\tif (lane == B53_INVALID_LANE || lane >= B53_N_PCS ||\n\t    !dev->pcs[lane].dev)\n\t\treturn NULL;\n\n\tif (!phy_interface_mode_is_8023z(interface) &&\n\t    interface != PHY_INTERFACE_MODE_SGMII)\n\t\treturn NULL;\n\n\treturn &dev->pcs[lane].pcs;\n}\nEXPORT_SYMBOL(b53_serdes_phylink_mac_select_pcs);\n\nint b53_serdes_init(struct b53_device *dev, int port)\n{\n\tu8 lane = b53_serdes_map_lane(dev, port);\n\tstruct b53_pcs *pcs;\n\tu16 id0, msb, lsb;\n\n\tif (lane == B53_INVALID_LANE)\n\t\treturn -EINVAL;\n\n\tid0 = b53_serdes_read(dev, lane, B53_SERDES_ID0, SERDES_ID0);\n\tmsb = b53_serdes_read(dev, lane, B53_SERDES_MII_REG(MII_PHYSID1),\n\t\t\t      SERDES_MII_BLK);\n\tlsb = b53_serdes_read(dev, lane, B53_SERDES_MII_REG(MII_PHYSID2),\n\t\t\t      SERDES_MII_BLK);\n\tif (id0 == 0 || id0 == 0xffff) {\n\t\tdev_err(dev->dev, \"SerDes not initialized, check settings\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(dev->dev,\n\t\t \"SerDes lane %d, model: %d, rev %c%d (OUI: 0x%08x)\\n\",\n\t\t lane, id0 & SERDES_ID0_MODEL_MASK,\n\t\t (id0 >> SERDES_ID0_REV_LETTER_SHIFT) + 0x41,\n\t\t (id0 >> SERDES_ID0_REV_NUM_SHIFT) & SERDES_ID0_REV_NUM_MASK,\n\t\t (u32)msb << 16 | lsb);\n\n\tpcs = &dev->pcs[lane];\n\tpcs->dev = dev;\n\tpcs->lane = lane;\n\tpcs->pcs.ops = &b53_pcs_ops;\n\tpcs->pcs.neg_mode = true;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(b53_serdes_init);\n\nMODULE_AUTHOR(\"Florian Fainelli <f.fainelli@gmail.com>\");\nMODULE_DESCRIPTION(\"B53 Switch SerDes driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}