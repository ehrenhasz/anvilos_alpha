{
  "module_name": "b53_srab.c",
  "hash_id": "213d76a0ac43de05f136680ea2fba0a6b58ac40484df0a0f9718f849e8987671",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/b53/b53_srab.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/b53.h>\n#include <linux/of.h>\n\n#include \"b53_priv.h\"\n#include \"b53_serdes.h\"\n\n \n#define B53_SRAB_CMDSTAT\t\t0x2c\n#define  B53_SRAB_CMDSTAT_RST\t\tBIT(2)\n#define  B53_SRAB_CMDSTAT_WRITE\t\tBIT(1)\n#define  B53_SRAB_CMDSTAT_GORDYN\tBIT(0)\n#define  B53_SRAB_CMDSTAT_PAGE\t\t24\n#define  B53_SRAB_CMDSTAT_REG\t\t16\n\n \n#define B53_SRAB_WD_H\t\t\t0x30\n\n \n#define B53_SRAB_WD_L\t\t\t0x34\n\n \n#define B53_SRAB_RD_H\t\t\t0x38\n\n \n#define B53_SRAB_RD_L\t\t\t0x3c\n\n \n#define B53_SRAB_CTRLS\t\t\t0x40\n#define  B53_SRAB_CTRLS_HOST_INTR\tBIT(1)\n#define  B53_SRAB_CTRLS_RCAREQ\t\tBIT(3)\n#define  B53_SRAB_CTRLS_RCAGNT\t\tBIT(4)\n#define  B53_SRAB_CTRLS_SW_INIT_DONE\tBIT(6)\n\n \n#define B53_SRAB_INTR\t\t\t0x44\n#define  B53_SRAB_INTR_P(x)\t\tBIT(x)\n#define  B53_SRAB_SWITCH_PHY\t\tBIT(8)\n#define  B53_SRAB_1588_SYNC\t\tBIT(9)\n#define  B53_SRAB_IMP1_SLEEP_TIMER\tBIT(10)\n#define  B53_SRAB_P7_SLEEP_TIMER\tBIT(11)\n#define  B53_SRAB_IMP0_SLEEP_TIMER\tBIT(12)\n\n \n#define B53_MUX_CONFIG_P5\t\t0x00\n#define  MUX_CONFIG_SGMII\t\t0\n#define  MUX_CONFIG_MII_LITE\t\t1\n#define  MUX_CONFIG_RGMII\t\t2\n#define  MUX_CONFIG_GMII\t\t3\n#define  MUX_CONFIG_GPHY\t\t4\n#define  MUX_CONFIG_INTERNAL\t\t5\n#define  MUX_CONFIG_MASK\t\t0x7\n#define B53_MUX_CONFIG_P4\t\t0x04\n\nstruct b53_srab_port_priv {\n\tint irq;\n\tbool irq_enabled;\n\tstruct b53_device *dev;\n\tunsigned int num;\n\tphy_interface_t mode;\n};\n\nstruct b53_srab_priv {\n\tvoid __iomem *regs;\n\tvoid __iomem *mux_config;\n\tstruct b53_srab_port_priv port_intrs[B53_N_PORTS];\n};\n\nstatic int b53_srab_request_grant(struct b53_device *dev)\n{\n\tstruct b53_srab_priv *priv = dev->priv;\n\tu8 __iomem *regs = priv->regs;\n\tu32 ctrls;\n\tint i;\n\n\tctrls = readl(regs + B53_SRAB_CTRLS);\n\tctrls |= B53_SRAB_CTRLS_RCAREQ;\n\twritel(ctrls, regs + B53_SRAB_CTRLS);\n\n\tfor (i = 0; i < 20; i++) {\n\t\tctrls = readl(regs + B53_SRAB_CTRLS);\n\t\tif (ctrls & B53_SRAB_CTRLS_RCAGNT)\n\t\t\tbreak;\n\t\tusleep_range(10, 100);\n\t}\n\tif (WARN_ON(i == 5))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic void b53_srab_release_grant(struct b53_device *dev)\n{\n\tstruct b53_srab_priv *priv = dev->priv;\n\tu8 __iomem *regs = priv->regs;\n\tu32 ctrls;\n\n\tctrls = readl(regs + B53_SRAB_CTRLS);\n\tctrls &= ~B53_SRAB_CTRLS_RCAREQ;\n\twritel(ctrls, regs + B53_SRAB_CTRLS);\n}\n\nstatic int b53_srab_op(struct b53_device *dev, u8 page, u8 reg, u32 op)\n{\n\tstruct b53_srab_priv *priv = dev->priv;\n\tu8 __iomem *regs = priv->regs;\n\tint i;\n\tu32 cmdstat;\n\n\t \n\tcmdstat = (page << B53_SRAB_CMDSTAT_PAGE) |\n\t\t  (reg << B53_SRAB_CMDSTAT_REG) |\n\t\t  B53_SRAB_CMDSTAT_GORDYN |\n\t\t  op;\n\twritel(cmdstat, regs + B53_SRAB_CMDSTAT);\n\n\t \n\tfor (i = 0; i < 5; ++i) {\n\t\tcmdstat = readl(regs + B53_SRAB_CMDSTAT);\n\t\tif (!(cmdstat & B53_SRAB_CMDSTAT_GORDYN))\n\t\t\tbreak;\n\t\tusleep_range(10, 100);\n\t}\n\n\tif (WARN_ON(i == 5))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int b53_srab_read8(struct b53_device *dev, u8 page, u8 reg, u8 *val)\n{\n\tstruct b53_srab_priv *priv = dev->priv;\n\tu8 __iomem *regs = priv->regs;\n\tint ret = 0;\n\n\tret = b53_srab_request_grant(dev);\n\tif (ret)\n\t\tgoto err;\n\n\tret = b53_srab_op(dev, page, reg, 0);\n\tif (ret)\n\t\tgoto err;\n\n\t*val = readl(regs + B53_SRAB_RD_L) & 0xff;\n\nerr:\n\tb53_srab_release_grant(dev);\n\n\treturn ret;\n}\n\nstatic int b53_srab_read16(struct b53_device *dev, u8 page, u8 reg, u16 *val)\n{\n\tstruct b53_srab_priv *priv = dev->priv;\n\tu8 __iomem *regs = priv->regs;\n\tint ret = 0;\n\n\tret = b53_srab_request_grant(dev);\n\tif (ret)\n\t\tgoto err;\n\n\tret = b53_srab_op(dev, page, reg, 0);\n\tif (ret)\n\t\tgoto err;\n\n\t*val = readl(regs + B53_SRAB_RD_L) & 0xffff;\n\nerr:\n\tb53_srab_release_grant(dev);\n\n\treturn ret;\n}\n\nstatic int b53_srab_read32(struct b53_device *dev, u8 page, u8 reg, u32 *val)\n{\n\tstruct b53_srab_priv *priv = dev->priv;\n\tu8 __iomem *regs = priv->regs;\n\tint ret = 0;\n\n\tret = b53_srab_request_grant(dev);\n\tif (ret)\n\t\tgoto err;\n\n\tret = b53_srab_op(dev, page, reg, 0);\n\tif (ret)\n\t\tgoto err;\n\n\t*val = readl(regs + B53_SRAB_RD_L);\n\nerr:\n\tb53_srab_release_grant(dev);\n\n\treturn ret;\n}\n\nstatic int b53_srab_read48(struct b53_device *dev, u8 page, u8 reg, u64 *val)\n{\n\tstruct b53_srab_priv *priv = dev->priv;\n\tu8 __iomem *regs = priv->regs;\n\tint ret = 0;\n\n\tret = b53_srab_request_grant(dev);\n\tif (ret)\n\t\tgoto err;\n\n\tret = b53_srab_op(dev, page, reg, 0);\n\tif (ret)\n\t\tgoto err;\n\n\t*val = readl(regs + B53_SRAB_RD_L);\n\t*val += ((u64)readl(regs + B53_SRAB_RD_H) & 0xffff) << 32;\n\nerr:\n\tb53_srab_release_grant(dev);\n\n\treturn ret;\n}\n\nstatic int b53_srab_read64(struct b53_device *dev, u8 page, u8 reg, u64 *val)\n{\n\tstruct b53_srab_priv *priv = dev->priv;\n\tu8 __iomem *regs = priv->regs;\n\tint ret = 0;\n\n\tret = b53_srab_request_grant(dev);\n\tif (ret)\n\t\tgoto err;\n\n\tret = b53_srab_op(dev, page, reg, 0);\n\tif (ret)\n\t\tgoto err;\n\n\t*val = readl(regs + B53_SRAB_RD_L);\n\t*val += (u64)readl(regs + B53_SRAB_RD_H) << 32;\n\nerr:\n\tb53_srab_release_grant(dev);\n\n\treturn ret;\n}\n\nstatic int b53_srab_write8(struct b53_device *dev, u8 page, u8 reg, u8 value)\n{\n\tstruct b53_srab_priv *priv = dev->priv;\n\tu8 __iomem *regs = priv->regs;\n\tint ret = 0;\n\n\tret = b53_srab_request_grant(dev);\n\tif (ret)\n\t\tgoto err;\n\n\twritel(value, regs + B53_SRAB_WD_L);\n\n\tret = b53_srab_op(dev, page, reg, B53_SRAB_CMDSTAT_WRITE);\n\nerr:\n\tb53_srab_release_grant(dev);\n\n\treturn ret;\n}\n\nstatic int b53_srab_write16(struct b53_device *dev, u8 page, u8 reg,\n\t\t\t    u16 value)\n{\n\tstruct b53_srab_priv *priv = dev->priv;\n\tu8 __iomem *regs = priv->regs;\n\tint ret = 0;\n\n\tret = b53_srab_request_grant(dev);\n\tif (ret)\n\t\tgoto err;\n\n\twritel(value, regs + B53_SRAB_WD_L);\n\n\tret = b53_srab_op(dev, page, reg, B53_SRAB_CMDSTAT_WRITE);\n\nerr:\n\tb53_srab_release_grant(dev);\n\n\treturn ret;\n}\n\nstatic int b53_srab_write32(struct b53_device *dev, u8 page, u8 reg,\n\t\t\t    u32 value)\n{\n\tstruct b53_srab_priv *priv = dev->priv;\n\tu8 __iomem *regs = priv->regs;\n\tint ret = 0;\n\n\tret = b53_srab_request_grant(dev);\n\tif (ret)\n\t\tgoto err;\n\n\twritel(value, regs + B53_SRAB_WD_L);\n\n\tret = b53_srab_op(dev, page, reg, B53_SRAB_CMDSTAT_WRITE);\n\nerr:\n\tb53_srab_release_grant(dev);\n\n\treturn ret;\n}\n\nstatic int b53_srab_write48(struct b53_device *dev, u8 page, u8 reg,\n\t\t\t    u64 value)\n{\n\tstruct b53_srab_priv *priv = dev->priv;\n\tu8 __iomem *regs = priv->regs;\n\tint ret = 0;\n\n\tret = b53_srab_request_grant(dev);\n\tif (ret)\n\t\tgoto err;\n\n\twritel((u32)value, regs + B53_SRAB_WD_L);\n\twritel((u16)(value >> 32), regs + B53_SRAB_WD_H);\n\n\tret = b53_srab_op(dev, page, reg, B53_SRAB_CMDSTAT_WRITE);\n\nerr:\n\tb53_srab_release_grant(dev);\n\n\treturn ret;\n}\n\nstatic int b53_srab_write64(struct b53_device *dev, u8 page, u8 reg,\n\t\t\t    u64 value)\n{\n\tstruct b53_srab_priv *priv = dev->priv;\n\tu8 __iomem *regs = priv->regs;\n\tint ret = 0;\n\n\tret = b53_srab_request_grant(dev);\n\tif (ret)\n\t\tgoto err;\n\n\twritel((u32)value, regs + B53_SRAB_WD_L);\n\twritel((u32)(value >> 32), regs + B53_SRAB_WD_H);\n\n\tret = b53_srab_op(dev, page, reg, B53_SRAB_CMDSTAT_WRITE);\n\nerr:\n\tb53_srab_release_grant(dev);\n\n\treturn ret;\n}\n\nstatic irqreturn_t b53_srab_port_thread(int irq, void *dev_id)\n{\n\tstruct b53_srab_port_priv *port = dev_id;\n\tstruct b53_device *dev = port->dev;\n\n\tif (port->mode == PHY_INTERFACE_MODE_SGMII)\n\t\tb53_port_event(dev->ds, port->num);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t b53_srab_port_isr(int irq, void *dev_id)\n{\n\tstruct b53_srab_port_priv *port = dev_id;\n\tstruct b53_device *dev = port->dev;\n\tstruct b53_srab_priv *priv = dev->priv;\n\n\t \n\twritel(BIT(port->num), priv->regs + B53_SRAB_INTR);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\n#if IS_ENABLED(CONFIG_B53_SERDES)\nstatic u8 b53_srab_serdes_map_lane(struct b53_device *dev, int port)\n{\n\tstruct b53_srab_priv *priv = dev->priv;\n\tstruct b53_srab_port_priv *p = &priv->port_intrs[port];\n\n\tif (p->mode != PHY_INTERFACE_MODE_SGMII)\n\t\treturn B53_INVALID_LANE;\n\n\tswitch (port) {\n\tcase 5:\n\t\treturn 0;\n\tcase 4:\n\t\treturn 1;\n\tdefault:\n\t\treturn B53_INVALID_LANE;\n\t}\n}\n#endif\n\nstatic int b53_srab_irq_enable(struct b53_device *dev, int port)\n{\n\tstruct b53_srab_priv *priv = dev->priv;\n\tstruct b53_srab_port_priv *p = &priv->port_intrs[port];\n\tint ret = 0;\n\n\t \n\tif (p->irq == -ENXIO)\n\t\treturn ret;\n\n\tret = request_threaded_irq(p->irq, b53_srab_port_isr,\n\t\t\t\t   b53_srab_port_thread, 0,\n\t\t\t\t   dev_name(dev->dev), p);\n\tif (!ret)\n\t\tp->irq_enabled = true;\n\n\treturn ret;\n}\n\nstatic void b53_srab_irq_disable(struct b53_device *dev, int port)\n{\n\tstruct b53_srab_priv *priv = dev->priv;\n\tstruct b53_srab_port_priv *p = &priv->port_intrs[port];\n\n\tif (p->irq_enabled) {\n\t\tfree_irq(p->irq, p);\n\t\tp->irq_enabled = false;\n\t}\n}\n\nstatic void b53_srab_phylink_get_caps(struct b53_device *dev, int port,\n\t\t\t\t      struct phylink_config *config)\n{\n\tstruct b53_srab_priv *priv = dev->priv;\n\tstruct b53_srab_port_priv *p = &priv->port_intrs[port];\n\n\tswitch (p->mode) {\n\tcase PHY_INTERFACE_MODE_SGMII:\n#if IS_ENABLED(CONFIG_B53_SERDES)\n\t\t \n\t\tb53_serdes_phylink_get_caps(dev, port, config);\n#endif\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_NA:\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_RGMII:\n\t\t \n\t\tphy_interface_set_rgmii(config->supported_interfaces);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\t__set_bit(p->mode, config->supported_interfaces);\n\t\tbreak;\n\t}\n}\n\nstatic const struct b53_io_ops b53_srab_ops = {\n\t.read8 = b53_srab_read8,\n\t.read16 = b53_srab_read16,\n\t.read32 = b53_srab_read32,\n\t.read48 = b53_srab_read48,\n\t.read64 = b53_srab_read64,\n\t.write8 = b53_srab_write8,\n\t.write16 = b53_srab_write16,\n\t.write32 = b53_srab_write32,\n\t.write48 = b53_srab_write48,\n\t.write64 = b53_srab_write64,\n\t.irq_enable = b53_srab_irq_enable,\n\t.irq_disable = b53_srab_irq_disable,\n\t.phylink_get_caps = b53_srab_phylink_get_caps,\n#if IS_ENABLED(CONFIG_B53_SERDES)\n\t.phylink_mac_select_pcs = b53_serdes_phylink_mac_select_pcs,\n\t.serdes_map_lane = b53_srab_serdes_map_lane,\n\t.serdes_link_set = b53_serdes_link_set,\n#endif\n};\n\nstatic const struct of_device_id b53_srab_of_match[] = {\n\t{ .compatible = \"brcm,bcm53010-srab\" },\n\t{ .compatible = \"brcm,bcm53011-srab\" },\n\t{ .compatible = \"brcm,bcm53012-srab\" },\n\t{ .compatible = \"brcm,bcm53018-srab\" },\n\t{ .compatible = \"brcm,bcm53019-srab\" },\n\t{ .compatible = \"brcm,bcm5301x-srab\" },\n\t{ .compatible = \"brcm,bcm11360-srab\", .data = (void *)BCM583XX_DEVICE_ID },\n\t{ .compatible = \"brcm,bcm58522-srab\", .data = (void *)BCM58XX_DEVICE_ID },\n\t{ .compatible = \"brcm,bcm58525-srab\", .data = (void *)BCM58XX_DEVICE_ID },\n\t{ .compatible = \"brcm,bcm58535-srab\", .data = (void *)BCM58XX_DEVICE_ID },\n\t{ .compatible = \"brcm,bcm58622-srab\", .data = (void *)BCM58XX_DEVICE_ID },\n\t{ .compatible = \"brcm,bcm58623-srab\", .data = (void *)BCM58XX_DEVICE_ID },\n\t{ .compatible = \"brcm,bcm58625-srab\", .data = (void *)BCM58XX_DEVICE_ID },\n\t{ .compatible = \"brcm,bcm88312-srab\", .data = (void *)BCM58XX_DEVICE_ID },\n\t{ .compatible = \"brcm,cygnus-srab\", .data = (void *)BCM583XX_DEVICE_ID },\n\t{ .compatible = \"brcm,nsp-srab\", .data = (void *)BCM58XX_DEVICE_ID },\n\t{ .compatible = \"brcm,omega-srab\", .data = (void *)BCM583XX_DEVICE_ID },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, b53_srab_of_match);\n\nstatic void b53_srab_intr_set(struct b53_srab_priv *priv, bool set)\n{\n\tu32 reg;\n\n\treg = readl(priv->regs + B53_SRAB_CTRLS);\n\tif (set)\n\t\treg |= B53_SRAB_CTRLS_HOST_INTR;\n\telse\n\t\treg &= ~B53_SRAB_CTRLS_HOST_INTR;\n\twritel(reg, priv->regs + B53_SRAB_CTRLS);\n}\n\nstatic void b53_srab_prepare_irq(struct platform_device *pdev)\n{\n\tstruct b53_device *dev = platform_get_drvdata(pdev);\n\tstruct b53_srab_priv *priv = dev->priv;\n\tstruct b53_srab_port_priv *port;\n\tunsigned int i;\n\tchar *name;\n\n\t \n\twritel(0xffffffff, priv->regs + B53_SRAB_INTR);\n\n\tfor (i = 0; i < B53_N_PORTS; i++) {\n\t\tport = &priv->port_intrs[i];\n\n\t\t \n\t\tif (i == 6)\n\t\t\tcontinue;\n\n\t\tname = kasprintf(GFP_KERNEL, \"link_state_p%d\", i);\n\t\tif (!name)\n\t\t\treturn;\n\n\t\tport->num = i;\n\t\tport->dev = dev;\n\t\tport->irq = platform_get_irq_byname_optional(pdev, name);\n\t\tkfree(name);\n\t}\n\n\tb53_srab_intr_set(priv, true);\n}\n\nstatic void b53_srab_mux_init(struct platform_device *pdev)\n{\n\tstruct b53_device *dev = platform_get_drvdata(pdev);\n\tstruct b53_srab_priv *priv = dev->priv;\n\tstruct b53_srab_port_priv *p;\n\tunsigned int port;\n\tu32 reg, off = 0;\n\tint ret;\n\n\tif (dev->pdata && dev->pdata->chip_id != BCM58XX_DEVICE_ID)\n\t\treturn;\n\n\tpriv->mux_config = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(priv->mux_config))\n\t\treturn;\n\n\t \n\tfor (port = 5; port > 3; port--, off += 4) {\n\t\tp = &priv->port_intrs[port];\n\n\t\treg = readl(priv->mux_config + B53_MUX_CONFIG_P5 + off);\n\t\tswitch (reg & MUX_CONFIG_MASK) {\n\t\tcase MUX_CONFIG_SGMII:\n\t\t\tp->mode = PHY_INTERFACE_MODE_SGMII;\n\t\t\tret = b53_serdes_init(dev, port);\n\t\t\tif (ret)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase MUX_CONFIG_MII_LITE:\n\t\t\tp->mode = PHY_INTERFACE_MODE_MII;\n\t\t\tbreak;\n\t\tcase MUX_CONFIG_GMII:\n\t\t\tp->mode = PHY_INTERFACE_MODE_GMII;\n\t\t\tbreak;\n\t\tcase MUX_CONFIG_RGMII:\n\t\t\tp->mode = PHY_INTERFACE_MODE_RGMII;\n\t\t\tbreak;\n\t\tcase MUX_CONFIG_INTERNAL:\n\t\t\tp->mode = PHY_INTERFACE_MODE_INTERNAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp->mode = PHY_INTERFACE_MODE_NA;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (p->mode != PHY_INTERFACE_MODE_NA)\n\t\t\tdev_info(&pdev->dev, \"Port %d mode: %s\\n\",\n\t\t\t\t port, phy_modes(p->mode));\n\t}\n}\n\nstatic int b53_srab_probe(struct platform_device *pdev)\n{\n\tstruct b53_platform_data *pdata = pdev->dev.platform_data;\n\tstruct device_node *dn = pdev->dev.of_node;\n\tconst struct of_device_id *of_id = NULL;\n\tstruct b53_srab_priv *priv;\n\tstruct b53_device *dev;\n\n\tif (dn)\n\t\tof_id = of_match_node(b53_srab_of_match, dn);\n\n\tif (of_id) {\n\t\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\t\tif (!pdata)\n\t\t\treturn -ENOMEM;\n\n\t\tpdata->chip_id = (u32)(unsigned long)of_id->data;\n\t}\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->regs))\n\t\treturn PTR_ERR(priv->regs);\n\n\tdev = b53_switch_alloc(&pdev->dev, &b53_srab_ops, priv);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tif (pdata)\n\t\tdev->pdata = pdata;\n\n\tplatform_set_drvdata(pdev, dev);\n\n\tb53_srab_prepare_irq(pdev);\n\tb53_srab_mux_init(pdev);\n\n\treturn b53_switch_register(dev);\n}\n\nstatic int b53_srab_remove(struct platform_device *pdev)\n{\n\tstruct b53_device *dev = platform_get_drvdata(pdev);\n\n\tif (!dev)\n\t\treturn 0;\n\n\tb53_srab_intr_set(dev->priv, false);\n\tb53_switch_remove(dev);\n\n\treturn 0;\n}\n\nstatic void b53_srab_shutdown(struct platform_device *pdev)\n{\n\tstruct b53_device *dev = platform_get_drvdata(pdev);\n\n\tif (!dev)\n\t\treturn;\n\n\tb53_switch_shutdown(dev);\n\n\tplatform_set_drvdata(pdev, NULL);\n}\n\nstatic struct platform_driver b53_srab_driver = {\n\t.probe = b53_srab_probe,\n\t.remove = b53_srab_remove,\n\t.shutdown = b53_srab_shutdown,\n\t.driver = {\n\t\t.name = \"b53-srab-switch\",\n\t\t.of_match_table = b53_srab_of_match,\n\t},\n};\n\nmodule_platform_driver(b53_srab_driver);\nMODULE_AUTHOR(\"Hauke Mehrtens <hauke@hauke-m.de>\");\nMODULE_DESCRIPTION(\"B53 Switch Register Access Bridge Registers (SRAB) access driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}