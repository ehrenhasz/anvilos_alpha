{
  "module_name": "bcm_sf2.h",
  "hash_id": "a6f050150d9442a19b6c8bd418876b46865cfe4f5fd4ff883b369989d115ffba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/bcm_sf2.h",
  "human_readable_source": " \n \n\n#ifndef __BCM_SF2_H\n#define __BCM_SF2_H\n\n#include <linux/platform_device.h>\n#include <linux/kernel.h>\n#include <linux/io.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/types.h>\n#include <linux/bitops.h>\n#include <linux/if_vlan.h>\n#include <linux/reset.h>\n\n#include <net/dsa.h>\n\n#include \"bcm_sf2_regs.h\"\n#include \"b53/b53_priv.h\"\n\nstruct bcm_sf2_hw_params {\n\tu16\ttop_rev;\n\tu16\tcore_rev;\n\tu16\tgphy_rev;\n\tu32\tnum_gphy;\n\tu8\tnum_acb_queue;\n\tu8\tnum_rgmii;\n\tu8\tnum_ports;\n\tu8\tfcb_pause_override:1;\n\tu8\tacb_packets_inflight:1;\n};\n\n#define BCM_SF2_REGS_NAME {\\\n\t\"core\", \"reg\", \"intrl2_0\", \"intrl2_1\", \"fcb\", \"acb\" \\\n}\n\n#define BCM_SF2_REGS_NUM\t6\n\nstruct bcm_sf2_port_status {\n\tphy_interface_t mode;\n\tunsigned int link;\n\tbool enabled;\n};\n\nstruct bcm_sf2_cfp_priv {\n\t \n\tstruct mutex lock;\n\tDECLARE_BITMAP(used, CFP_NUM_RULES);\n\tDECLARE_BITMAP(unique, CFP_NUM_RULES);\n\tunsigned int rules_cnt;\n\tstruct list_head rules_list;\n};\n\nstruct bcm_sf2_priv {\n\t \n\tvoid __iomem\t\t\t*core;\n\tvoid __iomem\t\t\t*reg;\n\tvoid __iomem\t\t\t*intrl2_0;\n\tvoid __iomem\t\t\t*intrl2_1;\n\tvoid __iomem\t\t\t*fcb;\n\tvoid __iomem\t\t\t*acb;\n\n\tstruct reset_control\t\t*rcdev;\n\n\t \n\tu32 \t\t\t\ttype;\n\tconst u16\t\t\t*reg_offsets;\n\tunsigned int\t\t\tcore_reg_align;\n\tunsigned int\t\t\tnum_cfp_rules;\n\tunsigned int\t\t\tnum_crossbar_int_ports;\n\n\t \n\tspinlock_t\t\t\tindir_lock;\n\n\tint\t\t\t\tirq0;\n\tint\t\t\t\tirq1;\n\tu32\t\t\t\tirq0_stat;\n\tu32\t\t\t\tirq0_mask;\n\tu32\t\t\t\tirq1_stat;\n\tu32\t\t\t\tirq1_mask;\n\n\t \n\tstruct b53_device\t\t*dev;\n\n\tstruct bcm_sf2_hw_params\thw_params;\n\n\tstruct bcm_sf2_port_status\tport_sts[DSA_MAX_PORTS];\n\n\t \n\tu32\t\t\t\twol_ports_mask;\n\n\tstruct clk\t\t\t*clk;\n\tstruct clk\t\t\t*clk_mdiv;\n\n\t \n\tint\t\t\t\tmoca_port;\n\n\t \n\tunsigned int\t\t\tint_phy_mask;\n\n\t \n\tunsigned int\t\t\tindir_phy_mask;\n\tstruct device_node\t\t*master_mii_dn;\n\tstruct mii_bus\t\t\t*slave_mii_bus;\n\tstruct mii_bus\t\t\t*master_mii_bus;\n\n\t \n\tunsigned int\t\t\tbrcm_tag_mask;\n\n\t \n\tstruct bcm_sf2_cfp_priv\t\tcfp;\n};\n\nstatic inline struct bcm_sf2_priv *bcm_sf2_to_priv(struct dsa_switch *ds)\n{\n\tstruct b53_device *dev = ds->priv;\n\n\treturn dev->priv;\n}\n\nstatic inline u32 bcm_sf2_mangle_addr(struct bcm_sf2_priv *priv, u32 off)\n{\n\treturn off << priv->core_reg_align;\n}\n\n#define SF2_IO_MACRO(name) \\\nstatic inline u32 name##_readl(struct bcm_sf2_priv *priv, u32 off)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn readl_relaxed(priv->name + off);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline void name##_writel(struct bcm_sf2_priv *priv,\t\t\\\n\t\t\t\t  u32 val, u32 off)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\twritel_relaxed(val, priv->name + off);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\n \n#define SF2_IO64_MACRO(name) \\\nstatic inline u64 name##_readq(struct bcm_sf2_priv *priv, u32 off)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tu32 indir, dir;\t\t\t\t\t\t\t\\\n\tspin_lock(&priv->indir_lock);\t\t\t\t\t\\\n\tdir = name##_readl(priv, off);\t\t\t\t\t\\\n\tindir = reg_readl(priv, REG_DIR_DATA_READ);\t\t\t\\\n\tspin_unlock(&priv->indir_lock);\t\t\t\t\t\\\n\treturn (u64)indir << 32 | dir;\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline void name##_writeq(struct bcm_sf2_priv *priv, u64 val,\t\\\n\t\t\t\t\t\t\tu32 off)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tspin_lock(&priv->indir_lock);\t\t\t\t\t\\\n\treg_writel(priv, upper_32_bits(val), REG_DIR_DATA_WRITE);\t\\\n\tname##_writel(priv, lower_32_bits(val), off);\t\t\t\\\n\tspin_unlock(&priv->indir_lock);\t\t\t\t\t\\\n}\n\n#define SWITCH_INTR_L2(which)\t\t\t\t\t\t\\\nstatic inline void intrl2_##which##_mask_clear(struct bcm_sf2_priv *priv, \\\n\t\t\t\t\t\tu32 mask)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tpriv->irq##which##_mask &= ~(mask);\t\t\t\t\\\n\tintrl2_##which##_writel(priv, mask, INTRL2_CPU_MASK_CLEAR);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline void intrl2_##which##_mask_set(struct bcm_sf2_priv *priv, \\\n\t\t\t\t\t\tu32 mask)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tintrl2_## which##_writel(priv, mask, INTRL2_CPU_MASK_SET);\t\\\n\tpriv->irq##which##_mask |= (mask);\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\nstatic inline u32 core_readl(struct bcm_sf2_priv *priv, u32 off)\n{\n\tu32 tmp = bcm_sf2_mangle_addr(priv, off);\n\treturn readl_relaxed(priv->core + tmp);\n}\n\nstatic inline void core_writel(struct bcm_sf2_priv *priv, u32 val, u32 off)\n{\n\tu32 tmp = bcm_sf2_mangle_addr(priv, off);\n\twritel_relaxed(val, priv->core + tmp);\n}\n\nstatic inline u32 reg_readl(struct bcm_sf2_priv *priv, u16 off)\n{\n\treturn readl_relaxed(priv->reg + priv->reg_offsets[off]);\n}\n\nstatic inline void reg_writel(struct bcm_sf2_priv *priv, u32 val, u16 off)\n{\n\twritel_relaxed(val, priv->reg + priv->reg_offsets[off]);\n}\n\nSF2_IO64_MACRO(core);\nSF2_IO_MACRO(intrl2_0);\nSF2_IO_MACRO(intrl2_1);\nSF2_IO_MACRO(fcb);\nSF2_IO_MACRO(acb);\n\nSWITCH_INTR_L2(0);\nSWITCH_INTR_L2(1);\n\nstatic inline u32 reg_led_readl(struct bcm_sf2_priv *priv, u16 off, u16 reg)\n{\n\treturn readl_relaxed(priv->reg + priv->reg_offsets[off] + reg);\n}\n\nstatic inline void reg_led_writel(struct bcm_sf2_priv *priv, u32 val, u16 off, u16 reg)\n{\n\twritel_relaxed(val, priv->reg + priv->reg_offsets[off] + reg);\n}\n\n \nint bcm_sf2_get_rxnfc(struct dsa_switch *ds, int port,\n\t\t      struct ethtool_rxnfc *nfc, u32 *rule_locs);\nint bcm_sf2_set_rxnfc(struct dsa_switch *ds, int port,\n\t\t      struct ethtool_rxnfc *nfc);\nint bcm_sf2_cfp_rst(struct bcm_sf2_priv *priv);\nvoid bcm_sf2_cfp_exit(struct dsa_switch *ds);\nint bcm_sf2_cfp_resume(struct dsa_switch *ds);\nvoid bcm_sf2_cfp_get_strings(struct dsa_switch *ds, int port,\n\t\t\t     u32 stringset, uint8_t *data);\nvoid bcm_sf2_cfp_get_ethtool_stats(struct dsa_switch *ds, int port,\n\t\t\t\t   uint64_t *data);\nint bcm_sf2_cfp_get_sset_count(struct dsa_switch *ds, int port, int sset);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}