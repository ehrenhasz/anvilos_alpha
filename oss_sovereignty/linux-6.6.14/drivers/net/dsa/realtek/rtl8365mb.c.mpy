{
  "module_name": "rtl8365mb.c",
  "hash_id": "f4ad498efd7b44147b4cd04a6ba56bfb05e6eb7825758cbfae6f7fa939be066f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/realtek/rtl8365mb.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/irqdomain.h>\n#include <linux/mutex.h>\n#include <linux/of_irq.h>\n#include <linux/regmap.h>\n#include <linux/if_bridge.h>\n#include <linux/if_vlan.h>\n\n#include \"realtek.h\"\n\n \n#define RTL8365MB_PHYADDRMAX\t\t7\n#define RTL8365MB_NUM_PHYREGS\t\t32\n#define RTL8365MB_PHYREGMAX\t\t(RTL8365MB_NUM_PHYREGS - 1)\n#define RTL8365MB_MAX_NUM_PORTS\t\t11\n#define RTL8365MB_MAX_NUM_EXTINTS\t3\n#define RTL8365MB_LEARN_LIMIT_MAX\t2112\n\n \n#define RTL8365MB_CHIP_ID_REG\t\t0x1300\n\n#define RTL8365MB_CHIP_VER_REG\t\t0x1301\n\n#define RTL8365MB_MAGIC_REG\t\t0x13C2\n#define   RTL8365MB_MAGIC_VALUE\t\t0x0249\n\n \n#define RTL8365MB_CHIP_RESET_REG\t0x1322\n#define RTL8365MB_CHIP_RESET_SW_MASK\t0x0002\n#define RTL8365MB_CHIP_RESET_HW_MASK\t0x0001\n\n \n#define RTL8365MB_INTR_POLARITY_REG\t0x1100\n#define   RTL8365MB_INTR_POLARITY_MASK\t0x0001\n#define   RTL8365MB_INTR_POLARITY_HIGH\t0\n#define   RTL8365MB_INTR_POLARITY_LOW\t1\n\n \n#define RTL8365MB_INTR_CTRL_REG\t\t\t0x1101\n#define RTL8365MB_INTR_STATUS_REG\t\t0x1102\n#define   RTL8365MB_INTR_SLIENT_START_2_MASK\t0x1000\n#define   RTL8365MB_INTR_SLIENT_START_MASK\t0x0800\n#define   RTL8365MB_INTR_ACL_ACTION_MASK\t0x0200\n#define   RTL8365MB_INTR_CABLE_DIAG_FIN_MASK\t0x0100\n#define   RTL8365MB_INTR_INTERRUPT_8051_MASK\t0x0080\n#define   RTL8365MB_INTR_LOOP_DETECTION_MASK\t0x0040\n#define   RTL8365MB_INTR_GREEN_TIMER_MASK\t0x0020\n#define   RTL8365MB_INTR_SPECIAL_CONGEST_MASK\t0x0010\n#define   RTL8365MB_INTR_SPEED_CHANGE_MASK\t0x0008\n#define   RTL8365MB_INTR_LEARN_OVER_MASK\t0x0004\n#define   RTL8365MB_INTR_METER_EXCEEDED_MASK\t0x0002\n#define   RTL8365MB_INTR_LINK_CHANGE_MASK\t0x0001\n#define   RTL8365MB_INTR_ALL_MASK                      \\\n\t\t(RTL8365MB_INTR_SLIENT_START_2_MASK |  \\\n\t\t RTL8365MB_INTR_SLIENT_START_MASK |    \\\n\t\t RTL8365MB_INTR_ACL_ACTION_MASK |      \\\n\t\t RTL8365MB_INTR_CABLE_DIAG_FIN_MASK |  \\\n\t\t RTL8365MB_INTR_INTERRUPT_8051_MASK |  \\\n\t\t RTL8365MB_INTR_LOOP_DETECTION_MASK |  \\\n\t\t RTL8365MB_INTR_GREEN_TIMER_MASK |     \\\n\t\t RTL8365MB_INTR_SPECIAL_CONGEST_MASK | \\\n\t\t RTL8365MB_INTR_SPEED_CHANGE_MASK |    \\\n\t\t RTL8365MB_INTR_LEARN_OVER_MASK |      \\\n\t\t RTL8365MB_INTR_METER_EXCEEDED_MASK |  \\\n\t\t RTL8365MB_INTR_LINK_CHANGE_MASK)\n\n \n#define RTL8365MB_PORT_LINKDOWN_IND_REG\t\t0x1106\n#define   RTL8365MB_PORT_LINKDOWN_IND_MASK\t0x07FF\n\n#define RTL8365MB_PORT_LINKUP_IND_REG\t\t0x1107\n#define   RTL8365MB_PORT_LINKUP_IND_MASK\t0x07FF\n\n \n#define RTL8365MB_INDIRECT_ACCESS_CTRL_REG\t\t\t0x1F00\n#define   RTL8365MB_INDIRECT_ACCESS_CTRL_RW_MASK\t\t0x0002\n#define   RTL8365MB_INDIRECT_ACCESS_CTRL_RW_READ\t\t0\n#define   RTL8365MB_INDIRECT_ACCESS_CTRL_RW_WRITE\t\t1\n#define   RTL8365MB_INDIRECT_ACCESS_CTRL_CMD_MASK\t\t0x0001\n#define   RTL8365MB_INDIRECT_ACCESS_CTRL_CMD_VALUE\t\t1\n#define RTL8365MB_INDIRECT_ACCESS_STATUS_REG\t\t\t0x1F01\n#define RTL8365MB_INDIRECT_ACCESS_ADDRESS_REG\t\t\t0x1F02\n#define   RTL8365MB_INDIRECT_ACCESS_ADDRESS_OCPADR_5_1_MASK\tGENMASK(4, 0)\n#define   RTL8365MB_INDIRECT_ACCESS_ADDRESS_PHYNUM_MASK\t\tGENMASK(7, 5)\n#define   RTL8365MB_INDIRECT_ACCESS_ADDRESS_OCPADR_9_6_MASK\tGENMASK(11, 8)\n#define   RTL8365MB_PHY_BASE\t\t\t\t\t0x2000\n#define RTL8365MB_INDIRECT_ACCESS_WRITE_DATA_REG\t\t0x1F03\n#define RTL8365MB_INDIRECT_ACCESS_READ_DATA_REG\t\t\t0x1F04\n\n \n#define RTL8365MB_GPHY_OCP_MSB_0_REG\t\t\t0x1D15\n#define   RTL8365MB_GPHY_OCP_MSB_0_CFG_CPU_OCPADR_MASK\t0x0FC0\n#define RTL8365MB_PHY_OCP_ADDR_PREFIX_MASK\t\t0xFC00\n\n \n#define RTL8365MB_PHY_OCP_ADDR_PHYREG_BASE\t\t0xA400\n\n \n#define RTL8365MB_EXT_PORT_MODE_DISABLE\t\t0\n#define RTL8365MB_EXT_PORT_MODE_RGMII\t\t1\n#define RTL8365MB_EXT_PORT_MODE_MII_MAC\t\t2\n#define RTL8365MB_EXT_PORT_MODE_MII_PHY\t\t3\n#define RTL8365MB_EXT_PORT_MODE_TMII_MAC\t4\n#define RTL8365MB_EXT_PORT_MODE_TMII_PHY\t5\n#define RTL8365MB_EXT_PORT_MODE_GMII\t\t6\n#define RTL8365MB_EXT_PORT_MODE_RMII_MAC\t7\n#define RTL8365MB_EXT_PORT_MODE_RMII_PHY\t8\n#define RTL8365MB_EXT_PORT_MODE_SGMII\t\t9\n#define RTL8365MB_EXT_PORT_MODE_HSGMII\t\t10\n#define RTL8365MB_EXT_PORT_MODE_1000X_100FX\t11\n#define RTL8365MB_EXT_PORT_MODE_1000X\t\t12\n#define RTL8365MB_EXT_PORT_MODE_100FX\t\t13\n\n \n#define RTL8365MB_DIGITAL_INTERFACE_SELECT_REG0\t\t0x1305  \n#define RTL8365MB_DIGITAL_INTERFACE_SELECT_REG1\t\t0x13C3  \n#define RTL8365MB_DIGITAL_INTERFACE_SELECT_REG(_extint) \\\n\t\t((_extint) == 1 ? RTL8365MB_DIGITAL_INTERFACE_SELECT_REG0 : \\\n\t\t (_extint) == 2 ? RTL8365MB_DIGITAL_INTERFACE_SELECT_REG1 : \\\n\t\t 0x0)\n#define   RTL8365MB_DIGITAL_INTERFACE_SELECT_MODE_MASK(_extint) \\\n\t\t(0xF << (((_extint) % 2)))\n#define   RTL8365MB_DIGITAL_INTERFACE_SELECT_MODE_OFFSET(_extint) \\\n\t\t(((_extint) % 2) * 4)\n\n \n#define RTL8365MB_EXT_RGMXF_REG0\t\t0x1306  \n#define RTL8365MB_EXT_RGMXF_REG1\t\t0x1307  \n#define RTL8365MB_EXT_RGMXF_REG2\t\t0x13C5  \n#define RTL8365MB_EXT_RGMXF_REG(_extint) \\\n\t\t((_extint) == 0 ? RTL8365MB_EXT_RGMXF_REG0 : \\\n\t\t (_extint) == 1 ? RTL8365MB_EXT_RGMXF_REG1 : \\\n\t\t (_extint) == 2 ? RTL8365MB_EXT_RGMXF_REG2 : \\\n\t\t 0x0)\n#define   RTL8365MB_EXT_RGMXF_RXDELAY_MASK\t0x0007\n#define   RTL8365MB_EXT_RGMXF_TXDELAY_MASK\t0x0008\n\n \n#define RTL8365MB_PORT_SPEED_10M\t0\n#define RTL8365MB_PORT_SPEED_100M\t1\n#define RTL8365MB_PORT_SPEED_1000M\t2\n\n \n#define RTL8365MB_DIGITAL_INTERFACE_FORCE_REG0\t\t0x1310  \n#define RTL8365MB_DIGITAL_INTERFACE_FORCE_REG1\t\t0x1311  \n#define RTL8365MB_DIGITAL_INTERFACE_FORCE_REG2\t\t0x13C4  \n#define RTL8365MB_DIGITAL_INTERFACE_FORCE_REG(_extint) \\\n\t\t((_extint) == 0 ? RTL8365MB_DIGITAL_INTERFACE_FORCE_REG0 : \\\n\t\t (_extint) == 1 ? RTL8365MB_DIGITAL_INTERFACE_FORCE_REG1 : \\\n\t\t (_extint) == 2 ? RTL8365MB_DIGITAL_INTERFACE_FORCE_REG2 : \\\n\t\t 0x0)\n#define   RTL8365MB_DIGITAL_INTERFACE_FORCE_EN_MASK\t\t0x1000\n#define   RTL8365MB_DIGITAL_INTERFACE_FORCE_NWAY_MASK\t\t0x0080\n#define   RTL8365MB_DIGITAL_INTERFACE_FORCE_TXPAUSE_MASK\t0x0040\n#define   RTL8365MB_DIGITAL_INTERFACE_FORCE_RXPAUSE_MASK\t0x0020\n#define   RTL8365MB_DIGITAL_INTERFACE_FORCE_LINK_MASK\t\t0x0010\n#define   RTL8365MB_DIGITAL_INTERFACE_FORCE_DUPLEX_MASK\t\t0x0004\n#define   RTL8365MB_DIGITAL_INTERFACE_FORCE_SPEED_MASK\t\t0x0003\n\n \n#define RTL8365MB_CPU_PORT_MASK_REG\t0x1219\n#define   RTL8365MB_CPU_PORT_MASK_MASK\t0x07FF\n\n \n#define RTL8365MB_CPU_CTRL_REG\t\t\t0x121A\n#define   RTL8365MB_CPU_CTRL_TRAP_PORT_EXT_MASK\t0x0400\n#define   RTL8365MB_CPU_CTRL_TAG_FORMAT_MASK\t0x0200\n#define   RTL8365MB_CPU_CTRL_RXBYTECOUNT_MASK\t0x0080\n#define   RTL8365MB_CPU_CTRL_TAG_POSITION_MASK\t0x0040\n#define   RTL8365MB_CPU_CTRL_TRAP_PORT_MASK\t0x0038\n#define   RTL8365MB_CPU_CTRL_INSERTMODE_MASK\t0x0006\n#define   RTL8365MB_CPU_CTRL_EN_MASK\t\t0x0001\n\n \n#define RTL8365MB_CFG0_MAX_LEN_REG\t0x088C\n#define   RTL8365MB_CFG0_MAX_LEN_MASK\t0x3FFF\n#define RTL8365MB_CFG0_MAX_LEN_MAX\t0x3FFF\n\n \n#define RTL8365MB_LUT_PORT_LEARN_LIMIT_BASE\t\t0x0A20\n#define RTL8365MB_LUT_PORT_LEARN_LIMIT_REG(_physport) \\\n\t\t(RTL8365MB_LUT_PORT_LEARN_LIMIT_BASE + (_physport))\n\n \n#define RTL8365MB_PORT_ISOLATION_REG_BASE\t\t0x08A2\n#define RTL8365MB_PORT_ISOLATION_REG(_physport) \\\n\t\t(RTL8365MB_PORT_ISOLATION_REG_BASE + (_physport))\n#define   RTL8365MB_PORT_ISOLATION_MASK\t\t\t0x07FF\n\n \n#define RTL8365MB_MSTI_CTRL_BASE\t\t\t0x0A00\n#define RTL8365MB_MSTI_CTRL_REG(_msti, _physport) \\\n\t\t(RTL8365MB_MSTI_CTRL_BASE + ((_msti) << 1) + ((_physport) >> 3))\n#define   RTL8365MB_MSTI_CTRL_PORT_STATE_OFFSET(_physport) ((_physport) << 1)\n#define   RTL8365MB_MSTI_CTRL_PORT_STATE_MASK(_physport) \\\n\t\t(0x3 << RTL8365MB_MSTI_CTRL_PORT_STATE_OFFSET((_physport)))\n\n \n#define RTL8365MB_MIB_COUNTER_BASE\t0x1000\n#define RTL8365MB_MIB_COUNTER_REG(_x)\t(RTL8365MB_MIB_COUNTER_BASE + (_x))\n\n \n#define RTL8365MB_MIB_ADDRESS_REG\t\t0x1004\n#define   RTL8365MB_MIB_ADDRESS_PORT_OFFSET\t0x007C\n#define   RTL8365MB_MIB_ADDRESS(_p, _x) \\\n\t\t(((RTL8365MB_MIB_ADDRESS_PORT_OFFSET) * (_p) + (_x)) >> 2)\n\n#define RTL8365MB_MIB_CTRL0_REG\t\t\t0x1005\n#define   RTL8365MB_MIB_CTRL0_RESET_MASK\t0x0002\n#define   RTL8365MB_MIB_CTRL0_BUSY_MASK\t\t0x0001\n\n \n#define RTL8365MB_STATS_INTERVAL_JIFFIES\t(3 * HZ)\n\nenum rtl8365mb_mib_counter_index {\n\tRTL8365MB_MIB_ifInOctets,\n\tRTL8365MB_MIB_dot3StatsFCSErrors,\n\tRTL8365MB_MIB_dot3StatsSymbolErrors,\n\tRTL8365MB_MIB_dot3InPauseFrames,\n\tRTL8365MB_MIB_dot3ControlInUnknownOpcodes,\n\tRTL8365MB_MIB_etherStatsFragments,\n\tRTL8365MB_MIB_etherStatsJabbers,\n\tRTL8365MB_MIB_ifInUcastPkts,\n\tRTL8365MB_MIB_etherStatsDropEvents,\n\tRTL8365MB_MIB_ifInMulticastPkts,\n\tRTL8365MB_MIB_ifInBroadcastPkts,\n\tRTL8365MB_MIB_inMldChecksumError,\n\tRTL8365MB_MIB_inIgmpChecksumError,\n\tRTL8365MB_MIB_inMldSpecificQuery,\n\tRTL8365MB_MIB_inMldGeneralQuery,\n\tRTL8365MB_MIB_inIgmpSpecificQuery,\n\tRTL8365MB_MIB_inIgmpGeneralQuery,\n\tRTL8365MB_MIB_inMldLeaves,\n\tRTL8365MB_MIB_inIgmpLeaves,\n\tRTL8365MB_MIB_etherStatsOctets,\n\tRTL8365MB_MIB_etherStatsUnderSizePkts,\n\tRTL8365MB_MIB_etherOversizeStats,\n\tRTL8365MB_MIB_etherStatsPkts64Octets,\n\tRTL8365MB_MIB_etherStatsPkts65to127Octets,\n\tRTL8365MB_MIB_etherStatsPkts128to255Octets,\n\tRTL8365MB_MIB_etherStatsPkts256to511Octets,\n\tRTL8365MB_MIB_etherStatsPkts512to1023Octets,\n\tRTL8365MB_MIB_etherStatsPkts1024to1518Octets,\n\tRTL8365MB_MIB_ifOutOctets,\n\tRTL8365MB_MIB_dot3StatsSingleCollisionFrames,\n\tRTL8365MB_MIB_dot3StatsMultipleCollisionFrames,\n\tRTL8365MB_MIB_dot3StatsDeferredTransmissions,\n\tRTL8365MB_MIB_dot3StatsLateCollisions,\n\tRTL8365MB_MIB_etherStatsCollisions,\n\tRTL8365MB_MIB_dot3StatsExcessiveCollisions,\n\tRTL8365MB_MIB_dot3OutPauseFrames,\n\tRTL8365MB_MIB_ifOutDiscards,\n\tRTL8365MB_MIB_dot1dTpPortInDiscards,\n\tRTL8365MB_MIB_ifOutUcastPkts,\n\tRTL8365MB_MIB_ifOutMulticastPkts,\n\tRTL8365MB_MIB_ifOutBroadcastPkts,\n\tRTL8365MB_MIB_outOampduPkts,\n\tRTL8365MB_MIB_inOampduPkts,\n\tRTL8365MB_MIB_inIgmpJoinsSuccess,\n\tRTL8365MB_MIB_inIgmpJoinsFail,\n\tRTL8365MB_MIB_inMldJoinsSuccess,\n\tRTL8365MB_MIB_inMldJoinsFail,\n\tRTL8365MB_MIB_inReportSuppressionDrop,\n\tRTL8365MB_MIB_inLeaveSuppressionDrop,\n\tRTL8365MB_MIB_outIgmpReports,\n\tRTL8365MB_MIB_outIgmpLeaves,\n\tRTL8365MB_MIB_outIgmpGeneralQuery,\n\tRTL8365MB_MIB_outIgmpSpecificQuery,\n\tRTL8365MB_MIB_outMldReports,\n\tRTL8365MB_MIB_outMldLeaves,\n\tRTL8365MB_MIB_outMldGeneralQuery,\n\tRTL8365MB_MIB_outMldSpecificQuery,\n\tRTL8365MB_MIB_inKnownMulticastPkts,\n\tRTL8365MB_MIB_END,\n};\n\nstruct rtl8365mb_mib_counter {\n\tu32 offset;\n\tu32 length;\n\tconst char *name;\n};\n\n#define RTL8365MB_MAKE_MIB_COUNTER(_offset, _length, _name) \\\n\t\t[RTL8365MB_MIB_ ## _name] = { _offset, _length, #_name }\n\nstatic struct rtl8365mb_mib_counter rtl8365mb_mib_counters[] = {\n\tRTL8365MB_MAKE_MIB_COUNTER(0, 4, ifInOctets),\n\tRTL8365MB_MAKE_MIB_COUNTER(4, 2, dot3StatsFCSErrors),\n\tRTL8365MB_MAKE_MIB_COUNTER(6, 2, dot3StatsSymbolErrors),\n\tRTL8365MB_MAKE_MIB_COUNTER(8, 2, dot3InPauseFrames),\n\tRTL8365MB_MAKE_MIB_COUNTER(10, 2, dot3ControlInUnknownOpcodes),\n\tRTL8365MB_MAKE_MIB_COUNTER(12, 2, etherStatsFragments),\n\tRTL8365MB_MAKE_MIB_COUNTER(14, 2, etherStatsJabbers),\n\tRTL8365MB_MAKE_MIB_COUNTER(16, 2, ifInUcastPkts),\n\tRTL8365MB_MAKE_MIB_COUNTER(18, 2, etherStatsDropEvents),\n\tRTL8365MB_MAKE_MIB_COUNTER(20, 2, ifInMulticastPkts),\n\tRTL8365MB_MAKE_MIB_COUNTER(22, 2, ifInBroadcastPkts),\n\tRTL8365MB_MAKE_MIB_COUNTER(24, 2, inMldChecksumError),\n\tRTL8365MB_MAKE_MIB_COUNTER(26, 2, inIgmpChecksumError),\n\tRTL8365MB_MAKE_MIB_COUNTER(28, 2, inMldSpecificQuery),\n\tRTL8365MB_MAKE_MIB_COUNTER(30, 2, inMldGeneralQuery),\n\tRTL8365MB_MAKE_MIB_COUNTER(32, 2, inIgmpSpecificQuery),\n\tRTL8365MB_MAKE_MIB_COUNTER(34, 2, inIgmpGeneralQuery),\n\tRTL8365MB_MAKE_MIB_COUNTER(36, 2, inMldLeaves),\n\tRTL8365MB_MAKE_MIB_COUNTER(38, 2, inIgmpLeaves),\n\tRTL8365MB_MAKE_MIB_COUNTER(40, 4, etherStatsOctets),\n\tRTL8365MB_MAKE_MIB_COUNTER(44, 2, etherStatsUnderSizePkts),\n\tRTL8365MB_MAKE_MIB_COUNTER(46, 2, etherOversizeStats),\n\tRTL8365MB_MAKE_MIB_COUNTER(48, 2, etherStatsPkts64Octets),\n\tRTL8365MB_MAKE_MIB_COUNTER(50, 2, etherStatsPkts65to127Octets),\n\tRTL8365MB_MAKE_MIB_COUNTER(52, 2, etherStatsPkts128to255Octets),\n\tRTL8365MB_MAKE_MIB_COUNTER(54, 2, etherStatsPkts256to511Octets),\n\tRTL8365MB_MAKE_MIB_COUNTER(56, 2, etherStatsPkts512to1023Octets),\n\tRTL8365MB_MAKE_MIB_COUNTER(58, 2, etherStatsPkts1024to1518Octets),\n\tRTL8365MB_MAKE_MIB_COUNTER(60, 4, ifOutOctets),\n\tRTL8365MB_MAKE_MIB_COUNTER(64, 2, dot3StatsSingleCollisionFrames),\n\tRTL8365MB_MAKE_MIB_COUNTER(66, 2, dot3StatsMultipleCollisionFrames),\n\tRTL8365MB_MAKE_MIB_COUNTER(68, 2, dot3StatsDeferredTransmissions),\n\tRTL8365MB_MAKE_MIB_COUNTER(70, 2, dot3StatsLateCollisions),\n\tRTL8365MB_MAKE_MIB_COUNTER(72, 2, etherStatsCollisions),\n\tRTL8365MB_MAKE_MIB_COUNTER(74, 2, dot3StatsExcessiveCollisions),\n\tRTL8365MB_MAKE_MIB_COUNTER(76, 2, dot3OutPauseFrames),\n\tRTL8365MB_MAKE_MIB_COUNTER(78, 2, ifOutDiscards),\n\tRTL8365MB_MAKE_MIB_COUNTER(80, 2, dot1dTpPortInDiscards),\n\tRTL8365MB_MAKE_MIB_COUNTER(82, 2, ifOutUcastPkts),\n\tRTL8365MB_MAKE_MIB_COUNTER(84, 2, ifOutMulticastPkts),\n\tRTL8365MB_MAKE_MIB_COUNTER(86, 2, ifOutBroadcastPkts),\n\tRTL8365MB_MAKE_MIB_COUNTER(88, 2, outOampduPkts),\n\tRTL8365MB_MAKE_MIB_COUNTER(90, 2, inOampduPkts),\n\tRTL8365MB_MAKE_MIB_COUNTER(92, 4, inIgmpJoinsSuccess),\n\tRTL8365MB_MAKE_MIB_COUNTER(96, 2, inIgmpJoinsFail),\n\tRTL8365MB_MAKE_MIB_COUNTER(98, 2, inMldJoinsSuccess),\n\tRTL8365MB_MAKE_MIB_COUNTER(100, 2, inMldJoinsFail),\n\tRTL8365MB_MAKE_MIB_COUNTER(102, 2, inReportSuppressionDrop),\n\tRTL8365MB_MAKE_MIB_COUNTER(104, 2, inLeaveSuppressionDrop),\n\tRTL8365MB_MAKE_MIB_COUNTER(106, 2, outIgmpReports),\n\tRTL8365MB_MAKE_MIB_COUNTER(108, 2, outIgmpLeaves),\n\tRTL8365MB_MAKE_MIB_COUNTER(110, 2, outIgmpGeneralQuery),\n\tRTL8365MB_MAKE_MIB_COUNTER(112, 2, outIgmpSpecificQuery),\n\tRTL8365MB_MAKE_MIB_COUNTER(114, 2, outMldReports),\n\tRTL8365MB_MAKE_MIB_COUNTER(116, 2, outMldLeaves),\n\tRTL8365MB_MAKE_MIB_COUNTER(118, 2, outMldGeneralQuery),\n\tRTL8365MB_MAKE_MIB_COUNTER(120, 2, outMldSpecificQuery),\n\tRTL8365MB_MAKE_MIB_COUNTER(122, 2, inKnownMulticastPkts),\n};\n\nstatic_assert(ARRAY_SIZE(rtl8365mb_mib_counters) == RTL8365MB_MIB_END);\n\nstruct rtl8365mb_jam_tbl_entry {\n\tu16 reg;\n\tu16 val;\n};\n\n \nstatic const struct rtl8365mb_jam_tbl_entry rtl8365mb_init_jam_8365mb_vc[] = {\n\t{ 0x13EB, 0x15BB }, { 0x1303, 0x06D6 }, { 0x1304, 0x0700 },\n\t{ 0x13E2, 0x003F }, { 0x13F9, 0x0090 }, { 0x121E, 0x03CA },\n\t{ 0x1233, 0x0352 }, { 0x1237, 0x00A0 }, { 0x123A, 0x0030 },\n\t{ 0x1239, 0x0084 }, { 0x0301, 0x1000 }, { 0x1349, 0x001F },\n\t{ 0x18E0, 0x4004 }, { 0x122B, 0x241C }, { 0x1305, 0xC000 },\n\t{ 0x13F0, 0x0000 },\n};\n\nstatic const struct rtl8365mb_jam_tbl_entry rtl8365mb_init_jam_common[] = {\n\t{ 0x1200, 0x7FCB }, { 0x0884, 0x0003 }, { 0x06EB, 0x0001 },\n\t{ 0x03Fa, 0x0007 }, { 0x08C8, 0x00C0 }, { 0x0A30, 0x020E },\n\t{ 0x0800, 0x0000 }, { 0x0802, 0x0000 }, { 0x09DA, 0x0013 },\n\t{ 0x1D32, 0x0002 },\n};\n\nenum rtl8365mb_phy_interface_mode {\n\tRTL8365MB_PHY_INTERFACE_MODE_INVAL = 0,\n\tRTL8365MB_PHY_INTERFACE_MODE_INTERNAL = BIT(0),\n\tRTL8365MB_PHY_INTERFACE_MODE_MII = BIT(1),\n\tRTL8365MB_PHY_INTERFACE_MODE_TMII = BIT(2),\n\tRTL8365MB_PHY_INTERFACE_MODE_RMII = BIT(3),\n\tRTL8365MB_PHY_INTERFACE_MODE_RGMII = BIT(4),\n\tRTL8365MB_PHY_INTERFACE_MODE_SGMII = BIT(5),\n\tRTL8365MB_PHY_INTERFACE_MODE_HSGMII = BIT(6),\n};\n\n \nstruct rtl8365mb_extint {\n\tint port;\n\tint id;\n\tunsigned int supported_interfaces;\n};\n\n \nstruct rtl8365mb_chip_info {\n\tconst char *name;\n\tu32 chip_id;\n\tu32 chip_ver;\n\tconst struct rtl8365mb_extint extints[RTL8365MB_MAX_NUM_EXTINTS];\n\tconst struct rtl8365mb_jam_tbl_entry *jam_table;\n\tsize_t jam_size;\n};\n\n \n#define PHY_INTF(_mode) (RTL8365MB_PHY_INTERFACE_MODE_ ## _mode)\nstatic const struct rtl8365mb_chip_info rtl8365mb_chip_infos[] = {\n\t{\n\t\t.name = \"RTL8365MB-VC\",\n\t\t.chip_id = 0x6367,\n\t\t.chip_ver = 0x0040,\n\t\t.extints = {\n\t\t\t{ 6, 1, PHY_INTF(MII) | PHY_INTF(TMII) |\n\t\t\t\tPHY_INTF(RMII) | PHY_INTF(RGMII) },\n\t\t},\n\t\t.jam_table = rtl8365mb_init_jam_8365mb_vc,\n\t\t.jam_size = ARRAY_SIZE(rtl8365mb_init_jam_8365mb_vc),\n\t},\n\t{\n\t\t.name = \"RTL8367S\",\n\t\t.chip_id = 0x6367,\n\t\t.chip_ver = 0x00A0,\n\t\t.extints = {\n\t\t\t{ 6, 1, PHY_INTF(SGMII) | PHY_INTF(HSGMII) },\n\t\t\t{ 7, 2, PHY_INTF(MII) | PHY_INTF(TMII) |\n\t\t\t\tPHY_INTF(RMII) | PHY_INTF(RGMII) },\n\t\t},\n\t\t.jam_table = rtl8365mb_init_jam_8365mb_vc,\n\t\t.jam_size = ARRAY_SIZE(rtl8365mb_init_jam_8365mb_vc),\n\t},\n\t{\n\t\t.name = \"RTL8367RB-VB\",\n\t\t.chip_id = 0x6367,\n\t\t.chip_ver = 0x0020,\n\t\t.extints = {\n\t\t\t{ 6, 1, PHY_INTF(MII) | PHY_INTF(TMII) |\n\t\t\t\tPHY_INTF(RMII) | PHY_INTF(RGMII) },\n\t\t\t{ 7, 2, PHY_INTF(MII) | PHY_INTF(TMII) |\n\t\t\t\tPHY_INTF(RMII) | PHY_INTF(RGMII) },\n\t\t},\n\t\t.jam_table = rtl8365mb_init_jam_8365mb_vc,\n\t\t.jam_size = ARRAY_SIZE(rtl8365mb_init_jam_8365mb_vc),\n\t},\n};\n\nenum rtl8365mb_stp_state {\n\tRTL8365MB_STP_STATE_DISABLED = 0,\n\tRTL8365MB_STP_STATE_BLOCKING = 1,\n\tRTL8365MB_STP_STATE_LEARNING = 2,\n\tRTL8365MB_STP_STATE_FORWARDING = 3,\n};\n\nenum rtl8365mb_cpu_insert {\n\tRTL8365MB_CPU_INSERT_TO_ALL = 0,\n\tRTL8365MB_CPU_INSERT_TO_TRAPPING = 1,\n\tRTL8365MB_CPU_INSERT_TO_NONE = 2,\n};\n\nenum rtl8365mb_cpu_position {\n\tRTL8365MB_CPU_POS_AFTER_SA = 0,\n\tRTL8365MB_CPU_POS_BEFORE_CRC = 1,\n};\n\nenum rtl8365mb_cpu_format {\n\tRTL8365MB_CPU_FORMAT_8BYTES = 0,\n\tRTL8365MB_CPU_FORMAT_4BYTES = 1,\n};\n\nenum rtl8365mb_cpu_rxlen {\n\tRTL8365MB_CPU_RXLEN_72BYTES = 0,\n\tRTL8365MB_CPU_RXLEN_64BYTES = 1,\n};\n\n \nstruct rtl8365mb_cpu {\n\tbool enable;\n\tu32 mask;\n\tu32 trap_port;\n\tenum rtl8365mb_cpu_insert insert;\n\tenum rtl8365mb_cpu_position position;\n\tenum rtl8365mb_cpu_rxlen rx_length;\n\tenum rtl8365mb_cpu_format format;\n};\n\n \nstruct rtl8365mb_port {\n\tstruct realtek_priv *priv;\n\tunsigned int index;\n\tstruct rtnl_link_stats64 stats;\n\tspinlock_t stats_lock;\n\tstruct delayed_work mib_work;\n};\n\n \nstruct rtl8365mb {\n\tstruct realtek_priv *priv;\n\tint irq;\n\tconst struct rtl8365mb_chip_info *chip_info;\n\tstruct rtl8365mb_cpu cpu;\n\tstruct mutex mib_lock;\n\tstruct rtl8365mb_port ports[RTL8365MB_MAX_NUM_PORTS];\n};\n\nstatic int rtl8365mb_phy_poll_busy(struct realtek_priv *priv)\n{\n\tu32 val;\n\n\treturn regmap_read_poll_timeout(priv->map_nolock,\n\t\t\t\t\tRTL8365MB_INDIRECT_ACCESS_STATUS_REG,\n\t\t\t\t\tval, !val, 10, 100);\n}\n\nstatic int rtl8365mb_phy_ocp_prepare(struct realtek_priv *priv, int phy,\n\t\t\t\t     u32 ocp_addr)\n{\n\tu32 val;\n\tint ret;\n\n\t \n\tval = FIELD_GET(RTL8365MB_PHY_OCP_ADDR_PREFIX_MASK, ocp_addr);\n\tret = regmap_update_bits(\n\t\tpriv->map_nolock, RTL8365MB_GPHY_OCP_MSB_0_REG,\n\t\tRTL8365MB_GPHY_OCP_MSB_0_CFG_CPU_OCPADR_MASK,\n\t\tFIELD_PREP(RTL8365MB_GPHY_OCP_MSB_0_CFG_CPU_OCPADR_MASK, val));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tval = RTL8365MB_PHY_BASE;\n\tval |= FIELD_PREP(RTL8365MB_INDIRECT_ACCESS_ADDRESS_PHYNUM_MASK, phy);\n\tval |= FIELD_PREP(RTL8365MB_INDIRECT_ACCESS_ADDRESS_OCPADR_5_1_MASK,\n\t\t\t  ocp_addr >> 1);\n\tval |= FIELD_PREP(RTL8365MB_INDIRECT_ACCESS_ADDRESS_OCPADR_9_6_MASK,\n\t\t\t  ocp_addr >> 6);\n\tret = regmap_write(priv->map_nolock,\n\t\t\t   RTL8365MB_INDIRECT_ACCESS_ADDRESS_REG, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int rtl8365mb_phy_ocp_read(struct realtek_priv *priv, int phy,\n\t\t\t\t  u32 ocp_addr, u16 *data)\n{\n\tu32 val;\n\tint ret;\n\n\tmutex_lock(&priv->map_lock);\n\n\tret = rtl8365mb_phy_poll_busy(priv);\n\tif (ret)\n\t\tgoto out;\n\n\tret = rtl8365mb_phy_ocp_prepare(priv, phy, ocp_addr);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tval = FIELD_PREP(RTL8365MB_INDIRECT_ACCESS_CTRL_CMD_MASK,\n\t\t\t RTL8365MB_INDIRECT_ACCESS_CTRL_CMD_VALUE) |\n\t      FIELD_PREP(RTL8365MB_INDIRECT_ACCESS_CTRL_RW_MASK,\n\t\t\t RTL8365MB_INDIRECT_ACCESS_CTRL_RW_READ);\n\tret = regmap_write(priv->map_nolock, RTL8365MB_INDIRECT_ACCESS_CTRL_REG,\n\t\t\t   val);\n\tif (ret)\n\t\tgoto out;\n\n\tret = rtl8365mb_phy_poll_busy(priv);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = regmap_read(priv->map_nolock,\n\t\t\t  RTL8365MB_INDIRECT_ACCESS_READ_DATA_REG, &val);\n\tif (ret)\n\t\tgoto out;\n\n\t*data = val & 0xFFFF;\n\nout:\n\tmutex_unlock(&priv->map_lock);\n\n\treturn ret;\n}\n\nstatic int rtl8365mb_phy_ocp_write(struct realtek_priv *priv, int phy,\n\t\t\t\t   u32 ocp_addr, u16 data)\n{\n\tu32 val;\n\tint ret;\n\n\tmutex_lock(&priv->map_lock);\n\n\tret = rtl8365mb_phy_poll_busy(priv);\n\tif (ret)\n\t\tgoto out;\n\n\tret = rtl8365mb_phy_ocp_prepare(priv, phy, ocp_addr);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = regmap_write(priv->map_nolock,\n\t\t\t   RTL8365MB_INDIRECT_ACCESS_WRITE_DATA_REG, data);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tval = FIELD_PREP(RTL8365MB_INDIRECT_ACCESS_CTRL_CMD_MASK,\n\t\t\t RTL8365MB_INDIRECT_ACCESS_CTRL_CMD_VALUE) |\n\t      FIELD_PREP(RTL8365MB_INDIRECT_ACCESS_CTRL_RW_MASK,\n\t\t\t RTL8365MB_INDIRECT_ACCESS_CTRL_RW_WRITE);\n\tret = regmap_write(priv->map_nolock, RTL8365MB_INDIRECT_ACCESS_CTRL_REG,\n\t\t\t   val);\n\tif (ret)\n\t\tgoto out;\n\n\tret = rtl8365mb_phy_poll_busy(priv);\n\tif (ret)\n\t\tgoto out;\n\nout:\n\tmutex_unlock(&priv->map_lock);\n\n\treturn 0;\n}\n\nstatic int rtl8365mb_phy_read(struct realtek_priv *priv, int phy, int regnum)\n{\n\tu32 ocp_addr;\n\tu16 val;\n\tint ret;\n\n\tif (phy > RTL8365MB_PHYADDRMAX)\n\t\treturn -EINVAL;\n\n\tif (regnum > RTL8365MB_PHYREGMAX)\n\t\treturn -EINVAL;\n\n\tocp_addr = RTL8365MB_PHY_OCP_ADDR_PHYREG_BASE + regnum * 2;\n\n\tret = rtl8365mb_phy_ocp_read(priv, phy, ocp_addr, &val);\n\tif (ret) {\n\t\tdev_err(priv->dev,\n\t\t\t\"failed to read PHY%d reg %02x @ %04x, ret %d\\n\", phy,\n\t\t\tregnum, ocp_addr, ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(priv->dev, \"read PHY%d register 0x%02x @ %04x, val <- %04x\\n\",\n\t\tphy, regnum, ocp_addr, val);\n\n\treturn val;\n}\n\nstatic int rtl8365mb_phy_write(struct realtek_priv *priv, int phy, int regnum,\n\t\t\t       u16 val)\n{\n\tu32 ocp_addr;\n\tint ret;\n\n\tif (phy > RTL8365MB_PHYADDRMAX)\n\t\treturn -EINVAL;\n\n\tif (regnum > RTL8365MB_PHYREGMAX)\n\t\treturn -EINVAL;\n\n\tocp_addr = RTL8365MB_PHY_OCP_ADDR_PHYREG_BASE + regnum * 2;\n\n\tret = rtl8365mb_phy_ocp_write(priv, phy, ocp_addr, val);\n\tif (ret) {\n\t\tdev_err(priv->dev,\n\t\t\t\"failed to write PHY%d reg %02x @ %04x, ret %d\\n\", phy,\n\t\t\tregnum, ocp_addr, ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(priv->dev, \"write PHY%d register 0x%02x @ %04x, val -> %04x\\n\",\n\t\tphy, regnum, ocp_addr, val);\n\n\treturn 0;\n}\n\nstatic int rtl8365mb_dsa_phy_read(struct dsa_switch *ds, int phy, int regnum)\n{\n\treturn rtl8365mb_phy_read(ds->priv, phy, regnum);\n}\n\nstatic int rtl8365mb_dsa_phy_write(struct dsa_switch *ds, int phy, int regnum,\n\t\t\t\t   u16 val)\n{\n\treturn rtl8365mb_phy_write(ds->priv, phy, regnum, val);\n}\n\nstatic const struct rtl8365mb_extint *\nrtl8365mb_get_port_extint(struct realtek_priv *priv, int port)\n{\n\tstruct rtl8365mb *mb = priv->chip_data;\n\tint i;\n\n\tfor (i = 0; i < RTL8365MB_MAX_NUM_EXTINTS; i++) {\n\t\tconst struct rtl8365mb_extint *extint =\n\t\t\t&mb->chip_info->extints[i];\n\n\t\tif (!extint->supported_interfaces)\n\t\t\tcontinue;\n\n\t\tif (extint->port == port)\n\t\t\treturn extint;\n\t}\n\n\treturn NULL;\n}\n\nstatic enum dsa_tag_protocol\nrtl8365mb_get_tag_protocol(struct dsa_switch *ds, int port,\n\t\t\t   enum dsa_tag_protocol mp)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\tstruct rtl8365mb_cpu *cpu;\n\tstruct rtl8365mb *mb;\n\n\tmb = priv->chip_data;\n\tcpu = &mb->cpu;\n\n\tif (cpu->position == RTL8365MB_CPU_POS_BEFORE_CRC)\n\t\treturn DSA_TAG_PROTO_RTL8_4T;\n\n\treturn DSA_TAG_PROTO_RTL8_4;\n}\n\nstatic int rtl8365mb_ext_config_rgmii(struct realtek_priv *priv, int port,\n\t\t\t\t      phy_interface_t interface)\n{\n\tconst struct rtl8365mb_extint *extint =\n\t\trtl8365mb_get_port_extint(priv, port);\n\tstruct device_node *dn;\n\tstruct dsa_port *dp;\n\tint tx_delay = 0;\n\tint rx_delay = 0;\n\tu32 val;\n\tint ret;\n\n\tif (!extint)\n\t\treturn -ENODEV;\n\n\tdp = dsa_to_port(priv->ds, port);\n\tdn = dp->dn;\n\n\t \n\tif (!of_property_read_u32(dn, \"tx-internal-delay-ps\", &val)) {\n\t\tval = val / 1000;  \n\n\t\tif (val == 0 || val == 2)\n\t\t\ttx_delay = val / 2;\n\t\telse\n\t\t\tdev_warn(priv->dev,\n\t\t\t\t \"RGMII TX delay must be 0 or 2 ns\\n\");\n\t}\n\n\tif (!of_property_read_u32(dn, \"rx-internal-delay-ps\", &val)) {\n\t\tval = DIV_ROUND_CLOSEST(val, 300);  \n\n\t\tif (val <= 7)\n\t\t\trx_delay = val;\n\t\telse\n\t\t\tdev_warn(priv->dev,\n\t\t\t\t \"RGMII RX delay must be 0 to 2.1 ns\\n\");\n\t}\n\n\tret = regmap_update_bits(\n\t\tpriv->map, RTL8365MB_EXT_RGMXF_REG(extint->id),\n\t\tRTL8365MB_EXT_RGMXF_TXDELAY_MASK |\n\t\t\tRTL8365MB_EXT_RGMXF_RXDELAY_MASK,\n\t\tFIELD_PREP(RTL8365MB_EXT_RGMXF_TXDELAY_MASK, tx_delay) |\n\t\t\tFIELD_PREP(RTL8365MB_EXT_RGMXF_RXDELAY_MASK, rx_delay));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(\n\t\tpriv->map, RTL8365MB_DIGITAL_INTERFACE_SELECT_REG(extint->id),\n\t\tRTL8365MB_DIGITAL_INTERFACE_SELECT_MODE_MASK(extint->id),\n\t\tRTL8365MB_EXT_PORT_MODE_RGMII\n\t\t\t<< RTL8365MB_DIGITAL_INTERFACE_SELECT_MODE_OFFSET(\n\t\t\t\t   extint->id));\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int rtl8365mb_ext_config_forcemode(struct realtek_priv *priv, int port,\n\t\t\t\t\t  bool link, int speed, int duplex,\n\t\t\t\t\t  bool tx_pause, bool rx_pause)\n{\n\tconst struct rtl8365mb_extint *extint =\n\t\trtl8365mb_get_port_extint(priv, port);\n\tu32 r_tx_pause;\n\tu32 r_rx_pause;\n\tu32 r_duplex;\n\tu32 r_speed;\n\tu32 r_link;\n\tint val;\n\tint ret;\n\n\tif (!extint)\n\t\treturn -ENODEV;\n\n\tif (link) {\n\t\t \n\t\tr_link = 1;\n\t\tr_rx_pause = rx_pause ? 1 : 0;\n\t\tr_tx_pause = tx_pause ? 1 : 0;\n\n\t\tif (speed == SPEED_1000) {\n\t\t\tr_speed = RTL8365MB_PORT_SPEED_1000M;\n\t\t} else if (speed == SPEED_100) {\n\t\t\tr_speed = RTL8365MB_PORT_SPEED_100M;\n\t\t} else if (speed == SPEED_10) {\n\t\t\tr_speed = RTL8365MB_PORT_SPEED_10M;\n\t\t} else {\n\t\t\tdev_err(priv->dev, \"unsupported port speed %s\\n\",\n\t\t\t\tphy_speed_to_str(speed));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (duplex == DUPLEX_FULL) {\n\t\t\tr_duplex = 1;\n\t\t} else if (duplex == DUPLEX_HALF) {\n\t\t\tr_duplex = 0;\n\t\t} else {\n\t\t\tdev_err(priv->dev, \"unsupported duplex %s\\n\",\n\t\t\t\tphy_duplex_to_str(duplex));\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t \n\t\tr_link = 0;\n\t\tr_tx_pause = 0;\n\t\tr_rx_pause = 0;\n\t\tr_speed = 0;\n\t\tr_duplex = 0;\n\t}\n\n\tval = FIELD_PREP(RTL8365MB_DIGITAL_INTERFACE_FORCE_EN_MASK, 1) |\n\t      FIELD_PREP(RTL8365MB_DIGITAL_INTERFACE_FORCE_TXPAUSE_MASK,\n\t\t\t r_tx_pause) |\n\t      FIELD_PREP(RTL8365MB_DIGITAL_INTERFACE_FORCE_RXPAUSE_MASK,\n\t\t\t r_rx_pause) |\n\t      FIELD_PREP(RTL8365MB_DIGITAL_INTERFACE_FORCE_LINK_MASK, r_link) |\n\t      FIELD_PREP(RTL8365MB_DIGITAL_INTERFACE_FORCE_DUPLEX_MASK,\n\t\t\t r_duplex) |\n\t      FIELD_PREP(RTL8365MB_DIGITAL_INTERFACE_FORCE_SPEED_MASK, r_speed);\n\tret = regmap_write(priv->map,\n\t\t\t   RTL8365MB_DIGITAL_INTERFACE_FORCE_REG(extint->id),\n\t\t\t   val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void rtl8365mb_phylink_get_caps(struct dsa_switch *ds, int port,\n\t\t\t\t       struct phylink_config *config)\n{\n\tconst struct rtl8365mb_extint *extint =\n\t\trtl8365mb_get_port_extint(ds->priv, port);\n\n\tconfig->mac_capabilities = MAC_SYM_PAUSE | MAC_ASYM_PAUSE |\n\t\t\t\t   MAC_10 | MAC_100 | MAC_1000FD;\n\n\tif (!extint) {\n\t\t__set_bit(PHY_INTERFACE_MODE_INTERNAL,\n\t\t\t  config->supported_interfaces);\n\n\t\t \n\t\t__set_bit(PHY_INTERFACE_MODE_GMII,\n\t\t\t  config->supported_interfaces);\n\t\treturn;\n\t}\n\n\t \n\n\tif (extint->supported_interfaces & RTL8365MB_PHY_INTERFACE_MODE_RGMII)\n\t\tphy_interface_set_rgmii(config->supported_interfaces);\n}\n\nstatic void rtl8365mb_phylink_mac_config(struct dsa_switch *ds, int port,\n\t\t\t\t\t unsigned int mode,\n\t\t\t\t\t const struct phylink_link_state *state)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\tint ret;\n\n\tif (mode != MLO_AN_PHY && mode != MLO_AN_FIXED) {\n\t\tdev_err(priv->dev,\n\t\t\t\"port %d supports only conventional PHY or fixed-link\\n\",\n\t\t\tport);\n\t\treturn;\n\t}\n\n\tif (phy_interface_mode_is_rgmii(state->interface)) {\n\t\tret = rtl8365mb_ext_config_rgmii(priv, port, state->interface);\n\t\tif (ret)\n\t\t\tdev_err(priv->dev,\n\t\t\t\t\"failed to configure RGMII mode on port %d: %d\\n\",\n\t\t\t\tport, ret);\n\t\treturn;\n\t}\n\n\t \n}\n\nstatic void rtl8365mb_phylink_mac_link_down(struct dsa_switch *ds, int port,\n\t\t\t\t\t    unsigned int mode,\n\t\t\t\t\t    phy_interface_t interface)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\tstruct rtl8365mb_port *p;\n\tstruct rtl8365mb *mb;\n\tint ret;\n\n\tmb = priv->chip_data;\n\tp = &mb->ports[port];\n\tcancel_delayed_work_sync(&p->mib_work);\n\n\tif (phy_interface_mode_is_rgmii(interface)) {\n\t\tret = rtl8365mb_ext_config_forcemode(priv, port, false, 0, 0,\n\t\t\t\t\t\t     false, false);\n\t\tif (ret)\n\t\t\tdev_err(priv->dev,\n\t\t\t\t\"failed to reset forced mode on port %d: %d\\n\",\n\t\t\t\tport, ret);\n\n\t\treturn;\n\t}\n}\n\nstatic void rtl8365mb_phylink_mac_link_up(struct dsa_switch *ds, int port,\n\t\t\t\t\t  unsigned int mode,\n\t\t\t\t\t  phy_interface_t interface,\n\t\t\t\t\t  struct phy_device *phydev, int speed,\n\t\t\t\t\t  int duplex, bool tx_pause,\n\t\t\t\t\t  bool rx_pause)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\tstruct rtl8365mb_port *p;\n\tstruct rtl8365mb *mb;\n\tint ret;\n\n\tmb = priv->chip_data;\n\tp = &mb->ports[port];\n\tschedule_delayed_work(&p->mib_work, 0);\n\n\tif (phy_interface_mode_is_rgmii(interface)) {\n\t\tret = rtl8365mb_ext_config_forcemode(priv, port, true, speed,\n\t\t\t\t\t\t     duplex, tx_pause,\n\t\t\t\t\t\t     rx_pause);\n\t\tif (ret)\n\t\t\tdev_err(priv->dev,\n\t\t\t\t\"failed to force mode on port %d: %d\\n\", port,\n\t\t\t\tret);\n\n\t\treturn;\n\t}\n}\n\nstatic int rtl8365mb_port_change_mtu(struct dsa_switch *ds, int port,\n\t\t\t\t     int new_mtu)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\tint frame_size;\n\n\t \n\tif (!dsa_is_cpu_port(ds, port))\n\t\treturn 0;\n\n\tframe_size = new_mtu + VLAN_ETH_HLEN + ETH_FCS_LEN;\n\n\tdev_dbg(priv->dev, \"changing mtu to %d (frame size: %d)\\n\",\n\t\tnew_mtu, frame_size);\n\n\treturn regmap_update_bits(priv->map, RTL8365MB_CFG0_MAX_LEN_REG,\n\t\t\t\t  RTL8365MB_CFG0_MAX_LEN_MASK,\n\t\t\t\t  FIELD_PREP(RTL8365MB_CFG0_MAX_LEN_MASK,\n\t\t\t\t\t     frame_size));\n}\n\nstatic int rtl8365mb_port_max_mtu(struct dsa_switch *ds, int port)\n{\n\treturn RTL8365MB_CFG0_MAX_LEN_MAX - VLAN_ETH_HLEN - ETH_FCS_LEN;\n}\n\nstatic void rtl8365mb_port_stp_state_set(struct dsa_switch *ds, int port,\n\t\t\t\t\t u8 state)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\tenum rtl8365mb_stp_state val;\n\tint msti = 0;\n\n\tswitch (state) {\n\tcase BR_STATE_DISABLED:\n\t\tval = RTL8365MB_STP_STATE_DISABLED;\n\t\tbreak;\n\tcase BR_STATE_BLOCKING:\n\tcase BR_STATE_LISTENING:\n\t\tval = RTL8365MB_STP_STATE_BLOCKING;\n\t\tbreak;\n\tcase BR_STATE_LEARNING:\n\t\tval = RTL8365MB_STP_STATE_LEARNING;\n\t\tbreak;\n\tcase BR_STATE_FORWARDING:\n\t\tval = RTL8365MB_STP_STATE_FORWARDING;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(priv->dev, \"invalid STP state: %u\\n\", state);\n\t\treturn;\n\t}\n\n\tregmap_update_bits(priv->map, RTL8365MB_MSTI_CTRL_REG(msti, port),\n\t\t\t   RTL8365MB_MSTI_CTRL_PORT_STATE_MASK(port),\n\t\t\t   val << RTL8365MB_MSTI_CTRL_PORT_STATE_OFFSET(port));\n}\n\nstatic int rtl8365mb_port_set_learning(struct realtek_priv *priv, int port,\n\t\t\t\t       bool enable)\n{\n\t \n\treturn regmap_write(priv->map, RTL8365MB_LUT_PORT_LEARN_LIMIT_REG(port),\n\t\t\t    enable ? RTL8365MB_LEARN_LIMIT_MAX : 0);\n}\n\nstatic int rtl8365mb_port_set_isolation(struct realtek_priv *priv, int port,\n\t\t\t\t\tu32 mask)\n{\n\treturn regmap_write(priv->map, RTL8365MB_PORT_ISOLATION_REG(port), mask);\n}\n\nstatic int rtl8365mb_mib_counter_read(struct realtek_priv *priv, int port,\n\t\t\t\t      u32 offset, u32 length, u64 *mibvalue)\n{\n\tu64 tmpvalue = 0;\n\tu32 val;\n\tint ret;\n\tint i;\n\n\t \n\tret = regmap_write(priv->map, RTL8365MB_MIB_ADDRESS_REG,\n\t\t\t   RTL8365MB_MIB_ADDRESS(port, offset));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_read_poll_timeout(priv->map, RTL8365MB_MIB_CTRL0_REG, val,\n\t\t\t\t       !(val & RTL8365MB_MIB_CTRL0_BUSY_MASK),\n\t\t\t\t       10, 100);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (val & RTL8365MB_MIB_CTRL0_RESET_MASK)\n\t\treturn -EIO;\n\n\t \n\tif (length == 4)\n\t\toffset = 3;\n\telse\n\t\toffset = (offset + 1) % 4;\n\n\t \n\tfor (i = 0; i < length; i++) {\n\t\tret = regmap_read(priv->map,\n\t\t\t\t  RTL8365MB_MIB_COUNTER_REG(offset - i), &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\ttmpvalue = ((tmpvalue) << 16) | (val & 0xFFFF);\n\t}\n\n\t \n\t*mibvalue = tmpvalue;\n\n\treturn 0;\n}\n\nstatic void rtl8365mb_get_ethtool_stats(struct dsa_switch *ds, int port, u64 *data)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\tstruct rtl8365mb *mb;\n\tint ret;\n\tint i;\n\n\tmb = priv->chip_data;\n\n\tmutex_lock(&mb->mib_lock);\n\tfor (i = 0; i < RTL8365MB_MIB_END; i++) {\n\t\tstruct rtl8365mb_mib_counter *mib = &rtl8365mb_mib_counters[i];\n\n\t\tret = rtl8365mb_mib_counter_read(priv, port, mib->offset,\n\t\t\t\t\t\t mib->length, &data[i]);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev,\n\t\t\t\t\"failed to read port %d counters: %d\\n\", port,\n\t\t\t\tret);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&mb->mib_lock);\n}\n\nstatic void rtl8365mb_get_strings(struct dsa_switch *ds, int port, u32 stringset, u8 *data)\n{\n\tint i;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tfor (i = 0; i < RTL8365MB_MIB_END; i++) {\n\t\tstruct rtl8365mb_mib_counter *mib = &rtl8365mb_mib_counters[i];\n\n\t\tstrncpy(data + i * ETH_GSTRING_LEN, mib->name, ETH_GSTRING_LEN);\n\t}\n}\n\nstatic int rtl8365mb_get_sset_count(struct dsa_switch *ds, int port, int sset)\n{\n\tif (sset != ETH_SS_STATS)\n\t\treturn -EOPNOTSUPP;\n\n\treturn RTL8365MB_MIB_END;\n}\n\nstatic void rtl8365mb_get_phy_stats(struct dsa_switch *ds, int port,\n\t\t\t\t    struct ethtool_eth_phy_stats *phy_stats)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\tstruct rtl8365mb_mib_counter *mib;\n\tstruct rtl8365mb *mb;\n\n\tmb = priv->chip_data;\n\tmib = &rtl8365mb_mib_counters[RTL8365MB_MIB_dot3StatsSymbolErrors];\n\n\tmutex_lock(&mb->mib_lock);\n\trtl8365mb_mib_counter_read(priv, port, mib->offset, mib->length,\n\t\t\t\t   &phy_stats->SymbolErrorDuringCarrier);\n\tmutex_unlock(&mb->mib_lock);\n}\n\nstatic void rtl8365mb_get_mac_stats(struct dsa_switch *ds, int port,\n\t\t\t\t    struct ethtool_eth_mac_stats *mac_stats)\n{\n\tu64 cnt[RTL8365MB_MIB_END] = {\n\t\t[RTL8365MB_MIB_ifOutOctets] = 1,\n\t\t[RTL8365MB_MIB_ifOutUcastPkts] = 1,\n\t\t[RTL8365MB_MIB_ifOutMulticastPkts] = 1,\n\t\t[RTL8365MB_MIB_ifOutBroadcastPkts] = 1,\n\t\t[RTL8365MB_MIB_dot3OutPauseFrames] = 1,\n\t\t[RTL8365MB_MIB_ifOutDiscards] = 1,\n\t\t[RTL8365MB_MIB_ifInOctets] = 1,\n\t\t[RTL8365MB_MIB_ifInUcastPkts] = 1,\n\t\t[RTL8365MB_MIB_ifInMulticastPkts] = 1,\n\t\t[RTL8365MB_MIB_ifInBroadcastPkts] = 1,\n\t\t[RTL8365MB_MIB_dot3InPauseFrames] = 1,\n\t\t[RTL8365MB_MIB_dot3StatsSingleCollisionFrames] = 1,\n\t\t[RTL8365MB_MIB_dot3StatsMultipleCollisionFrames] = 1,\n\t\t[RTL8365MB_MIB_dot3StatsFCSErrors] = 1,\n\t\t[RTL8365MB_MIB_dot3StatsDeferredTransmissions] = 1,\n\t\t[RTL8365MB_MIB_dot3StatsLateCollisions] = 1,\n\t\t[RTL8365MB_MIB_dot3StatsExcessiveCollisions] = 1,\n\n\t};\n\tstruct realtek_priv *priv = ds->priv;\n\tstruct rtl8365mb *mb;\n\tint ret;\n\tint i;\n\n\tmb = priv->chip_data;\n\n\tmutex_lock(&mb->mib_lock);\n\tfor (i = 0; i < RTL8365MB_MIB_END; i++) {\n\t\tstruct rtl8365mb_mib_counter *mib = &rtl8365mb_mib_counters[i];\n\n\t\t \n\t\tif (!cnt[i])\n\t\t\tcontinue;\n\n\t\tret = rtl8365mb_mib_counter_read(priv, port, mib->offset,\n\t\t\t\t\t\t mib->length, &cnt[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&mb->mib_lock);\n\n\t \n\n\tmac_stats->FramesTransmittedOK = cnt[RTL8365MB_MIB_ifOutUcastPkts] +\n\t\t\t\t\t cnt[RTL8365MB_MIB_ifOutMulticastPkts] +\n\t\t\t\t\t cnt[RTL8365MB_MIB_ifOutBroadcastPkts] +\n\t\t\t\t\t cnt[RTL8365MB_MIB_dot3OutPauseFrames] -\n\t\t\t\t\t cnt[RTL8365MB_MIB_ifOutDiscards];\n\tmac_stats->SingleCollisionFrames =\n\t\tcnt[RTL8365MB_MIB_dot3StatsSingleCollisionFrames];\n\tmac_stats->MultipleCollisionFrames =\n\t\tcnt[RTL8365MB_MIB_dot3StatsMultipleCollisionFrames];\n\tmac_stats->FramesReceivedOK = cnt[RTL8365MB_MIB_ifInUcastPkts] +\n\t\t\t\t      cnt[RTL8365MB_MIB_ifInMulticastPkts] +\n\t\t\t\t      cnt[RTL8365MB_MIB_ifInBroadcastPkts] +\n\t\t\t\t      cnt[RTL8365MB_MIB_dot3InPauseFrames];\n\tmac_stats->FrameCheckSequenceErrors =\n\t\tcnt[RTL8365MB_MIB_dot3StatsFCSErrors];\n\tmac_stats->OctetsTransmittedOK = cnt[RTL8365MB_MIB_ifOutOctets] -\n\t\t\t\t\t 18 * mac_stats->FramesTransmittedOK;\n\tmac_stats->FramesWithDeferredXmissions =\n\t\tcnt[RTL8365MB_MIB_dot3StatsDeferredTransmissions];\n\tmac_stats->LateCollisions = cnt[RTL8365MB_MIB_dot3StatsLateCollisions];\n\tmac_stats->FramesAbortedDueToXSColls =\n\t\tcnt[RTL8365MB_MIB_dot3StatsExcessiveCollisions];\n\tmac_stats->OctetsReceivedOK = cnt[RTL8365MB_MIB_ifInOctets] -\n\t\t\t\t      18 * mac_stats->FramesReceivedOK;\n\tmac_stats->MulticastFramesXmittedOK =\n\t\tcnt[RTL8365MB_MIB_ifOutMulticastPkts];\n\tmac_stats->BroadcastFramesXmittedOK =\n\t\tcnt[RTL8365MB_MIB_ifOutBroadcastPkts];\n\tmac_stats->MulticastFramesReceivedOK =\n\t\tcnt[RTL8365MB_MIB_ifInMulticastPkts];\n\tmac_stats->BroadcastFramesReceivedOK =\n\t\tcnt[RTL8365MB_MIB_ifInBroadcastPkts];\n}\n\nstatic void rtl8365mb_get_ctrl_stats(struct dsa_switch *ds, int port,\n\t\t\t\t     struct ethtool_eth_ctrl_stats *ctrl_stats)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\tstruct rtl8365mb_mib_counter *mib;\n\tstruct rtl8365mb *mb;\n\n\tmb = priv->chip_data;\n\tmib = &rtl8365mb_mib_counters[RTL8365MB_MIB_dot3ControlInUnknownOpcodes];\n\n\tmutex_lock(&mb->mib_lock);\n\trtl8365mb_mib_counter_read(priv, port, mib->offset, mib->length,\n\t\t\t\t   &ctrl_stats->UnsupportedOpcodesReceived);\n\tmutex_unlock(&mb->mib_lock);\n}\n\nstatic void rtl8365mb_stats_update(struct realtek_priv *priv, int port)\n{\n\tu64 cnt[RTL8365MB_MIB_END] = {\n\t\t[RTL8365MB_MIB_ifOutOctets] = 1,\n\t\t[RTL8365MB_MIB_ifOutUcastPkts] = 1,\n\t\t[RTL8365MB_MIB_ifOutMulticastPkts] = 1,\n\t\t[RTL8365MB_MIB_ifOutBroadcastPkts] = 1,\n\t\t[RTL8365MB_MIB_ifOutDiscards] = 1,\n\t\t[RTL8365MB_MIB_ifInOctets] = 1,\n\t\t[RTL8365MB_MIB_ifInUcastPkts] = 1,\n\t\t[RTL8365MB_MIB_ifInMulticastPkts] = 1,\n\t\t[RTL8365MB_MIB_ifInBroadcastPkts] = 1,\n\t\t[RTL8365MB_MIB_etherStatsDropEvents] = 1,\n\t\t[RTL8365MB_MIB_etherStatsCollisions] = 1,\n\t\t[RTL8365MB_MIB_etherStatsFragments] = 1,\n\t\t[RTL8365MB_MIB_etherStatsJabbers] = 1,\n\t\t[RTL8365MB_MIB_dot3StatsFCSErrors] = 1,\n\t\t[RTL8365MB_MIB_dot3StatsLateCollisions] = 1,\n\t};\n\tstruct rtl8365mb *mb = priv->chip_data;\n\tstruct rtnl_link_stats64 *stats;\n\tint ret;\n\tint i;\n\n\tstats = &mb->ports[port].stats;\n\n\tmutex_lock(&mb->mib_lock);\n\tfor (i = 0; i < RTL8365MB_MIB_END; i++) {\n\t\tstruct rtl8365mb_mib_counter *c = &rtl8365mb_mib_counters[i];\n\n\t\t \n\t\tif (!cnt[i])\n\t\t\tcontinue;\n\n\t\tret = rtl8365mb_mib_counter_read(priv, port, c->offset,\n\t\t\t\t\t\t c->length, &cnt[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&mb->mib_lock);\n\n\t \n\tif (ret)\n\t\treturn;\n\n\tspin_lock(&mb->ports[port].stats_lock);\n\n\tstats->rx_packets = cnt[RTL8365MB_MIB_ifInUcastPkts] +\n\t\t\t    cnt[RTL8365MB_MIB_ifInMulticastPkts] +\n\t\t\t    cnt[RTL8365MB_MIB_ifInBroadcastPkts] -\n\t\t\t    cnt[RTL8365MB_MIB_ifOutDiscards];\n\n\tstats->tx_packets = cnt[RTL8365MB_MIB_ifOutUcastPkts] +\n\t\t\t    cnt[RTL8365MB_MIB_ifOutMulticastPkts] +\n\t\t\t    cnt[RTL8365MB_MIB_ifOutBroadcastPkts];\n\n\t \n\tstats->rx_bytes = cnt[RTL8365MB_MIB_ifInOctets] - 4 * stats->rx_packets;\n\tstats->tx_bytes =\n\t\tcnt[RTL8365MB_MIB_ifOutOctets] - 4 * stats->tx_packets;\n\n\tstats->rx_dropped = cnt[RTL8365MB_MIB_etherStatsDropEvents];\n\tstats->tx_dropped = cnt[RTL8365MB_MIB_ifOutDiscards];\n\n\tstats->multicast = cnt[RTL8365MB_MIB_ifInMulticastPkts];\n\tstats->collisions = cnt[RTL8365MB_MIB_etherStatsCollisions];\n\n\tstats->rx_length_errors = cnt[RTL8365MB_MIB_etherStatsFragments] +\n\t\t\t\t  cnt[RTL8365MB_MIB_etherStatsJabbers];\n\tstats->rx_crc_errors = cnt[RTL8365MB_MIB_dot3StatsFCSErrors];\n\tstats->rx_errors = stats->rx_length_errors + stats->rx_crc_errors;\n\n\tstats->tx_aborted_errors = cnt[RTL8365MB_MIB_ifOutDiscards];\n\tstats->tx_window_errors = cnt[RTL8365MB_MIB_dot3StatsLateCollisions];\n\tstats->tx_errors = stats->tx_aborted_errors + stats->tx_window_errors;\n\n\tspin_unlock(&mb->ports[port].stats_lock);\n}\n\nstatic void rtl8365mb_stats_poll(struct work_struct *work)\n{\n\tstruct rtl8365mb_port *p = container_of(to_delayed_work(work),\n\t\t\t\t\t\tstruct rtl8365mb_port,\n\t\t\t\t\t\tmib_work);\n\tstruct realtek_priv *priv = p->priv;\n\n\trtl8365mb_stats_update(priv, p->index);\n\n\tschedule_delayed_work(&p->mib_work, RTL8365MB_STATS_INTERVAL_JIFFIES);\n}\n\nstatic void rtl8365mb_get_stats64(struct dsa_switch *ds, int port,\n\t\t\t\t  struct rtnl_link_stats64 *s)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\tstruct rtl8365mb_port *p;\n\tstruct rtl8365mb *mb;\n\n\tmb = priv->chip_data;\n\tp = &mb->ports[port];\n\n\tspin_lock(&p->stats_lock);\n\tmemcpy(s, &p->stats, sizeof(*s));\n\tspin_unlock(&p->stats_lock);\n}\n\nstatic void rtl8365mb_stats_setup(struct realtek_priv *priv)\n{\n\tstruct rtl8365mb *mb = priv->chip_data;\n\tint i;\n\n\t \n\tmutex_init(&mb->mib_lock);\n\n\tfor (i = 0; i < priv->num_ports; i++) {\n\t\tstruct rtl8365mb_port *p = &mb->ports[i];\n\n\t\tif (dsa_is_unused_port(priv->ds, i))\n\t\t\tcontinue;\n\n\t\t \n\t\tspin_lock_init(&p->stats_lock);\n\n\t\t \n\t\tINIT_DELAYED_WORK(&p->mib_work, rtl8365mb_stats_poll);\n\t}\n}\n\nstatic void rtl8365mb_stats_teardown(struct realtek_priv *priv)\n{\n\tstruct rtl8365mb *mb = priv->chip_data;\n\tint i;\n\n\tfor (i = 0; i < priv->num_ports; i++) {\n\t\tstruct rtl8365mb_port *p = &mb->ports[i];\n\n\t\tif (dsa_is_unused_port(priv->ds, i))\n\t\t\tcontinue;\n\n\t\tcancel_delayed_work_sync(&p->mib_work);\n\t}\n}\n\nstatic int rtl8365mb_get_and_clear_status_reg(struct realtek_priv *priv, u32 reg,\n\t\t\t\t\t      u32 *val)\n{\n\tint ret;\n\n\tret = regmap_read(priv->map, reg, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_write(priv->map, reg, *val);\n}\n\nstatic irqreturn_t rtl8365mb_irq(int irq, void *data)\n{\n\tstruct realtek_priv *priv = data;\n\tunsigned long line_changes = 0;\n\tu32 stat;\n\tint line;\n\tint ret;\n\n\tret = rtl8365mb_get_and_clear_status_reg(priv, RTL8365MB_INTR_STATUS_REG,\n\t\t\t\t\t\t &stat);\n\tif (ret)\n\t\tgoto out_error;\n\n\tif (stat & RTL8365MB_INTR_LINK_CHANGE_MASK) {\n\t\tu32 linkdown_ind;\n\t\tu32 linkup_ind;\n\t\tu32 val;\n\n\t\tret = rtl8365mb_get_and_clear_status_reg(\n\t\t\tpriv, RTL8365MB_PORT_LINKUP_IND_REG, &val);\n\t\tif (ret)\n\t\t\tgoto out_error;\n\n\t\tlinkup_ind = FIELD_GET(RTL8365MB_PORT_LINKUP_IND_MASK, val);\n\n\t\tret = rtl8365mb_get_and_clear_status_reg(\n\t\t\tpriv, RTL8365MB_PORT_LINKDOWN_IND_REG, &val);\n\t\tif (ret)\n\t\t\tgoto out_error;\n\n\t\tlinkdown_ind = FIELD_GET(RTL8365MB_PORT_LINKDOWN_IND_MASK, val);\n\n\t\tline_changes = linkup_ind | linkdown_ind;\n\t}\n\n\tif (!line_changes)\n\t\tgoto out_none;\n\n\tfor_each_set_bit(line, &line_changes, priv->num_ports) {\n\t\tint child_irq = irq_find_mapping(priv->irqdomain, line);\n\n\t\thandle_nested_irq(child_irq);\n\t}\n\n\treturn IRQ_HANDLED;\n\nout_error:\n\tdev_err(priv->dev, \"failed to read interrupt status: %d\\n\", ret);\n\nout_none:\n\treturn IRQ_NONE;\n}\n\nstatic struct irq_chip rtl8365mb_irq_chip = {\n\t.name = \"rtl8365mb\",\n\t \n};\n\nstatic int rtl8365mb_irq_map(struct irq_domain *domain, unsigned int irq,\n\t\t\t     irq_hw_number_t hwirq)\n{\n\tirq_set_chip_data(irq, domain->host_data);\n\tirq_set_chip_and_handler(irq, &rtl8365mb_irq_chip, handle_simple_irq);\n\tirq_set_nested_thread(irq, 1);\n\tirq_set_noprobe(irq);\n\n\treturn 0;\n}\n\nstatic void rtl8365mb_irq_unmap(struct irq_domain *d, unsigned int irq)\n{\n\tirq_set_nested_thread(irq, 0);\n\tirq_set_chip_and_handler(irq, NULL, NULL);\n\tirq_set_chip_data(irq, NULL);\n}\n\nstatic const struct irq_domain_ops rtl8365mb_irqdomain_ops = {\n\t.map = rtl8365mb_irq_map,\n\t.unmap = rtl8365mb_irq_unmap,\n\t.xlate = irq_domain_xlate_onecell,\n};\n\nstatic int rtl8365mb_set_irq_enable(struct realtek_priv *priv, bool enable)\n{\n\treturn regmap_update_bits(priv->map, RTL8365MB_INTR_CTRL_REG,\n\t\t\t\t  RTL8365MB_INTR_LINK_CHANGE_MASK,\n\t\t\t\t  FIELD_PREP(RTL8365MB_INTR_LINK_CHANGE_MASK,\n\t\t\t\t\t     enable ? 1 : 0));\n}\n\nstatic int rtl8365mb_irq_enable(struct realtek_priv *priv)\n{\n\treturn rtl8365mb_set_irq_enable(priv, true);\n}\n\nstatic int rtl8365mb_irq_disable(struct realtek_priv *priv)\n{\n\treturn rtl8365mb_set_irq_enable(priv, false);\n}\n\nstatic int rtl8365mb_irq_setup(struct realtek_priv *priv)\n{\n\tstruct rtl8365mb *mb = priv->chip_data;\n\tstruct device_node *intc;\n\tu32 irq_trig;\n\tint virq;\n\tint irq;\n\tu32 val;\n\tint ret;\n\tint i;\n\n\tintc = of_get_child_by_name(priv->dev->of_node, \"interrupt-controller\");\n\tif (!intc) {\n\t\tdev_err(priv->dev, \"missing child interrupt-controller node\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tirq = of_irq_get(intc, 0);\n\tif (irq <= 0) {\n\t\tif (irq != -EPROBE_DEFER)\n\t\t\tdev_err(priv->dev, \"failed to get parent irq: %d\\n\",\n\t\t\t\tirq);\n\t\tret = irq ? irq : -EINVAL;\n\t\tgoto out_put_node;\n\t}\n\n\tpriv->irqdomain = irq_domain_add_linear(intc, priv->num_ports,\n\t\t\t\t\t\t&rtl8365mb_irqdomain_ops, priv);\n\tif (!priv->irqdomain) {\n\t\tdev_err(priv->dev, \"failed to add irq domain\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_put_node;\n\t}\n\n\tfor (i = 0; i < priv->num_ports; i++) {\n\t\tvirq = irq_create_mapping(priv->irqdomain, i);\n\t\tif (!virq) {\n\t\t\tdev_err(priv->dev,\n\t\t\t\t\"failed to create irq domain mapping\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_remove_irqdomain;\n\t\t}\n\n\t\tirq_set_parent(virq, irq);\n\t}\n\n\t \n\tirq_trig = irqd_get_trigger_type(irq_get_irq_data(irq));\n\tswitch (irq_trig) {\n\tcase IRQF_TRIGGER_RISING:\n\tcase IRQF_TRIGGER_HIGH:\n\t\tval = RTL8365MB_INTR_POLARITY_HIGH;\n\t\tbreak;\n\tcase IRQF_TRIGGER_FALLING:\n\tcase IRQF_TRIGGER_LOW:\n\t\tval = RTL8365MB_INTR_POLARITY_LOW;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(priv->dev, \"unsupported irq trigger type %u\\n\",\n\t\t\tirq_trig);\n\t\tret = -EINVAL;\n\t\tgoto out_remove_irqdomain;\n\t}\n\n\tret = regmap_update_bits(priv->map, RTL8365MB_INTR_POLARITY_REG,\n\t\t\t\t RTL8365MB_INTR_POLARITY_MASK,\n\t\t\t\t FIELD_PREP(RTL8365MB_INTR_POLARITY_MASK, val));\n\tif (ret)\n\t\tgoto out_remove_irqdomain;\n\n\t \n\tret = rtl8365mb_irq_disable(priv);\n\tif (ret)\n\t\tgoto out_remove_irqdomain;\n\n\t \n\tret = regmap_write(priv->map, RTL8365MB_INTR_STATUS_REG,\n\t\t\t   RTL8365MB_INTR_ALL_MASK);\n\tif (ret)\n\t\tgoto out_remove_irqdomain;\n\n\tret = request_threaded_irq(irq, NULL, rtl8365mb_irq, IRQF_ONESHOT,\n\t\t\t\t   \"rtl8365mb\", priv);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"failed to request irq: %d\\n\", ret);\n\t\tgoto out_remove_irqdomain;\n\t}\n\n\t \n\tmb->irq = irq;\n\n\tret = rtl8365mb_irq_enable(priv);\n\tif (ret)\n\t\tgoto out_free_irq;\n\n\tof_node_put(intc);\n\n\treturn 0;\n\nout_free_irq:\n\tfree_irq(mb->irq, priv);\n\tmb->irq = 0;\n\nout_remove_irqdomain:\n\tfor (i = 0; i < priv->num_ports; i++) {\n\t\tvirq = irq_find_mapping(priv->irqdomain, i);\n\t\tirq_dispose_mapping(virq);\n\t}\n\n\tirq_domain_remove(priv->irqdomain);\n\tpriv->irqdomain = NULL;\n\nout_put_node:\n\tof_node_put(intc);\n\n\treturn ret;\n}\n\nstatic void rtl8365mb_irq_teardown(struct realtek_priv *priv)\n{\n\tstruct rtl8365mb *mb = priv->chip_data;\n\tint virq;\n\tint i;\n\n\tif (mb->irq) {\n\t\tfree_irq(mb->irq, priv);\n\t\tmb->irq = 0;\n\t}\n\n\tif (priv->irqdomain) {\n\t\tfor (i = 0; i < priv->num_ports; i++) {\n\t\t\tvirq = irq_find_mapping(priv->irqdomain, i);\n\t\t\tirq_dispose_mapping(virq);\n\t\t}\n\n\t\tirq_domain_remove(priv->irqdomain);\n\t\tpriv->irqdomain = NULL;\n\t}\n}\n\nstatic int rtl8365mb_cpu_config(struct realtek_priv *priv)\n{\n\tstruct rtl8365mb *mb = priv->chip_data;\n\tstruct rtl8365mb_cpu *cpu = &mb->cpu;\n\tu32 val;\n\tint ret;\n\n\tret = regmap_update_bits(priv->map, RTL8365MB_CPU_PORT_MASK_REG,\n\t\t\t\t RTL8365MB_CPU_PORT_MASK_MASK,\n\t\t\t\t FIELD_PREP(RTL8365MB_CPU_PORT_MASK_MASK,\n\t\t\t\t\t    cpu->mask));\n\tif (ret)\n\t\treturn ret;\n\n\tval = FIELD_PREP(RTL8365MB_CPU_CTRL_EN_MASK, cpu->enable ? 1 : 0) |\n\t      FIELD_PREP(RTL8365MB_CPU_CTRL_INSERTMODE_MASK, cpu->insert) |\n\t      FIELD_PREP(RTL8365MB_CPU_CTRL_TAG_POSITION_MASK, cpu->position) |\n\t      FIELD_PREP(RTL8365MB_CPU_CTRL_RXBYTECOUNT_MASK, cpu->rx_length) |\n\t      FIELD_PREP(RTL8365MB_CPU_CTRL_TAG_FORMAT_MASK, cpu->format) |\n\t      FIELD_PREP(RTL8365MB_CPU_CTRL_TRAP_PORT_MASK, cpu->trap_port & 0x7) |\n\t      FIELD_PREP(RTL8365MB_CPU_CTRL_TRAP_PORT_EXT_MASK,\n\t\t\t cpu->trap_port >> 3 & 0x1);\n\tret = regmap_write(priv->map, RTL8365MB_CPU_CTRL_REG, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int rtl8365mb_change_tag_protocol(struct dsa_switch *ds,\n\t\t\t\t\t enum dsa_tag_protocol proto)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\tstruct rtl8365mb_cpu *cpu;\n\tstruct rtl8365mb *mb;\n\n\tmb = priv->chip_data;\n\tcpu = &mb->cpu;\n\n\tswitch (proto) {\n\tcase DSA_TAG_PROTO_RTL8_4:\n\t\tcpu->format = RTL8365MB_CPU_FORMAT_8BYTES;\n\t\tcpu->position = RTL8365MB_CPU_POS_AFTER_SA;\n\t\tbreak;\n\tcase DSA_TAG_PROTO_RTL8_4T:\n\t\tcpu->format = RTL8365MB_CPU_FORMAT_8BYTES;\n\t\tcpu->position = RTL8365MB_CPU_POS_BEFORE_CRC;\n\t\tbreak;\n\t \n\tdefault:\n\t\treturn -EPROTONOSUPPORT;\n\t}\n\n\treturn rtl8365mb_cpu_config(priv);\n}\n\nstatic int rtl8365mb_switch_init(struct realtek_priv *priv)\n{\n\tstruct rtl8365mb *mb = priv->chip_data;\n\tconst struct rtl8365mb_chip_info *ci;\n\tint ret;\n\tint i;\n\n\tci = mb->chip_info;\n\n\t \n\tif (ci->jam_table) {\n\t\tfor (i = 0; i < ci->jam_size; i++) {\n\t\t\tret = regmap_write(priv->map, ci->jam_table[i].reg,\n\t\t\t\t\t   ci->jam_table[i].val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(rtl8365mb_init_jam_common); i++) {\n\t\tret = regmap_write(priv->map, rtl8365mb_init_jam_common[i].reg,\n\t\t\t\t   rtl8365mb_init_jam_common[i].val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtl8365mb_reset_chip(struct realtek_priv *priv)\n{\n\tu32 val;\n\n\tpriv->write_reg_noack(priv, RTL8365MB_CHIP_RESET_REG,\n\t\t\t      FIELD_PREP(RTL8365MB_CHIP_RESET_HW_MASK, 1));\n\n\t \n\tmsleep(100);\n\treturn regmap_read_poll_timeout(priv->map, RTL8365MB_CHIP_RESET_REG, val,\n\t\t\t\t\t!(val & RTL8365MB_CHIP_RESET_HW_MASK),\n\t\t\t\t\t20000, 1e6);\n}\n\nstatic int rtl8365mb_setup(struct dsa_switch *ds)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\tstruct rtl8365mb_cpu *cpu;\n\tstruct dsa_port *cpu_dp;\n\tstruct rtl8365mb *mb;\n\tint ret;\n\tint i;\n\n\tmb = priv->chip_data;\n\tcpu = &mb->cpu;\n\n\tret = rtl8365mb_reset_chip(priv);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"failed to reset chip: %d\\n\", ret);\n\t\tgoto out_error;\n\t}\n\n\t \n\tret = rtl8365mb_switch_init(priv);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"failed to initialize switch: %d\\n\", ret);\n\t\tgoto out_error;\n\t}\n\n\t \n\tret = rtl8365mb_irq_setup(priv);\n\tif (ret == -EPROBE_DEFER)\n\t\treturn ret;\n\telse if (ret)\n\t\tdev_info(priv->dev, \"no interrupt support\\n\");\n\n\t \n\tdsa_switch_for_each_cpu_port(cpu_dp, priv->ds) {\n\t\tcpu->mask |= BIT(cpu_dp->index);\n\n\t\tif (cpu->trap_port == RTL8365MB_MAX_NUM_PORTS)\n\t\t\tcpu->trap_port = cpu_dp->index;\n\t}\n\tcpu->enable = cpu->mask > 0;\n\tret = rtl8365mb_cpu_config(priv);\n\tif (ret)\n\t\tgoto out_teardown_irq;\n\n\t \n\tfor (i = 0; i < priv->num_ports; i++) {\n\t\tstruct rtl8365mb_port *p = &mb->ports[i];\n\n\t\tif (dsa_is_unused_port(priv->ds, i))\n\t\t\tcontinue;\n\n\t\t \n\t\tret = rtl8365mb_port_set_isolation(priv, i, cpu->mask);\n\t\tif (ret)\n\t\t\tgoto out_teardown_irq;\n\n\t\t \n\t\tret = rtl8365mb_port_set_learning(priv, i, false);\n\t\tif (ret)\n\t\t\tgoto out_teardown_irq;\n\n\t\t \n\t\trtl8365mb_port_stp_state_set(priv->ds, i, BR_STATE_DISABLED);\n\n\t\t \n\t\tp->priv = priv;\n\t\tp->index = i;\n\t}\n\n\tret = rtl8365mb_port_change_mtu(ds, cpu->trap_port, ETH_DATA_LEN);\n\tif (ret)\n\t\tgoto out_teardown_irq;\n\n\tif (priv->setup_interface) {\n\t\tret = priv->setup_interface(ds);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"could not set up MDIO bus\\n\");\n\t\t\tgoto out_teardown_irq;\n\t\t}\n\t}\n\n\t \n\trtl8365mb_stats_setup(priv);\n\n\treturn 0;\n\nout_teardown_irq:\n\trtl8365mb_irq_teardown(priv);\n\nout_error:\n\treturn ret;\n}\n\nstatic void rtl8365mb_teardown(struct dsa_switch *ds)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\n\trtl8365mb_stats_teardown(priv);\n\trtl8365mb_irq_teardown(priv);\n}\n\nstatic int rtl8365mb_get_chip_id_and_ver(struct regmap *map, u32 *id, u32 *ver)\n{\n\tint ret;\n\n\t \n\tret = regmap_write(map, RTL8365MB_MAGIC_REG, RTL8365MB_MAGIC_VALUE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(map, RTL8365MB_CHIP_ID_REG, id);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(map, RTL8365MB_CHIP_VER_REG, ver);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(map, RTL8365MB_MAGIC_REG, 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int rtl8365mb_detect(struct realtek_priv *priv)\n{\n\tstruct rtl8365mb *mb = priv->chip_data;\n\tu32 chip_id;\n\tu32 chip_ver;\n\tint ret;\n\tint i;\n\n\tret = rtl8365mb_get_chip_id_and_ver(priv->map, &chip_id, &chip_ver);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"failed to read chip id and version: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(rtl8365mb_chip_infos); i++) {\n\t\tconst struct rtl8365mb_chip_info *ci = &rtl8365mb_chip_infos[i];\n\n\t\tif (ci->chip_id == chip_id && ci->chip_ver == chip_ver) {\n\t\t\tmb->chip_info = ci;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!mb->chip_info) {\n\t\tdev_err(priv->dev,\n\t\t\t\"unrecognized switch (id=0x%04x, ver=0x%04x)\", chip_id,\n\t\t\tchip_ver);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(priv->dev, \"found an %s switch\\n\", mb->chip_info->name);\n\n\tpriv->num_ports = RTL8365MB_MAX_NUM_PORTS;\n\tmb->priv = priv;\n\tmb->cpu.trap_port = RTL8365MB_MAX_NUM_PORTS;\n\tmb->cpu.insert = RTL8365MB_CPU_INSERT_TO_ALL;\n\tmb->cpu.position = RTL8365MB_CPU_POS_AFTER_SA;\n\tmb->cpu.rx_length = RTL8365MB_CPU_RXLEN_64BYTES;\n\tmb->cpu.format = RTL8365MB_CPU_FORMAT_8BYTES;\n\n\treturn 0;\n}\n\nstatic const struct dsa_switch_ops rtl8365mb_switch_ops_smi = {\n\t.get_tag_protocol = rtl8365mb_get_tag_protocol,\n\t.change_tag_protocol = rtl8365mb_change_tag_protocol,\n\t.setup = rtl8365mb_setup,\n\t.teardown = rtl8365mb_teardown,\n\t.phylink_get_caps = rtl8365mb_phylink_get_caps,\n\t.phylink_mac_config = rtl8365mb_phylink_mac_config,\n\t.phylink_mac_link_down = rtl8365mb_phylink_mac_link_down,\n\t.phylink_mac_link_up = rtl8365mb_phylink_mac_link_up,\n\t.port_stp_state_set = rtl8365mb_port_stp_state_set,\n\t.get_strings = rtl8365mb_get_strings,\n\t.get_ethtool_stats = rtl8365mb_get_ethtool_stats,\n\t.get_sset_count = rtl8365mb_get_sset_count,\n\t.get_eth_phy_stats = rtl8365mb_get_phy_stats,\n\t.get_eth_mac_stats = rtl8365mb_get_mac_stats,\n\t.get_eth_ctrl_stats = rtl8365mb_get_ctrl_stats,\n\t.get_stats64 = rtl8365mb_get_stats64,\n\t.port_change_mtu = rtl8365mb_port_change_mtu,\n\t.port_max_mtu = rtl8365mb_port_max_mtu,\n};\n\nstatic const struct dsa_switch_ops rtl8365mb_switch_ops_mdio = {\n\t.get_tag_protocol = rtl8365mb_get_tag_protocol,\n\t.change_tag_protocol = rtl8365mb_change_tag_protocol,\n\t.setup = rtl8365mb_setup,\n\t.teardown = rtl8365mb_teardown,\n\t.phylink_get_caps = rtl8365mb_phylink_get_caps,\n\t.phylink_mac_config = rtl8365mb_phylink_mac_config,\n\t.phylink_mac_link_down = rtl8365mb_phylink_mac_link_down,\n\t.phylink_mac_link_up = rtl8365mb_phylink_mac_link_up,\n\t.phy_read = rtl8365mb_dsa_phy_read,\n\t.phy_write = rtl8365mb_dsa_phy_write,\n\t.port_stp_state_set = rtl8365mb_port_stp_state_set,\n\t.get_strings = rtl8365mb_get_strings,\n\t.get_ethtool_stats = rtl8365mb_get_ethtool_stats,\n\t.get_sset_count = rtl8365mb_get_sset_count,\n\t.get_eth_phy_stats = rtl8365mb_get_phy_stats,\n\t.get_eth_mac_stats = rtl8365mb_get_mac_stats,\n\t.get_eth_ctrl_stats = rtl8365mb_get_ctrl_stats,\n\t.get_stats64 = rtl8365mb_get_stats64,\n\t.port_change_mtu = rtl8365mb_port_change_mtu,\n\t.port_max_mtu = rtl8365mb_port_max_mtu,\n};\n\nstatic const struct realtek_ops rtl8365mb_ops = {\n\t.detect = rtl8365mb_detect,\n\t.phy_read = rtl8365mb_phy_read,\n\t.phy_write = rtl8365mb_phy_write,\n};\n\nconst struct realtek_variant rtl8365mb_variant = {\n\t.ds_ops_smi = &rtl8365mb_switch_ops_smi,\n\t.ds_ops_mdio = &rtl8365mb_switch_ops_mdio,\n\t.ops = &rtl8365mb_ops,\n\t.clk_delay = 10,\n\t.cmd_read = 0xb9,\n\t.cmd_write = 0xb8,\n\t.chip_data_sz = sizeof(struct rtl8365mb),\n};\nEXPORT_SYMBOL_GPL(rtl8365mb_variant);\n\nMODULE_AUTHOR(\"Alvin \u0160ipraga <alsi@bang-olufsen.dk>\");\nMODULE_DESCRIPTION(\"Driver for RTL8365MB-VC ethernet switch\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}