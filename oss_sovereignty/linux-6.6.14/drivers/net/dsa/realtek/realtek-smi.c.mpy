{
  "module_name": "realtek-smi.c",
  "hash_id": "179b7995a5d8ea3ce026809762d244b6196e1da9af2d92cc0e8f0e69e9bd247c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/realtek/realtek-smi.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/spinlock.h>\n#include <linux/skbuff.h>\n#include <linux/of.h>\n#include <linux/of_mdio.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/bitops.h>\n#include <linux/if_bridge.h>\n\n#include \"realtek.h\"\n\n#define REALTEK_SMI_ACK_RETRY_COUNT\t\t5\n\nstatic inline void realtek_smi_clk_delay(struct realtek_priv *priv)\n{\n\tndelay(priv->clk_delay);\n}\n\nstatic void realtek_smi_start(struct realtek_priv *priv)\n{\n\t \n\tgpiod_direction_output(priv->mdc, 0);\n\tgpiod_direction_output(priv->mdio, 1);\n\trealtek_smi_clk_delay(priv);\n\n\t \n\tgpiod_set_value(priv->mdc, 1);\n\trealtek_smi_clk_delay(priv);\n\tgpiod_set_value(priv->mdc, 0);\n\trealtek_smi_clk_delay(priv);\n\n\t \n\tgpiod_set_value(priv->mdc, 1);\n\trealtek_smi_clk_delay(priv);\n\tgpiod_set_value(priv->mdio, 0);\n\trealtek_smi_clk_delay(priv);\n\tgpiod_set_value(priv->mdc, 0);\n\trealtek_smi_clk_delay(priv);\n\tgpiod_set_value(priv->mdio, 1);\n}\n\nstatic void realtek_smi_stop(struct realtek_priv *priv)\n{\n\trealtek_smi_clk_delay(priv);\n\tgpiod_set_value(priv->mdio, 0);\n\tgpiod_set_value(priv->mdc, 1);\n\trealtek_smi_clk_delay(priv);\n\tgpiod_set_value(priv->mdio, 1);\n\trealtek_smi_clk_delay(priv);\n\tgpiod_set_value(priv->mdc, 1);\n\trealtek_smi_clk_delay(priv);\n\tgpiod_set_value(priv->mdc, 0);\n\trealtek_smi_clk_delay(priv);\n\tgpiod_set_value(priv->mdc, 1);\n\n\t \n\trealtek_smi_clk_delay(priv);\n\tgpiod_set_value(priv->mdc, 0);\n\trealtek_smi_clk_delay(priv);\n\tgpiod_set_value(priv->mdc, 1);\n\n\t \n\tgpiod_direction_input(priv->mdio);\n\tgpiod_direction_input(priv->mdc);\n}\n\nstatic void realtek_smi_write_bits(struct realtek_priv *priv, u32 data, u32 len)\n{\n\tfor (; len > 0; len--) {\n\t\trealtek_smi_clk_delay(priv);\n\n\t\t \n\t\tgpiod_set_value(priv->mdio, !!(data & (1 << (len - 1))));\n\t\trealtek_smi_clk_delay(priv);\n\n\t\t \n\t\tgpiod_set_value(priv->mdc, 1);\n\t\trealtek_smi_clk_delay(priv);\n\t\tgpiod_set_value(priv->mdc, 0);\n\t}\n}\n\nstatic void realtek_smi_read_bits(struct realtek_priv *priv, u32 len, u32 *data)\n{\n\tgpiod_direction_input(priv->mdio);\n\n\tfor (*data = 0; len > 0; len--) {\n\t\tu32 u;\n\n\t\trealtek_smi_clk_delay(priv);\n\n\t\t \n\t\tgpiod_set_value(priv->mdc, 1);\n\t\trealtek_smi_clk_delay(priv);\n\t\tu = !!gpiod_get_value(priv->mdio);\n\t\tgpiod_set_value(priv->mdc, 0);\n\n\t\t*data |= (u << (len - 1));\n\t}\n\n\tgpiod_direction_output(priv->mdio, 0);\n}\n\nstatic int realtek_smi_wait_for_ack(struct realtek_priv *priv)\n{\n\tint retry_cnt;\n\n\tretry_cnt = 0;\n\tdo {\n\t\tu32 ack;\n\n\t\trealtek_smi_read_bits(priv, 1, &ack);\n\t\tif (ack == 0)\n\t\t\tbreak;\n\n\t\tif (++retry_cnt > REALTEK_SMI_ACK_RETRY_COUNT) {\n\t\t\tdev_err(priv->dev, \"ACK timeout\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t} while (1);\n\n\treturn 0;\n}\n\nstatic int realtek_smi_write_byte(struct realtek_priv *priv, u8 data)\n{\n\trealtek_smi_write_bits(priv, data, 8);\n\treturn realtek_smi_wait_for_ack(priv);\n}\n\nstatic int realtek_smi_write_byte_noack(struct realtek_priv *priv, u8 data)\n{\n\trealtek_smi_write_bits(priv, data, 8);\n\treturn 0;\n}\n\nstatic int realtek_smi_read_byte0(struct realtek_priv *priv, u8 *data)\n{\n\tu32 t;\n\n\t \n\trealtek_smi_read_bits(priv, 8, &t);\n\t*data = (t & 0xff);\n\n\t \n\trealtek_smi_write_bits(priv, 0x00, 1);\n\n\treturn 0;\n}\n\nstatic int realtek_smi_read_byte1(struct realtek_priv *priv, u8 *data)\n{\n\tu32 t;\n\n\t \n\trealtek_smi_read_bits(priv, 8, &t);\n\t*data = (t & 0xff);\n\n\t \n\trealtek_smi_write_bits(priv, 0x01, 1);\n\n\treturn 0;\n}\n\nstatic int realtek_smi_read_reg(struct realtek_priv *priv, u32 addr, u32 *data)\n{\n\tunsigned long flags;\n\tu8 lo = 0;\n\tu8 hi = 0;\n\tint ret;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\trealtek_smi_start(priv);\n\n\t \n\tret = realtek_smi_write_byte(priv, priv->cmd_read);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = realtek_smi_write_byte(priv, addr & 0xff);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = realtek_smi_write_byte(priv, addr >> 8);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\trealtek_smi_read_byte0(priv, &lo);\n\t \n\trealtek_smi_read_byte1(priv, &hi);\n\n\t*data = ((u32)lo) | (((u32)hi) << 8);\n\n\tret = 0;\n\n out:\n\trealtek_smi_stop(priv);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn ret;\n}\n\nstatic int realtek_smi_write_reg(struct realtek_priv *priv,\n\t\t\t\t u32 addr, u32 data, bool ack)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\trealtek_smi_start(priv);\n\n\t \n\tret = realtek_smi_write_byte(priv, priv->cmd_write);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = realtek_smi_write_byte(priv, addr & 0xff);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = realtek_smi_write_byte(priv, addr >> 8);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = realtek_smi_write_byte(priv, data & 0xff);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (ack)\n\t\tret = realtek_smi_write_byte(priv, data >> 8);\n\telse\n\t\tret = realtek_smi_write_byte_noack(priv, data >> 8);\n\tif (ret)\n\t\tgoto out;\n\n\tret = 0;\n\n out:\n\trealtek_smi_stop(priv);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn ret;\n}\n\n \nstatic int realtek_smi_write_reg_noack(void *ctx, u32 reg, u32 val)\n{\n\treturn realtek_smi_write_reg(ctx, reg, val, false);\n}\n\n \n\nstatic int realtek_smi_write(void *ctx, u32 reg, u32 val)\n{\n\tstruct realtek_priv *priv = ctx;\n\n\treturn realtek_smi_write_reg(priv, reg, val, true);\n}\n\nstatic int realtek_smi_read(void *ctx, u32 reg, u32 *val)\n{\n\tstruct realtek_priv *priv = ctx;\n\n\treturn realtek_smi_read_reg(priv, reg, val);\n}\n\nstatic void realtek_smi_lock(void *ctx)\n{\n\tstruct realtek_priv *priv = ctx;\n\n\tmutex_lock(&priv->map_lock);\n}\n\nstatic void realtek_smi_unlock(void *ctx)\n{\n\tstruct realtek_priv *priv = ctx;\n\n\tmutex_unlock(&priv->map_lock);\n}\n\nstatic const struct regmap_config realtek_smi_regmap_config = {\n\t.reg_bits = 10,  \n\t.val_bits = 16,\n\t.reg_stride = 1,\n\t \n\t.max_register = 0xffff,\n\t.reg_format_endian = REGMAP_ENDIAN_BIG,\n\t.reg_read = realtek_smi_read,\n\t.reg_write = realtek_smi_write,\n\t.cache_type = REGCACHE_NONE,\n\t.lock = realtek_smi_lock,\n\t.unlock = realtek_smi_unlock,\n};\n\nstatic const struct regmap_config realtek_smi_nolock_regmap_config = {\n\t.reg_bits = 10,  \n\t.val_bits = 16,\n\t.reg_stride = 1,\n\t \n\t.max_register = 0xffff,\n\t.reg_format_endian = REGMAP_ENDIAN_BIG,\n\t.reg_read = realtek_smi_read,\n\t.reg_write = realtek_smi_write,\n\t.cache_type = REGCACHE_NONE,\n\t.disable_locking = true,\n};\n\nstatic int realtek_smi_mdio_read(struct mii_bus *bus, int addr, int regnum)\n{\n\tstruct realtek_priv *priv = bus->priv;\n\n\treturn priv->ops->phy_read(priv, addr, regnum);\n}\n\nstatic int realtek_smi_mdio_write(struct mii_bus *bus, int addr, int regnum,\n\t\t\t\t  u16 val)\n{\n\tstruct realtek_priv *priv = bus->priv;\n\n\treturn priv->ops->phy_write(priv, addr, regnum, val);\n}\n\nstatic int realtek_smi_setup_mdio(struct dsa_switch *ds)\n{\n\tstruct realtek_priv *priv =  ds->priv;\n\tstruct device_node *mdio_np;\n\tint ret;\n\n\tmdio_np = of_get_compatible_child(priv->dev->of_node, \"realtek,smi-mdio\");\n\tif (!mdio_np) {\n\t\tdev_err(priv->dev, \"no MDIO bus node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv->slave_mii_bus = devm_mdiobus_alloc(priv->dev);\n\tif (!priv->slave_mii_bus) {\n\t\tret = -ENOMEM;\n\t\tgoto err_put_node;\n\t}\n\tpriv->slave_mii_bus->priv = priv;\n\tpriv->slave_mii_bus->name = \"SMI slave MII\";\n\tpriv->slave_mii_bus->read = realtek_smi_mdio_read;\n\tpriv->slave_mii_bus->write = realtek_smi_mdio_write;\n\tsnprintf(priv->slave_mii_bus->id, MII_BUS_ID_SIZE, \"SMI-%d\",\n\t\t ds->index);\n\tpriv->slave_mii_bus->dev.of_node = mdio_np;\n\tpriv->slave_mii_bus->parent = priv->dev;\n\tds->slave_mii_bus = priv->slave_mii_bus;\n\n\tret = devm_of_mdiobus_register(priv->dev, priv->slave_mii_bus, mdio_np);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"unable to register MDIO bus %s\\n\",\n\t\t\tpriv->slave_mii_bus->id);\n\t\tgoto err_put_node;\n\t}\n\n\treturn 0;\n\nerr_put_node:\n\tof_node_put(mdio_np);\n\n\treturn ret;\n}\n\nstatic int realtek_smi_probe(struct platform_device *pdev)\n{\n\tconst struct realtek_variant *var;\n\tstruct device *dev = &pdev->dev;\n\tstruct realtek_priv *priv;\n\tstruct regmap_config rc;\n\tstruct device_node *np;\n\tint ret;\n\n\tvar = of_device_get_match_data(dev);\n\tnp = dev->of_node;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv) + var->chip_data_sz, GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tpriv->chip_data = (void *)priv + sizeof(*priv);\n\n\tmutex_init(&priv->map_lock);\n\n\trc = realtek_smi_regmap_config;\n\trc.lock_arg = priv;\n\tpriv->map = devm_regmap_init(dev, NULL, priv, &rc);\n\tif (IS_ERR(priv->map)) {\n\t\tret = PTR_ERR(priv->map);\n\t\tdev_err(dev, \"regmap init failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trc = realtek_smi_nolock_regmap_config;\n\tpriv->map_nolock = devm_regmap_init(dev, NULL, priv, &rc);\n\tif (IS_ERR(priv->map_nolock)) {\n\t\tret = PTR_ERR(priv->map_nolock);\n\t\tdev_err(dev, \"regmap init failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tpriv->dev = dev;\n\tpriv->clk_delay = var->clk_delay;\n\tpriv->cmd_read = var->cmd_read;\n\tpriv->cmd_write = var->cmd_write;\n\tpriv->ops = var->ops;\n\n\tpriv->setup_interface = realtek_smi_setup_mdio;\n\tpriv->write_reg_noack = realtek_smi_write_reg_noack;\n\n\tdev_set_drvdata(dev, priv);\n\tspin_lock_init(&priv->lock);\n\n\t \n\n\tpriv->reset = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->reset)) {\n\t\tdev_err(dev, \"failed to get RESET GPIO\\n\");\n\t\treturn PTR_ERR(priv->reset);\n\t}\n\tif (priv->reset) {\n\t\tgpiod_set_value(priv->reset, 1);\n\t\tdev_dbg(dev, \"asserted RESET\\n\");\n\t\tmsleep(REALTEK_HW_STOP_DELAY);\n\t\tgpiod_set_value(priv->reset, 0);\n\t\tmsleep(REALTEK_HW_START_DELAY);\n\t\tdev_dbg(dev, \"deasserted RESET\\n\");\n\t}\n\n\t \n\tpriv->mdc = devm_gpiod_get_optional(dev, \"mdc\", GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->mdc))\n\t\treturn PTR_ERR(priv->mdc);\n\tpriv->mdio = devm_gpiod_get_optional(dev, \"mdio\", GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->mdio))\n\t\treturn PTR_ERR(priv->mdio);\n\n\tpriv->leds_disabled = of_property_read_bool(np, \"realtek,disable-leds\");\n\n\tret = priv->ops->detect(priv);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to detect switch\\n\");\n\t\treturn ret;\n\t}\n\n\tpriv->ds = devm_kzalloc(dev, sizeof(*priv->ds), GFP_KERNEL);\n\tif (!priv->ds)\n\t\treturn -ENOMEM;\n\n\tpriv->ds->dev = dev;\n\tpriv->ds->num_ports = priv->num_ports;\n\tpriv->ds->priv = priv;\n\n\tpriv->ds->ops = var->ds_ops_smi;\n\tret = dsa_register_switch(priv->ds);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"unable to register switch\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int realtek_smi_remove(struct platform_device *pdev)\n{\n\tstruct realtek_priv *priv = platform_get_drvdata(pdev);\n\n\tif (!priv)\n\t\treturn 0;\n\n\tdsa_unregister_switch(priv->ds);\n\tif (priv->slave_mii_bus)\n\t\tof_node_put(priv->slave_mii_bus->dev.of_node);\n\n\t \n\tif (priv->reset)\n\t\tgpiod_set_value(priv->reset, 1);\n\n\treturn 0;\n}\n\nstatic void realtek_smi_shutdown(struct platform_device *pdev)\n{\n\tstruct realtek_priv *priv = platform_get_drvdata(pdev);\n\n\tif (!priv)\n\t\treturn;\n\n\tdsa_switch_shutdown(priv->ds);\n\n\tplatform_set_drvdata(pdev, NULL);\n}\n\nstatic const struct of_device_id realtek_smi_of_match[] = {\n#if IS_ENABLED(CONFIG_NET_DSA_REALTEK_RTL8366RB)\n\t{\n\t\t.compatible = \"realtek,rtl8366rb\",\n\t\t.data = &rtl8366rb_variant,\n\t},\n#endif\n#if IS_ENABLED(CONFIG_NET_DSA_REALTEK_RTL8365MB)\n\t{\n\t\t.compatible = \"realtek,rtl8365mb\",\n\t\t.data = &rtl8365mb_variant,\n\t},\n#endif\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, realtek_smi_of_match);\n\nstatic struct platform_driver realtek_smi_driver = {\n\t.driver = {\n\t\t.name = \"realtek-smi\",\n\t\t.of_match_table = realtek_smi_of_match,\n\t},\n\t.probe  = realtek_smi_probe,\n\t.remove = realtek_smi_remove,\n\t.shutdown = realtek_smi_shutdown,\n};\nmodule_platform_driver(realtek_smi_driver);\n\nMODULE_AUTHOR(\"Linus Walleij <linus.walleij@linaro.org>\");\nMODULE_DESCRIPTION(\"Driver for Realtek ethernet switch connected via SMI interface\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}