{
  "module_name": "realtek-mdio.c",
  "hash_id": "0a979fb0869f74debc814eb19ce26b59e2a3229de4061558cdbcb7077b43ac27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/realtek/realtek-mdio.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/overflow.h>\n#include <linux/regmap.h>\n\n#include \"realtek.h\"\n\n \n#define REALTEK_MDIO_CTRL0_REG\t\t31\n#define REALTEK_MDIO_START_REG\t\t29\n#define REALTEK_MDIO_CTRL1_REG\t\t21\n#define REALTEK_MDIO_ADDRESS_REG\t23\n#define REALTEK_MDIO_DATA_WRITE_REG\t24\n#define REALTEK_MDIO_DATA_READ_REG\t25\n\n#define REALTEK_MDIO_START_OP\t\t0xFFFF\n#define REALTEK_MDIO_ADDR_OP\t\t0x000E\n#define REALTEK_MDIO_READ_OP\t\t0x0001\n#define REALTEK_MDIO_WRITE_OP\t\t0x0003\n\nstatic int realtek_mdio_write(void *ctx, u32 reg, u32 val)\n{\n\tstruct realtek_priv *priv = ctx;\n\tstruct mii_bus *bus = priv->bus;\n\tint ret;\n\n\tmutex_lock(&bus->mdio_lock);\n\n\tret = bus->write(bus, priv->mdio_addr, REALTEK_MDIO_CTRL0_REG, REALTEK_MDIO_ADDR_OP);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = bus->write(bus, priv->mdio_addr, REALTEK_MDIO_ADDRESS_REG, reg);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = bus->write(bus, priv->mdio_addr, REALTEK_MDIO_DATA_WRITE_REG, val);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = bus->write(bus, priv->mdio_addr, REALTEK_MDIO_CTRL1_REG, REALTEK_MDIO_WRITE_OP);\n\nout_unlock:\n\tmutex_unlock(&bus->mdio_lock);\n\n\treturn ret;\n}\n\nstatic int realtek_mdio_read(void *ctx, u32 reg, u32 *val)\n{\n\tstruct realtek_priv *priv = ctx;\n\tstruct mii_bus *bus = priv->bus;\n\tint ret;\n\n\tmutex_lock(&bus->mdio_lock);\n\n\tret = bus->write(bus, priv->mdio_addr, REALTEK_MDIO_CTRL0_REG, REALTEK_MDIO_ADDR_OP);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = bus->write(bus, priv->mdio_addr, REALTEK_MDIO_ADDRESS_REG, reg);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = bus->write(bus, priv->mdio_addr, REALTEK_MDIO_CTRL1_REG, REALTEK_MDIO_READ_OP);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = bus->read(bus, priv->mdio_addr, REALTEK_MDIO_DATA_READ_REG);\n\tif (ret >= 0) {\n\t\t*val = ret;\n\t\tret = 0;\n\t}\n\nout_unlock:\n\tmutex_unlock(&bus->mdio_lock);\n\n\treturn ret;\n}\n\nstatic void realtek_mdio_lock(void *ctx)\n{\n\tstruct realtek_priv *priv = ctx;\n\n\tmutex_lock(&priv->map_lock);\n}\n\nstatic void realtek_mdio_unlock(void *ctx)\n{\n\tstruct realtek_priv *priv = ctx;\n\n\tmutex_unlock(&priv->map_lock);\n}\n\nstatic const struct regmap_config realtek_mdio_regmap_config = {\n\t.reg_bits = 10,  \n\t.val_bits = 16,\n\t.reg_stride = 1,\n\t \n\t.max_register = 0xffff,\n\t.reg_format_endian = REGMAP_ENDIAN_BIG,\n\t.reg_read = realtek_mdio_read,\n\t.reg_write = realtek_mdio_write,\n\t.cache_type = REGCACHE_NONE,\n\t.lock = realtek_mdio_lock,\n\t.unlock = realtek_mdio_unlock,\n};\n\nstatic const struct regmap_config realtek_mdio_nolock_regmap_config = {\n\t.reg_bits = 10,  \n\t.val_bits = 16,\n\t.reg_stride = 1,\n\t \n\t.max_register = 0xffff,\n\t.reg_format_endian = REGMAP_ENDIAN_BIG,\n\t.reg_read = realtek_mdio_read,\n\t.reg_write = realtek_mdio_write,\n\t.cache_type = REGCACHE_NONE,\n\t.disable_locking = true,\n};\n\nstatic int realtek_mdio_probe(struct mdio_device *mdiodev)\n{\n\tstruct realtek_priv *priv;\n\tstruct device *dev = &mdiodev->dev;\n\tconst struct realtek_variant *var;\n\tstruct regmap_config rc;\n\tstruct device_node *np;\n\tint ret;\n\n\tvar = of_device_get_match_data(dev);\n\tif (!var)\n\t\treturn -EINVAL;\n\n\tpriv = devm_kzalloc(&mdiodev->dev,\n\t\t\t    size_add(sizeof(*priv), var->chip_data_sz),\n\t\t\t    GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&priv->map_lock);\n\n\trc = realtek_mdio_regmap_config;\n\trc.lock_arg = priv;\n\tpriv->map = devm_regmap_init(dev, NULL, priv, &rc);\n\tif (IS_ERR(priv->map)) {\n\t\tret = PTR_ERR(priv->map);\n\t\tdev_err(dev, \"regmap init failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trc = realtek_mdio_nolock_regmap_config;\n\tpriv->map_nolock = devm_regmap_init(dev, NULL, priv, &rc);\n\tif (IS_ERR(priv->map_nolock)) {\n\t\tret = PTR_ERR(priv->map_nolock);\n\t\tdev_err(dev, \"regmap init failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpriv->mdio_addr = mdiodev->addr;\n\tpriv->bus = mdiodev->bus;\n\tpriv->dev = &mdiodev->dev;\n\tpriv->chip_data = (void *)priv + sizeof(*priv);\n\n\tpriv->clk_delay = var->clk_delay;\n\tpriv->cmd_read = var->cmd_read;\n\tpriv->cmd_write = var->cmd_write;\n\tpriv->ops = var->ops;\n\n\tpriv->write_reg_noack = realtek_mdio_write;\n\n\tnp = dev->of_node;\n\n\tdev_set_drvdata(dev, priv);\n\n\t \n\tpriv->leds_disabled = of_property_read_bool(np, \"realtek,disable-leds\");\n\n\tpriv->reset = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(priv->reset)) {\n\t\tdev_err(dev, \"failed to get RESET GPIO\\n\");\n\t\treturn PTR_ERR(priv->reset);\n\t}\n\n\tif (priv->reset) {\n\t\tgpiod_set_value(priv->reset, 1);\n\t\tdev_dbg(dev, \"asserted RESET\\n\");\n\t\tmsleep(REALTEK_HW_STOP_DELAY);\n\t\tgpiod_set_value(priv->reset, 0);\n\t\tmsleep(REALTEK_HW_START_DELAY);\n\t\tdev_dbg(dev, \"deasserted RESET\\n\");\n\t}\n\n\tret = priv->ops->detect(priv);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to detect switch\\n\");\n\t\treturn ret;\n\t}\n\n\tpriv->ds = devm_kzalloc(dev, sizeof(*priv->ds), GFP_KERNEL);\n\tif (!priv->ds)\n\t\treturn -ENOMEM;\n\n\tpriv->ds->dev = dev;\n\tpriv->ds->num_ports = priv->num_ports;\n\tpriv->ds->priv = priv;\n\tpriv->ds->ops = var->ds_ops_mdio;\n\n\tret = dsa_register_switch(priv->ds);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"unable to register switch ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void realtek_mdio_remove(struct mdio_device *mdiodev)\n{\n\tstruct realtek_priv *priv = dev_get_drvdata(&mdiodev->dev);\n\n\tif (!priv)\n\t\treturn;\n\n\tdsa_unregister_switch(priv->ds);\n\n\t \n\tif (priv->reset)\n\t\tgpiod_set_value(priv->reset, 1);\n}\n\nstatic void realtek_mdio_shutdown(struct mdio_device *mdiodev)\n{\n\tstruct realtek_priv *priv = dev_get_drvdata(&mdiodev->dev);\n\n\tif (!priv)\n\t\treturn;\n\n\tdsa_switch_shutdown(priv->ds);\n\n\tdev_set_drvdata(&mdiodev->dev, NULL);\n}\n\nstatic const struct of_device_id realtek_mdio_of_match[] = {\n#if IS_ENABLED(CONFIG_NET_DSA_REALTEK_RTL8366RB)\n\t{ .compatible = \"realtek,rtl8366rb\", .data = &rtl8366rb_variant, },\n#endif\n#if IS_ENABLED(CONFIG_NET_DSA_REALTEK_RTL8365MB)\n\t{ .compatible = \"realtek,rtl8365mb\", .data = &rtl8365mb_variant, },\n#endif\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, realtek_mdio_of_match);\n\nstatic struct mdio_driver realtek_mdio_driver = {\n\t.mdiodrv.driver = {\n\t\t.name = \"realtek-mdio\",\n\t\t.of_match_table = realtek_mdio_of_match,\n\t},\n\t.probe  = realtek_mdio_probe,\n\t.remove = realtek_mdio_remove,\n\t.shutdown = realtek_mdio_shutdown,\n};\n\nmdio_module_driver(realtek_mdio_driver);\n\nMODULE_AUTHOR(\"Luiz Angelo Daros de Luca <luizluca@gmail.com>\");\nMODULE_DESCRIPTION(\"Driver for Realtek ethernet switch connected via MDIO interface\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}