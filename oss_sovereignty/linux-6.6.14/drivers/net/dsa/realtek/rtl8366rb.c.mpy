{
  "module_name": "rtl8366rb.c",
  "hash_id": "d8e4952bfa64bdca69fdda448f24db327694267e530585e67996c3a0cfa489bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/realtek/rtl8366rb.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/etherdevice.h>\n#include <linux/if_bridge.h>\n#include <linux/interrupt.h>\n#include <linux/irqdomain.h>\n#include <linux/irqchip/chained_irq.h>\n#include <linux/of_irq.h>\n#include <linux/regmap.h>\n\n#include \"realtek.h\"\n\n#define RTL8366RB_PORT_NUM_CPU\t\t5\n#define RTL8366RB_NUM_PORTS\t\t6\n#define RTL8366RB_PHY_NO_MAX\t\t4\n#define RTL8366RB_PHY_ADDR_MAX\t\t31\n\n \n#define RTL8366RB_SGCR\t\t\t\t0x0000\n#define RTL8366RB_SGCR_EN_BC_STORM_CTRL\t\tBIT(0)\n#define RTL8366RB_SGCR_MAX_LENGTH(a)\t\t((a) << 4)\n#define RTL8366RB_SGCR_MAX_LENGTH_MASK\t\tRTL8366RB_SGCR_MAX_LENGTH(0x3)\n#define RTL8366RB_SGCR_MAX_LENGTH_1522\t\tRTL8366RB_SGCR_MAX_LENGTH(0x0)\n#define RTL8366RB_SGCR_MAX_LENGTH_1536\t\tRTL8366RB_SGCR_MAX_LENGTH(0x1)\n#define RTL8366RB_SGCR_MAX_LENGTH_1552\t\tRTL8366RB_SGCR_MAX_LENGTH(0x2)\n#define RTL8366RB_SGCR_MAX_LENGTH_16000\t\tRTL8366RB_SGCR_MAX_LENGTH(0x3)\n#define RTL8366RB_SGCR_EN_VLAN\t\t\tBIT(13)\n#define RTL8366RB_SGCR_EN_VLAN_4KTB\t\tBIT(14)\n\n \n#define RTL8366RB_PECR\t\t\t\t0x0001\n\n \n#define RTL8366RB_PORT_LEARNDIS_CTRL\t\t0x0002\n\n \n#define RTL8366RB_SECURITY_CTRL\t\t\t0x0003\n\n#define RTL8366RB_SSCR2\t\t\t\t0x0004\n#define RTL8366RB_SSCR2_DROP_UNKNOWN_DA\t\tBIT(0)\n\n \n#define RTL8366RB_PMC0\t\t\t\t0x0005\n#define RTL8366RB_PMC0_SPI\t\t\tBIT(0)\n#define RTL8366RB_PMC0_EN_AUTOLOAD\t\tBIT(1)\n#define RTL8366RB_PMC0_PROBE\t\t\tBIT(2)\n#define RTL8366RB_PMC0_DIS_BISR\t\t\tBIT(3)\n#define RTL8366RB_PMC0_ADCTEST\t\t\tBIT(4)\n#define RTL8366RB_PMC0_SRAM_DIAG\t\tBIT(5)\n#define RTL8366RB_PMC0_EN_SCAN\t\t\tBIT(6)\n#define RTL8366RB_PMC0_P4_IOMODE_SHIFT\t\t7\n#define RTL8366RB_PMC0_P4_IOMODE_MASK\t\tGENMASK(9, 7)\n#define RTL8366RB_PMC0_P5_IOMODE_SHIFT\t\t10\n#define RTL8366RB_PMC0_P5_IOMODE_MASK\t\tGENMASK(12, 10)\n#define RTL8366RB_PMC0_SDSMODE_SHIFT\t\t13\n#define RTL8366RB_PMC0_SDSMODE_MASK\t\tGENMASK(15, 13)\n#define RTL8366RB_PMC1\t\t\t\t0x0006\n\n \n#define RTL8366RB_PMCR\t\t\t\t0x0007\n#define RTL8366RB_PMCR_SOURCE_PORT(a)\t\t(a)\n#define RTL8366RB_PMCR_SOURCE_PORT_MASK\t\t0x000f\n#define RTL8366RB_PMCR_MONITOR_PORT(a)\t\t((a) << 4)\n#define RTL8366RB_PMCR_MONITOR_PORT_MASK\t0x00f0\n#define RTL8366RB_PMCR_MIRROR_RX\t\tBIT(8)\n#define RTL8366RB_PMCR_MIRROR_TX\t\tBIT(9)\n#define RTL8366RB_PMCR_MIRROR_SPC\t\tBIT(10)\n#define RTL8366RB_PMCR_MIRROR_ISO\t\tBIT(11)\n\n \n#define RTL8366RB_PAACR0\t\t0x0010\n \n#define RTL8366RB_PAACR1\t\t0x0011\n \n#define RTL8366RB_PAACR2\t\t0x0012\n#define RTL8366RB_PAACR_SPEED_10M\t0\n#define RTL8366RB_PAACR_SPEED_100M\t1\n#define RTL8366RB_PAACR_SPEED_1000M\t2\n#define RTL8366RB_PAACR_FULL_DUPLEX\tBIT(2)\n#define RTL8366RB_PAACR_LINK_UP\t\tBIT(4)\n#define RTL8366RB_PAACR_TX_PAUSE\tBIT(5)\n#define RTL8366RB_PAACR_RX_PAUSE\tBIT(6)\n#define RTL8366RB_PAACR_AN\t\tBIT(7)\n\n#define RTL8366RB_PAACR_CPU_PORT\t(RTL8366RB_PAACR_SPEED_1000M | \\\n\t\t\t\t\t RTL8366RB_PAACR_FULL_DUPLEX | \\\n\t\t\t\t\t RTL8366RB_PAACR_LINK_UP | \\\n\t\t\t\t\t RTL8366RB_PAACR_TX_PAUSE | \\\n\t\t\t\t\t RTL8366RB_PAACR_RX_PAUSE)\n\n \n#define RTL8366RB_PSTAT0\t\t0x0014\n \n#define RTL8366RB_PSTAT1\t\t0x0015\n \n#define RTL8366RB_PSTAT2\t\t0x0016\n\n#define RTL8366RB_POWER_SAVING_REG\t0x0021\n\n \n#define RTL8366RB_STP_STATE_BASE\t0x0050  \n#define RTL8366RB_STP_STATE_DISABLED\t0x0\n#define RTL8366RB_STP_STATE_BLOCKING\t0x1\n#define RTL8366RB_STP_STATE_LEARNING\t0x2\n#define RTL8366RB_STP_STATE_FORWARDING\t0x3\n#define RTL8366RB_STP_MASK\t\tGENMASK(1, 0)\n#define RTL8366RB_STP_STATE(port, state) \\\n\t((state) << ((port) * 2))\n#define RTL8366RB_STP_STATE_MASK(port) \\\n\tRTL8366RB_STP_STATE((port), RTL8366RB_STP_MASK)\n\n \n#define RTL8368RB_CPU_CTRL_REG\t\t0x0061\n#define RTL8368RB_CPU_PORTS_MSK\t\t0x00FF\n \n#define RTL8368RB_CPU_NO_TAG\t\tBIT(15)\n\n#define RTL8366RB_SMAR0\t\t\t0x0070  \n#define RTL8366RB_SMAR1\t\t\t0x0071  \n#define RTL8366RB_SMAR2\t\t\t0x0072  \n\n#define RTL8366RB_RESET_CTRL_REG\t\t0x0100\n#define RTL8366RB_CHIP_CTRL_RESET_HW\t\tBIT(0)\n#define RTL8366RB_CHIP_CTRL_RESET_SW\t\tBIT(1)\n\n#define RTL8366RB_CHIP_ID_REG\t\t\t0x0509\n#define RTL8366RB_CHIP_ID_8366\t\t\t0x5937\n#define RTL8366RB_CHIP_VERSION_CTRL_REG\t\t0x050A\n#define RTL8366RB_CHIP_VERSION_MASK\t\t0xf\n\n \n#define RTL8366RB_PHY_ACCESS_CTRL_REG\t\t0x8000\n#define RTL8366RB_PHY_CTRL_READ\t\t\tBIT(0)\n#define RTL8366RB_PHY_CTRL_WRITE\t\t0\n#define RTL8366RB_PHY_ACCESS_BUSY_REG\t\t0x8001\n#define RTL8366RB_PHY_INT_BUSY\t\t\tBIT(0)\n#define RTL8366RB_PHY_EXT_BUSY\t\t\tBIT(4)\n#define RTL8366RB_PHY_ACCESS_DATA_REG\t\t0x8002\n#define RTL8366RB_PHY_EXT_CTRL_REG\t\t0x8010\n#define RTL8366RB_PHY_EXT_WRDATA_REG\t\t0x8011\n#define RTL8366RB_PHY_EXT_RDDATA_REG\t\t0x8012\n\n#define RTL8366RB_PHY_REG_MASK\t\t\t0x1f\n#define RTL8366RB_PHY_PAGE_OFFSET\t\t5\n#define RTL8366RB_PHY_PAGE_MASK\t\t\t(0xf << 5)\n#define RTL8366RB_PHY_NO_OFFSET\t\t\t9\n#define RTL8366RB_PHY_NO_MASK\t\t\t(0x1f << 9)\n\n \n#define RTL8366RB_VLAN_INGRESS_CTRL1_REG\t0x037E\n#define RTL8366RB_VLAN_INGRESS_CTRL1_DROP(port)\t(BIT((port)) | BIT((port) + 6))\n\n \n#define RTL8366RB_VLAN_INGRESS_CTRL2_REG\t0x037f\n\n \n#define RTL8366RB_LED_BLINKRATE_REG\t\t0x0430\n#define RTL8366RB_LED_BLINKRATE_MASK\t\t0x0007\n#define RTL8366RB_LED_BLINKRATE_28MS\t\t0x0000\n#define RTL8366RB_LED_BLINKRATE_56MS\t\t0x0001\n#define RTL8366RB_LED_BLINKRATE_84MS\t\t0x0002\n#define RTL8366RB_LED_BLINKRATE_111MS\t\t0x0003\n#define RTL8366RB_LED_BLINKRATE_222MS\t\t0x0004\n#define RTL8366RB_LED_BLINKRATE_446MS\t\t0x0005\n\n#define RTL8366RB_LED_CTRL_REG\t\t\t0x0431\n#define RTL8366RB_LED_OFF\t\t\t0x0\n#define RTL8366RB_LED_DUP_COL\t\t\t0x1\n#define RTL8366RB_LED_LINK_ACT\t\t\t0x2\n#define RTL8366RB_LED_SPD1000\t\t\t0x3\n#define RTL8366RB_LED_SPD100\t\t\t0x4\n#define RTL8366RB_LED_SPD10\t\t\t0x5\n#define RTL8366RB_LED_SPD1000_ACT\t\t0x6\n#define RTL8366RB_LED_SPD100_ACT\t\t0x7\n#define RTL8366RB_LED_SPD10_ACT\t\t\t0x8\n#define RTL8366RB_LED_SPD100_10_ACT\t\t0x9\n#define RTL8366RB_LED_FIBER\t\t\t0xa\n#define RTL8366RB_LED_AN_FAULT\t\t\t0xb\n#define RTL8366RB_LED_LINK_RX\t\t\t0xc\n#define RTL8366RB_LED_LINK_TX\t\t\t0xd\n#define RTL8366RB_LED_MASTER\t\t\t0xe\n#define RTL8366RB_LED_FORCE\t\t\t0xf\n#define RTL8366RB_LED_0_1_CTRL_REG\t\t0x0432\n#define RTL8366RB_LED_1_OFFSET\t\t\t6\n#define RTL8366RB_LED_2_3_CTRL_REG\t\t0x0433\n#define RTL8366RB_LED_3_OFFSET\t\t\t6\n\n#define RTL8366RB_MIB_COUNT\t\t\t33\n#define RTL8366RB_GLOBAL_MIB_COUNT\t\t1\n#define RTL8366RB_MIB_COUNTER_PORT_OFFSET\t0x0050\n#define RTL8366RB_MIB_COUNTER_BASE\t\t0x1000\n#define RTL8366RB_MIB_CTRL_REG\t\t\t0x13F0\n#define RTL8366RB_MIB_CTRL_USER_MASK\t\t0x0FFC\n#define RTL8366RB_MIB_CTRL_BUSY_MASK\t\tBIT(0)\n#define RTL8366RB_MIB_CTRL_RESET_MASK\t\tBIT(1)\n#define RTL8366RB_MIB_CTRL_PORT_RESET(_p)\tBIT(2 + (_p))\n#define RTL8366RB_MIB_CTRL_GLOBAL_RESET\t\tBIT(11)\n\n#define RTL8366RB_PORT_VLAN_CTRL_BASE\t\t0x0063\n#define RTL8366RB_PORT_VLAN_CTRL_REG(_p)  \\\n\t\t(RTL8366RB_PORT_VLAN_CTRL_BASE + (_p) / 4)\n#define RTL8366RB_PORT_VLAN_CTRL_MASK\t\t0xf\n#define RTL8366RB_PORT_VLAN_CTRL_SHIFT(_p)\t(4 * ((_p) % 4))\n\n#define RTL8366RB_VLAN_TABLE_READ_BASE\t\t0x018C\n#define RTL8366RB_VLAN_TABLE_WRITE_BASE\t\t0x0185\n\n#define RTL8366RB_TABLE_ACCESS_CTRL_REG\t\t0x0180\n#define RTL8366RB_TABLE_VLAN_READ_CTRL\t\t0x0E01\n#define RTL8366RB_TABLE_VLAN_WRITE_CTRL\t\t0x0F01\n\n#define RTL8366RB_VLAN_MC_BASE(_x)\t\t(0x0020 + (_x) * 3)\n\n#define RTL8366RB_PORT_LINK_STATUS_BASE\t\t0x0014\n#define RTL8366RB_PORT_STATUS_SPEED_MASK\t0x0003\n#define RTL8366RB_PORT_STATUS_DUPLEX_MASK\t0x0004\n#define RTL8366RB_PORT_STATUS_LINK_MASK\t\t0x0010\n#define RTL8366RB_PORT_STATUS_TXPAUSE_MASK\t0x0020\n#define RTL8366RB_PORT_STATUS_RXPAUSE_MASK\t0x0040\n#define RTL8366RB_PORT_STATUS_AN_MASK\t\t0x0080\n\n#define RTL8366RB_NUM_VLANS\t\t16\n#define RTL8366RB_NUM_LEDGROUPS\t\t4\n#define RTL8366RB_NUM_VIDS\t\t4096\n#define RTL8366RB_PRIORITYMAX\t\t7\n#define RTL8366RB_NUM_FIDS\t\t8\n#define RTL8366RB_FIDMAX\t\t7\n\n#define RTL8366RB_PORT_1\t\tBIT(0)  \n#define RTL8366RB_PORT_2\t\tBIT(1)  \n#define RTL8366RB_PORT_3\t\tBIT(2)  \n#define RTL8366RB_PORT_4\t\tBIT(3)  \n#define RTL8366RB_PORT_5\t\tBIT(4)  \n\n#define RTL8366RB_PORT_CPU\t\tBIT(5)  \n\n#define RTL8366RB_PORT_ALL\t\t(RTL8366RB_PORT_1 |\t\\\n\t\t\t\t\t RTL8366RB_PORT_2 |\t\\\n\t\t\t\t\t RTL8366RB_PORT_3 |\t\\\n\t\t\t\t\t RTL8366RB_PORT_4 |\t\\\n\t\t\t\t\t RTL8366RB_PORT_5 |\t\\\n\t\t\t\t\t RTL8366RB_PORT_CPU)\n\n#define RTL8366RB_PORT_ALL_BUT_CPU\t(RTL8366RB_PORT_1 |\t\\\n\t\t\t\t\t RTL8366RB_PORT_2 |\t\\\n\t\t\t\t\t RTL8366RB_PORT_3 |\t\\\n\t\t\t\t\t RTL8366RB_PORT_4 |\t\\\n\t\t\t\t\t RTL8366RB_PORT_5)\n\n#define RTL8366RB_PORT_ALL_EXTERNAL\t(RTL8366RB_PORT_1 |\t\\\n\t\t\t\t\t RTL8366RB_PORT_2 |\t\\\n\t\t\t\t\t RTL8366RB_PORT_3 |\t\\\n\t\t\t\t\t RTL8366RB_PORT_4)\n\n#define RTL8366RB_PORT_ALL_INTERNAL\t RTL8366RB_PORT_CPU\n\n \n#define RTL8366RB_VLAN_VID_MASK\t\t0xfff\n#define RTL8366RB_VLAN_PRIORITY_SHIFT\t12\n#define RTL8366RB_VLAN_PRIORITY_MASK\t0x7\n \n#define RTL8366RB_VLAN_UNTAG_SHIFT\t8\n#define RTL8366RB_VLAN_UNTAG_MASK\t0xff\n#define RTL8366RB_VLAN_MEMBER_MASK\t0xff\n \n#define RTL8366RB_VLAN_STAG_MBR_MASK\t0xff\n#define RTL8366RB_VLAN_STAG_MBR_SHIFT\t8\n#define RTL8366RB_VLAN_STAG_IDX_MASK\t0x7\n#define RTL8366RB_VLAN_STAG_IDX_SHIFT\t5\n#define RTL8366RB_VLAN_FID_MASK\t\t0x7\n\n \n#define RTL8366RB_IB_BASE\t\t0x0200\n#define RTL8366RB_IB_REG(pnum)\t\t(RTL8366RB_IB_BASE + (pnum))\n#define RTL8366RB_IB_BDTH_MASK\t\t0x3fff\n#define RTL8366RB_IB_PREIFG\t\tBIT(14)\n\n \n#define RTL8366RB_EB_BASE\t\t0x02d1\n#define RTL8366RB_EB_REG(pnum)\t\t(RTL8366RB_EB_BASE + (pnum))\n#define RTL8366RB_EB_BDTH_MASK\t\t0x3fff\n#define RTL8366RB_EB_PREIFG_REG\t\t0x02f8\n#define RTL8366RB_EB_PREIFG\t\tBIT(9)\n\n#define RTL8366RB_BDTH_SW_MAX\t\t1048512  \n#define RTL8366RB_BDTH_UNIT\t\t64\n#define RTL8366RB_BDTH_REG_DEFAULT\t16383\n\n \n#define RTL8366RB_QOS\t\t\tBIT(15)\n \n#define RTL8366RB_QOS_DEFAULT_PREIFG\t1\n\n \n#define RTL8366RB_INTERRUPT_CONTROL_REG\t0x0440\n#define RTL8366RB_INTERRUPT_POLARITY\tBIT(0)\n#define RTL8366RB_P4_RGMII_LED\t\tBIT(2)\n#define RTL8366RB_INTERRUPT_MASK_REG\t0x0441\n#define RTL8366RB_INTERRUPT_LINK_CHGALL\tGENMASK(11, 0)\n#define RTL8366RB_INTERRUPT_ACLEXCEED\tBIT(8)\n#define RTL8366RB_INTERRUPT_STORMEXCEED\tBIT(9)\n#define RTL8366RB_INTERRUPT_P4_FIBER\tBIT(12)\n#define RTL8366RB_INTERRUPT_P4_UTP\tBIT(13)\n#define RTL8366RB_INTERRUPT_VALID\t(RTL8366RB_INTERRUPT_LINK_CHGALL | \\\n\t\t\t\t\t RTL8366RB_INTERRUPT_ACLEXCEED | \\\n\t\t\t\t\t RTL8366RB_INTERRUPT_STORMEXCEED | \\\n\t\t\t\t\t RTL8366RB_INTERRUPT_P4_FIBER | \\\n\t\t\t\t\t RTL8366RB_INTERRUPT_P4_UTP)\n#define RTL8366RB_INTERRUPT_STATUS_REG\t0x0442\n#define RTL8366RB_NUM_INTERRUPT\t\t14  \n\n \n#define RTL8366RB_PORT_ISO_BASE\t\t0x0F08\n#define RTL8366RB_PORT_ISO(pnum)\t(RTL8366RB_PORT_ISO_BASE + (pnum))\n#define RTL8366RB_PORT_ISO_EN\t\tBIT(0)\n#define RTL8366RB_PORT_ISO_PORTS_MASK\tGENMASK(7, 1)\n#define RTL8366RB_PORT_ISO_PORTS(pmask)\t((pmask) << 1)\n\n \n#define RTL8366RB_MAC_FORCE_CTRL_REG\t0x0F11\n\n#define RTL8366RB_OAM_PARSER_REG\t0x0F14\n#define RTL8366RB_OAM_MULTIPLEXER_REG\t0x0F15\n\n#define RTL8366RB_GREEN_FEATURE_REG\t0x0F51\n#define RTL8366RB_GREEN_FEATURE_MSK\t0x0007\n#define RTL8366RB_GREEN_FEATURE_TX\tBIT(0)\n#define RTL8366RB_GREEN_FEATURE_RX\tBIT(2)\n\n \nstruct rtl8366rb {\n\tunsigned int max_mtu[RTL8366RB_NUM_PORTS];\n\tbool pvid_enabled[RTL8366RB_NUM_PORTS];\n};\n\nstatic struct rtl8366_mib_counter rtl8366rb_mib_counters[] = {\n\t{ 0,  0, 4, \"IfInOctets\"\t\t\t\t},\n\t{ 0,  4, 4, \"EtherStatsOctets\"\t\t\t\t},\n\t{ 0,  8, 2, \"EtherStatsUnderSizePkts\"\t\t\t},\n\t{ 0, 10, 2, \"EtherFragments\"\t\t\t\t},\n\t{ 0, 12, 2, \"EtherStatsPkts64Octets\"\t\t\t},\n\t{ 0, 14, 2, \"EtherStatsPkts65to127Octets\"\t\t},\n\t{ 0, 16, 2, \"EtherStatsPkts128to255Octets\"\t\t},\n\t{ 0, 18, 2, \"EtherStatsPkts256to511Octets\"\t\t},\n\t{ 0, 20, 2, \"EtherStatsPkts512to1023Octets\"\t\t},\n\t{ 0, 22, 2, \"EtherStatsPkts1024to1518Octets\"\t\t},\n\t{ 0, 24, 2, \"EtherOversizeStats\"\t\t\t},\n\t{ 0, 26, 2, \"EtherStatsJabbers\"\t\t\t\t},\n\t{ 0, 28, 2, \"IfInUcastPkts\"\t\t\t\t},\n\t{ 0, 30, 2, \"EtherStatsMulticastPkts\"\t\t\t},\n\t{ 0, 32, 2, \"EtherStatsBroadcastPkts\"\t\t\t},\n\t{ 0, 34, 2, \"EtherStatsDropEvents\"\t\t\t},\n\t{ 0, 36, 2, \"Dot3StatsFCSErrors\"\t\t\t},\n\t{ 0, 38, 2, \"Dot3StatsSymbolErrors\"\t\t\t},\n\t{ 0, 40, 2, \"Dot3InPauseFrames\"\t\t\t\t},\n\t{ 0, 42, 2, \"Dot3ControlInUnknownOpcodes\"\t\t},\n\t{ 0, 44, 4, \"IfOutOctets\"\t\t\t\t},\n\t{ 0, 48, 2, \"Dot3StatsSingleCollisionFrames\"\t\t},\n\t{ 0, 50, 2, \"Dot3StatMultipleCollisionFrames\"\t\t},\n\t{ 0, 52, 2, \"Dot3sDeferredTransmissions\"\t\t},\n\t{ 0, 54, 2, \"Dot3StatsLateCollisions\"\t\t\t},\n\t{ 0, 56, 2, \"EtherStatsCollisions\"\t\t\t},\n\t{ 0, 58, 2, \"Dot3StatsExcessiveCollisions\"\t\t},\n\t{ 0, 60, 2, \"Dot3OutPauseFrames\"\t\t\t},\n\t{ 0, 62, 2, \"Dot1dBasePortDelayExceededDiscards\"\t},\n\t{ 0, 64, 2, \"Dot1dTpPortInDiscards\"\t\t\t},\n\t{ 0, 66, 2, \"IfOutUcastPkts\"\t\t\t\t},\n\t{ 0, 68, 2, \"IfOutMulticastPkts\"\t\t\t},\n\t{ 0, 70, 2, \"IfOutBroadcastPkts\"\t\t\t},\n};\n\nstatic int rtl8366rb_get_mib_counter(struct realtek_priv *priv,\n\t\t\t\t     int port,\n\t\t\t\t     struct rtl8366_mib_counter *mib,\n\t\t\t\t     u64 *mibvalue)\n{\n\tu32 addr, val;\n\tint ret;\n\tint i;\n\n\taddr = RTL8366RB_MIB_COUNTER_BASE +\n\t\tRTL8366RB_MIB_COUNTER_PORT_OFFSET * (port) +\n\t\tmib->offset;\n\n\t \n\tret = regmap_write(priv->map, addr, 0);  \n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_read(priv->map, RTL8366RB_MIB_CTRL_REG, &val);\n\tif (ret)\n\t\treturn -EIO;\n\n\tif (val & RTL8366RB_MIB_CTRL_BUSY_MASK)\n\t\treturn -EBUSY;\n\n\tif (val & RTL8366RB_MIB_CTRL_RESET_MASK)\n\t\treturn -EIO;\n\n\t \n\t*mibvalue = 0;\n\tfor (i = mib->length; i > 0; i--) {\n\t\tret = regmap_read(priv->map, addr + (i - 1), &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*mibvalue = (*mibvalue << 16) | (val & 0xFFFF);\n\t}\n\treturn 0;\n}\n\nstatic u32 rtl8366rb_get_irqmask(struct irq_data *d)\n{\n\tint line = irqd_to_hwirq(d);\n\tu32 val;\n\n\t \n\tif (line < 12)\n\t\tval = BIT(line) | BIT(line + 6);\n\telse\n\t\tval = BIT(line);\n\treturn val;\n}\n\nstatic void rtl8366rb_mask_irq(struct irq_data *d)\n{\n\tstruct realtek_priv *priv = irq_data_get_irq_chip_data(d);\n\tint ret;\n\n\tret = regmap_update_bits(priv->map, RTL8366RB_INTERRUPT_MASK_REG,\n\t\t\t\t rtl8366rb_get_irqmask(d), 0);\n\tif (ret)\n\t\tdev_err(priv->dev, \"could not mask IRQ\\n\");\n}\n\nstatic void rtl8366rb_unmask_irq(struct irq_data *d)\n{\n\tstruct realtek_priv *priv = irq_data_get_irq_chip_data(d);\n\tint ret;\n\n\tret = regmap_update_bits(priv->map, RTL8366RB_INTERRUPT_MASK_REG,\n\t\t\t\t rtl8366rb_get_irqmask(d),\n\t\t\t\t rtl8366rb_get_irqmask(d));\n\tif (ret)\n\t\tdev_err(priv->dev, \"could not unmask IRQ\\n\");\n}\n\nstatic irqreturn_t rtl8366rb_irq(int irq, void *data)\n{\n\tstruct realtek_priv *priv = data;\n\tu32 stat;\n\tint ret;\n\n\t \n\tret = regmap_read(priv->map, RTL8366RB_INTERRUPT_STATUS_REG,\n\t\t\t  &stat);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"can't read interrupt status\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\tstat &= RTL8366RB_INTERRUPT_VALID;\n\tif (!stat)\n\t\treturn IRQ_NONE;\n\twhile (stat) {\n\t\tint line = __ffs(stat);\n\t\tint child_irq;\n\n\t\tstat &= ~BIT(line);\n\t\t \n\t\tif (line < 12 && line > 5)\n\t\t\tline -= 5;\n\t\tchild_irq = irq_find_mapping(priv->irqdomain, line);\n\t\thandle_nested_irq(child_irq);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic struct irq_chip rtl8366rb_irq_chip = {\n\t.name = \"RTL8366RB\",\n\t.irq_mask = rtl8366rb_mask_irq,\n\t.irq_unmask = rtl8366rb_unmask_irq,\n};\n\nstatic int rtl8366rb_irq_map(struct irq_domain *domain, unsigned int irq,\n\t\t\t     irq_hw_number_t hwirq)\n{\n\tirq_set_chip_data(irq, domain->host_data);\n\tirq_set_chip_and_handler(irq, &rtl8366rb_irq_chip, handle_simple_irq);\n\tirq_set_nested_thread(irq, 1);\n\tirq_set_noprobe(irq);\n\n\treturn 0;\n}\n\nstatic void rtl8366rb_irq_unmap(struct irq_domain *d, unsigned int irq)\n{\n\tirq_set_nested_thread(irq, 0);\n\tirq_set_chip_and_handler(irq, NULL, NULL);\n\tirq_set_chip_data(irq, NULL);\n}\n\nstatic const struct irq_domain_ops rtl8366rb_irqdomain_ops = {\n\t.map = rtl8366rb_irq_map,\n\t.unmap = rtl8366rb_irq_unmap,\n\t.xlate  = irq_domain_xlate_onecell,\n};\n\nstatic int rtl8366rb_setup_cascaded_irq(struct realtek_priv *priv)\n{\n\tstruct device_node *intc;\n\tunsigned long irq_trig;\n\tint irq;\n\tint ret;\n\tu32 val;\n\tint i;\n\n\tintc = of_get_child_by_name(priv->dev->of_node, \"interrupt-controller\");\n\tif (!intc) {\n\t\tdev_err(priv->dev, \"missing child interrupt-controller node\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tirq = of_irq_get(intc, 0);\n\tif (irq <= 0) {\n\t\tdev_err(priv->dev, \"failed to get parent IRQ\\n\");\n\t\tret = irq ? irq : -EINVAL;\n\t\tgoto out_put_node;\n\t}\n\n\t \n\tret = regmap_read(priv->map, RTL8366RB_INTERRUPT_STATUS_REG,\n\t\t\t  &val);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"can't read interrupt status\\n\");\n\t\tgoto out_put_node;\n\t}\n\n\t \n\tirq_trig = irqd_get_trigger_type(irq_get_irq_data(irq));\n\tswitch (irq_trig) {\n\tcase IRQF_TRIGGER_RISING:\n\tcase IRQF_TRIGGER_HIGH:\n\t\tdev_info(priv->dev, \"active high/rising IRQ\\n\");\n\t\tval = 0;\n\t\tbreak;\n\tcase IRQF_TRIGGER_FALLING:\n\tcase IRQF_TRIGGER_LOW:\n\t\tdev_info(priv->dev, \"active low/falling IRQ\\n\");\n\t\tval = RTL8366RB_INTERRUPT_POLARITY;\n\t\tbreak;\n\t}\n\tret = regmap_update_bits(priv->map, RTL8366RB_INTERRUPT_CONTROL_REG,\n\t\t\t\t RTL8366RB_INTERRUPT_POLARITY,\n\t\t\t\t val);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"could not configure IRQ polarity\\n\");\n\t\tgoto out_put_node;\n\t}\n\n\tret = devm_request_threaded_irq(priv->dev, irq, NULL,\n\t\t\t\t\trtl8366rb_irq, IRQF_ONESHOT,\n\t\t\t\t\t\"RTL8366RB\", priv);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"unable to request irq: %d\\n\", ret);\n\t\tgoto out_put_node;\n\t}\n\tpriv->irqdomain = irq_domain_add_linear(intc,\n\t\t\t\t\t\tRTL8366RB_NUM_INTERRUPT,\n\t\t\t\t\t\t&rtl8366rb_irqdomain_ops,\n\t\t\t\t\t\tpriv);\n\tif (!priv->irqdomain) {\n\t\tdev_err(priv->dev, \"failed to create IRQ domain\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_put_node;\n\t}\n\tfor (i = 0; i < priv->num_ports; i++)\n\t\tirq_set_parent(irq_create_mapping(priv->irqdomain, i), irq);\n\nout_put_node:\n\tof_node_put(intc);\n\treturn ret;\n}\n\nstatic int rtl8366rb_set_addr(struct realtek_priv *priv)\n{\n\tu8 addr[ETH_ALEN];\n\tu16 val;\n\tint ret;\n\n\teth_random_addr(addr);\n\n\tdev_info(priv->dev, \"set MAC: %02X:%02X:%02X:%02X:%02X:%02X\\n\",\n\t\t addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);\n\tval = addr[0] << 8 | addr[1];\n\tret = regmap_write(priv->map, RTL8366RB_SMAR0, val);\n\tif (ret)\n\t\treturn ret;\n\tval = addr[2] << 8 | addr[3];\n\tret = regmap_write(priv->map, RTL8366RB_SMAR1, val);\n\tif (ret)\n\t\treturn ret;\n\tval = addr[4] << 8 | addr[5];\n\tret = regmap_write(priv->map, RTL8366RB_SMAR2, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \n\n \nstruct rtl8366rb_jam_tbl_entry {\n\tu16 reg;\n\tu16 val;\n};\n\n \nstatic const struct rtl8366rb_jam_tbl_entry rtl8366rb_init_jam_ver_0[] = {\n\t{0x000B, 0x0001}, {0x03A6, 0x0100}, {0x03A7, 0x0001}, {0x02D1, 0x3FFF},\n\t{0x02D2, 0x3FFF}, {0x02D3, 0x3FFF}, {0x02D4, 0x3FFF}, {0x02D5, 0x3FFF},\n\t{0x02D6, 0x3FFF}, {0x02D7, 0x3FFF}, {0x02D8, 0x3FFF}, {0x022B, 0x0688},\n\t{0x022C, 0x0FAC}, {0x03D0, 0x4688}, {0x03D1, 0x01F5}, {0x0000, 0x0830},\n\t{0x02F9, 0x0200}, {0x02F7, 0x7FFF}, {0x02F8, 0x03FF}, {0x0080, 0x03E8},\n\t{0x0081, 0x00CE}, {0x0082, 0x00DA}, {0x0083, 0x0230}, {0xBE0F, 0x2000},\n\t{0x0231, 0x422A}, {0x0232, 0x422A}, {0x0233, 0x422A}, {0x0234, 0x422A},\n\t{0x0235, 0x422A}, {0x0236, 0x422A}, {0x0237, 0x422A}, {0x0238, 0x422A},\n\t{0x0239, 0x422A}, {0x023A, 0x422A}, {0x023B, 0x422A}, {0x023C, 0x422A},\n\t{0x023D, 0x422A}, {0x023E, 0x422A}, {0x023F, 0x422A}, {0x0240, 0x422A},\n\t{0x0241, 0x422A}, {0x0242, 0x422A}, {0x0243, 0x422A}, {0x0244, 0x422A},\n\t{0x0245, 0x422A}, {0x0246, 0x422A}, {0x0247, 0x422A}, {0x0248, 0x422A},\n\t{0x0249, 0x0146}, {0x024A, 0x0146}, {0x024B, 0x0146}, {0xBE03, 0xC961},\n\t{0x024D, 0x0146}, {0x024E, 0x0146}, {0x024F, 0x0146}, {0x0250, 0x0146},\n\t{0xBE64, 0x0226}, {0x0252, 0x0146}, {0x0253, 0x0146}, {0x024C, 0x0146},\n\t{0x0251, 0x0146}, {0x0254, 0x0146}, {0xBE62, 0x3FD0}, {0x0084, 0x0320},\n\t{0x0255, 0x0146}, {0x0256, 0x0146}, {0x0257, 0x0146}, {0x0258, 0x0146},\n\t{0x0259, 0x0146}, {0x025A, 0x0146}, {0x025B, 0x0146}, {0x025C, 0x0146},\n\t{0x025D, 0x0146}, {0x025E, 0x0146}, {0x025F, 0x0146}, {0x0260, 0x0146},\n\t{0x0261, 0xA23F}, {0x0262, 0x0294}, {0x0263, 0xA23F}, {0x0264, 0x0294},\n\t{0x0265, 0xA23F}, {0x0266, 0x0294}, {0x0267, 0xA23F}, {0x0268, 0x0294},\n\t{0x0269, 0xA23F}, {0x026A, 0x0294}, {0x026B, 0xA23F}, {0x026C, 0x0294},\n\t{0x026D, 0xA23F}, {0x026E, 0x0294}, {0x026F, 0xA23F}, {0x0270, 0x0294},\n\t{0x02F5, 0x0048}, {0xBE09, 0x0E00}, {0xBE1E, 0x0FA0}, {0xBE14, 0x8448},\n\t{0xBE15, 0x1007}, {0xBE4A, 0xA284}, {0xC454, 0x3F0B}, {0xC474, 0x3F0B},\n\t{0xBE48, 0x3672}, {0xBE4B, 0x17A7}, {0xBE4C, 0x0B15}, {0xBE52, 0x0EDD},\n\t{0xBE49, 0x8C00}, {0xBE5B, 0x785C}, {0xBE5C, 0x785C}, {0xBE5D, 0x785C},\n\t{0xBE61, 0x368A}, {0xBE63, 0x9B84}, {0xC456, 0xCC13}, {0xC476, 0xCC13},\n\t{0xBE65, 0x307D}, {0xBE6D, 0x0005}, {0xBE6E, 0xE120}, {0xBE2E, 0x7BAF},\n};\n\n \nstatic const struct rtl8366rb_jam_tbl_entry rtl8366rb_init_jam_ver_1[] = {\n\t{0x0000, 0x0830}, {0x0001, 0x8000}, {0x0400, 0x8130}, {0xBE78, 0x3C3C},\n\t{0x0431, 0x5432}, {0xBE37, 0x0CE4}, {0x02FA, 0xFFDF}, {0x02FB, 0xFFE0},\n\t{0xC44C, 0x1585}, {0xC44C, 0x1185}, {0xC44C, 0x1585}, {0xC46C, 0x1585},\n\t{0xC46C, 0x1185}, {0xC46C, 0x1585}, {0xC451, 0x2135}, {0xC471, 0x2135},\n\t{0xBE10, 0x8140}, {0xBE15, 0x0007}, {0xBE6E, 0xE120}, {0xBE69, 0xD20F},\n\t{0xBE6B, 0x0320}, {0xBE24, 0xB000}, {0xBE23, 0xFF51}, {0xBE22, 0xDF20},\n\t{0xBE21, 0x0140}, {0xBE20, 0x00BB}, {0xBE24, 0xB800}, {0xBE24, 0x0000},\n\t{0xBE24, 0x7000}, {0xBE23, 0xFF51}, {0xBE22, 0xDF60}, {0xBE21, 0x0140},\n\t{0xBE20, 0x0077}, {0xBE24, 0x7800}, {0xBE24, 0x0000}, {0xBE2E, 0x7B7A},\n\t{0xBE36, 0x0CE4}, {0x02F5, 0x0048}, {0xBE77, 0x2940}, {0x000A, 0x83E0},\n\t{0xBE79, 0x3C3C}, {0xBE00, 0x1340},\n};\n\n \nstatic const struct rtl8366rb_jam_tbl_entry rtl8366rb_init_jam_ver_2[] = {\n\t{0x0450, 0x0000}, {0x0400, 0x8130}, {0x000A, 0x83ED}, {0x0431, 0x5432},\n\t{0xC44F, 0x6250}, {0xC46F, 0x6250}, {0xC456, 0x0C14}, {0xC476, 0x0C14},\n\t{0xC44C, 0x1C85}, {0xC44C, 0x1885}, {0xC44C, 0x1C85}, {0xC46C, 0x1C85},\n\t{0xC46C, 0x1885}, {0xC46C, 0x1C85}, {0xC44C, 0x0885}, {0xC44C, 0x0881},\n\t{0xC44C, 0x0885}, {0xC46C, 0x0885}, {0xC46C, 0x0881}, {0xC46C, 0x0885},\n\t{0xBE2E, 0x7BA7}, {0xBE36, 0x1000}, {0xBE37, 0x1000}, {0x8000, 0x0001},\n\t{0xBE69, 0xD50F}, {0x8000, 0x0000}, {0xBE69, 0xD50F}, {0xBE6E, 0x0320},\n\t{0xBE77, 0x2940}, {0xBE78, 0x3C3C}, {0xBE79, 0x3C3C}, {0xBE6E, 0xE120},\n\t{0x8000, 0x0001}, {0xBE15, 0x1007}, {0x8000, 0x0000}, {0xBE15, 0x1007},\n\t{0xBE14, 0x0448}, {0xBE1E, 0x00A0}, {0xBE10, 0x8160}, {0xBE10, 0x8140},\n\t{0xBE00, 0x1340}, {0x0F51, 0x0010},\n};\n\n \nstatic const struct rtl8366rb_jam_tbl_entry rtl8366rb_init_jam_ver_3[] = {\n\t{0x0000, 0x0830}, {0x0400, 0x8130}, {0x000A, 0x83ED}, {0x0431, 0x5432},\n\t{0x0F51, 0x0017}, {0x02F5, 0x0048}, {0x02FA, 0xFFDF}, {0x02FB, 0xFFE0},\n\t{0xC456, 0x0C14}, {0xC476, 0x0C14}, {0xC454, 0x3F8B}, {0xC474, 0x3F8B},\n\t{0xC450, 0x2071}, {0xC470, 0x2071}, {0xC451, 0x226B}, {0xC471, 0x226B},\n\t{0xC452, 0xA293}, {0xC472, 0xA293}, {0xC44C, 0x1585}, {0xC44C, 0x1185},\n\t{0xC44C, 0x1585}, {0xC46C, 0x1585}, {0xC46C, 0x1185}, {0xC46C, 0x1585},\n\t{0xC44C, 0x0185}, {0xC44C, 0x0181}, {0xC44C, 0x0185}, {0xC46C, 0x0185},\n\t{0xC46C, 0x0181}, {0xC46C, 0x0185}, {0xBE24, 0xB000}, {0xBE23, 0xFF51},\n\t{0xBE22, 0xDF20}, {0xBE21, 0x0140}, {0xBE20, 0x00BB}, {0xBE24, 0xB800},\n\t{0xBE24, 0x0000}, {0xBE24, 0x7000}, {0xBE23, 0xFF51}, {0xBE22, 0xDF60},\n\t{0xBE21, 0x0140}, {0xBE20, 0x0077}, {0xBE24, 0x7800}, {0xBE24, 0x0000},\n\t{0xBE2E, 0x7BA7}, {0xBE36, 0x1000}, {0xBE37, 0x1000}, {0x8000, 0x0001},\n\t{0xBE69, 0xD50F}, {0x8000, 0x0000}, {0xBE69, 0xD50F}, {0xBE6B, 0x0320},\n\t{0xBE77, 0x2800}, {0xBE78, 0x3C3C}, {0xBE79, 0x3C3C}, {0xBE6E, 0xE120},\n\t{0x8000, 0x0001}, {0xBE10, 0x8140}, {0x8000, 0x0000}, {0xBE10, 0x8140},\n\t{0xBE15, 0x1007}, {0xBE14, 0x0448}, {0xBE1E, 0x00A0}, {0xBE10, 0x8160},\n\t{0xBE10, 0x8140}, {0xBE00, 0x1340}, {0x0450, 0x0000}, {0x0401, 0x0000},\n};\n\n \nstatic const struct rtl8366rb_jam_tbl_entry rtl8366rb_init_jam_f5d8235[] = {\n\t{0x0242, 0x02BF}, {0x0245, 0x02BF}, {0x0248, 0x02BF}, {0x024B, 0x02BF},\n\t{0x024E, 0x02BF}, {0x0251, 0x02BF}, {0x0254, 0x0A3F}, {0x0256, 0x0A3F},\n\t{0x0258, 0x0A3F}, {0x025A, 0x0A3F}, {0x025C, 0x0A3F}, {0x025E, 0x0A3F},\n\t{0x0263, 0x007C}, {0x0100, 0x0004}, {0xBE5B, 0x3500}, {0x800E, 0x200F},\n\t{0xBE1D, 0x0F00}, {0x8001, 0x5011}, {0x800A, 0xA2F4}, {0x800B, 0x17A3},\n\t{0xBE4B, 0x17A3}, {0xBE41, 0x5011}, {0xBE17, 0x2100}, {0x8000, 0x8304},\n\t{0xBE40, 0x8304}, {0xBE4A, 0xA2F4}, {0x800C, 0xA8D5}, {0x8014, 0x5500},\n\t{0x8015, 0x0004}, {0xBE4C, 0xA8D5}, {0xBE59, 0x0008}, {0xBE09, 0x0E00},\n\t{0xBE36, 0x1036}, {0xBE37, 0x1036}, {0x800D, 0x00FF}, {0xBE4D, 0x00FF},\n};\n\n \nstatic const struct rtl8366rb_jam_tbl_entry rtl8366rb_init_jam_dgn3500[] = {\n\t{0x0000, 0x0830}, {0x0400, 0x8130}, {0x000A, 0x83ED}, {0x0F51, 0x0017},\n\t{0x02F5, 0x0048}, {0x02FA, 0xFFDF}, {0x02FB, 0xFFE0}, {0x0450, 0x0000},\n\t{0x0401, 0x0000}, {0x0431, 0x0960},\n};\n\n \nstatic const struct rtl8366rb_jam_tbl_entry rtl8366rb_green_jam[] = {\n\t{0xBE78, 0x323C}, {0xBE77, 0x5000}, {0xBE2E, 0x7BA7},\n\t{0xBE59, 0x3459}, {0xBE5A, 0x745A}, {0xBE5B, 0x785C},\n\t{0xBE5C, 0x785C}, {0xBE6E, 0xE120}, {0xBE79, 0x323C},\n};\n\n \nstatic int rtl8366rb_jam_table(const struct rtl8366rb_jam_tbl_entry *jam_table,\n\t\t\t       int jam_size, struct realtek_priv *priv,\n\t\t\t       bool write_dbg)\n{\n\tu32 val;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < jam_size; i++) {\n\t\tif ((jam_table[i].reg & 0xBE00) == 0xBE00) {\n\t\t\tret = regmap_read(priv->map,\n\t\t\t\t\t  RTL8366RB_PHY_ACCESS_BUSY_REG,\n\t\t\t\t\t  &val);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tif (!(val & RTL8366RB_PHY_INT_BUSY)) {\n\t\t\t\tret = regmap_write(priv->map,\n\t\t\t\t\t\t   RTL8366RB_PHY_ACCESS_CTRL_REG,\n\t\t\t\t\t\t   RTL8366RB_PHY_CTRL_WRITE);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tif (write_dbg)\n\t\t\tdev_dbg(priv->dev, \"jam %04x into register %04x\\n\",\n\t\t\t\tjam_table[i].val,\n\t\t\t\tjam_table[i].reg);\n\t\tret = regmap_write(priv->map,\n\t\t\t\t   jam_table[i].reg,\n\t\t\t\t   jam_table[i].val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int rtl8366rb_setup(struct dsa_switch *ds)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\tconst struct rtl8366rb_jam_tbl_entry *jam_table;\n\tstruct rtl8366rb *rb;\n\tu32 chip_ver = 0;\n\tu32 chip_id = 0;\n\tint jam_size;\n\tu32 val;\n\tint ret;\n\tint i;\n\n\trb = priv->chip_data;\n\n\tret = regmap_read(priv->map, RTL8366RB_CHIP_ID_REG, &chip_id);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"unable to read chip id\\n\");\n\t\treturn ret;\n\t}\n\n\tswitch (chip_id) {\n\tcase RTL8366RB_CHIP_ID_8366:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(priv->dev, \"unknown chip id (%04x)\\n\", chip_id);\n\t\treturn -ENODEV;\n\t}\n\n\tret = regmap_read(priv->map, RTL8366RB_CHIP_VERSION_CTRL_REG,\n\t\t\t  &chip_ver);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"unable to read chip version\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_info(priv->dev, \"RTL%04x ver %u chip found\\n\",\n\t\t chip_id, chip_ver & RTL8366RB_CHIP_VERSION_MASK);\n\n\t \n\tswitch (chip_ver) {\n\tcase 0:\n\t\tjam_table = rtl8366rb_init_jam_ver_0;\n\t\tjam_size = ARRAY_SIZE(rtl8366rb_init_jam_ver_0);\n\t\tbreak;\n\tcase 1:\n\t\tjam_table = rtl8366rb_init_jam_ver_1;\n\t\tjam_size = ARRAY_SIZE(rtl8366rb_init_jam_ver_1);\n\t\tbreak;\n\tcase 2:\n\t\tjam_table = rtl8366rb_init_jam_ver_2;\n\t\tjam_size = ARRAY_SIZE(rtl8366rb_init_jam_ver_2);\n\t\tbreak;\n\tdefault:\n\t\tjam_table = rtl8366rb_init_jam_ver_3;\n\t\tjam_size = ARRAY_SIZE(rtl8366rb_init_jam_ver_3);\n\t\tbreak;\n\t}\n\n\t \n\tif (of_machine_is_compatible(\"belkin,f5d8235-v1\")) {\n\t\tjam_table = rtl8366rb_init_jam_f5d8235;\n\t\tjam_size = ARRAY_SIZE(rtl8366rb_init_jam_f5d8235);\n\t}\n\tif (of_machine_is_compatible(\"netgear,dgn3500\") ||\n\t    of_machine_is_compatible(\"netgear,dgn3500b\")) {\n\t\tjam_table = rtl8366rb_init_jam_dgn3500;\n\t\tjam_size = ARRAY_SIZE(rtl8366rb_init_jam_dgn3500);\n\t}\n\n\tret = rtl8366rb_jam_table(jam_table, jam_size, priv, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < RTL8366RB_PORT_NUM_CPU; i++) {\n\t\tret = regmap_write(priv->map, RTL8366RB_PORT_ISO(i),\n\t\t\t\t   RTL8366RB_PORT_ISO_PORTS(BIT(RTL8366RB_PORT_NUM_CPU)) |\n\t\t\t\t   RTL8366RB_PORT_ISO_EN);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\t \n\tret = regmap_write(priv->map, RTL8366RB_PORT_ISO(RTL8366RB_PORT_NUM_CPU),\n\t\t\t   RTL8366RB_PORT_ISO_PORTS(dsa_user_ports(ds)) |\n\t\t\t   RTL8366RB_PORT_ISO_EN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = rtl8366rb_jam_table(rtl8366rb_green_jam,\n\t\t\t\t  ARRAY_SIZE(rtl8366rb_green_jam), priv, false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_write(priv->map,\n\t\t\t   RTL8366RB_GREEN_FEATURE_REG,\n\t\t\t   (chip_ver == 1) ? 0x0007 : 0x0003);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(priv->map, 0x0c, 0x240);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_write(priv->map, 0x0d, 0x240);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = rtl8366rb_set_addr(priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(priv->map, RTL8368RB_CPU_CTRL_REG,\n\t\t\t\t 0xFFFF,\n\t\t\t\t BIT(priv->cpu_port));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(priv->map, RTL8366RB_PECR,\n\t\t\t\t BIT(priv->cpu_port),\n\t\t\t\t 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(priv->map, RTL8366RB_SGCR,\n\t\t\t\t RTL8366RB_SGCR_MAX_LENGTH_MASK,\n\t\t\t\t RTL8366RB_SGCR_MAX_LENGTH_1536);\n\tif (ret)\n\t\treturn ret;\n\tfor (i = 0; i < RTL8366RB_NUM_PORTS; i++)\n\t\t \n\t\trb->max_mtu[i] = 1532;\n\n\t \n\tret = regmap_write(priv->map, RTL8366RB_PORT_LEARNDIS_CTRL,\n\t\t\t   RTL8366RB_PORT_ALL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(priv->map, RTL8366RB_SECURITY_CTRL, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(priv->map, RTL8366RB_PMC0,\n\t\t\t\t RTL8366RB_PMC0_P4_IOMODE_MASK,\n\t\t\t\t 0 << RTL8366RB_PMC0_P4_IOMODE_SHIFT);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(priv->map, RTL8366RB_VLAN_INGRESS_CTRL1_REG,\n\t\t\t   0);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_write(priv->map, RTL8366RB_VLAN_INGRESS_CTRL2_REG,\n\t\t\t   0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(priv->map, RTL8366RB_SSCR2,\n\t\t\t\t RTL8366RB_SSCR2_DROP_UNKNOWN_DA, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(priv->map, RTL8366RB_LED_BLINKRATE_REG,\n\t\t\t\t RTL8366RB_LED_BLINKRATE_MASK,\n\t\t\t\t RTL8366RB_LED_BLINKRATE_56MS);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (priv->leds_disabled) {\n\t\t \n\t\tregmap_update_bits(priv->map,\n\t\t\t\t   RTL8366RB_LED_0_1_CTRL_REG,\n\t\t\t\t   0x0FFF, 0);\n\t\tregmap_update_bits(priv->map,\n\t\t\t\t   RTL8366RB_LED_2_3_CTRL_REG,\n\t\t\t\t   0x0FFF, 0);\n\t\tregmap_update_bits(priv->map,\n\t\t\t\t   RTL8366RB_INTERRUPT_CONTROL_REG,\n\t\t\t\t   RTL8366RB_P4_RGMII_LED,\n\t\t\t\t   0);\n\t\tval = RTL8366RB_LED_OFF;\n\t} else {\n\t\t \n\t\tval = RTL8366RB_LED_FORCE;\n\t}\n\tfor (i = 0; i < 4; i++) {\n\t\tret = regmap_update_bits(priv->map,\n\t\t\t\t\t RTL8366RB_LED_CTRL_REG,\n\t\t\t\t\t 0xf << (i * 4),\n\t\t\t\t\t val << (i * 4));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = rtl8366_reset_vlan(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rtl8366rb_setup_cascaded_irq(priv);\n\tif (ret)\n\t\tdev_info(priv->dev, \"no interrupt support\\n\");\n\n\tif (priv->setup_interface) {\n\t\tret = priv->setup_interface(ds);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"could not set up MDIO bus\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic enum dsa_tag_protocol rtl8366_get_tag_protocol(struct dsa_switch *ds,\n\t\t\t\t\t\t      int port,\n\t\t\t\t\t\t      enum dsa_tag_protocol mp)\n{\n\t \n\treturn DSA_TAG_PROTO_RTL4_A;\n}\n\nstatic void rtl8366rb_phylink_get_caps(struct dsa_switch *ds, int port,\n\t\t\t\t       struct phylink_config *config)\n{\n\tunsigned long *interfaces = config->supported_interfaces;\n\tstruct realtek_priv *priv = ds->priv;\n\n\tif (port == priv->cpu_port) {\n\t\t__set_bit(PHY_INTERFACE_MODE_MII, interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_GMII, interfaces);\n\t\t \n\t\t__set_bit(PHY_INTERFACE_MODE_REVMII, interfaces);\n\t\t \n\t\tphy_interface_set_rgmii(interfaces);\n\n\t\tconfig->mac_capabilities = MAC_1000 | MAC_100 |\n\t\t\t\t\t   MAC_SYM_PAUSE;\n\t} else {\n\t\t \n\t\t__set_bit(PHY_INTERFACE_MODE_GMII, interfaces);\n\t\tconfig->mac_capabilities = MAC_1000 | MAC_100 | MAC_10 |\n\t\t\t\t\t   MAC_SYM_PAUSE | MAC_ASYM_PAUSE;\n\t}\n}\n\nstatic void\nrtl8366rb_mac_link_up(struct dsa_switch *ds, int port, unsigned int mode,\n\t\t      phy_interface_t interface, struct phy_device *phydev,\n\t\t      int speed, int duplex, bool tx_pause, bool rx_pause)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\tint ret;\n\n\tif (port != priv->cpu_port)\n\t\treturn;\n\n\tdev_dbg(priv->dev, \"MAC link up on CPU port (%d)\\n\", port);\n\n\t \n\tret = regmap_update_bits(priv->map, RTL8366RB_MAC_FORCE_CTRL_REG,\n\t\t\t\t BIT(port), BIT(port));\n\tif (ret) {\n\t\tdev_err(priv->dev, \"failed to force 1Gbit on CPU port\\n\");\n\t\treturn;\n\t}\n\n\tret = regmap_update_bits(priv->map, RTL8366RB_PAACR2,\n\t\t\t\t 0xFF00U,\n\t\t\t\t RTL8366RB_PAACR_CPU_PORT << 8);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"failed to set PAACR on CPU port\\n\");\n\t\treturn;\n\t}\n\n\t \n\tret = regmap_update_bits(priv->map, RTL8366RB_PECR, BIT(port),\n\t\t\t\t 0);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"failed to enable the CPU port\\n\");\n\t\treturn;\n\t}\n}\n\nstatic void\nrtl8366rb_mac_link_down(struct dsa_switch *ds, int port, unsigned int mode,\n\t\t\tphy_interface_t interface)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\tint ret;\n\n\tif (port != priv->cpu_port)\n\t\treturn;\n\n\tdev_dbg(priv->dev, \"MAC link down on CPU port (%d)\\n\", port);\n\n\t \n\tret = regmap_update_bits(priv->map, RTL8366RB_PECR, BIT(port),\n\t\t\t\t BIT(port));\n\tif (ret) {\n\t\tdev_err(priv->dev, \"failed to disable the CPU port\\n\");\n\t\treturn;\n\t}\n}\n\nstatic void rb8366rb_set_port_led(struct realtek_priv *priv,\n\t\t\t\t  int port, bool enable)\n{\n\tu16 val = enable ? 0x3f : 0;\n\tint ret;\n\n\tif (priv->leds_disabled)\n\t\treturn;\n\n\tswitch (port) {\n\tcase 0:\n\t\tret = regmap_update_bits(priv->map,\n\t\t\t\t\t RTL8366RB_LED_0_1_CTRL_REG,\n\t\t\t\t\t 0x3F, val);\n\t\tbreak;\n\tcase 1:\n\t\tret = regmap_update_bits(priv->map,\n\t\t\t\t\t RTL8366RB_LED_0_1_CTRL_REG,\n\t\t\t\t\t 0x3F << RTL8366RB_LED_1_OFFSET,\n\t\t\t\t\t val << RTL8366RB_LED_1_OFFSET);\n\t\tbreak;\n\tcase 2:\n\t\tret = regmap_update_bits(priv->map,\n\t\t\t\t\t RTL8366RB_LED_2_3_CTRL_REG,\n\t\t\t\t\t 0x3F, val);\n\t\tbreak;\n\tcase 3:\n\t\tret = regmap_update_bits(priv->map,\n\t\t\t\t\t RTL8366RB_LED_2_3_CTRL_REG,\n\t\t\t\t\t 0x3F << RTL8366RB_LED_3_OFFSET,\n\t\t\t\t\t val << RTL8366RB_LED_3_OFFSET);\n\t\tbreak;\n\tcase 4:\n\t\tret = regmap_update_bits(priv->map,\n\t\t\t\t\t RTL8366RB_INTERRUPT_CONTROL_REG,\n\t\t\t\t\t RTL8366RB_P4_RGMII_LED,\n\t\t\t\t\t enable ? RTL8366RB_P4_RGMII_LED : 0);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(priv->dev, \"no LED for port %d\\n\", port);\n\t\treturn;\n\t}\n\tif (ret)\n\t\tdev_err(priv->dev, \"error updating LED on port %d\\n\", port);\n}\n\nstatic int\nrtl8366rb_port_enable(struct dsa_switch *ds, int port,\n\t\t      struct phy_device *phy)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\tint ret;\n\n\tdev_dbg(priv->dev, \"enable port %d\\n\", port);\n\tret = regmap_update_bits(priv->map, RTL8366RB_PECR, BIT(port),\n\t\t\t\t 0);\n\tif (ret)\n\t\treturn ret;\n\n\trb8366rb_set_port_led(priv, port, true);\n\treturn 0;\n}\n\nstatic void\nrtl8366rb_port_disable(struct dsa_switch *ds, int port)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\tint ret;\n\n\tdev_dbg(priv->dev, \"disable port %d\\n\", port);\n\tret = regmap_update_bits(priv->map, RTL8366RB_PECR, BIT(port),\n\t\t\t\t BIT(port));\n\tif (ret)\n\t\treturn;\n\n\trb8366rb_set_port_led(priv, port, false);\n}\n\nstatic int\nrtl8366rb_port_bridge_join(struct dsa_switch *ds, int port,\n\t\t\t   struct dsa_bridge bridge,\n\t\t\t   bool *tx_fwd_offload,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\tunsigned int port_bitmap = 0;\n\tint ret, i;\n\n\t \n\tfor (i = 0; i < RTL8366RB_PORT_NUM_CPU; i++) {\n\t\t \n\t\tif (i == port)\n\t\t\tcontinue;\n\t\t \n\t\tif (!dsa_port_offloads_bridge(dsa_to_port(ds, i), &bridge))\n\t\t\tcontinue;\n\t\t \n\t\tret = regmap_update_bits(priv->map, RTL8366RB_PORT_ISO(i),\n\t\t\t\t\t RTL8366RB_PORT_ISO_PORTS(BIT(port)),\n\t\t\t\t\t RTL8366RB_PORT_ISO_PORTS(BIT(port)));\n\t\tif (ret)\n\t\t\tdev_err(priv->dev, \"failed to join port %d\\n\", port);\n\n\t\tport_bitmap |= BIT(i);\n\t}\n\n\t \n\treturn regmap_update_bits(priv->map, RTL8366RB_PORT_ISO(port),\n\t\t\t\t  RTL8366RB_PORT_ISO_PORTS(port_bitmap),\n\t\t\t\t  RTL8366RB_PORT_ISO_PORTS(port_bitmap));\n}\n\nstatic void\nrtl8366rb_port_bridge_leave(struct dsa_switch *ds, int port,\n\t\t\t    struct dsa_bridge bridge)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\tunsigned int port_bitmap = 0;\n\tint ret, i;\n\n\t \n\tfor (i = 0; i < RTL8366RB_PORT_NUM_CPU; i++) {\n\t\t \n\t\tif (i == port)\n\t\t\tcontinue;\n\t\t \n\t\tif (!dsa_port_offloads_bridge(dsa_to_port(ds, i), &bridge))\n\t\t\tcontinue;\n\t\t \n\t\tret = regmap_update_bits(priv->map, RTL8366RB_PORT_ISO(i),\n\t\t\t\t\t RTL8366RB_PORT_ISO_PORTS(BIT(port)), 0);\n\t\tif (ret)\n\t\t\tdev_err(priv->dev, \"failed to leave port %d\\n\", port);\n\n\t\tport_bitmap |= BIT(i);\n\t}\n\n\t \n\tregmap_update_bits(priv->map, RTL8366RB_PORT_ISO(port),\n\t\t\t   RTL8366RB_PORT_ISO_PORTS(port_bitmap), 0);\n}\n\n \nstatic int rtl8366rb_drop_untagged(struct realtek_priv *priv, int port, bool drop)\n{\n\treturn regmap_update_bits(priv->map, RTL8366RB_VLAN_INGRESS_CTRL1_REG,\n\t\t\t\t  RTL8366RB_VLAN_INGRESS_CTRL1_DROP(port),\n\t\t\t\t  drop ? RTL8366RB_VLAN_INGRESS_CTRL1_DROP(port) : 0);\n}\n\nstatic int rtl8366rb_vlan_filtering(struct dsa_switch *ds, int port,\n\t\t\t\t    bool vlan_filtering,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\tstruct rtl8366rb *rb;\n\tint ret;\n\n\trb = priv->chip_data;\n\n\tdev_dbg(priv->dev, \"port %d: %s VLAN filtering\\n\", port,\n\t\tvlan_filtering ? \"enable\" : \"disable\");\n\n\t \n\tret = regmap_update_bits(priv->map, RTL8366RB_VLAN_INGRESS_CTRL2_REG,\n\t\t\t\t BIT(port), vlan_filtering ? BIT(port) : 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (vlan_filtering)\n\t\tret = rtl8366rb_drop_untagged(priv, port, !rb->pvid_enabled[port]);\n\telse\n\t\tret = rtl8366rb_drop_untagged(priv, port, false);\n\n\treturn ret;\n}\n\nstatic int\nrtl8366rb_port_pre_bridge_flags(struct dsa_switch *ds, int port,\n\t\t\t\tstruct switchdev_brport_flags flags,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\t \n\tif (flags.mask & ~(BR_LEARNING))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int\nrtl8366rb_port_bridge_flags(struct dsa_switch *ds, int port,\n\t\t\t    struct switchdev_brport_flags flags,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\tint ret;\n\n\tif (flags.mask & BR_LEARNING) {\n\t\tret = regmap_update_bits(priv->map, RTL8366RB_PORT_LEARNDIS_CTRL,\n\t\t\t\t\t BIT(port),\n\t\t\t\t\t (flags.val & BR_LEARNING) ? 0 : BIT(port));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nrtl8366rb_port_stp_state_set(struct dsa_switch *ds, int port, u8 state)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\tu32 val;\n\tint i;\n\n\tswitch (state) {\n\tcase BR_STATE_DISABLED:\n\t\tval = RTL8366RB_STP_STATE_DISABLED;\n\t\tbreak;\n\tcase BR_STATE_BLOCKING:\n\tcase BR_STATE_LISTENING:\n\t\tval = RTL8366RB_STP_STATE_BLOCKING;\n\t\tbreak;\n\tcase BR_STATE_LEARNING:\n\t\tval = RTL8366RB_STP_STATE_LEARNING;\n\t\tbreak;\n\tcase BR_STATE_FORWARDING:\n\t\tval = RTL8366RB_STP_STATE_FORWARDING;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(priv->dev, \"unknown bridge state requested\\n\");\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0; i < RTL8366RB_NUM_FIDS; i++) {\n\t\tregmap_update_bits(priv->map, RTL8366RB_STP_STATE_BASE + i,\n\t\t\t\t   RTL8366RB_STP_STATE_MASK(port),\n\t\t\t\t   RTL8366RB_STP_STATE(port, val));\n\t}\n}\n\nstatic void\nrtl8366rb_port_fast_age(struct dsa_switch *ds, int port)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\n\t \n\tregmap_update_bits(priv->map, RTL8366RB_SECURITY_CTRL,\n\t\t\t   BIT(port), BIT(port));\n\t \n\tregmap_update_bits(priv->map, RTL8366RB_SECURITY_CTRL,\n\t\t\t   BIT(port), 0);\n}\n\nstatic int rtl8366rb_change_mtu(struct dsa_switch *ds, int port, int new_mtu)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\tstruct rtl8366rb *rb;\n\tunsigned int max_mtu;\n\tu32 len;\n\tint i;\n\n\t \n\trb = priv->chip_data;\n\trb->max_mtu[port] = new_mtu;\n\n\t \n\tmax_mtu = 1518;\n\tfor (i = 0; i < RTL8366RB_NUM_PORTS; i++) {\n\t\tif (rb->max_mtu[i] > max_mtu)\n\t\t\tmax_mtu = rb->max_mtu[i];\n\t}\n\tif (max_mtu <= 1518)\n\t\tlen = RTL8366RB_SGCR_MAX_LENGTH_1522;\n\telse if (max_mtu > 1518 && max_mtu <= 1532)\n\t\tlen = RTL8366RB_SGCR_MAX_LENGTH_1536;\n\telse if (max_mtu > 1532 && max_mtu <= 1548)\n\t\tlen = RTL8366RB_SGCR_MAX_LENGTH_1552;\n\telse\n\t\tlen = RTL8366RB_SGCR_MAX_LENGTH_16000;\n\n\treturn regmap_update_bits(priv->map, RTL8366RB_SGCR,\n\t\t\t\t  RTL8366RB_SGCR_MAX_LENGTH_MASK,\n\t\t\t\t  len);\n}\n\nstatic int rtl8366rb_max_mtu(struct dsa_switch *ds, int port)\n{\n\t \n\treturn 15996;\n}\n\nstatic int rtl8366rb_get_vlan_4k(struct realtek_priv *priv, u32 vid,\n\t\t\t\t struct rtl8366_vlan_4k *vlan4k)\n{\n\tu32 data[3];\n\tint ret;\n\tint i;\n\n\tmemset(vlan4k, '\\0', sizeof(struct rtl8366_vlan_4k));\n\n\tif (vid >= RTL8366RB_NUM_VIDS)\n\t\treturn -EINVAL;\n\n\t \n\tret = regmap_write(priv->map, RTL8366RB_VLAN_TABLE_WRITE_BASE,\n\t\t\t   vid & RTL8366RB_VLAN_VID_MASK);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(priv->map, RTL8366RB_TABLE_ACCESS_CTRL_REG,\n\t\t\t   RTL8366RB_TABLE_VLAN_READ_CTRL);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tret = regmap_read(priv->map,\n\t\t\t\t  RTL8366RB_VLAN_TABLE_READ_BASE + i,\n\t\t\t\t  &data[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tvlan4k->vid = vid;\n\tvlan4k->untag = (data[1] >> RTL8366RB_VLAN_UNTAG_SHIFT) &\n\t\t\tRTL8366RB_VLAN_UNTAG_MASK;\n\tvlan4k->member = data[1] & RTL8366RB_VLAN_MEMBER_MASK;\n\tvlan4k->fid = data[2] & RTL8366RB_VLAN_FID_MASK;\n\n\treturn 0;\n}\n\nstatic int rtl8366rb_set_vlan_4k(struct realtek_priv *priv,\n\t\t\t\t const struct rtl8366_vlan_4k *vlan4k)\n{\n\tu32 data[3];\n\tint ret;\n\tint i;\n\n\tif (vlan4k->vid >= RTL8366RB_NUM_VIDS ||\n\t    vlan4k->member > RTL8366RB_VLAN_MEMBER_MASK ||\n\t    vlan4k->untag > RTL8366RB_VLAN_UNTAG_MASK ||\n\t    vlan4k->fid > RTL8366RB_FIDMAX)\n\t\treturn -EINVAL;\n\n\tdata[0] = vlan4k->vid & RTL8366RB_VLAN_VID_MASK;\n\tdata[1] = (vlan4k->member & RTL8366RB_VLAN_MEMBER_MASK) |\n\t\t  ((vlan4k->untag & RTL8366RB_VLAN_UNTAG_MASK) <<\n\t\t\tRTL8366RB_VLAN_UNTAG_SHIFT);\n\tdata[2] = vlan4k->fid & RTL8366RB_VLAN_FID_MASK;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tret = regmap_write(priv->map,\n\t\t\t\t   RTL8366RB_VLAN_TABLE_WRITE_BASE + i,\n\t\t\t\t   data[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_write(priv->map, RTL8366RB_TABLE_ACCESS_CTRL_REG,\n\t\t\t   RTL8366RB_TABLE_VLAN_WRITE_CTRL);\n\n\treturn ret;\n}\n\nstatic int rtl8366rb_get_vlan_mc(struct realtek_priv *priv, u32 index,\n\t\t\t\t struct rtl8366_vlan_mc *vlanmc)\n{\n\tu32 data[3];\n\tint ret;\n\tint i;\n\n\tmemset(vlanmc, '\\0', sizeof(struct rtl8366_vlan_mc));\n\n\tif (index >= RTL8366RB_NUM_VLANS)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tret = regmap_read(priv->map,\n\t\t\t\t  RTL8366RB_VLAN_MC_BASE(index) + i,\n\t\t\t\t  &data[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tvlanmc->vid = data[0] & RTL8366RB_VLAN_VID_MASK;\n\tvlanmc->priority = (data[0] >> RTL8366RB_VLAN_PRIORITY_SHIFT) &\n\t\tRTL8366RB_VLAN_PRIORITY_MASK;\n\tvlanmc->untag = (data[1] >> RTL8366RB_VLAN_UNTAG_SHIFT) &\n\t\tRTL8366RB_VLAN_UNTAG_MASK;\n\tvlanmc->member = data[1] & RTL8366RB_VLAN_MEMBER_MASK;\n\tvlanmc->fid = data[2] & RTL8366RB_VLAN_FID_MASK;\n\n\treturn 0;\n}\n\nstatic int rtl8366rb_set_vlan_mc(struct realtek_priv *priv, u32 index,\n\t\t\t\t const struct rtl8366_vlan_mc *vlanmc)\n{\n\tu32 data[3];\n\tint ret;\n\tint i;\n\n\tif (index >= RTL8366RB_NUM_VLANS ||\n\t    vlanmc->vid >= RTL8366RB_NUM_VIDS ||\n\t    vlanmc->priority > RTL8366RB_PRIORITYMAX ||\n\t    vlanmc->member > RTL8366RB_VLAN_MEMBER_MASK ||\n\t    vlanmc->untag > RTL8366RB_VLAN_UNTAG_MASK ||\n\t    vlanmc->fid > RTL8366RB_FIDMAX)\n\t\treturn -EINVAL;\n\n\tdata[0] = (vlanmc->vid & RTL8366RB_VLAN_VID_MASK) |\n\t\t  ((vlanmc->priority & RTL8366RB_VLAN_PRIORITY_MASK) <<\n\t\t\tRTL8366RB_VLAN_PRIORITY_SHIFT);\n\tdata[1] = (vlanmc->member & RTL8366RB_VLAN_MEMBER_MASK) |\n\t\t  ((vlanmc->untag & RTL8366RB_VLAN_UNTAG_MASK) <<\n\t\t\tRTL8366RB_VLAN_UNTAG_SHIFT);\n\tdata[2] = vlanmc->fid & RTL8366RB_VLAN_FID_MASK;\n\n\tfor (i = 0; i < 3; i++) {\n\t\tret = regmap_write(priv->map,\n\t\t\t\t   RTL8366RB_VLAN_MC_BASE(index) + i,\n\t\t\t\t   data[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtl8366rb_get_mc_index(struct realtek_priv *priv, int port, int *val)\n{\n\tu32 data;\n\tint ret;\n\n\tif (port >= priv->num_ports)\n\t\treturn -EINVAL;\n\n\tret = regmap_read(priv->map, RTL8366RB_PORT_VLAN_CTRL_REG(port),\n\t\t\t  &data);\n\tif (ret)\n\t\treturn ret;\n\n\t*val = (data >> RTL8366RB_PORT_VLAN_CTRL_SHIFT(port)) &\n\t\tRTL8366RB_PORT_VLAN_CTRL_MASK;\n\n\treturn 0;\n}\n\nstatic int rtl8366rb_set_mc_index(struct realtek_priv *priv, int port, int index)\n{\n\tstruct rtl8366rb *rb;\n\tbool pvid_enabled;\n\tint ret;\n\n\trb = priv->chip_data;\n\tpvid_enabled = !!index;\n\n\tif (port >= priv->num_ports || index >= RTL8366RB_NUM_VLANS)\n\t\treturn -EINVAL;\n\n\tret = regmap_update_bits(priv->map, RTL8366RB_PORT_VLAN_CTRL_REG(port),\n\t\t\t\t RTL8366RB_PORT_VLAN_CTRL_MASK <<\n\t\t\t\t\tRTL8366RB_PORT_VLAN_CTRL_SHIFT(port),\n\t\t\t\t (index & RTL8366RB_PORT_VLAN_CTRL_MASK) <<\n\t\t\t\t\tRTL8366RB_PORT_VLAN_CTRL_SHIFT(port));\n\tif (ret)\n\t\treturn ret;\n\n\trb->pvid_enabled[port] = pvid_enabled;\n\n\t \n\tif (dsa_port_is_vlan_filtering(dsa_to_port(priv->ds, port)))\n\t\tret = rtl8366rb_drop_untagged(priv, port, !pvid_enabled);\n\n\treturn ret;\n}\n\nstatic bool rtl8366rb_is_vlan_valid(struct realtek_priv *priv, unsigned int vlan)\n{\n\tunsigned int max = RTL8366RB_NUM_VLANS - 1;\n\n\tif (priv->vlan4k_enabled)\n\t\tmax = RTL8366RB_NUM_VIDS - 1;\n\n\tif (vlan > max)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int rtl8366rb_enable_vlan(struct realtek_priv *priv, bool enable)\n{\n\tdev_dbg(priv->dev, \"%s VLAN\\n\", enable ? \"enable\" : \"disable\");\n\treturn regmap_update_bits(priv->map,\n\t\t\t\t  RTL8366RB_SGCR, RTL8366RB_SGCR_EN_VLAN,\n\t\t\t\t  enable ? RTL8366RB_SGCR_EN_VLAN : 0);\n}\n\nstatic int rtl8366rb_enable_vlan4k(struct realtek_priv *priv, bool enable)\n{\n\tdev_dbg(priv->dev, \"%s VLAN 4k\\n\", enable ? \"enable\" : \"disable\");\n\treturn regmap_update_bits(priv->map, RTL8366RB_SGCR,\n\t\t\t\t  RTL8366RB_SGCR_EN_VLAN_4KTB,\n\t\t\t\t  enable ? RTL8366RB_SGCR_EN_VLAN_4KTB : 0);\n}\n\nstatic int rtl8366rb_phy_read(struct realtek_priv *priv, int phy, int regnum)\n{\n\tu32 val;\n\tu32 reg;\n\tint ret;\n\n\tif (phy > RTL8366RB_PHY_NO_MAX)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->map_lock);\n\n\tret = regmap_write(priv->map_nolock, RTL8366RB_PHY_ACCESS_CTRL_REG,\n\t\t\t   RTL8366RB_PHY_CTRL_READ);\n\tif (ret)\n\t\tgoto out;\n\n\treg = 0x8000 | (1 << (phy + RTL8366RB_PHY_NO_OFFSET)) | regnum;\n\n\tret = regmap_write(priv->map_nolock, reg, 0);\n\tif (ret) {\n\t\tdev_err(priv->dev,\n\t\t\t\"failed to write PHY%d reg %04x @ %04x, ret %d\\n\",\n\t\t\tphy, regnum, reg, ret);\n\t\tgoto out;\n\t}\n\n\tret = regmap_read(priv->map_nolock, RTL8366RB_PHY_ACCESS_DATA_REG,\n\t\t\t  &val);\n\tif (ret)\n\t\tgoto out;\n\n\tret = val;\n\n\tdev_dbg(priv->dev, \"read PHY%d register 0x%04x @ %08x, val <- %04x\\n\",\n\t\tphy, regnum, reg, val);\n\nout:\n\tmutex_unlock(&priv->map_lock);\n\n\treturn ret;\n}\n\nstatic int rtl8366rb_phy_write(struct realtek_priv *priv, int phy, int regnum,\n\t\t\t       u16 val)\n{\n\tu32 reg;\n\tint ret;\n\n\tif (phy > RTL8366RB_PHY_NO_MAX)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->map_lock);\n\n\tret = regmap_write(priv->map_nolock, RTL8366RB_PHY_ACCESS_CTRL_REG,\n\t\t\t   RTL8366RB_PHY_CTRL_WRITE);\n\tif (ret)\n\t\tgoto out;\n\n\treg = 0x8000 | (1 << (phy + RTL8366RB_PHY_NO_OFFSET)) | regnum;\n\n\tdev_dbg(priv->dev, \"write PHY%d register 0x%04x @ %04x, val -> %04x\\n\",\n\t\tphy, regnum, reg, val);\n\n\tret = regmap_write(priv->map_nolock, reg, val);\n\tif (ret)\n\t\tgoto out;\n\nout:\n\tmutex_unlock(&priv->map_lock);\n\n\treturn ret;\n}\n\nstatic int rtl8366rb_dsa_phy_read(struct dsa_switch *ds, int phy, int regnum)\n{\n\treturn rtl8366rb_phy_read(ds->priv, phy, regnum);\n}\n\nstatic int rtl8366rb_dsa_phy_write(struct dsa_switch *ds, int phy, int regnum,\n\t\t\t\t   u16 val)\n{\n\treturn rtl8366rb_phy_write(ds->priv, phy, regnum, val);\n}\n\nstatic int rtl8366rb_reset_chip(struct realtek_priv *priv)\n{\n\tint timeout = 10;\n\tu32 val;\n\tint ret;\n\n\tpriv->write_reg_noack(priv, RTL8366RB_RESET_CTRL_REG,\n\t\t\t      RTL8366RB_CHIP_CTRL_RESET_HW);\n\tdo {\n\t\tusleep_range(20000, 25000);\n\t\tret = regmap_read(priv->map, RTL8366RB_RESET_CTRL_REG, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!(val & RTL8366RB_CHIP_CTRL_RESET_HW))\n\t\t\tbreak;\n\t} while (--timeout);\n\n\tif (!timeout) {\n\t\tdev_err(priv->dev, \"timeout waiting for the switch to reset\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtl8366rb_detect(struct realtek_priv *priv)\n{\n\tstruct device *dev = priv->dev;\n\tint ret;\n\tu32 val;\n\n\t \n\tret = regmap_read(priv->map, 0x5c, &val);\n\tif (ret) {\n\t\tdev_err(dev, \"can't get chip ID (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tswitch (val) {\n\tcase 0x6027:\n\t\tdev_info(dev, \"found an RTL8366S switch\\n\");\n\t\tdev_err(dev, \"this switch is not yet supported, submit patches!\\n\");\n\t\treturn -ENODEV;\n\tcase 0x5937:\n\t\tdev_info(dev, \"found an RTL8366RB switch\\n\");\n\t\tpriv->cpu_port = RTL8366RB_PORT_NUM_CPU;\n\t\tpriv->num_ports = RTL8366RB_NUM_PORTS;\n\t\tpriv->num_vlan_mc = RTL8366RB_NUM_VLANS;\n\t\tpriv->mib_counters = rtl8366rb_mib_counters;\n\t\tpriv->num_mib_counters = ARRAY_SIZE(rtl8366rb_mib_counters);\n\t\tbreak;\n\tdefault:\n\t\tdev_info(dev, \"found an Unknown Realtek switch (id=0x%04x)\\n\",\n\t\t\t val);\n\t\tbreak;\n\t}\n\n\tret = rtl8366rb_reset_chip(priv);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic const struct dsa_switch_ops rtl8366rb_switch_ops_smi = {\n\t.get_tag_protocol = rtl8366_get_tag_protocol,\n\t.setup = rtl8366rb_setup,\n\t.phylink_get_caps = rtl8366rb_phylink_get_caps,\n\t.phylink_mac_link_up = rtl8366rb_mac_link_up,\n\t.phylink_mac_link_down = rtl8366rb_mac_link_down,\n\t.get_strings = rtl8366_get_strings,\n\t.get_ethtool_stats = rtl8366_get_ethtool_stats,\n\t.get_sset_count = rtl8366_get_sset_count,\n\t.port_bridge_join = rtl8366rb_port_bridge_join,\n\t.port_bridge_leave = rtl8366rb_port_bridge_leave,\n\t.port_vlan_filtering = rtl8366rb_vlan_filtering,\n\t.port_vlan_add = rtl8366_vlan_add,\n\t.port_vlan_del = rtl8366_vlan_del,\n\t.port_enable = rtl8366rb_port_enable,\n\t.port_disable = rtl8366rb_port_disable,\n\t.port_pre_bridge_flags = rtl8366rb_port_pre_bridge_flags,\n\t.port_bridge_flags = rtl8366rb_port_bridge_flags,\n\t.port_stp_state_set = rtl8366rb_port_stp_state_set,\n\t.port_fast_age = rtl8366rb_port_fast_age,\n\t.port_change_mtu = rtl8366rb_change_mtu,\n\t.port_max_mtu = rtl8366rb_max_mtu,\n};\n\nstatic const struct dsa_switch_ops rtl8366rb_switch_ops_mdio = {\n\t.get_tag_protocol = rtl8366_get_tag_protocol,\n\t.setup = rtl8366rb_setup,\n\t.phy_read = rtl8366rb_dsa_phy_read,\n\t.phy_write = rtl8366rb_dsa_phy_write,\n\t.phylink_get_caps = rtl8366rb_phylink_get_caps,\n\t.phylink_mac_link_up = rtl8366rb_mac_link_up,\n\t.phylink_mac_link_down = rtl8366rb_mac_link_down,\n\t.get_strings = rtl8366_get_strings,\n\t.get_ethtool_stats = rtl8366_get_ethtool_stats,\n\t.get_sset_count = rtl8366_get_sset_count,\n\t.port_bridge_join = rtl8366rb_port_bridge_join,\n\t.port_bridge_leave = rtl8366rb_port_bridge_leave,\n\t.port_vlan_filtering = rtl8366rb_vlan_filtering,\n\t.port_vlan_add = rtl8366_vlan_add,\n\t.port_vlan_del = rtl8366_vlan_del,\n\t.port_enable = rtl8366rb_port_enable,\n\t.port_disable = rtl8366rb_port_disable,\n\t.port_pre_bridge_flags = rtl8366rb_port_pre_bridge_flags,\n\t.port_bridge_flags = rtl8366rb_port_bridge_flags,\n\t.port_stp_state_set = rtl8366rb_port_stp_state_set,\n\t.port_fast_age = rtl8366rb_port_fast_age,\n\t.port_change_mtu = rtl8366rb_change_mtu,\n\t.port_max_mtu = rtl8366rb_max_mtu,\n};\n\nstatic const struct realtek_ops rtl8366rb_ops = {\n\t.detect\t\t= rtl8366rb_detect,\n\t.get_vlan_mc\t= rtl8366rb_get_vlan_mc,\n\t.set_vlan_mc\t= rtl8366rb_set_vlan_mc,\n\t.get_vlan_4k\t= rtl8366rb_get_vlan_4k,\n\t.set_vlan_4k\t= rtl8366rb_set_vlan_4k,\n\t.get_mc_index\t= rtl8366rb_get_mc_index,\n\t.set_mc_index\t= rtl8366rb_set_mc_index,\n\t.get_mib_counter = rtl8366rb_get_mib_counter,\n\t.is_vlan_valid\t= rtl8366rb_is_vlan_valid,\n\t.enable_vlan\t= rtl8366rb_enable_vlan,\n\t.enable_vlan4k\t= rtl8366rb_enable_vlan4k,\n\t.phy_read\t= rtl8366rb_phy_read,\n\t.phy_write\t= rtl8366rb_phy_write,\n};\n\nconst struct realtek_variant rtl8366rb_variant = {\n\t.ds_ops_smi = &rtl8366rb_switch_ops_smi,\n\t.ds_ops_mdio = &rtl8366rb_switch_ops_mdio,\n\t.ops = &rtl8366rb_ops,\n\t.clk_delay = 10,\n\t.cmd_read = 0xa9,\n\t.cmd_write = 0xa8,\n\t.chip_data_sz = sizeof(struct rtl8366rb),\n};\nEXPORT_SYMBOL_GPL(rtl8366rb_variant);\n\nMODULE_AUTHOR(\"Linus Walleij <linus.walleij@linaro.org>\");\nMODULE_DESCRIPTION(\"Driver for RTL8366RB ethernet switch\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}