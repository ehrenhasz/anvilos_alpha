{
  "module_name": "rtl8366-core.c",
  "hash_id": "a64c77c4ee5bfdaf82a145b515e797faaf00825ac9180015d76d9bcb7582a656",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/realtek/rtl8366-core.c",
  "human_readable_source": "\n \n#include <linux/if_bridge.h>\n#include <net/dsa.h>\n\n#include \"realtek.h\"\n\nint rtl8366_mc_is_used(struct realtek_priv *priv, int mc_index, int *used)\n{\n\tint ret;\n\tint i;\n\n\t*used = 0;\n\tfor (i = 0; i < priv->num_ports; i++) {\n\t\tint index = 0;\n\n\t\tret = priv->ops->get_mc_index(priv, i, &index);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (mc_index == index) {\n\t\t\t*used = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtl8366_mc_is_used);\n\n \nstatic int rtl8366_obtain_mc(struct realtek_priv *priv, int vid,\n\t\t\t     struct rtl8366_vlan_mc *vlanmc)\n{\n\tstruct rtl8366_vlan_4k vlan4k;\n\tint ret;\n\tint i;\n\n\t \n\tfor (i = 0; i < priv->num_vlan_mc; i++) {\n\t\tret = priv->ops->get_vlan_mc(priv, i, vlanmc);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"error searching for VLAN MC %d for VID %d\\n\",\n\t\t\t\ti, vid);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (vid == vlanmc->vid)\n\t\t\treturn i;\n\t}\n\n\t \n\tfor (i = 0; i < priv->num_vlan_mc; i++) {\n\t\tret = priv->ops->get_vlan_mc(priv, i, vlanmc);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"error searching for VLAN MC %d for VID %d\\n\",\n\t\t\t\ti, vid);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (vlanmc->vid == 0 && vlanmc->member == 0) {\n\t\t\t \n\t\t\tret = priv->ops->get_vlan_4k(priv, vid, &vlan4k);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(priv->dev, \"error looking for 4K VLAN MC %d for VID %d\\n\",\n\t\t\t\t\ti, vid);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tvlanmc->vid = vid;\n\t\t\tvlanmc->member = vlan4k.member;\n\t\t\tvlanmc->untag = vlan4k.untag;\n\t\t\tvlanmc->fid = vlan4k.fid;\n\t\t\tret = priv->ops->set_vlan_mc(priv, i, vlanmc);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(priv->dev, \"unable to set/update VLAN MC %d for VID %d\\n\",\n\t\t\t\t\ti, vid);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tdev_dbg(priv->dev, \"created new MC at index %d for VID %d\\n\",\n\t\t\t\ti, vid);\n\t\t\treturn i;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < priv->num_vlan_mc; i++) {\n\t\tint used;\n\n\t\tret = rtl8366_mc_is_used(priv, i, &used);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!used) {\n\t\t\t \n\t\t\tret = priv->ops->get_vlan_4k(priv, vid, &vlan4k);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tvlanmc->vid = vid;\n\t\t\tvlanmc->member = vlan4k.member;\n\t\t\tvlanmc->untag = vlan4k.untag;\n\t\t\tvlanmc->fid = vlan4k.fid;\n\t\t\tret = priv->ops->set_vlan_mc(priv, i, vlanmc);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(priv->dev, \"unable to set/update VLAN MC %d for VID %d\\n\",\n\t\t\t\t\ti, vid);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tdev_dbg(priv->dev, \"recycled MC at index %i for VID %d\\n\",\n\t\t\t\ti, vid);\n\t\t\treturn i;\n\t\t}\n\t}\n\n\tdev_err(priv->dev, \"all VLAN member configurations are in use\\n\");\n\treturn -ENOSPC;\n}\n\nint rtl8366_set_vlan(struct realtek_priv *priv, int vid, u32 member,\n\t\t     u32 untag, u32 fid)\n{\n\tstruct rtl8366_vlan_mc vlanmc;\n\tstruct rtl8366_vlan_4k vlan4k;\n\tint mc;\n\tint ret;\n\n\tif (!priv->ops->is_vlan_valid(priv, vid))\n\t\treturn -EINVAL;\n\n\tdev_dbg(priv->dev,\n\t\t\"setting VLAN%d 4k members: 0x%02x, untagged: 0x%02x\\n\",\n\t\tvid, member, untag);\n\n\t \n\tret = priv->ops->get_vlan_4k(priv, vid, &vlan4k);\n\tif (ret)\n\t\treturn ret;\n\n\tvlan4k.member |= member;\n\tvlan4k.untag |= untag;\n\tvlan4k.fid = fid;\n\tret = priv->ops->set_vlan_4k(priv, &vlan4k);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(priv->dev,\n\t\t\"resulting VLAN%d 4k members: 0x%02x, untagged: 0x%02x\\n\",\n\t\tvid, vlan4k.member, vlan4k.untag);\n\n\t \n\tret = rtl8366_obtain_mc(priv, vid, &vlanmc);\n\tif (ret < 0)\n\t\treturn ret;\n\tmc = ret;\n\n\t \n\tvlanmc.member |= member;\n\tvlanmc.untag |= untag;\n\tvlanmc.fid = fid;\n\n\t \n\tret = priv->ops->set_vlan_mc(priv, mc, &vlanmc);\n\tif (ret)\n\t\tdev_err(priv->dev, \"failed to commit changes to VLAN MC index %d for VID %d\\n\",\n\t\t\tmc, vid);\n\telse\n\t\tdev_dbg(priv->dev,\n\t\t\t\"resulting VLAN%d MC members: 0x%02x, untagged: 0x%02x\\n\",\n\t\t\tvid, vlanmc.member, vlanmc.untag);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(rtl8366_set_vlan);\n\nint rtl8366_set_pvid(struct realtek_priv *priv, unsigned int port,\n\t\t     unsigned int vid)\n{\n\tstruct rtl8366_vlan_mc vlanmc;\n\tint mc;\n\tint ret;\n\n\tif (!priv->ops->is_vlan_valid(priv, vid))\n\t\treturn -EINVAL;\n\n\t \n\tret = rtl8366_obtain_mc(priv, vid, &vlanmc);\n\tif (ret < 0)\n\t\treturn ret;\n\tmc = ret;\n\n\tret = priv->ops->set_mc_index(priv, port, mc);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"set PVID: failed to set MC index %d for port %d\\n\",\n\t\t\tmc, port);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(priv->dev, \"set PVID: the PVID for port %d set to %d using existing MC index %d\\n\",\n\t\tport, vid, mc);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtl8366_set_pvid);\n\nint rtl8366_enable_vlan4k(struct realtek_priv *priv, bool enable)\n{\n\tint ret;\n\n\t \n\tif (enable) {\n\t\t \n\t\tret = priv->ops->enable_vlan(priv, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpriv->vlan_enabled = true;\n\t}\n\n\tret = priv->ops->enable_vlan4k(priv, enable);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->vlan4k_enabled = enable;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtl8366_enable_vlan4k);\n\nint rtl8366_enable_vlan(struct realtek_priv *priv, bool enable)\n{\n\tint ret;\n\n\tret = priv->ops->enable_vlan(priv, enable);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->vlan_enabled = enable;\n\n\t \n\tif (!enable) {\n\t\tpriv->vlan4k_enabled = false;\n\t\tret = priv->ops->enable_vlan4k(priv, false);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(rtl8366_enable_vlan);\n\nint rtl8366_reset_vlan(struct realtek_priv *priv)\n{\n\tstruct rtl8366_vlan_mc vlanmc;\n\tint ret;\n\tint i;\n\n\trtl8366_enable_vlan(priv, false);\n\trtl8366_enable_vlan4k(priv, false);\n\n\t \n\tvlanmc.vid = 0;\n\tvlanmc.priority = 0;\n\tvlanmc.member = 0;\n\tvlanmc.untag = 0;\n\tvlanmc.fid = 0;\n\tfor (i = 0; i < priv->num_vlan_mc; i++) {\n\t\tret = priv->ops->set_vlan_mc(priv, i, &vlanmc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtl8366_reset_vlan);\n\nint rtl8366_vlan_add(struct dsa_switch *ds, int port,\n\t\t     const struct switchdev_obj_port_vlan *vlan,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tbool untagged = !!(vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED);\n\tbool pvid = !!(vlan->flags & BRIDGE_VLAN_INFO_PVID);\n\tstruct realtek_priv *priv = ds->priv;\n\tu32 member = 0;\n\tu32 untag = 0;\n\tint ret;\n\n\tif (!priv->ops->is_vlan_valid(priv, vlan->vid)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VLAN ID not valid\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = rtl8366_enable_vlan4k(priv, true);\n\tif (ret) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to enable VLAN 4K\");\n\t\treturn ret;\n\t}\n\n\tdev_dbg(priv->dev, \"add VLAN %d on port %d, %s, %s\\n\",\n\t\tvlan->vid, port, untagged ? \"untagged\" : \"tagged\",\n\t\tpvid ? \"PVID\" : \"no PVID\");\n\n\tmember |= BIT(port);\n\n\tif (untagged)\n\t\tuntag |= BIT(port);\n\n\tret = rtl8366_set_vlan(priv, vlan->vid, member, untag, 0);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"failed to set up VLAN %04x\", vlan->vid);\n\t\treturn ret;\n\t}\n\n\tif (!pvid)\n\t\treturn 0;\n\n\tret = rtl8366_set_pvid(priv, port, vlan->vid);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"failed to set PVID on port %d to VLAN %04x\",\n\t\t\tport, vlan->vid);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtl8366_vlan_add);\n\nint rtl8366_vlan_del(struct dsa_switch *ds, int port,\n\t\t     const struct switchdev_obj_port_vlan *vlan)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\tint ret, i;\n\n\tdev_dbg(priv->dev, \"del VLAN %d on port %d\\n\", vlan->vid, port);\n\n\tfor (i = 0; i < priv->num_vlan_mc; i++) {\n\t\tstruct rtl8366_vlan_mc vlanmc;\n\n\t\tret = priv->ops->get_vlan_mc(priv, i, &vlanmc);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (vlan->vid == vlanmc.vid) {\n\t\t\t \n\t\t\tvlanmc.member &= ~BIT(port);\n\t\t\tvlanmc.untag &= ~BIT(port);\n\t\t\t \n\t\t\tif (!vlanmc.member) {\n\t\t\t\tvlanmc.vid = 0;\n\t\t\t\tvlanmc.priority = 0;\n\t\t\t\tvlanmc.fid = 0;\n\t\t\t}\n\t\t\tret = priv->ops->set_vlan_mc(priv, i, &vlanmc);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(priv->dev,\n\t\t\t\t\t\"failed to remove VLAN %04x\\n\",\n\t\t\t\t\tvlan->vid);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtl8366_vlan_del);\n\nvoid rtl8366_get_strings(struct dsa_switch *ds, int port, u32 stringset,\n\t\t\t uint8_t *data)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\tstruct rtl8366_mib_counter *mib;\n\tint i;\n\n\tif (port >= priv->num_ports)\n\t\treturn;\n\n\tfor (i = 0; i < priv->num_mib_counters; i++) {\n\t\tmib = &priv->mib_counters[i];\n\t\tstrncpy(data + i * ETH_GSTRING_LEN,\n\t\t\tmib->name, ETH_GSTRING_LEN);\n\t}\n}\nEXPORT_SYMBOL_GPL(rtl8366_get_strings);\n\nint rtl8366_get_sset_count(struct dsa_switch *ds, int port, int sset)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\n\t \n\tif (sset != ETH_SS_STATS)\n\t\treturn 0;\n\tif (port >= priv->num_ports)\n\t\treturn -EINVAL;\n\n\treturn priv->num_mib_counters;\n}\nEXPORT_SYMBOL_GPL(rtl8366_get_sset_count);\n\nvoid rtl8366_get_ethtool_stats(struct dsa_switch *ds, int port, uint64_t *data)\n{\n\tstruct realtek_priv *priv = ds->priv;\n\tint i;\n\tint ret;\n\n\tif (port >= priv->num_ports)\n\t\treturn;\n\n\tfor (i = 0; i < priv->num_mib_counters; i++) {\n\t\tstruct rtl8366_mib_counter *mib;\n\t\tu64 mibvalue = 0;\n\n\t\tmib = &priv->mib_counters[i];\n\t\tret = priv->ops->get_mib_counter(priv, port, mib, &mibvalue);\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"error reading MIB counter %s\\n\",\n\t\t\t\tmib->name);\n\t\t}\n\t\tdata[i] = mibvalue;\n\t}\n}\nEXPORT_SYMBOL_GPL(rtl8366_get_ethtool_stats);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}