{
  "module_name": "ar9331.c",
  "hash_id": "86ae11e736a33e6b04af963bbd4d5f51694a3ceaa8af159997b0c244f18e3aa9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/qca/ar9331.c",
  "human_readable_source": "\n\n \n\n#include <linux/bitfield.h>\n#include <linux/module.h>\n#include <linux/of_irq.h>\n#include <linux/of_mdio.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <net/dsa.h>\n\n#define AR9331_SW_NAME\t\t\t\t\"ar9331_switch\"\n#define AR9331_SW_PORTS\t\t\t\t6\n\n \n#define AR9331_SW_REG_PAGE\t\t\t0x40000\n\n \n#define AR9331_SW_REG_GINT\t\t\t0x10\n#define AR9331_SW_REG_GINT_MASK\t\t\t0x14\n#define AR9331_SW_GINT_PHY_INT\t\t\tBIT(2)\n\n#define AR9331_SW_REG_FLOOD_MASK\t\t0x2c\n#define AR9331_SW_FLOOD_MASK_BROAD_TO_CPU\tBIT(26)\n\n#define AR9331_SW_REG_GLOBAL_CTRL\t\t0x30\n#define AR9331_SW_GLOBAL_CTRL_MFS_M\t\tGENMASK(13, 0)\n\n#define AR9331_SW_REG_MDIO_CTRL\t\t\t0x98\n#define AR9331_SW_MDIO_CTRL_BUSY\t\tBIT(31)\n#define AR9331_SW_MDIO_CTRL_MASTER_EN\t\tBIT(30)\n#define AR9331_SW_MDIO_CTRL_CMD_READ\t\tBIT(27)\n#define AR9331_SW_MDIO_CTRL_PHY_ADDR_M\t\tGENMASK(25, 21)\n#define AR9331_SW_MDIO_CTRL_REG_ADDR_M\t\tGENMASK(20, 16)\n#define AR9331_SW_MDIO_CTRL_DATA_M\t\tGENMASK(16, 0)\n\n#define AR9331_SW_REG_PORT_STATUS(_port)\t(0x100 + (_port) * 0x100)\n\n \n#define AR9331_SW_PORT_STATUS_FLOW_LINK_EN\tBIT(12)\n\n \n#define AR9331_SW_PORT_STATUS_LINK_EN\t\tBIT(9)\n#define AR9331_SW_PORT_STATUS_DUPLEX_MODE\tBIT(6)\n#define AR9331_SW_PORT_STATUS_RX_FLOW_EN\tBIT(5)\n#define AR9331_SW_PORT_STATUS_TX_FLOW_EN\tBIT(4)\n#define AR9331_SW_PORT_STATUS_RXMAC\t\tBIT(3)\n#define AR9331_SW_PORT_STATUS_TXMAC\t\tBIT(2)\n#define AR9331_SW_PORT_STATUS_SPEED_M\t\tGENMASK(1, 0)\n#define AR9331_SW_PORT_STATUS_SPEED_1000\t2\n#define AR9331_SW_PORT_STATUS_SPEED_100\t\t1\n#define AR9331_SW_PORT_STATUS_SPEED_10\t\t0\n\n#define AR9331_SW_PORT_STATUS_MAC_MASK \\\n\t(AR9331_SW_PORT_STATUS_TXMAC | AR9331_SW_PORT_STATUS_RXMAC)\n\n#define AR9331_SW_PORT_STATUS_LINK_MASK \\\n\t(AR9331_SW_PORT_STATUS_DUPLEX_MODE | \\\n\t AR9331_SW_PORT_STATUS_RX_FLOW_EN | AR9331_SW_PORT_STATUS_TX_FLOW_EN | \\\n\t AR9331_SW_PORT_STATUS_SPEED_M)\n\n#define AR9331_SW_REG_PORT_CTRL(_port)\t\t\t(0x104 + (_port) * 0x100)\n#define AR9331_SW_PORT_CTRL_HEAD_EN\t\t\tBIT(11)\n#define AR9331_SW_PORT_CTRL_PORT_STATE\t\t\tGENMASK(2, 0)\n#define AR9331_SW_PORT_CTRL_PORT_STATE_DISABLED\t\t0\n#define AR9331_SW_PORT_CTRL_PORT_STATE_BLOCKING\t\t1\n#define AR9331_SW_PORT_CTRL_PORT_STATE_LISTENING\t2\n#define AR9331_SW_PORT_CTRL_PORT_STATE_LEARNING\t\t3\n#define AR9331_SW_PORT_CTRL_PORT_STATE_FORWARD\t\t4\n\n#define AR9331_SW_REG_PORT_VLAN(_port)\t\t\t(0x108 + (_port) * 0x100)\n#define AR9331_SW_PORT_VLAN_8021Q_MODE\t\t\tGENMASK(31, 30)\n#define AR9331_SW_8021Q_MODE_SECURE\t\t\t3\n#define AR9331_SW_8021Q_MODE_CHECK\t\t\t2\n#define AR9331_SW_8021Q_MODE_FALLBACK\t\t\t1\n#define AR9331_SW_8021Q_MODE_NONE\t\t\t0\n#define AR9331_SW_PORT_VLAN_PORT_VID_MEMBER\t\tGENMASK(25, 16)\n\n \n#define AR9331_MIB_COUNTER(x)\t\t\t(0x20000 + ((x) * 0x100))\n\n \n \n#define AR9331_SW_ADDR_PAGE\t\t\tGENMASK(18, 9)\n\n \n#define AR9331_SW_LOW_ADDR_PHY\t\t\tGENMASK(8, 6)\n#define AR9331_SW_LOW_ADDR_REG\t\t\tGENMASK(5, 1)\n\n#define AR9331_SW_MDIO_PHY_MODE_M\t\tGENMASK(4, 3)\n#define AR9331_SW_MDIO_PHY_MODE_PAGE\t\t3\n#define AR9331_SW_MDIO_PHY_MODE_REG\t\t2\n#define AR9331_SW_MDIO_PHY_MODE_BYPASS\t\t0\n#define AR9331_SW_MDIO_PHY_ADDR_M\t\tGENMASK(2, 0)\n\n \n#define AR9331_SW_MDIO_POLL_SLEEP_US\t\t1\n#define AR9331_SW_MDIO_POLL_TIMEOUT_US\t\t20\n\n \n \n#define STATS_INTERVAL_JIFFIES\t\t\t(3 * HZ)\n\nstruct ar9331_sw_stats_raw {\n\tu32 rxbroad;\t\t\t \n\tu32 rxpause;\t\t\t \n\tu32 rxmulti;\t\t\t \n\tu32 rxfcserr;\t\t\t \n\tu32 rxalignerr;\t\t\t \n\tu32 rxrunt;\t\t\t \n\tu32 rxfragment;\t\t\t \n\tu32 rx64byte;\t\t\t \n\tu32 rx128byte;\t\t\t \n\tu32 rx256byte;\t\t\t \n\tu32 rx512byte;\t\t\t \n\tu32 rx1024byte;\t\t\t \n\tu32 rx1518byte;\t\t\t \n\tu32 rxmaxbyte;\t\t\t \n\tu32 rxtoolong;\t\t\t \n\tu32 rxgoodbyte;\t\t\t \n\tu32 rxgoodbyte_hi;\n\tu32 rxbadbyte;\t\t\t \n\tu32 rxbadbyte_hi;\n\tu32 rxoverflow;\t\t\t \n\tu32 filtered;\t\t\t \n\tu32 txbroad;\t\t\t \n\tu32 txpause;\t\t\t \n\tu32 txmulti;\t\t\t \n\tu32 txunderrun;\t\t\t \n\tu32 tx64byte;\t\t\t \n\tu32 tx128byte;\t\t\t \n\tu32 tx256byte;\t\t\t \n\tu32 tx512byte;\t\t\t \n\tu32 tx1024byte;\t\t\t \n\tu32 tx1518byte;\t\t\t \n\tu32 txmaxbyte;\t\t\t \n\tu32 txoversize;\t\t\t \n\tu32 txbyte;\t\t\t \n\tu32 txbyte_hi;\n\tu32 txcollision;\t\t \n\tu32 txabortcol;\t\t\t \n\tu32 txmulticol;\t\t\t \n\tu32 txsinglecol;\t\t \n\tu32 txexcdefer;\t\t\t \n\tu32 txdefer;\t\t\t \n\tu32 txlatecol;\t\t\t \n};\n\nstruct ar9331_sw_port {\n\tint idx;\n\tstruct delayed_work mib_read;\n\tstruct rtnl_link_stats64 stats;\n\tstruct ethtool_pause_stats pause_stats;\n\tstruct spinlock stats_lock;\n};\n\nstruct ar9331_sw_priv {\n\tstruct device *dev;\n\tstruct dsa_switch ds;\n\tstruct dsa_switch_ops ops;\n\tstruct irq_domain *irqdomain;\n\tu32 irq_mask;\n\tstruct mutex lock_irq;\n\tstruct mii_bus *mbus;  \n\tstruct mii_bus *sbus;  \n\tstruct regmap *regmap;\n\tstruct reset_control *sw_reset;\n\tstruct ar9331_sw_port port[AR9331_SW_PORTS];\n};\n\nstatic struct ar9331_sw_priv *ar9331_sw_port_to_priv(struct ar9331_sw_port *port)\n{\n\tstruct ar9331_sw_port *p = port - port->idx;\n\n\treturn (struct ar9331_sw_priv *)((void *)p -\n\t\t\t\t\t offsetof(struct ar9331_sw_priv, port));\n}\n\n \nstatic int ar9331_sw_reset(struct ar9331_sw_priv *priv)\n{\n\tint ret;\n\n\tret = reset_control_assert(priv->sw_reset);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tusleep_range(10000, 15000);\n\tret = reset_control_deassert(priv->sw_reset);\n\tif (ret)\n\t\tgoto error;\n\t \n\n\treturn 0;\nerror:\n\tdev_err_ratelimited(priv->dev, \"%s: %i\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int ar9331_sw_mbus_write(struct mii_bus *mbus, int port, int regnum,\n\t\t\t\tu16 data)\n{\n\tstruct ar9331_sw_priv *priv = mbus->priv;\n\tstruct regmap *regmap = priv->regmap;\n\tu32 val;\n\tint ret;\n\n\tret = regmap_write(regmap, AR9331_SW_REG_MDIO_CTRL,\n\t\t\t   AR9331_SW_MDIO_CTRL_BUSY |\n\t\t\t   AR9331_SW_MDIO_CTRL_MASTER_EN |\n\t\t\t   FIELD_PREP(AR9331_SW_MDIO_CTRL_PHY_ADDR_M, port) |\n\t\t\t   FIELD_PREP(AR9331_SW_MDIO_CTRL_REG_ADDR_M, regnum) |\n\t\t\t   FIELD_PREP(AR9331_SW_MDIO_CTRL_DATA_M, data));\n\tif (ret)\n\t\tgoto error;\n\n\tret = regmap_read_poll_timeout(regmap, AR9331_SW_REG_MDIO_CTRL, val,\n\t\t\t\t       !(val & AR9331_SW_MDIO_CTRL_BUSY),\n\t\t\t\t       AR9331_SW_MDIO_POLL_SLEEP_US,\n\t\t\t\t       AR9331_SW_MDIO_POLL_TIMEOUT_US);\n\tif (ret)\n\t\tgoto error;\n\n\treturn 0;\nerror:\n\tdev_err_ratelimited(priv->dev, \"PHY write error: %i\\n\", ret);\n\treturn ret;\n}\n\nstatic int ar9331_sw_mbus_read(struct mii_bus *mbus, int port, int regnum)\n{\n\tstruct ar9331_sw_priv *priv = mbus->priv;\n\tstruct regmap *regmap = priv->regmap;\n\tu32 val;\n\tint ret;\n\n\tret = regmap_write(regmap, AR9331_SW_REG_MDIO_CTRL,\n\t\t\t   AR9331_SW_MDIO_CTRL_BUSY |\n\t\t\t   AR9331_SW_MDIO_CTRL_MASTER_EN |\n\t\t\t   AR9331_SW_MDIO_CTRL_CMD_READ |\n\t\t\t   FIELD_PREP(AR9331_SW_MDIO_CTRL_PHY_ADDR_M, port) |\n\t\t\t   FIELD_PREP(AR9331_SW_MDIO_CTRL_REG_ADDR_M, regnum));\n\tif (ret)\n\t\tgoto error;\n\n\tret = regmap_read_poll_timeout(regmap, AR9331_SW_REG_MDIO_CTRL, val,\n\t\t\t\t       !(val & AR9331_SW_MDIO_CTRL_BUSY),\n\t\t\t\t       AR9331_SW_MDIO_POLL_SLEEP_US,\n\t\t\t\t       AR9331_SW_MDIO_POLL_TIMEOUT_US);\n\tif (ret)\n\t\tgoto error;\n\n\tret = regmap_read(regmap, AR9331_SW_REG_MDIO_CTRL, &val);\n\tif (ret)\n\t\tgoto error;\n\n\treturn FIELD_GET(AR9331_SW_MDIO_CTRL_DATA_M, val);\n\nerror:\n\tdev_err_ratelimited(priv->dev, \"PHY read error: %i\\n\", ret);\n\treturn ret;\n}\n\nstatic int ar9331_sw_mbus_init(struct ar9331_sw_priv *priv)\n{\n\tstruct device *dev = priv->dev;\n\tstruct mii_bus *mbus;\n\tstruct device_node *np, *mnp;\n\tint ret;\n\n\tnp = dev->of_node;\n\n\tmbus = devm_mdiobus_alloc(dev);\n\tif (!mbus)\n\t\treturn -ENOMEM;\n\n\tmbus->name = np->full_name;\n\tsnprintf(mbus->id, MII_BUS_ID_SIZE, \"%pOF\", np);\n\n\tmbus->read = ar9331_sw_mbus_read;\n\tmbus->write = ar9331_sw_mbus_write;\n\tmbus->priv = priv;\n\tmbus->parent = dev;\n\n\tmnp = of_get_child_by_name(np, \"mdio\");\n\tif (!mnp)\n\t\treturn -ENODEV;\n\n\tret = devm_of_mdiobus_register(dev, mbus, mnp);\n\tof_node_put(mnp);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->mbus = mbus;\n\n\treturn 0;\n}\n\nstatic int ar9331_sw_setup_port(struct dsa_switch *ds, int port)\n{\n\tstruct ar9331_sw_priv *priv = ds->priv;\n\tstruct regmap *regmap = priv->regmap;\n\tu32 port_mask, port_ctrl, val;\n\tint ret;\n\n\t \n\tport_ctrl = FIELD_PREP(AR9331_SW_PORT_CTRL_PORT_STATE,\n\t\t\t       AR9331_SW_PORT_CTRL_PORT_STATE_FORWARD);\n\n\tif (dsa_is_cpu_port(ds, port)) {\n\t\t \n\t\tport_mask = dsa_user_ports(ds);\n\t\t \n\t\tport_ctrl |= AR9331_SW_PORT_CTRL_HEAD_EN;\n\t} else if (dsa_is_user_port(ds, port)) {\n\t\t \n\t\tport_mask = BIT(dsa_upstream_port(ds, port));\n\t} else {\n\t\t \n\t\tport_mask = 0;\n\t}\n\n\tval = FIELD_PREP(AR9331_SW_PORT_VLAN_8021Q_MODE,\n\t\t\t AR9331_SW_8021Q_MODE_NONE) |\n\t\tFIELD_PREP(AR9331_SW_PORT_VLAN_PORT_VID_MEMBER, port_mask);\n\n\tret = regmap_write(regmap, AR9331_SW_REG_PORT_VLAN(port), val);\n\tif (ret)\n\t\tgoto error;\n\n\tret = regmap_write(regmap, AR9331_SW_REG_PORT_CTRL(port), port_ctrl);\n\tif (ret)\n\t\tgoto error;\n\n\treturn 0;\nerror:\n\tdev_err(priv->dev, \"%s: error: %i\\n\", __func__, ret);\n\n\treturn ret;\n}\n\nstatic int ar9331_sw_setup(struct dsa_switch *ds)\n{\n\tstruct ar9331_sw_priv *priv = ds->priv;\n\tstruct regmap *regmap = priv->regmap;\n\tint ret, i;\n\n\tret = ar9331_sw_reset(priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ar9331_sw_mbus_init(priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write_bits(regmap, AR9331_SW_REG_FLOOD_MASK,\n\t\t\t\tAR9331_SW_FLOOD_MASK_BROAD_TO_CPU,\n\t\t\t\tAR9331_SW_FLOOD_MASK_BROAD_TO_CPU);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tret = regmap_write_bits(regmap, AR9331_SW_REG_GLOBAL_CTRL,\n\t\t\t\tAR9331_SW_GLOBAL_CTRL_MFS_M,\n\t\t\t\tAR9331_SW_GLOBAL_CTRL_MFS_M);\n\tif (ret)\n\t\tgoto error;\n\n\tfor (i = 0; i < ds->num_ports; i++) {\n\t\tret = ar9331_sw_setup_port(ds, i);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\n\tds->configure_vlan_while_not_filtering = false;\n\n\treturn 0;\nerror:\n\tdev_err_ratelimited(priv->dev, \"%s: %i\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic void ar9331_sw_port_disable(struct dsa_switch *ds, int port)\n{\n\tstruct ar9331_sw_priv *priv = ds->priv;\n\tstruct regmap *regmap = priv->regmap;\n\tint ret;\n\n\tret = regmap_write(regmap, AR9331_SW_REG_PORT_STATUS(port), 0);\n\tif (ret)\n\t\tdev_err_ratelimited(priv->dev, \"%s: %i\\n\", __func__, ret);\n}\n\nstatic enum dsa_tag_protocol ar9331_sw_get_tag_protocol(struct dsa_switch *ds,\n\t\t\t\t\t\t\tint port,\n\t\t\t\t\t\t\tenum dsa_tag_protocol m)\n{\n\treturn DSA_TAG_PROTO_AR9331;\n}\n\nstatic void ar9331_sw_phylink_get_caps(struct dsa_switch *ds, int port,\n\t\t\t\t       struct phylink_config *config)\n{\n\tconfig->mac_capabilities = MAC_ASYM_PAUSE | MAC_SYM_PAUSE |\n\t\tMAC_10 | MAC_100;\n\n\tswitch (port) {\n\tcase 0:\n\t\t__set_bit(PHY_INTERFACE_MODE_GMII,\n\t\t\t  config->supported_interfaces);\n\t\tconfig->mac_capabilities |= MAC_1000;\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\tcase 5:\n\t\t__set_bit(PHY_INTERFACE_MODE_INTERNAL,\n\t\t\t  config->supported_interfaces);\n\t\tbreak;\n\t}\n}\n\nstatic void ar9331_sw_phylink_mac_config(struct dsa_switch *ds, int port,\n\t\t\t\t\t unsigned int mode,\n\t\t\t\t\t const struct phylink_link_state *state)\n{\n\tstruct ar9331_sw_priv *priv = ds->priv;\n\tstruct regmap *regmap = priv->regmap;\n\tint ret;\n\n\tret = regmap_update_bits(regmap, AR9331_SW_REG_PORT_STATUS(port),\n\t\t\t\t AR9331_SW_PORT_STATUS_LINK_EN |\n\t\t\t\t AR9331_SW_PORT_STATUS_FLOW_LINK_EN, 0);\n\tif (ret)\n\t\tdev_err_ratelimited(priv->dev, \"%s: %i\\n\", __func__, ret);\n}\n\nstatic void ar9331_sw_phylink_mac_link_down(struct dsa_switch *ds, int port,\n\t\t\t\t\t    unsigned int mode,\n\t\t\t\t\t    phy_interface_t interface)\n{\n\tstruct ar9331_sw_priv *priv = ds->priv;\n\tstruct ar9331_sw_port *p = &priv->port[port];\n\tstruct regmap *regmap = priv->regmap;\n\tint ret;\n\n\tret = regmap_update_bits(regmap, AR9331_SW_REG_PORT_STATUS(port),\n\t\t\t\t AR9331_SW_PORT_STATUS_MAC_MASK, 0);\n\tif (ret)\n\t\tdev_err_ratelimited(priv->dev, \"%s: %i\\n\", __func__, ret);\n\n\tcancel_delayed_work_sync(&p->mib_read);\n}\n\nstatic void ar9331_sw_phylink_mac_link_up(struct dsa_switch *ds, int port,\n\t\t\t\t\t  unsigned int mode,\n\t\t\t\t\t  phy_interface_t interface,\n\t\t\t\t\t  struct phy_device *phydev,\n\t\t\t\t\t  int speed, int duplex,\n\t\t\t\t\t  bool tx_pause, bool rx_pause)\n{\n\tstruct ar9331_sw_priv *priv = ds->priv;\n\tstruct ar9331_sw_port *p = &priv->port[port];\n\tstruct regmap *regmap = priv->regmap;\n\tu32 val;\n\tint ret;\n\n\tschedule_delayed_work(&p->mib_read, 0);\n\n\tval = AR9331_SW_PORT_STATUS_MAC_MASK;\n\tswitch (speed) {\n\tcase SPEED_1000:\n\t\tval |= AR9331_SW_PORT_STATUS_SPEED_1000;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tval |= AR9331_SW_PORT_STATUS_SPEED_100;\n\t\tbreak;\n\tcase SPEED_10:\n\t\tval |= AR9331_SW_PORT_STATUS_SPEED_10;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (duplex)\n\t\tval |= AR9331_SW_PORT_STATUS_DUPLEX_MODE;\n\n\tif (tx_pause)\n\t\tval |= AR9331_SW_PORT_STATUS_TX_FLOW_EN;\n\n\tif (rx_pause)\n\t\tval |= AR9331_SW_PORT_STATUS_RX_FLOW_EN;\n\n\tret = regmap_update_bits(regmap, AR9331_SW_REG_PORT_STATUS(port),\n\t\t\t\t AR9331_SW_PORT_STATUS_MAC_MASK |\n\t\t\t\t AR9331_SW_PORT_STATUS_LINK_MASK,\n\t\t\t\t val);\n\tif (ret)\n\t\tdev_err_ratelimited(priv->dev, \"%s: %i\\n\", __func__, ret);\n}\n\nstatic void ar9331_read_stats(struct ar9331_sw_port *port)\n{\n\tstruct ar9331_sw_priv *priv = ar9331_sw_port_to_priv(port);\n\tstruct ethtool_pause_stats *pstats = &port->pause_stats;\n\tstruct rtnl_link_stats64 *stats = &port->stats;\n\tstruct ar9331_sw_stats_raw raw;\n\tint ret;\n\n\t \n\tret = regmap_bulk_read(priv->regmap, AR9331_MIB_COUNTER(port->idx),\n\t\t\t       &raw, sizeof(raw) / sizeof(u32));\n\tif (ret) {\n\t\tdev_err_ratelimited(priv->dev, \"%s: %i\\n\", __func__, ret);\n\t\treturn;\n\t}\n\t \n\n\tspin_lock(&port->stats_lock);\n\n\tstats->rx_bytes += raw.rxgoodbyte;\n\tstats->tx_bytes += raw.txbyte;\n\n\tstats->rx_packets += raw.rx64byte + raw.rx128byte + raw.rx256byte +\n\t\traw.rx512byte + raw.rx1024byte + raw.rx1518byte + raw.rxmaxbyte;\n\tstats->tx_packets += raw.tx64byte + raw.tx128byte + raw.tx256byte +\n\t\traw.tx512byte + raw.tx1024byte + raw.tx1518byte + raw.txmaxbyte;\n\n\tstats->rx_length_errors += raw.rxrunt + raw.rxfragment + raw.rxtoolong;\n\tstats->rx_crc_errors += raw.rxfcserr;\n\tstats->rx_frame_errors += raw.rxalignerr;\n\tstats->rx_missed_errors += raw.rxoverflow;\n\tstats->rx_dropped += raw.filtered;\n\tstats->rx_errors += raw.rxfcserr + raw.rxalignerr + raw.rxrunt +\n\t\traw.rxfragment + raw.rxoverflow + raw.rxtoolong;\n\n\tstats->tx_window_errors += raw.txlatecol;\n\tstats->tx_fifo_errors += raw.txunderrun;\n\tstats->tx_aborted_errors += raw.txabortcol;\n\tstats->tx_errors += raw.txoversize + raw.txabortcol + raw.txunderrun +\n\t\traw.txlatecol;\n\n\tstats->multicast += raw.rxmulti;\n\tstats->collisions += raw.txcollision;\n\n\tpstats->tx_pause_frames += raw.txpause;\n\tpstats->rx_pause_frames += raw.rxpause;\n\n\tspin_unlock(&port->stats_lock);\n}\n\nstatic void ar9331_do_stats_poll(struct work_struct *work)\n{\n\tstruct ar9331_sw_port *port = container_of(work, struct ar9331_sw_port,\n\t\t\t\t\t\t   mib_read.work);\n\n\tar9331_read_stats(port);\n\n\tschedule_delayed_work(&port->mib_read, STATS_INTERVAL_JIFFIES);\n}\n\nstatic void ar9331_get_stats64(struct dsa_switch *ds, int port,\n\t\t\t       struct rtnl_link_stats64 *s)\n{\n\tstruct ar9331_sw_priv *priv = ds->priv;\n\tstruct ar9331_sw_port *p = &priv->port[port];\n\n\tspin_lock(&p->stats_lock);\n\tmemcpy(s, &p->stats, sizeof(*s));\n\tspin_unlock(&p->stats_lock);\n}\n\nstatic void ar9331_get_pause_stats(struct dsa_switch *ds, int port,\n\t\t\t\t   struct ethtool_pause_stats *pause_stats)\n{\n\tstruct ar9331_sw_priv *priv = ds->priv;\n\tstruct ar9331_sw_port *p = &priv->port[port];\n\n\tspin_lock(&p->stats_lock);\n\tmemcpy(pause_stats, &p->pause_stats, sizeof(*pause_stats));\n\tspin_unlock(&p->stats_lock);\n}\n\nstatic const struct dsa_switch_ops ar9331_sw_ops = {\n\t.get_tag_protocol\t= ar9331_sw_get_tag_protocol,\n\t.setup\t\t\t= ar9331_sw_setup,\n\t.port_disable\t\t= ar9331_sw_port_disable,\n\t.phylink_get_caps\t= ar9331_sw_phylink_get_caps,\n\t.phylink_mac_config\t= ar9331_sw_phylink_mac_config,\n\t.phylink_mac_link_down\t= ar9331_sw_phylink_mac_link_down,\n\t.phylink_mac_link_up\t= ar9331_sw_phylink_mac_link_up,\n\t.get_stats64\t\t= ar9331_get_stats64,\n\t.get_pause_stats\t= ar9331_get_pause_stats,\n};\n\nstatic irqreturn_t ar9331_sw_irq(int irq, void *data)\n{\n\tstruct ar9331_sw_priv *priv = data;\n\tstruct regmap *regmap = priv->regmap;\n\tu32 stat;\n\tint ret;\n\n\tret = regmap_read(regmap, AR9331_SW_REG_GINT, &stat);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"can't read interrupt status\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (!stat)\n\t\treturn IRQ_NONE;\n\n\tif (stat & AR9331_SW_GINT_PHY_INT) {\n\t\tint child_irq;\n\n\t\tchild_irq = irq_find_mapping(priv->irqdomain, 0);\n\t\thandle_nested_irq(child_irq);\n\t}\n\n\tret = regmap_write(regmap, AR9331_SW_REG_GINT, stat);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"can't write interrupt status\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void ar9331_sw_mask_irq(struct irq_data *d)\n{\n\tstruct ar9331_sw_priv *priv = irq_data_get_irq_chip_data(d);\n\n\tpriv->irq_mask = 0;\n}\n\nstatic void ar9331_sw_unmask_irq(struct irq_data *d)\n{\n\tstruct ar9331_sw_priv *priv = irq_data_get_irq_chip_data(d);\n\n\tpriv->irq_mask = AR9331_SW_GINT_PHY_INT;\n}\n\nstatic void ar9331_sw_irq_bus_lock(struct irq_data *d)\n{\n\tstruct ar9331_sw_priv *priv = irq_data_get_irq_chip_data(d);\n\n\tmutex_lock(&priv->lock_irq);\n}\n\nstatic void ar9331_sw_irq_bus_sync_unlock(struct irq_data *d)\n{\n\tstruct ar9331_sw_priv *priv = irq_data_get_irq_chip_data(d);\n\tstruct regmap *regmap = priv->regmap;\n\tint ret;\n\n\tret = regmap_update_bits(regmap, AR9331_SW_REG_GINT_MASK,\n\t\t\t\t AR9331_SW_GINT_PHY_INT, priv->irq_mask);\n\tif (ret)\n\t\tdev_err(priv->dev, \"failed to change IRQ mask\\n\");\n\n\tmutex_unlock(&priv->lock_irq);\n}\n\nstatic struct irq_chip ar9331_sw_irq_chip = {\n\t.name = AR9331_SW_NAME,\n\t.irq_mask = ar9331_sw_mask_irq,\n\t.irq_unmask = ar9331_sw_unmask_irq,\n\t.irq_bus_lock = ar9331_sw_irq_bus_lock,\n\t.irq_bus_sync_unlock = ar9331_sw_irq_bus_sync_unlock,\n};\n\nstatic int ar9331_sw_irq_map(struct irq_domain *domain, unsigned int irq,\n\t\t\t     irq_hw_number_t hwirq)\n{\n\tirq_set_chip_data(irq, domain->host_data);\n\tirq_set_chip_and_handler(irq, &ar9331_sw_irq_chip, handle_simple_irq);\n\tirq_set_nested_thread(irq, 1);\n\tirq_set_noprobe(irq);\n\n\treturn 0;\n}\n\nstatic void ar9331_sw_irq_unmap(struct irq_domain *d, unsigned int irq)\n{\n\tirq_set_nested_thread(irq, 0);\n\tirq_set_chip_and_handler(irq, NULL, NULL);\n\tirq_set_chip_data(irq, NULL);\n}\n\nstatic const struct irq_domain_ops ar9331_sw_irqdomain_ops = {\n\t.map = ar9331_sw_irq_map,\n\t.unmap = ar9331_sw_irq_unmap,\n\t.xlate = irq_domain_xlate_onecell,\n};\n\nstatic int ar9331_sw_irq_init(struct ar9331_sw_priv *priv)\n{\n\tstruct device_node *np = priv->dev->of_node;\n\tstruct device *dev = priv->dev;\n\tint ret, irq;\n\n\tirq = of_irq_get(np, 0);\n\tif (irq <= 0) {\n\t\tdev_err(dev, \"failed to get parent IRQ\\n\");\n\t\treturn irq ? irq : -EINVAL;\n\t}\n\n\tmutex_init(&priv->lock_irq);\n\tret = devm_request_threaded_irq(dev, irq, NULL, ar9331_sw_irq,\n\t\t\t\t\tIRQF_ONESHOT, AR9331_SW_NAME, priv);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to request irq: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpriv->irqdomain = irq_domain_add_linear(np, 1, &ar9331_sw_irqdomain_ops,\n\t\t\t\t\t\tpriv);\n\tif (!priv->irqdomain) {\n\t\tdev_err(dev, \"failed to create IRQ domain\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tirq_set_parent(irq_create_mapping(priv->irqdomain, 0), irq);\n\n\treturn 0;\n}\n\nstatic int __ar9331_mdio_write(struct mii_bus *sbus, u8 mode, u16 reg, u16 val)\n{\n\tu8 r, p;\n\n\tp = FIELD_PREP(AR9331_SW_MDIO_PHY_MODE_M, mode) |\n\t\tFIELD_GET(AR9331_SW_LOW_ADDR_PHY, reg);\n\tr = FIELD_GET(AR9331_SW_LOW_ADDR_REG, reg);\n\n\treturn __mdiobus_write(sbus, p, r, val);\n}\n\nstatic int __ar9331_mdio_read(struct mii_bus *sbus, u16 reg)\n{\n\tu8 r, p;\n\n\tp = FIELD_PREP(AR9331_SW_MDIO_PHY_MODE_M, AR9331_SW_MDIO_PHY_MODE_REG) |\n\t\tFIELD_GET(AR9331_SW_LOW_ADDR_PHY, reg);\n\tr = FIELD_GET(AR9331_SW_LOW_ADDR_REG, reg);\n\n\treturn __mdiobus_read(sbus, p, r);\n}\n\nstatic int ar9331_mdio_read(void *ctx, const void *reg_buf, size_t reg_len,\n\t\t\t    void *val_buf, size_t val_len)\n{\n\tstruct ar9331_sw_priv *priv = ctx;\n\tstruct mii_bus *sbus = priv->sbus;\n\tu32 reg = *(u32 *)reg_buf;\n\tint ret;\n\n\tif (reg == AR9331_SW_REG_PAGE) {\n\t\t \n\t\t*(u32 *)val_buf = GENMASK(9, 0);\n\t\treturn 0;\n\t}\n\n\tmutex_lock_nested(&sbus->mdio_lock, MDIO_MUTEX_NESTED);\n\n\tret = __ar9331_mdio_read(sbus, reg);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t*(u32 *)val_buf = ret;\n\tret = __ar9331_mdio_read(sbus, reg + 2);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t*(u32 *)val_buf |= ret << 16;\n\n\tmutex_unlock(&sbus->mdio_lock);\n\n\treturn 0;\nerror:\n\tmutex_unlock(&sbus->mdio_lock);\n\tdev_err_ratelimited(&sbus->dev, \"Bus error. Failed to read register.\\n\");\n\n\treturn ret;\n}\n\nstatic int ar9331_mdio_write(void *ctx, u32 reg, u32 val)\n{\n\tstruct ar9331_sw_priv *priv = (struct ar9331_sw_priv *)ctx;\n\tstruct mii_bus *sbus = priv->sbus;\n\tint ret;\n\n\tmutex_lock_nested(&sbus->mdio_lock, MDIO_MUTEX_NESTED);\n\tif (reg == AR9331_SW_REG_PAGE) {\n\t\tret = __ar9331_mdio_write(sbus, AR9331_SW_MDIO_PHY_MODE_PAGE,\n\t\t\t\t\t  0, val);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tmutex_unlock(&sbus->mdio_lock);\n\n\t\treturn 0;\n\t}\n\n\t \n\tret = __ar9331_mdio_write(sbus, AR9331_SW_MDIO_PHY_MODE_REG, reg + 2,\n\t\t\t\t  val >> 16);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = __ar9331_mdio_write(sbus, AR9331_SW_MDIO_PHY_MODE_REG, reg, val);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tmutex_unlock(&sbus->mdio_lock);\n\n\treturn 0;\n\nerror:\n\tmutex_unlock(&sbus->mdio_lock);\n\tdev_err_ratelimited(&sbus->dev, \"Bus error. Failed to write register.\\n\");\n\n\treturn ret;\n}\n\nstatic int ar9331_sw_bus_write(void *context, const void *data, size_t count)\n{\n\tu32 reg = *(u32 *)data;\n\tu32 val = *((u32 *)data + 1);\n\n\treturn ar9331_mdio_write(context, reg, val);\n}\n\nstatic const struct regmap_range ar9331_valid_regs[] = {\n\tregmap_reg_range(0x0, 0x0),\n\tregmap_reg_range(0x10, 0x14),\n\tregmap_reg_range(0x20, 0x24),\n\tregmap_reg_range(0x2c, 0x30),\n\tregmap_reg_range(0x40, 0x44),\n\tregmap_reg_range(0x50, 0x78),\n\tregmap_reg_range(0x80, 0x98),\n\n\tregmap_reg_range(0x100, 0x120),\n\tregmap_reg_range(0x200, 0x220),\n\tregmap_reg_range(0x300, 0x320),\n\tregmap_reg_range(0x400, 0x420),\n\tregmap_reg_range(0x500, 0x520),\n\tregmap_reg_range(0x600, 0x620),\n\n\tregmap_reg_range(0x20000, 0x200a4),\n\tregmap_reg_range(0x20100, 0x201a4),\n\tregmap_reg_range(0x20200, 0x202a4),\n\tregmap_reg_range(0x20300, 0x203a4),\n\tregmap_reg_range(0x20400, 0x204a4),\n\tregmap_reg_range(0x20500, 0x205a4),\n\n\t \n\tregmap_reg_range(AR9331_SW_REG_PAGE, AR9331_SW_REG_PAGE),\n};\n\nstatic const struct regmap_range ar9331_nonvolatile_regs[] = {\n\tregmap_reg_range(AR9331_SW_REG_PAGE, AR9331_SW_REG_PAGE),\n};\n\nstatic const struct regmap_range_cfg ar9331_regmap_range[] = {\n\t{\n\t\t.selector_reg = AR9331_SW_REG_PAGE,\n\t\t.selector_mask = GENMASK(9, 0),\n\t\t.selector_shift = 0,\n\n\t\t.window_start = 0,\n\t\t.window_len = 512,\n\n\t\t.range_min = 0,\n\t\t.range_max = AR9331_SW_REG_PAGE - 4,\n\t},\n};\n\nstatic const struct regmap_access_table ar9331_register_set = {\n\t.yes_ranges = ar9331_valid_regs,\n\t.n_yes_ranges = ARRAY_SIZE(ar9331_valid_regs),\n};\n\nstatic const struct regmap_access_table ar9331_volatile_set = {\n\t.no_ranges = ar9331_nonvolatile_regs,\n\t.n_no_ranges = ARRAY_SIZE(ar9331_nonvolatile_regs),\n};\n\nstatic const struct regmap_config ar9331_mdio_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = AR9331_SW_REG_PAGE,\n\t.use_single_read = true,\n\t.use_single_write = true,\n\n\t.ranges = ar9331_regmap_range,\n\t.num_ranges = ARRAY_SIZE(ar9331_regmap_range),\n\n\t.volatile_table = &ar9331_volatile_set,\n\t.wr_table = &ar9331_register_set,\n\t.rd_table = &ar9331_register_set,\n\n\t.cache_type = REGCACHE_MAPLE,\n};\n\nstatic struct regmap_bus ar9331_sw_bus = {\n\t.reg_format_endian_default = REGMAP_ENDIAN_NATIVE,\n\t.val_format_endian_default = REGMAP_ENDIAN_NATIVE,\n\t.read = ar9331_mdio_read,\n\t.write = ar9331_sw_bus_write,\n};\n\nstatic int ar9331_sw_probe(struct mdio_device *mdiodev)\n{\n\tstruct ar9331_sw_priv *priv;\n\tstruct dsa_switch *ds;\n\tint ret, i;\n\n\tpriv = devm_kzalloc(&mdiodev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->regmap = devm_regmap_init(&mdiodev->dev, &ar9331_sw_bus, priv,\n\t\t\t\t\t&ar9331_mdio_regmap_config);\n\tif (IS_ERR(priv->regmap)) {\n\t\tret = PTR_ERR(priv->regmap);\n\t\tdev_err(&mdiodev->dev, \"regmap init failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpriv->sw_reset = devm_reset_control_get(&mdiodev->dev, \"switch\");\n\tif (IS_ERR(priv->sw_reset)) {\n\t\tdev_err(&mdiodev->dev, \"missing switch reset\\n\");\n\t\treturn PTR_ERR(priv->sw_reset);\n\t}\n\n\tpriv->sbus = mdiodev->bus;\n\tpriv->dev = &mdiodev->dev;\n\n\tret = ar9331_sw_irq_init(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tds = &priv->ds;\n\tds->dev = &mdiodev->dev;\n\tds->num_ports = AR9331_SW_PORTS;\n\tds->priv = priv;\n\tpriv->ops = ar9331_sw_ops;\n\tds->ops = &priv->ops;\n\tdev_set_drvdata(&mdiodev->dev, priv);\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->port); i++) {\n\t\tstruct ar9331_sw_port *port = &priv->port[i];\n\n\t\tport->idx = i;\n\t\tspin_lock_init(&port->stats_lock);\n\t\tINIT_DELAYED_WORK(&port->mib_read, ar9331_do_stats_poll);\n\t}\n\n\tret = dsa_register_switch(ds);\n\tif (ret)\n\t\tgoto err_remove_irq;\n\n\treturn 0;\n\nerr_remove_irq:\n\tirq_domain_remove(priv->irqdomain);\n\n\treturn ret;\n}\n\nstatic void ar9331_sw_remove(struct mdio_device *mdiodev)\n{\n\tstruct ar9331_sw_priv *priv = dev_get_drvdata(&mdiodev->dev);\n\tunsigned int i;\n\n\tif (!priv)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->port); i++) {\n\t\tstruct ar9331_sw_port *port = &priv->port[i];\n\n\t\tcancel_delayed_work_sync(&port->mib_read);\n\t}\n\n\tirq_domain_remove(priv->irqdomain);\n\tdsa_unregister_switch(&priv->ds);\n\n\treset_control_assert(priv->sw_reset);\n}\n\nstatic void ar9331_sw_shutdown(struct mdio_device *mdiodev)\n{\n\tstruct ar9331_sw_priv *priv = dev_get_drvdata(&mdiodev->dev);\n\n\tif (!priv)\n\t\treturn;\n\n\tdsa_switch_shutdown(&priv->ds);\n\n\tdev_set_drvdata(&mdiodev->dev, NULL);\n}\n\nstatic const struct of_device_id ar9331_sw_of_match[] = {\n\t{ .compatible = \"qca,ar9331-switch\" },\n\t{ },\n};\n\nstatic struct mdio_driver ar9331_sw_mdio_driver = {\n\t.probe = ar9331_sw_probe,\n\t.remove = ar9331_sw_remove,\n\t.shutdown = ar9331_sw_shutdown,\n\t.mdiodrv.driver = {\n\t\t.name = AR9331_SW_NAME,\n\t\t.of_match_table = ar9331_sw_of_match,\n\t},\n};\n\nmdio_module_driver(ar9331_sw_mdio_driver);\n\nMODULE_AUTHOR(\"Oleksij Rempel <kernel@pengutronix.de>\");\nMODULE_DESCRIPTION(\"Driver for Atheros AR9331 switch\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}