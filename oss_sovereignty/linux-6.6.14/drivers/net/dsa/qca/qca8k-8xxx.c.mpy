{
  "module_name": "qca8k-8xxx.c",
  "hash_id": "bc45d925972393dad65427aca42214ebd0e4058511eb37eb6a713c4e27fafc4c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/qca/qca8k-8xxx.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/phy.h>\n#include <linux/netdevice.h>\n#include <linux/bitfield.h>\n#include <linux/regmap.h>\n#include <net/dsa.h>\n#include <linux/of_net.h>\n#include <linux/of_mdio.h>\n#include <linux/of_platform.h>\n#include <linux/mdio.h>\n#include <linux/phylink.h>\n#include <linux/gpio/consumer.h>\n#include <linux/etherdevice.h>\n#include <linux/dsa/tag_qca.h>\n\n#include \"qca8k.h\"\n#include \"qca8k_leds.h\"\n\nstatic void\nqca8k_split_addr(u32 regaddr, u16 *r1, u16 *r2, u16 *page)\n{\n\tregaddr >>= 1;\n\t*r1 = regaddr & 0x1e;\n\n\tregaddr >>= 5;\n\t*r2 = regaddr & 0x7;\n\n\tregaddr >>= 3;\n\t*page = regaddr & 0x3ff;\n}\n\nstatic int\nqca8k_mii_write_lo(struct mii_bus *bus, int phy_id, u32 regnum, u32 val)\n{\n\tint ret;\n\tu16 lo;\n\n\tlo = val & 0xffff;\n\tret = bus->write(bus, phy_id, regnum, lo);\n\tif (ret < 0)\n\t\tdev_err_ratelimited(&bus->dev,\n\t\t\t\t    \"failed to write qca8k 32bit lo register\\n\");\n\n\treturn ret;\n}\n\nstatic int\nqca8k_mii_write_hi(struct mii_bus *bus, int phy_id, u32 regnum, u32 val)\n{\n\tint ret;\n\tu16 hi;\n\n\thi = (u16)(val >> 16);\n\tret = bus->write(bus, phy_id, regnum, hi);\n\tif (ret < 0)\n\t\tdev_err_ratelimited(&bus->dev,\n\t\t\t\t    \"failed to write qca8k 32bit hi register\\n\");\n\n\treturn ret;\n}\n\nstatic int\nqca8k_mii_read_lo(struct mii_bus *bus, int phy_id, u32 regnum, u32 *val)\n{\n\tint ret;\n\n\tret = bus->read(bus, phy_id, regnum);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t*val = ret & 0xffff;\n\treturn 0;\n\nerr:\n\tdev_err_ratelimited(&bus->dev,\n\t\t\t    \"failed to read qca8k 32bit lo register\\n\");\n\t*val = 0;\n\n\treturn ret;\n}\n\nstatic int\nqca8k_mii_read_hi(struct mii_bus *bus, int phy_id, u32 regnum, u32 *val)\n{\n\tint ret;\n\n\tret = bus->read(bus, phy_id, regnum);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t*val = ret << 16;\n\treturn 0;\n\nerr:\n\tdev_err_ratelimited(&bus->dev,\n\t\t\t    \"failed to read qca8k 32bit hi register\\n\");\n\t*val = 0;\n\n\treturn ret;\n}\n\nstatic int\nqca8k_mii_read32(struct mii_bus *bus, int phy_id, u32 regnum, u32 *val)\n{\n\tu32 hi, lo;\n\tint ret;\n\n\t*val = 0;\n\n\tret = qca8k_mii_read_lo(bus, phy_id, regnum, &lo);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = qca8k_mii_read_hi(bus, phy_id, regnum + 1, &hi);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t*val = lo | hi;\n\nerr:\n\treturn ret;\n}\n\nstatic void\nqca8k_mii_write32(struct mii_bus *bus, int phy_id, u32 regnum, u32 val)\n{\n\tif (qca8k_mii_write_lo(bus, phy_id, regnum, val) < 0)\n\t\treturn;\n\n\tqca8k_mii_write_hi(bus, phy_id, regnum + 1, val);\n}\n\nstatic int\nqca8k_set_page(struct qca8k_priv *priv, u16 page)\n{\n\tu16 *cached_page = &priv->mdio_cache.page;\n\tstruct mii_bus *bus = priv->bus;\n\tint ret;\n\n\tif (page == *cached_page)\n\t\treturn 0;\n\n\tret = bus->write(bus, 0x18, 0, page);\n\tif (ret < 0) {\n\t\tdev_err_ratelimited(&bus->dev,\n\t\t\t\t    \"failed to set qca8k page\\n\");\n\t\treturn ret;\n\t}\n\n\t*cached_page = page;\n\tusleep_range(1000, 2000);\n\treturn 0;\n}\n\nstatic void qca8k_rw_reg_ack_handler(struct dsa_switch *ds, struct sk_buff *skb)\n{\n\tstruct qca8k_mgmt_eth_data *mgmt_eth_data;\n\tstruct qca8k_priv *priv = ds->priv;\n\tstruct qca_mgmt_ethhdr *mgmt_ethhdr;\n\tu32 command;\n\tu8 len, cmd;\n\tint i;\n\n\tmgmt_ethhdr = (struct qca_mgmt_ethhdr *)skb_mac_header(skb);\n\tmgmt_eth_data = &priv->mgmt_eth_data;\n\n\tcommand = get_unaligned_le32(&mgmt_ethhdr->command);\n\tcmd = FIELD_GET(QCA_HDR_MGMT_CMD, command);\n\n\tlen = FIELD_GET(QCA_HDR_MGMT_LENGTH, command);\n\t \n\tif (len == 15)\n\t\tlen++;\n\n\t \n\tlen *= sizeof(u16);\n\n\t \n\tif (get_unaligned_le32(&mgmt_ethhdr->seq) == mgmt_eth_data->seq)\n\t\tmgmt_eth_data->ack = true;\n\n\tif (cmd == MDIO_READ) {\n\t\tu32 *val = mgmt_eth_data->data;\n\n\t\t*val = get_unaligned_le32(&mgmt_ethhdr->mdio_data);\n\n\t\t \n\t\tif (len > QCA_HDR_MGMT_DATA1_LEN) {\n\t\t\t__le32 *data2 = (__le32 *)skb->data;\n\t\t\tint data_len = min_t(int, QCA_HDR_MGMT_DATA2_LEN,\n\t\t\t\t\t     len - QCA_HDR_MGMT_DATA1_LEN);\n\n\t\t\tval++;\n\n\t\t\tfor (i = sizeof(u32); i <= data_len; i += sizeof(u32)) {\n\t\t\t\t*val = get_unaligned_le32(data2);\n\t\t\t\tval++;\n\t\t\t\tdata2++;\n\t\t\t}\n\t\t}\n\t}\n\n\tcomplete(&mgmt_eth_data->rw_done);\n}\n\nstatic struct sk_buff *qca8k_alloc_mdio_header(enum mdio_cmd cmd, u32 reg, u32 *val,\n\t\t\t\t\t       int priority, unsigned int len)\n{\n\tstruct qca_mgmt_ethhdr *mgmt_ethhdr;\n\tunsigned int real_len;\n\tstruct sk_buff *skb;\n\t__le32 *data2;\n\tu32 command;\n\tu16 hdr;\n\tint i;\n\n\tskb = dev_alloc_skb(QCA_HDR_MGMT_PKT_LEN);\n\tif (!skb)\n\t\treturn NULL;\n\n\t \n\treal_len = DIV_ROUND_UP(len, sizeof(u16));\n\n\t \n\tif (real_len % sizeof(u16) != 0)\n\t\treal_len++;\n\n\t \n\tif (real_len == 16)\n\t\treal_len--;\n\n\tskb_reset_mac_header(skb);\n\tskb_set_network_header(skb, skb->len);\n\n\tmgmt_ethhdr = skb_push(skb, QCA_HDR_MGMT_HEADER_LEN + QCA_HDR_LEN);\n\n\thdr = FIELD_PREP(QCA_HDR_XMIT_VERSION, QCA_HDR_VERSION);\n\thdr |= FIELD_PREP(QCA_HDR_XMIT_PRIORITY, priority);\n\thdr |= QCA_HDR_XMIT_FROM_CPU;\n\thdr |= FIELD_PREP(QCA_HDR_XMIT_DP_BIT, BIT(0));\n\thdr |= FIELD_PREP(QCA_HDR_XMIT_CONTROL, QCA_HDR_XMIT_TYPE_RW_REG);\n\n\tcommand = FIELD_PREP(QCA_HDR_MGMT_ADDR, reg);\n\tcommand |= FIELD_PREP(QCA_HDR_MGMT_LENGTH, real_len);\n\tcommand |= FIELD_PREP(QCA_HDR_MGMT_CMD, cmd);\n\tcommand |= FIELD_PREP(QCA_HDR_MGMT_CHECK_CODE,\n\t\t\t\t\t   QCA_HDR_MGMT_CHECK_CODE_VAL);\n\n\tput_unaligned_le32(command, &mgmt_ethhdr->command);\n\n\tif (cmd == MDIO_WRITE)\n\t\tput_unaligned_le32(*val, &mgmt_ethhdr->mdio_data);\n\n\tmgmt_ethhdr->hdr = htons(hdr);\n\n\tdata2 = skb_put_zero(skb, QCA_HDR_MGMT_DATA2_LEN + QCA_HDR_MGMT_PADDING_LEN);\n\tif (cmd == MDIO_WRITE && len > QCA_HDR_MGMT_DATA1_LEN) {\n\t\tint data_len = min_t(int, QCA_HDR_MGMT_DATA2_LEN,\n\t\t\t\t     len - QCA_HDR_MGMT_DATA1_LEN);\n\n\t\tval++;\n\n\t\tfor (i = sizeof(u32); i <= data_len; i += sizeof(u32)) {\n\t\t\tput_unaligned_le32(*val, data2);\n\t\t\tdata2++;\n\t\t\tval++;\n\t\t}\n\t}\n\n\treturn skb;\n}\n\nstatic void qca8k_mdio_header_fill_seq_num(struct sk_buff *skb, u32 seq_num)\n{\n\tstruct qca_mgmt_ethhdr *mgmt_ethhdr;\n\tu32 seq;\n\n\tseq = FIELD_PREP(QCA_HDR_MGMT_SEQ_NUM, seq_num);\n\tmgmt_ethhdr = (struct qca_mgmt_ethhdr *)skb->data;\n\tput_unaligned_le32(seq, &mgmt_ethhdr->seq);\n}\n\nstatic int qca8k_read_eth(struct qca8k_priv *priv, u32 reg, u32 *val, int len)\n{\n\tstruct qca8k_mgmt_eth_data *mgmt_eth_data = &priv->mgmt_eth_data;\n\tstruct sk_buff *skb;\n\tbool ack;\n\tint ret;\n\n\tskb = qca8k_alloc_mdio_header(MDIO_READ, reg, NULL,\n\t\t\t\t      QCA8K_ETHERNET_MDIO_PRIORITY, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&mgmt_eth_data->mutex);\n\n\t \n\tif (!priv->mgmt_master) {\n\t\tkfree_skb(skb);\n\t\tmutex_unlock(&mgmt_eth_data->mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tskb->dev = priv->mgmt_master;\n\n\treinit_completion(&mgmt_eth_data->rw_done);\n\n\t \n\tmgmt_eth_data->seq++;\n\tqca8k_mdio_header_fill_seq_num(skb, mgmt_eth_data->seq);\n\tmgmt_eth_data->ack = false;\n\n\tdev_queue_xmit(skb);\n\n\tret = wait_for_completion_timeout(&mgmt_eth_data->rw_done,\n\t\t\t\t\t  msecs_to_jiffies(QCA8K_ETHERNET_TIMEOUT));\n\n\t*val = mgmt_eth_data->data[0];\n\tif (len > QCA_HDR_MGMT_DATA1_LEN)\n\t\tmemcpy(val + 1, mgmt_eth_data->data + 1, len - QCA_HDR_MGMT_DATA1_LEN);\n\n\tack = mgmt_eth_data->ack;\n\n\tmutex_unlock(&mgmt_eth_data->mutex);\n\n\tif (ret <= 0)\n\t\treturn -ETIMEDOUT;\n\n\tif (!ack)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int qca8k_write_eth(struct qca8k_priv *priv, u32 reg, u32 *val, int len)\n{\n\tstruct qca8k_mgmt_eth_data *mgmt_eth_data = &priv->mgmt_eth_data;\n\tstruct sk_buff *skb;\n\tbool ack;\n\tint ret;\n\n\tskb = qca8k_alloc_mdio_header(MDIO_WRITE, reg, val,\n\t\t\t\t      QCA8K_ETHERNET_MDIO_PRIORITY, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&mgmt_eth_data->mutex);\n\n\t \n\tif (!priv->mgmt_master) {\n\t\tkfree_skb(skb);\n\t\tmutex_unlock(&mgmt_eth_data->mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tskb->dev = priv->mgmt_master;\n\n\treinit_completion(&mgmt_eth_data->rw_done);\n\n\t \n\tmgmt_eth_data->seq++;\n\tqca8k_mdio_header_fill_seq_num(skb, mgmt_eth_data->seq);\n\tmgmt_eth_data->ack = false;\n\n\tdev_queue_xmit(skb);\n\n\tret = wait_for_completion_timeout(&mgmt_eth_data->rw_done,\n\t\t\t\t\t  msecs_to_jiffies(QCA8K_ETHERNET_TIMEOUT));\n\n\tack = mgmt_eth_data->ack;\n\n\tmutex_unlock(&mgmt_eth_data->mutex);\n\n\tif (ret <= 0)\n\t\treturn -ETIMEDOUT;\n\n\tif (!ack)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int\nqca8k_regmap_update_bits_eth(struct qca8k_priv *priv, u32 reg, u32 mask, u32 write_val)\n{\n\tu32 val = 0;\n\tint ret;\n\n\tret = qca8k_read_eth(priv, reg, &val, sizeof(val));\n\tif (ret)\n\t\treturn ret;\n\n\tval &= ~mask;\n\tval |= write_val;\n\n\treturn qca8k_write_eth(priv, reg, &val, sizeof(val));\n}\n\nstatic int\nqca8k_read_mii(struct qca8k_priv *priv, uint32_t reg, uint32_t *val)\n{\n\tstruct mii_bus *bus = priv->bus;\n\tu16 r1, r2, page;\n\tint ret;\n\n\tqca8k_split_addr(reg, &r1, &r2, &page);\n\n\tmutex_lock_nested(&bus->mdio_lock, MDIO_MUTEX_NESTED);\n\n\tret = qca8k_set_page(priv, page);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tret = qca8k_mii_read32(bus, 0x10 | r2, r1, val);\n\nexit:\n\tmutex_unlock(&bus->mdio_lock);\n\treturn ret;\n}\n\nstatic int\nqca8k_write_mii(struct qca8k_priv *priv, uint32_t reg, uint32_t val)\n{\n\tstruct mii_bus *bus = priv->bus;\n\tu16 r1, r2, page;\n\tint ret;\n\n\tqca8k_split_addr(reg, &r1, &r2, &page);\n\n\tmutex_lock_nested(&bus->mdio_lock, MDIO_MUTEX_NESTED);\n\n\tret = qca8k_set_page(priv, page);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tqca8k_mii_write32(bus, 0x10 | r2, r1, val);\n\nexit:\n\tmutex_unlock(&bus->mdio_lock);\n\treturn ret;\n}\n\nstatic int\nqca8k_regmap_update_bits_mii(struct qca8k_priv *priv, uint32_t reg,\n\t\t\t     uint32_t mask, uint32_t write_val)\n{\n\tstruct mii_bus *bus = priv->bus;\n\tu16 r1, r2, page;\n\tu32 val;\n\tint ret;\n\n\tqca8k_split_addr(reg, &r1, &r2, &page);\n\n\tmutex_lock_nested(&bus->mdio_lock, MDIO_MUTEX_NESTED);\n\n\tret = qca8k_set_page(priv, page);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tret = qca8k_mii_read32(bus, 0x10 | r2, r1, &val);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tval &= ~mask;\n\tval |= write_val;\n\tqca8k_mii_write32(bus, 0x10 | r2, r1, val);\n\nexit:\n\tmutex_unlock(&bus->mdio_lock);\n\n\treturn ret;\n}\n\nstatic int\nqca8k_bulk_read(void *ctx, const void *reg_buf, size_t reg_len,\n\t\tvoid *val_buf, size_t val_len)\n{\n\tint i, count = val_len / sizeof(u32), ret;\n\tstruct qca8k_priv *priv = ctx;\n\tu32 reg = *(u16 *)reg_buf;\n\n\tif (priv->mgmt_master &&\n\t    !qca8k_read_eth(priv, reg, val_buf, val_len))\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < count; i++, reg += sizeof(u32)) {\n\t\tret = qca8k_read_mii(priv, reg, val_buf + i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nqca8k_bulk_gather_write(void *ctx, const void *reg_buf, size_t reg_len,\n\t\t\tconst void *val_buf, size_t val_len)\n{\n\tint i, count = val_len / sizeof(u32), ret;\n\tstruct qca8k_priv *priv = ctx;\n\tu32 reg = *(u16 *)reg_buf;\n\tu32 *val = (u32 *)val_buf;\n\n\tif (priv->mgmt_master &&\n\t    !qca8k_write_eth(priv, reg, val, val_len))\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < count; i++, reg += sizeof(u32), val++) {\n\t\tret = qca8k_write_mii(priv, reg, *val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nqca8k_bulk_write(void *ctx, const void *data, size_t bytes)\n{\n\treturn qca8k_bulk_gather_write(ctx, data, sizeof(u16), data + sizeof(u16),\n\t\t\t\t       bytes - sizeof(u16));\n}\n\nstatic int\nqca8k_regmap_update_bits(void *ctx, uint32_t reg, uint32_t mask, uint32_t write_val)\n{\n\tstruct qca8k_priv *priv = ctx;\n\n\tif (!qca8k_regmap_update_bits_eth(priv, reg, mask, write_val))\n\t\treturn 0;\n\n\treturn qca8k_regmap_update_bits_mii(priv, reg, mask, write_val);\n}\n\nstatic struct regmap_config qca8k_regmap_config = {\n\t.reg_bits = 16,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = 0x16ac,  \n\t.read = qca8k_bulk_read,\n\t.write = qca8k_bulk_write,\n\t.reg_update_bits = qca8k_regmap_update_bits,\n\t.rd_table = &qca8k_readable_table,\n\t.disable_locking = true,  \n\t.cache_type = REGCACHE_NONE,  \n\t.max_raw_read = 32,  \n\t \n\t.use_single_write = true,\n};\n\nstatic int\nqca8k_phy_eth_busy_wait(struct qca8k_mgmt_eth_data *mgmt_eth_data,\n\t\t\tstruct sk_buff *read_skb, u32 *val)\n{\n\tstruct sk_buff *skb = skb_copy(read_skb, GFP_KERNEL);\n\tbool ack;\n\tint ret;\n\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\treinit_completion(&mgmt_eth_data->rw_done);\n\n\t \n\tmgmt_eth_data->seq++;\n\tqca8k_mdio_header_fill_seq_num(skb, mgmt_eth_data->seq);\n\tmgmt_eth_data->ack = false;\n\n\tdev_queue_xmit(skb);\n\n\tret = wait_for_completion_timeout(&mgmt_eth_data->rw_done,\n\t\t\t\t\t  QCA8K_ETHERNET_TIMEOUT);\n\n\tack = mgmt_eth_data->ack;\n\n\tif (ret <= 0)\n\t\treturn -ETIMEDOUT;\n\n\tif (!ack)\n\t\treturn -EINVAL;\n\n\t*val = mgmt_eth_data->data[0];\n\n\treturn 0;\n}\n\nstatic int\nqca8k_phy_eth_command(struct qca8k_priv *priv, bool read, int phy,\n\t\t      int regnum, u16 data)\n{\n\tstruct sk_buff *write_skb, *clear_skb, *read_skb;\n\tstruct qca8k_mgmt_eth_data *mgmt_eth_data;\n\tu32 write_val, clear_val = 0, val;\n\tstruct net_device *mgmt_master;\n\tint ret, ret1;\n\tbool ack;\n\n\tif (regnum >= QCA8K_MDIO_MASTER_MAX_REG)\n\t\treturn -EINVAL;\n\n\tmgmt_eth_data = &priv->mgmt_eth_data;\n\n\twrite_val = QCA8K_MDIO_MASTER_BUSY | QCA8K_MDIO_MASTER_EN |\n\t\t    QCA8K_MDIO_MASTER_PHY_ADDR(phy) |\n\t\t    QCA8K_MDIO_MASTER_REG_ADDR(regnum);\n\n\tif (read) {\n\t\twrite_val |= QCA8K_MDIO_MASTER_READ;\n\t} else {\n\t\twrite_val |= QCA8K_MDIO_MASTER_WRITE;\n\t\twrite_val |= QCA8K_MDIO_MASTER_DATA(data);\n\t}\n\n\t \n\twrite_skb = qca8k_alloc_mdio_header(MDIO_WRITE, QCA8K_MDIO_MASTER_CTRL, &write_val,\n\t\t\t\t\t    QCA8K_ETHERNET_PHY_PRIORITY, sizeof(write_val));\n\tif (!write_skb)\n\t\treturn -ENOMEM;\n\n\tclear_skb = qca8k_alloc_mdio_header(MDIO_WRITE, QCA8K_MDIO_MASTER_CTRL, &clear_val,\n\t\t\t\t\t    QCA8K_ETHERNET_PHY_PRIORITY, sizeof(clear_val));\n\tif (!clear_skb) {\n\t\tret = -ENOMEM;\n\t\tgoto err_clear_skb;\n\t}\n\n\tread_skb = qca8k_alloc_mdio_header(MDIO_READ, QCA8K_MDIO_MASTER_CTRL, &clear_val,\n\t\t\t\t\t   QCA8K_ETHERNET_PHY_PRIORITY, sizeof(clear_val));\n\tif (!read_skb) {\n\t\tret = -ENOMEM;\n\t\tgoto err_read_skb;\n\t}\n\n\t \n\tmutex_lock(&priv->bus->mdio_lock);\n\n\t \n\tmutex_lock(&mgmt_eth_data->mutex);\n\n\t \n\tmgmt_master = priv->mgmt_master;\n\tif (!mgmt_master) {\n\t\tmutex_unlock(&mgmt_eth_data->mutex);\n\t\tmutex_unlock(&priv->bus->mdio_lock);\n\t\tret = -EINVAL;\n\t\tgoto err_mgmt_master;\n\t}\n\n\tread_skb->dev = mgmt_master;\n\tclear_skb->dev = mgmt_master;\n\twrite_skb->dev = mgmt_master;\n\n\treinit_completion(&mgmt_eth_data->rw_done);\n\n\t \n\tmgmt_eth_data->seq++;\n\tqca8k_mdio_header_fill_seq_num(write_skb, mgmt_eth_data->seq);\n\tmgmt_eth_data->ack = false;\n\n\tdev_queue_xmit(write_skb);\n\n\tret = wait_for_completion_timeout(&mgmt_eth_data->rw_done,\n\t\t\t\t\t  QCA8K_ETHERNET_TIMEOUT);\n\n\tack = mgmt_eth_data->ack;\n\n\tif (ret <= 0) {\n\t\tret = -ETIMEDOUT;\n\t\tkfree_skb(read_skb);\n\t\tgoto exit;\n\t}\n\n\tif (!ack) {\n\t\tret = -EINVAL;\n\t\tkfree_skb(read_skb);\n\t\tgoto exit;\n\t}\n\n\tret = read_poll_timeout(qca8k_phy_eth_busy_wait, ret1,\n\t\t\t\t!(val & QCA8K_MDIO_MASTER_BUSY), 0,\n\t\t\t\tQCA8K_BUSY_WAIT_TIMEOUT * USEC_PER_MSEC, false,\n\t\t\t\tmgmt_eth_data, read_skb, &val);\n\n\tif (ret < 0 && ret1 < 0) {\n\t\tret = ret1;\n\t\tgoto exit;\n\t}\n\n\tif (read) {\n\t\treinit_completion(&mgmt_eth_data->rw_done);\n\n\t\t \n\t\tmgmt_eth_data->seq++;\n\t\tqca8k_mdio_header_fill_seq_num(read_skb, mgmt_eth_data->seq);\n\t\tmgmt_eth_data->ack = false;\n\n\t\tdev_queue_xmit(read_skb);\n\n\t\tret = wait_for_completion_timeout(&mgmt_eth_data->rw_done,\n\t\t\t\t\t\t  QCA8K_ETHERNET_TIMEOUT);\n\n\t\tack = mgmt_eth_data->ack;\n\n\t\tif (ret <= 0) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (!ack) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tret = mgmt_eth_data->data[0] & QCA8K_MDIO_MASTER_DATA_MASK;\n\t} else {\n\t\tkfree_skb(read_skb);\n\t}\nexit:\n\treinit_completion(&mgmt_eth_data->rw_done);\n\n\t \n\tmgmt_eth_data->seq++;\n\tqca8k_mdio_header_fill_seq_num(clear_skb, mgmt_eth_data->seq);\n\tmgmt_eth_data->ack = false;\n\n\tdev_queue_xmit(clear_skb);\n\n\twait_for_completion_timeout(&mgmt_eth_data->rw_done,\n\t\t\t\t    QCA8K_ETHERNET_TIMEOUT);\n\n\tmutex_unlock(&mgmt_eth_data->mutex);\n\tmutex_unlock(&priv->bus->mdio_lock);\n\n\treturn ret;\n\n\t \nerr_mgmt_master:\n\tkfree_skb(read_skb);\nerr_read_skb:\n\tkfree_skb(clear_skb);\nerr_clear_skb:\n\tkfree_skb(write_skb);\n\n\treturn ret;\n}\n\nstatic int\nqca8k_mdio_busy_wait(struct mii_bus *bus, u32 reg, u32 mask)\n{\n\tu16 r1, r2, page;\n\tu32 val;\n\tint ret, ret1;\n\n\tqca8k_split_addr(reg, &r1, &r2, &page);\n\n\tret = read_poll_timeout(qca8k_mii_read_hi, ret1, !(val & mask), 0,\n\t\t\t\tQCA8K_BUSY_WAIT_TIMEOUT * USEC_PER_MSEC, false,\n\t\t\t\tbus, 0x10 | r2, r1 + 1, &val);\n\n\t \n\tif (ret < 0 && ret1 < 0)\n\t\treturn ret1;\n\n\treturn ret;\n}\n\nstatic int\nqca8k_mdio_write(struct qca8k_priv *priv, int phy, int regnum, u16 data)\n{\n\tstruct mii_bus *bus = priv->bus;\n\tu16 r1, r2, page;\n\tu32 val;\n\tint ret;\n\n\tif (regnum >= QCA8K_MDIO_MASTER_MAX_REG)\n\t\treturn -EINVAL;\n\n\tval = QCA8K_MDIO_MASTER_BUSY | QCA8K_MDIO_MASTER_EN |\n\t      QCA8K_MDIO_MASTER_WRITE | QCA8K_MDIO_MASTER_PHY_ADDR(phy) |\n\t      QCA8K_MDIO_MASTER_REG_ADDR(regnum) |\n\t      QCA8K_MDIO_MASTER_DATA(data);\n\n\tqca8k_split_addr(QCA8K_MDIO_MASTER_CTRL, &r1, &r2, &page);\n\n\tmutex_lock_nested(&bus->mdio_lock, MDIO_MUTEX_NESTED);\n\n\tret = qca8k_set_page(priv, page);\n\tif (ret)\n\t\tgoto exit;\n\n\tqca8k_mii_write32(bus, 0x10 | r2, r1, val);\n\n\tret = qca8k_mdio_busy_wait(bus, QCA8K_MDIO_MASTER_CTRL,\n\t\t\t\t   QCA8K_MDIO_MASTER_BUSY);\n\nexit:\n\t \n\tqca8k_mii_write_hi(bus, 0x10 | r2, r1 + 1, 0);\n\n\tmutex_unlock(&bus->mdio_lock);\n\n\treturn ret;\n}\n\nstatic int\nqca8k_mdio_read(struct qca8k_priv *priv, int phy, int regnum)\n{\n\tstruct mii_bus *bus = priv->bus;\n\tu16 r1, r2, page;\n\tu32 val;\n\tint ret;\n\n\tif (regnum >= QCA8K_MDIO_MASTER_MAX_REG)\n\t\treturn -EINVAL;\n\n\tval = QCA8K_MDIO_MASTER_BUSY | QCA8K_MDIO_MASTER_EN |\n\t      QCA8K_MDIO_MASTER_READ | QCA8K_MDIO_MASTER_PHY_ADDR(phy) |\n\t      QCA8K_MDIO_MASTER_REG_ADDR(regnum);\n\n\tqca8k_split_addr(QCA8K_MDIO_MASTER_CTRL, &r1, &r2, &page);\n\n\tmutex_lock_nested(&bus->mdio_lock, MDIO_MUTEX_NESTED);\n\n\tret = qca8k_set_page(priv, page);\n\tif (ret)\n\t\tgoto exit;\n\n\tqca8k_mii_write_hi(bus, 0x10 | r2, r1 + 1, val);\n\n\tret = qca8k_mdio_busy_wait(bus, QCA8K_MDIO_MASTER_CTRL,\n\t\t\t\t   QCA8K_MDIO_MASTER_BUSY);\n\tif (ret)\n\t\tgoto exit;\n\n\tret = qca8k_mii_read_lo(bus, 0x10 | r2, r1, &val);\n\nexit:\n\t \n\tqca8k_mii_write_hi(bus, 0x10 | r2, r1 + 1, 0);\n\n\tmutex_unlock(&bus->mdio_lock);\n\n\tif (ret >= 0)\n\t\tret = val & QCA8K_MDIO_MASTER_DATA_MASK;\n\n\treturn ret;\n}\n\nstatic int\nqca8k_internal_mdio_write(struct mii_bus *slave_bus, int phy, int regnum, u16 data)\n{\n\tstruct qca8k_priv *priv = slave_bus->priv;\n\tint ret;\n\n\t \n\tret = qca8k_phy_eth_command(priv, false, phy, regnum, data);\n\tif (!ret)\n\t\treturn 0;\n\n\treturn qca8k_mdio_write(priv, phy, regnum, data);\n}\n\nstatic int\nqca8k_internal_mdio_read(struct mii_bus *slave_bus, int phy, int regnum)\n{\n\tstruct qca8k_priv *priv = slave_bus->priv;\n\tint ret;\n\n\t \n\tret = qca8k_phy_eth_command(priv, true, phy, regnum, 0);\n\tif (ret >= 0)\n\t\treturn ret;\n\n\tret = qca8k_mdio_read(priv, phy, regnum);\n\n\tif (ret < 0)\n\t\treturn 0xffff;\n\n\treturn ret;\n}\n\nstatic int\nqca8k_legacy_mdio_write(struct mii_bus *slave_bus, int port, int regnum, u16 data)\n{\n\tport = qca8k_port_to_phy(port) % PHY_MAX_ADDR;\n\n\treturn qca8k_internal_mdio_write(slave_bus, port, regnum, data);\n}\n\nstatic int\nqca8k_legacy_mdio_read(struct mii_bus *slave_bus, int port, int regnum)\n{\n\tport = qca8k_port_to_phy(port) % PHY_MAX_ADDR;\n\n\treturn qca8k_internal_mdio_read(slave_bus, port, regnum);\n}\n\nstatic int\nqca8k_mdio_register(struct qca8k_priv *priv)\n{\n\tstruct dsa_switch *ds = priv->ds;\n\tstruct device_node *mdio;\n\tstruct mii_bus *bus;\n\n\tbus = devm_mdiobus_alloc(ds->dev);\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\tbus->priv = (void *)priv;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"qca8k-%d.%d\",\n\t\t ds->dst->index, ds->index);\n\tbus->parent = ds->dev;\n\tbus->phy_mask = ~ds->phys_mii_mask;\n\tds->slave_mii_bus = bus;\n\n\t \n\tmdio = of_get_child_by_name(priv->dev->of_node, \"mdio\");\n\tif (of_device_is_available(mdio)) {\n\t\tbus->name = \"qca8k slave mii\";\n\t\tbus->read = qca8k_internal_mdio_read;\n\t\tbus->write = qca8k_internal_mdio_write;\n\t\treturn devm_of_mdiobus_register(priv->dev, bus, mdio);\n\t}\n\n\t \n\tbus->name = \"qca8k-legacy slave mii\";\n\tbus->read = qca8k_legacy_mdio_read;\n\tbus->write = qca8k_legacy_mdio_write;\n\treturn devm_mdiobus_register(priv->dev, bus);\n}\n\nstatic int\nqca8k_setup_mdio_bus(struct qca8k_priv *priv)\n{\n\tu32 internal_mdio_mask = 0, external_mdio_mask = 0, reg;\n\tstruct device_node *ports, *port;\n\tphy_interface_t mode;\n\tint err;\n\n\tports = of_get_child_by_name(priv->dev->of_node, \"ports\");\n\tif (!ports)\n\t\tports = of_get_child_by_name(priv->dev->of_node, \"ethernet-ports\");\n\n\tif (!ports)\n\t\treturn -EINVAL;\n\n\tfor_each_available_child_of_node(ports, port) {\n\t\terr = of_property_read_u32(port, \"reg\", &reg);\n\t\tif (err) {\n\t\t\tof_node_put(port);\n\t\t\tof_node_put(ports);\n\t\t\treturn err;\n\t\t}\n\n\t\tif (!dsa_is_user_port(priv->ds, reg))\n\t\t\tcontinue;\n\n\t\tof_get_phy_mode(port, &mode);\n\n\t\tif (of_property_read_bool(port, \"phy-handle\") &&\n\t\t    mode != PHY_INTERFACE_MODE_INTERNAL)\n\t\t\texternal_mdio_mask |= BIT(reg);\n\t\telse\n\t\t\tinternal_mdio_mask |= BIT(reg);\n\t}\n\n\tof_node_put(ports);\n\tif (!external_mdio_mask && !internal_mdio_mask) {\n\t\tdev_err(priv->dev, \"no PHYs are defined.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!!external_mdio_mask && !!internal_mdio_mask) {\n\t\tdev_err(priv->dev, \"either internal or external mdio bus configuration is supported.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (external_mdio_mask) {\n\t\t \n\n\t\treturn regmap_clear_bits(priv->regmap, QCA8K_MDIO_MASTER_CTRL,\n\t\t\t\t\t QCA8K_MDIO_MASTER_EN);\n\t}\n\n\treturn qca8k_mdio_register(priv);\n}\n\nstatic int\nqca8k_setup_mac_pwr_sel(struct qca8k_priv *priv)\n{\n\tu32 mask = 0;\n\tint ret = 0;\n\n\t \n\tif (of_machine_is_compatible(\"qcom,ipq8064\"))\n\t\tmask |= QCA8K_MAC_PWR_RGMII0_1_8V;\n\n\t \n\tif (of_machine_is_compatible(\"qcom,ipq8065\"))\n\t\tmask |= QCA8K_MAC_PWR_RGMII1_1_8V;\n\n\tif (mask) {\n\t\tret = qca8k_rmw(priv, QCA8K_REG_MAC_PWR_SEL,\n\t\t\t\tQCA8K_MAC_PWR_RGMII0_1_8V |\n\t\t\t\tQCA8K_MAC_PWR_RGMII1_1_8V,\n\t\t\t\tmask);\n\t}\n\n\treturn ret;\n}\n\nstatic int qca8k_find_cpu_port(struct dsa_switch *ds)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\n\t \n\tif (dsa_is_cpu_port(ds, 0))\n\t\treturn 0;\n\n\tdev_dbg(priv->dev, \"port 0 is not the CPU port. Checking port 6\");\n\n\tif (dsa_is_cpu_port(ds, 6))\n\t\treturn 6;\n\n\treturn -EINVAL;\n}\n\nstatic int\nqca8k_setup_of_pws_reg(struct qca8k_priv *priv)\n{\n\tconst struct qca8k_match_data *data = priv->info;\n\tstruct device_node *node = priv->dev->of_node;\n\tu32 val = 0;\n\tint ret;\n\n\t \n\tif (priv->switch_id == QCA8K_ID_QCA8327) {\n\t\t \n\t\tif (data->reduced_package)\n\t\t\tval |= QCA8327_PWS_PACKAGE148_EN;\n\n\t\tret = qca8k_rmw(priv, QCA8K_REG_PWS, QCA8327_PWS_PACKAGE148_EN,\n\t\t\t\tval);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (of_property_read_bool(node, \"qca,ignore-power-on-sel\"))\n\t\tval |= QCA8K_PWS_POWER_ON_SEL;\n\n\tif (of_property_read_bool(node, \"qca,led-open-drain\")) {\n\t\tif (!(val & QCA8K_PWS_POWER_ON_SEL)) {\n\t\t\tdev_err(priv->dev, \"qca,led-open-drain require qca,ignore-power-on-sel to be set.\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tval |= QCA8K_PWS_LED_OPEN_EN_CSR;\n\t}\n\n\treturn qca8k_rmw(priv, QCA8K_REG_PWS,\n\t\t\tQCA8K_PWS_LED_OPEN_EN_CSR | QCA8K_PWS_POWER_ON_SEL,\n\t\t\tval);\n}\n\nstatic int\nqca8k_parse_port_config(struct qca8k_priv *priv)\n{\n\tint port, cpu_port_index = -1, ret;\n\tstruct device_node *port_dn;\n\tphy_interface_t mode;\n\tstruct dsa_port *dp;\n\tu32 delay;\n\n\t \n\tfor (port = 0; port < QCA8K_NUM_PORTS; port++) {\n\t\t \n\t\tif (port != 0 && port != 6)\n\t\t\tcontinue;\n\n\t\tdp = dsa_to_port(priv->ds, port);\n\t\tport_dn = dp->dn;\n\t\tcpu_port_index++;\n\n\t\tif (!of_device_is_available(port_dn))\n\t\t\tcontinue;\n\n\t\tret = of_get_phy_mode(port_dn, &mode);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tswitch (mode) {\n\t\tcase PHY_INTERFACE_MODE_RGMII:\n\t\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\t\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\tcase PHY_INTERFACE_MODE_SGMII:\n\t\t\tdelay = 0;\n\n\t\t\tif (!of_property_read_u32(port_dn, \"tx-internal-delay-ps\", &delay))\n\t\t\t\t \n\t\t\t\tdelay = delay / 1000;\n\t\t\telse if (mode == PHY_INTERFACE_MODE_RGMII_ID ||\n\t\t\t\t mode == PHY_INTERFACE_MODE_RGMII_TXID)\n\t\t\t\tdelay = 1;\n\n\t\t\tif (!FIELD_FIT(QCA8K_PORT_PAD_RGMII_TX_DELAY_MASK, delay)) {\n\t\t\t\tdev_err(priv->dev, \"rgmii tx delay is limited to a max value of 3ns, setting to the max value\");\n\t\t\t\tdelay = 3;\n\t\t\t}\n\n\t\t\tpriv->ports_config.rgmii_tx_delay[cpu_port_index] = delay;\n\n\t\t\tdelay = 0;\n\n\t\t\tif (!of_property_read_u32(port_dn, \"rx-internal-delay-ps\", &delay))\n\t\t\t\t \n\t\t\t\tdelay = delay / 1000;\n\t\t\telse if (mode == PHY_INTERFACE_MODE_RGMII_ID ||\n\t\t\t\t mode == PHY_INTERFACE_MODE_RGMII_RXID)\n\t\t\t\tdelay = 2;\n\n\t\t\tif (!FIELD_FIT(QCA8K_PORT_PAD_RGMII_RX_DELAY_MASK, delay)) {\n\t\t\t\tdev_err(priv->dev, \"rgmii rx delay is limited to a max value of 3ns, setting to the max value\");\n\t\t\t\tdelay = 3;\n\t\t\t}\n\n\t\t\tpriv->ports_config.rgmii_rx_delay[cpu_port_index] = delay;\n\n\t\t\t \n\t\t\tif (mode == PHY_INTERFACE_MODE_RGMII ||\n\t\t\t    mode == PHY_INTERFACE_MODE_RGMII_ID ||\n\t\t\t    mode == PHY_INTERFACE_MODE_RGMII_TXID ||\n\t\t\t    mode == PHY_INTERFACE_MODE_RGMII_RXID)\n\t\t\t\tbreak;\n\n\t\t\tif (of_property_read_bool(port_dn, \"qca,sgmii-txclk-falling-edge\"))\n\t\t\t\tpriv->ports_config.sgmii_tx_clk_falling_edge = true;\n\n\t\t\tif (of_property_read_bool(port_dn, \"qca,sgmii-rxclk-falling-edge\"))\n\t\t\t\tpriv->ports_config.sgmii_rx_clk_falling_edge = true;\n\n\t\t\tif (of_property_read_bool(port_dn, \"qca,sgmii-enable-pll\")) {\n\t\t\t\tpriv->ports_config.sgmii_enable_pll = true;\n\n\t\t\t\tif (priv->switch_id == QCA8K_ID_QCA8327) {\n\t\t\t\t\tdev_err(priv->dev, \"SGMII PLL should NOT be enabled for qca8327. Aborting enabling\");\n\t\t\t\t\tpriv->ports_config.sgmii_enable_pll = false;\n\t\t\t\t}\n\n\t\t\t\tif (priv->switch_revision < 2)\n\t\t\t\t\tdev_warn(priv->dev, \"SGMII PLL should NOT be enabled for qca8337 with revision 2 or more.\");\n\t\t\t}\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void\nqca8k_mac_config_setup_internal_delay(struct qca8k_priv *priv, int cpu_port_index,\n\t\t\t\t      u32 reg)\n{\n\tu32 delay, val = 0;\n\tint ret;\n\n\t \n\tif (priv->ports_config.rgmii_tx_delay[cpu_port_index]) {\n\t\tdelay = priv->ports_config.rgmii_tx_delay[cpu_port_index];\n\n\t\tval |= QCA8K_PORT_PAD_RGMII_TX_DELAY(delay) |\n\t\t\tQCA8K_PORT_PAD_RGMII_TX_DELAY_EN;\n\t}\n\n\tif (priv->ports_config.rgmii_rx_delay[cpu_port_index]) {\n\t\tdelay = priv->ports_config.rgmii_rx_delay[cpu_port_index];\n\n\t\tval |= QCA8K_PORT_PAD_RGMII_RX_DELAY(delay) |\n\t\t\tQCA8K_PORT_PAD_RGMII_RX_DELAY_EN;\n\t}\n\n\t \n\tret = qca8k_rmw(priv, reg,\n\t\t\tQCA8K_PORT_PAD_RGMII_TX_DELAY_MASK |\n\t\t\tQCA8K_PORT_PAD_RGMII_RX_DELAY_MASK |\n\t\t\tQCA8K_PORT_PAD_RGMII_TX_DELAY_EN |\n\t\t\tQCA8K_PORT_PAD_RGMII_RX_DELAY_EN,\n\t\t\tval);\n\tif (ret)\n\t\tdev_err(priv->dev, \"Failed to set internal delay for CPU port%d\",\n\t\t\tcpu_port_index == QCA8K_CPU_PORT0 ? 0 : 6);\n}\n\nstatic struct phylink_pcs *\nqca8k_phylink_mac_select_pcs(struct dsa_switch *ds, int port,\n\t\t\t     phy_interface_t interface)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\tstruct phylink_pcs *pcs = NULL;\n\n\tswitch (interface) {\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\t\tswitch (port) {\n\t\tcase 0:\n\t\t\tpcs = &priv->pcs_port_0.pcs;\n\t\t\tbreak;\n\n\t\tcase 6:\n\t\t\tpcs = &priv->pcs_port_6.pcs;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn pcs;\n}\n\nstatic void\nqca8k_phylink_mac_config(struct dsa_switch *ds, int port, unsigned int mode,\n\t\t\t const struct phylink_link_state *state)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\tint cpu_port_index;\n\tu32 reg;\n\n\tswitch (port) {\n\tcase 0:  \n\t\tif (state->interface != PHY_INTERFACE_MODE_RGMII &&\n\t\t    state->interface != PHY_INTERFACE_MODE_RGMII_ID &&\n\t\t    state->interface != PHY_INTERFACE_MODE_RGMII_TXID &&\n\t\t    state->interface != PHY_INTERFACE_MODE_RGMII_RXID &&\n\t\t    state->interface != PHY_INTERFACE_MODE_SGMII)\n\t\t\treturn;\n\n\t\treg = QCA8K_REG_PORT0_PAD_CTRL;\n\t\tcpu_port_index = QCA8K_CPU_PORT0;\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\tcase 5:\n\t\t \n\t\treturn;\n\tcase 6:  \n\t\tif (state->interface != PHY_INTERFACE_MODE_RGMII &&\n\t\t    state->interface != PHY_INTERFACE_MODE_RGMII_ID &&\n\t\t    state->interface != PHY_INTERFACE_MODE_RGMII_TXID &&\n\t\t    state->interface != PHY_INTERFACE_MODE_RGMII_RXID &&\n\t\t    state->interface != PHY_INTERFACE_MODE_SGMII &&\n\t\t    state->interface != PHY_INTERFACE_MODE_1000BASEX)\n\t\t\treturn;\n\n\t\treg = QCA8K_REG_PORT6_PAD_CTRL;\n\t\tcpu_port_index = QCA8K_CPU_PORT6;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(ds->dev, \"%s: unsupported port: %i\\n\", __func__, port);\n\t\treturn;\n\t}\n\n\tif (port != 6 && phylink_autoneg_inband(mode)) {\n\t\tdev_err(ds->dev, \"%s: in-band negotiation unsupported\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tswitch (state->interface) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\tqca8k_write(priv, reg, QCA8K_PORT_PAD_RGMII_EN);\n\n\t\t \n\t\tqca8k_mac_config_setup_internal_delay(priv, cpu_port_index, reg);\n\n\t\t \n\t\tif (priv->switch_id == QCA8K_ID_QCA8337)\n\t\t\tqca8k_write(priv, QCA8K_REG_PORT5_PAD_CTRL,\n\t\t\t\t    QCA8K_PORT_PAD_RGMII_RX_DELAY_EN);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\t\t \n\t\tqca8k_write(priv, reg, QCA8K_PORT_PAD_SGMII_EN);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(ds->dev, \"xMII mode %s not supported for port %d\\n\",\n\t\t\tphy_modes(state->interface), port);\n\t\treturn;\n\t}\n}\n\nstatic void qca8k_phylink_get_caps(struct dsa_switch *ds, int port,\n\t\t\t\t   struct phylink_config *config)\n{\n\tswitch (port) {\n\tcase 0:  \n\t\tphy_interface_set_rgmii(config->supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_SGMII,\n\t\t\t  config->supported_interfaces);\n\t\tbreak;\n\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 4:\n\tcase 5:\n\t\t \n\t\t__set_bit(PHY_INTERFACE_MODE_GMII,\n\t\t\t  config->supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_INTERNAL,\n\t\t\t  config->supported_interfaces);\n\t\tbreak;\n\n\tcase 6:  \n\t\tphy_interface_set_rgmii(config->supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_SGMII,\n\t\t\t  config->supported_interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_1000BASEX,\n\t\t\t  config->supported_interfaces);\n\t\tbreak;\n\t}\n\n\tconfig->mac_capabilities = MAC_ASYM_PAUSE | MAC_SYM_PAUSE |\n\t\tMAC_10 | MAC_100 | MAC_1000FD;\n}\n\nstatic void\nqca8k_phylink_mac_link_down(struct dsa_switch *ds, int port, unsigned int mode,\n\t\t\t    phy_interface_t interface)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\n\tqca8k_port_set_status(priv, port, 0);\n}\n\nstatic void\nqca8k_phylink_mac_link_up(struct dsa_switch *ds, int port, unsigned int mode,\n\t\t\t  phy_interface_t interface, struct phy_device *phydev,\n\t\t\t  int speed, int duplex, bool tx_pause, bool rx_pause)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\tu32 reg;\n\n\tif (phylink_autoneg_inband(mode)) {\n\t\treg = QCA8K_PORT_STATUS_LINK_AUTO;\n\t} else {\n\t\tswitch (speed) {\n\t\tcase SPEED_10:\n\t\t\treg = QCA8K_PORT_STATUS_SPEED_10;\n\t\t\tbreak;\n\t\tcase SPEED_100:\n\t\t\treg = QCA8K_PORT_STATUS_SPEED_100;\n\t\t\tbreak;\n\t\tcase SPEED_1000:\n\t\t\treg = QCA8K_PORT_STATUS_SPEED_1000;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treg = QCA8K_PORT_STATUS_LINK_AUTO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (duplex == DUPLEX_FULL)\n\t\t\treg |= QCA8K_PORT_STATUS_DUPLEX;\n\n\t\tif (rx_pause || dsa_is_cpu_port(ds, port))\n\t\t\treg |= QCA8K_PORT_STATUS_RXFLOW;\n\n\t\tif (tx_pause || dsa_is_cpu_port(ds, port))\n\t\t\treg |= QCA8K_PORT_STATUS_TXFLOW;\n\t}\n\n\treg |= QCA8K_PORT_STATUS_TXMAC | QCA8K_PORT_STATUS_RXMAC;\n\n\tqca8k_write(priv, QCA8K_REG_PORT_STATUS(port), reg);\n}\n\nstatic struct qca8k_pcs *pcs_to_qca8k_pcs(struct phylink_pcs *pcs)\n{\n\treturn container_of(pcs, struct qca8k_pcs, pcs);\n}\n\nstatic void qca8k_pcs_get_state(struct phylink_pcs *pcs,\n\t\t\t\tstruct phylink_link_state *state)\n{\n\tstruct qca8k_priv *priv = pcs_to_qca8k_pcs(pcs)->priv;\n\tint port = pcs_to_qca8k_pcs(pcs)->port;\n\tu32 reg;\n\tint ret;\n\n\tret = qca8k_read(priv, QCA8K_REG_PORT_STATUS(port), &reg);\n\tif (ret < 0) {\n\t\tstate->link = false;\n\t\treturn;\n\t}\n\n\tstate->link = !!(reg & QCA8K_PORT_STATUS_LINK_UP);\n\tstate->an_complete = state->link;\n\tstate->duplex = (reg & QCA8K_PORT_STATUS_DUPLEX) ? DUPLEX_FULL :\n\t\t\t\t\t\t\t   DUPLEX_HALF;\n\n\tswitch (reg & QCA8K_PORT_STATUS_SPEED) {\n\tcase QCA8K_PORT_STATUS_SPEED_10:\n\t\tstate->speed = SPEED_10;\n\t\tbreak;\n\tcase QCA8K_PORT_STATUS_SPEED_100:\n\t\tstate->speed = SPEED_100;\n\t\tbreak;\n\tcase QCA8K_PORT_STATUS_SPEED_1000:\n\t\tstate->speed = SPEED_1000;\n\t\tbreak;\n\tdefault:\n\t\tstate->speed = SPEED_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tif (reg & QCA8K_PORT_STATUS_RXFLOW)\n\t\tstate->pause |= MLO_PAUSE_RX;\n\tif (reg & QCA8K_PORT_STATUS_TXFLOW)\n\t\tstate->pause |= MLO_PAUSE_TX;\n}\n\nstatic int qca8k_pcs_config(struct phylink_pcs *pcs, unsigned int neg_mode,\n\t\t\t    phy_interface_t interface,\n\t\t\t    const unsigned long *advertising,\n\t\t\t    bool permit_pause_to_mac)\n{\n\tstruct qca8k_priv *priv = pcs_to_qca8k_pcs(pcs)->priv;\n\tint cpu_port_index, ret, port;\n\tu32 reg, val;\n\n\tport = pcs_to_qca8k_pcs(pcs)->port;\n\tswitch (port) {\n\tcase 0:\n\t\treg = QCA8K_REG_PORT0_PAD_CTRL;\n\t\tcpu_port_index = QCA8K_CPU_PORT0;\n\t\tbreak;\n\n\tcase 6:\n\t\treg = QCA8K_REG_PORT6_PAD_CTRL;\n\t\tcpu_port_index = QCA8K_CPU_PORT6;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tval = neg_mode == PHYLINK_PCS_NEG_INBAND_ENABLED ?\n\t\t0 : QCA8K_PWS_SERDES_AEN_DIS;\n\n\tret = qca8k_rmw(priv, QCA8K_REG_PWS, QCA8K_PWS_SERDES_AEN_DIS, val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = qca8k_read(priv, QCA8K_REG_SGMII_CTRL, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval |= QCA8K_SGMII_EN_SD;\n\n\tif (priv->ports_config.sgmii_enable_pll)\n\t\tval |= QCA8K_SGMII_EN_PLL | QCA8K_SGMII_EN_RX |\n\t\t       QCA8K_SGMII_EN_TX;\n\n\tif (dsa_is_cpu_port(priv->ds, port)) {\n\t\t \n\t\tval &= ~QCA8K_SGMII_MODE_CTRL_MASK;\n\t\tval |= QCA8K_SGMII_MODE_CTRL_PHY;\n\t} else if (interface == PHY_INTERFACE_MODE_SGMII) {\n\t\tval &= ~QCA8K_SGMII_MODE_CTRL_MASK;\n\t\tval |= QCA8K_SGMII_MODE_CTRL_MAC;\n\t} else if (interface == PHY_INTERFACE_MODE_1000BASEX) {\n\t\tval &= ~QCA8K_SGMII_MODE_CTRL_MASK;\n\t\tval |= QCA8K_SGMII_MODE_CTRL_BASEX;\n\t}\n\n\tqca8k_write(priv, QCA8K_REG_SGMII_CTRL, val);\n\n\t \n\tif (interface == PHY_INTERFACE_MODE_SGMII)\n\t\tqca8k_mac_config_setup_internal_delay(priv, cpu_port_index, reg);\n\t \n\tif (priv->switch_id == QCA8K_ID_QCA8327 ||\n\t    priv->switch_id == QCA8K_ID_QCA8337)\n\t\treg = QCA8K_REG_PORT0_PAD_CTRL;\n\n\tval = 0;\n\n\t \n\tif (priv->ports_config.sgmii_rx_clk_falling_edge)\n\t\tval |= QCA8K_PORT0_PAD_SGMII_RXCLK_FALLING_EDGE;\n\n\tif (priv->ports_config.sgmii_tx_clk_falling_edge)\n\t\tval |= QCA8K_PORT0_PAD_SGMII_TXCLK_FALLING_EDGE;\n\n\tif (val)\n\t\tret = qca8k_rmw(priv, reg,\n\t\t\t\tQCA8K_PORT0_PAD_SGMII_RXCLK_FALLING_EDGE |\n\t\t\t\tQCA8K_PORT0_PAD_SGMII_TXCLK_FALLING_EDGE,\n\t\t\t\tval);\n\n\treturn 0;\n}\n\nstatic void qca8k_pcs_an_restart(struct phylink_pcs *pcs)\n{\n}\n\nstatic const struct phylink_pcs_ops qca8k_pcs_ops = {\n\t.pcs_get_state = qca8k_pcs_get_state,\n\t.pcs_config = qca8k_pcs_config,\n\t.pcs_an_restart = qca8k_pcs_an_restart,\n};\n\nstatic void qca8k_setup_pcs(struct qca8k_priv *priv, struct qca8k_pcs *qpcs,\n\t\t\t    int port)\n{\n\tqpcs->pcs.ops = &qca8k_pcs_ops;\n\tqpcs->pcs.neg_mode = true;\n\n\t \n\tqpcs->pcs.poll = true;\n\tqpcs->priv = priv;\n\tqpcs->port = port;\n}\n\nstatic void qca8k_mib_autocast_handler(struct dsa_switch *ds, struct sk_buff *skb)\n{\n\tstruct qca8k_mib_eth_data *mib_eth_data;\n\tstruct qca8k_priv *priv = ds->priv;\n\tconst struct qca8k_mib_desc *mib;\n\tstruct mib_ethhdr *mib_ethhdr;\n\t__le32 *data2;\n\tu8 port;\n\tint i;\n\n\tmib_ethhdr = (struct mib_ethhdr *)skb_mac_header(skb);\n\tmib_eth_data = &priv->mib_eth_data;\n\n\t \n\tport = FIELD_GET(QCA_HDR_RECV_SOURCE_PORT, ntohs(mib_ethhdr->hdr));\n\tif (port != mib_eth_data->req_port)\n\t\tgoto exit;\n\n\tdata2 = (__le32 *)skb->data;\n\n\tfor (i = 0; i < priv->info->mib_count; i++) {\n\t\tmib = &ar8327_mib[i];\n\n\t\t \n\t\tif (i < 3) {\n\t\t\tmib_eth_data->data[i] = get_unaligned_le32(mib_ethhdr->data + i);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (mib->size == 2)\n\t\t\tmib_eth_data->data[i] = get_unaligned_le64((__le64 *)data2);\n\t\telse\n\t\t\tmib_eth_data->data[i] = get_unaligned_le32(data2);\n\n\t\tdata2 += mib->size;\n\t}\n\nexit:\n\t \n\tif (refcount_dec_and_test(&mib_eth_data->port_parsed))\n\t\tcomplete(&mib_eth_data->rw_done);\n}\n\nstatic int\nqca8k_get_ethtool_stats_eth(struct dsa_switch *ds, int port, u64 *data)\n{\n\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\tstruct qca8k_mib_eth_data *mib_eth_data;\n\tstruct qca8k_priv *priv = ds->priv;\n\tint ret;\n\n\tmib_eth_data = &priv->mib_eth_data;\n\n\tmutex_lock(&mib_eth_data->mutex);\n\n\treinit_completion(&mib_eth_data->rw_done);\n\n\tmib_eth_data->req_port = dp->index;\n\tmib_eth_data->data = data;\n\trefcount_set(&mib_eth_data->port_parsed, QCA8K_NUM_PORTS);\n\n\tmutex_lock(&priv->reg_mutex);\n\n\t \n\tret = regmap_update_bits(priv->regmap, QCA8K_REG_MIB,\n\t\t\t\t QCA8K_MIB_FUNC | QCA8K_MIB_BUSY,\n\t\t\t\t FIELD_PREP(QCA8K_MIB_FUNC, QCA8K_MIB_CAST) |\n\t\t\t\t QCA8K_MIB_BUSY);\n\n\tmutex_unlock(&priv->reg_mutex);\n\n\tif (ret)\n\t\tgoto exit;\n\n\tret = wait_for_completion_timeout(&mib_eth_data->rw_done, QCA8K_ETHERNET_TIMEOUT);\n\nexit:\n\tmutex_unlock(&mib_eth_data->mutex);\n\n\treturn ret;\n}\n\nstatic u32 qca8k_get_phy_flags(struct dsa_switch *ds, int port)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\n\t \n\tif (port > 0 && port < 6)\n\t\treturn priv->switch_revision;\n\n\treturn 0;\n}\n\nstatic enum dsa_tag_protocol\nqca8k_get_tag_protocol(struct dsa_switch *ds, int port,\n\t\t       enum dsa_tag_protocol mp)\n{\n\treturn DSA_TAG_PROTO_QCA;\n}\n\nstatic void\nqca8k_master_change(struct dsa_switch *ds, const struct net_device *master,\n\t\t    bool operational)\n{\n\tstruct dsa_port *dp = master->dsa_ptr;\n\tstruct qca8k_priv *priv = ds->priv;\n\n\t \n\tif (dp->index != 0)\n\t\treturn;\n\n\tmutex_lock(&priv->mgmt_eth_data.mutex);\n\tmutex_lock(&priv->mib_eth_data.mutex);\n\n\tpriv->mgmt_master = operational ? (struct net_device *)master : NULL;\n\n\tmutex_unlock(&priv->mib_eth_data.mutex);\n\tmutex_unlock(&priv->mgmt_eth_data.mutex);\n}\n\nstatic int qca8k_connect_tag_protocol(struct dsa_switch *ds,\n\t\t\t\t      enum dsa_tag_protocol proto)\n{\n\tstruct qca_tagger_data *tagger_data;\n\n\tswitch (proto) {\n\tcase DSA_TAG_PROTO_QCA:\n\t\ttagger_data = ds->tagger_data;\n\n\t\ttagger_data->rw_reg_ack_handler = qca8k_rw_reg_ack_handler;\n\t\ttagger_data->mib_autocast_handler = qca8k_mib_autocast_handler;\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic void qca8k_setup_hol_fixup(struct qca8k_priv *priv, int port)\n{\n\tu32 mask;\n\n\tswitch (port) {\n\t \n\tcase 0:\n\tcase 5:\n\tcase 6:\n\t\tmask = QCA8K_PORT_HOL_CTRL0_EG_PRI0(0x3) |\n\t\t\tQCA8K_PORT_HOL_CTRL0_EG_PRI1(0x4) |\n\t\t\tQCA8K_PORT_HOL_CTRL0_EG_PRI2(0x4) |\n\t\t\tQCA8K_PORT_HOL_CTRL0_EG_PRI3(0x4) |\n\t\t\tQCA8K_PORT_HOL_CTRL0_EG_PRI4(0x6) |\n\t\t\tQCA8K_PORT_HOL_CTRL0_EG_PRI5(0x8) |\n\t\t\tQCA8K_PORT_HOL_CTRL0_EG_PORT(0x1e);\n\t\tbreak;\n\tdefault:\n\t\tmask = QCA8K_PORT_HOL_CTRL0_EG_PRI0(0x3) |\n\t\t\tQCA8K_PORT_HOL_CTRL0_EG_PRI1(0x4) |\n\t\t\tQCA8K_PORT_HOL_CTRL0_EG_PRI2(0x6) |\n\t\t\tQCA8K_PORT_HOL_CTRL0_EG_PRI3(0x8) |\n\t\t\tQCA8K_PORT_HOL_CTRL0_EG_PORT(0x19);\n\t}\n\tregmap_write(priv->regmap, QCA8K_REG_PORT_HOL_CTRL0(port), mask);\n\n\tmask = QCA8K_PORT_HOL_CTRL1_ING(0x6) |\n\t       QCA8K_PORT_HOL_CTRL1_EG_PRI_BUF_EN |\n\t       QCA8K_PORT_HOL_CTRL1_EG_PORT_BUF_EN |\n\t       QCA8K_PORT_HOL_CTRL1_WRED_EN;\n\tregmap_update_bits(priv->regmap, QCA8K_REG_PORT_HOL_CTRL1(port),\n\t\t\t   QCA8K_PORT_HOL_CTRL1_ING_BUF_MASK |\n\t\t\t   QCA8K_PORT_HOL_CTRL1_EG_PRI_BUF_EN |\n\t\t\t   QCA8K_PORT_HOL_CTRL1_EG_PORT_BUF_EN |\n\t\t\t   QCA8K_PORT_HOL_CTRL1_WRED_EN,\n\t\t\t   mask);\n}\n\nstatic int\nqca8k_setup(struct dsa_switch *ds)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\tstruct dsa_port *dp;\n\tint cpu_port, ret;\n\tu32 mask;\n\n\tcpu_port = qca8k_find_cpu_port(ds);\n\tif (cpu_port < 0) {\n\t\tdev_err(priv->dev, \"No cpu port configured in both cpu port0 and port6\");\n\t\treturn cpu_port;\n\t}\n\n\t \n\tret = qca8k_parse_port_config(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qca8k_setup_mdio_bus(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qca8k_setup_of_pws_reg(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qca8k_setup_mac_pwr_sel(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qca8k_setup_led_ctrl(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tqca8k_setup_pcs(priv, &priv->pcs_port_0, 0);\n\tqca8k_setup_pcs(priv, &priv->pcs_port_6, 6);\n\n\t \n\tret = regmap_clear_bits(priv->regmap, QCA8K_REG_PORT0_PAD_CTRL,\n\t\t\t\tQCA8K_PORT0_PAD_MAC06_EXCHANGE_EN);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"failed disabling MAC06 exchange\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = regmap_set_bits(priv->regmap, QCA8K_REG_GLOBAL_FW_CTRL0,\n\t\t\t      QCA8K_GLOBAL_FW_CTRL0_CPU_PORT_EN);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"failed enabling CPU port\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = qca8k_mib_init(priv);\n\tif (ret)\n\t\tdev_warn(priv->dev, \"mib init failed\");\n\n\t \n\tdsa_switch_for_each_port(dp, ds) {\n\t\t \n\t\tret = qca8k_rmw(priv, QCA8K_PORT_LOOKUP_CTRL(dp->index),\n\t\t\t\tQCA8K_PORT_LOOKUP_MEMBER, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tdsa_switch_for_each_user_port(dp, ds)\n\t\tqca8k_port_set_status(priv, dp->index, 0);\n\n\t \n\tdsa_switch_for_each_cpu_port(dp, ds) {\n\t\tret = qca8k_write(priv, QCA8K_REG_PORT_HDR_CTRL(dp->index),\n\t\t\t\t  FIELD_PREP(QCA8K_PORT_HDR_CTRL_TX_MASK, QCA8K_PORT_HDR_CTRL_ALL) |\n\t\t\t\t  FIELD_PREP(QCA8K_PORT_HDR_CTRL_RX_MASK, QCA8K_PORT_HDR_CTRL_ALL));\n\t\tif (ret) {\n\t\t\tdev_err(priv->dev, \"failed enabling QCA header mode on port %d\", dp->index);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tret = qca8k_write(priv, QCA8K_REG_GLOBAL_FW_CTRL1,\n\t\t\t  FIELD_PREP(QCA8K_GLOBAL_FW_CTRL1_IGMP_DP_MASK, BIT(cpu_port)) |\n\t\t\t  FIELD_PREP(QCA8K_GLOBAL_FW_CTRL1_BC_DP_MASK, BIT(cpu_port)) |\n\t\t\t  FIELD_PREP(QCA8K_GLOBAL_FW_CTRL1_MC_DP_MASK, BIT(cpu_port)) |\n\t\t\t  FIELD_PREP(QCA8K_GLOBAL_FW_CTRL1_UC_DP_MASK, BIT(cpu_port)));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = qca8k_rmw(priv, QCA8K_PORT_LOOKUP_CTRL(cpu_port),\n\t\t\tQCA8K_PORT_LOOKUP_MEMBER, dsa_user_ports(ds));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdsa_switch_for_each_user_port(dp, ds) {\n\t\tu8 port = dp->index;\n\n\t\tret = qca8k_rmw(priv, QCA8K_PORT_LOOKUP_CTRL(port),\n\t\t\t\tQCA8K_PORT_LOOKUP_MEMBER,\n\t\t\t\tBIT(cpu_port));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regmap_clear_bits(priv->regmap, QCA8K_PORT_LOOKUP_CTRL(port),\n\t\t\t\t\tQCA8K_PORT_LOOKUP_LEARN);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = qca8k_rmw(priv, QCA8K_EGRESS_VLAN(port),\n\t\t\t\tQCA8K_EGREES_VLAN_PORT_MASK(port),\n\t\t\t\tQCA8K_EGREES_VLAN_PORT(port, QCA8K_PORT_VID_DEF));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = qca8k_write(priv, QCA8K_REG_PORT_VLAN_CTRL0(port),\n\t\t\t\t  QCA8K_PORT_VLAN_CVID(QCA8K_PORT_VID_DEF) |\n\t\t\t\t  QCA8K_PORT_VLAN_SVID(QCA8K_PORT_VID_DEF));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (priv->switch_id == QCA8K_ID_QCA8337)\n\t\tdsa_switch_for_each_available_port(dp, ds)\n\t\t\tqca8k_setup_hol_fixup(priv, dp->index);\n\n\t \n\tif (priv->switch_id == QCA8K_ID_QCA8327) {\n\t\tmask = QCA8K_GLOBAL_FC_GOL_XON_THRES(288) |\n\t\t       QCA8K_GLOBAL_FC_GOL_XOFF_THRES(496);\n\t\tqca8k_rmw(priv, QCA8K_REG_GLOBAL_FC_THRESH,\n\t\t\t  QCA8K_GLOBAL_FC_GOL_XON_THRES_MASK |\n\t\t\t  QCA8K_GLOBAL_FC_GOL_XOFF_THRES_MASK,\n\t\t\t  mask);\n\t}\n\n\t \n\tret = qca8k_write(priv, QCA8K_MAX_FRAME_SIZE, ETH_FRAME_LEN + ETH_FCS_LEN);\n\tif (ret)\n\t\tdev_warn(priv->dev, \"failed setting MTU settings\");\n\n\t \n\tqca8k_fdb_flush(priv);\n\n\t \n\tds->ageing_time_min = 7000;\n\tds->ageing_time_max = 458745000;\n\n\t \n\tds->num_lag_ids = QCA8K_NUM_LAGS;\n\n\treturn 0;\n}\n\nstatic const struct dsa_switch_ops qca8k_switch_ops = {\n\t.get_tag_protocol\t= qca8k_get_tag_protocol,\n\t.setup\t\t\t= qca8k_setup,\n\t.get_strings\t\t= qca8k_get_strings,\n\t.get_ethtool_stats\t= qca8k_get_ethtool_stats,\n\t.get_sset_count\t\t= qca8k_get_sset_count,\n\t.set_ageing_time\t= qca8k_set_ageing_time,\n\t.get_mac_eee\t\t= qca8k_get_mac_eee,\n\t.set_mac_eee\t\t= qca8k_set_mac_eee,\n\t.port_enable\t\t= qca8k_port_enable,\n\t.port_disable\t\t= qca8k_port_disable,\n\t.port_change_mtu\t= qca8k_port_change_mtu,\n\t.port_max_mtu\t\t= qca8k_port_max_mtu,\n\t.port_stp_state_set\t= qca8k_port_stp_state_set,\n\t.port_pre_bridge_flags\t= qca8k_port_pre_bridge_flags,\n\t.port_bridge_flags\t= qca8k_port_bridge_flags,\n\t.port_bridge_join\t= qca8k_port_bridge_join,\n\t.port_bridge_leave\t= qca8k_port_bridge_leave,\n\t.port_fast_age\t\t= qca8k_port_fast_age,\n\t.port_fdb_add\t\t= qca8k_port_fdb_add,\n\t.port_fdb_del\t\t= qca8k_port_fdb_del,\n\t.port_fdb_dump\t\t= qca8k_port_fdb_dump,\n\t.port_mdb_add\t\t= qca8k_port_mdb_add,\n\t.port_mdb_del\t\t= qca8k_port_mdb_del,\n\t.port_mirror_add\t= qca8k_port_mirror_add,\n\t.port_mirror_del\t= qca8k_port_mirror_del,\n\t.port_vlan_filtering\t= qca8k_port_vlan_filtering,\n\t.port_vlan_add\t\t= qca8k_port_vlan_add,\n\t.port_vlan_del\t\t= qca8k_port_vlan_del,\n\t.phylink_get_caps\t= qca8k_phylink_get_caps,\n\t.phylink_mac_select_pcs\t= qca8k_phylink_mac_select_pcs,\n\t.phylink_mac_config\t= qca8k_phylink_mac_config,\n\t.phylink_mac_link_down\t= qca8k_phylink_mac_link_down,\n\t.phylink_mac_link_up\t= qca8k_phylink_mac_link_up,\n\t.get_phy_flags\t\t= qca8k_get_phy_flags,\n\t.port_lag_join\t\t= qca8k_port_lag_join,\n\t.port_lag_leave\t\t= qca8k_port_lag_leave,\n\t.master_state_change\t= qca8k_master_change,\n\t.connect_tag_protocol\t= qca8k_connect_tag_protocol,\n};\n\nstatic int\nqca8k_sw_probe(struct mdio_device *mdiodev)\n{\n\tstruct qca8k_priv *priv;\n\tint ret;\n\n\t \n\tpriv = devm_kzalloc(&mdiodev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->bus = mdiodev->bus;\n\tpriv->dev = &mdiodev->dev;\n\tpriv->info = of_device_get_match_data(priv->dev);\n\n\tpriv->reset_gpio = devm_gpiod_get_optional(priv->dev, \"reset\",\n\t\t\t\t\t\t   GPIOD_ASIS);\n\tif (IS_ERR(priv->reset_gpio))\n\t\treturn PTR_ERR(priv->reset_gpio);\n\n\tif (priv->reset_gpio) {\n\t\tgpiod_set_value_cansleep(priv->reset_gpio, 1);\n\t\t \n\t\tmsleep(20);\n\t\tgpiod_set_value_cansleep(priv->reset_gpio, 0);\n\t}\n\n\t \n\tpriv->regmap = devm_regmap_init(&mdiodev->dev, NULL, priv,\n\t\t\t\t\t&qca8k_regmap_config);\n\tif (IS_ERR(priv->regmap)) {\n\t\tdev_err(priv->dev, \"regmap initialization failed\");\n\t\treturn PTR_ERR(priv->regmap);\n\t}\n\n\tpriv->mdio_cache.page = 0xffff;\n\n\t \n\tret = qca8k_read_switch_id(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->ds = devm_kzalloc(&mdiodev->dev, sizeof(*priv->ds), GFP_KERNEL);\n\tif (!priv->ds)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&priv->mgmt_eth_data.mutex);\n\tinit_completion(&priv->mgmt_eth_data.rw_done);\n\n\tmutex_init(&priv->mib_eth_data.mutex);\n\tinit_completion(&priv->mib_eth_data.rw_done);\n\n\tpriv->ds->dev = &mdiodev->dev;\n\tpriv->ds->num_ports = QCA8K_NUM_PORTS;\n\tpriv->ds->priv = priv;\n\tpriv->ds->ops = &qca8k_switch_ops;\n\tmutex_init(&priv->reg_mutex);\n\tdev_set_drvdata(&mdiodev->dev, priv);\n\n\treturn dsa_register_switch(priv->ds);\n}\n\nstatic void\nqca8k_sw_remove(struct mdio_device *mdiodev)\n{\n\tstruct qca8k_priv *priv = dev_get_drvdata(&mdiodev->dev);\n\tint i;\n\n\tif (!priv)\n\t\treturn;\n\n\tfor (i = 0; i < QCA8K_NUM_PORTS; i++)\n\t\tqca8k_port_set_status(priv, i, 0);\n\n\tdsa_unregister_switch(priv->ds);\n}\n\nstatic void qca8k_sw_shutdown(struct mdio_device *mdiodev)\n{\n\tstruct qca8k_priv *priv = dev_get_drvdata(&mdiodev->dev);\n\n\tif (!priv)\n\t\treturn;\n\n\tdsa_switch_shutdown(priv->ds);\n\n\tdev_set_drvdata(&mdiodev->dev, NULL);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic void\nqca8k_set_pm(struct qca8k_priv *priv, int enable)\n{\n\tint port;\n\n\tfor (port = 0; port < QCA8K_NUM_PORTS; port++) {\n\t\t \n\t\tif (!(priv->port_enabled_map & BIT(port)))\n\t\t\tcontinue;\n\n\t\tqca8k_port_set_status(priv, port, enable);\n\t}\n}\n\nstatic int qca8k_suspend(struct device *dev)\n{\n\tstruct qca8k_priv *priv = dev_get_drvdata(dev);\n\n\tqca8k_set_pm(priv, 0);\n\n\treturn dsa_switch_suspend(priv->ds);\n}\n\nstatic int qca8k_resume(struct device *dev)\n{\n\tstruct qca8k_priv *priv = dev_get_drvdata(dev);\n\n\tqca8k_set_pm(priv, 1);\n\n\treturn dsa_switch_resume(priv->ds);\n}\n#endif  \n\nstatic SIMPLE_DEV_PM_OPS(qca8k_pm_ops,\n\t\t\t qca8k_suspend, qca8k_resume);\n\nstatic const struct qca8k_info_ops qca8xxx_ops = {\n\t.autocast_mib = qca8k_get_ethtool_stats_eth,\n};\n\nstatic const struct qca8k_match_data qca8327 = {\n\t.id = QCA8K_ID_QCA8327,\n\t.reduced_package = true,\n\t.mib_count = QCA8K_QCA832X_MIB_COUNT,\n\t.ops = &qca8xxx_ops,\n};\n\nstatic const struct qca8k_match_data qca8328 = {\n\t.id = QCA8K_ID_QCA8327,\n\t.mib_count = QCA8K_QCA832X_MIB_COUNT,\n\t.ops = &qca8xxx_ops,\n};\n\nstatic const struct qca8k_match_data qca833x = {\n\t.id = QCA8K_ID_QCA8337,\n\t.mib_count = QCA8K_QCA833X_MIB_COUNT,\n\t.ops = &qca8xxx_ops,\n};\n\nstatic const struct of_device_id qca8k_of_match[] = {\n\t{ .compatible = \"qca,qca8327\", .data = &qca8327 },\n\t{ .compatible = \"qca,qca8328\", .data = &qca8328 },\n\t{ .compatible = \"qca,qca8334\", .data = &qca833x },\n\t{ .compatible = \"qca,qca8337\", .data = &qca833x },\n\t{   },\n};\n\nstatic struct mdio_driver qca8kmdio_driver = {\n\t.probe  = qca8k_sw_probe,\n\t.remove = qca8k_sw_remove,\n\t.shutdown = qca8k_sw_shutdown,\n\t.mdiodrv.driver = {\n\t\t.name = \"qca8k\",\n\t\t.of_match_table = qca8k_of_match,\n\t\t.pm = &qca8k_pm_ops,\n\t},\n};\n\nmdio_module_driver(qca8kmdio_driver);\n\nMODULE_AUTHOR(\"Mathieu Olivari, John Crispin <john@phrozen.org>\");\nMODULE_DESCRIPTION(\"Driver for QCA8K ethernet switch family\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:qca8k\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}