{
  "module_name": "qca8k-common.c",
  "hash_id": "100a98c3be48edcc4a396a17ad4508e5a70d70e4f8fe9474321e925739ea4d77",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/qca/qca8k-common.c",
  "human_readable_source": "\n \n\n#include <linux/netdevice.h>\n#include <net/dsa.h>\n#include <linux/if_bridge.h>\n\n#include \"qca8k.h\"\n\n#define MIB_DESC(_s, _o, _n)\t\\\n\t{\t\t\t\\\n\t\t.size = (_s),\t\\\n\t\t.offset = (_o),\t\\\n\t\t.name = (_n),\t\\\n\t}\n\nconst struct qca8k_mib_desc ar8327_mib[] = {\n\tMIB_DESC(1, 0x00, \"RxBroad\"),\n\tMIB_DESC(1, 0x04, \"RxPause\"),\n\tMIB_DESC(1, 0x08, \"RxMulti\"),\n\tMIB_DESC(1, 0x0c, \"RxFcsErr\"),\n\tMIB_DESC(1, 0x10, \"RxAlignErr\"),\n\tMIB_DESC(1, 0x14, \"RxRunt\"),\n\tMIB_DESC(1, 0x18, \"RxFragment\"),\n\tMIB_DESC(1, 0x1c, \"Rx64Byte\"),\n\tMIB_DESC(1, 0x20, \"Rx128Byte\"),\n\tMIB_DESC(1, 0x24, \"Rx256Byte\"),\n\tMIB_DESC(1, 0x28, \"Rx512Byte\"),\n\tMIB_DESC(1, 0x2c, \"Rx1024Byte\"),\n\tMIB_DESC(1, 0x30, \"Rx1518Byte\"),\n\tMIB_DESC(1, 0x34, \"RxMaxByte\"),\n\tMIB_DESC(1, 0x38, \"RxTooLong\"),\n\tMIB_DESC(2, 0x3c, \"RxGoodByte\"),\n\tMIB_DESC(2, 0x44, \"RxBadByte\"),\n\tMIB_DESC(1, 0x4c, \"RxOverFlow\"),\n\tMIB_DESC(1, 0x50, \"Filtered\"),\n\tMIB_DESC(1, 0x54, \"TxBroad\"),\n\tMIB_DESC(1, 0x58, \"TxPause\"),\n\tMIB_DESC(1, 0x5c, \"TxMulti\"),\n\tMIB_DESC(1, 0x60, \"TxUnderRun\"),\n\tMIB_DESC(1, 0x64, \"Tx64Byte\"),\n\tMIB_DESC(1, 0x68, \"Tx128Byte\"),\n\tMIB_DESC(1, 0x6c, \"Tx256Byte\"),\n\tMIB_DESC(1, 0x70, \"Tx512Byte\"),\n\tMIB_DESC(1, 0x74, \"Tx1024Byte\"),\n\tMIB_DESC(1, 0x78, \"Tx1518Byte\"),\n\tMIB_DESC(1, 0x7c, \"TxMaxByte\"),\n\tMIB_DESC(1, 0x80, \"TxOverSize\"),\n\tMIB_DESC(2, 0x84, \"TxByte\"),\n\tMIB_DESC(1, 0x8c, \"TxCollision\"),\n\tMIB_DESC(1, 0x90, \"TxAbortCol\"),\n\tMIB_DESC(1, 0x94, \"TxMultiCol\"),\n\tMIB_DESC(1, 0x98, \"TxSingleCol\"),\n\tMIB_DESC(1, 0x9c, \"TxExcDefer\"),\n\tMIB_DESC(1, 0xa0, \"TxDefer\"),\n\tMIB_DESC(1, 0xa4, \"TxLateCol\"),\n\tMIB_DESC(1, 0xa8, \"RXUnicast\"),\n\tMIB_DESC(1, 0xac, \"TXUnicast\"),\n};\n\nint qca8k_read(struct qca8k_priv *priv, u32 reg, u32 *val)\n{\n\treturn regmap_read(priv->regmap, reg, val);\n}\n\nint qca8k_write(struct qca8k_priv *priv, u32 reg, u32 val)\n{\n\treturn regmap_write(priv->regmap, reg, val);\n}\n\nint qca8k_rmw(struct qca8k_priv *priv, u32 reg, u32 mask, u32 write_val)\n{\n\treturn regmap_update_bits(priv->regmap, reg, mask, write_val);\n}\n\nstatic const struct regmap_range qca8k_readable_ranges[] = {\n\tregmap_reg_range(0x0000, 0x00e4),  \n\tregmap_reg_range(0x0100, 0x0168),  \n\tregmap_reg_range(0x0200, 0x0270),  \n\tregmap_reg_range(0x0400, 0x0454),  \n\tregmap_reg_range(0x0600, 0x0718),  \n\tregmap_reg_range(0x0800, 0x0b70),  \n\tregmap_reg_range(0x0c00, 0x0c80),  \n\tregmap_reg_range(0x0e00, 0x0e98),  \n\tregmap_reg_range(0x1000, 0x10ac),  \n\tregmap_reg_range(0x1100, 0x11ac),  \n\tregmap_reg_range(0x1200, 0x12ac),  \n\tregmap_reg_range(0x1300, 0x13ac),  \n\tregmap_reg_range(0x1400, 0x14ac),  \n\tregmap_reg_range(0x1500, 0x15ac),  \n\tregmap_reg_range(0x1600, 0x16ac),  \n};\n\nconst struct regmap_access_table qca8k_readable_table = {\n\t.yes_ranges = qca8k_readable_ranges,\n\t.n_yes_ranges = ARRAY_SIZE(qca8k_readable_ranges),\n};\n\nstatic int qca8k_busy_wait(struct qca8k_priv *priv, u32 reg, u32 mask)\n{\n\tu32 val;\n\n\treturn regmap_read_poll_timeout(priv->regmap, reg, val, !(val & mask), 0,\n\t\t\t\t       QCA8K_BUSY_WAIT_TIMEOUT * USEC_PER_MSEC);\n}\n\nstatic int qca8k_fdb_read(struct qca8k_priv *priv, struct qca8k_fdb *fdb)\n{\n\tu32 reg[QCA8K_ATU_TABLE_SIZE];\n\tint ret;\n\n\t \n\tret = regmap_bulk_read(priv->regmap, QCA8K_REG_ATU_DATA0, reg,\n\t\t\t       QCA8K_ATU_TABLE_SIZE);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfdb->vid = FIELD_GET(QCA8K_ATU_VID_MASK, reg[2]);\n\t \n\tfdb->aging = FIELD_GET(QCA8K_ATU_STATUS_MASK, reg[2]);\n\t \n\tfdb->port_mask = FIELD_GET(QCA8K_ATU_PORT_MASK, reg[1]);\n\t \n\tfdb->mac[0] = FIELD_GET(QCA8K_ATU_ADDR0_MASK, reg[1]);\n\tfdb->mac[1] = FIELD_GET(QCA8K_ATU_ADDR1_MASK, reg[1]);\n\tfdb->mac[2] = FIELD_GET(QCA8K_ATU_ADDR2_MASK, reg[0]);\n\tfdb->mac[3] = FIELD_GET(QCA8K_ATU_ADDR3_MASK, reg[0]);\n\tfdb->mac[4] = FIELD_GET(QCA8K_ATU_ADDR4_MASK, reg[0]);\n\tfdb->mac[5] = FIELD_GET(QCA8K_ATU_ADDR5_MASK, reg[0]);\n\n\treturn 0;\n}\n\nstatic void qca8k_fdb_write(struct qca8k_priv *priv, u16 vid, u8 port_mask,\n\t\t\t    const u8 *mac, u8 aging)\n{\n\tu32 reg[QCA8K_ATU_TABLE_SIZE] = { 0 };\n\n\t \n\treg[2] = FIELD_PREP(QCA8K_ATU_VID_MASK, vid);\n\t \n\treg[2] |= FIELD_PREP(QCA8K_ATU_STATUS_MASK, aging);\n\t \n\treg[1] = FIELD_PREP(QCA8K_ATU_PORT_MASK, port_mask);\n\t \n\treg[1] |= FIELD_PREP(QCA8K_ATU_ADDR0_MASK, mac[0]);\n\treg[1] |= FIELD_PREP(QCA8K_ATU_ADDR1_MASK, mac[1]);\n\treg[0] |= FIELD_PREP(QCA8K_ATU_ADDR2_MASK, mac[2]);\n\treg[0] |= FIELD_PREP(QCA8K_ATU_ADDR3_MASK, mac[3]);\n\treg[0] |= FIELD_PREP(QCA8K_ATU_ADDR4_MASK, mac[4]);\n\treg[0] |= FIELD_PREP(QCA8K_ATU_ADDR5_MASK, mac[5]);\n\n\t \n\tregmap_bulk_write(priv->regmap, QCA8K_REG_ATU_DATA0, reg,\n\t\t\t  QCA8K_ATU_TABLE_SIZE);\n}\n\nstatic int qca8k_fdb_access(struct qca8k_priv *priv, enum qca8k_fdb_cmd cmd,\n\t\t\t    int port)\n{\n\tu32 reg;\n\tint ret;\n\n\t \n\treg = QCA8K_ATU_FUNC_BUSY;\n\treg |= cmd;\n\tif (port >= 0) {\n\t\treg |= QCA8K_ATU_FUNC_PORT_EN;\n\t\treg |= FIELD_PREP(QCA8K_ATU_FUNC_PORT_MASK, port);\n\t}\n\n\t \n\tret = qca8k_write(priv, QCA8K_REG_ATU_FUNC, reg);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = qca8k_busy_wait(priv, QCA8K_REG_ATU_FUNC, QCA8K_ATU_FUNC_BUSY);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (cmd == QCA8K_FDB_LOAD) {\n\t\tret = qca8k_read(priv, QCA8K_REG_ATU_FUNC, &reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (reg & QCA8K_ATU_FUNC_FULL)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int qca8k_fdb_next(struct qca8k_priv *priv, struct qca8k_fdb *fdb,\n\t\t\t  int port)\n{\n\tint ret;\n\n\tqca8k_fdb_write(priv, fdb->vid, fdb->port_mask, fdb->mac, fdb->aging);\n\tret = qca8k_fdb_access(priv, QCA8K_FDB_NEXT, port);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn qca8k_fdb_read(priv, fdb);\n}\n\nstatic int qca8k_fdb_add(struct qca8k_priv *priv, const u8 *mac,\n\t\t\t u16 port_mask, u16 vid, u8 aging)\n{\n\tint ret;\n\n\tmutex_lock(&priv->reg_mutex);\n\tqca8k_fdb_write(priv, vid, port_mask, mac, aging);\n\tret = qca8k_fdb_access(priv, QCA8K_FDB_LOAD, -1);\n\tmutex_unlock(&priv->reg_mutex);\n\n\treturn ret;\n}\n\nstatic int qca8k_fdb_del(struct qca8k_priv *priv, const u8 *mac,\n\t\t\t u16 port_mask, u16 vid)\n{\n\tint ret;\n\n\tmutex_lock(&priv->reg_mutex);\n\tqca8k_fdb_write(priv, vid, port_mask, mac, 0);\n\tret = qca8k_fdb_access(priv, QCA8K_FDB_PURGE, -1);\n\tmutex_unlock(&priv->reg_mutex);\n\n\treturn ret;\n}\n\nvoid qca8k_fdb_flush(struct qca8k_priv *priv)\n{\n\tmutex_lock(&priv->reg_mutex);\n\tqca8k_fdb_access(priv, QCA8K_FDB_FLUSH, -1);\n\tmutex_unlock(&priv->reg_mutex);\n}\n\nstatic int qca8k_fdb_search_and_insert(struct qca8k_priv *priv, u8 port_mask,\n\t\t\t\t       const u8 *mac, u16 vid, u8 aging)\n{\n\tstruct qca8k_fdb fdb = { 0 };\n\tint ret;\n\n\tmutex_lock(&priv->reg_mutex);\n\n\tqca8k_fdb_write(priv, vid, 0, mac, 0);\n\tret = qca8k_fdb_access(priv, QCA8K_FDB_SEARCH, -1);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tret = qca8k_fdb_read(priv, &fdb);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\t \n\tif (fdb.aging) {\n\t\tret = qca8k_fdb_access(priv, QCA8K_FDB_PURGE, -1);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t} else {\n\t\tfdb.aging = aging;\n\t}\n\n\t \n\tfdb.port_mask |= port_mask;\n\n\tqca8k_fdb_write(priv, vid, fdb.port_mask, mac, fdb.aging);\n\tret = qca8k_fdb_access(priv, QCA8K_FDB_LOAD, -1);\n\nexit:\n\tmutex_unlock(&priv->reg_mutex);\n\treturn ret;\n}\n\nstatic int qca8k_fdb_search_and_del(struct qca8k_priv *priv, u8 port_mask,\n\t\t\t\t    const u8 *mac, u16 vid)\n{\n\tstruct qca8k_fdb fdb = { 0 };\n\tint ret;\n\n\tmutex_lock(&priv->reg_mutex);\n\n\tqca8k_fdb_write(priv, vid, 0, mac, 0);\n\tret = qca8k_fdb_access(priv, QCA8K_FDB_SEARCH, -1);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tret = qca8k_fdb_read(priv, &fdb);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\t \n\tif (!fdb.aging) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tret = qca8k_fdb_access(priv, QCA8K_FDB_PURGE, -1);\n\tif (ret)\n\t\tgoto exit;\n\n\t \n\tif (fdb.port_mask == port_mask)\n\t\tgoto exit;\n\n\t \n\tfdb.port_mask &= ~port_mask;\n\n\tqca8k_fdb_write(priv, vid, fdb.port_mask, mac, fdb.aging);\n\tret = qca8k_fdb_access(priv, QCA8K_FDB_LOAD, -1);\n\nexit:\n\tmutex_unlock(&priv->reg_mutex);\n\treturn ret;\n}\n\nstatic int qca8k_vlan_access(struct qca8k_priv *priv,\n\t\t\t     enum qca8k_vlan_cmd cmd, u16 vid)\n{\n\tu32 reg;\n\tint ret;\n\n\t \n\treg = QCA8K_VTU_FUNC1_BUSY;\n\treg |= cmd;\n\treg |= FIELD_PREP(QCA8K_VTU_FUNC1_VID_MASK, vid);\n\n\t \n\tret = qca8k_write(priv, QCA8K_REG_VTU_FUNC1, reg);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = qca8k_busy_wait(priv, QCA8K_REG_VTU_FUNC1, QCA8K_VTU_FUNC1_BUSY);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (cmd == QCA8K_VLAN_LOAD) {\n\t\tret = qca8k_read(priv, QCA8K_REG_VTU_FUNC1, &reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (reg & QCA8K_VTU_FUNC1_FULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int qca8k_vlan_add(struct qca8k_priv *priv, u8 port, u16 vid,\n\t\t\t  bool untagged)\n{\n\tu32 reg;\n\tint ret;\n\n\t \n\tif (vid == 0)\n\t\treturn 0;\n\n\tmutex_lock(&priv->reg_mutex);\n\tret = qca8k_vlan_access(priv, QCA8K_VLAN_READ, vid);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = qca8k_read(priv, QCA8K_REG_VTU_FUNC0, &reg);\n\tif (ret < 0)\n\t\tgoto out;\n\treg |= QCA8K_VTU_FUNC0_VALID | QCA8K_VTU_FUNC0_IVL_EN;\n\treg &= ~QCA8K_VTU_FUNC0_EG_MODE_PORT_MASK(port);\n\tif (untagged)\n\t\treg |= QCA8K_VTU_FUNC0_EG_MODE_PORT_UNTAG(port);\n\telse\n\t\treg |= QCA8K_VTU_FUNC0_EG_MODE_PORT_TAG(port);\n\n\tret = qca8k_write(priv, QCA8K_REG_VTU_FUNC0, reg);\n\tif (ret)\n\t\tgoto out;\n\tret = qca8k_vlan_access(priv, QCA8K_VLAN_LOAD, vid);\n\nout:\n\tmutex_unlock(&priv->reg_mutex);\n\n\treturn ret;\n}\n\nstatic int qca8k_vlan_del(struct qca8k_priv *priv, u8 port, u16 vid)\n{\n\tu32 reg, mask;\n\tint ret, i;\n\tbool del;\n\n\tmutex_lock(&priv->reg_mutex);\n\tret = qca8k_vlan_access(priv, QCA8K_VLAN_READ, vid);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = qca8k_read(priv, QCA8K_REG_VTU_FUNC0, &reg);\n\tif (ret < 0)\n\t\tgoto out;\n\treg &= ~QCA8K_VTU_FUNC0_EG_MODE_PORT_MASK(port);\n\treg |= QCA8K_VTU_FUNC0_EG_MODE_PORT_NOT(port);\n\n\t \n\tdel = true;\n\tfor (i = 0; i < QCA8K_NUM_PORTS; i++) {\n\t\tmask = QCA8K_VTU_FUNC0_EG_MODE_PORT_NOT(i);\n\n\t\tif ((reg & mask) != mask) {\n\t\t\tdel = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (del) {\n\t\tret = qca8k_vlan_access(priv, QCA8K_VLAN_PURGE, vid);\n\t} else {\n\t\tret = qca8k_write(priv, QCA8K_REG_VTU_FUNC0, reg);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = qca8k_vlan_access(priv, QCA8K_VLAN_LOAD, vid);\n\t}\n\nout:\n\tmutex_unlock(&priv->reg_mutex);\n\n\treturn ret;\n}\n\nint qca8k_mib_init(struct qca8k_priv *priv)\n{\n\tint ret;\n\n\tmutex_lock(&priv->reg_mutex);\n\tret = regmap_update_bits(priv->regmap, QCA8K_REG_MIB,\n\t\t\t\t QCA8K_MIB_FUNC | QCA8K_MIB_BUSY,\n\t\t\t\t FIELD_PREP(QCA8K_MIB_FUNC, QCA8K_MIB_FLUSH) |\n\t\t\t\t QCA8K_MIB_BUSY);\n\tif (ret)\n\t\tgoto exit;\n\n\tret = qca8k_busy_wait(priv, QCA8K_REG_MIB, QCA8K_MIB_BUSY);\n\tif (ret)\n\t\tgoto exit;\n\n\tret = regmap_set_bits(priv->regmap, QCA8K_REG_MIB, QCA8K_MIB_CPU_KEEP);\n\tif (ret)\n\t\tgoto exit;\n\n\tret = qca8k_write(priv, QCA8K_REG_MODULE_EN, QCA8K_MODULE_EN_MIB);\n\nexit:\n\tmutex_unlock(&priv->reg_mutex);\n\treturn ret;\n}\n\nvoid qca8k_port_set_status(struct qca8k_priv *priv, int port, int enable)\n{\n\tu32 mask = QCA8K_PORT_STATUS_TXMAC | QCA8K_PORT_STATUS_RXMAC;\n\n\t \n\tif (port > 0 && port < 6)\n\t\tmask |= QCA8K_PORT_STATUS_LINK_AUTO;\n\n\tif (enable)\n\t\tregmap_set_bits(priv->regmap, QCA8K_REG_PORT_STATUS(port), mask);\n\telse\n\t\tregmap_clear_bits(priv->regmap, QCA8K_REG_PORT_STATUS(port), mask);\n}\n\nvoid qca8k_get_strings(struct dsa_switch *ds, int port, u32 stringset,\n\t\t       uint8_t *data)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\tint i;\n\n\tif (stringset != ETH_SS_STATS)\n\t\treturn;\n\n\tfor (i = 0; i < priv->info->mib_count; i++)\n\t\tstrncpy(data + i * ETH_GSTRING_LEN, ar8327_mib[i].name,\n\t\t\tETH_GSTRING_LEN);\n}\n\nvoid qca8k_get_ethtool_stats(struct dsa_switch *ds, int port,\n\t\t\t     uint64_t *data)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\tconst struct qca8k_mib_desc *mib;\n\tu32 reg, i, val;\n\tu32 hi = 0;\n\tint ret;\n\n\tif (priv->mgmt_master && priv->info->ops->autocast_mib &&\n\t    priv->info->ops->autocast_mib(ds, port, data) > 0)\n\t\treturn;\n\n\tfor (i = 0; i < priv->info->mib_count; i++) {\n\t\tmib = &ar8327_mib[i];\n\t\treg = QCA8K_PORT_MIB_COUNTER(port) + mib->offset;\n\n\t\tret = qca8k_read(priv, reg, &val);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tif (mib->size == 2) {\n\t\t\tret = qca8k_read(priv, reg + 4, &hi);\n\t\t\tif (ret < 0)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tdata[i] = val;\n\t\tif (mib->size == 2)\n\t\t\tdata[i] |= (u64)hi << 32;\n\t}\n}\n\nint qca8k_get_sset_count(struct dsa_switch *ds, int port, int sset)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\n\tif (sset != ETH_SS_STATS)\n\t\treturn 0;\n\n\treturn priv->info->mib_count;\n}\n\nint qca8k_set_mac_eee(struct dsa_switch *ds, int port,\n\t\t      struct ethtool_eee *eee)\n{\n\tu32 lpi_en = QCA8K_REG_EEE_CTRL_LPI_EN(port);\n\tstruct qca8k_priv *priv = ds->priv;\n\tu32 reg;\n\tint ret;\n\n\tmutex_lock(&priv->reg_mutex);\n\tret = qca8k_read(priv, QCA8K_REG_EEE_CTRL, &reg);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tif (eee->eee_enabled)\n\t\treg |= lpi_en;\n\telse\n\t\treg &= ~lpi_en;\n\tret = qca8k_write(priv, QCA8K_REG_EEE_CTRL, reg);\n\nexit:\n\tmutex_unlock(&priv->reg_mutex);\n\treturn ret;\n}\n\nint qca8k_get_mac_eee(struct dsa_switch *ds, int port,\n\t\t      struct ethtool_eee *e)\n{\n\t \n\treturn 0;\n}\n\nstatic int qca8k_port_configure_learning(struct dsa_switch *ds, int port,\n\t\t\t\t\t bool learning)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\n\tif (learning)\n\t\treturn regmap_set_bits(priv->regmap,\n\t\t\t\t       QCA8K_PORT_LOOKUP_CTRL(port),\n\t\t\t\t       QCA8K_PORT_LOOKUP_LEARN);\n\telse\n\t\treturn regmap_clear_bits(priv->regmap,\n\t\t\t\t\t QCA8K_PORT_LOOKUP_CTRL(port),\n\t\t\t\t\t QCA8K_PORT_LOOKUP_LEARN);\n}\n\nvoid qca8k_port_stp_state_set(struct dsa_switch *ds, int port, u8 state)\n{\n\tstruct dsa_port *dp = dsa_to_port(ds, port);\n\tstruct qca8k_priv *priv = ds->priv;\n\tbool learning = false;\n\tu32 stp_state;\n\n\tswitch (state) {\n\tcase BR_STATE_DISABLED:\n\t\tstp_state = QCA8K_PORT_LOOKUP_STATE_DISABLED;\n\t\tbreak;\n\tcase BR_STATE_BLOCKING:\n\t\tstp_state = QCA8K_PORT_LOOKUP_STATE_BLOCKING;\n\t\tbreak;\n\tcase BR_STATE_LISTENING:\n\t\tstp_state = QCA8K_PORT_LOOKUP_STATE_LISTENING;\n\t\tbreak;\n\tcase BR_STATE_LEARNING:\n\t\tstp_state = QCA8K_PORT_LOOKUP_STATE_LEARNING;\n\t\tlearning = dp->learning;\n\t\tbreak;\n\tcase BR_STATE_FORWARDING:\n\t\tlearning = dp->learning;\n\t\tfallthrough;\n\tdefault:\n\t\tstp_state = QCA8K_PORT_LOOKUP_STATE_FORWARD;\n\t\tbreak;\n\t}\n\n\tqca8k_rmw(priv, QCA8K_PORT_LOOKUP_CTRL(port),\n\t\t  QCA8K_PORT_LOOKUP_STATE_MASK, stp_state);\n\n\tqca8k_port_configure_learning(ds, port, learning);\n}\n\nint qca8k_port_pre_bridge_flags(struct dsa_switch *ds, int port,\n\t\t\t\tstruct switchdev_brport_flags flags,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tif (flags.mask & ~BR_LEARNING)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint qca8k_port_bridge_flags(struct dsa_switch *ds, int port,\n\t\t\t    struct switchdev_brport_flags flags,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tint ret;\n\n\tif (flags.mask & BR_LEARNING) {\n\t\tret = qca8k_port_configure_learning(ds, port,\n\t\t\t\t\t\t    flags.val & BR_LEARNING);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint qca8k_port_bridge_join(struct dsa_switch *ds, int port,\n\t\t\t   struct dsa_bridge bridge,\n\t\t\t   bool *tx_fwd_offload,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\tint port_mask, cpu_port;\n\tint i, ret;\n\n\tcpu_port = dsa_to_port(ds, port)->cpu_dp->index;\n\tport_mask = BIT(cpu_port);\n\n\tfor (i = 0; i < QCA8K_NUM_PORTS; i++) {\n\t\tif (dsa_is_cpu_port(ds, i))\n\t\t\tcontinue;\n\t\tif (!dsa_port_offloads_bridge(dsa_to_port(ds, i), &bridge))\n\t\t\tcontinue;\n\t\t \n\t\tret = regmap_set_bits(priv->regmap,\n\t\t\t\t      QCA8K_PORT_LOOKUP_CTRL(i),\n\t\t\t\t      BIT(port));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (i != port)\n\t\t\tport_mask |= BIT(i);\n\t}\n\n\t \n\tret = qca8k_rmw(priv, QCA8K_PORT_LOOKUP_CTRL(port),\n\t\t\tQCA8K_PORT_LOOKUP_MEMBER, port_mask);\n\n\treturn ret;\n}\n\nvoid qca8k_port_bridge_leave(struct dsa_switch *ds, int port,\n\t\t\t     struct dsa_bridge bridge)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\tint cpu_port, i;\n\n\tcpu_port = dsa_to_port(ds, port)->cpu_dp->index;\n\n\tfor (i = 0; i < QCA8K_NUM_PORTS; i++) {\n\t\tif (dsa_is_cpu_port(ds, i))\n\t\t\tcontinue;\n\t\tif (!dsa_port_offloads_bridge(dsa_to_port(ds, i), &bridge))\n\t\t\tcontinue;\n\t\t \n\t\tregmap_clear_bits(priv->regmap,\n\t\t\t\t  QCA8K_PORT_LOOKUP_CTRL(i),\n\t\t\t\t  BIT(port));\n\t}\n\n\t \n\tqca8k_rmw(priv, QCA8K_PORT_LOOKUP_CTRL(port),\n\t\t  QCA8K_PORT_LOOKUP_MEMBER, BIT(cpu_port));\n}\n\nvoid qca8k_port_fast_age(struct dsa_switch *ds, int port)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\n\tmutex_lock(&priv->reg_mutex);\n\tqca8k_fdb_access(priv, QCA8K_FDB_FLUSH_PORT, port);\n\tmutex_unlock(&priv->reg_mutex);\n}\n\nint qca8k_set_ageing_time(struct dsa_switch *ds, unsigned int msecs)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\tunsigned int secs = msecs / 1000;\n\tu32 val;\n\n\t \n\tval = secs / 7;\n\n\t \n\tif (!val)\n\t\tval = 1;\n\n\treturn regmap_update_bits(priv->regmap, QCA8K_REG_ATU_CTRL,\n\t\t\t\t  QCA8K_ATU_AGE_TIME_MASK,\n\t\t\t\t  QCA8K_ATU_AGE_TIME(val));\n}\n\nint qca8k_port_enable(struct dsa_switch *ds, int port,\n\t\t      struct phy_device *phy)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\n\tqca8k_port_set_status(priv, port, 1);\n\tpriv->port_enabled_map |= BIT(port);\n\n\tif (dsa_is_user_port(ds, port))\n\t\tphy_support_asym_pause(phy);\n\n\treturn 0;\n}\n\nvoid qca8k_port_disable(struct dsa_switch *ds, int port)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\n\tqca8k_port_set_status(priv, port, 0);\n\tpriv->port_enabled_map &= ~BIT(port);\n}\n\nint qca8k_port_change_mtu(struct dsa_switch *ds, int port, int new_mtu)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\tint ret;\n\n\t \n\tif (!dsa_is_cpu_port(ds, port))\n\t\treturn 0;\n\n\t \n\tif (priv->port_enabled_map & BIT(0))\n\t\tqca8k_port_set_status(priv, 0, 0);\n\n\tif (priv->port_enabled_map & BIT(6))\n\t\tqca8k_port_set_status(priv, 6, 0);\n\n\t \n\tret = qca8k_write(priv, QCA8K_MAX_FRAME_SIZE, new_mtu +\n\t\t\t  ETH_HLEN + ETH_FCS_LEN);\n\n\tif (priv->port_enabled_map & BIT(0))\n\t\tqca8k_port_set_status(priv, 0, 1);\n\n\tif (priv->port_enabled_map & BIT(6))\n\t\tqca8k_port_set_status(priv, 6, 1);\n\n\treturn ret;\n}\n\nint qca8k_port_max_mtu(struct dsa_switch *ds, int port)\n{\n\treturn QCA8K_MAX_MTU;\n}\n\nint qca8k_port_fdb_insert(struct qca8k_priv *priv, const u8 *addr,\n\t\t\t  u16 port_mask, u16 vid)\n{\n\t \n\tif (!vid)\n\t\tvid = QCA8K_PORT_VID_DEF;\n\n\treturn qca8k_fdb_add(priv, addr, port_mask, vid,\n\t\t\t     QCA8K_ATU_STATUS_STATIC);\n}\n\nint qca8k_port_fdb_add(struct dsa_switch *ds, int port,\n\t\t       const unsigned char *addr, u16 vid,\n\t\t       struct dsa_db db)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\tu16 port_mask = BIT(port);\n\n\treturn qca8k_port_fdb_insert(priv, addr, port_mask, vid);\n}\n\nint qca8k_port_fdb_del(struct dsa_switch *ds, int port,\n\t\t       const unsigned char *addr, u16 vid,\n\t\t       struct dsa_db db)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\tu16 port_mask = BIT(port);\n\n\tif (!vid)\n\t\tvid = QCA8K_PORT_VID_DEF;\n\n\treturn qca8k_fdb_del(priv, addr, port_mask, vid);\n}\n\nint qca8k_port_fdb_dump(struct dsa_switch *ds, int port,\n\t\t\tdsa_fdb_dump_cb_t *cb, void *data)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\tstruct qca8k_fdb _fdb = { 0 };\n\tint cnt = QCA8K_NUM_FDB_RECORDS;\n\tbool is_static;\n\tint ret = 0;\n\n\tmutex_lock(&priv->reg_mutex);\n\twhile (cnt-- && !qca8k_fdb_next(priv, &_fdb, port)) {\n\t\tif (!_fdb.aging)\n\t\t\tbreak;\n\t\tis_static = (_fdb.aging == QCA8K_ATU_STATUS_STATIC);\n\t\tret = cb(_fdb.mac, _fdb.vid, is_static, data);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&priv->reg_mutex);\n\n\treturn 0;\n}\n\nint qca8k_port_mdb_add(struct dsa_switch *ds, int port,\n\t\t       const struct switchdev_obj_port_mdb *mdb,\n\t\t       struct dsa_db db)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\tconst u8 *addr = mdb->addr;\n\tu16 vid = mdb->vid;\n\n\tif (!vid)\n\t\tvid = QCA8K_PORT_VID_DEF;\n\n\treturn qca8k_fdb_search_and_insert(priv, BIT(port), addr, vid,\n\t\t\t\t\t   QCA8K_ATU_STATUS_STATIC);\n}\n\nint qca8k_port_mdb_del(struct dsa_switch *ds, int port,\n\t\t       const struct switchdev_obj_port_mdb *mdb,\n\t\t       struct dsa_db db)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\tconst u8 *addr = mdb->addr;\n\tu16 vid = mdb->vid;\n\n\tif (!vid)\n\t\tvid = QCA8K_PORT_VID_DEF;\n\n\treturn qca8k_fdb_search_and_del(priv, BIT(port), addr, vid);\n}\n\nint qca8k_port_mirror_add(struct dsa_switch *ds, int port,\n\t\t\t  struct dsa_mall_mirror_tc_entry *mirror,\n\t\t\t  bool ingress, struct netlink_ext_ack *extack)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\tint monitor_port, ret;\n\tu32 reg, val;\n\n\t \n\tif ((ingress ? priv->mirror_rx : priv->mirror_tx) & BIT(port))\n\t\treturn -EEXIST;\n\n\tret = regmap_read(priv->regmap, QCA8K_REG_GLOBAL_FW_CTRL0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmonitor_port = FIELD_GET(QCA8K_GLOBAL_FW_CTRL0_MIRROR_PORT_NUM, val);\n\tif (monitor_port != 0xF && monitor_port != mirror->to_local_port)\n\t\treturn -EEXIST;\n\n\t \n\tval = FIELD_PREP(QCA8K_GLOBAL_FW_CTRL0_MIRROR_PORT_NUM,\n\t\t\t mirror->to_local_port);\n\tret = regmap_update_bits(priv->regmap, QCA8K_REG_GLOBAL_FW_CTRL0,\n\t\t\t\t QCA8K_GLOBAL_FW_CTRL0_MIRROR_PORT_NUM, val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ingress) {\n\t\treg = QCA8K_PORT_LOOKUP_CTRL(port);\n\t\tval = QCA8K_PORT_LOOKUP_ING_MIRROR_EN;\n\t} else {\n\t\treg = QCA8K_REG_PORT_HOL_CTRL1(port);\n\t\tval = QCA8K_PORT_HOL_CTRL1_EG_MIRROR_EN;\n\t}\n\n\tret = regmap_update_bits(priv->regmap, reg, val, val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (ingress)\n\t\tpriv->mirror_rx |= BIT(port);\n\telse\n\t\tpriv->mirror_tx |= BIT(port);\n\n\treturn 0;\n}\n\nvoid qca8k_port_mirror_del(struct dsa_switch *ds, int port,\n\t\t\t   struct dsa_mall_mirror_tc_entry *mirror)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\tu32 reg, val;\n\tint ret;\n\n\tif (mirror->ingress) {\n\t\treg = QCA8K_PORT_LOOKUP_CTRL(port);\n\t\tval = QCA8K_PORT_LOOKUP_ING_MIRROR_EN;\n\t} else {\n\t\treg = QCA8K_REG_PORT_HOL_CTRL1(port);\n\t\tval = QCA8K_PORT_HOL_CTRL1_EG_MIRROR_EN;\n\t}\n\n\tret = regmap_clear_bits(priv->regmap, reg, val);\n\tif (ret)\n\t\tgoto err;\n\n\tif (mirror->ingress)\n\t\tpriv->mirror_rx &= ~BIT(port);\n\telse\n\t\tpriv->mirror_tx &= ~BIT(port);\n\n\t \n\tif (!priv->mirror_rx && !priv->mirror_tx) {\n\t\tval = FIELD_PREP(QCA8K_GLOBAL_FW_CTRL0_MIRROR_PORT_NUM, 0xF);\n\t\tret = regmap_update_bits(priv->regmap, QCA8K_REG_GLOBAL_FW_CTRL0,\n\t\t\t\t\t QCA8K_GLOBAL_FW_CTRL0_MIRROR_PORT_NUM, val);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\nerr:\n\tdev_err(priv->dev, \"Failed to del mirror port from %d\", port);\n}\n\nint qca8k_port_vlan_filtering(struct dsa_switch *ds, int port,\n\t\t\t      bool vlan_filtering,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\tint ret;\n\n\tif (vlan_filtering) {\n\t\tret = qca8k_rmw(priv, QCA8K_PORT_LOOKUP_CTRL(port),\n\t\t\t\tQCA8K_PORT_LOOKUP_VLAN_MODE_MASK,\n\t\t\t\tQCA8K_PORT_LOOKUP_VLAN_MODE_SECURE);\n\t} else {\n\t\tret = qca8k_rmw(priv, QCA8K_PORT_LOOKUP_CTRL(port),\n\t\t\t\tQCA8K_PORT_LOOKUP_VLAN_MODE_MASK,\n\t\t\t\tQCA8K_PORT_LOOKUP_VLAN_MODE_NONE);\n\t}\n\n\treturn ret;\n}\n\nint qca8k_port_vlan_add(struct dsa_switch *ds, int port,\n\t\t\tconst struct switchdev_obj_port_vlan *vlan,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tbool untagged = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;\n\tbool pvid = vlan->flags & BRIDGE_VLAN_INFO_PVID;\n\tstruct qca8k_priv *priv = ds->priv;\n\tint ret;\n\n\tret = qca8k_vlan_add(priv, port, vlan->vid, untagged);\n\tif (ret) {\n\t\tdev_err(priv->dev, \"Failed to add VLAN to port %d (%d)\", port, ret);\n\t\treturn ret;\n\t}\n\n\tif (pvid) {\n\t\tret = qca8k_rmw(priv, QCA8K_EGRESS_VLAN(port),\n\t\t\t\tQCA8K_EGREES_VLAN_PORT_MASK(port),\n\t\t\t\tQCA8K_EGREES_VLAN_PORT(port, vlan->vid));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = qca8k_write(priv, QCA8K_REG_PORT_VLAN_CTRL0(port),\n\t\t\t\t  QCA8K_PORT_VLAN_CVID(vlan->vid) |\n\t\t\t\t  QCA8K_PORT_VLAN_SVID(vlan->vid));\n\t}\n\n\treturn ret;\n}\n\nint qca8k_port_vlan_del(struct dsa_switch *ds, int port,\n\t\t\tconst struct switchdev_obj_port_vlan *vlan)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\tint ret;\n\n\tret = qca8k_vlan_del(priv, port, vlan->vid);\n\tif (ret)\n\t\tdev_err(priv->dev, \"Failed to delete VLAN from port %d (%d)\", port, ret);\n\n\treturn ret;\n}\n\nstatic bool qca8k_lag_can_offload(struct dsa_switch *ds,\n\t\t\t\t  struct dsa_lag lag,\n\t\t\t\t  struct netdev_lag_upper_info *info,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct dsa_port *dp;\n\tint members = 0;\n\n\tif (!lag.id)\n\t\treturn false;\n\n\tdsa_lag_foreach_port(dp, ds->dst, &lag)\n\t\t \n\t\tmembers++;\n\n\tif (members > QCA8K_NUM_PORTS_FOR_LAG) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Cannot offload more than 4 LAG ports\");\n\t\treturn false;\n\t}\n\n\tif (info->tx_type != NETDEV_LAG_TX_TYPE_HASH) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Can only offload LAG using hash TX type\");\n\t\treturn false;\n\t}\n\n\tif (info->hash_type != NETDEV_LAG_HASH_L2 &&\n\t    info->hash_type != NETDEV_LAG_HASH_L23) {\n\t\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t\t   \"Can only offload L2 or L2+L3 TX hash\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int qca8k_lag_setup_hash(struct dsa_switch *ds,\n\t\t\t\tstruct dsa_lag lag,\n\t\t\t\tstruct netdev_lag_upper_info *info)\n{\n\tstruct net_device *lag_dev = lag.dev;\n\tstruct qca8k_priv *priv = ds->priv;\n\tbool unique_lag = true;\n\tunsigned int i;\n\tu32 hash = 0;\n\n\tswitch (info->hash_type) {\n\tcase NETDEV_LAG_HASH_L23:\n\t\thash |= QCA8K_TRUNK_HASH_SIP_EN;\n\t\thash |= QCA8K_TRUNK_HASH_DIP_EN;\n\t\tfallthrough;\n\tcase NETDEV_LAG_HASH_L2:\n\t\thash |= QCA8K_TRUNK_HASH_SA_EN;\n\t\thash |= QCA8K_TRUNK_HASH_DA_EN;\n\t\tbreak;\n\tdefault:  \n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tdsa_lags_foreach_id(i, ds->dst)\n\t\tif (i != lag.id && dsa_lag_by_id(ds->dst, i)) {\n\t\t\tunique_lag = false;\n\t\t\tbreak;\n\t\t}\n\n\t \n\tif (unique_lag) {\n\t\tpriv->lag_hash_mode = hash;\n\t} else if (priv->lag_hash_mode != hash) {\n\t\tnetdev_err(lag_dev, \"Error: Mismatched Hash Mode across different lag is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn regmap_update_bits(priv->regmap, QCA8K_TRUNK_HASH_EN_CTRL,\n\t\t\t\t  QCA8K_TRUNK_HASH_MASK, hash);\n}\n\nstatic int qca8k_lag_refresh_portmap(struct dsa_switch *ds, int port,\n\t\t\t\t     struct dsa_lag lag, bool delete)\n{\n\tstruct qca8k_priv *priv = ds->priv;\n\tint ret, id, i;\n\tu32 val;\n\n\t \n\tid = lag.id - 1;\n\n\t \n\tret = regmap_read(priv->regmap, QCA8K_REG_GOL_TRUNK_CTRL0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tval >>= QCA8K_REG_GOL_TRUNK_SHIFT(id);\n\tval &= QCA8K_REG_GOL_TRUNK_MEMBER_MASK;\n\tif (delete)\n\t\tval &= ~BIT(port);\n\telse\n\t\tval |= BIT(port);\n\n\t \n\tret = regmap_update_bits(priv->regmap, QCA8K_REG_GOL_TRUNK_CTRL0,\n\t\t\t\t QCA8K_REG_GOL_TRUNK_MEMBER(id) |\n\t\t\t\t QCA8K_REG_GOL_TRUNK_EN(id),\n\t\t\t\t !val << QCA8K_REG_GOL_TRUNK_SHIFT(id) |\n\t\t\t\t val << QCA8K_REG_GOL_TRUNK_SHIFT(id));\n\n\t \n\tfor (i = 0; i < QCA8K_NUM_PORTS_FOR_LAG; i++) {\n\t\tret = regmap_read(priv->regmap, QCA8K_REG_GOL_TRUNK_CTRL(id), &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval >>= QCA8K_REG_GOL_TRUNK_ID_MEM_ID_SHIFT(id, i);\n\t\tval &= QCA8K_REG_GOL_TRUNK_ID_MEM_ID_MASK;\n\n\t\tif (delete) {\n\t\t\t \n\t\t\tif (val != QCA8K_REG_GOL_TRUNK_ID_MEM_ID_EN_MASK)\n\t\t\t\tcontinue;\n\n\t\t\tval &= QCA8K_REG_GOL_TRUNK_ID_MEM_ID_PORT_MASK;\n\t\t\tif (val != port)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\t \n\t\t\tif (val == QCA8K_REG_GOL_TRUNK_ID_MEM_ID_EN_MASK)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tbreak;\n\t}\n\n\t \n\treturn regmap_update_bits(priv->regmap, QCA8K_REG_GOL_TRUNK_CTRL(id),\n\t\t\t\t  QCA8K_REG_GOL_TRUNK_ID_MEM_ID_EN(id, i) |\n\t\t\t\t  QCA8K_REG_GOL_TRUNK_ID_MEM_ID_PORT(id, i),\n\t\t\t\t  !delete << QCA8K_REG_GOL_TRUNK_ID_MEM_ID_SHIFT(id, i) |\n\t\t\t\t  port << QCA8K_REG_GOL_TRUNK_ID_MEM_ID_SHIFT(id, i));\n}\n\nint qca8k_port_lag_join(struct dsa_switch *ds, int port, struct dsa_lag lag,\n\t\t\tstruct netdev_lag_upper_info *info,\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tint ret;\n\n\tif (!qca8k_lag_can_offload(ds, lag, info, extack))\n\t\treturn -EOPNOTSUPP;\n\n\tret = qca8k_lag_setup_hash(ds, lag, info);\n\tif (ret)\n\t\treturn ret;\n\n\treturn qca8k_lag_refresh_portmap(ds, port, lag, false);\n}\n\nint qca8k_port_lag_leave(struct dsa_switch *ds, int port,\n\t\t\t struct dsa_lag lag)\n{\n\treturn qca8k_lag_refresh_portmap(ds, port, lag, true);\n}\n\nint qca8k_read_switch_id(struct qca8k_priv *priv)\n{\n\tu32 val;\n\tu8 id;\n\tint ret;\n\n\tif (!priv->info)\n\t\treturn -ENODEV;\n\n\tret = qca8k_read(priv, QCA8K_REG_MASK_CTRL, &val);\n\tif (ret < 0)\n\t\treturn -ENODEV;\n\n\tid = QCA8K_MASK_CTRL_DEVICE_ID(val);\n\tif (id != priv->info->id) {\n\t\tdev_err(priv->dev,\n\t\t\t\"Switch id detected %x but expected %x\",\n\t\t\tid, priv->info->id);\n\t\treturn -ENODEV;\n\t}\n\n\tpriv->switch_id = id;\n\n\t \n\tpriv->switch_revision = QCA8K_MASK_CTRL_REV_ID(val);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}