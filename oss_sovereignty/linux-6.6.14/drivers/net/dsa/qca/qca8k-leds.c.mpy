{
  "module_name": "qca8k-leds.c",
  "hash_id": "48f55c2e2744b82893a4bcf16e3595388af5e7103cc5ceaf512569e74c8f9190",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dsa/qca/qca8k-leds.c",
  "human_readable_source": "\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <net/dsa.h>\n\n#include \"qca8k.h\"\n#include \"qca8k_leds.h\"\n\nstatic u32 qca8k_phy_to_port(int phy)\n{\n\t \n\n\treturn phy + 1;\n}\n\nstatic int\nqca8k_get_enable_led_reg(int port_num, int led_num, struct qca8k_led_pattern_en *reg_info)\n{\n\tswitch (port_num) {\n\tcase 0:\n\t\treg_info->reg = QCA8K_LED_CTRL_REG(led_num);\n\t\treg_info->shift = QCA8K_LED_PHY0123_CONTROL_RULE_SHIFT;\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\t\t \n\t\treg_info->reg = QCA8K_LED_CTRL3_REG;\n\t\treg_info->shift = QCA8K_LED_PHY123_PATTERN_EN_SHIFT(port_num, led_num);\n\t\tbreak;\n\tcase 4:\n\t\treg_info->reg = QCA8K_LED_CTRL_REG(led_num);\n\t\treg_info->shift = QCA8K_LED_PHY4_CONTROL_RULE_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nqca8k_get_control_led_reg(int port_num, int led_num, struct qca8k_led_pattern_en *reg_info)\n{\n\treg_info->reg = QCA8K_LED_CTRL_REG(led_num);\n\n\t \n\tif (port_num == 4)\n\t\treg_info->shift = QCA8K_LED_PHY4_CONTROL_RULE_SHIFT;\n\telse\n\t\treg_info->shift = QCA8K_LED_PHY0123_CONTROL_RULE_SHIFT;\n\n\treturn 0;\n}\n\nstatic int\nqca8k_parse_netdev(unsigned long rules, u32 *offload_trigger)\n{\n\t \n\tif (test_bit(TRIGGER_NETDEV_TX, &rules))\n\t\t*offload_trigger |= QCA8K_LED_TX_BLINK_MASK;\n\tif (test_bit(TRIGGER_NETDEV_RX, &rules))\n\t\t*offload_trigger |= QCA8K_LED_RX_BLINK_MASK;\n\tif (test_bit(TRIGGER_NETDEV_LINK_10, &rules))\n\t\t*offload_trigger |= QCA8K_LED_LINK_10M_EN_MASK;\n\tif (test_bit(TRIGGER_NETDEV_LINK_100, &rules))\n\t\t*offload_trigger |= QCA8K_LED_LINK_100M_EN_MASK;\n\tif (test_bit(TRIGGER_NETDEV_LINK_1000, &rules))\n\t\t*offload_trigger |= QCA8K_LED_LINK_1000M_EN_MASK;\n\tif (test_bit(TRIGGER_NETDEV_HALF_DUPLEX, &rules))\n\t\t*offload_trigger |= QCA8K_LED_HALF_DUPLEX_MASK;\n\tif (test_bit(TRIGGER_NETDEV_FULL_DUPLEX, &rules))\n\t\t*offload_trigger |= QCA8K_LED_FULL_DUPLEX_MASK;\n\n\tif (rules && !*offload_trigger)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\t*offload_trigger |= QCA8K_LED_BLINK_4HZ;\n\n\treturn 0;\n}\n\nstatic int\nqca8k_led_brightness_set(struct qca8k_led *led,\n\t\t\t enum led_brightness brightness)\n{\n\tstruct qca8k_led_pattern_en reg_info;\n\tstruct qca8k_priv *priv = led->priv;\n\tu32 mask, val;\n\n\tqca8k_get_enable_led_reg(led->port_num, led->led_num, &reg_info);\n\n\tval = QCA8K_LED_ALWAYS_OFF;\n\tif (brightness)\n\t\tval = QCA8K_LED_ALWAYS_ON;\n\n\t \n\tif (led->port_num == 0 || led->port_num == 4) {\n\t\tmask = QCA8K_LED_PATTERN_EN_MASK;\n\t\tval <<= QCA8K_LED_PATTERN_EN_SHIFT;\n\t} else {\n\t\tmask = QCA8K_LED_PHY123_PATTERN_EN_MASK;\n\t}\n\n\treturn regmap_update_bits(priv->regmap, reg_info.reg,\n\t\t\t\t  mask << reg_info.shift,\n\t\t\t\t  val << reg_info.shift);\n}\n\nstatic int\nqca8k_cled_brightness_set_blocking(struct led_classdev *ldev,\n\t\t\t\t   enum led_brightness brightness)\n{\n\tstruct qca8k_led *led = container_of(ldev, struct qca8k_led, cdev);\n\n\treturn qca8k_led_brightness_set(led, brightness);\n}\n\nstatic enum led_brightness\nqca8k_led_brightness_get(struct qca8k_led *led)\n{\n\tstruct qca8k_led_pattern_en reg_info;\n\tstruct qca8k_priv *priv = led->priv;\n\tu32 val;\n\tint ret;\n\n\tqca8k_get_enable_led_reg(led->port_num, led->led_num, &reg_info);\n\n\tret = regmap_read(priv->regmap, reg_info.reg, &val);\n\tif (ret)\n\t\treturn 0;\n\n\tval >>= reg_info.shift;\n\n\tif (led->port_num == 0 || led->port_num == 4) {\n\t\tval &= QCA8K_LED_PATTERN_EN_MASK;\n\t\tval >>= QCA8K_LED_PATTERN_EN_SHIFT;\n\t} else {\n\t\tval &= QCA8K_LED_PHY123_PATTERN_EN_MASK;\n\t}\n\n\t \n\treturn val == QCA8K_LED_ALWAYS_ON;\n}\n\nstatic int\nqca8k_cled_blink_set(struct led_classdev *ldev,\n\t\t     unsigned long *delay_on,\n\t\t     unsigned long *delay_off)\n{\n\tstruct qca8k_led *led = container_of(ldev, struct qca8k_led, cdev);\n\tu32 mask, val = QCA8K_LED_ALWAYS_BLINK_4HZ;\n\tstruct qca8k_led_pattern_en reg_info;\n\tstruct qca8k_priv *priv = led->priv;\n\n\tif (*delay_on == 0 && *delay_off == 0) {\n\t\t*delay_on = 125;\n\t\t*delay_off = 125;\n\t}\n\n\tif (*delay_on != 125 || *delay_off != 125) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tqca8k_get_enable_led_reg(led->port_num, led->led_num, &reg_info);\n\n\tif (led->port_num == 0 || led->port_num == 4) {\n\t\tmask = QCA8K_LED_PATTERN_EN_MASK;\n\t\tval <<= QCA8K_LED_PATTERN_EN_SHIFT;\n\t} else {\n\t\tmask = QCA8K_LED_PHY123_PATTERN_EN_MASK;\n\t}\n\n\tregmap_update_bits(priv->regmap, reg_info.reg, mask << reg_info.shift,\n\t\t\t   val << reg_info.shift);\n\n\treturn 0;\n}\n\nstatic int\nqca8k_cled_trigger_offload(struct led_classdev *ldev, bool enable)\n{\n\tstruct qca8k_led *led = container_of(ldev, struct qca8k_led, cdev);\n\n\tstruct qca8k_led_pattern_en reg_info;\n\tstruct qca8k_priv *priv = led->priv;\n\tu32 mask, val = QCA8K_LED_ALWAYS_OFF;\n\n\tqca8k_get_enable_led_reg(led->port_num, led->led_num, &reg_info);\n\n\tif (enable)\n\t\tval = QCA8K_LED_RULE_CONTROLLED;\n\n\tif (led->port_num == 0 || led->port_num == 4) {\n\t\tmask = QCA8K_LED_PATTERN_EN_MASK;\n\t\tval <<= QCA8K_LED_PATTERN_EN_SHIFT;\n\t} else {\n\t\tmask = QCA8K_LED_PHY123_PATTERN_EN_MASK;\n\t}\n\n\treturn regmap_update_bits(priv->regmap, reg_info.reg, mask << reg_info.shift,\n\t\t\t\t  val << reg_info.shift);\n}\n\nstatic bool\nqca8k_cled_hw_control_status(struct led_classdev *ldev)\n{\n\tstruct qca8k_led *led = container_of(ldev, struct qca8k_led, cdev);\n\n\tstruct qca8k_led_pattern_en reg_info;\n\tstruct qca8k_priv *priv = led->priv;\n\tu32 val;\n\n\tqca8k_get_enable_led_reg(led->port_num, led->led_num, &reg_info);\n\n\tregmap_read(priv->regmap, reg_info.reg, &val);\n\n\tval >>= reg_info.shift;\n\n\tif (led->port_num == 0 || led->port_num == 4) {\n\t\tval &= QCA8K_LED_PATTERN_EN_MASK;\n\t\tval >>= QCA8K_LED_PATTERN_EN_SHIFT;\n\t} else {\n\t\tval &= QCA8K_LED_PHY123_PATTERN_EN_MASK;\n\t}\n\n\treturn val == QCA8K_LED_RULE_CONTROLLED;\n}\n\nstatic int\nqca8k_cled_hw_control_is_supported(struct led_classdev *ldev, unsigned long rules)\n{\n\tu32 offload_trigger = 0;\n\n\treturn qca8k_parse_netdev(rules, &offload_trigger);\n}\n\nstatic int\nqca8k_cled_hw_control_set(struct led_classdev *ldev, unsigned long rules)\n{\n\tstruct qca8k_led *led = container_of(ldev, struct qca8k_led, cdev);\n\tstruct qca8k_led_pattern_en reg_info;\n\tstruct qca8k_priv *priv = led->priv;\n\tu32 offload_trigger = 0;\n\tint ret;\n\n\tret = qca8k_parse_netdev(rules, &offload_trigger);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qca8k_cled_trigger_offload(ldev, true);\n\tif (ret)\n\t\treturn ret;\n\n\tqca8k_get_control_led_reg(led->port_num, led->led_num, &reg_info);\n\n\treturn regmap_update_bits(priv->regmap, reg_info.reg,\n\t\t\t\t  QCA8K_LED_RULE_MASK << reg_info.shift,\n\t\t\t\t  offload_trigger << reg_info.shift);\n}\n\nstatic int\nqca8k_cled_hw_control_get(struct led_classdev *ldev, unsigned long *rules)\n{\n\tstruct qca8k_led *led = container_of(ldev, struct qca8k_led, cdev);\n\tstruct qca8k_led_pattern_en reg_info;\n\tstruct qca8k_priv *priv = led->priv;\n\tu32 val;\n\tint ret;\n\n\t \n\tif (!qca8k_cled_hw_control_status(ldev))\n\t\treturn -EINVAL;\n\n\tqca8k_get_control_led_reg(led->port_num, led->led_num, &reg_info);\n\n\tret = regmap_read(priv->regmap, reg_info.reg, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tval >>= reg_info.shift;\n\tval &= QCA8K_LED_RULE_MASK;\n\n\t \n\tif (val & QCA8K_LED_TX_BLINK_MASK)\n\t\tset_bit(TRIGGER_NETDEV_TX, rules);\n\tif (val & QCA8K_LED_RX_BLINK_MASK)\n\t\tset_bit(TRIGGER_NETDEV_RX, rules);\n\tif (val & QCA8K_LED_LINK_10M_EN_MASK)\n\t\tset_bit(TRIGGER_NETDEV_LINK_10, rules);\n\tif (val & QCA8K_LED_LINK_100M_EN_MASK)\n\t\tset_bit(TRIGGER_NETDEV_LINK_100, rules);\n\tif (val & QCA8K_LED_LINK_1000M_EN_MASK)\n\t\tset_bit(TRIGGER_NETDEV_LINK_1000, rules);\n\tif (val & QCA8K_LED_HALF_DUPLEX_MASK)\n\t\tset_bit(TRIGGER_NETDEV_HALF_DUPLEX, rules);\n\tif (val & QCA8K_LED_FULL_DUPLEX_MASK)\n\t\tset_bit(TRIGGER_NETDEV_FULL_DUPLEX, rules);\n\n\treturn 0;\n}\n\nstatic struct device *qca8k_cled_hw_control_get_device(struct led_classdev *ldev)\n{\n\tstruct qca8k_led *led = container_of(ldev, struct qca8k_led, cdev);\n\tstruct qca8k_priv *priv = led->priv;\n\tstruct dsa_port *dp;\n\n\tdp = dsa_to_port(priv->ds, qca8k_phy_to_port(led->port_num));\n\tif (!dp)\n\t\treturn NULL;\n\tif (dp->slave)\n\t\treturn &dp->slave->dev;\n\treturn NULL;\n}\n\nstatic int\nqca8k_parse_port_leds(struct qca8k_priv *priv, struct fwnode_handle *port, int port_num)\n{\n\tstruct fwnode_handle *led = NULL, *leds = NULL;\n\tstruct led_init_data init_data = { };\n\tstruct dsa_switch *ds = priv->ds;\n\tenum led_default_state state;\n\tstruct qca8k_led *port_led;\n\tint led_num, led_index;\n\tint ret;\n\n\tleds = fwnode_get_named_child_node(port, \"leds\");\n\tif (!leds) {\n\t\tdev_dbg(priv->dev, \"No Leds node specified in device tree for port %d!\\n\",\n\t\t\tport_num);\n\t\treturn 0;\n\t}\n\n\tfwnode_for_each_child_node(leds, led) {\n\t\t \n\t\tif (fwnode_property_read_u32(led, \"reg\", &led_num))\n\t\t\tcontinue;\n\n\t\tif (led_num >= QCA8K_LED_PORT_COUNT) {\n\t\t\tdev_warn(priv->dev, \"Invalid LED reg %d defined for port %d\",\n\t\t\t\t led_num, port_num);\n\t\t\tcontinue;\n\t\t}\n\n\t\tled_index = QCA8K_LED_PORT_INDEX(port_num, led_num);\n\n\t\tport_led = &priv->ports_led[led_index];\n\t\tport_led->port_num = port_num;\n\t\tport_led->led_num = led_num;\n\t\tport_led->priv = priv;\n\n\t\tstate = led_init_default_state_get(led);\n\t\tswitch (state) {\n\t\tcase LEDS_DEFSTATE_ON:\n\t\t\tport_led->cdev.brightness = 1;\n\t\t\tqca8k_led_brightness_set(port_led, 1);\n\t\t\tbreak;\n\t\tcase LEDS_DEFSTATE_KEEP:\n\t\t\tport_led->cdev.brightness =\n\t\t\t\t\tqca8k_led_brightness_get(port_led);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tport_led->cdev.brightness = 0;\n\t\t\tqca8k_led_brightness_set(port_led, 0);\n\t\t}\n\n\t\tport_led->cdev.max_brightness = 1;\n\t\tport_led->cdev.brightness_set_blocking = qca8k_cled_brightness_set_blocking;\n\t\tport_led->cdev.blink_set = qca8k_cled_blink_set;\n\t\tport_led->cdev.hw_control_is_supported = qca8k_cled_hw_control_is_supported;\n\t\tport_led->cdev.hw_control_set = qca8k_cled_hw_control_set;\n\t\tport_led->cdev.hw_control_get = qca8k_cled_hw_control_get;\n\t\tport_led->cdev.hw_control_get_device = qca8k_cled_hw_control_get_device;\n\t\tport_led->cdev.hw_control_trigger = \"netdev\";\n\t\tinit_data.default_label = \":port\";\n\t\tinit_data.fwnode = led;\n\t\tinit_data.devname_mandatory = true;\n\t\tinit_data.devicename = kasprintf(GFP_KERNEL, \"%s:0%d\", ds->slave_mii_bus->id,\n\t\t\t\t\t\t port_num);\n\t\tif (!init_data.devicename)\n\t\t\treturn -ENOMEM;\n\n\t\tret = devm_led_classdev_register_ext(priv->dev, &port_led->cdev, &init_data);\n\t\tif (ret)\n\t\t\tdev_warn(priv->dev, \"Failed to init LED %d for port %d\", led_num, port_num);\n\n\t\tkfree(init_data.devicename);\n\t}\n\n\treturn 0;\n}\n\nint\nqca8k_setup_led_ctrl(struct qca8k_priv *priv)\n{\n\tstruct fwnode_handle *ports, *port;\n\tint port_num;\n\tint ret;\n\n\tports = device_get_named_child_node(priv->dev, \"ports\");\n\tif (!ports) {\n\t\tdev_info(priv->dev, \"No ports node specified in device tree!\");\n\t\treturn 0;\n\t}\n\n\tfwnode_for_each_child_node(ports, port) {\n\t\tif (fwnode_property_read_u32(port, \"reg\", &port_num))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (port_num == 0 || port_num == 6)\n\t\t\tcontinue;\n\n\t\t \n\t\tret = qca8k_parse_port_leds(priv, port, qca8k_port_to_phy(port_num));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}