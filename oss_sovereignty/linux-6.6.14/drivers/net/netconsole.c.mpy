{
  "module_name": "netconsole.c",
  "hash_id": "13097b3246cfb3ae1017d4d5613716f9154185e5334f40b7d01c9223fc0356d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/netconsole.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/console.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/netpoll.h>\n#include <linux/inet.h>\n#include <linux/configfs.h>\n#include <linux/etherdevice.h>\n#include <linux/utsname.h>\n\nMODULE_AUTHOR(\"Maintainer: Matt Mackall <mpm@selenic.com>\");\nMODULE_DESCRIPTION(\"Console driver for network interfaces\");\nMODULE_LICENSE(\"GPL\");\n\n#define MAX_PARAM_LENGTH\t256\n#define MAX_PRINT_CHUNK\t\t1000\n\nstatic char config[MAX_PARAM_LENGTH];\nmodule_param_string(netconsole, config, MAX_PARAM_LENGTH, 0);\nMODULE_PARM_DESC(netconsole, \" netconsole=[src-port]@[src-ip]/[dev],[tgt-port]@<tgt-ip>/[tgt-macaddr]\");\n\nstatic bool oops_only = false;\nmodule_param(oops_only, bool, 0600);\nMODULE_PARM_DESC(oops_only, \"Only log oops messages\");\n\n#ifndef\tMODULE\nstatic int __init option_setup(char *opt)\n{\n\tstrscpy(config, opt, MAX_PARAM_LENGTH);\n\treturn 1;\n}\n__setup(\"netconsole=\", option_setup);\n#endif\t \n\n \nstatic LIST_HEAD(target_list);\n\n \nstatic DEFINE_SPINLOCK(target_list_lock);\n\n \nstatic struct console netconsole_ext;\n\n \nstruct netconsole_target {\n\tstruct list_head\tlist;\n#ifdef\tCONFIG_NETCONSOLE_DYNAMIC\n\tstruct config_item\titem;\n#endif\n\tbool\t\t\tenabled;\n\tbool\t\t\textended;\n\tbool\t\t\trelease;\n\tstruct netpoll\t\tnp;\n};\n\n#ifdef\tCONFIG_NETCONSOLE_DYNAMIC\n\nstatic struct configfs_subsystem netconsole_subsys;\nstatic DEFINE_MUTEX(dynamic_netconsole_mutex);\n\nstatic int __init dynamic_netconsole_init(void)\n{\n\tconfig_group_init(&netconsole_subsys.su_group);\n\tmutex_init(&netconsole_subsys.su_mutex);\n\treturn configfs_register_subsystem(&netconsole_subsys);\n}\n\nstatic void __exit dynamic_netconsole_exit(void)\n{\n\tconfigfs_unregister_subsystem(&netconsole_subsys);\n}\n\n \nstatic void netconsole_target_get(struct netconsole_target *nt)\n{\n\tif (config_item_name(&nt->item))\n\t\tconfig_item_get(&nt->item);\n}\n\nstatic void netconsole_target_put(struct netconsole_target *nt)\n{\n\tif (config_item_name(&nt->item))\n\t\tconfig_item_put(&nt->item);\n}\n\n#else\t \n\nstatic int __init dynamic_netconsole_init(void)\n{\n\treturn 0;\n}\n\nstatic void __exit dynamic_netconsole_exit(void)\n{\n}\n\n \nstatic void netconsole_target_get(struct netconsole_target *nt)\n{\n}\n\nstatic void netconsole_target_put(struct netconsole_target *nt)\n{\n}\n\n#endif\t \n\n \nstatic struct netconsole_target *alloc_and_init(void)\n{\n\tstruct netconsole_target *nt;\n\n\tnt = kzalloc(sizeof(*nt), GFP_KERNEL);\n\tif (!nt)\n\t\treturn nt;\n\n\tif (IS_ENABLED(CONFIG_NETCONSOLE_EXTENDED_LOG))\n\t\tnt->extended = true;\n\tif (IS_ENABLED(CONFIG_NETCONSOLE_PREPEND_RELEASE))\n\t\tnt->release = true;\n\n\tnt->np.name = \"netconsole\";\n\tstrscpy(nt->np.dev_name, \"eth0\", IFNAMSIZ);\n\tnt->np.local_port = 6665;\n\tnt->np.remote_port = 6666;\n\teth_broadcast_addr(nt->np.remote_mac);\n\n\treturn nt;\n}\n\n \nstatic struct netconsole_target *alloc_param_target(char *target_config)\n{\n\tstruct netconsole_target *nt;\n\tint err;\n\n\tnt = alloc_and_init();\n\tif (!nt) {\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tif (*target_config == '+') {\n\t\tnt->extended = true;\n\t\ttarget_config++;\n\t}\n\n\tif (*target_config == 'r') {\n\t\tif (!nt->extended) {\n\t\t\tpr_err(\"Netconsole configuration error. Release feature requires extended log message\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tnt->release = true;\n\t\ttarget_config++;\n\t}\n\n\t \n\terr = netpoll_parse_options(&nt->np, target_config);\n\tif (err)\n\t\tgoto fail;\n\n\terr = netpoll_setup(&nt->np);\n\tif (err)\n\t\tgoto fail;\n\n\tnt->enabled = true;\n\n\treturn nt;\n\nfail:\n\tkfree(nt);\n\treturn ERR_PTR(err);\n}\n\n \nstatic void free_param_target(struct netconsole_target *nt)\n{\n\tnetpoll_cleanup(&nt->np);\n\tkfree(nt);\n}\n\n#ifdef\tCONFIG_NETCONSOLE_DYNAMIC\n\n \n\nstatic struct netconsole_target *to_target(struct config_item *item)\n{\n\treturn item ?\n\t\tcontainer_of(item, struct netconsole_target, item) :\n\t\tNULL;\n}\n\n \n\nstatic ssize_t enabled_show(struct config_item *item, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", to_target(item)->enabled);\n}\n\nstatic ssize_t extended_show(struct config_item *item, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", to_target(item)->extended);\n}\n\nstatic ssize_t release_show(struct config_item *item, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", to_target(item)->release);\n}\n\nstatic ssize_t dev_name_show(struct config_item *item, char *buf)\n{\n\treturn sysfs_emit(buf, \"%s\\n\", to_target(item)->np.dev_name);\n}\n\nstatic ssize_t local_port_show(struct config_item *item, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", to_target(item)->np.local_port);\n}\n\nstatic ssize_t remote_port_show(struct config_item *item, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", to_target(item)->np.remote_port);\n}\n\nstatic ssize_t local_ip_show(struct config_item *item, char *buf)\n{\n\tstruct netconsole_target *nt = to_target(item);\n\n\tif (nt->np.ipv6)\n\t\treturn sysfs_emit(buf, \"%pI6c\\n\", &nt->np.local_ip.in6);\n\telse\n\t\treturn sysfs_emit(buf, \"%pI4\\n\", &nt->np.local_ip);\n}\n\nstatic ssize_t remote_ip_show(struct config_item *item, char *buf)\n{\n\tstruct netconsole_target *nt = to_target(item);\n\n\tif (nt->np.ipv6)\n\t\treturn sysfs_emit(buf, \"%pI6c\\n\", &nt->np.remote_ip.in6);\n\telse\n\t\treturn sysfs_emit(buf, \"%pI4\\n\", &nt->np.remote_ip);\n}\n\nstatic ssize_t local_mac_show(struct config_item *item, char *buf)\n{\n\tstruct net_device *dev = to_target(item)->np.dev;\n\tstatic const u8 bcast[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\n\treturn sysfs_emit(buf, \"%pM\\n\", dev ? dev->dev_addr : bcast);\n}\n\nstatic ssize_t remote_mac_show(struct config_item *item, char *buf)\n{\n\treturn sysfs_emit(buf, \"%pM\\n\", to_target(item)->np.remote_mac);\n}\n\n \nstatic ssize_t enabled_store(struct config_item *item,\n\t\tconst char *buf, size_t count)\n{\n\tstruct netconsole_target *nt = to_target(item);\n\tunsigned long flags;\n\tbool enabled;\n\tint err;\n\n\tmutex_lock(&dynamic_netconsole_mutex);\n\terr = kstrtobool(buf, &enabled);\n\tif (err)\n\t\tgoto out_unlock;\n\n\terr = -EINVAL;\n\tif ((bool)enabled == nt->enabled) {\n\t\tpr_info(\"network logging has already %s\\n\",\n\t\t\tnt->enabled ? \"started\" : \"stopped\");\n\t\tgoto out_unlock;\n\t}\n\n\tif (enabled) {\t \n\t\tif (nt->release && !nt->extended) {\n\t\t\tpr_err(\"Not enabling netconsole. Release feature requires extended log message\");\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (nt->extended && !console_is_registered(&netconsole_ext))\n\t\t\tregister_console(&netconsole_ext);\n\n\t\t \n\t\tnetpoll_print_options(&nt->np);\n\n\t\terr = netpoll_setup(&nt->np);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\n\t\tpr_info(\"network logging started\\n\");\n\t} else {\t \n\t\t \n\t\tspin_lock_irqsave(&target_list_lock, flags);\n\t\tnt->enabled = false;\n\t\tspin_unlock_irqrestore(&target_list_lock, flags);\n\t\tnetpoll_cleanup(&nt->np);\n\t}\n\n\tnt->enabled = enabled;\n\n\tmutex_unlock(&dynamic_netconsole_mutex);\n\treturn strnlen(buf, count);\nout_unlock:\n\tmutex_unlock(&dynamic_netconsole_mutex);\n\treturn err;\n}\n\nstatic ssize_t release_store(struct config_item *item, const char *buf,\n\t\t\t     size_t count)\n{\n\tstruct netconsole_target *nt = to_target(item);\n\tbool release;\n\tint err;\n\n\tmutex_lock(&dynamic_netconsole_mutex);\n\tif (nt->enabled) {\n\t\tpr_err(\"target (%s) is enabled, disable to update parameters\\n\",\n\t\t       config_item_name(&nt->item));\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\terr = kstrtobool(buf, &release);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tnt->release = release;\n\n\tmutex_unlock(&dynamic_netconsole_mutex);\n\treturn strnlen(buf, count);\nout_unlock:\n\tmutex_unlock(&dynamic_netconsole_mutex);\n\treturn err;\n}\n\nstatic ssize_t extended_store(struct config_item *item, const char *buf,\n\t\tsize_t count)\n{\n\tstruct netconsole_target *nt = to_target(item);\n\tbool extended;\n\tint err;\n\n\tmutex_lock(&dynamic_netconsole_mutex);\n\tif (nt->enabled) {\n\t\tpr_err(\"target (%s) is enabled, disable to update parameters\\n\",\n\t\t       config_item_name(&nt->item));\n\t\terr = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\terr = kstrtobool(buf, &extended);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tnt->extended = extended;\n\n\tmutex_unlock(&dynamic_netconsole_mutex);\n\treturn strnlen(buf, count);\nout_unlock:\n\tmutex_unlock(&dynamic_netconsole_mutex);\n\treturn err;\n}\n\nstatic ssize_t dev_name_store(struct config_item *item, const char *buf,\n\t\tsize_t count)\n{\n\tstruct netconsole_target *nt = to_target(item);\n\tsize_t len;\n\n\tmutex_lock(&dynamic_netconsole_mutex);\n\tif (nt->enabled) {\n\t\tpr_err(\"target (%s) is enabled, disable to update parameters\\n\",\n\t\t       config_item_name(&nt->item));\n\t\tmutex_unlock(&dynamic_netconsole_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tstrscpy(nt->np.dev_name, buf, IFNAMSIZ);\n\n\t \n\tlen = strnlen(nt->np.dev_name, IFNAMSIZ);\n\tif (nt->np.dev_name[len - 1] == '\\n')\n\t\tnt->np.dev_name[len - 1] = '\\0';\n\n\tmutex_unlock(&dynamic_netconsole_mutex);\n\treturn strnlen(buf, count);\n}\n\nstatic ssize_t local_port_store(struct config_item *item, const char *buf,\n\t\tsize_t count)\n{\n\tstruct netconsole_target *nt = to_target(item);\n\tint rv = -EINVAL;\n\n\tmutex_lock(&dynamic_netconsole_mutex);\n\tif (nt->enabled) {\n\t\tpr_err(\"target (%s) is enabled, disable to update parameters\\n\",\n\t\t       config_item_name(&nt->item));\n\t\tgoto out_unlock;\n\t}\n\n\trv = kstrtou16(buf, 10, &nt->np.local_port);\n\tif (rv < 0)\n\t\tgoto out_unlock;\n\tmutex_unlock(&dynamic_netconsole_mutex);\n\treturn strnlen(buf, count);\nout_unlock:\n\tmutex_unlock(&dynamic_netconsole_mutex);\n\treturn rv;\n}\n\nstatic ssize_t remote_port_store(struct config_item *item,\n\t\tconst char *buf, size_t count)\n{\n\tstruct netconsole_target *nt = to_target(item);\n\tint rv = -EINVAL;\n\n\tmutex_lock(&dynamic_netconsole_mutex);\n\tif (nt->enabled) {\n\t\tpr_err(\"target (%s) is enabled, disable to update parameters\\n\",\n\t\t       config_item_name(&nt->item));\n\t\tgoto out_unlock;\n\t}\n\n\trv = kstrtou16(buf, 10, &nt->np.remote_port);\n\tif (rv < 0)\n\t\tgoto out_unlock;\n\tmutex_unlock(&dynamic_netconsole_mutex);\n\treturn strnlen(buf, count);\nout_unlock:\n\tmutex_unlock(&dynamic_netconsole_mutex);\n\treturn rv;\n}\n\nstatic ssize_t local_ip_store(struct config_item *item, const char *buf,\n\t\tsize_t count)\n{\n\tstruct netconsole_target *nt = to_target(item);\n\n\tmutex_lock(&dynamic_netconsole_mutex);\n\tif (nt->enabled) {\n\t\tpr_err(\"target (%s) is enabled, disable to update parameters\\n\",\n\t\t       config_item_name(&nt->item));\n\t\tgoto out_unlock;\n\t}\n\n\tif (strnchr(buf, count, ':')) {\n\t\tconst char *end;\n\t\tif (in6_pton(buf, count, nt->np.local_ip.in6.s6_addr, -1, &end) > 0) {\n\t\t\tif (*end && *end != '\\n') {\n\t\t\t\tpr_err(\"invalid IPv6 address at: <%c>\\n\", *end);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tnt->np.ipv6 = true;\n\t\t} else\n\t\t\tgoto out_unlock;\n\t} else {\n\t\tif (!nt->np.ipv6) {\n\t\t\tnt->np.local_ip.ip = in_aton(buf);\n\t\t} else\n\t\t\tgoto out_unlock;\n\t}\n\n\tmutex_unlock(&dynamic_netconsole_mutex);\n\treturn strnlen(buf, count);\nout_unlock:\n\tmutex_unlock(&dynamic_netconsole_mutex);\n\treturn -EINVAL;\n}\n\nstatic ssize_t remote_ip_store(struct config_item *item, const char *buf,\n\t       size_t count)\n{\n\tstruct netconsole_target *nt = to_target(item);\n\n\tmutex_lock(&dynamic_netconsole_mutex);\n\tif (nt->enabled) {\n\t\tpr_err(\"target (%s) is enabled, disable to update parameters\\n\",\n\t\t       config_item_name(&nt->item));\n\t\tgoto out_unlock;\n\t}\n\n\tif (strnchr(buf, count, ':')) {\n\t\tconst char *end;\n\t\tif (in6_pton(buf, count, nt->np.remote_ip.in6.s6_addr, -1, &end) > 0) {\n\t\t\tif (*end && *end != '\\n') {\n\t\t\t\tpr_err(\"invalid IPv6 address at: <%c>\\n\", *end);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tnt->np.ipv6 = true;\n\t\t} else\n\t\t\tgoto out_unlock;\n\t} else {\n\t\tif (!nt->np.ipv6) {\n\t\t\tnt->np.remote_ip.ip = in_aton(buf);\n\t\t} else\n\t\t\tgoto out_unlock;\n\t}\n\n\tmutex_unlock(&dynamic_netconsole_mutex);\n\treturn strnlen(buf, count);\nout_unlock:\n\tmutex_unlock(&dynamic_netconsole_mutex);\n\treturn -EINVAL;\n}\n\nstatic ssize_t remote_mac_store(struct config_item *item, const char *buf,\n\t\tsize_t count)\n{\n\tstruct netconsole_target *nt = to_target(item);\n\tu8 remote_mac[ETH_ALEN];\n\n\tmutex_lock(&dynamic_netconsole_mutex);\n\tif (nt->enabled) {\n\t\tpr_err(\"target (%s) is enabled, disable to update parameters\\n\",\n\t\t       config_item_name(&nt->item));\n\t\tgoto out_unlock;\n\t}\n\n\tif (!mac_pton(buf, remote_mac))\n\t\tgoto out_unlock;\n\tif (buf[3 * ETH_ALEN - 1] && buf[3 * ETH_ALEN - 1] != '\\n')\n\t\tgoto out_unlock;\n\tmemcpy(nt->np.remote_mac, remote_mac, ETH_ALEN);\n\n\tmutex_unlock(&dynamic_netconsole_mutex);\n\treturn strnlen(buf, count);\nout_unlock:\n\tmutex_unlock(&dynamic_netconsole_mutex);\n\treturn -EINVAL;\n}\n\nCONFIGFS_ATTR(, enabled);\nCONFIGFS_ATTR(, extended);\nCONFIGFS_ATTR(, dev_name);\nCONFIGFS_ATTR(, local_port);\nCONFIGFS_ATTR(, remote_port);\nCONFIGFS_ATTR(, local_ip);\nCONFIGFS_ATTR(, remote_ip);\nCONFIGFS_ATTR_RO(, local_mac);\nCONFIGFS_ATTR(, remote_mac);\nCONFIGFS_ATTR(, release);\n\nstatic struct configfs_attribute *netconsole_target_attrs[] = {\n\t&attr_enabled,\n\t&attr_extended,\n\t&attr_release,\n\t&attr_dev_name,\n\t&attr_local_port,\n\t&attr_remote_port,\n\t&attr_local_ip,\n\t&attr_remote_ip,\n\t&attr_local_mac,\n\t&attr_remote_mac,\n\tNULL,\n};\n\n \n\nstatic void netconsole_target_release(struct config_item *item)\n{\n\tkfree(to_target(item));\n}\n\nstatic struct configfs_item_operations netconsole_target_item_ops = {\n\t.release\t\t= netconsole_target_release,\n};\n\nstatic const struct config_item_type netconsole_target_type = {\n\t.ct_attrs\t\t= netconsole_target_attrs,\n\t.ct_item_ops\t\t= &netconsole_target_item_ops,\n\t.ct_owner\t\t= THIS_MODULE,\n};\n\n \n\nstatic struct config_item *make_netconsole_target(struct config_group *group,\n\t\t\t\t\t\t  const char *name)\n{\n\tstruct netconsole_target *nt;\n\tunsigned long flags;\n\n\tnt = alloc_and_init();\n\tif (!nt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tconfig_item_init_type_name(&nt->item, name, &netconsole_target_type);\n\n\t \n\tspin_lock_irqsave(&target_list_lock, flags);\n\tlist_add(&nt->list, &target_list);\n\tspin_unlock_irqrestore(&target_list_lock, flags);\n\n\treturn &nt->item;\n}\n\nstatic void drop_netconsole_target(struct config_group *group,\n\t\t\t\t   struct config_item *item)\n{\n\tunsigned long flags;\n\tstruct netconsole_target *nt = to_target(item);\n\n\tspin_lock_irqsave(&target_list_lock, flags);\n\tlist_del(&nt->list);\n\tspin_unlock_irqrestore(&target_list_lock, flags);\n\n\t \n\tif (nt->enabled)\n\t\tnetpoll_cleanup(&nt->np);\n\n\tconfig_item_put(&nt->item);\n}\n\nstatic struct configfs_group_operations netconsole_subsys_group_ops = {\n\t.make_item\t= make_netconsole_target,\n\t.drop_item\t= drop_netconsole_target,\n};\n\nstatic const struct config_item_type netconsole_subsys_type = {\n\t.ct_group_ops\t= &netconsole_subsys_group_ops,\n\t.ct_owner\t= THIS_MODULE,\n};\n\n \nstatic struct configfs_subsystem netconsole_subsys = {\n\t.su_group\t= {\n\t\t.cg_item\t= {\n\t\t\t.ci_namebuf\t= \"netconsole\",\n\t\t\t.ci_type\t= &netconsole_subsys_type,\n\t\t},\n\t},\n};\n\n#endif\t \n\n \nstatic int netconsole_netdev_event(struct notifier_block *this,\n\t\t\t\t   unsigned long event, void *ptr)\n{\n\tunsigned long flags;\n\tstruct netconsole_target *nt;\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tbool stopped = false;\n\n\tif (!(event == NETDEV_CHANGENAME || event == NETDEV_UNREGISTER ||\n\t      event == NETDEV_RELEASE || event == NETDEV_JOIN))\n\t\tgoto done;\n\n\tspin_lock_irqsave(&target_list_lock, flags);\nrestart:\n\tlist_for_each_entry(nt, &target_list, list) {\n\t\tnetconsole_target_get(nt);\n\t\tif (nt->np.dev == dev) {\n\t\t\tswitch (event) {\n\t\t\tcase NETDEV_CHANGENAME:\n\t\t\t\tstrscpy(nt->np.dev_name, dev->name, IFNAMSIZ);\n\t\t\t\tbreak;\n\t\t\tcase NETDEV_RELEASE:\n\t\t\tcase NETDEV_JOIN:\n\t\t\tcase NETDEV_UNREGISTER:\n\t\t\t\t \n\t\t\t\tspin_unlock_irqrestore(&target_list_lock, flags);\n\n\t\t\t\t__netpoll_cleanup(&nt->np);\n\n\t\t\t\tspin_lock_irqsave(&target_list_lock, flags);\n\t\t\t\tnetdev_put(nt->np.dev, &nt->np.dev_tracker);\n\t\t\t\tnt->np.dev = NULL;\n\t\t\t\tnt->enabled = false;\n\t\t\t\tstopped = true;\n\t\t\t\tnetconsole_target_put(nt);\n\t\t\t\tgoto restart;\n\t\t\t}\n\t\t}\n\t\tnetconsole_target_put(nt);\n\t}\n\tspin_unlock_irqrestore(&target_list_lock, flags);\n\tif (stopped) {\n\t\tconst char *msg = \"had an event\";\n\t\tswitch (event) {\n\t\tcase NETDEV_UNREGISTER:\n\t\t\tmsg = \"unregistered\";\n\t\t\tbreak;\n\t\tcase NETDEV_RELEASE:\n\t\t\tmsg = \"released slaves\";\n\t\t\tbreak;\n\t\tcase NETDEV_JOIN:\n\t\t\tmsg = \"is joining a master device\";\n\t\t\tbreak;\n\t\t}\n\t\tpr_info(\"network logging stopped on interface %s as it %s\\n\",\n\t\t\tdev->name, msg);\n\t}\n\ndone:\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block netconsole_netdev_notifier = {\n\t.notifier_call  = netconsole_netdev_event,\n};\n\n \nstatic void send_ext_msg_udp(struct netconsole_target *nt, const char *msg,\n\t\t\t     int msg_len)\n{\n\tstatic char buf[MAX_PRINT_CHUNK];  \n\tconst char *header, *body;\n\tint offset = 0;\n\tint header_len, body_len;\n\tconst char *msg_ready = msg;\n\tconst char *release;\n\tint release_len = 0;\n\n\tif (nt->release) {\n\t\trelease = init_utsname()->release;\n\t\trelease_len = strlen(release) + 1;\n\t}\n\n\tif (msg_len + release_len <= MAX_PRINT_CHUNK) {\n\t\t \n\t\tif (nt->release) {\n\t\t\tscnprintf(buf, MAX_PRINT_CHUNK, \"%s,%s\", release, msg);\n\t\t\tmsg_len += release_len;\n\t\t\tmsg_ready = buf;\n\t\t}\n\t\tnetpoll_send_udp(&nt->np, msg_ready, msg_len);\n\t\treturn;\n\t}\n\n\t \n\theader = msg;\n\tbody = memchr(msg, ';', msg_len);\n\tif (WARN_ON_ONCE(!body))\n\t\treturn;\n\n\theader_len = body - header;\n\tbody_len = msg_len - header_len - 1;\n\tbody++;\n\n\t \n\tif (nt->release)\n\t\tscnprintf(buf, MAX_PRINT_CHUNK, \"%s,\", release);\n\tmemcpy(buf + release_len, header, header_len);\n\theader_len += release_len;\n\n\twhile (offset < body_len) {\n\t\tint this_header = header_len;\n\t\tint this_chunk;\n\n\t\tthis_header += scnprintf(buf + this_header,\n\t\t\t\t\t sizeof(buf) - this_header,\n\t\t\t\t\t \",ncfrag=%d/%d;\", offset, body_len);\n\n\t\tthis_chunk = min(body_len - offset,\n\t\t\t\t MAX_PRINT_CHUNK - this_header);\n\t\tif (WARN_ON_ONCE(this_chunk <= 0))\n\t\t\treturn;\n\n\t\tmemcpy(buf + this_header, body + offset, this_chunk);\n\n\t\tnetpoll_send_udp(&nt->np, buf, this_header + this_chunk);\n\n\t\toffset += this_chunk;\n\t}\n}\n\nstatic void write_ext_msg(struct console *con, const char *msg,\n\t\t\t  unsigned int len)\n{\n\tstruct netconsole_target *nt;\n\tunsigned long flags;\n\n\tif ((oops_only && !oops_in_progress) || list_empty(&target_list))\n\t\treturn;\n\n\tspin_lock_irqsave(&target_list_lock, flags);\n\tlist_for_each_entry(nt, &target_list, list)\n\t\tif (nt->extended && nt->enabled && netif_running(nt->np.dev))\n\t\t\tsend_ext_msg_udp(nt, msg, len);\n\tspin_unlock_irqrestore(&target_list_lock, flags);\n}\n\nstatic void write_msg(struct console *con, const char *msg, unsigned int len)\n{\n\tint frag, left;\n\tunsigned long flags;\n\tstruct netconsole_target *nt;\n\tconst char *tmp;\n\n\tif (oops_only && !oops_in_progress)\n\t\treturn;\n\t \n\tif (list_empty(&target_list))\n\t\treturn;\n\n\tspin_lock_irqsave(&target_list_lock, flags);\n\tlist_for_each_entry(nt, &target_list, list) {\n\t\tif (!nt->extended && nt->enabled && netif_running(nt->np.dev)) {\n\t\t\t \n\t\t\ttmp = msg;\n\t\t\tfor (left = len; left;) {\n\t\t\t\tfrag = min(left, MAX_PRINT_CHUNK);\n\t\t\t\tnetpoll_send_udp(&nt->np, tmp, frag);\n\t\t\t\ttmp += frag;\n\t\t\t\tleft -= frag;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&target_list_lock, flags);\n}\n\nstatic struct console netconsole_ext = {\n\t.name\t= \"netcon_ext\",\n\t.flags\t= CON_ENABLED | CON_EXTENDED,\n\t.write\t= write_ext_msg,\n};\n\nstatic struct console netconsole = {\n\t.name\t= \"netcon\",\n\t.flags\t= CON_ENABLED,\n\t.write\t= write_msg,\n};\n\nstatic int __init init_netconsole(void)\n{\n\tint err;\n\tstruct netconsole_target *nt, *tmp;\n\tbool extended = false;\n\tunsigned long flags;\n\tchar *target_config;\n\tchar *input = config;\n\n\tif (strnlen(input, MAX_PARAM_LENGTH)) {\n\t\twhile ((target_config = strsep(&input, \";\"))) {\n\t\t\tnt = alloc_param_target(target_config);\n\t\t\tif (IS_ERR(nt)) {\n\t\t\t\terr = PTR_ERR(nt);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\t \n\t\t\tif (nt->extended) {\n\t\t\t\textended = true;\n\t\t\t\tnetconsole_ext.flags |= CON_PRINTBUFFER;\n\t\t\t} else {\n\t\t\t\tnetconsole.flags |= CON_PRINTBUFFER;\n\t\t\t}\n\n\t\t\tspin_lock_irqsave(&target_list_lock, flags);\n\t\t\tlist_add(&nt->list, &target_list);\n\t\t\tspin_unlock_irqrestore(&target_list_lock, flags);\n\t\t}\n\t}\n\n\terr = register_netdevice_notifier(&netconsole_netdev_notifier);\n\tif (err)\n\t\tgoto fail;\n\n\terr = dynamic_netconsole_init();\n\tif (err)\n\t\tgoto undonotifier;\n\n\tif (extended)\n\t\tregister_console(&netconsole_ext);\n\tregister_console(&netconsole);\n\tpr_info(\"network logging started\\n\");\n\n\treturn err;\n\nundonotifier:\n\tunregister_netdevice_notifier(&netconsole_netdev_notifier);\n\nfail:\n\tpr_err(\"cleaning up\\n\");\n\n\t \n\tlist_for_each_entry_safe(nt, tmp, &target_list, list) {\n\t\tlist_del(&nt->list);\n\t\tfree_param_target(nt);\n\t}\n\n\treturn err;\n}\n\nstatic void __exit cleanup_netconsole(void)\n{\n\tstruct netconsole_target *nt, *tmp;\n\n\tif (console_is_registered(&netconsole_ext))\n\t\tunregister_console(&netconsole_ext);\n\tunregister_console(&netconsole);\n\tdynamic_netconsole_exit();\n\tunregister_netdevice_notifier(&netconsole_netdev_notifier);\n\n\t \n\tlist_for_each_entry_safe(nt, tmp, &target_list, list) {\n\t\tlist_del(&nt->list);\n\t\tfree_param_target(nt);\n\t}\n}\n\n \nlate_initcall(init_netconsole);\nmodule_exit(cleanup_netconsole);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}