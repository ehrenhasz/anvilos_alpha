{
  "module_name": "plip.c",
  "hash_id": "973f95880fc15d552b110cf831bdd777e39d4e310f47581bf032b7fec7aa167b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/plip/plip.c",
  "human_readable_source": "\n \n \n \n \n\n \n\n \nstatic const char version[] = \"NET3 PLIP version 2.4-parport gniibe@mri.co.jp\\n\";\n\n \n\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/if_ether.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/inetdevice.h>\n#include <linux/skbuff.h>\n#include <linux/if_plip.h>\n#include <linux/workqueue.h>\n#include <linux/spinlock.h>\n#include <linux/completion.h>\n#include <linux/parport.h>\n#include <linux/bitops.h>\n\n#include <net/neighbour.h>\n\n#include <asm/irq.h>\n#include <asm/byteorder.h>\n\n \n#define PLIP_MAX  8\n\n \n#ifndef NET_DEBUG\n#define NET_DEBUG 1\n#endif\nstatic const unsigned int net_debug = NET_DEBUG;\n\n#define ENABLE(irq)  if (irq != -1) enable_irq(irq)\n#define DISABLE(irq) if (irq != -1) disable_irq(irq)\n\n \n#define PLIP_DELAY_UNIT\t\t   1\n\n \n#define PLIP_TRIGGER_WAIT\t 500\n\n \n#define PLIP_NIBBLE_WAIT        3000\n\n \nstatic void plip_kick_bh(struct work_struct *work);\nstatic void plip_bh(struct work_struct *work);\nstatic void plip_timer_bh(struct work_struct *work);\n\n \nstatic void plip_interrupt(void *dev_id);\n\n \nstatic netdev_tx_t plip_tx_packet(struct sk_buff *skb, struct net_device *dev);\nstatic int plip_hard_header(struct sk_buff *skb, struct net_device *dev,\n                            unsigned short type, const void *daddr,\n\t\t\t    const void *saddr, unsigned len);\nstatic int plip_hard_header_cache(const struct neighbour *neigh,\n                                  struct hh_cache *hh, __be16 type);\nstatic int plip_open(struct net_device *dev);\nstatic int plip_close(struct net_device *dev);\nstatic int plip_siocdevprivate(struct net_device *dev, struct ifreq *ifr,\n\t\t\t       void __user *data, int cmd);\nstatic int plip_preempt(void *handle);\nstatic void plip_wakeup(void *handle);\n\nenum plip_connection_state {\n\tPLIP_CN_NONE=0,\n\tPLIP_CN_RECEIVE,\n\tPLIP_CN_SEND,\n\tPLIP_CN_CLOSING,\n\tPLIP_CN_ERROR\n};\n\nenum plip_packet_state {\n\tPLIP_PK_DONE=0,\n\tPLIP_PK_TRIGGER,\n\tPLIP_PK_LENGTH_LSB,\n\tPLIP_PK_LENGTH_MSB,\n\tPLIP_PK_DATA,\n\tPLIP_PK_CHECKSUM\n};\n\nenum plip_nibble_state {\n\tPLIP_NB_BEGIN,\n\tPLIP_NB_1,\n\tPLIP_NB_2,\n};\n\nstruct plip_local {\n\tenum plip_packet_state state;\n\tenum plip_nibble_state nibble;\n\tunion {\n\t\tstruct {\n#if defined(__LITTLE_ENDIAN)\n\t\t\tunsigned char lsb;\n\t\t\tunsigned char msb;\n#elif defined(__BIG_ENDIAN)\n\t\t\tunsigned char msb;\n\t\t\tunsigned char lsb;\n#else\n#error\t\"Please fix the endianness defines in <asm/byteorder.h>\"\n#endif\n\t\t} b;\n\t\tunsigned short h;\n\t} length;\n\tunsigned short byte;\n\tunsigned char  checksum;\n\tunsigned char  data;\n\tstruct sk_buff *skb;\n};\n\nstruct net_local {\n\tstruct net_device *dev;\n\tstruct work_struct immediate;\n\tstruct delayed_work deferred;\n\tstruct delayed_work timer;\n\tstruct plip_local snd_data;\n\tstruct plip_local rcv_data;\n\tstruct pardevice *pardev;\n\tunsigned long  trigger;\n\tunsigned long  nibble;\n\tenum plip_connection_state connection;\n\tunsigned short timeout_count;\n\tint is_deferred;\n\tint port_owner;\n\tint should_relinquish;\n\tspinlock_t lock;\n\tatomic_t kill_timer;\n\tstruct completion killed_timer_cmp;\n};\n\nstatic inline void enable_parport_interrupts (struct net_device *dev)\n{\n\tif (dev->irq != -1)\n\t{\n\t\tstruct parport *port =\n\t\t   ((struct net_local *)netdev_priv(dev))->pardev->port;\n\t\tport->ops->enable_irq (port);\n\t}\n}\n\nstatic inline void disable_parport_interrupts (struct net_device *dev)\n{\n\tif (dev->irq != -1)\n\t{\n\t\tstruct parport *port =\n\t\t   ((struct net_local *)netdev_priv(dev))->pardev->port;\n\t\tport->ops->disable_irq (port);\n\t}\n}\n\nstatic inline void write_data (struct net_device *dev, unsigned char data)\n{\n\tstruct parport *port =\n\t   ((struct net_local *)netdev_priv(dev))->pardev->port;\n\n\tport->ops->write_data (port, data);\n}\n\nstatic inline unsigned char read_status (struct net_device *dev)\n{\n\tstruct parport *port =\n\t   ((struct net_local *)netdev_priv(dev))->pardev->port;\n\n\treturn port->ops->read_status (port);\n}\n\nstatic const struct header_ops plip_header_ops = {\n\t.create\t= plip_hard_header,\n\t.cache  = plip_hard_header_cache,\n};\n\nstatic const struct net_device_ops plip_netdev_ops = {\n\t.ndo_open\t\t = plip_open,\n\t.ndo_stop\t\t = plip_close,\n\t.ndo_start_xmit\t\t = plip_tx_packet,\n\t.ndo_siocdevprivate\t = plip_siocdevprivate,\n\t.ndo_set_mac_address\t = eth_mac_addr,\n\t.ndo_validate_addr\t = eth_validate_addr,\n};\n\n \nstatic void\nplip_init_netdev(struct net_device *dev)\n{\n\tstatic const u8 addr_init[ETH_ALEN] = {\n\t\t0xfc, 0xfc, 0xfc,\n\t\t0xfc, 0xfc, 0xfc,\n\t};\n\tstruct net_local *nl = netdev_priv(dev);\n\n\t \n\tdev->tx_queue_len \t = 10;\n\tdev->flags\t         = IFF_POINTOPOINT|IFF_NOARP;\n\teth_hw_addr_set(dev, addr_init);\n\n\tdev->netdev_ops\t\t = &plip_netdev_ops;\n\tdev->header_ops          = &plip_header_ops;\n\n\n\tnl->port_owner = 0;\n\n\t \n\tnl->trigger\t= PLIP_TRIGGER_WAIT;\n\tnl->nibble\t= PLIP_NIBBLE_WAIT;\n\n\t \n\tINIT_WORK(&nl->immediate, plip_bh);\n\tINIT_DELAYED_WORK(&nl->deferred, plip_kick_bh);\n\n\tif (dev->irq == -1)\n\t\tINIT_DELAYED_WORK(&nl->timer, plip_timer_bh);\n\n\tspin_lock_init(&nl->lock);\n}\n\n \nstatic void\nplip_kick_bh(struct work_struct *work)\n{\n\tstruct net_local *nl =\n\t\tcontainer_of(work, struct net_local, deferred.work);\n\n\tif (nl->is_deferred)\n\t\tschedule_work(&nl->immediate);\n}\n\n \nstatic int plip_none(struct net_device *, struct net_local *,\n\t\t     struct plip_local *, struct plip_local *);\nstatic int plip_receive_packet(struct net_device *, struct net_local *,\n\t\t\t       struct plip_local *, struct plip_local *);\nstatic int plip_send_packet(struct net_device *, struct net_local *,\n\t\t\t    struct plip_local *, struct plip_local *);\nstatic int plip_connection_close(struct net_device *, struct net_local *,\n\t\t\t\t struct plip_local *, struct plip_local *);\nstatic int plip_error(struct net_device *, struct net_local *,\n\t\t      struct plip_local *, struct plip_local *);\nstatic int plip_bh_timeout_error(struct net_device *dev, struct net_local *nl,\n\t\t\t\t struct plip_local *snd,\n\t\t\t\t struct plip_local *rcv,\n\t\t\t\t int error);\n\n#define OK        0\n#define TIMEOUT   1\n#define ERROR     2\n#define HS_TIMEOUT\t3\n\ntypedef int (*plip_func)(struct net_device *dev, struct net_local *nl,\n\t\t\t struct plip_local *snd, struct plip_local *rcv);\n\nstatic const plip_func connection_state_table[] =\n{\n\tplip_none,\n\tplip_receive_packet,\n\tplip_send_packet,\n\tplip_connection_close,\n\tplip_error\n};\n\n \nstatic void\nplip_bh(struct work_struct *work)\n{\n\tstruct net_local *nl = container_of(work, struct net_local, immediate);\n\tstruct plip_local *snd = &nl->snd_data;\n\tstruct plip_local *rcv = &nl->rcv_data;\n\tplip_func f;\n\tint r;\n\n\tnl->is_deferred = 0;\n\tf = connection_state_table[nl->connection];\n\tif ((r = (*f)(nl->dev, nl, snd, rcv)) != OK &&\n\t    (r = plip_bh_timeout_error(nl->dev, nl, snd, rcv, r)) != OK) {\n\t\tnl->is_deferred = 1;\n\t\tschedule_delayed_work(&nl->deferred, 1);\n\t}\n}\n\nstatic void\nplip_timer_bh(struct work_struct *work)\n{\n\tstruct net_local *nl =\n\t\tcontainer_of(work, struct net_local, timer.work);\n\n\tif (!(atomic_read (&nl->kill_timer))) {\n\t\tplip_interrupt (nl->dev);\n\n\t\tschedule_delayed_work(&nl->timer, 1);\n\t}\n\telse {\n\t\tcomplete(&nl->killed_timer_cmp);\n\t}\n}\n\nstatic int\nplip_bh_timeout_error(struct net_device *dev, struct net_local *nl,\n\t\t      struct plip_local *snd, struct plip_local *rcv,\n\t\t      int error)\n{\n\tunsigned char c0;\n\t \n\n\tspin_lock_irq(&nl->lock);\n\tif (nl->connection == PLIP_CN_SEND) {\n\n\t\tif (error != ERROR) {  \n\t\t\tnl->timeout_count++;\n\t\t\tif ((error == HS_TIMEOUT && nl->timeout_count <= 10) ||\n\t\t\t    nl->timeout_count <= 3) {\n\t\t\t\tspin_unlock_irq(&nl->lock);\n\t\t\t\t \n\t\t\t\treturn TIMEOUT;\n\t\t\t}\n\t\t\tc0 = read_status(dev);\n\t\t\tprintk(KERN_WARNING \"%s: transmit timeout(%d,%02x)\\n\",\n\t\t\t       dev->name, snd->state, c0);\n\t\t} else\n\t\t\terror = HS_TIMEOUT;\n\t\tdev->stats.tx_errors++;\n\t\tdev->stats.tx_aborted_errors++;\n\t} else if (nl->connection == PLIP_CN_RECEIVE) {\n\t\tif (rcv->state == PLIP_PK_TRIGGER) {\n\t\t\t \n\t\t\tspin_unlock_irq(&nl->lock);\n\t\t\treturn OK;\n\t\t}\n\t\tif (error != ERROR) {  \n\t\t\tif (++nl->timeout_count <= 3) {\n\t\t\t\tspin_unlock_irq(&nl->lock);\n\t\t\t\t \n\t\t\t\treturn TIMEOUT;\n\t\t\t}\n\t\t\tc0 = read_status(dev);\n\t\t\tprintk(KERN_WARNING \"%s: receive timeout(%d,%02x)\\n\",\n\t\t\t       dev->name, rcv->state, c0);\n\t\t}\n\t\tdev->stats.rx_dropped++;\n\t}\n\trcv->state = PLIP_PK_DONE;\n\tif (rcv->skb) {\n\t\tdev_kfree_skb_irq(rcv->skb);\n\t\trcv->skb = NULL;\n\t}\n\tsnd->state = PLIP_PK_DONE;\n\tif (snd->skb) {\n\t\tdev_consume_skb_irq(snd->skb);\n\t\tsnd->skb = NULL;\n\t}\n\tspin_unlock_irq(&nl->lock);\n\tif (error == HS_TIMEOUT) {\n\t\tDISABLE(dev->irq);\n\t\tsynchronize_irq(dev->irq);\n\t}\n\tdisable_parport_interrupts (dev);\n\tnetif_stop_queue (dev);\n\tnl->connection = PLIP_CN_ERROR;\n\twrite_data (dev, 0x00);\n\n\treturn TIMEOUT;\n}\n\nstatic int\nplip_none(struct net_device *dev, struct net_local *nl,\n\t  struct plip_local *snd, struct plip_local *rcv)\n{\n\treturn OK;\n}\n\n \nstatic inline int\nplip_receive(unsigned short nibble_timeout, struct net_device *dev,\n\t     enum plip_nibble_state *ns_p, unsigned char *data_p)\n{\n\tunsigned char c0, c1;\n\tunsigned int cx;\n\n\tswitch (*ns_p) {\n\tcase PLIP_NB_BEGIN:\n\t\tcx = nibble_timeout;\n\t\twhile (1) {\n\t\t\tc0 = read_status(dev);\n\t\t\tudelay(PLIP_DELAY_UNIT);\n\t\t\tif ((c0 & 0x80) == 0) {\n\t\t\t\tc1 = read_status(dev);\n\t\t\t\tif (c0 == c1)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (--cx == 0)\n\t\t\t\treturn TIMEOUT;\n\t\t}\n\t\t*data_p = (c0 >> 3) & 0x0f;\n\t\twrite_data (dev, 0x10);  \n\t\t*ns_p = PLIP_NB_1;\n\t\tfallthrough;\n\n\tcase PLIP_NB_1:\n\t\tcx = nibble_timeout;\n\t\twhile (1) {\n\t\t\tc0 = read_status(dev);\n\t\t\tudelay(PLIP_DELAY_UNIT);\n\t\t\tif (c0 & 0x80) {\n\t\t\t\tc1 = read_status(dev);\n\t\t\t\tif (c0 == c1)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (--cx == 0)\n\t\t\t\treturn TIMEOUT;\n\t\t}\n\t\t*data_p |= (c0 << 1) & 0xf0;\n\t\twrite_data (dev, 0x00);  \n\t\t*ns_p = PLIP_NB_BEGIN;\n\t\tbreak;\n\tcase PLIP_NB_2:\n\t\tbreak;\n\t}\n\treturn OK;\n}\n\n \n\nstatic __be16 plip_type_trans(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ethhdr *eth;\n\tunsigned char *rawp;\n\n\tskb_reset_mac_header(skb);\n\tskb_pull(skb,dev->hard_header_len);\n\teth = eth_hdr(skb);\n\n\tif(is_multicast_ether_addr(eth->h_dest))\n\t{\n\t\tif(ether_addr_equal_64bits(eth->h_dest, dev->broadcast))\n\t\t\tskb->pkt_type=PACKET_BROADCAST;\n\t\telse\n\t\t\tskb->pkt_type=PACKET_MULTICAST;\n\t}\n\n\t \n\n\tif (ntohs(eth->h_proto) >= ETH_P_802_3_MIN)\n\t\treturn eth->h_proto;\n\n\trawp = skb->data;\n\n\t \n\tif (*(unsigned short *)rawp == 0xFFFF)\n\t\treturn htons(ETH_P_802_3);\n\n\t \n\treturn htons(ETH_P_802_2);\n}\n\n \nstatic int\nplip_receive_packet(struct net_device *dev, struct net_local *nl,\n\t\t    struct plip_local *snd, struct plip_local *rcv)\n{\n\tunsigned short nibble_timeout = nl->nibble;\n\tunsigned char *lbuf;\n\n\tswitch (rcv->state) {\n\tcase PLIP_PK_TRIGGER:\n\t\tDISABLE(dev->irq);\n\t\t \n\t\tdisable_parport_interrupts (dev);\n\t\twrite_data (dev, 0x01);  \n\t\tif (net_debug > 2)\n\t\t\tprintk(KERN_DEBUG \"%s: receive start\\n\", dev->name);\n\t\trcv->state = PLIP_PK_LENGTH_LSB;\n\t\trcv->nibble = PLIP_NB_BEGIN;\n\t\tfallthrough;\n\n\tcase PLIP_PK_LENGTH_LSB:\n\t\tif (snd->state != PLIP_PK_DONE) {\n\t\t\tif (plip_receive(nl->trigger, dev,\n\t\t\t\t\t &rcv->nibble, &rcv->length.b.lsb)) {\n\t\t\t\t \n\t\t\t\trcv->state = PLIP_PK_DONE;\n\t\t\t\tnl->is_deferred = 1;\n\t\t\t\tnl->connection = PLIP_CN_SEND;\n\t\t\t\tschedule_delayed_work(&nl->deferred, 1);\n\t\t\t\tenable_parport_interrupts (dev);\n\t\t\t\tENABLE(dev->irq);\n\t\t\t\treturn OK;\n\t\t\t}\n\t\t} else {\n\t\t\tif (plip_receive(nibble_timeout, dev,\n\t\t\t\t\t &rcv->nibble, &rcv->length.b.lsb))\n\t\t\t\treturn TIMEOUT;\n\t\t}\n\t\trcv->state = PLIP_PK_LENGTH_MSB;\n\t\tfallthrough;\n\n\tcase PLIP_PK_LENGTH_MSB:\n\t\tif (plip_receive(nibble_timeout, dev,\n\t\t\t\t &rcv->nibble, &rcv->length.b.msb))\n\t\t\treturn TIMEOUT;\n\t\tif (rcv->length.h > dev->mtu + dev->hard_header_len ||\n\t\t    rcv->length.h < 8) {\n\t\t\tprintk(KERN_WARNING \"%s: bogus packet size %d.\\n\", dev->name, rcv->length.h);\n\t\t\treturn ERROR;\n\t\t}\n\t\t \n\t\trcv->skb = dev_alloc_skb(rcv->length.h + 2);\n\t\tif (rcv->skb == NULL) {\n\t\t\tprintk(KERN_ERR \"%s: Memory squeeze.\\n\", dev->name);\n\t\t\treturn ERROR;\n\t\t}\n\t\tskb_reserve(rcv->skb, 2);\t \n\t\tskb_put(rcv->skb,rcv->length.h);\n\t\trcv->skb->dev = dev;\n\t\trcv->state = PLIP_PK_DATA;\n\t\trcv->byte = 0;\n\t\trcv->checksum = 0;\n\t\tfallthrough;\n\n\tcase PLIP_PK_DATA:\n\t\tlbuf = rcv->skb->data;\n\t\tdo {\n\t\t\tif (plip_receive(nibble_timeout, dev,\n\t\t\t\t\t &rcv->nibble, &lbuf[rcv->byte]))\n\t\t\t\treturn TIMEOUT;\n\t\t} while (++rcv->byte < rcv->length.h);\n\t\tdo {\n\t\t\trcv->checksum += lbuf[--rcv->byte];\n\t\t} while (rcv->byte);\n\t\trcv->state = PLIP_PK_CHECKSUM;\n\t\tfallthrough;\n\n\tcase PLIP_PK_CHECKSUM:\n\t\tif (plip_receive(nibble_timeout, dev,\n\t\t\t\t &rcv->nibble, &rcv->data))\n\t\t\treturn TIMEOUT;\n\t\tif (rcv->data != rcv->checksum) {\n\t\t\tdev->stats.rx_crc_errors++;\n\t\t\tif (net_debug)\n\t\t\t\tprintk(KERN_DEBUG \"%s: checksum error\\n\", dev->name);\n\t\t\treturn ERROR;\n\t\t}\n\t\trcv->state = PLIP_PK_DONE;\n\t\tfallthrough;\n\n\tcase PLIP_PK_DONE:\n\t\t \n\t\trcv->skb->protocol=plip_type_trans(rcv->skb, dev);\n\t\tnetif_rx(rcv->skb);\n\t\tdev->stats.rx_bytes += rcv->length.h;\n\t\tdev->stats.rx_packets++;\n\t\trcv->skb = NULL;\n\t\tif (net_debug > 2)\n\t\t\tprintk(KERN_DEBUG \"%s: receive end\\n\", dev->name);\n\n\t\t \n\t\twrite_data (dev, 0x00);\n\t\tspin_lock_irq(&nl->lock);\n\t\tif (snd->state != PLIP_PK_DONE) {\n\t\t\tnl->connection = PLIP_CN_SEND;\n\t\t\tspin_unlock_irq(&nl->lock);\n\t\t\tschedule_work(&nl->immediate);\n\t\t\tenable_parport_interrupts (dev);\n\t\t\tENABLE(dev->irq);\n\t\t\treturn OK;\n\t\t} else {\n\t\t\tnl->connection = PLIP_CN_NONE;\n\t\t\tspin_unlock_irq(&nl->lock);\n\t\t\tenable_parport_interrupts (dev);\n\t\t\tENABLE(dev->irq);\n\t\t\treturn OK;\n\t\t}\n\t}\n\treturn OK;\n}\n\n \nstatic inline int\nplip_send(unsigned short nibble_timeout, struct net_device *dev,\n\t  enum plip_nibble_state *ns_p, unsigned char data)\n{\n\tunsigned char c0;\n\tunsigned int cx;\n\n\tswitch (*ns_p) {\n\tcase PLIP_NB_BEGIN:\n\t\twrite_data (dev, data & 0x0f);\n\t\t*ns_p = PLIP_NB_1;\n\t\tfallthrough;\n\n\tcase PLIP_NB_1:\n\t\twrite_data (dev, 0x10 | (data & 0x0f));\n\t\tcx = nibble_timeout;\n\t\twhile (1) {\n\t\t\tc0 = read_status(dev);\n\t\t\tif ((c0 & 0x80) == 0)\n\t\t\t\tbreak;\n\t\t\tif (--cx == 0)\n\t\t\t\treturn TIMEOUT;\n\t\t\tudelay(PLIP_DELAY_UNIT);\n\t\t}\n\t\twrite_data (dev, 0x10 | (data >> 4));\n\t\t*ns_p = PLIP_NB_2;\n\t\tfallthrough;\n\n\tcase PLIP_NB_2:\n\t\twrite_data (dev, (data >> 4));\n\t\tcx = nibble_timeout;\n\t\twhile (1) {\n\t\t\tc0 = read_status(dev);\n\t\t\tif (c0 & 0x80)\n\t\t\t\tbreak;\n\t\t\tif (--cx == 0)\n\t\t\t\treturn TIMEOUT;\n\t\t\tudelay(PLIP_DELAY_UNIT);\n\t\t}\n\t\t*ns_p = PLIP_NB_BEGIN;\n\t\treturn OK;\n\t}\n\treturn OK;\n}\n\n \nstatic int\nplip_send_packet(struct net_device *dev, struct net_local *nl,\n\t\t struct plip_local *snd, struct plip_local *rcv)\n{\n\tunsigned short nibble_timeout = nl->nibble;\n\tunsigned char *lbuf;\n\tunsigned char c0;\n\tunsigned int cx;\n\n\tif (snd->skb == NULL || (lbuf = snd->skb->data) == NULL) {\n\t\tprintk(KERN_DEBUG \"%s: send skb lost\\n\", dev->name);\n\t\tsnd->state = PLIP_PK_DONE;\n\t\tsnd->skb = NULL;\n\t\treturn ERROR;\n\t}\n\n\tswitch (snd->state) {\n\tcase PLIP_PK_TRIGGER:\n\t\tif ((read_status(dev) & 0xf8) != 0x80)\n\t\t\treturn HS_TIMEOUT;\n\n\t\t \n\t\twrite_data (dev, 0x08);\n\t\tcx = nl->trigger;\n\t\twhile (1) {\n\t\t\tudelay(PLIP_DELAY_UNIT);\n\t\t\tspin_lock_irq(&nl->lock);\n\t\t\tif (nl->connection == PLIP_CN_RECEIVE) {\n\t\t\t\tspin_unlock_irq(&nl->lock);\n\t\t\t\t \n\t\t\t\tdev->stats.collisions++;\n\t\t\t\treturn OK;\n\t\t\t}\n\t\t\tc0 = read_status(dev);\n\t\t\tif (c0 & 0x08) {\n\t\t\t\tspin_unlock_irq(&nl->lock);\n\t\t\t\tDISABLE(dev->irq);\n\t\t\t\tsynchronize_irq(dev->irq);\n\t\t\t\tif (nl->connection == PLIP_CN_RECEIVE) {\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t\tENABLE(dev->irq);\n\t\t\t\t\tdev->stats.collisions++;\n\t\t\t\t\treturn OK;\n\t\t\t\t}\n\t\t\t\tdisable_parport_interrupts (dev);\n\t\t\t\tif (net_debug > 2)\n\t\t\t\t\tprintk(KERN_DEBUG \"%s: send start\\n\", dev->name);\n\t\t\t\tsnd->state = PLIP_PK_LENGTH_LSB;\n\t\t\t\tsnd->nibble = PLIP_NB_BEGIN;\n\t\t\t\tnl->timeout_count = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock_irq(&nl->lock);\n\t\t\tif (--cx == 0) {\n\t\t\t\twrite_data (dev, 0x00);\n\t\t\t\treturn HS_TIMEOUT;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase PLIP_PK_LENGTH_LSB:\n\t\tif (plip_send(nibble_timeout, dev,\n\t\t\t      &snd->nibble, snd->length.b.lsb))\n\t\t\treturn TIMEOUT;\n\t\tsnd->state = PLIP_PK_LENGTH_MSB;\n\t\tfallthrough;\n\n\tcase PLIP_PK_LENGTH_MSB:\n\t\tif (plip_send(nibble_timeout, dev,\n\t\t\t      &snd->nibble, snd->length.b.msb))\n\t\t\treturn TIMEOUT;\n\t\tsnd->state = PLIP_PK_DATA;\n\t\tsnd->byte = 0;\n\t\tsnd->checksum = 0;\n\t\tfallthrough;\n\n\tcase PLIP_PK_DATA:\n\t\tdo {\n\t\t\tif (plip_send(nibble_timeout, dev,\n\t\t\t\t      &snd->nibble, lbuf[snd->byte]))\n\t\t\t\treturn TIMEOUT;\n\t\t} while (++snd->byte < snd->length.h);\n\t\tdo {\n\t\t\tsnd->checksum += lbuf[--snd->byte];\n\t\t} while (snd->byte);\n\t\tsnd->state = PLIP_PK_CHECKSUM;\n\t\tfallthrough;\n\n\tcase PLIP_PK_CHECKSUM:\n\t\tif (plip_send(nibble_timeout, dev,\n\t\t\t      &snd->nibble, snd->checksum))\n\t\t\treturn TIMEOUT;\n\n\t\tdev->stats.tx_bytes += snd->skb->len;\n\t\tdev_kfree_skb(snd->skb);\n\t\tdev->stats.tx_packets++;\n\t\tsnd->state = PLIP_PK_DONE;\n\t\tfallthrough;\n\n\tcase PLIP_PK_DONE:\n\t\t \n\t\twrite_data (dev, 0x00);\n\t\tsnd->skb = NULL;\n\t\tif (net_debug > 2)\n\t\t\tprintk(KERN_DEBUG \"%s: send end\\n\", dev->name);\n\t\tnl->connection = PLIP_CN_CLOSING;\n\t\tnl->is_deferred = 1;\n\t\tschedule_delayed_work(&nl->deferred, 1);\n\t\tenable_parport_interrupts (dev);\n\t\tENABLE(dev->irq);\n\t\treturn OK;\n\t}\n\treturn OK;\n}\n\nstatic int\nplip_connection_close(struct net_device *dev, struct net_local *nl,\n\t\t      struct plip_local *snd, struct plip_local *rcv)\n{\n\tspin_lock_irq(&nl->lock);\n\tif (nl->connection == PLIP_CN_CLOSING) {\n\t\tnl->connection = PLIP_CN_NONE;\n\t\tnetif_wake_queue (dev);\n\t}\n\tspin_unlock_irq(&nl->lock);\n\tif (nl->should_relinquish) {\n\t\tnl->should_relinquish = nl->port_owner = 0;\n\t\tparport_release(nl->pardev);\n\t}\n\treturn OK;\n}\n\n \nstatic int\nplip_error(struct net_device *dev, struct net_local *nl,\n\t   struct plip_local *snd, struct plip_local *rcv)\n{\n\tunsigned char status;\n\n\tstatus = read_status(dev);\n\tif ((status & 0xf8) == 0x80) {\n\t\tif (net_debug > 2)\n\t\t\tprintk(KERN_DEBUG \"%s: reset interface.\\n\", dev->name);\n\t\tnl->connection = PLIP_CN_NONE;\n\t\tnl->should_relinquish = 0;\n\t\tnetif_start_queue (dev);\n\t\tenable_parport_interrupts (dev);\n\t\tENABLE(dev->irq);\n\t\tnetif_wake_queue (dev);\n\t} else {\n\t\tnl->is_deferred = 1;\n\t\tschedule_delayed_work(&nl->deferred, 1);\n\t}\n\n\treturn OK;\n}\n\n \nstatic void\nplip_interrupt(void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct net_local *nl;\n\tstruct plip_local *rcv;\n\tunsigned char c0;\n\tunsigned long flags;\n\n\tnl = netdev_priv(dev);\n\trcv = &nl->rcv_data;\n\n\tspin_lock_irqsave (&nl->lock, flags);\n\n\tc0 = read_status(dev);\n\tif ((c0 & 0xf8) != 0xc0) {\n\t\tif ((dev->irq != -1) && (net_debug > 1))\n\t\t\tprintk(KERN_DEBUG \"%s: spurious interrupt\\n\", dev->name);\n\t\tspin_unlock_irqrestore (&nl->lock, flags);\n\t\treturn;\n\t}\n\n\tif (net_debug > 3)\n\t\tprintk(KERN_DEBUG \"%s: interrupt.\\n\", dev->name);\n\n\tswitch (nl->connection) {\n\tcase PLIP_CN_CLOSING:\n\t\tnetif_wake_queue (dev);\n\t\tfallthrough;\n\tcase PLIP_CN_NONE:\n\tcase PLIP_CN_SEND:\n\t\trcv->state = PLIP_PK_TRIGGER;\n\t\tnl->connection = PLIP_CN_RECEIVE;\n\t\tnl->timeout_count = 0;\n\t\tschedule_work(&nl->immediate);\n\t\tbreak;\n\n\tcase PLIP_CN_RECEIVE:\n\t\t \n\t\tbreak;\n\n\tcase PLIP_CN_ERROR:\n\t\tprintk(KERN_ERR \"%s: receive interrupt in error state\\n\", dev->name);\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&nl->lock, flags);\n}\n\nstatic netdev_tx_t\nplip_tx_packet(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct net_local *nl = netdev_priv(dev);\n\tstruct plip_local *snd = &nl->snd_data;\n\n\tif (netif_queue_stopped(dev))\n\t\treturn NETDEV_TX_BUSY;\n\n\t \n\tif (!nl->port_owner) {\n\t\tif (parport_claim(nl->pardev))\n\t\t\treturn NETDEV_TX_BUSY;\n\t\tnl->port_owner = 1;\n\t}\n\n\tnetif_stop_queue (dev);\n\n\tif (skb->len > dev->mtu + dev->hard_header_len) {\n\t\tprintk(KERN_WARNING \"%s: packet too big, %d.\\n\", dev->name, (int)skb->len);\n\t\tnetif_start_queue (dev);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tif (net_debug > 2)\n\t\tprintk(KERN_DEBUG \"%s: send request\\n\", dev->name);\n\n\tspin_lock_irq(&nl->lock);\n\tsnd->skb = skb;\n\tsnd->length.h = skb->len;\n\tsnd->state = PLIP_PK_TRIGGER;\n\tif (nl->connection == PLIP_CN_NONE) {\n\t\tnl->connection = PLIP_CN_SEND;\n\t\tnl->timeout_count = 0;\n\t}\n\tschedule_work(&nl->immediate);\n\tspin_unlock_irq(&nl->lock);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void\nplip_rewrite_address(const struct net_device *dev, struct ethhdr *eth)\n{\n\tconst struct in_device *in_dev;\n\n\trcu_read_lock();\n\tin_dev = __in_dev_get_rcu(dev);\n\tif (in_dev) {\n\t\t \n\t\tconst struct in_ifaddr *ifa = rcu_dereference(in_dev->ifa_list);\n\t\tif (ifa) {\n\t\t\tmemcpy(eth->h_source, dev->dev_addr, ETH_ALEN);\n\t\t\tmemset(eth->h_dest, 0xfc, 2);\n\t\t\tmemcpy(eth->h_dest+2, &ifa->ifa_address, 4);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\nstatic int\nplip_hard_header(struct sk_buff *skb, struct net_device *dev,\n\t\t unsigned short type, const void *daddr,\n\t\t const void *saddr, unsigned len)\n{\n\tint ret;\n\n\tret = eth_header(skb, dev, type, daddr, saddr, len);\n\tif (ret >= 0)\n\t\tplip_rewrite_address (dev, (struct ethhdr *)skb->data);\n\n\treturn ret;\n}\n\nstatic int plip_hard_header_cache(const struct neighbour *neigh,\n\t\t\t\t  struct hh_cache *hh, __be16 type)\n{\n\tint ret;\n\n\tret = eth_header_cache(neigh, hh, type);\n\tif (ret == 0) {\n\t\tstruct ethhdr *eth;\n\n\t\teth = (struct ethhdr*)(((u8*)hh->hh_data) +\n\t\t\t\t       HH_DATA_OFF(sizeof(*eth)));\n\t\tplip_rewrite_address (neigh->dev, eth);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int\nplip_open(struct net_device *dev)\n{\n\tstruct net_local *nl = netdev_priv(dev);\n\tstruct in_device *in_dev;\n\n\t \n\tif (!nl->port_owner) {\n\t\tif (parport_claim(nl->pardev)) return -EAGAIN;\n\t\tnl->port_owner = 1;\n\t}\n\n\tnl->should_relinquish = 0;\n\n\t \n\twrite_data (dev, 0x00);\n\n\t \n\tenable_parport_interrupts (dev);\n\tif (dev->irq == -1)\n\t{\n\t\tatomic_set (&nl->kill_timer, 0);\n\t\tschedule_delayed_work(&nl->timer, 1);\n\t}\n\n\t \n\tnl->rcv_data.state = nl->snd_data.state = PLIP_PK_DONE;\n\tnl->rcv_data.skb = nl->snd_data.skb = NULL;\n\tnl->connection = PLIP_CN_NONE;\n\tnl->is_deferred = 0;\n\n\t \n\n\tin_dev=__in_dev_get_rtnl(dev);\n\tif (in_dev) {\n\t\t \n\t\tconst struct in_ifaddr *ifa = rtnl_dereference(in_dev->ifa_list);\n\t\tif (ifa != NULL) {\n\t\t\tdev_addr_mod(dev, 2, &ifa->ifa_local, 4);\n\t\t}\n\t}\n\n\tnetif_start_queue (dev);\n\n\treturn 0;\n}\n\n \nstatic int\nplip_close(struct net_device *dev)\n{\n\tstruct net_local *nl = netdev_priv(dev);\n\tstruct plip_local *snd = &nl->snd_data;\n\tstruct plip_local *rcv = &nl->rcv_data;\n\n\tnetif_stop_queue (dev);\n\tDISABLE(dev->irq);\n\tsynchronize_irq(dev->irq);\n\n\tif (dev->irq == -1)\n\t{\n\t\tinit_completion(&nl->killed_timer_cmp);\n\t\tatomic_set (&nl->kill_timer, 1);\n\t\twait_for_completion(&nl->killed_timer_cmp);\n\t}\n\n#ifdef NOTDEF\n\toutb(0x00, PAR_DATA(dev));\n#endif\n\tnl->is_deferred = 0;\n\tnl->connection = PLIP_CN_NONE;\n\tif (nl->port_owner) {\n\t\tparport_release(nl->pardev);\n\t\tnl->port_owner = 0;\n\t}\n\n\tsnd->state = PLIP_PK_DONE;\n\tif (snd->skb) {\n\t\tdev_kfree_skb(snd->skb);\n\t\tsnd->skb = NULL;\n\t}\n\trcv->state = PLIP_PK_DONE;\n\tif (rcv->skb) {\n\t\tkfree_skb(rcv->skb);\n\t\trcv->skb = NULL;\n\t}\n\n#ifdef NOTDEF\n\t \n\toutb(0x00, PAR_CONTROL(dev));\n#endif\n\treturn 0;\n}\n\nstatic int\nplip_preempt(void *handle)\n{\n\tstruct net_device *dev = (struct net_device *)handle;\n\tstruct net_local *nl = netdev_priv(dev);\n\n\t \n\tif (nl->connection != PLIP_CN_NONE) {\n\t\tnl->should_relinquish = 1;\n\t\treturn 1;\n\t}\n\n\tnl->port_owner = 0;\t \n\treturn 0;\n}\n\nstatic void\nplip_wakeup(void *handle)\n{\n\tstruct net_device *dev = (struct net_device *)handle;\n\tstruct net_local *nl = netdev_priv(dev);\n\n\tif (nl->port_owner) {\n\t\t \n\t\tprintk(KERN_DEBUG \"%s: why am I being woken up?\\n\", dev->name);\n\t\tif (!parport_claim(nl->pardev))\n\t\t\t \n\t\t\tprintk(KERN_DEBUG \"%s: I'm broken.\\n\", dev->name);\n\t\telse\n\t\t\treturn;\n\t}\n\n\tif (!(dev->flags & IFF_UP))\n\t\t \n\t\treturn;\n\n\tif (!parport_claim(nl->pardev)) {\n\t\tnl->port_owner = 1;\n\t\t \n\t\twrite_data (dev, 0x00);\n\t}\n}\n\nstatic int\nplip_siocdevprivate(struct net_device *dev, struct ifreq *rq,\n\t\t    void __user *data, int cmd)\n{\n\tstruct net_local *nl = netdev_priv(dev);\n\tstruct plipconf *pc = (struct plipconf *) &rq->ifr_ifru;\n\n\tif (cmd != SIOCDEVPLIP)\n\t\treturn -EOPNOTSUPP;\n\n\tif (in_compat_syscall())\n\t\treturn -EOPNOTSUPP;\n\n\tswitch(pc->pcmd) {\n\tcase PLIP_GET_TIMEOUT:\n\t\tpc->trigger = nl->trigger;\n\t\tpc->nibble  = nl->nibble;\n\t\tbreak;\n\tcase PLIP_SET_TIMEOUT:\n\t\tif(!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tnl->trigger = pc->trigger;\n\t\tnl->nibble  = pc->nibble;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int parport[PLIP_MAX] = { [0 ... PLIP_MAX-1] = -1 };\nstatic int timid;\n\nmodule_param_array(parport, int, NULL, 0);\nmodule_param(timid, int, 0);\nMODULE_PARM_DESC(parport, \"List of parport device numbers to use by plip\");\n\nstatic struct net_device *dev_plip[PLIP_MAX] = { NULL, };\n\nstatic inline int\nplip_searchfor(int list[], int a)\n{\n\tint i;\n\tfor (i = 0; i < PLIP_MAX && list[i] != -1; i++) {\n\t\tif (list[i] == a) return 1;\n\t}\n\treturn 0;\n}\n\n \nstatic void plip_attach (struct parport *port)\n{\n\tstatic int unit;\n\tstruct net_device *dev;\n\tstruct net_local *nl;\n\tchar name[IFNAMSIZ];\n\tstruct pardev_cb plip_cb;\n\n\tif ((parport[0] == -1 && (!timid || !port->devices)) ||\n\t    plip_searchfor(parport, port->number)) {\n\t\tif (unit == PLIP_MAX) {\n\t\t\tprintk(KERN_ERR \"plip: too many devices\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tsprintf(name, \"plip%d\", unit);\n\t\tdev = alloc_etherdev(sizeof(struct net_local));\n\t\tif (!dev)\n\t\t\treturn;\n\n\t\tstrcpy(dev->name, name);\n\n\t\tdev->irq = port->irq;\n\t\tdev->base_addr = port->base;\n\t\tif (port->irq == -1) {\n\t\t\tprintk(KERN_INFO \"plip: %s has no IRQ. Using IRQ-less mode,\"\n\t\t                 \"which is fairly inefficient!\\n\", port->name);\n\t\t}\n\n\t\tnl = netdev_priv(dev);\n\t\tnl->dev = dev;\n\n\t\tmemset(&plip_cb, 0, sizeof(plip_cb));\n\t\tplip_cb.private = dev;\n\t\tplip_cb.preempt = plip_preempt;\n\t\tplip_cb.wakeup = plip_wakeup;\n\t\tplip_cb.irq_func = plip_interrupt;\n\n\t\tnl->pardev = parport_register_dev_model(port, dev->name,\n\t\t\t\t\t\t\t&plip_cb, unit);\n\n\t\tif (!nl->pardev) {\n\t\t\tprintk(KERN_ERR \"%s: parport_register failed\\n\", name);\n\t\t\tgoto err_free_dev;\n\t\t}\n\n\t\tplip_init_netdev(dev);\n\n\t\tif (register_netdev(dev)) {\n\t\t\tprintk(KERN_ERR \"%s: network register failed\\n\", name);\n\t\t\tgoto err_parport_unregister;\n\t\t}\n\n\t\tprintk(KERN_INFO \"%s\", version);\n\t\tif (dev->irq != -1)\n\t\t\tprintk(KERN_INFO \"%s: Parallel port at %#3lx, \"\n\t\t\t\t\t \"using IRQ %d.\\n\",\n\t\t\t\t         dev->name, dev->base_addr, dev->irq);\n\t\telse\n\t\t\tprintk(KERN_INFO \"%s: Parallel port at %#3lx, \"\n\t\t\t\t\t \"not using IRQ.\\n\",\n\t\t\t\t\t dev->name, dev->base_addr);\n\t\tdev_plip[unit++] = dev;\n\t}\n\treturn;\n\nerr_parport_unregister:\n\tparport_unregister_device(nl->pardev);\nerr_free_dev:\n\tfree_netdev(dev);\n}\n\n \nstatic void plip_detach (struct parport *port)\n{\n\t \n}\n\nstatic int plip_probe(struct pardevice *par_dev)\n{\n\tstruct device_driver *drv = par_dev->dev.driver;\n\tint len = strlen(drv->name);\n\n\tif (strncmp(par_dev->name, drv->name, len))\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic struct parport_driver plip_driver = {\n\t.name\t\t= \"plip\",\n\t.probe\t\t= plip_probe,\n\t.match_port\t= plip_attach,\n\t.detach\t\t= plip_detach,\n\t.devmodel\t= true,\n};\n\nstatic void __exit plip_cleanup_module (void)\n{\n\tstruct net_device *dev;\n\tint i;\n\n\tfor (i=0; i < PLIP_MAX; i++) {\n\t\tif ((dev = dev_plip[i])) {\n\t\t\tstruct net_local *nl = netdev_priv(dev);\n\t\t\tunregister_netdev(dev);\n\t\t\tif (nl->port_owner)\n\t\t\t\tparport_release(nl->pardev);\n\t\t\tparport_unregister_device(nl->pardev);\n\t\t\tfree_netdev(dev);\n\t\t\tdev_plip[i] = NULL;\n\t\t}\n\t}\n\n\tparport_unregister_driver(&plip_driver);\n}\n\n#ifndef MODULE\n\nstatic int parport_ptr;\n\nstatic int __init plip_setup(char *str)\n{\n\tint ints[4];\n\n\tstr = get_options(str, ARRAY_SIZE(ints), ints);\n\n\t \n\tif (!strncmp(str, \"parport\", 7)) {\n\t\tint n = simple_strtoul(str+7, NULL, 10);\n\t\tif (parport_ptr < PLIP_MAX)\n\t\t\tparport[parport_ptr++] = n;\n\t\telse\n\t\t\tprintk(KERN_INFO \"plip: too many ports, %s ignored.\\n\",\n\t\t\t       str);\n\t} else if (!strcmp(str, \"timid\")) {\n\t\ttimid = 1;\n\t} else {\n\t\tif (ints[0] == 0 || ints[1] == 0) {\n\t\t\t \n\t\t\tparport[0] = -2;\n\t\t} else {\n\t\t\tprintk(KERN_WARNING \"warning: 'plip=0x%x' ignored\\n\",\n\t\t\t       ints[1]);\n\t\t}\n\t}\n\treturn 1;\n}\n\n__setup(\"plip=\", plip_setup);\n\n#endif  \n\nstatic int __init plip_init (void)\n{\n\tif (parport[0] == -2)\n\t\treturn 0;\n\n\tif (parport[0] != -1 && timid) {\n\t\tprintk(KERN_WARNING \"plip: warning, ignoring `timid' since specific ports given.\\n\");\n\t\ttimid = 0;\n\t}\n\n\tif (parport_register_driver (&plip_driver)) {\n\t\tprintk (KERN_WARNING \"plip: couldn't register driver\\n\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nmodule_init(plip_init);\nmodule_exit(plip_cleanup_module);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}