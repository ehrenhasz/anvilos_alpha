{
  "module_name": "softing_fw.c",
  "hash_id": "ec573a6b22d6ca0b50df2b0d5811d5ad16e27638b74d19b2946626cb5a90e532",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/softing/softing_fw.c",
  "human_readable_source": "\n \n\n#include <linux/firmware.h>\n#include <linux/sched/signal.h>\n#include <asm/div64.h>\n#include <asm/io.h>\n\n#include \"softing.h\"\n\n \nstatic int _softing_fct_cmd(struct softing *card, int16_t cmd, uint16_t vector,\n\t\tconst char *msg)\n{\n\tint ret;\n\tunsigned long stamp;\n\n\tiowrite16(cmd, &card->dpram[DPRAM_FCT_PARAM]);\n\tiowrite8(vector >> 8, &card->dpram[DPRAM_FCT_HOST + 1]);\n\tiowrite8(vector, &card->dpram[DPRAM_FCT_HOST]);\n\t \n\twmb();\n\tstamp = jiffies + 1 * HZ;\n\t \n\tdo {\n\t\t \n\t\tret = ioread8(&card->dpram[DPRAM_FCT_HOST]) +\n\t\t\t(ioread8(&card->dpram[DPRAM_FCT_HOST + 1]) << 8);\n\t\t \n\t\trmb();\n\t\tif (ret == RES_OK)\n\t\t\t \n\t\t\treturn ioread16(&card->dpram[DPRAM_FCT_RESULT]);\n\n\t\tif ((ret != vector) || time_after(jiffies, stamp))\n\t\t\tbreak;\n\t\t \n\t\tusleep_range(500, 10000);\n\t} while (1);\n\n\tret = (ret == RES_NONE) ? -ETIMEDOUT : -ECANCELED;\n\tdev_alert(&card->pdev->dev, \"firmware %s failed (%i)\\n\", msg, ret);\n\treturn ret;\n}\n\nstatic int softing_fct_cmd(struct softing *card, int16_t cmd, const char *msg)\n{\n\tint ret;\n\n\tret = _softing_fct_cmd(card, cmd, 0, msg);\n\tif (ret > 0) {\n\t\tdev_alert(&card->pdev->dev, \"%s returned %u\\n\", msg, ret);\n\t\tret = -EIO;\n\t}\n\treturn ret;\n}\n\nint softing_bootloader_command(struct softing *card, int16_t cmd,\n\t\tconst char *msg)\n{\n\tint ret;\n\tunsigned long stamp;\n\n\tiowrite16(RES_NONE, &card->dpram[DPRAM_RECEIPT]);\n\tiowrite16(cmd, &card->dpram[DPRAM_COMMAND]);\n\t \n\twmb();\n\tstamp = jiffies + 3 * HZ;\n\t \n\tdo {\n\t\tret = ioread16(&card->dpram[DPRAM_RECEIPT]);\n\t\t \n\t\trmb();\n\t\tif (ret == RES_OK)\n\t\t\treturn 0;\n\t\tif (time_after(jiffies, stamp))\n\t\t\tbreak;\n\t\t \n\t\tusleep_range(500, 10000);\n\t} while (!signal_pending(current));\n\n\tret = (ret == RES_NONE) ? -ETIMEDOUT : -ECANCELED;\n\tdev_alert(&card->pdev->dev, \"bootloader %s failed (%i)\\n\", msg, ret);\n\treturn ret;\n}\n\nstatic int fw_parse(const uint8_t **pmem, uint16_t *ptype, uint32_t *paddr,\n\t\tuint16_t *plen, const uint8_t **pdat)\n{\n\tuint16_t checksum[2];\n\tconst uint8_t *mem;\n\tconst uint8_t *end;\n\n\t \n\tmem = *pmem;\n\t*ptype = le16_to_cpup((void *)&mem[0]);\n\t*paddr = le32_to_cpup((void *)&mem[2]);\n\t*plen = le16_to_cpup((void *)&mem[6]);\n\t*pdat = &mem[8];\n\t \n\tend = &mem[8 + *plen];\n\tchecksum[0] = le16_to_cpup((void *)end);\n\tfor (checksum[1] = 0; mem < end; ++mem)\n\t\tchecksum[1] += *mem;\n\tif (checksum[0] != checksum[1])\n\t\treturn -EINVAL;\n\t \n\t*pmem += 10 + *plen;\n\treturn 0;\n}\n\nint softing_load_fw(const char *file, struct softing *card,\n\t\t__iomem uint8_t *dpram, unsigned int size, int offset)\n{\n\tconst struct firmware *fw;\n\tint ret;\n\tconst uint8_t *mem, *end, *dat;\n\tuint16_t type, len;\n\tuint32_t addr;\n\tuint8_t *buf = NULL, *new_buf;\n\tint buflen = 0;\n\tint8_t type_end = 0;\n\n\tret = request_firmware(&fw, file, &card->pdev->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\tdev_dbg(&card->pdev->dev, \"%s, firmware(%s) got %u bytes\"\n\t\t\", offset %c0x%04x\\n\",\n\t\tcard->pdat->name, file, (unsigned int)fw->size,\n\t\t(offset >= 0) ? '+' : '-', (unsigned int)abs(offset));\n\t \n\tmem = fw->data;\n\tend = &mem[fw->size];\n\t \n\tret = fw_parse(&mem, &type, &addr, &len, &dat);\n\tif (ret < 0)\n\t\tgoto failed;\n\tif (type != 0xffff)\n\t\tgoto failed;\n\tif (strncmp(\"Structured Binary Format, Softing GmbH\" , dat, len)) {\n\t\tret = -EINVAL;\n\t\tgoto failed;\n\t}\n\t \n\twhile (mem < end) {\n\t\tret = fw_parse(&mem, &type, &addr, &len, &dat);\n\t\tif (ret < 0)\n\t\t\tgoto failed;\n\t\tif (type == 3) {\n\t\t\t \n\t\t\tcontinue;\n\t\t} else if (type == 1) {\n\t\t\t \n\t\t\ttype_end = 1;\n\t\t\tbreak;\n\t\t} else if (type != 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif ((addr + len + offset) > size)\n\t\t\tgoto failed;\n\t\tmemcpy_toio(&dpram[addr + offset], dat, len);\n\t\t \n\t\tmb();\n\t\tif (len > buflen) {\n\t\t\t \n\t\t\tbuflen = (len + (1024-1)) & ~(1024-1);\n\t\t\tnew_buf = krealloc(buf, buflen, GFP_KERNEL);\n\t\t\tif (!new_buf) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto failed;\n\t\t\t}\n\t\t\tbuf = new_buf;\n\t\t}\n\t\t \n\t\tmemcpy_fromio(buf, &dpram[addr + offset], len);\n\t\tif (memcmp(buf, dat, len)) {\n\t\t\t \n\t\t\tdev_alert(&card->pdev->dev, \"DPRAM readback failed\\n\");\n\t\t\tret = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\t}\n\tif (!type_end)\n\t\t \n\t\tgoto failed;\n\tret = 0;\nfailed:\n\tkfree(buf);\n\trelease_firmware(fw);\n\tif (ret < 0)\n\t\tdev_info(&card->pdev->dev, \"firmware %s failed\\n\", file);\n\treturn ret;\n}\n\nint softing_load_app_fw(const char *file, struct softing *card)\n{\n\tconst struct firmware *fw;\n\tconst uint8_t *mem, *end, *dat;\n\tint ret, j;\n\tuint16_t type, len;\n\tuint32_t addr, start_addr = 0;\n\tunsigned int sum, rx_sum;\n\tint8_t type_end = 0, type_entrypoint = 0;\n\n\tret = request_firmware(&fw, file, &card->pdev->dev);\n\tif (ret) {\n\t\tdev_alert(&card->pdev->dev, \"request_firmware(%s) got %i\\n\",\n\t\t\tfile, ret);\n\t\treturn ret;\n\t}\n\tdev_dbg(&card->pdev->dev, \"firmware(%s) got %lu bytes\\n\",\n\t\tfile, (unsigned long)fw->size);\n\t \n\tmem = fw->data;\n\tend = &mem[fw->size];\n\t \n\tret = fw_parse(&mem, &type, &addr, &len, &dat);\n\tif (ret)\n\t\tgoto failed;\n\tret = -EINVAL;\n\tif (type != 0xffff) {\n\t\tdev_alert(&card->pdev->dev, \"firmware starts with type 0x%x\\n\",\n\t\t\ttype);\n\t\tgoto failed;\n\t}\n\tif (strncmp(\"Structured Binary Format, Softing GmbH\", dat, len)) {\n\t\tdev_alert(&card->pdev->dev, \"firmware string '%.*s' fault\\n\",\n\t\t\t\tlen, dat);\n\t\tgoto failed;\n\t}\n\t \n\twhile (mem < end) {\n\t\tret = fw_parse(&mem, &type, &addr, &len, &dat);\n\t\tif (ret)\n\t\t\tgoto failed;\n\n\t\tif (type == 3) {\n\t\t\t \n\t\t\tstart_addr = addr;\n\t\t\ttype_entrypoint = 1;\n\t\t\tcontinue;\n\t\t} else if (type == 1) {\n\t\t\t \n\t\t\ttype_end = 1;\n\t\t\tbreak;\n\t\t} else if (type != 0) {\n\t\t\tdev_alert(&card->pdev->dev,\n\t\t\t\t\t\"unknown record type 0x%04x\\n\", type);\n\t\t\tret = -EINVAL;\n\t\t\tgoto failed;\n\t\t}\n\n\t\t \n\t\tfor (sum = 0, j = 0; j < len; ++j)\n\t\t\tsum += dat[j];\n\t\t \n\t\tsum &= 0xffff;\n\n\t\tmemcpy_toio(&card->dpram[card->pdat->app.offs], dat, len);\n\t\tiowrite32(card->pdat->app.offs + card->pdat->app.addr,\n\t\t\t\t&card->dpram[DPRAM_COMMAND + 2]);\n\t\tiowrite32(addr, &card->dpram[DPRAM_COMMAND + 6]);\n\t\tiowrite16(len, &card->dpram[DPRAM_COMMAND + 10]);\n\t\tiowrite8(1, &card->dpram[DPRAM_COMMAND + 12]);\n\t\tret = softing_bootloader_command(card, 1, \"loading app.\");\n\t\tif (ret < 0)\n\t\t\tgoto failed;\n\t\t \n\t\trx_sum = ioread16(&card->dpram[DPRAM_RECEIPT + 2]);\n\t\tif (rx_sum != sum) {\n\t\t\tdev_alert(&card->pdev->dev, \"SRAM seems to be damaged\"\n\t\t\t\t\", wanted 0x%04x, got 0x%04x\\n\", sum, rx_sum);\n\t\t\tret = -EIO;\n\t\t\tgoto failed;\n\t\t}\n\t}\n\tif (!type_end || !type_entrypoint)\n\t\tgoto failed;\n\t \n\tiowrite32(start_addr, &card->dpram[DPRAM_COMMAND + 2]);\n\tiowrite8(1, &card->dpram[DPRAM_COMMAND + 6]);\n\tret = softing_bootloader_command(card, 3, \"start app.\");\n\tif (ret < 0)\n\t\tgoto failed;\n\tret = 0;\nfailed:\n\trelease_firmware(fw);\n\tif (ret < 0)\n\t\tdev_info(&card->pdev->dev, \"firmware %s failed\\n\", file);\n\treturn ret;\n}\n\nstatic int softing_reset_chip(struct softing *card)\n{\n\tint ret;\n\n\tdo {\n\t\t \n\t\tiowrite8(0, &card->dpram[DPRAM_RESET_RX_FIFO]);\n\t\tiowrite8(0, &card->dpram[DPRAM_RESET_RX_FIFO+1]);\n\t\tiowrite8(1, &card->dpram[DPRAM_RESET]);\n\t\tiowrite8(0, &card->dpram[DPRAM_RESET+1]);\n\n\t\tret = softing_fct_cmd(card, 0, \"reset_can\");\n\t\tif (!ret)\n\t\t\tbreak;\n\t\tif (signal_pending(current))\n\t\t\t \n\t\t\tbreak;\n\t} while (1);\n\tcard->tx.pending = 0;\n\treturn ret;\n}\n\nint softing_chip_poweron(struct softing *card)\n{\n\tint ret;\n\t \n\tret = _softing_fct_cmd(card, 99, 0x55, \"sync-a\");\n\tif (ret < 0)\n\t\tgoto failed;\n\n\tret = _softing_fct_cmd(card, 99, 0xaa, \"sync-b\");\n\tif (ret < 0)\n\t\tgoto failed;\n\n\tret = softing_reset_chip(card);\n\tif (ret < 0)\n\t\tgoto failed;\n\t \n\tret = softing_fct_cmd(card, 43, \"get_serial_number\");\n\tif (ret < 0)\n\t\tgoto failed;\n\tcard->id.serial = ioread32(&card->dpram[DPRAM_FCT_PARAM]);\n\t \n\tret = softing_fct_cmd(card, 12, \"get_version\");\n\tif (ret < 0)\n\t\tgoto failed;\n\tcard->id.fw_version = ioread16(&card->dpram[DPRAM_FCT_PARAM + 2]);\n\tcard->id.hw_version = ioread16(&card->dpram[DPRAM_FCT_PARAM + 4]);\n\tcard->id.license = ioread16(&card->dpram[DPRAM_FCT_PARAM + 6]);\n\tcard->id.chip[0] = ioread16(&card->dpram[DPRAM_FCT_PARAM + 8]);\n\tcard->id.chip[1] = ioread16(&card->dpram[DPRAM_FCT_PARAM + 10]);\n\treturn 0;\nfailed:\n\treturn ret;\n}\n\nstatic void softing_initialize_timestamp(struct softing *card)\n{\n\tuint64_t ovf;\n\n\tcard->ts_ref = ktime_get();\n\n\t \n\tovf = 0x100000000ULL * 16;\n\tdo_div(ovf, card->pdat->freq ?: 16);\n\n\tcard->ts_overflow = ktime_add_us(0, ovf);\n}\n\nktime_t softing_raw2ktime(struct softing *card, u32 raw)\n{\n\tuint64_t rawl;\n\tktime_t now, real_offset;\n\tktime_t target;\n\tktime_t tmp;\n\n\tnow = ktime_get();\n\treal_offset = ktime_sub(ktime_get_real(), now);\n\n\t \n\trawl = raw * 16;\n\tdo_div(rawl, card->pdat->freq ?: 16);\n\ttarget = ktime_add_us(card->ts_ref, rawl);\n\t \n\ttmp = ktime_add(target, card->ts_overflow);\n\twhile (unlikely(ktime_to_ns(tmp) > ktime_to_ns(now))) {\n\t\tcard->ts_ref = ktime_add(card->ts_ref, card->ts_overflow);\n\t\ttarget = tmp;\n\t\ttmp = ktime_add(target, card->ts_overflow);\n\t}\n\treturn ktime_add(target, real_offset);\n}\n\nstatic inline int softing_error_reporting(struct net_device *netdev)\n{\n\tstruct softing_priv *priv = netdev_priv(netdev);\n\n\treturn (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING)\n\t\t? 1 : 0;\n}\n\nint softing_startstop(struct net_device *dev, int up)\n{\n\tint ret;\n\tstruct softing *card;\n\tstruct softing_priv *priv;\n\tstruct net_device *netdev;\n\tint bus_bitmask_start;\n\tint j, error_reporting;\n\tstruct can_frame msg;\n\tconst struct can_bittiming *bt;\n\n\tpriv = netdev_priv(dev);\n\tcard = priv->card;\n\n\tif (!card->fw.up)\n\t\treturn -EIO;\n\n\tret = mutex_lock_interruptible(&card->fw.lock);\n\tif (ret)\n\t\treturn ret;\n\n\tbus_bitmask_start = 0;\n\tif (dev && up)\n\t\t \n\t\tbus_bitmask_start |= (1 << priv->index);\n\t \n\tfor (j = 0; j < ARRAY_SIZE(card->net); ++j) {\n\t\tnetdev = card->net[j];\n\t\tif (!netdev)\n\t\t\tcontinue;\n\t\tpriv = netdev_priv(netdev);\n\n\t\tif (dev != netdev)\n\t\t\tnetif_stop_queue(netdev);\n\n\t\tif (netif_running(netdev)) {\n\t\t\tif (dev != netdev)\n\t\t\t\tbus_bitmask_start |= (1 << j);\n\t\t\tpriv->tx.pending = 0;\n\t\t\tpriv->tx.echo_put = 0;\n\t\t\tpriv->tx.echo_get = 0;\n\t\t\t \n\t\t\tclose_candev(netdev);\n\t\t}\n\t\tpriv->can.state = CAN_STATE_STOPPED;\n\t}\n\tcard->tx.pending = 0;\n\n\tsofting_enable_irq(card, 0);\n\tret = softing_reset_chip(card);\n\tif (ret)\n\t\tgoto failed;\n\tif (!bus_bitmask_start)\n\t\t \n\t\tgoto card_done;\n\n\tif ((bus_bitmask_start & 1) && (bus_bitmask_start & 2)\n\t\t\t&& (softing_error_reporting(card->net[0])\n\t\t\t\t!= softing_error_reporting(card->net[1]))) {\n\t\tdev_alert(&card->pdev->dev,\n\t\t\t\t\"err_reporting flag differs for buses\\n\");\n\t\tgoto invalid;\n\t}\n\terror_reporting = 0;\n\tif (bus_bitmask_start & 1) {\n\t\tnetdev = card->net[0];\n\t\tpriv = netdev_priv(netdev);\n\t\terror_reporting += softing_error_reporting(netdev);\n\t\t \n\t\tbt = &priv->can.bittiming;\n\t\tiowrite16(bt->brp, &card->dpram[DPRAM_FCT_PARAM + 2]);\n\t\tiowrite16(bt->sjw, &card->dpram[DPRAM_FCT_PARAM + 4]);\n\t\tiowrite16(bt->phase_seg1 + bt->prop_seg,\n\t\t\t\t&card->dpram[DPRAM_FCT_PARAM + 6]);\n\t\tiowrite16(bt->phase_seg2, &card->dpram[DPRAM_FCT_PARAM + 8]);\n\t\tiowrite16((priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES) ? 1 : 0,\n\t\t\t\t&card->dpram[DPRAM_FCT_PARAM + 10]);\n\t\tret = softing_fct_cmd(card, 1, \"initialize_chip[0]\");\n\t\tif (ret < 0)\n\t\t\tgoto failed;\n\t\t \n\t\tiowrite16(0, &card->dpram[DPRAM_FCT_PARAM + 2]);\n\t\tiowrite16(0, &card->dpram[DPRAM_FCT_PARAM + 4]);\n\t\tret = softing_fct_cmd(card, 3, \"set_mode[0]\");\n\t\tif (ret < 0)\n\t\t\tgoto failed;\n\t\t \n\t\t \n\t\tiowrite16(0x0000, &card->dpram[DPRAM_FCT_PARAM + 2]);\n\t\tiowrite16(0x07ff, &card->dpram[DPRAM_FCT_PARAM + 4]);\n\t\t \n\t\tiowrite16(0x0000, &card->dpram[DPRAM_FCT_PARAM + 6]);\n\t\tiowrite16(0xffff, &card->dpram[DPRAM_FCT_PARAM + 8]);\n\t\tiowrite16(0x0000, &card->dpram[DPRAM_FCT_PARAM + 10]);\n\t\tiowrite16(0x1fff, &card->dpram[DPRAM_FCT_PARAM + 12]);\n\t\tret = softing_fct_cmd(card, 7, \"set_filter[0]\");\n\t\tif (ret < 0)\n\t\t\tgoto failed;\n\t\t \n\t\tiowrite16(priv->output, &card->dpram[DPRAM_FCT_PARAM + 2]);\n\t\tret = softing_fct_cmd(card, 5, \"set_output[0]\");\n\t\tif (ret < 0)\n\t\t\tgoto failed;\n\t}\n\tif (bus_bitmask_start & 2) {\n\t\tnetdev = card->net[1];\n\t\tpriv = netdev_priv(netdev);\n\t\terror_reporting += softing_error_reporting(netdev);\n\t\t \n\t\tbt = &priv->can.bittiming;\n\t\tiowrite16(bt->brp, &card->dpram[DPRAM_FCT_PARAM + 2]);\n\t\tiowrite16(bt->sjw, &card->dpram[DPRAM_FCT_PARAM + 4]);\n\t\tiowrite16(bt->phase_seg1 + bt->prop_seg,\n\t\t\t\t&card->dpram[DPRAM_FCT_PARAM + 6]);\n\t\tiowrite16(bt->phase_seg2, &card->dpram[DPRAM_FCT_PARAM + 8]);\n\t\tiowrite16((priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES) ? 1 : 0,\n\t\t\t\t&card->dpram[DPRAM_FCT_PARAM + 10]);\n\t\tret = softing_fct_cmd(card, 2, \"initialize_chip[1]\");\n\t\tif (ret < 0)\n\t\t\tgoto failed;\n\t\t \n\t\tiowrite16(0, &card->dpram[DPRAM_FCT_PARAM + 2]);\n\t\tiowrite16(0, &card->dpram[DPRAM_FCT_PARAM + 4]);\n\t\tret = softing_fct_cmd(card, 4, \"set_mode[1]\");\n\t\tif (ret < 0)\n\t\t\tgoto failed;\n\t\t \n\t\t \n\t\tiowrite16(0x0000, &card->dpram[DPRAM_FCT_PARAM + 2]);\n\t\tiowrite16(0x07ff, &card->dpram[DPRAM_FCT_PARAM + 4]);\n\t\t \n\t\tiowrite16(0x0000, &card->dpram[DPRAM_FCT_PARAM + 6]);\n\t\tiowrite16(0xffff, &card->dpram[DPRAM_FCT_PARAM + 8]);\n\t\tiowrite16(0x0000, &card->dpram[DPRAM_FCT_PARAM + 10]);\n\t\tiowrite16(0x1fff, &card->dpram[DPRAM_FCT_PARAM + 12]);\n\t\tret = softing_fct_cmd(card, 8, \"set_filter[1]\");\n\t\tif (ret < 0)\n\t\t\tgoto failed;\n\t\t \n\t\tiowrite16(priv->output, &card->dpram[DPRAM_FCT_PARAM + 2]);\n\t\tret = softing_fct_cmd(card, 6, \"set_output[1]\");\n\t\tif (ret < 0)\n\t\t\tgoto failed;\n\t}\n\n\t \n\tif (0 && error_reporting) {\n\t\tret = softing_fct_cmd(card, 51, \"enable_error_frame\");\n\t\tif (ret < 0)\n\t\t\tgoto failed;\n\t}\n\n\t \n\tiowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 2]);\n\tiowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 4]);\n\tiowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 6]);\n\tiowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 8]);\n\tiowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 10]);\n\tiowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 12]);\n\tiowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 14]);\n\tiowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 16]);\n\tiowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 18]);\n\tiowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 20]);\n\tret = softing_fct_cmd(card, 17, \"initialize_interface\");\n\tif (ret < 0)\n\t\tgoto failed;\n\t \n\tret = softing_fct_cmd(card, 36, \"enable_fifo\");\n\tif (ret < 0)\n\t\tgoto failed;\n\t \n\tret = softing_fct_cmd(card, 13, \"fifo_tx_ack[0]\");\n\tif (ret < 0)\n\t\tgoto failed;\n\t \n\tret = softing_fct_cmd(card, 14, \"fifo_tx_ack[1]\");\n\tif (ret < 0)\n\t\tgoto failed;\n\t \n\tret = softing_fct_cmd(card, 11, \"start_chip\");\n\tif (ret < 0)\n\t\tgoto failed;\n\tiowrite8(0, &card->dpram[DPRAM_INFO_BUSSTATE]);\n\tiowrite8(0, &card->dpram[DPRAM_INFO_BUSSTATE2]);\n\tif (card->pdat->generation < 2) {\n\t\tiowrite8(0, &card->dpram[DPRAM_V2_IRQ_TOHOST]);\n\t\t \n\t\twmb();\n\t}\n\n\tsofting_initialize_timestamp(card);\n\n\t \n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.can_id = CAN_ERR_FLAG | CAN_ERR_RESTARTED;\n\tmsg.len = CAN_ERR_DLC;\n\tfor (j = 0; j < ARRAY_SIZE(card->net); ++j) {\n\t\tif (!(bus_bitmask_start & (1 << j)))\n\t\t\tcontinue;\n\t\tnetdev = card->net[j];\n\t\tif (!netdev)\n\t\t\tcontinue;\n\t\tpriv = netdev_priv(netdev);\n\t\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\topen_candev(netdev);\n\t\tif (dev != netdev) {\n\t\t\t \n\t\t\tsofting_netdev_rx(netdev, &msg, 0);\n\t\t\t++priv->can.can_stats.restarts;\n\t\t}\n\t\tnetif_wake_queue(netdev);\n\t}\n\n\t \n\tret = softing_enable_irq(card, 1);\n\tif (ret)\n\t\tgoto failed;\ncard_done:\n\tmutex_unlock(&card->fw.lock);\n\treturn 0;\ninvalid:\n\tret = -EINVAL;\nfailed:\n\tsofting_enable_irq(card, 0);\n\tsofting_reset_chip(card);\n\tmutex_unlock(&card->fw.lock);\n\t \n\tfor (j = 0; j < ARRAY_SIZE(card->net); ++j) {\n\t\tnetdev = card->net[j];\n\t\tif (!netdev)\n\t\t\tcontinue;\n\t\tdev_close(netdev);\n\t}\n\treturn ret;\n}\n\nint softing_default_output(struct net_device *netdev)\n{\n\tstruct softing_priv *priv = netdev_priv(netdev);\n\tstruct softing *card = priv->card;\n\n\tswitch (priv->chip) {\n\tcase 1000:\n\t\treturn (card->pdat->generation < 2) ? 0xfb : 0xfa;\n\tcase 5:\n\t\treturn 0x60;\n\tdefault:\n\t\treturn 0x40;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}