{
  "module_name": "softing_main.c",
  "hash_id": "f4ba6e7ab6342fd7c2ced0acb3ec56566de306c8324136fc392f65181b599dae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/softing/softing_main.c",
  "human_readable_source": "\n \n\n#include <linux/ethtool.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <asm/io.h>\n\n#include \"softing.h\"\n\n#define TX_ECHO_SKB_MAX (((TXMAX+1)/2)-1)\n\n \nstatic inline int canif_is_active(struct net_device *netdev)\n{\n\tstruct can_priv *can = netdev_priv(netdev);\n\n\tif (!netif_running(netdev))\n\t\treturn 0;\n\treturn (can->state <= CAN_STATE_ERROR_PASSIVE);\n}\n\n \nstatic inline void softing_set_reset_dpram(struct softing *card)\n{\n\tif (card->pdat->generation >= 2) {\n\t\tspin_lock_bh(&card->spin);\n\t\tiowrite8(ioread8(&card->dpram[DPRAM_V2_RESET]) & ~1,\n\t\t\t\t&card->dpram[DPRAM_V2_RESET]);\n\t\tspin_unlock_bh(&card->spin);\n\t}\n}\n\nstatic inline void softing_clr_reset_dpram(struct softing *card)\n{\n\tif (card->pdat->generation >= 2) {\n\t\tspin_lock_bh(&card->spin);\n\t\tiowrite8(ioread8(&card->dpram[DPRAM_V2_RESET]) | 1,\n\t\t\t\t&card->dpram[DPRAM_V2_RESET]);\n\t\tspin_unlock_bh(&card->spin);\n\t}\n}\n\n \nstatic netdev_tx_t softing_netdev_start_xmit(struct sk_buff *skb,\n\t\tstruct net_device *dev)\n{\n\tstruct softing_priv *priv = netdev_priv(dev);\n\tstruct softing *card = priv->card;\n\tint ret;\n\tuint8_t *ptr;\n\tuint8_t fifo_wr, fifo_rd;\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tuint8_t buf[DPRAM_TX_SIZE];\n\n\tif (can_dev_dropped_skb(dev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tspin_lock(&card->spin);\n\n\tret = NETDEV_TX_BUSY;\n\tif (!card->fw.up ||\n\t\t\t(card->tx.pending >= TXMAX) ||\n\t\t\t(priv->tx.pending >= TX_ECHO_SKB_MAX))\n\t\tgoto xmit_done;\n\tfifo_wr = ioread8(&card->dpram[DPRAM_TX_WR]);\n\tfifo_rd = ioread8(&card->dpram[DPRAM_TX_RD]);\n\tif (fifo_wr == fifo_rd)\n\t\t \n\t\tgoto xmit_done;\n\tmemset(buf, 0, sizeof(buf));\n\tptr = buf;\n\t*ptr = CMD_TX;\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\t*ptr |= CMD_RTR;\n\tif (cf->can_id & CAN_EFF_FLAG)\n\t\t*ptr |= CMD_XTD;\n\tif (priv->index)\n\t\t*ptr |= CMD_BUS2;\n\t++ptr;\n\t*ptr++ = cf->len;\n\t*ptr++ = (cf->can_id >> 0);\n\t*ptr++ = (cf->can_id >> 8);\n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\t*ptr++ = (cf->can_id >> 16);\n\t\t*ptr++ = (cf->can_id >> 24);\n\t} else {\n\t\t \n\t\tptr += 1;\n\t}\n\tif (!(cf->can_id & CAN_RTR_FLAG))\n\t\tmemcpy(ptr, &cf->data[0], cf->len);\n\tmemcpy_toio(&card->dpram[DPRAM_TX + DPRAM_TX_SIZE * fifo_wr],\n\t\t\tbuf, DPRAM_TX_SIZE);\n\tif (++fifo_wr >= DPRAM_TX_CNT)\n\t\tfifo_wr = 0;\n\tiowrite8(fifo_wr, &card->dpram[DPRAM_TX_WR]);\n\tcard->tx.last_bus = priv->index;\n\t++card->tx.pending;\n\t++priv->tx.pending;\n\tcan_put_echo_skb(skb, dev, priv->tx.echo_put, 0);\n\t++priv->tx.echo_put;\n\tif (priv->tx.echo_put >= TX_ECHO_SKB_MAX)\n\t\tpriv->tx.echo_put = 0;\n\t \n\tret = NETDEV_TX_OK;\nxmit_done:\n\tspin_unlock(&card->spin);\n\tif (card->tx.pending >= TXMAX) {\n\t\tint j;\n\t\tfor (j = 0; j < ARRAY_SIZE(card->net); ++j) {\n\t\t\tif (card->net[j])\n\t\t\t\tnetif_stop_queue(card->net[j]);\n\t\t}\n\t}\n\tif (ret != NETDEV_TX_OK)\n\t\tnetif_stop_queue(dev);\n\n\treturn ret;\n}\n\n \nint softing_netdev_rx(struct net_device *netdev, const struct can_frame *msg,\n\t\tktime_t ktime)\n{\n\tstruct sk_buff *skb;\n\tstruct can_frame *cf;\n\n\tskb = alloc_can_skb(netdev, &cf);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tmemcpy(cf, msg, sizeof(*msg));\n\tskb->tstamp = ktime;\n\treturn netif_rx(skb);\n}\n\n \nstatic int softing_handle_1(struct softing *card)\n{\n\tstruct net_device *netdev;\n\tstruct softing_priv *priv;\n\tktime_t ktime;\n\tstruct can_frame msg;\n\tint cnt = 0, lost_msg;\n\tuint8_t fifo_rd, fifo_wr, cmd;\n\tuint8_t *ptr;\n\tuint32_t tmp_u32;\n\tuint8_t buf[DPRAM_RX_SIZE];\n\n\tmemset(&msg, 0, sizeof(msg));\n\t \n\tlost_msg = ioread8(&card->dpram[DPRAM_RX_LOST]);\n\tif (lost_msg) {\n\t\tint j;\n\t\t \n\t\tiowrite8(0, &card->dpram[DPRAM_RX_LOST]);\n\t\t \n\t\tmsg.can_id = CAN_ERR_FLAG | CAN_ERR_CRTL;\n\t\tmsg.len = CAN_ERR_DLC;\n\t\tmsg.data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\t\t \n\t\tfor (j = 0; j < ARRAY_SIZE(card->net); ++j) {\n\t\t\tnetdev = card->net[j];\n\t\t\tif (!netdev)\n\t\t\t\tcontinue;\n\t\t\tif (!canif_is_active(netdev))\n\t\t\t\t \n\t\t\t\tcontinue;\n\t\t\t++netdev->stats.rx_over_errors;\n\t\t\tsofting_netdev_rx(netdev, &msg, 0);\n\t\t}\n\t\t \n\t\tmemset(&msg, 0, sizeof(msg));\n\t\t++cnt;\n\t}\n\n\tfifo_rd = ioread8(&card->dpram[DPRAM_RX_RD]);\n\tfifo_wr = ioread8(&card->dpram[DPRAM_RX_WR]);\n\n\tif (++fifo_rd >= DPRAM_RX_CNT)\n\t\tfifo_rd = 0;\n\tif (fifo_wr == fifo_rd)\n\t\treturn cnt;\n\n\tmemcpy_fromio(buf, &card->dpram[DPRAM_RX + DPRAM_RX_SIZE*fifo_rd],\n\t\t\tDPRAM_RX_SIZE);\n\tmb();\n\t \n\tiowrite8(fifo_rd, &card->dpram[DPRAM_RX_RD]);\n\n\tptr = buf;\n\tcmd = *ptr++;\n\tif (cmd == 0xff)\n\t\t \n\t\treturn 0;\n\tnetdev = card->net[0];\n\tif (cmd & CMD_BUS2)\n\t\tnetdev = card->net[1];\n\tpriv = netdev_priv(netdev);\n\n\tif (cmd & CMD_ERR) {\n\t\tuint8_t can_state, state;\n\n\t\tstate = *ptr++;\n\n\t\tmsg.can_id = CAN_ERR_FLAG;\n\t\tmsg.len = CAN_ERR_DLC;\n\n\t\tif (state & SF_MASK_BUSOFF) {\n\t\t\tcan_state = CAN_STATE_BUS_OFF;\n\t\t\tmsg.can_id |= CAN_ERR_BUSOFF;\n\t\t\tstate = STATE_BUSOFF;\n\t\t} else if (state & SF_MASK_EPASSIVE) {\n\t\t\tcan_state = CAN_STATE_ERROR_PASSIVE;\n\t\t\tmsg.can_id |= CAN_ERR_CRTL;\n\t\t\tmsg.data[1] = CAN_ERR_CRTL_TX_PASSIVE;\n\t\t\tstate = STATE_EPASSIVE;\n\t\t} else {\n\t\t\tcan_state = CAN_STATE_ERROR_ACTIVE;\n\t\t\tmsg.can_id |= CAN_ERR_CRTL;\n\t\t\tstate = STATE_EACTIVE;\n\t\t}\n\t\t \n\t\tiowrite8(state, &card->dpram[priv->index ?\n\t\t\t\tDPRAM_INFO_BUSSTATE2 : DPRAM_INFO_BUSSTATE]);\n\t\t \n\t\ttmp_u32 = le32_to_cpup((void *)ptr);\n\t\tktime = softing_raw2ktime(card, tmp_u32);\n\n\t\t++netdev->stats.rx_errors;\n\t\t \n\t\tif (can_state != priv->can.state) {\n\t\t\tpriv->can.state = can_state;\n\t\t\tif (can_state == CAN_STATE_ERROR_PASSIVE)\n\t\t\t\t++priv->can.can_stats.error_passive;\n\t\t\telse if (can_state == CAN_STATE_BUS_OFF) {\n\t\t\t\t \n\t\t\t\t++priv->can.can_stats.bus_off;\n\t\t\t\tcan_bus_off(netdev);\n\t\t\t\tnetif_stop_queue(netdev);\n\t\t\t}\n\t\t\t \n\t\t\tsofting_netdev_rx(netdev, &msg, ktime);\n\t\t}\n\n\t} else {\n\t\tif (cmd & CMD_RTR)\n\t\t\tmsg.can_id |= CAN_RTR_FLAG;\n\t\tmsg.len = can_cc_dlc2len(*ptr++);\n\t\tif (cmd & CMD_XTD) {\n\t\t\tmsg.can_id |= CAN_EFF_FLAG;\n\t\t\tmsg.can_id |= le32_to_cpup((void *)ptr);\n\t\t\tptr += 4;\n\t\t} else {\n\t\t\tmsg.can_id |= le16_to_cpup((void *)ptr);\n\t\t\tptr += 2;\n\t\t}\n\t\t \n\t\ttmp_u32 = le32_to_cpup((void *)ptr);\n\t\tptr += 4;\n\t\tktime = softing_raw2ktime(card, tmp_u32);\n\t\tif (!(msg.can_id & CAN_RTR_FLAG))\n\t\t\tmemcpy(&msg.data[0], ptr, 8);\n\t\t \n\t\tif (cmd & CMD_ACK) {\n\t\t\t \n\t\t\tstruct sk_buff *skb;\n\t\t\tskb = priv->can.echo_skb[priv->tx.echo_get];\n\t\t\tif (skb)\n\t\t\t\tskb->tstamp = ktime;\n\t\t\t++netdev->stats.tx_packets;\n\t\t\tnetdev->stats.tx_bytes +=\n\t\t\t\tcan_get_echo_skb(netdev, priv->tx.echo_get,\n\t\t\t\t\t\t NULL);\n\t\t\t++priv->tx.echo_get;\n\t\t\tif (priv->tx.echo_get >= TX_ECHO_SKB_MAX)\n\t\t\t\tpriv->tx.echo_get = 0;\n\t\t\tif (priv->tx.pending)\n\t\t\t\t--priv->tx.pending;\n\t\t\tif (card->tx.pending)\n\t\t\t\t--card->tx.pending;\n\t\t} else {\n\t\t\tint ret;\n\n\t\t\tret = softing_netdev_rx(netdev, &msg, ktime);\n\t\t\tif (ret == NET_RX_SUCCESS) {\n\t\t\t\t++netdev->stats.rx_packets;\n\t\t\t\tif (!(msg.can_id & CAN_RTR_FLAG))\n\t\t\t\t\tnetdev->stats.rx_bytes += msg.len;\n\t\t\t} else {\n\t\t\t\t++netdev->stats.rx_dropped;\n\t\t\t}\n\t\t}\n\t}\n\t++cnt;\n\treturn cnt;\n}\n\n \nstatic irqreturn_t softing_irq_thread(int irq, void *dev_id)\n{\n\tstruct softing *card = (struct softing *)dev_id;\n\tstruct net_device *netdev;\n\tstruct softing_priv *priv;\n\tint j, offset, work_done;\n\n\twork_done = 0;\n\tspin_lock_bh(&card->spin);\n\twhile (softing_handle_1(card) > 0) {\n\t\t++card->irq.svc_count;\n\t\t++work_done;\n\t}\n\tspin_unlock_bh(&card->spin);\n\t \n\toffset = card->tx.last_bus;\n\tfor (j = 0; j < ARRAY_SIZE(card->net); ++j) {\n\t\tif (card->tx.pending >= TXMAX)\n\t\t\tbreak;\n\t\tnetdev = card->net[(j + offset + 1) % card->pdat->nbus];\n\t\tif (!netdev)\n\t\t\tcontinue;\n\t\tpriv = netdev_priv(netdev);\n\t\tif (!canif_is_active(netdev))\n\t\t\t \n\t\t\tcontinue;\n\t\tif (priv->tx.pending >= TX_ECHO_SKB_MAX)\n\t\t\tcontinue;\n\t\t++work_done;\n\t\tnetif_wake_queue(netdev);\n\t}\n\treturn work_done ? IRQ_HANDLED : IRQ_NONE;\n}\n\n \nstatic irqreturn_t softing_irq_v2(int irq, void *dev_id)\n{\n\tstruct softing *card = (struct softing *)dev_id;\n\tuint8_t ir;\n\n\tir = ioread8(&card->dpram[DPRAM_V2_IRQ_TOHOST]);\n\tiowrite8(0, &card->dpram[DPRAM_V2_IRQ_TOHOST]);\n\treturn (1 == ir) ? IRQ_WAKE_THREAD : IRQ_NONE;\n}\n\nstatic irqreturn_t softing_irq_v1(int irq, void *dev_id)\n{\n\tstruct softing *card = (struct softing *)dev_id;\n\tuint8_t ir;\n\n\tir = ioread8(&card->dpram[DPRAM_IRQ_TOHOST]);\n\tiowrite8(0, &card->dpram[DPRAM_IRQ_TOHOST]);\n\treturn ir ? IRQ_WAKE_THREAD : IRQ_NONE;\n}\n\n \nstatic int softing_netdev_open(struct net_device *ndev)\n{\n\tint ret;\n\n\t \n\tret = open_candev(ndev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = softing_startstop(ndev, 1);\n\tif (ret < 0)\n\t\tclose_candev(ndev);\n\n\treturn ret;\n}\n\nstatic int softing_netdev_stop(struct net_device *ndev)\n{\n\tnetif_stop_queue(ndev);\n\n\t \n\treturn softing_startstop(ndev, 0);\n}\n\nstatic int softing_candev_set_mode(struct net_device *ndev, enum can_mode mode)\n{\n\tint ret;\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\t \n\t\tret = softing_startstop(ndev, 1);\n\t\treturn ret;\n\tcase CAN_MODE_STOP:\n\tcase CAN_MODE_SLEEP:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n \nint softing_enable_irq(struct softing *card, int enable)\n{\n\tint ret;\n\n\tif (!card->irq.nr) {\n\t\treturn 0;\n\t} else if (card->irq.requested && !enable) {\n\t\tfree_irq(card->irq.nr, card);\n\t\tcard->irq.requested = 0;\n\t} else if (!card->irq.requested && enable) {\n\t\tret = request_threaded_irq(card->irq.nr,\n\t\t\t\t(card->pdat->generation >= 2) ?\n\t\t\t\t\tsofting_irq_v2 : softing_irq_v1,\n\t\t\t\tsofting_irq_thread, IRQF_SHARED,\n\t\t\t\tdev_name(&card->pdev->dev), card);\n\t\tif (ret) {\n\t\t\tdev_alert(&card->pdev->dev,\n\t\t\t\t\t\"request_threaded_irq(%u) failed\\n\",\n\t\t\t\t\tcard->irq.nr);\n\t\t\treturn ret;\n\t\t}\n\t\tcard->irq.requested = 1;\n\t}\n\treturn 0;\n}\n\nstatic void softing_card_shutdown(struct softing *card)\n{\n\tint fw_up = 0;\n\n\tif (mutex_lock_interruptible(&card->fw.lock)) {\n\t\t ;\n\t}\n\tfw_up = card->fw.up;\n\tcard->fw.up = 0;\n\n\tif (card->irq.requested && card->irq.nr) {\n\t\tfree_irq(card->irq.nr, card);\n\t\tcard->irq.requested = 0;\n\t}\n\tif (fw_up) {\n\t\tif (card->pdat->enable_irq)\n\t\t\tcard->pdat->enable_irq(card->pdev, 0);\n\t\tsofting_set_reset_dpram(card);\n\t\tif (card->pdat->reset)\n\t\t\tcard->pdat->reset(card->pdev, 1);\n\t}\n\tmutex_unlock(&card->fw.lock);\n}\n\nstatic int softing_card_boot(struct softing *card)\n{\n\tint ret, j;\n\tstatic const uint8_t stream[] = {\n\t\t0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, };\n\tunsigned char back[sizeof(stream)];\n\n\tif (mutex_lock_interruptible(&card->fw.lock))\n\t\treturn -ERESTARTSYS;\n\tif (card->fw.up) {\n\t\tmutex_unlock(&card->fw.lock);\n\t\treturn 0;\n\t}\n\t \n\tif (card->pdat->enable_irq)\n\t\tcard->pdat->enable_irq(card->pdev, 1);\n\t \n\tsofting_set_reset_dpram(card);\n\tif (card->pdat->reset)\n\t\tcard->pdat->reset(card->pdev, 1);\n\tfor (j = 0; (j + sizeof(stream)) < card->dpram_size;\n\t\t\tj += sizeof(stream)) {\n\n\t\tmemcpy_toio(&card->dpram[j], stream, sizeof(stream));\n\t\t \n\t\tmb();\n\t\tmemcpy_fromio(back, &card->dpram[j], sizeof(stream));\n\n\t\tif (!memcmp(back, stream, sizeof(stream)))\n\t\t\tcontinue;\n\t\t \n\t\tdev_alert(&card->pdev->dev, \"dpram failed at 0x%04x\\n\", j);\n\t\tret = -EIO;\n\t\tgoto failed;\n\t}\n\twmb();\n\t \n\tret = softing_load_fw(card->pdat->boot.fw, card, card->dpram,\n\t\t\t\tcard->dpram_size,\n\t\t\t\tcard->pdat->boot.offs - card->pdat->boot.addr);\n\tif (ret < 0)\n\t\tgoto failed;\n\t \n\tret = softing_load_fw(card->pdat->load.fw, card, card->dpram,\n\t\t\t\tcard->dpram_size,\n\t\t\t\tcard->pdat->load.offs - card->pdat->load.addr);\n\tif (ret < 0)\n\t\tgoto failed;\n\n\tif (card->pdat->reset)\n\t\tcard->pdat->reset(card->pdev, 0);\n\tsofting_clr_reset_dpram(card);\n\tret = softing_bootloader_command(card, 0, \"card boot\");\n\tif (ret < 0)\n\t\tgoto failed;\n\tret = softing_load_app_fw(card->pdat->app.fw, card);\n\tif (ret < 0)\n\t\tgoto failed;\n\n\tret = softing_chip_poweron(card);\n\tif (ret < 0)\n\t\tgoto failed;\n\n\tcard->fw.up = 1;\n\tmutex_unlock(&card->fw.lock);\n\treturn 0;\nfailed:\n\tcard->fw.up = 0;\n\tif (card->pdat->enable_irq)\n\t\tcard->pdat->enable_irq(card->pdev, 0);\n\tsofting_set_reset_dpram(card);\n\tif (card->pdat->reset)\n\t\tcard->pdat->reset(card->pdev, 1);\n\tmutex_unlock(&card->fw.lock);\n\treturn ret;\n}\n\n \nstatic ssize_t show_chip(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct net_device *ndev = to_net_dev(dev);\n\tstruct softing_priv *priv = netdev2softing(ndev);\n\n\treturn sprintf(buf, \"%i\\n\", priv->chip);\n}\n\nstatic ssize_t show_output(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct net_device *ndev = to_net_dev(dev);\n\tstruct softing_priv *priv = netdev2softing(ndev);\n\n\treturn sprintf(buf, \"0x%02x\\n\", priv->output);\n}\n\nstatic ssize_t store_output(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct net_device *ndev = to_net_dev(dev);\n\tstruct softing_priv *priv = netdev2softing(ndev);\n\tstruct softing *card = priv->card;\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 0, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\tval &= 0xFF;\n\n\tret = mutex_lock_interruptible(&card->fw.lock);\n\tif (ret)\n\t\treturn -ERESTARTSYS;\n\tif (netif_running(ndev)) {\n\t\tmutex_unlock(&card->fw.lock);\n\t\treturn -EBUSY;\n\t}\n\tpriv->output = val;\n\tmutex_unlock(&card->fw.lock);\n\treturn count;\n}\n\nstatic const DEVICE_ATTR(chip, 0444, show_chip, NULL);\nstatic const DEVICE_ATTR(output, 0644, show_output, store_output);\n\nstatic const struct attribute *const netdev_sysfs_attrs[] = {\n\t&dev_attr_chip.attr,\n\t&dev_attr_output.attr,\n\tNULL,\n};\nstatic const struct attribute_group netdev_sysfs_group = {\n\t.name = NULL,\n\t.attrs = (struct attribute **)netdev_sysfs_attrs,\n};\n\nstatic const struct net_device_ops softing_netdev_ops = {\n\t.ndo_open = softing_netdev_open,\n\t.ndo_stop = softing_netdev_stop,\n\t.ndo_start_xmit\t= softing_netdev_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic const struct ethtool_ops softing_ethtool_ops = {\n\t.get_ts_info = ethtool_op_get_ts_info,\n};\n\nstatic const struct can_bittiming_const softing_btr_const = {\n\t.name = KBUILD_MODNAME,\n\t.tseg1_min = 1,\n\t.tseg1_max = 16,\n\t.tseg2_min = 1,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,  \n\t.brp_min = 1,\n\t.brp_max = 32,  \n\t.brp_inc = 1,\n};\n\n\nstatic struct net_device *softing_netdev_create(struct softing *card,\n\t\t\t\t\t\tuint16_t chip_id)\n{\n\tstruct net_device *netdev;\n\tstruct softing_priv *priv;\n\n\tnetdev = alloc_candev(sizeof(*priv), TX_ECHO_SKB_MAX);\n\tif (!netdev) {\n\t\tdev_alert(&card->pdev->dev, \"alloc_candev failed\\n\");\n\t\treturn NULL;\n\t}\n\tpriv = netdev_priv(netdev);\n\tpriv->netdev = netdev;\n\tpriv->card = card;\n\tmemcpy(&priv->btr_const, &softing_btr_const, sizeof(priv->btr_const));\n\tpriv->btr_const.brp_max = card->pdat->max_brp;\n\tpriv->btr_const.sjw_max = card->pdat->max_sjw;\n\tpriv->can.bittiming_const = &priv->btr_const;\n\tpriv->can.clock.freq = 8000000;\n\tpriv->chip = chip_id;\n\tpriv->output = softing_default_output(netdev);\n\tSET_NETDEV_DEV(netdev, &card->pdev->dev);\n\n\tnetdev->flags |= IFF_ECHO;\n\tnetdev->netdev_ops = &softing_netdev_ops;\n\tnetdev->ethtool_ops = &softing_ethtool_ops;\n\tpriv->can.do_set_mode = softing_candev_set_mode;\n\tpriv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES;\n\n\treturn netdev;\n}\n\nstatic int softing_netdev_register(struct net_device *netdev)\n{\n\tint ret;\n\n\tret = register_candev(netdev);\n\tif (ret) {\n\t\tdev_alert(&netdev->dev, \"register failed\\n\");\n\t\treturn ret;\n\t}\n\tif (sysfs_create_group(&netdev->dev.kobj, &netdev_sysfs_group) < 0)\n\t\tnetdev_alert(netdev, \"sysfs group failed\\n\");\n\n\treturn 0;\n}\n\nstatic void softing_netdev_cleanup(struct net_device *netdev)\n{\n\tsysfs_remove_group(&netdev->dev.kobj, &netdev_sysfs_group);\n\tunregister_candev(netdev);\n\tfree_candev(netdev);\n}\n\n \n#define DEV_ATTR_RO(name, member) \\\nstatic ssize_t show_##name(struct device *dev, \\\n\t\tstruct device_attribute *attr, char *buf) \\\n{ \\\n\tstruct softing *card = dev_get_drvdata(dev); \\\n\treturn sprintf(buf, \"%u\\n\", card->member); \\\n} \\\nstatic DEVICE_ATTR(name, 0444, show_##name, NULL)\n\n#define DEV_ATTR_RO_STR(name, member) \\\nstatic ssize_t show_##name(struct device *dev, \\\n\t\tstruct device_attribute *attr, char *buf) \\\n{ \\\n\tstruct softing *card = dev_get_drvdata(dev); \\\n\treturn sprintf(buf, \"%s\\n\", card->member); \\\n} \\\nstatic DEVICE_ATTR(name, 0444, show_##name, NULL)\n\nDEV_ATTR_RO(serial, id.serial);\nDEV_ATTR_RO_STR(firmware, pdat->app.fw);\nDEV_ATTR_RO(firmware_version, id.fw_version);\nDEV_ATTR_RO_STR(hardware, pdat->name);\nDEV_ATTR_RO(hardware_version, id.hw_version);\nDEV_ATTR_RO(license, id.license);\n\nstatic struct attribute *softing_pdev_attrs[] = {\n\t&dev_attr_serial.attr,\n\t&dev_attr_firmware.attr,\n\t&dev_attr_firmware_version.attr,\n\t&dev_attr_hardware.attr,\n\t&dev_attr_hardware_version.attr,\n\t&dev_attr_license.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group softing_pdev_group = {\n\t.name = NULL,\n\t.attrs = softing_pdev_attrs,\n};\n\n \nstatic void softing_pdev_remove(struct platform_device *pdev)\n{\n\tstruct softing *card = platform_get_drvdata(pdev);\n\tint j;\n\n\t \n\tsofting_card_shutdown(card);\n\n\tfor (j = 0; j < ARRAY_SIZE(card->net); ++j) {\n\t\tif (!card->net[j])\n\t\t\tcontinue;\n\t\tsofting_netdev_cleanup(card->net[j]);\n\t\tcard->net[j] = NULL;\n\t}\n\tsysfs_remove_group(&pdev->dev.kobj, &softing_pdev_group);\n\n\tiounmap(card->dpram);\n\tkfree(card);\n}\n\nstatic int softing_pdev_probe(struct platform_device *pdev)\n{\n\tconst struct softing_platform_data *pdat = dev_get_platdata(&pdev->dev);\n\tstruct softing *card;\n\tstruct net_device *netdev;\n\tstruct softing_priv *priv;\n\tstruct resource *pres;\n\tint ret;\n\tint j;\n\n\tif (!pdat) {\n\t\tdev_warn(&pdev->dev, \"no platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (pdat->nbus > ARRAY_SIZE(card->net)) {\n\t\tdev_warn(&pdev->dev, \"%u nets??\\n\", pdat->nbus);\n\t\treturn -EINVAL;\n\t}\n\n\tcard = kzalloc(sizeof(*card), GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\tcard->pdat = pdat;\n\tcard->pdev = pdev;\n\tplatform_set_drvdata(pdev, card);\n\tmutex_init(&card->fw.lock);\n\tspin_lock_init(&card->spin);\n\n\tret = -EINVAL;\n\tpres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!pres)\n\t\tgoto platform_resource_failed;\n\tcard->dpram_phys = pres->start;\n\tcard->dpram_size = resource_size(pres);\n\tcard->dpram = ioremap(card->dpram_phys, card->dpram_size);\n\tif (!card->dpram) {\n\t\tdev_alert(&card->pdev->dev, \"dpram ioremap failed\\n\");\n\t\tgoto ioremap_failed;\n\t}\n\n\tpres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\tif (pres)\n\t\tcard->irq.nr = pres->start;\n\n\t \n\tret = softing_card_boot(card);\n\tif (ret < 0) {\n\t\tdev_alert(&pdev->dev, \"failed to boot\\n\");\n\t\tgoto boot_failed;\n\t}\n\n\t \n\tcard->id.freq = card->pdat->freq;\n\n\tret = sysfs_create_group(&pdev->dev.kobj, &softing_pdev_group);\n\tif (ret < 0) {\n\t\tdev_alert(&card->pdev->dev, \"sysfs failed\\n\");\n\t\tgoto sysfs_failed;\n\t}\n\n\tfor (j = 0; j < ARRAY_SIZE(card->net); ++j) {\n\t\tcard->net[j] = netdev =\n\t\t\tsofting_netdev_create(card, card->id.chip[j]);\n\t\tif (!netdev) {\n\t\t\tdev_alert(&pdev->dev, \"failed to make can[%i]\", j);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto netdev_failed;\n\t\t}\n\t\tnetdev->dev_id = j;\n\t\tpriv = netdev_priv(card->net[j]);\n\t\tpriv->index = j;\n\t\tret = softing_netdev_register(netdev);\n\t\tif (ret) {\n\t\t\tfree_candev(netdev);\n\t\t\tcard->net[j] = NULL;\n\t\t\tdev_alert(&card->pdev->dev,\n\t\t\t\t\t\"failed to register can[%i]\\n\", j);\n\t\t\tgoto netdev_failed;\n\t\t}\n\t}\n\tdev_info(&card->pdev->dev, \"%s ready.\\n\", card->pdat->name);\n\treturn 0;\n\nnetdev_failed:\n\tfor (j = 0; j < ARRAY_SIZE(card->net); ++j) {\n\t\tif (!card->net[j])\n\t\t\tcontinue;\n\t\tsofting_netdev_cleanup(card->net[j]);\n\t}\n\tsysfs_remove_group(&pdev->dev.kobj, &softing_pdev_group);\nsysfs_failed:\n\tsofting_card_shutdown(card);\nboot_failed:\n\tiounmap(card->dpram);\nioremap_failed:\nplatform_resource_failed:\n\tkfree(card);\n\treturn ret;\n}\n\nstatic struct platform_driver softing_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t},\n\t.probe = softing_pdev_probe,\n\t.remove_new = softing_pdev_remove,\n};\n\nmodule_platform_driver(softing_driver);\n\nMODULE_ALIAS(\"platform:softing\");\nMODULE_DESCRIPTION(\"Softing DPRAM CAN driver\");\nMODULE_AUTHOR(\"Kurt Van Dijck <kurt.van.dijck@eia.be>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}