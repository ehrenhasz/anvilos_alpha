{
  "module_name": "m_can.c",
  "hash_id": "8fc6e1316b8ae2499bdbf95f005270e0c17f94c1c062c4b275dfd7caf4b2ce85",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/m_can/m_can.c",
  "human_readable_source": "\n\n\n\n\n\n \n\n#include <linux/bitfield.h>\n#include <linux/can/dev.h>\n#include <linux/ethtool.h>\n#include <linux/hrtimer.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include \"m_can.h\"\n\n \nenum m_can_reg {\n\tM_CAN_CREL\t= 0x0,\n\tM_CAN_ENDN\t= 0x4,\n\tM_CAN_CUST\t= 0x8,\n\tM_CAN_DBTP\t= 0xc,\n\tM_CAN_TEST\t= 0x10,\n\tM_CAN_RWD\t= 0x14,\n\tM_CAN_CCCR\t= 0x18,\n\tM_CAN_NBTP\t= 0x1c,\n\tM_CAN_TSCC\t= 0x20,\n\tM_CAN_TSCV\t= 0x24,\n\tM_CAN_TOCC\t= 0x28,\n\tM_CAN_TOCV\t= 0x2c,\n\tM_CAN_ECR\t= 0x40,\n\tM_CAN_PSR\t= 0x44,\n\t \n\tM_CAN_TDCR\t= 0x48,\n\tM_CAN_IR\t= 0x50,\n\tM_CAN_IE\t= 0x54,\n\tM_CAN_ILS\t= 0x58,\n\tM_CAN_ILE\t= 0x5c,\n\tM_CAN_GFC\t= 0x80,\n\tM_CAN_SIDFC\t= 0x84,\n\tM_CAN_XIDFC\t= 0x88,\n\tM_CAN_XIDAM\t= 0x90,\n\tM_CAN_HPMS\t= 0x94,\n\tM_CAN_NDAT1\t= 0x98,\n\tM_CAN_NDAT2\t= 0x9c,\n\tM_CAN_RXF0C\t= 0xa0,\n\tM_CAN_RXF0S\t= 0xa4,\n\tM_CAN_RXF0A\t= 0xa8,\n\tM_CAN_RXBC\t= 0xac,\n\tM_CAN_RXF1C\t= 0xb0,\n\tM_CAN_RXF1S\t= 0xb4,\n\tM_CAN_RXF1A\t= 0xb8,\n\tM_CAN_RXESC\t= 0xbc,\n\tM_CAN_TXBC\t= 0xc0,\n\tM_CAN_TXFQS\t= 0xc4,\n\tM_CAN_TXESC\t= 0xc8,\n\tM_CAN_TXBRP\t= 0xcc,\n\tM_CAN_TXBAR\t= 0xd0,\n\tM_CAN_TXBCR\t= 0xd4,\n\tM_CAN_TXBTO\t= 0xd8,\n\tM_CAN_TXBCF\t= 0xdc,\n\tM_CAN_TXBTIE\t= 0xe0,\n\tM_CAN_TXBCIE\t= 0xe4,\n\tM_CAN_TXEFC\t= 0xf0,\n\tM_CAN_TXEFS\t= 0xf4,\n\tM_CAN_TXEFA\t= 0xf8,\n};\n\n \n#define MRAM_CFG_LEN\t8\n\n \n#define CREL_REL_MASK\t\tGENMASK(31, 28)\n#define CREL_STEP_MASK\t\tGENMASK(27, 24)\n#define CREL_SUBSTEP_MASK\tGENMASK(23, 20)\n\n \n#define DBTP_TDC\t\tBIT(23)\n#define DBTP_DBRP_MASK\t\tGENMASK(20, 16)\n#define DBTP_DTSEG1_MASK\tGENMASK(12, 8)\n#define DBTP_DTSEG2_MASK\tGENMASK(7, 4)\n#define DBTP_DSJW_MASK\t\tGENMASK(3, 0)\n\n \n#define TDCR_TDCO_MASK\t\tGENMASK(14, 8)\n#define TDCR_TDCF_MASK\t\tGENMASK(6, 0)\n\n \n#define TEST_LBCK\t\tBIT(4)\n\n \n#define CCCR_TXP\t\tBIT(14)\n#define CCCR_TEST\t\tBIT(7)\n#define CCCR_DAR\t\tBIT(6)\n#define CCCR_MON\t\tBIT(5)\n#define CCCR_CSR\t\tBIT(4)\n#define CCCR_CSA\t\tBIT(3)\n#define CCCR_ASM\t\tBIT(2)\n#define CCCR_CCE\t\tBIT(1)\n#define CCCR_INIT\t\tBIT(0)\n \n#define CCCR_CMR_MASK\t\tGENMASK(11, 10)\n#define CCCR_CMR_CANFD\t\t0x1\n#define CCCR_CMR_CANFD_BRS\t0x2\n#define CCCR_CMR_CAN\t\t0x3\n#define CCCR_CME_MASK\t\tGENMASK(9, 8)\n#define CCCR_CME_CAN\t\t0\n#define CCCR_CME_CANFD\t\t0x1\n#define CCCR_CME_CANFD_BRS\t0x2\n \n#define CCCR_EFBI\t\tBIT(13)\n#define CCCR_PXHD\t\tBIT(12)\n#define CCCR_BRSE\t\tBIT(9)\n#define CCCR_FDOE\t\tBIT(8)\n \n#define CCCR_NISO\t\tBIT(15)\n \n#define CCCR_WMM\t\tBIT(11)\n#define CCCR_UTSU\t\tBIT(10)\n\n \n#define NBTP_NSJW_MASK\t\tGENMASK(31, 25)\n#define NBTP_NBRP_MASK\t\tGENMASK(24, 16)\n#define NBTP_NTSEG1_MASK\tGENMASK(15, 8)\n#define NBTP_NTSEG2_MASK\tGENMASK(6, 0)\n\n \n#define TSCC_TCP_MASK\t\tGENMASK(19, 16)\n#define TSCC_TSS_MASK\t\tGENMASK(1, 0)\n#define TSCC_TSS_DISABLE\t0x0\n#define TSCC_TSS_INTERNAL\t0x1\n#define TSCC_TSS_EXTERNAL\t0x2\n\n \n#define TSCV_TSC_MASK\t\tGENMASK(15, 0)\n\n \n#define ECR_RP\t\t\tBIT(15)\n#define ECR_REC_MASK\t\tGENMASK(14, 8)\n#define ECR_TEC_MASK\t\tGENMASK(7, 0)\n\n \n#define PSR_BO\t\tBIT(7)\n#define PSR_EW\t\tBIT(6)\n#define PSR_EP\t\tBIT(5)\n#define PSR_LEC_MASK\tGENMASK(2, 0)\n#define PSR_DLEC_MASK\tGENMASK(10, 8)\n\n \n#define IR_ALL_INT\t0xffffffff\n\n \n#define IR_ARA\t\tBIT(29)\n#define IR_PED\t\tBIT(28)\n#define IR_PEA\t\tBIT(27)\n\n \n#define IR_STE\t\tBIT(31)\n#define IR_FOE\t\tBIT(30)\n#define IR_ACKE\t\tBIT(29)\n#define IR_BE\t\tBIT(28)\n#define IR_CRCE\t\tBIT(27)\n#define IR_WDI\t\tBIT(26)\n#define IR_BO\t\tBIT(25)\n#define IR_EW\t\tBIT(24)\n#define IR_EP\t\tBIT(23)\n#define IR_ELO\t\tBIT(22)\n#define IR_BEU\t\tBIT(21)\n#define IR_BEC\t\tBIT(20)\n#define IR_DRX\t\tBIT(19)\n#define IR_TOO\t\tBIT(18)\n#define IR_MRAF\t\tBIT(17)\n#define IR_TSW\t\tBIT(16)\n#define IR_TEFL\t\tBIT(15)\n#define IR_TEFF\t\tBIT(14)\n#define IR_TEFW\t\tBIT(13)\n#define IR_TEFN\t\tBIT(12)\n#define IR_TFE\t\tBIT(11)\n#define IR_TCF\t\tBIT(10)\n#define IR_TC\t\tBIT(9)\n#define IR_HPM\t\tBIT(8)\n#define IR_RF1L\t\tBIT(7)\n#define IR_RF1F\t\tBIT(6)\n#define IR_RF1W\t\tBIT(5)\n#define IR_RF1N\t\tBIT(4)\n#define IR_RF0L\t\tBIT(3)\n#define IR_RF0F\t\tBIT(2)\n#define IR_RF0W\t\tBIT(1)\n#define IR_RF0N\t\tBIT(0)\n#define IR_ERR_STATE\t(IR_BO | IR_EW | IR_EP)\n\n \n#define IR_ERR_LEC_30X\t(IR_STE\t| IR_FOE | IR_ACKE | IR_BE | IR_CRCE)\n#define IR_ERR_BUS_30X\t(IR_ERR_LEC_30X | IR_WDI | IR_BEU | IR_BEC | \\\n\t\t\t IR_TOO | IR_MRAF | IR_TSW | IR_TEFL | IR_RF1L | \\\n\t\t\t IR_RF0L)\n#define IR_ERR_ALL_30X\t(IR_ERR_STATE | IR_ERR_BUS_30X)\n\n \n#define IR_ERR_LEC_31X\t(IR_PED | IR_PEA)\n#define IR_ERR_BUS_31X\t(IR_ERR_LEC_31X | IR_WDI | IR_BEU | IR_BEC | \\\n\t\t\t IR_TOO | IR_MRAF | IR_TSW | IR_TEFL | IR_RF1L | \\\n\t\t\t IR_RF0L)\n#define IR_ERR_ALL_31X\t(IR_ERR_STATE | IR_ERR_BUS_31X)\n\n \n#define ILS_ALL_INT0\t0x0\n#define ILS_ALL_INT1\t0xFFFFFFFF\n\n \n#define ILE_EINT1\tBIT(1)\n#define ILE_EINT0\tBIT(0)\n\n \n#define RXFC_FWM_MASK\tGENMASK(30, 24)\n#define RXFC_FS_MASK\tGENMASK(22, 16)\n\n \n#define RXFS_RFL\tBIT(25)\n#define RXFS_FF\t\tBIT(24)\n#define RXFS_FPI_MASK\tGENMASK(21, 16)\n#define RXFS_FGI_MASK\tGENMASK(13, 8)\n#define RXFS_FFL_MASK\tGENMASK(6, 0)\n\n \n#define RXESC_RBDS_MASK\t\tGENMASK(10, 8)\n#define RXESC_F1DS_MASK\t\tGENMASK(6, 4)\n#define RXESC_F0DS_MASK\t\tGENMASK(2, 0)\n#define RXESC_64B\t\t0x7\n\n \n#define TXBC_TFQS_MASK\t\tGENMASK(29, 24)\n#define TXBC_NDTB_MASK\t\tGENMASK(21, 16)\n\n \n#define TXFQS_TFQF\t\tBIT(21)\n#define TXFQS_TFQPI_MASK\tGENMASK(20, 16)\n#define TXFQS_TFGI_MASK\t\tGENMASK(12, 8)\n#define TXFQS_TFFL_MASK\t\tGENMASK(5, 0)\n\n \n#define TXESC_TBDS_MASK\t\tGENMASK(2, 0)\n#define TXESC_TBDS_64B\t\t0x7\n\n \n#define TXEFC_EFS_MASK\t\tGENMASK(21, 16)\n\n \n#define TXEFS_TEFL\t\tBIT(25)\n#define TXEFS_EFF\t\tBIT(24)\n#define TXEFS_EFGI_MASK\t\tGENMASK(12, 8)\n#define TXEFS_EFFL_MASK\t\tGENMASK(5, 0)\n\n \n#define TXEFA_EFAI_MASK\t\tGENMASK(4, 0)\n\n \n#define SIDF_ELEMENT_SIZE\t4\n#define XIDF_ELEMENT_SIZE\t8\n#define RXF0_ELEMENT_SIZE\t72\n#define RXF1_ELEMENT_SIZE\t72\n#define RXB_ELEMENT_SIZE\t72\n#define TXE_ELEMENT_SIZE\t8\n#define TXB_ELEMENT_SIZE\t72\n\n \n#define M_CAN_FIFO_ID\t\t0x0\n#define M_CAN_FIFO_DLC\t\t0x4\n#define M_CAN_FIFO_DATA\t\t0x8\n\n \n \n#define RX_BUF_ESI\t\tBIT(31)\n#define RX_BUF_XTD\t\tBIT(30)\n#define RX_BUF_RTR\t\tBIT(29)\n \n#define RX_BUF_ANMF\t\tBIT(31)\n#define RX_BUF_FDF\t\tBIT(21)\n#define RX_BUF_BRS\t\tBIT(20)\n#define RX_BUF_RXTS_MASK\tGENMASK(15, 0)\n\n \n \n#define TX_BUF_ESI\t\tBIT(31)\n#define TX_BUF_XTD\t\tBIT(30)\n#define TX_BUF_RTR\t\tBIT(29)\n \n#define TX_BUF_EFC\t\tBIT(23)\n#define TX_BUF_FDF\t\tBIT(21)\n#define TX_BUF_BRS\t\tBIT(20)\n#define TX_BUF_MM_MASK\t\tGENMASK(31, 24)\n#define TX_BUF_DLC_MASK\t\tGENMASK(19, 16)\n\n \n \n#define TX_EVENT_MM_MASK\tGENMASK(31, 24)\n#define TX_EVENT_TXTS_MASK\tGENMASK(15, 0)\n\n \n#define HRTIMER_POLL_INTERVAL_MS\t\t1\n\n \nstruct id_and_dlc {\n\tu32 id;\n\tu32 dlc;\n};\n\nstatic inline u32 m_can_read(struct m_can_classdev *cdev, enum m_can_reg reg)\n{\n\treturn cdev->ops->read_reg(cdev, reg);\n}\n\nstatic inline void m_can_write(struct m_can_classdev *cdev, enum m_can_reg reg,\n\t\t\t       u32 val)\n{\n\tcdev->ops->write_reg(cdev, reg, val);\n}\n\nstatic int\nm_can_fifo_read(struct m_can_classdev *cdev,\n\t\tu32 fgi, unsigned int offset, void *val, size_t val_count)\n{\n\tu32 addr_offset = cdev->mcfg[MRAM_RXF0].off + fgi * RXF0_ELEMENT_SIZE +\n\t\toffset;\n\n\tif (val_count == 0)\n\t\treturn 0;\n\n\treturn cdev->ops->read_fifo(cdev, addr_offset, val, val_count);\n}\n\nstatic int\nm_can_fifo_write(struct m_can_classdev *cdev,\n\t\t u32 fpi, unsigned int offset, const void *val, size_t val_count)\n{\n\tu32 addr_offset = cdev->mcfg[MRAM_TXB].off + fpi * TXB_ELEMENT_SIZE +\n\t\toffset;\n\n\tif (val_count == 0)\n\t\treturn 0;\n\n\treturn cdev->ops->write_fifo(cdev, addr_offset, val, val_count);\n}\n\nstatic inline int m_can_fifo_write_no_off(struct m_can_classdev *cdev,\n\t\t\t\t\t  u32 fpi, u32 val)\n{\n\treturn cdev->ops->write_fifo(cdev, fpi, &val, 1);\n}\n\nstatic int\nm_can_txe_fifo_read(struct m_can_classdev *cdev, u32 fgi, u32 offset, u32 *val)\n{\n\tu32 addr_offset = cdev->mcfg[MRAM_TXE].off + fgi * TXE_ELEMENT_SIZE +\n\t\toffset;\n\n\treturn cdev->ops->read_fifo(cdev, addr_offset, val, 1);\n}\n\nstatic inline bool _m_can_tx_fifo_full(u32 txfqs)\n{\n\treturn !!(txfqs & TXFQS_TFQF);\n}\n\nstatic inline bool m_can_tx_fifo_full(struct m_can_classdev *cdev)\n{\n\treturn _m_can_tx_fifo_full(m_can_read(cdev, M_CAN_TXFQS));\n}\n\nstatic void m_can_config_endisable(struct m_can_classdev *cdev, bool enable)\n{\n\tu32 cccr = m_can_read(cdev, M_CAN_CCCR);\n\tu32 timeout = 10;\n\tu32 val = 0;\n\n\t \n\tif (cccr & CCCR_CSR)\n\t\tcccr &= ~CCCR_CSR;\n\n\tif (enable) {\n\t\t \n\t\tm_can_write(cdev, M_CAN_CCCR, cccr | CCCR_INIT);\n\t\tudelay(5);\n\t\t \n\t\tm_can_write(cdev, M_CAN_CCCR, cccr | CCCR_INIT | CCCR_CCE);\n\t} else {\n\t\tm_can_write(cdev, M_CAN_CCCR, cccr & ~(CCCR_INIT | CCCR_CCE));\n\t}\n\n\t \n\tif (enable)\n\t\tval = CCCR_INIT | CCCR_CCE;\n\n\twhile ((m_can_read(cdev, M_CAN_CCCR) & (CCCR_INIT | CCCR_CCE)) != val) {\n\t\tif (timeout == 0) {\n\t\t\tnetdev_warn(cdev->net, \"Failed to init module\\n\");\n\t\t\treturn;\n\t\t}\n\t\ttimeout--;\n\t\tudelay(1);\n\t}\n}\n\nstatic inline void m_can_enable_all_interrupts(struct m_can_classdev *cdev)\n{\n\t \n\tm_can_write(cdev, M_CAN_ILE, ILE_EINT0);\n}\n\nstatic inline void m_can_disable_all_interrupts(struct m_can_classdev *cdev)\n{\n\tm_can_write(cdev, M_CAN_ILE, 0x0);\n}\n\n \nstatic u32 m_can_get_timestamp(struct m_can_classdev *cdev)\n{\n\tu32 tscv;\n\tu32 tsc;\n\n\ttscv = m_can_read(cdev, M_CAN_TSCV);\n\ttsc = FIELD_GET(TSCV_TSC_MASK, tscv);\n\n\treturn (tsc << 16);\n}\n\nstatic void m_can_clean(struct net_device *net)\n{\n\tstruct m_can_classdev *cdev = netdev_priv(net);\n\n\tif (cdev->tx_skb) {\n\t\tint putidx = 0;\n\n\t\tnet->stats.tx_errors++;\n\t\tif (cdev->version > 30)\n\t\t\tputidx = FIELD_GET(TXFQS_TFQPI_MASK,\n\t\t\t\t\t   m_can_read(cdev, M_CAN_TXFQS));\n\n\t\tcan_free_echo_skb(cdev->net, putidx, NULL);\n\t\tcdev->tx_skb = NULL;\n\t}\n}\n\n \nstatic void m_can_receive_skb(struct m_can_classdev *cdev,\n\t\t\t      struct sk_buff *skb,\n\t\t\t      u32 timestamp)\n{\n\tif (cdev->is_peripheral) {\n\t\tstruct net_device_stats *stats = &cdev->net->stats;\n\t\tint err;\n\n\t\terr = can_rx_offload_queue_timestamp(&cdev->offload, skb,\n\t\t\t\t\t\t     timestamp);\n\t\tif (err)\n\t\t\tstats->rx_fifo_errors++;\n\t} else {\n\t\tnetif_receive_skb(skb);\n\t}\n}\n\nstatic int m_can_read_fifo(struct net_device *dev, u32 fgi)\n{\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct m_can_classdev *cdev = netdev_priv(dev);\n\tstruct canfd_frame *cf;\n\tstruct sk_buff *skb;\n\tstruct id_and_dlc fifo_header;\n\tu32 timestamp = 0;\n\tint err;\n\n\terr = m_can_fifo_read(cdev, fgi, M_CAN_FIFO_ID, &fifo_header, 2);\n\tif (err)\n\t\tgoto out_fail;\n\n\tif (fifo_header.dlc & RX_BUF_FDF)\n\t\tskb = alloc_canfd_skb(dev, &cf);\n\telse\n\t\tskb = alloc_can_skb(dev, (struct can_frame **)&cf);\n\tif (!skb) {\n\t\tstats->rx_dropped++;\n\t\treturn 0;\n\t}\n\n\tif (fifo_header.dlc & RX_BUF_FDF)\n\t\tcf->len = can_fd_dlc2len((fifo_header.dlc >> 16) & 0x0F);\n\telse\n\t\tcf->len = can_cc_dlc2len((fifo_header.dlc >> 16) & 0x0F);\n\n\tif (fifo_header.id & RX_BUF_XTD)\n\t\tcf->can_id = (fifo_header.id & CAN_EFF_MASK) | CAN_EFF_FLAG;\n\telse\n\t\tcf->can_id = (fifo_header.id >> 18) & CAN_SFF_MASK;\n\n\tif (fifo_header.id & RX_BUF_ESI) {\n\t\tcf->flags |= CANFD_ESI;\n\t\tnetdev_dbg(dev, \"ESI Error\\n\");\n\t}\n\n\tif (!(fifo_header.dlc & RX_BUF_FDF) && (fifo_header.id & RX_BUF_RTR)) {\n\t\tcf->can_id |= CAN_RTR_FLAG;\n\t} else {\n\t\tif (fifo_header.dlc & RX_BUF_BRS)\n\t\t\tcf->flags |= CANFD_BRS;\n\n\t\terr = m_can_fifo_read(cdev, fgi, M_CAN_FIFO_DATA,\n\t\t\t\t      cf->data, DIV_ROUND_UP(cf->len, 4));\n\t\tif (err)\n\t\t\tgoto out_free_skb;\n\n\t\tstats->rx_bytes += cf->len;\n\t}\n\tstats->rx_packets++;\n\n\ttimestamp = FIELD_GET(RX_BUF_RXTS_MASK, fifo_header.dlc) << 16;\n\n\tm_can_receive_skb(cdev, skb, timestamp);\n\n\treturn 0;\n\nout_free_skb:\n\tkfree_skb(skb);\nout_fail:\n\tnetdev_err(dev, \"FIFO read returned %d\\n\", err);\n\treturn err;\n}\n\nstatic int m_can_do_rx_poll(struct net_device *dev, int quota)\n{\n\tstruct m_can_classdev *cdev = netdev_priv(dev);\n\tu32 pkts = 0;\n\tu32 rxfs;\n\tu32 rx_count;\n\tu32 fgi;\n\tint ack_fgi = -1;\n\tint i;\n\tint err = 0;\n\n\trxfs = m_can_read(cdev, M_CAN_RXF0S);\n\tif (!(rxfs & RXFS_FFL_MASK)) {\n\t\tnetdev_dbg(dev, \"no messages in fifo0\\n\");\n\t\treturn 0;\n\t}\n\n\trx_count = FIELD_GET(RXFS_FFL_MASK, rxfs);\n\tfgi = FIELD_GET(RXFS_FGI_MASK, rxfs);\n\n\tfor (i = 0; i < rx_count && quota > 0; ++i) {\n\t\terr = m_can_read_fifo(dev, fgi);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tquota--;\n\t\tpkts++;\n\t\tack_fgi = fgi;\n\t\tfgi = (++fgi >= cdev->mcfg[MRAM_RXF0].num ? 0 : fgi);\n\t}\n\n\tif (ack_fgi != -1)\n\t\tm_can_write(cdev, M_CAN_RXF0A, ack_fgi);\n\n\tif (err)\n\t\treturn err;\n\n\treturn pkts;\n}\n\nstatic int m_can_handle_lost_msg(struct net_device *dev)\n{\n\tstruct m_can_classdev *cdev = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct sk_buff *skb;\n\tstruct can_frame *frame;\n\tu32 timestamp = 0;\n\n\tnetdev_err(dev, \"msg lost in rxf0\\n\");\n\n\tstats->rx_errors++;\n\tstats->rx_over_errors++;\n\n\tskb = alloc_can_err_skb(dev, &frame);\n\tif (unlikely(!skb))\n\t\treturn 0;\n\n\tframe->can_id |= CAN_ERR_CRTL;\n\tframe->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\n\tif (cdev->is_peripheral)\n\t\ttimestamp = m_can_get_timestamp(cdev);\n\n\tm_can_receive_skb(cdev, skb, timestamp);\n\n\treturn 1;\n}\n\nstatic int m_can_handle_lec_err(struct net_device *dev,\n\t\t\t\tenum m_can_lec_type lec_type)\n{\n\tstruct m_can_classdev *cdev = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tu32 timestamp = 0;\n\n\tcdev->can.can_stats.bus_error++;\n\tstats->rx_errors++;\n\n\t \n\tskb = alloc_can_err_skb(dev, &cf);\n\tif (unlikely(!skb))\n\t\treturn 0;\n\n\t \n\tcf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\n\n\tswitch (lec_type) {\n\tcase LEC_STUFF_ERROR:\n\t\tnetdev_dbg(dev, \"stuff error\\n\");\n\t\tcf->data[2] |= CAN_ERR_PROT_STUFF;\n\t\tbreak;\n\tcase LEC_FORM_ERROR:\n\t\tnetdev_dbg(dev, \"form error\\n\");\n\t\tcf->data[2] |= CAN_ERR_PROT_FORM;\n\t\tbreak;\n\tcase LEC_ACK_ERROR:\n\t\tnetdev_dbg(dev, \"ack error\\n\");\n\t\tcf->data[3] = CAN_ERR_PROT_LOC_ACK;\n\t\tbreak;\n\tcase LEC_BIT1_ERROR:\n\t\tnetdev_dbg(dev, \"bit1 error\\n\");\n\t\tcf->data[2] |= CAN_ERR_PROT_BIT1;\n\t\tbreak;\n\tcase LEC_BIT0_ERROR:\n\t\tnetdev_dbg(dev, \"bit0 error\\n\");\n\t\tcf->data[2] |= CAN_ERR_PROT_BIT0;\n\t\tbreak;\n\tcase LEC_CRC_ERROR:\n\t\tnetdev_dbg(dev, \"CRC error\\n\");\n\t\tcf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (cdev->is_peripheral)\n\t\ttimestamp = m_can_get_timestamp(cdev);\n\n\tm_can_receive_skb(cdev, skb, timestamp);\n\n\treturn 1;\n}\n\nstatic int __m_can_get_berr_counter(const struct net_device *dev,\n\t\t\t\t    struct can_berr_counter *bec)\n{\n\tstruct m_can_classdev *cdev = netdev_priv(dev);\n\tunsigned int ecr;\n\n\tecr = m_can_read(cdev, M_CAN_ECR);\n\tbec->rxerr = FIELD_GET(ECR_REC_MASK, ecr);\n\tbec->txerr = FIELD_GET(ECR_TEC_MASK, ecr);\n\n\treturn 0;\n}\n\nstatic int m_can_clk_start(struct m_can_classdev *cdev)\n{\n\tif (cdev->pm_clock_support == 0)\n\t\treturn 0;\n\n\treturn pm_runtime_resume_and_get(cdev->dev);\n}\n\nstatic void m_can_clk_stop(struct m_can_classdev *cdev)\n{\n\tif (cdev->pm_clock_support)\n\t\tpm_runtime_put_sync(cdev->dev);\n}\n\nstatic int m_can_get_berr_counter(const struct net_device *dev,\n\t\t\t\t  struct can_berr_counter *bec)\n{\n\tstruct m_can_classdev *cdev = netdev_priv(dev);\n\tint err;\n\n\terr = m_can_clk_start(cdev);\n\tif (err)\n\t\treturn err;\n\n\t__m_can_get_berr_counter(dev, bec);\n\n\tm_can_clk_stop(cdev);\n\n\treturn 0;\n}\n\nstatic int m_can_handle_state_change(struct net_device *dev,\n\t\t\t\t     enum can_state new_state)\n{\n\tstruct m_can_classdev *cdev = netdev_priv(dev);\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tstruct can_berr_counter bec;\n\tunsigned int ecr;\n\tu32 timestamp = 0;\n\n\tswitch (new_state) {\n\tcase CAN_STATE_ERROR_WARNING:\n\t\t \n\t\tcdev->can.can_stats.error_warning++;\n\t\tcdev->can.state = CAN_STATE_ERROR_WARNING;\n\t\tbreak;\n\tcase CAN_STATE_ERROR_PASSIVE:\n\t\t \n\t\tcdev->can.can_stats.error_passive++;\n\t\tcdev->can.state = CAN_STATE_ERROR_PASSIVE;\n\t\tbreak;\n\tcase CAN_STATE_BUS_OFF:\n\t\t \n\t\tcdev->can.state = CAN_STATE_BUS_OFF;\n\t\tm_can_disable_all_interrupts(cdev);\n\t\tcdev->can.can_stats.bus_off++;\n\t\tcan_bus_off(dev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tskb = alloc_can_err_skb(dev, &cf);\n\tif (unlikely(!skb))\n\t\treturn 0;\n\n\t__m_can_get_berr_counter(dev, &bec);\n\n\tswitch (new_state) {\n\tcase CAN_STATE_ERROR_WARNING:\n\t\t \n\t\tcf->can_id |= CAN_ERR_CRTL | CAN_ERR_CNT;\n\t\tcf->data[1] = (bec.txerr > bec.rxerr) ?\n\t\t\tCAN_ERR_CRTL_TX_WARNING :\n\t\t\tCAN_ERR_CRTL_RX_WARNING;\n\t\tcf->data[6] = bec.txerr;\n\t\tcf->data[7] = bec.rxerr;\n\t\tbreak;\n\tcase CAN_STATE_ERROR_PASSIVE:\n\t\t \n\t\tcf->can_id |= CAN_ERR_CRTL | CAN_ERR_CNT;\n\t\tecr = m_can_read(cdev, M_CAN_ECR);\n\t\tif (ecr & ECR_RP)\n\t\t\tcf->data[1] |= CAN_ERR_CRTL_RX_PASSIVE;\n\t\tif (bec.txerr > 127)\n\t\t\tcf->data[1] |= CAN_ERR_CRTL_TX_PASSIVE;\n\t\tcf->data[6] = bec.txerr;\n\t\tcf->data[7] = bec.rxerr;\n\t\tbreak;\n\tcase CAN_STATE_BUS_OFF:\n\t\t \n\t\tcf->can_id |= CAN_ERR_BUSOFF;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (cdev->is_peripheral)\n\t\ttimestamp = m_can_get_timestamp(cdev);\n\n\tm_can_receive_skb(cdev, skb, timestamp);\n\n\treturn 1;\n}\n\nstatic int m_can_handle_state_errors(struct net_device *dev, u32 psr)\n{\n\tstruct m_can_classdev *cdev = netdev_priv(dev);\n\tint work_done = 0;\n\n\tif (psr & PSR_EW && cdev->can.state != CAN_STATE_ERROR_WARNING) {\n\t\tnetdev_dbg(dev, \"entered error warning state\\n\");\n\t\twork_done += m_can_handle_state_change(dev,\n\t\t\t\t\t\t       CAN_STATE_ERROR_WARNING);\n\t}\n\n\tif (psr & PSR_EP && cdev->can.state != CAN_STATE_ERROR_PASSIVE) {\n\t\tnetdev_dbg(dev, \"entered error passive state\\n\");\n\t\twork_done += m_can_handle_state_change(dev,\n\t\t\t\t\t\t       CAN_STATE_ERROR_PASSIVE);\n\t}\n\n\tif (psr & PSR_BO && cdev->can.state != CAN_STATE_BUS_OFF) {\n\t\tnetdev_dbg(dev, \"entered error bus off state\\n\");\n\t\twork_done += m_can_handle_state_change(dev,\n\t\t\t\t\t\t       CAN_STATE_BUS_OFF);\n\t}\n\n\treturn work_done;\n}\n\nstatic void m_can_handle_other_err(struct net_device *dev, u32 irqstatus)\n{\n\tif (irqstatus & IR_WDI)\n\t\tnetdev_err(dev, \"Message RAM Watchdog event due to missing READY\\n\");\n\tif (irqstatus & IR_BEU)\n\t\tnetdev_err(dev, \"Bit Error Uncorrected\\n\");\n\tif (irqstatus & IR_BEC)\n\t\tnetdev_err(dev, \"Bit Error Corrected\\n\");\n\tif (irqstatus & IR_TOO)\n\t\tnetdev_err(dev, \"Timeout reached\\n\");\n\tif (irqstatus & IR_MRAF)\n\t\tnetdev_err(dev, \"Message RAM access failure occurred\\n\");\n}\n\nstatic inline bool is_lec_err(u8 lec)\n{\n\treturn lec != LEC_NO_ERROR && lec != LEC_NO_CHANGE;\n}\n\nstatic inline bool m_can_is_protocol_err(u32 irqstatus)\n{\n\treturn irqstatus & IR_ERR_LEC_31X;\n}\n\nstatic int m_can_handle_protocol_error(struct net_device *dev, u32 irqstatus)\n{\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct m_can_classdev *cdev = netdev_priv(dev);\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tu32 timestamp = 0;\n\n\t \n\tskb = alloc_can_err_skb(dev, &cf);\n\n\t \n\tstats->tx_errors++;\n\n\t \n\tif (cdev->version >= 31 && (irqstatus & IR_PEA)) {\n\t\tnetdev_dbg(dev, \"Protocol error in Arbitration fail\\n\");\n\t\tcdev->can.can_stats.arbitration_lost++;\n\t\tif (skb) {\n\t\t\tcf->can_id |= CAN_ERR_LOSTARB;\n\t\t\tcf->data[0] |= CAN_ERR_LOSTARB_UNSPEC;\n\t\t}\n\t}\n\n\tif (unlikely(!skb)) {\n\t\tnetdev_dbg(dev, \"allocation of skb failed\\n\");\n\t\treturn 0;\n\t}\n\n\tif (cdev->is_peripheral)\n\t\ttimestamp = m_can_get_timestamp(cdev);\n\n\tm_can_receive_skb(cdev, skb, timestamp);\n\n\treturn 1;\n}\n\nstatic int m_can_handle_bus_errors(struct net_device *dev, u32 irqstatus,\n\t\t\t\t   u32 psr)\n{\n\tstruct m_can_classdev *cdev = netdev_priv(dev);\n\tint work_done = 0;\n\n\tif (irqstatus & IR_RF0L)\n\t\twork_done += m_can_handle_lost_msg(dev);\n\n\t \n\tif (cdev->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING) {\n\t\tu8 lec = FIELD_GET(PSR_LEC_MASK, psr);\n\t\tu8 dlec = FIELD_GET(PSR_DLEC_MASK, psr);\n\n\t\tif (is_lec_err(lec)) {\n\t\t\tnetdev_dbg(dev, \"Arbitration phase error detected\\n\");\n\t\t\twork_done += m_can_handle_lec_err(dev, lec);\n\t\t}\n\n\t\tif (is_lec_err(dlec)) {\n\t\t\tnetdev_dbg(dev, \"Data phase error detected\\n\");\n\t\t\twork_done += m_can_handle_lec_err(dev, dlec);\n\t\t}\n\t}\n\n\t \n\tif ((cdev->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING) &&\n\t    m_can_is_protocol_err(irqstatus))\n\t\twork_done += m_can_handle_protocol_error(dev, irqstatus);\n\n\t \n\tm_can_handle_other_err(dev, irqstatus);\n\n\treturn work_done;\n}\n\nstatic int m_can_rx_handler(struct net_device *dev, int quota, u32 irqstatus)\n{\n\tstruct m_can_classdev *cdev = netdev_priv(dev);\n\tint rx_work_or_err;\n\tint work_done = 0;\n\n\tif (!irqstatus)\n\t\tgoto end;\n\n\t \n\tif (cdev->version <= 31 && irqstatus & IR_MRAF &&\n\t    m_can_read(cdev, M_CAN_ECR) & ECR_RP) {\n\t\tstruct can_berr_counter bec;\n\n\t\t__m_can_get_berr_counter(dev, &bec);\n\t\tif (bec.rxerr == 127) {\n\t\t\tm_can_write(cdev, M_CAN_IR, IR_MRAF);\n\t\t\tirqstatus &= ~IR_MRAF;\n\t\t}\n\t}\n\n\tif (irqstatus & IR_ERR_STATE)\n\t\twork_done += m_can_handle_state_errors(dev,\n\t\t\t\t\t\t       m_can_read(cdev, M_CAN_PSR));\n\n\tif (irqstatus & IR_ERR_BUS_30X)\n\t\twork_done += m_can_handle_bus_errors(dev, irqstatus,\n\t\t\t\t\t\t     m_can_read(cdev, M_CAN_PSR));\n\n\tif (irqstatus & IR_RF0N) {\n\t\trx_work_or_err = m_can_do_rx_poll(dev, (quota - work_done));\n\t\tif (rx_work_or_err < 0)\n\t\t\treturn rx_work_or_err;\n\n\t\twork_done += rx_work_or_err;\n\t}\nend:\n\treturn work_done;\n}\n\nstatic int m_can_rx_peripheral(struct net_device *dev, u32 irqstatus)\n{\n\tstruct m_can_classdev *cdev = netdev_priv(dev);\n\tint work_done;\n\n\twork_done = m_can_rx_handler(dev, NAPI_POLL_WEIGHT, irqstatus);\n\n\t \n\tif (work_done < 0)\n\t\tm_can_disable_all_interrupts(cdev);\n\n\treturn work_done;\n}\n\nstatic int m_can_poll(struct napi_struct *napi, int quota)\n{\n\tstruct net_device *dev = napi->dev;\n\tstruct m_can_classdev *cdev = netdev_priv(dev);\n\tint work_done;\n\tu32 irqstatus;\n\n\tirqstatus = cdev->irqstatus | m_can_read(cdev, M_CAN_IR);\n\n\twork_done = m_can_rx_handler(dev, quota, irqstatus);\n\n\t \n\tif (work_done >= 0 && work_done < quota) {\n\t\tnapi_complete_done(napi, work_done);\n\t\tm_can_enable_all_interrupts(cdev);\n\t}\n\n\treturn work_done;\n}\n\n \nstatic void m_can_tx_update_stats(struct m_can_classdev *cdev,\n\t\t\t\t  unsigned int msg_mark,\n\t\t\t\t  u32 timestamp)\n{\n\tstruct net_device *dev = cdev->net;\n\tstruct net_device_stats *stats = &dev->stats;\n\n\tif (cdev->is_peripheral)\n\t\tstats->tx_bytes +=\n\t\t\tcan_rx_offload_get_echo_skb_queue_timestamp(&cdev->offload,\n\t\t\t\t\t\t\t\t    msg_mark,\n\t\t\t\t\t\t\t\t    timestamp,\n\t\t\t\t\t\t\t\t    NULL);\n\telse\n\t\tstats->tx_bytes += can_get_echo_skb(dev, msg_mark, NULL);\n\n\tstats->tx_packets++;\n}\n\nstatic int m_can_echo_tx_event(struct net_device *dev)\n{\n\tu32 txe_count = 0;\n\tu32 m_can_txefs;\n\tu32 fgi = 0;\n\tint ack_fgi = -1;\n\tint i = 0;\n\tint err = 0;\n\tunsigned int msg_mark;\n\n\tstruct m_can_classdev *cdev = netdev_priv(dev);\n\n\t \n\tm_can_txefs = m_can_read(cdev, M_CAN_TXEFS);\n\n\t \n\ttxe_count = FIELD_GET(TXEFS_EFFL_MASK, m_can_txefs);\n\tfgi = FIELD_GET(TXEFS_EFGI_MASK, m_can_txefs);\n\n\t \n\tfor (i = 0; i < txe_count; i++) {\n\t\tu32 txe, timestamp = 0;\n\n\t\t \n\t\terr = m_can_txe_fifo_read(cdev, fgi, 4, &txe);\n\t\tif (err) {\n\t\t\tnetdev_err(dev, \"TXE FIFO read returned %d\\n\", err);\n\t\t\tbreak;\n\t\t}\n\n\t\tmsg_mark = FIELD_GET(TX_EVENT_MM_MASK, txe);\n\t\ttimestamp = FIELD_GET(TX_EVENT_TXTS_MASK, txe) << 16;\n\n\t\tack_fgi = fgi;\n\t\tfgi = (++fgi >= cdev->mcfg[MRAM_TXE].num ? 0 : fgi);\n\n\t\t \n\t\tm_can_tx_update_stats(cdev, msg_mark, timestamp);\n\t}\n\n\tif (ack_fgi != -1)\n\t\tm_can_write(cdev, M_CAN_TXEFA, FIELD_PREP(TXEFA_EFAI_MASK,\n\t\t\t\t\t\t\t  ack_fgi));\n\n\treturn err;\n}\n\nstatic irqreturn_t m_can_isr(int irq, void *dev_id)\n{\n\tstruct net_device *dev = (struct net_device *)dev_id;\n\tstruct m_can_classdev *cdev = netdev_priv(dev);\n\tu32 ir;\n\n\tif (pm_runtime_suspended(cdev->dev))\n\t\treturn IRQ_NONE;\n\tir = m_can_read(cdev, M_CAN_IR);\n\tif (!ir)\n\t\treturn IRQ_NONE;\n\n\t \n\tm_can_write(cdev, M_CAN_IR, ir);\n\n\tif (cdev->ops->clear_interrupts)\n\t\tcdev->ops->clear_interrupts(cdev);\n\n\t \n\tif ((ir & IR_RF0N) || (ir & IR_ERR_ALL_30X)) {\n\t\tcdev->irqstatus = ir;\n\t\tif (!cdev->is_peripheral) {\n\t\t\tm_can_disable_all_interrupts(cdev);\n\t\t\tnapi_schedule(&cdev->napi);\n\t\t} else if (m_can_rx_peripheral(dev, ir) < 0) {\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\tif (cdev->version == 30) {\n\t\tif (ir & IR_TC) {\n\t\t\t \n\t\t\tu32 timestamp = 0;\n\n\t\t\tif (cdev->is_peripheral)\n\t\t\t\ttimestamp = m_can_get_timestamp(cdev);\n\t\t\tm_can_tx_update_stats(cdev, 0, timestamp);\n\t\t\tnetif_wake_queue(dev);\n\t\t}\n\t} else  {\n\t\tif (ir & IR_TEFN) {\n\t\t\t \n\t\t\tif (m_can_echo_tx_event(dev) != 0)\n\t\t\t\tgoto out_fail;\n\n\t\t\tif (netif_queue_stopped(dev) &&\n\t\t\t    !m_can_tx_fifo_full(cdev))\n\t\t\t\tnetif_wake_queue(dev);\n\t\t}\n\t}\n\n\tif (cdev->is_peripheral)\n\t\tcan_rx_offload_threaded_irq_finish(&cdev->offload);\n\n\treturn IRQ_HANDLED;\n\nout_fail:\n\tm_can_disable_all_interrupts(cdev);\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct can_bittiming_const m_can_bittiming_const_30X = {\n\t.name = KBUILD_MODNAME,\n\t.tseg1_min = 2,\t\t \n\t.tseg1_max = 64,\n\t.tseg2_min = 1,\t\t \n\t.tseg2_max = 16,\n\t.sjw_max = 16,\n\t.brp_min = 1,\n\t.brp_max = 1024,\n\t.brp_inc = 1,\n};\n\nstatic const struct can_bittiming_const m_can_data_bittiming_const_30X = {\n\t.name = KBUILD_MODNAME,\n\t.tseg1_min = 2,\t\t \n\t.tseg1_max = 16,\n\t.tseg2_min = 1,\t\t \n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 32,\n\t.brp_inc = 1,\n};\n\nstatic const struct can_bittiming_const m_can_bittiming_const_31X = {\n\t.name = KBUILD_MODNAME,\n\t.tseg1_min = 2,\t\t \n\t.tseg1_max = 256,\n\t.tseg2_min = 2,\t\t \n\t.tseg2_max = 128,\n\t.sjw_max = 128,\n\t.brp_min = 1,\n\t.brp_max = 512,\n\t.brp_inc = 1,\n};\n\nstatic const struct can_bittiming_const m_can_data_bittiming_const_31X = {\n\t.name = KBUILD_MODNAME,\n\t.tseg1_min = 1,\t\t \n\t.tseg1_max = 32,\n\t.tseg2_min = 1,\t\t \n\t.tseg2_max = 16,\n\t.sjw_max = 16,\n\t.brp_min = 1,\n\t.brp_max = 32,\n\t.brp_inc = 1,\n};\n\nstatic int m_can_set_bittiming(struct net_device *dev)\n{\n\tstruct m_can_classdev *cdev = netdev_priv(dev);\n\tconst struct can_bittiming *bt = &cdev->can.bittiming;\n\tconst struct can_bittiming *dbt = &cdev->can.data_bittiming;\n\tu16 brp, sjw, tseg1, tseg2;\n\tu32 reg_btp;\n\n\tbrp = bt->brp - 1;\n\tsjw = bt->sjw - 1;\n\ttseg1 = bt->prop_seg + bt->phase_seg1 - 1;\n\ttseg2 = bt->phase_seg2 - 1;\n\treg_btp = FIELD_PREP(NBTP_NBRP_MASK, brp) |\n\t\t  FIELD_PREP(NBTP_NSJW_MASK, sjw) |\n\t\t  FIELD_PREP(NBTP_NTSEG1_MASK, tseg1) |\n\t\t  FIELD_PREP(NBTP_NTSEG2_MASK, tseg2);\n\tm_can_write(cdev, M_CAN_NBTP, reg_btp);\n\n\tif (cdev->can.ctrlmode & CAN_CTRLMODE_FD) {\n\t\treg_btp = 0;\n\t\tbrp = dbt->brp - 1;\n\t\tsjw = dbt->sjw - 1;\n\t\ttseg1 = dbt->prop_seg + dbt->phase_seg1 - 1;\n\t\ttseg2 = dbt->phase_seg2 - 1;\n\n\t\t \n\t\tif (dbt->bitrate > 2500000) {\n\t\t\tu32 tdco, ssp;\n\n\t\t\t \n\t\t\tssp = dbt->sample_point;\n\n\t\t\t \n\t\t\ttdco = (cdev->can.clock.freq / 1000) *\n\t\t\t\tssp / dbt->bitrate;\n\n\t\t\t \n\t\t\tif (tdco > 127) {\n\t\t\t\tnetdev_warn(dev, \"TDCO value of %u is beyond maximum. Using maximum possible value\\n\",\n\t\t\t\t\t    tdco);\n\t\t\t\ttdco = 127;\n\t\t\t}\n\n\t\t\treg_btp |= DBTP_TDC;\n\t\t\tm_can_write(cdev, M_CAN_TDCR,\n\t\t\t\t    FIELD_PREP(TDCR_TDCO_MASK, tdco));\n\t\t}\n\n\t\treg_btp |= FIELD_PREP(DBTP_DBRP_MASK, brp) |\n\t\t\tFIELD_PREP(DBTP_DSJW_MASK, sjw) |\n\t\t\tFIELD_PREP(DBTP_DTSEG1_MASK, tseg1) |\n\t\t\tFIELD_PREP(DBTP_DTSEG2_MASK, tseg2);\n\n\t\tm_can_write(cdev, M_CAN_DBTP, reg_btp);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int m_can_chip_config(struct net_device *dev)\n{\n\tstruct m_can_classdev *cdev = netdev_priv(dev);\n\tu32 interrupts = IR_ALL_INT;\n\tu32 cccr, test;\n\tint err;\n\n\terr = m_can_init_ram(cdev);\n\tif (err) {\n\t\tdev_err(cdev->dev, \"Message RAM configuration failed\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tinterrupts &= ~(IR_ARA | IR_ELO | IR_DRX | IR_TEFF | IR_TEFW | IR_TFE |\n\t\t\tIR_TCF | IR_HPM | IR_RF1F | IR_RF1W | IR_RF1N |\n\t\t\tIR_RF0F | IR_RF0W);\n\n\tm_can_config_endisable(cdev, true);\n\n\t \n\tm_can_write(cdev, M_CAN_RXESC,\n\t\t    FIELD_PREP(RXESC_RBDS_MASK, RXESC_64B) |\n\t\t    FIELD_PREP(RXESC_F1DS_MASK, RXESC_64B) |\n\t\t    FIELD_PREP(RXESC_F0DS_MASK, RXESC_64B));\n\n\t \n\tm_can_write(cdev, M_CAN_GFC, 0x0);\n\n\tif (cdev->version == 30) {\n\t\t \n\t\tm_can_write(cdev, M_CAN_TXBC, FIELD_PREP(TXBC_NDTB_MASK, 1) |\n\t\t\t    cdev->mcfg[MRAM_TXB].off);\n\t} else {\n\t\t \n\t\tm_can_write(cdev, M_CAN_TXBC,\n\t\t\t    FIELD_PREP(TXBC_TFQS_MASK,\n\t\t\t\t       cdev->mcfg[MRAM_TXB].num) |\n\t\t\t    cdev->mcfg[MRAM_TXB].off);\n\t}\n\n\t \n\tm_can_write(cdev, M_CAN_TXESC,\n\t\t    FIELD_PREP(TXESC_TBDS_MASK, TXESC_TBDS_64B));\n\n\t \n\tif (cdev->version == 30) {\n\t\tm_can_write(cdev, M_CAN_TXEFC,\n\t\t\t    FIELD_PREP(TXEFC_EFS_MASK, 1) |\n\t\t\t    cdev->mcfg[MRAM_TXE].off);\n\t} else {\n\t\t \n\t\tm_can_write(cdev, M_CAN_TXEFC,\n\t\t\t    FIELD_PREP(TXEFC_EFS_MASK,\n\t\t\t\t       cdev->mcfg[MRAM_TXE].num) |\n\t\t\t    cdev->mcfg[MRAM_TXE].off);\n\t}\n\n\t \n\tm_can_write(cdev, M_CAN_RXF0C,\n\t\t    FIELD_PREP(RXFC_FS_MASK, cdev->mcfg[MRAM_RXF0].num) |\n\t\t    cdev->mcfg[MRAM_RXF0].off);\n\n\tm_can_write(cdev, M_CAN_RXF1C,\n\t\t    FIELD_PREP(RXFC_FS_MASK, cdev->mcfg[MRAM_RXF1].num) |\n\t\t    cdev->mcfg[MRAM_RXF1].off);\n\n\tcccr = m_can_read(cdev, M_CAN_CCCR);\n\ttest = m_can_read(cdev, M_CAN_TEST);\n\ttest &= ~TEST_LBCK;\n\tif (cdev->version == 30) {\n\t\t \n\n\t\tcccr &= ~(CCCR_TEST | CCCR_MON | CCCR_DAR |\n\t\t\t  FIELD_PREP(CCCR_CMR_MASK, FIELD_MAX(CCCR_CMR_MASK)) |\n\t\t\t  FIELD_PREP(CCCR_CME_MASK, FIELD_MAX(CCCR_CME_MASK)));\n\n\t\tif (cdev->can.ctrlmode & CAN_CTRLMODE_FD)\n\t\t\tcccr |= FIELD_PREP(CCCR_CME_MASK, CCCR_CME_CANFD_BRS);\n\n\t} else {\n\t\t \n\t\tcccr &= ~(CCCR_TEST | CCCR_MON | CCCR_BRSE | CCCR_FDOE |\n\t\t\t  CCCR_NISO | CCCR_DAR);\n\n\t\t \n\t\tif (cdev->can.ctrlmode & CAN_CTRLMODE_FD_NON_ISO)\n\t\t\tcccr |= CCCR_NISO;\n\n\t\tif (cdev->can.ctrlmode & CAN_CTRLMODE_FD)\n\t\t\tcccr |= (CCCR_BRSE | CCCR_FDOE);\n\t}\n\n\t \n\tif (cdev->can.ctrlmode & CAN_CTRLMODE_LOOPBACK) {\n\t\tcccr |= CCCR_TEST | CCCR_MON;\n\t\ttest |= TEST_LBCK;\n\t}\n\n\t \n\tif (cdev->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tcccr |= CCCR_MON;\n\n\t \n\tif (cdev->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)\n\t\tcccr |= CCCR_DAR;\n\n\t \n\tm_can_write(cdev, M_CAN_CCCR, cccr);\n\tm_can_write(cdev, M_CAN_TEST, test);\n\n\t \n\tif (!(cdev->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING)) {\n\t\tif (cdev->version == 30)\n\t\t\tinterrupts &= ~(IR_ERR_LEC_30X);\n\t\telse\n\t\t\tinterrupts &= ~(IR_ERR_LEC_31X);\n\t}\n\tm_can_write(cdev, M_CAN_IE, interrupts);\n\n\t \n\tm_can_write(cdev, M_CAN_ILS, ILS_ALL_INT0);\n\n\t \n\tm_can_set_bittiming(dev);\n\n\t \n\tm_can_write(cdev, M_CAN_TSCC,\n\t\t    FIELD_PREP(TSCC_TCP_MASK, 0xf) |\n\t\t    FIELD_PREP(TSCC_TSS_MASK, TSCC_TSS_INTERNAL));\n\n\tm_can_config_endisable(cdev, false);\n\n\tif (cdev->ops->init)\n\t\tcdev->ops->init(cdev);\n\n\treturn 0;\n}\n\nstatic int m_can_start(struct net_device *dev)\n{\n\tstruct m_can_classdev *cdev = netdev_priv(dev);\n\tint ret;\n\n\t \n\tret = m_can_chip_config(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tcdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\tm_can_enable_all_interrupts(cdev);\n\n\tif (!dev->irq) {\n\t\tdev_dbg(cdev->dev, \"Start hrtimer\\n\");\n\t\thrtimer_start(&cdev->hrtimer, ms_to_ktime(HRTIMER_POLL_INTERVAL_MS),\n\t\t\t      HRTIMER_MODE_REL_PINNED);\n\t}\n\n\treturn 0;\n}\n\nstatic int m_can_set_mode(struct net_device *dev, enum can_mode mode)\n{\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\tm_can_clean(dev);\n\t\tm_can_start(dev);\n\t\tnetif_wake_queue(dev);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int m_can_check_core_release(struct m_can_classdev *cdev)\n{\n\tu32 crel_reg;\n\tu8 rel;\n\tu8 step;\n\tint res;\n\n\t \n\tcrel_reg = m_can_read(cdev, M_CAN_CREL);\n\trel = (u8)FIELD_GET(CREL_REL_MASK, crel_reg);\n\tstep = (u8)FIELD_GET(CREL_STEP_MASK, crel_reg);\n\n\tif (rel == 3) {\n\t\t \n\t\tres = 30 + step;\n\t} else {\n\t\t \n\t\tres = 0;\n\t}\n\n\treturn res;\n}\n\n \nstatic bool m_can_niso_supported(struct m_can_classdev *cdev)\n{\n\tu32 cccr_reg, cccr_poll = 0;\n\tint niso_timeout = -ETIMEDOUT;\n\tint i;\n\n\tm_can_config_endisable(cdev, true);\n\tcccr_reg = m_can_read(cdev, M_CAN_CCCR);\n\tcccr_reg |= CCCR_NISO;\n\tm_can_write(cdev, M_CAN_CCCR, cccr_reg);\n\n\tfor (i = 0; i <= 10; i++) {\n\t\tcccr_poll = m_can_read(cdev, M_CAN_CCCR);\n\t\tif (cccr_poll == cccr_reg) {\n\t\t\tniso_timeout = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tusleep_range(1, 5);\n\t}\n\n\t \n\tcccr_reg &= ~(CCCR_NISO);\n\tm_can_write(cdev, M_CAN_CCCR, cccr_reg);\n\n\tm_can_config_endisable(cdev, false);\n\n\t \n\treturn !niso_timeout;\n}\n\nstatic int m_can_dev_setup(struct m_can_classdev *cdev)\n{\n\tstruct net_device *dev = cdev->net;\n\tint m_can_version, err;\n\n\tm_can_version = m_can_check_core_release(cdev);\n\t \n\tif (!m_can_version) {\n\t\tdev_err(cdev->dev, \"Unsupported version number: %2d\",\n\t\t\tm_can_version);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!cdev->is_peripheral)\n\t\tnetif_napi_add(dev, &cdev->napi, m_can_poll);\n\n\t \n\tcdev->version = m_can_version;\n\tcdev->can.do_set_mode = m_can_set_mode;\n\tcdev->can.do_get_berr_counter = m_can_get_berr_counter;\n\n\t \n\tcdev->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |\n\t\tCAN_CTRLMODE_LISTENONLY |\n\t\tCAN_CTRLMODE_BERR_REPORTING |\n\t\tCAN_CTRLMODE_FD |\n\t\tCAN_CTRLMODE_ONE_SHOT;\n\n\t \n\tswitch (cdev->version) {\n\tcase 30:\n\t\t \n\t\terr = can_set_static_ctrlmode(dev, CAN_CTRLMODE_FD_NON_ISO);\n\t\tif (err)\n\t\t\treturn err;\n\t\tcdev->can.bittiming_const = &m_can_bittiming_const_30X;\n\t\tcdev->can.data_bittiming_const = &m_can_data_bittiming_const_30X;\n\t\tbreak;\n\tcase 31:\n\t\t \n\t\terr = can_set_static_ctrlmode(dev, CAN_CTRLMODE_FD_NON_ISO);\n\t\tif (err)\n\t\t\treturn err;\n\t\tcdev->can.bittiming_const = &m_can_bittiming_const_31X;\n\t\tcdev->can.data_bittiming_const = &m_can_data_bittiming_const_31X;\n\t\tbreak;\n\tcase 32:\n\tcase 33:\n\t\t \n\t\tcdev->can.bittiming_const = &m_can_bittiming_const_31X;\n\t\tcdev->can.data_bittiming_const = &m_can_data_bittiming_const_31X;\n\n\t\tcdev->can.ctrlmode_supported |=\n\t\t\t(m_can_niso_supported(cdev) ?\n\t\t\t CAN_CTRLMODE_FD_NON_ISO : 0);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cdev->dev, \"Unsupported version number: %2d\",\n\t\t\tcdev->version);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cdev->ops->init)\n\t\tcdev->ops->init(cdev);\n\n\treturn 0;\n}\n\nstatic void m_can_stop(struct net_device *dev)\n{\n\tstruct m_can_classdev *cdev = netdev_priv(dev);\n\n\tif (!dev->irq) {\n\t\tdev_dbg(cdev->dev, \"Stop hrtimer\\n\");\n\t\thrtimer_cancel(&cdev->hrtimer);\n\t}\n\n\t \n\tm_can_disable_all_interrupts(cdev);\n\n\t \n\tm_can_config_endisable(cdev, true);\n\n\t \n\tcdev->can.state = CAN_STATE_STOPPED;\n}\n\nstatic int m_can_close(struct net_device *dev)\n{\n\tstruct m_can_classdev *cdev = netdev_priv(dev);\n\n\tnetif_stop_queue(dev);\n\n\tif (!cdev->is_peripheral)\n\t\tnapi_disable(&cdev->napi);\n\n\tm_can_stop(dev);\n\tm_can_clk_stop(cdev);\n\tfree_irq(dev->irq, dev);\n\n\tif (cdev->is_peripheral) {\n\t\tcdev->tx_skb = NULL;\n\t\tdestroy_workqueue(cdev->tx_wq);\n\t\tcdev->tx_wq = NULL;\n\t\tcan_rx_offload_disable(&cdev->offload);\n\t}\n\n\tclose_candev(dev);\n\n\tphy_power_off(cdev->transceiver);\n\n\treturn 0;\n}\n\nstatic int m_can_next_echo_skb_occupied(struct net_device *dev, int putidx)\n{\n\tstruct m_can_classdev *cdev = netdev_priv(dev);\n\t \n\tunsigned int wrap = cdev->can.echo_skb_max;\n\tint next_idx;\n\n\t \n\tnext_idx = (++putidx >= wrap ? 0 : putidx);\n\n\t \n\treturn !!cdev->can.echo_skb[next_idx];\n}\n\nstatic netdev_tx_t m_can_tx_handler(struct m_can_classdev *cdev)\n{\n\tstruct canfd_frame *cf = (struct canfd_frame *)cdev->tx_skb->data;\n\tstruct net_device *dev = cdev->net;\n\tstruct sk_buff *skb = cdev->tx_skb;\n\tstruct id_and_dlc fifo_header;\n\tu32 cccr, fdflags;\n\tu32 txfqs;\n\tint err;\n\tint putidx;\n\n\tcdev->tx_skb = NULL;\n\n\t \n\t \n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\tfifo_header.id = cf->can_id & CAN_EFF_MASK;\n\t\tfifo_header.id |= TX_BUF_XTD;\n\t} else {\n\t\tfifo_header.id = ((cf->can_id & CAN_SFF_MASK) << 18);\n\t}\n\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tfifo_header.id |= TX_BUF_RTR;\n\n\tif (cdev->version == 30) {\n\t\tnetif_stop_queue(dev);\n\n\t\tfifo_header.dlc = can_fd_len2dlc(cf->len) << 16;\n\n\t\t \n\t\terr = m_can_fifo_write(cdev, 0, M_CAN_FIFO_ID, &fifo_header, 2);\n\t\tif (err)\n\t\t\tgoto out_fail;\n\n\t\terr = m_can_fifo_write(cdev, 0, M_CAN_FIFO_DATA,\n\t\t\t\t       cf->data, DIV_ROUND_UP(cf->len, 4));\n\t\tif (err)\n\t\t\tgoto out_fail;\n\n\t\tif (cdev->can.ctrlmode & CAN_CTRLMODE_FD) {\n\t\t\tcccr = m_can_read(cdev, M_CAN_CCCR);\n\t\t\tcccr &= ~CCCR_CMR_MASK;\n\t\t\tif (can_is_canfd_skb(skb)) {\n\t\t\t\tif (cf->flags & CANFD_BRS)\n\t\t\t\t\tcccr |= FIELD_PREP(CCCR_CMR_MASK,\n\t\t\t\t\t\t\t   CCCR_CMR_CANFD_BRS);\n\t\t\t\telse\n\t\t\t\t\tcccr |= FIELD_PREP(CCCR_CMR_MASK,\n\t\t\t\t\t\t\t   CCCR_CMR_CANFD);\n\t\t\t} else {\n\t\t\t\tcccr |= FIELD_PREP(CCCR_CMR_MASK, CCCR_CMR_CAN);\n\t\t\t}\n\t\t\tm_can_write(cdev, M_CAN_CCCR, cccr);\n\t\t}\n\t\tm_can_write(cdev, M_CAN_TXBTIE, 0x1);\n\n\t\tcan_put_echo_skb(skb, dev, 0, 0);\n\n\t\tm_can_write(cdev, M_CAN_TXBAR, 0x1);\n\t\t \n\t} else {\n\t\t \n\n\t\ttxfqs = m_can_read(cdev, M_CAN_TXFQS);\n\n\t\t \n\t\tif (_m_can_tx_fifo_full(txfqs)) {\n\t\t\t \n\t\t\tnetif_stop_queue(dev);\n\t\t\tnetdev_warn(dev,\n\t\t\t\t    \"TX queue active although FIFO is full.\");\n\n\t\t\tif (cdev->is_peripheral) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tdev->stats.tx_dropped++;\n\t\t\t\treturn NETDEV_TX_OK;\n\t\t\t} else {\n\t\t\t\treturn NETDEV_TX_BUSY;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tputidx = FIELD_GET(TXFQS_TFQPI_MASK, txfqs);\n\n\t\t \n\n\t\t \n\t\tfdflags = 0;\n\t\tif (can_is_canfd_skb(skb)) {\n\t\t\tfdflags |= TX_BUF_FDF;\n\t\t\tif (cf->flags & CANFD_BRS)\n\t\t\t\tfdflags |= TX_BUF_BRS;\n\t\t}\n\n\t\tfifo_header.dlc = FIELD_PREP(TX_BUF_MM_MASK, putidx) |\n\t\t\tFIELD_PREP(TX_BUF_DLC_MASK, can_fd_len2dlc(cf->len)) |\n\t\t\tfdflags | TX_BUF_EFC;\n\t\terr = m_can_fifo_write(cdev, putidx, M_CAN_FIFO_ID, &fifo_header, 2);\n\t\tif (err)\n\t\t\tgoto out_fail;\n\n\t\terr = m_can_fifo_write(cdev, putidx, M_CAN_FIFO_DATA,\n\t\t\t\t       cf->data, DIV_ROUND_UP(cf->len, 4));\n\t\tif (err)\n\t\t\tgoto out_fail;\n\n\t\t \n\t\tcan_put_echo_skb(skb, dev, putidx, 0);\n\n\t\t \n\t\tm_can_write(cdev, M_CAN_TXBAR, (1 << putidx));\n\n\t\t \n\t\tif (m_can_tx_fifo_full(cdev) ||\n\t\t    m_can_next_echo_skb_occupied(dev, putidx))\n\t\t\tnetif_stop_queue(dev);\n\t}\n\n\treturn NETDEV_TX_OK;\n\nout_fail:\n\tnetdev_err(dev, \"FIFO write returned %d\\n\", err);\n\tm_can_disable_all_interrupts(cdev);\n\treturn NETDEV_TX_BUSY;\n}\n\nstatic void m_can_tx_work_queue(struct work_struct *ws)\n{\n\tstruct m_can_classdev *cdev = container_of(ws, struct m_can_classdev,\n\t\t\t\t\t\t   tx_work);\n\n\tm_can_tx_handler(cdev);\n}\n\nstatic netdev_tx_t m_can_start_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *dev)\n{\n\tstruct m_can_classdev *cdev = netdev_priv(dev);\n\n\tif (can_dev_dropped_skb(dev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tif (cdev->is_peripheral) {\n\t\tif (cdev->tx_skb) {\n\t\t\tnetdev_err(dev, \"hard_xmit called while tx busy\\n\");\n\t\t\treturn NETDEV_TX_BUSY;\n\t\t}\n\n\t\tif (cdev->can.state == CAN_STATE_BUS_OFF) {\n\t\t\tm_can_clean(dev);\n\t\t} else {\n\t\t\t \n\t\t\tcdev->tx_skb = skb;\n\t\t\tnetif_stop_queue(cdev->net);\n\t\t\tqueue_work(cdev->tx_wq, &cdev->tx_work);\n\t\t}\n\t} else {\n\t\tcdev->tx_skb = skb;\n\t\treturn m_can_tx_handler(cdev);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic enum hrtimer_restart hrtimer_callback(struct hrtimer *timer)\n{\n\tstruct m_can_classdev *cdev = container_of(timer, struct\n\t\t\t\t\t\t   m_can_classdev, hrtimer);\n\n\tm_can_isr(0, cdev->net);\n\n\thrtimer_forward_now(timer, ms_to_ktime(HRTIMER_POLL_INTERVAL_MS));\n\n\treturn HRTIMER_RESTART;\n}\n\nstatic int m_can_open(struct net_device *dev)\n{\n\tstruct m_can_classdev *cdev = netdev_priv(dev);\n\tint err;\n\n\terr = phy_power_on(cdev->transceiver);\n\tif (err)\n\t\treturn err;\n\n\terr = m_can_clk_start(cdev);\n\tif (err)\n\t\tgoto out_phy_power_off;\n\n\t \n\terr = open_candev(dev);\n\tif (err) {\n\t\tnetdev_err(dev, \"failed to open can device\\n\");\n\t\tgoto exit_disable_clks;\n\t}\n\n\tif (cdev->is_peripheral)\n\t\tcan_rx_offload_enable(&cdev->offload);\n\n\t \n\tif (cdev->is_peripheral) {\n\t\tcdev->tx_skb = NULL;\n\t\tcdev->tx_wq = alloc_workqueue(\"mcan_wq\",\n\t\t\t\t\t      WQ_FREEZABLE | WQ_MEM_RECLAIM, 0);\n\t\tif (!cdev->tx_wq) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_wq_fail;\n\t\t}\n\n\t\tINIT_WORK(&cdev->tx_work, m_can_tx_work_queue);\n\n\t\terr = request_threaded_irq(dev->irq, NULL, m_can_isr,\n\t\t\t\t\t   IRQF_ONESHOT,\n\t\t\t\t\t   dev->name, dev);\n\t} else if (dev->irq) {\n\t\terr = request_irq(dev->irq, m_can_isr, IRQF_SHARED, dev->name,\n\t\t\t\t  dev);\n\t}\n\n\tif (err < 0) {\n\t\tnetdev_err(dev, \"failed to request interrupt\\n\");\n\t\tgoto exit_irq_fail;\n\t}\n\n\t \n\terr = m_can_start(dev);\n\tif (err)\n\t\tgoto exit_irq_fail;\n\n\tif (!cdev->is_peripheral)\n\t\tnapi_enable(&cdev->napi);\n\n\tnetif_start_queue(dev);\n\n\treturn 0;\n\nexit_irq_fail:\n\tif (cdev->is_peripheral)\n\t\tdestroy_workqueue(cdev->tx_wq);\nout_wq_fail:\n\tif (cdev->is_peripheral)\n\t\tcan_rx_offload_disable(&cdev->offload);\n\tclose_candev(dev);\nexit_disable_clks:\n\tm_can_clk_stop(cdev);\nout_phy_power_off:\n\tphy_power_off(cdev->transceiver);\n\treturn err;\n}\n\nstatic const struct net_device_ops m_can_netdev_ops = {\n\t.ndo_open = m_can_open,\n\t.ndo_stop = m_can_close,\n\t.ndo_start_xmit = m_can_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic const struct ethtool_ops m_can_ethtool_ops = {\n\t.get_ts_info = ethtool_op_get_ts_info,\n};\n\nstatic int register_m_can_dev(struct net_device *dev)\n{\n\tdev->flags |= IFF_ECHO;\t \n\tdev->netdev_ops = &m_can_netdev_ops;\n\tdev->ethtool_ops = &m_can_ethtool_ops;\n\n\treturn register_candev(dev);\n}\n\nint m_can_check_mram_cfg(struct m_can_classdev *cdev, u32 mram_max_size)\n{\n\tu32 total_size;\n\n\ttotal_size = cdev->mcfg[MRAM_TXB].off - cdev->mcfg[MRAM_SIDF].off +\n\t\t\tcdev->mcfg[MRAM_TXB].num * TXB_ELEMENT_SIZE;\n\tif (total_size > mram_max_size) {\n\t\tdev_err(cdev->dev, \"Total size of mram config(%u) exceeds mram(%u)\\n\",\n\t\t\ttotal_size, mram_max_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(m_can_check_mram_cfg);\n\nstatic void m_can_of_parse_mram(struct m_can_classdev *cdev,\n\t\t\t\tconst u32 *mram_config_vals)\n{\n\tcdev->mcfg[MRAM_SIDF].off = mram_config_vals[0];\n\tcdev->mcfg[MRAM_SIDF].num = mram_config_vals[1];\n\tcdev->mcfg[MRAM_XIDF].off = cdev->mcfg[MRAM_SIDF].off +\n\t\tcdev->mcfg[MRAM_SIDF].num * SIDF_ELEMENT_SIZE;\n\tcdev->mcfg[MRAM_XIDF].num = mram_config_vals[2];\n\tcdev->mcfg[MRAM_RXF0].off = cdev->mcfg[MRAM_XIDF].off +\n\t\tcdev->mcfg[MRAM_XIDF].num * XIDF_ELEMENT_SIZE;\n\tcdev->mcfg[MRAM_RXF0].num = mram_config_vals[3] &\n\t\tFIELD_MAX(RXFC_FS_MASK);\n\tcdev->mcfg[MRAM_RXF1].off = cdev->mcfg[MRAM_RXF0].off +\n\t\tcdev->mcfg[MRAM_RXF0].num * RXF0_ELEMENT_SIZE;\n\tcdev->mcfg[MRAM_RXF1].num = mram_config_vals[4] &\n\t\tFIELD_MAX(RXFC_FS_MASK);\n\tcdev->mcfg[MRAM_RXB].off = cdev->mcfg[MRAM_RXF1].off +\n\t\tcdev->mcfg[MRAM_RXF1].num * RXF1_ELEMENT_SIZE;\n\tcdev->mcfg[MRAM_RXB].num = mram_config_vals[5];\n\tcdev->mcfg[MRAM_TXE].off = cdev->mcfg[MRAM_RXB].off +\n\t\tcdev->mcfg[MRAM_RXB].num * RXB_ELEMENT_SIZE;\n\tcdev->mcfg[MRAM_TXE].num = mram_config_vals[6];\n\tcdev->mcfg[MRAM_TXB].off = cdev->mcfg[MRAM_TXE].off +\n\t\tcdev->mcfg[MRAM_TXE].num * TXE_ELEMENT_SIZE;\n\tcdev->mcfg[MRAM_TXB].num = mram_config_vals[7] &\n\t\tFIELD_MAX(TXBC_NDTB_MASK);\n\n\tdev_dbg(cdev->dev,\n\t\t\"sidf 0x%x %d xidf 0x%x %d rxf0 0x%x %d rxf1 0x%x %d rxb 0x%x %d txe 0x%x %d txb 0x%x %d\\n\",\n\t\tcdev->mcfg[MRAM_SIDF].off, cdev->mcfg[MRAM_SIDF].num,\n\t\tcdev->mcfg[MRAM_XIDF].off, cdev->mcfg[MRAM_XIDF].num,\n\t\tcdev->mcfg[MRAM_RXF0].off, cdev->mcfg[MRAM_RXF0].num,\n\t\tcdev->mcfg[MRAM_RXF1].off, cdev->mcfg[MRAM_RXF1].num,\n\t\tcdev->mcfg[MRAM_RXB].off, cdev->mcfg[MRAM_RXB].num,\n\t\tcdev->mcfg[MRAM_TXE].off, cdev->mcfg[MRAM_TXE].num,\n\t\tcdev->mcfg[MRAM_TXB].off, cdev->mcfg[MRAM_TXB].num);\n}\n\nint m_can_init_ram(struct m_can_classdev *cdev)\n{\n\tint end, i, start;\n\tint err = 0;\n\n\t \n\tstart = cdev->mcfg[MRAM_SIDF].off;\n\tend = cdev->mcfg[MRAM_TXB].off +\n\t\tcdev->mcfg[MRAM_TXB].num * TXB_ELEMENT_SIZE;\n\n\tfor (i = start; i < end; i += 4) {\n\t\terr = m_can_fifo_write_no_off(cdev, i, 0x0);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(m_can_init_ram);\n\nint m_can_class_get_clocks(struct m_can_classdev *cdev)\n{\n\tint ret = 0;\n\n\tcdev->hclk = devm_clk_get(cdev->dev, \"hclk\");\n\tcdev->cclk = devm_clk_get(cdev->dev, \"cclk\");\n\n\tif (IS_ERR(cdev->hclk) || IS_ERR(cdev->cclk)) {\n\t\tdev_err(cdev->dev, \"no clock found\\n\");\n\t\tret = -ENODEV;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(m_can_class_get_clocks);\n\nstruct m_can_classdev *m_can_class_allocate_dev(struct device *dev,\n\t\t\t\t\t\tint sizeof_priv)\n{\n\tstruct m_can_classdev *class_dev = NULL;\n\tu32 mram_config_vals[MRAM_CFG_LEN];\n\tstruct net_device *net_dev;\n\tu32 tx_fifo_size;\n\tint ret;\n\n\tret = fwnode_property_read_u32_array(dev_fwnode(dev),\n\t\t\t\t\t     \"bosch,mram-cfg\",\n\t\t\t\t\t     mram_config_vals,\n\t\t\t\t\t     sizeof(mram_config_vals) / 4);\n\tif (ret) {\n\t\tdev_err(dev, \"Could not get Message RAM configuration.\");\n\t\tgoto out;\n\t}\n\n\t \n\ttx_fifo_size = mram_config_vals[7];\n\n\t \n\tnet_dev = alloc_candev(sizeof_priv, tx_fifo_size);\n\tif (!net_dev) {\n\t\tdev_err(dev, \"Failed to allocate CAN device\");\n\t\tgoto out;\n\t}\n\n\tclass_dev = netdev_priv(net_dev);\n\tclass_dev->net = net_dev;\n\tclass_dev->dev = dev;\n\tSET_NETDEV_DEV(net_dev, dev);\n\n\tm_can_of_parse_mram(class_dev, mram_config_vals);\nout:\n\treturn class_dev;\n}\nEXPORT_SYMBOL_GPL(m_can_class_allocate_dev);\n\nvoid m_can_class_free_dev(struct net_device *net)\n{\n\tfree_candev(net);\n}\nEXPORT_SYMBOL_GPL(m_can_class_free_dev);\n\nint m_can_class_register(struct m_can_classdev *cdev)\n{\n\tint ret;\n\n\tif (cdev->pm_clock_support) {\n\t\tret = m_can_clk_start(cdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (cdev->is_peripheral) {\n\t\tret = can_rx_offload_add_manual(cdev->net, &cdev->offload,\n\t\t\t\t\t\tNAPI_POLL_WEIGHT);\n\t\tif (ret)\n\t\t\tgoto clk_disable;\n\t}\n\n\tif (!cdev->net->irq)\n\t\tcdev->hrtimer.function = &hrtimer_callback;\n\n\tret = m_can_dev_setup(cdev);\n\tif (ret)\n\t\tgoto rx_offload_del;\n\n\tret = register_m_can_dev(cdev->net);\n\tif (ret) {\n\t\tdev_err(cdev->dev, \"registering %s failed (err=%d)\\n\",\n\t\t\tcdev->net->name, ret);\n\t\tgoto rx_offload_del;\n\t}\n\n\tof_can_transceiver(cdev->net);\n\n\tdev_info(cdev->dev, \"%s device registered (irq=%d, version=%d)\\n\",\n\t\t KBUILD_MODNAME, cdev->net->irq, cdev->version);\n\n\t \n\tm_can_clk_stop(cdev);\n\n\treturn 0;\n\nrx_offload_del:\n\tif (cdev->is_peripheral)\n\t\tcan_rx_offload_del(&cdev->offload);\nclk_disable:\n\tm_can_clk_stop(cdev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(m_can_class_register);\n\nvoid m_can_class_unregister(struct m_can_classdev *cdev)\n{\n\tif (cdev->is_peripheral)\n\t\tcan_rx_offload_del(&cdev->offload);\n\tunregister_candev(cdev->net);\n}\nEXPORT_SYMBOL_GPL(m_can_class_unregister);\n\nint m_can_class_suspend(struct device *dev)\n{\n\tstruct m_can_classdev *cdev = dev_get_drvdata(dev);\n\tstruct net_device *ndev = cdev->net;\n\n\tif (netif_running(ndev)) {\n\t\tnetif_stop_queue(ndev);\n\t\tnetif_device_detach(ndev);\n\t\tm_can_stop(ndev);\n\t\tm_can_clk_stop(cdev);\n\t}\n\n\tpinctrl_pm_select_sleep_state(dev);\n\n\tcdev->can.state = CAN_STATE_SLEEPING;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(m_can_class_suspend);\n\nint m_can_class_resume(struct device *dev)\n{\n\tstruct m_can_classdev *cdev = dev_get_drvdata(dev);\n\tstruct net_device *ndev = cdev->net;\n\n\tpinctrl_pm_select_default_state(dev);\n\n\tcdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\tif (netif_running(ndev)) {\n\t\tint ret;\n\n\t\tret = m_can_clk_start(cdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret  = m_can_start(ndev);\n\t\tif (ret) {\n\t\t\tm_can_clk_stop(cdev);\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tnetif_device_attach(ndev);\n\t\tnetif_start_queue(ndev);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(m_can_class_resume);\n\nMODULE_AUTHOR(\"Dong Aisheng <b29396@freescale.com>\");\nMODULE_AUTHOR(\"Dan Murphy <dmurphy@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"CAN bus driver for Bosch M_CAN controller\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}