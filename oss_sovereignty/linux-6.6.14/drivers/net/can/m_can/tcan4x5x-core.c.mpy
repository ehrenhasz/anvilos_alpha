{
  "module_name": "tcan4x5x-core.c",
  "hash_id": "75bf069db037c15ef27143c16d778d1b84c91291d4fb23a1459f1add353c7aff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/m_can/tcan4x5x-core.c",
  "human_readable_source": "\n\n\n\n#include \"tcan4x5x.h\"\n\n#define TCAN4X5X_EXT_CLK_DEF 40000000\n\n#define TCAN4X5X_DEV_ID1 0x00\n#define TCAN4X5X_DEV_ID1_TCAN 0x4e414354  \n#define TCAN4X5X_DEV_ID2 0x04\n#define TCAN4X5X_REV 0x08\n#define TCAN4X5X_STATUS 0x0C\n#define TCAN4X5X_ERROR_STATUS_MASK 0x10\n#define TCAN4X5X_CONTROL 0x14\n\n#define TCAN4X5X_CONFIG 0x800\n#define TCAN4X5X_TS_PRESCALE 0x804\n#define TCAN4X5X_TEST_REG 0x808\n#define TCAN4X5X_INT_FLAGS 0x820\n#define TCAN4X5X_MCAN_INT_REG 0x824\n#define TCAN4X5X_INT_EN 0x830\n\n \n#define TCAN4X5X_CANBUSTERMOPEN_INT_EN BIT(30)\n#define TCAN4X5X_CANHCANL_INT_EN BIT(29)\n#define TCAN4X5X_CANHBAT_INT_EN BIT(28)\n#define TCAN4X5X_CANLGND_INT_EN BIT(27)\n#define TCAN4X5X_CANBUSOPEN_INT_EN BIT(26)\n#define TCAN4X5X_CANBUSGND_INT_EN BIT(25)\n#define TCAN4X5X_CANBUSBAT_INT_EN BIT(24)\n#define TCAN4X5X_UVSUP_INT_EN BIT(22)\n#define TCAN4X5X_UVIO_INT_EN BIT(21)\n#define TCAN4X5X_TSD_INT_EN BIT(19)\n#define TCAN4X5X_ECCERR_INT_EN BIT(16)\n#define TCAN4X5X_CANINT_INT_EN BIT(15)\n#define TCAN4X5X_LWU_INT_EN BIT(14)\n#define TCAN4X5X_CANSLNT_INT_EN BIT(10)\n#define TCAN4X5X_CANDOM_INT_EN BIT(8)\n#define TCAN4X5X_CANBUS_ERR_INT_EN BIT(5)\n#define TCAN4X5X_BUS_FAULT BIT(4)\n#define TCAN4X5X_MCAN_INT BIT(1)\n#define TCAN4X5X_ENABLE_TCAN_INT \\\n\t(TCAN4X5X_MCAN_INT | TCAN4X5X_BUS_FAULT | \\\n\t TCAN4X5X_CANBUS_ERR_INT_EN | TCAN4X5X_CANINT_INT_EN)\n\n \n#define TCAN4X5X_MCAN_IR_ARA BIT(29)\n#define TCAN4X5X_MCAN_IR_PED BIT(28)\n#define TCAN4X5X_MCAN_IR_PEA BIT(27)\n#define TCAN4X5X_MCAN_IR_WD BIT(26)\n#define TCAN4X5X_MCAN_IR_BO BIT(25)\n#define TCAN4X5X_MCAN_IR_EW BIT(24)\n#define TCAN4X5X_MCAN_IR_EP BIT(23)\n#define TCAN4X5X_MCAN_IR_ELO BIT(22)\n#define TCAN4X5X_MCAN_IR_BEU BIT(21)\n#define TCAN4X5X_MCAN_IR_BEC BIT(20)\n#define TCAN4X5X_MCAN_IR_DRX BIT(19)\n#define TCAN4X5X_MCAN_IR_TOO BIT(18)\n#define TCAN4X5X_MCAN_IR_MRAF BIT(17)\n#define TCAN4X5X_MCAN_IR_TSW BIT(16)\n#define TCAN4X5X_MCAN_IR_TEFL BIT(15)\n#define TCAN4X5X_MCAN_IR_TEFF BIT(14)\n#define TCAN4X5X_MCAN_IR_TEFW BIT(13)\n#define TCAN4X5X_MCAN_IR_TEFN BIT(12)\n#define TCAN4X5X_MCAN_IR_TFE BIT(11)\n#define TCAN4X5X_MCAN_IR_TCF BIT(10)\n#define TCAN4X5X_MCAN_IR_TC BIT(9)\n#define TCAN4X5X_MCAN_IR_HPM BIT(8)\n#define TCAN4X5X_MCAN_IR_RF1L BIT(7)\n#define TCAN4X5X_MCAN_IR_RF1F BIT(6)\n#define TCAN4X5X_MCAN_IR_RF1W BIT(5)\n#define TCAN4X5X_MCAN_IR_RF1N BIT(4)\n#define TCAN4X5X_MCAN_IR_RF0L BIT(3)\n#define TCAN4X5X_MCAN_IR_RF0F BIT(2)\n#define TCAN4X5X_MCAN_IR_RF0W BIT(1)\n#define TCAN4X5X_MCAN_IR_RF0N BIT(0)\n#define TCAN4X5X_ENABLE_MCAN_INT \\\n\t(TCAN4X5X_MCAN_IR_TC | TCAN4X5X_MCAN_IR_RF0N | \\\n\t TCAN4X5X_MCAN_IR_RF1N | TCAN4X5X_MCAN_IR_RF0F | \\\n\t TCAN4X5X_MCAN_IR_RF1F)\n\n#define TCAN4X5X_MRAM_START 0x8000\n#define TCAN4X5X_MRAM_SIZE 0x800\n#define TCAN4X5X_MCAN_OFFSET 0x1000\n\n#define TCAN4X5X_CLEAR_ALL_INT 0xffffffff\n#define TCAN4X5X_SET_ALL_INT 0xffffffff\n\n#define TCAN4X5X_MODE_SEL_MASK (BIT(7) | BIT(6))\n#define TCAN4X5X_MODE_SLEEP 0x00\n#define TCAN4X5X_MODE_STANDBY BIT(6)\n#define TCAN4X5X_MODE_NORMAL BIT(7)\n\n#define TCAN4X5X_DISABLE_WAKE_MSK\t(BIT(31) | BIT(30))\n#define TCAN4X5X_DISABLE_INH_MSK\tBIT(9)\n\n#define TCAN4X5X_SW_RESET BIT(2)\n\n#define TCAN4X5X_MCAN_CONFIGURED BIT(5)\n#define TCAN4X5X_WATCHDOG_EN BIT(3)\n#define TCAN4X5X_WD_60_MS_TIMER 0\n#define TCAN4X5X_WD_600_MS_TIMER BIT(28)\n#define TCAN4X5X_WD_3_S_TIMER BIT(29)\n#define TCAN4X5X_WD_6_S_TIMER (BIT(28) | BIT(29))\n\nstruct tcan4x5x_version_info {\n\tconst char *name;\n\tu32 id2_register;\n\n\tbool has_wake_pin;\n\tbool has_state_pin;\n};\n\nenum {\n\tTCAN4552 = 0,\n\tTCAN4553,\n\tTCAN4X5X,\n};\n\nstatic const struct tcan4x5x_version_info tcan4x5x_versions[] = {\n\t[TCAN4552] = {\n\t\t.name = \"4552\",\n\t\t.id2_register = 0x32353534,\n\t},\n\t[TCAN4553] = {\n\t\t.name = \"4553\",\n\t\t.id2_register = 0x33353534,\n\t},\n\t \n\t[TCAN4X5X] = {\n\t\t.name = \"generic\",\n\t\t.has_wake_pin = true,\n\t\t.has_state_pin = true,\n\t},\n};\n\nstatic inline struct tcan4x5x_priv *cdev_to_priv(struct m_can_classdev *cdev)\n{\n\treturn container_of(cdev, struct tcan4x5x_priv, cdev);\n}\n\nstatic void tcan4x5x_check_wake(struct tcan4x5x_priv *priv)\n{\n\tint wake_state = 0;\n\n\tif (priv->device_state_gpio)\n\t\twake_state = gpiod_get_value(priv->device_state_gpio);\n\n\tif (priv->device_wake_gpio && wake_state) {\n\t\tgpiod_set_value(priv->device_wake_gpio, 0);\n\t\tusleep_range(5, 50);\n\t\tgpiod_set_value(priv->device_wake_gpio, 1);\n\t}\n}\n\nstatic int tcan4x5x_reset(struct tcan4x5x_priv *priv)\n{\n\tint ret = 0;\n\n\tif (priv->reset_gpio) {\n\t\tgpiod_set_value(priv->reset_gpio, 1);\n\n\t\t \n\t\tusleep_range(30, 100);\n\t\tgpiod_set_value(priv->reset_gpio, 0);\n\t} else {\n\t\tret = regmap_write(priv->regmap, TCAN4X5X_CONFIG,\n\t\t\t\t   TCAN4X5X_SW_RESET);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tusleep_range(700, 1000);\n\n\treturn ret;\n}\n\nstatic u32 tcan4x5x_read_reg(struct m_can_classdev *cdev, int reg)\n{\n\tstruct tcan4x5x_priv *priv = cdev_to_priv(cdev);\n\tu32 val;\n\n\tregmap_read(priv->regmap, TCAN4X5X_MCAN_OFFSET + reg, &val);\n\n\treturn val;\n}\n\nstatic int tcan4x5x_read_fifo(struct m_can_classdev *cdev, int addr_offset,\n\t\t\t      void *val, size_t val_count)\n{\n\tstruct tcan4x5x_priv *priv = cdev_to_priv(cdev);\n\n\treturn regmap_bulk_read(priv->regmap, TCAN4X5X_MRAM_START + addr_offset, val, val_count);\n}\n\nstatic int tcan4x5x_write_reg(struct m_can_classdev *cdev, int reg, int val)\n{\n\tstruct tcan4x5x_priv *priv = cdev_to_priv(cdev);\n\n\treturn regmap_write(priv->regmap, TCAN4X5X_MCAN_OFFSET + reg, val);\n}\n\nstatic int tcan4x5x_write_fifo(struct m_can_classdev *cdev,\n\t\t\t       int addr_offset, const void *val, size_t val_count)\n{\n\tstruct tcan4x5x_priv *priv = cdev_to_priv(cdev);\n\n\treturn regmap_bulk_write(priv->regmap, TCAN4X5X_MRAM_START + addr_offset, val, val_count);\n}\n\nstatic int tcan4x5x_power_enable(struct regulator *reg, int enable)\n{\n\tif (IS_ERR_OR_NULL(reg))\n\t\treturn 0;\n\n\tif (enable)\n\t\treturn regulator_enable(reg);\n\telse\n\t\treturn regulator_disable(reg);\n}\n\nstatic int tcan4x5x_write_tcan_reg(struct m_can_classdev *cdev,\n\t\t\t\t   int reg, int val)\n{\n\tstruct tcan4x5x_priv *priv = cdev_to_priv(cdev);\n\n\treturn regmap_write(priv->regmap, reg, val);\n}\n\nstatic int tcan4x5x_clear_interrupts(struct m_can_classdev *cdev)\n{\n\tint ret;\n\n\tret = tcan4x5x_write_tcan_reg(cdev, TCAN4X5X_STATUS,\n\t\t\t\t      TCAN4X5X_CLEAR_ALL_INT);\n\tif (ret)\n\t\treturn ret;\n\n\treturn tcan4x5x_write_tcan_reg(cdev, TCAN4X5X_INT_FLAGS,\n\t\t\t\t       TCAN4X5X_CLEAR_ALL_INT);\n}\n\nstatic int tcan4x5x_init(struct m_can_classdev *cdev)\n{\n\tstruct tcan4x5x_priv *tcan4x5x = cdev_to_priv(cdev);\n\tint ret;\n\n\ttcan4x5x_check_wake(tcan4x5x);\n\n\tret = tcan4x5x_clear_interrupts(cdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tcan4x5x_write_tcan_reg(cdev, TCAN4X5X_INT_EN,\n\t\t\t\t      TCAN4X5X_ENABLE_TCAN_INT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tcan4x5x_write_tcan_reg(cdev, TCAN4X5X_ERROR_STATUS_MASK,\n\t\t\t\t      TCAN4X5X_CLEAR_ALL_INT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(tcan4x5x->regmap, TCAN4X5X_CONFIG,\n\t\t\t\t TCAN4X5X_MODE_SEL_MASK, TCAN4X5X_MODE_NORMAL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic int tcan4x5x_disable_wake(struct m_can_classdev *cdev)\n{\n\tstruct tcan4x5x_priv *tcan4x5x = cdev_to_priv(cdev);\n\n\treturn regmap_update_bits(tcan4x5x->regmap, TCAN4X5X_CONFIG,\n\t\t\t\t  TCAN4X5X_DISABLE_WAKE_MSK, 0x00);\n}\n\nstatic int tcan4x5x_disable_state(struct m_can_classdev *cdev)\n{\n\tstruct tcan4x5x_priv *tcan4x5x = cdev_to_priv(cdev);\n\n\treturn regmap_update_bits(tcan4x5x->regmap, TCAN4X5X_CONFIG,\n\t\t\t\t  TCAN4X5X_DISABLE_INH_MSK, 0x01);\n}\n\nstatic const struct tcan4x5x_version_info\n*tcan4x5x_find_version(struct tcan4x5x_priv *priv)\n{\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read(priv->regmap, TCAN4X5X_DEV_ID1, &val);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (val != TCAN4X5X_DEV_ID1_TCAN) {\n\t\tdev_err(&priv->spi->dev, \"Not a tcan device %x\\n\", val);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tret = regmap_read(priv->regmap, TCAN4X5X_DEV_ID2, &val);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tfor (int i = 0; i != ARRAY_SIZE(tcan4x5x_versions); ++i) {\n\t\tconst struct tcan4x5x_version_info *vinfo = &tcan4x5x_versions[i];\n\n\t\tif (!vinfo->id2_register || val == vinfo->id2_register) {\n\t\t\tdev_info(&priv->spi->dev, \"Detected TCAN device version %s\\n\",\n\t\t\t\t vinfo->name);\n\t\t\treturn vinfo;\n\t\t}\n\t}\n\n\treturn &tcan4x5x_versions[TCAN4X5X];\n}\n\nstatic int tcan4x5x_get_gpios(struct m_can_classdev *cdev,\n\t\t\t      const struct tcan4x5x_version_info *version_info)\n{\n\tstruct tcan4x5x_priv *tcan4x5x = cdev_to_priv(cdev);\n\tint ret;\n\n\tif (version_info->has_wake_pin) {\n\t\ttcan4x5x->device_wake_gpio = devm_gpiod_get(cdev->dev, \"device-wake\",\n\t\t\t\t\t\t\t    GPIOD_OUT_HIGH);\n\t\tif (IS_ERR(tcan4x5x->device_wake_gpio)) {\n\t\t\tif (PTR_ERR(tcan4x5x->device_wake_gpio) == -EPROBE_DEFER)\n\t\t\t\treturn -EPROBE_DEFER;\n\n\t\t\ttcan4x5x_disable_wake(cdev);\n\t\t}\n\t}\n\n\ttcan4x5x->reset_gpio = devm_gpiod_get_optional(cdev->dev, \"reset\",\n\t\t\t\t\t\t       GPIOD_OUT_LOW);\n\tif (IS_ERR(tcan4x5x->reset_gpio))\n\t\ttcan4x5x->reset_gpio = NULL;\n\n\tret = tcan4x5x_reset(tcan4x5x);\n\tif (ret)\n\t\treturn ret;\n\n\tif (version_info->has_state_pin) {\n\t\ttcan4x5x->device_state_gpio = devm_gpiod_get_optional(cdev->dev,\n\t\t\t\t\t\t\t\t      \"device-state\",\n\t\t\t\t\t\t\t\t      GPIOD_IN);\n\t\tif (IS_ERR(tcan4x5x->device_state_gpio)) {\n\t\t\ttcan4x5x->device_state_gpio = NULL;\n\t\t\ttcan4x5x_disable_state(cdev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct m_can_ops tcan4x5x_ops = {\n\t.init = tcan4x5x_init,\n\t.read_reg = tcan4x5x_read_reg,\n\t.write_reg = tcan4x5x_write_reg,\n\t.write_fifo = tcan4x5x_write_fifo,\n\t.read_fifo = tcan4x5x_read_fifo,\n\t.clear_interrupts = tcan4x5x_clear_interrupts,\n};\n\nstatic int tcan4x5x_can_probe(struct spi_device *spi)\n{\n\tconst struct tcan4x5x_version_info *version_info;\n\tstruct tcan4x5x_priv *priv;\n\tstruct m_can_classdev *mcan_class;\n\tint freq, ret;\n\n\tmcan_class = m_can_class_allocate_dev(&spi->dev,\n\t\t\t\t\t      sizeof(struct tcan4x5x_priv));\n\tif (!mcan_class)\n\t\treturn -ENOMEM;\n\n\tret = m_can_check_mram_cfg(mcan_class, TCAN4X5X_MRAM_SIZE);\n\tif (ret)\n\t\tgoto out_m_can_class_free_dev;\n\n\tpriv = cdev_to_priv(mcan_class);\n\n\tpriv->power = devm_regulator_get_optional(&spi->dev, \"vsup\");\n\tif (PTR_ERR(priv->power) == -EPROBE_DEFER) {\n\t\tret = -EPROBE_DEFER;\n\t\tgoto out_m_can_class_free_dev;\n\t} else {\n\t\tpriv->power = NULL;\n\t}\n\n\tm_can_class_get_clocks(mcan_class);\n\tif (IS_ERR(mcan_class->cclk)) {\n\t\tdev_err(&spi->dev, \"no CAN clock source defined\\n\");\n\t\tfreq = TCAN4X5X_EXT_CLK_DEF;\n\t} else {\n\t\tfreq = clk_get_rate(mcan_class->cclk);\n\t}\n\n\t \n\tif (freq < 20000000 || freq > TCAN4X5X_EXT_CLK_DEF) {\n\t\tdev_err(&spi->dev, \"Clock frequency is out of supported range %d\\n\",\n\t\t\tfreq);\n\t\tret = -ERANGE;\n\t\tgoto out_m_can_class_free_dev;\n\t}\n\n\tpriv->spi = spi;\n\n\tmcan_class->pm_clock_support = 0;\n\tmcan_class->can.clock.freq = freq;\n\tmcan_class->dev = &spi->dev;\n\tmcan_class->ops = &tcan4x5x_ops;\n\tmcan_class->is_peripheral = true;\n\tmcan_class->net->irq = spi->irq;\n\n\tspi_set_drvdata(spi, priv);\n\n\t \n\tspi->bits_per_word = 8;\n\tret = spi_setup(spi);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"SPI setup failed %pe\\n\", ERR_PTR(ret));\n\t\tgoto out_m_can_class_free_dev;\n\t}\n\n\tret = tcan4x5x_regmap_init(priv);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"regmap init failed %pe\\n\", ERR_PTR(ret));\n\t\tgoto out_m_can_class_free_dev;\n\t}\n\n\tret = tcan4x5x_power_enable(priv->power, 1);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Enabling regulator failed %pe\\n\",\n\t\t\tERR_PTR(ret));\n\t\tgoto out_m_can_class_free_dev;\n\t}\n\n\tversion_info = tcan4x5x_find_version(priv);\n\tif (IS_ERR(version_info)) {\n\t\tret = PTR_ERR(version_info);\n\t\tgoto out_power;\n\t}\n\n\tret = tcan4x5x_get_gpios(mcan_class, version_info);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Getting gpios failed %pe\\n\", ERR_PTR(ret));\n\t\tgoto out_power;\n\t}\n\n\tret = tcan4x5x_init(mcan_class);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"tcan initialization failed %pe\\n\",\n\t\t\tERR_PTR(ret));\n\t\tgoto out_power;\n\t}\n\n\tret = m_can_class_register(mcan_class);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"Failed registering m_can device %pe\\n\",\n\t\t\tERR_PTR(ret));\n\t\tgoto out_power;\n\t}\n\n\tnetdev_info(mcan_class->net, \"TCAN4X5X successfully initialized.\\n\");\n\treturn 0;\n\nout_power:\n\ttcan4x5x_power_enable(priv->power, 0);\n out_m_can_class_free_dev:\n\tm_can_class_free_dev(mcan_class->net);\n\treturn ret;\n}\n\nstatic void tcan4x5x_can_remove(struct spi_device *spi)\n{\n\tstruct tcan4x5x_priv *priv = spi_get_drvdata(spi);\n\n\tm_can_class_unregister(&priv->cdev);\n\n\ttcan4x5x_power_enable(priv->power, 0);\n\n\tm_can_class_free_dev(priv->cdev.net);\n}\n\nstatic const struct of_device_id tcan4x5x_of_match[] = {\n\t{\n\t\t.compatible = \"ti,tcan4x5x\",\n\t}, {\n\t\t \n\t},\n};\nMODULE_DEVICE_TABLE(of, tcan4x5x_of_match);\n\nstatic const struct spi_device_id tcan4x5x_id_table[] = {\n\t{\n\t\t.name = \"tcan4x5x\",\n\t}, {\n\t\t \n\t},\n};\nMODULE_DEVICE_TABLE(spi, tcan4x5x_id_table);\n\nstatic struct spi_driver tcan4x5x_can_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = tcan4x5x_of_match,\n\t\t.pm = NULL,\n\t},\n\t.id_table = tcan4x5x_id_table,\n\t.probe = tcan4x5x_can_probe,\n\t.remove = tcan4x5x_can_remove,\n};\nmodule_spi_driver(tcan4x5x_can_driver);\n\nMODULE_AUTHOR(\"Dan Murphy <dmurphy@ti.com>\");\nMODULE_DESCRIPTION(\"Texas Instruments TCAN4x5x CAN driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}