{
  "module_name": "m_can_platform.c",
  "hash_id": "165f623b624529b6b4b601a703c6c99f85a1fb532342869b7b9c854825036c5e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/m_can/m_can_platform.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/hrtimer.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n\n#include \"m_can.h\"\n\nstruct m_can_plat_priv {\n\tstruct m_can_classdev cdev;\n\n\tvoid __iomem *base;\n\tvoid __iomem *mram_base;\n};\n\nstatic inline struct m_can_plat_priv *cdev_to_priv(struct m_can_classdev *cdev)\n{\n\treturn container_of(cdev, struct m_can_plat_priv, cdev);\n}\n\nstatic u32 iomap_read_reg(struct m_can_classdev *cdev, int reg)\n{\n\tstruct m_can_plat_priv *priv = cdev_to_priv(cdev);\n\n\treturn readl(priv->base + reg);\n}\n\nstatic int iomap_read_fifo(struct m_can_classdev *cdev, int offset, void *val, size_t val_count)\n{\n\tstruct m_can_plat_priv *priv = cdev_to_priv(cdev);\n\tvoid __iomem *src = priv->mram_base + offset;\n\n\twhile (val_count--) {\n\t\t*(unsigned int *)val = ioread32(src);\n\t\tval += 4;\n\t\tsrc += 4;\n\t}\n\n\treturn 0;\n}\n\nstatic int iomap_write_reg(struct m_can_classdev *cdev, int reg, int val)\n{\n\tstruct m_can_plat_priv *priv = cdev_to_priv(cdev);\n\n\twritel(val, priv->base + reg);\n\n\treturn 0;\n}\n\nstatic int iomap_write_fifo(struct m_can_classdev *cdev, int offset,\n\t\t\t    const void *val, size_t val_count)\n{\n\tstruct m_can_plat_priv *priv = cdev_to_priv(cdev);\n\tvoid __iomem *dst = priv->mram_base + offset;\n\n\twhile (val_count--) {\n\t\tiowrite32(*(unsigned int *)val, dst);\n\t\tval += 4;\n\t\tdst += 4;\n\t}\n\n\treturn 0;\n}\n\nstatic struct m_can_ops m_can_plat_ops = {\n\t.read_reg = iomap_read_reg,\n\t.write_reg = iomap_write_reg,\n\t.write_fifo = iomap_write_fifo,\n\t.read_fifo = iomap_read_fifo,\n};\n\nstatic int m_can_plat_probe(struct platform_device *pdev)\n{\n\tstruct m_can_classdev *mcan_class;\n\tstruct m_can_plat_priv *priv;\n\tstruct resource *res;\n\tvoid __iomem *addr;\n\tvoid __iomem *mram_addr;\n\tstruct phy *transceiver;\n\tint irq = 0, ret = 0;\n\n\tmcan_class = m_can_class_allocate_dev(&pdev->dev,\n\t\t\t\t\t      sizeof(struct m_can_plat_priv));\n\tif (!mcan_class)\n\t\treturn -ENOMEM;\n\n\tpriv = cdev_to_priv(mcan_class);\n\n\tret = m_can_class_get_clocks(mcan_class);\n\tif (ret)\n\t\tgoto probe_fail;\n\n\taddr = devm_platform_ioremap_resource_byname(pdev, \"m_can\");\n\tif (IS_ERR(addr)) {\n\t\tret = PTR_ERR(addr);\n\t\tgoto probe_fail;\n\t}\n\n\tif (device_property_present(mcan_class->dev, \"interrupts\") ||\n\t    device_property_present(mcan_class->dev, \"interrupt-names\")) {\n\t\tirq = platform_get_irq_byname(pdev, \"int0\");\n\t\tif (irq < 0) {\n\t\t\tret = irq;\n\t\t\tgoto probe_fail;\n\t\t}\n\t} else {\n\t\tdev_dbg(mcan_class->dev, \"Polling enabled, initialize hrtimer\");\n\t\thrtimer_init(&mcan_class->hrtimer, CLOCK_MONOTONIC,\n\t\t\t     HRTIMER_MODE_REL_PINNED);\n\t}\n\n\t \n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"message_ram\");\n\tif (!res) {\n\t\tret = -ENODEV;\n\t\tgoto probe_fail;\n\t}\n\n\tmram_addr = devm_ioremap(&pdev->dev, res->start, resource_size(res));\n\tif (!mram_addr) {\n\t\tret = -ENOMEM;\n\t\tgoto probe_fail;\n\t}\n\n\ttransceiver = devm_phy_optional_get(&pdev->dev, NULL);\n\tif (IS_ERR(transceiver)) {\n\t\tret = PTR_ERR(transceiver);\n\t\tdev_err_probe(&pdev->dev, ret, \"failed to get phy\\n\");\n\t\tgoto probe_fail;\n\t}\n\n\tif (transceiver)\n\t\tmcan_class->can.bitrate_max = transceiver->attrs.max_link_rate;\n\n\tpriv->base = addr;\n\tpriv->mram_base = mram_addr;\n\n\tmcan_class->net->irq = irq;\n\tmcan_class->pm_clock_support = 1;\n\tmcan_class->can.clock.freq = clk_get_rate(mcan_class->cclk);\n\tmcan_class->dev = &pdev->dev;\n\tmcan_class->transceiver = transceiver;\n\n\tmcan_class->ops = &m_can_plat_ops;\n\n\tmcan_class->is_peripheral = false;\n\n\tplatform_set_drvdata(pdev, mcan_class);\n\n\tpm_runtime_enable(mcan_class->dev);\n\tret = m_can_class_register(mcan_class);\n\tif (ret)\n\t\tgoto out_runtime_disable;\n\n\treturn ret;\n\nout_runtime_disable:\n\tpm_runtime_disable(mcan_class->dev);\nprobe_fail:\n\tm_can_class_free_dev(mcan_class->net);\n\treturn ret;\n}\n\nstatic __maybe_unused int m_can_suspend(struct device *dev)\n{\n\treturn m_can_class_suspend(dev);\n}\n\nstatic __maybe_unused int m_can_resume(struct device *dev)\n{\n\treturn m_can_class_resume(dev);\n}\n\nstatic void m_can_plat_remove(struct platform_device *pdev)\n{\n\tstruct m_can_plat_priv *priv = platform_get_drvdata(pdev);\n\tstruct m_can_classdev *mcan_class = &priv->cdev;\n\n\tm_can_class_unregister(mcan_class);\n\n\tm_can_class_free_dev(mcan_class->net);\n}\n\nstatic int __maybe_unused m_can_runtime_suspend(struct device *dev)\n{\n\tstruct m_can_plat_priv *priv = dev_get_drvdata(dev);\n\tstruct m_can_classdev *mcan_class = &priv->cdev;\n\n\tclk_disable_unprepare(mcan_class->cclk);\n\tclk_disable_unprepare(mcan_class->hclk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused m_can_runtime_resume(struct device *dev)\n{\n\tstruct m_can_plat_priv *priv = dev_get_drvdata(dev);\n\tstruct m_can_classdev *mcan_class = &priv->cdev;\n\tint err;\n\n\terr = clk_prepare_enable(mcan_class->hclk);\n\tif (err)\n\t\treturn err;\n\n\terr = clk_prepare_enable(mcan_class->cclk);\n\tif (err)\n\t\tclk_disable_unprepare(mcan_class->hclk);\n\n\treturn err;\n}\n\nstatic const struct dev_pm_ops m_can_pmops = {\n\tSET_RUNTIME_PM_OPS(m_can_runtime_suspend,\n\t\t\t   m_can_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(m_can_suspend, m_can_resume)\n};\n\nstatic const struct of_device_id m_can_of_table[] = {\n\t{ .compatible = \"bosch,m_can\", .data = NULL },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, m_can_of_table);\n\nstatic struct platform_driver m_can_plat_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = m_can_of_table,\n\t\t.pm     = &m_can_pmops,\n\t},\n\t.probe = m_can_plat_probe,\n\t.remove_new = m_can_plat_remove,\n};\n\nmodule_platform_driver(m_can_plat_driver);\n\nMODULE_AUTHOR(\"Dong Aisheng <b29396@freescale.com>\");\nMODULE_AUTHOR(\"Dan Murphy <dmurphy@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"M_CAN driver for IO Mapped Bosch controllers\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}