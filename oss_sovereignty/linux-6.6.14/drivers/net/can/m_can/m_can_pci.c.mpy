{
  "module_name": "m_can_pci.c",
  "hash_id": "a620cdf05b04390bfb9f6e7c78b64400aa021cb7146de73f4e69e1b81d2b3b49",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/m_can/m_can_pci.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/pci.h>\n#include <linux/pm_runtime.h>\n\n#include \"m_can.h\"\n\n#define M_CAN_PCI_MMIO_BAR\t\t0\n\n#define M_CAN_CLOCK_FREQ_EHL\t\t200000000\n#define CTL_CSR_INT_CTL_OFFSET\t\t0x508\n\nstruct m_can_pci_priv {\n\tstruct m_can_classdev cdev;\n\n\tvoid __iomem *base;\n};\n\nstatic inline struct m_can_pci_priv *cdev_to_priv(struct m_can_classdev *cdev)\n{\n\treturn container_of(cdev, struct m_can_pci_priv, cdev);\n}\n\nstatic u32 iomap_read_reg(struct m_can_classdev *cdev, int reg)\n{\n\tstruct m_can_pci_priv *priv = cdev_to_priv(cdev);\n\n\treturn readl(priv->base + reg);\n}\n\nstatic int iomap_read_fifo(struct m_can_classdev *cdev, int offset, void *val, size_t val_count)\n{\n\tstruct m_can_pci_priv *priv = cdev_to_priv(cdev);\n\tvoid __iomem *src = priv->base + offset;\n\n\twhile (val_count--) {\n\t\t*(unsigned int *)val = ioread32(src);\n\t\tval += 4;\n\t\tsrc += 4;\n\t}\n\n\treturn 0;\n}\n\nstatic int iomap_write_reg(struct m_can_classdev *cdev, int reg, int val)\n{\n\tstruct m_can_pci_priv *priv = cdev_to_priv(cdev);\n\n\twritel(val, priv->base + reg);\n\n\treturn 0;\n}\n\nstatic int iomap_write_fifo(struct m_can_classdev *cdev, int offset,\n\t\t\t    const void *val, size_t val_count)\n{\n\tstruct m_can_pci_priv *priv = cdev_to_priv(cdev);\n\tvoid __iomem *dst = priv->base + offset;\n\n\twhile (val_count--) {\n\t\tiowrite32(*(unsigned int *)val, dst);\n\t\tval += 4;\n\t\tdst += 4;\n\t}\n\n\treturn 0;\n}\n\nstatic struct m_can_ops m_can_pci_ops = {\n\t.read_reg = iomap_read_reg,\n\t.write_reg = iomap_write_reg,\n\t.write_fifo = iomap_write_fifo,\n\t.read_fifo = iomap_read_fifo,\n};\n\nstatic int m_can_pci_probe(struct pci_dev *pci, const struct pci_device_id *id)\n{\n\tstruct device *dev = &pci->dev;\n\tstruct m_can_classdev *mcan_class;\n\tstruct m_can_pci_priv *priv;\n\tvoid __iomem *base;\n\tint ret;\n\n\tret = pcim_enable_device(pci);\n\tif (ret)\n\t\treturn ret;\n\n\tpci_set_master(pci);\n\n\tret = pcim_iomap_regions(pci, BIT(M_CAN_PCI_MMIO_BAR), pci_name(pci));\n\tif (ret)\n\t\treturn ret;\n\n\tbase = pcim_iomap_table(pci)[M_CAN_PCI_MMIO_BAR];\n\n\tif (!base) {\n\t\tdev_err(dev, \"failed to map BARs\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmcan_class = m_can_class_allocate_dev(&pci->dev,\n\t\t\t\t\t      sizeof(struct m_can_pci_priv));\n\tif (!mcan_class)\n\t\treturn -ENOMEM;\n\n\tpriv = cdev_to_priv(mcan_class);\n\n\tpriv->base = base;\n\n\tret = pci_alloc_irq_vectors(pci, 1, 1, PCI_IRQ_ALL_TYPES);\n\tif (ret < 0)\n\t\tgoto err_free_dev;\n\n\tmcan_class->dev = &pci->dev;\n\tmcan_class->net->irq = pci_irq_vector(pci, 0);\n\tmcan_class->pm_clock_support = 1;\n\tmcan_class->can.clock.freq = id->driver_data;\n\tmcan_class->ops = &m_can_pci_ops;\n\n\tpci_set_drvdata(pci, mcan_class);\n\n\tret = m_can_class_register(mcan_class);\n\tif (ret)\n\t\tgoto err_free_irq;\n\n\t \n\twritel(0x1, base + CTL_CSR_INT_CTL_OFFSET);\n\n\tpm_runtime_set_autosuspend_delay(dev, 1000);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_put_noidle(dev);\n\tpm_runtime_allow(dev);\n\n\treturn 0;\n\nerr_free_irq:\n\tpci_free_irq_vectors(pci);\nerr_free_dev:\n\tm_can_class_free_dev(mcan_class->net);\n\treturn ret;\n}\n\nstatic void m_can_pci_remove(struct pci_dev *pci)\n{\n\tstruct m_can_classdev *mcan_class = pci_get_drvdata(pci);\n\tstruct m_can_pci_priv *priv = cdev_to_priv(mcan_class);\n\n\tpm_runtime_forbid(&pci->dev);\n\tpm_runtime_get_noresume(&pci->dev);\n\n\t \n\twritel(0x0, priv->base + CTL_CSR_INT_CTL_OFFSET);\n\n\tm_can_class_unregister(mcan_class);\n\tm_can_class_free_dev(mcan_class->net);\n\tpci_free_irq_vectors(pci);\n}\n\nstatic __maybe_unused int m_can_pci_suspend(struct device *dev)\n{\n\treturn m_can_class_suspend(dev);\n}\n\nstatic __maybe_unused int m_can_pci_resume(struct device *dev)\n{\n\treturn m_can_class_resume(dev);\n}\n\nstatic SIMPLE_DEV_PM_OPS(m_can_pci_pm_ops,\n\t\t\t m_can_pci_suspend, m_can_pci_resume);\n\nstatic const struct pci_device_id m_can_pci_id_table[] = {\n\t{ PCI_VDEVICE(INTEL, 0x4bc1), M_CAN_CLOCK_FREQ_EHL, },\n\t{ PCI_VDEVICE(INTEL, 0x4bc2), M_CAN_CLOCK_FREQ_EHL, },\n\t{  }\t \n};\nMODULE_DEVICE_TABLE(pci, m_can_pci_id_table);\n\nstatic struct pci_driver m_can_pci_driver = {\n\t.name = \"m_can_pci\",\n\t.probe = m_can_pci_probe,\n\t.remove = m_can_pci_remove,\n\t.id_table = m_can_pci_id_table,\n\t.driver = {\n\t\t.pm = &m_can_pci_pm_ops,\n\t},\n};\n\nmodule_pci_driver(m_can_pci_driver);\n\nMODULE_AUTHOR(\"Felipe Balbi (Intel)\");\nMODULE_AUTHOR(\"Jarkko Nikula <jarkko.nikula@linux.intel.com>\");\nMODULE_AUTHOR(\"Raymond Tan <raymond.tan@intel.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"CAN bus driver for Bosch M_CAN controller on PCI bus\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}