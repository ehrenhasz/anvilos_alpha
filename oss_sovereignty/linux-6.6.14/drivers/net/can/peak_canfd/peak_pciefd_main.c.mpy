{
  "module_name": "peak_pciefd_main.c",
  "hash_id": "d06a623d8243d10df7f2f514e256917b95ad290555f819f4e71a89756e4473d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/peak_canfd/peak_pciefd_main.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/io.h>\n#include <linux/can.h>\n#include <linux/can/dev.h>\n\n#include \"peak_canfd_user.h\"\n\nMODULE_AUTHOR(\"Stephane Grosjean <s.grosjean@peak-system.com>\");\nMODULE_DESCRIPTION(\"Socket-CAN driver for PEAK PCAN PCIe/M.2 FD family cards\");\nMODULE_LICENSE(\"GPL v2\");\n\n#define PCIEFD_DRV_NAME\t\t\"peak_pciefd\"\n\n#define PEAK_PCI_VENDOR_ID\t0x001c\t \n#define PEAK_PCIEFD_ID\t\t0x0013\t \n#define PCAN_CPCIEFD_ID\t\t0x0014\t \n#define PCAN_PCIE104FD_ID\t0x0017\t \n#define PCAN_MINIPCIEFD_ID      0x0018\t \n#define PCAN_PCIEFD_OEM_ID      0x0019\t \n#define PCAN_M2_ID\t\t0x001a\t \n\n \n#define PCIEFD_BAR0_SIZE\t\t(64 * 1024)\n#define PCIEFD_RX_DMA_SIZE\t\t(4 * 1024)\n#define PCIEFD_TX_DMA_SIZE\t\t(4 * 1024)\n\n#define PCIEFD_TX_PAGE_SIZE\t\t(2 * 1024)\n\n \n#define PCIEFD_REG_SYS_CTL_SET\t\t0x0000\t \n#define PCIEFD_REG_SYS_CTL_CLR\t\t0x0004\t \n\n \n#define PCIEFD_REG_SYS_VER1\t\t0x0040\t \n#define PCIEFD_REG_SYS_VER2\t\t0x0044\t \n\n#define PCIEFD_FW_VERSION(x, y, z)\t(((u32)(x) << 24) | \\\n\t\t\t\t\t ((u32)(y) << 16) | \\\n\t\t\t\t\t ((u32)(z) << 8))\n\n \n#define PCIEFD_SYS_CTL_TS_RST\t\t0x00000001\t \n#define PCIEFD_SYS_CTL_CLK_EN\t\t0x00000002\t \n\n \n#define PCIEFD_CANX_OFF(c)\t\t(((c) + 1) * 0x1000)\n\n#define PCIEFD_ECHO_SKB_MAX\t\tPCANFD_ECHO_SKB_DEF\n\n \n#define PCIEFD_REG_CAN_MISC\t\t0x0000\t \n#define PCIEFD_REG_CAN_CLK_SEL\t\t0x0008\t \n#define PCIEFD_REG_CAN_CMD_PORT_L\t0x0010\t \n#define PCIEFD_REG_CAN_CMD_PORT_H\t0x0014\n#define PCIEFD_REG_CAN_TX_REQ_ACC\t0x0020\t \n#define PCIEFD_REG_CAN_TX_CTL_SET\t0x0030\t \n#define PCIEFD_REG_CAN_TX_CTL_CLR\t0x0038\t \n#define PCIEFD_REG_CAN_TX_DMA_ADDR_L\t0x0040\t \n#define PCIEFD_REG_CAN_TX_DMA_ADDR_H\t0x0044\n#define PCIEFD_REG_CAN_RX_CTL_SET\t0x0050\t \n#define PCIEFD_REG_CAN_RX_CTL_CLR\t0x0058\t \n#define PCIEFD_REG_CAN_RX_CTL_WRT\t0x0060\t \n#define PCIEFD_REG_CAN_RX_CTL_ACK\t0x0068\t \n#define PCIEFD_REG_CAN_RX_DMA_ADDR_L\t0x0070\t \n#define PCIEFD_REG_CAN_RX_DMA_ADDR_H\t0x0074\n\n \n#define CANFD_MISC_TS_RST\t\t0x00000001\t \n\n \n#define CANFD_CLK_SEL_DIV_MASK\t\t0x00000007\n#define CANFD_CLK_SEL_DIV_60MHZ\t\t0x00000000\t \n#define CANFD_CLK_SEL_DIV_40MHZ\t\t0x00000001\t \n#define CANFD_CLK_SEL_DIV_30MHZ\t\t0x00000002\t \n#define CANFD_CLK_SEL_DIV_24MHZ\t\t0x00000003\t \n#define CANFD_CLK_SEL_DIV_20MHZ\t\t0x00000004\t \n\n#define CANFD_CLK_SEL_SRC_MASK\t\t0x00000008\t \n#define CANFD_CLK_SEL_SRC_240MHZ\t0x00000008\n#define CANFD_CLK_SEL_SRC_80MHZ\t\t(~CANFD_CLK_SEL_SRC_240MHZ & \\\n\t\t\t\t\t\t\tCANFD_CLK_SEL_SRC_MASK)\n\n#define CANFD_CLK_SEL_20MHZ\t\t(CANFD_CLK_SEL_SRC_240MHZ |\\\n\t\t\t\t\t\tCANFD_CLK_SEL_DIV_20MHZ)\n#define CANFD_CLK_SEL_24MHZ\t\t(CANFD_CLK_SEL_SRC_240MHZ |\\\n\t\t\t\t\t\tCANFD_CLK_SEL_DIV_24MHZ)\n#define CANFD_CLK_SEL_30MHZ\t\t(CANFD_CLK_SEL_SRC_240MHZ |\\\n\t\t\t\t\t\tCANFD_CLK_SEL_DIV_30MHZ)\n#define CANFD_CLK_SEL_40MHZ\t\t(CANFD_CLK_SEL_SRC_240MHZ |\\\n\t\t\t\t\t\tCANFD_CLK_SEL_DIV_40MHZ)\n#define CANFD_CLK_SEL_60MHZ\t\t(CANFD_CLK_SEL_SRC_240MHZ |\\\n\t\t\t\t\t\tCANFD_CLK_SEL_DIV_60MHZ)\n#define CANFD_CLK_SEL_80MHZ\t\t(CANFD_CLK_SEL_SRC_80MHZ)\n\n \n#define CANFD_CTL_UNC_BIT\t\t0x00010000\t \n#define CANFD_CTL_RST_BIT\t\t0x00020000\t \n#define CANFD_CTL_IEN_BIT\t\t0x00040000\t \n\n \n#define CANFD_CTL_IRQ_CL_DEF\t16\t \n#define CANFD_CTL_IRQ_TL_DEF\t10\t \n\n \n#define PCIEFD_TX_PAGE_COUNT\t(PCIEFD_TX_DMA_SIZE / PCIEFD_TX_PAGE_SIZE)\n\n#define CANFD_MSG_LNK_TX\t0x1001\t \n\n \nstatic inline int pciefd_irq_tag(u32 irq_status)\n{\n\treturn irq_status & 0x0000000f;\n}\n\nstatic inline int pciefd_irq_rx_cnt(u32 irq_status)\n{\n\treturn (irq_status & 0x000007f0) >> 4;\n}\n\nstatic inline int pciefd_irq_is_lnk(u32 irq_status)\n{\n\treturn irq_status & 0x00010000;\n}\n\n \nstruct pciefd_rx_dma {\n\t__le32 irq_status;\n\t__le32 sys_time_low;\n\t__le32 sys_time_high;\n\tstruct pucan_rx_msg msg[];\n} __packed __aligned(4);\n\n \nstruct pciefd_tx_link {\n\t__le16 size;\n\t__le16 type;\n\t__le32 laddr_lo;\n\t__le32 laddr_hi;\n} __packed __aligned(4);\n\n \nstruct pciefd_page {\n\tvoid *vbase;\t\t\t \n\tdma_addr_t lbase;\t\t \n\tu32 offset;\n\tu32 size;\n};\n\n \nstruct pciefd_board;\nstruct pciefd_can {\n\tstruct peak_canfd_priv ucan;\t \n\tvoid __iomem *reg_base;\t\t \n\tstruct pciefd_board *board;\t \n\n\tstruct pucan_command pucan_cmd;\t \n\n\tdma_addr_t rx_dma_laddr;\t \n\tvoid *rx_dma_vaddr;\t\t \n\tdma_addr_t tx_dma_laddr;\n\tvoid *tx_dma_vaddr;\n\n\tstruct pciefd_page tx_pages[PCIEFD_TX_PAGE_COUNT];\n\tu16 tx_pages_free;\t\t \n\tu16 tx_page_index;\t\t \n\tspinlock_t tx_lock;\n\n\tu32 irq_status;\n\tu32 irq_tag;\t\t\t\t \n};\n\n \nstruct pciefd_board {\n\tvoid __iomem *reg_base;\n\tstruct pci_dev *pci_dev;\n\tint can_count;\n\tspinlock_t cmd_lock;\t\t \n\tstruct pciefd_can *can[];\t \n};\n\n \nstatic const struct pci_device_id peak_pciefd_tbl[] = {\n\t{PEAK_PCI_VENDOR_ID, PEAK_PCIEFD_ID, PCI_ANY_ID, PCI_ANY_ID,},\n\t{PEAK_PCI_VENDOR_ID, PCAN_CPCIEFD_ID, PCI_ANY_ID, PCI_ANY_ID,},\n\t{PEAK_PCI_VENDOR_ID, PCAN_PCIE104FD_ID, PCI_ANY_ID, PCI_ANY_ID,},\n\t{PEAK_PCI_VENDOR_ID, PCAN_MINIPCIEFD_ID, PCI_ANY_ID, PCI_ANY_ID,},\n\t{PEAK_PCI_VENDOR_ID, PCAN_PCIEFD_OEM_ID, PCI_ANY_ID, PCI_ANY_ID,},\n\t{PEAK_PCI_VENDOR_ID, PCAN_M2_ID, PCI_ANY_ID, PCI_ANY_ID,},\n\t{0,}\n};\n\nMODULE_DEVICE_TABLE(pci, peak_pciefd_tbl);\n\n \nstatic inline u32 pciefd_sys_readreg(const struct pciefd_board *priv, u16 reg)\n{\n\treturn readl(priv->reg_base + reg);\n}\n\n \nstatic inline void pciefd_sys_writereg(const struct pciefd_board *priv,\n\t\t\t\t       u32 val, u16 reg)\n{\n\twritel(val, priv->reg_base + reg);\n}\n\n \nstatic inline u32 pciefd_can_readreg(const struct pciefd_can *priv, u16 reg)\n{\n\treturn readl(priv->reg_base + reg);\n}\n\n \nstatic inline void pciefd_can_writereg(const struct pciefd_can *priv,\n\t\t\t\t       u32 val, u16 reg)\n{\n\twritel(val, priv->reg_base + reg);\n}\n\n \nstatic void pciefd_can_setup_rx_dma(struct pciefd_can *priv)\n{\n#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT\n\tconst u32 dma_addr_h = (u32)(priv->rx_dma_laddr >> 32);\n#else\n\tconst u32 dma_addr_h = 0;\n#endif\n\n\t \n\tpciefd_can_writereg(priv, CANFD_CTL_RST_BIT, PCIEFD_REG_CAN_RX_CTL_SET);\n\n\t \n\tpciefd_can_writereg(priv, (u32)priv->rx_dma_laddr,\n\t\t\t    PCIEFD_REG_CAN_RX_DMA_ADDR_L);\n\tpciefd_can_writereg(priv, dma_addr_h, PCIEFD_REG_CAN_RX_DMA_ADDR_H);\n\n\t \n\tpciefd_can_writereg(priv, CANFD_CTL_UNC_BIT, PCIEFD_REG_CAN_RX_CTL_CLR);\n}\n\n \nstatic void pciefd_can_clear_rx_dma(struct pciefd_can *priv)\n{\n\t \n\tpciefd_can_writereg(priv, CANFD_CTL_RST_BIT, PCIEFD_REG_CAN_RX_CTL_SET);\n\n\t \n\tpciefd_can_writereg(priv, 0, PCIEFD_REG_CAN_RX_DMA_ADDR_L);\n\tpciefd_can_writereg(priv, 0, PCIEFD_REG_CAN_RX_DMA_ADDR_H);\n}\n\n \nstatic void pciefd_can_setup_tx_dma(struct pciefd_can *priv)\n{\n#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT\n\tconst u32 dma_addr_h = (u32)(priv->tx_dma_laddr >> 32);\n#else\n\tconst u32 dma_addr_h = 0;\n#endif\n\n\t \n\tpciefd_can_writereg(priv, CANFD_CTL_RST_BIT, PCIEFD_REG_CAN_TX_CTL_SET);\n\n\t \n\tpciefd_can_writereg(priv, (u32)priv->tx_dma_laddr,\n\t\t\t    PCIEFD_REG_CAN_TX_DMA_ADDR_L);\n\tpciefd_can_writereg(priv, dma_addr_h, PCIEFD_REG_CAN_TX_DMA_ADDR_H);\n\n\t \n\tpciefd_can_writereg(priv, CANFD_CTL_UNC_BIT, PCIEFD_REG_CAN_TX_CTL_CLR);\n}\n\n \nstatic void pciefd_can_clear_tx_dma(struct pciefd_can *priv)\n{\n\t \n\tpciefd_can_writereg(priv, CANFD_CTL_RST_BIT, PCIEFD_REG_CAN_TX_CTL_SET);\n\n\t \n\tpciefd_can_writereg(priv, 0, PCIEFD_REG_CAN_TX_DMA_ADDR_L);\n\tpciefd_can_writereg(priv, 0, PCIEFD_REG_CAN_TX_DMA_ADDR_H);\n}\n\nstatic void pciefd_can_ack_rx_dma(struct pciefd_can *priv)\n{\n\t \n\tpriv->irq_tag = le32_to_cpu(*(__le32 *)priv->rx_dma_vaddr);\n\tpriv->irq_tag++;\n\tpriv->irq_tag &= 0xf;\n\n\t \n\tpciefd_can_writereg(priv, priv->irq_tag, PCIEFD_REG_CAN_RX_CTL_ACK);\n}\n\n \nstatic irqreturn_t pciefd_irq_handler(int irq, void *arg)\n{\n\tstruct pciefd_can *priv = arg;\n\tstruct pciefd_rx_dma *rx_dma = priv->rx_dma_vaddr;\n\n\t \n\tif (!pci_dev_msi_enabled(priv->board->pci_dev))\n\t\t(void)pciefd_sys_readreg(priv->board, PCIEFD_REG_SYS_VER1);\n\n\t \n\tpriv->irq_status = le32_to_cpu(rx_dma->irq_status);\n\n\t \n\tif (pciefd_irq_tag(priv->irq_status) != priv->irq_tag)\n\t\treturn IRQ_NONE;\n\n\t \n\tpeak_canfd_handle_msgs_list(&priv->ucan,\n\t\t\t\t    rx_dma->msg,\n\t\t\t\t    pciefd_irq_rx_cnt(priv->irq_status));\n\n\t \n\tif (pciefd_irq_is_lnk(priv->irq_status)) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&priv->tx_lock, flags);\n\t\tpriv->tx_pages_free++;\n\t\tspin_unlock_irqrestore(&priv->tx_lock, flags);\n\n\t\t \n\t\tspin_lock_irqsave(&priv->ucan.echo_lock, flags);\n\t\tif (!priv->ucan.can.echo_skb[priv->ucan.echo_idx])\n\t\t\tnetif_wake_queue(priv->ucan.ndev);\n\n\t\tspin_unlock_irqrestore(&priv->ucan.echo_lock, flags);\n\t}\n\n\t \n\tpciefd_can_ack_rx_dma(priv);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int pciefd_enable_tx_path(struct peak_canfd_priv *ucan)\n{\n\tstruct pciefd_can *priv = (struct pciefd_can *)ucan;\n\tint i;\n\n\t \n\tpriv->tx_pages_free = PCIEFD_TX_PAGE_COUNT - 1;\n\tpriv->tx_page_index = 0;\n\n\tpriv->tx_pages[0].vbase = priv->tx_dma_vaddr;\n\tpriv->tx_pages[0].lbase = priv->tx_dma_laddr;\n\n\tfor (i = 0; i < PCIEFD_TX_PAGE_COUNT; i++) {\n\t\tpriv->tx_pages[i].offset = 0;\n\t\tpriv->tx_pages[i].size = PCIEFD_TX_PAGE_SIZE -\n\t\t\t\t\t sizeof(struct pciefd_tx_link);\n\t\tif (i) {\n\t\t\tpriv->tx_pages[i].vbase =\n\t\t\t\t\t  priv->tx_pages[i - 1].vbase +\n\t\t\t\t\t  PCIEFD_TX_PAGE_SIZE;\n\t\t\tpriv->tx_pages[i].lbase =\n\t\t\t\t\t  priv->tx_pages[i - 1].lbase +\n\t\t\t\t\t  PCIEFD_TX_PAGE_SIZE;\n\t\t}\n\t}\n\n\t \n\tpciefd_can_setup_tx_dma(priv);\n\n\t \n\tpciefd_can_writereg(priv, CANFD_CTL_RST_BIT, PCIEFD_REG_CAN_TX_CTL_CLR);\n\n\treturn 0;\n}\n\n \nstatic int pciefd_pre_cmd(struct peak_canfd_priv *ucan)\n{\n\tstruct pciefd_can *priv = (struct pciefd_can *)ucan;\n\tu16 cmd = pucan_cmd_get_opcode(&priv->pucan_cmd);\n\tint err;\n\n\t \n\tswitch (cmd) {\n\tcase PUCAN_CMD_NORMAL_MODE:\n\tcase PUCAN_CMD_LISTEN_ONLY_MODE:\n\n\t\tif (ucan->can.state == CAN_STATE_BUS_OFF)\n\t\t\tbreak;\n\n\t\t \n\t\terr = request_irq(priv->ucan.ndev->irq,\n\t\t\t\t  pciefd_irq_handler,\n\t\t\t\t  IRQF_SHARED,\n\t\t\t\t  PCIEFD_DRV_NAME,\n\t\t\t\t  priv);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tpciefd_can_setup_rx_dma(priv);\n\n\t\t \n\t\tpciefd_can_writereg(priv, (CANFD_CTL_IRQ_TL_DEF) << 8 |\n\t\t\t\t    CANFD_CTL_IRQ_CL_DEF,\n\t\t\t\t    PCIEFD_REG_CAN_RX_CTL_WRT);\n\n\t\t \n\t\tpciefd_can_writereg(priv, CANFD_CTL_RST_BIT,\n\t\t\t\t    PCIEFD_REG_CAN_RX_CTL_CLR);\n\n\t\t \n\t\tpciefd_can_writereg(priv, !CANFD_MISC_TS_RST,\n\t\t\t\t    PCIEFD_REG_CAN_MISC);\n\n\t\t \n\t\tpciefd_can_ack_rx_dma(priv);\n\n\t\t \n\t\tpciefd_can_writereg(priv, CANFD_CTL_IEN_BIT,\n\t\t\t\t    PCIEFD_REG_CAN_RX_CTL_SET);\n\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int pciefd_write_cmd(struct peak_canfd_priv *ucan)\n{\n\tstruct pciefd_can *priv = (struct pciefd_can *)ucan;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&priv->board->cmd_lock, flags);\n\n\tpciefd_can_writereg(priv, *(u32 *)ucan->cmd_buffer,\n\t\t\t    PCIEFD_REG_CAN_CMD_PORT_L);\n\tpciefd_can_writereg(priv, *(u32 *)(ucan->cmd_buffer + 4),\n\t\t\t    PCIEFD_REG_CAN_CMD_PORT_H);\n\n\tspin_unlock_irqrestore(&priv->board->cmd_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int pciefd_post_cmd(struct peak_canfd_priv *ucan)\n{\n\tstruct pciefd_can *priv = (struct pciefd_can *)ucan;\n\tu16 cmd = pucan_cmd_get_opcode(&priv->pucan_cmd);\n\n\tswitch (cmd) {\n\tcase PUCAN_CMD_RESET_MODE:\n\n\t\tif (ucan->can.state == CAN_STATE_STOPPED)\n\t\t\tbreak;\n\n\t\t \n\n\t\t \n\t\tpciefd_can_writereg(priv, CANFD_CTL_IEN_BIT,\n\t\t\t\t    PCIEFD_REG_CAN_RX_CTL_CLR);\n\n\t\t \n\t\tpciefd_can_clear_tx_dma(priv);\n\t\tpciefd_can_clear_rx_dma(priv);\n\n\t\t \n\t\t(void)pciefd_sys_readreg(priv->board, PCIEFD_REG_SYS_VER1);\n\n\t\tfree_irq(priv->ucan.ndev->irq, priv);\n\n\t\tucan->can.state = CAN_STATE_STOPPED;\n\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void *pciefd_alloc_tx_msg(struct peak_canfd_priv *ucan, u16 msg_size,\n\t\t\t\t int *room_left)\n{\n\tstruct pciefd_can *priv = (struct pciefd_can *)ucan;\n\tstruct pciefd_page *page = priv->tx_pages + priv->tx_page_index;\n\tunsigned long flags;\n\tvoid *msg;\n\n\tspin_lock_irqsave(&priv->tx_lock, flags);\n\n\tif (page->offset + msg_size > page->size) {\n\t\tstruct pciefd_tx_link *lk;\n\n\t\t \n\t\tif (!priv->tx_pages_free) {\n\t\t\tspin_unlock_irqrestore(&priv->tx_lock, flags);\n\n\t\t\t \n\t\t\treturn NULL;\n\t\t}\n\n\t\tpriv->tx_pages_free--;\n\n\t\t \n\t\tlk = page->vbase + page->offset;\n\n\t\t \n\t\tpriv->tx_page_index = (priv->tx_page_index + 1) %\n\t\t\t\t      PCIEFD_TX_PAGE_COUNT;\n\t\tpage = priv->tx_pages + priv->tx_page_index;\n\n\t\t \n\t\tlk->size = cpu_to_le16(sizeof(*lk));\n\t\tlk->type = cpu_to_le16(CANFD_MSG_LNK_TX);\n\t\tlk->laddr_lo = cpu_to_le32(page->lbase);\n\n#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT\n\t\tlk->laddr_hi = cpu_to_le32(page->lbase >> 32);\n#else\n\t\tlk->laddr_hi = 0;\n#endif\n\t\t \n\t\tpage->offset = 0;\n\t}\n\n\t*room_left = priv->tx_pages_free * page->size;\n\n\tspin_unlock_irqrestore(&priv->tx_lock, flags);\n\n\tmsg = page->vbase + page->offset;\n\n\t \n\t*room_left += page->size - (page->offset + msg_size);\n\n\treturn msg;\n}\n\nstatic int pciefd_write_tx_msg(struct peak_canfd_priv *ucan,\n\t\t\t       struct pucan_tx_msg *msg)\n{\n\tstruct pciefd_can *priv = (struct pciefd_can *)ucan;\n\tstruct pciefd_page *page = priv->tx_pages + priv->tx_page_index;\n\n\t \n\tpage->offset += le16_to_cpu(msg->size);\n\n\t \n\tpciefd_can_writereg(priv, 1, PCIEFD_REG_CAN_TX_REQ_ACC);\n\n\treturn 0;\n}\n\n \nstatic int pciefd_can_probe(struct pciefd_board *pciefd)\n{\n\tstruct net_device *ndev;\n\tstruct pciefd_can *priv;\n\tu32 clk;\n\tint err;\n\n\t \n\tndev = alloc_peak_canfd_dev(sizeof(*priv), pciefd->can_count,\n\t\t\t\t    PCIEFD_ECHO_SKB_MAX);\n\tif (!ndev) {\n\t\tdev_err(&pciefd->pci_dev->dev,\n\t\t\t\"failed to alloc candev object\\n\");\n\t\tgoto failure;\n\t}\n\n\tpriv = netdev_priv(ndev);\n\n\t \n\n\t \n\tpriv->ucan.pre_cmd = pciefd_pre_cmd;\n\tpriv->ucan.write_cmd = pciefd_write_cmd;\n\tpriv->ucan.post_cmd = pciefd_post_cmd;\n\tpriv->ucan.enable_tx_path = pciefd_enable_tx_path;\n\tpriv->ucan.alloc_tx_msg = pciefd_alloc_tx_msg;\n\tpriv->ucan.write_tx_msg = pciefd_write_tx_msg;\n\n\t \n\tpriv->ucan.cmd_buffer = &priv->pucan_cmd;\n\tpriv->ucan.cmd_maxlen = sizeof(priv->pucan_cmd);\n\n\tpriv->board = pciefd;\n\n\t \n\tpriv->reg_base = pciefd->reg_base + PCIEFD_CANX_OFF(priv->ucan.index);\n\n\t \n\tpriv->rx_dma_vaddr = dmam_alloc_coherent(&pciefd->pci_dev->dev,\n\t\t\t\t\t\t PCIEFD_RX_DMA_SIZE,\n\t\t\t\t\t\t &priv->rx_dma_laddr,\n\t\t\t\t\t\t GFP_KERNEL);\n\tif (!priv->rx_dma_vaddr) {\n\t\tdev_err(&pciefd->pci_dev->dev,\n\t\t\t\"Rx dmam_alloc_coherent(%u) failure\\n\",\n\t\t\tPCIEFD_RX_DMA_SIZE);\n\t\tgoto err_free_candev;\n\t}\n\n\t \n\tpriv->tx_dma_vaddr = dmam_alloc_coherent(&pciefd->pci_dev->dev,\n\t\t\t\t\t\t PCIEFD_TX_DMA_SIZE,\n\t\t\t\t\t\t &priv->tx_dma_laddr,\n\t\t\t\t\t\t GFP_KERNEL);\n\tif (!priv->tx_dma_vaddr) {\n\t\tdev_err(&pciefd->pci_dev->dev,\n\t\t\t\"Tx dmam_alloc_coherent(%u) failure\\n\",\n\t\t\tPCIEFD_TX_DMA_SIZE);\n\t\tgoto err_free_candev;\n\t}\n\n\t \n\tpciefd_can_writereg(priv, CANFD_MISC_TS_RST, PCIEFD_REG_CAN_MISC);\n\n\t \n\tclk = pciefd_can_readreg(priv, PCIEFD_REG_CAN_CLK_SEL);\n\tswitch (clk) {\n\tcase CANFD_CLK_SEL_20MHZ:\n\t\tpriv->ucan.can.clock.freq = 20 * 1000 * 1000;\n\t\tbreak;\n\tcase CANFD_CLK_SEL_24MHZ:\n\t\tpriv->ucan.can.clock.freq = 24 * 1000 * 1000;\n\t\tbreak;\n\tcase CANFD_CLK_SEL_30MHZ:\n\t\tpriv->ucan.can.clock.freq = 30 * 1000 * 1000;\n\t\tbreak;\n\tcase CANFD_CLK_SEL_40MHZ:\n\t\tpriv->ucan.can.clock.freq = 40 * 1000 * 1000;\n\t\tbreak;\n\tcase CANFD_CLK_SEL_60MHZ:\n\t\tpriv->ucan.can.clock.freq = 60 * 1000 * 1000;\n\t\tbreak;\n\tdefault:\n\t\tpciefd_can_writereg(priv, CANFD_CLK_SEL_80MHZ,\n\t\t\t\t    PCIEFD_REG_CAN_CLK_SEL);\n\n\t\tfallthrough;\n\tcase CANFD_CLK_SEL_80MHZ:\n\t\tpriv->ucan.can.clock.freq = 80 * 1000 * 1000;\n\t\tbreak;\n\t}\n\n\tndev->irq = pciefd->pci_dev->irq;\n\n\tSET_NETDEV_DEV(ndev, &pciefd->pci_dev->dev);\n\n\terr = register_candev(ndev);\n\tif (err) {\n\t\tdev_err(&pciefd->pci_dev->dev,\n\t\t\t\"couldn't register CAN device: %d\\n\", err);\n\t\tgoto err_free_candev;\n\t}\n\n\tspin_lock_init(&priv->tx_lock);\n\n\t \n\tpciefd->can[pciefd->can_count] = priv;\n\n\tdev_info(&pciefd->pci_dev->dev, \"%s at reg_base=0x%p irq=%d\\n\",\n\t\t ndev->name, priv->reg_base, ndev->irq);\n\n\treturn 0;\n\nerr_free_candev:\n\tfree_candev(ndev);\n\nfailure:\n\treturn -ENOMEM;\n}\n\n \nstatic void pciefd_can_remove(struct pciefd_can *priv)\n{\n\t \n\tunregister_candev(priv->ucan.ndev);\n\n\t \n\tfree_candev(priv->ucan.ndev);\n}\n\n \nstatic void pciefd_can_remove_all(struct pciefd_board *pciefd)\n{\n\twhile (pciefd->can_count > 0)\n\t\tpciefd_can_remove(pciefd->can[--pciefd->can_count]);\n}\n\n \nstatic int peak_pciefd_probe(struct pci_dev *pdev,\n\t\t\t     const struct pci_device_id *ent)\n{\n\tstruct pciefd_board *pciefd;\n\tint err, can_count;\n\tu16 sub_sys_id;\n\tu8 hw_ver_major;\n\tu8 hw_ver_minor;\n\tu8 hw_ver_sub;\n\tu32 v2;\n\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\treturn err;\n\terr = pci_request_regions(pdev, PCIEFD_DRV_NAME);\n\tif (err)\n\t\tgoto err_disable_pci;\n\n\t \n\terr = pci_read_config_word(pdev, PCI_SUBSYSTEM_ID, &sub_sys_id);\n\tif (err)\n\t\tgoto err_release_regions;\n\n\tdev_dbg(&pdev->dev, \"probing device %04x:%04x:%04x\\n\",\n\t\tpdev->vendor, pdev->device, sub_sys_id);\n\n\tif (sub_sys_id >= 0x0012)\n\t\tcan_count = 4;\n\telse if (sub_sys_id >= 0x0010)\n\t\tcan_count = 3;\n\telse if (sub_sys_id >= 0x0004)\n\t\tcan_count = 2;\n\telse\n\t\tcan_count = 1;\n\n\t \n\tpciefd = devm_kzalloc(&pdev->dev, struct_size(pciefd, can, can_count),\n\t\t\t      GFP_KERNEL);\n\tif (!pciefd) {\n\t\terr = -ENOMEM;\n\t\tgoto err_release_regions;\n\t}\n\n\t \n\tpciefd->pci_dev = pdev;\n\tspin_lock_init(&pciefd->cmd_lock);\n\n\t \n\tpciefd->reg_base = pci_iomap(pdev, 0, PCIEFD_BAR0_SIZE);\n\tif (!pciefd->reg_base) {\n\t\tdev_err(&pdev->dev, \"failed to map PCI resource #0\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_release_regions;\n\t}\n\n\t \n\tv2 = pciefd_sys_readreg(pciefd, PCIEFD_REG_SYS_VER2);\n\n\thw_ver_major = (v2 & 0x0000f000) >> 12;\n\thw_ver_minor = (v2 & 0x00000f00) >> 8;\n\thw_ver_sub = (v2 & 0x000000f0) >> 4;\n\n\tdev_info(&pdev->dev,\n\t\t \"%ux CAN-FD PCAN-PCIe FPGA v%u.%u.%u:\\n\", can_count,\n\t\t hw_ver_major, hw_ver_minor, hw_ver_sub);\n\n#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT\n\t \n\tif (PCIEFD_FW_VERSION(hw_ver_major, hw_ver_minor, hw_ver_sub) <\n\t    PCIEFD_FW_VERSION(3, 3, 0)) {\n\t\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (err)\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"warning: can't set DMA mask %llxh (err %d)\\n\",\n\t\t\t\t DMA_BIT_MASK(32), err);\n\t}\n#endif\n\n\t \n\tpciefd_sys_writereg(pciefd, PCIEFD_SYS_CTL_CLK_EN,\n\t\t\t    PCIEFD_REG_SYS_CTL_CLR);\n\n\tpci_set_master(pdev);\n\n\t \n\twhile (pciefd->can_count < can_count) {\n\t\terr = pciefd_can_probe(pciefd);\n\t\tif (err)\n\t\t\tgoto err_free_canfd;\n\n\t\tpciefd->can_count++;\n\t}\n\n\t \n\tpciefd_sys_writereg(pciefd, PCIEFD_SYS_CTL_TS_RST,\n\t\t\t    PCIEFD_REG_SYS_CTL_SET);\n\n\t \n\t(void)pciefd_sys_readreg(pciefd, PCIEFD_REG_SYS_VER1);\n\n\t \n\tpciefd_sys_writereg(pciefd, PCIEFD_SYS_CTL_TS_RST,\n\t\t\t    PCIEFD_REG_SYS_CTL_CLR);\n\n\t \n\tpciefd_sys_writereg(pciefd, PCIEFD_SYS_CTL_CLK_EN,\n\t\t\t    PCIEFD_REG_SYS_CTL_SET);\n\n\t \n\tpci_set_drvdata(pdev, pciefd);\n\n\treturn 0;\n\nerr_free_canfd:\n\tpciefd_can_remove_all(pciefd);\n\n\tpci_iounmap(pdev, pciefd->reg_base);\n\nerr_release_regions:\n\tpci_release_regions(pdev);\n\nerr_disable_pci:\n\tpci_disable_device(pdev);\n\n\t \n\treturn pcibios_err_to_errno(err);\n}\n\n \nstatic void peak_pciefd_remove(struct pci_dev *pdev)\n{\n\tstruct pciefd_board *pciefd = pci_get_drvdata(pdev);\n\n\t \n\tpciefd_can_remove_all(pciefd);\n\n\tpci_iounmap(pdev, pciefd->reg_base);\n\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n}\n\nstatic struct pci_driver peak_pciefd_driver = {\n\t.name = PCIEFD_DRV_NAME,\n\t.id_table = peak_pciefd_tbl,\n\t.probe = peak_pciefd_probe,\n\t.remove = peak_pciefd_remove,\n};\n\nmodule_pci_driver(peak_pciefd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}