{
  "module_name": "peak_canfd.c",
  "hash_id": "3d6fe5a62cbd55412151887930f76f36c57dce572c0b1dae4c7edc8368290305",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/peak_canfd/peak_canfd.c",
  "human_readable_source": "\n \n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/ethtool.h>\n\n#include \"peak_canfd_user.h\"\n\n \n#define PCANFD_ECHO_SKB_MAX\t\t24\n\n \nstatic const struct can_bittiming_const peak_canfd_nominal_const = {\n\t.name = \"peak_canfd\",\n\t.tseg1_min = 1,\n\t.tseg1_max = (1 << PUCAN_TSLOW_TSGEG1_BITS),\n\t.tseg2_min = 1,\n\t.tseg2_max = (1 << PUCAN_TSLOW_TSGEG2_BITS),\n\t.sjw_max = (1 << PUCAN_TSLOW_SJW_BITS),\n\t.brp_min = 1,\n\t.brp_max = (1 << PUCAN_TSLOW_BRP_BITS),\n\t.brp_inc = 1,\n};\n\nstatic const struct can_bittiming_const peak_canfd_data_const = {\n\t.name = \"peak_canfd\",\n\t.tseg1_min = 1,\n\t.tseg1_max = (1 << PUCAN_TFAST_TSGEG1_BITS),\n\t.tseg2_min = 1,\n\t.tseg2_max = (1 << PUCAN_TFAST_TSGEG2_BITS),\n\t.sjw_max = (1 << PUCAN_TFAST_SJW_BITS),\n\t.brp_min = 1,\n\t.brp_max = (1 << PUCAN_TFAST_BRP_BITS),\n\t.brp_inc = 1,\n};\n\nstatic struct peak_canfd_priv *pucan_init_cmd(struct peak_canfd_priv *priv)\n{\n\tpriv->cmd_len = 0;\n\treturn priv;\n}\n\nstatic void *pucan_add_cmd(struct peak_canfd_priv *priv, int cmd_op)\n{\n\tstruct pucan_command *cmd;\n\n\tif (priv->cmd_len + sizeof(*cmd) > priv->cmd_maxlen)\n\t\treturn NULL;\n\n\tcmd = priv->cmd_buffer + priv->cmd_len;\n\n\t \n\tmemset(cmd, 0, sizeof(*cmd));\n\n\tcmd->opcode_channel = pucan_cmd_opcode_channel(priv->index, cmd_op);\n\tpriv->cmd_len += sizeof(*cmd);\n\n\treturn cmd;\n}\n\nstatic int pucan_write_cmd(struct peak_canfd_priv *priv)\n{\n\tint err;\n\n\tif (priv->pre_cmd) {\n\t\terr = priv->pre_cmd(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = priv->write_cmd(priv);\n\tif (err)\n\t\treturn err;\n\n\tif (priv->post_cmd)\n\t\terr = priv->post_cmd(priv);\n\n\treturn err;\n}\n\n \nstatic int pucan_set_reset_mode(struct peak_canfd_priv *priv)\n{\n\tpucan_add_cmd(pucan_init_cmd(priv), PUCAN_CMD_RESET_MODE);\n\treturn pucan_write_cmd(priv);\n}\n\nstatic int pucan_set_normal_mode(struct peak_canfd_priv *priv)\n{\n\tint err;\n\n\tpucan_add_cmd(pucan_init_cmd(priv), PUCAN_CMD_NORMAL_MODE);\n\terr = pucan_write_cmd(priv);\n\tif (!err)\n\t\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\treturn err;\n}\n\nstatic int pucan_set_listen_only_mode(struct peak_canfd_priv *priv)\n{\n\tint err;\n\n\tpucan_add_cmd(pucan_init_cmd(priv), PUCAN_CMD_LISTEN_ONLY_MODE);\n\terr = pucan_write_cmd(priv);\n\tif (!err)\n\t\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\treturn err;\n}\n\nstatic int pucan_set_timing_slow(struct peak_canfd_priv *priv,\n\t\t\t\t const struct can_bittiming *pbt)\n{\n\tstruct pucan_timing_slow *cmd;\n\n\tcmd = pucan_add_cmd(pucan_init_cmd(priv), PUCAN_CMD_TIMING_SLOW);\n\n\tcmd->sjw_t = PUCAN_TSLOW_SJW_T(pbt->sjw - 1,\n\t\t\t\t       priv->can.ctrlmode &\n\t\t\t\t       CAN_CTRLMODE_3_SAMPLES);\n\tcmd->tseg1 = PUCAN_TSLOW_TSEG1(pbt->prop_seg + pbt->phase_seg1 - 1);\n\tcmd->tseg2 = PUCAN_TSLOW_TSEG2(pbt->phase_seg2 - 1);\n\tcmd->brp = cpu_to_le16(PUCAN_TSLOW_BRP(pbt->brp - 1));\n\n\tcmd->ewl = 96;\t \n\n\tnetdev_dbg(priv->ndev,\n\t\t   \"nominal: brp=%u tseg1=%u tseg2=%u sjw=%u\\n\",\n\t\t   le16_to_cpu(cmd->brp), cmd->tseg1, cmd->tseg2, cmd->sjw_t);\n\n\treturn pucan_write_cmd(priv);\n}\n\nstatic int pucan_set_timing_fast(struct peak_canfd_priv *priv,\n\t\t\t\t const struct can_bittiming *pbt)\n{\n\tstruct pucan_timing_fast *cmd;\n\n\tcmd = pucan_add_cmd(pucan_init_cmd(priv), PUCAN_CMD_TIMING_FAST);\n\n\tcmd->sjw = PUCAN_TFAST_SJW(pbt->sjw - 1);\n\tcmd->tseg1 = PUCAN_TFAST_TSEG1(pbt->prop_seg + pbt->phase_seg1 - 1);\n\tcmd->tseg2 = PUCAN_TFAST_TSEG2(pbt->phase_seg2 - 1);\n\tcmd->brp = cpu_to_le16(PUCAN_TFAST_BRP(pbt->brp - 1));\n\n\tnetdev_dbg(priv->ndev,\n\t\t   \"data: brp=%u tseg1=%u tseg2=%u sjw=%u\\n\",\n\t\t   le16_to_cpu(cmd->brp), cmd->tseg1, cmd->tseg2, cmd->sjw);\n\n\treturn pucan_write_cmd(priv);\n}\n\nstatic int pucan_set_std_filter(struct peak_canfd_priv *priv, u8 row, u32 mask)\n{\n\tstruct pucan_std_filter *cmd;\n\n\tcmd = pucan_add_cmd(pucan_init_cmd(priv), PUCAN_CMD_SET_STD_FILTER);\n\n\t \n\n\t \n\tcmd->idx = row;\n\n\t \n\tcmd->mask = cpu_to_le32(mask);\n\n\treturn pucan_write_cmd(priv);\n}\n\nstatic int pucan_tx_abort(struct peak_canfd_priv *priv, u16 flags)\n{\n\tstruct pucan_tx_abort *cmd;\n\n\tcmd = pucan_add_cmd(pucan_init_cmd(priv), PUCAN_CMD_TX_ABORT);\n\n\tcmd->flags = cpu_to_le16(flags);\n\n\treturn pucan_write_cmd(priv);\n}\n\nstatic int pucan_clr_err_counters(struct peak_canfd_priv *priv)\n{\n\tstruct pucan_wr_err_cnt *cmd;\n\n\tcmd = pucan_add_cmd(pucan_init_cmd(priv), PUCAN_CMD_WR_ERR_CNT);\n\n\tcmd->sel_mask = cpu_to_le16(PUCAN_WRERRCNT_TE | PUCAN_WRERRCNT_RE);\n\tcmd->tx_counter = 0;\n\tcmd->rx_counter = 0;\n\n\treturn pucan_write_cmd(priv);\n}\n\nstatic int pucan_set_options(struct peak_canfd_priv *priv, u16 opt_mask)\n{\n\tstruct pucan_options *cmd;\n\n\tcmd = pucan_add_cmd(pucan_init_cmd(priv), PUCAN_CMD_SET_EN_OPTION);\n\n\tcmd->options = cpu_to_le16(opt_mask);\n\n\treturn pucan_write_cmd(priv);\n}\n\nstatic int pucan_clr_options(struct peak_canfd_priv *priv, u16 opt_mask)\n{\n\tstruct pucan_options *cmd;\n\n\tcmd = pucan_add_cmd(pucan_init_cmd(priv), PUCAN_CMD_CLR_DIS_OPTION);\n\n\tcmd->options = cpu_to_le16(opt_mask);\n\n\treturn pucan_write_cmd(priv);\n}\n\nstatic int pucan_setup_rx_barrier(struct peak_canfd_priv *priv)\n{\n\tpucan_add_cmd(pucan_init_cmd(priv), PUCAN_CMD_RX_BARRIER);\n\n\treturn pucan_write_cmd(priv);\n}\n\nstatic int pucan_netif_rx(struct sk_buff *skb, __le32 ts_low, __le32 ts_high)\n{\n\tstruct skb_shared_hwtstamps *hwts = skb_hwtstamps(skb);\n\tu64 ts_us;\n\n\tts_us = (u64)le32_to_cpu(ts_high) << 32;\n\tts_us |= le32_to_cpu(ts_low);\n\n\t \n\thwts->hwtstamp = ns_to_ktime(ts_us * NSEC_PER_USEC);\n\n\treturn netif_rx(skb);\n}\n\n \nstatic int pucan_handle_can_rx(struct peak_canfd_priv *priv,\n\t\t\t       struct pucan_rx_msg *msg)\n{\n\tstruct net_device_stats *stats = &priv->ndev->stats;\n\tstruct canfd_frame *cf;\n\tstruct sk_buff *skb;\n\tconst u16 rx_msg_flags = le16_to_cpu(msg->flags);\n\tu8 cf_len;\n\n\tif (rx_msg_flags & PUCAN_MSG_EXT_DATA_LEN)\n\t\tcf_len = can_fd_dlc2len(pucan_msg_get_dlc(msg));\n\telse\n\t\tcf_len = can_cc_dlc2len(pucan_msg_get_dlc(msg));\n\n\t \n\tif (rx_msg_flags & PUCAN_MSG_LOOPED_BACK) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&priv->echo_lock, flags);\n\n\t\t \n\t\tstats->tx_bytes += can_get_echo_skb(priv->ndev, msg->client, NULL);\n\t\tstats->tx_packets++;\n\n\t\t \n\t\tnetif_wake_queue(priv->ndev);\n\n\t\tspin_unlock_irqrestore(&priv->echo_lock, flags);\n\n\t\t \n\t\tif (!(rx_msg_flags & PUCAN_MSG_SELF_RECEIVE))\n\t\t\treturn 0;\n\t}\n\n\t \n\tif (rx_msg_flags & PUCAN_MSG_EXT_DATA_LEN) {\n\t\t \n\t\tskb = alloc_canfd_skb(priv->ndev, &cf);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\n\t\tif (rx_msg_flags & PUCAN_MSG_BITRATE_SWITCH)\n\t\t\tcf->flags |= CANFD_BRS;\n\n\t\tif (rx_msg_flags & PUCAN_MSG_ERROR_STATE_IND)\n\t\t\tcf->flags |= CANFD_ESI;\n\t} else {\n\t\t \n\t\tskb = alloc_can_skb(priv->ndev, (struct can_frame **)&cf);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tcf->can_id = le32_to_cpu(msg->can_id);\n\tcf->len = cf_len;\n\n\tif (rx_msg_flags & PUCAN_MSG_EXT_ID)\n\t\tcf->can_id |= CAN_EFF_FLAG;\n\n\tif (rx_msg_flags & PUCAN_MSG_RTR) {\n\t\tcf->can_id |= CAN_RTR_FLAG;\n\t} else {\n\t\tmemcpy(cf->data, msg->d, cf->len);\n\n\t\tstats->rx_bytes += cf->len;\n\t}\n\tstats->rx_packets++;\n\n\tpucan_netif_rx(skb, msg->ts_low, msg->ts_high);\n\n\treturn 0;\n}\n\n \nstatic int pucan_handle_error(struct peak_canfd_priv *priv,\n\t\t\t      struct pucan_error_msg *msg)\n{\n\tpriv->bec.txerr = msg->tx_err_cnt;\n\tpriv->bec.rxerr = msg->rx_err_cnt;\n\n\treturn 0;\n}\n\n \nstatic int pucan_handle_status(struct peak_canfd_priv *priv,\n\t\t\t       struct pucan_status_msg *msg)\n{\n\tstruct net_device *ndev = priv->ndev;\n\tstruct net_device_stats *stats = &ndev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\n\t \n\tif (pucan_status_is_rx_barrier(msg)) {\n\t\tif (priv->enable_tx_path) {\n\t\t\tint err = priv->enable_tx_path(priv);\n\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tnetif_wake_queue(ndev);\n\n\t\treturn 0;\n\t}\n\n\tskb = alloc_can_err_skb(ndev, &cf);\n\n\t \n\tif (pucan_status_is_busoff(msg)) {\n\t\tnetdev_dbg(ndev, \"Bus-off entry status\\n\");\n\t\tpriv->can.state = CAN_STATE_BUS_OFF;\n\t\tpriv->can.can_stats.bus_off++;\n\t\tcan_bus_off(ndev);\n\t\tif (skb)\n\t\t\tcf->can_id |= CAN_ERR_BUSOFF;\n\n\t} else if (pucan_status_is_passive(msg)) {\n\t\tnetdev_dbg(ndev, \"Error passive status\\n\");\n\t\tpriv->can.state = CAN_STATE_ERROR_PASSIVE;\n\t\tpriv->can.can_stats.error_passive++;\n\t\tif (skb) {\n\t\t\tcf->can_id |= CAN_ERR_CRTL | CAN_ERR_CNT;\n\t\t\tcf->data[1] = (priv->bec.txerr > priv->bec.rxerr) ?\n\t\t\t\t\tCAN_ERR_CRTL_TX_PASSIVE :\n\t\t\t\t\tCAN_ERR_CRTL_RX_PASSIVE;\n\t\t\tcf->data[6] = priv->bec.txerr;\n\t\t\tcf->data[7] = priv->bec.rxerr;\n\t\t}\n\n\t} else if (pucan_status_is_warning(msg)) {\n\t\tnetdev_dbg(ndev, \"Error warning status\\n\");\n\t\tpriv->can.state = CAN_STATE_ERROR_WARNING;\n\t\tpriv->can.can_stats.error_warning++;\n\t\tif (skb) {\n\t\t\tcf->can_id |= CAN_ERR_CRTL | CAN_ERR_CNT;\n\t\t\tcf->data[1] = (priv->bec.txerr > priv->bec.rxerr) ?\n\t\t\t\t\tCAN_ERR_CRTL_TX_WARNING :\n\t\t\t\t\tCAN_ERR_CRTL_RX_WARNING;\n\t\t\tcf->data[6] = priv->bec.txerr;\n\t\t\tcf->data[7] = priv->bec.rxerr;\n\t\t}\n\n\t} else if (priv->can.state != CAN_STATE_ERROR_ACTIVE) {\n\t\t \n\t\tnetdev_dbg(ndev, \"Error active status\\n\");\n\t\tcan_change_state(ndev, cf, CAN_STATE_ERROR_ACTIVE,\n\t\t\t\t CAN_STATE_ERROR_ACTIVE);\n\t} else {\n\t\tdev_kfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\tif (!skb) {\n\t\tstats->rx_dropped++;\n\t\treturn -ENOMEM;\n\t}\n\n\tpucan_netif_rx(skb, msg->ts_low, msg->ts_high);\n\n\treturn 0;\n}\n\n \nstatic int pucan_handle_cache_critical(struct peak_canfd_priv *priv)\n{\n\tstruct net_device_stats *stats = &priv->ndev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\n\tstats->rx_over_errors++;\n\tstats->rx_errors++;\n\n\tskb = alloc_can_err_skb(priv->ndev, &cf);\n\tif (!skb) {\n\t\tstats->rx_dropped++;\n\t\treturn -ENOMEM;\n\t}\n\n\tcf->can_id |= CAN_ERR_CRTL | CAN_ERR_CNT;\n\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\n\tcf->data[6] = priv->bec.txerr;\n\tcf->data[7] = priv->bec.rxerr;\n\n\tnetif_rx(skb);\n\n\treturn 0;\n}\n\n \nint peak_canfd_handle_msg(struct peak_canfd_priv *priv,\n\t\t\t  struct pucan_rx_msg *msg)\n{\n\tu16 msg_type = le16_to_cpu(msg->type);\n\tint msg_size = le16_to_cpu(msg->size);\n\tint err;\n\n\tif (!msg_size || !msg_type) {\n\t\t \n\t\tgoto exit;\n\t}\n\n\tswitch (msg_type) {\n\tcase PUCAN_MSG_CAN_RX:\n\t\terr = pucan_handle_can_rx(priv, (struct pucan_rx_msg *)msg);\n\t\tbreak;\n\tcase PUCAN_MSG_ERROR:\n\t\terr = pucan_handle_error(priv, (struct pucan_error_msg *)msg);\n\t\tbreak;\n\tcase PUCAN_MSG_STATUS:\n\t\terr = pucan_handle_status(priv, (struct pucan_status_msg *)msg);\n\t\tbreak;\n\tcase PUCAN_MSG_CACHE_CRITICAL:\n\t\terr = pucan_handle_cache_critical(priv);\n\t\tbreak;\n\tdefault:\n\t\terr = 0;\n\t}\n\n\tif (err < 0)\n\t\treturn err;\n\nexit:\n\treturn msg_size;\n}\n\n \nint peak_canfd_handle_msgs_list(struct peak_canfd_priv *priv,\n\t\t\t\tstruct pucan_rx_msg *msg_list, int msg_count)\n{\n\tvoid *msg_ptr = msg_list;\n\tint i, msg_size = 0;\n\n\tfor (i = 0; i < msg_count; i++) {\n\t\tmsg_size = peak_canfd_handle_msg(priv, msg_ptr);\n\n\t\t \n\t\tif (msg_size <= 0)\n\t\t\tbreak;\n\n\t\tmsg_ptr += ALIGN(msg_size, 4);\n\t}\n\n\tif (msg_size < 0)\n\t\treturn msg_size;\n\n\treturn i;\n}\n\nstatic int peak_canfd_start(struct peak_canfd_priv *priv)\n{\n\tint err;\n\n\terr = pucan_clr_err_counters(priv);\n\tif (err)\n\t\tgoto err_exit;\n\n\tpriv->echo_idx = 0;\n\n\tpriv->bec.txerr = 0;\n\tpriv->bec.rxerr = 0;\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\terr = pucan_set_listen_only_mode(priv);\n\telse\n\t\terr = pucan_set_normal_mode(priv);\n\nerr_exit:\n\treturn err;\n}\n\nstatic void peak_canfd_stop(struct peak_canfd_priv *priv)\n{\n\tint err;\n\n\t \n\terr = pucan_set_reset_mode(priv);\n\tif (err) {\n\t\tnetdev_err(priv->ndev, \"channel %u reset failed\\n\",\n\t\t\t   priv->index);\n\t} else {\n\t\t \n\t\tpucan_tx_abort(priv, PUCAN_TX_ABORT_FLUSH);\n\t}\n}\n\nstatic int peak_canfd_set_mode(struct net_device *ndev, enum can_mode mode)\n{\n\tstruct peak_canfd_priv *priv = netdev_priv(ndev);\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\tpeak_canfd_start(priv);\n\t\tnetif_wake_queue(ndev);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int peak_canfd_get_berr_counter(const struct net_device *ndev,\n\t\t\t\t       struct can_berr_counter *bec)\n{\n\tstruct peak_canfd_priv *priv = netdev_priv(ndev);\n\n\t*bec = priv->bec;\n\treturn 0;\n}\n\nstatic int peak_canfd_open(struct net_device *ndev)\n{\n\tstruct peak_canfd_priv *priv = netdev_priv(ndev);\n\tint i, err = 0;\n\n\terr = open_candev(ndev);\n\tif (err) {\n\t\tnetdev_err(ndev, \"open_candev() failed, error %d\\n\", err);\n\t\tgoto err_exit;\n\t}\n\n\terr = pucan_set_reset_mode(priv);\n\tif (err)\n\t\tgoto err_close;\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_FD) {\n\t\tif (priv->can.ctrlmode & CAN_CTRLMODE_FD_NON_ISO)\n\t\t\terr = pucan_clr_options(priv, PUCAN_OPTION_CANDFDISO);\n\t\telse\n\t\t\terr = pucan_set_options(priv, PUCAN_OPTION_CANDFDISO);\n\n\t\tif (err)\n\t\t\tgoto err_close;\n\t}\n\n\t \n\terr = pucan_set_options(priv, PUCAN_OPTION_ERROR);\n\tif (err)\n\t\tgoto err_close;\n\n\t \n\tfor (i = 0; i <= PUCAN_FLTSTD_ROW_IDX_MAX; i++)\n\t\tpucan_set_std_filter(priv, i, 0xffffffff);\n\n\terr = peak_canfd_start(priv);\n\tif (err)\n\t\tgoto err_close;\n\n\t \n\terr = pucan_setup_rx_barrier(priv);\n\tif (!err)\n\t\tgoto err_exit;\n\nerr_close:\n\tclose_candev(ndev);\nerr_exit:\n\treturn err;\n}\n\nstatic int peak_canfd_set_bittiming(struct net_device *ndev)\n{\n\tstruct peak_canfd_priv *priv = netdev_priv(ndev);\n\n\treturn pucan_set_timing_slow(priv, &priv->can.bittiming);\n}\n\nstatic int peak_canfd_set_data_bittiming(struct net_device *ndev)\n{\n\tstruct peak_canfd_priv *priv = netdev_priv(ndev);\n\n\treturn pucan_set_timing_fast(priv, &priv->can.data_bittiming);\n}\n\nstatic int peak_canfd_close(struct net_device *ndev)\n{\n\tstruct peak_canfd_priv *priv = netdev_priv(ndev);\n\n\tnetif_stop_queue(ndev);\n\tpeak_canfd_stop(priv);\n\tclose_candev(ndev);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t peak_canfd_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *ndev)\n{\n\tstruct peak_canfd_priv *priv = netdev_priv(ndev);\n\tstruct net_device_stats *stats = &ndev->stats;\n\tstruct canfd_frame *cf = (struct canfd_frame *)skb->data;\n\tstruct pucan_tx_msg *msg;\n\tu16 msg_size, msg_flags;\n\tunsigned long flags;\n\tbool should_stop_tx_queue;\n\tint room_left;\n\tu8 len;\n\n\tif (can_dev_dropped_skb(ndev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tmsg_size = ALIGN(sizeof(*msg) + cf->len, 4);\n\tmsg = priv->alloc_tx_msg(priv, msg_size, &room_left);\n\n\t \n\tif (!msg) {\n\t\tstats->tx_dropped++;\n\t\tnetif_stop_queue(ndev);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tmsg->size = cpu_to_le16(msg_size);\n\tmsg->type = cpu_to_le16(PUCAN_MSG_CAN_TX);\n\tmsg_flags = 0;\n\n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\tmsg_flags |= PUCAN_MSG_EXT_ID;\n\t\tmsg->can_id = cpu_to_le32(cf->can_id & CAN_EFF_MASK);\n\t} else {\n\t\tmsg->can_id = cpu_to_le32(cf->can_id & CAN_SFF_MASK);\n\t}\n\n\tif (can_is_canfd_skb(skb)) {\n\t\t \n\t\tlen = can_fd_len2dlc(cf->len);\n\n\t\tmsg_flags |= PUCAN_MSG_EXT_DATA_LEN;\n\n\t\tif (cf->flags & CANFD_BRS)\n\t\t\tmsg_flags |= PUCAN_MSG_BITRATE_SWITCH;\n\n\t\tif (cf->flags & CANFD_ESI)\n\t\t\tmsg_flags |= PUCAN_MSG_ERROR_STATE_IND;\n\t} else {\n\t\t \n\t\tlen = cf->len;\n\n\t\tif (cf->can_id & CAN_RTR_FLAG)\n\t\t\tmsg_flags |= PUCAN_MSG_RTR;\n\t}\n\n\t \n\tmsg_flags |= PUCAN_MSG_LOOPED_BACK;\n\n\t \n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\tmsg_flags |= PUCAN_MSG_SELF_RECEIVE;\n\n\tmsg->flags = cpu_to_le16(msg_flags);\n\tmsg->channel_dlc = PUCAN_MSG_CHANNEL_DLC(priv->index, len);\n\tmemcpy(msg->d, cf->data, cf->len);\n\n\t \n\tmsg->client = priv->echo_idx;\n\n\tspin_lock_irqsave(&priv->echo_lock, flags);\n\n\t \n\tcan_put_echo_skb(skb, ndev, priv->echo_idx, 0);\n\n\t \n\tpriv->echo_idx = (priv->echo_idx + 1) % priv->can.echo_skb_max;\n\n\t \n\tshould_stop_tx_queue = !!(priv->can.echo_skb[priv->echo_idx]);\n\n\t \n\tif (priv->can.ctrlmode & CAN_CTRLMODE_FD)\n\t\tshould_stop_tx_queue |= (room_left <\n\t\t\t\t\t(sizeof(*msg) + CANFD_MAX_DLEN));\n\telse\n\t\tshould_stop_tx_queue |= (room_left <\n\t\t\t\t\t(sizeof(*msg) + CAN_MAX_DLEN));\n\n\tif (should_stop_tx_queue)\n\t\tnetif_stop_queue(ndev);\n\n\tspin_unlock_irqrestore(&priv->echo_lock, flags);\n\n\t \n\tpriv->write_tx_msg(priv, msg);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int peak_eth_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\n{\n\tstruct hwtstamp_config hwts_cfg = { 0 };\n\n\tswitch (cmd) {\n\tcase SIOCSHWTSTAMP:  \n\t\tif (copy_from_user(&hwts_cfg, ifr->ifr_data, sizeof(hwts_cfg)))\n\t\t\treturn -EFAULT;\n\t\tif (hwts_cfg.tx_type == HWTSTAMP_TX_OFF &&\n\t\t    hwts_cfg.rx_filter == HWTSTAMP_FILTER_ALL)\n\t\t\treturn 0;\n\t\treturn -ERANGE;\n\n\tcase SIOCGHWTSTAMP:  \n\t\thwts_cfg.tx_type = HWTSTAMP_TX_OFF;\n\t\thwts_cfg.rx_filter = HWTSTAMP_FILTER_ALL;\n\t\tif (copy_to_user(ifr->ifr_data, &hwts_cfg, sizeof(hwts_cfg)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct net_device_ops peak_canfd_netdev_ops = {\n\t.ndo_open = peak_canfd_open,\n\t.ndo_stop = peak_canfd_close,\n\t.ndo_eth_ioctl = peak_eth_ioctl,\n\t.ndo_start_xmit = peak_canfd_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic int peak_get_ts_info(struct net_device *dev,\n\t\t\t    struct ethtool_ts_info *info)\n{\n\tinfo->so_timestamping =\n\t\tSOF_TIMESTAMPING_TX_SOFTWARE |\n\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\tSOF_TIMESTAMPING_SOFTWARE |\n\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\tinfo->phc_index = -1;\n\tinfo->tx_types = BIT(HWTSTAMP_TX_OFF);\n\tinfo->rx_filters = BIT(HWTSTAMP_FILTER_ALL);\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops peak_canfd_ethtool_ops = {\n\t.get_ts_info = peak_get_ts_info,\n};\n\nstruct net_device *alloc_peak_canfd_dev(int sizeof_priv, int index,\n\t\t\t\t\tint echo_skb_max)\n{\n\tstruct net_device *ndev;\n\tstruct peak_canfd_priv *priv;\n\n\t \n\tif (echo_skb_max < 0)\n\t\techo_skb_max = PCANFD_ECHO_SKB_MAX;\n\n\t \n\tndev = alloc_candev(sizeof_priv, echo_skb_max);\n\tif (!ndev)\n\t\treturn NULL;\n\n\tpriv = netdev_priv(ndev);\n\n\t \n\tpriv->can.state = CAN_STATE_STOPPED;\n\tpriv->can.bittiming_const = &peak_canfd_nominal_const;\n\tpriv->can.data_bittiming_const = &peak_canfd_data_const;\n\n\tpriv->can.do_set_mode = peak_canfd_set_mode;\n\tpriv->can.do_get_berr_counter = peak_canfd_get_berr_counter;\n\tpriv->can.do_set_bittiming = peak_canfd_set_bittiming;\n\tpriv->can.do_set_data_bittiming = peak_canfd_set_data_bittiming;\n\tpriv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |\n\t\t\t\t       CAN_CTRLMODE_LISTENONLY |\n\t\t\t\t       CAN_CTRLMODE_3_SAMPLES |\n\t\t\t\t       CAN_CTRLMODE_FD |\n\t\t\t\t       CAN_CTRLMODE_FD_NON_ISO |\n\t\t\t\t       CAN_CTRLMODE_BERR_REPORTING;\n\n\tpriv->ndev = ndev;\n\tpriv->index = index;\n\tpriv->cmd_len = 0;\n\tspin_lock_init(&priv->echo_lock);\n\n\tndev->flags |= IFF_ECHO;\n\tndev->netdev_ops = &peak_canfd_netdev_ops;\n\tndev->ethtool_ops = &peak_canfd_ethtool_ops;\n\tndev->dev_id = index;\n\n\treturn ndev;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}