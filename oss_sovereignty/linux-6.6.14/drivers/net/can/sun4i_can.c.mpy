{
  "module_name": "sun4i_can.c",
  "hash_id": "11d2e32dc3c1d6e4fc9ae4567126da1476381f48218b6f83dc472d95fbe3ab50",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/sun4i_can.c",
  "human_readable_source": " \n\n#include <linux/netdevice.h>\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/ethtool.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n#define DRV_NAME \"sun4i_can\"\n\n \n#define SUN4I_REG_MSEL_ADDR\t0x0000\t \n#define SUN4I_REG_CMD_ADDR\t0x0004\t \n#define SUN4I_REG_STA_ADDR\t0x0008\t \n#define SUN4I_REG_INT_ADDR\t0x000c\t \n#define SUN4I_REG_INTEN_ADDR\t0x0010\t \n#define SUN4I_REG_BTIME_ADDR\t0x0014\t \n#define SUN4I_REG_TEWL_ADDR\t0x0018\t \n#define SUN4I_REG_ERRC_ADDR\t0x001c\t \n#define SUN4I_REG_RMCNT_ADDR\t0x0020\t \n#define SUN4I_REG_RBUFSA_ADDR\t0x0024\t \n#define SUN4I_REG_BUF0_ADDR\t0x0040\t \n#define SUN4I_REG_BUF1_ADDR\t0x0044\t \n#define SUN4I_REG_BUF2_ADDR\t0x0048\t \n#define SUN4I_REG_BUF3_ADDR\t0x004c\t \n#define SUN4I_REG_BUF4_ADDR\t0x0050\t \n#define SUN4I_REG_BUF5_ADDR\t0x0054\t \n#define SUN4I_REG_BUF6_ADDR\t0x0058\t \n#define SUN4I_REG_BUF7_ADDR\t0x005c\t \n#define SUN4I_REG_BUF8_ADDR\t0x0060\t \n#define SUN4I_REG_BUF9_ADDR\t0x0064\t \n#define SUN4I_REG_BUF10_ADDR\t0x0068\t \n#define SUN4I_REG_BUF11_ADDR\t0x006c\t \n#define SUN4I_REG_BUF12_ADDR\t0x0070\t \n#define SUN4I_REG_ACPC_ADDR\t0x0040\t \n#define SUN4I_REG_ACPM_ADDR\t0x0044\t \n#define SUN4I_REG_ACPC_ADDR_D1\t0x0028\t \n#define SUN4I_REG_ACPM_ADDR_D1\t0x002C\t \n#define SUN4I_REG_RBUF_RBACK_START_ADDR\t0x0180\t \n#define SUN4I_REG_RBUF_RBACK_END_ADDR\t0x01b0\t \n\n \n\n \n#define SUN4I_MSEL_SLEEP_MODE\t\t(0x01 << 4)  \n#define SUN4I_MSEL_WAKE_UP\t\t(0x00 << 4)\n#define SUN4I_MSEL_SINGLE_FILTER\t(0x01 << 3)  \n#define SUN4I_MSEL_DUAL_FILTERS\t\t(0x00 << 3)\n#define SUN4I_MSEL_LOOPBACK_MODE\tBIT(2)\n#define SUN4I_MSEL_LISTEN_ONLY_MODE\tBIT(1)\n#define SUN4I_MSEL_RESET_MODE\t\tBIT(0)\n\n \n#define SUN4I_CMD_BUS_OFF_REQ\tBIT(5)\n#define SUN4I_CMD_SELF_RCV_REQ\tBIT(4)\n#define SUN4I_CMD_CLEAR_OR_FLAG\tBIT(3)\n#define SUN4I_CMD_RELEASE_RBUF\tBIT(2)\n#define SUN4I_CMD_ABORT_REQ\tBIT(1)\n#define SUN4I_CMD_TRANS_REQ\tBIT(0)\n\n \n#define SUN4I_STA_BIT_ERR\t(0x00 << 22)\n#define SUN4I_STA_FORM_ERR\t(0x01 << 22)\n#define SUN4I_STA_STUFF_ERR\t(0x02 << 22)\n#define SUN4I_STA_OTHER_ERR\t(0x03 << 22)\n#define SUN4I_STA_MASK_ERR\t(0x03 << 22)\n#define SUN4I_STA_ERR_DIR\tBIT(21)\n#define SUN4I_STA_ERR_SEG_CODE\t(0x1f << 16)\n#define SUN4I_STA_START\t\t(0x03 << 16)\n#define SUN4I_STA_ID28_21\t(0x02 << 16)\n#define SUN4I_STA_ID20_18\t(0x06 << 16)\n#define SUN4I_STA_SRTR\t\t(0x04 << 16)\n#define SUN4I_STA_IDE\t\t(0x05 << 16)\n#define SUN4I_STA_ID17_13\t(0x07 << 16)\n#define SUN4I_STA_ID12_5\t(0x0f << 16)\n#define SUN4I_STA_ID4_0\t\t(0x0e << 16)\n#define SUN4I_STA_RTR\t\t(0x0c << 16)\n#define SUN4I_STA_RB1\t\t(0x0d << 16)\n#define SUN4I_STA_RB0\t\t(0x09 << 16)\n#define SUN4I_STA_DLEN\t\t(0x0b << 16)\n#define SUN4I_STA_DATA_FIELD\t(0x0a << 16)\n#define SUN4I_STA_CRC_SEQUENCE\t(0x08 << 16)\n#define SUN4I_STA_CRC_DELIMITER\t(0x18 << 16)\n#define SUN4I_STA_ACK\t\t(0x19 << 16)\n#define SUN4I_STA_ACK_DELIMITER\t(0x1b << 16)\n#define SUN4I_STA_END\t\t(0x1a << 16)\n#define SUN4I_STA_INTERMISSION\t(0x12 << 16)\n#define SUN4I_STA_ACTIVE_ERROR\t(0x11 << 16)\n#define SUN4I_STA_PASSIVE_ERROR\t(0x16 << 16)\n#define SUN4I_STA_TOLERATE_DOMINANT_BITS\t(0x13 << 16)\n#define SUN4I_STA_ERROR_DELIMITER\t(0x17 << 16)\n#define SUN4I_STA_OVERLOAD\t(0x1c << 16)\n#define SUN4I_STA_BUS_OFF\tBIT(7)\n#define SUN4I_STA_ERR_STA\tBIT(6)\n#define SUN4I_STA_TRANS_BUSY\tBIT(5)\n#define SUN4I_STA_RCV_BUSY\tBIT(4)\n#define SUN4I_STA_TRANS_OVER\tBIT(3)\n#define SUN4I_STA_TBUF_RDY\tBIT(2)\n#define SUN4I_STA_DATA_ORUN\tBIT(1)\n#define SUN4I_STA_RBUF_RDY\tBIT(0)\n\n \n#define SUN4I_INT_BUS_ERR\tBIT(7)\n#define SUN4I_INT_ARB_LOST\tBIT(6)\n#define SUN4I_INT_ERR_PASSIVE\tBIT(5)\n#define SUN4I_INT_WAKEUP\tBIT(4)\n#define SUN4I_INT_DATA_OR\tBIT(3)\n#define SUN4I_INT_ERR_WRN\tBIT(2)\n#define SUN4I_INT_TBUF_VLD\tBIT(1)\n#define SUN4I_INT_RBUF_VLD\tBIT(0)\n\n \n#define SUN4I_INTEN_BERR\tBIT(7)\n#define SUN4I_INTEN_ARB_LOST\tBIT(6)\n#define SUN4I_INTEN_ERR_PASSIVE\tBIT(5)\n#define SUN4I_INTEN_WAKEUP\tBIT(4)\n#define SUN4I_INTEN_OR\t\tBIT(3)\n#define SUN4I_INTEN_ERR_WRN\tBIT(2)\n#define SUN4I_INTEN_TX\t\tBIT(1)\n#define SUN4I_INTEN_RX\t\tBIT(0)\n\n \n#define SUN4I_ERR_INRCV\t\t(0x1 << 5)\n#define SUN4I_ERR_INTRANS\t(0x0 << 5)\n\n \n#define SUN4I_FILTER_CLOSE\t0\n#define SUN4I_SINGLE_FLTER_MODE\t1\n#define SUN4I_DUAL_FILTER_MODE\t2\n\n \n#define SUN4I_MSG_EFF_FLAG\tBIT(7)\n#define SUN4I_MSG_RTR_FLAG\tBIT(6)\n\n \n#define SUN4I_CAN_MAX_IRQ\t20\n#define SUN4I_MODE_MAX_RETRIES\t100\n\n \nstruct sun4ican_quirks {\n\tbool has_reset;\n\tint acp_offset;\n};\n\nstruct sun4ican_priv {\n\tstruct can_priv can;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tstruct reset_control *reset;\n\tspinlock_t cmdreg_lock;\t \n\tint acp_offset;\n};\n\nstatic const struct can_bittiming_const sun4ican_bittiming_const = {\n\t.name = DRV_NAME,\n\t.tseg1_min = 1,\n\t.tseg1_max = 16,\n\t.tseg2_min = 1,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 64,\n\t.brp_inc = 1,\n};\n\nstatic void sun4i_can_write_cmdreg(struct sun4ican_priv *priv, u8 val)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->cmdreg_lock, flags);\n\twritel(val, priv->base + SUN4I_REG_CMD_ADDR);\n\tspin_unlock_irqrestore(&priv->cmdreg_lock, flags);\n}\n\nstatic int set_normal_mode(struct net_device *dev)\n{\n\tstruct sun4ican_priv *priv = netdev_priv(dev);\n\tint retry = SUN4I_MODE_MAX_RETRIES;\n\tu32 mod_reg_val = 0;\n\n\tdo {\n\t\tmod_reg_val = readl(priv->base + SUN4I_REG_MSEL_ADDR);\n\t\tmod_reg_val &= ~SUN4I_MSEL_RESET_MODE;\n\t\twritel(mod_reg_val, priv->base + SUN4I_REG_MSEL_ADDR);\n\t} while (retry-- && (mod_reg_val & SUN4I_MSEL_RESET_MODE));\n\n\tif (readl(priv->base + SUN4I_REG_MSEL_ADDR) & SUN4I_MSEL_RESET_MODE) {\n\t\tnetdev_err(dev,\n\t\t\t   \"setting controller into normal mode failed!\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int set_reset_mode(struct net_device *dev)\n{\n\tstruct sun4ican_priv *priv = netdev_priv(dev);\n\tint retry = SUN4I_MODE_MAX_RETRIES;\n\tu32 mod_reg_val = 0;\n\n\tdo {\n\t\tmod_reg_val = readl(priv->base + SUN4I_REG_MSEL_ADDR);\n\t\tmod_reg_val |= SUN4I_MSEL_RESET_MODE;\n\t\twritel(mod_reg_val, priv->base + SUN4I_REG_MSEL_ADDR);\n\t} while (retry-- && !(mod_reg_val & SUN4I_MSEL_RESET_MODE));\n\n\tif (!(readl(priv->base + SUN4I_REG_MSEL_ADDR) &\n\t      SUN4I_MSEL_RESET_MODE)) {\n\t\tnetdev_err(dev, \"setting controller into reset mode failed!\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sun4ican_set_bittiming(struct net_device *dev)\n{\n\tstruct sun4ican_priv *priv = netdev_priv(dev);\n\tstruct can_bittiming *bt = &priv->can.bittiming;\n\tu32 cfg;\n\n\tcfg = ((bt->brp - 1) & 0x3FF) |\n\t     (((bt->sjw - 1) & 0x3) << 14) |\n\t     (((bt->prop_seg + bt->phase_seg1 - 1) & 0xf) << 16) |\n\t     (((bt->phase_seg2 - 1) & 0x7) << 20);\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\tcfg |= 0x800000;\n\n\tnetdev_dbg(dev, \"setting BITTIMING=0x%08x\\n\", cfg);\n\twritel(cfg, priv->base + SUN4I_REG_BTIME_ADDR);\n\n\treturn 0;\n}\n\nstatic int sun4ican_get_berr_counter(const struct net_device *dev,\n\t\t\t\t     struct can_berr_counter *bec)\n{\n\tstruct sun4ican_priv *priv = netdev_priv(dev);\n\tu32 errors;\n\tint err;\n\n\terr = clk_prepare_enable(priv->clk);\n\tif (err) {\n\t\tnetdev_err(dev, \"could not enable clock\\n\");\n\t\treturn err;\n\t}\n\n\terrors = readl(priv->base + SUN4I_REG_ERRC_ADDR);\n\n\tbec->txerr = errors & 0xFF;\n\tbec->rxerr = (errors >> 16) & 0xFF;\n\n\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n}\n\nstatic int sun4i_can_start(struct net_device *dev)\n{\n\tstruct sun4ican_priv *priv = netdev_priv(dev);\n\tint err;\n\tu32 mod_reg_val;\n\n\t \n\terr = set_reset_mode(dev);\n\tif (err) {\n\t\tnetdev_err(dev, \"could not enter reset mode\\n\");\n\t\treturn err;\n\t}\n\n\t \n\twritel(0x00000000, priv->base + SUN4I_REG_ACPC_ADDR + priv->acp_offset);\n\twritel(0xFFFFFFFF, priv->base + SUN4I_REG_ACPM_ADDR + priv->acp_offset);\n\n\t \n\twritel(0, priv->base + SUN4I_REG_ERRC_ADDR);\n\n\t \n\tif (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING)\n\t\twritel(0xFF, priv->base + SUN4I_REG_INTEN_ADDR);\n\telse\n\t\twritel(0xFF & ~SUN4I_INTEN_BERR,\n\t\t       priv->base + SUN4I_REG_INTEN_ADDR);\n\n\t \n\tmod_reg_val = readl(priv->base + SUN4I_REG_MSEL_ADDR);\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\tmod_reg_val |= SUN4I_MSEL_LOOPBACK_MODE;\n\telse if (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tmod_reg_val |= SUN4I_MSEL_LISTEN_ONLY_MODE;\n\twritel(mod_reg_val, priv->base + SUN4I_REG_MSEL_ADDR);\n\n\terr = sun4ican_set_bittiming(dev);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = set_normal_mode(dev);\n\tif (err) {\n\t\tnetdev_err(dev, \"could not enter normal mode\\n\");\n\t\treturn err;\n\t}\n\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\treturn 0;\n}\n\nstatic int sun4i_can_stop(struct net_device *dev)\n{\n\tstruct sun4ican_priv *priv = netdev_priv(dev);\n\tint err;\n\n\tpriv->can.state = CAN_STATE_STOPPED;\n\t \n\terr = set_reset_mode(dev);\n\tif (err) {\n\t\tnetdev_err(dev, \"could not enter reset mode\\n\");\n\t\treturn err;\n\t}\n\n\t \n\twritel(0, priv->base + SUN4I_REG_INTEN_ADDR);\n\n\treturn 0;\n}\n\nstatic int sun4ican_set_mode(struct net_device *dev, enum can_mode mode)\n{\n\tint err;\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\terr = sun4i_can_start(dev);\n\t\tif (err) {\n\t\t\tnetdev_err(dev, \"starting CAN controller failed!\\n\");\n\t\t\treturn err;\n\t\t}\n\t\tif (netif_queue_stopped(dev))\n\t\t\tnetif_wake_queue(dev);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n \nstatic netdev_tx_t sun4ican_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct sun4ican_priv *priv = netdev_priv(dev);\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tu8 dlc;\n\tu32 dreg, msg_flag_n;\n\tcanid_t id;\n\tint i;\n\n\tif (can_dev_dropped_skb(dev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tnetif_stop_queue(dev);\n\n\tid = cf->can_id;\n\tdlc = cf->len;\n\tmsg_flag_n = dlc;\n\n\tif (id & CAN_RTR_FLAG)\n\t\tmsg_flag_n |= SUN4I_MSG_RTR_FLAG;\n\n\tif (id & CAN_EFF_FLAG) {\n\t\tmsg_flag_n |= SUN4I_MSG_EFF_FLAG;\n\t\tdreg = SUN4I_REG_BUF5_ADDR;\n\t\twritel((id >> 21) & 0xFF, priv->base + SUN4I_REG_BUF1_ADDR);\n\t\twritel((id >> 13) & 0xFF, priv->base + SUN4I_REG_BUF2_ADDR);\n\t\twritel((id >> 5)  & 0xFF, priv->base + SUN4I_REG_BUF3_ADDR);\n\t\twritel((id << 3)  & 0xF8, priv->base + SUN4I_REG_BUF4_ADDR);\n\t} else {\n\t\tdreg = SUN4I_REG_BUF3_ADDR;\n\t\twritel((id >> 3) & 0xFF, priv->base + SUN4I_REG_BUF1_ADDR);\n\t\twritel((id << 5) & 0xE0, priv->base + SUN4I_REG_BUF2_ADDR);\n\t}\n\n\tfor (i = 0; i < dlc; i++)\n\t\twritel(cf->data[i], priv->base + (dreg + i * 4));\n\n\twritel(msg_flag_n, priv->base + SUN4I_REG_BUF0_ADDR);\n\n\tcan_put_echo_skb(skb, dev, 0, 0);\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\tsun4i_can_write_cmdreg(priv, SUN4I_CMD_SELF_RCV_REQ);\n\telse\n\t\tsun4i_can_write_cmdreg(priv, SUN4I_CMD_TRANS_REQ);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void sun4i_can_rx(struct net_device *dev)\n{\n\tstruct sun4ican_priv *priv = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tu8 fi;\n\tu32 dreg;\n\tcanid_t id;\n\tint i;\n\n\t \n\tskb = alloc_can_skb(dev, &cf);\n\tif (!skb)\n\t\treturn;\n\n\tfi = readl(priv->base + SUN4I_REG_BUF0_ADDR);\n\tcf->len = can_cc_dlc2len(fi & 0x0F);\n\tif (fi & SUN4I_MSG_EFF_FLAG) {\n\t\tdreg = SUN4I_REG_BUF5_ADDR;\n\t\tid = (readl(priv->base + SUN4I_REG_BUF1_ADDR) << 21) |\n\t\t     (readl(priv->base + SUN4I_REG_BUF2_ADDR) << 13) |\n\t\t     (readl(priv->base + SUN4I_REG_BUF3_ADDR) << 5)  |\n\t\t    ((readl(priv->base + SUN4I_REG_BUF4_ADDR) >> 3)  & 0x1f);\n\t\tid |= CAN_EFF_FLAG;\n\t} else {\n\t\tdreg = SUN4I_REG_BUF3_ADDR;\n\t\tid = (readl(priv->base + SUN4I_REG_BUF1_ADDR) << 3) |\n\t\t    ((readl(priv->base + SUN4I_REG_BUF2_ADDR) >> 5) & 0x7);\n\t}\n\n\t \n\tif (fi & SUN4I_MSG_RTR_FLAG) {\n\t\tid |= CAN_RTR_FLAG;\n\t} else {\n\t\tfor (i = 0; i < cf->len; i++)\n\t\t\tcf->data[i] = readl(priv->base + dreg + i * 4);\n\n\t\tstats->rx_bytes += cf->len;\n\t}\n\tstats->rx_packets++;\n\n\tcf->can_id = id;\n\n\tsun4i_can_write_cmdreg(priv, SUN4I_CMD_RELEASE_RBUF);\n\n\tnetif_rx(skb);\n}\n\nstatic int sun4i_can_err(struct net_device *dev, u8 isrc, u8 status)\n{\n\tstruct sun4ican_priv *priv = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tenum can_state state = priv->can.state;\n\tenum can_state rx_state, tx_state;\n\tunsigned int rxerr, txerr, errc;\n\tu32 ecc, alc;\n\n\t \n\tskb = alloc_can_err_skb(dev, &cf);\n\n\terrc = readl(priv->base + SUN4I_REG_ERRC_ADDR);\n\trxerr = (errc >> 16) & 0xFF;\n\ttxerr = errc & 0xFF;\n\n\tif (isrc & SUN4I_INT_DATA_OR) {\n\t\t \n\t\tnetdev_dbg(dev, \"data overrun interrupt\\n\");\n\t\tif (likely(skb)) {\n\t\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\t\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\t\t}\n\t\tstats->rx_over_errors++;\n\t\tstats->rx_errors++;\n\n\t\t \n\t\tset_reset_mode(dev);\n\t\tset_normal_mode(dev);\n\n\t\t \n\t\tsun4i_can_write_cmdreg(priv, SUN4I_CMD_CLEAR_OR_FLAG);\n\t}\n\tif (isrc & SUN4I_INT_ERR_WRN) {\n\t\t \n\t\tnetdev_dbg(dev, \"error warning interrupt\\n\");\n\n\t\tif (status & SUN4I_STA_BUS_OFF)\n\t\t\tstate = CAN_STATE_BUS_OFF;\n\t\telse if (status & SUN4I_STA_ERR_STA)\n\t\t\tstate = CAN_STATE_ERROR_WARNING;\n\t\telse\n\t\t\tstate = CAN_STATE_ERROR_ACTIVE;\n\t}\n\tif (skb && state != CAN_STATE_BUS_OFF) {\n\t\tcf->can_id |= CAN_ERR_CNT;\n\t\tcf->data[6] = txerr;\n\t\tcf->data[7] = rxerr;\n\t}\n\tif (isrc & SUN4I_INT_BUS_ERR) {\n\t\t \n\t\tnetdev_dbg(dev, \"bus error interrupt\\n\");\n\t\tpriv->can.can_stats.bus_error++;\n\t\tstats->rx_errors++;\n\n\t\tif (likely(skb)) {\n\t\t\tecc = readl(priv->base + SUN4I_REG_STA_ADDR);\n\n\t\t\tcf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\n\n\t\t\tswitch (ecc & SUN4I_STA_MASK_ERR) {\n\t\t\tcase SUN4I_STA_BIT_ERR:\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT;\n\t\t\t\tbreak;\n\t\t\tcase SUN4I_STA_FORM_ERR:\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_FORM;\n\t\t\t\tbreak;\n\t\t\tcase SUN4I_STA_STUFF_ERR:\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_STUFF;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcf->data[3] = (ecc & SUN4I_STA_ERR_SEG_CODE)\n\t\t\t\t\t       >> 16;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tif ((ecc & SUN4I_STA_ERR_DIR) == 0)\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_TX;\n\t\t}\n\t}\n\tif (isrc & SUN4I_INT_ERR_PASSIVE) {\n\t\t \n\t\tnetdev_dbg(dev, \"error passive interrupt\\n\");\n\t\tif (state == CAN_STATE_ERROR_PASSIVE)\n\t\t\tstate = CAN_STATE_ERROR_WARNING;\n\t\telse\n\t\t\tstate = CAN_STATE_ERROR_PASSIVE;\n\t}\n\tif (isrc & SUN4I_INT_ARB_LOST) {\n\t\t \n\t\tnetdev_dbg(dev, \"arbitration lost interrupt\\n\");\n\t\talc = readl(priv->base + SUN4I_REG_STA_ADDR);\n\t\tpriv->can.can_stats.arbitration_lost++;\n\t\tif (likely(skb)) {\n\t\t\tcf->can_id |= CAN_ERR_LOSTARB;\n\t\t\tcf->data[0] = (alc >> 8) & 0x1f;\n\t\t}\n\t}\n\n\tif (state != priv->can.state) {\n\t\ttx_state = txerr >= rxerr ? state : 0;\n\t\trx_state = txerr <= rxerr ? state : 0;\n\n\t\tif (likely(skb))\n\t\t\tcan_change_state(dev, cf, tx_state, rx_state);\n\t\telse\n\t\t\tpriv->can.state = state;\n\t\tif (state == CAN_STATE_BUS_OFF)\n\t\t\tcan_bus_off(dev);\n\t}\n\n\tif (likely(skb))\n\t\tnetif_rx(skb);\n\telse\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic irqreturn_t sun4i_can_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = (struct net_device *)dev_id;\n\tstruct sun4ican_priv *priv = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tu8 isrc, status;\n\tint n = 0;\n\n\twhile ((isrc = readl(priv->base + SUN4I_REG_INT_ADDR)) &&\n\t       (n < SUN4I_CAN_MAX_IRQ)) {\n\t\tn++;\n\t\tstatus = readl(priv->base + SUN4I_REG_STA_ADDR);\n\n\t\tif (isrc & SUN4I_INT_WAKEUP)\n\t\t\tnetdev_warn(dev, \"wakeup interrupt\\n\");\n\n\t\tif (isrc & SUN4I_INT_TBUF_VLD) {\n\t\t\t \n\t\t\tstats->tx_bytes += can_get_echo_skb(dev, 0, NULL);\n\t\t\tstats->tx_packets++;\n\t\t\tnetif_wake_queue(dev);\n\t\t}\n\t\tif ((isrc & SUN4I_INT_RBUF_VLD) &&\n\t\t    !(isrc & SUN4I_INT_DATA_OR)) {\n\t\t\t \n\t\t\twhile (status & SUN4I_STA_RBUF_RDY) {\n\t\t\t\t \n\t\t\t\tsun4i_can_rx(dev);\n\t\t\t\tstatus = readl(priv->base + SUN4I_REG_STA_ADDR);\n\t\t\t}\n\t\t}\n\t\tif (isrc &\n\t\t    (SUN4I_INT_DATA_OR | SUN4I_INT_ERR_WRN | SUN4I_INT_BUS_ERR |\n\t\t     SUN4I_INT_ERR_PASSIVE | SUN4I_INT_ARB_LOST)) {\n\t\t\t \n\t\t\tif (sun4i_can_err(dev, isrc, status))\n\t\t\t\tnetdev_err(dev, \"can't allocate buffer - clearing pending interrupts\\n\");\n\t\t}\n\t\t \n\t\twritel(isrc, priv->base + SUN4I_REG_INT_ADDR);\n\t\treadl(priv->base + SUN4I_REG_INT_ADDR);\n\t}\n\tif (n >= SUN4I_CAN_MAX_IRQ)\n\t\tnetdev_dbg(dev, \"%d messages handled in ISR\", n);\n\n\treturn (n) ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic int sun4ican_open(struct net_device *dev)\n{\n\tstruct sun4ican_priv *priv = netdev_priv(dev);\n\tint err;\n\n\t \n\terr = open_candev(dev);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = request_irq(dev->irq, sun4i_can_interrupt, 0, dev->name, dev);\n\tif (err) {\n\t\tnetdev_err(dev, \"request_irq err: %d\\n\", err);\n\t\tgoto exit_irq;\n\t}\n\n\t \n\terr = reset_control_deassert(priv->reset);\n\tif (err) {\n\t\tnetdev_err(dev, \"could not deassert CAN reset\\n\");\n\t\tgoto exit_soft_reset;\n\t}\n\n\t \n\terr = clk_prepare_enable(priv->clk);\n\tif (err) {\n\t\tnetdev_err(dev, \"could not enable CAN peripheral clock\\n\");\n\t\tgoto exit_clock;\n\t}\n\n\terr = sun4i_can_start(dev);\n\tif (err) {\n\t\tnetdev_err(dev, \"could not start CAN peripheral\\n\");\n\t\tgoto exit_can_start;\n\t}\n\n\tnetif_start_queue(dev);\n\n\treturn 0;\n\nexit_can_start:\n\tclk_disable_unprepare(priv->clk);\nexit_clock:\n\treset_control_assert(priv->reset);\nexit_soft_reset:\n\tfree_irq(dev->irq, dev);\nexit_irq:\n\tclose_candev(dev);\n\treturn err;\n}\n\nstatic int sun4ican_close(struct net_device *dev)\n{\n\tstruct sun4ican_priv *priv = netdev_priv(dev);\n\n\tnetif_stop_queue(dev);\n\tsun4i_can_stop(dev);\n\tclk_disable_unprepare(priv->clk);\n\treset_control_assert(priv->reset);\n\n\tfree_irq(dev->irq, dev);\n\tclose_candev(dev);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops sun4ican_netdev_ops = {\n\t.ndo_open = sun4ican_open,\n\t.ndo_stop = sun4ican_close,\n\t.ndo_start_xmit = sun4ican_start_xmit,\n};\n\nstatic const struct ethtool_ops sun4ican_ethtool_ops = {\n\t.get_ts_info = ethtool_op_get_ts_info,\n};\n\nstatic const struct sun4ican_quirks sun4ican_quirks_a10 = {\n\t.has_reset = false,\n\t.acp_offset = 0,\n};\n\nstatic const struct sun4ican_quirks sun4ican_quirks_r40 = {\n\t.has_reset = true,\n\t.acp_offset = 0,\n};\n\nstatic const struct sun4ican_quirks sun4ican_quirks_d1 = {\n\t.has_reset = true,\n\t.acp_offset = (SUN4I_REG_ACPC_ADDR_D1 - SUN4I_REG_ACPC_ADDR),\n};\n\nstatic const struct of_device_id sun4ican_of_match[] = {\n\t{\n\t\t.compatible = \"allwinner,sun4i-a10-can\",\n\t\t.data = &sun4ican_quirks_a10\n\t}, {\n\t\t.compatible = \"allwinner,sun7i-a20-can\",\n\t\t.data = &sun4ican_quirks_a10\n\t}, {\n\t\t.compatible = \"allwinner,sun8i-r40-can\",\n\t\t.data = &sun4ican_quirks_r40\n\t}, {\n\t\t.compatible = \"allwinner,sun20i-d1-can\",\n\t\t.data = &sun4ican_quirks_d1\n\t}, {\n\t\t \n\t},\n};\n\nMODULE_DEVICE_TABLE(of, sun4ican_of_match);\n\nstatic void sun4ican_remove(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\n\tunregister_netdev(dev);\n\tfree_candev(dev);\n}\n\nstatic int sun4ican_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct clk *clk;\n\tstruct reset_control *reset = NULL;\n\tvoid __iomem *addr;\n\tint err, irq;\n\tstruct net_device *dev;\n\tstruct sun4ican_priv *priv;\n\tconst struct sun4ican_quirks *quirks;\n\n\tquirks = of_device_get_match_data(&pdev->dev);\n\tif (!quirks) {\n\t\tdev_err(&pdev->dev, \"failed to determine the quirks to use\\n\");\n\t\terr = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tif (quirks->has_reset) {\n\t\treset = devm_reset_control_get_exclusive(&pdev->dev, NULL);\n\t\tif (IS_ERR(reset)) {\n\t\t\tdev_err(&pdev->dev, \"unable to request reset\\n\");\n\t\t\terr = PTR_ERR(reset);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tclk = of_clk_get(np, 0);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(&pdev->dev, \"unable to request clock\\n\");\n\t\terr = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\terr = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\taddr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(addr)) {\n\t\terr = PTR_ERR(addr);\n\t\tgoto exit;\n\t}\n\n\tdev = alloc_candev(sizeof(struct sun4ican_priv), 1);\n\tif (!dev) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"could not allocate memory for CAN device\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tdev->netdev_ops = &sun4ican_netdev_ops;\n\tdev->ethtool_ops = &sun4ican_ethtool_ops;\n\tdev->irq = irq;\n\tdev->flags |= IFF_ECHO;\n\n\tpriv = netdev_priv(dev);\n\tpriv->can.clock.freq = clk_get_rate(clk);\n\tpriv->can.bittiming_const = &sun4ican_bittiming_const;\n\tpriv->can.do_set_mode = sun4ican_set_mode;\n\tpriv->can.do_get_berr_counter = sun4ican_get_berr_counter;\n\tpriv->can.ctrlmode_supported = CAN_CTRLMODE_BERR_REPORTING |\n\t\t\t\t       CAN_CTRLMODE_LISTENONLY |\n\t\t\t\t       CAN_CTRLMODE_LOOPBACK |\n\t\t\t\t       CAN_CTRLMODE_3_SAMPLES;\n\tpriv->base = addr;\n\tpriv->clk = clk;\n\tpriv->reset = reset;\n\tpriv->acp_offset = quirks->acp_offset;\n\tspin_lock_init(&priv->cmdreg_lock);\n\n\tplatform_set_drvdata(pdev, dev);\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\terr = register_candev(dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"registering %s failed (err=%d)\\n\",\n\t\t\tDRV_NAME, err);\n\t\tgoto exit_free;\n\t}\n\n\tdev_info(&pdev->dev, \"device registered (base=%p, irq=%d)\\n\",\n\t\t priv->base, dev->irq);\n\n\treturn 0;\n\nexit_free:\n\tfree_candev(dev);\nexit:\n\treturn err;\n}\n\nstatic struct platform_driver sun4i_can_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = sun4ican_of_match,\n\t},\n\t.probe = sun4ican_probe,\n\t.remove_new = sun4ican_remove,\n};\n\nmodule_platform_driver(sun4i_can_driver);\n\nMODULE_AUTHOR(\"Peter Chen <xingkongcp@gmail.com>\");\nMODULE_AUTHOR(\"Gerhard Bertelsmann <info@gerhard-bertelsmann.de>\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DESCRIPTION(\"CAN driver for Allwinner SoCs (A10/A20/D1)\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}