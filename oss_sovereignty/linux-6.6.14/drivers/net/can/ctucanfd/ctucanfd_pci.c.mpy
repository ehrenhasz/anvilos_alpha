{
  "module_name": "ctucanfd_pci.c",
  "hash_id": "445348c427f41bbe02d615c9aaa5d267f9cd9c7453328ecf8f8c0d63f9127e2d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/ctucanfd/ctucanfd_pci.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n\n#include \"ctucanfd.h\"\n\n#ifndef PCI_DEVICE_DATA\n#define PCI_DEVICE_DATA(vend, dev, data) \\\n.vendor = PCI_VENDOR_ID_##vend, \\\n.device = PCI_DEVICE_ID_##vend##_##dev, \\\n.subvendor = PCI_ANY_ID, .subdevice = PCI_ANY_ID, 0, 0, \\\n.driver_data = (kernel_ulong_t)(data)\n#endif\n\n#ifndef PCI_VENDOR_ID_TEDIA\n#define PCI_VENDOR_ID_TEDIA 0x1760\n#endif\n\n#ifndef PCI_DEVICE_ID_TEDIA_CTUCAN_VER21\n#define PCI_DEVICE_ID_TEDIA_CTUCAN_VER21 0xff00\n#endif\n\n#define CTUCAN_BAR0_CTUCAN_ID 0x0000\n#define CTUCAN_BAR0_CRA_BASE  0x4000\n#define CYCLONE_IV_CRA_A2P_IE (0x0050)\n\n#define CTUCAN_WITHOUT_CTUCAN_ID  0\n#define CTUCAN_WITH_CTUCAN_ID     1\n\nstruct ctucan_pci_board_data {\n\tvoid __iomem *bar0_base;\n\tvoid __iomem *cra_base;\n\tvoid __iomem *bar1_base;\n\tstruct list_head ndev_list_head;\n\tint use_msi;\n};\n\nstatic struct ctucan_pci_board_data *ctucan_pci_get_bdata(struct pci_dev *pdev)\n{\n\treturn (struct ctucan_pci_board_data *)pci_get_drvdata(pdev);\n}\n\nstatic void ctucan_pci_set_drvdata(struct device *dev,\n\t\t\t\t   struct net_device *ndev)\n{\n\tstruct pci_dev *pdev = container_of(dev, struct pci_dev, dev);\n\tstruct ctucan_priv *priv = netdev_priv(ndev);\n\tstruct ctucan_pci_board_data *bdata = ctucan_pci_get_bdata(pdev);\n\n\tlist_add(&priv->peers_on_pdev, &bdata->ndev_list_head);\n\tpriv->irq_flags = IRQF_SHARED;\n}\n\n \nstatic int ctucan_pci_probe(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *ent)\n{\n\tstruct device\t*dev = &pdev->dev;\n\tunsigned long driver_data = ent->driver_data;\n\tstruct ctucan_pci_board_data *bdata;\n\tvoid __iomem *addr;\n\tvoid __iomem *cra_addr;\n\tvoid __iomem *bar0_base;\n\tu32 cra_a2p_ie;\n\tu32 ctucan_id = 0;\n\tint ret;\n\tunsigned int ntxbufs;\n\tunsigned int num_cores = 1;\n\tunsigned int core_i = 0;\n\tint irq;\n\tint msi_ok = 0;\n\n\tret = pci_enable_device(pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"pci_enable_device FAILED\\n\");\n\t\tgoto err;\n\t}\n\n\tret = pci_request_regions(pdev, KBUILD_MODNAME);\n\tif (ret) {\n\t\tdev_err(dev, \"pci_request_regions FAILED\\n\");\n\t\tgoto err_disable_device;\n\t}\n\n\tret = pci_enable_msi(pdev);\n\tif (!ret) {\n\t\tdev_info(dev, \"MSI enabled\\n\");\n\t\tpci_set_master(pdev);\n\t\tmsi_ok = 1;\n\t}\n\n\tdev_info(dev, \"ctucan BAR0 0x%08llx 0x%08llx\\n\",\n\t\t (long long)pci_resource_start(pdev, 0),\n\t\t (long long)pci_resource_len(pdev, 0));\n\n\tdev_info(dev, \"ctucan BAR1 0x%08llx 0x%08llx\\n\",\n\t\t (long long)pci_resource_start(pdev, 1),\n\t\t (long long)pci_resource_len(pdev, 1));\n\n\taddr = pci_iomap(pdev, 1, pci_resource_len(pdev, 1));\n\tif (!addr) {\n\t\tdev_err(dev, \"PCI BAR 1 cannot be mapped\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_release_regions;\n\t}\n\n\t \n\tbar0_base = pci_iomap(pdev, 0, pci_resource_len(pdev, 0));\n\tif (!bar0_base) {\n\t\tdev_err(dev, \"PCI BAR 0 cannot be mapped\\n\");\n\t\tret = -EIO;\n\t\tgoto err_pci_iounmap_bar1;\n\t}\n\n\tif (driver_data == CTUCAN_WITHOUT_CTUCAN_ID) {\n\t\tcra_addr = bar0_base;\n\t\tnum_cores = 2;\n\t} else {\n\t\tcra_addr = bar0_base + CTUCAN_BAR0_CRA_BASE;\n\t\tctucan_id = ioread32(bar0_base + CTUCAN_BAR0_CTUCAN_ID);\n\t\tdev_info(dev, \"ctucan_id 0x%08lx\\n\", (unsigned long)ctucan_id);\n\t\tnum_cores = ctucan_id & 0xf;\n\t}\n\n\tirq = pdev->irq;\n\n\tntxbufs = 4;\n\n\tbdata = kzalloc(sizeof(*bdata), GFP_KERNEL);\n\tif (!bdata) {\n\t\tret = -ENOMEM;\n\t\tgoto err_pci_iounmap_bar0;\n\t}\n\n\tINIT_LIST_HEAD(&bdata->ndev_list_head);\n\tbdata->bar0_base = bar0_base;\n\tbdata->cra_base = cra_addr;\n\tbdata->bar1_base = addr;\n\tbdata->use_msi = msi_ok;\n\n\tpci_set_drvdata(pdev, bdata);\n\n\tret = ctucan_probe_common(dev, addr, irq, ntxbufs, 100000000,\n\t\t\t\t  0, ctucan_pci_set_drvdata);\n\tif (ret < 0)\n\t\tgoto err_free_board;\n\n\tcore_i++;\n\n\twhile (core_i < num_cores) {\n\t\taddr += 0x4000;\n\t\tret = ctucan_probe_common(dev, addr, irq, ntxbufs, 100000000,\n\t\t\t\t\t  0, ctucan_pci_set_drvdata);\n\t\tif (ret < 0) {\n\t\t\tdev_info(dev, \"CTU CAN FD core %d initialization failed\\n\",\n\t\t\t\t core_i);\n\t\t\tbreak;\n\t\t}\n\t\tcore_i++;\n\t}\n\n\t \n\tcra_a2p_ie = ioread32(cra_addr + CYCLONE_IV_CRA_A2P_IE);\n\tdev_info(dev, \"cra_a2p_ie 0x%08x\\n\", cra_a2p_ie);\n\tcra_a2p_ie |= 1;\n\tiowrite32(cra_a2p_ie, cra_addr + CYCLONE_IV_CRA_A2P_IE);\n\tcra_a2p_ie = ioread32(cra_addr + CYCLONE_IV_CRA_A2P_IE);\n\tdev_info(dev, \"cra_a2p_ie 0x%08x\\n\", cra_a2p_ie);\n\n\treturn 0;\n\nerr_free_board:\n\tpci_set_drvdata(pdev, NULL);\n\tkfree(bdata);\nerr_pci_iounmap_bar0:\n\tpci_iounmap(pdev, cra_addr);\nerr_pci_iounmap_bar1:\n\tpci_iounmap(pdev, addr);\nerr_release_regions:\n\tif (msi_ok)\n\t\tpci_disable_msi(pdev);\n\tpci_release_regions(pdev);\nerr_disable_device:\n\tpci_disable_device(pdev);\nerr:\n\treturn ret;\n}\n\n \nstatic void ctucan_pci_remove(struct pci_dev *pdev)\n{\n\tstruct net_device *ndev;\n\tstruct ctucan_priv *priv = NULL;\n\tstruct ctucan_pci_board_data *bdata = ctucan_pci_get_bdata(pdev);\n\n\tdev_dbg(&pdev->dev, \"ctucan_remove\");\n\n\tif (!bdata) {\n\t\tdev_err(&pdev->dev, \"%s: no list of devices\\n\", __func__);\n\t\treturn;\n\t}\n\n\t \n\tif (bdata->cra_base)\n\t\tiowrite32(0, bdata->cra_base + CYCLONE_IV_CRA_A2P_IE);\n\n\twhile ((priv = list_first_entry_or_null(&bdata->ndev_list_head, struct ctucan_priv,\n\t\t\t\t\t\tpeers_on_pdev)) != NULL) {\n\t\tndev = priv->can.dev;\n\n\t\tunregister_candev(ndev);\n\n\t\tnetif_napi_del(&priv->napi);\n\n\t\tlist_del_init(&priv->peers_on_pdev);\n\t\tfree_candev(ndev);\n\t}\n\n\tpci_iounmap(pdev, bdata->bar1_base);\n\n\tif (bdata->use_msi)\n\t\tpci_disable_msi(pdev);\n\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\n\tpci_iounmap(pdev, bdata->bar0_base);\n\n\tpci_set_drvdata(pdev, NULL);\n\tkfree(bdata);\n}\n\nstatic SIMPLE_DEV_PM_OPS(ctucan_pci_pm_ops, ctucan_suspend, ctucan_resume);\n\nstatic const struct pci_device_id ctucan_pci_tbl[] = {\n\t{PCI_DEVICE_DATA(TEDIA, CTUCAN_VER21,\n\t\tCTUCAN_WITH_CTUCAN_ID)},\n\t{},\n};\n\nstatic struct pci_driver ctucan_pci_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = ctucan_pci_tbl,\n\t.probe = ctucan_pci_probe,\n\t.remove = ctucan_pci_remove,\n\t.driver.pm = &ctucan_pci_pm_ops,\n};\n\nmodule_pci_driver(ctucan_pci_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Pavel Pisa <pisa@cmp.felk.cvut.cz>\");\nMODULE_DESCRIPTION(\"CTU CAN FD for PCI bus\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}