{
  "module_name": "ctucanfd_base.c",
  "hash_id": "58b22363315c4988e54de29fa3185c08e513930f41bca384d6cc9784fdcc6af8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/ctucanfd/ctucanfd_base.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/errno.h>\n#include <linux/ethtool.h>\n#include <linux/init.h>\n#include <linux/bitfield.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/can/error.h>\n#include <linux/pm_runtime.h>\n\n#include \"ctucanfd.h\"\n#include \"ctucanfd_kregs.h\"\n#include \"ctucanfd_kframe.h\"\n\n#ifdef DEBUG\n#define  ctucan_netdev_dbg(ndev, args...) \\\n\t\tnetdev_dbg(ndev, args)\n#else\n#define ctucan_netdev_dbg(...) do { } while (0)\n#endif\n\n#define CTUCANFD_ID 0xCAFD\n\n \n\n#define CTUCANFD_FLAG_RX_FFW_BUFFERED\t1\n\n#define CTUCAN_STATE_TO_TEXT_ENTRY(st) \\\n\t\t[st] = #st\n\nenum ctucan_txtb_status {\n\tTXT_NOT_EXIST       = 0x0,\n\tTXT_RDY             = 0x1,\n\tTXT_TRAN            = 0x2,\n\tTXT_ABTP            = 0x3,\n\tTXT_TOK             = 0x4,\n\tTXT_ERR             = 0x6,\n\tTXT_ABT             = 0x7,\n\tTXT_ETY             = 0x8,\n};\n\nenum ctucan_txtb_command {\n\tTXT_CMD_SET_EMPTY   = 0x01,\n\tTXT_CMD_SET_READY   = 0x02,\n\tTXT_CMD_SET_ABORT   = 0x04\n};\n\nstatic const struct can_bittiming_const ctu_can_fd_bit_timing_max = {\n\t.name = \"ctu_can_fd\",\n\t.tseg1_min = 2,\n\t.tseg1_max = 190,\n\t.tseg2_min = 1,\n\t.tseg2_max = 63,\n\t.sjw_max = 31,\n\t.brp_min = 1,\n\t.brp_max = 8,\n\t.brp_inc = 1,\n};\n\nstatic const struct can_bittiming_const ctu_can_fd_bit_timing_data_max = {\n\t.name = \"ctu_can_fd\",\n\t.tseg1_min = 2,\n\t.tseg1_max = 94,\n\t.tseg2_min = 1,\n\t.tseg2_max = 31,\n\t.sjw_max = 31,\n\t.brp_min = 1,\n\t.brp_max = 2,\n\t.brp_inc = 1,\n};\n\nstatic const char * const ctucan_state_strings[CAN_STATE_MAX] = {\n\tCTUCAN_STATE_TO_TEXT_ENTRY(CAN_STATE_ERROR_ACTIVE),\n\tCTUCAN_STATE_TO_TEXT_ENTRY(CAN_STATE_ERROR_WARNING),\n\tCTUCAN_STATE_TO_TEXT_ENTRY(CAN_STATE_ERROR_PASSIVE),\n\tCTUCAN_STATE_TO_TEXT_ENTRY(CAN_STATE_BUS_OFF),\n\tCTUCAN_STATE_TO_TEXT_ENTRY(CAN_STATE_STOPPED),\n\tCTUCAN_STATE_TO_TEXT_ENTRY(CAN_STATE_SLEEPING)\n};\n\nstatic void ctucan_write32_le(struct ctucan_priv *priv,\n\t\t\t      enum ctu_can_fd_can_registers reg, u32 val)\n{\n\tiowrite32(val, priv->mem_base + reg);\n}\n\nstatic void ctucan_write32_be(struct ctucan_priv *priv,\n\t\t\t      enum ctu_can_fd_can_registers reg, u32 val)\n{\n\tiowrite32be(val, priv->mem_base + reg);\n}\n\nstatic u32 ctucan_read32_le(struct ctucan_priv *priv,\n\t\t\t    enum ctu_can_fd_can_registers reg)\n{\n\treturn ioread32(priv->mem_base + reg);\n}\n\nstatic u32 ctucan_read32_be(struct ctucan_priv *priv,\n\t\t\t    enum ctu_can_fd_can_registers reg)\n{\n\treturn ioread32be(priv->mem_base + reg);\n}\n\nstatic void ctucan_write32(struct ctucan_priv *priv, enum ctu_can_fd_can_registers reg, u32 val)\n{\n\tpriv->write_reg(priv, reg, val);\n}\n\nstatic u32 ctucan_read32(struct ctucan_priv *priv, enum ctu_can_fd_can_registers reg)\n{\n\treturn priv->read_reg(priv, reg);\n}\n\nstatic void ctucan_write_txt_buf(struct ctucan_priv *priv, enum ctu_can_fd_can_registers buf_base,\n\t\t\t\t u32 offset, u32 val)\n{\n\tpriv->write_reg(priv, buf_base + offset, val);\n}\n\n#define CTU_CAN_FD_TXTNF(priv) (!!FIELD_GET(REG_STATUS_TXNF, ctucan_read32(priv, CTUCANFD_STATUS)))\n#define CTU_CAN_FD_ENABLED(priv) (!!FIELD_GET(REG_MODE_ENA, ctucan_read32(priv, CTUCANFD_MODE)))\n\n \nstatic const char *ctucan_state_to_str(enum can_state state)\n{\n\tconst char *txt = NULL;\n\n\tif (state >= 0 && state < CAN_STATE_MAX)\n\t\ttxt = ctucan_state_strings[state];\n\treturn txt ? txt : \"UNKNOWN\";\n}\n\n \nstatic int ctucan_reset(struct net_device *ndev)\n{\n\tstruct ctucan_priv *priv = netdev_priv(ndev);\n\tint i = 100;\n\n\tctucan_write32(priv, CTUCANFD_MODE, REG_MODE_RST);\n\tclear_bit(CTUCANFD_FLAG_RX_FFW_BUFFERED, &priv->drv_flags);\n\n\tdo {\n\t\tu16 device_id = FIELD_GET(REG_DEVICE_ID_DEVICE_ID,\n\t\t\t\t\t  ctucan_read32(priv, CTUCANFD_DEVICE_ID));\n\n\t\tif (device_id == 0xCAFD)\n\t\t\treturn 0;\n\t\tif (!i--) {\n\t\t\tnetdev_warn(ndev, \"device did not leave reset\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tusleep_range(100, 200);\n\t} while (1);\n}\n\n \nstatic int ctucan_set_btr(struct net_device *ndev, struct can_bittiming *bt, bool nominal)\n{\n\tstruct ctucan_priv *priv = netdev_priv(ndev);\n\tint max_ph1_len = 31;\n\tu32 btr = 0;\n\tu32 prop_seg = bt->prop_seg;\n\tu32 phase_seg1 = bt->phase_seg1;\n\n\tif (CTU_CAN_FD_ENABLED(priv)) {\n\t\tnetdev_err(ndev, \"BUG! Cannot set bittiming - CAN is enabled\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tif (nominal)\n\t\tmax_ph1_len = 63;\n\n\t \n\tif (phase_seg1 > max_ph1_len) {\n\t\tprop_seg += phase_seg1 - max_ph1_len;\n\t\tphase_seg1 = max_ph1_len;\n\t\tbt->prop_seg = prop_seg;\n\t\tbt->phase_seg1 = phase_seg1;\n\t}\n\n\tif (nominal) {\n\t\tbtr = FIELD_PREP(REG_BTR_PROP, prop_seg);\n\t\tbtr |= FIELD_PREP(REG_BTR_PH1, phase_seg1);\n\t\tbtr |= FIELD_PREP(REG_BTR_PH2, bt->phase_seg2);\n\t\tbtr |= FIELD_PREP(REG_BTR_BRP, bt->brp);\n\t\tbtr |= FIELD_PREP(REG_BTR_SJW, bt->sjw);\n\n\t\tctucan_write32(priv, CTUCANFD_BTR, btr);\n\t} else {\n\t\tbtr = FIELD_PREP(REG_BTR_FD_PROP_FD, prop_seg);\n\t\tbtr |= FIELD_PREP(REG_BTR_FD_PH1_FD, phase_seg1);\n\t\tbtr |= FIELD_PREP(REG_BTR_FD_PH2_FD, bt->phase_seg2);\n\t\tbtr |= FIELD_PREP(REG_BTR_FD_BRP_FD, bt->brp);\n\t\tbtr |= FIELD_PREP(REG_BTR_FD_SJW_FD, bt->sjw);\n\n\t\tctucan_write32(priv, CTUCANFD_BTR_FD, btr);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ctucan_set_bittiming(struct net_device *ndev)\n{\n\tstruct ctucan_priv *priv = netdev_priv(ndev);\n\tstruct can_bittiming *bt = &priv->can.bittiming;\n\n\t \n\treturn ctucan_set_btr(ndev, bt, true);\n}\n\n \nstatic int ctucan_set_data_bittiming(struct net_device *ndev)\n{\n\tstruct ctucan_priv *priv = netdev_priv(ndev);\n\tstruct can_bittiming *dbt = &priv->can.data_bittiming;\n\n\t \n\treturn ctucan_set_btr(ndev, dbt, false);\n}\n\n \nstatic int ctucan_set_secondary_sample_point(struct net_device *ndev)\n{\n\tstruct ctucan_priv *priv = netdev_priv(ndev);\n\tstruct can_bittiming *dbt = &priv->can.data_bittiming;\n\tint ssp_offset = 0;\n\tu32 ssp_cfg = 0;  \n\n\tif (CTU_CAN_FD_ENABLED(priv)) {\n\t\tnetdev_err(ndev, \"BUG! Cannot set SSP - CAN is enabled\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t \n\tif (dbt->bitrate > 1000000) {\n\t\t \n\t\tssp_offset = (priv->can.clock.freq / 1000) * dbt->sample_point / dbt->bitrate;\n\n\t\tif (ssp_offset > 127) {\n\t\t\tnetdev_warn(ndev, \"SSP offset saturated to 127\\n\");\n\t\t\tssp_offset = 127;\n\t\t}\n\n\t\tssp_cfg = FIELD_PREP(REG_TRV_DELAY_SSP_OFFSET, ssp_offset);\n\t\tssp_cfg |= FIELD_PREP(REG_TRV_DELAY_SSP_SRC, 0x1);\n\t}\n\n\tctucan_write32(priv, CTUCANFD_TRV_DELAY, ssp_cfg);\n\n\treturn 0;\n}\n\n \nstatic void ctucan_set_mode(struct ctucan_priv *priv, const struct can_ctrlmode *mode)\n{\n\tu32 mode_reg = ctucan_read32(priv, CTUCANFD_MODE);\n\n\tmode_reg = (mode->flags & CAN_CTRLMODE_LOOPBACK) ?\n\t\t\t(mode_reg | REG_MODE_ILBP) :\n\t\t\t(mode_reg & ~REG_MODE_ILBP);\n\n\tmode_reg = (mode->flags & CAN_CTRLMODE_LISTENONLY) ?\n\t\t\t(mode_reg | REG_MODE_BMM) :\n\t\t\t(mode_reg & ~REG_MODE_BMM);\n\n\tmode_reg = (mode->flags & CAN_CTRLMODE_FD) ?\n\t\t\t(mode_reg | REG_MODE_FDE) :\n\t\t\t(mode_reg & ~REG_MODE_FDE);\n\n\tmode_reg = (mode->flags & CAN_CTRLMODE_PRESUME_ACK) ?\n\t\t\t(mode_reg | REG_MODE_ACF) :\n\t\t\t(mode_reg & ~REG_MODE_ACF);\n\n\tmode_reg = (mode->flags & CAN_CTRLMODE_FD_NON_ISO) ?\n\t\t\t(mode_reg | REG_MODE_NISOFD) :\n\t\t\t(mode_reg & ~REG_MODE_NISOFD);\n\n\t \n\tmode_reg &= ~FIELD_PREP(REG_MODE_RTRTH, 0xF);\n\tmode_reg = (mode->flags & CAN_CTRLMODE_ONE_SHOT) ?\n\t\t\t(mode_reg | REG_MODE_RTRLE) :\n\t\t\t(mode_reg & ~REG_MODE_RTRLE);\n\n\t \n\tmode_reg &= ~REG_MODE_TSTM;\n\n\tctucan_write32(priv, CTUCANFD_MODE, mode_reg);\n}\n\n \nstatic int ctucan_chip_start(struct net_device *ndev)\n{\n\tstruct ctucan_priv *priv = netdev_priv(ndev);\n\tu32 int_ena, int_msk;\n\tu32 mode_reg;\n\tint err;\n\tstruct can_ctrlmode mode;\n\n\tpriv->txb_prio = 0x01234567;\n\tpriv->txb_head = 0;\n\tpriv->txb_tail = 0;\n\tctucan_write32(priv, CTUCANFD_TX_PRIORITY, priv->txb_prio);\n\n\t \n\terr = ctucan_set_bittiming(ndev);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = ctucan_set_data_bittiming(ndev);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = ctucan_set_secondary_sample_point(ndev);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tmode.flags = priv->can.ctrlmode;\n\tmode.mask = 0xFFFFFFFF;\n\tctucan_set_mode(priv, &mode);\n\n\t \n\tint_ena = REG_INT_STAT_RBNEI |\n\t\t  REG_INT_STAT_TXBHCI |\n\t\t  REG_INT_STAT_EWLI |\n\t\t  REG_INT_STAT_FCSI;\n\n\t \n\tif (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING) {\n\t\tint_ena |= REG_INT_STAT_ALI |\n\t\t\t   REG_INT_STAT_BEI;\n\t}\n\n\tint_msk = ~int_ena;  \n\n\t \n\tctucan_write32(priv, CTUCANFD_INT_MASK_SET, int_msk);\n\tctucan_write32(priv, CTUCANFD_INT_ENA_SET, int_ena);\n\n\t \n\tpriv->can.state = CAN_STATE_STOPPED;\n\n\t \n\tmode_reg = ctucan_read32(priv, CTUCANFD_MODE);\n\tmode_reg |= REG_MODE_ENA;\n\tctucan_write32(priv, CTUCANFD_MODE, mode_reg);\n\n\treturn 0;\n}\n\n \nstatic int ctucan_do_set_mode(struct net_device *ndev, enum can_mode mode)\n{\n\tint ret;\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\tret = ctucan_reset(ndev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = ctucan_chip_start(ndev);\n\t\tif (ret < 0) {\n\t\t\tnetdev_err(ndev, \"ctucan_chip_start failed!\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tnetif_wake_queue(ndev);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic enum ctucan_txtb_status ctucan_get_tx_status(struct ctucan_priv *priv, u8 buf)\n{\n\tu32 tx_status = ctucan_read32(priv, CTUCANFD_TX_STATUS);\n\tenum ctucan_txtb_status status = (tx_status >> (buf * 4)) & 0x7;\n\n\treturn status;\n}\n\n \nstatic bool ctucan_is_txt_buf_writable(struct ctucan_priv *priv, u8 buf)\n{\n\tenum ctucan_txtb_status buf_status;\n\n\tbuf_status = ctucan_get_tx_status(priv, buf);\n\tif (buf_status == TXT_RDY || buf_status == TXT_TRAN || buf_status == TXT_ABTP)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic bool ctucan_insert_frame(struct ctucan_priv *priv, const struct canfd_frame *cf, u8 buf,\n\t\t\t\tbool isfdf)\n{\n\tu32 buf_base;\n\tu32 ffw = 0;\n\tu32 idw = 0;\n\tunsigned int i;\n\n\tif (buf >= priv->ntxbufs)\n\t\treturn false;\n\n\tif (!ctucan_is_txt_buf_writable(priv, buf))\n\t\treturn false;\n\n\tif (cf->len > CANFD_MAX_DLEN)\n\t\treturn false;\n\n\t \n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tffw |= REG_FRAME_FORMAT_W_RTR;\n\n\tif (cf->can_id & CAN_EFF_FLAG)\n\t\tffw |= REG_FRAME_FORMAT_W_IDE;\n\n\tif (isfdf) {\n\t\tffw |= REG_FRAME_FORMAT_W_FDF;\n\t\tif (cf->flags & CANFD_BRS)\n\t\t\tffw |= REG_FRAME_FORMAT_W_BRS;\n\t}\n\n\tffw |= FIELD_PREP(REG_FRAME_FORMAT_W_DLC, can_fd_len2dlc(cf->len));\n\n\t \n\tif (cf->can_id & CAN_EFF_FLAG)\n\t\tidw = cf->can_id & CAN_EFF_MASK;\n\telse\n\t\tidw = FIELD_PREP(REG_IDENTIFIER_W_IDENTIFIER_BASE, cf->can_id & CAN_SFF_MASK);\n\n\t \n\tbuf_base = (buf + 1) * 0x100;\n\tctucan_write_txt_buf(priv, buf_base, CTUCANFD_FRAME_FORMAT_W, ffw);\n\tctucan_write_txt_buf(priv, buf_base, CTUCANFD_IDENTIFIER_W, idw);\n\n\t \n\tif (!(cf->can_id & CAN_RTR_FLAG)) {\n\t\tfor (i = 0; i < cf->len; i += 4) {\n\t\t\tu32 data = le32_to_cpu(*(__le32 *)(cf->data + i));\n\n\t\t\tctucan_write_txt_buf(priv, buf_base, CTUCANFD_DATA_1_4_W + i, data);\n\t\t}\n\t}\n\n\treturn true;\n}\n\n \nstatic void ctucan_give_txtb_cmd(struct ctucan_priv *priv, enum ctucan_txtb_command cmd, u8 buf)\n{\n\tu32 tx_cmd = cmd;\n\n\ttx_cmd |= 1 << (buf + 8);\n\tctucan_write32(priv, CTUCANFD_TX_COMMAND, tx_cmd);\n}\n\n \nstatic netdev_tx_t ctucan_start_xmit(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct ctucan_priv *priv = netdev_priv(ndev);\n\tstruct canfd_frame *cf = (struct canfd_frame *)skb->data;\n\tu32 txtb_id;\n\tbool ok;\n\tunsigned long flags;\n\n\tif (can_dev_dropped_skb(ndev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tif (unlikely(!CTU_CAN_FD_TXTNF(priv))) {\n\t\tnetif_stop_queue(ndev);\n\t\tnetdev_err(ndev, \"BUG!, no TXB free when queue awake!\\n\");\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\ttxtb_id = priv->txb_head % priv->ntxbufs;\n\tctucan_netdev_dbg(ndev, \"%s: using TXB#%u\\n\", __func__, txtb_id);\n\tok = ctucan_insert_frame(priv, cf, txtb_id, can_is_canfd_skb(skb));\n\n\tif (!ok) {\n\t\tnetdev_err(ndev, \"BUG! TXNF set but cannot insert frame into TXTB! HW Bug?\");\n\t\tkfree_skb(skb);\n\t\tndev->stats.tx_dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tcan_put_echo_skb(skb, ndev, txtb_id, 0);\n\n\tspin_lock_irqsave(&priv->tx_lock, flags);\n\tctucan_give_txtb_cmd(priv, TXT_CMD_SET_READY, txtb_id);\n\tpriv->txb_head++;\n\n\t \n\tif (!CTU_CAN_FD_TXTNF(priv))\n\t\tnetif_stop_queue(ndev);\n\n\tspin_unlock_irqrestore(&priv->tx_lock, flags);\n\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic void ctucan_read_rx_frame(struct ctucan_priv *priv, struct canfd_frame *cf, u32 ffw)\n{\n\tu32 idw;\n\tunsigned int i;\n\tunsigned int wc;\n\tunsigned int len;\n\n\tidw = ctucan_read32(priv, CTUCANFD_RX_DATA);\n\tif (FIELD_GET(REG_FRAME_FORMAT_W_IDE, ffw))\n\t\tcf->can_id = (idw & CAN_EFF_MASK) | CAN_EFF_FLAG;\n\telse\n\t\tcf->can_id = (idw >> 18) & CAN_SFF_MASK;\n\n\t \n\tif (FIELD_GET(REG_FRAME_FORMAT_W_FDF, ffw)) {\n\t\tif (FIELD_GET(REG_FRAME_FORMAT_W_BRS, ffw))\n\t\t\tcf->flags |= CANFD_BRS;\n\t\tif (FIELD_GET(REG_FRAME_FORMAT_W_ESI_RSV, ffw))\n\t\t\tcf->flags |= CANFD_ESI;\n\t} else if (FIELD_GET(REG_FRAME_FORMAT_W_RTR, ffw)) {\n\t\tcf->can_id |= CAN_RTR_FLAG;\n\t}\n\n\twc = FIELD_GET(REG_FRAME_FORMAT_W_RWCNT, ffw) - 3;\n\n\t \n\tif (FIELD_GET(REG_FRAME_FORMAT_W_DLC, ffw) <= 8) {\n\t\tlen = FIELD_GET(REG_FRAME_FORMAT_W_DLC, ffw);\n\t} else {\n\t\tif (FIELD_GET(REG_FRAME_FORMAT_W_FDF, ffw))\n\t\t\tlen = wc << 2;\n\t\telse\n\t\t\tlen = 8;\n\t}\n\tcf->len = len;\n\tif (unlikely(len > wc * 4))\n\t\tlen = wc * 4;\n\n\t \n\tctucan_read32(priv, CTUCANFD_RX_DATA);\n\tctucan_read32(priv, CTUCANFD_RX_DATA);\n\n\t \n\tfor (i = 0; i < len; i += 4) {\n\t\tu32 data = ctucan_read32(priv, CTUCANFD_RX_DATA);\n\t\t*(__le32 *)(cf->data + i) = cpu_to_le32(data);\n\t}\n\twhile (unlikely(i < wc * 4)) {\n\t\tctucan_read32(priv, CTUCANFD_RX_DATA);\n\t\ti += 4;\n\t}\n}\n\n \nstatic int ctucan_rx(struct net_device *ndev)\n{\n\tstruct ctucan_priv *priv = netdev_priv(ndev);\n\tstruct net_device_stats *stats = &ndev->stats;\n\tstruct canfd_frame *cf;\n\tstruct sk_buff *skb;\n\tu32 ffw;\n\n\tif (test_bit(CTUCANFD_FLAG_RX_FFW_BUFFERED, &priv->drv_flags)) {\n\t\tffw = priv->rxfrm_first_word;\n\t\tclear_bit(CTUCANFD_FLAG_RX_FFW_BUFFERED, &priv->drv_flags);\n\t} else {\n\t\tffw = ctucan_read32(priv, CTUCANFD_RX_DATA);\n\t}\n\n\tif (!FIELD_GET(REG_FRAME_FORMAT_W_RWCNT, ffw))\n\t\treturn -EAGAIN;\n\n\tif (FIELD_GET(REG_FRAME_FORMAT_W_FDF, ffw))\n\t\tskb = alloc_canfd_skb(ndev, &cf);\n\telse\n\t\tskb = alloc_can_skb(ndev, (struct can_frame **)&cf);\n\n\tif (unlikely(!skb)) {\n\t\tpriv->rxfrm_first_word = ffw;\n\t\tset_bit(CTUCANFD_FLAG_RX_FFW_BUFFERED, &priv->drv_flags);\n\t\treturn 0;\n\t}\n\n\tctucan_read_rx_frame(priv, cf, ffw);\n\n\tstats->rx_bytes += cf->len;\n\tstats->rx_packets++;\n\tnetif_receive_skb(skb);\n\n\treturn 1;\n}\n\n \nstatic enum can_state ctucan_read_fault_state(struct ctucan_priv *priv)\n{\n\tu32 fs;\n\tu32 rec_tec;\n\tu32 ewl;\n\n\tfs = ctucan_read32(priv, CTUCANFD_EWL);\n\trec_tec = ctucan_read32(priv, CTUCANFD_REC);\n\tewl = FIELD_GET(REG_EWL_EW_LIMIT, fs);\n\n\tif (FIELD_GET(REG_EWL_ERA, fs)) {\n\t\tif (ewl > FIELD_GET(REG_REC_REC_VAL, rec_tec) &&\n\t\t    ewl > FIELD_GET(REG_REC_TEC_VAL, rec_tec))\n\t\t\treturn CAN_STATE_ERROR_ACTIVE;\n\t\telse\n\t\t\treturn CAN_STATE_ERROR_WARNING;\n\t} else if (FIELD_GET(REG_EWL_ERP, fs)) {\n\t\treturn CAN_STATE_ERROR_PASSIVE;\n\t} else if (FIELD_GET(REG_EWL_BOF, fs)) {\n\t\treturn CAN_STATE_BUS_OFF;\n\t}\n\n\tWARN(true, \"Invalid error state\");\n\treturn CAN_STATE_ERROR_PASSIVE;\n}\n\n \nstatic void ctucan_get_rec_tec(struct ctucan_priv *priv, struct can_berr_counter *bec)\n{\n\tu32 err_ctrs = ctucan_read32(priv, CTUCANFD_REC);\n\n\tbec->rxerr = FIELD_GET(REG_REC_REC_VAL, err_ctrs);\n\tbec->txerr = FIELD_GET(REG_REC_TEC_VAL, err_ctrs);\n}\n\n \nstatic void ctucan_err_interrupt(struct net_device *ndev, u32 isr)\n{\n\tstruct ctucan_priv *priv = netdev_priv(ndev);\n\tstruct net_device_stats *stats = &ndev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tenum can_state state;\n\tstruct can_berr_counter bec;\n\tu32 err_capt_alc;\n\tint dologerr = net_ratelimit();\n\n\tctucan_get_rec_tec(priv, &bec);\n\tstate = ctucan_read_fault_state(priv);\n\terr_capt_alc = ctucan_read32(priv, CTUCANFD_ERR_CAPT);\n\n\tif (dologerr)\n\t\tnetdev_info(ndev, \"%s: ISR = 0x%08x, rxerr %d, txerr %d, error type %lu, pos %lu, ALC id_field %lu, bit %lu\\n\",\n\t\t\t    __func__, isr, bec.rxerr, bec.txerr,\n\t\t\t    FIELD_GET(REG_ERR_CAPT_ERR_TYPE, err_capt_alc),\n\t\t\t    FIELD_GET(REG_ERR_CAPT_ERR_POS, err_capt_alc),\n\t\t\t    FIELD_GET(REG_ERR_CAPT_ALC_ID_FIELD, err_capt_alc),\n\t\t\t    FIELD_GET(REG_ERR_CAPT_ALC_BIT, err_capt_alc));\n\n\tskb = alloc_can_err_skb(ndev, &cf);\n\n\t \n\tif (FIELD_GET(REG_INT_STAT_FCSI, isr) || FIELD_GET(REG_INT_STAT_EWLI, isr)) {\n\t\tnetdev_info(ndev, \"state changes from %s to %s\\n\",\n\t\t\t    ctucan_state_to_str(priv->can.state),\n\t\t\t    ctucan_state_to_str(state));\n\n\t\tif (priv->can.state == state)\n\t\t\tnetdev_warn(ndev,\n\t\t\t\t    \"current and previous state is the same! (missed interrupt?)\\n\");\n\n\t\tpriv->can.state = state;\n\t\tswitch (state) {\n\t\tcase CAN_STATE_BUS_OFF:\n\t\t\tpriv->can.can_stats.bus_off++;\n\t\t\tcan_bus_off(ndev);\n\t\t\tif (skb)\n\t\t\t\tcf->can_id |= CAN_ERR_BUSOFF;\n\t\t\tbreak;\n\t\tcase CAN_STATE_ERROR_PASSIVE:\n\t\t\tpriv->can.can_stats.error_passive++;\n\t\t\tif (skb) {\n\t\t\t\tcf->can_id |= CAN_ERR_CRTL | CAN_ERR_CNT;\n\t\t\t\tcf->data[1] = (bec.rxerr > 127) ?\n\t\t\t\t\t\tCAN_ERR_CRTL_RX_PASSIVE :\n\t\t\t\t\t\tCAN_ERR_CRTL_TX_PASSIVE;\n\t\t\t\tcf->data[6] = bec.txerr;\n\t\t\t\tcf->data[7] = bec.rxerr;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CAN_STATE_ERROR_WARNING:\n\t\t\tpriv->can.can_stats.error_warning++;\n\t\t\tif (skb) {\n\t\t\t\tcf->can_id |= CAN_ERR_CRTL | CAN_ERR_CNT;\n\t\t\t\tcf->data[1] |= (bec.txerr > bec.rxerr) ?\n\t\t\t\t\tCAN_ERR_CRTL_TX_WARNING :\n\t\t\t\t\tCAN_ERR_CRTL_RX_WARNING;\n\t\t\t\tcf->data[6] = bec.txerr;\n\t\t\t\tcf->data[7] = bec.rxerr;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CAN_STATE_ERROR_ACTIVE:\n\t\t\tcf->can_id |= CAN_ERR_CNT;\n\t\t\tcf->data[1] = CAN_ERR_CRTL_ACTIVE;\n\t\t\tcf->data[6] = bec.txerr;\n\t\t\tcf->data[7] = bec.rxerr;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetdev_warn(ndev, \"unhandled error state (%d:%s)!\\n\",\n\t\t\t\t    state, ctucan_state_to_str(state));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (FIELD_GET(REG_INT_STAT_ALI, isr)) {\n\t\tif (dologerr)\n\t\t\tnetdev_info(ndev, \"arbitration lost\\n\");\n\t\tpriv->can.can_stats.arbitration_lost++;\n\t\tif (skb) {\n\t\t\tcf->can_id |= CAN_ERR_LOSTARB;\n\t\t\tcf->data[0] = CAN_ERR_LOSTARB_UNSPEC;\n\t\t}\n\t}\n\n\t \n\tif (FIELD_GET(REG_INT_STAT_BEI, isr)) {\n\t\tnetdev_info(ndev, \"bus error\\n\");\n\t\tpriv->can.can_stats.bus_error++;\n\t\tstats->rx_errors++;\n\t\tif (skb) {\n\t\t\tcf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\n\t\t\tcf->data[2] = CAN_ERR_PROT_UNSPEC;\n\t\t\tcf->data[3] = CAN_ERR_PROT_LOC_UNSPEC;\n\t\t}\n\t}\n\n\tif (skb) {\n\t\tstats->rx_packets++;\n\t\tstats->rx_bytes += cf->can_dlc;\n\t\tnetif_rx(skb);\n\t}\n}\n\n \nstatic int ctucan_rx_poll(struct napi_struct *napi, int quota)\n{\n\tstruct net_device *ndev = napi->dev;\n\tstruct ctucan_priv *priv = netdev_priv(ndev);\n\tint work_done = 0;\n\tu32 status;\n\tu32 framecnt;\n\tint res = 1;\n\n\tframecnt = FIELD_GET(REG_RX_STATUS_RXFRC, ctucan_read32(priv, CTUCANFD_RX_STATUS));\n\twhile (framecnt && work_done < quota && res > 0) {\n\t\tres = ctucan_rx(ndev);\n\t\twork_done++;\n\t\tframecnt = FIELD_GET(REG_RX_STATUS_RXFRC, ctucan_read32(priv, CTUCANFD_RX_STATUS));\n\t}\n\n\t \n\tstatus = ctucan_read32(priv, CTUCANFD_STATUS);\n\tif (FIELD_GET(REG_STATUS_DOR, status)) {\n\t\tstruct net_device_stats *stats = &ndev->stats;\n\t\tstruct can_frame *cf;\n\t\tstruct sk_buff *skb;\n\n\t\tnetdev_info(ndev, \"rx_poll: rx fifo overflow\\n\");\n\t\tstats->rx_over_errors++;\n\t\tstats->rx_errors++;\n\t\tskb = alloc_can_err_skb(ndev, &cf);\n\t\tif (skb) {\n\t\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\t\tcf->data[1] |= CAN_ERR_CRTL_RX_OVERFLOW;\n\t\t\tstats->rx_packets++;\n\t\t\tstats->rx_bytes += cf->can_dlc;\n\t\t\tnetif_rx(skb);\n\t\t}\n\n\t\t \n\t\tctucan_write32(priv, CTUCANFD_COMMAND, REG_COMMAND_CDO);\n\t}\n\n\tif (!framecnt && res != 0) {\n\t\tif (napi_complete_done(napi, work_done)) {\n\t\t\t \n\t\t\tctucan_write32(priv, CTUCANFD_INT_STAT, REG_INT_STAT_RBNEI);\n\t\t\tctucan_write32(priv, CTUCANFD_INT_MASK_CLR, REG_INT_STAT_RBNEI);\n\t\t}\n\t}\n\n\treturn work_done;\n}\n\n \nstatic void ctucan_rotate_txb_prio(struct net_device *ndev)\n{\n\tstruct ctucan_priv *priv = netdev_priv(ndev);\n\tu32 prio = priv->txb_prio;\n\n\tprio = (prio << 4) | ((prio >> ((priv->ntxbufs - 1) * 4)) & 0xF);\n\tctucan_netdev_dbg(ndev, \"%s: from 0x%08x to 0x%08x\\n\", __func__, priv->txb_prio, prio);\n\tpriv->txb_prio = prio;\n\tctucan_write32(priv, CTUCANFD_TX_PRIORITY, prio);\n}\n\n \nstatic void ctucan_tx_interrupt(struct net_device *ndev)\n{\n\tstruct ctucan_priv *priv = netdev_priv(ndev);\n\tstruct net_device_stats *stats = &ndev->stats;\n\tbool first = true;\n\tbool some_buffers_processed;\n\tunsigned long flags;\n\tenum ctucan_txtb_status txtb_status;\n\tu32 txtb_id;\n\n\t \n\tdo {\n\t\tspin_lock_irqsave(&priv->tx_lock, flags);\n\n\t\tsome_buffers_processed = false;\n\t\twhile ((int)(priv->txb_head - priv->txb_tail) > 0) {\n\t\t\ttxtb_id = priv->txb_tail % priv->ntxbufs;\n\t\t\ttxtb_status = ctucan_get_tx_status(priv, txtb_id);\n\n\t\t\tctucan_netdev_dbg(ndev, \"TXI: TXB#%u: status 0x%x\\n\", txtb_id, txtb_status);\n\n\t\t\tswitch (txtb_status) {\n\t\t\tcase TXT_TOK:\n\t\t\t\tctucan_netdev_dbg(ndev, \"TXT_OK\\n\");\n\t\t\t\tstats->tx_bytes += can_get_echo_skb(ndev, txtb_id, NULL);\n\t\t\t\tstats->tx_packets++;\n\t\t\t\tbreak;\n\t\t\tcase TXT_ERR:\n\t\t\t\t \n\t\t\t\tnetdev_warn(ndev, \"TXB in Error state\\n\");\n\t\t\t\tcan_free_echo_skb(ndev, txtb_id, NULL);\n\t\t\t\tstats->tx_dropped++;\n\t\t\t\tbreak;\n\t\t\tcase TXT_ABT:\n\t\t\t\t \n\t\t\t\tnetdev_warn(ndev, \"TXB in Aborted state\\n\");\n\t\t\t\tcan_free_echo_skb(ndev, txtb_id, NULL);\n\t\t\t\tstats->tx_dropped++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tif (first) {\n\t\t\t\t\tnetdev_err(ndev,\n\t\t\t\t\t\t   \"BUG: TXB#%u not in a finished state (0x%x)!\\n\",\n\t\t\t\t\t\t   txtb_id, txtb_status);\n\t\t\t\t\tspin_unlock_irqrestore(&priv->tx_lock, flags);\n\t\t\t\t\t \n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tgoto clear;\n\t\t\t}\n\t\t\tpriv->txb_tail++;\n\t\t\tfirst = false;\n\t\t\tsome_buffers_processed = true;\n\t\t\t \n\t\t\tctucan_rotate_txb_prio(ndev);\n\t\t\tctucan_give_txtb_cmd(priv, TXT_CMD_SET_EMPTY, txtb_id);\n\t\t}\nclear:\n\t\tspin_unlock_irqrestore(&priv->tx_lock, flags);\n\n\t\t \n\t\tif (some_buffers_processed) {\n\t\t\t \n\t\t\tctucan_write32(priv, CTUCANFD_INT_STAT, REG_INT_STAT_TXBHCI);\n\t\t}\n\t} while (some_buffers_processed);\n\n\tspin_lock_irqsave(&priv->tx_lock, flags);\n\n\t \n\tif (CTU_CAN_FD_TXTNF(priv))\n\t\tnetif_wake_queue(ndev);\n\n\tspin_unlock_irqrestore(&priv->tx_lock, flags);\n}\n\n \nstatic irqreturn_t ctucan_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *ndev = (struct net_device *)dev_id;\n\tstruct ctucan_priv *priv = netdev_priv(ndev);\n\tu32 isr, icr;\n\tu32 imask;\n\tint irq_loops;\n\n\tfor (irq_loops = 0; irq_loops < 10000; irq_loops++) {\n\t\t \n\t\tisr = ctucan_read32(priv, CTUCANFD_INT_STAT);\n\n\t\tif (!isr)\n\t\t\treturn irq_loops ? IRQ_HANDLED : IRQ_NONE;\n\n\t\t \n\t\tif (FIELD_GET(REG_INT_STAT_RBNEI, isr)) {\n\t\t\tctucan_netdev_dbg(ndev, \"RXBNEI\\n\");\n\t\t\t \n\t\t\ticr = REG_INT_STAT_RBNEI;\n\t\t\tctucan_write32(priv, CTUCANFD_INT_MASK_SET, icr);\n\t\t\tctucan_write32(priv, CTUCANFD_INT_STAT, icr);\n\t\t\tnapi_schedule(&priv->napi);\n\t\t}\n\n\t\t \n\t\tif (FIELD_GET(REG_INT_STAT_TXBHCI, isr)) {\n\t\t\tctucan_netdev_dbg(ndev, \"TXBHCI\\n\");\n\t\t\t \n\t\t\tctucan_tx_interrupt(ndev);\n\t\t}\n\n\t\t \n\t\tif (FIELD_GET(REG_INT_STAT_EWLI, isr) ||\n\t\t    FIELD_GET(REG_INT_STAT_FCSI, isr) ||\n\t\t    FIELD_GET(REG_INT_STAT_ALI, isr)) {\n\t\t\ticr = isr & (REG_INT_STAT_EWLI | REG_INT_STAT_FCSI | REG_INT_STAT_ALI);\n\n\t\t\tctucan_netdev_dbg(ndev, \"some ERR interrupt: clearing 0x%08x\\n\", icr);\n\t\t\tctucan_write32(priv, CTUCANFD_INT_STAT, icr);\n\t\t\tctucan_err_interrupt(ndev, isr);\n\t\t}\n\t\t \n\t}\n\n\tnetdev_err(ndev, \"%s: stuck interrupt (isr=0x%08x), stopping\\n\", __func__, isr);\n\n\tif (FIELD_GET(REG_INT_STAT_TXBHCI, isr)) {\n\t\tint i;\n\n\t\tnetdev_err(ndev, \"txb_head=0x%08x txb_tail=0x%08x\\n\",\n\t\t\t   priv->txb_head, priv->txb_tail);\n\t\tfor (i = 0; i < priv->ntxbufs; i++) {\n\t\t\tu32 status = ctucan_get_tx_status(priv, i);\n\n\t\t\tnetdev_err(ndev, \"txb[%d] txb status=0x%08x\\n\", i, status);\n\t\t}\n\t}\n\n\timask = 0xffffffff;\n\tctucan_write32(priv, CTUCANFD_INT_ENA_CLR, imask);\n\tctucan_write32(priv, CTUCANFD_INT_MASK_SET, imask);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void ctucan_chip_stop(struct net_device *ndev)\n{\n\tstruct ctucan_priv *priv = netdev_priv(ndev);\n\tu32 mask = 0xffffffff;\n\tu32 mode;\n\n\t \n\tctucan_write32(priv, CTUCANFD_INT_ENA_CLR, mask);\n\tctucan_write32(priv, CTUCANFD_INT_MASK_SET, mask);\n\tmode = ctucan_read32(priv, CTUCANFD_MODE);\n\tmode &= ~REG_MODE_ENA;\n\tctucan_write32(priv, CTUCANFD_MODE, mode);\n\n\tpriv->can.state = CAN_STATE_STOPPED;\n}\n\n \nstatic int ctucan_open(struct net_device *ndev)\n{\n\tstruct ctucan_priv *priv = netdev_priv(ndev);\n\tint ret;\n\n\tret = pm_runtime_get_sync(priv->dev);\n\tif (ret < 0) {\n\t\tnetdev_err(ndev, \"%s: pm_runtime_get failed(%d)\\n\",\n\t\t\t   __func__, ret);\n\t\tpm_runtime_put_noidle(priv->dev);\n\t\treturn ret;\n\t}\n\n\tret = ctucan_reset(ndev);\n\tif (ret < 0)\n\t\tgoto err_reset;\n\n\t \n\tret = open_candev(ndev);\n\tif (ret) {\n\t\tnetdev_warn(ndev, \"open_candev failed!\\n\");\n\t\tgoto err_open;\n\t}\n\n\tret = request_irq(ndev->irq, ctucan_interrupt, priv->irq_flags, ndev->name, ndev);\n\tif (ret < 0) {\n\t\tnetdev_err(ndev, \"irq allocation for CAN failed\\n\");\n\t\tgoto err_irq;\n\t}\n\n\tret = ctucan_chip_start(ndev);\n\tif (ret < 0) {\n\t\tnetdev_err(ndev, \"ctucan_chip_start failed!\\n\");\n\t\tgoto err_chip_start;\n\t}\n\n\tnetdev_info(ndev, \"ctu_can_fd device registered\\n\");\n\tnapi_enable(&priv->napi);\n\tnetif_start_queue(ndev);\n\n\treturn 0;\n\nerr_chip_start:\n\tfree_irq(ndev->irq, ndev);\nerr_irq:\n\tclose_candev(ndev);\nerr_open:\nerr_reset:\n\tpm_runtime_put(priv->dev);\n\n\treturn ret;\n}\n\n \nstatic int ctucan_close(struct net_device *ndev)\n{\n\tstruct ctucan_priv *priv = netdev_priv(ndev);\n\n\tnetif_stop_queue(ndev);\n\tnapi_disable(&priv->napi);\n\tctucan_chip_stop(ndev);\n\tfree_irq(ndev->irq, ndev);\n\tclose_candev(ndev);\n\n\tpm_runtime_put(priv->dev);\n\n\treturn 0;\n}\n\n \nstatic int ctucan_get_berr_counter(const struct net_device *ndev, struct can_berr_counter *bec)\n{\n\tstruct ctucan_priv *priv = netdev_priv(ndev);\n\tint ret;\n\n\tret = pm_runtime_get_sync(priv->dev);\n\tif (ret < 0) {\n\t\tnetdev_err(ndev, \"%s: pm_runtime_get failed(%d)\\n\", __func__, ret);\n\t\tpm_runtime_put_noidle(priv->dev);\n\t\treturn ret;\n\t}\n\n\tctucan_get_rec_tec(priv, bec);\n\tpm_runtime_put(priv->dev);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops ctucan_netdev_ops = {\n\t.ndo_open\t= ctucan_open,\n\t.ndo_stop\t= ctucan_close,\n\t.ndo_start_xmit\t= ctucan_start_xmit,\n\t.ndo_change_mtu\t= can_change_mtu,\n};\n\nstatic const struct ethtool_ops ctucan_ethtool_ops = {\n\t.get_ts_info = ethtool_op_get_ts_info,\n};\n\nint ctucan_suspend(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct ctucan_priv *priv = netdev_priv(ndev);\n\n\tif (netif_running(ndev)) {\n\t\tnetif_stop_queue(ndev);\n\t\tnetif_device_detach(ndev);\n\t}\n\n\tpriv->can.state = CAN_STATE_SLEEPING;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ctucan_suspend);\n\nint ctucan_resume(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct ctucan_priv *priv = netdev_priv(ndev);\n\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\tif (netif_running(ndev)) {\n\t\tnetif_device_attach(ndev);\n\t\tnetif_start_queue(ndev);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ctucan_resume);\n\nint ctucan_probe_common(struct device *dev, void __iomem *addr, int irq, unsigned int ntxbufs,\n\t\t\tunsigned long can_clk_rate, int pm_enable_call,\n\t\t\tvoid (*set_drvdata_fnc)(struct device *dev, struct net_device *ndev))\n{\n\tstruct ctucan_priv *priv;\n\tstruct net_device *ndev;\n\tint ret;\n\n\t \n\tndev = alloc_candev(sizeof(struct ctucan_priv), ntxbufs);\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tpriv = netdev_priv(ndev);\n\tspin_lock_init(&priv->tx_lock);\n\tINIT_LIST_HEAD(&priv->peers_on_pdev);\n\tpriv->ntxbufs = ntxbufs;\n\tpriv->dev = dev;\n\tpriv->can.bittiming_const = &ctu_can_fd_bit_timing_max;\n\tpriv->can.data_bittiming_const = &ctu_can_fd_bit_timing_data_max;\n\tpriv->can.do_set_mode = ctucan_do_set_mode;\n\n\t \n\tpriv->can.do_set_bittiming = ctucan_set_bittiming;\n\tpriv->can.do_set_data_bittiming = ctucan_set_data_bittiming;\n\n\tpriv->can.do_get_berr_counter = ctucan_get_berr_counter;\n\tpriv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK\n\t\t\t\t\t| CAN_CTRLMODE_LISTENONLY\n\t\t\t\t\t| CAN_CTRLMODE_FD\n\t\t\t\t\t| CAN_CTRLMODE_PRESUME_ACK\n\t\t\t\t\t| CAN_CTRLMODE_BERR_REPORTING\n\t\t\t\t\t| CAN_CTRLMODE_FD_NON_ISO\n\t\t\t\t\t| CAN_CTRLMODE_ONE_SHOT;\n\tpriv->mem_base = addr;\n\n\t \n\tndev->irq = irq;\n\tndev->flags |= IFF_ECHO;\t \n\n\tif (set_drvdata_fnc)\n\t\tset_drvdata_fnc(dev, ndev);\n\tSET_NETDEV_DEV(ndev, dev);\n\tndev->netdev_ops = &ctucan_netdev_ops;\n\tndev->ethtool_ops = &ctucan_ethtool_ops;\n\n\t \n\tif (!can_clk_rate) {\n\t\tpriv->can_clk = devm_clk_get(dev, NULL);\n\t\tif (IS_ERR(priv->can_clk)) {\n\t\t\tdev_err(dev, \"Device clock not found.\\n\");\n\t\t\tret = PTR_ERR(priv->can_clk);\n\t\t\tgoto err_free;\n\t\t}\n\t\tcan_clk_rate = clk_get_rate(priv->can_clk);\n\t}\n\n\tpriv->write_reg = ctucan_write32_le;\n\tpriv->read_reg = ctucan_read32_le;\n\n\tif (pm_enable_call)\n\t\tpm_runtime_enable(dev);\n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0) {\n\t\tnetdev_err(ndev, \"%s: pm_runtime_get failed(%d)\\n\",\n\t\t\t   __func__, ret);\n\t\tpm_runtime_put_noidle(priv->dev);\n\t\tgoto err_pmdisable;\n\t}\n\n\t \n\tif ((ctucan_read32(priv, CTUCANFD_DEVICE_ID) & 0xFFFF) != CTUCANFD_ID) {\n\t\tpriv->write_reg = ctucan_write32_be;\n\t\tpriv->read_reg = ctucan_read32_be;\n\t\tif ((ctucan_read32(priv, CTUCANFD_DEVICE_ID) & 0xFFFF) != CTUCANFD_ID) {\n\t\t\tnetdev_err(ndev, \"CTU_CAN_FD signature not found\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_deviceoff;\n\t\t}\n\t}\n\n\tret = ctucan_reset(ndev);\n\tif (ret < 0)\n\t\tgoto err_deviceoff;\n\n\tpriv->can.clock.freq = can_clk_rate;\n\n\tnetif_napi_add(ndev, &priv->napi, ctucan_rx_poll);\n\n\tret = register_candev(ndev);\n\tif (ret) {\n\t\tdev_err(dev, \"fail to register failed (err=%d)\\n\", ret);\n\t\tgoto err_deviceoff;\n\t}\n\n\tpm_runtime_put(dev);\n\n\tnetdev_dbg(ndev, \"mem_base=0x%p irq=%d clock=%d, no. of txt buffers:%d\\n\",\n\t\t   priv->mem_base, ndev->irq, priv->can.clock.freq, priv->ntxbufs);\n\n\treturn 0;\n\nerr_deviceoff:\n\tpm_runtime_put(priv->dev);\nerr_pmdisable:\n\tif (pm_enable_call)\n\t\tpm_runtime_disable(dev);\nerr_free:\n\tlist_del_init(&priv->peers_on_pdev);\n\tfree_candev(ndev);\n\treturn ret;\n}\nEXPORT_SYMBOL(ctucan_probe_common);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Martin Jerabek <martin.jerabek01@gmail.com>\");\nMODULE_AUTHOR(\"Pavel Pisa <pisa@cmp.felk.cvut.cz>\");\nMODULE_AUTHOR(\"Ondrej Ille <ondrej.ille@gmail.com>\");\nMODULE_DESCRIPTION(\"CTU CAN FD interface\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}