{
  "module_name": "rcar_can.c",
  "hash_id": "22e190bc648194dadf0139375a71fc26de360f0dd36e5a5438265b252fcf837c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/rcar/rcar_can.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/errno.h>\n#include <linux/ethtool.h>\n#include <linux/netdevice.h>\n#include <linux/platform_device.h>\n#include <linux/can/dev.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n\n#define RCAR_CAN_DRV_NAME\t\"rcar_can\"\n\n \nenum CLKR {\n\tCLKR_CLKP1 = 0,  \n\tCLKR_CLKP2 = 1,  \n\tCLKR_CLKEXT = 3,  \n};\n\n#define RCAR_SUPPORTED_CLOCKS\t(BIT(CLKR_CLKP1) | BIT(CLKR_CLKP2) | \\\n\t\t\t\t BIT(CLKR_CLKEXT))\n\n \n#define RCAR_CAN_N_MBX\t\t64  \n#define RCAR_CAN_RX_FIFO_MBX\t60  \n#define RCAR_CAN_TX_FIFO_MBX\t56  \n#define RCAR_CAN_FIFO_DEPTH\t4\n\n \nstruct rcar_can_mbox_regs {\n\tu32 id;\t\t \n\tu8 stub;\t \n\tu8 dlc;\t\t \n\tu8 data[8];\t \n\tu8 tsh;\t\t \n\tu8 tsl;\t\t \n};\n\nstruct rcar_can_regs {\n\tstruct rcar_can_mbox_regs mb[RCAR_CAN_N_MBX];  \n\tu32 mkr_2_9[8];\t \n\tu32 fidcr[2];\t \n\tu32 mkivlr1;\t \n\tu32 mier1;\t \n\tu32 mkr_0_1[2];\t \n\tu32 mkivlr0;     \n\tu32 mier0;       \n\tu8 pad_440[0x3c0];\n\tu8 mctl[64];\t \n\tu16 ctlr;\t \n\tu16 str;\t \n\tu8 bcr[3];\t \n\tu8 clkr;\t \n\tu8 rfcr;\t \n\tu8 rfpcr;\t \n\tu8 tfcr;\t \n\tu8 tfpcr;        \n\tu8 eier;\t \n\tu8 eifr;\t \n\tu8 recr;\t \n\tu8 tecr;         \n\tu8 ecsr;\t \n\tu8 cssr;\t \n\tu8 mssr;\t \n\tu8 msmr;\t \n\tu16 tsr;\t \n\tu8 afsr;\t \n\tu8 pad_857;\n\tu8 tcr;\t\t \n\tu8 pad_859[7];\n\tu8 ier;\t\t \n\tu8 isr;\t\t \n\tu8 pad_862;\n\tu8 mbsmr;\t \n};\n\nstruct rcar_can_priv {\n\tstruct can_priv can;\t \n\tstruct net_device *ndev;\n\tstruct napi_struct napi;\n\tstruct rcar_can_regs __iomem *regs;\n\tstruct clk *clk;\n\tstruct clk *can_clk;\n\tu32 tx_head;\n\tu32 tx_tail;\n\tu8 clock_select;\n\tu8 ier;\n};\n\nstatic const struct can_bittiming_const rcar_can_bittiming_const = {\n\t.name = RCAR_CAN_DRV_NAME,\n\t.tseg1_min = 4,\n\t.tseg1_max = 16,\n\t.tseg2_min = 2,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 1024,\n\t.brp_inc = 1,\n};\n\n \n#define RCAR_CAN_CTLR_BOM\t(3 << 11)  \n#define RCAR_CAN_CTLR_BOM_ENT\t(1 << 11)  \n\t\t\t\t\t \n#define RCAR_CAN_CTLR_SLPM\t(1 << 10)\n#define RCAR_CAN_CTLR_CANM\t(3 << 8)  \n#define RCAR_CAN_CTLR_CANM_HALT\t(1 << 9)\n#define RCAR_CAN_CTLR_CANM_RESET (1 << 8)\n#define RCAR_CAN_CTLR_CANM_FORCE_RESET (3 << 8)\n#define RCAR_CAN_CTLR_MLM\t(1 << 3)  \n#define RCAR_CAN_CTLR_IDFM\t(3 << 1)  \n#define RCAR_CAN_CTLR_IDFM_MIXED (1 << 2)  \n#define RCAR_CAN_CTLR_MBM\t(1 << 0)  \n\n \n#define RCAR_CAN_STR_RSTST\t(1 << 8)  \n\n \n#define RCAR_CAN_FIDCR_IDE\t(1 << 31)  \n#define RCAR_CAN_FIDCR_RTR\t(1 << 30)  \n\n \n#define RCAR_CAN_RFCR_RFEST\t(1 << 7)  \n#define RCAR_CAN_RFCR_RFE\t(1 << 0)  \n\n \n#define RCAR_CAN_TFCR_TFUST\t(7 << 1)  \n\t\t\t\t\t \n#define RCAR_CAN_TFCR_TFUST_SHIFT 1\t \n\t\t\t\t\t \n#define RCAR_CAN_TFCR_TFE\t(1 << 0)  \n\n#define RCAR_CAN_N_RX_MKREGS1\t2\t \n\t\t\t\t\t \n#define RCAR_CAN_N_RX_MKREGS2\t8\n\n \n#define RCAR_CAN_BCR_TSEG1(x)\t(((x) & 0x0f) << 20)\n#define RCAR_CAN_BCR_BPR(x)\t(((x) & 0x3ff) << 8)\n#define RCAR_CAN_BCR_SJW(x)\t(((x) & 0x3) << 4)\n#define RCAR_CAN_BCR_TSEG2(x)\t((x) & 0x07)\n\n \n#define RCAR_CAN_IDE\t\t(1 << 31)\n#define RCAR_CAN_RTR\t\t(1 << 30)\n#define RCAR_CAN_SID_SHIFT\t18\n\n \n#define RCAR_CAN_MIER1_RXFIE\t(1 << 28)  \n#define RCAR_CAN_MIER1_TXFIE\t(1 << 24)  \n\n \n#define RCAR_CAN_IER_ERSIE\t(1 << 5)  \n#define RCAR_CAN_IER_RXFIE\t(1 << 4)  \n\t\t\t\t\t \n#define RCAR_CAN_IER_TXFIE\t(1 << 3)  \n\t\t\t\t\t \n \n#define RCAR_CAN_ISR_ERSF\t(1 << 5)  \n#define RCAR_CAN_ISR_RXFF\t(1 << 4)  \n\t\t\t\t\t \n#define RCAR_CAN_ISR_TXFF\t(1 << 3)  \n\t\t\t\t\t \n\n \n#define RCAR_CAN_EIER_BLIE\t(1 << 7)  \n#define RCAR_CAN_EIER_OLIE\t(1 << 6)  \n\t\t\t\t\t \n#define RCAR_CAN_EIER_ORIE\t(1 << 5)  \n#define RCAR_CAN_EIER_BORIE\t(1 << 4)  \n#define RCAR_CAN_EIER_BOEIE\t(1 << 3)  \n#define RCAR_CAN_EIER_EPIE\t(1 << 2)  \n#define RCAR_CAN_EIER_EWIE\t(1 << 1)  \n#define RCAR_CAN_EIER_BEIE\t(1 << 0)  \n\n \n#define RCAR_CAN_EIFR_BLIF\t(1 << 7)  \n#define RCAR_CAN_EIFR_OLIF\t(1 << 6)  \n\t\t\t\t\t  \n#define RCAR_CAN_EIFR_ORIF\t(1 << 5)  \n#define RCAR_CAN_EIFR_BORIF\t(1 << 4)  \n#define RCAR_CAN_EIFR_BOEIF\t(1 << 3)  \n#define RCAR_CAN_EIFR_EPIF\t(1 << 2)  \n#define RCAR_CAN_EIFR_EWIF\t(1 << 1)  \n#define RCAR_CAN_EIFR_BEIF\t(1 << 0)  \n\n \n#define RCAR_CAN_ECSR_EDPM\t(1 << 7)  \n#define RCAR_CAN_ECSR_ADEF\t(1 << 6)  \n#define RCAR_CAN_ECSR_BE0F\t(1 << 5)  \n#define RCAR_CAN_ECSR_BE1F\t(1 << 4)  \n#define RCAR_CAN_ECSR_CEF\t(1 << 3)  \n#define RCAR_CAN_ECSR_AEF\t(1 << 2)  \n#define RCAR_CAN_ECSR_FEF\t(1 << 1)  \n#define RCAR_CAN_ECSR_SEF\t(1 << 0)  \n\n#define RCAR_CAN_NAPI_WEIGHT\t4\n#define MAX_STR_READS\t\t0x100\n\nstatic void tx_failure_cleanup(struct net_device *ndev)\n{\n\tint i;\n\n\tfor (i = 0; i < RCAR_CAN_FIFO_DEPTH; i++)\n\t\tcan_free_echo_skb(ndev, i, NULL);\n}\n\nstatic void rcar_can_error(struct net_device *ndev)\n{\n\tstruct rcar_can_priv *priv = netdev_priv(ndev);\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tu8 eifr, txerr = 0, rxerr = 0;\n\n\t \n\tskb = alloc_can_err_skb(ndev, &cf);\n\n\teifr = readb(&priv->regs->eifr);\n\tif (eifr & (RCAR_CAN_EIFR_EWIF | RCAR_CAN_EIFR_EPIF)) {\n\t\ttxerr = readb(&priv->regs->tecr);\n\t\trxerr = readb(&priv->regs->recr);\n\t\tif (skb)\n\t\t\tcf->can_id |= CAN_ERR_CRTL;\n\t}\n\tif (eifr & RCAR_CAN_EIFR_BEIF) {\n\t\tint rx_errors = 0, tx_errors = 0;\n\t\tu8 ecsr;\n\n\t\tnetdev_dbg(priv->ndev, \"Bus error interrupt:\\n\");\n\t\tif (skb)\n\t\t\tcf->can_id |= CAN_ERR_BUSERROR | CAN_ERR_PROT;\n\n\t\tecsr = readb(&priv->regs->ecsr);\n\t\tif (ecsr & RCAR_CAN_ECSR_ADEF) {\n\t\t\tnetdev_dbg(priv->ndev, \"ACK Delimiter Error\\n\");\n\t\t\ttx_errors++;\n\t\t\twriteb(~RCAR_CAN_ECSR_ADEF, &priv->regs->ecsr);\n\t\t\tif (skb)\n\t\t\t\tcf->data[3] = CAN_ERR_PROT_LOC_ACK_DEL;\n\t\t}\n\t\tif (ecsr & RCAR_CAN_ECSR_BE0F) {\n\t\t\tnetdev_dbg(priv->ndev, \"Bit Error (dominant)\\n\");\n\t\t\ttx_errors++;\n\t\t\twriteb(~RCAR_CAN_ECSR_BE0F, &priv->regs->ecsr);\n\t\t\tif (skb)\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT0;\n\t\t}\n\t\tif (ecsr & RCAR_CAN_ECSR_BE1F) {\n\t\t\tnetdev_dbg(priv->ndev, \"Bit Error (recessive)\\n\");\n\t\t\ttx_errors++;\n\t\t\twriteb(~RCAR_CAN_ECSR_BE1F, &priv->regs->ecsr);\n\t\t\tif (skb)\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT1;\n\t\t}\n\t\tif (ecsr & RCAR_CAN_ECSR_CEF) {\n\t\t\tnetdev_dbg(priv->ndev, \"CRC Error\\n\");\n\t\t\trx_errors++;\n\t\t\twriteb(~RCAR_CAN_ECSR_CEF, &priv->regs->ecsr);\n\t\t\tif (skb)\n\t\t\t\tcf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;\n\t\t}\n\t\tif (ecsr & RCAR_CAN_ECSR_AEF) {\n\t\t\tnetdev_dbg(priv->ndev, \"ACK Error\\n\");\n\t\t\ttx_errors++;\n\t\t\twriteb(~RCAR_CAN_ECSR_AEF, &priv->regs->ecsr);\n\t\t\tif (skb) {\n\t\t\t\tcf->can_id |= CAN_ERR_ACK;\n\t\t\t\tcf->data[3] = CAN_ERR_PROT_LOC_ACK;\n\t\t\t}\n\t\t}\n\t\tif (ecsr & RCAR_CAN_ECSR_FEF) {\n\t\t\tnetdev_dbg(priv->ndev, \"Form Error\\n\");\n\t\t\trx_errors++;\n\t\t\twriteb(~RCAR_CAN_ECSR_FEF, &priv->regs->ecsr);\n\t\t\tif (skb)\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_FORM;\n\t\t}\n\t\tif (ecsr & RCAR_CAN_ECSR_SEF) {\n\t\t\tnetdev_dbg(priv->ndev, \"Stuff Error\\n\");\n\t\t\trx_errors++;\n\t\t\twriteb(~RCAR_CAN_ECSR_SEF, &priv->regs->ecsr);\n\t\t\tif (skb)\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_STUFF;\n\t\t}\n\n\t\tpriv->can.can_stats.bus_error++;\n\t\tndev->stats.rx_errors += rx_errors;\n\t\tndev->stats.tx_errors += tx_errors;\n\t\twriteb(~RCAR_CAN_EIFR_BEIF, &priv->regs->eifr);\n\t}\n\tif (eifr & RCAR_CAN_EIFR_EWIF) {\n\t\tnetdev_dbg(priv->ndev, \"Error warning interrupt\\n\");\n\t\tpriv->can.state = CAN_STATE_ERROR_WARNING;\n\t\tpriv->can.can_stats.error_warning++;\n\t\t \n\t\twriteb(~RCAR_CAN_EIFR_EWIF, &priv->regs->eifr);\n\t\tif (skb)\n\t\t\tcf->data[1] = txerr > rxerr ? CAN_ERR_CRTL_TX_WARNING :\n\t\t\t\t\t      CAN_ERR_CRTL_RX_WARNING;\n\t}\n\tif (eifr & RCAR_CAN_EIFR_EPIF) {\n\t\tnetdev_dbg(priv->ndev, \"Error passive interrupt\\n\");\n\t\tpriv->can.state = CAN_STATE_ERROR_PASSIVE;\n\t\tpriv->can.can_stats.error_passive++;\n\t\t \n\t\twriteb(~RCAR_CAN_EIFR_EPIF, &priv->regs->eifr);\n\t\tif (skb)\n\t\t\tcf->data[1] = txerr > rxerr ? CAN_ERR_CRTL_TX_PASSIVE :\n\t\t\t\t\t      CAN_ERR_CRTL_RX_PASSIVE;\n\t}\n\tif (eifr & RCAR_CAN_EIFR_BOEIF) {\n\t\tnetdev_dbg(priv->ndev, \"Bus-off entry interrupt\\n\");\n\t\ttx_failure_cleanup(ndev);\n\t\tpriv->ier = RCAR_CAN_IER_ERSIE;\n\t\twriteb(priv->ier, &priv->regs->ier);\n\t\tpriv->can.state = CAN_STATE_BUS_OFF;\n\t\t \n\t\twriteb(~RCAR_CAN_EIFR_BOEIF, &priv->regs->eifr);\n\t\tpriv->can.can_stats.bus_off++;\n\t\tcan_bus_off(ndev);\n\t\tif (skb)\n\t\t\tcf->can_id |= CAN_ERR_BUSOFF;\n\t} else if (skb) {\n\t\tcf->can_id |= CAN_ERR_CNT;\n\t\tcf->data[6] = txerr;\n\t\tcf->data[7] = rxerr;\n\t}\n\tif (eifr & RCAR_CAN_EIFR_ORIF) {\n\t\tnetdev_dbg(priv->ndev, \"Receive overrun error interrupt\\n\");\n\t\tndev->stats.rx_over_errors++;\n\t\tndev->stats.rx_errors++;\n\t\twriteb(~RCAR_CAN_EIFR_ORIF, &priv->regs->eifr);\n\t\tif (skb) {\n\t\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\t\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\t\t}\n\t}\n\tif (eifr & RCAR_CAN_EIFR_OLIF) {\n\t\tnetdev_dbg(priv->ndev,\n\t\t\t   \"Overload Frame Transmission error interrupt\\n\");\n\t\tndev->stats.rx_over_errors++;\n\t\tndev->stats.rx_errors++;\n\t\twriteb(~RCAR_CAN_EIFR_OLIF, &priv->regs->eifr);\n\t\tif (skb) {\n\t\t\tcf->can_id |= CAN_ERR_PROT;\n\t\t\tcf->data[2] |= CAN_ERR_PROT_OVERLOAD;\n\t\t}\n\t}\n\n\tif (skb)\n\t\tnetif_rx(skb);\n}\n\nstatic void rcar_can_tx_done(struct net_device *ndev)\n{\n\tstruct rcar_can_priv *priv = netdev_priv(ndev);\n\tstruct net_device_stats *stats = &ndev->stats;\n\tu8 isr;\n\n\twhile (1) {\n\t\tu8 unsent = readb(&priv->regs->tfcr);\n\n\t\tunsent = (unsent & RCAR_CAN_TFCR_TFUST) >>\n\t\t\t  RCAR_CAN_TFCR_TFUST_SHIFT;\n\t\tif (priv->tx_head - priv->tx_tail <= unsent)\n\t\t\tbreak;\n\t\tstats->tx_packets++;\n\t\tstats->tx_bytes +=\n\t\t\tcan_get_echo_skb(ndev,\n\t\t\t\t\t priv->tx_tail % RCAR_CAN_FIFO_DEPTH,\n\t\t\t\t\t NULL);\n\n\t\tpriv->tx_tail++;\n\t\tnetif_wake_queue(ndev);\n\t}\n\t \n\tisr = readb(&priv->regs->isr);\n\twriteb(isr & ~RCAR_CAN_ISR_TXFF, &priv->regs->isr);\n}\n\nstatic irqreturn_t rcar_can_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *ndev = dev_id;\n\tstruct rcar_can_priv *priv = netdev_priv(ndev);\n\tu8 isr;\n\n\tisr = readb(&priv->regs->isr);\n\tif (!(isr & priv->ier))\n\t\treturn IRQ_NONE;\n\n\tif (isr & RCAR_CAN_ISR_ERSF)\n\t\trcar_can_error(ndev);\n\n\tif (isr & RCAR_CAN_ISR_TXFF)\n\t\trcar_can_tx_done(ndev);\n\n\tif (isr & RCAR_CAN_ISR_RXFF) {\n\t\tif (napi_schedule_prep(&priv->napi)) {\n\t\t\t \n\t\t\tpriv->ier &= ~RCAR_CAN_IER_RXFIE;\n\t\t\twriteb(priv->ier, &priv->regs->ier);\n\t\t\t__napi_schedule(&priv->napi);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void rcar_can_set_bittiming(struct net_device *dev)\n{\n\tstruct rcar_can_priv *priv = netdev_priv(dev);\n\tstruct can_bittiming *bt = &priv->can.bittiming;\n\tu32 bcr;\n\n\tbcr = RCAR_CAN_BCR_TSEG1(bt->phase_seg1 + bt->prop_seg - 1) |\n\t      RCAR_CAN_BCR_BPR(bt->brp - 1) | RCAR_CAN_BCR_SJW(bt->sjw - 1) |\n\t      RCAR_CAN_BCR_TSEG2(bt->phase_seg2 - 1);\n\t \n\twritel((bcr << 8) | priv->clock_select, &priv->regs->bcr);\n}\n\nstatic void rcar_can_start(struct net_device *ndev)\n{\n\tstruct rcar_can_priv *priv = netdev_priv(ndev);\n\tu16 ctlr;\n\tint i;\n\n\t \n\tctlr = readw(&priv->regs->ctlr);\n\tctlr &= ~RCAR_CAN_CTLR_SLPM;\n\twritew(ctlr, &priv->regs->ctlr);\n\t \n\tctlr |= RCAR_CAN_CTLR_CANM_FORCE_RESET;\n\twritew(ctlr, &priv->regs->ctlr);\n\tfor (i = 0; i < MAX_STR_READS; i++) {\n\t\tif (readw(&priv->regs->str) & RCAR_CAN_STR_RSTST)\n\t\t\tbreak;\n\t}\n\trcar_can_set_bittiming(ndev);\n\tctlr |= RCAR_CAN_CTLR_IDFM_MIXED;  \n\tctlr |= RCAR_CAN_CTLR_BOM_ENT;\t \n\t\t\t\t\t \n\tctlr |= RCAR_CAN_CTLR_MBM;\t \n\tctlr |= RCAR_CAN_CTLR_MLM;\t \n\twritew(ctlr, &priv->regs->ctlr);\n\n\t \n\twritel(0, &priv->regs->mkr_2_9[6]);\n\twritel(0, &priv->regs->mkr_2_9[7]);\n\t \n\twritel(0, &priv->regs->mkivlr1);\n\t \n\twritel(0, &priv->regs->fidcr[0]);\n\twritel(RCAR_CAN_FIDCR_IDE | RCAR_CAN_FIDCR_RTR, &priv->regs->fidcr[1]);\n\t \n\twritel(RCAR_CAN_MIER1_RXFIE | RCAR_CAN_MIER1_TXFIE, &priv->regs->mier1);\n\n\tpriv->ier = RCAR_CAN_IER_ERSIE | RCAR_CAN_IER_RXFIE |\n\t\t    RCAR_CAN_IER_TXFIE;\n\twriteb(priv->ier, &priv->regs->ier);\n\n\t \n\twriteb(RCAR_CAN_ECSR_EDPM, &priv->regs->ecsr);\n\t \n\twriteb(RCAR_CAN_EIER_EWIE | RCAR_CAN_EIER_EPIE | RCAR_CAN_EIER_BOEIE |\n\t       (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING ?\n\t       RCAR_CAN_EIER_BEIE : 0) | RCAR_CAN_EIER_ORIE |\n\t       RCAR_CAN_EIER_OLIE, &priv->regs->eier);\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\t \n\twritew(ctlr & ~RCAR_CAN_CTLR_CANM, &priv->regs->ctlr);\n\tfor (i = 0; i < MAX_STR_READS; i++) {\n\t\tif (!(readw(&priv->regs->str) & RCAR_CAN_STR_RSTST))\n\t\t\tbreak;\n\t}\n\t \n\twriteb(RCAR_CAN_RFCR_RFE, &priv->regs->rfcr);\n\twriteb(RCAR_CAN_TFCR_TFE, &priv->regs->tfcr);\n}\n\nstatic int rcar_can_open(struct net_device *ndev)\n{\n\tstruct rcar_can_priv *priv = netdev_priv(ndev);\n\tint err;\n\n\terr = clk_prepare_enable(priv->clk);\n\tif (err) {\n\t\tnetdev_err(ndev,\n\t\t\t   \"failed to enable peripheral clock, error %d\\n\",\n\t\t\t   err);\n\t\tgoto out;\n\t}\n\terr = clk_prepare_enable(priv->can_clk);\n\tif (err) {\n\t\tnetdev_err(ndev, \"failed to enable CAN clock, error %d\\n\",\n\t\t\t   err);\n\t\tgoto out_clock;\n\t}\n\terr = open_candev(ndev);\n\tif (err) {\n\t\tnetdev_err(ndev, \"open_candev() failed, error %d\\n\", err);\n\t\tgoto out_can_clock;\n\t}\n\tnapi_enable(&priv->napi);\n\terr = request_irq(ndev->irq, rcar_can_interrupt, 0, ndev->name, ndev);\n\tif (err) {\n\t\tnetdev_err(ndev, \"request_irq(%d) failed, error %d\\n\",\n\t\t\t   ndev->irq, err);\n\t\tgoto out_close;\n\t}\n\trcar_can_start(ndev);\n\tnetif_start_queue(ndev);\n\treturn 0;\nout_close:\n\tnapi_disable(&priv->napi);\n\tclose_candev(ndev);\nout_can_clock:\n\tclk_disable_unprepare(priv->can_clk);\nout_clock:\n\tclk_disable_unprepare(priv->clk);\nout:\n\treturn err;\n}\n\nstatic void rcar_can_stop(struct net_device *ndev)\n{\n\tstruct rcar_can_priv *priv = netdev_priv(ndev);\n\tu16 ctlr;\n\tint i;\n\n\t \n\tctlr = readw(&priv->regs->ctlr);\n\tctlr |= RCAR_CAN_CTLR_CANM_FORCE_RESET;\n\twritew(ctlr, &priv->regs->ctlr);\n\tfor (i = 0; i < MAX_STR_READS; i++) {\n\t\tif (readw(&priv->regs->str) & RCAR_CAN_STR_RSTST)\n\t\t\tbreak;\n\t}\n\twritel(0, &priv->regs->mier0);\n\twritel(0, &priv->regs->mier1);\n\twriteb(0, &priv->regs->ier);\n\twriteb(0, &priv->regs->eier);\n\t \n\tctlr |= RCAR_CAN_CTLR_SLPM;\n\twritew(ctlr, &priv->regs->ctlr);\n\tpriv->can.state = CAN_STATE_STOPPED;\n}\n\nstatic int rcar_can_close(struct net_device *ndev)\n{\n\tstruct rcar_can_priv *priv = netdev_priv(ndev);\n\n\tnetif_stop_queue(ndev);\n\trcar_can_stop(ndev);\n\tfree_irq(ndev->irq, ndev);\n\tnapi_disable(&priv->napi);\n\tclk_disable_unprepare(priv->can_clk);\n\tclk_disable_unprepare(priv->clk);\n\tclose_candev(ndev);\n\treturn 0;\n}\n\nstatic netdev_tx_t rcar_can_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *ndev)\n{\n\tstruct rcar_can_priv *priv = netdev_priv(ndev);\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tu32 data, i;\n\n\tif (can_dev_dropped_skb(ndev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tif (cf->can_id & CAN_EFF_FLAG)\t \n\t\tdata = (cf->can_id & CAN_EFF_MASK) | RCAR_CAN_IDE;\n\telse\t\t\t\t \n\t\tdata = (cf->can_id & CAN_SFF_MASK) << RCAR_CAN_SID_SHIFT;\n\n\tif (cf->can_id & CAN_RTR_FLAG) {  \n\t\tdata |= RCAR_CAN_RTR;\n\t} else {\n\t\tfor (i = 0; i < cf->len; i++)\n\t\t\twriteb(cf->data[i],\n\t\t\t       &priv->regs->mb[RCAR_CAN_TX_FIFO_MBX].data[i]);\n\t}\n\n\twritel(data, &priv->regs->mb[RCAR_CAN_TX_FIFO_MBX].id);\n\n\twriteb(cf->len, &priv->regs->mb[RCAR_CAN_TX_FIFO_MBX].dlc);\n\n\tcan_put_echo_skb(skb, ndev, priv->tx_head % RCAR_CAN_FIFO_DEPTH, 0);\n\tpriv->tx_head++;\n\t \n\twriteb(0xff, &priv->regs->tfpcr);\n\t \n\tif (priv->tx_head - priv->tx_tail >= RCAR_CAN_FIFO_DEPTH)\n\t\tnetif_stop_queue(ndev);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic const struct net_device_ops rcar_can_netdev_ops = {\n\t.ndo_open = rcar_can_open,\n\t.ndo_stop = rcar_can_close,\n\t.ndo_start_xmit = rcar_can_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic const struct ethtool_ops rcar_can_ethtool_ops = {\n\t.get_ts_info = ethtool_op_get_ts_info,\n};\n\nstatic void rcar_can_rx_pkt(struct rcar_can_priv *priv)\n{\n\tstruct net_device_stats *stats = &priv->ndev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tu32 data;\n\tu8 dlc;\n\n\tskb = alloc_can_skb(priv->ndev, &cf);\n\tif (!skb) {\n\t\tstats->rx_dropped++;\n\t\treturn;\n\t}\n\n\tdata = readl(&priv->regs->mb[RCAR_CAN_RX_FIFO_MBX].id);\n\tif (data & RCAR_CAN_IDE)\n\t\tcf->can_id = (data & CAN_EFF_MASK) | CAN_EFF_FLAG;\n\telse\n\t\tcf->can_id = (data >> RCAR_CAN_SID_SHIFT) & CAN_SFF_MASK;\n\n\tdlc = readb(&priv->regs->mb[RCAR_CAN_RX_FIFO_MBX].dlc);\n\tcf->len = can_cc_dlc2len(dlc);\n\tif (data & RCAR_CAN_RTR) {\n\t\tcf->can_id |= CAN_RTR_FLAG;\n\t} else {\n\t\tfor (dlc = 0; dlc < cf->len; dlc++)\n\t\t\tcf->data[dlc] =\n\t\t\treadb(&priv->regs->mb[RCAR_CAN_RX_FIFO_MBX].data[dlc]);\n\n\t\tstats->rx_bytes += cf->len;\n\t}\n\tstats->rx_packets++;\n\n\tnetif_receive_skb(skb);\n}\n\nstatic int rcar_can_rx_poll(struct napi_struct *napi, int quota)\n{\n\tstruct rcar_can_priv *priv = container_of(napi,\n\t\t\t\t\t\t  struct rcar_can_priv, napi);\n\tint num_pkts;\n\n\tfor (num_pkts = 0; num_pkts < quota; num_pkts++) {\n\t\tu8 rfcr, isr;\n\n\t\tisr = readb(&priv->regs->isr);\n\t\t \n\t\tif (isr & RCAR_CAN_ISR_RXFF)\n\t\t\twriteb(isr & ~RCAR_CAN_ISR_RXFF, &priv->regs->isr);\n\t\trfcr = readb(&priv->regs->rfcr);\n\t\tif (rfcr & RCAR_CAN_RFCR_RFEST)\n\t\t\tbreak;\n\t\trcar_can_rx_pkt(priv);\n\t\t \n\t\twriteb(0xff, &priv->regs->rfpcr);\n\t}\n\t \n\tif (num_pkts < quota) {\n\t\tnapi_complete_done(napi, num_pkts);\n\t\tpriv->ier |= RCAR_CAN_IER_RXFIE;\n\t\twriteb(priv->ier, &priv->regs->ier);\n\t}\n\treturn num_pkts;\n}\n\nstatic int rcar_can_do_set_mode(struct net_device *ndev, enum can_mode mode)\n{\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\trcar_can_start(ndev);\n\t\tnetif_wake_queue(ndev);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int rcar_can_get_berr_counter(const struct net_device *dev,\n\t\t\t\t     struct can_berr_counter *bec)\n{\n\tstruct rcar_can_priv *priv = netdev_priv(dev);\n\tint err;\n\n\terr = clk_prepare_enable(priv->clk);\n\tif (err)\n\t\treturn err;\n\tbec->txerr = readb(&priv->regs->tecr);\n\tbec->rxerr = readb(&priv->regs->recr);\n\tclk_disable_unprepare(priv->clk);\n\treturn 0;\n}\n\nstatic const char * const clock_names[] = {\n\t[CLKR_CLKP1]\t= \"clkp1\",\n\t[CLKR_CLKP2]\t= \"clkp2\",\n\t[CLKR_CLKEXT]\t= \"can_clk\",\n};\n\nstatic int rcar_can_probe(struct platform_device *pdev)\n{\n\tstruct rcar_can_priv *priv;\n\tstruct net_device *ndev;\n\tvoid __iomem *addr;\n\tu32 clock_select = CLKR_CLKP1;\n\tint err = -ENODEV;\n\tint irq;\n\n\tof_property_read_u32(pdev->dev.of_node, \"renesas,can-clock-select\",\n\t\t\t     &clock_select);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\terr = irq;\n\t\tgoto fail;\n\t}\n\n\taddr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(addr)) {\n\t\terr = PTR_ERR(addr);\n\t\tgoto fail;\n\t}\n\n\tndev = alloc_candev(sizeof(struct rcar_can_priv), RCAR_CAN_FIFO_DEPTH);\n\tif (!ndev) {\n\t\tdev_err(&pdev->dev, \"alloc_candev() failed\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tpriv = netdev_priv(ndev);\n\n\tpriv->clk = devm_clk_get(&pdev->dev, \"clkp1\");\n\tif (IS_ERR(priv->clk)) {\n\t\terr = PTR_ERR(priv->clk);\n\t\tdev_err(&pdev->dev, \"cannot get peripheral clock, error %d\\n\",\n\t\t\terr);\n\t\tgoto fail_clk;\n\t}\n\n\tif (!(BIT(clock_select) & RCAR_SUPPORTED_CLOCKS)) {\n\t\terr = -EINVAL;\n\t\tdev_err(&pdev->dev, \"invalid CAN clock selected\\n\");\n\t\tgoto fail_clk;\n\t}\n\tpriv->can_clk = devm_clk_get(&pdev->dev, clock_names[clock_select]);\n\tif (IS_ERR(priv->can_clk)) {\n\t\terr = PTR_ERR(priv->can_clk);\n\t\tdev_err(&pdev->dev, \"cannot get CAN clock, error %d\\n\", err);\n\t\tgoto fail_clk;\n\t}\n\n\tndev->netdev_ops = &rcar_can_netdev_ops;\n\tndev->ethtool_ops = &rcar_can_ethtool_ops;\n\tndev->irq = irq;\n\tndev->flags |= IFF_ECHO;\n\tpriv->ndev = ndev;\n\tpriv->regs = addr;\n\tpriv->clock_select = clock_select;\n\tpriv->can.clock.freq = clk_get_rate(priv->can_clk);\n\tpriv->can.bittiming_const = &rcar_can_bittiming_const;\n\tpriv->can.do_set_mode = rcar_can_do_set_mode;\n\tpriv->can.do_get_berr_counter = rcar_can_get_berr_counter;\n\tpriv->can.ctrlmode_supported = CAN_CTRLMODE_BERR_REPORTING;\n\tplatform_set_drvdata(pdev, ndev);\n\tSET_NETDEV_DEV(ndev, &pdev->dev);\n\n\tnetif_napi_add_weight(ndev, &priv->napi, rcar_can_rx_poll,\n\t\t\t      RCAR_CAN_NAPI_WEIGHT);\n\terr = register_candev(ndev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"register_candev() failed, error %d\\n\",\n\t\t\terr);\n\t\tgoto fail_candev;\n\t}\n\n\tdev_info(&pdev->dev, \"device registered (IRQ%d)\\n\", ndev->irq);\n\n\treturn 0;\nfail_candev:\n\tnetif_napi_del(&priv->napi);\nfail_clk:\n\tfree_candev(ndev);\nfail:\n\treturn err;\n}\n\nstatic void rcar_can_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct rcar_can_priv *priv = netdev_priv(ndev);\n\n\tunregister_candev(ndev);\n\tnetif_napi_del(&priv->napi);\n\tfree_candev(ndev);\n}\n\nstatic int __maybe_unused rcar_can_suspend(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct rcar_can_priv *priv = netdev_priv(ndev);\n\tu16 ctlr;\n\n\tif (!netif_running(ndev))\n\t\treturn 0;\n\n\tnetif_stop_queue(ndev);\n\tnetif_device_detach(ndev);\n\n\tctlr = readw(&priv->regs->ctlr);\n\tctlr |= RCAR_CAN_CTLR_CANM_HALT;\n\twritew(ctlr, &priv->regs->ctlr);\n\tctlr |= RCAR_CAN_CTLR_SLPM;\n\twritew(ctlr, &priv->regs->ctlr);\n\tpriv->can.state = CAN_STATE_SLEEPING;\n\n\tclk_disable(priv->clk);\n\treturn 0;\n}\n\nstatic int __maybe_unused rcar_can_resume(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct rcar_can_priv *priv = netdev_priv(ndev);\n\tu16 ctlr;\n\tint err;\n\n\tif (!netif_running(ndev))\n\t\treturn 0;\n\n\terr = clk_enable(priv->clk);\n\tif (err) {\n\t\tnetdev_err(ndev, \"clk_enable() failed, error %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tctlr = readw(&priv->regs->ctlr);\n\tctlr &= ~RCAR_CAN_CTLR_SLPM;\n\twritew(ctlr, &priv->regs->ctlr);\n\tctlr &= ~RCAR_CAN_CTLR_CANM;\n\twritew(ctlr, &priv->regs->ctlr);\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\tnetif_device_attach(ndev);\n\tnetif_start_queue(ndev);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(rcar_can_pm_ops, rcar_can_suspend, rcar_can_resume);\n\nstatic const struct of_device_id rcar_can_of_table[] __maybe_unused = {\n\t{ .compatible = \"renesas,can-r8a7778\" },\n\t{ .compatible = \"renesas,can-r8a7779\" },\n\t{ .compatible = \"renesas,can-r8a7790\" },\n\t{ .compatible = \"renesas,can-r8a7791\" },\n\t{ .compatible = \"renesas,rcar-gen1-can\" },\n\t{ .compatible = \"renesas,rcar-gen2-can\" },\n\t{ .compatible = \"renesas,rcar-gen3-can\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, rcar_can_of_table);\n\nstatic struct platform_driver rcar_can_driver = {\n\t.driver = {\n\t\t.name = RCAR_CAN_DRV_NAME,\n\t\t.of_match_table = of_match_ptr(rcar_can_of_table),\n\t\t.pm = &rcar_can_pm_ops,\n\t},\n\t.probe = rcar_can_probe,\n\t.remove_new = rcar_can_remove,\n};\n\nmodule_platform_driver(rcar_can_driver);\n\nMODULE_AUTHOR(\"Cogent Embedded, Inc.\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"CAN driver for Renesas R-Car SoC\");\nMODULE_ALIAS(\"platform:\" RCAR_CAN_DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}