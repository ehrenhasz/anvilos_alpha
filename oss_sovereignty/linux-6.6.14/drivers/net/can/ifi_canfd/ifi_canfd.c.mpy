{
  "module_name": "ifi_canfd.c",
  "hash_id": "248f9fc50581205dafd083029b7d2f48e940cff0fe649043adf7914809e6b6c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/ifi_canfd/ifi_canfd.c",
  "human_readable_source": " \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/ethtool.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <linux/can/dev.h>\n\n#define IFI_CANFD_STCMD\t\t\t\t0x0\n#define IFI_CANFD_STCMD_HARDRESET\t\t0xDEADCAFD\n#define IFI_CANFD_STCMD_ENABLE\t\t\tBIT(0)\n#define IFI_CANFD_STCMD_ERROR_ACTIVE\t\tBIT(2)\n#define IFI_CANFD_STCMD_ERROR_PASSIVE\t\tBIT(3)\n#define IFI_CANFD_STCMD_BUSOFF\t\t\tBIT(4)\n#define IFI_CANFD_STCMD_ERROR_WARNING\t\tBIT(5)\n#define IFI_CANFD_STCMD_BUSMONITOR\t\tBIT(16)\n#define IFI_CANFD_STCMD_LOOPBACK\t\tBIT(18)\n#define IFI_CANFD_STCMD_DISABLE_CANFD\t\tBIT(24)\n#define IFI_CANFD_STCMD_ENABLE_ISO\t\tBIT(25)\n#define IFI_CANFD_STCMD_ENABLE_7_9_8_8_TIMING\tBIT(26)\n#define IFI_CANFD_STCMD_NORMAL_MODE\t\t((u32)BIT(31))\n\n#define IFI_CANFD_RXSTCMD\t\t\t0x4\n#define IFI_CANFD_RXSTCMD_REMOVE_MSG\t\tBIT(0)\n#define IFI_CANFD_RXSTCMD_RESET\t\t\tBIT(7)\n#define IFI_CANFD_RXSTCMD_EMPTY\t\t\tBIT(8)\n#define IFI_CANFD_RXSTCMD_OVERFLOW\t\tBIT(13)\n\n#define IFI_CANFD_TXSTCMD\t\t\t0x8\n#define IFI_CANFD_TXSTCMD_ADD_MSG\t\tBIT(0)\n#define IFI_CANFD_TXSTCMD_HIGH_PRIO\t\tBIT(1)\n#define IFI_CANFD_TXSTCMD_RESET\t\t\tBIT(7)\n#define IFI_CANFD_TXSTCMD_EMPTY\t\t\tBIT(8)\n#define IFI_CANFD_TXSTCMD_FULL\t\t\tBIT(12)\n#define IFI_CANFD_TXSTCMD_OVERFLOW\t\tBIT(13)\n\n#define IFI_CANFD_INTERRUPT\t\t\t0xc\n#define IFI_CANFD_INTERRUPT_ERROR_BUSOFF\tBIT(0)\n#define IFI_CANFD_INTERRUPT_ERROR_WARNING\tBIT(1)\n#define IFI_CANFD_INTERRUPT_ERROR_STATE_CHG\tBIT(2)\n#define IFI_CANFD_INTERRUPT_ERROR_REC_TEC_INC\tBIT(3)\n#define IFI_CANFD_INTERRUPT_ERROR_COUNTER\tBIT(10)\n#define IFI_CANFD_INTERRUPT_TXFIFO_EMPTY\tBIT(16)\n#define IFI_CANFD_INTERRUPT_TXFIFO_REMOVE\tBIT(22)\n#define IFI_CANFD_INTERRUPT_RXFIFO_NEMPTY\tBIT(24)\n#define IFI_CANFD_INTERRUPT_RXFIFO_NEMPTY_PER\tBIT(25)\n#define IFI_CANFD_INTERRUPT_SET_IRQ\t\t((u32)BIT(31))\n\n#define IFI_CANFD_IRQMASK\t\t\t0x10\n#define IFI_CANFD_IRQMASK_ERROR_BUSOFF\t\tBIT(0)\n#define IFI_CANFD_IRQMASK_ERROR_WARNING\t\tBIT(1)\n#define IFI_CANFD_IRQMASK_ERROR_STATE_CHG\tBIT(2)\n#define IFI_CANFD_IRQMASK_ERROR_REC_TEC_INC\tBIT(3)\n#define IFI_CANFD_IRQMASK_SET_ERR\t\tBIT(7)\n#define IFI_CANFD_IRQMASK_SET_TS\t\tBIT(15)\n#define IFI_CANFD_IRQMASK_TXFIFO_EMPTY\t\tBIT(16)\n#define IFI_CANFD_IRQMASK_SET_TX\t\tBIT(23)\n#define IFI_CANFD_IRQMASK_RXFIFO_NEMPTY\t\tBIT(24)\n#define IFI_CANFD_IRQMASK_SET_RX\t\t((u32)BIT(31))\n\n#define IFI_CANFD_TIME\t\t\t\t0x14\n#define IFI_CANFD_FTIME\t\t\t\t0x18\n#define IFI_CANFD_TIME_TIMEB_OFF\t\t0\n#define IFI_CANFD_TIME_TIMEA_OFF\t\t8\n#define IFI_CANFD_TIME_PRESCALE_OFF\t\t16\n#define IFI_CANFD_TIME_SJW_OFF_7_9_8_8\t\t25\n#define IFI_CANFD_TIME_SJW_OFF_4_12_6_6\t\t28\n#define IFI_CANFD_TIME_SET_SJW_4_12_6_6\t\tBIT(6)\n#define IFI_CANFD_TIME_SET_TIMEB_4_12_6_6\tBIT(7)\n#define IFI_CANFD_TIME_SET_PRESC_4_12_6_6\tBIT(14)\n#define IFI_CANFD_TIME_SET_TIMEA_4_12_6_6\tBIT(15)\n\n#define IFI_CANFD_TDELAY\t\t\t0x1c\n#define IFI_CANFD_TDELAY_DEFAULT\t\t0xb\n#define IFI_CANFD_TDELAY_MASK\t\t\t0x3fff\n#define IFI_CANFD_TDELAY_ABS\t\t\tBIT(14)\n#define IFI_CANFD_TDELAY_EN\t\t\tBIT(15)\n\n#define IFI_CANFD_ERROR\t\t\t\t0x20\n#define IFI_CANFD_ERROR_TX_OFFSET\t\t0\n#define IFI_CANFD_ERROR_TX_MASK\t\t\t0xff\n#define IFI_CANFD_ERROR_RX_OFFSET\t\t16\n#define IFI_CANFD_ERROR_RX_MASK\t\t\t0xff\n\n#define IFI_CANFD_ERRCNT\t\t\t0x24\n\n#define IFI_CANFD_SUSPEND\t\t\t0x28\n\n#define IFI_CANFD_REPEAT\t\t\t0x2c\n\n#define IFI_CANFD_TRAFFIC\t\t\t0x30\n\n#define IFI_CANFD_TSCONTROL\t\t\t0x34\n\n#define IFI_CANFD_TSC\t\t\t\t0x38\n\n#define IFI_CANFD_TST\t\t\t\t0x3c\n\n#define IFI_CANFD_RES1\t\t\t\t0x40\n\n#define IFI_CANFD_ERROR_CTR\t\t\t0x44\n#define IFI_CANFD_ERROR_CTR_UNLOCK_MAGIC\t0x21302899\n#define IFI_CANFD_ERROR_CTR_OVERLOAD_FIRST\tBIT(0)\n#define IFI_CANFD_ERROR_CTR_ACK_ERROR_FIRST\tBIT(1)\n#define IFI_CANFD_ERROR_CTR_BIT0_ERROR_FIRST\tBIT(2)\n#define IFI_CANFD_ERROR_CTR_BIT1_ERROR_FIRST\tBIT(3)\n#define IFI_CANFD_ERROR_CTR_STUFF_ERROR_FIRST\tBIT(4)\n#define IFI_CANFD_ERROR_CTR_CRC_ERROR_FIRST\tBIT(5)\n#define IFI_CANFD_ERROR_CTR_FORM_ERROR_FIRST\tBIT(6)\n#define IFI_CANFD_ERROR_CTR_OVERLOAD_ALL\tBIT(8)\n#define IFI_CANFD_ERROR_CTR_ACK_ERROR_ALL\tBIT(9)\n#define IFI_CANFD_ERROR_CTR_BIT0_ERROR_ALL\tBIT(10)\n#define IFI_CANFD_ERROR_CTR_BIT1_ERROR_ALL\tBIT(11)\n#define IFI_CANFD_ERROR_CTR_STUFF_ERROR_ALL\tBIT(12)\n#define IFI_CANFD_ERROR_CTR_CRC_ERROR_ALL\tBIT(13)\n#define IFI_CANFD_ERROR_CTR_FORM_ERROR_ALL\tBIT(14)\n#define IFI_CANFD_ERROR_CTR_BITPOSITION_OFFSET\t16\n#define IFI_CANFD_ERROR_CTR_BITPOSITION_MASK\t0xff\n#define IFI_CANFD_ERROR_CTR_ER_RESET\t\tBIT(30)\n#define IFI_CANFD_ERROR_CTR_ER_ENABLE\t\t((u32)BIT(31))\n\n#define IFI_CANFD_PAR\t\t\t\t0x48\n\n#define IFI_CANFD_CANCLOCK\t\t\t0x4c\n\n#define IFI_CANFD_SYSCLOCK\t\t\t0x50\n\n#define IFI_CANFD_VER\t\t\t\t0x54\n#define IFI_CANFD_VER_REV_MASK\t\t\t0xff\n#define IFI_CANFD_VER_REV_MIN_SUPPORTED\t\t0x15\n\n#define IFI_CANFD_IP_ID\t\t\t\t0x58\n#define IFI_CANFD_IP_ID_VALUE\t\t\t0xD073CAFD\n\n#define IFI_CANFD_TEST\t\t\t\t0x5c\n\n#define IFI_CANFD_RXFIFO_TS_63_32\t\t0x60\n\n#define IFI_CANFD_RXFIFO_TS_31_0\t\t0x64\n\n#define IFI_CANFD_RXFIFO_DLC\t\t\t0x68\n#define IFI_CANFD_RXFIFO_DLC_DLC_OFFSET\t\t0\n#define IFI_CANFD_RXFIFO_DLC_DLC_MASK\t\t0xf\n#define IFI_CANFD_RXFIFO_DLC_RTR\t\tBIT(4)\n#define IFI_CANFD_RXFIFO_DLC_EDL\t\tBIT(5)\n#define IFI_CANFD_RXFIFO_DLC_BRS\t\tBIT(6)\n#define IFI_CANFD_RXFIFO_DLC_ESI\t\tBIT(7)\n#define IFI_CANFD_RXFIFO_DLC_OBJ_OFFSET\t\t8\n#define IFI_CANFD_RXFIFO_DLC_OBJ_MASK\t\t0x1ff\n#define IFI_CANFD_RXFIFO_DLC_FNR_OFFSET\t\t24\n#define IFI_CANFD_RXFIFO_DLC_FNR_MASK\t\t0xff\n\n#define IFI_CANFD_RXFIFO_ID\t\t\t0x6c\n#define IFI_CANFD_RXFIFO_ID_ID_OFFSET\t\t0\n#define IFI_CANFD_RXFIFO_ID_ID_STD_MASK\t\tCAN_SFF_MASK\n#define IFI_CANFD_RXFIFO_ID_ID_STD_OFFSET\t0\n#define IFI_CANFD_RXFIFO_ID_ID_STD_WIDTH\t10\n#define IFI_CANFD_RXFIFO_ID_ID_XTD_MASK\t\tCAN_EFF_MASK\n#define IFI_CANFD_RXFIFO_ID_ID_XTD_OFFSET\t11\n#define IFI_CANFD_RXFIFO_ID_ID_XTD_WIDTH\t18\n#define IFI_CANFD_RXFIFO_ID_IDE\t\t\tBIT(29)\n\n#define IFI_CANFD_RXFIFO_DATA\t\t\t0x70\t \n\n#define IFI_CANFD_TXFIFO_SUSPEND_US\t\t0xb0\n\n#define IFI_CANFD_TXFIFO_REPEATCOUNT\t\t0xb4\n\n#define IFI_CANFD_TXFIFO_DLC\t\t\t0xb8\n#define IFI_CANFD_TXFIFO_DLC_DLC_OFFSET\t\t0\n#define IFI_CANFD_TXFIFO_DLC_DLC_MASK\t\t0xf\n#define IFI_CANFD_TXFIFO_DLC_RTR\t\tBIT(4)\n#define IFI_CANFD_TXFIFO_DLC_EDL\t\tBIT(5)\n#define IFI_CANFD_TXFIFO_DLC_BRS\t\tBIT(6)\n#define IFI_CANFD_TXFIFO_DLC_FNR_OFFSET\t\t24\n#define IFI_CANFD_TXFIFO_DLC_FNR_MASK\t\t0xff\n\n#define IFI_CANFD_TXFIFO_ID\t\t\t0xbc\n#define IFI_CANFD_TXFIFO_ID_ID_OFFSET\t\t0\n#define IFI_CANFD_TXFIFO_ID_ID_STD_MASK\t\tCAN_SFF_MASK\n#define IFI_CANFD_TXFIFO_ID_ID_STD_OFFSET\t0\n#define IFI_CANFD_TXFIFO_ID_ID_STD_WIDTH\t10\n#define IFI_CANFD_TXFIFO_ID_ID_XTD_MASK\t\tCAN_EFF_MASK\n#define IFI_CANFD_TXFIFO_ID_ID_XTD_OFFSET\t11\n#define IFI_CANFD_TXFIFO_ID_ID_XTD_WIDTH\t18\n#define IFI_CANFD_TXFIFO_ID_IDE\t\t\tBIT(29)\n\n#define IFI_CANFD_TXFIFO_DATA\t\t\t0xc0\t \n\n#define IFI_CANFD_FILTER_MASK(n)\t\t(0x800 + ((n) * 8) + 0)\n#define IFI_CANFD_FILTER_MASK_EXT\t\tBIT(29)\n#define IFI_CANFD_FILTER_MASK_EDL\t\tBIT(30)\n#define IFI_CANFD_FILTER_MASK_VALID\t\t((u32)BIT(31))\n\n#define IFI_CANFD_FILTER_IDENT(n)\t\t(0x800 + ((n) * 8) + 4)\n#define IFI_CANFD_FILTER_IDENT_IDE\t\tBIT(29)\n#define IFI_CANFD_FILTER_IDENT_CANFD\t\tBIT(30)\n#define IFI_CANFD_FILTER_IDENT_VALID\t\t((u32)BIT(31))\n\n \nstruct ifi_canfd_priv {\n\tstruct can_priv\t\tcan;\t \n\tstruct napi_struct\tnapi;\n\tstruct net_device\t*ndev;\n\tvoid __iomem\t\t*base;\n};\n\nstatic void ifi_canfd_irq_enable(struct net_device *ndev, bool enable)\n{\n\tstruct ifi_canfd_priv *priv = netdev_priv(ndev);\n\tu32 enirq = 0;\n\n\tif (enable) {\n\t\tenirq = IFI_CANFD_IRQMASK_TXFIFO_EMPTY |\n\t\t\tIFI_CANFD_IRQMASK_RXFIFO_NEMPTY |\n\t\t\tIFI_CANFD_IRQMASK_ERROR_STATE_CHG |\n\t\t\tIFI_CANFD_IRQMASK_ERROR_WARNING |\n\t\t\tIFI_CANFD_IRQMASK_ERROR_BUSOFF;\n\t\tif (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING)\n\t\t\tenirq |= IFI_CANFD_INTERRUPT_ERROR_COUNTER;\n\t}\n\n\twritel(IFI_CANFD_IRQMASK_SET_ERR |\n\t       IFI_CANFD_IRQMASK_SET_TS |\n\t       IFI_CANFD_IRQMASK_SET_TX |\n\t       IFI_CANFD_IRQMASK_SET_RX | enirq,\n\t       priv->base + IFI_CANFD_IRQMASK);\n}\n\nstatic void ifi_canfd_read_fifo(struct net_device *ndev)\n{\n\tstruct net_device_stats *stats = &ndev->stats;\n\tstruct ifi_canfd_priv *priv = netdev_priv(ndev);\n\tstruct canfd_frame *cf;\n\tstruct sk_buff *skb;\n\tconst u32 rx_irq_mask = IFI_CANFD_INTERRUPT_RXFIFO_NEMPTY |\n\t\t\t\tIFI_CANFD_INTERRUPT_RXFIFO_NEMPTY_PER;\n\tu32 rxdlc, rxid;\n\tu32 dlc, id;\n\tint i;\n\n\trxdlc = readl(priv->base + IFI_CANFD_RXFIFO_DLC);\n\tif (rxdlc & IFI_CANFD_RXFIFO_DLC_EDL)\n\t\tskb = alloc_canfd_skb(ndev, &cf);\n\telse\n\t\tskb = alloc_can_skb(ndev, (struct can_frame **)&cf);\n\n\tif (!skb) {\n\t\tstats->rx_dropped++;\n\t\treturn;\n\t}\n\n\tdlc = (rxdlc >> IFI_CANFD_RXFIFO_DLC_DLC_OFFSET) &\n\t      IFI_CANFD_RXFIFO_DLC_DLC_MASK;\n\tif (rxdlc & IFI_CANFD_RXFIFO_DLC_EDL)\n\t\tcf->len = can_fd_dlc2len(dlc);\n\telse\n\t\tcf->len = can_cc_dlc2len(dlc);\n\n\trxid = readl(priv->base + IFI_CANFD_RXFIFO_ID);\n\tid = (rxid >> IFI_CANFD_RXFIFO_ID_ID_OFFSET);\n\tif (id & IFI_CANFD_RXFIFO_ID_IDE) {\n\t\tid &= IFI_CANFD_RXFIFO_ID_ID_XTD_MASK;\n\t\t \n\t\tid = (id >> IFI_CANFD_RXFIFO_ID_ID_XTD_OFFSET) |\n\t\t     ((id & IFI_CANFD_RXFIFO_ID_ID_STD_MASK) <<\n\t\t       IFI_CANFD_RXFIFO_ID_ID_XTD_WIDTH);\n\t\tid |= CAN_EFF_FLAG;\n\t} else {\n\t\tid &= IFI_CANFD_RXFIFO_ID_ID_STD_MASK;\n\t}\n\tcf->can_id = id;\n\n\tif (rxdlc & IFI_CANFD_RXFIFO_DLC_ESI) {\n\t\tcf->flags |= CANFD_ESI;\n\t\tnetdev_dbg(ndev, \"ESI Error\\n\");\n\t}\n\n\tif (!(rxdlc & IFI_CANFD_RXFIFO_DLC_EDL) &&\n\t    (rxdlc & IFI_CANFD_RXFIFO_DLC_RTR)) {\n\t\tcf->can_id |= CAN_RTR_FLAG;\n\t} else {\n\t\tif (rxdlc & IFI_CANFD_RXFIFO_DLC_BRS)\n\t\t\tcf->flags |= CANFD_BRS;\n\n\t\tfor (i = 0; i < cf->len; i += 4) {\n\t\t\t*(u32 *)(cf->data + i) =\n\t\t\t\treadl(priv->base + IFI_CANFD_RXFIFO_DATA + i);\n\t\t}\n\n\t\tstats->rx_bytes += cf->len;\n\t}\n\tstats->rx_packets++;\n\n\t \n\twritel(IFI_CANFD_RXSTCMD_REMOVE_MSG, priv->base + IFI_CANFD_RXSTCMD);\n\twritel(rx_irq_mask, priv->base + IFI_CANFD_INTERRUPT);\n\n\tnetif_receive_skb(skb);\n}\n\nstatic int ifi_canfd_do_rx_poll(struct net_device *ndev, int quota)\n{\n\tstruct ifi_canfd_priv *priv = netdev_priv(ndev);\n\tu32 pkts = 0;\n\tu32 rxst;\n\n\trxst = readl(priv->base + IFI_CANFD_RXSTCMD);\n\tif (rxst & IFI_CANFD_RXSTCMD_EMPTY) {\n\t\tnetdev_dbg(ndev, \"No messages in RX FIFO\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (;;) {\n\t\tif (rxst & IFI_CANFD_RXSTCMD_EMPTY)\n\t\t\tbreak;\n\t\tif (quota <= 0)\n\t\t\tbreak;\n\n\t\tifi_canfd_read_fifo(ndev);\n\t\tquota--;\n\t\tpkts++;\n\t\trxst = readl(priv->base + IFI_CANFD_RXSTCMD);\n\t}\n\n\treturn pkts;\n}\n\nstatic int ifi_canfd_handle_lost_msg(struct net_device *ndev)\n{\n\tstruct net_device_stats *stats = &ndev->stats;\n\tstruct sk_buff *skb;\n\tstruct can_frame *frame;\n\n\tnetdev_err(ndev, \"RX FIFO overflow, message(s) lost.\\n\");\n\n\tstats->rx_errors++;\n\tstats->rx_over_errors++;\n\n\tskb = alloc_can_err_skb(ndev, &frame);\n\tif (unlikely(!skb))\n\t\treturn 0;\n\n\tframe->can_id |= CAN_ERR_CRTL;\n\tframe->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\n\tnetif_receive_skb(skb);\n\n\treturn 1;\n}\n\nstatic int ifi_canfd_handle_lec_err(struct net_device *ndev)\n{\n\tstruct ifi_canfd_priv *priv = netdev_priv(ndev);\n\tstruct net_device_stats *stats = &ndev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tu32 errctr = readl(priv->base + IFI_CANFD_ERROR_CTR);\n\tconst u32 errmask = IFI_CANFD_ERROR_CTR_OVERLOAD_FIRST |\n\t\t\t    IFI_CANFD_ERROR_CTR_ACK_ERROR_FIRST |\n\t\t\t    IFI_CANFD_ERROR_CTR_BIT0_ERROR_FIRST |\n\t\t\t    IFI_CANFD_ERROR_CTR_BIT1_ERROR_FIRST |\n\t\t\t    IFI_CANFD_ERROR_CTR_STUFF_ERROR_FIRST |\n\t\t\t    IFI_CANFD_ERROR_CTR_CRC_ERROR_FIRST |\n\t\t\t    IFI_CANFD_ERROR_CTR_FORM_ERROR_FIRST;\n\n\tif (!(errctr & errmask))\t \n\t\treturn 0;\n\n\tpriv->can.can_stats.bus_error++;\n\tstats->rx_errors++;\n\n\t \n\tskb = alloc_can_err_skb(ndev, &cf);\n\tif (unlikely(!skb))\n\t\treturn 0;\n\n\t \n\tcf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\n\n\tif (errctr & IFI_CANFD_ERROR_CTR_OVERLOAD_FIRST)\n\t\tcf->data[2] |= CAN_ERR_PROT_OVERLOAD;\n\n\tif (errctr & IFI_CANFD_ERROR_CTR_ACK_ERROR_FIRST)\n\t\tcf->data[3] = CAN_ERR_PROT_LOC_ACK;\n\n\tif (errctr & IFI_CANFD_ERROR_CTR_BIT0_ERROR_FIRST)\n\t\tcf->data[2] |= CAN_ERR_PROT_BIT0;\n\n\tif (errctr & IFI_CANFD_ERROR_CTR_BIT1_ERROR_FIRST)\n\t\tcf->data[2] |= CAN_ERR_PROT_BIT1;\n\n\tif (errctr & IFI_CANFD_ERROR_CTR_STUFF_ERROR_FIRST)\n\t\tcf->data[2] |= CAN_ERR_PROT_STUFF;\n\n\tif (errctr & IFI_CANFD_ERROR_CTR_CRC_ERROR_FIRST)\n\t\tcf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;\n\n\tif (errctr & IFI_CANFD_ERROR_CTR_FORM_ERROR_FIRST)\n\t\tcf->data[2] |= CAN_ERR_PROT_FORM;\n\n\t \n\twritel(IFI_CANFD_ERROR_CTR_ER_RESET, priv->base + IFI_CANFD_ERROR_CTR);\n\twritel(IFI_CANFD_INTERRUPT_ERROR_COUNTER,\n\t       priv->base + IFI_CANFD_INTERRUPT);\n\twritel(IFI_CANFD_ERROR_CTR_ER_ENABLE, priv->base + IFI_CANFD_ERROR_CTR);\n\n\tnetif_receive_skb(skb);\n\n\treturn 1;\n}\n\nstatic int ifi_canfd_get_berr_counter(const struct net_device *ndev,\n\t\t\t\t      struct can_berr_counter *bec)\n{\n\tstruct ifi_canfd_priv *priv = netdev_priv(ndev);\n\tu32 err;\n\n\terr = readl(priv->base + IFI_CANFD_ERROR);\n\tbec->rxerr = (err >> IFI_CANFD_ERROR_RX_OFFSET) &\n\t\t     IFI_CANFD_ERROR_RX_MASK;\n\tbec->txerr = (err >> IFI_CANFD_ERROR_TX_OFFSET) &\n\t\t     IFI_CANFD_ERROR_TX_MASK;\n\n\treturn 0;\n}\n\nstatic int ifi_canfd_handle_state_change(struct net_device *ndev,\n\t\t\t\t\t enum can_state new_state)\n{\n\tstruct ifi_canfd_priv *priv = netdev_priv(ndev);\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tstruct can_berr_counter bec;\n\n\tswitch (new_state) {\n\tcase CAN_STATE_ERROR_ACTIVE:\n\t\t \n\t\tpriv->can.can_stats.error_warning++;\n\t\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\tbreak;\n\tcase CAN_STATE_ERROR_WARNING:\n\t\t \n\t\tpriv->can.can_stats.error_warning++;\n\t\tpriv->can.state = CAN_STATE_ERROR_WARNING;\n\t\tbreak;\n\tcase CAN_STATE_ERROR_PASSIVE:\n\t\t \n\t\tpriv->can.can_stats.error_passive++;\n\t\tpriv->can.state = CAN_STATE_ERROR_PASSIVE;\n\t\tbreak;\n\tcase CAN_STATE_BUS_OFF:\n\t\t \n\t\tpriv->can.state = CAN_STATE_BUS_OFF;\n\t\tifi_canfd_irq_enable(ndev, 0);\n\t\tpriv->can.can_stats.bus_off++;\n\t\tcan_bus_off(ndev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tskb = alloc_can_err_skb(ndev, &cf);\n\tif (unlikely(!skb))\n\t\treturn 0;\n\n\tifi_canfd_get_berr_counter(ndev, &bec);\n\n\tswitch (new_state) {\n\tcase CAN_STATE_ERROR_WARNING:\n\t\t \n\t\tcf->can_id |= CAN_ERR_CRTL | CAN_ERR_CNT;\n\t\tcf->data[1] = (bec.txerr > bec.rxerr) ?\n\t\t\tCAN_ERR_CRTL_TX_WARNING :\n\t\t\tCAN_ERR_CRTL_RX_WARNING;\n\t\tcf->data[6] = bec.txerr;\n\t\tcf->data[7] = bec.rxerr;\n\t\tbreak;\n\tcase CAN_STATE_ERROR_PASSIVE:\n\t\t \n\t\tcf->can_id |= CAN_ERR_CRTL | CAN_ERR_CNT;\n\t\tcf->data[1] |= CAN_ERR_CRTL_RX_PASSIVE;\n\t\tif (bec.txerr > 127)\n\t\t\tcf->data[1] |= CAN_ERR_CRTL_TX_PASSIVE;\n\t\tcf->data[6] = bec.txerr;\n\t\tcf->data[7] = bec.rxerr;\n\t\tbreak;\n\tcase CAN_STATE_BUS_OFF:\n\t\t \n\t\tcf->can_id |= CAN_ERR_BUSOFF;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tnetif_receive_skb(skb);\n\n\treturn 1;\n}\n\nstatic int ifi_canfd_handle_state_errors(struct net_device *ndev)\n{\n\tstruct ifi_canfd_priv *priv = netdev_priv(ndev);\n\tu32 stcmd = readl(priv->base + IFI_CANFD_STCMD);\n\tint work_done = 0;\n\n\tif ((stcmd & IFI_CANFD_STCMD_ERROR_ACTIVE) &&\n\t    (priv->can.state != CAN_STATE_ERROR_ACTIVE)) {\n\t\tnetdev_dbg(ndev, \"Error, entered active state\\n\");\n\t\twork_done += ifi_canfd_handle_state_change(ndev,\n\t\t\t\t\t\tCAN_STATE_ERROR_ACTIVE);\n\t}\n\n\tif ((stcmd & IFI_CANFD_STCMD_ERROR_WARNING) &&\n\t    (priv->can.state != CAN_STATE_ERROR_WARNING)) {\n\t\tnetdev_dbg(ndev, \"Error, entered warning state\\n\");\n\t\twork_done += ifi_canfd_handle_state_change(ndev,\n\t\t\t\t\t\tCAN_STATE_ERROR_WARNING);\n\t}\n\n\tif ((stcmd & IFI_CANFD_STCMD_ERROR_PASSIVE) &&\n\t    (priv->can.state != CAN_STATE_ERROR_PASSIVE)) {\n\t\tnetdev_dbg(ndev, \"Error, entered passive state\\n\");\n\t\twork_done += ifi_canfd_handle_state_change(ndev,\n\t\t\t\t\t\tCAN_STATE_ERROR_PASSIVE);\n\t}\n\n\tif ((stcmd & IFI_CANFD_STCMD_BUSOFF) &&\n\t    (priv->can.state != CAN_STATE_BUS_OFF)) {\n\t\tnetdev_dbg(ndev, \"Error, entered bus-off state\\n\");\n\t\twork_done += ifi_canfd_handle_state_change(ndev,\n\t\t\t\t\t\tCAN_STATE_BUS_OFF);\n\t}\n\n\treturn work_done;\n}\n\nstatic int ifi_canfd_poll(struct napi_struct *napi, int quota)\n{\n\tstruct net_device *ndev = napi->dev;\n\tstruct ifi_canfd_priv *priv = netdev_priv(ndev);\n\tu32 rxstcmd = readl(priv->base + IFI_CANFD_RXSTCMD);\n\tint work_done = 0;\n\n\t \n\twork_done += ifi_canfd_handle_state_errors(ndev);\n\n\t \n\tif (rxstcmd & IFI_CANFD_RXSTCMD_OVERFLOW)\n\t\twork_done += ifi_canfd_handle_lost_msg(ndev);\n\n\t \n\tif (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING)\n\t\twork_done += ifi_canfd_handle_lec_err(ndev);\n\n\t \n\tif (!(rxstcmd & IFI_CANFD_RXSTCMD_EMPTY))\n\t\twork_done += ifi_canfd_do_rx_poll(ndev, quota - work_done);\n\n\tif (work_done < quota) {\n\t\tnapi_complete_done(napi, work_done);\n\t\tifi_canfd_irq_enable(ndev, 1);\n\t}\n\n\treturn work_done;\n}\n\nstatic irqreturn_t ifi_canfd_isr(int irq, void *dev_id)\n{\n\tstruct net_device *ndev = (struct net_device *)dev_id;\n\tstruct ifi_canfd_priv *priv = netdev_priv(ndev);\n\tstruct net_device_stats *stats = &ndev->stats;\n\tconst u32 rx_irq_mask = IFI_CANFD_INTERRUPT_RXFIFO_NEMPTY |\n\t\t\t\tIFI_CANFD_INTERRUPT_RXFIFO_NEMPTY_PER |\n\t\t\t\tIFI_CANFD_INTERRUPT_ERROR_COUNTER |\n\t\t\t\tIFI_CANFD_INTERRUPT_ERROR_STATE_CHG |\n\t\t\t\tIFI_CANFD_INTERRUPT_ERROR_WARNING |\n\t\t\t\tIFI_CANFD_INTERRUPT_ERROR_BUSOFF;\n\tconst u32 tx_irq_mask = IFI_CANFD_INTERRUPT_TXFIFO_EMPTY |\n\t\t\t\tIFI_CANFD_INTERRUPT_TXFIFO_REMOVE;\n\tconst u32 clr_irq_mask = ~((u32)IFI_CANFD_INTERRUPT_SET_IRQ);\n\tu32 isr;\n\n\tisr = readl(priv->base + IFI_CANFD_INTERRUPT);\n\n\t \n\tif (isr == 0)\n\t\treturn IRQ_NONE;\n\n\t \n\twritel(clr_irq_mask, priv->base + IFI_CANFD_INTERRUPT);\n\n\t \n\tif (isr & rx_irq_mask) {\n\t\tifi_canfd_irq_enable(ndev, 0);\n\t\tnapi_schedule(&priv->napi);\n\t}\n\n\t \n\tif (isr & IFI_CANFD_INTERRUPT_TXFIFO_REMOVE) {\n\t\tstats->tx_bytes += can_get_echo_skb(ndev, 0, NULL);\n\t\tstats->tx_packets++;\n\t}\n\n\tif (isr & tx_irq_mask)\n\t\tnetif_wake_queue(ndev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct can_bittiming_const ifi_canfd_bittiming_const = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.tseg1_min\t= 1,\t \n\t.tseg1_max\t= 256,\n\t.tseg2_min\t= 2,\t \n\t.tseg2_max\t= 256,\n\t.sjw_max\t= 128,\n\t.brp_min\t= 2,\n\t.brp_max\t= 512,\n\t.brp_inc\t= 1,\n};\n\nstatic void ifi_canfd_set_bittiming(struct net_device *ndev)\n{\n\tstruct ifi_canfd_priv *priv = netdev_priv(ndev);\n\tconst struct can_bittiming *bt = &priv->can.bittiming;\n\tconst struct can_bittiming *dbt = &priv->can.data_bittiming;\n\tu16 brp, sjw, tseg1, tseg2, tdc;\n\n\t \n\tbrp = bt->brp - 2;\n\tsjw = bt->sjw - 1;\n\ttseg1 = bt->prop_seg + bt->phase_seg1 - 1;\n\ttseg2 = bt->phase_seg2 - 2;\n\twritel((tseg2 << IFI_CANFD_TIME_TIMEB_OFF) |\n\t       (tseg1 << IFI_CANFD_TIME_TIMEA_OFF) |\n\t       (brp << IFI_CANFD_TIME_PRESCALE_OFF) |\n\t       (sjw << IFI_CANFD_TIME_SJW_OFF_7_9_8_8),\n\t       priv->base + IFI_CANFD_TIME);\n\n\t \n\tbrp = dbt->brp - 2;\n\tsjw = dbt->sjw - 1;\n\ttseg1 = dbt->prop_seg + dbt->phase_seg1 - 1;\n\ttseg2 = dbt->phase_seg2 - 2;\n\twritel((tseg2 << IFI_CANFD_TIME_TIMEB_OFF) |\n\t       (tseg1 << IFI_CANFD_TIME_TIMEA_OFF) |\n\t       (brp << IFI_CANFD_TIME_PRESCALE_OFF) |\n\t       (sjw << IFI_CANFD_TIME_SJW_OFF_7_9_8_8),\n\t       priv->base + IFI_CANFD_FTIME);\n\n\t \n\ttdc = dbt->brp * (dbt->prop_seg + dbt->phase_seg1);\n\ttdc &= IFI_CANFD_TDELAY_MASK;\n\twritel(IFI_CANFD_TDELAY_EN | tdc, priv->base + IFI_CANFD_TDELAY);\n}\n\nstatic void ifi_canfd_set_filter(struct net_device *ndev, const u32 id,\n\t\t\t\t const u32 mask, const u32 ident)\n{\n\tstruct ifi_canfd_priv *priv = netdev_priv(ndev);\n\n\twritel(mask, priv->base + IFI_CANFD_FILTER_MASK(id));\n\twritel(ident, priv->base + IFI_CANFD_FILTER_IDENT(id));\n}\n\nstatic void ifi_canfd_set_filters(struct net_device *ndev)\n{\n\t \n\tifi_canfd_set_filter(ndev, 0,\n\t\t\t     IFI_CANFD_FILTER_MASK_VALID |\n\t\t\t     IFI_CANFD_FILTER_MASK_EXT,\n\t\t\t     IFI_CANFD_FILTER_IDENT_VALID);\n\n\t \n\tifi_canfd_set_filter(ndev, 1,\n\t\t\t     IFI_CANFD_FILTER_MASK_VALID |\n\t\t\t     IFI_CANFD_FILTER_MASK_EXT,\n\t\t\t     IFI_CANFD_FILTER_IDENT_VALID |\n\t\t\t     IFI_CANFD_FILTER_IDENT_IDE);\n\n\t \n\tifi_canfd_set_filter(ndev, 2,\n\t\t\t     IFI_CANFD_FILTER_MASK_VALID |\n\t\t\t     IFI_CANFD_FILTER_MASK_EDL |\n\t\t\t     IFI_CANFD_FILTER_MASK_EXT,\n\t\t\t     IFI_CANFD_FILTER_IDENT_VALID |\n\t\t\t     IFI_CANFD_FILTER_IDENT_CANFD |\n\t\t\t     IFI_CANFD_FILTER_IDENT_IDE);\n}\n\nstatic void ifi_canfd_start(struct net_device *ndev)\n{\n\tstruct ifi_canfd_priv *priv = netdev_priv(ndev);\n\tu32 stcmd;\n\n\t \n\twritel(IFI_CANFD_STCMD_HARDRESET, priv->base + IFI_CANFD_STCMD);\n\twritel(IFI_CANFD_STCMD_ENABLE_7_9_8_8_TIMING,\n\t       priv->base + IFI_CANFD_STCMD);\n\n\tifi_canfd_set_bittiming(ndev);\n\tifi_canfd_set_filters(ndev);\n\n\t \n\twritel(IFI_CANFD_RXSTCMD_RESET, priv->base + IFI_CANFD_RXSTCMD);\n\twritel(0, priv->base + IFI_CANFD_RXSTCMD);\n\twritel(IFI_CANFD_TXSTCMD_RESET, priv->base + IFI_CANFD_TXSTCMD);\n\twritel(0, priv->base + IFI_CANFD_TXSTCMD);\n\n\t \n\twritel(0, priv->base + IFI_CANFD_REPEAT);\n\twritel(0, priv->base + IFI_CANFD_SUSPEND);\n\n\t \n\twritel((u32)(~IFI_CANFD_INTERRUPT_SET_IRQ),\n\t       priv->base + IFI_CANFD_INTERRUPT);\n\n\tstcmd = IFI_CANFD_STCMD_ENABLE | IFI_CANFD_STCMD_NORMAL_MODE |\n\t\tIFI_CANFD_STCMD_ENABLE_7_9_8_8_TIMING;\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tstcmd |= IFI_CANFD_STCMD_BUSMONITOR;\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\tstcmd |= IFI_CANFD_STCMD_LOOPBACK;\n\n\tif ((priv->can.ctrlmode & CAN_CTRLMODE_FD) &&\n\t    !(priv->can.ctrlmode & CAN_CTRLMODE_FD_NON_ISO))\n\t\tstcmd |= IFI_CANFD_STCMD_ENABLE_ISO;\n\n\tif (!(priv->can.ctrlmode & CAN_CTRLMODE_FD))\n\t\tstcmd |= IFI_CANFD_STCMD_DISABLE_CANFD;\n\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\tifi_canfd_irq_enable(ndev, 1);\n\n\t \n\twritel(IFI_CANFD_ERROR_CTR_UNLOCK_MAGIC,\n\t       priv->base + IFI_CANFD_ERROR_CTR);\n\twritel(IFI_CANFD_ERROR_CTR_ER_RESET, priv->base + IFI_CANFD_ERROR_CTR);\n\twritel(IFI_CANFD_ERROR_CTR_ER_ENABLE, priv->base + IFI_CANFD_ERROR_CTR);\n\n\t \n\twritel(stcmd, priv->base + IFI_CANFD_STCMD);\n}\n\nstatic void ifi_canfd_stop(struct net_device *ndev)\n{\n\tstruct ifi_canfd_priv *priv = netdev_priv(ndev);\n\n\t \n\twritel(IFI_CANFD_ERROR_CTR_ER_RESET, priv->base + IFI_CANFD_ERROR_CTR);\n\twritel(0, priv->base + IFI_CANFD_ERROR_CTR);\n\n\t \n\twritel(IFI_CANFD_STCMD_HARDRESET, priv->base + IFI_CANFD_STCMD);\n\n\t \n\twritel(~0, priv->base + IFI_CANFD_IRQMASK);\n\n\t \n\twritel((u32)(~IFI_CANFD_INTERRUPT_SET_IRQ),\n\t       priv->base + IFI_CANFD_INTERRUPT);\n\n\t \n\tpriv->can.state = CAN_STATE_STOPPED;\n}\n\nstatic int ifi_canfd_set_mode(struct net_device *ndev, enum can_mode mode)\n{\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\tifi_canfd_start(ndev);\n\t\tnetif_wake_queue(ndev);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int ifi_canfd_open(struct net_device *ndev)\n{\n\tstruct ifi_canfd_priv *priv = netdev_priv(ndev);\n\tint ret;\n\n\tret = open_candev(ndev);\n\tif (ret) {\n\t\tnetdev_err(ndev, \"Failed to open CAN device\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = request_irq(ndev->irq, ifi_canfd_isr, IRQF_SHARED,\n\t\t\t  ndev->name, ndev);\n\tif (ret < 0) {\n\t\tnetdev_err(ndev, \"Failed to request interrupt\\n\");\n\t\tgoto err_irq;\n\t}\n\n\tifi_canfd_start(ndev);\n\n\tnapi_enable(&priv->napi);\n\tnetif_start_queue(ndev);\n\n\treturn 0;\nerr_irq:\n\tclose_candev(ndev);\n\treturn ret;\n}\n\nstatic int ifi_canfd_close(struct net_device *ndev)\n{\n\tstruct ifi_canfd_priv *priv = netdev_priv(ndev);\n\n\tnetif_stop_queue(ndev);\n\tnapi_disable(&priv->napi);\n\n\tifi_canfd_stop(ndev);\n\n\tfree_irq(ndev->irq, ndev);\n\n\tclose_candev(ndev);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t ifi_canfd_start_xmit(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *ndev)\n{\n\tstruct ifi_canfd_priv *priv = netdev_priv(ndev);\n\tstruct canfd_frame *cf = (struct canfd_frame *)skb->data;\n\tu32 txst, txid, txdlc;\n\tint i;\n\n\tif (can_dev_dropped_skb(ndev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\t \n\ttxst = readl(priv->base + IFI_CANFD_TXSTCMD);\n\tif (txst & IFI_CANFD_TXSTCMD_FULL) {\n\t\tnetif_stop_queue(ndev);\n\t\tnetdev_err(ndev, \"BUG! TX FIFO full when queue awake!\\n\");\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tnetif_stop_queue(ndev);\n\n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\ttxid = cf->can_id & CAN_EFF_MASK;\n\t\t \n\t\ttxid = (txid >> IFI_CANFD_TXFIFO_ID_ID_XTD_WIDTH) |\n\t\t       ((txid & IFI_CANFD_TXFIFO_ID_ID_XTD_MASK) <<\n\t\t         IFI_CANFD_TXFIFO_ID_ID_XTD_OFFSET);\n\t\ttxid |= IFI_CANFD_TXFIFO_ID_IDE;\n\t} else {\n\t\ttxid = cf->can_id & CAN_SFF_MASK;\n\t}\n\n\ttxdlc = can_fd_len2dlc(cf->len);\n\tif ((priv->can.ctrlmode & CAN_CTRLMODE_FD) && can_is_canfd_skb(skb)) {\n\t\ttxdlc |= IFI_CANFD_TXFIFO_DLC_EDL;\n\t\tif (cf->flags & CANFD_BRS)\n\t\t\ttxdlc |= IFI_CANFD_TXFIFO_DLC_BRS;\n\t}\n\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\ttxdlc |= IFI_CANFD_TXFIFO_DLC_RTR;\n\n\t \n\twritel(txid, priv->base + IFI_CANFD_TXFIFO_ID);\n\twritel(txdlc, priv->base + IFI_CANFD_TXFIFO_DLC);\n\n\tfor (i = 0; i < cf->len; i += 4) {\n\t\twritel(*(u32 *)(cf->data + i),\n\t\t       priv->base + IFI_CANFD_TXFIFO_DATA + i);\n\t}\n\n\twritel(0, priv->base + IFI_CANFD_TXFIFO_REPEATCOUNT);\n\twritel(0, priv->base + IFI_CANFD_TXFIFO_SUSPEND_US);\n\n\tcan_put_echo_skb(skb, ndev, 0, 0);\n\n\t \n\twritel(IFI_CANFD_TXSTCMD_ADD_MSG, priv->base + IFI_CANFD_TXSTCMD);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic const struct net_device_ops ifi_canfd_netdev_ops = {\n\t.ndo_open\t= ifi_canfd_open,\n\t.ndo_stop\t= ifi_canfd_close,\n\t.ndo_start_xmit\t= ifi_canfd_start_xmit,\n\t.ndo_change_mtu\t= can_change_mtu,\n};\n\nstatic const struct ethtool_ops ifi_canfd_ethtool_ops = {\n\t.get_ts_info = ethtool_op_get_ts_info,\n};\n\nstatic int ifi_canfd_plat_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct net_device *ndev;\n\tstruct ifi_canfd_priv *priv;\n\tvoid __iomem *addr;\n\tint irq, ret;\n\tu32 id, rev;\n\n\taddr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(addr))\n\t\treturn PTR_ERR(addr);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn -EINVAL;\n\n\tid = readl(addr + IFI_CANFD_IP_ID);\n\tif (id != IFI_CANFD_IP_ID_VALUE) {\n\t\tdev_err(dev, \"This block is not IFI CANFD, id=%08x\\n\", id);\n\t\treturn -EINVAL;\n\t}\n\n\trev = readl(addr + IFI_CANFD_VER) & IFI_CANFD_VER_REV_MASK;\n\tif (rev < IFI_CANFD_VER_REV_MIN_SUPPORTED) {\n\t\tdev_err(dev, \"This block is too old (rev %i), minimum supported is rev %i\\n\",\n\t\t\trev, IFI_CANFD_VER_REV_MIN_SUPPORTED);\n\t\treturn -EINVAL;\n\t}\n\n\tndev = alloc_candev(sizeof(*priv), 1);\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tndev->irq = irq;\n\tndev->flags |= IFF_ECHO;\t \n\tndev->netdev_ops = &ifi_canfd_netdev_ops;\n\tndev->ethtool_ops = &ifi_canfd_ethtool_ops;\n\n\tpriv = netdev_priv(ndev);\n\tpriv->ndev = ndev;\n\tpriv->base = addr;\n\n\tnetif_napi_add(ndev, &priv->napi, ifi_canfd_poll);\n\n\tpriv->can.state = CAN_STATE_STOPPED;\n\n\tpriv->can.clock.freq = readl(addr + IFI_CANFD_CANCLOCK);\n\n\tpriv->can.bittiming_const\t= &ifi_canfd_bittiming_const;\n\tpriv->can.data_bittiming_const\t= &ifi_canfd_bittiming_const;\n\tpriv->can.do_set_mode\t\t= ifi_canfd_set_mode;\n\tpriv->can.do_get_berr_counter\t= ifi_canfd_get_berr_counter;\n\n\t \n\tpriv->can.ctrlmode = CAN_CTRLMODE_FD;\n\n\t \n\tpriv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |\n\t\t\t\t       CAN_CTRLMODE_LISTENONLY |\n\t\t\t\t       CAN_CTRLMODE_FD |\n\t\t\t\t       CAN_CTRLMODE_FD_NON_ISO |\n\t\t\t\t       CAN_CTRLMODE_BERR_REPORTING;\n\n\tplatform_set_drvdata(pdev, ndev);\n\tSET_NETDEV_DEV(ndev, dev);\n\n\tret = register_candev(ndev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register (ret=%d)\\n\", ret);\n\t\tgoto err_reg;\n\t}\n\n\tdev_info(dev, \"Driver registered: regs=%p, irq=%d, clock=%d\\n\",\n\t\t priv->base, ndev->irq, priv->can.clock.freq);\n\n\treturn 0;\n\nerr_reg:\n\tfree_candev(ndev);\n\treturn ret;\n}\n\nstatic void ifi_canfd_plat_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\n\tunregister_candev(ndev);\n\tplatform_set_drvdata(pdev, NULL);\n\tfree_candev(ndev);\n}\n\nstatic const struct of_device_id ifi_canfd_of_table[] = {\n\t{ .compatible = \"ifi,canfd-1.0\", .data = NULL },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, ifi_canfd_of_table);\n\nstatic struct platform_driver ifi_canfd_plat_driver = {\n\t.driver = {\n\t\t.name\t\t= KBUILD_MODNAME,\n\t\t.of_match_table\t= ifi_canfd_of_table,\n\t},\n\t.probe\t= ifi_canfd_plat_probe,\n\t.remove_new = ifi_canfd_plat_remove,\n};\n\nmodule_platform_driver(ifi_canfd_plat_driver);\n\nMODULE_AUTHOR(\"Marek Vasut <marex@denx.de>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"CAN bus driver for IFI CANFD controller\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}