{
  "module_name": "c_can_pci.c",
  "hash_id": "c8e2862344eeba110d1ad08e2ceb3393751c21c63efff58c2b30c0bf6ad707d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/c_can/c_can_pci.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/pci.h>\n\n#include <linux/can/dev.h>\n\n#include \"c_can.h\"\n\n#define PCI_DEVICE_ID_PCH_CAN\t0x8818\n#define PCH_PCI_SOFT_RESET\t0x01fc\n\nenum c_can_pci_reg_align {\n\tC_CAN_REG_ALIGN_16,\n\tC_CAN_REG_ALIGN_32,\n\tC_CAN_REG_32,\n};\n\nstruct c_can_pci_data {\n\t \n\tenum c_can_dev_id type;\n\t \n\tunsigned int msg_obj_num;\n\t \n\tenum c_can_pci_reg_align reg_align;\n\t \n\tunsigned int freq;\n\t \n\tint bar;\n\t \n\tvoid (*init)(const struct c_can_priv *priv, bool enable);\n};\n\n \nstatic u16 c_can_pci_read_reg_aligned_to_16bit(const struct c_can_priv *priv,\n\t\t\t\t\t       enum reg index)\n{\n\treturn readw(priv->base + priv->regs[index]);\n}\n\nstatic void c_can_pci_write_reg_aligned_to_16bit(const struct c_can_priv *priv,\n\t\t\t\t\t\t enum reg index, u16 val)\n{\n\twritew(val, priv->base + priv->regs[index]);\n}\n\nstatic u16 c_can_pci_read_reg_aligned_to_32bit(const struct c_can_priv *priv,\n\t\t\t\t\t       enum reg index)\n{\n\treturn readw(priv->base + 2 * priv->regs[index]);\n}\n\nstatic void c_can_pci_write_reg_aligned_to_32bit(const struct c_can_priv *priv,\n\t\t\t\t\t\t enum reg index, u16 val)\n{\n\twritew(val, priv->base + 2 * priv->regs[index]);\n}\n\nstatic u16 c_can_pci_read_reg_32bit(const struct c_can_priv *priv,\n\t\t\t\t    enum reg index)\n{\n\treturn (u16)ioread32(priv->base + 2 * priv->regs[index]);\n}\n\nstatic void c_can_pci_write_reg_32bit(const struct c_can_priv *priv,\n\t\t\t\t      enum reg index, u16 val)\n{\n\tiowrite32((u32)val, priv->base + 2 * priv->regs[index]);\n}\n\nstatic u32 c_can_pci_read_reg32(const struct c_can_priv *priv, enum reg index)\n{\n\tu32 val;\n\n\tval = priv->read_reg(priv, index);\n\tval |= ((u32)priv->read_reg(priv, index + 1)) << 16;\n\n\treturn val;\n}\n\nstatic void c_can_pci_write_reg32(const struct c_can_priv *priv, enum reg index,\n\t\t\t\t  u32 val)\n{\n\tpriv->write_reg(priv, index + 1, val >> 16);\n\tpriv->write_reg(priv, index, val);\n}\n\nstatic void c_can_pci_reset_pch(const struct c_can_priv *priv, bool enable)\n{\n\tif (enable) {\n\t\tu32 __iomem *addr = priv->base + PCH_PCI_SOFT_RESET;\n\n\t\t \n\t\tiowrite32(1, addr);\n\t\tiowrite32(0, addr);\n\t}\n}\n\nstatic int c_can_pci_probe(struct pci_dev *pdev,\n\t\t\t   const struct pci_device_id *ent)\n{\n\tstruct c_can_pci_data *c_can_pci_data = (void *)ent->driver_data;\n\tstruct c_can_priv *priv;\n\tstruct net_device *dev;\n\tvoid __iomem *addr;\n\tint ret;\n\n\tret = pci_enable_device(pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"pci_enable_device FAILED\\n\");\n\t\tgoto out;\n\t}\n\n\tret = pci_request_regions(pdev, KBUILD_MODNAME);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"pci_request_regions FAILED\\n\");\n\t\tgoto out_disable_device;\n\t}\n\n\tret = pci_enable_msi(pdev);\n\tif (!ret) {\n\t\tdev_info(&pdev->dev, \"MSI enabled\\n\");\n\t\tpci_set_master(pdev);\n\t}\n\n\taddr = pci_iomap(pdev, c_can_pci_data->bar,\n\t\t\t pci_resource_len(pdev, c_can_pci_data->bar));\n\tif (!addr) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"device has no PCI memory resources, failing adapter\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_release_regions;\n\t}\n\n\t \n\tdev = alloc_c_can_dev(c_can_pci_data->msg_obj_num);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto out_iounmap;\n\t}\n\n\tpriv = netdev_priv(dev);\n\tpci_set_drvdata(pdev, dev);\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\tdev->irq = pdev->irq;\n\tpriv->base = addr;\n\tpriv->device = &pdev->dev;\n\n\tif (!c_can_pci_data->freq) {\n\t\tdev_err(&pdev->dev, \"no clock frequency defined\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_free_c_can;\n\t} else {\n\t\tpriv->can.clock.freq = c_can_pci_data->freq;\n\t}\n\n\t \n\tswitch (c_can_pci_data->type) {\n\tcase BOSCH_C_CAN:\n\t\tpriv->regs = reg_map_c_can;\n\t\tbreak;\n\tcase BOSCH_D_CAN:\n\t\tpriv->regs = reg_map_d_can;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out_free_c_can;\n\t}\n\n\tpriv->type = c_can_pci_data->type;\n\n\t \n\tswitch (c_can_pci_data->reg_align) {\n\tcase C_CAN_REG_ALIGN_32:\n\t\tpriv->read_reg = c_can_pci_read_reg_aligned_to_32bit;\n\t\tpriv->write_reg = c_can_pci_write_reg_aligned_to_32bit;\n\t\tbreak;\n\tcase C_CAN_REG_ALIGN_16:\n\t\tpriv->read_reg = c_can_pci_read_reg_aligned_to_16bit;\n\t\tpriv->write_reg = c_can_pci_write_reg_aligned_to_16bit;\n\t\tbreak;\n\tcase C_CAN_REG_32:\n\t\tpriv->read_reg = c_can_pci_read_reg_32bit;\n\t\tpriv->write_reg = c_can_pci_write_reg_32bit;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out_free_c_can;\n\t}\n\tpriv->read_reg32 = c_can_pci_read_reg32;\n\tpriv->write_reg32 = c_can_pci_write_reg32;\n\n\tpriv->raminit = c_can_pci_data->init;\n\n\tret = register_c_can_dev(dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"registering %s failed (err=%d)\\n\",\n\t\t\tKBUILD_MODNAME, ret);\n\t\tgoto out_free_c_can;\n\t}\n\n\tdev_dbg(&pdev->dev, \"%s device registered (regs=%p, irq=%d)\\n\",\n\t\tKBUILD_MODNAME, priv->regs, dev->irq);\n\n\treturn 0;\n\nout_free_c_can:\n\tfree_c_can_dev(dev);\nout_iounmap:\n\tpci_iounmap(pdev, addr);\nout_release_regions:\n\tpci_disable_msi(pdev);\n\tpci_release_regions(pdev);\nout_disable_device:\n\tpci_disable_device(pdev);\nout:\n\treturn ret;\n}\n\nstatic void c_can_pci_remove(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\tvoid __iomem *addr = priv->base;\n\n\tunregister_c_can_dev(dev);\n\n\tfree_c_can_dev(dev);\n\n\tpci_iounmap(pdev, addr);\n\tpci_disable_msi(pdev);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n}\n\nstatic const struct c_can_pci_data c_can_sta2x11 = {\n\t.type = BOSCH_C_CAN,\n\t.msg_obj_num = 32,\n\t.reg_align = C_CAN_REG_ALIGN_32,\n\t.freq = 52000000,  \n\t.bar = 0,\n};\n\nstatic const struct c_can_pci_data c_can_pch = {\n\t.type = BOSCH_C_CAN,\n\t.msg_obj_num = 32,\n\t.reg_align = C_CAN_REG_32,\n\t.freq = 50000000,  \n\t.init = c_can_pci_reset_pch,\n\t.bar = 1,\n};\n\n#define C_CAN_ID(_vend, _dev, _driverdata) {\t\t\\\n\tPCI_DEVICE(_vend, _dev),\t\t\t\\\n\t.driver_data = (unsigned long)&(_driverdata),\t\\\n}\n\nstatic const struct pci_device_id c_can_pci_tbl[] = {\n\tC_CAN_ID(PCI_VENDOR_ID_STMICRO, PCI_DEVICE_ID_STMICRO_CAN,\n\t\t c_can_sta2x11),\n\tC_CAN_ID(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_PCH_CAN,\n\t\t c_can_pch),\n\t{},\n};\n\nstatic struct pci_driver c_can_pci_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = c_can_pci_tbl,\n\t.probe = c_can_pci_probe,\n\t.remove = c_can_pci_remove,\n};\n\nmodule_pci_driver(c_can_pci_driver);\n\nMODULE_AUTHOR(\"Federico Vaga <federico.vaga@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"PCI CAN bus driver for Bosch C_CAN/D_CAN controller\");\nMODULE_DEVICE_TABLE(pci, c_can_pci_tbl);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}