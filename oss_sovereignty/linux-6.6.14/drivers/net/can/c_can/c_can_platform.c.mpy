{
  "module_name": "c_can_platform.c",
  "hash_id": "c7aa4862023e1e02513d83d62b054ba58b23ed8b944839c80cd17de12fc47b89",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/c_can/c_can_platform.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n\n#include <linux/can/dev.h>\n\n#include \"c_can.h\"\n\n#define DCAN_RAM_INIT_BIT BIT(3)\n\nstatic DEFINE_SPINLOCK(raminit_lock);\n\n \nstatic u16 c_can_plat_read_reg_aligned_to_16bit(const struct c_can_priv *priv,\n\t\t\t\t\t\tenum reg index)\n{\n\treturn readw(priv->base + priv->regs[index]);\n}\n\nstatic void c_can_plat_write_reg_aligned_to_16bit(const struct c_can_priv *priv,\n\t\t\t\t\t\t  enum reg index, u16 val)\n{\n\twritew(val, priv->base + priv->regs[index]);\n}\n\nstatic u16 c_can_plat_read_reg_aligned_to_32bit(const struct c_can_priv *priv,\n\t\t\t\t\t\tenum reg index)\n{\n\treturn readw(priv->base + 2 * priv->regs[index]);\n}\n\nstatic void c_can_plat_write_reg_aligned_to_32bit(const struct c_can_priv *priv,\n\t\t\t\t\t\t  enum reg index, u16 val)\n{\n\twritew(val, priv->base + 2 * priv->regs[index]);\n}\n\nstatic void c_can_hw_raminit_wait_syscon(const struct c_can_priv *priv,\n\t\t\t\t\t u32 mask, u32 val)\n{\n\tconst struct c_can_raminit *raminit = &priv->raminit_sys;\n\tint timeout = 0;\n\tu32 ctrl = 0;\n\n\t \n\tval &= mask;\n\tdo {\n\t\tudelay(1);\n\t\ttimeout++;\n\n\t\tregmap_read(raminit->syscon, raminit->reg, &ctrl);\n\t\tif (timeout == 1000) {\n\t\t\tdev_err(&priv->dev->dev, \"%s: time out\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t} while ((ctrl & mask) != val);\n}\n\nstatic void c_can_hw_raminit_syscon(const struct c_can_priv *priv, bool enable)\n{\n\tconst struct c_can_raminit *raminit = &priv->raminit_sys;\n\tu32 ctrl = 0;\n\tu32 mask;\n\n\tspin_lock(&raminit_lock);\n\n\tmask = 1 << raminit->bits.start | 1 << raminit->bits.done;\n\tregmap_read(raminit->syscon, raminit->reg, &ctrl);\n\n\t \n\tctrl &= ~mask;\t \n\tregmap_update_bits(raminit->syscon, raminit->reg, mask, ctrl);\n\n\t \n\tc_can_hw_raminit_wait_syscon(priv, 1 << raminit->bits.start, ctrl);\n\n\tif (enable) {\n\t\t \n\t\tctrl |= 1 << raminit->bits.start;\n\t\t \n\t\tctrl |= 1 << raminit->bits.done;\n\t\tregmap_update_bits(raminit->syscon, raminit->reg, mask, ctrl);\n\t\t \n\t\tctrl &= ~(1 << raminit->bits.done);\n\t\t \n\t\tif (raminit->needs_pulse) {\n\t\t\tctrl &= ~(1 << raminit->bits.start);\n\t\t\tregmap_update_bits(raminit->syscon, raminit->reg,\n\t\t\t\t\t   mask, ctrl);\n\t\t}\n\n\t\tctrl |= 1 << raminit->bits.done;\n\t\tc_can_hw_raminit_wait_syscon(priv, mask, ctrl);\n\t}\n\tspin_unlock(&raminit_lock);\n}\n\nstatic u32 c_can_plat_read_reg32(const struct c_can_priv *priv, enum reg index)\n{\n\tu32 val;\n\n\tval = priv->read_reg(priv, index);\n\tval |= ((u32)priv->read_reg(priv, index + 1)) << 16;\n\n\treturn val;\n}\n\nstatic void c_can_plat_write_reg32(const struct c_can_priv *priv,\n\t\t\t\t   enum reg index, u32 val)\n{\n\tpriv->write_reg(priv, index + 1, val >> 16);\n\tpriv->write_reg(priv, index, val);\n}\n\nstatic u32 d_can_plat_read_reg32(const struct c_can_priv *priv, enum reg index)\n{\n\treturn readl(priv->base + priv->regs[index]);\n}\n\nstatic void d_can_plat_write_reg32(const struct c_can_priv *priv,\n\t\t\t\t   enum reg index, u32 val)\n{\n\twritel(val, priv->base + priv->regs[index]);\n}\n\nstatic void c_can_hw_raminit_wait(const struct c_can_priv *priv, u32 mask)\n{\n\twhile (priv->read_reg32(priv, C_CAN_FUNCTION_REG) & mask)\n\t\tudelay(1);\n}\n\nstatic void c_can_hw_raminit(const struct c_can_priv *priv, bool enable)\n{\n\tu32 ctrl;\n\n\tctrl = priv->read_reg32(priv, C_CAN_FUNCTION_REG);\n\tctrl &= ~DCAN_RAM_INIT_BIT;\n\tpriv->write_reg32(priv, C_CAN_FUNCTION_REG, ctrl);\n\tc_can_hw_raminit_wait(priv, ctrl);\n\n\tif (enable) {\n\t\tctrl |= DCAN_RAM_INIT_BIT;\n\t\tpriv->write_reg32(priv, C_CAN_FUNCTION_REG, ctrl);\n\t\tc_can_hw_raminit_wait(priv, ctrl);\n\t}\n}\n\nstatic const struct c_can_driver_data c_can_drvdata = {\n\t.id = BOSCH_C_CAN,\n\t.msg_obj_num = 32,\n};\n\nstatic const struct c_can_driver_data d_can_drvdata = {\n\t.id = BOSCH_D_CAN,\n\t.msg_obj_num = 32,\n};\n\nstatic const struct raminit_bits dra7_raminit_bits[] = {\n\t[0] = { .start = 3, .done = 1, },\n\t[1] = { .start = 5, .done = 2, },\n};\n\nstatic const struct c_can_driver_data dra7_dcan_drvdata = {\n\t.id = BOSCH_D_CAN,\n\t.msg_obj_num = 64,\n\t.raminit_num = ARRAY_SIZE(dra7_raminit_bits),\n\t.raminit_bits = dra7_raminit_bits,\n\t.raminit_pulse = true,\n};\n\nstatic const struct raminit_bits am3352_raminit_bits[] = {\n\t[0] = { .start = 0, .done = 8, },\n\t[1] = { .start = 1, .done = 9, },\n};\n\nstatic const struct c_can_driver_data am3352_dcan_drvdata = {\n\t.id = BOSCH_D_CAN,\n\t.msg_obj_num = 64,\n\t.raminit_num = ARRAY_SIZE(am3352_raminit_bits),\n\t.raminit_bits = am3352_raminit_bits,\n};\n\nstatic const struct platform_device_id c_can_id_table[] = {\n\t{\n\t\t.name = KBUILD_MODNAME,\n\t\t.driver_data = (kernel_ulong_t)&c_can_drvdata,\n\t},\n\t{\n\t\t.name = \"c_can\",\n\t\t.driver_data = (kernel_ulong_t)&c_can_drvdata,\n\t},\n\t{\n\t\t.name = \"d_can\",\n\t\t.driver_data = (kernel_ulong_t)&d_can_drvdata,\n\t},\n\t{   },\n};\nMODULE_DEVICE_TABLE(platform, c_can_id_table);\n\nstatic const struct of_device_id c_can_of_table[] = {\n\t{ .compatible = \"bosch,c_can\", .data = &c_can_drvdata },\n\t{ .compatible = \"bosch,d_can\", .data = &d_can_drvdata },\n\t{ .compatible = \"ti,dra7-d_can\", .data = &dra7_dcan_drvdata },\n\t{ .compatible = \"ti,am3352-d_can\", .data = &am3352_dcan_drvdata },\n\t{ .compatible = \"ti,am4372-d_can\", .data = &am3352_dcan_drvdata },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, c_can_of_table);\n\nstatic int c_can_plat_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tvoid __iomem *addr;\n\tstruct net_device *dev;\n\tstruct c_can_priv *priv;\n\tconst struct of_device_id *match;\n\tstruct resource *mem;\n\tint irq;\n\tstruct clk *clk;\n\tconst struct c_can_driver_data *drvdata;\n\tstruct device_node *np = pdev->dev.of_node;\n\n\tmatch = of_match_device(c_can_of_table, &pdev->dev);\n\tif (match) {\n\t\tdrvdata = match->data;\n\t} else if (pdev->id_entry->driver_data) {\n\t\tdrvdata = (struct c_can_driver_data *)\n\t\t\tplatform_get_device_id(pdev)->driver_data;\n\t} else {\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tclk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tgoto exit;\n\t}\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto exit;\n\t}\n\n\taddr = devm_platform_get_and_ioremap_resource(pdev, 0, &mem);\n\tif (IS_ERR(addr)) {\n\t\tret =  PTR_ERR(addr);\n\t\tgoto exit;\n\t}\n\n\t \n\tdev = alloc_c_can_dev(drvdata->msg_obj_num);\n\tif (!dev) {\n\t\tret = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tpriv = netdev_priv(dev);\n\tswitch (drvdata->id) {\n\tcase BOSCH_C_CAN:\n\t\tpriv->regs = reg_map_c_can;\n\t\tswitch (mem->flags & IORESOURCE_MEM_TYPE_MASK) {\n\t\tcase IORESOURCE_MEM_32BIT:\n\t\t\tpriv->read_reg = c_can_plat_read_reg_aligned_to_32bit;\n\t\t\tpriv->write_reg = c_can_plat_write_reg_aligned_to_32bit;\n\t\t\tpriv->read_reg32 = c_can_plat_read_reg32;\n\t\t\tpriv->write_reg32 = c_can_plat_write_reg32;\n\t\t\tbreak;\n\t\tcase IORESOURCE_MEM_16BIT:\n\t\tdefault:\n\t\t\tpriv->read_reg = c_can_plat_read_reg_aligned_to_16bit;\n\t\t\tpriv->write_reg = c_can_plat_write_reg_aligned_to_16bit;\n\t\t\tpriv->read_reg32 = c_can_plat_read_reg32;\n\t\t\tpriv->write_reg32 = c_can_plat_write_reg32;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BOSCH_D_CAN:\n\t\tpriv->regs = reg_map_d_can;\n\t\tpriv->read_reg = c_can_plat_read_reg_aligned_to_16bit;\n\t\tpriv->write_reg = c_can_plat_write_reg_aligned_to_16bit;\n\t\tpriv->read_reg32 = d_can_plat_read_reg32;\n\t\tpriv->write_reg32 = d_can_plat_write_reg32;\n\n\t\t \n\t\tif (np && of_property_read_bool(np, \"syscon-raminit\")) {\n\t\t\tu32 id;\n\t\t\tstruct c_can_raminit *raminit = &priv->raminit_sys;\n\n\t\t\tret = -EINVAL;\n\t\t\traminit->syscon = syscon_regmap_lookup_by_phandle(np,\n\t\t\t\t\t\t\t\t\t  \"syscon-raminit\");\n\t\t\tif (IS_ERR(raminit->syscon)) {\n\t\t\t\t \n\t\t\t\tret = PTR_ERR(raminit->syscon);\n\t\t\t\tfree_c_can_dev(dev);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tif (of_property_read_u32_index(np, \"syscon-raminit\", 1,\n\t\t\t\t\t\t       &raminit->reg)) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"couldn't get the RAMINIT reg. offset!\\n\");\n\t\t\t\tgoto exit_free_device;\n\t\t\t}\n\n\t\t\tif (of_property_read_u32_index(np, \"syscon-raminit\", 2,\n\t\t\t\t\t\t       &id)) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"couldn't get the CAN instance ID\\n\");\n\t\t\t\tgoto exit_free_device;\n\t\t\t}\n\n\t\t\tif (id >= drvdata->raminit_num) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"Invalid CAN instance ID\\n\");\n\t\t\t\tgoto exit_free_device;\n\t\t\t}\n\n\t\t\traminit->bits = drvdata->raminit_bits[id];\n\t\t\traminit->needs_pulse = drvdata->raminit_pulse;\n\n\t\t\tpriv->raminit = c_can_hw_raminit_syscon;\n\t\t} else {\n\t\t\tpriv->raminit = c_can_hw_raminit;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto exit_free_device;\n\t}\n\n\tdev->irq = irq;\n\tpriv->base = addr;\n\tpriv->device = &pdev->dev;\n\tpriv->can.clock.freq = clk_get_rate(clk);\n\tpriv->type = drvdata->id;\n\n\tplatform_set_drvdata(pdev, dev);\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\tpm_runtime_enable(priv->device);\n\tret = register_c_can_dev(dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"registering %s failed (err=%d)\\n\",\n\t\t\tKBUILD_MODNAME, ret);\n\t\tgoto exit_free_device;\n\t}\n\n\tdev_info(&pdev->dev, \"%s device registered (regs=%p, irq=%d)\\n\",\n\t\t KBUILD_MODNAME, priv->base, dev->irq);\n\treturn 0;\n\nexit_free_device:\n\tpm_runtime_disable(priv->device);\n\tfree_c_can_dev(dev);\nexit:\n\tdev_err(&pdev->dev, \"probe failed\\n\");\n\n\treturn ret;\n}\n\nstatic void c_can_plat_remove(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\n\tunregister_c_can_dev(dev);\n\tpm_runtime_disable(priv->device);\n\tfree_c_can_dev(dev);\n}\n\n#ifdef CONFIG_PM\nstatic int c_can_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\tint ret;\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct c_can_priv *priv = netdev_priv(ndev);\n\n\tif (priv->type != BOSCH_D_CAN) {\n\t\tdev_warn(&pdev->dev, \"Not supported\\n\");\n\t\treturn 0;\n\t}\n\n\tif (netif_running(ndev)) {\n\t\tnetif_stop_queue(ndev);\n\t\tnetif_device_detach(ndev);\n\t}\n\n\tret = c_can_power_down(ndev);\n\tif (ret) {\n\t\tnetdev_err(ndev, \"failed to enter power down mode\\n\");\n\t\treturn ret;\n\t}\n\n\tpriv->can.state = CAN_STATE_SLEEPING;\n\n\treturn 0;\n}\n\nstatic int c_can_resume(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct c_can_priv *priv = netdev_priv(ndev);\n\n\tif (priv->type != BOSCH_D_CAN) {\n\t\tdev_warn(&pdev->dev, \"Not supported\\n\");\n\t\treturn 0;\n\t}\n\n\tret = c_can_power_up(ndev);\n\tif (ret) {\n\t\tnetdev_err(ndev, \"Still in power down mode\\n\");\n\t\treturn ret;\n\t}\n\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\tif (netif_running(ndev)) {\n\t\tnetif_device_attach(ndev);\n\t\tnetif_start_queue(ndev);\n\t}\n\n\treturn 0;\n}\n#else\n#define c_can_suspend NULL\n#define c_can_resume NULL\n#endif\n\nstatic struct platform_driver c_can_plat_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = c_can_of_table,\n\t},\n\t.probe = c_can_plat_probe,\n\t.remove_new = c_can_plat_remove,\n\t.suspend = c_can_suspend,\n\t.resume = c_can_resume,\n\t.id_table = c_can_id_table,\n};\n\nmodule_platform_driver(c_can_plat_driver);\n\nMODULE_AUTHOR(\"Bhupesh Sharma <bhupesh.sharma@st.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Platform CAN bus driver for Bosch C_CAN controller\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}