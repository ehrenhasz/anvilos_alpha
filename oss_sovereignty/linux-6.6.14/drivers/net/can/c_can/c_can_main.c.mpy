{
  "module_name": "c_can_main.c",
  "hash_id": "d3385563d8e616686220f5f0fec98a68c1415905eb760e3c266e6c4f4944c327",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/c_can/c_can_main.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/pm_runtime.h>\n#include <linux/pinctrl/consumer.h>\n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n\n#include \"c_can.h\"\n\n \n#define IF_ENUM_REG_LEN\t\t11\n#define C_CAN_IFACE(reg, iface)\t(C_CAN_IF1_##reg + (iface) * IF_ENUM_REG_LEN)\n\n \n#define CONTROL_EX_PDR\t\tBIT(8)\n\n \n#define CONTROL_SWR\t\tBIT(15)\n#define CONTROL_TEST\t\tBIT(7)\n#define CONTROL_CCE\t\tBIT(6)\n#define CONTROL_DISABLE_AR\tBIT(5)\n#define CONTROL_ENABLE_AR\t(0 << 5)\n#define CONTROL_EIE\t\tBIT(3)\n#define CONTROL_SIE\t\tBIT(2)\n#define CONTROL_IE\t\tBIT(1)\n#define CONTROL_INIT\t\tBIT(0)\n\n#define CONTROL_IRQMSK\t\t(CONTROL_EIE | CONTROL_IE | CONTROL_SIE)\n\n \n#define TEST_RX\t\t\tBIT(7)\n#define TEST_TX1\t\tBIT(6)\n#define TEST_TX2\t\tBIT(5)\n#define TEST_LBACK\t\tBIT(4)\n#define TEST_SILENT\t\tBIT(3)\n#define TEST_BASIC\t\tBIT(2)\n\n \n#define STATUS_PDA\t\tBIT(10)\n#define STATUS_BOFF\t\tBIT(7)\n#define STATUS_EWARN\t\tBIT(6)\n#define STATUS_EPASS\t\tBIT(5)\n#define STATUS_RXOK\t\tBIT(4)\n#define STATUS_TXOK\t\tBIT(3)\n\n \n#define ERR_CNT_TEC_MASK\t0xff\n#define ERR_CNT_TEC_SHIFT\t0\n#define ERR_CNT_REC_SHIFT\t8\n#define ERR_CNT_REC_MASK\t(0x7f << ERR_CNT_REC_SHIFT)\n#define ERR_CNT_RP_SHIFT\t15\n#define ERR_CNT_RP_MASK\t\t(0x1 << ERR_CNT_RP_SHIFT)\n\n \n#define BTR_BRP_MASK\t\t0x3f\n#define BTR_BRP_SHIFT\t\t0\n#define BTR_SJW_SHIFT\t\t6\n#define BTR_SJW_MASK\t\t(0x3 << BTR_SJW_SHIFT)\n#define BTR_TSEG1_SHIFT\t\t8\n#define BTR_TSEG1_MASK\t\t(0xf << BTR_TSEG1_SHIFT)\n#define BTR_TSEG2_SHIFT\t\t12\n#define BTR_TSEG2_MASK\t\t(0x7 << BTR_TSEG2_SHIFT)\n\n \n#define INT_STS_PENDING\t\t0x8000\n\n \n#define BRP_EXT_BRPE_MASK\t0x0f\n#define BRP_EXT_BRPE_SHIFT\t0\n\n \n#define IF_COMR_BUSY\t\tBIT(15)\n\n \n#define IF_COMM_WR\t\tBIT(7)\n#define IF_COMM_MASK\t\tBIT(6)\n#define IF_COMM_ARB\t\tBIT(5)\n#define IF_COMM_CONTROL\t\tBIT(4)\n#define IF_COMM_CLR_INT_PND\tBIT(3)\n#define IF_COMM_TXRQST\t\tBIT(2)\n#define IF_COMM_CLR_NEWDAT\tIF_COMM_TXRQST\n#define IF_COMM_DATAA\t\tBIT(1)\n#define IF_COMM_DATAB\t\tBIT(0)\n\n \n#define IF_COMM_TX\t\t(IF_COMM_ARB | IF_COMM_CONTROL | \\\n\t\t\t\t IF_COMM_TXRQST |\t\t \\\n\t\t\t\t IF_COMM_DATAA | IF_COMM_DATAB)\n\n \n#define IF_COMM_RCV_LOW\t\t(IF_COMM_MASK | IF_COMM_ARB | \\\n\t\t\t\t IF_COMM_CONTROL | IF_COMM_CLR_INT_PND | \\\n\t\t\t\t IF_COMM_DATAA | IF_COMM_DATAB)\n\n \n#define IF_COMM_RCV_HIGH\t(IF_COMM_RCV_LOW | IF_COMM_CLR_NEWDAT)\n\n \n#define IF_COMM_RCV_SETUP\t(IF_COMM_MASK | IF_COMM_ARB | IF_COMM_CONTROL)\n\n \n#define IF_COMM_INVAL\t\t(IF_COMM_ARB | IF_COMM_CONTROL)\n\n \n#define IF_ARB_MSGVAL\t\tBIT(31)\n#define IF_ARB_MSGXTD\t\tBIT(30)\n#define IF_ARB_TRANSMIT\t\tBIT(29)\n\n \n#define IF_MCONT_NEWDAT\t\tBIT(15)\n#define IF_MCONT_MSGLST\t\tBIT(14)\n#define IF_MCONT_INTPND\t\tBIT(13)\n#define IF_MCONT_UMASK\t\tBIT(12)\n#define IF_MCONT_TXIE\t\tBIT(11)\n#define IF_MCONT_RXIE\t\tBIT(10)\n#define IF_MCONT_RMTEN\t\tBIT(9)\n#define IF_MCONT_TXRQST\t\tBIT(8)\n#define IF_MCONT_EOB\t\tBIT(7)\n#define IF_MCONT_DLC_MASK\t0xf\n\n#define IF_MCONT_RCV\t\t(IF_MCONT_RXIE | IF_MCONT_UMASK)\n#define IF_MCONT_RCV_EOB\t(IF_MCONT_RCV | IF_MCONT_EOB)\n\n#define IF_MCONT_TX\t\t(IF_MCONT_TXIE | IF_MCONT_EOB)\n\n \n#define IF_NAPI\t\t\t0\n#define IF_TX\t\t\t1\n\n \n#define MIN_TIMEOUT_VALUE\t6\n\n \n#define INIT_WAIT_MS\t\t1000\n\n \nenum c_can_lec_type {\n\tLEC_NO_ERROR = 0,\n\tLEC_STUFF_ERROR,\n\tLEC_FORM_ERROR,\n\tLEC_ACK_ERROR,\n\tLEC_BIT1_ERROR,\n\tLEC_BIT0_ERROR,\n\tLEC_CRC_ERROR,\n\tLEC_UNUSED,\n\tLEC_MASK = LEC_UNUSED,\n};\n\n \nenum c_can_bus_error_types {\n\tC_CAN_NO_ERROR = 0,\n\tC_CAN_BUS_OFF,\n\tC_CAN_ERROR_WARNING,\n\tC_CAN_ERROR_PASSIVE,\n};\n\nstatic const struct can_bittiming_const c_can_bittiming_const = {\n\t.name = KBUILD_MODNAME,\n\t.tseg1_min = 2,\t\t \n\t.tseg1_max = 16,\n\t.tseg2_min = 1,\t\t \n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 1024,\t \n\t.brp_inc = 1,\n};\n\nstatic inline void c_can_pm_runtime_get_sync(const struct c_can_priv *priv)\n{\n\tif (priv->device)\n\t\tpm_runtime_get_sync(priv->device);\n}\n\nstatic inline void c_can_pm_runtime_put_sync(const struct c_can_priv *priv)\n{\n\tif (priv->device)\n\t\tpm_runtime_put_sync(priv->device);\n}\n\nstatic inline void c_can_reset_ram(const struct c_can_priv *priv, bool enable)\n{\n\tif (priv->raminit)\n\t\tpriv->raminit(priv, enable);\n}\n\nstatic void c_can_irq_control(struct c_can_priv *priv, bool enable)\n{\n\tu32 ctrl = priv->read_reg(priv,\tC_CAN_CTRL_REG) & ~CONTROL_IRQMSK;\n\n\tif (enable)\n\t\tctrl |= CONTROL_IRQMSK;\n\n\tpriv->write_reg(priv, C_CAN_CTRL_REG, ctrl);\n}\n\nstatic void c_can_obj_update(struct net_device *dev, int iface, u32 cmd, u32 obj)\n{\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\tint cnt, reg = C_CAN_IFACE(COMREQ_REG, iface);\n\n\tpriv->write_reg32(priv, reg, (cmd << 16) | obj);\n\n\tfor (cnt = MIN_TIMEOUT_VALUE; cnt; cnt--) {\n\t\tif (!(priv->read_reg(priv, reg) & IF_COMR_BUSY))\n\t\t\treturn;\n\t\tudelay(1);\n\t}\n\tnetdev_err(dev, \"Updating object timed out\\n\");\n}\n\nstatic inline void c_can_object_get(struct net_device *dev, int iface,\n\t\t\t\t    u32 obj, u32 cmd)\n{\n\tc_can_obj_update(dev, iface, cmd, obj);\n}\n\nstatic inline void c_can_object_put(struct net_device *dev, int iface,\n\t\t\t\t    u32 obj, u32 cmd)\n{\n\tc_can_obj_update(dev, iface, cmd | IF_COMM_WR, obj);\n}\n\n \nstatic void c_can_inval_tx_object(struct net_device *dev, int iface, int obj)\n{\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\n\tpriv->write_reg(priv, C_CAN_IFACE(MSGCTRL_REG, iface), 0);\n\tc_can_object_put(dev, iface, obj, IF_COMM_INVAL);\n}\n\nstatic void c_can_inval_msg_object(struct net_device *dev, int iface, int obj)\n{\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\n\tpriv->write_reg32(priv, C_CAN_IFACE(ARB1_REG, iface), 0);\n\tc_can_inval_tx_object(dev, iface, obj);\n}\n\nstatic void c_can_setup_tx_object(struct net_device *dev, int iface,\n\t\t\t\t  struct can_frame *frame, int idx)\n{\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\tu16 ctrl = IF_MCONT_TX | frame->len;\n\tbool rtr = frame->can_id & CAN_RTR_FLAG;\n\tu32 arb = IF_ARB_MSGVAL;\n\tint i;\n\n\tif (frame->can_id & CAN_EFF_FLAG) {\n\t\tarb |= frame->can_id & CAN_EFF_MASK;\n\t\tarb |= IF_ARB_MSGXTD;\n\t} else {\n\t\tarb |= (frame->can_id & CAN_SFF_MASK) << 18;\n\t}\n\n\tif (!rtr)\n\t\tarb |= IF_ARB_TRANSMIT;\n\n\t \n\tif (rtr != (bool)test_bit(idx, &priv->tx_dir)) {\n\t\tu32 obj = idx + priv->msg_obj_tx_first;\n\n\t\tc_can_inval_msg_object(dev, iface, obj);\n\t\tchange_bit(idx, &priv->tx_dir);\n\t}\n\n\tpriv->write_reg32(priv, C_CAN_IFACE(ARB1_REG, iface), arb);\n\n\tpriv->write_reg(priv, C_CAN_IFACE(MSGCTRL_REG, iface), ctrl);\n\n\tif (priv->type == BOSCH_D_CAN) {\n\t\tu32 data = 0, dreg = C_CAN_IFACE(DATA1_REG, iface);\n\n\t\tfor (i = 0; i < frame->len; i += 4, dreg += 2) {\n\t\t\tdata = (u32)frame->data[i];\n\t\t\tdata |= (u32)frame->data[i + 1] << 8;\n\t\t\tdata |= (u32)frame->data[i + 2] << 16;\n\t\t\tdata |= (u32)frame->data[i + 3] << 24;\n\t\t\tpriv->write_reg32(priv, dreg, data);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < frame->len; i += 2) {\n\t\t\tpriv->write_reg(priv,\n\t\t\t\t\tC_CAN_IFACE(DATA1_REG, iface) + i / 2,\n\t\t\t\t\tframe->data[i] |\n\t\t\t\t\t(frame->data[i + 1] << 8));\n\t\t}\n\t}\n}\n\nstatic int c_can_handle_lost_msg_obj(struct net_device *dev,\n\t\t\t\t     int iface, int objno, u32 ctrl)\n{\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\tstruct can_frame *frame;\n\tstruct sk_buff *skb;\n\n\tctrl &= ~(IF_MCONT_MSGLST | IF_MCONT_INTPND | IF_MCONT_NEWDAT);\n\tpriv->write_reg(priv, C_CAN_IFACE(MSGCTRL_REG, iface), ctrl);\n\tc_can_object_put(dev, iface, objno, IF_COMM_CONTROL);\n\n\tstats->rx_errors++;\n\tstats->rx_over_errors++;\n\n\t \n\tskb = alloc_can_err_skb(dev, &frame);\n\tif (unlikely(!skb))\n\t\treturn 0;\n\n\tframe->can_id |= CAN_ERR_CRTL;\n\tframe->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\n\tnetif_receive_skb(skb);\n\treturn 1;\n}\n\nstatic int c_can_read_msg_object(struct net_device *dev, int iface, u32 ctrl)\n{\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\tstruct can_frame *frame;\n\tstruct sk_buff *skb;\n\tu32 arb, data;\n\n\tskb = alloc_can_skb(dev, &frame);\n\tif (!skb) {\n\t\tstats->rx_dropped++;\n\t\treturn -ENOMEM;\n\t}\n\n\tframe->len = can_cc_dlc2len(ctrl & 0x0F);\n\n\tarb = priv->read_reg32(priv, C_CAN_IFACE(ARB1_REG, iface));\n\n\tif (arb & IF_ARB_MSGXTD)\n\t\tframe->can_id = (arb & CAN_EFF_MASK) | CAN_EFF_FLAG;\n\telse\n\t\tframe->can_id = (arb >> 18) & CAN_SFF_MASK;\n\n\tif (arb & IF_ARB_TRANSMIT) {\n\t\tframe->can_id |= CAN_RTR_FLAG;\n\t} else {\n\t\tint i, dreg = C_CAN_IFACE(DATA1_REG, iface);\n\n\t\tif (priv->type == BOSCH_D_CAN) {\n\t\t\tfor (i = 0; i < frame->len; i += 4, dreg += 2) {\n\t\t\t\tdata = priv->read_reg32(priv, dreg);\n\t\t\t\tframe->data[i] = data;\n\t\t\t\tframe->data[i + 1] = data >> 8;\n\t\t\t\tframe->data[i + 2] = data >> 16;\n\t\t\t\tframe->data[i + 3] = data >> 24;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < frame->len; i += 2, dreg++) {\n\t\t\t\tdata = priv->read_reg(priv, dreg);\n\t\t\t\tframe->data[i] = data;\n\t\t\t\tframe->data[i + 1] = data >> 8;\n\t\t\t}\n\t\t}\n\n\t\tstats->rx_bytes += frame->len;\n\t}\n\tstats->rx_packets++;\n\n\tnetif_receive_skb(skb);\n\treturn 0;\n}\n\nstatic void c_can_setup_receive_object(struct net_device *dev, int iface,\n\t\t\t\t       u32 obj, u32 mask, u32 id, u32 mcont)\n{\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\n\tmask |= BIT(29);\n\tpriv->write_reg32(priv, C_CAN_IFACE(MASK1_REG, iface), mask);\n\n\tid |= IF_ARB_MSGVAL;\n\tpriv->write_reg32(priv, C_CAN_IFACE(ARB1_REG, iface), id);\n\n\tpriv->write_reg(priv, C_CAN_IFACE(MSGCTRL_REG, iface), mcont);\n\tc_can_object_put(dev, iface, obj, IF_COMM_RCV_SETUP);\n}\n\nstatic bool c_can_tx_busy(const struct c_can_priv *priv,\n\t\t\t  const struct c_can_tx_ring *tx_ring)\n{\n\tif (c_can_get_tx_free(priv, tx_ring) > 0)\n\t\treturn false;\n\n\tnetif_stop_queue(priv->dev);\n\n\t \n\tsmp_mb();\n\n\tif (c_can_get_tx_free(priv, tx_ring) == 0) {\n\t\tnetdev_dbg(priv->dev,\n\t\t\t   \"Stopping tx-queue (tx_head=0x%08x, tx_tail=0x%08x, len=%d).\\n\",\n\t\t\t   tx_ring->head, tx_ring->tail,\n\t\t\t   tx_ring->head - tx_ring->tail);\n\t\treturn true;\n\t}\n\n\tnetif_start_queue(priv->dev);\n\treturn false;\n}\n\nstatic netdev_tx_t c_can_start_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *dev)\n{\n\tstruct can_frame *frame = (struct can_frame *)skb->data;\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\tstruct c_can_tx_ring *tx_ring = &priv->tx;\n\tu32 idx, obj, cmd = IF_COMM_TX;\n\n\tif (can_dev_dropped_skb(dev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tif (c_can_tx_busy(priv, tx_ring))\n\t\treturn NETDEV_TX_BUSY;\n\n\tidx = c_can_get_tx_head(tx_ring);\n\ttx_ring->head++;\n\tif (c_can_get_tx_free(priv, tx_ring) == 0)\n\t\tnetif_stop_queue(dev);\n\n\tif (idx < c_can_get_tx_tail(tx_ring))\n\t\tcmd &= ~IF_COMM_TXRQST;  \n\n\t \n\tc_can_setup_tx_object(dev, IF_TX, frame, idx);\n\tcan_put_echo_skb(skb, dev, idx, 0);\n\tobj = idx + priv->msg_obj_tx_first;\n\tc_can_object_put(dev, IF_TX, obj, cmd);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int c_can_wait_for_ctrl_init(struct net_device *dev,\n\t\t\t\t    struct c_can_priv *priv, u32 init)\n{\n\tint retry = 0;\n\n\twhile (init != (priv->read_reg(priv, C_CAN_CTRL_REG) & CONTROL_INIT)) {\n\t\tudelay(10);\n\t\tif (retry++ > 1000) {\n\t\t\tnetdev_err(dev, \"CCTRL: set CONTROL_INIT failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int c_can_set_bittiming(struct net_device *dev)\n{\n\tunsigned int reg_btr, reg_brpe, ctrl_save;\n\tu8 brp, brpe, sjw, tseg1, tseg2;\n\tu32 ten_bit_brp;\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\tconst struct can_bittiming *bt = &priv->can.bittiming;\n\tint res;\n\n\t \n\tten_bit_brp = bt->brp - 1;\n\tbrp = ten_bit_brp & BTR_BRP_MASK;\n\tbrpe = ten_bit_brp >> 6;\n\n\tsjw = bt->sjw - 1;\n\ttseg1 = bt->prop_seg + bt->phase_seg1 - 1;\n\ttseg2 = bt->phase_seg2 - 1;\n\treg_btr = brp | (sjw << BTR_SJW_SHIFT) | (tseg1 << BTR_TSEG1_SHIFT) |\n\t\t\t(tseg2 << BTR_TSEG2_SHIFT);\n\treg_brpe = brpe & BRP_EXT_BRPE_MASK;\n\n\tnetdev_info(dev,\n\t\t    \"setting BTR=%04x BRPE=%04x\\n\", reg_btr, reg_brpe);\n\n\tctrl_save = priv->read_reg(priv, C_CAN_CTRL_REG);\n\tctrl_save &= ~CONTROL_INIT;\n\tpriv->write_reg(priv, C_CAN_CTRL_REG, CONTROL_CCE | CONTROL_INIT);\n\tres = c_can_wait_for_ctrl_init(dev, priv, CONTROL_INIT);\n\tif (res)\n\t\treturn res;\n\n\tpriv->write_reg(priv, C_CAN_BTR_REG, reg_btr);\n\tpriv->write_reg(priv, C_CAN_BRPEXT_REG, reg_brpe);\n\tpriv->write_reg(priv, C_CAN_CTRL_REG, ctrl_save);\n\n\treturn c_can_wait_for_ctrl_init(dev, priv, 0);\n}\n\n \nstatic void c_can_configure_msg_objects(struct net_device *dev)\n{\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\tint i;\n\n\t \n\tfor (i = priv->msg_obj_rx_first; i <= priv->msg_obj_num; i++)\n\t\tc_can_inval_msg_object(dev, IF_NAPI, i);\n\n\t \n\tfor (i = priv->msg_obj_rx_first; i < priv->msg_obj_rx_last; i++)\n\t\tc_can_setup_receive_object(dev, IF_NAPI, i, 0, 0, IF_MCONT_RCV);\n\n\tc_can_setup_receive_object(dev, IF_NAPI, priv->msg_obj_rx_last, 0, 0,\n\t\t\t\t   IF_MCONT_RCV_EOB);\n}\n\nstatic int c_can_software_reset(struct net_device *dev)\n{\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\tint retry = 0;\n\n\tif (priv->type != BOSCH_D_CAN)\n\t\treturn 0;\n\n\tpriv->write_reg(priv, C_CAN_CTRL_REG, CONTROL_SWR | CONTROL_INIT);\n\twhile (priv->read_reg(priv, C_CAN_CTRL_REG) & CONTROL_SWR) {\n\t\tmsleep(20);\n\t\tif (retry++ > 100) {\n\t\t\tnetdev_err(dev, \"CCTRL: software reset failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int c_can_chip_config(struct net_device *dev)\n{\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\tstruct c_can_tx_ring *tx_ring = &priv->tx;\n\tint err;\n\n\terr = c_can_software_reset(dev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tpriv->write_reg(priv, C_CAN_CTRL_REG, CONTROL_ENABLE_AR);\n\n\tif ((priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY) &&\n\t    (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)) {\n\t\t \n\t\tpriv->write_reg(priv, C_CAN_CTRL_REG, CONTROL_TEST);\n\t\tpriv->write_reg(priv, C_CAN_TEST_REG, TEST_LBACK | TEST_SILENT);\n\t} else if (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK) {\n\t\t \n\t\tpriv->write_reg(priv, C_CAN_CTRL_REG, CONTROL_TEST);\n\t\tpriv->write_reg(priv, C_CAN_TEST_REG, TEST_LBACK);\n\t} else if (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY) {\n\t\t \n\t\tpriv->write_reg(priv, C_CAN_CTRL_REG, CONTROL_TEST);\n\t\tpriv->write_reg(priv, C_CAN_TEST_REG, TEST_SILENT);\n\t}\n\n\t \n\tc_can_configure_msg_objects(dev);\n\n\t \n\tpriv->write_reg(priv, C_CAN_STS_REG, LEC_UNUSED);\n\n\t \n\ttx_ring->head = 0;\n\ttx_ring->tail = 0;\n\tpriv->tx_dir = 0;\n\n\t \n\treturn c_can_set_bittiming(dev);\n}\n\nstatic int c_can_start(struct net_device *dev)\n{\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\tint err;\n\tstruct pinctrl *p;\n\n\t \n\terr = c_can_chip_config(dev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tpriv->comm_rcv_high = priv->type != BOSCH_D_CAN ?\n\t\tIF_COMM_RCV_LOW : IF_COMM_RCV_HIGH;\n\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\t \n\tp = pinctrl_get_select(priv->device, \"active\");\n\tif (!IS_ERR(p))\n\t\tpinctrl_put(p);\n\telse\n\t\tpinctrl_pm_select_default_state(priv->device);\n\n\treturn 0;\n}\n\nstatic void c_can_stop(struct net_device *dev)\n{\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\n\tc_can_irq_control(priv, false);\n\n\t \n\tpriv->write_reg(priv, C_CAN_CTRL_REG, CONTROL_INIT);\n\n\t \n\tpinctrl_pm_select_sleep_state(dev->dev.parent);\n\tpriv->can.state = CAN_STATE_STOPPED;\n}\n\nstatic int c_can_set_mode(struct net_device *dev, enum can_mode mode)\n{\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\tint err;\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\terr = c_can_start(dev);\n\t\tif (err)\n\t\t\treturn err;\n\t\tnetif_wake_queue(dev);\n\t\tc_can_irq_control(priv, true);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int __c_can_get_berr_counter(const struct net_device *dev,\n\t\t\t\t    struct can_berr_counter *bec)\n{\n\tunsigned int reg_err_counter;\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\n\treg_err_counter = priv->read_reg(priv, C_CAN_ERR_CNT_REG);\n\tbec->rxerr = (reg_err_counter & ERR_CNT_REC_MASK) >>\n\t\t\t\tERR_CNT_REC_SHIFT;\n\tbec->txerr = reg_err_counter & ERR_CNT_TEC_MASK;\n\n\treturn 0;\n}\n\nstatic int c_can_get_berr_counter(const struct net_device *dev,\n\t\t\t\t  struct can_berr_counter *bec)\n{\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\tint err;\n\n\tc_can_pm_runtime_get_sync(priv);\n\terr = __c_can_get_berr_counter(dev, bec);\n\tc_can_pm_runtime_put_sync(priv);\n\n\treturn err;\n}\n\nstatic void c_can_do_tx(struct net_device *dev)\n{\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\tstruct c_can_tx_ring *tx_ring = &priv->tx;\n\tstruct net_device_stats *stats = &dev->stats;\n\tu32 idx, obj, pkts = 0, bytes = 0, pend;\n\tu8 tail;\n\n\tif (priv->msg_obj_tx_last > 32)\n\t\tpend = priv->read_reg32(priv, C_CAN_INTPND3_REG);\n\telse\n\t\tpend = priv->read_reg(priv, C_CAN_INTPND2_REG);\n\n\twhile ((idx = ffs(pend))) {\n\t\tidx--;\n\t\tpend &= ~BIT(idx);\n\t\tobj = idx + priv->msg_obj_tx_first;\n\n\t\t \n\t\tc_can_inval_tx_object(dev, IF_NAPI, obj);\n\t\tbytes += can_get_echo_skb(dev, idx, NULL);\n\t\tpkts++;\n\t}\n\n\tif (!pkts)\n\t\treturn;\n\n\ttx_ring->tail += pkts;\n\tif (c_can_get_tx_free(priv, tx_ring)) {\n\t\t \n\t\tsmp_mb();\n\t\tnetif_wake_queue(priv->dev);\n\t}\n\n\tstats->tx_bytes += bytes;\n\tstats->tx_packets += pkts;\n\n\ttail = c_can_get_tx_tail(tx_ring);\n\tif (priv->type == BOSCH_D_CAN && tail == 0) {\n\t\tu8 head = c_can_get_tx_head(tx_ring);\n\n\t\t \n\t\tfor (idx = tail; idx < head; idx++) {\n\t\t\tobj = idx + priv->msg_obj_tx_first;\n\t\t\tc_can_object_put(dev, IF_NAPI, obj, IF_COMM_TXRQST);\n\t\t}\n\t}\n}\n\n \nstatic u32 c_can_adjust_pending(u32 pend, u32 rx_mask)\n{\n\tu32 weight, lasts;\n\n\tif (pend == rx_mask)\n\t\treturn pend;\n\n\t \n\tweight = hweight32(pend);\n\tlasts = fls(pend);\n\n\t \n\tif (lasts == weight)\n\t\treturn pend;\n\n\t \n\tfor (lasts--; pend & BIT(lasts - 1); lasts--)\n\t\t;\n\n\treturn pend & ~GENMASK(lasts - 1, 0);\n}\n\nstatic inline void c_can_rx_object_get(struct net_device *dev,\n\t\t\t\t       struct c_can_priv *priv, u32 obj)\n{\n\tc_can_object_get(dev, IF_NAPI, obj, priv->comm_rcv_high);\n}\n\nstatic inline void c_can_rx_finalize(struct net_device *dev,\n\t\t\t\t     struct c_can_priv *priv, u32 obj)\n{\n\tif (priv->type != BOSCH_D_CAN)\n\t\tc_can_object_get(dev, IF_NAPI, obj, IF_COMM_CLR_NEWDAT);\n}\n\nstatic int c_can_read_objects(struct net_device *dev, struct c_can_priv *priv,\n\t\t\t      u32 pend, int quota)\n{\n\tu32 pkts = 0, ctrl, obj;\n\n\twhile ((obj = ffs(pend)) && quota > 0) {\n\t\tpend &= ~BIT(obj - 1);\n\n\t\tc_can_rx_object_get(dev, priv, obj);\n\t\tctrl = priv->read_reg(priv, C_CAN_IFACE(MSGCTRL_REG, IF_NAPI));\n\n\t\tif (ctrl & IF_MCONT_MSGLST) {\n\t\t\tint n;\n\n\t\t\tn = c_can_handle_lost_msg_obj(dev, IF_NAPI, obj, ctrl);\n\n\t\t\tpkts += n;\n\t\t\tquota -= n;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!(ctrl & IF_MCONT_NEWDAT))\n\t\t\tcontinue;\n\n\t\t \n\t\tc_can_read_msg_object(dev, IF_NAPI, ctrl);\n\n\t\tc_can_rx_finalize(dev, priv, obj);\n\n\t\tpkts++;\n\t\tquota--;\n\t}\n\n\treturn pkts;\n}\n\nstatic inline u32 c_can_get_pending(struct c_can_priv *priv)\n{\n\tu32 pend;\n\n\tif (priv->msg_obj_rx_last > 16)\n\t\tpend = priv->read_reg32(priv, C_CAN_NEWDAT1_REG);\n\telse\n\t\tpend = priv->read_reg(priv, C_CAN_NEWDAT1_REG);\n\n\treturn pend;\n}\n\n \nstatic int c_can_do_rx_poll(struct net_device *dev, int quota)\n{\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\tu32 pkts = 0, pend = 0, toread, n;\n\n\twhile (quota > 0) {\n\t\tif (!pend) {\n\t\t\tpend = c_can_get_pending(priv);\n\t\t\tif (!pend)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\ttoread = c_can_adjust_pending(pend,\n\t\t\t\t\t\t      priv->msg_obj_rx_mask);\n\t\t} else {\n\t\t\ttoread = pend;\n\t\t}\n\t\t \n\t\tpend &= ~toread;\n\t\t \n\t\tn = c_can_read_objects(dev, priv, toread, quota);\n\t\tpkts += n;\n\t\tquota -= n;\n\t}\n\n\treturn pkts;\n}\n\nstatic int c_can_handle_state_change(struct net_device *dev,\n\t\t\t\t     enum c_can_bus_error_types error_type)\n{\n\tunsigned int reg_err_counter;\n\tunsigned int rx_err_passive;\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tstruct can_berr_counter bec;\n\n\tswitch (error_type) {\n\tcase C_CAN_NO_ERROR:\n\t\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\tbreak;\n\tcase C_CAN_ERROR_WARNING:\n\t\t \n\t\tpriv->can.can_stats.error_warning++;\n\t\tpriv->can.state = CAN_STATE_ERROR_WARNING;\n\t\tbreak;\n\tcase C_CAN_ERROR_PASSIVE:\n\t\t \n\t\tpriv->can.can_stats.error_passive++;\n\t\tpriv->can.state = CAN_STATE_ERROR_PASSIVE;\n\t\tbreak;\n\tcase C_CAN_BUS_OFF:\n\t\t \n\t\tpriv->can.state = CAN_STATE_BUS_OFF;\n\t\tpriv->can.can_stats.bus_off++;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tskb = alloc_can_err_skb(dev, &cf);\n\tif (unlikely(!skb))\n\t\treturn 0;\n\n\t__c_can_get_berr_counter(dev, &bec);\n\treg_err_counter = priv->read_reg(priv, C_CAN_ERR_CNT_REG);\n\trx_err_passive = (reg_err_counter & ERR_CNT_RP_MASK) >>\n\t\t\t\tERR_CNT_RP_SHIFT;\n\n\tswitch (error_type) {\n\tcase C_CAN_NO_ERROR:\n\t\tcf->can_id |= CAN_ERR_CRTL | CAN_ERR_CNT;\n\t\tcf->data[1] = CAN_ERR_CRTL_ACTIVE;\n\t\tcf->data[6] = bec.txerr;\n\t\tcf->data[7] = bec.rxerr;\n\t\tbreak;\n\tcase C_CAN_ERROR_WARNING:\n\t\t \n\t\tcf->can_id |= CAN_ERR_CRTL | CAN_ERR_CNT;\n\t\tcf->data[1] = (bec.txerr > bec.rxerr) ?\n\t\t\tCAN_ERR_CRTL_TX_WARNING :\n\t\t\tCAN_ERR_CRTL_RX_WARNING;\n\t\tcf->data[6] = bec.txerr;\n\t\tcf->data[7] = bec.rxerr;\n\n\t\tbreak;\n\tcase C_CAN_ERROR_PASSIVE:\n\t\t \n\t\tcf->can_id |= CAN_ERR_CRTL | CAN_ERR_CNT;\n\t\tif (rx_err_passive)\n\t\t\tcf->data[1] |= CAN_ERR_CRTL_RX_PASSIVE;\n\t\tif (bec.txerr > 127)\n\t\t\tcf->data[1] |= CAN_ERR_CRTL_TX_PASSIVE;\n\n\t\tcf->data[6] = bec.txerr;\n\t\tcf->data[7] = bec.rxerr;\n\t\tbreak;\n\tcase C_CAN_BUS_OFF:\n\t\t \n\t\tcf->can_id |= CAN_ERR_BUSOFF;\n\t\tcan_bus_off(dev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tnetif_receive_skb(skb);\n\n\treturn 1;\n}\n\nstatic int c_can_handle_bus_err(struct net_device *dev,\n\t\t\t\tenum c_can_lec_type lec_type)\n{\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\n\t \n\tif (lec_type == LEC_UNUSED || lec_type == LEC_NO_ERROR)\n\t\treturn 0;\n\n\tif (!(priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING))\n\t\treturn 0;\n\n\t \n\tpriv->can.can_stats.bus_error++;\n\tstats->rx_errors++;\n\n\t \n\tskb = alloc_can_err_skb(dev, &cf);\n\tif (unlikely(!skb))\n\t\treturn 0;\n\n\t \n\tcf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\n\n\tswitch (lec_type) {\n\tcase LEC_STUFF_ERROR:\n\t\tnetdev_dbg(dev, \"stuff error\\n\");\n\t\tcf->data[2] |= CAN_ERR_PROT_STUFF;\n\t\tbreak;\n\tcase LEC_FORM_ERROR:\n\t\tnetdev_dbg(dev, \"form error\\n\");\n\t\tcf->data[2] |= CAN_ERR_PROT_FORM;\n\t\tbreak;\n\tcase LEC_ACK_ERROR:\n\t\tnetdev_dbg(dev, \"ack error\\n\");\n\t\tcf->data[3] = CAN_ERR_PROT_LOC_ACK;\n\t\tbreak;\n\tcase LEC_BIT1_ERROR:\n\t\tnetdev_dbg(dev, \"bit1 error\\n\");\n\t\tcf->data[2] |= CAN_ERR_PROT_BIT1;\n\t\tbreak;\n\tcase LEC_BIT0_ERROR:\n\t\tnetdev_dbg(dev, \"bit0 error\\n\");\n\t\tcf->data[2] |= CAN_ERR_PROT_BIT0;\n\t\tbreak;\n\tcase LEC_CRC_ERROR:\n\t\tnetdev_dbg(dev, \"CRC error\\n\");\n\t\tcf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tnetif_receive_skb(skb);\n\treturn 1;\n}\n\nstatic int c_can_poll(struct napi_struct *napi, int quota)\n{\n\tstruct net_device *dev = napi->dev;\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\tu16 curr, last = priv->last_status;\n\tint work_done = 0;\n\n\t \n\tif (atomic_xchg(&priv->sie_pending, 0)) {\n\t\tpriv->last_status = priv->read_reg(priv, C_CAN_STS_REG);\n\t\tcurr = priv->last_status;\n\t\t \n\t\tif (priv->type != BOSCH_D_CAN)\n\t\t\tpriv->write_reg(priv, C_CAN_STS_REG, LEC_UNUSED);\n\t} else {\n\t\t \n\t\tcurr = last;\n\t}\n\n\t \n\tif ((curr & STATUS_EWARN) && (!(last & STATUS_EWARN))) {\n\t\tnetdev_dbg(dev, \"entered error warning state\\n\");\n\t\twork_done += c_can_handle_state_change(dev, C_CAN_ERROR_WARNING);\n\t}\n\n\tif ((curr & STATUS_EPASS) && (!(last & STATUS_EPASS))) {\n\t\tnetdev_dbg(dev, \"entered error passive state\\n\");\n\t\twork_done += c_can_handle_state_change(dev, C_CAN_ERROR_PASSIVE);\n\t}\n\n\tif ((curr & STATUS_BOFF) && (!(last & STATUS_BOFF))) {\n\t\tnetdev_dbg(dev, \"entered bus off state\\n\");\n\t\twork_done += c_can_handle_state_change(dev, C_CAN_BUS_OFF);\n\t\tgoto end;\n\t}\n\n\t \n\tif ((!(curr & STATUS_BOFF)) && (last & STATUS_BOFF)) {\n\t\tnetdev_dbg(dev, \"left bus off state\\n\");\n\t\twork_done += c_can_handle_state_change(dev, C_CAN_ERROR_PASSIVE);\n\t}\n\n\tif ((!(curr & STATUS_EPASS)) && (last & STATUS_EPASS)) {\n\t\tnetdev_dbg(dev, \"left error passive state\\n\");\n\t\twork_done += c_can_handle_state_change(dev, C_CAN_ERROR_WARNING);\n\t}\n\n\tif ((!(curr & STATUS_EWARN)) && (last & STATUS_EWARN)) {\n\t\tnetdev_dbg(dev, \"left error warning state\\n\");\n\t\twork_done += c_can_handle_state_change(dev, C_CAN_NO_ERROR);\n\t}\n\n\t \n\twork_done += c_can_handle_bus_err(dev, curr & LEC_MASK);\n\n\t \n\twork_done += c_can_do_rx_poll(dev, (quota - work_done));\n\tc_can_do_tx(dev);\n\nend:\n\tif (work_done < quota) {\n\t\tnapi_complete_done(napi, work_done);\n\t\t \n\t\tif (priv->can.state != CAN_STATE_BUS_OFF)\n\t\t\tc_can_irq_control(priv, true);\n\t}\n\n\treturn work_done;\n}\n\nstatic irqreturn_t c_can_isr(int irq, void *dev_id)\n{\n\tstruct net_device *dev = (struct net_device *)dev_id;\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\tint reg_int;\n\n\treg_int = priv->read_reg(priv, C_CAN_INT_REG);\n\tif (!reg_int)\n\t\treturn IRQ_NONE;\n\n\t \n\tif (reg_int & INT_STS_PENDING)\n\t\tatomic_set(&priv->sie_pending, 1);\n\n\t \n\tc_can_irq_control(priv, false);\n\tnapi_schedule(&priv->napi);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int c_can_open(struct net_device *dev)\n{\n\tint err;\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\n\tc_can_pm_runtime_get_sync(priv);\n\tc_can_reset_ram(priv, true);\n\n\t \n\terr = open_candev(dev);\n\tif (err) {\n\t\tnetdev_err(dev, \"failed to open can device\\n\");\n\t\tgoto exit_open_fail;\n\t}\n\n\t \n\terr = request_irq(dev->irq, &c_can_isr, IRQF_SHARED, dev->name,\n\t\t\t  dev);\n\tif (err < 0) {\n\t\tnetdev_err(dev, \"failed to request interrupt\\n\");\n\t\tgoto exit_irq_fail;\n\t}\n\n\t \n\terr = c_can_start(dev);\n\tif (err)\n\t\tgoto exit_start_fail;\n\n\tnapi_enable(&priv->napi);\n\t \n\tc_can_irq_control(priv, true);\n\tnetif_start_queue(dev);\n\n\treturn 0;\n\nexit_start_fail:\n\tfree_irq(dev->irq, dev);\nexit_irq_fail:\n\tclose_candev(dev);\nexit_open_fail:\n\tc_can_reset_ram(priv, false);\n\tc_can_pm_runtime_put_sync(priv);\n\treturn err;\n}\n\nstatic int c_can_close(struct net_device *dev)\n{\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\n\tnetif_stop_queue(dev);\n\tnapi_disable(&priv->napi);\n\tc_can_stop(dev);\n\tfree_irq(dev->irq, dev);\n\tclose_candev(dev);\n\n\tc_can_reset_ram(priv, false);\n\tc_can_pm_runtime_put_sync(priv);\n\n\treturn 0;\n}\n\nstruct net_device *alloc_c_can_dev(int msg_obj_num)\n{\n\tstruct net_device *dev;\n\tstruct c_can_priv *priv;\n\tint msg_obj_tx_num = msg_obj_num / 2;\n\n\tdev = alloc_candev(sizeof(*priv), msg_obj_tx_num);\n\tif (!dev)\n\t\treturn NULL;\n\n\tpriv = netdev_priv(dev);\n\tpriv->msg_obj_num = msg_obj_num;\n\tpriv->msg_obj_rx_num = msg_obj_num - msg_obj_tx_num;\n\tpriv->msg_obj_rx_first = 1;\n\tpriv->msg_obj_rx_last =\n\t\tpriv->msg_obj_rx_first + priv->msg_obj_rx_num - 1;\n\tpriv->msg_obj_rx_mask = GENMASK(priv->msg_obj_rx_num - 1, 0);\n\n\tpriv->msg_obj_tx_num = msg_obj_tx_num;\n\tpriv->msg_obj_tx_first = priv->msg_obj_rx_last + 1;\n\tpriv->msg_obj_tx_last =\n\t\tpriv->msg_obj_tx_first + priv->msg_obj_tx_num - 1;\n\n\tpriv->tx.head = 0;\n\tpriv->tx.tail = 0;\n\tpriv->tx.obj_num = msg_obj_tx_num;\n\n\tnetif_napi_add_weight(dev, &priv->napi, c_can_poll,\n\t\t\t      priv->msg_obj_rx_num);\n\n\tpriv->dev = dev;\n\tpriv->can.bittiming_const = &c_can_bittiming_const;\n\tpriv->can.do_set_mode = c_can_set_mode;\n\tpriv->can.do_get_berr_counter = c_can_get_berr_counter;\n\tpriv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |\n\t\t\t\t\tCAN_CTRLMODE_LISTENONLY |\n\t\t\t\t\tCAN_CTRLMODE_BERR_REPORTING;\n\n\treturn dev;\n}\nEXPORT_SYMBOL_GPL(alloc_c_can_dev);\n\n#ifdef CONFIG_PM\nint c_can_power_down(struct net_device *dev)\n{\n\tu32 val;\n\tunsigned long time_out;\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\n\tif (!(dev->flags & IFF_UP))\n\t\treturn 0;\n\n\tWARN_ON(priv->type != BOSCH_D_CAN);\n\n\t \n\tval = priv->read_reg(priv, C_CAN_CTRL_EX_REG);\n\tval |= CONTROL_EX_PDR;\n\tpriv->write_reg(priv, C_CAN_CTRL_EX_REG, val);\n\n\t \n\ttime_out = jiffies + msecs_to_jiffies(INIT_WAIT_MS);\n\twhile (!(priv->read_reg(priv, C_CAN_STS_REG) & STATUS_PDA) &&\n\t       time_after(time_out, jiffies))\n\t\tcpu_relax();\n\n\tif (time_after(jiffies, time_out))\n\t\treturn -ETIMEDOUT;\n\n\tc_can_stop(dev);\n\n\tc_can_reset_ram(priv, false);\n\tc_can_pm_runtime_put_sync(priv);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(c_can_power_down);\n\nint c_can_power_up(struct net_device *dev)\n{\n\tu32 val;\n\tunsigned long time_out;\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\tint ret;\n\n\tif (!(dev->flags & IFF_UP))\n\t\treturn 0;\n\n\tWARN_ON(priv->type != BOSCH_D_CAN);\n\n\tc_can_pm_runtime_get_sync(priv);\n\tc_can_reset_ram(priv, true);\n\n\t \n\tval = priv->read_reg(priv, C_CAN_CTRL_EX_REG);\n\tval &= ~CONTROL_EX_PDR;\n\tpriv->write_reg(priv, C_CAN_CTRL_EX_REG, val);\n\tval = priv->read_reg(priv, C_CAN_CTRL_REG);\n\tval &= ~CONTROL_INIT;\n\tpriv->write_reg(priv, C_CAN_CTRL_REG, val);\n\n\t \n\ttime_out = jiffies + msecs_to_jiffies(INIT_WAIT_MS);\n\twhile ((priv->read_reg(priv, C_CAN_STS_REG) & STATUS_PDA) &&\n\t       time_after(time_out, jiffies))\n\t\tcpu_relax();\n\n\tif (time_after(jiffies, time_out)) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto err_out;\n\t}\n\n\tret = c_can_start(dev);\n\tif (ret)\n\t\tgoto err_out;\n\n\tc_can_irq_control(priv, true);\n\n\treturn 0;\n\nerr_out:\n\tc_can_reset_ram(priv, false);\n\tc_can_pm_runtime_put_sync(priv);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(c_can_power_up);\n#endif\n\nvoid free_c_can_dev(struct net_device *dev)\n{\n\tstruct c_can_priv *priv = netdev_priv(dev);\n\n\tnetif_napi_del(&priv->napi);\n\tfree_candev(dev);\n}\nEXPORT_SYMBOL_GPL(free_c_can_dev);\n\nstatic const struct net_device_ops c_can_netdev_ops = {\n\t.ndo_open = c_can_open,\n\t.ndo_stop = c_can_close,\n\t.ndo_start_xmit = c_can_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nint register_c_can_dev(struct net_device *dev)\n{\n\t \n\tpinctrl_pm_select_sleep_state(dev->dev.parent);\n\n\tdev->flags |= IFF_ECHO;\t \n\tdev->netdev_ops = &c_can_netdev_ops;\n\tdev->ethtool_ops = &c_can_ethtool_ops;\n\n\treturn register_candev(dev);\n}\nEXPORT_SYMBOL_GPL(register_c_can_dev);\n\nvoid unregister_c_can_dev(struct net_device *dev)\n{\n\tunregister_candev(dev);\n}\nEXPORT_SYMBOL_GPL(unregister_c_can_dev);\n\nMODULE_AUTHOR(\"Bhupesh Sharma <bhupesh.sharma@st.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"CAN bus driver for Bosch C_CAN controller\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}