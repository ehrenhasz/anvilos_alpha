{
  "module_name": "flexcan-core.c",
  "hash_id": "09acce595874458fe7db9ee011b65b57ba0f9507b5c4adb4dfe1dd05c3a804e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/flexcan/flexcan-core.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n#include <dt-bindings/firmware/imx/rsrc.h>\n#include <linux/bitfield.h>\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/firmware/imx/sci.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/can/platform/flexcan.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n#include \"flexcan.h\"\n\n#define DRV_NAME\t\t\t\"flexcan\"\n\n \n#define FLEXCAN_NAPI_WEIGHT\t\t(8 + 2)\n\n \n#define FLEXCAN_MCR_MDIS\t\tBIT(31)\n#define FLEXCAN_MCR_FRZ\t\t\tBIT(30)\n#define FLEXCAN_MCR_FEN\t\t\tBIT(29)\n#define FLEXCAN_MCR_HALT\t\tBIT(28)\n#define FLEXCAN_MCR_NOT_RDY\t\tBIT(27)\n#define FLEXCAN_MCR_WAK_MSK\t\tBIT(26)\n#define FLEXCAN_MCR_SOFTRST\t\tBIT(25)\n#define FLEXCAN_MCR_FRZ_ACK\t\tBIT(24)\n#define FLEXCAN_MCR_SUPV\t\tBIT(23)\n#define FLEXCAN_MCR_SLF_WAK\t\tBIT(22)\n#define FLEXCAN_MCR_WRN_EN\t\tBIT(21)\n#define FLEXCAN_MCR_LPM_ACK\t\tBIT(20)\n#define FLEXCAN_MCR_WAK_SRC\t\tBIT(19)\n#define FLEXCAN_MCR_DOZE\t\tBIT(18)\n#define FLEXCAN_MCR_SRX_DIS\t\tBIT(17)\n#define FLEXCAN_MCR_IRMQ\t\tBIT(16)\n#define FLEXCAN_MCR_LPRIO_EN\t\tBIT(13)\n#define FLEXCAN_MCR_AEN\t\t\tBIT(12)\n#define FLEXCAN_MCR_FDEN\t\tBIT(11)\n \n#define FLEXCAN_MCR_MAXMB(x)\t\t((x) & 0x7f)\n#define FLEXCAN_MCR_IDAM_A\t\t(0x0 << 8)\n#define FLEXCAN_MCR_IDAM_B\t\t(0x1 << 8)\n#define FLEXCAN_MCR_IDAM_C\t\t(0x2 << 8)\n#define FLEXCAN_MCR_IDAM_D\t\t(0x3 << 8)\n\n \n#define FLEXCAN_CTRL_PRESDIV(x)\t\t(((x) & 0xff) << 24)\n#define FLEXCAN_CTRL_RJW(x)\t\t(((x) & 0x03) << 22)\n#define FLEXCAN_CTRL_PSEG1(x)\t\t(((x) & 0x07) << 19)\n#define FLEXCAN_CTRL_PSEG2(x)\t\t(((x) & 0x07) << 16)\n#define FLEXCAN_CTRL_BOFF_MSK\t\tBIT(15)\n#define FLEXCAN_CTRL_ERR_MSK\t\tBIT(14)\n#define FLEXCAN_CTRL_CLK_SRC\t\tBIT(13)\n#define FLEXCAN_CTRL_LPB\t\tBIT(12)\n#define FLEXCAN_CTRL_TWRN_MSK\t\tBIT(11)\n#define FLEXCAN_CTRL_RWRN_MSK\t\tBIT(10)\n#define FLEXCAN_CTRL_SMP\t\tBIT(7)\n#define FLEXCAN_CTRL_BOFF_REC\t\tBIT(6)\n#define FLEXCAN_CTRL_TSYN\t\tBIT(5)\n#define FLEXCAN_CTRL_LBUF\t\tBIT(4)\n#define FLEXCAN_CTRL_LOM\t\tBIT(3)\n#define FLEXCAN_CTRL_PROPSEG(x)\t\t((x) & 0x07)\n#define FLEXCAN_CTRL_ERR_BUS\t\t(FLEXCAN_CTRL_ERR_MSK)\n#define FLEXCAN_CTRL_ERR_STATE \\\n\t(FLEXCAN_CTRL_TWRN_MSK | FLEXCAN_CTRL_RWRN_MSK | \\\n\t FLEXCAN_CTRL_BOFF_MSK)\n#define FLEXCAN_CTRL_ERR_ALL \\\n\t(FLEXCAN_CTRL_ERR_BUS | FLEXCAN_CTRL_ERR_STATE)\n\n \n#define FLEXCAN_CTRL2_ECRWRE\t\tBIT(29)\n#define FLEXCAN_CTRL2_WRMFRZ\t\tBIT(28)\n#define FLEXCAN_CTRL2_RFFN(x)\t\t(((x) & 0x0f) << 24)\n#define FLEXCAN_CTRL2_TASD(x)\t\t(((x) & 0x1f) << 19)\n#define FLEXCAN_CTRL2_MRP\t\tBIT(18)\n#define FLEXCAN_CTRL2_RRS\t\tBIT(17)\n#define FLEXCAN_CTRL2_EACEN\t\tBIT(16)\n#define FLEXCAN_CTRL2_ISOCANFDEN\tBIT(12)\n\n \n#define FLEXCAN_MECR_ECRWRDIS\t\tBIT(31)\n#define FLEXCAN_MECR_HANCEI_MSK\t\tBIT(19)\n#define FLEXCAN_MECR_FANCEI_MSK\t\tBIT(18)\n#define FLEXCAN_MECR_CEI_MSK\t\tBIT(16)\n#define FLEXCAN_MECR_HAERRIE\t\tBIT(15)\n#define FLEXCAN_MECR_FAERRIE\t\tBIT(14)\n#define FLEXCAN_MECR_EXTERRIE\t\tBIT(13)\n#define FLEXCAN_MECR_RERRDIS\t\tBIT(9)\n#define FLEXCAN_MECR_ECCDIS\t\tBIT(8)\n#define FLEXCAN_MECR_NCEFAFRZ\t\tBIT(7)\n\n \n#define FLEXCAN_ESR_TWRN_INT\t\tBIT(17)\n#define FLEXCAN_ESR_RWRN_INT\t\tBIT(16)\n#define FLEXCAN_ESR_BIT1_ERR\t\tBIT(15)\n#define FLEXCAN_ESR_BIT0_ERR\t\tBIT(14)\n#define FLEXCAN_ESR_ACK_ERR\t\tBIT(13)\n#define FLEXCAN_ESR_CRC_ERR\t\tBIT(12)\n#define FLEXCAN_ESR_FRM_ERR\t\tBIT(11)\n#define FLEXCAN_ESR_STF_ERR\t\tBIT(10)\n#define FLEXCAN_ESR_TX_WRN\t\tBIT(9)\n#define FLEXCAN_ESR_RX_WRN\t\tBIT(8)\n#define FLEXCAN_ESR_IDLE\t\tBIT(7)\n#define FLEXCAN_ESR_TXRX\t\tBIT(6)\n#define FLEXCAN_EST_FLT_CONF_SHIFT\t(4)\n#define FLEXCAN_ESR_FLT_CONF_MASK\t(0x3 << FLEXCAN_EST_FLT_CONF_SHIFT)\n#define FLEXCAN_ESR_FLT_CONF_ACTIVE\t(0x0 << FLEXCAN_EST_FLT_CONF_SHIFT)\n#define FLEXCAN_ESR_FLT_CONF_PASSIVE\t(0x1 << FLEXCAN_EST_FLT_CONF_SHIFT)\n#define FLEXCAN_ESR_BOFF_INT\t\tBIT(2)\n#define FLEXCAN_ESR_ERR_INT\t\tBIT(1)\n#define FLEXCAN_ESR_WAK_INT\t\tBIT(0)\n#define FLEXCAN_ESR_ERR_BUS \\\n\t(FLEXCAN_ESR_BIT1_ERR | FLEXCAN_ESR_BIT0_ERR | \\\n\t FLEXCAN_ESR_ACK_ERR | FLEXCAN_ESR_CRC_ERR | \\\n\t FLEXCAN_ESR_FRM_ERR | FLEXCAN_ESR_STF_ERR)\n#define FLEXCAN_ESR_ERR_STATE \\\n\t(FLEXCAN_ESR_TWRN_INT | FLEXCAN_ESR_RWRN_INT | FLEXCAN_ESR_BOFF_INT)\n#define FLEXCAN_ESR_ERR_ALL \\\n\t(FLEXCAN_ESR_ERR_BUS | FLEXCAN_ESR_ERR_STATE)\n#define FLEXCAN_ESR_ALL_INT \\\n\t(FLEXCAN_ESR_TWRN_INT | FLEXCAN_ESR_RWRN_INT | \\\n\t FLEXCAN_ESR_BOFF_INT | FLEXCAN_ESR_ERR_INT)\n\n \n#define FLEXCAN_CBT_BTF\t\t\tBIT(31)\n#define FLEXCAN_CBT_EPRESDIV_MASK\tGENMASK(30, 21)\n#define FLEXCAN_CBT_ERJW_MASK\t\tGENMASK(20, 16)\n#define FLEXCAN_CBT_EPROPSEG_MASK\tGENMASK(15, 10)\n#define FLEXCAN_CBT_EPSEG1_MASK\t\tGENMASK(9, 5)\n#define FLEXCAN_CBT_EPSEG2_MASK\t\tGENMASK(4, 0)\n\n \n#define FLEXCAN_FDCTRL_FDRATE\t\tBIT(31)\n#define FLEXCAN_FDCTRL_MBDSR1\t\tGENMASK(20, 19)\n#define FLEXCAN_FDCTRL_MBDSR0\t\tGENMASK(17, 16)\n#define FLEXCAN_FDCTRL_MBDSR_8\t\t0x0\n#define FLEXCAN_FDCTRL_MBDSR_12\t\t0x1\n#define FLEXCAN_FDCTRL_MBDSR_32\t\t0x2\n#define FLEXCAN_FDCTRL_MBDSR_64\t\t0x3\n#define FLEXCAN_FDCTRL_TDCEN\t\tBIT(15)\n#define FLEXCAN_FDCTRL_TDCFAIL\t\tBIT(14)\n#define FLEXCAN_FDCTRL_TDCOFF\t\tGENMASK(12, 8)\n#define FLEXCAN_FDCTRL_TDCVAL\t\tGENMASK(5, 0)\n\n \n#define FLEXCAN_FDCBT_FPRESDIV_MASK\tGENMASK(29, 20)\n#define FLEXCAN_FDCBT_FRJW_MASK\t\tGENMASK(18, 16)\n#define FLEXCAN_FDCBT_FPROPSEG_MASK\tGENMASK(14, 10)\n#define FLEXCAN_FDCBT_FPSEG1_MASK\tGENMASK(7, 5)\n#define FLEXCAN_FDCBT_FPSEG2_MASK\tGENMASK(2, 0)\n\n \n \n#define FLEXCAN_TX_MB_RESERVED_RX_FIFO\t8\n#define FLEXCAN_TX_MB_RESERVED_RX_MAILBOX\t0\n#define FLEXCAN_RX_MB_RX_MAILBOX_FIRST\t(FLEXCAN_TX_MB_RESERVED_RX_MAILBOX + 1)\n#define FLEXCAN_IFLAG_MB(x)\t\tBIT_ULL(x)\n#define FLEXCAN_IFLAG_RX_FIFO_OVERFLOW\tBIT(7)\n#define FLEXCAN_IFLAG_RX_FIFO_WARN\tBIT(6)\n#define FLEXCAN_IFLAG_RX_FIFO_AVAILABLE\tBIT(5)\n\n \n#define FLEXCAN_MB_CODE_MASK\t\t(0xf << 24)\n#define FLEXCAN_MB_CODE_RX_BUSY_BIT\t(0x1 << 24)\n#define FLEXCAN_MB_CODE_RX_INACTIVE\t(0x0 << 24)\n#define FLEXCAN_MB_CODE_RX_EMPTY\t(0x4 << 24)\n#define FLEXCAN_MB_CODE_RX_FULL\t\t(0x2 << 24)\n#define FLEXCAN_MB_CODE_RX_OVERRUN\t(0x6 << 24)\n#define FLEXCAN_MB_CODE_RX_RANSWER\t(0xa << 24)\n\n#define FLEXCAN_MB_CODE_TX_INACTIVE\t(0x8 << 24)\n#define FLEXCAN_MB_CODE_TX_ABORT\t(0x9 << 24)\n#define FLEXCAN_MB_CODE_TX_DATA\t\t(0xc << 24)\n#define FLEXCAN_MB_CODE_TX_TANSWER\t(0xe << 24)\n\n#define FLEXCAN_MB_CNT_EDL\t\tBIT(31)\n#define FLEXCAN_MB_CNT_BRS\t\tBIT(30)\n#define FLEXCAN_MB_CNT_ESI\t\tBIT(29)\n#define FLEXCAN_MB_CNT_SRR\t\tBIT(22)\n#define FLEXCAN_MB_CNT_IDE\t\tBIT(21)\n#define FLEXCAN_MB_CNT_RTR\t\tBIT(20)\n#define FLEXCAN_MB_CNT_LENGTH(x)\t(((x) & 0xf) << 16)\n#define FLEXCAN_MB_CNT_TIMESTAMP(x)\t((x) & 0xffff)\n\n#define FLEXCAN_TIMEOUT_US\t\t(250)\n\n \nstruct flexcan_mb {\n\tu32 can_ctrl;\n\tu32 can_id;\n\tu32 data[];\n};\n\n \nstruct flexcan_regs {\n\tu32 mcr;\t\t \n\tu32 ctrl;\t\t \n\tu32 timer;\t\t \n\tu32 tcr;\t\t \n\tu32 rxgmask;\t\t \n\tu32 rx14mask;\t\t \n\tu32 rx15mask;\t\t \n\tu32 ecr;\t\t \n\tu32 esr;\t\t \n\tu32 imask2;\t\t \n\tu32 imask1;\t\t \n\tu32 iflag2;\t\t \n\tu32 iflag1;\t\t \n\tunion {\t\t\t \n\t\tu32 gfwr_mx28;\t \n\t\tu32 ctrl2;\t \n\t};\n\tu32 esr2;\t\t \n\tu32 imeur;\t\t \n\tu32 lrfr;\t\t \n\tu32 crcr;\t\t \n\tu32 rxfgmask;\t\t \n\tu32 rxfir;\t\t \n\tu32 cbt;\t\t \n\tu32 _reserved2;\t\t \n\tu32 dbg1;\t\t \n\tu32 dbg2;\t\t \n\tu32 _reserved3[8];\t \n\tstruct_group(init,\n\t\tu8 mb[2][512];\t\t \n\t\t \n\t\tu32 _reserved4[256];\t \n\t\tu32 rximr[64];\t\t \n\t\tu32 _reserved5[24];\t \n\t\tu32 gfwr_mx6;\t\t \n\t\tu32 _reserved6[39];\t \n\t\tu32 _rxfir[6];\t\t \n\t\tu32 _reserved8[2];\t \n\t\tu32 _rxmgmask;\t\t \n\t\tu32 _rxfgmask;\t\t \n\t\tu32 _rx14mask;\t\t \n\t\tu32 _rx15mask;\t\t \n\t\tu32 tx_smb[4];\t\t \n\t\tu32 rx_smb0[4];\t\t \n\t\tu32 rx_smb1[4];\t\t \n\t);\n\tu32 mecr;\t\t \n\tu32 erriar;\t\t \n\tu32 erridpr;\t\t \n\tu32 errippr;\t\t \n\tu32 rerrar;\t\t \n\tu32 rerrdr;\t\t \n\tu32 rerrsynr;\t\t \n\tu32 errsr;\t\t \n\tu32 _reserved7[64];\t \n\tu32 fdctrl;\t\t \n\tu32 fdcbt;\t\t \n\tu32 fdcrc;\t\t \n\tu32 _reserved9[199];\t \n\tstruct_group(init_fd,\n\t\tu32 tx_smb_fd[18];\t \n\t\tu32 rx_smb0_fd[18];\t \n\t\tu32 rx_smb1_fd[18];\t \n\t);\n};\n\nstatic_assert(sizeof(struct flexcan_regs) ==  0x4 * 18 + 0xfb8);\n\nstatic const struct flexcan_devtype_data fsl_mcf5441x_devtype_data = {\n\t.quirks = FLEXCAN_QUIRK_BROKEN_PERR_STATE |\n\t\tFLEXCAN_QUIRK_NR_IRQ_3 | FLEXCAN_QUIRK_NR_MB_16 |\n\t\tFLEXCAN_QUIRK_SUPPORT_RX_MAILBOX |\n\t\tFLEXCAN_QUIRK_SUPPORT_RX_FIFO,\n};\n\nstatic const struct flexcan_devtype_data fsl_p1010_devtype_data = {\n\t.quirks = FLEXCAN_QUIRK_BROKEN_WERR_STATE |\n\t\tFLEXCAN_QUIRK_BROKEN_PERR_STATE |\n\t\tFLEXCAN_QUIRK_DEFAULT_BIG_ENDIAN |\n\t\tFLEXCAN_QUIRK_SUPPORT_RX_MAILBOX |\n\t\tFLEXCAN_QUIRK_SUPPORT_RX_FIFO,\n};\n\nstatic const struct flexcan_devtype_data fsl_imx25_devtype_data = {\n\t.quirks = FLEXCAN_QUIRK_BROKEN_WERR_STATE |\n\t\tFLEXCAN_QUIRK_BROKEN_PERR_STATE |\n\t\tFLEXCAN_QUIRK_SUPPORT_RX_MAILBOX |\n\t\tFLEXCAN_QUIRK_SUPPORT_RX_FIFO,\n};\n\nstatic const struct flexcan_devtype_data fsl_imx28_devtype_data = {\n\t.quirks = FLEXCAN_QUIRK_BROKEN_PERR_STATE |\n\t\tFLEXCAN_QUIRK_SUPPORT_RX_MAILBOX |\n\t\tFLEXCAN_QUIRK_SUPPORT_RX_FIFO,\n};\n\nstatic const struct flexcan_devtype_data fsl_imx6q_devtype_data = {\n\t.quirks = FLEXCAN_QUIRK_DISABLE_RXFG | FLEXCAN_QUIRK_ENABLE_EACEN_RRS |\n\t\tFLEXCAN_QUIRK_USE_RX_MAILBOX | FLEXCAN_QUIRK_BROKEN_PERR_STATE |\n\t\tFLEXCAN_QUIRK_SETUP_STOP_MODE_GPR |\n\t\tFLEXCAN_QUIRK_SUPPORT_RX_MAILBOX |\n\t\tFLEXCAN_QUIRK_SUPPORT_RX_MAILBOX_RTR,\n};\n\nstatic const struct flexcan_devtype_data fsl_imx8qm_devtype_data = {\n\t.quirks = FLEXCAN_QUIRK_DISABLE_RXFG | FLEXCAN_QUIRK_ENABLE_EACEN_RRS |\n\t\tFLEXCAN_QUIRK_USE_RX_MAILBOX | FLEXCAN_QUIRK_BROKEN_PERR_STATE |\n\t\tFLEXCAN_QUIRK_SUPPORT_FD | FLEXCAN_QUIRK_SETUP_STOP_MODE_SCFW |\n\t\tFLEXCAN_QUIRK_SUPPORT_RX_MAILBOX |\n\t\tFLEXCAN_QUIRK_SUPPORT_RX_MAILBOX_RTR,\n};\n\nstatic struct flexcan_devtype_data fsl_imx8mp_devtype_data = {\n\t.quirks = FLEXCAN_QUIRK_DISABLE_RXFG | FLEXCAN_QUIRK_ENABLE_EACEN_RRS |\n\t\tFLEXCAN_QUIRK_DISABLE_MECR | FLEXCAN_QUIRK_USE_RX_MAILBOX |\n\t\tFLEXCAN_QUIRK_BROKEN_PERR_STATE | FLEXCAN_QUIRK_SETUP_STOP_MODE_GPR |\n\t\tFLEXCAN_QUIRK_SUPPORT_FD | FLEXCAN_QUIRK_SUPPORT_ECC |\n\t\tFLEXCAN_QUIRK_SUPPORT_RX_MAILBOX |\n\t\tFLEXCAN_QUIRK_SUPPORT_RX_MAILBOX_RTR,\n};\n\nstatic struct flexcan_devtype_data fsl_imx93_devtype_data = {\n\t.quirks = FLEXCAN_QUIRK_DISABLE_RXFG | FLEXCAN_QUIRK_ENABLE_EACEN_RRS |\n\t\tFLEXCAN_QUIRK_DISABLE_MECR | FLEXCAN_QUIRK_USE_RX_MAILBOX |\n\t\tFLEXCAN_QUIRK_BROKEN_PERR_STATE | FLEXCAN_QUIRK_SETUP_STOP_MODE_GPR |\n\t\tFLEXCAN_QUIRK_SUPPORT_FD | FLEXCAN_QUIRK_SUPPORT_ECC |\n\t\tFLEXCAN_QUIRK_SUPPORT_RX_MAILBOX |\n\t\tFLEXCAN_QUIRK_SUPPORT_RX_MAILBOX_RTR,\n};\n\nstatic const struct flexcan_devtype_data fsl_vf610_devtype_data = {\n\t.quirks = FLEXCAN_QUIRK_DISABLE_RXFG | FLEXCAN_QUIRK_ENABLE_EACEN_RRS |\n\t\tFLEXCAN_QUIRK_DISABLE_MECR | FLEXCAN_QUIRK_USE_RX_MAILBOX |\n\t\tFLEXCAN_QUIRK_BROKEN_PERR_STATE | FLEXCAN_QUIRK_SUPPORT_ECC |\n\t\tFLEXCAN_QUIRK_SUPPORT_RX_MAILBOX |\n\t\tFLEXCAN_QUIRK_SUPPORT_RX_MAILBOX_RTR,\n};\n\nstatic const struct flexcan_devtype_data fsl_ls1021a_r2_devtype_data = {\n\t.quirks = FLEXCAN_QUIRK_DISABLE_RXFG | FLEXCAN_QUIRK_ENABLE_EACEN_RRS |\n\t\tFLEXCAN_QUIRK_BROKEN_PERR_STATE | FLEXCAN_QUIRK_USE_RX_MAILBOX |\n\t\tFLEXCAN_QUIRK_SUPPORT_RX_MAILBOX |\n\t\tFLEXCAN_QUIRK_SUPPORT_RX_MAILBOX_RTR,\n};\n\nstatic const struct flexcan_devtype_data fsl_lx2160a_r1_devtype_data = {\n\t.quirks = FLEXCAN_QUIRK_DISABLE_RXFG | FLEXCAN_QUIRK_ENABLE_EACEN_RRS |\n\t\tFLEXCAN_QUIRK_DISABLE_MECR | FLEXCAN_QUIRK_BROKEN_PERR_STATE |\n\t\tFLEXCAN_QUIRK_USE_RX_MAILBOX | FLEXCAN_QUIRK_SUPPORT_FD |\n\t\tFLEXCAN_QUIRK_SUPPORT_ECC |\n\t\tFLEXCAN_QUIRK_SUPPORT_RX_MAILBOX |\n\t\tFLEXCAN_QUIRK_SUPPORT_RX_MAILBOX_RTR,\n};\n\nstatic const struct can_bittiming_const flexcan_bittiming_const = {\n\t.name = DRV_NAME,\n\t.tseg1_min = 4,\n\t.tseg1_max = 16,\n\t.tseg2_min = 2,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 256,\n\t.brp_inc = 1,\n};\n\nstatic const struct can_bittiming_const flexcan_fd_bittiming_const = {\n\t.name = DRV_NAME,\n\t.tseg1_min = 2,\n\t.tseg1_max = 96,\n\t.tseg2_min = 2,\n\t.tseg2_max = 32,\n\t.sjw_max = 16,\n\t.brp_min = 1,\n\t.brp_max = 1024,\n\t.brp_inc = 1,\n};\n\nstatic const struct can_bittiming_const flexcan_fd_data_bittiming_const = {\n\t.name = DRV_NAME,\n\t.tseg1_min = 2,\n\t.tseg1_max = 39,\n\t.tseg2_min = 2,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 1024,\n\t.brp_inc = 1,\n};\n\n \nstatic inline u32 flexcan_read_be(void __iomem *addr)\n{\n\treturn ioread32be(addr);\n}\n\nstatic inline void flexcan_write_be(u32 val, void __iomem *addr)\n{\n\tiowrite32be(val, addr);\n}\n\nstatic inline u32 flexcan_read_le(void __iomem *addr)\n{\n\treturn ioread32(addr);\n}\n\nstatic inline void flexcan_write_le(u32 val, void __iomem *addr)\n{\n\tiowrite32(val, addr);\n}\n\nstatic struct flexcan_mb __iomem *flexcan_get_mb(const struct flexcan_priv *priv,\n\t\t\t\t\t\t u8 mb_index)\n{\n\tu8 bank_size;\n\tbool bank;\n\n\tif (WARN_ON(mb_index >= priv->mb_count))\n\t\treturn NULL;\n\n\tbank_size = sizeof(priv->regs->mb[0]) / priv->mb_size;\n\n\tbank = mb_index >= bank_size;\n\tif (bank)\n\t\tmb_index -= bank_size;\n\n\treturn (struct flexcan_mb __iomem *)\n\t\t(&priv->regs->mb[bank][priv->mb_size * mb_index]);\n}\n\nstatic int flexcan_low_power_enter_ack(struct flexcan_priv *priv)\n{\n\tstruct flexcan_regs __iomem *regs = priv->regs;\n\tunsigned int timeout = FLEXCAN_TIMEOUT_US / 10;\n\n\twhile (timeout-- && !(priv->read(&regs->mcr) & FLEXCAN_MCR_LPM_ACK))\n\t\tudelay(10);\n\n\tif (!(priv->read(&regs->mcr) & FLEXCAN_MCR_LPM_ACK))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int flexcan_low_power_exit_ack(struct flexcan_priv *priv)\n{\n\tstruct flexcan_regs __iomem *regs = priv->regs;\n\tunsigned int timeout = FLEXCAN_TIMEOUT_US / 10;\n\n\twhile (timeout-- && (priv->read(&regs->mcr) & FLEXCAN_MCR_LPM_ACK))\n\t\tudelay(10);\n\n\tif (priv->read(&regs->mcr) & FLEXCAN_MCR_LPM_ACK)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic void flexcan_enable_wakeup_irq(struct flexcan_priv *priv, bool enable)\n{\n\tstruct flexcan_regs __iomem *regs = priv->regs;\n\tu32 reg_mcr;\n\n\treg_mcr = priv->read(&regs->mcr);\n\n\tif (enable)\n\t\treg_mcr |= FLEXCAN_MCR_WAK_MSK;\n\telse\n\t\treg_mcr &= ~FLEXCAN_MCR_WAK_MSK;\n\n\tpriv->write(reg_mcr, &regs->mcr);\n}\n\nstatic int flexcan_stop_mode_enable_scfw(struct flexcan_priv *priv, bool enabled)\n{\n\tu8 idx = priv->scu_idx;\n\tu32 rsrc_id, val;\n\n\trsrc_id = IMX_SC_R_CAN(idx);\n\n\tif (enabled)\n\t\tval = 1;\n\telse\n\t\tval = 0;\n\n\t \n\treturn imx_sc_misc_set_control(priv->sc_ipc_handle, rsrc_id,\n\t\t\t\t       IMX_SC_C_IPG_STOP, val);\n}\n\nstatic inline int flexcan_enter_stop_mode(struct flexcan_priv *priv)\n{\n\tstruct flexcan_regs __iomem *regs = priv->regs;\n\tu32 reg_mcr;\n\tint ret;\n\n\treg_mcr = priv->read(&regs->mcr);\n\treg_mcr |= FLEXCAN_MCR_SLF_WAK;\n\tpriv->write(reg_mcr, &regs->mcr);\n\n\t \n\tif (priv->devtype_data.quirks & FLEXCAN_QUIRK_SETUP_STOP_MODE_SCFW) {\n\t\tret = flexcan_stop_mode_enable_scfw(priv, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else if (priv->devtype_data.quirks & FLEXCAN_QUIRK_SETUP_STOP_MODE_GPR) {\n\t\tregmap_update_bits(priv->stm.gpr, priv->stm.req_gpr,\n\t\t\t\t   1 << priv->stm.req_bit, 1 << priv->stm.req_bit);\n\t}\n\n\treturn flexcan_low_power_enter_ack(priv);\n}\n\nstatic inline int flexcan_exit_stop_mode(struct flexcan_priv *priv)\n{\n\tstruct flexcan_regs __iomem *regs = priv->regs;\n\tu32 reg_mcr;\n\tint ret;\n\n\t \n\tif (priv->devtype_data.quirks & FLEXCAN_QUIRK_SETUP_STOP_MODE_SCFW) {\n\t\tret = flexcan_stop_mode_enable_scfw(priv, false);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else if (priv->devtype_data.quirks & FLEXCAN_QUIRK_SETUP_STOP_MODE_GPR) {\n\t\tregmap_update_bits(priv->stm.gpr, priv->stm.req_gpr,\n\t\t\t\t   1 << priv->stm.req_bit, 0);\n\t}\n\n\treg_mcr = priv->read(&regs->mcr);\n\treg_mcr &= ~FLEXCAN_MCR_SLF_WAK;\n\tpriv->write(reg_mcr, &regs->mcr);\n\n\treturn flexcan_low_power_exit_ack(priv);\n}\n\nstatic inline void flexcan_error_irq_enable(const struct flexcan_priv *priv)\n{\n\tstruct flexcan_regs __iomem *regs = priv->regs;\n\tu32 reg_ctrl = (priv->reg_ctrl_default | FLEXCAN_CTRL_ERR_MSK);\n\n\tpriv->write(reg_ctrl, &regs->ctrl);\n}\n\nstatic inline void flexcan_error_irq_disable(const struct flexcan_priv *priv)\n{\n\tstruct flexcan_regs __iomem *regs = priv->regs;\n\tu32 reg_ctrl = (priv->reg_ctrl_default & ~FLEXCAN_CTRL_ERR_MSK);\n\n\tpriv->write(reg_ctrl, &regs->ctrl);\n}\n\nstatic int flexcan_clks_enable(const struct flexcan_priv *priv)\n{\n\tint err = 0;\n\n\tif (priv->clk_ipg) {\n\t\terr = clk_prepare_enable(priv->clk_ipg);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (priv->clk_per) {\n\t\terr = clk_prepare_enable(priv->clk_per);\n\t\tif (err)\n\t\t\tclk_disable_unprepare(priv->clk_ipg);\n\t}\n\n\treturn err;\n}\n\nstatic void flexcan_clks_disable(const struct flexcan_priv *priv)\n{\n\tclk_disable_unprepare(priv->clk_per);\n\tclk_disable_unprepare(priv->clk_ipg);\n}\n\nstatic inline int flexcan_transceiver_enable(const struct flexcan_priv *priv)\n{\n\tif (!priv->reg_xceiver)\n\t\treturn 0;\n\n\treturn regulator_enable(priv->reg_xceiver);\n}\n\nstatic inline int flexcan_transceiver_disable(const struct flexcan_priv *priv)\n{\n\tif (!priv->reg_xceiver)\n\t\treturn 0;\n\n\treturn regulator_disable(priv->reg_xceiver);\n}\n\nstatic int flexcan_chip_enable(struct flexcan_priv *priv)\n{\n\tstruct flexcan_regs __iomem *regs = priv->regs;\n\tu32 reg;\n\n\treg = priv->read(&regs->mcr);\n\treg &= ~FLEXCAN_MCR_MDIS;\n\tpriv->write(reg, &regs->mcr);\n\n\treturn flexcan_low_power_exit_ack(priv);\n}\n\nstatic int flexcan_chip_disable(struct flexcan_priv *priv)\n{\n\tstruct flexcan_regs __iomem *regs = priv->regs;\n\tu32 reg;\n\n\treg = priv->read(&regs->mcr);\n\treg |= FLEXCAN_MCR_MDIS;\n\tpriv->write(reg, &regs->mcr);\n\n\treturn flexcan_low_power_enter_ack(priv);\n}\n\nstatic int flexcan_chip_freeze(struct flexcan_priv *priv)\n{\n\tstruct flexcan_regs __iomem *regs = priv->regs;\n\tunsigned int timeout;\n\tu32 bitrate = priv->can.bittiming.bitrate;\n\tu32 reg;\n\n\tif (bitrate)\n\t\ttimeout = 1000 * 1000 * 10 / bitrate;\n\telse\n\t\ttimeout = FLEXCAN_TIMEOUT_US / 10;\n\n\treg = priv->read(&regs->mcr);\n\treg |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT;\n\tpriv->write(reg, &regs->mcr);\n\n\twhile (timeout-- && !(priv->read(&regs->mcr) & FLEXCAN_MCR_FRZ_ACK))\n\t\tudelay(100);\n\n\tif (!(priv->read(&regs->mcr) & FLEXCAN_MCR_FRZ_ACK))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int flexcan_chip_unfreeze(struct flexcan_priv *priv)\n{\n\tstruct flexcan_regs __iomem *regs = priv->regs;\n\tunsigned int timeout = FLEXCAN_TIMEOUT_US / 10;\n\tu32 reg;\n\n\treg = priv->read(&regs->mcr);\n\treg &= ~FLEXCAN_MCR_HALT;\n\tpriv->write(reg, &regs->mcr);\n\n\twhile (timeout-- && (priv->read(&regs->mcr) & FLEXCAN_MCR_FRZ_ACK))\n\t\tudelay(10);\n\n\tif (priv->read(&regs->mcr) & FLEXCAN_MCR_FRZ_ACK)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int flexcan_chip_softreset(struct flexcan_priv *priv)\n{\n\tstruct flexcan_regs __iomem *regs = priv->regs;\n\tunsigned int timeout = FLEXCAN_TIMEOUT_US / 10;\n\n\tpriv->write(FLEXCAN_MCR_SOFTRST, &regs->mcr);\n\twhile (timeout-- && (priv->read(&regs->mcr) & FLEXCAN_MCR_SOFTRST))\n\t\tudelay(10);\n\n\tif (priv->read(&regs->mcr) & FLEXCAN_MCR_SOFTRST)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int __flexcan_get_berr_counter(const struct net_device *dev,\n\t\t\t\t      struct can_berr_counter *bec)\n{\n\tconst struct flexcan_priv *priv = netdev_priv(dev);\n\tstruct flexcan_regs __iomem *regs = priv->regs;\n\tu32 reg = priv->read(&regs->ecr);\n\n\tbec->txerr = (reg >> 0) & 0xff;\n\tbec->rxerr = (reg >> 8) & 0xff;\n\n\treturn 0;\n}\n\nstatic int flexcan_get_berr_counter(const struct net_device *dev,\n\t\t\t\t    struct can_berr_counter *bec)\n{\n\tconst struct flexcan_priv *priv = netdev_priv(dev);\n\tint err;\n\n\terr = pm_runtime_resume_and_get(priv->dev);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = __flexcan_get_berr_counter(dev, bec);\n\n\tpm_runtime_put(priv->dev);\n\n\treturn err;\n}\n\nstatic netdev_tx_t flexcan_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tconst struct flexcan_priv *priv = netdev_priv(dev);\n\tstruct canfd_frame *cfd = (struct canfd_frame *)skb->data;\n\tu32 can_id;\n\tu32 data;\n\tu32 ctrl = FLEXCAN_MB_CODE_TX_DATA | ((can_fd_len2dlc(cfd->len)) << 16);\n\tint i;\n\n\tif (can_dev_dropped_skb(dev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tnetif_stop_queue(dev);\n\n\tif (cfd->can_id & CAN_EFF_FLAG) {\n\t\tcan_id = cfd->can_id & CAN_EFF_MASK;\n\t\tctrl |= FLEXCAN_MB_CNT_IDE | FLEXCAN_MB_CNT_SRR;\n\t} else {\n\t\tcan_id = (cfd->can_id & CAN_SFF_MASK) << 18;\n\t}\n\n\tif (cfd->can_id & CAN_RTR_FLAG)\n\t\tctrl |= FLEXCAN_MB_CNT_RTR;\n\n\tif (can_is_canfd_skb(skb)) {\n\t\tctrl |= FLEXCAN_MB_CNT_EDL;\n\n\t\tif (cfd->flags & CANFD_BRS)\n\t\t\tctrl |= FLEXCAN_MB_CNT_BRS;\n\t}\n\n\tfor (i = 0; i < cfd->len; i += sizeof(u32)) {\n\t\tdata = be32_to_cpup((__be32 *)&cfd->data[i]);\n\t\tpriv->write(data, &priv->tx_mb->data[i / sizeof(u32)]);\n\t}\n\n\tcan_put_echo_skb(skb, dev, 0, 0);\n\n\tpriv->write(can_id, &priv->tx_mb->can_id);\n\tpriv->write(ctrl, &priv->tx_mb->can_ctrl);\n\n\t \n\tpriv->write(FLEXCAN_MB_CODE_TX_INACTIVE,\n\t\t    &priv->tx_mb_reserved->can_ctrl);\n\tpriv->write(FLEXCAN_MB_CODE_TX_INACTIVE,\n\t\t    &priv->tx_mb_reserved->can_ctrl);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void flexcan_irq_bus_err(struct net_device *dev, u32 reg_esr)\n{\n\tstruct flexcan_priv *priv = netdev_priv(dev);\n\tstruct flexcan_regs __iomem *regs = priv->regs;\n\tstruct sk_buff *skb;\n\tstruct can_frame *cf;\n\tbool rx_errors = false, tx_errors = false;\n\tu32 timestamp;\n\tint err;\n\n\ttimestamp = priv->read(&regs->timer) << 16;\n\n\tskb = alloc_can_err_skb(dev, &cf);\n\tif (unlikely(!skb))\n\t\treturn;\n\n\tcf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\n\n\tif (reg_esr & FLEXCAN_ESR_BIT1_ERR) {\n\t\tnetdev_dbg(dev, \"BIT1_ERR irq\\n\");\n\t\tcf->data[2] |= CAN_ERR_PROT_BIT1;\n\t\ttx_errors = true;\n\t}\n\tif (reg_esr & FLEXCAN_ESR_BIT0_ERR) {\n\t\tnetdev_dbg(dev, \"BIT0_ERR irq\\n\");\n\t\tcf->data[2] |= CAN_ERR_PROT_BIT0;\n\t\ttx_errors = true;\n\t}\n\tif (reg_esr & FLEXCAN_ESR_ACK_ERR) {\n\t\tnetdev_dbg(dev, \"ACK_ERR irq\\n\");\n\t\tcf->can_id |= CAN_ERR_ACK;\n\t\tcf->data[3] = CAN_ERR_PROT_LOC_ACK;\n\t\ttx_errors = true;\n\t}\n\tif (reg_esr & FLEXCAN_ESR_CRC_ERR) {\n\t\tnetdev_dbg(dev, \"CRC_ERR irq\\n\");\n\t\tcf->data[2] |= CAN_ERR_PROT_BIT;\n\t\tcf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;\n\t\trx_errors = true;\n\t}\n\tif (reg_esr & FLEXCAN_ESR_FRM_ERR) {\n\t\tnetdev_dbg(dev, \"FRM_ERR irq\\n\");\n\t\tcf->data[2] |= CAN_ERR_PROT_FORM;\n\t\trx_errors = true;\n\t}\n\tif (reg_esr & FLEXCAN_ESR_STF_ERR) {\n\t\tnetdev_dbg(dev, \"STF_ERR irq\\n\");\n\t\tcf->data[2] |= CAN_ERR_PROT_STUFF;\n\t\trx_errors = true;\n\t}\n\n\tpriv->can.can_stats.bus_error++;\n\tif (rx_errors)\n\t\tdev->stats.rx_errors++;\n\tif (tx_errors)\n\t\tdev->stats.tx_errors++;\n\n\terr = can_rx_offload_queue_timestamp(&priv->offload, skb, timestamp);\n\tif (err)\n\t\tdev->stats.rx_fifo_errors++;\n}\n\nstatic void flexcan_irq_state(struct net_device *dev, u32 reg_esr)\n{\n\tstruct flexcan_priv *priv = netdev_priv(dev);\n\tstruct flexcan_regs __iomem *regs = priv->regs;\n\tstruct sk_buff *skb;\n\tstruct can_frame *cf;\n\tenum can_state new_state, rx_state, tx_state;\n\tint flt;\n\tstruct can_berr_counter bec;\n\tu32 timestamp;\n\tint err;\n\n\tflt = reg_esr & FLEXCAN_ESR_FLT_CONF_MASK;\n\tif (likely(flt == FLEXCAN_ESR_FLT_CONF_ACTIVE)) {\n\t\ttx_state = unlikely(reg_esr & FLEXCAN_ESR_TX_WRN) ?\n\t\t\tCAN_STATE_ERROR_WARNING : CAN_STATE_ERROR_ACTIVE;\n\t\trx_state = unlikely(reg_esr & FLEXCAN_ESR_RX_WRN) ?\n\t\t\tCAN_STATE_ERROR_WARNING : CAN_STATE_ERROR_ACTIVE;\n\t\tnew_state = max(tx_state, rx_state);\n\t} else {\n\t\t__flexcan_get_berr_counter(dev, &bec);\n\t\tnew_state = flt == FLEXCAN_ESR_FLT_CONF_PASSIVE ?\n\t\t\tCAN_STATE_ERROR_PASSIVE : CAN_STATE_BUS_OFF;\n\t\trx_state = bec.rxerr >= bec.txerr ? new_state : 0;\n\t\ttx_state = bec.rxerr <= bec.txerr ? new_state : 0;\n\t}\n\n\t \n\tif (likely(new_state == priv->can.state))\n\t\treturn;\n\n\ttimestamp = priv->read(&regs->timer) << 16;\n\n\tskb = alloc_can_err_skb(dev, &cf);\n\tif (unlikely(!skb))\n\t\treturn;\n\n\tcan_change_state(dev, cf, tx_state, rx_state);\n\n\tif (unlikely(new_state == CAN_STATE_BUS_OFF))\n\t\tcan_bus_off(dev);\n\n\terr = can_rx_offload_queue_timestamp(&priv->offload, skb, timestamp);\n\tif (err)\n\t\tdev->stats.rx_fifo_errors++;\n}\n\nstatic inline u64 flexcan_read64_mask(struct flexcan_priv *priv, void __iomem *addr, u64 mask)\n{\n\tu64 reg = 0;\n\n\tif (upper_32_bits(mask))\n\t\treg = (u64)priv->read(addr - 4) << 32;\n\tif (lower_32_bits(mask))\n\t\treg |= priv->read(addr);\n\n\treturn reg & mask;\n}\n\nstatic inline void flexcan_write64(struct flexcan_priv *priv, u64 val, void __iomem *addr)\n{\n\tif (upper_32_bits(val))\n\t\tpriv->write(upper_32_bits(val), addr - 4);\n\tif (lower_32_bits(val))\n\t\tpriv->write(lower_32_bits(val), addr);\n}\n\nstatic inline u64 flexcan_read_reg_iflag_rx(struct flexcan_priv *priv)\n{\n\treturn flexcan_read64_mask(priv, &priv->regs->iflag1, priv->rx_mask);\n}\n\nstatic inline u64 flexcan_read_reg_iflag_tx(struct flexcan_priv *priv)\n{\n\treturn flexcan_read64_mask(priv, &priv->regs->iflag1, priv->tx_mask);\n}\n\nstatic inline struct flexcan_priv *rx_offload_to_priv(struct can_rx_offload *offload)\n{\n\treturn container_of(offload, struct flexcan_priv, offload);\n}\n\nstatic struct sk_buff *flexcan_mailbox_read(struct can_rx_offload *offload,\n\t\t\t\t\t    unsigned int n, u32 *timestamp,\n\t\t\t\t\t    bool drop)\n{\n\tstruct flexcan_priv *priv = rx_offload_to_priv(offload);\n\tstruct flexcan_regs __iomem *regs = priv->regs;\n\tstruct flexcan_mb __iomem *mb;\n\tstruct sk_buff *skb;\n\tstruct canfd_frame *cfd;\n\tu32 reg_ctrl, reg_id, reg_iflag1;\n\tint i;\n\n\tmb = flexcan_get_mb(priv, n);\n\n\tif (priv->devtype_data.quirks & FLEXCAN_QUIRK_USE_RX_MAILBOX) {\n\t\tu32 code;\n\n\t\tdo {\n\t\t\treg_ctrl = priv->read(&mb->can_ctrl);\n\t\t} while (reg_ctrl & FLEXCAN_MB_CODE_RX_BUSY_BIT);\n\n\t\t \n\t\tcode = reg_ctrl & FLEXCAN_MB_CODE_MASK;\n\t\tif ((code != FLEXCAN_MB_CODE_RX_FULL) &&\n\t\t    (code != FLEXCAN_MB_CODE_RX_OVERRUN))\n\t\t\treturn NULL;\n\n\t\tif (code == FLEXCAN_MB_CODE_RX_OVERRUN) {\n\t\t\t \n\t\t\toffload->dev->stats.rx_over_errors++;\n\t\t\toffload->dev->stats.rx_errors++;\n\t\t}\n\t} else {\n\t\treg_iflag1 = priv->read(&regs->iflag1);\n\t\tif (!(reg_iflag1 & FLEXCAN_IFLAG_RX_FIFO_AVAILABLE))\n\t\t\treturn NULL;\n\n\t\treg_ctrl = priv->read(&mb->can_ctrl);\n\t}\n\n\tif (unlikely(drop)) {\n\t\tskb = ERR_PTR(-ENOBUFS);\n\t\tgoto mark_as_read;\n\t}\n\n\tif (reg_ctrl & FLEXCAN_MB_CNT_EDL)\n\t\tskb = alloc_canfd_skb(offload->dev, &cfd);\n\telse\n\t\tskb = alloc_can_skb(offload->dev, (struct can_frame **)&cfd);\n\tif (unlikely(!skb)) {\n\t\tskb = ERR_PTR(-ENOMEM);\n\t\tgoto mark_as_read;\n\t}\n\n\t \n\t*timestamp = reg_ctrl << 16;\n\n\treg_id = priv->read(&mb->can_id);\n\tif (reg_ctrl & FLEXCAN_MB_CNT_IDE)\n\t\tcfd->can_id = ((reg_id >> 0) & CAN_EFF_MASK) | CAN_EFF_FLAG;\n\telse\n\t\tcfd->can_id = (reg_id >> 18) & CAN_SFF_MASK;\n\n\tif (reg_ctrl & FLEXCAN_MB_CNT_EDL) {\n\t\tcfd->len = can_fd_dlc2len((reg_ctrl >> 16) & 0xf);\n\n\t\tif (reg_ctrl & FLEXCAN_MB_CNT_BRS)\n\t\t\tcfd->flags |= CANFD_BRS;\n\t} else {\n\t\tcfd->len = can_cc_dlc2len((reg_ctrl >> 16) & 0xf);\n\n\t\tif (reg_ctrl & FLEXCAN_MB_CNT_RTR)\n\t\t\tcfd->can_id |= CAN_RTR_FLAG;\n\t}\n\n\tif (reg_ctrl & FLEXCAN_MB_CNT_ESI)\n\t\tcfd->flags |= CANFD_ESI;\n\n\tfor (i = 0; i < cfd->len; i += sizeof(u32)) {\n\t\t__be32 data = cpu_to_be32(priv->read(&mb->data[i / sizeof(u32)]));\n\t\t*(__be32 *)(cfd->data + i) = data;\n\t}\n\n mark_as_read:\n\tif (priv->devtype_data.quirks & FLEXCAN_QUIRK_USE_RX_MAILBOX)\n\t\tflexcan_write64(priv, FLEXCAN_IFLAG_MB(n), &regs->iflag1);\n\telse\n\t\tpriv->write(FLEXCAN_IFLAG_RX_FIFO_AVAILABLE, &regs->iflag1);\n\n\t \n\tpriv->read(&regs->timer);\n\n\treturn skb;\n}\n\nstatic irqreturn_t flexcan_irq(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct flexcan_priv *priv = netdev_priv(dev);\n\tstruct flexcan_regs __iomem *regs = priv->regs;\n\tirqreturn_t handled = IRQ_NONE;\n\tu64 reg_iflag_tx;\n\tu32 reg_esr;\n\tenum can_state last_state = priv->can.state;\n\n\t \n\tif (priv->devtype_data.quirks & FLEXCAN_QUIRK_USE_RX_MAILBOX) {\n\t\tu64 reg_iflag_rx;\n\t\tint ret;\n\n\t\twhile ((reg_iflag_rx = flexcan_read_reg_iflag_rx(priv))) {\n\t\t\thandled = IRQ_HANDLED;\n\t\t\tret = can_rx_offload_irq_offload_timestamp(&priv->offload,\n\t\t\t\t\t\t\t\t   reg_iflag_rx);\n\t\t\tif (!ret)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tu32 reg_iflag1;\n\n\t\treg_iflag1 = priv->read(&regs->iflag1);\n\t\tif (reg_iflag1 & FLEXCAN_IFLAG_RX_FIFO_AVAILABLE) {\n\t\t\thandled = IRQ_HANDLED;\n\t\t\tcan_rx_offload_irq_offload_fifo(&priv->offload);\n\t\t}\n\n\t\t \n\t\tif (reg_iflag1 & FLEXCAN_IFLAG_RX_FIFO_OVERFLOW) {\n\t\t\thandled = IRQ_HANDLED;\n\t\t\tpriv->write(FLEXCAN_IFLAG_RX_FIFO_OVERFLOW,\n\t\t\t\t    &regs->iflag1);\n\t\t\tdev->stats.rx_over_errors++;\n\t\t\tdev->stats.rx_errors++;\n\t\t}\n\t}\n\n\treg_iflag_tx = flexcan_read_reg_iflag_tx(priv);\n\n\t \n\tif (reg_iflag_tx & priv->tx_mask) {\n\t\tu32 reg_ctrl = priv->read(&priv->tx_mb->can_ctrl);\n\n\t\thandled = IRQ_HANDLED;\n\t\tstats->tx_bytes +=\n\t\t\tcan_rx_offload_get_echo_skb_queue_timestamp(&priv->offload, 0,\n\t\t\t\t\t\t\t\t    reg_ctrl << 16, NULL);\n\t\tstats->tx_packets++;\n\n\t\t \n\t\tpriv->write(FLEXCAN_MB_CODE_TX_INACTIVE,\n\t\t\t    &priv->tx_mb->can_ctrl);\n\t\tflexcan_write64(priv, priv->tx_mask, &regs->iflag1);\n\t\tnetif_wake_queue(dev);\n\t}\n\n\treg_esr = priv->read(&regs->esr);\n\n\t \n\tif (reg_esr & (FLEXCAN_ESR_ALL_INT | FLEXCAN_ESR_WAK_INT)) {\n\t\thandled = IRQ_HANDLED;\n\t\tpriv->write(reg_esr & (FLEXCAN_ESR_ALL_INT | FLEXCAN_ESR_WAK_INT), &regs->esr);\n\t}\n\n\t \n\tif ((reg_esr & FLEXCAN_ESR_ERR_STATE) ||\n\t    (priv->devtype_data.quirks & (FLEXCAN_QUIRK_BROKEN_WERR_STATE |\n\t\t\t\t\t   FLEXCAN_QUIRK_BROKEN_PERR_STATE)))\n\t\tflexcan_irq_state(dev, reg_esr);\n\n\t \n\tif ((reg_esr & FLEXCAN_ESR_ERR_BUS) &&\n\t    (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING))\n\t\tflexcan_irq_bus_err(dev, reg_esr);\n\n\t \n\tif ((last_state != priv->can.state) &&\n\t    (priv->devtype_data.quirks & FLEXCAN_QUIRK_BROKEN_PERR_STATE) &&\n\t    !(priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING)) {\n\t\tswitch (priv->can.state) {\n\t\tcase CAN_STATE_ERROR_ACTIVE:\n\t\t\tif (priv->devtype_data.quirks &\n\t\t\t    FLEXCAN_QUIRK_BROKEN_WERR_STATE)\n\t\t\t\tflexcan_error_irq_enable(priv);\n\t\t\telse\n\t\t\t\tflexcan_error_irq_disable(priv);\n\t\t\tbreak;\n\n\t\tcase CAN_STATE_ERROR_WARNING:\n\t\t\tflexcan_error_irq_enable(priv);\n\t\t\tbreak;\n\n\t\tcase CAN_STATE_ERROR_PASSIVE:\n\t\tcase CAN_STATE_BUS_OFF:\n\t\t\tflexcan_error_irq_disable(priv);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (handled)\n\t\tcan_rx_offload_irq_finish(&priv->offload);\n\n\treturn handled;\n}\n\nstatic void flexcan_set_bittiming_ctrl(const struct net_device *dev)\n{\n\tconst struct flexcan_priv *priv = netdev_priv(dev);\n\tconst struct can_bittiming *bt = &priv->can.bittiming;\n\tstruct flexcan_regs __iomem *regs = priv->regs;\n\tu32 reg;\n\n\treg = priv->read(&regs->ctrl);\n\treg &= ~(FLEXCAN_CTRL_PRESDIV(0xff) |\n\t\t FLEXCAN_CTRL_RJW(0x3) |\n\t\t FLEXCAN_CTRL_PSEG1(0x7) |\n\t\t FLEXCAN_CTRL_PSEG2(0x7) |\n\t\t FLEXCAN_CTRL_PROPSEG(0x7));\n\n\treg |= FLEXCAN_CTRL_PRESDIV(bt->brp - 1) |\n\t\tFLEXCAN_CTRL_PSEG1(bt->phase_seg1 - 1) |\n\t\tFLEXCAN_CTRL_PSEG2(bt->phase_seg2 - 1) |\n\t\tFLEXCAN_CTRL_RJW(bt->sjw - 1) |\n\t\tFLEXCAN_CTRL_PROPSEG(bt->prop_seg - 1);\n\n\tnetdev_dbg(dev, \"writing ctrl=0x%08x\\n\", reg);\n\tpriv->write(reg, &regs->ctrl);\n\n\t \n\tnetdev_dbg(dev, \"%s: mcr=0x%08x ctrl=0x%08x\\n\", __func__,\n\t\t   priv->read(&regs->mcr), priv->read(&regs->ctrl));\n}\n\nstatic void flexcan_set_bittiming_cbt(const struct net_device *dev)\n{\n\tstruct flexcan_priv *priv = netdev_priv(dev);\n\tstruct can_bittiming *bt = &priv->can.bittiming;\n\tstruct can_bittiming *dbt = &priv->can.data_bittiming;\n\tstruct flexcan_regs __iomem *regs = priv->regs;\n\tu32 reg_cbt, reg_fdctrl;\n\n\t \n\t \n\tif (bt->phase_seg1 > 0x20) {\n\t\tbt->prop_seg += (bt->phase_seg1 - 0x20);\n\t\tbt->phase_seg1 = 0x20;\n\t}\n\n\treg_cbt = FLEXCAN_CBT_BTF |\n\t\tFIELD_PREP(FLEXCAN_CBT_EPRESDIV_MASK, bt->brp - 1) |\n\t\tFIELD_PREP(FLEXCAN_CBT_ERJW_MASK, bt->sjw - 1) |\n\t\tFIELD_PREP(FLEXCAN_CBT_EPROPSEG_MASK, bt->prop_seg - 1) |\n\t\tFIELD_PREP(FLEXCAN_CBT_EPSEG1_MASK, bt->phase_seg1 - 1) |\n\t\tFIELD_PREP(FLEXCAN_CBT_EPSEG2_MASK, bt->phase_seg2 - 1);\n\n\tnetdev_dbg(dev, \"writing cbt=0x%08x\\n\", reg_cbt);\n\tpriv->write(reg_cbt, &regs->cbt);\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_FD) {\n\t\tu32 reg_fdcbt, reg_ctrl2;\n\n\t\tif (bt->brp != dbt->brp)\n\t\t\tnetdev_warn(dev, \"Data brp=%d and brp=%d don't match, this may result in a phase error. Consider using different bitrate and/or data bitrate.\\n\",\n\t\t\t\t    dbt->brp, bt->brp);\n\n\t\t \n\t\t \n\t\tif (dbt->phase_seg1 > 0x8) {\n\t\t\tdbt->prop_seg += (dbt->phase_seg1 - 0x8);\n\t\t\tdbt->phase_seg1 = 0x8;\n\t\t}\n\n\t\treg_fdcbt = priv->read(&regs->fdcbt);\n\t\treg_fdcbt &= ~(FIELD_PREP(FLEXCAN_FDCBT_FPRESDIV_MASK, 0x3ff) |\n\t\t\t       FIELD_PREP(FLEXCAN_FDCBT_FRJW_MASK, 0x7) |\n\t\t\t       FIELD_PREP(FLEXCAN_FDCBT_FPROPSEG_MASK, 0x1f) |\n\t\t\t       FIELD_PREP(FLEXCAN_FDCBT_FPSEG1_MASK, 0x7) |\n\t\t\t       FIELD_PREP(FLEXCAN_FDCBT_FPSEG2_MASK, 0x7));\n\n\t\treg_fdcbt |= FIELD_PREP(FLEXCAN_FDCBT_FPRESDIV_MASK, dbt->brp - 1) |\n\t\t\tFIELD_PREP(FLEXCAN_FDCBT_FRJW_MASK, dbt->sjw - 1) |\n\t\t\tFIELD_PREP(FLEXCAN_FDCBT_FPROPSEG_MASK, dbt->prop_seg) |\n\t\t\tFIELD_PREP(FLEXCAN_FDCBT_FPSEG1_MASK, dbt->phase_seg1 - 1) |\n\t\t\tFIELD_PREP(FLEXCAN_FDCBT_FPSEG2_MASK, dbt->phase_seg2 - 1);\n\n\t\tnetdev_dbg(dev, \"writing fdcbt=0x%08x\\n\", reg_fdcbt);\n\t\tpriv->write(reg_fdcbt, &regs->fdcbt);\n\n\t\t \n\t\treg_ctrl2 = priv->read(&regs->ctrl2);\n\t\treg_ctrl2 &= ~FLEXCAN_CTRL2_ISOCANFDEN;\n\t\tif (!(priv->can.ctrlmode & CAN_CTRLMODE_FD_NON_ISO))\n\t\t\treg_ctrl2 |= FLEXCAN_CTRL2_ISOCANFDEN;\n\n\t\tnetdev_dbg(dev, \"writing ctrl2=0x%08x\\n\", reg_ctrl2);\n\t\tpriv->write(reg_ctrl2, &regs->ctrl2);\n\t}\n\n\t \n\treg_fdctrl = priv->read(&regs->fdctrl);\n\treg_fdctrl &= ~(FLEXCAN_FDCTRL_FDRATE |\n\t\t\tFIELD_PREP(FLEXCAN_FDCTRL_TDCOFF, 0x1f));\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_FD) {\n\t\treg_fdctrl |= FLEXCAN_FDCTRL_FDRATE;\n\n\t\tif (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK) {\n\t\t\t \n\t\t\treg_fdctrl &= ~FLEXCAN_FDCTRL_TDCEN;\n\t\t} else {\n\t\t\treg_fdctrl |= FLEXCAN_FDCTRL_TDCEN |\n\t\t\t\tFIELD_PREP(FLEXCAN_FDCTRL_TDCOFF,\n\t\t\t\t\t   ((dbt->phase_seg1 - 1) +\n\t\t\t\t\t    dbt->prop_seg + 2) *\n\t\t\t\t\t   ((dbt->brp - 1 ) + 1));\n\t\t}\n\t}\n\n\tnetdev_dbg(dev, \"writing fdctrl=0x%08x\\n\", reg_fdctrl);\n\tpriv->write(reg_fdctrl, &regs->fdctrl);\n\n\tnetdev_dbg(dev, \"%s: mcr=0x%08x ctrl=0x%08x ctrl2=0x%08x fdctrl=0x%08x cbt=0x%08x fdcbt=0x%08x\\n\",\n\t\t   __func__,\n\t\t   priv->read(&regs->mcr), priv->read(&regs->ctrl),\n\t\t   priv->read(&regs->ctrl2), priv->read(&regs->fdctrl),\n\t\t   priv->read(&regs->cbt), priv->read(&regs->fdcbt));\n}\n\nstatic void flexcan_set_bittiming(struct net_device *dev)\n{\n\tconst struct flexcan_priv *priv = netdev_priv(dev);\n\tstruct flexcan_regs __iomem *regs = priv->regs;\n\tu32 reg;\n\n\treg = priv->read(&regs->ctrl);\n\treg &= ~(FLEXCAN_CTRL_LPB | FLEXCAN_CTRL_SMP |\n\t\t FLEXCAN_CTRL_LOM);\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\treg |= FLEXCAN_CTRL_LPB;\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\treg |= FLEXCAN_CTRL_LOM;\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\treg |= FLEXCAN_CTRL_SMP;\n\n\tnetdev_dbg(dev, \"writing ctrl=0x%08x\\n\", reg);\n\tpriv->write(reg, &regs->ctrl);\n\n\tif (priv->can.ctrlmode_supported & CAN_CTRLMODE_FD)\n\t\treturn flexcan_set_bittiming_cbt(dev);\n\telse\n\t\treturn flexcan_set_bittiming_ctrl(dev);\n}\n\nstatic void flexcan_ram_init(struct net_device *dev)\n{\n\tstruct flexcan_priv *priv = netdev_priv(dev);\n\tstruct flexcan_regs __iomem *regs = priv->regs;\n\tu32 reg_ctrl2;\n\n\t \n\treg_ctrl2 = priv->read(&regs->ctrl2);\n\treg_ctrl2 |= FLEXCAN_CTRL2_WRMFRZ;\n\tpriv->write(reg_ctrl2, &regs->ctrl2);\n\n\tmemset_io(&regs->init, 0, sizeof(regs->init));\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_FD)\n\t\tmemset_io(&regs->init_fd, 0, sizeof(regs->init_fd));\n\n\treg_ctrl2 &= ~FLEXCAN_CTRL2_WRMFRZ;\n\tpriv->write(reg_ctrl2, &regs->ctrl2);\n}\n\nstatic int flexcan_rx_offload_setup(struct net_device *dev)\n{\n\tstruct flexcan_priv *priv = netdev_priv(dev);\n\tint err;\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_FD)\n\t\tpriv->mb_size = sizeof(struct flexcan_mb) + CANFD_MAX_DLEN;\n\telse\n\t\tpriv->mb_size = sizeof(struct flexcan_mb) + CAN_MAX_DLEN;\n\n\tif (priv->devtype_data.quirks & FLEXCAN_QUIRK_NR_MB_16)\n\t\tpriv->mb_count = 16;\n\telse\n\t\tpriv->mb_count = (sizeof(priv->regs->mb[0]) / priv->mb_size) +\n\t\t\t\t (sizeof(priv->regs->mb[1]) / priv->mb_size);\n\n\tif (priv->devtype_data.quirks & FLEXCAN_QUIRK_USE_RX_MAILBOX)\n\t\tpriv->tx_mb_reserved =\n\t\t\tflexcan_get_mb(priv, FLEXCAN_TX_MB_RESERVED_RX_MAILBOX);\n\telse\n\t\tpriv->tx_mb_reserved =\n\t\t\tflexcan_get_mb(priv, FLEXCAN_TX_MB_RESERVED_RX_FIFO);\n\tpriv->tx_mb_idx = priv->mb_count - 1;\n\tpriv->tx_mb = flexcan_get_mb(priv, priv->tx_mb_idx);\n\tpriv->tx_mask = FLEXCAN_IFLAG_MB(priv->tx_mb_idx);\n\n\tpriv->offload.mailbox_read = flexcan_mailbox_read;\n\n\tif (priv->devtype_data.quirks & FLEXCAN_QUIRK_USE_RX_MAILBOX) {\n\t\tpriv->offload.mb_first = FLEXCAN_RX_MB_RX_MAILBOX_FIRST;\n\t\tpriv->offload.mb_last = priv->mb_count - 2;\n\n\t\tpriv->rx_mask = GENMASK_ULL(priv->offload.mb_last,\n\t\t\t\t\t    priv->offload.mb_first);\n\t\terr = can_rx_offload_add_timestamp(dev, &priv->offload);\n\t} else {\n\t\tpriv->rx_mask = FLEXCAN_IFLAG_RX_FIFO_OVERFLOW |\n\t\t\tFLEXCAN_IFLAG_RX_FIFO_AVAILABLE;\n\t\terr = can_rx_offload_add_fifo(dev, &priv->offload,\n\t\t\t\t\t      FLEXCAN_NAPI_WEIGHT);\n\t}\n\n\treturn err;\n}\n\nstatic void flexcan_chip_interrupts_enable(const struct net_device *dev)\n{\n\tconst struct flexcan_priv *priv = netdev_priv(dev);\n\tstruct flexcan_regs __iomem *regs = priv->regs;\n\tu64 reg_imask;\n\n\tdisable_irq(dev->irq);\n\tpriv->write(priv->reg_ctrl_default, &regs->ctrl);\n\treg_imask = priv->rx_mask | priv->tx_mask;\n\tpriv->write(upper_32_bits(reg_imask), &regs->imask2);\n\tpriv->write(lower_32_bits(reg_imask), &regs->imask1);\n\tenable_irq(dev->irq);\n}\n\nstatic void flexcan_chip_interrupts_disable(const struct net_device *dev)\n{\n\tconst struct flexcan_priv *priv = netdev_priv(dev);\n\tstruct flexcan_regs __iomem *regs = priv->regs;\n\n\tpriv->write(0, &regs->imask2);\n\tpriv->write(0, &regs->imask1);\n\tpriv->write(priv->reg_ctrl_default & ~FLEXCAN_CTRL_ERR_ALL,\n\t\t    &regs->ctrl);\n}\n\n \nstatic int flexcan_chip_start(struct net_device *dev)\n{\n\tstruct flexcan_priv *priv = netdev_priv(dev);\n\tstruct flexcan_regs __iomem *regs = priv->regs;\n\tu32 reg_mcr, reg_ctrl, reg_ctrl2, reg_mecr;\n\tint err, i;\n\tstruct flexcan_mb __iomem *mb;\n\n\t \n\terr = flexcan_chip_enable(priv);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = flexcan_chip_softreset(priv);\n\tif (err)\n\t\tgoto out_chip_disable;\n\n\tif (priv->devtype_data.quirks & FLEXCAN_QUIRK_SUPPORT_ECC)\n\t\tflexcan_ram_init(dev);\n\n\tflexcan_set_bittiming(dev);\n\n\t \n\terr = flexcan_chip_freeze(priv);\n\tif (err)\n\t\tgoto out_chip_disable;\n\n\t \n\treg_mcr = priv->read(&regs->mcr);\n\treg_mcr &= ~FLEXCAN_MCR_MAXMB(0xff);\n\treg_mcr |= FLEXCAN_MCR_SUPV | FLEXCAN_MCR_WRN_EN | FLEXCAN_MCR_IRMQ |\n\t\tFLEXCAN_MCR_IDAM_C | FLEXCAN_MCR_MAXMB(priv->tx_mb_idx);\n\n\t \n\tif (priv->devtype_data.quirks & FLEXCAN_QUIRK_USE_RX_MAILBOX)\n\t\treg_mcr &= ~FLEXCAN_MCR_FEN;\n\telse\n\t\treg_mcr |= FLEXCAN_MCR_FEN;\n\n\t \n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\treg_mcr &= ~FLEXCAN_MCR_SRX_DIS;\n\telse\n\t\treg_mcr |= FLEXCAN_MCR_SRX_DIS;\n\n\t \n\tif (priv->can.ctrlmode & CAN_CTRLMODE_FD)\n\t\treg_mcr |= FLEXCAN_MCR_FDEN;\n\telse\n\t\treg_mcr &= ~FLEXCAN_MCR_FDEN;\n\n\tnetdev_dbg(dev, \"%s: writing mcr=0x%08x\", __func__, reg_mcr);\n\tpriv->write(reg_mcr, &regs->mcr);\n\n\t \n\treg_ctrl = priv->read(&regs->ctrl);\n\treg_ctrl &= ~FLEXCAN_CTRL_TSYN;\n\treg_ctrl |= FLEXCAN_CTRL_BOFF_REC | FLEXCAN_CTRL_LBUF |\n\t\tFLEXCAN_CTRL_ERR_STATE;\n\n\t \n\tif (priv->devtype_data.quirks & FLEXCAN_QUIRK_BROKEN_WERR_STATE ||\n\t    priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING)\n\t\treg_ctrl |= FLEXCAN_CTRL_ERR_MSK;\n\telse\n\t\treg_ctrl &= ~FLEXCAN_CTRL_ERR_MSK;\n\n\t \n\tpriv->reg_ctrl_default = reg_ctrl;\n\t \n\treg_ctrl &= ~FLEXCAN_CTRL_ERR_ALL;\n\tnetdev_dbg(dev, \"%s: writing ctrl=0x%08x\", __func__, reg_ctrl);\n\tpriv->write(reg_ctrl, &regs->ctrl);\n\n\tif ((priv->devtype_data.quirks & FLEXCAN_QUIRK_ENABLE_EACEN_RRS)) {\n\t\treg_ctrl2 = priv->read(&regs->ctrl2);\n\t\treg_ctrl2 |= FLEXCAN_CTRL2_EACEN | FLEXCAN_CTRL2_RRS;\n\t\tpriv->write(reg_ctrl2, &regs->ctrl2);\n\t}\n\n\tif (priv->can.ctrlmode_supported & CAN_CTRLMODE_FD) {\n\t\tu32 reg_fdctrl;\n\n\t\treg_fdctrl = priv->read(&regs->fdctrl);\n\t\treg_fdctrl &= ~(FIELD_PREP(FLEXCAN_FDCTRL_MBDSR1, 0x3) |\n\t\t\t\tFIELD_PREP(FLEXCAN_FDCTRL_MBDSR0, 0x3));\n\n\t\tif (priv->can.ctrlmode & CAN_CTRLMODE_FD) {\n\t\t\treg_fdctrl |=\n\t\t\t\tFIELD_PREP(FLEXCAN_FDCTRL_MBDSR1,\n\t\t\t\t\t   FLEXCAN_FDCTRL_MBDSR_64) |\n\t\t\t\tFIELD_PREP(FLEXCAN_FDCTRL_MBDSR0,\n\t\t\t\t\t   FLEXCAN_FDCTRL_MBDSR_64);\n\t\t} else {\n\t\t\treg_fdctrl |=\n\t\t\t\tFIELD_PREP(FLEXCAN_FDCTRL_MBDSR1,\n\t\t\t\t\t   FLEXCAN_FDCTRL_MBDSR_8) |\n\t\t\t\tFIELD_PREP(FLEXCAN_FDCTRL_MBDSR0,\n\t\t\t\t\t   FLEXCAN_FDCTRL_MBDSR_8);\n\t\t}\n\n\t\tnetdev_dbg(dev, \"%s: writing fdctrl=0x%08x\",\n\t\t\t   __func__, reg_fdctrl);\n\t\tpriv->write(reg_fdctrl, &regs->fdctrl);\n\t}\n\n\tif (priv->devtype_data.quirks & FLEXCAN_QUIRK_USE_RX_MAILBOX) {\n\t\tfor (i = priv->offload.mb_first; i <= priv->offload.mb_last; i++) {\n\t\t\tmb = flexcan_get_mb(priv, i);\n\t\t\tpriv->write(FLEXCAN_MB_CODE_RX_EMPTY,\n\t\t\t\t    &mb->can_ctrl);\n\t\t}\n\t} else {\n\t\t \n\t\tfor (i = FLEXCAN_TX_MB_RESERVED_RX_FIFO; i < priv->mb_count; i++) {\n\t\t\tmb = flexcan_get_mb(priv, i);\n\t\t\tpriv->write(FLEXCAN_MB_CODE_RX_INACTIVE,\n\t\t\t\t    &mb->can_ctrl);\n\t\t}\n\t}\n\n\t \n\tpriv->write(FLEXCAN_MB_CODE_TX_INACTIVE,\n\t\t    &priv->tx_mb_reserved->can_ctrl);\n\n\t \n\tpriv->write(FLEXCAN_MB_CODE_TX_INACTIVE,\n\t\t    &priv->tx_mb->can_ctrl);\n\n\t \n\tpriv->write(0x0, &regs->rxgmask);\n\tpriv->write(0x0, &regs->rx14mask);\n\tpriv->write(0x0, &regs->rx15mask);\n\n\tif (priv->devtype_data.quirks & FLEXCAN_QUIRK_DISABLE_RXFG)\n\t\tpriv->write(0x0, &regs->rxfgmask);\n\n\t \n\tfor (i = 0; i < priv->mb_count; i++)\n\t\tpriv->write(0, &regs->rximr[i]);\n\n\t \n\tif (priv->devtype_data.quirks & FLEXCAN_QUIRK_DISABLE_MECR) {\n\t\t \n\t\treg_ctrl2 = priv->read(&regs->ctrl2);\n\t\treg_ctrl2 |= FLEXCAN_CTRL2_ECRWRE;\n\t\tpriv->write(reg_ctrl2, &regs->ctrl2);\n\n\t\t \n\t\treg_mecr = priv->read(&regs->mecr);\n\t\treg_mecr &= ~FLEXCAN_MECR_ECRWRDIS;\n\t\tpriv->write(reg_mecr, &regs->mecr);\n\n\t\t \n\t\treg_mecr &= ~(FLEXCAN_MECR_NCEFAFRZ | FLEXCAN_MECR_HANCEI_MSK |\n\t\t\t      FLEXCAN_MECR_FANCEI_MSK);\n\t\tpriv->write(reg_mecr, &regs->mecr);\n\n\t\t \n\t\treg_mecr |= FLEXCAN_MECR_ECRWRDIS;\n\t\tpriv->write(reg_mecr, &regs->mecr);\n\n\t\treg_ctrl2 &= ~FLEXCAN_CTRL2_ECRWRE;\n\t\tpriv->write(reg_ctrl2, &regs->ctrl2);\n\t}\n\n\t \n\terr = flexcan_chip_unfreeze(priv);\n\tif (err)\n\t\tgoto out_chip_disable;\n\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\t \n\tnetdev_dbg(dev, \"%s: reading mcr=0x%08x ctrl=0x%08x\\n\", __func__,\n\t\t   priv->read(&regs->mcr), priv->read(&regs->ctrl));\n\n\treturn 0;\n\n out_chip_disable:\n\tflexcan_chip_disable(priv);\n\treturn err;\n}\n\n \nstatic int __flexcan_chip_stop(struct net_device *dev, bool disable_on_error)\n{\n\tstruct flexcan_priv *priv = netdev_priv(dev);\n\tint err;\n\n\t \n\terr = flexcan_chip_freeze(priv);\n\tif (err && !disable_on_error)\n\t\treturn err;\n\terr = flexcan_chip_disable(priv);\n\tif (err && !disable_on_error)\n\t\tgoto out_chip_unfreeze;\n\n\tpriv->can.state = CAN_STATE_STOPPED;\n\n\treturn 0;\n\n out_chip_unfreeze:\n\tflexcan_chip_unfreeze(priv);\n\n\treturn err;\n}\n\nstatic inline int flexcan_chip_stop_disable_on_error(struct net_device *dev)\n{\n\treturn __flexcan_chip_stop(dev, true);\n}\n\nstatic inline int flexcan_chip_stop(struct net_device *dev)\n{\n\treturn __flexcan_chip_stop(dev, false);\n}\n\nstatic int flexcan_open(struct net_device *dev)\n{\n\tstruct flexcan_priv *priv = netdev_priv(dev);\n\tint err;\n\n\tif ((priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES) &&\n\t    (priv->can.ctrlmode & CAN_CTRLMODE_FD)) {\n\t\tnetdev_err(dev, \"Three Samples mode and CAN-FD mode can't be used together\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = pm_runtime_resume_and_get(priv->dev);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = open_candev(dev);\n\tif (err)\n\t\tgoto out_runtime_put;\n\n\terr = flexcan_transceiver_enable(priv);\n\tif (err)\n\t\tgoto out_close;\n\n\terr = flexcan_rx_offload_setup(dev);\n\tif (err)\n\t\tgoto out_transceiver_disable;\n\n\terr = flexcan_chip_start(dev);\n\tif (err)\n\t\tgoto out_can_rx_offload_del;\n\n\tcan_rx_offload_enable(&priv->offload);\n\n\terr = request_irq(dev->irq, flexcan_irq, IRQF_SHARED, dev->name, dev);\n\tif (err)\n\t\tgoto out_can_rx_offload_disable;\n\n\tif (priv->devtype_data.quirks & FLEXCAN_QUIRK_NR_IRQ_3) {\n\t\terr = request_irq(priv->irq_boff,\n\t\t\t\t  flexcan_irq, IRQF_SHARED, dev->name, dev);\n\t\tif (err)\n\t\t\tgoto out_free_irq;\n\n\t\terr = request_irq(priv->irq_err,\n\t\t\t\t  flexcan_irq, IRQF_SHARED, dev->name, dev);\n\t\tif (err)\n\t\t\tgoto out_free_irq_boff;\n\t}\n\n\tflexcan_chip_interrupts_enable(dev);\n\n\tnetif_start_queue(dev);\n\n\treturn 0;\n\n out_free_irq_boff:\n\tfree_irq(priv->irq_boff, dev);\n out_free_irq:\n\tfree_irq(dev->irq, dev);\n out_can_rx_offload_disable:\n\tcan_rx_offload_disable(&priv->offload);\n\tflexcan_chip_stop(dev);\n out_can_rx_offload_del:\n\tcan_rx_offload_del(&priv->offload);\n out_transceiver_disable:\n\tflexcan_transceiver_disable(priv);\n out_close:\n\tclose_candev(dev);\n out_runtime_put:\n\tpm_runtime_put(priv->dev);\n\n\treturn err;\n}\n\nstatic int flexcan_close(struct net_device *dev)\n{\n\tstruct flexcan_priv *priv = netdev_priv(dev);\n\n\tnetif_stop_queue(dev);\n\tflexcan_chip_interrupts_disable(dev);\n\n\tif (priv->devtype_data.quirks & FLEXCAN_QUIRK_NR_IRQ_3) {\n\t\tfree_irq(priv->irq_err, dev);\n\t\tfree_irq(priv->irq_boff, dev);\n\t}\n\n\tfree_irq(dev->irq, dev);\n\tcan_rx_offload_disable(&priv->offload);\n\tflexcan_chip_stop_disable_on_error(dev);\n\n\tcan_rx_offload_del(&priv->offload);\n\tflexcan_transceiver_disable(priv);\n\tclose_candev(dev);\n\n\tpm_runtime_put(priv->dev);\n\n\treturn 0;\n}\n\nstatic int flexcan_set_mode(struct net_device *dev, enum can_mode mode)\n{\n\tint err;\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\terr = flexcan_chip_start(dev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tflexcan_chip_interrupts_enable(dev);\n\n\t\tnetif_wake_queue(dev);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops flexcan_netdev_ops = {\n\t.ndo_open\t= flexcan_open,\n\t.ndo_stop\t= flexcan_close,\n\t.ndo_start_xmit\t= flexcan_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic int register_flexcandev(struct net_device *dev)\n{\n\tstruct flexcan_priv *priv = netdev_priv(dev);\n\tstruct flexcan_regs __iomem *regs = priv->regs;\n\tu32 reg, err;\n\n\terr = flexcan_clks_enable(priv);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = flexcan_chip_disable(priv);\n\tif (err)\n\t\tgoto out_clks_disable;\n\n\treg = priv->read(&regs->ctrl);\n\tif (priv->clk_src)\n\t\treg |= FLEXCAN_CTRL_CLK_SRC;\n\telse\n\t\treg &= ~FLEXCAN_CTRL_CLK_SRC;\n\tpriv->write(reg, &regs->ctrl);\n\n\terr = flexcan_chip_enable(priv);\n\tif (err)\n\t\tgoto out_chip_disable;\n\n\t \n\terr = flexcan_chip_freeze(priv);\n\tif (err)\n\t\tgoto out_chip_disable;\n\n\t \n\treg = priv->read(&regs->mcr);\n\treg |=  FLEXCAN_MCR_FEN | FLEXCAN_MCR_SUPV;\n\tpriv->write(reg, &regs->mcr);\n\n\t \n\treg = priv->read(&regs->mcr);\n\tif (!(reg & FLEXCAN_MCR_FEN)) {\n\t\tnetdev_err(dev, \"Could not enable RX FIFO, unsupported core\\n\");\n\t\terr = -ENODEV;\n\t\tgoto out_chip_disable;\n\t}\n\n\terr = register_candev(dev);\n\tif (err)\n\t\tgoto out_chip_disable;\n\n\t \n\tflexcan_chip_disable(priv);\n\tpm_runtime_put(priv->dev);\n\n\treturn 0;\n\n out_chip_disable:\n\tflexcan_chip_disable(priv);\n out_clks_disable:\n\tflexcan_clks_disable(priv);\n\treturn err;\n}\n\nstatic void unregister_flexcandev(struct net_device *dev)\n{\n\tunregister_candev(dev);\n}\n\nstatic int flexcan_setup_stop_mode_gpr(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *gpr_np;\n\tstruct flexcan_priv *priv;\n\tphandle phandle;\n\tu32 out_val[3];\n\tint ret;\n\n\tif (!np)\n\t\treturn -EINVAL;\n\n\t \n\tret = of_property_read_u32_array(np, \"fsl,stop-mode\", out_val,\n\t\t\t\t\t ARRAY_SIZE(out_val));\n\tif (ret) {\n\t\tdev_dbg(&pdev->dev, \"no stop-mode property\\n\");\n\t\treturn ret;\n\t}\n\tphandle = *out_val;\n\n\tgpr_np = of_find_node_by_phandle(phandle);\n\tif (!gpr_np) {\n\t\tdev_dbg(&pdev->dev, \"could not find gpr node by phandle\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = netdev_priv(dev);\n\tpriv->stm.gpr = syscon_node_to_regmap(gpr_np);\n\tif (IS_ERR(priv->stm.gpr)) {\n\t\tdev_dbg(&pdev->dev, \"could not find gpr regmap\\n\");\n\t\tret = PTR_ERR(priv->stm.gpr);\n\t\tgoto out_put_node;\n\t}\n\n\tpriv->stm.req_gpr = out_val[1];\n\tpriv->stm.req_bit = out_val[2];\n\n\tdev_dbg(&pdev->dev,\n\t\t\"gpr %s req_gpr=0x02%x req_bit=%u\\n\",\n\t\tgpr_np->full_name, priv->stm.req_gpr, priv->stm.req_bit);\n\n\treturn 0;\n\nout_put_node:\n\tof_node_put(gpr_np);\n\treturn ret;\n}\n\nstatic int flexcan_setup_stop_mode_scfw(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\tstruct flexcan_priv *priv;\n\tu8 scu_idx;\n\tint ret;\n\n\tret = of_property_read_u8(pdev->dev.of_node, \"fsl,scu-index\", &scu_idx);\n\tif (ret < 0) {\n\t\tdev_dbg(&pdev->dev, \"failed to get scu index\\n\");\n\t\treturn ret;\n\t}\n\n\tpriv = netdev_priv(dev);\n\tpriv->scu_idx = scu_idx;\n\n\t \n\treturn imx_scu_get_handle(&priv->sc_ipc_handle);\n}\n\n \nstatic int flexcan_setup_stop_mode(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\tstruct flexcan_priv *priv;\n\tint ret;\n\n\tpriv = netdev_priv(dev);\n\n\tif (priv->devtype_data.quirks & FLEXCAN_QUIRK_SETUP_STOP_MODE_SCFW)\n\t\tret = flexcan_setup_stop_mode_scfw(pdev);\n\telse if (priv->devtype_data.quirks & FLEXCAN_QUIRK_SETUP_STOP_MODE_GPR)\n\t\tret = flexcan_setup_stop_mode_gpr(pdev);\n\telse\n\t\t \n\t\treturn 0;\n\n\t \n\tif (ret == -EINVAL)\n\t\treturn 0;\n\telse if (ret)\n\t\treturn ret;\n\n\tdevice_set_wakeup_capable(&pdev->dev, true);\n\n\tif (of_property_read_bool(pdev->dev.of_node, \"wakeup-source\"))\n\t\tdevice_set_wakeup_enable(&pdev->dev, true);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id flexcan_of_match[] = {\n\t{ .compatible = \"fsl,imx8qm-flexcan\", .data = &fsl_imx8qm_devtype_data, },\n\t{ .compatible = \"fsl,imx8mp-flexcan\", .data = &fsl_imx8mp_devtype_data, },\n\t{ .compatible = \"fsl,imx93-flexcan\", .data = &fsl_imx93_devtype_data, },\n\t{ .compatible = \"fsl,imx6q-flexcan\", .data = &fsl_imx6q_devtype_data, },\n\t{ .compatible = \"fsl,imx28-flexcan\", .data = &fsl_imx28_devtype_data, },\n\t{ .compatible = \"fsl,imx53-flexcan\", .data = &fsl_imx25_devtype_data, },\n\t{ .compatible = \"fsl,imx35-flexcan\", .data = &fsl_imx25_devtype_data, },\n\t{ .compatible = \"fsl,imx25-flexcan\", .data = &fsl_imx25_devtype_data, },\n\t{ .compatible = \"fsl,p1010-flexcan\", .data = &fsl_p1010_devtype_data, },\n\t{ .compatible = \"fsl,vf610-flexcan\", .data = &fsl_vf610_devtype_data, },\n\t{ .compatible = \"fsl,ls1021ar2-flexcan\", .data = &fsl_ls1021a_r2_devtype_data, },\n\t{ .compatible = \"fsl,lx2160ar1-flexcan\", .data = &fsl_lx2160a_r1_devtype_data, },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, flexcan_of_match);\n\nstatic const struct platform_device_id flexcan_id_table[] = {\n\t{\n\t\t.name = \"flexcan-mcf5441x\",\n\t\t.driver_data = (kernel_ulong_t)&fsl_mcf5441x_devtype_data,\n\t}, {\n\t\t \n\t},\n};\nMODULE_DEVICE_TABLE(platform, flexcan_id_table);\n\nstatic int flexcan_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *of_id;\n\tconst struct flexcan_devtype_data *devtype_data;\n\tstruct net_device *dev;\n\tstruct flexcan_priv *priv;\n\tstruct regulator *reg_xceiver;\n\tstruct clk *clk_ipg = NULL, *clk_per = NULL;\n\tstruct flexcan_regs __iomem *regs;\n\tstruct flexcan_platform_data *pdata;\n\tint err, irq;\n\tu8 clk_src = 1;\n\tu32 clock_freq = 0;\n\n\treg_xceiver = devm_regulator_get_optional(&pdev->dev, \"xceiver\");\n\tif (PTR_ERR(reg_xceiver) == -EPROBE_DEFER)\n\t\treturn -EPROBE_DEFER;\n\telse if (PTR_ERR(reg_xceiver) == -ENODEV)\n\t\treg_xceiver = NULL;\n\telse if (IS_ERR(reg_xceiver))\n\t\treturn PTR_ERR(reg_xceiver);\n\n\tif (pdev->dev.of_node) {\n\t\tof_property_read_u32(pdev->dev.of_node,\n\t\t\t\t     \"clock-frequency\", &clock_freq);\n\t\tof_property_read_u8(pdev->dev.of_node,\n\t\t\t\t    \"fsl,clk-source\", &clk_src);\n\t} else {\n\t\tpdata = dev_get_platdata(&pdev->dev);\n\t\tif (pdata) {\n\t\t\tclock_freq = pdata->clock_frequency;\n\t\t\tclk_src = pdata->clk_src;\n\t\t}\n\t}\n\n\tif (!clock_freq) {\n\t\tclk_ipg = devm_clk_get(&pdev->dev, \"ipg\");\n\t\tif (IS_ERR(clk_ipg)) {\n\t\t\tdev_err(&pdev->dev, \"no ipg clock defined\\n\");\n\t\t\treturn PTR_ERR(clk_ipg);\n\t\t}\n\n\t\tclk_per = devm_clk_get(&pdev->dev, \"per\");\n\t\tif (IS_ERR(clk_per)) {\n\t\t\tdev_err(&pdev->dev, \"no per clock defined\\n\");\n\t\t\treturn PTR_ERR(clk_per);\n\t\t}\n\t\tclock_freq = clk_get_rate(clk_per);\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tof_id = of_match_device(flexcan_of_match, &pdev->dev);\n\tif (of_id)\n\t\tdevtype_data = of_id->data;\n\telse if (platform_get_device_id(pdev)->driver_data)\n\t\tdevtype_data = (struct flexcan_devtype_data *)\n\t\t\tplatform_get_device_id(pdev)->driver_data;\n\telse\n\t\treturn -ENODEV;\n\n\tif ((devtype_data->quirks & FLEXCAN_QUIRK_SUPPORT_FD) &&\n\t    !((devtype_data->quirks &\n\t       (FLEXCAN_QUIRK_USE_RX_MAILBOX |\n\t\tFLEXCAN_QUIRK_SUPPORT_RX_MAILBOX |\n\t\tFLEXCAN_QUIRK_SUPPORT_RX_MAILBOX_RTR |\n\t\tFLEXCAN_QUIRK_SUPPORT_RX_FIFO)) ==\n\t      (FLEXCAN_QUIRK_USE_RX_MAILBOX |\n\t       FLEXCAN_QUIRK_SUPPORT_RX_MAILBOX |\n\t       FLEXCAN_QUIRK_SUPPORT_RX_MAILBOX_RTR))) {\n\t\tdev_err(&pdev->dev, \"CAN-FD mode doesn't work in RX-FIFO mode!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((devtype_data->quirks &\n\t     (FLEXCAN_QUIRK_SUPPORT_RX_MAILBOX |\n\t      FLEXCAN_QUIRK_SUPPORT_RX_MAILBOX_RTR)) ==\n\t    FLEXCAN_QUIRK_SUPPORT_RX_MAILBOX_RTR) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Quirks (0x%08x) inconsistent: RX_MAILBOX_RX supported but not RX_MAILBOX\\n\",\n\t\t\tdevtype_data->quirks);\n\t\treturn -EINVAL;\n\t}\n\n\tdev = alloc_candev(sizeof(struct flexcan_priv), 1);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, dev);\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\tdev->netdev_ops = &flexcan_netdev_ops;\n\tdev->ethtool_ops = &flexcan_ethtool_ops;\n\tdev->irq = irq;\n\tdev->flags |= IFF_ECHO;\n\n\tpriv = netdev_priv(dev);\n\tpriv->devtype_data = *devtype_data;\n\n\tif (of_property_read_bool(pdev->dev.of_node, \"big-endian\") ||\n\t    priv->devtype_data.quirks & FLEXCAN_QUIRK_DEFAULT_BIG_ENDIAN) {\n\t\tpriv->read = flexcan_read_be;\n\t\tpriv->write = flexcan_write_be;\n\t} else {\n\t\tpriv->read = flexcan_read_le;\n\t\tpriv->write = flexcan_write_le;\n\t}\n\n\tpriv->dev = &pdev->dev;\n\tpriv->can.clock.freq = clock_freq;\n\tpriv->can.do_set_mode = flexcan_set_mode;\n\tpriv->can.do_get_berr_counter = flexcan_get_berr_counter;\n\tpriv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |\n\t\tCAN_CTRLMODE_LISTENONLY\t| CAN_CTRLMODE_3_SAMPLES |\n\t\tCAN_CTRLMODE_BERR_REPORTING;\n\tpriv->regs = regs;\n\tpriv->clk_ipg = clk_ipg;\n\tpriv->clk_per = clk_per;\n\tpriv->clk_src = clk_src;\n\tpriv->reg_xceiver = reg_xceiver;\n\n\tif (priv->devtype_data.quirks & FLEXCAN_QUIRK_NR_IRQ_3) {\n\t\tpriv->irq_boff = platform_get_irq(pdev, 1);\n\t\tif (priv->irq_boff < 0) {\n\t\t\terr = priv->irq_boff;\n\t\t\tgoto failed_platform_get_irq;\n\t\t}\n\t\tpriv->irq_err = platform_get_irq(pdev, 2);\n\t\tif (priv->irq_err < 0) {\n\t\t\terr = priv->irq_err;\n\t\t\tgoto failed_platform_get_irq;\n\t\t}\n\t}\n\n\tif (priv->devtype_data.quirks & FLEXCAN_QUIRK_SUPPORT_FD) {\n\t\tpriv->can.ctrlmode_supported |= CAN_CTRLMODE_FD |\n\t\t\tCAN_CTRLMODE_FD_NON_ISO;\n\t\tpriv->can.bittiming_const = &flexcan_fd_bittiming_const;\n\t\tpriv->can.data_bittiming_const =\n\t\t\t&flexcan_fd_data_bittiming_const;\n\t} else {\n\t\tpriv->can.bittiming_const = &flexcan_bittiming_const;\n\t}\n\n\tpm_runtime_get_noresume(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\terr = register_flexcandev(dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"registering netdev failed\\n\");\n\t\tgoto failed_register;\n\t}\n\n\terr = flexcan_setup_stop_mode(pdev);\n\tif (err < 0) {\n\t\tdev_err_probe(&pdev->dev, err, \"setup stop mode failed\\n\");\n\t\tgoto failed_setup_stop_mode;\n\t}\n\n\tof_can_transceiver(dev);\n\n\treturn 0;\n\n failed_setup_stop_mode:\n\tunregister_flexcandev(dev);\n failed_register:\n\tpm_runtime_put_noidle(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n failed_platform_get_irq:\n\tfree_candev(dev);\n\treturn err;\n}\n\nstatic void flexcan_remove(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\n\tdevice_set_wakeup_enable(&pdev->dev, false);\n\tdevice_set_wakeup_capable(&pdev->dev, false);\n\tunregister_flexcandev(dev);\n\tpm_runtime_disable(&pdev->dev);\n\tfree_candev(dev);\n}\n\nstatic int __maybe_unused flexcan_suspend(struct device *device)\n{\n\tstruct net_device *dev = dev_get_drvdata(device);\n\tstruct flexcan_priv *priv = netdev_priv(dev);\n\tint err;\n\n\tif (netif_running(dev)) {\n\t\t \n\t\tif (device_may_wakeup(device)) {\n\t\t\tenable_irq_wake(dev->irq);\n\t\t\terr = flexcan_enter_stop_mode(priv);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\terr = flexcan_chip_stop(dev);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tflexcan_chip_interrupts_disable(dev);\n\n\t\t\terr = pinctrl_pm_select_sleep_state(device);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tnetif_stop_queue(dev);\n\t\tnetif_device_detach(dev);\n\t}\n\tpriv->can.state = CAN_STATE_SLEEPING;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused flexcan_resume(struct device *device)\n{\n\tstruct net_device *dev = dev_get_drvdata(device);\n\tstruct flexcan_priv *priv = netdev_priv(dev);\n\tint err;\n\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\tif (netif_running(dev)) {\n\t\tnetif_device_attach(dev);\n\t\tnetif_start_queue(dev);\n\t\tif (device_may_wakeup(device)) {\n\t\t\tdisable_irq_wake(dev->irq);\n\t\t\terr = flexcan_exit_stop_mode(priv);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\terr = pinctrl_pm_select_default_state(device);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\terr = flexcan_chip_start(dev);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tflexcan_chip_interrupts_enable(dev);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused flexcan_runtime_suspend(struct device *device)\n{\n\tstruct net_device *dev = dev_get_drvdata(device);\n\tstruct flexcan_priv *priv = netdev_priv(dev);\n\n\tflexcan_clks_disable(priv);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused flexcan_runtime_resume(struct device *device)\n{\n\tstruct net_device *dev = dev_get_drvdata(device);\n\tstruct flexcan_priv *priv = netdev_priv(dev);\n\n\treturn flexcan_clks_enable(priv);\n}\n\nstatic int __maybe_unused flexcan_noirq_suspend(struct device *device)\n{\n\tstruct net_device *dev = dev_get_drvdata(device);\n\tstruct flexcan_priv *priv = netdev_priv(dev);\n\n\tif (netif_running(dev)) {\n\t\tint err;\n\n\t\tif (device_may_wakeup(device))\n\t\t\tflexcan_enable_wakeup_irq(priv, true);\n\n\t\terr = pm_runtime_force_suspend(device);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused flexcan_noirq_resume(struct device *device)\n{\n\tstruct net_device *dev = dev_get_drvdata(device);\n\tstruct flexcan_priv *priv = netdev_priv(dev);\n\n\tif (netif_running(dev)) {\n\t\tint err;\n\n\t\terr = pm_runtime_force_resume(device);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (device_may_wakeup(device))\n\t\t\tflexcan_enable_wakeup_irq(priv, false);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops flexcan_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(flexcan_suspend, flexcan_resume)\n\tSET_RUNTIME_PM_OPS(flexcan_runtime_suspend, flexcan_runtime_resume, NULL)\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(flexcan_noirq_suspend, flexcan_noirq_resume)\n};\n\nstatic struct platform_driver flexcan_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.pm = &flexcan_pm_ops,\n\t\t.of_match_table = flexcan_of_match,\n\t},\n\t.probe = flexcan_probe,\n\t.remove_new = flexcan_remove,\n\t.id_table = flexcan_id_table,\n};\n\nmodule_platform_driver(flexcan_driver);\n\nMODULE_AUTHOR(\"Sascha Hauer <kernel@pengutronix.de>, \"\n\t      \"Marc Kleine-Budde <kernel@pengutronix.de>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"CAN port driver for flexcan based chip\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}