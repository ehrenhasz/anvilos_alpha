{
  "module_name": "mcba_usb.c",
  "hash_id": "7c036af38214ac6ced04f46db61254db7d2af10537fc9485ad89b11132d9b8fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/usb/mcba_usb.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n#include <linux/ethtool.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/signal.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n\n \n#define MCBA_MODULE_NAME \"mcba_usb\"\n#define MCBA_VENDOR_ID 0x04d8\n#define MCBA_PRODUCT_ID 0x0a30\n\n \n#define MCBA_MAX_RX_URBS 20\n#define MCBA_MAX_TX_URBS 20\n#define MCBA_CTX_FREE MCBA_MAX_TX_URBS\n\n \n#define MCBA_USB_RX_BUFF_SIZE 64\n#define MCBA_USB_TX_BUFF_SIZE (sizeof(struct mcba_usb_msg))\n\n \n#define MBCA_CMD_RECEIVE_MESSAGE 0xE3\n#define MBCA_CMD_I_AM_ALIVE_FROM_CAN 0xF5\n#define MBCA_CMD_I_AM_ALIVE_FROM_USB 0xF7\n#define MBCA_CMD_CHANGE_BIT_RATE 0xA1\n#define MBCA_CMD_TRANSMIT_MESSAGE_EV 0xA3\n#define MBCA_CMD_SETUP_TERMINATION_RESISTANCE 0xA8\n#define MBCA_CMD_READ_FW_VERSION 0xA9\n#define MBCA_CMD_NOTHING_TO_SEND 0xFF\n#define MBCA_CMD_TRANSMIT_MESSAGE_RSP 0xE2\n\n#define MCBA_VER_REQ_USB 1\n#define MCBA_VER_REQ_CAN 2\n\n \n#define MCBA_VER_TERMINATION_ON 0\n#define MCBA_VER_TERMINATION_OFF 1\n\n#define MCBA_SIDL_EXID_MASK 0x8\n#define MCBA_DLC_MASK 0xf\n#define MCBA_DLC_RTR_MASK 0x40\n\n#define MCBA_CAN_STATE_WRN_TH 95\n#define MCBA_CAN_STATE_ERR_PSV_TH 127\n\n#define MCBA_TERMINATION_DISABLED CAN_TERMINATION_DISABLED\n#define MCBA_TERMINATION_ENABLED 120\n\nstruct mcba_usb_ctx {\n\tstruct mcba_priv *priv;\n\tu32 ndx;\n\tbool can;\n};\n\n \nstruct mcba_priv {\n\tstruct can_priv can;  \n\tstruct sk_buff *echo_skb[MCBA_MAX_TX_URBS];\n\tstruct mcba_usb_ctx tx_context[MCBA_MAX_TX_URBS];\n\tstruct usb_device *udev;\n\tstruct net_device *netdev;\n\tstruct usb_anchor tx_submitted;\n\tstruct usb_anchor rx_submitted;\n\tstruct can_berr_counter bec;\n\tbool usb_ka_first_pass;\n\tbool can_ka_first_pass;\n\tbool can_speed_check;\n\tatomic_t free_ctx_cnt;\n\tvoid *rxbuf[MCBA_MAX_RX_URBS];\n\tdma_addr_t rxbuf_dma[MCBA_MAX_RX_URBS];\n\tint rx_pipe;\n\tint tx_pipe;\n};\n\n \nstruct __packed mcba_usb_msg_can {\n\tu8 cmd_id;\n\t__be16 eid;\n\t__be16 sid;\n\tu8 dlc;\n\tu8 data[8];\n\tu8 timestamp[4];\n\tu8 checksum;\n};\n\n \nstruct __packed mcba_usb_msg {\n\tu8 cmd_id;\n\tu8 unused[18];\n};\n\nstruct __packed mcba_usb_msg_ka_usb {\n\tu8 cmd_id;\n\tu8 termination_state;\n\tu8 soft_ver_major;\n\tu8 soft_ver_minor;\n\tu8 unused[15];\n};\n\nstruct __packed mcba_usb_msg_ka_can {\n\tu8 cmd_id;\n\tu8 tx_err_cnt;\n\tu8 rx_err_cnt;\n\tu8 rx_buff_ovfl;\n\tu8 tx_bus_off;\n\t__be16 can_bitrate;\n\t__le16 rx_lost;\n\tu8 can_stat;\n\tu8 soft_ver_major;\n\tu8 soft_ver_minor;\n\tu8 debug_mode;\n\tu8 test_complete;\n\tu8 test_result;\n\tu8 unused[4];\n};\n\nstruct __packed mcba_usb_msg_change_bitrate {\n\tu8 cmd_id;\n\t__be16 bitrate;\n\tu8 unused[16];\n};\n\nstruct __packed mcba_usb_msg_termination {\n\tu8 cmd_id;\n\tu8 termination;\n\tu8 unused[17];\n};\n\nstruct __packed mcba_usb_msg_fw_ver {\n\tu8 cmd_id;\n\tu8 pic;\n\tu8 unused[17];\n};\n\nstatic const struct usb_device_id mcba_usb_table[] = {\n\t{ USB_DEVICE(MCBA_VENDOR_ID, MCBA_PRODUCT_ID) },\n\t{}  \n};\n\nMODULE_DEVICE_TABLE(usb, mcba_usb_table);\n\nstatic const u16 mcba_termination[] = { MCBA_TERMINATION_DISABLED,\n\t\t\t\t\tMCBA_TERMINATION_ENABLED };\n\nstatic const u32 mcba_bitrate[] = { 20000,  33333,  50000,  80000,  83333,\n\t\t\t\t    100000, 125000, 150000, 175000, 200000,\n\t\t\t\t    225000, 250000, 275000, 300000, 500000,\n\t\t\t\t    625000, 800000, 1000000 };\n\nstatic inline void mcba_init_ctx(struct mcba_priv *priv)\n{\n\tint i = 0;\n\n\tfor (i = 0; i < MCBA_MAX_TX_URBS; i++) {\n\t\tpriv->tx_context[i].ndx = MCBA_CTX_FREE;\n\t\tpriv->tx_context[i].priv = priv;\n\t}\n\n\tatomic_set(&priv->free_ctx_cnt, ARRAY_SIZE(priv->tx_context));\n}\n\nstatic inline struct mcba_usb_ctx *mcba_usb_get_free_ctx(struct mcba_priv *priv,\n\t\t\t\t\t\t\t struct can_frame *cf)\n{\n\tint i = 0;\n\tstruct mcba_usb_ctx *ctx = NULL;\n\n\tfor (i = 0; i < MCBA_MAX_TX_URBS; i++) {\n\t\tif (priv->tx_context[i].ndx == MCBA_CTX_FREE) {\n\t\t\tctx = &priv->tx_context[i];\n\t\t\tctx->ndx = i;\n\n\t\t\tif (cf)\n\t\t\t\tctx->can = true;\n\t\t\telse\n\t\t\t\tctx->can = false;\n\n\t\t\tatomic_dec(&priv->free_ctx_cnt);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!atomic_read(&priv->free_ctx_cnt))\n\t\t \n\t\tnetif_stop_queue(priv->netdev);\n\n\treturn ctx;\n}\n\n \nstatic inline void mcba_usb_free_ctx(struct mcba_usb_ctx *ctx)\n{\n\t \n\tatomic_inc(&ctx->priv->free_ctx_cnt);\n\n\tctx->ndx = MCBA_CTX_FREE;\n\n\t \n\tnetif_wake_queue(ctx->priv->netdev);\n}\n\nstatic void mcba_usb_write_bulk_callback(struct urb *urb)\n{\n\tstruct mcba_usb_ctx *ctx = urb->context;\n\tstruct net_device *netdev;\n\n\tWARN_ON(!ctx);\n\n\tnetdev = ctx->priv->netdev;\n\n\t \n\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\n\tif (ctx->can) {\n\t\tif (!netif_device_present(netdev))\n\t\t\treturn;\n\n\t\tnetdev->stats.tx_packets++;\n\t\tnetdev->stats.tx_bytes += can_get_echo_skb(netdev, ctx->ndx,\n\t\t\t\t\t\t\t   NULL);\n\t}\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"Tx URB aborted (%d)\\n\", urb->status);\n\n\t \n\tmcba_usb_free_ctx(ctx);\n}\n\n \nstatic netdev_tx_t mcba_usb_xmit(struct mcba_priv *priv,\n\t\t\t\t struct mcba_usb_msg *usb_msg,\n\t\t\t\t struct mcba_usb_ctx *ctx)\n{\n\tstruct urb *urb;\n\tu8 *buf;\n\tint err;\n\n\t \n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tbuf = usb_alloc_coherent(priv->udev, MCBA_USB_TX_BUFF_SIZE, GFP_ATOMIC,\n\t\t\t\t &urb->transfer_dma);\n\tif (!buf) {\n\t\terr = -ENOMEM;\n\t\tgoto nomembuf;\n\t}\n\n\tmemcpy(buf, usb_msg, MCBA_USB_TX_BUFF_SIZE);\n\n\tusb_fill_bulk_urb(urb, priv->udev, priv->tx_pipe, buf, MCBA_USB_TX_BUFF_SIZE,\n\t\t\t  mcba_usb_write_bulk_callback, ctx);\n\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tusb_anchor_urb(urb, &priv->tx_submitted);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(err))\n\t\tgoto failed;\n\n\t \n\tusb_free_urb(urb);\n\n\treturn 0;\n\nfailed:\n\tusb_unanchor_urb(urb);\n\tusb_free_coherent(priv->udev, MCBA_USB_TX_BUFF_SIZE, buf,\n\t\t\t  urb->transfer_dma);\n\n\tif (err == -ENODEV)\n\t\tnetif_device_detach(priv->netdev);\n\telse\n\t\tnetdev_warn(priv->netdev, \"failed tx_urb %d\\n\", err);\n\nnomembuf:\n\tusb_free_urb(urb);\n\n\treturn err;\n}\n\n \nstatic netdev_tx_t mcba_usb_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *netdev)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct mcba_usb_ctx *ctx = NULL;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\tu16 sid;\n\tint err;\n\tstruct mcba_usb_msg_can usb_msg = {\n\t\t.cmd_id = MBCA_CMD_TRANSMIT_MESSAGE_EV\n\t};\n\n\tif (can_dev_dropped_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tctx = mcba_usb_get_free_ctx(priv, cf);\n\tif (!ctx)\n\t\treturn NETDEV_TX_BUSY;\n\n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\t \n\t\tsid = MCBA_SIDL_EXID_MASK;\n\t\t \n\t\tsid |= (cf->can_id & 0x1ffc0000) >> 13;\n\t\t \n\t\tsid |= (cf->can_id & 0x30000) >> 16;\n\t\tput_unaligned_be16(sid, &usb_msg.sid);\n\n\t\t \n\t\tput_unaligned_be16(cf->can_id & 0xffff, &usb_msg.eid);\n\t} else {\n\t\t \n\t\tput_unaligned_be16((cf->can_id & CAN_SFF_MASK) << 5,\n\t\t\t\t   &usb_msg.sid);\n\t\tusb_msg.eid = 0;\n\t}\n\n\tusb_msg.dlc = cf->len;\n\n\tmemcpy(usb_msg.data, cf->data, usb_msg.dlc);\n\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tusb_msg.dlc |= MCBA_DLC_RTR_MASK;\n\n\tcan_put_echo_skb(skb, priv->netdev, ctx->ndx, 0);\n\n\terr = mcba_usb_xmit(priv, (struct mcba_usb_msg *)&usb_msg, ctx);\n\tif (err)\n\t\tgoto xmit_failed;\n\n\treturn NETDEV_TX_OK;\n\nxmit_failed:\n\tcan_free_echo_skb(priv->netdev, ctx->ndx, NULL);\n\tmcba_usb_free_ctx(ctx);\n\tstats->tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic void mcba_usb_xmit_cmd(struct mcba_priv *priv,\n\t\t\t      struct mcba_usb_msg *usb_msg)\n{\n\tstruct mcba_usb_ctx *ctx = NULL;\n\tint err;\n\n\tctx = mcba_usb_get_free_ctx(priv, NULL);\n\tif (!ctx) {\n\t\tnetdev_err(priv->netdev,\n\t\t\t   \"Lack of free ctx. Sending (%d) cmd aborted\",\n\t\t\t   usb_msg->cmd_id);\n\n\t\treturn;\n\t}\n\n\terr = mcba_usb_xmit(priv, usb_msg, ctx);\n\tif (err)\n\t\tnetdev_err(priv->netdev, \"Failed to send cmd (%d)\",\n\t\t\t   usb_msg->cmd_id);\n}\n\nstatic void mcba_usb_xmit_change_bitrate(struct mcba_priv *priv, u16 bitrate)\n{\n\tstruct mcba_usb_msg_change_bitrate usb_msg = {\n\t\t.cmd_id = MBCA_CMD_CHANGE_BIT_RATE\n\t};\n\n\tput_unaligned_be16(bitrate, &usb_msg.bitrate);\n\n\tmcba_usb_xmit_cmd(priv, (struct mcba_usb_msg *)&usb_msg);\n}\n\nstatic void mcba_usb_xmit_read_fw_ver(struct mcba_priv *priv, u8 pic)\n{\n\tstruct mcba_usb_msg_fw_ver usb_msg = {\n\t\t.cmd_id = MBCA_CMD_READ_FW_VERSION,\n\t\t.pic = pic\n\t};\n\n\tmcba_usb_xmit_cmd(priv, (struct mcba_usb_msg *)&usb_msg);\n}\n\nstatic void mcba_usb_process_can(struct mcba_priv *priv,\n\t\t\t\t struct mcba_usb_msg_can *msg)\n{\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\tu16 sid;\n\n\tskb = alloc_can_skb(priv->netdev, &cf);\n\tif (!skb)\n\t\treturn;\n\n\tsid = get_unaligned_be16(&msg->sid);\n\n\tif (sid & MCBA_SIDL_EXID_MASK) {\n\t\t \n\t\tcf->can_id = CAN_EFF_FLAG;\n\n\t\t \n\t\tcf->can_id |= (sid & 0xffe0) << 13;\n\t\t \n\t\tcf->can_id |= (sid & 3) << 16;\n\t\t \n\t\tcf->can_id |= get_unaligned_be16(&msg->eid);\n\t} else {\n\t\t \n\t\tcf->can_id = (sid & 0xffe0) >> 5;\n\t}\n\n\tcf->len = can_cc_dlc2len(msg->dlc & MCBA_DLC_MASK);\n\n\tif (msg->dlc & MCBA_DLC_RTR_MASK) {\n\t\tcf->can_id |= CAN_RTR_FLAG;\n\t} else {\n\t\tmemcpy(cf->data, msg->data, cf->len);\n\n\t\tstats->rx_bytes += cf->len;\n\t}\n\tstats->rx_packets++;\n\n\tnetif_rx(skb);\n}\n\nstatic void mcba_usb_process_ka_usb(struct mcba_priv *priv,\n\t\t\t\t    struct mcba_usb_msg_ka_usb *msg)\n{\n\tif (unlikely(priv->usb_ka_first_pass)) {\n\t\tnetdev_info(priv->netdev, \"PIC USB version %u.%u\\n\",\n\t\t\t    msg->soft_ver_major, msg->soft_ver_minor);\n\n\t\tpriv->usb_ka_first_pass = false;\n\t}\n\n\tif (msg->termination_state == MCBA_VER_TERMINATION_ON)\n\t\tpriv->can.termination = MCBA_TERMINATION_ENABLED;\n\telse\n\t\tpriv->can.termination = MCBA_TERMINATION_DISABLED;\n}\n\nstatic u32 convert_can2host_bitrate(struct mcba_usb_msg_ka_can *msg)\n{\n\tconst u32 bitrate = get_unaligned_be16(&msg->can_bitrate);\n\n\tif ((bitrate == 33) || (bitrate == 83))\n\t\treturn bitrate * 1000 + 333;\n\telse\n\t\treturn bitrate * 1000;\n}\n\nstatic void mcba_usb_process_ka_can(struct mcba_priv *priv,\n\t\t\t\t    struct mcba_usb_msg_ka_can *msg)\n{\n\tif (unlikely(priv->can_ka_first_pass)) {\n\t\tnetdev_info(priv->netdev, \"PIC CAN version %u.%u\\n\",\n\t\t\t    msg->soft_ver_major, msg->soft_ver_minor);\n\n\t\tpriv->can_ka_first_pass = false;\n\t}\n\n\tif (unlikely(priv->can_speed_check)) {\n\t\tconst u32 bitrate = convert_can2host_bitrate(msg);\n\n\t\tpriv->can_speed_check = false;\n\n\t\tif (bitrate != priv->can.bittiming.bitrate)\n\t\t\tnetdev_err(\n\t\t\t    priv->netdev,\n\t\t\t    \"Wrong bitrate reported by the device (%u). Expected %u\",\n\t\t\t    bitrate, priv->can.bittiming.bitrate);\n\t}\n\n\tpriv->bec.txerr = msg->tx_err_cnt;\n\tpriv->bec.rxerr = msg->rx_err_cnt;\n\n\tif (msg->tx_bus_off)\n\t\tpriv->can.state = CAN_STATE_BUS_OFF;\n\n\telse if ((priv->bec.txerr > MCBA_CAN_STATE_ERR_PSV_TH) ||\n\t\t (priv->bec.rxerr > MCBA_CAN_STATE_ERR_PSV_TH))\n\t\tpriv->can.state = CAN_STATE_ERROR_PASSIVE;\n\n\telse if ((priv->bec.txerr > MCBA_CAN_STATE_WRN_TH) ||\n\t\t (priv->bec.rxerr > MCBA_CAN_STATE_WRN_TH))\n\t\tpriv->can.state = CAN_STATE_ERROR_WARNING;\n}\n\nstatic void mcba_usb_process_rx(struct mcba_priv *priv,\n\t\t\t\tstruct mcba_usb_msg *msg)\n{\n\tswitch (msg->cmd_id) {\n\tcase MBCA_CMD_I_AM_ALIVE_FROM_CAN:\n\t\tmcba_usb_process_ka_can(priv,\n\t\t\t\t\t(struct mcba_usb_msg_ka_can *)msg);\n\t\tbreak;\n\n\tcase MBCA_CMD_I_AM_ALIVE_FROM_USB:\n\t\tmcba_usb_process_ka_usb(priv,\n\t\t\t\t\t(struct mcba_usb_msg_ka_usb *)msg);\n\t\tbreak;\n\n\tcase MBCA_CMD_RECEIVE_MESSAGE:\n\t\tmcba_usb_process_can(priv, (struct mcba_usb_msg_can *)msg);\n\t\tbreak;\n\n\tcase MBCA_CMD_NOTHING_TO_SEND:\n\t\t \n\t\tbreak;\n\n\tcase MBCA_CMD_TRANSMIT_MESSAGE_RSP:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tnetdev_warn(priv->netdev, \"Unsupported msg (0x%X)\",\n\t\t\t    msg->cmd_id);\n\t\tbreak;\n\t}\n}\n\n \nstatic void mcba_usb_read_bulk_callback(struct urb *urb)\n{\n\tstruct mcba_priv *priv = urb->context;\n\tstruct net_device *netdev;\n\tint retval;\n\tint pos = 0;\n\n\tnetdev = priv->netdev;\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tswitch (urb->status) {\n\tcase 0:  \n\t\tbreak;\n\n\tcase -ENOENT:\n\tcase -EPIPE:\n\tcase -EPROTO:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\n\tdefault:\n\t\tnetdev_info(netdev, \"Rx URB aborted (%d)\\n\", urb->status);\n\n\t\tgoto resubmit_urb;\n\t}\n\n\twhile (pos < urb->actual_length) {\n\t\tstruct mcba_usb_msg *msg;\n\n\t\tif (pos + sizeof(struct mcba_usb_msg) > urb->actual_length) {\n\t\t\tnetdev_err(priv->netdev, \"format error\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tmsg = (struct mcba_usb_msg *)(urb->transfer_buffer + pos);\n\t\tmcba_usb_process_rx(priv, msg);\n\n\t\tpos += sizeof(struct mcba_usb_msg);\n\t}\n\nresubmit_urb:\n\n\tusb_fill_bulk_urb(urb, priv->udev,\n\t\t\t  priv->rx_pipe,\n\t\t\t  urb->transfer_buffer, MCBA_USB_RX_BUFF_SIZE,\n\t\t\t  mcba_usb_read_bulk_callback, priv);\n\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\n\tif (retval == -ENODEV)\n\t\tnetif_device_detach(netdev);\n\telse if (retval)\n\t\tnetdev_err(netdev, \"failed resubmitting read bulk urb: %d\\n\",\n\t\t\t   retval);\n}\n\n \nstatic int mcba_usb_start(struct mcba_priv *priv)\n{\n\tstruct net_device *netdev = priv->netdev;\n\tint err, i;\n\n\tmcba_init_ctx(priv);\n\n\tfor (i = 0; i < MCBA_MAX_RX_URBS; i++) {\n\t\tstruct urb *urb = NULL;\n\t\tu8 *buf;\n\t\tdma_addr_t buf_dma;\n\n\t\t \n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf = usb_alloc_coherent(priv->udev, MCBA_USB_RX_BUFF_SIZE,\n\t\t\t\t\t GFP_KERNEL, &buf_dma);\n\t\tif (!buf) {\n\t\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\t\tusb_free_urb(urb);\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\turb->transfer_dma = buf_dma;\n\n\t\tusb_fill_bulk_urb(urb, priv->udev,\n\t\t\t\t  priv->rx_pipe,\n\t\t\t\t  buf, MCBA_USB_RX_BUFF_SIZE,\n\t\t\t\t  mcba_usb_read_bulk_callback, priv);\n\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\tusb_anchor_urb(urb, &priv->rx_submitted);\n\n\t\terr = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (err) {\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tusb_free_coherent(priv->udev, MCBA_USB_RX_BUFF_SIZE,\n\t\t\t\t\t  buf, buf_dma);\n\t\t\tusb_free_urb(urb);\n\t\t\tbreak;\n\t\t}\n\n\t\tpriv->rxbuf[i] = buf;\n\t\tpriv->rxbuf_dma[i] = buf_dma;\n\n\t\t \n\t\tusb_free_urb(urb);\n\t}\n\n\t \n\tif (i == 0) {\n\t\tnetdev_warn(netdev, \"couldn't setup read URBs\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tif (i < MCBA_MAX_RX_URBS)\n\t\tnetdev_warn(netdev, \"rx performance may be slow\\n\");\n\n\tmcba_usb_xmit_read_fw_ver(priv, MCBA_VER_REQ_USB);\n\tmcba_usb_xmit_read_fw_ver(priv, MCBA_VER_REQ_CAN);\n\n\treturn err;\n}\n\n \nstatic int mcba_usb_open(struct net_device *netdev)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\tint err;\n\n\t \n\terr = open_candev(netdev);\n\tif (err)\n\t\treturn err;\n\n\tpriv->can_speed_check = true;\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\tnetif_start_queue(netdev);\n\n\treturn 0;\n}\n\nstatic void mcba_urb_unlink(struct mcba_priv *priv)\n{\n\tint i;\n\n\tusb_kill_anchored_urbs(&priv->rx_submitted);\n\n\tfor (i = 0; i < MCBA_MAX_RX_URBS; ++i)\n\t\tusb_free_coherent(priv->udev, MCBA_USB_RX_BUFF_SIZE,\n\t\t\t\t  priv->rxbuf[i], priv->rxbuf_dma[i]);\n\n\tusb_kill_anchored_urbs(&priv->tx_submitted);\n}\n\n \nstatic int mcba_usb_close(struct net_device *netdev)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\n\tpriv->can.state = CAN_STATE_STOPPED;\n\n\tnetif_stop_queue(netdev);\n\n\t \n\tmcba_urb_unlink(priv);\n\n\tclose_candev(netdev);\n\n\treturn 0;\n}\n\n \nstatic int mcba_net_set_mode(struct net_device *netdev, enum can_mode mode)\n{\n\treturn 0;\n}\n\nstatic int mcba_net_get_berr_counter(const struct net_device *netdev,\n\t\t\t\t     struct can_berr_counter *bec)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\n\tbec->txerr = priv->bec.txerr;\n\tbec->rxerr = priv->bec.rxerr;\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops mcba_netdev_ops = {\n\t.ndo_open = mcba_usb_open,\n\t.ndo_stop = mcba_usb_close,\n\t.ndo_start_xmit = mcba_usb_start_xmit,\n};\n\nstatic const struct ethtool_ops mcba_ethtool_ops = {\n\t.get_ts_info = ethtool_op_get_ts_info,\n};\n\n \nstatic int mcba_net_set_bittiming(struct net_device *netdev)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\tconst u16 bitrate_kbps = priv->can.bittiming.bitrate / 1000;\n\n\tmcba_usb_xmit_change_bitrate(priv, bitrate_kbps);\n\n\treturn 0;\n}\n\nstatic int mcba_set_termination(struct net_device *netdev, u16 term)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\tstruct mcba_usb_msg_termination usb_msg = {\n\t\t.cmd_id = MBCA_CMD_SETUP_TERMINATION_RESISTANCE\n\t};\n\n\tif (term == MCBA_TERMINATION_ENABLED)\n\t\tusb_msg.termination = MCBA_VER_TERMINATION_ON;\n\telse\n\t\tusb_msg.termination = MCBA_VER_TERMINATION_OFF;\n\n\tmcba_usb_xmit_cmd(priv, (struct mcba_usb_msg *)&usb_msg);\n\n\treturn 0;\n}\n\nstatic int mcba_usb_probe(struct usb_interface *intf,\n\t\t\t  const struct usb_device_id *id)\n{\n\tstruct net_device *netdev;\n\tstruct mcba_priv *priv;\n\tint err;\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct usb_endpoint_descriptor *in, *out;\n\n\terr = usb_find_common_endpoints(intf->cur_altsetting, &in, &out, NULL, NULL);\n\tif (err) {\n\t\tdev_err(&intf->dev, \"Can't find endpoints\\n\");\n\t\treturn err;\n\t}\n\n\tnetdev = alloc_candev(sizeof(struct mcba_priv), MCBA_MAX_TX_URBS);\n\tif (!netdev) {\n\t\tdev_err(&intf->dev, \"Couldn't alloc candev\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv = netdev_priv(netdev);\n\n\tpriv->udev = usbdev;\n\tpriv->netdev = netdev;\n\tpriv->usb_ka_first_pass = true;\n\tpriv->can_ka_first_pass = true;\n\tpriv->can_speed_check = false;\n\n\tinit_usb_anchor(&priv->rx_submitted);\n\tinit_usb_anchor(&priv->tx_submitted);\n\n\tusb_set_intfdata(intf, priv);\n\n\t \n\tpriv->can.state = CAN_STATE_STOPPED;\n\tpriv->can.termination_const = mcba_termination;\n\tpriv->can.termination_const_cnt = ARRAY_SIZE(mcba_termination);\n\tpriv->can.bitrate_const = mcba_bitrate;\n\tpriv->can.bitrate_const_cnt = ARRAY_SIZE(mcba_bitrate);\n\n\tpriv->can.do_set_termination = mcba_set_termination;\n\tpriv->can.do_set_mode = mcba_net_set_mode;\n\tpriv->can.do_get_berr_counter = mcba_net_get_berr_counter;\n\tpriv->can.do_set_bittiming = mcba_net_set_bittiming;\n\n\tnetdev->netdev_ops = &mcba_netdev_ops;\n\tnetdev->ethtool_ops = &mcba_ethtool_ops;\n\n\tnetdev->flags |= IFF_ECHO;  \n\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\n\terr = register_candev(netdev);\n\tif (err) {\n\t\tnetdev_err(netdev, \"couldn't register CAN device: %d\\n\", err);\n\n\t\tgoto cleanup_free_candev;\n\t}\n\n\tpriv->rx_pipe = usb_rcvbulkpipe(priv->udev, in->bEndpointAddress);\n\tpriv->tx_pipe = usb_sndbulkpipe(priv->udev, out->bEndpointAddress);\n\n\t \n\terr = mcba_usb_start(priv);\n\tif (err) {\n\t\tif (err == -ENODEV)\n\t\t\tnetif_device_detach(priv->netdev);\n\n\t\tnetdev_warn(netdev, \"couldn't start device: %d\\n\", err);\n\n\t\tgoto cleanup_unregister_candev;\n\t}\n\n\tdev_info(&intf->dev, \"Microchip CAN BUS Analyzer connected\\n\");\n\n\treturn 0;\n\ncleanup_unregister_candev:\n\tunregister_candev(priv->netdev);\n\ncleanup_free_candev:\n\tfree_candev(netdev);\n\n\treturn err;\n}\n\n \nstatic void mcba_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct mcba_priv *priv = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\n\tnetdev_info(priv->netdev, \"device disconnected\\n\");\n\n\tunregister_candev(priv->netdev);\n\tmcba_urb_unlink(priv);\n\tfree_candev(priv->netdev);\n}\n\nstatic struct usb_driver mcba_usb_driver = {\n\t.name = MCBA_MODULE_NAME,\n\t.probe = mcba_usb_probe,\n\t.disconnect = mcba_usb_disconnect,\n\t.id_table = mcba_usb_table,\n};\n\nmodule_usb_driver(mcba_usb_driver);\n\nMODULE_AUTHOR(\"Remigiusz Ko\u0142\u0142\u0105taj <remigiusz.kollataj@mobica.com>\");\nMODULE_DESCRIPTION(\"SocketCAN driver for Microchip CAN BUS Analyzer Tool\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}