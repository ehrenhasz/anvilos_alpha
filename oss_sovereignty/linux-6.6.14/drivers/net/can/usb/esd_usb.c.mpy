{
  "module_name": "esd_usb.c",
  "hash_id": "c0781b1151e5e24205a480a3e433d0a2326f2decb22d8dbbcd67e0aef9ade38b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/usb/esd_usb.c",
  "human_readable_source": "\n \n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n#include <linux/ethtool.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/signal.h>\n#include <linux/slab.h>\n#include <linux/units.h>\n#include <linux/usb.h>\n\nMODULE_AUTHOR(\"Matthias Fuchs <socketcan@esd.eu>\");\nMODULE_AUTHOR(\"Frank Jungclaus <frank.jungclaus@esd.eu>\");\nMODULE_DESCRIPTION(\"CAN driver for esd electronics gmbh CAN-USB/2, CAN-USB/3 and CAN-USB/Micro interfaces\");\nMODULE_LICENSE(\"GPL v2\");\n\n \n#define ESD_USB_ESDGMBH_VENDOR_ID\t0x0ab4\n#define ESD_USB_CANUSB2_PRODUCT_ID\t0x0010\n#define ESD_USB_CANUSBM_PRODUCT_ID\t0x0011\n#define ESD_USB_CANUSB3_PRODUCT_ID\t0x0014\n\n \n#define ESD_USB_2_CAN_CLOCK\t(60 * MEGA)  \n#define ESD_USB_M_CAN_CLOCK\t(36 * MEGA)  \n#define ESD_USB_3_CAN_CLOCK\t(80 * MEGA)  \n\n \n#define ESD_USB_MAX_NETS\t2\n\n \n#define ESD_USB_CMD_VERSION\t\t1  \n#define ESD_USB_CMD_CAN_RX\t\t2  \n#define ESD_USB_CMD_CAN_TX\t\t3  \n#define ESD_USB_CMD_SETBAUD\t\t4  \n#define ESD_USB_CMD_TS\t\t\t5  \n#define ESD_USB_CMD_IDADD\t\t6  \n\n \n#define ESD_USB_RTR\tBIT(4)\n#define ESD_USB_NO_BRS\tBIT(4)\n#define ESD_USB_ESI\tBIT(5)\n#define ESD_USB_FD\tBIT(7)\n\n \n#define ESD_USB_EXTID\tBIT(29)\n#define ESD_USB_EVENT\tBIT(30)\n#define ESD_USB_IDMASK\tGENMASK(28, 0)\n\n \n#define ESD_USB_EV_CAN_ERROR_EXT\t2  \n\n \n#define ESD_USB_LOM\tBIT(30)  \n#define ESD_USB_UBR\tBIT(31)  \n#define ESD_USB_NO_BAUDRATE\tGENMASK(30, 0)  \n\n \n#define ESD_USB_2_TSEG1_SHIFT\t16\n#define ESD_USB_2_TSEG2_SHIFT\t20\n#define ESD_USB_2_SJW_SHIFT\t14\n#define ESD_USB_M_SJW_SHIFT\t24\n#define ESD_USB_TRIPLE_SAMPLES\tBIT(23)\n\n \n#define ESD_USB_3_TDC_MODE_AUTO\t0\n\n \n#define ESD_USB_ID_ENABLE\tBIT(7)\n#define ESD_USB_MAX_ID_SEGMENT\t64\n\n \n#define ESD_USB_SJA1000_ECC_SEG\t\tGENMASK(4, 0)\n#define ESD_USB_SJA1000_ECC_DIR\t\tBIT(5)\n#define ESD_USB_SJA1000_ECC_ERR\t\tBIT(2, 1)\n#define ESD_USB_SJA1000_ECC_BIT\t\t0x00\n#define ESD_USB_SJA1000_ECC_FORM\tBIT(6)\n#define ESD_USB_SJA1000_ECC_STUFF\tBIT(7)\n#define ESD_USB_SJA1000_ECC_MASK\tGENMASK(7, 6)\n\n \n#define ESD_USB_BUSSTATE_MASK\tGENMASK(7, 6)\n#define ESD_USB_BUSSTATE_WARN\tBIT(6)\n#define ESD_USB_BUSSTATE_ERRPASSIVE\tBIT(7)\n#define ESD_USB_BUSSTATE_BUSOFF\tGENMASK(7, 6)\n\n#define ESD_USB_RX_BUFFER_SIZE\t\t1024\n#define ESD_USB_MAX_RX_URBS\t\t4\n#define ESD_USB_MAX_TX_URBS\t\t16  \n\n \n#define ESD_USB_3_BAUDRATE_MODE_DISABLE\t\t0  \n#define ESD_USB_3_BAUDRATE_MODE_INDEX\t\t1  \n#define ESD_USB_3_BAUDRATE_MODE_BTR_CTRL\t2  \n#define ESD_USB_3_BAUDRATE_MODE_BTR_CANONICAL\t3  \n#define ESD_USB_3_BAUDRATE_MODE_NUM\t\t4  \n#define ESD_USB_3_BAUDRATE_MODE_AUTOBAUD\t5  \n\n \n#define ESD_USB_3_BAUDRATE_FLAG_FD\tBIT(0)  \n#define ESD_USB_3_BAUDRATE_FLAG_LOM\tBIT(1)  \n#define ESD_USB_3_BAUDRATE_FLAG_STM\tBIT(2)  \n#define ESD_USB_3_BAUDRATE_FLAG_TRS\tBIT(3)  \n#define ESD_USB_3_BAUDRATE_FLAG_TXP\tBIT(4)  \n\nstruct esd_usb_header_msg {\n\tu8 len;  \n\tu8 cmd;\n\tu8 rsvd[2];\n};\n\nstruct esd_usb_version_msg {\n\tu8 len;  \n\tu8 cmd;\n\tu8 rsvd;\n\tu8 flags;\n\t__le32 drv_version;\n};\n\nstruct esd_usb_version_reply_msg {\n\tu8 len;  \n\tu8 cmd;\n\tu8 nets;\n\tu8 features;\n\t__le32 version;\n\tu8 name[16];\n\t__le32 rsvd;\n\t__le32 ts;\n};\n\nstruct esd_usb_rx_msg {\n\tu8 len;  \n\tu8 cmd;\n\tu8 net;\n\tu8 dlc;\n\t__le32 ts;\n\t__le32 id;  \n\tunion {\n\t\tu8 data[CAN_MAX_DLEN];\n\t\tu8 data_fd[CANFD_MAX_DLEN];\n\t\tstruct {\n\t\t\tu8 status;  \n\t\t\tu8 ecc;     \n\t\t\tu8 rec;     \n\t\t\tu8 tec;     \n\t\t} ev_can_err_ext;   \n\t};\n};\n\nstruct esd_usb_tx_msg {\n\tu8 len;  \n\tu8 cmd;\n\tu8 net;\n\tu8 dlc;\n\tu32 hnd;\t \n\t__le32 id;  \n\tunion {\n\t\tu8 data[CAN_MAX_DLEN];\n\t\tu8 data_fd[CANFD_MAX_DLEN];\n\t};\n};\n\nstruct esd_usb_tx_done_msg {\n\tu8 len;  \n\tu8 cmd;\n\tu8 net;\n\tu8 status;\n\tu32 hnd;\t \n\t__le32 ts;\n};\n\nstruct esd_usb_id_filter_msg {\n\tu8 len;  \n\tu8 cmd;\n\tu8 net;\n\tu8 option;\n\t__le32 mask[ESD_USB_MAX_ID_SEGMENT + 1];  \n};\n\nstruct esd_usb_set_baudrate_msg {\n\tu8 len;  \n\tu8 cmd;\n\tu8 net;\n\tu8 rsvd;\n\t__le32 baud;\n};\n\n \nstruct esd_usb_3_baudrate_cfg {\n\t__le16 brp;\t \n\t__le16 tseg1;\t \n\t__le16 tseg2;\t \n\t__le16 sjw;\t \n};\n\n \nstruct esd_usb_3_tdc_cfg {\n\tu8 tdc_mode;\t \n\tu8 ssp_offset;\t \n\ts8 ssp_shift;\t \n\tu8 tdc_filter;\t \n};\n\n \nstruct esd_usb_3_set_baudrate_msg_x {\n\tu8 len;\t \n\tu8 cmd;\n\tu8 net;\n\tu8 rsvd;\t \n\t \n\t__le16 mode;\t \n\t__le16 flags;\t \n\tstruct esd_usb_3_tdc_cfg tdc;\t \n\tstruct esd_usb_3_baudrate_cfg nom;\t \n\tstruct esd_usb_3_baudrate_cfg data;\t \n};\n\n \nunion __packed esd_usb_msg {\n\tstruct esd_usb_header_msg hdr;\n\tstruct esd_usb_version_msg version;\n\tstruct esd_usb_version_reply_msg version_reply;\n\tstruct esd_usb_rx_msg rx;\n\tstruct esd_usb_tx_msg tx;\n\tstruct esd_usb_tx_done_msg txdone;\n\tstruct esd_usb_set_baudrate_msg setbaud;\n\tstruct esd_usb_3_set_baudrate_msg_x setbaud_x;\n\tstruct esd_usb_id_filter_msg filter;\n};\n\nstatic struct usb_device_id esd_usb_table[] = {\n\t{USB_DEVICE(ESD_USB_ESDGMBH_VENDOR_ID, ESD_USB_CANUSB2_PRODUCT_ID)},\n\t{USB_DEVICE(ESD_USB_ESDGMBH_VENDOR_ID, ESD_USB_CANUSBM_PRODUCT_ID)},\n\t{USB_DEVICE(ESD_USB_ESDGMBH_VENDOR_ID, ESD_USB_CANUSB3_PRODUCT_ID)},\n\t{}\n};\nMODULE_DEVICE_TABLE(usb, esd_usb_table);\n\nstruct esd_usb_net_priv;\n\nstruct esd_tx_urb_context {\n\tstruct esd_usb_net_priv *priv;\n\tu32 echo_index;\n};\n\nstruct esd_usb {\n\tstruct usb_device *udev;\n\tstruct esd_usb_net_priv *nets[ESD_USB_MAX_NETS];\n\n\tstruct usb_anchor rx_submitted;\n\n\tint net_count;\n\tu32 version;\n\tint rxinitdone;\n\tvoid *rxbuf[ESD_USB_MAX_RX_URBS];\n\tdma_addr_t rxbuf_dma[ESD_USB_MAX_RX_URBS];\n};\n\nstruct esd_usb_net_priv {\n\tstruct can_priv can;  \n\n\tatomic_t active_tx_jobs;\n\tstruct usb_anchor tx_submitted;\n\tstruct esd_tx_urb_context tx_contexts[ESD_USB_MAX_TX_URBS];\n\n\tstruct esd_usb *usb;\n\tstruct net_device *netdev;\n\tint index;\n\tu8 old_state;\n\tstruct can_berr_counter bec;\n};\n\nstatic void esd_usb_rx_event(struct esd_usb_net_priv *priv,\n\t\t\t     union esd_usb_msg *msg)\n{\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tu32 id = le32_to_cpu(msg->rx.id) & ESD_USB_IDMASK;\n\n\tif (id == ESD_USB_EV_CAN_ERROR_EXT) {\n\t\tu8 state = msg->rx.ev_can_err_ext.status;\n\t\tu8 ecc = msg->rx.ev_can_err_ext.ecc;\n\n\t\tpriv->bec.rxerr = msg->rx.ev_can_err_ext.rec;\n\t\tpriv->bec.txerr = msg->rx.ev_can_err_ext.tec;\n\n\t\tnetdev_dbg(priv->netdev,\n\t\t\t   \"CAN_ERR_EV_EXT: dlc=%#02x state=%02x ecc=%02x rec=%02x tec=%02x\\n\",\n\t\t\t   msg->rx.dlc, state, ecc,\n\t\t\t   priv->bec.rxerr, priv->bec.txerr);\n\n\t\t \n\t\tif (!(priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING) &&\n\t\t    state == priv->old_state)\n\t\t\treturn;\n\n\t\tskb = alloc_can_err_skb(priv->netdev, &cf);\n\t\tif (!skb)\n\t\t\tstats->rx_dropped++;\n\n\t\tif (state != priv->old_state) {\n\t\t\tenum can_state tx_state, rx_state;\n\t\t\tenum can_state new_state = CAN_STATE_ERROR_ACTIVE;\n\n\t\t\tpriv->old_state = state;\n\n\t\t\tswitch (state & ESD_USB_BUSSTATE_MASK) {\n\t\t\tcase ESD_USB_BUSSTATE_BUSOFF:\n\t\t\t\tnew_state = CAN_STATE_BUS_OFF;\n\t\t\t\tcan_bus_off(priv->netdev);\n\t\t\t\tbreak;\n\t\t\tcase ESD_USB_BUSSTATE_WARN:\n\t\t\t\tnew_state = CAN_STATE_ERROR_WARNING;\n\t\t\t\tbreak;\n\t\t\tcase ESD_USB_BUSSTATE_ERRPASSIVE:\n\t\t\t\tnew_state = CAN_STATE_ERROR_PASSIVE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnew_state = CAN_STATE_ERROR_ACTIVE;\n\t\t\t\tpriv->bec.txerr = 0;\n\t\t\t\tpriv->bec.rxerr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (new_state != priv->can.state) {\n\t\t\t\ttx_state = (priv->bec.txerr >= priv->bec.rxerr) ? new_state : 0;\n\t\t\t\trx_state = (priv->bec.txerr <= priv->bec.rxerr) ? new_state : 0;\n\t\t\t\tcan_change_state(priv->netdev, cf,\n\t\t\t\t\t\t tx_state, rx_state);\n\t\t\t}\n\t\t} else if (skb) {\n\t\t\tpriv->can.can_stats.bus_error++;\n\t\t\tstats->rx_errors++;\n\n\t\t\tcf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\n\n\t\t\tswitch (ecc & ESD_USB_SJA1000_ECC_MASK) {\n\t\t\tcase ESD_USB_SJA1000_ECC_BIT:\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT;\n\t\t\t\tbreak;\n\t\t\tcase ESD_USB_SJA1000_ECC_FORM:\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_FORM;\n\t\t\t\tbreak;\n\t\t\tcase ESD_USB_SJA1000_ECC_STUFF:\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_STUFF;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!(ecc & ESD_USB_SJA1000_ECC_DIR))\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_TX;\n\n\t\t\t \n\t\t\tcf->data[3] = ecc & ESD_USB_SJA1000_ECC_SEG;\n\t\t}\n\n\t\tif (skb) {\n\t\t\tcf->can_id |= CAN_ERR_CNT;\n\t\t\tcf->data[6] = priv->bec.txerr;\n\t\t\tcf->data[7] = priv->bec.rxerr;\n\n\t\t\tnetif_rx(skb);\n\t\t}\n\t}\n}\n\nstatic void esd_usb_rx_can_msg(struct esd_usb_net_priv *priv,\n\t\t\t       union esd_usb_msg *msg)\n{\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\tstruct can_frame *cf;\n\tstruct canfd_frame *cfd;\n\tstruct sk_buff *skb;\n\tu32 id;\n\tu8 len;\n\n\tif (!netif_device_present(priv->netdev))\n\t\treturn;\n\n\tid = le32_to_cpu(msg->rx.id);\n\n\tif (id & ESD_USB_EVENT) {\n\t\tesd_usb_rx_event(priv, msg);\n\t} else {\n\t\tif (msg->rx.dlc & ESD_USB_FD) {\n\t\t\tskb = alloc_canfd_skb(priv->netdev, &cfd);\n\t\t} else {\n\t\t\tskb = alloc_can_skb(priv->netdev, &cf);\n\t\t\tcfd = (struct canfd_frame *)cf;\n\t\t}\n\n\t\tif (skb == NULL) {\n\t\t\tstats->rx_dropped++;\n\t\t\treturn;\n\t\t}\n\n\t\tcfd->can_id = id & ESD_USB_IDMASK;\n\n\t\tif (msg->rx.dlc & ESD_USB_FD) {\n\t\t\t \n\t\t\tcfd->len = can_fd_dlc2len(msg->rx.dlc);\n\t\t\tlen = cfd->len;\n\t\t\tif ((msg->rx.dlc & ESD_USB_NO_BRS) == 0)\n\t\t\t\tcfd->flags |= CANFD_BRS;\n\t\t\tif (msg->rx.dlc & ESD_USB_ESI)\n\t\t\t\tcfd->flags |= CANFD_ESI;\n\t\t} else {\n\t\t\tcan_frame_set_cc_len(cf, msg->rx.dlc & ~ESD_USB_RTR, priv->can.ctrlmode);\n\t\t\tlen = cf->len;\n\t\t\tif (msg->rx.dlc & ESD_USB_RTR) {\n\t\t\t\tcf->can_id |= CAN_RTR_FLAG;\n\t\t\t\tlen = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (id & ESD_USB_EXTID)\n\t\t\tcfd->can_id |= CAN_EFF_FLAG;\n\n\t\tmemcpy(cfd->data, msg->rx.data_fd, len);\n\t\tstats->rx_bytes += len;\n\t\tstats->rx_packets++;\n\n\t\tnetif_rx(skb);\n\t}\n}\n\nstatic void esd_usb_tx_done_msg(struct esd_usb_net_priv *priv,\n\t\t\t\tunion esd_usb_msg *msg)\n{\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\tstruct net_device *netdev = priv->netdev;\n\tstruct esd_tx_urb_context *context;\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tcontext = &priv->tx_contexts[msg->txdone.hnd & (ESD_USB_MAX_TX_URBS - 1)];\n\n\tif (!msg->txdone.status) {\n\t\tstats->tx_packets++;\n\t\tstats->tx_bytes += can_get_echo_skb(netdev, context->echo_index,\n\t\t\t\t\t\t    NULL);\n\t} else {\n\t\tstats->tx_errors++;\n\t\tcan_free_echo_skb(netdev, context->echo_index, NULL);\n\t}\n\n\t \n\tcontext->echo_index = ESD_USB_MAX_TX_URBS;\n\tatomic_dec(&priv->active_tx_jobs);\n\n\tnetif_wake_queue(netdev);\n}\n\nstatic void esd_usb_read_bulk_callback(struct urb *urb)\n{\n\tstruct esd_usb *dev = urb->context;\n\tint retval;\n\tint pos = 0;\n\tint i;\n\n\tswitch (urb->status) {\n\tcase 0:  \n\t\tbreak;\n\n\tcase -ENOENT:\n\tcase -EPIPE:\n\tcase -EPROTO:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\n\tdefault:\n\t\tdev_info(dev->udev->dev.parent,\n\t\t\t \"Rx URB aborted (%d)\\n\", urb->status);\n\t\tgoto resubmit_urb;\n\t}\n\n\twhile (pos < urb->actual_length) {\n\t\tunion esd_usb_msg *msg;\n\n\t\tmsg = (union esd_usb_msg *)(urb->transfer_buffer + pos);\n\n\t\tswitch (msg->hdr.cmd) {\n\t\tcase ESD_USB_CMD_CAN_RX:\n\t\t\tif (msg->rx.net >= dev->net_count) {\n\t\t\t\tdev_err(dev->udev->dev.parent, \"format error\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tesd_usb_rx_can_msg(dev->nets[msg->rx.net], msg);\n\t\t\tbreak;\n\n\t\tcase ESD_USB_CMD_CAN_TX:\n\t\t\tif (msg->txdone.net >= dev->net_count) {\n\t\t\t\tdev_err(dev->udev->dev.parent, \"format error\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tesd_usb_tx_done_msg(dev->nets[msg->txdone.net],\n\t\t\t\t\t    msg);\n\t\t\tbreak;\n\t\t}\n\n\t\tpos += msg->hdr.len * sizeof(u32);  \n\n\t\tif (pos > urb->actual_length) {\n\t\t\tdev_err(dev->udev->dev.parent, \"format error\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\nresubmit_urb:\n\tusb_fill_bulk_urb(urb, dev->udev, usb_rcvbulkpipe(dev->udev, 1),\n\t\t\t  urb->transfer_buffer, ESD_USB_RX_BUFFER_SIZE,\n\t\t\t  esd_usb_read_bulk_callback, dev);\n\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval == -ENODEV) {\n\t\tfor (i = 0; i < dev->net_count; i++) {\n\t\t\tif (dev->nets[i])\n\t\t\t\tnetif_device_detach(dev->nets[i]->netdev);\n\t\t}\n\t} else if (retval) {\n\t\tdev_err(dev->udev->dev.parent,\n\t\t\t\"failed resubmitting read bulk urb: %d\\n\", retval);\n\t}\n}\n\n \nstatic void esd_usb_write_bulk_callback(struct urb *urb)\n{\n\tstruct esd_tx_urb_context *context = urb->context;\n\tstruct esd_usb_net_priv *priv;\n\tstruct net_device *netdev;\n\tsize_t size = sizeof(union esd_usb_msg);\n\n\tWARN_ON(!context);\n\n\tpriv = context->priv;\n\tnetdev = priv->netdev;\n\n\t \n\tusb_free_coherent(urb->dev, size,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"Tx URB aborted (%d)\\n\", urb->status);\n\n\tnetif_trans_update(netdev);\n}\n\nstatic ssize_t firmware_show(struct device *d,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct usb_interface *intf = to_usb_interface(d);\n\tstruct esd_usb *dev = usb_get_intfdata(intf);\n\n\treturn sprintf(buf, \"%d.%d.%d\\n\",\n\t\t       (dev->version >> 12) & 0xf,\n\t\t       (dev->version >> 8) & 0xf,\n\t\t       dev->version & 0xff);\n}\nstatic DEVICE_ATTR_RO(firmware);\n\nstatic ssize_t hardware_show(struct device *d,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct usb_interface *intf = to_usb_interface(d);\n\tstruct esd_usb *dev = usb_get_intfdata(intf);\n\n\treturn sprintf(buf, \"%d.%d.%d\\n\",\n\t\t       (dev->version >> 28) & 0xf,\n\t\t       (dev->version >> 24) & 0xf,\n\t\t       (dev->version >> 16) & 0xff);\n}\nstatic DEVICE_ATTR_RO(hardware);\n\nstatic ssize_t nets_show(struct device *d,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct usb_interface *intf = to_usb_interface(d);\n\tstruct esd_usb *dev = usb_get_intfdata(intf);\n\n\treturn sprintf(buf, \"%d\", dev->net_count);\n}\nstatic DEVICE_ATTR_RO(nets);\n\nstatic int esd_usb_send_msg(struct esd_usb *dev, union esd_usb_msg *msg)\n{\n\tint actual_length;\n\n\treturn usb_bulk_msg(dev->udev,\n\t\t\t    usb_sndbulkpipe(dev->udev, 2),\n\t\t\t    msg,\n\t\t\t    msg->hdr.len * sizeof(u32),  \n\t\t\t    &actual_length,\n\t\t\t    1000);\n}\n\nstatic int esd_usb_wait_msg(struct esd_usb *dev,\n\t\t\t    union esd_usb_msg *msg)\n{\n\tint actual_length;\n\n\treturn usb_bulk_msg(dev->udev,\n\t\t\t    usb_rcvbulkpipe(dev->udev, 1),\n\t\t\t    msg,\n\t\t\t    sizeof(*msg),\n\t\t\t    &actual_length,\n\t\t\t    1000);\n}\n\nstatic int esd_usb_setup_rx_urbs(struct esd_usb *dev)\n{\n\tint i, err = 0;\n\n\tif (dev->rxinitdone)\n\t\treturn 0;\n\n\tfor (i = 0; i < ESD_USB_MAX_RX_URBS; i++) {\n\t\tstruct urb *urb = NULL;\n\t\tu8 *buf = NULL;\n\t\tdma_addr_t buf_dma;\n\n\t\t \n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf = usb_alloc_coherent(dev->udev, ESD_USB_RX_BUFFER_SIZE, GFP_KERNEL,\n\t\t\t\t\t &buf_dma);\n\t\tif (!buf) {\n\t\t\tdev_warn(dev->udev->dev.parent,\n\t\t\t\t \"No memory left for USB buffer\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto freeurb;\n\t\t}\n\n\t\turb->transfer_dma = buf_dma;\n\n\t\tusb_fill_bulk_urb(urb, dev->udev,\n\t\t\t\t  usb_rcvbulkpipe(dev->udev, 1),\n\t\t\t\t  buf, ESD_USB_RX_BUFFER_SIZE,\n\t\t\t\t  esd_usb_read_bulk_callback, dev);\n\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\tusb_anchor_urb(urb, &dev->rx_submitted);\n\n\t\terr = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (err) {\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tusb_free_coherent(dev->udev, ESD_USB_RX_BUFFER_SIZE, buf,\n\t\t\t\t\t  urb->transfer_dma);\n\t\t\tgoto freeurb;\n\t\t}\n\n\t\tdev->rxbuf[i] = buf;\n\t\tdev->rxbuf_dma[i] = buf_dma;\n\nfreeurb:\n\t\t \n\t\tusb_free_urb(urb);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (i == 0) {\n\t\tdev_err(dev->udev->dev.parent, \"couldn't setup read URBs\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tif (i < ESD_USB_MAX_RX_URBS) {\n\t\tdev_warn(dev->udev->dev.parent,\n\t\t\t \"rx performance may be slow\\n\");\n\t}\n\n\tdev->rxinitdone = 1;\n\treturn 0;\n}\n\n \nstatic int esd_usb_start(struct esd_usb_net_priv *priv)\n{\n\tstruct esd_usb *dev = priv->usb;\n\tstruct net_device *netdev = priv->netdev;\n\tunion esd_usb_msg *msg;\n\tint err, i;\n\n\tmsg = kmalloc(sizeof(*msg), GFP_KERNEL);\n\tif (!msg) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tmsg->hdr.cmd = ESD_USB_CMD_IDADD;\n\tmsg->hdr.len = sizeof(struct esd_usb_id_filter_msg) / sizeof(u32);  \n\tmsg->filter.net = priv->index;\n\tmsg->filter.option = ESD_USB_ID_ENABLE;  \n\tfor (i = 0; i < ESD_USB_MAX_ID_SEGMENT; i++)\n\t\tmsg->filter.mask[i] = cpu_to_le32(GENMASK(31, 0));\n\t \n\tmsg->filter.mask[ESD_USB_MAX_ID_SEGMENT] = cpu_to_le32(BIT(0));\n\n\terr = esd_usb_send_msg(dev, msg);\n\tif (err)\n\t\tgoto out;\n\n\terr = esd_usb_setup_rx_urbs(dev);\n\tif (err)\n\t\tgoto out;\n\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\nout:\n\tif (err == -ENODEV)\n\t\tnetif_device_detach(netdev);\n\tif (err)\n\t\tnetdev_err(netdev, \"couldn't start device: %d\\n\", err);\n\n\tkfree(msg);\n\treturn err;\n}\n\nstatic void unlink_all_urbs(struct esd_usb *dev)\n{\n\tstruct esd_usb_net_priv *priv;\n\tint i, j;\n\n\tusb_kill_anchored_urbs(&dev->rx_submitted);\n\n\tfor (i = 0; i < ESD_USB_MAX_RX_URBS; ++i)\n\t\tusb_free_coherent(dev->udev, ESD_USB_RX_BUFFER_SIZE,\n\t\t\t\t  dev->rxbuf[i], dev->rxbuf_dma[i]);\n\n\tfor (i = 0; i < dev->net_count; i++) {\n\t\tpriv = dev->nets[i];\n\t\tif (priv) {\n\t\t\tusb_kill_anchored_urbs(&priv->tx_submitted);\n\t\t\tatomic_set(&priv->active_tx_jobs, 0);\n\n\t\t\tfor (j = 0; j < ESD_USB_MAX_TX_URBS; j++)\n\t\t\t\tpriv->tx_contexts[j].echo_index = ESD_USB_MAX_TX_URBS;\n\t\t}\n\t}\n}\n\nstatic int esd_usb_open(struct net_device *netdev)\n{\n\tstruct esd_usb_net_priv *priv = netdev_priv(netdev);\n\tint err;\n\n\t \n\terr = open_candev(netdev);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = esd_usb_start(priv);\n\tif (err) {\n\t\tnetdev_warn(netdev, \"couldn't start device: %d\\n\", err);\n\t\tclose_candev(netdev);\n\t\treturn err;\n\t}\n\n\tnetif_start_queue(netdev);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t esd_usb_start_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *netdev)\n{\n\tstruct esd_usb_net_priv *priv = netdev_priv(netdev);\n\tstruct esd_usb *dev = priv->usb;\n\tstruct esd_tx_urb_context *context = NULL;\n\tstruct net_device_stats *stats = &netdev->stats;\n\tstruct canfd_frame *cfd = (struct canfd_frame *)skb->data;\n\tunion esd_usb_msg *msg;\n\tstruct urb *urb;\n\tu8 *buf;\n\tint i, err;\n\tint ret = NETDEV_TX_OK;\n\tsize_t size = sizeof(union esd_usb_msg);\n\n\tif (can_dev_dropped_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\t \n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb) {\n\t\tstats->tx_dropped++;\n\t\tdev_kfree_skb(skb);\n\t\tgoto nourbmem;\n\t}\n\n\tbuf = usb_alloc_coherent(dev->udev, size, GFP_ATOMIC,\n\t\t\t\t &urb->transfer_dma);\n\tif (!buf) {\n\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\tstats->tx_dropped++;\n\t\tdev_kfree_skb(skb);\n\t\tgoto nobufmem;\n\t}\n\n\tmsg = (union esd_usb_msg *)buf;\n\n\t \n\tmsg->hdr.len = offsetof(struct esd_usb_tx_msg, data) / sizeof(u32);\n\tmsg->hdr.cmd = ESD_USB_CMD_CAN_TX;\n\tmsg->tx.net = priv->index;\n\n\tif (can_is_canfd_skb(skb)) {\n\t\tmsg->tx.dlc = can_fd_len2dlc(cfd->len);\n\t\tmsg->tx.dlc |= ESD_USB_FD;\n\n\t\tif ((cfd->flags & CANFD_BRS) == 0)\n\t\t\tmsg->tx.dlc |= ESD_USB_NO_BRS;\n\t} else {\n\t\tmsg->tx.dlc = can_get_cc_dlc((struct can_frame *)cfd, priv->can.ctrlmode);\n\n\t\tif (cfd->can_id & CAN_RTR_FLAG)\n\t\t\tmsg->tx.dlc |= ESD_USB_RTR;\n\t}\n\n\tmsg->tx.id = cpu_to_le32(cfd->can_id & CAN_ERR_MASK);\n\n\tif (cfd->can_id & CAN_EFF_FLAG)\n\t\tmsg->tx.id |= cpu_to_le32(ESD_USB_EXTID);\n\n\tmemcpy(msg->tx.data_fd, cfd->data, cfd->len);\n\n\t \n\tmsg->hdr.len += DIV_ROUND_UP(cfd->len, sizeof(u32));\n\n\tfor (i = 0; i < ESD_USB_MAX_TX_URBS; i++) {\n\t\tif (priv->tx_contexts[i].echo_index == ESD_USB_MAX_TX_URBS) {\n\t\t\tcontext = &priv->tx_contexts[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!context) {\n\t\tnetdev_warn(netdev, \"couldn't find free context\\n\");\n\t\tret = NETDEV_TX_BUSY;\n\t\tgoto releasebuf;\n\t}\n\n\tcontext->priv = priv;\n\tcontext->echo_index = i;\n\n\t \n\tmsg->tx.hnd = BIT(31) | i;  \n\n\tusb_fill_bulk_urb(urb, dev->udev, usb_sndbulkpipe(dev->udev, 2), buf,\n\t\t\t  msg->hdr.len * sizeof(u32),  \n\t\t\t  esd_usb_write_bulk_callback, context);\n\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\tusb_anchor_urb(urb, &priv->tx_submitted);\n\n\tcan_put_echo_skb(skb, netdev, context->echo_index, 0);\n\n\tatomic_inc(&priv->active_tx_jobs);\n\n\t \n\tif (atomic_read(&priv->active_tx_jobs) >= ESD_USB_MAX_TX_URBS)\n\t\tnetif_stop_queue(netdev);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err) {\n\t\tcan_free_echo_skb(netdev, context->echo_index, NULL);\n\n\t\tatomic_dec(&priv->active_tx_jobs);\n\t\tusb_unanchor_urb(urb);\n\n\t\tstats->tx_dropped++;\n\n\t\tif (err == -ENODEV)\n\t\t\tnetif_device_detach(netdev);\n\t\telse\n\t\t\tnetdev_warn(netdev, \"failed tx_urb %d\\n\", err);\n\n\t\tgoto releasebuf;\n\t}\n\n\tnetif_trans_update(netdev);\n\n\t \n\tusb_free_urb(urb);\n\n\treturn NETDEV_TX_OK;\n\nreleasebuf:\n\tusb_free_coherent(dev->udev, size, buf, urb->transfer_dma);\n\nnobufmem:\n\tusb_free_urb(urb);\n\nnourbmem:\n\treturn ret;\n}\n\nstatic int esd_usb_close(struct net_device *netdev)\n{\n\tstruct esd_usb_net_priv *priv = netdev_priv(netdev);\n\tunion esd_usb_msg *msg;\n\tint i;\n\n\tmsg = kmalloc(sizeof(*msg), GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\t \n\tmsg->hdr.cmd = ESD_USB_CMD_IDADD;\n\tmsg->hdr.len = sizeof(struct esd_usb_id_filter_msg) / sizeof(u32); \n\tmsg->filter.net = priv->index;\n\tmsg->filter.option = ESD_USB_ID_ENABLE;  \n\tfor (i = 0; i <= ESD_USB_MAX_ID_SEGMENT; i++)\n\t\tmsg->filter.mask[i] = 0;\n\tif (esd_usb_send_msg(priv->usb, msg) < 0)\n\t\tnetdev_err(netdev, \"sending idadd message failed\\n\");\n\n\t \n\tmsg->hdr.len = sizeof(struct esd_usb_set_baudrate_msg) / sizeof(u32);  \n\tmsg->hdr.cmd = ESD_USB_CMD_SETBAUD;\n\tmsg->setbaud.net = priv->index;\n\tmsg->setbaud.rsvd = 0;\n\tmsg->setbaud.baud = cpu_to_le32(ESD_USB_NO_BAUDRATE);\n\tif (esd_usb_send_msg(priv->usb, msg) < 0)\n\t\tnetdev_err(netdev, \"sending setbaud message failed\\n\");\n\n\tpriv->can.state = CAN_STATE_STOPPED;\n\n\tnetif_stop_queue(netdev);\n\n\tclose_candev(netdev);\n\n\tkfree(msg);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops esd_usb_netdev_ops = {\n\t.ndo_open = esd_usb_open,\n\t.ndo_stop = esd_usb_close,\n\t.ndo_start_xmit = esd_usb_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic const struct ethtool_ops esd_usb_ethtool_ops = {\n\t.get_ts_info = ethtool_op_get_ts_info,\n};\n\nstatic const struct can_bittiming_const esd_usb_2_bittiming_const = {\n\t.name = \"esd_usb_2\",\n\t.tseg1_min = 1,\n\t.tseg1_max = 16,\n\t.tseg2_min = 1,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 1024,\n\t.brp_inc = 1,\n};\n\nstatic int esd_usb_2_set_bittiming(struct net_device *netdev)\n{\n\tconst struct can_bittiming_const *btc = &esd_usb_2_bittiming_const;\n\tstruct esd_usb_net_priv *priv = netdev_priv(netdev);\n\tstruct can_bittiming *bt = &priv->can.bittiming;\n\tunion esd_usb_msg *msg;\n\tint err;\n\tu32 canbtr;\n\tint sjw_shift;\n\n\tcanbtr = ESD_USB_UBR;\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tcanbtr |= ESD_USB_LOM;\n\n\tcanbtr |= (bt->brp - 1) & (btc->brp_max - 1);\n\n\tif (le16_to_cpu(priv->usb->udev->descriptor.idProduct) ==\n\t    ESD_USB_CANUSBM_PRODUCT_ID)\n\t\tsjw_shift = ESD_USB_M_SJW_SHIFT;\n\telse\n\t\tsjw_shift = ESD_USB_2_SJW_SHIFT;\n\n\tcanbtr |= ((bt->sjw - 1) & (btc->sjw_max - 1))\n\t\t<< sjw_shift;\n\tcanbtr |= ((bt->prop_seg + bt->phase_seg1 - 1)\n\t\t   & (btc->tseg1_max - 1))\n\t\t<< ESD_USB_2_TSEG1_SHIFT;\n\tcanbtr |= ((bt->phase_seg2 - 1) & (btc->tseg2_max - 1))\n\t\t<< ESD_USB_2_TSEG2_SHIFT;\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\tcanbtr |= ESD_USB_TRIPLE_SAMPLES;\n\n\tmsg = kmalloc(sizeof(*msg), GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->hdr.len = sizeof(struct esd_usb_set_baudrate_msg) / sizeof(u32);  \n\tmsg->hdr.cmd = ESD_USB_CMD_SETBAUD;\n\tmsg->setbaud.net = priv->index;\n\tmsg->setbaud.rsvd = 0;\n\tmsg->setbaud.baud = cpu_to_le32(canbtr);\n\n\tnetdev_dbg(netdev, \"setting BTR=%#x\\n\", canbtr);\n\n\terr = esd_usb_send_msg(priv->usb, msg);\n\n\tkfree(msg);\n\treturn err;\n}\n\n \nstatic const struct can_bittiming_const esd_usb_3_nom_bittiming_const = {\n\t.name = \"esd_usb_3\",\n\t.tseg1_min = 2,\n\t.tseg1_max = 256,\n\t.tseg2_min = 2,\n\t.tseg2_max = 128,\n\t.sjw_max = 128,\n\t.brp_min = 1,\n\t.brp_max = 512,\n\t.brp_inc = 1,\n};\n\n \nstatic const struct can_bittiming_const esd_usb_3_data_bittiming_const = {\n\t.name = \"esd_usb_3\",\n\t.tseg1_min = 2,\n\t.tseg1_max = 32,\n\t.tseg2_min = 1,\n\t.tseg2_max = 16,\n\t.sjw_max = 8,\n\t.brp_min = 1,\n\t.brp_max = 32,\n\t.brp_inc = 1,\n};\n\nstatic int esd_usb_3_set_bittiming(struct net_device *netdev)\n{\n\tconst struct can_bittiming_const *nom_btc = &esd_usb_3_nom_bittiming_const;\n\tconst struct can_bittiming_const *data_btc = &esd_usb_3_data_bittiming_const;\n\tstruct esd_usb_net_priv *priv = netdev_priv(netdev);\n\tstruct can_bittiming *nom_bt = &priv->can.bittiming;\n\tstruct can_bittiming *data_bt = &priv->can.data_bittiming;\n\tstruct esd_usb_3_set_baudrate_msg_x *baud_x;\n\tunion esd_usb_msg *msg;\n\tu16 flags = 0;\n\tint err;\n\n\tmsg = kmalloc(sizeof(*msg), GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tbaud_x = &msg->setbaud_x;\n\n\t \n\tbaud_x->mode = cpu_to_le16(ESD_USB_3_BAUDRATE_MODE_BTR_CANONICAL);\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tflags |= ESD_USB_3_BAUDRATE_FLAG_LOM;\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\tflags |= ESD_USB_3_BAUDRATE_FLAG_TRS;\n\n\tbaud_x->nom.brp = cpu_to_le16(nom_bt->brp & (nom_btc->brp_max - 1));\n\tbaud_x->nom.sjw = cpu_to_le16(nom_bt->sjw & (nom_btc->sjw_max - 1));\n\tbaud_x->nom.tseg1 = cpu_to_le16((nom_bt->prop_seg + nom_bt->phase_seg1)\n\t\t\t\t\t& (nom_btc->tseg1_max - 1));\n\tbaud_x->nom.tseg2 = cpu_to_le16(nom_bt->phase_seg2 & (nom_btc->tseg2_max - 1));\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_FD) {\n\t\tbaud_x->data.brp = cpu_to_le16(data_bt->brp & (data_btc->brp_max - 1));\n\t\tbaud_x->data.sjw = cpu_to_le16(data_bt->sjw & (data_btc->sjw_max - 1));\n\t\tbaud_x->data.tseg1 = cpu_to_le16((data_bt->prop_seg + data_bt->phase_seg1)\n\t\t\t\t\t\t & (data_btc->tseg1_max - 1));\n\t\tbaud_x->data.tseg2 = cpu_to_le16(data_bt->phase_seg2 & (data_btc->tseg2_max - 1));\n\t\tflags |= ESD_USB_3_BAUDRATE_FLAG_FD;\n\t}\n\n\t \n\tbaud_x->tdc.tdc_mode = ESD_USB_3_TDC_MODE_AUTO;\n\tbaud_x->tdc.ssp_offset = 0;\n\tbaud_x->tdc.ssp_shift = 0;\n\tbaud_x->tdc.tdc_filter = 0;\n\n\tbaud_x->flags = cpu_to_le16(flags);\n\tbaud_x->net = priv->index;\n\tbaud_x->rsvd = 0;\n\n\t \n\tmsg->hdr.len = sizeof(struct esd_usb_3_set_baudrate_msg_x) / sizeof(u32);\n\tmsg->hdr.cmd = ESD_USB_CMD_SETBAUD;\n\n\tnetdev_dbg(netdev,\n\t\t   \"ctrlmode=%#x/%#x, esd-net=%u, esd-mode=%#x, esd-flags=%#x\\n\",\n\t\t   priv->can.ctrlmode, priv->can.ctrlmode_supported,\n\t\t   priv->index, le16_to_cpu(baud_x->mode), flags);\n\n\terr = esd_usb_send_msg(priv->usb, msg);\n\n\tkfree(msg);\n\treturn err;\n}\n\nstatic int esd_usb_get_berr_counter(const struct net_device *netdev,\n\t\t\t\t    struct can_berr_counter *bec)\n{\n\tstruct esd_usb_net_priv *priv = netdev_priv(netdev);\n\n\tbec->txerr = priv->bec.txerr;\n\tbec->rxerr = priv->bec.rxerr;\n\n\treturn 0;\n}\n\nstatic int esd_usb_set_mode(struct net_device *netdev, enum can_mode mode)\n{\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\tnetif_wake_queue(netdev);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int esd_usb_probe_one_net(struct usb_interface *intf, int index)\n{\n\tstruct esd_usb *dev = usb_get_intfdata(intf);\n\tstruct net_device *netdev;\n\tstruct esd_usb_net_priv *priv;\n\tint err = 0;\n\tint i;\n\n\tnetdev = alloc_candev(sizeof(*priv), ESD_USB_MAX_TX_URBS);\n\tif (!netdev) {\n\t\tdev_err(&intf->dev, \"couldn't alloc candev\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tpriv = netdev_priv(netdev);\n\n\tinit_usb_anchor(&priv->tx_submitted);\n\tatomic_set(&priv->active_tx_jobs, 0);\n\n\tfor (i = 0; i < ESD_USB_MAX_TX_URBS; i++)\n\t\tpriv->tx_contexts[i].echo_index = ESD_USB_MAX_TX_URBS;\n\n\tpriv->usb = dev;\n\tpriv->netdev = netdev;\n\tpriv->index = index;\n\n\tpriv->can.state = CAN_STATE_STOPPED;\n\tpriv->can.ctrlmode_supported = CAN_CTRLMODE_LISTENONLY |\n\t\tCAN_CTRLMODE_CC_LEN8_DLC |\n\t\tCAN_CTRLMODE_BERR_REPORTING;\n\n\tswitch (le16_to_cpu(dev->udev->descriptor.idProduct)) {\n\tcase ESD_USB_CANUSB3_PRODUCT_ID:\n\t\tpriv->can.clock.freq = ESD_USB_3_CAN_CLOCK;\n\t\tpriv->can.ctrlmode_supported |= CAN_CTRLMODE_3_SAMPLES;\n\t\tpriv->can.ctrlmode_supported |= CAN_CTRLMODE_FD;\n\t\tpriv->can.bittiming_const = &esd_usb_3_nom_bittiming_const;\n\t\tpriv->can.data_bittiming_const = &esd_usb_3_data_bittiming_const;\n\t\tpriv->can.do_set_bittiming = esd_usb_3_set_bittiming;\n\t\tpriv->can.do_set_data_bittiming = esd_usb_3_set_bittiming;\n\t\tbreak;\n\n\tcase ESD_USB_CANUSBM_PRODUCT_ID:\n\t\tpriv->can.clock.freq = ESD_USB_M_CAN_CLOCK;\n\t\tpriv->can.bittiming_const = &esd_usb_2_bittiming_const;\n\t\tpriv->can.do_set_bittiming = esd_usb_2_set_bittiming;\n\t\tbreak;\n\n\tcase ESD_USB_CANUSB2_PRODUCT_ID:\n\tdefault:\n\t\tpriv->can.clock.freq = ESD_USB_2_CAN_CLOCK;\n\t\tpriv->can.ctrlmode_supported |= CAN_CTRLMODE_3_SAMPLES;\n\t\tpriv->can.bittiming_const = &esd_usb_2_bittiming_const;\n\t\tpriv->can.do_set_bittiming = esd_usb_2_set_bittiming;\n\t\tbreak;\n\t}\n\n\tpriv->can.do_set_mode = esd_usb_set_mode;\n\tpriv->can.do_get_berr_counter = esd_usb_get_berr_counter;\n\n\tnetdev->flags |= IFF_ECHO;  \n\n\tnetdev->netdev_ops = &esd_usb_netdev_ops;\n\tnetdev->ethtool_ops = &esd_usb_ethtool_ops;\n\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\tnetdev->dev_id = index;\n\n\terr = register_candev(netdev);\n\tif (err) {\n\t\tdev_err(&intf->dev, \"couldn't register CAN device: %d\\n\", err);\n\t\tfree_candev(netdev);\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tdev->nets[index] = priv;\n\tnetdev_info(netdev, \"device %s registered\\n\", netdev->name);\n\ndone:\n\treturn err;\n}\n\n \nstatic int esd_usb_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct esd_usb *dev;\n\tunion esd_usb_msg *msg;\n\tint i, err;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tdev->udev = interface_to_usbdev(intf);\n\n\tinit_usb_anchor(&dev->rx_submitted);\n\n\tusb_set_intfdata(intf, dev);\n\n\tmsg = kmalloc(sizeof(*msg), GFP_KERNEL);\n\tif (!msg) {\n\t\terr = -ENOMEM;\n\t\tgoto free_msg;\n\t}\n\n\t \n\tmsg->hdr.cmd = ESD_USB_CMD_VERSION;\n\tmsg->hdr.len = sizeof(struct esd_usb_version_msg) / sizeof(u32);  \n\tmsg->version.rsvd = 0;\n\tmsg->version.flags = 0;\n\tmsg->version.drv_version = 0;\n\n\terr = esd_usb_send_msg(dev, msg);\n\tif (err < 0) {\n\t\tdev_err(&intf->dev, \"sending version message failed\\n\");\n\t\tgoto free_msg;\n\t}\n\n\terr = esd_usb_wait_msg(dev, msg);\n\tif (err < 0) {\n\t\tdev_err(&intf->dev, \"no version message answer\\n\");\n\t\tgoto free_msg;\n\t}\n\n\tdev->net_count = (int)msg->version_reply.nets;\n\tdev->version = le32_to_cpu(msg->version_reply.version);\n\n\tif (device_create_file(&intf->dev, &dev_attr_firmware))\n\t\tdev_err(&intf->dev,\n\t\t\t\"Couldn't create device file for firmware\\n\");\n\n\tif (device_create_file(&intf->dev, &dev_attr_hardware))\n\t\tdev_err(&intf->dev,\n\t\t\t\"Couldn't create device file for hardware\\n\");\n\n\tif (device_create_file(&intf->dev, &dev_attr_nets))\n\t\tdev_err(&intf->dev,\n\t\t\t\"Couldn't create device file for nets\\n\");\n\n\t \n\tfor (i = 0; i < dev->net_count; i++)\n\t\tesd_usb_probe_one_net(intf, i);\n\nfree_msg:\n\tkfree(msg);\n\tif (err)\n\t\tkfree(dev);\ndone:\n\treturn err;\n}\n\n \nstatic void esd_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct esd_usb *dev = usb_get_intfdata(intf);\n\tstruct net_device *netdev;\n\tint i;\n\n\tdevice_remove_file(&intf->dev, &dev_attr_firmware);\n\tdevice_remove_file(&intf->dev, &dev_attr_hardware);\n\tdevice_remove_file(&intf->dev, &dev_attr_nets);\n\n\tusb_set_intfdata(intf, NULL);\n\n\tif (dev) {\n\t\tfor (i = 0; i < dev->net_count; i++) {\n\t\t\tif (dev->nets[i]) {\n\t\t\t\tnetdev = dev->nets[i]->netdev;\n\t\t\t\tunregister_netdev(netdev);\n\t\t\t\tfree_candev(netdev);\n\t\t\t}\n\t\t}\n\t\tunlink_all_urbs(dev);\n\t\tkfree(dev);\n\t}\n}\n\n \nstatic struct usb_driver esd_usb_driver = {\n\t.name = KBUILD_MODNAME,\n\t.probe = esd_usb_probe,\n\t.disconnect = esd_usb_disconnect,\n\t.id_table = esd_usb_table,\n};\n\nmodule_usb_driver(esd_usb_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}