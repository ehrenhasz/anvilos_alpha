{
  "module_name": "f81604.c",
  "hash_id": "43fd0f15fe7ddbbef85bb4779eb76560ffaac97804f7500a47e66be5e6d96da5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/usb/f81604.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/netdevice.h>\n#include <linux/units.h>\n#include <linux/usb.h>\n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n#include <linux/can/platform/sja1000.h>\n\n#include <asm-generic/unaligned.h>\n\n \n#define F81604_VENDOR_ID 0x2c42\n#define F81604_PRODUCT_ID 0x1709\n#define F81604_CAN_CLOCK (12 * MEGA)\n#define F81604_MAX_DEV 2\n#define F81604_SET_DEVICE_RETRY 10\n\n#define F81604_USB_TIMEOUT 2000\n#define F81604_SET_GET_REGISTER 0xA0\n#define F81604_PORT_OFFSET 0x1000\n#define F81604_MAX_RX_URBS 4\n\n#define F81604_CMD_DATA 0x00\n\n#define F81604_DLC_LEN_MASK GENMASK(3, 0)\n#define F81604_DLC_EFF_BIT BIT(7)\n#define F81604_DLC_RTR_BIT BIT(6)\n\n#define F81604_SFF_SHIFT 5\n#define F81604_EFF_SHIFT 3\n\n#define F81604_BRP_MASK GENMASK(5, 0)\n#define F81604_SJW_MASK GENMASK(7, 6)\n\n#define F81604_SEG1_MASK GENMASK(3, 0)\n#define F81604_SEG2_MASK GENMASK(6, 4)\n\n#define F81604_CLEAR_ALC 0\n#define F81604_CLEAR_ECC 1\n#define F81604_CLEAR_OVERRUN 2\n\n \n#define F81604_CTRL_MODE_REG 0x80\n#define F81604_TX_ONESHOT (0x03 << 3)\n#define F81604_TX_NORMAL (0x01 << 3)\n#define F81604_RX_AUTO_RELEASE_BUF BIT(1)\n#define F81604_INT_WHEN_CHANGE BIT(0)\n\n#define F81604_TERMINATOR_REG 0x105\n#define F81604_CAN0_TERM BIT(2)\n#define F81604_CAN1_TERM BIT(3)\n\n#define F81604_TERMINATION_DISABLED CAN_TERMINATION_DISABLED\n#define F81604_TERMINATION_ENABLED 120\n\n \n#define F81604_SJA1000_MOD 0x00\n#define F81604_SJA1000_CMR 0x01\n#define F81604_SJA1000_IR 0x03\n#define F81604_SJA1000_IER 0x04\n#define F81604_SJA1000_ALC 0x0B\n#define F81604_SJA1000_ECC 0x0C\n#define F81604_SJA1000_RXERR 0x0E\n#define F81604_SJA1000_TXERR 0x0F\n#define F81604_SJA1000_ACCC0 0x10\n#define F81604_SJA1000_ACCM0 0x14\n#define F81604_MAX_FILTER_CNT 4\n\n \n#define F81604_SJA1000_BTR0 0x06\n#define F81604_SJA1000_BTR1 0x07\n#define F81604_SJA1000_BTR1_SAMPLE_TRIPLE BIT(7)\n#define F81604_SJA1000_OCR 0x08\n#define F81604_SJA1000_CDR 0x1F\n\n \n#define F81604_SJA1000_MOD_RM 0x01\n#define F81604_SJA1000_MOD_LOM 0x02\n#define F81604_SJA1000_MOD_STM 0x04\n\n \n#define F81604_SJA1000_CMD_CDO 0x08\n\n \n#define F81604_SJA1000_IRQ_BEI 0x80\n#define F81604_SJA1000_IRQ_ALI 0x40\n#define F81604_SJA1000_IRQ_EPI 0x20\n#define F81604_SJA1000_IRQ_DOI 0x08\n#define F81604_SJA1000_IRQ_EI 0x04\n#define F81604_SJA1000_IRQ_TI 0x02\n#define F81604_SJA1000_IRQ_RI 0x01\n#define F81604_SJA1000_IRQ_ALL 0xFF\n#define F81604_SJA1000_IRQ_OFF 0x00\n\n \n#define F81604_SJA1000_SR_BS 0x80\n#define F81604_SJA1000_SR_ES 0x40\n#define F81604_SJA1000_SR_TCS 0x08\n\n \n#define F81604_SJA1000_ECC_SEG 0x1F\n#define F81604_SJA1000_ECC_DIR 0x20\n#define F81604_SJA1000_ECC_BIT 0x00\n#define F81604_SJA1000_ECC_FORM 0x40\n#define F81604_SJA1000_ECC_STUFF 0x80\n#define F81604_SJA1000_ECC_MASK 0xc0\n\n \n#define F81604_SJA1000_ALC_MASK 0x1f\n\n \nstatic const struct usb_device_id f81604_table[] = {\n\t{ USB_DEVICE(F81604_VENDOR_ID, F81604_PRODUCT_ID) },\n\t{}  \n};\n\nMODULE_DEVICE_TABLE(usb, f81604_table);\n\nstatic const struct ethtool_ops f81604_ethtool_ops = {\n\t.get_ts_info = ethtool_op_get_ts_info,\n};\n\nstatic const u16 f81604_termination[] = { F81604_TERMINATION_DISABLED,\n\t\t\t\t\t  F81604_TERMINATION_ENABLED };\n\nstruct f81604_priv {\n\tstruct net_device *netdev[F81604_MAX_DEV];\n};\n\nstruct f81604_port_priv {\n\tstruct can_priv can;\n\tstruct net_device *netdev;\n\tstruct sk_buff *echo_skb;\n\n\tunsigned long clear_flags;\n\tstruct work_struct clear_reg_work;\n\n\tstruct usb_device *dev;\n\tstruct usb_interface *intf;\n\n\tstruct usb_anchor urbs_anchor;\n};\n\n \nstruct f81604_int_data {\n\tu8 sr;\n\tu8 isrc;\n\tu8 ier;\n\tu8 alc;\n\tu8 ecc;\n\tu8 ewlr;\n\tu8 rxerr;\n\tu8 txerr;\n\tu8 val;\n} __packed __aligned(4);\n\nstruct f81604_sff {\n\t__be16 id;\n\tu8 data[CAN_MAX_DLEN];\n} __packed __aligned(2);\n\nstruct f81604_eff {\n\t__be32 id;\n\tu8 data[CAN_MAX_DLEN];\n} __packed __aligned(2);\n\nstruct f81604_can_frame {\n\tu8 cmd;\n\n\t \n\tu8 dlc;\n\n\tunion {\n\t\tstruct f81604_sff sff;\n\t\tstruct f81604_eff eff;\n\t};\n} __packed __aligned(2);\n\nstatic const u8 bulk_in_addr[F81604_MAX_DEV] = { 2, 4 };\nstatic const u8 bulk_out_addr[F81604_MAX_DEV] = { 1, 3 };\nstatic const u8 int_in_addr[F81604_MAX_DEV] = { 1, 3 };\n\nstatic int f81604_write(struct usb_device *dev, u16 reg, u8 data)\n{\n\tint ret;\n\n\tret = usb_control_msg_send(dev, 0, F81604_SET_GET_REGISTER,\n\t\t\t\t   USB_TYPE_VENDOR | USB_DIR_OUT, 0, reg,\n\t\t\t\t   &data, sizeof(data), F81604_USB_TIMEOUT,\n\t\t\t\t   GFP_KERNEL);\n\tif (ret)\n\t\tdev_err(&dev->dev, \"%s: reg: %x data: %x failed: %pe\\n\",\n\t\t\t__func__, reg, data, ERR_PTR(ret));\n\n\treturn ret;\n}\n\nstatic int f81604_read(struct usb_device *dev, u16 reg, u8 *data)\n{\n\tint ret;\n\n\tret = usb_control_msg_recv(dev, 0, F81604_SET_GET_REGISTER,\n\t\t\t\t   USB_TYPE_VENDOR | USB_DIR_IN, 0, reg, data,\n\t\t\t\t   sizeof(*data), F81604_USB_TIMEOUT,\n\t\t\t\t   GFP_KERNEL);\n\n\tif (ret < 0)\n\t\tdev_err(&dev->dev, \"%s: reg: %x failed: %pe\\n\", __func__, reg,\n\t\t\tERR_PTR(ret));\n\n\treturn ret;\n}\n\nstatic int f81604_update_bits(struct usb_device *dev, u16 reg, u8 mask,\n\t\t\t      u8 data)\n{\n\tint ret;\n\tu8 tmp;\n\n\tret = f81604_read(dev, reg, &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\ttmp &= ~mask;\n\ttmp |= (mask & data);\n\n\treturn f81604_write(dev, reg, tmp);\n}\n\nstatic int f81604_sja1000_write(struct f81604_port_priv *priv, u16 reg,\n\t\t\t\tu8 data)\n{\n\tint port = priv->netdev->dev_port;\n\tint real_reg;\n\n\treal_reg = reg + F81604_PORT_OFFSET * port + F81604_PORT_OFFSET;\n\treturn f81604_write(priv->dev, real_reg, data);\n}\n\nstatic int f81604_sja1000_read(struct f81604_port_priv *priv, u16 reg,\n\t\t\t       u8 *data)\n{\n\tint port = priv->netdev->dev_port;\n\tint real_reg;\n\n\treal_reg = reg + F81604_PORT_OFFSET * port + F81604_PORT_OFFSET;\n\treturn f81604_read(priv->dev, real_reg, data);\n}\n\nstatic int f81604_set_reset_mode(struct f81604_port_priv *priv)\n{\n\tint ret, i;\n\tu8 tmp;\n\n\t \n\tret = f81604_sja1000_write(priv, F81604_SJA1000_IER,\n\t\t\t\t   F81604_SJA1000_IRQ_OFF);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < F81604_SET_DEVICE_RETRY; i++) {\n\t\tret = f81604_sja1000_read(priv, F81604_SJA1000_MOD, &tmp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (tmp & F81604_SJA1000_MOD_RM) {\n\t\t\tpriv->can.state = CAN_STATE_STOPPED;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tret = f81604_sja1000_write(priv, F81604_SJA1000_MOD,\n\t\t\t\t\t   F81604_SJA1000_MOD_RM);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn -EPERM;\n}\n\nstatic int f81604_set_normal_mode(struct f81604_port_priv *priv)\n{\n\tu8 tmp, ier = 0;\n\tu8 mod_reg = 0;\n\tint ret, i;\n\n\tfor (i = 0; i < F81604_SET_DEVICE_RETRY; i++) {\n\t\tret = f81604_sja1000_read(priv, F81604_SJA1000_MOD, &tmp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif ((tmp & F81604_SJA1000_MOD_RM) == 0) {\n\t\t\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\t\t \n\t\t\tier = F81604_SJA1000_IRQ_ALL & ~F81604_SJA1000_IRQ_RI;\n\t\t\tif (!(priv->can.ctrlmode &\n\t\t\t      CAN_CTRLMODE_BERR_REPORTING))\n\t\t\t\tier &= ~F81604_SJA1000_IRQ_BEI;\n\n\t\t\treturn f81604_sja1000_write(priv, F81604_SJA1000_IER,\n\t\t\t\t\t\t    ier);\n\t\t}\n\n\t\t \n\t\tif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\t\tmod_reg |= F81604_SJA1000_MOD_LOM;\n\t\tif (priv->can.ctrlmode & CAN_CTRLMODE_PRESUME_ACK)\n\t\t\tmod_reg |= F81604_SJA1000_MOD_STM;\n\n\t\tret = f81604_sja1000_write(priv, F81604_SJA1000_MOD, mod_reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn -EPERM;\n}\n\nstatic int f81604_chipset_init(struct f81604_port_priv *priv)\n{\n\tint i, ret;\n\n\t \n\tret = f81604_sja1000_write(priv, F81604_SJA1000_CDR,\n\t\t\t\t   CDR_CBP | CDR_PELICAN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < F81604_MAX_FILTER_CNT; ++i) {\n\t\tret = f81604_sja1000_write(priv, F81604_SJA1000_ACCC0 + i, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < F81604_MAX_FILTER_CNT; ++i) {\n\t\tret = f81604_sja1000_write(priv, F81604_SJA1000_ACCM0 + i,\n\t\t\t\t\t   0xFF);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn f81604_sja1000_write(priv, F81604_SJA1000_OCR,\n\t\t\t\t    OCR_TX0_PUSHPULL | OCR_TX1_PUSHPULL |\n\t\t\t\t\t    OCR_MODE_NORMAL);\n}\n\nstatic void f81604_process_rx_packet(struct net_device *netdev,\n\t\t\t\t     struct f81604_can_frame *frame)\n{\n\tstruct net_device_stats *stats = &netdev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\n\tif (frame->cmd != F81604_CMD_DATA)\n\t\treturn;\n\n\tskb = alloc_can_skb(netdev, &cf);\n\tif (!skb) {\n\t\tstats->rx_dropped++;\n\t\treturn;\n\t}\n\n\tcf->len = can_cc_dlc2len(frame->dlc & F81604_DLC_LEN_MASK);\n\n\tif (frame->dlc & F81604_DLC_EFF_BIT) {\n\t\tcf->can_id = get_unaligned_be32(&frame->eff.id) >>\n\t\t\t     F81604_EFF_SHIFT;\n\t\tcf->can_id |= CAN_EFF_FLAG;\n\n\t\tif (!(frame->dlc & F81604_DLC_RTR_BIT))\n\t\t\tmemcpy(cf->data, frame->eff.data, cf->len);\n\t} else {\n\t\tcf->can_id = get_unaligned_be16(&frame->sff.id) >>\n\t\t\t     F81604_SFF_SHIFT;\n\n\t\tif (!(frame->dlc & F81604_DLC_RTR_BIT))\n\t\t\tmemcpy(cf->data, frame->sff.data, cf->len);\n\t}\n\n\tif (frame->dlc & F81604_DLC_RTR_BIT)\n\t\tcf->can_id |= CAN_RTR_FLAG;\n\telse\n\t\tstats->rx_bytes += cf->len;\n\n\tstats->rx_packets++;\n\tnetif_rx(skb);\n}\n\nstatic void f81604_read_bulk_callback(struct urb *urb)\n{\n\tstruct f81604_can_frame *frame = urb->transfer_buffer;\n\tstruct net_device *netdev = urb->context;\n\tint ret;\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"%s: URB aborted %pe\\n\", __func__,\n\t\t\t    ERR_PTR(urb->status));\n\n\tswitch (urb->status) {\n\tcase 0:  \n\t\tbreak;\n\n\tcase -ENOENT:\n\tcase -EPIPE:\n\tcase -EPROTO:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\n\tdefault:\n\t\tgoto resubmit_urb;\n\t}\n\n\tif (urb->actual_length != sizeof(*frame)) {\n\t\tnetdev_warn(netdev, \"URB length %u not equal to %zu\\n\",\n\t\t\t    urb->actual_length, sizeof(*frame));\n\t\tgoto resubmit_urb;\n\t}\n\n\tf81604_process_rx_packet(netdev, frame);\n\nresubmit_urb:\n\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (ret == -ENODEV)\n\t\tnetif_device_detach(netdev);\n\telse if (ret)\n\t\tnetdev_err(netdev,\n\t\t\t   \"%s: failed to resubmit read bulk urb: %pe\\n\",\n\t\t\t   __func__, ERR_PTR(ret));\n}\n\nstatic void f81604_handle_tx(struct f81604_port_priv *priv,\n\t\t\t     struct f81604_int_data *data)\n{\n\tstruct net_device *netdev = priv->netdev;\n\tstruct net_device_stats *stats = &netdev->stats;\n\n\t \n\tif (priv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT &&\n\t    !(data->sr & F81604_SJA1000_SR_TCS)) {\n\t\tstats->tx_errors++;\n\t\tcan_free_echo_skb(netdev, 0, NULL);\n\t} else {\n\t\t \n\t\tstats->tx_bytes += can_get_echo_skb(netdev, 0, NULL);\n\t\tstats->tx_packets++;\n\t}\n\n\tnetif_wake_queue(netdev);\n}\n\nstatic void f81604_handle_can_bus_errors(struct f81604_port_priv *priv,\n\t\t\t\t\t struct f81604_int_data *data)\n{\n\tenum can_state can_state = priv->can.state;\n\tstruct net_device *netdev = priv->netdev;\n\tstruct net_device_stats *stats = &netdev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\n\t \n\n\tskb = alloc_can_err_skb(netdev, &cf);\n\tif (skb) {\n\t\tcf->can_id |= CAN_ERR_CNT;\n\t\tcf->data[6] = data->txerr;\n\t\tcf->data[7] = data->rxerr;\n\t}\n\n\tif (data->isrc & F81604_SJA1000_IRQ_DOI) {\n\t\t \n\t\tnetdev_dbg(netdev, \"data overrun interrupt\\n\");\n\n\t\tif (skb) {\n\t\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\t\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\t\t}\n\n\t\tstats->rx_over_errors++;\n\t\tstats->rx_errors++;\n\n\t\tset_bit(F81604_CLEAR_OVERRUN, &priv->clear_flags);\n\t}\n\n\tif (data->isrc & F81604_SJA1000_IRQ_EI) {\n\t\t \n\t\tnetdev_dbg(netdev, \"error warning interrupt\\n\");\n\n\t\tif (data->sr & F81604_SJA1000_SR_BS)\n\t\t\tcan_state = CAN_STATE_BUS_OFF;\n\t\telse if (data->sr & F81604_SJA1000_SR_ES)\n\t\t\tcan_state = CAN_STATE_ERROR_WARNING;\n\t\telse\n\t\t\tcan_state = CAN_STATE_ERROR_ACTIVE;\n\t}\n\n\tif (data->isrc & F81604_SJA1000_IRQ_BEI) {\n\t\t \n\t\tnetdev_dbg(netdev, \"bus error interrupt\\n\");\n\n\t\tpriv->can.can_stats.bus_error++;\n\t\tstats->rx_errors++;\n\n\t\tif (skb) {\n\t\t\tcf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\n\n\t\t\t \n\t\t\tswitch (data->ecc & F81604_SJA1000_ECC_MASK) {\n\t\t\tcase F81604_SJA1000_ECC_BIT:\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT;\n\t\t\t\tbreak;\n\t\t\tcase F81604_SJA1000_ECC_FORM:\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_FORM;\n\t\t\t\tbreak;\n\t\t\tcase F81604_SJA1000_ECC_STUFF:\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_STUFF;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tcf->data[3] = data->ecc & F81604_SJA1000_ECC_SEG;\n\n\t\t\t \n\t\t\tif ((data->ecc & F81604_SJA1000_ECC_DIR) == 0)\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_TX;\n\t\t}\n\n\t\tset_bit(F81604_CLEAR_ECC, &priv->clear_flags);\n\t}\n\n\tif (data->isrc & F81604_SJA1000_IRQ_EPI) {\n\t\tif (can_state == CAN_STATE_ERROR_PASSIVE)\n\t\t\tcan_state = CAN_STATE_ERROR_WARNING;\n\t\telse\n\t\t\tcan_state = CAN_STATE_ERROR_PASSIVE;\n\n\t\t \n\t\tnetdev_dbg(netdev, \"error passive interrupt: %d\\n\", can_state);\n\t}\n\n\tif (data->isrc & F81604_SJA1000_IRQ_ALI) {\n\t\t \n\t\tnetdev_dbg(netdev, \"arbitration lost interrupt\\n\");\n\n\t\tpriv->can.can_stats.arbitration_lost++;\n\n\t\tif (skb) {\n\t\t\tcf->can_id |= CAN_ERR_LOSTARB;\n\t\t\tcf->data[0] = data->alc & F81604_SJA1000_ALC_MASK;\n\t\t}\n\n\t\tset_bit(F81604_CLEAR_ALC, &priv->clear_flags);\n\t}\n\n\tif (can_state != priv->can.state) {\n\t\tenum can_state tx_state, rx_state;\n\n\t\ttx_state = data->txerr >= data->rxerr ? can_state : 0;\n\t\trx_state = data->txerr <= data->rxerr ? can_state : 0;\n\n\t\tcan_change_state(netdev, cf, tx_state, rx_state);\n\n\t\tif (can_state == CAN_STATE_BUS_OFF)\n\t\t\tcan_bus_off(netdev);\n\t}\n\n\tif (priv->clear_flags)\n\t\tschedule_work(&priv->clear_reg_work);\n\n\tif (skb)\n\t\tnetif_rx(skb);\n}\n\nstatic void f81604_read_int_callback(struct urb *urb)\n{\n\tstruct f81604_int_data *data = urb->transfer_buffer;\n\tstruct net_device *netdev = urb->context;\n\tstruct f81604_port_priv *priv;\n\tint ret;\n\n\tpriv = netdev_priv(netdev);\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"%s: Int URB aborted: %pe\\n\", __func__,\n\t\t\t    ERR_PTR(urb->status));\n\n\tswitch (urb->status) {\n\tcase 0:  \n\t\tbreak;\n\n\tcase -ENOENT:\n\tcase -EPIPE:\n\tcase -EPROTO:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\n\tdefault:\n\t\tgoto resubmit_urb;\n\t}\n\n\t \n\tif (data->isrc & (F81604_SJA1000_IRQ_DOI | F81604_SJA1000_IRQ_EI |\n\t\t\t  F81604_SJA1000_IRQ_BEI | F81604_SJA1000_IRQ_EPI |\n\t\t\t  F81604_SJA1000_IRQ_ALI))\n\t\tf81604_handle_can_bus_errors(priv, data);\n\n\t \n\tif (priv->can.state != CAN_STATE_BUS_OFF &&\n\t    (data->isrc & F81604_SJA1000_IRQ_TI))\n\t\tf81604_handle_tx(priv, data);\n\nresubmit_urb:\n\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (ret == -ENODEV)\n\t\tnetif_device_detach(netdev);\n\telse if (ret)\n\t\tnetdev_err(netdev, \"%s: failed to resubmit int urb: %pe\\n\",\n\t\t\t   __func__, ERR_PTR(ret));\n}\n\nstatic void f81604_unregister_urbs(struct f81604_port_priv *priv)\n{\n\tusb_kill_anchored_urbs(&priv->urbs_anchor);\n}\n\nstatic int f81604_register_urbs(struct f81604_port_priv *priv)\n{\n\tstruct net_device *netdev = priv->netdev;\n\tstruct f81604_int_data *int_data;\n\tint id = netdev->dev_port;\n\tstruct urb *int_urb;\n\tint rx_urb_cnt;\n\tint ret;\n\n\tfor (rx_urb_cnt = 0; rx_urb_cnt < F81604_MAX_RX_URBS; ++rx_urb_cnt) {\n\t\tstruct f81604_can_frame *frame;\n\t\tstruct urb *rx_urb;\n\n\t\trx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!rx_urb) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tframe = kmalloc(sizeof(*frame), GFP_KERNEL);\n\t\tif (!frame) {\n\t\t\tusb_free_urb(rx_urb);\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tusb_fill_bulk_urb(rx_urb, priv->dev,\n\t\t\t\t  usb_rcvbulkpipe(priv->dev, bulk_in_addr[id]),\n\t\t\t\t  frame, sizeof(*frame),\n\t\t\t\t  f81604_read_bulk_callback, netdev);\n\n\t\trx_urb->transfer_flags |= URB_FREE_BUFFER;\n\t\tusb_anchor_urb(rx_urb, &priv->urbs_anchor);\n\n\t\tret = usb_submit_urb(rx_urb, GFP_KERNEL);\n\t\tif (ret) {\n\t\t\tusb_unanchor_urb(rx_urb);\n\t\t\tusb_free_urb(rx_urb);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tusb_free_urb(rx_urb);\n\t}\n\n\tif (rx_urb_cnt == 0) {\n\t\tnetdev_warn(netdev, \"%s: submit rx urb failed: %pe\\n\",\n\t\t\t    __func__, ERR_PTR(ret));\n\n\t\tgoto error;\n\t}\n\n\tint_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!int_urb) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tint_data = kmalloc(sizeof(*int_data), GFP_KERNEL);\n\tif (!int_data) {\n\t\tusb_free_urb(int_urb);\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tusb_fill_int_urb(int_urb, priv->dev,\n\t\t\t usb_rcvintpipe(priv->dev, int_in_addr[id]), int_data,\n\t\t\t sizeof(*int_data), f81604_read_int_callback, netdev,\n\t\t\t 1);\n\n\tint_urb->transfer_flags |= URB_FREE_BUFFER;\n\tusb_anchor_urb(int_urb, &priv->urbs_anchor);\n\n\tret = usb_submit_urb(int_urb, GFP_KERNEL);\n\tif (ret) {\n\t\tusb_unanchor_urb(int_urb);\n\t\tusb_free_urb(int_urb);\n\n\t\tnetdev_warn(netdev, \"%s: submit int urb failed: %pe\\n\",\n\t\t\t    __func__, ERR_PTR(ret));\n\t\tgoto error;\n\t}\n\n\t \n\tusb_free_urb(int_urb);\n\n\treturn 0;\n\nerror:\n\tf81604_unregister_urbs(priv);\n\treturn ret;\n}\n\nstatic int f81604_start(struct net_device *netdev)\n{\n\tstruct f81604_port_priv *priv = netdev_priv(netdev);\n\tint ret;\n\tu8 mode;\n\tu8 tmp;\n\n\tmode = F81604_RX_AUTO_RELEASE_BUF | F81604_INT_WHEN_CHANGE;\n\n\t \n\tif (priv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)\n\t\tmode |= F81604_TX_ONESHOT;\n\telse\n\t\tmode |= F81604_TX_NORMAL;\n\n\tret = f81604_sja1000_write(priv, F81604_CTRL_MODE_REG, mode);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = f81604_set_reset_mode(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = f81604_chipset_init(priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = f81604_sja1000_write(priv, F81604_SJA1000_TXERR, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = f81604_sja1000_write(priv, F81604_SJA1000_RXERR, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = f81604_sja1000_read(priv, F81604_SJA1000_ECC, &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = f81604_sja1000_read(priv, F81604_SJA1000_ALC, &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = f81604_sja1000_read(priv, F81604_SJA1000_IR, &tmp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = f81604_register_urbs(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tret = f81604_set_normal_mode(priv);\n\tif (ret) {\n\t\tf81604_unregister_urbs(priv);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int f81604_set_bittiming(struct net_device *dev)\n{\n\tstruct f81604_port_priv *priv = netdev_priv(dev);\n\tstruct can_bittiming *bt = &priv->can.bittiming;\n\tu8 btr0, btr1;\n\tint ret;\n\n\tbtr0 = FIELD_PREP(F81604_BRP_MASK, bt->brp - 1) |\n\t       FIELD_PREP(F81604_SJW_MASK, bt->sjw - 1);\n\n\tbtr1 = FIELD_PREP(F81604_SEG1_MASK,\n\t\t\t  bt->prop_seg + bt->phase_seg1 - 1) |\n\t       FIELD_PREP(F81604_SEG2_MASK, bt->phase_seg2 - 1);\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\tbtr1 |= F81604_SJA1000_BTR1_SAMPLE_TRIPLE;\n\n\tret = f81604_sja1000_write(priv, F81604_SJA1000_BTR0, btr0);\n\tif (ret) {\n\t\tnetdev_warn(dev, \"%s: Set BTR0 failed: %pe\\n\", __func__,\n\t\t\t    ERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\tret = f81604_sja1000_write(priv, F81604_SJA1000_BTR1, btr1);\n\tif (ret) {\n\t\tnetdev_warn(dev, \"%s: Set BTR1 failed: %pe\\n\", __func__,\n\t\t\t    ERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int f81604_set_mode(struct net_device *netdev, enum can_mode mode)\n{\n\tint ret;\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\tret = f81604_start(netdev);\n\t\tif (!ret && netif_queue_stopped(netdev))\n\t\t\tnetif_wake_queue(netdev);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstatic void f81604_write_bulk_callback(struct urb *urb)\n{\n\tstruct net_device *netdev = urb->context;\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"%s: Tx URB error: %pe\\n\", __func__,\n\t\t\t    ERR_PTR(urb->status));\n}\n\nstatic void f81604_clear_reg_work(struct work_struct *work)\n{\n\tstruct f81604_port_priv *priv;\n\tu8 tmp;\n\n\tpriv = container_of(work, struct f81604_port_priv, clear_reg_work);\n\n\t \n\tif (test_and_clear_bit(F81604_CLEAR_ALC, &priv->clear_flags))\n\t\tf81604_sja1000_read(priv, F81604_SJA1000_ALC, &tmp);\n\n\t \n\tif (test_and_clear_bit(F81604_CLEAR_ECC, &priv->clear_flags))\n\t\tf81604_sja1000_read(priv, F81604_SJA1000_ECC, &tmp);\n\n\t \n\tif (test_and_clear_bit(F81604_CLEAR_OVERRUN, &priv->clear_flags))\n\t\tf81604_sja1000_write(priv, F81604_SJA1000_CMR,\n\t\t\t\t     F81604_SJA1000_CMD_CDO);\n}\n\nstatic netdev_tx_t f81604_start_xmit(struct sk_buff *skb,\n\t\t\t\t     struct net_device *netdev)\n{\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct f81604_port_priv *priv = netdev_priv(netdev);\n\tstruct net_device_stats *stats = &netdev->stats;\n\tstruct f81604_can_frame *frame;\n\tstruct urb *write_urb;\n\tint ret;\n\n\tif (can_dev_dropped_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tnetif_stop_queue(netdev);\n\n\twrite_urb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!write_urb)\n\t\tgoto nomem_urb;\n\n\tframe = kzalloc(sizeof(*frame), GFP_ATOMIC);\n\tif (!frame)\n\t\tgoto nomem_buf;\n\n\tusb_fill_bulk_urb(write_urb, priv->dev,\n\t\t\t  usb_sndbulkpipe(priv->dev,\n\t\t\t\t\t  bulk_out_addr[netdev->dev_port]),\n\t\t\t  frame, sizeof(*frame), f81604_write_bulk_callback,\n\t\t\t  priv->netdev);\n\n\twrite_urb->transfer_flags |= URB_FREE_BUFFER;\n\n\tframe->cmd = F81604_CMD_DATA;\n\tframe->dlc = cf->len;\n\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tframe->dlc |= F81604_DLC_RTR_BIT;\n\n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\tu32 id = (cf->can_id & CAN_EFF_MASK) << F81604_EFF_SHIFT;\n\n\t\tput_unaligned_be32(id, &frame->eff.id);\n\n\t\tframe->dlc |= F81604_DLC_EFF_BIT;\n\n\t\tif (!(cf->can_id & CAN_RTR_FLAG))\n\t\t\tmemcpy(&frame->eff.data, cf->data, cf->len);\n\t} else {\n\t\tu32 id = (cf->can_id & CAN_SFF_MASK) << F81604_SFF_SHIFT;\n\n\t\tput_unaligned_be16(id, &frame->sff.id);\n\n\t\tif (!(cf->can_id & CAN_RTR_FLAG))\n\t\t\tmemcpy(&frame->sff.data, cf->data, cf->len);\n\t}\n\n\tcan_put_echo_skb(skb, netdev, 0, 0);\n\n\tret = usb_submit_urb(write_urb, GFP_ATOMIC);\n\tif (ret) {\n\t\tnetdev_err(netdev, \"%s: failed to resubmit tx bulk urb: %pe\\n\",\n\t\t\t   __func__, ERR_PTR(ret));\n\n\t\tcan_free_echo_skb(netdev, 0, NULL);\n\t\tstats->tx_dropped++;\n\t\tstats->tx_errors++;\n\n\t\tif (ret == -ENODEV)\n\t\t\tnetif_device_detach(netdev);\n\t\telse\n\t\t\tnetif_wake_queue(netdev);\n\t}\n\n\t \n\tusb_free_urb(write_urb);\n\n\treturn NETDEV_TX_OK;\n\nnomem_buf:\n\tusb_free_urb(write_urb);\n\nnomem_urb:\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\tstats->tx_errors++;\n\tnetif_wake_queue(netdev);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int f81604_get_berr_counter(const struct net_device *netdev,\n\t\t\t\t   struct can_berr_counter *bec)\n{\n\tstruct f81604_port_priv *priv = netdev_priv(netdev);\n\tu8 txerr, rxerr;\n\tint ret;\n\n\tret = f81604_sja1000_read(priv, F81604_SJA1000_TXERR, &txerr);\n\tif (ret)\n\t\treturn ret;\n\n\tret = f81604_sja1000_read(priv, F81604_SJA1000_RXERR, &rxerr);\n\tif (ret)\n\t\treturn ret;\n\n\tbec->txerr = txerr;\n\tbec->rxerr = rxerr;\n\n\treturn 0;\n}\n\n \nstatic int f81604_open(struct net_device *netdev)\n{\n\tint ret;\n\n\tret = open_candev(netdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = f81604_start(netdev);\n\tif (ret) {\n\t\tif (ret == -ENODEV)\n\t\t\tnetif_device_detach(netdev);\n\n\t\tclose_candev(netdev);\n\t\treturn ret;\n\t}\n\n\tnetif_start_queue(netdev);\n\treturn 0;\n}\n\n \nstatic int f81604_close(struct net_device *netdev)\n{\n\tstruct f81604_port_priv *priv = netdev_priv(netdev);\n\n\tf81604_set_reset_mode(priv);\n\n\tnetif_stop_queue(netdev);\n\tcancel_work_sync(&priv->clear_reg_work);\n\tclose_candev(netdev);\n\n\tf81604_unregister_urbs(priv);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops f81604_netdev_ops = {\n\t.ndo_open = f81604_open,\n\t.ndo_stop = f81604_close,\n\t.ndo_start_xmit = f81604_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic const struct can_bittiming_const f81604_bittiming_const = {\n\t.name = KBUILD_MODNAME,\n\t.tseg1_min = 1,\n\t.tseg1_max = 16,\n\t.tseg2_min = 1,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 64,\n\t.brp_inc = 1,\n};\n\n \nstatic void f81604_disconnect(struct usb_interface *intf)\n{\n\tstruct f81604_priv *priv = usb_get_intfdata(intf);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->netdev); ++i) {\n\t\tif (!priv->netdev[i])\n\t\t\tcontinue;\n\n\t\tunregister_netdev(priv->netdev[i]);\n\t\tfree_candev(priv->netdev[i]);\n\t}\n}\n\nstatic int __f81604_set_termination(struct usb_device *dev, int idx, u16 term)\n{\n\tu8 mask, data = 0;\n\n\tif (idx == 0)\n\t\tmask = F81604_CAN0_TERM;\n\telse\n\t\tmask = F81604_CAN1_TERM;\n\n\tif (term)\n\t\tdata = mask;\n\n\treturn f81604_update_bits(dev, F81604_TERMINATOR_REG, mask, data);\n}\n\nstatic int f81604_set_termination(struct net_device *netdev, u16 term)\n{\n\tstruct f81604_port_priv *port_priv = netdev_priv(netdev);\n\n\tASSERT_RTNL();\n\n\treturn __f81604_set_termination(port_priv->dev, netdev->dev_port,\n\t\t\t\t\tterm);\n}\n\nstatic int f81604_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct net_device *netdev;\n\tstruct f81604_priv *priv;\n\tint i, ret;\n\n\tpriv = devm_kzalloc(&intf->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tusb_set_intfdata(intf, priv);\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->netdev); ++i) {\n\t\tret = __f81604_set_termination(dev, i, 0);\n\t\tif (ret) {\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"Setting termination of CH#%d failed: %pe\\n\",\n\t\t\t\ti, ERR_PTR(ret));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->netdev); ++i) {\n\t\tstruct f81604_port_priv *port_priv;\n\n\t\tnetdev = alloc_candev(sizeof(*port_priv), 1);\n\t\tif (!netdev) {\n\t\t\tdev_err(&intf->dev, \"Couldn't alloc candev: %d\\n\", i);\n\t\t\tret = -ENOMEM;\n\n\t\t\tgoto failure_cleanup;\n\t\t}\n\n\t\tport_priv = netdev_priv(netdev);\n\n\t\tINIT_WORK(&port_priv->clear_reg_work, f81604_clear_reg_work);\n\t\tinit_usb_anchor(&port_priv->urbs_anchor);\n\n\t\tport_priv->intf = intf;\n\t\tport_priv->dev = dev;\n\t\tport_priv->netdev = netdev;\n\t\tport_priv->can.clock.freq = F81604_CAN_CLOCK;\n\n\t\tport_priv->can.termination_const = f81604_termination;\n\t\tport_priv->can.termination_const_cnt =\n\t\t\tARRAY_SIZE(f81604_termination);\n\t\tport_priv->can.bittiming_const = &f81604_bittiming_const;\n\t\tport_priv->can.do_set_bittiming = f81604_set_bittiming;\n\t\tport_priv->can.do_set_mode = f81604_set_mode;\n\t\tport_priv->can.do_set_termination = f81604_set_termination;\n\t\tport_priv->can.do_get_berr_counter = f81604_get_berr_counter;\n\t\tport_priv->can.ctrlmode_supported =\n\t\t\tCAN_CTRLMODE_LISTENONLY | CAN_CTRLMODE_3_SAMPLES |\n\t\t\tCAN_CTRLMODE_ONE_SHOT | CAN_CTRLMODE_BERR_REPORTING |\n\t\t\tCAN_CTRLMODE_PRESUME_ACK;\n\n\t\tnetdev->ethtool_ops = &f81604_ethtool_ops;\n\t\tnetdev->netdev_ops = &f81604_netdev_ops;\n\t\tnetdev->flags |= IFF_ECHO;\n\t\tnetdev->dev_port = i;\n\n\t\tSET_NETDEV_DEV(netdev, &intf->dev);\n\n\t\tret = register_candev(netdev);\n\t\tif (ret) {\n\t\t\tnetdev_err(netdev, \"register CAN device failed: %pe\\n\",\n\t\t\t\t   ERR_PTR(ret));\n\t\t\tfree_candev(netdev);\n\n\t\t\tgoto failure_cleanup;\n\t\t}\n\n\t\tpriv->netdev[i] = netdev;\n\t}\n\n\treturn 0;\n\nfailure_cleanup:\n\tf81604_disconnect(intf);\n\treturn ret;\n}\n\nstatic struct usb_driver f81604_driver = {\n\t.name = KBUILD_MODNAME,\n\t.probe = f81604_probe,\n\t.disconnect = f81604_disconnect,\n\t.id_table = f81604_table,\n};\n\nmodule_usb_driver(f81604_driver);\n\nMODULE_AUTHOR(\"Ji-Ze Hong (Peter Hong) <peter_hong@fintek.com.tw>\");\nMODULE_DESCRIPTION(\"Fintek F81604 USB to 2xCANBUS\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}