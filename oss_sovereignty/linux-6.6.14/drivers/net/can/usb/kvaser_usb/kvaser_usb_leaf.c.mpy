{
  "module_name": "kvaser_usb_leaf.c",
  "hash_id": "c928a9c0e029493afdf3d1b8d52a7c306a9fc51ce35faaf5a3bcd42c9caf9744",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/usb/kvaser_usb/kvaser_usb_leaf.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/gfp.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/units.h>\n#include <linux/usb.h>\n#include <linux/workqueue.h>\n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n#include <linux/can/netlink.h>\n\n#include \"kvaser_usb.h\"\n\n#define MAX_USBCAN_NET_DEVICES\t\t2\n\n \n#define CMD_HEADER_LEN\t\t\t2\n\n \n#define MSG_FLAG_ERROR_FRAME\t\tBIT(0)\n#define MSG_FLAG_OVERRUN\t\tBIT(1)\n#define MSG_FLAG_NERR\t\t\tBIT(2)\n#define MSG_FLAG_WAKEUP\t\t\tBIT(3)\n#define MSG_FLAG_REMOTE_FRAME\t\tBIT(4)\n#define MSG_FLAG_RESERVED\t\tBIT(5)\n#define MSG_FLAG_TX_ACK\t\t\tBIT(6)\n#define MSG_FLAG_TX_REQUEST\t\tBIT(7)\n\n \n#define M16C_STATE_BUS_RESET\t\tBIT(0)\n#define M16C_STATE_BUS_ERROR\t\tBIT(4)\n#define M16C_STATE_BUS_PASSIVE\t\tBIT(5)\n#define M16C_STATE_BUS_OFF\t\tBIT(6)\n\n \n#define CMD_RX_STD_MESSAGE\t\t12\n#define CMD_TX_STD_MESSAGE\t\t13\n#define CMD_RX_EXT_MESSAGE\t\t14\n#define CMD_TX_EXT_MESSAGE\t\t15\n#define CMD_SET_BUS_PARAMS\t\t16\n#define CMD_GET_BUS_PARAMS\t\t17\n#define CMD_GET_BUS_PARAMS_REPLY\t18\n#define CMD_GET_CHIP_STATE\t\t19\n#define CMD_CHIP_STATE_EVENT\t\t20\n#define CMD_SET_CTRL_MODE\t\t21\n#define CMD_RESET_CHIP\t\t\t24\n#define CMD_START_CHIP\t\t\t26\n#define CMD_START_CHIP_REPLY\t\t27\n#define CMD_STOP_CHIP\t\t\t28\n#define CMD_STOP_CHIP_REPLY\t\t29\n\n#define CMD_USBCAN_CLOCK_OVERFLOW_EVENT\t33\n\n#define CMD_GET_CARD_INFO\t\t34\n#define CMD_GET_CARD_INFO_REPLY\t\t35\n#define CMD_GET_SOFTWARE_INFO\t\t38\n#define CMD_GET_SOFTWARE_INFO_REPLY\t39\n#define CMD_ERROR_EVENT\t\t\t45\n#define CMD_FLUSH_QUEUE\t\t\t48\n#define CMD_TX_ACKNOWLEDGE\t\t50\n#define CMD_CAN_ERROR_EVENT\t\t51\n#define CMD_FLUSH_QUEUE_REPLY\t\t68\n#define CMD_GET_CAPABILITIES_REQ\t95\n#define CMD_GET_CAPABILITIES_RESP\t96\n\n#define CMD_LEAF_LOG_MESSAGE\t\t106\n\n \n#define KVASER_USB_LEAF_SWOPTION_FREQ_MASK 0x60\n#define KVASER_USB_LEAF_SWOPTION_FREQ_16_MHZ_CLK 0\n#define KVASER_USB_LEAF_SWOPTION_FREQ_32_MHZ_CLK BIT(5)\n#define KVASER_USB_LEAF_SWOPTION_FREQ_24_MHZ_CLK BIT(6)\n\n#define KVASER_USB_LEAF_SWOPTION_EXT_CAP BIT(12)\n\n \n#define M16C_EF_ACKE\t\t\tBIT(0)\n#define M16C_EF_CRCE\t\t\tBIT(1)\n#define M16C_EF_FORME\t\t\tBIT(2)\n#define M16C_EF_STFE\t\t\tBIT(3)\n#define M16C_EF_BITE0\t\t\tBIT(4)\n#define M16C_EF_BITE1\t\t\tBIT(5)\n#define M16C_EF_RCVE\t\t\tBIT(6)\n#define M16C_EF_TRE\t\t\tBIT(7)\n\n \n#define USBCAN_ERROR_STATE_NONE\t\t0\n#define USBCAN_ERROR_STATE_TX_ERROR\tBIT(0)\n#define USBCAN_ERROR_STATE_RX_ERROR\tBIT(1)\n#define USBCAN_ERROR_STATE_BUSERROR\tBIT(2)\n\n \n#define KVASER_CTRL_MODE_NORMAL\t\t1\n#define KVASER_CTRL_MODE_SILENT\t\t2\n#define KVASER_CTRL_MODE_SELFRECEPTION\t3\n#define KVASER_CTRL_MODE_OFF\t\t4\n\n \n#define KVASER_EXTENDED_FRAME\t\tBIT(31)\n\nstruct kvaser_cmd_simple {\n\tu8 tid;\n\tu8 channel;\n} __packed;\n\nstruct kvaser_cmd_cardinfo {\n\tu8 tid;\n\tu8 nchannels;\n\t__le32 serial_number;\n\t__le32 padding0;\n\t__le32 clock_resolution;\n\t__le32 mfgdate;\n\tu8 ean[8];\n\tu8 hw_revision;\n\tunion {\n\t\tstruct {\n\t\t\tu8 usb_hs_mode;\n\t\t} __packed leaf1;\n\t\tstruct {\n\t\t\tu8 padding;\n\t\t} __packed usbcan1;\n\t} __packed;\n\t__le16 padding1;\n} __packed;\n\nstruct leaf_cmd_softinfo {\n\tu8 tid;\n\tu8 padding0;\n\t__le32 sw_options;\n\t__le32 fw_version;\n\t__le16 max_outstanding_tx;\n\t__le16 padding1[9];\n} __packed;\n\nstruct usbcan_cmd_softinfo {\n\tu8 tid;\n\tu8 fw_name[5];\n\t__le16 max_outstanding_tx;\n\tu8 padding[6];\n\t__le32 fw_version;\n\t__le16 checksum;\n\t__le16 sw_options;\n} __packed;\n\nstruct kvaser_cmd_busparams {\n\tu8 tid;\n\tu8 channel;\n\tstruct kvaser_usb_busparams busparams;\n} __packed;\n\nstruct kvaser_cmd_tx_can {\n\tu8 channel;\n\tu8 tid;\n\tu8 data[14];\n\tunion {\n\t\tstruct {\n\t\t\tu8 padding;\n\t\t\tu8 flags;\n\t\t} __packed leaf;\n\t\tstruct {\n\t\t\tu8 flags;\n\t\t\tu8 padding;\n\t\t} __packed usbcan;\n\t} __packed;\n} __packed;\n\nstruct kvaser_cmd_rx_can_header {\n\tu8 channel;\n\tu8 flag;\n} __packed;\n\nstruct leaf_cmd_rx_can {\n\tu8 channel;\n\tu8 flag;\n\n\t__le16 time[3];\n\tu8 data[14];\n} __packed;\n\nstruct usbcan_cmd_rx_can {\n\tu8 channel;\n\tu8 flag;\n\n\tu8 data[14];\n\t__le16 time;\n} __packed;\n\nstruct leaf_cmd_chip_state_event {\n\tu8 tid;\n\tu8 channel;\n\n\t__le16 time[3];\n\tu8 tx_errors_count;\n\tu8 rx_errors_count;\n\n\tu8 status;\n\tu8 padding[3];\n} __packed;\n\nstruct usbcan_cmd_chip_state_event {\n\tu8 tid;\n\tu8 channel;\n\n\tu8 tx_errors_count;\n\tu8 rx_errors_count;\n\t__le16 time;\n\n\tu8 status;\n\tu8 padding[3];\n} __packed;\n\nstruct kvaser_cmd_tx_acknowledge_header {\n\tu8 channel;\n\tu8 tid;\n} __packed;\n\nstruct leaf_cmd_can_error_event {\n\tu8 tid;\n\tu8 flags;\n\t__le16 time[3];\n\tu8 channel;\n\tu8 padding;\n\tu8 tx_errors_count;\n\tu8 rx_errors_count;\n\tu8 status;\n\tu8 error_factor;\n} __packed;\n\nstruct usbcan_cmd_can_error_event {\n\tu8 tid;\n\tu8 padding;\n\tu8 tx_errors_count_ch0;\n\tu8 rx_errors_count_ch0;\n\tu8 tx_errors_count_ch1;\n\tu8 rx_errors_count_ch1;\n\tu8 status_ch0;\n\tu8 status_ch1;\n\t__le16 time;\n} __packed;\n\n \n#define KVASER_USB_LEAF_ERROR_EVENT_TX_QUEUE_FULL 0x8\n#define KVASER_USB_LEAF_ERROR_EVENT_PARAM 0x9\n\nstruct leaf_cmd_error_event {\n\tu8 tid;\n\tu8 error_code;\n\t__le16 timestamp[3];\n\t__le16 padding;\n\t__le16 info1;\n\t__le16 info2;\n} __packed;\n\nstruct usbcan_cmd_error_event {\n\tu8 tid;\n\tu8 error_code;\n\t__le16 info1;\n\t__le16 info2;\n\t__le16 timestamp;\n\t__le16 padding;\n} __packed;\n\nstruct kvaser_cmd_ctrl_mode {\n\tu8 tid;\n\tu8 channel;\n\tu8 ctrl_mode;\n\tu8 padding[3];\n} __packed;\n\nstruct kvaser_cmd_flush_queue {\n\tu8 tid;\n\tu8 channel;\n\tu8 flags;\n\tu8 padding[3];\n} __packed;\n\nstruct leaf_cmd_log_message {\n\tu8 channel;\n\tu8 flags;\n\t__le16 time[3];\n\tu8 dlc;\n\tu8 time_offset;\n\t__le32 id;\n\tu8 data[8];\n} __packed;\n\n \n#define KVASER_USB_LEAF_CAP_CMD_LISTEN_MODE 0x02\n#define KVASER_USB_LEAF_CAP_CMD_ERR_REPORT 0x05\nstruct kvaser_cmd_cap_req {\n\t__le16 padding0;\n\t__le16 cap_cmd;\n\t__le16 padding1;\n\t__le16 channel;\n} __packed;\n\n \n#define KVASER_USB_LEAF_CAP_STAT_OK 0x00\n#define KVASER_USB_LEAF_CAP_STAT_NOT_IMPL 0x01\n#define KVASER_USB_LEAF_CAP_STAT_UNAVAIL 0x02\nstruct kvaser_cmd_cap_res {\n\t__le16 padding;\n\t__le16 cap_cmd;\n\t__le16 status;\n\t__le32 mask;\n\t__le32 value;\n} __packed;\n\nstruct kvaser_cmd {\n\tu8 len;\n\tu8 id;\n\tunion\t{\n\t\tstruct kvaser_cmd_simple simple;\n\t\tstruct kvaser_cmd_cardinfo cardinfo;\n\t\tstruct kvaser_cmd_busparams busparams;\n\n\t\tstruct kvaser_cmd_rx_can_header rx_can_header;\n\t\tstruct kvaser_cmd_tx_acknowledge_header tx_acknowledge_header;\n\n\t\tunion {\n\t\t\tstruct leaf_cmd_softinfo softinfo;\n\t\t\tstruct leaf_cmd_rx_can rx_can;\n\t\t\tstruct leaf_cmd_chip_state_event chip_state_event;\n\t\t\tstruct leaf_cmd_can_error_event can_error_event;\n\t\t\tstruct leaf_cmd_log_message log_message;\n\t\t\tstruct leaf_cmd_error_event error_event;\n\t\t\tstruct kvaser_cmd_cap_req cap_req;\n\t\t\tstruct kvaser_cmd_cap_res cap_res;\n\t\t} __packed leaf;\n\n\t\tunion {\n\t\t\tstruct usbcan_cmd_softinfo softinfo;\n\t\t\tstruct usbcan_cmd_rx_can rx_can;\n\t\t\tstruct usbcan_cmd_chip_state_event chip_state_event;\n\t\t\tstruct usbcan_cmd_can_error_event can_error_event;\n\t\t\tstruct usbcan_cmd_error_event error_event;\n\t\t} __packed usbcan;\n\n\t\tstruct kvaser_cmd_tx_can tx_can;\n\t\tstruct kvaser_cmd_ctrl_mode ctrl_mode;\n\t\tstruct kvaser_cmd_flush_queue flush_queue;\n\t} u;\n} __packed;\n\n#define CMD_SIZE_ANY 0xff\n#define kvaser_fsize(field) sizeof_field(struct kvaser_cmd, field)\n\nstatic const u8 kvaser_usb_leaf_cmd_sizes_leaf[] = {\n\t[CMD_START_CHIP_REPLY]\t\t= kvaser_fsize(u.simple),\n\t[CMD_STOP_CHIP_REPLY]\t\t= kvaser_fsize(u.simple),\n\t[CMD_GET_CARD_INFO_REPLY]\t= kvaser_fsize(u.cardinfo),\n\t[CMD_TX_ACKNOWLEDGE]\t\t= kvaser_fsize(u.tx_acknowledge_header),\n\t[CMD_GET_SOFTWARE_INFO_REPLY]\t= kvaser_fsize(u.leaf.softinfo),\n\t[CMD_RX_STD_MESSAGE]\t\t= kvaser_fsize(u.leaf.rx_can),\n\t[CMD_RX_EXT_MESSAGE]\t\t= kvaser_fsize(u.leaf.rx_can),\n\t[CMD_LEAF_LOG_MESSAGE]\t\t= kvaser_fsize(u.leaf.log_message),\n\t[CMD_CHIP_STATE_EVENT]\t\t= kvaser_fsize(u.leaf.chip_state_event),\n\t[CMD_CAN_ERROR_EVENT]\t\t= kvaser_fsize(u.leaf.can_error_event),\n\t[CMD_GET_CAPABILITIES_RESP]\t= kvaser_fsize(u.leaf.cap_res),\n\t[CMD_GET_BUS_PARAMS_REPLY]\t= kvaser_fsize(u.busparams),\n\t[CMD_ERROR_EVENT]\t\t= kvaser_fsize(u.leaf.error_event),\n\t \n\t[CMD_FLUSH_QUEUE_REPLY]\t\t= CMD_SIZE_ANY,\n};\n\nstatic const u8 kvaser_usb_leaf_cmd_sizes_usbcan[] = {\n\t[CMD_START_CHIP_REPLY]\t\t= kvaser_fsize(u.simple),\n\t[CMD_STOP_CHIP_REPLY]\t\t= kvaser_fsize(u.simple),\n\t[CMD_GET_CARD_INFO_REPLY]\t= kvaser_fsize(u.cardinfo),\n\t[CMD_TX_ACKNOWLEDGE]\t\t= kvaser_fsize(u.tx_acknowledge_header),\n\t[CMD_GET_SOFTWARE_INFO_REPLY]\t= kvaser_fsize(u.usbcan.softinfo),\n\t[CMD_RX_STD_MESSAGE]\t\t= kvaser_fsize(u.usbcan.rx_can),\n\t[CMD_RX_EXT_MESSAGE]\t\t= kvaser_fsize(u.usbcan.rx_can),\n\t[CMD_CHIP_STATE_EVENT]\t\t= kvaser_fsize(u.usbcan.chip_state_event),\n\t[CMD_CAN_ERROR_EVENT]\t\t= kvaser_fsize(u.usbcan.can_error_event),\n\t[CMD_ERROR_EVENT]\t\t= kvaser_fsize(u.usbcan.error_event),\n\t \n\t[CMD_USBCAN_CLOCK_OVERFLOW_EVENT] = CMD_SIZE_ANY,\n};\n\n \nstruct kvaser_usb_err_summary {\n\tu8 channel, status, txerr, rxerr;\n\tunion {\n\t\tstruct {\n\t\t\tu8 error_factor;\n\t\t} leaf;\n\t\tstruct {\n\t\t\tu8 other_ch_status;\n\t\t\tu8 error_state;\n\t\t} usbcan;\n\t};\n};\n\nstruct kvaser_usb_net_leaf_priv {\n\tstruct kvaser_usb_net_priv *net;\n\n\tstruct delayed_work chip_state_req_work;\n\n\t \n\tbool joining_bus;\n};\n\nstatic const struct can_bittiming_const kvaser_usb_leaf_m16c_bittiming_const = {\n\t.name = \"kvaser_usb_ucii\",\n\t.tseg1_min = 4,\n\t.tseg1_max = 16,\n\t.tseg2_min = 2,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 16,\n\t.brp_inc = 1,\n};\n\nstatic const struct can_bittiming_const kvaser_usb_leaf_m32c_bittiming_const = {\n\t.name = \"kvaser_usb_leaf\",\n\t.tseg1_min = 3,\n\t.tseg1_max = 16,\n\t.tseg2_min = 2,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 2,\n\t.brp_max = 128,\n\t.brp_inc = 2,\n};\n\nstatic const struct kvaser_usb_dev_cfg kvaser_usb_leaf_usbcan_dev_cfg = {\n\t.clock = {\n\t\t.freq = 8 * MEGA  ,\n\t},\n\t.timestamp_freq = 1,\n\t.bittiming_const = &kvaser_usb_leaf_m16c_bittiming_const,\n};\n\nstatic const struct kvaser_usb_dev_cfg kvaser_usb_leaf_m32c_dev_cfg = {\n\t.clock = {\n\t\t.freq = 16 * MEGA  ,\n\t},\n\t.timestamp_freq = 1,\n\t.bittiming_const = &kvaser_usb_leaf_m32c_bittiming_const,\n};\n\nstatic const struct kvaser_usb_dev_cfg kvaser_usb_leaf_imx_dev_cfg_16mhz = {\n\t.clock = {\n\t\t.freq = 16 * MEGA  ,\n\t},\n\t.timestamp_freq = 1,\n\t.bittiming_const = &kvaser_usb_flexc_bittiming_const,\n};\n\nstatic const struct kvaser_usb_dev_cfg kvaser_usb_leaf_imx_dev_cfg_24mhz = {\n\t.clock = {\n\t\t.freq = 24 * MEGA  ,\n\t},\n\t.timestamp_freq = 1,\n\t.bittiming_const = &kvaser_usb_flexc_bittiming_const,\n};\n\nstatic const struct kvaser_usb_dev_cfg kvaser_usb_leaf_imx_dev_cfg_32mhz = {\n\t.clock = {\n\t\t.freq = 32 * MEGA  ,\n\t},\n\t.timestamp_freq = 1,\n\t.bittiming_const = &kvaser_usb_flexc_bittiming_const,\n};\n\nstatic int kvaser_usb_leaf_verify_size(const struct kvaser_usb *dev,\n\t\t\t\t       const struct kvaser_cmd *cmd)\n{\n\t \n\tu8 min_size = 0;\n\n\tswitch (dev->driver_info->family) {\n\tcase KVASER_LEAF:\n\t\tif (cmd->id < ARRAY_SIZE(kvaser_usb_leaf_cmd_sizes_leaf))\n\t\t\tmin_size = kvaser_usb_leaf_cmd_sizes_leaf[cmd->id];\n\t\tbreak;\n\tcase KVASER_USBCAN:\n\t\tif (cmd->id < ARRAY_SIZE(kvaser_usb_leaf_cmd_sizes_usbcan))\n\t\t\tmin_size = kvaser_usb_leaf_cmd_sizes_usbcan[cmd->id];\n\t\tbreak;\n\t}\n\n\tif (min_size == CMD_SIZE_ANY)\n\t\treturn 0;\n\n\tif (min_size) {\n\t\tmin_size += CMD_HEADER_LEN;\n\t\tif (cmd->len >= min_size)\n\t\t\treturn 0;\n\n\t\tdev_err_ratelimited(&dev->intf->dev,\n\t\t\t\t    \"Received command %u too short (size %u, needed %u)\",\n\t\t\t\t    cmd->id, cmd->len, min_size);\n\t\treturn -EIO;\n\t}\n\n\tdev_warn_ratelimited(&dev->intf->dev,\n\t\t\t     \"Unhandled command (%d, size %d)\\n\",\n\t\t\t     cmd->id, cmd->len);\n\treturn -EINVAL;\n}\n\nstatic void *\nkvaser_usb_leaf_frame_to_cmd(const struct kvaser_usb_net_priv *priv,\n\t\t\t     const struct sk_buff *skb, int *cmd_len,\n\t\t\t     u16 transid)\n{\n\tstruct kvaser_usb *dev = priv->dev;\n\tstruct kvaser_cmd *cmd;\n\tu8 *cmd_tx_can_flags = NULL;\t\t \n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\n\tcmd = kmalloc(sizeof(*cmd), GFP_ATOMIC);\n\tif (cmd) {\n\t\tcmd->u.tx_can.tid = transid & 0xff;\n\t\tcmd->len = *cmd_len = CMD_HEADER_LEN +\n\t\t\t\t      sizeof(struct kvaser_cmd_tx_can);\n\t\tcmd->u.tx_can.channel = priv->channel;\n\n\t\tswitch (dev->driver_info->family) {\n\t\tcase KVASER_LEAF:\n\t\t\tcmd_tx_can_flags = &cmd->u.tx_can.leaf.flags;\n\t\t\tbreak;\n\t\tcase KVASER_USBCAN:\n\t\t\tcmd_tx_can_flags = &cmd->u.tx_can.usbcan.flags;\n\t\t\tbreak;\n\t\t}\n\n\t\t*cmd_tx_can_flags = 0;\n\n\t\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\t\tcmd->id = CMD_TX_EXT_MESSAGE;\n\t\t\tcmd->u.tx_can.data[0] = (cf->can_id >> 24) & 0x1f;\n\t\t\tcmd->u.tx_can.data[1] = (cf->can_id >> 18) & 0x3f;\n\t\t\tcmd->u.tx_can.data[2] = (cf->can_id >> 14) & 0x0f;\n\t\t\tcmd->u.tx_can.data[3] = (cf->can_id >> 6) & 0xff;\n\t\t\tcmd->u.tx_can.data[4] = cf->can_id & 0x3f;\n\t\t} else {\n\t\t\tcmd->id = CMD_TX_STD_MESSAGE;\n\t\t\tcmd->u.tx_can.data[0] = (cf->can_id >> 6) & 0x1f;\n\t\t\tcmd->u.tx_can.data[1] = cf->can_id & 0x3f;\n\t\t}\n\n\t\tcmd->u.tx_can.data[5] = can_get_cc_dlc(cf, priv->can.ctrlmode);\n\t\tmemcpy(&cmd->u.tx_can.data[6], cf->data, cf->len);\n\n\t\tif (cf->can_id & CAN_RTR_FLAG)\n\t\t\t*cmd_tx_can_flags |= MSG_FLAG_REMOTE_FRAME;\n\t}\n\treturn cmd;\n}\n\nstatic int kvaser_usb_leaf_wait_cmd(const struct kvaser_usb *dev, u8 id,\n\t\t\t\t    struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_cmd *tmp;\n\tvoid *buf;\n\tint actual_len;\n\tint err;\n\tint pos;\n\tunsigned long to = jiffies + msecs_to_jiffies(KVASER_USB_TIMEOUT);\n\n\tbuf = kzalloc(KVASER_USB_RX_BUFFER_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tdo {\n\t\terr = kvaser_usb_recv_cmd(dev, buf, KVASER_USB_RX_BUFFER_SIZE,\n\t\t\t\t\t  &actual_len);\n\t\tif (err < 0)\n\t\t\tgoto end;\n\n\t\tpos = 0;\n\t\twhile (pos <= actual_len - CMD_HEADER_LEN) {\n\t\t\ttmp = buf + pos;\n\n\t\t\t \n\t\t\tif (tmp->len == 0) {\n\t\t\t\tpos = round_up(pos,\n\t\t\t\t\t       le16_to_cpu\n\t\t\t\t\t\t(dev->bulk_in->wMaxPacketSize));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (pos + tmp->len > actual_len) {\n\t\t\t\tdev_err_ratelimited(&dev->intf->dev,\n\t\t\t\t\t\t    \"Format error\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (tmp->id == id) {\n\t\t\t\tmemcpy(cmd, tmp, tmp->len);\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tpos += tmp->len;\n\t\t}\n\t} while (time_before(jiffies, to));\n\n\terr = -EINVAL;\n\nend:\n\tkfree(buf);\n\n\tif (err == 0)\n\t\terr = kvaser_usb_leaf_verify_size(dev, cmd);\n\n\treturn err;\n}\n\nstatic int kvaser_usb_leaf_send_simple_cmd(const struct kvaser_usb *dev,\n\t\t\t\t\t   u8 cmd_id, int channel)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\n\tcmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->id = cmd_id;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_simple);\n\tcmd->u.simple.channel = channel;\n\tcmd->u.simple.tid = 0xff;\n\n\trc = kvaser_usb_send_cmd(dev, cmd, cmd->len);\n\n\tkfree(cmd);\n\treturn rc;\n}\n\nstatic void kvaser_usb_leaf_get_software_info_leaf(struct kvaser_usb *dev,\n\t\t\t\t\t\t   const struct leaf_cmd_softinfo *softinfo)\n{\n\tu32 sw_options = le32_to_cpu(softinfo->sw_options);\n\n\tdev->fw_version = le32_to_cpu(softinfo->fw_version);\n\tdev->max_tx_urbs = le16_to_cpu(softinfo->max_outstanding_tx);\n\n\tif (sw_options & KVASER_USB_LEAF_SWOPTION_EXT_CAP)\n\t\tdev->card_data.capabilities |= KVASER_USB_CAP_EXT_CAP;\n\n\tif (dev->driver_info->quirks & KVASER_USB_QUIRK_IGNORE_CLK_FREQ) {\n\t\t \n\t\tdev->cfg = &kvaser_usb_leaf_m32c_dev_cfg;\n\t} else {\n\t\tswitch (sw_options & KVASER_USB_LEAF_SWOPTION_FREQ_MASK) {\n\t\tcase KVASER_USB_LEAF_SWOPTION_FREQ_16_MHZ_CLK:\n\t\t\tdev->cfg = &kvaser_usb_leaf_imx_dev_cfg_16mhz;\n\t\t\tbreak;\n\t\tcase KVASER_USB_LEAF_SWOPTION_FREQ_24_MHZ_CLK:\n\t\t\tdev->cfg = &kvaser_usb_leaf_imx_dev_cfg_24mhz;\n\t\t\tbreak;\n\t\tcase KVASER_USB_LEAF_SWOPTION_FREQ_32_MHZ_CLK:\n\t\t\tdev->cfg = &kvaser_usb_leaf_imx_dev_cfg_32mhz;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int kvaser_usb_leaf_get_software_info_inner(struct kvaser_usb *dev)\n{\n\tstruct kvaser_cmd cmd;\n\tint err;\n\n\terr = kvaser_usb_leaf_send_simple_cmd(dev, CMD_GET_SOFTWARE_INFO, 0);\n\tif (err)\n\t\treturn err;\n\n\terr = kvaser_usb_leaf_wait_cmd(dev, CMD_GET_SOFTWARE_INFO_REPLY, &cmd);\n\tif (err)\n\t\treturn err;\n\n\tswitch (dev->driver_info->family) {\n\tcase KVASER_LEAF:\n\t\tkvaser_usb_leaf_get_software_info_leaf(dev, &cmd.u.leaf.softinfo);\n\t\tbreak;\n\tcase KVASER_USBCAN:\n\t\tdev->fw_version = le32_to_cpu(cmd.u.usbcan.softinfo.fw_version);\n\t\tdev->max_tx_urbs =\n\t\t\tle16_to_cpu(cmd.u.usbcan.softinfo.max_outstanding_tx);\n\t\tdev->cfg = &kvaser_usb_leaf_usbcan_dev_cfg;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_leaf_get_software_info(struct kvaser_usb *dev)\n{\n\tint err;\n\tint retry = 3;\n\n\t \n\tdo {\n\t\terr = kvaser_usb_leaf_get_software_info_inner(dev);\n\t} while (--retry && err == -ETIMEDOUT);\n\n\treturn err;\n}\n\nstatic int kvaser_usb_leaf_get_card_info(struct kvaser_usb *dev)\n{\n\tstruct kvaser_cmd cmd;\n\tint err;\n\n\terr = kvaser_usb_leaf_send_simple_cmd(dev, CMD_GET_CARD_INFO, 0);\n\tif (err)\n\t\treturn err;\n\n\terr = kvaser_usb_leaf_wait_cmd(dev, CMD_GET_CARD_INFO_REPLY, &cmd);\n\tif (err)\n\t\treturn err;\n\n\tdev->nchannels = cmd.u.cardinfo.nchannels;\n\tif (dev->nchannels > KVASER_USB_MAX_NET_DEVICES ||\n\t    (dev->driver_info->family == KVASER_USBCAN &&\n\t     dev->nchannels > MAX_USBCAN_NET_DEVICES))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_leaf_get_single_capability(struct kvaser_usb *dev,\n\t\t\t\t\t\t u16 cap_cmd_req, u16 *status)\n{\n\tstruct kvaser_usb_dev_card_data *card_data = &dev->card_data;\n\tstruct kvaser_cmd *cmd;\n\tu32 value = 0;\n\tu32 mask = 0;\n\tu16 cap_cmd_res;\n\tint err;\n\tint i;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->id = CMD_GET_CAPABILITIES_REQ;\n\tcmd->u.leaf.cap_req.cap_cmd = cpu_to_le16(cap_cmd_req);\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_cap_req);\n\n\terr = kvaser_usb_send_cmd(dev, cmd, cmd->len);\n\tif (err)\n\t\tgoto end;\n\n\terr = kvaser_usb_leaf_wait_cmd(dev, CMD_GET_CAPABILITIES_RESP, cmd);\n\tif (err)\n\t\tgoto end;\n\n\t*status = le16_to_cpu(cmd->u.leaf.cap_res.status);\n\n\tif (*status != KVASER_USB_LEAF_CAP_STAT_OK)\n\t\tgoto end;\n\n\tcap_cmd_res = le16_to_cpu(cmd->u.leaf.cap_res.cap_cmd);\n\tswitch (cap_cmd_res) {\n\tcase KVASER_USB_LEAF_CAP_CMD_LISTEN_MODE:\n\tcase KVASER_USB_LEAF_CAP_CMD_ERR_REPORT:\n\t\tvalue = le32_to_cpu(cmd->u.leaf.cap_res.value);\n\t\tmask = le32_to_cpu(cmd->u.leaf.cap_res.mask);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&dev->intf->dev, \"Unknown capability command %u\\n\",\n\t\t\t cap_cmd_res);\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < dev->nchannels; i++) {\n\t\tif (BIT(i) & (value & mask)) {\n\t\t\tswitch (cap_cmd_res) {\n\t\t\tcase KVASER_USB_LEAF_CAP_CMD_LISTEN_MODE:\n\t\t\t\tcard_data->ctrlmode_supported |=\n\t\t\t\t\t\tCAN_CTRLMODE_LISTENONLY;\n\t\t\t\tbreak;\n\t\t\tcase KVASER_USB_LEAF_CAP_CMD_ERR_REPORT:\n\t\t\t\tcard_data->capabilities |=\n\t\t\t\t\t\tKVASER_USB_CAP_BERR_CAP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\nend:\n\tkfree(cmd);\n\n\treturn err;\n}\n\nstatic int kvaser_usb_leaf_get_capabilities_leaf(struct kvaser_usb *dev)\n{\n\tint err;\n\tu16 status;\n\n\tif (!(dev->card_data.capabilities & KVASER_USB_CAP_EXT_CAP)) {\n\t\tdev_info(&dev->intf->dev,\n\t\t\t \"No extended capability support. Upgrade device firmware.\\n\");\n\t\treturn 0;\n\t}\n\n\terr = kvaser_usb_leaf_get_single_capability(dev,\n\t\t\t\t\t\t    KVASER_USB_LEAF_CAP_CMD_LISTEN_MODE,\n\t\t\t\t\t\t    &status);\n\tif (err)\n\t\treturn err;\n\tif (status)\n\t\tdev_info(&dev->intf->dev,\n\t\t\t \"KVASER_USB_LEAF_CAP_CMD_LISTEN_MODE failed %u\\n\",\n\t\t\t status);\n\n\terr = kvaser_usb_leaf_get_single_capability(dev,\n\t\t\t\t\t\t    KVASER_USB_LEAF_CAP_CMD_ERR_REPORT,\n\t\t\t\t\t\t    &status);\n\tif (err)\n\t\treturn err;\n\tif (status)\n\t\tdev_info(&dev->intf->dev,\n\t\t\t \"KVASER_USB_LEAF_CAP_CMD_ERR_REPORT failed %u\\n\",\n\t\t\t status);\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_leaf_get_capabilities(struct kvaser_usb *dev)\n{\n\tint err = 0;\n\n\tif (dev->driver_info->family == KVASER_LEAF)\n\t\terr = kvaser_usb_leaf_get_capabilities_leaf(dev);\n\n\treturn err;\n}\n\nstatic void kvaser_usb_leaf_tx_acknowledge(const struct kvaser_usb *dev,\n\t\t\t\t\t   const struct kvaser_cmd *cmd)\n{\n\tstruct net_device_stats *stats;\n\tstruct kvaser_usb_tx_urb_context *context;\n\tstruct kvaser_usb_net_priv *priv;\n\tunsigned long flags;\n\tu8 channel, tid;\n\n\tchannel = cmd->u.tx_acknowledge_header.channel;\n\ttid = cmd->u.tx_acknowledge_header.tid;\n\n\tif (channel >= dev->nchannels) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"Invalid channel number (%d)\\n\", channel);\n\t\treturn;\n\t}\n\n\tpriv = dev->nets[channel];\n\n\tif (!netif_device_present(priv->netdev))\n\t\treturn;\n\n\tstats = &priv->netdev->stats;\n\n\tcontext = &priv->tx_contexts[tid % dev->max_tx_urbs];\n\n\t \n\tif (priv->can.restart_ms && priv->can.state == CAN_STATE_BUS_OFF) {\n\t\tstruct sk_buff *skb;\n\t\tstruct can_frame *cf;\n\n\t\tskb = alloc_can_err_skb(priv->netdev, &cf);\n\t\tif (skb) {\n\t\t\tcf->can_id |= CAN_ERR_RESTARTED;\n\n\t\t\tnetif_rx(skb);\n\t\t} else {\n\t\t\tnetdev_err(priv->netdev,\n\t\t\t\t   \"No memory left for err_skb\\n\");\n\t\t}\n\n\t\tpriv->can.can_stats.restarts++;\n\t\tnetif_carrier_on(priv->netdev);\n\n\t\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\t}\n\n\tspin_lock_irqsave(&priv->tx_contexts_lock, flags);\n\n\tstats->tx_packets++;\n\tstats->tx_bytes += can_get_echo_skb(priv->netdev,\n\t\t\t\t\t    context->echo_index, NULL);\n\tcontext->echo_index = dev->max_tx_urbs;\n\t--priv->active_tx_contexts;\n\tnetif_wake_queue(priv->netdev);\n\n\tspin_unlock_irqrestore(&priv->tx_contexts_lock, flags);\n}\n\nstatic int kvaser_usb_leaf_simple_cmd_async(struct kvaser_usb_net_priv *priv,\n\t\t\t\t\t    u8 cmd_id)\n{\n\tstruct kvaser_cmd *cmd;\n\tint err;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_ATOMIC);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_simple);\n\tcmd->id = cmd_id;\n\tcmd->u.simple.channel = priv->channel;\n\n\terr = kvaser_usb_send_cmd_async(priv, cmd, cmd->len);\n\tif (err)\n\t\tkfree(cmd);\n\n\treturn err;\n}\n\nstatic void kvaser_usb_leaf_chip_state_req_work(struct work_struct *work)\n{\n\tstruct kvaser_usb_net_leaf_priv *leaf =\n\t\tcontainer_of(work, struct kvaser_usb_net_leaf_priv,\n\t\t\t     chip_state_req_work.work);\n\tstruct kvaser_usb_net_priv *priv = leaf->net;\n\n\tkvaser_usb_leaf_simple_cmd_async(priv, CMD_GET_CHIP_STATE);\n}\n\nstatic void\nkvaser_usb_leaf_rx_error_update_can_state(struct kvaser_usb_net_priv *priv,\n\t\t\t\t\tconst struct kvaser_usb_err_summary *es,\n\t\t\t\t\tstruct can_frame *cf)\n{\n\tstruct kvaser_usb_net_leaf_priv *leaf = priv->sub_priv;\n\tstruct kvaser_usb *dev = priv->dev;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\tenum can_state cur_state, new_state, tx_state, rx_state;\n\n\tnetdev_dbg(priv->netdev, \"Error status: 0x%02x\\n\", es->status);\n\n\tnew_state = priv->can.state;\n\tcur_state = priv->can.state;\n\n\tif (es->status & (M16C_STATE_BUS_OFF | M16C_STATE_BUS_RESET)) {\n\t\tnew_state = CAN_STATE_BUS_OFF;\n\t} else if (es->status & M16C_STATE_BUS_PASSIVE) {\n\t\tnew_state = CAN_STATE_ERROR_PASSIVE;\n\t} else if ((es->status & M16C_STATE_BUS_ERROR) &&\n\t\t   cur_state >= CAN_STATE_BUS_OFF) {\n\t\t \n\t} else if (es->txerr >= 128 || es->rxerr >= 128) {\n\t\tnew_state = CAN_STATE_ERROR_PASSIVE;\n\t} else if (es->txerr >= 96 || es->rxerr >= 96) {\n\t\tnew_state = CAN_STATE_ERROR_WARNING;\n\t} else {\n\t\tnew_state = CAN_STATE_ERROR_ACTIVE;\n\t}\n\n\t \n\tif (leaf->joining_bus) {\n\t\tif (new_state == CAN_STATE_BUS_OFF) {\n\t\t\tnetdev_dbg(priv->netdev, \"ignoring bus-off during startup\");\n\t\t\tnew_state = cur_state;\n\t\t} else {\n\t\t\tleaf->joining_bus = false;\n\t\t}\n\t}\n\n\tif (new_state != cur_state) {\n\t\ttx_state = (es->txerr >= es->rxerr) ? new_state : 0;\n\t\trx_state = (es->txerr <= es->rxerr) ? new_state : 0;\n\n\t\tcan_change_state(priv->netdev, cf, tx_state, rx_state);\n\t}\n\n\tif (priv->can.restart_ms &&\n\t    cur_state == CAN_STATE_BUS_OFF &&\n\t    new_state < CAN_STATE_BUS_OFF)\n\t\tpriv->can.can_stats.restarts++;\n\n\tswitch (dev->driver_info->family) {\n\tcase KVASER_LEAF:\n\t\tif (es->leaf.error_factor) {\n\t\t\tpriv->can.can_stats.bus_error++;\n\t\t\tstats->rx_errors++;\n\t\t}\n\t\tbreak;\n\tcase KVASER_USBCAN:\n\t\tif (es->usbcan.error_state & USBCAN_ERROR_STATE_TX_ERROR)\n\t\t\tstats->tx_errors++;\n\t\tif (es->usbcan.error_state & USBCAN_ERROR_STATE_RX_ERROR)\n\t\t\tstats->rx_errors++;\n\t\tif (es->usbcan.error_state & USBCAN_ERROR_STATE_BUSERROR)\n\t\t\tpriv->can.can_stats.bus_error++;\n\t\tbreak;\n\t}\n\n\tpriv->bec.txerr = es->txerr;\n\tpriv->bec.rxerr = es->rxerr;\n}\n\nstatic void kvaser_usb_leaf_rx_error(const struct kvaser_usb *dev,\n\t\t\t\t     const struct kvaser_usb_err_summary *es)\n{\n\tstruct can_frame *cf;\n\tstruct can_frame tmp_cf = { .can_id = CAN_ERR_FLAG,\n\t\t\t\t    .len = CAN_ERR_DLC };\n\tstruct sk_buff *skb;\n\tstruct net_device_stats *stats;\n\tstruct kvaser_usb_net_priv *priv;\n\tstruct kvaser_usb_net_leaf_priv *leaf;\n\tenum can_state old_state, new_state;\n\n\tif (es->channel >= dev->nchannels) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"Invalid channel number (%d)\\n\", es->channel);\n\t\treturn;\n\t}\n\n\tpriv = dev->nets[es->channel];\n\tleaf = priv->sub_priv;\n\tstats = &priv->netdev->stats;\n\n\t \n\tif (!netif_running(priv->netdev))\n\t\treturn;\n\n\t \n\told_state = priv->can.state;\n\tkvaser_usb_leaf_rx_error_update_can_state(priv, es, &tmp_cf);\n\tnew_state = priv->can.state;\n\n\t \n\tif (new_state < CAN_STATE_BUS_OFF &&\n\t    (es->rxerr || es->txerr || new_state == CAN_STATE_ERROR_PASSIVE ||\n\t     leaf->joining_bus))\n\t\tschedule_delayed_work(&leaf->chip_state_req_work,\n\t\t\t\t      msecs_to_jiffies(500));\n\n\tskb = alloc_can_err_skb(priv->netdev, &cf);\n\tif (!skb) {\n\t\tstats->rx_dropped++;\n\t\treturn;\n\t}\n\tmemcpy(cf, &tmp_cf, sizeof(*cf));\n\n\tif (new_state != old_state) {\n\t\tif (es->status &\n\t\t    (M16C_STATE_BUS_OFF | M16C_STATE_BUS_RESET)) {\n\t\t\tif (!priv->can.restart_ms)\n\t\t\t\tkvaser_usb_leaf_simple_cmd_async(priv,\n\t\t\t\t\t\t\t\t CMD_STOP_CHIP);\n\t\t\tnetif_carrier_off(priv->netdev);\n\t\t}\n\n\t\tif (priv->can.restart_ms &&\n\t\t    old_state == CAN_STATE_BUS_OFF &&\n\t\t    new_state < CAN_STATE_BUS_OFF) {\n\t\t\tcf->can_id |= CAN_ERR_RESTARTED;\n\t\t\tnetif_carrier_on(priv->netdev);\n\t\t}\n\t}\n\n\tswitch (dev->driver_info->family) {\n\tcase KVASER_LEAF:\n\t\tif (es->leaf.error_factor) {\n\t\t\tcf->can_id |= CAN_ERR_BUSERROR | CAN_ERR_PROT;\n\n\t\t\tif (es->leaf.error_factor & M16C_EF_ACKE)\n\t\t\t\tcf->data[3] = CAN_ERR_PROT_LOC_ACK;\n\t\t\tif (es->leaf.error_factor & M16C_EF_CRCE)\n\t\t\t\tcf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;\n\t\t\tif (es->leaf.error_factor & M16C_EF_FORME)\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_FORM;\n\t\t\tif (es->leaf.error_factor & M16C_EF_STFE)\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_STUFF;\n\t\t\tif (es->leaf.error_factor & M16C_EF_BITE0)\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT0;\n\t\t\tif (es->leaf.error_factor & M16C_EF_BITE1)\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT1;\n\t\t\tif (es->leaf.error_factor & M16C_EF_TRE)\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_TX;\n\t\t}\n\t\tbreak;\n\tcase KVASER_USBCAN:\n\t\tif (es->usbcan.error_state & USBCAN_ERROR_STATE_BUSERROR)\n\t\t\tcf->can_id |= CAN_ERR_BUSERROR;\n\t\tbreak;\n\t}\n\n\tif (new_state != CAN_STATE_BUS_OFF) {\n\t\tcf->can_id |= CAN_ERR_CNT;\n\t\tcf->data[6] = es->txerr;\n\t\tcf->data[7] = es->rxerr;\n\t}\n\n\tnetif_rx(skb);\n}\n\n \nstatic void\nkvaser_usb_leaf_usbcan_conditionally_rx_error(const struct kvaser_usb *dev,\n\t\t\t\t\t      struct kvaser_usb_err_summary *es)\n{\n\tstruct kvaser_usb_net_priv *priv;\n\tunsigned int channel;\n\tbool report_error;\n\n\tchannel = es->channel;\n\tif (channel >= dev->nchannels) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"Invalid channel number (%d)\\n\", channel);\n\t\treturn;\n\t}\n\n\tpriv = dev->nets[channel];\n\treport_error = false;\n\n\tif (es->txerr != priv->bec.txerr) {\n\t\tes->usbcan.error_state |= USBCAN_ERROR_STATE_TX_ERROR;\n\t\treport_error = true;\n\t}\n\tif (es->rxerr != priv->bec.rxerr) {\n\t\tes->usbcan.error_state |= USBCAN_ERROR_STATE_RX_ERROR;\n\t\treport_error = true;\n\t}\n\tif ((es->status & M16C_STATE_BUS_ERROR) &&\n\t    !(es->usbcan.other_ch_status & M16C_STATE_BUS_ERROR)) {\n\t\tes->usbcan.error_state |= USBCAN_ERROR_STATE_BUSERROR;\n\t\treport_error = true;\n\t}\n\n\tif (report_error)\n\t\tkvaser_usb_leaf_rx_error(dev, es);\n}\n\nstatic void kvaser_usb_leaf_usbcan_rx_error(const struct kvaser_usb *dev,\n\t\t\t\t\t    const struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_usb_err_summary es = { };\n\n\tswitch (cmd->id) {\n\t \n\tcase CMD_CHIP_STATE_EVENT:\n\t\tes.channel = cmd->u.usbcan.chip_state_event.channel;\n\t\tes.status = cmd->u.usbcan.chip_state_event.status;\n\t\tes.txerr = cmd->u.usbcan.chip_state_event.tx_errors_count;\n\t\tes.rxerr = cmd->u.usbcan.chip_state_event.rx_errors_count;\n\t\tkvaser_usb_leaf_usbcan_conditionally_rx_error(dev, &es);\n\t\tbreak;\n\n\tcase CMD_CAN_ERROR_EVENT:\n\t\tes.channel = 0;\n\t\tes.status = cmd->u.usbcan.can_error_event.status_ch0;\n\t\tes.txerr = cmd->u.usbcan.can_error_event.tx_errors_count_ch0;\n\t\tes.rxerr = cmd->u.usbcan.can_error_event.rx_errors_count_ch0;\n\t\tes.usbcan.other_ch_status =\n\t\t\tcmd->u.usbcan.can_error_event.status_ch1;\n\t\tkvaser_usb_leaf_usbcan_conditionally_rx_error(dev, &es);\n\n\t\t \n\t\tif (dev->nchannels == MAX_USBCAN_NET_DEVICES) {\n\t\t\tes.channel = 1;\n\t\t\tes.status = cmd->u.usbcan.can_error_event.status_ch1;\n\t\t\tes.txerr =\n\t\t\t\tcmd->u.usbcan.can_error_event.tx_errors_count_ch1;\n\t\t\tes.rxerr =\n\t\t\t\tcmd->u.usbcan.can_error_event.rx_errors_count_ch1;\n\t\t\tes.usbcan.other_ch_status =\n\t\t\t\tcmd->u.usbcan.can_error_event.status_ch0;\n\t\t\tkvaser_usb_leaf_usbcan_conditionally_rx_error(dev, &es);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&dev->intf->dev, \"Invalid cmd id (%d)\\n\", cmd->id);\n\t}\n}\n\nstatic void kvaser_usb_leaf_leaf_rx_error(const struct kvaser_usb *dev,\n\t\t\t\t\t  const struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_usb_err_summary es = { };\n\n\tswitch (cmd->id) {\n\tcase CMD_CAN_ERROR_EVENT:\n\t\tes.channel = cmd->u.leaf.can_error_event.channel;\n\t\tes.status = cmd->u.leaf.can_error_event.status;\n\t\tes.txerr = cmd->u.leaf.can_error_event.tx_errors_count;\n\t\tes.rxerr = cmd->u.leaf.can_error_event.rx_errors_count;\n\t\tes.leaf.error_factor = cmd->u.leaf.can_error_event.error_factor;\n\t\tbreak;\n\tcase CMD_LEAF_LOG_MESSAGE:\n\t\tes.channel = cmd->u.leaf.log_message.channel;\n\t\tes.status = cmd->u.leaf.log_message.data[0];\n\t\tes.txerr = cmd->u.leaf.log_message.data[2];\n\t\tes.rxerr = cmd->u.leaf.log_message.data[3];\n\t\tes.leaf.error_factor = cmd->u.leaf.log_message.data[1];\n\t\tbreak;\n\tcase CMD_CHIP_STATE_EVENT:\n\t\tes.channel = cmd->u.leaf.chip_state_event.channel;\n\t\tes.status = cmd->u.leaf.chip_state_event.status;\n\t\tes.txerr = cmd->u.leaf.chip_state_event.tx_errors_count;\n\t\tes.rxerr = cmd->u.leaf.chip_state_event.rx_errors_count;\n\t\tes.leaf.error_factor = 0;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&dev->intf->dev, \"Invalid cmd id (%d)\\n\", cmd->id);\n\t\treturn;\n\t}\n\n\tkvaser_usb_leaf_rx_error(dev, &es);\n}\n\nstatic void kvaser_usb_leaf_rx_can_err(const struct kvaser_usb_net_priv *priv,\n\t\t\t\t       const struct kvaser_cmd *cmd)\n{\n\tif (cmd->u.rx_can_header.flag & (MSG_FLAG_ERROR_FRAME |\n\t\t\t\t\t MSG_FLAG_NERR)) {\n\t\tstruct net_device_stats *stats = &priv->netdev->stats;\n\n\t\tnetdev_err(priv->netdev, \"Unknown error (flags: 0x%02x)\\n\",\n\t\t\t   cmd->u.rx_can_header.flag);\n\n\t\tstats->rx_errors++;\n\t\treturn;\n\t}\n\n\tif (cmd->u.rx_can_header.flag & MSG_FLAG_OVERRUN)\n\t\tkvaser_usb_can_rx_over_error(priv->netdev);\n}\n\nstatic void kvaser_usb_leaf_rx_can_msg(const struct kvaser_usb *dev,\n\t\t\t\t       const struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_usb_net_priv *priv;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tstruct net_device_stats *stats;\n\tu8 channel = cmd->u.rx_can_header.channel;\n\tconst u8 *rx_data = NULL;\t \n\n\tif (channel >= dev->nchannels) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"Invalid channel number (%d)\\n\", channel);\n\t\treturn;\n\t}\n\n\tpriv = dev->nets[channel];\n\tstats = &priv->netdev->stats;\n\n\tif ((cmd->u.rx_can_header.flag & MSG_FLAG_ERROR_FRAME) &&\n\t    (dev->driver_info->family == KVASER_LEAF &&\n\t     cmd->id == CMD_LEAF_LOG_MESSAGE)) {\n\t\tkvaser_usb_leaf_leaf_rx_error(dev, cmd);\n\t\treturn;\n\t} else if (cmd->u.rx_can_header.flag & (MSG_FLAG_ERROR_FRAME |\n\t\t\t\t\t\tMSG_FLAG_NERR |\n\t\t\t\t\t\tMSG_FLAG_OVERRUN)) {\n\t\tkvaser_usb_leaf_rx_can_err(priv, cmd);\n\t\treturn;\n\t} else if (cmd->u.rx_can_header.flag & ~MSG_FLAG_REMOTE_FRAME) {\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"Unhandled frame (flags: 0x%02x)\\n\",\n\t\t\t    cmd->u.rx_can_header.flag);\n\t\treturn;\n\t}\n\n\tswitch (dev->driver_info->family) {\n\tcase KVASER_LEAF:\n\t\trx_data = cmd->u.leaf.rx_can.data;\n\t\tbreak;\n\tcase KVASER_USBCAN:\n\t\trx_data = cmd->u.usbcan.rx_can.data;\n\t\tbreak;\n\t}\n\n\tskb = alloc_can_skb(priv->netdev, &cf);\n\tif (!skb) {\n\t\tstats->rx_dropped++;\n\t\treturn;\n\t}\n\n\tif (dev->driver_info->family == KVASER_LEAF && cmd->id ==\n\t    CMD_LEAF_LOG_MESSAGE) {\n\t\tcf->can_id = le32_to_cpu(cmd->u.leaf.log_message.id);\n\t\tif (cf->can_id & KVASER_EXTENDED_FRAME)\n\t\t\tcf->can_id &= CAN_EFF_MASK | CAN_EFF_FLAG;\n\t\telse\n\t\t\tcf->can_id &= CAN_SFF_MASK;\n\n\t\tcan_frame_set_cc_len(cf, cmd->u.leaf.log_message.dlc & 0xF, priv->can.ctrlmode);\n\n\t\tif (cmd->u.leaf.log_message.flags & MSG_FLAG_REMOTE_FRAME)\n\t\t\tcf->can_id |= CAN_RTR_FLAG;\n\t\telse\n\t\t\tmemcpy(cf->data, &cmd->u.leaf.log_message.data,\n\t\t\t       cf->len);\n\t} else {\n\t\tcf->can_id = ((rx_data[0] & 0x1f) << 6) | (rx_data[1] & 0x3f);\n\n\t\tif (cmd->id == CMD_RX_EXT_MESSAGE) {\n\t\t\tcf->can_id <<= 18;\n\t\t\tcf->can_id |= ((rx_data[2] & 0x0f) << 14) |\n\t\t\t\t      ((rx_data[3] & 0xff) << 6) |\n\t\t\t\t      (rx_data[4] & 0x3f);\n\t\t\tcf->can_id |= CAN_EFF_FLAG;\n\t\t}\n\n\t\tcan_frame_set_cc_len(cf, rx_data[5] & 0xF, priv->can.ctrlmode);\n\n\t\tif (cmd->u.rx_can_header.flag & MSG_FLAG_REMOTE_FRAME)\n\t\t\tcf->can_id |= CAN_RTR_FLAG;\n\t\telse\n\t\t\tmemcpy(cf->data, &rx_data[6], cf->len);\n\t}\n\n\tstats->rx_packets++;\n\tif (!(cf->can_id & CAN_RTR_FLAG))\n\t\tstats->rx_bytes += cf->len;\n\tnetif_rx(skb);\n}\n\nstatic void kvaser_usb_leaf_error_event_parameter(const struct kvaser_usb *dev,\n\t\t\t\t\t\t  const struct kvaser_cmd *cmd)\n{\n\tu16 info1 = 0;\n\n\tswitch (dev->driver_info->family) {\n\tcase KVASER_LEAF:\n\t\tinfo1 = le16_to_cpu(cmd->u.leaf.error_event.info1);\n\t\tbreak;\n\tcase KVASER_USBCAN:\n\t\tinfo1 = le16_to_cpu(cmd->u.usbcan.error_event.info1);\n\t\tbreak;\n\t}\n\n\t \n\tswitch (info1) {\n\tcase CMD_SET_CTRL_MODE:\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"CMD_SET_CTRL_MODE error in parameter\\n\");\n\t\tbreak;\n\n\tcase CMD_SET_BUS_PARAMS:\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"CMD_SET_BUS_PARAMS error in parameter\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"Unhandled parameter error event cmd_no (%u)\\n\",\n\t\t\t info1);\n\t\tbreak;\n\t}\n}\n\nstatic void kvaser_usb_leaf_error_event(const struct kvaser_usb *dev,\n\t\t\t\t\tconst struct kvaser_cmd *cmd)\n{\n\tu8 error_code = 0;\n\n\tswitch (dev->driver_info->family) {\n\tcase KVASER_LEAF:\n\t\terror_code = cmd->u.leaf.error_event.error_code;\n\t\tbreak;\n\tcase KVASER_USBCAN:\n\t\terror_code = cmd->u.usbcan.error_event.error_code;\n\t\tbreak;\n\t}\n\n\tswitch (error_code) {\n\tcase KVASER_USB_LEAF_ERROR_EVENT_TX_QUEUE_FULL:\n\t\t \n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"Received error event TX_QUEUE_FULL\\n\");\n\t\tbreak;\n\tcase KVASER_USB_LEAF_ERROR_EVENT_PARAM:\n\t\tkvaser_usb_leaf_error_event_parameter(dev, cmd);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"Unhandled error event (%d)\\n\", error_code);\n\t\tbreak;\n\t}\n}\n\nstatic void kvaser_usb_leaf_start_chip_reply(const struct kvaser_usb *dev,\n\t\t\t\t\t     const struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_usb_net_priv *priv;\n\tu8 channel = cmd->u.simple.channel;\n\n\tif (channel >= dev->nchannels) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"Invalid channel number (%d)\\n\", channel);\n\t\treturn;\n\t}\n\n\tpriv = dev->nets[channel];\n\n\tif (completion_done(&priv->start_comp) &&\n\t    netif_queue_stopped(priv->netdev)) {\n\t\tnetif_wake_queue(priv->netdev);\n\t} else {\n\t\tnetif_start_queue(priv->netdev);\n\t\tcomplete(&priv->start_comp);\n\t}\n}\n\nstatic void kvaser_usb_leaf_stop_chip_reply(const struct kvaser_usb *dev,\n\t\t\t\t\t    const struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_usb_net_priv *priv;\n\tu8 channel = cmd->u.simple.channel;\n\n\tif (channel >= dev->nchannels) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"Invalid channel number (%d)\\n\", channel);\n\t\treturn;\n\t}\n\n\tpriv = dev->nets[channel];\n\n\tcomplete(&priv->stop_comp);\n}\n\nstatic void kvaser_usb_leaf_get_busparams_reply(const struct kvaser_usb *dev,\n\t\t\t\t\t\tconst struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_usb_net_priv *priv;\n\tu8 channel = cmd->u.busparams.channel;\n\n\tif (channel >= dev->nchannels) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"Invalid channel number (%d)\\n\", channel);\n\t\treturn;\n\t}\n\n\tpriv = dev->nets[channel];\n\tmemcpy(&priv->busparams_nominal, &cmd->u.busparams.busparams,\n\t       sizeof(priv->busparams_nominal));\n\n\tcomplete(&priv->get_busparams_comp);\n}\n\nstatic void kvaser_usb_leaf_handle_command(const struct kvaser_usb *dev,\n\t\t\t\t\t   const struct kvaser_cmd *cmd)\n{\n\tif (kvaser_usb_leaf_verify_size(dev, cmd) < 0)\n\t\treturn;\n\n\tswitch (cmd->id) {\n\tcase CMD_START_CHIP_REPLY:\n\t\tkvaser_usb_leaf_start_chip_reply(dev, cmd);\n\t\tbreak;\n\n\tcase CMD_STOP_CHIP_REPLY:\n\t\tkvaser_usb_leaf_stop_chip_reply(dev, cmd);\n\t\tbreak;\n\n\tcase CMD_RX_STD_MESSAGE:\n\tcase CMD_RX_EXT_MESSAGE:\n\t\tkvaser_usb_leaf_rx_can_msg(dev, cmd);\n\t\tbreak;\n\n\tcase CMD_LEAF_LOG_MESSAGE:\n\t\tif (dev->driver_info->family != KVASER_LEAF)\n\t\t\tgoto warn;\n\t\tkvaser_usb_leaf_rx_can_msg(dev, cmd);\n\t\tbreak;\n\n\tcase CMD_CHIP_STATE_EVENT:\n\tcase CMD_CAN_ERROR_EVENT:\n\t\tif (dev->driver_info->family == KVASER_LEAF)\n\t\t\tkvaser_usb_leaf_leaf_rx_error(dev, cmd);\n\t\telse\n\t\t\tkvaser_usb_leaf_usbcan_rx_error(dev, cmd);\n\t\tbreak;\n\n\tcase CMD_TX_ACKNOWLEDGE:\n\t\tkvaser_usb_leaf_tx_acknowledge(dev, cmd);\n\t\tbreak;\n\n\tcase CMD_ERROR_EVENT:\n\t\tkvaser_usb_leaf_error_event(dev, cmd);\n\t\tbreak;\n\n\tcase CMD_GET_BUS_PARAMS_REPLY:\n\t\tkvaser_usb_leaf_get_busparams_reply(dev, cmd);\n\t\tbreak;\n\n\t \n\tcase CMD_USBCAN_CLOCK_OVERFLOW_EVENT:\n\t\tif (dev->driver_info->family != KVASER_USBCAN)\n\t\t\tgoto warn;\n\t\tbreak;\n\n\tcase CMD_FLUSH_QUEUE_REPLY:\n\t\tif (dev->driver_info->family != KVASER_LEAF)\n\t\t\tgoto warn;\n\t\tbreak;\n\n\tdefault:\nwarn:\t\tdev_warn(&dev->intf->dev, \"Unhandled command (%d)\\n\", cmd->id);\n\t\tbreak;\n\t}\n}\n\nstatic void kvaser_usb_leaf_read_bulk_callback(struct kvaser_usb *dev,\n\t\t\t\t\t       void *buf, int len)\n{\n\tstruct kvaser_cmd *cmd;\n\tint pos = 0;\n\n\twhile (pos <= len - CMD_HEADER_LEN) {\n\t\tcmd = buf + pos;\n\n\t\t \n\t\tif (cmd->len == 0) {\n\t\t\tpos = round_up(pos, le16_to_cpu\n\t\t\t\t\t\t(dev->bulk_in->wMaxPacketSize));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pos + cmd->len > len) {\n\t\t\tdev_err_ratelimited(&dev->intf->dev, \"Format error\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tkvaser_usb_leaf_handle_command(dev, cmd);\n\t\tpos += cmd->len;\n\t}\n}\n\nstatic int kvaser_usb_leaf_set_opt_mode(const struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->id = CMD_SET_CTRL_MODE;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_ctrl_mode);\n\tcmd->u.ctrl_mode.tid = 0xff;\n\tcmd->u.ctrl_mode.channel = priv->channel;\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tcmd->u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_SILENT;\n\telse\n\t\tcmd->u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_NORMAL;\n\n\trc = kvaser_usb_send_cmd(priv->dev, cmd, cmd->len);\n\n\tkfree(cmd);\n\treturn rc;\n}\n\nstatic int kvaser_usb_leaf_start_chip(struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_usb_net_leaf_priv *leaf = priv->sub_priv;\n\tint err;\n\n\tleaf->joining_bus = true;\n\n\treinit_completion(&priv->start_comp);\n\n\terr = kvaser_usb_leaf_send_simple_cmd(priv->dev, CMD_START_CHIP,\n\t\t\t\t\t      priv->channel);\n\tif (err)\n\t\treturn err;\n\n\tif (!wait_for_completion_timeout(&priv->start_comp,\n\t\t\t\t\t msecs_to_jiffies(KVASER_USB_TIMEOUT)))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_leaf_stop_chip(struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_usb_net_leaf_priv *leaf = priv->sub_priv;\n\tint err;\n\n\treinit_completion(&priv->stop_comp);\n\n\tcancel_delayed_work(&leaf->chip_state_req_work);\n\n\terr = kvaser_usb_leaf_send_simple_cmd(priv->dev, CMD_STOP_CHIP,\n\t\t\t\t\t      priv->channel);\n\tif (err)\n\t\treturn err;\n\n\tif (!wait_for_completion_timeout(&priv->stop_comp,\n\t\t\t\t\t msecs_to_jiffies(KVASER_USB_TIMEOUT)))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_leaf_reset_chip(struct kvaser_usb *dev, int channel)\n{\n\treturn kvaser_usb_leaf_send_simple_cmd(dev, CMD_RESET_CHIP, channel);\n}\n\nstatic int kvaser_usb_leaf_flush_queue(struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->id = CMD_FLUSH_QUEUE;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_flush_queue);\n\tcmd->u.flush_queue.channel = priv->channel;\n\tcmd->u.flush_queue.flags = 0x00;\n\n\trc = kvaser_usb_send_cmd(priv->dev, cmd, cmd->len);\n\n\tkfree(cmd);\n\treturn rc;\n}\n\nstatic int kvaser_usb_leaf_init_card(struct kvaser_usb *dev)\n{\n\tstruct kvaser_usb_dev_card_data *card_data = &dev->card_data;\n\n\tcard_data->ctrlmode_supported |= CAN_CTRLMODE_3_SAMPLES;\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_leaf_init_channel(struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_usb_net_leaf_priv *leaf;\n\n\tleaf = devm_kzalloc(&priv->dev->intf->dev, sizeof(*leaf), GFP_KERNEL);\n\tif (!leaf)\n\t\treturn -ENOMEM;\n\n\tleaf->net = priv;\n\tINIT_DELAYED_WORK(&leaf->chip_state_req_work,\n\t\t\t  kvaser_usb_leaf_chip_state_req_work);\n\n\tpriv->sub_priv = leaf;\n\n\treturn 0;\n}\n\nstatic void kvaser_usb_leaf_remove_channel(struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_usb_net_leaf_priv *leaf = priv->sub_priv;\n\n\tif (leaf)\n\t\tcancel_delayed_work_sync(&leaf->chip_state_req_work);\n}\n\nstatic int kvaser_usb_leaf_set_bittiming(const struct net_device *netdev,\n\t\t\t\t\t const struct kvaser_usb_busparams *busparams)\n{\n\tstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\n\tstruct kvaser_usb *dev = priv->dev;\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\n\tcmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->id = CMD_SET_BUS_PARAMS;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_busparams);\n\tcmd->u.busparams.channel = priv->channel;\n\tcmd->u.busparams.tid = 0xff;\n\tmemcpy(&cmd->u.busparams.busparams, busparams,\n\t       sizeof(cmd->u.busparams.busparams));\n\n\trc = kvaser_usb_send_cmd(dev, cmd, cmd->len);\n\n\tkfree(cmd);\n\treturn rc;\n}\n\nstatic int kvaser_usb_leaf_get_busparams(struct kvaser_usb_net_priv *priv)\n{\n\tint err;\n\n\tif (priv->dev->driver_info->family == KVASER_USBCAN)\n\t\treturn -EOPNOTSUPP;\n\n\treinit_completion(&priv->get_busparams_comp);\n\n\terr = kvaser_usb_leaf_send_simple_cmd(priv->dev, CMD_GET_BUS_PARAMS,\n\t\t\t\t\t      priv->channel);\n\tif (err)\n\t\treturn err;\n\n\tif (!wait_for_completion_timeout(&priv->get_busparams_comp,\n\t\t\t\t\t msecs_to_jiffies(KVASER_USB_TIMEOUT)))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_leaf_set_mode(struct net_device *netdev,\n\t\t\t\t    enum can_mode mode)\n{\n\tstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\n\tstruct kvaser_usb_net_leaf_priv *leaf = priv->sub_priv;\n\tint err;\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\tkvaser_usb_unlink_tx_urbs(priv);\n\n\t\tleaf->joining_bus = true;\n\n\t\terr = kvaser_usb_leaf_simple_cmd_async(priv, CMD_START_CHIP);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_leaf_get_berr_counter(const struct net_device *netdev,\n\t\t\t\t\t    struct can_berr_counter *bec)\n{\n\tstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\n\n\t*bec = priv->bec;\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_leaf_setup_endpoints(struct kvaser_usb *dev)\n{\n\tconst struct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tint i;\n\n\tiface_desc = dev->intf->cur_altsetting;\n\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\n\t\tif (!dev->bulk_in && usb_endpoint_is_bulk_in(endpoint))\n\t\t\tdev->bulk_in = endpoint;\n\n\t\tif (!dev->bulk_out && usb_endpoint_is_bulk_out(endpoint))\n\t\t\tdev->bulk_out = endpoint;\n\n\t\t \n\t\tif (dev->bulk_in && dev->bulk_out)\n\t\t\treturn 0;\n\t}\n\n\treturn -ENODEV;\n}\n\nconst struct kvaser_usb_dev_ops kvaser_usb_leaf_dev_ops = {\n\t.dev_set_mode = kvaser_usb_leaf_set_mode,\n\t.dev_set_bittiming = kvaser_usb_leaf_set_bittiming,\n\t.dev_get_busparams = kvaser_usb_leaf_get_busparams,\n\t.dev_set_data_bittiming = NULL,\n\t.dev_get_data_busparams = NULL,\n\t.dev_get_berr_counter = kvaser_usb_leaf_get_berr_counter,\n\t.dev_setup_endpoints = kvaser_usb_leaf_setup_endpoints,\n\t.dev_init_card = kvaser_usb_leaf_init_card,\n\t.dev_init_channel = kvaser_usb_leaf_init_channel,\n\t.dev_remove_channel = kvaser_usb_leaf_remove_channel,\n\t.dev_get_software_info = kvaser_usb_leaf_get_software_info,\n\t.dev_get_software_details = NULL,\n\t.dev_get_card_info = kvaser_usb_leaf_get_card_info,\n\t.dev_get_capabilities = kvaser_usb_leaf_get_capabilities,\n\t.dev_set_opt_mode = kvaser_usb_leaf_set_opt_mode,\n\t.dev_start_chip = kvaser_usb_leaf_start_chip,\n\t.dev_stop_chip = kvaser_usb_leaf_stop_chip,\n\t.dev_reset_chip = kvaser_usb_leaf_reset_chip,\n\t.dev_flush_queue = kvaser_usb_leaf_flush_queue,\n\t.dev_read_bulk_callback = kvaser_usb_leaf_read_bulk_callback,\n\t.dev_frame_to_cmd = kvaser_usb_leaf_frame_to_cmd,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}