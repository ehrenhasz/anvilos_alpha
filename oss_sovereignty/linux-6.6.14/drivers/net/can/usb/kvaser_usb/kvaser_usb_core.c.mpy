{
  "module_name": "kvaser_usb_core.c",
  "hash_id": "8f6d4fa8b27404172561a1a1a86bf45204575567fd0e8085a0ecacc074945d36",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/usb/kvaser_usb/kvaser_usb_core.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/ethtool.h>\n#include <linux/gfp.h>\n#include <linux/if.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/usb.h>\n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n#include <linux/can/netlink.h>\n\n#include \"kvaser_usb.h\"\n\n \n#define KVASER_VENDOR_ID 0x0bfd\n\n \n#define USB_LEAF_DEVEL_PRODUCT_ID 0x000a\n#define USB_LEAF_LITE_PRODUCT_ID 0x000b\n#define USB_LEAF_PRO_PRODUCT_ID 0x000c\n#define USB_LEAF_SPRO_PRODUCT_ID 0x000e\n#define USB_LEAF_PRO_LS_PRODUCT_ID 0x000f\n#define USB_LEAF_PRO_SWC_PRODUCT_ID 0x0010\n#define USB_LEAF_PRO_LIN_PRODUCT_ID 0x0011\n#define USB_LEAF_SPRO_LS_PRODUCT_ID 0x0012\n#define USB_LEAF_SPRO_SWC_PRODUCT_ID 0x0013\n#define USB_MEMO2_DEVEL_PRODUCT_ID 0x0016\n#define USB_MEMO2_HSHS_PRODUCT_ID 0x0017\n#define USB_UPRO_HSHS_PRODUCT_ID 0x0018\n#define USB_LEAF_LITE_GI_PRODUCT_ID 0x0019\n#define USB_LEAF_PRO_OBDII_PRODUCT_ID 0x001a\n#define USB_MEMO2_HSLS_PRODUCT_ID 0x001b\n#define USB_LEAF_LITE_CH_PRODUCT_ID 0x001c\n#define USB_BLACKBIRD_SPRO_PRODUCT_ID 0x001d\n#define USB_OEM_MERCURY_PRODUCT_ID 0x0022\n#define USB_OEM_LEAF_PRODUCT_ID 0x0023\n#define USB_CAN_R_PRODUCT_ID 0x0027\n#define USB_LEAF_LITE_V2_PRODUCT_ID 0x0120\n#define USB_MINI_PCIE_HS_PRODUCT_ID 0x0121\n#define USB_LEAF_LIGHT_HS_V2_OEM_PRODUCT_ID 0x0122\n#define USB_USBCAN_LIGHT_2HS_PRODUCT_ID 0x0123\n#define USB_MINI_PCIE_2HS_PRODUCT_ID 0x0124\n#define USB_USBCAN_R_V2_PRODUCT_ID 0x0126\n#define USB_LEAF_LIGHT_R_V2_PRODUCT_ID 0x0127\n#define USB_LEAF_LIGHT_HS_V2_OEM2_PRODUCT_ID 0x0128\n\n \n#define USB_USBCAN_REVB_PRODUCT_ID 0x0002\n#define USB_VCI2_PRODUCT_ID 0x0003\n#define USB_USBCAN2_PRODUCT_ID 0x0004\n#define USB_MEMORATOR_PRODUCT_ID 0x0005\n\n \n#define USB_BLACKBIRD_V2_PRODUCT_ID 0x0102\n#define USB_MEMO_PRO_5HS_PRODUCT_ID 0x0104\n#define USB_USBCAN_PRO_5HS_PRODUCT_ID 0x0105\n#define USB_USBCAN_LIGHT_4HS_PRODUCT_ID 0x0106\n#define USB_LEAF_PRO_HS_V2_PRODUCT_ID 0x0107\n#define USB_USBCAN_PRO_2HS_V2_PRODUCT_ID 0x0108\n#define USB_MEMO_2HS_PRODUCT_ID 0x0109\n#define USB_MEMO_PRO_2HS_V2_PRODUCT_ID 0x010a\n#define USB_HYBRID_2CANLIN_PRODUCT_ID 0x010b\n#define USB_ATI_USBCAN_PRO_2HS_V2_PRODUCT_ID 0x010c\n#define USB_ATI_MEMO_PRO_2HS_V2_PRODUCT_ID 0x010d\n#define USB_HYBRID_PRO_2CANLIN_PRODUCT_ID 0x010e\n#define USB_U100_PRODUCT_ID 0x0111\n#define USB_U100P_PRODUCT_ID 0x0112\n#define USB_U100S_PRODUCT_ID 0x0113\n#define USB_USBCAN_PRO_4HS_PRODUCT_ID 0x0114\n#define USB_HYBRID_CANLIN_PRODUCT_ID 0x0115\n#define USB_HYBRID_PRO_CANLIN_PRODUCT_ID 0x0116\n\nstatic const struct kvaser_usb_driver_info kvaser_usb_driver_info_hydra = {\n\t.quirks = KVASER_USB_QUIRK_HAS_HARDWARE_TIMESTAMP,\n\t.ops = &kvaser_usb_hydra_dev_ops,\n};\n\nstatic const struct kvaser_usb_driver_info kvaser_usb_driver_info_usbcan = {\n\t.quirks = KVASER_USB_QUIRK_HAS_TXRX_ERRORS |\n\t\t  KVASER_USB_QUIRK_HAS_SILENT_MODE,\n\t.family = KVASER_USBCAN,\n\t.ops = &kvaser_usb_leaf_dev_ops,\n};\n\nstatic const struct kvaser_usb_driver_info kvaser_usb_driver_info_leaf = {\n\t.quirks = KVASER_USB_QUIRK_IGNORE_CLK_FREQ,\n\t.family = KVASER_LEAF,\n\t.ops = &kvaser_usb_leaf_dev_ops,\n};\n\nstatic const struct kvaser_usb_driver_info kvaser_usb_driver_info_leaf_err = {\n\t.quirks = KVASER_USB_QUIRK_HAS_TXRX_ERRORS |\n\t\t  KVASER_USB_QUIRK_IGNORE_CLK_FREQ,\n\t.family = KVASER_LEAF,\n\t.ops = &kvaser_usb_leaf_dev_ops,\n};\n\nstatic const struct kvaser_usb_driver_info kvaser_usb_driver_info_leaf_err_listen = {\n\t.quirks = KVASER_USB_QUIRK_HAS_TXRX_ERRORS |\n\t\t  KVASER_USB_QUIRK_HAS_SILENT_MODE |\n\t\t  KVASER_USB_QUIRK_IGNORE_CLK_FREQ,\n\t.family = KVASER_LEAF,\n\t.ops = &kvaser_usb_leaf_dev_ops,\n};\n\nstatic const struct kvaser_usb_driver_info kvaser_usb_driver_info_leafimx = {\n\t.quirks = 0,\n\t.ops = &kvaser_usb_leaf_dev_ops,\n};\n\nstatic const struct usb_device_id kvaser_usb_table[] = {\n\t \n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_LEAF_DEVEL_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leaf },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_LEAF_LITE_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leaf },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_LEAF_PRO_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leaf_err_listen },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_LEAF_SPRO_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leaf_err_listen },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_LEAF_PRO_LS_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leaf_err_listen },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_LEAF_PRO_SWC_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leaf_err_listen },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_LEAF_PRO_LIN_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leaf_err_listen },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_LEAF_SPRO_LS_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leaf_err_listen },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_LEAF_SPRO_SWC_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leaf_err_listen },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_MEMO2_DEVEL_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leaf_err_listen },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_MEMO2_HSHS_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leaf_err_listen },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_UPRO_HSHS_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leaf_err },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_LEAF_LITE_GI_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leaf },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_LEAF_PRO_OBDII_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leaf_err_listen },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_MEMO2_HSLS_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leaf_err },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_LEAF_LITE_CH_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leaf_err },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_BLACKBIRD_SPRO_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leaf_err },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_OEM_MERCURY_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leaf_err },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_OEM_LEAF_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leaf_err },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_CAN_R_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leaf_err },\n\n\t \n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_LEAF_LITE_V2_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leafimx },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_MINI_PCIE_HS_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leafimx },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_LEAF_LIGHT_HS_V2_OEM_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leafimx },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_USBCAN_LIGHT_2HS_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leafimx },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_MINI_PCIE_2HS_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leafimx },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_USBCAN_R_V2_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leafimx },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_LEAF_LIGHT_R_V2_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leafimx },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_LEAF_LIGHT_HS_V2_OEM2_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_leafimx },\n\n\t \n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_USBCAN2_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_usbcan },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_USBCAN_REVB_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_usbcan },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_MEMORATOR_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_usbcan },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_VCI2_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_usbcan },\n\n\t \n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_BLACKBIRD_V2_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_hydra },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_MEMO_PRO_5HS_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_hydra },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_USBCAN_PRO_5HS_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_hydra },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_USBCAN_LIGHT_4HS_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_hydra },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_LEAF_PRO_HS_V2_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_hydra },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_USBCAN_PRO_2HS_V2_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_hydra },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_MEMO_2HS_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_hydra },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_MEMO_PRO_2HS_V2_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_hydra },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_HYBRID_2CANLIN_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_hydra },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_ATI_USBCAN_PRO_2HS_V2_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_hydra },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_ATI_MEMO_PRO_2HS_V2_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_hydra },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_HYBRID_PRO_2CANLIN_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_hydra },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_U100_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_hydra },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_U100P_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_hydra },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_U100S_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_hydra },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_USBCAN_PRO_4HS_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_hydra },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_HYBRID_CANLIN_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_hydra },\n\t{ USB_DEVICE(KVASER_VENDOR_ID, USB_HYBRID_PRO_CANLIN_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&kvaser_usb_driver_info_hydra },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, kvaser_usb_table);\n\nint kvaser_usb_send_cmd(const struct kvaser_usb *dev, void *cmd, int len)\n{\n\treturn usb_bulk_msg(dev->udev,\n\t\t\t    usb_sndbulkpipe(dev->udev,\n\t\t\t\t\t    dev->bulk_out->bEndpointAddress),\n\t\t\t    cmd, len, NULL, KVASER_USB_TIMEOUT);\n}\n\nint kvaser_usb_recv_cmd(const struct kvaser_usb *dev, void *cmd, int len,\n\t\t\tint *actual_len)\n{\n\treturn usb_bulk_msg(dev->udev,\n\t\t\t    usb_rcvbulkpipe(dev->udev,\n\t\t\t\t\t    dev->bulk_in->bEndpointAddress),\n\t\t\t    cmd, len, actual_len, KVASER_USB_TIMEOUT);\n}\n\nstatic void kvaser_usb_send_cmd_callback(struct urb *urb)\n{\n\tstruct net_device *netdev = urb->context;\n\n\tkfree(urb->transfer_buffer);\n\n\tif (urb->status)\n\t\tnetdev_warn(netdev, \"urb status received: %d\\n\", urb->status);\n}\n\nint kvaser_usb_send_cmd_async(struct kvaser_usb_net_priv *priv, void *cmd,\n\t\t\t      int len)\n{\n\tstruct kvaser_usb *dev = priv->dev;\n\tstruct net_device *netdev = priv->netdev;\n\tstruct urb *urb;\n\tint err;\n\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tusb_fill_bulk_urb(urb, dev->udev,\n\t\t\t  usb_sndbulkpipe(dev->udev,\n\t\t\t\t\t  dev->bulk_out->bEndpointAddress),\n\t\t\t  cmd, len, kvaser_usb_send_cmd_callback, netdev);\n\tusb_anchor_urb(urb, &priv->tx_submitted);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err) {\n\t\tnetdev_err(netdev, \"Error transmitting URB\\n\");\n\t\tusb_unanchor_urb(urb);\n\t}\n\tusb_free_urb(urb);\n\n\treturn 0;\n}\n\nint kvaser_usb_can_rx_over_error(struct net_device *netdev)\n{\n\tstruct net_device_stats *stats = &netdev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\n\tstats->rx_over_errors++;\n\tstats->rx_errors++;\n\n\tskb = alloc_can_err_skb(netdev, &cf);\n\tif (!skb) {\n\t\tstats->rx_dropped++;\n\t\tnetdev_warn(netdev, \"No memory left for err_skb\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcf->can_id |= CAN_ERR_CRTL;\n\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\n\tnetif_rx(skb);\n\n\treturn 0;\n}\n\nstatic void kvaser_usb_read_bulk_callback(struct urb *urb)\n{\n\tstruct kvaser_usb *dev = urb->context;\n\tconst struct kvaser_usb_dev_ops *ops = dev->driver_info->ops;\n\tint err;\n\tunsigned int i;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ENOENT:\n\tcase -EPIPE:\n\tcase -EPROTO:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:\n\t\tdev_info(&dev->intf->dev, \"Rx URB aborted (%d)\\n\", urb->status);\n\t\tgoto resubmit_urb;\n\t}\n\n\tops->dev_read_bulk_callback(dev, urb->transfer_buffer,\n\t\t\t\t    urb->actual_length);\n\nresubmit_urb:\n\tusb_fill_bulk_urb(urb, dev->udev,\n\t\t\t  usb_rcvbulkpipe(dev->udev,\n\t\t\t\t\t  dev->bulk_in->bEndpointAddress),\n\t\t\t  urb->transfer_buffer, KVASER_USB_RX_BUFFER_SIZE,\n\t\t\t  kvaser_usb_read_bulk_callback, dev);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err == -ENODEV) {\n\t\tfor (i = 0; i < dev->nchannels; i++) {\n\t\t\tif (!dev->nets[i])\n\t\t\t\tcontinue;\n\n\t\t\tnetif_device_detach(dev->nets[i]->netdev);\n\t\t}\n\t} else if (err) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"Failed resubmitting read bulk urb: %d\\n\", err);\n\t}\n}\n\nstatic int kvaser_usb_setup_rx_urbs(struct kvaser_usb *dev)\n{\n\tint i, err = 0;\n\n\tif (dev->rxinitdone)\n\t\treturn 0;\n\n\tfor (i = 0; i < KVASER_USB_MAX_RX_URBS; i++) {\n\t\tstruct urb *urb = NULL;\n\t\tu8 *buf = NULL;\n\t\tdma_addr_t buf_dma;\n\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf = usb_alloc_coherent(dev->udev, KVASER_USB_RX_BUFFER_SIZE,\n\t\t\t\t\t GFP_KERNEL, &buf_dma);\n\t\tif (!buf) {\n\t\t\tdev_warn(&dev->intf->dev,\n\t\t\t\t \"No memory left for USB buffer\\n\");\n\t\t\tusb_free_urb(urb);\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tusb_fill_bulk_urb(urb, dev->udev,\n\t\t\t\t  usb_rcvbulkpipe\n\t\t\t\t\t(dev->udev,\n\t\t\t\t\t dev->bulk_in->bEndpointAddress),\n\t\t\t\t  buf, KVASER_USB_RX_BUFFER_SIZE,\n\t\t\t\t  kvaser_usb_read_bulk_callback, dev);\n\t\turb->transfer_dma = buf_dma;\n\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\tusb_anchor_urb(urb, &dev->rx_submitted);\n\n\t\terr = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (err) {\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tusb_free_coherent(dev->udev,\n\t\t\t\t\t  KVASER_USB_RX_BUFFER_SIZE, buf,\n\t\t\t\t\t  buf_dma);\n\t\t\tusb_free_urb(urb);\n\t\t\tbreak;\n\t\t}\n\n\t\tdev->rxbuf[i] = buf;\n\t\tdev->rxbuf_dma[i] = buf_dma;\n\n\t\tusb_free_urb(urb);\n\t}\n\n\tif (i == 0) {\n\t\tdev_warn(&dev->intf->dev, \"Cannot setup read URBs, error %d\\n\",\n\t\t\t err);\n\t\treturn err;\n\t} else if (i < KVASER_USB_MAX_RX_URBS) {\n\t\tdev_warn(&dev->intf->dev, \"RX performances may be slow\\n\");\n\t}\n\n\tdev->rxinitdone = true;\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_open(struct net_device *netdev)\n{\n\tstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\n\tstruct kvaser_usb *dev = priv->dev;\n\tconst struct kvaser_usb_dev_ops *ops = dev->driver_info->ops;\n\tint err;\n\n\terr = open_candev(netdev);\n\tif (err)\n\t\treturn err;\n\n\terr = ops->dev_set_opt_mode(priv);\n\tif (err)\n\t\tgoto error;\n\n\terr = ops->dev_start_chip(priv);\n\tif (err) {\n\t\tnetdev_warn(netdev, \"Cannot start device, error %d\\n\", err);\n\t\tgoto error;\n\t}\n\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\treturn 0;\n\nerror:\n\tclose_candev(netdev);\n\treturn err;\n}\n\nstatic void kvaser_usb_reset_tx_urb_contexts(struct kvaser_usb_net_priv *priv)\n{\n\tint i, max_tx_urbs;\n\n\tmax_tx_urbs = priv->dev->max_tx_urbs;\n\n\tpriv->active_tx_contexts = 0;\n\tfor (i = 0; i < max_tx_urbs; i++)\n\t\tpriv->tx_contexts[i].echo_index = max_tx_urbs;\n}\n\n \nvoid kvaser_usb_unlink_tx_urbs(struct kvaser_usb_net_priv *priv)\n{\n\tusb_kill_anchored_urbs(&priv->tx_submitted);\n\tkvaser_usb_reset_tx_urb_contexts(priv);\n}\n\nstatic void kvaser_usb_unlink_all_urbs(struct kvaser_usb *dev)\n{\n\tint i;\n\n\tusb_kill_anchored_urbs(&dev->rx_submitted);\n\n\tfor (i = 0; i < KVASER_USB_MAX_RX_URBS; i++)\n\t\tusb_free_coherent(dev->udev, KVASER_USB_RX_BUFFER_SIZE,\n\t\t\t\t  dev->rxbuf[i], dev->rxbuf_dma[i]);\n\n\tfor (i = 0; i < dev->nchannels; i++) {\n\t\tstruct kvaser_usb_net_priv *priv = dev->nets[i];\n\n\t\tif (priv)\n\t\t\tkvaser_usb_unlink_tx_urbs(priv);\n\t}\n}\n\nstatic int kvaser_usb_close(struct net_device *netdev)\n{\n\tstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\n\tstruct kvaser_usb *dev = priv->dev;\n\tconst struct kvaser_usb_dev_ops *ops = dev->driver_info->ops;\n\tint err;\n\n\tnetif_stop_queue(netdev);\n\n\terr = ops->dev_flush_queue(priv);\n\tif (err)\n\t\tnetdev_warn(netdev, \"Cannot flush queue, error %d\\n\", err);\n\n\tif (ops->dev_reset_chip) {\n\t\terr = ops->dev_reset_chip(dev, priv->channel);\n\t\tif (err)\n\t\t\tnetdev_warn(netdev, \"Cannot reset card, error %d\\n\",\n\t\t\t\t    err);\n\t}\n\n\terr = ops->dev_stop_chip(priv);\n\tif (err)\n\t\tnetdev_warn(netdev, \"Cannot stop device, error %d\\n\", err);\n\n\t \n\tkvaser_usb_unlink_tx_urbs(priv);\n\n\tpriv->can.state = CAN_STATE_STOPPED;\n\tclose_candev(priv->netdev);\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_set_bittiming(struct net_device *netdev)\n{\n\tstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\n\tstruct kvaser_usb *dev = priv->dev;\n\tconst struct kvaser_usb_dev_ops *ops = dev->driver_info->ops;\n\tstruct can_bittiming *bt = &priv->can.bittiming;\n\tstruct kvaser_usb_busparams busparams;\n\tint tseg1 = bt->prop_seg + bt->phase_seg1;\n\tint tseg2 = bt->phase_seg2;\n\tint sjw = bt->sjw;\n\tint err;\n\n\tbusparams.bitrate = cpu_to_le32(bt->bitrate);\n\tbusparams.sjw = (u8)sjw;\n\tbusparams.tseg1 = (u8)tseg1;\n\tbusparams.tseg2 = (u8)tseg2;\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\tbusparams.nsamples = 3;\n\telse\n\t\tbusparams.nsamples = 1;\n\n\terr = ops->dev_set_bittiming(netdev, &busparams);\n\tif (err)\n\t\treturn err;\n\n\terr = kvaser_usb_setup_rx_urbs(priv->dev);\n\tif (err)\n\t\treturn err;\n\n\terr = ops->dev_get_busparams(priv);\n\tif (err) {\n\t\t \n\t\tif (err == -EOPNOTSUPP)\n\t\t\terr = 0;\n\t\treturn err;\n\t}\n\n\tif (memcmp(&busparams, &priv->busparams_nominal,\n\t\t   sizeof(priv->busparams_nominal)) != 0)\n\t\terr = -EINVAL;\n\n\treturn err;\n}\n\nstatic int kvaser_usb_set_data_bittiming(struct net_device *netdev)\n{\n\tstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\n\tstruct kvaser_usb *dev = priv->dev;\n\tconst struct kvaser_usb_dev_ops *ops = dev->driver_info->ops;\n\tstruct can_bittiming *dbt = &priv->can.data_bittiming;\n\tstruct kvaser_usb_busparams busparams;\n\tint tseg1 = dbt->prop_seg + dbt->phase_seg1;\n\tint tseg2 = dbt->phase_seg2;\n\tint sjw = dbt->sjw;\n\tint err;\n\n\tif (!ops->dev_set_data_bittiming ||\n\t    !ops->dev_get_data_busparams)\n\t\treturn -EOPNOTSUPP;\n\n\tbusparams.bitrate = cpu_to_le32(dbt->bitrate);\n\tbusparams.sjw = (u8)sjw;\n\tbusparams.tseg1 = (u8)tseg1;\n\tbusparams.tseg2 = (u8)tseg2;\n\tbusparams.nsamples = 1;\n\n\terr = ops->dev_set_data_bittiming(netdev, &busparams);\n\tif (err)\n\t\treturn err;\n\n\terr = kvaser_usb_setup_rx_urbs(priv->dev);\n\tif (err)\n\t\treturn err;\n\n\terr = ops->dev_get_data_busparams(priv);\n\tif (err)\n\t\treturn err;\n\n\tif (memcmp(&busparams, &priv->busparams_data,\n\t\t   sizeof(priv->busparams_data)) != 0)\n\t\terr = -EINVAL;\n\n\treturn err;\n}\n\nstatic void kvaser_usb_write_bulk_callback(struct urb *urb)\n{\n\tstruct kvaser_usb_tx_urb_context *context = urb->context;\n\tstruct kvaser_usb_net_priv *priv;\n\tstruct net_device *netdev;\n\n\tif (WARN_ON(!context))\n\t\treturn;\n\n\tpriv = context->priv;\n\tnetdev = priv->netdev;\n\n\tkfree(urb->transfer_buffer);\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"Tx URB aborted (%d)\\n\", urb->status);\n}\n\nstatic netdev_tx_t kvaser_usb_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *netdev)\n{\n\tstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\n\tstruct kvaser_usb *dev = priv->dev;\n\tconst struct kvaser_usb_dev_ops *ops = dev->driver_info->ops;\n\tstruct net_device_stats *stats = &netdev->stats;\n\tstruct kvaser_usb_tx_urb_context *context = NULL;\n\tstruct urb *urb;\n\tvoid *buf;\n\tint cmd_len = 0;\n\tint err, ret = NETDEV_TX_OK;\n\tunsigned int i;\n\tunsigned long flags;\n\n\tif (can_dev_dropped_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb) {\n\t\tstats->tx_dropped++;\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tspin_lock_irqsave(&priv->tx_contexts_lock, flags);\n\tfor (i = 0; i < dev->max_tx_urbs; i++) {\n\t\tif (priv->tx_contexts[i].echo_index == dev->max_tx_urbs) {\n\t\t\tcontext = &priv->tx_contexts[i];\n\n\t\t\tcontext->echo_index = i;\n\t\t\t++priv->active_tx_contexts;\n\t\t\tif (priv->active_tx_contexts >= (int)dev->max_tx_urbs)\n\t\t\t\tnetif_stop_queue(netdev);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&priv->tx_contexts_lock, flags);\n\n\t \n\tif (!context) {\n\t\tnetdev_warn(netdev, \"cannot find free context\\n\");\n\n\t\tret = NETDEV_TX_BUSY;\n\t\tgoto freeurb;\n\t}\n\n\tbuf = ops->dev_frame_to_cmd(priv, skb, &cmd_len, context->echo_index);\n\tif (!buf) {\n\t\tstats->tx_dropped++;\n\t\tdev_kfree_skb(skb);\n\t\tspin_lock_irqsave(&priv->tx_contexts_lock, flags);\n\n\t\tcontext->echo_index = dev->max_tx_urbs;\n\t\t--priv->active_tx_contexts;\n\t\tnetif_wake_queue(netdev);\n\n\t\tspin_unlock_irqrestore(&priv->tx_contexts_lock, flags);\n\t\tgoto freeurb;\n\t}\n\n\tcontext->priv = priv;\n\n\tcan_put_echo_skb(skb, netdev, context->echo_index, 0);\n\n\tusb_fill_bulk_urb(urb, dev->udev,\n\t\t\t  usb_sndbulkpipe(dev->udev,\n\t\t\t\t\t  dev->bulk_out->bEndpointAddress),\n\t\t\t  buf, cmd_len, kvaser_usb_write_bulk_callback,\n\t\t\t  context);\n\tusb_anchor_urb(urb, &priv->tx_submitted);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tspin_lock_irqsave(&priv->tx_contexts_lock, flags);\n\n\t\tcan_free_echo_skb(netdev, context->echo_index, NULL);\n\t\tcontext->echo_index = dev->max_tx_urbs;\n\t\t--priv->active_tx_contexts;\n\t\tnetif_wake_queue(netdev);\n\n\t\tspin_unlock_irqrestore(&priv->tx_contexts_lock, flags);\n\n\t\tusb_unanchor_urb(urb);\n\t\tkfree(buf);\n\n\t\tstats->tx_dropped++;\n\n\t\tif (err == -ENODEV)\n\t\t\tnetif_device_detach(netdev);\n\t\telse\n\t\t\tnetdev_warn(netdev, \"Failed tx_urb %d\\n\", err);\n\n\t\tgoto freeurb;\n\t}\n\n\tret = NETDEV_TX_OK;\n\nfreeurb:\n\tusb_free_urb(urb);\n\treturn ret;\n}\n\nstatic const struct net_device_ops kvaser_usb_netdev_ops = {\n\t.ndo_open = kvaser_usb_open,\n\t.ndo_stop = kvaser_usb_close,\n\t.ndo_start_xmit = kvaser_usb_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic const struct net_device_ops kvaser_usb_netdev_ops_hwts = {\n\t.ndo_open = kvaser_usb_open,\n\t.ndo_stop = kvaser_usb_close,\n\t.ndo_eth_ioctl = can_eth_ioctl_hwts,\n\t.ndo_start_xmit = kvaser_usb_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic const struct ethtool_ops kvaser_usb_ethtool_ops = {\n\t.get_ts_info = ethtool_op_get_ts_info,\n};\n\nstatic const struct ethtool_ops kvaser_usb_ethtool_ops_hwts = {\n\t.get_ts_info = can_ethtool_op_get_ts_info_hwts,\n};\n\nstatic void kvaser_usb_remove_interfaces(struct kvaser_usb *dev)\n{\n\tconst struct kvaser_usb_dev_ops *ops = dev->driver_info->ops;\n\tint i;\n\n\tfor (i = 0; i < dev->nchannels; i++) {\n\t\tif (!dev->nets[i])\n\t\t\tcontinue;\n\n\t\tunregister_candev(dev->nets[i]->netdev);\n\t}\n\n\tkvaser_usb_unlink_all_urbs(dev);\n\n\tfor (i = 0; i < dev->nchannels; i++) {\n\t\tif (!dev->nets[i])\n\t\t\tcontinue;\n\n\t\tif (ops->dev_remove_channel)\n\t\t\tops->dev_remove_channel(dev->nets[i]);\n\n\t\tfree_candev(dev->nets[i]->netdev);\n\t}\n}\n\nstatic int kvaser_usb_init_one(struct kvaser_usb *dev, int channel)\n{\n\tstruct net_device *netdev;\n\tstruct kvaser_usb_net_priv *priv;\n\tconst struct kvaser_usb_driver_info *driver_info = dev->driver_info;\n\tconst struct kvaser_usb_dev_ops *ops = driver_info->ops;\n\tint err;\n\n\tif (ops->dev_reset_chip) {\n\t\terr = ops->dev_reset_chip(dev, channel);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tnetdev = alloc_candev(struct_size(priv, tx_contexts, dev->max_tx_urbs),\n\t\t\t      dev->max_tx_urbs);\n\tif (!netdev) {\n\t\tdev_err(&dev->intf->dev, \"Cannot alloc candev\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv = netdev_priv(netdev);\n\n\tinit_usb_anchor(&priv->tx_submitted);\n\tinit_completion(&priv->start_comp);\n\tinit_completion(&priv->stop_comp);\n\tinit_completion(&priv->flush_comp);\n\tinit_completion(&priv->get_busparams_comp);\n\tpriv->can.ctrlmode_supported = CAN_CTRLMODE_CC_LEN8_DLC;\n\n\tpriv->dev = dev;\n\tpriv->netdev = netdev;\n\tpriv->channel = channel;\n\n\tspin_lock_init(&priv->tx_contexts_lock);\n\tkvaser_usb_reset_tx_urb_contexts(priv);\n\n\tpriv->can.state = CAN_STATE_STOPPED;\n\tpriv->can.clock.freq = dev->cfg->clock.freq;\n\tpriv->can.bittiming_const = dev->cfg->bittiming_const;\n\tpriv->can.do_set_bittiming = kvaser_usb_set_bittiming;\n\tpriv->can.do_set_mode = ops->dev_set_mode;\n\tif ((driver_info->quirks & KVASER_USB_QUIRK_HAS_TXRX_ERRORS) ||\n\t    (priv->dev->card_data.capabilities & KVASER_USB_CAP_BERR_CAP))\n\t\tpriv->can.do_get_berr_counter = ops->dev_get_berr_counter;\n\tif (driver_info->quirks & KVASER_USB_QUIRK_HAS_SILENT_MODE)\n\t\tpriv->can.ctrlmode_supported |= CAN_CTRLMODE_LISTENONLY;\n\n\tpriv->can.ctrlmode_supported |= dev->card_data.ctrlmode_supported;\n\n\tif (priv->can.ctrlmode_supported & CAN_CTRLMODE_FD) {\n\t\tpriv->can.data_bittiming_const = dev->cfg->data_bittiming_const;\n\t\tpriv->can.do_set_data_bittiming = kvaser_usb_set_data_bittiming;\n\t}\n\n\tnetdev->flags |= IFF_ECHO;\n\n\tnetdev->netdev_ops = &kvaser_usb_netdev_ops;\n\tif (driver_info->quirks & KVASER_USB_QUIRK_HAS_HARDWARE_TIMESTAMP) {\n\t\tnetdev->netdev_ops = &kvaser_usb_netdev_ops_hwts;\n\t\tnetdev->ethtool_ops = &kvaser_usb_ethtool_ops_hwts;\n\t} else {\n\t\tnetdev->netdev_ops = &kvaser_usb_netdev_ops;\n\t\tnetdev->ethtool_ops = &kvaser_usb_ethtool_ops;\n\t}\n\tSET_NETDEV_DEV(netdev, &dev->intf->dev);\n\tnetdev->dev_id = channel;\n\n\tdev->nets[channel] = priv;\n\n\tif (ops->dev_init_channel) {\n\t\terr = ops->dev_init_channel(priv);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\terr = register_candev(netdev);\n\tif (err) {\n\t\tdev_err(&dev->intf->dev, \"Failed to register CAN device\\n\");\n\t\tgoto err;\n\t}\n\n\tnetdev_dbg(netdev, \"device registered\\n\");\n\n\treturn 0;\n\nerr:\n\tfree_candev(netdev);\n\tdev->nets[channel] = NULL;\n\treturn err;\n}\n\nstatic int kvaser_usb_probe(struct usb_interface *intf,\n\t\t\t    const struct usb_device_id *id)\n{\n\tstruct kvaser_usb *dev;\n\tint err;\n\tint i;\n\tconst struct kvaser_usb_driver_info *driver_info;\n\tconst struct kvaser_usb_dev_ops *ops;\n\n\tdriver_info = (const struct kvaser_usb_driver_info *)id->driver_info;\n\tif (!driver_info)\n\t\treturn -ENODEV;\n\n\tdev = devm_kzalloc(&intf->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->intf = intf;\n\tdev->driver_info = driver_info;\n\tops = driver_info->ops;\n\n\terr = ops->dev_setup_endpoints(dev);\n\tif (err) {\n\t\tdev_err(&intf->dev, \"Cannot get usb endpoint(s)\");\n\t\treturn err;\n\t}\n\n\tdev->udev = interface_to_usbdev(intf);\n\n\tinit_usb_anchor(&dev->rx_submitted);\n\n\tusb_set_intfdata(intf, dev);\n\n\tdev->card_data.ctrlmode_supported = 0;\n\tdev->card_data.capabilities = 0;\n\terr = ops->dev_init_card(dev);\n\tif (err) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Failed to initialize card, error %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = ops->dev_get_software_info(dev);\n\tif (err) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Cannot get software info, error %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (ops->dev_get_software_details) {\n\t\terr = ops->dev_get_software_details(dev);\n\t\tif (err) {\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"Cannot get software details, error %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (WARN_ON(!dev->cfg))\n\t\treturn -ENODEV;\n\n\tdev_dbg(&intf->dev, \"Firmware version: %d.%d.%d\\n\",\n\t\t((dev->fw_version >> 24) & 0xff),\n\t\t((dev->fw_version >> 16) & 0xff),\n\t\t(dev->fw_version & 0xffff));\n\n\tdev_dbg(&intf->dev, \"Max outstanding tx = %d URBs\\n\", dev->max_tx_urbs);\n\n\terr = ops->dev_get_card_info(dev);\n\tif (err) {\n\t\tdev_err(&intf->dev, \"Cannot get card info, error %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (ops->dev_get_capabilities) {\n\t\terr = ops->dev_get_capabilities(dev);\n\t\tif (err) {\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"Cannot get capabilities, error %d\\n\", err);\n\t\t\tkvaser_usb_remove_interfaces(dev);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tfor (i = 0; i < dev->nchannels; i++) {\n\t\terr = kvaser_usb_init_one(dev, i);\n\t\tif (err) {\n\t\t\tkvaser_usb_remove_interfaces(dev);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void kvaser_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct kvaser_usb *dev = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\n\tif (!dev)\n\t\treturn;\n\n\tkvaser_usb_remove_interfaces(dev);\n}\n\nstatic struct usb_driver kvaser_usb_driver = {\n\t.name = KBUILD_MODNAME,\n\t.probe = kvaser_usb_probe,\n\t.disconnect = kvaser_usb_disconnect,\n\t.id_table = kvaser_usb_table,\n};\n\nmodule_usb_driver(kvaser_usb_driver);\n\nMODULE_AUTHOR(\"Olivier Sobrie <olivier@sobrie.be>\");\nMODULE_AUTHOR(\"Kvaser AB <support@kvaser.com>\");\nMODULE_DESCRIPTION(\"CAN driver for Kvaser CAN/USB devices\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}