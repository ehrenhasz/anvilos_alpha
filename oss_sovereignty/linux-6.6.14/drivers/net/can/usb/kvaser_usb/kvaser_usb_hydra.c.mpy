{
  "module_name": "kvaser_usb_hydra.c",
  "hash_id": "fb0bc89c13e423b61e40a63ef0db4a4020c1aa36e7a87e765d481686fe9b9397",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/usb/kvaser_usb/kvaser_usb_hydra.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/gfp.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/units.h>\n#include <linux/usb.h>\n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n#include <linux/can/netlink.h>\n\n#include \"kvaser_usb.h\"\n\n \nstatic const struct kvaser_usb_dev_cfg kvaser_usb_hydra_dev_cfg_kcan;\nstatic const struct kvaser_usb_dev_cfg kvaser_usb_hydra_dev_cfg_flexc;\nstatic const struct kvaser_usb_dev_cfg kvaser_usb_hydra_dev_cfg_rt;\n\n#define KVASER_USB_HYDRA_BULK_EP_IN_ADDR\t0x82\n#define KVASER_USB_HYDRA_BULK_EP_OUT_ADDR\t0x02\n\n#define KVASER_USB_HYDRA_MAX_TRANSID\t\t0xff\n#define KVASER_USB_HYDRA_MIN_TRANSID\t\t0x01\n\n \n#define CMD_SET_BUSPARAMS_REQ\t\t\t16\n#define CMD_GET_BUSPARAMS_REQ\t\t\t17\n#define CMD_GET_BUSPARAMS_RESP\t\t\t18\n#define CMD_GET_CHIP_STATE_REQ\t\t\t19\n#define CMD_CHIP_STATE_EVENT\t\t\t20\n#define CMD_SET_DRIVERMODE_REQ\t\t\t21\n#define CMD_START_CHIP_REQ\t\t\t26\n#define CMD_START_CHIP_RESP\t\t\t27\n#define CMD_STOP_CHIP_REQ\t\t\t28\n#define CMD_STOP_CHIP_RESP\t\t\t29\n#define CMD_TX_CAN_MESSAGE\t\t\t33\n#define CMD_GET_CARD_INFO_REQ\t\t\t34\n#define CMD_GET_CARD_INFO_RESP\t\t\t35\n#define CMD_GET_SOFTWARE_INFO_REQ\t\t38\n#define CMD_GET_SOFTWARE_INFO_RESP\t\t39\n#define CMD_ERROR_EVENT\t\t\t\t45\n#define CMD_FLUSH_QUEUE\t\t\t\t48\n#define CMD_TX_ACKNOWLEDGE\t\t\t50\n#define CMD_FLUSH_QUEUE_RESP\t\t\t66\n#define CMD_SET_BUSPARAMS_FD_REQ\t\t69\n#define CMD_SET_BUSPARAMS_FD_RESP\t\t70\n#define CMD_SET_BUSPARAMS_RESP\t\t\t85\n#define CMD_GET_CAPABILITIES_REQ\t\t95\n#define CMD_GET_CAPABILITIES_RESP\t\t96\n#define CMD_RX_MESSAGE\t\t\t\t106\n#define CMD_MAP_CHANNEL_REQ\t\t\t200\n#define CMD_MAP_CHANNEL_RESP\t\t\t201\n#define CMD_GET_SOFTWARE_DETAILS_REQ\t\t202\n#define CMD_GET_SOFTWARE_DETAILS_RESP\t\t203\n#define CMD_EXTENDED\t\t\t\t255\n\n \n#define CMD_TX_CAN_MESSAGE_FD\t\t\t224\n#define CMD_TX_ACKNOWLEDGE_FD\t\t\t225\n#define CMD_RX_MESSAGE_FD\t\t\t226\n\n \n\n \n#define KVASER_USB_HYDRA_HE_ADDRESS_ROUTER\t0x00\n#define KVASER_USB_HYDRA_HE_ADDRESS_ILLEGAL\t0x3e\n\n#define KVASER_USB_HYDRA_TRANSID_CANHE\t\t0x40\n#define KVASER_USB_HYDRA_TRANSID_SYSDBG\t\t0x61\n\nstruct kvaser_cmd_map_ch_req {\n\tchar name[16];\n\tu8 channel;\n\tu8 reserved[11];\n} __packed;\n\nstruct kvaser_cmd_map_ch_res {\n\tu8 he_addr;\n\tu8 channel;\n\tu8 reserved[26];\n} __packed;\n\nstruct kvaser_cmd_card_info {\n\t__le32 serial_number;\n\t__le32 clock_res;\n\t__le32 mfg_date;\n\t__le32 ean[2];\n\tu8 hw_version;\n\tu8 usb_mode;\n\tu8 hw_type;\n\tu8 reserved0;\n\tu8 nchannels;\n\tu8 reserved1[3];\n} __packed;\n\nstruct kvaser_cmd_sw_info {\n\tu8 reserved0[8];\n\t__le16 max_outstanding_tx;\n\tu8 reserved1[18];\n} __packed;\n\nstruct kvaser_cmd_sw_detail_req {\n\tu8 use_ext_cmd;\n\tu8 reserved[27];\n} __packed;\n\n \n#define KVASER_USB_HYDRA_SW_FLAG_FW_BETA\tBIT(2)\n#define KVASER_USB_HYDRA_SW_FLAG_FW_BAD\t\tBIT(4)\n#define KVASER_USB_HYDRA_SW_FLAG_FREQ_80M\tBIT(5)\n#define KVASER_USB_HYDRA_SW_FLAG_EXT_CMD\tBIT(9)\n#define KVASER_USB_HYDRA_SW_FLAG_CANFD\t\tBIT(10)\n#define KVASER_USB_HYDRA_SW_FLAG_NONISO\t\tBIT(11)\n#define KVASER_USB_HYDRA_SW_FLAG_EXT_CAP\tBIT(12)\n#define KVASER_USB_HYDRA_SW_FLAG_CAN_FREQ_80M\tBIT(13)\nstruct kvaser_cmd_sw_detail_res {\n\t__le32 sw_flags;\n\t__le32 sw_version;\n\t__le32 sw_name;\n\t__le32 ean[2];\n\t__le32 max_bitrate;\n\tu8 reserved[4];\n} __packed;\n\n \n#define KVASER_USB_HYDRA_CAP_CMD_LISTEN_MODE\t0x02\n#define KVASER_USB_HYDRA_CAP_CMD_ERR_REPORT\t0x05\n#define KVASER_USB_HYDRA_CAP_CMD_ONE_SHOT\t0x06\nstruct kvaser_cmd_cap_req {\n\t__le16 cap_cmd;\n\tu8 reserved[26];\n} __packed;\n\n \n#define KVASER_USB_HYDRA_CAP_STAT_OK\t\t0x00\n#define KVASER_USB_HYDRA_CAP_STAT_NOT_IMPL\t0x01\n#define KVASER_USB_HYDRA_CAP_STAT_UNAVAIL\t0x02\nstruct kvaser_cmd_cap_res {\n\t__le16 cap_cmd;\n\t__le16 status;\n\t__le32 mask;\n\t__le32 value;\n\tu8 reserved[16];\n} __packed;\n\n \n#define KVASER_USB_HYDRA_ERROR_EVENT_CAN\t0x01\n#define KVASER_USB_HYDRA_ERROR_EVENT_PARAM\t0x09\nstruct kvaser_cmd_error_event {\n\t__le16 timestamp[3];\n\tu8 reserved;\n\tu8 error_code;\n\t__le16 info1;\n\t__le16 info2;\n} __packed;\n\n \n#define KVASER_USB_HYDRA_BUS_ERR_ACT\t\t0x00\n#define KVASER_USB_HYDRA_BUS_ERR_PASS\t\tBIT(5)\n#define KVASER_USB_HYDRA_BUS_BUS_OFF\t\tBIT(6)\nstruct kvaser_cmd_chip_state_event {\n\t__le16 timestamp[3];\n\tu8 tx_err_counter;\n\tu8 rx_err_counter;\n\tu8 bus_status;\n\tu8 reserved[19];\n} __packed;\n\n \n#define KVASER_USB_HYDRA_BUS_MODE_CAN\t\t0x00\n#define KVASER_USB_HYDRA_BUS_MODE_CANFD_ISO\t0x01\n#define KVASER_USB_HYDRA_BUS_MODE_NONISO\t0x02\nstruct kvaser_cmd_set_busparams {\n\tstruct kvaser_usb_busparams busparams_nominal;\n\tu8 reserved0[4];\n\tstruct kvaser_usb_busparams busparams_data;\n\tu8 canfd_mode;\n\tu8 reserved1[7];\n} __packed;\n\n \n#define KVASER_USB_HYDRA_BUSPARAM_TYPE_CAN\t0x00\n#define KVASER_USB_HYDRA_BUSPARAM_TYPE_CANFD\t0x01\nstruct kvaser_cmd_get_busparams_req {\n\tu8 type;\n\tu8 reserved[27];\n} __packed;\n\nstruct kvaser_cmd_get_busparams_res {\n\tstruct kvaser_usb_busparams busparams;\n\tu8 reserved[20];\n} __packed;\n\n \n#define KVASER_USB_HYDRA_CTRLMODE_NORMAL\t0x01\n#define KVASER_USB_HYDRA_CTRLMODE_LISTEN\t0x02\nstruct kvaser_cmd_set_ctrlmode {\n\tu8 mode;\n\tu8 reserved[27];\n} __packed;\n\nstruct kvaser_err_frame_data {\n\tu8 bus_status;\n\tu8 reserved0;\n\tu8 tx_err_counter;\n\tu8 rx_err_counter;\n\tu8 reserved1[4];\n} __packed;\n\nstruct kvaser_cmd_rx_can {\n\tu8 cmd_len;\n\tu8 cmd_no;\n\tu8 channel;\n\tu8 flags;\n\t__le16 timestamp[3];\n\tu8 dlc;\n\tu8 padding;\n\t__le32 id;\n\tunion {\n\t\tu8 data[8];\n\t\tstruct kvaser_err_frame_data err_frame_data;\n\t};\n} __packed;\n\n \n#define KVASER_USB_HYDRA_EXTENDED_FRAME_ID\tBIT(31)\nstruct kvaser_cmd_tx_can {\n\t__le32 id;\n\tu8 data[8];\n\tu8 dlc;\n\tu8 flags;\n\t__le16 transid;\n\tu8 channel;\n\tu8 reserved[11];\n} __packed;\n\nstruct kvaser_cmd_header {\n\tu8 cmd_no;\n\t \n\tu8 he_addr;\n\t__le16 transid;\n} __packed;\n\nstruct kvaser_cmd {\n\tstruct kvaser_cmd_header header;\n\tunion {\n\t\tstruct kvaser_cmd_map_ch_req map_ch_req;\n\t\tstruct kvaser_cmd_map_ch_res map_ch_res;\n\n\t\tstruct kvaser_cmd_card_info card_info;\n\t\tstruct kvaser_cmd_sw_info sw_info;\n\t\tstruct kvaser_cmd_sw_detail_req sw_detail_req;\n\t\tstruct kvaser_cmd_sw_detail_res sw_detail_res;\n\n\t\tstruct kvaser_cmd_cap_req cap_req;\n\t\tstruct kvaser_cmd_cap_res cap_res;\n\n\t\tstruct kvaser_cmd_error_event error_event;\n\n\t\tstruct kvaser_cmd_set_busparams set_busparams_req;\n\t\tstruct kvaser_cmd_get_busparams_req get_busparams_req;\n\t\tstruct kvaser_cmd_get_busparams_res get_busparams_res;\n\n\t\tstruct kvaser_cmd_chip_state_event chip_state_event;\n\n\t\tstruct kvaser_cmd_set_ctrlmode set_ctrlmode;\n\n\t\tstruct kvaser_cmd_rx_can rx_can;\n\t\tstruct kvaser_cmd_tx_can tx_can;\n\t} __packed;\n} __packed;\n\n \n#define KVASER_USB_HYDRA_CF_FLAG_ERROR_FRAME\tBIT(0)\n#define KVASER_USB_HYDRA_CF_FLAG_OVERRUN\tBIT(1)\n#define KVASER_USB_HYDRA_CF_FLAG_REMOTE_FRAME\tBIT(4)\n#define KVASER_USB_HYDRA_CF_FLAG_EXTENDED_ID\tBIT(5)\n#define KVASER_USB_HYDRA_CF_FLAG_TX_ACK\t\tBIT(6)\n \n#define KVASER_USB_HYDRA_CF_FLAG_OSM_NACK\tBIT(12)\n#define KVASER_USB_HYDRA_CF_FLAG_ABL\t\tBIT(13)\n#define KVASER_USB_HYDRA_CF_FLAG_FDF\t\tBIT(16)\n#define KVASER_USB_HYDRA_CF_FLAG_BRS\t\tBIT(17)\n#define KVASER_USB_HYDRA_CF_FLAG_ESI\t\tBIT(18)\n\n \n#define KVASER_USB_KCAN_DATA_DLC_BITS\t\t4\n#define KVASER_USB_KCAN_DATA_DLC_SHIFT\t\t8\n#define KVASER_USB_KCAN_DATA_DLC_MASK \\\n\t\t\t\tGENMASK(KVASER_USB_KCAN_DATA_DLC_BITS - 1 + \\\n\t\t\t\tKVASER_USB_KCAN_DATA_DLC_SHIFT, \\\n\t\t\t\tKVASER_USB_KCAN_DATA_DLC_SHIFT)\n\n#define KVASER_USB_KCAN_DATA_BRS\t\tBIT(14)\n#define KVASER_USB_KCAN_DATA_FDF\t\tBIT(15)\n#define KVASER_USB_KCAN_DATA_OSM\t\tBIT(16)\n#define KVASER_USB_KCAN_DATA_AREQ\t\tBIT(31)\n#define KVASER_USB_KCAN_DATA_SRR\t\tBIT(31)\n#define KVASER_USB_KCAN_DATA_RTR\t\tBIT(29)\n#define KVASER_USB_KCAN_DATA_IDE\t\tBIT(30)\nstruct kvaser_cmd_ext_rx_can {\n\t__le32 flags;\n\t__le32 id;\n\t__le32 kcan_id;\n\t__le32 kcan_header;\n\t__le64 timestamp;\n\tunion {\n\t\tu8 kcan_payload[64];\n\t\tstruct kvaser_err_frame_data err_frame_data;\n\t};\n} __packed;\n\nstruct kvaser_cmd_ext_tx_can {\n\t__le32 flags;\n\t__le32 id;\n\t__le32 kcan_id;\n\t__le32 kcan_header;\n\tu8 databytes;\n\tu8 dlc;\n\tu8 reserved[6];\n\tu8 kcan_payload[64];\n} __packed;\n\nstruct kvaser_cmd_ext_tx_ack {\n\t__le32 flags;\n\tu8 reserved0[4];\n\t__le64 timestamp;\n\tu8 reserved1[8];\n} __packed;\n\n \nstruct kvaser_cmd_ext {\n\tstruct kvaser_cmd_header header;\n\t__le16 len;\n\tu8 cmd_no_ext;\n\tu8 reserved;\n\n\tunion {\n\t\tstruct kvaser_cmd_ext_rx_can rx_can;\n\t\tstruct kvaser_cmd_ext_tx_can tx_can;\n\t\tstruct kvaser_cmd_ext_tx_ack tx_ack;\n\t} __packed;\n} __packed;\n\nstruct kvaser_usb_net_hydra_priv {\n\tint pending_get_busparams_type;\n};\n\nstatic const struct can_bittiming_const kvaser_usb_hydra_kcan_bittiming_c = {\n\t.name = \"kvaser_usb_kcan\",\n\t.tseg1_min = 1,\n\t.tseg1_max = 255,\n\t.tseg2_min = 1,\n\t.tseg2_max = 32,\n\t.sjw_max = 16,\n\t.brp_min = 1,\n\t.brp_max = 8192,\n\t.brp_inc = 1,\n};\n\nconst struct can_bittiming_const kvaser_usb_flexc_bittiming_const = {\n\t.name = \"kvaser_usb_flex\",\n\t.tseg1_min = 4,\n\t.tseg1_max = 16,\n\t.tseg2_min = 2,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 256,\n\t.brp_inc = 1,\n};\n\nstatic const struct can_bittiming_const kvaser_usb_hydra_rt_bittiming_c = {\n\t.name = \"kvaser_usb_rt\",\n\t.tseg1_min = 2,\n\t.tseg1_max = 96,\n\t.tseg2_min = 2,\n\t.tseg2_max = 32,\n\t.sjw_max = 32,\n\t.brp_min = 1,\n\t.brp_max = 1024,\n\t.brp_inc = 1,\n};\n\nstatic const struct can_bittiming_const kvaser_usb_hydra_rtd_bittiming_c = {\n\t.name = \"kvaser_usb_rt\",\n\t.tseg1_min = 2,\n\t.tseg1_max = 39,\n\t.tseg2_min = 2,\n\t.tseg2_max = 8,\n\t.sjw_max = 8,\n\t.brp_min = 1,\n\t.brp_max = 1024,\n\t.brp_inc = 1,\n};\n\n#define KVASER_USB_HYDRA_TRANSID_BITS\t\t12\n#define KVASER_USB_HYDRA_TRANSID_MASK \\\n\t\t\t\tGENMASK(KVASER_USB_HYDRA_TRANSID_BITS - 1, 0)\n#define KVASER_USB_HYDRA_HE_ADDR_SRC_MASK\tGENMASK(7, 6)\n#define KVASER_USB_HYDRA_HE_ADDR_DEST_MASK\tGENMASK(5, 0)\n#define KVASER_USB_HYDRA_HE_ADDR_SRC_BITS\t2\nstatic inline u16 kvaser_usb_hydra_get_cmd_transid(const struct kvaser_cmd *cmd)\n{\n\treturn le16_to_cpu(cmd->header.transid) & KVASER_USB_HYDRA_TRANSID_MASK;\n}\n\nstatic inline void kvaser_usb_hydra_set_cmd_transid(struct kvaser_cmd *cmd,\n\t\t\t\t\t\t    u16 transid)\n{\n\tcmd->header.transid =\n\t\t\tcpu_to_le16(transid & KVASER_USB_HYDRA_TRANSID_MASK);\n}\n\nstatic inline u8 kvaser_usb_hydra_get_cmd_src_he(const struct kvaser_cmd *cmd)\n{\n\treturn (cmd->header.he_addr & KVASER_USB_HYDRA_HE_ADDR_SRC_MASK) >>\n\t\tKVASER_USB_HYDRA_HE_ADDR_SRC_BITS |\n\t\tle16_to_cpu(cmd->header.transid) >>\n\t\tKVASER_USB_HYDRA_TRANSID_BITS;\n}\n\nstatic inline void kvaser_usb_hydra_set_cmd_dest_he(struct kvaser_cmd *cmd,\n\t\t\t\t\t\t    u8 dest_he)\n{\n\tcmd->header.he_addr =\n\t\t(cmd->header.he_addr & KVASER_USB_HYDRA_HE_ADDR_SRC_MASK) |\n\t\t(dest_he & KVASER_USB_HYDRA_HE_ADDR_DEST_MASK);\n}\n\nstatic u8 kvaser_usb_hydra_channel_from_cmd(const struct kvaser_usb *dev,\n\t\t\t\t\t    const struct kvaser_cmd *cmd)\n{\n\tint i;\n\tu8 channel = 0xff;\n\tu8 src_he = kvaser_usb_hydra_get_cmd_src_he(cmd);\n\n\tfor (i = 0; i < KVASER_USB_MAX_NET_DEVICES; i++) {\n\t\tif (dev->card_data.hydra.channel_to_he[i] == src_he) {\n\t\t\tchannel = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn channel;\n}\n\nstatic u16 kvaser_usb_hydra_get_next_transid(struct kvaser_usb *dev)\n{\n\tunsigned long flags;\n\tu16 transid;\n\tstruct kvaser_usb_dev_card_data_hydra *card_data =\n\t\t\t\t\t\t\t&dev->card_data.hydra;\n\n\tspin_lock_irqsave(&card_data->transid_lock, flags);\n\ttransid = card_data->transid;\n\tif (transid >= KVASER_USB_HYDRA_MAX_TRANSID)\n\t\ttransid = KVASER_USB_HYDRA_MIN_TRANSID;\n\telse\n\t\ttransid++;\n\tcard_data->transid = transid;\n\tspin_unlock_irqrestore(&card_data->transid_lock, flags);\n\n\treturn transid;\n}\n\nstatic size_t kvaser_usb_hydra_cmd_size(struct kvaser_cmd *cmd)\n{\n\tsize_t ret;\n\n\tif (cmd->header.cmd_no == CMD_EXTENDED)\n\t\tret = le16_to_cpu(((struct kvaser_cmd_ext *)cmd)->len);\n\telse\n\t\tret = sizeof(struct kvaser_cmd);\n\n\treturn ret;\n}\n\nstatic struct kvaser_usb_net_priv *\nkvaser_usb_hydra_net_priv_from_cmd(const struct kvaser_usb *dev,\n\t\t\t\t   const struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_usb_net_priv *priv = NULL;\n\tu8 channel = kvaser_usb_hydra_channel_from_cmd(dev, cmd);\n\n\tif (channel >= dev->nchannels)\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"Invalid channel number (%d)\\n\", channel);\n\telse\n\t\tpriv = dev->nets[channel];\n\n\treturn priv;\n}\n\nstatic ktime_t\nkvaser_usb_hydra_ktime_from_rx_cmd(const struct kvaser_usb_dev_cfg *cfg,\n\t\t\t\t   const struct kvaser_cmd *cmd)\n{\n\tu64 ticks;\n\n\tif (cmd->header.cmd_no == CMD_EXTENDED) {\n\t\tstruct kvaser_cmd_ext *cmd_ext = (struct kvaser_cmd_ext *)cmd;\n\n\t\tticks = le64_to_cpu(cmd_ext->rx_can.timestamp);\n\t} else {\n\t\tticks = le16_to_cpu(cmd->rx_can.timestamp[0]);\n\t\tticks += (u64)(le16_to_cpu(cmd->rx_can.timestamp[1])) << 16;\n\t\tticks += (u64)(le16_to_cpu(cmd->rx_can.timestamp[2])) << 32;\n\t}\n\n\treturn ns_to_ktime(div_u64(ticks * 1000, cfg->timestamp_freq));\n}\n\nstatic int kvaser_usb_hydra_send_simple_cmd(struct kvaser_usb *dev,\n\t\t\t\t\t    u8 cmd_no, int channel)\n{\n\tstruct kvaser_cmd *cmd;\n\tsize_t cmd_len;\n\tint err;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->header.cmd_no = cmd_no;\n\tcmd_len = kvaser_usb_hydra_cmd_size(cmd);\n\tif (channel < 0) {\n\t\tkvaser_usb_hydra_set_cmd_dest_he\n\t\t\t\t(cmd, KVASER_USB_HYDRA_HE_ADDRESS_ILLEGAL);\n\t} else {\n\t\tif (channel >= KVASER_USB_MAX_NET_DEVICES) {\n\t\t\tdev_err(&dev->intf->dev, \"channel (%d) out of range.\\n\",\n\t\t\t\tchannel);\n\t\t\terr = -EINVAL;\n\t\t\tgoto end;\n\t\t}\n\t\tkvaser_usb_hydra_set_cmd_dest_he\n\t\t\t(cmd, dev->card_data.hydra.channel_to_he[channel]);\n\t}\n\tkvaser_usb_hydra_set_cmd_transid\n\t\t\t\t(cmd, kvaser_usb_hydra_get_next_transid(dev));\n\n\terr = kvaser_usb_send_cmd(dev, cmd, cmd_len);\n\tif (err)\n\t\tgoto end;\n\nend:\n\tkfree(cmd);\n\n\treturn err;\n}\n\nstatic int\nkvaser_usb_hydra_send_simple_cmd_async(struct kvaser_usb_net_priv *priv,\n\t\t\t\t       u8 cmd_no)\n{\n\tstruct kvaser_cmd *cmd;\n\tstruct kvaser_usb *dev = priv->dev;\n\tsize_t cmd_len;\n\tint err;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_ATOMIC);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->header.cmd_no = cmd_no;\n\tcmd_len = kvaser_usb_hydra_cmd_size(cmd);\n\n\tkvaser_usb_hydra_set_cmd_dest_he\n\t\t(cmd, dev->card_data.hydra.channel_to_he[priv->channel]);\n\tkvaser_usb_hydra_set_cmd_transid\n\t\t\t\t(cmd, kvaser_usb_hydra_get_next_transid(dev));\n\n\terr = kvaser_usb_send_cmd_async(priv, cmd, cmd_len);\n\tif (err)\n\t\tkfree(cmd);\n\n\treturn err;\n}\n\n \nstatic int kvaser_usb_hydra_wait_cmd(const struct kvaser_usb *dev, u8 cmd_no,\n\t\t\t\t     struct kvaser_cmd *cmd)\n{\n\tvoid *buf;\n\tint err;\n\tunsigned long timeout = jiffies + msecs_to_jiffies(KVASER_USB_TIMEOUT);\n\n\tif (cmd->header.cmd_no == CMD_EXTENDED) {\n\t\tdev_err(&dev->intf->dev, \"Wait for CMD_EXTENDED not allowed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbuf = kzalloc(KVASER_USB_RX_BUFFER_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tdo {\n\t\tint actual_len = 0;\n\t\tint pos = 0;\n\n\t\terr = kvaser_usb_recv_cmd(dev, buf, KVASER_USB_RX_BUFFER_SIZE,\n\t\t\t\t\t  &actual_len);\n\t\tif (err < 0)\n\t\t\tgoto end;\n\n\t\twhile (pos < actual_len) {\n\t\t\tstruct kvaser_cmd *tmp_cmd;\n\t\t\tsize_t cmd_len;\n\n\t\t\ttmp_cmd = buf + pos;\n\t\t\tcmd_len = kvaser_usb_hydra_cmd_size(tmp_cmd);\n\t\t\tif (pos + cmd_len > actual_len) {\n\t\t\t\tdev_err_ratelimited(&dev->intf->dev,\n\t\t\t\t\t\t    \"Format error\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (tmp_cmd->header.cmd_no == cmd_no) {\n\t\t\t\tmemcpy(cmd, tmp_cmd, cmd_len);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tpos += cmd_len;\n\t\t}\n\t} while (time_before(jiffies, timeout));\n\n\terr = -EINVAL;\n\nend:\n\tkfree(buf);\n\n\treturn err;\n}\n\nstatic int kvaser_usb_hydra_map_channel_resp(struct kvaser_usb *dev,\n\t\t\t\t\t     const struct kvaser_cmd *cmd)\n{\n\tu8 he, channel;\n\tu16 transid = kvaser_usb_hydra_get_cmd_transid(cmd);\n\tstruct kvaser_usb_dev_card_data_hydra *card_data =\n\t\t\t\t\t\t\t&dev->card_data.hydra;\n\n\tif (transid > 0x007f || transid < 0x0040) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"CMD_MAP_CHANNEL_RESP, invalid transid: 0x%x\\n\",\n\t\t\ttransid);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (transid) {\n\tcase KVASER_USB_HYDRA_TRANSID_CANHE:\n\tcase KVASER_USB_HYDRA_TRANSID_CANHE + 1:\n\tcase KVASER_USB_HYDRA_TRANSID_CANHE + 2:\n\tcase KVASER_USB_HYDRA_TRANSID_CANHE + 3:\n\tcase KVASER_USB_HYDRA_TRANSID_CANHE + 4:\n\t\tchannel = transid & 0x000f;\n\t\the = cmd->map_ch_res.he_addr;\n\t\tcard_data->channel_to_he[channel] = he;\n\t\tbreak;\n\tcase KVASER_USB_HYDRA_TRANSID_SYSDBG:\n\t\tcard_data->sysdbg_he = cmd->map_ch_res.he_addr;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"Unknown CMD_MAP_CHANNEL_RESP transid=0x%x\\n\",\n\t\t\t transid);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_hydra_map_channel(struct kvaser_usb *dev, u16 transid,\n\t\t\t\t\tu8 channel, const char *name)\n{\n\tstruct kvaser_cmd *cmd;\n\tint err;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tstrcpy(cmd->map_ch_req.name, name);\n\tcmd->header.cmd_no = CMD_MAP_CHANNEL_REQ;\n\tkvaser_usb_hydra_set_cmd_dest_he\n\t\t\t\t(cmd, KVASER_USB_HYDRA_HE_ADDRESS_ROUTER);\n\tcmd->map_ch_req.channel = channel;\n\n\tkvaser_usb_hydra_set_cmd_transid(cmd, transid);\n\n\terr = kvaser_usb_send_cmd(dev, cmd, kvaser_usb_hydra_cmd_size(cmd));\n\tif (err)\n\t\tgoto end;\n\n\terr = kvaser_usb_hydra_wait_cmd(dev, CMD_MAP_CHANNEL_RESP, cmd);\n\tif (err)\n\t\tgoto end;\n\n\terr = kvaser_usb_hydra_map_channel_resp(dev, cmd);\n\tif (err)\n\t\tgoto end;\n\nend:\n\tkfree(cmd);\n\n\treturn err;\n}\n\nstatic int kvaser_usb_hydra_get_single_capability(struct kvaser_usb *dev,\n\t\t\t\t\t\t  u16 cap_cmd_req, u16 *status)\n{\n\tstruct kvaser_usb_dev_card_data *card_data = &dev->card_data;\n\tstruct kvaser_cmd *cmd;\n\tsize_t cmd_len;\n\tu32 value = 0;\n\tu32 mask = 0;\n\tu16 cap_cmd_res;\n\tint err;\n\tint i;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->header.cmd_no = CMD_GET_CAPABILITIES_REQ;\n\tcmd_len = kvaser_usb_hydra_cmd_size(cmd);\n\tcmd->cap_req.cap_cmd = cpu_to_le16(cap_cmd_req);\n\n\tkvaser_usb_hydra_set_cmd_dest_he(cmd, card_data->hydra.sysdbg_he);\n\tkvaser_usb_hydra_set_cmd_transid\n\t\t\t\t(cmd, kvaser_usb_hydra_get_next_transid(dev));\n\n\terr = kvaser_usb_send_cmd(dev, cmd, cmd_len);\n\tif (err)\n\t\tgoto end;\n\n\terr = kvaser_usb_hydra_wait_cmd(dev, CMD_GET_CAPABILITIES_RESP, cmd);\n\tif (err)\n\t\tgoto end;\n\n\t*status = le16_to_cpu(cmd->cap_res.status);\n\n\tif (*status != KVASER_USB_HYDRA_CAP_STAT_OK)\n\t\tgoto end;\n\n\tcap_cmd_res = le16_to_cpu(cmd->cap_res.cap_cmd);\n\tswitch (cap_cmd_res) {\n\tcase KVASER_USB_HYDRA_CAP_CMD_LISTEN_MODE:\n\tcase KVASER_USB_HYDRA_CAP_CMD_ERR_REPORT:\n\tcase KVASER_USB_HYDRA_CAP_CMD_ONE_SHOT:\n\t\tvalue = le32_to_cpu(cmd->cap_res.value);\n\t\tmask = le32_to_cpu(cmd->cap_res.mask);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&dev->intf->dev, \"Unknown capability command %u\\n\",\n\t\t\t cap_cmd_res);\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < dev->nchannels; i++) {\n\t\tif (BIT(i) & (value & mask)) {\n\t\t\tswitch (cap_cmd_res) {\n\t\t\tcase KVASER_USB_HYDRA_CAP_CMD_LISTEN_MODE:\n\t\t\t\tcard_data->ctrlmode_supported |=\n\t\t\t\t\t\tCAN_CTRLMODE_LISTENONLY;\n\t\t\t\tbreak;\n\t\t\tcase KVASER_USB_HYDRA_CAP_CMD_ERR_REPORT:\n\t\t\t\tcard_data->capabilities |=\n\t\t\t\t\t\tKVASER_USB_CAP_BERR_CAP;\n\t\t\t\tbreak;\n\t\t\tcase KVASER_USB_HYDRA_CAP_CMD_ONE_SHOT:\n\t\t\t\tcard_data->ctrlmode_supported |=\n\t\t\t\t\t\tCAN_CTRLMODE_ONE_SHOT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\nend:\n\tkfree(cmd);\n\n\treturn err;\n}\n\nstatic void kvaser_usb_hydra_start_chip_reply(const struct kvaser_usb *dev,\n\t\t\t\t\t      const struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_usb_net_priv *priv;\n\n\tpriv = kvaser_usb_hydra_net_priv_from_cmd(dev, cmd);\n\tif (!priv)\n\t\treturn;\n\n\tif (completion_done(&priv->start_comp) &&\n\t    netif_queue_stopped(priv->netdev)) {\n\t\tnetif_wake_queue(priv->netdev);\n\t} else {\n\t\tnetif_start_queue(priv->netdev);\n\t\tcomplete(&priv->start_comp);\n\t}\n}\n\nstatic void kvaser_usb_hydra_stop_chip_reply(const struct kvaser_usb *dev,\n\t\t\t\t\t     const struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_usb_net_priv *priv;\n\n\tpriv = kvaser_usb_hydra_net_priv_from_cmd(dev, cmd);\n\tif (!priv)\n\t\treturn;\n\n\tcomplete(&priv->stop_comp);\n}\n\nstatic void kvaser_usb_hydra_flush_queue_reply(const struct kvaser_usb *dev,\n\t\t\t\t\t       const struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_usb_net_priv *priv;\n\n\tpriv = kvaser_usb_hydra_net_priv_from_cmd(dev, cmd);\n\tif (!priv)\n\t\treturn;\n\n\tcomplete(&priv->flush_comp);\n}\n\nstatic void kvaser_usb_hydra_get_busparams_reply(const struct kvaser_usb *dev,\n\t\t\t\t\t\t const struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_usb_net_priv *priv;\n\tstruct kvaser_usb_net_hydra_priv *hydra;\n\n\tpriv = kvaser_usb_hydra_net_priv_from_cmd(dev, cmd);\n\tif (!priv)\n\t\treturn;\n\n\thydra = priv->sub_priv;\n\tif (!hydra)\n\t\treturn;\n\n\tswitch (hydra->pending_get_busparams_type) {\n\tcase KVASER_USB_HYDRA_BUSPARAM_TYPE_CAN:\n\t\tmemcpy(&priv->busparams_nominal, &cmd->get_busparams_res.busparams,\n\t\t       sizeof(priv->busparams_nominal));\n\t\tbreak;\n\tcase KVASER_USB_HYDRA_BUSPARAM_TYPE_CANFD:\n\t\tmemcpy(&priv->busparams_data, &cmd->get_busparams_res.busparams,\n\t\t       sizeof(priv->busparams_nominal));\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&dev->intf->dev, \"Unknown get_busparams_type %d\\n\",\n\t\t\t hydra->pending_get_busparams_type);\n\t\tbreak;\n\t}\n\thydra->pending_get_busparams_type = -1;\n\n\tcomplete(&priv->get_busparams_comp);\n}\n\nstatic void\nkvaser_usb_hydra_bus_status_to_can_state(const struct kvaser_usb_net_priv *priv,\n\t\t\t\t\t u8 bus_status,\n\t\t\t\t\t const struct can_berr_counter *bec,\n\t\t\t\t\t enum can_state *new_state)\n{\n\tif (bus_status & KVASER_USB_HYDRA_BUS_BUS_OFF) {\n\t\t*new_state = CAN_STATE_BUS_OFF;\n\t} else if (bus_status & KVASER_USB_HYDRA_BUS_ERR_PASS) {\n\t\t*new_state = CAN_STATE_ERROR_PASSIVE;\n\t} else if (bus_status == KVASER_USB_HYDRA_BUS_ERR_ACT) {\n\t\tif (bec->txerr >= 128 || bec->rxerr >= 128) {\n\t\t\tnetdev_warn(priv->netdev,\n\t\t\t\t    \"ERR_ACTIVE but err tx=%u or rx=%u >=128\\n\",\n\t\t\t\t    bec->txerr, bec->rxerr);\n\t\t\t*new_state = CAN_STATE_ERROR_PASSIVE;\n\t\t} else if (bec->txerr >= 96 || bec->rxerr >= 96) {\n\t\t\t*new_state = CAN_STATE_ERROR_WARNING;\n\t\t} else {\n\t\t\t*new_state = CAN_STATE_ERROR_ACTIVE;\n\t\t}\n\t}\n}\n\nstatic void kvaser_usb_hydra_update_state(struct kvaser_usb_net_priv *priv,\n\t\t\t\t\t  u8 bus_status,\n\t\t\t\t\t  const struct can_berr_counter *bec)\n{\n\tstruct net_device *netdev = priv->netdev;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tenum can_state new_state, old_state;\n\n\told_state = priv->can.state;\n\n\tkvaser_usb_hydra_bus_status_to_can_state(priv, bus_status, bec,\n\t\t\t\t\t\t &new_state);\n\n\tif (new_state == old_state)\n\t\treturn;\n\n\t \n\tif (old_state == CAN_STATE_STOPPED && new_state == CAN_STATE_BUS_OFF)\n\t\treturn;\n\n\tskb = alloc_can_err_skb(netdev, &cf);\n\tif (skb) {\n\t\tenum can_state tx_state, rx_state;\n\n\t\ttx_state = (bec->txerr >= bec->rxerr) ?\n\t\t\t\t\tnew_state : CAN_STATE_ERROR_ACTIVE;\n\t\trx_state = (bec->txerr <= bec->rxerr) ?\n\t\t\t\t\tnew_state : CAN_STATE_ERROR_ACTIVE;\n\t\tcan_change_state(netdev, cf, tx_state, rx_state);\n\t}\n\n\tif (new_state == CAN_STATE_BUS_OFF && old_state < CAN_STATE_BUS_OFF) {\n\t\tif (!priv->can.restart_ms)\n\t\t\tkvaser_usb_hydra_send_simple_cmd_async\n\t\t\t\t\t\t(priv, CMD_STOP_CHIP_REQ);\n\n\t\tcan_bus_off(netdev);\n\t}\n\n\tif (!skb) {\n\t\tnetdev_warn(netdev, \"No memory left for err_skb\\n\");\n\t\treturn;\n\t}\n\n\tif (priv->can.restart_ms &&\n\t    old_state >= CAN_STATE_BUS_OFF &&\n\t    new_state < CAN_STATE_BUS_OFF)\n\t\tpriv->can.can_stats.restarts++;\n\n\tif (new_state != CAN_STATE_BUS_OFF) {\n\t\tcf->can_id |= CAN_ERR_CNT;\n\t\tcf->data[6] = bec->txerr;\n\t\tcf->data[7] = bec->rxerr;\n\t}\n\n\tnetif_rx(skb);\n}\n\nstatic void kvaser_usb_hydra_state_event(const struct kvaser_usb *dev,\n\t\t\t\t\t const struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_usb_net_priv *priv;\n\tstruct can_berr_counter bec;\n\tu8 bus_status;\n\n\tpriv = kvaser_usb_hydra_net_priv_from_cmd(dev, cmd);\n\tif (!priv)\n\t\treturn;\n\n\tbus_status = cmd->chip_state_event.bus_status;\n\tbec.txerr = cmd->chip_state_event.tx_err_counter;\n\tbec.rxerr = cmd->chip_state_event.rx_err_counter;\n\n\tkvaser_usb_hydra_update_state(priv, bus_status, &bec);\n\tpriv->bec.txerr = bec.txerr;\n\tpriv->bec.rxerr = bec.rxerr;\n}\n\nstatic void kvaser_usb_hydra_error_event_parameter(const struct kvaser_usb *dev,\n\t\t\t\t\t\t   const struct kvaser_cmd *cmd)\n{\n\t \n\tswitch (le16_to_cpu(cmd->error_event.info1)) {\n\tcase CMD_START_CHIP_REQ:\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"CMD_START_CHIP_REQ error in parameter\\n\");\n\t\tbreak;\n\n\tcase CMD_STOP_CHIP_REQ:\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"CMD_STOP_CHIP_REQ error in parameter\\n\");\n\t\tbreak;\n\n\tcase CMD_FLUSH_QUEUE:\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"CMD_FLUSH_QUEUE error in parameter\\n\");\n\t\tbreak;\n\n\tcase CMD_SET_BUSPARAMS_REQ:\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"Set bittiming failed. Error in parameter\\n\");\n\t\tbreak;\n\n\tcase CMD_SET_BUSPARAMS_FD_REQ:\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"Set data bittiming failed. Error in parameter\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"Unhandled parameter error event cmd_no (%u)\\n\",\n\t\t\t le16_to_cpu(cmd->error_event.info1));\n\t\tbreak;\n\t}\n}\n\nstatic void kvaser_usb_hydra_error_event(const struct kvaser_usb *dev,\n\t\t\t\t\t const struct kvaser_cmd *cmd)\n{\n\tswitch (cmd->error_event.error_code) {\n\tcase KVASER_USB_HYDRA_ERROR_EVENT_PARAM:\n\t\tkvaser_usb_hydra_error_event_parameter(dev, cmd);\n\t\tbreak;\n\n\tcase KVASER_USB_HYDRA_ERROR_EVENT_CAN:\n\t\t \n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"Received CAN error event for cmd_no (%u)\\n\",\n\t\t\tle16_to_cpu(cmd->error_event.info1));\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(&dev->intf->dev,\n\t\t\t \"Unhandled error event (%d)\\n\",\n\t\t\t cmd->error_event.error_code);\n\t\tbreak;\n\t}\n}\n\nstatic void\nkvaser_usb_hydra_error_frame(struct kvaser_usb_net_priv *priv,\n\t\t\t     const struct kvaser_err_frame_data *err_frame_data,\n\t\t\t     ktime_t hwtstamp)\n{\n\tstruct net_device *netdev = priv->netdev;\n\tstruct net_device_stats *stats = &netdev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tstruct skb_shared_hwtstamps *shhwtstamps;\n\tstruct can_berr_counter bec;\n\tenum can_state new_state, old_state;\n\tu8 bus_status;\n\n\tpriv->can.can_stats.bus_error++;\n\tstats->rx_errors++;\n\n\tbus_status = err_frame_data->bus_status;\n\tbec.txerr = err_frame_data->tx_err_counter;\n\tbec.rxerr = err_frame_data->rx_err_counter;\n\n\told_state = priv->can.state;\n\tkvaser_usb_hydra_bus_status_to_can_state(priv, bus_status, &bec,\n\t\t\t\t\t\t &new_state);\n\n\tskb = alloc_can_err_skb(netdev, &cf);\n\n\tif (new_state != old_state) {\n\t\tif (skb) {\n\t\t\tenum can_state tx_state, rx_state;\n\n\t\t\ttx_state = (bec.txerr >= bec.rxerr) ?\n\t\t\t\t\tnew_state : CAN_STATE_ERROR_ACTIVE;\n\t\t\trx_state = (bec.txerr <= bec.rxerr) ?\n\t\t\t\t\tnew_state : CAN_STATE_ERROR_ACTIVE;\n\n\t\t\tcan_change_state(netdev, cf, tx_state, rx_state);\n\n\t\t\tif (priv->can.restart_ms &&\n\t\t\t    old_state >= CAN_STATE_BUS_OFF &&\n\t\t\t    new_state < CAN_STATE_BUS_OFF)\n\t\t\t\tcf->can_id |= CAN_ERR_RESTARTED;\n\t\t}\n\n\t\tif (new_state == CAN_STATE_BUS_OFF) {\n\t\t\tif (!priv->can.restart_ms)\n\t\t\t\tkvaser_usb_hydra_send_simple_cmd_async\n\t\t\t\t\t\t(priv, CMD_STOP_CHIP_REQ);\n\n\t\t\tcan_bus_off(netdev);\n\t\t}\n\t}\n\n\tif (!skb) {\n\t\tstats->rx_dropped++;\n\t\tnetdev_warn(netdev, \"No memory left for err_skb\\n\");\n\t\treturn;\n\t}\n\n\tshhwtstamps = skb_hwtstamps(skb);\n\tshhwtstamps->hwtstamp = hwtstamp;\n\n\tcf->can_id |= CAN_ERR_BUSERROR;\n\tif (new_state != CAN_STATE_BUS_OFF) {\n\t\tcf->can_id |= CAN_ERR_CNT;\n\t\tcf->data[6] = bec.txerr;\n\t\tcf->data[7] = bec.rxerr;\n\t}\n\n\tnetif_rx(skb);\n\n\tpriv->bec.txerr = bec.txerr;\n\tpriv->bec.rxerr = bec.rxerr;\n}\n\nstatic void kvaser_usb_hydra_one_shot_fail(struct kvaser_usb_net_priv *priv,\n\t\t\t\t\t   const struct kvaser_cmd_ext *cmd)\n{\n\tstruct net_device *netdev = priv->netdev;\n\tstruct net_device_stats *stats = &netdev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tu32 flags;\n\n\tskb = alloc_can_err_skb(netdev, &cf);\n\tif (!skb) {\n\t\tstats->rx_dropped++;\n\t\tnetdev_warn(netdev, \"No memory left for err_skb\\n\");\n\t\treturn;\n\t}\n\n\tcf->can_id |= CAN_ERR_BUSERROR;\n\tflags = le32_to_cpu(cmd->tx_ack.flags);\n\n\tif (flags & KVASER_USB_HYDRA_CF_FLAG_OSM_NACK)\n\t\tcf->can_id |= CAN_ERR_ACK;\n\tif (flags & KVASER_USB_HYDRA_CF_FLAG_ABL) {\n\t\tcf->can_id |= CAN_ERR_LOSTARB;\n\t\tpriv->can.can_stats.arbitration_lost++;\n\t}\n\n\tstats->tx_errors++;\n\tnetif_rx(skb);\n}\n\nstatic void kvaser_usb_hydra_tx_acknowledge(const struct kvaser_usb *dev,\n\t\t\t\t\t    const struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_usb_tx_urb_context *context;\n\tstruct kvaser_usb_net_priv *priv;\n\tunsigned long irq_flags;\n\tunsigned int len;\n\tbool one_shot_fail = false;\n\tbool is_err_frame = false;\n\tu16 transid = kvaser_usb_hydra_get_cmd_transid(cmd);\n\n\tpriv = kvaser_usb_hydra_net_priv_from_cmd(dev, cmd);\n\tif (!priv)\n\t\treturn;\n\n\tif (!netif_device_present(priv->netdev))\n\t\treturn;\n\n\tif (cmd->header.cmd_no == CMD_EXTENDED) {\n\t\tstruct kvaser_cmd_ext *cmd_ext = (struct kvaser_cmd_ext *)cmd;\n\t\tu32 flags = le32_to_cpu(cmd_ext->tx_ack.flags);\n\n\t\tif (flags & (KVASER_USB_HYDRA_CF_FLAG_OSM_NACK |\n\t\t\t     KVASER_USB_HYDRA_CF_FLAG_ABL)) {\n\t\t\tkvaser_usb_hydra_one_shot_fail(priv, cmd_ext);\n\t\t\tone_shot_fail = true;\n\t\t}\n\n\t\tis_err_frame = flags & KVASER_USB_HYDRA_CF_FLAG_TX_ACK &&\n\t\t\t       flags & KVASER_USB_HYDRA_CF_FLAG_ERROR_FRAME;\n\t}\n\n\tcontext = &priv->tx_contexts[transid % dev->max_tx_urbs];\n\n\tspin_lock_irqsave(&priv->tx_contexts_lock, irq_flags);\n\n\tlen = can_get_echo_skb(priv->netdev, context->echo_index, NULL);\n\tcontext->echo_index = dev->max_tx_urbs;\n\t--priv->active_tx_contexts;\n\tnetif_wake_queue(priv->netdev);\n\n\tspin_unlock_irqrestore(&priv->tx_contexts_lock, irq_flags);\n\n\tif (!one_shot_fail && !is_err_frame) {\n\t\tstruct net_device_stats *stats = &priv->netdev->stats;\n\n\t\tstats->tx_packets++;\n\t\tstats->tx_bytes += len;\n\t}\n}\n\nstatic void kvaser_usb_hydra_rx_msg_std(const struct kvaser_usb *dev,\n\t\t\t\t\tconst struct kvaser_cmd *cmd)\n{\n\tstruct kvaser_usb_net_priv *priv = NULL;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tstruct skb_shared_hwtstamps *shhwtstamps;\n\tstruct net_device_stats *stats;\n\tu8 flags;\n\tktime_t hwtstamp;\n\n\tpriv = kvaser_usb_hydra_net_priv_from_cmd(dev, cmd);\n\tif (!priv)\n\t\treturn;\n\n\tstats = &priv->netdev->stats;\n\n\tflags = cmd->rx_can.flags;\n\thwtstamp = kvaser_usb_hydra_ktime_from_rx_cmd(dev->cfg, cmd);\n\n\tif (flags & KVASER_USB_HYDRA_CF_FLAG_ERROR_FRAME) {\n\t\tkvaser_usb_hydra_error_frame(priv, &cmd->rx_can.err_frame_data,\n\t\t\t\t\t     hwtstamp);\n\t\treturn;\n\t}\n\n\tskb = alloc_can_skb(priv->netdev, &cf);\n\tif (!skb) {\n\t\tstats->rx_dropped++;\n\t\treturn;\n\t}\n\n\tshhwtstamps = skb_hwtstamps(skb);\n\tshhwtstamps->hwtstamp = hwtstamp;\n\n\tcf->can_id = le32_to_cpu(cmd->rx_can.id);\n\n\tif (cf->can_id &  KVASER_USB_HYDRA_EXTENDED_FRAME_ID) {\n\t\tcf->can_id &= CAN_EFF_MASK;\n\t\tcf->can_id |= CAN_EFF_FLAG;\n\t} else {\n\t\tcf->can_id &= CAN_SFF_MASK;\n\t}\n\n\tif (flags & KVASER_USB_HYDRA_CF_FLAG_OVERRUN)\n\t\tkvaser_usb_can_rx_over_error(priv->netdev);\n\n\tcan_frame_set_cc_len((struct can_frame *)cf, cmd->rx_can.dlc, priv->can.ctrlmode);\n\n\tif (flags & KVASER_USB_HYDRA_CF_FLAG_REMOTE_FRAME) {\n\t\tcf->can_id |= CAN_RTR_FLAG;\n\t} else {\n\t\tmemcpy(cf->data, cmd->rx_can.data, cf->len);\n\n\t\tstats->rx_bytes += cf->len;\n\t}\n\tstats->rx_packets++;\n\n\tnetif_rx(skb);\n}\n\nstatic void kvaser_usb_hydra_rx_msg_ext(const struct kvaser_usb *dev,\n\t\t\t\t\tconst struct kvaser_cmd_ext *cmd)\n{\n\tstruct kvaser_cmd *std_cmd = (struct kvaser_cmd *)cmd;\n\tstruct kvaser_usb_net_priv *priv;\n\tstruct canfd_frame *cf;\n\tstruct sk_buff *skb;\n\tstruct skb_shared_hwtstamps *shhwtstamps;\n\tstruct net_device_stats *stats;\n\tu32 flags;\n\tu8 dlc;\n\tu32 kcan_header;\n\tktime_t hwtstamp;\n\n\tpriv = kvaser_usb_hydra_net_priv_from_cmd(dev, std_cmd);\n\tif (!priv)\n\t\treturn;\n\n\tstats = &priv->netdev->stats;\n\n\tkcan_header = le32_to_cpu(cmd->rx_can.kcan_header);\n\tdlc = (kcan_header & KVASER_USB_KCAN_DATA_DLC_MASK) >>\n\t\tKVASER_USB_KCAN_DATA_DLC_SHIFT;\n\n\tflags = le32_to_cpu(cmd->rx_can.flags);\n\thwtstamp = kvaser_usb_hydra_ktime_from_rx_cmd(dev->cfg, std_cmd);\n\n\tif (flags & KVASER_USB_HYDRA_CF_FLAG_ERROR_FRAME) {\n\t\tkvaser_usb_hydra_error_frame(priv, &cmd->rx_can.err_frame_data,\n\t\t\t\t\t     hwtstamp);\n\t\treturn;\n\t}\n\n\tif (flags & KVASER_USB_HYDRA_CF_FLAG_FDF)\n\t\tskb = alloc_canfd_skb(priv->netdev, &cf);\n\telse\n\t\tskb = alloc_can_skb(priv->netdev, (struct can_frame **)&cf);\n\n\tif (!skb) {\n\t\tstats->rx_dropped++;\n\t\treturn;\n\t}\n\n\tshhwtstamps = skb_hwtstamps(skb);\n\tshhwtstamps->hwtstamp = hwtstamp;\n\n\tcf->can_id = le32_to_cpu(cmd->rx_can.id);\n\n\tif (flags & KVASER_USB_HYDRA_CF_FLAG_EXTENDED_ID) {\n\t\tcf->can_id &= CAN_EFF_MASK;\n\t\tcf->can_id |= CAN_EFF_FLAG;\n\t} else {\n\t\tcf->can_id &= CAN_SFF_MASK;\n\t}\n\n\tif (flags & KVASER_USB_HYDRA_CF_FLAG_OVERRUN)\n\t\tkvaser_usb_can_rx_over_error(priv->netdev);\n\n\tif (flags & KVASER_USB_HYDRA_CF_FLAG_FDF) {\n\t\tcf->len = can_fd_dlc2len(dlc);\n\t\tif (flags & KVASER_USB_HYDRA_CF_FLAG_BRS)\n\t\t\tcf->flags |= CANFD_BRS;\n\t\tif (flags & KVASER_USB_HYDRA_CF_FLAG_ESI)\n\t\t\tcf->flags |= CANFD_ESI;\n\t} else {\n\t\tcan_frame_set_cc_len((struct can_frame *)cf, dlc, priv->can.ctrlmode);\n\t}\n\n\tif (flags & KVASER_USB_HYDRA_CF_FLAG_REMOTE_FRAME) {\n\t\tcf->can_id |= CAN_RTR_FLAG;\n\t} else {\n\t\tmemcpy(cf->data, cmd->rx_can.kcan_payload, cf->len);\n\n\t\tstats->rx_bytes += cf->len;\n\t}\n\tstats->rx_packets++;\n\n\tnetif_rx(skb);\n}\n\nstatic void kvaser_usb_hydra_handle_cmd_std(const struct kvaser_usb *dev,\n\t\t\t\t\t    const struct kvaser_cmd *cmd)\n{\n\tswitch (cmd->header.cmd_no) {\n\tcase CMD_START_CHIP_RESP:\n\t\tkvaser_usb_hydra_start_chip_reply(dev, cmd);\n\t\tbreak;\n\n\tcase CMD_STOP_CHIP_RESP:\n\t\tkvaser_usb_hydra_stop_chip_reply(dev, cmd);\n\t\tbreak;\n\n\tcase CMD_FLUSH_QUEUE_RESP:\n\t\tkvaser_usb_hydra_flush_queue_reply(dev, cmd);\n\t\tbreak;\n\n\tcase CMD_CHIP_STATE_EVENT:\n\t\tkvaser_usb_hydra_state_event(dev, cmd);\n\t\tbreak;\n\n\tcase CMD_GET_BUSPARAMS_RESP:\n\t\tkvaser_usb_hydra_get_busparams_reply(dev, cmd);\n\t\tbreak;\n\n\tcase CMD_ERROR_EVENT:\n\t\tkvaser_usb_hydra_error_event(dev, cmd);\n\t\tbreak;\n\n\tcase CMD_TX_ACKNOWLEDGE:\n\t\tkvaser_usb_hydra_tx_acknowledge(dev, cmd);\n\t\tbreak;\n\n\tcase CMD_RX_MESSAGE:\n\t\tkvaser_usb_hydra_rx_msg_std(dev, cmd);\n\t\tbreak;\n\n\t \n\tcase CMD_SET_BUSPARAMS_RESP:\n\tcase CMD_SET_BUSPARAMS_FD_RESP:\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(&dev->intf->dev, \"Unhandled command (%d)\\n\",\n\t\t\t cmd->header.cmd_no);\n\t\tbreak;\n\t}\n}\n\nstatic void kvaser_usb_hydra_handle_cmd_ext(const struct kvaser_usb *dev,\n\t\t\t\t\t    const struct kvaser_cmd_ext *cmd)\n{\n\tswitch (cmd->cmd_no_ext) {\n\tcase CMD_TX_ACKNOWLEDGE_FD:\n\t\tkvaser_usb_hydra_tx_acknowledge(dev, (struct kvaser_cmd *)cmd);\n\t\tbreak;\n\n\tcase CMD_RX_MESSAGE_FD:\n\t\tkvaser_usb_hydra_rx_msg_ext(dev, cmd);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(&dev->intf->dev, \"Unhandled extended command (%d)\\n\",\n\t\t\t cmd->header.cmd_no);\n\t\tbreak;\n\t}\n}\n\nstatic void kvaser_usb_hydra_handle_cmd(const struct kvaser_usb *dev,\n\t\t\t\t\tconst struct kvaser_cmd *cmd)\n{\n\t\tif (cmd->header.cmd_no == CMD_EXTENDED)\n\t\t\tkvaser_usb_hydra_handle_cmd_ext\n\t\t\t\t\t(dev, (struct kvaser_cmd_ext *)cmd);\n\t\telse\n\t\t\tkvaser_usb_hydra_handle_cmd_std(dev, cmd);\n}\n\nstatic void *\nkvaser_usb_hydra_frame_to_cmd_ext(const struct kvaser_usb_net_priv *priv,\n\t\t\t\t  const struct sk_buff *skb, int *cmd_len,\n\t\t\t\t  u16 transid)\n{\n\tstruct kvaser_usb *dev = priv->dev;\n\tstruct kvaser_cmd_ext *cmd;\n\tstruct canfd_frame *cf = (struct canfd_frame *)skb->data;\n\tu8 dlc;\n\tu8 nbr_of_bytes = cf->len;\n\tu32 flags;\n\tu32 id;\n\tu32 kcan_id;\n\tu32 kcan_header;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_ATOMIC);\n\tif (!cmd)\n\t\treturn NULL;\n\n\tkvaser_usb_hydra_set_cmd_dest_he\n\t\t\t((struct kvaser_cmd *)cmd,\n\t\t\t dev->card_data.hydra.channel_to_he[priv->channel]);\n\tkvaser_usb_hydra_set_cmd_transid((struct kvaser_cmd *)cmd, transid);\n\n\tcmd->header.cmd_no = CMD_EXTENDED;\n\tcmd->cmd_no_ext = CMD_TX_CAN_MESSAGE_FD;\n\n\t*cmd_len = ALIGN(sizeof(struct kvaser_cmd_ext) -\n\t\t\t sizeof(cmd->tx_can.kcan_payload) + nbr_of_bytes,\n\t\t\t 8);\n\n\tcmd->len = cpu_to_le16(*cmd_len);\n\n\tif (can_is_canfd_skb(skb))\n\t\tdlc = can_fd_len2dlc(cf->len);\n\telse\n\t\tdlc = can_get_cc_dlc((struct can_frame *)cf, priv->can.ctrlmode);\n\n\tcmd->tx_can.databytes = nbr_of_bytes;\n\tcmd->tx_can.dlc = dlc;\n\n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\tid = cf->can_id & CAN_EFF_MASK;\n\t\tflags = KVASER_USB_HYDRA_CF_FLAG_EXTENDED_ID;\n\t\tkcan_id = (cf->can_id & CAN_EFF_MASK) |\n\t\t\t  KVASER_USB_KCAN_DATA_IDE | KVASER_USB_KCAN_DATA_SRR;\n\t} else {\n\t\tid = cf->can_id & CAN_SFF_MASK;\n\t\tflags = 0;\n\t\tkcan_id = cf->can_id & CAN_SFF_MASK;\n\t}\n\n\tif (cf->can_id & CAN_ERR_FLAG)\n\t\tflags |= KVASER_USB_HYDRA_CF_FLAG_ERROR_FRAME;\n\n\tkcan_header = ((dlc << KVASER_USB_KCAN_DATA_DLC_SHIFT) &\n\t\t\t\tKVASER_USB_KCAN_DATA_DLC_MASK) |\n\t\t\tKVASER_USB_KCAN_DATA_AREQ |\n\t\t\t(priv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT ?\n\t\t\t\tKVASER_USB_KCAN_DATA_OSM : 0);\n\n\tif (can_is_canfd_skb(skb)) {\n\t\tkcan_header |= KVASER_USB_KCAN_DATA_FDF |\n\t\t\t       (cf->flags & CANFD_BRS ?\n\t\t\t\t\tKVASER_USB_KCAN_DATA_BRS : 0);\n\t} else {\n\t\tif (cf->can_id & CAN_RTR_FLAG) {\n\t\t\tkcan_id |= KVASER_USB_KCAN_DATA_RTR;\n\t\t\tcmd->tx_can.databytes = 0;\n\t\t\tflags |= KVASER_USB_HYDRA_CF_FLAG_REMOTE_FRAME;\n\t\t}\n\t}\n\n\tcmd->tx_can.kcan_id = cpu_to_le32(kcan_id);\n\tcmd->tx_can.id = cpu_to_le32(id);\n\tcmd->tx_can.flags = cpu_to_le32(flags);\n\tcmd->tx_can.kcan_header = cpu_to_le32(kcan_header);\n\n\tmemcpy(cmd->tx_can.kcan_payload, cf->data, nbr_of_bytes);\n\n\treturn cmd;\n}\n\nstatic void *\nkvaser_usb_hydra_frame_to_cmd_std(const struct kvaser_usb_net_priv *priv,\n\t\t\t\t  const struct sk_buff *skb, int *cmd_len,\n\t\t\t\t  u16 transid)\n{\n\tstruct kvaser_usb *dev = priv->dev;\n\tstruct kvaser_cmd *cmd;\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tu32 flags;\n\tu32 id;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_ATOMIC);\n\tif (!cmd)\n\t\treturn NULL;\n\n\tkvaser_usb_hydra_set_cmd_dest_he\n\t\t(cmd, dev->card_data.hydra.channel_to_he[priv->channel]);\n\tkvaser_usb_hydra_set_cmd_transid(cmd, transid);\n\n\tcmd->header.cmd_no = CMD_TX_CAN_MESSAGE;\n\n\t*cmd_len = ALIGN(sizeof(struct kvaser_cmd), 8);\n\n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\tid = (cf->can_id & CAN_EFF_MASK);\n\t\tid |= KVASER_USB_HYDRA_EXTENDED_FRAME_ID;\n\t} else {\n\t\tid = cf->can_id & CAN_SFF_MASK;\n\t}\n\n\tcmd->tx_can.dlc = can_get_cc_dlc(cf, priv->can.ctrlmode);\n\n\tflags = (cf->can_id & CAN_EFF_FLAG ?\n\t\t KVASER_USB_HYDRA_CF_FLAG_EXTENDED_ID : 0);\n\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tflags |= KVASER_USB_HYDRA_CF_FLAG_REMOTE_FRAME;\n\n\tflags |= (cf->can_id & CAN_ERR_FLAG ?\n\t\t  KVASER_USB_HYDRA_CF_FLAG_ERROR_FRAME : 0);\n\n\tcmd->tx_can.id = cpu_to_le32(id);\n\tcmd->tx_can.flags = flags;\n\n\tmemcpy(cmd->tx_can.data, cf->data, cf->len);\n\n\treturn cmd;\n}\n\nstatic int kvaser_usb_hydra_set_mode(struct net_device *netdev,\n\t\t\t\t     enum can_mode mode)\n{\n\tint err = 0;\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\nstatic int kvaser_usb_hydra_get_busparams(struct kvaser_usb_net_priv *priv,\n\t\t\t\t\t  int busparams_type)\n{\n\tstruct kvaser_usb *dev = priv->dev;\n\tstruct kvaser_usb_net_hydra_priv *hydra = priv->sub_priv;\n\tstruct kvaser_cmd *cmd;\n\tsize_t cmd_len;\n\tint err;\n\n\tif (!hydra)\n\t\treturn -EINVAL;\n\n\tcmd = kcalloc(1, sizeof(struct kvaser_cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->header.cmd_no = CMD_GET_BUSPARAMS_REQ;\n\tcmd_len = kvaser_usb_hydra_cmd_size(cmd);\n\tkvaser_usb_hydra_set_cmd_dest_he\n\t\t(cmd, dev->card_data.hydra.channel_to_he[priv->channel]);\n\tkvaser_usb_hydra_set_cmd_transid\n\t\t\t\t(cmd, kvaser_usb_hydra_get_next_transid(dev));\n\tcmd->get_busparams_req.type = busparams_type;\n\thydra->pending_get_busparams_type = busparams_type;\n\n\treinit_completion(&priv->get_busparams_comp);\n\n\terr = kvaser_usb_send_cmd(dev, cmd, cmd_len);\n\tif (err)\n\t\treturn err;\n\n\tif (!wait_for_completion_timeout(&priv->get_busparams_comp,\n\t\t\t\t\t msecs_to_jiffies(KVASER_USB_TIMEOUT)))\n\t\treturn -ETIMEDOUT;\n\n\treturn err;\n}\n\nstatic int kvaser_usb_hydra_get_nominal_busparams(struct kvaser_usb_net_priv *priv)\n{\n\treturn kvaser_usb_hydra_get_busparams(priv, KVASER_USB_HYDRA_BUSPARAM_TYPE_CAN);\n}\n\nstatic int kvaser_usb_hydra_get_data_busparams(struct kvaser_usb_net_priv *priv)\n{\n\treturn kvaser_usb_hydra_get_busparams(priv, KVASER_USB_HYDRA_BUSPARAM_TYPE_CANFD);\n}\n\nstatic int kvaser_usb_hydra_set_bittiming(const struct net_device *netdev,\n\t\t\t\t\t  const struct kvaser_usb_busparams *busparams)\n{\n\tstruct kvaser_cmd *cmd;\n\tstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\n\tstruct kvaser_usb *dev = priv->dev;\n\tsize_t cmd_len;\n\tint err;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->header.cmd_no = CMD_SET_BUSPARAMS_REQ;\n\tcmd_len = kvaser_usb_hydra_cmd_size(cmd);\n\tmemcpy(&cmd->set_busparams_req.busparams_nominal, busparams,\n\t       sizeof(cmd->set_busparams_req.busparams_nominal));\n\n\tkvaser_usb_hydra_set_cmd_dest_he\n\t\t(cmd, dev->card_data.hydra.channel_to_he[priv->channel]);\n\tkvaser_usb_hydra_set_cmd_transid\n\t\t\t\t(cmd, kvaser_usb_hydra_get_next_transid(dev));\n\n\terr = kvaser_usb_send_cmd(dev, cmd, cmd_len);\n\n\tkfree(cmd);\n\n\treturn err;\n}\n\nstatic int kvaser_usb_hydra_set_data_bittiming(const struct net_device *netdev,\n\t\t\t\t\t       const struct kvaser_usb_busparams *busparams)\n{\n\tstruct kvaser_cmd *cmd;\n\tstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\n\tstruct kvaser_usb *dev = priv->dev;\n\tsize_t cmd_len;\n\tint err;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->header.cmd_no = CMD_SET_BUSPARAMS_FD_REQ;\n\tcmd_len = kvaser_usb_hydra_cmd_size(cmd);\n\tmemcpy(&cmd->set_busparams_req.busparams_data, busparams,\n\t       sizeof(cmd->set_busparams_req.busparams_data));\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_FD) {\n\t\tif (priv->can.ctrlmode & CAN_CTRLMODE_FD_NON_ISO)\n\t\t\tcmd->set_busparams_req.canfd_mode =\n\t\t\t\t\tKVASER_USB_HYDRA_BUS_MODE_NONISO;\n\t\telse\n\t\t\tcmd->set_busparams_req.canfd_mode =\n\t\t\t\t\tKVASER_USB_HYDRA_BUS_MODE_CANFD_ISO;\n\t}\n\n\tkvaser_usb_hydra_set_cmd_dest_he\n\t\t(cmd, dev->card_data.hydra.channel_to_he[priv->channel]);\n\tkvaser_usb_hydra_set_cmd_transid\n\t\t\t\t(cmd, kvaser_usb_hydra_get_next_transid(dev));\n\n\terr = kvaser_usb_send_cmd(dev, cmd, cmd_len);\n\n\tkfree(cmd);\n\n\treturn err;\n}\n\nstatic int kvaser_usb_hydra_get_berr_counter(const struct net_device *netdev,\n\t\t\t\t\t     struct can_berr_counter *bec)\n{\n\tstruct kvaser_usb_net_priv *priv = netdev_priv(netdev);\n\tint err;\n\n\terr = kvaser_usb_hydra_send_simple_cmd(priv->dev,\n\t\t\t\t\t       CMD_GET_CHIP_STATE_REQ,\n\t\t\t\t\t       priv->channel);\n\tif (err)\n\t\treturn err;\n\n\t*bec = priv->bec;\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_hydra_setup_endpoints(struct kvaser_usb *dev)\n{\n\tconst struct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *ep;\n\tint i;\n\n\tiface_desc = dev->intf->cur_altsetting;\n\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tep = &iface_desc->endpoint[i].desc;\n\n\t\tif (!dev->bulk_in && usb_endpoint_is_bulk_in(ep) &&\n\t\t    ep->bEndpointAddress == KVASER_USB_HYDRA_BULK_EP_IN_ADDR)\n\t\t\tdev->bulk_in = ep;\n\n\t\tif (!dev->bulk_out && usb_endpoint_is_bulk_out(ep) &&\n\t\t    ep->bEndpointAddress == KVASER_USB_HYDRA_BULK_EP_OUT_ADDR)\n\t\t\tdev->bulk_out = ep;\n\n\t\tif (dev->bulk_in && dev->bulk_out)\n\t\t\treturn 0;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic int kvaser_usb_hydra_init_card(struct kvaser_usb *dev)\n{\n\tint err;\n\tunsigned int i;\n\tstruct kvaser_usb_dev_card_data_hydra *card_data =\n\t\t\t\t\t\t\t&dev->card_data.hydra;\n\n\tcard_data->transid = KVASER_USB_HYDRA_MIN_TRANSID;\n\tspin_lock_init(&card_data->transid_lock);\n\n\tmemset(card_data->usb_rx_leftover, 0, KVASER_USB_HYDRA_MAX_CMD_LEN);\n\tcard_data->usb_rx_leftover_len = 0;\n\tspin_lock_init(&card_data->usb_rx_leftover_lock);\n\n\tmemset(card_data->channel_to_he, KVASER_USB_HYDRA_HE_ADDRESS_ILLEGAL,\n\t       sizeof(card_data->channel_to_he));\n\tcard_data->sysdbg_he = 0;\n\n\tfor (i = 0; i < KVASER_USB_MAX_NET_DEVICES; i++) {\n\t\terr = kvaser_usb_hydra_map_channel\n\t\t\t\t\t(dev,\n\t\t\t\t\t (KVASER_USB_HYDRA_TRANSID_CANHE | i),\n\t\t\t\t\t i, \"CAN\");\n\t\tif (err) {\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"CMD_MAP_CHANNEL_REQ failed for CAN%u\\n\", i);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = kvaser_usb_hydra_map_channel(dev, KVASER_USB_HYDRA_TRANSID_SYSDBG,\n\t\t\t\t\t   0, \"SYSDBG\");\n\tif (err) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"CMD_MAP_CHANNEL_REQ failed for SYSDBG\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_hydra_init_channel(struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_usb_net_hydra_priv *hydra;\n\n\thydra = devm_kzalloc(&priv->dev->intf->dev, sizeof(*hydra), GFP_KERNEL);\n\tif (!hydra)\n\t\treturn -ENOMEM;\n\n\tpriv->sub_priv = hydra;\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_hydra_get_software_info(struct kvaser_usb *dev)\n{\n\tstruct kvaser_cmd cmd;\n\tint err;\n\n\terr = kvaser_usb_hydra_send_simple_cmd(dev, CMD_GET_SOFTWARE_INFO_REQ,\n\t\t\t\t\t       -1);\n\tif (err)\n\t\treturn err;\n\n\tmemset(&cmd, 0, sizeof(struct kvaser_cmd));\n\terr = kvaser_usb_hydra_wait_cmd(dev, CMD_GET_SOFTWARE_INFO_RESP, &cmd);\n\tif (err)\n\t\treturn err;\n\n\tdev->max_tx_urbs = min_t(unsigned int, KVASER_USB_MAX_TX_URBS,\n\t\t\t\t le16_to_cpu(cmd.sw_info.max_outstanding_tx));\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_hydra_get_software_details(struct kvaser_usb *dev)\n{\n\tstruct kvaser_cmd *cmd;\n\tsize_t cmd_len;\n\tint err;\n\tu32 flags;\n\tstruct kvaser_usb_dev_card_data *card_data = &dev->card_data;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->header.cmd_no = CMD_GET_SOFTWARE_DETAILS_REQ;\n\tcmd_len = kvaser_usb_hydra_cmd_size(cmd);\n\tcmd->sw_detail_req.use_ext_cmd = 1;\n\tkvaser_usb_hydra_set_cmd_dest_he\n\t\t\t\t(cmd, KVASER_USB_HYDRA_HE_ADDRESS_ILLEGAL);\n\n\tkvaser_usb_hydra_set_cmd_transid\n\t\t\t\t(cmd, kvaser_usb_hydra_get_next_transid(dev));\n\n\terr = kvaser_usb_send_cmd(dev, cmd, cmd_len);\n\tif (err)\n\t\tgoto end;\n\n\terr = kvaser_usb_hydra_wait_cmd(dev, CMD_GET_SOFTWARE_DETAILS_RESP,\n\t\t\t\t\tcmd);\n\tif (err)\n\t\tgoto end;\n\n\tdev->fw_version = le32_to_cpu(cmd->sw_detail_res.sw_version);\n\tflags = le32_to_cpu(cmd->sw_detail_res.sw_flags);\n\n\tif (flags & KVASER_USB_HYDRA_SW_FLAG_FW_BAD) {\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"Bad firmware, device refuse to run!\\n\");\n\t\terr = -EINVAL;\n\t\tgoto end;\n\t}\n\n\tif (flags & KVASER_USB_HYDRA_SW_FLAG_FW_BETA)\n\t\tdev_info(&dev->intf->dev, \"Beta firmware in use\\n\");\n\n\tif (flags & KVASER_USB_HYDRA_SW_FLAG_EXT_CAP)\n\t\tcard_data->capabilities |= KVASER_USB_CAP_EXT_CAP;\n\n\tif (flags & KVASER_USB_HYDRA_SW_FLAG_EXT_CMD)\n\t\tcard_data->capabilities |= KVASER_USB_HYDRA_CAP_EXT_CMD;\n\n\tif (flags & KVASER_USB_HYDRA_SW_FLAG_CANFD)\n\t\tcard_data->ctrlmode_supported |= CAN_CTRLMODE_FD;\n\n\tif (flags & KVASER_USB_HYDRA_SW_FLAG_NONISO)\n\t\tcard_data->ctrlmode_supported |= CAN_CTRLMODE_FD_NON_ISO;\n\n\tif (flags &  KVASER_USB_HYDRA_SW_FLAG_FREQ_80M)\n\t\tdev->cfg = &kvaser_usb_hydra_dev_cfg_kcan;\n\telse if (flags & KVASER_USB_HYDRA_SW_FLAG_CAN_FREQ_80M)\n\t\tdev->cfg = &kvaser_usb_hydra_dev_cfg_rt;\n\telse\n\t\tdev->cfg = &kvaser_usb_hydra_dev_cfg_flexc;\n\nend:\n\tkfree(cmd);\n\n\treturn err;\n}\n\nstatic int kvaser_usb_hydra_get_card_info(struct kvaser_usb *dev)\n{\n\tstruct kvaser_cmd cmd;\n\tint err;\n\n\terr = kvaser_usb_hydra_send_simple_cmd(dev, CMD_GET_CARD_INFO_REQ, -1);\n\tif (err)\n\t\treturn err;\n\n\tmemset(&cmd, 0, sizeof(struct kvaser_cmd));\n\terr = kvaser_usb_hydra_wait_cmd(dev, CMD_GET_CARD_INFO_RESP, &cmd);\n\tif (err)\n\t\treturn err;\n\n\tdev->nchannels = cmd.card_info.nchannels;\n\tif (dev->nchannels > KVASER_USB_MAX_NET_DEVICES)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_hydra_get_capabilities(struct kvaser_usb *dev)\n{\n\tint err;\n\tu16 status;\n\n\tif (!(dev->card_data.capabilities & KVASER_USB_CAP_EXT_CAP)) {\n\t\tdev_info(&dev->intf->dev,\n\t\t\t \"No extended capability support. Upgrade your device.\\n\");\n\t\treturn 0;\n\t}\n\n\terr = kvaser_usb_hydra_get_single_capability\n\t\t\t\t\t(dev,\n\t\t\t\t\t KVASER_USB_HYDRA_CAP_CMD_LISTEN_MODE,\n\t\t\t\t\t &status);\n\tif (err)\n\t\treturn err;\n\tif (status)\n\t\tdev_info(&dev->intf->dev,\n\t\t\t \"KVASER_USB_HYDRA_CAP_CMD_LISTEN_MODE failed %u\\n\",\n\t\t\t status);\n\n\terr = kvaser_usb_hydra_get_single_capability\n\t\t\t\t\t(dev,\n\t\t\t\t\t KVASER_USB_HYDRA_CAP_CMD_ERR_REPORT,\n\t\t\t\t\t &status);\n\tif (err)\n\t\treturn err;\n\tif (status)\n\t\tdev_info(&dev->intf->dev,\n\t\t\t \"KVASER_USB_HYDRA_CAP_CMD_ERR_REPORT failed %u\\n\",\n\t\t\t status);\n\n\terr = kvaser_usb_hydra_get_single_capability\n\t\t\t\t\t(dev, KVASER_USB_HYDRA_CAP_CMD_ONE_SHOT,\n\t\t\t\t\t &status);\n\tif (err)\n\t\treturn err;\n\tif (status)\n\t\tdev_info(&dev->intf->dev,\n\t\t\t \"KVASER_USB_HYDRA_CAP_CMD_ONE_SHOT failed %u\\n\",\n\t\t\t status);\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_hydra_set_opt_mode(const struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_usb *dev = priv->dev;\n\tstruct kvaser_cmd *cmd;\n\tsize_t cmd_len;\n\tint err;\n\n\tif ((priv->can.ctrlmode &\n\t    (CAN_CTRLMODE_FD | CAN_CTRLMODE_FD_NON_ISO)) ==\n\t    CAN_CTRLMODE_FD_NON_ISO) {\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"CTRLMODE_FD shall be on if CTRLMODE_FD_NON_ISO is on\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->header.cmd_no = CMD_SET_DRIVERMODE_REQ;\n\tcmd_len = kvaser_usb_hydra_cmd_size(cmd);\n\tkvaser_usb_hydra_set_cmd_dest_he\n\t\t(cmd, dev->card_data.hydra.channel_to_he[priv->channel]);\n\tkvaser_usb_hydra_set_cmd_transid\n\t\t\t\t(cmd, kvaser_usb_hydra_get_next_transid(dev));\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tcmd->set_ctrlmode.mode = KVASER_USB_HYDRA_CTRLMODE_LISTEN;\n\telse\n\t\tcmd->set_ctrlmode.mode = KVASER_USB_HYDRA_CTRLMODE_NORMAL;\n\n\terr = kvaser_usb_send_cmd(dev, cmd, cmd_len);\n\tkfree(cmd);\n\n\treturn err;\n}\n\nstatic int kvaser_usb_hydra_start_chip(struct kvaser_usb_net_priv *priv)\n{\n\tint err;\n\n\treinit_completion(&priv->start_comp);\n\n\terr = kvaser_usb_hydra_send_simple_cmd(priv->dev, CMD_START_CHIP_REQ,\n\t\t\t\t\t       priv->channel);\n\tif (err)\n\t\treturn err;\n\n\tif (!wait_for_completion_timeout(&priv->start_comp,\n\t\t\t\t\t msecs_to_jiffies(KVASER_USB_TIMEOUT)))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_hydra_stop_chip(struct kvaser_usb_net_priv *priv)\n{\n\tint err;\n\n\treinit_completion(&priv->stop_comp);\n\n\t \n\tpriv->can.state = CAN_STATE_STOPPED;\n\n\terr = kvaser_usb_hydra_send_simple_cmd(priv->dev, CMD_STOP_CHIP_REQ,\n\t\t\t\t\t       priv->channel);\n\tif (err)\n\t\treturn err;\n\n\tif (!wait_for_completion_timeout(&priv->stop_comp,\n\t\t\t\t\t msecs_to_jiffies(KVASER_USB_TIMEOUT)))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int kvaser_usb_hydra_flush_queue(struct kvaser_usb_net_priv *priv)\n{\n\tint err;\n\n\treinit_completion(&priv->flush_comp);\n\n\terr = kvaser_usb_hydra_send_simple_cmd(priv->dev, CMD_FLUSH_QUEUE,\n\t\t\t\t\t       priv->channel);\n\tif (err)\n\t\treturn err;\n\n\tif (!wait_for_completion_timeout(&priv->flush_comp,\n\t\t\t\t\t msecs_to_jiffies(KVASER_USB_TIMEOUT)))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\n \nstatic void kvaser_usb_hydra_read_bulk_callback(struct kvaser_usb *dev,\n\t\t\t\t\t\tvoid *buf, int len)\n{\n\tunsigned long irq_flags;\n\tstruct kvaser_cmd *cmd;\n\tint pos = 0;\n\tsize_t cmd_len;\n\tstruct kvaser_usb_dev_card_data_hydra *card_data =\n\t\t\t\t\t\t\t&dev->card_data.hydra;\n\tint usb_rx_leftover_len;\n\tspinlock_t *usb_rx_leftover_lock = &card_data->usb_rx_leftover_lock;\n\n\tspin_lock_irqsave(usb_rx_leftover_lock, irq_flags);\n\tusb_rx_leftover_len = card_data->usb_rx_leftover_len;\n\tif (usb_rx_leftover_len) {\n\t\tint remaining_bytes;\n\n\t\tcmd = (struct kvaser_cmd *)card_data->usb_rx_leftover;\n\n\t\tcmd_len = kvaser_usb_hydra_cmd_size(cmd);\n\n\t\tremaining_bytes = min_t(unsigned int, len,\n\t\t\t\t\tcmd_len - usb_rx_leftover_len);\n\t\t \n\t\tif (remaining_bytes + usb_rx_leftover_len >\n\t\t\t\t\t\tKVASER_USB_HYDRA_MAX_CMD_LEN) {\n\t\t\tdev_err(&dev->intf->dev, \"Format error\\n\");\n\t\t\tspin_unlock_irqrestore(usb_rx_leftover_lock, irq_flags);\n\t\t\treturn;\n\t\t}\n\n\t\tmemcpy(card_data->usb_rx_leftover + usb_rx_leftover_len, buf,\n\t\t       remaining_bytes);\n\t\tpos += remaining_bytes;\n\n\t\tif (remaining_bytes + usb_rx_leftover_len == cmd_len) {\n\t\t\tkvaser_usb_hydra_handle_cmd(dev, cmd);\n\t\t\tusb_rx_leftover_len = 0;\n\t\t} else {\n\t\t\t \n\t\t\tusb_rx_leftover_len += remaining_bytes;\n\t\t}\n\t\tcard_data->usb_rx_leftover_len = usb_rx_leftover_len;\n\t}\n\tspin_unlock_irqrestore(usb_rx_leftover_lock, irq_flags);\n\n\twhile (pos < len) {\n\t\tcmd = buf + pos;\n\n\t\tcmd_len = kvaser_usb_hydra_cmd_size(cmd);\n\n\t\tif (pos + cmd_len > len) {\n\t\t\t \n\t\t\tint leftover_bytes;\n\n\t\t\tleftover_bytes = len - pos;\n\t\t\t \n\t\t\tif (leftover_bytes > KVASER_USB_HYDRA_MAX_CMD_LEN) {\n\t\t\t\tdev_err(&dev->intf->dev, \"Format error\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tspin_lock_irqsave(usb_rx_leftover_lock, irq_flags);\n\t\t\tmemcpy(card_data->usb_rx_leftover, buf + pos,\n\t\t\t       leftover_bytes);\n\t\t\tcard_data->usb_rx_leftover_len = leftover_bytes;\n\t\t\tspin_unlock_irqrestore(usb_rx_leftover_lock, irq_flags);\n\t\t\tbreak;\n\t\t}\n\n\t\tkvaser_usb_hydra_handle_cmd(dev, cmd);\n\t\tpos += cmd_len;\n\t}\n}\n\nstatic void *\nkvaser_usb_hydra_frame_to_cmd(const struct kvaser_usb_net_priv *priv,\n\t\t\t      const struct sk_buff *skb, int *cmd_len,\n\t\t\t      u16 transid)\n{\n\tvoid *buf;\n\n\tif (priv->dev->card_data.capabilities & KVASER_USB_HYDRA_CAP_EXT_CMD)\n\t\tbuf = kvaser_usb_hydra_frame_to_cmd_ext(priv, skb, cmd_len,\n\t\t\t\t\t\t\ttransid);\n\telse\n\t\tbuf = kvaser_usb_hydra_frame_to_cmd_std(priv, skb, cmd_len,\n\t\t\t\t\t\t\ttransid);\n\n\treturn buf;\n}\n\nconst struct kvaser_usb_dev_ops kvaser_usb_hydra_dev_ops = {\n\t.dev_set_mode = kvaser_usb_hydra_set_mode,\n\t.dev_set_bittiming = kvaser_usb_hydra_set_bittiming,\n\t.dev_get_busparams = kvaser_usb_hydra_get_nominal_busparams,\n\t.dev_set_data_bittiming = kvaser_usb_hydra_set_data_bittiming,\n\t.dev_get_data_busparams = kvaser_usb_hydra_get_data_busparams,\n\t.dev_get_berr_counter = kvaser_usb_hydra_get_berr_counter,\n\t.dev_setup_endpoints = kvaser_usb_hydra_setup_endpoints,\n\t.dev_init_card = kvaser_usb_hydra_init_card,\n\t.dev_init_channel = kvaser_usb_hydra_init_channel,\n\t.dev_get_software_info = kvaser_usb_hydra_get_software_info,\n\t.dev_get_software_details = kvaser_usb_hydra_get_software_details,\n\t.dev_get_card_info = kvaser_usb_hydra_get_card_info,\n\t.dev_get_capabilities = kvaser_usb_hydra_get_capabilities,\n\t.dev_set_opt_mode = kvaser_usb_hydra_set_opt_mode,\n\t.dev_start_chip = kvaser_usb_hydra_start_chip,\n\t.dev_stop_chip = kvaser_usb_hydra_stop_chip,\n\t.dev_reset_chip = NULL,\n\t.dev_flush_queue = kvaser_usb_hydra_flush_queue,\n\t.dev_read_bulk_callback = kvaser_usb_hydra_read_bulk_callback,\n\t.dev_frame_to_cmd = kvaser_usb_hydra_frame_to_cmd,\n};\n\nstatic const struct kvaser_usb_dev_cfg kvaser_usb_hydra_dev_cfg_kcan = {\n\t.clock = {\n\t\t.freq = 80 * MEGA  ,\n\t},\n\t.timestamp_freq = 80,\n\t.bittiming_const = &kvaser_usb_hydra_kcan_bittiming_c,\n\t.data_bittiming_const = &kvaser_usb_hydra_kcan_bittiming_c,\n};\n\nstatic const struct kvaser_usb_dev_cfg kvaser_usb_hydra_dev_cfg_flexc = {\n\t.clock = {\n\t\t.freq = 24 * MEGA  ,\n\t},\n\t.timestamp_freq = 1,\n\t.bittiming_const = &kvaser_usb_flexc_bittiming_const,\n};\n\nstatic const struct kvaser_usb_dev_cfg kvaser_usb_hydra_dev_cfg_rt = {\n\t.clock = {\n\t\t.freq = 80 * MEGA  ,\n\t},\n\t.timestamp_freq = 24,\n\t.bittiming_const = &kvaser_usb_hydra_rt_bittiming_c,\n\t.data_bittiming_const = &kvaser_usb_hydra_rtd_bittiming_c,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}