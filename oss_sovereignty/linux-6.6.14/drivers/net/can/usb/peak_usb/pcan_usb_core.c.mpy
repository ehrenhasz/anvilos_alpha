{
  "module_name": "pcan_usb_core.c",
  "hash_id": "080f590c2afd500ee22e3111a175b88c7229bbfe97051424f79f2ffede62e159",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/usb/peak_usb/pcan_usb_core.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/ethtool.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/signal.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/usb.h>\n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n\n#include \"pcan_usb_core.h\"\n\nMODULE_AUTHOR(\"Stephane Grosjean <s.grosjean@peak-system.com>\");\nMODULE_DESCRIPTION(\"CAN driver for PEAK-System USB adapters\");\nMODULE_LICENSE(\"GPL v2\");\n\n \nstatic const struct usb_device_id peak_usb_table[] = {\n\t{\n\t\tUSB_DEVICE(PCAN_USB_VENDOR_ID, PCAN_USB_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&pcan_usb,\n\t}, {\n\t\tUSB_DEVICE(PCAN_USB_VENDOR_ID, PCAN_USBPRO_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&pcan_usb_pro,\n\t}, {\n\t\tUSB_DEVICE(PCAN_USB_VENDOR_ID, PCAN_USBFD_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&pcan_usb_fd,\n\t}, {\n\t\tUSB_DEVICE(PCAN_USB_VENDOR_ID, PCAN_USBPROFD_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&pcan_usb_pro_fd,\n\t}, {\n\t\tUSB_DEVICE(PCAN_USB_VENDOR_ID, PCAN_USBCHIP_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&pcan_usb_chip,\n\t}, {\n\t\tUSB_DEVICE(PCAN_USB_VENDOR_ID, PCAN_USBX6_PRODUCT_ID),\n\t\t.driver_info = (kernel_ulong_t)&pcan_usb_x6,\n\t}, {\n\t\t \n\t}\n};\n\nMODULE_DEVICE_TABLE(usb, peak_usb_table);\n\nstatic ssize_t can_channel_id_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct net_device *netdev = to_net_dev(dev);\n\tstruct peak_usb_device *peak_dev = netdev_priv(netdev);\n\n\treturn sysfs_emit(buf, \"%08X\\n\", peak_dev->can_channel_id);\n}\nstatic DEVICE_ATTR_RO(can_channel_id);\n\n \nstatic struct attribute *peak_usb_sysfs_attrs[] = {\n\t&dev_attr_can_channel_id.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group peak_usb_sysfs_group = {\n\t.name\t= \"peak_usb\",\n\t.attrs\t= peak_usb_sysfs_attrs,\n};\n\n \n#define DUMP_WIDTH\t16\nvoid pcan_dump_mem(const char *prompt, const void *p, int l)\n{\n\tpr_info(\"%s dumping %s (%d bytes):\\n\",\n\t\tPCAN_USB_DRIVER_NAME, prompt ? prompt : \"memory\", l);\n\tprint_hex_dump(KERN_INFO, PCAN_USB_DRIVER_NAME \" \", DUMP_PREFIX_NONE,\n\t\t       DUMP_WIDTH, 1, p, l, false);\n}\n\n \nvoid peak_usb_init_time_ref(struct peak_time_ref *time_ref,\n\t\t\t    const struct peak_usb_adapter *adapter)\n{\n\tif (time_ref) {\n\t\tmemset(time_ref, 0, sizeof(struct peak_time_ref));\n\t\ttime_ref->adapter = adapter;\n\t}\n}\n\n \nvoid peak_usb_update_ts_now(struct peak_time_ref *time_ref, u32 ts_now)\n{\n\ttime_ref->ts_dev_2 = ts_now;\n\n\t \n\tif (ktime_to_ns(time_ref->tv_host) > 0) {\n\t\tu32 delta_ts = time_ref->ts_dev_2 - time_ref->ts_dev_1;\n\n\t\tif (time_ref->ts_dev_2 < time_ref->ts_dev_1)\n\t\t\tdelta_ts &= (1 << time_ref->adapter->ts_used_bits) - 1;\n\n\t\ttime_ref->ts_total += delta_ts;\n\t}\n}\n\n \nvoid peak_usb_set_ts_now(struct peak_time_ref *time_ref, u32 ts_now)\n{\n\tif (ktime_to_ns(time_ref->tv_host_0) == 0) {\n\t\t \n\t\ttime_ref->tv_host_0 = ktime_get();\n\t\ttime_ref->tv_host = ktime_set(0, 0);\n\t} else {\n\t\t \n\t\tif (ktime_to_ns(time_ref->tv_host)) {\n\t\t\tktime_t delta = ktime_sub(time_ref->tv_host,\n\t\t\t\t\t\t  time_ref->tv_host_0);\n\t\t\tif (ktime_to_ns(delta) > (4200ull * NSEC_PER_SEC)) {\n\t\t\t\ttime_ref->tv_host_0 = time_ref->tv_host;\n\t\t\t\ttime_ref->ts_total = 0;\n\t\t\t}\n\t\t}\n\n\t\ttime_ref->tv_host = ktime_get();\n\t\ttime_ref->tick_count++;\n\t}\n\n\ttime_ref->ts_dev_1 = time_ref->ts_dev_2;\n\tpeak_usb_update_ts_now(time_ref, ts_now);\n}\n\n \nvoid peak_usb_get_ts_time(struct peak_time_ref *time_ref, u32 ts, ktime_t *time)\n{\n\t \n\tif (ktime_to_ns(time_ref->tv_host)) {\n\t\tu64 delta_us;\n\t\ts64 delta_ts = 0;\n\n\t\t \n\t\tif (time_ref->ts_dev_1 < time_ref->ts_dev_2) {\n\t\t\t \n\t\t\tif (ts < time_ref->ts_dev_1)\n\t\t\t\tdelta_ts = BIT_ULL(time_ref->adapter->ts_used_bits);\n\n\t\t \n\t\t} else if (time_ref->ts_dev_1 < ts) {\n\t\t\tdelta_ts = -BIT_ULL(time_ref->adapter->ts_used_bits);\n\t\t}\n\n\t\t \n\t\tdelta_ts += (signed int)(ts - time_ref->ts_dev_2);\n\n\t\t \n\t\tdelta_ts += time_ref->ts_total;\n\n\t\t \n\t\tdelta_us = delta_ts * time_ref->adapter->us_per_ts_scale;\n\t\tdelta_us >>= time_ref->adapter->us_per_ts_shift;\n\n\t\t*time = ktime_add_us(time_ref->tv_host_0, delta_us);\n\t} else {\n\t\t*time = ktime_get();\n\t}\n}\n\n \nint peak_usb_netif_rx_64(struct sk_buff *skb, u32 ts_low, u32 ts_high)\n{\n\tstruct skb_shared_hwtstamps *hwts = skb_hwtstamps(skb);\n\tu64 ns_ts;\n\n\tns_ts = (u64)ts_high << 32 | ts_low;\n\tns_ts *= NSEC_PER_USEC;\n\thwts->hwtstamp = ns_to_ktime(ns_ts);\n\n\treturn netif_rx(skb);\n}\n\n \nstatic void peak_usb_read_bulk_callback(struct urb *urb)\n{\n\tstruct peak_usb_device *dev = urb->context;\n\tstruct net_device *netdev;\n\tint err;\n\n\tnetdev = dev->netdev;\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\t \n\tswitch (urb->status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\n\tcase -EILSEQ:\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\n\tdefault:\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Rx urb aborted (%d)\\n\", urb->status);\n\t\tgoto resubmit_urb;\n\t}\n\n\t \n\tif ((urb->actual_length > 0) && (dev->adapter->dev_decode_buf)) {\n\t\t \n\t\tif (dev->state & PCAN_USB_STATE_STARTED) {\n\t\t\terr = dev->adapter->dev_decode_buf(dev, urb);\n\t\t\tif (err)\n\t\t\t\tpcan_dump_mem(\"received usb message\",\n\t\t\t\t\t      urb->transfer_buffer,\n\t\t\t\t\t      urb->transfer_buffer_length);\n\t\t}\n\t}\n\nresubmit_urb:\n\tusb_fill_bulk_urb(urb, dev->udev,\n\t\tusb_rcvbulkpipe(dev->udev, dev->ep_msg_in),\n\t\turb->transfer_buffer, dev->adapter->rx_buffer_size,\n\t\tpeak_usb_read_bulk_callback, dev);\n\n\tusb_anchor_urb(urb, &dev->rx_submitted);\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (!err)\n\t\treturn;\n\n\tusb_unanchor_urb(urb);\n\n\tif (err == -ENODEV)\n\t\tnetif_device_detach(netdev);\n\telse\n\t\tnetdev_err(netdev, \"failed resubmitting read bulk urb: %d\\n\",\n\t\t\t   err);\n}\n\n \nstatic void peak_usb_write_bulk_callback(struct urb *urb)\n{\n\tstruct peak_tx_urb_context *context = urb->context;\n\tstruct peak_usb_device *dev;\n\tstruct net_device *netdev;\n\tint tx_bytes;\n\n\tBUG_ON(!context);\n\n\tdev = context->dev;\n\tnetdev = dev->netdev;\n\n\tatomic_dec(&dev->active_tx_urbs);\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\t \n\tswitch (urb->status) {\n\tcase 0:\n\t\t \n\t\tnetif_trans_update(netdev);\n\t\tbreak;\n\n\tcase -EPROTO:\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\t\tbreak;\n\n\tdefault:\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(netdev, \"Tx urb aborted (%d)\\n\",\n\t\t\t\t   urb->status);\n\t\tbreak;\n\t}\n\n\t \n\ttx_bytes = can_get_echo_skb(netdev, context->echo_index, NULL);\n\tcontext->echo_index = PCAN_USB_MAX_TX_URBS;\n\n\tif (!urb->status) {\n\t\t \n\t\tnetdev->stats.tx_packets++;\n\t\tnetdev->stats.tx_bytes += tx_bytes;\n\n\t\t \n\t\tnetif_wake_queue(netdev);\n\t}\n}\n\n \nstatic netdev_tx_t peak_usb_ndo_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t   struct net_device *netdev)\n{\n\tstruct peak_usb_device *dev = netdev_priv(netdev);\n\tstruct peak_tx_urb_context *context = NULL;\n\tstruct net_device_stats *stats = &netdev->stats;\n\tstruct urb *urb;\n\tu8 *obuf;\n\tint i, err;\n\tsize_t size = dev->adapter->tx_buffer_size;\n\n\tif (can_dev_dropped_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tfor (i = 0; i < PCAN_USB_MAX_TX_URBS; i++)\n\t\tif (dev->tx_contexts[i].echo_index == PCAN_USB_MAX_TX_URBS) {\n\t\t\tcontext = dev->tx_contexts + i;\n\t\t\tbreak;\n\t\t}\n\n\tif (!context) {\n\t\t \n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\turb = context->urb;\n\tobuf = urb->transfer_buffer;\n\n\terr = dev->adapter->dev_encode_msg(dev, skb, obuf, &size);\n\tif (err) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(netdev, \"packet dropped\\n\");\n\t\tdev_kfree_skb(skb);\n\t\tstats->tx_dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tcontext->echo_index = i;\n\n\tusb_anchor_urb(urb, &dev->tx_submitted);\n\n\tcan_put_echo_skb(skb, netdev, context->echo_index, 0);\n\n\tatomic_inc(&dev->active_tx_urbs);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err) {\n\t\tcan_free_echo_skb(netdev, context->echo_index, NULL);\n\n\t\tusb_unanchor_urb(urb);\n\n\t\t \n\t\tcontext->echo_index = PCAN_USB_MAX_TX_URBS;\n\n\t\tatomic_dec(&dev->active_tx_urbs);\n\n\t\tswitch (err) {\n\t\tcase -ENODEV:\n\t\t\tnetif_device_detach(netdev);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetdev_warn(netdev, \"tx urb submitting failed err=%d\\n\",\n\t\t\t\t    err);\n\t\t\tfallthrough;\n\t\tcase -ENOENT:\n\t\t\t \n\t\t\tstats->tx_dropped++;\n\t\t}\n\t} else {\n\t\tnetif_trans_update(netdev);\n\n\t\t \n\t\tif (atomic_read(&dev->active_tx_urbs) >= PCAN_USB_MAX_TX_URBS)\n\t\t\tnetif_stop_queue(netdev);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic int peak_usb_start(struct peak_usb_device *dev)\n{\n\tstruct net_device *netdev = dev->netdev;\n\tint err, i;\n\n\tfor (i = 0; i < PCAN_USB_MAX_RX_URBS; i++) {\n\t\tstruct urb *urb;\n\t\tu8 *buf;\n\n\t\t \n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf = kmalloc(dev->adapter->rx_buffer_size, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tusb_free_urb(urb);\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tusb_fill_bulk_urb(urb, dev->udev,\n\t\t\tusb_rcvbulkpipe(dev->udev, dev->ep_msg_in),\n\t\t\tbuf, dev->adapter->rx_buffer_size,\n\t\t\tpeak_usb_read_bulk_callback, dev);\n\n\t\t \n\t\turb->transfer_flags |= URB_FREE_BUFFER;\n\t\tusb_anchor_urb(urb, &dev->rx_submitted);\n\n\t\terr = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (err) {\n\t\t\tif (err == -ENODEV)\n\t\t\t\tnetif_device_detach(dev->netdev);\n\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tkfree(buf);\n\t\t\tusb_free_urb(urb);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tusb_free_urb(urb);\n\t}\n\n\t \n\tif (i < PCAN_USB_MAX_RX_URBS) {\n\t\tif (i == 0) {\n\t\t\tnetdev_err(netdev, \"couldn't setup any rx URB\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\tnetdev_warn(netdev, \"rx performance may be slow\\n\");\n\t}\n\n\t \n\tfor (i = 0; i < PCAN_USB_MAX_TX_URBS; i++) {\n\t\tstruct peak_tx_urb_context *context;\n\t\tstruct urb *urb;\n\t\tu8 *buf;\n\n\t\t \n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf = kmalloc(dev->adapter->tx_buffer_size, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tusb_free_urb(urb);\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tcontext = dev->tx_contexts + i;\n\t\tcontext->dev = dev;\n\t\tcontext->urb = urb;\n\n\t\tusb_fill_bulk_urb(urb, dev->udev,\n\t\t\tusb_sndbulkpipe(dev->udev, dev->ep_msg_out),\n\t\t\tbuf, dev->adapter->tx_buffer_size,\n\t\t\tpeak_usb_write_bulk_callback, context);\n\n\t\t \n\t\turb->transfer_flags |= URB_FREE_BUFFER;\n\t}\n\n\t \n\tif (i < PCAN_USB_MAX_TX_URBS) {\n\t\tif (i == 0) {\n\t\t\tnetdev_err(netdev, \"couldn't setup any tx URB\\n\");\n\t\t\tgoto err_tx;\n\t\t}\n\n\t\tnetdev_warn(netdev, \"tx performance may be slow\\n\");\n\t}\n\n\tif (dev->adapter->dev_start) {\n\t\terr = dev->adapter->dev_start(dev);\n\t\tif (err)\n\t\t\tgoto err_adapter;\n\t}\n\n\tdev->state |= PCAN_USB_STATE_STARTED;\n\n\t \n\tif (dev->adapter->dev_set_bus) {\n\t\terr = dev->adapter->dev_set_bus(dev, 1);\n\t\tif (err)\n\t\t\tgoto err_adapter;\n\t}\n\n\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\treturn 0;\n\nerr_adapter:\n\tif (err == -ENODEV)\n\t\tnetif_device_detach(dev->netdev);\n\n\tnetdev_warn(netdev, \"couldn't submit control: %d\\n\", err);\n\n\tfor (i = 0; i < PCAN_USB_MAX_TX_URBS; i++) {\n\t\tusb_free_urb(dev->tx_contexts[i].urb);\n\t\tdev->tx_contexts[i].urb = NULL;\n\t}\nerr_tx:\n\tusb_kill_anchored_urbs(&dev->rx_submitted);\n\n\treturn err;\n}\n\n \nstatic int peak_usb_ndo_open(struct net_device *netdev)\n{\n\tstruct peak_usb_device *dev = netdev_priv(netdev);\n\tint err;\n\n\t \n\terr = open_candev(netdev);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = peak_usb_start(dev);\n\tif (err) {\n\t\tnetdev_err(netdev, \"couldn't start device: %d\\n\", err);\n\t\tclose_candev(netdev);\n\t\treturn err;\n\t}\n\n\tnetif_start_queue(netdev);\n\n\treturn 0;\n}\n\n \nstatic void peak_usb_unlink_all_urbs(struct peak_usb_device *dev)\n{\n\tint i;\n\n\t \n\tusb_kill_anchored_urbs(&dev->rx_submitted);\n\n\t \n\tfor (i = 0; i < PCAN_USB_MAX_TX_URBS; i++) {\n\t\tstruct urb *urb = dev->tx_contexts[i].urb;\n\n\t\tif (!urb ||\n\t\t    dev->tx_contexts[i].echo_index != PCAN_USB_MAX_TX_URBS) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tusb_free_urb(urb);\n\t\tdev->tx_contexts[i].urb = NULL;\n\t}\n\n\t \n\tusb_kill_anchored_urbs(&dev->tx_submitted);\n\tatomic_set(&dev->active_tx_urbs, 0);\n}\n\n \nstatic int peak_usb_ndo_stop(struct net_device *netdev)\n{\n\tstruct peak_usb_device *dev = netdev_priv(netdev);\n\n\tdev->state &= ~PCAN_USB_STATE_STARTED;\n\tnetif_stop_queue(netdev);\n\n\tclose_candev(netdev);\n\n\tdev->can.state = CAN_STATE_STOPPED;\n\n\t \n\tpeak_usb_unlink_all_urbs(dev);\n\n\tif (dev->adapter->dev_stop)\n\t\tdev->adapter->dev_stop(dev);\n\n\t \n\tif (dev->adapter->dev_set_bus) {\n\t\tint err = dev->adapter->dev_set_bus(dev, 0);\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nvoid peak_usb_restart_complete(struct peak_usb_device *dev)\n{\n\t \n\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\t \n\tnetif_wake_queue(dev->netdev);\n}\n\nvoid peak_usb_async_complete(struct urb *urb)\n{\n\tkfree(urb->transfer_buffer);\n\tusb_free_urb(urb);\n}\n\n \nstatic int peak_usb_restart(struct peak_usb_device *dev)\n{\n\tstruct urb *urb;\n\tint err;\n\tu8 *buf;\n\n\t \n\tif (!dev->adapter->dev_restart_async) {\n\t\tpeak_usb_restart_complete(dev);\n\t\treturn 0;\n\t}\n\n\t \n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\t \n\tbuf = kmalloc(PCAN_USB_MAX_CMD_LEN, GFP_ATOMIC);\n\tif (!buf) {\n\t\tusb_free_urb(urb);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\terr = dev->adapter->dev_restart_async(dev, urb, buf);\n\tif (!err)\n\t\treturn 0;\n\n\tkfree(buf);\n\tusb_free_urb(urb);\n\n\treturn err;\n}\n\n \nstatic int peak_usb_set_mode(struct net_device *netdev, enum can_mode mode)\n{\n\tstruct peak_usb_device *dev = netdev_priv(netdev);\n\tint err = 0;\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\terr = peak_usb_restart(dev);\n\t\tif (err)\n\t\t\tnetdev_err(netdev, \"couldn't start device (err %d)\\n\",\n\t\t\t\t   err);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\n \nstatic int peak_usb_set_bittiming(struct net_device *netdev)\n{\n\tstruct peak_usb_device *dev = netdev_priv(netdev);\n\tconst struct peak_usb_adapter *pa = dev->adapter;\n\n\tif (pa->dev_set_bittiming) {\n\t\tstruct can_bittiming *bt = &dev->can.bittiming;\n\t\tint err = pa->dev_set_bittiming(dev, bt);\n\n\t\tif (err)\n\t\t\tnetdev_info(netdev, \"couldn't set bitrate (err %d)\\n\",\n\t\t\t\t    err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int peak_usb_set_data_bittiming(struct net_device *netdev)\n{\n\tstruct peak_usb_device *dev = netdev_priv(netdev);\n\tconst struct peak_usb_adapter *pa = dev->adapter;\n\n\tif (pa->dev_set_data_bittiming) {\n\t\tstruct can_bittiming *bt = &dev->can.data_bittiming;\n\t\tint err = pa->dev_set_data_bittiming(dev, bt);\n\n\t\tif (err)\n\t\t\tnetdev_info(netdev,\n\t\t\t\t    \"couldn't set data bitrate (err %d)\\n\",\n\t\t\t\t    err);\n\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int peak_eth_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\n{\n\tstruct hwtstamp_config hwts_cfg = { 0 };\n\n\tswitch (cmd) {\n\tcase SIOCSHWTSTAMP:  \n\t\tif (copy_from_user(&hwts_cfg, ifr->ifr_data, sizeof(hwts_cfg)))\n\t\t\treturn -EFAULT;\n\t\tif (hwts_cfg.tx_type == HWTSTAMP_TX_OFF &&\n\t\t    hwts_cfg.rx_filter == HWTSTAMP_FILTER_ALL)\n\t\t\treturn 0;\n\t\treturn -ERANGE;\n\n\tcase SIOCGHWTSTAMP:  \n\t\thwts_cfg.tx_type = HWTSTAMP_TX_OFF;\n\t\thwts_cfg.rx_filter = HWTSTAMP_FILTER_ALL;\n\t\tif (copy_to_user(ifr->ifr_data, &hwts_cfg, sizeof(hwts_cfg)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct net_device_ops peak_usb_netdev_ops = {\n\t.ndo_open = peak_usb_ndo_open,\n\t.ndo_stop = peak_usb_ndo_stop,\n\t.ndo_eth_ioctl = peak_eth_ioctl,\n\t.ndo_start_xmit = peak_usb_ndo_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\n \nint peak_usb_get_eeprom_len(struct net_device *netdev)\n{\n\treturn sizeof(u32);\n}\n\n \nint peak_usb_get_eeprom(struct net_device *netdev,\n\t\t\tstruct ethtool_eeprom *eeprom, u8 *data)\n{\n\tstruct peak_usb_device *dev = netdev_priv(netdev);\n\tu32 ch_id;\n\t__le32 ch_id_le;\n\tint err;\n\n\terr = dev->adapter->dev_get_can_channel_id(dev, &ch_id);\n\tif (err)\n\t\treturn err;\n\n\t \n\tch_id_le = cpu_to_le32(ch_id);\n\tmemcpy(data, (u8 *)&ch_id_le + eeprom->offset, eeprom->len);\n\n\t \n\tdev->can_channel_id = ch_id;\n\treturn err;\n}\n\n \nint peak_usb_set_eeprom(struct net_device *netdev,\n\t\t\tstruct ethtool_eeprom *eeprom, u8 *data)\n{\n\tstruct peak_usb_device *dev = netdev_priv(netdev);\n\tu32 ch_id;\n\t__le32 ch_id_le;\n\tint err;\n\n\t \n\terr = dev->adapter->dev_get_can_channel_id(dev, &ch_id);\n\tif (err) {\n\t\tnetdev_err(netdev, \"Failed to init CAN channel id (err %d)\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tch_id_le = cpu_to_le32(ch_id);\n\tmemcpy((u8 *)&ch_id_le + eeprom->offset, data, eeprom->len);\n\tch_id = le32_to_cpu(ch_id_le);\n\n\t \n\terr = dev->adapter->dev_set_can_channel_id(dev, ch_id);\n\tif (err) {\n\t\tnetdev_err(netdev, \"Failed to write new CAN channel id (err %d)\\n\",\n\t\t\t   err);\n\t\treturn err;\n\t}\n\n\t \n\tdev->can_channel_id = ch_id;\n\n\treturn 0;\n}\n\nint pcan_get_ts_info(struct net_device *dev, struct ethtool_ts_info *info)\n{\n\tinfo->so_timestamping =\n\t\tSOF_TIMESTAMPING_TX_SOFTWARE |\n\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\tSOF_TIMESTAMPING_SOFTWARE |\n\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\tinfo->phc_index = -1;\n\tinfo->tx_types = BIT(HWTSTAMP_TX_OFF);\n\tinfo->rx_filters = BIT(HWTSTAMP_FILTER_ALL);\n\n\treturn 0;\n}\n\n \nstatic int peak_usb_create_dev(const struct peak_usb_adapter *peak_usb_adapter,\n\t\t\t       struct usb_interface *intf, int ctrl_idx)\n{\n\tstruct usb_device *usb_dev = interface_to_usbdev(intf);\n\tint sizeof_candev = peak_usb_adapter->sizeof_dev_private;\n\tstruct peak_usb_device *dev;\n\tstruct net_device *netdev;\n\tint i, err;\n\tu16 tmp16;\n\n\tif (sizeof_candev < sizeof(struct peak_usb_device))\n\t\tsizeof_candev = sizeof(struct peak_usb_device);\n\n\tnetdev = alloc_candev(sizeof_candev, PCAN_USB_MAX_TX_URBS);\n\tif (!netdev) {\n\t\tdev_err(&intf->dev, \"%s: couldn't alloc candev\\n\",\n\t\t\tPCAN_USB_DRIVER_NAME);\n\t\treturn -ENOMEM;\n\t}\n\n\tdev = netdev_priv(netdev);\n\n\t \n\tdev->cmd_buf = kzalloc(PCAN_USB_MAX_CMD_LEN, GFP_KERNEL);\n\tif (!dev->cmd_buf) {\n\t\terr = -ENOMEM;\n\t\tgoto lbl_free_candev;\n\t}\n\n\tdev->udev = usb_dev;\n\tdev->netdev = netdev;\n\tdev->adapter = peak_usb_adapter;\n\tdev->ctrl_idx = ctrl_idx;\n\tdev->state = PCAN_USB_STATE_CONNECTED;\n\n\tdev->ep_msg_in = peak_usb_adapter->ep_msg_in;\n\tdev->ep_msg_out = peak_usb_adapter->ep_msg_out[ctrl_idx];\n\n\tdev->can.clock = peak_usb_adapter->clock;\n\tdev->can.bittiming_const = peak_usb_adapter->bittiming_const;\n\tdev->can.do_set_bittiming = peak_usb_set_bittiming;\n\tdev->can.data_bittiming_const = peak_usb_adapter->data_bittiming_const;\n\tdev->can.do_set_data_bittiming = peak_usb_set_data_bittiming;\n\tdev->can.do_set_mode = peak_usb_set_mode;\n\tdev->can.do_get_berr_counter = peak_usb_adapter->do_get_berr_counter;\n\tdev->can.ctrlmode_supported = peak_usb_adapter->ctrlmode_supported;\n\n\tnetdev->netdev_ops = &peak_usb_netdev_ops;\n\n\tnetdev->flags |= IFF_ECHO;  \n\n\t \n\tnetdev->ethtool_ops = peak_usb_adapter->ethtool_ops;\n\n\t \n\tnetdev->sysfs_groups[0] = &peak_usb_sysfs_group;\n\n\tinit_usb_anchor(&dev->rx_submitted);\n\n\tinit_usb_anchor(&dev->tx_submitted);\n\tatomic_set(&dev->active_tx_urbs, 0);\n\n\tfor (i = 0; i < PCAN_USB_MAX_TX_URBS; i++)\n\t\tdev->tx_contexts[i].echo_index = PCAN_USB_MAX_TX_URBS;\n\n\tdev->prev_siblings = usb_get_intfdata(intf);\n\tusb_set_intfdata(intf, dev);\n\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\tnetdev->dev_id = ctrl_idx;\n\n\terr = register_candev(netdev);\n\tif (err) {\n\t\tdev_err(&intf->dev, \"couldn't register CAN device: %d\\n\", err);\n\t\tgoto lbl_restore_intf_data;\n\t}\n\n\tif (dev->prev_siblings)\n\t\t(dev->prev_siblings)->next_siblings = dev;\n\n\t \n\ttmp16 = le16_to_cpu(usb_dev->descriptor.bcdDevice);\n\tdev->device_rev = tmp16 >> 8;\n\n\tif (dev->adapter->dev_init) {\n\t\terr = dev->adapter->dev_init(dev);\n\t\tif (err)\n\t\t\tgoto lbl_unregister_candev;\n\t}\n\n\t \n\tif (dev->adapter->dev_set_bus) {\n\t\terr = dev->adapter->dev_set_bus(dev, 0);\n\t\tif (err)\n\t\t\tgoto adap_dev_free;\n\t}\n\n\t \n\tdev->adapter->dev_get_can_channel_id(dev, &dev->can_channel_id);\n\n\tnetdev_info(netdev, \"attached to %s channel %u (device 0x%08X)\\n\",\n\t\t    peak_usb_adapter->name, ctrl_idx, dev->can_channel_id);\n\n\treturn 0;\n\nadap_dev_free:\n\tif (dev->adapter->dev_free)\n\t\tdev->adapter->dev_free(dev);\n\nlbl_unregister_candev:\n\tunregister_candev(netdev);\n\nlbl_restore_intf_data:\n\tusb_set_intfdata(intf, dev->prev_siblings);\n\tkfree(dev->cmd_buf);\n\nlbl_free_candev:\n\tfree_candev(netdev);\n\n\treturn err;\n}\n\n \nstatic void peak_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct peak_usb_device *dev;\n\tstruct peak_usb_device *dev_prev_siblings;\n\n\t \n\tfor (dev = usb_get_intfdata(intf); dev; dev = dev_prev_siblings) {\n\t\tstruct net_device *netdev = dev->netdev;\n\t\tchar name[IFNAMSIZ];\n\n\t\tdev_prev_siblings = dev->prev_siblings;\n\t\tdev->state &= ~PCAN_USB_STATE_CONNECTED;\n\t\tstrscpy(name, netdev->name, IFNAMSIZ);\n\n\t\tunregister_candev(netdev);\n\n\t\tkfree(dev->cmd_buf);\n\t\tdev->next_siblings = NULL;\n\t\tif (dev->adapter->dev_free)\n\t\t\tdev->adapter->dev_free(dev);\n\n\t\tfree_candev(netdev);\n\t\tdev_info(&intf->dev, \"%s removed\\n\", name);\n\t}\n\n\tusb_set_intfdata(intf, NULL);\n}\n\n \nstatic int peak_usb_probe(struct usb_interface *intf,\n\t\t\t  const struct usb_device_id *id)\n{\n\tconst struct peak_usb_adapter *peak_usb_adapter;\n\tint i, err = -ENOMEM;\n\n\t \n\tpeak_usb_adapter = (const struct peak_usb_adapter *)id->driver_info;\n\n\t \n\tif (peak_usb_adapter->intf_probe) {\n\t\terr = peak_usb_adapter->intf_probe(intf);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0; i < peak_usb_adapter->ctrl_count; i++) {\n\t\terr = peak_usb_create_dev(peak_usb_adapter, intf, i);\n\t\tif (err) {\n\t\t\t \n\t\t\tpeak_usb_disconnect(intf);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\n \nstatic struct usb_driver peak_usb_driver = {\n\t.name = PCAN_USB_DRIVER_NAME,\n\t.disconnect = peak_usb_disconnect,\n\t.probe = peak_usb_probe,\n\t.id_table = peak_usb_table,\n};\n\nstatic int __init peak_usb_init(void)\n{\n\tint err;\n\n\t \n\terr = usb_register(&peak_usb_driver);\n\tif (err)\n\t\tpr_err(\"%s: usb_register failed (err %d)\\n\",\n\t\t\tPCAN_USB_DRIVER_NAME, err);\n\n\treturn err;\n}\n\nstatic int peak_usb_do_device_exit(struct device *d, void *arg)\n{\n\tstruct usb_interface *intf = to_usb_interface(d);\n\tstruct peak_usb_device *dev;\n\n\t \n\tfor (dev = usb_get_intfdata(intf); dev; dev = dev->prev_siblings) {\n\t\tstruct net_device *netdev = dev->netdev;\n\n\t\tif (netif_device_present(netdev))\n\t\t\tif (dev->adapter->dev_exit)\n\t\t\t\tdev->adapter->dev_exit(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit peak_usb_exit(void)\n{\n\tint err;\n\n\t \n\terr = driver_for_each_device(&peak_usb_driver.drvwrap.driver, NULL,\n\t\t\t\t     NULL, peak_usb_do_device_exit);\n\tif (err)\n\t\tpr_err(\"%s: failed to stop all can devices (err %d)\\n\",\n\t\t\tPCAN_USB_DRIVER_NAME, err);\n\n\t \n\tusb_deregister(&peak_usb_driver);\n\n\tpr_info(\"%s: PCAN-USB interfaces driver unloaded\\n\",\n\t\tPCAN_USB_DRIVER_NAME);\n}\n\nmodule_init(peak_usb_init);\nmodule_exit(peak_usb_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}