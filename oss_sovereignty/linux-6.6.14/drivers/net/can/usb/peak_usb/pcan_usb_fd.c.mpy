{
  "module_name": "pcan_usb_fd.c",
  "hash_id": "4bfe4020d1853b2369a1dd670e8ead6320d9c32b48bdb1fad3ec9b7f626473c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/usb/peak_usb/pcan_usb_fd.c",
  "human_readable_source": "\n \n#include <linux/ethtool.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/usb.h>\n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n#include <linux/can/dev/peak_canfd.h>\n\n#include \"pcan_usb_core.h\"\n#include \"pcan_usb_pro.h\"\n\n#define PCAN_USBPROFD_CHANNEL_COUNT\t2\n#define PCAN_USBFD_CHANNEL_COUNT\t1\n\n \n#define PCAN_UFD_CRYSTAL_HZ\t\t80000000\n\n#define PCAN_UFD_CMD_BUFFER_SIZE\t512\n#define PCAN_UFD_LOSPD_PKT_SIZE\t\t64\n\n \n#define PCAN_UFD_CMD_TIMEOUT_MS\t\t1000\n\n \n#define PCAN_UFD_RX_BUFFER_SIZE\t\t2048\n#define PCAN_UFD_TX_BUFFER_SIZE\t\t512\n\n \n#define PCAN_USBFD_TYPE_STD\t\t1\n#define PCAN_USBFD_TYPE_EXT\t\t2\t \n\n \nstruct __packed pcan_ufd_fw_info {\n\t__le16\tsize_of;\t \n\t__le16\ttype;\t\t \n\tu8\thw_type;\t \n\tu8\tbl_version[3];\t \n\tu8\thw_version;\t \n\tu8\tfw_version[3];\t \n\t__le32\tdev_id[2];\t \n\t__le32\tser_no;\t\t \n\t__le32\tflags;\t\t \n\n\t \n\tu8\tcmd_out_ep;\t \n\tu8\tcmd_in_ep;\t \n\tu8\tdata_out_ep[2];\t \n\tu8\tdata_in_ep;\t \n\tu8\tdummy[3];\n};\n\n \nstruct pcan_usb_fd_if {\n\tstruct peak_usb_device\t*dev[PCAN_USB_MAX_CHANNEL];\n\tstruct pcan_ufd_fw_info\tfw_info;\n\tstruct peak_time_ref\ttime_ref;\n\tint\t\t\tcm_ignore_count;\n\tint\t\t\tdev_opened_count;\n};\n\n \nstruct pcan_usb_fd_device {\n\tstruct peak_usb_device\tdev;\n\tstruct can_berr_counter\tbec;\n\tstruct pcan_usb_fd_if\t*usb_if;\n\tu8\t\t\t*cmd_buffer_addr;\n};\n\n \n\n \n#define PCAN_UFD_CMD_CLK_SET\t\t0x80\n\n#define PCAN_UFD_CLK_80MHZ\t\t0x0\n#define PCAN_UFD_CLK_60MHZ\t\t0x1\n#define PCAN_UFD_CLK_40MHZ\t\t0x2\n#define PCAN_UFD_CLK_30MHZ\t\t0x3\n#define PCAN_UFD_CLK_24MHZ\t\t0x4\n#define PCAN_UFD_CLK_20MHZ\t\t0x5\n#define PCAN_UFD_CLK_DEF\t\tPCAN_UFD_CLK_80MHZ\n\nstruct __packed pcan_ufd_clock {\n\t__le16\topcode_channel;\n\n\tu8\tmode;\n\tu8\tunused[5];\n};\n\n \n#define PCAN_UFD_CMD_LED_SET\t\t0x86\n\n#define PCAN_UFD_LED_DEV\t\t0x00\n#define PCAN_UFD_LED_FAST\t\t0x01\n#define PCAN_UFD_LED_SLOW\t\t0x02\n#define PCAN_UFD_LED_ON\t\t\t0x03\n#define PCAN_UFD_LED_OFF\t\t0x04\n#define PCAN_UFD_LED_DEF\t\tPCAN_UFD_LED_DEV\n\nstruct __packed pcan_ufd_led {\n\t__le16\topcode_channel;\n\n\tu8\tmode;\n\tu8\tunused[5];\n};\n\n \n#define PCAN_UFD_FLTEXT_CALIBRATION\t0x8000\n\nstruct __packed pcan_ufd_options {\n\t__le16\topcode_channel;\n\n\t__le16\tucan_mask;\n\tu16\tunused;\n\t__le16\tusb_mask;\n};\n\n \n#define PCAN_UFD_MSG_CALIBRATION\t0x100\n\nstruct __packed pcan_ufd_ts_msg {\n\t__le16\tsize;\n\t__le16\ttype;\n\t__le32\tts_low;\n\t__le32\tts_high;\n\t__le16\tusb_frame_index;\n\tu16\tunused;\n};\n\n#define PCAN_UFD_MSG_OVERRUN\t\t0x101\n\n#define PCAN_UFD_OVMSG_CHANNEL(o)\t((o)->channel & 0xf)\n\nstruct __packed pcan_ufd_ovr_msg {\n\t__le16\tsize;\n\t__le16\ttype;\n\t__le32\tts_low;\n\t__le32\tts_high;\n\tu8\tchannel;\n\tu8\tunused[3];\n};\n\n#define PCAN_UFD_CMD_DEVID_SET\t\t0x81\n\nstruct __packed pcan_ufd_device_id {\n\t__le16\topcode_channel;\n\n\tu16\tunused;\n\t__le32\tdevice_id;\n};\n\nstatic inline int pufd_omsg_get_channel(struct pcan_ufd_ovr_msg *om)\n{\n\treturn om->channel & 0xf;\n}\n\n \nstatic const u32 pcan_usb_fd_clk_freq[6] = {\n\t[PCAN_UFD_CLK_80MHZ] = 80000000,\n\t[PCAN_UFD_CLK_60MHZ] = 60000000,\n\t[PCAN_UFD_CLK_40MHZ] = 40000000,\n\t[PCAN_UFD_CLK_30MHZ] = 30000000,\n\t[PCAN_UFD_CLK_24MHZ] = 24000000,\n\t[PCAN_UFD_CLK_20MHZ] = 20000000\n};\n\n \nstatic inline\nstruct pcan_usb_fd_if *pcan_usb_fd_dev_if(struct peak_usb_device *dev)\n{\n\tstruct pcan_usb_fd_device *pdev =\n\t\t\tcontainer_of(dev, struct pcan_usb_fd_device, dev);\n\treturn pdev->usb_if;\n}\n\n \nstatic inline void *pcan_usb_fd_cmd_buffer(struct peak_usb_device *dev)\n{\n\tstruct pcan_usb_fd_device *pdev =\n\t\t\tcontainer_of(dev, struct pcan_usb_fd_device, dev);\n\treturn pdev->cmd_buffer_addr;\n}\n\n \nstatic int pcan_usb_fd_send_cmd(struct peak_usb_device *dev, void *cmd_tail)\n{\n\tstruct pcan_usb_fd_device *pdev =\n\t\tcontainer_of(dev, struct pcan_usb_fd_device, dev);\n\tstruct pcan_ufd_fw_info *fw_info = &pdev->usb_if->fw_info;\n\tvoid *cmd_head = pcan_usb_fd_cmd_buffer(dev);\n\tint err = 0;\n\tu8 *packet_ptr;\n\tint packet_len;\n\tptrdiff_t cmd_len;\n\n\t \n\tif (!(dev->state & PCAN_USB_STATE_CONNECTED))\n\t\treturn 0;\n\n\t \n\tcmd_len = cmd_tail - cmd_head;\n\tif (cmd_len <= (PCAN_UFD_CMD_BUFFER_SIZE - sizeof(u64))) {\n\t\tmemset(cmd_tail, 0xff, sizeof(u64));\n\t\tcmd_len += sizeof(u64);\n\t}\n\n\tpacket_ptr = cmd_head;\n\tpacket_len = cmd_len;\n\n\t \n\tif (unlikely(dev->udev->speed != USB_SPEED_HIGH))\n\t\tpacket_len = min(packet_len, PCAN_UFD_LOSPD_PKT_SIZE);\n\n\tdo {\n\t\terr = usb_bulk_msg(dev->udev,\n\t\t\t\t   usb_sndbulkpipe(dev->udev,\n\t\t\t\t\t\t   fw_info->cmd_out_ep),\n\t\t\t\t   packet_ptr, packet_len,\n\t\t\t\t   NULL, PCAN_UFD_CMD_TIMEOUT_MS);\n\t\tif (err) {\n\t\t\tnetdev_err(dev->netdev,\n\t\t\t\t   \"sending command failure: %d\\n\", err);\n\t\t\tbreak;\n\t\t}\n\n\t\tpacket_ptr += packet_len;\n\t\tcmd_len -= packet_len;\n\n\t\tif (cmd_len < PCAN_UFD_LOSPD_PKT_SIZE)\n\t\t\tpacket_len = cmd_len;\n\n\t} while (packet_len > 0);\n\n\treturn err;\n}\n\nstatic int pcan_usb_fd_read_fwinfo(struct peak_usb_device *dev,\n\t\t\t\t   struct pcan_ufd_fw_info *fw_info)\n{\n\treturn pcan_usb_pro_send_req(dev, PCAN_USBPRO_REQ_INFO,\n\t\t\t\t     PCAN_USBPRO_INFO_FW,\n\t\t\t\t     fw_info,\n\t\t\t\t     sizeof(*fw_info));\n}\n\n \nstatic int pcan_usb_fd_build_restart_cmd(struct peak_usb_device *dev, u8 *buf)\n{\n\tstruct pucan_wr_err_cnt *prc;\n\tstruct pucan_command *cmd;\n\tu8 *pc = buf;\n\n\t \n\tprc = (struct pucan_wr_err_cnt *)pc;\n\tprc->opcode_channel = pucan_cmd_opcode_channel(dev->ctrl_idx,\n\t\t\t\t\t\t       PUCAN_CMD_WR_ERR_CNT);\n\n\t \n\tprc->sel_mask = cpu_to_le16(PUCAN_WRERRCNT_TE|PUCAN_WRERRCNT_RE);\n\n\t \n\tprc->tx_counter = 0;\n\tprc->rx_counter = 0;\n\n\t \n\tpc += sizeof(struct pucan_wr_err_cnt);\n\n\t \n\tif (dev->can.ctrlmode_supported & CAN_CTRLMODE_FD_NON_ISO) {\n\t\tstruct pucan_options *puo = (struct pucan_options *)pc;\n\n\t\tpuo->opcode_channel =\n\t\t\t(dev->can.ctrlmode & CAN_CTRLMODE_FD_NON_ISO) ?\n\t\t\tpucan_cmd_opcode_channel(dev->ctrl_idx,\n\t\t\t\t\t\t PUCAN_CMD_CLR_DIS_OPTION) :\n\t\t\tpucan_cmd_opcode_channel(dev->ctrl_idx,\n\t\t\t\t\t\t PUCAN_CMD_SET_EN_OPTION);\n\n\t\tpuo->options = cpu_to_le16(PUCAN_OPTION_CANDFDISO);\n\n\t\t \n\t\tpuo->unused = 0;\n\n\t\t \n\t\tpc += sizeof(struct pucan_options);\n\t}\n\n\t \n\tcmd = (struct pucan_command *)pc;\n\tcmd->opcode_channel = pucan_cmd_opcode_channel(dev->ctrl_idx,\n\t\t\t\t(dev->can.ctrlmode & CAN_CTRLMODE_LISTENONLY) ?\n\t\t\t\t\t\tPUCAN_CMD_LISTEN_ONLY_MODE :\n\t\t\t\t\t\tPUCAN_CMD_NORMAL_MODE);\n\tpc += sizeof(struct pucan_command);\n\n\treturn pc - buf;\n}\n\n \nstatic int pcan_usb_fd_set_bus(struct peak_usb_device *dev, u8 onoff)\n{\n\tu8 *pc = pcan_usb_fd_cmd_buffer(dev);\n\tint l;\n\n\tif (onoff) {\n\t\t \n\t\tl = pcan_usb_fd_build_restart_cmd(dev, pc);\n\t} else {\n\t\tstruct pucan_command *cmd = (struct pucan_command *)pc;\n\n\t\t \n\t\tcmd->opcode_channel = pucan_cmd_opcode_channel(dev->ctrl_idx,\n\t\t\t\t\t\t\tPUCAN_CMD_RESET_MODE);\n\t\tl = sizeof(struct pucan_command);\n\t}\n\n\t \n\treturn pcan_usb_fd_send_cmd(dev, pc + l);\n}\n\n \nstatic int pcan_usb_fd_set_filter_std(struct peak_usb_device *dev, int idx,\n\t\t\t\t      u32 mask)\n{\n\tstruct pucan_filter_std *cmd = pcan_usb_fd_cmd_buffer(dev);\n\tint i, n;\n\n\t \n\tif ((idx < 0) || (idx >= (1 << PUCAN_FLTSTD_ROW_IDX_BITS))) {\n\t\tn = 1 << PUCAN_FLTSTD_ROW_IDX_BITS;\n\t\tidx = 0;\n\n\t \n\t} else {\n\t\tn = idx + 1;\n\t}\n\n\tfor (i = idx; i < n; i++, cmd++) {\n\t\tcmd->opcode_channel = pucan_cmd_opcode_channel(dev->ctrl_idx,\n\t\t\t\t\t\t\tPUCAN_CMD_FILTER_STD);\n\t\tcmd->idx = cpu_to_le16(i);\n\t\tcmd->mask = cpu_to_le32(mask);\n\t}\n\n\t \n\treturn pcan_usb_fd_send_cmd(dev, cmd);\n}\n\n \nstatic int pcan_usb_fd_set_options(struct peak_usb_device *dev,\n\t\t\t\t   bool onoff, u16 ucan_mask, u16 usb_mask)\n{\n\tstruct pcan_ufd_options *cmd = pcan_usb_fd_cmd_buffer(dev);\n\n\tcmd->opcode_channel = pucan_cmd_opcode_channel(dev->ctrl_idx,\n\t\t\t\t\t(onoff) ? PUCAN_CMD_SET_EN_OPTION :\n\t\t\t\t\t\t  PUCAN_CMD_CLR_DIS_OPTION);\n\n\tcmd->ucan_mask = cpu_to_le16(ucan_mask);\n\tcmd->usb_mask = cpu_to_le16(usb_mask);\n\n\t \n\treturn pcan_usb_fd_send_cmd(dev, ++cmd);\n}\n\n \nstatic int pcan_usb_fd_set_can_led(struct peak_usb_device *dev, u8 led_mode)\n{\n\tstruct pcan_ufd_led *cmd = pcan_usb_fd_cmd_buffer(dev);\n\n\tcmd->opcode_channel = pucan_cmd_opcode_channel(dev->ctrl_idx,\n\t\t\t\t\t\t       PCAN_UFD_CMD_LED_SET);\n\tcmd->mode = led_mode;\n\n\t \n\treturn pcan_usb_fd_send_cmd(dev, ++cmd);\n}\n\n \nstatic int pcan_usb_fd_set_clock_domain(struct peak_usb_device *dev,\n\t\t\t\t\tu8 clk_mode)\n{\n\tstruct pcan_ufd_clock *cmd = pcan_usb_fd_cmd_buffer(dev);\n\n\tcmd->opcode_channel = pucan_cmd_opcode_channel(dev->ctrl_idx,\n\t\t\t\t\t\t       PCAN_UFD_CMD_CLK_SET);\n\tcmd->mode = clk_mode;\n\n\t \n\treturn pcan_usb_fd_send_cmd(dev, ++cmd);\n}\n\n \nstatic int pcan_usb_fd_set_bittiming_slow(struct peak_usb_device *dev,\n\t\t\t\t\t  struct can_bittiming *bt)\n{\n\tstruct pucan_timing_slow *cmd = pcan_usb_fd_cmd_buffer(dev);\n\n\tcmd->opcode_channel = pucan_cmd_opcode_channel(dev->ctrl_idx,\n\t\t\t\t\t\t       PUCAN_CMD_TIMING_SLOW);\n\tcmd->sjw_t = PUCAN_TSLOW_SJW_T(bt->sjw - 1,\n\t\t\t\tdev->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES);\n\n\tcmd->tseg2 = PUCAN_TSLOW_TSEG2(bt->phase_seg2 - 1);\n\tcmd->tseg1 = PUCAN_TSLOW_TSEG1(bt->prop_seg + bt->phase_seg1 - 1);\n\tcmd->brp = cpu_to_le16(PUCAN_TSLOW_BRP(bt->brp - 1));\n\n\tcmd->ewl = 96;\t \n\n\t \n\treturn pcan_usb_fd_send_cmd(dev, ++cmd);\n}\n\n \nstatic int pcan_usb_fd_set_bittiming_fast(struct peak_usb_device *dev,\n\t\t\t\t\t  struct can_bittiming *bt)\n{\n\tstruct pucan_timing_fast *cmd = pcan_usb_fd_cmd_buffer(dev);\n\n\tcmd->opcode_channel = pucan_cmd_opcode_channel(dev->ctrl_idx,\n\t\t\t\t\t\t       PUCAN_CMD_TIMING_FAST);\n\tcmd->sjw = PUCAN_TFAST_SJW(bt->sjw - 1);\n\tcmd->tseg2 = PUCAN_TFAST_TSEG2(bt->phase_seg2 - 1);\n\tcmd->tseg1 = PUCAN_TFAST_TSEG1(bt->prop_seg + bt->phase_seg1 - 1);\n\tcmd->brp = cpu_to_le16(PUCAN_TFAST_BRP(bt->brp - 1));\n\n\t \n\treturn pcan_usb_fd_send_cmd(dev, ++cmd);\n}\n\n \nstatic int pcan_usb_fd_get_can_channel_id(struct peak_usb_device *dev,\n\t\t\t\t\t  u32 *can_ch_id)\n{\n\tint err;\n\tstruct pcan_usb_fd_if *usb_if = pcan_usb_fd_dev_if(dev);\n\n\terr = pcan_usb_fd_read_fwinfo(dev, &usb_if->fw_info);\n\tif (err)\n\t\treturn err;\n\n\t*can_ch_id = le32_to_cpu(usb_if->fw_info.dev_id[dev->ctrl_idx]);\n\treturn err;\n}\n\n \nstatic int pcan_usb_fd_set_can_channel_id(struct peak_usb_device *dev, u32 can_ch_id)\n{\n\tstruct pcan_ufd_device_id *cmd = pcan_usb_fd_cmd_buffer(dev);\n\n\tcmd->opcode_channel = pucan_cmd_opcode_channel(dev->ctrl_idx,\n\t\t\t\t\t\t       PCAN_UFD_CMD_DEVID_SET);\n\tcmd->device_id = cpu_to_le32(can_ch_id);\n\n\t \n\treturn pcan_usb_fd_send_cmd(dev, ++cmd);\n}\n\n \nstatic int pcan_usb_fd_restart_async(struct peak_usb_device *dev,\n\t\t\t\t     struct urb *urb, u8 *buf)\n{\n\tstruct pcan_usb_fd_device *pdev =\n\t\tcontainer_of(dev, struct pcan_usb_fd_device, dev);\n\tstruct pcan_ufd_fw_info *fw_info = &pdev->usb_if->fw_info;\n\tu8 *pc = buf;\n\n\t \n\tpc += pcan_usb_fd_build_restart_cmd(dev, pc);\n\n\t \n\tmemset(pc, 0xff, sizeof(struct pucan_command));\n\tpc += sizeof(struct pucan_command);\n\n\t \n\tusb_fill_bulk_urb(urb, dev->udev,\n\t\t\t  usb_sndbulkpipe(dev->udev, fw_info->cmd_out_ep),\n\t\t\t  buf, pc - buf,\n\t\t\t  pcan_usb_pro_restart_complete, dev);\n\n\t \n\treturn usb_submit_urb(urb, GFP_ATOMIC);\n}\n\nstatic int pcan_usb_fd_drv_loaded(struct peak_usb_device *dev, bool loaded)\n{\n\tstruct pcan_usb_fd_device *pdev =\n\t\t\tcontainer_of(dev, struct pcan_usb_fd_device, dev);\n\n\tpdev->cmd_buffer_addr[0] = 0;\n\tpdev->cmd_buffer_addr[1] = !!loaded;\n\n\treturn pcan_usb_pro_send_req(dev,\n\t\t\t\tPCAN_USBPRO_REQ_FCT,\n\t\t\t\tPCAN_USBPRO_FCT_DRVLD,\n\t\t\t\tpdev->cmd_buffer_addr,\n\t\t\t\tPCAN_USBPRO_FCT_DRVLD_REQ_LEN);\n}\n\nstatic int pcan_usb_fd_decode_canmsg(struct pcan_usb_fd_if *usb_if,\n\t\t\t\t     struct pucan_msg *rx_msg)\n{\n\tstruct pucan_rx_msg *rm = (struct pucan_rx_msg *)rx_msg;\n\tstruct peak_usb_device *dev;\n\tstruct net_device *netdev;\n\tstruct canfd_frame *cfd;\n\tstruct sk_buff *skb;\n\tconst u16 rx_msg_flags = le16_to_cpu(rm->flags);\n\n\tif (pucan_msg_get_channel(rm) >= ARRAY_SIZE(usb_if->dev))\n\t\treturn -ENOMEM;\n\n\tdev = usb_if->dev[pucan_msg_get_channel(rm)];\n\tnetdev = dev->netdev;\n\n\tif (rx_msg_flags & PUCAN_MSG_EXT_DATA_LEN) {\n\t\t \n\t\tskb = alloc_canfd_skb(netdev, &cfd);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\n\t\tif (rx_msg_flags & PUCAN_MSG_BITRATE_SWITCH)\n\t\t\tcfd->flags |= CANFD_BRS;\n\n\t\tif (rx_msg_flags & PUCAN_MSG_ERROR_STATE_IND)\n\t\t\tcfd->flags |= CANFD_ESI;\n\n\t\tcfd->len = can_fd_dlc2len(pucan_msg_get_dlc(rm));\n\t} else {\n\t\t \n\t\tskb = alloc_can_skb(netdev, (struct can_frame **)&cfd);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\n\t\tcan_frame_set_cc_len((struct can_frame *)cfd,\n\t\t\t\t     pucan_msg_get_dlc(rm),\n\t\t\t\t     dev->can.ctrlmode);\n\t}\n\n\tcfd->can_id = le32_to_cpu(rm->can_id);\n\n\tif (rx_msg_flags & PUCAN_MSG_EXT_ID)\n\t\tcfd->can_id |= CAN_EFF_FLAG;\n\n\tif (rx_msg_flags & PUCAN_MSG_RTR) {\n\t\tcfd->can_id |= CAN_RTR_FLAG;\n\t} else {\n\t\tmemcpy(cfd->data, rm->d, cfd->len);\n\t\tnetdev->stats.rx_bytes += cfd->len;\n\t}\n\tnetdev->stats.rx_packets++;\n\n\tpeak_usb_netif_rx_64(skb, le32_to_cpu(rm->ts_low),\n\t\t\t     le32_to_cpu(rm->ts_high));\n\n\treturn 0;\n}\n\n \nstatic int pcan_usb_fd_decode_status(struct pcan_usb_fd_if *usb_if,\n\t\t\t\t     struct pucan_msg *rx_msg)\n{\n\tstruct pucan_status_msg *sm = (struct pucan_status_msg *)rx_msg;\n\tstruct pcan_usb_fd_device *pdev;\n\tenum can_state new_state = CAN_STATE_ERROR_ACTIVE;\n\tenum can_state rx_state, tx_state;\n\tstruct peak_usb_device *dev;\n\tstruct net_device *netdev;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\n\tif (pucan_stmsg_get_channel(sm) >= ARRAY_SIZE(usb_if->dev))\n\t\treturn -ENOMEM;\n\n\tdev = usb_if->dev[pucan_stmsg_get_channel(sm)];\n\tpdev = container_of(dev, struct pcan_usb_fd_device, dev);\n\tnetdev = dev->netdev;\n\n\t \n\tif (dev->can.state == CAN_STATE_BUS_OFF)\n\t\treturn 0;\n\n\tif (sm->channel_p_w_b & PUCAN_BUS_BUSOFF) {\n\t\tnew_state = CAN_STATE_BUS_OFF;\n\t} else if (sm->channel_p_w_b & PUCAN_BUS_PASSIVE) {\n\t\tnew_state = CAN_STATE_ERROR_PASSIVE;\n\t} else if (sm->channel_p_w_b & PUCAN_BUS_WARNING) {\n\t\tnew_state = CAN_STATE_ERROR_WARNING;\n\t} else {\n\t\t \n\t\tnew_state = CAN_STATE_ERROR_ACTIVE;\n\t\tpdev->bec.txerr = 0;\n\t\tpdev->bec.rxerr = 0;\n\t}\n\n\t \n\tif (new_state == dev->can.state)\n\t\treturn 0;\n\n\t \n\ttx_state = (pdev->bec.txerr >= pdev->bec.rxerr) ? new_state : 0;\n\trx_state = (pdev->bec.txerr <= pdev->bec.rxerr) ? new_state : 0;\n\n\t \n\tskb = alloc_can_err_skb(netdev, &cf);\n\tcan_change_state(netdev, cf, tx_state, rx_state);\n\n\t \n\tif (new_state == CAN_STATE_BUS_OFF)\n\t\tcan_bus_off(netdev);\n\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tpeak_usb_netif_rx_64(skb, le32_to_cpu(sm->ts_low),\n\t\t\t     le32_to_cpu(sm->ts_high));\n\n\treturn 0;\n}\n\n \nstatic int pcan_usb_fd_decode_error(struct pcan_usb_fd_if *usb_if,\n\t\t\t\t    struct pucan_msg *rx_msg)\n{\n\tstruct pucan_error_msg *er = (struct pucan_error_msg *)rx_msg;\n\tstruct pcan_usb_fd_device *pdev;\n\tstruct peak_usb_device *dev;\n\n\tif (pucan_ermsg_get_channel(er) >= ARRAY_SIZE(usb_if->dev))\n\t\treturn -EINVAL;\n\n\tdev = usb_if->dev[pucan_ermsg_get_channel(er)];\n\tpdev = container_of(dev, struct pcan_usb_fd_device, dev);\n\n\t \n\tpdev->bec.txerr = er->tx_err_cnt;\n\tpdev->bec.rxerr = er->rx_err_cnt;\n\n\treturn 0;\n}\n\n \nstatic int pcan_usb_fd_decode_overrun(struct pcan_usb_fd_if *usb_if,\n\t\t\t\t      struct pucan_msg *rx_msg)\n{\n\tstruct pcan_ufd_ovr_msg *ov = (struct pcan_ufd_ovr_msg *)rx_msg;\n\tstruct peak_usb_device *dev;\n\tstruct net_device *netdev;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\n\tif (pufd_omsg_get_channel(ov) >= ARRAY_SIZE(usb_if->dev))\n\t\treturn -EINVAL;\n\n\tdev = usb_if->dev[pufd_omsg_get_channel(ov)];\n\tnetdev = dev->netdev;\n\n\t \n\tskb = alloc_can_err_skb(netdev, &cf);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcf->can_id |= CAN_ERR_CRTL;\n\tcf->data[1] |= CAN_ERR_CRTL_RX_OVERFLOW;\n\n\tpeak_usb_netif_rx_64(skb, le32_to_cpu(ov->ts_low),\n\t\t\t     le32_to_cpu(ov->ts_high));\n\n\tnetdev->stats.rx_over_errors++;\n\tnetdev->stats.rx_errors++;\n\n\treturn 0;\n}\n\n \nstatic void pcan_usb_fd_decode_ts(struct pcan_usb_fd_if *usb_if,\n\t\t\t\t  struct pucan_msg *rx_msg)\n{\n\tstruct pcan_ufd_ts_msg *ts = (struct pcan_ufd_ts_msg *)rx_msg;\n\n\t \n\tif (usb_if->cm_ignore_count > 0)\n\t\tusb_if->cm_ignore_count--;\n\telse\n\t\tpeak_usb_set_ts_now(&usb_if->time_ref, le32_to_cpu(ts->ts_low));\n}\n\n \nstatic int pcan_usb_fd_decode_buf(struct peak_usb_device *dev, struct urb *urb)\n{\n\tstruct pcan_usb_fd_if *usb_if = pcan_usb_fd_dev_if(dev);\n\tstruct net_device *netdev = dev->netdev;\n\tstruct pucan_msg *rx_msg;\n\tu8 *msg_ptr, *msg_end;\n\tint err = 0;\n\n\t \n\tmsg_ptr = urb->transfer_buffer;\n\tmsg_end = urb->transfer_buffer + urb->actual_length;\n\tfor (; msg_ptr < msg_end;) {\n\t\tu16 rx_msg_type, rx_msg_size;\n\n\t\trx_msg = (struct pucan_msg *)msg_ptr;\n\t\tif (!rx_msg->size) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\trx_msg_size = le16_to_cpu(rx_msg->size);\n\t\trx_msg_type = le16_to_cpu(rx_msg->type);\n\n\t\t \n\t\tif (msg_ptr + rx_msg_size > msg_end) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"got frag rec: should inc usb rx buf sze\\n\");\n\t\t\terr = -EBADMSG;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (rx_msg_type) {\n\t\tcase PUCAN_MSG_CAN_RX:\n\t\t\terr = pcan_usb_fd_decode_canmsg(usb_if, rx_msg);\n\t\t\tif (err < 0)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\n\t\tcase PCAN_UFD_MSG_CALIBRATION:\n\t\t\tpcan_usb_fd_decode_ts(usb_if, rx_msg);\n\t\t\tbreak;\n\n\t\tcase PUCAN_MSG_ERROR:\n\t\t\terr = pcan_usb_fd_decode_error(usb_if, rx_msg);\n\t\t\tif (err < 0)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\n\t\tcase PUCAN_MSG_STATUS:\n\t\t\terr = pcan_usb_fd_decode_status(usb_if, rx_msg);\n\t\t\tif (err < 0)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\n\t\tcase PCAN_UFD_MSG_OVERRUN:\n\t\t\terr = pcan_usb_fd_decode_overrun(usb_if, rx_msg);\n\t\t\tif (err < 0)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"unhandled msg type 0x%02x (%d): ignored\\n\",\n\t\t\t\t   rx_msg_type, rx_msg_type);\n\t\t\tbreak;\n\t\t}\n\n\t\tmsg_ptr += rx_msg_size;\n\t}\n\nfail:\n\tif (err)\n\t\tpcan_dump_mem(\"received msg\",\n\t\t\t      urb->transfer_buffer, urb->actual_length);\n\treturn err;\n}\n\n \nstatic int pcan_usb_fd_encode_msg(struct peak_usb_device *dev,\n\t\t\t\t  struct sk_buff *skb, u8 *obuf, size_t *size)\n{\n\tstruct pucan_tx_msg *tx_msg = (struct pucan_tx_msg *)obuf;\n\tstruct canfd_frame *cfd = (struct canfd_frame *)skb->data;\n\tu16 tx_msg_size, tx_msg_flags;\n\tu8 dlc;\n\n\tif (cfd->len > CANFD_MAX_DLEN)\n\t\treturn -EINVAL;\n\n\ttx_msg_size = ALIGN(sizeof(struct pucan_tx_msg) + cfd->len, 4);\n\ttx_msg->size = cpu_to_le16(tx_msg_size);\n\ttx_msg->type = cpu_to_le16(PUCAN_MSG_CAN_TX);\n\n\ttx_msg_flags = 0;\n\tif (cfd->can_id & CAN_EFF_FLAG) {\n\t\ttx_msg_flags |= PUCAN_MSG_EXT_ID;\n\t\ttx_msg->can_id = cpu_to_le32(cfd->can_id & CAN_EFF_MASK);\n\t} else {\n\t\ttx_msg->can_id = cpu_to_le32(cfd->can_id & CAN_SFF_MASK);\n\t}\n\n\tif (can_is_canfd_skb(skb)) {\n\t\t \n\t\tdlc = can_fd_len2dlc(cfd->len);\n\n\t\ttx_msg_flags |= PUCAN_MSG_EXT_DATA_LEN;\n\n\t\tif (cfd->flags & CANFD_BRS)\n\t\t\ttx_msg_flags |= PUCAN_MSG_BITRATE_SWITCH;\n\n\t\tif (cfd->flags & CANFD_ESI)\n\t\t\ttx_msg_flags |= PUCAN_MSG_ERROR_STATE_IND;\n\t} else {\n\t\t \n\t\tdlc = can_get_cc_dlc((struct can_frame *)cfd,\n\t\t\t\t     dev->can.ctrlmode);\n\n\t\tif (cfd->can_id & CAN_RTR_FLAG)\n\t\t\ttx_msg_flags |= PUCAN_MSG_RTR;\n\t}\n\n\t \n\tif (dev->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)\n\t\ttx_msg_flags |= PUCAN_MSG_SINGLE_SHOT;\n\n\ttx_msg->flags = cpu_to_le16(tx_msg_flags);\n\ttx_msg->channel_dlc = PUCAN_MSG_CHANNEL_DLC(dev->ctrl_idx, dlc);\n\tmemcpy(tx_msg->d, cfd->data, cfd->len);\n\n\t \n\ttx_msg = (struct pucan_tx_msg *)(obuf + tx_msg_size);\n\n\ttx_msg->size = 0;\n\n\t \n\t*size = tx_msg_size + sizeof(u32);\n\n\treturn 0;\n}\n\n \nstatic int pcan_usb_fd_start(struct peak_usb_device *dev)\n{\n\tstruct pcan_usb_fd_device *pdev =\n\t\t\tcontainer_of(dev, struct pcan_usb_fd_device, dev);\n\tint err;\n\n\t \n\terr = pcan_usb_fd_set_filter_std(dev, -1, 0xffffffff);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (pdev->usb_if->dev_opened_count == 0) {\n\t\t \n\t\tpeak_usb_init_time_ref(&pdev->usb_if->time_ref,\n\t\t\t\t       &pcan_usb_pro_fd);\n\n\t\t \n\t\terr = pcan_usb_fd_set_options(dev, 1,\n\t\t\t\t\t      PUCAN_OPTION_ERROR,\n\t\t\t\t\t      PCAN_UFD_FLTEXT_CALIBRATION);\n\t}\n\n\tpdev->usb_if->dev_opened_count++;\n\n\t \n\tpdev->bec.txerr = 0;\n\tpdev->bec.rxerr = 0;\n\n\treturn err;\n}\n\n \nstatic int pcan_usb_fd_get_berr_counter(const struct net_device *netdev,\n\t\t\t\t\tstruct can_berr_counter *bec)\n{\n\tstruct peak_usb_device *dev = netdev_priv(netdev);\n\tstruct pcan_usb_fd_device *pdev =\n\t\t\tcontainer_of(dev, struct pcan_usb_fd_device, dev);\n\n\t*bec = pdev->bec;\n\n\t \n\treturn 0;\n}\n\n \nstatic int pcan_usb_fd_probe(struct usb_interface *intf)\n{\n\tstruct usb_host_interface *iface_desc = &intf->altsetting[0];\n\n\t \n\treturn iface_desc->desc.bInterfaceNumber;\n}\n\n \nstatic int pcan_usb_fd_stop(struct peak_usb_device *dev)\n{\n\tstruct pcan_usb_fd_device *pdev =\n\t\t\tcontainer_of(dev, struct pcan_usb_fd_device, dev);\n\n\t \n\tif (pdev->usb_if->dev_opened_count == 1)\n\t\tpcan_usb_fd_set_options(dev, 0,\n\t\t\t\t\tPUCAN_OPTION_ERROR,\n\t\t\t\t\tPCAN_UFD_FLTEXT_CALIBRATION);\n\tpdev->usb_if->dev_opened_count--;\n\n\treturn 0;\n}\n\n \nstatic int pcan_usb_fd_init(struct peak_usb_device *dev)\n{\n\tstruct pcan_usb_fd_device *pdev =\n\t\t\tcontainer_of(dev, struct pcan_usb_fd_device, dev);\n\tstruct pcan_ufd_fw_info *fw_info;\n\tint i, err = -ENOMEM;\n\n\t \n\tif (!dev->prev_siblings) {\n\t\t \n\t\tpdev->usb_if = kzalloc(sizeof(*pdev->usb_if), GFP_KERNEL);\n\t\tif (!pdev->usb_if)\n\t\t\tgoto err_out;\n\n\t\t \n\t\tpdev->cmd_buffer_addr = kzalloc(PCAN_UFD_CMD_BUFFER_SIZE,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!pdev->cmd_buffer_addr)\n\t\t\tgoto err_out_1;\n\n\t\t \n\t\tpdev->usb_if->cm_ignore_count = 5;\n\n\t\tfw_info = &pdev->usb_if->fw_info;\n\n\t\terr = pcan_usb_fd_read_fwinfo(dev, fw_info);\n\t\tif (err) {\n\t\t\tdev_err(dev->netdev->dev.parent,\n\t\t\t\t\"unable to read %s firmware info (err %d)\\n\",\n\t\t\t\tdev->adapter->name, err);\n\t\t\tgoto err_out_2;\n\t\t}\n\n\t\t \n\t\tdev_info(dev->netdev->dev.parent,\n\t\t\t \"PEAK-System %s v%u fw v%u.%u.%u (%u channels)\\n\",\n\t\t\t dev->adapter->name, fw_info->hw_version,\n\t\t\t fw_info->fw_version[0],\n\t\t\t fw_info->fw_version[1],\n\t\t\t fw_info->fw_version[2],\n\t\t\t dev->adapter->ctrl_count);\n\n\t\t \n\t\tif (fw_info->fw_version[0] >= 2) {\n\t\t\t \n\t\t\tdev->can.ctrlmode_supported |= CAN_CTRLMODE_FD_NON_ISO;\n\t\t} else {\n\t\t\t \n\t\t\tdev->can.ctrlmode |= CAN_CTRLMODE_FD_NON_ISO;\n\t\t}\n\n\t\t \n\t\tif (fw_info->type != cpu_to_le16(PCAN_USBFD_TYPE_EXT)) {\n\t\t\tfw_info->cmd_out_ep = PCAN_USBPRO_EP_CMDOUT;\n\t\t\tfw_info->cmd_in_ep = PCAN_USBPRO_EP_CMDIN;\n\t\t}\n\n\t\t \n\t\terr = pcan_usb_fd_drv_loaded(dev, 1);\n\t\tif (err) {\n\t\t\tdev_err(dev->netdev->dev.parent,\n\t\t\t\t\"unable to tell %s driver is loaded (err %d)\\n\",\n\t\t\t\tdev->adapter->name, err);\n\t\t\tgoto err_out_2;\n\t\t}\n\t} else {\n\t\t \n\t\tstruct pcan_usb_fd_device *ppdev =\n\t\t\tcontainer_of(dev->prev_siblings,\n\t\t\t\t     struct pcan_usb_fd_device, dev);\n\n\t\tpdev->usb_if = ppdev->usb_if;\n\t\tpdev->cmd_buffer_addr = ppdev->cmd_buffer_addr;\n\n\t\t \n\t\tdev->can.ctrlmode = ppdev->dev.can.ctrlmode;\n\t\tdev->can.ctrlmode_supported = ppdev->dev.can.ctrlmode_supported;\n\n\t\tfw_info = &pdev->usb_if->fw_info;\n\t}\n\n\tpdev->usb_if->dev[dev->ctrl_idx] = dev;\n\tdev->can_channel_id =\n\t\tle32_to_cpu(pdev->usb_if->fw_info.dev_id[dev->ctrl_idx]);\n\n\t \n\tif (fw_info->type == cpu_to_le16(PCAN_USBFD_TYPE_EXT)) {\n\t\tdev->ep_msg_in = fw_info->data_in_ep;\n\t\tdev->ep_msg_out = fw_info->data_out_ep[dev->ctrl_idx];\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(pcan_usb_fd_clk_freq); i++)\n\t\tif (dev->adapter->clock.freq == pcan_usb_fd_clk_freq[i])\n\t\t\tbreak;\n\n\tif (i >= ARRAY_SIZE(pcan_usb_fd_clk_freq)) {\n\t\tdev_warn(dev->netdev->dev.parent,\n\t\t\t \"incompatible clock frequencies\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_out_2;\n\t}\n\n\tpcan_usb_fd_set_clock_domain(dev, i);\n\n\t \n\tpcan_usb_fd_set_can_led(dev, PCAN_UFD_LED_DEF);\n\n\treturn 0;\n\nerr_out_2:\n\tkfree(pdev->cmd_buffer_addr);\nerr_out_1:\n\tkfree(pdev->usb_if);\nerr_out:\n\treturn err;\n}\n\n \nstatic void pcan_usb_fd_exit(struct peak_usb_device *dev)\n{\n\tstruct pcan_usb_fd_device *pdev =\n\t\t\tcontainer_of(dev, struct pcan_usb_fd_device, dev);\n\n\t \n\tif (dev->can.state != CAN_STATE_STOPPED) {\n\t\t \n\t\tpcan_usb_fd_set_bus(dev, 0);\n\t}\n\n\t \n\tpcan_usb_fd_set_can_led(dev, PCAN_UFD_LED_OFF);\n\n\t \n\tif (dev->ctrl_idx == 0) {\n\t\t \n\t\tif (pdev->usb_if->dev_opened_count > 0)\n\t\t\tpcan_usb_fd_set_options(dev, 0,\n\t\t\t\t\t\tPUCAN_OPTION_ERROR,\n\t\t\t\t\t\tPCAN_UFD_FLTEXT_CALIBRATION);\n\n\t\t \n\t\tpcan_usb_fd_drv_loaded(dev, 0);\n\t}\n}\n\n \nstatic void pcan_usb_fd_free(struct peak_usb_device *dev)\n{\n\t \n\tif (!dev->prev_siblings && !dev->next_siblings) {\n\t\tstruct pcan_usb_fd_device *pdev =\n\t\t\tcontainer_of(dev, struct pcan_usb_fd_device, dev);\n\n\t\t \n\t\tkfree(pdev->cmd_buffer_addr);\n\n\t\t \n\t\tkfree(pdev->usb_if);\n\t}\n}\n\n \nstatic int pcan_usb_fd_set_phys_id(struct net_device *netdev,\n\t\t\t\t   enum ethtool_phys_id_state state)\n{\n\tstruct peak_usb_device *dev = netdev_priv(netdev);\n\tint err = 0;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\terr = pcan_usb_fd_set_can_led(dev, PCAN_UFD_LED_FAST);\n\t\tbreak;\n\tcase ETHTOOL_ID_INACTIVE:\n\t\terr = pcan_usb_fd_set_can_led(dev, PCAN_UFD_LED_DEF);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic const struct ethtool_ops pcan_usb_fd_ethtool_ops = {\n\t.set_phys_id = pcan_usb_fd_set_phys_id,\n\t.get_ts_info = pcan_get_ts_info,\n\t.get_eeprom_len\t= peak_usb_get_eeprom_len,\n\t.get_eeprom = peak_usb_get_eeprom,\n\t.set_eeprom = peak_usb_set_eeprom,\n};\n\n \nstatic const struct can_bittiming_const pcan_usb_fd_const = {\n\t.name = \"pcan_usb_fd\",\n\t.tseg1_min = 1,\n\t.tseg1_max = (1 << PUCAN_TSLOW_TSGEG1_BITS),\n\t.tseg2_min = 1,\n\t.tseg2_max = (1 << PUCAN_TSLOW_TSGEG2_BITS),\n\t.sjw_max = (1 << PUCAN_TSLOW_SJW_BITS),\n\t.brp_min = 1,\n\t.brp_max = (1 << PUCAN_TSLOW_BRP_BITS),\n\t.brp_inc = 1,\n};\n\nstatic const struct can_bittiming_const pcan_usb_fd_data_const = {\n\t.name = \"pcan_usb_fd\",\n\t.tseg1_min = 1,\n\t.tseg1_max = (1 << PUCAN_TFAST_TSGEG1_BITS),\n\t.tseg2_min = 1,\n\t.tseg2_max = (1 << PUCAN_TFAST_TSGEG2_BITS),\n\t.sjw_max = (1 << PUCAN_TFAST_SJW_BITS),\n\t.brp_min = 1,\n\t.brp_max = (1 << PUCAN_TFAST_BRP_BITS),\n\t.brp_inc = 1,\n};\n\nconst struct peak_usb_adapter pcan_usb_fd = {\n\t.name = \"PCAN-USB FD\",\n\t.device_id = PCAN_USBFD_PRODUCT_ID,\n\t.ctrl_count = PCAN_USBFD_CHANNEL_COUNT,\n\t.ctrlmode_supported = CAN_CTRLMODE_FD |\n\t\t\tCAN_CTRLMODE_3_SAMPLES | CAN_CTRLMODE_LISTENONLY |\n\t\t\tCAN_CTRLMODE_ONE_SHOT | CAN_CTRLMODE_CC_LEN8_DLC,\n\t.clock = {\n\t\t.freq = PCAN_UFD_CRYSTAL_HZ,\n\t},\n\t.bittiming_const = &pcan_usb_fd_const,\n\t.data_bittiming_const = &pcan_usb_fd_data_const,\n\n\t \n\t.sizeof_dev_private = sizeof(struct pcan_usb_fd_device),\n\n\t.ethtool_ops = &pcan_usb_fd_ethtool_ops,\n\n\t \n\t.ts_used_bits = 32,\n\t.us_per_ts_scale = 1,  \n\t.us_per_ts_shift = 0,\n\n\t \n\t.ep_msg_in = PCAN_USBPRO_EP_MSGIN,\n\t.ep_msg_out = {PCAN_USBPRO_EP_MSGOUT_0},\n\n\t \n\t.rx_buffer_size = PCAN_UFD_RX_BUFFER_SIZE,\n\t.tx_buffer_size = PCAN_UFD_TX_BUFFER_SIZE,\n\n\t \n\t.intf_probe = pcan_usb_fd_probe,\n\t.dev_init = pcan_usb_fd_init,\n\n\t.dev_exit = pcan_usb_fd_exit,\n\t.dev_free = pcan_usb_fd_free,\n\t.dev_set_bus = pcan_usb_fd_set_bus,\n\t.dev_set_bittiming = pcan_usb_fd_set_bittiming_slow,\n\t.dev_set_data_bittiming = pcan_usb_fd_set_bittiming_fast,\n\t.dev_get_can_channel_id = pcan_usb_fd_get_can_channel_id,\n\t.dev_set_can_channel_id = pcan_usb_fd_set_can_channel_id,\n\t.dev_decode_buf = pcan_usb_fd_decode_buf,\n\t.dev_start = pcan_usb_fd_start,\n\t.dev_stop = pcan_usb_fd_stop,\n\t.dev_restart_async = pcan_usb_fd_restart_async,\n\t.dev_encode_msg = pcan_usb_fd_encode_msg,\n\n\t.do_get_berr_counter = pcan_usb_fd_get_berr_counter,\n};\n\n \nstatic const struct can_bittiming_const pcan_usb_chip_const = {\n\t.name = \"pcan_chip_usb\",\n\t.tseg1_min = 1,\n\t.tseg1_max = (1 << PUCAN_TSLOW_TSGEG1_BITS),\n\t.tseg2_min = 1,\n\t.tseg2_max = (1 << PUCAN_TSLOW_TSGEG2_BITS),\n\t.sjw_max = (1 << PUCAN_TSLOW_SJW_BITS),\n\t.brp_min = 1,\n\t.brp_max = (1 << PUCAN_TSLOW_BRP_BITS),\n\t.brp_inc = 1,\n};\n\nstatic const struct can_bittiming_const pcan_usb_chip_data_const = {\n\t.name = \"pcan_chip_usb\",\n\t.tseg1_min = 1,\n\t.tseg1_max = (1 << PUCAN_TFAST_TSGEG1_BITS),\n\t.tseg2_min = 1,\n\t.tseg2_max = (1 << PUCAN_TFAST_TSGEG2_BITS),\n\t.sjw_max = (1 << PUCAN_TFAST_SJW_BITS),\n\t.brp_min = 1,\n\t.brp_max = (1 << PUCAN_TFAST_BRP_BITS),\n\t.brp_inc = 1,\n};\n\nconst struct peak_usb_adapter pcan_usb_chip = {\n\t.name = \"PCAN-Chip USB\",\n\t.device_id = PCAN_USBCHIP_PRODUCT_ID,\n\t.ctrl_count = PCAN_USBFD_CHANNEL_COUNT,\n\t.ctrlmode_supported = CAN_CTRLMODE_FD |\n\t\tCAN_CTRLMODE_3_SAMPLES | CAN_CTRLMODE_LISTENONLY |\n\t\tCAN_CTRLMODE_ONE_SHOT | CAN_CTRLMODE_CC_LEN8_DLC,\n\t.clock = {\n\t\t.freq = PCAN_UFD_CRYSTAL_HZ,\n\t},\n\t.bittiming_const = &pcan_usb_chip_const,\n\t.data_bittiming_const = &pcan_usb_chip_data_const,\n\n\t \n\t.sizeof_dev_private = sizeof(struct pcan_usb_fd_device),\n\n\t.ethtool_ops = &pcan_usb_fd_ethtool_ops,\n\n\t \n\t.ts_used_bits = 32,\n\t.us_per_ts_scale = 1,  \n\t.us_per_ts_shift = 0,\n\n\t \n\t.ep_msg_in = PCAN_USBPRO_EP_MSGIN,\n\t.ep_msg_out = {PCAN_USBPRO_EP_MSGOUT_0},\n\n\t \n\t.rx_buffer_size = PCAN_UFD_RX_BUFFER_SIZE,\n\t.tx_buffer_size = PCAN_UFD_TX_BUFFER_SIZE,\n\n\t \n\t.intf_probe = pcan_usb_pro_probe,\t \n\t.dev_init = pcan_usb_fd_init,\n\n\t.dev_exit = pcan_usb_fd_exit,\n\t.dev_free = pcan_usb_fd_free,\n\t.dev_set_bus = pcan_usb_fd_set_bus,\n\t.dev_set_bittiming = pcan_usb_fd_set_bittiming_slow,\n\t.dev_set_data_bittiming = pcan_usb_fd_set_bittiming_fast,\n\t.dev_get_can_channel_id = pcan_usb_fd_get_can_channel_id,\n\t.dev_set_can_channel_id = pcan_usb_fd_set_can_channel_id,\n\t.dev_decode_buf = pcan_usb_fd_decode_buf,\n\t.dev_start = pcan_usb_fd_start,\n\t.dev_stop = pcan_usb_fd_stop,\n\t.dev_restart_async = pcan_usb_fd_restart_async,\n\t.dev_encode_msg = pcan_usb_fd_encode_msg,\n\n\t.do_get_berr_counter = pcan_usb_fd_get_berr_counter,\n};\n\n \nstatic const struct can_bittiming_const pcan_usb_pro_fd_const = {\n\t.name = \"pcan_usb_pro_fd\",\n\t.tseg1_min = 1,\n\t.tseg1_max = (1 << PUCAN_TSLOW_TSGEG1_BITS),\n\t.tseg2_min = 1,\n\t.tseg2_max = (1 << PUCAN_TSLOW_TSGEG2_BITS),\n\t.sjw_max = (1 << PUCAN_TSLOW_SJW_BITS),\n\t.brp_min = 1,\n\t.brp_max = (1 << PUCAN_TSLOW_BRP_BITS),\n\t.brp_inc = 1,\n};\n\nstatic const struct can_bittiming_const pcan_usb_pro_fd_data_const = {\n\t.name = \"pcan_usb_pro_fd\",\n\t.tseg1_min = 1,\n\t.tseg1_max = (1 << PUCAN_TFAST_TSGEG1_BITS),\n\t.tseg2_min = 1,\n\t.tseg2_max = (1 << PUCAN_TFAST_TSGEG2_BITS),\n\t.sjw_max = (1 << PUCAN_TFAST_SJW_BITS),\n\t.brp_min = 1,\n\t.brp_max = (1 << PUCAN_TFAST_BRP_BITS),\n\t.brp_inc = 1,\n};\n\nconst struct peak_usb_adapter pcan_usb_pro_fd = {\n\t.name = \"PCAN-USB Pro FD\",\n\t.device_id = PCAN_USBPROFD_PRODUCT_ID,\n\t.ctrl_count = PCAN_USBPROFD_CHANNEL_COUNT,\n\t.ctrlmode_supported = CAN_CTRLMODE_FD |\n\t\t\tCAN_CTRLMODE_3_SAMPLES | CAN_CTRLMODE_LISTENONLY |\n\t\t\tCAN_CTRLMODE_ONE_SHOT | CAN_CTRLMODE_CC_LEN8_DLC,\n\t.clock = {\n\t\t.freq = PCAN_UFD_CRYSTAL_HZ,\n\t},\n\t.bittiming_const = &pcan_usb_pro_fd_const,\n\t.data_bittiming_const = &pcan_usb_pro_fd_data_const,\n\n\t \n\t.sizeof_dev_private = sizeof(struct pcan_usb_fd_device),\n\n\t.ethtool_ops = &pcan_usb_fd_ethtool_ops,\n\n\t \n\t.ts_used_bits = 32,\n\t.us_per_ts_scale = 1,  \n\t.us_per_ts_shift = 0,\n\n\t \n\t.ep_msg_in = PCAN_USBPRO_EP_MSGIN,\n\t.ep_msg_out = {PCAN_USBPRO_EP_MSGOUT_0, PCAN_USBPRO_EP_MSGOUT_1},\n\n\t \n\t.rx_buffer_size = PCAN_UFD_RX_BUFFER_SIZE,\n\t.tx_buffer_size = PCAN_UFD_TX_BUFFER_SIZE,\n\n\t \n\t.intf_probe = pcan_usb_pro_probe,\t \n\t.dev_init = pcan_usb_fd_init,\n\n\t.dev_exit = pcan_usb_fd_exit,\n\t.dev_free = pcan_usb_fd_free,\n\t.dev_set_bus = pcan_usb_fd_set_bus,\n\t.dev_set_bittiming = pcan_usb_fd_set_bittiming_slow,\n\t.dev_set_data_bittiming = pcan_usb_fd_set_bittiming_fast,\n\t.dev_get_can_channel_id = pcan_usb_fd_get_can_channel_id,\n\t.dev_set_can_channel_id = pcan_usb_fd_set_can_channel_id,\n\t.dev_decode_buf = pcan_usb_fd_decode_buf,\n\t.dev_start = pcan_usb_fd_start,\n\t.dev_stop = pcan_usb_fd_stop,\n\t.dev_restart_async = pcan_usb_fd_restart_async,\n\t.dev_encode_msg = pcan_usb_fd_encode_msg,\n\n\t.do_get_berr_counter = pcan_usb_fd_get_berr_counter,\n};\n\n \nstatic const struct can_bittiming_const pcan_usb_x6_const = {\n\t.name = \"pcan_usb_x6\",\n\t.tseg1_min = 1,\n\t.tseg1_max = (1 << PUCAN_TSLOW_TSGEG1_BITS),\n\t.tseg2_min = 1,\n\t.tseg2_max = (1 << PUCAN_TSLOW_TSGEG2_BITS),\n\t.sjw_max = (1 << PUCAN_TSLOW_SJW_BITS),\n\t.brp_min = 1,\n\t.brp_max = (1 << PUCAN_TSLOW_BRP_BITS),\n\t.brp_inc = 1,\n};\n\nstatic const struct can_bittiming_const pcan_usb_x6_data_const = {\n\t.name = \"pcan_usb_x6\",\n\t.tseg1_min = 1,\n\t.tseg1_max = (1 << PUCAN_TFAST_TSGEG1_BITS),\n\t.tseg2_min = 1,\n\t.tseg2_max = (1 << PUCAN_TFAST_TSGEG2_BITS),\n\t.sjw_max = (1 << PUCAN_TFAST_SJW_BITS),\n\t.brp_min = 1,\n\t.brp_max = (1 << PUCAN_TFAST_BRP_BITS),\n\t.brp_inc = 1,\n};\n\nconst struct peak_usb_adapter pcan_usb_x6 = {\n\t.name = \"PCAN-USB X6\",\n\t.device_id = PCAN_USBX6_PRODUCT_ID,\n\t.ctrl_count = PCAN_USBPROFD_CHANNEL_COUNT,\n\t.ctrlmode_supported = CAN_CTRLMODE_FD |\n\t\t\tCAN_CTRLMODE_3_SAMPLES | CAN_CTRLMODE_LISTENONLY |\n\t\t\tCAN_CTRLMODE_ONE_SHOT | CAN_CTRLMODE_CC_LEN8_DLC,\n\t.clock = {\n\t\t.freq = PCAN_UFD_CRYSTAL_HZ,\n\t},\n\t.bittiming_const = &pcan_usb_x6_const,\n\t.data_bittiming_const = &pcan_usb_x6_data_const,\n\n\t \n\t.sizeof_dev_private = sizeof(struct pcan_usb_fd_device),\n\n\t.ethtool_ops = &pcan_usb_fd_ethtool_ops,\n\n\t \n\t.ts_used_bits = 32,\n\t.us_per_ts_scale = 1,  \n\t.us_per_ts_shift = 0,\n\n\t \n\t.ep_msg_in = PCAN_USBPRO_EP_MSGIN,\n\t.ep_msg_out = {PCAN_USBPRO_EP_MSGOUT_0, PCAN_USBPRO_EP_MSGOUT_1},\n\n\t \n\t.rx_buffer_size = PCAN_UFD_RX_BUFFER_SIZE,\n\t.tx_buffer_size = PCAN_UFD_TX_BUFFER_SIZE,\n\n\t \n\t.intf_probe = pcan_usb_pro_probe,\t \n\t.dev_init = pcan_usb_fd_init,\n\n\t.dev_exit = pcan_usb_fd_exit,\n\t.dev_free = pcan_usb_fd_free,\n\t.dev_set_bus = pcan_usb_fd_set_bus,\n\t.dev_set_bittiming = pcan_usb_fd_set_bittiming_slow,\n\t.dev_set_data_bittiming = pcan_usb_fd_set_bittiming_fast,\n\t.dev_get_can_channel_id = pcan_usb_fd_get_can_channel_id,\n\t.dev_set_can_channel_id = pcan_usb_fd_set_can_channel_id,\n\t.dev_decode_buf = pcan_usb_fd_decode_buf,\n\t.dev_start = pcan_usb_fd_start,\n\t.dev_stop = pcan_usb_fd_stop,\n\t.dev_restart_async = pcan_usb_fd_restart_async,\n\t.dev_encode_msg = pcan_usb_fd_encode_msg,\n\n\t.do_get_berr_counter = pcan_usb_fd_get_berr_counter,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}