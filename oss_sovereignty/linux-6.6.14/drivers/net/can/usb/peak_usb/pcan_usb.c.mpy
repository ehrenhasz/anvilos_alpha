{
  "module_name": "pcan_usb.c",
  "hash_id": "536f52642af139ec6406842045334a80119e5121bb4a17389344eee45ddcf228",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/usb/peak_usb/pcan_usb.c",
  "human_readable_source": "\n \n#include <asm/unaligned.h>\n\n#include <linux/ethtool.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/usb.h>\n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n\n#include \"pcan_usb_core.h\"\n\n \n#define PCAN_USB_EP_CMDOUT\t\t1\n#define PCAN_USB_EP_CMDIN\t\t(PCAN_USB_EP_CMDOUT | USB_DIR_IN)\n#define PCAN_USB_EP_MSGOUT\t\t2\n#define PCAN_USB_EP_MSGIN\t\t(PCAN_USB_EP_MSGOUT | USB_DIR_IN)\n\n \n#define PCAN_USB_CMD_FUNC\t\t0\n#define PCAN_USB_CMD_NUM\t\t1\n#define PCAN_USB_CMD_ARGS\t\t2\n#define PCAN_USB_CMD_ARGS_LEN\t\t14\n#define PCAN_USB_CMD_LEN\t\t(PCAN_USB_CMD_ARGS + \\\n\t\t\t\t\t PCAN_USB_CMD_ARGS_LEN)\n\n \n#define PCAN_USB_CMD_BITRATE\t1\n#define PCAN_USB_CMD_SET_BUS\t3\n#define PCAN_USB_CMD_DEVID\t4\n#define PCAN_USB_CMD_SN\t\t6\n#define PCAN_USB_CMD_REGISTER\t9\n#define PCAN_USB_CMD_EXT_VCC\t10\n#define PCAN_USB_CMD_ERR_FR\t11\n#define PCAN_USB_CMD_LED\t12\n\n \n#define PCAN_USB_BUS_XCVER\t\t2\n#define PCAN_USB_BUS_SILENT_MODE\t3\n\n \n#define PCAN_USB_GET\t\t1\n#define PCAN_USB_SET\t\t2\n\n \n#define PCAN_USB_COMMAND_TIMEOUT\t1000\n\n \n#define PCAN_USB_STARTUP_TIMEOUT\t10\n\n \n#define PCAN_USB_RX_BUFFER_SIZE\t\t64\n#define PCAN_USB_TX_BUFFER_SIZE\t\t64\n\n#define PCAN_USB_MSG_HEADER_LEN\t\t2\n\n#define PCAN_USB_MSG_TX_CAN\t\t2\t \n\n \n#define PCAN_USB_CRYSTAL_HZ\t\t16000000\n\n \n#define PCAN_USB_STATUSLEN_TIMESTAMP\t(1 << 7)\n#define PCAN_USB_STATUSLEN_INTERNAL\t(1 << 6)\n#define PCAN_USB_STATUSLEN_EXT_ID\t(1 << 5)\n#define PCAN_USB_STATUSLEN_RTR\t\t(1 << 4)\n#define PCAN_USB_STATUSLEN_DLC\t\t(0xf)\n\n \n#define PCAN_USB_TX_SRR\t\t\t0x01\t \n#define PCAN_USB_TX_AT\t\t\t0x02\t \n\n \n#define PCAN_USB_ERROR_TXFULL\t\t0x01\n#define PCAN_USB_ERROR_RXQOVR\t\t0x02\n#define PCAN_USB_ERROR_BUS_LIGHT\t0x04\n#define PCAN_USB_ERROR_BUS_HEAVY\t0x08\n#define PCAN_USB_ERROR_BUS_OFF\t\t0x10\n#define PCAN_USB_ERROR_RXQEMPTY\t\t0x20\n#define PCAN_USB_ERROR_QOVR\t\t0x40\n#define PCAN_USB_ERROR_TXQFULL\t\t0x80\n\n#define PCAN_USB_ERROR_BUS\t\t(PCAN_USB_ERROR_BUS_LIGHT | \\\n\t\t\t\t\t PCAN_USB_ERROR_BUS_HEAVY | \\\n\t\t\t\t\t PCAN_USB_ERROR_BUS_OFF)\n\n \n#define SJA1000_MODE_NORMAL\t\t0x00\n#define SJA1000_MODE_INIT\t\t0x01\n\n \n#define PCAN_USB_TS_DIV_SHIFTER\t\t20\n#define PCAN_USB_TS_US_PER_TICK\t\t44739243\n\n \n#define PCAN_USB_REC_ERROR\t\t1\n#define PCAN_USB_REC_ANALOG\t\t2\n#define PCAN_USB_REC_BUSLOAD\t\t3\n#define PCAN_USB_REC_TS\t\t\t4\n#define PCAN_USB_REC_BUSEVT\t\t5\n\n \n#define PCAN_USB_ERR_RXERR\t\t0x02\t \n#define PCAN_USB_ERR_TXERR\t\t0x04\t \n\n \n#define PCAN_USB_BERR_MASK\t(PCAN_USB_ERR_RXERR | PCAN_USB_ERR_TXERR)\n\n \n#define PCAN_USB_ERR_CNT_DEC\t\t0x00\t \n#define PCAN_USB_ERR_CNT_INC\t\t0x80\t \n\n \nstruct pcan_usb {\n\tstruct peak_usb_device dev;\n\tstruct peak_time_ref time_ref;\n\tstruct timer_list restart_timer;\n\tstruct can_berr_counter bec;\n};\n\n \nstruct pcan_usb_msg_context {\n\tu16 ts16;\n\tu8 prev_ts8;\n\tu8 *ptr;\n\tu8 *end;\n\tu8 rec_cnt;\n\tu8 rec_idx;\n\tu8 rec_ts_idx;\n\tstruct net_device *netdev;\n\tstruct pcan_usb *pdev;\n};\n\n \nstatic int pcan_usb_send_cmd(struct peak_usb_device *dev, u8 f, u8 n, u8 *p)\n{\n\tint err;\n\tint actual_length;\n\n\t \n\tif (!(dev->state & PCAN_USB_STATE_CONNECTED))\n\t\treturn 0;\n\n\tdev->cmd_buf[PCAN_USB_CMD_FUNC] = f;\n\tdev->cmd_buf[PCAN_USB_CMD_NUM] = n;\n\n\tif (p)\n\t\tmemcpy(dev->cmd_buf + PCAN_USB_CMD_ARGS,\n\t\t\tp, PCAN_USB_CMD_ARGS_LEN);\n\n\terr = usb_bulk_msg(dev->udev,\n\t\t\tusb_sndbulkpipe(dev->udev, PCAN_USB_EP_CMDOUT),\n\t\t\tdev->cmd_buf, PCAN_USB_CMD_LEN, &actual_length,\n\t\t\tPCAN_USB_COMMAND_TIMEOUT);\n\tif (err)\n\t\tnetdev_err(dev->netdev,\n\t\t\t\"sending cmd f=0x%x n=0x%x failure: %d\\n\",\n\t\t\tf, n, err);\n\treturn err;\n}\n\n \nstatic int pcan_usb_wait_rsp(struct peak_usb_device *dev, u8 f, u8 n, u8 *p)\n{\n\tint err;\n\tint actual_length;\n\n\t \n\tif (!(dev->state & PCAN_USB_STATE_CONNECTED))\n\t\treturn 0;\n\n\t \n\terr = pcan_usb_send_cmd(dev, f, n, NULL);\n\tif (err)\n\t\treturn err;\n\n\terr = usb_bulk_msg(dev->udev,\n\t\tusb_rcvbulkpipe(dev->udev, PCAN_USB_EP_CMDIN),\n\t\tdev->cmd_buf, PCAN_USB_CMD_LEN, &actual_length,\n\t\tPCAN_USB_COMMAND_TIMEOUT);\n\tif (err)\n\t\tnetdev_err(dev->netdev,\n\t\t\t\"waiting rsp f=0x%x n=0x%x failure: %d\\n\", f, n, err);\n\telse if (p)\n\t\tmemcpy(p, dev->cmd_buf + PCAN_USB_CMD_ARGS,\n\t\t\tPCAN_USB_CMD_ARGS_LEN);\n\n\treturn err;\n}\n\nstatic int pcan_usb_set_sja1000(struct peak_usb_device *dev, u8 mode)\n{\n\tu8 args[PCAN_USB_CMD_ARGS_LEN] = {\n\t\t[1] = mode,\n\t};\n\n\treturn pcan_usb_send_cmd(dev, PCAN_USB_CMD_REGISTER, PCAN_USB_SET,\n\t\t\t\t args);\n}\n\nstatic int pcan_usb_set_bus(struct peak_usb_device *dev, u8 onoff)\n{\n\tu8 args[PCAN_USB_CMD_ARGS_LEN] = {\n\t\t[0] = !!onoff,\n\t};\n\n\treturn pcan_usb_send_cmd(dev, PCAN_USB_CMD_SET_BUS, PCAN_USB_BUS_XCVER,\n\t\t\t\t args);\n}\n\nstatic int pcan_usb_set_silent(struct peak_usb_device *dev, u8 onoff)\n{\n\tu8 args[PCAN_USB_CMD_ARGS_LEN] = {\n\t\t[0] = !!onoff,\n\t};\n\n\treturn pcan_usb_send_cmd(dev, PCAN_USB_CMD_SET_BUS,\n\t\t\t\t PCAN_USB_BUS_SILENT_MODE, args);\n}\n\n \nstatic int pcan_usb_set_err_frame(struct peak_usb_device *dev, u8 err_mask)\n{\n\tu8 args[PCAN_USB_CMD_ARGS_LEN] = {\n\t\t[0] = err_mask,\n\t};\n\n\treturn pcan_usb_send_cmd(dev, PCAN_USB_CMD_ERR_FR, PCAN_USB_SET, args);\n}\n\nstatic int pcan_usb_set_ext_vcc(struct peak_usb_device *dev, u8 onoff)\n{\n\tu8 args[PCAN_USB_CMD_ARGS_LEN] = {\n\t\t[0] = !!onoff,\n\t};\n\n\treturn pcan_usb_send_cmd(dev, PCAN_USB_CMD_EXT_VCC, PCAN_USB_SET, args);\n}\n\nstatic int pcan_usb_set_led(struct peak_usb_device *dev, u8 onoff)\n{\n\tu8 args[PCAN_USB_CMD_ARGS_LEN] = {\n\t\t[0] = !!onoff,\n\t};\n\n\treturn pcan_usb_send_cmd(dev, PCAN_USB_CMD_LED, PCAN_USB_SET, args);\n}\n\n \nstatic int pcan_usb_set_bittiming(struct peak_usb_device *dev,\n\t\t\t\t  struct can_bittiming *bt)\n{\n\tu8 args[PCAN_USB_CMD_ARGS_LEN];\n\tu8 btr0, btr1;\n\n\tbtr0 = ((bt->brp - 1) & 0x3f) | (((bt->sjw - 1) & 0x3) << 6);\n\tbtr1 = ((bt->prop_seg + bt->phase_seg1 - 1) & 0xf) |\n\t\t(((bt->phase_seg2 - 1) & 0x7) << 4);\n\tif (dev->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\tbtr1 |= 0x80;\n\n\tnetdev_info(dev->netdev, \"setting BTR0=0x%02x BTR1=0x%02x\\n\",\n\t\tbtr0, btr1);\n\n\targs[0] = btr1;\n\targs[1] = btr0;\n\n\treturn pcan_usb_send_cmd(dev, PCAN_USB_CMD_BITRATE, PCAN_USB_SET, args);\n}\n\n \nstatic int pcan_usb_write_mode(struct peak_usb_device *dev, u8 onoff)\n{\n\tint err;\n\n\terr = pcan_usb_set_bus(dev, onoff);\n\tif (err)\n\t\treturn err;\n\n\tif (!onoff) {\n\t\terr = pcan_usb_set_sja1000(dev, SJA1000_MODE_INIT);\n\t} else {\n\t\t \n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule_timeout(msecs_to_jiffies(PCAN_USB_STARTUP_TIMEOUT));\n\t}\n\n\treturn err;\n}\n\n \nstatic void pcan_usb_restart(struct timer_list *t)\n{\n\tstruct pcan_usb *pdev = from_timer(pdev, t, restart_timer);\n\tstruct peak_usb_device *dev = &pdev->dev;\n\n\t \n\tpeak_usb_restart_complete(dev);\n}\n\n \nstatic void pcan_usb_restart_pending(struct urb *urb)\n{\n\tstruct pcan_usb *pdev = urb->context;\n\n\t \n\tmod_timer(&pdev->restart_timer,\n\t\t\tjiffies + msecs_to_jiffies(PCAN_USB_STARTUP_TIMEOUT));\n\n\t \n\tpeak_usb_async_complete(urb);\n}\n\n \nstatic int pcan_usb_restart_async(struct peak_usb_device *dev, struct urb *urb,\n\t\t\t\t  u8 *buf)\n{\n\tstruct pcan_usb *pdev = container_of(dev, struct pcan_usb, dev);\n\n\tif (timer_pending(&pdev->restart_timer))\n\t\treturn -EBUSY;\n\n\t \n\tbuf[PCAN_USB_CMD_FUNC] = 3;\n\tbuf[PCAN_USB_CMD_NUM] = 2;\n\tbuf[PCAN_USB_CMD_ARGS] = 1;\n\n\tusb_fill_bulk_urb(urb, dev->udev,\n\t\t\tusb_sndbulkpipe(dev->udev, PCAN_USB_EP_CMDOUT),\n\t\t\tbuf, PCAN_USB_CMD_LEN,\n\t\t\tpcan_usb_restart_pending, pdev);\n\n\treturn usb_submit_urb(urb, GFP_ATOMIC);\n}\n\n \nstatic int pcan_usb_get_serial(struct peak_usb_device *dev, u32 *serial_number)\n{\n\tu8 args[PCAN_USB_CMD_ARGS_LEN];\n\tint err;\n\n\terr = pcan_usb_wait_rsp(dev, PCAN_USB_CMD_SN, PCAN_USB_GET, args);\n\tif (err)\n\t\treturn err;\n\t*serial_number = le32_to_cpup((__le32 *)args);\n\n\treturn 0;\n}\n\n \nstatic int pcan_usb_get_can_channel_id(struct peak_usb_device *dev, u32 *can_ch_id)\n{\n\tu8 args[PCAN_USB_CMD_ARGS_LEN];\n\tint err;\n\n\terr = pcan_usb_wait_rsp(dev, PCAN_USB_CMD_DEVID, PCAN_USB_GET, args);\n\tif (err)\n\t\tnetdev_err(dev->netdev, \"getting can channel id failure: %d\\n\", err);\n\n\telse\n\t\t*can_ch_id = args[0];\n\n\treturn err;\n}\n\n \nstatic int pcan_usb_set_can_channel_id(struct peak_usb_device *dev, u32 can_ch_id)\n{\n\tu8 args[PCAN_USB_CMD_ARGS_LEN];\n\n\t \n\tif (can_ch_id > U8_MAX)\n\t\treturn -EINVAL;\n\n\t \n\tif (dev->netdev->flags & IFF_UP)\n\t\treturn -EBUSY;\n\n\targs[0] = can_ch_id;\n\treturn pcan_usb_send_cmd(dev, PCAN_USB_CMD_DEVID, PCAN_USB_SET, args);\n}\n\n \nstatic int pcan_usb_update_ts(struct pcan_usb_msg_context *mc)\n{\n\tif ((mc->ptr + 2) > mc->end)\n\t\treturn -EINVAL;\n\n\tmc->ts16 = get_unaligned_le16(mc->ptr);\n\n\tif (mc->rec_idx > 0)\n\t\tpeak_usb_update_ts_now(&mc->pdev->time_ref, mc->ts16);\n\telse\n\t\tpeak_usb_set_ts_now(&mc->pdev->time_ref, mc->ts16);\n\n\treturn 0;\n}\n\n \nstatic int pcan_usb_decode_ts(struct pcan_usb_msg_context *mc, u8 first_packet)\n{\n\t \n\tif (first_packet) {\n\t\tif ((mc->ptr + 2) > mc->end)\n\t\t\treturn -EINVAL;\n\n\t\tmc->ts16 = get_unaligned_le16(mc->ptr);\n\t\tmc->prev_ts8 = mc->ts16 & 0x00ff;\n\n\t\tmc->ptr += 2;\n\t} else {\n\t\tu8 ts8;\n\n\t\tif ((mc->ptr + 1) > mc->end)\n\t\t\treturn -EINVAL;\n\n\t\tts8 = *mc->ptr++;\n\n\t\tif (ts8 < mc->prev_ts8)\n\t\t\tmc->ts16 += 0x100;\n\n\t\tmc->ts16 &= 0xff00;\n\t\tmc->ts16 |= ts8;\n\t\tmc->prev_ts8 = ts8;\n\t}\n\n\treturn 0;\n}\n\nstatic int pcan_usb_decode_error(struct pcan_usb_msg_context *mc, u8 n,\n\t\t\t\t u8 status_len)\n{\n\tstruct sk_buff *skb;\n\tstruct can_frame *cf;\n\tenum can_state new_state = CAN_STATE_ERROR_ACTIVE;\n\n\t \n\tif (n == PCAN_USB_ERROR_QOVR)\n\t\tif (!mc->pdev->time_ref.tick_count)\n\t\t\treturn 0;\n\n\t \n\tskb = alloc_can_err_skb(mc->netdev, &cf);\n\n\tif (n & PCAN_USB_ERROR_RXQOVR) {\n\t\t \n\t\tnetdev_dbg(mc->netdev, \"data overrun interrupt\\n\");\n\t\tmc->netdev->stats.rx_over_errors++;\n\t\tmc->netdev->stats.rx_errors++;\n\t\tif (cf) {\n\t\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\t\tcf->data[1] |= CAN_ERR_CRTL_RX_OVERFLOW;\n\t\t}\n\t}\n\n\tif (n & PCAN_USB_ERROR_TXQFULL)\n\t\tnetdev_dbg(mc->netdev, \"device Tx queue full)\\n\");\n\n\tif (n & PCAN_USB_ERROR_BUS_OFF) {\n\t\tnew_state = CAN_STATE_BUS_OFF;\n\t} else if (n & PCAN_USB_ERROR_BUS_HEAVY) {\n\t\tnew_state = ((mc->pdev->bec.txerr >= 128) ||\n\t\t\t     (mc->pdev->bec.rxerr >= 128)) ?\n\t\t\t\tCAN_STATE_ERROR_PASSIVE :\n\t\t\t\tCAN_STATE_ERROR_WARNING;\n\t} else {\n\t\tnew_state = CAN_STATE_ERROR_ACTIVE;\n\t}\n\n\t \n\tif (new_state != mc->pdev->dev.can.state) {\n\t\tenum can_state tx_state =\n\t\t\t(mc->pdev->bec.txerr >= mc->pdev->bec.rxerr) ?\n\t\t\t\tnew_state : 0;\n\t\tenum can_state rx_state =\n\t\t\t(mc->pdev->bec.txerr <= mc->pdev->bec.rxerr) ?\n\t\t\t\tnew_state : 0;\n\n\t\tcan_change_state(mc->netdev, cf, tx_state, rx_state);\n\n\t\tif (new_state == CAN_STATE_BUS_OFF) {\n\t\t\tcan_bus_off(mc->netdev);\n\t\t} else if (cf && (cf->can_id & CAN_ERR_CRTL)) {\n\t\t\t \n\t\t\tcf->can_id = CAN_ERR_CNT;\n\t\t\tcf->data[6] = mc->pdev->bec.txerr;\n\t\t\tcf->data[7] = mc->pdev->bec.rxerr;\n\t\t}\n\t}\n\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tif (status_len & PCAN_USB_STATUSLEN_TIMESTAMP) {\n\t\tstruct skb_shared_hwtstamps *hwts = skb_hwtstamps(skb);\n\n\t\tpeak_usb_get_ts_time(&mc->pdev->time_ref, mc->ts16,\n\t\t\t\t     &hwts->hwtstamp);\n\t}\n\n\tnetif_rx(skb);\n\n\treturn 0;\n}\n\n \nstatic int pcan_usb_handle_bus_evt(struct pcan_usb_msg_context *mc, u8 ir)\n{\n\tstruct pcan_usb *pdev = mc->pdev;\n\n\t \n\tswitch (ir) {\n\tcase PCAN_USB_ERR_CNT_DEC:\n\tcase PCAN_USB_ERR_CNT_INC:\n\n\t\t \n\t\tpdev->bec.rxerr = mc->ptr[1];\n\t\tpdev->bec.txerr = mc->ptr[2];\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int pcan_usb_decode_status(struct pcan_usb_msg_context *mc,\n\t\t\t\t  u8 status_len)\n{\n\tu8 rec_len = status_len & PCAN_USB_STATUSLEN_DLC;\n\tu8 f, n;\n\tint err;\n\n\t \n\tif ((mc->ptr + 2) > mc->end)\n\t\treturn -EINVAL;\n\n\tf = mc->ptr[PCAN_USB_CMD_FUNC];\n\tn = mc->ptr[PCAN_USB_CMD_NUM];\n\tmc->ptr += PCAN_USB_CMD_ARGS;\n\n\tif (status_len & PCAN_USB_STATUSLEN_TIMESTAMP) {\n\t\tint err = pcan_usb_decode_ts(mc, !mc->rec_ts_idx);\n\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tmc->rec_ts_idx++;\n\t}\n\n\tswitch (f) {\n\tcase PCAN_USB_REC_ERROR:\n\t\terr = pcan_usb_decode_error(mc, n, status_len);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\n\tcase PCAN_USB_REC_ANALOG:\n\t\t \n\t\trec_len = 2;\n\t\tbreak;\n\n\tcase PCAN_USB_REC_BUSLOAD:\n\t\t \n\t\trec_len = 1;\n\t\tbreak;\n\n\tcase PCAN_USB_REC_TS:\n\t\t \n\t\tif (pcan_usb_update_ts(mc))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase PCAN_USB_REC_BUSEVT:\n\t\t \n\t\terr = pcan_usb_handle_bus_evt(mc, n);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(mc->netdev, \"unexpected function %u\\n\", f);\n\t\tbreak;\n\t}\n\n\tif ((mc->ptr + rec_len) > mc->end)\n\t\treturn -EINVAL;\n\n\tmc->ptr += rec_len;\n\n\treturn 0;\n}\n\n \nstatic int pcan_usb_decode_data(struct pcan_usb_msg_context *mc, u8 status_len)\n{\n\tu8 rec_len = status_len & PCAN_USB_STATUSLEN_DLC;\n\tstruct sk_buff *skb;\n\tstruct can_frame *cf;\n\tstruct skb_shared_hwtstamps *hwts;\n\tu32 can_id_flags;\n\n\tskb = alloc_can_skb(mc->netdev, &cf);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tif (status_len & PCAN_USB_STATUSLEN_EXT_ID) {\n\t\tif ((mc->ptr + 4) > mc->end)\n\t\t\tgoto decode_failed;\n\n\t\tcan_id_flags = get_unaligned_le32(mc->ptr);\n\t\tcf->can_id = can_id_flags >> 3 | CAN_EFF_FLAG;\n\t\tmc->ptr += 4;\n\t} else {\n\t\tif ((mc->ptr + 2) > mc->end)\n\t\t\tgoto decode_failed;\n\n\t\tcan_id_flags = get_unaligned_le16(mc->ptr);\n\t\tcf->can_id = can_id_flags >> 5;\n\t\tmc->ptr += 2;\n\t}\n\n\tcan_frame_set_cc_len(cf, rec_len, mc->pdev->dev.can.ctrlmode);\n\n\t \n\tif (pcan_usb_decode_ts(mc, !mc->rec_ts_idx))\n\t\tgoto decode_failed;\n\n\t \n\tmc->rec_ts_idx++;\n\n\t \n\tmemset(cf->data, 0x0, sizeof(cf->data));\n\tif (status_len & PCAN_USB_STATUSLEN_RTR) {\n\t\tcf->can_id |= CAN_RTR_FLAG;\n\t} else {\n\t\tif ((mc->ptr + rec_len) > mc->end)\n\t\t\tgoto decode_failed;\n\n\t\tmemcpy(cf->data, mc->ptr, cf->len);\n\t\tmc->ptr += rec_len;\n\n\t\t \n\t\tif (can_id_flags & PCAN_USB_TX_SRR)\n\t\t\tmc->ptr++;\n\n\t\t \n\t\tmc->netdev->stats.rx_bytes += cf->len;\n\t}\n\tmc->netdev->stats.rx_packets++;\n\n\t \n\thwts = skb_hwtstamps(skb);\n\tpeak_usb_get_ts_time(&mc->pdev->time_ref, mc->ts16, &hwts->hwtstamp);\n\n\t \n\tnetif_rx(skb);\n\n\treturn 0;\n\ndecode_failed:\n\tdev_kfree_skb(skb);\n\treturn -EINVAL;\n}\n\n \nstatic int pcan_usb_decode_msg(struct peak_usb_device *dev, u8 *ibuf, u32 lbuf)\n{\n\tstruct pcan_usb_msg_context mc = {\n\t\t.rec_cnt = ibuf[1],\n\t\t.ptr = ibuf + PCAN_USB_MSG_HEADER_LEN,\n\t\t.end = ibuf + lbuf,\n\t\t.netdev = dev->netdev,\n\t\t.pdev = container_of(dev, struct pcan_usb, dev),\n\t};\n\tint err;\n\n\tfor (err = 0; mc.rec_idx < mc.rec_cnt && !err; mc.rec_idx++) {\n\t\tu8 sl = *mc.ptr++;\n\n\t\t \n\t\tif (sl & PCAN_USB_STATUSLEN_INTERNAL) {\n\t\t\terr = pcan_usb_decode_status(&mc, sl);\n\t\t \n\t\t} else {\n\t\t\terr = pcan_usb_decode_data(&mc, sl);\n\t\t}\n\t}\n\n\treturn err;\n}\n\n \nstatic int pcan_usb_decode_buf(struct peak_usb_device *dev, struct urb *urb)\n{\n\tint err = 0;\n\n\tif (urb->actual_length > PCAN_USB_MSG_HEADER_LEN) {\n\t\terr = pcan_usb_decode_msg(dev, urb->transfer_buffer,\n\t\t\turb->actual_length);\n\n\t} else if (urb->actual_length > 0) {\n\t\tnetdev_err(dev->netdev, \"usb message length error (%u)\\n\",\n\t\t\turb->actual_length);\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\n\n \nstatic int pcan_usb_encode_msg(struct peak_usb_device *dev, struct sk_buff *skb,\n\t\t\t       u8 *obuf, size_t *size)\n{\n\tstruct net_device *netdev = dev->netdev;\n\tstruct net_device_stats *stats = &netdev->stats;\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tu32 can_id_flags = cf->can_id & CAN_ERR_MASK;\n\tu8 *pc;\n\n\tobuf[0] = PCAN_USB_MSG_TX_CAN;\n\tobuf[1] = 1;\t \n\n\tpc = obuf + PCAN_USB_MSG_HEADER_LEN;\n\n\t \n\t*pc = can_get_cc_dlc(cf, dev->can.ctrlmode);\n\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\t*pc |= PCAN_USB_STATUSLEN_RTR;\n\n\t \n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\t*pc |= PCAN_USB_STATUSLEN_EXT_ID;\n\t\tpc++;\n\n\t\tcan_id_flags <<= 3;\n\n\t\tif (dev->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\t\tcan_id_flags |= PCAN_USB_TX_SRR;\n\n\t\tif (dev->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)\n\t\t\tcan_id_flags |= PCAN_USB_TX_AT;\n\n\t\tput_unaligned_le32(can_id_flags, pc);\n\t\tpc += 4;\n\t} else {\n\t\tpc++;\n\n\t\tcan_id_flags <<= 5;\n\n\t\tif (dev->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\t\tcan_id_flags |= PCAN_USB_TX_SRR;\n\n\t\tif (dev->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)\n\t\t\tcan_id_flags |= PCAN_USB_TX_AT;\n\n\t\tput_unaligned_le16(can_id_flags, pc);\n\t\tpc += 2;\n\t}\n\n\t \n\tif (!(cf->can_id & CAN_RTR_FLAG)) {\n\t\tmemcpy(pc, cf->data, cf->len);\n\t\tpc += cf->len;\n\t}\n\n\t \n\tif (can_id_flags & PCAN_USB_TX_SRR)\n\t\t*pc++ = 0x80;\n\n\tobuf[(*size)-1] = (u8)(stats->tx_packets & 0xff);\n\n\treturn 0;\n}\n\n \nstatic int pcan_usb_get_berr_counter(const struct net_device *netdev,\n\t\t\t\t     struct can_berr_counter *bec)\n{\n\tstruct peak_usb_device *dev = netdev_priv(netdev);\n\tstruct pcan_usb *pdev = container_of(dev, struct pcan_usb, dev);\n\n\t*bec = pdev->bec;\n\n\t \n\treturn 0;\n}\n\n \nstatic int pcan_usb_start(struct peak_usb_device *dev)\n{\n\tstruct pcan_usb *pdev = container_of(dev, struct pcan_usb, dev);\n\tint err;\n\n\t \n\tpeak_usb_init_time_ref(&pdev->time_ref, &pcan_usb);\n\n\tpdev->bec.rxerr = 0;\n\tpdev->bec.txerr = 0;\n\n\t \n\terr = pcan_usb_set_err_frame(dev, PCAN_USB_BERR_MASK);\n\tif (err)\n\t\tnetdev_warn(dev->netdev,\n\t\t\t    \"Asking for BERR reporting error %u\\n\",\n\t\t\t    err);\n\n\t \n\tif (dev->device_rev > 3) {\n\t\terr = pcan_usb_set_silent(dev,\n\t\t\t\tdev->can.ctrlmode & CAN_CTRLMODE_LISTENONLY);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn pcan_usb_set_ext_vcc(dev, 0);\n}\n\nstatic int pcan_usb_init(struct peak_usb_device *dev)\n{\n\tstruct pcan_usb *pdev = container_of(dev, struct pcan_usb, dev);\n\tu32 serial_number;\n\tint err;\n\n\t \n\ttimer_setup(&pdev->restart_timer, pcan_usb_restart, 0);\n\n\t \n\terr = pcan_usb_get_serial(dev, &serial_number);\n\tif (err) {\n\t\tdev_err(dev->netdev->dev.parent,\n\t\t\t\"unable to read %s serial number (err %d)\\n\",\n\t\t\tpcan_usb.name, err);\n\t\treturn err;\n\t}\n\n\tdev_info(dev->netdev->dev.parent,\n\t\t \"PEAK-System %s adapter hwrev %u serial %08X (%u channel)\\n\",\n\t\t pcan_usb.name, dev->device_rev, serial_number,\n\t\t pcan_usb.ctrl_count);\n\n\t \n\tif (dev->device_rev >= 41) {\n\t\tstruct can_priv *priv = netdev_priv(dev->netdev);\n\n\t\tpriv->ctrlmode_supported |= CAN_CTRLMODE_ONE_SHOT |\n\t\t\t\t\t    CAN_CTRLMODE_LOOPBACK;\n\t} else {\n\t\tdev_info(dev->netdev->dev.parent,\n\t\t\t \"Firmware update available. Please contact support@peak-system.com\\n\");\n\t}\n\n\treturn 0;\n}\n\n \nstatic int pcan_usb_probe(struct usb_interface *intf)\n{\n\tstruct usb_host_interface *if_desc;\n\tint i;\n\n\tif_desc = intf->altsetting;\n\n\t \n\tfor (i = 0; i < if_desc->desc.bNumEndpoints; i++) {\n\t\tstruct usb_endpoint_descriptor *ep = &if_desc->endpoint[i].desc;\n\n\t\tswitch (ep->bEndpointAddress) {\n\t\tcase PCAN_USB_EP_CMDOUT:\n\t\tcase PCAN_USB_EP_CMDIN:\n\t\tcase PCAN_USB_EP_MSGOUT:\n\t\tcase PCAN_USB_EP_MSGIN:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int pcan_usb_set_phys_id(struct net_device *netdev,\n\t\t\t\tenum ethtool_phys_id_state state)\n{\n\tstruct peak_usb_device *dev = netdev_priv(netdev);\n\tint err = 0;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\t \n\t\treturn 2;\n\n\tcase ETHTOOL_ID_OFF:\n\t\terr = pcan_usb_set_led(dev, 0);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_ON:\n\t\tfallthrough;\n\n\tcase ETHTOOL_ID_INACTIVE:\n\t\t \n\t\terr = pcan_usb_set_led(dev, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n \nstatic int pcan_usb_get_eeprom_len(struct net_device *netdev)\n{\n\treturn sizeof(u8);\n}\n\nstatic const struct ethtool_ops pcan_usb_ethtool_ops = {\n\t.set_phys_id = pcan_usb_set_phys_id,\n\t.get_ts_info = pcan_get_ts_info,\n\t.get_eeprom_len\t= pcan_usb_get_eeprom_len,\n\t.get_eeprom = peak_usb_get_eeprom,\n\t.set_eeprom = peak_usb_set_eeprom,\n};\n\n \nstatic const struct can_bittiming_const pcan_usb_const = {\n\t.name = \"pcan_usb\",\n\t.tseg1_min = 1,\n\t.tseg1_max = 16,\n\t.tseg2_min = 1,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 64,\n\t.brp_inc = 1,\n};\n\nconst struct peak_usb_adapter pcan_usb = {\n\t.name = \"PCAN-USB\",\n\t.device_id = PCAN_USB_PRODUCT_ID,\n\t.ctrl_count = 1,\n\t.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES | CAN_CTRLMODE_LISTENONLY |\n\t\t\t      CAN_CTRLMODE_CC_LEN8_DLC,\n\t.clock = {\n\t\t.freq = PCAN_USB_CRYSTAL_HZ / 2,\n\t},\n\t.bittiming_const = &pcan_usb_const,\n\n\t \n\t.sizeof_dev_private = sizeof(struct pcan_usb),\n\n\t.ethtool_ops = &pcan_usb_ethtool_ops,\n\n\t \n\t.ts_used_bits = 16,\n\t.us_per_ts_scale = PCAN_USB_TS_US_PER_TICK,  \n\t.us_per_ts_shift = PCAN_USB_TS_DIV_SHIFTER,  \n\n\t \n\t.ep_msg_in = PCAN_USB_EP_MSGIN,\n\t.ep_msg_out = {PCAN_USB_EP_MSGOUT},\n\n\t \n\t.rx_buffer_size = PCAN_USB_RX_BUFFER_SIZE,\n\t.tx_buffer_size = PCAN_USB_TX_BUFFER_SIZE,\n\n\t \n\t.intf_probe = pcan_usb_probe,\n\t.dev_init = pcan_usb_init,\n\t.dev_set_bus = pcan_usb_write_mode,\n\t.dev_set_bittiming = pcan_usb_set_bittiming,\n\t.dev_get_can_channel_id = pcan_usb_get_can_channel_id,\n\t.dev_set_can_channel_id = pcan_usb_set_can_channel_id,\n\t.dev_decode_buf = pcan_usb_decode_buf,\n\t.dev_encode_msg = pcan_usb_encode_msg,\n\t.dev_start = pcan_usb_start,\n\t.dev_restart_async = pcan_usb_restart_async,\n\t.do_get_berr_counter = pcan_usb_get_berr_counter,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}