{
  "module_name": "pcan_usb_pro.h",
  "hash_id": "741e14e30a4555dd7cf855fbcbd4b6e855a8dff2e658f94068f438957fe2e942",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/usb/peak_usb/pcan_usb_pro.h",
  "human_readable_source": " \n \n#ifndef PCAN_USB_PRO_H\n#define PCAN_USB_PRO_H\n\n \n#define PCAN_USBPRO_REQ_INFO\t\t0\n#define PCAN_USBPRO_REQ_FCT\t\t2\n\n \n#define PCAN_USBPRO_INFO_BL\t\t0\n#define PCAN_USBPRO_INFO_FW\t\t1\n\n \n#define PCAN_USBPRO_EP_CMDOUT\t\t1\n#define PCAN_USBPRO_EP_CMDIN\t\t(PCAN_USBPRO_EP_CMDOUT | USB_DIR_IN)\n#define PCAN_USBPRO_EP_MSGOUT_0\t\t2\n#define PCAN_USBPRO_EP_MSGIN\t\t(PCAN_USBPRO_EP_MSGOUT_0 | USB_DIR_IN)\n#define PCAN_USBPRO_EP_MSGOUT_1\t\t3\n#define PCAN_USBPRO_EP_UNUSED\t\t(PCAN_USBPRO_EP_MSGOUT_1 | USB_DIR_IN)\n\n \n#define PCAN_USBPRO_FCT_DRVLD\t\t5  \n#define PCAN_USBPRO_FCT_DRVLD_REQ_LEN\t16\n\n \nstruct __packed pcan_usb_pro_blinfo {\n\t__le32 ctrl_type;\n\tu8 version[4];\n\tu8 day;\n\tu8 month;\n\tu8 year;\n\tu8 dummy;\n\t__le32 serial_num_hi;\n\t__le32 serial_num_lo;\n\t__le32 hw_type;\n\t__le32 hw_rev;\n};\n\n \nstruct __packed pcan_usb_pro_fwinfo {\n\t__le32 ctrl_type;\n\tu8 version[4];\n\tu8 day;\n\tu8 month;\n\tu8 year;\n\tu8 dummy;\n\t__le32 fw_type;\n};\n\n \n#define PCAN_USBPRO_SETBTR\t0x02\n#define PCAN_USBPRO_SETBUSACT\t0x04\n#define PCAN_USBPRO_SETSILENT\t0x05\n#define PCAN_USBPRO_SETDEVID\t0x06\n#define PCAN_USBPRO_SETFILTR\t0x0a\n#define PCAN_USBPRO_SETTS\t0x10\n#define PCAN_USBPRO_GETDEVID\t0x12\n#define PCAN_USBPRO_SETLED\t0x1C\n#define PCAN_USBPRO_RXMSG8\t0x80\n#define PCAN_USBPRO_RXMSG4\t0x81\n#define PCAN_USBPRO_RXMSG0\t0x82\n#define PCAN_USBPRO_RXRTR\t0x83\n#define PCAN_USBPRO_RXSTATUS\t0x84\n#define PCAN_USBPRO_RXTS\t0x85\n#define PCAN_USBPRO_TXMSG8\t0x41\n#define PCAN_USBPRO_TXMSG4\t0x42\n#define PCAN_USBPRO_TXMSG0\t0x43\n\n \nstruct __packed pcan_usb_pro_btr {\n\tu8 data_type;\n\tu8 channel;\n\t__le16 dummy;\n\t__le32 CCBT;\n};\n\nstruct __packed pcan_usb_pro_busact {\n\tu8 data_type;\n\tu8 channel;\n\t__le16 onoff;\n};\n\nstruct __packed pcan_usb_pro_silent {\n\tu8 data_type;\n\tu8 channel;\n\t__le16 onoff;\n};\n\nstruct __packed pcan_usb_pro_filter {\n\tu8 data_type;\n\tu8 dummy;\n\t__le16 filter_mode;\n};\n\nstruct __packed pcan_usb_pro_setts {\n\tu8 data_type;\n\tu8 dummy;\n\t__le16 mode;\n};\n\nstruct __packed pcan_usb_pro_devid {\n\tu8 data_type;\n\tu8 channel;\n\t__le16 dummy;\n\t__le32 dev_num;\n};\n\n#define PCAN_USBPRO_LED_DEVICE\t\t0x00\n#define PCAN_USBPRO_LED_BLINK_FAST\t0x01\n#define PCAN_USBPRO_LED_BLINK_SLOW\t0x02\n#define PCAN_USBPRO_LED_ON\t\t0x03\n#define PCAN_USBPRO_LED_OFF\t\t0x04\n\nstruct __packed pcan_usb_pro_setled {\n\tu8 data_type;\n\tu8 channel;\n\t__le16 mode;\n\t__le32 timeout;\n};\n\nstruct __packed pcan_usb_pro_rxmsg {\n\tu8 data_type;\n\tu8 client;\n\tu8 flags;\n\tu8 len;\n\t__le32 ts32;\n\t__le32 id;\n\n\tu8 data[8];\n};\n\n#define PCAN_USBPRO_STATUS_ERROR\t0x0001\n#define PCAN_USBPRO_STATUS_BUS\t\t0x0002\n#define PCAN_USBPRO_STATUS_OVERRUN\t0x0004\n#define PCAN_USBPRO_STATUS_QOVERRUN\t0x0008\n\nstruct __packed pcan_usb_pro_rxstatus {\n\tu8 data_type;\n\tu8 channel;\n\t__le16 status;\n\t__le32 ts32;\n\t__le32 err_frm;\n};\n\nstruct __packed pcan_usb_pro_rxts {\n\tu8 data_type;\n\tu8 dummy[3];\n\t__le32 ts64[2];\n};\n\nstruct __packed pcan_usb_pro_txmsg {\n\tu8 data_type;\n\tu8 client;\n\tu8 flags;\n\tu8 len;\n\t__le32 id;\n\tu8 data[8];\n};\n\nunion pcan_usb_pro_rec {\n\tu8\t\t\t\tdata_type;\n\tstruct pcan_usb_pro_btr\t\tbtr;\n\tstruct pcan_usb_pro_busact\tbus_act;\n\tstruct pcan_usb_pro_silent\tsilent_mode;\n\tstruct pcan_usb_pro_filter\tfilter_mode;\n\tstruct pcan_usb_pro_setts\tts;\n\tstruct pcan_usb_pro_devid\tdev_id;\n\tstruct pcan_usb_pro_setled\tset_led;\n\tstruct pcan_usb_pro_rxmsg\trx_msg;\n\tstruct pcan_usb_pro_rxstatus\trx_status;\n\tstruct pcan_usb_pro_rxts\trx_ts;\n\tstruct pcan_usb_pro_txmsg\ttx_msg;\n};\n\nint pcan_usb_pro_probe(struct usb_interface *intf);\nint pcan_usb_pro_send_req(struct peak_usb_device *dev, int req_id,\n\t\t\t  int req_value, void *req_addr, int req_size);\nvoid pcan_usb_pro_restart_complete(struct urb *urb);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}