{
  "module_name": "pcan_usb_pro.c",
  "hash_id": "82c5ec3ddeb91d8d03b17d5284d0957987823ec589b239b396e28f533e82f935",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/usb/peak_usb/pcan_usb_pro.c",
  "human_readable_source": "\n \n#include <linux/ethtool.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/usb.h>\n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n\n#include \"pcan_usb_core.h\"\n#include \"pcan_usb_pro.h\"\n\n#define PCAN_USBPRO_CHANNEL_COUNT\t2\n\n \n#define PCAN_USBPRO_CRYSTAL_HZ\t\t56000000\n\n \n#define PCAN_USBPRO_COMMAND_TIMEOUT\t1000\n\n \n#define PCAN_USBPRO_RX_BUFFER_SIZE\t1024\n#define PCAN_USBPRO_TX_BUFFER_SIZE\t64\n\n#define PCAN_USBPRO_MSG_HEADER_LEN\t4\n\n \n#define PCAN_USBPRO_RSP_SUBMIT_MAX\t2\n\n#define PCAN_USBPRO_RTR\t\t\t0x01\n#define PCAN_USBPRO_EXT\t\t\t0x02\n#define PCAN_USBPRO_SS\t\t\t0x08\n\n#define PCAN_USBPRO_CMD_BUFFER_SIZE\t512\n\n \nstruct pcan_usb_pro_interface {\n\tstruct peak_usb_device *dev[PCAN_USBPRO_CHANNEL_COUNT];\n\tstruct peak_time_ref time_ref;\n\tint cm_ignore_count;\n\tint dev_opened_count;\n};\n\n \nstruct pcan_usb_pro_device {\n\tstruct peak_usb_device dev;\n\tstruct pcan_usb_pro_interface *usb_if;\n\tu32 cached_ccbt;\n};\n\n \nstruct pcan_usb_pro_msg {\n\tu8 *rec_ptr;\n\tint rec_buffer_size;\n\tint rec_buffer_len;\n\tunion {\n\t\t__le16 *rec_cnt_rd;\n\t\t__le32 *rec_cnt;\n\t\tu8 *rec_buffer;\n\t} u;\n};\n\n \nstatic u16 pcan_usb_pro_sizeof_rec[256] = {\n\t[PCAN_USBPRO_SETBTR] = sizeof(struct pcan_usb_pro_btr),\n\t[PCAN_USBPRO_SETBUSACT] = sizeof(struct pcan_usb_pro_busact),\n\t[PCAN_USBPRO_SETSILENT] = sizeof(struct pcan_usb_pro_silent),\n\t[PCAN_USBPRO_SETFILTR] = sizeof(struct pcan_usb_pro_filter),\n\t[PCAN_USBPRO_SETTS] = sizeof(struct pcan_usb_pro_setts),\n\t[PCAN_USBPRO_GETDEVID] = sizeof(struct pcan_usb_pro_devid),\n\t[PCAN_USBPRO_SETDEVID] = sizeof(struct pcan_usb_pro_devid),\n\t[PCAN_USBPRO_SETLED] = sizeof(struct pcan_usb_pro_setled),\n\t[PCAN_USBPRO_RXMSG8] = sizeof(struct pcan_usb_pro_rxmsg),\n\t[PCAN_USBPRO_RXMSG4] = sizeof(struct pcan_usb_pro_rxmsg) - 4,\n\t[PCAN_USBPRO_RXMSG0] = sizeof(struct pcan_usb_pro_rxmsg) - 8,\n\t[PCAN_USBPRO_RXRTR] = sizeof(struct pcan_usb_pro_rxmsg) - 8,\n\t[PCAN_USBPRO_RXSTATUS] = sizeof(struct pcan_usb_pro_rxstatus),\n\t[PCAN_USBPRO_RXTS] = sizeof(struct pcan_usb_pro_rxts),\n\t[PCAN_USBPRO_TXMSG8] = sizeof(struct pcan_usb_pro_txmsg),\n\t[PCAN_USBPRO_TXMSG4] = sizeof(struct pcan_usb_pro_txmsg) - 4,\n\t[PCAN_USBPRO_TXMSG0] = sizeof(struct pcan_usb_pro_txmsg) - 8,\n};\n\n \nstatic u8 *pcan_msg_init(struct pcan_usb_pro_msg *pm, void *buffer_addr,\n\t\t\t int buffer_size)\n{\n\tif (buffer_size < PCAN_USBPRO_MSG_HEADER_LEN)\n\t\treturn NULL;\n\n\tpm->u.rec_buffer = (u8 *)buffer_addr;\n\tpm->rec_buffer_size = pm->rec_buffer_len = buffer_size;\n\tpm->rec_ptr = pm->u.rec_buffer + PCAN_USBPRO_MSG_HEADER_LEN;\n\n\treturn pm->rec_ptr;\n}\n\nstatic u8 *pcan_msg_init_empty(struct pcan_usb_pro_msg *pm,\n\t\t\t       void *buffer_addr, int buffer_size)\n{\n\tu8 *pr = pcan_msg_init(pm, buffer_addr, buffer_size);\n\n\tif (pr) {\n\t\tpm->rec_buffer_len = PCAN_USBPRO_MSG_HEADER_LEN;\n\t\t*pm->u.rec_cnt = 0;\n\t}\n\treturn pr;\n}\n\n \nstatic int pcan_msg_add_rec(struct pcan_usb_pro_msg *pm, int id, ...)\n{\n\tint len, i;\n\tu8 *pc;\n\tva_list ap;\n\n\tva_start(ap, id);\n\n\tpc = pm->rec_ptr + 1;\n\n\ti = 0;\n\tswitch (id) {\n\tcase PCAN_USBPRO_TXMSG8:\n\t\ti += 4;\n\t\tfallthrough;\n\tcase PCAN_USBPRO_TXMSG4:\n\t\ti += 4;\n\t\tfallthrough;\n\tcase PCAN_USBPRO_TXMSG0:\n\t\t*pc++ = va_arg(ap, int);\n\t\t*pc++ = va_arg(ap, int);\n\t\t*pc++ = va_arg(ap, int);\n\t\t*(__le32 *)pc = cpu_to_le32(va_arg(ap, u32));\n\t\tpc += 4;\n\t\tmemcpy(pc, va_arg(ap, int *), i);\n\t\tpc += i;\n\t\tbreak;\n\n\tcase PCAN_USBPRO_SETBTR:\n\tcase PCAN_USBPRO_GETDEVID:\n\tcase PCAN_USBPRO_SETDEVID:\n\t\t*pc++ = va_arg(ap, int);\n\t\tpc += 2;\n\t\t*(__le32 *)pc = cpu_to_le32(va_arg(ap, u32));\n\t\tpc += 4;\n\t\tbreak;\n\n\tcase PCAN_USBPRO_SETFILTR:\n\tcase PCAN_USBPRO_SETBUSACT:\n\tcase PCAN_USBPRO_SETSILENT:\n\t\t*pc++ = va_arg(ap, int);\n\t\t*(__le16 *)pc = cpu_to_le16(va_arg(ap, int));\n\t\tpc += 2;\n\t\tbreak;\n\n\tcase PCAN_USBPRO_SETLED:\n\t\t*pc++ = va_arg(ap, int);\n\t\t*(__le16 *)pc = cpu_to_le16(va_arg(ap, int));\n\t\tpc += 2;\n\t\t*(__le32 *)pc = cpu_to_le32(va_arg(ap, u32));\n\t\tpc += 4;\n\t\tbreak;\n\n\tcase PCAN_USBPRO_SETTS:\n\t\tpc++;\n\t\t*(__le16 *)pc = cpu_to_le16(va_arg(ap, int));\n\t\tpc += 2;\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"%s: %s(): unknown data type %02Xh (%d)\\n\",\n\t\t\tPCAN_USB_DRIVER_NAME, __func__, id, id);\n\t\tpc--;\n\t\tbreak;\n\t}\n\n\tlen = pc - pm->rec_ptr;\n\tif (len > 0) {\n\t\tle32_add_cpu(pm->u.rec_cnt, 1);\n\t\t*pm->rec_ptr = id;\n\n\t\tpm->rec_ptr = pc;\n\t\tpm->rec_buffer_len += len;\n\t}\n\n\tva_end(ap);\n\n\treturn len;\n}\n\n \nstatic int pcan_usb_pro_send_cmd(struct peak_usb_device *dev,\n\t\t\t\t struct pcan_usb_pro_msg *pum)\n{\n\tint actual_length;\n\tint err;\n\n\t \n\tif (!(dev->state & PCAN_USB_STATE_CONNECTED))\n\t\treturn 0;\n\n\terr = usb_bulk_msg(dev->udev,\n\t\tusb_sndbulkpipe(dev->udev, PCAN_USBPRO_EP_CMDOUT),\n\t\tpum->u.rec_buffer, pum->rec_buffer_len,\n\t\t&actual_length, PCAN_USBPRO_COMMAND_TIMEOUT);\n\tif (err)\n\t\tnetdev_err(dev->netdev, \"sending command failure: %d\\n\", err);\n\n\treturn err;\n}\n\n \nstatic int pcan_usb_pro_wait_rsp(struct peak_usb_device *dev,\n\t\t\t\t struct pcan_usb_pro_msg *pum)\n{\n\tu8 req_data_type, req_channel;\n\tint actual_length;\n\tint i, err = 0;\n\n\t \n\tif (!(dev->state & PCAN_USB_STATE_CONNECTED))\n\t\treturn 0;\n\n\treq_data_type = pum->u.rec_buffer[4];\n\treq_channel = pum->u.rec_buffer[5];\n\n\t*pum->u.rec_cnt = 0;\n\tfor (i = 0; !err && i < PCAN_USBPRO_RSP_SUBMIT_MAX; i++) {\n\t\tstruct pcan_usb_pro_msg rsp;\n\t\tunion pcan_usb_pro_rec *pr;\n\t\tu32 r, rec_cnt;\n\t\tu16 rec_len;\n\t\tu8 *pc;\n\n\t\terr = usb_bulk_msg(dev->udev,\n\t\t\tusb_rcvbulkpipe(dev->udev, PCAN_USBPRO_EP_CMDIN),\n\t\t\tpum->u.rec_buffer, pum->rec_buffer_len,\n\t\t\t&actual_length, PCAN_USBPRO_COMMAND_TIMEOUT);\n\t\tif (err) {\n\t\t\tnetdev_err(dev->netdev, \"waiting rsp error %d\\n\", err);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (actual_length == 0)\n\t\t\tcontinue;\n\n\t\terr = -EBADMSG;\n\t\tif (actual_length < PCAN_USBPRO_MSG_HEADER_LEN) {\n\t\t\tnetdev_err(dev->netdev,\n\t\t\t\t   \"got abnormal too small rsp (len=%d)\\n\",\n\t\t\t\t   actual_length);\n\t\t\tbreak;\n\t\t}\n\n\t\tpc = pcan_msg_init(&rsp, pum->u.rec_buffer,\n\t\t\tactual_length);\n\n\t\trec_cnt = le32_to_cpu(*rsp.u.rec_cnt);\n\n\t\t \n\t\tfor (r = 0; r < rec_cnt; r++) {\n\t\t\tpr = (union pcan_usb_pro_rec *)pc;\n\t\t\trec_len = pcan_usb_pro_sizeof_rec[pr->data_type];\n\t\t\tif (!rec_len) {\n\t\t\t\tnetdev_err(dev->netdev,\n\t\t\t\t\t   \"got unprocessed record in msg\\n\");\n\t\t\t\tpcan_dump_mem(\"rcvd rsp msg\", pum->u.rec_buffer,\n\t\t\t\t\t      actual_length);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (pr->data_type != req_data_type)\n\t\t\t\tnetdev_err(dev->netdev,\n\t\t\t\t\t   \"got unwanted rsp %xh: ignored\\n\",\n\t\t\t\t\t   pr->data_type);\n\n\t\t\t \n\t\t\telse if ((req_channel != 0xff) &&\n\t\t\t\t(pr->bus_act.channel != req_channel))\n\t\t\t\tnetdev_err(dev->netdev,\n\t\t\t\t\t\"got rsp %xh but on chan%u: ignored\\n\",\n\t\t\t\t\treq_data_type, pr->bus_act.channel);\n\n\t\t\t \n\t\t\telse\n\t\t\t\treturn 0;\n\n\t\t\t \n\t\t\tpc += rec_len;\n\t\t}\n\t}\n\n\treturn (i >= PCAN_USBPRO_RSP_SUBMIT_MAX) ? -ERANGE : err;\n}\n\nint pcan_usb_pro_send_req(struct peak_usb_device *dev, int req_id,\n\t\t\t  int req_value, void *req_addr, int req_size)\n{\n\tint err;\n\tu8 req_type;\n\tunsigned int p;\n\n\t \n\tif (!(dev->state & PCAN_USB_STATE_CONNECTED))\n\t\treturn 0;\n\n\treq_type = USB_TYPE_VENDOR | USB_RECIP_OTHER;\n\n\tswitch (req_id) {\n\tcase PCAN_USBPRO_REQ_FCT:\n\t\tp = usb_sndctrlpipe(dev->udev, 0);\n\t\tbreak;\n\n\tdefault:\n\t\tp = usb_rcvctrlpipe(dev->udev, 0);\n\t\treq_type |= USB_DIR_IN;\n\t\tmemset(req_addr, '\\0', req_size);\n\t\tbreak;\n\t}\n\n\terr = usb_control_msg(dev->udev, p, req_id, req_type, req_value, 0,\n\t\t\t      req_addr, req_size, 2 * USB_CTRL_GET_TIMEOUT);\n\tif (err < 0) {\n\t\tnetdev_info(dev->netdev,\n\t\t\t    \"unable to request usb[type=%d value=%d] err=%d\\n\",\n\t\t\t    req_id, req_value, err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int pcan_usb_pro_set_ts(struct peak_usb_device *dev, u16 onoff)\n{\n\tstruct pcan_usb_pro_msg um;\n\n\tpcan_msg_init_empty(&um, dev->cmd_buf, PCAN_USB_MAX_CMD_LEN);\n\tpcan_msg_add_rec(&um, PCAN_USBPRO_SETTS, onoff);\n\n\treturn pcan_usb_pro_send_cmd(dev, &um);\n}\n\nstatic int pcan_usb_pro_set_bitrate(struct peak_usb_device *dev, u32 ccbt)\n{\n\tstruct pcan_usb_pro_device *pdev =\n\t\t\tcontainer_of(dev, struct pcan_usb_pro_device, dev);\n\tstruct pcan_usb_pro_msg um;\n\n\tpcan_msg_init_empty(&um, dev->cmd_buf, PCAN_USB_MAX_CMD_LEN);\n\tpcan_msg_add_rec(&um, PCAN_USBPRO_SETBTR, dev->ctrl_idx, ccbt);\n\n\t \n\tpdev->cached_ccbt = ccbt;\n\n\treturn pcan_usb_pro_send_cmd(dev, &um);\n}\n\nstatic int pcan_usb_pro_set_bus(struct peak_usb_device *dev, u8 onoff)\n{\n\tstruct pcan_usb_pro_msg um;\n\n\t \n\tif (onoff) {\n\t\tstruct pcan_usb_pro_device *pdev =\n\t\t\t     container_of(dev, struct pcan_usb_pro_device, dev);\n\n\t\tpcan_usb_pro_set_bitrate(dev, pdev->cached_ccbt);\n\t}\n\n\tpcan_msg_init_empty(&um, dev->cmd_buf, PCAN_USB_MAX_CMD_LEN);\n\tpcan_msg_add_rec(&um, PCAN_USBPRO_SETBUSACT, dev->ctrl_idx, onoff);\n\n\treturn pcan_usb_pro_send_cmd(dev, &um);\n}\n\nstatic int pcan_usb_pro_set_silent(struct peak_usb_device *dev, u8 onoff)\n{\n\tstruct pcan_usb_pro_msg um;\n\n\tpcan_msg_init_empty(&um, dev->cmd_buf, PCAN_USB_MAX_CMD_LEN);\n\tpcan_msg_add_rec(&um, PCAN_USBPRO_SETSILENT, dev->ctrl_idx, onoff);\n\n\treturn pcan_usb_pro_send_cmd(dev, &um);\n}\n\nstatic int pcan_usb_pro_set_filter(struct peak_usb_device *dev, u16 filter_mode)\n{\n\tstruct pcan_usb_pro_msg um;\n\n\tpcan_msg_init_empty(&um, dev->cmd_buf, PCAN_USB_MAX_CMD_LEN);\n\tpcan_msg_add_rec(&um, PCAN_USBPRO_SETFILTR, dev->ctrl_idx, filter_mode);\n\n\treturn pcan_usb_pro_send_cmd(dev, &um);\n}\n\nstatic int pcan_usb_pro_set_led(struct peak_usb_device *dev, u8 mode,\n\t\t\t\tu32 timeout)\n{\n\tstruct pcan_usb_pro_msg um;\n\n\tpcan_msg_init_empty(&um, dev->cmd_buf, PCAN_USB_MAX_CMD_LEN);\n\tpcan_msg_add_rec(&um, PCAN_USBPRO_SETLED, dev->ctrl_idx, mode, timeout);\n\n\treturn pcan_usb_pro_send_cmd(dev, &um);\n}\n\nstatic int pcan_usb_pro_get_can_channel_id(struct peak_usb_device *dev,\n\t\t\t\t\t   u32 *can_ch_id)\n{\n\tstruct pcan_usb_pro_devid *pdn;\n\tstruct pcan_usb_pro_msg um;\n\tint err;\n\tu8 *pc;\n\n\tpc = pcan_msg_init_empty(&um, dev->cmd_buf, PCAN_USB_MAX_CMD_LEN);\n\tpcan_msg_add_rec(&um, PCAN_USBPRO_GETDEVID, dev->ctrl_idx);\n\n\terr =  pcan_usb_pro_send_cmd(dev, &um);\n\tif (err)\n\t\treturn err;\n\n\terr = pcan_usb_pro_wait_rsp(dev, &um);\n\tif (err)\n\t\treturn err;\n\n\tpdn = (struct pcan_usb_pro_devid *)pc;\n\t*can_ch_id = le32_to_cpu(pdn->dev_num);\n\n\treturn err;\n}\n\nstatic int pcan_usb_pro_set_can_channel_id(struct peak_usb_device *dev,\n\t\t\t\t\t   u32 can_ch_id)\n{\n\tstruct pcan_usb_pro_msg um;\n\n\tpcan_msg_init_empty(&um, dev->cmd_buf, PCAN_USB_MAX_CMD_LEN);\n\tpcan_msg_add_rec(&um, PCAN_USBPRO_SETDEVID, dev->ctrl_idx,\n\t\t\t can_ch_id);\n\n\treturn pcan_usb_pro_send_cmd(dev, &um);\n}\n\nstatic int pcan_usb_pro_set_bittiming(struct peak_usb_device *dev,\n\t\t\t\t      struct can_bittiming *bt)\n{\n\tu32 ccbt;\n\n\tccbt = (dev->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES) ? 0x00800000 : 0;\n\tccbt |= (bt->sjw - 1) << 24;\n\tccbt |= (bt->phase_seg2 - 1) << 20;\n\tccbt |= (bt->prop_seg + bt->phase_seg1 - 1) << 16;  \n\tccbt |= bt->brp - 1;\n\n\tnetdev_info(dev->netdev, \"setting ccbt=0x%08x\\n\", ccbt);\n\n\treturn pcan_usb_pro_set_bitrate(dev, ccbt);\n}\n\nvoid pcan_usb_pro_restart_complete(struct urb *urb)\n{\n\t \n\tpeak_usb_async_complete(urb);\n\n\t \n\tpeak_usb_restart_complete(urb->context);\n}\n\n \nstatic int pcan_usb_pro_restart_async(struct peak_usb_device *dev,\n\t\t\t\t      struct urb *urb, u8 *buf)\n{\n\tstruct pcan_usb_pro_msg um;\n\n\tpcan_msg_init_empty(&um, buf, PCAN_USB_MAX_CMD_LEN);\n\tpcan_msg_add_rec(&um, PCAN_USBPRO_SETBUSACT, dev->ctrl_idx, 1);\n\n\tusb_fill_bulk_urb(urb, dev->udev,\n\t\t\tusb_sndbulkpipe(dev->udev, PCAN_USBPRO_EP_CMDOUT),\n\t\t\tbuf, PCAN_USB_MAX_CMD_LEN,\n\t\t\tpcan_usb_pro_restart_complete, dev);\n\n\treturn usb_submit_urb(urb, GFP_ATOMIC);\n}\n\nstatic int pcan_usb_pro_drv_loaded(struct peak_usb_device *dev, int loaded)\n{\n\tu8 *buffer;\n\tint err;\n\n\tbuffer = kzalloc(PCAN_USBPRO_FCT_DRVLD_REQ_LEN, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tbuffer[0] = 0;\n\tbuffer[1] = !!loaded;\n\n\terr = pcan_usb_pro_send_req(dev, PCAN_USBPRO_REQ_FCT,\n\t\t\t\t    PCAN_USBPRO_FCT_DRVLD, buffer,\n\t\t\t\t    PCAN_USBPRO_FCT_DRVLD_REQ_LEN);\n\tkfree(buffer);\n\n\treturn err;\n}\n\nstatic inline\nstruct pcan_usb_pro_interface *pcan_usb_pro_dev_if(struct peak_usb_device *dev)\n{\n\tstruct pcan_usb_pro_device *pdev =\n\t\t\tcontainer_of(dev, struct pcan_usb_pro_device, dev);\n\treturn pdev->usb_if;\n}\n\nstatic int pcan_usb_pro_handle_canmsg(struct pcan_usb_pro_interface *usb_if,\n\t\t\t\t      struct pcan_usb_pro_rxmsg *rx)\n{\n\tconst unsigned int ctrl_idx = (rx->len >> 4) & 0x0f;\n\tstruct peak_usb_device *dev = usb_if->dev[ctrl_idx];\n\tstruct net_device *netdev = dev->netdev;\n\tstruct can_frame *can_frame;\n\tstruct sk_buff *skb;\n\tstruct skb_shared_hwtstamps *hwts;\n\n\tskb = alloc_can_skb(netdev, &can_frame);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcan_frame->can_id = le32_to_cpu(rx->id);\n\tcan_frame->len = rx->len & 0x0f;\n\n\tif (rx->flags & PCAN_USBPRO_EXT)\n\t\tcan_frame->can_id |= CAN_EFF_FLAG;\n\n\tif (rx->flags & PCAN_USBPRO_RTR) {\n\t\tcan_frame->can_id |= CAN_RTR_FLAG;\n\t} else {\n\t\tmemcpy(can_frame->data, rx->data, can_frame->len);\n\n\t\tnetdev->stats.rx_bytes += can_frame->len;\n\t}\n\tnetdev->stats.rx_packets++;\n\n\thwts = skb_hwtstamps(skb);\n\tpeak_usb_get_ts_time(&usb_if->time_ref, le32_to_cpu(rx->ts32),\n\t\t\t     &hwts->hwtstamp);\n\n\tnetif_rx(skb);\n\n\treturn 0;\n}\n\nstatic int pcan_usb_pro_handle_error(struct pcan_usb_pro_interface *usb_if,\n\t\t\t\t     struct pcan_usb_pro_rxstatus *er)\n{\n\tconst u16 raw_status = le16_to_cpu(er->status);\n\tconst unsigned int ctrl_idx = (er->channel >> 4) & 0x0f;\n\tstruct peak_usb_device *dev = usb_if->dev[ctrl_idx];\n\tstruct net_device *netdev = dev->netdev;\n\tstruct can_frame *can_frame;\n\tenum can_state new_state = CAN_STATE_ERROR_ACTIVE;\n\tu8 err_mask = 0;\n\tstruct sk_buff *skb;\n\tstruct skb_shared_hwtstamps *hwts;\n\n\t \n\tif (dev->can.state == CAN_STATE_BUS_OFF)\n\t\treturn 0;\n\n\tif (!raw_status) {\n\t\t \n\t\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\treturn 0;\n\t}\n\n\tif (raw_status & (PCAN_USBPRO_STATUS_OVERRUN |\n\t\t\t  PCAN_USBPRO_STATUS_QOVERRUN)) {\n\t\t \n\t\tnew_state = CAN_STATE_MAX;\n\t}\n\n\tif (raw_status & PCAN_USBPRO_STATUS_BUS) {\n\t\tnew_state = CAN_STATE_BUS_OFF;\n\t} else if (raw_status & PCAN_USBPRO_STATUS_ERROR) {\n\t\tu32 rx_err_cnt = (le32_to_cpu(er->err_frm) & 0x00ff0000) >> 16;\n\t\tu32 tx_err_cnt = (le32_to_cpu(er->err_frm) & 0xff000000) >> 24;\n\n\t\tif (rx_err_cnt > 127)\n\t\t\terr_mask |= CAN_ERR_CRTL_RX_PASSIVE;\n\t\telse if (rx_err_cnt > 96)\n\t\t\terr_mask |= CAN_ERR_CRTL_RX_WARNING;\n\n\t\tif (tx_err_cnt > 127)\n\t\t\terr_mask |= CAN_ERR_CRTL_TX_PASSIVE;\n\t\telse if (tx_err_cnt > 96)\n\t\t\terr_mask |= CAN_ERR_CRTL_TX_WARNING;\n\n\t\tif (err_mask & (CAN_ERR_CRTL_RX_WARNING |\n\t\t\t\tCAN_ERR_CRTL_TX_WARNING))\n\t\t\tnew_state = CAN_STATE_ERROR_WARNING;\n\t\telse if (err_mask & (CAN_ERR_CRTL_RX_PASSIVE |\n\t\t\t\t     CAN_ERR_CRTL_TX_PASSIVE))\n\t\t\tnew_state = CAN_STATE_ERROR_PASSIVE;\n\t}\n\n\t \n\tif (dev->can.state == new_state)\n\t\treturn 0;\n\n\t \n\tskb = alloc_can_err_skb(netdev, &can_frame);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tswitch (new_state) {\n\tcase CAN_STATE_BUS_OFF:\n\t\tcan_frame->can_id |= CAN_ERR_BUSOFF;\n\t\tdev->can.can_stats.bus_off++;\n\t\tcan_bus_off(netdev);\n\t\tbreak;\n\n\tcase CAN_STATE_ERROR_PASSIVE:\n\t\tcan_frame->can_id |= CAN_ERR_CRTL;\n\t\tcan_frame->data[1] |= err_mask;\n\t\tdev->can.can_stats.error_passive++;\n\t\tbreak;\n\n\tcase CAN_STATE_ERROR_WARNING:\n\t\tcan_frame->can_id |= CAN_ERR_CRTL;\n\t\tcan_frame->data[1] |= err_mask;\n\t\tdev->can.can_stats.error_warning++;\n\t\tbreak;\n\n\tcase CAN_STATE_ERROR_ACTIVE:\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tif (raw_status & PCAN_USBPRO_STATUS_OVERRUN) {\n\t\t\tcan_frame->can_id |= CAN_ERR_PROT;\n\t\t\tcan_frame->data[2] |= CAN_ERR_PROT_OVERLOAD;\n\t\t\tnetdev->stats.rx_over_errors++;\n\t\t\tnetdev->stats.rx_errors++;\n\t\t}\n\n\t\tif (raw_status & PCAN_USBPRO_STATUS_QOVERRUN) {\n\t\t\tcan_frame->can_id |= CAN_ERR_CRTL;\n\t\t\tcan_frame->data[1] |= CAN_ERR_CRTL_RX_OVERFLOW;\n\t\t\tnetdev->stats.rx_over_errors++;\n\t\t\tnetdev->stats.rx_errors++;\n\t\t}\n\n\t\tnew_state = CAN_STATE_ERROR_ACTIVE;\n\t\tbreak;\n\t}\n\n\tdev->can.state = new_state;\n\n\thwts = skb_hwtstamps(skb);\n\tpeak_usb_get_ts_time(&usb_if->time_ref, le32_to_cpu(er->ts32), &hwts->hwtstamp);\n\tnetif_rx(skb);\n\n\treturn 0;\n}\n\nstatic void pcan_usb_pro_handle_ts(struct pcan_usb_pro_interface *usb_if,\n\t\t\t\t   struct pcan_usb_pro_rxts *ts)\n{\n\t \n\tif (usb_if->cm_ignore_count > 0)\n\t\tusb_if->cm_ignore_count--;\n\telse\n\t\tpeak_usb_set_ts_now(&usb_if->time_ref,\n\t\t\t\t    le32_to_cpu(ts->ts64[1]));\n}\n\n \nstatic int pcan_usb_pro_decode_buf(struct peak_usb_device *dev, struct urb *urb)\n{\n\tstruct pcan_usb_pro_interface *usb_if = pcan_usb_pro_dev_if(dev);\n\tstruct net_device *netdev = dev->netdev;\n\tstruct pcan_usb_pro_msg usb_msg;\n\tu8 *rec_ptr, *msg_end;\n\tu16 rec_cnt;\n\tint err = 0;\n\n\trec_ptr = pcan_msg_init(&usb_msg, urb->transfer_buffer,\n\t\t\t\t\turb->actual_length);\n\tif (!rec_ptr) {\n\t\tnetdev_err(netdev, \"bad msg hdr len %d\\n\", urb->actual_length);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmsg_end = urb->transfer_buffer + urb->actual_length;\n\trec_cnt = le16_to_cpu(*usb_msg.u.rec_cnt_rd);\n\tfor (; rec_cnt > 0; rec_cnt--) {\n\t\tunion pcan_usb_pro_rec *pr = (union pcan_usb_pro_rec *)rec_ptr;\n\t\tu16 sizeof_rec = pcan_usb_pro_sizeof_rec[pr->data_type];\n\n\t\tif (!sizeof_rec) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"got unsupported rec in usb msg:\\n\");\n\t\t\terr = -ENOTSUPP;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (rec_ptr + sizeof_rec > msg_end) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t\"got frag rec: should inc usb rx buf size\\n\");\n\t\t\terr = -EBADMSG;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (pr->data_type) {\n\t\tcase PCAN_USBPRO_RXMSG8:\n\t\tcase PCAN_USBPRO_RXMSG4:\n\t\tcase PCAN_USBPRO_RXMSG0:\n\t\tcase PCAN_USBPRO_RXRTR:\n\t\t\terr = pcan_usb_pro_handle_canmsg(usb_if, &pr->rx_msg);\n\t\t\tif (err < 0)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\n\t\tcase PCAN_USBPRO_RXSTATUS:\n\t\t\terr = pcan_usb_pro_handle_error(usb_if, &pr->rx_status);\n\t\t\tif (err < 0)\n\t\t\t\tgoto fail;\n\t\t\tbreak;\n\n\t\tcase PCAN_USBPRO_RXTS:\n\t\t\tpcan_usb_pro_handle_ts(usb_if, &pr->rx_ts);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"unhandled rec type 0x%02x (%d): ignored\\n\",\n\t\t\t\t   pr->data_type, pr->data_type);\n\t\t\tbreak;\n\t\t}\n\n\t\trec_ptr += sizeof_rec;\n\t}\n\nfail:\n\tif (err)\n\t\tpcan_dump_mem(\"received msg\",\n\t\t\t      urb->transfer_buffer, urb->actual_length);\n\n\treturn err;\n}\n\nstatic int pcan_usb_pro_encode_msg(struct peak_usb_device *dev,\n\t\t\t\t   struct sk_buff *skb, u8 *obuf, size_t *size)\n{\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tu8 data_type, len, flags;\n\tstruct pcan_usb_pro_msg usb_msg;\n\n\tpcan_msg_init_empty(&usb_msg, obuf, *size);\n\n\tif ((cf->can_id & CAN_RTR_FLAG) || (cf->len == 0))\n\t\tdata_type = PCAN_USBPRO_TXMSG0;\n\telse if (cf->len <= 4)\n\t\tdata_type = PCAN_USBPRO_TXMSG4;\n\telse\n\t\tdata_type = PCAN_USBPRO_TXMSG8;\n\n\tlen = (dev->ctrl_idx << 4) | (cf->len & 0x0f);\n\n\tflags = 0;\n\tif (cf->can_id & CAN_EFF_FLAG)\n\t\tflags |= PCAN_USBPRO_EXT;\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tflags |= PCAN_USBPRO_RTR;\n\n\t \n\tif (dev->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)\n\t\tflags |= PCAN_USBPRO_SS;\n\n\tpcan_msg_add_rec(&usb_msg, data_type, 0, flags, len, cf->can_id,\n\t\t\t cf->data);\n\n\t*size = usb_msg.rec_buffer_len;\n\n\treturn 0;\n}\n\nstatic int pcan_usb_pro_start(struct peak_usb_device *dev)\n{\n\tstruct pcan_usb_pro_device *pdev =\n\t\t\tcontainer_of(dev, struct pcan_usb_pro_device, dev);\n\tint err;\n\n\terr = pcan_usb_pro_set_silent(dev,\n\t\t\t\tdev->can.ctrlmode & CAN_CTRLMODE_LISTENONLY);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = pcan_usb_pro_set_filter(dev, 1);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (pdev->usb_if->dev_opened_count == 0) {\n\t\t \n\t\tpeak_usb_init_time_ref(&pdev->usb_if->time_ref, &pcan_usb_pro);\n\n\t\t \n\t\terr = pcan_usb_pro_set_ts(dev, 1);\n\t}\n\n\tpdev->usb_if->dev_opened_count++;\n\n\treturn err;\n}\n\n \nstatic int pcan_usb_pro_stop(struct peak_usb_device *dev)\n{\n\tstruct pcan_usb_pro_device *pdev =\n\t\t\tcontainer_of(dev, struct pcan_usb_pro_device, dev);\n\n\t \n\tif (pdev->usb_if->dev_opened_count == 1)\n\t\tpcan_usb_pro_set_ts(dev, 0);\n\n\tpdev->usb_if->dev_opened_count--;\n\n\treturn 0;\n}\n\n \nstatic int pcan_usb_pro_init(struct peak_usb_device *dev)\n{\n\tstruct pcan_usb_pro_device *pdev =\n\t\t\tcontainer_of(dev, struct pcan_usb_pro_device, dev);\n\tstruct pcan_usb_pro_interface *usb_if = NULL;\n\tstruct pcan_usb_pro_fwinfo *fi = NULL;\n\tstruct pcan_usb_pro_blinfo *bi = NULL;\n\tint err;\n\n\t \n\tif (!dev->prev_siblings) {\n\t\t \n\t\tusb_if = kzalloc(sizeof(struct pcan_usb_pro_interface),\n\t\t\t\t GFP_KERNEL);\n\t\tfi = kmalloc(sizeof(struct pcan_usb_pro_fwinfo), GFP_KERNEL);\n\t\tbi = kmalloc(sizeof(struct pcan_usb_pro_blinfo), GFP_KERNEL);\n\t\tif (!usb_if || !fi || !bi) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\t \n\t\tusb_if->cm_ignore_count = 5;\n\n\t\t \n\t\terr = pcan_usb_pro_send_req(dev, PCAN_USBPRO_REQ_INFO,\n\t\t\t\t\t    PCAN_USBPRO_INFO_FW,\n\t\t\t\t\t    fi, sizeof(*fi));\n\t\tif (err) {\n\t\t\tdev_err(dev->netdev->dev.parent,\n\t\t\t\t\"unable to read %s firmware info (err %d)\\n\",\n\t\t\t\tpcan_usb_pro.name, err);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\terr = pcan_usb_pro_send_req(dev, PCAN_USBPRO_REQ_INFO,\n\t\t\t\t\t    PCAN_USBPRO_INFO_BL,\n\t\t\t\t\t    bi, sizeof(*bi));\n\t\tif (err) {\n\t\t\tdev_err(dev->netdev->dev.parent,\n\t\t\t\t\"unable to read %s bootloader info (err %d)\\n\",\n\t\t\t\tpcan_usb_pro.name, err);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\t \n\t\terr = pcan_usb_pro_drv_loaded(dev, 1);\n\t\tif (err)\n\t\t\tgoto err_out;\n\n\t\tdev_info(dev->netdev->dev.parent,\n\t\t     \"PEAK-System %s hwrev %u serial %08X.%08X (%u channels)\\n\",\n\t\t     pcan_usb_pro.name,\n\t\t     bi->hw_rev, bi->serial_num_hi, bi->serial_num_lo,\n\t\t     pcan_usb_pro.ctrl_count);\n\t} else {\n\t\tusb_if = pcan_usb_pro_dev_if(dev->prev_siblings);\n\t}\n\n\tpdev->usb_if = usb_if;\n\tusb_if->dev[dev->ctrl_idx] = dev;\n\n\t \n\tpcan_usb_pro_set_led(dev, PCAN_USBPRO_LED_DEVICE, 1);\n\n\tkfree(bi);\n\tkfree(fi);\n\n\treturn 0;\n\n err_out:\n\tkfree(bi);\n\tkfree(fi);\n\tkfree(usb_if);\n\n\treturn err;\n}\n\nstatic void pcan_usb_pro_exit(struct peak_usb_device *dev)\n{\n\tstruct pcan_usb_pro_device *pdev =\n\t\t\tcontainer_of(dev, struct pcan_usb_pro_device, dev);\n\n\t \n\tif (dev->can.state != CAN_STATE_STOPPED) {\n\t\t \n\t\tpcan_usb_pro_set_bus(dev, 0);\n\t}\n\n\t \n\tif (dev->ctrl_idx == 0) {\n\t\t \n\t\tif (pdev->usb_if->dev_opened_count > 0)\n\t\t\tpcan_usb_pro_set_ts(dev, 0);\n\n\t\t \n\t\tpcan_usb_pro_drv_loaded(dev, 0);\n\t}\n}\n\n \nstatic void pcan_usb_pro_free(struct peak_usb_device *dev)\n{\n\t \n\tif (!dev->prev_siblings && !dev->next_siblings)\n\t\tkfree(pcan_usb_pro_dev_if(dev));\n}\n\n \nint pcan_usb_pro_probe(struct usb_interface *intf)\n{\n\tstruct usb_host_interface *if_desc;\n\tint i;\n\n\tif_desc = intf->altsetting;\n\n\t \n\tfor (i = 0; i < if_desc->desc.bNumEndpoints; i++) {\n\t\tstruct usb_endpoint_descriptor *ep = &if_desc->endpoint[i].desc;\n\n\t\t \n\t\tswitch (ep->bEndpointAddress) {\n\t\tcase PCAN_USBPRO_EP_CMDOUT:\n\t\tcase PCAN_USBPRO_EP_CMDIN:\n\t\tcase PCAN_USBPRO_EP_MSGOUT_0:\n\t\tcase PCAN_USBPRO_EP_MSGOUT_1:\n\t\tcase PCAN_USBPRO_EP_MSGIN:\n\t\tcase PCAN_USBPRO_EP_UNUSED:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int pcan_usb_pro_set_phys_id(struct net_device *netdev,\n\t\t\t\t    enum ethtool_phys_id_state state)\n{\n\tstruct peak_usb_device *dev = netdev_priv(netdev);\n\tint err = 0;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\t \n\t\terr = pcan_usb_pro_set_led(dev, PCAN_USBPRO_LED_BLINK_FAST,\n\t\t\t\t\t   0xffffffff);\n\t\tbreak;\n\n\tcase ETHTOOL_ID_INACTIVE:\n\t\t \n\t\terr = pcan_usb_pro_set_led(dev, PCAN_USBPRO_LED_DEVICE, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic const struct ethtool_ops pcan_usb_pro_ethtool_ops = {\n\t.set_phys_id = pcan_usb_pro_set_phys_id,\n\t.get_ts_info = pcan_get_ts_info,\n\t.get_eeprom_len\t= peak_usb_get_eeprom_len,\n\t.get_eeprom = peak_usb_get_eeprom,\n\t.set_eeprom = peak_usb_set_eeprom,\n};\n\n \nstatic const struct can_bittiming_const pcan_usb_pro_const = {\n\t.name = \"pcan_usb_pro\",\n\t.tseg1_min = 1,\n\t.tseg1_max = 16,\n\t.tseg2_min = 1,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 1024,\n\t.brp_inc = 1,\n};\n\nconst struct peak_usb_adapter pcan_usb_pro = {\n\t.name = \"PCAN-USB Pro\",\n\t.device_id = PCAN_USBPRO_PRODUCT_ID,\n\t.ctrl_count = PCAN_USBPRO_CHANNEL_COUNT,\n\t.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES | CAN_CTRLMODE_LISTENONLY |\n\t\t\t      CAN_CTRLMODE_ONE_SHOT,\n\t.clock = {\n\t\t.freq = PCAN_USBPRO_CRYSTAL_HZ,\n\t},\n\t.bittiming_const = &pcan_usb_pro_const,\n\n\t \n\t.sizeof_dev_private = sizeof(struct pcan_usb_pro_device),\n\n\t.ethtool_ops = &pcan_usb_pro_ethtool_ops,\n\n\t \n\t.ts_used_bits = 32,\n\t.us_per_ts_scale = 1,  \n\t.us_per_ts_shift = 0,\n\n\t \n\t.ep_msg_in = PCAN_USBPRO_EP_MSGIN,\n\t.ep_msg_out = {PCAN_USBPRO_EP_MSGOUT_0, PCAN_USBPRO_EP_MSGOUT_1},\n\n\t \n\t.rx_buffer_size = PCAN_USBPRO_RX_BUFFER_SIZE,\n\t.tx_buffer_size = PCAN_USBPRO_TX_BUFFER_SIZE,\n\n\t \n\t.intf_probe = pcan_usb_pro_probe,\n\t.dev_init = pcan_usb_pro_init,\n\t.dev_exit = pcan_usb_pro_exit,\n\t.dev_free = pcan_usb_pro_free,\n\t.dev_set_bus = pcan_usb_pro_set_bus,\n\t.dev_set_bittiming = pcan_usb_pro_set_bittiming,\n\t.dev_get_can_channel_id = pcan_usb_pro_get_can_channel_id,\n\t.dev_set_can_channel_id = pcan_usb_pro_set_can_channel_id,\n\t.dev_decode_buf = pcan_usb_pro_decode_buf,\n\t.dev_encode_msg = pcan_usb_pro_encode_msg,\n\t.dev_start = pcan_usb_pro_start,\n\t.dev_stop = pcan_usb_pro_stop,\n\t.dev_restart_async = pcan_usb_pro_restart_async,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}