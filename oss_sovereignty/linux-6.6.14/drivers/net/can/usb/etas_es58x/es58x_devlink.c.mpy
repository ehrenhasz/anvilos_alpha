{
  "module_name": "es58x_devlink.c",
  "hash_id": "60d59e446c7d15e4924b305611959a870cecce822d600019d58c515472e608c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/usb/etas_es58x/es58x_devlink.c",
  "human_readable_source": "\n\n \n\n#include <linux/ctype.h>\n#include <linux/device.h>\n#include <linux/usb.h>\n#include <net/devlink.h>\n\n#include \"es58x_core.h\"\n\n \n#define ES58X_PROD_INFO_IDX 6\n\n \nstatic int es58x_parse_sw_version(struct es58x_device *es58x_dev,\n\t\t\t\t  const char *prod_info, const char *prefix)\n{\n\tstruct es58x_sw_version *version;\n\tint major, minor, revision;\n\n\tif (!strcmp(prefix, \"FW\"))\n\t\tversion = &es58x_dev->firmware_version;\n\telse if (!strcmp(prefix, \"BL\"))\n\t\tversion = &es58x_dev->bootloader_version;\n\telse\n\t\treturn -EINVAL;\n\n\t \n\tprod_info = strstr(prod_info, prefix);\n\tif (!prod_info)\n\t\treturn -EBADMSG;\n\t \n\twhile (!isdigit(*prod_info)) {\n\t\tprod_info++;\n\t\tif (!*prod_info)\n\t\t\treturn -EBADMSG;\n\t}\n\n\tif (sscanf(prod_info, \"%2u.%2u.%2u\", &major, &minor, &revision) != 3)\n\t\treturn -EBADMSG;\n\n\tversion->major = major;\n\tversion->minor = minor;\n\tversion->revision = revision;\n\n\treturn 0;\n}\n\n \nstatic int es58x_parse_hw_rev(struct es58x_device *es58x_dev,\n\t\t\t      const char *prod_info)\n{\n\tchar letter;\n\tint major, minor;\n\n\t \n\tprod_info = strchr(prod_info, 'H');\n\tif (!prod_info)\n\t\treturn -EBADMSG;\n\t \n\tprod_info = strchr(prod_info, ':');\n\tif (!prod_info)\n\t\treturn -EBADMSG;\n\tprod_info++;\n\n\tif (sscanf(prod_info, \"%c%3u/%3u\", &letter, &major, &minor) != 3)\n\t\treturn -EBADMSG;\n\n\tes58x_dev->hardware_revision.letter = letter;\n\tes58x_dev->hardware_revision.major = major;\n\tes58x_dev->hardware_revision.minor = minor;\n\n\treturn 0;\n}\n\n \nvoid es58x_parse_product_info(struct es58x_device *es58x_dev)\n{\n\tstatic const struct es58x_sw_version sw_version_not_set = {\n\t\t.major = -1,\n\t\t.minor = -1,\n\t\t.revision = -1,\n\t};\n\tstatic const struct es58x_hw_revision hw_revision_not_set = {\n\t\t.letter = '\\0',\n\t\t.major = -1,\n\t\t.minor = -1,\n\t};\n\tchar *prod_info;\n\n\tes58x_dev->firmware_version = sw_version_not_set;\n\tes58x_dev->bootloader_version = sw_version_not_set;\n\tes58x_dev->hardware_revision = hw_revision_not_set;\n\n\tprod_info = usb_cache_string(es58x_dev->udev, ES58X_PROD_INFO_IDX);\n\tif (!prod_info) {\n\t\tdev_warn(es58x_dev->dev,\n\t\t\t \"could not retrieve the product info string\\n\");\n\t\treturn;\n\t}\n\n\tif (es58x_parse_sw_version(es58x_dev, prod_info, \"FW\") ||\n\t    es58x_parse_sw_version(es58x_dev, prod_info, \"BL\") ||\n\t    es58x_parse_hw_rev(es58x_dev, prod_info))\n\t\tdev_info(es58x_dev->dev,\n\t\t\t \"could not parse product info: '%s'\\n\", prod_info);\n\n\tkfree(prod_info);\n}\n\n \nstatic inline bool es58x_sw_version_is_valid(struct es58x_sw_version *sw_ver)\n{\n\treturn sw_ver->major < 100 && sw_ver->minor < 100 &&\n\t\tsw_ver->revision < 100;\n}\n\n \nstatic inline bool es58x_hw_revision_is_valid(struct es58x_hw_revision *hw_rev)\n{\n\treturn isalnum(hw_rev->letter) && hw_rev->major < 1000 &&\n\t\thw_rev->minor < 1000;\n}\n\n \nstatic int es58x_devlink_info_get(struct devlink *devlink,\n\t\t\t\t  struct devlink_info_req *req,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct es58x_device *es58x_dev = devlink_priv(devlink);\n\tstruct es58x_sw_version *fw_ver = &es58x_dev->firmware_version;\n\tstruct es58x_sw_version *bl_ver = &es58x_dev->bootloader_version;\n\tstruct es58x_hw_revision *hw_rev = &es58x_dev->hardware_revision;\n\tchar buf[max(sizeof(\"xx.xx.xx\"), sizeof(\"axxx/xxx\"))];\n\tint ret = 0;\n\n\tif (es58x_sw_version_is_valid(fw_ver)) {\n\t\tsnprintf(buf, sizeof(buf), \"%02u.%02u.%02u\",\n\t\t\t fw_ver->major, fw_ver->minor, fw_ver->revision);\n\t\tret = devlink_info_version_running_put(req,\n\t\t\t\t\t\t       DEVLINK_INFO_VERSION_GENERIC_FW,\n\t\t\t\t\t\t       buf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (es58x_sw_version_is_valid(bl_ver)) {\n\t\tsnprintf(buf, sizeof(buf), \"%02u.%02u.%02u\",\n\t\t\t bl_ver->major, bl_ver->minor, bl_ver->revision);\n\t\tret = devlink_info_version_running_put(req,\n\t\t\t\t\t\t       DEVLINK_INFO_VERSION_GENERIC_FW_BOOTLOADER,\n\t\t\t\t\t\t       buf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (es58x_hw_revision_is_valid(hw_rev)) {\n\t\tsnprintf(buf, sizeof(buf), \"%c%03u/%03u\",\n\t\t\t hw_rev->letter, hw_rev->major, hw_rev->minor);\n\t\tret = devlink_info_version_fixed_put(req,\n\t\t\t\t\t\t     DEVLINK_INFO_VERSION_GENERIC_BOARD_REV,\n\t\t\t\t\t\t     buf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn devlink_info_serial_number_put(req, es58x_dev->udev->serial);\n}\n\nconst struct devlink_ops es58x_dl_ops = {\n\t.info_get = es58x_devlink_info_get,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}