{
  "module_name": "es58x_core.h",
  "hash_id": "962ae4b4853e29c5b05d17963149adbb4e4fa794c6aa09eb9dd1eb0dfc360a18",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/usb/etas_es58x/es58x_core.h",
  "human_readable_source": " \n\n \n\n#ifndef __ES58X_COMMON_H__\n#define __ES58X_COMMON_H__\n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/netdevice.h>\n#include <linux/types.h>\n#include <linux/usb.h>\n#include <net/devlink.h>\n\n#include \"es581_4.h\"\n#include \"es58x_fd.h\"\n\n \n#define ES58X_RX_URBS_MAX 5\t \n#define ES58X_TX_URBS_MAX 6\t \n\n#define ES58X_MAX(param)\t\t\t\t\\\n\t(ES581_4_##param > ES58X_FD_##param ?\t\t\\\n\t\tES581_4_##param : ES58X_FD_##param)\n#define ES58X_TX_BULK_MAX ES58X_MAX(TX_BULK_MAX)\n#define ES58X_RX_BULK_MAX ES58X_MAX(RX_BULK_MAX)\n#define ES58X_ECHO_BULK_MAX ES58X_MAX(ECHO_BULK_MAX)\n#define ES58X_NUM_CAN_CH_MAX ES58X_MAX(NUM_CAN_CH)\n\n \n#define ES58X_CHANNEL_IDX_NA 0xFF\n#define ES58X_EMPTY_MSG NULL\n\n \n#define ES58X_CONSECUTIVE_ERR_PASSIVE_MAX 254\n\n \n#define ES58X_HEARTBEAT 0x11\n\n \nenum es58x_driver_info {\n\tES58X_DUAL_CHANNEL = BIT(0),\n\tES58X_FD_FAMILY = BIT(1)\n};\n\nenum es58x_echo {\n\tES58X_ECHO_OFF = 0,\n\tES58X_ECHO_ON = 1\n};\n\n \nenum es58x_physical_layer {\n\tES58X_PHYSICAL_LAYER_HIGH_SPEED = 1\n};\n\nenum es58x_samples_per_bit {\n\tES58X_SAMPLES_PER_BIT_ONE = 1,\n\tES58X_SAMPLES_PER_BIT_THREE = 2\n};\n\n \nenum es58x_sync_edge {\n\tES58X_SYNC_EDGE_SINGLE = 1\n};\n\n \nenum es58x_flag {\n\tES58X_FLAG_EFF = BIT(0),\n\tES58X_FLAG_RTR = BIT(1),\n\tES58X_FLAG_FD_BRS = BIT(3),\n\tES58X_FLAG_FD_ESI = BIT(5),\n\tES58X_FLAG_FD_DATA = BIT(6)\n};\n\n \nenum es58x_err {\n\tES58X_ERR_OK = 0,\n\tES58X_ERR_PROT_STUFF = BIT(0),\n\tES58X_ERR_PROT_FORM = BIT(1),\n\tES58X_ERR_ACK = BIT(2),\n\tES58X_ERR_PROT_BIT = BIT(3),\n\tES58X_ERR_PROT_CRC = BIT(4),\n\tES58X_ERR_PROT_BIT1 = BIT(5),\n\tES58X_ERR_PROT_BIT0 = BIT(6),\n\tES58X_ERR_PROT_OVERLOAD = BIT(7),\n\tES58X_ERR_PROT_UNSPEC = BIT(31)\n};\n\n \nenum es58x_event {\n\tES58X_EVENT_OK = 0,\n\tES58X_EVENT_CRTL_ACTIVE = BIT(0),\n\tES58X_EVENT_CRTL_PASSIVE = BIT(1),\n\tES58X_EVENT_CRTL_WARNING = BIT(2),\n\tES58X_EVENT_BUSOFF = BIT(3),\n\tES58X_EVENT_SINGLE_WIRE = BIT(4)\n};\n\n \nenum es58x_ret_u8 {\n\tES58X_RET_U8_OK = 0x00,\n\tES58X_RET_U8_ERR_UNSPECIFIED_FAILURE = 0x80,\n\tES58X_RET_U8_ERR_NO_MEM = 0x81,\n\tES58X_RET_U8_ERR_BAD_CRC = 0x99\n};\n\n \nenum es58x_ret_u32 {\n\tES58X_RET_U32_OK = 0x00000000UL,\n\tES58X_RET_U32_ERR_UNSPECIFIED_FAILURE = 0x80000000UL,\n\tES58X_RET_U32_ERR_NO_MEM = 0x80004001UL,\n\tES58X_RET_U32_WARN_PARAM_ADJUSTED = 0x40004000UL,\n\tES58X_RET_U32_WARN_TX_MAYBE_REORDER = 0x40004001UL,\n\tES58X_RET_U32_ERR_TIMEDOUT = 0x80000008UL,\n\tES58X_RET_U32_ERR_FIFO_FULL = 0x80003002UL,\n\tES58X_RET_U32_ERR_BAD_CONFIG = 0x80004000UL,\n\tES58X_RET_U32_ERR_NO_RESOURCE = 0x80004002UL\n};\n\n \nenum es58x_ret_type {\n\tES58X_RET_TYPE_SET_BITTIMING,\n\tES58X_RET_TYPE_ENABLE_CHANNEL,\n\tES58X_RET_TYPE_DISABLE_CHANNEL,\n\tES58X_RET_TYPE_TX_MSG,\n\tES58X_RET_TYPE_RESET_RX,\n\tES58X_RET_TYPE_RESET_TX,\n\tES58X_RET_TYPE_DEVICE_ERR\n};\n\nunion es58x_urb_cmd {\n\tstruct es581_4_urb_cmd es581_4_urb_cmd;\n\tstruct es58x_fd_urb_cmd es58x_fd_urb_cmd;\n\tstruct {\t\t \n\t\t__le16 sof;\n\t\tu8 cmd_type;\n\t\tu8 cmd_id;\n\t} __packed;\n\tDECLARE_FLEX_ARRAY(u8, raw_cmd);\n};\n\n \nstruct es58x_priv {\n\tstruct can_priv can;\n\tstruct devlink_port devlink_port;\n\tstruct es58x_device *es58x_dev;\n\tstruct urb *tx_urb;\n\n\tu32 tx_tail;\n\tu32 tx_head;\n\n\tu8 tx_can_msg_cnt;\n\tbool tx_can_msg_is_fd;\n\n\tu8 err_passive_before_rtx_success;\n\n\tu8 channel_idx;\n};\n\n \nstruct es58x_parameters {\n\tconst struct can_bittiming_const *bittiming_const;\n\tconst struct can_bittiming_const *data_bittiming_const;\n\tconst struct can_tdc_const *tdc_const;\n\tu32 bitrate_max;\n\tstruct can_clock clock;\n\tu32 ctrlmode_supported;\n\tu16 tx_start_of_frame;\n\tu16 rx_start_of_frame;\n\tu16 tx_urb_cmd_max_len;\n\tu16 rx_urb_cmd_max_len;\n\tu16 fifo_mask;\n\tu16 dql_min_limit;\n\tu8 tx_bulk_max;\n\tu8 urb_cmd_header_len;\n\tu8 rx_urb_max;\n\tu8 tx_urb_max;\n};\n\n \nstruct es58x_operators {\n\tu16 (*get_msg_len)(const union es58x_urb_cmd *urb_cmd);\n\tint (*handle_urb_cmd)(struct es58x_device *es58x_dev,\n\t\t\t      const union es58x_urb_cmd *urb_cmd);\n\tvoid (*fill_urb_header)(union es58x_urb_cmd *urb_cmd, u8 cmd_type,\n\t\t\t\tu8 cmd_id, u8 channel_idx, u16 cmd_len);\n\tint (*tx_can_msg)(struct es58x_priv *priv, const struct sk_buff *skb);\n\tint (*enable_channel)(struct es58x_priv *priv);\n\tint (*disable_channel)(struct es58x_priv *priv);\n\tint (*reset_device)(struct es58x_device *es58x_dev);\n\tint (*get_timestamp)(struct es58x_device *es58x_dev);\n};\n\n \nstruct es58x_sw_version {\n\tu8 major;\n\tu8 minor;\n\tu8 revision;\n};\n\n \nstruct es58x_hw_revision {\n\tchar letter;\n\tu16 major;\n\tu16 minor;\n};\n\n \nstruct es58x_device {\n\tstruct device *dev;\n\tstruct usb_device *udev;\n\tstruct net_device *netdev[ES58X_NUM_CAN_CH_MAX];\n\n\tconst struct es58x_parameters *param;\n\tconst struct es58x_operators *ops;\n\n\tunsigned int rx_pipe;\n\tunsigned int tx_pipe;\n\n\tstruct usb_anchor rx_urbs;\n\tstruct usb_anchor tx_urbs_busy;\n\tstruct usb_anchor tx_urbs_idle;\n\tatomic_t tx_urbs_idle_cnt;\n\n\tstruct es58x_sw_version firmware_version;\n\tstruct es58x_sw_version bootloader_version;\n\tstruct es58x_hw_revision hardware_revision;\n\n\tu64 ktime_req_ns;\n\ts64 realtime_diff_ns;\n\n\tu64 timestamps[ES58X_ECHO_BULK_MAX];\n\n\tu8 num_can_ch;\n\tu8 opened_channel_cnt;\n\n\tu16 rx_cmd_buf_len;\n\tunion es58x_urb_cmd rx_cmd_buf;\n};\n\n \nstatic inline size_t es58x_sizeof_es58x_device(const struct es58x_parameters\n\t\t\t\t\t       *es58x_dev_param)\n{\n\treturn offsetof(struct es58x_device, rx_cmd_buf) +\n\t\tes58x_dev_param->rx_urb_cmd_max_len;\n}\n\nstatic inline int __es58x_check_msg_len(const struct device *dev,\n\t\t\t\t\tconst char *stringified_msg,\n\t\t\t\t\tsize_t actual_len, size_t expected_len)\n{\n\tif (expected_len != actual_len) {\n\t\tdev_err(dev,\n\t\t\t\"Length of %s is %zu but received command is %zu.\\n\",\n\t\t\tstringified_msg, expected_len, actual_len);\n\t\treturn -EMSGSIZE;\n\t}\n\treturn 0;\n}\n\n \n#define es58x_check_msg_len(dev, msg, actual_len)\t\t\t\\\n\t__es58x_check_msg_len(dev, __stringify(msg),\t\t\t\\\n\t\t\t      actual_len, sizeof(msg))\n\nstatic inline int __es58x_check_msg_max_len(const struct device *dev,\n\t\t\t\t\t    const char *stringified_msg,\n\t\t\t\t\t    size_t actual_len,\n\t\t\t\t\t    size_t expected_len)\n{\n\tif (actual_len > expected_len) {\n\t\tdev_err(dev,\n\t\t\t\"Maximum length for %s is %zu but received command is %zu.\\n\",\n\t\t\tstringified_msg, expected_len, actual_len);\n\t\treturn -EOVERFLOW;\n\t}\n\treturn 0;\n}\n\n \n#define es58x_check_msg_max_len(dev, msg, actual_len)\t\t\t\\\n\t__es58x_check_msg_max_len(dev, __stringify(msg),\t\t\\\n\t\t\t\t  actual_len, sizeof(msg))\n\nstatic inline int __es58x_msg_num_element(const struct device *dev,\n\t\t\t\t\t  const char *stringified_msg,\n\t\t\t\t\t  size_t actual_len, size_t msg_len,\n\t\t\t\t\t  size_t elem_len)\n{\n\tsize_t actual_num_elem = actual_len / elem_len;\n\tsize_t expected_num_elem = msg_len / elem_len;\n\n\tif (actual_num_elem == 0) {\n\t\tdev_err(dev,\n\t\t\t\"Minimum length for %s is %zu but received command is %zu.\\n\",\n\t\t\tstringified_msg, elem_len, actual_len);\n\t\treturn -EMSGSIZE;\n\t} else if ((actual_len % elem_len) != 0) {\n\t\tdev_err(dev,\n\t\t\t\"Received command length: %zu is not a multiple of %s[0]: %zu\\n\",\n\t\t\tactual_len, stringified_msg, elem_len);\n\t\treturn -EMSGSIZE;\n\t} else if (actual_num_elem > expected_num_elem) {\n\t\tdev_err(dev,\n\t\t\t\"Array %s is supposed to have %zu elements each of size %zu...\\n\",\n\t\t\tstringified_msg, expected_num_elem, elem_len);\n\t\tdev_err(dev,\n\t\t\t\"... But received command has %zu elements (total length %zu).\\n\",\n\t\t\tactual_num_elem, actual_len);\n\t\treturn -EOVERFLOW;\n\t}\n\treturn actual_num_elem;\n}\n\n \n#define es58x_msg_num_element(dev, msg, actual_len)\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tsize_t __elem_len = sizeof((msg)[0]) + __must_be_array(msg);\t\\\n\t__es58x_msg_num_element(dev, __stringify(msg), actual_len,\t\\\n\t\t\t\tsizeof(msg), __elem_len);\t\t\\\n})\n\n \nstatic inline struct es58x_priv *es58x_priv(struct net_device *netdev)\n{\n\treturn (struct es58x_priv *)netdev_priv(netdev);\n}\n\n \n#define ES58X_SIZEOF_URB_CMD(es58x_urb_cmd_type, msg_field)\t\t\\\n\t(offsetof(es58x_urb_cmd_type, raw_msg)\t\t\t\t\\\n\t\t+ sizeof_field(es58x_urb_cmd_type, msg_field)\t\t\\\n\t\t+ sizeof_field(es58x_urb_cmd_type,\t\t\t\\\n\t\t\t       reserved_for_crc16_do_not_use))\n\n \nstatic inline size_t es58x_get_urb_cmd_len(struct es58x_device *es58x_dev,\n\t\t\t\t\t   u16 msg_len)\n{\n\treturn es58x_dev->param->urb_cmd_header_len + msg_len + sizeof(u16);\n}\n\n \nstatic inline int es58x_get_netdev(struct es58x_device *es58x_dev,\n\t\t\t\t   int channel_no, int channel_idx_offset,\n\t\t\t\t   struct net_device **netdev)\n{\n\tint channel_idx = channel_no - channel_idx_offset;\n\n\t*netdev = NULL;\n\tif (channel_idx < 0 || channel_idx >= es58x_dev->num_can_ch)\n\t\treturn -ECHRNG;\n\n\t*netdev = es58x_dev->netdev[channel_idx];\n\tif (!*netdev || !netif_device_present(*netdev))\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\n \nstatic inline int es58x_get_raw_can_id(const struct can_frame *cf)\n{\n\tif (cf->can_id & CAN_EFF_FLAG)\n\t\treturn cf->can_id & CAN_EFF_MASK;\n\telse\n\t\treturn cf->can_id & CAN_SFF_MASK;\n}\n\n \nstatic inline enum es58x_flag es58x_get_flags(const struct sk_buff *skb)\n{\n\tstruct canfd_frame *cf = (struct canfd_frame *)skb->data;\n\tenum es58x_flag es58x_flags = 0;\n\n\tif (cf->can_id & CAN_EFF_FLAG)\n\t\tes58x_flags |= ES58X_FLAG_EFF;\n\n\tif (can_is_canfd_skb(skb)) {\n\t\tes58x_flags |= ES58X_FLAG_FD_DATA;\n\t\tif (cf->flags & CANFD_BRS)\n\t\t\tes58x_flags |= ES58X_FLAG_FD_BRS;\n\t\tif (cf->flags & CANFD_ESI)\n\t\t\tes58x_flags |= ES58X_FLAG_FD_ESI;\n\t} else if (cf->can_id & CAN_RTR_FLAG)\n\t\t \n\t\tes58x_flags |= ES58X_FLAG_RTR;\n\n\treturn es58x_flags;\n}\n\n \nint es58x_can_get_echo_skb(struct net_device *netdev, u32 packet_idx,\n\t\t\t   u64 *tstamps, unsigned int pkts);\nint es58x_tx_ack_msg(struct net_device *netdev, u16 tx_free_entries,\n\t\t     enum es58x_ret_u32 rx_cmd_ret_u32);\nint es58x_rx_can_msg(struct net_device *netdev, u64 timestamp, const u8 *data,\n\t\t     canid_t can_id, enum es58x_flag es58x_flags, u8 dlc);\nint es58x_rx_err_msg(struct net_device *netdev, enum es58x_err error,\n\t\t     enum es58x_event event, u64 timestamp);\nvoid es58x_rx_timestamp(struct es58x_device *es58x_dev, u64 timestamp);\nint es58x_rx_cmd_ret_u8(struct device *dev, enum es58x_ret_type cmd_ret_type,\n\t\t\tenum es58x_ret_u8 rx_cmd_ret_u8);\nint es58x_rx_cmd_ret_u32(struct net_device *netdev,\n\t\t\t enum es58x_ret_type cmd_ret_type,\n\t\t\t enum es58x_ret_u32 rx_cmd_ret_u32);\nint es58x_send_msg(struct es58x_device *es58x_dev, u8 cmd_type, u8 cmd_id,\n\t\t   const void *msg, u16 cmd_len, int channel_idx);\n\n \nvoid es58x_parse_product_info(struct es58x_device *es58x_dev);\nextern const struct devlink_ops es58x_dl_ops;\n\n \nextern const struct es58x_parameters es581_4_param;\nextern const struct es58x_operators es581_4_ops;\n\n \nextern const struct es58x_parameters es58x_fd_param;\nextern const struct es58x_operators es58x_fd_ops;\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}