{
  "module_name": "es581_4.c",
  "hash_id": "bdf1a84b7eea72908d5b8548f20173198aac51a8461e185186c7a32c87374c48",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/usb/etas_es58x/es581_4.c",
  "human_readable_source": "\n\n \n\n#include <asm/unaligned.h>\n#include <linux/kernel.h>\n#include <linux/units.h>\n\n#include \"es58x_core.h\"\n#include \"es581_4.h\"\n\n \n#define es581_4_sizeof_rx_tx_msg(msg)\t\t\t\t\\\n\toffsetof(typeof(msg), data[can_cc_dlc2len((msg).dlc)])\n\nstatic u16 es581_4_get_msg_len(const union es58x_urb_cmd *urb_cmd)\n{\n\treturn get_unaligned_le16(&urb_cmd->es581_4_urb_cmd.msg_len);\n}\n\nstatic int es581_4_echo_msg(struct es58x_device *es58x_dev,\n\t\t\t    const struct es581_4_urb_cmd *es581_4_urb_cmd)\n{\n\tstruct net_device *netdev;\n\tconst struct es581_4_bulk_echo_msg *bulk_echo_msg;\n\tconst struct es581_4_echo_msg *echo_msg;\n\tu64 *tstamps = es58x_dev->timestamps;\n\tu16 msg_len;\n\tu32 first_packet_idx, packet_idx;\n\tunsigned int dropped = 0;\n\tint i, num_element, ret;\n\n\tbulk_echo_msg = &es581_4_urb_cmd->bulk_echo_msg;\n\tmsg_len = get_unaligned_le16(&es581_4_urb_cmd->msg_len) -\n\t    sizeof(bulk_echo_msg->channel_no);\n\tnum_element = es58x_msg_num_element(es58x_dev->dev,\n\t\t\t\t\t    bulk_echo_msg->echo_msg, msg_len);\n\tif (num_element <= 0)\n\t\treturn num_element;\n\n\tret = es58x_get_netdev(es58x_dev, bulk_echo_msg->channel_no,\n\t\t\t       ES581_4_CHANNEL_IDX_OFFSET, &netdev);\n\tif (ret)\n\t\treturn ret;\n\n\techo_msg = &bulk_echo_msg->echo_msg[0];\n\tfirst_packet_idx = get_unaligned_le32(&echo_msg->packet_idx);\n\tpacket_idx = first_packet_idx;\n\tfor (i = 0; i < num_element; i++) {\n\t\tu32 tmp_idx;\n\n\t\techo_msg = &bulk_echo_msg->echo_msg[i];\n\t\ttmp_idx = get_unaligned_le32(&echo_msg->packet_idx);\n\t\tif (tmp_idx == packet_idx - 1) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tnetdev_warn(netdev,\n\t\t\t\t\t    \"Received echo packet idx %u twice\\n\",\n\t\t\t\t\t    packet_idx - 1);\n\t\t\tdropped++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (tmp_idx != packet_idx) {\n\t\t\tnetdev_err(netdev, \"Echo packet idx jumped from %u to %u\\n\",\n\t\t\t\t   packet_idx - 1, echo_msg->packet_idx);\n\t\t\treturn -EBADMSG;\n\t\t}\n\n\t\ttstamps[i] = get_unaligned_le64(&echo_msg->timestamp);\n\t\tpacket_idx++;\n\t}\n\n\tnetdev->stats.tx_dropped += dropped;\n\treturn es58x_can_get_echo_skb(netdev, first_packet_idx,\n\t\t\t\t      tstamps, num_element - dropped);\n}\n\nstatic int es581_4_rx_can_msg(struct es58x_device *es58x_dev,\n\t\t\t      const struct es581_4_urb_cmd *es581_4_urb_cmd,\n\t\t\t      u16 msg_len)\n{\n\tconst struct device *dev = es58x_dev->dev;\n\tstruct net_device *netdev;\n\tint pkts, num_element, channel_no, ret;\n\n\tnum_element = es58x_msg_num_element(dev, es581_4_urb_cmd->rx_can_msg,\n\t\t\t\t\t    msg_len);\n\tif (num_element <= 0)\n\t\treturn num_element;\n\n\tchannel_no = es581_4_urb_cmd->rx_can_msg[0].channel_no;\n\tret = es58x_get_netdev(es58x_dev, channel_no,\n\t\t\t       ES581_4_CHANNEL_IDX_OFFSET, &netdev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!netif_running(netdev)) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_info(netdev,\n\t\t\t\t    \"%s: %s is down, dropping %d rx packets\\n\",\n\t\t\t\t    __func__, netdev->name, num_element);\n\t\tnetdev->stats.rx_dropped += num_element;\n\t\treturn 0;\n\t}\n\n\tfor (pkts = 0; pkts < num_element; pkts++) {\n\t\tconst struct es581_4_rx_can_msg *rx_can_msg =\n\t\t    &es581_4_urb_cmd->rx_can_msg[pkts];\n\t\tu64 tstamp = get_unaligned_le64(&rx_can_msg->timestamp);\n\t\tcanid_t can_id = get_unaligned_le32(&rx_can_msg->can_id);\n\n\t\tif (channel_no != rx_can_msg->channel_no)\n\t\t\treturn -EBADMSG;\n\n\t\tret = es58x_rx_can_msg(netdev, tstamp, rx_can_msg->data,\n\t\t\t\t       can_id, rx_can_msg->flags,\n\t\t\t\t       rx_can_msg->dlc);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int es581_4_rx_err_msg(struct es58x_device *es58x_dev,\n\t\t\t      const struct es581_4_rx_err_msg *rx_err_msg)\n{\n\tstruct net_device *netdev;\n\tenum es58x_err error = get_unaligned_le32(&rx_err_msg->error);\n\tint ret;\n\n\tret = es58x_get_netdev(es58x_dev, rx_err_msg->channel_no,\n\t\t\t       ES581_4_CHANNEL_IDX_OFFSET, &netdev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn es58x_rx_err_msg(netdev, error, 0,\n\t\t\t\tget_unaligned_le64(&rx_err_msg->timestamp));\n}\n\nstatic int es581_4_rx_event_msg(struct es58x_device *es58x_dev,\n\t\t\t\tconst struct es581_4_rx_event_msg *rx_event_msg)\n{\n\tstruct net_device *netdev;\n\tenum es58x_event event = get_unaligned_le32(&rx_event_msg->event);\n\tint ret;\n\n\tret = es58x_get_netdev(es58x_dev, rx_event_msg->channel_no,\n\t\t\t       ES581_4_CHANNEL_IDX_OFFSET, &netdev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn es58x_rx_err_msg(netdev, 0, event,\n\t\t\t\tget_unaligned_le64(&rx_event_msg->timestamp));\n}\n\nstatic int es581_4_rx_cmd_ret_u32(struct es58x_device *es58x_dev,\n\t\t\t\t  const struct es581_4_urb_cmd *es581_4_urb_cmd,\n\t\t\t\t  enum es58x_ret_type ret_type)\n{\n\tstruct net_device *netdev;\n\tconst struct es581_4_rx_cmd_ret *rx_cmd_ret;\n\tu16 msg_len = get_unaligned_le16(&es581_4_urb_cmd->msg_len);\n\tint ret;\n\n\tret = es58x_check_msg_len(es58x_dev->dev,\n\t\t\t\t  es581_4_urb_cmd->rx_cmd_ret, msg_len);\n\tif (ret)\n\t\treturn ret;\n\n\trx_cmd_ret = &es581_4_urb_cmd->rx_cmd_ret;\n\n\tret = es58x_get_netdev(es58x_dev, rx_cmd_ret->channel_no,\n\t\t\t       ES581_4_CHANNEL_IDX_OFFSET, &netdev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn es58x_rx_cmd_ret_u32(netdev, ret_type,\n\t\t\t\t    get_unaligned_le32(&rx_cmd_ret->rx_cmd_ret_le32));\n}\n\nstatic int es581_4_tx_ack_msg(struct es58x_device *es58x_dev,\n\t\t\t      const struct es581_4_urb_cmd *es581_4_urb_cmd)\n{\n\tstruct net_device *netdev;\n\tconst struct es581_4_tx_ack_msg *tx_ack_msg;\n\tu16 msg_len = get_unaligned_le16(&es581_4_urb_cmd->msg_len);\n\tint ret;\n\n\ttx_ack_msg = &es581_4_urb_cmd->tx_ack_msg;\n\tret = es58x_check_msg_len(es58x_dev->dev, *tx_ack_msg, msg_len);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tx_ack_msg->rx_cmd_ret_u8 != ES58X_RET_U8_OK)\n\t\treturn es58x_rx_cmd_ret_u8(es58x_dev->dev,\n\t\t\t\t\t   ES58X_RET_TYPE_TX_MSG,\n\t\t\t\t\t   tx_ack_msg->rx_cmd_ret_u8);\n\n\tret = es58x_get_netdev(es58x_dev, tx_ack_msg->channel_no,\n\t\t\t       ES581_4_CHANNEL_IDX_OFFSET, &netdev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn es58x_tx_ack_msg(netdev,\n\t\t\t\tget_unaligned_le16(&tx_ack_msg->tx_free_entries),\n\t\t\t\tES58X_RET_U32_OK);\n}\n\nstatic int es581_4_dispatch_rx_cmd(struct es58x_device *es58x_dev,\n\t\t\t\t   const struct es581_4_urb_cmd *es581_4_urb_cmd)\n{\n\tconst struct device *dev = es58x_dev->dev;\n\tu16 msg_len = get_unaligned_le16(&es581_4_urb_cmd->msg_len);\n\tenum es581_4_rx_type rx_type = es581_4_urb_cmd->rx_can_msg[0].rx_type;\n\tint ret = 0;\n\n\tswitch (rx_type) {\n\tcase ES581_4_RX_TYPE_MESSAGE:\n\t\treturn es581_4_rx_can_msg(es58x_dev, es581_4_urb_cmd, msg_len);\n\n\tcase ES581_4_RX_TYPE_ERROR:\n\t\tret = es58x_check_msg_len(dev, es581_4_urb_cmd->rx_err_msg,\n\t\t\t\t\t  msg_len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn es581_4_rx_err_msg(es58x_dev,\n\t\t\t\t\t  &es581_4_urb_cmd->rx_err_msg);\n\n\tcase ES581_4_RX_TYPE_EVENT:\n\t\tret = es58x_check_msg_len(dev, es581_4_urb_cmd->rx_event_msg,\n\t\t\t\t\t  msg_len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn es581_4_rx_event_msg(es58x_dev,\n\t\t\t\t\t    &es581_4_urb_cmd->rx_event_msg);\n\n\tdefault:\n\t\tdev_err(dev, \"%s: Unknown rx_type 0x%02X\\n\", __func__, rx_type);\n\t\treturn -EBADRQC;\n\t}\n}\n\nstatic int es581_4_handle_urb_cmd(struct es58x_device *es58x_dev,\n\t\t\t\t  const union es58x_urb_cmd *urb_cmd)\n{\n\tconst struct es581_4_urb_cmd *es581_4_urb_cmd;\n\tstruct device *dev = es58x_dev->dev;\n\tu16 msg_len = es581_4_get_msg_len(urb_cmd);\n\tint ret;\n\n\tes581_4_urb_cmd = &urb_cmd->es581_4_urb_cmd;\n\n\tif (es581_4_urb_cmd->cmd_type != ES581_4_CAN_COMMAND_TYPE) {\n\t\tdev_err(dev, \"%s: Unknown command type (0x%02X)\\n\",\n\t\t\t__func__, es581_4_urb_cmd->cmd_type);\n\t\treturn -EBADRQC;\n\t}\n\n\tswitch ((enum es581_4_cmd_id)es581_4_urb_cmd->cmd_id) {\n\tcase ES581_4_CMD_ID_SET_BITTIMING:\n\t\treturn es581_4_rx_cmd_ret_u32(es58x_dev, es581_4_urb_cmd,\n\t\t\t\t\t      ES58X_RET_TYPE_SET_BITTIMING);\n\n\tcase ES581_4_CMD_ID_ENABLE_CHANNEL:\n\t\treturn es581_4_rx_cmd_ret_u32(es58x_dev, es581_4_urb_cmd,\n\t\t\t\t\t      ES58X_RET_TYPE_ENABLE_CHANNEL);\n\n\tcase ES581_4_CMD_ID_TX_MSG:\n\t\treturn es581_4_tx_ack_msg(es58x_dev, es581_4_urb_cmd);\n\n\tcase ES581_4_CMD_ID_RX_MSG:\n\t\treturn es581_4_dispatch_rx_cmd(es58x_dev, es581_4_urb_cmd);\n\n\tcase ES581_4_CMD_ID_RESET_RX:\n\t\tret = es581_4_rx_cmd_ret_u32(es58x_dev, es581_4_urb_cmd,\n\t\t\t\t\t     ES58X_RET_TYPE_RESET_RX);\n\t\treturn ret;\n\n\tcase ES581_4_CMD_ID_RESET_TX:\n\t\tret = es581_4_rx_cmd_ret_u32(es58x_dev, es581_4_urb_cmd,\n\t\t\t\t\t     ES58X_RET_TYPE_RESET_TX);\n\t\treturn ret;\n\n\tcase ES581_4_CMD_ID_DISABLE_CHANNEL:\n\t\treturn es581_4_rx_cmd_ret_u32(es58x_dev, es581_4_urb_cmd,\n\t\t\t\t\t      ES58X_RET_TYPE_DISABLE_CHANNEL);\n\n\tcase ES581_4_CMD_ID_TIMESTAMP:\n\t\tret = es58x_check_msg_len(dev, es581_4_urb_cmd->timestamp,\n\t\t\t\t\t  msg_len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tes58x_rx_timestamp(es58x_dev,\n\t\t\t\t   get_unaligned_le64(&es581_4_urb_cmd->timestamp));\n\t\treturn 0;\n\n\tcase ES581_4_CMD_ID_ECHO:\n\t\treturn es581_4_echo_msg(es58x_dev, es581_4_urb_cmd);\n\n\tcase ES581_4_CMD_ID_DEVICE_ERR:\n\t\tret = es58x_check_msg_len(dev, es581_4_urb_cmd->rx_cmd_ret_u8,\n\t\t\t\t\t  msg_len);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\treturn es58x_rx_cmd_ret_u8(dev, ES58X_RET_TYPE_DEVICE_ERR,\n\t\t\t\t\t   es581_4_urb_cmd->rx_cmd_ret_u8);\n\n\tdefault:\n\t\tdev_warn(dev, \"%s: Unexpected command ID: 0x%02X\\n\",\n\t\t\t __func__, es581_4_urb_cmd->cmd_id);\n\t\treturn -EBADRQC;\n\t}\n}\n\nstatic void es581_4_fill_urb_header(union es58x_urb_cmd *urb_cmd, u8 cmd_type,\n\t\t\t\t    u8 cmd_id, u8 channel_idx, u16 msg_len)\n{\n\tstruct es581_4_urb_cmd *es581_4_urb_cmd = &urb_cmd->es581_4_urb_cmd;\n\n\tes581_4_urb_cmd->SOF = cpu_to_le16(es581_4_param.tx_start_of_frame);\n\tes581_4_urb_cmd->cmd_type = cmd_type;\n\tes581_4_urb_cmd->cmd_id = cmd_id;\n\tes581_4_urb_cmd->msg_len = cpu_to_le16(msg_len);\n}\n\nstatic int es581_4_tx_can_msg(struct es58x_priv *priv,\n\t\t\t      const struct sk_buff *skb)\n{\n\tstruct es58x_device *es58x_dev = priv->es58x_dev;\n\tunion es58x_urb_cmd *urb_cmd = priv->tx_urb->transfer_buffer;\n\tstruct es581_4_urb_cmd *es581_4_urb_cmd = &urb_cmd->es581_4_urb_cmd;\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct es581_4_tx_can_msg *tx_can_msg;\n\tu16 msg_len;\n\tint ret;\n\n\tif (can_is_canfd_skb(skb))\n\t\treturn -EMSGSIZE;\n\n\tif (priv->tx_can_msg_cnt == 0) {\n\t\tmsg_len = sizeof(es581_4_urb_cmd->bulk_tx_can_msg.num_can_msg);\n\t\tes581_4_fill_urb_header(urb_cmd, ES581_4_CAN_COMMAND_TYPE,\n\t\t\t\t\tES581_4_CMD_ID_TX_MSG,\n\t\t\t\t\tpriv->channel_idx, msg_len);\n\t\tes581_4_urb_cmd->bulk_tx_can_msg.num_can_msg = 0;\n\t} else {\n\t\tmsg_len = es581_4_get_msg_len(urb_cmd);\n\t}\n\n\tret = es58x_check_msg_max_len(es58x_dev->dev,\n\t\t\t\t      es581_4_urb_cmd->bulk_tx_can_msg,\n\t\t\t\t      msg_len + sizeof(*tx_can_msg));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttx_can_msg = (typeof(tx_can_msg))&es581_4_urb_cmd->raw_msg[msg_len];\n\tput_unaligned_le32(es58x_get_raw_can_id(cf), &tx_can_msg->can_id);\n\tput_unaligned_le32(priv->tx_head, &tx_can_msg->packet_idx);\n\tput_unaligned_le16((u16)es58x_get_flags(skb), &tx_can_msg->flags);\n\ttx_can_msg->channel_no = priv->channel_idx + ES581_4_CHANNEL_IDX_OFFSET;\n\ttx_can_msg->dlc = can_get_cc_dlc(cf, priv->can.ctrlmode);\n\n\tmemcpy(tx_can_msg->data, cf->data, cf->len);\n\n\t \n\tes581_4_urb_cmd->bulk_tx_can_msg.num_can_msg++;\n\tmsg_len += es581_4_sizeof_rx_tx_msg(*tx_can_msg);\n\tpriv->tx_urb->transfer_buffer_length = es58x_get_urb_cmd_len(es58x_dev,\n\t\t\t\t\t\t\t\t     msg_len);\n\tes581_4_urb_cmd->msg_len = cpu_to_le16(msg_len);\n\n\treturn 0;\n}\n\nstatic int es581_4_set_bittiming(struct es58x_priv *priv)\n{\n\tstruct es581_4_tx_conf_msg tx_conf_msg = { 0 };\n\tstruct can_bittiming *bt = &priv->can.bittiming;\n\n\ttx_conf_msg.bitrate = cpu_to_le32(bt->bitrate);\n\t \n\ttx_conf_msg.sample_point = cpu_to_le32(bt->sample_point / 10U);\n\ttx_conf_msg.samples_per_bit = cpu_to_le32(ES58X_SAMPLES_PER_BIT_ONE);\n\ttx_conf_msg.bit_time = cpu_to_le32(can_bit_time(bt));\n\ttx_conf_msg.sjw = cpu_to_le32(bt->sjw);\n\ttx_conf_msg.sync_edge = cpu_to_le32(ES58X_SYNC_EDGE_SINGLE);\n\ttx_conf_msg.physical_layer =\n\t    cpu_to_le32(ES58X_PHYSICAL_LAYER_HIGH_SPEED);\n\ttx_conf_msg.echo_mode = cpu_to_le32(ES58X_ECHO_ON);\n\ttx_conf_msg.channel_no = priv->channel_idx + ES581_4_CHANNEL_IDX_OFFSET;\n\n\treturn es58x_send_msg(priv->es58x_dev, ES581_4_CAN_COMMAND_TYPE,\n\t\t\t      ES581_4_CMD_ID_SET_BITTIMING, &tx_conf_msg,\n\t\t\t      sizeof(tx_conf_msg), priv->channel_idx);\n}\n\nstatic int es581_4_enable_channel(struct es58x_priv *priv)\n{\n\tint ret;\n\tu8 msg = priv->channel_idx + ES581_4_CHANNEL_IDX_OFFSET;\n\n\tret = es581_4_set_bittiming(priv);\n\tif (ret)\n\t\treturn ret;\n\n\treturn es58x_send_msg(priv->es58x_dev, ES581_4_CAN_COMMAND_TYPE,\n\t\t\t      ES581_4_CMD_ID_ENABLE_CHANNEL, &msg, sizeof(msg),\n\t\t\t      priv->channel_idx);\n}\n\nstatic int es581_4_disable_channel(struct es58x_priv *priv)\n{\n\tu8 msg = priv->channel_idx + ES581_4_CHANNEL_IDX_OFFSET;\n\n\treturn es58x_send_msg(priv->es58x_dev, ES581_4_CAN_COMMAND_TYPE,\n\t\t\t      ES581_4_CMD_ID_DISABLE_CHANNEL, &msg, sizeof(msg),\n\t\t\t      priv->channel_idx);\n}\n\nstatic int es581_4_reset_device(struct es58x_device *es58x_dev)\n{\n\treturn es58x_send_msg(es58x_dev, ES581_4_CAN_COMMAND_TYPE,\n\t\t\t      ES581_4_CMD_ID_RESET_DEVICE,\n\t\t\t      ES58X_EMPTY_MSG, 0, ES58X_CHANNEL_IDX_NA);\n}\n\nstatic int es581_4_get_timestamp(struct es58x_device *es58x_dev)\n{\n\treturn es58x_send_msg(es58x_dev, ES581_4_CAN_COMMAND_TYPE,\n\t\t\t      ES581_4_CMD_ID_TIMESTAMP,\n\t\t\t      ES58X_EMPTY_MSG, 0, ES58X_CHANNEL_IDX_NA);\n}\n\n \nstatic const struct can_bittiming_const es581_4_bittiming_const = {\n\t.name = \"ES581.4\",\n\t.tseg1_min = 1,\n\t.tseg1_max = 8,\n\t.tseg2_min = 1,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 128,\n\t.brp_inc = 1\n};\n\nconst struct es58x_parameters es581_4_param = {\n\t.bittiming_const = &es581_4_bittiming_const,\n\t.data_bittiming_const = NULL,\n\t.tdc_const = NULL,\n\t.bitrate_max = 1 * MEGA  ,\n\t.clock = {.freq = 50 * MEGA  },\n\t.ctrlmode_supported = CAN_CTRLMODE_CC_LEN8_DLC,\n\t.tx_start_of_frame = 0xAFAF,\n\t.rx_start_of_frame = 0xFAFA,\n\t.tx_urb_cmd_max_len = ES581_4_TX_URB_CMD_MAX_LEN,\n\t.rx_urb_cmd_max_len = ES581_4_RX_URB_CMD_MAX_LEN,\n\t \n\t.fifo_mask = 63,  \n\t.dql_min_limit = CAN_FRAME_LEN_MAX * 50,  \n\t.tx_bulk_max = ES581_4_TX_BULK_MAX,\n\t.urb_cmd_header_len = ES581_4_URB_CMD_HEADER_LEN,\n\t.rx_urb_max = ES58X_RX_URBS_MAX,\n\t.tx_urb_max = ES58X_TX_URBS_MAX\n};\n\nconst struct es58x_operators es581_4_ops = {\n\t.get_msg_len = es581_4_get_msg_len,\n\t.handle_urb_cmd = es581_4_handle_urb_cmd,\n\t.fill_urb_header = es581_4_fill_urb_header,\n\t.tx_can_msg = es581_4_tx_can_msg,\n\t.enable_channel = es581_4_enable_channel,\n\t.disable_channel = es581_4_disable_channel,\n\t.reset_device = es581_4_reset_device,\n\t.get_timestamp = es581_4_get_timestamp\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}