{
  "module_name": "es58x_core.c",
  "hash_id": "509c8daabb72b7c01d8d93fea63e057232a2e66d6be61fd9e13a068ee470907a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/usb/etas_es58x/es58x_core.c",
  "human_readable_source": "\n\n \n\n#include <asm/unaligned.h>\n#include <linux/crc16.h>\n#include <linux/ethtool.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <net/devlink.h>\n\n#include \"es58x_core.h\"\n\nMODULE_AUTHOR(\"Vincent Mailhol <mailhol.vincent@wanadoo.fr>\");\nMODULE_AUTHOR(\"Arunachalam Santhanam <arunachalam.santhanam@in.bosch.com>\");\nMODULE_DESCRIPTION(\"Socket CAN driver for ETAS ES58X USB adapters\");\nMODULE_LICENSE(\"GPL v2\");\n\n#define ES58X_VENDOR_ID 0x108C\n#define ES581_4_PRODUCT_ID 0x0159\n#define ES582_1_PRODUCT_ID 0x0168\n#define ES584_1_PRODUCT_ID 0x0169\n\n \n#define ES58X_FD_INTERFACE_PROTOCOL 0\n\n \nstatic const struct usb_device_id es58x_id_table[] = {\n\t{\n\t\t \n\t\tUSB_DEVICE(ES58X_VENDOR_ID, ES581_4_PRODUCT_ID),\n\t\t.driver_info = ES58X_DUAL_CHANNEL\n\t}, {\n\t\t \n\t\tUSB_DEVICE_INTERFACE_PROTOCOL(ES58X_VENDOR_ID, ES582_1_PRODUCT_ID,\n\t\t\t\t\t      ES58X_FD_INTERFACE_PROTOCOL),\n\t\t.driver_info = ES58X_DUAL_CHANNEL | ES58X_FD_FAMILY\n\t}, {\n\t\t \n\t\tUSB_DEVICE_INTERFACE_PROTOCOL(ES58X_VENDOR_ID, ES584_1_PRODUCT_ID,\n\t\t\t\t\t      ES58X_FD_INTERFACE_PROTOCOL),\n\t\t.driver_info = ES58X_FD_FAMILY\n\t}, {\n\t\t \n\t}\n};\n\nMODULE_DEVICE_TABLE(usb, es58x_id_table);\n\n#define es58x_print_hex_dump(buf, len)\t\t\t\t\t\\\n\tprint_hex_dump(KERN_DEBUG,\t\t\t\t\t\\\n\t\t       KBUILD_MODNAME \" \" __stringify(buf) \": \",\t\\\n\t\t       DUMP_PREFIX_NONE, 16, 1, buf, len, false)\n\n#define es58x_print_hex_dump_debug(buf, len)\t\t\t\t \\\n\tprint_hex_dump_debug(KBUILD_MODNAME \" \" __stringify(buf) \": \",\\\n\t\t\t     DUMP_PREFIX_NONE, 16, 1, buf, len, false)\n\n \n#define ES58X_CRC_CALC_OFFSET sizeof_field(union es58x_urb_cmd, sof)\n\n \nstatic u16 es58x_calculate_crc(const union es58x_urb_cmd *urb_cmd, u16 urb_len)\n{\n\tu16 crc;\n\tssize_t len = urb_len - ES58X_CRC_CALC_OFFSET - sizeof(crc);\n\n\tcrc = crc16(0, &urb_cmd->raw_cmd[ES58X_CRC_CALC_OFFSET], len);\n\treturn crc;\n}\n\n \nstatic u16 es58x_get_crc(const union es58x_urb_cmd *urb_cmd, u16 urb_len)\n{\n\tu16 crc;\n\tconst __le16 *crc_addr;\n\n\tcrc_addr = (__le16 *)&urb_cmd->raw_cmd[urb_len - sizeof(crc)];\n\tcrc = get_unaligned_le16(crc_addr);\n\treturn crc;\n}\n\n \nstatic void es58x_set_crc(union es58x_urb_cmd *urb_cmd, u16 urb_len)\n{\n\tu16 crc;\n\t__le16 *crc_addr;\n\n\tcrc = es58x_calculate_crc(urb_cmd, urb_len);\n\tcrc_addr = (__le16 *)&urb_cmd->raw_cmd[urb_len - sizeof(crc)];\n\tput_unaligned_le16(crc, crc_addr);\n}\n\n \nstatic int es58x_check_crc(struct es58x_device *es58x_dev,\n\t\t\t   const union es58x_urb_cmd *urb_cmd, u16 urb_len)\n{\n\tu16 calculated_crc = es58x_calculate_crc(urb_cmd, urb_len);\n\tu16 expected_crc = es58x_get_crc(urb_cmd, urb_len);\n\n\tif (expected_crc != calculated_crc) {\n\t\tdev_err_ratelimited(es58x_dev->dev,\n\t\t\t\t    \"%s: Bad CRC, urb_len: %d\\n\",\n\t\t\t\t    __func__, urb_len);\n\t\treturn -EBADMSG;\n\t}\n\n\treturn 0;\n}\n\n \nstatic u64 es58x_timestamp_to_ns(u64 timestamp)\n{\n\tconst u64 es58x_timestamp_ns_mult_coef = 500ULL;\n\n\treturn es58x_timestamp_ns_mult_coef * timestamp;\n}\n\n \nstatic void es58x_set_skb_timestamp(struct net_device *netdev,\n\t\t\t\t    struct sk_buff *skb, u64 timestamp)\n{\n\tstruct es58x_device *es58x_dev = es58x_priv(netdev)->es58x_dev;\n\tstruct skb_shared_hwtstamps *hwts;\n\n\thwts = skb_hwtstamps(skb);\n\t \n\thwts->hwtstamp = ns_to_ktime(es58x_timestamp_to_ns(timestamp) +\n\t\t\t\t     es58x_dev->realtime_diff_ns);\n}\n\n \nvoid es58x_rx_timestamp(struct es58x_device *es58x_dev, u64 timestamp)\n{\n\tu64 ktime_real_ns = ktime_get_real_ns();\n\tu64 device_timestamp = es58x_timestamp_to_ns(timestamp);\n\n\tdev_dbg(es58x_dev->dev, \"%s: request round-trip time: %llu ns\\n\",\n\t\t__func__, ktime_real_ns - es58x_dev->ktime_req_ns);\n\n\tes58x_dev->realtime_diff_ns =\n\t    (es58x_dev->ktime_req_ns + ktime_real_ns) / 2 - device_timestamp;\n\tes58x_dev->ktime_req_ns = 0;\n\n\tdev_dbg(es58x_dev->dev,\n\t\t\"%s: Device timestamp: %llu, diff with kernel: %llu\\n\",\n\t\t__func__, device_timestamp, es58x_dev->realtime_diff_ns);\n}\n\n \nstatic int es58x_set_realtime_diff_ns(struct es58x_device *es58x_dev)\n{\n\tif (es58x_dev->ktime_req_ns) {\n\t\tdev_warn(es58x_dev->dev,\n\t\t\t \"%s: Previous request to set timestamp has not completed yet\\n\",\n\t\t\t __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tes58x_dev->ktime_req_ns = ktime_get_real_ns();\n\treturn es58x_dev->ops->get_timestamp(es58x_dev);\n}\n\n \nstatic bool es58x_is_can_state_active(struct net_device *netdev)\n{\n\treturn es58x_priv(netdev)->can.state < CAN_STATE_BUS_OFF;\n}\n\n \nstatic bool es58x_is_echo_skb_threshold_reached(struct es58x_priv *priv)\n{\n\tu32 num_echo_skb =  priv->tx_head - priv->tx_tail;\n\tu32 threshold = priv->can.echo_skb_max -\n\t\tpriv->es58x_dev->param->tx_bulk_max + 1;\n\n\treturn num_echo_skb >= threshold;\n}\n\n \nstatic void es58x_can_free_echo_skb_tail(struct net_device *netdev)\n{\n\tstruct es58x_priv *priv = es58x_priv(netdev);\n\tu16 fifo_mask = priv->es58x_dev->param->fifo_mask;\n\tunsigned int frame_len = 0;\n\n\tcan_free_echo_skb(netdev, priv->tx_tail & fifo_mask, &frame_len);\n\tnetdev_completed_queue(netdev, 1, frame_len);\n\n\tpriv->tx_tail++;\n\n\tnetdev->stats.tx_dropped++;\n}\n\n \nstatic int es58x_can_get_echo_skb_recovery(struct net_device *netdev,\n\t\t\t\t\t   u32 rcv_packet_idx)\n{\n\tstruct es58x_priv *priv = es58x_priv(netdev);\n\tint ret = 0;\n\n\tnetdev->stats.tx_errors++;\n\n\tif (net_ratelimit())\n\t\tnetdev_warn(netdev,\n\t\t\t    \"Bad echo packet index: %u. First index: %u, end index %u, num_echo_skb: %02u/%02u\\n\",\n\t\t\t    rcv_packet_idx, priv->tx_tail, priv->tx_head,\n\t\t\t    priv->tx_head - priv->tx_tail,\n\t\t\t    priv->can.echo_skb_max);\n\n\tif ((s32)(rcv_packet_idx - priv->tx_tail) < 0) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_warn(netdev,\n\t\t\t\t    \"Received echo index is from the past. Ignoring it\\n\");\n\t\tret = -EINVAL;\n\t} else if ((s32)(rcv_packet_idx - priv->tx_head) >= 0) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Received echo index is from the future. Ignoring it\\n\");\n\t\tret = -EINVAL;\n\t} else {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_warn(netdev,\n\t\t\t\t    \"Recovery: dropping %u echo skb from index %u to %u\\n\",\n\t\t\t\t    rcv_packet_idx - priv->tx_tail,\n\t\t\t\t    priv->tx_tail, rcv_packet_idx - 1);\n\t\twhile (priv->tx_tail != rcv_packet_idx) {\n\t\t\tif (priv->tx_tail == priv->tx_head)\n\t\t\t\treturn -EINVAL;\n\t\t\tes58x_can_free_echo_skb_tail(netdev);\n\t\t}\n\t}\n\treturn ret;\n}\n\n \nint es58x_can_get_echo_skb(struct net_device *netdev, u32 rcv_packet_idx,\n\t\t\t   u64 *tstamps, unsigned int pkts)\n{\n\tstruct es58x_priv *priv = es58x_priv(netdev);\n\tunsigned int rx_total_frame_len = 0;\n\tunsigned int num_echo_skb = priv->tx_head - priv->tx_tail;\n\tint i;\n\tu16 fifo_mask = priv->es58x_dev->param->fifo_mask;\n\n\tif (!netif_running(netdev)) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_info(netdev,\n\t\t\t\t    \"%s: %s is down, dropping %d echo packets\\n\",\n\t\t\t\t    __func__, netdev->name, pkts);\n\t\tnetdev->stats.tx_dropped += pkts;\n\t\treturn 0;\n\t} else if (!es58x_is_can_state_active(netdev)) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_dbg(netdev,\n\t\t\t\t   \"Bus is off or device is restarting. Ignoring %u echo packets from index %u\\n\",\n\t\t\t\t   pkts, rcv_packet_idx);\n\t\t \n\t\treturn 0;\n\t} else if (num_echo_skb == 0) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_warn(netdev,\n\t\t\t\t    \"Received %u echo packets from index: %u but echo skb queue is empty.\\n\",\n\t\t\t\t    pkts, rcv_packet_idx);\n\t\tnetdev->stats.tx_dropped += pkts;\n\t\treturn 0;\n\t}\n\n\tif (priv->tx_tail != rcv_packet_idx) {\n\t\tif (es58x_can_get_echo_skb_recovery(netdev, rcv_packet_idx) < 0) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tnetdev_warn(netdev,\n\t\t\t\t\t    \"Could not find echo skb for echo packet index: %u\\n\",\n\t\t\t\t\t    rcv_packet_idx);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (num_echo_skb < pkts) {\n\t\tint pkts_drop = pkts - num_echo_skb;\n\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Received %u echo packets but have only %d echo skb. Dropping %d echo skb\\n\",\n\t\t\t\t   pkts, num_echo_skb, pkts_drop);\n\t\tnetdev->stats.tx_dropped += pkts_drop;\n\t\tpkts -= pkts_drop;\n\t}\n\n\tfor (i = 0; i < pkts; i++) {\n\t\tunsigned int skb_idx = priv->tx_tail & fifo_mask;\n\t\tstruct sk_buff *skb = priv->can.echo_skb[skb_idx];\n\t\tunsigned int frame_len = 0;\n\n\t\tif (skb)\n\t\t\tes58x_set_skb_timestamp(netdev, skb, tstamps[i]);\n\n\t\tnetdev->stats.tx_bytes += can_get_echo_skb(netdev, skb_idx,\n\t\t\t\t\t\t\t   &frame_len);\n\t\trx_total_frame_len += frame_len;\n\n\t\tpriv->tx_tail++;\n\t}\n\n\tnetdev_completed_queue(netdev, pkts, rx_total_frame_len);\n\tnetdev->stats.tx_packets += pkts;\n\n\tpriv->err_passive_before_rtx_success = 0;\n\tif (!es58x_is_echo_skb_threshold_reached(priv))\n\t\tnetif_wake_queue(netdev);\n\n\treturn 0;\n}\n\n \nstatic void es58x_can_reset_echo_fifo(struct net_device *netdev)\n{\n\tstruct es58x_priv *priv = es58x_priv(netdev);\n\n\tpriv->tx_tail = 0;\n\tpriv->tx_head = 0;\n\tpriv->tx_urb = NULL;\n\tpriv->err_passive_before_rtx_success = 0;\n\tnetdev_reset_queue(netdev);\n}\n\n \nstatic void es58x_flush_pending_tx_msg(struct net_device *netdev)\n{\n\tstruct es58x_priv *priv = es58x_priv(netdev);\n\tstruct es58x_device *es58x_dev = priv->es58x_dev;\n\n\tif (priv->tx_urb) {\n\t\tnetdev_warn(netdev, \"%s: dropping %d TX messages\\n\",\n\t\t\t    __func__, priv->tx_can_msg_cnt);\n\t\tnetdev->stats.tx_dropped += priv->tx_can_msg_cnt;\n\t\twhile (priv->tx_can_msg_cnt > 0) {\n\t\t\tunsigned int frame_len = 0;\n\t\t\tu16 fifo_mask = priv->es58x_dev->param->fifo_mask;\n\n\t\t\tpriv->tx_head--;\n\t\t\tpriv->tx_can_msg_cnt--;\n\t\t\tcan_free_echo_skb(netdev, priv->tx_head & fifo_mask,\n\t\t\t\t\t  &frame_len);\n\t\t\tnetdev_completed_queue(netdev, 1, frame_len);\n\t\t}\n\t\tusb_anchor_urb(priv->tx_urb, &priv->es58x_dev->tx_urbs_idle);\n\t\tatomic_inc(&es58x_dev->tx_urbs_idle_cnt);\n\t\tusb_free_urb(priv->tx_urb);\n\t}\n\tpriv->tx_urb = NULL;\n}\n\n \nint es58x_tx_ack_msg(struct net_device *netdev, u16 tx_free_entries,\n\t\t     enum es58x_ret_u32 rx_cmd_ret_u32)\n{\n\tstruct es58x_priv *priv = es58x_priv(netdev);\n\n\tif (tx_free_entries <= priv->es58x_dev->param->tx_bulk_max) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Only %d entries left in device queue, num_echo_skb: %d/%d\\n\",\n\t\t\t\t   tx_free_entries,\n\t\t\t\t   priv->tx_head - priv->tx_tail,\n\t\t\t\t   priv->can.echo_skb_max);\n\t\tnetif_stop_queue(netdev);\n\t}\n\n\treturn es58x_rx_cmd_ret_u32(netdev, ES58X_RET_TYPE_TX_MSG,\n\t\t\t\t    rx_cmd_ret_u32);\n}\n\n \nint es58x_rx_can_msg(struct net_device *netdev, u64 timestamp, const u8 *data,\n\t\t     canid_t can_id, enum es58x_flag es58x_flags, u8 dlc)\n{\n\tstruct canfd_frame *cfd;\n\tstruct can_frame *ccf;\n\tstruct sk_buff *skb;\n\tu8 len;\n\tbool is_can_fd = !!(es58x_flags & ES58X_FLAG_FD_DATA);\n\n\tif (dlc > CAN_MAX_RAW_DLC) {\n\t\tnetdev_err(netdev,\n\t\t\t   \"%s: DLC is %d but maximum should be %d\\n\",\n\t\t\t   __func__, dlc, CAN_MAX_RAW_DLC);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tif (is_can_fd) {\n\t\tlen = can_fd_dlc2len(dlc);\n\t\tskb = alloc_canfd_skb(netdev, &cfd);\n\t} else {\n\t\tlen = can_cc_dlc2len(dlc);\n\t\tskb = alloc_can_skb(netdev, &ccf);\n\t\tcfd = (struct canfd_frame *)ccf;\n\t}\n\tif (!skb) {\n\t\tnetdev->stats.rx_dropped++;\n\t\treturn 0;\n\t}\n\n\tcfd->can_id = can_id;\n\tif (es58x_flags & ES58X_FLAG_EFF)\n\t\tcfd->can_id |= CAN_EFF_FLAG;\n\tif (is_can_fd) {\n\t\tcfd->len = len;\n\t\tif (es58x_flags & ES58X_FLAG_FD_BRS)\n\t\t\tcfd->flags |= CANFD_BRS;\n\t\tif (es58x_flags & ES58X_FLAG_FD_ESI)\n\t\t\tcfd->flags |= CANFD_ESI;\n\t} else {\n\t\tcan_frame_set_cc_len(ccf, dlc, es58x_priv(netdev)->can.ctrlmode);\n\t\tif (es58x_flags & ES58X_FLAG_RTR) {\n\t\t\tccf->can_id |= CAN_RTR_FLAG;\n\t\t\tlen = 0;\n\t\t}\n\t}\n\tmemcpy(cfd->data, data, len);\n\tnetdev->stats.rx_packets++;\n\tnetdev->stats.rx_bytes += len;\n\n\tes58x_set_skb_timestamp(netdev, skb, timestamp);\n\tnetif_rx(skb);\n\n\tes58x_priv(netdev)->err_passive_before_rtx_success = 0;\n\n\treturn 0;\n}\n\n \nint es58x_rx_err_msg(struct net_device *netdev, enum es58x_err error,\n\t\t     enum es58x_event event, u64 timestamp)\n{\n\tstruct es58x_priv *priv = es58x_priv(netdev);\n\tstruct can_priv *can = netdev_priv(netdev);\n\tstruct can_device_stats *can_stats = &can->can_stats;\n\tstruct can_frame *cf = NULL;\n\tstruct sk_buff *skb;\n\tint ret = 0;\n\n\tif (!netif_running(netdev)) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_info(netdev, \"%s: %s is down, dropping packet\\n\",\n\t\t\t\t    __func__, netdev->name);\n\t\tnetdev->stats.rx_dropped++;\n\t\treturn 0;\n\t}\n\n\tif (error == ES58X_ERR_OK && event == ES58X_EVENT_OK) {\n\t\tnetdev_err(netdev, \"%s: Both error and event are zero\\n\",\n\t\t\t   __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tskb = alloc_can_err_skb(netdev, &cf);\n\n\tswitch (error) {\n\tcase ES58X_ERR_OK:\t \n\t\tbreak;\n\n\tcase ES58X_ERR_PROT_STUFF:\n\t\tif (net_ratelimit())\n\t\t\tnetdev_dbg(netdev, \"Error BITSTUFF\\n\");\n\t\tif (cf)\n\t\t\tcf->data[2] |= CAN_ERR_PROT_STUFF;\n\t\tbreak;\n\n\tcase ES58X_ERR_PROT_FORM:\n\t\tif (net_ratelimit())\n\t\t\tnetdev_dbg(netdev, \"Error FORMAT\\n\");\n\t\tif (cf)\n\t\t\tcf->data[2] |= CAN_ERR_PROT_FORM;\n\t\tbreak;\n\n\tcase ES58X_ERR_ACK:\n\t\tif (net_ratelimit())\n\t\t\tnetdev_dbg(netdev, \"Error ACK\\n\");\n\t\tif (cf)\n\t\t\tcf->can_id |= CAN_ERR_ACK;\n\t\tbreak;\n\n\tcase ES58X_ERR_PROT_BIT:\n\t\tif (net_ratelimit())\n\t\t\tnetdev_dbg(netdev, \"Error BIT\\n\");\n\t\tif (cf)\n\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT;\n\t\tbreak;\n\n\tcase ES58X_ERR_PROT_CRC:\n\t\tif (net_ratelimit())\n\t\t\tnetdev_dbg(netdev, \"Error CRC\\n\");\n\t\tif (cf)\n\t\t\tcf->data[3] |= CAN_ERR_PROT_LOC_CRC_SEQ;\n\t\tbreak;\n\n\tcase ES58X_ERR_PROT_BIT1:\n\t\tif (net_ratelimit())\n\t\t\tnetdev_dbg(netdev,\n\t\t\t\t   \"Error: expected a recessive bit but monitored a dominant one\\n\");\n\t\tif (cf)\n\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT1;\n\t\tbreak;\n\n\tcase ES58X_ERR_PROT_BIT0:\n\t\tif (net_ratelimit())\n\t\t\tnetdev_dbg(netdev,\n\t\t\t\t   \"Error expected a dominant bit but monitored a recessive one\\n\");\n\t\tif (cf)\n\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT0;\n\t\tbreak;\n\n\tcase ES58X_ERR_PROT_OVERLOAD:\n\t\tif (net_ratelimit())\n\t\t\tnetdev_dbg(netdev, \"Error OVERLOAD\\n\");\n\t\tif (cf)\n\t\t\tcf->data[2] |= CAN_ERR_PROT_OVERLOAD;\n\t\tbreak;\n\n\tcase ES58X_ERR_PROT_UNSPEC:\n\t\tif (net_ratelimit())\n\t\t\tnetdev_dbg(netdev, \"Unspecified error\\n\");\n\t\tif (cf)\n\t\t\tcf->can_id |= CAN_ERR_PROT;\n\t\tbreak;\n\n\tdefault:\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"%s: Unspecified error code 0x%04X\\n\",\n\t\t\t\t   __func__, (int)error);\n\t\tif (cf)\n\t\t\tcf->can_id |= CAN_ERR_PROT;\n\t\tbreak;\n\t}\n\n\tswitch (event) {\n\tcase ES58X_EVENT_OK:\t \n\t\tbreak;\n\n\tcase ES58X_EVENT_CRTL_ACTIVE:\n\t\tif (can->state == CAN_STATE_BUS_OFF) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"%s: state transition: BUS OFF -> ACTIVE\\n\",\n\t\t\t\t   __func__);\n\t\t}\n\t\tif (net_ratelimit())\n\t\t\tnetdev_dbg(netdev, \"Event CAN BUS ACTIVE\\n\");\n\t\tif (cf)\n\t\t\tcf->data[1] |= CAN_ERR_CRTL_ACTIVE;\n\t\tcan->state = CAN_STATE_ERROR_ACTIVE;\n\t\tbreak;\n\n\tcase ES58X_EVENT_CRTL_PASSIVE:\n\t\tif (net_ratelimit())\n\t\t\tnetdev_dbg(netdev, \"Event CAN BUS PASSIVE\\n\");\n\t\t \n\t\tif (cf) {\n\t\t\tcf->data[1] |= CAN_ERR_CRTL_RX_PASSIVE;\n\t\t\tcf->data[1] |= CAN_ERR_CRTL_TX_PASSIVE;\n\t\t}\n\t\tif (can->state < CAN_STATE_BUS_OFF)\n\t\t\tcan->state = CAN_STATE_ERROR_PASSIVE;\n\t\tcan_stats->error_passive++;\n\t\tif (priv->err_passive_before_rtx_success < U8_MAX)\n\t\t\tpriv->err_passive_before_rtx_success++;\n\t\tbreak;\n\n\tcase ES58X_EVENT_CRTL_WARNING:\n\t\tif (net_ratelimit())\n\t\t\tnetdev_dbg(netdev, \"Event CAN BUS WARNING\\n\");\n\t\t \n\t\tif (cf) {\n\t\t\tcf->data[1] |= CAN_ERR_CRTL_RX_WARNING;\n\t\t\tcf->data[1] |= CAN_ERR_CRTL_TX_WARNING;\n\t\t}\n\t\tif (can->state < CAN_STATE_BUS_OFF)\n\t\t\tcan->state = CAN_STATE_ERROR_WARNING;\n\t\tcan_stats->error_warning++;\n\t\tbreak;\n\n\tcase ES58X_EVENT_BUSOFF:\n\t\tif (net_ratelimit())\n\t\t\tnetdev_dbg(netdev, \"Event CAN BUS OFF\\n\");\n\t\tif (cf)\n\t\t\tcf->can_id |= CAN_ERR_BUSOFF;\n\t\tcan_stats->bus_off++;\n\t\tnetif_stop_queue(netdev);\n\t\tif (can->state != CAN_STATE_BUS_OFF) {\n\t\t\tcan->state = CAN_STATE_BUS_OFF;\n\t\t\tcan_bus_off(netdev);\n\t\t\tret = can->do_set_mode(netdev, CAN_MODE_STOP);\n\t\t}\n\t\tbreak;\n\n\tcase ES58X_EVENT_SINGLE_WIRE:\n\t\tif (net_ratelimit())\n\t\t\tnetdev_warn(netdev,\n\t\t\t\t    \"Lost connection on either CAN high or CAN low\\n\");\n\t\t \n\t\tif (cf) {\n\t\t\tcf->data[4] |= CAN_ERR_TRX_CANH_NO_WIRE;\n\t\t\tcf->data[4] |= CAN_ERR_TRX_CANL_NO_WIRE;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"%s: Unspecified event code 0x%04X\\n\",\n\t\t\t\t   __func__, (int)event);\n\t\tif (cf)\n\t\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\tbreak;\n\t}\n\n\tif (cf) {\n\t\tif (cf->data[1])\n\t\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\tif (cf->data[2] || cf->data[3]) {\n\t\t\tcf->can_id |= CAN_ERR_PROT;\n\t\t\tcan_stats->bus_error++;\n\t\t}\n\t\tif (cf->data[4])\n\t\t\tcf->can_id |= CAN_ERR_TRX;\n\n\t\tes58x_set_skb_timestamp(netdev, skb, timestamp);\n\t\tnetif_rx(skb);\n\t}\n\n\tif ((event & ES58X_EVENT_CRTL_PASSIVE) &&\n\t    priv->err_passive_before_rtx_success == ES58X_CONSECUTIVE_ERR_PASSIVE_MAX) {\n\t\tnetdev_info(netdev,\n\t\t\t    \"Got %d consecutive warning events with no successful RX or TX. Forcing bus-off\\n\",\n\t\t\t    priv->err_passive_before_rtx_success);\n\t\treturn es58x_rx_err_msg(netdev, ES58X_ERR_OK,\n\t\t\t\t\tES58X_EVENT_BUSOFF, timestamp);\n\t}\n\n\treturn ret;\n}\n\n \nstatic const char *es58x_cmd_ret_desc(enum es58x_ret_type cmd_ret_type)\n{\n\tswitch (cmd_ret_type) {\n\tcase ES58X_RET_TYPE_SET_BITTIMING:\n\t\treturn \"Set bittiming\";\n\tcase ES58X_RET_TYPE_ENABLE_CHANNEL:\n\t\treturn \"Enable channel\";\n\tcase ES58X_RET_TYPE_DISABLE_CHANNEL:\n\t\treturn \"Disable channel\";\n\tcase ES58X_RET_TYPE_TX_MSG:\n\t\treturn \"Transmit message\";\n\tcase ES58X_RET_TYPE_RESET_RX:\n\t\treturn \"Reset RX\";\n\tcase ES58X_RET_TYPE_RESET_TX:\n\t\treturn \"Reset TX\";\n\tcase ES58X_RET_TYPE_DEVICE_ERR:\n\t\treturn \"Device error\";\n\t}\n\n\treturn \"<unknown>\";\n};\n\n \nint es58x_rx_cmd_ret_u8(struct device *dev,\n\t\t\tenum es58x_ret_type cmd_ret_type,\n\t\t\tenum es58x_ret_u8 rx_cmd_ret_u8)\n{\n\tconst char *ret_desc = es58x_cmd_ret_desc(cmd_ret_type);\n\n\tswitch (rx_cmd_ret_u8) {\n\tcase ES58X_RET_U8_OK:\n\t\tdev_dbg_ratelimited(dev, \"%s: OK\\n\", ret_desc);\n\t\treturn 0;\n\n\tcase ES58X_RET_U8_ERR_UNSPECIFIED_FAILURE:\n\t\tdev_err(dev, \"%s: unspecified failure\\n\", ret_desc);\n\t\treturn -EBADMSG;\n\n\tcase ES58X_RET_U8_ERR_NO_MEM:\n\t\tdev_err(dev, \"%s: device ran out of memory\\n\", ret_desc);\n\t\treturn -ENOMEM;\n\n\tcase ES58X_RET_U8_ERR_BAD_CRC:\n\t\tdev_err(dev, \"%s: CRC of previous command is incorrect\\n\",\n\t\t\tret_desc);\n\t\treturn -EIO;\n\n\tdefault:\n\t\tdev_err(dev, \"%s: returned unknown value: 0x%02X\\n\",\n\t\t\tret_desc, rx_cmd_ret_u8);\n\t\treturn -EBADMSG;\n\t}\n}\n\n \nint es58x_rx_cmd_ret_u32(struct net_device *netdev,\n\t\t\t enum es58x_ret_type cmd_ret_type,\n\t\t\t enum es58x_ret_u32 rx_cmd_ret_u32)\n{\n\tstruct es58x_priv *priv = es58x_priv(netdev);\n\tconst struct es58x_operators *ops = priv->es58x_dev->ops;\n\tconst char *ret_desc = es58x_cmd_ret_desc(cmd_ret_type);\n\n\tswitch (rx_cmd_ret_u32) {\n\tcase ES58X_RET_U32_OK:\n\t\tswitch (cmd_ret_type) {\n\t\tcase ES58X_RET_TYPE_ENABLE_CHANNEL:\n\t\t\tes58x_can_reset_echo_fifo(netdev);\n\t\t\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\t\tnetif_wake_queue(netdev);\n\t\t\tnetdev_info(netdev,\n\t\t\t\t    \"%s: %s (Serial Number %s): CAN%d channel becomes ready\\n\",\n\t\t\t\t    ret_desc, priv->es58x_dev->udev->product,\n\t\t\t\t    priv->es58x_dev->udev->serial,\n\t\t\t\t    priv->channel_idx + 1);\n\t\t\tbreak;\n\n\t\tcase ES58X_RET_TYPE_TX_MSG:\n\t\t\tif (IS_ENABLED(CONFIG_VERBOSE_DEBUG) && net_ratelimit())\n\t\t\t\tnetdev_vdbg(netdev, \"%s: OK\\n\", ret_desc);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tnetdev_dbg(netdev, \"%s: OK\\n\", ret_desc);\n\t\t\tbreak;\n\t\t}\n\t\treturn 0;\n\n\tcase ES58X_RET_U32_ERR_UNSPECIFIED_FAILURE:\n\t\tif (cmd_ret_type == ES58X_RET_TYPE_ENABLE_CHANNEL) {\n\t\t\tint ret;\n\n\t\t\tnetdev_warn(netdev,\n\t\t\t\t    \"%s: channel is already opened, closing and re-opening it to reflect new configuration\\n\",\n\t\t\t\t    ret_desc);\n\t\t\tret = ops->disable_channel(es58x_priv(netdev));\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\treturn ops->enable_channel(es58x_priv(netdev));\n\t\t}\n\t\tif (cmd_ret_type == ES58X_RET_TYPE_DISABLE_CHANNEL) {\n\t\t\tnetdev_info(netdev,\n\t\t\t\t    \"%s: channel is already closed\\n\", ret_desc);\n\t\t\treturn 0;\n\t\t}\n\t\tnetdev_err(netdev,\n\t\t\t   \"%s: unspecified failure\\n\", ret_desc);\n\t\treturn -EBADMSG;\n\n\tcase ES58X_RET_U32_ERR_NO_MEM:\n\t\tnetdev_err(netdev, \"%s: device ran out of memory\\n\", ret_desc);\n\t\treturn -ENOMEM;\n\n\tcase ES58X_RET_U32_WARN_PARAM_ADJUSTED:\n\t\tnetdev_warn(netdev,\n\t\t\t    \"%s: some incompatible parameters have been adjusted\\n\",\n\t\t\t    ret_desc);\n\t\treturn 0;\n\n\tcase ES58X_RET_U32_WARN_TX_MAYBE_REORDER:\n\t\tnetdev_warn(netdev,\n\t\t\t    \"%s: TX messages might have been reordered\\n\",\n\t\t\t    ret_desc);\n\t\treturn 0;\n\n\tcase ES58X_RET_U32_ERR_TIMEDOUT:\n\t\tnetdev_err(netdev, \"%s: command timed out\\n\", ret_desc);\n\t\treturn -ETIMEDOUT;\n\n\tcase ES58X_RET_U32_ERR_FIFO_FULL:\n\t\tnetdev_warn(netdev, \"%s: fifo is full\\n\", ret_desc);\n\t\treturn 0;\n\n\tcase ES58X_RET_U32_ERR_BAD_CONFIG:\n\t\tnetdev_err(netdev, \"%s: bad configuration\\n\", ret_desc);\n\t\treturn -EINVAL;\n\n\tcase ES58X_RET_U32_ERR_NO_RESOURCE:\n\t\tnetdev_err(netdev, \"%s: no resource available\\n\", ret_desc);\n\t\treturn -EBUSY;\n\n\tdefault:\n\t\tnetdev_err(netdev, \"%s returned unknown value: 0x%08X\\n\",\n\t\t\t   ret_desc, rx_cmd_ret_u32);\n\t\treturn -EBADMSG;\n\t}\n}\n\n \nstatic void es58x_increment_rx_errors(struct es58x_device *es58x_dev)\n{\n\tint i;\n\n\tfor (i = 0; i < es58x_dev->num_can_ch; i++)\n\t\tif (es58x_dev->netdev[i])\n\t\t\tes58x_dev->netdev[i]->stats.rx_errors++;\n}\n\n \nstatic void es58x_handle_urb_cmd(struct es58x_device *es58x_dev,\n\t\t\t\t const union es58x_urb_cmd *urb_cmd)\n{\n\tconst struct es58x_operators *ops = es58x_dev->ops;\n\tsize_t cmd_len;\n\tint i, ret;\n\n\tret = ops->handle_urb_cmd(es58x_dev, urb_cmd);\n\tswitch (ret) {\n\tcase 0:\t\t \n\t\treturn;\n\n\tcase -ENODEV:\n\t\tdev_err_ratelimited(es58x_dev->dev, \"Device is not ready\\n\");\n\t\tbreak;\n\n\tcase -EINVAL:\n\tcase -EMSGSIZE:\n\tcase -EBADRQC:\n\tcase -EBADMSG:\n\tcase -ECHRNG:\n\tcase -ETIMEDOUT:\n\t\tcmd_len = es58x_get_urb_cmd_len(es58x_dev,\n\t\t\t\t\t\tops->get_msg_len(urb_cmd));\n\t\tdev_err(es58x_dev->dev,\n\t\t\t\"ops->handle_urb_cmd() returned error %pe\",\n\t\t\tERR_PTR(ret));\n\t\tes58x_print_hex_dump(urb_cmd, cmd_len);\n\t\tbreak;\n\n\tcase -EFAULT:\n\tcase -ENOMEM:\n\tcase -EIO:\n\tdefault:\n\t\tdev_crit(es58x_dev->dev,\n\t\t\t \"ops->handle_urb_cmd() returned error %pe, detaching all network devices\\n\",\n\t\t\t ERR_PTR(ret));\n\t\tfor (i = 0; i < es58x_dev->num_can_ch; i++)\n\t\t\tif (es58x_dev->netdev[i])\n\t\t\t\tnetif_device_detach(es58x_dev->netdev[i]);\n\t\tif (es58x_dev->ops->reset_device)\n\t\t\tes58x_dev->ops->reset_device(es58x_dev);\n\t\tbreak;\n\t}\n\n\t \n\tes58x_increment_rx_errors(es58x_dev);\n}\n\n \nstatic signed int es58x_check_rx_urb(struct es58x_device *es58x_dev,\n\t\t\t\t     const union es58x_urb_cmd *urb_cmd,\n\t\t\t\t     u32 urb_actual_len)\n{\n\tconst struct device *dev = es58x_dev->dev;\n\tconst struct es58x_parameters *param = es58x_dev->param;\n\tu16 sof, msg_len;\n\tsigned int urb_cmd_len, ret;\n\n\tif (urb_actual_len < param->urb_cmd_header_len) {\n\t\tdev_vdbg(dev,\n\t\t\t \"%s: Received %d bytes [%*ph]: header incomplete\\n\",\n\t\t\t __func__, urb_actual_len, urb_actual_len,\n\t\t\t urb_cmd->raw_cmd);\n\t\treturn -ENODATA;\n\t}\n\n\tsof = get_unaligned_le16(&urb_cmd->sof);\n\tif (sof != param->rx_start_of_frame) {\n\t\tdev_err_ratelimited(es58x_dev->dev,\n\t\t\t\t    \"%s: Expected sequence 0x%04X for start of frame but got 0x%04X.\\n\",\n\t\t\t\t    __func__, param->rx_start_of_frame, sof);\n\t\treturn -EBADRQC;\n\t}\n\n\tmsg_len = es58x_dev->ops->get_msg_len(urb_cmd);\n\turb_cmd_len = es58x_get_urb_cmd_len(es58x_dev, msg_len);\n\tif (urb_cmd_len > param->rx_urb_cmd_max_len) {\n\t\tdev_err_ratelimited(es58x_dev->dev,\n\t\t\t\t    \"%s: Biggest expected size for rx urb_cmd is %u but receive a command of size %d\\n\",\n\t\t\t\t    __func__,\n\t\t\t\t    param->rx_urb_cmd_max_len, urb_cmd_len);\n\t\treturn -EOVERFLOW;\n\t} else if (urb_actual_len < urb_cmd_len) {\n\t\tdev_vdbg(dev, \"%s: Received %02d/%02d bytes\\n\",\n\t\t\t __func__, urb_actual_len, urb_cmd_len);\n\t\treturn -ENODATA;\n\t}\n\n\tret = es58x_check_crc(es58x_dev, urb_cmd, urb_cmd_len);\n\tif (ret)\n\t\treturn ret;\n\n\treturn urb_cmd_len;\n}\n\n \nstatic int es58x_copy_to_cmd_buf(struct es58x_device *es58x_dev,\n\t\t\t\t u8 *raw_cmd, int raw_cmd_len)\n{\n\tif (es58x_dev->rx_cmd_buf_len + raw_cmd_len >\n\t    es58x_dev->param->rx_urb_cmd_max_len)\n\t\treturn -EMSGSIZE;\n\n\tmemcpy(&es58x_dev->rx_cmd_buf.raw_cmd[es58x_dev->rx_cmd_buf_len],\n\t       raw_cmd, raw_cmd_len);\n\tes58x_dev->rx_cmd_buf_len += raw_cmd_len;\n\n\treturn 0;\n}\n\n \nstatic int es58x_split_urb_try_recovery(struct es58x_device *es58x_dev,\n\t\t\t\t\tu8 *raw_cmd, size_t raw_cmd_len)\n{\n\tunion es58x_urb_cmd *urb_cmd;\n\tsigned int urb_cmd_len;\n\tu16 sof;\n\tint dropped_bytes = 0;\n\n\tes58x_increment_rx_errors(es58x_dev);\n\n\twhile (raw_cmd_len > sizeof(sof)) {\n\t\turb_cmd = (union es58x_urb_cmd *)raw_cmd;\n\t\tsof = get_unaligned_le16(&urb_cmd->sof);\n\n\t\tif (sof == es58x_dev->param->rx_start_of_frame) {\n\t\t\turb_cmd_len = es58x_check_rx_urb(es58x_dev,\n\t\t\t\t\t\t\t urb_cmd, raw_cmd_len);\n\t\t\tif ((urb_cmd_len == -ENODATA) || urb_cmd_len > 0) {\n\t\t\t\tdev_info_ratelimited(es58x_dev->dev,\n\t\t\t\t\t\t     \"Recovery successful! Dropped %d bytes (urb_cmd_len: %d)\\n\",\n\t\t\t\t\t\t     dropped_bytes,\n\t\t\t\t\t\t     urb_cmd_len);\n\t\t\t\treturn dropped_bytes;\n\t\t\t}\n\t\t}\n\t\traw_cmd++;\n\t\traw_cmd_len--;\n\t\tdropped_bytes++;\n\t}\n\n\tdev_warn_ratelimited(es58x_dev->dev, \"%s: Recovery failed\\n\", __func__);\n\treturn -EBADMSG;\n}\n\n \nstatic signed int es58x_handle_incomplete_cmd(struct es58x_device *es58x_dev,\n\t\t\t\t\t      struct urb *urb)\n{\n\tsize_t cpy_len;\n\tsigned int urb_cmd_len, tmp_cmd_buf_len, ret;\n\n\ttmp_cmd_buf_len = es58x_dev->rx_cmd_buf_len;\n\tcpy_len = min_t(int, es58x_dev->param->rx_urb_cmd_max_len -\n\t\t\tes58x_dev->rx_cmd_buf_len, urb->actual_length);\n\tret = es58x_copy_to_cmd_buf(es58x_dev, urb->transfer_buffer, cpy_len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\turb_cmd_len = es58x_check_rx_urb(es58x_dev, &es58x_dev->rx_cmd_buf,\n\t\t\t\t\t es58x_dev->rx_cmd_buf_len);\n\tif (urb_cmd_len == -ENODATA) {\n\t\treturn -ENODATA;\n\t} else if (urb_cmd_len < 0) {\n\t\tdev_err_ratelimited(es58x_dev->dev,\n\t\t\t\t    \"Could not reconstitute incomplete command from previous URB, dropping %d bytes\\n\",\n\t\t\t\t    tmp_cmd_buf_len + urb->actual_length);\n\t\tdev_err_ratelimited(es58x_dev->dev,\n\t\t\t\t    \"Error code: %pe, es58x_dev->rx_cmd_buf_len: %d, urb->actual_length: %u\\n\",\n\t\t\t\t    ERR_PTR(urb_cmd_len),\n\t\t\t\t    tmp_cmd_buf_len, urb->actual_length);\n\t\tes58x_print_hex_dump(&es58x_dev->rx_cmd_buf, tmp_cmd_buf_len);\n\t\tes58x_print_hex_dump(urb->transfer_buffer, urb->actual_length);\n\t\treturn urb->actual_length;\n\t}\n\n\tes58x_handle_urb_cmd(es58x_dev, &es58x_dev->rx_cmd_buf);\n\treturn urb_cmd_len - tmp_cmd_buf_len;\t \n}\n\n \nstatic signed int es58x_split_urb(struct es58x_device *es58x_dev,\n\t\t\t\t  struct urb *urb)\n{\n\tunion es58x_urb_cmd *urb_cmd;\n\tu8 *raw_cmd = urb->transfer_buffer;\n\ts32 raw_cmd_len = urb->actual_length;\n\tint ret;\n\n\tif (es58x_dev->rx_cmd_buf_len != 0) {\n\t\tret = es58x_handle_incomplete_cmd(es58x_dev, urb);\n\t\tif (ret != -ENODATA)\n\t\t\tes58x_dev->rx_cmd_buf_len = 0;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\traw_cmd += ret;\n\t\traw_cmd_len -= ret;\n\t}\n\n\twhile (raw_cmd_len > 0) {\n\t\tif (raw_cmd[0] == ES58X_HEARTBEAT) {\n\t\t\traw_cmd++;\n\t\t\traw_cmd_len--;\n\t\t\tcontinue;\n\t\t}\n\t\turb_cmd = (union es58x_urb_cmd *)raw_cmd;\n\t\tret = es58x_check_rx_urb(es58x_dev, urb_cmd, raw_cmd_len);\n\t\tif (ret > 0) {\n\t\t\tes58x_handle_urb_cmd(es58x_dev, urb_cmd);\n\t\t} else if (ret == -ENODATA) {\n\t\t\tes58x_copy_to_cmd_buf(es58x_dev, raw_cmd, raw_cmd_len);\n\t\t\treturn -ENODATA;\n\t\t} else if (ret < 0) {\n\t\t\tret = es58x_split_urb_try_recovery(es58x_dev, raw_cmd,\n\t\t\t\t\t\t\t   raw_cmd_len);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\traw_cmd += ret;\n\t\traw_cmd_len -= ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void es58x_read_bulk_callback(struct urb *urb)\n{\n\tstruct es58x_device *es58x_dev = urb->context;\n\tconst struct device *dev = es58x_dev->dev;\n\tint i, ret;\n\n\tswitch (urb->status) {\n\tcase 0:\t\t \n\t\tbreak;\n\n\tcase -EOVERFLOW:\n\t\tdev_err_ratelimited(dev, \"%s: error %pe\\n\",\n\t\t\t\t    __func__, ERR_PTR(urb->status));\n\t\tes58x_print_hex_dump_debug(urb->transfer_buffer,\n\t\t\t\t\t   urb->transfer_buffer_length);\n\t\tgoto resubmit_urb;\n\n\tcase -EPROTO:\n\t\tdev_warn_ratelimited(dev, \"%s: error %pe. Device unplugged?\\n\",\n\t\t\t\t     __func__, ERR_PTR(urb->status));\n\t\tgoto free_urb;\n\n\tcase -ENOENT:\n\tcase -EPIPE:\n\t\tdev_err_ratelimited(dev, \"%s: error %pe\\n\",\n\t\t\t\t    __func__, ERR_PTR(urb->status));\n\t\tgoto free_urb;\n\n\tcase -ESHUTDOWN:\n\t\tdev_dbg_ratelimited(dev, \"%s: error %pe\\n\",\n\t\t\t\t    __func__, ERR_PTR(urb->status));\n\t\tgoto free_urb;\n\n\tdefault:\n\t\tdev_err_ratelimited(dev, \"%s: error %pe\\n\",\n\t\t\t\t    __func__, ERR_PTR(urb->status));\n\t\tgoto resubmit_urb;\n\t}\n\n\tret = es58x_split_urb(es58x_dev, urb);\n\tif ((ret != -ENODATA) && ret < 0) {\n\t\tdev_err(es58x_dev->dev, \"es58x_split_urb() returned error %pe\",\n\t\t\tERR_PTR(ret));\n\t\tes58x_print_hex_dump_debug(urb->transfer_buffer,\n\t\t\t\t\t   urb->actual_length);\n\n\t\t \n\t\tes58x_increment_rx_errors(es58x_dev);\n\t}\n\n resubmit_urb:\n\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (ret == -ENODEV) {\n\t\tfor (i = 0; i < es58x_dev->num_can_ch; i++)\n\t\t\tif (es58x_dev->netdev[i])\n\t\t\t\tnetif_device_detach(es58x_dev->netdev[i]);\n\t} else if (ret)\n\t\tdev_err_ratelimited(dev,\n\t\t\t\t    \"Failed resubmitting read bulk urb: %pe\\n\",\n\t\t\t\t    ERR_PTR(ret));\n\treturn;\n\n free_urb:\n\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n}\n\n \nstatic void es58x_write_bulk_callback(struct urb *urb)\n{\n\tstruct net_device *netdev = urb->context;\n\tstruct es58x_device *es58x_dev = es58x_priv(netdev)->es58x_dev;\n\n\tswitch (urb->status) {\n\tcase 0:\t\t \n\t\tbreak;\n\n\tcase -EOVERFLOW:\n\t\tif (net_ratelimit())\n\t\t\tnetdev_err(netdev, \"%s: error %pe\\n\",\n\t\t\t\t   __func__, ERR_PTR(urb->status));\n\t\tes58x_print_hex_dump(urb->transfer_buffer,\n\t\t\t\t     urb->transfer_buffer_length);\n\t\tbreak;\n\n\tcase -ENOENT:\n\t\tif (net_ratelimit())\n\t\t\tnetdev_dbg(netdev, \"%s: error %pe\\n\",\n\t\t\t\t   __func__, ERR_PTR(urb->status));\n\t\tusb_free_coherent(urb->dev,\n\t\t\t\t  es58x_dev->param->tx_urb_cmd_max_len,\n\t\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\t\treturn;\n\n\tdefault:\n\t\tif (net_ratelimit())\n\t\t\tnetdev_info(netdev, \"%s: error %pe\\n\",\n\t\t\t\t    __func__, ERR_PTR(urb->status));\n\t\tbreak;\n\t}\n\n\tusb_anchor_urb(urb, &es58x_dev->tx_urbs_idle);\n\tatomic_inc(&es58x_dev->tx_urbs_idle_cnt);\n}\n\n \nstatic int es58x_alloc_urb(struct es58x_device *es58x_dev, struct urb **urb,\n\t\t\t   u8 **buf, size_t buf_len, gfp_t mem_flags)\n{\n\t*urb = usb_alloc_urb(0, mem_flags);\n\tif (!*urb) {\n\t\tdev_err(es58x_dev->dev, \"No memory left for URBs\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t*buf = usb_alloc_coherent(es58x_dev->udev, buf_len,\n\t\t\t\t  mem_flags, &(*urb)->transfer_dma);\n\tif (!*buf) {\n\t\tdev_err(es58x_dev->dev, \"No memory left for USB buffer\\n\");\n\t\tusb_free_urb(*urb);\n\t\treturn -ENOMEM;\n\t}\n\n\t(*urb)->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\treturn 0;\n}\n\n \nstatic struct urb *es58x_get_tx_urb(struct es58x_device *es58x_dev)\n{\n\tatomic_t *idle_cnt = &es58x_dev->tx_urbs_idle_cnt;\n\tstruct urb *urb = usb_get_from_anchor(&es58x_dev->tx_urbs_idle);\n\n\tif (!urb) {\n\t\tsize_t tx_buf_len;\n\t\tu8 *buf;\n\n\t\ttx_buf_len = es58x_dev->param->tx_urb_cmd_max_len;\n\t\tif (es58x_alloc_urb(es58x_dev, &urb, &buf, tx_buf_len,\n\t\t\t\t    GFP_ATOMIC))\n\t\t\treturn NULL;\n\n\t\tusb_fill_bulk_urb(urb, es58x_dev->udev, es58x_dev->tx_pipe,\n\t\t\t\t  buf, tx_buf_len, es58x_write_bulk_callback,\n\t\t\t\t  NULL);\n\t\treturn urb;\n\t}\n\n\twhile (atomic_dec_return(idle_cnt) > ES58X_TX_URBS_MAX) {\n\t\t \n\t\tstruct urb *tmp = usb_get_from_anchor(&es58x_dev->tx_urbs_idle);\n\n\t\tif (!tmp)\n\t\t\tbreak;\n\t\tusb_free_coherent(tmp->dev,\n\t\t\t\t  es58x_dev->param->tx_urb_cmd_max_len,\n\t\t\t\t  tmp->transfer_buffer, tmp->transfer_dma);\n\t\tusb_free_urb(tmp);\n\t}\n\n\treturn urb;\n}\n\n \nstatic int es58x_submit_urb(struct es58x_device *es58x_dev, struct urb *urb,\n\t\t\t    struct net_device *netdev)\n{\n\tint ret;\n\n\tes58x_set_crc(urb->transfer_buffer, urb->transfer_buffer_length);\n\turb->context = netdev;\n\tusb_anchor_urb(urb, &es58x_dev->tx_urbs_busy);\n\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (ret) {\n\t\tnetdev_err(netdev, \"%s: USB send urb failure: %pe\\n\",\n\t\t\t   __func__, ERR_PTR(ret));\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_coherent(urb->dev,\n\t\t\t\t  es58x_dev->param->tx_urb_cmd_max_len,\n\t\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\t}\n\tusb_free_urb(urb);\n\n\treturn ret;\n}\n\n \nint es58x_send_msg(struct es58x_device *es58x_dev, u8 cmd_type, u8 cmd_id,\n\t\t   const void *msg, u16 msg_len, int channel_idx)\n{\n\tstruct net_device *netdev;\n\tunion es58x_urb_cmd *urb_cmd;\n\tstruct urb *urb;\n\tint urb_cmd_len;\n\n\tif (channel_idx == ES58X_CHANNEL_IDX_NA)\n\t\tnetdev = es58x_dev->netdev[0];\t \n\telse\n\t\tnetdev = es58x_dev->netdev[channel_idx];\n\n\turb_cmd_len = es58x_get_urb_cmd_len(es58x_dev, msg_len);\n\tif (urb_cmd_len > es58x_dev->param->tx_urb_cmd_max_len)\n\t\treturn -EOVERFLOW;\n\n\turb = es58x_get_tx_urb(es58x_dev);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\turb_cmd = urb->transfer_buffer;\n\tes58x_dev->ops->fill_urb_header(urb_cmd, cmd_type, cmd_id,\n\t\t\t\t\tchannel_idx, msg_len);\n\tmemcpy(&urb_cmd->raw_cmd[es58x_dev->param->urb_cmd_header_len],\n\t       msg, msg_len);\n\turb->transfer_buffer_length = urb_cmd_len;\n\n\treturn es58x_submit_urb(es58x_dev, urb, netdev);\n}\n\n \nstatic int es58x_alloc_rx_urbs(struct es58x_device *es58x_dev)\n{\n\tconst struct device *dev = es58x_dev->dev;\n\tconst struct es58x_parameters *param = es58x_dev->param;\n\tu16 rx_buf_len = usb_maxpacket(es58x_dev->udev, es58x_dev->rx_pipe);\n\tstruct urb *urb;\n\tu8 *buf;\n\tint i;\n\tint ret = -EINVAL;\n\n\tfor (i = 0; i < param->rx_urb_max; i++) {\n\t\tret = es58x_alloc_urb(es58x_dev, &urb, &buf, rx_buf_len,\n\t\t\t\t      GFP_KERNEL);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tusb_fill_bulk_urb(urb, es58x_dev->udev, es58x_dev->rx_pipe,\n\t\t\t\t  buf, rx_buf_len, es58x_read_bulk_callback,\n\t\t\t\t  es58x_dev);\n\t\tusb_anchor_urb(urb, &es58x_dev->rx_urbs);\n\n\t\tret = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (ret) {\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tusb_free_coherent(es58x_dev->udev, rx_buf_len,\n\t\t\t\t\t  buf, urb->transfer_dma);\n\t\t\tusb_free_urb(urb);\n\t\t\tbreak;\n\t\t}\n\t\tusb_free_urb(urb);\n\t}\n\n\tif (i == 0) {\n\t\tdev_err(dev, \"%s: Could not setup any rx URBs\\n\", __func__);\n\t\treturn ret;\n\t}\n\tdev_dbg(dev, \"%s: Allocated %d rx URBs each of size %u\\n\",\n\t\t__func__, i, rx_buf_len);\n\n\treturn ret;\n}\n\n \nstatic void es58x_free_urbs(struct es58x_device *es58x_dev)\n{\n\tstruct urb *urb;\n\n\tif (!usb_wait_anchor_empty_timeout(&es58x_dev->tx_urbs_busy, 1000)) {\n\t\tdev_err(es58x_dev->dev, \"%s: Timeout, some TX urbs still remain\\n\",\n\t\t\t__func__);\n\t\tusb_kill_anchored_urbs(&es58x_dev->tx_urbs_busy);\n\t}\n\n\twhile ((urb = usb_get_from_anchor(&es58x_dev->tx_urbs_idle)) != NULL) {\n\t\tusb_free_coherent(urb->dev, es58x_dev->param->tx_urb_cmd_max_len,\n\t\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\t\tusb_free_urb(urb);\n\t\tatomic_dec(&es58x_dev->tx_urbs_idle_cnt);\n\t}\n\tif (atomic_read(&es58x_dev->tx_urbs_idle_cnt))\n\t\tdev_err(es58x_dev->dev,\n\t\t\t\"All idle urbs were freed but tx_urb_idle_cnt is %d\\n\",\n\t\t\tatomic_read(&es58x_dev->tx_urbs_idle_cnt));\n\n\tusb_kill_anchored_urbs(&es58x_dev->rx_urbs);\n}\n\n \nstatic int es58x_open(struct net_device *netdev)\n{\n\tstruct es58x_device *es58x_dev = es58x_priv(netdev)->es58x_dev;\n\tint ret;\n\n\tif (!es58x_dev->opened_channel_cnt) {\n\t\tret = es58x_alloc_rx_urbs(es58x_dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = es58x_set_realtime_diff_ns(es58x_dev);\n\t\tif (ret)\n\t\t\tgoto free_urbs;\n\t}\n\n\tret = open_candev(netdev);\n\tif (ret)\n\t\tgoto free_urbs;\n\n\tret = es58x_dev->ops->enable_channel(es58x_priv(netdev));\n\tif (ret)\n\t\tgoto free_urbs;\n\n\tes58x_dev->opened_channel_cnt++;\n\tnetif_start_queue(netdev);\n\n\treturn ret;\n\n free_urbs:\n\tif (!es58x_dev->opened_channel_cnt)\n\t\tes58x_free_urbs(es58x_dev);\n\tnetdev_err(netdev, \"%s: Could not open the network device: %pe\\n\",\n\t\t   __func__, ERR_PTR(ret));\n\n\treturn ret;\n}\n\n \nstatic int es58x_stop(struct net_device *netdev)\n{\n\tstruct es58x_priv *priv = es58x_priv(netdev);\n\tstruct es58x_device *es58x_dev = priv->es58x_dev;\n\tint ret;\n\n\tnetif_stop_queue(netdev);\n\tret = es58x_dev->ops->disable_channel(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->can.state = CAN_STATE_STOPPED;\n\tes58x_can_reset_echo_fifo(netdev);\n\tclose_candev(netdev);\n\n\tes58x_flush_pending_tx_msg(netdev);\n\n\tes58x_dev->opened_channel_cnt--;\n\tif (!es58x_dev->opened_channel_cnt)\n\t\tes58x_free_urbs(es58x_dev);\n\n\treturn 0;\n}\n\n \nstatic int es58x_xmit_commit(struct net_device *netdev)\n{\n\tstruct es58x_priv *priv = es58x_priv(netdev);\n\tint ret;\n\n\tif (!es58x_is_can_state_active(netdev))\n\t\treturn -ENETDOWN;\n\n\tif (es58x_is_echo_skb_threshold_reached(priv))\n\t\tnetif_stop_queue(netdev);\n\n\tret = es58x_submit_urb(priv->es58x_dev, priv->tx_urb, netdev);\n\tif (ret == 0)\n\t\tpriv->tx_urb = NULL;\n\n\treturn ret;\n}\n\n \nstatic bool es58x_xmit_more(struct es58x_priv *priv)\n{\n\tunsigned int free_slots =\n\t    priv->can.echo_skb_max - (priv->tx_head - priv->tx_tail);\n\n\treturn netdev_xmit_more() && free_slots > 0 &&\n\t\tpriv->tx_can_msg_cnt < priv->es58x_dev->param->tx_bulk_max;\n}\n\n \nstatic netdev_tx_t es58x_start_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *netdev)\n{\n\tstruct es58x_priv *priv = es58x_priv(netdev);\n\tstruct es58x_device *es58x_dev = priv->es58x_dev;\n\tunsigned int frame_len;\n\tint ret;\n\n\tif (can_dev_dropped_skb(netdev, skb)) {\n\t\tif (priv->tx_urb)\n\t\t\tgoto xmit_commit;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (priv->tx_urb && priv->tx_can_msg_is_fd != can_is_canfd_skb(skb)) {\n\t\t \n\t\tret = es58x_xmit_commit(netdev);\n\t\tif (ret)\n\t\t\tgoto drop_skb;\n\t}\n\n\tif (!priv->tx_urb) {\n\t\tpriv->tx_urb = es58x_get_tx_urb(es58x_dev);\n\t\tif (!priv->tx_urb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto drop_skb;\n\t\t}\n\t\tpriv->tx_can_msg_cnt = 0;\n\t\tpriv->tx_can_msg_is_fd = can_is_canfd_skb(skb);\n\t}\n\n\tret = es58x_dev->ops->tx_can_msg(priv, skb);\n\tif (ret)\n\t\tgoto drop_skb;\n\n\tframe_len = can_skb_get_frame_len(skb);\n\tret = can_put_echo_skb(skb, netdev,\n\t\t\t       priv->tx_head & es58x_dev->param->fifo_mask,\n\t\t\t       frame_len);\n\tif (ret)\n\t\tgoto xmit_failure;\n\tnetdev_sent_queue(netdev, frame_len);\n\n\tpriv->tx_head++;\n\tpriv->tx_can_msg_cnt++;\n\n xmit_commit:\n\tif (!es58x_xmit_more(priv)) {\n\t\tret = es58x_xmit_commit(netdev);\n\t\tif (ret)\n\t\t\tgoto xmit_failure;\n\t}\n\n\treturn NETDEV_TX_OK;\n\n drop_skb:\n\tdev_kfree_skb(skb);\n\tnetdev->stats.tx_dropped++;\n xmit_failure:\n\tnetdev_warn(netdev, \"%s: send message failure: %pe\\n\",\n\t\t    __func__, ERR_PTR(ret));\n\tnetdev->stats.tx_errors++;\n\tes58x_flush_pending_tx_msg(netdev);\n\treturn NETDEV_TX_OK;\n}\n\nstatic const struct net_device_ops es58x_netdev_ops = {\n\t.ndo_open = es58x_open,\n\t.ndo_stop = es58x_stop,\n\t.ndo_start_xmit = es58x_start_xmit,\n\t.ndo_eth_ioctl = can_eth_ioctl_hwts,\n};\n\nstatic const struct ethtool_ops es58x_ethtool_ops = {\n\t.get_ts_info = can_ethtool_op_get_ts_info_hwts,\n};\n\n \nstatic int es58x_set_mode(struct net_device *netdev, enum can_mode mode)\n{\n\tstruct es58x_priv *priv = es58x_priv(netdev);\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\tswitch (priv->can.state) {\n\t\tcase CAN_STATE_BUS_OFF:\n\t\t\treturn priv->es58x_dev->ops->enable_channel(priv);\n\n\t\tcase CAN_STATE_STOPPED:\n\t\t\treturn es58x_open(netdev);\n\n\t\tcase CAN_STATE_ERROR_ACTIVE:\n\t\tcase CAN_STATE_ERROR_WARNING:\n\t\tcase CAN_STATE_ERROR_PASSIVE:\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\n\tcase CAN_MODE_STOP:\n\t\tswitch (priv->can.state) {\n\t\tcase CAN_STATE_STOPPED:\n\t\t\treturn 0;\n\n\t\tcase CAN_STATE_ERROR_ACTIVE:\n\t\tcase CAN_STATE_ERROR_WARNING:\n\t\tcase CAN_STATE_ERROR_PASSIVE:\n\t\tcase CAN_STATE_BUS_OFF:\n\t\tdefault:\n\t\t\treturn priv->es58x_dev->ops->disable_channel(priv);\n\t\t}\n\n\tcase CAN_MODE_SLEEP:\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n \nstatic int es58x_init_priv(struct es58x_device *es58x_dev,\n\t\t\t   struct es58x_priv *priv, int channel_idx)\n{\n\tstruct devlink_port_attrs attrs = {\n\t\t.flavour = DEVLINK_PORT_FLAVOUR_PHYSICAL,\n\t};\n\tconst struct es58x_parameters *param = es58x_dev->param;\n\tstruct can_priv *can = &priv->can;\n\n\tpriv->es58x_dev = es58x_dev;\n\tpriv->channel_idx = channel_idx;\n\tpriv->tx_urb = NULL;\n\tpriv->tx_can_msg_cnt = 0;\n\n\tcan->bittiming_const = param->bittiming_const;\n\tif (param->ctrlmode_supported & CAN_CTRLMODE_FD) {\n\t\tcan->data_bittiming_const = param->data_bittiming_const;\n\t\tcan->tdc_const = param->tdc_const;\n\t}\n\tcan->bitrate_max = param->bitrate_max;\n\tcan->clock = param->clock;\n\tcan->state = CAN_STATE_STOPPED;\n\tcan->ctrlmode_supported = param->ctrlmode_supported;\n\tcan->do_set_mode = es58x_set_mode;\n\n\tdevlink_port_attrs_set(&priv->devlink_port, &attrs);\n\treturn devlink_port_register(priv_to_devlink(es58x_dev),\n\t\t\t\t     &priv->devlink_port, channel_idx);\n}\n\n \nstatic int es58x_init_netdev(struct es58x_device *es58x_dev, int channel_idx)\n{\n\tstruct net_device *netdev;\n\tstruct device *dev = es58x_dev->dev;\n\tint ret;\n\n\tnetdev = alloc_candev(sizeof(struct es58x_priv),\n\t\t\t      es58x_dev->param->fifo_mask + 1);\n\tif (!netdev) {\n\t\tdev_err(dev, \"Could not allocate candev\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tSET_NETDEV_DEV(netdev, dev);\n\tes58x_dev->netdev[channel_idx] = netdev;\n\tret = es58x_init_priv(es58x_dev, es58x_priv(netdev), channel_idx);\n\tif (ret)\n\t\tgoto free_candev;\n\tSET_NETDEV_DEVLINK_PORT(netdev, &es58x_priv(netdev)->devlink_port);\n\n\tnetdev->netdev_ops = &es58x_netdev_ops;\n\tnetdev->ethtool_ops = &es58x_ethtool_ops;\n\tnetdev->flags |= IFF_ECHO;\t \n\tnetdev->dev_port = channel_idx;\n\n\tret = register_candev(netdev);\n\tif (ret)\n\t\tgoto devlink_port_unregister;\n\n\tnetdev_queue_set_dql_min_limit(netdev_get_tx_queue(netdev, 0),\n\t\t\t\t       es58x_dev->param->dql_min_limit);\n\n\treturn ret;\n\n devlink_port_unregister:\n\tdevlink_port_unregister(&es58x_priv(netdev)->devlink_port);\n free_candev:\n\tes58x_dev->netdev[channel_idx] = NULL;\n\tfree_candev(netdev);\n\treturn ret;\n}\n\n \nstatic void es58x_free_netdevs(struct es58x_device *es58x_dev)\n{\n\tint i;\n\n\tfor (i = 0; i < es58x_dev->num_can_ch; i++) {\n\t\tstruct net_device *netdev = es58x_dev->netdev[i];\n\n\t\tif (!netdev)\n\t\t\tcontinue;\n\t\tunregister_candev(netdev);\n\t\tdevlink_port_unregister(&es58x_priv(netdev)->devlink_port);\n\t\tes58x_dev->netdev[i] = NULL;\n\t\tfree_candev(netdev);\n\t}\n}\n\n \nstatic struct es58x_device *es58x_init_es58x_dev(struct usb_interface *intf,\n\t\t\t\t\t\t kernel_ulong_t driver_info)\n{\n\tstruct device *dev = &intf->dev;\n\tstruct es58x_device *es58x_dev;\n\tstruct devlink *devlink;\n\tconst struct es58x_parameters *param;\n\tconst struct es58x_operators *ops;\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_endpoint_descriptor *ep_in, *ep_out;\n\tint ret;\n\n\tdev_info(dev, \"Starting %s %s (Serial Number %s)\\n\",\n\t\t udev->manufacturer, udev->product, udev->serial);\n\n\tret = usb_find_common_endpoints(intf->cur_altsetting, &ep_in, &ep_out,\n\t\t\t\t\tNULL, NULL);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (driver_info & ES58X_FD_FAMILY) {\n\t\tparam = &es58x_fd_param;\n\t\tops = &es58x_fd_ops;\n\t} else {\n\t\tparam = &es581_4_param;\n\t\tops = &es581_4_ops;\n\t}\n\n\tdevlink = devlink_alloc(&es58x_dl_ops, es58x_sizeof_es58x_device(param),\n\t\t\t\tdev);\n\tif (!devlink)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tes58x_dev = devlink_priv(devlink);\n\tes58x_dev->param = param;\n\tes58x_dev->ops = ops;\n\tes58x_dev->dev = dev;\n\tes58x_dev->udev = udev;\n\n\tif (driver_info & ES58X_DUAL_CHANNEL)\n\t\tes58x_dev->num_can_ch = 2;\n\telse\n\t\tes58x_dev->num_can_ch = 1;\n\n\tinit_usb_anchor(&es58x_dev->rx_urbs);\n\tinit_usb_anchor(&es58x_dev->tx_urbs_idle);\n\tinit_usb_anchor(&es58x_dev->tx_urbs_busy);\n\tatomic_set(&es58x_dev->tx_urbs_idle_cnt, 0);\n\tusb_set_intfdata(intf, es58x_dev);\n\n\tes58x_dev->rx_pipe = usb_rcvbulkpipe(es58x_dev->udev,\n\t\t\t\t\t     ep_in->bEndpointAddress);\n\tes58x_dev->tx_pipe = usb_sndbulkpipe(es58x_dev->udev,\n\t\t\t\t\t     ep_out->bEndpointAddress);\n\n\treturn es58x_dev;\n}\n\n \nstatic int es58x_probe(struct usb_interface *intf,\n\t\t       const struct usb_device_id *id)\n{\n\tstruct es58x_device *es58x_dev;\n\tint ch_idx;\n\n\tes58x_dev = es58x_init_es58x_dev(intf, id->driver_info);\n\tif (IS_ERR(es58x_dev))\n\t\treturn PTR_ERR(es58x_dev);\n\n\tes58x_parse_product_info(es58x_dev);\n\tdevlink_register(priv_to_devlink(es58x_dev));\n\n\tfor (ch_idx = 0; ch_idx < es58x_dev->num_can_ch; ch_idx++) {\n\t\tint ret = es58x_init_netdev(es58x_dev, ch_idx);\n\n\t\tif (ret) {\n\t\t\tes58x_free_netdevs(es58x_dev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void es58x_disconnect(struct usb_interface *intf)\n{\n\tstruct es58x_device *es58x_dev = usb_get_intfdata(intf);\n\n\tdev_info(&intf->dev, \"Disconnecting %s %s\\n\",\n\t\t es58x_dev->udev->manufacturer, es58x_dev->udev->product);\n\n\tdevlink_unregister(priv_to_devlink(es58x_dev));\n\tes58x_free_netdevs(es58x_dev);\n\tes58x_free_urbs(es58x_dev);\n\tdevlink_free(priv_to_devlink(es58x_dev));\n\tusb_set_intfdata(intf, NULL);\n}\n\nstatic struct usb_driver es58x_driver = {\n\t.name = KBUILD_MODNAME,\n\t.probe = es58x_probe,\n\t.disconnect = es58x_disconnect,\n\t.id_table = es58x_id_table\n};\n\nmodule_usb_driver(es58x_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}