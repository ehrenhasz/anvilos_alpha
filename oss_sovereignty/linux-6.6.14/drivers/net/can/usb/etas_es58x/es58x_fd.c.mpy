{
  "module_name": "es58x_fd.c",
  "hash_id": "c6104fc2188c4b4374419acc1acabde002aabfdb4709fb6590418c44e1f0407f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/usb/etas_es58x/es58x_fd.c",
  "human_readable_source": "\n\n \n\n#include <asm/unaligned.h>\n#include <linux/kernel.h>\n#include <linux/units.h>\n\n#include \"es58x_core.h\"\n#include \"es58x_fd.h\"\n\n \n#define es58x_fd_sizeof_rx_tx_msg(msg)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\ttypeof(msg) __msg = (msg);\t\t\t\t\t\\\n\tsize_t __msg_len;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (__msg.flags & ES58X_FLAG_FD_DATA)\t\t\t\t\\\n\t\t__msg_len = canfd_sanitize_len(__msg.len);\t\t\\\n\telse\t\t\t\t\t\t\t\t\\\n\t\t__msg_len = can_cc_dlc2len(__msg.dlc);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\toffsetof(typeof(__msg), data[__msg_len]);\t\t\t\\\n})\n\nstatic enum es58x_fd_cmd_type es58x_fd_cmd_type(struct net_device *netdev)\n{\n\tu32 ctrlmode = es58x_priv(netdev)->can.ctrlmode;\n\n\tif (ctrlmode & (CAN_CTRLMODE_FD | CAN_CTRLMODE_FD_NON_ISO))\n\t\treturn ES58X_FD_CMD_TYPE_CANFD;\n\telse\n\t\treturn ES58X_FD_CMD_TYPE_CAN;\n}\n\nstatic u16 es58x_fd_get_msg_len(const union es58x_urb_cmd *urb_cmd)\n{\n\treturn get_unaligned_le16(&urb_cmd->es58x_fd_urb_cmd.msg_len);\n}\n\nstatic int es58x_fd_echo_msg(struct net_device *netdev,\n\t\t\t     const struct es58x_fd_urb_cmd *es58x_fd_urb_cmd)\n{\n\tstruct es58x_priv *priv = es58x_priv(netdev);\n\tconst struct es58x_fd_echo_msg *echo_msg;\n\tstruct es58x_device *es58x_dev = priv->es58x_dev;\n\tu64 *tstamps = es58x_dev->timestamps;\n\tu16 msg_len = get_unaligned_le16(&es58x_fd_urb_cmd->msg_len);\n\tint i, num_element;\n\tu32 rcv_packet_idx;\n\n\tconst u32 mask = GENMASK(BITS_PER_TYPE(mask) - 1,\n\t\t\t\t BITS_PER_TYPE(echo_msg->packet_idx));\n\n\tnum_element = es58x_msg_num_element(es58x_dev->dev,\n\t\t\t\t\t    es58x_fd_urb_cmd->echo_msg,\n\t\t\t\t\t    msg_len);\n\tif (num_element < 0)\n\t\treturn num_element;\n\techo_msg = es58x_fd_urb_cmd->echo_msg;\n\n\trcv_packet_idx = (priv->tx_tail & mask) | echo_msg[0].packet_idx;\n\tfor (i = 0; i < num_element; i++) {\n\t\tif ((u8)rcv_packet_idx != echo_msg[i].packet_idx) {\n\t\t\tnetdev_err(netdev, \"Packet idx jumped from %u to %u\\n\",\n\t\t\t\t   (u8)rcv_packet_idx - 1,\n\t\t\t\t   echo_msg[i].packet_idx);\n\t\t\treturn -EBADMSG;\n\t\t}\n\n\t\ttstamps[i] = get_unaligned_le64(&echo_msg[i].timestamp);\n\t\trcv_packet_idx++;\n\t}\n\n\treturn es58x_can_get_echo_skb(netdev, priv->tx_tail, tstamps, num_element);\n}\n\nstatic int es58x_fd_rx_can_msg(struct net_device *netdev,\n\t\t\t       const struct es58x_fd_urb_cmd *es58x_fd_urb_cmd)\n{\n\tstruct es58x_device *es58x_dev = es58x_priv(netdev)->es58x_dev;\n\tconst u8 *rx_can_msg_buf = es58x_fd_urb_cmd->rx_can_msg_buf;\n\tu16 rx_can_msg_buf_len = get_unaligned_le16(&es58x_fd_urb_cmd->msg_len);\n\tint pkts, ret;\n\n\tret = es58x_check_msg_max_len(es58x_dev->dev,\n\t\t\t\t      es58x_fd_urb_cmd->rx_can_msg_buf,\n\t\t\t\t      rx_can_msg_buf_len);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (pkts = 0; rx_can_msg_buf_len > 0; pkts++) {\n\t\tconst struct es58x_fd_rx_can_msg *rx_can_msg =\n\t\t    (const struct es58x_fd_rx_can_msg *)rx_can_msg_buf;\n\t\tbool is_can_fd = !!(rx_can_msg->flags & ES58X_FLAG_FD_DATA);\n\t\t \n\t\tu16 rx_can_msg_len = es58x_fd_sizeof_rx_tx_msg(*rx_can_msg);\n\n\t\tif (rx_can_msg_len > rx_can_msg_buf_len) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"%s: Expected a rx_can_msg of size %d but only %d bytes are left in rx_can_msg_buf\\n\",\n\t\t\t\t   __func__,\n\t\t\t\t   rx_can_msg_len, rx_can_msg_buf_len);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t\tif (rx_can_msg->len > CANFD_MAX_DLEN) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"%s: Data length is %d but maximum should be %d\\n\",\n\t\t\t\t   __func__, rx_can_msg->len, CANFD_MAX_DLEN);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\n\t\tif (netif_running(netdev)) {\n\t\t\tu64 tstamp = get_unaligned_le64(&rx_can_msg->timestamp);\n\t\t\tcanid_t can_id = get_unaligned_le32(&rx_can_msg->can_id);\n\t\t\tu8 dlc;\n\n\t\t\tif (is_can_fd)\n\t\t\t\tdlc = can_fd_len2dlc(rx_can_msg->len);\n\t\t\telse\n\t\t\t\tdlc = rx_can_msg->dlc;\n\n\t\t\tret = es58x_rx_can_msg(netdev, tstamp, rx_can_msg->data,\n\t\t\t\t\t       can_id, rx_can_msg->flags, dlc);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\trx_can_msg_buf_len -= rx_can_msg_len;\n\t\trx_can_msg_buf += rx_can_msg_len;\n\t}\n\n\tif (!netif_running(netdev)) {\n\t\tif (net_ratelimit())\n\t\t\tnetdev_info(netdev,\n\t\t\t\t    \"%s: %s is down, dropping %d rx packets\\n\",\n\t\t\t\t    __func__, netdev->name, pkts);\n\t\tnetdev->stats.rx_dropped += pkts;\n\t}\n\n\treturn ret;\n}\n\nstatic int es58x_fd_rx_event_msg(struct net_device *netdev,\n\t\t\t\t const struct es58x_fd_urb_cmd *es58x_fd_urb_cmd)\n{\n\tstruct es58x_device *es58x_dev = es58x_priv(netdev)->es58x_dev;\n\tu16 msg_len = get_unaligned_le16(&es58x_fd_urb_cmd->msg_len);\n\tconst struct es58x_fd_rx_event_msg *rx_event_msg;\n\tint ret;\n\n\trx_event_msg = &es58x_fd_urb_cmd->rx_event_msg;\n\tret = es58x_check_msg_len(es58x_dev->dev, *rx_event_msg, msg_len);\n\tif (ret)\n\t\treturn ret;\n\n\treturn es58x_rx_err_msg(netdev, rx_event_msg->error_code,\n\t\t\t\trx_event_msg->event_code,\n\t\t\t\tget_unaligned_le64(&rx_event_msg->timestamp));\n}\n\nstatic int es58x_fd_rx_cmd_ret_u32(struct net_device *netdev,\n\t\t\t\t   const struct es58x_fd_urb_cmd *es58x_fd_urb_cmd,\n\t\t\t\t   enum es58x_ret_type cmd_ret_type)\n{\n\tstruct es58x_device *es58x_dev = es58x_priv(netdev)->es58x_dev;\n\tu16 msg_len = get_unaligned_le16(&es58x_fd_urb_cmd->msg_len);\n\tint ret;\n\n\tret = es58x_check_msg_len(es58x_dev->dev,\n\t\t\t\t  es58x_fd_urb_cmd->rx_cmd_ret_le32, msg_len);\n\tif (ret)\n\t\treturn ret;\n\n\treturn es58x_rx_cmd_ret_u32(netdev, cmd_ret_type,\n\t\t\t\t    get_unaligned_le32(&es58x_fd_urb_cmd->rx_cmd_ret_le32));\n}\n\nstatic int es58x_fd_tx_ack_msg(struct net_device *netdev,\n\t\t\t       const struct es58x_fd_urb_cmd *es58x_fd_urb_cmd)\n{\n\tstruct es58x_device *es58x_dev = es58x_priv(netdev)->es58x_dev;\n\tconst struct es58x_fd_tx_ack_msg *tx_ack_msg;\n\tu16 msg_len = get_unaligned_le16(&es58x_fd_urb_cmd->msg_len);\n\tint ret;\n\n\ttx_ack_msg = &es58x_fd_urb_cmd->tx_ack_msg;\n\tret = es58x_check_msg_len(es58x_dev->dev, *tx_ack_msg, msg_len);\n\tif (ret)\n\t\treturn ret;\n\n\treturn es58x_tx_ack_msg(netdev,\n\t\t\t\tget_unaligned_le16(&tx_ack_msg->tx_free_entries),\n\t\t\t\tget_unaligned_le32(&tx_ack_msg->rx_cmd_ret_le32));\n}\n\nstatic int es58x_fd_can_cmd_id(struct es58x_device *es58x_dev,\n\t\t\t       const struct es58x_fd_urb_cmd *es58x_fd_urb_cmd)\n{\n\tstruct net_device *netdev;\n\tint ret;\n\n\tret = es58x_get_netdev(es58x_dev, es58x_fd_urb_cmd->channel_idx,\n\t\t\t       ES58X_FD_CHANNEL_IDX_OFFSET, &netdev);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch ((enum es58x_fd_can_cmd_id)es58x_fd_urb_cmd->cmd_id) {\n\tcase ES58X_FD_CAN_CMD_ID_ENABLE_CHANNEL:\n\t\treturn es58x_fd_rx_cmd_ret_u32(netdev, es58x_fd_urb_cmd,\n\t\t\t\t\t       ES58X_RET_TYPE_ENABLE_CHANNEL);\n\n\tcase ES58X_FD_CAN_CMD_ID_DISABLE_CHANNEL:\n\t\treturn es58x_fd_rx_cmd_ret_u32(netdev, es58x_fd_urb_cmd,\n\t\t\t\t\t       ES58X_RET_TYPE_DISABLE_CHANNEL);\n\n\tcase ES58X_FD_CAN_CMD_ID_TX_MSG:\n\t\treturn es58x_fd_tx_ack_msg(netdev, es58x_fd_urb_cmd);\n\n\tcase ES58X_FD_CAN_CMD_ID_ECHO_MSG:\n\t\treturn es58x_fd_echo_msg(netdev, es58x_fd_urb_cmd);\n\n\tcase ES58X_FD_CAN_CMD_ID_RX_MSG:\n\t\treturn es58x_fd_rx_can_msg(netdev, es58x_fd_urb_cmd);\n\n\tcase ES58X_FD_CAN_CMD_ID_RESET_RX:\n\t\treturn es58x_fd_rx_cmd_ret_u32(netdev, es58x_fd_urb_cmd,\n\t\t\t\t\t       ES58X_RET_TYPE_RESET_RX);\n\n\tcase ES58X_FD_CAN_CMD_ID_RESET_TX:\n\t\treturn es58x_fd_rx_cmd_ret_u32(netdev, es58x_fd_urb_cmd,\n\t\t\t\t\t       ES58X_RET_TYPE_RESET_TX);\n\n\tcase ES58X_FD_CAN_CMD_ID_ERROR_OR_EVENT_MSG:\n\t\treturn es58x_fd_rx_event_msg(netdev, es58x_fd_urb_cmd);\n\n\tdefault:\n\t\treturn -EBADRQC;\n\t}\n}\n\nstatic int es58x_fd_device_cmd_id(struct es58x_device *es58x_dev,\n\t\t\t\t  const struct es58x_fd_urb_cmd *es58x_fd_urb_cmd)\n{\n\tu16 msg_len = get_unaligned_le16(&es58x_fd_urb_cmd->msg_len);\n\tint ret;\n\n\tswitch ((enum es58x_fd_dev_cmd_id)es58x_fd_urb_cmd->cmd_id) {\n\tcase ES58X_FD_DEV_CMD_ID_TIMESTAMP:\n\t\tret = es58x_check_msg_len(es58x_dev->dev,\n\t\t\t\t\t  es58x_fd_urb_cmd->timestamp, msg_len);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tes58x_rx_timestamp(es58x_dev,\n\t\t\t\t   get_unaligned_le64(&es58x_fd_urb_cmd->timestamp));\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EBADRQC;\n\t}\n}\n\nstatic int es58x_fd_handle_urb_cmd(struct es58x_device *es58x_dev,\n\t\t\t\t   const union es58x_urb_cmd *urb_cmd)\n{\n\tconst struct es58x_fd_urb_cmd *es58x_fd_urb_cmd;\n\tint ret;\n\n\tes58x_fd_urb_cmd = &urb_cmd->es58x_fd_urb_cmd;\n\n\tswitch ((enum es58x_fd_cmd_type)es58x_fd_urb_cmd->cmd_type) {\n\tcase ES58X_FD_CMD_TYPE_CAN:\n\tcase ES58X_FD_CMD_TYPE_CANFD:\n\t\tret = es58x_fd_can_cmd_id(es58x_dev, es58x_fd_urb_cmd);\n\t\tbreak;\n\n\tcase ES58X_FD_CMD_TYPE_DEVICE:\n\t\tret = es58x_fd_device_cmd_id(es58x_dev, es58x_fd_urb_cmd);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EBADRQC;\n\t\tbreak;\n\t}\n\n\tif (ret == -EBADRQC)\n\t\tdev_err(es58x_dev->dev,\n\t\t\t\"%s: Unknown command type (0x%02X) and command ID (0x%02X) combination\\n\",\n\t\t\t__func__, es58x_fd_urb_cmd->cmd_type,\n\t\t\tes58x_fd_urb_cmd->cmd_id);\n\n\treturn ret;\n}\n\nstatic void es58x_fd_fill_urb_header(union es58x_urb_cmd *urb_cmd, u8 cmd_type,\n\t\t\t\t     u8 cmd_id, u8 channel_idx, u16 msg_len)\n{\n\tstruct es58x_fd_urb_cmd *es58x_fd_urb_cmd = &urb_cmd->es58x_fd_urb_cmd;\n\n\tes58x_fd_urb_cmd->SOF = cpu_to_le16(es58x_fd_param.tx_start_of_frame);\n\tes58x_fd_urb_cmd->cmd_type = cmd_type;\n\tes58x_fd_urb_cmd->cmd_id = cmd_id;\n\tes58x_fd_urb_cmd->channel_idx = channel_idx;\n\tes58x_fd_urb_cmd->msg_len = cpu_to_le16(msg_len);\n}\n\nstatic int es58x_fd_tx_can_msg(struct es58x_priv *priv,\n\t\t\t       const struct sk_buff *skb)\n{\n\tstruct es58x_device *es58x_dev = priv->es58x_dev;\n\tunion es58x_urb_cmd *urb_cmd = priv->tx_urb->transfer_buffer;\n\tstruct es58x_fd_urb_cmd *es58x_fd_urb_cmd = &urb_cmd->es58x_fd_urb_cmd;\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct es58x_fd_tx_can_msg *tx_can_msg;\n\tbool is_fd = can_is_canfd_skb(skb);\n\tu16 msg_len;\n\tint ret;\n\n\tif (priv->tx_can_msg_cnt == 0) {\n\t\tmsg_len = 0;\n\t\tes58x_fd_fill_urb_header(urb_cmd,\n\t\t\t\t\t is_fd ? ES58X_FD_CMD_TYPE_CANFD\n\t\t\t\t\t       : ES58X_FD_CMD_TYPE_CAN,\n\t\t\t\t\t ES58X_FD_CAN_CMD_ID_TX_MSG_NO_ACK,\n\t\t\t\t\t priv->channel_idx, msg_len);\n\t} else {\n\t\tmsg_len = es58x_fd_get_msg_len(urb_cmd);\n\t}\n\n\tret = es58x_check_msg_max_len(es58x_dev->dev,\n\t\t\t\t      es58x_fd_urb_cmd->tx_can_msg_buf,\n\t\t\t\t      msg_len + sizeof(*tx_can_msg));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\ttx_can_msg = (typeof(tx_can_msg))&es58x_fd_urb_cmd->raw_msg[msg_len];\n\ttx_can_msg->packet_idx = (u8)priv->tx_head;\n\tput_unaligned_le32(es58x_get_raw_can_id(cf), &tx_can_msg->can_id);\n\ttx_can_msg->flags = (u8)es58x_get_flags(skb);\n\tif (is_fd)\n\t\ttx_can_msg->len = cf->len;\n\telse\n\t\ttx_can_msg->dlc = can_get_cc_dlc(cf, priv->can.ctrlmode);\n\tmemcpy(tx_can_msg->data, cf->data, cf->len);\n\n\t \n\tmsg_len += es58x_fd_sizeof_rx_tx_msg(*tx_can_msg);\n\tpriv->tx_urb->transfer_buffer_length = es58x_get_urb_cmd_len(es58x_dev,\n\t\t\t\t\t\t\t\t     msg_len);\n\tput_unaligned_le16(msg_len, &es58x_fd_urb_cmd->msg_len);\n\n\treturn 0;\n}\n\nstatic void es58x_fd_convert_bittiming(struct es58x_fd_bittiming *es58x_fd_bt,\n\t\t\t\t       struct can_bittiming *bt)\n{\n\t \n\tconst int offset = 1;\n\n\tes58x_fd_bt->bitrate = cpu_to_le32(bt->bitrate);\n\tes58x_fd_bt->tseg1 =\n\t    cpu_to_le16(bt->prop_seg + bt->phase_seg1 - offset);\n\tes58x_fd_bt->tseg2 = cpu_to_le16(bt->phase_seg2 - offset);\n\tes58x_fd_bt->brp = cpu_to_le16(bt->brp - offset);\n\tes58x_fd_bt->sjw = cpu_to_le16(bt->sjw - offset);\n}\n\nstatic int es58x_fd_enable_channel(struct es58x_priv *priv)\n{\n\tstruct es58x_device *es58x_dev = priv->es58x_dev;\n\tstruct net_device *netdev = es58x_dev->netdev[priv->channel_idx];\n\tstruct es58x_fd_tx_conf_msg tx_conf_msg = { 0 };\n\tu32 ctrlmode;\n\tsize_t conf_len = 0;\n\n\tes58x_fd_convert_bittiming(&tx_conf_msg.nominal_bittiming,\n\t\t\t\t   &priv->can.bittiming);\n\tctrlmode = priv->can.ctrlmode;\n\n\tif (ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\ttx_conf_msg.samples_per_bit = ES58X_SAMPLES_PER_BIT_THREE;\n\telse\n\t\ttx_conf_msg.samples_per_bit = ES58X_SAMPLES_PER_BIT_ONE;\n\ttx_conf_msg.sync_edge = ES58X_SYNC_EDGE_SINGLE;\n\ttx_conf_msg.physical_layer = ES58X_PHYSICAL_LAYER_HIGH_SPEED;\n\ttx_conf_msg.echo_mode = ES58X_ECHO_ON;\n\tif (ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\ttx_conf_msg.ctrlmode |= ES58X_FD_CTRLMODE_PASSIVE;\n\telse\n\t\ttx_conf_msg.ctrlmode |=  ES58X_FD_CTRLMODE_ACTIVE;\n\n\tif (ctrlmode & CAN_CTRLMODE_FD_NON_ISO) {\n\t\ttx_conf_msg.ctrlmode |= ES58X_FD_CTRLMODE_FD_NON_ISO;\n\t\ttx_conf_msg.canfd_enabled = 1;\n\t} else if (ctrlmode & CAN_CTRLMODE_FD) {\n\t\ttx_conf_msg.ctrlmode |= ES58X_FD_CTRLMODE_FD;\n\t\ttx_conf_msg.canfd_enabled = 1;\n\t}\n\n\tif (tx_conf_msg.canfd_enabled) {\n\t\tes58x_fd_convert_bittiming(&tx_conf_msg.data_bittiming,\n\t\t\t\t\t   &priv->can.data_bittiming);\n\n\t\tif (can_tdc_is_enabled(&priv->can)) {\n\t\t\ttx_conf_msg.tdc_enabled = 1;\n\t\t\ttx_conf_msg.tdco = cpu_to_le16(priv->can.tdc.tdco);\n\t\t\ttx_conf_msg.tdcf = cpu_to_le16(priv->can.tdc.tdcf);\n\t\t}\n\n\t\tconf_len = ES58X_FD_CANFD_CONF_LEN;\n\t} else {\n\t\tconf_len = ES58X_FD_CAN_CONF_LEN;\n\t}\n\n\treturn es58x_send_msg(es58x_dev, es58x_fd_cmd_type(netdev),\n\t\t\t      ES58X_FD_CAN_CMD_ID_ENABLE_CHANNEL,\n\t\t\t      &tx_conf_msg, conf_len, priv->channel_idx);\n}\n\nstatic int es58x_fd_disable_channel(struct es58x_priv *priv)\n{\n\t \n\treturn es58x_send_msg(priv->es58x_dev, ES58X_FD_CMD_TYPE_CAN,\n\t\t\t      ES58X_FD_CAN_CMD_ID_DISABLE_CHANNEL,\n\t\t\t      ES58X_EMPTY_MSG, 0, priv->channel_idx);\n}\n\nstatic int es58x_fd_get_timestamp(struct es58x_device *es58x_dev)\n{\n\treturn es58x_send_msg(es58x_dev, ES58X_FD_CMD_TYPE_DEVICE,\n\t\t\t      ES58X_FD_DEV_CMD_ID_TIMESTAMP, ES58X_EMPTY_MSG,\n\t\t\t      0, ES58X_CHANNEL_IDX_NA);\n}\n\n \nstatic const struct can_bittiming_const es58x_fd_nom_bittiming_const = {\n\t.name = \"ES582.1/ES584.1\",\n\t.tseg1_min = 2,\n\t.tseg1_max = 256,\n\t.tseg2_min = 2,\n\t.tseg2_max = 128,\n\t.sjw_max = 128,\n\t.brp_min = 1,\n\t.brp_max = 512,\n\t.brp_inc = 1\n};\n\n \nstatic const struct can_bittiming_const es58x_fd_data_bittiming_const = {\n\t.name = \"ES582.1/ES584.1\",\n\t.tseg1_min = 2,\n\t.tseg1_max = 32,\n\t.tseg2_min = 1,\n\t.tseg2_max = 16,\n\t.sjw_max = 8,\n\t.brp_min = 1,\n\t.brp_max = 32,\n\t.brp_inc = 1\n};\n\n \nstatic const struct can_tdc_const es58x_tdc_const = {\n\t.tdcv_min = 0,\n\t.tdcv_max = 0,  \n\t.tdco_min = 0,\n\t.tdco_max = 127,\n\t.tdcf_min = 0,\n\t.tdcf_max = 127\n};\n\nconst struct es58x_parameters es58x_fd_param = {\n\t.bittiming_const = &es58x_fd_nom_bittiming_const,\n\t.data_bittiming_const = &es58x_fd_data_bittiming_const,\n\t.tdc_const = &es58x_tdc_const,\n\t \n\t.bitrate_max = 8 * MEGA  ,\n\t.clock = {.freq = 80 * MEGA  },\n\t.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK | CAN_CTRLMODE_LISTENONLY |\n\t    CAN_CTRLMODE_3_SAMPLES | CAN_CTRLMODE_FD | CAN_CTRLMODE_FD_NON_ISO |\n\t    CAN_CTRLMODE_CC_LEN8_DLC | CAN_CTRLMODE_TDC_AUTO,\n\t.tx_start_of_frame = 0xCEFA,\t \n\t.rx_start_of_frame = 0xFECA,\t \n\t.tx_urb_cmd_max_len = ES58X_FD_TX_URB_CMD_MAX_LEN,\n\t.rx_urb_cmd_max_len = ES58X_FD_RX_URB_CMD_MAX_LEN,\n\t \n\t.fifo_mask = 255,  \n\t.dql_min_limit = CAN_FRAME_LEN_MAX * 15,  \n\t.tx_bulk_max = ES58X_FD_TX_BULK_MAX,\n\t.urb_cmd_header_len = ES58X_FD_URB_CMD_HEADER_LEN,\n\t.rx_urb_max = ES58X_RX_URBS_MAX,\n\t.tx_urb_max = ES58X_TX_URBS_MAX\n};\n\nconst struct es58x_operators es58x_fd_ops = {\n\t.get_msg_len = es58x_fd_get_msg_len,\n\t.handle_urb_cmd = es58x_fd_handle_urb_cmd,\n\t.fill_urb_header = es58x_fd_fill_urb_header,\n\t.tx_can_msg = es58x_fd_tx_can_msg,\n\t.enable_channel = es58x_fd_enable_channel,\n\t.disable_channel = es58x_fd_disable_channel,\n\t.reset_device = NULL,  \n\t.get_timestamp = es58x_fd_get_timestamp\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}