{
  "module_name": "ucan.c",
  "hash_id": "532bb86252fa122c1be75bbf07cdbd253891e01314be6476100b61012e80e17e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/usb/ucan.c",
  "human_readable_source": "\n\n \n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n#include <linux/ethtool.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/signal.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n\n#define UCAN_DRIVER_NAME \"ucan\"\n#define UCAN_MAX_RX_URBS 8\n \n#define UCAN_USB_CTL_PIPE_TIMEOUT 1000\n \n#define UCAN_PROTOCOL_VERSION_MIN 3\n#define UCAN_PROTOCOL_VERSION_MAX 3\n\n \n\n \nenum {\n\tUCAN_DEVICE_GET_FW_STRING = 0,\n};\n\n \nenum {\n\t \n\tUCAN_COMMAND_START = 0,\n\t \n\tUCAN_COMMAND_STOP = 1,\n\t \n\tUCAN_COMMAND_SLEEP = 2,\n\t \n\tUCAN_COMMAND_WAKEUP = 3,\n\t \n\tUCAN_COMMAND_RESET = 4,\n\t \n\tUCAN_COMMAND_GET = 5,\n\t \n\tUCAN_COMMAND_FILTER = 6,\n\t \n\tUCAN_COMMAND_SET_BITTIMING = 7,\n\t \n\tUCAN_COMMAND_RESTART = 8,\n};\n\n \nenum {\n\tUCAN_MODE_LOOPBACK = BIT(0),\n\tUCAN_MODE_SILENT = BIT(1),\n\tUCAN_MODE_3_SAMPLES = BIT(2),\n\tUCAN_MODE_ONE_SHOT = BIT(3),\n\tUCAN_MODE_BERR_REPORT = BIT(4),\n};\n\n \nenum {\n\tUCAN_COMMAND_GET_INFO = 0,\n\tUCAN_COMMAND_GET_PROTOCOL_VERSION = 1,\n};\n\n \nenum {\n\tUCAN_FILTER_CLEAR = 0,\n\tUCAN_FILTER_DISABLE = 1,\n\tUCAN_FILTER_ENABLE = 2,\n};\n\n \nenum {\n\tUCAN_OUT_TX = 2,      \n};\n\n \nenum {\n\tUCAN_IN_TX_COMPLETE = 1,   \n\tUCAN_IN_RX = 2,            \n};\n\nstruct ucan_ctl_cmd_start {\n\t__le16 mode;          \n} __packed;\n\nstruct ucan_ctl_cmd_set_bittiming {\n\t__le32 tq;            \n\t__le16 brp;           \n\t__le16 sample_point;  \n\tu8 prop_seg;          \n\tu8 phase_seg1;        \n\tu8 phase_seg2;        \n\tu8 sjw;               \n} __packed;\n\nstruct ucan_ctl_cmd_device_info {\n\t__le32 freq;          \n\tu8 tx_fifo;           \n\tu8 sjw_max;           \n\tu8 tseg1_min;\n\tu8 tseg1_max;\n\tu8 tseg2_min;\n\tu8 tseg2_max;\n\t__le16 brp_inc;\n\t__le32 brp_min;\n\t__le32 brp_max;       \n\t__le16 ctrlmodes;     \n\t__le16 hwfilter;      \n\t__le16 rxmboxes;      \n} __packed;\n\nstruct ucan_ctl_cmd_get_protocol_version {\n\t__le32 version;\n} __packed;\n\nunion ucan_ctl_payload {\n\t \n\tstruct ucan_ctl_cmd_start cmd_start;\n\t \n\tstruct ucan_ctl_cmd_set_bittiming cmd_set_bittiming;\n\t \n\tstruct ucan_ctl_cmd_device_info cmd_get_device_info;\n\t \n\tstruct ucan_ctl_cmd_get_protocol_version cmd_get_protocol_version;\n\n\tu8 raw[128];\n} __packed;\n\nenum {\n\tUCAN_TX_COMPLETE_SUCCESS = BIT(0),\n};\n\n \nstruct ucan_tx_complete_entry_t {\n\tu8 echo_index;\n\tu8 flags;\n} __packed __aligned(0x2);\n\n \nstruct ucan_can_msg {\n\t \n\t__le32 id;\n\n\tunion {\n\t\tu8 data[CAN_MAX_DLEN];   \n\t\tu8 dlc;                  \n\t};\n} __packed;\n\n \nstruct ucan_message_out {\n\t__le16 len;  \n\tu8 type;     \n\tu8 subtype;  \n\n\tunion {\n\t\t \n\t\tstruct ucan_can_msg can_msg;\n\t} msg;\n} __packed __aligned(0x4);\n\n \nstruct ucan_message_in {\n\t__le16 len;  \n\tu8 type;     \n\tu8 subtype;  \n\n\tunion {\n\t\t \n\t\tstruct ucan_can_msg can_msg;\n\n\t\t \n\t\tDECLARE_FLEX_ARRAY(struct ucan_tx_complete_entry_t,\n\t\t\t\t   can_tx_complete_msg);\n\t} __aligned(0x4) msg;\n} __packed __aligned(0x4);\n\n \n#define UCAN_OUT_HDR_SIZE offsetof(struct ucan_message_out, msg)\n\n#define UCAN_IN_HDR_SIZE offsetof(struct ucan_message_in, msg)\n#define UCAN_IN_LEN(member) (UCAN_OUT_HDR_SIZE + sizeof(member))\n\nstruct ucan_priv;\n\n \nstruct ucan_urb_context {\n\tstruct ucan_priv *up;\n\tbool allocated;\n};\n\n \nstruct ucan_device_info {\n\tstruct can_bittiming_const bittiming_const;\n\tu8 tx_fifo;\n};\n\n \nstruct ucan_priv {\n\t \n\tstruct can_priv can;\n\n\t \n\tstruct usb_device *udev;\n\tstruct net_device *netdev;\n\n\t \n\tspinlock_t echo_skb_lock;\n\n\t \n\tu8 intf_index;\n\tu8 in_ep_addr;\n\tu8 out_ep_addr;\n\tu16 in_ep_size;\n\n\t \n\tstruct usb_anchor rx_urbs;\n\tstruct usb_anchor tx_urbs;\n\n\tunion ucan_ctl_payload *ctl_msg_buffer;\n\tstruct ucan_device_info device_info;\n\n\t \n\tspinlock_t context_lock;\n\tunsigned int available_tx_urbs;\n\tstruct ucan_urb_context *context_array;\n};\n\nstatic u8 ucan_can_cc_dlc2len(struct ucan_can_msg *msg, u16 len)\n{\n\tif (le32_to_cpu(msg->id) & CAN_RTR_FLAG)\n\t\treturn can_cc_dlc2len(msg->dlc);\n\telse\n\t\treturn can_cc_dlc2len(len - (UCAN_IN_HDR_SIZE + sizeof(msg->id)));\n}\n\nstatic void ucan_release_context_array(struct ucan_priv *up)\n{\n\tif (!up->context_array)\n\t\treturn;\n\n\t \n\tup->available_tx_urbs = 0;\n\n\tkfree(up->context_array);\n\tup->context_array = NULL;\n}\n\nstatic int ucan_alloc_context_array(struct ucan_priv *up)\n{\n\tint i;\n\n\t \n\tucan_release_context_array(up);\n\n\tup->context_array = kcalloc(up->device_info.tx_fifo,\n\t\t\t\t    sizeof(*up->context_array),\n\t\t\t\t    GFP_KERNEL);\n\tif (!up->context_array) {\n\t\tnetdev_err(up->netdev,\n\t\t\t   \"Not enough memory to allocate tx contexts\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < up->device_info.tx_fifo; i++) {\n\t\tup->context_array[i].allocated = false;\n\t\tup->context_array[i].up = up;\n\t}\n\n\t \n\tup->available_tx_urbs = up->device_info.tx_fifo;\n\n\treturn 0;\n}\n\nstatic struct ucan_urb_context *ucan_alloc_context(struct ucan_priv *up)\n{\n\tint i;\n\tunsigned long flags;\n\tstruct ucan_urb_context *ret = NULL;\n\n\tif (WARN_ON_ONCE(!up->context_array))\n\t\treturn NULL;\n\n\t \n\tspin_lock_irqsave(&up->context_lock, flags);\n\n\tfor (i = 0; i < up->device_info.tx_fifo; i++) {\n\t\tif (!up->context_array[i].allocated) {\n\t\t\t \n\t\t\tret = &up->context_array[i];\n\t\t\tup->context_array[i].allocated = true;\n\n\t\t\t \n\t\t\tup->available_tx_urbs--;\n\t\t\tif (!up->available_tx_urbs)\n\t\t\t\tnetif_stop_queue(up->netdev);\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&up->context_lock, flags);\n\treturn ret;\n}\n\nstatic bool ucan_release_context(struct ucan_priv *up,\n\t\t\t\t struct ucan_urb_context *ctx)\n{\n\tunsigned long flags;\n\tbool ret = false;\n\n\tif (WARN_ON_ONCE(!up->context_array))\n\t\treturn false;\n\n\t \n\tspin_lock_irqsave(&up->context_lock, flags);\n\n\t \n\tif (ctx->allocated) {\n\t\tctx->allocated = false;\n\n\t\t \n\t\tif (!up->available_tx_urbs)\n\t\t\tnetif_wake_queue(up->netdev);\n\t\tup->available_tx_urbs++;\n\n\t\tret = true;\n\t}\n\n\tspin_unlock_irqrestore(&up->context_lock, flags);\n\treturn ret;\n}\n\nstatic int ucan_ctrl_command_out(struct ucan_priv *up,\n\t\t\t\t u8 cmd, u16 subcmd, u16 datalen)\n{\n\treturn usb_control_msg(up->udev,\n\t\t\t       usb_sndctrlpipe(up->udev, 0),\n\t\t\t       cmd,\n\t\t\t       USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t\t\t\tUSB_RECIP_INTERFACE,\n\t\t\t       subcmd,\n\t\t\t       up->intf_index,\n\t\t\t       up->ctl_msg_buffer,\n\t\t\t       datalen,\n\t\t\t       UCAN_USB_CTL_PIPE_TIMEOUT);\n}\n\nstatic int ucan_device_request_in(struct ucan_priv *up,\n\t\t\t\t  u8 cmd, u16 subcmd, u16 datalen)\n{\n\treturn usb_control_msg(up->udev,\n\t\t\t       usb_rcvctrlpipe(up->udev, 0),\n\t\t\t       cmd,\n\t\t\t       USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t       subcmd,\n\t\t\t       0,\n\t\t\t       up->ctl_msg_buffer,\n\t\t\t       datalen,\n\t\t\t       UCAN_USB_CTL_PIPE_TIMEOUT);\n}\n\n \nstatic void ucan_parse_device_info(struct ucan_priv *up,\n\t\t\t\t   struct ucan_ctl_cmd_device_info *device_info)\n{\n\tstruct can_bittiming_const *bittiming =\n\t\t&up->device_info.bittiming_const;\n\tu16 ctrlmodes;\n\n\t \n\tup->can.clock.freq = le32_to_cpu(device_info->freq);\n\tup->device_info.tx_fifo = device_info->tx_fifo;\n\tstrcpy(bittiming->name, \"ucan\");\n\tbittiming->tseg1_min = device_info->tseg1_min;\n\tbittiming->tseg1_max = device_info->tseg1_max;\n\tbittiming->tseg2_min = device_info->tseg2_min;\n\tbittiming->tseg2_max = device_info->tseg2_max;\n\tbittiming->sjw_max = device_info->sjw_max;\n\tbittiming->brp_min = le32_to_cpu(device_info->brp_min);\n\tbittiming->brp_max = le32_to_cpu(device_info->brp_max);\n\tbittiming->brp_inc = le16_to_cpu(device_info->brp_inc);\n\n\tctrlmodes = le16_to_cpu(device_info->ctrlmodes);\n\n\tup->can.ctrlmode_supported = 0;\n\n\tif (ctrlmodes & UCAN_MODE_LOOPBACK)\n\t\tup->can.ctrlmode_supported |= CAN_CTRLMODE_LOOPBACK;\n\tif (ctrlmodes & UCAN_MODE_SILENT)\n\t\tup->can.ctrlmode_supported |= CAN_CTRLMODE_LISTENONLY;\n\tif (ctrlmodes & UCAN_MODE_3_SAMPLES)\n\t\tup->can.ctrlmode_supported |= CAN_CTRLMODE_3_SAMPLES;\n\tif (ctrlmodes & UCAN_MODE_ONE_SHOT)\n\t\tup->can.ctrlmode_supported |= CAN_CTRLMODE_ONE_SHOT;\n\tif (ctrlmodes & UCAN_MODE_BERR_REPORT)\n\t\tup->can.ctrlmode_supported |= CAN_CTRLMODE_BERR_REPORTING;\n}\n\n \nstatic bool ucan_handle_error_frame(struct ucan_priv *up,\n\t\t\t\t    struct ucan_message_in *m,\n\t\t\t\t    canid_t canid)\n{\n\tenum can_state new_state = up->can.state;\n\tstruct net_device_stats *net_stats = &up->netdev->stats;\n\tstruct can_device_stats *can_stats = &up->can.can_stats;\n\n\tif (canid & CAN_ERR_LOSTARB)\n\t\tcan_stats->arbitration_lost++;\n\n\tif (canid & CAN_ERR_BUSERROR)\n\t\tcan_stats->bus_error++;\n\n\tif (canid & CAN_ERR_ACK)\n\t\tnet_stats->tx_errors++;\n\n\tif (canid & CAN_ERR_BUSOFF)\n\t\tnew_state = CAN_STATE_BUS_OFF;\n\n\t \n\tif (canid & CAN_ERR_CRTL) {\n\t\tu8 d1 = m->msg.can_msg.data[1];\n\n\t\tif (d1 & CAN_ERR_CRTL_RX_OVERFLOW)\n\t\t\tnet_stats->rx_over_errors++;\n\n\t\t \n\t\tif (d1 & CAN_ERR_CRTL_ACTIVE)\n\t\t\tnew_state = CAN_STATE_ERROR_ACTIVE;\n\n\t\tif (d1 & (CAN_ERR_CRTL_RX_WARNING | CAN_ERR_CRTL_TX_WARNING))\n\t\t\tnew_state = CAN_STATE_ERROR_WARNING;\n\n\t\tif (d1 & (CAN_ERR_CRTL_RX_PASSIVE | CAN_ERR_CRTL_TX_PASSIVE))\n\t\t\tnew_state = CAN_STATE_ERROR_PASSIVE;\n\t}\n\n\t \n\tif (canid & CAN_ERR_PROT) {\n\t\tu8 d2 = m->msg.can_msg.data[2];\n\n\t\tif (d2 & CAN_ERR_PROT_TX)\n\t\t\tnet_stats->tx_errors++;\n\t\telse\n\t\t\tnet_stats->rx_errors++;\n\t}\n\n\t \n\tif (up->can.state == new_state)\n\t\treturn false;\n\n\t \n\tif (up->can.state > new_state) {\n\t\tup->can.state = new_state;\n\t\treturn true;\n\t}\n\n\t \n\tup->can.state = new_state;\n\tswitch (new_state) {\n\tcase CAN_STATE_BUS_OFF:\n\t\tcan_stats->bus_off++;\n\t\tcan_bus_off(up->netdev);\n\t\tbreak;\n\tcase CAN_STATE_ERROR_PASSIVE:\n\t\tcan_stats->error_passive++;\n\t\tbreak;\n\tcase CAN_STATE_ERROR_WARNING:\n\t\tcan_stats->error_warning++;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn true;\n}\n\n \nstatic void ucan_rx_can_msg(struct ucan_priv *up, struct ucan_message_in *m)\n{\n\tint len;\n\tcanid_t canid;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tstruct net_device_stats *stats = &up->netdev->stats;\n\n\t \n\tlen = le16_to_cpu(m->len);\n\n\t \n\tif (len < UCAN_IN_HDR_SIZE + sizeof(m->msg.can_msg.id)) {\n\t\tnetdev_warn(up->netdev, \"invalid input message len: %d\\n\", len);\n\t\treturn;\n\t}\n\n\t \n\tcanid = le32_to_cpu(m->msg.can_msg.id);\n\tif (canid & CAN_ERR_FLAG) {\n\t\tbool busstate_changed = ucan_handle_error_frame(up, m, canid);\n\n\t\t \n\t\tif (!(up->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING) &&\n\t\t    !busstate_changed)\n\t\t\treturn;\n\t} else {\n\t\tcanid_t canid_mask;\n\t\t \n\t\tcanid_mask = CAN_RTR_FLAG;\n\t\tif (canid & CAN_EFF_FLAG)\n\t\t\tcanid_mask |= CAN_EFF_MASK | CAN_EFF_FLAG;\n\t\telse\n\t\t\tcanid_mask |= CAN_SFF_MASK;\n\n\t\tif (canid & ~canid_mask)\n\t\t\tnetdev_warn(up->netdev,\n\t\t\t\t    \"unexpected bits set (canid %x, mask %x)\",\n\t\t\t\t    canid, canid_mask);\n\n\t\tcanid &= canid_mask;\n\t}\n\n\t \n\tskb = alloc_can_skb(up->netdev, &cf);\n\tif (!skb)\n\t\treturn;\n\n\t \n\tcf->can_id = canid;\n\n\t \n\tcf->len = ucan_can_cc_dlc2len(&m->msg.can_msg, len);\n\n\t \n\tif (!(cf->can_id & CAN_RTR_FLAG) || (cf->can_id & CAN_ERR_FLAG))\n\t\tmemcpy(cf->data, m->msg.can_msg.data, cf->len);\n\n\t \n\tif (!(cf->can_id & CAN_ERR_FLAG)) {\n\t\tstats->rx_packets++;\n\t\tif (!(cf->can_id & CAN_RTR_FLAG))\n\t\t\tstats->rx_bytes += cf->len;\n\t}\n\n\t \n\tnetif_rx(skb);\n}\n\n \nstatic void ucan_tx_complete_msg(struct ucan_priv *up,\n\t\t\t\t struct ucan_message_in *m)\n{\n\tunsigned long flags;\n\tu16 count, i;\n\tu8 echo_index;\n\tu16 len = le16_to_cpu(m->len);\n\n\tstruct ucan_urb_context *context;\n\n\tif (len < UCAN_IN_HDR_SIZE || (len % 2 != 0)) {\n\t\tnetdev_err(up->netdev, \"invalid tx complete length\\n\");\n\t\treturn;\n\t}\n\n\tcount = (len - UCAN_IN_HDR_SIZE) / 2;\n\tfor (i = 0; i < count; i++) {\n\t\t \n\t\techo_index = m->msg.can_tx_complete_msg[i].echo_index;\n\t\tif (echo_index >= up->device_info.tx_fifo) {\n\t\t\tup->netdev->stats.tx_errors++;\n\t\t\tnetdev_err(up->netdev,\n\t\t\t\t   \"invalid echo_index %d received\\n\",\n\t\t\t\t   echo_index);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tcontext = &up->context_array[echo_index];\n\n\t\t \n\t\tif (!ucan_release_context(up, context))\n\t\t\tcontinue;\n\n\t\tspin_lock_irqsave(&up->echo_skb_lock, flags);\n\t\tif (m->msg.can_tx_complete_msg[i].flags &\n\t\t    UCAN_TX_COMPLETE_SUCCESS) {\n\t\t\t \n\t\t\tup->netdev->stats.tx_packets++;\n\t\t\tup->netdev->stats.tx_bytes +=\n\t\t\t\tcan_get_echo_skb(up->netdev, echo_index, NULL);\n\t\t} else {\n\t\t\tup->netdev->stats.tx_dropped++;\n\t\t\tcan_free_echo_skb(up->netdev, echo_index, NULL);\n\t\t}\n\t\tspin_unlock_irqrestore(&up->echo_skb_lock, flags);\n\t}\n}\n\n \nstatic void ucan_read_bulk_callback(struct urb *urb)\n{\n\tint ret;\n\tint pos;\n\tstruct ucan_priv *up = urb->context;\n\tstruct net_device *netdev = up->netdev;\n\tstruct ucan_message_in *m;\n\n\t \n\tif (WARN_ON(!up->context_array)) {\n\t\tusb_free_coherent(up->udev,\n\t\t\t\t  up->in_ep_size,\n\t\t\t\t  urb->transfer_buffer,\n\t\t\t\t  urb->transfer_dma);\n\t\treturn;\n\t}\n\n\t \n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ENOENT:\n\tcase -EPIPE:\n\tcase -EPROTO:\n\tcase -ESHUTDOWN:\n\tcase -ETIME:\n\t\t \n\t\tusb_free_coherent(up->udev,\n\t\t\t\t  up->in_ep_size,\n\t\t\t\t  urb->transfer_buffer,\n\t\t\t\t  urb->transfer_dma);\n\t\tnetdev_dbg(up->netdev, \"not resubmitting urb; status: %d\\n\",\n\t\t\t   urb->status);\n\t\treturn;\n\tdefault:\n\t\tgoto resubmit;\n\t}\n\n\t \n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\t \n\tpos = 0;\n\twhile (pos < urb->actual_length) {\n\t\tint len;\n\n\t\t \n\t\tif ((urb->actual_length - pos) < UCAN_IN_HDR_SIZE) {\n\t\t\tnetdev_warn(up->netdev,\n\t\t\t\t    \"invalid message (short; no hdr; l:%d)\\n\",\n\t\t\t\t    urb->actual_length);\n\t\t\tgoto resubmit;\n\t\t}\n\n\t\t \n\t\tm = (struct ucan_message_in *)\n\t\t\t((u8 *)urb->transfer_buffer + pos);\n\t\tlen = le16_to_cpu(m->len);\n\n\t\t \n\t\tif (urb->actual_length - pos < len) {\n\t\t\tnetdev_warn(up->netdev,\n\t\t\t\t    \"invalid message (short; no data; l:%d)\\n\",\n\t\t\t\t    urb->actual_length);\n\t\t\tprint_hex_dump(KERN_WARNING,\n\t\t\t\t       \"raw data: \",\n\t\t\t\t       DUMP_PREFIX_ADDRESS,\n\t\t\t\t       16,\n\t\t\t\t       1,\n\t\t\t\t       urb->transfer_buffer,\n\t\t\t\t       urb->actual_length,\n\t\t\t\t       true);\n\n\t\t\tgoto resubmit;\n\t\t}\n\n\t\tswitch (m->type) {\n\t\tcase UCAN_IN_RX:\n\t\t\tucan_rx_can_msg(up, m);\n\t\t\tbreak;\n\t\tcase UCAN_IN_TX_COMPLETE:\n\t\t\tucan_tx_complete_msg(up, m);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetdev_warn(up->netdev,\n\t\t\t\t    \"invalid message (type; t:%d)\\n\",\n\t\t\t\t    m->type);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tpos += len;\n\t\t \n\t\tpos = round_up(pos, 4);\n\t}\n\nresubmit:\n\t \n\tusb_fill_bulk_urb(urb, up->udev,\n\t\t\t  usb_rcvbulkpipe(up->udev,\n\t\t\t\t\t  up->in_ep_addr),\n\t\t\t  urb->transfer_buffer,\n\t\t\t  up->in_ep_size,\n\t\t\t  ucan_read_bulk_callback,\n\t\t\t  up);\n\n\tusb_anchor_urb(urb, &up->rx_urbs);\n\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\n\tif (ret < 0) {\n\t\tnetdev_err(up->netdev,\n\t\t\t   \"failed resubmitting read bulk urb: %d\\n\",\n\t\t\t   ret);\n\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_coherent(up->udev,\n\t\t\t\t  up->in_ep_size,\n\t\t\t\t  urb->transfer_buffer,\n\t\t\t\t  urb->transfer_dma);\n\n\t\tif (ret == -ENODEV)\n\t\t\tnetif_device_detach(netdev);\n\t}\n}\n\n \nstatic void ucan_write_bulk_callback(struct urb *urb)\n{\n\tunsigned long flags;\n\tstruct ucan_priv *up;\n\tstruct ucan_urb_context *context = urb->context;\n\n\t \n\tif (WARN_ON_ONCE(!context))\n\t\treturn;\n\n\t \n\tusb_free_coherent(urb->dev,\n\t\t\t  sizeof(struct ucan_message_out),\n\t\t\t  urb->transfer_buffer,\n\t\t\t  urb->transfer_dma);\n\n\tup = context->up;\n\tif (WARN_ON_ONCE(!up))\n\t\treturn;\n\n\t \n\tif (!netif_device_present(up->netdev))\n\t\treturn;\n\n\t \n\tif (urb->status) {\n\t\tnetdev_warn(up->netdev,\n\t\t\t    \"failed to transmit USB message to device: %d\\n\",\n\t\t\t     urb->status);\n\n\t\t \n\t\tspin_lock_irqsave(&up->echo_skb_lock, flags);\n\t\tcan_free_echo_skb(up->netdev, context - up->context_array, NULL);\n\t\tspin_unlock_irqrestore(&up->echo_skb_lock, flags);\n\n\t\tup->netdev->stats.tx_dropped++;\n\n\t\t \n\t\tif (!ucan_release_context(up, context))\n\t\t\tnetdev_err(up->netdev,\n\t\t\t\t   \"urb failed, failed to release context\\n\");\n\t}\n}\n\nstatic void ucan_cleanup_rx_urbs(struct ucan_priv *up, struct urb **urbs)\n{\n\tint i;\n\n\tfor (i = 0; i < UCAN_MAX_RX_URBS; i++) {\n\t\tif (urbs[i]) {\n\t\t\tusb_unanchor_urb(urbs[i]);\n\t\t\tusb_free_coherent(up->udev,\n\t\t\t\t\t  up->in_ep_size,\n\t\t\t\t\t  urbs[i]->transfer_buffer,\n\t\t\t\t\t  urbs[i]->transfer_dma);\n\t\t\tusb_free_urb(urbs[i]);\n\t\t}\n\t}\n\n\tmemset(urbs, 0, sizeof(*urbs) * UCAN_MAX_RX_URBS);\n}\n\nstatic int ucan_prepare_and_anchor_rx_urbs(struct ucan_priv *up,\n\t\t\t\t\t   struct urb **urbs)\n{\n\tint i;\n\n\tmemset(urbs, 0, sizeof(*urbs) * UCAN_MAX_RX_URBS);\n\n\tfor (i = 0; i < UCAN_MAX_RX_URBS; i++) {\n\t\tvoid *buf;\n\n\t\turbs[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urbs[i])\n\t\t\tgoto err;\n\n\t\tbuf = usb_alloc_coherent(up->udev,\n\t\t\t\t\t up->in_ep_size,\n\t\t\t\t\t GFP_KERNEL, &urbs[i]->transfer_dma);\n\t\tif (!buf) {\n\t\t\t \n\t\t\tusb_free_urb(urbs[i]);\n\t\t\turbs[i] = NULL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tusb_fill_bulk_urb(urbs[i], up->udev,\n\t\t\t\t  usb_rcvbulkpipe(up->udev,\n\t\t\t\t\t\t  up->in_ep_addr),\n\t\t\t\t  buf,\n\t\t\t\t  up->in_ep_size,\n\t\t\t\t  ucan_read_bulk_callback,\n\t\t\t\t  up);\n\n\t\turbs[i]->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\t\tusb_anchor_urb(urbs[i], &up->rx_urbs);\n\t}\n\treturn 0;\n\nerr:\n\t \n\tucan_cleanup_rx_urbs(up, urbs);\n\treturn -ENOMEM;\n}\n\n \nstatic int ucan_submit_rx_urbs(struct ucan_priv *up, struct urb **urbs)\n{\n\tint i, ret;\n\n\t \n\tfor (i = 0; i < UCAN_MAX_RX_URBS; i++) {\n\t\tret = usb_submit_urb(urbs[i], GFP_KERNEL);\n\t\tif (ret) {\n\t\t\tnetdev_err(up->netdev,\n\t\t\t\t   \"could not submit urb; code: %d\\n\",\n\t\t\t\t   ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\t \n\t\tusb_free_urb(urbs[i]);\n\t\turbs[i] = NULL;\n\t}\n\treturn 0;\n\nerr:\n\t \n\tucan_cleanup_rx_urbs(up, urbs);\n\n\t \n\tusb_kill_anchored_urbs(&up->rx_urbs);\n\n\treturn ret;\n}\n\n \nstatic int ucan_open(struct net_device *netdev)\n{\n\tint ret, ret_cleanup;\n\tu16 ctrlmode;\n\tstruct urb *urbs[UCAN_MAX_RX_URBS];\n\tstruct ucan_priv *up = netdev_priv(netdev);\n\n\tret = ucan_alloc_context_array(up);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ucan_prepare_and_anchor_rx_urbs(up, urbs);\n\tif (ret)\n\t\tgoto err_contexts;\n\n\t \n\tctrlmode = 0;\n\tif (up->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\tctrlmode |= UCAN_MODE_LOOPBACK;\n\tif (up->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tctrlmode |= UCAN_MODE_SILENT;\n\tif (up->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\tctrlmode |= UCAN_MODE_3_SAMPLES;\n\tif (up->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)\n\t\tctrlmode |= UCAN_MODE_ONE_SHOT;\n\n\t \n\tctrlmode |= UCAN_MODE_BERR_REPORT;\n\tup->ctl_msg_buffer->cmd_start.mode = cpu_to_le16(ctrlmode);\n\n\t \n\tret = ucan_ctrl_command_out(up, UCAN_COMMAND_START, 0, 2);\n\tif (ret < 0) {\n\t\tnetdev_err(up->netdev,\n\t\t\t   \"could not start device, code: %d\\n\",\n\t\t\t   ret);\n\t\tgoto err_reset;\n\t}\n\n\t \n\tret = open_candev(netdev);\n\tif (ret)\n\t\tgoto err_stop;\n\n\t \n\tret = ucan_submit_rx_urbs(up, urbs);\n\tif (ret)\n\t\tgoto err_stop;\n\n\tup->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\t \n\tnetif_start_queue(netdev);\n\n\treturn 0;\n\nerr_stop:\n\t \n\tret_cleanup = ucan_ctrl_command_out(up, UCAN_COMMAND_STOP, 0, 0);\n\tif (ret_cleanup < 0)\n\t\tnetdev_err(up->netdev,\n\t\t\t   \"could not stop device, code: %d\\n\",\n\t\t\t   ret_cleanup);\n\nerr_reset:\n\t \n\tret_cleanup = ucan_ctrl_command_out(up, UCAN_COMMAND_RESET, 0, 0);\n\tif (ret_cleanup < 0)\n\t\tnetdev_err(up->netdev,\n\t\t\t   \"could not reset device, code: %d\\n\",\n\t\t\t   ret_cleanup);\n\n\t \n\tucan_cleanup_rx_urbs(up, urbs);\n\nerr_contexts:\n\tucan_release_context_array(up);\n\treturn ret;\n}\n\nstatic struct urb *ucan_prepare_tx_urb(struct ucan_priv *up,\n\t\t\t\t       struct ucan_urb_context *context,\n\t\t\t\t       struct can_frame *cf,\n\t\t\t\t       u8 echo_index)\n{\n\tint mlen;\n\tstruct urb *urb;\n\tstruct ucan_message_out *m;\n\n\t \n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb) {\n\t\tnetdev_err(up->netdev, \"no memory left for URBs\\n\");\n\t\treturn NULL;\n\t}\n\n\tm = usb_alloc_coherent(up->udev,\n\t\t\t       sizeof(struct ucan_message_out),\n\t\t\t       GFP_ATOMIC,\n\t\t\t       &urb->transfer_dma);\n\tif (!m) {\n\t\tnetdev_err(up->netdev, \"no memory left for USB buffer\\n\");\n\t\tusb_free_urb(urb);\n\t\treturn NULL;\n\t}\n\n\t \n\tm->type = UCAN_OUT_TX;\n\tm->msg.can_msg.id = cpu_to_le32(cf->can_id);\n\n\tif (cf->can_id & CAN_RTR_FLAG) {\n\t\tmlen = UCAN_OUT_HDR_SIZE +\n\t\t\toffsetof(struct ucan_can_msg, dlc) +\n\t\t\tsizeof(m->msg.can_msg.dlc);\n\t\tm->msg.can_msg.dlc = cf->len;\n\t} else {\n\t\tmlen = UCAN_OUT_HDR_SIZE +\n\t\t\tsizeof(m->msg.can_msg.id) + cf->len;\n\t\tmemcpy(m->msg.can_msg.data, cf->data, cf->len);\n\t}\n\tm->len = cpu_to_le16(mlen);\n\n\tm->subtype = echo_index;\n\n\t \n\tusb_fill_bulk_urb(urb, up->udev,\n\t\t\t  usb_sndbulkpipe(up->udev,\n\t\t\t\t\t  up->out_ep_addr),\n\t\t\t  m, mlen, ucan_write_bulk_callback, context);\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\treturn urb;\n}\n\nstatic void ucan_clean_up_tx_urb(struct ucan_priv *up, struct urb *urb)\n{\n\tusb_free_coherent(up->udev, sizeof(struct ucan_message_out),\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\tusb_free_urb(urb);\n}\n\n \nstatic netdev_tx_t ucan_start_xmit(struct sk_buff *skb,\n\t\t\t\t   struct net_device *netdev)\n{\n\tunsigned long flags;\n\tint ret;\n\tu8 echo_index;\n\tstruct urb *urb;\n\tstruct ucan_urb_context *context;\n\tstruct ucan_priv *up = netdev_priv(netdev);\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\n\t \n\tif (can_dev_dropped_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\t \n\tcontext = ucan_alloc_context(up);\n\techo_index = context - up->context_array;\n\n\tif (WARN_ON_ONCE(!context))\n\t\treturn NETDEV_TX_BUSY;\n\n\t \n\turb = ucan_prepare_tx_urb(up, context, cf, echo_index);\n\tif (!urb)\n\t\tgoto drop;\n\n\t \n\tspin_lock_irqsave(&up->echo_skb_lock, flags);\n\tcan_put_echo_skb(skb, up->netdev, echo_index, 0);\n\tspin_unlock_irqrestore(&up->echo_skb_lock, flags);\n\n\t \n\tusb_anchor_urb(urb, &up->tx_urbs);\n\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\n\t \n\tif (ret) {\n\t\t \n\t\tusb_unanchor_urb(urb);\n\t\tucan_clean_up_tx_urb(up, urb);\n\t\tif (!ucan_release_context(up, context))\n\t\t\tnetdev_err(up->netdev,\n\t\t\t\t   \"xmit err: failed to release context\\n\");\n\n\t\t \n\t\tspin_lock_irqsave(&up->echo_skb_lock, flags);\n\t\tcan_free_echo_skb(up->netdev, echo_index, NULL);\n\t\tspin_unlock_irqrestore(&up->echo_skb_lock, flags);\n\n\t\tif (ret == -ENODEV) {\n\t\t\tnetif_device_detach(up->netdev);\n\t\t} else {\n\t\t\tnetdev_warn(up->netdev,\n\t\t\t\t    \"xmit err: failed to submit urb %d\\n\",\n\t\t\t\t    ret);\n\t\t\tup->netdev->stats.tx_dropped++;\n\t\t}\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tnetif_trans_update(netdev);\n\n\t \n\tusb_free_urb(urb);\n\n\treturn NETDEV_TX_OK;\n\ndrop:\n\tif (!ucan_release_context(up, context))\n\t\tnetdev_err(up->netdev,\n\t\t\t   \"xmit drop: failed to release context\\n\");\n\tdev_kfree_skb(skb);\n\tup->netdev->stats.tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic int ucan_close(struct net_device *netdev)\n{\n\tint ret;\n\tstruct ucan_priv *up = netdev_priv(netdev);\n\n\tup->can.state = CAN_STATE_STOPPED;\n\n\t \n\tusb_kill_anchored_urbs(&up->tx_urbs);\n\n\t \n\tusb_kill_anchored_urbs(&up->rx_urbs);\n\n\t \n\tret = ucan_ctrl_command_out(up, UCAN_COMMAND_STOP, 0, 0);\n\tif (ret < 0)\n\t\tnetdev_err(up->netdev,\n\t\t\t   \"could not stop device, code: %d\\n\",\n\t\t\t   ret);\n\n\tret = ucan_ctrl_command_out(up, UCAN_COMMAND_RESET, 0, 0);\n\tif (ret < 0)\n\t\tnetdev_err(up->netdev,\n\t\t\t   \"could not reset device, code: %d\\n\",\n\t\t\t   ret);\n\n\tnetif_stop_queue(netdev);\n\n\tucan_release_context_array(up);\n\n\tclose_candev(up->netdev);\n\treturn 0;\n}\n\n \nstatic const struct net_device_ops ucan_netdev_ops = {\n\t.ndo_open = ucan_open,\n\t.ndo_stop = ucan_close,\n\t.ndo_start_xmit = ucan_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic const struct ethtool_ops ucan_ethtool_ops = {\n\t.get_ts_info = ethtool_op_get_ts_info,\n};\n\n \nstatic int ucan_set_bittiming(struct net_device *netdev)\n{\n\tint ret;\n\tstruct ucan_priv *up = netdev_priv(netdev);\n\tstruct ucan_ctl_cmd_set_bittiming *cmd_set_bittiming;\n\n\tcmd_set_bittiming = &up->ctl_msg_buffer->cmd_set_bittiming;\n\tcmd_set_bittiming->tq = cpu_to_le32(up->can.bittiming.tq);\n\tcmd_set_bittiming->brp = cpu_to_le16(up->can.bittiming.brp);\n\tcmd_set_bittiming->sample_point =\n\t    cpu_to_le16(up->can.bittiming.sample_point);\n\tcmd_set_bittiming->prop_seg = up->can.bittiming.prop_seg;\n\tcmd_set_bittiming->phase_seg1 = up->can.bittiming.phase_seg1;\n\tcmd_set_bittiming->phase_seg2 = up->can.bittiming.phase_seg2;\n\tcmd_set_bittiming->sjw = up->can.bittiming.sjw;\n\n\tret = ucan_ctrl_command_out(up, UCAN_COMMAND_SET_BITTIMING, 0,\n\t\t\t\t    sizeof(*cmd_set_bittiming));\n\treturn (ret < 0) ? ret : 0;\n}\n\n \nstatic int ucan_set_mode(struct net_device *netdev, enum can_mode mode)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct ucan_priv *up = netdev_priv(netdev);\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\tnetdev_dbg(up->netdev, \"restarting device\\n\");\n\n\t\tret = ucan_ctrl_command_out(up, UCAN_COMMAND_RESTART, 0, 0);\n\t\tup->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\t\t \n\t\tspin_lock_irqsave(&up->context_lock, flags);\n\n\t\tif (up->available_tx_urbs > 0)\n\t\t\tnetif_wake_queue(up->netdev);\n\n\t\tspin_unlock_irqrestore(&up->context_lock, flags);\n\n\t\treturn ret;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n \nstatic int ucan_probe(struct usb_interface *intf,\n\t\t      const struct usb_device_id *id)\n{\n\tint ret;\n\tint i;\n\tu32 protocol_version;\n\tstruct usb_device *udev;\n\tstruct net_device *netdev;\n\tstruct usb_host_interface *iface_desc;\n\tstruct ucan_priv *up;\n\tstruct usb_endpoint_descriptor *ep;\n\tu16 in_ep_size;\n\tu16 out_ep_size;\n\tu8 in_ep_addr;\n\tu8 out_ep_addr;\n\tunion ucan_ctl_payload *ctl_msg_buffer;\n\tchar firmware_str[sizeof(union ucan_ctl_payload) + 1];\n\n\tudev = interface_to_usbdev(intf);\n\n\t \n\n\t \n\tiface_desc = intf->cur_altsetting;\n\tif (!iface_desc)\n\t\treturn -ENODEV;\n\n\tdev_info(&udev->dev,\n\t\t \"%s: probing device on interface #%d\\n\",\n\t\t UCAN_DRIVER_NAME,\n\t\t iface_desc->desc.bInterfaceNumber);\n\n\t \n\tif (iface_desc->desc.bNumEndpoints != 2) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"%s: invalid EP count (%d)\",\n\t\t\tUCAN_DRIVER_NAME, iface_desc->desc.bNumEndpoints);\n\t\tgoto err_firmware_needs_update;\n\t}\n\n\t \n\tin_ep_addr = 0;\n\tout_ep_addr = 0;\n\tin_ep_size = 0;\n\tout_ep_size = 0;\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {\n\t\tep = &iface_desc->endpoint[i].desc;\n\n\t\tif (((ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK) != 0) &&\n\t\t    ((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\t     USB_ENDPOINT_XFER_BULK)) {\n\t\t\t \n\t\t\tin_ep_addr = ep->bEndpointAddress;\n\t\t\tin_ep_addr &= USB_ENDPOINT_NUMBER_MASK;\n\t\t\tin_ep_size = le16_to_cpu(ep->wMaxPacketSize);\n\t\t} else if (((ep->bEndpointAddress & USB_ENDPOINT_DIR_MASK) ==\n\t\t\t    0) &&\n\t\t\t   ((ep->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\t\t    USB_ENDPOINT_XFER_BULK)) {\n\t\t\t \n\t\t\tout_ep_addr = ep->bEndpointAddress;\n\t\t\tout_ep_addr &= USB_ENDPOINT_NUMBER_MASK;\n\t\t\tout_ep_size = le16_to_cpu(ep->wMaxPacketSize);\n\t\t}\n\t}\n\n\t \n\tif (!in_ep_addr || !out_ep_addr) {\n\t\tdev_err(&udev->dev, \"%s: invalid endpoint configuration\\n\",\n\t\t\tUCAN_DRIVER_NAME);\n\t\tgoto err_firmware_needs_update;\n\t}\n\tif (in_ep_size < sizeof(struct ucan_message_in)) {\n\t\tdev_err(&udev->dev, \"%s: invalid in_ep MaxPacketSize\\n\",\n\t\t\tUCAN_DRIVER_NAME);\n\t\tgoto err_firmware_needs_update;\n\t}\n\tif (out_ep_size < sizeof(struct ucan_message_out)) {\n\t\tdev_err(&udev->dev, \"%s: invalid out_ep MaxPacketSize\\n\",\n\t\t\tUCAN_DRIVER_NAME);\n\t\tgoto err_firmware_needs_update;\n\t}\n\n\t \n\n\t \n\tctl_msg_buffer = devm_kzalloc(&udev->dev,\n\t\t\t\t      sizeof(union ucan_ctl_payload),\n\t\t\t\t      GFP_KERNEL);\n\tif (!ctl_msg_buffer) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"%s: failed to allocate control pipe memory\\n\",\n\t\t\tUCAN_DRIVER_NAME);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tret = usb_control_msg(udev,\n\t\t\t      usb_rcvctrlpipe(udev, 0),\n\t\t\t      UCAN_COMMAND_GET,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t\t\tUSB_RECIP_INTERFACE,\n\t\t\t      UCAN_COMMAND_GET_PROTOCOL_VERSION,\n\t\t\t      iface_desc->desc.bInterfaceNumber,\n\t\t\t      ctl_msg_buffer,\n\t\t\t      sizeof(union ucan_ctl_payload),\n\t\t\t      UCAN_USB_CTL_PIPE_TIMEOUT);\n\n\t \n\tif (ret != 4) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"%s: could not read protocol version, ret=%d\\n\",\n\t\t\tUCAN_DRIVER_NAME, ret);\n\t\tif (ret >= 0)\n\t\t\tret = -EINVAL;\n\t\tgoto err_firmware_needs_update;\n\t}\n\n\t \n\tprotocol_version =\n\t\tle32_to_cpu(ctl_msg_buffer->cmd_get_protocol_version.version);\n\tif (protocol_version < UCAN_PROTOCOL_VERSION_MIN ||\n\t    protocol_version > UCAN_PROTOCOL_VERSION_MAX) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"%s: device protocol version %d is not supported\\n\",\n\t\t\tUCAN_DRIVER_NAME, protocol_version);\n\t\tgoto err_firmware_needs_update;\n\t}\n\n\t \n\tret = usb_control_msg(udev,\n\t\t\t      usb_rcvctrlpipe(udev, 0),\n\t\t\t      UCAN_COMMAND_GET,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t\t\tUSB_RECIP_INTERFACE,\n\t\t\t      UCAN_COMMAND_GET_INFO,\n\t\t\t      iface_desc->desc.bInterfaceNumber,\n\t\t\t      ctl_msg_buffer,\n\t\t\t      sizeof(ctl_msg_buffer->cmd_get_device_info),\n\t\t\t      UCAN_USB_CTL_PIPE_TIMEOUT);\n\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev, \"%s: failed to retrieve device info\\n\",\n\t\t\tUCAN_DRIVER_NAME);\n\t\tgoto err_firmware_needs_update;\n\t}\n\tif (ret < sizeof(ctl_msg_buffer->cmd_get_device_info)) {\n\t\tdev_err(&udev->dev, \"%s: device reported invalid device info\\n\",\n\t\t\tUCAN_DRIVER_NAME);\n\t\tgoto err_firmware_needs_update;\n\t}\n\tif (ctl_msg_buffer->cmd_get_device_info.tx_fifo == 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"%s: device reported invalid tx-fifo size\\n\",\n\t\t\tUCAN_DRIVER_NAME);\n\t\tgoto err_firmware_needs_update;\n\t}\n\n\t \n\n\t \n\tnetdev = alloc_candev(sizeof(struct ucan_priv),\n\t\t\t      ctl_msg_buffer->cmd_get_device_info.tx_fifo);\n\tif (!netdev) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"%s: cannot allocate candev\\n\", UCAN_DRIVER_NAME);\n\t\treturn -ENOMEM;\n\t}\n\n\tup = netdev_priv(netdev);\n\n\t \n\tup->udev = udev;\n\tup->netdev = netdev;\n\tup->intf_index = iface_desc->desc.bInterfaceNumber;\n\tup->in_ep_addr = in_ep_addr;\n\tup->out_ep_addr = out_ep_addr;\n\tup->in_ep_size = in_ep_size;\n\tup->ctl_msg_buffer = ctl_msg_buffer;\n\tup->context_array = NULL;\n\tup->available_tx_urbs = 0;\n\n\tup->can.state = CAN_STATE_STOPPED;\n\tup->can.bittiming_const = &up->device_info.bittiming_const;\n\tup->can.do_set_bittiming = ucan_set_bittiming;\n\tup->can.do_set_mode = &ucan_set_mode;\n\tspin_lock_init(&up->context_lock);\n\tspin_lock_init(&up->echo_skb_lock);\n\tnetdev->netdev_ops = &ucan_netdev_ops;\n\tnetdev->ethtool_ops = &ucan_ethtool_ops;\n\n\tusb_set_intfdata(intf, up);\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\n\t \n\tucan_parse_device_info(up, &ctl_msg_buffer->cmd_get_device_info);\n\n\t \n\tret = ucan_device_request_in(up, UCAN_DEVICE_GET_FW_STRING, 0,\n\t\t\t\t     sizeof(union ucan_ctl_payload));\n\tif (ret > 0) {\n\t\t \n\t\tstrscpy(firmware_str, up->ctl_msg_buffer->raw,\n\t\t\tsizeof(union ucan_ctl_payload) + 1);\n\t} else {\n\t\tstrcpy(firmware_str, \"unknown\");\n\t}\n\n\t \n\tret = ucan_ctrl_command_out(up, UCAN_COMMAND_RESET, 0, 0);\n\tif (ret < 0)\n\t\tgoto err_free_candev;\n\n\tinit_usb_anchor(&up->rx_urbs);\n\tinit_usb_anchor(&up->tx_urbs);\n\n\tup->can.state = CAN_STATE_STOPPED;\n\n\t \n\tret = register_candev(netdev);\n\tif (ret)\n\t\tgoto err_free_candev;\n\n\t \n\tnetdev_info(up->netdev, \"registered device\\n\");\n\tnetdev_info(up->netdev, \"firmware string: %s\\n\", firmware_str);\n\n\t \n\treturn 0;\n\nerr_free_candev:\n\tfree_candev(netdev);\n\treturn ret;\n\nerr_firmware_needs_update:\n\tdev_err(&udev->dev,\n\t\t\"%s: probe failed; try to update the device firmware\\n\",\n\t\tUCAN_DRIVER_NAME);\n\treturn -ENODEV;\n}\n\n \nstatic void ucan_disconnect(struct usb_interface *intf)\n{\n\tstruct ucan_priv *up = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\n\tif (up) {\n\t\tunregister_candev(up->netdev);\n\t\tfree_candev(up->netdev);\n\t}\n}\n\nstatic struct usb_device_id ucan_table[] = {\n\t \n\t{USB_DEVICE_INTERFACE_NUMBER(0x2294, 0x425a, 0)},\n\t \n\t{USB_DEVICE_INTERFACE_NUMBER(0x2294, 0x425b, 0)},\n\t{}  \n};\n\nMODULE_DEVICE_TABLE(usb, ucan_table);\n \nstatic struct usb_driver ucan_driver = {\n\t.name = UCAN_DRIVER_NAME,\n\t.probe = ucan_probe,\n\t.disconnect = ucan_disconnect,\n\t.id_table = ucan_table,\n};\n\nmodule_usb_driver(ucan_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Martin Elshuber <martin.elshuber@theobroma-systems.com>\");\nMODULE_AUTHOR(\"Jakob Unterwurzacher <jakob.unterwurzacher@theobroma-systems.com>\");\nMODULE_DESCRIPTION(\"Driver for Theobroma Systems UCAN devices\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}