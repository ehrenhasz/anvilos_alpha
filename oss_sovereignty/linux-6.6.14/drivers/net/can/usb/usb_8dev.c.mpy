{
  "module_name": "usb_8dev.c",
  "hash_id": "0d177265336fdde92cde0435f09f036ce6d6269eecc1c4905f735549769ddff8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/usb/usb_8dev.c",
  "human_readable_source": "\n \n\n#include <linux/ethtool.h>\n#include <linux/signal.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/usb.h>\n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n\n \n#define MAX_RX_URBS\t\t\t20\n#define MAX_TX_URBS\t\t\t20\n#define RX_BUFFER_SIZE\t\t\t64\n\n \n#define USB_8DEV_VENDOR_ID\t\t0x0483\n#define USB_8DEV_PRODUCT_ID\t\t0x1234\n\n \nenum usb_8dev_endpoint {\n\tUSB_8DEV_ENDP_DATA_RX = 1,\n\tUSB_8DEV_ENDP_DATA_TX,\n\tUSB_8DEV_ENDP_CMD_RX,\n\tUSB_8DEV_ENDP_CMD_TX\n};\n\n \n#define USB_8DEV_ABP_CLOCK\t\t32000000\n\n \n#define USB_8DEV_SILENT\t\t\t0x01\n#define USB_8DEV_LOOPBACK\t\t0x02\n#define USB_8DEV_DISABLE_AUTO_RESTRANS\t0x04\n#define USB_8DEV_STATUS_FRAME\t\t0x08\n\n \nenum usb_8dev_cmd {\n\tUSB_8DEV_RESET = 1,\n\tUSB_8DEV_OPEN,\n\tUSB_8DEV_CLOSE,\n\tUSB_8DEV_SET_SPEED,\n\tUSB_8DEV_SET_MASK_FILTER,\n\tUSB_8DEV_GET_STATUS,\n\tUSB_8DEV_GET_STATISTICS,\n\tUSB_8DEV_GET_SERIAL,\n\tUSB_8DEV_GET_SOFTW_VER,\n\tUSB_8DEV_GET_HARDW_VER,\n\tUSB_8DEV_RESET_TIMESTAMP,\n\tUSB_8DEV_GET_SOFTW_HARDW_VER\n};\n\n \n#define USB_8DEV_BAUD_MANUAL\t\t0x09\n#define USB_8DEV_CMD_START\t\t0x11\n#define USB_8DEV_CMD_END\t\t0x22\n\n#define USB_8DEV_CMD_SUCCESS\t\t0\n#define USB_8DEV_CMD_ERROR\t\t255\n\n#define USB_8DEV_CMD_TIMEOUT\t\t1000\n\n \n#define USB_8DEV_DATA_START\t\t0x55\n#define USB_8DEV_DATA_END\t\t0xAA\n\n#define USB_8DEV_TYPE_CAN_FRAME\t\t0\n#define USB_8DEV_TYPE_ERROR_FRAME\t3\n\n#define USB_8DEV_EXTID\t\t\t0x01\n#define USB_8DEV_RTR\t\t\t0x02\n#define USB_8DEV_ERR_FLAG\t\t0x04\n\n \n#define USB_8DEV_STATUSMSG_OK\t\t0x00   \n#define USB_8DEV_STATUSMSG_OVERRUN\t0x01   \n#define USB_8DEV_STATUSMSG_BUSLIGHT\t0x02   \n#define USB_8DEV_STATUSMSG_BUSHEAVY\t0x03   \n#define USB_8DEV_STATUSMSG_BUSOFF\t0x04   \n#define USB_8DEV_STATUSMSG_STUFF\t0x20   \n#define USB_8DEV_STATUSMSG_FORM\t\t0x21   \n#define USB_8DEV_STATUSMSG_ACK\t\t0x23   \n#define USB_8DEV_STATUSMSG_BIT0\t\t0x24   \n#define USB_8DEV_STATUSMSG_BIT1\t\t0x25   \n#define USB_8DEV_STATUSMSG_CRC\t\t0x27   \n\n#define USB_8DEV_RP_MASK\t\t0x7F   \n\n\n \nstatic const struct usb_device_id usb_8dev_table[] = {\n\t{ USB_DEVICE(USB_8DEV_VENDOR_ID, USB_8DEV_PRODUCT_ID) },\n\t{ }\t\t\t\t\t \n};\n\nMODULE_DEVICE_TABLE(usb, usb_8dev_table);\n\nstruct usb_8dev_tx_urb_context {\n\tstruct usb_8dev_priv *priv;\n\n\tu32 echo_index;\n};\n\n \nstruct usb_8dev_priv {\n\tstruct can_priv can;  \n\n\tstruct usb_device *udev;\n\tstruct net_device *netdev;\n\n\tatomic_t active_tx_urbs;\n\tstruct usb_anchor tx_submitted;\n\tstruct usb_8dev_tx_urb_context tx_contexts[MAX_TX_URBS];\n\n\tstruct usb_anchor rx_submitted;\n\n\tstruct can_berr_counter bec;\n\n\tu8 *cmd_msg_buffer;\n\n\tstruct mutex usb_8dev_cmd_lock;\n\tvoid *rxbuf[MAX_RX_URBS];\n\tdma_addr_t rxbuf_dma[MAX_RX_URBS];\n};\n\n \nstruct __packed usb_8dev_tx_msg {\n\tu8 begin;\n\tu8 flags;\t \n\t__be32 id;\t \n\tu8 dlc;\t\t \n\tu8 data[8];\t \n\tu8 end;\n};\n\n \nstruct __packed usb_8dev_rx_msg {\n\tu8 begin;\n\tu8 type;\t\t \n\tu8 flags;\t\t \n\t__be32 id;\t\t \n\tu8 dlc;\t\t\t \n\tu8 data[8];\t\t \n\t__be32 timestamp;\t \n\tu8 end;\n};\n\n \nstruct __packed usb_8dev_cmd_msg {\n\tu8 begin;\n\tu8 channel;\t \n\tu8 command;\t \n\tu8 opt1;\t \n\tu8 opt2;\t \n\tu8 data[10];\t \n\tu8 end;\n};\n\nstatic int usb_8dev_send_cmd_msg(struct usb_8dev_priv *priv, u8 *msg, int size)\n{\n\tint actual_length;\n\n\treturn usb_bulk_msg(priv->udev,\n\t\t\t    usb_sndbulkpipe(priv->udev, USB_8DEV_ENDP_CMD_TX),\n\t\t\t    msg, size, &actual_length, USB_8DEV_CMD_TIMEOUT);\n}\n\nstatic int usb_8dev_wait_cmd_msg(struct usb_8dev_priv *priv, u8 *msg, int size,\n\t\t\t\tint *actual_length)\n{\n\treturn usb_bulk_msg(priv->udev,\n\t\t\t    usb_rcvbulkpipe(priv->udev, USB_8DEV_ENDP_CMD_RX),\n\t\t\t    msg, size, actual_length, USB_8DEV_CMD_TIMEOUT);\n}\n\n \nstatic int usb_8dev_send_cmd(struct usb_8dev_priv *priv,\n\t\t\t     struct usb_8dev_cmd_msg *out,\n\t\t\t     struct usb_8dev_cmd_msg *in)\n{\n\tint err;\n\tint num_bytes_read;\n\tstruct net_device *netdev;\n\n\tnetdev = priv->netdev;\n\n\tout->begin = USB_8DEV_CMD_START;\n\tout->end = USB_8DEV_CMD_END;\n\n\tmutex_lock(&priv->usb_8dev_cmd_lock);\n\n\tmemcpy(priv->cmd_msg_buffer, out,\n\t\tsizeof(struct usb_8dev_cmd_msg));\n\n\terr = usb_8dev_send_cmd_msg(priv, priv->cmd_msg_buffer,\n\t\t\t\t    sizeof(struct usb_8dev_cmd_msg));\n\tif (err < 0) {\n\t\tnetdev_err(netdev, \"sending command message failed\\n\");\n\t\tgoto failed;\n\t}\n\n\terr = usb_8dev_wait_cmd_msg(priv, priv->cmd_msg_buffer,\n\t\t\t\t    sizeof(struct usb_8dev_cmd_msg),\n\t\t\t\t    &num_bytes_read);\n\tif (err < 0) {\n\t\tnetdev_err(netdev, \"no command message answer\\n\");\n\t\tgoto failed;\n\t}\n\n\tmemcpy(in, priv->cmd_msg_buffer, sizeof(struct usb_8dev_cmd_msg));\n\n\tif (in->begin != USB_8DEV_CMD_START || in->end != USB_8DEV_CMD_END ||\n\t\t\tnum_bytes_read != 16 || in->opt1 != 0)\n\t\terr = -EPROTO;\n\nfailed:\n\tmutex_unlock(&priv->usb_8dev_cmd_lock);\n\treturn err;\n}\n\n \nstatic int usb_8dev_cmd_open(struct usb_8dev_priv *priv)\n{\n\tstruct can_bittiming *bt = &priv->can.bittiming;\n\tstruct usb_8dev_cmd_msg outmsg;\n\tstruct usb_8dev_cmd_msg inmsg;\n\tu32 ctrlmode = priv->can.ctrlmode;\n\tu32 flags = USB_8DEV_STATUS_FRAME;\n\t__be32 beflags;\n\t__be16 bebrp;\n\n\tmemset(&outmsg, 0, sizeof(outmsg));\n\toutmsg.command = USB_8DEV_OPEN;\n\toutmsg.opt1 = USB_8DEV_BAUD_MANUAL;\n\toutmsg.data[0] = bt->prop_seg + bt->phase_seg1;\n\toutmsg.data[1] = bt->phase_seg2;\n\toutmsg.data[2] = bt->sjw;\n\n\t \n\tbebrp = cpu_to_be16((u16)bt->brp);\n\tmemcpy(&outmsg.data[3], &bebrp, sizeof(bebrp));\n\n\t \n\tif (ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\tflags |= USB_8DEV_LOOPBACK;\n\tif (ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tflags |= USB_8DEV_SILENT;\n\tif (ctrlmode & CAN_CTRLMODE_ONE_SHOT)\n\t\tflags |= USB_8DEV_DISABLE_AUTO_RESTRANS;\n\n\tbeflags = cpu_to_be32(flags);\n\tmemcpy(&outmsg.data[5], &beflags, sizeof(beflags));\n\n\treturn usb_8dev_send_cmd(priv, &outmsg, &inmsg);\n}\n\n \nstatic int usb_8dev_cmd_close(struct usb_8dev_priv *priv)\n{\n\tstruct usb_8dev_cmd_msg inmsg;\n\tstruct usb_8dev_cmd_msg outmsg = {\n\t\t.channel = 0,\n\t\t.command = USB_8DEV_CLOSE,\n\t\t.opt1 = 0,\n\t\t.opt2 = 0\n\t};\n\n\treturn usb_8dev_send_cmd(priv, &outmsg, &inmsg);\n}\n\n \nstatic int usb_8dev_cmd_version(struct usb_8dev_priv *priv, u32 *res)\n{\n\tstruct usb_8dev_cmd_msg\tinmsg;\n\tstruct usb_8dev_cmd_msg\toutmsg = {\n\t\t.channel = 0,\n\t\t.command = USB_8DEV_GET_SOFTW_HARDW_VER,\n\t\t.opt1 = 0,\n\t\t.opt2 = 0\n\t};\n\n\tint err = usb_8dev_send_cmd(priv, &outmsg, &inmsg);\n\tif (err)\n\t\treturn err;\n\n\t*res = be32_to_cpup((__be32 *)inmsg.data);\n\n\treturn err;\n}\n\n \nstatic int usb_8dev_set_mode(struct net_device *netdev, enum can_mode mode)\n{\n\tstruct usb_8dev_priv *priv = netdev_priv(netdev);\n\tint err = 0;\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\terr = usb_8dev_cmd_open(priv);\n\t\tif (err)\n\t\t\tnetdev_warn(netdev, \"couldn't start device\");\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\n \nstatic void usb_8dev_rx_err_msg(struct usb_8dev_priv *priv,\n\t\t\t\tstruct usb_8dev_rx_msg *msg)\n{\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\n\t \n\n\tu8 state = msg->data[0];\n\tu8 rxerr = msg->data[1] & USB_8DEV_RP_MASK;\n\tu8 txerr = msg->data[2];\n\tint rx_errors = 0;\n\tint tx_errors = 0;\n\n\tskb = alloc_can_err_skb(priv->netdev, &cf);\n\tif (!skb)\n\t\treturn;\n\n\tswitch (state) {\n\tcase USB_8DEV_STATUSMSG_OK:\n\t\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\tcf->can_id |= CAN_ERR_PROT;\n\t\tcf->data[2] = CAN_ERR_PROT_ACTIVE;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_BUSOFF:\n\t\tpriv->can.state = CAN_STATE_BUS_OFF;\n\t\tcf->can_id |= CAN_ERR_BUSOFF;\n\t\tpriv->can.can_stats.bus_off++;\n\t\tcan_bus_off(priv->netdev);\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_OVERRUN:\n\tcase USB_8DEV_STATUSMSG_BUSLIGHT:\n\tcase USB_8DEV_STATUSMSG_BUSHEAVY:\n\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\tbreak;\n\tdefault:\n\t\tpriv->can.state = CAN_STATE_ERROR_WARNING;\n\t\tcf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\n\t\tpriv->can.can_stats.bus_error++;\n\t\tbreak;\n\t}\n\n\tswitch (state) {\n\tcase USB_8DEV_STATUSMSG_OK:\n\tcase USB_8DEV_STATUSMSG_BUSOFF:\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_ACK:\n\t\tcf->can_id |= CAN_ERR_ACK;\n\t\ttx_errors = 1;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_CRC:\n\t\tcf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;\n\t\trx_errors = 1;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_BIT0:\n\t\tcf->data[2] |= CAN_ERR_PROT_BIT0;\n\t\ttx_errors = 1;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_BIT1:\n\t\tcf->data[2] |= CAN_ERR_PROT_BIT1;\n\t\ttx_errors = 1;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_FORM:\n\t\tcf->data[2] |= CAN_ERR_PROT_FORM;\n\t\trx_errors = 1;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_STUFF:\n\t\tcf->data[2] |= CAN_ERR_PROT_STUFF;\n\t\trx_errors = 1;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_OVERRUN:\n\t\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\t\tstats->rx_over_errors++;\n\t\trx_errors = 1;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_BUSLIGHT:\n\t\tpriv->can.state = CAN_STATE_ERROR_WARNING;\n\t\tcf->data[1] = (txerr > rxerr) ?\n\t\t\tCAN_ERR_CRTL_TX_WARNING :\n\t\t\tCAN_ERR_CRTL_RX_WARNING;\n\t\tpriv->can.can_stats.error_warning++;\n\t\tbreak;\n\tcase USB_8DEV_STATUSMSG_BUSHEAVY:\n\t\tpriv->can.state = CAN_STATE_ERROR_PASSIVE;\n\t\tcf->data[1] = (txerr > rxerr) ?\n\t\t\tCAN_ERR_CRTL_TX_PASSIVE :\n\t\t\tCAN_ERR_CRTL_RX_PASSIVE;\n\t\tpriv->can.can_stats.error_passive++;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_warn(priv->netdev,\n\t\t\t    \"Unknown status/error message (%d)\\n\", state);\n\t\tbreak;\n\t}\n\n\tif (tx_errors) {\n\t\tcf->data[2] |= CAN_ERR_PROT_TX;\n\t\tstats->tx_errors++;\n\t}\n\n\tif (rx_errors)\n\t\tstats->rx_errors++;\n\tif (priv->can.state != CAN_STATE_BUS_OFF) {\n\t\tcf->can_id |= CAN_ERR_CNT;\n\t\tcf->data[6] = txerr;\n\t\tcf->data[7] = rxerr;\n\t}\n\n\tpriv->bec.txerr = txerr;\n\tpriv->bec.rxerr = rxerr;\n\n\tnetif_rx(skb);\n}\n\n \nstatic void usb_8dev_rx_can_msg(struct usb_8dev_priv *priv,\n\t\t\t\tstruct usb_8dev_rx_msg *msg)\n{\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\n\tif (msg->type == USB_8DEV_TYPE_ERROR_FRAME &&\n\t\t   msg->flags == USB_8DEV_ERR_FLAG) {\n\t\tusb_8dev_rx_err_msg(priv, msg);\n\t} else if (msg->type == USB_8DEV_TYPE_CAN_FRAME) {\n\t\tskb = alloc_can_skb(priv->netdev, &cf);\n\t\tif (!skb)\n\t\t\treturn;\n\n\t\tcf->can_id = be32_to_cpu(msg->id);\n\t\tcan_frame_set_cc_len(cf, msg->dlc & 0xF, priv->can.ctrlmode);\n\n\t\tif (msg->flags & USB_8DEV_EXTID)\n\t\t\tcf->can_id |= CAN_EFF_FLAG;\n\n\t\tif (msg->flags & USB_8DEV_RTR) {\n\t\t\tcf->can_id |= CAN_RTR_FLAG;\n\t\t} else {\n\t\t\tmemcpy(cf->data, msg->data, cf->len);\n\t\t\tstats->rx_bytes += cf->len;\n\t\t}\n\t\tstats->rx_packets++;\n\n\t\tnetif_rx(skb);\n\t} else {\n\t\tnetdev_warn(priv->netdev, \"frame type %d unknown\",\n\t\t\t msg->type);\n\t}\n\n}\n\n \nstatic void usb_8dev_read_bulk_callback(struct urb *urb)\n{\n\tstruct usb_8dev_priv *priv = urb->context;\n\tstruct net_device *netdev;\n\tint retval;\n\tint pos = 0;\n\n\tnetdev = priv->netdev;\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tswitch (urb->status) {\n\tcase 0:  \n\t\tbreak;\n\n\tcase -ENOENT:\n\tcase -EPIPE:\n\tcase -EPROTO:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\n\tdefault:\n\t\tnetdev_info(netdev, \"Rx URB aborted (%d)\\n\",\n\t\t\t urb->status);\n\t\tgoto resubmit_urb;\n\t}\n\n\twhile (pos < urb->actual_length) {\n\t\tstruct usb_8dev_rx_msg *msg;\n\n\t\tif (pos + sizeof(struct usb_8dev_rx_msg) > urb->actual_length) {\n\t\t\tnetdev_err(priv->netdev, \"format error\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tmsg = (struct usb_8dev_rx_msg *)(urb->transfer_buffer + pos);\n\t\tusb_8dev_rx_can_msg(priv, msg);\n\n\t\tpos += sizeof(struct usb_8dev_rx_msg);\n\t}\n\nresubmit_urb:\n\tusb_fill_bulk_urb(urb, priv->udev,\n\t\t\t  usb_rcvbulkpipe(priv->udev, USB_8DEV_ENDP_DATA_RX),\n\t\t\t  urb->transfer_buffer, RX_BUFFER_SIZE,\n\t\t\t  usb_8dev_read_bulk_callback, priv);\n\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\n\tif (retval == -ENODEV)\n\t\tnetif_device_detach(netdev);\n\telse if (retval)\n\t\tnetdev_err(netdev,\n\t\t\t\"failed resubmitting read bulk urb: %d\\n\", retval);\n}\n\n \nstatic void usb_8dev_write_bulk_callback(struct urb *urb)\n{\n\tstruct usb_8dev_tx_urb_context *context = urb->context;\n\tstruct usb_8dev_priv *priv;\n\tstruct net_device *netdev;\n\n\tBUG_ON(!context);\n\n\tpriv = context->priv;\n\tnetdev = priv->netdev;\n\n\t \n\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\n\tatomic_dec(&priv->active_tx_urbs);\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"Tx URB aborted (%d)\\n\",\n\t\t\t urb->status);\n\n\tnetdev->stats.tx_packets++;\n\tnetdev->stats.tx_bytes += can_get_echo_skb(netdev, context->echo_index, NULL);\n\n\t \n\tcontext->echo_index = MAX_TX_URBS;\n\n\tnetif_wake_queue(netdev);\n}\n\n \nstatic netdev_tx_t usb_8dev_start_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *netdev)\n{\n\tstruct usb_8dev_priv *priv = netdev_priv(netdev);\n\tstruct net_device_stats *stats = &netdev->stats;\n\tstruct can_frame *cf = (struct can_frame *) skb->data;\n\tstruct usb_8dev_tx_msg *msg;\n\tstruct urb *urb;\n\tstruct usb_8dev_tx_urb_context *context = NULL;\n\tu8 *buf;\n\tint i, err;\n\tsize_t size = sizeof(struct usb_8dev_tx_msg);\n\n\tif (can_dev_dropped_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\t \n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\tgoto nomem;\n\n\tbuf = usb_alloc_coherent(priv->udev, size, GFP_ATOMIC,\n\t\t\t\t &urb->transfer_dma);\n\tif (!buf) {\n\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\tgoto nomembuf;\n\t}\n\n\tmemset(buf, 0, size);\n\n\tmsg = (struct usb_8dev_tx_msg *)buf;\n\tmsg->begin = USB_8DEV_DATA_START;\n\tmsg->flags = 0x00;\n\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tmsg->flags |= USB_8DEV_RTR;\n\n\tif (cf->can_id & CAN_EFF_FLAG)\n\t\tmsg->flags |= USB_8DEV_EXTID;\n\n\tmsg->id = cpu_to_be32(cf->can_id & CAN_ERR_MASK);\n\tmsg->dlc = can_get_cc_dlc(cf, priv->can.ctrlmode);\n\tmemcpy(msg->data, cf->data, cf->len);\n\tmsg->end = USB_8DEV_DATA_END;\n\n\tfor (i = 0; i < MAX_TX_URBS; i++) {\n\t\tif (priv->tx_contexts[i].echo_index == MAX_TX_URBS) {\n\t\t\tcontext = &priv->tx_contexts[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!context)\n\t\tgoto nofreecontext;\n\n\tcontext->priv = priv;\n\tcontext->echo_index = i;\n\n\tusb_fill_bulk_urb(urb, priv->udev,\n\t\t\t  usb_sndbulkpipe(priv->udev, USB_8DEV_ENDP_DATA_TX),\n\t\t\t  buf, size, usb_8dev_write_bulk_callback, context);\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tusb_anchor_urb(urb, &priv->tx_submitted);\n\n\tcan_put_echo_skb(skb, netdev, context->echo_index, 0);\n\n\tatomic_inc(&priv->active_tx_urbs);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tcan_free_echo_skb(netdev, context->echo_index, NULL);\n\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_coherent(priv->udev, size, buf, urb->transfer_dma);\n\n\t\tatomic_dec(&priv->active_tx_urbs);\n\n\t\tif (err == -ENODEV)\n\t\t\tnetif_device_detach(netdev);\n\t\telse\n\t\t\tnetdev_warn(netdev, \"failed tx_urb %d\\n\", err);\n\t\tstats->tx_dropped++;\n\t} else if (atomic_read(&priv->active_tx_urbs) >= MAX_TX_URBS)\n\t\t \n\t\tnetif_stop_queue(netdev);\n\n\t \n\tusb_free_urb(urb);\n\n\treturn NETDEV_TX_OK;\n\nnofreecontext:\n\tusb_free_coherent(priv->udev, size, buf, urb->transfer_dma);\n\tusb_free_urb(urb);\n\n\tnetdev_warn(netdev, \"couldn't find free context\");\n\n\treturn NETDEV_TX_BUSY;\n\nnomembuf:\n\tusb_free_urb(urb);\n\nnomem:\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int usb_8dev_get_berr_counter(const struct net_device *netdev,\n\t\t\t\t     struct can_berr_counter *bec)\n{\n\tstruct usb_8dev_priv *priv = netdev_priv(netdev);\n\n\tbec->txerr = priv->bec.txerr;\n\tbec->rxerr = priv->bec.rxerr;\n\n\treturn 0;\n}\n\n \nstatic int usb_8dev_start(struct usb_8dev_priv *priv)\n{\n\tstruct net_device *netdev = priv->netdev;\n\tint err, i;\n\n\tfor (i = 0; i < MAX_RX_URBS; i++) {\n\t\tstruct urb *urb = NULL;\n\t\tu8 *buf;\n\t\tdma_addr_t buf_dma;\n\n\t\t \n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf = usb_alloc_coherent(priv->udev, RX_BUFFER_SIZE, GFP_KERNEL,\n\t\t\t\t\t &buf_dma);\n\t\tif (!buf) {\n\t\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\t\tusb_free_urb(urb);\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\turb->transfer_dma = buf_dma;\n\n\t\tusb_fill_bulk_urb(urb, priv->udev,\n\t\t\t\t  usb_rcvbulkpipe(priv->udev,\n\t\t\t\t\t\t  USB_8DEV_ENDP_DATA_RX),\n\t\t\t\t  buf, RX_BUFFER_SIZE,\n\t\t\t\t  usb_8dev_read_bulk_callback, priv);\n\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\tusb_anchor_urb(urb, &priv->rx_submitted);\n\n\t\terr = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (err) {\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tusb_free_coherent(priv->udev, RX_BUFFER_SIZE, buf,\n\t\t\t\t\t  urb->transfer_dma);\n\t\t\tusb_free_urb(urb);\n\t\t\tbreak;\n\t\t}\n\n\t\tpriv->rxbuf[i] = buf;\n\t\tpriv->rxbuf_dma[i] = buf_dma;\n\n\t\t \n\t\tusb_free_urb(urb);\n\t}\n\n\t \n\tif (i == 0) {\n\t\tnetdev_warn(netdev, \"couldn't setup read URBs\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tif (i < MAX_RX_URBS)\n\t\tnetdev_warn(netdev, \"rx performance may be slow\\n\");\n\n\terr = usb_8dev_cmd_open(priv);\n\tif (err)\n\t\tgoto failed;\n\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\treturn 0;\n\nfailed:\n\tif (err == -ENODEV)\n\t\tnetif_device_detach(priv->netdev);\n\n\tnetdev_warn(netdev, \"couldn't submit control: %d\\n\", err);\n\n\treturn err;\n}\n\n \nstatic int usb_8dev_open(struct net_device *netdev)\n{\n\tstruct usb_8dev_priv *priv = netdev_priv(netdev);\n\tint err;\n\n\t \n\terr = open_candev(netdev);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = usb_8dev_start(priv);\n\tif (err) {\n\t\tif (err == -ENODEV)\n\t\t\tnetif_device_detach(priv->netdev);\n\n\t\tnetdev_warn(netdev, \"couldn't start device: %d\\n\",\n\t\t\t err);\n\n\t\tclose_candev(netdev);\n\n\t\treturn err;\n\t}\n\n\tnetif_start_queue(netdev);\n\n\treturn 0;\n}\n\nstatic void unlink_all_urbs(struct usb_8dev_priv *priv)\n{\n\tint i;\n\n\tusb_kill_anchored_urbs(&priv->rx_submitted);\n\n\tfor (i = 0; i < MAX_RX_URBS; ++i)\n\t\tusb_free_coherent(priv->udev, RX_BUFFER_SIZE,\n\t\t\t\t  priv->rxbuf[i], priv->rxbuf_dma[i]);\n\n\tusb_kill_anchored_urbs(&priv->tx_submitted);\n\tatomic_set(&priv->active_tx_urbs, 0);\n\n\tfor (i = 0; i < MAX_TX_URBS; i++)\n\t\tpriv->tx_contexts[i].echo_index = MAX_TX_URBS;\n}\n\n \nstatic int usb_8dev_close(struct net_device *netdev)\n{\n\tstruct usb_8dev_priv *priv = netdev_priv(netdev);\n\tint err = 0;\n\n\t \n\terr = usb_8dev_cmd_close(priv);\n\tif (err)\n\t\tnetdev_warn(netdev, \"couldn't stop device\");\n\n\tpriv->can.state = CAN_STATE_STOPPED;\n\n\tnetif_stop_queue(netdev);\n\n\t \n\tunlink_all_urbs(priv);\n\n\tclose_candev(netdev);\n\n\treturn err;\n}\n\nstatic const struct net_device_ops usb_8dev_netdev_ops = {\n\t.ndo_open = usb_8dev_open,\n\t.ndo_stop = usb_8dev_close,\n\t.ndo_start_xmit = usb_8dev_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic const struct ethtool_ops usb_8dev_ethtool_ops = {\n\t.get_ts_info = ethtool_op_get_ts_info,\n};\n\nstatic const struct can_bittiming_const usb_8dev_bittiming_const = {\n\t.name = KBUILD_MODNAME,\n\t.tseg1_min = 1,\n\t.tseg1_max = 16,\n\t.tseg2_min = 1,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 1024,\n\t.brp_inc = 1,\n};\n\n \nstatic int usb_8dev_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct net_device *netdev;\n\tstruct usb_8dev_priv *priv;\n\tint i, err = -ENOMEM;\n\tu32 version;\n\tchar buf[18];\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\n\t \n\tif (usb_string(usbdev, usbdev->descriptor.iProduct, buf,\n\t\t       sizeof(buf)) > 0 && strcmp(buf, \"USB2CAN converter\")) {\n\t\tdev_info(&usbdev->dev, \"ignoring: not an USB2CAN converter\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tnetdev = alloc_candev(sizeof(struct usb_8dev_priv), MAX_TX_URBS);\n\tif (!netdev) {\n\t\tdev_err(&intf->dev, \"Couldn't alloc candev\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv = netdev_priv(netdev);\n\n\tpriv->udev = usbdev;\n\tpriv->netdev = netdev;\n\n\tpriv->can.state = CAN_STATE_STOPPED;\n\tpriv->can.clock.freq = USB_8DEV_ABP_CLOCK;\n\tpriv->can.bittiming_const = &usb_8dev_bittiming_const;\n\tpriv->can.do_set_mode = usb_8dev_set_mode;\n\tpriv->can.do_get_berr_counter = usb_8dev_get_berr_counter;\n\tpriv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |\n\t\t\t\t      CAN_CTRLMODE_LISTENONLY |\n\t\t\t\t      CAN_CTRLMODE_ONE_SHOT |\n\t\t\t\t      CAN_CTRLMODE_CC_LEN8_DLC;\n\n\tnetdev->netdev_ops = &usb_8dev_netdev_ops;\n\tnetdev->ethtool_ops = &usb_8dev_ethtool_ops;\n\n\tnetdev->flags |= IFF_ECHO;  \n\n\tinit_usb_anchor(&priv->rx_submitted);\n\n\tinit_usb_anchor(&priv->tx_submitted);\n\tatomic_set(&priv->active_tx_urbs, 0);\n\n\tfor (i = 0; i < MAX_TX_URBS; i++)\n\t\tpriv->tx_contexts[i].echo_index = MAX_TX_URBS;\n\n\tpriv->cmd_msg_buffer = devm_kzalloc(&intf->dev, sizeof(struct usb_8dev_cmd_msg),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!priv->cmd_msg_buffer)\n\t\tgoto cleanup_candev;\n\n\tusb_set_intfdata(intf, priv);\n\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\n\tmutex_init(&priv->usb_8dev_cmd_lock);\n\n\terr = register_candev(netdev);\n\tif (err) {\n\t\tnetdev_err(netdev,\n\t\t\t\"couldn't register CAN device: %d\\n\", err);\n\t\tgoto cleanup_candev;\n\t}\n\n\terr = usb_8dev_cmd_version(priv, &version);\n\tif (err) {\n\t\tnetdev_err(netdev, \"can't get firmware version\\n\");\n\t\tgoto cleanup_unregister_candev;\n\t} else {\n\t\tnetdev_info(netdev,\n\t\t\t \"firmware: %d.%d, hardware: %d.%d\\n\",\n\t\t\t (version>>24) & 0xff, (version>>16) & 0xff,\n\t\t\t (version>>8) & 0xff, version & 0xff);\n\t}\n\n\treturn 0;\n\ncleanup_unregister_candev:\n\tunregister_netdev(priv->netdev);\n\ncleanup_candev:\n\tfree_candev(netdev);\n\n\treturn err;\n\n}\n\n \nstatic void usb_8dev_disconnect(struct usb_interface *intf)\n{\n\tstruct usb_8dev_priv *priv = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\n\tif (priv) {\n\t\tnetdev_info(priv->netdev, \"device disconnected\\n\");\n\n\t\tunregister_netdev(priv->netdev);\n\t\tunlink_all_urbs(priv);\n\t\tfree_candev(priv->netdev);\n\t}\n\n}\n\nstatic struct usb_driver usb_8dev_driver = {\n\t.name =\t\tKBUILD_MODNAME,\n\t.probe =\tusb_8dev_probe,\n\t.disconnect =\tusb_8dev_disconnect,\n\t.id_table =\tusb_8dev_table,\n};\n\nmodule_usb_driver(usb_8dev_driver);\n\nMODULE_AUTHOR(\"Bernd Krumboeck <krumboeck@universalnet.at>\");\nMODULE_DESCRIPTION(\"CAN driver for 8 devices USB2CAN interfaces\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}