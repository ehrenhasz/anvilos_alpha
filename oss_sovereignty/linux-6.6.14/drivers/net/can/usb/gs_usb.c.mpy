{
  "module_name": "gs_usb.c",
  "hash_id": "d0d8fb2b294fdf27015fabf417e21504e91e46214753bbd61f4430b6a581a3d0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/usb/gs_usb.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clocksource.h>\n#include <linux/ethtool.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/signal.h>\n#include <linux/timecounter.h>\n#include <linux/units.h>\n#include <linux/usb.h>\n#include <linux/workqueue.h>\n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n#include <linux/can/rx-offload.h>\n\n \n#define USB_GS_USB_1_VENDOR_ID 0x1d50\n#define USB_GS_USB_1_PRODUCT_ID 0x606f\n\n#define USB_CANDLELIGHT_VENDOR_ID 0x1209\n#define USB_CANDLELIGHT_PRODUCT_ID 0x2323\n\n#define USB_CES_CANEXT_FD_VENDOR_ID 0x1cd2\n#define USB_CES_CANEXT_FD_PRODUCT_ID 0x606f\n\n#define USB_ABE_CANDEBUGGER_FD_VENDOR_ID 0x16d0\n#define USB_ABE_CANDEBUGGER_FD_PRODUCT_ID 0x10b8\n\n#define GS_USB_ENDPOINT_IN 1\n#define GS_USB_ENDPOINT_OUT 2\n\n \n#define GS_USB_TIMESTAMP_TIMER_HZ (1 * HZ_PER_MHZ)\n#define GS_USB_TIMESTAMP_WORK_DELAY_SEC 1800\nstatic_assert(GS_USB_TIMESTAMP_WORK_DELAY_SEC <\n\t      CYCLECOUNTER_MASK(32) / GS_USB_TIMESTAMP_TIMER_HZ / 2);\n\n \nenum gs_usb_breq {\n\tGS_USB_BREQ_HOST_FORMAT = 0,\n\tGS_USB_BREQ_BITTIMING,\n\tGS_USB_BREQ_MODE,\n\tGS_USB_BREQ_BERR,\n\tGS_USB_BREQ_BT_CONST,\n\tGS_USB_BREQ_DEVICE_CONFIG,\n\tGS_USB_BREQ_TIMESTAMP,\n\tGS_USB_BREQ_IDENTIFY,\n\tGS_USB_BREQ_GET_USER_ID,\n\tGS_USB_BREQ_QUIRK_CANTACT_PRO_DATA_BITTIMING = GS_USB_BREQ_GET_USER_ID,\n\tGS_USB_BREQ_SET_USER_ID,\n\tGS_USB_BREQ_DATA_BITTIMING,\n\tGS_USB_BREQ_BT_CONST_EXT,\n\tGS_USB_BREQ_SET_TERMINATION,\n\tGS_USB_BREQ_GET_TERMINATION,\n\tGS_USB_BREQ_GET_STATE,\n};\n\nenum gs_can_mode {\n\t \n\tGS_CAN_MODE_RESET = 0,\n\t \n\tGS_CAN_MODE_START\n};\n\nenum gs_can_state {\n\tGS_CAN_STATE_ERROR_ACTIVE = 0,\n\tGS_CAN_STATE_ERROR_WARNING,\n\tGS_CAN_STATE_ERROR_PASSIVE,\n\tGS_CAN_STATE_BUS_OFF,\n\tGS_CAN_STATE_STOPPED,\n\tGS_CAN_STATE_SLEEPING\n};\n\nenum gs_can_identify_mode {\n\tGS_CAN_IDENTIFY_OFF = 0,\n\tGS_CAN_IDENTIFY_ON\n};\n\nenum gs_can_termination_state {\n\tGS_CAN_TERMINATION_STATE_OFF = 0,\n\tGS_CAN_TERMINATION_STATE_ON\n};\n\n#define GS_USB_TERMINATION_DISABLED CAN_TERMINATION_DISABLED\n#define GS_USB_TERMINATION_ENABLED 120\n\n \n\n \nstruct gs_host_config {\n\t__le32 byte_order;\n} __packed;\n\nstruct gs_device_config {\n\tu8 reserved1;\n\tu8 reserved2;\n\tu8 reserved3;\n\tu8 icount;\n\t__le32 sw_version;\n\t__le32 hw_version;\n} __packed;\n\n#define GS_CAN_MODE_NORMAL 0\n#define GS_CAN_MODE_LISTEN_ONLY BIT(0)\n#define GS_CAN_MODE_LOOP_BACK BIT(1)\n#define GS_CAN_MODE_TRIPLE_SAMPLE BIT(2)\n#define GS_CAN_MODE_ONE_SHOT BIT(3)\n#define GS_CAN_MODE_HW_TIMESTAMP BIT(4)\n \n \n#define GS_CAN_MODE_PAD_PKTS_TO_MAX_PKT_SIZE BIT(7)\n#define GS_CAN_MODE_FD BIT(8)\n \n \n \n#define GS_CAN_MODE_BERR_REPORTING BIT(12)\n \n\nstruct gs_device_mode {\n\t__le32 mode;\n\t__le32 flags;\n} __packed;\n\nstruct gs_device_state {\n\t__le32 state;\n\t__le32 rxerr;\n\t__le32 txerr;\n} __packed;\n\nstruct gs_device_bittiming {\n\t__le32 prop_seg;\n\t__le32 phase_seg1;\n\t__le32 phase_seg2;\n\t__le32 sjw;\n\t__le32 brp;\n} __packed;\n\nstruct gs_identify_mode {\n\t__le32 mode;\n} __packed;\n\nstruct gs_device_termination_state {\n\t__le32 state;\n} __packed;\n\n#define GS_CAN_FEATURE_LISTEN_ONLY BIT(0)\n#define GS_CAN_FEATURE_LOOP_BACK BIT(1)\n#define GS_CAN_FEATURE_TRIPLE_SAMPLE BIT(2)\n#define GS_CAN_FEATURE_ONE_SHOT BIT(3)\n#define GS_CAN_FEATURE_HW_TIMESTAMP BIT(4)\n#define GS_CAN_FEATURE_IDENTIFY BIT(5)\n#define GS_CAN_FEATURE_USER_ID BIT(6)\n#define GS_CAN_FEATURE_PAD_PKTS_TO_MAX_PKT_SIZE BIT(7)\n#define GS_CAN_FEATURE_FD BIT(8)\n#define GS_CAN_FEATURE_REQ_USB_QUIRK_LPC546XX BIT(9)\n#define GS_CAN_FEATURE_BT_CONST_EXT BIT(10)\n#define GS_CAN_FEATURE_TERMINATION BIT(11)\n#define GS_CAN_FEATURE_BERR_REPORTING BIT(12)\n#define GS_CAN_FEATURE_GET_STATE BIT(13)\n#define GS_CAN_FEATURE_MASK GENMASK(13, 0)\n\n \n\n \n#define GS_CAN_FEATURE_QUIRK_BREQ_CANTACT_PRO BIT(31)\n\nstruct gs_device_bt_const {\n\t__le32 feature;\n\t__le32 fclk_can;\n\t__le32 tseg1_min;\n\t__le32 tseg1_max;\n\t__le32 tseg2_min;\n\t__le32 tseg2_max;\n\t__le32 sjw_max;\n\t__le32 brp_min;\n\t__le32 brp_max;\n\t__le32 brp_inc;\n} __packed;\n\nstruct gs_device_bt_const_extended {\n\t__le32 feature;\n\t__le32 fclk_can;\n\t__le32 tseg1_min;\n\t__le32 tseg1_max;\n\t__le32 tseg2_min;\n\t__le32 tseg2_max;\n\t__le32 sjw_max;\n\t__le32 brp_min;\n\t__le32 brp_max;\n\t__le32 brp_inc;\n\n\t__le32 dtseg1_min;\n\t__le32 dtseg1_max;\n\t__le32 dtseg2_min;\n\t__le32 dtseg2_max;\n\t__le32 dsjw_max;\n\t__le32 dbrp_min;\n\t__le32 dbrp_max;\n\t__le32 dbrp_inc;\n} __packed;\n\n#define GS_CAN_FLAG_OVERFLOW BIT(0)\n#define GS_CAN_FLAG_FD BIT(1)\n#define GS_CAN_FLAG_BRS BIT(2)\n#define GS_CAN_FLAG_ESI BIT(3)\n\nstruct classic_can {\n\tu8 data[8];\n} __packed;\n\nstruct classic_can_ts {\n\tu8 data[8];\n\t__le32 timestamp_us;\n} __packed;\n\nstruct classic_can_quirk {\n\tu8 data[8];\n\tu8 quirk;\n} __packed;\n\nstruct canfd {\n\tu8 data[64];\n} __packed;\n\nstruct canfd_ts {\n\tu8 data[64];\n\t__le32 timestamp_us;\n} __packed;\n\nstruct canfd_quirk {\n\tu8 data[64];\n\tu8 quirk;\n} __packed;\n\nstruct gs_host_frame {\n\tu32 echo_id;\n\t__le32 can_id;\n\n\tu8 can_dlc;\n\tu8 channel;\n\tu8 flags;\n\tu8 reserved;\n\n\tunion {\n\t\tDECLARE_FLEX_ARRAY(struct classic_can, classic_can);\n\t\tDECLARE_FLEX_ARRAY(struct classic_can_ts, classic_can_ts);\n\t\tDECLARE_FLEX_ARRAY(struct classic_can_quirk, classic_can_quirk);\n\t\tDECLARE_FLEX_ARRAY(struct canfd, canfd);\n\t\tDECLARE_FLEX_ARRAY(struct canfd_ts, canfd_ts);\n\t\tDECLARE_FLEX_ARRAY(struct canfd_quirk, canfd_quirk);\n\t};\n} __packed;\n \n\n \n#define GS_MAX_TX_URBS 10\n \n#define GS_MAX_RX_URBS 30\n#define GS_NAPI_WEIGHT 32\n\n \n#define GS_MAX_INTF 3\n\nstruct gs_tx_context {\n\tstruct gs_can *dev;\n\tunsigned int echo_id;\n};\n\nstruct gs_can {\n\tstruct can_priv can;  \n\n\tstruct can_rx_offload offload;\n\tstruct gs_usb *parent;\n\n\tstruct net_device *netdev;\n\tstruct usb_device *udev;\n\n\tstruct can_bittiming_const bt_const, data_bt_const;\n\tunsigned int channel;\t \n\n\tu32 feature;\n\tunsigned int hf_size_tx;\n\n\t \n\tspinlock_t tx_ctx_lock;\n\tstruct gs_tx_context tx_context[GS_MAX_TX_URBS];\n\n\tstruct usb_anchor tx_submitted;\n\tatomic_t active_tx_urbs;\n};\n\n \nstruct gs_usb {\n\tstruct gs_can *canch[GS_MAX_INTF];\n\tstruct usb_anchor rx_submitted;\n\tstruct usb_device *udev;\n\n\t \n\tstruct cyclecounter cc;\n\tstruct timecounter tc;\n\tspinlock_t tc_lock;  \n\tstruct delayed_work timestamp;\n\n\tunsigned int hf_size_rx;\n\tu8 active_channels;\n};\n\n \nstatic struct gs_tx_context *gs_alloc_tx_context(struct gs_can *dev)\n{\n\tint i = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->tx_ctx_lock, flags);\n\n\tfor (; i < GS_MAX_TX_URBS; i++) {\n\t\tif (dev->tx_context[i].echo_id == GS_MAX_TX_URBS) {\n\t\t\tdev->tx_context[i].echo_id = i;\n\t\t\tspin_unlock_irqrestore(&dev->tx_ctx_lock, flags);\n\t\t\treturn &dev->tx_context[i];\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&dev->tx_ctx_lock, flags);\n\treturn NULL;\n}\n\n \nstatic void gs_free_tx_context(struct gs_tx_context *txc)\n{\n\ttxc->echo_id = GS_MAX_TX_URBS;\n}\n\n \nstatic struct gs_tx_context *gs_get_tx_context(struct gs_can *dev,\n\t\t\t\t\t       unsigned int id)\n{\n\tunsigned long flags;\n\n\tif (id < GS_MAX_TX_URBS) {\n\t\tspin_lock_irqsave(&dev->tx_ctx_lock, flags);\n\t\tif (dev->tx_context[id].echo_id == id) {\n\t\t\tspin_unlock_irqrestore(&dev->tx_ctx_lock, flags);\n\t\t\treturn &dev->tx_context[id];\n\t\t}\n\t\tspin_unlock_irqrestore(&dev->tx_ctx_lock, flags);\n\t}\n\treturn NULL;\n}\n\nstatic int gs_cmd_reset(struct gs_can *dev)\n{\n\tstruct gs_device_mode dm = {\n\t\t.mode = GS_CAN_MODE_RESET,\n\t};\n\n\treturn usb_control_msg_send(dev->udev, 0, GS_USB_BREQ_MODE,\n\t\t\t\t    USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t\t    dev->channel, 0, &dm, sizeof(dm), 1000,\n\t\t\t\t    GFP_KERNEL);\n}\n\nstatic inline int gs_usb_get_timestamp(const struct gs_usb *parent,\n\t\t\t\t       u32 *timestamp_p)\n{\n\t__le32 timestamp;\n\tint rc;\n\n\trc = usb_control_msg_recv(parent->udev, 0, GS_USB_BREQ_TIMESTAMP,\n\t\t\t\t  USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t\t  0, 0,\n\t\t\t\t  &timestamp, sizeof(timestamp),\n\t\t\t\t  USB_CTRL_GET_TIMEOUT,\n\t\t\t\t  GFP_KERNEL);\n\tif (rc)\n\t\treturn rc;\n\n\t*timestamp_p = le32_to_cpu(timestamp);\n\n\treturn 0;\n}\n\nstatic u64 gs_usb_timestamp_read(const struct cyclecounter *cc) __must_hold(&dev->tc_lock)\n{\n\tstruct gs_usb *parent = container_of(cc, struct gs_usb, cc);\n\tu32 timestamp = 0;\n\tint err;\n\n\tlockdep_assert_held(&parent->tc_lock);\n\n\t \n\tspin_unlock_bh(&parent->tc_lock);\n\terr = gs_usb_get_timestamp(parent, &timestamp);\n\tspin_lock_bh(&parent->tc_lock);\n\tif (err)\n\t\tdev_err(&parent->udev->dev,\n\t\t\t\"Error %d while reading timestamp. HW timestamps may be inaccurate.\",\n\t\t\terr);\n\n\treturn timestamp;\n}\n\nstatic void gs_usb_timestamp_work(struct work_struct *work)\n{\n\tstruct delayed_work *delayed_work = to_delayed_work(work);\n\tstruct gs_usb *parent;\n\n\tparent = container_of(delayed_work, struct gs_usb, timestamp);\n\tspin_lock_bh(&parent->tc_lock);\n\ttimecounter_read(&parent->tc);\n\tspin_unlock_bh(&parent->tc_lock);\n\n\tschedule_delayed_work(&parent->timestamp,\n\t\t\t      GS_USB_TIMESTAMP_WORK_DELAY_SEC * HZ);\n}\n\nstatic void gs_usb_skb_set_timestamp(struct gs_can *dev,\n\t\t\t\t     struct sk_buff *skb, u32 timestamp)\n{\n\tstruct skb_shared_hwtstamps *hwtstamps = skb_hwtstamps(skb);\n\tstruct gs_usb *parent = dev->parent;\n\tu64 ns;\n\n\tspin_lock_bh(&parent->tc_lock);\n\tns = timecounter_cyc2time(&parent->tc, timestamp);\n\tspin_unlock_bh(&parent->tc_lock);\n\n\thwtstamps->hwtstamp = ns_to_ktime(ns);\n}\n\nstatic void gs_usb_timestamp_init(struct gs_usb *parent)\n{\n\tstruct cyclecounter *cc = &parent->cc;\n\n\tcc->read = gs_usb_timestamp_read;\n\tcc->mask = CYCLECOUNTER_MASK(32);\n\tcc->shift = 32 - bits_per(NSEC_PER_SEC / GS_USB_TIMESTAMP_TIMER_HZ);\n\tcc->mult = clocksource_hz2mult(GS_USB_TIMESTAMP_TIMER_HZ, cc->shift);\n\n\tspin_lock_init(&parent->tc_lock);\n\tspin_lock_bh(&parent->tc_lock);\n\ttimecounter_init(&parent->tc, &parent->cc, ktime_get_real_ns());\n\tspin_unlock_bh(&parent->tc_lock);\n\n\tINIT_DELAYED_WORK(&parent->timestamp, gs_usb_timestamp_work);\n\tschedule_delayed_work(&parent->timestamp,\n\t\t\t      GS_USB_TIMESTAMP_WORK_DELAY_SEC * HZ);\n}\n\nstatic void gs_usb_timestamp_stop(struct gs_usb *parent)\n{\n\tcancel_delayed_work_sync(&parent->timestamp);\n}\n\nstatic void gs_update_state(struct gs_can *dev, struct can_frame *cf)\n{\n\tstruct can_device_stats *can_stats = &dev->can.can_stats;\n\n\tif (cf->can_id & CAN_ERR_RESTARTED) {\n\t\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\tcan_stats->restarts++;\n\t} else if (cf->can_id & CAN_ERR_BUSOFF) {\n\t\tdev->can.state = CAN_STATE_BUS_OFF;\n\t\tcan_stats->bus_off++;\n\t} else if (cf->can_id & CAN_ERR_CRTL) {\n\t\tif ((cf->data[1] & CAN_ERR_CRTL_TX_WARNING) ||\n\t\t    (cf->data[1] & CAN_ERR_CRTL_RX_WARNING)) {\n\t\t\tdev->can.state = CAN_STATE_ERROR_WARNING;\n\t\t\tcan_stats->error_warning++;\n\t\t} else if ((cf->data[1] & CAN_ERR_CRTL_TX_PASSIVE) ||\n\t\t\t   (cf->data[1] & CAN_ERR_CRTL_RX_PASSIVE)) {\n\t\t\tdev->can.state = CAN_STATE_ERROR_PASSIVE;\n\t\t\tcan_stats->error_passive++;\n\t\t} else {\n\t\t\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\t}\n\t}\n}\n\nstatic u32 gs_usb_set_timestamp(struct gs_can *dev, struct sk_buff *skb,\n\t\t\t\tconst struct gs_host_frame *hf)\n{\n\tu32 timestamp;\n\n\tif (hf->flags & GS_CAN_FLAG_FD)\n\t\ttimestamp = le32_to_cpu(hf->canfd_ts->timestamp_us);\n\telse\n\t\ttimestamp = le32_to_cpu(hf->classic_can_ts->timestamp_us);\n\n\tif (skb)\n\t\tgs_usb_skb_set_timestamp(dev, skb, timestamp);\n\n\treturn timestamp;\n}\n\nstatic void gs_usb_rx_offload(struct gs_can *dev, struct sk_buff *skb,\n\t\t\t      const struct gs_host_frame *hf)\n{\n\tstruct can_rx_offload *offload = &dev->offload;\n\tint rc;\n\n\tif (dev->feature & GS_CAN_FEATURE_HW_TIMESTAMP) {\n\t\tconst u32 ts = gs_usb_set_timestamp(dev, skb, hf);\n\n\t\trc = can_rx_offload_queue_timestamp(offload, skb, ts);\n\t} else {\n\t\trc = can_rx_offload_queue_tail(offload, skb);\n\t}\n\n\tif (rc)\n\t\tdev->netdev->stats.rx_fifo_errors++;\n}\n\nstatic unsigned int\ngs_usb_get_echo_skb(struct gs_can *dev, struct sk_buff *skb,\n\t\t    const struct gs_host_frame *hf)\n{\n\tstruct can_rx_offload *offload = &dev->offload;\n\tconst u32 echo_id = hf->echo_id;\n\tunsigned int len;\n\n\tif (dev->feature & GS_CAN_FEATURE_HW_TIMESTAMP) {\n\t\tconst u32 ts = gs_usb_set_timestamp(dev, skb, hf);\n\n\t\tlen = can_rx_offload_get_echo_skb_queue_timestamp(offload, echo_id,\n\t\t\t\t\t\t\t\t  ts, NULL);\n\t} else {\n\t\tlen = can_rx_offload_get_echo_skb_queue_tail(offload, echo_id,\n\t\t\t\t\t\t\t     NULL);\n\t}\n\n\treturn len;\n}\n\nstatic void gs_usb_receive_bulk_callback(struct urb *urb)\n{\n\tstruct gs_usb *parent = urb->context;\n\tstruct gs_can *dev;\n\tstruct net_device *netdev;\n\tint rc;\n\tstruct net_device_stats *stats;\n\tstruct gs_host_frame *hf = urb->transfer_buffer;\n\tstruct gs_tx_context *txc;\n\tstruct can_frame *cf;\n\tstruct canfd_frame *cfd;\n\tstruct sk_buff *skb;\n\n\tBUG_ON(!parent);\n\n\tswitch (urb->status) {\n\tcase 0:  \n\t\tbreak;\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tif (hf->channel >= GS_MAX_INTF)\n\t\tgoto device_detach;\n\n\tdev = parent->canch[hf->channel];\n\n\tnetdev = dev->netdev;\n\tstats = &netdev->stats;\n\n\tif (!netif_device_present(netdev))\n\t\treturn;\n\n\tif (!netif_running(netdev))\n\t\tgoto resubmit_urb;\n\n\tif (hf->echo_id == -1) {  \n\t\tif (hf->flags & GS_CAN_FLAG_FD) {\n\t\t\tskb = alloc_canfd_skb(netdev, &cfd);\n\t\t\tif (!skb)\n\t\t\t\treturn;\n\n\t\t\tcfd->can_id = le32_to_cpu(hf->can_id);\n\t\t\tcfd->len = can_fd_dlc2len(hf->can_dlc);\n\t\t\tif (hf->flags & GS_CAN_FLAG_BRS)\n\t\t\t\tcfd->flags |= CANFD_BRS;\n\t\t\tif (hf->flags & GS_CAN_FLAG_ESI)\n\t\t\t\tcfd->flags |= CANFD_ESI;\n\n\t\t\tmemcpy(cfd->data, hf->canfd->data, cfd->len);\n\t\t} else {\n\t\t\tskb = alloc_can_skb(netdev, &cf);\n\t\t\tif (!skb)\n\t\t\t\treturn;\n\n\t\t\tcf->can_id = le32_to_cpu(hf->can_id);\n\t\t\tcan_frame_set_cc_len(cf, hf->can_dlc, dev->can.ctrlmode);\n\n\t\t\tmemcpy(cf->data, hf->classic_can->data, 8);\n\n\t\t\t \n\t\t\tif (le32_to_cpu(hf->can_id) & CAN_ERR_FLAG)\n\t\t\t\tgs_update_state(dev, cf);\n\t\t}\n\n\t\tgs_usb_rx_offload(dev, skb, hf);\n\t} else {  \n\t\tif (hf->echo_id >= GS_MAX_TX_URBS) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Unexpected out of range echo id %u\\n\",\n\t\t\t\t   hf->echo_id);\n\t\t\tgoto resubmit_urb;\n\t\t}\n\n\t\ttxc = gs_get_tx_context(dev, hf->echo_id);\n\n\t\t \n\t\tif (!txc) {\n\t\t\tnetdev_err(netdev,\n\t\t\t\t   \"Unexpected unused echo id %u\\n\",\n\t\t\t\t   hf->echo_id);\n\t\t\tgoto resubmit_urb;\n\t\t}\n\n\t\tskb = dev->can.echo_skb[hf->echo_id];\n\t\tstats->tx_packets++;\n\t\tstats->tx_bytes += gs_usb_get_echo_skb(dev, skb, hf);\n\t\tgs_free_tx_context(txc);\n\n\t\tatomic_dec(&dev->active_tx_urbs);\n\n\t\tnetif_wake_queue(netdev);\n\t}\n\n\tif (hf->flags & GS_CAN_FLAG_OVERFLOW) {\n\t\tstats->rx_over_errors++;\n\t\tstats->rx_errors++;\n\n\t\tskb = alloc_can_err_skb(netdev, &cf);\n\t\tif (!skb)\n\t\t\tgoto resubmit_urb;\n\n\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\tcf->len = CAN_ERR_DLC;\n\t\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\n\t\tgs_usb_rx_offload(dev, skb, hf);\n\t}\n\n\tcan_rx_offload_irq_finish(&dev->offload);\n\nresubmit_urb:\n\tusb_fill_bulk_urb(urb, parent->udev,\n\t\t\t  usb_rcvbulkpipe(parent->udev, GS_USB_ENDPOINT_IN),\n\t\t\t  hf, dev->parent->hf_size_rx,\n\t\t\t  gs_usb_receive_bulk_callback, parent);\n\n\trc = usb_submit_urb(urb, GFP_ATOMIC);\n\n\t \n\tif (rc == -ENODEV) {\ndevice_detach:\n\t\tfor (rc = 0; rc < GS_MAX_INTF; rc++) {\n\t\t\tif (parent->canch[rc])\n\t\t\t\tnetif_device_detach(parent->canch[rc]->netdev);\n\t\t}\n\t}\n}\n\nstatic int gs_usb_set_bittiming(struct net_device *netdev)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct can_bittiming *bt = &dev->can.bittiming;\n\tstruct gs_device_bittiming dbt = {\n\t\t.prop_seg = cpu_to_le32(bt->prop_seg),\n\t\t.phase_seg1 = cpu_to_le32(bt->phase_seg1),\n\t\t.phase_seg2 = cpu_to_le32(bt->phase_seg2),\n\t\t.sjw = cpu_to_le32(bt->sjw),\n\t\t.brp = cpu_to_le32(bt->brp),\n\t};\n\n\t \n\treturn usb_control_msg_send(dev->udev, 0, GS_USB_BREQ_BITTIMING,\n\t\t\t\t    USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t\t    dev->channel, 0, &dbt, sizeof(dbt), 1000,\n\t\t\t\t    GFP_KERNEL);\n}\n\nstatic int gs_usb_set_data_bittiming(struct net_device *netdev)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct can_bittiming *bt = &dev->can.data_bittiming;\n\tstruct gs_device_bittiming dbt = {\n\t\t.prop_seg = cpu_to_le32(bt->prop_seg),\n\t\t.phase_seg1 = cpu_to_le32(bt->phase_seg1),\n\t\t.phase_seg2 = cpu_to_le32(bt->phase_seg2),\n\t\t.sjw = cpu_to_le32(bt->sjw),\n\t\t.brp = cpu_to_le32(bt->brp),\n\t};\n\tu8 request = GS_USB_BREQ_DATA_BITTIMING;\n\n\tif (dev->feature & GS_CAN_FEATURE_QUIRK_BREQ_CANTACT_PRO)\n\t\trequest = GS_USB_BREQ_QUIRK_CANTACT_PRO_DATA_BITTIMING;\n\n\t \n\treturn usb_control_msg_send(dev->udev, 0, request,\n\t\t\t\t    USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t\t    dev->channel, 0, &dbt, sizeof(dbt), 1000,\n\t\t\t\t    GFP_KERNEL);\n}\n\nstatic void gs_usb_xmit_callback(struct urb *urb)\n{\n\tstruct gs_tx_context *txc = urb->context;\n\tstruct gs_can *dev = txc->dev;\n\tstruct net_device *netdev = dev->netdev;\n\n\tif (urb->status)\n\t\tnetdev_info(netdev, \"usb xmit fail %u\\n\", txc->echo_id);\n}\n\nstatic netdev_tx_t gs_can_start_xmit(struct sk_buff *skb,\n\t\t\t\t     struct net_device *netdev)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct net_device_stats *stats = &dev->netdev->stats;\n\tstruct urb *urb;\n\tstruct gs_host_frame *hf;\n\tstruct can_frame *cf;\n\tstruct canfd_frame *cfd;\n\tint rc;\n\tunsigned int idx;\n\tstruct gs_tx_context *txc;\n\n\tif (can_dev_dropped_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\t \n\ttxc = gs_alloc_tx_context(dev);\n\tif (!txc)\n\t\treturn NETDEV_TX_BUSY;\n\n\t \n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\tgoto nomem_urb;\n\n\thf = kmalloc(dev->hf_size_tx, GFP_ATOMIC);\n\tif (!hf)\n\t\tgoto nomem_hf;\n\n\tidx = txc->echo_id;\n\n\tif (idx >= GS_MAX_TX_URBS) {\n\t\tnetdev_err(netdev, \"Invalid tx context %u\\n\", idx);\n\t\tgoto badidx;\n\t}\n\n\thf->echo_id = idx;\n\thf->channel = dev->channel;\n\thf->flags = 0;\n\thf->reserved = 0;\n\n\tif (can_is_canfd_skb(skb)) {\n\t\tcfd = (struct canfd_frame *)skb->data;\n\n\t\thf->can_id = cpu_to_le32(cfd->can_id);\n\t\thf->can_dlc = can_fd_len2dlc(cfd->len);\n\t\thf->flags |= GS_CAN_FLAG_FD;\n\t\tif (cfd->flags & CANFD_BRS)\n\t\t\thf->flags |= GS_CAN_FLAG_BRS;\n\t\tif (cfd->flags & CANFD_ESI)\n\t\t\thf->flags |= GS_CAN_FLAG_ESI;\n\n\t\tmemcpy(hf->canfd->data, cfd->data, cfd->len);\n\t} else {\n\t\tcf = (struct can_frame *)skb->data;\n\n\t\thf->can_id = cpu_to_le32(cf->can_id);\n\t\thf->can_dlc = can_get_cc_dlc(cf, dev->can.ctrlmode);\n\n\t\tmemcpy(hf->classic_can->data, cf->data, cf->len);\n\t}\n\n\tusb_fill_bulk_urb(urb, dev->udev,\n\t\t\t  usb_sndbulkpipe(dev->udev, GS_USB_ENDPOINT_OUT),\n\t\t\t  hf, dev->hf_size_tx,\n\t\t\t  gs_usb_xmit_callback, txc);\n\n\turb->transfer_flags |= URB_FREE_BUFFER;\n\tusb_anchor_urb(urb, &dev->tx_submitted);\n\n\tcan_put_echo_skb(skb, netdev, idx, 0);\n\n\tatomic_inc(&dev->active_tx_urbs);\n\n\trc = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(rc)) {\t\t\t \n\t\tatomic_dec(&dev->active_tx_urbs);\n\n\t\tcan_free_echo_skb(netdev, idx, NULL);\n\t\tgs_free_tx_context(txc);\n\n\t\tusb_unanchor_urb(urb);\n\n\t\tif (rc == -ENODEV) {\n\t\t\tnetif_device_detach(netdev);\n\t\t} else {\n\t\t\tnetdev_err(netdev, \"usb_submit failed (err=%d)\\n\", rc);\n\t\t\tstats->tx_dropped++;\n\t\t}\n\t} else {\n\t\t \n\t\tif (atomic_read(&dev->active_tx_urbs) >= GS_MAX_TX_URBS)\n\t\t\tnetif_stop_queue(netdev);\n\t}\n\n\t \n\tusb_free_urb(urb);\n\n\treturn NETDEV_TX_OK;\n\nbadidx:\n\tkfree(hf);\nnomem_hf:\n\tusb_free_urb(urb);\n\nnomem_urb:\n\tgs_free_tx_context(txc);\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\treturn NETDEV_TX_OK;\n}\n\nstatic int gs_can_open(struct net_device *netdev)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct gs_usb *parent = dev->parent;\n\tstruct gs_device_mode dm = {\n\t\t.mode = cpu_to_le32(GS_CAN_MODE_START),\n\t};\n\tstruct gs_host_frame *hf;\n\tstruct urb *urb = NULL;\n\tu32 ctrlmode;\n\tu32 flags = 0;\n\tint rc, i;\n\n\trc = open_candev(netdev);\n\tif (rc)\n\t\treturn rc;\n\n\tctrlmode = dev->can.ctrlmode;\n\tif (ctrlmode & CAN_CTRLMODE_FD) {\n\t\tif (dev->feature & GS_CAN_FEATURE_REQ_USB_QUIRK_LPC546XX)\n\t\t\tdev->hf_size_tx = struct_size(hf, canfd_quirk, 1);\n\t\telse\n\t\t\tdev->hf_size_tx = struct_size(hf, canfd, 1);\n\t} else {\n\t\tif (dev->feature & GS_CAN_FEATURE_REQ_USB_QUIRK_LPC546XX)\n\t\t\tdev->hf_size_tx = struct_size(hf, classic_can_quirk, 1);\n\t\telse\n\t\t\tdev->hf_size_tx = struct_size(hf, classic_can, 1);\n\t}\n\n\tcan_rx_offload_enable(&dev->offload);\n\n\tif (!parent->active_channels) {\n\t\tif (dev->feature & GS_CAN_FEATURE_HW_TIMESTAMP)\n\t\t\tgs_usb_timestamp_init(parent);\n\n\t\tfor (i = 0; i < GS_MAX_RX_URBS; i++) {\n\t\t\tu8 *buf;\n\n\t\t\t \n\t\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\t\tif (!urb) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out_usb_kill_anchored_urbs;\n\t\t\t}\n\n\t\t\t \n\t\t\tbuf = kmalloc(dev->parent->hf_size_rx,\n\t\t\t\t      GFP_KERNEL);\n\t\t\tif (!buf) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto out_usb_free_urb;\n\t\t\t}\n\n\t\t\t \n\t\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t\t  dev->udev,\n\t\t\t\t\t  usb_rcvbulkpipe(dev->udev,\n\t\t\t\t\t\t\t  GS_USB_ENDPOINT_IN),\n\t\t\t\t\t  buf,\n\t\t\t\t\t  dev->parent->hf_size_rx,\n\t\t\t\t\t  gs_usb_receive_bulk_callback, parent);\n\t\t\turb->transfer_flags |= URB_FREE_BUFFER;\n\n\t\t\tusb_anchor_urb(urb, &parent->rx_submitted);\n\n\t\t\trc = usb_submit_urb(urb, GFP_KERNEL);\n\t\t\tif (rc) {\n\t\t\t\tif (rc == -ENODEV)\n\t\t\t\t\tnetif_device_detach(dev->netdev);\n\n\t\t\t\tnetdev_err(netdev,\n\t\t\t\t\t   \"usb_submit_urb() failed, error %pe\\n\",\n\t\t\t\t\t   ERR_PTR(rc));\n\n\t\t\t\tgoto out_usb_unanchor_urb;\n\t\t\t}\n\n\t\t\t \n\t\t\tusb_free_urb(urb);\n\t\t}\n\t}\n\n\t \n\tif (ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\tflags |= GS_CAN_MODE_LOOP_BACK;\n\n\tif (ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tflags |= GS_CAN_MODE_LISTEN_ONLY;\n\n\tif (ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\tflags |= GS_CAN_MODE_TRIPLE_SAMPLE;\n\n\tif (ctrlmode & CAN_CTRLMODE_ONE_SHOT)\n\t\tflags |= GS_CAN_MODE_ONE_SHOT;\n\n\tif (ctrlmode & CAN_CTRLMODE_BERR_REPORTING)\n\t\tflags |= GS_CAN_MODE_BERR_REPORTING;\n\n\tif (ctrlmode & CAN_CTRLMODE_FD)\n\t\tflags |= GS_CAN_MODE_FD;\n\n\t \n\tif (dev->feature & GS_CAN_FEATURE_HW_TIMESTAMP)\n\t\tflags |= GS_CAN_MODE_HW_TIMESTAMP;\n\n\t \n\tdev->can.state = CAN_STATE_ERROR_ACTIVE;\n\tdm.flags = cpu_to_le32(flags);\n\trc = usb_control_msg_send(dev->udev, 0, GS_USB_BREQ_MODE,\n\t\t\t\t  USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t\t  dev->channel, 0, &dm, sizeof(dm), 1000,\n\t\t\t\t  GFP_KERNEL);\n\tif (rc) {\n\t\tnetdev_err(netdev, \"Couldn't start device (err=%d)\\n\", rc);\n\t\tdev->can.state = CAN_STATE_STOPPED;\n\n\t\tgoto out_usb_kill_anchored_urbs;\n\t}\n\n\tparent->active_channels++;\n\tif (!(dev->can.ctrlmode & CAN_CTRLMODE_LISTENONLY))\n\t\tnetif_start_queue(netdev);\n\n\treturn 0;\n\nout_usb_unanchor_urb:\n\tusb_unanchor_urb(urb);\nout_usb_free_urb:\n\tusb_free_urb(urb);\nout_usb_kill_anchored_urbs:\n\tif (!parent->active_channels) {\n\t\tusb_kill_anchored_urbs(&dev->tx_submitted);\n\n\t\tif (dev->feature & GS_CAN_FEATURE_HW_TIMESTAMP)\n\t\t\tgs_usb_timestamp_stop(parent);\n\t}\n\n\tcan_rx_offload_disable(&dev->offload);\n\tclose_candev(netdev);\n\n\treturn rc;\n}\n\nstatic int gs_usb_get_state(const struct net_device *netdev,\n\t\t\t    struct can_berr_counter *bec,\n\t\t\t    enum can_state *state)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct gs_device_state ds;\n\tint rc;\n\n\trc = usb_control_msg_recv(dev->udev, 0, GS_USB_BREQ_GET_STATE,\n\t\t\t\t  USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t\t  dev->channel, 0,\n\t\t\t\t  &ds, sizeof(ds),\n\t\t\t\t  USB_CTRL_GET_TIMEOUT,\n\t\t\t\t  GFP_KERNEL);\n\tif (rc)\n\t\treturn rc;\n\n\tif (le32_to_cpu(ds.state) >= CAN_STATE_MAX)\n\t\treturn -EOPNOTSUPP;\n\n\t*state = le32_to_cpu(ds.state);\n\tbec->txerr = le32_to_cpu(ds.txerr);\n\tbec->rxerr = le32_to_cpu(ds.rxerr);\n\n\treturn 0;\n}\n\nstatic int gs_usb_can_get_berr_counter(const struct net_device *netdev,\n\t\t\t\t       struct can_berr_counter *bec)\n{\n\tenum can_state state;\n\n\treturn gs_usb_get_state(netdev, bec, &state);\n}\n\nstatic int gs_can_close(struct net_device *netdev)\n{\n\tint rc;\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct gs_usb *parent = dev->parent;\n\n\tnetif_stop_queue(netdev);\n\n\t \n\tparent->active_channels--;\n\tif (!parent->active_channels) {\n\t\tusb_kill_anchored_urbs(&parent->rx_submitted);\n\n\t\tif (dev->feature & GS_CAN_FEATURE_HW_TIMESTAMP)\n\t\t\tgs_usb_timestamp_stop(parent);\n\t}\n\n\t \n\tusb_kill_anchored_urbs(&dev->tx_submitted);\n\tatomic_set(&dev->active_tx_urbs, 0);\n\n\tdev->can.state = CAN_STATE_STOPPED;\n\n\t \n\tgs_cmd_reset(dev);\n\n\t \n\tfor (rc = 0; rc < GS_MAX_TX_URBS; rc++) {\n\t\tdev->tx_context[rc].dev = dev;\n\t\tdev->tx_context[rc].echo_id = GS_MAX_TX_URBS;\n\t}\n\n\tcan_rx_offload_disable(&dev->offload);\n\n\t \n\tclose_candev(netdev);\n\n\treturn 0;\n}\n\nstatic int gs_can_eth_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\n{\n\tconst struct gs_can *dev = netdev_priv(netdev);\n\n\tif (dev->feature & GS_CAN_FEATURE_HW_TIMESTAMP)\n\t\treturn can_eth_ioctl_hwts(netdev, ifr, cmd);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct net_device_ops gs_usb_netdev_ops = {\n\t.ndo_open = gs_can_open,\n\t.ndo_stop = gs_can_close,\n\t.ndo_start_xmit = gs_can_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n\t.ndo_eth_ioctl = gs_can_eth_ioctl,\n};\n\nstatic int gs_usb_set_identify(struct net_device *netdev, bool do_identify)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct gs_identify_mode imode;\n\n\tif (do_identify)\n\t\timode.mode = cpu_to_le32(GS_CAN_IDENTIFY_ON);\n\telse\n\t\timode.mode = cpu_to_le32(GS_CAN_IDENTIFY_OFF);\n\n\treturn usb_control_msg_send(dev->udev, 0, GS_USB_BREQ_IDENTIFY,\n\t\t\t\t    USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t\t    dev->channel, 0, &imode, sizeof(imode), 100,\n\t\t\t\t    GFP_KERNEL);\n}\n\n \nstatic int gs_usb_set_phys_id(struct net_device *netdev,\n\t\t\t      enum ethtool_phys_id_state state)\n{\n\tconst struct gs_can *dev = netdev_priv(netdev);\n\tint rc = 0;\n\n\tif (!(dev->feature & GS_CAN_FEATURE_IDENTIFY))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (state) {\n\tcase ETHTOOL_ID_ACTIVE:\n\t\trc = gs_usb_set_identify(netdev, GS_CAN_IDENTIFY_ON);\n\t\tbreak;\n\tcase ETHTOOL_ID_INACTIVE:\n\t\trc = gs_usb_set_identify(netdev, GS_CAN_IDENTIFY_OFF);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rc;\n}\n\nstatic int gs_usb_get_ts_info(struct net_device *netdev,\n\t\t\t      struct ethtool_ts_info *info)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\n\t \n\tif (dev->feature & GS_CAN_FEATURE_HW_TIMESTAMP)\n\t\treturn can_ethtool_op_get_ts_info_hwts(netdev, info);\n\n\treturn ethtool_op_get_ts_info(netdev, info);\n}\n\nstatic const struct ethtool_ops gs_usb_ethtool_ops = {\n\t.set_phys_id = gs_usb_set_phys_id,\n\t.get_ts_info = gs_usb_get_ts_info,\n};\n\nstatic int gs_usb_get_termination(struct net_device *netdev, u16 *term)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct gs_device_termination_state term_state;\n\tint rc;\n\n\trc = usb_control_msg_recv(dev->udev, 0, GS_USB_BREQ_GET_TERMINATION,\n\t\t\t\t  USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t\t  dev->channel, 0,\n\t\t\t\t  &term_state, sizeof(term_state), 1000,\n\t\t\t\t  GFP_KERNEL);\n\tif (rc)\n\t\treturn rc;\n\n\tif (term_state.state == cpu_to_le32(GS_CAN_TERMINATION_STATE_ON))\n\t\t*term = GS_USB_TERMINATION_ENABLED;\n\telse\n\t\t*term = GS_USB_TERMINATION_DISABLED;\n\n\treturn 0;\n}\n\nstatic int gs_usb_set_termination(struct net_device *netdev, u16 term)\n{\n\tstruct gs_can *dev = netdev_priv(netdev);\n\tstruct gs_device_termination_state term_state;\n\n\tif (term == GS_USB_TERMINATION_ENABLED)\n\t\tterm_state.state = cpu_to_le32(GS_CAN_TERMINATION_STATE_ON);\n\telse\n\t\tterm_state.state = cpu_to_le32(GS_CAN_TERMINATION_STATE_OFF);\n\n\treturn usb_control_msg_send(dev->udev, 0, GS_USB_BREQ_SET_TERMINATION,\n\t\t\t\t    USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t\t    dev->channel, 0,\n\t\t\t\t    &term_state, sizeof(term_state), 1000,\n\t\t\t\t    GFP_KERNEL);\n}\n\nstatic const u16 gs_usb_termination_const[] = {\n\tGS_USB_TERMINATION_DISABLED,\n\tGS_USB_TERMINATION_ENABLED\n};\n\nstatic struct gs_can *gs_make_candev(unsigned int channel,\n\t\t\t\t     struct usb_interface *intf,\n\t\t\t\t     struct gs_device_config *dconf)\n{\n\tstruct gs_can *dev;\n\tstruct net_device *netdev;\n\tint rc;\n\tstruct gs_device_bt_const_extended bt_const_extended;\n\tstruct gs_device_bt_const bt_const;\n\tu32 feature;\n\n\t \n\trc = usb_control_msg_recv(interface_to_usbdev(intf), 0,\n\t\t\t\t  GS_USB_BREQ_BT_CONST,\n\t\t\t\t  USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t\t  channel, 0, &bt_const, sizeof(bt_const), 1000,\n\t\t\t\t  GFP_KERNEL);\n\n\tif (rc) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Couldn't get bit timing const for channel %d (%pe)\\n\",\n\t\t\tchannel, ERR_PTR(rc));\n\t\treturn ERR_PTR(rc);\n\t}\n\n\t \n\tnetdev = alloc_candev(sizeof(struct gs_can), GS_MAX_TX_URBS);\n\tif (!netdev) {\n\t\tdev_err(&intf->dev, \"Couldn't allocate candev\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tdev = netdev_priv(netdev);\n\n\tnetdev->netdev_ops = &gs_usb_netdev_ops;\n\tnetdev->ethtool_ops = &gs_usb_ethtool_ops;\n\n\tnetdev->flags |= IFF_ECHO;  \n\tnetdev->dev_id = channel;\n\n\t \n\tstrcpy(dev->bt_const.name, KBUILD_MODNAME);\n\tdev->bt_const.tseg1_min = le32_to_cpu(bt_const.tseg1_min);\n\tdev->bt_const.tseg1_max = le32_to_cpu(bt_const.tseg1_max);\n\tdev->bt_const.tseg2_min = le32_to_cpu(bt_const.tseg2_min);\n\tdev->bt_const.tseg2_max = le32_to_cpu(bt_const.tseg2_max);\n\tdev->bt_const.sjw_max = le32_to_cpu(bt_const.sjw_max);\n\tdev->bt_const.brp_min = le32_to_cpu(bt_const.brp_min);\n\tdev->bt_const.brp_max = le32_to_cpu(bt_const.brp_max);\n\tdev->bt_const.brp_inc = le32_to_cpu(bt_const.brp_inc);\n\n\tdev->udev = interface_to_usbdev(intf);\n\tdev->netdev = netdev;\n\tdev->channel = channel;\n\n\tinit_usb_anchor(&dev->tx_submitted);\n\tatomic_set(&dev->active_tx_urbs, 0);\n\tspin_lock_init(&dev->tx_ctx_lock);\n\tfor (rc = 0; rc < GS_MAX_TX_URBS; rc++) {\n\t\tdev->tx_context[rc].dev = dev;\n\t\tdev->tx_context[rc].echo_id = GS_MAX_TX_URBS;\n\t}\n\n\t \n\tdev->can.state = CAN_STATE_STOPPED;\n\tdev->can.clock.freq = le32_to_cpu(bt_const.fclk_can);\n\tdev->can.bittiming_const = &dev->bt_const;\n\tdev->can.do_set_bittiming = gs_usb_set_bittiming;\n\n\tdev->can.ctrlmode_supported = CAN_CTRLMODE_CC_LEN8_DLC;\n\n\tfeature = le32_to_cpu(bt_const.feature);\n\tdev->feature = FIELD_GET(GS_CAN_FEATURE_MASK, feature);\n\tif (feature & GS_CAN_FEATURE_LISTEN_ONLY)\n\t\tdev->can.ctrlmode_supported |= CAN_CTRLMODE_LISTENONLY;\n\n\tif (feature & GS_CAN_FEATURE_LOOP_BACK)\n\t\tdev->can.ctrlmode_supported |= CAN_CTRLMODE_LOOPBACK;\n\n\tif (feature & GS_CAN_FEATURE_TRIPLE_SAMPLE)\n\t\tdev->can.ctrlmode_supported |= CAN_CTRLMODE_3_SAMPLES;\n\n\tif (feature & GS_CAN_FEATURE_ONE_SHOT)\n\t\tdev->can.ctrlmode_supported |= CAN_CTRLMODE_ONE_SHOT;\n\n\tif (feature & GS_CAN_FEATURE_FD) {\n\t\tdev->can.ctrlmode_supported |= CAN_CTRLMODE_FD;\n\t\t \n\t\tdev->can.data_bittiming_const = &dev->bt_const;\n\t\tdev->can.do_set_data_bittiming = gs_usb_set_data_bittiming;\n\t}\n\n\tif (feature & GS_CAN_FEATURE_TERMINATION) {\n\t\trc = gs_usb_get_termination(netdev, &dev->can.termination);\n\t\tif (rc) {\n\t\t\tdev->feature &= ~GS_CAN_FEATURE_TERMINATION;\n\n\t\t\tdev_info(&intf->dev,\n\t\t\t\t \"Disabling termination support for channel %d (%pe)\\n\",\n\t\t\t\t channel, ERR_PTR(rc));\n\t\t} else {\n\t\t\tdev->can.termination_const = gs_usb_termination_const;\n\t\t\tdev->can.termination_const_cnt = ARRAY_SIZE(gs_usb_termination_const);\n\t\t\tdev->can.do_set_termination = gs_usb_set_termination;\n\t\t}\n\t}\n\n\tif (feature & GS_CAN_FEATURE_BERR_REPORTING)\n\t\tdev->can.ctrlmode_supported |= CAN_CTRLMODE_BERR_REPORTING;\n\n\tif (feature & GS_CAN_FEATURE_GET_STATE)\n\t\tdev->can.do_get_berr_counter = gs_usb_can_get_berr_counter;\n\n\t \n\tif (dev->udev->descriptor.idVendor == cpu_to_le16(USB_GS_USB_1_VENDOR_ID) &&\n\t    dev->udev->descriptor.idProduct == cpu_to_le16(USB_GS_USB_1_PRODUCT_ID) &&\n\t    dev->udev->manufacturer && dev->udev->product &&\n\t    !strcmp(dev->udev->manufacturer, \"LinkLayer Labs\") &&\n\t    !strcmp(dev->udev->product, \"CANtact Pro\") &&\n\t    (le32_to_cpu(dconf->sw_version) <= 2))\n\t\tdev->feature |= GS_CAN_FEATURE_REQ_USB_QUIRK_LPC546XX |\n\t\t\tGS_CAN_FEATURE_QUIRK_BREQ_CANTACT_PRO;\n\n\t \n\tif (!(le32_to_cpu(dconf->sw_version) > 1 &&\n\t      feature & GS_CAN_FEATURE_IDENTIFY))\n\t\tdev->feature &= ~GS_CAN_FEATURE_IDENTIFY;\n\n\t \n\tif (feature & GS_CAN_FEATURE_FD &&\n\t    feature & GS_CAN_FEATURE_BT_CONST_EXT) {\n\t\trc = usb_control_msg_recv(interface_to_usbdev(intf), 0,\n\t\t\t\t\t  GS_USB_BREQ_BT_CONST_EXT,\n\t\t\t\t\t  USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t\t\t  channel, 0, &bt_const_extended,\n\t\t\t\t\t  sizeof(bt_const_extended),\n\t\t\t\t\t  1000, GFP_KERNEL);\n\t\tif (rc) {\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"Couldn't get extended bit timing const for channel %d (%pe)\\n\",\n\t\t\t\tchannel, ERR_PTR(rc));\n\t\t\tgoto out_free_candev;\n\t\t}\n\n\t\tstrcpy(dev->data_bt_const.name, KBUILD_MODNAME);\n\t\tdev->data_bt_const.tseg1_min = le32_to_cpu(bt_const_extended.dtseg1_min);\n\t\tdev->data_bt_const.tseg1_max = le32_to_cpu(bt_const_extended.dtseg1_max);\n\t\tdev->data_bt_const.tseg2_min = le32_to_cpu(bt_const_extended.dtseg2_min);\n\t\tdev->data_bt_const.tseg2_max = le32_to_cpu(bt_const_extended.dtseg2_max);\n\t\tdev->data_bt_const.sjw_max = le32_to_cpu(bt_const_extended.dsjw_max);\n\t\tdev->data_bt_const.brp_min = le32_to_cpu(bt_const_extended.dbrp_min);\n\t\tdev->data_bt_const.brp_max = le32_to_cpu(bt_const_extended.dbrp_max);\n\t\tdev->data_bt_const.brp_inc = le32_to_cpu(bt_const_extended.dbrp_inc);\n\n\t\tdev->can.data_bittiming_const = &dev->data_bt_const;\n\t}\n\n\tcan_rx_offload_add_manual(netdev, &dev->offload, GS_NAPI_WEIGHT);\n\tSET_NETDEV_DEV(netdev, &intf->dev);\n\n\trc = register_candev(dev->netdev);\n\tif (rc) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Couldn't register candev for channel %d (%pe)\\n\",\n\t\t\tchannel, ERR_PTR(rc));\n\t\tgoto out_can_rx_offload_del;\n\t}\n\n\treturn dev;\n\nout_can_rx_offload_del:\n\tcan_rx_offload_del(&dev->offload);\nout_free_candev:\n\tfree_candev(dev->netdev);\n\treturn ERR_PTR(rc);\n}\n\nstatic void gs_destroy_candev(struct gs_can *dev)\n{\n\tunregister_candev(dev->netdev);\n\tcan_rx_offload_del(&dev->offload);\n\tfree_candev(dev->netdev);\n}\n\nstatic int gs_usb_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct gs_host_frame *hf;\n\tstruct gs_usb *parent;\n\tstruct gs_host_config hconf = {\n\t\t.byte_order = cpu_to_le32(0x0000beef),\n\t};\n\tstruct gs_device_config dconf;\n\tunsigned int icount, i;\n\tint rc;\n\n\t \n\trc = usb_control_msg_send(udev, 0,\n\t\t\t\t  GS_USB_BREQ_HOST_FORMAT,\n\t\t\t\t  USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t\t  1, intf->cur_altsetting->desc.bInterfaceNumber,\n\t\t\t\t  &hconf, sizeof(hconf), 1000,\n\t\t\t\t  GFP_KERNEL);\n\tif (rc) {\n\t\tdev_err(&intf->dev, \"Couldn't send data format (err=%d)\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t \n\trc = usb_control_msg_recv(udev, 0,\n\t\t\t\t  GS_USB_BREQ_DEVICE_CONFIG,\n\t\t\t\t  USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\n\t\t\t\t  1, intf->cur_altsetting->desc.bInterfaceNumber,\n\t\t\t\t  &dconf, sizeof(dconf), 1000,\n\t\t\t\t  GFP_KERNEL);\n\tif (rc) {\n\t\tdev_err(&intf->dev, \"Couldn't get device config: (err=%d)\\n\",\n\t\t\trc);\n\t\treturn rc;\n\t}\n\n\ticount = dconf.icount + 1;\n\tdev_info(&intf->dev, \"Configuring for %u interfaces\\n\", icount);\n\n\tif (icount > GS_MAX_INTF) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Driver cannot handle more that %u CAN interfaces\\n\",\n\t\t\tGS_MAX_INTF);\n\t\treturn -EINVAL;\n\t}\n\n\tparent = kzalloc(sizeof(*parent), GFP_KERNEL);\n\tif (!parent)\n\t\treturn -ENOMEM;\n\n\tinit_usb_anchor(&parent->rx_submitted);\n\n\tusb_set_intfdata(intf, parent);\n\tparent->udev = udev;\n\n\tfor (i = 0; i < icount; i++) {\n\t\tunsigned int hf_size_rx = 0;\n\n\t\tparent->canch[i] = gs_make_candev(i, intf, &dconf);\n\t\tif (IS_ERR_OR_NULL(parent->canch[i])) {\n\t\t\t \n\t\t\trc = PTR_ERR(parent->canch[i]);\n\n\t\t\t \n\t\t\ticount = i;\n\t\t\tfor (i = 0; i < icount; i++)\n\t\t\t\tgs_destroy_candev(parent->canch[i]);\n\n\t\t\tusb_kill_anchored_urbs(&parent->rx_submitted);\n\t\t\tkfree(parent);\n\t\t\treturn rc;\n\t\t}\n\t\tparent->canch[i]->parent = parent;\n\n\t\t \n\t\tif (parent->canch[i]->can.ctrlmode_supported & CAN_CTRLMODE_FD) {\n\t\t\tif (parent->canch[i]->feature & GS_CAN_FEATURE_HW_TIMESTAMP)\n\t\t\t\thf_size_rx = struct_size(hf, canfd_ts, 1);\n\t\t\telse\n\t\t\t\thf_size_rx = struct_size(hf, canfd, 1);\n\t\t} else {\n\t\t\tif (parent->canch[i]->feature & GS_CAN_FEATURE_HW_TIMESTAMP)\n\t\t\t\thf_size_rx = struct_size(hf, classic_can_ts, 1);\n\t\t\telse\n\t\t\t\thf_size_rx = struct_size(hf, classic_can, 1);\n\t\t}\n\t\tparent->hf_size_rx = max(parent->hf_size_rx, hf_size_rx);\n\t}\n\n\treturn 0;\n}\n\nstatic void gs_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct gs_usb *parent = usb_get_intfdata(intf);\n\tunsigned int i;\n\n\tusb_set_intfdata(intf, NULL);\n\n\tif (!parent) {\n\t\tdev_err(&intf->dev, \"Disconnect (nodata)\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < GS_MAX_INTF; i++)\n\t\tif (parent->canch[i])\n\t\t\tgs_destroy_candev(parent->canch[i]);\n\n\tkfree(parent);\n}\n\nstatic const struct usb_device_id gs_usb_table[] = {\n\t{ USB_DEVICE_INTERFACE_NUMBER(USB_GS_USB_1_VENDOR_ID,\n\t\t\t\t      USB_GS_USB_1_PRODUCT_ID, 0) },\n\t{ USB_DEVICE_INTERFACE_NUMBER(USB_CANDLELIGHT_VENDOR_ID,\n\t\t\t\t      USB_CANDLELIGHT_PRODUCT_ID, 0) },\n\t{ USB_DEVICE_INTERFACE_NUMBER(USB_CES_CANEXT_FD_VENDOR_ID,\n\t\t\t\t      USB_CES_CANEXT_FD_PRODUCT_ID, 0) },\n\t{ USB_DEVICE_INTERFACE_NUMBER(USB_ABE_CANDEBUGGER_FD_VENDOR_ID,\n\t\t\t\t      USB_ABE_CANDEBUGGER_FD_PRODUCT_ID, 0) },\n\t{}  \n};\n\nMODULE_DEVICE_TABLE(usb, gs_usb_table);\n\nstatic struct usb_driver gs_usb_driver = {\n\t.name = KBUILD_MODNAME,\n\t.probe = gs_usb_probe,\n\t.disconnect = gs_usb_disconnect,\n\t.id_table = gs_usb_table,\n};\n\nmodule_usb_driver(gs_usb_driver);\n\nMODULE_AUTHOR(\"Maximilian Schneider <mws@schneidersoft.net>\");\nMODULE_DESCRIPTION(\n\"Socket CAN device driver for Geschwister Schneider Technologie-, \"\n\"Entwicklungs- und Vertriebs UG. USB2.0 to CAN interfaces\\n\"\n\"and bytewerk.org candleLight USB CAN interfaces.\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}