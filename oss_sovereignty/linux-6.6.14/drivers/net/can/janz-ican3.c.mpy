{
  "module_name": "janz-ican3.c",
  "hash_id": "4e7ceb4253071c97ca5e622ac8762091fc530b315700ab1974440c0c8217dc90",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/janz-ican3.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/ethtool.h>\n#include <linux/platform_device.h>\n\n#include <linux/netdevice.h>\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/skb.h>\n#include <linux/can/error.h>\n\n#include <linux/mfd/janz.h>\n#include <asm/io.h>\n\n \n#define DPM_NUM_PAGES\t\t256\n#define DPM_PAGE_SIZE\t\t256\n#define DPM_PAGE_ADDR(p)\t((p) * DPM_PAGE_SIZE)\n\n \n#define QUEUE_OLD_CONTROL\t0\n#define QUEUE_OLD_RB0\t\t1\n#define QUEUE_OLD_RB1\t\t2\n#define QUEUE_OLD_WB0\t\t3\n#define QUEUE_OLD_WB1\t\t4\n\n \n#define MSYNC_PEER\t\t0x00\t\t \n#define MSYNC_LOCL\t\t0x01\t\t \n#define TARGET_RUNNING\t\t0x02\n#define FIRMWARE_STAMP\t\t0x60\t\t \n\n#define MSYNC_RB0\t\t0x01\n#define MSYNC_RB1\t\t0x02\n#define MSYNC_RBLW\t\t0x04\n#define MSYNC_RB_MASK\t\t(MSYNC_RB0 | MSYNC_RB1)\n\n#define MSYNC_WB0\t\t0x10\n#define MSYNC_WB1\t\t0x20\n#define MSYNC_WBLW\t\t0x40\n#define MSYNC_WB_MASK\t\t(MSYNC_WB0 | MSYNC_WB1)\n\n \n#define QUEUE_TOHOST\t\t5\n#define QUEUE_FROMHOST_MID\t6\n#define QUEUE_FROMHOST_HIGH\t7\n#define QUEUE_FROMHOST_LOW\t8\n\n \n#define DPM_FREE_START\t\t9\n\n \n#define DESC_VALID\t\t0x80\n#define DESC_WRAP\t\t0x40\n#define DESC_INTERRUPT\t\t0x20\n#define DESC_IVALID\t\t0x10\n#define DESC_LEN(len)\t\t(len)\n\n \n#define MSG_CONNECTI\t\t0x02\n#define MSG_DISCONNECT\t\t0x03\n#define MSG_IDVERS\t\t0x04\n#define MSG_MSGLOST\t\t0x05\n#define MSG_NEWHOSTIF\t\t0x08\n#define MSG_INQUIRY\t\t0x0a\n#define MSG_SETAFILMASK\t\t0x10\n#define MSG_INITFDPMQUEUE\t0x11\n#define MSG_HWCONF\t\t0x12\n#define MSG_FMSGLOST\t\t0x15\n#define MSG_CEVTIND\t\t0x37\n#define MSG_CBTRREQ\t\t0x41\n#define MSG_COFFREQ\t\t0x42\n#define MSG_CONREQ\t\t0x43\n#define MSG_CCONFREQ\t\t0x47\n#define MSG_NMTS\t\t0xb0\n#define MSG_LMTS\t\t0xb4\n\n \n#define INQUIRY_STATUS\t\t0x00\n#define INQUIRY_TERMINATION\t0x01\n#define INQUIRY_EXTENDED\t0x04\n\n \n#define SETAFILMASK_REJECT\t0x00\n#define SETAFILMASK_FASTIF\t0x02\n\n \n#define HWCONF_TERMINATE_ON\t0x01\n#define HWCONF_TERMINATE_OFF\t0x00\n\n \n#define CEVTIND_EI\t\t0x01\n#define CEVTIND_DOI\t\t0x02\n#define CEVTIND_LOST\t\t0x04\n#define CEVTIND_FULL\t\t0x08\n#define CEVTIND_BEI\t\t0x10\n\n#define CEVTIND_CHIP_SJA1000\t0x02\n\n#define ICAN3_BUSERR_QUOTA_MAX\t255\n\n \n#define ICAN3_SNGL\t0x02\n#define ICAN3_ECHO\t0x10\n#define ICAN3_EFF_RTR\t0x40\n#define ICAN3_SFF_RTR\t0x10\n#define ICAN3_EFF\t0x80\n\n#define ICAN3_CAN_TYPE_MASK\t0x0f\n#define ICAN3_CAN_TYPE_SFF\t0x00\n#define ICAN3_CAN_TYPE_EFF\t0x01\n\n#define ICAN3_CAN_DLC_MASK\t0x0f\n\n \n#define NMTS_CREATE_NODE_REQ\t0x0\n#define NMTS_SLAVE_STATE_IND\t0x8\n#define NMTS_SLAVE_EVENT_IND\t0x9\n\n \n#define LMTS_BUSON_REQ\t\t0x0\n#define LMTS_BUSOFF_REQ\t\t0x1\n#define LMTS_CAN_CONF_REQ\t0x2\n\n \n#define NE_LOCAL_OCCURRED\t0x3\n#define NE_LOCAL_RESOLVED\t0x2\n#define NE_REMOTE_OCCURRED\t0xc\n#define NE_REMOTE_RESOLVED\t0x8\n\n \n\n \n#define SR_BS\t\t0x80\n#define SR_ES\t\t0x40\n#define SR_TS\t\t0x20\n#define SR_RS\t\t0x10\n#define SR_TCS\t\t0x08\n#define SR_TBS\t\t0x04\n#define SR_DOS\t\t0x02\n#define SR_RBS\t\t0x01\n\n#define SR_CRIT (SR_BS|SR_ES)\n\n \n#define ECC_SEG\t\t0x1F\n#define ECC_DIR\t\t0x20\n#define ECC_ERR\t\t6\n#define ECC_BIT\t\t0x00\n#define ECC_FORM\t0x40\n#define ECC_STUFF\t0x80\n#define ECC_MASK\t0xc0\n\n \n#define ICAN3_NEW_BUFFERS\t16\n\n \n#define ICAN3_TX_BUFFERS\t512\n#define ICAN3_RX_BUFFERS\t1024\n\n \n#define ICAN3_CAN_CLOCK\t\t8000000\n\n \nenum ican3_fwtype {\n\tICAN3_FWTYPE_ICANOS,\n\tICAN3_FWTYPE_CAL_CANOPEN,\n};\n\n \n#define DRV_NAME \"janz-ican3\"\n\n \nstruct ican3_dpm_control {\n\t \n\tu8 window_address;\n\tu8 unused1;\n\n\t \n\tu8 interrupt;\n\tu8 unused2;\n\n\t \n\tu8 hwreset;\n\tu8 unused3;\n\n\t \n\tu8 tpuinterrupt;\n};\n\nstruct ican3_dev {\n\n\t \n\tstruct can_priv can;\n\n\t \n\tstruct net_device *ndev;\n\tstruct napi_struct napi;\n\n\t \n\tunsigned int num;\n\n\t \n\tstruct janz_cmodio_onboard_regs __iomem *ctrl;\n\tstruct ican3_dpm_control __iomem *dpmctrl;\n\tvoid __iomem *dpm;\n\tint irq;\n\n\t \n\tstruct completion termination_comp;\n\tbool termination_enabled;\n\n\t \n\tstruct completion buserror_comp;\n\tstruct can_berr_counter bec;\n\n\t \n\tenum ican3_fwtype fwtype;\n\tchar fwinfo[32];\n\n\t \n\tunsigned int iftype;\n\n\t \n\tstruct sk_buff_head echoq;\n\n\t \n\tspinlock_t lock;\n\n\t \n\tunsigned int rx_int;\n\tunsigned int rx_num;\n\tunsigned int tx_num;\n\n\t \n\tunsigned int fastrx_start;\n\tunsigned int fastrx_num;\n\tunsigned int fasttx_start;\n\tunsigned int fasttx_num;\n\n\t \n\tunsigned int free_page;\n};\n\nstruct ican3_msg {\n\tu8 control;\n\tu8 spec;\n\t__le16 len;\n\tu8 data[252];\n};\n\nstruct ican3_new_desc {\n\tu8 control;\n\tu8 pointer;\n};\n\nstruct ican3_fast_desc {\n\tu8 control;\n\tu8 command;\n\tu8 data[14];\n};\n\n \nstatic inline void ican3_set_page(struct ican3_dev *mod, unsigned int page)\n{\n\tBUG_ON(page >= DPM_NUM_PAGES);\n\tiowrite8(page, &mod->dpmctrl->window_address);\n}\n\n \n\n \nstatic int ican3_old_recv_msg(struct ican3_dev *mod, struct ican3_msg *msg)\n{\n\tunsigned int mbox, mbox_page;\n\tu8 locl, peer, xord;\n\n\t \n\tican3_set_page(mod, QUEUE_OLD_CONTROL);\n\tpeer = ioread8(mod->dpm + MSYNC_PEER);\n\tlocl = ioread8(mod->dpm + MSYNC_LOCL);\n\txord = locl ^ peer;\n\n\tif ((xord & MSYNC_RB_MASK) == 0x00) {\n\t\tnetdev_dbg(mod->ndev, \"no mbox for reading\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif ((xord & MSYNC_RB_MASK) == MSYNC_RB_MASK)\n\t\tmbox = (xord & MSYNC_RBLW) ? MSYNC_RB0 : MSYNC_RB1;\n\telse\n\t\tmbox = (xord & MSYNC_RB0) ? MSYNC_RB0 : MSYNC_RB1;\n\n\t \n\tmbox_page = (mbox == MSYNC_RB0) ? QUEUE_OLD_RB0 : QUEUE_OLD_RB1;\n\tican3_set_page(mod, mbox_page);\n\tmemcpy_fromio(msg, mod->dpm, sizeof(*msg));\n\n\t \n\tlocl ^= mbox;\n\n\tican3_set_page(mod, QUEUE_OLD_CONTROL);\n\tiowrite8(locl, mod->dpm + MSYNC_LOCL);\n\treturn 0;\n}\n\n \nstatic int ican3_old_send_msg(struct ican3_dev *mod, struct ican3_msg *msg)\n{\n\tunsigned int mbox, mbox_page;\n\tu8 locl, peer, xord;\n\n\t \n\tican3_set_page(mod, QUEUE_OLD_CONTROL);\n\tpeer = ioread8(mod->dpm + MSYNC_PEER);\n\tlocl = ioread8(mod->dpm + MSYNC_LOCL);\n\txord = locl ^ peer;\n\n\tif ((xord & MSYNC_WB_MASK) == MSYNC_WB_MASK) {\n\t\tnetdev_err(mod->ndev, \"no mbox for writing\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tmbox = (xord & MSYNC_WB0) ? MSYNC_WB1 : MSYNC_WB0;\n\n\t \n\tmbox_page = (mbox == MSYNC_WB0) ? QUEUE_OLD_WB0 : QUEUE_OLD_WB1;\n\tican3_set_page(mod, mbox_page);\n\tmemcpy_toio(mod->dpm, msg, sizeof(*msg));\n\n\tlocl ^= mbox;\n\tif (mbox == MSYNC_WB1)\n\t\tlocl |= MSYNC_WBLW;\n\n\tican3_set_page(mod, QUEUE_OLD_CONTROL);\n\tiowrite8(locl, mod->dpm + MSYNC_LOCL);\n\treturn 0;\n}\n\n \n\nstatic void ican3_init_new_host_interface(struct ican3_dev *mod)\n{\n\tstruct ican3_new_desc desc;\n\tunsigned long flags;\n\tvoid __iomem *dst;\n\tint i;\n\n\tspin_lock_irqsave(&mod->lock, flags);\n\n\t \n\tmod->rx_num = 0;\n\tmod->rx_int = 0;\n\n\t \n\tican3_set_page(mod, QUEUE_TOHOST);\n\tdst = mod->dpm;\n\n\t \n\tfor (i = 0; i < ICAN3_NEW_BUFFERS; i++) {\n\t\tdesc.control = DESC_INTERRUPT | DESC_LEN(1);  \n\t\tdesc.pointer = mod->free_page;\n\n\t\t \n\t\tif (i == ICAN3_NEW_BUFFERS - 1)\n\t\t\tdesc.control |= DESC_WRAP;\n\n\t\tmemcpy_toio(dst, &desc, sizeof(desc));\n\t\tdst += sizeof(desc);\n\t\tmod->free_page++;\n\t}\n\n\t \n\tican3_set_page(mod, QUEUE_FROMHOST_MID);\n\tdst = mod->dpm;\n\n\t \n\tmod->tx_num = 0;\n\n\t \n\tfor (i = 0; i < ICAN3_NEW_BUFFERS; i++) {\n\t\tdesc.control = DESC_VALID | DESC_LEN(1);  \n\t\tdesc.pointer = mod->free_page;\n\n\t\t \n\t\tif (i == ICAN3_NEW_BUFFERS - 1)\n\t\t\tdesc.control |= DESC_WRAP;\n\n\t\tmemcpy_toio(dst, &desc, sizeof(desc));\n\t\tdst += sizeof(desc);\n\t\tmod->free_page++;\n\t}\n\n\t \n\tican3_set_page(mod, QUEUE_FROMHOST_HIGH);\n\tdst = mod->dpm;\n\n\t \n\tdesc.control = DESC_VALID | DESC_WRAP | DESC_LEN(1);  \n\tdesc.pointer = mod->free_page;\n\tmemcpy_toio(dst, &desc, sizeof(desc));\n\tmod->free_page++;\n\n\t \n\tican3_set_page(mod, QUEUE_FROMHOST_LOW);\n\tdst = mod->dpm;\n\n\t \n\tdesc.control = DESC_VALID | DESC_WRAP | DESC_LEN(1);  \n\tdesc.pointer = mod->free_page;\n\tmemcpy_toio(dst, &desc, sizeof(desc));\n\tmod->free_page++;\n\n\tspin_unlock_irqrestore(&mod->lock, flags);\n}\n\n \n\nstatic void ican3_init_fast_host_interface(struct ican3_dev *mod)\n{\n\tstruct ican3_fast_desc desc;\n\tunsigned long flags;\n\tunsigned int addr;\n\tvoid __iomem *dst;\n\tint i;\n\n\tspin_lock_irqsave(&mod->lock, flags);\n\n\t \n\tmod->fastrx_start = mod->free_page;\n\tmod->fastrx_num = 0;\n\n\t \n\tmemset(&desc, 0, sizeof(desc));\n\tdesc.control = 0x00;\n\tdesc.command = 1;\n\n\t \n\taddr = 0;\n\tfor (i = 0; i < ICAN3_RX_BUFFERS; i++) {\n\n\t\t \n\t\tif (i == ICAN3_RX_BUFFERS - 1)\n\t\t\tdesc.control |= DESC_WRAP;\n\n\t\t \n\t\tican3_set_page(mod, mod->free_page);\n\n\t\t \n\t\tdst = mod->dpm + addr;\n\t\tmemcpy_toio(dst, &desc, sizeof(desc));\n\t\taddr += sizeof(desc);\n\n\t\t \n\t\tif (addr >= DPM_PAGE_SIZE) {\n\t\t\taddr = 0;\n\t\t\tmod->free_page++;\n\t\t}\n\t}\n\n\t \n\tif (addr != 0)\n\t\tmod->free_page++;\n\n\t \n\tmod->fasttx_start = mod->free_page;\n\tmod->fasttx_num = 0;\n\n\t \n\tmemset(&desc, 0, sizeof(desc));\n\tdesc.control = DESC_VALID;\n\tdesc.command = 1;\n\n\t \n\taddr = 0;\n\tfor (i = 0; i < ICAN3_TX_BUFFERS; i++) {\n\n\t\t \n\t\tif (i == ICAN3_TX_BUFFERS - 1)\n\t\t\tdesc.control |= DESC_WRAP;\n\n\t\t \n\t\tican3_set_page(mod, mod->free_page);\n\n\t\t \n\t\tdst = mod->dpm + addr;\n\t\tmemcpy_toio(dst, &desc, sizeof(desc));\n\t\taddr += sizeof(desc);\n\n\t\t \n\t\tif (addr >= DPM_PAGE_SIZE) {\n\t\t\taddr = 0;\n\t\t\tmod->free_page++;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&mod->lock, flags);\n}\n\n \n\n \nstatic int ican3_new_send_msg(struct ican3_dev *mod, struct ican3_msg *msg)\n{\n\tstruct ican3_new_desc desc;\n\tvoid __iomem *desc_addr = mod->dpm + (mod->tx_num * sizeof(desc));\n\n\t \n\tican3_set_page(mod, QUEUE_FROMHOST_MID);\n\tmemcpy_fromio(&desc, desc_addr, sizeof(desc));\n\n\tif (!(desc.control & DESC_VALID)) {\n\t\tnetdev_dbg(mod->ndev, \"%s: no free buffers\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tican3_set_page(mod, desc.pointer);\n\tmemcpy_toio(mod->dpm, msg, sizeof(*msg));\n\n\t \n\tican3_set_page(mod, QUEUE_FROMHOST_MID);\n\tdesc.control ^= DESC_VALID;\n\tmemcpy_toio(desc_addr, &desc, sizeof(desc));\n\n\t \n\tmod->tx_num = (desc.control & DESC_WRAP) ? 0 : (mod->tx_num + 1);\n\treturn 0;\n}\n\n \nstatic int ican3_new_recv_msg(struct ican3_dev *mod, struct ican3_msg *msg)\n{\n\tstruct ican3_new_desc desc;\n\tvoid __iomem *desc_addr = mod->dpm + (mod->rx_num * sizeof(desc));\n\n\t \n\tican3_set_page(mod, QUEUE_TOHOST);\n\tmemcpy_fromio(&desc, desc_addr, sizeof(desc));\n\n\tif (!(desc.control & DESC_VALID)) {\n\t\tnetdev_dbg(mod->ndev, \"%s: no buffers to recv\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tican3_set_page(mod, desc.pointer);\n\tmemcpy_fromio(msg, mod->dpm, sizeof(*msg));\n\n\t \n\tican3_set_page(mod, QUEUE_TOHOST);\n\tdesc.control ^= DESC_VALID;\n\tmemcpy_toio(desc_addr, &desc, sizeof(desc));\n\n\t \n\tmod->rx_num = (desc.control & DESC_WRAP) ? 0 : (mod->rx_num + 1);\n\treturn 0;\n}\n\n \n\nstatic int ican3_send_msg(struct ican3_dev *mod, struct ican3_msg *msg)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&mod->lock, flags);\n\n\tif (mod->iftype == 0)\n\t\tret = ican3_old_send_msg(mod, msg);\n\telse\n\t\tret = ican3_new_send_msg(mod, msg);\n\n\tspin_unlock_irqrestore(&mod->lock, flags);\n\treturn ret;\n}\n\nstatic int ican3_recv_msg(struct ican3_dev *mod, struct ican3_msg *msg)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&mod->lock, flags);\n\n\tif (mod->iftype == 0)\n\t\tret = ican3_old_recv_msg(mod, msg);\n\telse\n\t\tret = ican3_new_recv_msg(mod, msg);\n\n\tspin_unlock_irqrestore(&mod->lock, flags);\n\treturn ret;\n}\n\n \n\nstatic int ican3_msg_connect(struct ican3_dev *mod)\n{\n\tstruct ican3_msg msg;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.spec = MSG_CONNECTI;\n\tmsg.len = cpu_to_le16(0);\n\n\treturn ican3_send_msg(mod, &msg);\n}\n\nstatic int ican3_msg_disconnect(struct ican3_dev *mod)\n{\n\tstruct ican3_msg msg;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.spec = MSG_DISCONNECT;\n\tmsg.len = cpu_to_le16(0);\n\n\treturn ican3_send_msg(mod, &msg);\n}\n\nstatic int ican3_msg_newhostif(struct ican3_dev *mod)\n{\n\tstruct ican3_msg msg;\n\tint ret;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.spec = MSG_NEWHOSTIF;\n\tmsg.len = cpu_to_le16(0);\n\n\t \n\tWARN_ON(mod->iftype != 0);\n\n\tret = ican3_send_msg(mod, &msg);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmod->iftype = 1;\n\treturn 0;\n}\n\nstatic int ican3_msg_fasthostif(struct ican3_dev *mod)\n{\n\tstruct ican3_msg msg;\n\tunsigned int addr;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.spec = MSG_INITFDPMQUEUE;\n\tmsg.len = cpu_to_le16(8);\n\n\t \n\taddr = DPM_PAGE_ADDR(mod->fastrx_start);\n\tmsg.data[0] = addr & 0xff;\n\tmsg.data[1] = (addr >> 8) & 0xff;\n\tmsg.data[2] = (addr >> 16) & 0xff;\n\tmsg.data[3] = (addr >> 24) & 0xff;\n\n\t \n\taddr = DPM_PAGE_ADDR(mod->fasttx_start);\n\tmsg.data[4] = addr & 0xff;\n\tmsg.data[5] = (addr >> 8) & 0xff;\n\tmsg.data[6] = (addr >> 16) & 0xff;\n\tmsg.data[7] = (addr >> 24) & 0xff;\n\n\t \n\tWARN_ON(mod->iftype != 1);\n\n\treturn ican3_send_msg(mod, &msg);\n}\n\n \nstatic int ican3_set_id_filter(struct ican3_dev *mod, bool accept)\n{\n\tstruct ican3_msg msg;\n\tint ret;\n\n\t \n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.spec = MSG_SETAFILMASK;\n\tmsg.len = cpu_to_le16(5);\n\tmsg.data[0] = 0x00;  \n\tmsg.data[1] = 0x00;  \n\tmsg.data[2] = 0xff;  \n\tmsg.data[3] = 0x07;  \n\n\t \n\tmsg.data[4] = accept ? SETAFILMASK_FASTIF : SETAFILMASK_REJECT;\n\n\tret = ican3_send_msg(mod, &msg);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.spec = MSG_SETAFILMASK;\n\tmsg.len = cpu_to_le16(13);\n\tmsg.data[0] = 0;     \n\tmsg.data[1] = 0x00;  \n\tmsg.data[2] = 0x00;\n\tmsg.data[3] = 0x00;\n\tmsg.data[4] = 0x20;  \n\tmsg.data[5] = 0xff;  \n\tmsg.data[6] = 0xff;\n\tmsg.data[7] = 0xff;\n\tmsg.data[8] = 0x3f;  \n\n\t \n\tmsg.data[9] = accept ? SETAFILMASK_FASTIF : SETAFILMASK_REJECT;\n\n\treturn ican3_send_msg(mod, &msg);\n}\n\n \nstatic int ican3_set_bus_state(struct ican3_dev *mod, bool on)\n{\n\tstruct can_bittiming *bt = &mod->can.bittiming;\n\tstruct ican3_msg msg;\n\tu8 btr0, btr1;\n\tint res;\n\n\t \n\t \n\t \n\tbtr0 = ((bt->brp - 1) & 0x3f) | (((bt->sjw - 1) & 0x3) << 6);\n\tbtr1 = ((bt->prop_seg + bt->phase_seg1 - 1) & 0xf) |\n\t\t(((bt->phase_seg2 - 1) & 0x7) << 4);\n\tif (mod->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\tbtr1 |= 0x80;\n\n\tif (mod->fwtype == ICAN3_FWTYPE_ICANOS) {\n\t\tif (on) {\n\t\t\t \n\t\t\tmemset(&msg, 0, sizeof(msg));\n\t\t\tmsg.spec = MSG_CBTRREQ;\n\t\t\tmsg.len = cpu_to_le16(4);\n\t\t\tmsg.data[0] = 0x00;\n\t\t\tmsg.data[1] = 0x00;\n\t\t\tmsg.data[2] = btr0;\n\t\t\tmsg.data[3] = btr1;\n\n\t\t\tres = ican3_send_msg(mod, &msg);\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t}\n\n\t\t \n\t\tmemset(&msg, 0, sizeof(msg));\n\t\tmsg.spec = on ? MSG_CONREQ : MSG_COFFREQ;\n\t\tmsg.len = cpu_to_le16(0);\n\n\t\treturn ican3_send_msg(mod, &msg);\n\n\t} else if (mod->fwtype == ICAN3_FWTYPE_CAL_CANOPEN) {\n\t\t \n\t\tmemset(&msg, 0, sizeof(msg));\n\t\tmsg.spec = MSG_LMTS;\n\t\tif (on) {\n\t\t\tmsg.len = cpu_to_le16(4);\n\t\t\tmsg.data[0] = LMTS_BUSON_REQ;\n\t\t\tmsg.data[1] = 0;\n\t\t\tmsg.data[2] = btr0;\n\t\t\tmsg.data[3] = btr1;\n\t\t} else {\n\t\t\tmsg.len = cpu_to_le16(2);\n\t\t\tmsg.data[0] = LMTS_BUSOFF_REQ;\n\t\t\tmsg.data[1] = 0;\n\t\t}\n\t\tres = ican3_send_msg(mod, &msg);\n\t\tif (res)\n\t\t\treturn res;\n\n\t\tif (on) {\n\t\t\t \n\t\t\tmemset(&msg, 0, sizeof(msg));\n\t\t\tmsg.spec = MSG_NMTS;\n\t\t\tmsg.len = cpu_to_le16(11);\n\t\t\tmsg.data[0] = NMTS_CREATE_NODE_REQ;\n\t\t\tmsg.data[1] = 0;\n\t\t\tmsg.data[2] = 2;                  \n\t\t\tmsg.data[3] = 1;                  \n\t\t\tstrcpy(msg.data + 4, \"locnod1\");  \n\t\t\treturn ican3_send_msg(mod, &msg);\n\t\t}\n\t\treturn 0;\n\t}\n\treturn -ENOTSUPP;\n}\n\nstatic int ican3_set_termination(struct ican3_dev *mod, bool on)\n{\n\tstruct ican3_msg msg;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.spec = MSG_HWCONF;\n\tmsg.len = cpu_to_le16(2);\n\tmsg.data[0] = 0x00;\n\tmsg.data[1] = on ? HWCONF_TERMINATE_ON : HWCONF_TERMINATE_OFF;\n\n\treturn ican3_send_msg(mod, &msg);\n}\n\nstatic int ican3_send_inquiry(struct ican3_dev *mod, u8 subspec)\n{\n\tstruct ican3_msg msg;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.spec = MSG_INQUIRY;\n\tmsg.len = cpu_to_le16(2);\n\tmsg.data[0] = subspec;\n\tmsg.data[1] = 0x00;\n\n\treturn ican3_send_msg(mod, &msg);\n}\n\nstatic int ican3_set_buserror(struct ican3_dev *mod, u8 quota)\n{\n\tstruct ican3_msg msg;\n\n\tif (mod->fwtype == ICAN3_FWTYPE_ICANOS) {\n\t\tmemset(&msg, 0, sizeof(msg));\n\t\tmsg.spec = MSG_CCONFREQ;\n\t\tmsg.len = cpu_to_le16(2);\n\t\tmsg.data[0] = 0x00;\n\t\tmsg.data[1] = quota;\n\t} else if (mod->fwtype == ICAN3_FWTYPE_CAL_CANOPEN) {\n\t\tmemset(&msg, 0, sizeof(msg));\n\t\tmsg.spec = MSG_LMTS;\n\t\tmsg.len = cpu_to_le16(4);\n\t\tmsg.data[0] = LMTS_CAN_CONF_REQ;\n\t\tmsg.data[1] = 0x00;\n\t\tmsg.data[2] = 0x00;\n\t\tmsg.data[3] = quota;\n\t} else {\n\t\treturn -ENOTSUPP;\n\t}\n\treturn ican3_send_msg(mod, &msg);\n}\n\n \n\nstatic void ican3_to_can_frame(struct ican3_dev *mod,\n\t\t\t       struct ican3_fast_desc *desc,\n\t\t\t       struct can_frame *cf)\n{\n\tif ((desc->command & ICAN3_CAN_TYPE_MASK) == ICAN3_CAN_TYPE_SFF) {\n\t\tif (desc->data[1] & ICAN3_SFF_RTR)\n\t\t\tcf->can_id |= CAN_RTR_FLAG;\n\n\t\tcf->can_id |= desc->data[0] << 3;\n\t\tcf->can_id |= (desc->data[1] & 0xe0) >> 5;\n\t\tcf->len = can_cc_dlc2len(desc->data[1] & ICAN3_CAN_DLC_MASK);\n\t\tmemcpy(cf->data, &desc->data[2], cf->len);\n\t} else {\n\t\tcf->len = can_cc_dlc2len(desc->data[0] & ICAN3_CAN_DLC_MASK);\n\t\tif (desc->data[0] & ICAN3_EFF_RTR)\n\t\t\tcf->can_id |= CAN_RTR_FLAG;\n\n\t\tif (desc->data[0] & ICAN3_EFF) {\n\t\t\tcf->can_id |= CAN_EFF_FLAG;\n\t\t\tcf->can_id |= desc->data[2] << 21;  \n\t\t\tcf->can_id |= desc->data[3] << 13;  \n\t\t\tcf->can_id |= desc->data[4] << 5;   \n\t\t\tcf->can_id |= (desc->data[5] & 0xf8) >> 3;\n\t\t} else {\n\t\t\tcf->can_id |= desc->data[2] << 3;   \n\t\t\tcf->can_id |= desc->data[3] >> 5;   \n\t\t}\n\n\t\tmemcpy(cf->data, &desc->data[6], cf->len);\n\t}\n}\n\nstatic void can_frame_to_ican3(struct ican3_dev *mod,\n\t\t\t       struct can_frame *cf,\n\t\t\t       struct ican3_fast_desc *desc)\n{\n\t \n\tmemset(desc->data, 0, sizeof(desc->data));\n\n\t \n\tdesc->command = ICAN3_CAN_TYPE_EFF;\n\tdesc->data[0] |= cf->len;\n\tdesc->data[1] |= ICAN3_ECHO;\n\n\t \n\tif (mod->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)\n\t\tdesc->data[1] |= ICAN3_SNGL;\n\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tdesc->data[0] |= ICAN3_EFF_RTR;\n\n\t \n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\tdesc->data[0] |= ICAN3_EFF;\n\t\tdesc->data[2] = (cf->can_id & 0x1fe00000) >> 21;  \n\t\tdesc->data[3] = (cf->can_id & 0x001fe000) >> 13;  \n\t\tdesc->data[4] = (cf->can_id & 0x00001fe0) >> 5;   \n\t\tdesc->data[5] = (cf->can_id & 0x0000001f) << 3;   \n\t} else {\n\t\tdesc->data[2] = (cf->can_id & 0x7F8) >> 3;  \n\t\tdesc->data[3] = (cf->can_id & 0x007) << 5;  \n\t}\n\n\t \n\tmemcpy(&desc->data[6], cf->data, cf->len);\n}\n\n \n\n \nstatic void ican3_handle_idvers(struct ican3_dev *mod, struct ican3_msg *msg)\n{\n\tnetdev_dbg(mod->ndev, \"IDVERS response: %s\\n\", msg->data);\n}\n\nstatic void ican3_handle_msglost(struct ican3_dev *mod, struct ican3_msg *msg)\n{\n\tstruct net_device *dev = mod->ndev;\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\n\t \n\tif (msg->spec == MSG_MSGLOST) {\n\t\tnetdev_err(mod->ndev, \"lost %d control messages\\n\", msg->data[0]);\n\t\treturn;\n\t}\n\n\t \n\tskb = alloc_can_err_skb(dev, &cf);\n\tif (skb) {\n\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\t\tstats->rx_over_errors++;\n\t\tstats->rx_errors++;\n\t\tnetif_rx(skb);\n\t}\n}\n\n \nstatic int ican3_handle_cevtind(struct ican3_dev *mod, struct ican3_msg *msg)\n{\n\tstruct net_device *dev = mod->ndev;\n\tstruct net_device_stats *stats = &dev->stats;\n\tenum can_state state = mod->can.state;\n\tu8 isrc, ecc, status, rxerr, txerr;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\n\t \n\tif (msg->data[1] != CEVTIND_CHIP_SJA1000) {\n\t\tnetdev_err(mod->ndev, \"unable to handle errors on non-SJA1000\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (le16_to_cpu(msg->len) < 6) {\n\t\tnetdev_err(mod->ndev, \"error message too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tisrc = msg->data[0];\n\tecc = msg->data[2];\n\tstatus = msg->data[3];\n\trxerr = msg->data[4];\n\ttxerr = msg->data[5];\n\n\t \n\tif (isrc == CEVTIND_BEI) {\n\t\tint ret;\n\t\tnetdev_dbg(mod->ndev, \"bus error interrupt\\n\");\n\n\t\t \n\t\tif (!(ecc & ECC_DIR)) {\n\t\t\tkfree_skb(skb_dequeue(&mod->echoq));\n\t\t\tstats->tx_errors++;\n\t\t} else {\n\t\t\tstats->rx_errors++;\n\t\t}\n\n\t\t \n\t\tret = ican3_set_buserror(mod, 1);\n\t\tif (ret) {\n\t\t\tnetdev_err(mod->ndev, \"unable to re-enable bus-error\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (!(mod->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING))\n\t\t\treturn 0;\n\t}\n\n\tskb = alloc_can_err_skb(dev, &cf);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\t \n\tif (isrc == CEVTIND_DOI || isrc == CEVTIND_LOST) {\n\t\tnetdev_dbg(mod->ndev, \"data overrun interrupt\\n\");\n\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\t\tstats->rx_over_errors++;\n\t\tstats->rx_errors++;\n\t}\n\n\t \n\tif (isrc == CEVTIND_EI) {\n\t\tnetdev_dbg(mod->ndev, \"error warning + passive interrupt\\n\");\n\t\tif (status & SR_BS) {\n\t\t\tstate = CAN_STATE_BUS_OFF;\n\t\t\tcf->can_id |= CAN_ERR_BUSOFF;\n\t\t\tmod->can.can_stats.bus_off++;\n\t\t\tcan_bus_off(dev);\n\t\t} else if (status & SR_ES) {\n\t\t\tif (rxerr >= 128 || txerr >= 128)\n\t\t\t\tstate = CAN_STATE_ERROR_PASSIVE;\n\t\t\telse\n\t\t\t\tstate = CAN_STATE_ERROR_WARNING;\n\t\t} else {\n\t\t\tstate = CAN_STATE_ERROR_ACTIVE;\n\t\t}\n\t}\n\n\t \n\tif (isrc == CEVTIND_BEI) {\n\t\tmod->can.can_stats.bus_error++;\n\t\tcf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR | CAN_ERR_CNT;\n\n\t\tswitch (ecc & ECC_MASK) {\n\t\tcase ECC_BIT:\n\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT;\n\t\t\tbreak;\n\t\tcase ECC_FORM:\n\t\t\tcf->data[2] |= CAN_ERR_PROT_FORM;\n\t\t\tbreak;\n\t\tcase ECC_STUFF:\n\t\t\tcf->data[2] |= CAN_ERR_PROT_STUFF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcf->data[3] = ecc & ECC_SEG;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(ecc & ECC_DIR))\n\t\t\tcf->data[2] |= CAN_ERR_PROT_TX;\n\n\t\tcf->data[6] = txerr;\n\t\tcf->data[7] = rxerr;\n\t}\n\n\tif (state != mod->can.state && (state == CAN_STATE_ERROR_WARNING ||\n\t\t\t\t\tstate == CAN_STATE_ERROR_PASSIVE)) {\n\t\tcf->can_id |= CAN_ERR_CRTL | CAN_ERR_CNT;\n\t\tif (state == CAN_STATE_ERROR_WARNING) {\n\t\t\tmod->can.can_stats.error_warning++;\n\t\t\tcf->data[1] = (txerr > rxerr) ?\n\t\t\t\tCAN_ERR_CRTL_TX_WARNING :\n\t\t\t\tCAN_ERR_CRTL_RX_WARNING;\n\t\t} else {\n\t\t\tmod->can.can_stats.error_passive++;\n\t\t\tcf->data[1] = (txerr > rxerr) ?\n\t\t\t\tCAN_ERR_CRTL_TX_PASSIVE :\n\t\t\t\tCAN_ERR_CRTL_RX_PASSIVE;\n\t\t}\n\n\t\tcf->data[6] = txerr;\n\t\tcf->data[7] = rxerr;\n\t}\n\n\tmod->can.state = state;\n\tnetif_rx(skb);\n\treturn 0;\n}\n\nstatic void ican3_handle_inquiry(struct ican3_dev *mod, struct ican3_msg *msg)\n{\n\tswitch (msg->data[0]) {\n\tcase INQUIRY_STATUS:\n\tcase INQUIRY_EXTENDED:\n\t\tmod->bec.rxerr = msg->data[5];\n\t\tmod->bec.txerr = msg->data[6];\n\t\tcomplete(&mod->buserror_comp);\n\t\tbreak;\n\tcase INQUIRY_TERMINATION:\n\t\tmod->termination_enabled = msg->data[6] & HWCONF_TERMINATE_ON;\n\t\tcomplete(&mod->termination_comp);\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(mod->ndev, \"received an unknown inquiry response\\n\");\n\t\tbreak;\n\t}\n}\n\n \nstatic void ican3_handle_nmtsind(struct ican3_dev *mod, struct ican3_msg *msg)\n{\n\tu16 subspec;\n\n\tsubspec = msg->data[0] + msg->data[1] * 0x100;\n\tif (subspec == NMTS_SLAVE_EVENT_IND) {\n\t\tswitch (msg->data[2]) {\n\t\tcase NE_LOCAL_OCCURRED:\n\t\tcase NE_LOCAL_RESOLVED:\n\t\t\t \n\t\t\tle16_add_cpu(&msg->len, -3);\n\t\t\tmemmove(msg->data, msg->data + 3, le16_to_cpu(msg->len));\n\t\t\tican3_handle_cevtind(mod, msg);\n\t\t\tbreak;\n\t\tcase NE_REMOTE_OCCURRED:\n\t\tcase NE_REMOTE_RESOLVED:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnetdev_warn(mod->ndev, \"unknown NMTS event indication %x\\n\",\n\t\t\t\t    msg->data[2]);\n\t\t\tbreak;\n\t\t}\n\t} else if (subspec == NMTS_SLAVE_STATE_IND) {\n\t\t \n\t} else {\n\t\tnetdev_warn(mod->ndev, \"unhandled NMTS indication %x\\n\",\n\t\t\t    subspec);\n\t\treturn;\n\t}\n}\n\nstatic void ican3_handle_unknown_message(struct ican3_dev *mod,\n\t\t\t\t\tstruct ican3_msg *msg)\n{\n\tnetdev_warn(mod->ndev, \"received unknown message: spec 0x%.2x length %d\\n\",\n\t\t\t   msg->spec, le16_to_cpu(msg->len));\n}\n\n \nstatic void ican3_handle_message(struct ican3_dev *mod, struct ican3_msg *msg)\n{\n\tnetdev_dbg(mod->ndev, \"%s: modno %d spec 0x%.2x len %d bytes\\n\", __func__,\n\t\t\t   mod->num, msg->spec, le16_to_cpu(msg->len));\n\n\tswitch (msg->spec) {\n\tcase MSG_IDVERS:\n\t\tican3_handle_idvers(mod, msg);\n\t\tbreak;\n\tcase MSG_MSGLOST:\n\tcase MSG_FMSGLOST:\n\t\tican3_handle_msglost(mod, msg);\n\t\tbreak;\n\tcase MSG_CEVTIND:\n\t\tican3_handle_cevtind(mod, msg);\n\t\tbreak;\n\tcase MSG_INQUIRY:\n\t\tican3_handle_inquiry(mod, msg);\n\t\tbreak;\n\tcase MSG_NMTS:\n\t\tican3_handle_nmtsind(mod, msg);\n\t\tbreak;\n\tdefault:\n\t\tican3_handle_unknown_message(mod, msg);\n\t\tbreak;\n\t}\n}\n\n \nstatic void ican3_put_echo_skb(struct ican3_dev *mod, struct sk_buff *skb)\n{\n\tskb = can_create_echo_skb(skb);\n\tif (!skb)\n\t\treturn;\n\n\tskb_tx_timestamp(skb);\n\n\t \n\tskb_queue_tail(&mod->echoq, skb);\n}\n\nstatic unsigned int ican3_get_echo_skb(struct ican3_dev *mod)\n{\n\tstruct sk_buff *skb = skb_dequeue(&mod->echoq);\n\tstruct can_frame *cf;\n\tu8 dlc = 0;\n\n\t \n\tif (!skb) {\n\t\tnetdev_err(mod->ndev, \"BUG: echo skb not occupied\\n\");\n\t\treturn 0;\n\t}\n\n\tcf = (struct can_frame *)skb->data;\n\tif (!(cf->can_id & CAN_RTR_FLAG))\n\t\tdlc = cf->len;\n\n\t \n\tif (skb->pkt_type != PACKET_LOOPBACK) {\n\t\tkfree_skb(skb);\n\t\treturn dlc;\n\t}\n\n\tskb->protocol = htons(ETH_P_CAN);\n\tskb->pkt_type = PACKET_BROADCAST;\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\tskb->dev = mod->ndev;\n\tnetif_receive_skb(skb);\n\treturn dlc;\n}\n\n \nstatic bool ican3_echo_skb_matches(struct ican3_dev *mod, struct sk_buff *skb)\n{\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct sk_buff *echo_skb = skb_peek(&mod->echoq);\n\tstruct can_frame *echo_cf;\n\n\tif (!echo_skb)\n\t\treturn false;\n\n\techo_cf = (struct can_frame *)echo_skb->data;\n\tif (cf->can_id != echo_cf->can_id)\n\t\treturn false;\n\n\tif (cf->len != echo_cf->len)\n\t\treturn false;\n\n\treturn memcmp(cf->data, echo_cf->data, cf->len) == 0;\n}\n\n \nstatic bool ican3_txok(struct ican3_dev *mod)\n{\n\tstruct ican3_fast_desc __iomem *desc;\n\tu8 control;\n\n\t \n\tif (skb_queue_len(&mod->echoq) >= ICAN3_TX_BUFFERS)\n\t\treturn false;\n\n\t \n\tican3_set_page(mod, mod->fasttx_start + (mod->fasttx_num / 16));\n\tdesc = mod->dpm + ((mod->fasttx_num % 16) * sizeof(*desc));\n\tcontrol = ioread8(&desc->control);\n\n\t \n\tif (!(control & DESC_VALID))\n\t\treturn false;\n\n\treturn true;\n}\n\n \nstatic int ican3_recv_skb(struct ican3_dev *mod)\n{\n\tstruct net_device *ndev = mod->ndev;\n\tstruct net_device_stats *stats = &ndev->stats;\n\tstruct ican3_fast_desc desc;\n\tvoid __iomem *desc_addr;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mod->lock, flags);\n\n\t \n\tican3_set_page(mod, mod->fastrx_start + (mod->fastrx_num / 16));\n\tdesc_addr = mod->dpm + ((mod->fastrx_num % 16) * sizeof(desc));\n\tmemcpy_fromio(&desc, desc_addr, sizeof(desc));\n\n\tspin_unlock_irqrestore(&mod->lock, flags);\n\n\t \n\tif (!(desc.control & DESC_VALID))\n\t\treturn -ENOBUFS;\n\n\t \n\tskb = alloc_can_skb(ndev, &cf);\n\tif (unlikely(skb == NULL)) {\n\t\tstats->rx_dropped++;\n\t\tgoto err_noalloc;\n\t}\n\n\t \n\tican3_to_can_frame(mod, &desc, cf);\n\n\t \n\tif (ican3_echo_skb_matches(mod, skb)) {\n\t\tstats->tx_packets++;\n\t\tstats->tx_bytes += ican3_get_echo_skb(mod);\n\t\tkfree_skb(skb);\n\t\tgoto err_noalloc;\n\t}\n\n\t \n\tstats->rx_packets++;\n\tif (!(cf->can_id & CAN_RTR_FLAG))\n\t\tstats->rx_bytes += cf->len;\n\tnetif_receive_skb(skb);\n\nerr_noalloc:\n\t \n\tdesc.control ^= DESC_VALID;\n\n\tspin_lock_irqsave(&mod->lock, flags);\n\n\tican3_set_page(mod, mod->fastrx_start + (mod->fastrx_num / 16));\n\tmemcpy_toio(desc_addr, &desc, 1);\n\n\t \n\tmod->fastrx_num = (desc.control & DESC_WRAP) ? 0\n\t\t\t\t\t\t     : (mod->fastrx_num + 1);\n\n\t \n\tspin_unlock_irqrestore(&mod->lock, flags);\n\treturn 0;\n}\n\nstatic int ican3_napi(struct napi_struct *napi, int budget)\n{\n\tstruct ican3_dev *mod = container_of(napi, struct ican3_dev, napi);\n\tunsigned long flags;\n\tint received = 0;\n\tint ret;\n\n\t \n\twhile (true) {\n\t\tstruct ican3_msg msg;\n\t\tret = ican3_recv_msg(mod, &msg);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tican3_handle_message(mod, &msg);\n\t}\n\n\t \n\twhile (received < budget) {\n\t\tret = ican3_recv_skb(mod);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\treceived++;\n\t}\n\n\t \n\tif (received < budget)\n\t\tnapi_complete_done(napi, received);\n\n\tspin_lock_irqsave(&mod->lock, flags);\n\n\t \n\tif (netif_queue_stopped(mod->ndev) && ican3_txok(mod))\n\t\tnetif_wake_queue(mod->ndev);\n\n\tspin_unlock_irqrestore(&mod->lock, flags);\n\n\t \n\tiowrite8(1 << mod->num, &mod->ctrl->int_enable);\n\treturn received;\n}\n\nstatic irqreturn_t ican3_irq(int irq, void *dev_id)\n{\n\tstruct ican3_dev *mod = dev_id;\n\tu8 stat;\n\n\t \n\tstat = ioread8(&mod->ctrl->int_disable) & (1 << mod->num);\n\tif (stat == (1 << mod->num))\n\t\treturn IRQ_NONE;\n\n\t \n\tioread8(&mod->dpmctrl->interrupt);\n\n\t \n\tiowrite8(1 << mod->num, &mod->ctrl->int_disable);\n\tnapi_schedule(&mod->napi);\n\treturn IRQ_HANDLED;\n}\n\n \n\n \nstatic int ican3_reset_module(struct ican3_dev *mod)\n{\n\tunsigned long start;\n\tu8 runold, runnew;\n\n\t \n\tiowrite8(1 << mod->num, &mod->ctrl->int_disable);\n\n\t \n\tmod->free_page = DPM_FREE_START;\n\n\tican3_set_page(mod, QUEUE_OLD_CONTROL);\n\trunold = ioread8(mod->dpm + TARGET_RUNNING);\n\n\t \n\tiowrite8(0x00, &mod->dpmctrl->hwreset);\n\n\t \n\tstart = jiffies;\n\tdo {\n\t\tican3_set_page(mod, QUEUE_OLD_CONTROL);\n\t\trunnew = ioread8(mod->dpm + TARGET_RUNNING);\n\t\tif (runnew == (runold ^ 0xff))\n\t\t\treturn 0;\n\n\t\tmsleep(10);\n\t} while (time_before(jiffies, start + HZ / 2));\n\n\tnetdev_err(mod->ndev, \"failed to reset CAN module\\n\");\n\treturn -ETIMEDOUT;\n}\n\nstatic void ican3_shutdown_module(struct ican3_dev *mod)\n{\n\tican3_msg_disconnect(mod);\n\tican3_reset_module(mod);\n}\n\n \nstatic int ican3_startup_module(struct ican3_dev *mod)\n{\n\tint ret;\n\n\tret = ican3_reset_module(mod);\n\tif (ret) {\n\t\tnetdev_err(mod->ndev, \"unable to reset module\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tmemcpy_fromio(mod->fwinfo, mod->dpm + FIRMWARE_STAMP, sizeof(mod->fwinfo) - 1);\n\tif (strncmp(mod->fwinfo, \"JANZ-ICAN3\", 10)) {\n\t\tnetdev_err(mod->ndev, \"ICAN3 not detected (found %s)\\n\", mod->fwinfo);\n\t\treturn -ENODEV;\n\t}\n\tif (strstr(mod->fwinfo, \"CAL/CANopen\"))\n\t\tmod->fwtype = ICAN3_FWTYPE_CAL_CANOPEN;\n\telse\n\t\tmod->fwtype = ICAN3_FWTYPE_ICANOS;\n\n\t \n\tiowrite8(1 << mod->num, &mod->ctrl->int_enable);\n\n\tret = ican3_msg_connect(mod);\n\tif (ret) {\n\t\tnetdev_err(mod->ndev, \"unable to connect to module\\n\");\n\t\treturn ret;\n\t}\n\n\tican3_init_new_host_interface(mod);\n\tret = ican3_msg_newhostif(mod);\n\tif (ret) {\n\t\tnetdev_err(mod->ndev, \"unable to switch to new-style interface\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = ican3_set_termination(mod, true);\n\tif (ret) {\n\t\tnetdev_err(mod->ndev, \"unable to enable termination\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = ican3_set_buserror(mod, 1);\n\tif (ret) {\n\t\tnetdev_err(mod->ndev, \"unable to set bus-error\\n\");\n\t\treturn ret;\n\t}\n\n\tican3_init_fast_host_interface(mod);\n\tret = ican3_msg_fasthostif(mod);\n\tif (ret) {\n\t\tnetdev_err(mod->ndev, \"unable to switch to fast host interface\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ican3_set_id_filter(mod, true);\n\tif (ret) {\n\t\tnetdev_err(mod->ndev, \"unable to set acceptance filter\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int ican3_open(struct net_device *ndev)\n{\n\tstruct ican3_dev *mod = netdev_priv(ndev);\n\tint ret;\n\n\t \n\tret = open_candev(ndev);\n\tif (ret) {\n\t\tnetdev_err(mod->ndev, \"unable to start CAN layer\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = ican3_set_bus_state(mod, true);\n\tif (ret) {\n\t\tnetdev_err(mod->ndev, \"unable to set bus-on\\n\");\n\t\tclose_candev(ndev);\n\t\treturn ret;\n\t}\n\n\t \n\tmod->can.state = CAN_STATE_ERROR_ACTIVE;\n\tnetif_start_queue(ndev);\n\n\treturn 0;\n}\n\nstatic int ican3_stop(struct net_device *ndev)\n{\n\tstruct ican3_dev *mod = netdev_priv(ndev);\n\tint ret;\n\n\t \n\tnetif_stop_queue(ndev);\n\tmod->can.state = CAN_STATE_STOPPED;\n\n\t \n\tret = ican3_set_bus_state(mod, false);\n\tif (ret) {\n\t\tnetdev_err(mod->ndev, \"unable to set bus-off\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tskb_queue_purge(&mod->echoq);\n\n\t \n\tclose_candev(ndev);\n\treturn 0;\n}\n\nstatic netdev_tx_t ican3_xmit(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct ican3_dev *mod = netdev_priv(ndev);\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct ican3_fast_desc desc;\n\tvoid __iomem *desc_addr;\n\tunsigned long flags;\n\n\tif (can_dev_dropped_skb(ndev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tspin_lock_irqsave(&mod->lock, flags);\n\n\t \n\tif (!ican3_txok(mod)) {\n\t\tnetdev_err(mod->ndev, \"BUG: no free descriptors\\n\");\n\t\tspin_unlock_irqrestore(&mod->lock, flags);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\t \n\tican3_set_page(mod, mod->fasttx_start + (mod->fasttx_num / 16));\n\tdesc_addr = mod->dpm + ((mod->fasttx_num % 16) * sizeof(desc));\n\tmemset(&desc, 0, sizeof(desc));\n\tmemcpy_fromio(&desc, desc_addr, 1);\n\n\t \n\tcan_frame_to_ican3(mod, cf, &desc);\n\n\t \n\tican3_put_echo_skb(mod, skb);\n\n\t \n\tdesc.control |= DESC_IVALID;\n\tmemcpy_toio(desc_addr, &desc, sizeof(desc));\n\n\t \n\tiowrite8(0x01, &mod->dpmctrl->interrupt);\n\n\tdesc.control ^= DESC_VALID;\n\tmemcpy_toio(desc_addr, &desc, sizeof(desc));\n\n\t \n\tmod->fasttx_num = (desc.control & DESC_WRAP) ? 0\n\t\t\t\t\t\t     : (mod->fasttx_num + 1);\n\n\t \n\tif (!ican3_txok(mod))\n\t\tnetif_stop_queue(ndev);\n\n\tspin_unlock_irqrestore(&mod->lock, flags);\n\treturn NETDEV_TX_OK;\n}\n\nstatic const struct net_device_ops ican3_netdev_ops = {\n\t.ndo_open\t= ican3_open,\n\t.ndo_stop\t= ican3_stop,\n\t.ndo_start_xmit\t= ican3_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic const struct ethtool_ops ican3_ethtool_ops = {\n\t.get_ts_info = ethtool_op_get_ts_info,\n};\n\n \n\n \nstatic const struct can_bittiming_const ican3_bittiming_const = {\n\t.name = DRV_NAME,\n\t.tseg1_min = 1,\n\t.tseg1_max = 16,\n\t.tseg2_min = 1,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 64,\n\t.brp_inc = 1,\n};\n\nstatic int ican3_set_mode(struct net_device *ndev, enum can_mode mode)\n{\n\tstruct ican3_dev *mod = netdev_priv(ndev);\n\tint ret;\n\n\tif (mode != CAN_MODE_START)\n\t\treturn -ENOTSUPP;\n\n\t \n\tret = ican3_set_bus_state(mod, true);\n\tif (ret) {\n\t\tnetdev_err(ndev, \"unable to set bus-on\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tmod->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\tif (netif_queue_stopped(ndev))\n\t\tnetif_wake_queue(ndev);\n\n\treturn 0;\n}\n\nstatic int ican3_get_berr_counter(const struct net_device *ndev,\n\t\t\t\t  struct can_berr_counter *bec)\n{\n\tstruct ican3_dev *mod = netdev_priv(ndev);\n\tint ret;\n\n\tret = ican3_send_inquiry(mod, INQUIRY_STATUS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!wait_for_completion_timeout(&mod->buserror_comp, HZ)) {\n\t\tnetdev_info(mod->ndev, \"%s timed out\\n\", __func__);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tbec->rxerr = mod->bec.rxerr;\n\tbec->txerr = mod->bec.txerr;\n\treturn 0;\n}\n\n \n\nstatic ssize_t termination_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct ican3_dev *mod = netdev_priv(to_net_dev(dev));\n\tint ret;\n\n\tret = ican3_send_inquiry(mod, INQUIRY_TERMINATION);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!wait_for_completion_timeout(&mod->termination_comp, HZ)) {\n\t\tnetdev_info(mod->ndev, \"%s timed out\\n\", __func__);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn sysfs_emit(buf, \"%u\\n\", mod->termination_enabled);\n}\n\nstatic ssize_t termination_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct ican3_dev *mod = netdev_priv(to_net_dev(dev));\n\tunsigned long enable;\n\tint ret;\n\n\tif (kstrtoul(buf, 0, &enable))\n\t\treturn -EINVAL;\n\n\tret = ican3_set_termination(mod, enable);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t fwinfo_show(struct device *dev,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct ican3_dev *mod = netdev_priv(to_net_dev(dev));\n\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", mod->fwinfo);\n}\n\nstatic DEVICE_ATTR_RW(termination);\nstatic DEVICE_ATTR_RO(fwinfo);\n\nstatic struct attribute *ican3_sysfs_attrs[] = {\n\t&dev_attr_termination.attr,\n\t&dev_attr_fwinfo.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ican3_sysfs_attr_group = {\n\t.attrs = ican3_sysfs_attrs,\n};\n\n \n\nstatic int ican3_probe(struct platform_device *pdev)\n{\n\tstruct janz_platform_data *pdata;\n\tstruct net_device *ndev;\n\tstruct ican3_dev *mod;\n\tstruct resource *res;\n\tstruct device *dev;\n\tint ret;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\tif (!pdata)\n\t\treturn -ENXIO;\n\n\tdev_dbg(&pdev->dev, \"probe: module number %d\\n\", pdata->modno);\n\n\t \n\tdev = &pdev->dev;\n\n\t \n\tndev = alloc_candev(sizeof(*mod), 0);\n\tif (!ndev) {\n\t\tdev_err(dev, \"unable to allocate CANdev\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_return;\n\t}\n\n\tplatform_set_drvdata(pdev, ndev);\n\tmod = netdev_priv(ndev);\n\tmod->ndev = ndev;\n\tmod->num = pdata->modno;\n\tnetif_napi_add_weight(ndev, &mod->napi, ican3_napi, ICAN3_RX_BUFFERS);\n\tskb_queue_head_init(&mod->echoq);\n\tspin_lock_init(&mod->lock);\n\tinit_completion(&mod->termination_comp);\n\tinit_completion(&mod->buserror_comp);\n\n\t \n\tndev->sysfs_groups[0] = &ican3_sysfs_attr_group;\n\n\t \n\tmod->free_page = DPM_FREE_START;\n\n\tndev->netdev_ops = &ican3_netdev_ops;\n\tndev->ethtool_ops = &ican3_ethtool_ops;\n\tndev->flags |= IFF_ECHO;\n\tSET_NETDEV_DEV(ndev, &pdev->dev);\n\n\tmod->can.clock.freq = ICAN3_CAN_CLOCK;\n\tmod->can.bittiming_const = &ican3_bittiming_const;\n\tmod->can.do_set_mode = ican3_set_mode;\n\tmod->can.do_get_berr_counter = ican3_get_berr_counter;\n\tmod->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES\n\t\t\t\t    | CAN_CTRLMODE_BERR_REPORTING\n\t\t\t\t    | CAN_CTRLMODE_ONE_SHOT;\n\n\t \n\tmod->irq = platform_get_irq(pdev, 0);\n\tif (mod->irq < 0) {\n\t\tret = -ENODEV;\n\t\tgoto out_free_ndev;\n\t}\n\n\tndev->irq = mod->irq;\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(dev, \"MODULbus registers not found\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_free_ndev;\n\t}\n\n\tmod->dpm = ioremap(res->start, resource_size(res));\n\tif (!mod->dpm) {\n\t\tdev_err(dev, \"MODULbus registers not ioremap\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_free_ndev;\n\t}\n\n\tmod->dpmctrl = mod->dpm + DPM_PAGE_SIZE;\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (!res) {\n\t\tdev_err(dev, \"CONTROL registers not found\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_iounmap_dpm;\n\t}\n\n\tmod->ctrl = ioremap(res->start, resource_size(res));\n\tif (!mod->ctrl) {\n\t\tdev_err(dev, \"CONTROL registers not ioremap\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_iounmap_dpm;\n\t}\n\n\t \n\tiowrite8(1 << mod->num, &mod->ctrl->int_disable);\n\tret = request_irq(mod->irq, ican3_irq, IRQF_SHARED, DRV_NAME, mod);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to request IRQ\\n\");\n\t\tgoto out_iounmap_ctrl;\n\t}\n\n\t \n\tnapi_enable(&mod->napi);\n\tret = ican3_startup_module(mod);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: unable to start CANdev\\n\", __func__);\n\t\tgoto out_free_irq;\n\t}\n\n\t \n\tret = register_candev(ndev);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: unable to register CANdev\\n\", __func__);\n\t\tgoto out_free_irq;\n\t}\n\n\tnetdev_info(mod->ndev, \"module %d: registered CAN device\\n\", pdata->modno);\n\treturn 0;\n\nout_free_irq:\n\tnapi_disable(&mod->napi);\n\tiowrite8(1 << mod->num, &mod->ctrl->int_disable);\n\tfree_irq(mod->irq, mod);\nout_iounmap_ctrl:\n\tiounmap(mod->ctrl);\nout_iounmap_dpm:\n\tiounmap(mod->dpm);\nout_free_ndev:\n\tfree_candev(ndev);\nout_return:\n\treturn ret;\n}\n\nstatic void ican3_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct ican3_dev *mod = netdev_priv(ndev);\n\n\t \n\tunregister_netdev(ndev);\n\tnapi_disable(&mod->napi);\n\tiowrite8(1 << mod->num, &mod->ctrl->int_disable);\n\tfree_irq(mod->irq, mod);\n\n\t \n\tican3_shutdown_module(mod);\n\n\t \n\tiounmap(mod->ctrl);\n\tiounmap(mod->dpm);\n\n\tfree_candev(ndev);\n}\n\nstatic struct platform_driver ican3_driver = {\n\t.driver\t\t= {\n\t\t.name\t= DRV_NAME,\n\t},\n\t.probe\t\t= ican3_probe,\n\t.remove_new\t= ican3_remove,\n};\n\nmodule_platform_driver(ican3_driver);\n\nMODULE_AUTHOR(\"Ira W. Snyder <iws@ovro.caltech.edu>\");\nMODULE_DESCRIPTION(\"Janz MODULbus VMOD-ICAN3 Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:janz-ican3\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}