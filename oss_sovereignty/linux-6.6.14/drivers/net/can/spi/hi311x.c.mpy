{
  "module_name": "hi311x.c",
  "hash_id": "f58f3f0606e47ea6315eb8279d90f98f3ebfe4a65860dc297defbfa7fc6ddf20",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/spi/hi311x.c",
  "human_readable_source": "\n \n\n#include <linux/can/core.h>\n#include <linux/can/dev.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/ethtool.h>\n#include <linux/freezer.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/uaccess.h>\n\n#define HI3110_MASTER_RESET 0x56\n#define HI3110_READ_CTRL0 0xD2\n#define HI3110_READ_CTRL1 0xD4\n#define HI3110_READ_STATF 0xE2\n#define HI3110_WRITE_CTRL0 0x14\n#define HI3110_WRITE_CTRL1 0x16\n#define HI3110_WRITE_INTE 0x1C\n#define HI3110_WRITE_BTR0 0x18\n#define HI3110_WRITE_BTR1 0x1A\n#define HI3110_READ_BTR0 0xD6\n#define HI3110_READ_BTR1 0xD8\n#define HI3110_READ_INTF 0xDE\n#define HI3110_READ_ERR 0xDC\n#define HI3110_READ_FIFO_WOTIME 0x48\n#define HI3110_WRITE_FIFO 0x12\n#define HI3110_READ_MESSTAT 0xDA\n#define HI3110_READ_REC 0xEA\n#define HI3110_READ_TEC 0xEC\n\n#define HI3110_CTRL0_MODE_MASK (7 << 5)\n#define HI3110_CTRL0_NORMAL_MODE (0 << 5)\n#define HI3110_CTRL0_LOOPBACK_MODE (1 << 5)\n#define HI3110_CTRL0_MONITOR_MODE (2 << 5)\n#define HI3110_CTRL0_SLEEP_MODE (3 << 5)\n#define HI3110_CTRL0_INIT_MODE (4 << 5)\n\n#define HI3110_CTRL1_TXEN BIT(7)\n\n#define HI3110_INT_RXTMP BIT(7)\n#define HI3110_INT_RXFIFO BIT(6)\n#define HI3110_INT_TXCPLT BIT(5)\n#define HI3110_INT_BUSERR BIT(4)\n#define HI3110_INT_MCHG BIT(3)\n#define HI3110_INT_WAKEUP BIT(2)\n#define HI3110_INT_F1MESS BIT(1)\n#define HI3110_INT_F0MESS BIT(0)\n\n#define HI3110_ERR_BUSOFF BIT(7)\n#define HI3110_ERR_TXERRP BIT(6)\n#define HI3110_ERR_RXERRP BIT(5)\n#define HI3110_ERR_BITERR BIT(4)\n#define HI3110_ERR_FRMERR BIT(3)\n#define HI3110_ERR_CRCERR BIT(2)\n#define HI3110_ERR_ACKERR BIT(1)\n#define HI3110_ERR_STUFERR BIT(0)\n#define HI3110_ERR_PROTOCOL_MASK (0x1F)\n#define HI3110_ERR_PASSIVE_MASK (0x60)\n\n#define HI3110_STAT_RXFMTY BIT(1)\n#define HI3110_STAT_BUSOFF BIT(2)\n#define HI3110_STAT_ERRP BIT(3)\n#define HI3110_STAT_ERRW BIT(4)\n#define HI3110_STAT_TXMTY BIT(7)\n\n#define HI3110_BTR0_SJW_SHIFT 6\n#define HI3110_BTR0_BRP_SHIFT 0\n\n#define HI3110_BTR1_SAMP_3PERBIT (1 << 7)\n#define HI3110_BTR1_SAMP_1PERBIT (0 << 7)\n#define HI3110_BTR1_TSEG2_SHIFT 4\n#define HI3110_BTR1_TSEG1_SHIFT 0\n\n#define HI3110_FIFO_WOTIME_TAG_OFF 0\n#define HI3110_FIFO_WOTIME_ID_OFF 1\n#define HI3110_FIFO_WOTIME_DLC_OFF 5\n#define HI3110_FIFO_WOTIME_DAT_OFF 6\n\n#define HI3110_FIFO_WOTIME_TAG_IDE BIT(7)\n#define HI3110_FIFO_WOTIME_ID_RTR BIT(0)\n\n#define HI3110_FIFO_TAG_OFF 0\n#define HI3110_FIFO_ID_OFF 1\n#define HI3110_FIFO_STD_DLC_OFF 3\n#define HI3110_FIFO_STD_DATA_OFF 4\n#define HI3110_FIFO_EXT_DLC_OFF 5\n#define HI3110_FIFO_EXT_DATA_OFF 6\n\n#define HI3110_CAN_MAX_DATA_LEN 8\n#define HI3110_RX_BUF_LEN 15\n#define HI3110_TX_STD_BUF_LEN 12\n#define HI3110_TX_EXT_BUF_LEN 14\n#define HI3110_CAN_FRAME_MAX_BITS 128\n#define HI3110_EFF_FLAGS 0x18  \n\n#define HI3110_TX_ECHO_SKB_MAX 1\n\n#define HI3110_OST_DELAY_MS (10)\n\n#define DEVICE_NAME \"hi3110\"\n\nstatic const struct can_bittiming_const hi3110_bittiming_const = {\n\t.name = DEVICE_NAME,\n\t.tseg1_min = 2,\n\t.tseg1_max = 16,\n\t.tseg2_min = 2,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 64,\n\t.brp_inc = 1,\n};\n\nenum hi3110_model {\n\tCAN_HI3110_HI3110 = 0x3110,\n};\n\nstruct hi3110_priv {\n\tstruct can_priv can;\n\tstruct net_device *net;\n\tstruct spi_device *spi;\n\tenum hi3110_model model;\n\n\tstruct mutex hi3110_lock;  \n\n\tu8 *spi_tx_buf;\n\tu8 *spi_rx_buf;\n\n\tstruct sk_buff *tx_skb;\n\n\tstruct workqueue_struct *wq;\n\tstruct work_struct tx_work;\n\tstruct work_struct restart_work;\n\n\tint force_quit;\n\tint after_suspend;\n#define HI3110_AFTER_SUSPEND_UP 1\n#define HI3110_AFTER_SUSPEND_DOWN 2\n#define HI3110_AFTER_SUSPEND_POWER 4\n#define HI3110_AFTER_SUSPEND_RESTART 8\n\tint restart_tx;\n\tbool tx_busy;\n\n\tstruct regulator *power;\n\tstruct regulator *transceiver;\n\tstruct clk *clk;\n};\n\nstatic void hi3110_clean(struct net_device *net)\n{\n\tstruct hi3110_priv *priv = netdev_priv(net);\n\n\tif (priv->tx_skb || priv->tx_busy)\n\t\tnet->stats.tx_errors++;\n\tdev_kfree_skb(priv->tx_skb);\n\tif (priv->tx_busy)\n\t\tcan_free_echo_skb(priv->net, 0, NULL);\n\tpriv->tx_skb = NULL;\n\tpriv->tx_busy = false;\n}\n\n \nstatic int hi3110_spi_trans(struct spi_device *spi, int len)\n{\n\tstruct hi3110_priv *priv = spi_get_drvdata(spi);\n\tstruct spi_transfer t = {\n\t\t.tx_buf = priv->spi_tx_buf,\n\t\t.rx_buf = priv->spi_rx_buf,\n\t\t.len = len,\n\t\t.cs_change = 0,\n\t};\n\tstruct spi_message m;\n\tint ret;\n\n\tspi_message_init(&m);\n\tspi_message_add_tail(&t, &m);\n\n\tret = spi_sync(spi, &m);\n\n\tif (ret)\n\t\tdev_err(&spi->dev, \"spi transfer failed: ret = %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int hi3110_cmd(struct spi_device *spi, u8 command)\n{\n\tstruct hi3110_priv *priv = spi_get_drvdata(spi);\n\n\tpriv->spi_tx_buf[0] = command;\n\tdev_dbg(&spi->dev, \"hi3110_cmd: %02X\\n\", command);\n\n\treturn hi3110_spi_trans(spi, 1);\n}\n\nstatic u8 hi3110_read(struct spi_device *spi, u8 command)\n{\n\tstruct hi3110_priv *priv = spi_get_drvdata(spi);\n\tu8 val = 0;\n\n\tpriv->spi_tx_buf[0] = command;\n\thi3110_spi_trans(spi, 2);\n\tval = priv->spi_rx_buf[1];\n\n\treturn val;\n}\n\nstatic void hi3110_write(struct spi_device *spi, u8 reg, u8 val)\n{\n\tstruct hi3110_priv *priv = spi_get_drvdata(spi);\n\n\tpriv->spi_tx_buf[0] = reg;\n\tpriv->spi_tx_buf[1] = val;\n\thi3110_spi_trans(spi, 2);\n}\n\nstatic void hi3110_hw_tx_frame(struct spi_device *spi, u8 *buf, int len)\n{\n\tstruct hi3110_priv *priv = spi_get_drvdata(spi);\n\n\tpriv->spi_tx_buf[0] = HI3110_WRITE_FIFO;\n\tmemcpy(priv->spi_tx_buf + 1, buf, len);\n\thi3110_spi_trans(spi, len + 1);\n}\n\nstatic void hi3110_hw_tx(struct spi_device *spi, struct can_frame *frame)\n{\n\tu8 buf[HI3110_TX_EXT_BUF_LEN];\n\n\tbuf[HI3110_FIFO_TAG_OFF] = 0;\n\n\tif (frame->can_id & CAN_EFF_FLAG) {\n\t\t \n\t\tbuf[HI3110_FIFO_ID_OFF] = (frame->can_id & CAN_EFF_MASK) >> 21;\n\t\tbuf[HI3110_FIFO_ID_OFF + 1] =\n\t\t\t(((frame->can_id & CAN_EFF_MASK) >> 13) & 0xe0) |\n\t\t\tHI3110_EFF_FLAGS |\n\t\t\t(((frame->can_id & CAN_EFF_MASK) >> 15) & 0x07);\n\t\tbuf[HI3110_FIFO_ID_OFF + 2] =\n\t\t\t(frame->can_id & CAN_EFF_MASK) >> 7;\n\t\tbuf[HI3110_FIFO_ID_OFF + 3] =\n\t\t\t((frame->can_id & CAN_EFF_MASK) << 1) |\n\t\t\t((frame->can_id & CAN_RTR_FLAG) ? 1 : 0);\n\n\t\tbuf[HI3110_FIFO_EXT_DLC_OFF] = frame->len;\n\n\t\tmemcpy(buf + HI3110_FIFO_EXT_DATA_OFF,\n\t\t       frame->data, frame->len);\n\n\t\thi3110_hw_tx_frame(spi, buf, HI3110_TX_EXT_BUF_LEN -\n\t\t\t\t   (HI3110_CAN_MAX_DATA_LEN - frame->len));\n\t} else {\n\t\t \n\t\tbuf[HI3110_FIFO_ID_OFF] =   (frame->can_id & CAN_SFF_MASK) >> 3;\n\t\tbuf[HI3110_FIFO_ID_OFF + 1] =\n\t\t\t((frame->can_id & CAN_SFF_MASK) << 5) |\n\t\t\t((frame->can_id & CAN_RTR_FLAG) ? (1 << 4) : 0);\n\n\t\tbuf[HI3110_FIFO_STD_DLC_OFF] = frame->len;\n\n\t\tmemcpy(buf + HI3110_FIFO_STD_DATA_OFF,\n\t\t       frame->data, frame->len);\n\n\t\thi3110_hw_tx_frame(spi, buf, HI3110_TX_STD_BUF_LEN -\n\t\t\t\t   (HI3110_CAN_MAX_DATA_LEN - frame->len));\n\t}\n}\n\nstatic void hi3110_hw_rx_frame(struct spi_device *spi, u8 *buf)\n{\n\tstruct hi3110_priv *priv = spi_get_drvdata(spi);\n\n\tpriv->spi_tx_buf[0] = HI3110_READ_FIFO_WOTIME;\n\thi3110_spi_trans(spi, HI3110_RX_BUF_LEN);\n\tmemcpy(buf, priv->spi_rx_buf + 1, HI3110_RX_BUF_LEN - 1);\n}\n\nstatic void hi3110_hw_rx(struct spi_device *spi)\n{\n\tstruct hi3110_priv *priv = spi_get_drvdata(spi);\n\tstruct sk_buff *skb;\n\tstruct can_frame *frame;\n\tu8 buf[HI3110_RX_BUF_LEN - 1];\n\n\tskb = alloc_can_skb(priv->net, &frame);\n\tif (!skb) {\n\t\tpriv->net->stats.rx_dropped++;\n\t\treturn;\n\t}\n\n\thi3110_hw_rx_frame(spi, buf);\n\tif (buf[HI3110_FIFO_WOTIME_TAG_OFF] & HI3110_FIFO_WOTIME_TAG_IDE) {\n\t\t \n\t\tframe->can_id = CAN_EFF_FLAG;\n\t\tframe->can_id |=\n\t\t\t(buf[HI3110_FIFO_WOTIME_ID_OFF] << 21) |\n\t\t\t(((buf[HI3110_FIFO_WOTIME_ID_OFF + 1] & 0xE0) >> 5) << 18) |\n\t\t\t((buf[HI3110_FIFO_WOTIME_ID_OFF + 1] & 0x07) << 15) |\n\t\t\t(buf[HI3110_FIFO_WOTIME_ID_OFF + 2] << 7) |\n\t\t\t(buf[HI3110_FIFO_WOTIME_ID_OFF + 3] >> 1);\n\t} else {\n\t\t \n\t\tframe->can_id =\n\t\t\t(buf[HI3110_FIFO_WOTIME_ID_OFF] << 3) |\n\t\t\t((buf[HI3110_FIFO_WOTIME_ID_OFF + 1] & 0xE0) >> 5);\n\t}\n\n\t \n\tframe->len = can_cc_dlc2len(buf[HI3110_FIFO_WOTIME_DLC_OFF] & 0x0F);\n\n\tif (buf[HI3110_FIFO_WOTIME_ID_OFF + 3] & HI3110_FIFO_WOTIME_ID_RTR) {\n\t\tframe->can_id |= CAN_RTR_FLAG;\n\t} else {\n\t\tmemcpy(frame->data, buf + HI3110_FIFO_WOTIME_DAT_OFF,\n\t\t       frame->len);\n\n\t\tpriv->net->stats.rx_bytes += frame->len;\n\t}\n\tpriv->net->stats.rx_packets++;\n\n\tnetif_rx(skb);\n}\n\nstatic void hi3110_hw_sleep(struct spi_device *spi)\n{\n\thi3110_write(spi, HI3110_WRITE_CTRL0, HI3110_CTRL0_SLEEP_MODE);\n}\n\nstatic netdev_tx_t hi3110_hard_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t  struct net_device *net)\n{\n\tstruct hi3110_priv *priv = netdev_priv(net);\n\tstruct spi_device *spi = priv->spi;\n\n\tif (priv->tx_skb || priv->tx_busy) {\n\t\tdev_err(&spi->dev, \"hard_xmit called while tx busy\\n\");\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tif (can_dev_dropped_skb(net, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tnetif_stop_queue(net);\n\tpriv->tx_skb = skb;\n\tqueue_work(priv->wq, &priv->tx_work);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int hi3110_do_set_mode(struct net_device *net, enum can_mode mode)\n{\n\tstruct hi3110_priv *priv = netdev_priv(net);\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\thi3110_clean(net);\n\t\t \n\t\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\tpriv->restart_tx = 1;\n\t\tif (priv->can.restart_ms == 0)\n\t\t\tpriv->after_suspend = HI3110_AFTER_SUSPEND_RESTART;\n\t\tqueue_work(priv->wq, &priv->restart_work);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int hi3110_get_berr_counter(const struct net_device *net,\n\t\t\t\t   struct can_berr_counter *bec)\n{\n\tstruct hi3110_priv *priv = netdev_priv(net);\n\tstruct spi_device *spi = priv->spi;\n\n\tmutex_lock(&priv->hi3110_lock);\n\tbec->txerr = hi3110_read(spi, HI3110_READ_TEC);\n\tbec->rxerr = hi3110_read(spi, HI3110_READ_REC);\n\tmutex_unlock(&priv->hi3110_lock);\n\n\treturn 0;\n}\n\nstatic int hi3110_set_normal_mode(struct spi_device *spi)\n{\n\tstruct hi3110_priv *priv = spi_get_drvdata(spi);\n\tu8 reg = 0;\n\n\thi3110_write(spi, HI3110_WRITE_INTE, HI3110_INT_BUSERR |\n\t\t     HI3110_INT_RXFIFO | HI3110_INT_TXCPLT);\n\n\t \n\thi3110_write(spi, HI3110_WRITE_CTRL1, HI3110_CTRL1_TXEN);\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\treg = HI3110_CTRL0_LOOPBACK_MODE;\n\telse if (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\treg = HI3110_CTRL0_MONITOR_MODE;\n\telse\n\t\treg = HI3110_CTRL0_NORMAL_MODE;\n\n\thi3110_write(spi, HI3110_WRITE_CTRL0, reg);\n\n\t \n\tmdelay(HI3110_OST_DELAY_MS);\n\treg = hi3110_read(spi, HI3110_READ_CTRL0);\n\tif ((reg & HI3110_CTRL0_MODE_MASK) != reg)\n\t\treturn -EBUSY;\n\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\treturn 0;\n}\n\nstatic int hi3110_do_set_bittiming(struct net_device *net)\n{\n\tstruct hi3110_priv *priv = netdev_priv(net);\n\tstruct can_bittiming *bt = &priv->can.bittiming;\n\tstruct spi_device *spi = priv->spi;\n\n\thi3110_write(spi, HI3110_WRITE_BTR0,\n\t\t     ((bt->sjw - 1) << HI3110_BTR0_SJW_SHIFT) |\n\t\t     ((bt->brp - 1) << HI3110_BTR0_BRP_SHIFT));\n\n\thi3110_write(spi, HI3110_WRITE_BTR1,\n\t\t     (priv->can.ctrlmode &\n\t\t      CAN_CTRLMODE_3_SAMPLES ?\n\t\t      HI3110_BTR1_SAMP_3PERBIT : HI3110_BTR1_SAMP_1PERBIT) |\n\t\t     ((bt->phase_seg1 + bt->prop_seg - 1)\n\t\t      << HI3110_BTR1_TSEG1_SHIFT) |\n\t\t     ((bt->phase_seg2 - 1) << HI3110_BTR1_TSEG2_SHIFT));\n\n\tdev_dbg(&spi->dev, \"BT: 0x%02x 0x%02x\\n\",\n\t\thi3110_read(spi, HI3110_READ_BTR0),\n\t\thi3110_read(spi, HI3110_READ_BTR1));\n\n\treturn 0;\n}\n\nstatic int hi3110_setup(struct net_device *net)\n{\n\thi3110_do_set_bittiming(net);\n\treturn 0;\n}\n\nstatic int hi3110_hw_reset(struct spi_device *spi)\n{\n\tu8 reg;\n\tint ret;\n\n\t \n\tmdelay(HI3110_OST_DELAY_MS);\n\n\tret = hi3110_cmd(spi, HI3110_MASTER_RESET);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmdelay(HI3110_OST_DELAY_MS);\n\n\treg = hi3110_read(spi, HI3110_READ_CTRL0);\n\tif ((reg & HI3110_CTRL0_MODE_MASK) != HI3110_CTRL0_INIT_MODE)\n\t\treturn -ENODEV;\n\n\t \n\thi3110_read(spi, HI3110_READ_ERR);\n\n\treturn 0;\n}\n\nstatic int hi3110_hw_probe(struct spi_device *spi)\n{\n\tu8 statf;\n\n\thi3110_hw_reset(spi);\n\n\t \n\tstatf = hi3110_read(spi, HI3110_READ_STATF);\n\n\tdev_dbg(&spi->dev, \"statf: %02X\\n\", statf);\n\n\tif (statf != 0x82)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int hi3110_power_enable(struct regulator *reg, int enable)\n{\n\tif (IS_ERR_OR_NULL(reg))\n\t\treturn 0;\n\n\tif (enable)\n\t\treturn regulator_enable(reg);\n\telse\n\t\treturn regulator_disable(reg);\n}\n\nstatic int hi3110_stop(struct net_device *net)\n{\n\tstruct hi3110_priv *priv = netdev_priv(net);\n\tstruct spi_device *spi = priv->spi;\n\n\tclose_candev(net);\n\n\tpriv->force_quit = 1;\n\tfree_irq(spi->irq, priv);\n\tdestroy_workqueue(priv->wq);\n\tpriv->wq = NULL;\n\n\tmutex_lock(&priv->hi3110_lock);\n\n\t \n\thi3110_write(spi, HI3110_WRITE_CTRL1, 0x0);\n\thi3110_write(spi, HI3110_WRITE_INTE, 0x0);\n\thi3110_read(spi, HI3110_READ_INTF);\n\n\thi3110_clean(net);\n\n\thi3110_hw_sleep(spi);\n\n\thi3110_power_enable(priv->transceiver, 0);\n\n\tpriv->can.state = CAN_STATE_STOPPED;\n\n\tmutex_unlock(&priv->hi3110_lock);\n\n\treturn 0;\n}\n\nstatic void hi3110_tx_work_handler(struct work_struct *ws)\n{\n\tstruct hi3110_priv *priv = container_of(ws, struct hi3110_priv,\n\t\t\t\t\t\ttx_work);\n\tstruct spi_device *spi = priv->spi;\n\tstruct net_device *net = priv->net;\n\tstruct can_frame *frame;\n\n\tmutex_lock(&priv->hi3110_lock);\n\tif (priv->tx_skb) {\n\t\tif (priv->can.state == CAN_STATE_BUS_OFF) {\n\t\t\thi3110_clean(net);\n\t\t} else {\n\t\t\tframe = (struct can_frame *)priv->tx_skb->data;\n\t\t\thi3110_hw_tx(spi, frame);\n\t\t\tpriv->tx_busy = true;\n\t\t\tcan_put_echo_skb(priv->tx_skb, net, 0, 0);\n\t\t\tpriv->tx_skb = NULL;\n\t\t}\n\t}\n\tmutex_unlock(&priv->hi3110_lock);\n}\n\nstatic void hi3110_restart_work_handler(struct work_struct *ws)\n{\n\tstruct hi3110_priv *priv = container_of(ws, struct hi3110_priv,\n\t\t\t\t\t\trestart_work);\n\tstruct spi_device *spi = priv->spi;\n\tstruct net_device *net = priv->net;\n\n\tmutex_lock(&priv->hi3110_lock);\n\tif (priv->after_suspend) {\n\t\thi3110_hw_reset(spi);\n\t\thi3110_setup(net);\n\t\tif (priv->after_suspend & HI3110_AFTER_SUSPEND_RESTART) {\n\t\t\thi3110_set_normal_mode(spi);\n\t\t} else if (priv->after_suspend & HI3110_AFTER_SUSPEND_UP) {\n\t\t\tnetif_device_attach(net);\n\t\t\thi3110_clean(net);\n\t\t\thi3110_set_normal_mode(spi);\n\t\t\tnetif_wake_queue(net);\n\t\t} else {\n\t\t\thi3110_hw_sleep(spi);\n\t\t}\n\t\tpriv->after_suspend = 0;\n\t\tpriv->force_quit = 0;\n\t}\n\n\tif (priv->restart_tx) {\n\t\tpriv->restart_tx = 0;\n\t\thi3110_hw_reset(spi);\n\t\thi3110_setup(net);\n\t\thi3110_clean(net);\n\t\thi3110_set_normal_mode(spi);\n\t\tnetif_wake_queue(net);\n\t}\n\tmutex_unlock(&priv->hi3110_lock);\n}\n\nstatic irqreturn_t hi3110_can_ist(int irq, void *dev_id)\n{\n\tstruct hi3110_priv *priv = dev_id;\n\tstruct spi_device *spi = priv->spi;\n\tstruct net_device *net = priv->net;\n\n\tmutex_lock(&priv->hi3110_lock);\n\n\twhile (!priv->force_quit) {\n\t\tenum can_state new_state;\n\t\tu8 intf, eflag, statf;\n\n\t\twhile (!(HI3110_STAT_RXFMTY &\n\t\t\t (statf = hi3110_read(spi, HI3110_READ_STATF)))) {\n\t\t\thi3110_hw_rx(spi);\n\t\t}\n\n\t\tintf = hi3110_read(spi, HI3110_READ_INTF);\n\t\teflag = hi3110_read(spi, HI3110_READ_ERR);\n\t\t \n\t\tif (eflag & HI3110_ERR_BUSOFF)\n\t\t\tnew_state = CAN_STATE_BUS_OFF;\n\t\telse if (eflag & HI3110_ERR_PASSIVE_MASK)\n\t\t\tnew_state = CAN_STATE_ERROR_PASSIVE;\n\t\telse if (statf & HI3110_STAT_ERRW)\n\t\t\tnew_state = CAN_STATE_ERROR_WARNING;\n\t\telse\n\t\t\tnew_state = CAN_STATE_ERROR_ACTIVE;\n\n\t\tif (new_state != priv->can.state) {\n\t\t\tstruct can_frame *cf;\n\t\t\tstruct sk_buff *skb;\n\t\t\tenum can_state rx_state, tx_state;\n\t\t\tu8 rxerr, txerr;\n\n\t\t\tskb = alloc_can_err_skb(net, &cf);\n\t\t\tif (!skb)\n\t\t\t\tbreak;\n\n\t\t\ttxerr = hi3110_read(spi, HI3110_READ_TEC);\n\t\t\trxerr = hi3110_read(spi, HI3110_READ_REC);\n\t\t\ttx_state = txerr >= rxerr ? new_state : 0;\n\t\t\trx_state = txerr <= rxerr ? new_state : 0;\n\t\t\tcan_change_state(net, cf, tx_state, rx_state);\n\t\t\tnetif_rx(skb);\n\n\t\t\tif (new_state == CAN_STATE_BUS_OFF) {\n\t\t\t\tcan_bus_off(net);\n\t\t\t\tif (priv->can.restart_ms == 0) {\n\t\t\t\t\tpriv->force_quit = 1;\n\t\t\t\t\thi3110_hw_sleep(spi);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcf->can_id |= CAN_ERR_CNT;\n\t\t\t\tcf->data[6] = txerr;\n\t\t\t\tcf->data[7] = rxerr;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif ((intf & HI3110_INT_BUSERR) &&\n\t\t    (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING)) {\n\t\t\tstruct can_frame *cf;\n\t\t\tstruct sk_buff *skb;\n\n\t\t\t \n\t\t\tif (eflag & HI3110_ERR_PROTOCOL_MASK) {\n\t\t\t\tskb = alloc_can_err_skb(net, &cf);\n\t\t\t\tif (!skb)\n\t\t\t\t\tbreak;\n\n\t\t\t\tcf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\n\t\t\t\tpriv->can.can_stats.bus_error++;\n\t\t\t\tpriv->net->stats.rx_errors++;\n\t\t\t\tif (eflag & HI3110_ERR_BITERR)\n\t\t\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT;\n\t\t\t\telse if (eflag & HI3110_ERR_FRMERR)\n\t\t\t\t\tcf->data[2] |= CAN_ERR_PROT_FORM;\n\t\t\t\telse if (eflag & HI3110_ERR_STUFERR)\n\t\t\t\t\tcf->data[2] |= CAN_ERR_PROT_STUFF;\n\t\t\t\telse if (eflag & HI3110_ERR_CRCERR)\n\t\t\t\t\tcf->data[3] |= CAN_ERR_PROT_LOC_CRC_SEQ;\n\t\t\t\telse if (eflag & HI3110_ERR_ACKERR)\n\t\t\t\t\tcf->data[3] |= CAN_ERR_PROT_LOC_ACK;\n\n\t\t\t\tcf->data[6] = hi3110_read(spi, HI3110_READ_TEC);\n\t\t\t\tcf->data[7] = hi3110_read(spi, HI3110_READ_REC);\n\t\t\t\tnetdev_dbg(priv->net, \"Bus Error\\n\");\n\t\t\t\tnetif_rx(skb);\n\t\t\t}\n\t\t}\n\n\t\tif (priv->tx_busy && statf & HI3110_STAT_TXMTY) {\n\t\t\tnet->stats.tx_packets++;\n\t\t\tnet->stats.tx_bytes += can_get_echo_skb(net, 0, NULL);\n\t\t\tpriv->tx_busy = false;\n\t\t\tnetif_wake_queue(net);\n\t\t}\n\n\t\tif (intf == 0)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&priv->hi3110_lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic int hi3110_open(struct net_device *net)\n{\n\tstruct hi3110_priv *priv = netdev_priv(net);\n\tstruct spi_device *spi = priv->spi;\n\tunsigned long flags = IRQF_ONESHOT | IRQF_TRIGGER_HIGH;\n\tint ret;\n\n\tret = open_candev(net);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&priv->hi3110_lock);\n\thi3110_power_enable(priv->transceiver, 1);\n\n\tpriv->force_quit = 0;\n\tpriv->tx_skb = NULL;\n\tpriv->tx_busy = false;\n\n\tret = request_threaded_irq(spi->irq, NULL, hi3110_can_ist,\n\t\t\t\t   flags, DEVICE_NAME, priv);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"failed to acquire irq %d\\n\", spi->irq);\n\t\tgoto out_close;\n\t}\n\n\tpriv->wq = alloc_workqueue(\"hi3110_wq\", WQ_FREEZABLE | WQ_MEM_RECLAIM,\n\t\t\t\t   0);\n\tif (!priv->wq) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_irq;\n\t}\n\tINIT_WORK(&priv->tx_work, hi3110_tx_work_handler);\n\tINIT_WORK(&priv->restart_work, hi3110_restart_work_handler);\n\n\tret = hi3110_hw_reset(spi);\n\tif (ret)\n\t\tgoto out_free_wq;\n\n\tret = hi3110_setup(net);\n\tif (ret)\n\t\tgoto out_free_wq;\n\n\tret = hi3110_set_normal_mode(spi);\n\tif (ret)\n\t\tgoto out_free_wq;\n\n\tnetif_wake_queue(net);\n\tmutex_unlock(&priv->hi3110_lock);\n\n\treturn 0;\n\n out_free_wq:\n\tdestroy_workqueue(priv->wq);\n out_free_irq:\n\tfree_irq(spi->irq, priv);\n\thi3110_hw_sleep(spi);\n out_close:\n\thi3110_power_enable(priv->transceiver, 0);\n\tclose_candev(net);\n\tmutex_unlock(&priv->hi3110_lock);\n\treturn ret;\n}\n\nstatic const struct net_device_ops hi3110_netdev_ops = {\n\t.ndo_open = hi3110_open,\n\t.ndo_stop = hi3110_stop,\n\t.ndo_start_xmit = hi3110_hard_start_xmit,\n};\n\nstatic const struct ethtool_ops hi3110_ethtool_ops = {\n\t.get_ts_info = ethtool_op_get_ts_info,\n};\n\nstatic const struct of_device_id hi3110_of_match[] = {\n\t{\n\t\t.compatible\t= \"holt,hi3110\",\n\t\t.data\t\t= (void *)CAN_HI3110_HI3110,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, hi3110_of_match);\n\nstatic const struct spi_device_id hi3110_id_table[] = {\n\t{\n\t\t.name\t\t= \"hi3110\",\n\t\t.driver_data\t= (kernel_ulong_t)CAN_HI3110_HI3110,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, hi3110_id_table);\n\nstatic int hi3110_can_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct net_device *net;\n\tstruct hi3110_priv *priv;\n\tconst void *match;\n\tstruct clk *clk;\n\tu32 freq;\n\tint ret;\n\n\tclk = devm_clk_get_optional(&spi->dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(clk), \"no CAN clock source defined\\n\");\n\n\tif (clk) {\n\t\tfreq = clk_get_rate(clk);\n\t} else {\n\t\tret = device_property_read_u32(dev, \"clock-frequency\", &freq);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"Failed to get clock-frequency!\\n\");\n\t}\n\n\t \n\tif (freq > 40000000)\n\t\treturn -ERANGE;\n\n\t \n\tnet = alloc_candev(sizeof(struct hi3110_priv), HI3110_TX_ECHO_SKB_MAX);\n\tif (!net)\n\t\treturn -ENOMEM;\n\n\tret = clk_prepare_enable(clk);\n\tif (ret)\n\t\tgoto out_free;\n\n\tnet->netdev_ops = &hi3110_netdev_ops;\n\tnet->ethtool_ops = &hi3110_ethtool_ops;\n\tnet->flags |= IFF_ECHO;\n\n\tpriv = netdev_priv(net);\n\tpriv->can.bittiming_const = &hi3110_bittiming_const;\n\tpriv->can.do_set_mode = hi3110_do_set_mode;\n\tpriv->can.do_get_berr_counter = hi3110_get_berr_counter;\n\tpriv->can.clock.freq = freq / 2;\n\tpriv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES |\n\t\tCAN_CTRLMODE_LOOPBACK |\n\t\tCAN_CTRLMODE_LISTENONLY |\n\t\tCAN_CTRLMODE_BERR_REPORTING;\n\n\tmatch = device_get_match_data(dev);\n\tif (match)\n\t\tpriv->model = (enum hi3110_model)(uintptr_t)match;\n\telse\n\t\tpriv->model = spi_get_device_id(spi)->driver_data;\n\tpriv->net = net;\n\tpriv->clk = clk;\n\n\tspi_set_drvdata(spi, priv);\n\n\t \n\tspi->bits_per_word = 8;\n\tret = spi_setup(spi);\n\tif (ret)\n\t\tgoto out_clk;\n\n\tpriv->power = devm_regulator_get_optional(&spi->dev, \"vdd\");\n\tpriv->transceiver = devm_regulator_get_optional(&spi->dev, \"xceiver\");\n\tif ((PTR_ERR(priv->power) == -EPROBE_DEFER) ||\n\t    (PTR_ERR(priv->transceiver) == -EPROBE_DEFER)) {\n\t\tret = -EPROBE_DEFER;\n\t\tgoto out_clk;\n\t}\n\n\tret = hi3110_power_enable(priv->power, 1);\n\tif (ret)\n\t\tgoto out_clk;\n\n\tpriv->spi = spi;\n\tmutex_init(&priv->hi3110_lock);\n\n\tpriv->spi_tx_buf = devm_kzalloc(&spi->dev, HI3110_RX_BUF_LEN,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!priv->spi_tx_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto error_probe;\n\t}\n\tpriv->spi_rx_buf = devm_kzalloc(&spi->dev, HI3110_RX_BUF_LEN,\n\t\t\t\t\tGFP_KERNEL);\n\n\tif (!priv->spi_rx_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto error_probe;\n\t}\n\n\tSET_NETDEV_DEV(net, &spi->dev);\n\n\tret = hi3110_hw_probe(spi);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"Cannot initialize %x. Wrong wiring?\\n\", priv->model);\n\t\tgoto error_probe;\n\t}\n\thi3110_hw_sleep(spi);\n\n\tret = register_candev(net);\n\tif (ret)\n\t\tgoto error_probe;\n\n\tnetdev_info(net, \"%x successfully initialized.\\n\", priv->model);\n\n\treturn 0;\n\n error_probe:\n\thi3110_power_enable(priv->power, 0);\n\n out_clk:\n\tclk_disable_unprepare(clk);\n\n out_free:\n\tfree_candev(net);\n\n\treturn dev_err_probe(dev, ret, \"Probe failed\\n\");\n}\n\nstatic void hi3110_can_remove(struct spi_device *spi)\n{\n\tstruct hi3110_priv *priv = spi_get_drvdata(spi);\n\tstruct net_device *net = priv->net;\n\n\tunregister_candev(net);\n\n\thi3110_power_enable(priv->power, 0);\n\n\tclk_disable_unprepare(priv->clk);\n\n\tfree_candev(net);\n}\n\nstatic int __maybe_unused hi3110_can_suspend(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct hi3110_priv *priv = spi_get_drvdata(spi);\n\tstruct net_device *net = priv->net;\n\n\tpriv->force_quit = 1;\n\tdisable_irq(spi->irq);\n\n\t \n\tif (netif_running(net)) {\n\t\tnetif_device_detach(net);\n\n\t\thi3110_hw_sleep(spi);\n\t\thi3110_power_enable(priv->transceiver, 0);\n\t\tpriv->after_suspend = HI3110_AFTER_SUSPEND_UP;\n\t} else {\n\t\tpriv->after_suspend = HI3110_AFTER_SUSPEND_DOWN;\n\t}\n\n\tif (!IS_ERR_OR_NULL(priv->power)) {\n\t\tregulator_disable(priv->power);\n\t\tpriv->after_suspend |= HI3110_AFTER_SUSPEND_POWER;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused hi3110_can_resume(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct hi3110_priv *priv = spi_get_drvdata(spi);\n\n\tif (priv->after_suspend & HI3110_AFTER_SUSPEND_POWER)\n\t\thi3110_power_enable(priv->power, 1);\n\n\tif (priv->after_suspend & HI3110_AFTER_SUSPEND_UP) {\n\t\thi3110_power_enable(priv->transceiver, 1);\n\t\tqueue_work(priv->wq, &priv->restart_work);\n\t} else {\n\t\tpriv->after_suspend = 0;\n\t}\n\n\tpriv->force_quit = 0;\n\tenable_irq(spi->irq);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(hi3110_can_pm_ops, hi3110_can_suspend, hi3110_can_resume);\n\nstatic struct spi_driver hi3110_can_driver = {\n\t.driver = {\n\t\t.name = DEVICE_NAME,\n\t\t.of_match_table = hi3110_of_match,\n\t\t.pm = &hi3110_can_pm_ops,\n\t},\n\t.id_table = hi3110_id_table,\n\t.probe = hi3110_can_probe,\n\t.remove = hi3110_can_remove,\n};\n\nmodule_spi_driver(hi3110_can_driver);\n\nMODULE_AUTHOR(\"Akshay Bhat <akshay.bhat@timesys.com>\");\nMODULE_AUTHOR(\"Casey Fitzpatrick <casey.fitzpatrick@timesys.com>\");\nMODULE_DESCRIPTION(\"Holt HI-3110 CAN driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}