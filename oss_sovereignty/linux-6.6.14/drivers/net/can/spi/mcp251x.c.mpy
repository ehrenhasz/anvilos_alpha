{
  "module_name": "mcp251x.c",
  "hash_id": "3ec5569e798110959aae958c3031ba676577f4fb9696d8b656f92053963660b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/spi/mcp251x.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/can/core.h>\n#include <linux/can/dev.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/ethtool.h>\n#include <linux/freezer.h>\n#include <linux/gpio.h>\n#include <linux/gpio/driver.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/uaccess.h>\n\n \n#define INSTRUCTION_WRITE\t0x02\n#define INSTRUCTION_READ\t0x03\n#define INSTRUCTION_BIT_MODIFY\t0x05\n#define INSTRUCTION_LOAD_TXB(n)\t(0x40 + 2 * (n))\n#define INSTRUCTION_READ_RXB(n)\t(((n) == 0) ? 0x90 : 0x94)\n#define INSTRUCTION_RESET\t0xC0\n#define RTS_TXB0\t\t0x01\n#define RTS_TXB1\t\t0x02\n#define RTS_TXB2\t\t0x04\n#define INSTRUCTION_RTS(n)\t(0x80 | ((n) & 0x07))\n\n \n#define BFPCTRL\t\t\t0x0c\n#  define BFPCTRL_B0BFM\t\tBIT(0)\n#  define BFPCTRL_B1BFM\t\tBIT(1)\n#  define BFPCTRL_BFM(n)\t(BFPCTRL_B0BFM << (n))\n#  define BFPCTRL_BFM_MASK\tGENMASK(1, 0)\n#  define BFPCTRL_B0BFE\t\tBIT(2)\n#  define BFPCTRL_B1BFE\t\tBIT(3)\n#  define BFPCTRL_BFE(n)\t(BFPCTRL_B0BFE << (n))\n#  define BFPCTRL_BFE_MASK\tGENMASK(3, 2)\n#  define BFPCTRL_B0BFS\t\tBIT(4)\n#  define BFPCTRL_B1BFS\t\tBIT(5)\n#  define BFPCTRL_BFS(n)\t(BFPCTRL_B0BFS << (n))\n#  define BFPCTRL_BFS_MASK\tGENMASK(5, 4)\n#define TXRTSCTRL\t\t0x0d\n#  define TXRTSCTRL_B0RTSM\tBIT(0)\n#  define TXRTSCTRL_B1RTSM\tBIT(1)\n#  define TXRTSCTRL_B2RTSM\tBIT(2)\n#  define TXRTSCTRL_RTSM(n)\t(TXRTSCTRL_B0RTSM << (n))\n#  define TXRTSCTRL_RTSM_MASK\tGENMASK(2, 0)\n#  define TXRTSCTRL_B0RTS\tBIT(3)\n#  define TXRTSCTRL_B1RTS\tBIT(4)\n#  define TXRTSCTRL_B2RTS\tBIT(5)\n#  define TXRTSCTRL_RTS(n)\t(TXRTSCTRL_B0RTS << (n))\n#  define TXRTSCTRL_RTS_MASK\tGENMASK(5, 3)\n#define CANSTAT\t      0x0e\n#define CANCTRL\t      0x0f\n#  define CANCTRL_REQOP_MASK\t    0xe0\n#  define CANCTRL_REQOP_CONF\t    0x80\n#  define CANCTRL_REQOP_LISTEN_ONLY 0x60\n#  define CANCTRL_REQOP_LOOPBACK    0x40\n#  define CANCTRL_REQOP_SLEEP\t    0x20\n#  define CANCTRL_REQOP_NORMAL\t    0x00\n#  define CANCTRL_OSM\t\t    0x08\n#  define CANCTRL_ABAT\t\t    0x10\n#define TEC\t      0x1c\n#define REC\t      0x1d\n#define CNF1\t      0x2a\n#  define CNF1_SJW_SHIFT   6\n#define CNF2\t      0x29\n#  define CNF2_BTLMODE\t   0x80\n#  define CNF2_SAM         0x40\n#  define CNF2_PS1_SHIFT   3\n#define CNF3\t      0x28\n#  define CNF3_SOF\t   0x08\n#  define CNF3_WAKFIL\t   0x04\n#  define CNF3_PHSEG2_MASK 0x07\n#define CANINTE\t      0x2b\n#  define CANINTE_MERRE 0x80\n#  define CANINTE_WAKIE 0x40\n#  define CANINTE_ERRIE 0x20\n#  define CANINTE_TX2IE 0x10\n#  define CANINTE_TX1IE 0x08\n#  define CANINTE_TX0IE 0x04\n#  define CANINTE_RX1IE 0x02\n#  define CANINTE_RX0IE 0x01\n#define CANINTF\t      0x2c\n#  define CANINTF_MERRF 0x80\n#  define CANINTF_WAKIF 0x40\n#  define CANINTF_ERRIF 0x20\n#  define CANINTF_TX2IF 0x10\n#  define CANINTF_TX1IF 0x08\n#  define CANINTF_TX0IF 0x04\n#  define CANINTF_RX1IF 0x02\n#  define CANINTF_RX0IF 0x01\n#  define CANINTF_RX (CANINTF_RX0IF | CANINTF_RX1IF)\n#  define CANINTF_TX (CANINTF_TX2IF | CANINTF_TX1IF | CANINTF_TX0IF)\n#  define CANINTF_ERR (CANINTF_ERRIF)\n#define EFLG\t      0x2d\n#  define EFLG_EWARN\t0x01\n#  define EFLG_RXWAR\t0x02\n#  define EFLG_TXWAR\t0x04\n#  define EFLG_RXEP\t0x08\n#  define EFLG_TXEP\t0x10\n#  define EFLG_TXBO\t0x20\n#  define EFLG_RX0OVR\t0x40\n#  define EFLG_RX1OVR\t0x80\n#define TXBCTRL(n)  (((n) * 0x10) + 0x30 + TXBCTRL_OFF)\n#  define TXBCTRL_ABTF\t0x40\n#  define TXBCTRL_MLOA\t0x20\n#  define TXBCTRL_TXERR 0x10\n#  define TXBCTRL_TXREQ 0x08\n#define TXBSIDH(n)  (((n) * 0x10) + 0x30 + TXBSIDH_OFF)\n#  define SIDH_SHIFT    3\n#define TXBSIDL(n)  (((n) * 0x10) + 0x30 + TXBSIDL_OFF)\n#  define SIDL_SID_MASK    7\n#  define SIDL_SID_SHIFT   5\n#  define SIDL_EXIDE_SHIFT 3\n#  define SIDL_EID_SHIFT   16\n#  define SIDL_EID_MASK    3\n#define TXBEID8(n)  (((n) * 0x10) + 0x30 + TXBEID8_OFF)\n#define TXBEID0(n)  (((n) * 0x10) + 0x30 + TXBEID0_OFF)\n#define TXBDLC(n)   (((n) * 0x10) + 0x30 + TXBDLC_OFF)\n#  define DLC_RTR_SHIFT    6\n#define TXBCTRL_OFF 0\n#define TXBSIDH_OFF 1\n#define TXBSIDL_OFF 2\n#define TXBEID8_OFF 3\n#define TXBEID0_OFF 4\n#define TXBDLC_OFF  5\n#define TXBDAT_OFF  6\n#define RXBCTRL(n)  (((n) * 0x10) + 0x60 + RXBCTRL_OFF)\n#  define RXBCTRL_BUKT\t0x04\n#  define RXBCTRL_RXM0\t0x20\n#  define RXBCTRL_RXM1\t0x40\n#define RXBSIDH(n)  (((n) * 0x10) + 0x60 + RXBSIDH_OFF)\n#  define RXBSIDH_SHIFT 3\n#define RXBSIDL(n)  (((n) * 0x10) + 0x60 + RXBSIDL_OFF)\n#  define RXBSIDL_IDE   0x08\n#  define RXBSIDL_SRR   0x10\n#  define RXBSIDL_EID   3\n#  define RXBSIDL_SHIFT 5\n#define RXBEID8(n)  (((n) * 0x10) + 0x60 + RXBEID8_OFF)\n#define RXBEID0(n)  (((n) * 0x10) + 0x60 + RXBEID0_OFF)\n#define RXBDLC(n)   (((n) * 0x10) + 0x60 + RXBDLC_OFF)\n#  define RXBDLC_LEN_MASK  0x0f\n#  define RXBDLC_RTR       0x40\n#define RXBCTRL_OFF 0\n#define RXBSIDH_OFF 1\n#define RXBSIDL_OFF 2\n#define RXBEID8_OFF 3\n#define RXBEID0_OFF 4\n#define RXBDLC_OFF  5\n#define RXBDAT_OFF  6\n#define RXFSID(n) ((n < 3) ? 0 : 4)\n#define RXFSIDH(n) ((n) * 4 + RXFSID(n))\n#define RXFSIDL(n) ((n) * 4 + 1 + RXFSID(n))\n#define RXFEID8(n) ((n) * 4 + 2 + RXFSID(n))\n#define RXFEID0(n) ((n) * 4 + 3 + RXFSID(n))\n#define RXMSIDH(n) ((n) * 4 + 0x20)\n#define RXMSIDL(n) ((n) * 4 + 0x21)\n#define RXMEID8(n) ((n) * 4 + 0x22)\n#define RXMEID0(n) ((n) * 4 + 0x23)\n\n#define GET_BYTE(val, byte)\t\t\t\\\n\t(((val) >> ((byte) * 8)) & 0xff)\n#define SET_BYTE(val, byte)\t\t\t\\\n\t(((val) & 0xff) << ((byte) * 8))\n\n \n#define CAN_FRAME_MAX_DATA_LEN\t8\n#define SPI_TRANSFER_BUF_LEN\t(6 + CAN_FRAME_MAX_DATA_LEN)\n#define CAN_FRAME_MAX_BITS\t128\n\n#define TX_ECHO_SKB_MAX\t1\n\n#define MCP251X_OST_DELAY_MS\t(5)\n\n#define DEVICE_NAME \"mcp251x\"\n\nstatic const struct can_bittiming_const mcp251x_bittiming_const = {\n\t.name = DEVICE_NAME,\n\t.tseg1_min = 3,\n\t.tseg1_max = 16,\n\t.tseg2_min = 2,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 64,\n\t.brp_inc = 1,\n};\n\nenum mcp251x_model {\n\tCAN_MCP251X_MCP2510\t= 0x2510,\n\tCAN_MCP251X_MCP2515\t= 0x2515,\n\tCAN_MCP251X_MCP25625\t= 0x25625,\n};\n\nstruct mcp251x_priv {\n\tstruct can_priv\t   can;\n\tstruct net_device *net;\n\tstruct spi_device *spi;\n\tenum mcp251x_model model;\n\n\tstruct mutex mcp_lock;  \n\n\tu8 *spi_tx_buf;\n\tu8 *spi_rx_buf;\n\n\tstruct sk_buff *tx_skb;\n\n\tstruct workqueue_struct *wq;\n\tstruct work_struct tx_work;\n\tstruct work_struct restart_work;\n\n\tint force_quit;\n\tint after_suspend;\n#define AFTER_SUSPEND_UP 1\n#define AFTER_SUSPEND_DOWN 2\n#define AFTER_SUSPEND_POWER 4\n#define AFTER_SUSPEND_RESTART 8\n\tint restart_tx;\n\tbool tx_busy;\n\n\tstruct regulator *power;\n\tstruct regulator *transceiver;\n\tstruct clk *clk;\n#ifdef CONFIG_GPIOLIB\n\tstruct gpio_chip gpio;\n\tu8 reg_bfpctrl;\n#endif\n};\n\n#define MCP251X_IS(_model) \\\nstatic inline int mcp251x_is_##_model(struct spi_device *spi) \\\n{ \\\n\tstruct mcp251x_priv *priv = spi_get_drvdata(spi); \\\n\treturn priv->model == CAN_MCP251X_MCP##_model; \\\n}\n\nMCP251X_IS(2510);\n\nstatic void mcp251x_clean(struct net_device *net)\n{\n\tstruct mcp251x_priv *priv = netdev_priv(net);\n\n\tif (priv->tx_skb || priv->tx_busy)\n\t\tnet->stats.tx_errors++;\n\tdev_kfree_skb(priv->tx_skb);\n\tif (priv->tx_busy)\n\t\tcan_free_echo_skb(priv->net, 0, NULL);\n\tpriv->tx_skb = NULL;\n\tpriv->tx_busy = false;\n}\n\n \nstatic int mcp251x_spi_trans(struct spi_device *spi, int len)\n{\n\tstruct mcp251x_priv *priv = spi_get_drvdata(spi);\n\tstruct spi_transfer t = {\n\t\t.tx_buf = priv->spi_tx_buf,\n\t\t.rx_buf = priv->spi_rx_buf,\n\t\t.len = len,\n\t\t.cs_change = 0,\n\t};\n\tstruct spi_message m;\n\tint ret;\n\n\tspi_message_init(&m);\n\tspi_message_add_tail(&t, &m);\n\n\tret = spi_sync(spi, &m);\n\tif (ret)\n\t\tdev_err(&spi->dev, \"spi transfer failed: ret = %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int mcp251x_spi_write(struct spi_device *spi, int len)\n{\n\tstruct mcp251x_priv *priv = spi_get_drvdata(spi);\n\tint ret;\n\n\tret = spi_write(spi, priv->spi_tx_buf, len);\n\tif (ret)\n\t\tdev_err(&spi->dev, \"spi write failed: ret = %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic u8 mcp251x_read_reg(struct spi_device *spi, u8 reg)\n{\n\tstruct mcp251x_priv *priv = spi_get_drvdata(spi);\n\tu8 val = 0;\n\n\tpriv->spi_tx_buf[0] = INSTRUCTION_READ;\n\tpriv->spi_tx_buf[1] = reg;\n\n\tif (spi->controller->flags & SPI_CONTROLLER_HALF_DUPLEX) {\n\t\tspi_write_then_read(spi, priv->spi_tx_buf, 2, &val, 1);\n\t} else {\n\t\tmcp251x_spi_trans(spi, 3);\n\t\tval = priv->spi_rx_buf[2];\n\t}\n\n\treturn val;\n}\n\nstatic void mcp251x_read_2regs(struct spi_device *spi, u8 reg, u8 *v1, u8 *v2)\n{\n\tstruct mcp251x_priv *priv = spi_get_drvdata(spi);\n\n\tpriv->spi_tx_buf[0] = INSTRUCTION_READ;\n\tpriv->spi_tx_buf[1] = reg;\n\n\tif (spi->controller->flags & SPI_CONTROLLER_HALF_DUPLEX) {\n\t\tu8 val[2] = { 0 };\n\n\t\tspi_write_then_read(spi, priv->spi_tx_buf, 2, val, 2);\n\t\t*v1 = val[0];\n\t\t*v2 = val[1];\n\t} else {\n\t\tmcp251x_spi_trans(spi, 4);\n\n\t\t*v1 = priv->spi_rx_buf[2];\n\t\t*v2 = priv->spi_rx_buf[3];\n\t}\n}\n\nstatic void mcp251x_write_reg(struct spi_device *spi, u8 reg, u8 val)\n{\n\tstruct mcp251x_priv *priv = spi_get_drvdata(spi);\n\n\tpriv->spi_tx_buf[0] = INSTRUCTION_WRITE;\n\tpriv->spi_tx_buf[1] = reg;\n\tpriv->spi_tx_buf[2] = val;\n\n\tmcp251x_spi_write(spi, 3);\n}\n\nstatic void mcp251x_write_2regs(struct spi_device *spi, u8 reg, u8 v1, u8 v2)\n{\n\tstruct mcp251x_priv *priv = spi_get_drvdata(spi);\n\n\tpriv->spi_tx_buf[0] = INSTRUCTION_WRITE;\n\tpriv->spi_tx_buf[1] = reg;\n\tpriv->spi_tx_buf[2] = v1;\n\tpriv->spi_tx_buf[3] = v2;\n\n\tmcp251x_spi_write(spi, 4);\n}\n\nstatic void mcp251x_write_bits(struct spi_device *spi, u8 reg,\n\t\t\t       u8 mask, u8 val)\n{\n\tstruct mcp251x_priv *priv = spi_get_drvdata(spi);\n\n\tpriv->spi_tx_buf[0] = INSTRUCTION_BIT_MODIFY;\n\tpriv->spi_tx_buf[1] = reg;\n\tpriv->spi_tx_buf[2] = mask;\n\tpriv->spi_tx_buf[3] = val;\n\n\tmcp251x_spi_write(spi, 4);\n}\n\nstatic u8 mcp251x_read_stat(struct spi_device *spi)\n{\n\treturn mcp251x_read_reg(spi, CANSTAT) & CANCTRL_REQOP_MASK;\n}\n\n#define mcp251x_read_stat_poll_timeout(addr, val, cond, delay_us, timeout_us) \\\n\treadx_poll_timeout(mcp251x_read_stat, addr, val, cond, \\\n\t\t\t   delay_us, timeout_us)\n\n#ifdef CONFIG_GPIOLIB\nenum {\n\tMCP251X_GPIO_TX0RTS = 0,\t\t \n\tMCP251X_GPIO_TX1RTS,\n\tMCP251X_GPIO_TX2RTS,\n\tMCP251X_GPIO_RX0BF,\t\t\t \n\tMCP251X_GPIO_RX1BF,\n};\n\n#define MCP251X_GPIO_INPUT_MASK \\\n\tGENMASK(MCP251X_GPIO_TX2RTS, MCP251X_GPIO_TX0RTS)\n#define MCP251X_GPIO_OUTPUT_MASK \\\n\tGENMASK(MCP251X_GPIO_RX1BF, MCP251X_GPIO_RX0BF)\n\nstatic const char * const mcp251x_gpio_names[] = {\n\t[MCP251X_GPIO_TX0RTS] = \"TX0RTS\",\t \n\t[MCP251X_GPIO_TX1RTS] = \"TX1RTS\",\n\t[MCP251X_GPIO_TX2RTS] = \"TX2RTS\",\n\t[MCP251X_GPIO_RX0BF] = \"RX0BF\",\t\t \n\t[MCP251X_GPIO_RX1BF] = \"RX1BF\",\n};\n\nstatic inline bool mcp251x_gpio_is_input(unsigned int offset)\n{\n\treturn offset <= MCP251X_GPIO_TX2RTS;\n}\n\nstatic int mcp251x_gpio_request(struct gpio_chip *chip,\n\t\t\t\tunsigned int offset)\n{\n\tstruct mcp251x_priv *priv = gpiochip_get_data(chip);\n\tu8 val;\n\n\t \n\tif (mcp251x_gpio_is_input(offset))\n\t\treturn 0;\n\n\tval = BFPCTRL_BFE(offset - MCP251X_GPIO_RX0BF);\n\n\tmutex_lock(&priv->mcp_lock);\n\tmcp251x_write_bits(priv->spi, BFPCTRL, val, val);\n\tmutex_unlock(&priv->mcp_lock);\n\n\tpriv->reg_bfpctrl |= val;\n\n\treturn 0;\n}\n\nstatic void mcp251x_gpio_free(struct gpio_chip *chip,\n\t\t\t      unsigned int offset)\n{\n\tstruct mcp251x_priv *priv = gpiochip_get_data(chip);\n\tu8 val;\n\n\t \n\tif (mcp251x_gpio_is_input(offset))\n\t\treturn;\n\n\tval = BFPCTRL_BFE(offset - MCP251X_GPIO_RX0BF);\n\n\tmutex_lock(&priv->mcp_lock);\n\tmcp251x_write_bits(priv->spi, BFPCTRL, val, 0);\n\tmutex_unlock(&priv->mcp_lock);\n\n\tpriv->reg_bfpctrl &= ~val;\n}\n\nstatic int mcp251x_gpio_get_direction(struct gpio_chip *chip,\n\t\t\t\t      unsigned int offset)\n{\n\tif (mcp251x_gpio_is_input(offset))\n\t\treturn GPIOF_DIR_IN;\n\n\treturn GPIOF_DIR_OUT;\n}\n\nstatic int mcp251x_gpio_get(struct gpio_chip *chip, unsigned int offset)\n{\n\tstruct mcp251x_priv *priv = gpiochip_get_data(chip);\n\tu8 reg, mask, val;\n\n\tif (mcp251x_gpio_is_input(offset)) {\n\t\treg = TXRTSCTRL;\n\t\tmask = TXRTSCTRL_RTS(offset);\n\t} else {\n\t\treg = BFPCTRL;\n\t\tmask = BFPCTRL_BFS(offset - MCP251X_GPIO_RX0BF);\n\t}\n\n\tmutex_lock(&priv->mcp_lock);\n\tval = mcp251x_read_reg(priv->spi, reg);\n\tmutex_unlock(&priv->mcp_lock);\n\n\treturn !!(val & mask);\n}\n\nstatic int mcp251x_gpio_get_multiple(struct gpio_chip *chip,\n\t\t\t\t     unsigned long *maskp, unsigned long *bitsp)\n{\n\tstruct mcp251x_priv *priv = gpiochip_get_data(chip);\n\tunsigned long bits = 0;\n\tu8 val;\n\n\tmutex_lock(&priv->mcp_lock);\n\tif (maskp[0] & MCP251X_GPIO_INPUT_MASK) {\n\t\tval = mcp251x_read_reg(priv->spi, TXRTSCTRL);\n\t\tval = FIELD_GET(TXRTSCTRL_RTS_MASK, val);\n\t\tbits |= FIELD_PREP(MCP251X_GPIO_INPUT_MASK, val);\n\t}\n\tif (maskp[0] & MCP251X_GPIO_OUTPUT_MASK) {\n\t\tval = mcp251x_read_reg(priv->spi, BFPCTRL);\n\t\tval = FIELD_GET(BFPCTRL_BFS_MASK, val);\n\t\tbits |= FIELD_PREP(MCP251X_GPIO_OUTPUT_MASK, val);\n\t}\n\tmutex_unlock(&priv->mcp_lock);\n\n\tbitsp[0] = bits;\n\treturn 0;\n}\n\nstatic void mcp251x_gpio_set(struct gpio_chip *chip, unsigned int offset,\n\t\t\t     int value)\n{\n\tstruct mcp251x_priv *priv = gpiochip_get_data(chip);\n\tu8 mask, val;\n\n\tmask = BFPCTRL_BFS(offset - MCP251X_GPIO_RX0BF);\n\tval = value ? mask : 0;\n\n\tmutex_lock(&priv->mcp_lock);\n\tmcp251x_write_bits(priv->spi, BFPCTRL, mask, val);\n\tmutex_unlock(&priv->mcp_lock);\n\n\tpriv->reg_bfpctrl &= ~mask;\n\tpriv->reg_bfpctrl |= val;\n}\n\nstatic void\nmcp251x_gpio_set_multiple(struct gpio_chip *chip,\n\t\t\t  unsigned long *maskp, unsigned long *bitsp)\n{\n\tstruct mcp251x_priv *priv = gpiochip_get_data(chip);\n\tu8 mask, val;\n\n\tmask = FIELD_GET(MCP251X_GPIO_OUTPUT_MASK, maskp[0]);\n\tmask = FIELD_PREP(BFPCTRL_BFS_MASK, mask);\n\n\tval = FIELD_GET(MCP251X_GPIO_OUTPUT_MASK, bitsp[0]);\n\tval = FIELD_PREP(BFPCTRL_BFS_MASK, val);\n\n\tif (!mask)\n\t\treturn;\n\n\tmutex_lock(&priv->mcp_lock);\n\tmcp251x_write_bits(priv->spi, BFPCTRL, mask, val);\n\tmutex_unlock(&priv->mcp_lock);\n\n\tpriv->reg_bfpctrl &= ~mask;\n\tpriv->reg_bfpctrl |= val;\n}\n\nstatic void mcp251x_gpio_restore(struct spi_device *spi)\n{\n\tstruct mcp251x_priv *priv = spi_get_drvdata(spi);\n\n\tmcp251x_write_reg(spi, BFPCTRL, priv->reg_bfpctrl);\n}\n\nstatic int mcp251x_gpio_setup(struct mcp251x_priv *priv)\n{\n\tstruct gpio_chip *gpio = &priv->gpio;\n\n\tif (!device_property_present(&priv->spi->dev, \"gpio-controller\"))\n\t\treturn 0;\n\n\t \n\tgpio->label = priv->spi->modalias;\n\tgpio->parent = &priv->spi->dev;\n\tgpio->owner = THIS_MODULE;\n\tgpio->request = mcp251x_gpio_request;\n\tgpio->free = mcp251x_gpio_free;\n\tgpio->get_direction = mcp251x_gpio_get_direction;\n\tgpio->get = mcp251x_gpio_get;\n\tgpio->get_multiple = mcp251x_gpio_get_multiple;\n\tgpio->set = mcp251x_gpio_set;\n\tgpio->set_multiple = mcp251x_gpio_set_multiple;\n\tgpio->base = -1;\n\tgpio->ngpio = ARRAY_SIZE(mcp251x_gpio_names);\n\tgpio->names = mcp251x_gpio_names;\n\tgpio->can_sleep = true;\n\n\treturn devm_gpiochip_add_data(&priv->spi->dev, gpio, priv);\n}\n#else\nstatic inline void mcp251x_gpio_restore(struct spi_device *spi)\n{\n}\n\nstatic inline int mcp251x_gpio_setup(struct mcp251x_priv *priv)\n{\n\treturn 0;\n}\n#endif\n\nstatic void mcp251x_hw_tx_frame(struct spi_device *spi, u8 *buf,\n\t\t\t\tint len, int tx_buf_idx)\n{\n\tstruct mcp251x_priv *priv = spi_get_drvdata(spi);\n\n\tif (mcp251x_is_2510(spi)) {\n\t\tint i;\n\n\t\tfor (i = 1; i < TXBDAT_OFF + len; i++)\n\t\t\tmcp251x_write_reg(spi, TXBCTRL(tx_buf_idx) + i,\n\t\t\t\t\t  buf[i]);\n\t} else {\n\t\tmemcpy(priv->spi_tx_buf, buf, TXBDAT_OFF + len);\n\t\tmcp251x_spi_write(spi, TXBDAT_OFF + len);\n\t}\n}\n\nstatic void mcp251x_hw_tx(struct spi_device *spi, struct can_frame *frame,\n\t\t\t  int tx_buf_idx)\n{\n\tstruct mcp251x_priv *priv = spi_get_drvdata(spi);\n\tu32 sid, eid, exide, rtr;\n\tu8 buf[SPI_TRANSFER_BUF_LEN];\n\n\texide = (frame->can_id & CAN_EFF_FLAG) ? 1 : 0;  \n\tif (exide)\n\t\tsid = (frame->can_id & CAN_EFF_MASK) >> 18;\n\telse\n\t\tsid = frame->can_id & CAN_SFF_MASK;  \n\teid = frame->can_id & CAN_EFF_MASK;  \n\trtr = (frame->can_id & CAN_RTR_FLAG) ? 1 : 0;  \n\n\tbuf[TXBCTRL_OFF] = INSTRUCTION_LOAD_TXB(tx_buf_idx);\n\tbuf[TXBSIDH_OFF] = sid >> SIDH_SHIFT;\n\tbuf[TXBSIDL_OFF] = ((sid & SIDL_SID_MASK) << SIDL_SID_SHIFT) |\n\t\t(exide << SIDL_EXIDE_SHIFT) |\n\t\t((eid >> SIDL_EID_SHIFT) & SIDL_EID_MASK);\n\tbuf[TXBEID8_OFF] = GET_BYTE(eid, 1);\n\tbuf[TXBEID0_OFF] = GET_BYTE(eid, 0);\n\tbuf[TXBDLC_OFF] = (rtr << DLC_RTR_SHIFT) | frame->len;\n\tmemcpy(buf + TXBDAT_OFF, frame->data, frame->len);\n\tmcp251x_hw_tx_frame(spi, buf, frame->len, tx_buf_idx);\n\n\t \n\tpriv->spi_tx_buf[0] = INSTRUCTION_RTS(1 << tx_buf_idx);\n\tmcp251x_spi_write(priv->spi, 1);\n}\n\nstatic void mcp251x_hw_rx_frame(struct spi_device *spi, u8 *buf,\n\t\t\t\tint buf_idx)\n{\n\tstruct mcp251x_priv *priv = spi_get_drvdata(spi);\n\n\tif (mcp251x_is_2510(spi)) {\n\t\tint i, len;\n\n\t\tfor (i = 1; i < RXBDAT_OFF; i++)\n\t\t\tbuf[i] = mcp251x_read_reg(spi, RXBCTRL(buf_idx) + i);\n\n\t\tlen = can_cc_dlc2len(buf[RXBDLC_OFF] & RXBDLC_LEN_MASK);\n\t\tfor (; i < (RXBDAT_OFF + len); i++)\n\t\t\tbuf[i] = mcp251x_read_reg(spi, RXBCTRL(buf_idx) + i);\n\t} else {\n\t\tpriv->spi_tx_buf[RXBCTRL_OFF] = INSTRUCTION_READ_RXB(buf_idx);\n\t\tif (spi->controller->flags & SPI_CONTROLLER_HALF_DUPLEX) {\n\t\t\tspi_write_then_read(spi, priv->spi_tx_buf, 1,\n\t\t\t\t\t    priv->spi_rx_buf,\n\t\t\t\t\t    SPI_TRANSFER_BUF_LEN);\n\t\t\tmemcpy(buf + 1, priv->spi_rx_buf,\n\t\t\t       SPI_TRANSFER_BUF_LEN - 1);\n\t\t} else {\n\t\t\tmcp251x_spi_trans(spi, SPI_TRANSFER_BUF_LEN);\n\t\t\tmemcpy(buf, priv->spi_rx_buf, SPI_TRANSFER_BUF_LEN);\n\t\t}\n\t}\n}\n\nstatic void mcp251x_hw_rx(struct spi_device *spi, int buf_idx)\n{\n\tstruct mcp251x_priv *priv = spi_get_drvdata(spi);\n\tstruct sk_buff *skb;\n\tstruct can_frame *frame;\n\tu8 buf[SPI_TRANSFER_BUF_LEN];\n\n\tskb = alloc_can_skb(priv->net, &frame);\n\tif (!skb) {\n\t\tdev_err(&spi->dev, \"cannot allocate RX skb\\n\");\n\t\tpriv->net->stats.rx_dropped++;\n\t\treturn;\n\t}\n\n\tmcp251x_hw_rx_frame(spi, buf, buf_idx);\n\tif (buf[RXBSIDL_OFF] & RXBSIDL_IDE) {\n\t\t \n\t\tframe->can_id = CAN_EFF_FLAG;\n\t\tframe->can_id |=\n\t\t\t \n\t\t\tSET_BYTE(buf[RXBSIDL_OFF] & RXBSIDL_EID, 2) |\n\t\t\tSET_BYTE(buf[RXBEID8_OFF], 1) |\n\t\t\tSET_BYTE(buf[RXBEID0_OFF], 0) |\n\t\t\t \n\t\t\t(((buf[RXBSIDH_OFF] << RXBSIDH_SHIFT) |\n\t\t\t  (buf[RXBSIDL_OFF] >> RXBSIDL_SHIFT)) << 18);\n\t\t \n\t\tif (buf[RXBDLC_OFF] & RXBDLC_RTR)\n\t\t\tframe->can_id |= CAN_RTR_FLAG;\n\t} else {\n\t\t \n\t\tframe->can_id =\n\t\t\t(buf[RXBSIDH_OFF] << RXBSIDH_SHIFT) |\n\t\t\t(buf[RXBSIDL_OFF] >> RXBSIDL_SHIFT);\n\t\tif (buf[RXBSIDL_OFF] & RXBSIDL_SRR)\n\t\t\tframe->can_id |= CAN_RTR_FLAG;\n\t}\n\t \n\tframe->len = can_cc_dlc2len(buf[RXBDLC_OFF] & RXBDLC_LEN_MASK);\n\tif (!(frame->can_id & CAN_RTR_FLAG)) {\n\t\tmemcpy(frame->data, buf + RXBDAT_OFF, frame->len);\n\n\t\tpriv->net->stats.rx_bytes += frame->len;\n\t}\n\tpriv->net->stats.rx_packets++;\n\n\tnetif_rx(skb);\n}\n\nstatic void mcp251x_hw_sleep(struct spi_device *spi)\n{\n\tmcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_SLEEP);\n}\n\n \nstatic int mcp251x_hw_wake(struct spi_device *spi)\n{\n\tu8 value;\n\tint ret;\n\n\t \n\tdisable_irq(spi->irq);\n\tmcp251x_write_2regs(spi, CANINTE, CANINTE_WAKIE, CANINTF_WAKIF);\n\n\t \n\tmdelay(MCP251X_OST_DELAY_MS);\n\n\t \n\tmcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_CONF);\n\n\t \n\tret = mcp251x_read_stat_poll_timeout(spi, value, value == CANCTRL_REQOP_CONF,\n\t\t\t\t\t     MCP251X_OST_DELAY_MS * 1000,\n\t\t\t\t\t     USEC_PER_SEC);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"MCP251x didn't enter in config mode\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tmcp251x_write_2regs(spi, CANINTE, 0x00, 0x00);\n\tenable_irq(spi->irq);\n\n\treturn 0;\n}\n\nstatic netdev_tx_t mcp251x_hard_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t   struct net_device *net)\n{\n\tstruct mcp251x_priv *priv = netdev_priv(net);\n\tstruct spi_device *spi = priv->spi;\n\n\tif (priv->tx_skb || priv->tx_busy) {\n\t\tdev_warn(&spi->dev, \"hard_xmit called while tx busy\\n\");\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tif (can_dev_dropped_skb(net, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tnetif_stop_queue(net);\n\tpriv->tx_skb = skb;\n\tqueue_work(priv->wq, &priv->tx_work);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int mcp251x_do_set_mode(struct net_device *net, enum can_mode mode)\n{\n\tstruct mcp251x_priv *priv = netdev_priv(net);\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\tmcp251x_clean(net);\n\t\t \n\t\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\tpriv->restart_tx = 1;\n\t\tif (priv->can.restart_ms == 0)\n\t\t\tpriv->after_suspend = AFTER_SUSPEND_RESTART;\n\t\tqueue_work(priv->wq, &priv->restart_work);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int mcp251x_set_normal_mode(struct spi_device *spi)\n{\n\tstruct mcp251x_priv *priv = spi_get_drvdata(spi);\n\tu8 value;\n\tint ret;\n\n\t \n\tmcp251x_write_reg(spi, CANINTE,\n\t\t\t  CANINTE_ERRIE | CANINTE_TX2IE | CANINTE_TX1IE |\n\t\t\t  CANINTE_TX0IE | CANINTE_RX1IE | CANINTE_RX0IE);\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK) {\n\t\t \n\t\tmcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_LOOPBACK);\n\t} else if (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY) {\n\t\t \n\t\tmcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_LISTEN_ONLY);\n\t} else {\n\t\t \n\t\tmcp251x_write_reg(spi, CANCTRL, CANCTRL_REQOP_NORMAL);\n\n\t\t \n\t\tret = mcp251x_read_stat_poll_timeout(spi, value, value == 0,\n\t\t\t\t\t\t     MCP251X_OST_DELAY_MS * 1000,\n\t\t\t\t\t\t     USEC_PER_SEC);\n\t\tif (ret) {\n\t\t\tdev_err(&spi->dev, \"MCP251x didn't enter in normal mode\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\treturn 0;\n}\n\nstatic int mcp251x_do_set_bittiming(struct net_device *net)\n{\n\tstruct mcp251x_priv *priv = netdev_priv(net);\n\tstruct can_bittiming *bt = &priv->can.bittiming;\n\tstruct spi_device *spi = priv->spi;\n\n\tmcp251x_write_reg(spi, CNF1, ((bt->sjw - 1) << CNF1_SJW_SHIFT) |\n\t\t\t  (bt->brp - 1));\n\tmcp251x_write_reg(spi, CNF2, CNF2_BTLMODE |\n\t\t\t  (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES ?\n\t\t\t   CNF2_SAM : 0) |\n\t\t\t  ((bt->phase_seg1 - 1) << CNF2_PS1_SHIFT) |\n\t\t\t  (bt->prop_seg - 1));\n\tmcp251x_write_bits(spi, CNF3, CNF3_PHSEG2_MASK,\n\t\t\t   (bt->phase_seg2 - 1));\n\tdev_dbg(&spi->dev, \"CNF: 0x%02x 0x%02x 0x%02x\\n\",\n\t\tmcp251x_read_reg(spi, CNF1),\n\t\tmcp251x_read_reg(spi, CNF2),\n\t\tmcp251x_read_reg(spi, CNF3));\n\n\treturn 0;\n}\n\nstatic int mcp251x_setup(struct net_device *net, struct spi_device *spi)\n{\n\tmcp251x_do_set_bittiming(net);\n\n\tmcp251x_write_reg(spi, RXBCTRL(0),\n\t\t\t  RXBCTRL_BUKT | RXBCTRL_RXM0 | RXBCTRL_RXM1);\n\tmcp251x_write_reg(spi, RXBCTRL(1),\n\t\t\t  RXBCTRL_RXM0 | RXBCTRL_RXM1);\n\treturn 0;\n}\n\nstatic int mcp251x_hw_reset(struct spi_device *spi)\n{\n\tstruct mcp251x_priv *priv = spi_get_drvdata(spi);\n\tu8 value;\n\tint ret;\n\n\t \n\tmdelay(MCP251X_OST_DELAY_MS);\n\n\tpriv->spi_tx_buf[0] = INSTRUCTION_RESET;\n\tret = mcp251x_spi_write(spi, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmdelay(MCP251X_OST_DELAY_MS);\n\n\t \n\tret = mcp251x_read_stat_poll_timeout(spi, value, value == CANCTRL_REQOP_CONF,\n\t\t\t\t\t     MCP251X_OST_DELAY_MS * 1000,\n\t\t\t\t\t     USEC_PER_SEC);\n\tif (ret)\n\t\tdev_err(&spi->dev, \"MCP251x didn't enter in conf mode after reset\\n\");\n\treturn ret;\n}\n\nstatic int mcp251x_hw_probe(struct spi_device *spi)\n{\n\tu8 ctrl;\n\tint ret;\n\n\tret = mcp251x_hw_reset(spi);\n\tif (ret)\n\t\treturn ret;\n\n\tctrl = mcp251x_read_reg(spi, CANCTRL);\n\n\tdev_dbg(&spi->dev, \"CANCTRL 0x%02x\\n\", ctrl);\n\n\t \n\tif ((ctrl & 0x17) != 0x07)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int mcp251x_power_enable(struct regulator *reg, int enable)\n{\n\tif (IS_ERR_OR_NULL(reg))\n\t\treturn 0;\n\n\tif (enable)\n\t\treturn regulator_enable(reg);\n\telse\n\t\treturn regulator_disable(reg);\n}\n\nstatic int mcp251x_stop(struct net_device *net)\n{\n\tstruct mcp251x_priv *priv = netdev_priv(net);\n\tstruct spi_device *spi = priv->spi;\n\n\tclose_candev(net);\n\n\tpriv->force_quit = 1;\n\tfree_irq(spi->irq, priv);\n\n\tmutex_lock(&priv->mcp_lock);\n\n\t \n\tmcp251x_write_2regs(spi, CANINTE, 0x00, 0x00);\n\n\tmcp251x_write_reg(spi, TXBCTRL(0), 0);\n\tmcp251x_clean(net);\n\n\tmcp251x_hw_sleep(spi);\n\n\tmcp251x_power_enable(priv->transceiver, 0);\n\n\tpriv->can.state = CAN_STATE_STOPPED;\n\n\tmutex_unlock(&priv->mcp_lock);\n\n\treturn 0;\n}\n\nstatic void mcp251x_error_skb(struct net_device *net, int can_id, int data1)\n{\n\tstruct sk_buff *skb;\n\tstruct can_frame *frame;\n\n\tskb = alloc_can_err_skb(net, &frame);\n\tif (skb) {\n\t\tframe->can_id |= can_id;\n\t\tframe->data[1] = data1;\n\t\tnetif_rx(skb);\n\t} else {\n\t\tnetdev_err(net, \"cannot allocate error skb\\n\");\n\t}\n}\n\nstatic void mcp251x_tx_work_handler(struct work_struct *ws)\n{\n\tstruct mcp251x_priv *priv = container_of(ws, struct mcp251x_priv,\n\t\t\t\t\t\t tx_work);\n\tstruct spi_device *spi = priv->spi;\n\tstruct net_device *net = priv->net;\n\tstruct can_frame *frame;\n\n\tmutex_lock(&priv->mcp_lock);\n\tif (priv->tx_skb) {\n\t\tif (priv->can.state == CAN_STATE_BUS_OFF) {\n\t\t\tmcp251x_clean(net);\n\t\t} else {\n\t\t\tframe = (struct can_frame *)priv->tx_skb->data;\n\n\t\t\tif (frame->len > CAN_FRAME_MAX_DATA_LEN)\n\t\t\t\tframe->len = CAN_FRAME_MAX_DATA_LEN;\n\t\t\tmcp251x_hw_tx(spi, frame, 0);\n\t\t\tpriv->tx_busy = true;\n\t\t\tcan_put_echo_skb(priv->tx_skb, net, 0, 0);\n\t\t\tpriv->tx_skb = NULL;\n\t\t}\n\t}\n\tmutex_unlock(&priv->mcp_lock);\n}\n\nstatic void mcp251x_restart_work_handler(struct work_struct *ws)\n{\n\tstruct mcp251x_priv *priv = container_of(ws, struct mcp251x_priv,\n\t\t\t\t\t\t restart_work);\n\tstruct spi_device *spi = priv->spi;\n\tstruct net_device *net = priv->net;\n\n\tmutex_lock(&priv->mcp_lock);\n\tif (priv->after_suspend) {\n\t\tif (priv->after_suspend & AFTER_SUSPEND_POWER) {\n\t\t\tmcp251x_hw_reset(spi);\n\t\t\tmcp251x_setup(net, spi);\n\t\t\tmcp251x_gpio_restore(spi);\n\t\t} else {\n\t\t\tmcp251x_hw_wake(spi);\n\t\t}\n\t\tpriv->force_quit = 0;\n\t\tif (priv->after_suspend & AFTER_SUSPEND_RESTART) {\n\t\t\tmcp251x_set_normal_mode(spi);\n\t\t} else if (priv->after_suspend & AFTER_SUSPEND_UP) {\n\t\t\tnetif_device_attach(net);\n\t\t\tmcp251x_clean(net);\n\t\t\tmcp251x_set_normal_mode(spi);\n\t\t\tnetif_wake_queue(net);\n\t\t} else {\n\t\t\tmcp251x_hw_sleep(spi);\n\t\t}\n\t\tpriv->after_suspend = 0;\n\t}\n\n\tif (priv->restart_tx) {\n\t\tpriv->restart_tx = 0;\n\t\tmcp251x_write_reg(spi, TXBCTRL(0), 0);\n\t\tmcp251x_clean(net);\n\t\tnetif_wake_queue(net);\n\t\tmcp251x_error_skb(net, CAN_ERR_RESTARTED, 0);\n\t}\n\tmutex_unlock(&priv->mcp_lock);\n}\n\nstatic irqreturn_t mcp251x_can_ist(int irq, void *dev_id)\n{\n\tstruct mcp251x_priv *priv = dev_id;\n\tstruct spi_device *spi = priv->spi;\n\tstruct net_device *net = priv->net;\n\n\tmutex_lock(&priv->mcp_lock);\n\twhile (!priv->force_quit) {\n\t\tenum can_state new_state;\n\t\tu8 intf, eflag;\n\t\tu8 clear_intf = 0;\n\t\tint can_id = 0, data1 = 0;\n\n\t\tmcp251x_read_2regs(spi, CANINTF, &intf, &eflag);\n\n\t\t \n\t\tif (intf & CANINTF_RX0IF) {\n\t\t\tmcp251x_hw_rx(spi, 0);\n\t\t\t \n\t\t\tif (mcp251x_is_2510(spi))\n\t\t\t\tmcp251x_write_bits(spi, CANINTF,\n\t\t\t\t\t\t   CANINTF_RX0IF, 0x00);\n\n\t\t\t \n\t\t\tif (!(intf & CANINTF_RX1IF)) {\n\t\t\t\tu8 intf1, eflag1;\n\n\t\t\t\t \n\t\t\t\tmcp251x_read_2regs(spi, CANINTF, &intf1, &eflag1);\n\n\t\t\t\t \n\t\t\t\tintf |= intf1;\n\t\t\t\teflag |= eflag1;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (intf & CANINTF_RX1IF) {\n\t\t\tmcp251x_hw_rx(spi, 1);\n\t\t\t \n\t\t\tif (mcp251x_is_2510(spi))\n\t\t\t\tclear_intf |= CANINTF_RX1IF;\n\t\t}\n\n\t\t \n\t\tintf &= CANINTF_RX | CANINTF_TX | CANINTF_ERR;\n\n\t\t \n\t\tif (intf & (CANINTF_ERR | CANINTF_TX))\n\t\t\tclear_intf |= intf & (CANINTF_ERR | CANINTF_TX);\n\t\tif (clear_intf)\n\t\t\tmcp251x_write_bits(spi, CANINTF, clear_intf, 0x00);\n\n\t\tif (eflag & (EFLG_RX0OVR | EFLG_RX1OVR))\n\t\t\tmcp251x_write_bits(spi, EFLG, eflag, 0x00);\n\n\t\t \n\t\tif (eflag & EFLG_TXBO) {\n\t\t\tnew_state = CAN_STATE_BUS_OFF;\n\t\t\tcan_id |= CAN_ERR_BUSOFF;\n\t\t} else if (eflag & EFLG_TXEP) {\n\t\t\tnew_state = CAN_STATE_ERROR_PASSIVE;\n\t\t\tcan_id |= CAN_ERR_CRTL;\n\t\t\tdata1 |= CAN_ERR_CRTL_TX_PASSIVE;\n\t\t} else if (eflag & EFLG_RXEP) {\n\t\t\tnew_state = CAN_STATE_ERROR_PASSIVE;\n\t\t\tcan_id |= CAN_ERR_CRTL;\n\t\t\tdata1 |= CAN_ERR_CRTL_RX_PASSIVE;\n\t\t} else if (eflag & EFLG_TXWAR) {\n\t\t\tnew_state = CAN_STATE_ERROR_WARNING;\n\t\t\tcan_id |= CAN_ERR_CRTL;\n\t\t\tdata1 |= CAN_ERR_CRTL_TX_WARNING;\n\t\t} else if (eflag & EFLG_RXWAR) {\n\t\t\tnew_state = CAN_STATE_ERROR_WARNING;\n\t\t\tcan_id |= CAN_ERR_CRTL;\n\t\t\tdata1 |= CAN_ERR_CRTL_RX_WARNING;\n\t\t} else {\n\t\t\tnew_state = CAN_STATE_ERROR_ACTIVE;\n\t\t}\n\n\t\t \n\t\tswitch (priv->can.state) {\n\t\tcase CAN_STATE_ERROR_ACTIVE:\n\t\t\tif (new_state >= CAN_STATE_ERROR_WARNING &&\n\t\t\t    new_state <= CAN_STATE_BUS_OFF)\n\t\t\t\tpriv->can.can_stats.error_warning++;\n\t\t\tfallthrough;\n\t\tcase CAN_STATE_ERROR_WARNING:\n\t\t\tif (new_state >= CAN_STATE_ERROR_PASSIVE &&\n\t\t\t    new_state <= CAN_STATE_BUS_OFF)\n\t\t\t\tpriv->can.can_stats.error_passive++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tpriv->can.state = new_state;\n\n\t\tif (intf & CANINTF_ERRIF) {\n\t\t\t \n\t\t\tif (eflag & (EFLG_RX0OVR | EFLG_RX1OVR)) {\n\t\t\t\tif (eflag & EFLG_RX0OVR) {\n\t\t\t\t\tnet->stats.rx_over_errors++;\n\t\t\t\t\tnet->stats.rx_errors++;\n\t\t\t\t}\n\t\t\t\tif (eflag & EFLG_RX1OVR) {\n\t\t\t\t\tnet->stats.rx_over_errors++;\n\t\t\t\t\tnet->stats.rx_errors++;\n\t\t\t\t}\n\t\t\t\tcan_id |= CAN_ERR_CRTL;\n\t\t\t\tdata1 |= CAN_ERR_CRTL_RX_OVERFLOW;\n\t\t\t}\n\t\t\tmcp251x_error_skb(net, can_id, data1);\n\t\t}\n\n\t\tif (priv->can.state == CAN_STATE_BUS_OFF) {\n\t\t\tif (priv->can.restart_ms == 0) {\n\t\t\t\tpriv->force_quit = 1;\n\t\t\t\tpriv->can.can_stats.bus_off++;\n\t\t\t\tcan_bus_off(net);\n\t\t\t\tmcp251x_hw_sleep(spi);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (intf == 0)\n\t\t\tbreak;\n\n\t\tif (intf & CANINTF_TX) {\n\t\t\tif (priv->tx_busy) {\n\t\t\t\tnet->stats.tx_packets++;\n\t\t\t\tnet->stats.tx_bytes += can_get_echo_skb(net, 0,\n\t\t\t\t\t\t\t\t\tNULL);\n\t\t\t\tpriv->tx_busy = false;\n\t\t\t}\n\t\t\tnetif_wake_queue(net);\n\t\t}\n\t}\n\tmutex_unlock(&priv->mcp_lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic int mcp251x_open(struct net_device *net)\n{\n\tstruct mcp251x_priv *priv = netdev_priv(net);\n\tstruct spi_device *spi = priv->spi;\n\tunsigned long flags = 0;\n\tint ret;\n\n\tret = open_candev(net);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"unable to set initial baudrate!\\n\");\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&priv->mcp_lock);\n\tmcp251x_power_enable(priv->transceiver, 1);\n\n\tpriv->force_quit = 0;\n\tpriv->tx_skb = NULL;\n\tpriv->tx_busy = false;\n\n\tif (!dev_fwnode(&spi->dev))\n\t\tflags = IRQF_TRIGGER_FALLING;\n\n\tret = request_threaded_irq(spi->irq, NULL, mcp251x_can_ist,\n\t\t\t\t   flags | IRQF_ONESHOT, dev_name(&spi->dev),\n\t\t\t\t   priv);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"failed to acquire irq %d\\n\", spi->irq);\n\t\tgoto out_close;\n\t}\n\n\tret = mcp251x_hw_wake(spi);\n\tif (ret)\n\t\tgoto out_free_irq;\n\tret = mcp251x_setup(net, spi);\n\tif (ret)\n\t\tgoto out_free_irq;\n\tret = mcp251x_set_normal_mode(spi);\n\tif (ret)\n\t\tgoto out_free_irq;\n\n\tnetif_wake_queue(net);\n\tmutex_unlock(&priv->mcp_lock);\n\n\treturn 0;\n\nout_free_irq:\n\tfree_irq(spi->irq, priv);\n\tmcp251x_hw_sleep(spi);\nout_close:\n\tmcp251x_power_enable(priv->transceiver, 0);\n\tclose_candev(net);\n\tmutex_unlock(&priv->mcp_lock);\n\treturn ret;\n}\n\nstatic const struct net_device_ops mcp251x_netdev_ops = {\n\t.ndo_open = mcp251x_open,\n\t.ndo_stop = mcp251x_stop,\n\t.ndo_start_xmit = mcp251x_hard_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic const struct ethtool_ops mcp251x_ethtool_ops = {\n\t.get_ts_info = ethtool_op_get_ts_info,\n};\n\nstatic const struct of_device_id mcp251x_of_match[] = {\n\t{\n\t\t.compatible\t= \"microchip,mcp2510\",\n\t\t.data\t\t= (void *)CAN_MCP251X_MCP2510,\n\t},\n\t{\n\t\t.compatible\t= \"microchip,mcp2515\",\n\t\t.data\t\t= (void *)CAN_MCP251X_MCP2515,\n\t},\n\t{\n\t\t.compatible\t= \"microchip,mcp25625\",\n\t\t.data\t\t= (void *)CAN_MCP251X_MCP25625,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mcp251x_of_match);\n\nstatic const struct spi_device_id mcp251x_id_table[] = {\n\t{\n\t\t.name\t\t= \"mcp2510\",\n\t\t.driver_data\t= (kernel_ulong_t)CAN_MCP251X_MCP2510,\n\t},\n\t{\n\t\t.name\t\t= \"mcp2515\",\n\t\t.driver_data\t= (kernel_ulong_t)CAN_MCP251X_MCP2515,\n\t},\n\t{\n\t\t.name\t\t= \"mcp25625\",\n\t\t.driver_data\t= (kernel_ulong_t)CAN_MCP251X_MCP25625,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, mcp251x_id_table);\n\nstatic int mcp251x_can_probe(struct spi_device *spi)\n{\n\tconst void *match = device_get_match_data(&spi->dev);\n\tstruct net_device *net;\n\tstruct mcp251x_priv *priv;\n\tstruct clk *clk;\n\tu32 freq;\n\tint ret;\n\n\tclk = devm_clk_get_optional(&spi->dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tfreq = clk_get_rate(clk);\n\tif (freq == 0)\n\t\tdevice_property_read_u32(&spi->dev, \"clock-frequency\", &freq);\n\n\t \n\tif (freq < 1000000 || freq > 25000000)\n\t\treturn -ERANGE;\n\n\t \n\tnet = alloc_candev(sizeof(struct mcp251x_priv), TX_ECHO_SKB_MAX);\n\tif (!net)\n\t\treturn -ENOMEM;\n\n\tret = clk_prepare_enable(clk);\n\tif (ret)\n\t\tgoto out_free;\n\n\tnet->netdev_ops = &mcp251x_netdev_ops;\n\tnet->ethtool_ops = &mcp251x_ethtool_ops;\n\tnet->flags |= IFF_ECHO;\n\n\tpriv = netdev_priv(net);\n\tpriv->can.bittiming_const = &mcp251x_bittiming_const;\n\tpriv->can.do_set_mode = mcp251x_do_set_mode;\n\tpriv->can.clock.freq = freq / 2;\n\tpriv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES |\n\t\tCAN_CTRLMODE_LOOPBACK | CAN_CTRLMODE_LISTENONLY;\n\tif (match)\n\t\tpriv->model = (enum mcp251x_model)(uintptr_t)match;\n\telse\n\t\tpriv->model = spi_get_device_id(spi)->driver_data;\n\tpriv->net = net;\n\tpriv->clk = clk;\n\n\tspi_set_drvdata(spi, priv);\n\n\t \n\tspi->bits_per_word = 8;\n\tif (mcp251x_is_2510(spi))\n\t\tspi->max_speed_hz = spi->max_speed_hz ? : 5 * 1000 * 1000;\n\telse\n\t\tspi->max_speed_hz = spi->max_speed_hz ? : 10 * 1000 * 1000;\n\tret = spi_setup(spi);\n\tif (ret)\n\t\tgoto out_clk;\n\n\tpriv->power = devm_regulator_get_optional(&spi->dev, \"vdd\");\n\tpriv->transceiver = devm_regulator_get_optional(&spi->dev, \"xceiver\");\n\tif ((PTR_ERR(priv->power) == -EPROBE_DEFER) ||\n\t    (PTR_ERR(priv->transceiver) == -EPROBE_DEFER)) {\n\t\tret = -EPROBE_DEFER;\n\t\tgoto out_clk;\n\t}\n\n\tret = mcp251x_power_enable(priv->power, 1);\n\tif (ret)\n\t\tgoto out_clk;\n\n\tpriv->wq = alloc_workqueue(\"mcp251x_wq\", WQ_FREEZABLE | WQ_MEM_RECLAIM,\n\t\t\t\t   0);\n\tif (!priv->wq) {\n\t\tret = -ENOMEM;\n\t\tgoto out_clk;\n\t}\n\tINIT_WORK(&priv->tx_work, mcp251x_tx_work_handler);\n\tINIT_WORK(&priv->restart_work, mcp251x_restart_work_handler);\n\n\tpriv->spi = spi;\n\tmutex_init(&priv->mcp_lock);\n\n\tpriv->spi_tx_buf = devm_kzalloc(&spi->dev, SPI_TRANSFER_BUF_LEN,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!priv->spi_tx_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto error_probe;\n\t}\n\n\tpriv->spi_rx_buf = devm_kzalloc(&spi->dev, SPI_TRANSFER_BUF_LEN,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!priv->spi_rx_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto error_probe;\n\t}\n\n\tSET_NETDEV_DEV(net, &spi->dev);\n\n\t \n\tret = mcp251x_hw_probe(spi);\n\tif (ret) {\n\t\tif (ret == -ENODEV)\n\t\t\tdev_err(&spi->dev, \"Cannot initialize MCP%x. Wrong wiring?\\n\",\n\t\t\t\tpriv->model);\n\t\tgoto error_probe;\n\t}\n\n\tmcp251x_hw_sleep(spi);\n\n\tret = register_candev(net);\n\tif (ret)\n\t\tgoto error_probe;\n\n\tret = mcp251x_gpio_setup(priv);\n\tif (ret)\n\t\tgoto out_unregister_candev;\n\n\tnetdev_info(net, \"MCP%x successfully initialized.\\n\", priv->model);\n\treturn 0;\n\nout_unregister_candev:\n\tunregister_candev(net);\n\nerror_probe:\n\tdestroy_workqueue(priv->wq);\n\tpriv->wq = NULL;\n\tmcp251x_power_enable(priv->power, 0);\n\nout_clk:\n\tclk_disable_unprepare(clk);\n\nout_free:\n\tfree_candev(net);\n\n\tdev_err(&spi->dev, \"Probe failed, err=%d\\n\", -ret);\n\treturn ret;\n}\n\nstatic void mcp251x_can_remove(struct spi_device *spi)\n{\n\tstruct mcp251x_priv *priv = spi_get_drvdata(spi);\n\tstruct net_device *net = priv->net;\n\n\tunregister_candev(net);\n\n\tmcp251x_power_enable(priv->power, 0);\n\n\tdestroy_workqueue(priv->wq);\n\tpriv->wq = NULL;\n\n\tclk_disable_unprepare(priv->clk);\n\n\tfree_candev(net);\n}\n\nstatic int __maybe_unused mcp251x_can_suspend(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct mcp251x_priv *priv = spi_get_drvdata(spi);\n\tstruct net_device *net = priv->net;\n\n\tpriv->force_quit = 1;\n\tdisable_irq(spi->irq);\n\t \n\tif (netif_running(net)) {\n\t\tnetif_device_detach(net);\n\n\t\tmcp251x_hw_sleep(spi);\n\t\tmcp251x_power_enable(priv->transceiver, 0);\n\t\tpriv->after_suspend = AFTER_SUSPEND_UP;\n\t} else {\n\t\tpriv->after_suspend = AFTER_SUSPEND_DOWN;\n\t}\n\n\tmcp251x_power_enable(priv->power, 0);\n\tpriv->after_suspend |= AFTER_SUSPEND_POWER;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused mcp251x_can_resume(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct mcp251x_priv *priv = spi_get_drvdata(spi);\n\n\tif (priv->after_suspend & AFTER_SUSPEND_POWER)\n\t\tmcp251x_power_enable(priv->power, 1);\n\tif (priv->after_suspend & AFTER_SUSPEND_UP)\n\t\tmcp251x_power_enable(priv->transceiver, 1);\n\n\tif (priv->after_suspend & (AFTER_SUSPEND_POWER | AFTER_SUSPEND_UP))\n\t\tqueue_work(priv->wq, &priv->restart_work);\n\telse\n\t\tpriv->after_suspend = 0;\n\n\tpriv->force_quit = 0;\n\tenable_irq(spi->irq);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(mcp251x_can_pm_ops, mcp251x_can_suspend,\n\tmcp251x_can_resume);\n\nstatic struct spi_driver mcp251x_can_driver = {\n\t.driver = {\n\t\t.name = DEVICE_NAME,\n\t\t.of_match_table = mcp251x_of_match,\n\t\t.pm = &mcp251x_can_pm_ops,\n\t},\n\t.id_table = mcp251x_id_table,\n\t.probe = mcp251x_can_probe,\n\t.remove = mcp251x_can_remove,\n};\nmodule_spi_driver(mcp251x_can_driver);\n\nMODULE_AUTHOR(\"Chris Elston <celston@katalix.com>, \"\n\t      \"Christian Pellegrin <chripell@evolware.org>\");\nMODULE_DESCRIPTION(\"Microchip 251x/25625 CAN driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}