{
  "module_name": "mcp251xfd-core.c",
  "hash_id": "aedea60d190d59264fcd8c04fd6a8fac4350a7eec54399c4e45ad8f749aaa897",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/spi/mcp251xfd/mcp251xfd-core.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <asm/unaligned.h>\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n\n#include \"mcp251xfd.h\"\n\n#define DEVICE_NAME \"mcp251xfd\"\n\nstatic const struct mcp251xfd_devtype_data mcp251xfd_devtype_data_mcp2517fd = {\n\t.quirks = MCP251XFD_QUIRK_MAB_NO_WARN | MCP251XFD_QUIRK_CRC_REG |\n\t\tMCP251XFD_QUIRK_CRC_RX | MCP251XFD_QUIRK_CRC_TX |\n\t\tMCP251XFD_QUIRK_ECC,\n\t.model = MCP251XFD_MODEL_MCP2517FD,\n};\n\nstatic const struct mcp251xfd_devtype_data mcp251xfd_devtype_data_mcp2518fd = {\n\t.quirks = MCP251XFD_QUIRK_CRC_REG | MCP251XFD_QUIRK_CRC_RX |\n\t\tMCP251XFD_QUIRK_CRC_TX | MCP251XFD_QUIRK_ECC,\n\t.model = MCP251XFD_MODEL_MCP2518FD,\n};\n\nstatic const struct mcp251xfd_devtype_data mcp251xfd_devtype_data_mcp251863 = {\n\t.quirks = MCP251XFD_QUIRK_CRC_REG | MCP251XFD_QUIRK_CRC_RX |\n\t\tMCP251XFD_QUIRK_CRC_TX | MCP251XFD_QUIRK_ECC,\n\t.model = MCP251XFD_MODEL_MCP251863,\n};\n\n \nstatic const struct mcp251xfd_devtype_data mcp251xfd_devtype_data_mcp251xfd = {\n\t.quirks = MCP251XFD_QUIRK_CRC_REG | MCP251XFD_QUIRK_CRC_RX |\n\t\tMCP251XFD_QUIRK_CRC_TX | MCP251XFD_QUIRK_ECC,\n\t.model = MCP251XFD_MODEL_MCP251XFD,\n};\n\nstatic const struct can_bittiming_const mcp251xfd_bittiming_const = {\n\t.name = DEVICE_NAME,\n\t.tseg1_min = 2,\n\t.tseg1_max = 256,\n\t.tseg2_min = 1,\n\t.tseg2_max = 128,\n\t.sjw_max = 128,\n\t.brp_min = 1,\n\t.brp_max = 256,\n\t.brp_inc = 1,\n};\n\nstatic const struct can_bittiming_const mcp251xfd_data_bittiming_const = {\n\t.name = DEVICE_NAME,\n\t.tseg1_min = 1,\n\t.tseg1_max = 32,\n\t.tseg2_min = 1,\n\t.tseg2_max = 16,\n\t.sjw_max = 16,\n\t.brp_min = 1,\n\t.brp_max = 256,\n\t.brp_inc = 1,\n};\n\nstatic const char *__mcp251xfd_get_model_str(enum mcp251xfd_model model)\n{\n\tswitch (model) {\n\tcase MCP251XFD_MODEL_MCP2517FD:\n\t\treturn \"MCP2517FD\";\n\tcase MCP251XFD_MODEL_MCP2518FD:\n\t\treturn \"MCP2518FD\";\n\tcase MCP251XFD_MODEL_MCP251863:\n\t\treturn \"MCP251863\";\n\tcase MCP251XFD_MODEL_MCP251XFD:\n\t\treturn \"MCP251xFD\";\n\t}\n\n\treturn \"<unknown>\";\n}\n\nstatic inline const char *\nmcp251xfd_get_model_str(const struct mcp251xfd_priv *priv)\n{\n\treturn __mcp251xfd_get_model_str(priv->devtype_data.model);\n}\n\nstatic const char *mcp251xfd_get_mode_str(const u8 mode)\n{\n\tswitch (mode) {\n\tcase MCP251XFD_REG_CON_MODE_MIXED:\n\t\treturn \"Mixed (CAN FD/CAN 2.0)\";\n\tcase MCP251XFD_REG_CON_MODE_SLEEP:\n\t\treturn \"Sleep\";\n\tcase MCP251XFD_REG_CON_MODE_INT_LOOPBACK:\n\t\treturn \"Internal Loopback\";\n\tcase MCP251XFD_REG_CON_MODE_LISTENONLY:\n\t\treturn \"Listen Only\";\n\tcase MCP251XFD_REG_CON_MODE_CONFIG:\n\t\treturn \"Configuration\";\n\tcase MCP251XFD_REG_CON_MODE_EXT_LOOPBACK:\n\t\treturn \"External Loopback\";\n\tcase MCP251XFD_REG_CON_MODE_CAN2_0:\n\t\treturn \"CAN 2.0\";\n\tcase MCP251XFD_REG_CON_MODE_RESTRICTED:\n\t\treturn \"Restricted Operation\";\n\t}\n\n\treturn \"<unknown>\";\n}\n\nstatic const char *\nmcp251xfd_get_osc_str(const u32 osc, const u32 osc_reference)\n{\n\tswitch (~osc & osc_reference &\n\t\t(MCP251XFD_REG_OSC_OSCRDY | MCP251XFD_REG_OSC_PLLRDY)) {\n\tcase MCP251XFD_REG_OSC_PLLRDY:\n\t\treturn \"PLL\";\n\tcase MCP251XFD_REG_OSC_OSCRDY:\n\t\treturn \"Oscillator\";\n\tcase MCP251XFD_REG_OSC_PLLRDY | MCP251XFD_REG_OSC_OSCRDY:\n\t\treturn \"Oscillator/PLL\";\n\t}\n\n\treturn \"<unknown>\";\n}\n\nstatic inline int mcp251xfd_vdd_enable(const struct mcp251xfd_priv *priv)\n{\n\tif (!priv->reg_vdd)\n\t\treturn 0;\n\n\treturn regulator_enable(priv->reg_vdd);\n}\n\nstatic inline int mcp251xfd_vdd_disable(const struct mcp251xfd_priv *priv)\n{\n\tif (!priv->reg_vdd)\n\t\treturn 0;\n\n\treturn regulator_disable(priv->reg_vdd);\n}\n\nstatic inline int\nmcp251xfd_transceiver_enable(const struct mcp251xfd_priv *priv)\n{\n\tif (!priv->reg_xceiver)\n\t\treturn 0;\n\n\treturn regulator_enable(priv->reg_xceiver);\n}\n\nstatic inline int\nmcp251xfd_transceiver_disable(const struct mcp251xfd_priv *priv)\n{\n\tif (!priv->reg_xceiver)\n\t\treturn 0;\n\n\treturn regulator_disable(priv->reg_xceiver);\n}\n\nstatic int mcp251xfd_clks_and_vdd_enable(const struct mcp251xfd_priv *priv)\n{\n\tint err;\n\n\terr = clk_prepare_enable(priv->clk);\n\tif (err)\n\t\treturn err;\n\n\terr = mcp251xfd_vdd_enable(priv);\n\tif (err)\n\t\tclk_disable_unprepare(priv->clk);\n\n\t \n\tusleep_range(MCP251XFD_OSC_STAB_SLEEP_US,\n\t\t     2 * MCP251XFD_OSC_STAB_SLEEP_US);\n\n\treturn err;\n}\n\nstatic int mcp251xfd_clks_and_vdd_disable(const struct mcp251xfd_priv *priv)\n{\n\tint err;\n\n\terr = mcp251xfd_vdd_disable(priv);\n\tif (err)\n\t\treturn err;\n\n\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n}\n\nstatic inline bool mcp251xfd_reg_invalid(u32 reg)\n{\n\treturn reg == 0x0 || reg == 0xffffffff;\n}\n\nstatic inline int\nmcp251xfd_chip_get_mode(const struct mcp251xfd_priv *priv, u8 *mode)\n{\n\tu32 val;\n\tint err;\n\n\terr = regmap_read(priv->map_reg, MCP251XFD_REG_CON, &val);\n\tif (err)\n\t\treturn err;\n\n\t*mode = FIELD_GET(MCP251XFD_REG_CON_OPMOD_MASK, val);\n\n\treturn 0;\n}\n\nstatic int\n__mcp251xfd_chip_set_mode(const struct mcp251xfd_priv *priv,\n\t\t\t  const u8 mode_req, bool nowait)\n{\n\tconst struct can_bittiming *bt = &priv->can.bittiming;\n\tunsigned long timeout_us = MCP251XFD_POLL_TIMEOUT_US;\n\tu32 con = 0, con_reqop, osc = 0;\n\tu8 mode;\n\tint err;\n\n\tcon_reqop = FIELD_PREP(MCP251XFD_REG_CON_REQOP_MASK, mode_req);\n\terr = regmap_update_bits(priv->map_reg, MCP251XFD_REG_CON,\n\t\t\t\t MCP251XFD_REG_CON_REQOP_MASK, con_reqop);\n\tif (err == -EBADMSG) {\n\t\tnetdev_err(priv->ndev,\n\t\t\t   \"Failed to set Requested Operation Mode.\\n\");\n\n\t\treturn -ENODEV;\n\t} else if (err) {\n\t\treturn err;\n\t}\n\n\tif (mode_req == MCP251XFD_REG_CON_MODE_SLEEP || nowait)\n\t\treturn 0;\n\n\tif (bt->bitrate)\n\t\ttimeout_us = max_t(unsigned long, timeout_us,\n\t\t\t\t   MCP251XFD_FRAME_LEN_MAX_BITS * USEC_PER_SEC /\n\t\t\t\t   bt->bitrate);\n\n\terr = regmap_read_poll_timeout(priv->map_reg, MCP251XFD_REG_CON, con,\n\t\t\t\t       !mcp251xfd_reg_invalid(con) &&\n\t\t\t\t       FIELD_GET(MCP251XFD_REG_CON_OPMOD_MASK,\n\t\t\t\t\t\t con) == mode_req,\n\t\t\t\t       MCP251XFD_POLL_SLEEP_US, timeout_us);\n\tif (err != -ETIMEDOUT && err != -EBADMSG)\n\t\treturn err;\n\n\t \n\tregmap_read(priv->map_reg, MCP251XFD_REG_OSC, &osc);\n\n\tif (mcp251xfd_reg_invalid(con)) {\n\t\tnetdev_err(priv->ndev,\n\t\t\t   \"Failed to read CAN Control Register (con=0x%08x, osc=0x%08x).\\n\",\n\t\t\t   con, osc);\n\n\t\treturn -ENODEV;\n\t}\n\n\tmode = FIELD_GET(MCP251XFD_REG_CON_OPMOD_MASK, con);\n\tnetdev_err(priv->ndev,\n\t\t   \"Controller failed to enter mode %s Mode (%u) and stays in %s Mode (%u) (con=0x%08x, osc=0x%08x).\\n\",\n\t\t   mcp251xfd_get_mode_str(mode_req), mode_req,\n\t\t   mcp251xfd_get_mode_str(mode), mode,\n\t\t   con, osc);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic inline int\nmcp251xfd_chip_set_mode(const struct mcp251xfd_priv *priv,\n\t\t\tconst u8 mode_req)\n{\n\treturn __mcp251xfd_chip_set_mode(priv, mode_req, false);\n}\n\nstatic inline int __maybe_unused\nmcp251xfd_chip_set_mode_nowait(const struct mcp251xfd_priv *priv,\n\t\t\t       const u8 mode_req)\n{\n\treturn __mcp251xfd_chip_set_mode(priv, mode_req, true);\n}\n\nstatic int\nmcp251xfd_chip_wait_for_osc_ready(const struct mcp251xfd_priv *priv,\n\t\t\t\t  u32 osc_reference, u32 osc_mask)\n{\n\tu32 osc;\n\tint err;\n\n\terr = regmap_read_poll_timeout(priv->map_reg, MCP251XFD_REG_OSC, osc,\n\t\t\t\t       !mcp251xfd_reg_invalid(osc) &&\n\t\t\t\t       (osc & osc_mask) == osc_reference,\n\t\t\t\t       MCP251XFD_OSC_STAB_SLEEP_US,\n\t\t\t\t       MCP251XFD_OSC_STAB_TIMEOUT_US);\n\tif (err != -ETIMEDOUT)\n\t\treturn err;\n\n\tif (mcp251xfd_reg_invalid(osc)) {\n\t\tnetdev_err(priv->ndev,\n\t\t\t   \"Failed to read Oscillator Configuration Register (osc=0x%08x).\\n\",\n\t\t\t   osc);\n\t\treturn -ENODEV;\n\t}\n\n\tnetdev_err(priv->ndev,\n\t\t   \"Timeout waiting for %s ready (osc=0x%08x, osc_reference=0x%08x, osc_mask=0x%08x).\\n\",\n\t\t   mcp251xfd_get_osc_str(osc, osc_reference),\n\t\t   osc, osc_reference, osc_mask);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int mcp251xfd_chip_wake(const struct mcp251xfd_priv *priv)\n{\n\tu32 osc, osc_reference, osc_mask;\n\tint err;\n\n\t \n\tosc = FIELD_PREP(MCP251XFD_REG_OSC_CLKODIV_MASK,\n\t\t\t MCP251XFD_REG_OSC_CLKODIV_10);\n\n\t \n\tosc_reference = MCP251XFD_REG_OSC_OSCRDY;\n\tosc_mask = MCP251XFD_REG_OSC_OSCRDY;\n\n\t \n\terr = regmap_write(priv->map_reg, MCP251XFD_REG_OSC, osc);\n\tif (err)\n\t\treturn err;\n\n\t \n\treturn mcp251xfd_chip_wait_for_osc_ready(priv, osc_reference, osc_mask);\n}\n\nstatic inline int mcp251xfd_chip_sleep(const struct mcp251xfd_priv *priv)\n{\n\tif (priv->pll_enable) {\n\t\tu32 osc;\n\t\tint err;\n\n\t\t \n\t\tosc = FIELD_PREP(MCP251XFD_REG_OSC_CLKODIV_MASK,\n\t\t\t\t MCP251XFD_REG_OSC_CLKODIV_10);\n\t\terr = regmap_write(priv->map_reg, MCP251XFD_REG_OSC, osc);\n\t\tif (err)\n\t\t\tnetdev_err(priv->ndev,\n\t\t\t\t   \"Failed to disable PLL.\\n\");\n\n\t\tpriv->spi->max_speed_hz = priv->spi_max_speed_hz_slow;\n\t}\n\n\treturn mcp251xfd_chip_set_mode(priv, MCP251XFD_REG_CON_MODE_SLEEP);\n}\n\nstatic int mcp251xfd_chip_softreset_do(const struct mcp251xfd_priv *priv)\n{\n\tconst __be16 cmd = mcp251xfd_cmd_reset();\n\tint err;\n\n\t \n\terr = mcp251xfd_chip_wake(priv);\n\tif (err)\n\t\treturn err;\n\n\terr = mcp251xfd_chip_set_mode(priv, MCP251XFD_REG_CON_MODE_CONFIG);\n\tif (err)\n\t\treturn err;\n\n\t \n\treturn spi_write_then_read(priv->spi, &cmd, sizeof(cmd), NULL, 0);\n}\n\nstatic int mcp251xfd_chip_softreset_check(const struct mcp251xfd_priv *priv)\n{\n\tu32 osc_reference, osc_mask;\n\tu8 mode;\n\tint err;\n\n\t \n\tosc_reference = MCP251XFD_REG_OSC_OSCRDY |\n\t\tFIELD_PREP(MCP251XFD_REG_OSC_CLKODIV_MASK,\n\t\t\t   MCP251XFD_REG_OSC_CLKODIV_10);\n\tosc_mask = osc_reference | MCP251XFD_REG_OSC_PLLRDY;\n\terr = mcp251xfd_chip_wait_for_osc_ready(priv, osc_reference, osc_mask);\n\tif (err)\n\t\treturn err;\n\n\terr = mcp251xfd_chip_get_mode(priv, &mode);\n\tif (err)\n\t\treturn err;\n\n\tif (mode != MCP251XFD_REG_CON_MODE_CONFIG) {\n\t\tnetdev_info(priv->ndev,\n\t\t\t    \"Controller not in Config Mode after reset, but in %s Mode (%u).\\n\",\n\t\t\t    mcp251xfd_get_mode_str(mode), mode);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int mcp251xfd_chip_softreset(const struct mcp251xfd_priv *priv)\n{\n\tint err, i;\n\n\tfor (i = 0; i < MCP251XFD_SOFTRESET_RETRIES_MAX; i++) {\n\t\tif (i)\n\t\t\tnetdev_info(priv->ndev,\n\t\t\t\t    \"Retrying to reset controller.\\n\");\n\n\t\terr = mcp251xfd_chip_softreset_do(priv);\n\t\tif (err == -ETIMEDOUT)\n\t\t\tcontinue;\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mcp251xfd_chip_softreset_check(priv);\n\t\tif (err == -ETIMEDOUT)\n\t\t\tcontinue;\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn 0;\n\t}\n\n\treturn err;\n}\n\nstatic int mcp251xfd_chip_clock_init(const struct mcp251xfd_priv *priv)\n{\n\tu32 osc, osc_reference, osc_mask;\n\tint err;\n\n\t \n\tosc = MCP251XFD_REG_OSC_LPMEN |\n\t\tFIELD_PREP(MCP251XFD_REG_OSC_CLKODIV_MASK,\n\t\t\t   MCP251XFD_REG_OSC_CLKODIV_10);\n\tosc_reference = MCP251XFD_REG_OSC_OSCRDY;\n\tosc_mask = MCP251XFD_REG_OSC_OSCRDY | MCP251XFD_REG_OSC_PLLRDY;\n\n\tif (priv->pll_enable) {\n\t\tosc |= MCP251XFD_REG_OSC_PLLEN;\n\t\tosc_reference |= MCP251XFD_REG_OSC_PLLRDY;\n\t}\n\n\terr = regmap_write(priv->map_reg, MCP251XFD_REG_OSC, osc);\n\tif (err)\n\t\treturn err;\n\n\terr = mcp251xfd_chip_wait_for_osc_ready(priv, osc_reference, osc_mask);\n\tif (err)\n\t\treturn err;\n\n\tpriv->spi->max_speed_hz = priv->spi_max_speed_hz_fast;\n\n\treturn 0;\n}\n\nstatic int mcp251xfd_chip_timestamp_init(const struct mcp251xfd_priv *priv)\n{\n\t \n\treturn regmap_write(priv->map_reg, MCP251XFD_REG_TSCON,\n\t\t\t    MCP251XFD_REG_TSCON_TBCEN);\n}\n\nstatic int mcp251xfd_set_bittiming(const struct mcp251xfd_priv *priv)\n{\n\tconst struct can_bittiming *bt = &priv->can.bittiming;\n\tconst struct can_bittiming *dbt = &priv->can.data_bittiming;\n\tu32 val = 0;\n\ts8 tdco;\n\tint err;\n\n\t \n\tval = FIELD_PREP(MCP251XFD_REG_CON_REQOP_MASK,\n\t\t\t MCP251XFD_REG_CON_MODE_CONFIG) |\n\t\tMCP251XFD_REG_CON_STEF |\n\t\tMCP251XFD_REG_CON_ESIGM |\n\t\tMCP251XFD_REG_CON_RTXAT |\n\t\tFIELD_PREP(MCP251XFD_REG_CON_WFT_MASK,\n\t\t\t   MCP251XFD_REG_CON_WFT_T11FILTER) |\n\t\tMCP251XFD_REG_CON_WAKFIL |\n\t\tMCP251XFD_REG_CON_PXEDIS;\n\n\tif (!(priv->can.ctrlmode & CAN_CTRLMODE_FD_NON_ISO))\n\t\tval |= MCP251XFD_REG_CON_ISOCRCEN;\n\n\terr = regmap_write(priv->map_reg, MCP251XFD_REG_CON, val);\n\tif (err)\n\t\treturn err;\n\n\t \n\tval = FIELD_PREP(MCP251XFD_REG_NBTCFG_BRP_MASK, bt->brp - 1) |\n\t\tFIELD_PREP(MCP251XFD_REG_NBTCFG_TSEG1_MASK,\n\t\t\t   bt->prop_seg + bt->phase_seg1 - 1) |\n\t\tFIELD_PREP(MCP251XFD_REG_NBTCFG_TSEG2_MASK,\n\t\t\t   bt->phase_seg2 - 1) |\n\t\tFIELD_PREP(MCP251XFD_REG_NBTCFG_SJW_MASK, bt->sjw - 1);\n\n\terr = regmap_write(priv->map_reg, MCP251XFD_REG_NBTCFG, val);\n\tif (err)\n\t\treturn err;\n\n\tif (!(priv->can.ctrlmode & CAN_CTRLMODE_FD))\n\t\treturn 0;\n\n\t \n\tval = FIELD_PREP(MCP251XFD_REG_DBTCFG_BRP_MASK, dbt->brp - 1) |\n\t\tFIELD_PREP(MCP251XFD_REG_DBTCFG_TSEG1_MASK,\n\t\t\t   dbt->prop_seg + dbt->phase_seg1 - 1) |\n\t\tFIELD_PREP(MCP251XFD_REG_DBTCFG_TSEG2_MASK,\n\t\t\t   dbt->phase_seg2 - 1) |\n\t\tFIELD_PREP(MCP251XFD_REG_DBTCFG_SJW_MASK, dbt->sjw - 1);\n\n\terr = regmap_write(priv->map_reg, MCP251XFD_REG_DBTCFG, val);\n\tif (err)\n\t\treturn err;\n\n\t \n\ttdco = clamp_t(int, dbt->brp * (dbt->prop_seg + dbt->phase_seg1),\n\t\t       -64, 63);\n\tval = FIELD_PREP(MCP251XFD_REG_TDC_TDCMOD_MASK,\n\t\t\t MCP251XFD_REG_TDC_TDCMOD_AUTO) |\n\t\tFIELD_PREP(MCP251XFD_REG_TDC_TDCO_MASK, tdco);\n\n\treturn regmap_write(priv->map_reg, MCP251XFD_REG_TDC, val);\n}\n\nstatic int mcp251xfd_chip_rx_int_enable(const struct mcp251xfd_priv *priv)\n{\n\tu32 val;\n\n\tif (!priv->rx_int)\n\t\treturn 0;\n\n\t \n\tval = MCP251XFD_REG_IOCON_PM0 | MCP251XFD_REG_IOCON_TRIS1 |\n\t\tMCP251XFD_REG_IOCON_TRIS0;\n\treturn regmap_write(priv->map_reg, MCP251XFD_REG_IOCON, val);\n}\n\nstatic int mcp251xfd_chip_rx_int_disable(const struct mcp251xfd_priv *priv)\n{\n\tu32 val;\n\n\tif (!priv->rx_int)\n\t\treturn 0;\n\n\t \n\tval = MCP251XFD_REG_IOCON_PM1 | MCP251XFD_REG_IOCON_PM0 |\n\t\tMCP251XFD_REG_IOCON_TRIS1 | MCP251XFD_REG_IOCON_TRIS0;\n\treturn regmap_write(priv->map_reg, MCP251XFD_REG_IOCON, val);\n}\n\nstatic int mcp251xfd_chip_ecc_init(struct mcp251xfd_priv *priv)\n{\n\tstruct mcp251xfd_ecc *ecc = &priv->ecc;\n\tvoid *ram;\n\tu32 val = 0;\n\tint err;\n\n\tecc->ecc_stat = 0;\n\n\tif (priv->devtype_data.quirks & MCP251XFD_QUIRK_ECC)\n\t\tval = MCP251XFD_REG_ECCCON_ECCEN;\n\n\terr = regmap_update_bits(priv->map_reg, MCP251XFD_REG_ECCCON,\n\t\t\t\t MCP251XFD_REG_ECCCON_ECCEN, val);\n\tif (err)\n\t\treturn err;\n\n\tram = kzalloc(MCP251XFD_RAM_SIZE, GFP_KERNEL);\n\tif (!ram)\n\t\treturn -ENOMEM;\n\n\terr = regmap_raw_write(priv->map_reg, MCP251XFD_RAM_START, ram,\n\t\t\t       MCP251XFD_RAM_SIZE);\n\tkfree(ram);\n\n\treturn err;\n}\n\nstatic u8 mcp251xfd_get_normal_mode(const struct mcp251xfd_priv *priv)\n{\n\tu8 mode;\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\tmode = MCP251XFD_REG_CON_MODE_INT_LOOPBACK;\n\telse if (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tmode = MCP251XFD_REG_CON_MODE_LISTENONLY;\n\telse if (priv->can.ctrlmode & CAN_CTRLMODE_FD)\n\t\tmode = MCP251XFD_REG_CON_MODE_MIXED;\n\telse\n\t\tmode = MCP251XFD_REG_CON_MODE_CAN2_0;\n\n\treturn mode;\n}\n\nstatic int\n__mcp251xfd_chip_set_normal_mode(const struct mcp251xfd_priv *priv,\n\t\t\t\t bool nowait)\n{\n\tu8 mode;\n\n\tmode = mcp251xfd_get_normal_mode(priv);\n\n\treturn __mcp251xfd_chip_set_mode(priv, mode, nowait);\n}\n\nstatic inline int\nmcp251xfd_chip_set_normal_mode(const struct mcp251xfd_priv *priv)\n{\n\treturn __mcp251xfd_chip_set_normal_mode(priv, false);\n}\n\nstatic inline int\nmcp251xfd_chip_set_normal_mode_nowait(const struct mcp251xfd_priv *priv)\n{\n\treturn __mcp251xfd_chip_set_normal_mode(priv, true);\n}\n\nstatic int mcp251xfd_chip_interrupts_enable(const struct mcp251xfd_priv *priv)\n{\n\tu32 val;\n\tint err;\n\n\tval = MCP251XFD_REG_CRC_FERRIE | MCP251XFD_REG_CRC_CRCERRIE;\n\terr = regmap_write(priv->map_reg, MCP251XFD_REG_CRC, val);\n\tif (err)\n\t\treturn err;\n\n\tval = MCP251XFD_REG_ECCCON_DEDIE | MCP251XFD_REG_ECCCON_SECIE;\n\terr = regmap_update_bits(priv->map_reg, MCP251XFD_REG_ECCCON, val, val);\n\tif (err)\n\t\treturn err;\n\n\tval = MCP251XFD_REG_INT_CERRIE |\n\t\tMCP251XFD_REG_INT_SERRIE |\n\t\tMCP251XFD_REG_INT_RXOVIE |\n\t\tMCP251XFD_REG_INT_TXATIE |\n\t\tMCP251XFD_REG_INT_SPICRCIE |\n\t\tMCP251XFD_REG_INT_ECCIE |\n\t\tMCP251XFD_REG_INT_TEFIE |\n\t\tMCP251XFD_REG_INT_MODIE |\n\t\tMCP251XFD_REG_INT_RXIE;\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING)\n\t\tval |= MCP251XFD_REG_INT_IVMIE;\n\n\treturn regmap_write(priv->map_reg, MCP251XFD_REG_INT, val);\n}\n\nstatic int mcp251xfd_chip_interrupts_disable(const struct mcp251xfd_priv *priv)\n{\n\tint err;\n\tu32 mask;\n\n\terr = regmap_write(priv->map_reg, MCP251XFD_REG_INT, 0);\n\tif (err)\n\t\treturn err;\n\n\tmask = MCP251XFD_REG_ECCCON_DEDIE | MCP251XFD_REG_ECCCON_SECIE;\n\terr = regmap_update_bits(priv->map_reg, MCP251XFD_REG_ECCCON,\n\t\t\t\t mask, 0x0);\n\tif (err)\n\t\treturn err;\n\n\treturn regmap_write(priv->map_reg, MCP251XFD_REG_CRC, 0);\n}\n\nstatic void mcp251xfd_chip_stop(struct mcp251xfd_priv *priv,\n\t\t\t\tconst enum can_state state)\n{\n\tpriv->can.state = state;\n\n\tmcp251xfd_chip_interrupts_disable(priv);\n\tmcp251xfd_chip_rx_int_disable(priv);\n\tmcp251xfd_chip_sleep(priv);\n}\n\nstatic int mcp251xfd_chip_start(struct mcp251xfd_priv *priv)\n{\n\tint err;\n\n\terr = mcp251xfd_chip_softreset(priv);\n\tif (err)\n\t\tgoto out_chip_stop;\n\n\terr = mcp251xfd_chip_clock_init(priv);\n\tif (err)\n\t\tgoto out_chip_stop;\n\n\terr = mcp251xfd_chip_timestamp_init(priv);\n\tif (err)\n\t\tgoto out_chip_stop;\n\n\terr = mcp251xfd_set_bittiming(priv);\n\tif (err)\n\t\tgoto out_chip_stop;\n\n\terr = mcp251xfd_chip_rx_int_enable(priv);\n\tif (err)\n\t\tgoto out_chip_stop;\n\n\terr = mcp251xfd_chip_ecc_init(priv);\n\tif (err)\n\t\tgoto out_chip_stop;\n\n\terr = mcp251xfd_ring_init(priv);\n\tif (err)\n\t\tgoto out_chip_stop;\n\n\terr = mcp251xfd_chip_fifo_init(priv);\n\tif (err)\n\t\tgoto out_chip_stop;\n\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\terr = mcp251xfd_chip_set_normal_mode(priv);\n\tif (err)\n\t\tgoto out_chip_stop;\n\n\treturn 0;\n\n out_chip_stop:\n\tmcp251xfd_dump(priv);\n\tmcp251xfd_chip_stop(priv, CAN_STATE_STOPPED);\n\n\treturn err;\n}\n\nstatic int mcp251xfd_set_mode(struct net_device *ndev, enum can_mode mode)\n{\n\tstruct mcp251xfd_priv *priv = netdev_priv(ndev);\n\tint err;\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\terr = mcp251xfd_chip_start(priv);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mcp251xfd_chip_interrupts_enable(priv);\n\t\tif (err) {\n\t\t\tmcp251xfd_chip_stop(priv, CAN_STATE_STOPPED);\n\t\t\treturn err;\n\t\t}\n\n\t\tnetif_wake_queue(ndev);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int __mcp251xfd_get_berr_counter(const struct net_device *ndev,\n\t\t\t\t\tstruct can_berr_counter *bec)\n{\n\tconst struct mcp251xfd_priv *priv = netdev_priv(ndev);\n\tu32 trec;\n\tint err;\n\n\terr = regmap_read(priv->map_reg, MCP251XFD_REG_TREC, &trec);\n\tif (err)\n\t\treturn err;\n\n\tif (trec & MCP251XFD_REG_TREC_TXBO)\n\t\tbec->txerr = 256;\n\telse\n\t\tbec->txerr = FIELD_GET(MCP251XFD_REG_TREC_TEC_MASK, trec);\n\tbec->rxerr = FIELD_GET(MCP251XFD_REG_TREC_REC_MASK, trec);\n\n\treturn 0;\n}\n\nstatic int mcp251xfd_get_berr_counter(const struct net_device *ndev,\n\t\t\t\t      struct can_berr_counter *bec)\n{\n\tconst struct mcp251xfd_priv *priv = netdev_priv(ndev);\n\n\t \n\tif (!(ndev->flags & IFF_UP))\n\t\treturn 0;\n\n\t \n\tif (priv->can.state == CAN_STATE_BUS_OFF) {\n\t\t*bec = priv->bec;\n\t\treturn 0;\n\t}\n\n\treturn __mcp251xfd_get_berr_counter(ndev, bec);\n}\n\nstatic struct sk_buff *\nmcp251xfd_alloc_can_err_skb(struct mcp251xfd_priv *priv,\n\t\t\t    struct can_frame **cf, u32 *timestamp)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\terr = mcp251xfd_get_timestamp(priv, timestamp);\n\tif (err)\n\t\treturn NULL;\n\n\tskb = alloc_can_err_skb(priv->ndev, cf);\n\tif (skb)\n\t\tmcp251xfd_skb_set_timestamp(priv, skb, *timestamp);\n\n\treturn skb;\n}\n\nstatic int mcp251xfd_handle_rxovif(struct mcp251xfd_priv *priv)\n{\n\tstruct net_device_stats *stats = &priv->ndev->stats;\n\tstruct mcp251xfd_rx_ring *ring;\n\tstruct sk_buff *skb;\n\tstruct can_frame *cf;\n\tu32 timestamp, rxovif;\n\tint err, i;\n\n\tstats->rx_over_errors++;\n\tstats->rx_errors++;\n\n\terr = regmap_read(priv->map_reg, MCP251XFD_REG_RXOVIF, &rxovif);\n\tif (err)\n\t\treturn err;\n\n\tmcp251xfd_for_each_rx_ring(priv, ring, i) {\n\t\tif (!(rxovif & BIT(ring->fifo_nr)))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (priv->regs_status.intf & MCP251XFD_REG_INT_SERRIF) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tnetdev_dbg(priv->ndev,\n\t\t\t\t\t   \"RX-%d: MAB overflow detected.\\n\",\n\t\t\t\t\t   ring->nr);\n\t\t} else {\n\t\t\tif (net_ratelimit())\n\t\t\t\tnetdev_dbg(priv->ndev,\n\t\t\t\t\t   \"RX-%d: FIFO overflow.\\n\",\n\t\t\t\t\t   ring->nr);\n\t\t}\n\n\t\terr = regmap_update_bits(priv->map_reg,\n\t\t\t\t\t MCP251XFD_REG_FIFOSTA(ring->fifo_nr),\n\t\t\t\t\t MCP251XFD_REG_FIFOSTA_RXOVIF,\n\t\t\t\t\t 0x0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tskb = mcp251xfd_alloc_can_err_skb(priv, &cf, &timestamp);\n\tif (!skb)\n\t\treturn 0;\n\n\tcf->can_id |= CAN_ERR_CRTL;\n\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\n\terr = can_rx_offload_queue_timestamp(&priv->offload, skb, timestamp);\n\tif (err)\n\t\tstats->rx_fifo_errors++;\n\n\treturn 0;\n}\n\nstatic int mcp251xfd_handle_txatif(struct mcp251xfd_priv *priv)\n{\n\tnetdev_info(priv->ndev, \"%s\\n\", __func__);\n\n\treturn 0;\n}\n\nstatic int mcp251xfd_handle_ivmif(struct mcp251xfd_priv *priv)\n{\n\tstruct net_device_stats *stats = &priv->ndev->stats;\n\tu32 bdiag1, timestamp;\n\tstruct sk_buff *skb;\n\tstruct can_frame *cf = NULL;\n\tint err;\n\n\terr = mcp251xfd_get_timestamp(priv, &timestamp);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_read(priv->map_reg, MCP251XFD_REG_BDIAG1, &bdiag1);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = regmap_write(priv->map_reg, MCP251XFD_REG_BDIAG1, 0x0);\n\tif (err)\n\t\treturn err;\n\n\tpriv->can.can_stats.bus_error++;\n\n\tskb = alloc_can_err_skb(priv->ndev, &cf);\n\tif (cf)\n\t\tcf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\n\n\t \n\tif (WARN_ON(bdiag1 & MCP251XFD_REG_BDIAG1_DLCMM))\n\t\tnetdev_err(priv->ndev,\n\t\t\t   \"recv'd DLC is larger than PLSIZE of FIFO element.\");\n\n\t \n\tif (bdiag1 & (MCP251XFD_REG_BDIAG1_DCRCERR |\n\t\t      MCP251XFD_REG_BDIAG1_NCRCERR)) {\n\t\tnetdev_dbg(priv->ndev, \"CRC error\\n\");\n\n\t\tstats->rx_errors++;\n\t\tif (cf)\n\t\t\tcf->data[3] |= CAN_ERR_PROT_LOC_CRC_SEQ;\n\t}\n\tif (bdiag1 & (MCP251XFD_REG_BDIAG1_DSTUFERR |\n\t\t      MCP251XFD_REG_BDIAG1_NSTUFERR)) {\n\t\tnetdev_dbg(priv->ndev, \"Stuff error\\n\");\n\n\t\tstats->rx_errors++;\n\t\tif (cf)\n\t\t\tcf->data[2] |= CAN_ERR_PROT_STUFF;\n\t}\n\tif (bdiag1 & (MCP251XFD_REG_BDIAG1_DFORMERR |\n\t\t      MCP251XFD_REG_BDIAG1_NFORMERR)) {\n\t\tnetdev_dbg(priv->ndev, \"Format error\\n\");\n\n\t\tstats->rx_errors++;\n\t\tif (cf)\n\t\t\tcf->data[2] |= CAN_ERR_PROT_FORM;\n\t}\n\n\t \n\tif (bdiag1 & MCP251XFD_REG_BDIAG1_NACKERR) {\n\t\tnetdev_dbg(priv->ndev, \"NACK error\\n\");\n\n\t\tstats->tx_errors++;\n\t\tif (cf) {\n\t\t\tcf->can_id |= CAN_ERR_ACK;\n\t\t\tcf->data[2] |= CAN_ERR_PROT_TX;\n\t\t}\n\t}\n\tif (bdiag1 & (MCP251XFD_REG_BDIAG1_DBIT1ERR |\n\t\t      MCP251XFD_REG_BDIAG1_NBIT1ERR)) {\n\t\tnetdev_dbg(priv->ndev, \"Bit1 error\\n\");\n\n\t\tstats->tx_errors++;\n\t\tif (cf)\n\t\t\tcf->data[2] |= CAN_ERR_PROT_TX | CAN_ERR_PROT_BIT1;\n\t}\n\tif (bdiag1 & (MCP251XFD_REG_BDIAG1_DBIT0ERR |\n\t\t      MCP251XFD_REG_BDIAG1_NBIT0ERR)) {\n\t\tnetdev_dbg(priv->ndev, \"Bit0 error\\n\");\n\n\t\tstats->tx_errors++;\n\t\tif (cf)\n\t\t\tcf->data[2] |= CAN_ERR_PROT_TX | CAN_ERR_PROT_BIT0;\n\t}\n\n\tif (!cf)\n\t\treturn 0;\n\n\tmcp251xfd_skb_set_timestamp(priv, skb, timestamp);\n\terr = can_rx_offload_queue_timestamp(&priv->offload, skb, timestamp);\n\tif (err)\n\t\tstats->rx_fifo_errors++;\n\n\treturn 0;\n}\n\nstatic int mcp251xfd_handle_cerrif(struct mcp251xfd_priv *priv)\n{\n\tstruct net_device_stats *stats = &priv->ndev->stats;\n\tstruct sk_buff *skb;\n\tstruct can_frame *cf = NULL;\n\tenum can_state new_state, rx_state, tx_state;\n\tu32 trec, timestamp;\n\tint err;\n\n\terr = regmap_read(priv->map_reg, MCP251XFD_REG_TREC, &trec);\n\tif (err)\n\t\treturn err;\n\n\tif (trec & MCP251XFD_REG_TREC_TXBO)\n\t\ttx_state = CAN_STATE_BUS_OFF;\n\telse if (trec & MCP251XFD_REG_TREC_TXBP)\n\t\ttx_state = CAN_STATE_ERROR_PASSIVE;\n\telse if (trec & MCP251XFD_REG_TREC_TXWARN)\n\t\ttx_state = CAN_STATE_ERROR_WARNING;\n\telse\n\t\ttx_state = CAN_STATE_ERROR_ACTIVE;\n\n\tif (trec & MCP251XFD_REG_TREC_RXBP)\n\t\trx_state = CAN_STATE_ERROR_PASSIVE;\n\telse if (trec & MCP251XFD_REG_TREC_RXWARN)\n\t\trx_state = CAN_STATE_ERROR_WARNING;\n\telse\n\t\trx_state = CAN_STATE_ERROR_ACTIVE;\n\n\tnew_state = max(tx_state, rx_state);\n\tif (new_state == priv->can.state)\n\t\treturn 0;\n\n\t \n\tskb = mcp251xfd_alloc_can_err_skb(priv, &cf, &timestamp);\n\tcan_change_state(priv->ndev, cf, tx_state, rx_state);\n\n\tif (new_state == CAN_STATE_BUS_OFF) {\n\t\t \n\t\terr = __mcp251xfd_get_berr_counter(priv->ndev, &priv->bec);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tmcp251xfd_chip_stop(priv, CAN_STATE_BUS_OFF);\n\t\tcan_bus_off(priv->ndev);\n\t}\n\n\tif (!skb)\n\t\treturn 0;\n\n\tif (new_state != CAN_STATE_BUS_OFF) {\n\t\tstruct can_berr_counter bec;\n\n\t\terr = mcp251xfd_get_berr_counter(priv->ndev, &bec);\n\t\tif (err)\n\t\t\treturn err;\n\t\tcf->can_id |= CAN_ERR_CNT;\n\t\tcf->data[6] = bec.txerr;\n\t\tcf->data[7] = bec.rxerr;\n\t}\n\n\terr = can_rx_offload_queue_timestamp(&priv->offload, skb, timestamp);\n\tif (err)\n\t\tstats->rx_fifo_errors++;\n\n\treturn 0;\n}\n\nstatic int\nmcp251xfd_handle_modif(const struct mcp251xfd_priv *priv, bool *set_normal_mode)\n{\n\tconst u8 mode_reference = mcp251xfd_get_normal_mode(priv);\n\tu8 mode;\n\tint err;\n\n\terr = mcp251xfd_chip_get_mode(priv, &mode);\n\tif (err)\n\t\treturn err;\n\n\tif (mode == mode_reference) {\n\t\tnetdev_dbg(priv->ndev,\n\t\t\t   \"Controller changed into %s Mode (%u).\\n\",\n\t\t\t   mcp251xfd_get_mode_str(mode), mode);\n\t\treturn 0;\n\t}\n\n\t \n\tif ((priv->devtype_data.quirks & MCP251XFD_QUIRK_MAB_NO_WARN) &&\n\t    (mode == MCP251XFD_REG_CON_MODE_RESTRICTED ||\n\t     mode == MCP251XFD_REG_CON_MODE_LISTENONLY))\n\t\tnetdev_dbg(priv->ndev,\n\t\t\t   \"Controller changed into %s Mode (%u).\\n\",\n\t\t\t   mcp251xfd_get_mode_str(mode), mode);\n\telse\n\t\tnetdev_err(priv->ndev,\n\t\t\t   \"Controller changed into %s Mode (%u).\\n\",\n\t\t\t   mcp251xfd_get_mode_str(mode), mode);\n\n\t \n\tif (priv->regs_status.intf & MCP251XFD_REG_INT_ECCIF) {\n\t\t*set_normal_mode = true;\n\t\treturn 0;\n\t}\n\n\treturn mcp251xfd_chip_set_normal_mode_nowait(priv);\n}\n\nstatic int mcp251xfd_handle_serrif(struct mcp251xfd_priv *priv)\n{\n\tstruct mcp251xfd_ecc *ecc = &priv->ecc;\n\tstruct net_device_stats *stats = &priv->ndev->stats;\n\tbool handled = false;\n\n\t \n\tif ((priv->regs_status.intf & MCP251XFD_REG_INT_MODIF &&\n\t     priv->regs_status.intf & MCP251XFD_REG_INT_IVMIF) ||\n\t    priv->regs_status.intf & MCP251XFD_REG_INT_ECCIF ||\n\t    ecc->cnt) {\n\t\tconst char *msg;\n\n\t\tif (priv->regs_status.intf & MCP251XFD_REG_INT_ECCIF ||\n\t\t    ecc->cnt)\n\t\t\tmsg = \"TX MAB underflow due to ECC error detected.\";\n\t\telse\n\t\t\tmsg = \"TX MAB underflow detected.\";\n\n\t\tif (priv->devtype_data.quirks & MCP251XFD_QUIRK_MAB_NO_WARN)\n\t\t\tnetdev_dbg(priv->ndev, \"%s\\n\", msg);\n\t\telse\n\t\t\tnetdev_info(priv->ndev, \"%s\\n\", msg);\n\n\t\tstats->tx_aborted_errors++;\n\t\tstats->tx_errors++;\n\t\thandled = true;\n\t}\n\n\t \n\tif (priv->regs_status.intf & MCP251XFD_REG_INT_RXOVIF ||\n\t    priv->regs_status.intf & MCP251XFD_REG_INT_RXIF) {\n\t\tstats->rx_dropped++;\n\t\thandled = true;\n\t}\n\n\tif (!handled)\n\t\tnetdev_err(priv->ndev,\n\t\t\t   \"Unhandled System Error Interrupt (intf=0x%08x)!\\n\",\n\t\t\t   priv->regs_status.intf);\n\n\treturn 0;\n}\n\nstatic int\nmcp251xfd_handle_eccif_recover(struct mcp251xfd_priv *priv, u8 nr)\n{\n\tstruct mcp251xfd_tx_ring *tx_ring = priv->tx;\n\tstruct mcp251xfd_ecc *ecc = &priv->ecc;\n\tstruct mcp251xfd_tx_obj *tx_obj;\n\tu8 chip_tx_tail, tx_tail, offset;\n\tu16 addr;\n\tint err;\n\n\taddr = FIELD_GET(MCP251XFD_REG_ECCSTAT_ERRADDR_MASK, ecc->ecc_stat);\n\n\terr = mcp251xfd_tx_tail_get_from_chip(priv, &chip_tx_tail);\n\tif (err)\n\t\treturn err;\n\n\ttx_tail = mcp251xfd_get_tx_tail(tx_ring);\n\toffset = (nr - chip_tx_tail) & (tx_ring->obj_num - 1);\n\n\t \n\tif (chip_tx_tail != tx_tail ||\n\t    !(offset == 0 || (offset == 1 && (mcp251xfd_is_2518FD(priv) ||\n\t\t\t\t\t      mcp251xfd_is_251863(priv))))) {\n\t\tnetdev_err(priv->ndev,\n\t\t\t   \"ECC Error information inconsistent (addr=0x%04x, nr=%d, tx_tail=0x%08x(%d), chip_tx_tail=%d, offset=%d).\\n\",\n\t\t\t   addr, nr, tx_ring->tail, tx_tail, chip_tx_tail,\n\t\t\t   offset);\n\t\treturn -EINVAL;\n\t}\n\n\tnetdev_info(priv->ndev,\n\t\t    \"Recovering %s ECC Error at address 0x%04x (in TX-RAM, tx_obj=%d, tx_tail=0x%08x(%d), offset=%d).\\n\",\n\t\t    ecc->ecc_stat & MCP251XFD_REG_ECCSTAT_SECIF ?\n\t\t    \"Single\" : \"Double\",\n\t\t    addr, nr, tx_ring->tail, tx_tail, offset);\n\n\t \n\ttx_obj = &tx_ring->obj[nr];\n\terr = spi_sync_transfer(priv->spi, tx_obj->xfer, 1);\n\tif (err)\n\t\treturn err;\n\n\t \n\treturn mcp251xfd_chip_set_normal_mode(priv);\n}\n\nstatic int\nmcp251xfd_handle_eccif(struct mcp251xfd_priv *priv, bool set_normal_mode)\n{\n\tstruct mcp251xfd_ecc *ecc = &priv->ecc;\n\tconst char *msg;\n\tbool in_tx_ram;\n\tu32 ecc_stat;\n\tu16 addr;\n\tu8 nr;\n\tint err;\n\n\terr = regmap_read(priv->map_reg, MCP251XFD_REG_ECCSTAT, &ecc_stat);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_update_bits(priv->map_reg, MCP251XFD_REG_ECCSTAT,\n\t\t\t\t MCP251XFD_REG_ECCSTAT_IF_MASK, ~ecc_stat);\n\tif (err)\n\t\treturn err;\n\n\t \n\taddr = FIELD_GET(MCP251XFD_REG_ECCSTAT_ERRADDR_MASK, ecc_stat);\n\terr = mcp251xfd_get_tx_nr_by_addr(priv->tx, &nr, addr);\n\tif (!err)\n\t\tin_tx_ram = true;\n\telse if (err == -ENOENT)\n\t\tin_tx_ram = false;\n\telse\n\t\treturn err;\n\n\t \n\tif (ecc_stat & MCP251XFD_REG_ECCSTAT_SECIF)\n\t\tmsg = \"Single ECC Error detected at address\";\n\telse if (ecc_stat & MCP251XFD_REG_ECCSTAT_DEDIF)\n\t\tmsg = \"Double ECC Error detected at address\";\n\telse\n\t\treturn -EINVAL;\n\n\tif (!in_tx_ram) {\n\t\tecc->ecc_stat = 0;\n\n\t\tnetdev_notice(priv->ndev, \"%s 0x%04x.\\n\", msg, addr);\n\t} else {\n\t\t \n\t\tif (ecc->ecc_stat == ecc_stat) {\n\t\t\tecc->cnt++;\n\t\t} else {\n\t\t\tecc->ecc_stat = ecc_stat;\n\t\t\tecc->cnt = 1;\n\t\t}\n\n\t\tnetdev_info(priv->ndev,\n\t\t\t    \"%s 0x%04x (in TX-RAM, tx_obj=%d), occurred %d time%s.\\n\",\n\t\t\t    msg, addr, nr, ecc->cnt, ecc->cnt > 1 ? \"s\" : \"\");\n\n\t\tif (ecc->cnt >= MCP251XFD_ECC_CNT_MAX)\n\t\t\treturn mcp251xfd_handle_eccif_recover(priv, nr);\n\t}\n\n\tif (set_normal_mode)\n\t\treturn mcp251xfd_chip_set_normal_mode_nowait(priv);\n\n\treturn 0;\n}\n\nstatic int mcp251xfd_handle_spicrcif(struct mcp251xfd_priv *priv)\n{\n\tint err;\n\tu32 crc;\n\n\terr = regmap_read(priv->map_reg, MCP251XFD_REG_CRC, &crc);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_update_bits(priv->map_reg, MCP251XFD_REG_CRC,\n\t\t\t\t MCP251XFD_REG_CRC_IF_MASK,\n\t\t\t\t ~crc);\n\tif (err)\n\t\treturn err;\n\n\tif (crc & MCP251XFD_REG_CRC_FERRIF)\n\t\tnetdev_notice(priv->ndev, \"CRC write command format error.\\n\");\n\telse if (crc & MCP251XFD_REG_CRC_CRCERRIF)\n\t\tnetdev_notice(priv->ndev,\n\t\t\t      \"CRC write error detected. CRC=0x%04lx.\\n\",\n\t\t\t      FIELD_GET(MCP251XFD_REG_CRC_MASK, crc));\n\n\treturn 0;\n}\n\nstatic int mcp251xfd_read_regs_status(struct mcp251xfd_priv *priv)\n{\n\tconst int val_bytes = regmap_get_val_bytes(priv->map_reg);\n\tsize_t len;\n\n\tif (priv->rx_ring_num == 1)\n\t\tlen = sizeof(priv->regs_status.intf);\n\telse\n\t\tlen = sizeof(priv->regs_status);\n\n\treturn regmap_bulk_read(priv->map_reg, MCP251XFD_REG_INT,\n\t\t\t\t&priv->regs_status, len / val_bytes);\n}\n\n#define mcp251xfd_handle(priv, irq, ...) \\\n({ \\\n\tstruct mcp251xfd_priv *_priv = (priv); \\\n\tint err; \\\n\\\n\terr = mcp251xfd_handle_##irq(_priv, ## __VA_ARGS__); \\\n\tif (err) \\\n\t\tnetdev_err(_priv->ndev, \\\n\t\t\t\"IRQ handler mcp251xfd_handle_%s() returned %d.\\n\", \\\n\t\t\t__stringify(irq), err); \\\n\terr; \\\n})\n\nstatic irqreturn_t mcp251xfd_irq(int irq, void *dev_id)\n{\n\tstruct mcp251xfd_priv *priv = dev_id;\n\tirqreturn_t handled = IRQ_NONE;\n\tint err;\n\n\tif (priv->rx_int)\n\t\tdo {\n\t\t\tint rx_pending;\n\n\t\t\trx_pending = gpiod_get_value_cansleep(priv->rx_int);\n\t\t\tif (!rx_pending)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tpriv->regs_status.rxif = BIT(priv->rx[0]->fifo_nr);\n\t\t\terr = mcp251xfd_handle(priv, rxif);\n\t\t\tif (err)\n\t\t\t\tgoto out_fail;\n\n\t\t\thandled = IRQ_HANDLED;\n\n\t\t\t \n\t\t} while (priv->rx_ring_num == 1);\n\n\tdo {\n\t\tu32 intf_pending, intf_pending_clearable;\n\t\tbool set_normal_mode = false;\n\n\t\terr = mcp251xfd_read_regs_status(priv);\n\t\tif (err)\n\t\t\tgoto out_fail;\n\n\t\tintf_pending = FIELD_GET(MCP251XFD_REG_INT_IF_MASK,\n\t\t\t\t\t priv->regs_status.intf) &\n\t\t\tFIELD_GET(MCP251XFD_REG_INT_IE_MASK,\n\t\t\t\t  priv->regs_status.intf);\n\n\t\tif (!(intf_pending)) {\n\t\t\tcan_rx_offload_threaded_irq_finish(&priv->offload);\n\t\t\treturn handled;\n\t\t}\n\n\t\t \n\t\tintf_pending_clearable = intf_pending &\n\t\t\tMCP251XFD_REG_INT_IF_CLEARABLE_MASK;\n\t\tif (intf_pending_clearable) {\n\t\t\terr = regmap_update_bits(priv->map_reg,\n\t\t\t\t\t\t MCP251XFD_REG_INT,\n\t\t\t\t\t\t MCP251XFD_REG_INT_IF_MASK,\n\t\t\t\t\t\t ~intf_pending_clearable);\n\t\t\tif (err)\n\t\t\t\tgoto out_fail;\n\t\t}\n\n\t\tif (intf_pending & MCP251XFD_REG_INT_MODIF) {\n\t\t\terr = mcp251xfd_handle(priv, modif, &set_normal_mode);\n\t\t\tif (err)\n\t\t\t\tgoto out_fail;\n\t\t}\n\n\t\tif (intf_pending & MCP251XFD_REG_INT_RXIF) {\n\t\t\terr = mcp251xfd_handle(priv, rxif);\n\t\t\tif (err)\n\t\t\t\tgoto out_fail;\n\t\t}\n\n\t\tif (intf_pending & MCP251XFD_REG_INT_TEFIF) {\n\t\t\terr = mcp251xfd_handle(priv, tefif);\n\t\t\tif (err)\n\t\t\t\tgoto out_fail;\n\t\t}\n\n\t\tif (intf_pending & MCP251XFD_REG_INT_RXOVIF) {\n\t\t\terr = mcp251xfd_handle(priv, rxovif);\n\t\t\tif (err)\n\t\t\t\tgoto out_fail;\n\t\t}\n\n\t\tif (intf_pending & MCP251XFD_REG_INT_TXATIF) {\n\t\t\terr = mcp251xfd_handle(priv, txatif);\n\t\t\tif (err)\n\t\t\t\tgoto out_fail;\n\t\t}\n\n\t\tif (intf_pending & MCP251XFD_REG_INT_IVMIF) {\n\t\t\terr = mcp251xfd_handle(priv, ivmif);\n\t\t\tif (err)\n\t\t\t\tgoto out_fail;\n\t\t}\n\n\t\tif (intf_pending & MCP251XFD_REG_INT_SERRIF) {\n\t\t\terr = mcp251xfd_handle(priv, serrif);\n\t\t\tif (err)\n\t\t\t\tgoto out_fail;\n\t\t}\n\n\t\tif (intf_pending & MCP251XFD_REG_INT_ECCIF) {\n\t\t\terr = mcp251xfd_handle(priv, eccif, set_normal_mode);\n\t\t\tif (err)\n\t\t\t\tgoto out_fail;\n\t\t}\n\n\t\tif (intf_pending & MCP251XFD_REG_INT_SPICRCIF) {\n\t\t\terr = mcp251xfd_handle(priv, spicrcif);\n\t\t\tif (err)\n\t\t\t\tgoto out_fail;\n\t\t}\n\n\t\t \n\t\tif (intf_pending & MCP251XFD_REG_INT_CERRIF ||\n\t\t    priv->can.state > CAN_STATE_ERROR_ACTIVE) {\n\t\t\terr = mcp251xfd_handle(priv, cerrif);\n\t\t\tif (err)\n\t\t\t\tgoto out_fail;\n\n\t\t\t \n\t\t\tif (priv->can.state == CAN_STATE_BUS_OFF) {\n\t\t\t\tcan_rx_offload_threaded_irq_finish(&priv->offload);\n\t\t\t\treturn IRQ_HANDLED;\n\t\t\t}\n\t\t}\n\n\t\thandled = IRQ_HANDLED;\n\t} while (1);\n\n out_fail:\n\tcan_rx_offload_threaded_irq_finish(&priv->offload);\n\n\tnetdev_err(priv->ndev, \"IRQ handler returned %d (intf=0x%08x).\\n\",\n\t\t   err, priv->regs_status.intf);\n\tmcp251xfd_dump(priv);\n\tmcp251xfd_chip_interrupts_disable(priv);\n\tmcp251xfd_timestamp_stop(priv);\n\n\treturn handled;\n}\n\nstatic int mcp251xfd_open(struct net_device *ndev)\n{\n\tstruct mcp251xfd_priv *priv = netdev_priv(ndev);\n\tconst struct spi_device *spi = priv->spi;\n\tint err;\n\n\terr = open_candev(ndev);\n\tif (err)\n\t\treturn err;\n\n\terr = pm_runtime_resume_and_get(ndev->dev.parent);\n\tif (err)\n\t\tgoto out_close_candev;\n\n\terr = mcp251xfd_ring_alloc(priv);\n\tif (err)\n\t\tgoto out_pm_runtime_put;\n\n\terr = mcp251xfd_transceiver_enable(priv);\n\tif (err)\n\t\tgoto out_mcp251xfd_ring_free;\n\n\terr = mcp251xfd_chip_start(priv);\n\tif (err)\n\t\tgoto out_transceiver_disable;\n\n\tmcp251xfd_timestamp_init(priv);\n\tclear_bit(MCP251XFD_FLAGS_DOWN, priv->flags);\n\tcan_rx_offload_enable(&priv->offload);\n\n\terr = request_threaded_irq(spi->irq, NULL, mcp251xfd_irq,\n\t\t\t\t   IRQF_SHARED | IRQF_ONESHOT,\n\t\t\t\t   dev_name(&spi->dev), priv);\n\tif (err)\n\t\tgoto out_can_rx_offload_disable;\n\n\terr = mcp251xfd_chip_interrupts_enable(priv);\n\tif (err)\n\t\tgoto out_free_irq;\n\n\tnetif_start_queue(ndev);\n\n\treturn 0;\n\n out_free_irq:\n\tfree_irq(spi->irq, priv);\n out_can_rx_offload_disable:\n\tcan_rx_offload_disable(&priv->offload);\n\tset_bit(MCP251XFD_FLAGS_DOWN, priv->flags);\n\tmcp251xfd_timestamp_stop(priv);\n out_transceiver_disable:\n\tmcp251xfd_transceiver_disable(priv);\n out_mcp251xfd_ring_free:\n\tmcp251xfd_ring_free(priv);\n out_pm_runtime_put:\n\tmcp251xfd_chip_stop(priv, CAN_STATE_STOPPED);\n\tpm_runtime_put(ndev->dev.parent);\n out_close_candev:\n\tclose_candev(ndev);\n\n\treturn err;\n}\n\nstatic int mcp251xfd_stop(struct net_device *ndev)\n{\n\tstruct mcp251xfd_priv *priv = netdev_priv(ndev);\n\n\tnetif_stop_queue(ndev);\n\tset_bit(MCP251XFD_FLAGS_DOWN, priv->flags);\n\thrtimer_cancel(&priv->rx_irq_timer);\n\thrtimer_cancel(&priv->tx_irq_timer);\n\tmcp251xfd_chip_interrupts_disable(priv);\n\tfree_irq(ndev->irq, priv);\n\tcan_rx_offload_disable(&priv->offload);\n\tmcp251xfd_timestamp_stop(priv);\n\tmcp251xfd_chip_stop(priv, CAN_STATE_STOPPED);\n\tmcp251xfd_transceiver_disable(priv);\n\tmcp251xfd_ring_free(priv);\n\tclose_candev(ndev);\n\n\tpm_runtime_put(ndev->dev.parent);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops mcp251xfd_netdev_ops = {\n\t.ndo_open = mcp251xfd_open,\n\t.ndo_stop = mcp251xfd_stop,\n\t.ndo_start_xmit\t= mcp251xfd_start_xmit,\n\t.ndo_eth_ioctl = can_eth_ioctl_hwts,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic void\nmcp251xfd_register_quirks(struct mcp251xfd_priv *priv)\n{\n\tconst struct spi_device *spi = priv->spi;\n\tconst struct spi_controller *ctlr = spi->controller;\n\n\tif (ctlr->flags & SPI_CONTROLLER_HALF_DUPLEX)\n\t\tpriv->devtype_data.quirks |= MCP251XFD_QUIRK_HALF_DUPLEX;\n}\n\nstatic int mcp251xfd_register_chip_detect(struct mcp251xfd_priv *priv)\n{\n\tconst struct net_device *ndev = priv->ndev;\n\tconst struct mcp251xfd_devtype_data *devtype_data;\n\tu32 osc;\n\tint err;\n\n\t \n\terr = regmap_update_bits(priv->map_reg, MCP251XFD_REG_OSC,\n\t\t\t\t MCP251XFD_REG_OSC_LPMEN,\n\t\t\t\t MCP251XFD_REG_OSC_LPMEN);\n\tif (err)\n\t\treturn err;\n\n\terr = regmap_read(priv->map_reg, MCP251XFD_REG_OSC, &osc);\n\tif (err)\n\t\treturn err;\n\n\tif (osc & MCP251XFD_REG_OSC_LPMEN) {\n\t\t \n\t\tif (mcp251xfd_is_251863(priv))\n\t\t\tdevtype_data = &mcp251xfd_devtype_data_mcp251863;\n\t\telse\n\t\t\tdevtype_data = &mcp251xfd_devtype_data_mcp2518fd;\n\t} else {\n\t\tdevtype_data = &mcp251xfd_devtype_data_mcp2517fd;\n\t}\n\n\tif (!mcp251xfd_is_251XFD(priv) &&\n\t    priv->devtype_data.model != devtype_data->model) {\n\t\tnetdev_info(ndev,\n\t\t\t    \"Detected %s, but firmware specifies a %s. Fixing up.\\n\",\n\t\t\t    __mcp251xfd_get_model_str(devtype_data->model),\n\t\t\t    mcp251xfd_get_model_str(priv));\n\t}\n\tpriv->devtype_data = *devtype_data;\n\n\t \n\tmcp251xfd_register_quirks(priv);\n\n\t \n\treturn mcp251xfd_regmap_init(priv);\n}\n\nstatic int mcp251xfd_register_check_rx_int(struct mcp251xfd_priv *priv)\n{\n\tint err, rx_pending;\n\n\tif (!priv->rx_int)\n\t\treturn 0;\n\n\terr = mcp251xfd_chip_rx_int_enable(priv);\n\tif (err)\n\t\treturn err;\n\n\t \n\trx_pending = gpiod_get_value_cansleep(priv->rx_int);\n\n\terr = mcp251xfd_chip_rx_int_disable(priv);\n\tif (err)\n\t\treturn err;\n\n\tif (!rx_pending)\n\t\treturn 0;\n\n\tnetdev_info(priv->ndev,\n\t\t    \"RX_INT active after softreset, disabling RX_INT support.\\n\");\n\tdevm_gpiod_put(&priv->spi->dev, priv->rx_int);\n\tpriv->rx_int = NULL;\n\n\treturn 0;\n}\n\nstatic int\nmcp251xfd_register_get_dev_id(const struct mcp251xfd_priv *priv, u32 *dev_id,\n\t\t\t      u32 *effective_speed_hz_slow,\n\t\t\t      u32 *effective_speed_hz_fast)\n{\n\tstruct mcp251xfd_map_buf_nocrc *buf_rx;\n\tstruct mcp251xfd_map_buf_nocrc *buf_tx;\n\tstruct spi_transfer xfer[2] = { };\n\tint err;\n\n\tbuf_rx = kzalloc(sizeof(*buf_rx), GFP_KERNEL);\n\tif (!buf_rx)\n\t\treturn -ENOMEM;\n\n\tbuf_tx = kzalloc(sizeof(*buf_tx), GFP_KERNEL);\n\tif (!buf_tx) {\n\t\terr = -ENOMEM;\n\t\tgoto out_kfree_buf_rx;\n\t}\n\n\txfer[0].tx_buf = buf_tx;\n\txfer[0].len = sizeof(buf_tx->cmd);\n\txfer[0].speed_hz = priv->spi_max_speed_hz_slow;\n\txfer[1].rx_buf = buf_rx->data;\n\txfer[1].len = sizeof(*dev_id);\n\txfer[1].speed_hz = priv->spi_max_speed_hz_fast;\n\n\tmcp251xfd_spi_cmd_read_nocrc(&buf_tx->cmd, MCP251XFD_REG_DEVID);\n\n\terr = spi_sync_transfer(priv->spi, xfer, ARRAY_SIZE(xfer));\n\tif (err)\n\t\tgoto out_kfree_buf_tx;\n\n\t*dev_id = get_unaligned_le32(buf_rx->data);\n\t*effective_speed_hz_slow = xfer[0].effective_speed_hz;\n\t*effective_speed_hz_fast = xfer[1].effective_speed_hz;\n\n out_kfree_buf_tx:\n\tkfree(buf_tx);\n out_kfree_buf_rx:\n\tkfree(buf_rx);\n\n\treturn err;\n}\n\n#define MCP251XFD_QUIRK_ACTIVE(quirk) \\\n\t(priv->devtype_data.quirks & MCP251XFD_QUIRK_##quirk ? '+' : '-')\n\nstatic int\nmcp251xfd_register_done(const struct mcp251xfd_priv *priv)\n{\n\tu32 dev_id, effective_speed_hz_slow, effective_speed_hz_fast;\n\tunsigned long clk_rate;\n\tint err;\n\n\terr = mcp251xfd_register_get_dev_id(priv, &dev_id,\n\t\t\t\t\t    &effective_speed_hz_slow,\n\t\t\t\t\t    &effective_speed_hz_fast);\n\tif (err)\n\t\treturn err;\n\n\tclk_rate = clk_get_rate(priv->clk);\n\n\tnetdev_info(priv->ndev,\n\t\t    \"%s rev%lu.%lu (%cRX_INT %cPLL %cMAB_NO_WARN %cCRC_REG %cCRC_RX %cCRC_TX %cECC %cHD o:%lu.%02luMHz c:%u.%02uMHz m:%u.%02uMHz rs:%u.%02uMHz es:%u.%02uMHz rf:%u.%02uMHz ef:%u.%02uMHz) successfully initialized.\\n\",\n\t\t    mcp251xfd_get_model_str(priv),\n\t\t    FIELD_GET(MCP251XFD_REG_DEVID_ID_MASK, dev_id),\n\t\t    FIELD_GET(MCP251XFD_REG_DEVID_REV_MASK, dev_id),\n\t\t    priv->rx_int ? '+' : '-',\n\t\t    priv->pll_enable ? '+' : '-',\n\t\t    MCP251XFD_QUIRK_ACTIVE(MAB_NO_WARN),\n\t\t    MCP251XFD_QUIRK_ACTIVE(CRC_REG),\n\t\t    MCP251XFD_QUIRK_ACTIVE(CRC_RX),\n\t\t    MCP251XFD_QUIRK_ACTIVE(CRC_TX),\n\t\t    MCP251XFD_QUIRK_ACTIVE(ECC),\n\t\t    MCP251XFD_QUIRK_ACTIVE(HALF_DUPLEX),\n\t\t    clk_rate / 1000000,\n\t\t    clk_rate % 1000000 / 1000 / 10,\n\t\t    priv->can.clock.freq / 1000000,\n\t\t    priv->can.clock.freq % 1000000 / 1000 / 10,\n\t\t    priv->spi_max_speed_hz_orig / 1000000,\n\t\t    priv->spi_max_speed_hz_orig % 1000000 / 1000 / 10,\n\t\t    priv->spi_max_speed_hz_slow / 1000000,\n\t\t    priv->spi_max_speed_hz_slow % 1000000 / 1000 / 10,\n\t\t    effective_speed_hz_slow / 1000000,\n\t\t    effective_speed_hz_slow % 1000000 / 1000 / 10,\n\t\t    priv->spi_max_speed_hz_fast / 1000000,\n\t\t    priv->spi_max_speed_hz_fast % 1000000 / 1000 / 10,\n\t\t    effective_speed_hz_fast / 1000000,\n\t\t    effective_speed_hz_fast % 1000000 / 1000 / 10);\n\n\treturn 0;\n}\n\nstatic int mcp251xfd_register(struct mcp251xfd_priv *priv)\n{\n\tstruct net_device *ndev = priv->ndev;\n\tint err;\n\n\terr = mcp251xfd_clks_and_vdd_enable(priv);\n\tif (err)\n\t\treturn err;\n\n\tpm_runtime_get_noresume(ndev->dev.parent);\n\terr = pm_runtime_set_active(ndev->dev.parent);\n\tif (err)\n\t\tgoto out_runtime_put_noidle;\n\tpm_runtime_enable(ndev->dev.parent);\n\n\tmcp251xfd_register_quirks(priv);\n\n\terr = mcp251xfd_chip_softreset(priv);\n\tif (err == -ENODEV)\n\t\tgoto out_runtime_disable;\n\tif (err)\n\t\tgoto out_chip_sleep;\n\n\terr = mcp251xfd_chip_clock_init(priv);\n\tif (err == -ENODEV)\n\t\tgoto out_runtime_disable;\n\tif (err)\n\t\tgoto out_chip_sleep;\n\n\terr = mcp251xfd_register_chip_detect(priv);\n\tif (err)\n\t\tgoto out_chip_sleep;\n\n\terr = mcp251xfd_register_check_rx_int(priv);\n\tif (err)\n\t\tgoto out_chip_sleep;\n\n\tmcp251xfd_ethtool_init(priv);\n\n\terr = register_candev(ndev);\n\tif (err)\n\t\tgoto out_chip_sleep;\n\n\terr = mcp251xfd_register_done(priv);\n\tif (err)\n\t\tgoto out_unregister_candev;\n\n\t \n\terr = mcp251xfd_chip_sleep(priv);\n\tif (err)\n\t\tgoto out_unregister_candev;\n\n\tpm_runtime_put(ndev->dev.parent);\n\n\treturn 0;\n\n out_unregister_candev:\n\tunregister_candev(ndev);\n out_chip_sleep:\n\tmcp251xfd_chip_sleep(priv);\n out_runtime_disable:\n\tpm_runtime_disable(ndev->dev.parent);\n out_runtime_put_noidle:\n\tpm_runtime_put_noidle(ndev->dev.parent);\n\tmcp251xfd_clks_and_vdd_disable(priv);\n\n\treturn err;\n}\n\nstatic inline void mcp251xfd_unregister(struct mcp251xfd_priv *priv)\n{\n\tstruct net_device *ndev\t= priv->ndev;\n\n\tunregister_candev(ndev);\n\n\tif (pm_runtime_enabled(ndev->dev.parent))\n\t\tpm_runtime_disable(ndev->dev.parent);\n\telse\n\t\tmcp251xfd_clks_and_vdd_disable(priv);\n}\n\nstatic const struct of_device_id mcp251xfd_of_match[] = {\n\t{\n\t\t.compatible = \"microchip,mcp2517fd\",\n\t\t.data = &mcp251xfd_devtype_data_mcp2517fd,\n\t}, {\n\t\t.compatible = \"microchip,mcp2518fd\",\n\t\t.data = &mcp251xfd_devtype_data_mcp2518fd,\n\t}, {\n\t\t.compatible = \"microchip,mcp251863\",\n\t\t.data = &mcp251xfd_devtype_data_mcp251863,\n\t}, {\n\t\t.compatible = \"microchip,mcp251xfd\",\n\t\t.data = &mcp251xfd_devtype_data_mcp251xfd,\n\t}, {\n\t\t \n\t},\n};\nMODULE_DEVICE_TABLE(of, mcp251xfd_of_match);\n\nstatic const struct spi_device_id mcp251xfd_id_table[] = {\n\t{\n\t\t.name = \"mcp2517fd\",\n\t\t.driver_data = (kernel_ulong_t)&mcp251xfd_devtype_data_mcp2517fd,\n\t}, {\n\t\t.name = \"mcp2518fd\",\n\t\t.driver_data = (kernel_ulong_t)&mcp251xfd_devtype_data_mcp2518fd,\n\t}, {\n\t\t.name = \"mcp251863\",\n\t\t.driver_data = (kernel_ulong_t)&mcp251xfd_devtype_data_mcp251863,\n\t}, {\n\t\t.name = \"mcp251xfd\",\n\t\t.driver_data = (kernel_ulong_t)&mcp251xfd_devtype_data_mcp251xfd,\n\t}, {\n\t\t \n\t},\n};\nMODULE_DEVICE_TABLE(spi, mcp251xfd_id_table);\n\nstatic int mcp251xfd_probe(struct spi_device *spi)\n{\n\tconst void *match;\n\tstruct net_device *ndev;\n\tstruct mcp251xfd_priv *priv;\n\tstruct gpio_desc *rx_int;\n\tstruct regulator *reg_vdd, *reg_xceiver;\n\tstruct clk *clk;\n\tbool pll_enable = false;\n\tu32 freq = 0;\n\tint err;\n\n\tif (!spi->irq)\n\t\treturn dev_err_probe(&spi->dev, -ENXIO,\n\t\t\t\t     \"No IRQ specified (maybe node \\\"interrupts-extended\\\" in DT missing)!\\n\");\n\n\trx_int = devm_gpiod_get_optional(&spi->dev, \"microchip,rx-int\",\n\t\t\t\t\t GPIOD_IN);\n\tif (IS_ERR(rx_int))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(rx_int),\n\t\t\t\t     \"Failed to get RX-INT!\\n\");\n\n\treg_vdd = devm_regulator_get_optional(&spi->dev, \"vdd\");\n\tif (PTR_ERR(reg_vdd) == -ENODEV)\n\t\treg_vdd = NULL;\n\telse if (IS_ERR(reg_vdd))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(reg_vdd),\n\t\t\t\t     \"Failed to get VDD regulator!\\n\");\n\n\treg_xceiver = devm_regulator_get_optional(&spi->dev, \"xceiver\");\n\tif (PTR_ERR(reg_xceiver) == -ENODEV)\n\t\treg_xceiver = NULL;\n\telse if (IS_ERR(reg_xceiver))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(reg_xceiver),\n\t\t\t\t     \"Failed to get Transceiver regulator!\\n\");\n\n\tclk = devm_clk_get_optional(&spi->dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(clk),\n\t\t\t\t     \"Failed to get Oscillator (clock)!\\n\");\n\tif (clk) {\n\t\tfreq = clk_get_rate(clk);\n\t} else {\n\t\terr = device_property_read_u32(&spi->dev, \"clock-frequency\",\n\t\t\t\t\t       &freq);\n\t\tif (err)\n\t\t\treturn dev_err_probe(&spi->dev, err,\n\t\t\t\t\t     \"Failed to get clock-frequency!\\n\");\n\t}\n\n\t \n\tif (freq < MCP251XFD_SYSCLOCK_HZ_MIN ||\n\t    freq > MCP251XFD_SYSCLOCK_HZ_MAX) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"Oscillator frequency (%u Hz) is too low or high.\\n\",\n\t\t\tfreq);\n\t\treturn -ERANGE;\n\t}\n\n\tif (freq <= MCP251XFD_SYSCLOCK_HZ_MAX / MCP251XFD_OSC_PLL_MULTIPLIER)\n\t\tpll_enable = true;\n\n\tndev = alloc_candev(sizeof(struct mcp251xfd_priv),\n\t\t\t    MCP251XFD_TX_OBJ_NUM_MAX);\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tSET_NETDEV_DEV(ndev, &spi->dev);\n\n\tndev->netdev_ops = &mcp251xfd_netdev_ops;\n\tndev->irq = spi->irq;\n\tndev->flags |= IFF_ECHO;\n\n\tpriv = netdev_priv(ndev);\n\tspi_set_drvdata(spi, priv);\n\tpriv->can.clock.freq = freq;\n\tif (pll_enable)\n\t\tpriv->can.clock.freq *= MCP251XFD_OSC_PLL_MULTIPLIER;\n\tpriv->can.do_set_mode = mcp251xfd_set_mode;\n\tpriv->can.do_get_berr_counter = mcp251xfd_get_berr_counter;\n\tpriv->can.bittiming_const = &mcp251xfd_bittiming_const;\n\tpriv->can.data_bittiming_const = &mcp251xfd_data_bittiming_const;\n\tpriv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |\n\t\tCAN_CTRLMODE_LISTENONLY | CAN_CTRLMODE_BERR_REPORTING |\n\t\tCAN_CTRLMODE_FD | CAN_CTRLMODE_FD_NON_ISO |\n\t\tCAN_CTRLMODE_CC_LEN8_DLC;\n\tset_bit(MCP251XFD_FLAGS_DOWN, priv->flags);\n\tpriv->ndev = ndev;\n\tpriv->spi = spi;\n\tpriv->rx_int = rx_int;\n\tpriv->clk = clk;\n\tpriv->pll_enable = pll_enable;\n\tpriv->reg_vdd = reg_vdd;\n\tpriv->reg_xceiver = reg_xceiver;\n\n\tmatch = device_get_match_data(&spi->dev);\n\tif (match)\n\t\tpriv->devtype_data = *(struct mcp251xfd_devtype_data *)match;\n\telse\n\t\tpriv->devtype_data = *(struct mcp251xfd_devtype_data *)\n\t\t\tspi_get_device_id(spi)->driver_data;\n\n\t \n\tpriv->spi_max_speed_hz_orig = spi->max_speed_hz;\n\tpriv->spi_max_speed_hz_slow = min(spi->max_speed_hz,\n\t\t\t\t\t  freq / 2 / 1000 * 850);\n\tif (priv->pll_enable)\n\t\tpriv->spi_max_speed_hz_fast = min(spi->max_speed_hz,\n\t\t\t\t\t\t  freq *\n\t\t\t\t\t\t  MCP251XFD_OSC_PLL_MULTIPLIER /\n\t\t\t\t\t\t  2 / 1000 * 850);\n\telse\n\t\tpriv->spi_max_speed_hz_fast = priv->spi_max_speed_hz_slow;\n\tspi->max_speed_hz = priv->spi_max_speed_hz_slow;\n\tspi->bits_per_word = 8;\n\tspi->rt = true;\n\terr = spi_setup(spi);\n\tif (err)\n\t\tgoto out_free_candev;\n\n\terr = mcp251xfd_regmap_init(priv);\n\tif (err)\n\t\tgoto out_free_candev;\n\n\terr = can_rx_offload_add_manual(ndev, &priv->offload,\n\t\t\t\t\tMCP251XFD_NAPI_WEIGHT);\n\tif (err)\n\t\tgoto out_free_candev;\n\n\terr = mcp251xfd_register(priv);\n\tif (err) {\n\t\tdev_err_probe(&spi->dev, err, \"Failed to detect %s.\\n\",\n\t\t\t      mcp251xfd_get_model_str(priv));\n\t\tgoto out_can_rx_offload_del;\n\t}\n\n\treturn 0;\n\n out_can_rx_offload_del:\n\tcan_rx_offload_del(&priv->offload);\n out_free_candev:\n\tspi->max_speed_hz = priv->spi_max_speed_hz_orig;\n\n\tfree_candev(ndev);\n\n\treturn err;\n}\n\nstatic void mcp251xfd_remove(struct spi_device *spi)\n{\n\tstruct mcp251xfd_priv *priv = spi_get_drvdata(spi);\n\tstruct net_device *ndev = priv->ndev;\n\n\tcan_rx_offload_del(&priv->offload);\n\tmcp251xfd_unregister(priv);\n\tspi->max_speed_hz = priv->spi_max_speed_hz_orig;\n\tfree_candev(ndev);\n}\n\nstatic int __maybe_unused mcp251xfd_runtime_suspend(struct device *device)\n{\n\tconst struct mcp251xfd_priv *priv = dev_get_drvdata(device);\n\n\treturn mcp251xfd_clks_and_vdd_disable(priv);\n}\n\nstatic int __maybe_unused mcp251xfd_runtime_resume(struct device *device)\n{\n\tconst struct mcp251xfd_priv *priv = dev_get_drvdata(device);\n\n\treturn mcp251xfd_clks_and_vdd_enable(priv);\n}\n\nstatic const struct dev_pm_ops mcp251xfd_pm_ops = {\n\tSET_RUNTIME_PM_OPS(mcp251xfd_runtime_suspend,\n\t\t\t   mcp251xfd_runtime_resume, NULL)\n};\n\nstatic struct spi_driver mcp251xfd_driver = {\n\t.driver = {\n\t\t.name = DEVICE_NAME,\n\t\t.pm = &mcp251xfd_pm_ops,\n\t\t.of_match_table = mcp251xfd_of_match,\n\t},\n\t.probe = mcp251xfd_probe,\n\t.remove = mcp251xfd_remove,\n\t.id_table = mcp251xfd_id_table,\n};\nmodule_spi_driver(mcp251xfd_driver);\n\nMODULE_AUTHOR(\"Marc Kleine-Budde <mkl@pengutronix.de>\");\nMODULE_DESCRIPTION(\"Microchip MCP251xFD Family CAN controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}