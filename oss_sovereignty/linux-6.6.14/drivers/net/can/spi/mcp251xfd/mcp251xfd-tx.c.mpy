{
  "module_name": "mcp251xfd-tx.c",
  "hash_id": "09dbd770b145749c510206fdbf2e65df41e7115d05deec85087feb871cb8226f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/spi/mcp251xfd/mcp251xfd-tx.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <asm/unaligned.h>\n#include <linux/bitfield.h>\n\n#include \"mcp251xfd.h\"\n\nstatic inline struct\nmcp251xfd_tx_obj *mcp251xfd_get_tx_obj_next(struct mcp251xfd_tx_ring *tx_ring)\n{\n\tu8 tx_head;\n\n\ttx_head = mcp251xfd_get_tx_head(tx_ring);\n\n\treturn &tx_ring->obj[tx_head];\n}\n\nstatic void\nmcp251xfd_tx_obj_from_skb(const struct mcp251xfd_priv *priv,\n\t\t\t  struct mcp251xfd_tx_obj *tx_obj,\n\t\t\t  const struct sk_buff *skb,\n\t\t\t  unsigned int seq)\n{\n\tconst struct canfd_frame *cfd = (struct canfd_frame *)skb->data;\n\tstruct mcp251xfd_hw_tx_obj_raw *hw_tx_obj;\n\tunion mcp251xfd_tx_obj_load_buf *load_buf;\n\tu8 dlc;\n\tu32 id, flags;\n\tint len_sanitized = 0, len;\n\n\tif (cfd->can_id & CAN_EFF_FLAG) {\n\t\tu32 sid, eid;\n\n\t\tsid = FIELD_GET(MCP251XFD_REG_FRAME_EFF_SID_MASK, cfd->can_id);\n\t\teid = FIELD_GET(MCP251XFD_REG_FRAME_EFF_EID_MASK, cfd->can_id);\n\n\t\tid = FIELD_PREP(MCP251XFD_OBJ_ID_EID_MASK, eid) |\n\t\t\tFIELD_PREP(MCP251XFD_OBJ_ID_SID_MASK, sid);\n\n\t\tflags = MCP251XFD_OBJ_FLAGS_IDE;\n\t} else {\n\t\tid = FIELD_PREP(MCP251XFD_OBJ_ID_SID_MASK, cfd->can_id);\n\t\tflags = 0;\n\t}\n\n\t \n\tflags |= FIELD_PREP(MCP251XFD_OBJ_FLAGS_SEQ_MCP2518FD_MASK, seq);\n\n\tif (cfd->can_id & CAN_RTR_FLAG)\n\t\tflags |= MCP251XFD_OBJ_FLAGS_RTR;\n\telse\n\t\tlen_sanitized = canfd_sanitize_len(cfd->len);\n\n\t \n\tif (can_is_canfd_skb(skb)) {\n\t\tif (cfd->flags & CANFD_ESI)\n\t\t\tflags |= MCP251XFD_OBJ_FLAGS_ESI;\n\n\t\tflags |= MCP251XFD_OBJ_FLAGS_FDF;\n\n\t\tif (cfd->flags & CANFD_BRS)\n\t\t\tflags |= MCP251XFD_OBJ_FLAGS_BRS;\n\n\t\tdlc = can_fd_len2dlc(cfd->len);\n\t} else {\n\t\tdlc = can_get_cc_dlc((struct can_frame *)cfd,\n\t\t\t\t     priv->can.ctrlmode);\n\t}\n\n\tflags |= FIELD_PREP(MCP251XFD_OBJ_FLAGS_DLC_MASK, dlc);\n\n\tload_buf = &tx_obj->buf;\n\tif (priv->devtype_data.quirks & MCP251XFD_QUIRK_CRC_TX)\n\t\thw_tx_obj = &load_buf->crc.hw_tx_obj;\n\telse\n\t\thw_tx_obj = &load_buf->nocrc.hw_tx_obj;\n\n\tput_unaligned_le32(id, &hw_tx_obj->id);\n\tput_unaligned_le32(flags, &hw_tx_obj->flags);\n\n\t \n\tmemcpy(hw_tx_obj->data, cfd->data, cfd->len);\n\n\t \n\tif (MCP251XFD_SANITIZE_CAN && len_sanitized) {\n\t\tint pad_len;\n\n\t\tpad_len = len_sanitized - cfd->len;\n\t\tif (pad_len)\n\t\t\tmemset(hw_tx_obj->data + cfd->len, 0x0, pad_len);\n\t}\n\n\t \n\tlen = sizeof(hw_tx_obj->id) + sizeof(hw_tx_obj->flags);\n\tif (MCP251XFD_SANITIZE_CAN)\n\t\tlen += round_up(len_sanitized, sizeof(u32));\n\telse\n\t\tlen += round_up(cfd->len, sizeof(u32));\n\n\tif (priv->devtype_data.quirks & MCP251XFD_QUIRK_CRC_TX) {\n\t\tu16 crc;\n\n\t\tmcp251xfd_spi_cmd_crc_set_len_in_ram(&load_buf->crc.cmd,\n\t\t\t\t\t\t     len);\n\t\t \n\t\tlen += sizeof(load_buf->crc.cmd);\n\t\tcrc = mcp251xfd_crc16_compute(&load_buf->crc, len);\n\t\tput_unaligned_be16(crc, (void *)load_buf + len);\n\n\t\t \n\t\tlen += sizeof(load_buf->crc.crc);\n\t} else {\n\t\tlen += sizeof(load_buf->nocrc.cmd);\n\t}\n\n\ttx_obj->xfer[0].len = len;\n}\n\nstatic int mcp251xfd_tx_obj_write(const struct mcp251xfd_priv *priv,\n\t\t\t\t  struct mcp251xfd_tx_obj *tx_obj)\n{\n\treturn spi_async(priv->spi, &tx_obj->msg);\n}\n\nstatic bool mcp251xfd_tx_busy(const struct mcp251xfd_priv *priv,\n\t\t\t      struct mcp251xfd_tx_ring *tx_ring)\n{\n\tif (mcp251xfd_get_tx_free(tx_ring) > 0)\n\t\treturn false;\n\n\tnetif_stop_queue(priv->ndev);\n\n\t \n\tsmp_mb();\n\n\tif (mcp251xfd_get_tx_free(tx_ring) == 0) {\n\t\tnetdev_dbg(priv->ndev,\n\t\t\t   \"Stopping tx-queue (tx_head=0x%08x, tx_tail=0x%08x, len=%d).\\n\",\n\t\t\t   tx_ring->head, tx_ring->tail,\n\t\t\t   tx_ring->head - tx_ring->tail);\n\n\t\treturn true;\n\t}\n\n\tnetif_start_queue(priv->ndev);\n\n\treturn false;\n}\n\nnetdev_tx_t mcp251xfd_start_xmit(struct sk_buff *skb,\n\t\t\t\t struct net_device *ndev)\n{\n\tstruct mcp251xfd_priv *priv = netdev_priv(ndev);\n\tstruct mcp251xfd_tx_ring *tx_ring = priv->tx;\n\tstruct mcp251xfd_tx_obj *tx_obj;\n\tunsigned int frame_len;\n\tu8 tx_head;\n\tint err;\n\n\tif (can_dev_dropped_skb(ndev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tif (mcp251xfd_tx_busy(priv, tx_ring))\n\t\treturn NETDEV_TX_BUSY;\n\n\ttx_obj = mcp251xfd_get_tx_obj_next(tx_ring);\n\tmcp251xfd_tx_obj_from_skb(priv, tx_obj, skb, tx_ring->head);\n\n\t \n\ttx_head = mcp251xfd_get_tx_head(tx_ring);\n\ttx_ring->head++;\n\tif (mcp251xfd_get_tx_free(tx_ring) == 0)\n\t\tnetif_stop_queue(ndev);\n\n\tframe_len = can_skb_get_frame_len(skb);\n\terr = can_put_echo_skb(skb, ndev, tx_head, frame_len);\n\tif (!err)\n\t\tnetdev_sent_queue(priv->ndev, frame_len);\n\n\terr = mcp251xfd_tx_obj_write(priv, tx_obj);\n\tif (err)\n\t\tgoto out_err;\n\n\treturn NETDEV_TX_OK;\n\n out_err:\n\tnetdev_err(priv->ndev, \"ERROR in %s: %d\\n\", __func__, err);\n\n\treturn NETDEV_TX_OK;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}