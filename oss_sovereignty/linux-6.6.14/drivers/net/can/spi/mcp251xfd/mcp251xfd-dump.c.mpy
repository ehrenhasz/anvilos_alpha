{
  "module_name": "mcp251xfd-dump.c",
  "hash_id": "105d03d2e3b767cdc0ec0ac69ebce2699e6a434b47d50e07b4587bb492b410bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/spi/mcp251xfd/mcp251xfd-dump.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#include <linux/devcoredump.h>\n\n#include \"mcp251xfd.h\"\n#include \"mcp251xfd-dump.h\"\n\nstruct mcp251xfd_dump_iter {\n\tvoid *start;\n\tstruct mcp251xfd_dump_object_header *hdr;\n\tvoid *data;\n};\n\nstruct mcp251xfd_dump_reg_space {\n\tu16 base;\n\tu16 size;\n};\n\nstruct mcp251xfd_dump_ring {\n\tenum mcp251xfd_dump_object_ring_key key;\n\tu32 val;\n};\n\nstatic const struct mcp251xfd_dump_reg_space mcp251xfd_dump_reg_space[] = {\n\t{\n\t\t.base = MCP251XFD_REG_CON,\n\t\t.size = MCP251XFD_REG_FLTOBJ(32) - MCP251XFD_REG_CON,\n\t}, {\n\t\t.base = MCP251XFD_RAM_START,\n\t\t.size = MCP251XFD_RAM_SIZE,\n\t}, {\n\t\t.base = MCP251XFD_REG_OSC,\n\t\t.size = MCP251XFD_REG_DEVID - MCP251XFD_REG_OSC,\n\t},\n};\n\nstatic void mcp251xfd_dump_header(struct mcp251xfd_dump_iter *iter,\n\t\t\t\t  enum mcp251xfd_dump_object_type object_type,\n\t\t\t\t  const void *data_end)\n{\n\tstruct mcp251xfd_dump_object_header *hdr = iter->hdr;\n\tunsigned int len;\n\n\tlen = data_end - iter->data;\n\tif (!len)\n\t\treturn;\n\n\thdr->magic = cpu_to_le32(MCP251XFD_DUMP_MAGIC);\n\thdr->type = cpu_to_le32(object_type);\n\thdr->offset = cpu_to_le32(iter->data - iter->start);\n\thdr->len = cpu_to_le32(len);\n\n\titer->hdr++;\n\titer->data += len;\n}\n\nstatic void mcp251xfd_dump_registers(const struct mcp251xfd_priv *priv,\n\t\t\t\t     struct mcp251xfd_dump_iter *iter)\n{\n\tconst int val_bytes = regmap_get_val_bytes(priv->map_rx);\n\tstruct mcp251xfd_dump_object_reg *reg = iter->data;\n\tunsigned int i, j;\n\tint err;\n\n\tfor (i = 0; i < ARRAY_SIZE(mcp251xfd_dump_reg_space); i++) {\n\t\tconst struct mcp251xfd_dump_reg_space *reg_space;\n\t\tvoid *buf;\n\n\t\treg_space = &mcp251xfd_dump_reg_space[i];\n\n\t\tbuf = kmalloc(reg_space->size, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\tgoto out;\n\n\t\terr = regmap_bulk_read(priv->map_reg, reg_space->base,\n\t\t\t\t       buf, reg_space->size / val_bytes);\n\t\tif (err) {\n\t\t\tkfree(buf);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < reg_space->size; j += sizeof(u32), reg++) {\n\t\t\treg->reg = cpu_to_le32(reg_space->base + j);\n\t\t\treg->val = cpu_to_le32p(buf + j);\n\t\t}\n\n\t\tkfree(buf);\n\t}\n\n out:\n\tmcp251xfd_dump_header(iter, MCP251XFD_DUMP_OBJECT_TYPE_REG, reg);\n}\n\nstatic void mcp251xfd_dump_ring(struct mcp251xfd_dump_iter *iter,\n\t\t\t\tenum mcp251xfd_dump_object_type object_type,\n\t\t\t\tconst struct mcp251xfd_dump_ring *dump_ring,\n\t\t\t\tunsigned int len)\n{\n\tstruct mcp251xfd_dump_object_reg *reg = iter->data;\n\tunsigned int i;\n\n\tfor (i = 0; i < len; i++, reg++) {\n\t\treg->reg = cpu_to_le32(dump_ring[i].key);\n\t\treg->val = cpu_to_le32(dump_ring[i].val);\n\t}\n\n\tmcp251xfd_dump_header(iter, object_type, reg);\n}\n\nstatic void mcp251xfd_dump_tef_ring(const struct mcp251xfd_priv *priv,\n\t\t\t\t    struct mcp251xfd_dump_iter *iter)\n{\n\tconst struct mcp251xfd_tef_ring *tef = priv->tef;\n\tconst struct mcp251xfd_tx_ring *tx = priv->tx;\n\tconst struct mcp251xfd_dump_ring dump_ring[] = {\n\t\t{\n\t\t\t.key = MCP251XFD_DUMP_OBJECT_RING_KEY_HEAD,\n\t\t\t.val = tef->head,\n\t\t}, {\n\t\t\t.key = MCP251XFD_DUMP_OBJECT_RING_KEY_TAIL,\n\t\t\t.val = tef->tail,\n\t\t}, {\n\t\t\t.key = MCP251XFD_DUMP_OBJECT_RING_KEY_BASE,\n\t\t\t.val = 0,\n\t\t}, {\n\t\t\t.key = MCP251XFD_DUMP_OBJECT_RING_KEY_NR,\n\t\t\t.val = 0,\n\t\t}, {\n\t\t\t.key = MCP251XFD_DUMP_OBJECT_RING_KEY_FIFO_NR,\n\t\t\t.val = 0,\n\t\t}, {\n\t\t\t.key = MCP251XFD_DUMP_OBJECT_RING_KEY_OBJ_NUM,\n\t\t\t.val = tx->obj_num,\n\t\t}, {\n\t\t\t.key = MCP251XFD_DUMP_OBJECT_RING_KEY_OBJ_SIZE,\n\t\t\t.val = sizeof(struct mcp251xfd_hw_tef_obj),\n\t\t},\n\t};\n\n\tmcp251xfd_dump_ring(iter, MCP251XFD_DUMP_OBJECT_TYPE_TEF,\n\t\t\t    dump_ring, ARRAY_SIZE(dump_ring));\n}\n\nstatic void mcp251xfd_dump_rx_ring_one(const struct mcp251xfd_priv *priv,\n\t\t\t\t       struct mcp251xfd_dump_iter *iter,\n\t\t\t\t       const struct mcp251xfd_rx_ring *rx)\n{\n\tconst struct mcp251xfd_dump_ring dump_ring[] = {\n\t\t{\n\t\t\t.key = MCP251XFD_DUMP_OBJECT_RING_KEY_HEAD,\n\t\t\t.val = rx->head,\n\t\t}, {\n\t\t\t.key = MCP251XFD_DUMP_OBJECT_RING_KEY_TAIL,\n\t\t\t.val = rx->tail,\n\t\t}, {\n\t\t\t.key = MCP251XFD_DUMP_OBJECT_RING_KEY_BASE,\n\t\t\t.val = rx->base,\n\t\t}, {\n\t\t\t.key = MCP251XFD_DUMP_OBJECT_RING_KEY_NR,\n\t\t\t.val = rx->nr,\n\t\t}, {\n\t\t\t.key = MCP251XFD_DUMP_OBJECT_RING_KEY_FIFO_NR,\n\t\t\t.val = rx->fifo_nr,\n\t\t}, {\n\t\t\t.key = MCP251XFD_DUMP_OBJECT_RING_KEY_OBJ_NUM,\n\t\t\t.val = rx->obj_num,\n\t\t}, {\n\t\t\t.key = MCP251XFD_DUMP_OBJECT_RING_KEY_OBJ_SIZE,\n\t\t\t.val = rx->obj_size,\n\t\t},\n\t};\n\n\tmcp251xfd_dump_ring(iter, MCP251XFD_DUMP_OBJECT_TYPE_RX,\n\t\t\t    dump_ring, ARRAY_SIZE(dump_ring));\n}\n\nstatic void mcp251xfd_dump_rx_ring(const struct mcp251xfd_priv *priv,\n\t\t\t\t   struct mcp251xfd_dump_iter *iter)\n{\n\tstruct mcp251xfd_rx_ring *rx_ring;\n\tunsigned int i;\n\n\tmcp251xfd_for_each_rx_ring(priv, rx_ring, i)\n\t\tmcp251xfd_dump_rx_ring_one(priv, iter, rx_ring);\n}\n\nstatic void mcp251xfd_dump_tx_ring(const struct mcp251xfd_priv *priv,\n\t\t\t\t   struct mcp251xfd_dump_iter *iter)\n{\n\tconst struct mcp251xfd_tx_ring *tx = priv->tx;\n\tconst struct mcp251xfd_dump_ring dump_ring[] = {\n\t\t{\n\t\t\t.key = MCP251XFD_DUMP_OBJECT_RING_KEY_HEAD,\n\t\t\t.val = tx->head,\n\t\t}, {\n\t\t\t.key = MCP251XFD_DUMP_OBJECT_RING_KEY_TAIL,\n\t\t\t.val = tx->tail,\n\t\t}, {\n\t\t\t.key = MCP251XFD_DUMP_OBJECT_RING_KEY_BASE,\n\t\t\t.val = tx->base,\n\t\t}, {\n\t\t\t.key = MCP251XFD_DUMP_OBJECT_RING_KEY_NR,\n\t\t\t.val = tx->nr,\n\t\t}, {\n\t\t\t.key = MCP251XFD_DUMP_OBJECT_RING_KEY_FIFO_NR,\n\t\t\t.val = tx->fifo_nr,\n\t\t}, {\n\t\t\t.key = MCP251XFD_DUMP_OBJECT_RING_KEY_OBJ_NUM,\n\t\t\t.val = tx->obj_num,\n\t\t}, {\n\t\t\t.key = MCP251XFD_DUMP_OBJECT_RING_KEY_OBJ_SIZE,\n\t\t\t.val = tx->obj_size,\n\t\t},\n\t};\n\n\tmcp251xfd_dump_ring(iter, MCP251XFD_DUMP_OBJECT_TYPE_TX,\n\t\t\t    dump_ring, ARRAY_SIZE(dump_ring));\n}\n\nstatic void mcp251xfd_dump_end(const struct mcp251xfd_priv *priv,\n\t\t\t       struct mcp251xfd_dump_iter *iter)\n{\n\tstruct mcp251xfd_dump_object_header *hdr = iter->hdr;\n\n\thdr->magic = cpu_to_le32(MCP251XFD_DUMP_MAGIC);\n\thdr->type = cpu_to_le32(MCP251XFD_DUMP_OBJECT_TYPE_END);\n\thdr->offset = cpu_to_le32(0);\n\thdr->len = cpu_to_le32(0);\n\n\t \n\titer->hdr = NULL;\n}\n\nvoid mcp251xfd_dump(const struct mcp251xfd_priv *priv)\n{\n\tstruct mcp251xfd_dump_iter iter;\n\tunsigned int rings_num, obj_num;\n\tunsigned int file_size = 0;\n\tunsigned int i;\n\n\t \n\tobj_num = 2;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(mcp251xfd_dump_reg_space); i++)\n\t\tfile_size += mcp251xfd_dump_reg_space[i].size / sizeof(u32) *\n\t\t\tsizeof(struct mcp251xfd_dump_object_reg);\n\n\t \n\trings_num = 1 + priv->rx_ring_num + 1;\n\tobj_num += rings_num;\n\tfile_size += rings_num * __MCP251XFD_DUMP_OBJECT_RING_KEY_MAX  *\n\t\tsizeof(struct mcp251xfd_dump_object_reg);\n\n\t \n\tfile_size += sizeof(*iter.hdr) * obj_num;\n\n\t \n\titer.start = __vmalloc(file_size, GFP_KERNEL | __GFP_NOWARN |\n\t\t\t       __GFP_ZERO | __GFP_NORETRY);\n\tif (!iter.start) {\n\t\tnetdev_warn(priv->ndev, \"Failed to allocate devcoredump file.\\n\");\n\t\treturn;\n\t}\n\n\t \n\titer.hdr = iter.start;\n\titer.data = &iter.hdr[obj_num];\n\n\tmcp251xfd_dump_registers(priv, &iter);\n\tmcp251xfd_dump_tef_ring(priv, &iter);\n\tmcp251xfd_dump_rx_ring(priv, &iter);\n\tmcp251xfd_dump_tx_ring(priv, &iter);\n\tmcp251xfd_dump_end(priv, &iter);\n\n\tdev_coredumpv(&priv->spi->dev, iter.start,\n\t\t      iter.data - iter.start, GFP_KERNEL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}