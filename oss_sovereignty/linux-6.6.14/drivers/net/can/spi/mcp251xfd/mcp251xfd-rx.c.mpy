{
  "module_name": "mcp251xfd-rx.c",
  "hash_id": "d26f28cb30a359727329aeac1442ee5354d9c6dc85539beceb28d3fc36e10028",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/spi/mcp251xfd/mcp251xfd-rx.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/bitfield.h>\n\n#include \"mcp251xfd.h\"\n\nstatic inline int\nmcp251xfd_rx_head_get_from_chip(const struct mcp251xfd_priv *priv,\n\t\t\t\tconst struct mcp251xfd_rx_ring *ring,\n\t\t\t\tu8 *rx_head, bool *fifo_empty)\n{\n\tu32 fifo_sta;\n\tint err;\n\n\terr = regmap_read(priv->map_reg, MCP251XFD_REG_FIFOSTA(ring->fifo_nr),\n\t\t\t  &fifo_sta);\n\tif (err)\n\t\treturn err;\n\n\t*rx_head = FIELD_GET(MCP251XFD_REG_FIFOSTA_FIFOCI_MASK, fifo_sta);\n\t*fifo_empty = !(fifo_sta & MCP251XFD_REG_FIFOSTA_TFNRFNIF);\n\n\treturn 0;\n}\n\nstatic inline int\nmcp251xfd_rx_tail_get_from_chip(const struct mcp251xfd_priv *priv,\n\t\t\t\tconst struct mcp251xfd_rx_ring *ring,\n\t\t\t\tu8 *rx_tail)\n{\n\tu32 fifo_ua;\n\tint err;\n\n\terr = regmap_read(priv->map_reg, MCP251XFD_REG_FIFOUA(ring->fifo_nr),\n\t\t\t  &fifo_ua);\n\tif (err)\n\t\treturn err;\n\n\tfifo_ua -= ring->base - MCP251XFD_RAM_START;\n\t*rx_tail = fifo_ua / ring->obj_size;\n\n\treturn 0;\n}\n\nstatic int\nmcp251xfd_check_rx_tail(const struct mcp251xfd_priv *priv,\n\t\t\tconst struct mcp251xfd_rx_ring *ring)\n{\n\tu8 rx_tail_chip, rx_tail;\n\tint err;\n\n\tif (!IS_ENABLED(CONFIG_CAN_MCP251XFD_SANITY))\n\t\treturn 0;\n\n\terr = mcp251xfd_rx_tail_get_from_chip(priv, ring, &rx_tail_chip);\n\tif (err)\n\t\treturn err;\n\n\trx_tail = mcp251xfd_get_rx_tail(ring);\n\tif (rx_tail_chip != rx_tail) {\n\t\tnetdev_err(priv->ndev,\n\t\t\t   \"RX tail of chip (%d) and ours (%d) inconsistent.\\n\",\n\t\t\t   rx_tail_chip, rx_tail);\n\t\treturn -EILSEQ;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmcp251xfd_rx_ring_update(const struct mcp251xfd_priv *priv,\n\t\t\t struct mcp251xfd_rx_ring *ring)\n{\n\tu32 new_head;\n\tu8 chip_rx_head;\n\tbool fifo_empty;\n\tint err;\n\n\terr = mcp251xfd_rx_head_get_from_chip(priv, ring, &chip_rx_head,\n\t\t\t\t\t      &fifo_empty);\n\tif (err || fifo_empty)\n\t\treturn err;\n\n\t \n\tnew_head = round_down(ring->head, ring->obj_num) + chip_rx_head;\n\tif (new_head <= ring->head)\n\t\tnew_head += ring->obj_num;\n\n\tring->head = new_head;\n\n\treturn mcp251xfd_check_rx_tail(priv, ring);\n}\n\nstatic void\nmcp251xfd_hw_rx_obj_to_skb(const struct mcp251xfd_priv *priv,\n\t\t\t   const struct mcp251xfd_hw_rx_obj_canfd *hw_rx_obj,\n\t\t\t   struct sk_buff *skb)\n{\n\tstruct canfd_frame *cfd = (struct canfd_frame *)skb->data;\n\tu8 dlc;\n\n\tif (hw_rx_obj->flags & MCP251XFD_OBJ_FLAGS_IDE) {\n\t\tu32 sid, eid;\n\n\t\teid = FIELD_GET(MCP251XFD_OBJ_ID_EID_MASK, hw_rx_obj->id);\n\t\tsid = FIELD_GET(MCP251XFD_OBJ_ID_SID_MASK, hw_rx_obj->id);\n\n\t\tcfd->can_id = CAN_EFF_FLAG |\n\t\t\tFIELD_PREP(MCP251XFD_REG_FRAME_EFF_EID_MASK, eid) |\n\t\t\tFIELD_PREP(MCP251XFD_REG_FRAME_EFF_SID_MASK, sid);\n\t} else {\n\t\tcfd->can_id = FIELD_GET(MCP251XFD_OBJ_ID_SID_MASK,\n\t\t\t\t\thw_rx_obj->id);\n\t}\n\n\tdlc = FIELD_GET(MCP251XFD_OBJ_FLAGS_DLC_MASK, hw_rx_obj->flags);\n\n\t \n\tif (hw_rx_obj->flags & MCP251XFD_OBJ_FLAGS_FDF) {\n\t\tif (hw_rx_obj->flags & MCP251XFD_OBJ_FLAGS_ESI)\n\t\t\tcfd->flags |= CANFD_ESI;\n\n\t\tif (hw_rx_obj->flags & MCP251XFD_OBJ_FLAGS_BRS)\n\t\t\tcfd->flags |= CANFD_BRS;\n\n\t\tcfd->len = can_fd_dlc2len(dlc);\n\t} else {\n\t\tif (hw_rx_obj->flags & MCP251XFD_OBJ_FLAGS_RTR)\n\t\t\tcfd->can_id |= CAN_RTR_FLAG;\n\n\t\tcan_frame_set_cc_len((struct can_frame *)cfd, dlc,\n\t\t\t\t     priv->can.ctrlmode);\n\t}\n\n\tif (!(hw_rx_obj->flags & MCP251XFD_OBJ_FLAGS_RTR))\n\t\tmemcpy(cfd->data, hw_rx_obj->data, cfd->len);\n\n\tmcp251xfd_skb_set_timestamp(priv, skb, hw_rx_obj->ts);\n}\n\nstatic int\nmcp251xfd_handle_rxif_one(struct mcp251xfd_priv *priv,\n\t\t\t  struct mcp251xfd_rx_ring *ring,\n\t\t\t  const struct mcp251xfd_hw_rx_obj_canfd *hw_rx_obj)\n{\n\tstruct net_device_stats *stats = &priv->ndev->stats;\n\tstruct sk_buff *skb;\n\tstruct canfd_frame *cfd;\n\tint err;\n\n\tif (hw_rx_obj->flags & MCP251XFD_OBJ_FLAGS_FDF)\n\t\tskb = alloc_canfd_skb(priv->ndev, &cfd);\n\telse\n\t\tskb = alloc_can_skb(priv->ndev, (struct can_frame **)&cfd);\n\n\tif (!skb) {\n\t\tstats->rx_dropped++;\n\t\treturn 0;\n\t}\n\n\tmcp251xfd_hw_rx_obj_to_skb(priv, hw_rx_obj, skb);\n\terr = can_rx_offload_queue_timestamp(&priv->offload, skb, hw_rx_obj->ts);\n\tif (err)\n\t\tstats->rx_fifo_errors++;\n\n\treturn 0;\n}\n\nstatic inline int\nmcp251xfd_rx_obj_read(const struct mcp251xfd_priv *priv,\n\t\t      const struct mcp251xfd_rx_ring *ring,\n\t\t      struct mcp251xfd_hw_rx_obj_canfd *hw_rx_obj,\n\t\t      const u8 offset, const u8 len)\n{\n\tconst int val_bytes = regmap_get_val_bytes(priv->map_rx);\n\tint err;\n\n\terr = regmap_bulk_read(priv->map_rx,\n\t\t\t       mcp251xfd_get_rx_obj_addr(ring, offset),\n\t\t\t       hw_rx_obj,\n\t\t\t       len * ring->obj_size / val_bytes);\n\n\treturn err;\n}\n\nstatic int\nmcp251xfd_handle_rxif_ring(struct mcp251xfd_priv *priv,\n\t\t\t   struct mcp251xfd_rx_ring *ring)\n{\n\tstruct mcp251xfd_hw_rx_obj_canfd *hw_rx_obj = ring->obj;\n\tu8 rx_tail, len;\n\tint err, i;\n\n\terr = mcp251xfd_rx_ring_update(priv, ring);\n\tif (err)\n\t\treturn err;\n\n\twhile ((len = mcp251xfd_get_rx_linear_len(ring))) {\n\t\tint offset;\n\n\t\trx_tail = mcp251xfd_get_rx_tail(ring);\n\n\t\terr = mcp251xfd_rx_obj_read(priv, ring, hw_rx_obj,\n\t\t\t\t\t    rx_tail, len);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\terr = mcp251xfd_handle_rxif_one(priv, ring,\n\t\t\t\t\t\t\t(void *)hw_rx_obj +\n\t\t\t\t\t\t\ti * ring->obj_size);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\toffset = ARRAY_SIZE(ring->uinc_xfer) - len;\n\t\terr = spi_sync_transfer(priv->spi,\n\t\t\t\t\tring->uinc_xfer + offset, len);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tring->tail += len;\n\t}\n\n\treturn 0;\n}\n\nint mcp251xfd_handle_rxif(struct mcp251xfd_priv *priv)\n{\n\tstruct mcp251xfd_rx_ring *ring;\n\tint err, n;\n\n\tmcp251xfd_for_each_rx_ring(priv, ring, n) {\n\t\t \n\t\tif ((ring->nr > 0 || !priv->rx_obj_num_coalesce_irq) &&\n\t\t    !(priv->regs_status.rxif & BIT(ring->fifo_nr)))\n\t\t\tcontinue;\n\n\t\terr = mcp251xfd_handle_rxif_ring(priv, ring);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (priv->rx_coalesce_usecs_irq)\n\t\thrtimer_start(&priv->rx_irq_timer,\n\t\t\t      ns_to_ktime(priv->rx_coalesce_usecs_irq *\n\t\t\t\t\t  NSEC_PER_USEC),\n\t\t\t      HRTIMER_MODE_REL);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}