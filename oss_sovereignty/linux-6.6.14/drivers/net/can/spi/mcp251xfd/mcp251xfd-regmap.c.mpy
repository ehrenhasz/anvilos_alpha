{
  "module_name": "mcp251xfd-regmap.c",
  "hash_id": "35e20521568b2bbb4b9c5fa27ef8b974e6b92232d757a055fd286476842c965b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/spi/mcp251xfd/mcp251xfd-regmap.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n#include \"mcp251xfd.h\"\n\n#include <asm/unaligned.h>\n\nstatic const struct regmap_config mcp251xfd_regmap_crc;\n\nstatic int\nmcp251xfd_regmap_nocrc_write(void *context, const void *data, size_t count)\n{\n\tstruct spi_device *spi = context;\n\n\treturn spi_write(spi, data, count);\n}\n\nstatic int\nmcp251xfd_regmap_nocrc_gather_write(void *context,\n\t\t\t\t    const void *reg, size_t reg_len,\n\t\t\t\t    const void *val, size_t val_len)\n{\n\tstruct spi_device *spi = context;\n\tstruct mcp251xfd_priv *priv = spi_get_drvdata(spi);\n\tstruct mcp251xfd_map_buf_nocrc *buf_tx = priv->map_buf_nocrc_tx;\n\tstruct spi_transfer xfer[] = {\n\t\t{\n\t\t\t.tx_buf = buf_tx,\n\t\t\t.len = sizeof(buf_tx->cmd) + val_len,\n\t\t},\n\t};\n\n\tBUILD_BUG_ON(sizeof(buf_tx->cmd) != sizeof(__be16));\n\n\tif (IS_ENABLED(CONFIG_CAN_MCP251XFD_SANITY) &&\n\t    reg_len != sizeof(buf_tx->cmd.cmd))\n\t\treturn -EINVAL;\n\n\tmemcpy(&buf_tx->cmd, reg, sizeof(buf_tx->cmd));\n\tmemcpy(buf_tx->data, val, val_len);\n\n\treturn spi_sync_transfer(spi, xfer, ARRAY_SIZE(xfer));\n}\n\nstatic inline bool\nmcp251xfd_update_bits_read_reg(const struct mcp251xfd_priv *priv,\n\t\t\t       unsigned int reg)\n{\n\tstruct mcp251xfd_rx_ring *ring;\n\tint n;\n\n\tswitch (reg) {\n\tcase MCP251XFD_REG_INT:\n\tcase MCP251XFD_REG_TEFCON:\n\tcase MCP251XFD_REG_FLTCON(0):\n\tcase MCP251XFD_REG_ECCSTAT:\n\tcase MCP251XFD_REG_CRC:\n\t\treturn false;\n\tcase MCP251XFD_REG_CON:\n\tcase MCP251XFD_REG_OSC:\n\tcase MCP251XFD_REG_ECCCON:\n\t\treturn true;\n\tdefault:\n\t\tmcp251xfd_for_each_rx_ring(priv, ring, n) {\n\t\t\tif (reg == MCP251XFD_REG_FIFOCON(ring->fifo_nr))\n\t\t\t\treturn false;\n\t\t\tif (reg == MCP251XFD_REG_FIFOSTA(ring->fifo_nr))\n\t\t\t\treturn true;\n\t\t}\n\n\t\tWARN(1, \"Status of reg 0x%04x unknown.\\n\", reg);\n\t}\n\n\treturn true;\n}\n\nstatic int\nmcp251xfd_regmap_nocrc_update_bits(void *context, unsigned int reg,\n\t\t\t\t   unsigned int mask, unsigned int val)\n{\n\tstruct spi_device *spi = context;\n\tstruct mcp251xfd_priv *priv = spi_get_drvdata(spi);\n\tstruct mcp251xfd_map_buf_nocrc *buf_rx = priv->map_buf_nocrc_rx;\n\tstruct mcp251xfd_map_buf_nocrc *buf_tx = priv->map_buf_nocrc_tx;\n\t__le32 orig_le32 = 0, mask_le32, val_le32, tmp_le32;\n\tu8 first_byte, last_byte, len;\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(buf_rx->cmd) != sizeof(__be16));\n\tBUILD_BUG_ON(sizeof(buf_tx->cmd) != sizeof(__be16));\n\n\tif (IS_ENABLED(CONFIG_CAN_MCP251XFD_SANITY) &&\n\t    mask == 0)\n\t\treturn -EINVAL;\n\n\tfirst_byte = mcp251xfd_first_byte_set(mask);\n\tlast_byte = mcp251xfd_last_byte_set(mask);\n\tlen = last_byte - first_byte + 1;\n\n\tif (mcp251xfd_update_bits_read_reg(priv, reg)) {\n\t\tstruct spi_transfer xfer[2] = { };\n\t\tstruct spi_message msg;\n\n\t\tspi_message_init(&msg);\n\t\tspi_message_add_tail(&xfer[0], &msg);\n\n\t\tif (priv->devtype_data.quirks & MCP251XFD_QUIRK_HALF_DUPLEX) {\n\t\t\txfer[0].tx_buf = buf_tx;\n\t\t\txfer[0].len = sizeof(buf_tx->cmd);\n\n\t\t\txfer[1].rx_buf = buf_rx->data;\n\t\t\txfer[1].len = len;\n\t\t\tspi_message_add_tail(&xfer[1], &msg);\n\t\t} else {\n\t\t\txfer[0].tx_buf = buf_tx;\n\t\t\txfer[0].rx_buf = buf_rx;\n\t\t\txfer[0].len = sizeof(buf_tx->cmd) + len;\n\n\t\t\tif (MCP251XFD_SANITIZE_SPI)\n\t\t\t\tmemset(buf_tx->data, 0x0, len);\n\t\t}\n\n\t\tmcp251xfd_spi_cmd_read_nocrc(&buf_tx->cmd, reg + first_byte);\n\t\terr = spi_sync(spi, &msg);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tmemcpy(&orig_le32, buf_rx->data, len);\n\t}\n\n\tmask_le32 = cpu_to_le32(mask >> BITS_PER_BYTE * first_byte);\n\tval_le32 = cpu_to_le32(val >> BITS_PER_BYTE * first_byte);\n\n\ttmp_le32 = orig_le32 & ~mask_le32;\n\ttmp_le32 |= val_le32 & mask_le32;\n\n\tmcp251xfd_spi_cmd_write_nocrc(&buf_tx->cmd, reg + first_byte);\n\tmemcpy(buf_tx->data, &tmp_le32, len);\n\n\treturn spi_write(spi, buf_tx, sizeof(buf_tx->cmd) + len);\n}\n\nstatic int\nmcp251xfd_regmap_nocrc_read(void *context,\n\t\t\t    const void *reg, size_t reg_len,\n\t\t\t    void *val_buf, size_t val_len)\n{\n\tstruct spi_device *spi = context;\n\tstruct mcp251xfd_priv *priv = spi_get_drvdata(spi);\n\tstruct mcp251xfd_map_buf_nocrc *buf_rx = priv->map_buf_nocrc_rx;\n\tstruct mcp251xfd_map_buf_nocrc *buf_tx = priv->map_buf_nocrc_tx;\n\tstruct spi_transfer xfer[2] = { };\n\tstruct spi_message msg;\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(buf_rx->cmd) != sizeof(__be16));\n\tBUILD_BUG_ON(sizeof(buf_tx->cmd) != sizeof(__be16));\n\n\tif (IS_ENABLED(CONFIG_CAN_MCP251XFD_SANITY) &&\n\t    reg_len != sizeof(buf_tx->cmd.cmd))\n\t\treturn -EINVAL;\n\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&xfer[0], &msg);\n\n\tif (priv->devtype_data.quirks & MCP251XFD_QUIRK_HALF_DUPLEX) {\n\t\txfer[0].tx_buf = reg;\n\t\txfer[0].len = sizeof(buf_tx->cmd);\n\n\t\txfer[1].rx_buf = val_buf;\n\t\txfer[1].len = val_len;\n\t\tspi_message_add_tail(&xfer[1], &msg);\n\t} else {\n\t\txfer[0].tx_buf = buf_tx;\n\t\txfer[0].rx_buf = buf_rx;\n\t\txfer[0].len = sizeof(buf_tx->cmd) + val_len;\n\n\t\tmemcpy(&buf_tx->cmd, reg, sizeof(buf_tx->cmd));\n\t\tif (MCP251XFD_SANITIZE_SPI)\n\t\t\tmemset(buf_tx->data, 0x0, val_len);\n\t}\n\n\terr = spi_sync(spi, &msg);\n\tif (err)\n\t\treturn err;\n\n\tif (!(priv->devtype_data.quirks & MCP251XFD_QUIRK_HALF_DUPLEX))\n\t\tmemcpy(val_buf, buf_rx->data, val_len);\n\n\treturn 0;\n}\n\nstatic int\nmcp251xfd_regmap_crc_gather_write(void *context,\n\t\t\t\t  const void *reg_p, size_t reg_len,\n\t\t\t\t  const void *val, size_t val_len)\n{\n\tstruct spi_device *spi = context;\n\tstruct mcp251xfd_priv *priv = spi_get_drvdata(spi);\n\tstruct mcp251xfd_map_buf_crc *buf_tx = priv->map_buf_crc_tx;\n\tstruct spi_transfer xfer[] = {\n\t\t{\n\t\t\t.tx_buf = buf_tx,\n\t\t\t.len = sizeof(buf_tx->cmd) + val_len +\n\t\t\t\tsizeof(buf_tx->crc),\n\t\t},\n\t};\n\tu16 reg = *(u16 *)reg_p;\n\tu16 crc;\n\n\tBUILD_BUG_ON(sizeof(buf_tx->cmd) != sizeof(__be16) + sizeof(u8));\n\n\tif (IS_ENABLED(CONFIG_CAN_MCP251XFD_SANITY) &&\n\t    reg_len != sizeof(buf_tx->cmd.cmd) +\n\t    mcp251xfd_regmap_crc.pad_bits / BITS_PER_BYTE)\n\t\treturn -EINVAL;\n\n\tmcp251xfd_spi_cmd_write_crc(&buf_tx->cmd, reg, val_len);\n\tmemcpy(buf_tx->data, val, val_len);\n\n\tcrc = mcp251xfd_crc16_compute(buf_tx, sizeof(buf_tx->cmd) + val_len);\n\tput_unaligned_be16(crc, buf_tx->data + val_len);\n\n\treturn spi_sync_transfer(spi, xfer, ARRAY_SIZE(xfer));\n}\n\nstatic int\nmcp251xfd_regmap_crc_write(void *context,\n\t\t\t   const void *data, size_t count)\n{\n\tconst size_t data_offset = sizeof(__be16) +\n\t\tmcp251xfd_regmap_crc.pad_bits / BITS_PER_BYTE;\n\n\treturn mcp251xfd_regmap_crc_gather_write(context,\n\t\t\t\t\t\t data, data_offset,\n\t\t\t\t\t\t data + data_offset,\n\t\t\t\t\t\t count - data_offset);\n}\n\nstatic int\nmcp251xfd_regmap_crc_read_check_crc(const struct mcp251xfd_map_buf_crc * const buf_rx,\n\t\t\t\t    const struct mcp251xfd_map_buf_crc * const buf_tx,\n\t\t\t\t    unsigned int data_len)\n{\n\tu16 crc_received, crc_calculated;\n\n\tcrc_received = get_unaligned_be16(buf_rx->data + data_len);\n\tcrc_calculated = mcp251xfd_crc16_compute2(&buf_tx->cmd,\n\t\t\t\t\t\t  sizeof(buf_tx->cmd),\n\t\t\t\t\t\t  buf_rx->data,\n\t\t\t\t\t\t  data_len);\n\tif (crc_received != crc_calculated)\n\t\treturn -EBADMSG;\n\n\treturn 0;\n}\n\nstatic int\nmcp251xfd_regmap_crc_read_one(struct mcp251xfd_priv *priv,\n\t\t\t      struct spi_message *msg, unsigned int data_len)\n{\n\tconst struct mcp251xfd_map_buf_crc *buf_rx = priv->map_buf_crc_rx;\n\tconst struct mcp251xfd_map_buf_crc *buf_tx = priv->map_buf_crc_tx;\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(buf_rx->cmd) != sizeof(__be16) + sizeof(u8));\n\tBUILD_BUG_ON(sizeof(buf_tx->cmd) != sizeof(__be16) + sizeof(u8));\n\n\terr = spi_sync(priv->spi, msg);\n\tif (err)\n\t\treturn err;\n\n\treturn mcp251xfd_regmap_crc_read_check_crc(buf_rx, buf_tx, data_len);\n}\n\nstatic int\nmcp251xfd_regmap_crc_read(void *context,\n\t\t\t  const void *reg_p, size_t reg_len,\n\t\t\t  void *val_buf, size_t val_len)\n{\n\tstruct spi_device *spi = context;\n\tstruct mcp251xfd_priv *priv = spi_get_drvdata(spi);\n\tstruct mcp251xfd_map_buf_crc *buf_rx = priv->map_buf_crc_rx;\n\tstruct mcp251xfd_map_buf_crc *buf_tx = priv->map_buf_crc_tx;\n\tstruct spi_transfer xfer[2] = { };\n\tstruct spi_message msg;\n\tu16 reg = *(u16 *)reg_p;\n\tint i, err;\n\n\tBUILD_BUG_ON(sizeof(buf_rx->cmd) != sizeof(__be16) + sizeof(u8));\n\tBUILD_BUG_ON(sizeof(buf_tx->cmd) != sizeof(__be16) + sizeof(u8));\n\n\tif (IS_ENABLED(CONFIG_CAN_MCP251XFD_SANITY) &&\n\t    reg_len != sizeof(buf_tx->cmd.cmd) +\n\t    mcp251xfd_regmap_crc.pad_bits / BITS_PER_BYTE)\n\t\treturn -EINVAL;\n\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&xfer[0], &msg);\n\n\tif (priv->devtype_data.quirks & MCP251XFD_QUIRK_HALF_DUPLEX) {\n\t\txfer[0].tx_buf = buf_tx;\n\t\txfer[0].len = sizeof(buf_tx->cmd);\n\n\t\txfer[1].rx_buf = buf_rx->data;\n\t\txfer[1].len = val_len + sizeof(buf_tx->crc);\n\t\tspi_message_add_tail(&xfer[1], &msg);\n\t} else {\n\t\txfer[0].tx_buf = buf_tx;\n\t\txfer[0].rx_buf = buf_rx;\n\t\txfer[0].len = sizeof(buf_tx->cmd) + val_len +\n\t\t\tsizeof(buf_tx->crc);\n\n\t\tif (MCP251XFD_SANITIZE_SPI)\n\t\t\tmemset(buf_tx->data, 0x0, val_len +\n\t\t\t       sizeof(buf_tx->crc));\n\t}\n\n\tmcp251xfd_spi_cmd_read_crc(&buf_tx->cmd, reg, val_len);\n\n\tfor (i = 0; i < MCP251XFD_READ_CRC_RETRIES_MAX; i++) {\n\t\terr = mcp251xfd_regmap_crc_read_one(priv, &msg, val_len);\n\t\tif (!err)\n\t\t\tgoto out;\n\t\tif (err != -EBADMSG)\n\t\t\treturn err;\n\n\t\t \n\t\tif (reg == MCP251XFD_REG_TBC &&\n\t\t    ((buf_rx->data[0] & 0xf8) == 0x0 ||\n\t\t     (buf_rx->data[0] & 0xf8) == 0x80)) {\n\t\t\t \n\t\t\tbuf_rx->data[0] ^= 0x80;\n\n\t\t\t \n\t\t\terr = mcp251xfd_regmap_crc_read_check_crc(buf_rx,\n\t\t\t\t\t\t\t\t  buf_tx,\n\t\t\t\t\t\t\t\t  val_len);\n\t\t\tif (!err) {\n\t\t\t\t \n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (reg == MCP251XFD_REG_OSC && val_len == sizeof(__le32)) {\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tnetdev_info(priv->ndev,\n\t\t\t    \"CRC read error at address 0x%04x (length=%zd, data=%*ph, CRC=0x%04x) retrying.\\n\",\n\t\t\t    reg, val_len, (int)val_len, buf_rx->data,\n\t\t\t    get_unaligned_be16(buf_rx->data + val_len));\n\t}\n\n\tif (err) {\n\t\tnetdev_err(priv->ndev,\n\t\t\t   \"CRC read error at address 0x%04x (length=%zd, data=%*ph, CRC=0x%04x).\\n\",\n\t\t\t   reg, val_len, (int)val_len, buf_rx->data,\n\t\t\t   get_unaligned_be16(buf_rx->data + val_len));\n\n\t\treturn err;\n\t}\n out:\n\tmemcpy(val_buf, buf_rx->data, val_len);\n\n\treturn 0;\n}\n\nstatic const struct regmap_range mcp251xfd_reg_table_yes_range[] = {\n\tregmap_reg_range(0x000, 0x2ec),\t \n\tregmap_reg_range(0x400, 0xbfc),\t \n\tregmap_reg_range(0xe00, 0xe14),\t \n};\n\nstatic const struct regmap_access_table mcp251xfd_reg_table = {\n\t.yes_ranges = mcp251xfd_reg_table_yes_range,\n\t.n_yes_ranges = ARRAY_SIZE(mcp251xfd_reg_table_yes_range),\n};\n\nstatic const struct regmap_config mcp251xfd_regmap_nocrc = {\n\t.name = \"nocrc\",\n\t.reg_bits = 16,\n\t.reg_stride = 4,\n\t.pad_bits = 0,\n\t.val_bits = 32,\n\t.max_register = 0xffc,\n\t.wr_table = &mcp251xfd_reg_table,\n\t.rd_table = &mcp251xfd_reg_table,\n\t.cache_type = REGCACHE_NONE,\n\t.read_flag_mask = (__force unsigned long)\n\t\tcpu_to_be16(MCP251XFD_SPI_INSTRUCTION_READ),\n\t.write_flag_mask = (__force unsigned long)\n\t\tcpu_to_be16(MCP251XFD_SPI_INSTRUCTION_WRITE),\n};\n\nstatic const struct regmap_bus mcp251xfd_bus_nocrc = {\n\t.write = mcp251xfd_regmap_nocrc_write,\n\t.gather_write = mcp251xfd_regmap_nocrc_gather_write,\n\t.reg_update_bits = mcp251xfd_regmap_nocrc_update_bits,\n\t.read = mcp251xfd_regmap_nocrc_read,\n\t.reg_format_endian_default = REGMAP_ENDIAN_BIG,\n\t.val_format_endian_default = REGMAP_ENDIAN_LITTLE,\n\t.max_raw_read = sizeof_field(struct mcp251xfd_map_buf_nocrc, data),\n\t.max_raw_write = sizeof_field(struct mcp251xfd_map_buf_nocrc, data),\n};\n\nstatic const struct regmap_config mcp251xfd_regmap_crc = {\n\t.name = \"crc\",\n\t.reg_bits = 16,\n\t.reg_stride = 4,\n\t.pad_bits = 16,\t\t \n\t.val_bits = 32,\n\t.max_register = 0xffc,\n\t.wr_table = &mcp251xfd_reg_table,\n\t.rd_table = &mcp251xfd_reg_table,\n\t.cache_type = REGCACHE_NONE,\n};\n\nstatic const struct regmap_bus mcp251xfd_bus_crc = {\n\t.write = mcp251xfd_regmap_crc_write,\n\t.gather_write = mcp251xfd_regmap_crc_gather_write,\n\t.read = mcp251xfd_regmap_crc_read,\n\t.reg_format_endian_default = REGMAP_ENDIAN_NATIVE,\n\t.val_format_endian_default = REGMAP_ENDIAN_LITTLE,\n\t.max_raw_read = sizeof_field(struct mcp251xfd_map_buf_crc, data),\n\t.max_raw_write = sizeof_field(struct mcp251xfd_map_buf_crc, data),\n};\n\nstatic inline bool\nmcp251xfd_regmap_use_nocrc(struct mcp251xfd_priv *priv)\n{\n\treturn (!(priv->devtype_data.quirks & MCP251XFD_QUIRK_CRC_REG)) ||\n\t\t(!(priv->devtype_data.quirks & MCP251XFD_QUIRK_CRC_RX));\n}\n\nstatic inline bool\nmcp251xfd_regmap_use_crc(struct mcp251xfd_priv *priv)\n{\n\treturn (priv->devtype_data.quirks & MCP251XFD_QUIRK_CRC_REG) ||\n\t\t(priv->devtype_data.quirks & MCP251XFD_QUIRK_CRC_RX);\n}\n\nstatic int\nmcp251xfd_regmap_init_nocrc(struct mcp251xfd_priv *priv)\n{\n\tif (!priv->map_nocrc) {\n\t\tstruct regmap *map;\n\n\t\tmap = devm_regmap_init(&priv->spi->dev, &mcp251xfd_bus_nocrc,\n\t\t\t\t       priv->spi, &mcp251xfd_regmap_nocrc);\n\t\tif (IS_ERR(map))\n\t\t\treturn PTR_ERR(map);\n\n\t\tpriv->map_nocrc = map;\n\t}\n\n\tif (!priv->map_buf_nocrc_rx) {\n\t\tpriv->map_buf_nocrc_rx =\n\t\t\tdevm_kzalloc(&priv->spi->dev,\n\t\t\t\t     sizeof(*priv->map_buf_nocrc_rx),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!priv->map_buf_nocrc_rx)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (!priv->map_buf_nocrc_tx) {\n\t\tpriv->map_buf_nocrc_tx =\n\t\t\tdevm_kzalloc(&priv->spi->dev,\n\t\t\t\t     sizeof(*priv->map_buf_nocrc_tx),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!priv->map_buf_nocrc_tx)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (!(priv->devtype_data.quirks & MCP251XFD_QUIRK_CRC_REG))\n\t\tpriv->map_reg = priv->map_nocrc;\n\n\tif (!(priv->devtype_data.quirks & MCP251XFD_QUIRK_CRC_RX))\n\t\tpriv->map_rx = priv->map_nocrc;\n\n\treturn 0;\n}\n\nstatic void mcp251xfd_regmap_destroy_nocrc(struct mcp251xfd_priv *priv)\n{\n\tif (priv->map_buf_nocrc_rx) {\n\t\tdevm_kfree(&priv->spi->dev, priv->map_buf_nocrc_rx);\n\t\tpriv->map_buf_nocrc_rx = NULL;\n\t}\n\tif (priv->map_buf_nocrc_tx) {\n\t\tdevm_kfree(&priv->spi->dev, priv->map_buf_nocrc_tx);\n\t\tpriv->map_buf_nocrc_tx = NULL;\n\t}\n}\n\nstatic int\nmcp251xfd_regmap_init_crc(struct mcp251xfd_priv *priv)\n{\n\tif (!priv->map_crc) {\n\t\tstruct regmap *map;\n\n\t\tmap = devm_regmap_init(&priv->spi->dev, &mcp251xfd_bus_crc,\n\t\t\t\t       priv->spi, &mcp251xfd_regmap_crc);\n\t\tif (IS_ERR(map))\n\t\t\treturn PTR_ERR(map);\n\n\t\tpriv->map_crc = map;\n\t}\n\n\tif (!priv->map_buf_crc_rx) {\n\t\tpriv->map_buf_crc_rx =\n\t\t\tdevm_kzalloc(&priv->spi->dev,\n\t\t\t\t     sizeof(*priv->map_buf_crc_rx),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!priv->map_buf_crc_rx)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (!priv->map_buf_crc_tx) {\n\t\tpriv->map_buf_crc_tx =\n\t\t\tdevm_kzalloc(&priv->spi->dev,\n\t\t\t\t     sizeof(*priv->map_buf_crc_tx),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!priv->map_buf_crc_tx)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (priv->devtype_data.quirks & MCP251XFD_QUIRK_CRC_REG)\n\t\tpriv->map_reg = priv->map_crc;\n\n\tif (priv->devtype_data.quirks & MCP251XFD_QUIRK_CRC_RX)\n\t\tpriv->map_rx = priv->map_crc;\n\n\treturn 0;\n}\n\nstatic void mcp251xfd_regmap_destroy_crc(struct mcp251xfd_priv *priv)\n{\n\tif (priv->map_buf_crc_rx) {\n\t\tdevm_kfree(&priv->spi->dev, priv->map_buf_crc_rx);\n\t\tpriv->map_buf_crc_rx = NULL;\n\t}\n\tif (priv->map_buf_crc_tx) {\n\t\tdevm_kfree(&priv->spi->dev, priv->map_buf_crc_tx);\n\t\tpriv->map_buf_crc_tx = NULL;\n\t}\n}\n\nint mcp251xfd_regmap_init(struct mcp251xfd_priv *priv)\n{\n\tint err;\n\n\tif (mcp251xfd_regmap_use_nocrc(priv)) {\n\t\terr = mcp251xfd_regmap_init_nocrc(priv);\n\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tmcp251xfd_regmap_destroy_nocrc(priv);\n\t}\n\n\tif (mcp251xfd_regmap_use_crc(priv)) {\n\t\terr = mcp251xfd_regmap_init_crc(priv);\n\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tmcp251xfd_regmap_destroy_crc(priv);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}