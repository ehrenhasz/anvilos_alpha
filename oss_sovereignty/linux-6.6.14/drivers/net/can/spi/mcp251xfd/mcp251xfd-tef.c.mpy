{
  "module_name": "mcp251xfd-tef.c",
  "hash_id": "243665f692910e36fb3556c87cf6eff8897f172b169f56de332319b16e227c99",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/spi/mcp251xfd/mcp251xfd-tef.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/bitfield.h>\n\n#include \"mcp251xfd.h\"\n\nstatic inline int\nmcp251xfd_tef_tail_get_from_chip(const struct mcp251xfd_priv *priv,\n\t\t\t\t u8 *tef_tail)\n{\n\tu32 tef_ua;\n\tint err;\n\n\terr = regmap_read(priv->map_reg, MCP251XFD_REG_TEFUA, &tef_ua);\n\tif (err)\n\t\treturn err;\n\n\t*tef_tail = tef_ua / sizeof(struct mcp251xfd_hw_tef_obj);\n\n\treturn 0;\n}\n\nstatic int mcp251xfd_check_tef_tail(const struct mcp251xfd_priv *priv)\n{\n\tu8 tef_tail_chip, tef_tail;\n\tint err;\n\n\tif (!IS_ENABLED(CONFIG_CAN_MCP251XFD_SANITY))\n\t\treturn 0;\n\n\terr = mcp251xfd_tef_tail_get_from_chip(priv, &tef_tail_chip);\n\tif (err)\n\t\treturn err;\n\n\ttef_tail = mcp251xfd_get_tef_tail(priv);\n\tif (tef_tail_chip != tef_tail) {\n\t\tnetdev_err(priv->ndev,\n\t\t\t   \"TEF tail of chip (0x%02x) and ours (0x%08x) inconsistent.\\n\",\n\t\t\t   tef_tail_chip, tef_tail);\n\t\treturn -EILSEQ;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmcp251xfd_handle_tefif_recover(const struct mcp251xfd_priv *priv, const u32 seq)\n{\n\tconst struct mcp251xfd_tx_ring *tx_ring = priv->tx;\n\tu32 tef_sta;\n\tint err;\n\n\terr = regmap_read(priv->map_reg, MCP251XFD_REG_TEFSTA, &tef_sta);\n\tif (err)\n\t\treturn err;\n\n\tif (tef_sta & MCP251XFD_REG_TEFSTA_TEFOVIF) {\n\t\tnetdev_err(priv->ndev,\n\t\t\t   \"Transmit Event FIFO buffer overflow.\\n\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tnetdev_info(priv->ndev,\n\t\t    \"Transmit Event FIFO buffer %s. (seq=0x%08x, tef_tail=0x%08x, tef_head=0x%08x, tx_head=0x%08x).\\n\",\n\t\t    tef_sta & MCP251XFD_REG_TEFSTA_TEFFIF ?\n\t\t    \"full\" : tef_sta & MCP251XFD_REG_TEFSTA_TEFNEIF ?\n\t\t    \"not empty\" : \"empty\",\n\t\t    seq, priv->tef->tail, priv->tef->head, tx_ring->head);\n\n\t \n\treturn -EAGAIN;\n}\n\nstatic int\nmcp251xfd_handle_tefif_one(struct mcp251xfd_priv *priv,\n\t\t\t   const struct mcp251xfd_hw_tef_obj *hw_tef_obj,\n\t\t\t   unsigned int *frame_len_ptr)\n{\n\tstruct net_device_stats *stats = &priv->ndev->stats;\n\tstruct sk_buff *skb;\n\tu32 seq, seq_masked, tef_tail_masked, tef_tail;\n\n\tseq = FIELD_GET(MCP251XFD_OBJ_FLAGS_SEQ_MCP2518FD_MASK,\n\t\t\thw_tef_obj->flags);\n\n\t \n\tseq_masked = seq &\n\t\tfield_mask(MCP251XFD_OBJ_FLAGS_SEQ_MCP2517FD_MASK);\n\ttef_tail_masked = priv->tef->tail &\n\t\tfield_mask(MCP251XFD_OBJ_FLAGS_SEQ_MCP2517FD_MASK);\n\tif (seq_masked != tef_tail_masked)\n\t\treturn mcp251xfd_handle_tefif_recover(priv, seq);\n\n\ttef_tail = mcp251xfd_get_tef_tail(priv);\n\tskb = priv->can.echo_skb[tef_tail];\n\tif (skb)\n\t\tmcp251xfd_skb_set_timestamp(priv, skb, hw_tef_obj->ts);\n\tstats->tx_bytes +=\n\t\tcan_rx_offload_get_echo_skb_queue_timestamp(&priv->offload,\n\t\t\t\t\t\t\t    tef_tail, hw_tef_obj->ts,\n\t\t\t\t\t\t\t    frame_len_ptr);\n\tstats->tx_packets++;\n\tpriv->tef->tail++;\n\n\treturn 0;\n}\n\nstatic int mcp251xfd_tef_ring_update(struct mcp251xfd_priv *priv)\n{\n\tconst struct mcp251xfd_tx_ring *tx_ring = priv->tx;\n\tunsigned int new_head;\n\tu8 chip_tx_tail;\n\tint err;\n\n\terr = mcp251xfd_tx_tail_get_from_chip(priv, &chip_tx_tail);\n\tif (err)\n\t\treturn err;\n\n\t \n\tnew_head = round_down(priv->tef->head, tx_ring->obj_num) + chip_tx_tail;\n\tif (new_head <= priv->tef->head)\n\t\tnew_head += tx_ring->obj_num;\n\n\t \n\tpriv->tef->head = min(new_head, tx_ring->head);\n\n\treturn mcp251xfd_check_tef_tail(priv);\n}\n\nstatic inline int\nmcp251xfd_tef_obj_read(const struct mcp251xfd_priv *priv,\n\t\t       struct mcp251xfd_hw_tef_obj *hw_tef_obj,\n\t\t       const u8 offset, const u8 len)\n{\n\tconst struct mcp251xfd_tx_ring *tx_ring = priv->tx;\n\tconst int val_bytes = regmap_get_val_bytes(priv->map_rx);\n\n\tif (IS_ENABLED(CONFIG_CAN_MCP251XFD_SANITY) &&\n\t    (offset > tx_ring->obj_num ||\n\t     len > tx_ring->obj_num ||\n\t     offset + len > tx_ring->obj_num)) {\n\t\tnetdev_err(priv->ndev,\n\t\t\t   \"Trying to read too many TEF objects (max=%d, offset=%d, len=%d).\\n\",\n\t\t\t   tx_ring->obj_num, offset, len);\n\t\treturn -ERANGE;\n\t}\n\n\treturn regmap_bulk_read(priv->map_rx,\n\t\t\t\tmcp251xfd_get_tef_obj_addr(offset),\n\t\t\t\thw_tef_obj,\n\t\t\t\tsizeof(*hw_tef_obj) / val_bytes * len);\n}\n\nstatic inline void mcp251xfd_ecc_tefif_successful(struct mcp251xfd_priv *priv)\n{\n\tstruct mcp251xfd_ecc *ecc = &priv->ecc;\n\n\tecc->ecc_stat = 0;\n}\n\nint mcp251xfd_handle_tefif(struct mcp251xfd_priv *priv)\n{\n\tstruct mcp251xfd_hw_tef_obj hw_tef_obj[MCP251XFD_TX_OBJ_NUM_MAX];\n\tunsigned int total_frame_len = 0;\n\tu8 tef_tail, len, l;\n\tint err, i;\n\n\terr = mcp251xfd_tef_ring_update(priv);\n\tif (err)\n\t\treturn err;\n\n\ttef_tail = mcp251xfd_get_tef_tail(priv);\n\tlen = mcp251xfd_get_tef_len(priv);\n\tl = mcp251xfd_get_tef_linear_len(priv);\n\terr = mcp251xfd_tef_obj_read(priv, hw_tef_obj, tef_tail, l);\n\tif (err)\n\t\treturn err;\n\n\tif (l < len) {\n\t\terr = mcp251xfd_tef_obj_read(priv, &hw_tef_obj[l], 0, len - l);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor (i = 0; i < len; i++) {\n\t\tunsigned int frame_len = 0;\n\n\t\terr = mcp251xfd_handle_tefif_one(priv, &hw_tef_obj[i], &frame_len);\n\t\t \n\t\tif (err == -EAGAIN)\n\t\t\tgoto out_netif_wake_queue;\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttotal_frame_len += frame_len;\n\t}\n\n out_netif_wake_queue:\n\tlen = i;\t \n\tif (len) {\n\t\tstruct mcp251xfd_tef_ring *ring = priv->tef;\n\t\tstruct mcp251xfd_tx_ring *tx_ring = priv->tx;\n\t\tint offset;\n\n\t\t \n\t\toffset = ARRAY_SIZE(ring->uinc_xfer) - len;\n\t\terr = spi_sync_transfer(priv->spi,\n\t\t\t\t\tring->uinc_xfer + offset, len);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttx_ring->tail += len;\n\t\tnetdev_completed_queue(priv->ndev, len, total_frame_len);\n\n\t\terr = mcp251xfd_check_tef_tail(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmcp251xfd_ecc_tefif_successful(priv);\n\n\tif (mcp251xfd_get_tx_free(priv->tx)) {\n\t\t \n\t\tsmp_mb();\n\t\tnetif_wake_queue(priv->ndev);\n\t}\n\n\tif (priv->tx_coalesce_usecs_irq)\n\t\thrtimer_start(&priv->tx_irq_timer,\n\t\t\t      ns_to_ktime(priv->tx_coalesce_usecs_irq *\n\t\t\t\t\t  NSEC_PER_USEC),\n\t\t\t      HRTIMER_MODE_REL);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}