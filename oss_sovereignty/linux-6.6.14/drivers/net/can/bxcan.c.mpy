{
  "module_name": "bxcan.c",
  "hash_id": "3931e94eb58150f1cd64c1c2424fa4fc349308f2092b092503d55c1520722db2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/bxcan.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/bitfield.h>\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n#include <linux/can/rx-offload.h>\n#include <linux/clk.h>\n#include <linux/ethtool.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#define BXCAN_NAPI_WEIGHT 3\n#define BXCAN_TIMEOUT_US 10000\n\n#define BXCAN_RX_MB_NUM 2\n#define BXCAN_TX_MB_NUM 3\n\n \n#define BXCAN_MCR_RESET BIT(15)\n#define BXCAN_MCR_TTCM BIT(7)\n#define BXCAN_MCR_ABOM BIT(6)\n#define BXCAN_MCR_AWUM BIT(5)\n#define BXCAN_MCR_NART BIT(4)\n#define BXCAN_MCR_RFLM BIT(3)\n#define BXCAN_MCR_TXFP BIT(2)\n#define BXCAN_MCR_SLEEP BIT(1)\n#define BXCAN_MCR_INRQ BIT(0)\n\n \n#define BXCAN_MSR_ERRI BIT(2)\n#define BXCAN_MSR_SLAK BIT(1)\n#define BXCAN_MSR_INAK BIT(0)\n\n \n#define BXCAN_TSR_RQCP2 BIT(16)\n#define BXCAN_TSR_RQCP1 BIT(8)\n#define BXCAN_TSR_RQCP0 BIT(0)\n\n \n#define BXCAN_RF0R_RFOM0 BIT(5)\n#define BXCAN_RF0R_FMP0_MASK GENMASK(1, 0)\n\n \n#define BXCAN_IER_SLKIE BIT(17)\n#define BXCAN_IER_WKUIE BIT(16)\n#define BXCAN_IER_ERRIE BIT(15)\n#define BXCAN_IER_LECIE BIT(11)\n#define BXCAN_IER_BOFIE BIT(10)\n#define BXCAN_IER_EPVIE BIT(9)\n#define BXCAN_IER_EWGIE BIT(8)\n#define BXCAN_IER_FOVIE1 BIT(6)\n#define BXCAN_IER_FFIE1 BIT(5)\n#define BXCAN_IER_FMPIE1 BIT(4)\n#define BXCAN_IER_FOVIE0 BIT(3)\n#define BXCAN_IER_FFIE0 BIT(2)\n#define BXCAN_IER_FMPIE0 BIT(1)\n#define BXCAN_IER_TMEIE BIT(0)\n\n \n#define BXCAN_ESR_REC_MASK GENMASK(31, 24)\n#define BXCAN_ESR_TEC_MASK GENMASK(23, 16)\n#define BXCAN_ESR_LEC_MASK GENMASK(6, 4)\n#define BXCAN_ESR_BOFF BIT(2)\n#define BXCAN_ESR_EPVF BIT(1)\n#define BXCAN_ESR_EWGF BIT(0)\n\n \n#define BXCAN_BTR_SILM BIT(31)\n#define BXCAN_BTR_LBKM BIT(30)\n#define BXCAN_BTR_SJW_MASK GENMASK(25, 24)\n#define BXCAN_BTR_TS2_MASK GENMASK(22, 20)\n#define BXCAN_BTR_TS1_MASK GENMASK(19, 16)\n#define BXCAN_BTR_BRP_MASK GENMASK(9, 0)\n\n \n#define BXCAN_TIxR_STID_MASK GENMASK(31, 21)\n#define BXCAN_TIxR_EXID_MASK GENMASK(31, 3)\n#define BXCAN_TIxR_IDE BIT(2)\n#define BXCAN_TIxR_RTR BIT(1)\n#define BXCAN_TIxR_TXRQ BIT(0)\n\n \n#define BXCAN_TDTxR_DLC_MASK GENMASK(3, 0)\n\n \n#define BXCAN_RIxR_STID_MASK GENMASK(31, 21)\n#define BXCAN_RIxR_EXID_MASK GENMASK(31, 3)\n#define BXCAN_RIxR_IDE BIT(2)\n#define BXCAN_RIxR_RTR BIT(1)\n\n \n#define BXCAN_RDTxR_TIME_MASK GENMASK(31, 16)\n#define BXCAN_RDTxR_DLC_MASK GENMASK(3, 0)\n\n#define BXCAN_FMR_REG 0x00\n#define BXCAN_FM1R_REG 0x04\n#define BXCAN_FS1R_REG 0x0c\n#define BXCAN_FFA1R_REG 0x14\n#define BXCAN_FA1R_REG 0x1c\n#define BXCAN_FiR1_REG(b) (0x40 + (b) * 8)\n#define BXCAN_FiR2_REG(b) (0x44 + (b) * 8)\n\n#define BXCAN_FILTER_ID(cfg) ((cfg) == BXCAN_CFG_DUAL_SECONDARY ? 14 : 0)\n\n \n#define BXCAN_FMR_CANSB_MASK GENMASK(13, 8)\n#define BXCAN_FMR_FINIT BIT(0)\n\nenum bxcan_lec_code {\n\tBXCAN_LEC_NO_ERROR = 0,\n\tBXCAN_LEC_STUFF_ERROR,\n\tBXCAN_LEC_FORM_ERROR,\n\tBXCAN_LEC_ACK_ERROR,\n\tBXCAN_LEC_BIT1_ERROR,\n\tBXCAN_LEC_BIT0_ERROR,\n\tBXCAN_LEC_CRC_ERROR,\n\tBXCAN_LEC_UNUSED\n};\n\nenum bxcan_cfg {\n\tBXCAN_CFG_SINGLE = 0,\n\tBXCAN_CFG_DUAL_PRIMARY,\n\tBXCAN_CFG_DUAL_SECONDARY\n};\n\n \nstruct bxcan_mb {\n\tu32 id;\t\t\t \n\tu32 dlc;\t\t \n\tu32 data[2];\t\t \n};\n\n \nstruct bxcan_regs {\n\tu32 mcr;\t\t\t \n\tu32 msr;\t\t\t \n\tu32 tsr;\t\t\t \n\tu32 rf0r;\t\t\t \n\tu32 rf1r;\t\t\t \n\tu32 ier;\t\t\t \n\tu32 esr;\t\t\t \n\tu32 btr;\t\t\t \n\tu32 reserved0[88];\t\t \n\tstruct bxcan_mb tx_mb[BXCAN_TX_MB_NUM];\t \n\tstruct bxcan_mb rx_mb[BXCAN_RX_MB_NUM];\t \n};\n\nstruct bxcan_priv {\n\tstruct can_priv can;\n\tstruct can_rx_offload offload;\n\tstruct device *dev;\n\tstruct net_device *ndev;\n\n\tstruct bxcan_regs __iomem *regs;\n\tstruct regmap *gcan;\n\tint tx_irq;\n\tint sce_irq;\n\tenum bxcan_cfg cfg;\n\tstruct clk *clk;\n\tspinlock_t rmw_lock;\t \n\tunsigned int tx_head;\n\tunsigned int tx_tail;\n\tu32 timestamp;\n};\n\nstatic const struct can_bittiming_const bxcan_bittiming_const = {\n\t.name = KBUILD_MODNAME,\n\t.tseg1_min = 1,\n\t.tseg1_max = 16,\n\t.tseg2_min = 1,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 1024,\n\t.brp_inc = 1,\n};\n\nstatic inline void bxcan_rmw(struct bxcan_priv *priv, void __iomem *addr,\n\t\t\t     u32 clear, u32 set)\n{\n\tunsigned long flags;\n\tu32 old, val;\n\n\tspin_lock_irqsave(&priv->rmw_lock, flags);\n\told = readl(addr);\n\tval = (old & ~clear) | set;\n\tif (val != old)\n\t\twritel(val, addr);\n\n\tspin_unlock_irqrestore(&priv->rmw_lock, flags);\n}\n\nstatic void bxcan_disable_filters(struct bxcan_priv *priv, enum bxcan_cfg cfg)\n{\n\tunsigned int fid = BXCAN_FILTER_ID(cfg);\n\tu32 fmask = BIT(fid);\n\n\tregmap_update_bits(priv->gcan, BXCAN_FA1R_REG, fmask, 0);\n}\n\nstatic void bxcan_enable_filters(struct bxcan_priv *priv, enum bxcan_cfg cfg)\n{\n\tunsigned int fid = BXCAN_FILTER_ID(cfg);\n\tu32 fmask = BIT(fid);\n\n\t \n\n\t \n\tregmap_update_bits(priv->gcan, BXCAN_FMR_REG,\n\t\t\t   BXCAN_FMR_CANSB_MASK | BXCAN_FMR_FINIT,\n\t\t\t   FIELD_PREP(BXCAN_FMR_CANSB_MASK, 14) |\n\t\t\t   BXCAN_FMR_FINIT);\n\n\t \n\tregmap_update_bits(priv->gcan, BXCAN_FA1R_REG, fmask, 0);\n\n\t \n\tregmap_update_bits(priv->gcan, BXCAN_FM1R_REG, fmask, 0);\n\n\t \n\tregmap_update_bits(priv->gcan, BXCAN_FS1R_REG, fmask, fmask);\n\n\t \n\tregmap_update_bits(priv->gcan, BXCAN_FFA1R_REG, fmask, 0);\n\n\t \n\tregmap_write(priv->gcan, BXCAN_FiR1_REG(fid), 0);\n\tregmap_write(priv->gcan, BXCAN_FiR2_REG(fid), 0);\n\n\t \n\tregmap_update_bits(priv->gcan, BXCAN_FA1R_REG, fmask, fmask);\n\n\t \n\tregmap_update_bits(priv->gcan, BXCAN_FMR_REG, BXCAN_FMR_FINIT, 0);\n}\n\nstatic inline u8 bxcan_get_tx_head(const struct bxcan_priv *priv)\n{\n\treturn priv->tx_head % BXCAN_TX_MB_NUM;\n}\n\nstatic inline u8 bxcan_get_tx_tail(const struct bxcan_priv *priv)\n{\n\treturn priv->tx_tail % BXCAN_TX_MB_NUM;\n}\n\nstatic inline u8 bxcan_get_tx_free(const struct bxcan_priv *priv)\n{\n\treturn BXCAN_TX_MB_NUM - (priv->tx_head - priv->tx_tail);\n}\n\nstatic bool bxcan_tx_busy(const struct bxcan_priv *priv)\n{\n\tif (bxcan_get_tx_free(priv) > 0)\n\t\treturn false;\n\n\tnetif_stop_queue(priv->ndev);\n\n\t \n\tsmp_mb();\n\n\tif (bxcan_get_tx_free(priv) == 0) {\n\t\tnetdev_dbg(priv->ndev,\n\t\t\t   \"Stopping tx-queue (tx_head=0x%08x, tx_tail=0x%08x, len=%d).\\n\",\n\t\t\t   priv->tx_head, priv->tx_tail,\n\t\t\t   priv->tx_head - priv->tx_tail);\n\n\t\treturn true;\n\t}\n\n\tnetif_start_queue(priv->ndev);\n\n\treturn false;\n}\n\nstatic int bxcan_chip_softreset(struct bxcan_priv *priv)\n{\n\tstruct bxcan_regs __iomem *regs = priv->regs;\n\tu32 value;\n\n\tbxcan_rmw(priv, &regs->mcr, 0, BXCAN_MCR_RESET);\n\treturn readx_poll_timeout(readl, &regs->msr, value,\n\t\t\t\t  value & BXCAN_MSR_SLAK, BXCAN_TIMEOUT_US,\n\t\t\t\t  USEC_PER_SEC);\n}\n\nstatic int bxcan_enter_init_mode(struct bxcan_priv *priv)\n{\n\tstruct bxcan_regs __iomem *regs = priv->regs;\n\tu32 value;\n\n\tbxcan_rmw(priv, &regs->mcr, 0, BXCAN_MCR_INRQ);\n\treturn readx_poll_timeout(readl, &regs->msr, value,\n\t\t\t\t  value & BXCAN_MSR_INAK, BXCAN_TIMEOUT_US,\n\t\t\t\t  USEC_PER_SEC);\n}\n\nstatic int bxcan_leave_init_mode(struct bxcan_priv *priv)\n{\n\tstruct bxcan_regs __iomem *regs = priv->regs;\n\tu32 value;\n\n\tbxcan_rmw(priv, &regs->mcr, BXCAN_MCR_INRQ, 0);\n\treturn readx_poll_timeout(readl, &regs->msr, value,\n\t\t\t\t  !(value & BXCAN_MSR_INAK), BXCAN_TIMEOUT_US,\n\t\t\t\t  USEC_PER_SEC);\n}\n\nstatic int bxcan_enter_sleep_mode(struct bxcan_priv *priv)\n{\n\tstruct bxcan_regs __iomem *regs = priv->regs;\n\tu32 value;\n\n\tbxcan_rmw(priv, &regs->mcr, 0, BXCAN_MCR_SLEEP);\n\treturn readx_poll_timeout(readl, &regs->msr, value,\n\t\t\t\t  value & BXCAN_MSR_SLAK, BXCAN_TIMEOUT_US,\n\t\t\t\t  USEC_PER_SEC);\n}\n\nstatic int bxcan_leave_sleep_mode(struct bxcan_priv *priv)\n{\n\tstruct bxcan_regs __iomem *regs = priv->regs;\n\tu32 value;\n\n\tbxcan_rmw(priv, &regs->mcr, BXCAN_MCR_SLEEP, 0);\n\treturn readx_poll_timeout(readl, &regs->msr, value,\n\t\t\t\t  !(value & BXCAN_MSR_SLAK), BXCAN_TIMEOUT_US,\n\t\t\t\t  USEC_PER_SEC);\n}\n\nstatic inline\nstruct bxcan_priv *rx_offload_to_priv(struct can_rx_offload *offload)\n{\n\treturn container_of(offload, struct bxcan_priv, offload);\n}\n\nstatic struct sk_buff *bxcan_mailbox_read(struct can_rx_offload *offload,\n\t\t\t\t\t  unsigned int mbxno, u32 *timestamp,\n\t\t\t\t\t  bool drop)\n{\n\tstruct bxcan_priv *priv = rx_offload_to_priv(offload);\n\tstruct bxcan_regs __iomem *regs = priv->regs;\n\tstruct bxcan_mb __iomem *mb_regs = &regs->rx_mb[0];\n\tstruct sk_buff *skb = NULL;\n\tstruct can_frame *cf;\n\tu32 rf0r, id, dlc;\n\n\trf0r = readl(&regs->rf0r);\n\tif (unlikely(drop)) {\n\t\tskb = ERR_PTR(-ENOBUFS);\n\t\tgoto mark_as_read;\n\t}\n\n\tif (!(rf0r & BXCAN_RF0R_FMP0_MASK))\n\t\tgoto mark_as_read;\n\n\tskb = alloc_can_skb(offload->dev, &cf);\n\tif (unlikely(!skb)) {\n\t\tskb = ERR_PTR(-ENOMEM);\n\t\tgoto mark_as_read;\n\t}\n\n\tid = readl(&mb_regs->id);\n\tif (id & BXCAN_RIxR_IDE)\n\t\tcf->can_id = FIELD_GET(BXCAN_RIxR_EXID_MASK, id) | CAN_EFF_FLAG;\n\telse\n\t\tcf->can_id = FIELD_GET(BXCAN_RIxR_STID_MASK, id) & CAN_SFF_MASK;\n\n\tdlc = readl(&mb_regs->dlc);\n\tpriv->timestamp = FIELD_GET(BXCAN_RDTxR_TIME_MASK, dlc);\n\tcf->len = can_cc_dlc2len(FIELD_GET(BXCAN_RDTxR_DLC_MASK, dlc));\n\n\tif (id & BXCAN_RIxR_RTR) {\n\t\tcf->can_id |= CAN_RTR_FLAG;\n\t} else {\n\t\tint i, j;\n\n\t\tfor (i = 0, j = 0; i < cf->len; i += 4, j++)\n\t\t\t*(u32 *)(cf->data + i) = readl(&mb_regs->data[j]);\n\t}\n\n mark_as_read:\n\trf0r |= BXCAN_RF0R_RFOM0;\n\twritel(rf0r, &regs->rf0r);\n\treturn skb;\n}\n\nstatic irqreturn_t bxcan_rx_isr(int irq, void *dev_id)\n{\n\tstruct net_device *ndev = dev_id;\n\tstruct bxcan_priv *priv = netdev_priv(ndev);\n\tstruct bxcan_regs __iomem *regs = priv->regs;\n\tu32 rf0r;\n\n\trf0r = readl(&regs->rf0r);\n\tif (!(rf0r & BXCAN_RF0R_FMP0_MASK))\n\t\treturn IRQ_NONE;\n\n\tcan_rx_offload_irq_offload_fifo(&priv->offload);\n\tcan_rx_offload_irq_finish(&priv->offload);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t bxcan_tx_isr(int irq, void *dev_id)\n{\n\tstruct net_device *ndev = dev_id;\n\tstruct bxcan_priv *priv = netdev_priv(ndev);\n\tstruct bxcan_regs __iomem *regs = priv->regs;\n\tstruct net_device_stats *stats = &ndev->stats;\n\tu32 tsr, rqcp_bit;\n\tint idx;\n\n\ttsr = readl(&regs->tsr);\n\tif (!(tsr & (BXCAN_TSR_RQCP0 | BXCAN_TSR_RQCP1 | BXCAN_TSR_RQCP2)))\n\t\treturn IRQ_NONE;\n\n\twhile (priv->tx_head - priv->tx_tail > 0) {\n\t\tidx = bxcan_get_tx_tail(priv);\n\t\trqcp_bit = BXCAN_TSR_RQCP0 << (idx << 3);\n\t\tif (!(tsr & rqcp_bit))\n\t\t\tbreak;\n\n\t\tstats->tx_packets++;\n\t\tstats->tx_bytes += can_get_echo_skb(ndev, idx, NULL);\n\t\tpriv->tx_tail++;\n\t}\n\n\twritel(tsr, &regs->tsr);\n\n\tif (bxcan_get_tx_free(priv)) {\n\t\t \n\t\tsmp_mb();\n\t\tnetif_wake_queue(ndev);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void bxcan_handle_state_change(struct net_device *ndev, u32 esr)\n{\n\tstruct bxcan_priv *priv = netdev_priv(ndev);\n\tenum can_state new_state = priv->can.state;\n\tstruct can_berr_counter bec;\n\tenum can_state rx_state, tx_state;\n\tstruct sk_buff *skb;\n\tstruct can_frame *cf;\n\n\t \n\tif (!(esr & (BXCAN_ESR_EWGF | BXCAN_ESR_EPVF | BXCAN_ESR_BOFF)))\n\t\treturn;\n\n\tbec.txerr = FIELD_GET(BXCAN_ESR_TEC_MASK, esr);\n\tbec.rxerr = FIELD_GET(BXCAN_ESR_REC_MASK, esr);\n\n\tif (esr & BXCAN_ESR_BOFF)\n\t\tnew_state = CAN_STATE_BUS_OFF;\n\telse if (esr & BXCAN_ESR_EPVF)\n\t\tnew_state = CAN_STATE_ERROR_PASSIVE;\n\telse if (esr & BXCAN_ESR_EWGF)\n\t\tnew_state = CAN_STATE_ERROR_WARNING;\n\n\t \n\tif (unlikely(new_state == priv->can.state))\n\t\treturn;\n\n\tskb = alloc_can_err_skb(ndev, &cf);\n\n\ttx_state = bec.txerr >= bec.rxerr ? new_state : 0;\n\trx_state = bec.txerr <= bec.rxerr ? new_state : 0;\n\tcan_change_state(ndev, cf, tx_state, rx_state);\n\n\tif (new_state == CAN_STATE_BUS_OFF) {\n\t\tcan_bus_off(ndev);\n\t} else if (skb) {\n\t\tcf->can_id |= CAN_ERR_CNT;\n\t\tcf->data[6] = bec.txerr;\n\t\tcf->data[7] = bec.rxerr;\n\t}\n\n\tif (skb) {\n\t\tint err;\n\n\t\terr = can_rx_offload_queue_timestamp(&priv->offload, skb,\n\t\t\t\t\t\t     priv->timestamp);\n\t\tif (err)\n\t\t\tndev->stats.rx_fifo_errors++;\n\t}\n}\n\nstatic void bxcan_handle_bus_err(struct net_device *ndev, u32 esr)\n{\n\tstruct bxcan_priv *priv = netdev_priv(ndev);\n\tenum bxcan_lec_code lec_code;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\n\tlec_code = FIELD_GET(BXCAN_ESR_LEC_MASK, esr);\n\n\t \n\tif (lec_code == BXCAN_LEC_UNUSED || lec_code == BXCAN_LEC_NO_ERROR)\n\t\treturn;\n\n\t \n\tpriv->can.can_stats.bus_error++;\n\n\t \n\tskb = alloc_can_err_skb(ndev, &cf);\n\tif (skb)\n\t\tcf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\n\n\tswitch (lec_code) {\n\tcase BXCAN_LEC_STUFF_ERROR:\n\t\tnetdev_dbg(ndev, \"Stuff error\\n\");\n\t\tndev->stats.rx_errors++;\n\t\tif (skb)\n\t\t\tcf->data[2] |= CAN_ERR_PROT_STUFF;\n\t\tbreak;\n\n\tcase BXCAN_LEC_FORM_ERROR:\n\t\tnetdev_dbg(ndev, \"Form error\\n\");\n\t\tndev->stats.rx_errors++;\n\t\tif (skb)\n\t\t\tcf->data[2] |= CAN_ERR_PROT_FORM;\n\t\tbreak;\n\n\tcase BXCAN_LEC_ACK_ERROR:\n\t\tnetdev_dbg(ndev, \"Ack error\\n\");\n\t\tndev->stats.tx_errors++;\n\t\tif (skb) {\n\t\t\tcf->can_id |= CAN_ERR_ACK;\n\t\t\tcf->data[3] = CAN_ERR_PROT_LOC_ACK;\n\t\t}\n\t\tbreak;\n\n\tcase BXCAN_LEC_BIT1_ERROR:\n\t\tnetdev_dbg(ndev, \"Bit error (recessive)\\n\");\n\t\tndev->stats.tx_errors++;\n\t\tif (skb)\n\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT1;\n\t\tbreak;\n\n\tcase BXCAN_LEC_BIT0_ERROR:\n\t\tnetdev_dbg(ndev, \"Bit error (dominant)\\n\");\n\t\tndev->stats.tx_errors++;\n\t\tif (skb)\n\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT0;\n\t\tbreak;\n\n\tcase BXCAN_LEC_CRC_ERROR:\n\t\tnetdev_dbg(ndev, \"CRC error\\n\");\n\t\tndev->stats.rx_errors++;\n\t\tif (skb) {\n\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT;\n\t\t\tcf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (skb) {\n\t\tint err;\n\n\t\terr = can_rx_offload_queue_timestamp(&priv->offload, skb,\n\t\t\t\t\t\t     priv->timestamp);\n\t\tif (err)\n\t\t\tndev->stats.rx_fifo_errors++;\n\t}\n}\n\nstatic irqreturn_t bxcan_state_change_isr(int irq, void *dev_id)\n{\n\tstruct net_device *ndev = dev_id;\n\tstruct bxcan_priv *priv = netdev_priv(ndev);\n\tstruct bxcan_regs __iomem *regs = priv->regs;\n\tu32 msr, esr;\n\n\tmsr = readl(&regs->msr);\n\tif (!(msr & BXCAN_MSR_ERRI))\n\t\treturn IRQ_NONE;\n\n\tesr = readl(&regs->esr);\n\tbxcan_handle_state_change(ndev, esr);\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING)\n\t\tbxcan_handle_bus_err(ndev, esr);\n\n\tmsr |= BXCAN_MSR_ERRI;\n\twritel(msr, &regs->msr);\n\tcan_rx_offload_irq_finish(&priv->offload);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bxcan_chip_start(struct net_device *ndev)\n{\n\tstruct bxcan_priv *priv = netdev_priv(ndev);\n\tstruct bxcan_regs __iomem *regs = priv->regs;\n\tstruct can_bittiming *bt = &priv->can.bittiming;\n\tu32 clr, set;\n\tint err;\n\n\terr = bxcan_chip_softreset(priv);\n\tif (err) {\n\t\tnetdev_err(ndev, \"failed to reset chip, error %pe\\n\",\n\t\t\t   ERR_PTR(err));\n\t\treturn err;\n\t}\n\n\terr = bxcan_leave_sleep_mode(priv);\n\tif (err) {\n\t\tnetdev_err(ndev, \"failed to leave sleep mode, error %pe\\n\",\n\t\t\t   ERR_PTR(err));\n\t\tgoto failed_leave_sleep;\n\t}\n\n\terr = bxcan_enter_init_mode(priv);\n\tif (err) {\n\t\tnetdev_err(ndev, \"failed to enter init mode, error %pe\\n\",\n\t\t\t   ERR_PTR(err));\n\t\tgoto failed_enter_init;\n\t}\n\n\t \n\tbxcan_rmw(priv, &regs->mcr,\n\t\t  BXCAN_MCR_ABOM | BXCAN_MCR_AWUM | BXCAN_MCR_NART |\n\t\t  BXCAN_MCR_RFLM, BXCAN_MCR_TTCM | BXCAN_MCR_TXFP);\n\n\t \n\tset = FIELD_PREP(BXCAN_BTR_BRP_MASK, bt->brp - 1) |\n\t\tFIELD_PREP(BXCAN_BTR_TS1_MASK, bt->phase_seg1 +\n\t\t\t   bt->prop_seg - 1) |\n\t\tFIELD_PREP(BXCAN_BTR_TS2_MASK, bt->phase_seg2 - 1) |\n\t\tFIELD_PREP(BXCAN_BTR_SJW_MASK, bt->sjw - 1);\n\n\t \n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\tset |= BXCAN_BTR_LBKM;\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tset |= BXCAN_BTR_SILM;\n\n\tbxcan_rmw(priv, &regs->btr, BXCAN_BTR_SILM | BXCAN_BTR_LBKM |\n\t\t  BXCAN_BTR_BRP_MASK | BXCAN_BTR_TS1_MASK | BXCAN_BTR_TS2_MASK |\n\t\t  BXCAN_BTR_SJW_MASK, set);\n\n\tbxcan_enable_filters(priv, priv->cfg);\n\n\t \n\tpriv->tx_head = 0;\n\tpriv->tx_tail = 0;\n\n\terr = bxcan_leave_init_mode(priv);\n\tif (err) {\n\t\tnetdev_err(ndev, \"failed to leave init mode, error %pe\\n\",\n\t\t\t   ERR_PTR(err));\n\t\tgoto failed_leave_init;\n\t}\n\n\t \n\tbxcan_rmw(priv, &regs->esr, BXCAN_ESR_LEC_MASK,\n\t\t  FIELD_PREP(BXCAN_ESR_LEC_MASK, BXCAN_LEC_UNUSED));\n\n\t \n\tclr = BXCAN_IER_WKUIE | BXCAN_IER_SLKIE |  BXCAN_IER_FOVIE1 |\n\t\tBXCAN_IER_FFIE1 | BXCAN_IER_FMPIE1 | BXCAN_IER_FOVIE0 |\n\t\tBXCAN_IER_FFIE0;\n\tset = BXCAN_IER_ERRIE | BXCAN_IER_BOFIE | BXCAN_IER_EPVIE |\n\t\tBXCAN_IER_EWGIE | BXCAN_IER_FMPIE0 | BXCAN_IER_TMEIE;\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING)\n\t\tset |= BXCAN_IER_LECIE;\n\telse\n\t\tclr |= BXCAN_IER_LECIE;\n\n\tbxcan_rmw(priv, &regs->ier, clr, set);\n\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\treturn 0;\n\nfailed_leave_init:\nfailed_enter_init:\nfailed_leave_sleep:\n\tbxcan_chip_softreset(priv);\n\treturn err;\n}\n\nstatic int bxcan_open(struct net_device *ndev)\n{\n\tstruct bxcan_priv *priv = netdev_priv(ndev);\n\tint err;\n\n\terr = clk_prepare_enable(priv->clk);\n\tif (err) {\n\t\tnetdev_err(ndev, \"failed to enable clock, error %pe\\n\",\n\t\t\t   ERR_PTR(err));\n\t\treturn err;\n\t}\n\n\terr = open_candev(ndev);\n\tif (err) {\n\t\tnetdev_err(ndev, \"open_candev() failed, error %pe\\n\",\n\t\t\t   ERR_PTR(err));\n\t\tgoto out_disable_clock;\n\t}\n\n\tcan_rx_offload_enable(&priv->offload);\n\terr = request_irq(ndev->irq, bxcan_rx_isr, IRQF_SHARED, ndev->name,\n\t\t\t  ndev);\n\tif (err) {\n\t\tnetdev_err(ndev, \"failed to register rx irq(%d), error %pe\\n\",\n\t\t\t   ndev->irq, ERR_PTR(err));\n\t\tgoto out_close_candev;\n\t}\n\n\terr = request_irq(priv->tx_irq, bxcan_tx_isr, IRQF_SHARED, ndev->name,\n\t\t\t  ndev);\n\tif (err) {\n\t\tnetdev_err(ndev, \"failed to register tx irq(%d), error %pe\\n\",\n\t\t\t   priv->tx_irq, ERR_PTR(err));\n\t\tgoto out_free_rx_irq;\n\t}\n\n\terr = request_irq(priv->sce_irq, bxcan_state_change_isr, IRQF_SHARED,\n\t\t\t  ndev->name, ndev);\n\tif (err) {\n\t\tnetdev_err(ndev, \"failed to register sce irq(%d), error %pe\\n\",\n\t\t\t   priv->sce_irq, ERR_PTR(err));\n\t\tgoto out_free_tx_irq;\n\t}\n\n\terr = bxcan_chip_start(ndev);\n\tif (err)\n\t\tgoto out_free_sce_irq;\n\n\tnetif_start_queue(ndev);\n\treturn 0;\n\nout_free_sce_irq:\n\tfree_irq(priv->sce_irq, ndev);\nout_free_tx_irq:\n\tfree_irq(priv->tx_irq, ndev);\nout_free_rx_irq:\n\tfree_irq(ndev->irq, ndev);\nout_close_candev:\n\tcan_rx_offload_disable(&priv->offload);\n\tclose_candev(ndev);\nout_disable_clock:\n\tclk_disable_unprepare(priv->clk);\n\treturn err;\n}\n\nstatic void bxcan_chip_stop(struct net_device *ndev)\n{\n\tstruct bxcan_priv *priv = netdev_priv(ndev);\n\tstruct bxcan_regs __iomem *regs = priv->regs;\n\n\t \n\tbxcan_rmw(priv, &regs->ier, BXCAN_IER_SLKIE | BXCAN_IER_WKUIE |\n\t\t  BXCAN_IER_ERRIE | BXCAN_IER_LECIE | BXCAN_IER_BOFIE |\n\t\t  BXCAN_IER_EPVIE | BXCAN_IER_EWGIE | BXCAN_IER_FOVIE1 |\n\t\t  BXCAN_IER_FFIE1 | BXCAN_IER_FMPIE1 | BXCAN_IER_FOVIE0 |\n\t\t  BXCAN_IER_FFIE0 | BXCAN_IER_FMPIE0 | BXCAN_IER_TMEIE, 0);\n\tbxcan_disable_filters(priv, priv->cfg);\n\tbxcan_enter_sleep_mode(priv);\n\tpriv->can.state = CAN_STATE_STOPPED;\n}\n\nstatic int bxcan_stop(struct net_device *ndev)\n{\n\tstruct bxcan_priv *priv = netdev_priv(ndev);\n\n\tnetif_stop_queue(ndev);\n\tbxcan_chip_stop(ndev);\n\tfree_irq(ndev->irq, ndev);\n\tfree_irq(priv->tx_irq, ndev);\n\tfree_irq(priv->sce_irq, ndev);\n\tcan_rx_offload_disable(&priv->offload);\n\tclose_candev(ndev);\n\tclk_disable_unprepare(priv->clk);\n\treturn 0;\n}\n\nstatic netdev_tx_t bxcan_start_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *ndev)\n{\n\tstruct bxcan_priv *priv = netdev_priv(ndev);\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct bxcan_regs __iomem *regs = priv->regs;\n\tstruct bxcan_mb __iomem *mb_regs;\n\tunsigned int idx;\n\tu32 id;\n\tint i, j;\n\n\tif (can_dropped_invalid_skb(ndev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tif (bxcan_tx_busy(priv))\n\t\treturn NETDEV_TX_BUSY;\n\n\tidx = bxcan_get_tx_head(priv);\n\tpriv->tx_head++;\n\tif (bxcan_get_tx_free(priv) == 0)\n\t\tnetif_stop_queue(ndev);\n\n\tmb_regs = &regs->tx_mb[idx];\n\tif (cf->can_id & CAN_EFF_FLAG)\n\t\tid = FIELD_PREP(BXCAN_TIxR_EXID_MASK, cf->can_id) |\n\t\t\tBXCAN_TIxR_IDE;\n\telse\n\t\tid = FIELD_PREP(BXCAN_TIxR_STID_MASK, cf->can_id);\n\n\tif (cf->can_id & CAN_RTR_FLAG) {  \n\t\tid |= BXCAN_TIxR_RTR;\n\t} else {\n\t\tfor (i = 0, j = 0; i < cf->len; i += 4, j++)\n\t\t\twritel(*(u32 *)(cf->data + i), &mb_regs->data[j]);\n\t}\n\n\twritel(FIELD_PREP(BXCAN_TDTxR_DLC_MASK, cf->len), &mb_regs->dlc);\n\n\tcan_put_echo_skb(skb, ndev, idx, 0);\n\n\t \n\twritel(id | BXCAN_TIxR_TXRQ, &mb_regs->id);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic const struct net_device_ops bxcan_netdev_ops = {\n\t.ndo_open = bxcan_open,\n\t.ndo_stop = bxcan_stop,\n\t.ndo_start_xmit = bxcan_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic const struct ethtool_ops bxcan_ethtool_ops = {\n\t.get_ts_info = ethtool_op_get_ts_info,\n};\n\nstatic int bxcan_do_set_mode(struct net_device *ndev, enum can_mode mode)\n{\n\tint err;\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\terr = bxcan_chip_start(ndev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tnetif_wake_queue(ndev);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int bxcan_get_berr_counter(const struct net_device *ndev,\n\t\t\t\t  struct can_berr_counter *bec)\n{\n\tstruct bxcan_priv *priv = netdev_priv(ndev);\n\tstruct bxcan_regs __iomem *regs = priv->regs;\n\tu32 esr;\n\tint err;\n\n\terr = clk_prepare_enable(priv->clk);\n\tif (err)\n\t\treturn err;\n\n\tesr = readl(&regs->esr);\n\tbec->txerr = FIELD_GET(BXCAN_ESR_TEC_MASK, esr);\n\tbec->rxerr = FIELD_GET(BXCAN_ESR_REC_MASK, esr);\n\tclk_disable_unprepare(priv->clk);\n\treturn 0;\n}\n\nstatic int bxcan_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\tstruct net_device *ndev;\n\tstruct bxcan_priv *priv;\n\tstruct clk *clk = NULL;\n\tvoid __iomem *regs;\n\tstruct regmap *gcan;\n\tenum bxcan_cfg cfg;\n\tint err, rx_irq, tx_irq, sce_irq;\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs)) {\n\t\tdev_err(dev, \"failed to get base address\\n\");\n\t\treturn PTR_ERR(regs);\n\t}\n\n\tgcan = syscon_regmap_lookup_by_phandle(np, \"st,gcan\");\n\tif (IS_ERR(gcan)) {\n\t\tdev_err(dev, \"failed to get shared memory base address\\n\");\n\t\treturn PTR_ERR(gcan);\n\t}\n\n\tif (of_property_read_bool(np, \"st,can-primary\"))\n\t\tcfg = BXCAN_CFG_DUAL_PRIMARY;\n\telse if (of_property_read_bool(np, \"st,can-secondary\"))\n\t\tcfg = BXCAN_CFG_DUAL_SECONDARY;\n\telse\n\t\tcfg = BXCAN_CFG_SINGLE;\n\n\tclk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(dev, \"failed to get clock\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\trx_irq = platform_get_irq_byname(pdev, \"rx0\");\n\tif (rx_irq < 0)\n\t\treturn rx_irq;\n\n\ttx_irq = platform_get_irq_byname(pdev, \"tx\");\n\tif (tx_irq < 0)\n\t\treturn tx_irq;\n\n\tsce_irq = platform_get_irq_byname(pdev, \"sce\");\n\tif (sce_irq < 0)\n\t\treturn sce_irq;\n\n\tndev = alloc_candev(sizeof(struct bxcan_priv), BXCAN_TX_MB_NUM);\n\tif (!ndev) {\n\t\tdev_err(dev, \"alloc_candev() failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv = netdev_priv(ndev);\n\tplatform_set_drvdata(pdev, ndev);\n\tSET_NETDEV_DEV(ndev, dev);\n\tndev->netdev_ops = &bxcan_netdev_ops;\n\tndev->ethtool_ops = &bxcan_ethtool_ops;\n\tndev->irq = rx_irq;\n\tndev->flags |= IFF_ECHO;\n\n\tpriv->dev = dev;\n\tpriv->ndev = ndev;\n\tpriv->regs = regs;\n\tpriv->gcan = gcan;\n\tpriv->clk = clk;\n\tpriv->tx_irq = tx_irq;\n\tpriv->sce_irq = sce_irq;\n\tpriv->cfg = cfg;\n\tpriv->can.clock.freq = clk_get_rate(clk);\n\tspin_lock_init(&priv->rmw_lock);\n\tpriv->tx_head = 0;\n\tpriv->tx_tail = 0;\n\tpriv->can.bittiming_const = &bxcan_bittiming_const;\n\tpriv->can.do_set_mode = bxcan_do_set_mode;\n\tpriv->can.do_get_berr_counter = bxcan_get_berr_counter;\n\tpriv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |\n\t\tCAN_CTRLMODE_LISTENONLY\t| CAN_CTRLMODE_BERR_REPORTING;\n\n\tpriv->offload.mailbox_read = bxcan_mailbox_read;\n\terr = can_rx_offload_add_fifo(ndev, &priv->offload, BXCAN_NAPI_WEIGHT);\n\tif (err) {\n\t\tdev_err(dev, \"failed to add FIFO rx_offload\\n\");\n\t\tgoto out_free_candev;\n\t}\n\n\terr = register_candev(ndev);\n\tif (err) {\n\t\tdev_err(dev, \"failed to register netdev\\n\");\n\t\tgoto out_can_rx_offload_del;\n\t}\n\n\tdev_info(dev, \"clk: %d Hz, IRQs: %d, %d, %d\\n\", priv->can.clock.freq,\n\t\t tx_irq, rx_irq, sce_irq);\n\treturn 0;\n\nout_can_rx_offload_del:\n\tcan_rx_offload_del(&priv->offload);\nout_free_candev:\n\tfree_candev(ndev);\n\treturn err;\n}\n\nstatic void bxcan_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct bxcan_priv *priv = netdev_priv(ndev);\n\n\tunregister_candev(ndev);\n\tclk_disable_unprepare(priv->clk);\n\tcan_rx_offload_del(&priv->offload);\n\tfree_candev(ndev);\n}\n\nstatic int __maybe_unused bxcan_suspend(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct bxcan_priv *priv = netdev_priv(ndev);\n\n\tif (!netif_running(ndev))\n\t\treturn 0;\n\n\tnetif_stop_queue(ndev);\n\tnetif_device_detach(ndev);\n\n\tbxcan_enter_sleep_mode(priv);\n\tpriv->can.state = CAN_STATE_SLEEPING;\n\tclk_disable_unprepare(priv->clk);\n\treturn 0;\n}\n\nstatic int __maybe_unused bxcan_resume(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct bxcan_priv *priv = netdev_priv(ndev);\n\n\tif (!netif_running(ndev))\n\t\treturn 0;\n\n\tclk_prepare_enable(priv->clk);\n\tbxcan_leave_sleep_mode(priv);\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\tnetif_device_attach(ndev);\n\tnetif_start_queue(ndev);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(bxcan_pm_ops, bxcan_suspend, bxcan_resume);\n\nstatic const struct of_device_id bxcan_of_match[] = {\n\t{.compatible = \"st,stm32f4-bxcan\"},\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, bxcan_of_match);\n\nstatic struct platform_driver bxcan_driver = {\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.pm = &bxcan_pm_ops,\n\t\t.of_match_table = bxcan_of_match,\n\t},\n\t.probe = bxcan_probe,\n\t.remove_new = bxcan_remove,\n};\n\nmodule_platform_driver(bxcan_driver);\n\nMODULE_AUTHOR(\"Dario Binacchi <dario.binacchi@amarulasolutions.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics Basic Extended CAN controller driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}