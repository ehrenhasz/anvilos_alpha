{
  "module_name": "peak_pcmcia.c",
  "hash_id": "8a6a48b70b212214fb148886e834b6d548fce5fd2d1161aa046893c351261c80",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/sja1000/peak_pcmcia.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/delay.h>\n#include <linux/timer.h>\n#include <linux/io.h>\n#include <pcmcia/cistpl.h>\n#include <pcmcia/ds.h>\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include \"sja1000.h\"\n\nMODULE_AUTHOR(\"Stephane Grosjean <s.grosjean@peak-system.com>\");\nMODULE_DESCRIPTION(\"CAN driver for PEAK-System PCAN-PC Cards\");\nMODULE_LICENSE(\"GPL v2\");\n\n \n#define PCC_NAME\t\t\"peak_pcmcia\"\n\n#define PCC_CHAN_MAX\t\t2\n\n#define PCC_CAN_CLOCK\t\t(16000000 / 2)\n\n#define PCC_MANF_ID\t\t0x0377\n#define PCC_CARD_ID\t\t0x0001\n\n#define PCC_CHAN_SIZE\t\t0x20\n#define PCC_CHAN_OFF(c)\t\t((c) * PCC_CHAN_SIZE)\n#define PCC_COMN_OFF\t\t(PCC_CHAN_OFF(PCC_CHAN_MAX))\n#define PCC_COMN_SIZE\t\t0x40\n\n \n#define PCC_CCR\t\t\t0x00\n#define PCC_CSR\t\t\t0x02\n#define PCC_CPR\t\t\t0x04\n#define PCC_SPI_DIR\t\t0x06\n#define PCC_SPI_DOR\t\t0x08\n#define PCC_SPI_ADR\t\t0x0a\n#define PCC_SPI_IR\t\t0x0c\n#define PCC_FW_MAJOR\t\t0x10\n#define PCC_FW_MINOR\t\t0x12\n\n \n#define PCC_CCR_CLK_16\t\t0x00\n#define PCC_CCR_CLK_10\t\t0x01\n#define PCC_CCR_CLK_21\t\t0x02\n#define PCC_CCR_CLK_8\t\t0x03\n#define PCC_CCR_CLK_MASK\tPCC_CCR_CLK_8\n\n#define PCC_CCR_RST_CHAN(c)\t(0x01 << ((c) + 2))\n#define PCC_CCR_RST_ALL\t\t(PCC_CCR_RST_CHAN(0) | PCC_CCR_RST_CHAN(1))\n#define PCC_CCR_RST_MASK\tPCC_CCR_RST_ALL\n\n \n#define PCC_LED(c)\t\t(1 << (c))\n#define PCC_LED_ALL\t\t(PCC_LED(0) | PCC_LED(1))\n\n \n#define PCC_LED_ON\t\t0x00\n#define PCC_LED_FAST\t\t0x01\n#define PCC_LED_SLOW\t\t0x02\n#define PCC_LED_OFF\t\t0x03\n\n#define PCC_CCR_LED_CHAN(s, c)\t((s) << (((c) + 2) << 1))\n\n#define PCC_CCR_LED_ON_CHAN(c)\t\tPCC_CCR_LED_CHAN(PCC_LED_ON, c)\n#define PCC_CCR_LED_FAST_CHAN(c)\tPCC_CCR_LED_CHAN(PCC_LED_FAST, c)\n#define PCC_CCR_LED_SLOW_CHAN(c)\tPCC_CCR_LED_CHAN(PCC_LED_SLOW, c)\n#define PCC_CCR_LED_OFF_CHAN(c)\t\tPCC_CCR_LED_CHAN(PCC_LED_OFF, c)\n#define PCC_CCR_LED_MASK_CHAN(c)\tPCC_CCR_LED_OFF_CHAN(c)\n#define PCC_CCR_LED_OFF_ALL\t\t(PCC_CCR_LED_OFF_CHAN(0) | \\\n\t\t\t\t\t PCC_CCR_LED_OFF_CHAN(1))\n#define PCC_CCR_LED_MASK\t\tPCC_CCR_LED_OFF_ALL\n\n#define PCC_CCR_INIT\t(PCC_CCR_CLK_16 | PCC_CCR_RST_ALL | PCC_CCR_LED_OFF_ALL)\n\n \n#define PCC_CSR_SPI_BUSY\t\t0x04\n\n \n#define PCC_SPI_MAX_BUSY_WAIT_MS\t3\n\n \n \n#define PCC_WRITE_MAX_LOOP\t\t1000\n\n \n#define PCC_ISR_MAX_LOOP\t\t10\n\n \n \n#define PCC_EEP_WRITE(a)\t(0x02 | (((a) & 0x100) >> 5))\n#define PCC_EEP_READ(a)\t\t(0x03 | (((a) & 0x100) >> 5))\n#define PCC_EEP_WRDI\t\t0x04\t \n#define PCC_EEP_RDSR\t\t0x05\t \n#define PCC_EEP_WREN\t\t0x06\t \n\n \n#define PCC_EEP_SR_WEN\t\t0x02\t \n#define PCC_EEP_SR_WIP\t\t0x01\t \n\n \n#define PCC_OCR\t\t\t(OCR_TX0_PUSHPULL | OCR_TX1_PUSHPULL)\n\n \n#define PCC_CDR\t\t\t(CDR_CBP | CDR_CLKOUT_MASK)\n\nstruct pcan_channel {\n\tstruct net_device *netdev;\n\tunsigned long prev_rx_bytes;\n\tunsigned long prev_tx_bytes;\n};\n\n \nstruct pcan_pccard {\n\tstruct pcmcia_device *pdev;\n\tint chan_count;\n\tstruct pcan_channel channel[PCC_CHAN_MAX];\n\tu8 ccr;\n\tu8 fw_major;\n\tu8 fw_minor;\n\tvoid __iomem *ioport_addr;\n\tstruct timer_list led_timer;\n};\n\nstatic struct pcmcia_device_id pcan_table[] = {\n\tPCMCIA_DEVICE_MANF_CARD(PCC_MANF_ID, PCC_CARD_ID),\n\tPCMCIA_DEVICE_NULL,\n};\n\nMODULE_DEVICE_TABLE(pcmcia, pcan_table);\n\nstatic void pcan_set_leds(struct pcan_pccard *card, u8 mask, u8 state);\n\n \nstatic void pcan_start_led_timer(struct pcan_pccard *card)\n{\n\tif (!timer_pending(&card->led_timer))\n\t\tmod_timer(&card->led_timer, jiffies + HZ);\n}\n\n \nstatic void pcan_stop_led_timer(struct pcan_pccard *card)\n{\n\tdel_timer_sync(&card->led_timer);\n}\n\n \nstatic u8 pcan_read_canreg(const struct sja1000_priv *priv, int port)\n{\n\treturn ioread8(priv->reg_base + port);\n}\n\n \nstatic void pcan_write_canreg(const struct sja1000_priv *priv, int port, u8 v)\n{\n\tstruct pcan_pccard *card = priv->priv;\n\tint c = (priv->reg_base - card->ioport_addr) / PCC_CHAN_SIZE;\n\n\t \n\tif (port == SJA1000_MOD)\n\t\tswitch (v) {\n\t\tcase MOD_RM:\n\t\t\t \n\t\t\tpcan_set_leds(card, PCC_LED(c), PCC_LED_ON);\n\t\t\tbreak;\n\t\tcase 0x00:\n\t\t\t \n\t\t\tpcan_set_leds(card, PCC_LED(c), PCC_LED_SLOW);\n\t\t\tpcan_start_led_timer(card);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\tiowrite8(v, priv->reg_base + port);\n}\n\n \nstatic u8 pcan_read_reg(struct pcan_pccard *card, int port)\n{\n\treturn ioread8(card->ioport_addr + PCC_COMN_OFF + port);\n}\n\n \nstatic void pcan_write_reg(struct pcan_pccard *card, int port, u8 v)\n{\n\t \n\tif (port == PCC_CCR) {\n\t\tif (card->ccr == v)\n\t\t\treturn;\n\t\tcard->ccr = v;\n\t}\n\n\tiowrite8(v, card->ioport_addr + PCC_COMN_OFF + port);\n}\n\n \nstatic inline int pcan_pccard_present(struct pcan_pccard *card)\n{\n\treturn ((pcan_read_reg(card, PCC_FW_MAJOR) == card->fw_major) &&\n\t\t(pcan_read_reg(card, PCC_FW_MINOR) == card->fw_minor));\n}\n\n \nstatic int pcan_wait_spi_busy(struct pcan_pccard *card)\n{\n\tunsigned long timeout = jiffies +\n\t\t\t\tmsecs_to_jiffies(PCC_SPI_MAX_BUSY_WAIT_MS) + 1;\n\n\t \n\twhile (pcan_read_reg(card, PCC_CSR) & PCC_CSR_SPI_BUSY) {\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -EBUSY;\n\t\tschedule();\n\t}\n\n\treturn 0;\n}\n\n \nstatic int pcan_write_eeprom(struct pcan_pccard *card, u16 addr, u8 v)\n{\n\tu8 status;\n\tint err, i;\n\n\t \n\tpcan_write_reg(card, PCC_SPI_IR, PCC_EEP_WREN);\n\terr = pcan_wait_spi_busy(card);\n\tif (err)\n\t\tgoto we_spi_err;\n\n\t \n\tfor (i = 0; i < PCC_WRITE_MAX_LOOP; i++) {\n\t\t \n\t\tpcan_write_reg(card, PCC_SPI_IR, PCC_EEP_RDSR);\n\t\terr = pcan_wait_spi_busy(card);\n\t\tif (err)\n\t\t\tgoto we_spi_err;\n\n\t\t \n\t\tstatus = pcan_read_reg(card, PCC_SPI_DIR);\n\t\tif (status & PCC_EEP_SR_WEN)\n\t\t\tbreak;\n\t}\n\n\tif (i >= PCC_WRITE_MAX_LOOP) {\n\t\tdev_err(&card->pdev->dev,\n\t\t\t\"stop waiting to be allowed to write in eeprom\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tpcan_write_reg(card, PCC_SPI_ADR, addr & 0xff);\n\tpcan_write_reg(card, PCC_SPI_DOR, v);\n\n\t \n\tpcan_write_reg(card, PCC_SPI_IR, PCC_EEP_WRITE(addr));\n\terr = pcan_wait_spi_busy(card);\n\tif (err)\n\t\tgoto we_spi_err;\n\n\t \n\tfor (i = 0; i < PCC_WRITE_MAX_LOOP; i++) {\n\t\t \n\t\tpcan_write_reg(card, PCC_SPI_IR, PCC_EEP_RDSR);\n\t\terr = pcan_wait_spi_busy(card);\n\t\tif (err)\n\t\t\tgoto we_spi_err;\n\n\t\t \n\t\tstatus = pcan_read_reg(card, PCC_SPI_DIR);\n\t\tif (!(status & PCC_EEP_SR_WIP))\n\t\t\tbreak;\n\t}\n\n\tif (i >= PCC_WRITE_MAX_LOOP) {\n\t\tdev_err(&card->pdev->dev,\n\t\t\t\"stop waiting for write in eeprom to complete\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tpcan_write_reg(card, PCC_SPI_IR, PCC_EEP_WRDI);\n\terr = pcan_wait_spi_busy(card);\n\tif (err)\n\t\tgoto we_spi_err;\n\n\treturn 0;\n\nwe_spi_err:\n\tdev_err(&card->pdev->dev,\n\t\t\"stop waiting (spi engine always busy) err %d\\n\", err);\n\n\treturn err;\n}\n\nstatic void pcan_set_leds(struct pcan_pccard *card, u8 led_mask, u8 state)\n{\n\tu8 ccr = card->ccr;\n\tint i;\n\n\tfor (i = 0; i < card->chan_count; i++)\n\t\tif (led_mask & PCC_LED(i)) {\n\t\t\t \n\t\t\tccr &= ~PCC_CCR_LED_MASK_CHAN(i);\n\t\t\t \n\t\t\tccr |= PCC_CCR_LED_CHAN(state, i);\n\t\t}\n\n\t \n\tpcan_write_reg(card, PCC_CCR, ccr);\n}\n\n \nstatic inline void pcan_set_can_power(struct pcan_pccard *card, int onoff)\n{\n\tint err;\n\n\terr = pcan_write_eeprom(card, 0, !!onoff);\n\tif (err)\n\t\tdev_err(&card->pdev->dev,\n\t\t\t\"failed setting power %s to can connectors (err %d)\\n\",\n\t\t\t(onoff) ? \"on\" : \"off\", err);\n}\n\n \nstatic void pcan_led_timer(struct timer_list *t)\n{\n\tstruct pcan_pccard *card = from_timer(card, t, led_timer);\n\tstruct net_device *netdev;\n\tint i, up_count = 0;\n\tu8 ccr;\n\n\tccr = card->ccr;\n\tfor (i = 0; i < card->chan_count; i++) {\n\t\t \n\t\tccr &= ~PCC_CCR_LED_MASK_CHAN(i);\n\t\tccr |= PCC_CCR_LED_ON_CHAN(i);\n\n\t\tnetdev = card->channel[i].netdev;\n\t\tif (!netdev || !(netdev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tup_count++;\n\n\t\t \n\t\tccr &= ~PCC_CCR_LED_MASK_CHAN(i);\n\t\tccr |= PCC_CCR_LED_SLOW_CHAN(i);\n\n\t\t \n\t\tif (netdev->stats.rx_bytes != card->channel[i].prev_rx_bytes) {\n\t\t\tcard->channel[i].prev_rx_bytes = netdev->stats.rx_bytes;\n\t\t\tccr &= ~PCC_CCR_LED_MASK_CHAN(i);\n\t\t\tccr |= PCC_CCR_LED_FAST_CHAN(i);\n\t\t}\n\t\tif (netdev->stats.tx_bytes != card->channel[i].prev_tx_bytes) {\n\t\t\tcard->channel[i].prev_tx_bytes = netdev->stats.tx_bytes;\n\t\t\tccr &= ~PCC_CCR_LED_MASK_CHAN(i);\n\t\t\tccr |= PCC_CCR_LED_FAST_CHAN(i);\n\t\t}\n\t}\n\n\t \n\tpcan_write_reg(card, PCC_CCR, ccr);\n\n\t \n\tif (up_count)\n\t\tmod_timer(&card->led_timer, jiffies + HZ);\n}\n\n \nstatic irqreturn_t pcan_isr(int irq, void *dev_id)\n{\n\tstruct pcan_pccard *card = dev_id;\n\tint irq_handled;\n\n\t \n\tfor (irq_handled = 0; irq_handled < PCC_ISR_MAX_LOOP; irq_handled++) {\n\t\t \n\t\tint nothing_to_handle = 1;\n\t\tint i;\n\n\t\t \n\t\tfor (i = 0; i < card->chan_count; i++) {\n\t\t\tstruct net_device *netdev;\n\n\t\t\t \n\t\t\tif (!pcan_pccard_present(card)) {\n\t\t\t\t \n\t\t\t\treturn IRQ_NONE;\n\t\t\t}\n\n\t\t\t \n\t\t\tnetdev = card->channel[i].netdev;\n\t\t\tif (netdev &&\n\t\t\t    sja1000_interrupt(irq, netdev) == IRQ_HANDLED)\n\t\t\t\tnothing_to_handle = 0;\n\t\t}\n\n\t\tif (nothing_to_handle)\n\t\t\tbreak;\n\t}\n\n\treturn (irq_handled) ? IRQ_HANDLED : IRQ_NONE;\n}\n\n \nstatic void pcan_free_channels(struct pcan_pccard *card)\n{\n\tint i;\n\tu8 led_mask = 0;\n\n\tfor (i = 0; i < card->chan_count; i++) {\n\t\tstruct net_device *netdev;\n\t\tchar name[IFNAMSIZ];\n\n\t\tled_mask |= PCC_LED(i);\n\n\t\tnetdev = card->channel[i].netdev;\n\t\tif (!netdev)\n\t\t\tcontinue;\n\n\t\tstrscpy(name, netdev->name, IFNAMSIZ);\n\n\t\tunregister_sja1000dev(netdev);\n\n\t\tfree_sja1000dev(netdev);\n\n\t\tdev_info(&card->pdev->dev, \"%s removed\\n\", name);\n\t}\n\n\t \n\tif (pcan_pccard_present(card)) {\n\t\tpcan_set_leds(card, led_mask, PCC_LED_OFF);\n\t\tpcan_set_can_power(card, 0);\n\t}\n}\n\n \nstatic inline int pcan_channel_present(struct sja1000_priv *priv)\n{\n\t \n\tpcan_write_canreg(priv, SJA1000_MOD, 1);\n\tpcan_write_canreg(priv, SJA1000_CDR, CDR_PELICAN);\n\n\t \n\tif (pcan_read_canreg(priv, SJA1000_CDR) == CDR_PELICAN)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int pcan_add_channels(struct pcan_pccard *card)\n{\n\tstruct pcmcia_device *pdev = card->pdev;\n\tint i, err = 0;\n\tu8 ccr = PCC_CCR_INIT;\n\n\t \n\tcard->ccr = ~ccr;\n\tpcan_write_reg(card, PCC_CCR, ccr);\n\n\t \n\tusleep_range(2000, 3000);\n\n\tccr &= ~PCC_CCR_RST_ALL;\n\tpcan_write_reg(card, PCC_CCR, ccr);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(card->channel); i++) {\n\t\tstruct net_device *netdev;\n\t\tstruct sja1000_priv *priv;\n\n\t\tnetdev = alloc_sja1000dev(0);\n\t\tif (!netdev) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tpriv = netdev_priv(netdev);\n\t\tpriv->priv = card;\n\t\tSET_NETDEV_DEV(netdev, &pdev->dev);\n\t\tnetdev->dev_id = i;\n\n\t\tpriv->irq_flags = IRQF_SHARED;\n\t\tnetdev->irq = pdev->irq;\n\t\tpriv->reg_base = card->ioport_addr + PCC_CHAN_OFF(i);\n\n\t\t \n\t\tif (!pcan_channel_present(priv)) {\n\t\t\tdev_err(&pdev->dev, \"channel %d not present\\n\", i);\n\t\t\tfree_sja1000dev(netdev);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpriv->read_reg  = pcan_read_canreg;\n\t\tpriv->write_reg = pcan_write_canreg;\n\t\tpriv->can.clock.freq = PCC_CAN_CLOCK;\n\t\tpriv->ocr = PCC_OCR;\n\t\tpriv->cdr = PCC_CDR;\n\n\t\t \n\t\tif (i > 0)\n\t\t\tpriv->cdr |= CDR_CLK_OFF;\n\n\t\tpriv->flags |= SJA1000_CUSTOM_IRQ_HANDLER;\n\n\t\t \n\t\terr = register_sja1000dev(netdev);\n\t\tif (err) {\n\t\t\tfree_sja1000dev(netdev);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcard->channel[i].netdev = netdev;\n\t\tcard->chan_count++;\n\n\t\t \n\t\tccr &= ~PCC_CCR_LED_OFF_CHAN(i);\n\n\t\tdev_info(&pdev->dev,\n\t\t\t\"%s on channel %d at 0x%p irq %d\\n\",\n\t\t\tnetdev->name, i, priv->reg_base, pdev->irq);\n\t}\n\n\t \n\tpcan_write_reg(card, PCC_CCR, ccr);\n\n\treturn err;\n}\n\nstatic int pcan_conf_check(struct pcmcia_device *pdev, void *priv_data)\n{\n\tpdev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\n\tpdev->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;  \n\tpdev->io_lines = 10;\n\n\t \n\treturn pcmcia_request_io(pdev);\n}\n\n \nstatic void pcan_free(struct pcmcia_device *pdev)\n{\n\tstruct pcan_pccard *card = pdev->priv;\n\n\tif (!card)\n\t\treturn;\n\n\tfree_irq(pdev->irq, card);\n\tpcan_stop_led_timer(card);\n\n\tpcan_free_channels(card);\n\n\tioport_unmap(card->ioport_addr);\n\n\tkfree(card);\n\tpdev->priv = NULL;\n}\n\n \nstatic int pcan_probe(struct pcmcia_device *pdev)\n{\n\tstruct pcan_pccard *card;\n\tint err;\n\n\tpdev->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;\n\n\terr = pcmcia_loop_config(pdev, pcan_conf_check, NULL);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"pcmcia_loop_config() error %d\\n\", err);\n\t\tgoto probe_err_1;\n\t}\n\n\tif (!pdev->irq) {\n\t\tdev_err(&pdev->dev, \"no irq assigned\\n\");\n\t\terr = -ENODEV;\n\t\tgoto probe_err_1;\n\t}\n\n\terr = pcmcia_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"pcmcia_enable_device failed err=%d\\n\",\n\t\t\terr);\n\t\tgoto probe_err_1;\n\t}\n\n\tcard = kzalloc(sizeof(struct pcan_pccard), GFP_KERNEL);\n\tif (!card) {\n\t\terr = -ENOMEM;\n\t\tgoto probe_err_2;\n\t}\n\n\tcard->pdev = pdev;\n\tpdev->priv = card;\n\n\t \n\tcard->ioport_addr = ioport_map(pdev->resource[0]->start,\n\t\t\t\t\tresource_size(pdev->resource[0]));\n\tif (!card->ioport_addr) {\n\t\tdev_err(&pdev->dev, \"couldn't map io port into io memory\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto probe_err_3;\n\t}\n\tcard->fw_major = pcan_read_reg(card, PCC_FW_MAJOR);\n\tcard->fw_minor = pcan_read_reg(card, PCC_FW_MINOR);\n\n\t \n\tdev_info(&pdev->dev, \"PEAK-System pcmcia card %s fw %d.%d\\n\",\n\t\tpdev->prod_id[1] ? pdev->prod_id[1] : \"PCAN-PC Card\",\n\t\tcard->fw_major, card->fw_minor);\n\n\t \n\tpcan_add_channels(card);\n\tif (!card->chan_count) {\n\t\terr = -ENOMEM;\n\t\tgoto probe_err_4;\n\t}\n\n\t \n\ttimer_setup(&card->led_timer, pcan_led_timer, 0);\n\n\t \n\terr = request_irq(pdev->irq, &pcan_isr, IRQF_SHARED, PCC_NAME, card);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"couldn't request irq%d\\n\", pdev->irq);\n\t\tgoto probe_err_5;\n\t}\n\n\t \n\tpcan_set_can_power(card, 1);\n\n\treturn 0;\n\nprobe_err_5:\n\t \n\tpcan_free_channels(card);\n\nprobe_err_4:\n\tioport_unmap(card->ioport_addr);\n\nprobe_err_3:\n\tkfree(card);\n\tpdev->priv = NULL;\n\nprobe_err_2:\n\tpcmcia_disable_device(pdev);\n\nprobe_err_1:\n\treturn err;\n}\n\n \nstatic void pcan_remove(struct pcmcia_device *pdev)\n{\n\tpcan_free(pdev);\n\tpcmcia_disable_device(pdev);\n}\n\nstatic struct pcmcia_driver pcan_driver = {\n\t.name = PCC_NAME,\n\t.probe = pcan_probe,\n\t.remove = pcan_remove,\n\t.id_table = pcan_table,\n};\nmodule_pcmcia_driver(pcan_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}