{
  "module_name": "plx_pci.c",
  "hash_id": "b51cab1aba6f74cc0718076336a90d727699e92380456b6203b3cca0ae6d9d19",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/sja1000/plx_pci.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/can/dev.h>\n#include <linux/io.h>\n\n#include \"sja1000.h\"\n\n#define DRV_NAME  \"sja1000_plx_pci\"\n\nMODULE_AUTHOR(\"Pavel Cheblakov <P.B.Cheblakov@inp.nsk.su>\");\nMODULE_DESCRIPTION(\"Socket-CAN driver for PLX90xx PCI-bridge cards with \"\n\t\t   \"the SJA1000 chips\");\nMODULE_LICENSE(\"GPL v2\");\n\n#define PLX_PCI_MAX_CHAN 2\n\nstruct plx_pci_card {\n\tint channels;\t\t\t \n\tstruct net_device *net_dev[PLX_PCI_MAX_CHAN];\n\tvoid __iomem *conf_addr;\n\n\t \n\tvoid (*reset_func)(struct pci_dev *pdev);\n};\n\n#define PLX_PCI_CAN_CLOCK (16000000 / 2)\n\n \n#define PLX_INTCSR\t0x4c\t\t \n#define PLX_CNTRL\t0x50\t\t \n\n#define PLX_LINT1_EN\t0x1\t\t \n#define PLX_LINT1_POL\t(1 << 1)\t \n#define PLX_LINT2_EN\t(1 << 3)\t \n#define PLX_LINT2_POL\t(1 << 4)\t \n#define PLX_PCI_INT_EN\t(1 << 6)\t \n#define PLX_PCI_RESET\t(1 << 30)\t \n\n \n#define PLX9056_INTCSR\t0x68\t\t \n#define PLX9056_CNTRL\t0x6c\t\t \n\n#define PLX9056_LINTI\t(1 << 11)\n#define PLX9056_PCI_INT_EN (1 << 8)\n#define PLX9056_PCI_RCR\t(1 << 29)\t \n\n \n#define PLX_PCI_OCR\t(OCR_TX0_PUSHPULL | OCR_TX1_PUSHPULL)\n\n \n#define ASEM_PCI_OCR\t0xfe\n\n \n#define PLX_PCI_CDR\t\t\t(CDR_CBP | CDR_CLKOUT_MASK)\n\n \n#define REG_CR\t\t\t\t0x00\n\n \n#define REG_CR_BASICCAN_INITIAL\t\t0x21\n#define REG_CR_BASICCAN_INITIAL_MASK\t0xa1\n#define REG_SR_BASICCAN_INITIAL\t\t0x0c\n#define REG_IR_BASICCAN_INITIAL\t\t0xe0\n\n \n#define REG_MOD_PELICAN_INITIAL\t\t0x01\n#define REG_SR_PELICAN_INITIAL\t\t0x3c\n#define REG_IR_PELICAN_INITIAL\t\t0x00\n\n#define ADLINK_PCI_VENDOR_ID\t\t0x144A\n#define ADLINK_PCI_DEVICE_ID\t\t0x7841\n\n#define ESD_PCI_SUB_SYS_ID_PCI200\t0x0004\n#define ESD_PCI_SUB_SYS_ID_PCI266\t0x0009\n#define ESD_PCI_SUB_SYS_ID_PMC266\t0x000e\n#define ESD_PCI_SUB_SYS_ID_CPCI200\t0x010b\n#define ESD_PCI_SUB_SYS_ID_PCIE2000\t0x0200\n#define ESD_PCI_SUB_SYS_ID_PCI104200\t0x0501\n\n#define CAN200PCI_DEVICE_ID\t\t0x9030\n#define CAN200PCI_VENDOR_ID\t\t0x10b5\n#define CAN200PCI_SUB_DEVICE_ID\t\t0x0301\n#define CAN200PCI_SUB_VENDOR_ID\t\t0xe1c5\n\n#define IXXAT_PCI_VENDOR_ID\t\t0x10b5\n#define IXXAT_PCI_DEVICE_ID\t\t0x9050\n#define IXXAT_PCI_SUB_SYS_ID\t\t0x2540\n\n#define MARATHON_PCI_DEVICE_ID\t\t0x2715\n#define MARATHON_PCIE_DEVICE_ID\t\t0x3432\n\n#define TEWS_PCI_VENDOR_ID\t\t0x1498\n#define TEWS_PCI_DEVICE_ID_TMPC810\t0x032A\n\n#define CTI_PCI_VENDOR_ID\t\t0x12c4\n#define CTI_PCI_DEVICE_ID_CRG001\t0x0900\n\n#define MOXA_PCI_VENDOR_ID\t\t0x1393\n#define MOXA_PCI_DEVICE_ID\t\t0x0100\n\n#define ASEM_RAW_CAN_VENDOR_ID\t\t0x10b5\n#define ASEM_RAW_CAN_DEVICE_ID\t\t0x9030\n#define ASEM_RAW_CAN_SUB_VENDOR_ID\t0x3000\n#define ASEM_RAW_CAN_SUB_DEVICE_ID\t0x1001\n#define ASEM_RAW_CAN_SUB_DEVICE_ID_BIS\t0x1002\n#define ASEM_RAW_CAN_RST_REGISTER\t0x54\n#define ASEM_RAW_CAN_RST_MASK_CAN1\t0x20\n#define ASEM_RAW_CAN_RST_MASK_CAN2\t0x04\n\nstatic void plx_pci_reset_common(struct pci_dev *pdev);\nstatic void plx9056_pci_reset_common(struct pci_dev *pdev);\nstatic void plx_pci_reset_marathon_pci(struct pci_dev *pdev);\nstatic void plx_pci_reset_marathon_pcie(struct pci_dev *pdev);\nstatic void plx_pci_reset_asem_dual_can_raw(struct pci_dev *pdev);\n\nstruct plx_pci_channel_map {\n\tu32 bar;\n\tu32 offset;\n\tu32 size;\t\t \n};\n\nstruct plx_pci_card_info {\n\tconst char *name;\n\tint channel_count;\n\tu32 can_clock;\n\tu8 ocr;\t\t\t \n\tu8 cdr;\t\t\t \n\n\t \n\tstruct plx_pci_channel_map conf_map;\n\n\t \n\tstruct plx_pci_channel_map chan_map_tbl[PLX_PCI_MAX_CHAN];\n\n\t \n\tvoid (*reset_func)(struct pci_dev *pdev);\n};\n\nstatic struct plx_pci_card_info plx_pci_card_info_adlink = {\n\t\"Adlink PCI-7841/cPCI-7841\", 2,\n\tPLX_PCI_CAN_CLOCK, PLX_PCI_OCR, PLX_PCI_CDR,\n\t{1, 0x00, 0x00}, { {2, 0x00, 0x80}, {2, 0x80, 0x80} },\n\t&plx_pci_reset_common\n\t \n};\n\nstatic struct plx_pci_card_info plx_pci_card_info_adlink_se = {\n\t\"Adlink PCI-7841/cPCI-7841 SE\", 2,\n\tPLX_PCI_CAN_CLOCK, PLX_PCI_OCR, PLX_PCI_CDR,\n\t{0, 0x00, 0x00}, { {2, 0x00, 0x80}, {2, 0x80, 0x80} },\n\t&plx_pci_reset_common\n\t \n};\n\nstatic struct plx_pci_card_info plx_pci_card_info_esd200 = {\n\t\"esd CAN-PCI/CPCI/PCI104/200\", 2,\n\tPLX_PCI_CAN_CLOCK, PLX_PCI_OCR, PLX_PCI_CDR,\n\t{0, 0x00, 0x00}, { {2, 0x00, 0x80}, {2, 0x100, 0x80} },\n\t&plx_pci_reset_common\n\t \n};\n\nstatic struct plx_pci_card_info plx_pci_card_info_esd266 = {\n\t\"esd CAN-PCI/PMC/266\", 2,\n\tPLX_PCI_CAN_CLOCK, PLX_PCI_OCR, PLX_PCI_CDR,\n\t{0, 0x00, 0x00}, { {2, 0x00, 0x80}, {2, 0x100, 0x80} },\n\t&plx9056_pci_reset_common\n\t \n};\n\nstatic struct plx_pci_card_info plx_pci_card_info_esd2000 = {\n\t\"esd CAN-PCIe/2000\", 2,\n\tPLX_PCI_CAN_CLOCK, PLX_PCI_OCR, PLX_PCI_CDR,\n\t{0, 0x00, 0x00}, { {2, 0x00, 0x80}, {2, 0x100, 0x80} },\n\t&plx9056_pci_reset_common\n\t \n};\n\nstatic struct plx_pci_card_info plx_pci_card_info_ixxat = {\n\t\"IXXAT PC-I 04/PCI\", 2,\n\tPLX_PCI_CAN_CLOCK, PLX_PCI_OCR, PLX_PCI_CDR,\n\t{0, 0x00, 0x00}, { {2, 0x00, 0x80}, {2, 0x200, 0x80} },\n\t&plx_pci_reset_common\n\t \n};\n\nstatic struct plx_pci_card_info plx_pci_card_info_marathon_pci = {\n\t\"Marathon CAN-bus-PCI\", 2,\n\tPLX_PCI_CAN_CLOCK, PLX_PCI_OCR, PLX_PCI_CDR,\n\t{0, 0x00, 0x00}, { {2, 0x00, 0x00}, {4, 0x00, 0x00} },\n\t&plx_pci_reset_marathon_pci\n\t \n};\n\nstatic struct plx_pci_card_info plx_pci_card_info_marathon_pcie = {\n\t\"Marathon CAN-bus-PCIe\", 2,\n\tPLX_PCI_CAN_CLOCK, PLX_PCI_OCR, PLX_PCI_CDR,\n\t{0, 0x00, 0x00}, { {2, 0x00, 0x00}, {3, 0x80, 0x00} },\n\t&plx_pci_reset_marathon_pcie\n\t \n};\n\nstatic struct plx_pci_card_info plx_pci_card_info_tews = {\n\t\"TEWS TECHNOLOGIES TPMC810\", 2,\n\tPLX_PCI_CAN_CLOCK, PLX_PCI_OCR, PLX_PCI_CDR,\n\t{0, 0x00, 0x00}, { {2, 0x000, 0x80}, {2, 0x100, 0x80} },\n\t&plx_pci_reset_common\n\t \n};\n\nstatic struct plx_pci_card_info plx_pci_card_info_cti = {\n\t\"Connect Tech Inc. CANpro/104-Plus Opto (CRG001)\", 2,\n\tPLX_PCI_CAN_CLOCK, PLX_PCI_OCR, PLX_PCI_CDR,\n\t{0, 0x00, 0x00}, { {2, 0x000, 0x80}, {2, 0x100, 0x80} },\n\t&plx_pci_reset_common\n\t \n};\n\nstatic struct plx_pci_card_info plx_pci_card_info_elcus = {\n\t\"Eclus CAN-200-PCI\", 2,\n\tPLX_PCI_CAN_CLOCK, PLX_PCI_OCR, PLX_PCI_CDR,\n\t{1, 0x00, 0x00}, { {2, 0x00, 0x80}, {3, 0x00, 0x80} },\n\t&plx_pci_reset_common\n\t \n};\n\nstatic struct plx_pci_card_info plx_pci_card_info_moxa = {\n\t\"MOXA\", 2,\n\tPLX_PCI_CAN_CLOCK, PLX_PCI_OCR, PLX_PCI_CDR,\n\t{0, 0x00, 0x00}, { {0, 0x00, 0x80}, {1, 0x00, 0x80} },\n\t&plx_pci_reset_common\n\t  \n};\n\nstatic struct plx_pci_card_info plx_pci_card_info_asem_dual_can = {\n\t\"ASEM Dual CAN raw PCI\", 2,\n\tPLX_PCI_CAN_CLOCK, ASEM_PCI_OCR, PLX_PCI_CDR,\n\t{0, 0x00, 0x00}, { {2, 0x00, 0x00}, {4, 0x00, 0x00} },\n\t&plx_pci_reset_asem_dual_can_raw\n\t \n};\n\nstatic const struct pci_device_id plx_pci_tbl[] = {\n\t{\n\t\t \n\t\tADLINK_PCI_VENDOR_ID, ADLINK_PCI_DEVICE_ID,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\tPCI_CLASS_NETWORK_OTHER << 8, ~0,\n\t\t(kernel_ulong_t)&plx_pci_card_info_adlink\n\t},\n\t{\n\t\t \n\t\tADLINK_PCI_VENDOR_ID, ADLINK_PCI_DEVICE_ID,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\tPCI_CLASS_COMMUNICATION_OTHER << 8, ~0,\n\t\t(kernel_ulong_t)&plx_pci_card_info_adlink_se\n\t},\n\t{\n\t\t \n\t\tPCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9050,\n\t\tPCI_VENDOR_ID_ESDGMBH, ESD_PCI_SUB_SYS_ID_PCI200,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&plx_pci_card_info_esd200\n\t},\n\t{\n\t\t \n\t\tPCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030,\n\t\tPCI_VENDOR_ID_ESDGMBH, ESD_PCI_SUB_SYS_ID_CPCI200,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&plx_pci_card_info_esd200\n\t},\n\t{\n\t\t \n\t\tPCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030,\n\t\tPCI_VENDOR_ID_ESDGMBH, ESD_PCI_SUB_SYS_ID_PCI104200,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&plx_pci_card_info_esd200\n\t},\n\t{\n\t\t \n\t\tPCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9056,\n\t\tPCI_VENDOR_ID_ESDGMBH, ESD_PCI_SUB_SYS_ID_PCI266,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&plx_pci_card_info_esd266\n\t},\n\t{\n\t\t \n\t\tPCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9056,\n\t\tPCI_VENDOR_ID_ESDGMBH, ESD_PCI_SUB_SYS_ID_PMC266,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&plx_pci_card_info_esd266\n\t},\n\t{\n\t\t \n\t\tPCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9056,\n\t\tPCI_VENDOR_ID_ESDGMBH, ESD_PCI_SUB_SYS_ID_PCIE2000,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&plx_pci_card_info_esd2000\n\t},\n\t{\n\t\t \n\t\tIXXAT_PCI_VENDOR_ID, IXXAT_PCI_DEVICE_ID,\n\t\tPCI_ANY_ID, IXXAT_PCI_SUB_SYS_ID,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&plx_pci_card_info_ixxat\n\t},\n\t{\n\t\t \n\t\tPCI_VENDOR_ID_PLX, MARATHON_PCI_DEVICE_ID,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&plx_pci_card_info_marathon_pci\n\t},\n\t{\n\t\t \n\t\tPCI_VENDOR_ID_PLX, MARATHON_PCIE_DEVICE_ID,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&plx_pci_card_info_marathon_pcie\n\t},\n\t{\n\t\t \n\t\tTEWS_PCI_VENDOR_ID, TEWS_PCI_DEVICE_ID_TMPC810,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&plx_pci_card_info_tews\n\t},\n\t{\n\t\t \n\t\tPCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030,\n\t\tCTI_PCI_VENDOR_ID, CTI_PCI_DEVICE_ID_CRG001,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&plx_pci_card_info_cti\n\t},\n\t{\n\t\t \n\t\tCAN200PCI_VENDOR_ID, CAN200PCI_DEVICE_ID,\n\t\tCAN200PCI_SUB_VENDOR_ID, CAN200PCI_SUB_DEVICE_ID,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&plx_pci_card_info_elcus\n\t},\n\t{\n\t\t \n\t\tMOXA_PCI_VENDOR_ID, MOXA_PCI_DEVICE_ID,\n\t\tPCI_ANY_ID, PCI_ANY_ID,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&plx_pci_card_info_moxa\n\t},\n\t{\n\t\t \n\t\tASEM_RAW_CAN_VENDOR_ID, ASEM_RAW_CAN_DEVICE_ID,\n\t\tASEM_RAW_CAN_SUB_VENDOR_ID, ASEM_RAW_CAN_SUB_DEVICE_ID,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&plx_pci_card_info_asem_dual_can\n\t},\n\t{\n\t\t \n\t\tASEM_RAW_CAN_VENDOR_ID, ASEM_RAW_CAN_DEVICE_ID,\n\t\tASEM_RAW_CAN_SUB_VENDOR_ID, ASEM_RAW_CAN_SUB_DEVICE_ID_BIS,\n\t\t0, 0,\n\t\t(kernel_ulong_t)&plx_pci_card_info_asem_dual_can\n\t},\n\t{ 0,}\n};\nMODULE_DEVICE_TABLE(pci, plx_pci_tbl);\n\nstatic u8 plx_pci_read_reg(const struct sja1000_priv *priv, int port)\n{\n\treturn ioread8(priv->reg_base + port);\n}\n\nstatic void plx_pci_write_reg(const struct sja1000_priv *priv, int port, u8 val)\n{\n\tiowrite8(val, priv->reg_base + port);\n}\n\n \nstatic inline int plx_pci_check_sja1000(const struct sja1000_priv *priv)\n{\n\tint flag = 0;\n\n\t \n\tif ((priv->read_reg(priv, REG_CR) & REG_CR_BASICCAN_INITIAL_MASK) ==\n\t    REG_CR_BASICCAN_INITIAL &&\n\t    (priv->read_reg(priv, SJA1000_SR) == REG_SR_BASICCAN_INITIAL) &&\n\t    (priv->read_reg(priv, SJA1000_IR) == REG_IR_BASICCAN_INITIAL))\n\t\tflag = 1;\n\n\t \n\tpriv->write_reg(priv, SJA1000_CDR, CDR_PELICAN);\n\n\t \n\tif (priv->read_reg(priv, SJA1000_MOD) == REG_MOD_PELICAN_INITIAL &&\n\t    priv->read_reg(priv, SJA1000_SR) == REG_SR_PELICAN_INITIAL &&\n\t    priv->read_reg(priv, SJA1000_IR) == REG_IR_PELICAN_INITIAL)\n\t\treturn flag;\n\n\treturn 0;\n}\n\n \nstatic void plx_pci_reset_common(struct pci_dev *pdev)\n{\n\tstruct plx_pci_card *card = pci_get_drvdata(pdev);\n\tu32 cntrl;\n\n\tcntrl = ioread32(card->conf_addr + PLX_CNTRL);\n\tcntrl |= PLX_PCI_RESET;\n\tiowrite32(cntrl, card->conf_addr + PLX_CNTRL);\n\tudelay(100);\n\tcntrl ^= PLX_PCI_RESET;\n\tiowrite32(cntrl, card->conf_addr + PLX_CNTRL);\n};\n\n \nstatic void plx9056_pci_reset_common(struct pci_dev *pdev)\n{\n\tstruct plx_pci_card *card = pci_get_drvdata(pdev);\n\tu32 cntrl;\n\n\t \n\tcntrl = ioread32(card->conf_addr + PLX9056_CNTRL);\n\tcntrl |= PLX_PCI_RESET;\n\tiowrite32(cntrl, card->conf_addr + PLX9056_CNTRL);\n\tudelay(100);\n\tcntrl ^= PLX_PCI_RESET;\n\tiowrite32(cntrl, card->conf_addr + PLX9056_CNTRL);\n\n\t \n\tcntrl |= PLX9056_PCI_RCR;\n\tiowrite32(cntrl, card->conf_addr + PLX9056_CNTRL);\n\n\t \n\tmdelay(10);\n\n\tcntrl ^= PLX9056_PCI_RCR;\n\tiowrite32(cntrl, card->conf_addr + PLX9056_CNTRL);\n};\n\n \nstatic void plx_pci_reset_marathon_pci(struct pci_dev *pdev)\n{\n\tvoid __iomem *reset_addr;\n\tint i;\n\tstatic const int reset_bar[2] = {3, 5};\n\n\tplx_pci_reset_common(pdev);\n\n\tfor (i = 0; i < 2; i++) {\n\t\treset_addr = pci_iomap(pdev, reset_bar[i], 0);\n\t\tif (!reset_addr) {\n\t\t\tdev_err(&pdev->dev, \"Failed to remap reset \"\n\t\t\t\t\"space %d (BAR%d)\\n\", i, reset_bar[i]);\n\t\t} else {\n\t\t\t \n\t\t\tiowrite8(0x1, reset_addr);\n\t\t\tudelay(100);\n\t\t\tpci_iounmap(pdev, reset_addr);\n\t\t}\n\t}\n}\n\n \nstatic void plx_pci_reset_marathon_pcie(struct pci_dev *pdev)\n{\n\tvoid __iomem *addr;\n\tvoid __iomem *reset_addr;\n\tint i;\n\n\tplx9056_pci_reset_common(pdev);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct plx_pci_channel_map *chan_map =\n\t\t\t&plx_pci_card_info_marathon_pcie.chan_map_tbl[i];\n\t\taddr = pci_iomap(pdev, chan_map->bar, chan_map->size);\n\t\tif (!addr) {\n\t\t\tdev_err(&pdev->dev, \"Failed to remap reset \"\n\t\t\t\t\"space %d (BAR%d)\\n\", i, chan_map->bar);\n\t\t} else {\n\t\t\t \n\t\t\t#define MARATHON_PCIE_RESET_OFFSET 32\n\t\t\treset_addr = addr + chan_map->offset +\n\t\t\t             MARATHON_PCIE_RESET_OFFSET;\n\t\t\tiowrite8(0x1, reset_addr);\n\t\t\tudelay(100);\n\t\t\tpci_iounmap(pdev, addr);\n\t\t}\n\t}\n}\n\n \nstatic void plx_pci_reset_asem_dual_can_raw(struct pci_dev *pdev)\n{\n\tvoid __iomem *bar0_addr;\n\tu8 tmpval;\n\n\tplx_pci_reset_common(pdev);\n\n\tbar0_addr = pci_iomap(pdev, 0, 0);\n\tif (!bar0_addr) {\n\t\tdev_err(&pdev->dev, \"Failed to remap reset space 0 (BAR0)\\n\");\n\t\treturn;\n\t}\n\n\t \n\ttmpval = ioread8(bar0_addr + ASEM_RAW_CAN_RST_REGISTER);\n\ttmpval &= ~(ASEM_RAW_CAN_RST_MASK_CAN1 | ASEM_RAW_CAN_RST_MASK_CAN2);\n\tiowrite8(tmpval, bar0_addr + ASEM_RAW_CAN_RST_REGISTER);\n\tusleep_range(300, 400);\n\ttmpval |= ASEM_RAW_CAN_RST_MASK_CAN1 | ASEM_RAW_CAN_RST_MASK_CAN2;\n\tiowrite8(tmpval, bar0_addr + ASEM_RAW_CAN_RST_REGISTER);\n\tusleep_range(300, 400);\n\tpci_iounmap(pdev, bar0_addr);\n}\n\nstatic void plx_pci_del_card(struct pci_dev *pdev)\n{\n\tstruct plx_pci_card *card = pci_get_drvdata(pdev);\n\tstruct net_device *dev;\n\tstruct sja1000_priv *priv;\n\tint i = 0;\n\n\tfor (i = 0; i < PLX_PCI_MAX_CHAN; i++) {\n\t\tdev = card->net_dev[i];\n\t\tif (!dev)\n\t\t\tcontinue;\n\n\t\tdev_info(&pdev->dev, \"Removing %s\\n\", dev->name);\n\t\tunregister_sja1000dev(dev);\n\t\tpriv = netdev_priv(dev);\n\t\tif (priv->reg_base)\n\t\t\tpci_iounmap(pdev, priv->reg_base);\n\t\tfree_sja1000dev(dev);\n\t}\n\n\tcard->reset_func(pdev);\n\n\t \n\tif (pdev->device != PCI_DEVICE_ID_PLX_9056 &&\n\t    pdev->device != MARATHON_PCIE_DEVICE_ID)\n\t\tiowrite32(0x0, card->conf_addr + PLX_INTCSR);\n\telse\n\t\tiowrite32(0x0, card->conf_addr + PLX9056_INTCSR);\n\n\tif (card->conf_addr)\n\t\tpci_iounmap(pdev, card->conf_addr);\n\n\tkfree(card);\n\n\tpci_disable_device(pdev);\n}\n\n \nstatic int plx_pci_add_card(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *ent)\n{\n\tstruct sja1000_priv *priv;\n\tstruct net_device *dev;\n\tstruct plx_pci_card *card;\n\tstruct plx_pci_card_info *ci;\n\tint err, i;\n\tu32 val;\n\tvoid __iomem *addr;\n\n\tci = (struct plx_pci_card_info *)ent->driver_data;\n\n\tif (pci_enable_device(pdev) < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to enable PCI device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(&pdev->dev, \"Detected \\\"%s\\\" card at slot #%i\\n\",\n\t\t ci->name, PCI_SLOT(pdev->devfn));\n\n\t \n\tcard = kzalloc(sizeof(*card), GFP_KERNEL);\n\tif (!card) {\n\t\tpci_disable_device(pdev);\n\t\treturn -ENOMEM;\n\t}\n\n\tpci_set_drvdata(pdev, card);\n\n\tcard->channels = 0;\n\n\t \n\taddr = pci_iomap(pdev, ci->conf_map.bar, ci->conf_map.size);\n\tif (!addr) {\n\t\terr = -ENOMEM;\n\t\tdev_err(&pdev->dev, \"Failed to remap configuration space \"\n\t\t\t\"(BAR%d)\\n\", ci->conf_map.bar);\n\t\tgoto failure_cleanup;\n\t}\n\tcard->conf_addr = addr + ci->conf_map.offset;\n\n\tci->reset_func(pdev);\n\tcard->reset_func = ci->reset_func;\n\n\t \n\tfor (i = 0; i < ci->channel_count; i++) {\n\t\tstruct plx_pci_channel_map *cm = &ci->chan_map_tbl[i];\n\n\t\tdev = alloc_sja1000dev(0);\n\t\tif (!dev) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failure_cleanup;\n\t\t}\n\n\t\tcard->net_dev[i] = dev;\n\t\tpriv = netdev_priv(dev);\n\t\tpriv->priv = card;\n\t\tpriv->irq_flags = IRQF_SHARED;\n\n\t\tdev->irq = pdev->irq;\n\n\t\t \n\t\taddr = pci_iomap(pdev, cm->bar, cm->size);\n\t\tif (!addr) {\n\t\t\terr = -ENOMEM;\n\t\t\tdev_err(&pdev->dev, \"Failed to remap BAR%d\\n\", cm->bar);\n\t\t\tgoto failure_cleanup;\n\t\t}\n\n\t\tpriv->reg_base = addr + cm->offset;\n\t\tpriv->read_reg = plx_pci_read_reg;\n\t\tpriv->write_reg = plx_pci_write_reg;\n\n\t\t \n\t\tif (plx_pci_check_sja1000(priv)) {\n\t\t\tpriv->can.clock.freq = ci->can_clock;\n\t\t\tpriv->ocr = ci->ocr;\n\t\t\tpriv->cdr = ci->cdr;\n\n\t\t\tSET_NETDEV_DEV(dev, &pdev->dev);\n\t\t\tdev->dev_id = i;\n\n\t\t\t \n\t\t\terr = register_sja1000dev(dev);\n\t\t\tif (err) {\n\t\t\t\tdev_err(&pdev->dev, \"Registering device failed \"\n\t\t\t\t\t\"(err=%d)\\n\", err);\n\t\t\t\tgoto failure_cleanup;\n\t\t\t}\n\n\t\t\tcard->channels++;\n\n\t\t\tdev_info(&pdev->dev, \"Channel #%d at 0x%p, irq %d \"\n\t\t\t\t \"registered as %s\\n\", i + 1, priv->reg_base,\n\t\t\t\t dev->irq, dev->name);\n\t\t} else {\n\t\t\tdev_err(&pdev->dev, \"Channel #%d not detected\\n\",\n\t\t\t\ti + 1);\n\t\t\tfree_sja1000dev(dev);\n\t\t\tcard->net_dev[i] = NULL;\n\t\t}\n\t}\n\n\tif (!card->channels) {\n\t\terr = -ENODEV;\n\t\tgoto failure_cleanup;\n\t}\n\n\t \n\tif (pdev->device != PCI_DEVICE_ID_PLX_9056 &&\n\t    pdev->device != MARATHON_PCIE_DEVICE_ID) {\n\t\tval = ioread32(card->conf_addr + PLX_INTCSR);\n\t\tif (pdev->subsystem_vendor == PCI_VENDOR_ID_ESDGMBH)\n\t\t\tval |= PLX_LINT1_EN | PLX_PCI_INT_EN;\n\t\telse\n\t\t\tval |= PLX_LINT1_EN | PLX_LINT2_EN | PLX_PCI_INT_EN;\n\t\tiowrite32(val, card->conf_addr + PLX_INTCSR);\n\t} else {\n\t\tiowrite32(PLX9056_LINTI | PLX9056_PCI_INT_EN,\n\t\t\t  card->conf_addr + PLX9056_INTCSR);\n\t}\n\treturn 0;\n\nfailure_cleanup:\n\tdev_err(&pdev->dev, \"Error: %d. Cleaning Up.\\n\", err);\n\n\tplx_pci_del_card(pdev);\n\n\treturn err;\n}\n\nstatic struct pci_driver plx_pci_driver = {\n\t.name = DRV_NAME,\n\t.id_table = plx_pci_tbl,\n\t.probe = plx_pci_add_card,\n\t.remove = plx_pci_del_card,\n};\n\nmodule_pci_driver(plx_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}