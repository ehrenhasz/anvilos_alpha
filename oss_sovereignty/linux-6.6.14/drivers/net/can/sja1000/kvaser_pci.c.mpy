{
  "module_name": "kvaser_pci.c",
  "hash_id": "125d7bd5591dfe595495b41f7a969d4873bb9e3e0a24254b7252897f39c60c6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/sja1000/kvaser_pci.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/can/dev.h>\n#include <linux/io.h>\n\n#include \"sja1000.h\"\n\n#define DRV_NAME  \"kvaser_pci\"\n\nMODULE_AUTHOR(\"Per Dalen <per.dalen@cnw.se>\");\nMODULE_DESCRIPTION(\"Socket-CAN driver for KVASER PCAN PCI cards\");\nMODULE_LICENSE(\"GPL v2\");\n\n#define MAX_NO_OF_CHANNELS        4  \n\nstruct kvaser_pci {\n\tint channel;\n\tstruct pci_dev *pci_dev;\n\tstruct net_device *slave_dev[MAX_NO_OF_CHANNELS-1];\n\tvoid __iomem *conf_addr;\n\tvoid __iomem *res_addr;\n\tint no_channels;\n\tu8 xilinx_ver;\n};\n\n#define KVASER_PCI_CAN_CLOCK      (16000000 / 2)\n\n \n#define KVASER_PCI_OCR            (OCR_TX0_PUSHPULL | OCR_TX1_PUSHPULL)\n\n \n#define KVASER_PCI_CDR            (CDR_CBP | CDR_CLKOUT_MASK)\n\n \n#define XILINX_VERINT             7    \n\n#define XILINX_PRESUMED_VERSION   14\n\n \n#define S5920_INTCSR              0x38\n#define S5920_PTCR                0x60\n#define INTCSR_ADDON_INTENABLE_M  0x2000\n\n\n#define KVASER_PCI_PORT_BYTES     0x20\n\n#define PCI_CONFIG_PORT_SIZE      0x80       \n#define PCI_PORT_SIZE             0x80       \n#define PCI_PORT_XILINX_SIZE      0x08       \n\n#define KVASER_PCI_VENDOR_ID1     0x10e8     \n#define KVASER_PCI_DEVICE_ID1     0x8406\n\n#define KVASER_PCI_VENDOR_ID2     0x1a07     \n#define KVASER_PCI_DEVICE_ID2     0x0008\n\nstatic const struct pci_device_id kvaser_pci_tbl[] = {\n\t{KVASER_PCI_VENDOR_ID1, KVASER_PCI_DEVICE_ID1, PCI_ANY_ID, PCI_ANY_ID,},\n\t{KVASER_PCI_VENDOR_ID2, KVASER_PCI_DEVICE_ID2, PCI_ANY_ID, PCI_ANY_ID,},\n\t{ 0,}\n};\n\nMODULE_DEVICE_TABLE(pci, kvaser_pci_tbl);\n\nstatic u8 kvaser_pci_read_reg(const struct sja1000_priv *priv, int port)\n{\n\treturn ioread8(priv->reg_base + port);\n}\n\nstatic void kvaser_pci_write_reg(const struct sja1000_priv *priv,\n\t\t\t\t int port, u8 val)\n{\n\tiowrite8(val, priv->reg_base + port);\n}\n\nstatic void kvaser_pci_disable_irq(struct net_device *dev)\n{\n\tstruct sja1000_priv *priv = netdev_priv(dev);\n\tstruct kvaser_pci *board = priv->priv;\n\tu32 intcsr;\n\n\t \n\tintcsr = ioread32(board->conf_addr + S5920_INTCSR);\n\tintcsr &= ~INTCSR_ADDON_INTENABLE_M;\n\tiowrite32(intcsr, board->conf_addr + S5920_INTCSR);\n}\n\nstatic void kvaser_pci_enable_irq(struct net_device *dev)\n{\n\tstruct sja1000_priv *priv = netdev_priv(dev);\n\tstruct kvaser_pci *board = priv->priv;\n\tu32 tmp_en_io;\n\n\t \n\ttmp_en_io = ioread32(board->conf_addr + S5920_INTCSR);\n\ttmp_en_io |= INTCSR_ADDON_INTENABLE_M;\n\tiowrite32(tmp_en_io, board->conf_addr + S5920_INTCSR);\n}\n\nstatic int number_of_sja1000_chip(void __iomem *base_addr)\n{\n\tu8 status;\n\tint i;\n\n\tfor (i = 0; i < MAX_NO_OF_CHANNELS; i++) {\n\t\t \n\t\tiowrite8(MOD_RM, base_addr +\n\t\t\t (i * KVASER_PCI_PORT_BYTES) + SJA1000_MOD);\n\t\tstatus = ioread8(base_addr +\n\t\t\t\t (i * KVASER_PCI_PORT_BYTES) + SJA1000_MOD);\n\t\t \n\t\tif (!(status & MOD_RM))\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}\n\nstatic void kvaser_pci_del_chan(struct net_device *dev)\n{\n\tstruct sja1000_priv *priv;\n\tstruct kvaser_pci *board;\n\tint i;\n\n\tif (!dev)\n\t\treturn;\n\tpriv = netdev_priv(dev);\n\tboard = priv->priv;\n\tif (!board)\n\t\treturn;\n\n\tdev_info(&board->pci_dev->dev, \"Removing device %s\\n\",\n\t\t dev->name);\n\n\t \n\tkvaser_pci_disable_irq(dev);\n\n\tfor (i = 0; i < board->no_channels - 1; i++) {\n\t\tif (board->slave_dev[i]) {\n\t\t\tdev_info(&board->pci_dev->dev, \"Removing device %s\\n\",\n\t\t\t\t board->slave_dev[i]->name);\n\t\t\tunregister_sja1000dev(board->slave_dev[i]);\n\t\t\tfree_sja1000dev(board->slave_dev[i]);\n\t\t}\n\t}\n\tunregister_sja1000dev(dev);\n\n\tpci_iounmap(board->pci_dev, priv->reg_base);\n\tpci_iounmap(board->pci_dev, board->conf_addr);\n\tpci_iounmap(board->pci_dev, board->res_addr);\n\n\tfree_sja1000dev(dev);\n}\n\nstatic int kvaser_pci_add_chan(struct pci_dev *pdev, int channel,\n\t\t\t       struct net_device **master_dev,\n\t\t\t       void __iomem *conf_addr,\n\t\t\t       void __iomem *res_addr,\n\t\t\t       void __iomem *base_addr)\n{\n\tstruct net_device *dev;\n\tstruct sja1000_priv *priv;\n\tstruct kvaser_pci *board;\n\tint err;\n\n\tdev = alloc_sja1000dev(sizeof(struct kvaser_pci));\n\tif (dev == NULL)\n\t\treturn -ENOMEM;\n\n\tpriv = netdev_priv(dev);\n\tboard = priv->priv;\n\n\tboard->pci_dev = pdev;\n\tboard->channel = channel;\n\n\t \n\tboard->conf_addr = conf_addr;\n\n\t \n\tboard->res_addr = res_addr;\n\n\tif (channel == 0) {\n\t\tboard->xilinx_ver =\n\t\t\tioread8(board->res_addr + XILINX_VERINT) >> 4;\n\n\t\t \n\t\tiowrite32(0x80808080UL, board->conf_addr + S5920_PTCR);\n\n\t\t \n\t\tkvaser_pci_enable_irq(dev);\n\t} else {\n\t\tstruct sja1000_priv *master_priv = netdev_priv(*master_dev);\n\t\tstruct kvaser_pci *master_board = master_priv->priv;\n\t\tmaster_board->slave_dev[channel - 1] = dev;\n\t\tmaster_board->no_channels = channel + 1;\n\t\tboard->xilinx_ver = master_board->xilinx_ver;\n\t}\n\n\tpriv->reg_base = base_addr + channel * KVASER_PCI_PORT_BYTES;\n\n\tpriv->read_reg = kvaser_pci_read_reg;\n\tpriv->write_reg = kvaser_pci_write_reg;\n\n\tpriv->can.clock.freq = KVASER_PCI_CAN_CLOCK;\n\n\tpriv->ocr = KVASER_PCI_OCR;\n\tpriv->cdr = KVASER_PCI_CDR;\n\n\tpriv->irq_flags = IRQF_SHARED;\n\tdev->irq = pdev->irq;\n\n\tdev_info(&pdev->dev, \"reg_base=%p conf_addr=%p irq=%d\\n\",\n\t\t priv->reg_base, board->conf_addr, dev->irq);\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\tdev->dev_id = channel;\n\n\t \n\terr = register_sja1000dev(dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Registering device failed (err=%d)\\n\",\n\t\t\terr);\n\t\tgoto failure;\n\t}\n\n\tif (channel == 0)\n\t\t*master_dev = dev;\n\n\treturn 0;\n\nfailure:\n\tkvaser_pci_del_chan(dev);\n\treturn err;\n}\n\nstatic int kvaser_pci_init_one(struct pci_dev *pdev,\n\t\t\t       const struct pci_device_id *ent)\n{\n\tint err;\n\tstruct net_device *master_dev = NULL;\n\tstruct sja1000_priv *priv;\n\tstruct kvaser_pci *board;\n\tint no_channels;\n\tvoid __iomem *base_addr = NULL;\n\tvoid __iomem *conf_addr = NULL;\n\tvoid __iomem *res_addr = NULL;\n\tint i;\n\n\tdev_info(&pdev->dev, \"initializing device %04x:%04x\\n\",\n\t\t pdev->vendor, pdev->device);\n\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\tgoto failure;\n\n\terr = pci_request_regions(pdev, DRV_NAME);\n\tif (err)\n\t\tgoto failure_release_pci;\n\n\t \n\tconf_addr = pci_iomap(pdev, 0, PCI_CONFIG_PORT_SIZE);\n\tif (conf_addr == NULL) {\n\t\terr = -ENODEV;\n\t\tgoto failure_release_regions;\n\t}\n\n\t \n\tres_addr = pci_iomap(pdev, 2, PCI_PORT_XILINX_SIZE);\n\tif (res_addr == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto failure_iounmap;\n\t}\n\n\tbase_addr = pci_iomap(pdev, 1, PCI_PORT_SIZE);\n\tif (base_addr == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto failure_iounmap;\n\t}\n\n\tno_channels = number_of_sja1000_chip(base_addr);\n\tif (no_channels == 0) {\n\t\terr = -ENOMEM;\n\t\tgoto failure_iounmap;\n\t}\n\n\tfor (i = 0; i < no_channels; i++) {\n\t\terr = kvaser_pci_add_chan(pdev, i, &master_dev,\n\t\t\t\t\t  conf_addr, res_addr,\n\t\t\t\t\t  base_addr);\n\t\tif (err)\n\t\t\tgoto failure_cleanup;\n\t}\n\n\tpriv = netdev_priv(master_dev);\n\tboard = priv->priv;\n\n\tdev_info(&pdev->dev, \"xilinx version=%d number of channels=%d\\n\",\n\t\t board->xilinx_ver, board->no_channels);\n\n\tpci_set_drvdata(pdev, master_dev);\n\treturn 0;\n\nfailure_cleanup:\n\tkvaser_pci_del_chan(master_dev);\n\nfailure_iounmap:\n\tif (conf_addr != NULL)\n\t\tpci_iounmap(pdev, conf_addr);\n\tif (res_addr != NULL)\n\t\tpci_iounmap(pdev, res_addr);\n\tif (base_addr != NULL)\n\t\tpci_iounmap(pdev, base_addr);\n\nfailure_release_regions:\n\tpci_release_regions(pdev);\n\nfailure_release_pci:\n\tpci_disable_device(pdev);\n\nfailure:\n\treturn err;\n\n}\n\nstatic void kvaser_pci_remove_one(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\n\tkvaser_pci_del_chan(dev);\n\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n}\n\nstatic struct pci_driver kvaser_pci_driver = {\n\t.name = DRV_NAME,\n\t.id_table = kvaser_pci_tbl,\n\t.probe = kvaser_pci_init_one,\n\t.remove = kvaser_pci_remove_one,\n};\n\nmodule_pci_driver(kvaser_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}