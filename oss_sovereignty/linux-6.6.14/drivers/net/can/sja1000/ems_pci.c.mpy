{
  "module_name": "ems_pci.c",
  "hash_id": "a8eddafbd0c8ff9cf2bf5aece4153febc64888b3c912d7383c170427bc075c59",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/sja1000/ems_pci.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/can/dev.h>\n#include <linux/io.h>\n\n#include \"sja1000.h\"\n\n#define DRV_NAME  \"ems_pci\"\n\nMODULE_AUTHOR(\"Sebastian Haas <support@ems-wuensche.com>\");\nMODULE_AUTHOR(\"Gerhard Uttenthaler <uttenthaler@ems-wuensche.com>\");\nMODULE_DESCRIPTION(\"Socket-CAN driver for EMS CPC-PCI/PCIe/104P CAN cards\");\nMODULE_LICENSE(\"GPL v2\");\n\n#define EMS_PCI_V1_MAX_CHAN 2\n#define EMS_PCI_V2_MAX_CHAN 4\n#define EMS_PCI_V3_MAX_CHAN 4\n#define EMS_PCI_MAX_CHAN    EMS_PCI_V2_MAX_CHAN\n\nstruct ems_pci_card {\n\tint version;\n\tint channels;\n\n\tstruct pci_dev *pci_dev;\n\tstruct net_device *net_dev[EMS_PCI_MAX_CHAN];\n\n\tvoid __iomem *conf_addr;\n\tvoid __iomem *base_addr;\n};\n\n#define EMS_PCI_CAN_CLOCK (16000000 / 2)\n\n \n#define PITA2_ICR           0x00\t \n#define PITA2_ICR_INT0      0x00000002\t \n#define PITA2_ICR_INT0_EN   0x00020000\t \n\n#define PITA2_MISC          0x1c\t \n#define PITA2_MISC_CONFIG   0x04000000\t \n\n \n#define PLX_ICSR            0x4c    \n#define PLX_ICSR_LINTI1_ENA 0x0001  \n#define PLX_ICSR_PCIINT_ENA 0x0040  \n#define PLX_ICSR_LINTI1_CLR 0x0400  \n#define PLX_ICSR_ENA_CLR    (PLX_ICSR_LINTI1_ENA | PLX_ICSR_PCIINT_ENA | \\\n\t\t\t     PLX_ICSR_LINTI1_CLR)\n\n \n#define ASIX_LINTSR 0x28  \n#define ASIX_LINTSR_INT0AC BIT(0)  \n\n#define ASIX_LIEMR 0x24  \n#define ASIX_LIEMR_L0EINTEN BIT(16)  \n#define ASIX_LIEMR_LRST BIT(14)  \n\n \n#define EMS_PCI_OCR         (OCR_TX0_PUSHPULL | OCR_TX1_PUSHPULL)\n\n \n#define EMS_PCI_CDR             (CDR_CBP | CDR_CLKOUT_MASK)\n\n#define EMS_PCI_V1_BASE_BAR 1\n#define EMS_PCI_V1_CONF_BAR 0\n#define EMS_PCI_V1_CONF_SIZE 4096  \n#define EMS_PCI_V1_CAN_BASE_OFFSET 0x400  \n#define EMS_PCI_V1_CAN_CTRL_SIZE 0x200  \n\n#define EMS_PCI_V2_BASE_BAR 2\n#define EMS_PCI_V2_CONF_BAR 0\n#define EMS_PCI_V2_CONF_SIZE 128  \n#define EMS_PCI_V2_CAN_BASE_OFFSET 0x400  \n#define EMS_PCI_V2_CAN_CTRL_SIZE 0x200  \n\n#define EMS_PCI_V3_BASE_BAR 0\n#define EMS_PCI_V3_CONF_BAR 5\n#define EMS_PCI_V3_CONF_SIZE 128  \n#define EMS_PCI_V3_CAN_BASE_OFFSET 0x00  \n#define EMS_PCI_V3_CAN_CTRL_SIZE 0x100  \n\n#define EMS_PCI_BASE_SIZE  4096  \n\n#define PCI_SUBDEVICE_ID_EMS 0x4010\n\nstatic const struct pci_device_id ems_pci_tbl[] = {\n\t \n\t{PCI_VENDOR_ID_SIEMENS, 0x2104, PCI_ANY_ID, PCI_ANY_ID,},\n\t \n\t{PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030, PCI_VENDOR_ID_PLX, 0x4000},\n\t \n\t{PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030, PCI_VENDOR_ID_PLX, 0x4002},\n\t \n\t{PCI_VENDOR_ID_ASIX, PCI_DEVICE_ID_ASIX_AX99100_LB, 0xa000, PCI_SUBDEVICE_ID_EMS},\n\t{0,}\n};\nMODULE_DEVICE_TABLE(pci, ems_pci_tbl);\n\n \nstatic u8 ems_pci_v1_readb(struct ems_pci_card *card, unsigned int port)\n{\n\treturn readb(card->base_addr + (port * 4));\n}\n\nstatic u8 ems_pci_v1_read_reg(const struct sja1000_priv *priv, int port)\n{\n\treturn readb(priv->reg_base + (port * 4));\n}\n\nstatic void ems_pci_v1_write_reg(const struct sja1000_priv *priv,\n\t\t\t\t int port, u8 val)\n{\n\twriteb(val, priv->reg_base + (port * 4));\n}\n\nstatic void ems_pci_v1_post_irq(const struct sja1000_priv *priv)\n{\n\tstruct ems_pci_card *card = priv->priv;\n\n\t \n\twritel(PITA2_ICR_INT0_EN | PITA2_ICR_INT0,\n\t       card->conf_addr + PITA2_ICR);\n}\n\nstatic u8 ems_pci_v2_read_reg(const struct sja1000_priv *priv, int port)\n{\n\treturn readb(priv->reg_base + port);\n}\n\nstatic void ems_pci_v2_write_reg(const struct sja1000_priv *priv,\n\t\t\t\t int port, u8 val)\n{\n\twriteb(val, priv->reg_base + port);\n}\n\nstatic void ems_pci_v2_post_irq(const struct sja1000_priv *priv)\n{\n\tstruct ems_pci_card *card = priv->priv;\n\n\twritel(PLX_ICSR_ENA_CLR, card->conf_addr + PLX_ICSR);\n}\n\nstatic u8 ems_pci_v3_read_reg(const struct sja1000_priv *priv, int port)\n{\n\treturn readb(priv->reg_base + port);\n}\n\nstatic void ems_pci_v3_write_reg(const struct sja1000_priv *priv,\n\t\t\t\t int port, u8 val)\n{\n\twriteb(val, priv->reg_base + port);\n}\n\nstatic void ems_pci_v3_post_irq(const struct sja1000_priv *priv)\n{\n\tstruct ems_pci_card *card = priv->priv;\n\n\twritel(ASIX_LINTSR_INT0AC, card->conf_addr + ASIX_LINTSR);\n}\n\n \nstatic inline int ems_pci_check_chan(const struct sja1000_priv *priv)\n{\n\tunsigned char res;\n\n\t \n\tpriv->write_reg(priv, SJA1000_MOD, 1);\n\n\tpriv->write_reg(priv, SJA1000_CDR, CDR_PELICAN);\n\n\t \n\tres = priv->read_reg(priv, SJA1000_CDR);\n\n\tif (res == CDR_PELICAN)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void ems_pci_del_card(struct pci_dev *pdev)\n{\n\tstruct ems_pci_card *card = pci_get_drvdata(pdev);\n\tstruct net_device *dev;\n\tint i = 0;\n\n\tfor (i = 0; i < card->channels; i++) {\n\t\tdev = card->net_dev[i];\n\n\t\tif (!dev)\n\t\t\tcontinue;\n\n\t\tdev_info(&pdev->dev, \"Removing %s.\\n\", dev->name);\n\t\tunregister_sja1000dev(dev);\n\t\tfree_sja1000dev(dev);\n\t}\n\n\tif (card->base_addr)\n\t\tpci_iounmap(card->pci_dev, card->base_addr);\n\n\tif (card->conf_addr)\n\t\tpci_iounmap(card->pci_dev, card->conf_addr);\n\n\tkfree(card);\n\n\tpci_disable_device(pdev);\n}\n\nstatic void ems_pci_card_reset(struct ems_pci_card *card)\n{\n\t \n\twriteb(0, card->base_addr);\n}\n\n \nstatic int ems_pci_add_card(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *ent)\n{\n\tstruct sja1000_priv *priv;\n\tstruct net_device *dev;\n\tstruct ems_pci_card *card;\n\tint max_chan, conf_size, base_bar, conf_bar;\n\tint err, i;\n\n\t \n\tif (pci_enable_device(pdev) < 0) {\n\t\tdev_err(&pdev->dev, \"Enabling PCI device failed\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tcard = kzalloc(sizeof(*card), GFP_KERNEL);\n\tif (!card) {\n\t\tpci_disable_device(pdev);\n\t\treturn -ENOMEM;\n\t}\n\n\tpci_set_drvdata(pdev, card);\n\n\tcard->pci_dev = pdev;\n\n\tcard->channels = 0;\n\n\tif (pdev->vendor == PCI_VENDOR_ID_ASIX) {\n\t\tcard->version = 3;  \n\t\tmax_chan = EMS_PCI_V3_MAX_CHAN;\n\t\tbase_bar = EMS_PCI_V3_BASE_BAR;\n\t\tconf_bar = EMS_PCI_V3_CONF_BAR;\n\t\tconf_size = EMS_PCI_V3_CONF_SIZE;\n\t} else if (pdev->vendor == PCI_VENDOR_ID_PLX) {\n\t\tcard->version = 2;  \n\t\tmax_chan = EMS_PCI_V2_MAX_CHAN;\n\t\tbase_bar = EMS_PCI_V2_BASE_BAR;\n\t\tconf_bar = EMS_PCI_V2_CONF_BAR;\n\t\tconf_size = EMS_PCI_V2_CONF_SIZE;\n\t} else {\n\t\tcard->version = 1;  \n\t\tmax_chan = EMS_PCI_V1_MAX_CHAN;\n\t\tbase_bar = EMS_PCI_V1_BASE_BAR;\n\t\tconf_bar = EMS_PCI_V1_CONF_BAR;\n\t\tconf_size = EMS_PCI_V1_CONF_SIZE;\n\t}\n\n\t \n\tcard->conf_addr = pci_iomap(pdev, conf_bar, conf_size);\n\tif (!card->conf_addr) {\n\t\terr = -ENOMEM;\n\t\tgoto failure_cleanup;\n\t}\n\n\tcard->base_addr = pci_iomap(pdev, base_bar, EMS_PCI_BASE_SIZE);\n\tif (!card->base_addr) {\n\t\terr = -ENOMEM;\n\t\tgoto failure_cleanup;\n\t}\n\n\tif (card->version == 1) {\n\t\t \n\t\twritel(PITA2_MISC_CONFIG, card->conf_addr + PITA2_MISC);\n\n\t\t \n\t\tif (ems_pci_v1_readb(card, 0) != 0x55 ||\n\t\t    ems_pci_v1_readb(card, 1) != 0xAA ||\n\t\t    ems_pci_v1_readb(card, 2) != 0x01 ||\n\t\t    ems_pci_v1_readb(card, 3) != 0xCB ||\n\t\t    ems_pci_v1_readb(card, 4) != 0x11) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Not EMS Dr. Thomas Wuensche interface\\n\");\n\t\t\terr = -ENODEV;\n\t\t\tgoto failure_cleanup;\n\t\t}\n\t}\n\n\tif (card->version == 3) {\n\t\t \n\t\twritel(readl(card->conf_addr + ASIX_LIEMR) & ~ASIX_LIEMR_LRST,\n\t\t       card->conf_addr + ASIX_LIEMR);\n\t}\n\n\tems_pci_card_reset(card);\n\n\t \n\tfor (i = 0; i < max_chan; i++) {\n\t\tdev = alloc_sja1000dev(0);\n\t\tif (!dev) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failure_cleanup;\n\t\t}\n\n\t\tcard->net_dev[i] = dev;\n\t\tpriv = netdev_priv(dev);\n\t\tpriv->priv = card;\n\t\tpriv->irq_flags = IRQF_SHARED;\n\n\t\tdev->irq = pdev->irq;\n\n\t\tif (card->version == 1) {\n\t\t\tpriv->read_reg  = ems_pci_v1_read_reg;\n\t\t\tpriv->write_reg = ems_pci_v1_write_reg;\n\t\t\tpriv->post_irq  = ems_pci_v1_post_irq;\n\t\t\tpriv->reg_base = card->base_addr + EMS_PCI_V1_CAN_BASE_OFFSET\n\t\t\t\t\t+ (i * EMS_PCI_V1_CAN_CTRL_SIZE);\n\t\t} else if (card->version == 2) {\n\t\t\tpriv->read_reg  = ems_pci_v2_read_reg;\n\t\t\tpriv->write_reg = ems_pci_v2_write_reg;\n\t\t\tpriv->post_irq  = ems_pci_v2_post_irq;\n\t\t\tpriv->reg_base = card->base_addr + EMS_PCI_V2_CAN_BASE_OFFSET\n\t\t\t\t\t+ (i * EMS_PCI_V2_CAN_CTRL_SIZE);\n\t\t} else {\n\t\t\tpriv->read_reg  = ems_pci_v3_read_reg;\n\t\t\tpriv->write_reg = ems_pci_v3_write_reg;\n\t\t\tpriv->post_irq  = ems_pci_v3_post_irq;\n\t\t\tpriv->reg_base = card->base_addr + EMS_PCI_V3_CAN_BASE_OFFSET\n\t\t\t\t\t+ (i * EMS_PCI_V3_CAN_CTRL_SIZE);\n\t\t}\n\n\t\t \n\t\tif (ems_pci_check_chan(priv)) {\n\t\t\tpriv->can.clock.freq = EMS_PCI_CAN_CLOCK;\n\t\t\tpriv->ocr = EMS_PCI_OCR;\n\t\t\tpriv->cdr = EMS_PCI_CDR;\n\n\t\t\tSET_NETDEV_DEV(dev, &pdev->dev);\n\t\t\tdev->dev_id = i;\n\n\t\t\tif (card->version == 1) {\n\t\t\t\t \n\t\t\t\twritel(PITA2_ICR_INT0_EN | PITA2_ICR_INT0,\n\t\t\t\t       card->conf_addr + PITA2_ICR);\n\t\t\t} else if (card->version == 2) {\n\t\t\t\t \n\t\t\t\twritel(PLX_ICSR_ENA_CLR,\n\t\t\t\t       card->conf_addr + PLX_ICSR);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\twritel(ASIX_LINTSR_INT0AC, card->conf_addr + ASIX_LINTSR);\n\t\t\t\t \n\t\t\t\twritel(readl(card->conf_addr + ASIX_LIEMR) | ASIX_LIEMR_L0EINTEN,\n\t\t\t\t       card->conf_addr + ASIX_LIEMR);\n\t\t\t}\n\n\t\t\t \n\t\t\terr = register_sja1000dev(dev);\n\t\t\tif (err) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"Registering device failed: %pe\\n\",\n\t\t\t\t\tERR_PTR(err));\n\t\t\t\tfree_sja1000dev(dev);\n\t\t\t\tgoto failure_cleanup;\n\t\t\t}\n\n\t\t\tcard->channels++;\n\n\t\t\tdev_info(&pdev->dev, \"Channel #%d at 0x%p, irq %d\\n\",\n\t\t\t\t i + 1, priv->reg_base, dev->irq);\n\t\t} else {\n\t\t\tfree_sja1000dev(dev);\n\t\t}\n\t}\n\n\treturn 0;\n\nfailure_cleanup:\n\tdev_err(&pdev->dev, \"Error: %d. Cleaning Up.\\n\", err);\n\n\tems_pci_del_card(pdev);\n\n\treturn err;\n}\n\nstatic struct pci_driver ems_pci_driver = {\n\t.name = DRV_NAME,\n\t.id_table = ems_pci_tbl,\n\t.probe = ems_pci_add_card,\n\t.remove = ems_pci_del_card,\n};\n\nmodule_pci_driver(ems_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}