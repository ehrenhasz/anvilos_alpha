{
  "module_name": "sja1000.c",
  "hash_id": "cb28d25d445a5b372684ac0621adfa9230d88e52bf6851a57f4ad74f959c83cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/sja1000/sja1000.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/ethtool.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\n\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n\n#include \"sja1000.h\"\n\n#define DRV_NAME \"sja1000\"\n\nMODULE_AUTHOR(\"Oliver Hartkopp <oliver.hartkopp@volkswagen.de>\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DESCRIPTION(DRV_NAME \"CAN netdevice driver\");\n\nstatic const struct can_bittiming_const sja1000_bittiming_const = {\n\t.name = DRV_NAME,\n\t.tseg1_min = 1,\n\t.tseg1_max = 16,\n\t.tseg2_min = 1,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 64,\n\t.brp_inc = 1,\n};\n\nstatic void sja1000_write_cmdreg(struct sja1000_priv *priv, u8 val)\n{\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&priv->cmdreg_lock, flags);\n\tpriv->write_reg(priv, SJA1000_CMR, val);\n\tpriv->read_reg(priv, SJA1000_SR);\n\tspin_unlock_irqrestore(&priv->cmdreg_lock, flags);\n}\n\nstatic int sja1000_is_absent(struct sja1000_priv *priv)\n{\n\treturn (priv->read_reg(priv, SJA1000_MOD) == 0xFF);\n}\n\nstatic int sja1000_probe_chip(struct net_device *dev)\n{\n\tstruct sja1000_priv *priv = netdev_priv(dev);\n\n\tif (priv->reg_base && sja1000_is_absent(priv)) {\n\t\tnetdev_err(dev, \"probing failed\\n\");\n\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nstatic void set_reset_mode(struct net_device *dev)\n{\n\tstruct sja1000_priv *priv = netdev_priv(dev);\n\tunsigned char status = priv->read_reg(priv, SJA1000_MOD);\n\tint i;\n\n\t \n\tpriv->write_reg(priv, SJA1000_IER, IRQ_OFF);\n\n\tfor (i = 0; i < 100; i++) {\n\t\t \n\t\tif (status & MOD_RM) {\n\t\t\tpriv->can.state = CAN_STATE_STOPPED;\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tpriv->write_reg(priv, SJA1000_MOD, MOD_RM);\n\t\tudelay(10);\n\t\tstatus = priv->read_reg(priv, SJA1000_MOD);\n\t}\n\n\tnetdev_err(dev, \"setting SJA1000 into reset mode failed!\\n\");\n}\n\nstatic void set_normal_mode(struct net_device *dev)\n{\n\tstruct sja1000_priv *priv = netdev_priv(dev);\n\tunsigned char status = priv->read_reg(priv, SJA1000_MOD);\n\tu8 mod_reg_val = 0x00;\n\tint i;\n\n\tfor (i = 0; i < 100; i++) {\n\t\t \n\t\tif ((status & MOD_RM) == 0) {\n\t\t\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\t\t \n\t\t\tif (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING)\n\t\t\t\tpriv->write_reg(priv, SJA1000_IER, IRQ_ALL);\n\t\t\telse\n\t\t\t\tpriv->write_reg(priv, SJA1000_IER,\n\t\t\t\t\t\tIRQ_ALL & ~IRQ_BEI);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\t\tmod_reg_val |= MOD_LOM;\n\t\tif (priv->can.ctrlmode & CAN_CTRLMODE_PRESUME_ACK)\n\t\t\tmod_reg_val |= MOD_STM;\n\t\tpriv->write_reg(priv, SJA1000_MOD, mod_reg_val);\n\n\t\tudelay(10);\n\n\t\tstatus = priv->read_reg(priv, SJA1000_MOD);\n\t}\n\n\tnetdev_err(dev, \"setting SJA1000 into normal mode failed!\\n\");\n}\n\n \nstatic void chipset_init(struct net_device *dev)\n{\n\tstruct sja1000_priv *priv = netdev_priv(dev);\n\n\tif (!(priv->flags & SJA1000_QUIRK_NO_CDR_REG))\n\t\t \n\t\tpriv->write_reg(priv, SJA1000_CDR, priv->cdr | CDR_PELICAN);\n\n\t \n\tpriv->write_reg(priv, SJA1000_ACCC0, 0x00);\n\tpriv->write_reg(priv, SJA1000_ACCC1, 0x00);\n\tpriv->write_reg(priv, SJA1000_ACCC2, 0x00);\n\tpriv->write_reg(priv, SJA1000_ACCC3, 0x00);\n\n\tpriv->write_reg(priv, SJA1000_ACCM0, 0xFF);\n\tpriv->write_reg(priv, SJA1000_ACCM1, 0xFF);\n\tpriv->write_reg(priv, SJA1000_ACCM2, 0xFF);\n\tpriv->write_reg(priv, SJA1000_ACCM3, 0xFF);\n\n\tpriv->write_reg(priv, SJA1000_OCR, priv->ocr | OCR_MODE_NORMAL);\n}\n\nstatic void sja1000_start(struct net_device *dev)\n{\n\tstruct sja1000_priv *priv = netdev_priv(dev);\n\n\t \n\tif (priv->can.state != CAN_STATE_STOPPED)\n\t\tset_reset_mode(dev);\n\n\t \n\tif (!(priv->flags & SJA1000_QUIRK_NO_CDR_REG ||\n\t      priv->read_reg(priv, SJA1000_CDR) & CDR_PELICAN))\n\t\tchipset_init(dev);\n\n\t \n\tpriv->write_reg(priv, SJA1000_TXERR, 0x0);\n\tpriv->write_reg(priv, SJA1000_RXERR, 0x0);\n\tpriv->read_reg(priv, SJA1000_ECC);\n\n\t \n\tpriv->read_reg(priv, SJA1000_IR);\n\n\t \n\tset_normal_mode(dev);\n}\n\nstatic int sja1000_set_mode(struct net_device *dev, enum can_mode mode)\n{\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\tsja1000_start(dev);\n\t\tif (netif_queue_stopped(dev))\n\t\t\tnetif_wake_queue(dev);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int sja1000_set_bittiming(struct net_device *dev)\n{\n\tstruct sja1000_priv *priv = netdev_priv(dev);\n\tstruct can_bittiming *bt = &priv->can.bittiming;\n\tu8 btr0, btr1;\n\n\tbtr0 = ((bt->brp - 1) & 0x3f) | (((bt->sjw - 1) & 0x3) << 6);\n\tbtr1 = ((bt->prop_seg + bt->phase_seg1 - 1) & 0xf) |\n\t\t(((bt->phase_seg2 - 1) & 0x7) << 4);\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\tbtr1 |= 0x80;\n\n\tnetdev_info(dev, \"setting BTR0=0x%02x BTR1=0x%02x\\n\", btr0, btr1);\n\n\tpriv->write_reg(priv, SJA1000_BTR0, btr0);\n\tpriv->write_reg(priv, SJA1000_BTR1, btr1);\n\n\treturn 0;\n}\n\nstatic int sja1000_get_berr_counter(const struct net_device *dev,\n\t\t\t\t    struct can_berr_counter *bec)\n{\n\tstruct sja1000_priv *priv = netdev_priv(dev);\n\n\tbec->txerr = priv->read_reg(priv, SJA1000_TXERR);\n\tbec->rxerr = priv->read_reg(priv, SJA1000_RXERR);\n\n\treturn 0;\n}\n\n \nstatic netdev_tx_t sja1000_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *dev)\n{\n\tstruct sja1000_priv *priv = netdev_priv(dev);\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tuint8_t fi;\n\tcanid_t id;\n\tuint8_t dreg;\n\tu8 cmd_reg_val = 0x00;\n\tint i;\n\n\tif (can_dev_dropped_skb(dev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tnetif_stop_queue(dev);\n\n\tfi = can_get_cc_dlc(cf, priv->can.ctrlmode);\n\tid = cf->can_id;\n\n\tif (id & CAN_RTR_FLAG)\n\t\tfi |= SJA1000_FI_RTR;\n\n\tif (id & CAN_EFF_FLAG) {\n\t\tfi |= SJA1000_FI_FF;\n\t\tdreg = SJA1000_EFF_BUF;\n\t\tpriv->write_reg(priv, SJA1000_FI, fi);\n\t\tpriv->write_reg(priv, SJA1000_ID1, (id & 0x1fe00000) >> 21);\n\t\tpriv->write_reg(priv, SJA1000_ID2, (id & 0x001fe000) >> 13);\n\t\tpriv->write_reg(priv, SJA1000_ID3, (id & 0x00001fe0) >> 5);\n\t\tpriv->write_reg(priv, SJA1000_ID4, (id & 0x0000001f) << 3);\n\t} else {\n\t\tdreg = SJA1000_SFF_BUF;\n\t\tpriv->write_reg(priv, SJA1000_FI, fi);\n\t\tpriv->write_reg(priv, SJA1000_ID1, (id & 0x000007f8) >> 3);\n\t\tpriv->write_reg(priv, SJA1000_ID2, (id & 0x00000007) << 5);\n\t}\n\n\tfor (i = 0; i < cf->len; i++)\n\t\tpriv->write_reg(priv, dreg++, cf->data[i]);\n\n\tcan_put_echo_skb(skb, dev, 0, 0);\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)\n\t\tcmd_reg_val |= CMD_AT;\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\tcmd_reg_val |= CMD_SRR;\n\telse\n\t\tcmd_reg_val |= CMD_TR;\n\n\tsja1000_write_cmdreg(priv, cmd_reg_val);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void sja1000_rx(struct net_device *dev)\n{\n\tstruct sja1000_priv *priv = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tuint8_t fi;\n\tuint8_t dreg;\n\tcanid_t id;\n\tint i;\n\n\t \n\tskb = alloc_can_skb(dev, &cf);\n\tif (skb == NULL)\n\t\treturn;\n\n\tfi = priv->read_reg(priv, SJA1000_FI);\n\n\tif (fi & SJA1000_FI_FF) {\n\t\t \n\t\tdreg = SJA1000_EFF_BUF;\n\t\tid = (priv->read_reg(priv, SJA1000_ID1) << 21)\n\t\t    | (priv->read_reg(priv, SJA1000_ID2) << 13)\n\t\t    | (priv->read_reg(priv, SJA1000_ID3) << 5)\n\t\t    | (priv->read_reg(priv, SJA1000_ID4) >> 3);\n\t\tid |= CAN_EFF_FLAG;\n\t} else {\n\t\t \n\t\tdreg = SJA1000_SFF_BUF;\n\t\tid = (priv->read_reg(priv, SJA1000_ID1) << 3)\n\t\t    | (priv->read_reg(priv, SJA1000_ID2) >> 5);\n\t}\n\n\tcan_frame_set_cc_len(cf, fi & 0x0F, priv->can.ctrlmode);\n\tif (fi & SJA1000_FI_RTR) {\n\t\tid |= CAN_RTR_FLAG;\n\t} else {\n\t\tfor (i = 0; i < cf->len; i++)\n\t\t\tcf->data[i] = priv->read_reg(priv, dreg++);\n\n\t\tstats->rx_bytes += cf->len;\n\t}\n\tstats->rx_packets++;\n\n\tcf->can_id = id;\n\n\t \n\tsja1000_write_cmdreg(priv, CMD_RRB);\n\n\tnetif_rx(skb);\n}\n\nstatic irqreturn_t sja1000_reset_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = (struct net_device *)dev_id;\n\n\tnetdev_dbg(dev, \"performing a soft reset upon overrun\\n\");\n\n\tnetif_tx_lock(dev);\n\n\tcan_free_echo_skb(dev, 0, NULL);\n\tsja1000_set_mode(dev, CAN_MODE_START);\n\n\tnetif_tx_unlock(dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sja1000_err(struct net_device *dev, uint8_t isrc, uint8_t status)\n{\n\tstruct sja1000_priv *priv = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tenum can_state state = priv->can.state;\n\tenum can_state rx_state, tx_state;\n\tunsigned int rxerr, txerr;\n\tuint8_t ecc, alc;\n\tint ret = 0;\n\n\tskb = alloc_can_err_skb(dev, &cf);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\ttxerr = priv->read_reg(priv, SJA1000_TXERR);\n\trxerr = priv->read_reg(priv, SJA1000_RXERR);\n\n\tif (isrc & IRQ_DOI) {\n\t\t \n\t\tnetdev_dbg(dev, \"data overrun interrupt\\n\");\n\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\t\tstats->rx_over_errors++;\n\t\tstats->rx_errors++;\n\t\tsja1000_write_cmdreg(priv, CMD_CDO);\t \n\n\t\t \n\t\tif (priv->flags & SJA1000_QUIRK_RESET_ON_OVERRUN)\n\t\t\tret = IRQ_WAKE_THREAD;\n\t}\n\n\tif (isrc & IRQ_EI) {\n\t\t \n\t\tnetdev_dbg(dev, \"error warning interrupt\\n\");\n\n\t\tif (status & SR_BS)\n\t\t\tstate = CAN_STATE_BUS_OFF;\n\t\telse if (status & SR_ES)\n\t\t\tstate = CAN_STATE_ERROR_WARNING;\n\t\telse\n\t\t\tstate = CAN_STATE_ERROR_ACTIVE;\n\t}\n\tif (state != CAN_STATE_BUS_OFF) {\n\t\tcf->can_id |= CAN_ERR_CNT;\n\t\tcf->data[6] = txerr;\n\t\tcf->data[7] = rxerr;\n\t}\n\tif (isrc & IRQ_BEI) {\n\t\t \n\t\tpriv->can.can_stats.bus_error++;\n\t\tstats->rx_errors++;\n\n\t\tecc = priv->read_reg(priv, SJA1000_ECC);\n\n\t\tcf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\n\n\t\t \n\t\tswitch (ecc & ECC_MASK) {\n\t\tcase ECC_BIT:\n\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT;\n\t\t\tbreak;\n\t\tcase ECC_FORM:\n\t\t\tcf->data[2] |= CAN_ERR_PROT_FORM;\n\t\t\tbreak;\n\t\tcase ECC_STUFF:\n\t\t\tcf->data[2] |= CAN_ERR_PROT_STUFF;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tcf->data[3] = ecc & ECC_SEG;\n\n\t\t \n\t\tif ((ecc & ECC_DIR) == 0)\n\t\t\tcf->data[2] |= CAN_ERR_PROT_TX;\n\t}\n\tif (isrc & IRQ_EPI) {\n\t\t \n\t\tnetdev_dbg(dev, \"error passive interrupt\\n\");\n\n\t\tif (state == CAN_STATE_ERROR_PASSIVE)\n\t\t\tstate = CAN_STATE_ERROR_WARNING;\n\t\telse\n\t\t\tstate = CAN_STATE_ERROR_PASSIVE;\n\t}\n\tif (isrc & IRQ_ALI) {\n\t\t \n\t\tnetdev_dbg(dev, \"arbitration lost interrupt\\n\");\n\t\talc = priv->read_reg(priv, SJA1000_ALC);\n\t\tpriv->can.can_stats.arbitration_lost++;\n\t\tcf->can_id |= CAN_ERR_LOSTARB;\n\t\tcf->data[0] = alc & 0x1f;\n\t}\n\n\tif (state != priv->can.state) {\n\t\ttx_state = txerr >= rxerr ? state : 0;\n\t\trx_state = txerr <= rxerr ? state : 0;\n\n\t\tcan_change_state(dev, cf, tx_state, rx_state);\n\n\t\tif(state == CAN_STATE_BUS_OFF)\n\t\t\tcan_bus_off(dev);\n\t}\n\n\tnetif_rx(skb);\n\n\treturn ret;\n}\n\nirqreturn_t sja1000_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = (struct net_device *)dev_id;\n\tstruct sja1000_priv *priv = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tuint8_t isrc, status;\n\tirqreturn_t ret = 0;\n\tint n = 0, err;\n\n\tif (priv->pre_irq)\n\t\tpriv->pre_irq(priv);\n\n\t \n\tif (priv->read_reg(priv, SJA1000_IER) == IRQ_OFF)\n\t\tgoto out;\n\n\twhile ((isrc = priv->read_reg(priv, SJA1000_IR)) &&\n\t       (n < SJA1000_MAX_IRQ)) {\n\n\t\tstatus = priv->read_reg(priv, SJA1000_SR);\n\t\t \n\t\tif (status == 0xFF && sja1000_is_absent(priv))\n\t\t\tgoto out;\n\n\t\tif (isrc & IRQ_WUI)\n\t\t\tnetdev_warn(dev, \"wakeup interrupt\\n\");\n\n\t\tif (isrc & IRQ_TI) {\n\t\t\t \n\t\t\tif (priv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT &&\n\t\t\t    !(status & SR_TCS)) {\n\t\t\t\tstats->tx_errors++;\n\t\t\t\tcan_free_echo_skb(dev, 0, NULL);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tstats->tx_bytes += can_get_echo_skb(dev, 0, NULL);\n\t\t\t\tstats->tx_packets++;\n\t\t\t}\n\t\t\tnetif_wake_queue(dev);\n\t\t}\n\t\tif (isrc & IRQ_RI) {\n\t\t\t \n\t\t\twhile (status & SR_RBS) {\n\t\t\t\tsja1000_rx(dev);\n\t\t\t\tstatus = priv->read_reg(priv, SJA1000_SR);\n\t\t\t\t \n\t\t\t\tif (status == 0xFF && sja1000_is_absent(priv))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (isrc & (IRQ_DOI | IRQ_EI | IRQ_BEI | IRQ_EPI | IRQ_ALI)) {\n\t\t\t \n\t\t\terr = sja1000_err(dev, isrc, status);\n\t\t\tif (err == IRQ_WAKE_THREAD)\n\t\t\t\tret = err;\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\t\tn++;\n\t}\nout:\n\tif (!ret)\n\t\tret = (n) ? IRQ_HANDLED : IRQ_NONE;\n\n\tif (priv->post_irq)\n\t\tpriv->post_irq(priv);\n\n\tif (n >= SJA1000_MAX_IRQ)\n\t\tnetdev_dbg(dev, \"%d messages handled in ISR\", n);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sja1000_interrupt);\n\nstatic int sja1000_open(struct net_device *dev)\n{\n\tstruct sja1000_priv *priv = netdev_priv(dev);\n\tint err;\n\n\t \n\tset_reset_mode(dev);\n\n\t \n\terr = open_candev(dev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!(priv->flags & SJA1000_CUSTOM_IRQ_HANDLER)) {\n\t\terr = request_threaded_irq(dev->irq, sja1000_interrupt,\n\t\t\t\t\t   sja1000_reset_interrupt,\n\t\t\t\t\t   priv->irq_flags, dev->name, (void *)dev);\n\t\tif (err) {\n\t\t\tclose_candev(dev);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\t \n\tsja1000_start(dev);\n\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\nstatic int sja1000_close(struct net_device *dev)\n{\n\tstruct sja1000_priv *priv = netdev_priv(dev);\n\n\tnetif_stop_queue(dev);\n\tset_reset_mode(dev);\n\n\tif (!(priv->flags & SJA1000_CUSTOM_IRQ_HANDLER))\n\t\tfree_irq(dev->irq, (void *)dev);\n\n\tclose_candev(dev);\n\n\treturn 0;\n}\n\nstruct net_device *alloc_sja1000dev(int sizeof_priv)\n{\n\tstruct net_device *dev;\n\tstruct sja1000_priv *priv;\n\n\tdev = alloc_candev(sizeof(struct sja1000_priv) + sizeof_priv,\n\t\tSJA1000_ECHO_SKB_MAX);\n\tif (!dev)\n\t\treturn NULL;\n\n\tpriv = netdev_priv(dev);\n\n\tpriv->dev = dev;\n\tpriv->can.bittiming_const = &sja1000_bittiming_const;\n\tpriv->can.do_set_bittiming = sja1000_set_bittiming;\n\tpriv->can.do_set_mode = sja1000_set_mode;\n\tpriv->can.do_get_berr_counter = sja1000_get_berr_counter;\n\tpriv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |\n\t\t\t\t       CAN_CTRLMODE_LISTENONLY |\n\t\t\t\t       CAN_CTRLMODE_3_SAMPLES |\n\t\t\t\t       CAN_CTRLMODE_ONE_SHOT |\n\t\t\t\t       CAN_CTRLMODE_BERR_REPORTING |\n\t\t\t\t       CAN_CTRLMODE_PRESUME_ACK |\n\t\t\t\t       CAN_CTRLMODE_CC_LEN8_DLC;\n\n\tspin_lock_init(&priv->cmdreg_lock);\n\n\tif (sizeof_priv)\n\t\tpriv->priv = (void *)priv + sizeof(struct sja1000_priv);\n\n\treturn dev;\n}\nEXPORT_SYMBOL_GPL(alloc_sja1000dev);\n\nvoid free_sja1000dev(struct net_device *dev)\n{\n\tfree_candev(dev);\n}\nEXPORT_SYMBOL_GPL(free_sja1000dev);\n\nstatic const struct net_device_ops sja1000_netdev_ops = {\n\t.ndo_open\t= sja1000_open,\n\t.ndo_stop\t= sja1000_close,\n\t.ndo_start_xmit\t= sja1000_start_xmit,\n\t.ndo_change_mtu\t= can_change_mtu,\n};\n\nstatic const struct ethtool_ops sja1000_ethtool_ops = {\n\t.get_ts_info = ethtool_op_get_ts_info,\n};\n\nint register_sja1000dev(struct net_device *dev)\n{\n\tif (!sja1000_probe_chip(dev))\n\t\treturn -ENODEV;\n\n\tdev->flags |= IFF_ECHO;\t \n\tdev->netdev_ops = &sja1000_netdev_ops;\n\tdev->ethtool_ops = &sja1000_ethtool_ops;\n\n\tset_reset_mode(dev);\n\tchipset_init(dev);\n\n\treturn register_candev(dev);\n}\nEXPORT_SYMBOL_GPL(register_sja1000dev);\n\nvoid unregister_sja1000dev(struct net_device *dev)\n{\n\tset_reset_mode(dev);\n\tunregister_candev(dev);\n}\nEXPORT_SYMBOL_GPL(unregister_sja1000dev);\n\nstatic __init int sja1000_init(void)\n{\n\tprintk(KERN_INFO \"%s CAN netdevice driver\\n\", DRV_NAME);\n\n\treturn 0;\n}\n\nmodule_init(sja1000_init);\n\nstatic __exit void sja1000_exit(void)\n{\n\tprintk(KERN_INFO \"%s: driver removed\\n\", DRV_NAME);\n}\n\nmodule_exit(sja1000_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}