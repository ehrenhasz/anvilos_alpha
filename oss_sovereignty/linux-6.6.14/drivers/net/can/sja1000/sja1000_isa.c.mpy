{
  "module_name": "sja1000_isa.c",
  "hash_id": "030a6726fd9e9803d7e0f56a1cf863c33d4d6ae6c568ba090c0d725faabfec26",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/sja1000/sja1000_isa.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/can/dev.h>\n#include <linux/can/platform/sja1000.h>\n\n#include \"sja1000.h\"\n\n#define DRV_NAME \"sja1000_isa\"\n\n#define MAXDEV 8\n\nMODULE_AUTHOR(\"Wolfgang Grandegger <wg@grandegger.com>\");\nMODULE_DESCRIPTION(\"Socket-CAN driver for SJA1000 on the ISA bus\");\nMODULE_LICENSE(\"GPL v2\");\n\n#define CLK_DEFAULT\t16000000\t \n#define CDR_DEFAULT\t(CDR_CBP | CDR_CLK_OFF)\n#define OCR_DEFAULT\tOCR_TX0_PUSHPULL\n\nstatic unsigned long port[MAXDEV];\nstatic unsigned long mem[MAXDEV];\nstatic int irq[MAXDEV];\nstatic int clk[MAXDEV];\nstatic unsigned char cdr[MAXDEV] = {[0 ... (MAXDEV - 1)] = 0xff};\nstatic unsigned char ocr[MAXDEV] = {[0 ... (MAXDEV - 1)] = 0xff};\nstatic int indirect[MAXDEV] = {[0 ... (MAXDEV - 1)] = -1};\nstatic spinlock_t indirect_lock[MAXDEV];   \n\nmodule_param_hw_array(port, ulong, ioport, NULL, 0444);\nMODULE_PARM_DESC(port, \"I/O port number\");\n\nmodule_param_hw_array(mem, ulong, iomem, NULL, 0444);\nMODULE_PARM_DESC(mem, \"I/O memory address\");\n\nmodule_param_hw_array(indirect, int, ioport, NULL, 0444);\nMODULE_PARM_DESC(indirect, \"Indirect access via address and data port\");\n\nmodule_param_hw_array(irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(irq, \"IRQ number\");\n\nmodule_param_array(clk, int, NULL, 0444);\nMODULE_PARM_DESC(clk, \"External oscillator clock frequency \"\n\t\t \"(default=16000000 [16 MHz])\");\n\nmodule_param_array(cdr, byte, NULL, 0444);\nMODULE_PARM_DESC(cdr, \"Clock divider register \"\n\t\t \"(default=0x48 [CDR_CBP | CDR_CLK_OFF])\");\n\nmodule_param_array(ocr, byte, NULL, 0444);\nMODULE_PARM_DESC(ocr, \"Output control register \"\n\t\t \"(default=0x18 [OCR_TX0_PUSHPULL])\");\n\n#define SJA1000_IOSIZE          0x20\n#define SJA1000_IOSIZE_INDIRECT 0x02\n\nstatic struct platform_device *sja1000_isa_devs[MAXDEV];\n\nstatic u8 sja1000_isa_mem_read_reg(const struct sja1000_priv *priv, int reg)\n{\n\treturn readb(priv->reg_base + reg);\n}\n\nstatic void sja1000_isa_mem_write_reg(const struct sja1000_priv *priv,\n\t\t\t\t      int reg, u8 val)\n{\n\twriteb(val, priv->reg_base + reg);\n}\n\nstatic u8 sja1000_isa_port_read_reg(const struct sja1000_priv *priv, int reg)\n{\n\treturn inb((unsigned long)priv->reg_base + reg);\n}\n\nstatic void sja1000_isa_port_write_reg(const struct sja1000_priv *priv,\n\t\t\t\t       int reg, u8 val)\n{\n\toutb(val, (unsigned long)priv->reg_base + reg);\n}\n\nstatic u8 sja1000_isa_port_read_reg_indirect(const struct sja1000_priv *priv,\n\t\t\t\t\t     int reg)\n{\n\tunsigned long flags, base = (unsigned long)priv->reg_base;\n\tu8 readval;\n\n\tspin_lock_irqsave(&indirect_lock[priv->dev->dev_id], flags);\n\toutb(reg, base);\n\treadval = inb(base + 1);\n\tspin_unlock_irqrestore(&indirect_lock[priv->dev->dev_id], flags);\n\n\treturn readval;\n}\n\nstatic void sja1000_isa_port_write_reg_indirect(const struct sja1000_priv *priv,\n\t\t\t\t\t\tint reg, u8 val)\n{\n\tunsigned long flags, base = (unsigned long)priv->reg_base;\n\n\tspin_lock_irqsave(&indirect_lock[priv->dev->dev_id], flags);\n\toutb(reg, base);\n\toutb(val, base + 1);\n\tspin_unlock_irqrestore(&indirect_lock[priv->dev->dev_id], flags);\n}\n\nstatic int sja1000_isa_probe(struct platform_device *pdev)\n{\n\tstruct net_device *dev;\n\tstruct sja1000_priv *priv;\n\tvoid __iomem *base = NULL;\n\tint iosize = SJA1000_IOSIZE;\n\tint idx = pdev->id;\n\tint err;\n\n\tdev_dbg(&pdev->dev, \"probing idx=%d: port=%#lx, mem=%#lx, irq=%d\\n\",\n\t\tidx, port[idx], mem[idx], irq[idx]);\n\n\tif (mem[idx]) {\n\t\tif (!request_mem_region(mem[idx], iosize, DRV_NAME)) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto exit;\n\t\t}\n\t\tbase = ioremap(mem[idx], iosize);\n\t\tif (!base) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit_release;\n\t\t}\n\t} else {\n\t\tif (indirect[idx] > 0 ||\n\t\t    (indirect[idx] == -1 && indirect[0] > 0))\n\t\t\tiosize = SJA1000_IOSIZE_INDIRECT;\n\t\tif (!request_region(port[idx], iosize, DRV_NAME)) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tdev = alloc_sja1000dev(0);\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto exit_unmap;\n\t}\n\tpriv = netdev_priv(dev);\n\n\tdev->irq = irq[idx];\n\tpriv->irq_flags = IRQF_SHARED;\n\tif (mem[idx]) {\n\t\tpriv->reg_base = base;\n\t\tdev->base_addr = mem[idx];\n\t\tpriv->read_reg = sja1000_isa_mem_read_reg;\n\t\tpriv->write_reg = sja1000_isa_mem_write_reg;\n\t} else {\n\t\tpriv->reg_base = (void __iomem *)port[idx];\n\t\tdev->base_addr = port[idx];\n\n\t\tif (iosize == SJA1000_IOSIZE_INDIRECT) {\n\t\t\tpriv->read_reg = sja1000_isa_port_read_reg_indirect;\n\t\t\tpriv->write_reg = sja1000_isa_port_write_reg_indirect;\n\t\t\tspin_lock_init(&indirect_lock[idx]);\n\t\t} else {\n\t\t\tpriv->read_reg = sja1000_isa_port_read_reg;\n\t\t\tpriv->write_reg = sja1000_isa_port_write_reg;\n\t\t}\n\t}\n\n\tif (clk[idx])\n\t\tpriv->can.clock.freq = clk[idx] / 2;\n\telse if (clk[0])\n\t\tpriv->can.clock.freq = clk[0] / 2;\n\telse\n\t\tpriv->can.clock.freq = CLK_DEFAULT / 2;\n\n\tif (ocr[idx] != 0xff)\n\t\tpriv->ocr = ocr[idx];\n\telse if (ocr[0] != 0xff)\n\t\tpriv->ocr = ocr[0];\n\telse\n\t\tpriv->ocr = OCR_DEFAULT;\n\n\tif (cdr[idx] != 0xff)\n\t\tpriv->cdr = cdr[idx];\n\telse if (cdr[0] != 0xff)\n\t\tpriv->cdr = cdr[0];\n\telse\n\t\tpriv->cdr = CDR_DEFAULT;\n\n\tplatform_set_drvdata(pdev, dev);\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\tdev->dev_id = idx;\n\n\terr = register_sja1000dev(dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"registering %s failed (err=%d)\\n\",\n\t\t\tDRV_NAME, err);\n\t\tgoto exit_free;\n\t}\n\n\tdev_info(&pdev->dev, \"%s device registered (reg_base=0x%p, irq=%d)\\n\",\n\t\t DRV_NAME, priv->reg_base, dev->irq);\n\treturn 0;\n\nexit_free:\n\tfree_sja1000dev(dev);\nexit_unmap:\n\tif (mem[idx])\n\t\tiounmap(base);\nexit_release:\n\tif (mem[idx])\n\t\trelease_mem_region(mem[idx], iosize);\n\telse\n\t\trelease_region(port[idx], iosize);\nexit:\n\treturn err;\n}\n\nstatic void sja1000_isa_remove(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\tstruct sja1000_priv *priv = netdev_priv(dev);\n\tint idx = pdev->id;\n\n\tunregister_sja1000dev(dev);\n\n\tif (mem[idx]) {\n\t\tiounmap(priv->reg_base);\n\t\trelease_mem_region(mem[idx], SJA1000_IOSIZE);\n\t} else {\n\t\tif (priv->read_reg == sja1000_isa_port_read_reg_indirect)\n\t\t\trelease_region(port[idx], SJA1000_IOSIZE_INDIRECT);\n\t\telse\n\t\t\trelease_region(port[idx], SJA1000_IOSIZE);\n\t}\n\tfree_sja1000dev(dev);\n}\n\nstatic struct platform_driver sja1000_isa_driver = {\n\t.probe = sja1000_isa_probe,\n\t.remove_new = sja1000_isa_remove,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t},\n};\n\nstatic int __init sja1000_isa_init(void)\n{\n\tint idx, err;\n\n\tfor (idx = 0; idx < MAXDEV; idx++) {\n\t\tif ((port[idx] || mem[idx]) && irq[idx]) {\n\t\t\tsja1000_isa_devs[idx] =\n\t\t\t\tplatform_device_alloc(DRV_NAME, idx);\n\t\t\tif (!sja1000_isa_devs[idx]) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto exit_free_devices;\n\t\t\t}\n\t\t\terr = platform_device_add(sja1000_isa_devs[idx]);\n\t\t\tif (err) {\n\t\t\t\tplatform_device_put(sja1000_isa_devs[idx]);\n\t\t\t\tgoto exit_free_devices;\n\t\t\t}\n\t\t\tpr_debug(\"%s: platform device %d: port=%#lx, mem=%#lx, \"\n\t\t\t\t \"irq=%d\\n\",\n\t\t\t\t DRV_NAME, idx, port[idx], mem[idx], irq[idx]);\n\t\t} else if (idx == 0 || port[idx] || mem[idx]) {\n\t\t\t\tpr_err(\"%s: insufficient parameters supplied\\n\",\n\t\t\t\t       DRV_NAME);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit_free_devices;\n\t\t}\n\t}\n\n\terr = platform_driver_register(&sja1000_isa_driver);\n\tif (err)\n\t\tgoto exit_free_devices;\n\n\tpr_info(\"Legacy %s driver for max. %d devices registered\\n\",\n\t\tDRV_NAME, MAXDEV);\n\n\treturn 0;\n\nexit_free_devices:\n\twhile (--idx >= 0) {\n\t\tif (sja1000_isa_devs[idx])\n\t\t\tplatform_device_unregister(sja1000_isa_devs[idx]);\n\t}\n\n\treturn err;\n}\n\nstatic void __exit sja1000_isa_exit(void)\n{\n\tint idx;\n\n\tplatform_driver_unregister(&sja1000_isa_driver);\n\tfor (idx = 0; idx < MAXDEV; idx++) {\n\t\tif (sja1000_isa_devs[idx])\n\t\t\tplatform_device_unregister(sja1000_isa_devs[idx]);\n\t}\n}\n\nmodule_init(sja1000_isa_init);\nmodule_exit(sja1000_isa_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}