{
  "module_name": "peak_pci.c",
  "hash_id": "e8126baa1dc6a35b6ae54258004e0be5c707bd52e7b245c4cfc5922b1f2e763c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/sja1000/peak_pci.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/io.h>\n#include <linux/i2c.h>\n#include <linux/i2c-algo-bit.h>\n#include <linux/can.h>\n#include <linux/can/dev.h>\n\n#include \"sja1000.h\"\n\nMODULE_AUTHOR(\"Stephane Grosjean <s.grosjean@peak-system.com>\");\nMODULE_DESCRIPTION(\"Socket-CAN driver for PEAK PCAN PCI family cards\");\nMODULE_LICENSE(\"GPL v2\");\n\n#define DRV_NAME  \"peak_pci\"\n\n \n#define PEAK_VER_REG1\t\t0x40\n#define PEAK_VER_REG2\t\t0x44\n\nstruct peak_pciec_card;\nstruct peak_pci_chan {\n\tvoid __iomem *cfg_base;\t\t \n\tstruct net_device *prev_dev;\t \n\tu16 icr_mask;\t\t\t \n\tstruct peak_pciec_card *pciec_card;\t \n};\n\n#define PEAK_PCI_CAN_CLOCK\t(16000000 / 2)\n\n#define PEAK_PCI_CDR\t\t(CDR_CBP | CDR_CLKOUT_MASK)\n#define PEAK_PCI_OCR\t\tOCR_TX0_PUSHPULL\n\n \n#define PITA_ICR\t\t0x00\t \n#define PITA_GPIOICR\t\t0x18\t \n#define PITA_MISC\t\t0x1C\t \n\n#define PEAK_PCI_CFG_SIZE\t0x1000\t \n#define PEAK_PCI_CHAN_SIZE\t0x0400\t \n\n#define PEAK_PCI_VENDOR_ID\t0x001C\t \n#define PEAK_PCI_DEVICE_ID\t0x0001\t \n#define PEAK_PCIEC_DEVICE_ID\t0x0002\t \n#define PEAK_PCIE_DEVICE_ID\t0x0003\t \n#define PEAK_CPCI_DEVICE_ID\t0x0004\t \n#define PEAK_MPCI_DEVICE_ID\t0x0005\t \n#define PEAK_PC_104P_DEVICE_ID\t0x0006\t \n#define PEAK_PCI_104E_DEVICE_ID\t0x0007\t \n#define PEAK_MPCIE_DEVICE_ID\t0x0008\t \n#define PEAK_PCIE_OEM_ID\t0x0009\t \n#define PEAK_PCIEC34_DEVICE_ID\t0x000A\t \n\n#define PEAK_PCI_CHAN_MAX\t4\n\nstatic const u16 peak_pci_icr_masks[PEAK_PCI_CHAN_MAX] = {\n\t0x02, 0x01, 0x40, 0x80\n};\n\nstatic const struct pci_device_id peak_pci_tbl[] = {\n\t{\n\t\tPEAK_PCI_VENDOR_ID, PEAK_PCI_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID,\n\t\t.driver_data = (kernel_ulong_t)\"PCAN-PCI\",\n\t}, {\n\t\tPEAK_PCI_VENDOR_ID, PEAK_PCIE_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID,\n\t\t.driver_data = (kernel_ulong_t)\"PCAN-PCI Express\",\n\t}, {\n\t\tPEAK_PCI_VENDOR_ID, PEAK_MPCI_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID,\n\t\t.driver_data = (kernel_ulong_t)\"PCAN-miniPCI\",\n\t}, {\n\t\tPEAK_PCI_VENDOR_ID, PEAK_MPCIE_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID,\n\t\t.driver_data = (kernel_ulong_t)\"PCAN-miniPCIe\",\n\t}, {\n\t\tPEAK_PCI_VENDOR_ID, PEAK_PC_104P_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID,\n\t\t.driver_data = (kernel_ulong_t)\"PCAN-PC/104-Plus Quad\",\n\t}, {\n\t\tPEAK_PCI_VENDOR_ID, PEAK_PCI_104E_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID,\n\t\t.driver_data = (kernel_ulong_t)\"PCAN-PCI/104-Express\",\n\t}, {\n\t\tPEAK_PCI_VENDOR_ID, PEAK_CPCI_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID,\n\t\t.driver_data = (kernel_ulong_t)\"PCAN-cPCI\",\n\t}, {\n\t\tPEAK_PCI_VENDOR_ID, PEAK_PCIE_OEM_ID, PCI_ANY_ID, PCI_ANY_ID,\n\t\t.driver_data = (kernel_ulong_t)\"PCAN-Chip PCIe\",\n\t},\n#ifdef CONFIG_CAN_PEAK_PCIEC\n\t{\n\t\tPEAK_PCI_VENDOR_ID, PEAK_PCIEC_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID,\n\t\t.driver_data = (kernel_ulong_t)\"PCAN-ExpressCard\",\n\t}, {\n\t\tPEAK_PCI_VENDOR_ID, PEAK_PCIEC34_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID,\n\t\t.driver_data = (kernel_ulong_t)\"PCAN-ExpressCard 34\",\n\t},\n#endif\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(pci, peak_pci_tbl);\n\n#ifdef CONFIG_CAN_PEAK_PCIEC\n \n\n \n#define PITA_GPOUT\t\t0x18\t \n#define PITA_GPIN\t\t0x19\t \n#define PITA_GPOEN\t\t0x1A\t \n\n \n#define PITA_GPIN_SCL\t\t0x01\t \n#define PITA_GPIN_SDA\t\t0x04\t \n\n#define PCA9553_1_SLAVEADDR\t(0xC4 >> 1)\n\n \nenum {\n\tPCA9553_LOW,\n\tPCA9553_HIGHZ,\n\tPCA9553_PWM0,\n\tPCA9553_PWM1\n};\n\n \n#define PCA9553_ON\t\tPCA9553_LOW\n#define PCA9553_OFF\t\tPCA9553_HIGHZ\n#define PCA9553_SLOW\t\tPCA9553_PWM0\n#define PCA9553_FAST\t\tPCA9553_PWM1\n\n#define PCA9553_LED(c)\t\t(1 << (c))\n#define PCA9553_LED_STATE(s, c)\t((s) << ((c) << 1))\n\n#define PCA9553_LED_ON(c)\tPCA9553_LED_STATE(PCA9553_ON, c)\n#define PCA9553_LED_OFF(c)\tPCA9553_LED_STATE(PCA9553_OFF, c)\n#define PCA9553_LED_SLOW(c)\tPCA9553_LED_STATE(PCA9553_SLOW, c)\n#define PCA9553_LED_FAST(c)\tPCA9553_LED_STATE(PCA9553_FAST, c)\n#define PCA9553_LED_MASK(c)\tPCA9553_LED_STATE(0x03, c)\n\n#define PCA9553_LED_OFF_ALL\t(PCA9553_LED_OFF(0) | PCA9553_LED_OFF(1))\n\n#define PCA9553_LS0_INIT\t0x40  \n\nstruct peak_pciec_chan {\n\tstruct net_device *netdev;\n\tunsigned long prev_rx_bytes;\n\tunsigned long prev_tx_bytes;\n};\n\nstruct peak_pciec_card {\n\tvoid __iomem *cfg_base;\t\t \n\tvoid __iomem *reg_base;\t\t \n\tu8 led_cache;\t\t\t \n\n\t \n\tstruct i2c_algo_bit_data i2c_bit;\n\tstruct i2c_adapter led_chip;\n\tstruct delayed_work led_work;\t \n\tint chan_count;\n\tstruct peak_pciec_chan channel[PEAK_PCI_CHAN_MAX];\n};\n\n \nstatic void peak_pci_write_reg(const struct sja1000_priv *priv,\n\t\t\t       int port, u8 val);\n\nstatic inline void pita_set_scl_highz(struct peak_pciec_card *card)\n{\n\tu8 gp_outen = readb(card->cfg_base + PITA_GPOEN) & ~PITA_GPIN_SCL;\n\n\twriteb(gp_outen, card->cfg_base + PITA_GPOEN);\n}\n\nstatic inline void pita_set_sda_highz(struct peak_pciec_card *card)\n{\n\tu8 gp_outen = readb(card->cfg_base + PITA_GPOEN) & ~PITA_GPIN_SDA;\n\n\twriteb(gp_outen, card->cfg_base + PITA_GPOEN);\n}\n\nstatic void peak_pciec_init_pita_gpio(struct peak_pciec_card *card)\n{\n\t \n\tpita_set_scl_highz(card);\n\tpita_set_sda_highz(card);\n}\n\nstatic void pita_setsda(void *data, int state)\n{\n\tstruct peak_pciec_card *card = (struct peak_pciec_card *)data;\n\tu8 gp_out, gp_outen;\n\n\t \n\tgp_out = readb(card->cfg_base + PITA_GPOUT) & ~PITA_GPIN_SDA;\n\twriteb(gp_out, card->cfg_base + PITA_GPOUT);\n\n\t \n\tgp_outen = readb(card->cfg_base + PITA_GPOEN);\n\tif (state)\n\t\tgp_outen &= ~PITA_GPIN_SDA;\n\telse\n\t\tgp_outen |= PITA_GPIN_SDA;\n\n\twriteb(gp_outen, card->cfg_base + PITA_GPOEN);\n}\n\nstatic void pita_setscl(void *data, int state)\n{\n\tstruct peak_pciec_card *card = (struct peak_pciec_card *)data;\n\tu8 gp_out, gp_outen;\n\n\t \n\tgp_out = readb(card->cfg_base + PITA_GPOUT) & ~PITA_GPIN_SCL;\n\twriteb(gp_out, card->cfg_base + PITA_GPOUT);\n\n\t \n\tgp_outen = readb(card->cfg_base + PITA_GPOEN);\n\tif (state)\n\t\tgp_outen &= ~PITA_GPIN_SCL;\n\telse\n\t\tgp_outen |= PITA_GPIN_SCL;\n\n\twriteb(gp_outen, card->cfg_base + PITA_GPOEN);\n}\n\nstatic int pita_getsda(void *data)\n{\n\tstruct peak_pciec_card *card = (struct peak_pciec_card *)data;\n\n\t \n\tpita_set_sda_highz(card);\n\n\treturn (readb(card->cfg_base + PITA_GPIN) & PITA_GPIN_SDA) ? 1 : 0;\n}\n\nstatic int pita_getscl(void *data)\n{\n\tstruct peak_pciec_card *card = (struct peak_pciec_card *)data;\n\n\t \n\tpita_set_scl_highz(card);\n\n\treturn (readb(card->cfg_base + PITA_GPIN) & PITA_GPIN_SCL) ? 1 : 0;\n}\n\n \nstatic int peak_pciec_write_pca9553(struct peak_pciec_card *card,\n\t\t\t\t    u8 offset, u8 data)\n{\n\tu8 buffer[2] = {\n\t\toffset,\n\t\tdata\n\t};\n\tstruct i2c_msg msg = {\n\t\t.addr = PCA9553_1_SLAVEADDR,\n\t\t.len = 2,\n\t\t.buf = buffer,\n\t};\n\tint ret;\n\n\t \n\tif (offset == 5 && data == card->led_cache)\n\t\treturn 0;\n\n\tret = i2c_transfer(&card->led_chip, &msg, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (offset == 5)\n\t\tcard->led_cache = data;\n\n\treturn 0;\n}\n\n \nstatic void peak_pciec_led_work(struct work_struct *work)\n{\n\tstruct peak_pciec_card *card =\n\t\tcontainer_of(work, struct peak_pciec_card, led_work.work);\n\tstruct net_device *netdev;\n\tu8 new_led = card->led_cache;\n\tint i, up_count = 0;\n\n\t \n\tfor (i = 0; i < card->chan_count; i++) {\n\t\t \n\t\tnew_led &= ~PCA9553_LED_MASK(i);\n\t\tnew_led |= PCA9553_LED_ON(i);\n\n\t\tnetdev = card->channel[i].netdev;\n\t\tif (!netdev || !(netdev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tup_count++;\n\n\t\t \n\t\tnew_led &= ~PCA9553_LED_MASK(i);\n\t\tnew_led |= PCA9553_LED_SLOW(i);\n\n\t\t \n\t\tif (netdev->stats.rx_bytes != card->channel[i].prev_rx_bytes) {\n\t\t\tcard->channel[i].prev_rx_bytes = netdev->stats.rx_bytes;\n\t\t\tnew_led &= ~PCA9553_LED_MASK(i);\n\t\t\tnew_led |= PCA9553_LED_FAST(i);\n\t\t}\n\t\tif (netdev->stats.tx_bytes != card->channel[i].prev_tx_bytes) {\n\t\t\tcard->channel[i].prev_tx_bytes = netdev->stats.tx_bytes;\n\t\t\tnew_led &= ~PCA9553_LED_MASK(i);\n\t\t\tnew_led |= PCA9553_LED_FAST(i);\n\t\t}\n\t}\n\n\t \n\tpeak_pciec_write_pca9553(card, 5, new_led);\n\n\t \n\tif (up_count)\n\t\tschedule_delayed_work(&card->led_work, HZ);\n}\n\n \nstatic void peak_pciec_set_leds(struct peak_pciec_card *card, u8 led_mask, u8 s)\n{\n\tu8 new_led = card->led_cache;\n\tint i;\n\n\t \n\tfor (i = 0; i < card->chan_count; i++)\n\t\tif (led_mask & PCA9553_LED(i)) {\n\t\t\tnew_led &= ~PCA9553_LED_MASK(i);\n\t\t\tnew_led |= PCA9553_LED_STATE(s, i);\n\t\t}\n\n\t \n\tpeak_pciec_write_pca9553(card, 5, new_led);\n}\n\n \nstatic void peak_pciec_start_led_work(struct peak_pciec_card *card)\n{\n\tschedule_delayed_work(&card->led_work, HZ);\n}\n\n \nstatic void peak_pciec_stop_led_work(struct peak_pciec_card *card)\n{\n\tcancel_delayed_work_sync(&card->led_work);\n}\n\n \nstatic int peak_pciec_init_leds(struct peak_pciec_card *card)\n{\n\tint err;\n\n\t \n\terr = peak_pciec_write_pca9553(card, 1, 44 / 1);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = peak_pciec_write_pca9553(card, 2, 0x80);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = peak_pciec_write_pca9553(card, 3, 44 / 5);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = peak_pciec_write_pca9553(card, 4, 0x80);\n\tif (err)\n\t\treturn err;\n\n\t \n\treturn peak_pciec_write_pca9553(card, 5, PCA9553_LS0_INIT);\n}\n\n \nstatic void peak_pciec_leds_exit(struct peak_pciec_card *card)\n{\n\t \n\tpeak_pciec_write_pca9553(card, 5, PCA9553_LED_OFF_ALL);\n}\n\n \nstatic void peak_pciec_write_reg(const struct sja1000_priv *priv,\n\t\t\t\t int port, u8 val)\n{\n\tstruct peak_pci_chan *chan = priv->priv;\n\tstruct peak_pciec_card *card = chan->pciec_card;\n\tint c = (priv->reg_base - card->reg_base) / PEAK_PCI_CHAN_SIZE;\n\n\t \n\tif (port == SJA1000_MOD)\n\t\tswitch (val) {\n\t\tcase MOD_RM:\n\t\t\t \n\t\t\tpeak_pciec_set_leds(card, PCA9553_LED(c), PCA9553_ON);\n\t\t\tbreak;\n\t\tcase 0x00:\n\t\t\t \n\t\t\tpeak_pciec_set_leds(card, PCA9553_LED(c), PCA9553_SLOW);\n\t\t\tpeak_pciec_start_led_work(card);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t \n\tpeak_pci_write_reg(priv, port, val);\n}\n\nstatic const struct i2c_algo_bit_data peak_pciec_i2c_bit_ops = {\n\t.setsda\t= pita_setsda,\n\t.setscl\t= pita_setscl,\n\t.getsda\t= pita_getsda,\n\t.getscl\t= pita_getscl,\n\t.udelay\t= 10,\n\t.timeout = HZ,\n};\n\nstatic int peak_pciec_probe(struct pci_dev *pdev, struct net_device *dev)\n{\n\tstruct sja1000_priv *priv = netdev_priv(dev);\n\tstruct peak_pci_chan *chan = priv->priv;\n\tstruct peak_pciec_card *card;\n\tint err;\n\n\t \n\tif (chan->prev_dev) {\n\t\tstruct sja1000_priv *prev_priv = netdev_priv(chan->prev_dev);\n\t\tstruct peak_pci_chan *prev_chan = prev_priv->priv;\n\n\t\tcard = prev_chan->pciec_card;\n\t\tif (!card)\n\t\t\treturn -ENODEV;\n\n\t \n\t} else {\n\t\t \n\t\tcard = kzalloc(sizeof(*card), GFP_KERNEL);\n\t\tif (!card)\n\t\t\treturn -ENOMEM;\n\n\t\tcard->cfg_base = chan->cfg_base;\n\t\tcard->reg_base = priv->reg_base;\n\n\t\tcard->led_chip.owner = THIS_MODULE;\n\t\tcard->led_chip.dev.parent = &pdev->dev;\n\t\tcard->led_chip.algo_data = &card->i2c_bit;\n\t\tstrncpy(card->led_chip.name, \"peak_i2c\",\n\t\t\tsizeof(card->led_chip.name));\n\n\t\tcard->i2c_bit = peak_pciec_i2c_bit_ops;\n\t\tcard->i2c_bit.udelay = 10;\n\t\tcard->i2c_bit.timeout = HZ;\n\t\tcard->i2c_bit.data = card;\n\n\t\tpeak_pciec_init_pita_gpio(card);\n\n\t\terr = i2c_bit_add_bus(&card->led_chip);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"i2c init failed\\n\");\n\t\t\tgoto pciec_init_err_1;\n\t\t}\n\n\t\terr = peak_pciec_init_leds(card);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"leds hardware init failed\\n\");\n\t\t\tgoto pciec_init_err_2;\n\t\t}\n\n\t\tINIT_DELAYED_WORK(&card->led_work, peak_pciec_led_work);\n\t\t \n\t\tpriv->write_reg = peak_pciec_write_reg;\n\t}\n\n\tchan->pciec_card = card;\n\tcard->channel[card->chan_count++].netdev = dev;\n\n\treturn 0;\n\npciec_init_err_2:\n\ti2c_del_adapter(&card->led_chip);\n\npciec_init_err_1:\n\tpeak_pciec_init_pita_gpio(card);\n\tkfree(card);\n\n\treturn err;\n}\n\nstatic void peak_pciec_remove(struct peak_pciec_card *card)\n{\n\tpeak_pciec_stop_led_work(card);\n\tpeak_pciec_leds_exit(card);\n\ti2c_del_adapter(&card->led_chip);\n\tpeak_pciec_init_pita_gpio(card);\n\tkfree(card);\n}\n\n#else  \n\n \nstatic inline int peak_pciec_probe(struct pci_dev *pdev, struct net_device *dev)\n{\n\treturn -ENODEV;\n}\n\nstatic inline void peak_pciec_remove(struct peak_pciec_card *card)\n{\n}\n#endif  \n\nstatic u8 peak_pci_read_reg(const struct sja1000_priv *priv, int port)\n{\n\treturn readb(priv->reg_base + (port << 2));\n}\n\nstatic void peak_pci_write_reg(const struct sja1000_priv *priv,\n\t\t\t       int port, u8 val)\n{\n\twriteb(val, priv->reg_base + (port << 2));\n}\n\nstatic void peak_pci_post_irq(const struct sja1000_priv *priv)\n{\n\tstruct peak_pci_chan *chan = priv->priv;\n\tu16 icr;\n\n\t \n\ticr = readw(chan->cfg_base + PITA_ICR);\n\tif (icr & chan->icr_mask)\n\t\twritew(chan->icr_mask, chan->cfg_base + PITA_ICR);\n}\n\nstatic int peak_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstruct sja1000_priv *priv;\n\tstruct peak_pci_chan *chan;\n\tstruct net_device *dev, *prev_dev;\n\tvoid __iomem *cfg_base, *reg_base;\n\tu16 sub_sys_id, icr;\n\tint i, err, channels;\n\tchar fw_str[14] = \"\";\n\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\treturn err;\n\n\terr = pci_request_regions(pdev, DRV_NAME);\n\tif (err)\n\t\tgoto failure_disable_pci;\n\n\terr = pci_read_config_word(pdev, 0x2e, &sub_sys_id);\n\tif (err)\n\t\tgoto failure_release_regions;\n\n\tdev_dbg(&pdev->dev, \"probing device %04x:%04x:%04x\\n\",\n\t\tpdev->vendor, pdev->device, sub_sys_id);\n\n\terr = pci_write_config_word(pdev, 0x44, 0);\n\tif (err)\n\t\tgoto failure_release_regions;\n\n\tif (sub_sys_id >= 12)\n\t\tchannels = 4;\n\telse if (sub_sys_id >= 10)\n\t\tchannels = 3;\n\telse if (sub_sys_id >= 4)\n\t\tchannels = 2;\n\telse\n\t\tchannels = 1;\n\n\tcfg_base = pci_iomap(pdev, 0, PEAK_PCI_CFG_SIZE);\n\tif (!cfg_base) {\n\t\tdev_err(&pdev->dev, \"failed to map PCI resource #0\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto failure_release_regions;\n\t}\n\n\treg_base = pci_iomap(pdev, 1, PEAK_PCI_CHAN_SIZE * channels);\n\tif (!reg_base) {\n\t\tdev_err(&pdev->dev, \"failed to map PCI resource #1\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto failure_unmap_cfg_base;\n\t}\n\n\t \n\twritew(0x0005, cfg_base + PITA_GPIOICR + 2);\n\t \n\twriteb(0x00, cfg_base + PITA_GPIOICR);\n\t \n\twriteb(0x05, cfg_base + PITA_MISC + 3);\n\tusleep_range(5000, 6000);\n\t \n\twriteb(0x04, cfg_base + PITA_MISC + 3);\n\n\t \n\tif (readl(cfg_base + PEAK_VER_REG1)) {\n\t\t \n\t\tu32 fw_ver = readl(cfg_base + PEAK_VER_REG2);\n\n\t\tsnprintf(fw_str, sizeof(fw_str), \" FW v%u.%u.%u\",\n\t\t\t (fw_ver >> 12) & 0xf,\n\t\t\t (fw_ver >> 8) & 0xf,\n\t\t\t (fw_ver >> 4) & 0xf);\n\t}\n\n\t \n\tdev_info(&pdev->dev, \"%ux CAN %s%s\\n\",\n\t\t channels, (const char *)ent->driver_data, fw_str);\n\n\ticr = readw(cfg_base + PITA_ICR + 2);\n\n\tfor (i = 0; i < channels; i++) {\n\t\tdev = alloc_sja1000dev(sizeof(struct peak_pci_chan));\n\t\tif (!dev) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failure_remove_channels;\n\t\t}\n\n\t\tpriv = netdev_priv(dev);\n\t\tchan = priv->priv;\n\n\t\tchan->cfg_base = cfg_base;\n\t\tpriv->reg_base = reg_base + i * PEAK_PCI_CHAN_SIZE;\n\n\t\tpriv->read_reg = peak_pci_read_reg;\n\t\tpriv->write_reg = peak_pci_write_reg;\n\t\tpriv->post_irq = peak_pci_post_irq;\n\n\t\tpriv->can.clock.freq = PEAK_PCI_CAN_CLOCK;\n\t\tpriv->ocr = PEAK_PCI_OCR;\n\t\tpriv->cdr = PEAK_PCI_CDR;\n\t\t \n\t\tif (channels == 1 || i > 0)\n\t\t\tpriv->cdr |= CDR_CLK_OFF;\n\n\t\t \n\t\tpriv->irq_flags = IRQF_SHARED;\n\t\tdev->irq = pdev->irq;\n\n\t\tchan->icr_mask = peak_pci_icr_masks[i];\n\t\ticr |= chan->icr_mask;\n\n\t\tSET_NETDEV_DEV(dev, &pdev->dev);\n\t\tdev->dev_id = i;\n\n\t\t \n\t\tchan->prev_dev = pci_get_drvdata(pdev);\n\t\tpci_set_drvdata(pdev, dev);\n\n\t\t \n\t\tif (pdev->device == PEAK_PCIEC_DEVICE_ID ||\n\t\t    pdev->device == PEAK_PCIEC34_DEVICE_ID) {\n\t\t\terr = peak_pciec_probe(pdev, dev);\n\t\t\tif (err) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"failed to probe device (err %d)\\n\",\n\t\t\t\t\terr);\n\t\t\t\tgoto failure_free_dev;\n\t\t\t}\n\t\t}\n\n\t\terr = register_sja1000dev(dev);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"failed to register device\\n\");\n\t\t\tgoto failure_free_dev;\n\t\t}\n\n\t\tdev_info(&pdev->dev,\n\t\t\t \"%s at reg_base=0x%p cfg_base=0x%p irq=%d\\n\",\n\t\t\t dev->name, priv->reg_base, chan->cfg_base, dev->irq);\n\t}\n\n\t \n\twritew(icr, cfg_base + PITA_ICR + 2);\n\n\treturn 0;\n\nfailure_free_dev:\n\tpci_set_drvdata(pdev, chan->prev_dev);\n\tfree_sja1000dev(dev);\n\nfailure_remove_channels:\n\t \n\twritew(0x0, cfg_base + PITA_ICR + 2);\n\n\tchan = NULL;\n\tfor (dev = pci_get_drvdata(pdev); dev; dev = prev_dev) {\n\t\tpriv = netdev_priv(dev);\n\t\tchan = priv->priv;\n\t\tprev_dev = chan->prev_dev;\n\n\t\tunregister_sja1000dev(dev);\n\t\tfree_sja1000dev(dev);\n\t}\n\n\t \n\tif (chan && chan->pciec_card)\n\t\tpeak_pciec_remove(chan->pciec_card);\n\n\tpci_iounmap(pdev, reg_base);\n\nfailure_unmap_cfg_base:\n\tpci_iounmap(pdev, cfg_base);\n\nfailure_release_regions:\n\tpci_release_regions(pdev);\n\nfailure_disable_pci:\n\tpci_disable_device(pdev);\n\n\t \n\treturn pcibios_err_to_errno(err);\n}\n\nstatic void peak_pci_remove(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);  \n\tstruct sja1000_priv *priv = netdev_priv(dev);\n\tstruct peak_pci_chan *chan = priv->priv;\n\tvoid __iomem *cfg_base = chan->cfg_base;\n\tvoid __iomem *reg_base = priv->reg_base;\n\n\t \n\twritew(0x0, cfg_base + PITA_ICR + 2);\n\n\t \n\twhile (1) {\n\t\tstruct net_device *prev_dev = chan->prev_dev;\n\n\t\tdev_info(&pdev->dev, \"removing device %s\\n\", dev->name);\n\t\t \n\t\tif (!prev_dev && chan->pciec_card)\n\t\t\tpeak_pciec_remove(chan->pciec_card);\n\t\tunregister_sja1000dev(dev);\n\t\tfree_sja1000dev(dev);\n\t\tdev = prev_dev;\n\n\t\tif (!dev)\n\t\t\tbreak;\n\t\tpriv = netdev_priv(dev);\n\t\tchan = priv->priv;\n\t}\n\n\tpci_iounmap(pdev, reg_base);\n\tpci_iounmap(pdev, cfg_base);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n}\n\nstatic struct pci_driver peak_pci_driver = {\n\t.name = DRV_NAME,\n\t.id_table = peak_pci_tbl,\n\t.probe = peak_pci_probe,\n\t.remove = peak_pci_remove,\n};\n\nmodule_pci_driver(peak_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}