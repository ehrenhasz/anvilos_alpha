{
  "module_name": "ems_pcmcia.c",
  "hash_id": "895577d1b2f8352ad03fc25b69238c31768ac1fe3e1a9eb270f9010b0ee43891",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/sja1000/ems_pcmcia.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <pcmcia/cistpl.h>\n#include <pcmcia/ds.h>\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include \"sja1000.h\"\n\n#define DRV_NAME \"ems_pcmcia\"\n\nMODULE_AUTHOR(\"Markus Plessing <plessing@ems-wuensche.com>\");\nMODULE_DESCRIPTION(\"Socket-CAN driver for EMS CPC-CARD cards\");\nMODULE_LICENSE(\"GPL v2\");\n\n#define EMS_PCMCIA_MAX_CHAN 2\n\nstruct ems_pcmcia_card {\n\tint channels;\n\tstruct pcmcia_device *pcmcia_dev;\n\tstruct net_device *net_dev[EMS_PCMCIA_MAX_CHAN];\n\tvoid __iomem *base_addr;\n};\n\n#define EMS_PCMCIA_CAN_CLOCK (16000000 / 2)\n\n \n#define EMS_PCMCIA_OCR (OCR_TX0_PUSHPULL | OCR_TX1_PUSHPULL)\n\n \n#define EMS_PCMCIA_CDR (CDR_CBP | CDR_CLKOUT_MASK)\n#define EMS_PCMCIA_MEM_SIZE 4096  \n#define EMS_PCMCIA_CAN_BASE_OFFSET 0x100  \n#define EMS_PCMCIA_CAN_CTRL_SIZE 0x80  \n\n#define EMS_CMD_RESET 0x00  \n#define EMS_CMD_MAP   0x03  \n#define EMS_CMD_UMAP  0x02  \n\nstatic struct pcmcia_device_id ems_pcmcia_tbl[] = {\n\tPCMCIA_DEVICE_PROD_ID123(\"EMS_T_W\", \"CPC-Card\", \"V2.0\", 0xeab1ea23,\n\t\t\t\t 0xa338573f, 0xe4575800),\n\tPCMCIA_DEVICE_NULL,\n};\n\nMODULE_DEVICE_TABLE(pcmcia, ems_pcmcia_tbl);\n\nstatic u8 ems_pcmcia_read_reg(const struct sja1000_priv *priv, int port)\n{\n\treturn readb(priv->reg_base + port);\n}\n\nstatic void ems_pcmcia_write_reg(const struct sja1000_priv *priv, int port,\n\t\t\t\t u8 val)\n{\n\twriteb(val, priv->reg_base + port);\n}\n\nstatic irqreturn_t ems_pcmcia_interrupt(int irq, void *dev_id)\n{\n\tstruct ems_pcmcia_card *card = dev_id;\n\tstruct net_device *dev;\n\tirqreturn_t retval = IRQ_NONE;\n\tint i, again;\n\n\t \n\tif (readw(card->base_addr) != 0xAA55)\n\t\treturn IRQ_HANDLED;\n\n\tdo {\n\t\tagain = 0;\n\n\t\t \n\t\tfor (i = 0; i < card->channels; i++) {\n\t\t\tdev = card->net_dev[i];\n\t\t\tif (!dev)\n\t\t\t\tcontinue;\n\n\t\t\tif (sja1000_interrupt(irq, dev) == IRQ_HANDLED)\n\t\t\t\tagain = 1;\n\t\t}\n\t\t \n\t\tif (again)\n\t\t\tretval = IRQ_HANDLED;\n\n\t} while (again);\n\n\treturn retval;\n}\n\n \nstatic inline int ems_pcmcia_check_chan(struct sja1000_priv *priv)\n{\n\t \n\tems_pcmcia_write_reg(priv, SJA1000_MOD, 1);\n\tems_pcmcia_write_reg(priv, SJA1000_CDR, CDR_PELICAN);\n\n\t \n\tif (ems_pcmcia_read_reg(priv, SJA1000_CDR) == CDR_PELICAN)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void ems_pcmcia_del_card(struct pcmcia_device *pdev)\n{\n\tstruct ems_pcmcia_card *card = pdev->priv;\n\tstruct net_device *dev;\n\tint i;\n\n\tfree_irq(pdev->irq, card);\n\n\tfor (i = 0; i < card->channels; i++) {\n\t\tdev = card->net_dev[i];\n\t\tif (!dev)\n\t\t\tcontinue;\n\n\t\tprintk(KERN_INFO \"%s: removing %s on channel #%d\\n\",\n\t\t       DRV_NAME, dev->name, i);\n\t\tunregister_sja1000dev(dev);\n\t\tfree_sja1000dev(dev);\n\t}\n\n\twriteb(EMS_CMD_UMAP, card->base_addr);\n\tiounmap(card->base_addr);\n\tkfree(card);\n\n\tpdev->priv = NULL;\n}\n\n \nstatic int ems_pcmcia_add_card(struct pcmcia_device *pdev, unsigned long base)\n{\n\tstruct sja1000_priv *priv;\n\tstruct net_device *dev;\n\tstruct ems_pcmcia_card *card;\n\tint err, i;\n\n\t \n\tcard = kzalloc(sizeof(struct ems_pcmcia_card), GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\n\tpdev->priv = card;\n\tcard->channels = 0;\n\n\tcard->base_addr = ioremap(base, EMS_PCMCIA_MEM_SIZE);\n\tif (!card->base_addr) {\n\t\terr = -ENOMEM;\n\t\tgoto failure_cleanup;\n\t}\n\n\t \n\tif (readw(card->base_addr) != 0xAA55) {\n\t\terr = -ENODEV;\n\t\tgoto failure_cleanup;\n\t}\n\n\t \n\twriteb(EMS_CMD_RESET, card->base_addr);\n\n\t \n\twriteb(EMS_CMD_MAP, card->base_addr);\n\n\t \n\tfor (i = 0; i < EMS_PCMCIA_MAX_CHAN; i++) {\n\t\tdev = alloc_sja1000dev(0);\n\t\tif (!dev) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failure_cleanup;\n\t\t}\n\n\t\tcard->net_dev[i] = dev;\n\t\tpriv = netdev_priv(dev);\n\t\tpriv->priv = card;\n\t\tSET_NETDEV_DEV(dev, &pdev->dev);\n\t\tdev->dev_id = i;\n\n\t\tpriv->irq_flags = IRQF_SHARED;\n\t\tdev->irq = pdev->irq;\n\t\tpriv->reg_base = card->base_addr + EMS_PCMCIA_CAN_BASE_OFFSET +\n\t\t\t(i * EMS_PCMCIA_CAN_CTRL_SIZE);\n\n\t\t \n\t\tif (ems_pcmcia_check_chan(priv)) {\n\t\t\tpriv->read_reg  = ems_pcmcia_read_reg;\n\t\t\tpriv->write_reg = ems_pcmcia_write_reg;\n\t\t\tpriv->can.clock.freq = EMS_PCMCIA_CAN_CLOCK;\n\t\t\tpriv->ocr = EMS_PCMCIA_OCR;\n\t\t\tpriv->cdr = EMS_PCMCIA_CDR;\n\t\t\tpriv->flags |= SJA1000_CUSTOM_IRQ_HANDLER;\n\n\t\t\t \n\t\t\terr = register_sja1000dev(dev);\n\t\t\tif (err) {\n\t\t\t\tfree_sja1000dev(dev);\n\t\t\t\tgoto failure_cleanup;\n\t\t\t}\n\n\t\t\tcard->channels++;\n\n\t\t\tprintk(KERN_INFO \"%s: registered %s on channel \"\n\t\t\t       \"#%d at 0x%p, irq %d\\n\", DRV_NAME, dev->name,\n\t\t\t       i, priv->reg_base, dev->irq);\n\t\t} else\n\t\t\tfree_sja1000dev(dev);\n\t}\n\n\tif (!card->channels) {\n\t\terr = -ENODEV;\n\t\tgoto failure_cleanup;\n\t}\n\n\terr = request_irq(pdev->irq, &ems_pcmcia_interrupt, IRQF_SHARED,\n\t\t\t  DRV_NAME, card);\n\tif (!err)\n\t\treturn 0;\n\nfailure_cleanup:\n\tems_pcmcia_del_card(pdev);\n\treturn err;\n}\n\n \nstatic int ems_pcmcia_probe(struct pcmcia_device *dev)\n{\n\tint csval;\n\n\t \n\tdev->config_flags |= CONF_ENABLE_IRQ;\n\tdev->config_index = 1;\n\tdev->config_regs = PRESENT_OPTION;\n\n\t \n\tdev->resource[0]->end = 16;\n\tdev->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;\n\tdev->resource[1]->end = 16;\n\tdev->resource[1]->flags |= IO_DATA_PATH_WIDTH_16;\n\tdev->io_lines = 5;\n\n\t \n\tdev->resource[2]->flags =\n\t\t(WIN_DATA_WIDTH_8 | WIN_MEMORY_TYPE_CM | WIN_ENABLE);\n\tdev->resource[2]->start = dev->resource[2]->end = 0;\n\n\tcsval = pcmcia_request_window(dev, dev->resource[2], 0);\n\tif (csval) {\n\t\tdev_err(&dev->dev, \"pcmcia_request_window failed (err=%d)\\n\",\n\t\t\tcsval);\n\t\treturn 0;\n\t}\n\n\tcsval = pcmcia_map_mem_page(dev, dev->resource[2], dev->config_base);\n\tif (csval) {\n\t\tdev_err(&dev->dev, \"pcmcia_map_mem_page failed (err=%d)\\n\",\n\t\t\tcsval);\n\t\treturn 0;\n\t}\n\n\tcsval = pcmcia_enable_device(dev);\n\tif (csval) {\n\t\tdev_err(&dev->dev, \"pcmcia_enable_device failed (err=%d)\\n\",\n\t\t\tcsval);\n\t\treturn 0;\n\t}\n\n\tems_pcmcia_add_card(dev, dev->resource[2]->start);\n\treturn 0;\n}\n\n \nstatic void ems_pcmcia_remove(struct pcmcia_device *dev)\n{\n\tems_pcmcia_del_card(dev);\n\tpcmcia_disable_device(dev);\n}\n\nstatic struct pcmcia_driver ems_pcmcia_driver = {\n\t.name = DRV_NAME,\n\t.probe = ems_pcmcia_probe,\n\t.remove = ems_pcmcia_remove,\n\t.id_table = ems_pcmcia_tbl,\n};\nmodule_pcmcia_driver(ems_pcmcia_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}