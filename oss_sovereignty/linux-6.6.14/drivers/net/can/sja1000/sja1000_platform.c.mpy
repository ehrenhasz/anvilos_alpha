{
  "module_name": "sja1000_platform.c",
  "hash_id": "ab229f641c5f336d2fb8c85f7c043316919b55a0cf7b6caf9ae58f10273db71e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/sja1000/sja1000_platform.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/irq.h>\n#include <linux/can/dev.h>\n#include <linux/can/platform/sja1000.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/of.h>\n\n#include \"sja1000.h\"\n\n#define DRV_NAME \"sja1000_platform\"\n#define SP_CAN_CLOCK  (16000000 / 2)\n\nMODULE_AUTHOR(\"Sascha Hauer <s.hauer@pengutronix.de>\");\nMODULE_AUTHOR(\"Wolfgang Grandegger <wg@grandegger.com>\");\nMODULE_DESCRIPTION(\"Socket-CAN driver for SJA1000 on the platform bus\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\nMODULE_LICENSE(\"GPL v2\");\n\nstruct sja1000_of_data {\n\tsize_t  priv_sz;\n\tvoid    (*init)(struct sja1000_priv *priv, struct device_node *of);\n};\n\nstruct technologic_priv {\n\tspinlock_t      io_lock;\n};\n\nstatic u8 sp_read_reg8(const struct sja1000_priv *priv, int reg)\n{\n\treturn ioread8(priv->reg_base + reg);\n}\n\nstatic void sp_write_reg8(const struct sja1000_priv *priv, int reg, u8 val)\n{\n\tiowrite8(val, priv->reg_base + reg);\n}\n\nstatic u8 sp_read_reg16(const struct sja1000_priv *priv, int reg)\n{\n\treturn ioread8(priv->reg_base + reg * 2);\n}\n\nstatic void sp_write_reg16(const struct sja1000_priv *priv, int reg, u8 val)\n{\n\tiowrite8(val, priv->reg_base + reg * 2);\n}\n\nstatic u8 sp_read_reg32(const struct sja1000_priv *priv, int reg)\n{\n\treturn ioread8(priv->reg_base + reg * 4);\n}\n\nstatic void sp_write_reg32(const struct sja1000_priv *priv, int reg, u8 val)\n{\n\tiowrite8(val, priv->reg_base + reg * 4);\n}\n\nstatic u8 sp_technologic_read_reg16(const struct sja1000_priv *priv, int reg)\n{\n\tstruct technologic_priv *tp = priv->priv;\n\tunsigned long flags;\n\tu8 val;\n\n\tspin_lock_irqsave(&tp->io_lock, flags);\n\tiowrite16(reg, priv->reg_base + 0);\n\tval = ioread16(priv->reg_base + 2);\n\tspin_unlock_irqrestore(&tp->io_lock, flags);\n\n\treturn val;\n}\n\nstatic void sp_technologic_write_reg16(const struct sja1000_priv *priv,\n\t\t\t\t       int reg, u8 val)\n{\n\tstruct technologic_priv *tp = priv->priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tp->io_lock, flags);\n\tiowrite16(reg, priv->reg_base + 0);\n\tiowrite16(val, priv->reg_base + 2);\n\tspin_unlock_irqrestore(&tp->io_lock, flags);\n}\n\nstatic void sp_technologic_init(struct sja1000_priv *priv, struct device_node *of)\n{\n\tstruct technologic_priv *tp = priv->priv;\n\n\tpriv->read_reg = sp_technologic_read_reg16;\n\tpriv->write_reg = sp_technologic_write_reg16;\n\tspin_lock_init(&tp->io_lock);\n}\n\nstatic void sp_rzn1_init(struct sja1000_priv *priv, struct device_node *of)\n{\n\tpriv->flags = SJA1000_QUIRK_NO_CDR_REG | SJA1000_QUIRK_RESET_ON_OVERRUN;\n}\n\nstatic void sp_populate(struct sja1000_priv *priv,\n\t\t\tstruct sja1000_platform_data *pdata,\n\t\t\tunsigned long resource_mem_flags)\n{\n\t \n\tpriv->can.clock.freq = pdata->osc_freq / 2;\n\tpriv->ocr = pdata->ocr;\n\tpriv->cdr = pdata->cdr;\n\n\tswitch (resource_mem_flags & IORESOURCE_MEM_TYPE_MASK) {\n\tcase IORESOURCE_MEM_32BIT:\n\t\tpriv->read_reg = sp_read_reg32;\n\t\tpriv->write_reg = sp_write_reg32;\n\t\tbreak;\n\tcase IORESOURCE_MEM_16BIT:\n\t\tpriv->read_reg = sp_read_reg16;\n\t\tpriv->write_reg = sp_write_reg16;\n\t\tbreak;\n\tcase IORESOURCE_MEM_8BIT:\n\tdefault:\n\t\tpriv->read_reg = sp_read_reg8;\n\t\tpriv->write_reg = sp_write_reg8;\n\t\tbreak;\n\t}\n}\n\nstatic void sp_populate_of(struct sja1000_priv *priv, struct device_node *of)\n{\n\tint err;\n\tu32 prop;\n\n\terr = of_property_read_u32(of, \"reg-io-width\", &prop);\n\tif (err)\n\t\tprop = 1;  \n\n\tswitch (prop) {\n\tcase 4:\n\t\tpriv->read_reg = sp_read_reg32;\n\t\tpriv->write_reg = sp_write_reg32;\n\t\tbreak;\n\tcase 2:\n\t\tpriv->read_reg = sp_read_reg16;\n\t\tpriv->write_reg = sp_write_reg16;\n\t\tbreak;\n\tcase 1:\n\tdefault:\n\t\tpriv->read_reg = sp_read_reg8;\n\t\tpriv->write_reg = sp_write_reg8;\n\t}\n\n\tif (!priv->can.clock.freq) {\n\t\terr = of_property_read_u32(of, \"nxp,external-clock-frequency\", &prop);\n\t\tif (!err)\n\t\t\tpriv->can.clock.freq = prop / 2;\n\t\telse\n\t\t\tpriv->can.clock.freq = SP_CAN_CLOCK;  \n\t}\n\n\terr = of_property_read_u32(of, \"nxp,tx-output-mode\", &prop);\n\tif (!err)\n\t\tpriv->ocr |= prop & OCR_MODE_MASK;\n\telse\n\t\tpriv->ocr |= OCR_MODE_NORMAL;  \n\n\terr = of_property_read_u32(of, \"nxp,tx-output-config\", &prop);\n\tif (!err)\n\t\tpriv->ocr |= (prop << OCR_TX_SHIFT) & OCR_TX_MASK;\n\telse\n\t\tpriv->ocr |= OCR_TX0_PULLDOWN;  \n\n\terr = of_property_read_u32(of, \"nxp,clock-out-frequency\", &prop);\n\tif (!err && prop) {\n\t\tu32 divider = priv->can.clock.freq * 2 / prop;\n\n\t\tif (divider > 1)\n\t\t\tpriv->cdr |= divider / 2 - 1;\n\t\telse\n\t\t\tpriv->cdr |= CDR_CLKOUT_MASK;\n\t} else {\n\t\tpriv->cdr |= CDR_CLK_OFF;  \n\t}\n\n\tif (!of_property_read_bool(of, \"nxp,no-comparator-bypass\"))\n\t\tpriv->cdr |= CDR_CBP;  \n}\n\nstatic struct sja1000_of_data technologic_data = {\n\t.priv_sz = sizeof(struct technologic_priv),\n\t.init = sp_technologic_init,\n};\n\nstatic struct sja1000_of_data renesas_data = {\n\t.init = sp_rzn1_init,\n};\n\nstatic const struct of_device_id sp_of_table[] = {\n\t{ .compatible = \"nxp,sja1000\", .data = NULL, },\n\t{ .compatible = \"renesas,rzn1-sja1000\", .data = &renesas_data, },\n\t{ .compatible = \"technologic,sja1000\", .data = &technologic_data, },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, sp_of_table);\n\nstatic int sp_probe(struct platform_device *pdev)\n{\n\tint err, irq = 0;\n\tvoid __iomem *addr;\n\tstruct net_device *dev;\n\tstruct sja1000_priv *priv;\n\tstruct resource *res_mem, *res_irq = NULL;\n\tstruct sja1000_platform_data *pdata;\n\tstruct device_node *of = pdev->dev.of_node;\n\tconst struct sja1000_of_data *of_data = NULL;\n\tsize_t priv_sz = 0;\n\tstruct clk *clk;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\tif (!pdata && !of) {\n\t\tdev_err(&pdev->dev, \"No platform data provided!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res_mem)\n\t\treturn -ENODEV;\n\n\tif (!devm_request_mem_region(&pdev->dev, res_mem->start,\n\t\t\t\t     resource_size(res_mem), DRV_NAME))\n\t\treturn -EBUSY;\n\n\taddr = devm_ioremap(&pdev->dev, res_mem->start,\n\t\t\t\t    resource_size(res_mem));\n\tif (!addr)\n\t\treturn -ENOMEM;\n\n\tif (of) {\n\t\tirq = platform_get_irq(pdev, 0);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tclk = devm_clk_get_optional_enabled(&pdev->dev, NULL);\n\t\tif (IS_ERR(clk))\n\t\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(clk),\n\t\t\t\t\t     \"CAN clk operation failed\");\n\t} else {\n\t\tres_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\t\tif (!res_irq)\n\t\t\treturn -ENODEV;\n\t}\n\n\tof_data = device_get_match_data(&pdev->dev);\n\tif (of_data)\n\t\tpriv_sz = of_data->priv_sz;\n\n\tdev = alloc_sja1000dev(priv_sz);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tpriv = netdev_priv(dev);\n\n\tif (res_irq) {\n\t\tirq = res_irq->start;\n\t\tpriv->irq_flags = res_irq->flags & IRQF_TRIGGER_MASK;\n\t\tif (res_irq->flags & IORESOURCE_IRQ_SHAREABLE)\n\t\t\tpriv->irq_flags |= IRQF_SHARED;\n\t} else {\n\t\tpriv->irq_flags = IRQF_SHARED;\n\t}\n\n\tif (priv->flags & SJA1000_QUIRK_RESET_ON_OVERRUN)\n\t\tpriv->irq_flags |= IRQF_ONESHOT;\n\n\tdev->irq = irq;\n\tpriv->reg_base = addr;\n\n\tif (of) {\n\t\tif (clk) {\n\t\t\tpriv->can.clock.freq  = clk_get_rate(clk) / 2;\n\t\t\tif (!priv->can.clock.freq) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tdev_err(&pdev->dev, \"Zero CAN clk rate\");\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t}\n\n\t\tsp_populate_of(priv, of);\n\n\t\tif (of_data && of_data->init)\n\t\t\tof_data->init(priv, of);\n\t} else {\n\t\tsp_populate(priv, pdata, res_mem->flags);\n\t}\n\n\tplatform_set_drvdata(pdev, dev);\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\terr = register_sja1000dev(dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"registering %s failed (err=%d)\\n\",\n\t\t\tDRV_NAME, err);\n\t\tgoto exit_free;\n\t}\n\n\tdev_info(&pdev->dev, \"%s device registered (reg_base=%p, irq=%d)\\n\",\n\t\t DRV_NAME, priv->reg_base, dev->irq);\n\treturn 0;\n\n exit_free:\n\tfree_sja1000dev(dev);\n\treturn err;\n}\n\nstatic void sp_remove(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\n\tunregister_sja1000dev(dev);\n\tfree_sja1000dev(dev);\n}\n\nstatic struct platform_driver sp_driver = {\n\t.probe = sp_probe,\n\t.remove_new = sp_remove,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = sp_of_table,\n\t},\n};\n\nmodule_platform_driver(sp_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}