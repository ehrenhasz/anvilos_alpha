{
  "module_name": "tscan1.c",
  "hash_id": "e66a2336fd537f976991cd23c571bda4613ed4f393be191f849e5a36440d6c89",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/sja1000/tscan1.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/isa.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include \"sja1000.h\"\n\nMODULE_DESCRIPTION(\"Driver for Technologic Systems TS-CAN1 PC104 boards\");\nMODULE_AUTHOR(\"Andre B. Oliveira <anbadeol@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define TSCAN1_MAXDEV 4\n\n \n#define TSCAN1_ID1\t0\n#define TSCAN1_ID2\t1\n#define TSCAN1_VERSION\t2\n#define TSCAN1_LED\t3\n#define TSCAN1_PAGE\t4\n#define TSCAN1_MODE\t5\n#define TSCAN1_JUMPERS\t6\n\n \n#define TSCAN1_ID1_VALUE 0xf6\n#define TSCAN1_ID2_VALUE 0xb9\n\n \n#define TSCAN1_MODE_ENABLE 0x40\n\n \n#define TSCAN1_JP4 0x10\n#define TSCAN1_JP5 0x20\n\n \n#define TSCAN1_PLD_ADDRESS 0x150\n\n \n#define TSCAN1_PLD_SIZE 8\n\n \n#define TSCAN1_SJA1000_SIZE 32\n\n \n#define TSCAN1_SJA1000_XTAL 16000000\n\n \nstatic const unsigned short tscan1_sja1000_addresses[] = {\n\t0x100, 0x120, 0x180, 0x1a0, 0x200, 0x240, 0x280, 0x320\n};\n\n \nstatic u8 tscan1_read(const struct sja1000_priv *priv, int reg)\n{\n\treturn inb((unsigned long)priv->reg_base + reg);\n}\n\n \nstatic void tscan1_write(const struct sja1000_priv *priv, int reg, u8 val)\n{\n\toutb(val, (unsigned long)priv->reg_base + reg);\n}\n\n \nstatic int tscan1_probe(struct device *dev, unsigned id)\n{\n\tstruct net_device *netdev;\n\tstruct sja1000_priv *priv;\n\tunsigned long pld_base, sja1000_base;\n\tint irq, i;\n\n\tpld_base = TSCAN1_PLD_ADDRESS + id * TSCAN1_PLD_SIZE;\n\tif (!request_region(pld_base, TSCAN1_PLD_SIZE, dev_name(dev)))\n\t\treturn -EBUSY;\n\n\tif (inb(pld_base + TSCAN1_ID1) != TSCAN1_ID1_VALUE ||\n\t    inb(pld_base + TSCAN1_ID2) != TSCAN1_ID2_VALUE) {\n\t\trelease_region(pld_base, TSCAN1_PLD_SIZE);\n\t\treturn -ENODEV;\n\t}\n\n\tswitch (inb(pld_base + TSCAN1_JUMPERS) & (TSCAN1_JP4 | TSCAN1_JP5)) {\n\tcase TSCAN1_JP4:\n\t\tirq = 6;\n\t\tbreak;\n\tcase TSCAN1_JP5:\n\t\tirq = 7;\n\t\tbreak;\n\tcase TSCAN1_JP4 | TSCAN1_JP5:\n\t\tirq = 5;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"invalid JP4:JP5 setting (no IRQ)\\n\");\n\t\trelease_region(pld_base, TSCAN1_PLD_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tnetdev = alloc_sja1000dev(0);\n\tif (!netdev) {\n\t\trelease_region(pld_base, TSCAN1_PLD_SIZE);\n\t\treturn -ENOMEM;\n\t}\n\n\tdev_set_drvdata(dev, netdev);\n\tSET_NETDEV_DEV(netdev, dev);\n\n\tnetdev->base_addr = pld_base;\n\tnetdev->irq = irq;\n\n\tpriv = netdev_priv(netdev);\n\tpriv->read_reg = tscan1_read;\n\tpriv->write_reg = tscan1_write;\n\tpriv->can.clock.freq = TSCAN1_SJA1000_XTAL / 2;\n\tpriv->cdr = CDR_CBP | CDR_CLK_OFF;\n\tpriv->ocr = OCR_TX0_PUSHPULL;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(tscan1_sja1000_addresses); i++) {\n\t\tsja1000_base = tscan1_sja1000_addresses[i];\n\t\tif (!request_region(sja1000_base, TSCAN1_SJA1000_SIZE,\n\t\t\t\t\t\t\t\tdev_name(dev)))\n\t\t\tcontinue;\n\n\t\t \n\t\toutb(TSCAN1_MODE_ENABLE | i, pld_base + TSCAN1_MODE);\n\n\t\tpriv->reg_base = (void __iomem *)sja1000_base;\n\t\tif (!register_sja1000dev(netdev)) {\n\t\t\t \n\t\t\toutb(0, pld_base + TSCAN1_LED);\n\t\t\tnetdev_info(netdev, \"TS-CAN1 at 0x%lx 0x%lx irq %d\\n\",\n\t\t\t\t\t\tpld_base, sja1000_base, irq);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\toutb(0, pld_base + TSCAN1_MODE);\n\t\trelease_region(sja1000_base, TSCAN1_SJA1000_SIZE);\n\t}\n\n\tdev_err(dev, \"failed to assign SJA1000 IO address\\n\");\n\tdev_set_drvdata(dev, NULL);\n\tfree_sja1000dev(netdev);\n\trelease_region(pld_base, TSCAN1_PLD_SIZE);\n\treturn -ENXIO;\n}\n\nstatic void tscan1_remove(struct device *dev, unsigned id  )\n{\n\tstruct net_device *netdev;\n\tstruct sja1000_priv *priv;\n\tunsigned long pld_base, sja1000_base;\n\n\tnetdev = dev_get_drvdata(dev);\n\tunregister_sja1000dev(netdev);\n\tdev_set_drvdata(dev, NULL);\n\n\tpriv = netdev_priv(netdev);\n\tpld_base = netdev->base_addr;\n\tsja1000_base = (unsigned long)priv->reg_base;\n\n\toutb(0, pld_base + TSCAN1_MODE);\t \n\n\trelease_region(sja1000_base, TSCAN1_SJA1000_SIZE);\n\trelease_region(pld_base, TSCAN1_PLD_SIZE);\n\n\tfree_sja1000dev(netdev);\n}\n\nstatic struct isa_driver tscan1_isa_driver = {\n\t.probe = tscan1_probe,\n\t.remove = tscan1_remove,\n\t.driver = {\n\t\t.name = \"tscan1\",\n\t},\n};\n\nmodule_isa_driver(tscan1_isa_driver, TSCAN1_MAXDEV);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}