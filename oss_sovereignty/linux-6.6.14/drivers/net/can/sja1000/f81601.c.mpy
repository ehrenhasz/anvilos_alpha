{
  "module_name": "f81601.c",
  "hash_id": "7c11ac61b0ea5fb5699a293a41c364e48aa587765e3e064ffa9d0d60e4cfde6c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/sja1000/f81601.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/can/dev.h>\n#include <linux/io.h>\n\n#include \"sja1000.h\"\n\n#define F81601_PCI_MAX_CHAN\t\t2\n\n#define F81601_DECODE_REG\t\t0x209\n#define F81601_IO_MODE\t\t\tBIT(7)\n#define F81601_MEM_MODE\t\t\tBIT(6)\n#define F81601_CFG_MODE\t\t\tBIT(5)\n#define F81601_CAN2_INTERNAL_CLK\tBIT(3)\n#define F81601_CAN1_INTERNAL_CLK\tBIT(2)\n#define F81601_CAN2_EN\t\t\tBIT(1)\n#define F81601_CAN1_EN\t\t\tBIT(0)\n\n#define F81601_TRAP_REG\t\t\t0x20a\n#define F81601_CAN2_HAS_EN\t\tBIT(4)\n\nstruct f81601_pci_card {\n\tvoid __iomem *addr;\n\tspinlock_t lock;\t \n\tstruct pci_dev *dev;\n\tstruct net_device *net_dev[F81601_PCI_MAX_CHAN];\n};\n\nstatic const struct pci_device_id f81601_pci_tbl[] = {\n\t{ PCI_DEVICE(0x1c29, 0x1703) },\n\t{   },\n};\n\nMODULE_DEVICE_TABLE(pci, f81601_pci_tbl);\n\nstatic bool internal_clk = true;\nmodule_param(internal_clk, bool, 0444);\nMODULE_PARM_DESC(internal_clk, \"Use internal clock, default true (24MHz)\");\n\nstatic unsigned int external_clk;\nmodule_param(external_clk, uint, 0444);\nMODULE_PARM_DESC(external_clk, \"External clock when internal_clk disabled\");\n\nstatic u8 f81601_pci_read_reg(const struct sja1000_priv *priv, int port)\n{\n\treturn readb(priv->reg_base + port);\n}\n\nstatic void f81601_pci_write_reg(const struct sja1000_priv *priv, int port,\n\t\t\t\t u8 val)\n{\n\tstruct f81601_pci_card *card = priv->priv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&card->lock, flags);\n\twriteb(val, priv->reg_base + port);\n\treadb(priv->reg_base);\n\tspin_unlock_irqrestore(&card->lock, flags);\n}\n\nstatic void f81601_pci_remove(struct pci_dev *pdev)\n{\n\tstruct f81601_pci_card *card = pci_get_drvdata(pdev);\n\tstruct net_device *dev;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(card->net_dev); i++) {\n\t\tdev = card->net_dev[i];\n\t\tif (!dev)\n\t\t\tcontinue;\n\n\t\tdev_info(&pdev->dev, \"%s: Removing %s\\n\", __func__, dev->name);\n\n\t\tunregister_sja1000dev(dev);\n\t\tfree_sja1000dev(dev);\n\t}\n}\n\n \nstatic int f81601_pci_probe(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *ent)\n{\n\tstruct sja1000_priv *priv;\n\tstruct net_device *dev;\n\tstruct f81601_pci_card *card;\n\tint err, i, count;\n\tu8 tmp;\n\n\tif (pcim_enable_device(pdev) < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to enable PCI device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev_info(&pdev->dev, \"Detected card at slot #%i\\n\",\n\t\t PCI_SLOT(pdev->devfn));\n\n\tcard = devm_kzalloc(&pdev->dev, sizeof(*card), GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\n\tcard->dev = pdev;\n\tspin_lock_init(&card->lock);\n\n\tpci_set_drvdata(pdev, card);\n\n\ttmp = F81601_IO_MODE | F81601_MEM_MODE | F81601_CFG_MODE |\n\t\tF81601_CAN2_EN | F81601_CAN1_EN;\n\n\tif (internal_clk) {\n\t\ttmp |= F81601_CAN2_INTERNAL_CLK | F81601_CAN1_INTERNAL_CLK;\n\n\t\tdev_info(&pdev->dev,\n\t\t\t \"F81601 running with internal clock: 24Mhz\\n\");\n\t} else {\n\t\tdev_info(&pdev->dev,\n\t\t\t \"F81601 running with external clock: %dMhz\\n\",\n\t\t\t external_clk / 1000000);\n\t}\n\n\tpci_write_config_byte(pdev, F81601_DECODE_REG, tmp);\n\n\tcard->addr = pcim_iomap(pdev, 0, pci_resource_len(pdev, 0));\n\n\tif (!card->addr) {\n\t\terr = -ENOMEM;\n\t\tdev_err(&pdev->dev, \"%s: Failed to remap BAR\\n\", __func__);\n\t\tgoto failure_cleanup;\n\t}\n\n\t \n\tcount = ARRAY_SIZE(card->net_dev);\n\tpci_read_config_byte(pdev, F81601_TRAP_REG, &tmp);\n\tif (!(tmp & F81601_CAN2_HAS_EN))\n\t\tcount = 1;\n\n\tfor (i = 0; i < count; i++) {\n\t\tdev = alloc_sja1000dev(0);\n\t\tif (!dev) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failure_cleanup;\n\t\t}\n\n\t\tpriv = netdev_priv(dev);\n\t\tpriv->priv = card;\n\t\tpriv->irq_flags = IRQF_SHARED;\n\t\tpriv->reg_base = card->addr + 0x80 * i;\n\t\tpriv->read_reg = f81601_pci_read_reg;\n\t\tpriv->write_reg = f81601_pci_write_reg;\n\n\t\tif (internal_clk)\n\t\t\tpriv->can.clock.freq = 24000000 / 2;\n\t\telse\n\t\t\tpriv->can.clock.freq = external_clk / 2;\n\n\t\tpriv->ocr = OCR_TX0_PUSHPULL | OCR_TX1_PUSHPULL;\n\t\tpriv->cdr = CDR_CBP;\n\n\t\tSET_NETDEV_DEV(dev, &pdev->dev);\n\t\tdev->dev_id = i;\n\t\tdev->irq = pdev->irq;\n\n\t\t \n\t\terr = register_sja1000dev(dev);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"%s: Registering device failed: %x\\n\", __func__,\n\t\t\t\terr);\n\t\t\tfree_sja1000dev(dev);\n\t\t\tgoto failure_cleanup;\n\t\t}\n\n\t\tcard->net_dev[i] = dev;\n\t\tdev_info(&pdev->dev, \"Channel #%d, %s at 0x%p, irq %d\\n\", i,\n\t\t\t dev->name, priv->reg_base, dev->irq);\n\t}\n\n\treturn 0;\n\n failure_cleanup:\n\tdev_err(&pdev->dev, \"%s: failed: %d. Cleaning Up.\\n\", __func__, err);\n\tf81601_pci_remove(pdev);\n\n\treturn err;\n}\n\nstatic struct pci_driver f81601_pci_driver = {\n\t.name =\t\"f81601\",\n\t.id_table = f81601_pci_tbl,\n\t.probe = f81601_pci_probe,\n\t.remove = f81601_pci_remove,\n};\n\nMODULE_DESCRIPTION(\"Fintek F81601 PCIE to 2 CANBUS adaptor driver\");\nMODULE_AUTHOR(\"Peter Hong <peter_hong@fintek.com.tw>\");\nMODULE_LICENSE(\"GPL v2\");\n\nmodule_pci_driver(f81601_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}