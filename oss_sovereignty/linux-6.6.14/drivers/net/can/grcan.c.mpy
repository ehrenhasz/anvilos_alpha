{
  "module_name": "grcan.c",
  "hash_id": "11465ad0fb52a8e7ccc9c199efb8126b01c52119308ba881c17532d096ee8f1f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/grcan.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/delay.h>\n#include <linux/ethtool.h>\n#include <linux/io.h>\n#include <linux/can/dev.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n\n#include <linux/dma-mapping.h>\n\n#define DRV_NAME\t\"grcan\"\n\n#define GRCAN_NAPI_WEIGHT\t32\n\n#define GRCAN_RESERVE_SIZE(slot1, slot2) (((slot2) - (slot1)) / 4 - 1)\n\nstruct grcan_registers {\n\tu32 conf;\t \n\tu32 stat;\t \n\tu32 ctrl;\t \n\tu32 __reserved1[GRCAN_RESERVE_SIZE(0x08, 0x18)];\n\tu32 smask;\t \n\tu32 scode;\t \n\tu32 __reserved2[GRCAN_RESERVE_SIZE(0x1c, 0x100)];\n\tu32 pimsr;\t \n\tu32 pimr;\t \n\tu32 pisr;\t \n\tu32 pir;\t \n\tu32 imr;\t \n\tu32 picr;\t \n\tu32 __reserved3[GRCAN_RESERVE_SIZE(0x114, 0x200)];\n\tu32 txctrl;\t \n\tu32 txaddr;\t \n\tu32 txsize;\t \n\tu32 txwr;\t \n\tu32 txrd;\t \n\tu32 txirq;\t \n\tu32 __reserved4[GRCAN_RESERVE_SIZE(0x214, 0x300)];\n\tu32 rxctrl;\t \n\tu32 rxaddr;\t \n\tu32 rxsize;\t \n\tu32 rxwr;\t \n\tu32 rxrd;\t \n\tu32 rxirq;\t \n\tu32 rxmask;\t \n\tu32 rxcode;\t \n};\n\n#define GRCAN_CONF_ABORT\t0x00000001\n#define GRCAN_CONF_ENABLE0\t0x00000002\n#define GRCAN_CONF_ENABLE1\t0x00000004\n#define GRCAN_CONF_SELECT\t0x00000008\n#define GRCAN_CONF_SILENT\t0x00000010\n#define GRCAN_CONF_SAM\t\t0x00000020  \n#define GRCAN_CONF_BPR\t\t0x00000300  \n#define GRCAN_CONF_RSJ\t\t0x00007000\n#define GRCAN_CONF_PS1\t\t0x00f00000\n#define GRCAN_CONF_PS2\t\t0x000f0000\n#define GRCAN_CONF_SCALER\t0xff000000\n#define GRCAN_CONF_OPERATION\t\t\t\t\t\t\\\n\t(GRCAN_CONF_ABORT | GRCAN_CONF_ENABLE0 | GRCAN_CONF_ENABLE1\t\\\n\t | GRCAN_CONF_SELECT | GRCAN_CONF_SILENT | GRCAN_CONF_SAM)\n#define GRCAN_CONF_TIMING\t\t\t\t\t\t\\\n\t(GRCAN_CONF_BPR | GRCAN_CONF_RSJ | GRCAN_CONF_PS1\t\t\\\n\t | GRCAN_CONF_PS2 | GRCAN_CONF_SCALER)\n\n#define GRCAN_CONF_RSJ_MIN\t1\n#define GRCAN_CONF_RSJ_MAX\t4\n#define GRCAN_CONF_PS1_MIN\t1\n#define GRCAN_CONF_PS1_MAX\t15\n#define GRCAN_CONF_PS2_MIN\t2\n#define GRCAN_CONF_PS2_MAX\t8\n#define GRCAN_CONF_SCALER_MIN\t0\n#define GRCAN_CONF_SCALER_MAX\t255\n#define GRCAN_CONF_SCALER_INC\t1\n\n#define GRCAN_CONF_BPR_BIT\t8\n#define GRCAN_CONF_RSJ_BIT\t12\n#define GRCAN_CONF_PS1_BIT\t20\n#define GRCAN_CONF_PS2_BIT\t16\n#define GRCAN_CONF_SCALER_BIT\t24\n\n#define GRCAN_STAT_PASS\t\t0x000001\n#define GRCAN_STAT_OFF\t\t0x000002\n#define GRCAN_STAT_OR\t\t0x000004\n#define GRCAN_STAT_AHBERR\t0x000008\n#define GRCAN_STAT_ACTIVE\t0x000010\n#define GRCAN_STAT_RXERRCNT\t0x00ff00\n#define GRCAN_STAT_TXERRCNT\t0xff0000\n\n#define GRCAN_STAT_ERRCTR_RELATED\t(GRCAN_STAT_PASS | GRCAN_STAT_OFF)\n\n#define GRCAN_STAT_RXERRCNT_BIT\t8\n#define GRCAN_STAT_TXERRCNT_BIT\t16\n\n#define GRCAN_STAT_ERRCNT_WARNING_LIMIT\t96\n#define GRCAN_STAT_ERRCNT_PASSIVE_LIMIT\t127\n\n#define GRCAN_CTRL_RESET\t0x2\n#define GRCAN_CTRL_ENABLE\t0x1\n\n#define GRCAN_TXCTRL_ENABLE\t0x1\n#define GRCAN_TXCTRL_ONGOING\t0x2\n#define GRCAN_TXCTRL_SINGLE\t0x4\n\n#define GRCAN_RXCTRL_ENABLE\t0x1\n#define GRCAN_RXCTRL_ONGOING\t0x2\n\n \n#define GRCAN_IRQIX_IRQ\t\t0\n#define GRCAN_IRQIX_TXSYNC\t1\n#define GRCAN_IRQIX_RXSYNC\t2\n\n#define GRCAN_IRQ_PASS\t\t0x00001\n#define GRCAN_IRQ_OFF\t\t0x00002\n#define GRCAN_IRQ_OR\t\t0x00004\n#define GRCAN_IRQ_RXAHBERR\t0x00008\n#define GRCAN_IRQ_TXAHBERR\t0x00010\n#define GRCAN_IRQ_RXIRQ\t\t0x00020\n#define GRCAN_IRQ_TXIRQ\t\t0x00040\n#define GRCAN_IRQ_RXFULL\t0x00080\n#define GRCAN_IRQ_TXEMPTY\t0x00100\n#define GRCAN_IRQ_RX\t\t0x00200\n#define GRCAN_IRQ_TX\t\t0x00400\n#define GRCAN_IRQ_RXSYNC\t0x00800\n#define GRCAN_IRQ_TXSYNC\t0x01000\n#define GRCAN_IRQ_RXERRCTR\t0x02000\n#define GRCAN_IRQ_TXERRCTR\t0x04000\n#define GRCAN_IRQ_RXMISS\t0x08000\n#define GRCAN_IRQ_TXLOSS\t0x10000\n\n#define GRCAN_IRQ_NONE\t0\n#define GRCAN_IRQ_ALL\t\t\t\t\t\t\t\\\n\t(GRCAN_IRQ_PASS | GRCAN_IRQ_OFF | GRCAN_IRQ_OR\t\t\t\\\n\t | GRCAN_IRQ_RXAHBERR | GRCAN_IRQ_TXAHBERR\t\t\t\\\n\t | GRCAN_IRQ_RXIRQ | GRCAN_IRQ_TXIRQ\t\t\t\t\\\n\t | GRCAN_IRQ_RXFULL | GRCAN_IRQ_TXEMPTY\t\t\t\t\\\n\t | GRCAN_IRQ_RX | GRCAN_IRQ_TX | GRCAN_IRQ_RXSYNC\t\t\\\n\t | GRCAN_IRQ_TXSYNC | GRCAN_IRQ_RXERRCTR\t\t\t\\\n\t | GRCAN_IRQ_TXERRCTR | GRCAN_IRQ_RXMISS\t\t\t\\\n\t | GRCAN_IRQ_TXLOSS)\n\n#define GRCAN_IRQ_ERRCTR_RELATED (GRCAN_IRQ_RXERRCTR | GRCAN_IRQ_TXERRCTR \\\n\t\t\t\t  | GRCAN_IRQ_PASS | GRCAN_IRQ_OFF)\n#define GRCAN_IRQ_ERRORS (GRCAN_IRQ_ERRCTR_RELATED | GRCAN_IRQ_OR\t\\\n\t\t\t  | GRCAN_IRQ_TXAHBERR | GRCAN_IRQ_RXAHBERR\t\\\n\t\t\t  | GRCAN_IRQ_TXLOSS)\n#define GRCAN_IRQ_DEFAULT (GRCAN_IRQ_RX | GRCAN_IRQ_TX | GRCAN_IRQ_ERRORS)\n\n#define GRCAN_MSG_SIZE\t\t16\n\n#define GRCAN_MSG_IDE\t\t0x80000000\n#define GRCAN_MSG_RTR\t\t0x40000000\n#define GRCAN_MSG_BID\t\t0x1ffc0000\n#define GRCAN_MSG_EID\t\t0x1fffffff\n#define GRCAN_MSG_IDE_BIT\t31\n#define GRCAN_MSG_RTR_BIT\t30\n#define GRCAN_MSG_BID_BIT\t18\n#define GRCAN_MSG_EID_BIT\t0\n\n#define GRCAN_MSG_DLC\t\t0xf0000000\n#define GRCAN_MSG_TXERRC\t0x00ff0000\n#define GRCAN_MSG_RXERRC\t0x0000ff00\n#define GRCAN_MSG_DLC_BIT\t28\n#define GRCAN_MSG_TXERRC_BIT\t16\n#define GRCAN_MSG_RXERRC_BIT\t8\n#define GRCAN_MSG_AHBERR\t0x00000008\n#define GRCAN_MSG_OR\t\t0x00000004\n#define GRCAN_MSG_OFF\t\t0x00000002\n#define GRCAN_MSG_PASS\t\t0x00000001\n\n#define GRCAN_MSG_DATA_SLOT_INDEX(i) (2 + (i) / 4)\n#define GRCAN_MSG_DATA_SHIFT(i) ((3 - (i) % 4) * 8)\n\n#define GRCAN_BUFFER_ALIGNMENT\t\t1024\n#define GRCAN_DEFAULT_BUFFER_SIZE\t1024\n#define GRCAN_VALID_TR_SIZE_MASK\t0x001fffc0\n\n#define GRCAN_INVALID_BUFFER_SIZE(s)\t\t\t\\\n\t((s) == 0 || ((s) & ~GRCAN_VALID_TR_SIZE_MASK))\n\n#if GRCAN_INVALID_BUFFER_SIZE(GRCAN_DEFAULT_BUFFER_SIZE)\n#error \"Invalid default buffer size\"\n#endif\n\nstruct grcan_dma_buffer {\n\tsize_t size;\n\tvoid *buf;\n\tdma_addr_t handle;\n};\n\nstruct grcan_dma {\n\tsize_t base_size;\n\tvoid *base_buf;\n\tdma_addr_t base_handle;\n\tstruct grcan_dma_buffer tx;\n\tstruct grcan_dma_buffer rx;\n};\n\n \nstruct grcan_device_config {\n\tunsigned short enable0;\n\tunsigned short enable1;\n\tunsigned short select;\n\tunsigned int txsize;\n\tunsigned int rxsize;\n};\n\n#define GRCAN_DEFAULT_DEVICE_CONFIG {\t\t\t\t\\\n\t\t.enable0\t= 0,\t\t\t\t\\\n\t\t.enable1\t= 0,\t\t\t\t\\\n\t\t.select\t\t= 0,\t\t\t\t\\\n\t\t.txsize\t\t= GRCAN_DEFAULT_BUFFER_SIZE,\t\\\n\t\t.rxsize\t\t= GRCAN_DEFAULT_BUFFER_SIZE,\t\\\n\t\t}\n\n#define GRCAN_TXBUG_SAFE_GRLIB_VERSION\t4100\n#define GRLIB_VERSION_MASK\t\t0xffff\n\n \nstruct grcan_priv {\n\tstruct can_priv can;\t \n\tstruct net_device *dev;\n\tstruct device *ofdev_dev;\n\tstruct napi_struct napi;\n\n\tstruct grcan_registers __iomem *regs;\t \n\tstruct grcan_device_config config;\n\tstruct grcan_dma dma;\n\n\tstruct sk_buff **echo_skb;\t \n\n\t \n\tu32 eskbp;\n\n\t \n\tspinlock_t lock;\n\n\t \n\tbool need_txbug_workaround;\n\n\t \n\tstruct timer_list hang_timer;\n\tstruct timer_list rr_timer;\n\n\t \n\tbool resetting;\n\tbool closing;\n};\n\n \n#define GRCAN_SHORTWAIT_USECS\t10\n\n \n#define GRCAN_EFF_FRAME_MAX_BITS\t(1+32+6+8*8+16+2+7)\n\n#if defined(__BIG_ENDIAN)\nstatic inline u32 grcan_read_reg(u32 __iomem *reg)\n{\n\treturn ioread32be(reg);\n}\n\nstatic inline void grcan_write_reg(u32 __iomem *reg, u32 val)\n{\n\tiowrite32be(val, reg);\n}\n#else\nstatic inline u32 grcan_read_reg(u32 __iomem *reg)\n{\n\treturn ioread32(reg);\n}\n\nstatic inline void grcan_write_reg(u32 __iomem *reg, u32 val)\n{\n\tiowrite32(val, reg);\n}\n#endif\n\nstatic inline void grcan_clear_bits(u32 __iomem *reg, u32 mask)\n{\n\tgrcan_write_reg(reg, grcan_read_reg(reg) & ~mask);\n}\n\nstatic inline void grcan_set_bits(u32 __iomem *reg, u32 mask)\n{\n\tgrcan_write_reg(reg, grcan_read_reg(reg) | mask);\n}\n\nstatic inline u32 grcan_read_bits(u32 __iomem *reg, u32 mask)\n{\n\treturn grcan_read_reg(reg) & mask;\n}\n\nstatic inline void grcan_write_bits(u32 __iomem *reg, u32 value, u32 mask)\n{\n\tu32 old = grcan_read_reg(reg);\n\n\tgrcan_write_reg(reg, (old & ~mask) | (value & mask));\n}\n\n \nstatic inline u32 grcan_ring_add(u32 a, u32 b, u32 size)\n{\n\tu32 sum = a + b;\n\n\tif (sum < size)\n\t\treturn sum;\n\telse\n\t\treturn sum - size;\n}\n\n \nstatic inline u32 grcan_ring_sub(u32 a, u32 b, u32 size)\n{\n\treturn grcan_ring_add(a, size - b, size);\n}\n\n \nstatic inline u32 grcan_txspace(size_t txsize, u32 txwr, u32 eskbp)\n{\n\tu32 slots = txsize / GRCAN_MSG_SIZE - 1;\n\tu32 used = grcan_ring_sub(txwr, eskbp, txsize) / GRCAN_MSG_SIZE;\n\n\treturn slots - used;\n}\n\n \nstatic struct grcan_device_config grcan_module_config =\n\tGRCAN_DEFAULT_DEVICE_CONFIG;\n\nstatic const struct can_bittiming_const grcan_bittiming_const = {\n\t.name\t\t= DRV_NAME,\n\t.tseg1_min\t= GRCAN_CONF_PS1_MIN + 1,\n\t.tseg1_max\t= GRCAN_CONF_PS1_MAX + 1,\n\t.tseg2_min\t= GRCAN_CONF_PS2_MIN,\n\t.tseg2_max\t= GRCAN_CONF_PS2_MAX,\n\t.sjw_max\t= GRCAN_CONF_RSJ_MAX,\n\t.brp_min\t= GRCAN_CONF_SCALER_MIN + 1,\n\t.brp_max\t= GRCAN_CONF_SCALER_MAX + 1,\n\t.brp_inc\t= GRCAN_CONF_SCALER_INC,\n};\n\nstatic int grcan_set_bittiming(struct net_device *dev)\n{\n\tstruct grcan_priv *priv = netdev_priv(dev);\n\tstruct grcan_registers __iomem *regs = priv->regs;\n\tstruct can_bittiming *bt = &priv->can.bittiming;\n\tu32 timing = 0;\n\tint bpr, rsj, ps1, ps2, scaler;\n\n\t \n\tif (grcan_read_bits(&regs->ctrl, GRCAN_CTRL_ENABLE))\n\t\treturn -EBUSY;\n\n\tbpr = 0;  \n\trsj = bt->sjw;\n\tps1 = (bt->prop_seg + bt->phase_seg1) - 1;  \n\tps2 = bt->phase_seg2;\n\tscaler = (bt->brp - 1);\n\tnetdev_dbg(dev, \"Request for BPR=%d, RSJ=%d, PS1=%d, PS2=%d, SCALER=%d\",\n\t\t   bpr, rsj, ps1, ps2, scaler);\n\tif (!(ps1 > ps2)) {\n\t\tnetdev_err(dev, \"PS1 > PS2 must hold: PS1=%d, PS2=%d\\n\",\n\t\t\t   ps1, ps2);\n\t\treturn -EINVAL;\n\t}\n\tif (!(ps2 >= rsj)) {\n\t\tnetdev_err(dev, \"PS2 >= RSJ must hold: PS2=%d, RSJ=%d\\n\",\n\t\t\t   ps2, rsj);\n\t\treturn -EINVAL;\n\t}\n\n\ttiming |= (bpr << GRCAN_CONF_BPR_BIT) & GRCAN_CONF_BPR;\n\ttiming |= (rsj << GRCAN_CONF_RSJ_BIT) & GRCAN_CONF_RSJ;\n\ttiming |= (ps1 << GRCAN_CONF_PS1_BIT) & GRCAN_CONF_PS1;\n\ttiming |= (ps2 << GRCAN_CONF_PS2_BIT) & GRCAN_CONF_PS2;\n\ttiming |= (scaler << GRCAN_CONF_SCALER_BIT) & GRCAN_CONF_SCALER;\n\tnetdev_info(dev, \"setting timing=0x%x\\n\", timing);\n\tgrcan_write_bits(&regs->conf, timing, GRCAN_CONF_TIMING);\n\n\treturn 0;\n}\n\nstatic int grcan_get_berr_counter(const struct net_device *dev,\n\t\t\t\t  struct can_berr_counter *bec)\n{\n\tstruct grcan_priv *priv = netdev_priv(dev);\n\tstruct grcan_registers __iomem *regs = priv->regs;\n\tu32 status = grcan_read_reg(&regs->stat);\n\n\tbec->txerr = (status & GRCAN_STAT_TXERRCNT) >> GRCAN_STAT_TXERRCNT_BIT;\n\tbec->rxerr = (status & GRCAN_STAT_RXERRCNT) >> GRCAN_STAT_RXERRCNT_BIT;\n\treturn 0;\n}\n\nstatic int grcan_poll(struct napi_struct *napi, int budget);\n\n \nstatic void grcan_reset(struct net_device *dev)\n{\n\tstruct grcan_priv *priv = netdev_priv(dev);\n\tstruct grcan_registers __iomem *regs = priv->regs;\n\tu32 config = grcan_read_reg(&regs->conf);\n\n\tgrcan_set_bits(&regs->ctrl, GRCAN_CTRL_RESET);\n\tgrcan_write_reg(&regs->conf, config);\n\n\tpriv->eskbp = grcan_read_reg(&regs->txrd);\n\tpriv->can.state = CAN_STATE_STOPPED;\n\n\t \n\tgrcan_write_reg(&regs->rxmask, 0);\n}\n\n \nstatic void grcan_stop_hardware(struct net_device *dev)\n{\n\tstruct grcan_priv *priv = netdev_priv(dev);\n\tstruct grcan_registers __iomem *regs = priv->regs;\n\n\tgrcan_write_reg(&regs->imr, GRCAN_IRQ_NONE);\n\tgrcan_clear_bits(&regs->txctrl, GRCAN_TXCTRL_ENABLE);\n\tgrcan_clear_bits(&regs->rxctrl, GRCAN_RXCTRL_ENABLE);\n\tgrcan_clear_bits(&regs->ctrl, GRCAN_CTRL_ENABLE);\n}\n\n \nstatic int catch_up_echo_skb(struct net_device *dev, int budget, bool echo)\n{\n\tstruct grcan_priv *priv = netdev_priv(dev);\n\tstruct grcan_registers __iomem *regs = priv->regs;\n\tstruct grcan_dma *dma = &priv->dma;\n\tstruct net_device_stats *stats = &dev->stats;\n\tint i, work_done;\n\n\t \n\tu32 txrd = grcan_read_reg(&regs->txrd);\n\n\tfor (work_done = 0; work_done < budget || budget < 0; work_done++) {\n\t\tif (priv->eskbp == txrd)\n\t\t\tbreak;\n\t\ti = priv->eskbp / GRCAN_MSG_SIZE;\n\t\tif (echo) {\n\t\t\t \n\t\t\tstats->tx_packets++;\n\t\t\tstats->tx_bytes += can_get_echo_skb(dev, i, NULL);\n\t\t} else {\n\t\t\t \n\t\t\tcan_free_echo_skb(dev, i, NULL);\n\t\t}\n\n\t\tpriv->eskbp = grcan_ring_add(priv->eskbp, GRCAN_MSG_SIZE,\n\t\t\t\t\t     dma->tx.size);\n\t\ttxrd = grcan_read_reg(&regs->txrd);\n\t}\n\treturn work_done;\n}\n\nstatic void grcan_lost_one_shot_frame(struct net_device *dev)\n{\n\tstruct grcan_priv *priv = netdev_priv(dev);\n\tstruct grcan_registers __iomem *regs = priv->regs;\n\tstruct grcan_dma *dma = &priv->dma;\n\tu32 txrd;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tcatch_up_echo_skb(dev, -1, true);\n\n\tif (unlikely(grcan_read_bits(&regs->txctrl, GRCAN_TXCTRL_ENABLE))) {\n\t\t \n\t\tnetdev_err(dev, \"TXCTRL enabled at TXLOSS in one shot mode\\n\");\n\t} else {\n\t\t \n\n\t\t \n\t\ttxrd = grcan_read_reg(&regs->txrd);\n\t\ttxrd = grcan_ring_add(txrd, GRCAN_MSG_SIZE, dma->tx.size);\n\t\tgrcan_write_reg(&regs->txrd, txrd);\n\t\tcatch_up_echo_skb(dev, -1, false);\n\n\t\tif (!priv->resetting && !priv->closing &&\n\t\t    !(priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)) {\n\t\t\tnetif_wake_queue(dev);\n\t\t\tgrcan_set_bits(&regs->txctrl, GRCAN_TXCTRL_ENABLE);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic void grcan_err(struct net_device *dev, u32 sources, u32 status)\n{\n\tstruct grcan_priv *priv = netdev_priv(dev);\n\tstruct grcan_registers __iomem *regs = priv->regs;\n\tstruct grcan_dma *dma = &priv->dma;\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct can_frame cf;\n\n\t \n\tmemset(&cf, 0, sizeof(cf));\n\n\t \n\tif (sources & GRCAN_IRQ_TXLOSS) {\n\t\t \n\t\tif (priv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)\n\t\t\tgrcan_lost_one_shot_frame(dev);\n\n\t\t \n\t\tif (!(status & GRCAN_STAT_ERRCTR_RELATED)) {\n\t\t\tnetdev_dbg(dev, \"tx message lost\\n\");\n\t\t\tstats->tx_errors++;\n\t\t}\n\t}\n\n\t \n\tif ((sources & GRCAN_IRQ_ERRCTR_RELATED) ||\n\t    (status & GRCAN_STAT_ERRCTR_RELATED)) {\n\t\tenum can_state state = priv->can.state;\n\t\tenum can_state oldstate = state;\n\t\tu32 txerr = (status & GRCAN_STAT_TXERRCNT)\n\t\t\t>> GRCAN_STAT_TXERRCNT_BIT;\n\t\tu32 rxerr = (status & GRCAN_STAT_RXERRCNT)\n\t\t\t>> GRCAN_STAT_RXERRCNT_BIT;\n\n\t\t \n\t\tif (status & GRCAN_STAT_OFF) {\n\t\t\tstate = CAN_STATE_BUS_OFF;\n\t\t} else if (status & GRCAN_STAT_PASS) {\n\t\t\tstate = CAN_STATE_ERROR_PASSIVE;\n\t\t} else if (txerr >= GRCAN_STAT_ERRCNT_WARNING_LIMIT ||\n\t\t\t   rxerr >= GRCAN_STAT_ERRCNT_WARNING_LIMIT) {\n\t\t\tstate = CAN_STATE_ERROR_WARNING;\n\t\t} else {\n\t\t\tstate = CAN_STATE_ERROR_ACTIVE;\n\t\t}\n\n\t\t \n\t\tif (state != oldstate) {\n\t\t\tswitch (state) {\n\t\t\tcase CAN_STATE_BUS_OFF:\n\t\t\t\tnetdev_dbg(dev, \"bus-off\\n\");\n\t\t\t\tnetif_carrier_off(dev);\n\t\t\t\tpriv->can.can_stats.bus_off++;\n\n\t\t\t\t \n\t\t\t\tif (!priv->can.restart_ms)\n\t\t\t\t\tgrcan_stop_hardware(dev);\n\n\t\t\t\tcf.can_id |= CAN_ERR_BUSOFF;\n\t\t\t\tbreak;\n\n\t\t\tcase CAN_STATE_ERROR_PASSIVE:\n\t\t\t\tnetdev_dbg(dev, \"Error passive condition\\n\");\n\t\t\t\tpriv->can.can_stats.error_passive++;\n\n\t\t\t\tcf.can_id |= CAN_ERR_CRTL;\n\t\t\t\tif (txerr >= GRCAN_STAT_ERRCNT_PASSIVE_LIMIT)\n\t\t\t\t\tcf.data[1] |= CAN_ERR_CRTL_TX_PASSIVE;\n\t\t\t\tif (rxerr >= GRCAN_STAT_ERRCNT_PASSIVE_LIMIT)\n\t\t\t\t\tcf.data[1] |= CAN_ERR_CRTL_RX_PASSIVE;\n\t\t\t\tbreak;\n\n\t\t\tcase CAN_STATE_ERROR_WARNING:\n\t\t\t\tnetdev_dbg(dev, \"Error warning condition\\n\");\n\t\t\t\tpriv->can.can_stats.error_warning++;\n\n\t\t\t\tcf.can_id |= CAN_ERR_CRTL;\n\t\t\t\tif (txerr >= GRCAN_STAT_ERRCNT_WARNING_LIMIT)\n\t\t\t\t\tcf.data[1] |= CAN_ERR_CRTL_TX_WARNING;\n\t\t\t\tif (rxerr >= GRCAN_STAT_ERRCNT_WARNING_LIMIT)\n\t\t\t\t\tcf.data[1] |= CAN_ERR_CRTL_RX_WARNING;\n\t\t\t\tbreak;\n\n\t\t\tcase CAN_STATE_ERROR_ACTIVE:\n\t\t\t\tnetdev_dbg(dev, \"Error active condition\\n\");\n\t\t\t\tcf.can_id |= CAN_ERR_CRTL;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcf.can_id |= CAN_ERR_CNT;\n\t\t\tcf.data[6] = txerr;\n\t\t\tcf.data[7] = rxerr;\n\t\t\tpriv->can.state = state;\n\t\t}\n\n\t\t \n\t\tif (priv->can.restart_ms && oldstate == CAN_STATE_BUS_OFF) {\n\t\t\tunsigned long flags;\n\n\t\t\tcf.can_id |= CAN_ERR_RESTARTED;\n\t\t\tnetdev_dbg(dev, \"restarted\\n\");\n\t\t\tpriv->can.can_stats.restarts++;\n\t\t\tnetif_carrier_on(dev);\n\n\t\t\tspin_lock_irqsave(&priv->lock, flags);\n\n\t\t\tif (!priv->resetting && !priv->closing) {\n\t\t\t\tu32 txwr = grcan_read_reg(&regs->txwr);\n\n\t\t\t\tif (grcan_txspace(dma->tx.size, txwr,\n\t\t\t\t\t\t  priv->eskbp))\n\t\t\t\t\tnetif_wake_queue(dev);\n\t\t\t}\n\n\t\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\t}\n\t}\n\n\t \n\tif ((sources & GRCAN_IRQ_OR) || (status & GRCAN_STAT_OR)) {\n\t\tnetdev_dbg(dev, \"got data overrun interrupt\\n\");\n\t\tstats->rx_over_errors++;\n\t\tstats->rx_errors++;\n\n\t\tcf.can_id |= CAN_ERR_CRTL;\n\t\tcf.data[1] |= CAN_ERR_CRTL_RX_OVERFLOW;\n\t}\n\n\t \n\tif (sources & (GRCAN_IRQ_TXAHBERR | GRCAN_IRQ_RXAHBERR) ||\n\t    (status & GRCAN_STAT_AHBERR)) {\n\t\tchar *txrx = \"\";\n\t\tunsigned long flags;\n\n\t\tif (sources & GRCAN_IRQ_TXAHBERR) {\n\t\t\ttxrx = \"on tx \";\n\t\t\tstats->tx_errors++;\n\t\t} else if (sources & GRCAN_IRQ_RXAHBERR) {\n\t\t\ttxrx = \"on rx \";\n\t\t\tstats->rx_errors++;\n\t\t}\n\t\tnetdev_err(dev, \"Fatal AHB bus error %s- halting device\\n\",\n\t\t\t   txrx);\n\n\t\tspin_lock_irqsave(&priv->lock, flags);\n\n\t\t \n\t\tpriv->closing = true;\n\t\tnetif_stop_queue(dev);\n\t\tgrcan_stop_hardware(dev);\n\t\tpriv->can.state = CAN_STATE_STOPPED;\n\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t}\n\n\t \n\tif (cf.can_id) {\n\t\tstruct can_frame *skb_cf;\n\t\tstruct sk_buff *skb = alloc_can_err_skb(dev, &skb_cf);\n\n\t\tif (skb == NULL) {\n\t\t\tnetdev_dbg(dev, \"could not allocate error frame\\n\");\n\t\t\treturn;\n\t\t}\n\t\tskb_cf->can_id |= cf.can_id;\n\t\tmemcpy(skb_cf->data, cf.data, sizeof(cf.data));\n\n\t\tnetif_rx(skb);\n\t}\n}\n\nstatic irqreturn_t grcan_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct grcan_priv *priv = netdev_priv(dev);\n\tstruct grcan_registers __iomem *regs = priv->regs;\n\tu32 sources, status;\n\n\t \n\tsources = grcan_read_reg(&regs->pimsr);\n\tif (!sources)\n\t\treturn IRQ_NONE;\n\tgrcan_write_reg(&regs->picr, sources);\n\tstatus = grcan_read_reg(&regs->stat);\n\n\t \n\tif (priv->need_txbug_workaround &&\n\t    (sources & (GRCAN_IRQ_TX | GRCAN_IRQ_TXLOSS))) {\n\t\tdel_timer(&priv->hang_timer);\n\t}\n\n\t \n\tif (sources & (GRCAN_IRQ_TX | GRCAN_IRQ_RX)) {\n\t\t \n\t\tgrcan_clear_bits(&regs->imr, GRCAN_IRQ_TX | GRCAN_IRQ_RX);\n\t\tnapi_schedule(&priv->napi);\n\t}\n\n\t \n\tif (sources & GRCAN_IRQ_ERRORS)\n\t\tgrcan_err(dev, sources, status);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void grcan_running_reset(struct timer_list *t)\n{\n\tstruct grcan_priv *priv = from_timer(priv, t, rr_timer);\n\tstruct net_device *dev = priv->dev;\n\tstruct grcan_registers __iomem *regs = priv->regs;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tpriv->resetting = false;\n\tdel_timer(&priv->hang_timer);\n\tdel_timer(&priv->rr_timer);\n\n\tif (!priv->closing) {\n\t\t \n\t\tu32 imr = grcan_read_reg(&regs->imr);\n\n\t\tu32 txaddr = grcan_read_reg(&regs->txaddr);\n\t\tu32 txsize = grcan_read_reg(&regs->txsize);\n\t\tu32 txwr = grcan_read_reg(&regs->txwr);\n\t\tu32 txrd = grcan_read_reg(&regs->txrd);\n\t\tu32 eskbp = priv->eskbp;\n\n\t\tu32 rxaddr = grcan_read_reg(&regs->rxaddr);\n\t\tu32 rxsize = grcan_read_reg(&regs->rxsize);\n\t\tu32 rxwr = grcan_read_reg(&regs->rxwr);\n\t\tu32 rxrd = grcan_read_reg(&regs->rxrd);\n\n\t\tgrcan_reset(dev);\n\n\t\t \n\t\tgrcan_write_reg(&regs->txaddr, txaddr);\n\t\tgrcan_write_reg(&regs->txsize, txsize);\n\t\tgrcan_write_reg(&regs->txwr, txwr);\n\t\tgrcan_write_reg(&regs->txrd, txrd);\n\t\tpriv->eskbp = eskbp;\n\n\t\tgrcan_write_reg(&regs->rxaddr, rxaddr);\n\t\tgrcan_write_reg(&regs->rxsize, rxsize);\n\t\tgrcan_write_reg(&regs->rxwr, rxwr);\n\t\tgrcan_write_reg(&regs->rxrd, rxrd);\n\n\t\t \n\t\tgrcan_write_reg(&regs->imr, imr);\n\t\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\tgrcan_write_reg(&regs->txctrl, GRCAN_TXCTRL_ENABLE\n\t\t\t\t| (priv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT\n\t\t\t\t   ? GRCAN_TXCTRL_SINGLE : 0));\n\t\tgrcan_write_reg(&regs->rxctrl, GRCAN_RXCTRL_ENABLE);\n\t\tgrcan_write_reg(&regs->ctrl, GRCAN_CTRL_ENABLE);\n\n\t\t \n\t\tif (grcan_txspace(priv->dma.tx.size, txwr, priv->eskbp) &&\n\t\t    !(priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY))\n\t\t\tnetif_wake_queue(dev);\n\t}\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tnetdev_err(dev, \"Device reset and restored\\n\");\n}\n\n \nstatic inline u32 grcan_ongoing_wait_usecs(__u32 bitrate)\n{\n\treturn 1000000 * 3 * GRCAN_EFF_FRAME_MAX_BITS / bitrate;\n}\n\n \nstatic inline void grcan_reset_timer(struct timer_list *timer, __u32 bitrate)\n{\n\tu32 wait_jiffies = usecs_to_jiffies(grcan_ongoing_wait_usecs(bitrate));\n\n\tmod_timer(timer, jiffies + wait_jiffies);\n}\n\n \nstatic void grcan_initiate_running_reset(struct timer_list *t)\n{\n\tstruct grcan_priv *priv = from_timer(priv, t, hang_timer);\n\tstruct net_device *dev = priv->dev;\n\tstruct grcan_registers __iomem *regs = priv->regs;\n\tunsigned long flags;\n\n\tnetdev_err(dev, \"Device seems hanged - reset scheduled\\n\");\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\t \n\tif (!priv->resetting && !priv->closing) {\n\t\tpriv->resetting = true;\n\t\tnetif_stop_queue(dev);\n\t\tgrcan_clear_bits(&regs->txctrl, GRCAN_TXCTRL_ENABLE);\n\t\tgrcan_clear_bits(&regs->rxctrl, GRCAN_RXCTRL_ENABLE);\n\t\tgrcan_reset_timer(&priv->rr_timer, priv->can.bittiming.bitrate);\n\t}\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic void grcan_free_dma_buffers(struct net_device *dev)\n{\n\tstruct grcan_priv *priv = netdev_priv(dev);\n\tstruct grcan_dma *dma = &priv->dma;\n\n\tdma_free_coherent(priv->ofdev_dev, dma->base_size, dma->base_buf,\n\t\t\t  dma->base_handle);\n\tmemset(dma, 0, sizeof(*dma));\n}\n\nstatic int grcan_allocate_dma_buffers(struct net_device *dev,\n\t\t\t\t      size_t tsize, size_t rsize)\n{\n\tstruct grcan_priv *priv = netdev_priv(dev);\n\tstruct grcan_dma *dma = &priv->dma;\n\tstruct grcan_dma_buffer *large = rsize > tsize ? &dma->rx : &dma->tx;\n\tstruct grcan_dma_buffer *small = rsize > tsize ? &dma->tx : &dma->rx;\n\tsize_t shift;\n\n\t \n\tsize_t maxs = max(tsize, rsize);\n\tsize_t lsize = ALIGN(maxs, GRCAN_BUFFER_ALIGNMENT);\n\n\t \n\tsize_t ssize = min(tsize, rsize);\n\n\t \n\tdma->base_size = lsize + ssize + GRCAN_BUFFER_ALIGNMENT;\n\tdma->base_buf = dma_alloc_coherent(priv->ofdev_dev,\n\t\t\t\t\t   dma->base_size,\n\t\t\t\t\t   &dma->base_handle,\n\t\t\t\t\t   GFP_KERNEL);\n\n\tif (!dma->base_buf)\n\t\treturn -ENOMEM;\n\n\tdma->tx.size = tsize;\n\tdma->rx.size = rsize;\n\n\tlarge->handle = ALIGN(dma->base_handle, GRCAN_BUFFER_ALIGNMENT);\n\tsmall->handle = large->handle + lsize;\n\tshift = large->handle - dma->base_handle;\n\n\tlarge->buf = dma->base_buf + shift;\n\tsmall->buf = large->buf + lsize;\n\n\treturn 0;\n}\n\n \nstatic int grcan_start(struct net_device *dev)\n{\n\tstruct grcan_priv *priv = netdev_priv(dev);\n\tstruct grcan_registers __iomem *regs = priv->regs;\n\tu32 confop, txctrl;\n\n\tgrcan_reset(dev);\n\n\tgrcan_write_reg(&regs->txaddr, priv->dma.tx.handle);\n\tgrcan_write_reg(&regs->txsize, priv->dma.tx.size);\n\t \n\n\tgrcan_write_reg(&regs->rxaddr, priv->dma.rx.handle);\n\tgrcan_write_reg(&regs->rxsize, priv->dma.rx.size);\n\t \n\n\t \n\tgrcan_read_reg(&regs->pir);\n\tgrcan_write_reg(&regs->imr, GRCAN_IRQ_DEFAULT);\n\n\t \n\tconfop = GRCAN_CONF_ABORT\n\t\t| (priv->config.enable0 ? GRCAN_CONF_ENABLE0 : 0)\n\t\t| (priv->config.enable1 ? GRCAN_CONF_ENABLE1 : 0)\n\t\t| (priv->config.select ? GRCAN_CONF_SELECT : 0)\n\t\t| (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY ?\n\t\t   GRCAN_CONF_SILENT : 0)\n\t\t| (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES ?\n\t\t   GRCAN_CONF_SAM : 0);\n\tgrcan_write_bits(&regs->conf, confop, GRCAN_CONF_OPERATION);\n\ttxctrl = GRCAN_TXCTRL_ENABLE\n\t\t| (priv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT\n\t\t   ? GRCAN_TXCTRL_SINGLE : 0);\n\tgrcan_write_reg(&regs->txctrl, txctrl);\n\tgrcan_write_reg(&regs->rxctrl, GRCAN_RXCTRL_ENABLE);\n\tgrcan_write_reg(&regs->ctrl, GRCAN_CTRL_ENABLE);\n\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\treturn 0;\n}\n\nstatic int grcan_set_mode(struct net_device *dev, enum can_mode mode)\n{\n\tstruct grcan_priv *priv = netdev_priv(dev);\n\tunsigned long flags;\n\tint err = 0;\n\n\tif (mode == CAN_MODE_START) {\n\t\t \n\t\tspin_lock_irqsave(&priv->lock, flags);\n\t\tif (priv->closing || priv->resetting) {\n\t\t\terr = -EBUSY;\n\t\t} else {\n\t\t\tnetdev_info(dev, \"Restarting device\\n\");\n\t\t\tgrcan_start(dev);\n\t\t\tif (!(priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY))\n\t\t\t\tnetif_wake_queue(dev);\n\t\t}\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\treturn err;\n\t}\n\treturn -EOPNOTSUPP;\n}\n\nstatic int grcan_open(struct net_device *dev)\n{\n\tstruct grcan_priv *priv = netdev_priv(dev);\n\tstruct grcan_dma *dma = &priv->dma;\n\tunsigned long flags;\n\tint err;\n\n\t \n\terr = grcan_allocate_dma_buffers(dev, priv->config.txsize,\n\t\t\t\t\t priv->config.rxsize);\n\tif (err) {\n\t\tnetdev_err(dev, \"could not allocate DMA buffers\\n\");\n\t\treturn err;\n\t}\n\n\tpriv->echo_skb = kcalloc(dma->tx.size, sizeof(*priv->echo_skb),\n\t\t\t\t GFP_KERNEL);\n\tif (!priv->echo_skb) {\n\t\terr = -ENOMEM;\n\t\tgoto exit_free_dma_buffers;\n\t}\n\tpriv->can.echo_skb_max = dma->tx.size;\n\tpriv->can.echo_skb = priv->echo_skb;\n\n\t \n\terr = open_candev(dev);\n\tif (err)\n\t\tgoto exit_free_echo_skb;\n\n\terr = request_irq(dev->irq, grcan_interrupt, IRQF_SHARED,\n\t\t\t  dev->name, dev);\n\tif (err)\n\t\tgoto exit_close_candev;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tnapi_enable(&priv->napi);\n\tgrcan_start(dev);\n\tif (!(priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY))\n\t\tnetif_start_queue(dev);\n\tpriv->resetting = false;\n\tpriv->closing = false;\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n\nexit_close_candev:\n\tclose_candev(dev);\nexit_free_echo_skb:\n\tkfree(priv->echo_skb);\nexit_free_dma_buffers:\n\tgrcan_free_dma_buffers(dev);\n\treturn err;\n}\n\nstatic int grcan_close(struct net_device *dev)\n{\n\tstruct grcan_priv *priv = netdev_priv(dev);\n\tunsigned long flags;\n\n\tnapi_disable(&priv->napi);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tpriv->closing = true;\n\tif (priv->need_txbug_workaround) {\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tdel_timer_sync(&priv->hang_timer);\n\t\tdel_timer_sync(&priv->rr_timer);\n\t\tspin_lock_irqsave(&priv->lock, flags);\n\t}\n\tnetif_stop_queue(dev);\n\tgrcan_stop_hardware(dev);\n\tpriv->can.state = CAN_STATE_STOPPED;\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tfree_irq(dev->irq, dev);\n\tclose_candev(dev);\n\n\tgrcan_free_dma_buffers(dev);\n\tpriv->can.echo_skb_max = 0;\n\tpriv->can.echo_skb = NULL;\n\tkfree(priv->echo_skb);\n\n\treturn 0;\n}\n\nstatic void grcan_transmit_catch_up(struct net_device *dev)\n{\n\tstruct grcan_priv *priv = netdev_priv(dev);\n\tunsigned long flags;\n\tint work_done;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\twork_done = catch_up_echo_skb(dev, -1, true);\n\tif (work_done) {\n\t\tif (!priv->resetting && !priv->closing &&\n\t\t    !(priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY))\n\t\t\tnetif_wake_queue(dev);\n\n\t\t \n\t\tif (priv->need_txbug_workaround)\n\t\t\tdel_timer(&priv->hang_timer);\n\t}\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic int grcan_receive(struct net_device *dev, int budget)\n{\n\tstruct grcan_priv *priv = netdev_priv(dev);\n\tstruct grcan_registers __iomem *regs = priv->regs;\n\tstruct grcan_dma *dma = &priv->dma;\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tu32 wr, rd, startrd;\n\tu32 *slot;\n\tu32 i, rtr, eff, j, shift;\n\tint work_done = 0;\n\n\trd = grcan_read_reg(&regs->rxrd);\n\tstartrd = rd;\n\tfor (work_done = 0; work_done < budget; work_done++) {\n\t\t \n\t\twr = grcan_read_reg(&regs->rxwr);\n\t\tif (rd == wr)\n\t\t\tbreak;\n\n\t\t \n\t\tskb = alloc_can_skb(dev, &cf);\n\t\tif (skb == NULL) {\n\t\t\tnetdev_err(dev,\n\t\t\t\t   \"dropping frame: skb allocation failed\\n\");\n\t\t\tstats->rx_dropped++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tslot = dma->rx.buf + rd;\n\t\teff = slot[0] & GRCAN_MSG_IDE;\n\t\trtr = slot[0] & GRCAN_MSG_RTR;\n\t\tif (eff) {\n\t\t\tcf->can_id = ((slot[0] & GRCAN_MSG_EID)\n\t\t\t\t      >> GRCAN_MSG_EID_BIT);\n\t\t\tcf->can_id |= CAN_EFF_FLAG;\n\t\t} else {\n\t\t\tcf->can_id = ((slot[0] & GRCAN_MSG_BID)\n\t\t\t\t      >> GRCAN_MSG_BID_BIT);\n\t\t}\n\t\tcf->len = can_cc_dlc2len((slot[1] & GRCAN_MSG_DLC)\n\t\t\t\t\t  >> GRCAN_MSG_DLC_BIT);\n\t\tif (rtr) {\n\t\t\tcf->can_id |= CAN_RTR_FLAG;\n\t\t} else {\n\t\t\tfor (i = 0; i < cf->len; i++) {\n\t\t\t\tj = GRCAN_MSG_DATA_SLOT_INDEX(i);\n\t\t\t\tshift = GRCAN_MSG_DATA_SHIFT(i);\n\t\t\t\tcf->data[i] = (u8)(slot[j] >> shift);\n\t\t\t}\n\n\t\t\tstats->rx_bytes += cf->len;\n\t\t}\n\t\tstats->rx_packets++;\n\n\t\tnetif_receive_skb(skb);\n\n\t\trd = grcan_ring_add(rd, GRCAN_MSG_SIZE, dma->rx.size);\n\t}\n\n\t \n\tmb();\n\n\t \n\tif (likely(rd != startrd))\n\t\tgrcan_write_reg(&regs->rxrd, rd);\n\n\treturn work_done;\n}\n\nstatic int grcan_poll(struct napi_struct *napi, int budget)\n{\n\tstruct grcan_priv *priv = container_of(napi, struct grcan_priv, napi);\n\tstruct net_device *dev = priv->dev;\n\tstruct grcan_registers __iomem *regs = priv->regs;\n\tunsigned long flags;\n\tint work_done;\n\n\twork_done = grcan_receive(dev, budget);\n\n\tgrcan_transmit_catch_up(dev);\n\n\tif (work_done < budget) {\n\t\tnapi_complete(napi);\n\n\t\t \n\t\tspin_lock_irqsave(&priv->lock, flags);\n\n\t\t \n\t\tgrcan_set_bits(&regs->imr, GRCAN_IRQ_TX | GRCAN_IRQ_RX);\n\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t}\n\n\treturn work_done;\n}\n\n \nstatic int grcan_txbug_workaround(struct net_device *dev, struct sk_buff *skb,\n\t\t\t\t  u32 txwr, u32 oneshotmode,\n\t\t\t\t  netdev_tx_t *netdev_tx_status)\n{\n\tstruct grcan_priv *priv = netdev_priv(dev);\n\tstruct grcan_registers __iomem *regs = priv->regs;\n\tstruct grcan_dma *dma = &priv->dma;\n\tint i;\n\tunsigned long flags;\n\n\t \n\tfor (i = 0; i < GRCAN_SHORTWAIT_USECS; i++) {\n\t\tudelay(1);\n\t\tif (!grcan_read_bits(&regs->txctrl, GRCAN_TXCTRL_ONGOING) ||\n\t\t    grcan_read_reg(&regs->txrd) == txwr) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (!priv->resetting && !priv->closing) {\n\t\t \n\t\tif (grcan_txspace(dma->tx.size, txwr, priv->eskbp))\n\t\t\tnetif_wake_queue(dev);\n\t\t \n\t\tif (!timer_pending(&priv->hang_timer))\n\t\t\tgrcan_reset_timer(&priv->hang_timer,\n\t\t\t\t\t  priv->can.bittiming.bitrate);\n\t}\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tif (oneshotmode) {\n\t\t \n\t\tkfree_skb(skb);\n\t\t*netdev_tx_status = NETDEV_TX_OK;\n\t} else {\n\t\t \n\t\t*netdev_tx_status = NETDEV_TX_BUSY;\n\t}\n\treturn -EBUSY;\n}\n\n \nstatic netdev_tx_t grcan_start_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *dev)\n{\n\tstruct grcan_priv *priv = netdev_priv(dev);\n\tstruct grcan_registers __iomem *regs = priv->regs;\n\tstruct grcan_dma *dma = &priv->dma;\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tu32 id, txwr, txrd, space, txctrl;\n\tint slotindex;\n\tu32 *slot;\n\tu32 i, rtr, eff, dlc, tmp, err;\n\tint j, shift;\n\tunsigned long flags;\n\tu32 oneshotmode = priv->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT;\n\n\tif (can_dev_dropped_skb(dev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\t \n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\treturn NETDEV_TX_BUSY;\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\n\ttxwr = grcan_read_reg(&regs->txwr);\n\tspace = grcan_txspace(dma->tx.size, txwr, priv->eskbp);\n\n\tslotindex = txwr / GRCAN_MSG_SIZE;\n\tslot = dma->tx.buf + txwr;\n\n\tif (unlikely(space == 1))\n\t\tnetif_stop_queue(dev);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\t \n\n\t \n\tif (unlikely(!space)) {\n\t\tnetdev_err(dev, \"No buffer space, but queue is non-stopped.\\n\");\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\t \n\teff = cf->can_id & CAN_EFF_FLAG;\n\trtr = cf->can_id & CAN_RTR_FLAG;\n\tid = cf->can_id & (eff ? CAN_EFF_MASK : CAN_SFF_MASK);\n\tdlc = cf->len;\n\tif (eff)\n\t\ttmp = (id << GRCAN_MSG_EID_BIT) & GRCAN_MSG_EID;\n\telse\n\t\ttmp = (id << GRCAN_MSG_BID_BIT) & GRCAN_MSG_BID;\n\tslot[0] = (eff ? GRCAN_MSG_IDE : 0) | (rtr ? GRCAN_MSG_RTR : 0) | tmp;\n\n\tslot[1] = ((dlc << GRCAN_MSG_DLC_BIT) & GRCAN_MSG_DLC);\n\tslot[2] = 0;\n\tslot[3] = 0;\n\tfor (i = 0; i < dlc; i++) {\n\t\tj = GRCAN_MSG_DATA_SLOT_INDEX(i);\n\t\tshift = GRCAN_MSG_DATA_SHIFT(i);\n\t\tslot[j] |= cf->data[i] << shift;\n\t}\n\n\t \n\ttxctrl = grcan_read_reg(&regs->txctrl);\n\tif (!(txctrl & GRCAN_TXCTRL_ENABLE))\n\t\tnetdev_err(dev, \"tx channel spuriously disabled\\n\");\n\n\tif (oneshotmode && !(txctrl & GRCAN_TXCTRL_SINGLE))\n\t\tnetdev_err(dev, \"one-shot mode spuriously disabled\\n\");\n\n\t \n\tif (priv->need_txbug_workaround) {\n\t\ttxrd = grcan_read_reg(&regs->txrd);\n\t\tif (unlikely(grcan_ring_sub(txwr, txrd, dma->tx.size) == 1)) {\n\t\t\tnetdev_tx_t txstatus;\n\n\t\t\terr = grcan_txbug_workaround(dev, skb, txwr,\n\t\t\t\t\t\t     oneshotmode, &txstatus);\n\t\t\tif (err)\n\t\t\t\treturn txstatus;\n\t\t}\n\t}\n\n\t \n\tcan_put_echo_skb(skb, dev, slotindex, 0);\n\n\t \n\twmb();\n\n\t \n\tgrcan_write_reg(&regs->txwr,\n\t\t\tgrcan_ring_add(txwr, GRCAN_MSG_SIZE, dma->tx.size));\n\n\treturn NETDEV_TX_OK;\n}\n\n \n\n#define GRCAN_NOT_BOOL(unsigned_val) ((unsigned_val) > 1)\n\n#define GRCAN_MODULE_PARAM(name, mtype, valcheckf, desc)\t\t\\\n\tstatic void grcan_sanitize_##name(struct platform_device *pd)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\tstruct grcan_device_config grcan_default_config\t\t\\\n\t\t\t= GRCAN_DEFAULT_DEVICE_CONFIG;\t\t\t\\\n\t\tif (valcheckf(grcan_module_config.name)) {\t\t\\\n\t\t\tdev_err(&pd->dev,\t\t\t\t\\\n\t\t\t\t\"Invalid module parameter value for \"\t\\\n\t\t\t\t#name \" - setting default\\n\");\t\t\\\n\t\t\tgrcan_module_config.name =\t\t\t\\\n\t\t\t\tgrcan_default_config.name;\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tmodule_param_named(name, grcan_module_config.name,\t\t\\\n\t\t\t   mtype, 0444);\t\t\t\t\\\n\tMODULE_PARM_DESC(name, desc)\n\n#define GRCAN_CONFIG_ATTR(name, desc)\t\t\t\t\t\\\n\tstatic ssize_t grcan_store_##name(struct device *sdev,\t\t\\\n\t\t\t\t\t  struct device_attribute *att,\t\\\n\t\t\t\t\t  const char *buf,\t\t\\\n\t\t\t\t\t  size_t count)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\tstruct net_device *dev = to_net_dev(sdev);\t\t\\\n\t\tstruct grcan_priv *priv = netdev_priv(dev);\t\t\\\n\t\tu8 val;\t\t\t\t\t\t\t\\\n\t\tint ret;\t\t\t\t\t\t\\\n\t\tif (dev->flags & IFF_UP)\t\t\t\t\\\n\t\t\treturn -EBUSY;\t\t\t\t\t\\\n\t\tret = kstrtou8(buf, 0, &val);\t\t\t\t\\\n\t\tif (ret < 0 || val > 1)\t\t\t\t\t\\\n\t\t\treturn -EINVAL;\t\t\t\t\t\\\n\t\tpriv->config.name = val;\t\t\t\t\\\n\t\treturn count;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tstatic ssize_t grcan_show_##name(struct device *sdev,\t\t\\\n\t\t\t\t\t struct device_attribute *att,\t\\\n\t\t\t\t\t char *buf)\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\tstruct net_device *dev = to_net_dev(sdev);\t\t\\\n\t\tstruct grcan_priv *priv = netdev_priv(dev);\t\t\\\n\t\treturn sprintf(buf, \"%d\\n\", priv->config.name);\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tstatic DEVICE_ATTR(name, 0644,\t\t\t\t\t\\\n\t\t\t   grcan_show_##name,\t\t\t\t\\\n\t\t\t   grcan_store_##name);\t\t\t\t\\\n\tGRCAN_MODULE_PARAM(name, ushort, GRCAN_NOT_BOOL, desc)\n\n \nGRCAN_CONFIG_ATTR(enable0,\n\t\t  \"Configuration of physical interface 0. Determines\\n\"\t\\\n\t\t  \"the \\\"Enable 0\\\" bit of the configuration register.\\n\" \\\n\t\t  \"Format: 0 | 1\\nDefault: 0\\n\");\n\nGRCAN_CONFIG_ATTR(enable1,\n\t\t  \"Configuration of physical interface 1. Determines\\n\"\t\\\n\t\t  \"the \\\"Enable 1\\\" bit of the configuration register.\\n\" \\\n\t\t  \"Format: 0 | 1\\nDefault: 0\\n\");\n\nGRCAN_CONFIG_ATTR(select,\n\t\t  \"Select which physical interface to use.\\n\"\t\\\n\t\t  \"Format: 0 | 1\\nDefault: 0\\n\");\n\n \nGRCAN_MODULE_PARAM(txsize, uint, GRCAN_INVALID_BUFFER_SIZE,\n\t\t   \"Sets the size of the tx buffer.\\n\"\t\t\t\\\n\t\t   \"Format: <unsigned int> where (txsize & ~0x1fffc0) == 0\\n\" \\\n\t\t   \"Default: 1024\\n\");\nGRCAN_MODULE_PARAM(rxsize, uint, GRCAN_INVALID_BUFFER_SIZE,\n\t\t   \"Sets the size of the rx buffer.\\n\"\t\t\t\\\n\t\t   \"Format: <unsigned int> where (size & ~0x1fffc0) == 0\\n\" \\\n\t\t   \"Default: 1024\\n\");\n\n \nstatic void grcan_sanitize_module_config(struct platform_device *ofdev)\n{\n\tgrcan_sanitize_enable0(ofdev);\n\tgrcan_sanitize_enable1(ofdev);\n\tgrcan_sanitize_select(ofdev);\n\tgrcan_sanitize_txsize(ofdev);\n\tgrcan_sanitize_rxsize(ofdev);\n}\n\nstatic const struct attribute *const sysfs_grcan_attrs[] = {\n\t \n\t&dev_attr_enable0.attr,\n\t&dev_attr_enable1.attr,\n\t&dev_attr_select.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group sysfs_grcan_group = {\n\t.name\t= \"grcan\",\n\t.attrs\t= (struct attribute **)sysfs_grcan_attrs,\n};\n\n \n\nstatic const struct net_device_ops grcan_netdev_ops = {\n\t.ndo_open\t= grcan_open,\n\t.ndo_stop\t= grcan_close,\n\t.ndo_start_xmit\t= grcan_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic const struct ethtool_ops grcan_ethtool_ops = {\n\t.get_ts_info = ethtool_op_get_ts_info,\n};\n\nstatic int grcan_setup_netdev(struct platform_device *ofdev,\n\t\t\t      void __iomem *base,\n\t\t\t      int irq, u32 ambafreq, bool txbug)\n{\n\tstruct net_device *dev;\n\tstruct grcan_priv *priv;\n\tstruct grcan_registers __iomem *regs;\n\tint err;\n\n\tdev = alloc_candev(sizeof(struct grcan_priv), 0);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->irq = irq;\n\tdev->flags |= IFF_ECHO;\n\tdev->netdev_ops = &grcan_netdev_ops;\n\tdev->ethtool_ops = &grcan_ethtool_ops;\n\tdev->sysfs_groups[0] = &sysfs_grcan_group;\n\n\tpriv = netdev_priv(dev);\n\tmemcpy(&priv->config, &grcan_module_config,\n\t       sizeof(struct grcan_device_config));\n\tpriv->dev = dev;\n\tpriv->ofdev_dev = &ofdev->dev;\n\tpriv->regs = base;\n\tpriv->can.bittiming_const = &grcan_bittiming_const;\n\tpriv->can.do_set_bittiming = grcan_set_bittiming;\n\tpriv->can.do_set_mode = grcan_set_mode;\n\tpriv->can.do_get_berr_counter = grcan_get_berr_counter;\n\tpriv->can.clock.freq = ambafreq;\n\tpriv->can.ctrlmode_supported =\n\t\tCAN_CTRLMODE_LISTENONLY | CAN_CTRLMODE_ONE_SHOT;\n\tpriv->need_txbug_workaround = txbug;\n\n\t \n\tregs = priv->regs;\n\tgrcan_set_bits(&regs->ctrl, GRCAN_CTRL_RESET);\n\tgrcan_set_bits(&regs->conf, GRCAN_CONF_SAM);\n\tif (grcan_read_bits(&regs->conf, GRCAN_CONF_SAM)) {\n\t\tpriv->can.ctrlmode_supported |= CAN_CTRLMODE_3_SAMPLES;\n\t\tdev_dbg(&ofdev->dev, \"Hardware supports triple-sampling\\n\");\n\t}\n\n\tspin_lock_init(&priv->lock);\n\n\tif (priv->need_txbug_workaround) {\n\t\ttimer_setup(&priv->rr_timer, grcan_running_reset, 0);\n\t\ttimer_setup(&priv->hang_timer, grcan_initiate_running_reset, 0);\n\t}\n\n\tnetif_napi_add_weight(dev, &priv->napi, grcan_poll, GRCAN_NAPI_WEIGHT);\n\n\tSET_NETDEV_DEV(dev, &ofdev->dev);\n\tdev_info(&ofdev->dev, \"regs=0x%p, irq=%d, clock=%d\\n\",\n\t\t priv->regs, dev->irq, priv->can.clock.freq);\n\n\terr = register_candev(dev);\n\tif (err)\n\t\tgoto exit_free_candev;\n\n\tplatform_set_drvdata(ofdev, dev);\n\n\t \n\tgrcan_write_reg(&regs->ctrl, GRCAN_CTRL_RESET);\n\n\treturn 0;\nexit_free_candev:\n\tfree_candev(dev);\n\treturn err;\n}\n\nstatic int grcan_probe(struct platform_device *ofdev)\n{\n\tstruct device_node *np = ofdev->dev.of_node;\n\tstruct device_node *sysid_parent;\n\tu32 sysid, ambafreq;\n\tint irq, err;\n\tvoid __iomem *base;\n\tbool txbug = true;\n\n\t \n\tsysid_parent = of_find_node_by_path(\"/ambapp0\");\n\tif (sysid_parent) {\n\t\terr = of_property_read_u32(sysid_parent, \"systemid\", &sysid);\n\t\tif (!err && ((sysid & GRLIB_VERSION_MASK) >=\n\t\t\t     GRCAN_TXBUG_SAFE_GRLIB_VERSION))\n\t\t\ttxbug = false;\n\t\tof_node_put(sysid_parent);\n\t}\n\n\terr = of_property_read_u32(np, \"freq\", &ambafreq);\n\tif (err) {\n\t\tdev_err(&ofdev->dev, \"unable to fetch \\\"freq\\\" property\\n\");\n\t\tgoto exit_error;\n\t}\n\n\tbase = devm_platform_ioremap_resource(ofdev, 0);\n\tif (IS_ERR(base)) {\n\t\terr = PTR_ERR(base);\n\t\tgoto exit_error;\n\t}\n\n\tirq = irq_of_parse_and_map(np, GRCAN_IRQIX_IRQ);\n\tif (!irq) {\n\t\tdev_err(&ofdev->dev, \"no irq found\\n\");\n\t\terr = -ENODEV;\n\t\tgoto exit_error;\n\t}\n\n\tgrcan_sanitize_module_config(ofdev);\n\n\terr = grcan_setup_netdev(ofdev, base, irq, ambafreq, txbug);\n\tif (err)\n\t\tgoto exit_dispose_irq;\n\n\treturn 0;\n\nexit_dispose_irq:\n\tirq_dispose_mapping(irq);\nexit_error:\n\tdev_err(&ofdev->dev,\n\t\t\"%s socket CAN driver initialization failed with error %d\\n\",\n\t\tDRV_NAME, err);\n\treturn err;\n}\n\nstatic void grcan_remove(struct platform_device *ofdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(ofdev);\n\tstruct grcan_priv *priv = netdev_priv(dev);\n\n\tunregister_candev(dev);  \n\n\tirq_dispose_mapping(dev->irq);\n\tnetif_napi_del(&priv->napi);\n\tfree_candev(dev);\n}\n\nstatic const struct of_device_id grcan_match[] = {\n\t{.name = \"GAISLER_GRCAN\"},\n\t{.name = \"01_03d\"},\n\t{.name = \"GAISLER_GRHCAN\"},\n\t{.name = \"01_034\"},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, grcan_match);\n\nstatic struct platform_driver grcan_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = grcan_match,\n\t},\n\t.probe = grcan_probe,\n\t.remove_new = grcan_remove,\n};\n\nmodule_platform_driver(grcan_driver);\n\nMODULE_AUTHOR(\"Aeroflex Gaisler AB.\");\nMODULE_DESCRIPTION(\"Socket CAN driver for Aeroflex Gaisler GRCAN\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}