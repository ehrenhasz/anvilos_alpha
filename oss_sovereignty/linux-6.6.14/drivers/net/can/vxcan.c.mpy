{
  "module_name": "vxcan.c",
  "hash_id": "d5311be089d8b125d95ab3efa262c51147f1374814cfe2124ab1b089482d4552",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/vxcan.c",
  "human_readable_source": "\n \n\n#include <linux/ethtool.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/skb.h>\n#include <linux/can/vxcan.h>\n#include <linux/can/can-ml.h>\n#include <linux/slab.h>\n#include <net/rtnetlink.h>\n\n#define DRV_NAME \"vxcan\"\n\nMODULE_DESCRIPTION(\"Virtual CAN Tunnel\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Oliver Hartkopp <socketcan@hartkopp.net>\");\nMODULE_ALIAS_RTNL_LINK(DRV_NAME);\n\nstruct vxcan_priv {\n\tstruct net_device __rcu\t*peer;\n};\n\nstatic netdev_tx_t vxcan_xmit(struct sk_buff *oskb, struct net_device *dev)\n{\n\tstruct vxcan_priv *priv = netdev_priv(dev);\n\tstruct net_device *peer;\n\tstruct net_device_stats *peerstats, *srcstats = &dev->stats;\n\tstruct sk_buff *skb;\n\tunsigned int len;\n\n\tif (can_dropped_invalid_skb(dev, oskb))\n\t\treturn NETDEV_TX_OK;\n\n\trcu_read_lock();\n\tpeer = rcu_dereference(priv->peer);\n\tif (unlikely(!peer)) {\n\t\tkfree_skb(oskb);\n\t\tdev->stats.tx_dropped++;\n\t\tgoto out_unlock;\n\t}\n\n\tskb_tx_timestamp(oskb);\n\n\tskb = skb_clone(oskb, GFP_ATOMIC);\n\tif (skb) {\n\t\tconsume_skb(oskb);\n\t} else {\n\t\tkfree_skb(oskb);\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tskb->csum_start = 0;\n\tskb->pkt_type   = PACKET_BROADCAST;\n\tskb->dev        = peer;\n\tskb->ip_summed  = CHECKSUM_UNNECESSARY;\n\n\tlen = can_skb_get_data_len(skb);\n\tif (netif_rx(skb) == NET_RX_SUCCESS) {\n\t\tsrcstats->tx_packets++;\n\t\tsrcstats->tx_bytes += len;\n\t\tpeerstats = &peer->stats;\n\t\tpeerstats->rx_packets++;\n\t\tpeerstats->rx_bytes += len;\n\t}\n\nout_unlock:\n\trcu_read_unlock();\n\treturn NETDEV_TX_OK;\n}\n\n\nstatic int vxcan_open(struct net_device *dev)\n{\n\tstruct vxcan_priv *priv = netdev_priv(dev);\n\tstruct net_device *peer = rtnl_dereference(priv->peer);\n\n\tif (!peer)\n\t\treturn -ENOTCONN;\n\n\tif (peer->flags & IFF_UP) {\n\t\tnetif_carrier_on(dev);\n\t\tnetif_carrier_on(peer);\n\t}\n\treturn 0;\n}\n\nstatic int vxcan_close(struct net_device *dev)\n{\n\tstruct vxcan_priv *priv = netdev_priv(dev);\n\tstruct net_device *peer = rtnl_dereference(priv->peer);\n\n\tnetif_carrier_off(dev);\n\tif (peer)\n\t\tnetif_carrier_off(peer);\n\n\treturn 0;\n}\n\nstatic int vxcan_get_iflink(const struct net_device *dev)\n{\n\tstruct vxcan_priv *priv = netdev_priv(dev);\n\tstruct net_device *peer;\n\tint iflink;\n\n\trcu_read_lock();\n\tpeer = rcu_dereference(priv->peer);\n\tiflink = peer ? peer->ifindex : 0;\n\trcu_read_unlock();\n\n\treturn iflink;\n}\n\nstatic int vxcan_change_mtu(struct net_device *dev, int new_mtu)\n{\n\t \n\tif (dev->flags & IFF_UP)\n\t\treturn -EBUSY;\n\n\tif (new_mtu != CAN_MTU && new_mtu != CANFD_MTU &&\n\t    !can_is_canxl_dev_mtu(new_mtu))\n\t\treturn -EINVAL;\n\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\nstatic const struct net_device_ops vxcan_netdev_ops = {\n\t.ndo_open\t= vxcan_open,\n\t.ndo_stop\t= vxcan_close,\n\t.ndo_start_xmit\t= vxcan_xmit,\n\t.ndo_get_iflink\t= vxcan_get_iflink,\n\t.ndo_change_mtu = vxcan_change_mtu,\n};\n\nstatic const struct ethtool_ops vxcan_ethtool_ops = {\n\t.get_ts_info = ethtool_op_get_ts_info,\n};\n\nstatic void vxcan_setup(struct net_device *dev)\n{\n\tstruct can_ml_priv *can_ml;\n\n\tdev->type\t\t= ARPHRD_CAN;\n\tdev->mtu\t\t= CANFD_MTU;\n\tdev->hard_header_len\t= 0;\n\tdev->addr_len\t\t= 0;\n\tdev->tx_queue_len\t= 0;\n\tdev->flags\t\t= IFF_NOARP;\n\tdev->netdev_ops\t\t= &vxcan_netdev_ops;\n\tdev->ethtool_ops\t= &vxcan_ethtool_ops;\n\tdev->needs_free_netdev\t= true;\n\n\tcan_ml = netdev_priv(dev) + ALIGN(sizeof(struct vxcan_priv), NETDEV_ALIGN);\n\tcan_set_ml_priv(dev, can_ml);\n}\n\n \nstatic struct rtnl_link_ops vxcan_link_ops;\n\nstatic int vxcan_newlink(struct net *net, struct net_device *dev,\n\t\t\t struct nlattr *tb[], struct nlattr *data[],\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct vxcan_priv *priv;\n\tstruct net_device *peer;\n\tstruct net *peer_net;\n\n\tstruct nlattr *peer_tb[IFLA_MAX + 1], **tbp = tb;\n\tchar ifname[IFNAMSIZ];\n\tunsigned char name_assign_type;\n\tstruct ifinfomsg *ifmp = NULL;\n\tint err;\n\n\t \n\tif (data && data[VXCAN_INFO_PEER]) {\n\t\tstruct nlattr *nla_peer;\n\n\t\tnla_peer = data[VXCAN_INFO_PEER];\n\t\tifmp = nla_data(nla_peer);\n\t\terr = rtnl_nla_parse_ifinfomsg(peer_tb, nla_peer, extack);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\ttbp = peer_tb;\n\t}\n\n\tif (ifmp && tbp[IFLA_IFNAME]) {\n\t\tnla_strscpy(ifname, tbp[IFLA_IFNAME], IFNAMSIZ);\n\t\tname_assign_type = NET_NAME_USER;\n\t} else {\n\t\tsnprintf(ifname, IFNAMSIZ, DRV_NAME \"%%d\");\n\t\tname_assign_type = NET_NAME_ENUM;\n\t}\n\n\tpeer_net = rtnl_link_get_net(net, tbp);\n\tif (IS_ERR(peer_net))\n\t\treturn PTR_ERR(peer_net);\n\n\tpeer = rtnl_create_link(peer_net, ifname, name_assign_type,\n\t\t\t\t&vxcan_link_ops, tbp, extack);\n\tif (IS_ERR(peer)) {\n\t\tput_net(peer_net);\n\t\treturn PTR_ERR(peer);\n\t}\n\n\tif (ifmp && dev->ifindex)\n\t\tpeer->ifindex = ifmp->ifi_index;\n\n\terr = register_netdevice(peer);\n\tput_net(peer_net);\n\tpeer_net = NULL;\n\tif (err < 0) {\n\t\tfree_netdev(peer);\n\t\treturn err;\n\t}\n\n\tnetif_carrier_off(peer);\n\n\terr = rtnl_configure_link(peer, ifmp, 0, NULL);\n\tif (err < 0)\n\t\tgoto unregister_network_device;\n\n\t \n\tif (tb[IFLA_IFNAME])\n\t\tnla_strscpy(dev->name, tb[IFLA_IFNAME], IFNAMSIZ);\n\telse\n\t\tsnprintf(dev->name, IFNAMSIZ, DRV_NAME \"%%d\");\n\n\terr = register_netdevice(dev);\n\tif (err < 0)\n\t\tgoto unregister_network_device;\n\n\tnetif_carrier_off(dev);\n\n\t \n\tpriv = netdev_priv(dev);\n\trcu_assign_pointer(priv->peer, peer);\n\n\tpriv = netdev_priv(peer);\n\trcu_assign_pointer(priv->peer, dev);\n\n\treturn 0;\n\nunregister_network_device:\n\tunregister_netdevice(peer);\n\treturn err;\n}\n\nstatic void vxcan_dellink(struct net_device *dev, struct list_head *head)\n{\n\tstruct vxcan_priv *priv;\n\tstruct net_device *peer;\n\n\tpriv = netdev_priv(dev);\n\tpeer = rtnl_dereference(priv->peer);\n\n\t \n\tRCU_INIT_POINTER(priv->peer, NULL);\n\tunregister_netdevice_queue(dev, head);\n\n\tif (peer) {\n\t\tpriv = netdev_priv(peer);\n\t\tRCU_INIT_POINTER(priv->peer, NULL);\n\t\tunregister_netdevice_queue(peer, head);\n\t}\n}\n\nstatic const struct nla_policy vxcan_policy[VXCAN_INFO_MAX + 1] = {\n\t[VXCAN_INFO_PEER] = { .len = sizeof(struct ifinfomsg) },\n};\n\nstatic struct net *vxcan_get_link_net(const struct net_device *dev)\n{\n\tstruct vxcan_priv *priv = netdev_priv(dev);\n\tstruct net_device *peer = rtnl_dereference(priv->peer);\n\n\treturn peer ? dev_net(peer) : dev_net(dev);\n}\n\nstatic struct rtnl_link_ops vxcan_link_ops = {\n\t.kind\t\t= DRV_NAME,\n\t.priv_size\t= ALIGN(sizeof(struct vxcan_priv), NETDEV_ALIGN) + sizeof(struct can_ml_priv),\n\t.setup\t\t= vxcan_setup,\n\t.newlink\t= vxcan_newlink,\n\t.dellink\t= vxcan_dellink,\n\t.policy\t\t= vxcan_policy,\n\t.maxtype\t= VXCAN_INFO_MAX,\n\t.get_link_net\t= vxcan_get_link_net,\n};\n\nstatic __init int vxcan_init(void)\n{\n\tpr_info(\"vxcan: Virtual CAN Tunnel driver\\n\");\n\n\treturn rtnl_link_register(&vxcan_link_ops);\n}\n\nstatic __exit void vxcan_exit(void)\n{\n\trtnl_link_unregister(&vxcan_link_ops);\n}\n\nmodule_init(vxcan_init);\nmodule_exit(vxcan_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}