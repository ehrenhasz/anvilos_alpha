{
  "module_name": "at91_can.c",
  "hash_id": "e850d8066105ddb0b3239a5ea42d9aef64e8035d869c45fbc4a22f2c94e15414",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/at91_can.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/errno.h>\n#include <linux/ethtool.h>\n#include <linux/if_arp.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/rtnetlink.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n\n#define AT91_MB_MASK(i)\t\t((1 << (i)) - 1)\n\n \nenum at91_reg {\n\tAT91_MR\t\t= 0x000,\n\tAT91_IER\t= 0x004,\n\tAT91_IDR\t= 0x008,\n\tAT91_IMR\t= 0x00C,\n\tAT91_SR\t\t= 0x010,\n\tAT91_BR\t\t= 0x014,\n\tAT91_TIM\t= 0x018,\n\tAT91_TIMESTP\t= 0x01C,\n\tAT91_ECR\t= 0x020,\n\tAT91_TCR\t= 0x024,\n\tAT91_ACR\t= 0x028,\n};\n\n \n#define AT91_MMR(i)\t\t((enum at91_reg)(0x200 + ((i) * 0x20)))\n#define AT91_MAM(i)\t\t((enum at91_reg)(0x204 + ((i) * 0x20)))\n#define AT91_MID(i)\t\t((enum at91_reg)(0x208 + ((i) * 0x20)))\n#define AT91_MFID(i)\t\t((enum at91_reg)(0x20C + ((i) * 0x20)))\n#define AT91_MSR(i)\t\t((enum at91_reg)(0x210 + ((i) * 0x20)))\n#define AT91_MDL(i)\t\t((enum at91_reg)(0x214 + ((i) * 0x20)))\n#define AT91_MDH(i)\t\t((enum at91_reg)(0x218 + ((i) * 0x20)))\n#define AT91_MCR(i)\t\t((enum at91_reg)(0x21C + ((i) * 0x20)))\n\n \n#define AT91_MR_CANEN\t\tBIT(0)\n#define AT91_MR_LPM\t\tBIT(1)\n#define AT91_MR_ABM\t\tBIT(2)\n#define AT91_MR_OVL\t\tBIT(3)\n#define AT91_MR_TEOF\t\tBIT(4)\n#define AT91_MR_TTM\t\tBIT(5)\n#define AT91_MR_TIMFRZ\t\tBIT(6)\n#define AT91_MR_DRPT\t\tBIT(7)\n\n#define AT91_SR_RBSY\t\tBIT(29)\n\n#define AT91_MMR_PRIO_SHIFT\t(16)\n\n#define AT91_MID_MIDE\t\tBIT(29)\n\n#define AT91_MSR_MRTR\t\tBIT(20)\n#define AT91_MSR_MABT\t\tBIT(22)\n#define AT91_MSR_MRDY\t\tBIT(23)\n#define AT91_MSR_MMI\t\tBIT(24)\n\n#define AT91_MCR_MRTR\t\tBIT(20)\n#define AT91_MCR_MTCR\t\tBIT(23)\n\n \nenum at91_mb_mode {\n\tAT91_MB_MODE_DISABLED\t= 0,\n\tAT91_MB_MODE_RX\t\t= 1,\n\tAT91_MB_MODE_RX_OVRWR\t= 2,\n\tAT91_MB_MODE_TX\t\t= 3,\n\tAT91_MB_MODE_CONSUMER\t= 4,\n\tAT91_MB_MODE_PRODUCER\t= 5,\n};\n\n \n#define AT91_IRQ_ERRA\t\tBIT(16)\n#define AT91_IRQ_WARN\t\tBIT(17)\n#define AT91_IRQ_ERRP\t\tBIT(18)\n#define AT91_IRQ_BOFF\t\tBIT(19)\n#define AT91_IRQ_SLEEP\t\tBIT(20)\n#define AT91_IRQ_WAKEUP\t\tBIT(21)\n#define AT91_IRQ_TOVF\t\tBIT(22)\n#define AT91_IRQ_TSTP\t\tBIT(23)\n#define AT91_IRQ_CERR\t\tBIT(24)\n#define AT91_IRQ_SERR\t\tBIT(25)\n#define AT91_IRQ_AERR\t\tBIT(26)\n#define AT91_IRQ_FERR\t\tBIT(27)\n#define AT91_IRQ_BERR\t\tBIT(28)\n\n#define AT91_IRQ_ERR_ALL\t(0x1fff0000)\n#define AT91_IRQ_ERR_FRAME\t(AT91_IRQ_CERR | AT91_IRQ_SERR | \\\n\t\t\t\t AT91_IRQ_AERR | AT91_IRQ_FERR | AT91_IRQ_BERR)\n#define AT91_IRQ_ERR_LINE\t(AT91_IRQ_ERRA | AT91_IRQ_WARN | \\\n\t\t\t\t AT91_IRQ_ERRP | AT91_IRQ_BOFF)\n\n#define AT91_IRQ_ALL\t\t(0x1fffffff)\n\nenum at91_devtype {\n\tAT91_DEVTYPE_SAM9263,\n\tAT91_DEVTYPE_SAM9X5,\n};\n\nstruct at91_devtype_data {\n\tunsigned int rx_first;\n\tunsigned int rx_split;\n\tunsigned int rx_last;\n\tunsigned int tx_shift;\n\tenum at91_devtype type;\n};\n\nstruct at91_priv {\n\tstruct can_priv can;\t\t \n\tstruct napi_struct napi;\n\n\tvoid __iomem *reg_base;\n\n\tu32 reg_sr;\n\tunsigned int tx_next;\n\tunsigned int tx_echo;\n\tunsigned int rx_next;\n\tstruct at91_devtype_data devtype_data;\n\n\tstruct clk *clk;\n\tstruct at91_can_data *pdata;\n\n\tcanid_t mb0_id;\n};\n\nstatic const struct at91_devtype_data at91_at91sam9263_data = {\n\t.rx_first = 1,\n\t.rx_split = 8,\n\t.rx_last = 11,\n\t.tx_shift = 2,\n\t.type = AT91_DEVTYPE_SAM9263,\n};\n\nstatic const struct at91_devtype_data at91_at91sam9x5_data = {\n\t.rx_first = 0,\n\t.rx_split = 4,\n\t.rx_last = 5,\n\t.tx_shift = 1,\n\t.type = AT91_DEVTYPE_SAM9X5,\n};\n\nstatic const struct can_bittiming_const at91_bittiming_const = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.tseg1_min\t= 4,\n\t.tseg1_max\t= 16,\n\t.tseg2_min\t= 2,\n\t.tseg2_max\t= 8,\n\t.sjw_max\t= 4,\n\t.brp_min\t= 2,\n\t.brp_max\t= 128,\n\t.brp_inc\t= 1,\n};\n\n#define AT91_IS(_model) \\\nstatic inline int __maybe_unused at91_is_sam##_model(const struct at91_priv *priv) \\\n{ \\\n\treturn priv->devtype_data.type == AT91_DEVTYPE_SAM##_model; \\\n}\n\nAT91_IS(9263);\nAT91_IS(9X5);\n\nstatic inline unsigned int get_mb_rx_first(const struct at91_priv *priv)\n{\n\treturn priv->devtype_data.rx_first;\n}\n\nstatic inline unsigned int get_mb_rx_last(const struct at91_priv *priv)\n{\n\treturn priv->devtype_data.rx_last;\n}\n\nstatic inline unsigned int get_mb_rx_split(const struct at91_priv *priv)\n{\n\treturn priv->devtype_data.rx_split;\n}\n\nstatic inline unsigned int get_mb_rx_num(const struct at91_priv *priv)\n{\n\treturn get_mb_rx_last(priv) - get_mb_rx_first(priv) + 1;\n}\n\nstatic inline unsigned int get_mb_rx_low_last(const struct at91_priv *priv)\n{\n\treturn get_mb_rx_split(priv) - 1;\n}\n\nstatic inline unsigned int get_mb_rx_low_mask(const struct at91_priv *priv)\n{\n\treturn AT91_MB_MASK(get_mb_rx_split(priv)) &\n\t\t~AT91_MB_MASK(get_mb_rx_first(priv));\n}\n\nstatic inline unsigned int get_mb_tx_shift(const struct at91_priv *priv)\n{\n\treturn priv->devtype_data.tx_shift;\n}\n\nstatic inline unsigned int get_mb_tx_num(const struct at91_priv *priv)\n{\n\treturn 1 << get_mb_tx_shift(priv);\n}\n\nstatic inline unsigned int get_mb_tx_first(const struct at91_priv *priv)\n{\n\treturn get_mb_rx_last(priv) + 1;\n}\n\nstatic inline unsigned int get_mb_tx_last(const struct at91_priv *priv)\n{\n\treturn get_mb_tx_first(priv) + get_mb_tx_num(priv) - 1;\n}\n\nstatic inline unsigned int get_next_prio_shift(const struct at91_priv *priv)\n{\n\treturn get_mb_tx_shift(priv);\n}\n\nstatic inline unsigned int get_next_prio_mask(const struct at91_priv *priv)\n{\n\treturn 0xf << get_mb_tx_shift(priv);\n}\n\nstatic inline unsigned int get_next_mb_mask(const struct at91_priv *priv)\n{\n\treturn AT91_MB_MASK(get_mb_tx_shift(priv));\n}\n\nstatic inline unsigned int get_next_mask(const struct at91_priv *priv)\n{\n\treturn get_next_mb_mask(priv) | get_next_prio_mask(priv);\n}\n\nstatic inline unsigned int get_irq_mb_rx(const struct at91_priv *priv)\n{\n\treturn AT91_MB_MASK(get_mb_rx_last(priv) + 1) &\n\t\t~AT91_MB_MASK(get_mb_rx_first(priv));\n}\n\nstatic inline unsigned int get_irq_mb_tx(const struct at91_priv *priv)\n{\n\treturn AT91_MB_MASK(get_mb_tx_last(priv) + 1) &\n\t\t~AT91_MB_MASK(get_mb_tx_first(priv));\n}\n\nstatic inline unsigned int get_tx_next_mb(const struct at91_priv *priv)\n{\n\treturn (priv->tx_next & get_next_mb_mask(priv)) + get_mb_tx_first(priv);\n}\n\nstatic inline unsigned int get_tx_next_prio(const struct at91_priv *priv)\n{\n\treturn (priv->tx_next >> get_next_prio_shift(priv)) & 0xf;\n}\n\nstatic inline unsigned int get_tx_echo_mb(const struct at91_priv *priv)\n{\n\treturn (priv->tx_echo & get_next_mb_mask(priv)) + get_mb_tx_first(priv);\n}\n\nstatic inline u32 at91_read(const struct at91_priv *priv, enum at91_reg reg)\n{\n\treturn readl_relaxed(priv->reg_base + reg);\n}\n\nstatic inline void at91_write(const struct at91_priv *priv, enum at91_reg reg,\n\t\t\t      u32 value)\n{\n\twritel_relaxed(value, priv->reg_base + reg);\n}\n\nstatic inline void set_mb_mode_prio(const struct at91_priv *priv,\n\t\t\t\t    unsigned int mb, enum at91_mb_mode mode,\n\t\t\t\t    int prio)\n{\n\tat91_write(priv, AT91_MMR(mb), (mode << 24) | (prio << 16));\n}\n\nstatic inline void set_mb_mode(const struct at91_priv *priv, unsigned int mb,\n\t\t\t       enum at91_mb_mode mode)\n{\n\tset_mb_mode_prio(priv, mb, mode, 0);\n}\n\nstatic inline u32 at91_can_id_to_reg_mid(canid_t can_id)\n{\n\tu32 reg_mid;\n\n\tif (can_id & CAN_EFF_FLAG)\n\t\treg_mid = (can_id & CAN_EFF_MASK) | AT91_MID_MIDE;\n\telse\n\t\treg_mid = (can_id & CAN_SFF_MASK) << 18;\n\n\treturn reg_mid;\n}\n\nstatic void at91_setup_mailboxes(struct net_device *dev)\n{\n\tstruct at91_priv *priv = netdev_priv(dev);\n\tunsigned int i;\n\tu32 reg_mid;\n\n\t \n\treg_mid = at91_can_id_to_reg_mid(priv->mb0_id);\n\tfor (i = 0; i < get_mb_rx_first(priv); i++) {\n\t\tset_mb_mode(priv, i, AT91_MB_MODE_DISABLED);\n\t\tat91_write(priv, AT91_MID(i), reg_mid);\n\t\tat91_write(priv, AT91_MCR(i), 0x0);\t \n\t}\n\n\tfor (i = get_mb_rx_first(priv); i < get_mb_rx_last(priv); i++)\n\t\tset_mb_mode(priv, i, AT91_MB_MODE_RX);\n\tset_mb_mode(priv, get_mb_rx_last(priv), AT91_MB_MODE_RX_OVRWR);\n\n\t \n\tfor (i = get_mb_rx_first(priv); i <= get_mb_rx_last(priv); i++) {\n\t\tat91_write(priv, AT91_MAM(i), 0x0);\n\t\tat91_write(priv, AT91_MID(i), AT91_MID_MIDE);\n\t}\n\n\t \n\tfor (i = get_mb_tx_first(priv); i <= get_mb_tx_last(priv); i++)\n\t\tset_mb_mode_prio(priv, i, AT91_MB_MODE_TX, 0);\n\n\t \n\tpriv->tx_next = priv->tx_echo = 0;\n\tpriv->rx_next = get_mb_rx_first(priv);\n}\n\nstatic int at91_set_bittiming(struct net_device *dev)\n{\n\tconst struct at91_priv *priv = netdev_priv(dev);\n\tconst struct can_bittiming *bt = &priv->can.bittiming;\n\tu32 reg_br;\n\n\treg_br = ((priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES) ? 1 << 24 : 0) |\n\t\t((bt->brp - 1) << 16) | ((bt->sjw - 1) << 12) |\n\t\t((bt->prop_seg - 1) << 8) | ((bt->phase_seg1 - 1) << 4) |\n\t\t((bt->phase_seg2 - 1) << 0);\n\n\tnetdev_info(dev, \"writing AT91_BR: 0x%08x\\n\", reg_br);\n\n\tat91_write(priv, AT91_BR, reg_br);\n\n\treturn 0;\n}\n\nstatic int at91_get_berr_counter(const struct net_device *dev,\n\t\t\t\t struct can_berr_counter *bec)\n{\n\tconst struct at91_priv *priv = netdev_priv(dev);\n\tu32 reg_ecr = at91_read(priv, AT91_ECR);\n\n\tbec->rxerr = reg_ecr & 0xff;\n\tbec->txerr = reg_ecr >> 16;\n\n\treturn 0;\n}\n\nstatic void at91_chip_start(struct net_device *dev)\n{\n\tstruct at91_priv *priv = netdev_priv(dev);\n\tu32 reg_mr, reg_ier;\n\n\t \n\tat91_write(priv, AT91_IDR, AT91_IRQ_ALL);\n\n\t \n\treg_mr = at91_read(priv, AT91_MR);\n\tat91_write(priv, AT91_MR, reg_mr & ~AT91_MR_CANEN);\n\n\tat91_set_bittiming(dev);\n\tat91_setup_mailboxes(dev);\n\n\t \n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\treg_mr = AT91_MR_CANEN | AT91_MR_ABM;\n\telse\n\t\treg_mr = AT91_MR_CANEN;\n\tat91_write(priv, AT91_MR, reg_mr);\n\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\t \n\treg_ier = get_irq_mb_rx(priv) | AT91_IRQ_ERRP | AT91_IRQ_ERR_FRAME;\n\tat91_write(priv, AT91_IDR, AT91_IRQ_ALL);\n\tat91_write(priv, AT91_IER, reg_ier);\n}\n\nstatic void at91_chip_stop(struct net_device *dev, enum can_state state)\n{\n\tstruct at91_priv *priv = netdev_priv(dev);\n\tu32 reg_mr;\n\n\t \n\tat91_write(priv, AT91_IDR, AT91_IRQ_ALL);\n\n\treg_mr = at91_read(priv, AT91_MR);\n\tat91_write(priv, AT91_MR, reg_mr & ~AT91_MR_CANEN);\n\n\tpriv->can.state = state;\n}\n\n \nstatic netdev_tx_t at91_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct at91_priv *priv = netdev_priv(dev);\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tunsigned int mb, prio;\n\tu32 reg_mid, reg_mcr;\n\n\tif (can_dev_dropped_skb(dev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tmb = get_tx_next_mb(priv);\n\tprio = get_tx_next_prio(priv);\n\n\tif (unlikely(!(at91_read(priv, AT91_MSR(mb)) & AT91_MSR_MRDY))) {\n\t\tnetif_stop_queue(dev);\n\n\t\tnetdev_err(dev, \"BUG! TX buffer full when queue awake!\\n\");\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\treg_mid = at91_can_id_to_reg_mid(cf->can_id);\n\treg_mcr = ((cf->can_id & CAN_RTR_FLAG) ? AT91_MCR_MRTR : 0) |\n\t\t(cf->len << 16) | AT91_MCR_MTCR;\n\n\t \n\tset_mb_mode(priv, mb, AT91_MB_MODE_DISABLED);\n\tat91_write(priv, AT91_MID(mb), reg_mid);\n\tset_mb_mode_prio(priv, mb, AT91_MB_MODE_TX, prio);\n\n\tat91_write(priv, AT91_MDL(mb), *(u32 *)(cf->data + 0));\n\tat91_write(priv, AT91_MDH(mb), *(u32 *)(cf->data + 4));\n\n\t \n\tat91_write(priv, AT91_MCR(mb), reg_mcr);\n\n\t \n\tcan_put_echo_skb(skb, dev, mb - get_mb_tx_first(priv), 0);\n\n\t \n\tpriv->tx_next++;\n\tif (!(at91_read(priv, AT91_MSR(get_tx_next_mb(priv))) &\n\t      AT91_MSR_MRDY) ||\n\t    (priv->tx_next & get_next_mask(priv)) == 0)\n\t\tnetif_stop_queue(dev);\n\n\t \n\tat91_write(priv, AT91_IER, 1 << mb);\n\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic inline void at91_activate_rx_low(const struct at91_priv *priv)\n{\n\tu32 mask = get_mb_rx_low_mask(priv);\n\n\tat91_write(priv, AT91_TCR, mask);\n}\n\n \nstatic inline void at91_activate_rx_mb(const struct at91_priv *priv,\n\t\t\t\t       unsigned int mb)\n{\n\tu32 mask = 1 << mb;\n\n\tat91_write(priv, AT91_TCR, mask);\n}\n\n \nstatic void at91_rx_overflow_err(struct net_device *dev)\n{\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct sk_buff *skb;\n\tstruct can_frame *cf;\n\n\tnetdev_dbg(dev, \"RX buffer overflow\\n\");\n\tstats->rx_over_errors++;\n\tstats->rx_errors++;\n\n\tskb = alloc_can_err_skb(dev, &cf);\n\tif (unlikely(!skb))\n\t\treturn;\n\n\tcf->can_id |= CAN_ERR_CRTL;\n\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\n\tnetif_receive_skb(skb);\n}\n\n \nstatic void at91_read_mb(struct net_device *dev, unsigned int mb,\n\t\t\t struct can_frame *cf)\n{\n\tconst struct at91_priv *priv = netdev_priv(dev);\n\tu32 reg_msr, reg_mid;\n\n\treg_mid = at91_read(priv, AT91_MID(mb));\n\tif (reg_mid & AT91_MID_MIDE)\n\t\tcf->can_id = ((reg_mid >> 0) & CAN_EFF_MASK) | CAN_EFF_FLAG;\n\telse\n\t\tcf->can_id = (reg_mid >> 18) & CAN_SFF_MASK;\n\n\treg_msr = at91_read(priv, AT91_MSR(mb));\n\tcf->len = can_cc_dlc2len((reg_msr >> 16) & 0xf);\n\n\tif (reg_msr & AT91_MSR_MRTR) {\n\t\tcf->can_id |= CAN_RTR_FLAG;\n\t} else {\n\t\t*(u32 *)(cf->data + 0) = at91_read(priv, AT91_MDL(mb));\n\t\t*(u32 *)(cf->data + 4) = at91_read(priv, AT91_MDH(mb));\n\t}\n\n\t \n\tat91_write(priv, AT91_MID(mb), AT91_MID_MIDE);\n\n\tif (unlikely(mb == get_mb_rx_last(priv) && reg_msr & AT91_MSR_MMI))\n\t\tat91_rx_overflow_err(dev);\n}\n\n \nstatic void at91_read_msg(struct net_device *dev, unsigned int mb)\n{\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\n\tskb = alloc_can_skb(dev, &cf);\n\tif (unlikely(!skb)) {\n\t\tstats->rx_dropped++;\n\t\treturn;\n\t}\n\n\tat91_read_mb(dev, mb, cf);\n\n\tstats->rx_packets++;\n\tif (!(cf->can_id & CAN_RTR_FLAG))\n\t\tstats->rx_bytes += cf->len;\n\n\tnetif_receive_skb(skb);\n}\n\n \nstatic int at91_poll_rx(struct net_device *dev, int quota)\n{\n\tstruct at91_priv *priv = netdev_priv(dev);\n\tu32 reg_sr = at91_read(priv, AT91_SR);\n\tconst unsigned long *addr = (unsigned long *)&reg_sr;\n\tunsigned int mb;\n\tint received = 0;\n\n\tif (priv->rx_next > get_mb_rx_low_last(priv) &&\n\t    reg_sr & get_mb_rx_low_mask(priv))\n\t\tnetdev_info(dev,\n\t\t\t    \"order of incoming frames cannot be guaranteed\\n\");\n\n again:\n\tfor (mb = find_next_bit(addr, get_mb_tx_first(priv), priv->rx_next);\n\t     mb < get_mb_tx_first(priv) && quota > 0;\n\t     reg_sr = at91_read(priv, AT91_SR),\n\t     mb = find_next_bit(addr, get_mb_tx_first(priv), ++priv->rx_next)) {\n\t\tat91_read_msg(dev, mb);\n\n\t\t \n\t\tif (mb == get_mb_rx_low_last(priv))\n\t\t\t \n\t\t\tat91_activate_rx_low(priv);\n\t\telse if (mb > get_mb_rx_low_last(priv))\n\t\t\t \n\t\t\tat91_activate_rx_mb(priv, mb);\n\n\t\treceived++;\n\t\tquota--;\n\t}\n\n\t \n\tif (priv->rx_next > get_mb_rx_low_last(priv) &&\n\t    mb > get_mb_rx_last(priv)) {\n\t\tpriv->rx_next = get_mb_rx_first(priv);\n\t\tif (quota > 0)\n\t\t\tgoto again;\n\t}\n\n\treturn received;\n}\n\nstatic void at91_poll_err_frame(struct net_device *dev,\n\t\t\t\tstruct can_frame *cf, u32 reg_sr)\n{\n\tstruct at91_priv *priv = netdev_priv(dev);\n\n\t \n\tif (reg_sr & AT91_IRQ_CERR) {\n\t\tnetdev_dbg(dev, \"CERR irq\\n\");\n\t\tdev->stats.rx_errors++;\n\t\tpriv->can.can_stats.bus_error++;\n\t\tcf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\n\t}\n\n\t \n\tif (reg_sr & AT91_IRQ_SERR) {\n\t\tnetdev_dbg(dev, \"SERR irq\\n\");\n\t\tdev->stats.rx_errors++;\n\t\tpriv->can.can_stats.bus_error++;\n\t\tcf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\n\t\tcf->data[2] |= CAN_ERR_PROT_STUFF;\n\t}\n\n\t \n\tif (reg_sr & AT91_IRQ_AERR) {\n\t\tnetdev_dbg(dev, \"AERR irq\\n\");\n\t\tdev->stats.tx_errors++;\n\t\tcf->can_id |= CAN_ERR_ACK;\n\t}\n\n\t \n\tif (reg_sr & AT91_IRQ_FERR) {\n\t\tnetdev_dbg(dev, \"FERR irq\\n\");\n\t\tdev->stats.rx_errors++;\n\t\tpriv->can.can_stats.bus_error++;\n\t\tcf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\n\t\tcf->data[2] |= CAN_ERR_PROT_FORM;\n\t}\n\n\t \n\tif (reg_sr & AT91_IRQ_BERR) {\n\t\tnetdev_dbg(dev, \"BERR irq\\n\");\n\t\tdev->stats.tx_errors++;\n\t\tpriv->can.can_stats.bus_error++;\n\t\tcf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\n\t\tcf->data[2] |= CAN_ERR_PROT_BIT;\n\t}\n}\n\nstatic int at91_poll_err(struct net_device *dev, int quota, u32 reg_sr)\n{\n\tstruct sk_buff *skb;\n\tstruct can_frame *cf;\n\n\tif (quota == 0)\n\t\treturn 0;\n\n\tskb = alloc_can_err_skb(dev, &cf);\n\tif (unlikely(!skb))\n\t\treturn 0;\n\n\tat91_poll_err_frame(dev, cf, reg_sr);\n\n\tnetif_receive_skb(skb);\n\n\treturn 1;\n}\n\nstatic int at91_poll(struct napi_struct *napi, int quota)\n{\n\tstruct net_device *dev = napi->dev;\n\tconst struct at91_priv *priv = netdev_priv(dev);\n\tu32 reg_sr = at91_read(priv, AT91_SR);\n\tint work_done = 0;\n\n\tif (reg_sr & get_irq_mb_rx(priv))\n\t\twork_done += at91_poll_rx(dev, quota - work_done);\n\n\t \n\treg_sr |= priv->reg_sr;\n\tif (reg_sr & AT91_IRQ_ERR_FRAME)\n\t\twork_done += at91_poll_err(dev, quota - work_done, reg_sr);\n\n\tif (work_done < quota) {\n\t\t \n\t\tu32 reg_ier = AT91_IRQ_ERR_FRAME;\n\n\t\treg_ier |= get_irq_mb_rx(priv) & ~AT91_MB_MASK(priv->rx_next);\n\n\t\tnapi_complete_done(napi, work_done);\n\t\tat91_write(priv, AT91_IER, reg_ier);\n\t}\n\n\treturn work_done;\n}\n\n \nstatic void at91_irq_tx(struct net_device *dev, u32 reg_sr)\n{\n\tstruct at91_priv *priv = netdev_priv(dev);\n\tu32 reg_msr;\n\tunsigned int mb;\n\n\t \n\n\tfor ( ; (priv->tx_next - priv->tx_echo) > 0; priv->tx_echo++) {\n\t\tmb = get_tx_echo_mb(priv);\n\n\t\t \n\t\tif (!(reg_sr & (1 << mb)))\n\t\t\tbreak;\n\n\t\t \n\t\tat91_write(priv, AT91_IDR, 1 << mb);\n\n\t\t \n\t\treg_msr = at91_read(priv, AT91_MSR(mb));\n\t\tif (likely(reg_msr & AT91_MSR_MRDY &&\n\t\t\t   ~reg_msr & AT91_MSR_MABT)) {\n\t\t\t \n\t\t\tdev->stats.tx_bytes +=\n\t\t\t\tcan_get_echo_skb(dev,\n\t\t\t\t\t\t mb - get_mb_tx_first(priv),\n\t\t\t\t\t\t NULL);\n\t\t\tdev->stats.tx_packets++;\n\t\t}\n\t}\n\n\t \n\tif ((priv->tx_next & get_next_mask(priv)) != 0 ||\n\t    (priv->tx_echo & get_next_mask(priv)) == 0)\n\t\tnetif_wake_queue(dev);\n}\n\nstatic void at91_irq_err_state(struct net_device *dev,\n\t\t\t       struct can_frame *cf, enum can_state new_state)\n{\n\tstruct at91_priv *priv = netdev_priv(dev);\n\tu32 reg_idr = 0, reg_ier = 0;\n\tstruct can_berr_counter bec;\n\n\tat91_get_berr_counter(dev, &bec);\n\n\tswitch (priv->can.state) {\n\tcase CAN_STATE_ERROR_ACTIVE:\n\t\t \n\t\tif (new_state >= CAN_STATE_ERROR_WARNING &&\n\t\t    new_state <= CAN_STATE_BUS_OFF) {\n\t\t\tnetdev_dbg(dev, \"Error Warning IRQ\\n\");\n\t\t\tpriv->can.can_stats.error_warning++;\n\n\t\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\t\tcf->data[1] = (bec.txerr > bec.rxerr) ?\n\t\t\t\tCAN_ERR_CRTL_TX_WARNING :\n\t\t\t\tCAN_ERR_CRTL_RX_WARNING;\n\t\t}\n\t\tfallthrough;\n\tcase CAN_STATE_ERROR_WARNING:\n\t\t \n\t\tif (new_state >= CAN_STATE_ERROR_PASSIVE &&\n\t\t    new_state <= CAN_STATE_BUS_OFF) {\n\t\t\tnetdev_dbg(dev, \"Error Passive IRQ\\n\");\n\t\t\tpriv->can.can_stats.error_passive++;\n\n\t\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\t\tcf->data[1] = (bec.txerr > bec.rxerr) ?\n\t\t\t\tCAN_ERR_CRTL_TX_PASSIVE :\n\t\t\t\tCAN_ERR_CRTL_RX_PASSIVE;\n\t\t}\n\t\tbreak;\n\tcase CAN_STATE_BUS_OFF:\n\t\t \n\t\tif (new_state <= CAN_STATE_ERROR_PASSIVE) {\n\t\t\tcf->can_id |= CAN_ERR_RESTARTED;\n\n\t\t\tnetdev_dbg(dev, \"restarted\\n\");\n\t\t\tpriv->can.can_stats.restarts++;\n\n\t\t\tnetif_carrier_on(dev);\n\t\t\tnetif_wake_queue(dev);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tswitch (new_state) {\n\tcase CAN_STATE_ERROR_ACTIVE:\n\t\t \n\t\tnetdev_dbg(dev, \"Error Active\\n\");\n\t\tcf->can_id |= CAN_ERR_PROT;\n\t\tcf->data[2] = CAN_ERR_PROT_ACTIVE;\n\t\tfallthrough;\n\tcase CAN_STATE_ERROR_WARNING:\n\t\treg_idr = AT91_IRQ_ERRA | AT91_IRQ_WARN | AT91_IRQ_BOFF;\n\t\treg_ier = AT91_IRQ_ERRP;\n\t\tbreak;\n\tcase CAN_STATE_ERROR_PASSIVE:\n\t\treg_idr = AT91_IRQ_ERRA | AT91_IRQ_WARN | AT91_IRQ_ERRP;\n\t\treg_ier = AT91_IRQ_BOFF;\n\t\tbreak;\n\tcase CAN_STATE_BUS_OFF:\n\t\treg_idr = AT91_IRQ_ERRA | AT91_IRQ_ERRP |\n\t\t\tAT91_IRQ_WARN | AT91_IRQ_BOFF;\n\t\treg_ier = 0;\n\n\t\tcf->can_id |= CAN_ERR_BUSOFF;\n\n\t\tnetdev_dbg(dev, \"bus-off\\n\");\n\t\tnetif_carrier_off(dev);\n\t\tpriv->can.can_stats.bus_off++;\n\n\t\t \n\t\tif (!priv->can.restart_ms) {\n\t\t\tat91_chip_stop(dev, CAN_STATE_BUS_OFF);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tat91_write(priv, AT91_IDR, reg_idr);\n\tat91_write(priv, AT91_IER, reg_ier);\n}\n\nstatic int at91_get_state_by_bec(const struct net_device *dev,\n\t\t\t\t enum can_state *state)\n{\n\tstruct can_berr_counter bec;\n\tint err;\n\n\terr = at91_get_berr_counter(dev, &bec);\n\tif (err)\n\t\treturn err;\n\n\tif (bec.txerr < 96 && bec.rxerr < 96)\n\t\t*state = CAN_STATE_ERROR_ACTIVE;\n\telse if (bec.txerr < 128 && bec.rxerr < 128)\n\t\t*state = CAN_STATE_ERROR_WARNING;\n\telse if (bec.txerr < 256 && bec.rxerr < 256)\n\t\t*state = CAN_STATE_ERROR_PASSIVE;\n\telse\n\t\t*state = CAN_STATE_BUS_OFF;\n\n\treturn 0;\n}\n\nstatic void at91_irq_err(struct net_device *dev)\n{\n\tstruct at91_priv *priv = netdev_priv(dev);\n\tstruct sk_buff *skb;\n\tstruct can_frame *cf;\n\tenum can_state new_state;\n\tu32 reg_sr;\n\tint err;\n\n\tif (at91_is_sam9263(priv)) {\n\t\treg_sr = at91_read(priv, AT91_SR);\n\n\t\t \n\t\tif (unlikely(reg_sr & AT91_IRQ_BOFF)) {\n\t\t\tnew_state = CAN_STATE_BUS_OFF;\n\t\t} else if (unlikely(reg_sr & AT91_IRQ_ERRP)) {\n\t\t\tnew_state = CAN_STATE_ERROR_PASSIVE;\n\t\t} else if (unlikely(reg_sr & AT91_IRQ_WARN)) {\n\t\t\tnew_state = CAN_STATE_ERROR_WARNING;\n\t\t} else if (likely(reg_sr & AT91_IRQ_ERRA)) {\n\t\t\tnew_state = CAN_STATE_ERROR_ACTIVE;\n\t\t} else {\n\t\t\tnetdev_err(dev, \"BUG! hardware in undefined state\\n\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\terr = at91_get_state_by_bec(dev, &new_state);\n\t\tif (err)\n\t\t\treturn;\n\t}\n\n\t \n\tif (likely(new_state == priv->can.state))\n\t\treturn;\n\n\tskb = alloc_can_err_skb(dev, &cf);\n\tif (unlikely(!skb))\n\t\treturn;\n\n\tat91_irq_err_state(dev, cf, new_state);\n\n\tnetif_rx(skb);\n\n\tpriv->can.state = new_state;\n}\n\n \nstatic irqreturn_t at91_irq(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct at91_priv *priv = netdev_priv(dev);\n\tirqreturn_t handled = IRQ_NONE;\n\tu32 reg_sr, reg_imr;\n\n\treg_sr = at91_read(priv, AT91_SR);\n\treg_imr = at91_read(priv, AT91_IMR);\n\n\t \n\treg_sr &= reg_imr;\n\tif (!reg_sr)\n\t\tgoto exit;\n\n\thandled = IRQ_HANDLED;\n\n\t \n\tif (reg_sr & (get_irq_mb_rx(priv) | AT91_IRQ_ERR_FRAME)) {\n\t\t \n\t\tpriv->reg_sr = reg_sr;\n\t\tat91_write(priv, AT91_IDR,\n\t\t\t   get_irq_mb_rx(priv) | AT91_IRQ_ERR_FRAME);\n\t\tnapi_schedule(&priv->napi);\n\t}\n\n\t \n\tif (reg_sr & get_irq_mb_tx(priv))\n\t\tat91_irq_tx(dev, reg_sr);\n\n\tat91_irq_err(dev);\n\n exit:\n\treturn handled;\n}\n\nstatic int at91_open(struct net_device *dev)\n{\n\tstruct at91_priv *priv = netdev_priv(dev);\n\tint err;\n\n\terr = clk_prepare_enable(priv->clk);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = open_candev(dev);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tif (request_irq(dev->irq, at91_irq, IRQF_SHARED,\n\t\t\tdev->name, dev)) {\n\t\terr = -EAGAIN;\n\t\tgoto out_close;\n\t}\n\n\t \n\tat91_chip_start(dev);\n\tnapi_enable(&priv->napi);\n\tnetif_start_queue(dev);\n\n\treturn 0;\n\n out_close:\n\tclose_candev(dev);\n out:\n\tclk_disable_unprepare(priv->clk);\n\n\treturn err;\n}\n\n \nstatic int at91_close(struct net_device *dev)\n{\n\tstruct at91_priv *priv = netdev_priv(dev);\n\n\tnetif_stop_queue(dev);\n\tnapi_disable(&priv->napi);\n\tat91_chip_stop(dev, CAN_STATE_STOPPED);\n\n\tfree_irq(dev->irq, dev);\n\tclk_disable_unprepare(priv->clk);\n\n\tclose_candev(dev);\n\n\treturn 0;\n}\n\nstatic int at91_set_mode(struct net_device *dev, enum can_mode mode)\n{\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\tat91_chip_start(dev);\n\t\tnetif_wake_queue(dev);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops at91_netdev_ops = {\n\t.ndo_open\t= at91_open,\n\t.ndo_stop\t= at91_close,\n\t.ndo_start_xmit\t= at91_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic const struct ethtool_ops at91_ethtool_ops = {\n\t.get_ts_info = ethtool_op_get_ts_info,\n};\n\nstatic ssize_t mb0_id_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct at91_priv *priv = netdev_priv(to_net_dev(dev));\n\n\tif (priv->mb0_id & CAN_EFF_FLAG)\n\t\treturn sysfs_emit(buf, \"0x%08x\\n\", priv->mb0_id);\n\telse\n\t\treturn sysfs_emit(buf, \"0x%03x\\n\", priv->mb0_id);\n}\n\nstatic ssize_t mb0_id_store(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct net_device *ndev = to_net_dev(dev);\n\tstruct at91_priv *priv = netdev_priv(ndev);\n\tunsigned long can_id;\n\tssize_t ret;\n\tint err;\n\n\trtnl_lock();\n\n\tif (ndev->flags & IFF_UP) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\terr = kstrtoul(buf, 0, &can_id);\n\tif (err) {\n\t\tret = err;\n\t\tgoto out;\n\t}\n\n\tif (can_id & CAN_EFF_FLAG)\n\t\tcan_id &= CAN_EFF_MASK | CAN_EFF_FLAG;\n\telse\n\t\tcan_id &= CAN_SFF_MASK;\n\n\tpriv->mb0_id = can_id;\n\tret = count;\n\n out:\n\trtnl_unlock();\n\treturn ret;\n}\n\nstatic DEVICE_ATTR_RW(mb0_id);\n\nstatic struct attribute *at91_sysfs_attrs[] = {\n\t&dev_attr_mb0_id.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group at91_sysfs_attr_group = {\n\t.attrs = at91_sysfs_attrs,\n};\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id at91_can_dt_ids[] = {\n\t{\n\t\t.compatible = \"atmel,at91sam9x5-can\",\n\t\t.data = &at91_at91sam9x5_data,\n\t}, {\n\t\t.compatible = \"atmel,at91sam9263-can\",\n\t\t.data = &at91_at91sam9263_data,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, at91_can_dt_ids);\n#endif\n\nstatic const struct at91_devtype_data *at91_can_get_driver_data(struct platform_device *pdev)\n{\n\tif (pdev->dev.of_node) {\n\t\tconst struct of_device_id *match;\n\n\t\tmatch = of_match_node(at91_can_dt_ids, pdev->dev.of_node);\n\t\tif (!match) {\n\t\t\tdev_err(&pdev->dev, \"no matching node found in dtb\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\treturn (const struct at91_devtype_data *)match->data;\n\t}\n\treturn (const struct at91_devtype_data *)\n\t\tplatform_get_device_id(pdev)->driver_data;\n}\n\nstatic int at91_can_probe(struct platform_device *pdev)\n{\n\tconst struct at91_devtype_data *devtype_data;\n\tstruct net_device *dev;\n\tstruct at91_priv *priv;\n\tstruct resource *res;\n\tstruct clk *clk;\n\tvoid __iomem *addr;\n\tint err, irq;\n\n\tdevtype_data = at91_can_get_driver_data(pdev);\n\tif (!devtype_data) {\n\t\tdev_err(&pdev->dev, \"no driver data\\n\");\n\t\terr = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tclk = clk_get(&pdev->dev, \"can_clk\");\n\tif (IS_ERR(clk)) {\n\t\tdev_err(&pdev->dev, \"no clock defined\\n\");\n\t\terr = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tirq = platform_get_irq(pdev, 0);\n\tif (!res || irq <= 0) {\n\t\terr = -ENODEV;\n\t\tgoto exit_put;\n\t}\n\n\tif (!request_mem_region(res->start,\n\t\t\t\tresource_size(res),\n\t\t\t\tpdev->name)) {\n\t\terr = -EBUSY;\n\t\tgoto exit_put;\n\t}\n\n\taddr = ioremap(res->start, resource_size(res));\n\tif (!addr) {\n\t\terr = -ENOMEM;\n\t\tgoto exit_release;\n\t}\n\n\tdev = alloc_candev(sizeof(struct at91_priv),\n\t\t\t   1 << devtype_data->tx_shift);\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto exit_iounmap;\n\t}\n\n\tdev->netdev_ops\t= &at91_netdev_ops;\n\tdev->ethtool_ops = &at91_ethtool_ops;\n\tdev->irq = irq;\n\tdev->flags |= IFF_ECHO;\n\n\tpriv = netdev_priv(dev);\n\tpriv->can.clock.freq = clk_get_rate(clk);\n\tpriv->can.bittiming_const = &at91_bittiming_const;\n\tpriv->can.do_set_mode = at91_set_mode;\n\tpriv->can.do_get_berr_counter = at91_get_berr_counter;\n\tpriv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES |\n\t\tCAN_CTRLMODE_LISTENONLY;\n\tpriv->reg_base = addr;\n\tpriv->devtype_data = *devtype_data;\n\tpriv->clk = clk;\n\tpriv->pdata = dev_get_platdata(&pdev->dev);\n\tpriv->mb0_id = 0x7ff;\n\n\tnetif_napi_add_weight(dev, &priv->napi, at91_poll, get_mb_rx_num(priv));\n\n\tif (at91_is_sam9263(priv))\n\t\tdev->sysfs_groups[0] = &at91_sysfs_attr_group;\n\n\tplatform_set_drvdata(pdev, dev);\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\terr = register_candev(dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"registering netdev failed\\n\");\n\t\tgoto exit_free;\n\t}\n\n\tdev_info(&pdev->dev, \"device registered (reg_base=%p, irq=%d)\\n\",\n\t\t priv->reg_base, dev->irq);\n\n\treturn 0;\n\n exit_free:\n\tfree_candev(dev);\n exit_iounmap:\n\tiounmap(addr);\n exit_release:\n\trelease_mem_region(res->start, resource_size(res));\n exit_put:\n\tclk_put(clk);\n exit:\n\treturn err;\n}\n\nstatic void at91_can_remove(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\tstruct at91_priv *priv = netdev_priv(dev);\n\tstruct resource *res;\n\n\tunregister_netdev(dev);\n\n\tiounmap(priv->reg_base);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\trelease_mem_region(res->start, resource_size(res));\n\n\tclk_put(priv->clk);\n\n\tfree_candev(dev);\n}\n\nstatic const struct platform_device_id at91_can_id_table[] = {\n\t{\n\t\t.name = \"at91sam9x5_can\",\n\t\t.driver_data = (kernel_ulong_t)&at91_at91sam9x5_data,\n\t}, {\n\t\t.name = \"at91_can\",\n\t\t.driver_data = (kernel_ulong_t)&at91_at91sam9263_data,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(platform, at91_can_id_table);\n\nstatic struct platform_driver at91_can_driver = {\n\t.probe = at91_can_probe,\n\t.remove_new = at91_can_remove,\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t\t.of_match_table = of_match_ptr(at91_can_dt_ids),\n\t},\n\t.id_table = at91_can_id_table,\n};\n\nmodule_platform_driver(at91_can_driver);\n\nMODULE_AUTHOR(\"Marc Kleine-Budde <mkl@pengutronix.de>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(KBUILD_MODNAME \" CAN netdevice driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}