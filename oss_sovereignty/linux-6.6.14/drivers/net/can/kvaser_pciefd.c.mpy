{
  "module_name": "kvaser_pciefd.c",
  "hash_id": "42d01b72f0a54841633108b8b4f92e95f70f288e8d26b2a09b0146c95c8c7d82",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/kvaser_pciefd.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/can/dev.h>\n#include <linux/device.h>\n#include <linux/ethtool.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/minmax.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/pci.h>\n#include <linux/timer.h>\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Kvaser AB <support@kvaser.com>\");\nMODULE_DESCRIPTION(\"CAN driver for Kvaser CAN/PCIe devices\");\n\n#define KVASER_PCIEFD_DRV_NAME \"kvaser_pciefd\"\n\n#define KVASER_PCIEFD_WAIT_TIMEOUT msecs_to_jiffies(1000)\n#define KVASER_PCIEFD_BEC_POLL_FREQ (jiffies + msecs_to_jiffies(200))\n#define KVASER_PCIEFD_MAX_ERR_REP 256U\n#define KVASER_PCIEFD_CAN_TX_MAX_COUNT 17U\n#define KVASER_PCIEFD_MAX_CAN_CHANNELS 4UL\n#define KVASER_PCIEFD_DMA_COUNT 2U\n\n#define KVASER_PCIEFD_DMA_SIZE (4U * 1024U)\n\n#define KVASER_PCIEFD_VENDOR 0x1a07\n \n#define KVASER_PCIEFD_4HS_DEVICE_ID 0x000d\n#define KVASER_PCIEFD_2HS_V2_DEVICE_ID 0x000e\n#define KVASER_PCIEFD_HS_V2_DEVICE_ID 0x000f\n#define KVASER_PCIEFD_MINIPCIE_HS_V2_DEVICE_ID 0x0010\n#define KVASER_PCIEFD_MINIPCIE_2HS_V2_DEVICE_ID 0x0011\n\n \n#define KVASER_PCIEFD_2CAN_V3_DEVICE_ID 0x0012\n#define KVASER_PCIEFD_1CAN_V3_DEVICE_ID 0x0013\n#define KVASER_PCIEFD_4CAN_V2_DEVICE_ID 0x0014\n#define KVASER_PCIEFD_MINIPCIE_2CAN_V3_DEVICE_ID 0x0015\n#define KVASER_PCIEFD_MINIPCIE_1CAN_V3_DEVICE_ID 0x0016\n\n \n#define KVASER_PCIEFD_ALTERA_DMA_64BIT BIT(0)\n\n \n#define KVASER_PCIEFD_SF2_DMA_LSB_MASK GENMASK(31, 12)\n\n \n#define KVASER_PCIEFD_KCAN_FIFO_REG 0x100\n#define KVASER_PCIEFD_KCAN_FIFO_LAST_REG 0x180\n#define KVASER_PCIEFD_KCAN_CTRL_REG 0x2c0\n#define KVASER_PCIEFD_KCAN_CMD_REG 0x400\n#define KVASER_PCIEFD_KCAN_IEN_REG 0x408\n#define KVASER_PCIEFD_KCAN_IRQ_REG 0x410\n#define KVASER_PCIEFD_KCAN_TX_NR_PACKETS_REG 0x414\n#define KVASER_PCIEFD_KCAN_STAT_REG 0x418\n#define KVASER_PCIEFD_KCAN_MODE_REG 0x41c\n#define KVASER_PCIEFD_KCAN_BTRN_REG 0x420\n#define KVASER_PCIEFD_KCAN_BUS_LOAD_REG 0x424\n#define KVASER_PCIEFD_KCAN_BTRD_REG 0x428\n#define KVASER_PCIEFD_KCAN_PWM_REG 0x430\n \n#define KVASER_PCIEFD_SYSID_VERSION_REG 0x8\n#define KVASER_PCIEFD_SYSID_CANFREQ_REG 0xc\n#define KVASER_PCIEFD_SYSID_BUSFREQ_REG 0x10\n#define KVASER_PCIEFD_SYSID_BUILD_REG 0x14\n \n#define KVASER_PCIEFD_SRB_FIFO_LAST_REG 0x1f4\n \n#define KVASER_PCIEFD_SRB_CMD_REG 0x0\n#define KVASER_PCIEFD_SRB_IEN_REG 0x04\n#define KVASER_PCIEFD_SRB_IRQ_REG 0x0c\n#define KVASER_PCIEFD_SRB_STAT_REG 0x10\n#define KVASER_PCIEFD_SRB_RX_NR_PACKETS_REG 0x14\n#define KVASER_PCIEFD_SRB_CTRL_REG 0x18\n\n \n#define KVASER_PCIEFD_SYSID_VERSION_NR_CHAN_MASK GENMASK(31, 24)\n#define KVASER_PCIEFD_SYSID_VERSION_MAJOR_MASK GENMASK(23, 16)\n#define KVASER_PCIEFD_SYSID_VERSION_MINOR_MASK GENMASK(7, 0)\n#define KVASER_PCIEFD_SYSID_BUILD_SEQ_MASK GENMASK(15, 1)\n\n \n#define KVASER_PCIEFD_SRB_CMD_RDB1 BIT(5)\n#define KVASER_PCIEFD_SRB_CMD_RDB0 BIT(4)\n#define KVASER_PCIEFD_SRB_CMD_FOR BIT(0)\n\n \n#define KVASER_PCIEFD_SRB_IRQ_DUF1 BIT(13)\n#define KVASER_PCIEFD_SRB_IRQ_DUF0 BIT(12)\n \n#define KVASER_PCIEFD_SRB_IRQ_DOF1 BIT(11)\n#define KVASER_PCIEFD_SRB_IRQ_DOF0 BIT(10)\n \n#define KVASER_PCIEFD_SRB_IRQ_DPD1 BIT(9)\n#define KVASER_PCIEFD_SRB_IRQ_DPD0 BIT(8)\n\n \n#define KVASER_PCIEFD_SRB_STAT_DMA BIT(24)\n \n#define KVASER_PCIEFD_SRB_STAT_DI BIT(15)\n\n \n#define KVASER_PCIEFD_SRB_RX_NR_PACKETS_MASK GENMASK(7, 0)\n\n \n#define KVASER_PCIEFD_SRB_CTRL_DMA_ENABLE BIT(0)\n\n \n#define KVASER_PCIEFD_KCAN_CTRL_TYPE_MASK GENMASK(31, 29)\n#define KVASER_PCIEFD_KCAN_CTRL_TYPE_EFLUSH 0x4\n#define KVASER_PCIEFD_KCAN_CTRL_TYPE_EFRAME 0x5\n\n \n#define KVASER_PCIEFD_KCAN_CMD_SEQ_MASK GENMASK(23, 16)\n \n#define KVASER_PCIEFD_KCAN_CMD_MASK GENMASK(5, 0)\n \n#define KVASER_PCIEFD_KCAN_CMD_AT BIT(1)\n \n#define KVASER_PCIEFD_KCAN_CMD_SRQ BIT(0)\n\n \n#define KVASER_PCIEFD_KCAN_IRQ_TAL BIT(17)\n \n#define KVASER_PCIEFD_KCAN_IRQ_TE BIT(16)\n \n#define KVASER_PCIEFD_KCAN_IRQ_TOF BIT(15)\n \n#define KVASER_PCIEFD_KCAN_IRQ_TFD BIT(14)\n \n#define KVASER_PCIEFD_KCAN_IRQ_ABD BIT(13)\n \n#define KVASER_PCIEFD_KCAN_IRQ_ROF BIT(5)\n \n#define KVASER_PCIEFD_KCAN_IRQ_FDIC BIT(3)\n \n#define KVASER_PCIEFD_KCAN_IRQ_BPP BIT(2)\n \n#define KVASER_PCIEFD_KCAN_IRQ_TAE BIT(1)\n \n#define KVASER_PCIEFD_KCAN_IRQ_TAR BIT(0)\n\n \n#define KVASER_PCIEFD_KCAN_TX_NR_PACKETS_MAX_MASK GENMASK(23, 16)\n \n#define KVASER_PCIEFD_KCAN_TX_NR_PACKETS_CURRENT_MASK GENMASK(7, 0)\n\n \n#define KVASER_PCIEFD_KCAN_STAT_SEQNO_MASK GENMASK(31, 24)\n \n#define KVASER_PCIEFD_KCAN_STAT_FD BIT(19)\n \n#define KVASER_PCIEFD_KCAN_STAT_CAP BIT(16)\n \n#define KVASER_PCIEFD_KCAN_STAT_IRM BIT(15)\n \n#define KVASER_PCIEFD_KCAN_STAT_RMR BIT(14)\n \n#define KVASER_PCIEFD_KCAN_STAT_BOFF BIT(11)\n \n#define KVASER_PCIEFD_KCAN_STAT_IDLE BIT(10)\n \n#define KVASER_PCIEFD_KCAN_STAT_AR BIT(7)\n \n#define KVASER_PCIEFD_KCAN_STAT_BUS_OFF_MASK \\\n\t(KVASER_PCIEFD_KCAN_STAT_AR | KVASER_PCIEFD_KCAN_STAT_BOFF | \\\n\t KVASER_PCIEFD_KCAN_STAT_RMR | KVASER_PCIEFD_KCAN_STAT_IRM)\n\n \n#define KVASER_PCIEFD_KCAN_MODE_CCM BIT(31)\n \n#define KVASER_PCIEFD_KCAN_MODE_EEN BIT(23)\n \n#define KVASER_PCIEFD_KCAN_MODE_APT BIT(20)\n \n#define KVASER_PCIEFD_KCAN_MODE_NIFDEN BIT(15)\n \n#define KVASER_PCIEFD_KCAN_MODE_EPEN BIT(12)\n \n#define KVASER_PCIEFD_KCAN_MODE_LOM BIT(9)\n \n#define KVASER_PCIEFD_KCAN_MODE_RM BIT(8)\n\n \n#define KVASER_PCIEFD_KCAN_BTRN_TSEG2_MASK GENMASK(30, 26)\n#define KVASER_PCIEFD_KCAN_BTRN_TSEG1_MASK GENMASK(25, 17)\n#define KVASER_PCIEFD_KCAN_BTRN_SJW_MASK GENMASK(16, 13)\n#define KVASER_PCIEFD_KCAN_BTRN_BRP_MASK GENMASK(12, 0)\n\n \n#define KVASER_PCIEFD_KCAN_PWM_TOP_MASK GENMASK(23, 16)\n#define KVASER_PCIEFD_KCAN_PWM_TRIGGER_MASK GENMASK(7, 0)\n\n \n#define KVASER_PCIEFD_PACK_TYPE_DATA 0x0\n#define KVASER_PCIEFD_PACK_TYPE_ACK 0x1\n#define KVASER_PCIEFD_PACK_TYPE_TXRQ 0x2\n#define KVASER_PCIEFD_PACK_TYPE_ERROR 0x3\n#define KVASER_PCIEFD_PACK_TYPE_EFLUSH_ACK 0x4\n#define KVASER_PCIEFD_PACK_TYPE_EFRAME_ACK 0x5\n#define KVASER_PCIEFD_PACK_TYPE_ACK_DATA 0x6\n#define KVASER_PCIEFD_PACK_TYPE_STATUS 0x8\n#define KVASER_PCIEFD_PACK_TYPE_BUS_LOAD 0x9\n\n \n#define KVASER_PCIEFD_PACKET_TYPE_MASK GENMASK(31, 28)\n#define KVASER_PCIEFD_PACKET_CHID_MASK GENMASK(27, 25)\n#define KVASER_PCIEFD_PACKET_SEQ_MASK GENMASK(7, 0)\n\n \n#define KVASER_PCIEFD_RPACKET_IDE BIT(30)\n#define KVASER_PCIEFD_RPACKET_RTR BIT(29)\n#define KVASER_PCIEFD_RPACKET_ID_MASK GENMASK(28, 0)\n \n#define KVASER_PCIEFD_TPACKET_AREQ BIT(31)\n#define KVASER_PCIEFD_TPACKET_SMS BIT(16)\n \n#define KVASER_PCIEFD_RPACKET_FDF BIT(15)\n#define KVASER_PCIEFD_RPACKET_BRS BIT(14)\n#define KVASER_PCIEFD_RPACKET_ESI BIT(13)\n#define KVASER_PCIEFD_RPACKET_DLC_MASK GENMASK(11, 8)\n\n \n#define KVASER_PCIEFD_APACKET_NACK BIT(11)\n#define KVASER_PCIEFD_APACKET_ABL BIT(10)\n#define KVASER_PCIEFD_APACKET_CT BIT(9)\n#define KVASER_PCIEFD_APACKET_FLU BIT(8)\n\n \n#define KVASER_PCIEFD_SPACK_RMCD BIT(22)\n#define KVASER_PCIEFD_SPACK_IRM BIT(21)\n#define KVASER_PCIEFD_SPACK_IDET BIT(20)\n#define KVASER_PCIEFD_SPACK_BOFF BIT(16)\n#define KVASER_PCIEFD_SPACK_RXERR_MASK GENMASK(15, 8)\n#define KVASER_PCIEFD_SPACK_TXERR_MASK GENMASK(7, 0)\n \n#define KVASER_PCIEFD_SPACK_EPLR BIT(24)\n#define KVASER_PCIEFD_SPACK_EWLR BIT(23)\n#define KVASER_PCIEFD_SPACK_AUTO BIT(21)\n\n \n#define KVASER_PCIEFD_EPACK_DIR_TX BIT(0)\n\n \n#define KVASER_PCIEFD_GET_BLOCK_ADDR(pcie, block) \\\n\t((pcie)->reg_base + (pcie)->driver_data->address_offset->block)\n#define KVASER_PCIEFD_PCI_IEN_ADDR(pcie) \\\n\t(KVASER_PCIEFD_GET_BLOCK_ADDR((pcie), pci_ien))\n#define KVASER_PCIEFD_PCI_IRQ_ADDR(pcie) \\\n\t(KVASER_PCIEFD_GET_BLOCK_ADDR((pcie), pci_irq))\n#define KVASER_PCIEFD_SERDES_ADDR(pcie) \\\n\t(KVASER_PCIEFD_GET_BLOCK_ADDR((pcie), serdes))\n#define KVASER_PCIEFD_SYSID_ADDR(pcie) \\\n\t(KVASER_PCIEFD_GET_BLOCK_ADDR((pcie), sysid))\n#define KVASER_PCIEFD_LOOPBACK_ADDR(pcie) \\\n\t(KVASER_PCIEFD_GET_BLOCK_ADDR((pcie), loopback))\n#define KVASER_PCIEFD_SRB_FIFO_ADDR(pcie) \\\n\t(KVASER_PCIEFD_GET_BLOCK_ADDR((pcie), kcan_srb_fifo))\n#define KVASER_PCIEFD_SRB_ADDR(pcie) \\\n\t(KVASER_PCIEFD_GET_BLOCK_ADDR((pcie), kcan_srb))\n#define KVASER_PCIEFD_KCAN_CH0_ADDR(pcie) \\\n\t(KVASER_PCIEFD_GET_BLOCK_ADDR((pcie), kcan_ch0))\n#define KVASER_PCIEFD_KCAN_CH1_ADDR(pcie) \\\n\t(KVASER_PCIEFD_GET_BLOCK_ADDR((pcie), kcan_ch1))\n#define KVASER_PCIEFD_KCAN_CHANNEL_SPAN(pcie) \\\n\t(KVASER_PCIEFD_KCAN_CH1_ADDR((pcie)) - KVASER_PCIEFD_KCAN_CH0_ADDR((pcie)))\n#define KVASER_PCIEFD_KCAN_CHX_ADDR(pcie, i) \\\n\t(KVASER_PCIEFD_KCAN_CH0_ADDR((pcie)) + (i) * KVASER_PCIEFD_KCAN_CHANNEL_SPAN((pcie)))\n\nstruct kvaser_pciefd;\nstatic void kvaser_pciefd_write_dma_map_altera(struct kvaser_pciefd *pcie,\n\t\t\t\t\t       dma_addr_t addr, int index);\nstatic void kvaser_pciefd_write_dma_map_sf2(struct kvaser_pciefd *pcie,\n\t\t\t\t\t    dma_addr_t addr, int index);\n\nstruct kvaser_pciefd_address_offset {\n\tu32 serdes;\n\tu32 pci_ien;\n\tu32 pci_irq;\n\tu32 sysid;\n\tu32 loopback;\n\tu32 kcan_srb_fifo;\n\tu32 kcan_srb;\n\tu32 kcan_ch0;\n\tu32 kcan_ch1;\n};\n\nstruct kvaser_pciefd_dev_ops {\n\tvoid (*kvaser_pciefd_write_dma_map)(struct kvaser_pciefd *pcie,\n\t\t\t\t\t    dma_addr_t addr, int index);\n};\n\nstruct kvaser_pciefd_irq_mask {\n\tu32 kcan_rx0;\n\tu32 kcan_tx[KVASER_PCIEFD_MAX_CAN_CHANNELS];\n\tu32 all;\n};\n\nstruct kvaser_pciefd_driver_data {\n\tconst struct kvaser_pciefd_address_offset *address_offset;\n\tconst struct kvaser_pciefd_irq_mask *irq_mask;\n\tconst struct kvaser_pciefd_dev_ops *ops;\n};\n\nstatic const struct kvaser_pciefd_address_offset kvaser_pciefd_altera_address_offset = {\n\t.serdes = 0x1000,\n\t.pci_ien = 0x50,\n\t.pci_irq = 0x40,\n\t.sysid = 0x1f020,\n\t.loopback = 0x1f000,\n\t.kcan_srb_fifo = 0x1f200,\n\t.kcan_srb = 0x1f400,\n\t.kcan_ch0 = 0x10000,\n\t.kcan_ch1 = 0x11000,\n};\n\nstatic const struct kvaser_pciefd_address_offset kvaser_pciefd_sf2_address_offset = {\n\t.serdes = 0x280c8,\n\t.pci_ien = 0x102004,\n\t.pci_irq = 0x102008,\n\t.sysid = 0x100000,\n\t.loopback = 0x103000,\n\t.kcan_srb_fifo = 0x120000,\n\t.kcan_srb = 0x121000,\n\t.kcan_ch0 = 0x140000,\n\t.kcan_ch1 = 0x142000,\n};\n\nstatic const struct kvaser_pciefd_irq_mask kvaser_pciefd_altera_irq_mask = {\n\t.kcan_rx0 = BIT(4),\n\t.kcan_tx = { BIT(0), BIT(1), BIT(2), BIT(3) },\n\t.all = GENMASK(4, 0),\n};\n\nstatic const struct kvaser_pciefd_irq_mask kvaser_pciefd_sf2_irq_mask = {\n\t.kcan_rx0 = BIT(4),\n\t.kcan_tx = { BIT(16), BIT(17), BIT(18), BIT(19) },\n\t.all = GENMASK(19, 16) | BIT(4),\n};\n\nstatic const struct kvaser_pciefd_dev_ops kvaser_pciefd_altera_dev_ops = {\n\t.kvaser_pciefd_write_dma_map = kvaser_pciefd_write_dma_map_altera,\n};\n\nstatic const struct kvaser_pciefd_dev_ops kvaser_pciefd_sf2_dev_ops = {\n\t.kvaser_pciefd_write_dma_map = kvaser_pciefd_write_dma_map_sf2,\n};\n\nstatic const struct kvaser_pciefd_driver_data kvaser_pciefd_altera_driver_data = {\n\t.address_offset = &kvaser_pciefd_altera_address_offset,\n\t.irq_mask = &kvaser_pciefd_altera_irq_mask,\n\t.ops = &kvaser_pciefd_altera_dev_ops,\n};\n\nstatic const struct kvaser_pciefd_driver_data kvaser_pciefd_sf2_driver_data = {\n\t.address_offset = &kvaser_pciefd_sf2_address_offset,\n\t.irq_mask = &kvaser_pciefd_sf2_irq_mask,\n\t.ops = &kvaser_pciefd_sf2_dev_ops,\n};\n\nstruct kvaser_pciefd_can {\n\tstruct can_priv can;\n\tstruct kvaser_pciefd *kv_pcie;\n\tvoid __iomem *reg_base;\n\tstruct can_berr_counter bec;\n\tu8 cmd_seq;\n\tint err_rep_cnt;\n\tint echo_idx;\n\tspinlock_t lock;  \n\tspinlock_t echo_lock;  \n\tstruct timer_list bec_poll_timer;\n\tstruct completion start_comp, flush_comp;\n};\n\nstruct kvaser_pciefd {\n\tstruct pci_dev *pci;\n\tvoid __iomem *reg_base;\n\tstruct kvaser_pciefd_can *can[KVASER_PCIEFD_MAX_CAN_CHANNELS];\n\tconst struct kvaser_pciefd_driver_data *driver_data;\n\tvoid *dma_data[KVASER_PCIEFD_DMA_COUNT];\n\tu8 nr_channels;\n\tu32 bus_freq;\n\tu32 freq;\n\tu32 freq_to_ticks_div;\n};\n\nstruct kvaser_pciefd_rx_packet {\n\tu32 header[2];\n\tu64 timestamp;\n};\n\nstruct kvaser_pciefd_tx_packet {\n\tu32 header[2];\n\tu8 data[64];\n};\n\nstatic const struct can_bittiming_const kvaser_pciefd_bittiming_const = {\n\t.name = KVASER_PCIEFD_DRV_NAME,\n\t.tseg1_min = 1,\n\t.tseg1_max = 512,\n\t.tseg2_min = 1,\n\t.tseg2_max = 32,\n\t.sjw_max = 16,\n\t.brp_min = 1,\n\t.brp_max = 8192,\n\t.brp_inc = 1,\n};\n\nstatic struct pci_device_id kvaser_pciefd_id_table[] = {\n\t{\n\t\tPCI_DEVICE(KVASER_PCIEFD_VENDOR, KVASER_PCIEFD_4HS_DEVICE_ID),\n\t\t.driver_data = (kernel_ulong_t)&kvaser_pciefd_altera_driver_data,\n\t},\n\t{\n\t\tPCI_DEVICE(KVASER_PCIEFD_VENDOR, KVASER_PCIEFD_2HS_V2_DEVICE_ID),\n\t\t.driver_data = (kernel_ulong_t)&kvaser_pciefd_altera_driver_data,\n\t},\n\t{\n\t\tPCI_DEVICE(KVASER_PCIEFD_VENDOR, KVASER_PCIEFD_HS_V2_DEVICE_ID),\n\t\t.driver_data = (kernel_ulong_t)&kvaser_pciefd_altera_driver_data,\n\t},\n\t{\n\t\tPCI_DEVICE(KVASER_PCIEFD_VENDOR, KVASER_PCIEFD_MINIPCIE_HS_V2_DEVICE_ID),\n\t\t.driver_data = (kernel_ulong_t)&kvaser_pciefd_altera_driver_data,\n\t},\n\t{\n\t\tPCI_DEVICE(KVASER_PCIEFD_VENDOR, KVASER_PCIEFD_MINIPCIE_2HS_V2_DEVICE_ID),\n\t\t.driver_data = (kernel_ulong_t)&kvaser_pciefd_altera_driver_data,\n\t},\n\t{\n\t\tPCI_DEVICE(KVASER_PCIEFD_VENDOR, KVASER_PCIEFD_2CAN_V3_DEVICE_ID),\n\t\t.driver_data = (kernel_ulong_t)&kvaser_pciefd_sf2_driver_data,\n\t},\n\t{\n\t\tPCI_DEVICE(KVASER_PCIEFD_VENDOR, KVASER_PCIEFD_1CAN_V3_DEVICE_ID),\n\t\t.driver_data = (kernel_ulong_t)&kvaser_pciefd_sf2_driver_data,\n\t},\n\t{\n\t\tPCI_DEVICE(KVASER_PCIEFD_VENDOR, KVASER_PCIEFD_4CAN_V2_DEVICE_ID),\n\t\t.driver_data = (kernel_ulong_t)&kvaser_pciefd_sf2_driver_data,\n\t},\n\t{\n\t\tPCI_DEVICE(KVASER_PCIEFD_VENDOR, KVASER_PCIEFD_MINIPCIE_2CAN_V3_DEVICE_ID),\n\t\t.driver_data = (kernel_ulong_t)&kvaser_pciefd_sf2_driver_data,\n\t},\n\t{\n\t\tPCI_DEVICE(KVASER_PCIEFD_VENDOR, KVASER_PCIEFD_MINIPCIE_1CAN_V3_DEVICE_ID),\n\t\t.driver_data = (kernel_ulong_t)&kvaser_pciefd_sf2_driver_data,\n\t},\n\t{\n\t\t0,\n\t},\n};\nMODULE_DEVICE_TABLE(pci, kvaser_pciefd_id_table);\n\nstatic inline void kvaser_pciefd_send_kcan_cmd(struct kvaser_pciefd_can *can, u32 cmd)\n{\n\tiowrite32(FIELD_PREP(KVASER_PCIEFD_KCAN_CMD_MASK, cmd) |\n\t\t  FIELD_PREP(KVASER_PCIEFD_KCAN_CMD_SEQ_MASK, ++can->cmd_seq),\n\t\t  can->reg_base + KVASER_PCIEFD_KCAN_CMD_REG);\n}\n\nstatic inline void kvaser_pciefd_request_status(struct kvaser_pciefd_can *can)\n{\n\tkvaser_pciefd_send_kcan_cmd(can, KVASER_PCIEFD_KCAN_CMD_SRQ);\n}\n\nstatic inline void kvaser_pciefd_abort_flush_reset(struct kvaser_pciefd_can *can)\n{\n\tkvaser_pciefd_send_kcan_cmd(can, KVASER_PCIEFD_KCAN_CMD_AT);\n}\n\nstatic void kvaser_pciefd_enable_err_gen(struct kvaser_pciefd_can *can)\n{\n\tu32 mode;\n\tunsigned long irq;\n\n\tspin_lock_irqsave(&can->lock, irq);\n\tmode = ioread32(can->reg_base + KVASER_PCIEFD_KCAN_MODE_REG);\n\tif (!(mode & KVASER_PCIEFD_KCAN_MODE_EPEN)) {\n\t\tmode |= KVASER_PCIEFD_KCAN_MODE_EPEN;\n\t\tiowrite32(mode, can->reg_base + KVASER_PCIEFD_KCAN_MODE_REG);\n\t}\n\tspin_unlock_irqrestore(&can->lock, irq);\n}\n\nstatic void kvaser_pciefd_disable_err_gen(struct kvaser_pciefd_can *can)\n{\n\tu32 mode;\n\tunsigned long irq;\n\n\tspin_lock_irqsave(&can->lock, irq);\n\tmode = ioread32(can->reg_base + KVASER_PCIEFD_KCAN_MODE_REG);\n\tmode &= ~KVASER_PCIEFD_KCAN_MODE_EPEN;\n\tiowrite32(mode, can->reg_base + KVASER_PCIEFD_KCAN_MODE_REG);\n\tspin_unlock_irqrestore(&can->lock, irq);\n}\n\nstatic void kvaser_pciefd_set_tx_irq(struct kvaser_pciefd_can *can)\n{\n\tu32 msk;\n\n\tmsk = KVASER_PCIEFD_KCAN_IRQ_TE | KVASER_PCIEFD_KCAN_IRQ_ROF |\n\t      KVASER_PCIEFD_KCAN_IRQ_TOF | KVASER_PCIEFD_KCAN_IRQ_ABD |\n\t      KVASER_PCIEFD_KCAN_IRQ_TAE | KVASER_PCIEFD_KCAN_IRQ_TAL |\n\t      KVASER_PCIEFD_KCAN_IRQ_FDIC | KVASER_PCIEFD_KCAN_IRQ_BPP |\n\t      KVASER_PCIEFD_KCAN_IRQ_TAR;\n\n\tiowrite32(msk, can->reg_base + KVASER_PCIEFD_KCAN_IEN_REG);\n}\n\nstatic inline void kvaser_pciefd_set_skb_timestamp(const struct kvaser_pciefd *pcie,\n\t\t\t\t\t\t   struct sk_buff *skb, u64 timestamp)\n{\n\tskb_hwtstamps(skb)->hwtstamp =\n\t\tns_to_ktime(div_u64(timestamp * 1000, pcie->freq_to_ticks_div));\n}\n\nstatic void kvaser_pciefd_setup_controller(struct kvaser_pciefd_can *can)\n{\n\tu32 mode;\n\tunsigned long irq;\n\n\tspin_lock_irqsave(&can->lock, irq);\n\tmode = ioread32(can->reg_base + KVASER_PCIEFD_KCAN_MODE_REG);\n\tif (can->can.ctrlmode & CAN_CTRLMODE_FD) {\n\t\tmode &= ~KVASER_PCIEFD_KCAN_MODE_CCM;\n\t\tif (can->can.ctrlmode & CAN_CTRLMODE_FD_NON_ISO)\n\t\t\tmode |= KVASER_PCIEFD_KCAN_MODE_NIFDEN;\n\t\telse\n\t\t\tmode &= ~KVASER_PCIEFD_KCAN_MODE_NIFDEN;\n\t} else {\n\t\tmode |= KVASER_PCIEFD_KCAN_MODE_CCM;\n\t\tmode &= ~KVASER_PCIEFD_KCAN_MODE_NIFDEN;\n\t}\n\n\tif (can->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tmode |= KVASER_PCIEFD_KCAN_MODE_LOM;\n\telse\n\t\tmode &= ~KVASER_PCIEFD_KCAN_MODE_LOM;\n\tmode |= KVASER_PCIEFD_KCAN_MODE_EEN;\n\tmode |= KVASER_PCIEFD_KCAN_MODE_EPEN;\n\t \n\tmode &= ~KVASER_PCIEFD_KCAN_MODE_APT;\n\tmode &= ~KVASER_PCIEFD_KCAN_MODE_RM;\n\tiowrite32(mode, can->reg_base + KVASER_PCIEFD_KCAN_MODE_REG);\n\n\tspin_unlock_irqrestore(&can->lock, irq);\n}\n\nstatic void kvaser_pciefd_start_controller_flush(struct kvaser_pciefd_can *can)\n{\n\tu32 status;\n\tunsigned long irq;\n\n\tspin_lock_irqsave(&can->lock, irq);\n\tiowrite32(GENMASK(31, 0), can->reg_base + KVASER_PCIEFD_KCAN_IRQ_REG);\n\tiowrite32(KVASER_PCIEFD_KCAN_IRQ_ABD,\n\t\t  can->reg_base + KVASER_PCIEFD_KCAN_IEN_REG);\n\tstatus = ioread32(can->reg_base + KVASER_PCIEFD_KCAN_STAT_REG);\n\tif (status & KVASER_PCIEFD_KCAN_STAT_IDLE) {\n\t\t \n\t\tkvaser_pciefd_abort_flush_reset(can);\n\t} else if (!(status & KVASER_PCIEFD_KCAN_STAT_RMR)) {\n\t\tu32 mode;\n\n\t\t \n\t\tmode = ioread32(can->reg_base + KVASER_PCIEFD_KCAN_MODE_REG);\n\t\tmode |= KVASER_PCIEFD_KCAN_MODE_RM;\n\t\tiowrite32(mode, can->reg_base + KVASER_PCIEFD_KCAN_MODE_REG);\n\t}\n\tspin_unlock_irqrestore(&can->lock, irq);\n}\n\nstatic int kvaser_pciefd_bus_on(struct kvaser_pciefd_can *can)\n{\n\tu32 mode;\n\tunsigned long irq;\n\n\tdel_timer(&can->bec_poll_timer);\n\tif (!completion_done(&can->flush_comp))\n\t\tkvaser_pciefd_start_controller_flush(can);\n\n\tif (!wait_for_completion_timeout(&can->flush_comp,\n\t\t\t\t\t KVASER_PCIEFD_WAIT_TIMEOUT)) {\n\t\tnetdev_err(can->can.dev, \"Timeout during bus on flush\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tspin_lock_irqsave(&can->lock, irq);\n\tiowrite32(0, can->reg_base + KVASER_PCIEFD_KCAN_IEN_REG);\n\tiowrite32(GENMASK(31, 0), can->reg_base + KVASER_PCIEFD_KCAN_IRQ_REG);\n\tiowrite32(KVASER_PCIEFD_KCAN_IRQ_ABD,\n\t\t  can->reg_base + KVASER_PCIEFD_KCAN_IEN_REG);\n\tmode = ioread32(can->reg_base + KVASER_PCIEFD_KCAN_MODE_REG);\n\tmode &= ~KVASER_PCIEFD_KCAN_MODE_RM;\n\tiowrite32(mode, can->reg_base + KVASER_PCIEFD_KCAN_MODE_REG);\n\tspin_unlock_irqrestore(&can->lock, irq);\n\n\tif (!wait_for_completion_timeout(&can->start_comp,\n\t\t\t\t\t KVASER_PCIEFD_WAIT_TIMEOUT)) {\n\t\tnetdev_err(can->can.dev, \"Timeout during bus on reset\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\t \n\tiowrite32(0, can->reg_base + KVASER_PCIEFD_KCAN_IEN_REG);\n\tiowrite32(GENMASK(31, 0), can->reg_base + KVASER_PCIEFD_KCAN_IRQ_REG);\n\n\tkvaser_pciefd_set_tx_irq(can);\n\tkvaser_pciefd_setup_controller(can);\n\tcan->can.state = CAN_STATE_ERROR_ACTIVE;\n\tnetif_wake_queue(can->can.dev);\n\tcan->bec.txerr = 0;\n\tcan->bec.rxerr = 0;\n\tcan->err_rep_cnt = 0;\n\n\treturn 0;\n}\n\nstatic void kvaser_pciefd_pwm_stop(struct kvaser_pciefd_can *can)\n{\n\tu8 top;\n\tu32 pwm_ctrl;\n\tunsigned long irq;\n\n\tspin_lock_irqsave(&can->lock, irq);\n\tpwm_ctrl = ioread32(can->reg_base + KVASER_PCIEFD_KCAN_PWM_REG);\n\ttop = FIELD_GET(KVASER_PCIEFD_KCAN_PWM_TOP_MASK, pwm_ctrl);\n\t \n\tpwm_ctrl |= FIELD_PREP(KVASER_PCIEFD_KCAN_PWM_TRIGGER_MASK, top);\n\tiowrite32(pwm_ctrl, can->reg_base + KVASER_PCIEFD_KCAN_PWM_REG);\n\tspin_unlock_irqrestore(&can->lock, irq);\n}\n\nstatic void kvaser_pciefd_pwm_start(struct kvaser_pciefd_can *can)\n{\n\tint top, trigger;\n\tu32 pwm_ctrl;\n\tunsigned long irq;\n\n\tkvaser_pciefd_pwm_stop(can);\n\tspin_lock_irqsave(&can->lock, irq);\n\t \n\ttop = can->kv_pcie->bus_freq / (2 * 500000) - 1;\n\n\tpwm_ctrl = FIELD_PREP(KVASER_PCIEFD_KCAN_PWM_TRIGGER_MASK, top);\n\tpwm_ctrl |= FIELD_PREP(KVASER_PCIEFD_KCAN_PWM_TOP_MASK, top);\n\tiowrite32(pwm_ctrl, can->reg_base + KVASER_PCIEFD_KCAN_PWM_REG);\n\n\t \n\ttrigger = (100 * top - 95 * (top + 1) + 50) / 100;\n\tpwm_ctrl = FIELD_PREP(KVASER_PCIEFD_KCAN_PWM_TRIGGER_MASK, trigger);\n\tpwm_ctrl |= FIELD_PREP(KVASER_PCIEFD_KCAN_PWM_TOP_MASK, top);\n\tiowrite32(pwm_ctrl, can->reg_base + KVASER_PCIEFD_KCAN_PWM_REG);\n\tspin_unlock_irqrestore(&can->lock, irq);\n}\n\nstatic int kvaser_pciefd_open(struct net_device *netdev)\n{\n\tint err;\n\tstruct kvaser_pciefd_can *can = netdev_priv(netdev);\n\n\terr = open_candev(netdev);\n\tif (err)\n\t\treturn err;\n\n\terr = kvaser_pciefd_bus_on(can);\n\tif (err) {\n\t\tclose_candev(netdev);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int kvaser_pciefd_stop(struct net_device *netdev)\n{\n\tstruct kvaser_pciefd_can *can = netdev_priv(netdev);\n\tint ret = 0;\n\n\t \n\tif (!completion_done(&can->flush_comp))\n\t\tkvaser_pciefd_start_controller_flush(can);\n\n\tif (!wait_for_completion_timeout(&can->flush_comp,\n\t\t\t\t\t KVASER_PCIEFD_WAIT_TIMEOUT)) {\n\t\tnetdev_err(can->can.dev, \"Timeout during stop\\n\");\n\t\tret = -ETIMEDOUT;\n\t} else {\n\t\tiowrite32(0, can->reg_base + KVASER_PCIEFD_KCAN_IEN_REG);\n\t\tdel_timer(&can->bec_poll_timer);\n\t}\n\tcan->can.state = CAN_STATE_STOPPED;\n\tclose_candev(netdev);\n\n\treturn ret;\n}\n\nstatic int kvaser_pciefd_prepare_tx_packet(struct kvaser_pciefd_tx_packet *p,\n\t\t\t\t\t   struct kvaser_pciefd_can *can,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct canfd_frame *cf = (struct canfd_frame *)skb->data;\n\tint packet_size;\n\tint seq = can->echo_idx;\n\n\tmemset(p, 0, sizeof(*p));\n\tif (can->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)\n\t\tp->header[1] |= KVASER_PCIEFD_TPACKET_SMS;\n\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tp->header[0] |= KVASER_PCIEFD_RPACKET_RTR;\n\n\tif (cf->can_id & CAN_EFF_FLAG)\n\t\tp->header[0] |= KVASER_PCIEFD_RPACKET_IDE;\n\n\tp->header[0] |= FIELD_PREP(KVASER_PCIEFD_RPACKET_ID_MASK, cf->can_id);\n\tp->header[1] |= KVASER_PCIEFD_TPACKET_AREQ;\n\n\tif (can_is_canfd_skb(skb)) {\n\t\tp->header[1] |= FIELD_PREP(KVASER_PCIEFD_RPACKET_DLC_MASK,\n\t\t\t\t\t   can_fd_len2dlc(cf->len));\n\t\tp->header[1] |= KVASER_PCIEFD_RPACKET_FDF;\n\t\tif (cf->flags & CANFD_BRS)\n\t\t\tp->header[1] |= KVASER_PCIEFD_RPACKET_BRS;\n\t\tif (cf->flags & CANFD_ESI)\n\t\t\tp->header[1] |= KVASER_PCIEFD_RPACKET_ESI;\n\t} else {\n\t\tp->header[1] |=\n\t\t\tFIELD_PREP(KVASER_PCIEFD_RPACKET_DLC_MASK,\n\t\t\t\t   can_get_cc_dlc((struct can_frame *)cf, can->can.ctrlmode));\n\t}\n\n\tp->header[1] |= FIELD_PREP(KVASER_PCIEFD_PACKET_SEQ_MASK, seq);\n\n\tpacket_size = cf->len;\n\tmemcpy(p->data, cf->data, packet_size);\n\n\treturn DIV_ROUND_UP(packet_size, 4);\n}\n\nstatic netdev_tx_t kvaser_pciefd_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *netdev)\n{\n\tstruct kvaser_pciefd_can *can = netdev_priv(netdev);\n\tunsigned long irq_flags;\n\tstruct kvaser_pciefd_tx_packet packet;\n\tint nr_words;\n\tu8 count;\n\n\tif (can_dev_dropped_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tnr_words = kvaser_pciefd_prepare_tx_packet(&packet, can, skb);\n\n\tspin_lock_irqsave(&can->echo_lock, irq_flags);\n\t \n\tcan_put_echo_skb(skb, netdev, can->echo_idx, 0);\n\n\t \n\tcan->echo_idx = (can->echo_idx + 1) % can->can.echo_skb_max;\n\n\t \n\tiowrite32(packet.header[0],\n\t\t  can->reg_base + KVASER_PCIEFD_KCAN_FIFO_REG);\n\tiowrite32(packet.header[1],\n\t\t  can->reg_base + KVASER_PCIEFD_KCAN_FIFO_REG);\n\n\tif (nr_words) {\n\t\tu32 data_last = ((u32 *)packet.data)[nr_words - 1];\n\n\t\t \n\t\tiowrite32_rep(can->reg_base +\n\t\t\t      KVASER_PCIEFD_KCAN_FIFO_REG, packet.data,\n\t\t\t      nr_words - 1);\n\t\t \n\t\t__raw_writel(data_last, can->reg_base +\n\t\t\t     KVASER_PCIEFD_KCAN_FIFO_LAST_REG);\n\t} else {\n\t\t \n\t\t__raw_writel(0, can->reg_base +\n\t\t\t     KVASER_PCIEFD_KCAN_FIFO_LAST_REG);\n\t}\n\n\tcount = FIELD_GET(KVASER_PCIEFD_KCAN_TX_NR_PACKETS_CURRENT_MASK,\n\t\t\t  ioread32(can->reg_base + KVASER_PCIEFD_KCAN_TX_NR_PACKETS_REG));\n\t \n\tif (count >= can->can.echo_skb_max || can->can.echo_skb[can->echo_idx])\n\t\tnetif_stop_queue(netdev);\n\tspin_unlock_irqrestore(&can->echo_lock, irq_flags);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int kvaser_pciefd_set_bittiming(struct kvaser_pciefd_can *can, bool data)\n{\n\tu32 mode, test, btrn;\n\tunsigned long irq_flags;\n\tint ret;\n\tstruct can_bittiming *bt;\n\n\tif (data)\n\t\tbt = &can->can.data_bittiming;\n\telse\n\t\tbt = &can->can.bittiming;\n\n\tbtrn = FIELD_PREP(KVASER_PCIEFD_KCAN_BTRN_TSEG2_MASK, bt->phase_seg2 - 1) |\n\t       FIELD_PREP(KVASER_PCIEFD_KCAN_BTRN_TSEG1_MASK, bt->prop_seg + bt->phase_seg1 - 1) |\n\t       FIELD_PREP(KVASER_PCIEFD_KCAN_BTRN_SJW_MASK, bt->sjw - 1) |\n\t       FIELD_PREP(KVASER_PCIEFD_KCAN_BTRN_BRP_MASK, bt->brp - 1);\n\n\tspin_lock_irqsave(&can->lock, irq_flags);\n\tmode = ioread32(can->reg_base + KVASER_PCIEFD_KCAN_MODE_REG);\n\t \n\tiowrite32(mode | KVASER_PCIEFD_KCAN_MODE_RM,\n\t\t  can->reg_base + KVASER_PCIEFD_KCAN_MODE_REG);\n\n\t \n\tret = readl_poll_timeout(can->reg_base + KVASER_PCIEFD_KCAN_MODE_REG,\n\t\t\t\t test, test & KVASER_PCIEFD_KCAN_MODE_RM, 0, 10);\n\tif (ret) {\n\t\tspin_unlock_irqrestore(&can->lock, irq_flags);\n\t\treturn -EBUSY;\n\t}\n\n\tif (data)\n\t\tiowrite32(btrn, can->reg_base + KVASER_PCIEFD_KCAN_BTRD_REG);\n\telse\n\t\tiowrite32(btrn, can->reg_base + KVASER_PCIEFD_KCAN_BTRN_REG);\n\t \n\tiowrite32(mode, can->reg_base + KVASER_PCIEFD_KCAN_MODE_REG);\n\tspin_unlock_irqrestore(&can->lock, irq_flags);\n\n\treturn 0;\n}\n\nstatic int kvaser_pciefd_set_nominal_bittiming(struct net_device *ndev)\n{\n\treturn kvaser_pciefd_set_bittiming(netdev_priv(ndev), false);\n}\n\nstatic int kvaser_pciefd_set_data_bittiming(struct net_device *ndev)\n{\n\treturn kvaser_pciefd_set_bittiming(netdev_priv(ndev), true);\n}\n\nstatic int kvaser_pciefd_set_mode(struct net_device *ndev, enum can_mode mode)\n{\n\tstruct kvaser_pciefd_can *can = netdev_priv(ndev);\n\tint ret = 0;\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\tif (!can->can.restart_ms)\n\t\t\tret = kvaser_pciefd_bus_on(can);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstatic int kvaser_pciefd_get_berr_counter(const struct net_device *ndev,\n\t\t\t\t\t  struct can_berr_counter *bec)\n{\n\tstruct kvaser_pciefd_can *can = netdev_priv(ndev);\n\n\tbec->rxerr = can->bec.rxerr;\n\tbec->txerr = can->bec.txerr;\n\n\treturn 0;\n}\n\nstatic void kvaser_pciefd_bec_poll_timer(struct timer_list *data)\n{\n\tstruct kvaser_pciefd_can *can = from_timer(can, data, bec_poll_timer);\n\n\tkvaser_pciefd_enable_err_gen(can);\n\tkvaser_pciefd_request_status(can);\n\tcan->err_rep_cnt = 0;\n}\n\nstatic const struct net_device_ops kvaser_pciefd_netdev_ops = {\n\t.ndo_open = kvaser_pciefd_open,\n\t.ndo_stop = kvaser_pciefd_stop,\n\t.ndo_eth_ioctl = can_eth_ioctl_hwts,\n\t.ndo_start_xmit = kvaser_pciefd_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic const struct ethtool_ops kvaser_pciefd_ethtool_ops = {\n\t.get_ts_info = can_ethtool_op_get_ts_info_hwts,\n};\n\nstatic int kvaser_pciefd_setup_can_ctrls(struct kvaser_pciefd *pcie)\n{\n\tint i;\n\n\tfor (i = 0; i < pcie->nr_channels; i++) {\n\t\tstruct net_device *netdev;\n\t\tstruct kvaser_pciefd_can *can;\n\t\tu32 status, tx_nr_packets_max;\n\n\t\tnetdev = alloc_candev(sizeof(struct kvaser_pciefd_can),\n\t\t\t\t      KVASER_PCIEFD_CAN_TX_MAX_COUNT);\n\t\tif (!netdev)\n\t\t\treturn -ENOMEM;\n\n\t\tcan = netdev_priv(netdev);\n\t\tnetdev->netdev_ops = &kvaser_pciefd_netdev_ops;\n\t\tnetdev->ethtool_ops = &kvaser_pciefd_ethtool_ops;\n\t\tcan->reg_base = KVASER_PCIEFD_KCAN_CHX_ADDR(pcie, i);\n\t\tcan->kv_pcie = pcie;\n\t\tcan->cmd_seq = 0;\n\t\tcan->err_rep_cnt = 0;\n\t\tcan->bec.txerr = 0;\n\t\tcan->bec.rxerr = 0;\n\n\t\tinit_completion(&can->start_comp);\n\t\tinit_completion(&can->flush_comp);\n\t\ttimer_setup(&can->bec_poll_timer, kvaser_pciefd_bec_poll_timer, 0);\n\n\t\t \n\t\tiowrite32(0, can->reg_base + KVASER_PCIEFD_KCAN_BUS_LOAD_REG);\n\n\t\ttx_nr_packets_max =\n\t\t\tFIELD_GET(KVASER_PCIEFD_KCAN_TX_NR_PACKETS_MAX_MASK,\n\t\t\t\t  ioread32(can->reg_base + KVASER_PCIEFD_KCAN_TX_NR_PACKETS_REG));\n\n\t\tcan->can.clock.freq = pcie->freq;\n\t\tcan->can.echo_skb_max = min(KVASER_PCIEFD_CAN_TX_MAX_COUNT, tx_nr_packets_max - 1);\n\t\tcan->echo_idx = 0;\n\t\tspin_lock_init(&can->echo_lock);\n\t\tspin_lock_init(&can->lock);\n\n\t\tcan->can.bittiming_const = &kvaser_pciefd_bittiming_const;\n\t\tcan->can.data_bittiming_const = &kvaser_pciefd_bittiming_const;\n\t\tcan->can.do_set_bittiming = kvaser_pciefd_set_nominal_bittiming;\n\t\tcan->can.do_set_data_bittiming = kvaser_pciefd_set_data_bittiming;\n\t\tcan->can.do_set_mode = kvaser_pciefd_set_mode;\n\t\tcan->can.do_get_berr_counter = kvaser_pciefd_get_berr_counter;\n\t\tcan->can.ctrlmode_supported = CAN_CTRLMODE_LISTENONLY |\n\t\t\t\t\t      CAN_CTRLMODE_FD |\n\t\t\t\t\t      CAN_CTRLMODE_FD_NON_ISO |\n\t\t\t\t\t      CAN_CTRLMODE_CC_LEN8_DLC;\n\n\t\tstatus = ioread32(can->reg_base + KVASER_PCIEFD_KCAN_STAT_REG);\n\t\tif (!(status & KVASER_PCIEFD_KCAN_STAT_FD)) {\n\t\t\tdev_err(&pcie->pci->dev,\n\t\t\t\t\"CAN FD not supported as expected %d\\n\", i);\n\n\t\t\tfree_candev(netdev);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tif (status & KVASER_PCIEFD_KCAN_STAT_CAP)\n\t\t\tcan->can.ctrlmode_supported |= CAN_CTRLMODE_ONE_SHOT;\n\n\t\tnetdev->flags |= IFF_ECHO;\n\t\tSET_NETDEV_DEV(netdev, &pcie->pci->dev);\n\n\t\tiowrite32(GENMASK(31, 0), can->reg_base + KVASER_PCIEFD_KCAN_IRQ_REG);\n\t\tiowrite32(KVASER_PCIEFD_KCAN_IRQ_ABD,\n\t\t\t  can->reg_base + KVASER_PCIEFD_KCAN_IEN_REG);\n\n\t\tpcie->can[i] = can;\n\t\tkvaser_pciefd_pwm_start(can);\n\t}\n\n\treturn 0;\n}\n\nstatic int kvaser_pciefd_reg_candev(struct kvaser_pciefd *pcie)\n{\n\tint i;\n\n\tfor (i = 0; i < pcie->nr_channels; i++) {\n\t\tint err = register_candev(pcie->can[i]->can.dev);\n\n\t\tif (err) {\n\t\t\tint j;\n\n\t\t\t \n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tunregister_candev(pcie->can[j]->can.dev);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void kvaser_pciefd_write_dma_map_altera(struct kvaser_pciefd *pcie,\n\t\t\t\t\t       dma_addr_t addr, int index)\n{\n\tvoid __iomem *serdes_base;\n\tu32 word1, word2;\n\n#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT\n\tword1 = addr | KVASER_PCIEFD_ALTERA_DMA_64BIT;\n\tword2 = addr >> 32;\n#else\n\tword1 = addr;\n\tword2 = 0;\n#endif\n\tserdes_base = KVASER_PCIEFD_SERDES_ADDR(pcie) + 0x8 * index;\n\tiowrite32(word1, serdes_base);\n\tiowrite32(word2, serdes_base + 0x4);\n}\n\nstatic void kvaser_pciefd_write_dma_map_sf2(struct kvaser_pciefd *pcie,\n\t\t\t\t\t    dma_addr_t addr, int index)\n{\n\tvoid __iomem *serdes_base;\n\tu32 lsb = addr & KVASER_PCIEFD_SF2_DMA_LSB_MASK;\n\tu32 msb = 0x0;\n\n#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT\n\tmsb = addr >> 32;\n#endif\n\tserdes_base = KVASER_PCIEFD_SERDES_ADDR(pcie) + 0x10 * index;\n\tiowrite32(lsb, serdes_base);\n\tiowrite32(msb, serdes_base + 0x4);\n}\n\nstatic int kvaser_pciefd_setup_dma(struct kvaser_pciefd *pcie)\n{\n\tint i;\n\tu32 srb_status;\n\tu32 srb_packet_count;\n\tdma_addr_t dma_addr[KVASER_PCIEFD_DMA_COUNT];\n\n\t \n\tiowrite32(0, KVASER_PCIEFD_SRB_ADDR(pcie) + KVASER_PCIEFD_SRB_CTRL_REG);\n\tfor (i = 0; i < KVASER_PCIEFD_DMA_COUNT; i++) {\n\t\tpcie->dma_data[i] = dmam_alloc_coherent(&pcie->pci->dev,\n\t\t\t\t\t\t\tKVASER_PCIEFD_DMA_SIZE,\n\t\t\t\t\t\t\t&dma_addr[i],\n\t\t\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!pcie->dma_data[i] || !dma_addr[i]) {\n\t\t\tdev_err(&pcie->pci->dev, \"Rx dma_alloc(%u) failure\\n\",\n\t\t\t\tKVASER_PCIEFD_DMA_SIZE);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpcie->driver_data->ops->kvaser_pciefd_write_dma_map(pcie, dma_addr[i], i);\n\t}\n\n\t \n\tiowrite32(KVASER_PCIEFD_SRB_CMD_FOR | KVASER_PCIEFD_SRB_CMD_RDB0 |\n\t\t  KVASER_PCIEFD_SRB_CMD_RDB1,\n\t\t  KVASER_PCIEFD_SRB_ADDR(pcie) + KVASER_PCIEFD_SRB_CMD_REG);\n\t \n\tsrb_packet_count =\n\t\tFIELD_GET(KVASER_PCIEFD_SRB_RX_NR_PACKETS_MASK,\n\t\t\t  ioread32(KVASER_PCIEFD_SRB_ADDR(pcie) +\n\t\t\t\t   KVASER_PCIEFD_SRB_RX_NR_PACKETS_REG));\n\twhile (srb_packet_count) {\n\t\t \n\t\tioread32(KVASER_PCIEFD_SRB_FIFO_ADDR(pcie) + KVASER_PCIEFD_SRB_FIFO_LAST_REG);\n\t\tsrb_packet_count--;\n\t}\n\n\tsrb_status = ioread32(KVASER_PCIEFD_SRB_ADDR(pcie) + KVASER_PCIEFD_SRB_STAT_REG);\n\tif (!(srb_status & KVASER_PCIEFD_SRB_STAT_DI)) {\n\t\tdev_err(&pcie->pci->dev, \"DMA not idle before enabling\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tiowrite32(KVASER_PCIEFD_SRB_CTRL_DMA_ENABLE,\n\t\t  KVASER_PCIEFD_SRB_ADDR(pcie) + KVASER_PCIEFD_SRB_CTRL_REG);\n\n\treturn 0;\n}\n\nstatic int kvaser_pciefd_setup_board(struct kvaser_pciefd *pcie)\n{\n\tu32 version, srb_status, build;\n\n\tversion = ioread32(KVASER_PCIEFD_SYSID_ADDR(pcie) + KVASER_PCIEFD_SYSID_VERSION_REG);\n\tpcie->nr_channels = min(KVASER_PCIEFD_MAX_CAN_CHANNELS,\n\t\t\t\tFIELD_GET(KVASER_PCIEFD_SYSID_VERSION_NR_CHAN_MASK, version));\n\n\tbuild = ioread32(KVASER_PCIEFD_SYSID_ADDR(pcie) + KVASER_PCIEFD_SYSID_BUILD_REG);\n\tdev_dbg(&pcie->pci->dev, \"Version %lu.%lu.%lu\\n\",\n\t\tFIELD_GET(KVASER_PCIEFD_SYSID_VERSION_MAJOR_MASK, version),\n\t\tFIELD_GET(KVASER_PCIEFD_SYSID_VERSION_MINOR_MASK, version),\n\t\tFIELD_GET(KVASER_PCIEFD_SYSID_BUILD_SEQ_MASK, build));\n\n\tsrb_status = ioread32(KVASER_PCIEFD_SRB_ADDR(pcie) + KVASER_PCIEFD_SRB_STAT_REG);\n\tif (!(srb_status & KVASER_PCIEFD_SRB_STAT_DMA)) {\n\t\tdev_err(&pcie->pci->dev, \"Hardware without DMA is not supported\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpcie->bus_freq = ioread32(KVASER_PCIEFD_SYSID_ADDR(pcie) + KVASER_PCIEFD_SYSID_BUSFREQ_REG);\n\tpcie->freq = ioread32(KVASER_PCIEFD_SYSID_ADDR(pcie) + KVASER_PCIEFD_SYSID_CANFREQ_REG);\n\tpcie->freq_to_ticks_div = pcie->freq / 1000000;\n\tif (pcie->freq_to_ticks_div == 0)\n\t\tpcie->freq_to_ticks_div = 1;\n\t \n\tiowrite32(0, KVASER_PCIEFD_LOOPBACK_ADDR(pcie));\n\n\treturn 0;\n}\n\nstatic int kvaser_pciefd_handle_data_packet(struct kvaser_pciefd *pcie,\n\t\t\t\t\t    struct kvaser_pciefd_rx_packet *p,\n\t\t\t\t\t    __le32 *data)\n{\n\tstruct sk_buff *skb;\n\tstruct canfd_frame *cf;\n\tstruct can_priv *priv;\n\tu8 ch_id = FIELD_GET(KVASER_PCIEFD_PACKET_CHID_MASK, p->header[1]);\n\tu8 dlc;\n\n\tif (ch_id >= pcie->nr_channels)\n\t\treturn -EIO;\n\n\tpriv = &pcie->can[ch_id]->can;\n\tdlc = FIELD_GET(KVASER_PCIEFD_RPACKET_DLC_MASK, p->header[1]);\n\n\tif (p->header[1] & KVASER_PCIEFD_RPACKET_FDF) {\n\t\tskb = alloc_canfd_skb(priv->dev, &cf);\n\t\tif (!skb) {\n\t\t\tpriv->dev->stats.rx_dropped++;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tcf->len = can_fd_dlc2len(dlc);\n\t\tif (p->header[1] & KVASER_PCIEFD_RPACKET_BRS)\n\t\t\tcf->flags |= CANFD_BRS;\n\t\tif (p->header[1] & KVASER_PCIEFD_RPACKET_ESI)\n\t\t\tcf->flags |= CANFD_ESI;\n\t} else {\n\t\tskb = alloc_can_skb(priv->dev, (struct can_frame **)&cf);\n\t\tif (!skb) {\n\t\t\tpriv->dev->stats.rx_dropped++;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tcan_frame_set_cc_len((struct can_frame *)cf, dlc, priv->ctrlmode);\n\t}\n\n\tcf->can_id = FIELD_GET(KVASER_PCIEFD_RPACKET_ID_MASK, p->header[0]);\n\tif (p->header[0] & KVASER_PCIEFD_RPACKET_IDE)\n\t\tcf->can_id |= CAN_EFF_FLAG;\n\n\tif (p->header[0] & KVASER_PCIEFD_RPACKET_RTR) {\n\t\tcf->can_id |= CAN_RTR_FLAG;\n\t} else {\n\t\tmemcpy(cf->data, data, cf->len);\n\t\tpriv->dev->stats.rx_bytes += cf->len;\n\t}\n\tpriv->dev->stats.rx_packets++;\n\tkvaser_pciefd_set_skb_timestamp(pcie, skb, p->timestamp);\n\n\treturn netif_rx(skb);\n}\n\nstatic void kvaser_pciefd_change_state(struct kvaser_pciefd_can *can,\n\t\t\t\t       struct can_frame *cf,\n\t\t\t\t       enum can_state new_state,\n\t\t\t\t       enum can_state tx_state,\n\t\t\t\t       enum can_state rx_state)\n{\n\tcan_change_state(can->can.dev, cf, tx_state, rx_state);\n\n\tif (new_state == CAN_STATE_BUS_OFF) {\n\t\tstruct net_device *ndev = can->can.dev;\n\t\tunsigned long irq_flags;\n\n\t\tspin_lock_irqsave(&can->lock, irq_flags);\n\t\tnetif_stop_queue(can->can.dev);\n\t\tspin_unlock_irqrestore(&can->lock, irq_flags);\n\t\t \n\t\tif (!can->can.restart_ms) {\n\t\t\tkvaser_pciefd_start_controller_flush(can);\n\t\t\tcan_bus_off(ndev);\n\t\t}\n\t}\n}\n\nstatic void kvaser_pciefd_packet_to_state(struct kvaser_pciefd_rx_packet *p,\n\t\t\t\t\t  struct can_berr_counter *bec,\n\t\t\t\t\t  enum can_state *new_state,\n\t\t\t\t\t  enum can_state *tx_state,\n\t\t\t\t\t  enum can_state *rx_state)\n{\n\tif (p->header[0] & KVASER_PCIEFD_SPACK_BOFF ||\n\t    p->header[0] & KVASER_PCIEFD_SPACK_IRM)\n\t\t*new_state = CAN_STATE_BUS_OFF;\n\telse if (bec->txerr >= 255 || bec->rxerr >= 255)\n\t\t*new_state = CAN_STATE_BUS_OFF;\n\telse if (p->header[1] & KVASER_PCIEFD_SPACK_EPLR)\n\t\t*new_state = CAN_STATE_ERROR_PASSIVE;\n\telse if (bec->txerr >= 128 || bec->rxerr >= 128)\n\t\t*new_state = CAN_STATE_ERROR_PASSIVE;\n\telse if (p->header[1] & KVASER_PCIEFD_SPACK_EWLR)\n\t\t*new_state = CAN_STATE_ERROR_WARNING;\n\telse if (bec->txerr >= 96 || bec->rxerr >= 96)\n\t\t*new_state = CAN_STATE_ERROR_WARNING;\n\telse\n\t\t*new_state = CAN_STATE_ERROR_ACTIVE;\n\n\t*tx_state = bec->txerr >= bec->rxerr ? *new_state : 0;\n\t*rx_state = bec->txerr <= bec->rxerr ? *new_state : 0;\n}\n\nstatic int kvaser_pciefd_rx_error_frame(struct kvaser_pciefd_can *can,\n\t\t\t\t\tstruct kvaser_pciefd_rx_packet *p)\n{\n\tstruct can_berr_counter bec;\n\tenum can_state old_state, new_state, tx_state, rx_state;\n\tstruct net_device *ndev = can->can.dev;\n\tstruct sk_buff *skb;\n\tstruct can_frame *cf = NULL;\n\n\told_state = can->can.state;\n\n\tbec.txerr = FIELD_GET(KVASER_PCIEFD_SPACK_TXERR_MASK, p->header[0]);\n\tbec.rxerr = FIELD_GET(KVASER_PCIEFD_SPACK_RXERR_MASK, p->header[0]);\n\n\tkvaser_pciefd_packet_to_state(p, &bec, &new_state, &tx_state, &rx_state);\n\tskb = alloc_can_err_skb(ndev, &cf);\n\tif (new_state != old_state) {\n\t\tkvaser_pciefd_change_state(can, cf, new_state, tx_state, rx_state);\n\t\tif (old_state == CAN_STATE_BUS_OFF &&\n\t\t    new_state == CAN_STATE_ERROR_ACTIVE &&\n\t\t    can->can.restart_ms) {\n\t\t\tcan->can.can_stats.restarts++;\n\t\t\tif (skb)\n\t\t\t\tcf->can_id |= CAN_ERR_RESTARTED;\n\t\t}\n\t}\n\n\tcan->err_rep_cnt++;\n\tcan->can.can_stats.bus_error++;\n\tif (p->header[1] & KVASER_PCIEFD_EPACK_DIR_TX)\n\t\tndev->stats.tx_errors++;\n\telse\n\t\tndev->stats.rx_errors++;\n\n\tcan->bec.txerr = bec.txerr;\n\tcan->bec.rxerr = bec.rxerr;\n\n\tif (!skb) {\n\t\tndev->stats.rx_dropped++;\n\t\treturn -ENOMEM;\n\t}\n\n\tkvaser_pciefd_set_skb_timestamp(can->kv_pcie, skb, p->timestamp);\n\tcf->can_id |= CAN_ERR_BUSERROR | CAN_ERR_CNT;\n\tcf->data[6] = bec.txerr;\n\tcf->data[7] = bec.rxerr;\n\n\tnetif_rx(skb);\n\n\treturn 0;\n}\n\nstatic int kvaser_pciefd_handle_error_packet(struct kvaser_pciefd *pcie,\n\t\t\t\t\t     struct kvaser_pciefd_rx_packet *p)\n{\n\tstruct kvaser_pciefd_can *can;\n\tu8 ch_id = FIELD_GET(KVASER_PCIEFD_PACKET_CHID_MASK, p->header[1]);\n\n\tif (ch_id >= pcie->nr_channels)\n\t\treturn -EIO;\n\n\tcan = pcie->can[ch_id];\n\tkvaser_pciefd_rx_error_frame(can, p);\n\tif (can->err_rep_cnt >= KVASER_PCIEFD_MAX_ERR_REP)\n\t\t \n\t\tkvaser_pciefd_disable_err_gen(can);\n\t \n\tmod_timer(&can->bec_poll_timer, KVASER_PCIEFD_BEC_POLL_FREQ);\n\n\treturn 0;\n}\n\nstatic int kvaser_pciefd_handle_status_resp(struct kvaser_pciefd_can *can,\n\t\t\t\t\t    struct kvaser_pciefd_rx_packet *p)\n{\n\tstruct can_berr_counter bec;\n\tenum can_state old_state, new_state, tx_state, rx_state;\n\n\told_state = can->can.state;\n\n\tbec.txerr = FIELD_GET(KVASER_PCIEFD_SPACK_TXERR_MASK, p->header[0]);\n\tbec.rxerr = FIELD_GET(KVASER_PCIEFD_SPACK_RXERR_MASK, p->header[0]);\n\n\tkvaser_pciefd_packet_to_state(p, &bec, &new_state, &tx_state, &rx_state);\n\tif (new_state != old_state) {\n\t\tstruct net_device *ndev = can->can.dev;\n\t\tstruct sk_buff *skb;\n\t\tstruct can_frame *cf;\n\n\t\tskb = alloc_can_err_skb(ndev, &cf);\n\t\tif (!skb) {\n\t\t\tndev->stats.rx_dropped++;\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tkvaser_pciefd_change_state(can, cf, new_state, tx_state, rx_state);\n\t\tif (old_state == CAN_STATE_BUS_OFF &&\n\t\t    new_state == CAN_STATE_ERROR_ACTIVE &&\n\t\t    can->can.restart_ms) {\n\t\t\tcan->can.can_stats.restarts++;\n\t\t\tcf->can_id |= CAN_ERR_RESTARTED;\n\t\t}\n\n\t\tkvaser_pciefd_set_skb_timestamp(can->kv_pcie, skb, p->timestamp);\n\n\t\tcf->data[6] = bec.txerr;\n\t\tcf->data[7] = bec.rxerr;\n\n\t\tnetif_rx(skb);\n\t}\n\tcan->bec.txerr = bec.txerr;\n\tcan->bec.rxerr = bec.rxerr;\n\t \n\tif (bec.txerr || bec.rxerr)\n\t\tmod_timer(&can->bec_poll_timer, KVASER_PCIEFD_BEC_POLL_FREQ);\n\n\treturn 0;\n}\n\nstatic int kvaser_pciefd_handle_status_packet(struct kvaser_pciefd *pcie,\n\t\t\t\t\t      struct kvaser_pciefd_rx_packet *p)\n{\n\tstruct kvaser_pciefd_can *can;\n\tu8 cmdseq;\n\tu32 status;\n\tu8 ch_id = FIELD_GET(KVASER_PCIEFD_PACKET_CHID_MASK, p->header[1]);\n\n\tif (ch_id >= pcie->nr_channels)\n\t\treturn -EIO;\n\n\tcan = pcie->can[ch_id];\n\n\tstatus = ioread32(can->reg_base + KVASER_PCIEFD_KCAN_STAT_REG);\n\tcmdseq = FIELD_GET(KVASER_PCIEFD_KCAN_STAT_SEQNO_MASK, status);\n\n\t \n\tif (p->header[0] & KVASER_PCIEFD_SPACK_IRM &&\n\t    p->header[0] & KVASER_PCIEFD_SPACK_RMCD &&\n\t    p->header[1] & KVASER_PCIEFD_SPACK_AUTO &&\n\t    cmdseq == FIELD_GET(KVASER_PCIEFD_PACKET_SEQ_MASK, p->header[1]) &&\n\t    status & KVASER_PCIEFD_KCAN_STAT_IDLE) {\n\t\tiowrite32(KVASER_PCIEFD_KCAN_IRQ_ABD,\n\t\t\t  can->reg_base + KVASER_PCIEFD_KCAN_IRQ_REG);\n\t\tkvaser_pciefd_abort_flush_reset(can);\n\t} else if (p->header[0] & KVASER_PCIEFD_SPACK_IDET &&\n\t\t   p->header[0] & KVASER_PCIEFD_SPACK_IRM &&\n\t\t   cmdseq == FIELD_GET(KVASER_PCIEFD_PACKET_SEQ_MASK, p->header[1]) &&\n\t\t   status & KVASER_PCIEFD_KCAN_STAT_IDLE) {\n\t\t \n\t\tu8 count;\n\n\t\tcount = FIELD_GET(KVASER_PCIEFD_KCAN_TX_NR_PACKETS_CURRENT_MASK,\n\t\t\t\t  ioread32(can->reg_base + KVASER_PCIEFD_KCAN_TX_NR_PACKETS_REG));\n\t\tif (!count)\n\t\t\tiowrite32(FIELD_PREP(KVASER_PCIEFD_KCAN_CTRL_TYPE_MASK,\n\t\t\t\t\t     KVASER_PCIEFD_KCAN_CTRL_TYPE_EFLUSH),\n\t\t\t\t  can->reg_base + KVASER_PCIEFD_KCAN_CTRL_REG);\n\t} else if (!(p->header[1] & KVASER_PCIEFD_SPACK_AUTO) &&\n\t\t   cmdseq == FIELD_GET(KVASER_PCIEFD_PACKET_SEQ_MASK, p->header[1])) {\n\t\t \n\t\tkvaser_pciefd_handle_status_resp(can, p);\n\t\tif (can->can.state != CAN_STATE_BUS_OFF &&\n\t\t    can->can.state != CAN_STATE_ERROR_ACTIVE) {\n\t\t\tmod_timer(&can->bec_poll_timer, KVASER_PCIEFD_BEC_POLL_FREQ);\n\t\t}\n\t} else if (p->header[0] & KVASER_PCIEFD_SPACK_RMCD &&\n\t\t   !(status & KVASER_PCIEFD_KCAN_STAT_BUS_OFF_MASK)) {\n\t\t \n\t\tif (!completion_done(&can->start_comp))\n\t\t\tcomplete(&can->start_comp);\n\t}\n\n\treturn 0;\n}\n\nstatic void kvaser_pciefd_handle_nack_packet(struct kvaser_pciefd_can *can,\n\t\t\t\t\t     struct kvaser_pciefd_rx_packet *p)\n{\n\tstruct sk_buff *skb;\n\tstruct can_frame *cf;\n\n\tskb = alloc_can_err_skb(can->can.dev, &cf);\n\tcan->can.dev->stats.tx_errors++;\n\tif (p->header[0] & KVASER_PCIEFD_APACKET_ABL) {\n\t\tif (skb)\n\t\t\tcf->can_id |= CAN_ERR_LOSTARB;\n\t\tcan->can.can_stats.arbitration_lost++;\n\t} else if (skb) {\n\t\tcf->can_id |= CAN_ERR_ACK;\n\t}\n\n\tif (skb) {\n\t\tcf->can_id |= CAN_ERR_BUSERROR;\n\t\tkvaser_pciefd_set_skb_timestamp(can->kv_pcie, skb, p->timestamp);\n\t\tnetif_rx(skb);\n\t} else {\n\t\tcan->can.dev->stats.rx_dropped++;\n\t\tnetdev_warn(can->can.dev, \"No memory left for err_skb\\n\");\n\t}\n}\n\nstatic int kvaser_pciefd_handle_ack_packet(struct kvaser_pciefd *pcie,\n\t\t\t\t\t   struct kvaser_pciefd_rx_packet *p)\n{\n\tstruct kvaser_pciefd_can *can;\n\tbool one_shot_fail = false;\n\tu8 ch_id = FIELD_GET(KVASER_PCIEFD_PACKET_CHID_MASK, p->header[1]);\n\n\tif (ch_id >= pcie->nr_channels)\n\t\treturn -EIO;\n\n\tcan = pcie->can[ch_id];\n\t \n\tif (p->header[0] & KVASER_PCIEFD_APACKET_CT)\n\t\treturn 0;\n\n\tif (p->header[0] & KVASER_PCIEFD_APACKET_NACK) {\n\t\tkvaser_pciefd_handle_nack_packet(can, p);\n\t\tone_shot_fail = true;\n\t}\n\n\tif (p->header[0] & KVASER_PCIEFD_APACKET_FLU) {\n\t\tnetdev_dbg(can->can.dev, \"Packet was flushed\\n\");\n\t} else {\n\t\tint echo_idx = FIELD_GET(KVASER_PCIEFD_PACKET_SEQ_MASK, p->header[0]);\n\t\tint len;\n\t\tu8 count;\n\t\tstruct sk_buff *skb;\n\n\t\tskb = can->can.echo_skb[echo_idx];\n\t\tif (skb)\n\t\t\tkvaser_pciefd_set_skb_timestamp(pcie, skb, p->timestamp);\n\t\tlen = can_get_echo_skb(can->can.dev, echo_idx, NULL);\n\t\tcount = FIELD_GET(KVASER_PCIEFD_KCAN_TX_NR_PACKETS_CURRENT_MASK,\n\t\t\t\t  ioread32(can->reg_base + KVASER_PCIEFD_KCAN_TX_NR_PACKETS_REG));\n\n\t\tif (count < can->can.echo_skb_max && netif_queue_stopped(can->can.dev))\n\t\t\tnetif_wake_queue(can->can.dev);\n\n\t\tif (!one_shot_fail) {\n\t\t\tcan->can.dev->stats.tx_bytes += len;\n\t\t\tcan->can.dev->stats.tx_packets++;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int kvaser_pciefd_handle_eflush_packet(struct kvaser_pciefd *pcie,\n\t\t\t\t\t      struct kvaser_pciefd_rx_packet *p)\n{\n\tstruct kvaser_pciefd_can *can;\n\tu8 ch_id = FIELD_GET(KVASER_PCIEFD_PACKET_CHID_MASK, p->header[1]);\n\n\tif (ch_id >= pcie->nr_channels)\n\t\treturn -EIO;\n\n\tcan = pcie->can[ch_id];\n\n\tif (!completion_done(&can->flush_comp))\n\t\tcomplete(&can->flush_comp);\n\n\treturn 0;\n}\n\nstatic int kvaser_pciefd_read_packet(struct kvaser_pciefd *pcie, int *start_pos,\n\t\t\t\t     int dma_buf)\n{\n\t__le32 *buffer = pcie->dma_data[dma_buf];\n\t__le64 timestamp;\n\tstruct kvaser_pciefd_rx_packet packet;\n\tstruct kvaser_pciefd_rx_packet *p = &packet;\n\tu8 type;\n\tint pos = *start_pos;\n\tint size;\n\tint ret = 0;\n\n\tsize = le32_to_cpu(buffer[pos++]);\n\tif (!size) {\n\t\t*start_pos = 0;\n\t\treturn 0;\n\t}\n\n\tp->header[0] = le32_to_cpu(buffer[pos++]);\n\tp->header[1] = le32_to_cpu(buffer[pos++]);\n\n\t \n\tmemcpy(&timestamp, &buffer[pos], sizeof(__le64));\n\tpos += 2;\n\tp->timestamp = le64_to_cpu(timestamp);\n\n\ttype = FIELD_GET(KVASER_PCIEFD_PACKET_TYPE_MASK, p->header[1]);\n\tswitch (type) {\n\tcase KVASER_PCIEFD_PACK_TYPE_DATA:\n\t\tret = kvaser_pciefd_handle_data_packet(pcie, p, &buffer[pos]);\n\t\tif (!(p->header[0] & KVASER_PCIEFD_RPACKET_RTR)) {\n\t\t\tu8 data_len;\n\n\t\t\tdata_len = can_fd_dlc2len(FIELD_GET(KVASER_PCIEFD_RPACKET_DLC_MASK,\n\t\t\t\t\t\t\t    p->header[1]));\n\t\t\tpos += DIV_ROUND_UP(data_len, 4);\n\t\t}\n\t\tbreak;\n\n\tcase KVASER_PCIEFD_PACK_TYPE_ACK:\n\t\tret = kvaser_pciefd_handle_ack_packet(pcie, p);\n\t\tbreak;\n\n\tcase KVASER_PCIEFD_PACK_TYPE_STATUS:\n\t\tret = kvaser_pciefd_handle_status_packet(pcie, p);\n\t\tbreak;\n\n\tcase KVASER_PCIEFD_PACK_TYPE_ERROR:\n\t\tret = kvaser_pciefd_handle_error_packet(pcie, p);\n\t\tbreak;\n\n\tcase KVASER_PCIEFD_PACK_TYPE_EFLUSH_ACK:\n\t\tret = kvaser_pciefd_handle_eflush_packet(pcie, p);\n\t\tbreak;\n\n\tcase KVASER_PCIEFD_PACK_TYPE_ACK_DATA:\n\tcase KVASER_PCIEFD_PACK_TYPE_BUS_LOAD:\n\tcase KVASER_PCIEFD_PACK_TYPE_EFRAME_ACK:\n\tcase KVASER_PCIEFD_PACK_TYPE_TXRQ:\n\t\tdev_info(&pcie->pci->dev,\n\t\t\t \"Received unexpected packet type 0x%08X\\n\", type);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&pcie->pci->dev, \"Unknown packet type 0x%08X\\n\", type);\n\t\tret = -EIO;\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif ((*start_pos + size) != pos)\n\t\treturn -EIO;\n\n\t \n\t*start_pos = pos;\n\n\treturn ret;\n}\n\nstatic int kvaser_pciefd_read_buffer(struct kvaser_pciefd *pcie, int dma_buf)\n{\n\tint pos = 0;\n\tint res = 0;\n\n\tdo {\n\t\tres = kvaser_pciefd_read_packet(pcie, &pos, dma_buf);\n\t} while (!res && pos > 0 && pos < KVASER_PCIEFD_DMA_SIZE);\n\n\treturn res;\n}\n\nstatic void kvaser_pciefd_receive_irq(struct kvaser_pciefd *pcie)\n{\n\tu32 irq = ioread32(KVASER_PCIEFD_SRB_ADDR(pcie) + KVASER_PCIEFD_SRB_IRQ_REG);\n\n\tif (irq & KVASER_PCIEFD_SRB_IRQ_DPD0) {\n\t\tkvaser_pciefd_read_buffer(pcie, 0);\n\t\t \n\t\tiowrite32(KVASER_PCIEFD_SRB_CMD_RDB0,\n\t\t\t  KVASER_PCIEFD_SRB_ADDR(pcie) + KVASER_PCIEFD_SRB_CMD_REG);\n\t}\n\n\tif (irq & KVASER_PCIEFD_SRB_IRQ_DPD1) {\n\t\tkvaser_pciefd_read_buffer(pcie, 1);\n\t\t \n\t\tiowrite32(KVASER_PCIEFD_SRB_CMD_RDB1,\n\t\t\t  KVASER_PCIEFD_SRB_ADDR(pcie) + KVASER_PCIEFD_SRB_CMD_REG);\n\t}\n\n\tif (irq & KVASER_PCIEFD_SRB_IRQ_DOF0 ||\n\t    irq & KVASER_PCIEFD_SRB_IRQ_DOF1 ||\n\t    irq & KVASER_PCIEFD_SRB_IRQ_DUF0 ||\n\t    irq & KVASER_PCIEFD_SRB_IRQ_DUF1)\n\t\tdev_err(&pcie->pci->dev, \"DMA IRQ error 0x%08X\\n\", irq);\n\n\tiowrite32(irq, KVASER_PCIEFD_SRB_ADDR(pcie) + KVASER_PCIEFD_SRB_IRQ_REG);\n}\n\nstatic void kvaser_pciefd_transmit_irq(struct kvaser_pciefd_can *can)\n{\n\tu32 irq = ioread32(can->reg_base + KVASER_PCIEFD_KCAN_IRQ_REG);\n\n\tif (irq & KVASER_PCIEFD_KCAN_IRQ_TOF)\n\t\tnetdev_err(can->can.dev, \"Tx FIFO overflow\\n\");\n\n\tif (irq & KVASER_PCIEFD_KCAN_IRQ_BPP)\n\t\tnetdev_err(can->can.dev,\n\t\t\t   \"Fail to change bittiming, when not in reset mode\\n\");\n\n\tif (irq & KVASER_PCIEFD_KCAN_IRQ_FDIC)\n\t\tnetdev_err(can->can.dev, \"CAN FD frame in CAN mode\\n\");\n\n\tif (irq & KVASER_PCIEFD_KCAN_IRQ_ROF)\n\t\tnetdev_err(can->can.dev, \"Rx FIFO overflow\\n\");\n\n\tiowrite32(irq, can->reg_base + KVASER_PCIEFD_KCAN_IRQ_REG);\n}\n\nstatic irqreturn_t kvaser_pciefd_irq_handler(int irq, void *dev)\n{\n\tstruct kvaser_pciefd *pcie = (struct kvaser_pciefd *)dev;\n\tconst struct kvaser_pciefd_irq_mask *irq_mask = pcie->driver_data->irq_mask;\n\tu32 board_irq = ioread32(KVASER_PCIEFD_PCI_IRQ_ADDR(pcie));\n\tint i;\n\n\tif (!(board_irq & irq_mask->all))\n\t\treturn IRQ_NONE;\n\n\tif (board_irq & irq_mask->kcan_rx0)\n\t\tkvaser_pciefd_receive_irq(pcie);\n\n\tfor (i = 0; i < pcie->nr_channels; i++) {\n\t\tif (!pcie->can[i]) {\n\t\t\tdev_err(&pcie->pci->dev,\n\t\t\t\t\"IRQ mask points to unallocated controller\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (board_irq & irq_mask->kcan_tx[i])\n\t\t\tkvaser_pciefd_transmit_irq(pcie->can[i]);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void kvaser_pciefd_teardown_can_ctrls(struct kvaser_pciefd *pcie)\n{\n\tint i;\n\n\tfor (i = 0; i < pcie->nr_channels; i++) {\n\t\tstruct kvaser_pciefd_can *can = pcie->can[i];\n\n\t\tif (can) {\n\t\t\tiowrite32(0, can->reg_base + KVASER_PCIEFD_KCAN_IEN_REG);\n\t\t\tkvaser_pciefd_pwm_stop(can);\n\t\t\tfree_candev(can->can.dev);\n\t\t}\n\t}\n}\n\nstatic int kvaser_pciefd_probe(struct pci_dev *pdev,\n\t\t\t       const struct pci_device_id *id)\n{\n\tint err;\n\tstruct kvaser_pciefd *pcie;\n\tconst struct kvaser_pciefd_irq_mask *irq_mask;\n\tvoid __iomem *irq_en_base;\n\n\tpcie = devm_kzalloc(&pdev->dev, sizeof(*pcie), GFP_KERNEL);\n\tif (!pcie)\n\t\treturn -ENOMEM;\n\n\tpci_set_drvdata(pdev, pcie);\n\tpcie->pci = pdev;\n\tpcie->driver_data = (const struct kvaser_pciefd_driver_data *)id->driver_data;\n\tirq_mask = pcie->driver_data->irq_mask;\n\n\terr = pci_enable_device(pdev);\n\tif (err)\n\t\treturn err;\n\n\terr = pci_request_regions(pdev, KVASER_PCIEFD_DRV_NAME);\n\tif (err)\n\t\tgoto err_disable_pci;\n\n\tpcie->reg_base = pci_iomap(pdev, 0, 0);\n\tif (!pcie->reg_base) {\n\t\terr = -ENOMEM;\n\t\tgoto err_release_regions;\n\t}\n\n\terr = kvaser_pciefd_setup_board(pcie);\n\tif (err)\n\t\tgoto err_pci_iounmap;\n\n\terr = kvaser_pciefd_setup_dma(pcie);\n\tif (err)\n\t\tgoto err_pci_iounmap;\n\n\tpci_set_master(pdev);\n\n\terr = kvaser_pciefd_setup_can_ctrls(pcie);\n\tif (err)\n\t\tgoto err_teardown_can_ctrls;\n\n\terr = request_irq(pcie->pci->irq, kvaser_pciefd_irq_handler,\n\t\t\t  IRQF_SHARED, KVASER_PCIEFD_DRV_NAME, pcie);\n\tif (err)\n\t\tgoto err_teardown_can_ctrls;\n\n\tiowrite32(KVASER_PCIEFD_SRB_IRQ_DPD0 | KVASER_PCIEFD_SRB_IRQ_DPD1,\n\t\t  KVASER_PCIEFD_SRB_ADDR(pcie) + KVASER_PCIEFD_SRB_IRQ_REG);\n\n\tiowrite32(KVASER_PCIEFD_SRB_IRQ_DPD0 | KVASER_PCIEFD_SRB_IRQ_DPD1 |\n\t\t  KVASER_PCIEFD_SRB_IRQ_DOF0 | KVASER_PCIEFD_SRB_IRQ_DOF1 |\n\t\t  KVASER_PCIEFD_SRB_IRQ_DUF0 | KVASER_PCIEFD_SRB_IRQ_DUF1,\n\t\t  KVASER_PCIEFD_SRB_ADDR(pcie) + KVASER_PCIEFD_SRB_IEN_REG);\n\n\t \n\tirq_en_base = KVASER_PCIEFD_PCI_IEN_ADDR(pcie);\n\tiowrite32(irq_mask->all, irq_en_base);\n\t \n\tiowrite32(KVASER_PCIEFD_SRB_CMD_RDB0,\n\t\t  KVASER_PCIEFD_SRB_ADDR(pcie) + KVASER_PCIEFD_SRB_CMD_REG);\n\tiowrite32(KVASER_PCIEFD_SRB_CMD_RDB1,\n\t\t  KVASER_PCIEFD_SRB_ADDR(pcie) + KVASER_PCIEFD_SRB_CMD_REG);\n\n\terr = kvaser_pciefd_reg_candev(pcie);\n\tif (err)\n\t\tgoto err_free_irq;\n\n\treturn 0;\n\nerr_free_irq:\n\t \n\tiowrite32(0, irq_en_base);\n\tfree_irq(pcie->pci->irq, pcie);\n\nerr_teardown_can_ctrls:\n\tkvaser_pciefd_teardown_can_ctrls(pcie);\n\tiowrite32(0, KVASER_PCIEFD_SRB_ADDR(pcie) + KVASER_PCIEFD_SRB_CTRL_REG);\n\tpci_clear_master(pdev);\n\nerr_pci_iounmap:\n\tpci_iounmap(pdev, pcie->reg_base);\n\nerr_release_regions:\n\tpci_release_regions(pdev);\n\nerr_disable_pci:\n\tpci_disable_device(pdev);\n\n\treturn err;\n}\n\nstatic void kvaser_pciefd_remove_all_ctrls(struct kvaser_pciefd *pcie)\n{\n\tint i;\n\n\tfor (i = 0; i < pcie->nr_channels; i++) {\n\t\tstruct kvaser_pciefd_can *can = pcie->can[i];\n\n\t\tif (can) {\n\t\t\tiowrite32(0, can->reg_base + KVASER_PCIEFD_KCAN_IEN_REG);\n\t\t\tunregister_candev(can->can.dev);\n\t\t\tdel_timer(&can->bec_poll_timer);\n\t\t\tkvaser_pciefd_pwm_stop(can);\n\t\t\tfree_candev(can->can.dev);\n\t\t}\n\t}\n}\n\nstatic void kvaser_pciefd_remove(struct pci_dev *pdev)\n{\n\tstruct kvaser_pciefd *pcie = pci_get_drvdata(pdev);\n\n\tkvaser_pciefd_remove_all_ctrls(pcie);\n\n\t \n\tiowrite32(0, KVASER_PCIEFD_SRB_ADDR(pcie) + KVASER_PCIEFD_SRB_CTRL_REG);\n\tiowrite32(0, KVASER_PCIEFD_PCI_IEN_ADDR(pcie));\n\n\tfree_irq(pcie->pci->irq, pcie);\n\n\tpci_iounmap(pdev, pcie->reg_base);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n}\n\nstatic struct pci_driver kvaser_pciefd = {\n\t.name = KVASER_PCIEFD_DRV_NAME,\n\t.id_table = kvaser_pciefd_id_table,\n\t.probe = kvaser_pciefd_probe,\n\t.remove = kvaser_pciefd_remove,\n};\n\nmodule_pci_driver(kvaser_pciefd)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}