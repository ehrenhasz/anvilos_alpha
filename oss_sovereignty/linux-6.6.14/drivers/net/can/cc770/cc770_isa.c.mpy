{
  "module_name": "cc770_isa.c",
  "hash_id": "82b52d37712ff2564716dc2de7dd643e46286ac4c52416ab1eae8f51756bdb43",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/cc770/cc770_isa.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/platform/cc770.h>\n\n#include \"cc770.h\"\n\n#define MAXDEV 8\n\nMODULE_AUTHOR(\"Wolfgang Grandegger <wg@grandegger.com>\");\nMODULE_DESCRIPTION(\"Socket-CAN driver for CC770 on the ISA bus\");\nMODULE_LICENSE(\"GPL v2\");\n\n#define CLK_DEFAULT\t16000000\t \n#define COR_DEFAULT\t0x00\n#define BCR_DEFAULT\tBUSCFG_CBY\n\nstatic unsigned long port[MAXDEV];\nstatic unsigned long mem[MAXDEV];\nstatic int irq[MAXDEV];\nstatic int clk[MAXDEV];\nstatic u8 cir[MAXDEV] = {[0 ... (MAXDEV - 1)] = 0xff};\nstatic u8 cor[MAXDEV] = {[0 ... (MAXDEV - 1)] = 0xff};\nstatic u8 bcr[MAXDEV] = {[0 ... (MAXDEV - 1)] = 0xff};\nstatic int indirect[MAXDEV] = {[0 ... (MAXDEV - 1)] = -1};\n\nmodule_param_hw_array(port, ulong, ioport, NULL, 0444);\nMODULE_PARM_DESC(port, \"I/O port number\");\n\nmodule_param_hw_array(mem, ulong, iomem, NULL, 0444);\nMODULE_PARM_DESC(mem, \"I/O memory address\");\n\nmodule_param_hw_array(indirect, int, ioport, NULL, 0444);\nMODULE_PARM_DESC(indirect, \"Indirect access via address and data port\");\n\nmodule_param_hw_array(irq, int, irq, NULL, 0444);\nMODULE_PARM_DESC(irq, \"IRQ number\");\n\nmodule_param_array(clk, int, NULL, 0444);\nMODULE_PARM_DESC(clk, \"External oscillator clock frequency \"\n\t\t \"(default=16000000 [16 MHz])\");\n\nmodule_param_array(cir, byte, NULL, 0444);\nMODULE_PARM_DESC(cir, \"CPU interface register (default=0x40 [DSC])\");\n\nmodule_param_array(cor, byte, NULL, 0444);\nMODULE_PARM_DESC(cor, \"Clockout register (default=0x00)\");\n\nmodule_param_array(bcr, byte, NULL, 0444);\nMODULE_PARM_DESC(bcr, \"Bus configuration register (default=0x40 [CBY])\");\n\n#define CC770_IOSIZE          0x20\n#define CC770_IOSIZE_INDIRECT 0x02\n\n \nstatic DEFINE_SPINLOCK(cc770_isa_port_lock);\n\nstatic struct platform_device *cc770_isa_devs[MAXDEV];\n\nstatic u8 cc770_isa_mem_read_reg(const struct cc770_priv *priv, int reg)\n{\n\treturn readb(priv->reg_base + reg);\n}\n\nstatic void cc770_isa_mem_write_reg(const struct cc770_priv *priv,\n\t\t\t\t      int reg, u8 val)\n{\n\twriteb(val, priv->reg_base + reg);\n}\n\nstatic u8 cc770_isa_port_read_reg(const struct cc770_priv *priv, int reg)\n{\n\treturn inb((unsigned long)priv->reg_base + reg);\n}\n\nstatic void cc770_isa_port_write_reg(const struct cc770_priv *priv,\n\t\t\t\t       int reg, u8 val)\n{\n\toutb(val, (unsigned long)priv->reg_base + reg);\n}\n\nstatic u8 cc770_isa_port_read_reg_indirect(const struct cc770_priv *priv,\n\t\t\t\t\t     int reg)\n{\n\tunsigned long base = (unsigned long)priv->reg_base;\n\tunsigned long flags;\n\tu8 val;\n\n\tspin_lock_irqsave(&cc770_isa_port_lock, flags);\n\toutb(reg, base);\n\tval = inb(base + 1);\n\tspin_unlock_irqrestore(&cc770_isa_port_lock, flags);\n\n\treturn val;\n}\n\nstatic void cc770_isa_port_write_reg_indirect(const struct cc770_priv *priv,\n\t\t\t\t\t\tint reg, u8 val)\n{\n\tunsigned long base = (unsigned long)priv->reg_base;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cc770_isa_port_lock, flags);\n\toutb(reg, base);\n\toutb(val, base + 1);\n\tspin_unlock_irqrestore(&cc770_isa_port_lock, flags);\n}\n\nstatic int cc770_isa_probe(struct platform_device *pdev)\n{\n\tstruct net_device *dev;\n\tstruct cc770_priv *priv;\n\tvoid __iomem *base = NULL;\n\tint iosize = CC770_IOSIZE;\n\tint idx = pdev->id;\n\tint err;\n\tu32 clktmp;\n\n\tdev_dbg(&pdev->dev, \"probing idx=%d: port=%#lx, mem=%#lx, irq=%d\\n\",\n\t\tidx, port[idx], mem[idx], irq[idx]);\n\tif (mem[idx]) {\n\t\tif (!request_mem_region(mem[idx], iosize, KBUILD_MODNAME)) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto exit;\n\t\t}\n\t\tbase = ioremap(mem[idx], iosize);\n\t\tif (!base) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit_release;\n\t\t}\n\t} else {\n\t\tif (indirect[idx] > 0 ||\n\t\t    (indirect[idx] == -1 && indirect[0] > 0))\n\t\t\tiosize = CC770_IOSIZE_INDIRECT;\n\t\tif (!request_region(port[idx], iosize, KBUILD_MODNAME)) {\n\t\t\terr = -EBUSY;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tdev = alloc_cc770dev(0);\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto exit_unmap;\n\t}\n\tpriv = netdev_priv(dev);\n\n\tdev->irq = irq[idx];\n\tpriv->irq_flags = IRQF_SHARED;\n\tif (mem[idx]) {\n\t\tpriv->reg_base = base;\n\t\tdev->base_addr = mem[idx];\n\t\tpriv->read_reg = cc770_isa_mem_read_reg;\n\t\tpriv->write_reg = cc770_isa_mem_write_reg;\n\t} else {\n\t\tpriv->reg_base = (void __iomem *)port[idx];\n\t\tdev->base_addr = port[idx];\n\n\t\tif (iosize == CC770_IOSIZE_INDIRECT) {\n\t\t\tpriv->read_reg = cc770_isa_port_read_reg_indirect;\n\t\t\tpriv->write_reg = cc770_isa_port_write_reg_indirect;\n\t\t} else {\n\t\t\tpriv->read_reg = cc770_isa_port_read_reg;\n\t\t\tpriv->write_reg = cc770_isa_port_write_reg;\n\t\t}\n\t}\n\n\tif (clk[idx])\n\t\tclktmp = clk[idx];\n\telse if (clk[0])\n\t\tclktmp = clk[0];\n\telse\n\t\tclktmp = CLK_DEFAULT;\n\tpriv->can.clock.freq = clktmp;\n\n\tif (cir[idx] != 0xff) {\n\t\tpriv->cpu_interface = cir[idx];\n\t} else if (cir[0] != 0xff) {\n\t\tpriv->cpu_interface = cir[0];\n\t} else {\n\t\t \n\t\tif (clktmp > 10000000) {\n\t\t\tpriv->cpu_interface |= CPUIF_DSC;\n\t\t\tclktmp /= 2;\n\t\t}\n\t\t \n\t\tif (clktmp > 8000000)\n\t\t\tpriv->cpu_interface |= CPUIF_DMC;\n\t}\n\n\tif (priv->cpu_interface & CPUIF_DSC)\n\t\tpriv->can.clock.freq /= 2;\n\n\tif (bcr[idx] != 0xff)\n\t\tpriv->bus_config = bcr[idx];\n\telse if (bcr[0] != 0xff)\n\t\tpriv->bus_config = bcr[0];\n\telse\n\t\tpriv->bus_config = BCR_DEFAULT;\n\n\tif (cor[idx] != 0xff)\n\t\tpriv->clkout = cor[idx];\n\telse if (cor[0] != 0xff)\n\t\tpriv->clkout = cor[0];\n\telse\n\t\tpriv->clkout = COR_DEFAULT;\n\n\tplatform_set_drvdata(pdev, dev);\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\terr = register_cc770dev(dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"couldn't register device (err=%d)\\n\", err);\n\t\tgoto exit_free;\n\t}\n\n\tdev_info(&pdev->dev, \"device registered (reg_base=0x%p, irq=%d)\\n\",\n\t\t priv->reg_base, dev->irq);\n\treturn 0;\n\nexit_free:\n\tfree_cc770dev(dev);\nexit_unmap:\n\tif (mem[idx])\n\t\tiounmap(base);\nexit_release:\n\tif (mem[idx])\n\t\trelease_mem_region(mem[idx], iosize);\n\telse\n\t\trelease_region(port[idx], iosize);\nexit:\n\treturn err;\n}\n\nstatic void cc770_isa_remove(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\tstruct cc770_priv *priv = netdev_priv(dev);\n\tint idx = pdev->id;\n\n\tunregister_cc770dev(dev);\n\n\tif (mem[idx]) {\n\t\tiounmap(priv->reg_base);\n\t\trelease_mem_region(mem[idx], CC770_IOSIZE);\n\t} else {\n\t\tif (priv->read_reg == cc770_isa_port_read_reg_indirect)\n\t\t\trelease_region(port[idx], CC770_IOSIZE_INDIRECT);\n\t\telse\n\t\t\trelease_region(port[idx], CC770_IOSIZE);\n\t}\n\tfree_cc770dev(dev);\n}\n\nstatic struct platform_driver cc770_isa_driver = {\n\t.probe = cc770_isa_probe,\n\t.remove_new = cc770_isa_remove,\n\t.driver = {\n\t\t.name = KBUILD_MODNAME,\n\t},\n};\n\nstatic int __init cc770_isa_init(void)\n{\n\tint idx, err;\n\n\tfor (idx = 0; idx < ARRAY_SIZE(cc770_isa_devs); idx++) {\n\t\tif ((port[idx] || mem[idx]) && irq[idx]) {\n\t\t\tcc770_isa_devs[idx] =\n\t\t\t\tplatform_device_alloc(KBUILD_MODNAME, idx);\n\t\t\tif (!cc770_isa_devs[idx]) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto exit_free_devices;\n\t\t\t}\n\t\t\terr = platform_device_add(cc770_isa_devs[idx]);\n\t\t\tif (err) {\n\t\t\t\tplatform_device_put(cc770_isa_devs[idx]);\n\t\t\t\tgoto exit_free_devices;\n\t\t\t}\n\t\t\tpr_debug(\"platform device %d: port=%#lx, mem=%#lx, \"\n\t\t\t\t \"irq=%d\\n\",\n\t\t\t\t idx, port[idx], mem[idx], irq[idx]);\n\t\t} else if (idx == 0 || port[idx] || mem[idx]) {\n\t\t\tpr_err(\"insufficient parameters supplied\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit_free_devices;\n\t\t}\n\t}\n\n\terr = platform_driver_register(&cc770_isa_driver);\n\tif (err)\n\t\tgoto exit_free_devices;\n\n\tpr_info(\"driver for max. %d devices registered\\n\", MAXDEV);\n\n\treturn 0;\n\nexit_free_devices:\n\twhile (--idx >= 0) {\n\t\tif (cc770_isa_devs[idx])\n\t\t\tplatform_device_unregister(cc770_isa_devs[idx]);\n\t}\n\n\treturn err;\n}\nmodule_init(cc770_isa_init);\n\nstatic void __exit cc770_isa_exit(void)\n{\n\tint idx;\n\n\tplatform_driver_unregister(&cc770_isa_driver);\n\tfor (idx = 0; idx < ARRAY_SIZE(cc770_isa_devs); idx++) {\n\t\tif (cc770_isa_devs[idx])\n\t\t\tplatform_device_unregister(cc770_isa_devs[idx]);\n\t}\n}\nmodule_exit(cc770_isa_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}