{
  "module_name": "cc770_platform.c",
  "hash_id": "a07fde5f39c653197dfb6f42fa904353da71a20e7104715e89c2177493ec2bad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/cc770/cc770_platform.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/netdevice.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/platform/cc770.h>\n\n#include \"cc770.h\"\n\n#define DRV_NAME \"cc770_platform\"\n\nMODULE_AUTHOR(\"Wolfgang Grandegger <wg@grandegger.com>\");\nMODULE_DESCRIPTION(\"Socket-CAN driver for CC770 on the platform bus\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n\n#define CC770_PLATFORM_CAN_CLOCK  16000000\n\nstatic u8 cc770_platform_read_reg(const struct cc770_priv *priv, int reg)\n{\n\treturn ioread8(priv->reg_base + reg);\n}\n\nstatic void cc770_platform_write_reg(const struct cc770_priv *priv, int reg,\n\t\t\t\t     u8 val)\n{\n\tiowrite8(val, priv->reg_base + reg);\n}\n\nstatic int cc770_get_of_node_data(struct platform_device *pdev,\n\t\t\t\t  struct cc770_priv *priv)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst u32 *prop;\n\tint prop_size;\n\tu32 clkext;\n\n\tprop = of_get_property(np, \"bosch,external-clock-frequency\",\n\t\t\t       &prop_size);\n\tif (prop && (prop_size ==  sizeof(u32)))\n\t\tclkext = *prop;\n\telse\n\t\tclkext = CC770_PLATFORM_CAN_CLOCK;  \n\tpriv->can.clock.freq = clkext;\n\n\t \n\tif (priv->can.clock.freq > 10000000) {\n\t\tpriv->cpu_interface |= CPUIF_DSC;\n\t\tpriv->can.clock.freq /= 2;\n\t}\n\n\t \n\tif (priv->can.clock.freq > 8000000)\n\t\tpriv->cpu_interface |= CPUIF_DMC;\n\n\tif (of_property_read_bool(np, \"bosch,divide-memory-clock\"))\n\t\tpriv->cpu_interface |= CPUIF_DMC;\n\tif (of_property_read_bool(np, \"bosch,iso-low-speed-mux\"))\n\t\tpriv->cpu_interface |= CPUIF_MUX;\n\n\tif (!of_get_property(np, \"bosch,no-comperator-bypass\", NULL))\n\t\tpriv->bus_config |= BUSCFG_CBY;\n\tif (of_property_read_bool(np, \"bosch,disconnect-rx0-input\"))\n\t\tpriv->bus_config |= BUSCFG_DR0;\n\tif (of_property_read_bool(np, \"bosch,disconnect-rx1-input\"))\n\t\tpriv->bus_config |= BUSCFG_DR1;\n\tif (of_property_read_bool(np, \"bosch,disconnect-tx1-output\"))\n\t\tpriv->bus_config |= BUSCFG_DT1;\n\tif (of_property_read_bool(np, \"bosch,polarity-dominant\"))\n\t\tpriv->bus_config |= BUSCFG_POL;\n\n\tprop = of_get_property(np, \"bosch,clock-out-frequency\", &prop_size);\n\tif (prop && (prop_size == sizeof(u32)) && *prop > 0) {\n\t\tu32 cdv = clkext / *prop;\n\t\tint slew;\n\n\t\tif (cdv > 0 && cdv < 16) {\n\t\t\tpriv->cpu_interface |= CPUIF_CEN;\n\t\t\tpriv->clkout |= (cdv - 1) & CLKOUT_CD_MASK;\n\n\t\t\tprop = of_get_property(np, \"bosch,slew-rate\",\n\t\t\t\t\t       &prop_size);\n\t\t\tif (prop && (prop_size == sizeof(u32))) {\n\t\t\t\tslew = *prop;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tslew = (CLKOUT_SL_MASK >>\n\t\t\t\t\tCLKOUT_SL_SHIFT) -\n\t\t\t\t\t((cdv * clkext - 1) / 8000000);\n\t\t\t\tif (slew < 0)\n\t\t\t\t\tslew = 0;\n\t\t\t}\n\t\t\tpriv->clkout |= (slew << CLKOUT_SL_SHIFT) &\n\t\t\t\tCLKOUT_SL_MASK;\n\t\t} else {\n\t\t\tdev_dbg(&pdev->dev, \"invalid clock-out-frequency\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int cc770_get_platform_data(struct platform_device *pdev,\n\t\t\t\t   struct cc770_priv *priv)\n{\n\n\tstruct cc770_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\n\tpriv->can.clock.freq = pdata->osc_freq;\n\tif (priv->cpu_interface & CPUIF_DSC)\n\t\tpriv->can.clock.freq /= 2;\n\tpriv->clkout = pdata->cor;\n\tpriv->bus_config = pdata->bcr;\n\tpriv->cpu_interface = pdata->cir;\n\n\treturn 0;\n}\n\nstatic int cc770_platform_probe(struct platform_device *pdev)\n{\n\tstruct net_device *dev;\n\tstruct cc770_priv *priv;\n\tstruct resource *mem;\n\tresource_size_t mem_size;\n\tvoid __iomem *base;\n\tint err, irq;\n\n\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tirq = platform_get_irq(pdev, 0);\n\tif (!mem || irq <= 0)\n\t\treturn -ENODEV;\n\n\tmem_size = resource_size(mem);\n\tif (!request_mem_region(mem->start, mem_size, pdev->name))\n\t\treturn -EBUSY;\n\n\tbase = ioremap(mem->start, mem_size);\n\tif (!base) {\n\t\terr = -ENOMEM;\n\t\tgoto exit_release_mem;\n\t}\n\n\tdev = alloc_cc770dev(0);\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto exit_unmap_mem;\n\t}\n\n\tdev->irq = irq;\n\tpriv = netdev_priv(dev);\n\tpriv->read_reg = cc770_platform_read_reg;\n\tpriv->write_reg = cc770_platform_write_reg;\n\tpriv->irq_flags = IRQF_SHARED;\n\tpriv->reg_base = base;\n\n\tif (pdev->dev.of_node)\n\t\terr = cc770_get_of_node_data(pdev, priv);\n\telse if (dev_get_platdata(&pdev->dev))\n\t\terr = cc770_get_platform_data(pdev, priv);\n\telse\n\t\terr = -ENODEV;\n\tif (err)\n\t\tgoto exit_free_cc770;\n\n\tdev_dbg(&pdev->dev,\n\t\t \"reg_base=0x%p irq=%d clock=%d cpu_interface=0x%02x \"\n\t\t \"bus_config=0x%02x clkout=0x%02x\\n\",\n\t\t priv->reg_base, dev->irq, priv->can.clock.freq,\n\t\t priv->cpu_interface, priv->bus_config, priv->clkout);\n\n\tplatform_set_drvdata(pdev, dev);\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\terr = register_cc770dev(dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"couldn't register CC700 device (err=%d)\\n\", err);\n\t\tgoto exit_free_cc770;\n\t}\n\n\treturn 0;\n\nexit_free_cc770:\n\tfree_cc770dev(dev);\nexit_unmap_mem:\n\tiounmap(base);\nexit_release_mem:\n\trelease_mem_region(mem->start, mem_size);\n\n\treturn err;\n}\n\nstatic void cc770_platform_remove(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\tstruct cc770_priv *priv = netdev_priv(dev);\n\tstruct resource *mem;\n\n\tunregister_cc770dev(dev);\n\tiounmap(priv->reg_base);\n\tfree_cc770dev(dev);\n\n\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\trelease_mem_region(mem->start, resource_size(mem));\n}\n\nstatic const struct of_device_id cc770_platform_table[] = {\n\t{.compatible = \"bosch,cc770\"},  \n\t{.compatible = \"intc,82527\"},   \n\t{},\n};\nMODULE_DEVICE_TABLE(of, cc770_platform_table);\n\nstatic struct platform_driver cc770_platform_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.of_match_table = cc770_platform_table,\n\t},\n\t.probe = cc770_platform_probe,\n\t.remove_new = cc770_platform_remove,\n};\n\nmodule_platform_driver(cc770_platform_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}