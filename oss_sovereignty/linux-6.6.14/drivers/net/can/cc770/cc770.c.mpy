{
  "module_name": "cc770.c",
  "hash_id": "796a0ed7d63f5516af9bfdb0bac52851a2c653ad0a5c5358cba13373f16fb32c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/cc770/cc770.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/ptrace.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/ethtool.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n#include <linux/can/platform/cc770.h>\n\n#include \"cc770.h\"\n\nMODULE_AUTHOR(\"Wolfgang Grandegger <wg@grandegger.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(KBUILD_MODNAME \"CAN netdevice driver\");\n\n \nstatic int msgobj15_eff;\nmodule_param(msgobj15_eff, int, 0444);\nMODULE_PARM_DESC(msgobj15_eff, \"Extended 29-bit frames for message object 15 \"\n\t\t \"(default: 11-bit standard frames)\");\n\nstatic int i82527_compat;\nmodule_param(i82527_compat, int, 0444);\nMODULE_PARM_DESC(i82527_compat, \"Strict Intel 82527 compatibility mode \"\n\t\t \"without using additional functions\");\n\n \nstatic unsigned char cc770_obj_flags[CC770_OBJ_MAX] = {\n\t[CC770_OBJ_RX0] = CC770_OBJ_FLAG_RX,\n\t[CC770_OBJ_RX1] = CC770_OBJ_FLAG_RX | CC770_OBJ_FLAG_EFF,\n\t[CC770_OBJ_RX_RTR0] = CC770_OBJ_FLAG_RX | CC770_OBJ_FLAG_RTR,\n\t[CC770_OBJ_RX_RTR1] = CC770_OBJ_FLAG_RX | CC770_OBJ_FLAG_RTR |\n\t\t\t      CC770_OBJ_FLAG_EFF,\n\t[CC770_OBJ_TX] = 0,\n};\n\nstatic const struct can_bittiming_const cc770_bittiming_const = {\n\t.name = KBUILD_MODNAME,\n\t.tseg1_min = 1,\n\t.tseg1_max = 16,\n\t.tseg2_min = 1,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 64,\n\t.brp_inc = 1,\n};\n\nstatic inline int intid2obj(unsigned int intid)\n{\n\tif (intid == 2)\n\t\treturn 0;\n\telse\n\t\treturn MSGOBJ_LAST + 2 - intid;\n}\n\nstatic void enable_all_objs(const struct net_device *dev)\n{\n\tstruct cc770_priv *priv = netdev_priv(dev);\n\tu8 msgcfg;\n\tunsigned char obj_flags;\n\tunsigned int o, mo;\n\n\tfor (o = 0; o < ARRAY_SIZE(priv->obj_flags); o++) {\n\t\tobj_flags = priv->obj_flags[o];\n\t\tmo = obj2msgobj(o);\n\n\t\tif (obj_flags & CC770_OBJ_FLAG_RX) {\n\t\t\t \n\t\t\tif (priv->control_normal_mode & CTRL_EAF) {\n\t\t\t\tif (o > 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tnetdev_dbg(dev, \"Message object %d for \"\n\t\t\t\t\t   \"RX data, RTR, SFF and EFF\\n\", mo);\n\t\t\t} else {\n\t\t\t\tnetdev_dbg(dev,\n\t\t\t\t\t   \"Message object %d for RX %s %s\\n\",\n\t\t\t\t\t   mo, obj_flags & CC770_OBJ_FLAG_RTR ?\n\t\t\t\t\t   \"RTR\" : \"data\",\n\t\t\t\t\t   obj_flags & CC770_OBJ_FLAG_EFF ?\n\t\t\t\t\t   \"EFF\" : \"SFF\");\n\t\t\t}\n\n\t\t\tif (obj_flags & CC770_OBJ_FLAG_EFF)\n\t\t\t\tmsgcfg = MSGCFG_XTD;\n\t\t\telse\n\t\t\t\tmsgcfg = 0;\n\t\t\tif (obj_flags & CC770_OBJ_FLAG_RTR)\n\t\t\t\tmsgcfg |= MSGCFG_DIR;\n\n\t\t\tcc770_write_reg(priv, msgobj[mo].config, msgcfg);\n\t\t\tcc770_write_reg(priv, msgobj[mo].ctrl0,\n\t\t\t\t\tMSGVAL_SET | TXIE_RES |\n\t\t\t\t\tRXIE_SET | INTPND_RES);\n\n\t\t\tif (obj_flags & CC770_OBJ_FLAG_RTR)\n\t\t\t\tcc770_write_reg(priv, msgobj[mo].ctrl1,\n\t\t\t\t\t\tNEWDAT_RES | CPUUPD_SET |\n\t\t\t\t\t\tTXRQST_RES | RMTPND_RES);\n\t\t\telse\n\t\t\t\tcc770_write_reg(priv, msgobj[mo].ctrl1,\n\t\t\t\t\t\tNEWDAT_RES | MSGLST_RES |\n\t\t\t\t\t\tTXRQST_RES | RMTPND_RES);\n\t\t} else {\n\t\t\tnetdev_dbg(dev, \"Message object %d for \"\n\t\t\t\t   \"TX data, RTR, SFF and EFF\\n\", mo);\n\n\t\t\tcc770_write_reg(priv, msgobj[mo].ctrl1,\n\t\t\t\t\tRMTPND_RES | TXRQST_RES |\n\t\t\t\t\tCPUUPD_RES | NEWDAT_RES);\n\t\t\tcc770_write_reg(priv, msgobj[mo].ctrl0,\n\t\t\t\t\tMSGVAL_RES | TXIE_RES |\n\t\t\t\t\tRXIE_RES | INTPND_RES);\n\t\t}\n\t}\n}\n\nstatic void disable_all_objs(const struct cc770_priv *priv)\n{\n\tint o, mo;\n\n\tfor (o = 0; o <  ARRAY_SIZE(priv->obj_flags); o++) {\n\t\tmo = obj2msgobj(o);\n\n\t\tif (priv->obj_flags[o] & CC770_OBJ_FLAG_RX) {\n\t\t\tif (o > 0 && priv->control_normal_mode & CTRL_EAF)\n\t\t\t\tcontinue;\n\n\t\t\tcc770_write_reg(priv, msgobj[mo].ctrl1,\n\t\t\t\t\tNEWDAT_RES | MSGLST_RES |\n\t\t\t\t\tTXRQST_RES | RMTPND_RES);\n\t\t\tcc770_write_reg(priv, msgobj[mo].ctrl0,\n\t\t\t\t\tMSGVAL_RES | TXIE_RES |\n\t\t\t\t\tRXIE_RES | INTPND_RES);\n\t\t} else {\n\t\t\t \n\t\t\tcc770_write_reg(priv, msgobj[mo].ctrl1,\n\t\t\t\t\tRMTPND_RES | TXRQST_RES |\n\t\t\t\t\tCPUUPD_RES | NEWDAT_RES);\n\t\t\tcc770_write_reg(priv, msgobj[mo].ctrl0,\n\t\t\t\t\tMSGVAL_RES | TXIE_RES |\n\t\t\t\t\tRXIE_RES | INTPND_RES);\n\t\t}\n\t}\n}\n\nstatic void set_reset_mode(struct net_device *dev)\n{\n\tstruct cc770_priv *priv = netdev_priv(dev);\n\n\t \n\tcc770_write_reg(priv, control, CTRL_CCE | CTRL_INI);\n\n\tpriv->can.state = CAN_STATE_STOPPED;\n\n\t \n\tcc770_read_reg(priv, interrupt);\n\n\t \n\tcc770_write_reg(priv, status, 0);\n\n\t \n\tdisable_all_objs(priv);\n}\n\nstatic void set_normal_mode(struct net_device *dev)\n{\n\tstruct cc770_priv *priv = netdev_priv(dev);\n\n\t \n\tcc770_read_reg(priv, interrupt);\n\n\t \n\tcc770_write_reg(priv, status, STAT_LEC_MASK);\n\n\t \n\tenable_all_objs(dev);\n\n\t \n\tcc770_write_reg(priv, control, priv->control_normal_mode);\n\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n}\n\nstatic void chipset_init(struct cc770_priv *priv)\n{\n\tint mo, id, data;\n\n\t \n\tcc770_write_reg(priv, control, (CTRL_CCE | CTRL_INI));\n\n\t \n\tcc770_write_reg(priv, clkout, priv->clkout);\n\n\t \n\tcc770_write_reg(priv, cpu_interface, priv->cpu_interface);\n\n\t \n\tcc770_write_reg(priv, bus_config, priv->bus_config);\n\n\t \n\tcc770_read_reg(priv, interrupt);\n\n\t \n\tcc770_write_reg(priv, status, 0);\n\n\t \n\tfor (mo = MSGOBJ_FIRST; mo <= MSGOBJ_LAST; mo++) {\n\t\tcc770_write_reg(priv, msgobj[mo].ctrl0,\n\t\t\t\tINTPND_UNC | RXIE_RES |\n\t\t\t\tTXIE_RES | MSGVAL_RES);\n\t\tcc770_write_reg(priv, msgobj[mo].ctrl0,\n\t\t\t\tINTPND_RES | RXIE_RES |\n\t\t\t\tTXIE_RES | MSGVAL_RES);\n\t\tcc770_write_reg(priv, msgobj[mo].ctrl1,\n\t\t\t\tNEWDAT_RES | MSGLST_RES |\n\t\t\t\tTXRQST_RES | RMTPND_RES);\n\t\tfor (data = 0; data < 8; data++)\n\t\t\tcc770_write_reg(priv, msgobj[mo].data[data], 0);\n\t\tfor (id = 0; id < 4; id++)\n\t\t\tcc770_write_reg(priv, msgobj[mo].id[id], 0);\n\t\tcc770_write_reg(priv, msgobj[mo].config, 0);\n\t}\n\n\t \n\tcc770_write_reg(priv, global_mask_std[0], 0);\n\tcc770_write_reg(priv, global_mask_std[1], 0);\n\tcc770_write_reg(priv, global_mask_ext[0], 0);\n\tcc770_write_reg(priv, global_mask_ext[1], 0);\n\tcc770_write_reg(priv, global_mask_ext[2], 0);\n\tcc770_write_reg(priv, global_mask_ext[3], 0);\n\n}\n\nstatic int cc770_probe_chip(struct net_device *dev)\n{\n\tstruct cc770_priv *priv = netdev_priv(dev);\n\n\t \n\tcc770_write_reg(priv, control, CTRL_CCE | CTRL_EAF | CTRL_INI);\n\t \n\tcc770_write_reg(priv, cpu_interface, priv->cpu_interface);\n\n\t \n\tif (cc770_read_reg(priv, cpu_interface) & CPUIF_RST) {\n\t\tnetdev_info(dev, \"probing @0x%p failed (reset)\\n\",\n\t\t\t    priv->reg_base);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tcc770_write_reg(priv, msgobj[1].data[1], 0x25);\n\tcc770_write_reg(priv, msgobj[2].data[3], 0x52);\n\tcc770_write_reg(priv, msgobj[10].data[6], 0xc3);\n\tif ((cc770_read_reg(priv, msgobj[1].data[1]) != 0x25) ||\n\t    (cc770_read_reg(priv, msgobj[2].data[3]) != 0x52) ||\n\t    (cc770_read_reg(priv, msgobj[10].data[6]) != 0xc3)) {\n\t\tnetdev_info(dev, \"probing @0x%p failed (pattern)\\n\",\n\t\t\t    priv->reg_base);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (cc770_read_reg(priv, control) & CTRL_EAF)\n\t\tpriv->control_normal_mode |= CTRL_EAF;\n\n\treturn 0;\n}\n\nstatic void cc770_start(struct net_device *dev)\n{\n\tstruct cc770_priv *priv = netdev_priv(dev);\n\n\t \n\tif (priv->can.state != CAN_STATE_STOPPED)\n\t\tset_reset_mode(dev);\n\n\t \n\tset_normal_mode(dev);\n}\n\nstatic int cc770_set_mode(struct net_device *dev, enum can_mode mode)\n{\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\tcc770_start(dev);\n\t\tnetif_wake_queue(dev);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int cc770_set_bittiming(struct net_device *dev)\n{\n\tstruct cc770_priv *priv = netdev_priv(dev);\n\tstruct can_bittiming *bt = &priv->can.bittiming;\n\tu8 btr0, btr1;\n\n\tbtr0 = ((bt->brp - 1) & 0x3f) | (((bt->sjw - 1) & 0x3) << 6);\n\tbtr1 = ((bt->prop_seg + bt->phase_seg1 - 1) & 0xf) |\n\t\t(((bt->phase_seg2 - 1) & 0x7) << 4);\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\n\t\tbtr1 |= 0x80;\n\n\tnetdev_info(dev, \"setting BTR0=0x%02x BTR1=0x%02x\\n\", btr0, btr1);\n\n\tcc770_write_reg(priv, bit_timing_0, btr0);\n\tcc770_write_reg(priv, bit_timing_1, btr1);\n\n\treturn 0;\n}\n\nstatic int cc770_get_berr_counter(const struct net_device *dev,\n\t\t\t\t  struct can_berr_counter *bec)\n{\n\tstruct cc770_priv *priv = netdev_priv(dev);\n\n\tbec->txerr = cc770_read_reg(priv, tx_error_counter);\n\tbec->rxerr = cc770_read_reg(priv, rx_error_counter);\n\n\treturn 0;\n}\n\nstatic void cc770_tx(struct net_device *dev, int mo)\n{\n\tstruct cc770_priv *priv = netdev_priv(dev);\n\tstruct can_frame *cf = (struct can_frame *)priv->tx_skb->data;\n\tu8 dlc, rtr;\n\tu32 id;\n\tint i;\n\n\tdlc = cf->len;\n\tid = cf->can_id;\n\trtr = cf->can_id & CAN_RTR_FLAG ? 0 : MSGCFG_DIR;\n\n\tcc770_write_reg(priv, msgobj[mo].ctrl0,\n\t\t\tMSGVAL_RES | TXIE_RES | RXIE_RES | INTPND_RES);\n\tcc770_write_reg(priv, msgobj[mo].ctrl1,\n\t\t\tRMTPND_RES | TXRQST_RES | CPUUPD_SET | NEWDAT_RES);\n\n\tif (id & CAN_EFF_FLAG) {\n\t\tid &= CAN_EFF_MASK;\n\t\tcc770_write_reg(priv, msgobj[mo].config,\n\t\t\t\t(dlc << 4) | rtr | MSGCFG_XTD);\n\t\tcc770_write_reg(priv, msgobj[mo].id[3], id << 3);\n\t\tcc770_write_reg(priv, msgobj[mo].id[2], id >> 5);\n\t\tcc770_write_reg(priv, msgobj[mo].id[1], id >> 13);\n\t\tcc770_write_reg(priv, msgobj[mo].id[0], id >> 21);\n\t} else {\n\t\tid &= CAN_SFF_MASK;\n\t\tcc770_write_reg(priv, msgobj[mo].config, (dlc << 4) | rtr);\n\t\tcc770_write_reg(priv, msgobj[mo].id[0], id >> 3);\n\t\tcc770_write_reg(priv, msgobj[mo].id[1], id << 5);\n\t}\n\n\tfor (i = 0; i < dlc; i++)\n\t\tcc770_write_reg(priv, msgobj[mo].data[i], cf->data[i]);\n\n\tcc770_write_reg(priv, msgobj[mo].ctrl1,\n\t\t\tRMTPND_UNC | TXRQST_SET | CPUUPD_RES | NEWDAT_UNC);\n\tcc770_write_reg(priv, msgobj[mo].ctrl0,\n\t\t\tMSGVAL_SET | TXIE_SET | RXIE_SET | INTPND_UNC);\n}\n\nstatic netdev_tx_t cc770_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct cc770_priv *priv = netdev_priv(dev);\n\tunsigned int mo = obj2msgobj(CC770_OBJ_TX);\n\n\tif (can_dev_dropped_skb(dev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tnetif_stop_queue(dev);\n\n\tif ((cc770_read_reg(priv,\n\t\t\t    msgobj[mo].ctrl1) & TXRQST_UNC) == TXRQST_SET) {\n\t\tnetdev_err(dev, \"TX register is still occupied!\\n\");\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tpriv->tx_skb = skb;\n\tcc770_tx(dev, mo);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void cc770_rx(struct net_device *dev, unsigned int mo, u8 ctrl1)\n{\n\tstruct cc770_priv *priv = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tu8 config;\n\tu32 id;\n\tint i;\n\n\tskb = alloc_can_skb(dev, &cf);\n\tif (!skb)\n\t\treturn;\n\n\tconfig = cc770_read_reg(priv, msgobj[mo].config);\n\n\tif (ctrl1 & RMTPND_SET) {\n\t\t \n\t\tcf->can_id = CAN_RTR_FLAG;\n\t\tif (config & MSGCFG_XTD)\n\t\t\tcf->can_id |= CAN_EFF_FLAG;\n\t\tcf->len = 0;\n\t} else {\n\t\tif (config & MSGCFG_XTD) {\n\t\t\tid = cc770_read_reg(priv, msgobj[mo].id[3]);\n\t\t\tid |= cc770_read_reg(priv, msgobj[mo].id[2]) << 8;\n\t\t\tid |= cc770_read_reg(priv, msgobj[mo].id[1]) << 16;\n\t\t\tid |= cc770_read_reg(priv, msgobj[mo].id[0]) << 24;\n\t\t\tid >>= 3;\n\t\t\tid |= CAN_EFF_FLAG;\n\t\t} else {\n\t\t\tid = cc770_read_reg(priv, msgobj[mo].id[1]);\n\t\t\tid |= cc770_read_reg(priv, msgobj[mo].id[0]) << 8;\n\t\t\tid >>= 5;\n\t\t}\n\n\t\tcf->can_id = id;\n\t\tcf->len = can_cc_dlc2len((config & 0xf0) >> 4);\n\t\tfor (i = 0; i < cf->len; i++)\n\t\t\tcf->data[i] = cc770_read_reg(priv, msgobj[mo].data[i]);\n\n\t\tstats->rx_bytes += cf->len;\n\t}\n\tstats->rx_packets++;\n\n\tnetif_rx(skb);\n}\n\nstatic int cc770_err(struct net_device *dev, u8 status)\n{\n\tstruct cc770_priv *priv = netdev_priv(dev);\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tu8 lec;\n\n\tnetdev_dbg(dev, \"status interrupt (%#x)\\n\", status);\n\n\tskb = alloc_can_err_skb(dev, &cf);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\t \n\tif (priv->control_normal_mode & CTRL_EAF) {\n\t\tcf->can_id |= CAN_ERR_CNT;\n\t\tcf->data[6] = cc770_read_reg(priv, tx_error_counter);\n\t\tcf->data[7] = cc770_read_reg(priv, rx_error_counter);\n\t}\n\n\tif (status & STAT_BOFF) {\n\t\t \n\t\tcc770_write_reg(priv, control, CTRL_INI);\n\t\tcf->can_id |= CAN_ERR_BUSOFF;\n\t\tpriv->can.state = CAN_STATE_BUS_OFF;\n\t\tpriv->can.can_stats.bus_off++;\n\t\tcan_bus_off(dev);\n\t} else if (status & STAT_WARN) {\n\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\t \n\t\tif (cf->data[7] > 127) {\n\t\t\tcf->data[1] = CAN_ERR_CRTL_RX_PASSIVE |\n\t\t\t\tCAN_ERR_CRTL_TX_PASSIVE;\n\t\t\tpriv->can.state = CAN_STATE_ERROR_PASSIVE;\n\t\t\tpriv->can.can_stats.error_passive++;\n\t\t} else {\n\t\t\tcf->data[1] = CAN_ERR_CRTL_RX_WARNING |\n\t\t\t\tCAN_ERR_CRTL_TX_WARNING;\n\t\t\tpriv->can.state = CAN_STATE_ERROR_WARNING;\n\t\t\tpriv->can.can_stats.error_warning++;\n\t\t}\n\t} else {\n\t\t \n\t\tcf->can_id |= CAN_ERR_PROT;\n\t\tcf->data[2] = CAN_ERR_PROT_ACTIVE;\n\t\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\t}\n\n\tlec = status & STAT_LEC_MASK;\n\tif (lec < 7 && lec > 0) {\n\t\tif (lec == STAT_LEC_ACK) {\n\t\t\tcf->can_id |= CAN_ERR_ACK;\n\t\t} else {\n\t\t\tcf->can_id |= CAN_ERR_PROT;\n\t\t\tswitch (lec) {\n\t\t\tcase STAT_LEC_STUFF:\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_STUFF;\n\t\t\t\tbreak;\n\t\t\tcase STAT_LEC_FORM:\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_FORM;\n\t\t\t\tbreak;\n\t\t\tcase STAT_LEC_BIT1:\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT1;\n\t\t\t\tbreak;\n\t\t\tcase STAT_LEC_BIT0:\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT0;\n\t\t\t\tbreak;\n\t\t\tcase STAT_LEC_CRC:\n\t\t\t\tcf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tnetif_rx(skb);\n\n\treturn 0;\n}\n\nstatic int cc770_status_interrupt(struct net_device *dev)\n{\n\tstruct cc770_priv *priv = netdev_priv(dev);\n\tu8 status;\n\n\tstatus = cc770_read_reg(priv, status);\n\t \n\tcc770_write_reg(priv, status, STAT_LEC_MASK);\n\n\tif (status & (STAT_WARN | STAT_BOFF) ||\n\t    (status & STAT_LEC_MASK) != STAT_LEC_MASK) {\n\t\tcc770_err(dev, status);\n\t\treturn status & STAT_BOFF;\n\t}\n\n\treturn 0;\n}\n\nstatic void cc770_rx_interrupt(struct net_device *dev, unsigned int o)\n{\n\tstruct cc770_priv *priv = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tunsigned int mo = obj2msgobj(o);\n\tu8 ctrl1;\n\tint n = CC770_MAX_MSG;\n\n\twhile (n--) {\n\t\tctrl1 = cc770_read_reg(priv, msgobj[mo].ctrl1);\n\n\t\tif (!(ctrl1 & NEWDAT_SET))  {\n\t\t\t \n\t\t\tif (priv->control_normal_mode & CTRL_EAF) {\n\t\t\t\tif (!(cc770_read_reg(priv, msgobj[mo].ctrl0) &\n\t\t\t\t      INTPND_SET))\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ctrl1 & MSGLST_SET) {\n\t\t\tstats->rx_over_errors++;\n\t\t\tstats->rx_errors++;\n\t\t}\n\t\tif (mo < MSGOBJ_LAST)\n\t\t\tcc770_write_reg(priv, msgobj[mo].ctrl1,\n\t\t\t\t\tNEWDAT_RES | MSGLST_RES |\n\t\t\t\t\tTXRQST_UNC | RMTPND_UNC);\n\t\tcc770_rx(dev, mo, ctrl1);\n\n\t\tcc770_write_reg(priv, msgobj[mo].ctrl0,\n\t\t\t\tMSGVAL_SET | TXIE_RES |\n\t\t\t\tRXIE_SET | INTPND_RES);\n\t\tcc770_write_reg(priv, msgobj[mo].ctrl1,\n\t\t\t\tNEWDAT_RES | MSGLST_RES |\n\t\t\t\tTXRQST_RES | RMTPND_RES);\n\t}\n}\n\nstatic void cc770_rtr_interrupt(struct net_device *dev, unsigned int o)\n{\n\tstruct cc770_priv *priv = netdev_priv(dev);\n\tunsigned int mo = obj2msgobj(o);\n\tu8 ctrl0, ctrl1;\n\tint n = CC770_MAX_MSG;\n\n\twhile (n--) {\n\t\tctrl0 = cc770_read_reg(priv, msgobj[mo].ctrl0);\n\t\tif (!(ctrl0 & INTPND_SET))\n\t\t\tbreak;\n\n\t\tctrl1 = cc770_read_reg(priv, msgobj[mo].ctrl1);\n\t\tcc770_rx(dev, mo, ctrl1);\n\n\t\tcc770_write_reg(priv, msgobj[mo].ctrl0,\n\t\t\t\tMSGVAL_SET | TXIE_RES |\n\t\t\t\tRXIE_SET | INTPND_RES);\n\t\tcc770_write_reg(priv, msgobj[mo].ctrl1,\n\t\t\t\tNEWDAT_RES | CPUUPD_SET |\n\t\t\t\tTXRQST_RES | RMTPND_RES);\n\t}\n}\n\nstatic void cc770_tx_interrupt(struct net_device *dev, unsigned int o)\n{\n\tstruct cc770_priv *priv = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tunsigned int mo = obj2msgobj(o);\n\tu8 ctrl1;\n\n\tctrl1 = cc770_read_reg(priv, msgobj[mo].ctrl1);\n\n\tcc770_write_reg(priv, msgobj[mo].ctrl0,\n\t\t\tMSGVAL_RES | TXIE_RES | RXIE_RES | INTPND_RES);\n\tcc770_write_reg(priv, msgobj[mo].ctrl1,\n\t\t\tRMTPND_RES | TXRQST_RES | MSGLST_RES | NEWDAT_RES);\n\n\tif (unlikely(!priv->tx_skb)) {\n\t\tnetdev_err(dev, \"missing tx skb in tx interrupt\\n\");\n\t\treturn;\n\t}\n\n\tif (unlikely(ctrl1 & MSGLST_SET)) {\n\t\tstats->rx_over_errors++;\n\t\tstats->rx_errors++;\n\t}\n\n\t \n\tif (unlikely(ctrl1 & NEWDAT_SET)) {\n\t\tcc770_rx(dev, mo, ctrl1);\n\t\tcc770_tx(dev, mo);\n\t\treturn;\n\t}\n\n\tcan_put_echo_skb(priv->tx_skb, dev, 0, 0);\n\tstats->tx_bytes += can_get_echo_skb(dev, 0, NULL);\n\tstats->tx_packets++;\n\tpriv->tx_skb = NULL;\n\n\tnetif_wake_queue(dev);\n}\n\nstatic irqreturn_t cc770_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = (struct net_device *)dev_id;\n\tstruct cc770_priv *priv = netdev_priv(dev);\n\tu8 intid;\n\tint o, n = 0;\n\n\t \n\tif (priv->can.state == CAN_STATE_STOPPED)\n\t\treturn IRQ_NONE;\n\n\tif (priv->pre_irq)\n\t\tpriv->pre_irq(priv);\n\n\twhile (n < CC770_MAX_IRQ) {\n\t\t \n\t\tintid = cc770_read_reg(priv, interrupt);\n\t\tif (!intid)\n\t\t\tbreak;\n\t\tn++;\n\n\t\tif (intid == 1) {\n\t\t\t \n\t\t\tif (cc770_status_interrupt(dev))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\to = intid2obj(intid);\n\n\t\t\tif (o >= CC770_OBJ_MAX) {\n\t\t\t\tnetdev_err(dev, \"Unexpected interrupt id %d\\n\",\n\t\t\t\t\t   intid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (priv->obj_flags[o] & CC770_OBJ_FLAG_RTR)\n\t\t\t\tcc770_rtr_interrupt(dev, o);\n\t\t\telse if (priv->obj_flags[o] & CC770_OBJ_FLAG_RX)\n\t\t\t\tcc770_rx_interrupt(dev, o);\n\t\t\telse\n\t\t\t\tcc770_tx_interrupt(dev, o);\n\t\t}\n\t}\n\n\tif (priv->post_irq)\n\t\tpriv->post_irq(priv);\n\n\tif (n >= CC770_MAX_IRQ)\n\t\tnetdev_dbg(dev, \"%d messages handled in ISR\", n);\n\n\treturn (n) ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic int cc770_open(struct net_device *dev)\n{\n\tstruct cc770_priv *priv = netdev_priv(dev);\n\tint err;\n\n\t \n\tset_reset_mode(dev);\n\n\t \n\terr = open_candev(dev);\n\tif (err)\n\t\treturn err;\n\n\terr = request_irq(dev->irq, &cc770_interrupt, priv->irq_flags,\n\t\t\t  dev->name, dev);\n\tif (err) {\n\t\tclose_candev(dev);\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tcc770_start(dev);\n\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\nstatic int cc770_close(struct net_device *dev)\n{\n\tnetif_stop_queue(dev);\n\tset_reset_mode(dev);\n\n\tfree_irq(dev->irq, dev);\n\tclose_candev(dev);\n\n\treturn 0;\n}\n\nstruct net_device *alloc_cc770dev(int sizeof_priv)\n{\n\tstruct net_device *dev;\n\tstruct cc770_priv *priv;\n\n\tdev = alloc_candev(sizeof(struct cc770_priv) + sizeof_priv,\n\t\t\t   CC770_ECHO_SKB_MAX);\n\tif (!dev)\n\t\treturn NULL;\n\n\tpriv = netdev_priv(dev);\n\n\tpriv->dev = dev;\n\tpriv->can.bittiming_const = &cc770_bittiming_const;\n\tpriv->can.do_set_bittiming = cc770_set_bittiming;\n\tpriv->can.do_set_mode = cc770_set_mode;\n\tpriv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES;\n\tpriv->tx_skb = NULL;\n\n\tmemcpy(priv->obj_flags, cc770_obj_flags, sizeof(cc770_obj_flags));\n\n\tif (sizeof_priv)\n\t\tpriv->priv = (void *)priv + sizeof(struct cc770_priv);\n\n\treturn dev;\n}\nEXPORT_SYMBOL_GPL(alloc_cc770dev);\n\nvoid free_cc770dev(struct net_device *dev)\n{\n\tfree_candev(dev);\n}\nEXPORT_SYMBOL_GPL(free_cc770dev);\n\nstatic const struct net_device_ops cc770_netdev_ops = {\n\t.ndo_open = cc770_open,\n\t.ndo_stop = cc770_close,\n\t.ndo_start_xmit = cc770_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic const struct ethtool_ops cc770_ethtool_ops = {\n\t.get_ts_info = ethtool_op_get_ts_info,\n};\n\nint register_cc770dev(struct net_device *dev)\n{\n\tstruct cc770_priv *priv = netdev_priv(dev);\n\tint err;\n\n\terr = cc770_probe_chip(dev);\n\tif (err)\n\t\treturn err;\n\n\tdev->netdev_ops = &cc770_netdev_ops;\n\tdev->ethtool_ops = &cc770_ethtool_ops;\n\n\tdev->flags |= IFF_ECHO;\t \n\n\t \n\tif (!i82527_compat && priv->control_normal_mode & CTRL_EAF) {\n\t\tpriv->can.do_get_berr_counter = cc770_get_berr_counter;\n\t\tpriv->control_normal_mode = CTRL_IE | CTRL_EAF | CTRL_EIE;\n\t\tnetdev_dbg(dev, \"i82527 mode with additional functions\\n\");\n\t} else {\n\t\tpriv->control_normal_mode = CTRL_IE | CTRL_EIE;\n\t\tnetdev_dbg(dev, \"strict i82527 compatibility mode\\n\");\n\t}\n\n\tchipset_init(priv);\n\tset_reset_mode(dev);\n\n\treturn register_candev(dev);\n}\nEXPORT_SYMBOL_GPL(register_cc770dev);\n\nvoid unregister_cc770dev(struct net_device *dev)\n{\n\tset_reset_mode(dev);\n\tunregister_candev(dev);\n}\nEXPORT_SYMBOL_GPL(unregister_cc770dev);\n\nstatic __init int cc770_init(void)\n{\n\tif (msgobj15_eff) {\n\t\tcc770_obj_flags[CC770_OBJ_RX0] |= CC770_OBJ_FLAG_EFF;\n\t\tcc770_obj_flags[CC770_OBJ_RX1] &= ~CC770_OBJ_FLAG_EFF;\n\t}\n\n\tpr_info(\"CAN netdevice driver\\n\");\n\n\treturn 0;\n}\nmodule_init(cc770_init);\n\nstatic __exit void cc770_exit(void)\n{\n\tpr_info(\"driver removed\\n\");\n}\nmodule_exit(cc770_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}