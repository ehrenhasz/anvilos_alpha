{
  "module_name": "vcan.c",
  "hash_id": "fe313edd95ece68bafd8a21b9e9af2dbf8b50ee02391717de85d5d3cdcd3d0a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/vcan.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/ethtool.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/can.h>\n#include <linux/can/can-ml.h>\n#include <linux/can/dev.h>\n#include <linux/can/skb.h>\n#include <linux/slab.h>\n#include <net/rtnetlink.h>\n\n#define DRV_NAME \"vcan\"\n\nMODULE_DESCRIPTION(\"virtual CAN interface\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Urs Thuermann <urs.thuermann@volkswagen.de>\");\nMODULE_ALIAS_RTNL_LINK(DRV_NAME);\n\n \n\nstatic bool echo;  \nmodule_param(echo, bool, 0444);\nMODULE_PARM_DESC(echo, \"Echo sent frames (for testing). Default: 0 (Off)\");\n\nstatic void vcan_rx(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct net_device_stats *stats = &dev->stats;\n\n\tstats->rx_packets++;\n\tstats->rx_bytes += can_skb_get_data_len(skb);\n\n\tskb->pkt_type  = PACKET_BROADCAST;\n\tskb->dev       = dev;\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tnetif_rx(skb);\n}\n\nstatic netdev_tx_t vcan_tx(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct net_device_stats *stats = &dev->stats;\n\tunsigned int len;\n\tint loop;\n\n\tif (can_dropped_invalid_skb(dev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tlen = can_skb_get_data_len(skb);\n\tstats->tx_packets++;\n\tstats->tx_bytes += len;\n\n\t \n\tloop = skb->pkt_type == PACKET_LOOPBACK;\n\n\tskb_tx_timestamp(skb);\n\n\tif (!echo) {\n\t\t \n\t\tif (loop) {\n\t\t\t \n\t\t\tstats->rx_packets++;\n\t\t\tstats->rx_bytes += len;\n\t\t}\n\t\tconsume_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t \n\n\tif (loop) {\n\t\tskb = can_create_echo_skb(skb);\n\t\tif (!skb)\n\t\t\treturn NETDEV_TX_OK;\n\n\t\t \n\t\tvcan_rx(skb, dev);\n\t} else {\n\t\t \n\t\tconsume_skb(skb);\n\t}\n\treturn NETDEV_TX_OK;\n}\n\nstatic int vcan_change_mtu(struct net_device *dev, int new_mtu)\n{\n\t \n\tif (dev->flags & IFF_UP)\n\t\treturn -EBUSY;\n\n\tif (new_mtu != CAN_MTU && new_mtu != CANFD_MTU &&\n\t    !can_is_canxl_dev_mtu(new_mtu))\n\t\treturn -EINVAL;\n\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\nstatic const struct net_device_ops vcan_netdev_ops = {\n\t.ndo_start_xmit = vcan_tx,\n\t.ndo_change_mtu = vcan_change_mtu,\n};\n\nstatic const struct ethtool_ops vcan_ethtool_ops = {\n\t.get_ts_info = ethtool_op_get_ts_info,\n};\n\nstatic void vcan_setup(struct net_device *dev)\n{\n\tdev->type\t\t= ARPHRD_CAN;\n\tdev->mtu\t\t= CANFD_MTU;\n\tdev->hard_header_len\t= 0;\n\tdev->addr_len\t\t= 0;\n\tdev->tx_queue_len\t= 0;\n\tdev->flags\t\t= IFF_NOARP;\n\tcan_set_ml_priv(dev, netdev_priv(dev));\n\n\t \n\tif (echo)\n\t\tdev->flags |= IFF_ECHO;\n\n\tdev->netdev_ops\t\t= &vcan_netdev_ops;\n\tdev->ethtool_ops\t= &vcan_ethtool_ops;\n\tdev->needs_free_netdev\t= true;\n}\n\nstatic struct rtnl_link_ops vcan_link_ops __read_mostly = {\n\t.kind = DRV_NAME,\n\t.priv_size = sizeof(struct can_ml_priv),\n\t.setup = vcan_setup,\n};\n\nstatic __init int vcan_init_module(void)\n{\n\tpr_info(\"Virtual CAN interface driver\\n\");\n\n\tif (echo)\n\t\tpr_info(\"enabled echo on driver level.\\n\");\n\n\treturn rtnl_link_register(&vcan_link_ops);\n}\n\nstatic __exit void vcan_cleanup_module(void)\n{\n\trtnl_link_unregister(&vcan_link_ops);\n}\n\nmodule_init(vcan_init_module);\nmodule_exit(vcan_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}