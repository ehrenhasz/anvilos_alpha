{
  "module_name": "can327.c",
  "hash_id": "ee36876488b9a3be5f752242453d7d6c5657d5449bba991cf92bdc1929f3500b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/can327.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/init.h>\n#include <linux/module.h>\n\n#include <linux/bitops.h>\n#include <linux/ctype.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/lockdep.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/tty.h>\n#include <linux/tty_ldisc.h>\n#include <linux/workqueue.h>\n\n#include <uapi/linux/tty.h>\n\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n#include <linux/can/rx-offload.h>\n\n#define CAN327_NAPI_WEIGHT 4\n\n#define CAN327_SIZE_TXBUF 32\n#define CAN327_SIZE_RXBUF 1024\n\n#define CAN327_CAN_CONFIG_SEND_SFF 0x8000\n#define CAN327_CAN_CONFIG_VARIABLE_DLC 0x4000\n#define CAN327_CAN_CONFIG_RECV_BOTH_SFF_EFF 0x2000\n#define CAN327_CAN_CONFIG_BAUDRATE_MULT_8_7 0x1000\n\n#define CAN327_DUMMY_CHAR 'y'\n#define CAN327_DUMMY_STRING \"y\"\n#define CAN327_READY_CHAR '>'\n\n \nenum can327_tx_do {\n\tCAN327_TX_DO_CAN_DATA = 0,\n\tCAN327_TX_DO_CANID_11BIT,\n\tCAN327_TX_DO_CANID_29BIT_LOW,\n\tCAN327_TX_DO_CANID_29BIT_HIGH,\n\tCAN327_TX_DO_CAN_CONFIG_PART2,\n\tCAN327_TX_DO_CAN_CONFIG,\n\tCAN327_TX_DO_RESPONSES,\n\tCAN327_TX_DO_SILENT_MONITOR,\n\tCAN327_TX_DO_INIT,\n};\n\nstruct can327 {\n\t \n\tstruct can_priv can;\n\n\tstruct can_rx_offload offload;\n\n\t \n\tu8 txbuf[CAN327_SIZE_TXBUF];\n\tu8 rxbuf[CAN327_SIZE_RXBUF];\n\n\t \n\tspinlock_t lock;\n\n\t \n\tstruct tty_struct *tty;\n\tstruct net_device *dev;\n\n\t \n\tstruct work_struct tx_work;\t \n\tu8 *txhead;\t\t\t \n\tsize_t txleft;\t\t\t \n\tint rxfill;\t\t\t \n\n\t \n\tenum {\n\t\tCAN327_STATE_NOTINIT = 0,\n\t\tCAN327_STATE_GETDUMMYCHAR,\n\t\tCAN327_STATE_GETPROMPT,\n\t\tCAN327_STATE_RECEIVING,\n\t} state;\n\n\t \n\tchar **next_init_cmd;\n\tunsigned long cmds_todo;\n\n\t \n\tstruct can_frame can_frame_to_send;\n\tu16 can_config;\n\tu8 can_bitrate_divisor;\n\n\t \n\tbool drop_next_line;\n\n\t \n\tbool uart_side_failure;\n};\n\nstatic inline void can327_uart_side_failure(struct can327 *elm);\n\nstatic void can327_send(struct can327 *elm, const void *buf, size_t len)\n{\n\tint written;\n\n\tlockdep_assert_held(&elm->lock);\n\n\tif (elm->uart_side_failure)\n\t\treturn;\n\n\tmemcpy(elm->txbuf, buf, len);\n\n\t \n\tset_bit(TTY_DO_WRITE_WAKEUP, &elm->tty->flags);\n\twritten = elm->tty->ops->write(elm->tty, elm->txbuf, len);\n\tif (written < 0) {\n\t\tnetdev_err(elm->dev, \"Failed to write to tty %s.\\n\",\n\t\t\t   elm->tty->name);\n\t\tcan327_uart_side_failure(elm);\n\t\treturn;\n\t}\n\n\telm->txleft = len - written;\n\telm->txhead = elm->txbuf + written;\n}\n\n \nstatic void can327_kick_into_cmd_mode(struct can327 *elm)\n{\n\tlockdep_assert_held(&elm->lock);\n\n\tif (elm->state != CAN327_STATE_GETDUMMYCHAR &&\n\t    elm->state != CAN327_STATE_GETPROMPT) {\n\t\tcan327_send(elm, CAN327_DUMMY_STRING, 1);\n\n\t\telm->state = CAN327_STATE_GETDUMMYCHAR;\n\t}\n}\n\n \nstatic void can327_send_frame(struct can327 *elm, struct can_frame *frame)\n{\n\tlockdep_assert_held(&elm->lock);\n\n\t \n\tif (elm->can_frame_to_send.can_id != frame->can_id) {\n\t\t \n\t\tif ((frame->can_id ^ elm->can_frame_to_send.can_id)\n\t\t    & CAN_EFF_FLAG) {\n\t\t\telm->can_config =\n\t\t\t\t(frame->can_id & CAN_EFF_FLAG ? 0 : CAN327_CAN_CONFIG_SEND_SFF) |\n\t\t\t\tCAN327_CAN_CONFIG_VARIABLE_DLC |\n\t\t\t\tCAN327_CAN_CONFIG_RECV_BOTH_SFF_EFF |\n\t\t\t\telm->can_bitrate_divisor;\n\n\t\t\tset_bit(CAN327_TX_DO_CAN_CONFIG, &elm->cmds_todo);\n\t\t}\n\n\t\tif (frame->can_id & CAN_EFF_FLAG) {\n\t\t\tclear_bit(CAN327_TX_DO_CANID_11BIT, &elm->cmds_todo);\n\t\t\tset_bit(CAN327_TX_DO_CANID_29BIT_LOW, &elm->cmds_todo);\n\t\t\tset_bit(CAN327_TX_DO_CANID_29BIT_HIGH, &elm->cmds_todo);\n\t\t} else {\n\t\t\tset_bit(CAN327_TX_DO_CANID_11BIT, &elm->cmds_todo);\n\t\t\tclear_bit(CAN327_TX_DO_CANID_29BIT_LOW,\n\t\t\t\t  &elm->cmds_todo);\n\t\t\tclear_bit(CAN327_TX_DO_CANID_29BIT_HIGH,\n\t\t\t\t  &elm->cmds_todo);\n\t\t}\n\t}\n\n\t \n\telm->can_frame_to_send = *frame;\n\tset_bit(CAN327_TX_DO_CAN_DATA, &elm->cmds_todo);\n\n\tcan327_kick_into_cmd_mode(elm);\n}\n\n \nstatic char *can327_init_script[] = {\n\t\"AT WS\\r\",         \n\t\"AT PP FF OFF\\r\",  \n\t\"AT M0\\r\",         \n\t\"AT AL\\r\",         \n\t\"AT BI\\r\",         \n\t\"AT CAF0\\r\",       \n\t\"AT CFC0\\r\",       \n\t\"AT CF 000\\r\",     \n\t\"AT CM 000\\r\",     \n\t\"AT E1\\r\",         \n\t\"AT H1\\r\",         \n\t\"AT L0\\r\",         \n\t\"AT SH 7DF\\r\",     \n\t\"AT ST FF\\r\",      \n\t\"AT AT0\\r\",        \n\t\"AT D1\\r\",         \n\t\"AT S1\\r\",         \n\t\"AT TP B\\r\",       \n\tNULL\n};\n\nstatic void can327_init_device(struct can327 *elm)\n{\n\tlockdep_assert_held(&elm->lock);\n\n\telm->state = CAN327_STATE_NOTINIT;\n\telm->can_frame_to_send.can_id = 0x7df;  \n\telm->rxfill = 0;\n\telm->drop_next_line = 0;\n\n\t \n\telm->can_bitrate_divisor = 500000 / elm->can.bittiming.bitrate;\n\telm->can_config =\n\t\tCAN327_CAN_CONFIG_SEND_SFF | CAN327_CAN_CONFIG_VARIABLE_DLC |\n\t\tCAN327_CAN_CONFIG_RECV_BOTH_SFF_EFF | elm->can_bitrate_divisor;\n\n\t \n\telm->next_init_cmd = &can327_init_script[0];\n\tset_bit(CAN327_TX_DO_INIT, &elm->cmds_todo);\n\tset_bit(CAN327_TX_DO_SILENT_MONITOR, &elm->cmds_todo);\n\tset_bit(CAN327_TX_DO_RESPONSES, &elm->cmds_todo);\n\tset_bit(CAN327_TX_DO_CAN_CONFIG, &elm->cmds_todo);\n\n\tcan327_kick_into_cmd_mode(elm);\n}\n\nstatic void can327_feed_frame_to_netdev(struct can327 *elm, struct sk_buff *skb)\n{\n\tlockdep_assert_held(&elm->lock);\n\n\tif (!netif_running(elm->dev)) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\t \n\tif (can_rx_offload_queue_tail(&elm->offload, skb))\n\t\telm->dev->stats.rx_fifo_errors++;\n\n\t \n\tcan_rx_offload_irq_finish(&elm->offload);\n}\n\n \nstatic inline void can327_uart_side_failure(struct can327 *elm)\n{\n\tstruct can_frame *frame;\n\tstruct sk_buff *skb;\n\n\tlockdep_assert_held(&elm->lock);\n\n\telm->uart_side_failure = true;\n\n\tclear_bit(TTY_DO_WRITE_WAKEUP, &elm->tty->flags);\n\n\telm->can.can_stats.bus_off++;\n\tnetif_stop_queue(elm->dev);\n\telm->can.state = CAN_STATE_BUS_OFF;\n\tcan_bus_off(elm->dev);\n\n\tnetdev_err(elm->dev,\n\t\t   \"ELM327 misbehaved. Blocking further communication.\\n\");\n\n\tskb = alloc_can_err_skb(elm->dev, &frame);\n\tif (!skb)\n\t\treturn;\n\n\tframe->can_id |= CAN_ERR_BUSOFF;\n\tcan327_feed_frame_to_netdev(elm, skb);\n}\n\n \nstatic inline bool can327_rxbuf_cmp(const u8 *buf, size_t nbytes,\n\t\t\t\t    const char *reference)\n{\n\tsize_t ref_len = strlen(reference);\n\n\treturn (nbytes == ref_len) && !memcmp(buf, reference, ref_len);\n}\n\nstatic void can327_parse_error(struct can327 *elm, size_t len)\n{\n\tstruct can_frame *frame;\n\tstruct sk_buff *skb;\n\n\tlockdep_assert_held(&elm->lock);\n\n\tskb = alloc_can_err_skb(elm->dev, &frame);\n\tif (!skb)\n\t\t \n\t\treturn;\n\n\t \n\tif (can327_rxbuf_cmp(elm->rxbuf, len, \"UNABLE TO CONNECT\")) {\n\t\tnetdev_err(elm->dev,\n\t\t\t   \"ELM327 reported UNABLE TO CONNECT. Please check your setup.\\n\");\n\t} else if (can327_rxbuf_cmp(elm->rxbuf, len, \"BUFFER FULL\")) {\n\t\t \n\t\tframe->can_id |= CAN_ERR_CRTL;\n\t\tframe->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\t} else if (can327_rxbuf_cmp(elm->rxbuf, len, \"BUS ERROR\")) {\n\t\tframe->can_id |= CAN_ERR_BUSERROR;\n\t} else if (can327_rxbuf_cmp(elm->rxbuf, len, \"CAN ERROR\")) {\n\t\tframe->can_id |= CAN_ERR_PROT;\n\t} else if (can327_rxbuf_cmp(elm->rxbuf, len, \"<RX ERROR\")) {\n\t\tframe->can_id |= CAN_ERR_PROT;\n\t} else if (can327_rxbuf_cmp(elm->rxbuf, len, \"BUS BUSY\")) {\n\t\tframe->can_id |= CAN_ERR_PROT;\n\t\tframe->data[2] = CAN_ERR_PROT_OVERLOAD;\n\t} else if (can327_rxbuf_cmp(elm->rxbuf, len, \"FB ERROR\")) {\n\t\tframe->can_id |= CAN_ERR_PROT;\n\t\tframe->data[2] = CAN_ERR_PROT_TX;\n\t} else if (len == 5 && !memcmp(elm->rxbuf, \"ERR\", 3)) {\n\t\t \n\t\tnetdev_err(elm->dev, \"ELM327 reported an ERR%c%c. Please power it off and on again.\\n\",\n\t\t\t   elm->rxbuf[3], elm->rxbuf[4]);\n\t\tframe->can_id |= CAN_ERR_CRTL;\n\t} else {\n\t\t \n\t}\n\n\tcan327_feed_frame_to_netdev(elm, skb);\n}\n\n \nstatic int can327_parse_frame(struct can327 *elm, size_t len)\n{\n\tstruct can_frame *frame;\n\tstruct sk_buff *skb;\n\tint hexlen;\n\tint datastart;\n\tint i;\n\n\tlockdep_assert_held(&elm->lock);\n\n\tskb = alloc_can_skb(elm->dev, &frame);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (hexlen = 0; hexlen <= len; hexlen++) {\n\t\tif (hex_to_bin(elm->rxbuf[hexlen]) < 0 &&\n\t\t    elm->rxbuf[hexlen] != ' ') {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (hexlen < len && !isdigit(elm->rxbuf[hexlen]) &&\n\t    !isupper(elm->rxbuf[hexlen]) && '<' != elm->rxbuf[hexlen] &&\n\t    ' ' != elm->rxbuf[hexlen]) {\n\t\t \n\t\tkfree_skb(skb);\n\t\treturn -ENODATA;\n\t}\n\n\t \n\tif (elm->rxbuf[2] == ' ' && elm->rxbuf[5] == ' ' &&\n\t    elm->rxbuf[8] == ' ' && elm->rxbuf[11] == ' ' &&\n\t    elm->rxbuf[13] == ' ') {\n\t\tframe->can_id = CAN_EFF_FLAG;\n\t\tdatastart = 14;\n\t} else if (elm->rxbuf[3] == ' ' && elm->rxbuf[5] == ' ') {\n\t\tdatastart = 6;\n\t} else {\n\t\t \n\t\tkfree_skb(skb);\n\t\treturn -ENODATA;\n\t}\n\n\tif (hexlen < datastart) {\n\t\t \n\t\tkfree_skb(skb);\n\t\treturn -ENODATA;\n\t}\n\n\t \n\n\t \n\tframe->len = (hex_to_bin(elm->rxbuf[datastart - 2]) << 0);\n\n\t \n\tif (frame->can_id & CAN_EFF_FLAG) {\n\t\tframe->can_id |= (hex_to_bin(elm->rxbuf[0]) << 28) |\n\t\t\t\t (hex_to_bin(elm->rxbuf[1]) << 24) |\n\t\t\t\t (hex_to_bin(elm->rxbuf[3]) << 20) |\n\t\t\t\t (hex_to_bin(elm->rxbuf[4]) << 16) |\n\t\t\t\t (hex_to_bin(elm->rxbuf[6]) << 12) |\n\t\t\t\t (hex_to_bin(elm->rxbuf[7]) << 8) |\n\t\t\t\t (hex_to_bin(elm->rxbuf[9]) << 4) |\n\t\t\t\t (hex_to_bin(elm->rxbuf[10]) << 0);\n\t} else {\n\t\tframe->can_id |= (hex_to_bin(elm->rxbuf[0]) << 8) |\n\t\t\t\t (hex_to_bin(elm->rxbuf[1]) << 4) |\n\t\t\t\t (hex_to_bin(elm->rxbuf[2]) << 0);\n\t}\n\n\t \n\tif (elm->rxfill >= hexlen + 3 &&\n\t    !memcmp(&elm->rxbuf[hexlen], \"RTR\", 3)) {\n\t\tframe->can_id |= CAN_RTR_FLAG;\n\t}\n\n\t \n\tif (!(frame->can_id & CAN_RTR_FLAG) &&\n\t    (hexlen < frame->len * 3 + datastart)) {\n\t\t \n\t\tframe->can_id = CAN_ERR_FLAG | CAN_ERR_CRTL;\n\t\tframe->len = CAN_ERR_DLC;\n\t\tframe->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\t\tcan327_feed_frame_to_netdev(elm, skb);\n\n\t\t \n\t\treturn -ENODATA;\n\t}\n\n\t \n\tfor (i = 0; i < frame->len; i++) {\n\t\tframe->data[i] =\n\t\t\t(hex_to_bin(elm->rxbuf[datastart + 3 * i]) << 4) |\n\t\t\t(hex_to_bin(elm->rxbuf[datastart + 3 * i + 1]));\n\t}\n\n\t \n\tcan327_feed_frame_to_netdev(elm, skb);\n\n\treturn 0;\n}\n\nstatic void can327_parse_line(struct can327 *elm, size_t len)\n{\n\tlockdep_assert_held(&elm->lock);\n\n\t \n\tif (!len)\n\t\treturn;\n\n\t \n\tif (elm->drop_next_line) {\n\t\telm->drop_next_line = 0;\n\t\treturn;\n\t} else if (!memcmp(elm->rxbuf, \"AT\", 2)) {\n\t\treturn;\n\t}\n\n\t \n\tif (elm->state == CAN327_STATE_RECEIVING &&\n\t    can327_parse_frame(elm, len)) {\n\t\t \n\t\tcan327_parse_error(elm, len);\n\n\t\t \n\t\tcan327_kick_into_cmd_mode(elm);\n\t}\n}\n\nstatic void can327_handle_prompt(struct can327 *elm)\n{\n\tstruct can_frame *frame = &elm->can_frame_to_send;\n\t \n\tchar local_txbuf[sizeof(\"0102030405060708\\r\")];\n\n\tlockdep_assert_held(&elm->lock);\n\n\tif (!elm->cmds_todo) {\n\t\t \n\t\tcan327_send(elm, \"ATMA\\r\", 5);\n\t\telm->state = CAN327_STATE_RECEIVING;\n\n\t\t \n\t\tnetif_wake_queue(elm->dev);\n\n\t\treturn;\n\t}\n\n\t \n\tif (test_bit(CAN327_TX_DO_INIT, &elm->cmds_todo)) {\n\t\tsnprintf(local_txbuf, sizeof(local_txbuf), \"%s\",\n\t\t\t *elm->next_init_cmd);\n\n\t\telm->next_init_cmd++;\n\t\tif (!(*elm->next_init_cmd)) {\n\t\t\tclear_bit(CAN327_TX_DO_INIT, &elm->cmds_todo);\n\t\t\t \n\t\t}\n\n\t} else if (test_and_clear_bit(CAN327_TX_DO_SILENT_MONITOR, &elm->cmds_todo)) {\n\t\tsnprintf(local_txbuf, sizeof(local_txbuf),\n\t\t\t \"ATCSM%i\\r\",\n\t\t\t !!(elm->can.ctrlmode & CAN_CTRLMODE_LISTENONLY));\n\n\t} else if (test_and_clear_bit(CAN327_TX_DO_RESPONSES, &elm->cmds_todo)) {\n\t\tsnprintf(local_txbuf, sizeof(local_txbuf),\n\t\t\t \"ATR%i\\r\",\n\t\t\t !(elm->can.ctrlmode & CAN_CTRLMODE_LISTENONLY));\n\n\t} else if (test_and_clear_bit(CAN327_TX_DO_CAN_CONFIG, &elm->cmds_todo)) {\n\t\tsnprintf(local_txbuf, sizeof(local_txbuf),\n\t\t\t \"ATPC\\r\");\n\t\tset_bit(CAN327_TX_DO_CAN_CONFIG_PART2, &elm->cmds_todo);\n\n\t} else if (test_and_clear_bit(CAN327_TX_DO_CAN_CONFIG_PART2, &elm->cmds_todo)) {\n\t\tsnprintf(local_txbuf, sizeof(local_txbuf),\n\t\t\t \"ATPB%04X\\r\",\n\t\t\t elm->can_config);\n\n\t} else if (test_and_clear_bit(CAN327_TX_DO_CANID_29BIT_HIGH, &elm->cmds_todo)) {\n\t\tsnprintf(local_txbuf, sizeof(local_txbuf),\n\t\t\t \"ATCP%02X\\r\",\n\t\t\t (frame->can_id & CAN_EFF_MASK) >> 24);\n\n\t} else if (test_and_clear_bit(CAN327_TX_DO_CANID_29BIT_LOW, &elm->cmds_todo)) {\n\t\tsnprintf(local_txbuf, sizeof(local_txbuf),\n\t\t\t \"ATSH%06X\\r\",\n\t\t\t frame->can_id & CAN_EFF_MASK & ((1 << 24) - 1));\n\n\t} else if (test_and_clear_bit(CAN327_TX_DO_CANID_11BIT, &elm->cmds_todo)) {\n\t\tsnprintf(local_txbuf, sizeof(local_txbuf),\n\t\t\t \"ATSH%03X\\r\",\n\t\t\t frame->can_id & CAN_SFF_MASK);\n\n\t} else if (test_and_clear_bit(CAN327_TX_DO_CAN_DATA, &elm->cmds_todo)) {\n\t\tif (frame->can_id & CAN_RTR_FLAG) {\n\t\t\t \n\t\t\tsnprintf(local_txbuf, sizeof(local_txbuf), \"ATRTR\\r\");\n\t\t} else {\n\t\t\t \n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < frame->len; i++) {\n\t\t\t\tsnprintf(&local_txbuf[2 * i],\n\t\t\t\t\t sizeof(local_txbuf), \"%02X\",\n\t\t\t\t\t frame->data[i]);\n\t\t\t}\n\n\t\t\tsnprintf(&local_txbuf[2 * i], sizeof(local_txbuf),\n\t\t\t\t \"\\r\");\n\t\t}\n\n\t\telm->drop_next_line = 1;\n\t\telm->state = CAN327_STATE_RECEIVING;\n\n\t\t \n\t\tnetif_wake_queue(elm->dev);\n\t}\n\n\tcan327_send(elm, local_txbuf, strlen(local_txbuf));\n}\n\nstatic bool can327_is_ready_char(char c)\n{\n\t \n\treturn (c & 0x3f) == CAN327_READY_CHAR;\n}\n\nstatic void can327_drop_bytes(struct can327 *elm, size_t i)\n{\n\tlockdep_assert_held(&elm->lock);\n\n\tmemmove(&elm->rxbuf[0], &elm->rxbuf[i], CAN327_SIZE_RXBUF - i);\n\telm->rxfill -= i;\n}\n\nstatic void can327_parse_rxbuf(struct can327 *elm, size_t first_new_char_idx)\n{\n\tsize_t len, pos;\n\n\tlockdep_assert_held(&elm->lock);\n\n\tswitch (elm->state) {\n\tcase CAN327_STATE_NOTINIT:\n\t\telm->rxfill = 0;\n\t\tbreak;\n\n\tcase CAN327_STATE_GETDUMMYCHAR:\n\t\t \n\t\tfor (pos = 0; pos < elm->rxfill; pos++) {\n\t\t\tif (elm->rxbuf[pos] == CAN327_DUMMY_CHAR) {\n\t\t\t\tcan327_send(elm, \"\\r\", 1);\n\t\t\t\telm->state = CAN327_STATE_GETPROMPT;\n\t\t\t\tpos++;\n\t\t\t\tbreak;\n\t\t\t} else if (can327_is_ready_char(elm->rxbuf[pos])) {\n\t\t\t\tcan327_send(elm, CAN327_DUMMY_STRING, 1);\n\t\t\t\tpos++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcan327_drop_bytes(elm, pos);\n\t\tbreak;\n\n\tcase CAN327_STATE_GETPROMPT:\n\t\t \n\t\tif (can327_is_ready_char(elm->rxbuf[elm->rxfill - 1]))\n\t\t\tcan327_handle_prompt(elm);\n\n\t\telm->rxfill = 0;\n\t\tbreak;\n\n\tcase CAN327_STATE_RECEIVING:\n\t\t \n\t\tlen = first_new_char_idx;\n\t\twhile (len < elm->rxfill && elm->rxbuf[len] != '\\r')\n\t\t\tlen++;\n\n\t\tif (len == CAN327_SIZE_RXBUF) {\n\t\t\t \n\t\t\tnetdev_err(elm->dev,\n\t\t\t\t   \"RX buffer overflow. Faulty ELM327 or UART?\\n\");\n\t\t\tcan327_uart_side_failure(elm);\n\t\t} else if (len == elm->rxfill) {\n\t\t\tif (can327_is_ready_char(elm->rxbuf[elm->rxfill - 1])) {\n\t\t\t\t \n\t\t\t\telm->rxfill = 0;\n\n\t\t\t\tcan327_handle_prompt(elm);\n\t\t\t}\n\n\t\t\t \n\t\t} else {\n\t\t\t \n\t\t\tcan327_parse_line(elm, len);\n\n\t\t\t \n\t\t\tcan327_drop_bytes(elm, len + 1);\n\n\t\t\t \n\t\t\tif (elm->rxfill)\n\t\t\t\tcan327_parse_rxbuf(elm, 0);\n\t\t}\n\t}\n}\n\nstatic int can327_netdev_open(struct net_device *dev)\n{\n\tstruct can327 *elm = netdev_priv(dev);\n\tint err;\n\n\tspin_lock_bh(&elm->lock);\n\n\tif (!elm->tty) {\n\t\tspin_unlock_bh(&elm->lock);\n\t\treturn -ENODEV;\n\t}\n\n\tif (elm->uart_side_failure)\n\t\tnetdev_warn(elm->dev,\n\t\t\t    \"Reopening netdev after a UART side fault has been detected.\\n\");\n\n\t \n\telm->rxfill = 0;\n\telm->txleft = 0;\n\n\t \n\terr = open_candev(dev);\n\tif (err) {\n\t\tspin_unlock_bh(&elm->lock);\n\t\treturn err;\n\t}\n\n\tcan327_init_device(elm);\n\tspin_unlock_bh(&elm->lock);\n\n\terr = can_rx_offload_add_manual(dev, &elm->offload, CAN327_NAPI_WEIGHT);\n\tif (err) {\n\t\tclose_candev(dev);\n\t\treturn err;\n\t}\n\n\tcan_rx_offload_enable(&elm->offload);\n\n\telm->can.state = CAN_STATE_ERROR_ACTIVE;\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\nstatic int can327_netdev_close(struct net_device *dev)\n{\n\tstruct can327 *elm = netdev_priv(dev);\n\n\t \n\tspin_lock_bh(&elm->lock);\n\tcan327_send(elm, CAN327_DUMMY_STRING, 1);\n\tspin_unlock_bh(&elm->lock);\n\n\tnetif_stop_queue(dev);\n\n\t \n\n\tcan_rx_offload_disable(&elm->offload);\n\telm->can.state = CAN_STATE_STOPPED;\n\tcan_rx_offload_del(&elm->offload);\n\tclose_candev(dev);\n\n\treturn 0;\n}\n\n \nstatic netdev_tx_t can327_netdev_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *dev)\n{\n\tstruct can327 *elm = netdev_priv(dev);\n\tstruct can_frame *frame = (struct can_frame *)skb->data;\n\n\tif (can_dev_dropped_skb(dev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\t \n\tif (elm->uart_side_failure) {\n\t\tWARN_ON_ONCE(elm->uart_side_failure);\n\t\tgoto out;\n\t}\n\n\tnetif_stop_queue(dev);\n\n\t \n\tspin_lock(&elm->lock);\n\tcan327_send_frame(elm, frame);\n\tspin_unlock(&elm->lock);\n\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += frame->can_id & CAN_RTR_FLAG ? 0 : frame->len;\n\n\tskb_tx_timestamp(skb);\n\nout:\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic const struct net_device_ops can327_netdev_ops = {\n\t.ndo_open = can327_netdev_open,\n\t.ndo_stop = can327_netdev_close,\n\t.ndo_start_xmit = can327_netdev_start_xmit,\n\t.ndo_change_mtu = can_change_mtu,\n};\n\nstatic const struct ethtool_ops can327_ethtool_ops = {\n\t.get_ts_info = ethtool_op_get_ts_info,\n};\n\nstatic bool can327_is_valid_rx_char(u8 c)\n{\n\tstatic const bool lut_char_is_valid['z'] = {\n\t\t['\\r'] = true,\n\t\t[' '] = true,\n\t\t['.'] = true,\n\t\t['0'] = true, true, true, true, true,\n\t\t['5'] = true, true, true, true, true,\n\t\t['<'] = true,\n\t\t[CAN327_READY_CHAR] = true,\n\t\t['?'] = true,\n\t\t['A'] = true, true, true, true, true, true, true,\n\t\t['H'] = true, true, true, true, true, true, true,\n\t\t['O'] = true, true, true, true, true, true, true,\n\t\t['V'] = true, true, true, true, true,\n\t\t['a'] = true,\n\t\t['b'] = true,\n\t\t['v'] = true,\n\t\t[CAN327_DUMMY_CHAR] = true,\n\t};\n\tBUILD_BUG_ON(CAN327_DUMMY_CHAR >= 'z');\n\n\treturn (c < ARRAY_SIZE(lut_char_is_valid) && lut_char_is_valid[c]);\n}\n\n \nstatic void can327_ldisc_rx(struct tty_struct *tty, const u8 *cp,\n\t\t\t    const u8 *fp, size_t count)\n{\n\tstruct can327 *elm = tty->disc_data;\n\tsize_t first_new_char_idx;\n\n\tif (elm->uart_side_failure)\n\t\treturn;\n\n\tspin_lock_bh(&elm->lock);\n\n\t \n\tfirst_new_char_idx = elm->rxfill;\n\n\twhile (count--) {\n\t\tif (elm->rxfill >= CAN327_SIZE_RXBUF) {\n\t\t\tnetdev_err(elm->dev,\n\t\t\t\t   \"Receive buffer overflowed. Bad chip or wiring? count = %zu\",\n\t\t\t\t   count);\n\t\t\tgoto uart_failure;\n\t\t}\n\t\tif (fp && *fp++) {\n\t\t\tnetdev_err(elm->dev,\n\t\t\t\t   \"Error in received character stream. Check your wiring.\");\n\t\t\tgoto uart_failure;\n\t\t}\n\n\t\t \n\t\tif (*cp) {\n\t\t\t \n\t\t\tif (!can327_is_valid_rx_char(*cp)) {\n\t\t\t\tnetdev_err(elm->dev,\n\t\t\t\t\t   \"Received illegal character %02x.\\n\",\n\t\t\t\t\t   *cp);\n\t\t\t\tgoto uart_failure;\n\t\t\t}\n\n\t\t\telm->rxbuf[elm->rxfill++] = *cp;\n\t\t}\n\n\t\tcp++;\n\t}\n\n\tcan327_parse_rxbuf(elm, first_new_char_idx);\n\tspin_unlock_bh(&elm->lock);\n\n\treturn;\nuart_failure:\n\tcan327_uart_side_failure(elm);\n\tspin_unlock_bh(&elm->lock);\n}\n\n \nstatic void can327_ldisc_tx_worker(struct work_struct *work)\n{\n\tstruct can327 *elm = container_of(work, struct can327, tx_work);\n\tssize_t written;\n\n\tif (elm->uart_side_failure)\n\t\treturn;\n\n\tspin_lock_bh(&elm->lock);\n\n\tif (elm->txleft) {\n\t\twritten = elm->tty->ops->write(elm->tty, elm->txhead,\n\t\t\t\t\t       elm->txleft);\n\t\tif (written < 0) {\n\t\t\tnetdev_err(elm->dev, \"Failed to write to tty %s.\\n\",\n\t\t\t\t   elm->tty->name);\n\t\t\tcan327_uart_side_failure(elm);\n\n\t\t\tspin_unlock_bh(&elm->lock);\n\t\t\treturn;\n\t\t}\n\n\t\telm->txleft -= written;\n\t\telm->txhead += written;\n\t}\n\n\tif (!elm->txleft)\n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &elm->tty->flags);\n\n\tspin_unlock_bh(&elm->lock);\n}\n\n \nstatic void can327_ldisc_tx_wakeup(struct tty_struct *tty)\n{\n\tstruct can327 *elm = tty->disc_data;\n\n\tschedule_work(&elm->tx_work);\n}\n\n \nstatic const u32 can327_bitrate_const[] = {\n\t7812,  7936,  8064,  8196,   8333,   8474,   8620,   8771,\n\t8928,  9090,  9259,  9433,   9615,   9803,   10000,  10204,\n\t10416, 10638, 10869, 11111,  11363,  11627,  11904,  12195,\n\t12500, 12820, 13157, 13513,  13888,  14285,  14705,  15151,\n\t15625, 16129, 16666, 17241,  17857,  18518,  19230,  20000,\n\t20833, 21739, 22727, 23809,  25000,  26315,  27777,  29411,\n\t31250, 33333, 35714, 38461,  41666,  45454,  50000,  55555,\n\t62500, 71428, 83333, 100000, 125000, 166666, 250000, 500000\n};\n\nstatic int can327_ldisc_open(struct tty_struct *tty)\n{\n\tstruct net_device *dev;\n\tstruct can327 *elm;\n\tint err;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!tty->ops->write)\n\t\treturn -EOPNOTSUPP;\n\n\tdev = alloc_candev(sizeof(struct can327), 0);\n\tif (!dev)\n\t\treturn -ENFILE;\n\telm = netdev_priv(dev);\n\n\t \n\ttty->receive_room = 65536;  \n\tspin_lock_init(&elm->lock);\n\tINIT_WORK(&elm->tx_work, can327_ldisc_tx_worker);\n\n\t \n\telm->can.bitrate_const = can327_bitrate_const;\n\telm->can.bitrate_const_cnt = ARRAY_SIZE(can327_bitrate_const);\n\telm->can.ctrlmode_supported = CAN_CTRLMODE_LISTENONLY;\n\n\t \n\telm->dev = dev;\n\tdev->netdev_ops = &can327_netdev_ops;\n\tdev->ethtool_ops = &can327_ethtool_ops;\n\n\t \n\telm->tty = tty;\n\ttty->disc_data = elm;\n\n\t \n\terr = register_candev(elm->dev);\n\tif (err) {\n\t\tfree_candev(elm->dev);\n\t\treturn err;\n\t}\n\n\tnetdev_info(elm->dev, \"can327 on %s.\\n\", tty->name);\n\n\treturn 0;\n}\n\n \nstatic void can327_ldisc_close(struct tty_struct *tty)\n{\n\tstruct can327 *elm = tty->disc_data;\n\n\t \n\tunregister_candev(elm->dev);\n\n\t \n\tflush_work(&elm->tx_work);\n\n\t \n\tspin_lock_bh(&elm->lock);\n\ttty->disc_data = NULL;\n\telm->tty = NULL;\n\tspin_unlock_bh(&elm->lock);\n\n\tnetdev_info(elm->dev, \"can327 off %s.\\n\", tty->name);\n\n\tfree_candev(elm->dev);\n}\n\nstatic int can327_ldisc_ioctl(struct tty_struct *tty, unsigned int cmd,\n\t\t\t      unsigned long arg)\n{\n\tstruct can327 *elm = tty->disc_data;\n\tunsigned int tmp;\n\n\tswitch (cmd) {\n\tcase SIOCGIFNAME:\n\t\ttmp = strnlen(elm->dev->name, IFNAMSIZ - 1) + 1;\n\t\tif (copy_to_user((void __user *)arg, elm->dev->name, tmp))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase SIOCSIFHWADDR:\n\t\treturn -EINVAL;\n\n\tdefault:\n\t\treturn tty_mode_ioctl(tty, cmd, arg);\n\t}\n}\n\nstatic struct tty_ldisc_ops can327_ldisc = {\n\t.owner = THIS_MODULE,\n\t.name = KBUILD_MODNAME,\n\t.num = N_CAN327,\n\t.receive_buf = can327_ldisc_rx,\n\t.write_wakeup = can327_ldisc_tx_wakeup,\n\t.open = can327_ldisc_open,\n\t.close = can327_ldisc_close,\n\t.ioctl = can327_ldisc_ioctl,\n};\n\nstatic int __init can327_init(void)\n{\n\tint status;\n\n\tstatus = tty_register_ldisc(&can327_ldisc);\n\tif (status)\n\t\tpr_err(\"Can't register line discipline\\n\");\n\n\treturn status;\n}\n\nstatic void __exit can327_exit(void)\n{\n\t \n\ttty_unregister_ldisc(&can327_ldisc);\n}\n\nmodule_init(can327_init);\nmodule_exit(can327_exit);\n\nMODULE_ALIAS_LDISC(N_CAN327);\nMODULE_DESCRIPTION(\"ELM327 based CAN interface\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Max Staudt <max@enpas.org>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}