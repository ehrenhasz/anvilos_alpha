{
  "module_name": "slcan-core.c",
  "hash_id": "37d7e364dae59d24fce75d12297012d53aafecff5b94e97aa8b9ef10ab99ab41",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/slcan/slcan-core.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/string.h>\n#include <linux/tty.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/workqueue.h>\n#include <linux/can.h>\n#include <linux/can/dev.h>\n#include <linux/can/skb.h>\n\n#include \"slcan.h\"\n\nMODULE_ALIAS_LDISC(N_SLCAN);\nMODULE_DESCRIPTION(\"serial line CAN interface\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Oliver Hartkopp <socketcan@hartkopp.net>\");\nMODULE_AUTHOR(\"Dario Binacchi <dario.binacchi@amarulasolutions.com>\");\n\n \n#define SLCAN_MTU (sizeof(\"T1111222281122334455667788EA5F\\r\") + 1)\n\n#define SLCAN_CMD_LEN 1\n#define SLCAN_SFF_ID_LEN 3\n#define SLCAN_EFF_ID_LEN 8\n#define SLCAN_STATE_LEN 1\n#define SLCAN_STATE_BE_RXCNT_LEN 3\n#define SLCAN_STATE_BE_TXCNT_LEN 3\n#define SLCAN_STATE_FRAME_LEN       (1 + SLCAN_CMD_LEN + \\\n\t\t\t\t     SLCAN_STATE_BE_RXCNT_LEN + \\\n\t\t\t\t     SLCAN_STATE_BE_TXCNT_LEN)\nstruct slcan {\n\tstruct can_priv         can;\n\n\t \n\tstruct tty_struct\t*tty;\t\t \n\tstruct net_device\t*dev;\t\t \n\tspinlock_t\t\tlock;\n\tstruct work_struct\ttx_work;\t \n\n\t \n\tunsigned char\t\trbuff[SLCAN_MTU];\t \n\tint\t\t\trcount;          \n\tunsigned char\t\txbuff[SLCAN_MTU];\t \n\tunsigned char\t\t*xhead;          \n\tint\t\t\txleft;           \n\n\tunsigned long\t\tflags;\t\t \n#define SLF_ERROR\t\t0                \n#define SLF_XCMD\t\t1                \n\tunsigned long           cmd_flags;       \n#define CF_ERR_RST\t\t0                \n\twait_queue_head_t       xcmd_wait;       \n\t\t\t\t\t\t \n};\n\nstatic const u32 slcan_bitrate_const[] = {\n\t10000, 20000, 50000, 100000, 125000,\n\t250000, 500000, 800000, 1000000\n};\n\nbool slcan_err_rst_on_open(struct net_device *ndev)\n{\n\tstruct slcan *sl = netdev_priv(ndev);\n\n\treturn !!test_bit(CF_ERR_RST, &sl->cmd_flags);\n}\n\nint slcan_enable_err_rst_on_open(struct net_device *ndev, bool on)\n{\n\tstruct slcan *sl = netdev_priv(ndev);\n\n\tif (netif_running(ndev))\n\t\treturn -EBUSY;\n\n\tif (on)\n\t\tset_bit(CF_ERR_RST, &sl->cmd_flags);\n\telse\n\t\tclear_bit(CF_ERR_RST, &sl->cmd_flags);\n\n\treturn 0;\n}\n\n \n\n \n\n \n\n \nstatic void slcan_bump_frame(struct slcan *sl)\n{\n\tstruct sk_buff *skb;\n\tstruct can_frame *cf;\n\tint i, tmp;\n\tu32 tmpid;\n\tchar *cmd = sl->rbuff;\n\n\tskb = alloc_can_skb(sl->dev, &cf);\n\tif (unlikely(!skb)) {\n\t\tsl->dev->stats.rx_dropped++;\n\t\treturn;\n\t}\n\n\tswitch (*cmd) {\n\tcase 'r':\n\t\tcf->can_id = CAN_RTR_FLAG;\n\t\tfallthrough;\n\tcase 't':\n\t\t \n\t\tcf->len = sl->rbuff[SLCAN_CMD_LEN + SLCAN_SFF_ID_LEN];\n\t\tsl->rbuff[SLCAN_CMD_LEN + SLCAN_SFF_ID_LEN] = 0;\n\t\t \n\t\tcmd += SLCAN_CMD_LEN + SLCAN_SFF_ID_LEN + 1;\n\t\tbreak;\n\tcase 'R':\n\t\tcf->can_id = CAN_RTR_FLAG;\n\t\tfallthrough;\n\tcase 'T':\n\t\tcf->can_id |= CAN_EFF_FLAG;\n\t\t \n\t\tcf->len = sl->rbuff[SLCAN_CMD_LEN + SLCAN_EFF_ID_LEN];\n\t\tsl->rbuff[SLCAN_CMD_LEN + SLCAN_EFF_ID_LEN] = 0;\n\t\t \n\t\tcmd += SLCAN_CMD_LEN + SLCAN_EFF_ID_LEN + 1;\n\t\tbreak;\n\tdefault:\n\t\tgoto decode_failed;\n\t}\n\n\tif (kstrtou32(sl->rbuff + SLCAN_CMD_LEN, 16, &tmpid))\n\t\tgoto decode_failed;\n\n\tcf->can_id |= tmpid;\n\n\t \n\tif (cf->len >= '0' && cf->len < '9')\n\t\tcf->len -= '0';\n\telse\n\t\tgoto decode_failed;\n\n\t \n\tif (!(cf->can_id & CAN_RTR_FLAG)) {\n\t\tfor (i = 0; i < cf->len; i++) {\n\t\t\ttmp = hex_to_bin(*cmd++);\n\t\t\tif (tmp < 0)\n\t\t\t\tgoto decode_failed;\n\n\t\t\tcf->data[i] = (tmp << 4);\n\t\t\ttmp = hex_to_bin(*cmd++);\n\t\t\tif (tmp < 0)\n\t\t\t\tgoto decode_failed;\n\n\t\t\tcf->data[i] |= tmp;\n\t\t}\n\t}\n\n\tsl->dev->stats.rx_packets++;\n\tif (!(cf->can_id & CAN_RTR_FLAG))\n\t\tsl->dev->stats.rx_bytes += cf->len;\n\n\tnetif_rx(skb);\n\treturn;\n\ndecode_failed:\n\tsl->dev->stats.rx_errors++;\n\tdev_kfree_skb(skb);\n}\n\n \nstatic void slcan_bump_state(struct slcan *sl)\n{\n\tstruct net_device *dev = sl->dev;\n\tstruct sk_buff *skb;\n\tstruct can_frame *cf;\n\tchar *cmd = sl->rbuff;\n\tu32 rxerr, txerr;\n\tenum can_state state, rx_state, tx_state;\n\n\tswitch (cmd[1]) {\n\tcase 'a':\n\t\tstate = CAN_STATE_ERROR_ACTIVE;\n\t\tbreak;\n\tcase 'w':\n\t\tstate = CAN_STATE_ERROR_WARNING;\n\t\tbreak;\n\tcase 'p':\n\t\tstate = CAN_STATE_ERROR_PASSIVE;\n\t\tbreak;\n\tcase 'b':\n\t\tstate = CAN_STATE_BUS_OFF;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (state == sl->can.state || sl->rcount < SLCAN_STATE_FRAME_LEN)\n\t\treturn;\n\n\tcmd += SLCAN_STATE_BE_RXCNT_LEN + SLCAN_CMD_LEN + 1;\n\tcmd[SLCAN_STATE_BE_TXCNT_LEN] = 0;\n\tif (kstrtou32(cmd, 10, &txerr))\n\t\treturn;\n\n\t*cmd = 0;\n\tcmd -= SLCAN_STATE_BE_RXCNT_LEN;\n\tif (kstrtou32(cmd, 10, &rxerr))\n\t\treturn;\n\n\tskb = alloc_can_err_skb(dev, &cf);\n\n\ttx_state = txerr >= rxerr ? state : 0;\n\trx_state = txerr <= rxerr ? state : 0;\n\tcan_change_state(dev, cf, tx_state, rx_state);\n\n\tif (state == CAN_STATE_BUS_OFF) {\n\t\tcan_bus_off(dev);\n\t} else if (skb) {\n\t\tcf->can_id |= CAN_ERR_CNT;\n\t\tcf->data[6] = txerr;\n\t\tcf->data[7] = rxerr;\n\t}\n\n\tif (skb)\n\t\tnetif_rx(skb);\n}\n\n \nstatic void slcan_bump_err(struct slcan *sl)\n{\n\tstruct net_device *dev = sl->dev;\n\tstruct sk_buff *skb;\n\tstruct can_frame *cf;\n\tchar *cmd = sl->rbuff;\n\tbool rx_errors = false, tx_errors = false, rx_over_errors = false;\n\tint i, len;\n\n\t \n\tlen = cmd[1];\n\tif (len >= '0' && len < '9')\n\t\tlen -= '0';\n\telse\n\t\treturn;\n\n\tif ((len + SLCAN_CMD_LEN + 1) > sl->rcount)\n\t\treturn;\n\n\tskb = alloc_can_err_skb(dev, &cf);\n\n\tif (skb)\n\t\tcf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\n\n\tcmd += SLCAN_CMD_LEN + 1;\n\tfor (i = 0; i < len; i++, cmd++) {\n\t\tswitch (*cmd) {\n\t\tcase 'a':\n\t\t\tnetdev_dbg(dev, \"ACK error\\n\");\n\t\t\ttx_errors = true;\n\t\t\tif (skb) {\n\t\t\t\tcf->can_id |= CAN_ERR_ACK;\n\t\t\t\tcf->data[3] = CAN_ERR_PROT_LOC_ACK;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tnetdev_dbg(dev, \"Bit0 error\\n\");\n\t\t\ttx_errors = true;\n\t\t\tif (skb)\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT0;\n\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tnetdev_dbg(dev, \"Bit1 error\\n\");\n\t\t\ttx_errors = true;\n\t\t\tif (skb)\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT1;\n\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tnetdev_dbg(dev, \"CRC error\\n\");\n\t\t\trx_errors = true;\n\t\t\tif (skb) {\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT;\n\t\t\t\tcf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tnetdev_dbg(dev, \"Form Error\\n\");\n\t\t\trx_errors = true;\n\t\t\tif (skb)\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_FORM;\n\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tnetdev_dbg(dev, \"Rx overrun error\\n\");\n\t\t\trx_over_errors = true;\n\t\t\trx_errors = true;\n\t\t\tif (skb) {\n\t\t\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\t\t\tcf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 'O':\n\t\t\tnetdev_dbg(dev, \"Tx overrun error\\n\");\n\t\t\ttx_errors = true;\n\t\t\tif (skb) {\n\t\t\t\tcf->can_id |= CAN_ERR_CRTL;\n\t\t\t\tcf->data[1] = CAN_ERR_CRTL_TX_OVERFLOW;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tnetdev_dbg(dev, \"Stuff error\\n\");\n\t\t\trx_errors = true;\n\t\t\tif (skb)\n\t\t\t\tcf->data[2] |= CAN_ERR_PROT_STUFF;\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (skb)\n\t\t\t\tdev_kfree_skb(skb);\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (rx_errors)\n\t\tdev->stats.rx_errors++;\n\n\tif (rx_over_errors)\n\t\tdev->stats.rx_over_errors++;\n\n\tif (tx_errors)\n\t\tdev->stats.tx_errors++;\n\n\tif (skb)\n\t\tnetif_rx(skb);\n}\n\nstatic void slcan_bump(struct slcan *sl)\n{\n\tswitch (sl->rbuff[0]) {\n\tcase 'r':\n\t\tfallthrough;\n\tcase 't':\n\t\tfallthrough;\n\tcase 'R':\n\t\tfallthrough;\n\tcase 'T':\n\t\treturn slcan_bump_frame(sl);\n\tcase 'e':\n\t\treturn slcan_bump_err(sl);\n\tcase 's':\n\t\treturn slcan_bump_state(sl);\n\tdefault:\n\t\treturn;\n\t}\n}\n\n \nstatic void slcan_unesc(struct slcan *sl, unsigned char s)\n{\n\tif ((s == '\\r') || (s == '\\a')) {  \n\t\tif (!test_and_clear_bit(SLF_ERROR, &sl->flags) &&\n\t\t    sl->rcount > 4)\n\t\t\tslcan_bump(sl);\n\n\t\tsl->rcount = 0;\n\t} else {\n\t\tif (!test_bit(SLF_ERROR, &sl->flags))  {\n\t\t\tif (sl->rcount < SLCAN_MTU)  {\n\t\t\t\tsl->rbuff[sl->rcount++] = s;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tsl->dev->stats.rx_over_errors++;\n\t\t\tset_bit(SLF_ERROR, &sl->flags);\n\t\t}\n\t}\n}\n\n \n\n \nstatic void slcan_encaps(struct slcan *sl, struct can_frame *cf)\n{\n\tint actual, i;\n\tunsigned char *pos;\n\tunsigned char *endpos;\n\tcanid_t id = cf->can_id;\n\n\tpos = sl->xbuff;\n\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\t*pos = 'R';  \n\telse\n\t\t*pos = 'T';  \n\n\t \n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\tid &= CAN_EFF_MASK;\n\t\tendpos = pos + SLCAN_EFF_ID_LEN;\n\t} else {\n\t\t*pos |= 0x20;  \n\t\tid &= CAN_SFF_MASK;\n\t\tendpos = pos + SLCAN_SFF_ID_LEN;\n\t}\n\n\t \n\tpos++;\n\twhile (endpos >= pos) {\n\t\t*endpos-- = hex_asc_upper[id & 0xf];\n\t\tid >>= 4;\n\t}\n\n\tpos += (cf->can_id & CAN_EFF_FLAG) ?\n\t\tSLCAN_EFF_ID_LEN : SLCAN_SFF_ID_LEN;\n\n\t*pos++ = cf->len + '0';\n\n\t \n\tif (!(cf->can_id & CAN_RTR_FLAG)) {\n\t\tfor (i = 0; i < cf->len; i++)\n\t\t\tpos = hex_byte_pack_upper(pos, cf->data[i]);\n\n\t\tsl->dev->stats.tx_bytes += cf->len;\n\t}\n\n\t*pos++ = '\\r';\n\n\t \n\tset_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\n\tactual = sl->tty->ops->write(sl->tty, sl->xbuff, pos - sl->xbuff);\n\tsl->xleft = (pos - sl->xbuff) - actual;\n\tsl->xhead = sl->xbuff + actual;\n}\n\n \nstatic void slcan_transmit(struct work_struct *work)\n{\n\tstruct slcan *sl = container_of(work, struct slcan, tx_work);\n\tint actual;\n\n\tspin_lock_bh(&sl->lock);\n\t \n\tif (unlikely(!netif_running(sl->dev)) &&\n\t    likely(!test_bit(SLF_XCMD, &sl->flags))) {\n\t\tspin_unlock_bh(&sl->lock);\n\t\treturn;\n\t}\n\n\tif (sl->xleft <= 0)  {\n\t\tif (unlikely(test_bit(SLF_XCMD, &sl->flags))) {\n\t\t\tclear_bit(SLF_XCMD, &sl->flags);\n\t\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\n\t\t\tspin_unlock_bh(&sl->lock);\n\t\t\twake_up(&sl->xcmd_wait);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tsl->dev->stats.tx_packets++;\n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\n\t\tspin_unlock_bh(&sl->lock);\n\t\tnetif_wake_queue(sl->dev);\n\t\treturn;\n\t}\n\n\tactual = sl->tty->ops->write(sl->tty, sl->xhead, sl->xleft);\n\tsl->xleft -= actual;\n\tsl->xhead += actual;\n\tspin_unlock_bh(&sl->lock);\n}\n\n \nstatic void slcan_write_wakeup(struct tty_struct *tty)\n{\n\tstruct slcan *sl = tty->disc_data;\n\n\tschedule_work(&sl->tx_work);\n}\n\n \nstatic netdev_tx_t slcan_netdev_xmit(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev)\n{\n\tstruct slcan *sl = netdev_priv(dev);\n\n\tif (can_dev_dropped_skb(dev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tspin_lock(&sl->lock);\n\tif (!netif_running(dev))  {\n\t\tspin_unlock(&sl->lock);\n\t\tnetdev_warn(dev, \"xmit: iface is down\\n\");\n\t\tgoto out;\n\t}\n\tif (!sl->tty) {\n\t\tspin_unlock(&sl->lock);\n\t\tgoto out;\n\t}\n\n\tnetif_stop_queue(sl->dev);\n\tslcan_encaps(sl, (struct can_frame *)skb->data);  \n\tspin_unlock(&sl->lock);\n\n\tskb_tx_timestamp(skb);\n\nout:\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\n \n\nstatic int slcan_transmit_cmd(struct slcan *sl, const unsigned char *cmd)\n{\n\tint ret, actual, n;\n\n\tspin_lock(&sl->lock);\n\tif (!sl->tty) {\n\t\tspin_unlock(&sl->lock);\n\t\treturn -ENODEV;\n\t}\n\n\tn = scnprintf(sl->xbuff, sizeof(sl->xbuff), \"%s\", cmd);\n\tset_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\n\tactual = sl->tty->ops->write(sl->tty, sl->xbuff, n);\n\tsl->xleft = n - actual;\n\tsl->xhead = sl->xbuff + actual;\n\tset_bit(SLF_XCMD, &sl->flags);\n\tspin_unlock(&sl->lock);\n\tret = wait_event_interruptible_timeout(sl->xcmd_wait,\n\t\t\t\t\t       !test_bit(SLF_XCMD, &sl->flags),\n\t\t\t\t\t       HZ);\n\tclear_bit(SLF_XCMD, &sl->flags);\n\tif (ret == -ERESTARTSYS)\n\t\treturn ret;\n\n\tif (ret == 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\n \nstatic int slcan_netdev_close(struct net_device *dev)\n{\n\tstruct slcan *sl = netdev_priv(dev);\n\tint err;\n\n\tif (sl->can.bittiming.bitrate &&\n\t    sl->can.bittiming.bitrate != CAN_BITRATE_UNKNOWN) {\n\t\terr = slcan_transmit_cmd(sl, \"C\\r\");\n\t\tif (err)\n\t\t\tnetdev_warn(dev,\n\t\t\t\t    \"failed to send close command 'C\\\\r'\\n\");\n\t}\n\n\t \n\tclear_bit(TTY_DO_WRITE_WAKEUP, &sl->tty->flags);\n\tflush_work(&sl->tx_work);\n\n\tnetif_stop_queue(dev);\n\tsl->rcount   = 0;\n\tsl->xleft    = 0;\n\tclose_candev(dev);\n\tsl->can.state = CAN_STATE_STOPPED;\n\tif (sl->can.bittiming.bitrate == CAN_BITRATE_UNKNOWN)\n\t\tsl->can.bittiming.bitrate = CAN_BITRATE_UNSET;\n\n\treturn 0;\n}\n\n \nstatic int slcan_netdev_open(struct net_device *dev)\n{\n\tstruct slcan *sl = netdev_priv(dev);\n\tunsigned char cmd[SLCAN_MTU];\n\tint err, s;\n\n\t \n\tif (sl->can.bittiming.bitrate == CAN_BITRATE_UNSET)\n\t\tsl->can.bittiming.bitrate = CAN_BITRATE_UNKNOWN;\n\n\terr = open_candev(dev);\n\tif (err) {\n\t\tnetdev_err(dev, \"failed to open can device\\n\");\n\t\treturn err;\n\t}\n\n\tif (sl->can.bittiming.bitrate != CAN_BITRATE_UNKNOWN) {\n\t\tfor (s = 0; s < ARRAY_SIZE(slcan_bitrate_const); s++) {\n\t\t\tif (sl->can.bittiming.bitrate == slcan_bitrate_const[s])\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tsnprintf(cmd, sizeof(cmd), \"C\\rS%d\\r\", s);\n\t\terr = slcan_transmit_cmd(sl, cmd);\n\t\tif (err) {\n\t\t\tnetdev_err(dev,\n\t\t\t\t   \"failed to send bitrate command 'C\\\\rS%d\\\\r'\\n\",\n\t\t\t\t   s);\n\t\t\tgoto cmd_transmit_failed;\n\t\t}\n\n\t\tif (test_bit(CF_ERR_RST, &sl->cmd_flags)) {\n\t\t\terr = slcan_transmit_cmd(sl, \"F\\r\");\n\t\t\tif (err) {\n\t\t\t\tnetdev_err(dev,\n\t\t\t\t\t   \"failed to send error command 'F\\\\r'\\n\");\n\t\t\t\tgoto cmd_transmit_failed;\n\t\t\t}\n\t\t}\n\n\t\tif (sl->can.ctrlmode & CAN_CTRLMODE_LISTENONLY) {\n\t\t\terr = slcan_transmit_cmd(sl, \"L\\r\");\n\t\t\tif (err) {\n\t\t\t\tnetdev_err(dev,\n\t\t\t\t\t   \"failed to send listen-only command 'L\\\\r'\\n\");\n\t\t\t\tgoto cmd_transmit_failed;\n\t\t\t}\n\t\t} else {\n\t\t\terr = slcan_transmit_cmd(sl, \"O\\r\");\n\t\t\tif (err) {\n\t\t\t\tnetdev_err(dev,\n\t\t\t\t\t   \"failed to send open command 'O\\\\r'\\n\");\n\t\t\t\tgoto cmd_transmit_failed;\n\t\t\t}\n\t\t}\n\t}\n\n\tsl->can.state = CAN_STATE_ERROR_ACTIVE;\n\tnetif_start_queue(dev);\n\treturn 0;\n\ncmd_transmit_failed:\n\tclose_candev(dev);\n\treturn err;\n}\n\nstatic const struct net_device_ops slcan_netdev_ops = {\n\t.ndo_open               = slcan_netdev_open,\n\t.ndo_stop               = slcan_netdev_close,\n\t.ndo_start_xmit         = slcan_netdev_xmit,\n\t.ndo_change_mtu         = can_change_mtu,\n};\n\n \n\n \nstatic void slcan_receive_buf(struct tty_struct *tty, const u8 *cp,\n\t\t\t      const u8 *fp, size_t count)\n{\n\tstruct slcan *sl = tty->disc_data;\n\n\tif (!netif_running(sl->dev))\n\t\treturn;\n\n\t \n\twhile (count--) {\n\t\tif (fp && *fp++) {\n\t\t\tif (!test_and_set_bit(SLF_ERROR, &sl->flags))\n\t\t\t\tsl->dev->stats.rx_errors++;\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\tslcan_unesc(sl, *cp++);\n\t}\n}\n\n \nstatic int slcan_open(struct tty_struct *tty)\n{\n\tstruct net_device *dev;\n\tstruct slcan *sl;\n\tint err;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!tty->ops->write)\n\t\treturn -EOPNOTSUPP;\n\n\tdev = alloc_candev(sizeof(*sl), 1);\n\tif (!dev)\n\t\treturn -ENFILE;\n\n\tsl = netdev_priv(dev);\n\n\t \n\ttty->receive_room = 65536;  \n\tsl->rcount = 0;\n\tsl->xleft = 0;\n\tspin_lock_init(&sl->lock);\n\tINIT_WORK(&sl->tx_work, slcan_transmit);\n\tinit_waitqueue_head(&sl->xcmd_wait);\n\n\t \n\tsl->can.bitrate_const = slcan_bitrate_const;\n\tsl->can.bitrate_const_cnt = ARRAY_SIZE(slcan_bitrate_const);\n\tsl->can.ctrlmode_supported = CAN_CTRLMODE_LISTENONLY;\n\n\t \n\tsl->dev\t= dev;\n\tdev->netdev_ops = &slcan_netdev_ops;\n\tdev->ethtool_ops = &slcan_ethtool_ops;\n\n\t \n\tsl->tty = tty;\n\ttty->disc_data = sl;\n\n\terr = register_candev(dev);\n\tif (err) {\n\t\tfree_candev(dev);\n\t\tpr_err(\"can't register candev\\n\");\n\t\treturn err;\n\t}\n\n\tnetdev_info(dev, \"slcan on %s.\\n\", tty->name);\n\t \n\treturn 0;\n}\n\n \nstatic void slcan_close(struct tty_struct *tty)\n{\n\tstruct slcan *sl = tty->disc_data;\n\n\tunregister_candev(sl->dev);\n\n\t \n\tflush_work(&sl->tx_work);\n\n\t \n\tspin_lock_bh(&sl->lock);\n\ttty->disc_data = NULL;\n\tsl->tty = NULL;\n\tspin_unlock_bh(&sl->lock);\n\n\tnetdev_info(sl->dev, \"slcan off %s.\\n\", tty->name);\n\tfree_candev(sl->dev);\n}\n\n \nstatic int slcan_ioctl(struct tty_struct *tty, unsigned int cmd,\n\t\t       unsigned long arg)\n{\n\tstruct slcan *sl = tty->disc_data;\n\tunsigned int tmp;\n\n\tswitch (cmd) {\n\tcase SIOCGIFNAME:\n\t\ttmp = strlen(sl->dev->name) + 1;\n\t\tif (copy_to_user((void __user *)arg, sl->dev->name, tmp))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase SIOCSIFHWADDR:\n\t\treturn -EINVAL;\n\n\tdefault:\n\t\treturn tty_mode_ioctl(tty, cmd, arg);\n\t}\n}\n\nstatic struct tty_ldisc_ops slcan_ldisc = {\n\t.owner\t\t= THIS_MODULE,\n\t.num\t\t= N_SLCAN,\n\t.name\t\t= KBUILD_MODNAME,\n\t.open\t\t= slcan_open,\n\t.close\t\t= slcan_close,\n\t.ioctl\t\t= slcan_ioctl,\n\t.receive_buf\t= slcan_receive_buf,\n\t.write_wakeup\t= slcan_write_wakeup,\n};\n\nstatic int __init slcan_init(void)\n{\n\tint status;\n\n\tpr_info(\"serial line CAN interface driver\\n\");\n\n\t \n\tstatus = tty_register_ldisc(&slcan_ldisc);\n\tif (status)\n\t\tpr_err(\"can't register line discipline\\n\");\n\n\treturn status;\n}\n\nstatic void __exit slcan_exit(void)\n{\n\t \n\ttty_unregister_ldisc(&slcan_ldisc);\n}\n\nmodule_init(slcan_init);\nmodule_exit(slcan_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}