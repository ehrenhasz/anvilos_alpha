{
  "module_name": "xilinx_can.c",
  "hash_id": "eaf64d98e08bec40e57abcc23c6735eca0eded89ca25f2542665b6e79f2ee619",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/xilinx_can.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/errno.h>\n#include <linux/ethtool.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n#include <linux/phy/phy.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n#define DRIVER_NAME\t\"xilinx_can\"\n\n \nenum xcan_reg {\n\tXCAN_SRR_OFFSET\t\t= 0x00,  \n\tXCAN_MSR_OFFSET\t\t= 0x04,  \n\tXCAN_BRPR_OFFSET\t= 0x08,  \n\tXCAN_BTR_OFFSET\t\t= 0x0C,  \n\tXCAN_ECR_OFFSET\t\t= 0x10,  \n\tXCAN_ESR_OFFSET\t\t= 0x14,  \n\tXCAN_SR_OFFSET\t\t= 0x18,  \n\tXCAN_ISR_OFFSET\t\t= 0x1C,  \n\tXCAN_IER_OFFSET\t\t= 0x20,  \n\tXCAN_ICR_OFFSET\t\t= 0x24,  \n\n\t \n\tXCAN_TXFIFO_OFFSET\t= 0x30,  \n\tXCAN_RXFIFO_OFFSET\t= 0x50,  \n\tXCAN_AFR_OFFSET\t\t= 0x60,  \n\n\t \n\tXCAN_F_BRPR_OFFSET\t= 0x088,  \n\tXCAN_F_BTR_OFFSET\t= 0x08C,  \n\tXCAN_TRR_OFFSET\t\t= 0x0090,  \n\tXCAN_AFR_EXT_OFFSET\t= 0x00E0,  \n\tXCAN_FSR_OFFSET\t\t= 0x00E8,  \n\tXCAN_TXMSG_BASE_OFFSET\t= 0x0100,  \n\tXCAN_RXMSG_BASE_OFFSET\t= 0x1100,  \n\tXCAN_RXMSG_2_BASE_OFFSET\t= 0x2100,  \n\tXCAN_AFR_2_MASK_OFFSET\t= 0x0A00,  \n\tXCAN_AFR_2_ID_OFFSET\t= 0x0A04,  \n};\n\n#define XCAN_FRAME_ID_OFFSET(frame_base)\t((frame_base) + 0x00)\n#define XCAN_FRAME_DLC_OFFSET(frame_base)\t((frame_base) + 0x04)\n#define XCAN_FRAME_DW1_OFFSET(frame_base)\t((frame_base) + 0x08)\n#define XCAN_FRAME_DW2_OFFSET(frame_base)\t((frame_base) + 0x0C)\n#define XCANFD_FRAME_DW_OFFSET(frame_base)\t((frame_base) + 0x08)\n\n#define XCAN_CANFD_FRAME_SIZE\t\t0x48\n#define XCAN_TXMSG_FRAME_OFFSET(n)\t(XCAN_TXMSG_BASE_OFFSET + \\\n\t\t\t\t\t XCAN_CANFD_FRAME_SIZE * (n))\n#define XCAN_RXMSG_FRAME_OFFSET(n)\t(XCAN_RXMSG_BASE_OFFSET + \\\n\t\t\t\t\t XCAN_CANFD_FRAME_SIZE * (n))\n#define XCAN_RXMSG_2_FRAME_OFFSET(n)\t(XCAN_RXMSG_2_BASE_OFFSET + \\\n\t\t\t\t\t XCAN_CANFD_FRAME_SIZE * (n))\n\n \n#define XCAN_TX_MAILBOX_IDX\t\t0\n\n \n#define XCAN_SRR_CEN_MASK\t\t0x00000002  \n#define XCAN_SRR_RESET_MASK\t\t0x00000001  \n#define XCAN_MSR_LBACK_MASK\t\t0x00000002  \n#define XCAN_MSR_SLEEP_MASK\t\t0x00000001  \n#define XCAN_BRPR_BRP_MASK\t\t0x000000FF  \n#define XCAN_BRPR_TDCO_MASK\t\tGENMASK(12, 8)   \n#define XCAN_2_BRPR_TDCO_MASK\t\tGENMASK(13, 8)   \n#define XCAN_BTR_SJW_MASK\t\t0x00000180  \n#define XCAN_BTR_TS2_MASK\t\t0x00000070  \n#define XCAN_BTR_TS1_MASK\t\t0x0000000F  \n#define XCAN_BTR_SJW_MASK_CANFD\t\t0x000F0000  \n#define XCAN_BTR_TS2_MASK_CANFD\t\t0x00000F00  \n#define XCAN_BTR_TS1_MASK_CANFD\t\t0x0000003F  \n#define XCAN_ECR_REC_MASK\t\t0x0000FF00  \n#define XCAN_ECR_TEC_MASK\t\t0x000000FF  \n#define XCAN_ESR_ACKER_MASK\t\t0x00000010  \n#define XCAN_ESR_BERR_MASK\t\t0x00000008  \n#define XCAN_ESR_STER_MASK\t\t0x00000004  \n#define XCAN_ESR_FMER_MASK\t\t0x00000002  \n#define XCAN_ESR_CRCER_MASK\t\t0x00000001  \n#define XCAN_SR_TDCV_MASK\t\tGENMASK(22, 16)  \n#define XCAN_SR_TXFLL_MASK\t\t0x00000400  \n#define XCAN_SR_ESTAT_MASK\t\t0x00000180  \n#define XCAN_SR_ERRWRN_MASK\t\t0x00000040  \n#define XCAN_SR_NORMAL_MASK\t\t0x00000008  \n#define XCAN_SR_LBACK_MASK\t\t0x00000002  \n#define XCAN_SR_CONFIG_MASK\t\t0x00000001  \n#define XCAN_IXR_RXMNF_MASK\t\t0x00020000  \n#define XCAN_IXR_TXFEMP_MASK\t\t0x00004000  \n#define XCAN_IXR_WKUP_MASK\t\t0x00000800  \n#define XCAN_IXR_SLP_MASK\t\t0x00000400  \n#define XCAN_IXR_BSOFF_MASK\t\t0x00000200  \n#define XCAN_IXR_ERROR_MASK\t\t0x00000100  \n#define XCAN_IXR_RXNEMP_MASK\t\t0x00000080  \n#define XCAN_IXR_RXOFLW_MASK\t\t0x00000040  \n#define XCAN_IXR_RXOK_MASK\t\t0x00000010  \n#define XCAN_IXR_TXFLL_MASK\t\t0x00000004  \n#define XCAN_IXR_TXOK_MASK\t\t0x00000002  \n#define XCAN_IXR_ARBLST_MASK\t\t0x00000001  \n#define XCAN_IDR_ID1_MASK\t\t0xFFE00000  \n#define XCAN_IDR_SRR_MASK\t\t0x00100000  \n#define XCAN_IDR_IDE_MASK\t\t0x00080000  \n#define XCAN_IDR_ID2_MASK\t\t0x0007FFFE  \n#define XCAN_IDR_RTR_MASK\t\t0x00000001  \n#define XCAN_DLCR_DLC_MASK\t\t0xF0000000  \n#define XCAN_FSR_FL_MASK\t\t0x00003F00  \n#define XCAN_2_FSR_FL_MASK\t\t0x00007F00  \n#define XCAN_FSR_IRI_MASK\t\t0x00000080  \n#define XCAN_FSR_RI_MASK\t\t0x0000001F  \n#define XCAN_2_FSR_RI_MASK\t\t0x0000003F  \n#define XCAN_DLCR_EDL_MASK\t\t0x08000000  \n#define XCAN_DLCR_BRS_MASK\t\t0x04000000  \n\n \n#define XCAN_BRPR_TDC_ENABLE\t\tBIT(16)  \n#define XCAN_BTR_SJW_SHIFT\t\t7   \n#define XCAN_BTR_TS2_SHIFT\t\t4   \n#define XCAN_BTR_SJW_SHIFT_CANFD\t16  \n#define XCAN_BTR_TS2_SHIFT_CANFD\t8   \n#define XCAN_IDR_ID1_SHIFT\t\t21  \n#define XCAN_IDR_ID2_SHIFT\t\t1   \n#define XCAN_DLCR_DLC_SHIFT\t\t28  \n#define XCAN_ESR_REC_SHIFT\t\t8   \n\n \n#define XCAN_FRAME_MAX_DATA_LEN\t\t8\n#define XCANFD_DW_BYTES\t\t\t4\n#define XCAN_TIMEOUT\t\t\t(1 * HZ)\n\n \n#define XCAN_FLAG_TXFEMP\t0x0001\n \n#define XCAN_FLAG_RXMNF\t\t0x0002\n \n#define XCAN_FLAG_EXT_FILTERS\t0x0004\n \n#define XCAN_FLAG_TX_MAILBOXES\t0x0008\n \n#define XCAN_FLAG_RX_FIFO_MULTI\t0x0010\n#define XCAN_FLAG_CANFD_2\t0x0020\n\nenum xcan_ip_type {\n\tXAXI_CAN = 0,\n\tXZYNQ_CANPS,\n\tXAXI_CANFD,\n\tXAXI_CANFD_2_0,\n};\n\nstruct xcan_devtype_data {\n\tenum xcan_ip_type cantype;\n\tunsigned int flags;\n\tconst struct can_bittiming_const *bittiming_const;\n\tconst char *bus_clk_name;\n\tunsigned int btr_ts2_shift;\n\tunsigned int btr_sjw_shift;\n};\n\n \nstruct xcan_priv {\n\tstruct can_priv can;\n\tspinlock_t tx_lock;  \n\tunsigned int tx_head;\n\tunsigned int tx_tail;\n\tunsigned int tx_max;\n\tstruct napi_struct napi;\n\tu32 (*read_reg)(const struct xcan_priv *priv, enum xcan_reg reg);\n\tvoid (*write_reg)(const struct xcan_priv *priv, enum xcan_reg reg,\n\t\t\t  u32 val);\n\tstruct device *dev;\n\tvoid __iomem *reg_base;\n\tunsigned long irq_flags;\n\tstruct clk *bus_clk;\n\tstruct clk *can_clk;\n\tstruct xcan_devtype_data devtype;\n\tstruct phy *transceiver;\n\tstruct reset_control *rstc;\n};\n\n \nstatic const struct can_bittiming_const xcan_bittiming_const = {\n\t.name = DRIVER_NAME,\n\t.tseg1_min = 1,\n\t.tseg1_max = 16,\n\t.tseg2_min = 1,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 256,\n\t.brp_inc = 1,\n};\n\n \nstatic const struct can_bittiming_const xcan_bittiming_const_canfd = {\n\t.name = DRIVER_NAME,\n\t.tseg1_min = 1,\n\t.tseg1_max = 64,\n\t.tseg2_min = 1,\n\t.tseg2_max = 16,\n\t.sjw_max = 16,\n\t.brp_min = 1,\n\t.brp_max = 256,\n\t.brp_inc = 1,\n};\n\n \nstatic const struct can_bittiming_const xcan_data_bittiming_const_canfd = {\n\t.name = DRIVER_NAME,\n\t.tseg1_min = 1,\n\t.tseg1_max = 16,\n\t.tseg2_min = 1,\n\t.tseg2_max = 8,\n\t.sjw_max = 8,\n\t.brp_min = 1,\n\t.brp_max = 256,\n\t.brp_inc = 1,\n};\n\n \nstatic const struct can_bittiming_const xcan_bittiming_const_canfd2 = {\n\t.name = DRIVER_NAME,\n\t.tseg1_min = 1,\n\t.tseg1_max = 256,\n\t.tseg2_min = 1,\n\t.tseg2_max = 128,\n\t.sjw_max = 128,\n\t.brp_min = 1,\n\t.brp_max = 256,\n\t.brp_inc = 1,\n};\n\n \nstatic const struct can_bittiming_const xcan_data_bittiming_const_canfd2 = {\n\t.name = DRIVER_NAME,\n\t.tseg1_min = 1,\n\t.tseg1_max = 32,\n\t.tseg2_min = 1,\n\t.tseg2_max = 16,\n\t.sjw_max = 16,\n\t.brp_min = 1,\n\t.brp_max = 256,\n\t.brp_inc = 1,\n};\n\n \nstatic const struct can_tdc_const xcan_tdc_const_canfd = {\n\t.tdcv_min = 0,\n\t.tdcv_max = 0,  \n\t.tdco_min = 0,\n\t.tdco_max = 32,\n\t.tdcf_min = 0,  \n\t.tdcf_max = 0,\n};\n\n \nstatic const struct can_tdc_const xcan_tdc_const_canfd2 = {\n\t.tdcv_min = 0,\n\t.tdcv_max = 0,  \n\t.tdco_min = 0,\n\t.tdco_max = 64,\n\t.tdcf_min = 0,  \n\t.tdcf_max = 0,\n};\n\n \nstatic void xcan_write_reg_le(const struct xcan_priv *priv, enum xcan_reg reg,\n\t\t\t      u32 val)\n{\n\tiowrite32(val, priv->reg_base + reg);\n}\n\n \nstatic u32 xcan_read_reg_le(const struct xcan_priv *priv, enum xcan_reg reg)\n{\n\treturn ioread32(priv->reg_base + reg);\n}\n\n \nstatic void xcan_write_reg_be(const struct xcan_priv *priv, enum xcan_reg reg,\n\t\t\t      u32 val)\n{\n\tiowrite32be(val, priv->reg_base + reg);\n}\n\n \nstatic u32 xcan_read_reg_be(const struct xcan_priv *priv, enum xcan_reg reg)\n{\n\treturn ioread32be(priv->reg_base + reg);\n}\n\n \nstatic u32 xcan_rx_int_mask(const struct xcan_priv *priv)\n{\n\t \n\tif (priv->devtype.flags & XCAN_FLAG_RX_FIFO_MULTI)\n\t\treturn XCAN_IXR_RXOK_MASK;\n\telse\n\t\treturn XCAN_IXR_RXNEMP_MASK;\n}\n\n \nstatic int set_reset_mode(struct net_device *ndev)\n{\n\tstruct xcan_priv *priv = netdev_priv(ndev);\n\tunsigned long timeout;\n\n\tpriv->write_reg(priv, XCAN_SRR_OFFSET, XCAN_SRR_RESET_MASK);\n\n\ttimeout = jiffies + XCAN_TIMEOUT;\n\twhile (!(priv->read_reg(priv, XCAN_SR_OFFSET) & XCAN_SR_CONFIG_MASK)) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tnetdev_warn(ndev, \"timed out for config mode\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tusleep_range(500, 10000);\n\t}\n\n\t \n\tpriv->tx_head = 0;\n\tpriv->tx_tail = 0;\n\n\treturn 0;\n}\n\n \nstatic int xcan_set_bittiming(struct net_device *ndev)\n{\n\tstruct xcan_priv *priv = netdev_priv(ndev);\n\tstruct can_bittiming *bt = &priv->can.bittiming;\n\tstruct can_bittiming *dbt = &priv->can.data_bittiming;\n\tu32 btr0, btr1;\n\tu32 is_config_mode;\n\n\t \n\tis_config_mode = priv->read_reg(priv, XCAN_SR_OFFSET) &\n\t\t\t\tXCAN_SR_CONFIG_MASK;\n\tif (!is_config_mode) {\n\t\tnetdev_alert(ndev,\n\t\t\t     \"BUG! Cannot set bittiming - CAN is not in config mode\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t \n\tbtr0 = (bt->brp - 1);\n\n\t \n\tbtr1 = (bt->prop_seg + bt->phase_seg1 - 1);\n\n\t \n\tbtr1 |= (bt->phase_seg2 - 1) << priv->devtype.btr_ts2_shift;\n\n\t \n\tbtr1 |= (bt->sjw - 1) << priv->devtype.btr_sjw_shift;\n\n\tpriv->write_reg(priv, XCAN_BRPR_OFFSET, btr0);\n\tpriv->write_reg(priv, XCAN_BTR_OFFSET, btr1);\n\n\tif (priv->devtype.cantype == XAXI_CANFD ||\n\t    priv->devtype.cantype == XAXI_CANFD_2_0) {\n\t\t \n\t\tbtr0 = dbt->brp - 1;\n\t\tif (can_tdc_is_enabled(&priv->can)) {\n\t\t\tif (priv->devtype.cantype == XAXI_CANFD)\n\t\t\t\tbtr0 |= FIELD_PREP(XCAN_BRPR_TDCO_MASK, priv->can.tdc.tdco) |\n\t\t\t\t\tXCAN_BRPR_TDC_ENABLE;\n\t\t\telse\n\t\t\t\tbtr0 |= FIELD_PREP(XCAN_2_BRPR_TDCO_MASK, priv->can.tdc.tdco) |\n\t\t\t\t\tXCAN_BRPR_TDC_ENABLE;\n\t\t}\n\n\t\t \n\t\tbtr1 = dbt->prop_seg + dbt->phase_seg1 - 1;\n\n\t\t \n\t\tbtr1 |= (dbt->phase_seg2 - 1) << priv->devtype.btr_ts2_shift;\n\n\t\t \n\t\tbtr1 |= (dbt->sjw - 1) << priv->devtype.btr_sjw_shift;\n\n\t\tpriv->write_reg(priv, XCAN_F_BRPR_OFFSET, btr0);\n\t\tpriv->write_reg(priv, XCAN_F_BTR_OFFSET, btr1);\n\t}\n\n\tnetdev_dbg(ndev, \"BRPR=0x%08x, BTR=0x%08x\\n\",\n\t\t   priv->read_reg(priv, XCAN_BRPR_OFFSET),\n\t\t   priv->read_reg(priv, XCAN_BTR_OFFSET));\n\n\treturn 0;\n}\n\n \nstatic int xcan_chip_start(struct net_device *ndev)\n{\n\tstruct xcan_priv *priv = netdev_priv(ndev);\n\tu32 reg_msr;\n\tint err;\n\tu32 ier;\n\n\t \n\terr = set_reset_mode(ndev);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = xcan_set_bittiming(ndev);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tier = XCAN_IXR_TXOK_MASK | XCAN_IXR_BSOFF_MASK |\n\t\tXCAN_IXR_WKUP_MASK | XCAN_IXR_SLP_MASK |\n\t\tXCAN_IXR_ERROR_MASK | XCAN_IXR_RXOFLW_MASK |\n\t\tXCAN_IXR_ARBLST_MASK | xcan_rx_int_mask(priv);\n\n\tif (priv->devtype.flags & XCAN_FLAG_RXMNF)\n\t\tier |= XCAN_IXR_RXMNF_MASK;\n\n\tpriv->write_reg(priv, XCAN_IER_OFFSET, ier);\n\n\t \n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)\n\t\treg_msr = XCAN_MSR_LBACK_MASK;\n\telse\n\t\treg_msr = 0x0;\n\n\t \n\tif (priv->devtype.flags & XCAN_FLAG_EXT_FILTERS)\n\t\tpriv->write_reg(priv, XCAN_AFR_EXT_OFFSET, 0x00000001);\n\n\tpriv->write_reg(priv, XCAN_MSR_OFFSET, reg_msr);\n\tpriv->write_reg(priv, XCAN_SRR_OFFSET, XCAN_SRR_CEN_MASK);\n\n\tnetdev_dbg(ndev, \"status:#x%08x\\n\",\n\t\t   priv->read_reg(priv, XCAN_SR_OFFSET));\n\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\treturn 0;\n}\n\n \nstatic int xcan_do_set_mode(struct net_device *ndev, enum can_mode mode)\n{\n\tint ret;\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\tret = xcan_chip_start(ndev);\n\t\tif (ret < 0) {\n\t\t\tnetdev_err(ndev, \"xcan_chip_start failed!\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tnetif_wake_queue(ndev);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic void xcan_write_frame(struct net_device *ndev, struct sk_buff *skb,\n\t\t\t     int frame_offset)\n{\n\tu32 id, dlc, data[2] = {0, 0};\n\tstruct canfd_frame *cf = (struct canfd_frame *)skb->data;\n\tu32 ramoff, dwindex = 0, i;\n\tstruct xcan_priv *priv = netdev_priv(ndev);\n\n\t \n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\t \n\t\tid = ((cf->can_id & CAN_EFF_MASK) << XCAN_IDR_ID2_SHIFT) &\n\t\t\tXCAN_IDR_ID2_MASK;\n\t\tid |= (((cf->can_id & CAN_EFF_MASK) >>\n\t\t\t(CAN_EFF_ID_BITS - CAN_SFF_ID_BITS)) <<\n\t\t\tXCAN_IDR_ID1_SHIFT) & XCAN_IDR_ID1_MASK;\n\n\t\t \n\t\tid |= XCAN_IDR_IDE_MASK | XCAN_IDR_SRR_MASK;\n\n\t\tif (cf->can_id & CAN_RTR_FLAG)\n\t\t\t \n\t\t\tid |= XCAN_IDR_RTR_MASK;\n\t} else {\n\t\t \n\t\tid = ((cf->can_id & CAN_SFF_MASK) << XCAN_IDR_ID1_SHIFT) &\n\t\t\tXCAN_IDR_ID1_MASK;\n\n\t\tif (cf->can_id & CAN_RTR_FLAG)\n\t\t\t \n\t\t\tid |= XCAN_IDR_SRR_MASK;\n\t}\n\n\tdlc = can_fd_len2dlc(cf->len) << XCAN_DLCR_DLC_SHIFT;\n\tif (can_is_canfd_skb(skb)) {\n\t\tif (cf->flags & CANFD_BRS)\n\t\t\tdlc |= XCAN_DLCR_BRS_MASK;\n\t\tdlc |= XCAN_DLCR_EDL_MASK;\n\t}\n\n\tif (!(priv->devtype.flags & XCAN_FLAG_TX_MAILBOXES) &&\n\t    (priv->devtype.flags & XCAN_FLAG_TXFEMP))\n\t\tcan_put_echo_skb(skb, ndev, priv->tx_head % priv->tx_max, 0);\n\telse\n\t\tcan_put_echo_skb(skb, ndev, 0, 0);\n\n\tpriv->tx_head++;\n\n\tpriv->write_reg(priv, XCAN_FRAME_ID_OFFSET(frame_offset), id);\n\t \n\tpriv->write_reg(priv, XCAN_FRAME_DLC_OFFSET(frame_offset), dlc);\n\tif (priv->devtype.cantype == XAXI_CANFD ||\n\t    priv->devtype.cantype == XAXI_CANFD_2_0) {\n\t\tfor (i = 0; i < cf->len; i += 4) {\n\t\t\tramoff = XCANFD_FRAME_DW_OFFSET(frame_offset) +\n\t\t\t\t\t(dwindex * XCANFD_DW_BYTES);\n\t\t\tpriv->write_reg(priv, ramoff,\n\t\t\t\t\tbe32_to_cpup((__be32 *)(cf->data + i)));\n\t\t\tdwindex++;\n\t\t}\n\t} else {\n\t\tif (cf->len > 0)\n\t\t\tdata[0] = be32_to_cpup((__be32 *)(cf->data + 0));\n\t\tif (cf->len > 4)\n\t\t\tdata[1] = be32_to_cpup((__be32 *)(cf->data + 4));\n\n\t\tif (!(cf->can_id & CAN_RTR_FLAG)) {\n\t\t\tpriv->write_reg(priv,\n\t\t\t\t\tXCAN_FRAME_DW1_OFFSET(frame_offset),\n\t\t\t\t\tdata[0]);\n\t\t\t \n\t\t\tpriv->write_reg(priv,\n\t\t\t\t\tXCAN_FRAME_DW2_OFFSET(frame_offset),\n\t\t\t\t\tdata[1]);\n\t\t}\n\t}\n}\n\n \nstatic int xcan_start_xmit_fifo(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct xcan_priv *priv = netdev_priv(ndev);\n\tunsigned long flags;\n\n\t \n\tif (unlikely(priv->read_reg(priv, XCAN_SR_OFFSET) &\n\t\t\tXCAN_SR_TXFLL_MASK))\n\t\treturn -ENOSPC;\n\n\tspin_lock_irqsave(&priv->tx_lock, flags);\n\n\txcan_write_frame(ndev, skb, XCAN_TXFIFO_OFFSET);\n\n\t \n\tif (priv->tx_max > 1)\n\t\tpriv->write_reg(priv, XCAN_ICR_OFFSET, XCAN_IXR_TXFEMP_MASK);\n\n\t \n\tif ((priv->tx_head - priv->tx_tail) == priv->tx_max)\n\t\tnetif_stop_queue(ndev);\n\n\tspin_unlock_irqrestore(&priv->tx_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int xcan_start_xmit_mailbox(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct xcan_priv *priv = netdev_priv(ndev);\n\tunsigned long flags;\n\n\tif (unlikely(priv->read_reg(priv, XCAN_TRR_OFFSET) &\n\t\t     BIT(XCAN_TX_MAILBOX_IDX)))\n\t\treturn -ENOSPC;\n\n\tspin_lock_irqsave(&priv->tx_lock, flags);\n\n\txcan_write_frame(ndev, skb,\n\t\t\t XCAN_TXMSG_FRAME_OFFSET(XCAN_TX_MAILBOX_IDX));\n\n\t \n\tpriv->write_reg(priv, XCAN_TRR_OFFSET, BIT(XCAN_TX_MAILBOX_IDX));\n\n\tnetif_stop_queue(ndev);\n\n\tspin_unlock_irqrestore(&priv->tx_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic netdev_tx_t xcan_start_xmit(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct xcan_priv *priv = netdev_priv(ndev);\n\tint ret;\n\n\tif (can_dev_dropped_skb(ndev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tif (priv->devtype.flags & XCAN_FLAG_TX_MAILBOXES)\n\t\tret = xcan_start_xmit_mailbox(skb, ndev);\n\telse\n\t\tret = xcan_start_xmit_fifo(skb, ndev);\n\n\tif (ret < 0) {\n\t\tnetdev_err(ndev, \"BUG!, TX full when queue awake!\\n\");\n\t\tnetif_stop_queue(ndev);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic int xcan_rx(struct net_device *ndev, int frame_base)\n{\n\tstruct xcan_priv *priv = netdev_priv(ndev);\n\tstruct net_device_stats *stats = &ndev->stats;\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tu32 id_xcan, dlc, data[2] = {0, 0};\n\n\tskb = alloc_can_skb(ndev, &cf);\n\tif (unlikely(!skb)) {\n\t\tstats->rx_dropped++;\n\t\treturn 0;\n\t}\n\n\t \n\tid_xcan = priv->read_reg(priv, XCAN_FRAME_ID_OFFSET(frame_base));\n\tdlc = priv->read_reg(priv, XCAN_FRAME_DLC_OFFSET(frame_base)) >>\n\t\t\t\t   XCAN_DLCR_DLC_SHIFT;\n\n\t \n\tcf->len = can_cc_dlc2len(dlc);\n\n\t \n\tif (id_xcan & XCAN_IDR_IDE_MASK) {\n\t\t \n\t\tcf->can_id = (id_xcan & XCAN_IDR_ID1_MASK) >> 3;\n\t\tcf->can_id |= (id_xcan & XCAN_IDR_ID2_MASK) >>\n\t\t\t\tXCAN_IDR_ID2_SHIFT;\n\t\tcf->can_id |= CAN_EFF_FLAG;\n\t\tif (id_xcan & XCAN_IDR_RTR_MASK)\n\t\t\tcf->can_id |= CAN_RTR_FLAG;\n\t} else {\n\t\t \n\t\tcf->can_id = (id_xcan & XCAN_IDR_ID1_MASK) >>\n\t\t\t\tXCAN_IDR_ID1_SHIFT;\n\t\tif (id_xcan & XCAN_IDR_SRR_MASK)\n\t\t\tcf->can_id |= CAN_RTR_FLAG;\n\t}\n\n\t \n\tdata[0] = priv->read_reg(priv, XCAN_FRAME_DW1_OFFSET(frame_base));\n\tdata[1] = priv->read_reg(priv, XCAN_FRAME_DW2_OFFSET(frame_base));\n\n\tif (!(cf->can_id & CAN_RTR_FLAG)) {\n\t\t \n\t\tif (cf->len > 0)\n\t\t\t*(__be32 *)(cf->data) = cpu_to_be32(data[0]);\n\t\tif (cf->len > 4)\n\t\t\t*(__be32 *)(cf->data + 4) = cpu_to_be32(data[1]);\n\n\t\tstats->rx_bytes += cf->len;\n\t}\n\tstats->rx_packets++;\n\n\tnetif_receive_skb(skb);\n\n\treturn 1;\n}\n\n \nstatic int xcanfd_rx(struct net_device *ndev, int frame_base)\n{\n\tstruct xcan_priv *priv = netdev_priv(ndev);\n\tstruct net_device_stats *stats = &ndev->stats;\n\tstruct canfd_frame *cf;\n\tstruct sk_buff *skb;\n\tu32 id_xcan, dlc, data[2] = {0, 0}, dwindex = 0, i, dw_offset;\n\n\tid_xcan = priv->read_reg(priv, XCAN_FRAME_ID_OFFSET(frame_base));\n\tdlc = priv->read_reg(priv, XCAN_FRAME_DLC_OFFSET(frame_base));\n\tif (dlc & XCAN_DLCR_EDL_MASK)\n\t\tskb = alloc_canfd_skb(ndev, &cf);\n\telse\n\t\tskb = alloc_can_skb(ndev, (struct can_frame **)&cf);\n\n\tif (unlikely(!skb)) {\n\t\tstats->rx_dropped++;\n\t\treturn 0;\n\t}\n\n\t \n\tif (dlc & XCAN_DLCR_EDL_MASK)\n\t\tcf->len = can_fd_dlc2len((dlc & XCAN_DLCR_DLC_MASK) >>\n\t\t\t\t  XCAN_DLCR_DLC_SHIFT);\n\telse\n\t\tcf->len = can_cc_dlc2len((dlc & XCAN_DLCR_DLC_MASK) >>\n\t\t\t\t\t  XCAN_DLCR_DLC_SHIFT);\n\n\t \n\tif (id_xcan & XCAN_IDR_IDE_MASK) {\n\t\t \n\t\tcf->can_id = (id_xcan & XCAN_IDR_ID1_MASK) >> 3;\n\t\tcf->can_id |= (id_xcan & XCAN_IDR_ID2_MASK) >>\n\t\t\t\tXCAN_IDR_ID2_SHIFT;\n\t\tcf->can_id |= CAN_EFF_FLAG;\n\t\tif (id_xcan & XCAN_IDR_RTR_MASK)\n\t\t\tcf->can_id |= CAN_RTR_FLAG;\n\t} else {\n\t\t \n\t\tcf->can_id = (id_xcan & XCAN_IDR_ID1_MASK) >>\n\t\t\t\tXCAN_IDR_ID1_SHIFT;\n\t\tif (!(dlc & XCAN_DLCR_EDL_MASK) && (id_xcan &\n\t\t\t\t\tXCAN_IDR_SRR_MASK))\n\t\t\tcf->can_id |= CAN_RTR_FLAG;\n\t}\n\n\t \n\tif (dlc & XCAN_DLCR_EDL_MASK) {\n\t\tfor (i = 0; i < cf->len; i += 4) {\n\t\t\tdw_offset = XCANFD_FRAME_DW_OFFSET(frame_base) +\n\t\t\t\t\t(dwindex * XCANFD_DW_BYTES);\n\t\t\tdata[0] = priv->read_reg(priv, dw_offset);\n\t\t\t*(__be32 *)(cf->data + i) = cpu_to_be32(data[0]);\n\t\t\tdwindex++;\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < cf->len; i += 4) {\n\t\t\tdw_offset = XCANFD_FRAME_DW_OFFSET(frame_base);\n\t\t\tdata[0] = priv->read_reg(priv, dw_offset + i);\n\t\t\t*(__be32 *)(cf->data + i) = cpu_to_be32(data[0]);\n\t\t}\n\t}\n\n\tif (!(cf->can_id & CAN_RTR_FLAG))\n\t\tstats->rx_bytes += cf->len;\n\tstats->rx_packets++;\n\n\tnetif_receive_skb(skb);\n\n\treturn 1;\n}\n\n \nstatic enum can_state xcan_current_error_state(struct net_device *ndev)\n{\n\tstruct xcan_priv *priv = netdev_priv(ndev);\n\tu32 status = priv->read_reg(priv, XCAN_SR_OFFSET);\n\n\tif ((status & XCAN_SR_ESTAT_MASK) == XCAN_SR_ESTAT_MASK)\n\t\treturn CAN_STATE_ERROR_PASSIVE;\n\telse if (status & XCAN_SR_ERRWRN_MASK)\n\t\treturn CAN_STATE_ERROR_WARNING;\n\telse\n\t\treturn CAN_STATE_ERROR_ACTIVE;\n}\n\n \nstatic void xcan_set_error_state(struct net_device *ndev,\n\t\t\t\t enum can_state new_state,\n\t\t\t\t struct can_frame *cf)\n{\n\tstruct xcan_priv *priv = netdev_priv(ndev);\n\tu32 ecr = priv->read_reg(priv, XCAN_ECR_OFFSET);\n\tu32 txerr = ecr & XCAN_ECR_TEC_MASK;\n\tu32 rxerr = (ecr & XCAN_ECR_REC_MASK) >> XCAN_ESR_REC_SHIFT;\n\tenum can_state tx_state = txerr >= rxerr ? new_state : 0;\n\tenum can_state rx_state = txerr <= rxerr ? new_state : 0;\n\n\t \n\tif (WARN_ON(new_state > CAN_STATE_ERROR_PASSIVE))\n\t\treturn;\n\n\tcan_change_state(ndev, cf, tx_state, rx_state);\n\n\tif (cf) {\n\t\tcf->can_id |= CAN_ERR_CNT;\n\t\tcf->data[6] = txerr;\n\t\tcf->data[7] = rxerr;\n\t}\n}\n\n \nstatic void xcan_update_error_state_after_rxtx(struct net_device *ndev)\n{\n\tstruct xcan_priv *priv = netdev_priv(ndev);\n\tenum can_state old_state = priv->can.state;\n\tenum can_state new_state;\n\n\t \n\tif (old_state != CAN_STATE_ERROR_WARNING &&\n\t    old_state != CAN_STATE_ERROR_PASSIVE)\n\t\treturn;\n\n\tnew_state = xcan_current_error_state(ndev);\n\n\tif (new_state != old_state) {\n\t\tstruct sk_buff *skb;\n\t\tstruct can_frame *cf;\n\n\t\tskb = alloc_can_err_skb(ndev, &cf);\n\n\t\txcan_set_error_state(ndev, new_state, skb ? cf : NULL);\n\n\t\tif (skb)\n\t\t\tnetif_rx(skb);\n\t}\n}\n\n \nstatic void xcan_err_interrupt(struct net_device *ndev, u32 isr)\n{\n\tstruct xcan_priv *priv = netdev_priv(ndev);\n\tstruct net_device_stats *stats = &ndev->stats;\n\tstruct can_frame cf = { };\n\tu32 err_status;\n\n\terr_status = priv->read_reg(priv, XCAN_ESR_OFFSET);\n\tpriv->write_reg(priv, XCAN_ESR_OFFSET, err_status);\n\n\tif (isr & XCAN_IXR_BSOFF_MASK) {\n\t\tpriv->can.state = CAN_STATE_BUS_OFF;\n\t\tpriv->can.can_stats.bus_off++;\n\t\t \n\t\tpriv->write_reg(priv, XCAN_SRR_OFFSET, XCAN_SRR_RESET_MASK);\n\t\tcan_bus_off(ndev);\n\t\tcf.can_id |= CAN_ERR_BUSOFF;\n\t} else {\n\t\tenum can_state new_state = xcan_current_error_state(ndev);\n\n\t\tif (new_state != priv->can.state)\n\t\t\txcan_set_error_state(ndev, new_state, &cf);\n\t}\n\n\t \n\tif (isr & XCAN_IXR_ARBLST_MASK) {\n\t\tpriv->can.can_stats.arbitration_lost++;\n\t\tcf.can_id |= CAN_ERR_LOSTARB;\n\t\tcf.data[0] = CAN_ERR_LOSTARB_UNSPEC;\n\t}\n\n\t \n\tif (isr & XCAN_IXR_RXOFLW_MASK) {\n\t\tstats->rx_over_errors++;\n\t\tstats->rx_errors++;\n\t\tcf.can_id |= CAN_ERR_CRTL;\n\t\tcf.data[1] |= CAN_ERR_CRTL_RX_OVERFLOW;\n\t}\n\n\t \n\tif (isr & XCAN_IXR_RXMNF_MASK) {\n\t\tstats->rx_dropped++;\n\t\tstats->rx_errors++;\n\t\tnetdev_err(ndev, \"RX match not finished, frame discarded\\n\");\n\t\tcf.can_id |= CAN_ERR_CRTL;\n\t\tcf.data[1] |= CAN_ERR_CRTL_UNSPEC;\n\t}\n\n\t \n\tif (isr & XCAN_IXR_ERROR_MASK) {\n\t\tbool berr_reporting = false;\n\n\t\tif (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING) {\n\t\t\tberr_reporting = true;\n\t\t\tcf.can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\n\t\t}\n\n\t\t \n\t\tif (err_status & XCAN_ESR_ACKER_MASK) {\n\t\t\tstats->tx_errors++;\n\t\t\tif (berr_reporting) {\n\t\t\t\tcf.can_id |= CAN_ERR_ACK;\n\t\t\t\tcf.data[3] = CAN_ERR_PROT_LOC_ACK;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (err_status & XCAN_ESR_BERR_MASK) {\n\t\t\tstats->tx_errors++;\n\t\t\tif (berr_reporting) {\n\t\t\t\tcf.can_id |= CAN_ERR_PROT;\n\t\t\t\tcf.data[2] = CAN_ERR_PROT_BIT;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (err_status & XCAN_ESR_STER_MASK) {\n\t\t\tstats->rx_errors++;\n\t\t\tif (berr_reporting) {\n\t\t\t\tcf.can_id |= CAN_ERR_PROT;\n\t\t\t\tcf.data[2] = CAN_ERR_PROT_STUFF;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (err_status & XCAN_ESR_FMER_MASK) {\n\t\t\tstats->rx_errors++;\n\t\t\tif (berr_reporting) {\n\t\t\t\tcf.can_id |= CAN_ERR_PROT;\n\t\t\t\tcf.data[2] = CAN_ERR_PROT_FORM;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (err_status & XCAN_ESR_CRCER_MASK) {\n\t\t\tstats->rx_errors++;\n\t\t\tif (berr_reporting) {\n\t\t\t\tcf.can_id |= CAN_ERR_PROT;\n\t\t\t\tcf.data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;\n\t\t\t}\n\t\t}\n\t\tpriv->can.can_stats.bus_error++;\n\t}\n\n\tif (cf.can_id) {\n\t\tstruct can_frame *skb_cf;\n\t\tstruct sk_buff *skb = alloc_can_err_skb(ndev, &skb_cf);\n\n\t\tif (skb) {\n\t\t\tskb_cf->can_id |= cf.can_id;\n\t\t\tmemcpy(skb_cf->data, cf.data, CAN_ERR_DLC);\n\t\t\tnetif_rx(skb);\n\t\t}\n\t}\n\n\tnetdev_dbg(ndev, \"%s: error status register:0x%x\\n\",\n\t\t   __func__, priv->read_reg(priv, XCAN_ESR_OFFSET));\n}\n\n \nstatic void xcan_state_interrupt(struct net_device *ndev, u32 isr)\n{\n\tstruct xcan_priv *priv = netdev_priv(ndev);\n\n\t \n\tif (isr & XCAN_IXR_SLP_MASK)\n\t\tpriv->can.state = CAN_STATE_SLEEPING;\n\n\t \n\tif (isr & XCAN_IXR_WKUP_MASK)\n\t\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n}\n\n \nstatic int xcan_rx_fifo_get_next_frame(struct xcan_priv *priv)\n{\n\tint offset;\n\n\tif (priv->devtype.flags & XCAN_FLAG_RX_FIFO_MULTI) {\n\t\tu32 fsr, mask;\n\n\t\t \n\t\tpriv->write_reg(priv, XCAN_ICR_OFFSET, XCAN_IXR_RXOK_MASK);\n\n\t\tfsr = priv->read_reg(priv, XCAN_FSR_OFFSET);\n\n\t\t \n\t\tif (priv->devtype.flags & XCAN_FLAG_CANFD_2)\n\t\t\tmask = XCAN_2_FSR_FL_MASK;\n\t\telse\n\t\t\tmask = XCAN_FSR_FL_MASK;\n\n\t\tif (!(fsr & mask))\n\t\t\treturn -ENOENT;\n\n\t\tif (priv->devtype.flags & XCAN_FLAG_CANFD_2)\n\t\t\toffset =\n\t\t\t  XCAN_RXMSG_2_FRAME_OFFSET(fsr & XCAN_2_FSR_RI_MASK);\n\t\telse\n\t\t\toffset =\n\t\t\t  XCAN_RXMSG_FRAME_OFFSET(fsr & XCAN_FSR_RI_MASK);\n\n\t} else {\n\t\t \n\t\tif (!(priv->read_reg(priv, XCAN_ISR_OFFSET) &\n\t\t      XCAN_IXR_RXNEMP_MASK))\n\t\t\treturn -ENOENT;\n\n\t\t \n\t\toffset = XCAN_RXFIFO_OFFSET;\n\t}\n\n\treturn offset;\n}\n\n \nstatic int xcan_rx_poll(struct napi_struct *napi, int quota)\n{\n\tstruct net_device *ndev = napi->dev;\n\tstruct xcan_priv *priv = netdev_priv(ndev);\n\tu32 ier;\n\tint work_done = 0;\n\tint frame_offset;\n\n\twhile ((frame_offset = xcan_rx_fifo_get_next_frame(priv)) >= 0 &&\n\t       (work_done < quota)) {\n\t\tif (xcan_rx_int_mask(priv) & XCAN_IXR_RXOK_MASK)\n\t\t\twork_done += xcanfd_rx(ndev, frame_offset);\n\t\telse\n\t\t\twork_done += xcan_rx(ndev, frame_offset);\n\n\t\tif (priv->devtype.flags & XCAN_FLAG_RX_FIFO_MULTI)\n\t\t\t \n\t\t\tpriv->write_reg(priv, XCAN_FSR_OFFSET,\n\t\t\t\t\tXCAN_FSR_IRI_MASK);\n\t\telse\n\t\t\t \n\t\t\tpriv->write_reg(priv, XCAN_ICR_OFFSET,\n\t\t\t\t\tXCAN_IXR_RXNEMP_MASK);\n\t}\n\n\tif (work_done)\n\t\txcan_update_error_state_after_rxtx(ndev);\n\n\tif (work_done < quota) {\n\t\tif (napi_complete_done(napi, work_done)) {\n\t\t\tier = priv->read_reg(priv, XCAN_IER_OFFSET);\n\t\t\tier |= xcan_rx_int_mask(priv);\n\t\t\tpriv->write_reg(priv, XCAN_IER_OFFSET, ier);\n\t\t}\n\t}\n\treturn work_done;\n}\n\n \nstatic void xcan_tx_interrupt(struct net_device *ndev, u32 isr)\n{\n\tstruct xcan_priv *priv = netdev_priv(ndev);\n\tstruct net_device_stats *stats = &ndev->stats;\n\tunsigned int frames_in_fifo;\n\tint frames_sent = 1;  \n\tunsigned long flags;\n\tint retries = 0;\n\n\t \n\tspin_lock_irqsave(&priv->tx_lock, flags);\n\n\tframes_in_fifo = priv->tx_head - priv->tx_tail;\n\n\tif (WARN_ON_ONCE(frames_in_fifo == 0)) {\n\t\t \n\t\tpriv->write_reg(priv, XCAN_ICR_OFFSET, XCAN_IXR_TXOK_MASK);\n\t\tspin_unlock_irqrestore(&priv->tx_lock, flags);\n\t\treturn;\n\t}\n\n\t \n\tif (frames_in_fifo > 1) {\n\t\tWARN_ON(frames_in_fifo > priv->tx_max);\n\n\t\t \n\t\twhile ((isr & XCAN_IXR_TXOK_MASK) &&\n\t\t       !WARN_ON(++retries == 100)) {\n\t\t\tpriv->write_reg(priv, XCAN_ICR_OFFSET,\n\t\t\t\t\tXCAN_IXR_TXOK_MASK);\n\t\t\tisr = priv->read_reg(priv, XCAN_ISR_OFFSET);\n\t\t}\n\n\t\tif (isr & XCAN_IXR_TXFEMP_MASK) {\n\t\t\t \n\t\t\tframes_sent = frames_in_fifo;\n\t\t}\n\t} else {\n\t\t \n\t\tpriv->write_reg(priv, XCAN_ICR_OFFSET, XCAN_IXR_TXOK_MASK);\n\t}\n\n\twhile (frames_sent--) {\n\t\tstats->tx_bytes += can_get_echo_skb(ndev, priv->tx_tail %\n\t\t\t\t\t\t    priv->tx_max, NULL);\n\t\tpriv->tx_tail++;\n\t\tstats->tx_packets++;\n\t}\n\n\tnetif_wake_queue(ndev);\n\n\tspin_unlock_irqrestore(&priv->tx_lock, flags);\n\n\txcan_update_error_state_after_rxtx(ndev);\n}\n\n \nstatic irqreturn_t xcan_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *ndev = (struct net_device *)dev_id;\n\tstruct xcan_priv *priv = netdev_priv(ndev);\n\tu32 isr, ier;\n\tu32 isr_errors;\n\tu32 rx_int_mask = xcan_rx_int_mask(priv);\n\n\t \n\tisr = priv->read_reg(priv, XCAN_ISR_OFFSET);\n\tif (!isr)\n\t\treturn IRQ_NONE;\n\n\t \n\tif (isr & (XCAN_IXR_SLP_MASK | XCAN_IXR_WKUP_MASK)) {\n\t\tpriv->write_reg(priv, XCAN_ICR_OFFSET, (XCAN_IXR_SLP_MASK |\n\t\t\t\tXCAN_IXR_WKUP_MASK));\n\t\txcan_state_interrupt(ndev, isr);\n\t}\n\n\t \n\tif (isr & XCAN_IXR_TXOK_MASK)\n\t\txcan_tx_interrupt(ndev, isr);\n\n\t \n\tisr_errors = isr & (XCAN_IXR_ERROR_MASK | XCAN_IXR_RXOFLW_MASK |\n\t\t\t    XCAN_IXR_BSOFF_MASK | XCAN_IXR_ARBLST_MASK |\n\t\t\t    XCAN_IXR_RXMNF_MASK);\n\tif (isr_errors) {\n\t\tpriv->write_reg(priv, XCAN_ICR_OFFSET, isr_errors);\n\t\txcan_err_interrupt(ndev, isr);\n\t}\n\n\t \n\tif (isr & rx_int_mask) {\n\t\tier = priv->read_reg(priv, XCAN_IER_OFFSET);\n\t\tier &= ~rx_int_mask;\n\t\tpriv->write_reg(priv, XCAN_IER_OFFSET, ier);\n\t\tnapi_schedule(&priv->napi);\n\t}\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void xcan_chip_stop(struct net_device *ndev)\n{\n\tstruct xcan_priv *priv = netdev_priv(ndev);\n\tint ret;\n\n\t \n\tret = set_reset_mode(ndev);\n\tif (ret < 0)\n\t\tnetdev_dbg(ndev, \"set_reset_mode() Failed\\n\");\n\n\tpriv->can.state = CAN_STATE_STOPPED;\n}\n\n \nstatic int xcan_open(struct net_device *ndev)\n{\n\tstruct xcan_priv *priv = netdev_priv(ndev);\n\tint ret;\n\n\tret = phy_power_on(priv->transceiver);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pm_runtime_get_sync(priv->dev);\n\tif (ret < 0) {\n\t\tnetdev_err(ndev, \"%s: pm_runtime_get failed(%d)\\n\",\n\t\t\t   __func__, ret);\n\t\tgoto err;\n\t}\n\n\tret = request_irq(ndev->irq, xcan_interrupt, priv->irq_flags,\n\t\t\t  ndev->name, ndev);\n\tif (ret < 0) {\n\t\tnetdev_err(ndev, \"irq allocation for CAN failed\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\tret = set_reset_mode(ndev);\n\tif (ret < 0) {\n\t\tnetdev_err(ndev, \"mode resetting failed!\\n\");\n\t\tgoto err_irq;\n\t}\n\n\t \n\tret = open_candev(ndev);\n\tif (ret)\n\t\tgoto err_irq;\n\n\tret = xcan_chip_start(ndev);\n\tif (ret < 0) {\n\t\tnetdev_err(ndev, \"xcan_chip_start failed!\\n\");\n\t\tgoto err_candev;\n\t}\n\n\tnapi_enable(&priv->napi);\n\tnetif_start_queue(ndev);\n\n\treturn 0;\n\nerr_candev:\n\tclose_candev(ndev);\nerr_irq:\n\tfree_irq(ndev->irq, ndev);\nerr:\n\tpm_runtime_put(priv->dev);\n\tphy_power_off(priv->transceiver);\n\n\treturn ret;\n}\n\n \nstatic int xcan_close(struct net_device *ndev)\n{\n\tstruct xcan_priv *priv = netdev_priv(ndev);\n\n\tnetif_stop_queue(ndev);\n\tnapi_disable(&priv->napi);\n\txcan_chip_stop(ndev);\n\tfree_irq(ndev->irq, ndev);\n\tclose_candev(ndev);\n\n\tpm_runtime_put(priv->dev);\n\tphy_power_off(priv->transceiver);\n\n\treturn 0;\n}\n\n \nstatic int xcan_get_berr_counter(const struct net_device *ndev,\n\t\t\t\t struct can_berr_counter *bec)\n{\n\tstruct xcan_priv *priv = netdev_priv(ndev);\n\tint ret;\n\n\tret = pm_runtime_get_sync(priv->dev);\n\tif (ret < 0) {\n\t\tnetdev_err(ndev, \"%s: pm_runtime_get failed(%d)\\n\",\n\t\t\t   __func__, ret);\n\t\tpm_runtime_put(priv->dev);\n\t\treturn ret;\n\t}\n\n\tbec->txerr = priv->read_reg(priv, XCAN_ECR_OFFSET) & XCAN_ECR_TEC_MASK;\n\tbec->rxerr = ((priv->read_reg(priv, XCAN_ECR_OFFSET) &\n\t\t\tXCAN_ECR_REC_MASK) >> XCAN_ESR_REC_SHIFT);\n\n\tpm_runtime_put(priv->dev);\n\n\treturn 0;\n}\n\n \nstatic int xcan_get_auto_tdcv(const struct net_device *ndev, u32 *tdcv)\n{\n\tstruct xcan_priv *priv = netdev_priv(ndev);\n\n\t*tdcv = FIELD_GET(XCAN_SR_TDCV_MASK, priv->read_reg(priv, XCAN_SR_OFFSET));\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops xcan_netdev_ops = {\n\t.ndo_open\t= xcan_open,\n\t.ndo_stop\t= xcan_close,\n\t.ndo_start_xmit\t= xcan_start_xmit,\n\t.ndo_change_mtu\t= can_change_mtu,\n};\n\nstatic const struct ethtool_ops xcan_ethtool_ops = {\n\t.get_ts_info = ethtool_op_get_ts_info,\n};\n\n \nstatic int __maybe_unused xcan_suspend(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\n\tif (netif_running(ndev)) {\n\t\tnetif_stop_queue(ndev);\n\t\tnetif_device_detach(ndev);\n\t\txcan_chip_stop(ndev);\n\t}\n\n\treturn pm_runtime_force_suspend(dev);\n}\n\n \nstatic int __maybe_unused xcan_resume(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = pm_runtime_force_resume(dev);\n\tif (ret) {\n\t\tdev_err(dev, \"pm_runtime_force_resume failed on resume\\n\");\n\t\treturn ret;\n\t}\n\n\tif (netif_running(ndev)) {\n\t\tret = xcan_chip_start(ndev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"xcan_chip_start failed on resume\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tnetif_device_attach(ndev);\n\t\tnetif_start_queue(ndev);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int __maybe_unused xcan_runtime_suspend(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct xcan_priv *priv = netdev_priv(ndev);\n\n\tclk_disable_unprepare(priv->bus_clk);\n\tclk_disable_unprepare(priv->can_clk);\n\n\treturn 0;\n}\n\n \nstatic int __maybe_unused xcan_runtime_resume(struct device *dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(dev);\n\tstruct xcan_priv *priv = netdev_priv(ndev);\n\tint ret;\n\n\tret = clk_prepare_enable(priv->bus_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot enable clock.\\n\");\n\t\treturn ret;\n\t}\n\tret = clk_prepare_enable(priv->can_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot enable clock.\\n\");\n\t\tclk_disable_unprepare(priv->bus_clk);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops xcan_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(xcan_suspend, xcan_resume)\n\tSET_RUNTIME_PM_OPS(xcan_runtime_suspend, xcan_runtime_resume, NULL)\n};\n\nstatic const struct xcan_devtype_data xcan_zynq_data = {\n\t.cantype = XZYNQ_CANPS,\n\t.flags = XCAN_FLAG_TXFEMP,\n\t.bittiming_const = &xcan_bittiming_const,\n\t.btr_ts2_shift = XCAN_BTR_TS2_SHIFT,\n\t.btr_sjw_shift = XCAN_BTR_SJW_SHIFT,\n\t.bus_clk_name = \"pclk\",\n};\n\nstatic const struct xcan_devtype_data xcan_axi_data = {\n\t.cantype = XAXI_CAN,\n\t.bittiming_const = &xcan_bittiming_const,\n\t.btr_ts2_shift = XCAN_BTR_TS2_SHIFT,\n\t.btr_sjw_shift = XCAN_BTR_SJW_SHIFT,\n\t.bus_clk_name = \"s_axi_aclk\",\n};\n\nstatic const struct xcan_devtype_data xcan_canfd_data = {\n\t.cantype = XAXI_CANFD,\n\t.flags = XCAN_FLAG_EXT_FILTERS |\n\t\t XCAN_FLAG_RXMNF |\n\t\t XCAN_FLAG_TX_MAILBOXES |\n\t\t XCAN_FLAG_RX_FIFO_MULTI,\n\t.bittiming_const = &xcan_bittiming_const_canfd,\n\t.btr_ts2_shift = XCAN_BTR_TS2_SHIFT_CANFD,\n\t.btr_sjw_shift = XCAN_BTR_SJW_SHIFT_CANFD,\n\t.bus_clk_name = \"s_axi_aclk\",\n};\n\nstatic const struct xcan_devtype_data xcan_canfd2_data = {\n\t.cantype = XAXI_CANFD_2_0,\n\t.flags = XCAN_FLAG_EXT_FILTERS |\n\t\t XCAN_FLAG_RXMNF |\n\t\t XCAN_FLAG_TX_MAILBOXES |\n\t\t XCAN_FLAG_CANFD_2 |\n\t\t XCAN_FLAG_RX_FIFO_MULTI,\n\t.bittiming_const = &xcan_bittiming_const_canfd2,\n\t.btr_ts2_shift = XCAN_BTR_TS2_SHIFT_CANFD,\n\t.btr_sjw_shift = XCAN_BTR_SJW_SHIFT_CANFD,\n\t.bus_clk_name = \"s_axi_aclk\",\n};\n\n \nstatic const struct of_device_id xcan_of_match[] = {\n\t{ .compatible = \"xlnx,zynq-can-1.0\", .data = &xcan_zynq_data },\n\t{ .compatible = \"xlnx,axi-can-1.00.a\", .data = &xcan_axi_data },\n\t{ .compatible = \"xlnx,canfd-1.0\", .data = &xcan_canfd_data },\n\t{ .compatible = \"xlnx,canfd-2.0\", .data = &xcan_canfd2_data },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, xcan_of_match);\n\n \nstatic int xcan_probe(struct platform_device *pdev)\n{\n\tstruct net_device *ndev;\n\tstruct xcan_priv *priv;\n\tstruct phy *transceiver;\n\tconst struct of_device_id *of_id;\n\tconst struct xcan_devtype_data *devtype = &xcan_axi_data;\n\tvoid __iomem *addr;\n\tint ret;\n\tint rx_max, tx_max;\n\tu32 hw_tx_max = 0, hw_rx_max = 0;\n\tconst char *hw_tx_max_property;\n\n\t \n\taddr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(addr)) {\n\t\tret = PTR_ERR(addr);\n\t\tgoto err;\n\t}\n\n\tof_id = of_match_device(xcan_of_match, &pdev->dev);\n\tif (of_id && of_id->data)\n\t\tdevtype = of_id->data;\n\n\thw_tx_max_property = devtype->flags & XCAN_FLAG_TX_MAILBOXES ?\n\t\t\t     \"tx-mailbox-count\" : \"tx-fifo-depth\";\n\n\tret = of_property_read_u32(pdev->dev.of_node, hw_tx_max_property,\n\t\t\t\t   &hw_tx_max);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"missing %s property\\n\",\n\t\t\thw_tx_max_property);\n\t\tgoto err;\n\t}\n\n\tret = of_property_read_u32(pdev->dev.of_node, \"rx-fifo-depth\",\n\t\t\t\t   &hw_rx_max);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"missing rx-fifo-depth property (mailbox mode is not supported)\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\tif (!(devtype->flags & XCAN_FLAG_TX_MAILBOXES) &&\n\t    (devtype->flags & XCAN_FLAG_TXFEMP))\n\t\ttx_max = min(hw_tx_max, 2U);\n\telse\n\t\ttx_max = 1;\n\n\trx_max = hw_rx_max;\n\n\t \n\tndev = alloc_candev(sizeof(struct xcan_priv), tx_max);\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tpriv = netdev_priv(ndev);\n\tpriv->dev = &pdev->dev;\n\tpriv->can.bittiming_const = devtype->bittiming_const;\n\tpriv->can.do_set_mode = xcan_do_set_mode;\n\tpriv->can.do_get_berr_counter = xcan_get_berr_counter;\n\tpriv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |\n\t\t\t\t\tCAN_CTRLMODE_BERR_REPORTING;\n\tpriv->rstc = devm_reset_control_get_optional_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(priv->rstc)) {\n\t\tdev_err(&pdev->dev, \"Cannot get CAN reset.\\n\");\n\t\tret = PTR_ERR(priv->rstc);\n\t\tgoto err_free;\n\t}\n\n\tret = reset_control_reset(priv->rstc);\n\tif (ret)\n\t\tgoto err_free;\n\n\tif (devtype->cantype == XAXI_CANFD) {\n\t\tpriv->can.data_bittiming_const =\n\t\t\t&xcan_data_bittiming_const_canfd;\n\t\tpriv->can.tdc_const = &xcan_tdc_const_canfd;\n\t}\n\n\tif (devtype->cantype == XAXI_CANFD_2_0) {\n\t\tpriv->can.data_bittiming_const =\n\t\t\t&xcan_data_bittiming_const_canfd2;\n\t\tpriv->can.tdc_const = &xcan_tdc_const_canfd2;\n\t}\n\n\tif (devtype->cantype == XAXI_CANFD ||\n\t    devtype->cantype == XAXI_CANFD_2_0) {\n\t\tpriv->can.ctrlmode_supported |= CAN_CTRLMODE_FD |\n\t\t\t\t\t\tCAN_CTRLMODE_TDC_AUTO;\n\t\tpriv->can.do_get_auto_tdcv = xcan_get_auto_tdcv;\n\t}\n\n\tpriv->reg_base = addr;\n\tpriv->tx_max = tx_max;\n\tpriv->devtype = *devtype;\n\tspin_lock_init(&priv->tx_lock);\n\n\t \n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto err_reset;\n\n\tndev->irq = ret;\n\n\tndev->flags |= IFF_ECHO;\t \n\n\tplatform_set_drvdata(pdev, ndev);\n\tSET_NETDEV_DEV(ndev, &pdev->dev);\n\tndev->netdev_ops = &xcan_netdev_ops;\n\tndev->ethtool_ops = &xcan_ethtool_ops;\n\n\t \n\tpriv->can_clk = devm_clk_get(&pdev->dev, \"can_clk\");\n\tif (IS_ERR(priv->can_clk)) {\n\t\tret = dev_err_probe(&pdev->dev, PTR_ERR(priv->can_clk),\n\t\t\t\t    \"device clock not found\\n\");\n\t\tgoto err_reset;\n\t}\n\n\tpriv->bus_clk = devm_clk_get(&pdev->dev, devtype->bus_clk_name);\n\tif (IS_ERR(priv->bus_clk)) {\n\t\tret = dev_err_probe(&pdev->dev, PTR_ERR(priv->bus_clk),\n\t\t\t\t    \"bus clock not found\\n\");\n\t\tgoto err_reset;\n\t}\n\n\ttransceiver = devm_phy_optional_get(&pdev->dev, NULL);\n\tif (IS_ERR(transceiver)) {\n\t\tret = PTR_ERR(transceiver);\n\t\tdev_err_probe(&pdev->dev, ret, \"failed to get phy\\n\");\n\t\tgoto err_reset;\n\t}\n\tpriv->transceiver = transceiver;\n\n\tpriv->write_reg = xcan_write_reg_le;\n\tpriv->read_reg = xcan_read_reg_le;\n\n\tpm_runtime_enable(&pdev->dev);\n\tret = pm_runtime_get_sync(&pdev->dev);\n\tif (ret < 0) {\n\t\tnetdev_err(ndev, \"%s: pm_runtime_get failed(%d)\\n\",\n\t\t\t   __func__, ret);\n\t\tgoto err_disableclks;\n\t}\n\n\tif (priv->read_reg(priv, XCAN_SR_OFFSET) != XCAN_SR_CONFIG_MASK) {\n\t\tpriv->write_reg = xcan_write_reg_be;\n\t\tpriv->read_reg = xcan_read_reg_be;\n\t}\n\n\tpriv->can.clock.freq = clk_get_rate(priv->can_clk);\n\n\tnetif_napi_add_weight(ndev, &priv->napi, xcan_rx_poll, rx_max);\n\n\tret = register_candev(ndev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"fail to register failed (err=%d)\\n\", ret);\n\t\tgoto err_disableclks;\n\t}\n\n\tof_can_transceiver(ndev);\n\tpm_runtime_put(&pdev->dev);\n\n\tif (priv->devtype.flags & XCAN_FLAG_CANFD_2) {\n\t\tpriv->write_reg(priv, XCAN_AFR_2_ID_OFFSET, 0x00000000);\n\t\tpriv->write_reg(priv, XCAN_AFR_2_MASK_OFFSET, 0x00000000);\n\t}\n\n\tnetdev_dbg(ndev, \"reg_base=0x%p irq=%d clock=%d, tx buffers: actual %d, using %d\\n\",\n\t\t   priv->reg_base, ndev->irq, priv->can.clock.freq,\n\t\t   hw_tx_max, priv->tx_max);\n\n\treturn 0;\n\nerr_disableclks:\n\tpm_runtime_put(priv->dev);\n\tpm_runtime_disable(&pdev->dev);\nerr_reset:\n\treset_control_assert(priv->rstc);\nerr_free:\n\tfree_candev(ndev);\nerr:\n\treturn ret;\n}\n\n \nstatic void xcan_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct xcan_priv *priv = netdev_priv(ndev);\n\n\tunregister_candev(ndev);\n\tpm_runtime_disable(&pdev->dev);\n\treset_control_assert(priv->rstc);\n\tfree_candev(ndev);\n}\n\nstatic struct platform_driver xcan_driver = {\n\t.probe = xcan_probe,\n\t.remove_new = xcan_remove,\n\t.driver\t= {\n\t\t.name = DRIVER_NAME,\n\t\t.pm = &xcan_dev_pm_ops,\n\t\t.of_match_table\t= xcan_of_match,\n\t},\n};\n\nmodule_platform_driver(xcan_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Xilinx Inc\");\nMODULE_DESCRIPTION(\"Xilinx CAN interface\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}