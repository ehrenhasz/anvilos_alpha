{
  "module_name": "ti_hecc.c",
  "hash_id": "b9777bba72709e35fd53e2034f4c0a74d83d1f0347c139f5175b31a352dbb48d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/ti_hecc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/interrupt.h>\n#include <linux/errno.h>\n#include <linux/ethtool.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n#include <linux/can/rx-offload.h>\n\n#define DRV_NAME \"ti_hecc\"\n#define HECC_MODULE_VERSION     \"0.7\"\nMODULE_VERSION(HECC_MODULE_VERSION);\n#define DRV_DESC \"TI High End CAN Controller Driver \" HECC_MODULE_VERSION\n\n \n#define HECC_MAX_MAILBOXES\t32\t \n#define MAX_TX_PRIO\t\t0x3F\t \n\n \n#define HECC_MB_TX_SHIFT\t2  \n#define HECC_MAX_TX_MBOX\tBIT(HECC_MB_TX_SHIFT)\n\n#define HECC_TX_PRIO_SHIFT\t(HECC_MB_TX_SHIFT)\n#define HECC_TX_PRIO_MASK\t(MAX_TX_PRIO << HECC_MB_TX_SHIFT)\n#define HECC_TX_MB_MASK\t\t(HECC_MAX_TX_MBOX - 1)\n#define HECC_TX_MASK\t\t((HECC_MAX_TX_MBOX - 1) | HECC_TX_PRIO_MASK)\n\n \n#define HECC_MAX_RX_MBOX\t(HECC_MAX_MAILBOXES - HECC_MAX_TX_MBOX)\n#define HECC_RX_FIRST_MBOX\t(HECC_MAX_MAILBOXES - 1)\n#define HECC_RX_LAST_MBOX\t(HECC_MAX_TX_MBOX)\n\n \n#define HECC_CANME\t\t0x0\t \n#define HECC_CANMD\t\t0x4\t \n#define HECC_CANTRS\t\t0x8\t \n#define HECC_CANTRR\t\t0xC\t \n#define HECC_CANTA\t\t0x10\t \n#define HECC_CANAA\t\t0x14\t \n#define HECC_CANRMP\t\t0x18\t \n#define HECC_CANRML\t\t0x1C\t \n#define HECC_CANRFP\t\t0x20\t \n#define HECC_CANGAM\t\t0x24\t \n#define HECC_CANMC\t\t0x28\t \n#define HECC_CANBTC\t\t0x2C\t \n#define HECC_CANES\t\t0x30\t \n#define HECC_CANTEC\t\t0x34\t \n#define HECC_CANREC\t\t0x38\t \n#define HECC_CANGIF0\t\t0x3C\t \n#define HECC_CANGIM\t\t0x40\t \n#define HECC_CANGIF1\t\t0x44\t \n#define HECC_CANMIM\t\t0x48\t \n#define HECC_CANMIL\t\t0x4C\t \n#define HECC_CANOPC\t\t0x50\t \n#define HECC_CANTIOC\t\t0x54\t \n#define HECC_CANRIOC\t\t0x58\t \n#define HECC_CANLNT\t\t0x5C\t \n#define HECC_CANTOC\t\t0x60\t \n#define HECC_CANTOS\t\t0x64\t \n#define HECC_CANTIOCE\t\t0x68\t \n#define HECC_CANRIOCE\t\t0x6C\t \n\n \n#define HECC_CANMOTS\t\t0x80\t \n\n \n#define HECC_CANMID\t\t0x0\n#define HECC_CANMCF\t\t0x4\n#define HECC_CANMDL\t\t0x8\n#define HECC_CANMDH\t\t0xC\n\n#define HECC_SET_REG\t\t0xFFFFFFFF\n#define HECC_CANID_MASK\t\t0x3FF\t \n#define HECC_CCE_WAIT_COUNT     100\t \n\n#define HECC_CANMC_SCM\t\tBIT(13)\t \n#define HECC_CANMC_CCR\t\tBIT(12)\t \n#define HECC_CANMC_PDR\t\tBIT(11)\t \n#define HECC_CANMC_ABO\t\tBIT(7)\t \n#define HECC_CANMC_STM\t\tBIT(6)\t \n#define HECC_CANMC_SRES\t\tBIT(5)\t \n\n#define HECC_CANTIOC_EN\t\tBIT(3)\t \n#define HECC_CANRIOC_EN\t\tBIT(3)\t \n\n#define HECC_CANMID_IDE\t\tBIT(31)\t \n#define HECC_CANMID_AME\t\tBIT(30)\t \n#define HECC_CANMID_AAM\t\tBIT(29)\t \n\n#define HECC_CANES_FE\t\tBIT(24)\t \n#define HECC_CANES_BE\t\tBIT(23)\t \n#define HECC_CANES_SA1\t\tBIT(22)\t \n#define HECC_CANES_CRCE\t\tBIT(21)\t \n#define HECC_CANES_SE\t\tBIT(20)\t \n#define HECC_CANES_ACKE\t\tBIT(19)\t \n#define HECC_CANES_BO\t\tBIT(18)\t \n#define HECC_CANES_EP\t\tBIT(17)\t \n#define HECC_CANES_EW\t\tBIT(16)\t \n#define HECC_CANES_SMA\t\tBIT(5)\t \n#define HECC_CANES_CCE\t\tBIT(4)\t \n#define HECC_CANES_PDA\t\tBIT(3)\t \n\n#define HECC_CANBTC_SAM\t\tBIT(7)\t \n\n#define HECC_BUS_ERROR\t\t(HECC_CANES_FE | HECC_CANES_BE |\\\n\t\t\t\tHECC_CANES_CRCE | HECC_CANES_SE |\\\n\t\t\t\tHECC_CANES_ACKE)\n#define HECC_CANES_FLAGS\t(HECC_BUS_ERROR | HECC_CANES_BO |\\\n\t\t\t\tHECC_CANES_EP | HECC_CANES_EW)\n\n#define HECC_CANMCF_RTR\t\tBIT(4)\t \n\n#define HECC_CANGIF_MAIF\tBIT(17)\t \n#define HECC_CANGIF_TCOIF\tBIT(16)  \n#define HECC_CANGIF_GMIF\tBIT(15)\t \n#define HECC_CANGIF_AAIF\tBIT(14)\t \n#define HECC_CANGIF_WDIF\tBIT(13)\t \n#define HECC_CANGIF_WUIF\tBIT(12)\t \n#define HECC_CANGIF_RMLIF\tBIT(11)\t \n#define HECC_CANGIF_BOIF\tBIT(10)\t \n#define HECC_CANGIF_EPIF\tBIT(9)\t \n#define HECC_CANGIF_WLIF\tBIT(8)\t \n#define HECC_CANGIF_MBOX_MASK\t0x1F\t \n#define HECC_CANGIM_I1EN\tBIT(1)\t \n#define HECC_CANGIM_I0EN\tBIT(0)\t \n#define HECC_CANGIM_DEF_MASK\t0x700\t \n#define HECC_CANGIM_SIL\t\tBIT(2)\t \n\n \nstatic const struct can_bittiming_const ti_hecc_bittiming_const = {\n\t.name = DRV_NAME,\n\t.tseg1_min = 1,\n\t.tseg1_max = 16,\n\t.tseg2_min = 1,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 256,\n\t.brp_inc = 1,\n};\n\nstruct ti_hecc_priv {\n\tstruct can_priv can;\t \n\tstruct can_rx_offload offload;\n\tstruct net_device *ndev;\n\tstruct clk *clk;\n\tvoid __iomem *base;\n\tvoid __iomem *hecc_ram;\n\tvoid __iomem *mbx;\n\tbool use_hecc1int;\n\tspinlock_t mbx_lock;  \n\tu32 tx_head;\n\tu32 tx_tail;\n\tstruct regulator *reg_xceiver;\n};\n\nstatic inline int get_tx_head_mb(struct ti_hecc_priv *priv)\n{\n\treturn priv->tx_head & HECC_TX_MB_MASK;\n}\n\nstatic inline int get_tx_tail_mb(struct ti_hecc_priv *priv)\n{\n\treturn priv->tx_tail & HECC_TX_MB_MASK;\n}\n\nstatic inline int get_tx_head_prio(struct ti_hecc_priv *priv)\n{\n\treturn (priv->tx_head >> HECC_TX_PRIO_SHIFT) & MAX_TX_PRIO;\n}\n\nstatic inline void hecc_write_lam(struct ti_hecc_priv *priv, u32 mbxno, u32 val)\n{\n\t__raw_writel(val, priv->hecc_ram + mbxno * 4);\n}\n\nstatic inline u32 hecc_read_stamp(struct ti_hecc_priv *priv, u32 mbxno)\n{\n\treturn __raw_readl(priv->hecc_ram + HECC_CANMOTS + mbxno * 4);\n}\n\nstatic inline void hecc_write_mbx(struct ti_hecc_priv *priv, u32 mbxno,\n\t\t\t\t  u32 reg, u32 val)\n{\n\t__raw_writel(val, priv->mbx + mbxno * 0x10 + reg);\n}\n\nstatic inline u32 hecc_read_mbx(struct ti_hecc_priv *priv, u32 mbxno, u32 reg)\n{\n\treturn __raw_readl(priv->mbx + mbxno * 0x10 + reg);\n}\n\nstatic inline void hecc_write(struct ti_hecc_priv *priv, u32 reg, u32 val)\n{\n\t__raw_writel(val, priv->base + reg);\n}\n\nstatic inline u32 hecc_read(struct ti_hecc_priv *priv, int reg)\n{\n\treturn __raw_readl(priv->base + reg);\n}\n\nstatic inline void hecc_set_bit(struct ti_hecc_priv *priv, int reg,\n\t\t\t\tu32 bit_mask)\n{\n\thecc_write(priv, reg, hecc_read(priv, reg) | bit_mask);\n}\n\nstatic inline void hecc_clear_bit(struct ti_hecc_priv *priv, int reg,\n\t\t\t\t  u32 bit_mask)\n{\n\thecc_write(priv, reg, hecc_read(priv, reg) & ~bit_mask);\n}\n\nstatic inline u32 hecc_get_bit(struct ti_hecc_priv *priv, int reg, u32 bit_mask)\n{\n\treturn (hecc_read(priv, reg) & bit_mask) ? 1 : 0;\n}\n\nstatic int ti_hecc_set_btc(struct ti_hecc_priv *priv)\n{\n\tstruct can_bittiming *bit_timing = &priv->can.bittiming;\n\tu32 can_btc;\n\n\tcan_btc = (bit_timing->phase_seg2 - 1) & 0x7;\n\tcan_btc |= ((bit_timing->phase_seg1 + bit_timing->prop_seg - 1)\n\t\t\t& 0xF) << 3;\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES) {\n\t\tif (bit_timing->brp > 4)\n\t\t\tcan_btc |= HECC_CANBTC_SAM;\n\t\telse\n\t\t\tnetdev_warn(priv->ndev,\n\t\t\t\t    \"WARN: Triple sampling not set due to h/w limitations\");\n\t}\n\tcan_btc |= ((bit_timing->sjw - 1) & 0x3) << 8;\n\tcan_btc |= ((bit_timing->brp - 1) & 0xFF) << 16;\n\n\t \n\n\thecc_write(priv, HECC_CANBTC, can_btc);\n\tnetdev_info(priv->ndev, \"setting CANBTC=%#x\\n\", can_btc);\n\n\treturn 0;\n}\n\nstatic int ti_hecc_transceiver_switch(const struct ti_hecc_priv *priv,\n\t\t\t\t      int on)\n{\n\tif (!priv->reg_xceiver)\n\t\treturn 0;\n\n\tif (on)\n\t\treturn regulator_enable(priv->reg_xceiver);\n\telse\n\t\treturn regulator_disable(priv->reg_xceiver);\n}\n\nstatic void ti_hecc_reset(struct net_device *ndev)\n{\n\tu32 cnt;\n\tstruct ti_hecc_priv *priv = netdev_priv(ndev);\n\n\tnetdev_dbg(ndev, \"resetting hecc ...\\n\");\n\thecc_set_bit(priv, HECC_CANMC, HECC_CANMC_SRES);\n\n\t \n\thecc_set_bit(priv, HECC_CANMC, HECC_CANMC_CCR);\n\n\t \n\tcnt = HECC_CCE_WAIT_COUNT;\n\twhile (!hecc_get_bit(priv, HECC_CANES, HECC_CANES_CCE) && cnt != 0) {\n\t\t--cnt;\n\t\tudelay(10);\n\t}\n\n\t \n\tti_hecc_set_btc(priv);\n\n\t \n\thecc_write(priv, HECC_CANMC, 0);\n\n\t \n\n\t \n\tcnt = HECC_CCE_WAIT_COUNT;\n\twhile (hecc_get_bit(priv, HECC_CANES, HECC_CANES_CCE) && cnt != 0) {\n\t\t--cnt;\n\t\tudelay(10);\n\t}\n\n\t \n\thecc_write(priv, HECC_CANTIOC, HECC_CANTIOC_EN);\n\thecc_write(priv, HECC_CANRIOC, HECC_CANRIOC_EN);\n\n\t \n\thecc_write(priv, HECC_CANTA, HECC_SET_REG);\n\thecc_write(priv, HECC_CANRMP, HECC_SET_REG);\n\thecc_write(priv, HECC_CANGIF0, HECC_SET_REG);\n\thecc_write(priv, HECC_CANGIF1, HECC_SET_REG);\n\thecc_write(priv, HECC_CANME, 0);\n\thecc_write(priv, HECC_CANMD, 0);\n\n\t \n\thecc_set_bit(priv, HECC_CANMC, HECC_CANMC_SCM);\n}\n\nstatic void ti_hecc_start(struct net_device *ndev)\n{\n\tstruct ti_hecc_priv *priv = netdev_priv(ndev);\n\tu32 cnt, mbxno, mbx_mask;\n\n\t \n\tti_hecc_reset(ndev);\n\n\tpriv->tx_head = HECC_TX_MASK;\n\tpriv->tx_tail = HECC_TX_MASK;\n\n\t \n\thecc_write(priv, HECC_CANGAM, HECC_SET_REG);\n\n\t \n\tfor (cnt = 0; cnt < HECC_MAX_RX_MBOX; cnt++) {\n\t\tmbxno = HECC_MAX_MAILBOXES - 1 - cnt;\n\t\tmbx_mask = BIT(mbxno);\n\t\thecc_clear_bit(priv, HECC_CANME, mbx_mask);\n\t\thecc_write_mbx(priv, mbxno, HECC_CANMID, HECC_CANMID_AME);\n\t\thecc_write_lam(priv, mbxno, HECC_SET_REG);\n\t\thecc_set_bit(priv, HECC_CANMD, mbx_mask);\n\t\thecc_set_bit(priv, HECC_CANME, mbx_mask);\n\t\thecc_set_bit(priv, HECC_CANMIM, mbx_mask);\n\t}\n\n\t \n\thecc_set_bit(priv, HECC_CANMIM, BIT(HECC_MAX_TX_MBOX) - 1);\n\n\t \n\tmbx_mask = ~BIT(HECC_RX_LAST_MBOX);\n\thecc_write(priv, HECC_CANOPC, mbx_mask);\n\n\t \n\tif (priv->use_hecc1int) {\n\t\thecc_write(priv, HECC_CANMIL, HECC_SET_REG);\n\t\thecc_write(priv, HECC_CANGIM, HECC_CANGIM_DEF_MASK |\n\t\t\tHECC_CANGIM_I1EN | HECC_CANGIM_SIL);\n\t} else {\n\t\thecc_write(priv, HECC_CANMIL, 0);\n\t\thecc_write(priv, HECC_CANGIM,\n\t\t\t   HECC_CANGIM_DEF_MASK | HECC_CANGIM_I0EN);\n\t}\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n}\n\nstatic void ti_hecc_stop(struct net_device *ndev)\n{\n\tstruct ti_hecc_priv *priv = netdev_priv(ndev);\n\n\t \n\thecc_set_bit(priv, HECC_CANMC, HECC_CANMC_CCR);\n\n\t \n\thecc_write(priv, HECC_CANGIM, 0);\n\thecc_write(priv, HECC_CANMIM, 0);\n\thecc_write(priv, HECC_CANME, 0);\n\tpriv->can.state = CAN_STATE_STOPPED;\n}\n\nstatic int ti_hecc_do_set_mode(struct net_device *ndev, enum can_mode mode)\n{\n\tint ret = 0;\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\tti_hecc_start(ndev);\n\t\tnetif_wake_queue(ndev);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int ti_hecc_get_berr_counter(const struct net_device *ndev,\n\t\t\t\t    struct can_berr_counter *bec)\n{\n\tstruct ti_hecc_priv *priv = netdev_priv(ndev);\n\n\tbec->txerr = hecc_read(priv, HECC_CANTEC);\n\tbec->rxerr = hecc_read(priv, HECC_CANREC);\n\n\treturn 0;\n}\n\n \nstatic netdev_tx_t ti_hecc_xmit(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct ti_hecc_priv *priv = netdev_priv(ndev);\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tu32 mbxno, mbx_mask, data;\n\tunsigned long flags;\n\n\tif (can_dev_dropped_skb(ndev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tmbxno = get_tx_head_mb(priv);\n\tmbx_mask = BIT(mbxno);\n\tspin_lock_irqsave(&priv->mbx_lock, flags);\n\tif (unlikely(hecc_read(priv, HECC_CANME) & mbx_mask)) {\n\t\tspin_unlock_irqrestore(&priv->mbx_lock, flags);\n\t\tnetif_stop_queue(ndev);\n\t\tnetdev_err(priv->ndev,\n\t\t\t   \"BUG: TX mbx not ready tx_head=%08X, tx_tail=%08X\\n\",\n\t\t\t   priv->tx_head, priv->tx_tail);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\tspin_unlock_irqrestore(&priv->mbx_lock, flags);\n\n\t \n\tdata = cf->len | (get_tx_head_prio(priv) << 8);\n\tif (cf->can_id & CAN_RTR_FLAG)  \n\t\tdata |= HECC_CANMCF_RTR;\n\thecc_write_mbx(priv, mbxno, HECC_CANMCF, data);\n\n\tif (cf->can_id & CAN_EFF_FLAG)  \n\t\tdata = (cf->can_id & CAN_EFF_MASK) | HECC_CANMID_IDE;\n\telse  \n\t\tdata = (cf->can_id & CAN_SFF_MASK) << 18;\n\thecc_write_mbx(priv, mbxno, HECC_CANMID, data);\n\thecc_write_mbx(priv, mbxno, HECC_CANMDL,\n\t\t       be32_to_cpu(*(__be32 *)(cf->data)));\n\tif (cf->len > 4)\n\t\thecc_write_mbx(priv, mbxno, HECC_CANMDH,\n\t\t\t       be32_to_cpu(*(__be32 *)(cf->data + 4)));\n\telse\n\t\t*(u32 *)(cf->data + 4) = 0;\n\tcan_put_echo_skb(skb, ndev, mbxno, 0);\n\n\tspin_lock_irqsave(&priv->mbx_lock, flags);\n\t--priv->tx_head;\n\tif ((hecc_read(priv, HECC_CANME) & BIT(get_tx_head_mb(priv))) ||\n\t    (priv->tx_head & HECC_TX_MASK) == HECC_TX_MASK) {\n\t\tnetif_stop_queue(ndev);\n\t}\n\thecc_set_bit(priv, HECC_CANME, mbx_mask);\n\tspin_unlock_irqrestore(&priv->mbx_lock, flags);\n\n\thecc_write(priv, HECC_CANTRS, mbx_mask);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic inline\nstruct ti_hecc_priv *rx_offload_to_priv(struct can_rx_offload *offload)\n{\n\treturn container_of(offload, struct ti_hecc_priv, offload);\n}\n\nstatic struct sk_buff *ti_hecc_mailbox_read(struct can_rx_offload *offload,\n\t\t\t\t\t    unsigned int mbxno, u32 *timestamp,\n\t\t\t\t\t    bool drop)\n{\n\tstruct ti_hecc_priv *priv = rx_offload_to_priv(offload);\n\tstruct sk_buff *skb;\n\tstruct can_frame *cf;\n\tu32 data, mbx_mask;\n\n\tmbx_mask = BIT(mbxno);\n\n\tif (unlikely(drop)) {\n\t\tskb = ERR_PTR(-ENOBUFS);\n\t\tgoto mark_as_read;\n\t}\n\n\tskb = alloc_can_skb(offload->dev, &cf);\n\tif (unlikely(!skb)) {\n\t\tskb = ERR_PTR(-ENOMEM);\n\t\tgoto mark_as_read;\n\t}\n\n\tdata = hecc_read_mbx(priv, mbxno, HECC_CANMID);\n\tif (data & HECC_CANMID_IDE)\n\t\tcf->can_id = (data & CAN_EFF_MASK) | CAN_EFF_FLAG;\n\telse\n\t\tcf->can_id = (data >> 18) & CAN_SFF_MASK;\n\n\tdata = hecc_read_mbx(priv, mbxno, HECC_CANMCF);\n\tif (data & HECC_CANMCF_RTR)\n\t\tcf->can_id |= CAN_RTR_FLAG;\n\tcf->len = can_cc_dlc2len(data & 0xF);\n\n\tdata = hecc_read_mbx(priv, mbxno, HECC_CANMDL);\n\t*(__be32 *)(cf->data) = cpu_to_be32(data);\n\tif (cf->len > 4) {\n\t\tdata = hecc_read_mbx(priv, mbxno, HECC_CANMDH);\n\t\t*(__be32 *)(cf->data + 4) = cpu_to_be32(data);\n\t}\n\n\t*timestamp = hecc_read_stamp(priv, mbxno);\n\n\t \n\tif (unlikely(mbxno == HECC_RX_LAST_MBOX &&\n\t\t     hecc_read(priv, HECC_CANRML) & mbx_mask))\n\t\tskb = ERR_PTR(-ENOBUFS);\n\n mark_as_read:\n\thecc_write(priv, HECC_CANRMP, mbx_mask);\n\n\treturn skb;\n}\n\nstatic int ti_hecc_error(struct net_device *ndev, int int_status,\n\t\t\t int err_status)\n{\n\tstruct ti_hecc_priv *priv = netdev_priv(ndev);\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tu32 timestamp;\n\tint err;\n\n\tif (err_status & HECC_BUS_ERROR) {\n\t\t \n\t\tskb = alloc_can_err_skb(ndev, &cf);\n\t\tif (!skb) {\n\t\t\tif (net_ratelimit())\n\t\t\t\tnetdev_err(priv->ndev,\n\t\t\t\t\t   \"%s: alloc_can_err_skb() failed\\n\",\n\t\t\t\t\t   __func__);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t++priv->can.can_stats.bus_error;\n\t\tcf->can_id |= CAN_ERR_BUSERROR | CAN_ERR_PROT;\n\t\tif (err_status & HECC_CANES_FE)\n\t\t\tcf->data[2] |= CAN_ERR_PROT_FORM;\n\t\tif (err_status & HECC_CANES_BE)\n\t\t\tcf->data[2] |= CAN_ERR_PROT_BIT;\n\t\tif (err_status & HECC_CANES_SE)\n\t\t\tcf->data[2] |= CAN_ERR_PROT_STUFF;\n\t\tif (err_status & HECC_CANES_CRCE)\n\t\t\tcf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;\n\t\tif (err_status & HECC_CANES_ACKE)\n\t\t\tcf->data[3] = CAN_ERR_PROT_LOC_ACK;\n\n\t\ttimestamp = hecc_read(priv, HECC_CANLNT);\n\t\terr = can_rx_offload_queue_timestamp(&priv->offload, skb,\n\t\t\t\t\t\t     timestamp);\n\t\tif (err)\n\t\t\tndev->stats.rx_fifo_errors++;\n\t}\n\n\thecc_write(priv, HECC_CANES, HECC_CANES_FLAGS);\n\n\treturn 0;\n}\n\nstatic void ti_hecc_change_state(struct net_device *ndev,\n\t\t\t\t enum can_state rx_state,\n\t\t\t\t enum can_state tx_state)\n{\n\tstruct ti_hecc_priv *priv = netdev_priv(ndev);\n\tstruct can_frame *cf;\n\tstruct sk_buff *skb;\n\tu32 timestamp;\n\tint err;\n\n\tskb = alloc_can_err_skb(priv->ndev, &cf);\n\tif (unlikely(!skb)) {\n\t\tpriv->can.state = max(tx_state, rx_state);\n\t\treturn;\n\t}\n\n\tcan_change_state(priv->ndev, cf, tx_state, rx_state);\n\n\tif (max(tx_state, rx_state) != CAN_STATE_BUS_OFF) {\n\t\tcf->can_id |= CAN_ERR_CNT;\n\t\tcf->data[6] = hecc_read(priv, HECC_CANTEC);\n\t\tcf->data[7] = hecc_read(priv, HECC_CANREC);\n\t}\n\n\ttimestamp = hecc_read(priv, HECC_CANLNT);\n\terr = can_rx_offload_queue_timestamp(&priv->offload, skb, timestamp);\n\tif (err)\n\t\tndev->stats.rx_fifo_errors++;\n}\n\nstatic irqreturn_t ti_hecc_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *ndev = (struct net_device *)dev_id;\n\tstruct ti_hecc_priv *priv = netdev_priv(ndev);\n\tstruct net_device_stats *stats = &ndev->stats;\n\tu32 mbxno, mbx_mask, int_status, err_status, stamp;\n\tunsigned long flags, rx_pending;\n\tu32 handled = 0;\n\n\tint_status = hecc_read(priv,\n\t\t\t       priv->use_hecc1int ?\n\t\t\t       HECC_CANGIF1 : HECC_CANGIF0);\n\n\tif (!int_status)\n\t\treturn IRQ_NONE;\n\n\terr_status = hecc_read(priv, HECC_CANES);\n\tif (unlikely(err_status & HECC_CANES_FLAGS))\n\t\tti_hecc_error(ndev, int_status, err_status);\n\n\tif (unlikely(int_status & HECC_CANGIM_DEF_MASK)) {\n\t\tenum can_state rx_state, tx_state;\n\t\tu32 rec = hecc_read(priv, HECC_CANREC);\n\t\tu32 tec = hecc_read(priv, HECC_CANTEC);\n\n\t\tif (int_status & HECC_CANGIF_WLIF) {\n\t\t\thandled |= HECC_CANGIF_WLIF;\n\t\t\trx_state = rec >= tec ? CAN_STATE_ERROR_WARNING : 0;\n\t\t\ttx_state = rec <= tec ? CAN_STATE_ERROR_WARNING : 0;\n\t\t\tnetdev_dbg(priv->ndev, \"Error Warning interrupt\\n\");\n\t\t\tti_hecc_change_state(ndev, rx_state, tx_state);\n\t\t}\n\n\t\tif (int_status & HECC_CANGIF_EPIF) {\n\t\t\thandled |= HECC_CANGIF_EPIF;\n\t\t\trx_state = rec >= tec ? CAN_STATE_ERROR_PASSIVE : 0;\n\t\t\ttx_state = rec <= tec ? CAN_STATE_ERROR_PASSIVE : 0;\n\t\t\tnetdev_dbg(priv->ndev, \"Error passive interrupt\\n\");\n\t\t\tti_hecc_change_state(ndev, rx_state, tx_state);\n\t\t}\n\n\t\tif (int_status & HECC_CANGIF_BOIF) {\n\t\t\thandled |= HECC_CANGIF_BOIF;\n\t\t\trx_state = CAN_STATE_BUS_OFF;\n\t\t\ttx_state = CAN_STATE_BUS_OFF;\n\t\t\tnetdev_dbg(priv->ndev, \"Bus off interrupt\\n\");\n\n\t\t\t \n\t\t\thecc_write(priv, HECC_CANGIM, 0);\n\t\t\tcan_bus_off(ndev);\n\t\t\tti_hecc_change_state(ndev, rx_state, tx_state);\n\t\t}\n\t} else if (unlikely(priv->can.state != CAN_STATE_ERROR_ACTIVE)) {\n\t\tenum can_state new_state, tx_state, rx_state;\n\t\tu32 rec = hecc_read(priv, HECC_CANREC);\n\t\tu32 tec = hecc_read(priv, HECC_CANTEC);\n\n\t\tif (rec >= 128 || tec >= 128)\n\t\t\tnew_state = CAN_STATE_ERROR_PASSIVE;\n\t\telse if (rec >= 96 || tec >= 96)\n\t\t\tnew_state = CAN_STATE_ERROR_WARNING;\n\t\telse\n\t\t\tnew_state = CAN_STATE_ERROR_ACTIVE;\n\n\t\tif (new_state < priv->can.state) {\n\t\t\trx_state = rec >= tec ? new_state : 0;\n\t\t\ttx_state = rec <= tec ? new_state : 0;\n\t\t\tti_hecc_change_state(ndev, rx_state, tx_state);\n\t\t}\n\t}\n\n\tif (int_status & HECC_CANGIF_GMIF) {\n\t\twhile (priv->tx_tail - priv->tx_head > 0) {\n\t\t\tmbxno = get_tx_tail_mb(priv);\n\t\t\tmbx_mask = BIT(mbxno);\n\t\t\tif (!(mbx_mask & hecc_read(priv, HECC_CANTA)))\n\t\t\t\tbreak;\n\t\t\thecc_write(priv, HECC_CANTA, mbx_mask);\n\t\t\tspin_lock_irqsave(&priv->mbx_lock, flags);\n\t\t\thecc_clear_bit(priv, HECC_CANME, mbx_mask);\n\t\t\tspin_unlock_irqrestore(&priv->mbx_lock, flags);\n\t\t\tstamp = hecc_read_stamp(priv, mbxno);\n\t\t\tstats->tx_bytes +=\n\t\t\t\tcan_rx_offload_get_echo_skb_queue_timestamp(&priv->offload,\n\t\t\t\t\t\t\t\t\t    mbxno, stamp, NULL);\n\t\t\tstats->tx_packets++;\n\t\t\t--priv->tx_tail;\n\t\t}\n\n\t\t \n\t\tif ((priv->tx_head == priv->tx_tail &&\n\t\t     ((priv->tx_head & HECC_TX_MASK) != HECC_TX_MASK)) ||\n\t\t    (((priv->tx_tail & HECC_TX_MASK) == HECC_TX_MASK) &&\n\t\t     ((priv->tx_head & HECC_TX_MASK) == HECC_TX_MASK)))\n\t\t\tnetif_wake_queue(ndev);\n\n\t\t \n\t\twhile ((rx_pending = hecc_read(priv, HECC_CANRMP))) {\n\t\t\tcan_rx_offload_irq_offload_timestamp(&priv->offload,\n\t\t\t\t\t\t\t     rx_pending);\n\t\t}\n\t}\n\n\t \n\tif (priv->use_hecc1int) {\n\t\thecc_write(priv, HECC_CANGIF1, handled);\n\t\tint_status = hecc_read(priv, HECC_CANGIF1);\n\t} else {\n\t\thecc_write(priv, HECC_CANGIF0, handled);\n\t\tint_status = hecc_read(priv, HECC_CANGIF0);\n\t}\n\n\tcan_rx_offload_irq_finish(&priv->offload);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ti_hecc_open(struct net_device *ndev)\n{\n\tstruct ti_hecc_priv *priv = netdev_priv(ndev);\n\tint err;\n\n\terr = request_irq(ndev->irq, ti_hecc_interrupt, IRQF_SHARED,\n\t\t\t  ndev->name, ndev);\n\tif (err) {\n\t\tnetdev_err(ndev, \"error requesting interrupt\\n\");\n\t\treturn err;\n\t}\n\n\tti_hecc_transceiver_switch(priv, 1);\n\n\t \n\terr = open_candev(ndev);\n\tif (err) {\n\t\tnetdev_err(ndev, \"open_candev() failed %d\\n\", err);\n\t\tti_hecc_transceiver_switch(priv, 0);\n\t\tfree_irq(ndev->irq, ndev);\n\t\treturn err;\n\t}\n\n\tti_hecc_start(ndev);\n\tcan_rx_offload_enable(&priv->offload);\n\tnetif_start_queue(ndev);\n\n\treturn 0;\n}\n\nstatic int ti_hecc_close(struct net_device *ndev)\n{\n\tstruct ti_hecc_priv *priv = netdev_priv(ndev);\n\n\tnetif_stop_queue(ndev);\n\tcan_rx_offload_disable(&priv->offload);\n\tti_hecc_stop(ndev);\n\tfree_irq(ndev->irq, ndev);\n\tclose_candev(ndev);\n\tti_hecc_transceiver_switch(priv, 0);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops ti_hecc_netdev_ops = {\n\t.ndo_open\t\t= ti_hecc_open,\n\t.ndo_stop\t\t= ti_hecc_close,\n\t.ndo_start_xmit\t\t= ti_hecc_xmit,\n\t.ndo_change_mtu\t\t= can_change_mtu,\n};\n\nstatic const struct ethtool_ops ti_hecc_ethtool_ops = {\n\t.get_ts_info = ethtool_op_get_ts_info,\n};\n\nstatic const struct of_device_id ti_hecc_dt_ids[] = {\n\t{\n\t\t.compatible = \"ti,am3517-hecc\",\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ti_hecc_dt_ids);\n\nstatic int ti_hecc_probe(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = (struct net_device *)0;\n\tstruct ti_hecc_priv *priv;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct regulator *reg_xceiver;\n\tint err = -ENODEV;\n\n\tif (!IS_ENABLED(CONFIG_OF) || !np)\n\t\treturn -EINVAL;\n\n\treg_xceiver = devm_regulator_get(&pdev->dev, \"xceiver\");\n\tif (PTR_ERR(reg_xceiver) == -EPROBE_DEFER)\n\t\treturn -EPROBE_DEFER;\n\telse if (IS_ERR(reg_xceiver))\n\t\treg_xceiver = NULL;\n\n\tndev = alloc_candev(sizeof(struct ti_hecc_priv), HECC_MAX_TX_MBOX);\n\tif (!ndev) {\n\t\tdev_err(&pdev->dev, \"alloc_candev failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tpriv = netdev_priv(ndev);\n\n\t \n\tpriv->base = devm_platform_ioremap_resource_byname(pdev, \"hecc\");\n\tif (IS_ERR(priv->base)) {\n\t\tdev_err(&pdev->dev, \"hecc ioremap failed\\n\");\n\t\terr = PTR_ERR(priv->base);\n\t\tgoto probe_exit_candev;\n\t}\n\n\t \n\tpriv->hecc_ram = devm_platform_ioremap_resource_byname(pdev,\n\t\t\t\t\t\t\t       \"hecc-ram\");\n\tif (IS_ERR(priv->hecc_ram)) {\n\t\tdev_err(&pdev->dev, \"hecc-ram ioremap failed\\n\");\n\t\terr = PTR_ERR(priv->hecc_ram);\n\t\tgoto probe_exit_candev;\n\t}\n\n\t \n\tpriv->mbx = devm_platform_ioremap_resource_byname(pdev, \"mbx\");\n\tif (IS_ERR(priv->mbx)) {\n\t\tdev_err(&pdev->dev, \"mbx ioremap failed\\n\");\n\t\terr = PTR_ERR(priv->mbx);\n\t\tgoto probe_exit_candev;\n\t}\n\n\tndev->irq = platform_get_irq(pdev, 0);\n\tif (ndev->irq < 0) {\n\t\terr = ndev->irq;\n\t\tgoto probe_exit_candev;\n\t}\n\n\tpriv->ndev = ndev;\n\tpriv->reg_xceiver = reg_xceiver;\n\tpriv->use_hecc1int = of_property_read_bool(np, \"ti,use-hecc1int\");\n\n\tpriv->can.bittiming_const = &ti_hecc_bittiming_const;\n\tpriv->can.do_set_mode = ti_hecc_do_set_mode;\n\tpriv->can.do_get_berr_counter = ti_hecc_get_berr_counter;\n\tpriv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES;\n\n\tspin_lock_init(&priv->mbx_lock);\n\tndev->flags |= IFF_ECHO;\n\tplatform_set_drvdata(pdev, ndev);\n\tSET_NETDEV_DEV(ndev, &pdev->dev);\n\tndev->netdev_ops = &ti_hecc_netdev_ops;\n\tndev->ethtool_ops = &ti_hecc_ethtool_ops;\n\n\tpriv->clk = clk_get(&pdev->dev, \"hecc_ck\");\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(&pdev->dev, \"No clock available\\n\");\n\t\terr = PTR_ERR(priv->clk);\n\t\tpriv->clk = NULL;\n\t\tgoto probe_exit_candev;\n\t}\n\tpriv->can.clock.freq = clk_get_rate(priv->clk);\n\n\terr = clk_prepare_enable(priv->clk);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"clk_prepare_enable() failed\\n\");\n\t\tgoto probe_exit_release_clk;\n\t}\n\n\tpriv->offload.mailbox_read = ti_hecc_mailbox_read;\n\tpriv->offload.mb_first = HECC_RX_FIRST_MBOX;\n\tpriv->offload.mb_last = HECC_RX_LAST_MBOX;\n\terr = can_rx_offload_add_timestamp(ndev, &priv->offload);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"can_rx_offload_add_timestamp() failed\\n\");\n\t\tgoto probe_exit_disable_clk;\n\t}\n\n\terr = register_candev(ndev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"register_candev() failed\\n\");\n\t\tgoto probe_exit_offload;\n\t}\n\n\tdev_info(&pdev->dev, \"device registered (reg_base=%p, irq=%u)\\n\",\n\t\t priv->base, (u32)ndev->irq);\n\n\treturn 0;\n\nprobe_exit_offload:\n\tcan_rx_offload_del(&priv->offload);\nprobe_exit_disable_clk:\n\tclk_disable_unprepare(priv->clk);\nprobe_exit_release_clk:\n\tclk_put(priv->clk);\nprobe_exit_candev:\n\tfree_candev(ndev);\n\n\treturn err;\n}\n\nstatic void ti_hecc_remove(struct platform_device *pdev)\n{\n\tstruct net_device *ndev = platform_get_drvdata(pdev);\n\tstruct ti_hecc_priv *priv = netdev_priv(ndev);\n\n\tunregister_candev(ndev);\n\tclk_disable_unprepare(priv->clk);\n\tclk_put(priv->clk);\n\tcan_rx_offload_del(&priv->offload);\n\tfree_candev(ndev);\n}\n\n#ifdef CONFIG_PM\nstatic int ti_hecc_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\tstruct ti_hecc_priv *priv = netdev_priv(dev);\n\n\tif (netif_running(dev)) {\n\t\tnetif_stop_queue(dev);\n\t\tnetif_device_detach(dev);\n\t}\n\n\thecc_set_bit(priv, HECC_CANMC, HECC_CANMC_PDR);\n\tpriv->can.state = CAN_STATE_SLEEPING;\n\n\tclk_disable_unprepare(priv->clk);\n\n\treturn 0;\n}\n\nstatic int ti_hecc_resume(struct platform_device *pdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(pdev);\n\tstruct ti_hecc_priv *priv = netdev_priv(dev);\n\tint err;\n\n\terr = clk_prepare_enable(priv->clk);\n\tif (err)\n\t\treturn err;\n\n\thecc_clear_bit(priv, HECC_CANMC, HECC_CANMC_PDR);\n\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\n\tif (netif_running(dev)) {\n\t\tnetif_device_attach(dev);\n\t\tnetif_start_queue(dev);\n\t}\n\n\treturn 0;\n}\n#else\n#define ti_hecc_suspend NULL\n#define ti_hecc_resume NULL\n#endif\n\n \nstatic struct platform_driver ti_hecc_driver = {\n\t.driver = {\n\t\t.name    = DRV_NAME,\n\t\t.of_match_table = ti_hecc_dt_ids,\n\t},\n\t.probe = ti_hecc_probe,\n\t.remove_new = ti_hecc_remove,\n\t.suspend = ti_hecc_suspend,\n\t.resume = ti_hecc_resume,\n};\n\nmodule_platform_driver(ti_hecc_driver);\n\nMODULE_AUTHOR(\"Anant Gole <anantgole@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(DRV_DESC);\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}