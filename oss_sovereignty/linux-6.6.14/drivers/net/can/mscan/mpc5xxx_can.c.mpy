{
  "module_name": "mpc5xxx_can.c",
  "hash_id": "794e20e4798eb38bd50879d518a146939a85273ce8a9012c7f3755e70fe5bc33",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/mscan/mpc5xxx_can.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/netdevice.h>\n#include <linux/can/dev.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <sysdev/fsl_soc.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <asm/mpc52xx.h>\n\n#include \"mscan.h\"\n\n#define DRV_NAME \"mpc5xxx_can\"\n\nstruct mpc5xxx_can_data {\n\tunsigned int type;\n\tu32 (*get_clock)(struct platform_device *ofdev, const char *clock_name,\n\t\t\t int *mscan_clksrc);\n\tvoid (*put_clock)(struct platform_device *ofdev);\n};\n\n#ifdef CONFIG_PPC_MPC52xx\nstatic const struct of_device_id mpc52xx_cdm_ids[] = {\n\t{ .compatible = \"fsl,mpc5200-cdm\", },\n\t{}\n};\n\nstatic u32 mpc52xx_can_get_clock(struct platform_device *ofdev,\n\t\t\t\t const char *clock_name, int *mscan_clksrc)\n{\n\tunsigned int pvr;\n\tstruct mpc52xx_cdm  __iomem *cdm;\n\tstruct device_node *np_cdm;\n\tunsigned int freq;\n\tu32 val;\n\n\tpvr = mfspr(SPRN_PVR);\n\n\t \n\tif (clock_name && strcmp(clock_name, \"ip\") == 0)\n\t\t*mscan_clksrc = MSCAN_CLKSRC_BUS;\n\telse\n\t\t*mscan_clksrc = MSCAN_CLKSRC_XTAL;\n\n\tfreq = mpc5xxx_get_bus_frequency(&ofdev->dev);\n\tif (!freq)\n\t\treturn 0;\n\n\tif (*mscan_clksrc == MSCAN_CLKSRC_BUS || pvr == 0x80822011)\n\t\treturn freq;\n\n\t \n\tnp_cdm = of_find_matching_node(NULL, mpc52xx_cdm_ids);\n\tif (!np_cdm) {\n\t\tdev_err(&ofdev->dev, \"can't get clock node!\\n\");\n\t\treturn 0;\n\t}\n\tcdm = of_iomap(np_cdm, 0);\n\tif (!cdm) {\n\t\tof_node_put(np_cdm);\n\t\tdev_err(&ofdev->dev, \"can't map clock node!\\n\");\n\t\treturn 0;\n\t}\n\n\tif (in_8(&cdm->ipb_clk_sel) & 0x1)\n\t\tfreq *= 2;\n\tval = in_be32(&cdm->rstcfg);\n\n\tfreq *= (val & (1 << 5)) ? 8 : 4;\n\tfreq /= (val & (1 << 6)) ? 12 : 16;\n\n\tof_node_put(np_cdm);\n\tiounmap(cdm);\n\n\treturn freq;\n}\n#else  \nstatic u32 mpc52xx_can_get_clock(struct platform_device *ofdev,\n\t\t\t\t const char *clock_name, int *mscan_clksrc)\n{\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_PPC_MPC512x\nstatic u32 mpc512x_can_get_clock(struct platform_device *ofdev,\n\t\t\t\t const char *clock_source, int *mscan_clksrc)\n{\n\tstruct device_node *np;\n\tu32 clockdiv;\n\tenum {\n\t\tCLK_FROM_AUTO,\n\t\tCLK_FROM_IPS,\n\t\tCLK_FROM_SYS,\n\t\tCLK_FROM_REF,\n\t} clk_from;\n\tstruct clk *clk_in, *clk_can;\n\tunsigned long freq_calc;\n\tstruct mscan_priv *priv;\n\tstruct clk *clk_ipg;\n\n\t \n\tnp = ofdev->dev.of_node;\n\tclockdiv = 1;\n\tof_property_read_u32(np, \"fsl,mscan-clock-divider\", &clockdiv);\n\tdev_dbg(&ofdev->dev, \"device tree specs: clk src[%s] div[%d]\\n\",\n\t\tclock_source ? clock_source : \"<NULL>\", clockdiv);\n\n\t \n\tclk_from = CLK_FROM_AUTO;\n\tif (clock_source) {\n\t\t \n\t\tif (!strcmp(clock_source, \"ip\"))\n\t\t\tclk_from = CLK_FROM_IPS;\n\t\telse if (!strcmp(clock_source, \"sys\"))\n\t\t\tclk_from = CLK_FROM_SYS;\n\t\telse if (!strcmp(clock_source, \"ref\"))\n\t\t\tclk_from = CLK_FROM_REF;\n\t\telse\n\t\t\tgoto err_invalid;\n\t\tdev_dbg(&ofdev->dev, \"got a clk source spec[%d]\\n\", clk_from);\n\t}\n\tif (clk_from == CLK_FROM_AUTO) {\n\t\t \n\t\tdev_dbg(&ofdev->dev, \"no clk source spec, trying SYS\\n\");\n\t\tclk_in = devm_clk_get(&ofdev->dev, \"sys\");\n\t\tif (IS_ERR(clk_in))\n\t\t\tgoto err_notavail;\n\t\tfreq_calc = clk_get_rate(clk_in);\n\t\tfreq_calc +=  499999;\n\t\tfreq_calc /= 1000000;\n\t\tfreq_calc *= 1000000;\n\t\tif ((freq_calc % 16000000) == 0) {\n\t\t\tclk_from = CLK_FROM_SYS;\n\t\t\tclockdiv = freq_calc / 16000000;\n\t\t\tdev_dbg(&ofdev->dev,\n\t\t\t\t\"clk fit, sys[%lu] div[%d] freq[%lu]\\n\",\n\t\t\t\tfreq_calc, clockdiv, freq_calc / clockdiv);\n\t\t}\n\t}\n\tif (clk_from == CLK_FROM_AUTO) {\n\t\t \n\t\tdev_dbg(&ofdev->dev, \"no clk source spec, trying REF\\n\");\n\t\tclk_in = devm_clk_get(&ofdev->dev, \"ref\");\n\t\tif (IS_ERR(clk_in))\n\t\t\tgoto err_notavail;\n\t\tclk_from = CLK_FROM_REF;\n\t\tfreq_calc = clk_get_rate(clk_in);\n\t\tdev_dbg(&ofdev->dev,\n\t\t\t\"clk fit, ref[%lu] (no div) freq[%lu]\\n\",\n\t\t\tfreq_calc, freq_calc);\n\t}\n\n\t \n\tswitch (clk_from) {\n\tcase CLK_FROM_IPS:\n\t\tclk_can = devm_clk_get(&ofdev->dev, \"ips\");\n\t\tif (IS_ERR(clk_can))\n\t\t\tgoto err_notavail;\n\t\tpriv = netdev_priv(dev_get_drvdata(&ofdev->dev));\n\t\tpriv->clk_can = clk_can;\n\t\tfreq_calc = clk_get_rate(clk_can);\n\t\t*mscan_clksrc = MSCAN_CLKSRC_IPS;\n\t\tdev_dbg(&ofdev->dev, \"clk from IPS, clksrc[%d] freq[%lu]\\n\",\n\t\t\t*mscan_clksrc, freq_calc);\n\t\tbreak;\n\tcase CLK_FROM_SYS:\n\tcase CLK_FROM_REF:\n\t\tclk_can = devm_clk_get(&ofdev->dev, \"mclk\");\n\t\tif (IS_ERR(clk_can))\n\t\t\tgoto err_notavail;\n\t\tpriv = netdev_priv(dev_get_drvdata(&ofdev->dev));\n\t\tpriv->clk_can = clk_can;\n\t\tif (clk_from == CLK_FROM_SYS)\n\t\t\tclk_in = devm_clk_get(&ofdev->dev, \"sys\");\n\t\tif (clk_from == CLK_FROM_REF)\n\t\t\tclk_in = devm_clk_get(&ofdev->dev, \"ref\");\n\t\tif (IS_ERR(clk_in))\n\t\t\tgoto err_notavail;\n\t\tclk_set_parent(clk_can, clk_in);\n\t\tfreq_calc = clk_get_rate(clk_in);\n\t\tfreq_calc /= clockdiv;\n\t\tclk_set_rate(clk_can, freq_calc);\n\t\tfreq_calc = clk_get_rate(clk_can);\n\t\t*mscan_clksrc = MSCAN_CLKSRC_BUS;\n\t\tdev_dbg(&ofdev->dev, \"clk from MCLK, clksrc[%d] freq[%lu]\\n\",\n\t\t\t*mscan_clksrc, freq_calc);\n\t\tbreak;\n\tdefault:\n\t\tgoto err_invalid;\n\t}\n\n\t \n\tclk_ipg = devm_clk_get(&ofdev->dev, \"ipg\");\n\tif (IS_ERR(clk_ipg))\n\t\tgoto err_notavail_ipg;\n\tif (clk_prepare_enable(clk_ipg))\n\t\tgoto err_notavail_ipg;\n\tpriv = netdev_priv(dev_get_drvdata(&ofdev->dev));\n\tpriv->clk_ipg = clk_ipg;\n\n\t \n\treturn freq_calc;\n\nerr_invalid:\n\tdev_err(&ofdev->dev, \"invalid clock source specification\\n\");\n\t \n\treturn 0;\n\nerr_notavail:\n\tdev_err(&ofdev->dev, \"cannot acquire or setup bitrate clock source\\n\");\n\t \n\treturn 0;\n\nerr_notavail_ipg:\n\tdev_err(&ofdev->dev, \"cannot acquire or setup register clock\\n\");\n\t \n\treturn 0;\n}\n\nstatic void mpc512x_can_put_clock(struct platform_device *ofdev)\n{\n\tstruct mscan_priv *priv;\n\n\tpriv = netdev_priv(dev_get_drvdata(&ofdev->dev));\n\tif (priv->clk_ipg)\n\t\tclk_disable_unprepare(priv->clk_ipg);\n}\n#else  \nstatic u32 mpc512x_can_get_clock(struct platform_device *ofdev,\n\t\t\t\t const char *clock_name, int *mscan_clksrc)\n{\n\treturn 0;\n}\n#define mpc512x_can_put_clock NULL\n#endif  \n\nstatic const struct of_device_id mpc5xxx_can_table[];\nstatic int mpc5xxx_can_probe(struct platform_device *ofdev)\n{\n\tconst struct mpc5xxx_can_data *data;\n\tstruct device_node *np = ofdev->dev.of_node;\n\tstruct net_device *dev;\n\tstruct mscan_priv *priv;\n\tvoid __iomem *base;\n\tconst char *clock_name = NULL;\n\tint irq, mscan_clksrc = 0;\n\tint err = -ENOMEM;\n\n\tdata = of_device_get_match_data(&ofdev->dev);\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tbase = of_iomap(np, 0);\n\tif (!base)\n\t\treturn dev_err_probe(&ofdev->dev, err, \"couldn't ioremap\\n\");\n\n\tirq = irq_of_parse_and_map(np, 0);\n\tif (!irq) {\n\t\tdev_err(&ofdev->dev, \"no irq found\\n\");\n\t\terr = -ENODEV;\n\t\tgoto exit_unmap_mem;\n\t}\n\n\tdev = alloc_mscandev();\n\tif (!dev)\n\t\tgoto exit_dispose_irq;\n\tplatform_set_drvdata(ofdev, dev);\n\tSET_NETDEV_DEV(dev, &ofdev->dev);\n\n\tpriv = netdev_priv(dev);\n\tpriv->reg_base = base;\n\tdev->irq = irq;\n\n\tclock_name = of_get_property(np, \"fsl,mscan-clock-source\", NULL);\n\n\tpriv->type = data->type;\n\tpriv->can.clock.freq = data->get_clock(ofdev, clock_name,\n\t\t\t\t\t       &mscan_clksrc);\n\tif (!priv->can.clock.freq) {\n\t\tdev_err(&ofdev->dev, \"couldn't get MSCAN clock properties\\n\");\n\t\tgoto exit_put_clock;\n\t}\n\n\terr = register_mscandev(dev, mscan_clksrc);\n\tif (err) {\n\t\tdev_err(&ofdev->dev, \"registering %s failed (err=%d)\\n\",\n\t\t\tDRV_NAME, err);\n\t\tgoto exit_put_clock;\n\t}\n\n\tdev_info(&ofdev->dev, \"MSCAN at 0x%p, irq %d, clock %d Hz\\n\",\n\t\t priv->reg_base, dev->irq, priv->can.clock.freq);\n\n\treturn 0;\n\nexit_put_clock:\n\tif (data->put_clock)\n\t\tdata->put_clock(ofdev);\n\tfree_candev(dev);\nexit_dispose_irq:\n\tirq_dispose_mapping(irq);\nexit_unmap_mem:\n\tiounmap(base);\n\n\treturn err;\n}\n\nstatic void mpc5xxx_can_remove(struct platform_device *ofdev)\n{\n\tconst struct of_device_id *match;\n\tconst struct mpc5xxx_can_data *data;\n\tstruct net_device *dev = platform_get_drvdata(ofdev);\n\tstruct mscan_priv *priv = netdev_priv(dev);\n\n\tmatch = of_match_device(mpc5xxx_can_table, &ofdev->dev);\n\tdata = match ? match->data : NULL;\n\n\tunregister_mscandev(dev);\n\tif (data && data->put_clock)\n\t\tdata->put_clock(ofdev);\n\tiounmap(priv->reg_base);\n\tirq_dispose_mapping(dev->irq);\n\tfree_candev(dev);\n}\n\n#ifdef CONFIG_PM\nstatic struct mscan_regs saved_regs;\nstatic int mpc5xxx_can_suspend(struct platform_device *ofdev, pm_message_t state)\n{\n\tstruct net_device *dev = platform_get_drvdata(ofdev);\n\tstruct mscan_priv *priv = netdev_priv(dev);\n\tstruct mscan_regs *regs = (struct mscan_regs *)priv->reg_base;\n\n\t_memcpy_fromio(&saved_regs, regs, sizeof(*regs));\n\n\treturn 0;\n}\n\nstatic int mpc5xxx_can_resume(struct platform_device *ofdev)\n{\n\tstruct net_device *dev = platform_get_drvdata(ofdev);\n\tstruct mscan_priv *priv = netdev_priv(dev);\n\tstruct mscan_regs *regs = (struct mscan_regs *)priv->reg_base;\n\n\tregs->canctl0 |= MSCAN_INITRQ;\n\twhile (!(regs->canctl1 & MSCAN_INITAK))\n\t\tudelay(10);\n\n\tregs->canctl1 = saved_regs.canctl1;\n\tregs->canbtr0 = saved_regs.canbtr0;\n\tregs->canbtr1 = saved_regs.canbtr1;\n\tregs->canidac = saved_regs.canidac;\n\n\t \n\t_memcpy_toio(&regs->canidar1_0, (void *)&saved_regs.canidar1_0,\n\t\t     sizeof(*regs) - offsetof(struct mscan_regs, canidar1_0));\n\n\tregs->canctl0 &= ~MSCAN_INITRQ;\n\tregs->cantbsel = saved_regs.cantbsel;\n\tregs->canrier = saved_regs.canrier;\n\tregs->cantier = saved_regs.cantier;\n\tregs->canctl0 = saved_regs.canctl0;\n\n\treturn 0;\n}\n#endif\n\nstatic const struct mpc5xxx_can_data mpc5200_can_data = {\n\t.type = MSCAN_TYPE_MPC5200,\n\t.get_clock = mpc52xx_can_get_clock,\n\t \n};\n\nstatic const struct mpc5xxx_can_data mpc5121_can_data = {\n\t.type = MSCAN_TYPE_MPC5121,\n\t.get_clock = mpc512x_can_get_clock,\n\t.put_clock = mpc512x_can_put_clock,\n};\n\nstatic const struct of_device_id mpc5xxx_can_table[] = {\n\t{ .compatible = \"fsl,mpc5200-mscan\", .data = &mpc5200_can_data, },\n\t \n\t{ .compatible = \"fsl,mpc5121-mscan\", .data = &mpc5121_can_data, },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mpc5xxx_can_table);\n\nstatic struct platform_driver mpc5xxx_can_driver = {\n\t.driver = {\n\t\t.name = \"mpc5xxx_can\",\n\t\t.of_match_table = mpc5xxx_can_table,\n\t},\n\t.probe = mpc5xxx_can_probe,\n\t.remove_new = mpc5xxx_can_remove,\n#ifdef CONFIG_PM\n\t.suspend = mpc5xxx_can_suspend,\n\t.resume = mpc5xxx_can_resume,\n#endif\n};\n\nmodule_platform_driver(mpc5xxx_can_driver);\n\nMODULE_AUTHOR(\"Wolfgang Grandegger <wg@grandegger.com>\");\nMODULE_DESCRIPTION(\"Freescale MPC5xxx CAN driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}