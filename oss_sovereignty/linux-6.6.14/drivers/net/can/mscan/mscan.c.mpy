{
  "module_name": "mscan.c",
  "hash_id": "45cf8184d89ae291b7cccb623f887d1a832addb737527f4a0db676f9e9952428",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/mscan/mscan.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/list.h>\n#include <linux/can/dev.h>\n#include <linux/can/error.h>\n#include <linux/io.h>\n\n#include \"mscan.h\"\n\nstatic const struct can_bittiming_const mscan_bittiming_const = {\n\t.name = \"mscan\",\n\t.tseg1_min = 4,\n\t.tseg1_max = 16,\n\t.tseg2_min = 2,\n\t.tseg2_max = 8,\n\t.sjw_max = 4,\n\t.brp_min = 1,\n\t.brp_max = 64,\n\t.brp_inc = 1,\n};\n\nstruct mscan_state {\n\tu8 mode;\n\tu8 canrier;\n\tu8 cantier;\n};\n\nstatic enum can_state state_map[] = {\n\tCAN_STATE_ERROR_ACTIVE,\n\tCAN_STATE_ERROR_WARNING,\n\tCAN_STATE_ERROR_PASSIVE,\n\tCAN_STATE_BUS_OFF\n};\n\nstatic int mscan_set_mode(struct net_device *dev, u8 mode)\n{\n\tstruct mscan_priv *priv = netdev_priv(dev);\n\tstruct mscan_regs __iomem *regs = priv->reg_base;\n\tint ret = 0;\n\tint i;\n\tu8 canctl1;\n\n\tif (mode != MSCAN_NORMAL_MODE) {\n\t\tif (priv->tx_active) {\n\t\t\t #\n\t\t\tout_8(&regs->cantarq, priv->tx_active);\n\t\t\t \n\t\t\tout_8(&regs->cantier, 0);\n\t\t}\n\n\t\tcanctl1 = in_8(&regs->canctl1);\n\t\tif ((mode & MSCAN_SLPRQ) && !(canctl1 & MSCAN_SLPAK)) {\n\t\t\tsetbits8(&regs->canctl0, MSCAN_SLPRQ);\n\t\t\tfor (i = 0; i < MSCAN_SET_MODE_RETRIES; i++) {\n\t\t\t\tif (in_8(&regs->canctl1) & MSCAN_SLPAK)\n\t\t\t\t\tbreak;\n\t\t\t\tudelay(100);\n\t\t\t}\n\t\t\t \n\t\t\tif (i >= MSCAN_SET_MODE_RETRIES)\n\t\t\t\tnetdev_dbg(dev,\n\t\t\t\t\t   \"device failed to enter sleep mode. \"\n\t\t\t\t\t   \"We proceed anyhow.\\n\");\n\t\t\telse\n\t\t\t\tpriv->can.state = CAN_STATE_SLEEPING;\n\t\t}\n\n\t\tif ((mode & MSCAN_INITRQ) && !(canctl1 & MSCAN_INITAK)) {\n\t\t\tsetbits8(&regs->canctl0, MSCAN_INITRQ);\n\t\t\tfor (i = 0; i < MSCAN_SET_MODE_RETRIES; i++) {\n\t\t\t\tif (in_8(&regs->canctl1) & MSCAN_INITAK)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i >= MSCAN_SET_MODE_RETRIES)\n\t\t\t\tret = -ENODEV;\n\t\t}\n\t\tif (!ret)\n\t\t\tpriv->can.state = CAN_STATE_STOPPED;\n\n\t\tif (mode & MSCAN_CSWAI)\n\t\t\tsetbits8(&regs->canctl0, MSCAN_CSWAI);\n\n\t} else {\n\t\tcanctl1 = in_8(&regs->canctl1);\n\t\tif (canctl1 & (MSCAN_SLPAK | MSCAN_INITAK)) {\n\t\t\tclrbits8(&regs->canctl0, MSCAN_SLPRQ | MSCAN_INITRQ);\n\t\t\tfor (i = 0; i < MSCAN_SET_MODE_RETRIES; i++) {\n\t\t\t\tcanctl1 = in_8(&regs->canctl1);\n\t\t\t\tif (!(canctl1 & (MSCAN_INITAK | MSCAN_SLPAK)))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i >= MSCAN_SET_MODE_RETRIES)\n\t\t\t\tret = -ENODEV;\n\t\t\telse\n\t\t\t\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int mscan_start(struct net_device *dev)\n{\n\tstruct mscan_priv *priv = netdev_priv(dev);\n\tstruct mscan_regs __iomem *regs = priv->reg_base;\n\tu8 canrflg;\n\tint err;\n\n\tout_8(&regs->canrier, 0);\n\n\tINIT_LIST_HEAD(&priv->tx_head);\n\tpriv->prev_buf_id = 0;\n\tpriv->cur_pri = 0;\n\tpriv->tx_active = 0;\n\tpriv->shadow_canrier = 0;\n\tpriv->flags = 0;\n\n\tif (priv->type == MSCAN_TYPE_MPC5121) {\n\t\t \n\t\tif (in_8(&regs->canmisc) & MSCAN_BOHOLD)\n\t\t\tout_8(&regs->canmisc, MSCAN_BOHOLD);\n\t}\n\n\terr = mscan_set_mode(dev, MSCAN_NORMAL_MODE);\n\tif (err)\n\t\treturn err;\n\n\tcanrflg = in_8(&regs->canrflg);\n\tpriv->shadow_statflg = canrflg & MSCAN_STAT_MSK;\n\tpriv->can.state = state_map[max(MSCAN_STATE_RX(canrflg),\n\t\t\t\t    MSCAN_STATE_TX(canrflg))];\n\tout_8(&regs->cantier, 0);\n\n\t \n\tout_8(&regs->canrier, MSCAN_RX_INTS_ENABLE);\n\n\treturn 0;\n}\n\nstatic int mscan_restart(struct net_device *dev)\n{\n\tstruct mscan_priv *priv = netdev_priv(dev);\n\n\tif (priv->type == MSCAN_TYPE_MPC5121) {\n\t\tstruct mscan_regs __iomem *regs = priv->reg_base;\n\n\t\tpriv->can.state = CAN_STATE_ERROR_ACTIVE;\n\t\tWARN(!(in_8(&regs->canmisc) & MSCAN_BOHOLD),\n\t\t     \"bus-off state expected\\n\");\n\t\tout_8(&regs->canmisc, MSCAN_BOHOLD);\n\t\t \n\t\tout_8(&regs->canrier, MSCAN_RX_INTS_ENABLE);\n\t} else {\n\t\tif (priv->can.state <= CAN_STATE_BUS_OFF)\n\t\t\tmscan_set_mode(dev, MSCAN_INIT_MODE);\n\t\treturn mscan_start(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic netdev_tx_t mscan_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct can_frame *frame = (struct can_frame *)skb->data;\n\tstruct mscan_priv *priv = netdev_priv(dev);\n\tstruct mscan_regs __iomem *regs = priv->reg_base;\n\tint i, rtr, buf_id;\n\tu32 can_id;\n\n\tif (can_dev_dropped_skb(dev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tout_8(&regs->cantier, 0);\n\n\ti = ~priv->tx_active & MSCAN_TXE;\n\tbuf_id = ffs(i) - 1;\n\tswitch (hweight8(i)) {\n\tcase 0:\n\t\tnetif_stop_queue(dev);\n\t\tnetdev_err(dev, \"Tx Ring full when queue awake!\\n\");\n\t\treturn NETDEV_TX_BUSY;\n\tcase 1:\n\t\t \n\t\tnetif_stop_queue(dev);\n\t\tfallthrough;\n\tcase 2:\n\t\tif (buf_id < priv->prev_buf_id) {\n\t\t\tpriv->cur_pri++;\n\t\t\tif (priv->cur_pri == 0xff) {\n\t\t\t\tset_bit(F_TX_WAIT_ALL, &priv->flags);\n\t\t\t\tnetif_stop_queue(dev);\n\t\t\t}\n\t\t}\n\t\tset_bit(F_TX_PROGRESS, &priv->flags);\n\t\tbreak;\n\t}\n\tpriv->prev_buf_id = buf_id;\n\tout_8(&regs->cantbsel, i);\n\n\trtr = frame->can_id & CAN_RTR_FLAG;\n\n\t \n\tif (frame->can_id & CAN_EFF_FLAG) {\n\t\tcan_id = (frame->can_id & CAN_EFF_MASK)\n\t\t\t << (MSCAN_EFF_RTR_SHIFT + 1);\n\t\tif (rtr)\n\t\t\tcan_id |= 1 << MSCAN_EFF_RTR_SHIFT;\n\t\tout_be16(&regs->tx.idr3_2, can_id);\n\n\t\tcan_id >>= 16;\n\t\t \n\t\tcan_id = (can_id & 0x7) | ((can_id << 2) & 0xffe0)\n\t\t\t | MSCAN_EFF_FLAGS;\n\t} else {\n\t\tcan_id = (frame->can_id & CAN_SFF_MASK)\n\t\t\t << (MSCAN_SFF_RTR_SHIFT + 1);\n\t\tif (rtr)\n\t\t\tcan_id |= 1 << MSCAN_SFF_RTR_SHIFT;\n\t}\n\tout_be16(&regs->tx.idr1_0, can_id);\n\n\tif (!rtr) {\n\t\tvoid __iomem *data = &regs->tx.dsr1_0;\n\t\tu16 *payload = (u16 *)frame->data;\n\n\t\tfor (i = 0; i < frame->len / 2; i++) {\n\t\t\tout_be16(data, *payload++);\n\t\t\tdata += 2 + _MSCAN_RESERVED_DSR_SIZE;\n\t\t}\n\t\t \n\t\tif (frame->len & 1)\n\t\t\tout_8(data, frame->data[frame->len - 1]);\n\t}\n\n\tout_8(&regs->tx.dlr, frame->len);\n\tout_8(&regs->tx.tbpr, priv->cur_pri);\n\n\t \n\tout_8(&regs->cantflg, 1 << buf_id);\n\n\tif (!test_bit(F_TX_PROGRESS, &priv->flags))\n\t\tnetif_trans_update(dev);\n\n\tlist_add_tail(&priv->tx_queue[buf_id].list, &priv->tx_head);\n\n\tcan_put_echo_skb(skb, dev, buf_id, 0);\n\n\t \n\tpriv->tx_active |= 1 << buf_id;\n\tout_8(&regs->cantier, priv->tx_active);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic enum can_state get_new_state(struct net_device *dev, u8 canrflg)\n{\n\tstruct mscan_priv *priv = netdev_priv(dev);\n\n\tif (unlikely(canrflg & MSCAN_CSCIF))\n\t\treturn state_map[max(MSCAN_STATE_RX(canrflg),\n\t\t\t\t MSCAN_STATE_TX(canrflg))];\n\n\treturn priv->can.state;\n}\n\nstatic void mscan_get_rx_frame(struct net_device *dev, struct can_frame *frame)\n{\n\tstruct mscan_priv *priv = netdev_priv(dev);\n\tstruct mscan_regs __iomem *regs = priv->reg_base;\n\tu32 can_id;\n\tint i;\n\n\tcan_id = in_be16(&regs->rx.idr1_0);\n\tif (can_id & (1 << 3)) {\n\t\tframe->can_id = CAN_EFF_FLAG;\n\t\tcan_id = ((can_id << 16) | in_be16(&regs->rx.idr3_2));\n\t\tcan_id = ((can_id & 0xffe00000) |\n\t\t\t  ((can_id & 0x7ffff) << 2)) >> 2;\n\t} else {\n\t\tcan_id >>= 4;\n\t\tframe->can_id = 0;\n\t}\n\n\tframe->can_id |= can_id >> 1;\n\tif (can_id & 1)\n\t\tframe->can_id |= CAN_RTR_FLAG;\n\n\tframe->len = can_cc_dlc2len(in_8(&regs->rx.dlr) & 0xf);\n\n\tif (!(frame->can_id & CAN_RTR_FLAG)) {\n\t\tvoid __iomem *data = &regs->rx.dsr1_0;\n\t\tu16 *payload = (u16 *)frame->data;\n\n\t\tfor (i = 0; i < frame->len / 2; i++) {\n\t\t\t*payload++ = in_be16(data);\n\t\t\tdata += 2 + _MSCAN_RESERVED_DSR_SIZE;\n\t\t}\n\t\t \n\t\tif (frame->len & 1)\n\t\t\tframe->data[frame->len - 1] = in_8(data);\n\t}\n\n\tout_8(&regs->canrflg, MSCAN_RXF);\n}\n\nstatic void mscan_get_err_frame(struct net_device *dev, struct can_frame *frame,\n\t\t\t\tu8 canrflg)\n{\n\tstruct mscan_priv *priv = netdev_priv(dev);\n\tstruct mscan_regs __iomem *regs = priv->reg_base;\n\tstruct net_device_stats *stats = &dev->stats;\n\tenum can_state new_state;\n\n\tnetdev_dbg(dev, \"error interrupt (canrflg=%#x)\\n\", canrflg);\n\tframe->can_id = CAN_ERR_FLAG;\n\n\tif (canrflg & MSCAN_OVRIF) {\n\t\tframe->can_id |= CAN_ERR_CRTL;\n\t\tframe->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\n\t\tstats->rx_over_errors++;\n\t\tstats->rx_errors++;\n\t} else {\n\t\tframe->data[1] = 0;\n\t}\n\n\tnew_state = get_new_state(dev, canrflg);\n\tif (new_state != priv->can.state) {\n\t\tcan_change_state(dev, frame,\n\t\t\t\t state_map[MSCAN_STATE_TX(canrflg)],\n\t\t\t\t state_map[MSCAN_STATE_RX(canrflg)]);\n\n\t\tif (priv->can.state == CAN_STATE_BUS_OFF) {\n\t\t\t \n\t\t\tif (priv->type != MSCAN_TYPE_MPC5121) {\n\t\t\t\tout_8(&regs->cantier, 0);\n\t\t\t\tout_8(&regs->canrier, 0);\n\t\t\t\tsetbits8(&regs->canctl0,\n\t\t\t\t\t MSCAN_SLPRQ | MSCAN_INITRQ);\n\t\t\t}\n\t\t\tcan_bus_off(dev);\n\t\t}\n\t}\n\tpriv->shadow_statflg = canrflg & MSCAN_STAT_MSK;\n\tframe->len = CAN_ERR_DLC;\n\tout_8(&regs->canrflg, MSCAN_ERR_IF);\n}\n\nstatic int mscan_rx_poll(struct napi_struct *napi, int quota)\n{\n\tstruct mscan_priv *priv = container_of(napi, struct mscan_priv, napi);\n\tstruct net_device *dev = napi->dev;\n\tstruct mscan_regs __iomem *regs = priv->reg_base;\n\tstruct net_device_stats *stats = &dev->stats;\n\tint work_done = 0;\n\tstruct sk_buff *skb;\n\tstruct can_frame *frame;\n\tu8 canrflg;\n\n\twhile (work_done < quota) {\n\t\tcanrflg = in_8(&regs->canrflg);\n\t\tif (!(canrflg & (MSCAN_RXF | MSCAN_ERR_IF)))\n\t\t\tbreak;\n\n\t\tskb = alloc_can_skb(dev, &frame);\n\t\tif (!skb) {\n\t\t\tif (printk_ratelimit())\n\t\t\t\tnetdev_notice(dev, \"packet dropped\\n\");\n\t\t\tstats->rx_dropped++;\n\t\t\tout_8(&regs->canrflg, canrflg);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (canrflg & MSCAN_RXF) {\n\t\t\tmscan_get_rx_frame(dev, frame);\n\t\t\tstats->rx_packets++;\n\t\t\tif (!(frame->can_id & CAN_RTR_FLAG))\n\t\t\t\tstats->rx_bytes += frame->len;\n\t\t} else if (canrflg & MSCAN_ERR_IF) {\n\t\t\tmscan_get_err_frame(dev, frame, canrflg);\n\t\t}\n\n\t\twork_done++;\n\t\tnetif_receive_skb(skb);\n\t}\n\n\tif (work_done < quota) {\n\t\tif (likely(napi_complete_done(&priv->napi, work_done))) {\n\t\t\tclear_bit(F_RX_PROGRESS, &priv->flags);\n\t\t\tif (priv->can.state < CAN_STATE_BUS_OFF)\n\t\t\t\tout_8(&regs->canrier, priv->shadow_canrier);\n\t\t}\n\t}\n\treturn work_done;\n}\n\nstatic irqreturn_t mscan_isr(int irq, void *dev_id)\n{\n\tstruct net_device *dev = (struct net_device *)dev_id;\n\tstruct mscan_priv *priv = netdev_priv(dev);\n\tstruct mscan_regs __iomem *regs = priv->reg_base;\n\tstruct net_device_stats *stats = &dev->stats;\n\tu8 cantier, cantflg, canrflg;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tcantier = in_8(&regs->cantier) & MSCAN_TXE;\n\tcantflg = in_8(&regs->cantflg) & cantier;\n\n\tif (cantier && cantflg) {\n\t\tstruct list_head *tmp, *pos;\n\n\t\tlist_for_each_safe(pos, tmp, &priv->tx_head) {\n\t\t\tstruct tx_queue_entry *entry =\n\t\t\t    list_entry(pos, struct tx_queue_entry, list);\n\t\t\tu8 mask = entry->mask;\n\n\t\t\tif (!(cantflg & mask))\n\t\t\t\tcontinue;\n\n\t\t\tout_8(&regs->cantbsel, mask);\n\t\t\tstats->tx_bytes += can_get_echo_skb(dev, entry->id,\n\t\t\t\t\t\t\t    NULL);\n\t\t\tstats->tx_packets++;\n\t\t\tpriv->tx_active &= ~mask;\n\t\t\tlist_del(pos);\n\t\t}\n\n\t\tif (list_empty(&priv->tx_head)) {\n\t\t\tclear_bit(F_TX_WAIT_ALL, &priv->flags);\n\t\t\tclear_bit(F_TX_PROGRESS, &priv->flags);\n\t\t\tpriv->cur_pri = 0;\n\t\t} else {\n\t\t\tnetif_trans_update(dev);\n\t\t}\n\n\t\tif (!test_bit(F_TX_WAIT_ALL, &priv->flags))\n\t\t\tnetif_wake_queue(dev);\n\n\t\tout_8(&regs->cantier, priv->tx_active);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tcanrflg = in_8(&regs->canrflg);\n\tif ((canrflg & ~MSCAN_STAT_MSK) &&\n\t    !test_and_set_bit(F_RX_PROGRESS, &priv->flags)) {\n\t\tif (canrflg & ~MSCAN_STAT_MSK) {\n\t\t\tpriv->shadow_canrier = in_8(&regs->canrier);\n\t\t\tout_8(&regs->canrier, 0);\n\t\t\tnapi_schedule(&priv->napi);\n\t\t\tret = IRQ_HANDLED;\n\t\t} else {\n\t\t\tclear_bit(F_RX_PROGRESS, &priv->flags);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int mscan_do_set_mode(struct net_device *dev, enum can_mode mode)\n{\n\tint ret = 0;\n\n\tswitch (mode) {\n\tcase CAN_MODE_START:\n\t\tret = mscan_restart(dev);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (netif_queue_stopped(dev))\n\t\t\tnetif_wake_queue(dev);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int mscan_do_set_bittiming(struct net_device *dev)\n{\n\tstruct mscan_priv *priv = netdev_priv(dev);\n\tstruct mscan_regs __iomem *regs = priv->reg_base;\n\tstruct can_bittiming *bt = &priv->can.bittiming;\n\tu8 btr0, btr1;\n\n\tbtr0 = BTR0_SET_BRP(bt->brp) | BTR0_SET_SJW(bt->sjw);\n\tbtr1 = (BTR1_SET_TSEG1(bt->prop_seg + bt->phase_seg1) |\n\t\tBTR1_SET_TSEG2(bt->phase_seg2) |\n\t\tBTR1_SET_SAM(priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES));\n\n\tnetdev_info(dev, \"setting BTR0=0x%02x BTR1=0x%02x\\n\", btr0, btr1);\n\n\tout_8(&regs->canbtr0, btr0);\n\tout_8(&regs->canbtr1, btr1);\n\n\treturn 0;\n}\n\nstatic int mscan_get_berr_counter(const struct net_device *dev,\n\t\t\t\t  struct can_berr_counter *bec)\n{\n\tstruct mscan_priv *priv = netdev_priv(dev);\n\tstruct mscan_regs __iomem *regs = priv->reg_base;\n\n\tbec->txerr = in_8(&regs->cantxerr);\n\tbec->rxerr = in_8(&regs->canrxerr);\n\n\treturn 0;\n}\n\nstatic int mscan_open(struct net_device *dev)\n{\n\tint ret;\n\tstruct mscan_priv *priv = netdev_priv(dev);\n\tstruct mscan_regs __iomem *regs = priv->reg_base;\n\n\tret = clk_prepare_enable(priv->clk_ipg);\n\tif (ret)\n\t\tgoto exit_retcode;\n\tret = clk_prepare_enable(priv->clk_can);\n\tif (ret)\n\t\tgoto exit_dis_ipg_clock;\n\n\t \n\tret = open_candev(dev);\n\tif (ret)\n\t\tgoto exit_dis_can_clock;\n\n\tnapi_enable(&priv->napi);\n\n\tret = request_irq(dev->irq, mscan_isr, 0, dev->name, dev);\n\tif (ret < 0) {\n\t\tnetdev_err(dev, \"failed to attach interrupt\\n\");\n\t\tgoto exit_napi_disable;\n\t}\n\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tsetbits8(&regs->canctl1, MSCAN_LISTEN);\n\telse\n\t\tclrbits8(&regs->canctl1, MSCAN_LISTEN);\n\n\tret = mscan_start(dev);\n\tif (ret)\n\t\tgoto exit_free_irq;\n\n\tnetif_start_queue(dev);\n\n\treturn 0;\n\nexit_free_irq:\n\tfree_irq(dev->irq, dev);\nexit_napi_disable:\n\tnapi_disable(&priv->napi);\n\tclose_candev(dev);\nexit_dis_can_clock:\n\tclk_disable_unprepare(priv->clk_can);\nexit_dis_ipg_clock:\n\tclk_disable_unprepare(priv->clk_ipg);\nexit_retcode:\n\treturn ret;\n}\n\nstatic int mscan_close(struct net_device *dev)\n{\n\tstruct mscan_priv *priv = netdev_priv(dev);\n\tstruct mscan_regs __iomem *regs = priv->reg_base;\n\n\tnetif_stop_queue(dev);\n\tnapi_disable(&priv->napi);\n\n\tout_8(&regs->cantier, 0);\n\tout_8(&regs->canrier, 0);\n\tmscan_set_mode(dev, MSCAN_INIT_MODE);\n\tclose_candev(dev);\n\tfree_irq(dev->irq, dev);\n\n\tclk_disable_unprepare(priv->clk_can);\n\tclk_disable_unprepare(priv->clk_ipg);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops mscan_netdev_ops = {\n\t.ndo_open\t= mscan_open,\n\t.ndo_stop\t= mscan_close,\n\t.ndo_start_xmit\t= mscan_start_xmit,\n\t.ndo_change_mtu\t= can_change_mtu,\n};\n\nstatic const struct ethtool_ops mscan_ethtool_ops = {\n\t.get_ts_info = ethtool_op_get_ts_info,\n};\n\nint register_mscandev(struct net_device *dev, int mscan_clksrc)\n{\n\tstruct mscan_priv *priv = netdev_priv(dev);\n\tstruct mscan_regs __iomem *regs = priv->reg_base;\n\tu8 ctl1;\n\n\tctl1 = in_8(&regs->canctl1);\n\tif (mscan_clksrc)\n\t\tctl1 |= MSCAN_CLKSRC;\n\telse\n\t\tctl1 &= ~MSCAN_CLKSRC;\n\n\tif (priv->type == MSCAN_TYPE_MPC5121) {\n\t\tpriv->can.do_get_berr_counter = mscan_get_berr_counter;\n\t\tctl1 |= MSCAN_BORM;  \n\t}\n\n\tctl1 |= MSCAN_CANE;\n\tout_8(&regs->canctl1, ctl1);\n\tudelay(100);\n\n\t \n\tout_be16(&regs->canidar1_0, 0);\n\tout_be16(&regs->canidar3_2, 0);\n\tout_be16(&regs->canidar5_4, 0);\n\tout_be16(&regs->canidar7_6, 0);\n\n\tout_be16(&regs->canidmr1_0, 0xffff);\n\tout_be16(&regs->canidmr3_2, 0xffff);\n\tout_be16(&regs->canidmr5_4, 0xffff);\n\tout_be16(&regs->canidmr7_6, 0xffff);\n\t \n\tout_8(&regs->canidac, MSCAN_AF_32BIT);\n\n\tmscan_set_mode(dev, MSCAN_INIT_MODE);\n\n\treturn register_candev(dev);\n}\n\nvoid unregister_mscandev(struct net_device *dev)\n{\n\tstruct mscan_priv *priv = netdev_priv(dev);\n\tstruct mscan_regs __iomem *regs = priv->reg_base;\n\tmscan_set_mode(dev, MSCAN_INIT_MODE);\n\tclrbits8(&regs->canctl1, MSCAN_CANE);\n\tunregister_candev(dev);\n}\n\nstruct net_device *alloc_mscandev(void)\n{\n\tstruct net_device *dev;\n\tstruct mscan_priv *priv;\n\tint i;\n\n\tdev = alloc_candev(sizeof(struct mscan_priv), MSCAN_ECHO_SKB_MAX);\n\tif (!dev)\n\t\treturn NULL;\n\tpriv = netdev_priv(dev);\n\n\tdev->netdev_ops = &mscan_netdev_ops;\n\tdev->ethtool_ops = &mscan_ethtool_ops;\n\n\tdev->flags |= IFF_ECHO;\t \n\n\tnetif_napi_add_weight(dev, &priv->napi, mscan_rx_poll, 8);\n\n\tpriv->can.bittiming_const = &mscan_bittiming_const;\n\tpriv->can.do_set_bittiming = mscan_do_set_bittiming;\n\tpriv->can.do_set_mode = mscan_do_set_mode;\n\tpriv->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES |\n\t\tCAN_CTRLMODE_LISTENONLY;\n\n\tfor (i = 0; i < TX_QUEUE_SIZE; i++) {\n\t\tpriv->tx_queue[i].id = i;\n\t\tpriv->tx_queue[i].mask = 1 << i;\n\t}\n\n\treturn dev;\n}\n\nMODULE_AUTHOR(\"Andrey Volkov <avolkov@varma-el.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"CAN port driver for a MSCAN based chips\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}