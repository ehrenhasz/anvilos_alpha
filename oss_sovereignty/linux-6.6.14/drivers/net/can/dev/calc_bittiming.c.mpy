{
  "module_name": "calc_bittiming.c",
  "hash_id": "fd8b29dc9e8b73d0a92c17e0545beba387aa75563784eb424f6be1cc351f7095",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/dev/calc_bittiming.c",
  "human_readable_source": "\n \n\n#include <linux/units.h>\n#include <linux/can/dev.h>\n\n#define CAN_CALC_MAX_ERROR 50  \n\n \nstatic int\ncan_update_sample_point(const struct can_bittiming_const *btc,\n\t\t\tconst unsigned int sample_point_nominal, const unsigned int tseg,\n\t\t\tunsigned int *tseg1_ptr, unsigned int *tseg2_ptr,\n\t\t\tunsigned int *sample_point_error_ptr)\n{\n\tunsigned int sample_point_error, best_sample_point_error = UINT_MAX;\n\tunsigned int sample_point, best_sample_point = 0;\n\tunsigned int tseg1, tseg2;\n\tint i;\n\n\tfor (i = 0; i <= 1; i++) {\n\t\ttseg2 = tseg + CAN_SYNC_SEG -\n\t\t\t(sample_point_nominal * (tseg + CAN_SYNC_SEG)) /\n\t\t\t1000 - i;\n\t\ttseg2 = clamp(tseg2, btc->tseg2_min, btc->tseg2_max);\n\t\ttseg1 = tseg - tseg2;\n\t\tif (tseg1 > btc->tseg1_max) {\n\t\t\ttseg1 = btc->tseg1_max;\n\t\t\ttseg2 = tseg - tseg1;\n\t\t}\n\n\t\tsample_point = 1000 * (tseg + CAN_SYNC_SEG - tseg2) /\n\t\t\t(tseg + CAN_SYNC_SEG);\n\t\tsample_point_error = abs(sample_point_nominal - sample_point);\n\n\t\tif (sample_point <= sample_point_nominal &&\n\t\t    sample_point_error < best_sample_point_error) {\n\t\t\tbest_sample_point = sample_point;\n\t\t\tbest_sample_point_error = sample_point_error;\n\t\t\t*tseg1_ptr = tseg1;\n\t\t\t*tseg2_ptr = tseg2;\n\t\t}\n\t}\n\n\tif (sample_point_error_ptr)\n\t\t*sample_point_error_ptr = best_sample_point_error;\n\n\treturn best_sample_point;\n}\n\nint can_calc_bittiming(const struct net_device *dev, struct can_bittiming *bt,\n\t\t       const struct can_bittiming_const *btc, struct netlink_ext_ack *extack)\n{\n\tstruct can_priv *priv = netdev_priv(dev);\n\tunsigned int bitrate;\t\t\t \n\tunsigned int bitrate_error;\t\t \n\tunsigned int best_bitrate_error = UINT_MAX;\n\tunsigned int sample_point_error;\t \n\tunsigned int best_sample_point_error = UINT_MAX;\n\tunsigned int sample_point_nominal;\t \n\tunsigned int best_tseg = 0;\t\t \n\tunsigned int best_brp = 0;\t\t \n\tunsigned int brp, tsegall, tseg, tseg1 = 0, tseg2 = 0;\n\tu64 v64;\n\tint err;\n\n\t \n\tif (bt->sample_point) {\n\t\tsample_point_nominal = bt->sample_point;\n\t} else {\n\t\tif (bt->bitrate > 800 * KILO  )\n\t\t\tsample_point_nominal = 750;\n\t\telse if (bt->bitrate > 500 * KILO  )\n\t\t\tsample_point_nominal = 800;\n\t\telse\n\t\t\tsample_point_nominal = 875;\n\t}\n\n\t \n\tfor (tseg = (btc->tseg1_max + btc->tseg2_max) * 2 + 1;\n\t     tseg >= (btc->tseg1_min + btc->tseg2_min) * 2; tseg--) {\n\t\ttsegall = CAN_SYNC_SEG + tseg / 2;\n\n\t\t \n\t\tbrp = priv->clock.freq / (tsegall * bt->bitrate) + tseg % 2;\n\n\t\t \n\t\tbrp = (brp / btc->brp_inc) * btc->brp_inc;\n\t\tif (brp < btc->brp_min || brp > btc->brp_max)\n\t\t\tcontinue;\n\n\t\tbitrate = priv->clock.freq / (brp * tsegall);\n\t\tbitrate_error = abs(bt->bitrate - bitrate);\n\n\t\t \n\t\tif (bitrate_error > best_bitrate_error)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (bitrate_error < best_bitrate_error)\n\t\t\tbest_sample_point_error = UINT_MAX;\n\n\t\tcan_update_sample_point(btc, sample_point_nominal, tseg / 2,\n\t\t\t\t\t&tseg1, &tseg2, &sample_point_error);\n\t\tif (sample_point_error >= best_sample_point_error)\n\t\t\tcontinue;\n\n\t\tbest_sample_point_error = sample_point_error;\n\t\tbest_bitrate_error = bitrate_error;\n\t\tbest_tseg = tseg / 2;\n\t\tbest_brp = brp;\n\n\t\tif (bitrate_error == 0 && sample_point_error == 0)\n\t\t\tbreak;\n\t}\n\n\tif (best_bitrate_error) {\n\t\t \n\t\tv64 = (u64)best_bitrate_error * 1000;\n\t\tdo_div(v64, bt->bitrate);\n\t\tbitrate_error = (u32)v64;\n\t\tif (bitrate_error > CAN_CALC_MAX_ERROR) {\n\t\t\tNL_SET_ERR_MSG_FMT(extack,\n\t\t\t\t\t   \"bitrate error: %u.%u%% too high\",\n\t\t\t\t\t   bitrate_error / 10, bitrate_error % 10);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tNL_SET_ERR_MSG_FMT(extack,\n\t\t\t\t   \"bitrate error: %u.%u%%\",\n\t\t\t\t   bitrate_error / 10, bitrate_error % 10);\n\t}\n\n\t \n\tbt->sample_point = can_update_sample_point(btc, sample_point_nominal,\n\t\t\t\t\t\t   best_tseg, &tseg1, &tseg2,\n\t\t\t\t\t\t   NULL);\n\n\tv64 = (u64)best_brp * 1000 * 1000 * 1000;\n\tdo_div(v64, priv->clock.freq);\n\tbt->tq = (u32)v64;\n\tbt->prop_seg = tseg1 / 2;\n\tbt->phase_seg1 = tseg1 - bt->prop_seg;\n\tbt->phase_seg2 = tseg2;\n\n\tcan_sjw_set_default(bt);\n\n\terr = can_sjw_check(dev, bt, btc, extack);\n\tif (err)\n\t\treturn err;\n\n\tbt->brp = best_brp;\n\n\t \n\tbt->bitrate = priv->clock.freq /\n\t\t(bt->brp * can_bit_time(bt));\n\n\treturn 0;\n}\n\nvoid can_calc_tdco(struct can_tdc *tdc, const struct can_tdc_const *tdc_const,\n\t\t   const struct can_bittiming *dbt,\n\t\t   u32 *ctrlmode, u32 ctrlmode_supported)\n\n{\n\tif (!tdc_const || !(ctrlmode_supported & CAN_CTRLMODE_TDC_AUTO))\n\t\treturn;\n\n\t*ctrlmode &= ~CAN_CTRLMODE_TDC_MASK;\n\n\t \n\tif (dbt->brp == 1 || dbt->brp == 2) {\n\t\t \n\t\tu32 sample_point_in_tc = (CAN_SYNC_SEG + dbt->prop_seg +\n\t\t\t\t\t  dbt->phase_seg1) * dbt->brp;\n\n\t\tif (sample_point_in_tc < tdc_const->tdco_min)\n\t\t\treturn;\n\t\ttdc->tdco = min(sample_point_in_tc, tdc_const->tdco_max);\n\t\t*ctrlmode |= CAN_CTRLMODE_TDC_AUTO;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}