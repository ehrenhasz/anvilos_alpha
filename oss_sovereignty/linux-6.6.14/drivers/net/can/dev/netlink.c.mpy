{
  "module_name": "netlink.c",
  "hash_id": "ac0480941f9a23d6b5765a2bb73a984593577c48bc9e6e75feab5ba503f01079",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/dev/netlink.c",
  "human_readable_source": "\n \n\n#include <linux/can/dev.h>\n#include <net/rtnetlink.h>\n\nstatic const struct nla_policy can_policy[IFLA_CAN_MAX + 1] = {\n\t[IFLA_CAN_STATE] = { .type = NLA_U32 },\n\t[IFLA_CAN_CTRLMODE] = { .len = sizeof(struct can_ctrlmode) },\n\t[IFLA_CAN_RESTART_MS] = { .type = NLA_U32 },\n\t[IFLA_CAN_RESTART] = { .type = NLA_U32 },\n\t[IFLA_CAN_BITTIMING] = { .len = sizeof(struct can_bittiming) },\n\t[IFLA_CAN_BITTIMING_CONST] = { .len = sizeof(struct can_bittiming_const) },\n\t[IFLA_CAN_CLOCK] = { .len = sizeof(struct can_clock) },\n\t[IFLA_CAN_BERR_COUNTER] = { .len = sizeof(struct can_berr_counter) },\n\t[IFLA_CAN_DATA_BITTIMING] = { .len = sizeof(struct can_bittiming) },\n\t[IFLA_CAN_DATA_BITTIMING_CONST]\t= { .len = sizeof(struct can_bittiming_const) },\n\t[IFLA_CAN_TERMINATION] = { .type = NLA_U16 },\n\t[IFLA_CAN_TDC] = { .type = NLA_NESTED },\n\t[IFLA_CAN_CTRLMODE_EXT] = { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy can_tdc_policy[IFLA_CAN_TDC_MAX + 1] = {\n\t[IFLA_CAN_TDC_TDCV_MIN] = { .type = NLA_U32 },\n\t[IFLA_CAN_TDC_TDCV_MAX] = { .type = NLA_U32 },\n\t[IFLA_CAN_TDC_TDCO_MIN] = { .type = NLA_U32 },\n\t[IFLA_CAN_TDC_TDCO_MAX] = { .type = NLA_U32 },\n\t[IFLA_CAN_TDC_TDCF_MIN] = { .type = NLA_U32 },\n\t[IFLA_CAN_TDC_TDCF_MAX] = { .type = NLA_U32 },\n\t[IFLA_CAN_TDC_TDCV] = { .type = NLA_U32 },\n\t[IFLA_CAN_TDC_TDCO] = { .type = NLA_U32 },\n\t[IFLA_CAN_TDC_TDCF] = { .type = NLA_U32 },\n};\n\nstatic int can_validate_bittiming(const struct can_bittiming *bt,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\t \n\tif (bt->sample_point >= 1000) {\n\t\tNL_SET_ERR_MSG(extack, \"sample point must be between 0 and 100%\");\n\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int can_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\tstruct netlink_ext_ack *extack)\n{\n\tbool is_can_fd = false;\n\tint err;\n\n\t \n\n\tif (!data)\n\t\treturn 0;\n\n\tif (data[IFLA_CAN_BITTIMING]) {\n\t\tstruct can_bittiming bt;\n\n\t\tmemcpy(&bt, nla_data(data[IFLA_CAN_BITTIMING]), sizeof(bt));\n\t\terr = can_validate_bittiming(&bt, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_CAN_CTRLMODE]) {\n\t\tstruct can_ctrlmode *cm = nla_data(data[IFLA_CAN_CTRLMODE]);\n\t\tu32 tdc_flags = cm->flags & CAN_CTRLMODE_TDC_MASK;\n\n\t\tis_can_fd = cm->flags & cm->mask & CAN_CTRLMODE_FD;\n\n\t\t \n\t\tif (tdc_flags == CAN_CTRLMODE_TDC_MASK)\n\t\t\treturn -EOPNOTSUPP;\n\t\t \n\t\tif (!!tdc_flags != !!data[IFLA_CAN_TDC])\n\t\t\treturn -EOPNOTSUPP;\n\t\t \n\t\tif (data[IFLA_CAN_TDC]) {\n\t\t\tstruct nlattr *tb_tdc[IFLA_CAN_TDC_MAX + 1];\n\n\t\t\terr = nla_parse_nested(tb_tdc, IFLA_CAN_TDC_MAX,\n\t\t\t\t\t       data[IFLA_CAN_TDC],\n\t\t\t\t\t       can_tdc_policy, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tif (tb_tdc[IFLA_CAN_TDC_TDCV]) {\n\t\t\t\tif (tdc_flags & CAN_CTRLMODE_TDC_AUTO)\n\t\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t} else {\n\t\t\t\tif (tdc_flags & CAN_CTRLMODE_TDC_MANUAL)\n\t\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\n\t\t\tif (!tb_tdc[IFLA_CAN_TDC_TDCO])\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tif (is_can_fd) {\n\t\tif (!data[IFLA_CAN_BITTIMING] || !data[IFLA_CAN_DATA_BITTIMING])\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (data[IFLA_CAN_DATA_BITTIMING] || data[IFLA_CAN_TDC]) {\n\t\tif (!is_can_fd)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (data[IFLA_CAN_DATA_BITTIMING]) {\n\t\tstruct can_bittiming bt;\n\n\t\tmemcpy(&bt, nla_data(data[IFLA_CAN_DATA_BITTIMING]), sizeof(bt));\n\t\terr = can_validate_bittiming(&bt, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int can_tdc_changelink(struct can_priv *priv, const struct nlattr *nla,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb_tdc[IFLA_CAN_TDC_MAX + 1];\n\tstruct can_tdc tdc = { 0 };\n\tconst struct can_tdc_const *tdc_const = priv->tdc_const;\n\tint err;\n\n\tif (!tdc_const || !can_tdc_is_enabled(priv))\n\t\treturn -EOPNOTSUPP;\n\n\terr = nla_parse_nested(tb_tdc, IFLA_CAN_TDC_MAX, nla,\n\t\t\t       can_tdc_policy, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (tb_tdc[IFLA_CAN_TDC_TDCV]) {\n\t\tu32 tdcv = nla_get_u32(tb_tdc[IFLA_CAN_TDC_TDCV]);\n\n\t\tif (tdcv < tdc_const->tdcv_min || tdcv > tdc_const->tdcv_max)\n\t\t\treturn -EINVAL;\n\n\t\ttdc.tdcv = tdcv;\n\t}\n\n\tif (tb_tdc[IFLA_CAN_TDC_TDCO]) {\n\t\tu32 tdco = nla_get_u32(tb_tdc[IFLA_CAN_TDC_TDCO]);\n\n\t\tif (tdco < tdc_const->tdco_min || tdco > tdc_const->tdco_max)\n\t\t\treturn -EINVAL;\n\n\t\ttdc.tdco = tdco;\n\t}\n\n\tif (tb_tdc[IFLA_CAN_TDC_TDCF]) {\n\t\tu32 tdcf = nla_get_u32(tb_tdc[IFLA_CAN_TDC_TDCF]);\n\n\t\tif (tdcf < tdc_const->tdcf_min || tdcf > tdc_const->tdcf_max)\n\t\t\treturn -EINVAL;\n\n\t\ttdc.tdcf = tdcf;\n\t}\n\n\tpriv->tdc = tdc;\n\n\treturn 0;\n}\n\nstatic int can_changelink(struct net_device *dev, struct nlattr *tb[],\n\t\t\t  struct nlattr *data[],\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct can_priv *priv = netdev_priv(dev);\n\tu32 tdc_mask = 0;\n\tint err;\n\n\t \n\tASSERT_RTNL();\n\n\tif (data[IFLA_CAN_BITTIMING]) {\n\t\tstruct can_bittiming bt;\n\n\t\t \n\t\tif (dev->flags & IFF_UP)\n\t\t\treturn -EBUSY;\n\n\t\t \n\t\tif (!priv->bittiming_const && !priv->do_set_bittiming &&\n\t\t    !priv->bitrate_const)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tmemcpy(&bt, nla_data(data[IFLA_CAN_BITTIMING]), sizeof(bt));\n\t\terr = can_get_bittiming(dev, &bt,\n\t\t\t\t\tpriv->bittiming_const,\n\t\t\t\t\tpriv->bitrate_const,\n\t\t\t\t\tpriv->bitrate_const_cnt,\n\t\t\t\t\textack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (priv->bitrate_max && bt.bitrate > priv->bitrate_max) {\n\t\t\tNL_SET_ERR_MSG_FMT(extack,\n\t\t\t\t\t   \"arbitration bitrate %u bps surpasses transceiver capabilities of %u bps\",\n\t\t\t\t\t   bt.bitrate, priv->bitrate_max);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemcpy(&priv->bittiming, &bt, sizeof(bt));\n\n\t\tif (priv->do_set_bittiming) {\n\t\t\t \n\t\t\terr = priv->do_set_bittiming(dev);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (data[IFLA_CAN_CTRLMODE]) {\n\t\tstruct can_ctrlmode *cm;\n\t\tu32 ctrlstatic;\n\t\tu32 maskedflags;\n\n\t\t \n\t\tif (dev->flags & IFF_UP)\n\t\t\treturn -EBUSY;\n\t\tcm = nla_data(data[IFLA_CAN_CTRLMODE]);\n\t\tctrlstatic = can_get_static_ctrlmode(priv);\n\t\tmaskedflags = cm->flags & cm->mask;\n\n\t\t \n\t\tif (maskedflags & ~(priv->ctrlmode_supported | ctrlstatic))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tif (!(maskedflags & CAN_CTRLMODE_FD))\n\t\t\tctrlstatic &= ~CAN_CTRLMODE_FD_NON_ISO;\n\n\t\t \n\t\tif ((maskedflags & ctrlstatic) != ctrlstatic)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tpriv->ctrlmode &= ~cm->mask;\n\t\tpriv->ctrlmode |= maskedflags;\n\n\t\t \n\t\tif (priv->ctrlmode & CAN_CTRLMODE_FD) {\n\t\t\tdev->mtu = CANFD_MTU;\n\t\t} else {\n\t\t\tdev->mtu = CAN_MTU;\n\t\t\tmemset(&priv->data_bittiming, 0,\n\t\t\t       sizeof(priv->data_bittiming));\n\t\t\tpriv->ctrlmode &= ~CAN_CTRLMODE_TDC_MASK;\n\t\t\tmemset(&priv->tdc, 0, sizeof(priv->tdc));\n\t\t}\n\n\t\ttdc_mask = cm->mask & CAN_CTRLMODE_TDC_MASK;\n\t\t \n\t\tif (tdc_mask)\n\t\t\tpriv->ctrlmode &= cm->flags | ~CAN_CTRLMODE_TDC_MASK;\n\t}\n\n\tif (data[IFLA_CAN_RESTART_MS]) {\n\t\t \n\t\tif (dev->flags & IFF_UP)\n\t\t\treturn -EBUSY;\n\t\tpriv->restart_ms = nla_get_u32(data[IFLA_CAN_RESTART_MS]);\n\t}\n\n\tif (data[IFLA_CAN_RESTART]) {\n\t\t \n\t\tif (!(dev->flags & IFF_UP))\n\t\t\treturn -EINVAL;\n\t\terr = can_restart_now(dev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_CAN_DATA_BITTIMING]) {\n\t\tstruct can_bittiming dbt;\n\n\t\t \n\t\tif (dev->flags & IFF_UP)\n\t\t\treturn -EBUSY;\n\n\t\t \n\t\tif (!priv->data_bittiming_const && !priv->do_set_data_bittiming &&\n\t\t    !priv->data_bitrate_const)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tmemcpy(&dbt, nla_data(data[IFLA_CAN_DATA_BITTIMING]),\n\t\t       sizeof(dbt));\n\t\terr = can_get_bittiming(dev, &dbt,\n\t\t\t\t\tpriv->data_bittiming_const,\n\t\t\t\t\tpriv->data_bitrate_const,\n\t\t\t\t\tpriv->data_bitrate_const_cnt,\n\t\t\t\t\textack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (priv->bitrate_max && dbt.bitrate > priv->bitrate_max) {\n\t\t\tNL_SET_ERR_MSG_FMT(extack,\n\t\t\t\t\t   \"CANFD data bitrate %u bps surpasses transceiver capabilities of %u bps\",\n\t\t\t\t\t   dbt.bitrate, priv->bitrate_max);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemset(&priv->tdc, 0, sizeof(priv->tdc));\n\t\tif (data[IFLA_CAN_TDC]) {\n\t\t\t \n\t\t\terr = can_tdc_changelink(priv, data[IFLA_CAN_TDC],\n\t\t\t\t\t\t extack);\n\t\t\tif (err) {\n\t\t\t\tpriv->ctrlmode &= ~CAN_CTRLMODE_TDC_MASK;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t} else if (!tdc_mask) {\n\t\t\t \n\t\t\tcan_calc_tdco(&priv->tdc, priv->tdc_const, &priv->data_bittiming,\n\t\t\t\t      &priv->ctrlmode, priv->ctrlmode_supported);\n\t\t}  \n\n\t\tmemcpy(&priv->data_bittiming, &dbt, sizeof(dbt));\n\n\t\tif (priv->do_set_data_bittiming) {\n\t\t\t \n\t\t\terr = priv->do_set_data_bittiming(dev);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (data[IFLA_CAN_TERMINATION]) {\n\t\tconst u16 termval = nla_get_u16(data[IFLA_CAN_TERMINATION]);\n\t\tconst unsigned int num_term = priv->termination_const_cnt;\n\t\tunsigned int i;\n\n\t\tif (!priv->do_set_termination)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tfor (i = 0; i < num_term; i++) {\n\t\t\tif (termval == priv->termination_const[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= num_term)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\terr = priv->do_set_termination(dev, termval);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tpriv->termination = termval;\n\t}\n\n\treturn 0;\n}\n\nstatic size_t can_tdc_get_size(const struct net_device *dev)\n{\n\tstruct can_priv *priv = netdev_priv(dev);\n\tsize_t size;\n\n\tif (!priv->tdc_const)\n\t\treturn 0;\n\n\tsize = nla_total_size(0);\t\t\t \n\tif (priv->ctrlmode_supported & CAN_CTRLMODE_TDC_MANUAL) {\n\t\tsize += nla_total_size(sizeof(u32));\t \n\t\tsize += nla_total_size(sizeof(u32));\t \n\t}\n\tsize += nla_total_size(sizeof(u32));\t\t \n\tsize += nla_total_size(sizeof(u32));\t\t \n\tif (priv->tdc_const->tdcf_max) {\n\t\tsize += nla_total_size(sizeof(u32));\t \n\t\tsize += nla_total_size(sizeof(u32));\t \n\t}\n\n\tif (can_tdc_is_enabled(priv)) {\n\t\tif (priv->ctrlmode & CAN_CTRLMODE_TDC_MANUAL ||\n\t\t    priv->do_get_auto_tdcv)\n\t\t\tsize += nla_total_size(sizeof(u32));\t \n\t\tsize += nla_total_size(sizeof(u32));\t\t \n\t\tif (priv->tdc_const->tdcf_max)\n\t\t\tsize += nla_total_size(sizeof(u32));\t \n\t}\n\n\treturn size;\n}\n\nstatic size_t can_ctrlmode_ext_get_size(void)\n{\n\treturn nla_total_size(0) +\t\t \n\t\tnla_total_size(sizeof(u32));\t \n}\n\nstatic size_t can_get_size(const struct net_device *dev)\n{\n\tstruct can_priv *priv = netdev_priv(dev);\n\tsize_t size = 0;\n\n\tif (priv->bittiming.bitrate)\t\t\t\t \n\t\tsize += nla_total_size(sizeof(struct can_bittiming));\n\tif (priv->bittiming_const)\t\t\t\t \n\t\tsize += nla_total_size(sizeof(struct can_bittiming_const));\n\tsize += nla_total_size(sizeof(struct can_clock));\t \n\tsize += nla_total_size(sizeof(u32));\t\t\t \n\tsize += nla_total_size(sizeof(struct can_ctrlmode));\t \n\tsize += nla_total_size(sizeof(u32));\t\t\t \n\tif (priv->do_get_berr_counter)\t\t\t\t \n\t\tsize += nla_total_size(sizeof(struct can_berr_counter));\n\tif (priv->data_bittiming.bitrate)\t\t\t \n\t\tsize += nla_total_size(sizeof(struct can_bittiming));\n\tif (priv->data_bittiming_const)\t\t\t\t \n\t\tsize += nla_total_size(sizeof(struct can_bittiming_const));\n\tif (priv->termination_const) {\n\t\tsize += nla_total_size(sizeof(priv->termination));\t\t \n\t\tsize += nla_total_size(sizeof(*priv->termination_const) *\t \n\t\t\t\t       priv->termination_const_cnt);\n\t}\n\tif (priv->bitrate_const)\t\t\t\t \n\t\tsize += nla_total_size(sizeof(*priv->bitrate_const) *\n\t\t\t\t       priv->bitrate_const_cnt);\n\tif (priv->data_bitrate_const)\t\t\t\t \n\t\tsize += nla_total_size(sizeof(*priv->data_bitrate_const) *\n\t\t\t\t       priv->data_bitrate_const_cnt);\n\tsize += sizeof(priv->bitrate_max);\t\t\t \n\tsize += can_tdc_get_size(dev);\t\t\t\t \n\tsize += can_ctrlmode_ext_get_size();\t\t\t \n\n\treturn size;\n}\n\nstatic int can_tdc_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct nlattr *nest;\n\tstruct can_priv *priv = netdev_priv(dev);\n\tstruct can_tdc *tdc = &priv->tdc;\n\tconst struct can_tdc_const *tdc_const = priv->tdc_const;\n\n\tif (!tdc_const)\n\t\treturn 0;\n\n\tnest = nla_nest_start(skb, IFLA_CAN_TDC);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (priv->ctrlmode_supported & CAN_CTRLMODE_TDC_MANUAL &&\n\t    (nla_put_u32(skb, IFLA_CAN_TDC_TDCV_MIN, tdc_const->tdcv_min) ||\n\t     nla_put_u32(skb, IFLA_CAN_TDC_TDCV_MAX, tdc_const->tdcv_max)))\n\t\tgoto err_cancel;\n\tif (nla_put_u32(skb, IFLA_CAN_TDC_TDCO_MIN, tdc_const->tdco_min) ||\n\t    nla_put_u32(skb, IFLA_CAN_TDC_TDCO_MAX, tdc_const->tdco_max))\n\t\tgoto err_cancel;\n\tif (tdc_const->tdcf_max &&\n\t    (nla_put_u32(skb, IFLA_CAN_TDC_TDCF_MIN, tdc_const->tdcf_min) ||\n\t     nla_put_u32(skb, IFLA_CAN_TDC_TDCF_MAX, tdc_const->tdcf_max)))\n\t\tgoto err_cancel;\n\n\tif (can_tdc_is_enabled(priv)) {\n\t\tu32 tdcv;\n\t\tint err = -EINVAL;\n\n\t\tif (priv->ctrlmode & CAN_CTRLMODE_TDC_MANUAL) {\n\t\t\ttdcv = tdc->tdcv;\n\t\t\terr = 0;\n\t\t} else if (priv->do_get_auto_tdcv) {\n\t\t\terr = priv->do_get_auto_tdcv(dev, &tdcv);\n\t\t}\n\t\tif (!err && nla_put_u32(skb, IFLA_CAN_TDC_TDCV, tdcv))\n\t\t\tgoto err_cancel;\n\t\tif (nla_put_u32(skb, IFLA_CAN_TDC_TDCO, tdc->tdco))\n\t\t\tgoto err_cancel;\n\t\tif (tdc_const->tdcf_max &&\n\t\t    nla_put_u32(skb, IFLA_CAN_TDC_TDCF, tdc->tdcf))\n\t\t\tgoto err_cancel;\n\t}\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\n\nerr_cancel:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int can_ctrlmode_ext_fill_info(struct sk_buff *skb,\n\t\t\t\t      const struct can_priv *priv)\n{\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start(skb, IFLA_CAN_CTRLMODE_EXT);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tif (nla_put_u32(skb, IFLA_CAN_CTRLMODE_SUPPORTED,\n\t\t\tpriv->ctrlmode_supported)) {\n\t\tnla_nest_cancel(skb, nest);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tnla_nest_end(skb, nest);\n\treturn 0;\n}\n\nstatic int can_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct can_priv *priv = netdev_priv(dev);\n\tstruct can_ctrlmode cm = {.flags = priv->ctrlmode};\n\tstruct can_berr_counter bec = { };\n\tenum can_state state = priv->state;\n\n\tif (priv->do_get_state)\n\t\tpriv->do_get_state(dev, &state);\n\n\tif ((priv->bittiming.bitrate != CAN_BITRATE_UNSET &&\n\t     priv->bittiming.bitrate != CAN_BITRATE_UNKNOWN &&\n\t     nla_put(skb, IFLA_CAN_BITTIMING,\n\t\t     sizeof(priv->bittiming), &priv->bittiming)) ||\n\n\t    (priv->bittiming_const &&\n\t     nla_put(skb, IFLA_CAN_BITTIMING_CONST,\n\t\t     sizeof(*priv->bittiming_const), priv->bittiming_const)) ||\n\n\t    nla_put(skb, IFLA_CAN_CLOCK, sizeof(priv->clock), &priv->clock) ||\n\t    nla_put_u32(skb, IFLA_CAN_STATE, state) ||\n\t    nla_put(skb, IFLA_CAN_CTRLMODE, sizeof(cm), &cm) ||\n\t    nla_put_u32(skb, IFLA_CAN_RESTART_MS, priv->restart_ms) ||\n\n\t    (priv->do_get_berr_counter &&\n\t     !priv->do_get_berr_counter(dev, &bec) &&\n\t     nla_put(skb, IFLA_CAN_BERR_COUNTER, sizeof(bec), &bec)) ||\n\n\t    (priv->data_bittiming.bitrate &&\n\t     nla_put(skb, IFLA_CAN_DATA_BITTIMING,\n\t\t     sizeof(priv->data_bittiming), &priv->data_bittiming)) ||\n\n\t    (priv->data_bittiming_const &&\n\t     nla_put(skb, IFLA_CAN_DATA_BITTIMING_CONST,\n\t\t     sizeof(*priv->data_bittiming_const),\n\t\t     priv->data_bittiming_const)) ||\n\n\t    (priv->termination_const &&\n\t     (nla_put_u16(skb, IFLA_CAN_TERMINATION, priv->termination) ||\n\t      nla_put(skb, IFLA_CAN_TERMINATION_CONST,\n\t\t      sizeof(*priv->termination_const) *\n\t\t      priv->termination_const_cnt,\n\t\t      priv->termination_const))) ||\n\n\t    (priv->bitrate_const &&\n\t     nla_put(skb, IFLA_CAN_BITRATE_CONST,\n\t\t     sizeof(*priv->bitrate_const) *\n\t\t     priv->bitrate_const_cnt,\n\t\t     priv->bitrate_const)) ||\n\n\t    (priv->data_bitrate_const &&\n\t     nla_put(skb, IFLA_CAN_DATA_BITRATE_CONST,\n\t\t     sizeof(*priv->data_bitrate_const) *\n\t\t     priv->data_bitrate_const_cnt,\n\t\t     priv->data_bitrate_const)) ||\n\n\t    (nla_put(skb, IFLA_CAN_BITRATE_MAX,\n\t\t     sizeof(priv->bitrate_max),\n\t\t     &priv->bitrate_max)) ||\n\n\t    can_tdc_fill_info(skb, dev) ||\n\n\t    can_ctrlmode_ext_fill_info(skb, priv)\n\t    )\n\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic size_t can_get_xstats_size(const struct net_device *dev)\n{\n\treturn sizeof(struct can_device_stats);\n}\n\nstatic int can_fill_xstats(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct can_priv *priv = netdev_priv(dev);\n\n\tif (nla_put(skb, IFLA_INFO_XSTATS,\n\t\t    sizeof(priv->can_stats), &priv->can_stats))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic int can_newlink(struct net *src_net, struct net_device *dev,\n\t\t       struct nlattr *tb[], struct nlattr *data[],\n\t\t       struct netlink_ext_ack *extack)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic void can_dellink(struct net_device *dev, struct list_head *head)\n{\n}\n\nstruct rtnl_link_ops can_link_ops __read_mostly = {\n\t.kind\t\t= \"can\",\n\t.netns_refund\t= true,\n\t.maxtype\t= IFLA_CAN_MAX,\n\t.policy\t\t= can_policy,\n\t.setup\t\t= can_setup,\n\t.validate\t= can_validate,\n\t.newlink\t= can_newlink,\n\t.changelink\t= can_changelink,\n\t.dellink\t= can_dellink,\n\t.get_size\t= can_get_size,\n\t.fill_info\t= can_fill_info,\n\t.get_xstats_size = can_get_xstats_size,\n\t.fill_xstats\t= can_fill_xstats,\n};\n\nint can_netlink_register(void)\n{\n\treturn rtnl_link_register(&can_link_ops);\n}\n\nvoid can_netlink_unregister(void)\n{\n\trtnl_link_unregister(&can_link_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}