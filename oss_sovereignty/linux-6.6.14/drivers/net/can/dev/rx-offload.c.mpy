{
  "module_name": "rx-offload.c",
  "hash_id": "8217056b333ed5d2f04f7763d48df84aae6f71d0b2dcc31596247c547a399fbb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/dev/rx-offload.c",
  "human_readable_source": "\n \n\n#include <linux/can/dev.h>\n#include <linux/can/rx-offload.h>\n\nstruct can_rx_offload_cb {\n\tu32 timestamp;\n};\n\nstatic inline struct can_rx_offload_cb *\ncan_rx_offload_get_cb(struct sk_buff *skb)\n{\n\tBUILD_BUG_ON(sizeof(struct can_rx_offload_cb) > sizeof(skb->cb));\n\n\treturn (struct can_rx_offload_cb *)skb->cb;\n}\n\nstatic inline bool\ncan_rx_offload_le(struct can_rx_offload *offload,\n\t\t  unsigned int a, unsigned int b)\n{\n\tif (offload->inc)\n\t\treturn a <= b;\n\telse\n\t\treturn a >= b;\n}\n\nstatic inline unsigned int\ncan_rx_offload_inc(struct can_rx_offload *offload, unsigned int *val)\n{\n\tif (offload->inc)\n\t\treturn (*val)++;\n\telse\n\t\treturn (*val)--;\n}\n\nstatic int can_rx_offload_napi_poll(struct napi_struct *napi, int quota)\n{\n\tstruct can_rx_offload *offload = container_of(napi,\n\t\t\t\t\t\t      struct can_rx_offload,\n\t\t\t\t\t\t      napi);\n\tstruct net_device *dev = offload->dev;\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct sk_buff *skb;\n\tint work_done = 0;\n\n\twhile ((work_done < quota) &&\n\t       (skb = skb_dequeue(&offload->skb_queue))) {\n\t\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\n\t\twork_done++;\n\t\tif (!(cf->can_id & CAN_ERR_FLAG)) {\n\t\t\tstats->rx_packets++;\n\t\t\tif (!(cf->can_id & CAN_RTR_FLAG))\n\t\t\t\tstats->rx_bytes += cf->len;\n\t\t}\n\t\tnetif_receive_skb(skb);\n\t}\n\n\tif (work_done < quota) {\n\t\tnapi_complete_done(napi, work_done);\n\n\t\t \n\t\tif (!skb_queue_empty(&offload->skb_queue))\n\t\t\tnapi_reschedule(&offload->napi);\n\t}\n\n\treturn work_done;\n}\n\nstatic inline void\n__skb_queue_add_sort(struct sk_buff_head *head, struct sk_buff *new,\n\t\t     int (*compare)(struct sk_buff *a, struct sk_buff *b))\n{\n\tstruct sk_buff *pos, *insert = NULL;\n\n\tskb_queue_reverse_walk(head, pos) {\n\t\tconst struct can_rx_offload_cb *cb_pos, *cb_new;\n\n\t\tcb_pos = can_rx_offload_get_cb(pos);\n\t\tcb_new = can_rx_offload_get_cb(new);\n\n\t\tnetdev_dbg(new->dev,\n\t\t\t   \"%s: pos=0x%08x, new=0x%08x, diff=%10d, queue_len=%d\\n\",\n\t\t\t   __func__,\n\t\t\t   cb_pos->timestamp, cb_new->timestamp,\n\t\t\t   cb_new->timestamp - cb_pos->timestamp,\n\t\t\t   skb_queue_len(head));\n\n\t\tif (compare(pos, new) < 0)\n\t\t\tcontinue;\n\t\tinsert = pos;\n\t\tbreak;\n\t}\n\tif (!insert)\n\t\t__skb_queue_head(head, new);\n\telse\n\t\t__skb_queue_after(head, insert, new);\n}\n\nstatic int can_rx_offload_compare(struct sk_buff *a, struct sk_buff *b)\n{\n\tconst struct can_rx_offload_cb *cb_a, *cb_b;\n\n\tcb_a = can_rx_offload_get_cb(a);\n\tcb_b = can_rx_offload_get_cb(b);\n\n\t \n\treturn cb_b->timestamp - cb_a->timestamp;\n}\n\n \nstatic struct sk_buff *\ncan_rx_offload_offload_one(struct can_rx_offload *offload, unsigned int n)\n{\n\tstruct sk_buff *skb;\n\tstruct can_rx_offload_cb *cb;\n\tbool drop = false;\n\tu32 timestamp;\n\n\t \n\tif (unlikely(skb_queue_len(&offload->skb_queue) >\n\t\t     offload->skb_queue_len_max))\n\t\tdrop = true;\n\n\tskb = offload->mailbox_read(offload, n, &timestamp, drop);\n\t \n\tif (unlikely(!skb))\n\t\treturn NULL;\n\n\t \n\tif (IS_ERR(skb)) {\n\t\toffload->dev->stats.rx_dropped++;\n\t\toffload->dev->stats.rx_fifo_errors++;\n\n\t\treturn skb;\n\t}\n\n\t \n\tcb = can_rx_offload_get_cb(skb);\n\tcb->timestamp = timestamp;\n\n\treturn skb;\n}\n\nint can_rx_offload_irq_offload_timestamp(struct can_rx_offload *offload,\n\t\t\t\t\t u64 pending)\n{\n\tunsigned int i;\n\tint received = 0;\n\n\tfor (i = offload->mb_first;\n\t     can_rx_offload_le(offload, i, offload->mb_last);\n\t     can_rx_offload_inc(offload, &i)) {\n\t\tstruct sk_buff *skb;\n\n\t\tif (!(pending & BIT_ULL(i)))\n\t\t\tcontinue;\n\n\t\tskb = can_rx_offload_offload_one(offload, i);\n\t\tif (IS_ERR_OR_NULL(skb))\n\t\t\tcontinue;\n\n\t\t__skb_queue_add_sort(&offload->skb_irq_queue, skb,\n\t\t\t\t     can_rx_offload_compare);\n\t\treceived++;\n\t}\n\n\treturn received;\n}\nEXPORT_SYMBOL_GPL(can_rx_offload_irq_offload_timestamp);\n\nint can_rx_offload_irq_offload_fifo(struct can_rx_offload *offload)\n{\n\tstruct sk_buff *skb;\n\tint received = 0;\n\n\twhile (1) {\n\t\tskb = can_rx_offload_offload_one(offload, 0);\n\t\tif (IS_ERR(skb))\n\t\t\tcontinue;\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\t__skb_queue_tail(&offload->skb_irq_queue, skb);\n\t\treceived++;\n\t}\n\n\treturn received;\n}\nEXPORT_SYMBOL_GPL(can_rx_offload_irq_offload_fifo);\n\nint can_rx_offload_queue_timestamp(struct can_rx_offload *offload,\n\t\t\t\t   struct sk_buff *skb, u32 timestamp)\n{\n\tstruct can_rx_offload_cb *cb;\n\n\tif (skb_queue_len(&offload->skb_queue) >\n\t    offload->skb_queue_len_max) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn -ENOBUFS;\n\t}\n\n\tcb = can_rx_offload_get_cb(skb);\n\tcb->timestamp = timestamp;\n\n\t__skb_queue_add_sort(&offload->skb_irq_queue, skb,\n\t\t\t     can_rx_offload_compare);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(can_rx_offload_queue_timestamp);\n\nunsigned int\ncan_rx_offload_get_echo_skb_queue_timestamp(struct can_rx_offload *offload,\n\t\t\t\t\t    unsigned int idx, u32 timestamp,\n\t\t\t\t\t    unsigned int *frame_len_ptr)\n{\n\tstruct net_device *dev = offload->dev;\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct sk_buff *skb;\n\tunsigned int len;\n\tint err;\n\n\tskb = __can_get_echo_skb(dev, idx, &len, frame_len_ptr);\n\tif (!skb)\n\t\treturn 0;\n\n\terr = can_rx_offload_queue_timestamp(offload, skb, timestamp);\n\tif (err) {\n\t\tstats->rx_errors++;\n\t\tstats->tx_fifo_errors++;\n\t}\n\n\treturn len;\n}\nEXPORT_SYMBOL_GPL(can_rx_offload_get_echo_skb_queue_timestamp);\n\nint can_rx_offload_queue_tail(struct can_rx_offload *offload,\n\t\t\t      struct sk_buff *skb)\n{\n\tif (skb_queue_len(&offload->skb_queue) >\n\t    offload->skb_queue_len_max) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn -ENOBUFS;\n\t}\n\n\t__skb_queue_tail(&offload->skb_irq_queue, skb);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(can_rx_offload_queue_tail);\n\nunsigned int\ncan_rx_offload_get_echo_skb_queue_tail(struct can_rx_offload *offload,\n\t\t\t\t       unsigned int idx,\n\t\t\t\t       unsigned int *frame_len_ptr)\n{\n\tstruct net_device *dev = offload->dev;\n\tstruct net_device_stats *stats = &dev->stats;\n\tstruct sk_buff *skb;\n\tunsigned int len;\n\tint err;\n\n\tskb = __can_get_echo_skb(dev, idx, &len, frame_len_ptr);\n\tif (!skb)\n\t\treturn 0;\n\n\terr = can_rx_offload_queue_tail(offload, skb);\n\tif (err) {\n\t\tstats->rx_errors++;\n\t\tstats->tx_fifo_errors++;\n\t}\n\n\treturn len;\n}\nEXPORT_SYMBOL_GPL(can_rx_offload_get_echo_skb_queue_tail);\n\nvoid can_rx_offload_irq_finish(struct can_rx_offload *offload)\n{\n\tunsigned long flags;\n\tint queue_len;\n\n\tif (skb_queue_empty_lockless(&offload->skb_irq_queue))\n\t\treturn;\n\n\tspin_lock_irqsave(&offload->skb_queue.lock, flags);\n\tskb_queue_splice_tail_init(&offload->skb_irq_queue, &offload->skb_queue);\n\tspin_unlock_irqrestore(&offload->skb_queue.lock, flags);\n\n\tqueue_len = skb_queue_len(&offload->skb_queue);\n\tif (queue_len > offload->skb_queue_len_max / 8)\n\t\tnetdev_dbg(offload->dev, \"%s: queue_len=%d\\n\",\n\t\t\t   __func__, queue_len);\n\n\tnapi_schedule(&offload->napi);\n}\nEXPORT_SYMBOL_GPL(can_rx_offload_irq_finish);\n\nvoid can_rx_offload_threaded_irq_finish(struct can_rx_offload *offload)\n{\n\tunsigned long flags;\n\tint queue_len;\n\n\tif (skb_queue_empty_lockless(&offload->skb_irq_queue))\n\t\treturn;\n\n\tspin_lock_irqsave(&offload->skb_queue.lock, flags);\n\tskb_queue_splice_tail_init(&offload->skb_irq_queue, &offload->skb_queue);\n\tspin_unlock_irqrestore(&offload->skb_queue.lock, flags);\n\n\tqueue_len = skb_queue_len(&offload->skb_queue);\n\tif (queue_len > offload->skb_queue_len_max / 8)\n\t\tnetdev_dbg(offload->dev, \"%s: queue_len=%d\\n\",\n\t\t\t   __func__, queue_len);\n\n\tlocal_bh_disable();\n\tnapi_schedule(&offload->napi);\n\tlocal_bh_enable();\n}\nEXPORT_SYMBOL_GPL(can_rx_offload_threaded_irq_finish);\n\nstatic int can_rx_offload_init_queue(struct net_device *dev,\n\t\t\t\t     struct can_rx_offload *offload,\n\t\t\t\t     unsigned int weight)\n{\n\toffload->dev = dev;\n\n\t \n\toffload->skb_queue_len_max = 2 << fls(weight);\n\toffload->skb_queue_len_max *= 4;\n\tskb_queue_head_init(&offload->skb_queue);\n\t__skb_queue_head_init(&offload->skb_irq_queue);\n\n\tnetif_napi_add_weight(dev, &offload->napi, can_rx_offload_napi_poll,\n\t\t\t      weight);\n\n\tdev_dbg(dev->dev.parent, \"%s: skb_queue_len_max=%d\\n\",\n\t\t__func__, offload->skb_queue_len_max);\n\n\treturn 0;\n}\n\nint can_rx_offload_add_timestamp(struct net_device *dev,\n\t\t\t\t struct can_rx_offload *offload)\n{\n\tunsigned int weight;\n\n\tif (offload->mb_first > BITS_PER_LONG_LONG ||\n\t    offload->mb_last > BITS_PER_LONG_LONG || !offload->mailbox_read)\n\t\treturn -EINVAL;\n\n\tif (offload->mb_first < offload->mb_last) {\n\t\toffload->inc = true;\n\t\tweight = offload->mb_last - offload->mb_first;\n\t} else {\n\t\toffload->inc = false;\n\t\tweight = offload->mb_first - offload->mb_last;\n\t}\n\n\treturn can_rx_offload_init_queue(dev, offload, weight);\n}\nEXPORT_SYMBOL_GPL(can_rx_offload_add_timestamp);\n\nint can_rx_offload_add_fifo(struct net_device *dev,\n\t\t\t    struct can_rx_offload *offload, unsigned int weight)\n{\n\tif (!offload->mailbox_read)\n\t\treturn -EINVAL;\n\n\treturn can_rx_offload_init_queue(dev, offload, weight);\n}\nEXPORT_SYMBOL_GPL(can_rx_offload_add_fifo);\n\nint can_rx_offload_add_manual(struct net_device *dev,\n\t\t\t      struct can_rx_offload *offload,\n\t\t\t      unsigned int weight)\n{\n\tif (offload->mailbox_read)\n\t\treturn -EINVAL;\n\n\treturn can_rx_offload_init_queue(dev, offload, weight);\n}\nEXPORT_SYMBOL_GPL(can_rx_offload_add_manual);\n\nvoid can_rx_offload_enable(struct can_rx_offload *offload)\n{\n\tnapi_enable(&offload->napi);\n}\nEXPORT_SYMBOL_GPL(can_rx_offload_enable);\n\nvoid can_rx_offload_del(struct can_rx_offload *offload)\n{\n\tnetif_napi_del(&offload->napi);\n\tskb_queue_purge(&offload->skb_queue);\n\t__skb_queue_purge(&offload->skb_irq_queue);\n}\nEXPORT_SYMBOL_GPL(can_rx_offload_del);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}