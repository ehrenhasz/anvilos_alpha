{
  "module_name": "dev.c",
  "hash_id": "93c31c600d2ab665c3a4df15860e36b7e32d92047f79038cf5765c95c1f5c408",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/dev/dev.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/workqueue.h>\n#include <linux/can.h>\n#include <linux/can/can-ml.h>\n#include <linux/can/dev.h>\n#include <linux/can/skb.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of.h>\n\nstatic void can_update_state_error_stats(struct net_device *dev,\n\t\t\t\t\t enum can_state new_state)\n{\n\tstruct can_priv *priv = netdev_priv(dev);\n\n\tif (new_state <= priv->state)\n\t\treturn;\n\n\tswitch (new_state) {\n\tcase CAN_STATE_ERROR_WARNING:\n\t\tpriv->can_stats.error_warning++;\n\t\tbreak;\n\tcase CAN_STATE_ERROR_PASSIVE:\n\t\tpriv->can_stats.error_passive++;\n\t\tbreak;\n\tcase CAN_STATE_BUS_OFF:\n\t\tpriv->can_stats.bus_off++;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int can_tx_state_to_frame(struct net_device *dev, enum can_state state)\n{\n\tswitch (state) {\n\tcase CAN_STATE_ERROR_ACTIVE:\n\t\treturn CAN_ERR_CRTL_ACTIVE;\n\tcase CAN_STATE_ERROR_WARNING:\n\t\treturn CAN_ERR_CRTL_TX_WARNING;\n\tcase CAN_STATE_ERROR_PASSIVE:\n\t\treturn CAN_ERR_CRTL_TX_PASSIVE;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int can_rx_state_to_frame(struct net_device *dev, enum can_state state)\n{\n\tswitch (state) {\n\tcase CAN_STATE_ERROR_ACTIVE:\n\t\treturn CAN_ERR_CRTL_ACTIVE;\n\tcase CAN_STATE_ERROR_WARNING:\n\t\treturn CAN_ERR_CRTL_RX_WARNING;\n\tcase CAN_STATE_ERROR_PASSIVE:\n\t\treturn CAN_ERR_CRTL_RX_PASSIVE;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nconst char *can_get_state_str(const enum can_state state)\n{\n\tswitch (state) {\n\tcase CAN_STATE_ERROR_ACTIVE:\n\t\treturn \"Error Active\";\n\tcase CAN_STATE_ERROR_WARNING:\n\t\treturn \"Error Warning\";\n\tcase CAN_STATE_ERROR_PASSIVE:\n\t\treturn \"Error Passive\";\n\tcase CAN_STATE_BUS_OFF:\n\t\treturn \"Bus Off\";\n\tcase CAN_STATE_STOPPED:\n\t\treturn \"Stopped\";\n\tcase CAN_STATE_SLEEPING:\n\t\treturn \"Sleeping\";\n\tdefault:\n\t\treturn \"<unknown>\";\n\t}\n\n\treturn \"<unknown>\";\n}\nEXPORT_SYMBOL_GPL(can_get_state_str);\n\nvoid can_change_state(struct net_device *dev, struct can_frame *cf,\n\t\t      enum can_state tx_state, enum can_state rx_state)\n{\n\tstruct can_priv *priv = netdev_priv(dev);\n\tenum can_state new_state = max(tx_state, rx_state);\n\n\tif (unlikely(new_state == priv->state)) {\n\t\tnetdev_warn(dev, \"%s: oops, state did not change\", __func__);\n\t\treturn;\n\t}\n\n\tnetdev_dbg(dev, \"Controller changed from %s State (%d) into %s State (%d).\\n\",\n\t\t   can_get_state_str(priv->state), priv->state,\n\t\t   can_get_state_str(new_state), new_state);\n\n\tcan_update_state_error_stats(dev, new_state);\n\tpriv->state = new_state;\n\n\tif (!cf)\n\t\treturn;\n\n\tif (unlikely(new_state == CAN_STATE_BUS_OFF)) {\n\t\tcf->can_id |= CAN_ERR_BUSOFF;\n\t\treturn;\n\t}\n\n\tcf->can_id |= CAN_ERR_CRTL;\n\tcf->data[1] |= tx_state >= rx_state ?\n\t\t       can_tx_state_to_frame(dev, tx_state) : 0;\n\tcf->data[1] |= tx_state <= rx_state ?\n\t\t       can_rx_state_to_frame(dev, rx_state) : 0;\n}\nEXPORT_SYMBOL_GPL(can_change_state);\n\n \nstatic void can_restart(struct net_device *dev)\n{\n\tstruct can_priv *priv = netdev_priv(dev);\n\tstruct sk_buff *skb;\n\tstruct can_frame *cf;\n\tint err;\n\n\tif (netif_carrier_ok(dev))\n\t\tnetdev_err(dev, \"Attempt to restart for bus-off recovery, but carrier is OK?\\n\");\n\n\t \n\tcan_flush_echo_skb(dev);\n\n\t \n\tskb = alloc_can_err_skb(dev, &cf);\n\tif (!skb)\n\t\tgoto restart;\n\n\tcf->can_id |= CAN_ERR_RESTARTED;\n\n\tnetif_rx(skb);\n\nrestart:\n\tnetdev_dbg(dev, \"restarted\\n\");\n\tpriv->can_stats.restarts++;\n\n\t \n\tnetif_carrier_on(dev);\n\terr = priv->do_set_mode(dev, CAN_MODE_START);\n\tif (err) {\n\t\tnetdev_err(dev, \"Error %d during restart\", err);\n\t\tnetif_carrier_off(dev);\n\t}\n}\n\nstatic void can_restart_work(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct can_priv *priv = container_of(dwork, struct can_priv,\n\t\t\t\t\t     restart_work);\n\n\tcan_restart(priv->dev);\n}\n\nint can_restart_now(struct net_device *dev)\n{\n\tstruct can_priv *priv = netdev_priv(dev);\n\n\t \n\tif (priv->restart_ms)\n\t\treturn -EINVAL;\n\tif (priv->state != CAN_STATE_BUS_OFF)\n\t\treturn -EBUSY;\n\n\tcancel_delayed_work_sync(&priv->restart_work);\n\tcan_restart(dev);\n\n\treturn 0;\n}\n\n \nvoid can_bus_off(struct net_device *dev)\n{\n\tstruct can_priv *priv = netdev_priv(dev);\n\n\tif (priv->restart_ms)\n\t\tnetdev_info(dev, \"bus-off, scheduling restart in %d ms\\n\",\n\t\t\t    priv->restart_ms);\n\telse\n\t\tnetdev_info(dev, \"bus-off\\n\");\n\n\tnetif_carrier_off(dev);\n\n\tif (priv->restart_ms)\n\t\tschedule_delayed_work(&priv->restart_work,\n\t\t\t\t      msecs_to_jiffies(priv->restart_ms));\n}\nEXPORT_SYMBOL_GPL(can_bus_off);\n\nvoid can_setup(struct net_device *dev)\n{\n\tdev->type = ARPHRD_CAN;\n\tdev->mtu = CAN_MTU;\n\tdev->hard_header_len = 0;\n\tdev->addr_len = 0;\n\tdev->tx_queue_len = 10;\n\n\t \n\tdev->flags = IFF_NOARP;\n\tdev->features = NETIF_F_HW_CSUM;\n}\n\n \nstruct net_device *alloc_candev_mqs(int sizeof_priv, unsigned int echo_skb_max,\n\t\t\t\t    unsigned int txqs, unsigned int rxqs)\n{\n\tstruct can_ml_priv *can_ml;\n\tstruct net_device *dev;\n\tstruct can_priv *priv;\n\tint size;\n\n\t \n\n\tsize = ALIGN(sizeof_priv, NETDEV_ALIGN) + sizeof(struct can_ml_priv);\n\n\tif (echo_skb_max)\n\t\tsize = ALIGN(size, sizeof(struct sk_buff *)) +\n\t\t\techo_skb_max * sizeof(struct sk_buff *);\n\n\tdev = alloc_netdev_mqs(size, \"can%d\", NET_NAME_UNKNOWN, can_setup,\n\t\t\t       txqs, rxqs);\n\tif (!dev)\n\t\treturn NULL;\n\n\tpriv = netdev_priv(dev);\n\tpriv->dev = dev;\n\n\tcan_ml = (void *)priv + ALIGN(sizeof_priv, NETDEV_ALIGN);\n\tcan_set_ml_priv(dev, can_ml);\n\n\tif (echo_skb_max) {\n\t\tpriv->echo_skb_max = echo_skb_max;\n\t\tpriv->echo_skb = (void *)priv +\n\t\t\t(size - echo_skb_max * sizeof(struct sk_buff *));\n\t}\n\n\tpriv->state = CAN_STATE_STOPPED;\n\n\tINIT_DELAYED_WORK(&priv->restart_work, can_restart_work);\n\n\treturn dev;\n}\nEXPORT_SYMBOL_GPL(alloc_candev_mqs);\n\n \nvoid free_candev(struct net_device *dev)\n{\n\tfree_netdev(dev);\n}\nEXPORT_SYMBOL_GPL(free_candev);\n\n \nint can_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct can_priv *priv = netdev_priv(dev);\n\tu32 ctrlmode_static = can_get_static_ctrlmode(priv);\n\n\t \n\tif (dev->flags & IFF_UP)\n\t\treturn -EBUSY;\n\n\t \n\tswitch (new_mtu) {\n\tcase CAN_MTU:\n\t\t \n\t\tif (ctrlmode_static & CAN_CTRLMODE_FD)\n\t\t\treturn -EINVAL;\n\n\t\tpriv->ctrlmode &= ~CAN_CTRLMODE_FD;\n\t\tbreak;\n\n\tcase CANFD_MTU:\n\t\t \n\t\tif (!(priv->ctrlmode_supported & CAN_CTRLMODE_FD) &&\n\t\t    !(ctrlmode_static & CAN_CTRLMODE_FD))\n\t\t\treturn -EINVAL;\n\n\t\tpriv->ctrlmode |= CAN_CTRLMODE_FD;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(can_change_mtu);\n\n \nint can_eth_ioctl_hwts(struct net_device *netdev, struct ifreq *ifr, int cmd)\n{\n\tstruct hwtstamp_config hwts_cfg = { 0 };\n\n\tswitch (cmd) {\n\tcase SIOCSHWTSTAMP:  \n\t\tif (copy_from_user(&hwts_cfg, ifr->ifr_data, sizeof(hwts_cfg)))\n\t\t\treturn -EFAULT;\n\t\tif (hwts_cfg.tx_type == HWTSTAMP_TX_ON &&\n\t\t    hwts_cfg.rx_filter == HWTSTAMP_FILTER_ALL)\n\t\t\treturn 0;\n\t\treturn -ERANGE;\n\n\tcase SIOCGHWTSTAMP:  \n\t\thwts_cfg.tx_type = HWTSTAMP_TX_ON;\n\t\thwts_cfg.rx_filter = HWTSTAMP_FILTER_ALL;\n\t\tif (copy_to_user(ifr->ifr_data, &hwts_cfg, sizeof(hwts_cfg)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\nEXPORT_SYMBOL(can_eth_ioctl_hwts);\n\n \nint can_ethtool_op_get_ts_info_hwts(struct net_device *dev,\n\t\t\t\t    struct ethtool_ts_info *info)\n{\n\tinfo->so_timestamping =\n\t\tSOF_TIMESTAMPING_TX_SOFTWARE |\n\t\tSOF_TIMESTAMPING_RX_SOFTWARE |\n\t\tSOF_TIMESTAMPING_SOFTWARE |\n\t\tSOF_TIMESTAMPING_TX_HARDWARE |\n\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\tinfo->phc_index = -1;\n\tinfo->tx_types = BIT(HWTSTAMP_TX_ON);\n\tinfo->rx_filters = BIT(HWTSTAMP_FILTER_ALL);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(can_ethtool_op_get_ts_info_hwts);\n\n \nint open_candev(struct net_device *dev)\n{\n\tstruct can_priv *priv = netdev_priv(dev);\n\n\tif (!priv->bittiming.bitrate) {\n\t\tnetdev_err(dev, \"bit-timing not yet defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((priv->ctrlmode & CAN_CTRLMODE_FD) &&\n\t    (!priv->data_bittiming.bitrate ||\n\t     priv->data_bittiming.bitrate < priv->bittiming.bitrate)) {\n\t\tnetdev_err(dev, \"incorrect/missing data bit-timing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!netif_carrier_ok(dev))\n\t\tnetif_carrier_on(dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(open_candev);\n\n#ifdef CONFIG_OF\n \nvoid of_can_transceiver(struct net_device *dev)\n{\n\tstruct device_node *dn;\n\tstruct can_priv *priv = netdev_priv(dev);\n\tstruct device_node *np = dev->dev.parent->of_node;\n\tint ret;\n\n\tdn = of_get_child_by_name(np, \"can-transceiver\");\n\tif (!dn)\n\t\treturn;\n\n\tret = of_property_read_u32(dn, \"max-bitrate\", &priv->bitrate_max);\n\tof_node_put(dn);\n\tif ((ret && ret != -EINVAL) || (!ret && !priv->bitrate_max))\n\t\tnetdev_warn(dev, \"Invalid value for transceiver max bitrate. Ignoring bitrate limit.\\n\");\n}\nEXPORT_SYMBOL_GPL(of_can_transceiver);\n#endif\n\n \nvoid close_candev(struct net_device *dev)\n{\n\tstruct can_priv *priv = netdev_priv(dev);\n\n\tcancel_delayed_work_sync(&priv->restart_work);\n\tcan_flush_echo_skb(dev);\n}\nEXPORT_SYMBOL_GPL(close_candev);\n\nstatic int can_set_termination(struct net_device *ndev, u16 term)\n{\n\tstruct can_priv *priv = netdev_priv(ndev);\n\tint set;\n\n\tif (term == priv->termination_gpio_ohms[CAN_TERMINATION_GPIO_ENABLED])\n\t\tset = 1;\n\telse\n\t\tset = 0;\n\n\tgpiod_set_value(priv->termination_gpio, set);\n\n\treturn 0;\n}\n\nstatic int can_get_termination(struct net_device *ndev)\n{\n\tstruct can_priv *priv = netdev_priv(ndev);\n\tstruct device *dev = ndev->dev.parent;\n\tstruct gpio_desc *gpio;\n\tu32 term;\n\tint ret;\n\n\t \n\tgpio = devm_gpiod_get_optional(dev, \"termination\", GPIOD_OUT_LOW);\n\tif (IS_ERR(gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(gpio),\n\t\t\t\t     \"Cannot get termination-gpios\\n\");\n\n\tif (!gpio)\n\t\treturn 0;\n\n\tret = device_property_read_u32(dev, \"termination-ohms\", &term);\n\tif (ret) {\n\t\tnetdev_err(ndev, \"Cannot get termination-ohms: %pe\\n\",\n\t\t\t   ERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\tif (term > U16_MAX) {\n\t\tnetdev_err(ndev, \"Invalid termination-ohms value (%u > %u)\\n\",\n\t\t\t   term, U16_MAX);\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->termination_const_cnt = ARRAY_SIZE(priv->termination_gpio_ohms);\n\tpriv->termination_const = priv->termination_gpio_ohms;\n\tpriv->termination_gpio = gpio;\n\tpriv->termination_gpio_ohms[CAN_TERMINATION_GPIO_DISABLED] =\n\t\tCAN_TERMINATION_DISABLED;\n\tpriv->termination_gpio_ohms[CAN_TERMINATION_GPIO_ENABLED] = term;\n\tpriv->do_set_termination = can_set_termination;\n\n\treturn 0;\n}\n\nstatic bool\ncan_bittiming_const_valid(const struct can_bittiming_const *btc)\n{\n\tif (!btc)\n\t\treturn true;\n\n\tif (!btc->sjw_max)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nint register_candev(struct net_device *dev)\n{\n\tstruct can_priv *priv = netdev_priv(dev);\n\tint err;\n\n\t \n\tif ((!priv->termination_const != !priv->termination_const_cnt) ||\n\t    (!priv->termination_const != !priv->do_set_termination))\n\t\treturn -EINVAL;\n\n\tif (!priv->bitrate_const != !priv->bitrate_const_cnt)\n\t\treturn -EINVAL;\n\n\tif (!priv->data_bitrate_const != !priv->data_bitrate_const_cnt)\n\t\treturn -EINVAL;\n\n\t \n\tif ((priv->bitrate_const || priv->data_bitrate_const) &&\n\t    (priv->bittiming_const || priv->data_bittiming_const))\n\t\treturn -EINVAL;\n\n\tif (!can_bittiming_const_valid(priv->bittiming_const) ||\n\t    !can_bittiming_const_valid(priv->data_bittiming_const))\n\t\treturn -EINVAL;\n\n\tif (!priv->termination_const) {\n\t\terr = can_get_termination(dev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tdev->rtnl_link_ops = &can_link_ops;\n\tnetif_carrier_off(dev);\n\n\treturn register_netdev(dev);\n}\nEXPORT_SYMBOL_GPL(register_candev);\n\n \nvoid unregister_candev(struct net_device *dev)\n{\n\tunregister_netdev(dev);\n}\nEXPORT_SYMBOL_GPL(unregister_candev);\n\n \nstruct can_priv *safe_candev_priv(struct net_device *dev)\n{\n\tif (dev->type != ARPHRD_CAN || dev->rtnl_link_ops != &can_link_ops)\n\t\treturn NULL;\n\n\treturn netdev_priv(dev);\n}\nEXPORT_SYMBOL_GPL(safe_candev_priv);\n\nstatic __init int can_dev_init(void)\n{\n\tint err;\n\n\terr = can_netlink_register();\n\tif (!err)\n\t\tpr_info(\"CAN device driver interface\\n\");\n\n\treturn err;\n}\nmodule_init(can_dev_init);\n\nstatic __exit void can_dev_exit(void)\n{\n\tcan_netlink_unregister();\n}\nmodule_exit(can_dev_exit);\n\nMODULE_ALIAS_RTNL_LINK(\"can\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}