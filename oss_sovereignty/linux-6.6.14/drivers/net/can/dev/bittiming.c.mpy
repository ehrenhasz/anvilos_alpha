{
  "module_name": "bittiming.c",
  "hash_id": "87033c0fa3dfa8b302d1c946a5d2e64c88a9e969a6db2871287b0cc830cf1157",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/dev/bittiming.c",
  "human_readable_source": "\n \n\n#include <linux/can/dev.h>\n\nvoid can_sjw_set_default(struct can_bittiming *bt)\n{\n\tif (bt->sjw)\n\t\treturn;\n\n\t \n\tbt->sjw = max(1U, min(bt->phase_seg1, bt->phase_seg2 / 2));\n}\n\nint can_sjw_check(const struct net_device *dev, const struct can_bittiming *bt,\n\t\t  const struct can_bittiming_const *btc, struct netlink_ext_ack *extack)\n{\n\tif (bt->sjw > btc->sjw_max) {\n\t\tNL_SET_ERR_MSG_FMT(extack, \"sjw: %u greater than max sjw: %u\",\n\t\t\t\t   bt->sjw, btc->sjw_max);\n\t\treturn -EINVAL;\n\t}\n\n\tif (bt->sjw > bt->phase_seg1) {\n\t\tNL_SET_ERR_MSG_FMT(extack,\n\t\t\t\t   \"sjw: %u greater than phase-seg1: %u\",\n\t\t\t\t   bt->sjw, bt->phase_seg1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (bt->sjw > bt->phase_seg2) {\n\t\tNL_SET_ERR_MSG_FMT(extack,\n\t\t\t\t   \"sjw: %u greater than phase-seg2: %u\",\n\t\t\t\t   bt->sjw, bt->phase_seg2);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int can_fixup_bittiming(const struct net_device *dev, struct can_bittiming *bt,\n\t\t\t       const struct can_bittiming_const *btc,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tconst unsigned int tseg1 = bt->prop_seg + bt->phase_seg1;\n\tconst struct can_priv *priv = netdev_priv(dev);\n\tu64 brp64;\n\tint err;\n\n\tif (tseg1 < btc->tseg1_min) {\n\t\tNL_SET_ERR_MSG_FMT(extack, \"prop-seg + phase-seg1: %u less than tseg1-min: %u\",\n\t\t\t\t   tseg1, btc->tseg1_min);\n\t\treturn -EINVAL;\n\t}\n\tif (tseg1 > btc->tseg1_max) {\n\t\tNL_SET_ERR_MSG_FMT(extack, \"prop-seg + phase-seg1: %u greater than tseg1-max: %u\",\n\t\t\t\t   tseg1, btc->tseg1_max);\n\t\treturn -EINVAL;\n\t}\n\tif (bt->phase_seg2 < btc->tseg2_min) {\n\t\tNL_SET_ERR_MSG_FMT(extack, \"phase-seg2: %u less than tseg2-min: %u\",\n\t\t\t\t   bt->phase_seg2, btc->tseg2_min);\n\t\treturn -EINVAL;\n\t}\n\tif (bt->phase_seg2 > btc->tseg2_max) {\n\t\tNL_SET_ERR_MSG_FMT(extack, \"phase-seg2: %u greater than tseg2-max: %u\",\n\t\t\t\t   bt->phase_seg2, btc->tseg2_max);\n\t\treturn -EINVAL;\n\t}\n\n\tcan_sjw_set_default(bt);\n\n\terr = can_sjw_check(dev, bt, btc, extack);\n\tif (err)\n\t\treturn err;\n\n\tbrp64 = (u64)priv->clock.freq * (u64)bt->tq;\n\tif (btc->brp_inc > 1)\n\t\tdo_div(brp64, btc->brp_inc);\n\tbrp64 += 500000000UL - 1;\n\tdo_div(brp64, 1000000000UL);  \n\tif (btc->brp_inc > 1)\n\t\tbrp64 *= btc->brp_inc;\n\tbt->brp = (u32)brp64;\n\n\tif (bt->brp < btc->brp_min) {\n\t\tNL_SET_ERR_MSG_FMT(extack, \"resulting brp: %u less than brp-min: %u\",\n\t\t\t\t   bt->brp, btc->brp_min);\n\t\treturn -EINVAL;\n\t}\n\tif (bt->brp > btc->brp_max) {\n\t\tNL_SET_ERR_MSG_FMT(extack, \"resulting brp: %u greater than brp-max: %u\",\n\t\t\t\t   bt->brp, btc->brp_max);\n\t\treturn -EINVAL;\n\t}\n\n\tbt->bitrate = priv->clock.freq / (bt->brp * can_bit_time(bt));\n\tbt->sample_point = ((CAN_SYNC_SEG + tseg1) * 1000) / can_bit_time(bt);\n\tbt->tq = DIV_U64_ROUND_CLOSEST(mul_u32_u32(bt->brp, NSEC_PER_SEC),\n\t\t\t\t       priv->clock.freq);\n\n\treturn 0;\n}\n\n \nstatic int\ncan_validate_bitrate(const struct net_device *dev, const struct can_bittiming *bt,\n\t\t     const u32 *bitrate_const,\n\t\t     const unsigned int bitrate_const_cnt,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < bitrate_const_cnt; i++) {\n\t\tif (bt->bitrate == bitrate_const[i])\n\t\t\treturn 0;\n\t}\n\n\tNL_SET_ERR_MSG_FMT(extack, \"bitrate %u bps not supported\",\n\t\t\t   bt->brp);\n\n\treturn -EINVAL;\n}\n\nint can_get_bittiming(const struct net_device *dev, struct can_bittiming *bt,\n\t\t      const struct can_bittiming_const *btc,\n\t\t      const u32 *bitrate_const,\n\t\t      const unsigned int bitrate_const_cnt,\n\t\t      struct netlink_ext_ack *extack)\n{\n\t \n\tif (!bt->tq && bt->bitrate && btc)\n\t\treturn can_calc_bittiming(dev, bt, btc, extack);\n\tif (bt->tq && !bt->bitrate && btc)\n\t\treturn can_fixup_bittiming(dev, bt, btc, extack);\n\tif (!bt->tq && bt->bitrate && bitrate_const)\n\t\treturn can_validate_bitrate(dev, bt, bitrate_const,\n\t\t\t\t\t    bitrate_const_cnt, extack);\n\n\treturn -EINVAL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}