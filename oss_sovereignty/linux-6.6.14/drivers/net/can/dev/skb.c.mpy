{
  "module_name": "skb.c",
  "hash_id": "1d98b3ef68c77434d32ce94e4649ede1b1fac9af0a7008c3fb896885c709dab5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/can/dev/skb.c",
  "human_readable_source": "\n \n\n#include <linux/can/dev.h>\n#include <linux/module.h>\n\n#define MOD_DESC \"CAN device driver interface\"\n\nMODULE_DESCRIPTION(MOD_DESC);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Wolfgang Grandegger <wg@grandegger.com>\");\n\n \nvoid can_flush_echo_skb(struct net_device *dev)\n{\n\tstruct can_priv *priv = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\tint i;\n\n\tfor (i = 0; i < priv->echo_skb_max; i++) {\n\t\tif (priv->echo_skb[i]) {\n\t\t\tkfree_skb(priv->echo_skb[i]);\n\t\t\tpriv->echo_skb[i] = NULL;\n\t\t\tstats->tx_dropped++;\n\t\t\tstats->tx_aborted_errors++;\n\t\t}\n\t}\n}\n\n \nint can_put_echo_skb(struct sk_buff *skb, struct net_device *dev,\n\t\t     unsigned int idx, unsigned int frame_len)\n{\n\tstruct can_priv *priv = netdev_priv(dev);\n\n\tif (idx >= priv->echo_skb_max) {\n\t\tnetdev_err(dev, \"%s: BUG! Trying to access can_priv::echo_skb out of bounds (%u/max %u)\\n\",\n\t\t\t   __func__, idx, priv->echo_skb_max);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!(dev->flags & IFF_ECHO) ||\n\t    (skb->protocol != htons(ETH_P_CAN) &&\n\t     skb->protocol != htons(ETH_P_CANFD) &&\n\t     skb->protocol != htons(ETH_P_CANXL))) {\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\tif (!priv->echo_skb[idx]) {\n\t\tskb = can_create_echo_skb(skb);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\t\tskb->dev = dev;\n\n\t\t \n\t\tcan_skb_prv(skb)->frame_len = frame_len;\n\n\t\tif (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)\n\t\t\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\n\t\tskb_tx_timestamp(skb);\n\n\t\t \n\t\tpriv->echo_skb[idx] = skb;\n\t} else {\n\t\t \n\t\tnetdev_err(dev, \"%s: BUG! echo_skb %d is occupied!\\n\", __func__, idx);\n\t\tkfree_skb(skb);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(can_put_echo_skb);\n\nstruct sk_buff *\n__can_get_echo_skb(struct net_device *dev, unsigned int idx,\n\t\t   unsigned int *len_ptr, unsigned int *frame_len_ptr)\n{\n\tstruct can_priv *priv = netdev_priv(dev);\n\n\tif (idx >= priv->echo_skb_max) {\n\t\tnetdev_err(dev, \"%s: BUG! Trying to access can_priv::echo_skb out of bounds (%u/max %u)\\n\",\n\t\t\t   __func__, idx, priv->echo_skb_max);\n\t\treturn NULL;\n\t}\n\n\tif (priv->echo_skb[idx]) {\n\t\t \n\t\tstruct sk_buff *skb = priv->echo_skb[idx];\n\t\tstruct can_skb_priv *can_skb_priv = can_skb_prv(skb);\n\n\t\tif (skb_shinfo(skb)->tx_flags & SKBTX_IN_PROGRESS)\n\t\t\tskb_tstamp_tx(skb, skb_hwtstamps(skb));\n\n\t\t \n\t\t*len_ptr = can_skb_get_data_len(skb);\n\n\t\tif (frame_len_ptr)\n\t\t\t*frame_len_ptr = can_skb_priv->frame_len;\n\n\t\tpriv->echo_skb[idx] = NULL;\n\n\t\tif (skb->pkt_type == PACKET_LOOPBACK) {\n\t\t\tskb->pkt_type = PACKET_BROADCAST;\n\t\t} else {\n\t\t\tdev_consume_skb_any(skb);\n\t\t\treturn NULL;\n\t\t}\n\n\t\treturn skb;\n\t}\n\n\treturn NULL;\n}\n\n \nunsigned int can_get_echo_skb(struct net_device *dev, unsigned int idx,\n\t\t\t      unsigned int *frame_len_ptr)\n{\n\tstruct sk_buff *skb;\n\tunsigned int len;\n\n\tskb = __can_get_echo_skb(dev, idx, &len, frame_len_ptr);\n\tif (!skb)\n\t\treturn 0;\n\n\tskb_get(skb);\n\tif (netif_rx(skb) == NET_RX_SUCCESS)\n\t\tdev_consume_skb_any(skb);\n\telse\n\t\tdev_kfree_skb_any(skb);\n\n\treturn len;\n}\nEXPORT_SYMBOL_GPL(can_get_echo_skb);\n\n \nvoid can_free_echo_skb(struct net_device *dev, unsigned int idx,\n\t\t       unsigned int *frame_len_ptr)\n{\n\tstruct can_priv *priv = netdev_priv(dev);\n\n\tif (idx >= priv->echo_skb_max) {\n\t\tnetdev_err(dev, \"%s: BUG! Trying to access can_priv::echo_skb out of bounds (%u/max %u)\\n\",\n\t\t\t   __func__, idx, priv->echo_skb_max);\n\t\treturn;\n\t}\n\n\tif (priv->echo_skb[idx]) {\n\t\tstruct sk_buff *skb = priv->echo_skb[idx];\n\t\tstruct can_skb_priv *can_skb_priv = can_skb_prv(skb);\n\n\t\tif (frame_len_ptr)\n\t\t\t*frame_len_ptr = can_skb_priv->frame_len;\n\n\t\tdev_kfree_skb_any(skb);\n\t\tpriv->echo_skb[idx] = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(can_free_echo_skb);\n\n \nstatic void init_can_skb_reserve(struct sk_buff *skb)\n{\n\tskb->pkt_type = PACKET_BROADCAST;\n\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\tskb_reset_transport_header(skb);\n\n\tcan_skb_reserve(skb);\n\tcan_skb_prv(skb)->skbcnt = 0;\n}\n\nstruct sk_buff *alloc_can_skb(struct net_device *dev, struct can_frame **cf)\n{\n\tstruct sk_buff *skb;\n\n\tskb = netdev_alloc_skb(dev, sizeof(struct can_skb_priv) +\n\t\t\t       sizeof(struct can_frame));\n\tif (unlikely(!skb)) {\n\t\t*cf = NULL;\n\n\t\treturn NULL;\n\t}\n\n\tskb->protocol = htons(ETH_P_CAN);\n\tinit_can_skb_reserve(skb);\n\tcan_skb_prv(skb)->ifindex = dev->ifindex;\n\n\t*cf = skb_put_zero(skb, sizeof(struct can_frame));\n\n\treturn skb;\n}\nEXPORT_SYMBOL_GPL(alloc_can_skb);\n\nstruct sk_buff *alloc_canfd_skb(struct net_device *dev,\n\t\t\t\tstruct canfd_frame **cfd)\n{\n\tstruct sk_buff *skb;\n\n\tskb = netdev_alloc_skb(dev, sizeof(struct can_skb_priv) +\n\t\t\t       sizeof(struct canfd_frame));\n\tif (unlikely(!skb)) {\n\t\t*cfd = NULL;\n\n\t\treturn NULL;\n\t}\n\n\tskb->protocol = htons(ETH_P_CANFD);\n\tinit_can_skb_reserve(skb);\n\tcan_skb_prv(skb)->ifindex = dev->ifindex;\n\n\t*cfd = skb_put_zero(skb, sizeof(struct canfd_frame));\n\n\t \n\t(*cfd)->flags = CANFD_FDF;\n\n\treturn skb;\n}\nEXPORT_SYMBOL_GPL(alloc_canfd_skb);\n\nstruct sk_buff *alloc_canxl_skb(struct net_device *dev,\n\t\t\t\tstruct canxl_frame **cxl,\n\t\t\t\tunsigned int data_len)\n{\n\tstruct sk_buff *skb;\n\n\tif (data_len < CANXL_MIN_DLEN || data_len > CANXL_MAX_DLEN)\n\t\tgoto out_error;\n\n\tskb = netdev_alloc_skb(dev, sizeof(struct can_skb_priv) +\n\t\t\t       CANXL_HDR_SIZE + data_len);\n\tif (unlikely(!skb))\n\t\tgoto out_error;\n\n\tskb->protocol = htons(ETH_P_CANXL);\n\tinit_can_skb_reserve(skb);\n\tcan_skb_prv(skb)->ifindex = dev->ifindex;\n\n\t*cxl = skb_put_zero(skb, CANXL_HDR_SIZE + data_len);\n\n\t \n\t(*cxl)->flags = CANXL_XLF;\n\t(*cxl)->len = data_len;\n\n\treturn skb;\n\nout_error:\n\t*cxl = NULL;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(alloc_canxl_skb);\n\nstruct sk_buff *alloc_can_err_skb(struct net_device *dev, struct can_frame **cf)\n{\n\tstruct sk_buff *skb;\n\n\tskb = alloc_can_skb(dev, cf);\n\tif (unlikely(!skb))\n\t\treturn NULL;\n\n\t(*cf)->can_id = CAN_ERR_FLAG;\n\t(*cf)->len = CAN_ERR_DLC;\n\n\treturn skb;\n}\nEXPORT_SYMBOL_GPL(alloc_can_err_skb);\n\n \nstatic bool can_skb_headroom_valid(struct net_device *dev, struct sk_buff *skb)\n{\n\t \n\tif (WARN_ON_ONCE(skb_headroom(skb) < sizeof(struct can_skb_priv)))\n\t\treturn false;\n\n\t \n\tif (skb->ip_summed == CHECKSUM_NONE) {\n\t\t \n\t\tcan_skb_prv(skb)->ifindex = dev->ifindex;\n\t\tcan_skb_prv(skb)->skbcnt = 0;\n\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\t\t \n\t\tif (dev->flags & IFF_ECHO)\n\t\t\tskb->pkt_type = PACKET_LOOPBACK;\n\t\telse\n\t\t\tskb->pkt_type = PACKET_HOST;\n\n\t\tskb_reset_mac_header(skb);\n\t\tskb_reset_network_header(skb);\n\t\tskb_reset_transport_header(skb);\n\n\t\t \n\t\tif (can_is_canfd_skb(skb)) {\n\t\t\tstruct canfd_frame *cfd;\n\n\t\t\tcfd = (struct canfd_frame *)skb->data;\n\t\t\tcfd->flags |= CANFD_FDF;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n \nbool can_dropped_invalid_skb(struct net_device *dev, struct sk_buff *skb)\n{\n\tswitch (ntohs(skb->protocol)) {\n\tcase ETH_P_CAN:\n\t\tif (!can_is_can_skb(skb))\n\t\t\tgoto inval_skb;\n\t\tbreak;\n\n\tcase ETH_P_CANFD:\n\t\tif (!can_is_canfd_skb(skb))\n\t\t\tgoto inval_skb;\n\t\tbreak;\n\n\tcase ETH_P_CANXL:\n\t\tif (!can_is_canxl_skb(skb))\n\t\t\tgoto inval_skb;\n\t\tbreak;\n\n\tdefault:\n\t\tgoto inval_skb;\n\t}\n\n\tif (!can_skb_headroom_valid(dev, skb))\n\t\tgoto inval_skb;\n\n\treturn false;\n\ninval_skb:\n\tkfree_skb(skb);\n\tdev->stats.tx_dropped++;\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(can_dropped_invalid_skb);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}