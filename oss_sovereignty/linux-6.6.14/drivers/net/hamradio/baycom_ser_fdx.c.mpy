{
  "module_name": "baycom_ser_fdx.c",
  "hash_id": "a1884e7e2c5ad7fd76ce2de0fadb0db706ab204ea9a66ff79b57370433c637dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/hamradio/baycom_ser_fdx.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/hdlcdrv.h>\n#include <linux/baycom.h>\n#include <linux/jiffies.h>\n#include <linux/time64.h>\n\n#include <linux/uaccess.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n\n \n\n#define BAYCOM_DEBUG\n\n \n\nstatic const char bc_drvname[] = \"baycom_ser_fdx\";\nstatic const char bc_drvinfo[] = KERN_INFO \"baycom_ser_fdx: (C) 1996-2000 Thomas Sailer, HB9JNX/AE4WA\\n\"\n\"baycom_ser_fdx: version 0.10\\n\";\n\n \n\n#define NR_PORTS 4\n\nstatic struct net_device *baycom_device[NR_PORTS];\n\n \n\n#define RBR(iobase) (iobase+0)\n#define THR(iobase) (iobase+0)\n#define IER(iobase) (iobase+1)\n#define IIR(iobase) (iobase+2)\n#define FCR(iobase) (iobase+2)\n#define LCR(iobase) (iobase+3)\n#define MCR(iobase) (iobase+4)\n#define LSR(iobase) (iobase+5)\n#define MSR(iobase) (iobase+6)\n#define SCR(iobase) (iobase+7)\n#define DLL(iobase) (iobase+0)\n#define DLM(iobase) (iobase+1)\n\n#define SER12_EXTENT 8\n\n \n \n\nstruct baycom_state {\n\tstruct hdlcdrv_state hdrv;\n\n\tunsigned int baud, baud_us, baud_arbdiv, baud_uartdiv, baud_dcdtimeout;\n\tint opt_dcd;\n\n\tstruct modem_state {\n\t\tunsigned char flags;\n\t\tunsigned char ptt;\n\t\tunsigned int shreg;\n\t\tstruct modem_state_ser12 {\n\t\t\tunsigned char tx_bit;\n\t\t\tunsigned char last_rxbit;\n\t\t\tint dcd_sum0, dcd_sum1, dcd_sum2;\n\t\t\tint dcd_time;\n\t\t\tunsigned int pll_time;\n\t\t\tunsigned int txshreg;\n\t\t} ser12;\n\t} modem;\n\n#ifdef BAYCOM_DEBUG\n\tstruct debug_vals {\n\t\tunsigned long last_jiffies;\n\t\tunsigned cur_intcnt;\n\t\tunsigned last_intcnt;\n\t\tint cur_pllcorr;\n\t\tint last_pllcorr;\n\t} debug_vals;\n#endif  \n};\n\n \n\nstatic inline void baycom_int_freq(struct baycom_state *bc)\n{\n#ifdef BAYCOM_DEBUG\n\tunsigned long cur_jiffies = jiffies;\n\t \n\tbc->debug_vals.cur_intcnt++;\n\tif (time_after_eq(cur_jiffies, bc->debug_vals.last_jiffies + HZ)) {\n\t\tbc->debug_vals.last_jiffies = cur_jiffies;\n\t\tbc->debug_vals.last_intcnt = bc->debug_vals.cur_intcnt;\n\t\tbc->debug_vals.cur_intcnt = 0;\n\t\tbc->debug_vals.last_pllcorr = bc->debug_vals.cur_pllcorr;\n\t\tbc->debug_vals.cur_pllcorr = 0;\n\t}\n#endif  \n}\n\n \n \n\n \n\nstatic inline void ser12_set_divisor(struct net_device *dev,\n                                     unsigned int divisor)\n{\n        outb(0x81, LCR(dev->base_addr));         \n        outb(divisor, DLL(dev->base_addr));\n        outb(divisor >> 8, DLM(dev->base_addr));\n        outb(0x01, LCR(dev->base_addr));         \n         \n        outb(0x00, THR(dev->base_addr));\n         \n}\n\nstatic __inline__ void ser12_rx(struct net_device *dev, struct baycom_state *bc, struct timespec64 *ts, unsigned char curs)\n{\n\tint timediff;\n\tint bdus8 = bc->baud_us >> 3;\n\tint bdus4 = bc->baud_us >> 2;\n\tint bdus2 = bc->baud_us >> 1;\n\n\ttimediff = 1000000 + ts->tv_nsec / NSEC_PER_USEC -\n\t\t\t\t\tbc->modem.ser12.pll_time;\n\twhile (timediff >= 500000)\n\t\ttimediff -= 1000000;\n\twhile (timediff >= bdus2) {\n\t\ttimediff -= bc->baud_us;\n\t\tbc->modem.ser12.pll_time += bc->baud_us;\n\t\tbc->modem.ser12.dcd_time--;\n\t\t \n\t\tif (bc->modem.shreg & 1) {\n\t\t\thdlcdrv_putbits(&bc->hdrv, (bc->modem.shreg >> 1) ^ 0xffff);\n\t\t\tbc->modem.shreg = 0x10000;\n\t\t}\n\t\t \n\t\tbc->modem.shreg >>= 1;\n\t}\n\tif (bc->modem.ser12.dcd_time <= 0) {\n\t\tif (!bc->opt_dcd)\n\t\t\thdlcdrv_setdcd(&bc->hdrv, (bc->modem.ser12.dcd_sum0 + \n\t\t\t\t\t\t   bc->modem.ser12.dcd_sum1 + \n\t\t\t\t\t\t   bc->modem.ser12.dcd_sum2) < 0);\n\t\tbc->modem.ser12.dcd_sum2 = bc->modem.ser12.dcd_sum1;\n\t\tbc->modem.ser12.dcd_sum1 = bc->modem.ser12.dcd_sum0;\n\t\tbc->modem.ser12.dcd_sum0 = 2;  \n\t\tbc->modem.ser12.dcd_time += 120;\n\t}\n\tif (bc->modem.ser12.last_rxbit != curs) {\n\t\tbc->modem.ser12.last_rxbit = curs;\n\t\tbc->modem.shreg |= 0x10000;\n\t\t \n\t\tif (timediff > 0)\n\t\t\tbc->modem.ser12.pll_time += bdus8;\n\t\telse\n\t\t\tbc->modem.ser12.pll_time += 1000000 - bdus8;\n\t\t \n\t\tif (abs(timediff) > bdus4)\n\t\t\tbc->modem.ser12.dcd_sum0 += 4;\n\t\telse\n\t\t\tbc->modem.ser12.dcd_sum0--;\n#ifdef BAYCOM_DEBUG\n\t\tbc->debug_vals.cur_pllcorr = timediff;\n#endif  \n\t}\n\twhile (bc->modem.ser12.pll_time >= 1000000)\n\t\tbc->modem.ser12.pll_time -= 1000000;\n}\n\n \n\nstatic irqreturn_t ser12_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = (struct net_device *)dev_id;\n\tstruct baycom_state *bc = netdev_priv(dev);\n\tstruct timespec64 ts;\n\tunsigned char iir, msr;\n\tunsigned int txcount = 0;\n\n\tif (!bc || bc->hdrv.magic != HDLCDRV_MAGIC)\n\t\treturn IRQ_NONE;\n\t \n\tif ((iir = inb(IIR(dev->base_addr))) & 1) \t\n\t\treturn IRQ_NONE;\n\t \n\tktime_get_ts64(&ts);\n\tmsr = inb(MSR(dev->base_addr));\n\t \n\tif ((msr & 8) && bc->opt_dcd)\n\t\thdlcdrv_setdcd(&bc->hdrv, !((msr ^ bc->opt_dcd) & 0x80));\n\tdo {\n\t\tswitch (iir & 6) {\n\t\tcase 6:\n\t\t\tinb(LSR(dev->base_addr));\n\t\t\tbreak;\n\t\t\t\n\t\tcase 4:\n\t\t\tinb(RBR(dev->base_addr));\n\t\t\tbreak;\n\t\t\t\n\t\tcase 2:\n\t\t\t \n\t\t\toutb(0x00, THR(dev->base_addr));\n\t\t\tbaycom_int_freq(bc);\n\t\t\ttxcount++;\n\t\t\t \n\t\t\tif (bc->modem.ptt)\n\t\t\t\toutb(0x0e | (!!bc->modem.ser12.tx_bit), MCR(dev->base_addr));\n\t\t\telse\n\t\t\t\toutb(0x0d, MCR(dev->base_addr));        \n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tmsr = inb(MSR(dev->base_addr));\n\t\t\t \n\t\t\tif ((msr & 8) && bc->opt_dcd) \n\t\t\t\thdlcdrv_setdcd(&bc->hdrv, !((msr ^ bc->opt_dcd) & 0x80));\n\t\t\tbreak;\n\t\t}\n\t\tiir = inb(IIR(dev->base_addr));\n\t} while (!(iir & 1));\n\tser12_rx(dev, bc, &ts, msr & 0x10);  \n\tif (bc->modem.ptt && txcount) {\n\t\tif (bc->modem.ser12.txshreg <= 1) {\n\t\t\tbc->modem.ser12.txshreg = 0x10000 | hdlcdrv_getbits(&bc->hdrv);\n\t\t\tif (!hdlcdrv_ptt(&bc->hdrv)) {\n\t\t\t\tser12_set_divisor(dev, 115200/100/8);\n\t\t\t\tbc->modem.ptt = 0;\n\t\t\t\tgoto end_transmit;\n\t\t\t}\n\t\t}\n\t\tbc->modem.ser12.tx_bit = !(bc->modem.ser12.tx_bit ^ (bc->modem.ser12.txshreg & 1));\n\t\tbc->modem.ser12.txshreg >>= 1;\n\t}\n end_transmit:\n\tlocal_irq_enable();\n\tif (!bc->modem.ptt && txcount) {\n\t\thdlcdrv_arbitrate(dev, &bc->hdrv);\n\t\tif (hdlcdrv_ptt(&bc->hdrv)) {\n\t\t\tser12_set_divisor(dev, bc->baud_uartdiv);\n\t\t\tbc->modem.ser12.txshreg = 1;\n\t\t\tbc->modem.ptt = 1;\n\t\t}\n\t}\n\thdlcdrv_transmitter(dev, &bc->hdrv);\n\thdlcdrv_receiver(dev, &bc->hdrv);\n\tlocal_irq_disable();\n\treturn IRQ_HANDLED;\n}\n\n \n\nenum uart { c_uart_unknown, c_uart_8250,\n\t    c_uart_16450, c_uart_16550, c_uart_16550A};\nstatic const char *uart_str[] = { \n\t\"unknown\", \"8250\", \"16450\", \"16550\", \"16550A\" \n};\n\nstatic enum uart ser12_check_uart(unsigned int iobase)\n{\n\tunsigned char b1,b2,b3;\n\tenum uart u;\n\tenum uart uart_tab[] =\n\t\t{ c_uart_16450, c_uart_unknown, c_uart_16550, c_uart_16550A };\n\n\tb1 = inb(MCR(iobase));\n\toutb(b1 | 0x10, MCR(iobase));\t \n\tb2 = inb(MSR(iobase));\n\toutb(0x1a, MCR(iobase));\n\tb3 = inb(MSR(iobase)) & 0xf0;\n\toutb(b1, MCR(iobase));\t\t\t \n\toutb(b2, MSR(iobase));\n\tif (b3 != 0x90)\n\t\treturn c_uart_unknown;\n\tinb(RBR(iobase));\n\tinb(RBR(iobase));\n\toutb(0x01, FCR(iobase));\t\t \n\tu = uart_tab[(inb(IIR(iobase)) >> 6) & 3];\n\tif (u == c_uart_16450) {\n\t\toutb(0x5a, SCR(iobase));\n\t\tb1 = inb(SCR(iobase));\n\t\toutb(0xa5, SCR(iobase));\n\t\tb2 = inb(SCR(iobase));\n\t\tif ((b1 != 0x5a) || (b2 != 0xa5))\n\t\t\tu = c_uart_8250;\n\t}\n\treturn u;\n}\n\n \n\nstatic int ser12_open(struct net_device *dev)\n{\n\tstruct baycom_state *bc = netdev_priv(dev);\n\tenum uart u;\n\n\tif (!dev || !bc)\n\t\treturn -ENXIO;\n\tif (!dev->base_addr || dev->base_addr > 0xffff-SER12_EXTENT ||\n\t    dev->irq < 2 || dev->irq > nr_irqs) {\n\t\tprintk(KERN_INFO \"baycom_ser_fdx: invalid portnumber (max %u) \"\n\t\t\t\t\"or irq (2 <= irq <= %d)\\n\",\n\t\t\t\t0xffff-SER12_EXTENT, nr_irqs);\n\t\treturn -ENXIO;\n\t}\n\tif (bc->baud < 300 || bc->baud > 4800) {\n\t\tprintk(KERN_INFO \"baycom_ser_fdx: invalid baudrate \"\n\t\t\t\t\"(300...4800)\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!request_region(dev->base_addr, SER12_EXTENT, \"baycom_ser_fdx\")) {\n\t\tprintk(KERN_WARNING \"BAYCOM_SER_FSX: I/O port 0x%04lx busy\\n\",\n\t\t       dev->base_addr);\n\t\treturn -EACCES;\n\t}\n\tmemset(&bc->modem, 0, sizeof(bc->modem));\n\tbc->hdrv.par.bitrate = bc->baud;\n\tbc->baud_us = 1000000/bc->baud;\n\tbc->baud_uartdiv = (115200/8)/bc->baud;\n\tif ((u = ser12_check_uart(dev->base_addr)) == c_uart_unknown){\n\t\trelease_region(dev->base_addr, SER12_EXTENT);\n\t\treturn -EIO;\n\t}\n\toutb(0, FCR(dev->base_addr));   \n\toutb(0x0d, MCR(dev->base_addr));\n\toutb(0, IER(dev->base_addr));\n\tif (request_irq(dev->irq, ser12_interrupt, IRQF_SHARED,\n\t\t\t\"baycom_ser_fdx\", dev)) {\n\t\trelease_region(dev->base_addr, SER12_EXTENT);\n\t\treturn -EBUSY;\n\t}\n\t \n\tser12_set_divisor(dev, 115200/100/8);\n\t \n\toutb(0x0a, IER(dev->base_addr));\n\t \n\toutb(0x00, THR(dev->base_addr));\n\thdlcdrv_setdcd(&bc->hdrv, 0);\n\tprintk(KERN_INFO \"%s: ser_fdx at iobase 0x%lx irq %u baud %u uart %s\\n\",\n\t       bc_drvname, dev->base_addr, dev->irq, bc->baud, uart_str[u]);\n\treturn 0;\n}\n\n \n\nstatic int ser12_close(struct net_device *dev)\n{\n\tstruct baycom_state *bc = netdev_priv(dev);\n\n\tif (!dev || !bc)\n\t\treturn -EINVAL;\n\t \n\toutb(0, IER(dev->base_addr));\n\toutb(1, MCR(dev->base_addr));\n\tfree_irq(dev->irq, dev);\n\trelease_region(dev->base_addr, SER12_EXTENT);\n\tprintk(KERN_INFO \"%s: close ser_fdx at iobase 0x%lx irq %u\\n\",\n\t       bc_drvname, dev->base_addr, dev->irq);\n\treturn 0;\n}\n\n \n \n\n \n\nstatic int baycom_ioctl(struct net_device *dev, void __user *data,\n\t\t\tstruct hdlcdrv_ioctl *hi, int cmd);\n\n \n\nstatic const struct hdlcdrv_ops ser12_ops = {\n\t.drvname = bc_drvname,\n\t.drvinfo = bc_drvinfo,\n\t.open    = ser12_open,\n\t.close   = ser12_close,\n\t.ioctl   = baycom_ioctl,\n};\n\n \n\nstatic int baycom_setmode(struct baycom_state *bc, const char *modestr)\n{\n\tunsigned int baud;\n\n\tif (!strncmp(modestr, \"ser\", 3)) {\n\t\tbaud = simple_strtoul(modestr+3, NULL, 10);\n\t\tif (baud >= 3 && baud <= 48)\n\t\t\tbc->baud = baud*100;\n\t}\n\tif (strchr(modestr, '*'))\n\t\tbc->opt_dcd = 0;\n\telse if (strchr(modestr, '+'))\n\t\tbc->opt_dcd = -1;\n\telse\n\t\tbc->opt_dcd = 1;\n\treturn 0;\n}\n\n \n\nstatic int baycom_ioctl(struct net_device *dev, void __user *data,\n\t\t\tstruct hdlcdrv_ioctl *hi, int cmd)\n{\n\tstruct baycom_state *bc;\n\tstruct baycom_ioctl bi;\n\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\tbc = netdev_priv(dev);\n\tBUG_ON(bc->hdrv.magic != HDLCDRV_MAGIC);\n\n\tif (cmd != SIOCDEVPRIVATE)\n\t\treturn -ENOIOCTLCMD;\n\tswitch (hi->cmd) {\n\tdefault:\n\t\tbreak;\n\n\tcase HDLCDRVCTL_GETMODE:\n\t\tsprintf(hi->data.modename, \"ser%u\", bc->baud / 100);\n\t\tif (bc->opt_dcd <= 0)\n\t\t\tstrcat(hi->data.modename, (!bc->opt_dcd) ? \"*\" : \"+\");\n\t\tif (copy_to_user(data, hi, sizeof(struct hdlcdrv_ioctl)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase HDLCDRVCTL_SETMODE:\n\t\tif (netif_running(dev) || !capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\t\thi->data.modename[sizeof(hi->data.modename)-1] = '\\0';\n\t\treturn baycom_setmode(bc, hi->data.modename);\n\n\tcase HDLCDRVCTL_MODELIST:\n\t\tstrcpy(hi->data.modename, \"ser12,ser3,ser24\");\n\t\tif (copy_to_user(data, hi, sizeof(struct hdlcdrv_ioctl)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase HDLCDRVCTL_MODEMPARMASK:\n\t\treturn HDLCDRV_PARMASK_IOBASE | HDLCDRV_PARMASK_IRQ;\n\n\t}\n\n\tif (copy_from_user(&bi, data, sizeof(bi)))\n\t\treturn -EFAULT;\n\tswitch (bi.cmd) {\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\n#ifdef BAYCOM_DEBUG\n\tcase BAYCOMCTL_GETDEBUG:\n\t\tbi.data.dbg.debug1 = bc->hdrv.ptt_keyed;\n\t\tbi.data.dbg.debug2 = bc->debug_vals.last_intcnt;\n\t\tbi.data.dbg.debug3 = bc->debug_vals.last_pllcorr;\n\t\tbreak;\n#endif  \n\n\t}\n\tif (copy_to_user(data, &bi, sizeof(bi)))\n\t\treturn -EFAULT;\n\treturn 0;\n\n}\n\n \n\n \nstatic char *mode[NR_PORTS] = { \"ser12*\", };\nstatic int iobase[NR_PORTS] = { 0x3f8, };\nstatic int irq[NR_PORTS] = { 4, };\nstatic int baud[NR_PORTS] = { [0 ... NR_PORTS-1] = 1200 };\n\nmodule_param_array(mode, charp, NULL, 0);\nMODULE_PARM_DESC(mode, \"baycom operating mode; * for software DCD\");\nmodule_param_hw_array(iobase, int, ioport, NULL, 0);\nMODULE_PARM_DESC(iobase, \"baycom io base address\");\nmodule_param_hw_array(irq, int, irq, NULL, 0);\nMODULE_PARM_DESC(irq, \"baycom irq number\");\nmodule_param_array(baud, int, NULL, 0);\nMODULE_PARM_DESC(baud, \"baycom baud rate (300 to 4800)\");\n\nMODULE_AUTHOR(\"Thomas M. Sailer, sailer@ife.ee.ethz.ch, hb9jnx@hb9w.che.eu\");\nMODULE_DESCRIPTION(\"Baycom ser12 full duplex amateur radio modem driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n\nstatic int __init init_baycomserfdx(void)\n{\n\tint i, found = 0;\n\tchar set_hw = 1;\n\n\tprintk(bc_drvinfo);\n\t \n\tfor (i = 0; i < NR_PORTS; i++) {\n\t\tstruct net_device *dev;\n\t\tstruct baycom_state *bc;\n\t\tchar ifname[IFNAMSIZ];\n\n\t\tsprintf(ifname, \"bcsf%d\", i);\n\n\t\tif (!mode[i])\n\t\t\tset_hw = 0;\n\t\tif (!set_hw)\n\t\t\tiobase[i] = irq[i] = 0;\n\n\t\tdev = hdlcdrv_register(&ser12_ops, \n\t\t\t\t       sizeof(struct baycom_state),\n\t\t\t\t       ifname, iobase[i], irq[i], 0);\n\t\tif (IS_ERR(dev)) \n\t\t\tbreak;\n\n\t\tbc = netdev_priv(dev);\n\t\tif (set_hw && baycom_setmode(bc, mode[i]))\n\t\t\tset_hw = 0;\n\t\tbc->baud = baud[i];\n\t\tfound++;\n\t\tbaycom_device[i] = dev;\n\t}\n\n\tif (!found)\n\t\treturn -ENXIO;\n\treturn 0;\n}\n\nstatic void __exit cleanup_baycomserfdx(void)\n{\n\tint i;\n\n\tfor(i = 0; i < NR_PORTS; i++) {\n\t\tstruct net_device *dev = baycom_device[i];\n\t\tif (dev) \n\t\t\thdlcdrv_unregister(dev);\n\t}\n}\n\nmodule_init(init_baycomserfdx);\nmodule_exit(cleanup_baycomserfdx);\n\n \n\n#ifndef MODULE\n\n \n\nstatic int __init baycom_ser_fdx_setup(char *str)\n{\n        static unsigned nr_dev;\n        int ints[4];\n\n        if (nr_dev >= NR_PORTS)\n                return 0;\n        str = get_options(str, 4, ints);\n        if (ints[0] < 2)\n                return 0;\n        mode[nr_dev] = str;\n        iobase[nr_dev] = ints[1];\n        irq[nr_dev] = ints[2];\n\tif (ints[0] >= 3)\n\t\tbaud[nr_dev] = ints[3];\n\tnr_dev++;\n\treturn 1;\n}\n\n__setup(\"baycom_ser_fdx=\", baycom_ser_fdx_setup);\n\n#endif  \n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}