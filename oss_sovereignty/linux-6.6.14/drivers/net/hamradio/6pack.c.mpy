{
  "module_name": "6pack.c",
  "hash_id": "0b38a54e3774a87ab6befe44c40fea579e70ee1d0556b09d631184612016364b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/hamradio/6pack.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/in.h>\n#include <linux/tty.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/rtnetlink.h>\n#include <linux/spinlock.h>\n#include <linux/if_arp.h>\n#include <linux/init.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/semaphore.h>\n#include <linux/refcount.h>\n\n#define SIXPACK_VERSION    \"Revision: 0.3.0\"\n\n \n#define SIXP_SEOF\t\t0x40\t \n#define SIXP_TX_URUN\t\t0x48\t \n#define SIXP_RX_ORUN\t\t0x50\t \n#define SIXP_RX_BUF_OVL\t\t0x58\t \n\n#define SIXP_CHKSUM\t\t0xFF\t \n\n \n\n#define SIXP_CMD_MASK\t\t0xC0\n#define SIXP_CHN_MASK\t\t0x07\n#define SIXP_PRIO_CMD_MASK\t0x80\n#define SIXP_STD_CMD_MASK\t0x40\n#define SIXP_PRIO_DATA_MASK\t0x38\n#define SIXP_TX_MASK\t\t0x20\n#define SIXP_RX_MASK\t\t0x10\n#define SIXP_RX_DCD_MASK\t0x18\n#define SIXP_LEDS_ON\t\t0x78\n#define SIXP_LEDS_OFF\t\t0x60\n#define SIXP_CON\t\t0x08\n#define SIXP_STA\t\t0x10\n\n#define SIXP_FOUND_TNC\t\t0xe9\n#define SIXP_CON_ON\t\t0x68\n#define SIXP_DCD_MASK\t\t0x08\n#define SIXP_DAMA_OFF\t\t0\n\n \n#define SIXP_TXDELAY\t\t\t25\t \n#define SIXP_PERSIST\t\t\t50\t \n#define SIXP_SLOTTIME\t\t\t10\t \n#define SIXP_INIT_RESYNC_TIMEOUT\t(3*HZ/2)  \n#define SIXP_RESYNC_TIMEOUT\t\t5*HZ\t \n\n \n#define SIXP_NRUNIT\t\t\t31       \n#define SIXP_MTU\t\t\t256\t \n\nenum sixpack_flags {\n\tSIXPF_ERROR,\t \n};\n\nstruct sixpack {\n\t \n\tstruct tty_struct\t*tty;\t\t \n\tstruct net_device\t*dev;\t\t \n\n\t \n\tunsigned char\t\t*rbuff;\t\t \n\tint\t\t\trcount;          \n\tunsigned char\t\t*xbuff;\t\t \n\tunsigned char\t\t*xhead;          \n\tint\t\t\txleft;           \n\n\tunsigned char\t\traw_buf[4];\n\tunsigned char\t\tcooked_buf[400];\n\n\tunsigned int\t\trx_count;\n\tunsigned int\t\trx_count_cooked;\n\tspinlock_t\t\trxlock;\n\n\tint\t\t\tmtu;\t\t \n\tint\t\t\tbuffsize;        \n\n\tunsigned long\t\tflags;\t\t \n\tunsigned char\t\tmode;\t\t \n\n\t \n\tunsigned char\t\ttx_delay;\n\tunsigned char\t\tpersistence;\n\tunsigned char\t\tslottime;\n\tunsigned char\t\tduplex;\n\tunsigned char\t\tled_state;\n\tunsigned char\t\tstatus;\n\tunsigned char\t\tstatus1;\n\tunsigned char\t\tstatus2;\n\tunsigned char\t\ttx_enable;\n\tunsigned char\t\ttnc_state;\n\n\tstruct timer_list\ttx_t;\n\tstruct timer_list\tresync_t;\n\trefcount_t\t\trefcnt;\n\tstruct completion\tdead;\n\tspinlock_t\t\tlock;\n};\n\n#define AX25_6PACK_HEADER_LEN 0\n\nstatic void sixpack_decode(struct sixpack *, const unsigned char[], int);\nstatic int encode_sixpack(unsigned char *, unsigned char *, int, unsigned char);\n\n \n\nstatic void sp_xmit_on_air(struct timer_list *t)\n{\n\tstruct sixpack *sp = from_timer(sp, t, tx_t);\n\tint actual, when = sp->slottime;\n\tstatic unsigned char random;\n\n\trandom = random * 17 + 41;\n\n\tif (((sp->status1 & SIXP_DCD_MASK) == 0) && (random < sp->persistence)) {\n\t\tsp->led_state = 0x70;\n\t\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\t\tsp->tx_enable = 1;\n\t\tactual = sp->tty->ops->write(sp->tty, sp->xbuff, sp->status2);\n\t\tsp->xleft -= actual;\n\t\tsp->xhead += actual;\n\t\tsp->led_state = 0x60;\n\t\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\t\tsp->status2 = 0;\n\t} else\n\t\tmod_timer(&sp->tx_t, jiffies + ((when + 1) * HZ) / 100);\n}\n\n \n\n \nstatic void sp_encaps(struct sixpack *sp, unsigned char *icp, int len)\n{\n\tunsigned char *msg, *p = icp;\n\tint actual, count;\n\n\tif (len > sp->mtu) {\t \n\t\tmsg = \"oversized transmit packet!\";\n\t\tgoto out_drop;\n\t}\n\n\tif (p[0] > 5) {\n\t\tmsg = \"invalid KISS command\";\n\t\tgoto out_drop;\n\t}\n\n\tif ((p[0] != 0) && (len > 2)) {\n\t\tmsg = \"KISS control packet too long\";\n\t\tgoto out_drop;\n\t}\n\n\tif ((p[0] == 0) && (len < 15)) {\n\t\tmsg = \"bad AX.25 packet to transmit\";\n\t\tgoto out_drop;\n\t}\n\n\tcount = encode_sixpack(p, sp->xbuff, len, sp->tx_delay);\n\tset_bit(TTY_DO_WRITE_WAKEUP, &sp->tty->flags);\n\n\tswitch (p[0]) {\n\tcase 1:\tsp->tx_delay = p[1];\n\t\treturn;\n\tcase 2:\tsp->persistence = p[1];\n\t\treturn;\n\tcase 3:\tsp->slottime = p[1];\n\t\treturn;\n\tcase 4:\t \n\t\treturn;\n\tcase 5:\tsp->duplex = p[1];\n\t\treturn;\n\t}\n\n\tif (p[0] != 0)\n\t\treturn;\n\n\t \n\tif (sp->duplex == 1) {\n\t\tsp->led_state = 0x70;\n\t\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\t\tsp->tx_enable = 1;\n\t\tactual = sp->tty->ops->write(sp->tty, sp->xbuff, count);\n\t\tsp->xleft = count - actual;\n\t\tsp->xhead = sp->xbuff + actual;\n\t\tsp->led_state = 0x60;\n\t\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\t} else {\n\t\tsp->xleft = count;\n\t\tsp->xhead = sp->xbuff;\n\t\tsp->status2 = count;\n\t\tsp_xmit_on_air(&sp->tx_t);\n\t}\n\n\treturn;\n\nout_drop:\n\tsp->dev->stats.tx_dropped++;\n\tnetif_start_queue(sp->dev);\n\tif (net_ratelimit())\n\t\tprintk(KERN_DEBUG \"%s: %s - dropped.\\n\", sp->dev->name, msg);\n}\n\n \n\nstatic netdev_tx_t sp_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct sixpack *sp = netdev_priv(dev);\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn ax25_ip_xmit(skb);\n\n\tspin_lock_bh(&sp->lock);\n\t \n\tnetif_stop_queue(dev);\n\tdev->stats.tx_bytes += skb->len;\n\tsp_encaps(sp, skb->data, skb->len);\n\tspin_unlock_bh(&sp->lock);\n\n\tdev_kfree_skb(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int sp_open_dev(struct net_device *dev)\n{\n\tstruct sixpack *sp = netdev_priv(dev);\n\n\tif (sp->tty == NULL)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\n \nstatic int sp_close(struct net_device *dev)\n{\n\tstruct sixpack *sp = netdev_priv(dev);\n\n\tspin_lock_bh(&sp->lock);\n\tif (sp->tty) {\n\t\t \n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &sp->tty->flags);\n\t}\n\tnetif_stop_queue(dev);\n\tspin_unlock_bh(&sp->lock);\n\n\treturn 0;\n}\n\nstatic int sp_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct sockaddr_ax25 *sa = addr;\n\n\tnetif_tx_lock_bh(dev);\n\tnetif_addr_lock(dev);\n\t__dev_addr_set(dev, &sa->sax25_call, AX25_ADDR_LEN);\n\tnetif_addr_unlock(dev);\n\tnetif_tx_unlock_bh(dev);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops sp_netdev_ops = {\n\t.ndo_open\t\t= sp_open_dev,\n\t.ndo_stop\t\t= sp_close,\n\t.ndo_start_xmit\t\t= sp_xmit,\n\t.ndo_set_mac_address    = sp_set_mac_address,\n};\n\nstatic void sp_setup(struct net_device *dev)\n{\n\t \n\tdev->netdev_ops\t\t= &sp_netdev_ops;\n\tdev->mtu\t\t= SIXP_MTU;\n\tdev->hard_header_len\t= AX25_MAX_HEADER_LEN;\n\tdev->header_ops \t= &ax25_header_ops;\n\n\tdev->addr_len\t\t= AX25_ADDR_LEN;\n\tdev->type\t\t= ARPHRD_AX25;\n\tdev->tx_queue_len\t= 10;\n\n\t \n\tmemcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);\n\tdev_addr_set(dev, (u8 *)&ax25_defaddr);\n\n\tdev->flags\t\t= 0;\n}\n\n \n\n \n\nstatic void sp_bump(struct sixpack *sp, char cmd)\n{\n\tstruct sk_buff *skb;\n\tint count;\n\tunsigned char *ptr;\n\n\tcount = sp->rcount + 1;\n\n\tsp->dev->stats.rx_bytes += count;\n\n\tif ((skb = dev_alloc_skb(count + 1)) == NULL)\n\t\tgoto out_mem;\n\n\tptr = skb_put(skb, count + 1);\n\t*ptr++ = cmd;\t \n\n\tmemcpy(ptr, sp->cooked_buf + 1, count);\n\tskb->protocol = ax25_type_trans(skb, sp->dev);\n\tnetif_rx(skb);\n\tsp->dev->stats.rx_packets++;\n\n\treturn;\n\nout_mem:\n\tsp->dev->stats.rx_dropped++;\n}\n\n\n \n\n \nstatic DEFINE_RWLOCK(disc_data_lock);\n                                                                                \nstatic struct sixpack *sp_get(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\n\tread_lock(&disc_data_lock);\n\tsp = tty->disc_data;\n\tif (sp)\n\t\trefcount_inc(&sp->refcnt);\n\tread_unlock(&disc_data_lock);\n\n\treturn sp;\n}\n\nstatic void sp_put(struct sixpack *sp)\n{\n\tif (refcount_dec_and_test(&sp->refcnt))\n\t\tcomplete(&sp->dead);\n}\n\n \nstatic void sixpack_write_wakeup(struct tty_struct *tty)\n{\n\tstruct sixpack *sp = sp_get(tty);\n\tint actual;\n\n\tif (!sp)\n\t\treturn;\n\tif (sp->xleft <= 0)  {\n\t\t \n\t\tsp->dev->stats.tx_packets++;\n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\t\tsp->tx_enable = 0;\n\t\tnetif_wake_queue(sp->dev);\n\t\tgoto out;\n\t}\n\n\tif (sp->tx_enable) {\n\t\tactual = tty->ops->write(tty, sp->xhead, sp->xleft);\n\t\tsp->xleft -= actual;\n\t\tsp->xhead += actual;\n\t}\n\nout:\n\tsp_put(sp);\n}\n\n \n\n \nstatic void sixpack_receive_buf(struct tty_struct *tty, const u8 *cp,\n\t\t\t\tconst u8 *fp, size_t count)\n{\n\tstruct sixpack *sp;\n\tint count1;\n\n\tif (!count)\n\t\treturn;\n\n\tsp = sp_get(tty);\n\tif (!sp)\n\t\treturn;\n\n\t \n\tcount1 = count;\n\twhile (count) {\n\t\tcount--;\n\t\tif (fp && *fp++) {\n\t\t\tif (!test_and_set_bit(SIXPF_ERROR, &sp->flags))\n\t\t\t\tsp->dev->stats.rx_errors++;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tsixpack_decode(sp, cp, count1);\n\n\tsp_put(sp);\n\ttty_unthrottle(tty);\n}\n\n \n\n#define TNC_UNINITIALIZED\t0\n#define TNC_UNSYNC_STARTUP\t1\n#define TNC_UNSYNCED\t\t2\n#define TNC_IN_SYNC\t\t3\n\nstatic void __tnc_set_sync_state(struct sixpack *sp, int new_tnc_state)\n{\n\tchar *msg;\n\n\tswitch (new_tnc_state) {\n\tdefault:\t\t\t \n\tcase TNC_UNSYNC_STARTUP:\n\t\tmsg = \"Synchronizing with TNC\";\n\t\tbreak;\n\tcase TNC_UNSYNCED:\n\t\tmsg = \"Lost synchronization with TNC\\n\";\n\t\tbreak;\n\tcase TNC_IN_SYNC:\n\t\tmsg = \"Found TNC\";\n\t\tbreak;\n\t}\n\n\tsp->tnc_state = new_tnc_state;\n\tprintk(KERN_INFO \"%s: %s\\n\", sp->dev->name, msg);\n}\n\nstatic inline void tnc_set_sync_state(struct sixpack *sp, int new_tnc_state)\n{\n\tint old_tnc_state = sp->tnc_state;\n\n\tif (old_tnc_state != new_tnc_state)\n\t\t__tnc_set_sync_state(sp, new_tnc_state);\n}\n\nstatic void resync_tnc(struct timer_list *t)\n{\n\tstruct sixpack *sp = from_timer(sp, t, resync_t);\n\tstatic char resync_cmd = 0xe8;\n\n\t \n\n\tsp->rx_count = 0;\n\tsp->rx_count_cooked = 0;\n\n\t \n\n\tsp->status = 1;\n\tsp->status1 = 1;\n\tsp->status2 = 0;\n\n\t \n\n\tsp->led_state = 0x60;\n\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\tsp->tty->ops->write(sp->tty, &resync_cmd, 1);\n\n\n\t \n\tmod_timer(&sp->resync_t, jiffies + SIXP_RESYNC_TIMEOUT);\n}\n\nstatic inline int tnc_init(struct sixpack *sp)\n{\n\tunsigned char inbyte = 0xe8;\n\n\ttnc_set_sync_state(sp, TNC_UNSYNC_STARTUP);\n\n\tsp->tty->ops->write(sp->tty, &inbyte, 1);\n\n\tmod_timer(&sp->resync_t, jiffies + SIXP_RESYNC_TIMEOUT);\n\n\treturn 0;\n}\n\n \nstatic int sixpack_open(struct tty_struct *tty)\n{\n\tchar *rbuff = NULL, *xbuff = NULL;\n\tstruct net_device *dev;\n\tstruct sixpack *sp;\n\tunsigned long len;\n\tint err = 0;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif (tty->ops->write == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tdev = alloc_netdev(sizeof(struct sixpack), \"sp%d\", NET_NAME_UNKNOWN,\n\t\t\t   sp_setup);\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsp = netdev_priv(dev);\n\tsp->dev = dev;\n\n\tspin_lock_init(&sp->lock);\n\tspin_lock_init(&sp->rxlock);\n\trefcount_set(&sp->refcnt, 1);\n\tinit_completion(&sp->dead);\n\n\t \n\n\tlen = dev->mtu * 2;\n\n\trbuff = kmalloc(len + 4, GFP_KERNEL);\n\txbuff = kmalloc(len + 4, GFP_KERNEL);\n\n\tif (rbuff == NULL || xbuff == NULL) {\n\t\terr = -ENOBUFS;\n\t\tgoto out_free;\n\t}\n\n\tspin_lock_bh(&sp->lock);\n\n\tsp->tty = tty;\n\n\tsp->rbuff\t= rbuff;\n\tsp->xbuff\t= xbuff;\n\n\tsp->mtu\t\t= AX25_MTU + 73;\n\tsp->buffsize\t= len;\n\tsp->rcount\t= 0;\n\tsp->rx_count\t= 0;\n\tsp->rx_count_cooked = 0;\n\tsp->xleft\t= 0;\n\n\tsp->flags\t= 0;\t\t \n\n\tsp->duplex\t= 0;\n\tsp->tx_delay    = SIXP_TXDELAY;\n\tsp->persistence = SIXP_PERSIST;\n\tsp->slottime    = SIXP_SLOTTIME;\n\tsp->led_state   = 0x60;\n\tsp->status      = 1;\n\tsp->status1     = 1;\n\tsp->status2     = 0;\n\tsp->tx_enable   = 0;\n\n\tnetif_start_queue(dev);\n\n\ttimer_setup(&sp->tx_t, sp_xmit_on_air, 0);\n\n\ttimer_setup(&sp->resync_t, resync_tnc, 0);\n\n\tspin_unlock_bh(&sp->lock);\n\n\t \n\ttty->disc_data = sp;\n\ttty->receive_room = 65536;\n\n\t \n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto out_free;\n\n\ttnc_init(sp);\n\n\treturn 0;\n\nout_free:\n\tkfree(xbuff);\n\tkfree(rbuff);\n\n\tfree_netdev(dev);\n\nout:\n\treturn err;\n}\n\n\n \nstatic void sixpack_close(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\n\twrite_lock_irq(&disc_data_lock);\n\tsp = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!sp)\n\t\treturn;\n\n\t \n\tif (!refcount_dec_and_test(&sp->refcnt))\n\t\twait_for_completion(&sp->dead);\n\n\t \n\tnetif_stop_queue(sp->dev);\n\n\tunregister_netdev(sp->dev);\n\n\tdel_timer_sync(&sp->tx_t);\n\tdel_timer_sync(&sp->resync_t);\n\n\t \n\tkfree(sp->rbuff);\n\tkfree(sp->xbuff);\n\n\tfree_netdev(sp->dev);\n}\n\n \nstatic int sixpack_ioctl(struct tty_struct *tty, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tstruct sixpack *sp = sp_get(tty);\n\tstruct net_device *dev;\n\tunsigned int tmp, err;\n\n\tif (!sp)\n\t\treturn -ENXIO;\n\tdev = sp->dev;\n\n\tswitch(cmd) {\n\tcase SIOCGIFNAME:\n\t\terr = copy_to_user((void __user *) arg, dev->name,\n\t\t                   strlen(dev->name) + 1) ? -EFAULT : 0;\n\t\tbreak;\n\n\tcase SIOCGIFENCAP:\n\t\terr = put_user(0, (int __user *) arg);\n\t\tbreak;\n\n\tcase SIOCSIFENCAP:\n\t\tif (get_user(tmp, (int __user *) arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tsp->mode = tmp;\n\t\tdev->addr_len        = AX25_ADDR_LEN;\n\t\tdev->hard_header_len = AX25_KISS_HEADER_LEN +\n\t\t                       AX25_MAX_HEADER_LEN + 3;\n\t\tdev->type            = ARPHRD_AX25;\n\n\t\terr = 0;\n\t\tbreak;\n\n\tcase SIOCSIFHWADDR: {\n\t\t\tchar addr[AX25_ADDR_LEN];\n\n\t\t\tif (copy_from_user(&addr,\n\t\t\t\t\t   (void __user *)arg, AX25_ADDR_LEN)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnetif_tx_lock_bh(dev);\n\t\t\t__dev_addr_set(dev, &addr, AX25_ADDR_LEN);\n\t\t\tnetif_tx_unlock_bh(dev);\n\t\t\terr = 0;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\terr = tty_mode_ioctl(tty, cmd, arg);\n\t}\n\n\tsp_put(sp);\n\n\treturn err;\n}\n\nstatic struct tty_ldisc_ops sp_ldisc = {\n\t.owner\t\t= THIS_MODULE,\n\t.num\t\t= N_6PACK,\n\t.name\t\t= \"6pack\",\n\t.open\t\t= sixpack_open,\n\t.close\t\t= sixpack_close,\n\t.ioctl\t\t= sixpack_ioctl,\n\t.receive_buf\t= sixpack_receive_buf,\n\t.write_wakeup\t= sixpack_write_wakeup,\n};\n\n \n\nstatic const char msg_banner[]  __initconst = KERN_INFO \\\n\t\"AX.25: 6pack driver, \" SIXPACK_VERSION \"\\n\";\nstatic const char msg_regfail[] __initconst = KERN_ERR  \\\n\t\"6pack: can't register line discipline (err = %d)\\n\";\n\nstatic int __init sixpack_init_driver(void)\n{\n\tint status;\n\n\tprintk(msg_banner);\n\n\t \n\tstatus = tty_register_ldisc(&sp_ldisc);\n\tif (status)\n\t\tprintk(msg_regfail, status);\n\n\treturn status;\n}\n\nstatic void __exit sixpack_exit_driver(void)\n{\n\ttty_unregister_ldisc(&sp_ldisc);\n}\n\n \n\nstatic int encode_sixpack(unsigned char *tx_buf, unsigned char *tx_buf_raw,\n\tint length, unsigned char tx_delay)\n{\n\tint count = 0;\n\tunsigned char checksum = 0, buf[400];\n\tint raw_count = 0;\n\n\ttx_buf_raw[raw_count++] = SIXP_PRIO_CMD_MASK | SIXP_TX_MASK;\n\ttx_buf_raw[raw_count++] = SIXP_SEOF;\n\n\tbuf[0] = tx_delay;\n\tfor (count = 1; count < length; count++)\n\t\tbuf[count] = tx_buf[count];\n\n\tfor (count = 0; count < length; count++)\n\t\tchecksum += buf[count];\n\tbuf[length] = (unsigned char) 0xff - checksum;\n\n\tfor (count = 0; count <= length; count++) {\n\t\tif ((count % 3) == 0) {\n\t\t\ttx_buf_raw[raw_count++] = (buf[count] & 0x3f);\n\t\t\ttx_buf_raw[raw_count] = ((buf[count] >> 2) & 0x30);\n\t\t} else if ((count % 3) == 1) {\n\t\t\ttx_buf_raw[raw_count++] |= (buf[count] & 0x0f);\n\t\t\ttx_buf_raw[raw_count] =\t((buf[count] >> 2) & 0x3c);\n\t\t} else {\n\t\t\ttx_buf_raw[raw_count++] |= (buf[count] & 0x03);\n\t\t\ttx_buf_raw[raw_count++] = (buf[count] >> 2);\n\t\t}\n\t}\n\tif ((length % 3) != 2)\n\t\traw_count++;\n\ttx_buf_raw[raw_count++] = SIXP_SEOF;\n\treturn raw_count;\n}\n\n \n\nstatic void decode_data(struct sixpack *sp, unsigned char inbyte)\n{\n\tunsigned char *buf;\n\n\tif (sp->rx_count != 3) {\n\t\tsp->raw_buf[sp->rx_count++] = inbyte;\n\n\t\treturn;\n\t}\n\n\tif (sp->rx_count_cooked + 2 >= sizeof(sp->cooked_buf)) {\n\t\tpr_err(\"6pack: cooked buffer overrun, data loss\\n\");\n\t\tsp->rx_count = 0;\n\t\treturn;\n\t}\n\n\tbuf = sp->raw_buf;\n\tsp->cooked_buf[sp->rx_count_cooked++] =\n\t\tbuf[0] | ((buf[1] << 2) & 0xc0);\n\tsp->cooked_buf[sp->rx_count_cooked++] =\n\t\t(buf[1] & 0x0f) | ((buf[2] << 2) & 0xf0);\n\tsp->cooked_buf[sp->rx_count_cooked++] =\n\t\t(buf[2] & 0x03) | (inbyte << 2);\n\tsp->rx_count = 0;\n}\n\n \n\nstatic void decode_prio_command(struct sixpack *sp, unsigned char cmd)\n{\n\tint actual;\n\n\tif ((cmd & SIXP_PRIO_DATA_MASK) != 0) {      \n\n\t \n\n\t\tif (((sp->status & SIXP_DCD_MASK) == 0) &&\n\t\t\t((cmd & SIXP_RX_DCD_MASK) == SIXP_RX_DCD_MASK)) {\n\t\t\t\tif (sp->status != 1)\n\t\t\t\t\tprintk(KERN_DEBUG \"6pack: protocol violation\\n\");\n\t\t\t\telse\n\t\t\t\t\tsp->status = 0;\n\t\t\t\tcmd &= ~SIXP_RX_DCD_MASK;\n\t\t}\n\t\tsp->status = cmd & SIXP_PRIO_DATA_MASK;\n\t} else {  \n\t\tif ((sp->status2 != 0) && (sp->duplex == 1)) {\n\t\t\tsp->led_state = 0x70;\n\t\t\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\t\t\tsp->tx_enable = 1;\n\t\t\tactual = sp->tty->ops->write(sp->tty, sp->xbuff, sp->status2);\n\t\t\tsp->xleft -= actual;\n\t\t\tsp->xhead += actual;\n\t\t\tsp->led_state = 0x60;\n\t\t\tsp->status2 = 0;\n\n\t\t}\n\t}\n\n\t \n\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\n         \n\n\tif (sp->tnc_state == TNC_IN_SYNC)\n\t\tmod_timer(&sp->resync_t, jiffies + SIXP_INIT_RESYNC_TIMEOUT);\n\n\tsp->status1 = cmd & SIXP_PRIO_DATA_MASK;\n}\n\n \n\nstatic void decode_std_command(struct sixpack *sp, unsigned char cmd)\n{\n\tunsigned char checksum = 0, rest = 0;\n\tshort i;\n\n\tswitch (cmd & SIXP_CMD_MASK) {      \n\tcase SIXP_SEOF:\n\t\tif ((sp->rx_count == 0) && (sp->rx_count_cooked == 0)) {\n\t\t\tif ((sp->status & SIXP_RX_DCD_MASK) ==\n\t\t\t\tSIXP_RX_DCD_MASK) {\n\t\t\t\tsp->led_state = 0x68;\n\t\t\t\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\t\t\t}\n\t\t} else {\n\t\t\tsp->led_state = 0x60;\n\t\t\t \n\t\t\tsp->tty->ops->write(sp->tty, &sp->led_state, 1);\n\t\t\tspin_lock_bh(&sp->rxlock);\n\t\t\trest = sp->rx_count;\n\t\t\tif (rest != 0)\n\t\t\t\t for (i = rest; i <= 3; i++)\n\t\t\t\t\tdecode_data(sp, 0);\n\t\t\tif (rest == 2)\n\t\t\t\tsp->rx_count_cooked -= 2;\n\t\t\telse if (rest == 3)\n\t\t\t\tsp->rx_count_cooked -= 1;\n\t\t\tfor (i = 0; i < sp->rx_count_cooked; i++)\n\t\t\t\tchecksum += sp->cooked_buf[i];\n\t\t\tif (checksum != SIXP_CHKSUM) {\n\t\t\t\tprintk(KERN_DEBUG \"6pack: bad checksum %2.2x\\n\", checksum);\n\t\t\t} else {\n\t\t\t\tsp->rcount = sp->rx_count_cooked-2;\n\t\t\t\tsp_bump(sp, 0);\n\t\t\t}\n\t\t\tsp->rx_count_cooked = 0;\n\t\t\tspin_unlock_bh(&sp->rxlock);\n\t\t}\n\t\tbreak;\n\tcase SIXP_TX_URUN: printk(KERN_DEBUG \"6pack: TX underrun\\n\");\n\t\tbreak;\n\tcase SIXP_RX_ORUN: printk(KERN_DEBUG \"6pack: RX overrun\\n\");\n\t\tbreak;\n\tcase SIXP_RX_BUF_OVL:\n\t\tprintk(KERN_DEBUG \"6pack: RX buffer overflow\\n\");\n\t}\n}\n\n \n\nstatic void\nsixpack_decode(struct sixpack *sp, const unsigned char *pre_rbuff, int count)\n{\n\tunsigned char inbyte;\n\tint count1;\n\n\tfor (count1 = 0; count1 < count; count1++) {\n\t\tinbyte = pre_rbuff[count1];\n\t\tif (inbyte == SIXP_FOUND_TNC) {\n\t\t\ttnc_set_sync_state(sp, TNC_IN_SYNC);\n\t\t\tdel_timer(&sp->resync_t);\n\t\t}\n\t\tif ((inbyte & SIXP_PRIO_CMD_MASK) != 0)\n\t\t\tdecode_prio_command(sp, inbyte);\n\t\telse if ((inbyte & SIXP_STD_CMD_MASK) != 0)\n\t\t\tdecode_std_command(sp, inbyte);\n\t\telse if ((sp->status & SIXP_RX_DCD_MASK) == SIXP_RX_DCD_MASK) {\n\t\t\tspin_lock_bh(&sp->rxlock);\n\t\t\tdecode_data(sp, inbyte);\n\t\t\tspin_unlock_bh(&sp->rxlock);\n\t\t}\n\t}\n}\n\nMODULE_AUTHOR(\"Ralf Baechle DO1GRB <ralf@linux-mips.org>\");\nMODULE_DESCRIPTION(\"6pack driver for AX.25\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_LDISC(N_6PACK);\n\nmodule_init(sixpack_init_driver);\nmodule_exit(sixpack_exit_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}