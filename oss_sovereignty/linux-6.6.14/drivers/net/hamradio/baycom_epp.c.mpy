{
  "module_name": "baycom_epp.c",
  "hash_id": "3257f05373ff222fa39cda0e64a8781869ad6285c379c021395bc898f12e739a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/hamradio/baycom_epp.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/crc-ccitt.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/workqueue.h>\n#include <linux/fs.h>\n#include <linux/parport.h>\n#include <linux/if_arp.h>\n#include <linux/hdlcdrv.h>\n#include <linux/baycom.h>\n#include <linux/jiffies.h>\n#include <linux/random.h>\n#include <net/ax25.h> \n#include <linux/uaccess.h>\n\n \n\n#define BAYCOM_DEBUG\n#define BAYCOM_MAGIC 19730510\n\n \n\nstatic const char paranoia_str[] = KERN_ERR \n\t\"baycom_epp: bad magic number for hdlcdrv_state struct in routine %s\\n\";\n\nstatic const char bc_drvname[] = \"baycom_epp\";\nstatic const char bc_drvinfo[] = KERN_INFO \"baycom_epp: (C) 1998-2000 Thomas Sailer, HB9JNX/AE4WA\\n\"\n\"baycom_epp: version 0.7\\n\";\n\n \n\n#define NR_PORTS 4\n\nstatic struct net_device *baycom_device[NR_PORTS];\n\n \n\n \n#define EPP_DCDBIT      0x80\n#define EPP_PTTBIT      0x08\n#define EPP_NREF        0x01\n#define EPP_NRAEF       0x02\n#define EPP_NRHF        0x04\n#define EPP_NTHF        0x20\n#define EPP_NTAEF       0x10\n#define EPP_NTEF        EPP_PTTBIT\n\n \n#define EPP_TX_FIFO_ENABLE 0x10\n#define EPP_RX_FIFO_ENABLE 0x08\n#define EPP_MODEM_ENABLE   0x20\n#define EPP_LEDS           0xC0\n#define EPP_IRQ_ENABLE     0x10\n\n \n#define LPTREG_ECONTROL       0x402\n#define LPTREG_CONFIGB        0x401\n#define LPTREG_CONFIGA        0x400\n#define LPTREG_EPPDATA        0x004\n#define LPTREG_EPPADDR        0x003\n#define LPTREG_CONTROL        0x002\n#define LPTREG_STATUS         0x001\n#define LPTREG_DATA           0x000\n\n \n#define LPTCTRL_PROGRAM       0x04    \n#define LPTCTRL_WRITE         0x01\n#define LPTCTRL_ADDRSTB       0x08\n#define LPTCTRL_DATASTB       0x02\n#define LPTCTRL_INTEN         0x10\n\n \n#define LPTSTAT_SHIFT_NINTR   6\n#define LPTSTAT_WAIT          0x80\n#define LPTSTAT_NINTR         (1<<LPTSTAT_SHIFT_NINTR)\n#define LPTSTAT_PE            0x20\n#define LPTSTAT_DONE          0x10\n#define LPTSTAT_NERROR        0x08\n#define LPTSTAT_EPPTIMEOUT    0x01\n\n \n#define LPTDATA_SHIFT_TDI     0\n#define LPTDATA_SHIFT_TMS     2\n#define LPTDATA_TDI           (1<<LPTDATA_SHIFT_TDI)\n#define LPTDATA_TCK           0x02\n#define LPTDATA_TMS           (1<<LPTDATA_SHIFT_TMS)\n#define LPTDATA_INITBIAS      0x80\n\n\n \n#define EPP_DCDBIT            0x80\n#define EPP_PTTBIT            0x08\n#define EPP_RXEBIT            0x01\n#define EPP_RXAEBIT           0x02\n#define EPP_RXHFULL           0x04\n\n#define EPP_NTHF              0x20\n#define EPP_NTAEF             0x10\n#define EPP_NTEF              EPP_PTTBIT\n\n#define EPP_TX_FIFO_ENABLE    0x10\n#define EPP_RX_FIFO_ENABLE    0x08\n#define EPP_MODEM_ENABLE      0x20\n#define EPP_LEDS              0xC0\n#define EPP_IRQ_ENABLE        0x10\n\n \n#define XC4K_IRLENGTH   3\n#define XC4K_EXTEST     0\n#define XC4K_PRELOAD    1\n#define XC4K_CONFIGURE  5\n#define XC4K_BYPASS     7\n\n#define EPP_CONVENTIONAL  0\n#define EPP_FPGA          1\n#define EPP_FPGAEXTSTATUS 2\n\n#define TXBUFFER_SIZE     ((HDLCDRV_MAXFLEN*6/5)+8)\n\n \n \n\nstruct baycom_state {\n\tint magic;\n\n        struct pardevice *pdev;\n\tstruct net_device *dev;\n\tunsigned int work_running;\n\tstruct delayed_work run_work;\n\tunsigned int modem;\n\tunsigned int bitrate;\n\tunsigned char stat;\n\n\tstruct {\n\t\tunsigned int intclk;\n\t\tunsigned int fclk;\n\t\tunsigned int bps;\n\t\tunsigned int extmodem;\n\t\tunsigned int loopback;\n\t} cfg;\n\n        struct hdlcdrv_channel_params ch_params;\n\n        struct {\n\t\tunsigned int bitbuf, bitstream, numbits, state;\n\t\tunsigned char *bufptr;\n\t\tint bufcnt;\n\t\tunsigned char buf[TXBUFFER_SIZE];\n        } hdlcrx;\n\n        struct {\n\t\tint calibrate;\n                int slotcnt;\n\t\tint flags;\n\t\tenum { tx_idle = 0, tx_keyup, tx_data, tx_tail } state;\n\t\tunsigned char *bufptr;\n\t\tint bufcnt;\n\t\tunsigned char buf[TXBUFFER_SIZE];\n        } hdlctx;\n\n\tunsigned int ptt_keyed;\n\tstruct sk_buff *skb;   \n\n#ifdef BAYCOM_DEBUG\n\tstruct debug_vals {\n\t\tunsigned long last_jiffies;\n\t\tunsigned cur_intcnt;\n\t\tunsigned last_intcnt;\n\t\tint cur_pllcorr;\n\t\tint last_pllcorr;\n\t\tunsigned int mod_cycles;\n\t\tunsigned int demod_cycles;\n\t} debug_vals;\n#endif  \n};\n\n \n\n#define KISS_VERBOSE\n\n \n\n#define PARAM_TXDELAY   1\n#define PARAM_PERSIST   2\n#define PARAM_SLOTTIME  3\n#define PARAM_TXTAIL    4\n#define PARAM_FULLDUP   5\n#define PARAM_HARDWARE  6\n#define PARAM_RETURN    255\n\n \n \n\n\n \n\n#if 0\nstatic inline void append_crc_ccitt(unsigned char *buffer, int len)\n{\n\tunsigned int crc = 0xffff;\n\n\tfor (;len>0;len--)\n\t\tcrc = (crc >> 8) ^ crc_ccitt_table[(crc ^ *buffer++) & 0xff];\n\tcrc ^= 0xffff;\n\t*buffer++ = crc;\n\t*buffer++ = crc >> 8;\n}\n#endif\n\n \n\nstatic inline int check_crc_ccitt(const unsigned char *buf, int cnt)\n{\n\treturn (crc_ccitt(0xffff, buf, cnt) & 0xffff) == 0xf0b8;\n}\n\n \n\nstatic inline int calc_crc_ccitt(const unsigned char *buf, int cnt)\n{\n\treturn (crc_ccitt(0xffff, buf, cnt) ^ 0xffff) & 0xffff;\n}\n\n \n\n#define tenms_to_flags(bc,tenms) ((tenms * bc->bitrate) / 800)\n\n \n\nstatic inline void baycom_int_freq(struct baycom_state *bc)\n{\n#ifdef BAYCOM_DEBUG\n\tunsigned long cur_jiffies = jiffies;\n\t \n\tbc->debug_vals.cur_intcnt++;\n\tif (time_after_eq(cur_jiffies, bc->debug_vals.last_jiffies + HZ)) {\n\t\tbc->debug_vals.last_jiffies = cur_jiffies;\n\t\tbc->debug_vals.last_intcnt = bc->debug_vals.cur_intcnt;\n\t\tbc->debug_vals.cur_intcnt = 0;\n\t\tbc->debug_vals.last_pllcorr = bc->debug_vals.cur_pllcorr;\n\t\tbc->debug_vals.cur_pllcorr = 0;\n\t}\n#endif  \n}\n\n \n \n\nstatic char const eppconfig_path[] = \"/usr/sbin/eppfpga\";\n\nstatic char *envp[] = { \"HOME=/\", \"TERM=linux\", \"PATH=/usr/bin:/bin\", NULL };\n\n \nstatic int eppconfig(struct baycom_state *bc)\n{\n\tchar modearg[256];\n\tchar portarg[16];\n        char *argv[] = {\n\t\t(char *)eppconfig_path,\n\t\t\"-s\",\n\t\t\"-p\", portarg,\n\t\t\"-m\", modearg,\n\t\tNULL };\n\n\t \n\tsprintf(modearg, \"%sclk,%smodem,fclk=%d,bps=%d,divider=%d%s,extstat\",\n\t\tbc->cfg.intclk ? \"int\" : \"ext\",\n\t\tbc->cfg.extmodem ? \"ext\" : \"int\", bc->cfg.fclk, bc->cfg.bps,\n\t\t(bc->cfg.fclk + 8 * bc->cfg.bps) / (16 * bc->cfg.bps),\n\t\tbc->cfg.loopback ? \",loopback\" : \"\");\n\tsprintf(portarg, \"%ld\", bc->pdev->port->base);\n\tprintk(KERN_DEBUG \"%s: %s -s -p %s -m %s\\n\", bc_drvname, eppconfig_path, portarg, modearg);\n\n\treturn call_usermodehelper(eppconfig_path, argv, envp, UMH_WAIT_PROC);\n}\n\n \n\nstatic inline void do_kiss_params(struct baycom_state *bc,\n\t\t\t\t  unsigned char *data, unsigned long len)\n{\n\n#ifdef KISS_VERBOSE\n#define PKP(a,b) printk(KERN_INFO \"baycomm_epp: channel params: \" a \"\\n\", b)\n#else  \t      \n#define PKP(a,b) \n#endif  \t      \n\n\tif (len < 2)\n\t\treturn;\n\tswitch(data[0]) {\n\tcase PARAM_TXDELAY:\n\t\tbc->ch_params.tx_delay = data[1];\n\t\tPKP(\"TX delay = %ums\", 10 * bc->ch_params.tx_delay);\n\t\tbreak;\n\tcase PARAM_PERSIST:   \n\t\tbc->ch_params.ppersist = data[1];\n\t\tPKP(\"p persistence = %u\", bc->ch_params.ppersist);\n\t\tbreak;\n\tcase PARAM_SLOTTIME:  \n\t\tbc->ch_params.slottime = data[1];\n\t\tPKP(\"slot time = %ums\", bc->ch_params.slottime);\n\t\tbreak;\n\tcase PARAM_TXTAIL:    \n\t\tbc->ch_params.tx_tail = data[1];\n\t\tPKP(\"TX tail = %ums\", bc->ch_params.tx_tail);\n\t\tbreak;\n\tcase PARAM_FULLDUP:   \n\t\tbc->ch_params.fulldup = !!data[1];\n\t\tPKP(\"%s duplex\", bc->ch_params.fulldup ? \"full\" : \"half\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n#undef PKP\n}\n\n \n\nstatic void encode_hdlc(struct baycom_state *bc)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *wp, *bp;\n\tint pkt_len;\n        unsigned bitstream, notbitstream, bitbuf, numbit, crc;\n\tunsigned char crcarr[2];\n\tint j;\n\t\n\tif (bc->hdlctx.bufcnt > 0)\n\t\treturn;\n\tskb = bc->skb;\n\tif (!skb)\n\t\treturn;\n\tbc->skb = NULL;\n\tpkt_len = skb->len-1;  \n\twp = bc->hdlctx.buf;\n\tbp = skb->data+1;\n\tcrc = calc_crc_ccitt(bp, pkt_len);\n\tcrcarr[0] = crc;\n\tcrcarr[1] = crc >> 8;\n\t*wp++ = 0x7e;\n\tbitstream = bitbuf = numbit = 0;\n\twhile (pkt_len > -2) {\n\t\tbitstream >>= 8;\n\t\tbitstream |= ((unsigned int)*bp) << 8;\n\t\tbitbuf |= ((unsigned int)*bp) << numbit;\n\t\tnotbitstream = ~bitstream;\n\t\tbp++;\n\t\tpkt_len--;\n\t\tif (!pkt_len)\n\t\t\tbp = crcarr;\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tif (unlikely(!(notbitstream & (0x1f0 << j)))) {\n\t\t\t\tbitstream &= ~(0x100 << j);\n\t\t\t\tbitbuf = (bitbuf & (((2 << j) << numbit) - 1)) |\n\t\t\t\t\t((bitbuf & ~(((2 << j) << numbit) - 1)) << 1);\n\t\t\t\tnumbit++;\n\t\t\t\tnotbitstream = ~bitstream;\n\t\t\t}\n\t\tnumbit += 8;\n\t\twhile (numbit >= 8) {\n\t\t\t*wp++ = bitbuf;\n\t\t\tbitbuf >>= 8;\n\t\t\tnumbit -= 8;\n\t\t}\n\t}\n\tbitbuf |= 0x7e7e << numbit;\n\tnumbit += 16;\n\twhile (numbit >= 8) {\n\t\t*wp++ = bitbuf;\n\t\tbitbuf >>= 8;\n\t\tnumbit -= 8;\n\t}\n\tbc->hdlctx.bufptr = bc->hdlctx.buf;\n\tbc->hdlctx.bufcnt = wp - bc->hdlctx.buf;\n\tdev_kfree_skb(skb);\n\tbc->dev->stats.tx_packets++;\n}\n\n \n\nstatic int transmit(struct baycom_state *bc, int cnt, unsigned char stat)\n{\n\tstruct parport *pp = bc->pdev->port;\n\tunsigned char tmp[128];\n\tint i, j;\n\n\tif (bc->hdlctx.state == tx_tail && !(stat & EPP_PTTBIT))\n\t\tbc->hdlctx.state = tx_idle;\n\tif (bc->hdlctx.state == tx_idle && bc->hdlctx.calibrate <= 0) {\n\t\tif (bc->hdlctx.bufcnt <= 0)\n\t\t\tencode_hdlc(bc);\n\t\tif (bc->hdlctx.bufcnt <= 0)\n\t\t\treturn 0;\n\t\tif (!bc->ch_params.fulldup) {\n\t\t\tif (!(stat & EPP_DCDBIT)) {\n\t\t\t\tbc->hdlctx.slotcnt = bc->ch_params.slottime;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif ((--bc->hdlctx.slotcnt) > 0)\n\t\t\t\treturn 0;\n\t\t\tbc->hdlctx.slotcnt = bc->ch_params.slottime;\n\t\t\tif (get_random_u8() > bc->ch_params.ppersist)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\tif (bc->hdlctx.state == tx_idle && bc->hdlctx.bufcnt > 0) {\n\t\tbc->hdlctx.state = tx_keyup;\n\t\tbc->hdlctx.flags = tenms_to_flags(bc, bc->ch_params.tx_delay);\n\t\tbc->ptt_keyed++;\n\t}\n\twhile (cnt > 0) {\n\t\tswitch (bc->hdlctx.state) {\n\t\tcase tx_keyup:\n\t\t\ti = min_t(int, cnt, bc->hdlctx.flags);\n\t\t\tcnt -= i;\n\t\t\tbc->hdlctx.flags -= i;\n\t\t\tif (bc->hdlctx.flags <= 0)\n\t\t\t\tbc->hdlctx.state = tx_data;\n\t\t\tmemset(tmp, 0x7e, sizeof(tmp));\n\t\t\twhile (i > 0) {\n\t\t\t\tj = (i > sizeof(tmp)) ? sizeof(tmp) : i;\n\t\t\t\tif (j != pp->ops->epp_write_data(pp, tmp, j, 0))\n\t\t\t\t\treturn -1;\n\t\t\t\ti -= j;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase tx_data:\n\t\t\tif (bc->hdlctx.bufcnt <= 0) {\n\t\t\t\tencode_hdlc(bc);\n\t\t\t\tif (bc->hdlctx.bufcnt <= 0) {\n\t\t\t\t\tbc->hdlctx.state = tx_tail;\n\t\t\t\t\tbc->hdlctx.flags = tenms_to_flags(bc, bc->ch_params.tx_tail);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti = min_t(int, cnt, bc->hdlctx.bufcnt);\n\t\t\tbc->hdlctx.bufcnt -= i;\n\t\t\tcnt -= i;\n\t\t\tif (i != pp->ops->epp_write_data(pp, bc->hdlctx.bufptr, i, 0))\n\t\t\t\t\treturn -1;\n\t\t\tbc->hdlctx.bufptr += i;\n\t\t\tbreak;\n\t\t\t\n\t\tcase tx_tail:\n\t\t\tencode_hdlc(bc);\n\t\t\tif (bc->hdlctx.bufcnt > 0) {\n\t\t\t\tbc->hdlctx.state = tx_data;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti = min_t(int, cnt, bc->hdlctx.flags);\n\t\t\tif (i) {\n\t\t\t\tcnt -= i;\n\t\t\t\tbc->hdlctx.flags -= i;\n\t\t\t\tmemset(tmp, 0x7e, sizeof(tmp));\n\t\t\t\twhile (i > 0) {\n\t\t\t\t\tj = (i > sizeof(tmp)) ? sizeof(tmp) : i;\n\t\t\t\t\tif (j != pp->ops->epp_write_data(pp, tmp, j, 0))\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\ti -= j;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\n\t\tdefault:\n\t\t\tif (bc->hdlctx.calibrate <= 0)\n\t\t\t\treturn 0;\n\t\t\ti = min_t(int, cnt, bc->hdlctx.calibrate);\n\t\t\tcnt -= i;\n\t\t\tbc->hdlctx.calibrate -= i;\n\t\t\tmemset(tmp, 0, sizeof(tmp));\n\t\t\twhile (i > 0) {\n\t\t\t\tj = (i > sizeof(tmp)) ? sizeof(tmp) : i;\n\t\t\t\tif (j != pp->ops->epp_write_data(pp, tmp, j, 0))\n\t\t\t\t\treturn -1;\n\t\t\t\ti -= j;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n\nstatic void do_rxpacket(struct net_device *dev)\n{\n\tstruct baycom_state *bc = netdev_priv(dev);\n\tstruct sk_buff *skb;\n\tunsigned char *cp;\n\tunsigned pktlen;\n\n\tif (bc->hdlcrx.bufcnt < 4) \n\t\treturn;\n\tif (!check_crc_ccitt(bc->hdlcrx.buf, bc->hdlcrx.bufcnt)) \n\t\treturn;\n\tpktlen = bc->hdlcrx.bufcnt-2+1;  \n\tif (!(skb = dev_alloc_skb(pktlen))) {\n\t\tprintk(\"%s: memory squeeze, dropping packet\\n\", dev->name);\n\t\tdev->stats.rx_dropped++;\n\t\treturn;\n\t}\n\tcp = skb_put(skb, pktlen);\n\t*cp++ = 0;  \n\tmemcpy(cp, bc->hdlcrx.buf, pktlen - 1);\n\tskb->protocol = ax25_type_trans(skb, dev);\n\tnetif_rx(skb);\n\tdev->stats.rx_packets++;\n}\n\nstatic int receive(struct net_device *dev, int cnt)\n{\n\tstruct baycom_state *bc = netdev_priv(dev);\n\tstruct parport *pp = bc->pdev->port;\n        unsigned int bitbuf, notbitstream, bitstream, numbits, state;\n\tunsigned char tmp[128];\n        unsigned char *cp;\n\tint cnt2, ret = 0;\n\tint j;\n        \n        numbits = bc->hdlcrx.numbits;\n\tstate = bc->hdlcrx.state;\n\tbitstream = bc->hdlcrx.bitstream;\n\tbitbuf = bc->hdlcrx.bitbuf;\n\twhile (cnt > 0) {\n\t\tcnt2 = (cnt > sizeof(tmp)) ? sizeof(tmp) : cnt;\n\t\tcnt -= cnt2;\n\t\tif (cnt2 != pp->ops->epp_read_data(pp, tmp, cnt2, 0)) {\n\t\t\tret = -1;\n\t\t\tbreak;\n\t\t}\n\t\tcp = tmp;\n\t\tfor (; cnt2 > 0; cnt2--, cp++) {\n\t\t\tbitstream >>= 8;\n\t\t\tbitstream |= (*cp) << 8;\n\t\t\tbitbuf >>= 8;\n\t\t\tbitbuf |= (*cp) << 8;\n\t\t\tnumbits += 8;\n\t\t\tnotbitstream = ~bitstream;\n\t\t\tfor (j = 0; j < 8; j++) {\n\n\t\t\t\t \n\t\t\t        if (unlikely(!(notbitstream & (0x0fc << j)))) {\n\n\t\t\t\t\t \n\t\t\t\t\tif (!(notbitstream & (0x1fc << j)))\n\t\t\t\t\t\tstate = 0;\n\n\t\t\t\t\t \n\t\t\t\t\telse if ((bitstream & (0x1fe << j)) == (0x0fc << j)) {\n\t\t\t\t\t\tif (state)\n\t\t\t\t\t\t\tdo_rxpacket(dev);\n\t\t\t\t\t\tbc->hdlcrx.bufcnt = 0;\n\t\t\t\t\t\tbc->hdlcrx.bufptr = bc->hdlcrx.buf;\n\t\t\t\t\t\tstate = 1;\n\t\t\t\t\t\tnumbits = 7-j;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\telse if (unlikely((bitstream & (0x1f8 << j)) == (0xf8 << j))) {\n\t\t\t\t\tnumbits--;\n\t\t\t\t\tbitbuf = (bitbuf & ((~0xff) << j)) | ((bitbuf & ~((~0xff) << j)) << 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\twhile (state && numbits >= 8) {\n\t\t\t\tif (bc->hdlcrx.bufcnt >= TXBUFFER_SIZE) {\n\t\t\t\t\tstate = 0;\n\t\t\t\t} else {\n\t\t\t\t\t*(bc->hdlcrx.bufptr)++ = bitbuf >> (16-numbits);\n\t\t\t\t\tbc->hdlcrx.bufcnt++;\n\t\t\t\t\tnumbits -= 8;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n        bc->hdlcrx.numbits = numbits;\n\tbc->hdlcrx.state = state;\n\tbc->hdlcrx.bitstream = bitstream;\n\tbc->hdlcrx.bitbuf = bitbuf;\n\treturn ret;\n}\n\n \n\n#define GETTICK(x)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\\\n\tx = (unsigned int)get_cycles();\t\t\t\t\\\n})\n\nstatic void epp_bh(struct work_struct *work)\n{\n\tstruct net_device *dev;\n\tstruct baycom_state *bc;\n\tstruct parport *pp;\n\tunsigned char stat;\n\tunsigned char tmp[2];\n\tunsigned int time1 = 0, time2 = 0, time3 = 0;\n\tint cnt, cnt2;\n\n\tbc = container_of(work, struct baycom_state, run_work.work);\n\tdev = bc->dev;\n\tif (!bc->work_running)\n\t\treturn;\n\tbaycom_int_freq(bc);\n\tpp = bc->pdev->port;\n\t \n\tif (pp->ops->epp_read_addr(pp, &stat, 1, 0) != 1)\n\t\tgoto epptimeout;\n\tbc->stat = stat;\n\tbc->debug_vals.last_pllcorr = stat;\n\tGETTICK(time1);\n\tif (bc->modem == EPP_FPGAEXTSTATUS) {\n\t\t \n\t\ttmp[0] = EPP_TX_FIFO_ENABLE|EPP_RX_FIFO_ENABLE|EPP_MODEM_ENABLE|1;\n\t\tif (pp->ops->epp_write_addr(pp, tmp, 1, 0) != 1)\n\t\t\tgoto epptimeout;\n\t\tif (pp->ops->epp_read_addr(pp, tmp, 2, 0) != 2)\n\t\t\tgoto epptimeout;\n\t\tcnt = tmp[0] | (tmp[1] << 8);\n\t\tcnt &= 0x7fff;\n\t\t \n\t\ttmp[0] = EPP_TX_FIFO_ENABLE|EPP_RX_FIFO_ENABLE|EPP_MODEM_ENABLE|2;\n\t\tif (pp->ops->epp_write_addr(pp, tmp, 1, 0) != 1)\n\t\t\tgoto epptimeout;\n\t\tif (pp->ops->epp_read_addr(pp, tmp, 2, 0) != 2)\n\t\t\tgoto epptimeout;\n\t\tcnt2 = tmp[0] | (tmp[1] << 8);\n\t\tcnt2 = 16384 - (cnt2 & 0x7fff);\n\t\t \n\t\ttmp[0] = EPP_TX_FIFO_ENABLE|EPP_RX_FIFO_ENABLE|EPP_MODEM_ENABLE;\n\t\tif (pp->ops->epp_write_addr(pp, tmp, 1, 0) != 1)\n\t\t\tgoto epptimeout;\n\t\tif (transmit(bc, cnt2, stat))\n\t\t\tgoto epptimeout;\n\t\tGETTICK(time2);\n\t\tif (receive(dev, cnt))\n\t\t\tgoto epptimeout;\n\t\tif (pp->ops->epp_read_addr(pp, &stat, 1, 0) != 1)\n\t\t\tgoto epptimeout;\n\t\tbc->stat = stat;\n\t} else {\n\t\t \n\t\tswitch (stat & (EPP_NTAEF|EPP_NTHF)) {\n\t\tcase EPP_NTHF:\n\t\t\tcnt = 2048 - 256;\n\t\t\tbreak;\n\t\t\n\t\tcase EPP_NTAEF:\n\t\t\tcnt = 2048 - 1793;\n\t\t\tbreak;\n\t\t\n\t\tcase 0:\n\t\t\tcnt = 0;\n\t\t\tbreak;\n\t\t\n\t\tdefault:\n\t\t\tcnt = 2048 - 1025;\n\t\t\tbreak;\n\t\t}\n\t\tif (transmit(bc, cnt, stat))\n\t\t\tgoto epptimeout;\n\t\tGETTICK(time2);\n\t\t \n\t\twhile ((stat & (EPP_NRAEF|EPP_NRHF)) != EPP_NRHF) {\n\t\t\tswitch (stat & (EPP_NRAEF|EPP_NRHF)) {\n\t\t\tcase EPP_NRAEF:\n\t\t\t\tcnt = 1025;\n\t\t\t\tbreak;\n\n\t\t\tcase 0:\n\t\t\t\tcnt = 1793;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tcnt = 256;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (receive(dev, cnt))\n\t\t\t\tgoto epptimeout;\n\t\t\tif (pp->ops->epp_read_addr(pp, &stat, 1, 0) != 1)\n\t\t\t\tgoto epptimeout;\n\t\t}\n\t\tcnt = 0;\n\t\tif (bc->bitrate < 50000)\n\t\t\tcnt = 256;\n\t\telse if (bc->bitrate < 100000)\n\t\t\tcnt = 128;\n\t\twhile (cnt > 0 && stat & EPP_NREF) {\n\t\t\tif (receive(dev, 1))\n\t\t\t\tgoto epptimeout;\n\t\t\tcnt--;\n\t\t\tif (pp->ops->epp_read_addr(pp, &stat, 1, 0) != 1)\n\t\t\t\tgoto epptimeout;\n\t\t}\n\t}\n\tGETTICK(time3);\n#ifdef BAYCOM_DEBUG\n\tbc->debug_vals.mod_cycles = time2 - time1;\n\tbc->debug_vals.demod_cycles = time3 - time2;\n#endif  \n\tschedule_delayed_work(&bc->run_work, 1);\n\tif (!bc->skb)\n\t\tnetif_wake_queue(dev);\n\treturn;\n epptimeout:\n\tprintk(KERN_ERR \"%s: EPP timeout!\\n\", bc_drvname);\n}\n\n \n \n\nstatic netdev_tx_t baycom_send_packet(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct baycom_state *bc = netdev_priv(dev);\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn ax25_ip_xmit(skb);\n\n\tif (skb->data[0] != 0) {\n\t\tdo_kiss_params(bc, skb->data, skb->len);\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\tif (bc->skb) {\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\t \n\tif (skb->len >= HDLCDRV_MAXFLEN+1 || skb->len < 3) {\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\tnetif_stop_queue(dev);\n\tbc->skb = skb;\n\treturn NETDEV_TX_OK;\n}\n\n \n\nstatic int baycom_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct sockaddr *sa = (struct sockaddr *)addr;\n\n\t \n\tdev_addr_set(dev, sa->sa_data);\n\treturn 0;                                         \n}\n\n \n\nstatic void epp_wakeup(void *handle)\n{\n        struct net_device *dev = (struct net_device *)handle;\n        struct baycom_state *bc = netdev_priv(dev);\n\n        printk(KERN_DEBUG \"baycom_epp: %s: why am I being woken up?\\n\", dev->name);\n        if (!parport_claim(bc->pdev))\n                printk(KERN_DEBUG \"baycom_epp: %s: I'm broken.\\n\", dev->name);\n}\n\n \n\n \n\nstatic int epp_open(struct net_device *dev)\n{\n\tstruct baycom_state *bc = netdev_priv(dev);\n        struct parport *pp = parport_find_base(dev->base_addr);\n\tunsigned int i, j;\n\tunsigned char tmp[128];\n\tunsigned char stat;\n\tunsigned long tstart;\n\tstruct pardev_cb par_cb;\n\t\n        if (!pp) {\n                printk(KERN_ERR \"%s: parport at 0x%lx unknown\\n\", bc_drvname, dev->base_addr);\n                return -ENXIO;\n        }\n#if 0\n        if (pp->irq < 0) {\n                printk(KERN_ERR \"%s: parport at 0x%lx has no irq\\n\", bc_drvname, pp->base);\n\t\tparport_put_port(pp);\n                return -ENXIO;\n        }\n#endif\n\tif ((~pp->modes) & (PARPORT_MODE_TRISTATE | PARPORT_MODE_PCSPP | PARPORT_MODE_SAFEININT)) {\n                printk(KERN_ERR \"%s: parport at 0x%lx cannot be used\\n\",\n\t\t       bc_drvname, pp->base);\n\t\tparport_put_port(pp);\n                return -EIO;\n\t}\n\tmemset(&bc->modem, 0, sizeof(bc->modem));\n\tmemset(&par_cb, 0, sizeof(par_cb));\n\tpar_cb.wakeup = epp_wakeup;\n\tpar_cb.private = (void *)dev;\n\tpar_cb.flags = PARPORT_DEV_EXCL;\n\tfor (i = 0; i < NR_PORTS; i++)\n\t\tif (baycom_device[i] == dev)\n\t\t\tbreak;\n\n\tif (i == NR_PORTS) {\n\t\tpr_err(\"%s: no device found\\n\", bc_drvname);\n\t\tparport_put_port(pp);\n\t\treturn -ENODEV;\n\t}\n\n\tbc->pdev = parport_register_dev_model(pp, dev->name, &par_cb, i);\n\tparport_put_port(pp);\n        if (!bc->pdev) {\n                printk(KERN_ERR \"%s: cannot register parport at 0x%lx\\n\", bc_drvname, pp->base);\n                return -ENXIO;\n        }\n        if (parport_claim(bc->pdev)) {\n                printk(KERN_ERR \"%s: parport at 0x%lx busy\\n\", bc_drvname, pp->base);\n                parport_unregister_device(bc->pdev);\n                return -EBUSY;\n        }\n        dev->irq =   0;\n\tINIT_DELAYED_WORK(&bc->run_work, epp_bh);\n\tbc->work_running = 1;\n\tbc->modem = EPP_CONVENTIONAL;\n\tif (eppconfig(bc))\n\t\tprintk(KERN_INFO \"%s: no FPGA detected, assuming conventional EPP modem\\n\", bc_drvname);\n\telse\n\t\tbc->modem =   EPP_FPGAEXTSTATUS;\n\tparport_write_control(pp, LPTCTRL_PROGRAM);  \n\t \n\ttmp[0] = 0;\n\ttmp[1] = EPP_TX_FIFO_ENABLE|EPP_RX_FIFO_ENABLE|EPP_MODEM_ENABLE;\n\tif (pp->ops->epp_write_addr(pp, tmp, 2, 0) != 2)\n\t\tgoto epptimeout;\n\t \n\ttstart = jiffies;\n\ti = 0;\n\twhile (time_before(jiffies, tstart + HZ/3)) {\n\t\tif (pp->ops->epp_read_addr(pp, &stat, 1, 0) != 1)\n\t\t\tgoto epptimeout;\n\t\tif ((stat & (EPP_NRAEF|EPP_NRHF)) == EPP_NRHF) {\n\t\t\tschedule();\n\t\t\tcontinue;\n\t\t}\n\t\tif (pp->ops->epp_read_data(pp, tmp, 128, 0) != 128)\n\t\t\tgoto epptimeout;\n\t\tif (pp->ops->epp_read_data(pp, tmp, 128, 0) != 128)\n\t\t\tgoto epptimeout;\n\t\ti += 256;\n\t}\n\tfor (j = 0; j < 256; j++) {\n\t\tif (pp->ops->epp_read_addr(pp, &stat, 1, 0) != 1)\n\t\t\tgoto epptimeout;\n\t\tif (!(stat & EPP_NREF))\n\t\t\tbreak;\n\t\tif (pp->ops->epp_read_data(pp, tmp, 1, 0) != 1)\n\t\t\tgoto epptimeout;\n\t\ti++;\n\t}\n\ttstart = jiffies - tstart;\n\tbc->bitrate = i * (8 * HZ) / tstart;\n\tj = 1;\n\ti = bc->bitrate >> 3;\n\twhile (j < 7 && i > 150) {\n\t\tj++;\n\t\ti >>= 1;\n\t}\n\tprintk(KERN_INFO \"%s: autoprobed bitrate: %d  int divider: %d  int rate: %d\\n\", \n\t       bc_drvname, bc->bitrate, j, bc->bitrate >> (j+2));\n\ttmp[0] = EPP_TX_FIFO_ENABLE|EPP_RX_FIFO_ENABLE|EPP_MODEM_ENABLE ;\n\tif (pp->ops->epp_write_addr(pp, tmp, 1, 0) != 1)\n\t\tgoto epptimeout;\n\t \n\tbc->hdlcrx.state = 0;\n\tbc->hdlcrx.numbits = 0;\n\tbc->hdlctx.state = tx_idle;\n\tbc->hdlctx.bufcnt = 0;\n\tbc->hdlctx.slotcnt = bc->ch_params.slottime;\n\tbc->hdlctx.calibrate = 0;\n\t \n\tschedule_delayed_work(&bc->run_work, 1);\n\tnetif_start_queue(dev);\n\treturn 0;\n\n epptimeout:\n\tprintk(KERN_ERR \"%s: epp timeout during bitrate probe\\n\", bc_drvname);\n\tparport_write_control(pp, 0);  \n        parport_release(bc->pdev);\n        parport_unregister_device(bc->pdev);\n\treturn -EIO;\n}\n\n \n\nstatic int epp_close(struct net_device *dev)\n{\n\tstruct baycom_state *bc = netdev_priv(dev);\n\tstruct parport *pp = bc->pdev->port;\n\tunsigned char tmp[1];\n\n\tbc->work_running = 0;\n\tcancel_delayed_work_sync(&bc->run_work);\n\tbc->stat = EPP_DCDBIT;\n\ttmp[0] = 0;\n\tpp->ops->epp_write_addr(pp, tmp, 1, 0);\n\tparport_write_control(pp, 0);  \n        parport_release(bc->pdev);\n        parport_unregister_device(bc->pdev);\n\tdev_kfree_skb(bc->skb);\n\tbc->skb = NULL;\n\tprintk(KERN_INFO \"%s: close epp at iobase 0x%lx irq %u\\n\",\n\t       bc_drvname, dev->base_addr, dev->irq);\n\treturn 0;\n}\n\n \n\nstatic int baycom_setmode(struct baycom_state *bc, const char *modestr)\n{\n\tconst char *cp;\n\n\tif (strstr(modestr,\"intclk\"))\n\t\tbc->cfg.intclk = 1;\n\tif (strstr(modestr,\"extclk\"))\n\t\tbc->cfg.intclk = 0;\n\tif (strstr(modestr,\"intmodem\"))\n\t\tbc->cfg.extmodem = 0;\n\tif (strstr(modestr,\"extmodem\"))\n\t\tbc->cfg.extmodem = 1;\n\tif (strstr(modestr,\"loopback\"))\n\t\tbc->cfg.loopback = 1;\n\tif (strstr(modestr, \"noloopback\"))\n\t\tbc->cfg.loopback = 0;\n\tif ((cp = strstr(modestr,\"fclk=\"))) {\n\t\tbc->cfg.fclk = simple_strtoul(cp+5, NULL, 0);\n\t\tif (bc->cfg.fclk < 1000000)\n\t\t\tbc->cfg.fclk = 1000000;\n\t\tif (bc->cfg.fclk > 25000000)\n\t\t\tbc->cfg.fclk = 25000000;\n\t}\n\tif ((cp = strstr(modestr,\"bps=\"))) {\n\t\tbc->cfg.bps = simple_strtoul(cp+4, NULL, 0);\n\t\tif (bc->cfg.bps < 1000)\n\t\t\tbc->cfg.bps = 1000;\n\t\tif (bc->cfg.bps > 1500000)\n\t\t\tbc->cfg.bps = 1500000;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int baycom_siocdevprivate(struct net_device *dev, struct ifreq *ifr,\n\t\t\t\t void __user *data, int cmd)\n{\n\tstruct baycom_state *bc = netdev_priv(dev);\n\tstruct hdlcdrv_ioctl hi;\n\n\tif (cmd != SIOCDEVPRIVATE)\n\t\treturn -ENOIOCTLCMD;\n\n\tif (copy_from_user(&hi, data, sizeof(hi)))\n\t\treturn -EFAULT;\n\tswitch (hi.cmd) {\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\n\tcase HDLCDRVCTL_GETCHANNELPAR:\n\t\thi.data.cp.tx_delay = bc->ch_params.tx_delay;\n\t\thi.data.cp.tx_tail = bc->ch_params.tx_tail;\n\t\thi.data.cp.slottime = bc->ch_params.slottime;\n\t\thi.data.cp.ppersist = bc->ch_params.ppersist;\n\t\thi.data.cp.fulldup = bc->ch_params.fulldup;\n\t\tbreak;\n\n\tcase HDLCDRVCTL_SETCHANNELPAR:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\t\tbc->ch_params.tx_delay = hi.data.cp.tx_delay;\n\t\tbc->ch_params.tx_tail = hi.data.cp.tx_tail;\n\t\tbc->ch_params.slottime = hi.data.cp.slottime;\n\t\tbc->ch_params.ppersist = hi.data.cp.ppersist;\n\t\tbc->ch_params.fulldup = hi.data.cp.fulldup;\n\t\tbc->hdlctx.slotcnt = 1;\n\t\treturn 0;\n\t\t\n\tcase HDLCDRVCTL_GETMODEMPAR:\n\t\thi.data.mp.iobase = dev->base_addr;\n\t\thi.data.mp.irq = dev->irq;\n\t\thi.data.mp.dma = dev->dma;\n\t\thi.data.mp.dma2 = 0;\n\t\thi.data.mp.seriobase = 0;\n\t\thi.data.mp.pariobase = 0;\n\t\thi.data.mp.midiiobase = 0;\n\t\tbreak;\n\n\tcase HDLCDRVCTL_SETMODEMPAR:\n\t\tif ((!capable(CAP_SYS_RAWIO)) || netif_running(dev))\n\t\t\treturn -EACCES;\n\t\tdev->base_addr = hi.data.mp.iobase;\n\t\tdev->irq =  0;\n\t\tdev->dma =  0;\n\t\treturn 0;\t\n\t\t\n\tcase HDLCDRVCTL_GETSTAT:\n\t\thi.data.cs.ptt = !!(bc->stat & EPP_PTTBIT);\n\t\thi.data.cs.dcd = !(bc->stat & EPP_DCDBIT);\n\t\thi.data.cs.ptt_keyed = bc->ptt_keyed;\n\t\thi.data.cs.tx_packets = dev->stats.tx_packets;\n\t\thi.data.cs.tx_errors = dev->stats.tx_errors;\n\t\thi.data.cs.rx_packets = dev->stats.rx_packets;\n\t\thi.data.cs.rx_errors = dev->stats.rx_errors;\n\t\tbreak;\t\t\n\n\tcase HDLCDRVCTL_OLDGETSTAT:\n\t\thi.data.ocs.ptt = !!(bc->stat & EPP_PTTBIT);\n\t\thi.data.ocs.dcd = !(bc->stat & EPP_DCDBIT);\n\t\thi.data.ocs.ptt_keyed = bc->ptt_keyed;\n\t\tbreak;\t\t\n\n\tcase HDLCDRVCTL_CALIBRATE:\n\t\tif (!capable(CAP_SYS_RAWIO))\n\t\t\treturn -EACCES;\n\t\tbc->hdlctx.calibrate = hi.data.calibrate * bc->bitrate / 8;\n\t\treturn 0;\n\n\tcase HDLCDRVCTL_DRIVERNAME:\n\t\tstrncpy(hi.data.drivername, \"baycom_epp\", sizeof(hi.data.drivername));\n\t\tbreak;\n\t\t\n\tcase HDLCDRVCTL_GETMODE:\n\t\tsprintf(hi.data.modename, \"%sclk,%smodem,fclk=%d,bps=%d%s\", \n\t\t\tbc->cfg.intclk ? \"int\" : \"ext\",\n\t\t\tbc->cfg.extmodem ? \"ext\" : \"int\", bc->cfg.fclk, bc->cfg.bps,\n\t\t\tbc->cfg.loopback ? \",loopback\" : \"\");\n\t\tbreak;\n\n\tcase HDLCDRVCTL_SETMODE:\n\t\tif (!capable(CAP_NET_ADMIN) || netif_running(dev))\n\t\t\treturn -EACCES;\n\t\thi.data.modename[sizeof(hi.data.modename)-1] = '\\0';\n\t\treturn baycom_setmode(bc, hi.data.modename);\n\n\tcase HDLCDRVCTL_MODELIST:\n\t\tstrncpy(hi.data.modename, \"intclk,extclk,intmodem,extmodem,divider=x\",\n\t\t\tsizeof(hi.data.modename));\n\t\tbreak;\n\n\tcase HDLCDRVCTL_MODEMPARMASK:\n\t\treturn HDLCDRV_PARMASK_IOBASE;\n\n\t}\n\tif (copy_to_user(data, &hi, sizeof(hi)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \n\nstatic const struct net_device_ops baycom_netdev_ops = {\n\t.ndo_open\t     = epp_open,\n\t.ndo_stop\t     = epp_close,\n\t.ndo_siocdevprivate  = baycom_siocdevprivate,\n\t.ndo_start_xmit      = baycom_send_packet,\n\t.ndo_set_mac_address = baycom_set_mac_address,\n};\n\n \nstatic void baycom_probe(struct net_device *dev)\n{\n\tconst struct hdlcdrv_channel_params dflt_ch_params = { \n\t\t20, 2, 10, 40, 0 \n\t};\n\tstruct baycom_state *bc;\n\n\t \n\tbc = netdev_priv(dev);\n\t \n\tbc->ch_params = dflt_ch_params;\n\tbc->ptt_keyed = 0;\n\n\t \n\n\t \n\tbc->skb = NULL;\n\t\n\tdev->netdev_ops = &baycom_netdev_ops;\n\tdev->header_ops = &ax25_header_ops;\n\t\n\tdev->type = ARPHRD_AX25;            \n\tdev->hard_header_len = AX25_MAX_HEADER_LEN + AX25_BPQ_HEADER_LEN;\n\tdev->mtu = AX25_DEF_PACLEN;         \n\tdev->addr_len = AX25_ADDR_LEN;      \n\tmemcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);\n\tdev_addr_set(dev, (u8 *)&null_ax25_address);\n\tdev->tx_queue_len = 16;\n\n\t \n\tdev->flags = 0;\n}\n\n \n\n \nstatic char *mode[NR_PORTS] = { \"\", };\nstatic int iobase[NR_PORTS] = { 0x378, };\n\nmodule_param_array(mode, charp, NULL, 0);\nMODULE_PARM_DESC(mode, \"baycom operating mode\");\nmodule_param_hw_array(iobase, int, ioport, NULL, 0);\nMODULE_PARM_DESC(iobase, \"baycom io base address\");\n\nMODULE_AUTHOR(\"Thomas M. Sailer, sailer@ife.ee.ethz.ch, hb9jnx@hb9w.che.eu\");\nMODULE_DESCRIPTION(\"Baycom epp amateur radio modem driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n\nstatic int baycom_epp_par_probe(struct pardevice *par_dev)\n{\n\tstruct device_driver *drv = par_dev->dev.driver;\n\tint len = strlen(drv->name);\n\n\tif (strncmp(par_dev->name, drv->name, len))\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic struct parport_driver baycom_epp_par_driver = {\n\t.name = \"bce\",\n\t.probe = baycom_epp_par_probe,\n\t.devmodel = true,\n};\n\nstatic void __init baycom_epp_dev_setup(struct net_device *dev)\n{\n\tstruct baycom_state *bc = netdev_priv(dev);\n\n\t \n\tbc->dev = dev;\n\tbc->magic = BAYCOM_MAGIC;\n\tbc->cfg.fclk = 19666600;\n\tbc->cfg.bps = 9600;\n\t \n\tbaycom_probe(dev);\n}\n\nstatic int __init init_baycomepp(void)\n{\n\tint i, found = 0, ret;\n\tchar set_hw = 1;\n\n\tprintk(bc_drvinfo);\n\n\tret = parport_register_driver(&baycom_epp_par_driver);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < NR_PORTS; i++) {\n\t\tstruct net_device *dev;\n\t\t\n\t\tdev = alloc_netdev(sizeof(struct baycom_state), \"bce%d\",\n\t\t\t\t   NET_NAME_UNKNOWN, baycom_epp_dev_setup);\n\n\t\tif (!dev) {\n\t\t\tprintk(KERN_WARNING \"bce%d : out of memory\\n\", i);\n\t\t\treturn found ? 0 : -ENOMEM;\n\t\t}\n\t\t\t\n\t\tsprintf(dev->name, \"bce%d\", i);\n\t\tdev->base_addr = iobase[i];\n\n\t\tif (!mode[i])\n\t\t\tset_hw = 0;\n\t\tif (!set_hw)\n\t\t\tiobase[i] = 0;\n\n\t\tif (register_netdev(dev)) {\n\t\t\tprintk(KERN_WARNING \"%s: cannot register net device %s\\n\", bc_drvname, dev->name);\n\t\t\tfree_netdev(dev);\n\t\t\tbreak;\n\t\t}\n\t\tif (set_hw && baycom_setmode(netdev_priv(dev), mode[i]))\n\t\t\tset_hw = 0;\n\t\tbaycom_device[i] = dev;\n\t\tfound++;\n\t}\n\n\tif (found == 0) {\n\t\tparport_unregister_driver(&baycom_epp_par_driver);\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit cleanup_baycomepp(void)\n{\n\tint i;\n\n\tfor(i = 0; i < NR_PORTS; i++) {\n\t\tstruct net_device *dev = baycom_device[i];\n\n\t\tif (dev) {\n\t\t\tstruct baycom_state *bc = netdev_priv(dev);\n\t\t\tif (bc->magic == BAYCOM_MAGIC) {\n\t\t\t\tunregister_netdev(dev);\n\t\t\t\tfree_netdev(dev);\n\t\t\t} else\n\t\t\t\tprintk(paranoia_str, \"cleanup_module\");\n\t\t}\n\t}\n\tparport_unregister_driver(&baycom_epp_par_driver);\n}\n\nmodule_init(init_baycomepp);\nmodule_exit(cleanup_baycomepp);\n\n \n\n#ifndef MODULE\n\n \n\nstatic int __init baycom_epp_setup(char *str)\n{\n        static unsigned __initdata nr_dev = 0;\n\tint ints[2];\n\n        if (nr_dev >= NR_PORTS)\n                return 0;\n\tstr = get_options(str, 2, ints);\n\tif (ints[0] < 1)\n\t\treturn 0;\n\tmode[nr_dev] = str;\n\tiobase[nr_dev] = ints[1];\n\tnr_dev++;\n\treturn 1;\n}\n\n__setup(\"baycom_epp=\", baycom_epp_setup);\n\n#endif  \n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}