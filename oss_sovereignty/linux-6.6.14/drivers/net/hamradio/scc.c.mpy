{
  "module_name": "scc.c",
  "hash_id": "8728237589b89ee97301d585a28d57e2be5bceac64787432b01ed812713fe646",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/hamradio/scc.c",
  "human_readable_source": "#define RCS_ID \"$Id: scc.c,v 1.75 1998/11/04 15:15:01 jreuter Exp jreuter $\"\n\n#define VERSION \"3.0\"\n\n \n\n \n\n \n\n#undef  SCC_LDELAY\t\t \n#undef  SCC_DONT_CHECK\t\t \n\n#define SCC_MAXCHIPS\t4        \n#define SCC_BUFSIZE\t384      \n#undef\tSCC_DEBUG\n\n#define SCC_DEFAULT_CLOCK\t4915200 \n\t\t\t\t \n\n \n\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/timer.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/string.h>\n#include <linux/in.h>\n#include <linux/fcntl.h>\n#include <linux/ptrace.h>\n#include <linux/delay.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/if_ether.h>\n#include <linux/if_arp.h>\n#include <linux/socket.h>\n#include <linux/init.h>\n#include <linux/scc.h>\n#include <linux/ctype.h>\n#include <linux/kernel.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/bitops.h>\n\n#include <net/net_namespace.h>\n#include <net/ax25.h>\n\n#include <asm/irq.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n#include \"z8530.h\"\n\nstatic const char banner[] __initconst = KERN_INFO \\\n\t\"AX.25: Z8530 SCC driver version \"VERSION\".dl1bke\\n\";\n\nstatic void t_dwait(struct timer_list *t);\nstatic void t_txdelay(struct timer_list *t);\nstatic void t_tail(struct timer_list *t);\nstatic void t_busy(struct timer_list *);\nstatic void t_maxkeyup(struct timer_list *);\nstatic void t_idle(struct timer_list *t);\nstatic void scc_tx_done(struct scc_channel *);\nstatic void scc_start_tx_timer(struct scc_channel *,\n\t\t\t       void (*)(struct timer_list *), unsigned long);\nstatic void scc_start_maxkeyup(struct scc_channel *);\nstatic void scc_start_defer(struct scc_channel *);\n\nstatic void z8530_init(void);\n\nstatic void init_channel(struct scc_channel *scc);\nstatic void scc_key_trx (struct scc_channel *scc, char tx);\nstatic void scc_init_timer(struct scc_channel *scc);\n\nstatic int scc_net_alloc(const char *name, struct scc_channel *scc);\nstatic void scc_net_setup(struct net_device *dev);\nstatic int scc_net_open(struct net_device *dev);\nstatic int scc_net_close(struct net_device *dev);\nstatic void scc_net_rx(struct scc_channel *scc, struct sk_buff *skb);\nstatic netdev_tx_t scc_net_tx(struct sk_buff *skb,\n\t\t\t      struct net_device *dev);\nstatic int scc_net_siocdevprivate(struct net_device *dev, struct ifreq *ifr,\n\t\t\t\t  void __user *data, int cmd);\nstatic int scc_net_set_mac_address(struct net_device *dev, void *addr);\nstatic struct net_device_stats * scc_net_get_stats(struct net_device *dev);\n\nstatic unsigned char SCC_DriverName[] = \"scc\";\n\nstatic struct irqflags { unsigned char used : 1; } Ivec[NR_IRQS];\n\t\nstatic struct scc_channel SCC_Info[2 * SCC_MAXCHIPS];\t \n\nstatic struct scc_ctrl {\n\tio_port chan_A;\n\tio_port chan_B;\n\tint irq;\n} SCC_ctrl[SCC_MAXCHIPS+1];\n\nstatic unsigned char Driver_Initialized;\nstatic int Nchips;\nstatic io_port Vector_Latch;\n\n\n \n \n \n\n \n\nstatic DEFINE_SPINLOCK(iolock);\t \n\nstatic inline unsigned char InReg(io_port port, unsigned char reg)\n{\n\tunsigned long flags;\n\tunsigned char r;\n\n\tspin_lock_irqsave(&iolock, flags);\t\n#ifdef SCC_LDELAY\n\tOutb(port, reg);\n\tudelay(SCC_LDELAY);\n\tr=Inb(port);\n\tudelay(SCC_LDELAY);\n#else\n\tOutb(port, reg);\n\tr=Inb(port);\n#endif\n\tspin_unlock_irqrestore(&iolock, flags);\n\treturn r;\n}\n\nstatic inline void OutReg(io_port port, unsigned char reg, unsigned char val)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&iolock, flags);\n#ifdef SCC_LDELAY\n\tOutb(port, reg); udelay(SCC_LDELAY);\n\tOutb(port, val); udelay(SCC_LDELAY);\n#else\n\tOutb(port, reg);\n\tOutb(port, val);\n#endif\n\tspin_unlock_irqrestore(&iolock, flags);\n}\n\nstatic inline void wr(struct scc_channel *scc, unsigned char reg,\n\tunsigned char val)\n{\n\tOutReg(scc->ctrl, reg, (scc->wreg[reg] = val));\n}\n\nstatic inline void or(struct scc_channel *scc, unsigned char reg, unsigned char val)\n{\n\tOutReg(scc->ctrl, reg, (scc->wreg[reg] |= val));\n}\n\nstatic inline void cl(struct scc_channel *scc, unsigned char reg, unsigned char val)\n{\n\tOutReg(scc->ctrl, reg, (scc->wreg[reg] &= ~val));\n}\n\n \n \n \n\nstatic inline void scc_discard_buffers(struct scc_channel *scc)\n{\n\tunsigned long flags;\n\t\n\tspin_lock_irqsave(&scc->lock, flags);\t\n\tif (scc->tx_buff != NULL)\n\t{\n\t\tdev_kfree_skb_irq(scc->tx_buff);\n\t\tscc->tx_buff = NULL;\n\t}\n\t\n\twhile (!skb_queue_empty(&scc->tx_queue))\n\t\tdev_kfree_skb_irq(skb_dequeue(&scc->tx_queue));\n\n\tspin_unlock_irqrestore(&scc->lock, flags);\n}\n\n\n\n \n \n \n\n\n \n\nstatic inline void scc_notify(struct scc_channel *scc, int event)\n{\n\tstruct sk_buff *skb;\n\tchar *bp;\n\t\n        if (scc->kiss.fulldup != KISS_DUPLEX_OPTIMA)\n\t\treturn;\n\n\tskb = dev_alloc_skb(2);\n\tif (skb != NULL)\n\t{\n\t\tbp = skb_put(skb, 2);\n\t\t*bp++ = PARAM_HWEVENT;\n\t\t*bp++ = event;\n\t\tscc_net_rx(scc, skb);\n\t} else\n\t\tscc->stat.nospace++;\n}\n\nstatic inline void flush_rx_FIFO(struct scc_channel *scc)\n{\n\tint k;\n\t\n\tfor (k=0; k<3; k++)\n\t\tInb(scc->data);\n\t\t\n\tif(scc->rx_buff != NULL)\t\t \n\t{\n\t\tscc->stat.rxerrs++;   \n\t\tdev_kfree_skb_irq(scc->rx_buff);\n\t\tscc->rx_buff = NULL;\n\t}\n}\n\nstatic void start_hunt(struct scc_channel *scc)\n{\n\tif ((scc->modem.clocksrc != CLK_EXTERNAL))\n\t\tOutReg(scc->ctrl,R14,SEARCH|scc->wreg[R14]);  \n\tor(scc,R3,ENT_HM|RxENABLE);   \n}\n\n \n \n\n \nstatic inline void scc_txint(struct scc_channel *scc)\n{\n\tstruct sk_buff *skb;\n\n\tscc->stat.txints++;\n\tskb = scc->tx_buff;\n\t\n\t \n\t\n\tif (skb == NULL)\n\t{\n\t\tskb = skb_dequeue(&scc->tx_queue);\n\t\tscc->tx_buff = skb;\n\t\tnetif_wake_queue(scc->dev);\n\n\t\tif (skb == NULL)\n\t\t{\n\t\t\tscc_tx_done(scc);\n\t\t\tOutb(scc->ctrl, RES_Tx_P);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (skb->len == 0)\t\t \n\t\t{\n\t\t\tdev_kfree_skb_irq(skb);\n\t\t\tscc->tx_buff = NULL;\n\t\t\tscc_tx_done(scc);\n\t\t\tOutb(scc->ctrl, RES_Tx_P);\n\t\t\treturn;\n\t\t}\n\n\t\tscc->stat.tx_state = TXS_ACTIVE;\n\n\t\tOutReg(scc->ctrl, R0, RES_Tx_CRC);\n\t\t\t\t\t\t \n\t\tor(scc,R10,ABUNDER);\t\t \n\t\tOutb(scc->data,*skb->data);\t \n\t\tskb_pull(skb, 1);\n\n\t\tif (!scc->enhanced)\t\t \n\t\t\tOutb(scc->ctrl,RES_EOM_L);\n\t\treturn;\n\t}\n\t\n\t \n\t\n\tif (skb->len == 0)\n\t{\n\t\tOutb(scc->ctrl, RES_Tx_P);\t \n\t\tcl(scc, R10, ABUNDER);\t\t \n\t\tdev_kfree_skb_irq(skb);\n\t\tscc->tx_buff = NULL;\n\t\tscc->stat.tx_state = TXS_NEWFRAME;  \n\t\treturn;\n\t} \n\t\n\t \n\t\n\tOutb(scc->data,*skb->data);\t\t\n\tskb_pull(skb, 1);\n}\n\n\n \nstatic inline void scc_exint(struct scc_channel *scc)\n{\n\tunsigned char status,changes,chg_and_stat;\n\n\tscc->stat.exints++;\n\n\tstatus = InReg(scc->ctrl,R0);\n\tchanges = status ^ scc->status;\n\tchg_and_stat = changes & status;\n\t\n\t \n\n\tif (chg_and_stat & BRK_ABRT)\t\t \n\t\tflush_rx_FIFO(scc);\n\n\t \n\n\tif ((changes & SYNC_HUNT) && scc->kiss.softdcd)\n\t{\n\t\tif (status & SYNC_HUNT)\n\t\t{\n\t\t\tscc->dcd = 0;\n\t\t\tflush_rx_FIFO(scc);\n\t\t\tif ((scc->modem.clocksrc != CLK_EXTERNAL))\n\t\t\t\tOutReg(scc->ctrl,R14,SEARCH|scc->wreg[R14]);  \n\t\t} else {\n\t\t\tscc->dcd = 1;\n\t\t}\n\n\t\tscc_notify(scc, scc->dcd? HWEV_DCD_OFF:HWEV_DCD_ON);\n\t}\n\n\t \n\t \n\t\n\tif((changes & DCD) && !scc->kiss.softdcd)  \n\t{\n\t\tif(status & DCD)                 \n\t\t{\n\t\t\tstart_hunt(scc);\n\t\t\tscc->dcd = 1;\n\t\t} else {                         \n\t\t\tcl(scc,R3,ENT_HM|RxENABLE);  \n\t\t\tflush_rx_FIFO(scc);\n\t\t\tscc->dcd = 0;\n\t\t}\n\t\t\n\t\tscc_notify(scc, scc->dcd? HWEV_DCD_ON:HWEV_DCD_OFF);\n\t}\n\n#ifdef notdef\n\t \n\t \n\tif (chg_and_stat & CTS)\t\t\t \n\t{\n\t\tif (scc->kiss.txdelay == 0)\t \n\t\t\tscc_start_tx_timer(scc, t_txdelay, 0);\n\t}\n#endif\n\t\n\tif (scc->stat.tx_state == TXS_ACTIVE && (status & TxEOM))\n\t{\n\t\tscc->stat.tx_under++;\t   \n\t\tOutb(scc->ctrl, RES_EXT_INT);\t \n\n\t\tif (scc->tx_buff != NULL)\n\t\t{\n\t\t\tdev_kfree_skb_irq(scc->tx_buff);\n\t\t\tscc->tx_buff = NULL;\n\t\t}\n\t\t\n\t\tor(scc,R10,ABUNDER);\n\t\tscc_start_tx_timer(scc, t_txdelay, 0);\t \n\t}\n\t\t\n\tscc->status = status;\n\tOutb(scc->ctrl,RES_EXT_INT);\n}\n\n\n \nstatic inline void scc_rxint(struct scc_channel *scc)\n{\n\tstruct sk_buff *skb;\n\n\tscc->stat.rxints++;\n\n\tif((scc->wreg[5] & RTS) && scc->kiss.fulldup == KISS_DUPLEX_HALF)\n\t{\n\t\tInb(scc->data);\t\t \n\t\tor(scc,R3,ENT_HM);\t \n\t\treturn;\n\t}\n\n\tskb = scc->rx_buff;\n\t\n\tif (skb == NULL)\n\t{\n\t\tskb = dev_alloc_skb(scc->stat.bufsize);\n\t\tif (skb == NULL)\n\t\t{\n\t\t\tscc->dev_stat.rx_dropped++;\n\t\t\tscc->stat.nospace++;\n\t\t\tInb(scc->data);\n\t\t\tor(scc, R3, ENT_HM);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tscc->rx_buff = skb;\n\t\tskb_put_u8(skb, 0);\t \n\t}\n\t\n\tif (skb->len >= scc->stat.bufsize)\n\t{\n#ifdef notdef\n\t\tprintk(KERN_DEBUG \"z8530drv: oops, scc_rxint() received huge frame...\\n\");\n#endif\n\t\tdev_kfree_skb_irq(skb);\n\t\tscc->rx_buff = NULL;\n\t\tInb(scc->data);\n\t\tor(scc, R3, ENT_HM);\n\t\treturn;\n\t}\n\n\tskb_put_u8(skb, Inb(scc->data));\n}\n\n\n \nstatic inline void scc_spint(struct scc_channel *scc)\n{\n\tunsigned char status;\n\tstruct sk_buff *skb;\n\n\tscc->stat.spints++;\n\n\tstatus = InReg(scc->ctrl,R1);\t\t \n\t\n\tInb(scc->data);\t\t\t\t \n\tskb = scc->rx_buff;\n\n\tif(status & Rx_OVR)\t\t\t \n\t{\n\t\tscc->stat.rx_over++;              \n\t\tor(scc,R3,ENT_HM);                \n\t\t\n\t\tif (skb != NULL) \n\t\t\tdev_kfree_skb_irq(skb);\n\t\tscc->rx_buff = skb = NULL;\n\t}\n\n\tif(status & END_FR && skb != NULL)\t \n\t{\n\t\t \n\t\t\n\t\tif (!(status & CRC_ERR) && (status & 0xe) == RES8 && skb->len > 0)\n\t\t{\n\t\t\t \n\t\t\tskb_trim(skb, skb->len-1);\n\t\t\tscc_net_rx(scc, skb);\n\t\t\tscc->rx_buff = NULL;\n\t\t\tscc->stat.rxframes++;\n\t\t} else {\t\t\t\t \n\t\t\tdev_kfree_skb_irq(skb);\n\t\t\tscc->rx_buff = NULL;\n\t\t\tscc->stat.rxerrs++;\n\t\t}\n\t} \n\n\tOutb(scc->ctrl,ERR_RES);\n}\n\n\n \n\nstatic void scc_isr_dispatch(struct scc_channel *scc, int vector)\n{\n\tspin_lock(&scc->lock);\n\tswitch (vector & VECTOR_MASK)\n\t{\n\t\tcase TXINT: scc_txint(scc); break;\n\t\tcase EXINT: scc_exint(scc); break;\n\t\tcase RXINT: scc_rxint(scc); break;\n\t\tcase SPINT: scc_spint(scc); break;\n\t}\n\tspin_unlock(&scc->lock);\n}\n\n \n\n#define SCC_IRQTIMEOUT 30000\n\nstatic irqreturn_t scc_isr(int irq, void *dev_id)\n{\n\tint chip_irq = (long) dev_id;\n\tunsigned char vector;\t\n\tstruct scc_channel *scc;\n\tstruct scc_ctrl *ctrl;\n\tint k;\n\t\n\tif (Vector_Latch)\n\t{\n\t    \tfor(k=0; k < SCC_IRQTIMEOUT; k++)\n    \t\t{\n\t\t\tOutb(Vector_Latch, 0);       \n        \n\t\t\t \n\t\t\tif((vector=Inb(Vector_Latch)) >= 16 * Nchips) break; \n\t\t\tif (vector & 0x01) break;\n        \t \n\t\t        scc=&SCC_Info[vector >> 3 ^ 0x01];\n\t\t\tif (!scc->dev) break;\n\n\t\t\tscc_isr_dispatch(scc, vector);\n\n\t\t\tOutReg(scc->ctrl,R0,RES_H_IUS);               \n\t\t}  \n\n\t\tif (k == SCC_IRQTIMEOUT)\n\t\t\tprintk(KERN_WARNING \"z8530drv: endless loop in scc_isr()?\\n\");\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\n\tctrl = SCC_ctrl;\n\twhile (ctrl->chan_A)\n\t{\n\t\tif (ctrl->irq != chip_irq)\n\t\t{\n\t\t\tctrl++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tscc = NULL;\n\t\tfor (k = 0; InReg(ctrl->chan_A,R3) && k < SCC_IRQTIMEOUT; k++)\n\t\t{\n\t\t\tvector=InReg(ctrl->chan_B,R2);\t \n\t\t\tif (vector & 0x01) break; \n\n\t\t\tscc = &SCC_Info[vector >> 3 ^ 0x01];\n\t\t        if (!scc->dev) break;\n\n\t\t\tscc_isr_dispatch(scc, vector);\n\t\t}\n\n\t\tif (k == SCC_IRQTIMEOUT)\n\t\t{\n\t\t\tprintk(KERN_WARNING \"z8530drv: endless loop in scc_isr()?!\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\tif (scc != NULL)\n\t\t{\n\t\t\tOutReg(scc->ctrl,R0,RES_H_IUS);\n\t\t\tctrl = SCC_ctrl; \n\t\t} else\n\t\t\tctrl++;\n\t}\n\treturn IRQ_HANDLED;\n}\n\n\n\n \n \n \n\n\n \n\nstatic inline void set_brg(struct scc_channel *scc, unsigned int tc)\n{\n\tcl(scc,R14,BRENABL);\t\t \n\twr(scc,R12,tc & 255);\t\t \n\twr(scc,R13,tc >> 8);   \t\t \n\tor(scc,R14,BRENABL);\t\t \n}\n\nstatic inline void set_speed(struct scc_channel *scc)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&scc->lock, flags);\n\n\tif (scc->modem.speed > 0)\t \n\t\tset_brg(scc, (unsigned) (scc->clock / (scc->modem.speed * 64)) - 2);\n\t\t\n\tspin_unlock_irqrestore(&scc->lock, flags);\n}\n\n\n \n\nstatic inline void init_brg(struct scc_channel *scc)\n{\n\twr(scc, R14, BRSRC);\t\t\t\t \n\tOutReg(scc->ctrl, R14, SSBR|scc->wreg[R14]);\t \n\tOutReg(scc->ctrl, R14, SNRZI|scc->wreg[R14]);\t \n}\n\n \n \nstatic void init_channel(struct scc_channel *scc)\n{\n\tdel_timer(&scc->tx_t);\n\tdel_timer(&scc->tx_wdog);\n\n\tdisable_irq(scc->irq);\n\n\twr(scc,R4,X1CLK|SDLC);\t\t \n\twr(scc,R1,0);\t\t\t \n\twr(scc,R3,Rx8|RxCRC_ENAB);\t \t\n\twr(scc,R5,Tx8|DTR|TxCRC_ENAB);\t \n\twr(scc,R6,0);\t\t\t \n\twr(scc,R7,FLAG);\t\t \n\twr(scc,R9,VIS);\t\t\t \n\twr(scc,R10,(scc->modem.nrz? NRZ : NRZI)|CRCPS|ABUNDER);  \n\twr(scc,R14, 0);\n\n\n   \n\n   \t\t\n\tswitch(scc->modem.clocksrc)\n\t{\n\t\tcase CLK_DPLL:\n\t\t\twr(scc, R11, RCDPLL|TCDPLL|TRxCOI|TRxCDP);\n\t\t\tinit_brg(scc);\n\t\t\tbreak;\n\n\t\tcase CLK_DIVIDER:\n\t\t\twr(scc, R11, ((scc->brand & BAYCOM)? TRxCDP : TRxCBR) | RCDPLL|TCRTxCP|TRxCOI);\n\t\t\tinit_brg(scc);\n\t\t\tbreak;\n\n\t\tcase CLK_EXTERNAL:\n\t\t\twr(scc, R11, (scc->brand & BAYCOM)? RCTRxCP|TCRTxCP : RCRTxCP|TCTRxCP);\n\t\t\tOutReg(scc->ctrl, R14, DISDPLL);\n\t\t\tbreak;\n\n\t}\n\t\n\tset_speed(scc);\t\t\t \n\t\n\tif(scc->enhanced)\n\t{\n\t\tor(scc,R15,SHDLCE|FIFOE);\t \n\t\twr(scc,R7,AUTOEOM);\n\t}\n\n\tif(scc->kiss.softdcd || (InReg(scc->ctrl,R0) & DCD))\n\t\t\t\t\t\t \n\t{\n\t\tstart_hunt(scc);\n\t}\n\t\n\t \n\n\twr(scc,R15, BRKIE|TxUIE|(scc->kiss.softdcd? SYNCIE:DCDIE));\n\n\tOutb(scc->ctrl,RES_EXT_INT);\t \n\tOutb(scc->ctrl,RES_EXT_INT);\t \n\n\tor(scc,R1,INT_ALL_Rx|TxINT_ENAB|EXT_INT_ENAB);  \n\t\n\tscc->status = InReg(scc->ctrl,R0);\t \n\t\n\tor(scc,R9,MIE);\t\t\t \n\t\n\tscc_init_timer(scc);\n\t\t\t\n\tenable_irq(scc->irq);\n}\n\n\n\n\n \n \n \n\n\n \n\nstatic void scc_key_trx(struct scc_channel *scc, char tx)\n{\n\tunsigned int time_const;\n\t\t\n\tif (scc->brand & PRIMUS)\n\t\tOutb(scc->ctrl + 4, scc->option | (tx? 0x80 : 0));\n\n\tif (scc->modem.speed < 300) \n\t\tscc->modem.speed = 1200;\n\n\ttime_const = (unsigned) (scc->clock / (scc->modem.speed * (tx? 2:64))) - 2;\n\n\tdisable_irq(scc->irq);\n\n\tif (tx)\n\t{\n\t\tor(scc, R1, TxINT_ENAB);\t \n\t\tor(scc, R15, TxUIE);\n\t}\n\n\tif (scc->modem.clocksrc == CLK_DPLL)\n\t{\t\t\t\t \n\t\tif (tx)\n\t\t{\n#ifdef CONFIG_SCC_TRXECHO\n\t\t\tcl(scc, R3, RxENABLE|ENT_HM);\t \n\t\t\tcl(scc, R15, DCDIE|SYNCIE);\t \n#endif\n\t\t\tset_brg(scc, time_const);\t \n\n\t\t\t \n\t\t\twr(scc, R11, RCDPLL|TCBR|TRxCOI|TRxCBR);\n\t\t\t\n\t\t\t \n\t\t\tif (scc->kiss.tx_inhibit)\n\t\t\t{\n\t\t\t\tor(scc,R5, TxENAB);\n\t\t\t\tscc->wreg[R5] |= RTS;\n\t\t\t} else {\n\t\t\t\tor(scc,R5,RTS|TxENAB);\t \n\t\t\t}\n\t\t} else {\n\t\t\tcl(scc,R5,RTS|TxENAB);\n\t\t\t\n\t\t\tset_brg(scc, time_const);\t \n\t\t\t\n\t\t\t \n\t\t\twr(scc, R11, RCDPLL|TCDPLL|TRxCOI|TRxCDP);\n\n#ifndef CONFIG_SCC_TRXECHO\n\t\t\tif (scc->kiss.softdcd)\n#endif\n\t\t\t{\n\t\t\t\tor(scc,R15, scc->kiss.softdcd? SYNCIE:DCDIE);\n\t\t\t\tstart_hunt(scc);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (tx)\n\t\t{\n#ifdef CONFIG_SCC_TRXECHO\n\t\t\tif (scc->kiss.fulldup == KISS_DUPLEX_HALF)\n\t\t\t{\n\t\t\t\tcl(scc, R3, RxENABLE);\n\t\t\t\tcl(scc, R15, DCDIE|SYNCIE);\n\t\t\t}\n#endif\n\t\t\t\t\n\t\t\tif (scc->kiss.tx_inhibit)\n\t\t\t{\n\t\t\t\tor(scc,R5, TxENAB);\n\t\t\t\tscc->wreg[R5] |= RTS;\n\t\t\t} else {\t\n\t\t\t\tor(scc,R5,RTS|TxENAB);\t \n\t\t\t}\n\t\t} else {\n\t\t\tcl(scc,R5,RTS|TxENAB);\t\t \n\n\t\t\tif ((scc->kiss.fulldup == KISS_DUPLEX_HALF) &&\n#ifndef CONFIG_SCC_TRXECHO\n\t\t\t    scc->kiss.softdcd)\n#else\n\t\t\t    1)\n#endif\n\t\t\t{\n\t\t\t\tor(scc, R15, scc->kiss.softdcd? SYNCIE:DCDIE);\n\t\t\t\tstart_hunt(scc);\n\t\t\t}\n\t\t}\n\t}\n\n\tenable_irq(scc->irq);\n}\n\n\n \n\nstatic void __scc_start_tx_timer(struct scc_channel *scc,\n\t\t\t\t void (*handler)(struct timer_list *t),\n\t\t\t\t unsigned long when)\n{\n\tdel_timer(&scc->tx_t);\n\n\tif (when == 0)\n\t{\n\t\thandler(&scc->tx_t);\n\t} else \n\tif (when != TIMER_OFF)\n\t{\n\t\tscc->tx_t.function = handler;\n\t\tscc->tx_t.expires = jiffies + (when*HZ)/100;\n\t\tadd_timer(&scc->tx_t);\n\t}\n}\n\nstatic void scc_start_tx_timer(struct scc_channel *scc,\n\t\t\t       void (*handler)(struct timer_list *t),\n\t\t\t       unsigned long when)\n{\n\tunsigned long flags;\n\t\n\tspin_lock_irqsave(&scc->lock, flags);\n\t__scc_start_tx_timer(scc, handler, when);\n\tspin_unlock_irqrestore(&scc->lock, flags);\n}\n\nstatic void scc_start_defer(struct scc_channel *scc)\n{\n\tunsigned long flags;\n\t\n\tspin_lock_irqsave(&scc->lock, flags);\n\tdel_timer(&scc->tx_wdog);\n\t\n\tif (scc->kiss.maxdefer != 0 && scc->kiss.maxdefer != TIMER_OFF)\n\t{\n\t\tscc->tx_wdog.function = t_busy;\n\t\tscc->tx_wdog.expires = jiffies + HZ*scc->kiss.maxdefer;\n\t\tadd_timer(&scc->tx_wdog);\n\t}\n\tspin_unlock_irqrestore(&scc->lock, flags);\n}\n\nstatic void scc_start_maxkeyup(struct scc_channel *scc)\n{\n\tunsigned long flags;\n\t\n\tspin_lock_irqsave(&scc->lock, flags);\n\tdel_timer(&scc->tx_wdog);\n\t\n\tif (scc->kiss.maxkeyup != 0 && scc->kiss.maxkeyup != TIMER_OFF)\n\t{\n\t\tscc->tx_wdog.function = t_maxkeyup;\n\t\tscc->tx_wdog.expires = jiffies + HZ*scc->kiss.maxkeyup;\n\t\tadd_timer(&scc->tx_wdog);\n\t}\n\tspin_unlock_irqrestore(&scc->lock, flags);\n}\n\n \n\nstatic void scc_tx_done(struct scc_channel *scc)\n{\n\t \n\t\t\t\t \n\tswitch (scc->kiss.fulldup)\n\t{\n\t\tcase KISS_DUPLEX_LINK:\n\t\t\tscc->stat.tx_state = TXS_IDLE2;\n\t\t\tif (scc->kiss.idletime != TIMER_OFF)\n\t\t\t\tscc_start_tx_timer(scc, t_idle,\n\t\t\t\t\t\t   scc->kiss.idletime*100);\n\t\t\tbreak;\n\t\tcase KISS_DUPLEX_OPTIMA:\n\t\t\tscc_notify(scc, HWEV_ALL_SENT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tscc->stat.tx_state = TXS_BUSY;\n\t\t\tscc_start_tx_timer(scc, t_tail, scc->kiss.tailtime);\n\t}\n\n\tnetif_wake_queue(scc->dev);\n}\n\n\nstatic unsigned char Rand = 17;\n\nstatic inline int is_grouped(struct scc_channel *scc)\n{\n\tint k;\n\tstruct scc_channel *scc2;\n\tunsigned char grp1, grp2;\n\n\tgrp1 = scc->kiss.group;\n\t\n\tfor (k = 0; k < (Nchips * 2); k++)\n\t{\n\t\tscc2 = &SCC_Info[k];\n\t\tgrp2 = scc2->kiss.group;\n\t\t\n\t\tif (scc2 == scc || !(scc2->dev && grp2))\n\t\t\tcontinue;\n\t\t\n\t\tif ((grp1 & 0x3f) == (grp2 & 0x3f))\n\t\t{\n\t\t\tif ( (grp1 & TXGROUP) && (scc2->wreg[R5] & RTS) )\n\t\t\t\treturn 1;\n\t\t\t\n\t\t\tif ( (grp1 & RXGROUP) && scc2->dcd )\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \n\nstatic void t_dwait(struct timer_list *t)\n{\n\tstruct scc_channel *scc = from_timer(scc, t, tx_t);\n\t\n\tif (scc->stat.tx_state == TXS_WAIT)\t \n\t{\n\t\tif (skb_queue_empty(&scc->tx_queue)) {\t \n\t\t\tscc->stat.tx_state = TXS_IDLE;\n\t\t\tnetif_wake_queue(scc->dev);\t \n\t\t\treturn;\n\t\t}\n\n\t\tscc->stat.tx_state = TXS_BUSY;\n\t}\n\n\tif (scc->kiss.fulldup == KISS_DUPLEX_HALF)\n\t{\n\t\tRand = Rand * 17 + 31;\n\t\t\n\t\tif (scc->dcd || (scc->kiss.persist) < Rand || (scc->kiss.group && is_grouped(scc)) )\n\t\t{\n\t\t\tscc_start_defer(scc);\n\t\t\tscc_start_tx_timer(scc, t_dwait, scc->kiss.slottime);\n\t\t\treturn ;\n\t\t}\n\t}\n\n\tif ( !(scc->wreg[R5] & RTS) )\n\t{\n\t\tscc_key_trx(scc, TX_ON);\n\t\tscc_start_tx_timer(scc, t_txdelay, scc->kiss.txdelay);\n\t} else {\n\t\tscc_start_tx_timer(scc, t_txdelay, 0);\n\t}\n}\n\n\n \n\nstatic void t_txdelay(struct timer_list *t)\n{\n\tstruct scc_channel *scc = from_timer(scc, t, tx_t);\n\n\tscc_start_maxkeyup(scc);\n\n\tif (scc->tx_buff == NULL)\n\t{\n\t\tdisable_irq(scc->irq);\n\t\tscc_txint(scc);\t\n\t\tenable_irq(scc->irq);\n\t}\n}\n\t\n\n \n\nstatic void t_tail(struct timer_list *t)\n{\n\tstruct scc_channel *scc = from_timer(scc, t, tx_t);\n\tunsigned long flags;\n\t\n\tspin_lock_irqsave(&scc->lock, flags); \n\tdel_timer(&scc->tx_wdog);\n\tscc_key_trx(scc, TX_OFF);\n\tspin_unlock_irqrestore(&scc->lock, flags);\n\n\tif (scc->stat.tx_state == TXS_TIMEOUT)\t\t \n\t{\n\t\tscc->stat.tx_state = TXS_WAIT;\n\t\tscc_start_tx_timer(scc, t_dwait, scc->kiss.mintime*100);\n\t\treturn;\n\t}\n\n\tscc->stat.tx_state = TXS_IDLE;\n\tnetif_wake_queue(scc->dev);\n}\n\n\n \n\nstatic void t_busy(struct timer_list *t)\n{\n\tstruct scc_channel *scc = from_timer(scc, t, tx_wdog);\n\n\tdel_timer(&scc->tx_t);\n\tnetif_stop_queue(scc->dev);\t \n\n\tscc_discard_buffers(scc);\n\tscc->stat.txerrs++;\n\tscc->stat.tx_state = TXS_IDLE;\n\n\tnetif_wake_queue(scc->dev);\t\n}\n\n \n\nstatic void t_maxkeyup(struct timer_list *t)\n{\n\tstruct scc_channel *scc = from_timer(scc, t, tx_wdog);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&scc->lock, flags);\n\t \n\n\tnetif_stop_queue(scc->dev);\n\tscc_discard_buffers(scc);\n\n\tdel_timer(&scc->tx_t);\n\n\tcl(scc, R1, TxINT_ENAB);\t \n\tcl(scc, R15, TxUIE);\t\t \n\tOutReg(scc->ctrl, R0, RES_Tx_P);\n\n\tspin_unlock_irqrestore(&scc->lock, flags);\n\n\tscc->stat.txerrs++;\n\tscc->stat.tx_state = TXS_TIMEOUT;\n\tscc_start_tx_timer(scc, t_tail, scc->kiss.tailtime);\n}\n\n \n\nstatic void t_idle(struct timer_list *t)\n{\n\tstruct scc_channel *scc = from_timer(scc, t, tx_t);\n\t\n\tdel_timer(&scc->tx_wdog);\n\n\tscc_key_trx(scc, TX_OFF);\n\tif(scc->kiss.mintime)\n\t\tscc_start_tx_timer(scc, t_dwait, scc->kiss.mintime*100);\n\tscc->stat.tx_state = TXS_WAIT;\n}\n\nstatic void scc_init_timer(struct scc_channel *scc)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&scc->lock, flags);\t\n\tscc->stat.tx_state = TXS_IDLE;\n\tspin_unlock_irqrestore(&scc->lock, flags);\n}\n\n\n \n \n \n\n\n \n\n#define CAST(x) (unsigned long)(x)\n\nstatic unsigned int scc_set_param(struct scc_channel *scc, unsigned int cmd, unsigned int arg)\n{\n\tswitch (cmd)\n\t{\n\t\tcase PARAM_TXDELAY:\tscc->kiss.txdelay=arg;\t\tbreak;\n\t\tcase PARAM_PERSIST:\tscc->kiss.persist=arg;\t\tbreak;\n\t\tcase PARAM_SLOTTIME:\tscc->kiss.slottime=arg;\t\tbreak;\n\t\tcase PARAM_TXTAIL:\tscc->kiss.tailtime=arg;\t\tbreak;\n\t\tcase PARAM_FULLDUP:\tscc->kiss.fulldup=arg;\t\tbreak;\n\t\tcase PARAM_DTR:\t\tbreak;  \n\t\tcase PARAM_GROUP:\tscc->kiss.group=arg;\t\tbreak;\n\t\tcase PARAM_IDLE:\tscc->kiss.idletime=arg;\t\tbreak;\n\t\tcase PARAM_MIN:\t\tscc->kiss.mintime=arg;\t\tbreak;\n\t\tcase PARAM_MAXKEY:\tscc->kiss.maxkeyup=arg;\t\tbreak;\n\t\tcase PARAM_WAIT:\tscc->kiss.waittime=arg;\t\tbreak;\n\t\tcase PARAM_MAXDEFER:\tscc->kiss.maxdefer=arg;\t\tbreak;\n\t\tcase PARAM_TX:\t\tscc->kiss.tx_inhibit=arg;\tbreak;\n\n\t\tcase PARAM_SOFTDCD:\t\n\t\t\tscc->kiss.softdcd=arg;\n\t\t\tif (arg)\n\t\t\t{\n\t\t\t\tor(scc, R15, SYNCIE);\n\t\t\t\tcl(scc, R15, DCDIE);\n\t\t\t\tstart_hunt(scc);\n\t\t\t} else {\n\t\t\t\tor(scc, R15, DCDIE);\n\t\t\t\tcl(scc, R15, SYNCIE);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\t\n\t\tcase PARAM_SPEED:\n\t\t\tif (arg < 256)\n\t\t\t\tscc->modem.speed=arg*100;\n\t\t\telse\n\t\t\t\tscc->modem.speed=arg;\n\n\t\t\tif (scc->stat.tx_state == 0)\t \n\t\t\t\tset_speed(scc);\n\t\t\tbreak;\n\t\t\t\n\t\tcase PARAM_RTS:\t\n\t\t\tif ( !(scc->wreg[R5] & RTS) )\n\t\t\t{\n\t\t\t\tif (arg != TX_OFF) {\n\t\t\t\t\tscc_key_trx(scc, TX_ON);\n\t\t\t\t\tscc_start_tx_timer(scc, t_txdelay, scc->kiss.txdelay);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (arg == TX_OFF)\n\t\t\t\t{\n\t\t\t\t\tscc->stat.tx_state = TXS_BUSY;\n\t\t\t\t\tscc_start_tx_timer(scc, t_tail, scc->kiss.tailtime);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase PARAM_HWEVENT:\n\t\t\tscc_notify(scc, scc->dcd? HWEV_DCD_ON:HWEV_DCD_OFF);\n\t\t\tbreak;\n\n\t\tdefault:\t\treturn -EINVAL;\n\t}\n\t\n\treturn 0;\n}\n\n\n \nstatic unsigned long scc_get_param(struct scc_channel *scc, unsigned int cmd)\n{\n\tswitch (cmd)\n\t{\n\t\tcase PARAM_TXDELAY:\treturn CAST(scc->kiss.txdelay);\n\t\tcase PARAM_PERSIST:\treturn CAST(scc->kiss.persist);\n\t\tcase PARAM_SLOTTIME:\treturn CAST(scc->kiss.slottime);\n\t\tcase PARAM_TXTAIL:\treturn CAST(scc->kiss.tailtime);\n\t\tcase PARAM_FULLDUP:\treturn CAST(scc->kiss.fulldup);\n\t\tcase PARAM_SOFTDCD:\treturn CAST(scc->kiss.softdcd);\n\t\tcase PARAM_DTR:\t\treturn CAST((scc->wreg[R5] & DTR)? 1:0);\n\t\tcase PARAM_RTS:\t\treturn CAST((scc->wreg[R5] & RTS)? 1:0);\n\t\tcase PARAM_SPEED:\treturn CAST(scc->modem.speed);\n\t\tcase PARAM_GROUP:\treturn CAST(scc->kiss.group);\n\t\tcase PARAM_IDLE:\treturn CAST(scc->kiss.idletime);\n\t\tcase PARAM_MIN:\t\treturn CAST(scc->kiss.mintime);\n\t\tcase PARAM_MAXKEY:\treturn CAST(scc->kiss.maxkeyup);\n\t\tcase PARAM_WAIT:\treturn CAST(scc->kiss.waittime);\n\t\tcase PARAM_MAXDEFER:\treturn CAST(scc->kiss.maxdefer);\n\t\tcase PARAM_TX:\t\treturn CAST(scc->kiss.tx_inhibit);\n\t\tdefault:\t\treturn NO_SUCH_PARAM;\n\t}\n\n}\n\n#undef CAST\n\n \n \n \n\nstatic void scc_stop_calibrate(struct timer_list *t)\n{\n\tstruct scc_channel *scc = from_timer(scc, t, tx_wdog);\n\tunsigned long flags;\n\t\n\tspin_lock_irqsave(&scc->lock, flags);\n\tdel_timer(&scc->tx_wdog);\n\tscc_key_trx(scc, TX_OFF);\n\twr(scc, R6, 0);\n\twr(scc, R7, FLAG);\n\tOutb(scc->ctrl,RES_EXT_INT);\t \n\tOutb(scc->ctrl,RES_EXT_INT);\n\n\tnetif_wake_queue(scc->dev);\n\tspin_unlock_irqrestore(&scc->lock, flags);\n}\n\n\nstatic void\nscc_start_calibrate(struct scc_channel *scc, int duration, unsigned char pattern)\n{\n\tunsigned long flags;\n\t\n\tspin_lock_irqsave(&scc->lock, flags);\n\tnetif_stop_queue(scc->dev);\n\tscc_discard_buffers(scc);\n\n\tdel_timer(&scc->tx_wdog);\n\n\tscc->tx_wdog.function = scc_stop_calibrate;\n\tscc->tx_wdog.expires = jiffies + HZ*duration;\n\tadd_timer(&scc->tx_wdog);\n\n\t \t\n\twr(scc, R6, 0);\n\twr(scc, R7, pattern);\n\n\t \n\n\tOutb(scc->ctrl,RES_EXT_INT);\t \n\tOutb(scc->ctrl,RES_EXT_INT);\n\n\tscc_key_trx(scc, TX_ON);\n\tspin_unlock_irqrestore(&scc->lock, flags);\n}\n\n \n \n \n\n \n\nstatic void z8530_init(void)\n{\n\tstruct scc_channel *scc;\n\tint chip, k;\n\tunsigned long flags;\n\tchar *flag;\n\n\n\tprintk(KERN_INFO \"Init Z8530 driver: %u channels, IRQ\", Nchips*2);\n\t\n\tflag=\" \";\n\tfor (k = 0; k < nr_irqs; k++)\n\t\tif (Ivec[k].used) \n\t\t{\n\t\t\tprintk(\"%s%d\", flag, k);\n\t\t\tflag=\",\";\n\t\t}\n\tprintk(\"\\n\");\n\n\n\t \n\tfor (chip = 0; chip < Nchips; chip++)\n\t{\n\t\tscc=&SCC_Info[2*chip];\n\t\tif (!scc->ctrl) continue;\n\n\t\t \n\n\t\tif(scc->brand & EAGLE)\t\t\t \n\t\t\tOutb(scc->special,0x08);\t \n\t\t\t\n\t\tif(scc->brand & (PC100 | PRIMUS))\t \n\t\t\tOutb(scc->special,scc->option);\t \n\n\t\t\t\n\t\t \n\n\t\tspin_lock_irqsave(&scc->lock, flags);\n\t\t\t\t\n\t\tOutb(scc->ctrl, 0);\n\t\tOutReg(scc->ctrl,R9,FHWRES);\t\t \n\t\tudelay(100);\t\t\t\t \n\t\twr(scc, R2, chip*16);\t\t\t \n\t\twr(scc, R9, VIS);\t\t\t \n\t\tspin_unlock_irqrestore(&scc->lock, flags);\t\t\n        }\n\n \n\tDriver_Initialized = 1;\n}\n\n \n\nstatic int scc_net_alloc(const char *name, struct scc_channel *scc)\n{\n\tint err;\n\tstruct net_device *dev;\n\n\tdev = alloc_netdev(0, name, NET_NAME_UNKNOWN, scc_net_setup);\n\tif (!dev) \n\t\treturn -ENOMEM;\n\n\tdev->ml_priv = scc;\n\tscc->dev = dev;\n\tspin_lock_init(&scc->lock);\n\ttimer_setup(&scc->tx_t, NULL, 0);\n\ttimer_setup(&scc->tx_wdog, NULL, 0);\n\n\terr = register_netdevice(dev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: can't register network device (%d)\\n\", \n\t\t       name, err);\n\t\tfree_netdev(dev);\n\t\tscc->dev = NULL;\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n\n\n \n \n \n\nstatic const struct net_device_ops scc_netdev_ops = {\n\t.ndo_open            = scc_net_open,\n\t.ndo_stop\t     = scc_net_close,\n\t.ndo_start_xmit\t     = scc_net_tx,\n\t.ndo_set_mac_address = scc_net_set_mac_address,\n\t.ndo_get_stats       = scc_net_get_stats,\n\t.ndo_siocdevprivate  = scc_net_siocdevprivate,\n};\n\n \n\nstatic void scc_net_setup(struct net_device *dev)\n{\n\tdev->tx_queue_len    = 16;\t \n\n\tdev->netdev_ops\t     = &scc_netdev_ops;\n\tdev->header_ops      = &ax25_header_ops;\n\n\tdev->flags      = 0;\n\n\tdev->type = ARPHRD_AX25;\n\tdev->hard_header_len = AX25_MAX_HEADER_LEN + AX25_BPQ_HEADER_LEN;\n\tdev->mtu = AX25_DEF_PACLEN;\n\tdev->addr_len = AX25_ADDR_LEN;\n\n\tmemcpy(dev->broadcast, &ax25_bcast,  AX25_ADDR_LEN);\n\tdev_addr_set(dev, (u8 *)&ax25_defaddr);\n}\n\n \n\nstatic int scc_net_open(struct net_device *dev)\n{\n\tstruct scc_channel *scc = (struct scc_channel *) dev->ml_priv;\n\n\tif (!scc->init)\n\t\treturn -EINVAL;\n\n\tscc->tx_buff = NULL;\n\tskb_queue_head_init(&scc->tx_queue);\n \n\tinit_channel(scc);\n\n\tnetif_start_queue(dev);\n\treturn 0;\n}\n\n \n\nstatic int scc_net_close(struct net_device *dev)\n{\n\tstruct scc_channel *scc = (struct scc_channel *) dev->ml_priv;\n\tunsigned long flags;\n\n\tnetif_stop_queue(dev);\n\n\tspin_lock_irqsave(&scc->lock, flags);\t\n\tOutb(scc->ctrl,0);\t\t \n\twr(scc,R1,0);\t\t\t \n\twr(scc,R3,0);\n\tspin_unlock_irqrestore(&scc->lock, flags);\n\n\tdel_timer_sync(&scc->tx_t);\n\tdel_timer_sync(&scc->tx_wdog);\n\t\n\tscc_discard_buffers(scc);\n\n\treturn 0;\n}\n\n \n\nstatic void scc_net_rx(struct scc_channel *scc, struct sk_buff *skb)\n{\n\tif (skb->len == 0) {\n\t\tdev_kfree_skb_irq(skb);\n\t\treturn;\n\t}\n\t\t\n\tscc->dev_stat.rx_packets++;\n\tscc->dev_stat.rx_bytes += skb->len;\n\n\tskb->protocol = ax25_type_trans(skb, scc->dev);\n\t\n\tnetif_rx(skb);\n}\n\n \n\nstatic netdev_tx_t scc_net_tx(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct scc_channel *scc = (struct scc_channel *) dev->ml_priv;\n\tunsigned long flags;\n\tchar kisscmd;\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn ax25_ip_xmit(skb);\n\n\tif (skb->len > scc->stat.bufsize || skb->len < 2) {\n\t\tscc->dev_stat.tx_dropped++;\t \n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\t\n\tscc->dev_stat.tx_packets++;\n\tscc->dev_stat.tx_bytes += skb->len;\n\tscc->stat.txframes++;\n\t\n\tkisscmd = *skb->data & 0x1f;\n\tskb_pull(skb, 1);\n\n\tif (kisscmd) {\n\t\tscc_set_param(scc, kisscmd, *skb->data);\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tspin_lock_irqsave(&scc->lock, flags);\n\t\t\n\tif (skb_queue_len(&scc->tx_queue) > scc->dev->tx_queue_len) {\n\t\tstruct sk_buff *skb_del;\n\t\tskb_del = skb_dequeue(&scc->tx_queue);\n\t\tdev_kfree_skb_irq(skb_del);\n\t}\n\tskb_queue_tail(&scc->tx_queue, skb);\n\tnetif_trans_update(dev);\n\t\n\n\t \n\n\tif(scc->stat.tx_state == TXS_IDLE || scc->stat.tx_state == TXS_IDLE2) {\n\t\tscc->stat.tx_state = TXS_BUSY;\n\t\tif (scc->kiss.fulldup == KISS_DUPLEX_HALF)\n\t\t\t__scc_start_tx_timer(scc, t_dwait, scc->kiss.waittime);\n\t\telse\n\t\t\t__scc_start_tx_timer(scc, t_dwait, 0);\n\t}\n\tspin_unlock_irqrestore(&scc->lock, flags);\n\treturn NETDEV_TX_OK;\n}\n\n \n\n \n\nstatic int scc_net_siocdevprivate(struct net_device *dev,\n\t\t\t\t  struct ifreq *ifr, void __user *arg, int cmd)\n{\n\tstruct scc_kiss_cmd kiss_cmd;\n\tstruct scc_mem_config memcfg;\n\tstruct scc_hw_config hwcfg;\n\tstruct scc_calibrate cal;\n\tstruct scc_channel *scc = (struct scc_channel *) dev->ml_priv;\n\tint chan;\n\tunsigned char device_name[IFNAMSIZ];\n\t\n\tif (!Driver_Initialized)\n\t{\n\t\tif (cmd == SIOCSCCCFG)\n\t\t{\n\t\t\tint found = 1;\n\n\t\t\tif (!capable(CAP_SYS_RAWIO)) return -EPERM;\n\t\t\tif (in_compat_syscall())\n\t\t\t\treturn -EOPNOTSUPP;\n\n\t\t\tif (!arg) return -EFAULT;\n\n\t\t\tif (Nchips >= SCC_MAXCHIPS) \n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (copy_from_user(&hwcfg, arg, sizeof(hwcfg)))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (hwcfg.irq == 2) hwcfg.irq = 9;\n\n\t\t\tif (hwcfg.irq < 0 || hwcfg.irq >= nr_irqs)\n\t\t\t\treturn -EINVAL;\n\t\t\t\t\n\t\t\tif (!Ivec[hwcfg.irq].used && hwcfg.irq)\n\t\t\t{\n\t\t\t\tif (request_irq(hwcfg.irq, scc_isr,\n\t\t\t\t\t\t0, \"AX.25 SCC\",\n\t\t\t\t\t\t(void *)(long) hwcfg.irq))\n\t\t\t\t\tprintk(KERN_WARNING \"z8530drv: warning, cannot get IRQ %d\\n\", hwcfg.irq);\n\t\t\t\telse\n\t\t\t\t\tIvec[hwcfg.irq].used = 1;\n\t\t\t}\n\n\t\t\tif (hwcfg.vector_latch && !Vector_Latch) {\n\t\t\t\tif (!request_region(hwcfg.vector_latch, 1, \"scc vector latch\"))\n\t\t\t\t\tprintk(KERN_WARNING \"z8530drv: warning, cannot reserve vector latch port 0x%lx\\n, disabled.\", hwcfg.vector_latch);\n\t\t\t\telse\n\t\t\t\t\tVector_Latch = hwcfg.vector_latch;\n\t\t\t}\n\n\t\t\tif (hwcfg.clock == 0)\n\t\t\t\thwcfg.clock = SCC_DEFAULT_CLOCK;\n\n#ifndef SCC_DONT_CHECK\n\n\t\t\tif(request_region(hwcfg.ctrl_a, 1, \"scc-probe\"))\n\t\t\t{\n\t\t\t\tdisable_irq(hwcfg.irq);\n\t\t\t\tOutb(hwcfg.ctrl_a, 0);\n\t\t\t\tOutReg(hwcfg.ctrl_a, R9, FHWRES);\n\t\t\t\tudelay(100);\n\t\t\t\tOutReg(hwcfg.ctrl_a,R13,0x55);\t\t \n\t\t\t\tudelay(5);\n\n\t\t\t\tif (InReg(hwcfg.ctrl_a,R13) != 0x55)\n\t\t\t\t\tfound = 0;\n\t\t\t\tenable_irq(hwcfg.irq);\n\t\t\t\trelease_region(hwcfg.ctrl_a, 1);\n\t\t\t}\n\t\t\telse\n\t\t\t\tfound = 0;\n#endif\n\n\t\t\tif (found)\n\t\t\t{\n\t\t\t\tSCC_Info[2*Nchips  ].ctrl = hwcfg.ctrl_a;\n\t\t\t\tSCC_Info[2*Nchips  ].data = hwcfg.data_a;\n\t\t\t\tSCC_Info[2*Nchips  ].irq  = hwcfg.irq;\n\t\t\t\tSCC_Info[2*Nchips+1].ctrl = hwcfg.ctrl_b;\n\t\t\t\tSCC_Info[2*Nchips+1].data = hwcfg.data_b;\n\t\t\t\tSCC_Info[2*Nchips+1].irq  = hwcfg.irq;\n\t\t\t\n\t\t\t\tSCC_ctrl[Nchips].chan_A = hwcfg.ctrl_a;\n\t\t\t\tSCC_ctrl[Nchips].chan_B = hwcfg.ctrl_b;\n\t\t\t\tSCC_ctrl[Nchips].irq    = hwcfg.irq;\n\t\t\t}\n\n\n\t\t\tfor (chan = 0; chan < 2; chan++)\n\t\t\t{\n\t\t\t\tsprintf(device_name, \"%s%i\", SCC_DriverName, 2*Nchips+chan);\n\n\t\t\t\tSCC_Info[2*Nchips+chan].special = hwcfg.special;\n\t\t\t\tSCC_Info[2*Nchips+chan].clock = hwcfg.clock;\n\t\t\t\tSCC_Info[2*Nchips+chan].brand = hwcfg.brand;\n\t\t\t\tSCC_Info[2*Nchips+chan].option = hwcfg.option;\n\t\t\t\tSCC_Info[2*Nchips+chan].enhanced = hwcfg.escc;\n\n#ifdef SCC_DONT_CHECK\n\t\t\t\tprintk(KERN_INFO \"%s: data port = 0x%3.3x  control port = 0x%3.3x\\n\",\n\t\t\t\t\tdevice_name, \n\t\t\t\t\tSCC_Info[2*Nchips+chan].data, \n\t\t\t\t\tSCC_Info[2*Nchips+chan].ctrl);\n\n#else\n\t\t\t\tprintk(KERN_INFO \"%s: data port = 0x%3.3lx  control port = 0x%3.3lx -- %s\\n\",\n\t\t\t\t\tdevice_name,\n\t\t\t\t\tchan? hwcfg.data_b : hwcfg.data_a, \n\t\t\t\t\tchan? hwcfg.ctrl_b : hwcfg.ctrl_a,\n\t\t\t\t\tfound? \"found\" : \"missing\");\n#endif\n\n\t\t\t\tif (found)\n\t\t\t\t{\n\t\t\t\t\trequest_region(SCC_Info[2*Nchips+chan].ctrl, 1, \"scc ctrl\");\n\t\t\t\t\trequest_region(SCC_Info[2*Nchips+chan].data, 1, \"scc data\");\n\t\t\t\t\tif (Nchips+chan != 0 &&\n\t\t\t\t\t    scc_net_alloc(device_name, \n\t\t\t\t\t\t\t  &SCC_Info[2*Nchips+chan]))\n\t\t\t\t\t    return -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (found) Nchips++;\n\t\t\t\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif (cmd == SIOCSCCINI)\n\t\t{\n\t\t\tif (!capable(CAP_SYS_RAWIO))\n\t\t\t\treturn -EPERM;\n\t\t\t\t\n\t\t\tif (Nchips == 0)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tz8530_init();\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\treturn -EINVAL;\t \n\t}\n\t\n\tif (!scc->init)\n\t{\n\t\tif (cmd == SIOCSCCCHANINI)\n\t\t{\n\t\t\tif (!capable(CAP_NET_ADMIN)) return -EPERM;\n\t\t\tif (!arg) return -EINVAL;\n\t\t\t\n\t\t\tscc->stat.bufsize   = SCC_BUFSIZE;\n\n\t\t\tif (copy_from_user(&scc->modem, arg, sizeof(struct scc_modem)))\n\t\t\t\treturn -EINVAL;\n\t\t\t\n\t\t\t \n\t\t\n\t\t\tif (scc->modem.speed < 4800)\n\t\t\t{\n\t\t\t\tscc->kiss.txdelay = 36;\t\t \n\t\t\t\tscc->kiss.persist = 42;\t\t \t\t\t \n\t\t\t\tscc->kiss.slottime = 16;\t \n\t\t\t\tscc->kiss.tailtime = 4;\t\t \n\t\t\t\tscc->kiss.fulldup = 0;\t\t \n\t\t\t\tscc->kiss.waittime = 50;\t \n\t\t\t\tscc->kiss.maxkeyup = 10;\t \n\t\t\t\tscc->kiss.mintime = 3;\t\t \n\t\t\t\tscc->kiss.idletime = 30;\t \n\t\t\t\tscc->kiss.maxdefer = 120;\t \n\t\t\t\tscc->kiss.softdcd = 0;\t\t \n\t\t\t} else {\n\t\t\t\tscc->kiss.txdelay = 10;\t\t \n\t\t\t\tscc->kiss.persist = 64;\t\t \t\t\t \n\t\t\t\tscc->kiss.slottime = 8;\t\t \n\t\t\t\tscc->kiss.tailtime = 1;\t\t \n\t\t\t\tscc->kiss.fulldup = 0;\t\t \n\t\t\t\tscc->kiss.waittime = 50;\t \n\t\t\t\tscc->kiss.maxkeyup = 7;\t\t \n\t\t\t\tscc->kiss.mintime = 3;\t\t \n\t\t\t\tscc->kiss.idletime = 30;\t \n\t\t\t\tscc->kiss.maxdefer = 120;\t \n\t\t\t\tscc->kiss.softdcd = 0;\t\t \n\t\t\t}\n\t\t\t\n\t\t\tscc->tx_buff = NULL;\n\t\t\tskb_queue_head_init(&scc->tx_queue);\n\t\t\tscc->init = 1;\n\t\t\t\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\treturn -EINVAL;\n\t}\n\t\n\tswitch(cmd)\n\t{\n\t\tcase SIOCSCCRESERVED:\n\t\t\treturn -ENOIOCTLCMD;\n\n\t\tcase SIOCSCCSMEM:\n\t\t\tif (!capable(CAP_SYS_RAWIO)) return -EPERM;\n\t\t\tif (!arg || copy_from_user(&memcfg, arg, sizeof(memcfg)))\n\t\t\t\treturn -EINVAL;\n\t\t\tscc->stat.bufsize   = memcfg.bufsize;\n\t\t\treturn 0;\n\t\t\n\t\tcase SIOCSCCGSTAT:\n\t\t\tif (!arg || copy_to_user(arg, &scc->stat, sizeof(scc->stat)))\n\t\t\t\treturn -EINVAL;\n\t\t\treturn 0;\n\t\t\n\t\tcase SIOCSCCGKISS:\n\t\t\tif (!arg || copy_from_user(&kiss_cmd, arg, sizeof(kiss_cmd)))\n\t\t\t\treturn -EINVAL;\n\t\t\tkiss_cmd.param = scc_get_param(scc, kiss_cmd.command);\n\t\t\tif (copy_to_user(arg, &kiss_cmd, sizeof(kiss_cmd)))\n\t\t\t\treturn -EINVAL;\n\t\t\treturn 0;\n\t\t\n\t\tcase SIOCSCCSKISS:\n\t\t\tif (!capable(CAP_NET_ADMIN)) return -EPERM;\n\t\t\tif (!arg || copy_from_user(&kiss_cmd, arg, sizeof(kiss_cmd)))\n\t\t\t\treturn -EINVAL;\n\t\t\treturn scc_set_param(scc, kiss_cmd.command, kiss_cmd.param);\n\t\t\n\t\tcase SIOCSCCCAL:\n\t\t\tif (!capable(CAP_SYS_RAWIO)) return -EPERM;\n\t\t\tif (!arg || copy_from_user(&cal, arg, sizeof(cal)) || cal.time == 0)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tscc_start_calibrate(scc, cal.time, cal.pattern);\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\treturn -ENOIOCTLCMD;\n\t\t\n\t}\n\t\n\treturn -EINVAL;\n}\n\n \n\nstatic int scc_net_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct sockaddr *sa = (struct sockaddr *) addr;\n\tdev_addr_set(dev, sa->sa_data);\n\treturn 0;\n}\n\n \n\nstatic struct net_device_stats *scc_net_get_stats(struct net_device *dev)\n{\n\tstruct scc_channel *scc = (struct scc_channel *) dev->ml_priv;\n\t\n\tscc->dev_stat.rx_errors = scc->stat.rxerrs + scc->stat.rx_over;\n\tscc->dev_stat.tx_errors = scc->stat.txerrs + scc->stat.tx_under;\n\tscc->dev_stat.rx_fifo_errors = scc->stat.rx_over;\n\tscc->dev_stat.tx_fifo_errors = scc->stat.tx_under;\n\n\treturn &scc->dev_stat;\n}\n\n \n \n \n\n#ifdef CONFIG_PROC_FS\n\nstatic inline struct scc_channel *scc_net_seq_idx(loff_t pos)\n{\n\tint k;\n\n\tfor (k = 0; k < Nchips*2; ++k) {\n\t\tif (!SCC_Info[k].init) \n\t\t\tcontinue;\n\t\tif (pos-- == 0)\n\t\t\treturn &SCC_Info[k];\n\t}\n\treturn NULL;\n}\n\nstatic void *scc_net_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\treturn *pos ? scc_net_seq_idx(*pos - 1) : SEQ_START_TOKEN;\n\t\n}\n\nstatic void *scc_net_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tunsigned k;\n\tstruct scc_channel *scc = v;\n\t++*pos;\n\t\n\tfor (k = (v == SEQ_START_TOKEN) ? 0 : (scc - SCC_Info)+1;\n\t     k < Nchips*2; ++k) {\n\t\tif (SCC_Info[k].init) \n\t\t\treturn &SCC_Info[k];\n\t}\n\treturn NULL;\n}\n\nstatic void scc_net_seq_stop(struct seq_file *seq, void *v)\n{\n}\n\nstatic int scc_net_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(seq, \"z8530drv-\"VERSION\"\\n\");\n\t} else if (!Driver_Initialized) {\n\t\tseq_puts(seq, \"not initialized\\n\");\n\t} else if (!Nchips) {\n\t\tseq_puts(seq, \"chips missing\\n\");\n\t} else {\n\t\tconst struct scc_channel *scc = v;\n\t\tconst struct scc_stat *stat = &scc->stat;\n\t\tconst struct scc_kiss *kiss = &scc->kiss;\n\n\n\t\t \n\n\t\tseq_printf(seq, \"%s\\t%3.3lx %3.3lx %d %lu %2.2x %d %3.3lx %3.3lx %d\\n\",\n\t\t\t\tscc->dev->name,\n\t\t\t\tscc->data, scc->ctrl, scc->irq, scc->clock, scc->brand,\n\t\t\t\tscc->enhanced, Vector_Latch, scc->special,\n\t\t\t\tscc->option);\n\t\tseq_printf(seq, \"\\t%lu %d %d %d %d\\n\",\n\t\t\t\tscc->modem.speed, scc->modem.nrz,\n\t\t\t\tscc->modem.clocksrc, kiss->softdcd,\n\t\t\t\tstat->bufsize);\n\t\tseq_printf(seq, \"\\t%lu %lu %lu %lu\\n\",\n\t\t\t\tstat->rxints, stat->txints, stat->exints, stat->spints);\n\t\tseq_printf(seq, \"\\t%lu %lu %d / %lu %lu %d / %d %d\\n\",\n\t\t\t\tstat->rxframes, stat->rxerrs, stat->rx_over,\n\t\t\t\tstat->txframes, stat->txerrs, stat->tx_under,\n\t\t\t\tstat->nospace,  stat->tx_state);\n\n#define K(x) kiss->x\n\t\tseq_printf(seq, \"\\t%d %d %d %d %d %d %d %d %d %d %d %d\\n\",\n\t\t\t\tK(txdelay), K(persist), K(slottime), K(tailtime),\n\t\t\t\tK(fulldup), K(waittime), K(mintime), K(maxkeyup),\n\t\t\t\tK(idletime), K(maxdefer), K(tx_inhibit), K(group));\n#undef K\n#ifdef SCC_DEBUG\n\t\t{\n\t\t\tint reg;\n\n\t\tseq_printf(seq, \"\\tW \");\n\t\t\tfor (reg = 0; reg < 16; reg++)\n\t\t\t\tseq_printf(seq, \"%2.2x \", scc->wreg[reg]);\n\t\t\tseq_printf(seq, \"\\n\");\n\t\t\t\n\t\tseq_printf(seq, \"\\tR %2.2x %2.2x XX \", InReg(scc->ctrl,R0), InReg(scc->ctrl,R1));\n\t\t\tfor (reg = 3; reg < 8; reg++)\n\t\t\t\tseq_printf(seq, \"%2.2x \", InReg(scc->ctrl, reg));\n\t\t\tseq_printf(seq, \"XX \");\n\t\t\tfor (reg = 9; reg < 16; reg++)\n\t\t\t\tseq_printf(seq, \"%2.2x \", InReg(scc->ctrl, reg));\n\t\t\tseq_printf(seq, \"\\n\");\n\t\t}\n#endif\n\t\tseq_putc(seq, '\\n');\n\t}\n\n        return 0;\n}\n\nstatic const struct seq_operations scc_net_seq_ops = {\n\t.start  = scc_net_seq_start,\n\t.next   = scc_net_seq_next,\n\t.stop   = scc_net_seq_stop,\n\t.show   = scc_net_seq_show,\n};\n#endif  \n\n \n \n \n \n\nstatic int __init scc_init_driver (void)\n{\n\tchar devname[IFNAMSIZ];\n\t\n\tprintk(banner);\n\t\n\tsprintf(devname,\"%s0\", SCC_DriverName);\n\t\n\trtnl_lock();\n\tif (scc_net_alloc(devname, SCC_Info)) {\n\t\trtnl_unlock();\n\t\tprintk(KERN_ERR \"z8530drv: cannot initialize module\\n\");\n\t\treturn -EIO;\n\t}\n\trtnl_unlock();\n\n\tproc_create_seq(\"z8530drv\", 0, init_net.proc_net, &scc_net_seq_ops);\n\n\treturn 0;\n}\n\nstatic void __exit scc_cleanup_driver(void)\n{\n\tio_port ctrl;\n\tint k;\n\tstruct scc_channel *scc;\n\tstruct net_device *dev;\n\t\n\tif (Nchips == 0 && (dev = SCC_Info[0].dev)) \n\t{\n\t\tunregister_netdev(dev);\n\t\tfree_netdev(dev);\n\t}\n\n\t \n\tlocal_irq_disable();\n\t\n\tfor (k = 0; k < Nchips; k++)\n\t\tif ( (ctrl = SCC_ctrl[k].chan_A) )\n\t\t{\n\t\t\tOutb(ctrl, 0);\n\t\t\tOutReg(ctrl,R9,FHWRES);\t \n\t\t\tudelay(50);\n\t\t}\n\t\t\n\t \n\tfor (k = 0; k < nr_irqs ; k++)\n\t\tif (Ivec[k].used) free_irq(k, NULL);\n\t\t\n\tlocal_irq_enable();\n\t\t\n\t \n\tfor (k = 0; k < Nchips*2; k++)\n\t{\n\t\tscc = &SCC_Info[k];\n\t\tif (scc->ctrl)\n\t\t{\n\t\t\trelease_region(scc->ctrl, 1);\n\t\t\trelease_region(scc->data, 1);\n\t\t}\n\t\tif (scc->dev)\n\t\t{\n\t\t\tunregister_netdev(scc->dev);\n\t\t\tfree_netdev(scc->dev);\n\t\t}\n\t}\n\t\n\t\t\n\tif (Vector_Latch)\n\t\trelease_region(Vector_Latch, 1);\n\n\tremove_proc_entry(\"z8530drv\", init_net.proc_net);\n}\n\nMODULE_AUTHOR(\"Joerg Reuter <jreuter@yaina.de>\");\nMODULE_DESCRIPTION(\"AX.25 Device Driver for Z8530 based HDLC cards\");\nMODULE_LICENSE(\"GPL\");\nmodule_init(scc_init_driver);\nmodule_exit(scc_cleanup_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}