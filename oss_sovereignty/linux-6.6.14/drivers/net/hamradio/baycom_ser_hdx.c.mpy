{
  "module_name": "baycom_ser_hdx.c",
  "hash_id": "56e5b915ab0eddce1065a440b2d7dd5c021ba65fd7d401cdc085910e2cdf2cc9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/hamradio/baycom_ser_hdx.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/uaccess.h>\n#include <asm/io.h>\n#include <linux/hdlcdrv.h>\n#include <linux/baycom.h>\n#include <linux/jiffies.h>\n\n \n\n#define BAYCOM_DEBUG\n\n \n\nstatic const char bc_drvname[] = \"baycom_ser_hdx\";\nstatic const char bc_drvinfo[] = KERN_INFO \"baycom_ser_hdx: (C) 1996-2000 Thomas Sailer, HB9JNX/AE4WA\\n\"\n\"baycom_ser_hdx: version 0.10\\n\";\n\n \n\n#define NR_PORTS 4\n\nstatic struct net_device *baycom_device[NR_PORTS];\n\n \n\n#define RBR(iobase) (iobase+0)\n#define THR(iobase) (iobase+0)\n#define IER(iobase) (iobase+1)\n#define IIR(iobase) (iobase+2)\n#define FCR(iobase) (iobase+2)\n#define LCR(iobase) (iobase+3)\n#define MCR(iobase) (iobase+4)\n#define LSR(iobase) (iobase+5)\n#define MSR(iobase) (iobase+6)\n#define SCR(iobase) (iobase+7)\n#define DLL(iobase) (iobase+0)\n#define DLM(iobase) (iobase+1)\n\n#define SER12_EXTENT 8\n\n \n \n\nstruct baycom_state {\n\tstruct hdlcdrv_state hdrv;\n\n\tint opt_dcd;\n\n\tstruct modem_state {\n\t\tshort arb_divider;\n\t\tunsigned char flags;\n\t\tunsigned int shreg;\n\t\tstruct modem_state_ser12 {\n\t\t\tunsigned char tx_bit;\n\t\t\tint dcd_sum0, dcd_sum1, dcd_sum2;\n\t\t\tunsigned char last_sample;\n\t\t\tunsigned char last_rxbit;\n\t\t\tunsigned int dcd_shreg;\n\t\t\tunsigned int dcd_time;\n\t\t\tunsigned int bit_pll;\n\t\t\tunsigned char interm_sample;\n\t\t} ser12;\n\t} modem;\n\n#ifdef BAYCOM_DEBUG\n\tstruct debug_vals {\n\t\tunsigned long last_jiffies;\n\t\tunsigned cur_intcnt;\n\t\tunsigned last_intcnt;\n\t\tint cur_pllcorr;\n\t\tint last_pllcorr;\n\t} debug_vals;\n#endif  \n};\n\n \n\nstatic inline void baycom_int_freq(struct baycom_state *bc)\n{\n#ifdef BAYCOM_DEBUG\n\tunsigned long cur_jiffies = jiffies;\n\t \n\tbc->debug_vals.cur_intcnt++;\n\tif (time_after_eq(cur_jiffies, bc->debug_vals.last_jiffies + HZ)) {\n\t\tbc->debug_vals.last_jiffies = cur_jiffies;\n\t\tbc->debug_vals.last_intcnt = bc->debug_vals.cur_intcnt;\n\t\tbc->debug_vals.cur_intcnt = 0;\n\t\tbc->debug_vals.last_pllcorr = bc->debug_vals.cur_pllcorr;\n\t\tbc->debug_vals.cur_pllcorr = 0;\n\t}\n#endif  \n}\n\n \n \n\nstatic inline void ser12_set_divisor(struct net_device *dev,\n\t\t\t\t     unsigned char divisor)\n{\n\toutb(0x81, LCR(dev->base_addr));\t \n\toutb(divisor, DLL(dev->base_addr));\n\toutb(0, DLM(dev->base_addr));\n\toutb(0x01, LCR(dev->base_addr));\t \n\t \n\toutb(0x00, THR(dev->base_addr));\n\t \n}\n\n \n\n \n#define SER12_ARB_DIVIDER(bc)  (bc->opt_dcd ? 24 : 36)\n\t\t\t       \n#define SER12_DCD_INTERVAL(bc) (bc->opt_dcd ? 12 : 240)\n\nstatic inline void ser12_tx(struct net_device *dev, struct baycom_state *bc)\n{\n\t \n\tser12_set_divisor(dev, 12);\n\t \n\toutb(0x0e | (!!bc->modem.ser12.tx_bit), MCR(dev->base_addr));\n\tif (bc->modem.shreg <= 1)\n\t\tbc->modem.shreg = 0x10000 | hdlcdrv_getbits(&bc->hdrv);\n\tbc->modem.ser12.tx_bit = !(bc->modem.ser12.tx_bit ^\n\t\t\t\t   (bc->modem.shreg & 1));\n\tbc->modem.shreg >>= 1;\n}\n\n \n\nstatic inline void ser12_rx(struct net_device *dev, struct baycom_state *bc)\n{\n\tunsigned char cur_s;\n\t \n\tcur_s = inb(MSR(dev->base_addr)) & 0x10;\t \n\thdlcdrv_channelbit(&bc->hdrv, cur_s);\n\tbc->modem.ser12.dcd_shreg = (bc->modem.ser12.dcd_shreg << 1) |\n\t\t(cur_s != bc->modem.ser12.last_sample);\n\tbc->modem.ser12.last_sample = cur_s;\n\tif(bc->modem.ser12.dcd_shreg & 1) {\n\t\tif (!bc->opt_dcd) {\n\t\t\tunsigned int dcdspos, dcdsneg;\n\n\t\t\tdcdspos = dcdsneg = 0;\n\t\t\tdcdspos += ((bc->modem.ser12.dcd_shreg >> 1) & 1);\n\t\t\tif (!(bc->modem.ser12.dcd_shreg & 0x7ffffffe))\n\t\t\t\tdcdspos += 2;\n\t\t\tdcdsneg += ((bc->modem.ser12.dcd_shreg >> 2) & 1);\n\t\t\tdcdsneg += ((bc->modem.ser12.dcd_shreg >> 3) & 1);\n\t\t\tdcdsneg += ((bc->modem.ser12.dcd_shreg >> 4) & 1);\n\n\t\t\tbc->modem.ser12.dcd_sum0 += 16*dcdspos - dcdsneg;\n\t\t} else\n\t\t\tbc->modem.ser12.dcd_sum0--;\n\t}\n\tif(!bc->modem.ser12.dcd_time) {\n\t\thdlcdrv_setdcd(&bc->hdrv, (bc->modem.ser12.dcd_sum0 +\n\t\t\t\t\t   bc->modem.ser12.dcd_sum1 +\n\t\t\t\t\t   bc->modem.ser12.dcd_sum2) < 0);\n\t\tbc->modem.ser12.dcd_sum2 = bc->modem.ser12.dcd_sum1;\n\t\tbc->modem.ser12.dcd_sum1 = bc->modem.ser12.dcd_sum0;\n\t\t \n\t\tbc->modem.ser12.dcd_sum0 = 2;\n\t\tbc->modem.ser12.dcd_time = SER12_DCD_INTERVAL(bc);\n\t}\n\tbc->modem.ser12.dcd_time--;\n\tif (!bc->opt_dcd) {\n\t\t \n\t\tif (bc->modem.ser12.interm_sample) {\n\t\t\t \n\t\t\tser12_set_divisor(dev, 4);\n\t\t} else {\n\t\t\t \n\t\t\tswitch (bc->modem.ser12.dcd_shreg & 7) {\n\t\t\tcase 1:  \n\t\t\t\tser12_set_divisor(dev, 5);\n#ifdef BAYCOM_DEBUG\n\t\t\t\tbc->debug_vals.cur_pllcorr++;\n#endif  \n\t\t\t\tbreak;\n\t\t\tcase 4:\t \n\t\t\t\tser12_set_divisor(dev, 3);\n#ifdef BAYCOM_DEBUG\n\t\t\t\tbc->debug_vals.cur_pllcorr--;\n#endif  \n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tser12_set_divisor(dev, 4);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbc->modem.shreg >>= 1;\n\t\t\tif (bc->modem.ser12.last_sample ==\n\t\t\t    bc->modem.ser12.last_rxbit)\n\t\t\t\tbc->modem.shreg |= 0x10000;\n\t\t\tbc->modem.ser12.last_rxbit =\n\t\t\t\tbc->modem.ser12.last_sample;\n\t\t}\n\t\tif (++bc->modem.ser12.interm_sample >= 3)\n\t\t\tbc->modem.ser12.interm_sample = 0;\n\t\t \n\t\tif (bc->modem.ser12.dcd_shreg & 1) {\n\t\t\tunsigned int dcdspos, dcdsneg;\n\n\t\t\tdcdspos = dcdsneg = 0;\n\t\t\tdcdspos += ((bc->modem.ser12.dcd_shreg >> 1) & 1);\n\t\t\tdcdspos += (!(bc->modem.ser12.dcd_shreg & 0x7ffffffe))\n\t\t\t\t<< 1;\n\t\t\tdcdsneg += ((bc->modem.ser12.dcd_shreg >> 2) & 1);\n\t\t\tdcdsneg += ((bc->modem.ser12.dcd_shreg >> 3) & 1);\n\t\t\tdcdsneg += ((bc->modem.ser12.dcd_shreg >> 4) & 1);\n\n\t\t\tbc->modem.ser12.dcd_sum0 += 16*dcdspos - dcdsneg;\n\t\t}\n\t} else {\n\t\t \n\t\tif (bc->modem.ser12.interm_sample) {\n\t\t\t \n\t\t\tser12_set_divisor(dev, 6);\n\t\t} else {\n\t\t\t \n\t\t\tswitch (bc->modem.ser12.dcd_shreg & 3) {\n\t\t\tcase 1:  \n\t\t\t\tser12_set_divisor(dev, 7);\n#ifdef BAYCOM_DEBUG\n\t\t\t\tbc->debug_vals.cur_pllcorr++;\n#endif  \n\t\t\t\tbreak;\n\t\t\tcase 2:\t \n\t\t\t\tser12_set_divisor(dev, 5);\n#ifdef BAYCOM_DEBUG\n\t\t\t\tbc->debug_vals.cur_pllcorr--;\n#endif  \n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tser12_set_divisor(dev, 6);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbc->modem.shreg >>= 1;\n\t\t\tif (bc->modem.ser12.last_sample ==\n\t\t\t    bc->modem.ser12.last_rxbit)\n\t\t\t\tbc->modem.shreg |= 0x10000;\n\t\t\tbc->modem.ser12.last_rxbit =\n\t\t\t\tbc->modem.ser12.last_sample;\n\t\t}\n\t\tbc->modem.ser12.interm_sample = !bc->modem.ser12.interm_sample;\n\t\t \n\t\tbc->modem.ser12.dcd_sum0 -= (bc->modem.ser12.dcd_shreg & 1);\n\t}\n\toutb(0x0d, MCR(dev->base_addr));\t\t \n\tif (bc->modem.shreg & 1) {\n\t\thdlcdrv_putbits(&bc->hdrv, bc->modem.shreg >> 1);\n\t\tbc->modem.shreg = 0x10000;\n\t}\n\tif(!bc->modem.ser12.dcd_time) {\n\t\tif (bc->opt_dcd & 1) \n\t\t\thdlcdrv_setdcd(&bc->hdrv, !((inb(MSR(dev->base_addr)) ^ bc->opt_dcd) & 0x80));\n\t\telse\n\t\t\thdlcdrv_setdcd(&bc->hdrv, (bc->modem.ser12.dcd_sum0 +\n\t\t\t\t\t\t   bc->modem.ser12.dcd_sum1 +\n\t\t\t\t\t\t   bc->modem.ser12.dcd_sum2) < 0);\n\t\tbc->modem.ser12.dcd_sum2 = bc->modem.ser12.dcd_sum1;\n\t\tbc->modem.ser12.dcd_sum1 = bc->modem.ser12.dcd_sum0;\n\t\t \n\t\tbc->modem.ser12.dcd_sum0 = 2;\n\t\tbc->modem.ser12.dcd_time = SER12_DCD_INTERVAL(bc);\n\t}\n\tbc->modem.ser12.dcd_time--;\n}\n\n \n\nstatic irqreturn_t ser12_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = (struct net_device *)dev_id;\n\tstruct baycom_state *bc = netdev_priv(dev);\n\tunsigned char iir;\n\n\tif (!dev || !bc || bc->hdrv.magic != HDLCDRV_MAGIC)\n\t\treturn IRQ_NONE;\n\t \n\tif ((iir = inb(IIR(dev->base_addr))) & 1)\n\t\treturn IRQ_NONE;\n\tbaycom_int_freq(bc);\n\tdo {\n\t\tswitch (iir & 6) {\n\t\tcase 6:\n\t\t\tinb(LSR(dev->base_addr));\n\t\t\tbreak;\n\t\t\t\n\t\tcase 4:\n\t\t\tinb(RBR(dev->base_addr));\n\t\t\tbreak;\n\t\t\t\n\t\tcase 2:\n\t\t\t \n\t\t\tif (hdlcdrv_ptt(&bc->hdrv))\n\t\t\t\tser12_tx(dev, bc);\n\t\t\telse {\n\t\t\t\tser12_rx(dev, bc);\n\t\t\t\tbc->modem.arb_divider--;\n\t\t\t}\n\t\t\toutb(0x00, THR(dev->base_addr));\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tinb(MSR(dev->base_addr));\n\t\t\tbreak;\n\t\t}\n\t\tiir = inb(IIR(dev->base_addr));\n\t} while (!(iir & 1));\n\tif (bc->modem.arb_divider <= 0) {\n\t\tbc->modem.arb_divider = SER12_ARB_DIVIDER(bc);\n\t\tlocal_irq_enable();\n\t\thdlcdrv_arbitrate(dev, &bc->hdrv);\n\t}\n\tlocal_irq_enable();\n\thdlcdrv_transmitter(dev, &bc->hdrv);\n\thdlcdrv_receiver(dev, &bc->hdrv);\n\tlocal_irq_disable();\n\treturn IRQ_HANDLED;\n}\n\n \n\nenum uart { c_uart_unknown, c_uart_8250,\n\t    c_uart_16450, c_uart_16550, c_uart_16550A};\nstatic const char *uart_str[] = { \n\t\"unknown\", \"8250\", \"16450\", \"16550\", \"16550A\" \n};\n\nstatic enum uart ser12_check_uart(unsigned int iobase)\n{\n\tunsigned char b1,b2,b3;\n\tenum uart u;\n\tenum uart uart_tab[] =\n\t\t{ c_uart_16450, c_uart_unknown, c_uart_16550, c_uart_16550A };\n\n\tb1 = inb(MCR(iobase));\n\toutb(b1 | 0x10, MCR(iobase));\t \n\tb2 = inb(MSR(iobase));\n\toutb(0x1a, MCR(iobase));\n\tb3 = inb(MSR(iobase)) & 0xf0;\n\toutb(b1, MCR(iobase));\t\t\t \n\toutb(b2, MSR(iobase));\n\tif (b3 != 0x90)\n\t\treturn c_uart_unknown;\n\tinb(RBR(iobase));\n\tinb(RBR(iobase));\n\toutb(0x01, FCR(iobase));\t\t \n\tu = uart_tab[(inb(IIR(iobase)) >> 6) & 3];\n\tif (u == c_uart_16450) {\n\t\toutb(0x5a, SCR(iobase));\n\t\tb1 = inb(SCR(iobase));\n\t\toutb(0xa5, SCR(iobase));\n\t\tb2 = inb(SCR(iobase));\n\t\tif ((b1 != 0x5a) || (b2 != 0xa5))\n\t\t\tu = c_uart_8250;\n\t}\n\treturn u;\n}\n\n \n\nstatic int ser12_open(struct net_device *dev)\n{\n\tstruct baycom_state *bc = netdev_priv(dev);\n\tenum uart u;\n\n\tif (!dev || !bc)\n\t\treturn -ENXIO;\n\tif (!dev->base_addr || dev->base_addr > 0x1000-SER12_EXTENT ||\n\t    dev->irq < 2 || dev->irq > 15)\n\t\treturn -ENXIO;\n\tif (!request_region(dev->base_addr, SER12_EXTENT, \"baycom_ser12\"))\n\t\treturn -EACCES;\n\tmemset(&bc->modem, 0, sizeof(bc->modem));\n\tbc->hdrv.par.bitrate = 1200;\n\tif ((u = ser12_check_uart(dev->base_addr)) == c_uart_unknown) {\n\t\trelease_region(dev->base_addr, SER12_EXTENT);       \n\t\treturn -EIO;\n\t}\n\toutb(0, FCR(dev->base_addr));   \n\toutb(0x0d, MCR(dev->base_addr));\n\toutb(0, IER(dev->base_addr));\n\tif (request_irq(dev->irq, ser12_interrupt, IRQF_SHARED,\n\t\t\t\"baycom_ser12\", dev)) {\n\t\trelease_region(dev->base_addr, SER12_EXTENT);       \n\t\treturn -EBUSY;\n\t}\n\t \n\toutb(2, IER(dev->base_addr));\n\t \n\tser12_set_divisor(dev, bc->opt_dcd ? 6 : 4);\n\tprintk(KERN_INFO \"%s: ser12 at iobase 0x%lx irq %u uart %s\\n\", \n\t       bc_drvname, dev->base_addr, dev->irq, uart_str[u]);\n\treturn 0;\n}\n\n \n\nstatic int ser12_close(struct net_device *dev)\n{\n\tstruct baycom_state *bc = netdev_priv(dev);\n\n\tif (!dev || !bc)\n\t\treturn -EINVAL;\n\t \n\toutb(0, IER(dev->base_addr));\n\toutb(1, MCR(dev->base_addr));\n\tfree_irq(dev->irq, dev);\n\trelease_region(dev->base_addr, SER12_EXTENT);\n\tprintk(KERN_INFO \"%s: close ser12 at iobase 0x%lx irq %u\\n\",\n\t       bc_drvname, dev->base_addr, dev->irq);\n\treturn 0;\n}\n\n \n \n\n \n\nstatic int baycom_ioctl(struct net_device *dev, void __user *data,\n\t\t\tstruct hdlcdrv_ioctl *hi, int cmd);\n\n \n\nstatic const struct hdlcdrv_ops ser12_ops = {\n\t.drvname = bc_drvname,\n\t.drvinfo = bc_drvinfo,\n\t.open    = ser12_open,\n\t.close   = ser12_close,\n\t.ioctl   = baycom_ioctl,\n};\n\n \n\nstatic int baycom_setmode(struct baycom_state *bc, const char *modestr)\n{\n\tif (strchr(modestr, '*'))\n\t\tbc->opt_dcd = 0;\n\telse if (strchr(modestr, '+'))\n\t\tbc->opt_dcd = -1;\n\telse if (strchr(modestr, '@'))\n\t\tbc->opt_dcd = -2;\n\telse\n\t\tbc->opt_dcd = 1;\n\treturn 0;\n}\n\n \n\nstatic int baycom_ioctl(struct net_device *dev, void __user *data,\n\t\t\tstruct hdlcdrv_ioctl *hi, int cmd)\n{\n\tstruct baycom_state *bc;\n\tstruct baycom_ioctl bi;\n\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\tbc = netdev_priv(dev);\n\tBUG_ON(bc->hdrv.magic != HDLCDRV_MAGIC);\n\n\tif (cmd != SIOCDEVPRIVATE)\n\t\treturn -ENOIOCTLCMD;\n\tswitch (hi->cmd) {\n\tdefault:\n\t\tbreak;\n\n\tcase HDLCDRVCTL_GETMODE:\n\t\tstrcpy(hi->data.modename, \"ser12\");\n\t\tif (bc->opt_dcd <= 0)\n\t\t\tstrcat(hi->data.modename, (!bc->opt_dcd) ? \"*\" : (bc->opt_dcd == -2) ? \"@\" : \"+\");\n\t\tif (copy_to_user(data, hi, sizeof(struct hdlcdrv_ioctl)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase HDLCDRVCTL_SETMODE:\n\t\tif (netif_running(dev) || !capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\t\thi->data.modename[sizeof(hi->data.modename)-1] = '\\0';\n\t\treturn baycom_setmode(bc, hi->data.modename);\n\n\tcase HDLCDRVCTL_MODELIST:\n\t\tstrcpy(hi->data.modename, \"ser12\");\n\t\tif (copy_to_user(data, hi, sizeof(struct hdlcdrv_ioctl)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase HDLCDRVCTL_MODEMPARMASK:\n\t\treturn HDLCDRV_PARMASK_IOBASE | HDLCDRV_PARMASK_IRQ;\n\n\t}\n\n\tif (copy_from_user(&bi, data, sizeof(bi)))\n\t\treturn -EFAULT;\n\tswitch (bi.cmd) {\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\n#ifdef BAYCOM_DEBUG\n\tcase BAYCOMCTL_GETDEBUG:\n\t\tbi.data.dbg.debug1 = bc->hdrv.ptt_keyed;\n\t\tbi.data.dbg.debug2 = bc->debug_vals.last_intcnt;\n\t\tbi.data.dbg.debug3 = bc->debug_vals.last_pllcorr;\n\t\tbreak;\n#endif  \n\n\t}\n\tif (copy_to_user(data, &bi, sizeof(bi)))\n\t\treturn -EFAULT;\n\treturn 0;\n\n}\n\n \n\n \nstatic char *mode[NR_PORTS] = { \"ser12*\", };\nstatic int iobase[NR_PORTS] = { 0x3f8, };\nstatic int irq[NR_PORTS] = { 4, };\n\nmodule_param_array(mode, charp, NULL, 0);\nMODULE_PARM_DESC(mode, \"baycom operating mode; * for software DCD\");\nmodule_param_hw_array(iobase, int, ioport, NULL, 0);\nMODULE_PARM_DESC(iobase, \"baycom io base address\");\nmodule_param_hw_array(irq, int, irq, NULL, 0);\nMODULE_PARM_DESC(irq, \"baycom irq number\");\n\nMODULE_AUTHOR(\"Thomas M. Sailer, sailer@ife.ee.ethz.ch, hb9jnx@hb9w.che.eu\");\nMODULE_DESCRIPTION(\"Baycom ser12 half duplex amateur radio modem driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n\nstatic int __init init_baycomserhdx(void)\n{\n\tint i, found = 0;\n\tchar set_hw = 1;\n\n\tprintk(bc_drvinfo);\n\t \n\tfor (i = 0; i < NR_PORTS; i++) {\n\t\tstruct net_device *dev;\n\t\tstruct baycom_state *bc;\n\t\tchar ifname[IFNAMSIZ];\n\n\t\tsprintf(ifname, \"bcsh%d\", i);\n\n\t\tif (!mode[i])\n\t\t\tset_hw = 0;\n\t\tif (!set_hw)\n\t\t\tiobase[i] = irq[i] = 0;\n\n\t\tdev = hdlcdrv_register(&ser12_ops, \n\t\t\t\t       sizeof(struct baycom_state),\n\t\t\t\t       ifname, iobase[i], irq[i], 0);\n\t\tif (IS_ERR(dev)) \n\t\t\tbreak;\n\n\t\tbc = netdev_priv(dev);\n\t\tif (set_hw && baycom_setmode(bc, mode[i]))\n\t\t\tset_hw = 0;\n\t\tfound++;\n\t\tbaycom_device[i] = dev;\n\t}\n\n\tif (!found)\n\t\treturn -ENXIO;\n\treturn 0;\n}\n\nstatic void __exit cleanup_baycomserhdx(void)\n{\n\tint i;\n\n\tfor(i = 0; i < NR_PORTS; i++) {\n\t\tstruct net_device *dev = baycom_device[i];\n\n\t\tif (dev)\n\t\t\thdlcdrv_unregister(dev);\n\t}\n}\n\nmodule_init(init_baycomserhdx);\nmodule_exit(cleanup_baycomserhdx);\n\n \n\n#ifndef MODULE\n\n \n\nstatic int __init baycom_ser_hdx_setup(char *str)\n{\n        static unsigned nr_dev;\n\tint ints[3];\n\n        if (nr_dev >= NR_PORTS)\n                return 0;\n\tstr = get_options(str, 3, ints);\n\tif (ints[0] < 2)\n\t\treturn 0;\n\tmode[nr_dev] = str;\n\tiobase[nr_dev] = ints[1];\n\tirq[nr_dev] = ints[2];\n\tnr_dev++;\n\treturn 1;\n}\n\n__setup(\"baycom_ser_hdx=\", baycom_ser_hdx_setup);\n\n#endif  \n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}