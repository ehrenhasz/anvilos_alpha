{
  "module_name": "mkiss.c",
  "hash_id": "03e7923e547c3fa8366c82a5bb13cc8c6732e443900bf05022250ab3c95890d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/hamradio/mkiss.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/crc16.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/major.h>\n#include <linux/init.h>\n#include <linux/rtnetlink.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/if_arp.h>\n#include <linux/jiffies.h>\n#include <linux/refcount.h>\n\n#include <net/ax25.h>\n\n#define AX_MTU\t\t236\n\n \n#undef\tEND\n \n#define END             0300\t\t \n#define ESC             0333\t\t \n#define ESC_END         0334\t\t \n#define ESC_ESC         0335\t\t \n\nstruct mkiss {\n\tstruct tty_struct\t*tty;\t \n\tstruct net_device\t*dev;\t \n\n\t \n\tspinlock_t\t\tbuflock; \n\tunsigned char\t\t*rbuff;\t \n\tint\t\t\trcount;\t \n\tunsigned char\t\t*xbuff;\t \n\tunsigned char\t\t*xhead;\t \n\tint\t\t\txleft;\t \n\n\t \n\tint\t\tmtu;\t\t \n\tint\t\tbuffsize;\t \n\n\tunsigned long\tflags;\t\t \n\t\t\t\t\t \n#define AXF_INUSE\t0\t\t \n#define AXF_ESCAPE\t1                \n#define AXF_ERROR\t2                \n#define AXF_KEEPTEST\t3\t\t \n#define AXF_OUTWAIT\t4\t\t \n\n\tint\t\tmode;\n        int\t\tcrcmode;\t \n\tint\t\tcrcauto;\t \n\n#define CRC_MODE_NONE\t\t0\n#define CRC_MODE_FLEX\t\t1\n#define CRC_MODE_SMACK\t\t2\n#define CRC_MODE_FLEX_TEST\t3\n#define CRC_MODE_SMACK_TEST\t4\n\n\trefcount_t\t\trefcnt;\n\tstruct completion\tdead;\n};\n\n \n\nstatic const unsigned short crc_flex_table[] = {\n\t0x0f87, 0x1e0e, 0x2c95, 0x3d1c, 0x49a3, 0x582a, 0x6ab1, 0x7b38,\n\t0x83cf, 0x9246, 0xa0dd, 0xb154, 0xc5eb, 0xd462, 0xe6f9, 0xf770,\n\t0x1f06, 0x0e8f, 0x3c14, 0x2d9d, 0x5922, 0x48ab, 0x7a30, 0x6bb9,\n\t0x934e, 0x82c7, 0xb05c, 0xa1d5, 0xd56a, 0xc4e3, 0xf678, 0xe7f1,\n\t0x2e85, 0x3f0c, 0x0d97, 0x1c1e, 0x68a1, 0x7928, 0x4bb3, 0x5a3a,\n\t0xa2cd, 0xb344, 0x81df, 0x9056, 0xe4e9, 0xf560, 0xc7fb, 0xd672,\n\t0x3e04, 0x2f8d, 0x1d16, 0x0c9f, 0x7820, 0x69a9, 0x5b32, 0x4abb,\n\t0xb24c, 0xa3c5, 0x915e, 0x80d7, 0xf468, 0xe5e1, 0xd77a, 0xc6f3,\n\t0x4d83, 0x5c0a, 0x6e91, 0x7f18, 0x0ba7, 0x1a2e, 0x28b5, 0x393c,\n\t0xc1cb, 0xd042, 0xe2d9, 0xf350, 0x87ef, 0x9666, 0xa4fd, 0xb574,\n\t0x5d02, 0x4c8b, 0x7e10, 0x6f99, 0x1b26, 0x0aaf, 0x3834, 0x29bd,\n\t0xd14a, 0xc0c3, 0xf258, 0xe3d1, 0x976e, 0x86e7, 0xb47c, 0xa5f5,\n\t0x6c81, 0x7d08, 0x4f93, 0x5e1a, 0x2aa5, 0x3b2c, 0x09b7, 0x183e,\n\t0xe0c9, 0xf140, 0xc3db, 0xd252, 0xa6ed, 0xb764, 0x85ff, 0x9476,\n\t0x7c00, 0x6d89, 0x5f12, 0x4e9b, 0x3a24, 0x2bad, 0x1936, 0x08bf,\n\t0xf048, 0xe1c1, 0xd35a, 0xc2d3, 0xb66c, 0xa7e5, 0x957e, 0x84f7,\n\t0x8b8f, 0x9a06, 0xa89d, 0xb914, 0xcdab, 0xdc22, 0xeeb9, 0xff30,\n\t0x07c7, 0x164e, 0x24d5, 0x355c, 0x41e3, 0x506a, 0x62f1, 0x7378,\n\t0x9b0e, 0x8a87, 0xb81c, 0xa995, 0xdd2a, 0xcca3, 0xfe38, 0xefb1,\n\t0x1746, 0x06cf, 0x3454, 0x25dd, 0x5162, 0x40eb, 0x7270, 0x63f9,\n\t0xaa8d, 0xbb04, 0x899f, 0x9816, 0xeca9, 0xfd20, 0xcfbb, 0xde32,\n\t0x26c5, 0x374c, 0x05d7, 0x145e, 0x60e1, 0x7168, 0x43f3, 0x527a,\n\t0xba0c, 0xab85, 0x991e, 0x8897, 0xfc28, 0xeda1, 0xdf3a, 0xceb3,\n\t0x3644, 0x27cd, 0x1556, 0x04df, 0x7060, 0x61e9, 0x5372, 0x42fb,\n\t0xc98b, 0xd802, 0xea99, 0xfb10, 0x8faf, 0x9e26, 0xacbd, 0xbd34,\n\t0x45c3, 0x544a, 0x66d1, 0x7758, 0x03e7, 0x126e, 0x20f5, 0x317c,\n\t0xd90a, 0xc883, 0xfa18, 0xeb91, 0x9f2e, 0x8ea7, 0xbc3c, 0xadb5,\n\t0x5542, 0x44cb, 0x7650, 0x67d9, 0x1366, 0x02ef, 0x3074, 0x21fd,\n\t0xe889, 0xf900, 0xcb9b, 0xda12, 0xaead, 0xbf24, 0x8dbf, 0x9c36,\n\t0x64c1, 0x7548, 0x47d3, 0x565a, 0x22e5, 0x336c, 0x01f7, 0x107e,\n\t0xf808, 0xe981, 0xdb1a, 0xca93, 0xbe2c, 0xafa5, 0x9d3e, 0x8cb7,\n\t0x7440, 0x65c9, 0x5752, 0x46db, 0x3264, 0x23ed, 0x1176, 0x00ff\n};\n\nstatic unsigned short calc_crc_flex(unsigned char *cp, int size)\n{\n\tunsigned short crc = 0xffff;\n\n\twhile (size--)\n\t\tcrc = (crc << 8) ^ crc_flex_table[((crc >> 8) ^ *cp++) & 0xff];\n\n\treturn crc;\n}\n\nstatic int check_crc_flex(unsigned char *cp, int size)\n{\n\tunsigned short crc = 0xffff;\n\n\tif (size < 3)\n\t\treturn -1;\n\n\twhile (size--)\n\t\tcrc = (crc << 8) ^ crc_flex_table[((crc >> 8) ^ *cp++) & 0xff];\n\n\tif ((crc & 0xffff) != 0x7070)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int check_crc_16(unsigned char *cp, int size)\n{\n\tunsigned short crc = 0x0000;\n\n\tif (size < 3)\n\t\treturn -1;\n\n\tcrc = crc16(0, cp, size);\n\n\tif (crc != 0x0000)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \n\nstatic int kiss_esc(unsigned char *s, unsigned char *d, int len)\n{\n\tunsigned char *ptr = d;\n\tunsigned char c;\n\n\t \n\n\t*ptr++ = END;\n\n\twhile (len-- > 0) {\n\t\tswitch (c = *s++) {\n\t\tcase END:\n\t\t\t*ptr++ = ESC;\n\t\t\t*ptr++ = ESC_END;\n\t\t\tbreak;\n\t\tcase ESC:\n\t\t\t*ptr++ = ESC;\n\t\t\t*ptr++ = ESC_ESC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*ptr++ = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t*ptr++ = END;\n\n\treturn ptr - d;\n}\n\n \nstatic int kiss_esc_crc(unsigned char *s, unsigned char *d, unsigned short crc,\n\tint len)\n{\n\tunsigned char *ptr = d;\n\tunsigned char c=0;\n\n\t*ptr++ = END;\n\twhile (len > 0) {\n\t\tif (len > 2)\n\t\t\tc = *s++;\n\t\telse if (len > 1)\n\t\t\tc = crc >> 8;\n\t\telse\n\t\t\tc = crc & 0xff;\n\n\t\tlen--;\n\n\t\tswitch (c) {\n\t\tcase END:\n\t\t\t*ptr++ = ESC;\n\t\t\t*ptr++ = ESC_END;\n\t\t\tbreak;\n\t\tcase ESC:\n\t\t\t*ptr++ = ESC;\n\t\t\t*ptr++ = ESC_ESC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*ptr++ = c;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*ptr++ = END;\n\n\treturn ptr - d;\n}\n\n \nstatic void ax_bump(struct mkiss *ax)\n{\n\tstruct sk_buff *skb;\n\tint count;\n\n\tspin_lock_bh(&ax->buflock);\n\tif (ax->rbuff[0] > 0x0f) {\n\t\tif (ax->rbuff[0] & 0x80) {\n\t\t\tif (check_crc_16(ax->rbuff, ax->rcount) < 0) {\n\t\t\t\tax->dev->stats.rx_errors++;\n\t\t\t\tspin_unlock_bh(&ax->buflock);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (ax->crcmode != CRC_MODE_SMACK && ax->crcauto) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"mkiss: %s: Switching to crc-smack\\n\",\n\t\t\t\t       ax->dev->name);\n\t\t\t\tax->crcmode = CRC_MODE_SMACK;\n\t\t\t}\n\t\t\tax->rcount -= 2;\n\t\t\t*ax->rbuff &= ~0x80;\n\t\t} else if (ax->rbuff[0] & 0x20)  {\n\t\t\tif (check_crc_flex(ax->rbuff, ax->rcount) < 0) {\n\t\t\t\tax->dev->stats.rx_errors++;\n\t\t\t\tspin_unlock_bh(&ax->buflock);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (ax->crcmode != CRC_MODE_FLEX && ax->crcauto) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t       \"mkiss: %s: Switching to crc-flexnet\\n\",\n\t\t\t\t       ax->dev->name);\n\t\t\t\tax->crcmode = CRC_MODE_FLEX;\n\t\t\t}\n\t\t\tax->rcount -= 2;\n\n\t\t\t \n\t\t\t*ax->rbuff &= ~0x20;\n\t\t}\n\t}\n\n\tcount = ax->rcount;\n\n\tif ((skb = dev_alloc_skb(count)) == NULL) {\n\t\tprintk(KERN_ERR \"mkiss: %s: memory squeeze, dropping packet.\\n\",\n\t\t       ax->dev->name);\n\t\tax->dev->stats.rx_dropped++;\n\t\tspin_unlock_bh(&ax->buflock);\n\t\treturn;\n\t}\n\n\tskb_put_data(skb, ax->rbuff, count);\n\tskb->protocol = ax25_type_trans(skb, ax->dev);\n\tnetif_rx(skb);\n\tax->dev->stats.rx_packets++;\n\tax->dev->stats.rx_bytes += count;\n\tspin_unlock_bh(&ax->buflock);\n}\n\nstatic void kiss_unesc(struct mkiss *ax, unsigned char s)\n{\n\tswitch (s) {\n\tcase END:\n\t\t \n\t\tif (test_bit(AXF_KEEPTEST, &ax->flags))\n\t\t\tclear_bit(AXF_KEEPTEST, &ax->flags);\n\n\t\tif (!test_and_clear_bit(AXF_ERROR, &ax->flags) && (ax->rcount > 2))\n\t\t\tax_bump(ax);\n\n\t\tclear_bit(AXF_ESCAPE, &ax->flags);\n\t\tax->rcount = 0;\n\t\treturn;\n\n\tcase ESC:\n\t\tset_bit(AXF_ESCAPE, &ax->flags);\n\t\treturn;\n\tcase ESC_ESC:\n\t\tif (test_and_clear_bit(AXF_ESCAPE, &ax->flags))\n\t\t\ts = ESC;\n\t\tbreak;\n\tcase ESC_END:\n\t\tif (test_and_clear_bit(AXF_ESCAPE, &ax->flags))\n\t\t\ts = END;\n\t\tbreak;\n\t}\n\n\tspin_lock_bh(&ax->buflock);\n\tif (!test_bit(AXF_ERROR, &ax->flags)) {\n\t\tif (ax->rcount < ax->buffsize) {\n\t\t\tax->rbuff[ax->rcount++] = s;\n\t\t\tspin_unlock_bh(&ax->buflock);\n\t\t\treturn;\n\t\t}\n\n\t\tax->dev->stats.rx_over_errors++;\n\t\tset_bit(AXF_ERROR, &ax->flags);\n\t}\n\tspin_unlock_bh(&ax->buflock);\n}\n\nstatic int ax_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct sockaddr_ax25 *sa = addr;\n\n\tnetif_tx_lock_bh(dev);\n\tnetif_addr_lock(dev);\n\t__dev_addr_set(dev, &sa->sax25_call, AX25_ADDR_LEN);\n\tnetif_addr_unlock(dev);\n\tnetif_tx_unlock_bh(dev);\n\n\treturn 0;\n}\n\n \n\nstatic void ax_changedmtu(struct mkiss *ax)\n{\n\tstruct net_device *dev = ax->dev;\n\tunsigned char *xbuff, *rbuff, *oxbuff, *orbuff;\n\tint len;\n\n\tlen = dev->mtu * 2;\n\n\t \n\tif (len < 576 * 2)\n\t\tlen = 576 * 2;\n\n\txbuff = kmalloc(len + 4, GFP_ATOMIC);\n\trbuff = kmalloc(len + 4, GFP_ATOMIC);\n\n\tif (xbuff == NULL || rbuff == NULL)  {\n\t\tprintk(KERN_ERR \"mkiss: %s: unable to grow ax25 buffers, \"\n\t\t       \"MTU change cancelled.\\n\",\n\t\t       ax->dev->name);\n\t\tdev->mtu = ax->mtu;\n\t\tkfree(xbuff);\n\t\tkfree(rbuff);\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&ax->buflock);\n\n\toxbuff    = ax->xbuff;\n\tax->xbuff = xbuff;\n\torbuff    = ax->rbuff;\n\tax->rbuff = rbuff;\n\n\tif (ax->xleft) {\n\t\tif (ax->xleft <= len) {\n\t\t\tmemcpy(ax->xbuff, ax->xhead, ax->xleft);\n\t\t} else  {\n\t\t\tax->xleft = 0;\n\t\t\tdev->stats.tx_dropped++;\n\t\t}\n\t}\n\n\tax->xhead = ax->xbuff;\n\n\tif (ax->rcount) {\n\t\tif (ax->rcount <= len) {\n\t\t\tmemcpy(ax->rbuff, orbuff, ax->rcount);\n\t\t} else  {\n\t\t\tax->rcount = 0;\n\t\t\tdev->stats.rx_over_errors++;\n\t\t\tset_bit(AXF_ERROR, &ax->flags);\n\t\t}\n\t}\n\n\tax->mtu      = dev->mtu + 73;\n\tax->buffsize = len;\n\n\tspin_unlock_bh(&ax->buflock);\n\n\tkfree(oxbuff);\n\tkfree(orbuff);\n}\n\n \nstatic void ax_encaps(struct net_device *dev, unsigned char *icp, int len)\n{\n\tstruct mkiss *ax = netdev_priv(dev);\n\tunsigned char *p;\n\tint actual, count;\n\n\tif (ax->mtu != ax->dev->mtu + 73)\t \n\t\tax_changedmtu(ax);\n\n\tif (len > ax->mtu) {\t\t \n\t\tprintk(KERN_ERR \"mkiss: %s: truncating oversized transmit packet!\\n\", ax->dev->name);\n\t\tdev->stats.tx_dropped++;\n\t\tnetif_start_queue(dev);\n\t\treturn;\n\t}\n\n\tp = icp;\n\n\tspin_lock_bh(&ax->buflock);\n\tif ((*p & 0x0f) != 0) {\n\t\t \n\t\tswitch (*p & 0xff) {\n\t\tcase 0x85:\n\t\t\t \n\t\t\tif (len > 1) {\n\t\t\t\tint cmd = (p[1] & 0xff);\n\t\t\t\tswitch(cmd) {\n\t\t\t\tcase 3:\n\t\t\t\t  ax->crcmode = CRC_MODE_SMACK;\n\t\t\t\t  break;\n\t\t\t\tcase 2:\n\t\t\t\t  ax->crcmode = CRC_MODE_FLEX;\n\t\t\t\t  break;\n\t\t\t\tcase 1:\n\t\t\t\t  ax->crcmode = CRC_MODE_NONE;\n\t\t\t\t  break;\n\t\t\t\tcase 0:\n\t\t\t\tdefault:\n\t\t\t\t  ax->crcmode = CRC_MODE_SMACK_TEST;\n\t\t\t\t  cmd = 0;\n\t\t\t\t}\n\t\t\t\tax->crcauto = (cmd ? 0 : 1);\n\t\t\t\tprintk(KERN_INFO \"mkiss: %s: crc mode set to %d\\n\",\n\t\t\t\t       ax->dev->name, cmd);\n\t\t\t}\n\t\t\tspin_unlock_bh(&ax->buflock);\n\t\t\tnetif_start_queue(dev);\n\n\t\t\treturn;\n\t\tdefault:\n\t\t\tcount = kiss_esc(p, ax->xbuff, len);\n\t\t}\n\t} else {\n\t\tunsigned short crc;\n\t\tswitch (ax->crcmode) {\n\t\tcase CRC_MODE_SMACK_TEST:\n\t\t\tax->crcmode  = CRC_MODE_FLEX_TEST;\n\t\t\tprintk(KERN_INFO \"mkiss: %s: Trying crc-smack\\n\", ax->dev->name);\n\t\t\tfallthrough;\n\t\tcase CRC_MODE_SMACK:\n\t\t\t*p |= 0x80;\n\t\t\tcrc = swab16(crc16(0, p, len));\n\t\t\tcount = kiss_esc_crc(p, ax->xbuff, crc, len+2);\n\t\t\tbreak;\n\t\tcase CRC_MODE_FLEX_TEST:\n\t\t\tax->crcmode = CRC_MODE_NONE;\n\t\t\tprintk(KERN_INFO \"mkiss: %s: Trying crc-flexnet\\n\", ax->dev->name);\n\t\t\tfallthrough;\n\t\tcase CRC_MODE_FLEX:\n\t\t\t*p |= 0x20;\n\t\t\tcrc = calc_crc_flex(p, len);\n\t\t\tcount = kiss_esc_crc(p, ax->xbuff, crc, len+2);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcount = kiss_esc(p, ax->xbuff, len);\n\t\t}\n\t}\n\tspin_unlock_bh(&ax->buflock);\n\n\tset_bit(TTY_DO_WRITE_WAKEUP, &ax->tty->flags);\n\tactual = ax->tty->ops->write(ax->tty, ax->xbuff, count);\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += actual;\n\n\tnetif_trans_update(ax->dev);\n\tax->xleft = count - actual;\n\tax->xhead = ax->xbuff + actual;\n}\n\n \nstatic netdev_tx_t ax_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct mkiss *ax = netdev_priv(dev);\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn ax25_ip_xmit(skb);\n\n\tif (!netif_running(dev))  {\n\t\tprintk(KERN_ERR \"mkiss: %s: xmit call when iface is down\\n\", dev->name);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tif (netif_queue_stopped(dev)) {\n\t\t \n\t\tif (time_before(jiffies, dev_trans_start(dev) + 20 * HZ)) {\n\t\t\t \n\t\t\treturn NETDEV_TX_BUSY;\n\t\t}\n\n\t\tprintk(KERN_ERR \"mkiss: %s: transmit timed out, %s?\\n\", dev->name,\n\t\t       (tty_chars_in_buffer(ax->tty) || ax->xleft) ?\n\t\t       \"bad line quality\" : \"driver error\");\n\n\t\tax->xleft = 0;\n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &ax->tty->flags);\n\t\tnetif_start_queue(dev);\n\t}\n\n\t \n\tnetif_stop_queue(dev);\n\tax_encaps(dev, skb->data, skb->len);\n\tkfree_skb(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int ax_open_dev(struct net_device *dev)\n{\n\tstruct mkiss *ax = netdev_priv(dev);\n\n\tif (ax->tty == NULL)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\n \nstatic int ax_open(struct net_device *dev)\n{\n\tstruct mkiss *ax = netdev_priv(dev);\n\tunsigned long len;\n\n\tif (ax->tty == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tlen = dev->mtu * 2;\n\n\t \n\tif (len < 576 * 2)\n\t\tlen = 576 * 2;\n\n\tif ((ax->rbuff = kmalloc(len + 4, GFP_KERNEL)) == NULL)\n\t\tgoto norbuff;\n\n\tif ((ax->xbuff = kmalloc(len + 4, GFP_KERNEL)) == NULL)\n\t\tgoto noxbuff;\n\n\tax->mtu\t     = dev->mtu + 73;\n\tax->buffsize = len;\n\tax->rcount   = 0;\n\tax->xleft    = 0;\n\n\tax->flags   &= (1 << AXF_INUSE);       \n\n\tspin_lock_init(&ax->buflock);\n\n\treturn 0;\n\nnoxbuff:\n\tkfree(ax->rbuff);\n\nnorbuff:\n\treturn -ENOMEM;\n}\n\n\n \nstatic int ax_close(struct net_device *dev)\n{\n\tstruct mkiss *ax = netdev_priv(dev);\n\n\tif (ax->tty)\n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &ax->tty->flags);\n\n\tnetif_stop_queue(dev);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops ax_netdev_ops = {\n\t.ndo_open            = ax_open_dev,\n\t.ndo_stop            = ax_close,\n\t.ndo_start_xmit\t     = ax_xmit,\n\t.ndo_set_mac_address = ax_set_mac_address,\n};\n\nstatic void ax_setup(struct net_device *dev)\n{\n\t \n\tdev->mtu             = AX_MTU;\n\tdev->hard_header_len = AX25_MAX_HEADER_LEN;\n\tdev->addr_len        = AX25_ADDR_LEN;\n\tdev->type            = ARPHRD_AX25;\n\tdev->tx_queue_len    = 10;\n\tdev->header_ops      = &ax25_header_ops;\n\tdev->netdev_ops\t     = &ax_netdev_ops;\n\n\n\tmemcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);\n\tdev_addr_set(dev, (u8 *)&ax25_defaddr);\n\n\tdev->flags      = IFF_BROADCAST | IFF_MULTICAST;\n}\n\n \nstatic DEFINE_RWLOCK(disc_data_lock);\n\nstatic struct mkiss *mkiss_get(struct tty_struct *tty)\n{\n\tstruct mkiss *ax;\n\n\tread_lock(&disc_data_lock);\n\tax = tty->disc_data;\n\tif (ax)\n\t\trefcount_inc(&ax->refcnt);\n\tread_unlock(&disc_data_lock);\n\n\treturn ax;\n}\n\nstatic void mkiss_put(struct mkiss *ax)\n{\n\tif (refcount_dec_and_test(&ax->refcnt))\n\t\tcomplete(&ax->dead);\n}\n\nstatic int crc_force = 0;\t \n\nstatic int mkiss_open(struct tty_struct *tty)\n{\n\tstruct net_device *dev;\n\tstruct mkiss *ax;\n\tint err;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif (tty->ops->write == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tdev = alloc_netdev(sizeof(struct mkiss), \"ax%d\", NET_NAME_UNKNOWN,\n\t\t\t   ax_setup);\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tax = netdev_priv(dev);\n\tax->dev = dev;\n\n\tspin_lock_init(&ax->buflock);\n\trefcount_set(&ax->refcnt, 1);\n\tinit_completion(&ax->dead);\n\n\tax->tty = tty;\n\ttty->disc_data = ax;\n\ttty->receive_room = 65535;\n\n\ttty_driver_flush_buffer(tty);\n\n\t \n\tdev->type = ARPHRD_AX25;\n\n\t \n\terr = ax_open(ax->dev);\n\tif (err)\n\t\tgoto out_free_netdev;\n\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto out_free_buffers;\n\n\t \n\tswitch (crc_force) {\n\tcase 3:\n\t\tax->crcmode  = CRC_MODE_SMACK;\n\t\tprintk(KERN_INFO \"mkiss: %s: crc mode smack forced.\\n\",\n\t\t       ax->dev->name);\n\t\tbreak;\n\tcase 2:\n\t\tax->crcmode  = CRC_MODE_FLEX;\n\t\tprintk(KERN_INFO \"mkiss: %s: crc mode flexnet forced.\\n\",\n\t\t       ax->dev->name);\n\t\tbreak;\n\tcase 1:\n\t\tax->crcmode  = CRC_MODE_NONE;\n\t\tprintk(KERN_INFO \"mkiss: %s: crc mode disabled.\\n\",\n\t\t       ax->dev->name);\n\t\tbreak;\n\tcase 0:\n\tdefault:\n\t\tcrc_force = 0;\n\t\tprintk(KERN_INFO \"mkiss: %s: crc mode is auto.\\n\",\n\t\t       ax->dev->name);\n\t\tax->crcmode  = CRC_MODE_SMACK_TEST;\n\t}\n\tax->crcauto = (crc_force ? 0 : 1);\n\n\tnetif_start_queue(dev);\n\n\t \n\treturn 0;\n\nout_free_buffers:\n\tkfree(ax->rbuff);\n\tkfree(ax->xbuff);\n\nout_free_netdev:\n\tfree_netdev(dev);\n\nout:\n\treturn err;\n}\n\nstatic void mkiss_close(struct tty_struct *tty)\n{\n\tstruct mkiss *ax;\n\n\twrite_lock_irq(&disc_data_lock);\n\tax = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\n\tif (!ax)\n\t\treturn;\n\n\t \n\tif (!refcount_dec_and_test(&ax->refcnt))\n\t\twait_for_completion(&ax->dead);\n\t \n\tnetif_stop_queue(ax->dev);\n\n\tunregister_netdev(ax->dev);\n\n\t \n\tkfree(ax->rbuff);\n\tkfree(ax->xbuff);\n\n\tax->tty = NULL;\n\n\tfree_netdev(ax->dev);\n}\n\n \nstatic int mkiss_ioctl(struct tty_struct *tty, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tstruct mkiss *ax = mkiss_get(tty);\n\tstruct net_device *dev;\n\tunsigned int tmp, err;\n\n\t \n\tif (ax == NULL)\n\t\treturn -ENXIO;\n\tdev = ax->dev;\n\n\tswitch (cmd) {\n\tcase SIOCGIFNAME:\n\t\terr = copy_to_user((void __user *) arg, ax->dev->name,\n\t\t                   strlen(ax->dev->name) + 1) ? -EFAULT : 0;\n\t\tbreak;\n\n\tcase SIOCGIFENCAP:\n\t\terr = put_user(4, (int __user *) arg);\n\t\tbreak;\n\n\tcase SIOCSIFENCAP:\n\t\tif (get_user(tmp, (int __user *) arg)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tax->mode = tmp;\n\t\tdev->addr_len        = AX25_ADDR_LEN;\n\t\tdev->hard_header_len = AX25_KISS_HEADER_LEN +\n\t\t                       AX25_MAX_HEADER_LEN + 3;\n\t\tdev->type            = ARPHRD_AX25;\n\n\t\terr = 0;\n\t\tbreak;\n\n\tcase SIOCSIFHWADDR: {\n\t\tchar addr[AX25_ADDR_LEN];\n\n\t\tif (copy_from_user(&addr,\n\t\t                   (void __user *) arg, AX25_ADDR_LEN)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tnetif_tx_lock_bh(dev);\n\t\t__dev_addr_set(dev, addr, AX25_ADDR_LEN);\n\t\tnetif_tx_unlock_bh(dev);\n\n\t\terr = 0;\n\t\tbreak;\n\t}\n\tdefault:\n\t\terr = -ENOIOCTLCMD;\n\t}\n\n\tmkiss_put(ax);\n\n\treturn err;\n}\n\n \nstatic void mkiss_receive_buf(struct tty_struct *tty, const u8 *cp,\n\t\t\t      const u8 *fp, size_t count)\n{\n\tstruct mkiss *ax = mkiss_get(tty);\n\n\tif (!ax)\n\t\treturn;\n\n\t \n\tif (ax->mtu != ax->dev->mtu + 73)\n\t\tax_changedmtu(ax);\n\n\t \n\twhile (count--) {\n\t\tif (fp != NULL && *fp++) {\n\t\t\tif (!test_and_set_bit(AXF_ERROR, &ax->flags))\n\t\t\t\tax->dev->stats.rx_errors++;\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkiss_unesc(ax, *cp++);\n\t}\n\n\tmkiss_put(ax);\n\ttty_unthrottle(tty);\n}\n\n \nstatic void mkiss_write_wakeup(struct tty_struct *tty)\n{\n\tstruct mkiss *ax = mkiss_get(tty);\n\tint actual;\n\n\tif (!ax)\n\t\treturn;\n\n\tif (ax->xleft <= 0)  {\n\t\t \n\t\tclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\n\t\tnetif_wake_queue(ax->dev);\n\t\tgoto out;\n\t}\n\n\tactual = tty->ops->write(tty, ax->xhead, ax->xleft);\n\tax->xleft -= actual;\n\tax->xhead += actual;\n\nout:\n\tmkiss_put(ax);\n}\n\nstatic struct tty_ldisc_ops ax_ldisc = {\n\t.owner\t\t= THIS_MODULE,\n\t.num\t\t= N_AX25,\n\t.name\t\t= \"mkiss\",\n\t.open\t\t= mkiss_open,\n\t.close\t\t= mkiss_close,\n\t.ioctl\t\t= mkiss_ioctl,\n\t.receive_buf\t= mkiss_receive_buf,\n\t.write_wakeup\t= mkiss_write_wakeup\n};\n\nstatic const char banner[] __initconst = KERN_INFO \\\n\t\"mkiss: AX.25 Multikiss, Hans Albas PE1AYX\\n\";\nstatic const char msg_regfail[] __initconst = KERN_ERR \\\n\t\"mkiss: can't register line discipline (err = %d)\\n\";\n\nstatic int __init mkiss_init_driver(void)\n{\n\tint status;\n\n\tprintk(banner);\n\n\tstatus = tty_register_ldisc(&ax_ldisc);\n\tif (status != 0)\n\t\tprintk(msg_regfail, status);\n\n\treturn status;\n}\n\nstatic void __exit mkiss_exit_driver(void)\n{\n\ttty_unregister_ldisc(&ax_ldisc);\n}\n\nMODULE_AUTHOR(\"Ralf Baechle DL5RB <ralf@linux-mips.org>\");\nMODULE_DESCRIPTION(\"KISS driver for AX.25 over TTYs\");\nmodule_param(crc_force, int, 0);\nMODULE_PARM_DESC(crc_force, \"crc [0 = auto | 1 = none | 2 = flexnet | 3 = smack]\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_LDISC(N_AX25);\n\nmodule_init(mkiss_init_driver);\nmodule_exit(mkiss_exit_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}