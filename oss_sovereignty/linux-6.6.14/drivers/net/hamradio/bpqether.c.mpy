{
  "module_name": "bpqether.c",
  "hash_id": "7a5713148c3f9a5667e2736fb79fd01d230b949b6e53d4bc560e07246b41d9e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/hamradio/bpqether.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/slab.h>\n#include <net/ax25.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/uaccess.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/rtnetlink.h>\n\n#include <net/ip.h>\n#include <net/arp.h>\n#include <net/net_namespace.h>\n\n#include <linux/bpqether.h>\n\nstatic const char banner[] __initconst = KERN_INFO \\\n\t\"AX.25: bpqether driver version 004\\n\";\n\nstatic int bpq_rcv(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *);\nstatic int bpq_device_event(struct notifier_block *, unsigned long, void *);\n\nstatic struct packet_type bpq_packet_type __read_mostly = {\n\t.type\t= cpu_to_be16(ETH_P_BPQ),\n\t.func\t= bpq_rcv,\n};\n\nstatic struct notifier_block bpq_dev_notifier = {\n\t.notifier_call = bpq_device_event,\n};\n\n\nstruct bpqdev {\n\tstruct list_head bpq_list;\t \n\tstruct net_device *ethdev;\t \n\tstruct net_device *axdev;\t \n\tchar   dest_addr[6];\t\t \n\tchar   acpt_addr[6];\t\t \n};\n\nstatic LIST_HEAD(bpq_devices);\n\n \nstatic struct lock_class_key bpq_netdev_xmit_lock_key;\nstatic struct lock_class_key bpq_netdev_addr_lock_key;\n\nstatic void bpq_set_lockdep_class_one(struct net_device *dev,\n\t\t\t\t      struct netdev_queue *txq,\n\t\t\t\t      void *_unused)\n{\n\tlockdep_set_class(&txq->_xmit_lock, &bpq_netdev_xmit_lock_key);\n}\n\nstatic void bpq_set_lockdep_class(struct net_device *dev)\n{\n\tlockdep_set_class(&dev->addr_list_lock, &bpq_netdev_addr_lock_key);\n\tnetdev_for_each_tx_queue(dev, bpq_set_lockdep_class_one, NULL);\n}\n\n \n\n\n \nstatic inline struct net_device *bpq_get_ether_dev(struct net_device *dev)\n{\n\tstruct bpqdev *bpq = netdev_priv(dev);\n\n\treturn bpq ? bpq->ethdev : NULL;\n}\n\n \nstatic inline struct net_device *bpq_get_ax25_dev(struct net_device *dev)\n{\n\tstruct bpqdev *bpq;\n\n\tlist_for_each_entry_rcu(bpq, &bpq_devices, bpq_list,\n\t\t\t\tlockdep_rtnl_is_held()) {\n\t\tif (bpq->ethdev == dev)\n\t\t\treturn bpq->axdev;\n\t}\n\treturn NULL;\n}\n\nstatic inline int dev_is_ethdev(struct net_device *dev)\n{\n\treturn dev->type == ARPHRD_ETHER && strncmp(dev->name, \"dummy\", 5);\n}\n\n \n\n\n \nstatic int bpq_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *ptype, struct net_device *orig_dev)\n{\n\tint len;\n\tchar * ptr;\n\tstruct ethhdr *eth;\n\tstruct bpqdev *bpq;\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\tgoto drop;\n\n\tif ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL)\n\t\treturn NET_RX_DROP;\n\n\tif (!pskb_may_pull(skb, sizeof(struct ethhdr)))\n\t\tgoto drop;\n\n\trcu_read_lock();\n\tdev = bpq_get_ax25_dev(dev);\n\n\tif (dev == NULL || !netif_running(dev)) \n\t\tgoto drop_unlock;\n\n\t \n\n\tbpq = netdev_priv(dev);\n\n\teth = eth_hdr(skb);\n\n\tif (!(bpq->acpt_addr[0] & 0x01) &&\n\t    !ether_addr_equal(eth->h_source, bpq->acpt_addr))\n\t\tgoto drop_unlock;\n\n\tif (skb_cow(skb, sizeof(struct ethhdr)))\n\t\tgoto drop_unlock;\n\n\tlen = skb->data[0] + skb->data[1] * 256 - 5;\n\n\tskb_pull(skb, 2);\t \n\tskb_trim(skb, len);\t \n\n\tdev->stats.rx_packets++;\n\tdev->stats.rx_bytes += len;\n\n\tptr = skb_push(skb, 1);\n\t*ptr = 0;\n\n\tskb->protocol = ax25_type_trans(skb, dev);\n\tnetif_rx(skb);\nunlock:\n\n\trcu_read_unlock();\n\n\treturn 0;\ndrop_unlock:\n\tkfree_skb(skb);\n\tgoto unlock;\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\n \nstatic netdev_tx_t bpq_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tunsigned char *ptr;\n\tstruct bpqdev *bpq;\n\tstruct net_device *orig_dev;\n\tint size;\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn ax25_ip_xmit(skb);\n\n\t \n\tif (!netif_running(dev)) {\n\t\tkfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tskb_pull(skb, 1);\t\t\t \n\tsize = skb->len;\n\n\t \n\tif (skb_cow(skb, AX25_BPQ_HEADER_LEN)) {\n\t\tif (net_ratelimit())\n\t\t\tpr_err(\"bpqether: out of memory\\n\");\n\t\tkfree_skb(skb);\n\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tptr = skb_push(skb, 2);\t\t\t \n\n\t*ptr++ = (size + 5) % 256;\n\t*ptr++ = (size + 5) / 256;\n\n\tbpq = netdev_priv(dev);\n\n\torig_dev = dev;\n\tif ((dev = bpq_get_ether_dev(dev)) == NULL) {\n\t\torig_dev->stats.tx_dropped++;\n\t\tkfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tskb->protocol = ax25_type_trans(skb, dev);\n\tskb_reset_network_header(skb);\n\tdev_hard_header(skb, dev, ETH_P_BPQ, bpq->dest_addr, NULL, 0);\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes+=skb->len;\n  \n\tdev_queue_xmit(skb);\n\tnetif_wake_queue(dev);\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic int bpq_set_mac_address(struct net_device *dev, void *addr)\n{\n    struct sockaddr *sa = (struct sockaddr *)addr;\n\n    dev_addr_set(dev, sa->sa_data);\n\n    return 0;\n}\n\n \nstatic int bpq_siocdevprivate(struct net_device *dev, struct ifreq *ifr,\n\t\t\t      void __user *data, int cmd)\n{\n\tstruct bpq_ethaddr __user *ethaddr = data;\n\tstruct bpqdev *bpq = netdev_priv(dev);\n\tstruct bpq_req req;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\t\tcase SIOCSBPQETHOPT:\n\t\t\tif (copy_from_user(&req, data, sizeof(struct bpq_req)))\n\t\t\t\treturn -EFAULT;\n\t\t\tswitch (req.cmd) {\n\t\t\t\tcase SIOCGBPQETHPARAM:\n\t\t\t\tcase SIOCSBPQETHPARAM:\n\t\t\t\tdefault:\n\t\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase SIOCSBPQETHADDR:\n\t\t\tif (copy_from_user(bpq->dest_addr, ethaddr->destination, ETH_ALEN))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (copy_from_user(bpq->acpt_addr, ethaddr->accept, ETH_ALEN))\n\t\t\t\treturn -EFAULT;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int bpq_open(struct net_device *dev)\n{\n\tnetif_start_queue(dev);\n\treturn 0;\n}\n\nstatic int bpq_close(struct net_device *dev)\n{\n\tnetif_stop_queue(dev);\n\treturn 0;\n}\n\n\n \n\n#ifdef CONFIG_PROC_FS\n \nstatic void *bpq_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(RCU)\n{\n\tint i = 1;\n\tstruct bpqdev *bpqdev;\n\n\trcu_read_lock();\n\n\tif (*pos == 0)\n\t\treturn SEQ_START_TOKEN;\n\t\n\tlist_for_each_entry_rcu(bpqdev, &bpq_devices, bpq_list) {\n\t\tif (i == *pos)\n\t\t\treturn bpqdev;\n\t}\n\treturn NULL;\n}\n\nstatic void *bpq_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct list_head *p;\n\tstruct bpqdev *bpqdev = v;\n\n\t++*pos;\n\n\tif (v == SEQ_START_TOKEN)\n\t\tp = rcu_dereference(list_next_rcu(&bpq_devices));\n\telse\n\t\tp = rcu_dereference(list_next_rcu(&bpqdev->bpq_list));\n\n\treturn (p == &bpq_devices) ? NULL \n\t\t: list_entry(p, struct bpqdev, bpq_list);\n}\n\nstatic void bpq_seq_stop(struct seq_file *seq, void *v)\n\t__releases(RCU)\n{\n\trcu_read_unlock();\n}\n\n\nstatic int bpq_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq, \n\t\t\t \"dev   ether      destination        accept from\\n\");\n\telse {\n\t\tconst struct bpqdev *bpqdev = v;\n\n\t\tseq_printf(seq, \"%-5s %-10s %pM  \",\n\t\t\tbpqdev->axdev->name, bpqdev->ethdev->name,\n\t\t\tbpqdev->dest_addr);\n\n\t\tif (is_multicast_ether_addr(bpqdev->acpt_addr))\n\t\t\tseq_printf(seq, \"*\\n\");\n\t\telse\n\t\t\tseq_printf(seq, \"%pM\\n\", bpqdev->acpt_addr);\n\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations bpq_seqops = {\n\t.start = bpq_seq_start,\n\t.next = bpq_seq_next,\n\t.stop = bpq_seq_stop,\n\t.show = bpq_seq_show,\n};\n#endif\n \n\nstatic const struct net_device_ops bpq_netdev_ops = {\n\t.ndo_open\t     = bpq_open,\n\t.ndo_stop\t     = bpq_close,\n\t.ndo_start_xmit\t     = bpq_xmit,\n\t.ndo_set_mac_address = bpq_set_mac_address,\n\t.ndo_siocdevprivate  = bpq_siocdevprivate,\n};\n\nstatic void bpq_setup(struct net_device *dev)\n{\n\tdev->netdev_ops\t     = &bpq_netdev_ops;\n\tdev->needs_free_netdev = true;\n\n\tdev->flags      = 0;\n\tdev->features\t= NETIF_F_LLTX;\t \n\n#if IS_ENABLED(CONFIG_AX25)\n\tdev->header_ops      = &ax25_header_ops;\n#endif\n\n\tdev->type            = ARPHRD_AX25;\n\tdev->hard_header_len = AX25_MAX_HEADER_LEN + AX25_BPQ_HEADER_LEN;\n\tdev->mtu             = AX25_DEF_PACLEN;\n\tdev->addr_len        = AX25_ADDR_LEN;\n\n\tmemcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);\n\tdev_addr_set(dev, (u8 *)&ax25_defaddr);\n}\n\n \nstatic int bpq_new_device(struct net_device *edev)\n{\n\tint err;\n\tstruct net_device *ndev;\n\tstruct bpqdev *bpq;\n\n\tndev = alloc_netdev(sizeof(struct bpqdev), \"bpq%d\", NET_NAME_UNKNOWN,\n\t\t\t    bpq_setup);\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\t\t\n\tbpq = netdev_priv(ndev);\n\tdev_hold(edev);\n\tbpq->ethdev = edev;\n\tbpq->axdev = ndev;\n\n\teth_broadcast_addr(bpq->dest_addr);\n\teth_broadcast_addr(bpq->acpt_addr);\n\n\terr = register_netdevice(ndev);\n\tif (err)\n\t\tgoto error;\n\tbpq_set_lockdep_class(ndev);\n\n\t \n\tlist_add_rcu(&bpq->bpq_list, &bpq_devices);\n\treturn 0;\n\n error:\n\tdev_put(edev);\n\tfree_netdev(ndev);\n\treturn err;\n\t\n}\n\nstatic void bpq_free_device(struct net_device *ndev)\n{\n\tstruct bpqdev *bpq = netdev_priv(ndev);\n\n\tdev_put(bpq->ethdev);\n\tlist_del_rcu(&bpq->bpq_list);\n\n\tunregister_netdevice(ndev);\n}\n\n \nstatic int bpq_device_event(struct notifier_block *this,\n\t\t\t    unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\treturn NOTIFY_DONE;\n\n\tif (!dev_is_ethdev(dev) && !bpq_get_ax25_dev(dev))\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_UP:\t\t \n\t\tif (bpq_get_ax25_dev(dev) == NULL)\n\t\t\tbpq_new_device(dev);\n\t\tbreak;\n\n\tcase NETDEV_DOWN:\t \n\t\tif ((dev = bpq_get_ax25_dev(dev)) != NULL)\n\t\t\tdev_close(dev);\n\t\tbreak;\n\n\tcase NETDEV_UNREGISTER:\t \n\t\tif ((dev = bpq_get_ax25_dev(dev)) != NULL)\n\t\t\tbpq_free_device(dev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\n\n \n\n \nstatic int __init bpq_init_driver(void)\n{\n#ifdef CONFIG_PROC_FS\n\tif (!proc_create_seq(\"bpqether\", 0444, init_net.proc_net, &bpq_seqops)) {\n\t\tprintk(KERN_ERR\n\t\t\t\"bpq: cannot create /proc/net/bpqether entry.\\n\");\n\t\treturn -ENOENT;\n\t}\n#endif   \n\n\tdev_add_pack(&bpq_packet_type);\n\n\tregister_netdevice_notifier(&bpq_dev_notifier);\n\n\tprintk(banner);\n\n\treturn 0;\n}\n\nstatic void __exit bpq_cleanup_driver(void)\n{\n\tstruct bpqdev *bpq;\n\n\tdev_remove_pack(&bpq_packet_type);\n\n\tunregister_netdevice_notifier(&bpq_dev_notifier);\n\n\tremove_proc_entry(\"bpqether\", init_net.proc_net);\n\n\trtnl_lock();\n\twhile (!list_empty(&bpq_devices)) {\n\t\tbpq = list_entry(bpq_devices.next, struct bpqdev, bpq_list);\n\t\tbpq_free_device(bpq->axdev);\n\t}\n\trtnl_unlock();\n}\n\nMODULE_AUTHOR(\"Joerg Reuter DL1BKE <jreuter@yaina.de>\");\nMODULE_DESCRIPTION(\"Transmit and receive AX.25 packets over Ethernet\");\nMODULE_LICENSE(\"GPL\");\nmodule_init(bpq_init_driver);\nmodule_exit(bpq_cleanup_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}