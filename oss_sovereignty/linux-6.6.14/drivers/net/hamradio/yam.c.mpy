{
  "module_name": "yam.c",
  "hash_id": "2b54eac72c093a87d0e4166e09bf3d538a12aba82a30d6dee4263a1f5626ee88",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/hamradio/yam.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <linux/if.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/bitops.h>\n#include <linux/random.h>\n#include <asm/io.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/firmware.h>\n#include <linux/platform_device.h>\n\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <net/ax25.h>\n\n#include <linux/kernel.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <net/net_namespace.h>\n\n#include <linux/uaccess.h>\n#include <linux/init.h>\n\n#include <linux/yam.h>\n\n \n\nstatic const char yam_drvname[] = \"yam\";\nstatic const char yam_drvinfo[] __initconst = KERN_INFO \\\n\t\"YAM driver version 0.8 by F1OAT/F6FBB\\n\";\n\n \n\n#define FIRMWARE_9600\t\"yam/9600.bin\"\n#define FIRMWARE_1200\t\"yam/1200.bin\"\n\n#define YAM_9600\t1\n#define YAM_1200\t2\n\n#define NR_PORTS\t4\n#define YAM_MAGIC\t0xF10A7654\n\n \n\n#define TX_OFF\t\t0\n#define TX_HEAD\t\t1\n#define TX_DATA\t\t2\n#define TX_CRC1\t\t3\n#define TX_CRC2\t\t4\n#define TX_TAIL\t\t5\n\n#define YAM_MAX_FRAME\t1024\n\n#define DEFAULT_BITRATE\t9600\t\t\t \n#define DEFAULT_HOLDD\t10\t\t\t \n#define DEFAULT_TXD\t300\t\t\t \n#define DEFAULT_TXTAIL\t10\t\t\t \n#define DEFAULT_SLOT\t100\t\t\t \n#define DEFAULT_PERS\t64\t\t\t \n\nstruct yam_port {\n\tint magic;\n\tint bitrate;\n\tint baudrate;\n\tint iobase;\n\tint irq;\n\tint dupmode;\n\n\tstruct net_device *dev;\n\n\tint nb_rxint;\n\tint nb_mdint;\n\n\t \n\n\tint txd;\t\t\t\t \n\tint holdd;\t\t\t\t \n\tint txtail;\t\t\t\t \n\tint slot;\t\t\t\t \n\tint pers;\t\t\t\t \n\n\t \n\n\tint tx_state;\n\tint tx_count;\n\tint slotcnt;\n\tunsigned char tx_buf[YAM_MAX_FRAME];\n\tint tx_len;\n\tint tx_crcl, tx_crch;\n\tstruct sk_buff_head send_queue;\t\t \n\n\t \n\n\tint dcd;\n\tunsigned char rx_buf[YAM_MAX_FRAME];\n\tint rx_len;\n\tint rx_crcl, rx_crch;\n};\n\nstruct yam_mcs {\n\tunsigned char bits[YAM_FPGA_SIZE];\n\tint bitrate;\n\tstruct yam_mcs *next;\n};\n\nstatic struct net_device *yam_devs[NR_PORTS];\n\nstatic struct yam_mcs *yam_data;\n\nstatic DEFINE_TIMER(yam_timer, NULL);\n\n \n\n#define RBR(iobase)\t(iobase+0)\n#define THR(iobase)\t(iobase+0)\n#define IER(iobase)\t(iobase+1)\n#define IIR(iobase)\t(iobase+2)\n#define FCR(iobase)\t(iobase+2)\n#define LCR(iobase)\t(iobase+3)\n#define MCR(iobase)\t(iobase+4)\n#define LSR(iobase)\t(iobase+5)\n#define MSR(iobase)\t(iobase+6)\n#define SCR(iobase)\t(iobase+7)\n#define DLL(iobase)\t(iobase+0)\n#define DLM(iobase)\t(iobase+1)\n\n#define YAM_EXTENT\t8\n\n \n#define IIR_NOPEND\t1\n#define IIR_MSR\t\t0\n#define IIR_TX\t\t2\n#define IIR_RX\t\t4\n#define IIR_LSR\t\t6\n#define IIR_TIMEOUT\t12\t\t\t \n\n#define IIR_MASK\t0x0F\n\n \n#define IER_RX\t\t1\t\t\t \n#define IER_TX\t\t2\t\t\t \n#define IER_LSR\t\t4\t\t\t \n#define IER_MSR\t\t8\t\t\t \n\n \n#define MCR_DTR\t\t0x01\t\t\t \n#define MCR_RTS\t\t0x02\t\t\t \n#define MCR_OUT1\t0x04\t\t\t \n#define MCR_OUT2\t0x08\t\t\t \n#define MCR_LOOP\t0x10\t\t\t \n\n \n#define MSR_DCTS\t0x01\t\t\t \n#define MSR_DDSR\t0x02\t\t\t \n#define MSR_DRIN\t0x04\t\t\t \n#define MSR_DDCD\t0x08\t\t\t \n#define MSR_CTS\t\t0x10\t\t\t \n#define MSR_DSR\t\t0x20\t\t\t \n#define MSR_RING\t0x40\t\t\t \n#define MSR_DCD\t\t0x80\t\t\t \n\n \n#define LSR_RXC\t\t0x01\n#define LSR_OE\t\t0x02\n#define LSR_PE\t\t0x04\n#define LSR_FE\t\t0x08\n#define LSR_BREAK\t0x10\n#define LSR_THRE\t0x20\n#define LSR_TSRE\t0x40\n\n \n#define LCR_DLAB\t0x80\n#define LCR_BREAK\t0x40\n#define LCR_PZERO\t0x28\n#define LCR_PEVEN\t0x18\n#define LCR_PODD\t0x08\n#define LCR_STOP1\t0x00\n#define LCR_STOP2\t0x04\n#define LCR_BIT5\t0x00\n#define LCR_BIT6\t0x02\n#define LCR_BIT7\t0x01\n#define LCR_BIT8\t0x03\n\n \n\n#define TX_RDY\t\tMSR_DCTS\t\t \n#define RX_DCD\t\tMSR_DCD\t\t\t \n#define RX_FLAG\t\tMSR_RING\t\t \n#define FPGA_DONE\tMSR_DSR\t\t\t \n#define PTT_ON\t\t(MCR_RTS|MCR_OUT2)\t \n#define PTT_OFF\t\t(MCR_DTR|MCR_OUT2)\t \n\n#define ENABLE_RXINT\tIER_RX\t\t\t \n#define ENABLE_TXINT\tIER_MSR\t\t\t \n#define ENABLE_RTXINT\t(IER_RX|IER_MSR)\t \n\n\n \n\nstatic const unsigned char chktabl[256] =\n{0x00, 0x89, 0x12, 0x9b, 0x24, 0xad, 0x36, 0xbf, 0x48, 0xc1, 0x5a, 0xd3, 0x6c, 0xe5, 0x7e,\n 0xf7, 0x81, 0x08, 0x93, 0x1a, 0xa5, 0x2c, 0xb7, 0x3e, 0xc9, 0x40, 0xdb, 0x52, 0xed, 0x64,\n 0xff, 0x76, 0x02, 0x8b, 0x10, 0x99, 0x26, 0xaf, 0x34, 0xbd, 0x4a, 0xc3, 0x58, 0xd1, 0x6e,\n 0xe7, 0x7c, 0xf5, 0x83, 0x0a, 0x91, 0x18, 0xa7, 0x2e, 0xb5, 0x3c, 0xcb, 0x42, 0xd9, 0x50,\n 0xef, 0x66, 0xfd, 0x74, 0x04, 0x8d, 0x16, 0x9f, 0x20, 0xa9, 0x32, 0xbb, 0x4c, 0xc5, 0x5e,\n 0xd7, 0x68, 0xe1, 0x7a, 0xf3, 0x85, 0x0c, 0x97, 0x1e, 0xa1, 0x28, 0xb3, 0x3a, 0xcd, 0x44,\n 0xdf, 0x56, 0xe9, 0x60, 0xfb, 0x72, 0x06, 0x8f, 0x14, 0x9d, 0x22, 0xab, 0x30, 0xb9, 0x4e,\n 0xc7, 0x5c, 0xd5, 0x6a, 0xe3, 0x78, 0xf1, 0x87, 0x0e, 0x95, 0x1c, 0xa3, 0x2a, 0xb1, 0x38,\n 0xcf, 0x46, 0xdd, 0x54, 0xeb, 0x62, 0xf9, 0x70, 0x08, 0x81, 0x1a, 0x93, 0x2c, 0xa5, 0x3e,\n 0xb7, 0x40, 0xc9, 0x52, 0xdb, 0x64, 0xed, 0x76, 0xff, 0x89, 0x00, 0x9b, 0x12, 0xad, 0x24,\n 0xbf, 0x36, 0xc1, 0x48, 0xd3, 0x5a, 0xe5, 0x6c, 0xf7, 0x7e, 0x0a, 0x83, 0x18, 0x91, 0x2e,\n 0xa7, 0x3c, 0xb5, 0x42, 0xcb, 0x50, 0xd9, 0x66, 0xef, 0x74, 0xfd, 0x8b, 0x02, 0x99, 0x10,\n 0xaf, 0x26, 0xbd, 0x34, 0xc3, 0x4a, 0xd1, 0x58, 0xe7, 0x6e, 0xf5, 0x7c, 0x0c, 0x85, 0x1e,\n 0x97, 0x28, 0xa1, 0x3a, 0xb3, 0x44, 0xcd, 0x56, 0xdf, 0x60, 0xe9, 0x72, 0xfb, 0x8d, 0x04,\n 0x9f, 0x16, 0xa9, 0x20, 0xbb, 0x32, 0xc5, 0x4c, 0xd7, 0x5e, 0xe1, 0x68, 0xf3, 0x7a, 0x0e,\n 0x87, 0x1c, 0x95, 0x2a, 0xa3, 0x38, 0xb1, 0x46, 0xcf, 0x54, 0xdd, 0x62, 0xeb, 0x70, 0xf9,\n 0x8f, 0x06, 0x9d, 0x14, 0xab, 0x22, 0xb9, 0x30, 0xc7, 0x4e, 0xd5, 0x5c, 0xe3, 0x6a, 0xf1,\n 0x78};\nstatic const unsigned char chktabh[256] =\n{0x00, 0x11, 0x23, 0x32, 0x46, 0x57, 0x65, 0x74, 0x8c, 0x9d, 0xaf, 0xbe, 0xca, 0xdb, 0xe9,\n 0xf8, 0x10, 0x01, 0x33, 0x22, 0x56, 0x47, 0x75, 0x64, 0x9c, 0x8d, 0xbf, 0xae, 0xda, 0xcb,\n 0xf9, 0xe8, 0x21, 0x30, 0x02, 0x13, 0x67, 0x76, 0x44, 0x55, 0xad, 0xbc, 0x8e, 0x9f, 0xeb,\n 0xfa, 0xc8, 0xd9, 0x31, 0x20, 0x12, 0x03, 0x77, 0x66, 0x54, 0x45, 0xbd, 0xac, 0x9e, 0x8f,\n 0xfb, 0xea, 0xd8, 0xc9, 0x42, 0x53, 0x61, 0x70, 0x04, 0x15, 0x27, 0x36, 0xce, 0xdf, 0xed,\n 0xfc, 0x88, 0x99, 0xab, 0xba, 0x52, 0x43, 0x71, 0x60, 0x14, 0x05, 0x37, 0x26, 0xde, 0xcf,\n 0xfd, 0xec, 0x98, 0x89, 0xbb, 0xaa, 0x63, 0x72, 0x40, 0x51, 0x25, 0x34, 0x06, 0x17, 0xef,\n 0xfe, 0xcc, 0xdd, 0xa9, 0xb8, 0x8a, 0x9b, 0x73, 0x62, 0x50, 0x41, 0x35, 0x24, 0x16, 0x07,\n 0xff, 0xee, 0xdc, 0xcd, 0xb9, 0xa8, 0x9a, 0x8b, 0x84, 0x95, 0xa7, 0xb6, 0xc2, 0xd3, 0xe1,\n 0xf0, 0x08, 0x19, 0x2b, 0x3a, 0x4e, 0x5f, 0x6d, 0x7c, 0x94, 0x85, 0xb7, 0xa6, 0xd2, 0xc3,\n 0xf1, 0xe0, 0x18, 0x09, 0x3b, 0x2a, 0x5e, 0x4f, 0x7d, 0x6c, 0xa5, 0xb4, 0x86, 0x97, 0xe3,\n 0xf2, 0xc0, 0xd1, 0x29, 0x38, 0x0a, 0x1b, 0x6f, 0x7e, 0x4c, 0x5d, 0xb5, 0xa4, 0x96, 0x87,\n 0xf3, 0xe2, 0xd0, 0xc1, 0x39, 0x28, 0x1a, 0x0b, 0x7f, 0x6e, 0x5c, 0x4d, 0xc6, 0xd7, 0xe5,\n 0xf4, 0x80, 0x91, 0xa3, 0xb2, 0x4a, 0x5b, 0x69, 0x78, 0x0c, 0x1d, 0x2f, 0x3e, 0xd6, 0xc7,\n 0xf5, 0xe4, 0x90, 0x81, 0xb3, 0xa2, 0x5a, 0x4b, 0x79, 0x68, 0x1c, 0x0d, 0x3f, 0x2e, 0xe7,\n 0xf6, 0xc4, 0xd5, 0xa1, 0xb0, 0x82, 0x93, 0x6b, 0x7a, 0x48, 0x59, 0x2d, 0x3c, 0x0e, 0x1f,\n 0xf7, 0xe6, 0xd4, 0xc5, 0xb1, 0xa0, 0x92, 0x83, 0x7b, 0x6a, 0x58, 0x49, 0x3d, 0x2c, 0x1e,\n 0x0f};\n\n \n\nstatic void delay(int ms)\n{\n\tunsigned long timeout = jiffies + ((ms * HZ) / 1000);\n\twhile (time_before(jiffies, timeout))\n\t\tcpu_relax();\n}\n\n \n\nstatic void fpga_reset(int iobase)\n{\n\toutb(0, IER(iobase));\n\toutb(LCR_DLAB | LCR_BIT5, LCR(iobase));\n\toutb(1, DLL(iobase));\n\toutb(0, DLM(iobase));\n\n\toutb(LCR_BIT5, LCR(iobase));\n\tinb(LSR(iobase));\n\tinb(MSR(iobase));\n\t \n\toutb(MCR_OUT1 | MCR_OUT2, MCR(iobase));\n\tdelay(100);\n\t \n\toutb(MCR_DTR | MCR_RTS | MCR_OUT1 | MCR_OUT2, MCR(iobase));\n\tdelay(100);\n}\n\n \n\nstatic int fpga_write(int iobase, unsigned char wrd)\n{\n\tunsigned char bit;\n\tint k;\n\tunsigned long timeout = jiffies + HZ / 10;\n\n\tfor (k = 0; k < 8; k++) {\n\t\tbit = (wrd & 0x80) ? (MCR_RTS | MCR_DTR) : MCR_DTR;\n\t\toutb(bit | MCR_OUT1 | MCR_OUT2, MCR(iobase));\n\t\twrd <<= 1;\n\t\toutb(0xfc, THR(iobase));\n\t\twhile ((inb(LSR(iobase)) & LSR_TSRE) == 0)\n\t\t\tif (time_after(jiffies, timeout))\n\t\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic unsigned char *add_mcs(unsigned char *bits, int bitrate,\n\t\t\t      unsigned int predef)\n{\n\tconst char *fw_name[2] = {FIRMWARE_9600, FIRMWARE_1200};\n\tconst struct firmware *fw;\n\tstruct platform_device *pdev;\n\tstruct yam_mcs *p;\n\tint err;\n\n\tswitch (predef) {\n\tcase 0:\n\t\tfw = NULL;\n\t\tbreak;\n\tcase YAM_1200:\n\tcase YAM_9600:\n\t\tpredef--;\n\t\tpdev = platform_device_register_simple(\"yam\", 0, NULL, 0);\n\t\tif (IS_ERR(pdev)) {\n\t\t\tprintk(KERN_ERR \"yam: Failed to register firmware\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\terr = request_firmware(&fw, fw_name[predef], &pdev->dev);\n\t\tplatform_device_unregister(pdev);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR \"Failed to load firmware \\\"%s\\\"\\n\",\n\t\t\t       fw_name[predef]);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (fw->size != YAM_FPGA_SIZE) {\n\t\t\tprintk(KERN_ERR \"Bogus length %zu in firmware \\\"%s\\\"\\n\",\n\t\t\t       fw->size, fw_name[predef]);\n\t\t\trelease_firmware(fw);\n\t\t\treturn NULL;\n\t\t}\n\t\tbits = (unsigned char *)fw->data;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"yam: Invalid predef number %u\\n\", predef);\n\t\treturn NULL;\n\t}\n\n\t \n\tp = yam_data;\n\twhile (p) {\n\t\tif (p->bitrate == bitrate) {\n\t\t\tmemcpy(p->bits, bits, YAM_FPGA_SIZE);\n\t\t\tgoto out;\n\t\t}\n\t\tp = p->next;\n\t}\n\n\t \n\tif ((p = kmalloc(sizeof(struct yam_mcs), GFP_KERNEL)) == NULL) {\n\t\trelease_firmware(fw);\n\t\treturn NULL;\n\t}\n\tmemcpy(p->bits, bits, YAM_FPGA_SIZE);\n\tp->bitrate = bitrate;\n\tp->next = yam_data;\n\tyam_data = p;\n out:\n\trelease_firmware(fw);\n\treturn p->bits;\n}\n\nstatic unsigned char *get_mcs(int bitrate)\n{\n\tstruct yam_mcs *p;\n\n\tp = yam_data;\n\twhile (p) {\n\t\tif (p->bitrate == bitrate)\n\t\t\treturn p->bits;\n\t\tp = p->next;\n\t}\n\n\t \n\tswitch (bitrate) {\n\tcase 1200:\n\t\t \n\t\treturn add_mcs(NULL, bitrate, YAM_1200);\n\tdefault:\n\t\t \n\t\treturn add_mcs(NULL, bitrate, YAM_9600);\n\t}\n}\n\n \n\nstatic int fpga_download(int iobase, int bitrate)\n{\n\tint i, rc;\n\tunsigned char *pbits;\n\n\tpbits = get_mcs(bitrate);\n\tif (pbits == NULL)\n\t\treturn -1;\n\n\tfpga_reset(iobase);\n\tfor (i = 0; i < YAM_FPGA_SIZE; i++) {\n\t\tif (fpga_write(iobase, pbits[i])) {\n\t\t\tprintk(KERN_ERR \"yam: error in write cycle\\n\");\n\t\t\treturn -1;\t\t\t \n\t\t}\n\t}\n\n\tfpga_write(iobase, 0xFF);\n\trc = inb(MSR(iobase));\t\t \n\n\t \n\tdelay(50);\n\n\treturn (rc & MSR_DSR) ? 0 : -1;\n}\n\n\n \n\nstatic void yam_set_uart(struct net_device *dev)\n{\n\tstruct yam_port *yp = netdev_priv(dev);\n\tint divisor = 115200 / yp->baudrate;\n\n\toutb(0, IER(dev->base_addr));\n\toutb(LCR_DLAB | LCR_BIT8, LCR(dev->base_addr));\n\toutb(divisor, DLL(dev->base_addr));\n\toutb(0, DLM(dev->base_addr));\n\toutb(LCR_BIT8, LCR(dev->base_addr));\n\toutb(PTT_OFF, MCR(dev->base_addr));\n\toutb(0x00, FCR(dev->base_addr));\n\n\t \n\n\tinb(RBR(dev->base_addr));\n\tinb(MSR(dev->base_addr));\n\n\t \n\n\toutb(ENABLE_RTXINT, IER(dev->base_addr));\n}\n\n\n \n\nenum uart {\n\tc_uart_unknown, c_uart_8250,\n\tc_uart_16450, c_uart_16550, c_uart_16550A\n};\n\nstatic const char *uart_str[] =\n{\"unknown\", \"8250\", \"16450\", \"16550\", \"16550A\"};\n\nstatic enum uart yam_check_uart(unsigned int iobase)\n{\n\tunsigned char b1, b2, b3;\n\tenum uart u;\n\tenum uart uart_tab[] =\n\t{c_uart_16450, c_uart_unknown, c_uart_16550, c_uart_16550A};\n\n\tb1 = inb(MCR(iobase));\n\toutb(b1 | 0x10, MCR(iobase));\t \n\tb2 = inb(MSR(iobase));\n\toutb(0x1a, MCR(iobase));\n\tb3 = inb(MSR(iobase)) & 0xf0;\n\toutb(b1, MCR(iobase));\t\t \n\toutb(b2, MSR(iobase));\n\tif (b3 != 0x90)\n\t\treturn c_uart_unknown;\n\tinb(RBR(iobase));\n\tinb(RBR(iobase));\n\toutb(0x01, FCR(iobase));\t \n\tu = uart_tab[(inb(IIR(iobase)) >> 6) & 3];\n\tif (u == c_uart_16450) {\n\t\toutb(0x5a, SCR(iobase));\n\t\tb1 = inb(SCR(iobase));\n\t\toutb(0xa5, SCR(iobase));\n\t\tb2 = inb(SCR(iobase));\n\t\tif ((b1 != 0x5a) || (b2 != 0xa5))\n\t\t\tu = c_uart_8250;\n\t}\n\treturn u;\n}\n\n \nstatic inline void yam_rx_flag(struct net_device *dev, struct yam_port *yp)\n{\n\tif (yp->dcd && yp->rx_len >= 3 && yp->rx_len < YAM_MAX_FRAME) {\n\t\tint pkt_len = yp->rx_len - 2 + 1;\t \n\t\tstruct sk_buff *skb;\n\n\t\tif ((yp->rx_crch & yp->rx_crcl) != 0xFF) {\n\t\t\t \n\t\t} else {\n\t\t\tif (!(skb = dev_alloc_skb(pkt_len))) {\n\t\t\t\tprintk(KERN_WARNING \"%s: memory squeeze, dropping packet\\n\", dev->name);\n\t\t\t\t++dev->stats.rx_dropped;\n\t\t\t} else {\n\t\t\t\tunsigned char *cp;\n\t\t\t\tcp = skb_put(skb, pkt_len);\n\t\t\t\t*cp++ = 0;\t\t \n\t\t\t\tmemcpy(cp, yp->rx_buf, pkt_len - 1);\n\t\t\t\tskb->protocol = ax25_type_trans(skb, dev);\n\t\t\t\tnetif_rx(skb);\n\t\t\t\t++dev->stats.rx_packets;\n\t\t\t}\n\t\t}\n\t}\n\typ->rx_len = 0;\n\typ->rx_crcl = 0x21;\n\typ->rx_crch = 0xf3;\n}\n\nstatic inline void yam_rx_byte(struct net_device *dev, struct yam_port *yp, unsigned char rxb)\n{\n\tif (yp->rx_len < YAM_MAX_FRAME) {\n\t\tunsigned char c = yp->rx_crcl;\n\t\typ->rx_crcl = (chktabl[c] ^ yp->rx_crch);\n\t\typ->rx_crch = (chktabh[c] ^ rxb);\n\t\typ->rx_buf[yp->rx_len++] = rxb;\n\t}\n}\n\n \n\nstatic void ptt_on(struct net_device *dev)\n{\n\toutb(PTT_ON, MCR(dev->base_addr));\n}\n\nstatic void ptt_off(struct net_device *dev)\n{\n\toutb(PTT_OFF, MCR(dev->base_addr));\n}\n\nstatic netdev_tx_t yam_send_packet(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\tstruct yam_port *yp = netdev_priv(dev);\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn ax25_ip_xmit(skb);\n\n\tskb_queue_tail(&yp->send_queue, skb);\n\tnetif_trans_update(dev);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void yam_start_tx(struct net_device *dev, struct yam_port *yp)\n{\n\tif ((yp->tx_state == TX_TAIL) || (yp->txd == 0))\n\t\typ->tx_count = 1;\n\telse\n\t\typ->tx_count = (yp->bitrate * yp->txd) / 8000;\n\typ->tx_state = TX_HEAD;\n\tptt_on(dev);\n}\n\nstatic void yam_arbitrate(struct net_device *dev)\n{\n\tstruct yam_port *yp = netdev_priv(dev);\n\n\tif (yp->magic != YAM_MAGIC || yp->tx_state != TX_OFF ||\n\t    skb_queue_empty(&yp->send_queue))\n\t\treturn;\n\t \n\n\tif (yp->dupmode) {\n\t\t \n\t\tyam_start_tx(dev, yp);\n\t\treturn;\n\t}\n\tif (yp->dcd) {\n\t\t \n\t\typ->slotcnt = yp->slot / 10;\n\t\treturn;\n\t}\n\t \n\tif ((--yp->slotcnt) > 0)\n\t\treturn;\n\n\typ->slotcnt = yp->slot / 10;\n\n\t \n\tif (get_random_u8() > yp->pers)\n\t\treturn;\n\n\tyam_start_tx(dev, yp);\n}\n\nstatic void yam_dotimer(struct timer_list *unused)\n{\n\tint i;\n\n\tfor (i = 0; i < NR_PORTS; i++) {\n\t\tstruct net_device *dev = yam_devs[i];\n\t\tif (dev && netif_running(dev))\n\t\t\tyam_arbitrate(dev);\n\t}\n\tyam_timer.expires = jiffies + HZ / 100;\n\tadd_timer(&yam_timer);\n}\n\nstatic void yam_tx_byte(struct net_device *dev, struct yam_port *yp)\n{\n\tstruct sk_buff *skb;\n\tunsigned char b, temp;\n\n\tswitch (yp->tx_state) {\n\tcase TX_OFF:\n\t\tbreak;\n\tcase TX_HEAD:\n\t\tif (--yp->tx_count <= 0) {\n\t\t\tif (!(skb = skb_dequeue(&yp->send_queue))) {\n\t\t\t\tptt_off(dev);\n\t\t\t\typ->tx_state = TX_OFF;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\typ->tx_state = TX_DATA;\n\t\t\tif (skb->data[0] != 0) {\n \n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\typ->tx_len = skb->len - 1;\t \n\t\t\tif (yp->tx_len >= YAM_MAX_FRAME || yp->tx_len < 2) {\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tskb_copy_from_linear_data_offset(skb, 1,\n\t\t\t\t\t\t\t yp->tx_buf,\n\t\t\t\t\t\t\t yp->tx_len);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\typ->tx_count = 0;\n\t\t\typ->tx_crcl = 0x21;\n\t\t\typ->tx_crch = 0xf3;\n\t\t\typ->tx_state = TX_DATA;\n\t\t}\n\t\tbreak;\n\tcase TX_DATA:\n\t\tb = yp->tx_buf[yp->tx_count++];\n\t\toutb(b, THR(dev->base_addr));\n\t\ttemp = yp->tx_crcl;\n\t\typ->tx_crcl = chktabl[temp] ^ yp->tx_crch;\n\t\typ->tx_crch = chktabh[temp] ^ b;\n\t\tif (yp->tx_count >= yp->tx_len) {\n\t\t\typ->tx_state = TX_CRC1;\n\t\t}\n\t\tbreak;\n\tcase TX_CRC1:\n\t\typ->tx_crch = chktabl[yp->tx_crcl] ^ yp->tx_crch;\n\t\typ->tx_crcl = chktabh[yp->tx_crcl] ^ chktabl[yp->tx_crch] ^ 0xff;\n\t\toutb(yp->tx_crcl, THR(dev->base_addr));\n\t\typ->tx_state = TX_CRC2;\n\t\tbreak;\n\tcase TX_CRC2:\n\t\toutb(chktabh[yp->tx_crch] ^ 0xFF, THR(dev->base_addr));\n\t\tif (skb_queue_empty(&yp->send_queue)) {\n\t\t\typ->tx_count = (yp->bitrate * yp->txtail) / 8000;\n\t\t\tif (yp->dupmode == 2)\n\t\t\t\typ->tx_count += (yp->bitrate * yp->holdd) / 8;\n\t\t\tif (yp->tx_count == 0)\n\t\t\t\typ->tx_count = 1;\n\t\t\typ->tx_state = TX_TAIL;\n\t\t} else {\n\t\t\typ->tx_count = 1;\n\t\t\typ->tx_state = TX_HEAD;\n\t\t}\n\t\t++dev->stats.tx_packets;\n\t\tbreak;\n\tcase TX_TAIL:\n\t\tif (--yp->tx_count <= 0) {\n\t\t\typ->tx_state = TX_OFF;\n\t\t\tptt_off(dev);\n\t\t}\n\t\tbreak;\n\t}\n}\n\n \n\nstatic irqreturn_t yam_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev;\n\tstruct yam_port *yp;\n\tunsigned char iir;\n\tint counter = 100;\n\tint i;\n\tint handled = 0;\n\n\tfor (i = 0; i < NR_PORTS; i++) {\n\t\tdev = yam_devs[i];\n\t\typ = netdev_priv(dev);\n\n\t\tif (!netif_running(dev))\n\t\t\tcontinue;\n\n\t\twhile ((iir = IIR_MASK & inb(IIR(dev->base_addr))) != IIR_NOPEND) {\n\t\t\tunsigned char msr = inb(MSR(dev->base_addr));\n\t\t\tunsigned char lsr = inb(LSR(dev->base_addr));\n\t\t\tunsigned char rxb;\n\n\t\t\thandled = 1;\n\n\t\t\tif (lsr & LSR_OE)\n\t\t\t\t++dev->stats.rx_fifo_errors;\n\n\t\t\typ->dcd = (msr & RX_DCD) ? 1 : 0;\n\n\t\t\tif (--counter <= 0) {\n\t\t\t\tprintk(KERN_ERR \"%s: too many irq iir=%d\\n\",\n\t\t\t\t\t\tdev->name, iir);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (msr & TX_RDY) {\n\t\t\t\t++yp->nb_mdint;\n\t\t\t\tyam_tx_byte(dev, yp);\n\t\t\t}\n\t\t\tif (lsr & LSR_RXC) {\n\t\t\t\t++yp->nb_rxint;\n\t\t\t\trxb = inb(RBR(dev->base_addr));\n\t\t\t\tif (msr & RX_FLAG)\n\t\t\t\t\tyam_rx_flag(dev, yp);\n\t\t\t\telse\n\t\t\t\t\tyam_rx_byte(dev, yp, rxb);\n\t\t\t}\n\t\t}\n\t}\nout:\n\treturn IRQ_RETVAL(handled);\n}\n\n#ifdef CONFIG_PROC_FS\n\nstatic void *yam_seq_start(struct seq_file *seq, loff_t *pos)\n{\n\treturn (*pos < NR_PORTS) ? yam_devs[*pos] : NULL;\n}\n\nstatic void *yam_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t++*pos;\n\treturn (*pos < NR_PORTS) ? yam_devs[*pos] : NULL;\n}\n\nstatic void yam_seq_stop(struct seq_file *seq, void *v)\n{\n}\n\nstatic int yam_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct net_device *dev = v;\n\tconst struct yam_port *yp = netdev_priv(dev);\n\n\tseq_printf(seq, \"Device %s\\n\", dev->name);\n\tseq_printf(seq, \"  Up       %d\\n\", netif_running(dev));\n\tseq_printf(seq, \"  Speed    %u\\n\", yp->bitrate);\n\tseq_printf(seq, \"  IoBase   0x%x\\n\", yp->iobase);\n\tseq_printf(seq, \"  BaudRate %u\\n\", yp->baudrate);\n\tseq_printf(seq, \"  IRQ      %u\\n\", yp->irq);\n\tseq_printf(seq, \"  TxState  %u\\n\", yp->tx_state);\n\tseq_printf(seq, \"  Duplex   %u\\n\", yp->dupmode);\n\tseq_printf(seq, \"  HoldDly  %u\\n\", yp->holdd);\n\tseq_printf(seq, \"  TxDelay  %u\\n\", yp->txd);\n\tseq_printf(seq, \"  TxTail   %u\\n\", yp->txtail);\n\tseq_printf(seq, \"  SlotTime %u\\n\", yp->slot);\n\tseq_printf(seq, \"  Persist  %u\\n\", yp->pers);\n\tseq_printf(seq, \"  TxFrames %lu\\n\", dev->stats.tx_packets);\n\tseq_printf(seq, \"  RxFrames %lu\\n\", dev->stats.rx_packets);\n\tseq_printf(seq, \"  TxInt    %u\\n\", yp->nb_mdint);\n\tseq_printf(seq, \"  RxInt    %u\\n\", yp->nb_rxint);\n\tseq_printf(seq, \"  RxOver   %lu\\n\", dev->stats.rx_fifo_errors);\n\tseq_printf(seq, \"\\n\");\n\treturn 0;\n}\n\nstatic const struct seq_operations yam_seqops = {\n\t.start = yam_seq_start,\n\t.next = yam_seq_next,\n\t.stop = yam_seq_stop,\n\t.show = yam_seq_show,\n};\n#endif\n\n\n \n\nstatic int yam_open(struct net_device *dev)\n{\n\tstruct yam_port *yp = netdev_priv(dev);\n\tenum uart u;\n\tint i;\n\tint ret=0;\n\n\tprintk(KERN_INFO \"Trying %s at iobase 0x%lx irq %u\\n\", dev->name, dev->base_addr, dev->irq);\n\n\tif (!yp->bitrate)\n\t\treturn -ENXIO;\n\tif (!dev->base_addr || dev->base_addr > 0x1000 - YAM_EXTENT ||\n\t\tdev->irq < 2 || dev->irq > 15) {\n\t\treturn -ENXIO;\n\t}\n\tif (!request_region(dev->base_addr, YAM_EXTENT, dev->name))\n\t{\n\t\tprintk(KERN_ERR \"%s: cannot 0x%lx busy\\n\", dev->name, dev->base_addr);\n\t\treturn -EACCES;\n\t}\n\tif ((u = yam_check_uart(dev->base_addr)) == c_uart_unknown) {\n\t\tprintk(KERN_ERR \"%s: cannot find uart type\\n\", dev->name);\n\t\tret = -EIO;\n\t\tgoto out_release_base;\n\t}\n\tif (fpga_download(dev->base_addr, yp->bitrate)) {\n\t\tprintk(KERN_ERR \"%s: cannot init FPGA\\n\", dev->name);\n\t\tret = -EIO;\n\t\tgoto out_release_base;\n\t}\n\toutb(0, IER(dev->base_addr));\n\tif (request_irq(dev->irq, yam_interrupt, IRQF_SHARED, dev->name, dev)) {\n\t\tprintk(KERN_ERR \"%s: irq %d busy\\n\", dev->name, dev->irq);\n\t\tret = -EBUSY;\n\t\tgoto out_release_base;\n\t}\n\n\tyam_set_uart(dev);\n\n\tnetif_start_queue(dev);\n\t\n\typ->slotcnt = yp->slot / 10;\n\n\t \n\tfor (i = 0; i < NR_PORTS; i++) {\n\t\tstruct net_device *yam_dev = yam_devs[i];\n\n\t\tinb(LSR(yam_dev->base_addr));\n\t\tyam_dev->stats.rx_fifo_errors = 0;\n\t}\n\n\tprintk(KERN_INFO \"%s at iobase 0x%lx irq %u uart %s\\n\", dev->name, dev->base_addr, dev->irq,\n\t\t   uart_str[u]);\n\treturn 0;\n\nout_release_base:\n\trelease_region(dev->base_addr, YAM_EXTENT);\n\treturn ret;\n}\n\n \n\nstatic int yam_close(struct net_device *dev)\n{\n\tstruct sk_buff *skb;\n\tstruct yam_port *yp = netdev_priv(dev);\n\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\t \n\toutb(0, IER(dev->base_addr));\n\toutb(1, MCR(dev->base_addr));\n\t \n\tfree_irq(dev->irq,dev);\n\trelease_region(dev->base_addr, YAM_EXTENT);\n\tnetif_stop_queue(dev);\n\twhile ((skb = skb_dequeue(&yp->send_queue)))\n\t\tdev_kfree_skb(skb);\n\n\tprintk(KERN_INFO \"%s: close yam at iobase 0x%lx irq %u\\n\",\n\t\t   yam_drvname, dev->base_addr, dev->irq);\n\treturn 0;\n}\n\n \n\nstatic int yam_siocdevprivate(struct net_device *dev, struct ifreq *ifr, void __user *data, int cmd)\n{\n\tstruct yam_port *yp = netdev_priv(dev);\n\tstruct yamdrv_ioctl_cfg yi;\n\tstruct yamdrv_ioctl_mcs *ym;\n\tint ioctl_cmd;\n\n\tif (copy_from_user(&ioctl_cmd, data, sizeof(int)))\n\t\treturn -EFAULT;\n\n\tif (yp->magic != YAM_MAGIC)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (cmd != SIOCDEVPRIVATE)\n\t\treturn -EINVAL;\n\n\tswitch (ioctl_cmd) {\n\n\tcase SIOCYAMRESERVED:\n\t\treturn -EINVAL;\t\t\t \n\n\tcase SIOCYAMSMCS:\n\t\tif (netif_running(dev))\n\t\t\treturn -EINVAL;\t\t \n\t\tym = memdup_user(data, sizeof(struct yamdrv_ioctl_mcs));\n\t\tif (IS_ERR(ym))\n\t\t\treturn PTR_ERR(ym);\n\t\tif (ym->cmd != SIOCYAMSMCS || ym->bitrate > YAM_MAXBITRATE) {\n\t\t\tkfree(ym);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tadd_mcs(ym->bits, ym->bitrate, 0);\n\t\tkfree(ym);\n\t\tbreak;\n\n\tcase SIOCYAMSCFG:\n\t\tif (!capable(CAP_SYS_RAWIO))\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&yi, data, sizeof(struct yamdrv_ioctl_cfg)))\n\t\t\treturn -EFAULT;\n\n\t\tif (yi.cmd != SIOCYAMSCFG)\n\t\t\treturn -EINVAL;\n\t\tif ((yi.cfg.mask & YAM_IOBASE) && netif_running(dev))\n\t\t\treturn -EINVAL;\t\t \n\t\tif ((yi.cfg.mask & YAM_IRQ) && netif_running(dev))\n\t\t\treturn -EINVAL;\t\t \n\t\tif ((yi.cfg.mask & YAM_BITRATE) && netif_running(dev))\n\t\t\treturn -EINVAL;\t\t \n\t\tif ((yi.cfg.mask & YAM_BAUDRATE) && netif_running(dev))\n\t\t\treturn -EINVAL;\t\t \n\n\t\tif (yi.cfg.mask & YAM_IOBASE) {\n\t\t\typ->iobase = yi.cfg.iobase;\n\t\t\tdev->base_addr = yi.cfg.iobase;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_IRQ) {\n\t\t\tif (yi.cfg.irq > 15)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->irq = yi.cfg.irq;\n\t\t\tdev->irq = yi.cfg.irq;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_BITRATE) {\n\t\t\tif (yi.cfg.bitrate > YAM_MAXBITRATE)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->bitrate = yi.cfg.bitrate;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_BAUDRATE) {\n\t\t\tif (yi.cfg.baudrate > YAM_MAXBAUDRATE)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->baudrate = yi.cfg.baudrate;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_MODE) {\n\t\t\tif (yi.cfg.mode > YAM_MAXMODE)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->dupmode = yi.cfg.mode;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_HOLDDLY) {\n\t\t\tif (yi.cfg.holddly > YAM_MAXHOLDDLY)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->holdd = yi.cfg.holddly;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_TXDELAY) {\n\t\t\tif (yi.cfg.txdelay > YAM_MAXTXDELAY)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->txd = yi.cfg.txdelay;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_TXTAIL) {\n\t\t\tif (yi.cfg.txtail > YAM_MAXTXTAIL)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->txtail = yi.cfg.txtail;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_PERSIST) {\n\t\t\tif (yi.cfg.persist > YAM_MAXPERSIST)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->pers = yi.cfg.persist;\n\t\t}\n\t\tif (yi.cfg.mask & YAM_SLOTTIME) {\n\t\t\tif (yi.cfg.slottime > YAM_MAXSLOTTIME)\n\t\t\t\treturn -EINVAL;\n\t\t\typ->slot = yi.cfg.slottime;\n\t\t\typ->slotcnt = yp->slot / 10;\n\t\t}\n\t\tbreak;\n\n\tcase SIOCYAMGCFG:\n\t\tmemset(&yi, 0, sizeof(yi));\n\t\tyi.cfg.mask = 0xffffffff;\n\t\tyi.cfg.iobase = yp->iobase;\n\t\tyi.cfg.irq = yp->irq;\n\t\tyi.cfg.bitrate = yp->bitrate;\n\t\tyi.cfg.baudrate = yp->baudrate;\n\t\tyi.cfg.mode = yp->dupmode;\n\t\tyi.cfg.txdelay = yp->txd;\n\t\tyi.cfg.holddly = yp->holdd;\n\t\tyi.cfg.txtail = yp->txtail;\n\t\tyi.cfg.persist = yp->pers;\n\t\tyi.cfg.slottime = yp->slot;\n\t\tif (copy_to_user(data, &yi, sizeof(struct yamdrv_ioctl_cfg)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int yam_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct sockaddr *sa = (struct sockaddr *) addr;\n\n\t \n\tdev_addr_set(dev, sa->sa_data);\n\treturn 0;\n}\n\n \n\nstatic const struct net_device_ops yam_netdev_ops = {\n\t.ndo_open\t     = yam_open,\n\t.ndo_stop\t     = yam_close,\n\t.ndo_start_xmit      = yam_send_packet,\n\t.ndo_siocdevprivate  = yam_siocdevprivate,\n\t.ndo_set_mac_address = yam_set_mac_address,\n};\n\nstatic void yam_setup(struct net_device *dev)\n{\n\tstruct yam_port *yp = netdev_priv(dev);\n\n\typ->magic = YAM_MAGIC;\n\typ->bitrate = DEFAULT_BITRATE;\n\typ->baudrate = DEFAULT_BITRATE * 2;\n\typ->iobase = 0;\n\typ->irq = 0;\n\typ->dupmode = 0;\n\typ->holdd = DEFAULT_HOLDD;\n\typ->txd = DEFAULT_TXD;\n\typ->txtail = DEFAULT_TXTAIL;\n\typ->slot = DEFAULT_SLOT;\n\typ->pers = DEFAULT_PERS;\n\typ->dev = dev;\n\n\tdev->base_addr = yp->iobase;\n\tdev->irq = yp->irq;\n\n\tskb_queue_head_init(&yp->send_queue);\n\n\tdev->netdev_ops = &yam_netdev_ops;\n\tdev->header_ops = &ax25_header_ops;\n\n\tdev->type = ARPHRD_AX25;\n\tdev->hard_header_len = AX25_MAX_HEADER_LEN;\n\tdev->mtu = AX25_MTU;\n\tdev->addr_len = AX25_ADDR_LEN;\n\tmemcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);\n\tdev_addr_set(dev, (u8 *)&ax25_defaddr);\n}\n\nstatic int __init yam_init_driver(void)\n{\n\tstruct net_device *dev;\n\tint i, err;\n\tchar name[IFNAMSIZ];\n\n\tprintk(yam_drvinfo);\n\n\tfor (i = 0; i < NR_PORTS; i++) {\n\t\tsprintf(name, \"yam%d\", i);\n\t\t\n\t\tdev = alloc_netdev(sizeof(struct yam_port), name,\n\t\t\t\t   NET_NAME_UNKNOWN, yam_setup);\n\t\tif (!dev) {\n\t\t\tpr_err(\"yam: cannot allocate net device\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\t\n\t\terr = register_netdev(dev);\n\t\tif (err) {\n\t\t\tprintk(KERN_WARNING \"yam: cannot register net device %s\\n\", dev->name);\n\t\t\tfree_netdev(dev);\n\t\t\tgoto error;\n\t\t}\n\t\tyam_devs[i] = dev;\n\n\t}\n\n\ttimer_setup(&yam_timer, yam_dotimer, 0);\n\tyam_timer.expires = jiffies + HZ / 100;\n\tadd_timer(&yam_timer);\n\n\tproc_create_seq(\"yam\", 0444, init_net.proc_net, &yam_seqops);\n\treturn 0;\n error:\n\twhile (--i >= 0) {\n\t\tunregister_netdev(yam_devs[i]);\n\t\tfree_netdev(yam_devs[i]);\n\t}\n\treturn err;\n}\n\n \n\nstatic void __exit yam_cleanup_driver(void)\n{\n\tstruct yam_mcs *p;\n\tint i;\n\n\tdel_timer_sync(&yam_timer);\n\tfor (i = 0; i < NR_PORTS; i++) {\n\t\tstruct net_device *dev = yam_devs[i];\n\t\tif (dev) {\n\t\t\tunregister_netdev(dev);\n\t\t\tfree_netdev(dev);\n\t\t}\n\t}\n\n\twhile (yam_data) {\n\t\tp = yam_data;\n\t\tyam_data = yam_data->next;\n\t\tkfree(p);\n\t}\n\n\tremove_proc_entry(\"yam\", init_net.proc_net);\n}\n\n \n\nMODULE_AUTHOR(\"Frederic Rible F1OAT frible@teaser.fr\");\nMODULE_DESCRIPTION(\"Yam amateur radio modem driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(FIRMWARE_1200);\nMODULE_FIRMWARE(FIRMWARE_9600);\n\nmodule_init(yam_init_driver);\nmodule_exit(yam_cleanup_driver);\n\n \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}