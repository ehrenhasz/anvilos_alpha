{
  "module_name": "baycom_par.c",
  "hash_id": "3fe02852dd33c9638a9a86f9ccd0bfe17ed87292df7d6e4d22db56c6da8d64e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/hamradio/baycom_par.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/hdlcdrv.h>\n#include <linux/baycom.h>\n#include <linux/parport.h>\n#include <linux/bitops.h>\n#include <linux/jiffies.h>\n\n#include <linux/uaccess.h>\n\n \n\n#define BAYCOM_DEBUG\n\n \n#define BAYCOM_OPTIONS_SOFTDCD  1\n\n \n\nstatic const char bc_drvname[] = \"baycom_par\";\nstatic const char bc_drvinfo[] = KERN_INFO \"baycom_par: (C) 1996-2000 Thomas Sailer, HB9JNX/AE4WA\\n\"\n\"baycom_par: version 0.9\\n\";\n\n \n\n#define NR_PORTS 4\n\nstatic struct net_device *baycom_device[NR_PORTS];\n\n \n\n#define PAR96_BURSTBITS 16\n#define PAR96_BURST     4\n#define PAR96_PTT       2\n#define PAR96_TXBIT     1\n#define PAR96_ACK       0x40\n#define PAR96_RXBIT     0x20\n#define PAR96_DCD       0x10\n#define PAR97_POWER     0xf8\n\n \n \n\nstruct baycom_state {\n\tstruct hdlcdrv_state hdrv;\n\n\tstruct pardevice *pdev;\n\tunsigned int options;\n\n\tstruct modem_state {\n\t\tshort arb_divider;\n\t\tunsigned char flags;\n\t\tunsigned int shreg;\n\t\tstruct modem_state_par96 {\n\t\t\tint dcd_count;\n\t\t\tunsigned int dcd_shreg;\n\t\t\tunsigned long descram;\n\t\t\tunsigned long scram;\n\t\t} par96;\n\t} modem;\n\n#ifdef BAYCOM_DEBUG\n\tstruct debug_vals {\n\t\tunsigned long last_jiffies;\n\t\tunsigned cur_intcnt;\n\t\tunsigned last_intcnt;\n\t\tint cur_pllcorr;\n\t\tint last_pllcorr;\n\t} debug_vals;\n#endif  \n};\n\n \n\nstatic inline void baycom_int_freq(struct baycom_state *bc)\n{\n#ifdef BAYCOM_DEBUG\n\tunsigned long cur_jiffies = jiffies;\n\t \n\tbc->debug_vals.cur_intcnt++;\n\tif (time_after_eq(cur_jiffies, bc->debug_vals.last_jiffies + HZ)) {\n\t\tbc->debug_vals.last_jiffies = cur_jiffies;\n\t\tbc->debug_vals.last_intcnt = bc->debug_vals.cur_intcnt;\n\t\tbc->debug_vals.cur_intcnt = 0;\n\t\tbc->debug_vals.last_pllcorr = bc->debug_vals.cur_pllcorr;\n\t\tbc->debug_vals.cur_pllcorr = 0;\n\t}\n#endif  \n}\n\n \n \n\n#define PAR96_DESCRAM_TAP1 0x20000\n#define PAR96_DESCRAM_TAP2 0x01000\n#define PAR96_DESCRAM_TAP3 0x00001\n\n#define PAR96_DESCRAM_TAPSH1 17\n#define PAR96_DESCRAM_TAPSH2 12\n#define PAR96_DESCRAM_TAPSH3 0\n\n#define PAR96_SCRAM_TAP1 0x20000  \n#define PAR96_SCRAM_TAPN 0x00021  \n\n \n\nstatic inline void par96_tx(struct net_device *dev, struct baycom_state *bc)\n{\n\tint i;\n\tunsigned int data = hdlcdrv_getbits(&bc->hdrv);\n\tstruct parport *pp = bc->pdev->port;\n\n\tfor(i = 0; i < PAR96_BURSTBITS; i++, data >>= 1) {\n\t\tunsigned char val = PAR97_POWER;\n\t\tbc->modem.par96.scram = ((bc->modem.par96.scram << 1) |\n\t\t\t\t\t (bc->modem.par96.scram & 1));\n\t\tif (!(data & 1))\n\t\t\tbc->modem.par96.scram ^= 1;\n\t\tif (bc->modem.par96.scram & (PAR96_SCRAM_TAP1 << 1))\n\t\t\tbc->modem.par96.scram ^=\n\t\t\t\t(PAR96_SCRAM_TAPN << 1);\n\t\tif (bc->modem.par96.scram & (PAR96_SCRAM_TAP1 << 2))\n\t\t\tval |= PAR96_TXBIT;\n\t\tpp->ops->write_data(pp, val);\n\t\tpp->ops->write_data(pp, val | PAR96_BURST);\n\t}\n}\n\n \n\nstatic inline void par96_rx(struct net_device *dev, struct baycom_state *bc)\n{\n\tint i;\n\tunsigned int data, mask, mask2, descx;\n\tstruct parport *pp = bc->pdev->port;\n\n\t \n\tfor(data = i = 0; i < PAR96_BURSTBITS; i++) {\n\t\tbc->modem.par96.descram = (bc->modem.par96.descram << 1);\n\t\tif (pp->ops->read_status(pp) & PAR96_RXBIT)\n\t\t\tbc->modem.par96.descram |= 1;\n\t\tdescx = bc->modem.par96.descram ^\n\t\t\t(bc->modem.par96.descram >> 1);\n\t\t \n\t\tpp->ops->write_data(pp, PAR97_POWER | PAR96_PTT);\n\t\tdescx ^= ((descx >> PAR96_DESCRAM_TAPSH1) ^\n\t\t\t  (descx >> PAR96_DESCRAM_TAPSH2));\n\t\tdata >>= 1;\n\t\tif (!(descx & 1))\n\t\t\tdata |= 0x8000;\n\t\tpp->ops->write_data(pp, PAR97_POWER | PAR96_PTT | PAR96_BURST);\n\t}\n\thdlcdrv_putbits(&bc->hdrv, data);\n\t \n\tif (bc->options & BAYCOM_OPTIONS_SOFTDCD) {\n\t\tbc->modem.par96.dcd_shreg = (bc->modem.par96.dcd_shreg >> 16)\n\t\t\t| (data << 16);\n\t\t \n\t\tfor(mask = 0x1fe00, mask2 = 0xfc00, i = 0;\n\t\t    i < PAR96_BURSTBITS; i++, mask <<= 1, mask2 <<= 1)\n\t\t\tif ((bc->modem.par96.dcd_shreg & mask) == mask2)\n\t\t\t\tbc->modem.par96.dcd_count = HDLCDRV_MAXFLEN+4;\n\t\t \n\t\tfor(mask = 0x1fe00, mask2 = 0x1fe00, i = 0;\n\t\t    i < PAR96_BURSTBITS; i++, mask <<= 1, mask2 <<= 1)\n\t\t\tif (((bc->modem.par96.dcd_shreg & mask) == mask2) &&\n\t\t\t    (bc->modem.par96.dcd_count >= 0))\n\t\t\t\tbc->modem.par96.dcd_count -= HDLCDRV_MAXFLEN-10;\n\t\t \n\t\tif (bc->modem.par96.dcd_count >= 0)\n\t\t\tbc->modem.par96.dcd_count -= 2;\n\t\thdlcdrv_setdcd(&bc->hdrv, bc->modem.par96.dcd_count > 0);\n\t} else {\n\t\thdlcdrv_setdcd(&bc->hdrv, !!(pp->ops->read_status(pp) & PAR96_DCD));\n\t}\n}\n\n \n\nstatic void par96_interrupt(void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tstruct baycom_state *bc = netdev_priv(dev);\n\n\tbaycom_int_freq(bc);\n\t \n\tif (hdlcdrv_ptt(&bc->hdrv))\n\t\tpar96_tx(dev, bc);\n\telse {\n\t\tpar96_rx(dev, bc);\n\t\tif (--bc->modem.arb_divider <= 0) {\n\t\t\tbc->modem.arb_divider = 6;\n\t\t\tlocal_irq_enable();\n\t\t\thdlcdrv_arbitrate(dev, &bc->hdrv);\n\t\t}\n\t}\n\tlocal_irq_enable();\n\thdlcdrv_transmitter(dev, &bc->hdrv);\n\thdlcdrv_receiver(dev, &bc->hdrv);\n        local_irq_disable();\n}\n\n \n\nstatic void par96_wakeup(void *handle)\n{\n        struct net_device *dev = (struct net_device *)handle;\n\tstruct baycom_state *bc = netdev_priv(dev);\n\n\tprintk(KERN_DEBUG \"baycom_par: %s: why am I being woken up?\\n\", dev->name);\n\tif (!parport_claim(bc->pdev))\n\t\tprintk(KERN_DEBUG \"baycom_par: %s: I'm broken.\\n\", dev->name);\n}\n\n \n\nstatic int par96_open(struct net_device *dev)\n{\n\tstruct baycom_state *bc = netdev_priv(dev);\n\tstruct pardev_cb par_cb;\n\tstruct parport *pp;\n\tint i;\n\n\tif (!dev || !bc)\n\t\treturn -ENXIO;\n\tpp = parport_find_base(dev->base_addr);\n\tif (!pp) {\n\t\tprintk(KERN_ERR \"baycom_par: parport at 0x%lx unknown\\n\", dev->base_addr);\n\t\treturn -ENXIO;\n\t}\n\tif (pp->irq < 0) {\n\t\tprintk(KERN_ERR \"baycom_par: parport at 0x%lx has no irq\\n\", pp->base);\n\t\tparport_put_port(pp);\n\t\treturn -ENXIO;\n\t}\n\tif ((~pp->modes) & (PARPORT_MODE_PCSPP | PARPORT_MODE_SAFEININT)) {\n\t\tprintk(KERN_ERR \"baycom_par: parport at 0x%lx cannot be used\\n\", pp->base);\n\t\tparport_put_port(pp);\n\t\treturn -ENXIO;\n\t}\n\tmemset(&bc->modem, 0, sizeof(bc->modem));\n\tbc->hdrv.par.bitrate = 9600;\n\tmemset(&par_cb, 0, sizeof(par_cb));\n\tpar_cb.wakeup = par96_wakeup;\n\tpar_cb.irq_func = par96_interrupt;\n\tpar_cb.private = (void *)dev;\n\tpar_cb.flags = PARPORT_DEV_EXCL;\n\tfor (i = 0; i < NR_PORTS; i++)\n\t\tif (baycom_device[i] == dev)\n\t\t\tbreak;\n\n\tif (i == NR_PORTS) {\n\t\tpr_err(\"%s: no device found\\n\", bc_drvname);\n\t\tparport_put_port(pp);\n\t\treturn -ENODEV;\n\t}\n\tbc->pdev = parport_register_dev_model(pp, dev->name, &par_cb, i);\n\tparport_put_port(pp);\n\tif (!bc->pdev) {\n\t\tprintk(KERN_ERR \"baycom_par: cannot register parport at 0x%lx\\n\", dev->base_addr);\n\t\treturn -ENXIO;\n\t}\n\tif (parport_claim(bc->pdev)) {\n\t\tprintk(KERN_ERR \"baycom_par: parport at 0x%lx busy\\n\", pp->base);\n\t\tparport_unregister_device(bc->pdev);\n\t\treturn -EBUSY;\n\t}\n\tpp = bc->pdev->port;\n\tdev->irq = pp->irq;\n\tpp->ops->data_forward(pp);\n        bc->hdrv.par.bitrate = 9600;\n\tpp->ops->write_data(pp, PAR96_PTT | PAR97_POWER);  \n\tpp->ops->enable_irq(pp);\n\tprintk(KERN_INFO \"%s: par96 at iobase 0x%lx irq %u options 0x%x\\n\",\n\t       bc_drvname, dev->base_addr, dev->irq, bc->options);\n\treturn 0;\n}\n\n \n\nstatic int par96_close(struct net_device *dev)\n{\n\tstruct baycom_state *bc = netdev_priv(dev);\n\tstruct parport *pp;\n\n\tif (!dev || !bc)\n\t\treturn -EINVAL;\n\tpp = bc->pdev->port;\n\t \n\tpp->ops->disable_irq(pp);\n\t \n\tpp->ops->write_data(pp, PAR96_PTT | PAR97_POWER);\n\tparport_release(bc->pdev);\n\tparport_unregister_device(bc->pdev);\n\tprintk(KERN_INFO \"%s: close par96 at iobase 0x%lx irq %u\\n\",\n\t       bc_drvname, dev->base_addr, dev->irq);\n\treturn 0;\n}\n\n \n \n\nstatic int baycom_ioctl(struct net_device *dev, void __user *data,\n\t\t\tstruct hdlcdrv_ioctl *hi, int cmd);\n\n \n\nstatic const struct hdlcdrv_ops par96_ops = {\n\t.drvname = bc_drvname,\n\t.drvinfo = bc_drvinfo,\n\t.open    = par96_open,\n\t.close   = par96_close,\n\t.ioctl   = baycom_ioctl\n};\n\n \n\nstatic int baycom_setmode(struct baycom_state *bc, const char *modestr)\n{\n\tif (!strncmp(modestr, \"picpar\", 6))\n\t\tbc->options = 0;\n\telse if (!strncmp(modestr, \"par96\", 5))\n\t\tbc->options = BAYCOM_OPTIONS_SOFTDCD;\n\telse\n\t\tbc->options = !!strchr(modestr, '*');\n\treturn 0;\n}\n\n \n\nstatic int baycom_ioctl(struct net_device *dev, void __user *data,\n\t\t\tstruct hdlcdrv_ioctl *hi, int cmd)\n{\n\tstruct baycom_state *bc;\n\tstruct baycom_ioctl bi;\n\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\tbc = netdev_priv(dev);\n\tBUG_ON(bc->hdrv.magic != HDLCDRV_MAGIC);\n\n\tif (cmd != SIOCDEVPRIVATE)\n\t\treturn -ENOIOCTLCMD;\n\tswitch (hi->cmd) {\n\tdefault:\n\t\tbreak;\n\n\tcase HDLCDRVCTL_GETMODE:\n\t\tstrcpy(hi->data.modename, bc->options ? \"par96\" : \"picpar\");\n\t\tif (copy_to_user(data, hi, sizeof(struct hdlcdrv_ioctl)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase HDLCDRVCTL_SETMODE:\n\t\tif (netif_running(dev) || !capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\t\thi->data.modename[sizeof(hi->data.modename)-1] = '\\0';\n\t\treturn baycom_setmode(bc, hi->data.modename);\n\n\tcase HDLCDRVCTL_MODELIST:\n\t\tstrcpy(hi->data.modename, \"par96,picpar\");\n\t\tif (copy_to_user(data, hi, sizeof(struct hdlcdrv_ioctl)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase HDLCDRVCTL_MODEMPARMASK:\n\t\treturn HDLCDRV_PARMASK_IOBASE;\n\n\t}\n\n\tif (copy_from_user(&bi, data, sizeof(bi)))\n\t\treturn -EFAULT;\n\tswitch (bi.cmd) {\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\n#ifdef BAYCOM_DEBUG\n\tcase BAYCOMCTL_GETDEBUG:\n\t\tbi.data.dbg.debug1 = bc->hdrv.ptt_keyed;\n\t\tbi.data.dbg.debug2 = bc->debug_vals.last_intcnt;\n\t\tbi.data.dbg.debug3 = bc->debug_vals.last_pllcorr;\n\t\tbreak;\n#endif  \n\n\t}\n\tif (copy_to_user(data, &bi, sizeof(bi)))\n\t\treturn -EFAULT;\n\treturn 0;\n\n}\n\n \n\n \nstatic char *mode[NR_PORTS] = { \"picpar\", };\nstatic int iobase[NR_PORTS] = { 0x378, };\n\nmodule_param_array(mode, charp, NULL, 0);\nMODULE_PARM_DESC(mode, \"baycom operating mode; eg. par96 or picpar\");\nmodule_param_hw_array(iobase, int, ioport, NULL, 0);\nMODULE_PARM_DESC(iobase, \"baycom io base address\");\n\nMODULE_AUTHOR(\"Thomas M. Sailer, sailer@ife.ee.ethz.ch, hb9jnx@hb9w.che.eu\");\nMODULE_DESCRIPTION(\"Baycom par96 and picpar amateur radio modem driver\");\nMODULE_LICENSE(\"GPL\");\n\n \n\nstatic int baycom_par_probe(struct pardevice *par_dev)\n{\n\tstruct device_driver *drv = par_dev->dev.driver;\n\tint len = strlen(drv->name);\n\n\tif (strncmp(par_dev->name, drv->name, len))\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic struct parport_driver baycom_par_driver = {\n\t.name = \"bcp\",\n\t.probe = baycom_par_probe,\n\t.devmodel = true,\n};\n\nstatic int __init init_baycompar(void)\n{\n\tint i, found = 0, ret;\n\tchar set_hw = 1;\n\n\tprintk(bc_drvinfo);\n\n\tret = parport_register_driver(&baycom_par_driver);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0; i < NR_PORTS; i++) {\n\t\tstruct net_device *dev;\n\t\tstruct baycom_state *bc;\n\t\tchar ifname[IFNAMSIZ];\n\n\t\tsprintf(ifname, \"bcp%d\", i);\n\n\t\tif (!mode[i])\n\t\t\tset_hw = 0;\n\t\tif (!set_hw)\n\t\t\tiobase[i] = 0;\n\n\t\tdev = hdlcdrv_register(&par96_ops,\n\t\t\t\t       sizeof(struct baycom_state),\n\t\t\t\t       ifname, iobase[i], 0, 0);\n\t\tif (IS_ERR(dev)) \n\t\t\tbreak;\n\n\t\tbc = netdev_priv(dev);\n\t\tif (set_hw && baycom_setmode(bc, mode[i]))\n\t\t\tset_hw = 0;\n\t\tfound++;\n\t\tbaycom_device[i] = dev;\n\t}\n\n\tif (!found) {\n\t\tparport_unregister_driver(&baycom_par_driver);\n\t\treturn -ENXIO;\n\t}\n\treturn 0;\n}\n\nstatic void __exit cleanup_baycompar(void)\n{\n\tint i;\n\n\tfor(i = 0; i < NR_PORTS; i++) {\n\t\tstruct net_device *dev = baycom_device[i];\n\n\t\tif (dev)\n\t\t\thdlcdrv_unregister(dev);\n\t}\n\tparport_unregister_driver(&baycom_par_driver);\n}\n\nmodule_init(init_baycompar);\nmodule_exit(cleanup_baycompar);\n\n \n\n#ifndef MODULE\n\n \n\nstatic int __init baycom_par_setup(char *str)\n{\n        static unsigned nr_dev;\n\tint ints[2];\n\n        if (nr_dev >= NR_PORTS)\n                return 0;\n        str = get_options(str, 2, ints);\n        if (ints[0] < 1)\n                return 0;\n        mode[nr_dev] = str;\n        iobase[nr_dev] = ints[1];\n\tnr_dev++;\n\treturn 1;\n}\n\n__setup(\"baycom_par=\", baycom_par_setup);\n\n#endif  \n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}