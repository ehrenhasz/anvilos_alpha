{
  "module_name": "hdlcdrv.c",
  "hash_id": "170cd6b1da422bbed1da2996ee452346463a6fb8bec95e28c49dbd09c18ecbbe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/hamradio/hdlcdrv.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/capability.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/net.h>\n#include <linux/in.h>\n#include <linux/if.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <linux/hdlcdrv.h>\n#include <linux/random.h>\n#include <net/ax25.h> \n#include <linux/uaccess.h>\n\n#include <linux/crc-ccitt.h>\n\n \n\n#define KISS_VERBOSE\n\n \n\n#define PARAM_TXDELAY   1\n#define PARAM_PERSIST   2\n#define PARAM_SLOTTIME  3\n#define PARAM_TXTAIL    4\n#define PARAM_FULLDUP   5\n#define PARAM_HARDWARE  6\n#define PARAM_RETURN    255\n\n \n \n\n\n \n\nstatic inline void append_crc_ccitt(unsigned char *buffer, int len)\n{\n\tunsigned int crc = crc_ccitt(0xffff, buffer, len) ^ 0xffff;\n\tbuffer += len;\n\t*buffer++ = crc;\n\t*buffer++ = crc >> 8;\n}\n\n \n\nstatic inline int check_crc_ccitt(const unsigned char *buf, int cnt)\n{\n\treturn (crc_ccitt(0xffff, buf, cnt) & 0xffff) == 0xf0b8;\n}\n\n \n\n#if 0\nstatic int calc_crc_ccitt(const unsigned char *buf, int cnt)\n{\n\tunsigned int crc = 0xffff;\n\n\tfor (; cnt > 0; cnt--)\n\t\tcrc = (crc >> 8) ^ crc_ccitt_table[(crc ^ *buf++) & 0xff];\n\tcrc ^= 0xffff;\n\treturn crc & 0xffff;\n}\n#endif\n\n \n\n#define tenms_to_2flags(s,tenms) ((tenms * s->par.bitrate) / 100 / 16)\n\n \n \n\nstatic int hdlc_rx_add_bytes(struct hdlcdrv_state *s, unsigned int bits, \n\t\t\t     int num)\n{\n\tint added = 0;\n\t\n\twhile (s->hdlcrx.rx_state && num >= 8) {\n\t\tif (s->hdlcrx.len >= sizeof(s->hdlcrx.buffer)) {\n\t\t\ts->hdlcrx.rx_state = 0;\n\t\t\treturn 0;\n\t\t}\n\t\t*s->hdlcrx.bp++ = bits >> (32-num);\n\t\ts->hdlcrx.len++;\n\t\tnum -= 8;\n\t\tadded += 8;\n\t}\n\treturn added;\n}\n\nstatic void hdlc_rx_flag(struct net_device *dev, struct hdlcdrv_state *s)\n{\n\tstruct sk_buff *skb;\n\tint pkt_len;\n\tunsigned char *cp;\n\n\tif (s->hdlcrx.len < 4) \n\t\treturn;\n\tif (!check_crc_ccitt(s->hdlcrx.buffer, s->hdlcrx.len)) \n\t\treturn;\n\tpkt_len = s->hdlcrx.len - 2 + 1;  \n\tif (!(skb = dev_alloc_skb(pkt_len))) {\n\t\tprintk(\"%s: memory squeeze, dropping packet\\n\", dev->name);\n\t\tdev->stats.rx_dropped++;\n\t\treturn;\n\t}\n\tcp = skb_put(skb, pkt_len);\n\t*cp++ = 0;  \n\tmemcpy(cp, s->hdlcrx.buffer, pkt_len - 1);\n\tskb->protocol = ax25_type_trans(skb, dev);\n\tnetif_rx(skb);\n\tdev->stats.rx_packets++;\n}\n\nvoid hdlcdrv_receiver(struct net_device *dev, struct hdlcdrv_state *s)\n{\n\tint i;\n\tunsigned int mask1, mask2, mask3, mask4, mask5, mask6, word;\n\t\n\tif (!s || s->magic != HDLCDRV_MAGIC) \n\t\treturn;\n\tif (test_and_set_bit(0, &s->hdlcrx.in_hdlc_rx))\n\t\treturn;\n\n\twhile (!hdlcdrv_hbuf_empty(&s->hdlcrx.hbuf)) {\n\t\tword = hdlcdrv_hbuf_get(&s->hdlcrx.hbuf);\t\n\n#ifdef HDLCDRV_DEBUG\n\t\thdlcdrv_add_bitbuffer_word(&s->bitbuf_hdlc, word);\n#endif  \n\t       \ts->hdlcrx.bitstream >>= 16;\n\t\ts->hdlcrx.bitstream |= word << 16;\n\t\ts->hdlcrx.bitbuf >>= 16;\n\t\ts->hdlcrx.bitbuf |= word << 16;\n\t\ts->hdlcrx.numbits += 16;\n\t\tfor(i = 15, mask1 = 0x1fc00, mask2 = 0x1fe00, mask3 = 0x0fc00,\n\t\t    mask4 = 0x1f800, mask5 = 0xf800, mask6 = 0xffff; \n\t\t    i >= 0; \n\t\t    i--, mask1 <<= 1, mask2 <<= 1, mask3 <<= 1, mask4 <<= 1, \n\t\t    mask5 <<= 1, mask6 = (mask6 << 1) | 1) {\n\t\t\tif ((s->hdlcrx.bitstream & mask1) == mask1)\n\t\t\t\ts->hdlcrx.rx_state = 0;  \n\t\t\telse if ((s->hdlcrx.bitstream & mask2) == mask3) {\n\t\t\t\t \n\t\t\t\tif (s->hdlcrx.rx_state) {\n\t\t\t\t\thdlc_rx_add_bytes(s, s->hdlcrx.bitbuf \n\t\t\t\t\t\t\t  << (8+i),\n\t\t\t\t\t\t\t  s->hdlcrx.numbits\n\t\t\t\t\t\t\t  -8-i);\n\t\t\t\t\thdlc_rx_flag(dev, s);\n\t\t\t\t}\n\t\t\t\ts->hdlcrx.len = 0;\n\t\t\t\ts->hdlcrx.bp = s->hdlcrx.buffer;\n\t\t\t\ts->hdlcrx.rx_state = 1;\n\t\t\t\ts->hdlcrx.numbits = i;\n\t\t\t} else if ((s->hdlcrx.bitstream & mask4) == mask5) {\n\t\t\t\t \n\t\t\t\ts->hdlcrx.numbits--;\n\t\t\t\ts->hdlcrx.bitbuf = (s->hdlcrx.bitbuf & (~mask6)) |\n\t\t\t\t\t((s->hdlcrx.bitbuf & mask6) << 1);\n\t\t\t}\n\t\t}\n\t\ts->hdlcrx.numbits -= hdlc_rx_add_bytes(s, s->hdlcrx.bitbuf,\n\t\t\t\t\t\t       s->hdlcrx.numbits);\n\t}\n\tclear_bit(0, &s->hdlcrx.in_hdlc_rx);\n}\n\n \n\nstatic inline void do_kiss_params(struct hdlcdrv_state *s,\n\t\t\t\t  unsigned char *data, unsigned long len)\n{\n\n#ifdef KISS_VERBOSE\n#define PKP(a,b) printk(KERN_INFO \"hdlcdrv.c: channel params: \" a \"\\n\", b)\n#else  \t      \n#define PKP(a,b) \n#endif  \t      \n\n\tif (len < 2)\n\t\treturn;\n\tswitch(data[0]) {\n\tcase PARAM_TXDELAY:\n\t\ts->ch_params.tx_delay = data[1];\n\t\tPKP(\"TX delay = %ums\", 10 * s->ch_params.tx_delay);\n\t\tbreak;\n\tcase PARAM_PERSIST:   \n\t\ts->ch_params.ppersist = data[1];\n\t\tPKP(\"p persistence = %u\", s->ch_params.ppersist);\n\t\tbreak;\n\tcase PARAM_SLOTTIME:  \n\t\ts->ch_params.slottime = data[1];\n\t\tPKP(\"slot time = %ums\", s->ch_params.slottime);\n\t\tbreak;\n\tcase PARAM_TXTAIL:    \n\t\ts->ch_params.tx_tail = data[1];\n\t\tPKP(\"TX tail = %ums\", s->ch_params.tx_tail);\n\t\tbreak;\n\tcase PARAM_FULLDUP:   \n\t\ts->ch_params.fulldup = !!data[1];\n\t\tPKP(\"%s duplex\", s->ch_params.fulldup ? \"full\" : \"half\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n#undef PKP\n}\n\n \n\nvoid hdlcdrv_transmitter(struct net_device *dev, struct hdlcdrv_state *s)\n{\n\tunsigned int mask1, mask2, mask3;\n\tint i;\n\tstruct sk_buff *skb;\n\tint pkt_len;\n\n\tif (!s || s->magic != HDLCDRV_MAGIC) \n\t\treturn;\n\tif (test_and_set_bit(0, &s->hdlctx.in_hdlc_tx))\n\t\treturn;\n\tfor (;;) {\n\t\tif (s->hdlctx.numbits >= 16) {\n\t\t\tif (hdlcdrv_hbuf_full(&s->hdlctx.hbuf)) {\n\t\t\t\tclear_bit(0, &s->hdlctx.in_hdlc_tx);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\thdlcdrv_hbuf_put(&s->hdlctx.hbuf, s->hdlctx.bitbuf);\n\t\t\ts->hdlctx.bitbuf >>= 16;\n\t\t\ts->hdlctx.numbits -= 16;\n\t\t}\n\t\tswitch (s->hdlctx.tx_state) {\n\t\tdefault:\n\t\t\tclear_bit(0, &s->hdlctx.in_hdlc_tx);\n\t\t\treturn;\n\t\tcase 0:\n\t\tcase 1:\n\t\t\tif (s->hdlctx.numflags) {\n\t\t\t\ts->hdlctx.numflags--;\n\t\t\t\ts->hdlctx.bitbuf |= \n\t\t\t\t\t0x7e7e << s->hdlctx.numbits;\n\t\t\t\ts->hdlctx.numbits += 16;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (s->hdlctx.tx_state == 1) {\n\t\t\t\tclear_bit(0, &s->hdlctx.in_hdlc_tx);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!(skb = s->skb)) {\n\t\t\t\tint flgs = tenms_to_2flags(s, s->ch_params.tx_tail);\n\t\t\t\tif (flgs < 2)\n\t\t\t\t\tflgs = 2;\n\t\t\t\ts->hdlctx.tx_state = 1;\n\t\t\t\ts->hdlctx.numflags = flgs;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts->skb = NULL;\n\t\t\tnetif_wake_queue(dev);\n\t\t\tpkt_len = skb->len-1;  \n\t\t\tif (pkt_len >= HDLCDRV_MAXFLEN || pkt_len < 2) {\n\t\t\t\ts->hdlctx.tx_state = 0;\n\t\t\t\ts->hdlctx.numflags = 1;\n\t\t\t\tdev_kfree_skb_irq(skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tskb_copy_from_linear_data_offset(skb, 1,\n\t\t\t\t\t\t\t s->hdlctx.buffer,\n\t\t\t\t\t\t\t pkt_len);\n\t\t\tdev_kfree_skb_irq(skb);\n\t\t\ts->hdlctx.bp = s->hdlctx.buffer;\n\t\t\tappend_crc_ccitt(s->hdlctx.buffer, pkt_len);\n\t\t\ts->hdlctx.len = pkt_len+2;  \n\t\t\ts->hdlctx.tx_state = 2;\n\t\t\ts->hdlctx.bitstream = 0;\n\t\t\tdev->stats.tx_packets++;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (!s->hdlctx.len) {\n\t\t\t\ts->hdlctx.tx_state = 0;\n\t\t\t\ts->hdlctx.numflags = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts->hdlctx.len--;\n\t\t\ts->hdlctx.bitbuf |= *s->hdlctx.bp <<\n\t\t\t\ts->hdlctx.numbits;\n\t\t\ts->hdlctx.bitstream >>= 8;\n\t\t\ts->hdlctx.bitstream |= (*s->hdlctx.bp++) << 16;\n\t\t\tmask1 = 0x1f000;\n\t\t\tmask2 = 0x10000;\n\t\t\tmask3 = 0xffffffff >> (31-s->hdlctx.numbits);\n\t\t\ts->hdlctx.numbits += 8;\n\t\t\tfor(i = 0; i < 8; i++, mask1 <<= 1, mask2 <<= 1, \n\t\t\t    mask3 = (mask3 << 1) | 1) {\n\t\t\t\tif ((s->hdlctx.bitstream & mask1) != mask1) \n\t\t\t\t\tcontinue;\n\t\t\t\ts->hdlctx.bitstream &= ~mask2;\n\t\t\t\ts->hdlctx.bitbuf = \n\t\t\t\t\t(s->hdlctx.bitbuf & mask3) |\n\t\t\t\t\t\t((s->hdlctx.bitbuf & \n\t\t\t\t\t\t (~mask3)) << 1);\n\t\t\t\ts->hdlctx.numbits++;\n\t\t\t\tmask3 = (mask3 << 1) | 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \n\nstatic void start_tx(struct net_device *dev, struct hdlcdrv_state *s)\n{\n\ts->hdlctx.tx_state = 0;\n\ts->hdlctx.numflags = tenms_to_2flags(s, s->ch_params.tx_delay);\n\ts->hdlctx.bitbuf = s->hdlctx.bitstream = s->hdlctx.numbits = 0;\n\thdlcdrv_transmitter(dev, s);\n\ts->hdlctx.ptt = 1;\n\ts->ptt_keyed++;\n}\n\n \n\nvoid hdlcdrv_arbitrate(struct net_device *dev, struct hdlcdrv_state *s)\n{\n\tif (!s || s->magic != HDLCDRV_MAGIC || s->hdlctx.ptt || !s->skb) \n\t\treturn;\n\tif (s->ch_params.fulldup) {\n\t\tstart_tx(dev, s);\n\t\treturn;\n\t}\n\tif (s->hdlcrx.dcd) {\n\t\ts->hdlctx.slotcnt = s->ch_params.slottime;\n\t\treturn;\n\t}\n\tif ((--s->hdlctx.slotcnt) > 0)\n\t\treturn;\n\ts->hdlctx.slotcnt = s->ch_params.slottime;\n\tif (get_random_u8() > s->ch_params.ppersist)\n\t\treturn;\n\tstart_tx(dev, s);\n}\n\n \n \n\nstatic netdev_tx_t hdlcdrv_send_packet(struct sk_buff *skb,\n\t\t\t\t       struct net_device *dev)\n{\n\tstruct hdlcdrv_state *sm = netdev_priv(dev);\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn ax25_ip_xmit(skb);\n\n\tif (skb->data[0] != 0) {\n\t\tdo_kiss_params(sm, skb->data, skb->len);\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\tif (sm->skb) {\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\tnetif_stop_queue(dev);\n\tsm->skb = skb;\n\treturn NETDEV_TX_OK;\n}\n\n \n\nstatic int hdlcdrv_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct sockaddr *sa = (struct sockaddr *)addr;\n\n\t \n\tdev_addr_set(dev, sa->sa_data);\n\treturn 0;                                         \n}\n\n \n \n\nstatic int hdlcdrv_open(struct net_device *dev)\n{\n\tstruct hdlcdrv_state *s = netdev_priv(dev);\n\tint i;\n\n\tif (!s->ops || !s->ops->open)\n\t\treturn -ENODEV;\n\n\t \n\ts->opened = 1;\n\ts->hdlcrx.hbuf.rd = s->hdlcrx.hbuf.wr = 0;\n\ts->hdlcrx.in_hdlc_rx = 0;\n\ts->hdlcrx.rx_state = 0;\n\t\n\ts->hdlctx.hbuf.rd = s->hdlctx.hbuf.wr = 0;\n\ts->hdlctx.in_hdlc_tx = 0;\n\ts->hdlctx.tx_state = 1;\n\ts->hdlctx.numflags = 0;\n\ts->hdlctx.bitstream = s->hdlctx.bitbuf = s->hdlctx.numbits = 0;\n\ts->hdlctx.ptt = 0;\n\ts->hdlctx.slotcnt = s->ch_params.slottime;\n\ts->hdlctx.calibrate = 0;\n\n\ti = s->ops->open(dev);\n\tif (i)\n\t\treturn i;\n\tnetif_start_queue(dev);\n\treturn 0;\n}\n\n \n \n\nstatic int hdlcdrv_close(struct net_device *dev)\n{\n\tstruct hdlcdrv_state *s = netdev_priv(dev);\n\tint i = 0;\n\n\tnetif_stop_queue(dev);\n\n\tif (s->ops && s->ops->close)\n\t\ti = s->ops->close(dev);\n\tdev_kfree_skb(s->skb);\n\ts->skb = NULL;\n\ts->opened = 0;\n\treturn i;\n}\n\n \n\nstatic int hdlcdrv_siocdevprivate(struct net_device *dev, struct ifreq *ifr,\n\t\t\t\t  void __user *data, int cmd)\n{\n\tstruct hdlcdrv_state *s = netdev_priv(dev);\n\tstruct hdlcdrv_ioctl bi;\n\n\tif (cmd != SIOCDEVPRIVATE)\n\t\treturn -ENOIOCTLCMD;\n\n\tif (in_compat_syscall())  \n\t\treturn -ENOIOCTLCMD;\n\n\tif (copy_from_user(&bi, data, sizeof(bi)))\n\t\treturn -EFAULT;\n\n\tswitch (bi.cmd) {\n\tdefault:\n\t\tif (s->ops && s->ops->ioctl)\n\t\t\treturn s->ops->ioctl(dev, data, &bi, cmd);\n\t\treturn -ENOIOCTLCMD;\n\n\tcase HDLCDRVCTL_GETCHANNELPAR:\n\t\tbi.data.cp.tx_delay = s->ch_params.tx_delay;\n\t\tbi.data.cp.tx_tail = s->ch_params.tx_tail;\n\t\tbi.data.cp.slottime = s->ch_params.slottime;\n\t\tbi.data.cp.ppersist = s->ch_params.ppersist;\n\t\tbi.data.cp.fulldup = s->ch_params.fulldup;\n\t\tbreak;\n\n\tcase HDLCDRVCTL_SETCHANNELPAR:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\t\ts->ch_params.tx_delay = bi.data.cp.tx_delay;\n\t\ts->ch_params.tx_tail = bi.data.cp.tx_tail;\n\t\ts->ch_params.slottime = bi.data.cp.slottime;\n\t\ts->ch_params.ppersist = bi.data.cp.ppersist;\n\t\ts->ch_params.fulldup = bi.data.cp.fulldup;\n\t\ts->hdlctx.slotcnt = 1;\n\t\treturn 0;\n\t\t\n\tcase HDLCDRVCTL_GETMODEMPAR:\n\t\tbi.data.mp.iobase = dev->base_addr;\n\t\tbi.data.mp.irq = dev->irq;\n\t\tbi.data.mp.dma = dev->dma;\n\t\tbi.data.mp.dma2 = s->ptt_out.dma2;\n\t\tbi.data.mp.seriobase = s->ptt_out.seriobase;\n\t\tbi.data.mp.pariobase = s->ptt_out.pariobase;\n\t\tbi.data.mp.midiiobase = s->ptt_out.midiiobase;\n\t\tbreak;\n\n\tcase HDLCDRVCTL_SETMODEMPAR:\n\t\tif ((!capable(CAP_SYS_RAWIO)) || netif_running(dev))\n\t\t\treturn -EACCES;\n\t\tdev->base_addr = bi.data.mp.iobase;\n\t\tdev->irq = bi.data.mp.irq;\n\t\tdev->dma = bi.data.mp.dma;\n\t\ts->ptt_out.dma2 = bi.data.mp.dma2;\n\t\ts->ptt_out.seriobase = bi.data.mp.seriobase;\n\t\ts->ptt_out.pariobase = bi.data.mp.pariobase;\n\t\ts->ptt_out.midiiobase = bi.data.mp.midiiobase;\n\t\treturn 0;\t\n\t\n\tcase HDLCDRVCTL_GETSTAT:\n\t\tbi.data.cs.ptt = hdlcdrv_ptt(s);\n\t\tbi.data.cs.dcd = s->hdlcrx.dcd;\n\t\tbi.data.cs.ptt_keyed = s->ptt_keyed;\n\t\tbi.data.cs.tx_packets = dev->stats.tx_packets;\n\t\tbi.data.cs.tx_errors = dev->stats.tx_errors;\n\t\tbi.data.cs.rx_packets = dev->stats.rx_packets;\n\t\tbi.data.cs.rx_errors = dev->stats.rx_errors;\n\t\tbreak;\t\t\n\n\tcase HDLCDRVCTL_OLDGETSTAT:\n\t\tbi.data.ocs.ptt = hdlcdrv_ptt(s);\n\t\tbi.data.ocs.dcd = s->hdlcrx.dcd;\n\t\tbi.data.ocs.ptt_keyed = s->ptt_keyed;\n\t\tbreak;\t\t\n\n\tcase HDLCDRVCTL_CALIBRATE:\n\t\tif(!capable(CAP_SYS_RAWIO))\n\t\t\treturn -EPERM;\n\t\tif (s->par.bitrate <= 0)\n\t\t\treturn -EINVAL;\n\t\tif (bi.data.calibrate > INT_MAX / s->par.bitrate)\n\t\t\treturn -EINVAL;\n\t\ts->hdlctx.calibrate = bi.data.calibrate * s->par.bitrate / 16;\n\t\treturn 0;\n\n\tcase HDLCDRVCTL_GETSAMPLES:\n#ifndef HDLCDRV_DEBUG\n\t\treturn -EPERM;\n#else  \n\t\tif (s->bitbuf_channel.rd == s->bitbuf_channel.wr) \n\t\t\treturn -EAGAIN;\n\t\tbi.data.bits = \n\t\t\ts->bitbuf_channel.buffer[s->bitbuf_channel.rd];\n\t\ts->bitbuf_channel.rd = (s->bitbuf_channel.rd+1) %\n\t\t\tsizeof(s->bitbuf_channel.buffer);\n\t\tbreak;\n#endif  \n\t\t\t\t\n\tcase HDLCDRVCTL_GETBITS:\n#ifndef HDLCDRV_DEBUG\n\t\treturn -EPERM;\n#else  \n\t\tif (s->bitbuf_hdlc.rd == s->bitbuf_hdlc.wr) \n\t\t\treturn -EAGAIN;\n\t\tbi.data.bits = \n\t\t\ts->bitbuf_hdlc.buffer[s->bitbuf_hdlc.rd];\n\t\ts->bitbuf_hdlc.rd = (s->bitbuf_hdlc.rd+1) %\n\t\t\tsizeof(s->bitbuf_hdlc.buffer);\n\t\tbreak;\t\t\n#endif  \n\n\tcase HDLCDRVCTL_DRIVERNAME:\n\t\tif (s->ops && s->ops->drvname) {\n\t\t\tstrscpy(bi.data.drivername, s->ops->drvname,\n\t\t\t\tsizeof(bi.data.drivername));\n\t\t\tbreak;\n\t\t}\n\t\tbi.data.drivername[0] = '\\0';\n\t\tbreak;\n\t\t\n\t}\n\tif (copy_to_user(data, &bi, sizeof(bi)))\n\t\treturn -EFAULT;\n\treturn 0;\n\n}\n\n \n\nstatic const struct net_device_ops hdlcdrv_netdev = {\n\t.ndo_open\t= hdlcdrv_open,\n\t.ndo_stop\t= hdlcdrv_close,\n\t.ndo_start_xmit = hdlcdrv_send_packet,\n\t.ndo_siocdevprivate  = hdlcdrv_siocdevprivate,\n\t.ndo_set_mac_address = hdlcdrv_set_mac_address,\n};\n\n \nstatic void hdlcdrv_setup(struct net_device *dev)\n{\n\tstatic const struct hdlcdrv_channel_params dflt_ch_params = { \n\t\t20, 2, 10, 40, 0 \n\t};\n\tstruct hdlcdrv_state *s = netdev_priv(dev);\n\n\t \n\ts->ch_params = dflt_ch_params;\n\ts->ptt_keyed = 0;\n\n\tspin_lock_init(&s->hdlcrx.hbuf.lock);\n\ts->hdlcrx.hbuf.rd = s->hdlcrx.hbuf.wr = 0;\n\ts->hdlcrx.in_hdlc_rx = 0;\n\ts->hdlcrx.rx_state = 0;\n\t\n\tspin_lock_init(&s->hdlctx.hbuf.lock);\n\ts->hdlctx.hbuf.rd = s->hdlctx.hbuf.wr = 0;\n\ts->hdlctx.in_hdlc_tx = 0;\n\ts->hdlctx.tx_state = 1;\n\ts->hdlctx.numflags = 0;\n\ts->hdlctx.bitstream = s->hdlctx.bitbuf = s->hdlctx.numbits = 0;\n\ts->hdlctx.ptt = 0;\n\ts->hdlctx.slotcnt = s->ch_params.slottime;\n\ts->hdlctx.calibrate = 0;\n\n#ifdef HDLCDRV_DEBUG\n\ts->bitbuf_channel.rd = s->bitbuf_channel.wr = 0;\n\ts->bitbuf_channel.shreg = 0x80;\n\n\ts->bitbuf_hdlc.rd = s->bitbuf_hdlc.wr = 0;\n\ts->bitbuf_hdlc.shreg = 0x80;\n#endif  \n\n\n\t \n\n\ts->skb = NULL;\n\t\n\tdev->netdev_ops = &hdlcdrv_netdev;\n\tdev->header_ops = &ax25_header_ops;\n\t\n\tdev->type = ARPHRD_AX25;            \n\tdev->hard_header_len = AX25_MAX_HEADER_LEN + AX25_BPQ_HEADER_LEN;\n\tdev->mtu = AX25_DEF_PACLEN;         \n\tdev->addr_len = AX25_ADDR_LEN;      \n\tmemcpy(dev->broadcast, &ax25_bcast, AX25_ADDR_LEN);\n\tdev_addr_set(dev, (u8 *)&ax25_defaddr);\n\tdev->tx_queue_len = 16;\n}\n\n \nstruct net_device *hdlcdrv_register(const struct hdlcdrv_ops *ops,\n\t\t\t\t    unsigned int privsize, const char *ifname,\n\t\t\t\t    unsigned int baseaddr, unsigned int irq, \n\t\t\t\t    unsigned int dma) \n{\n\tstruct net_device *dev;\n\tstruct hdlcdrv_state *s;\n\tint err;\n\n\tif (privsize < sizeof(struct hdlcdrv_state))\n\t\tprivsize = sizeof(struct hdlcdrv_state);\n\n\tdev = alloc_netdev(privsize, ifname, NET_NAME_UNKNOWN, hdlcdrv_setup);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\ts = netdev_priv(dev);\n\ts->magic = HDLCDRV_MAGIC;\n\ts->ops = ops;\n\tdev->base_addr = baseaddr;\n\tdev->irq = irq;\n\tdev->dma = dma;\n\n\terr = register_netdev(dev);\n\tif (err < 0) {\n\t\tprintk(KERN_WARNING \"hdlcdrv: cannot register net \"\n\t\t       \"device %s\\n\", dev->name);\n\t\tfree_netdev(dev);\n\t\tdev = ERR_PTR(err);\n\t}\n\treturn dev;\n}\n\n \n\nvoid hdlcdrv_unregister(struct net_device *dev) \n{\n\tstruct hdlcdrv_state *s = netdev_priv(dev);\n\n\tBUG_ON(s->magic != HDLCDRV_MAGIC);\n\n\tif (s->opened && s->ops->close)\n\t\ts->ops->close(dev);\n\tunregister_netdev(dev);\n\t\n\tfree_netdev(dev);\n}\n\n \n\nEXPORT_SYMBOL(hdlcdrv_receiver);\nEXPORT_SYMBOL(hdlcdrv_transmitter);\nEXPORT_SYMBOL(hdlcdrv_arbitrate);\nEXPORT_SYMBOL(hdlcdrv_register);\nEXPORT_SYMBOL(hdlcdrv_unregister);\n\n \n\nstatic int __init hdlcdrv_init_driver(void)\n{\n\tprintk(KERN_INFO \"hdlcdrv: (C) 1996-2000 Thomas Sailer HB9JNX/AE4WA\\n\");\n\tprintk(KERN_INFO \"hdlcdrv: version 0.8\\n\");\n\treturn 0;\n}\n\n \n\nstatic void __exit hdlcdrv_cleanup_driver(void)\n{\n\tprintk(KERN_INFO \"hdlcdrv: cleanup\\n\");\n}\n\n \n\nMODULE_AUTHOR(\"Thomas M. Sailer, sailer@ife.ee.ethz.ch, hb9jnx@hb9w.che.eu\");\nMODULE_DESCRIPTION(\"Packet Radio network interface HDLC encoder/decoder\");\nMODULE_LICENSE(\"GPL\");\nmodule_init(hdlcdrv_init_driver);\nmodule_exit(hdlcdrv_cleanup_driver);\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}