{
  "module_name": "mac802154_hwsim.c",
  "hash_id": "31682d266333b5042a58efd82b90fa4b6677434d729613c9a8e9d9661ec40189",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ieee802154/mac802154_hwsim.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/timer.h>\n#include <linux/platform_device.h>\n#include <linux/rtnetlink.h>\n#include <linux/netdevice.h>\n#include <linux/device.h>\n#include <linux/spinlock.h>\n#include <net/ieee802154_netdev.h>\n#include <net/mac802154.h>\n#include <net/cfg802154.h>\n#include <net/genetlink.h>\n#include \"mac802154_hwsim.h\"\n\nMODULE_DESCRIPTION(\"Software simulator of IEEE 802.15.4 radio(s) for mac802154\");\nMODULE_LICENSE(\"GPL\");\n\nstatic LIST_HEAD(hwsim_phys);\nstatic DEFINE_MUTEX(hwsim_phys_lock);\n\nstatic struct platform_device *mac802154hwsim_dev;\n\n \nstatic struct genl_family hwsim_genl_family;\n\nstatic int hwsim_radio_idx;\n\nenum hwsim_multicast_groups {\n\tHWSIM_MCGRP_CONFIG,\n};\n\nstatic const struct genl_multicast_group hwsim_mcgrps[] = {\n\t[HWSIM_MCGRP_CONFIG] = { .name = \"config\", },\n};\n\nstruct hwsim_pib {\n\tu8 page;\n\tu8 channel;\n\tstruct ieee802154_hw_addr_filt filt;\n\tenum ieee802154_filtering_level filt_level;\n\n\tstruct rcu_head rcu;\n};\n\nstruct hwsim_edge_info {\n\tu8 lqi;\n\n\tstruct rcu_head rcu;\n};\n\nstruct hwsim_edge {\n\tstruct hwsim_phy *endpoint;\n\tstruct hwsim_edge_info __rcu *info;\n\n\tstruct list_head list;\n\tstruct rcu_head rcu;\n};\n\nstruct hwsim_phy {\n\tstruct ieee802154_hw *hw;\n\tu32 idx;\n\n\tstruct hwsim_pib __rcu *pib;\n\n\tbool suspended;\n\tstruct list_head edges;\n\n\tstruct list_head list;\n};\n\nstatic int hwsim_add_one(struct genl_info *info, struct device *dev,\n\t\t\t bool init);\nstatic void hwsim_del(struct hwsim_phy *phy);\n\nstatic int hwsim_hw_ed(struct ieee802154_hw *hw, u8 *level)\n{\n\t*level = 0xbe;\n\n\treturn 0;\n}\n\nstatic int hwsim_update_pib(struct ieee802154_hw *hw, u8 page, u8 channel,\n\t\t\t    struct ieee802154_hw_addr_filt *filt,\n\t\t\t    enum ieee802154_filtering_level filt_level)\n{\n\tstruct hwsim_phy *phy = hw->priv;\n\tstruct hwsim_pib *pib, *pib_old;\n\n\tpib = kzalloc(sizeof(*pib), GFP_ATOMIC);\n\tif (!pib)\n\t\treturn -ENOMEM;\n\n\tpib_old = rtnl_dereference(phy->pib);\n\n\tpib->page = page;\n\tpib->channel = channel;\n\tpib->filt.short_addr = filt->short_addr;\n\tpib->filt.pan_id = filt->pan_id;\n\tpib->filt.ieee_addr = filt->ieee_addr;\n\tpib->filt.pan_coord = filt->pan_coord;\n\tpib->filt_level = filt_level;\n\n\trcu_assign_pointer(phy->pib, pib);\n\tkfree_rcu(pib_old, rcu);\n\treturn 0;\n}\n\nstatic int hwsim_hw_channel(struct ieee802154_hw *hw, u8 page, u8 channel)\n{\n\tstruct hwsim_phy *phy = hw->priv;\n\tstruct hwsim_pib *pib;\n\tint ret;\n\n\trcu_read_lock();\n\tpib = rcu_dereference(phy->pib);\n\tret = hwsim_update_pib(hw, page, channel, &pib->filt, pib->filt_level);\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nstatic int hwsim_hw_addr_filt(struct ieee802154_hw *hw,\n\t\t\t      struct ieee802154_hw_addr_filt *filt,\n\t\t\t      unsigned long changed)\n{\n\tstruct hwsim_phy *phy = hw->priv;\n\tstruct hwsim_pib *pib;\n\tint ret;\n\n\trcu_read_lock();\n\tpib = rcu_dereference(phy->pib);\n\tret = hwsim_update_pib(hw, pib->page, pib->channel, filt, pib->filt_level);\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nstatic void hwsim_hw_receive(struct ieee802154_hw *hw, struct sk_buff *skb,\n\t\t\t     u8 lqi)\n{\n\tstruct ieee802154_hdr hdr;\n\tstruct hwsim_phy *phy = hw->priv;\n\tstruct hwsim_pib *pib;\n\n\trcu_read_lock();\n\tpib = rcu_dereference(phy->pib);\n\n\tif (!pskb_may_pull(skb, 3)) {\n\t\tdev_dbg(hw->parent, \"invalid frame\\n\");\n\t\tgoto drop;\n\t}\n\n\tmemcpy(&hdr, skb->data, 3);\n\n\t \n\tif (pib->filt_level == IEEE802154_FILTERING_4_FRAME_FIELDS) {\n\t\t \n\t\tswitch (mac_cb(skb)->type) {\n\t\tcase IEEE802154_FC_TYPE_BEACON:\n\t\tcase IEEE802154_FC_TYPE_DATA:\n\t\tcase IEEE802154_FC_TYPE_ACK:\n\t\tcase IEEE802154_FC_TYPE_MAC_CMD:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(hw->parent, \"unrecognized frame type 0x%x\\n\",\n\t\t\t\tmac_cb(skb)->type);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t \n\t\tswitch (hdr.fc.version) {\n\t\tcase IEEE802154_2003_STD:\n\t\tcase IEEE802154_2006_STD:\n\t\tcase IEEE802154_STD:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(hw->parent,\n\t\t\t\t\"unrecognized frame version 0x%x\\n\",\n\t\t\t\thdr.fc.version);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t \n\t\tif ((mac_cb(skb)->dest.mode == IEEE802154_ADDR_LONG ||\n\t\t     mac_cb(skb)->dest.mode == IEEE802154_ADDR_SHORT) &&\n\t\t    mac_cb(skb)->dest.pan_id != pib->filt.pan_id &&\n\t\t    mac_cb(skb)->dest.pan_id != cpu_to_le16(IEEE802154_PANID_BROADCAST)) {\n\t\t\tdev_dbg(hw->parent,\n\t\t\t\t\"unrecognized PAN ID %04x\\n\",\n\t\t\t\tle16_to_cpu(mac_cb(skb)->dest.pan_id));\n\t\t\tgoto drop;\n\t\t}\n\n\t\t \n\t\tif (mac_cb(skb)->dest.mode == IEEE802154_ADDR_SHORT &&\n\t\t    mac_cb(skb)->dest.short_addr != pib->filt.short_addr &&\n\t\t    mac_cb(skb)->dest.short_addr != cpu_to_le16(IEEE802154_ADDR_BROADCAST)) {\n\t\t\tdev_dbg(hw->parent,\n\t\t\t\t\"unrecognized short address %04x\\n\",\n\t\t\t\tle16_to_cpu(mac_cb(skb)->dest.short_addr));\n\t\t\tgoto drop;\n\t\t}\n\n\t\t \n\t\tif (mac_cb(skb)->dest.mode == IEEE802154_ADDR_LONG &&\n\t\t    mac_cb(skb)->dest.extended_addr != pib->filt.ieee_addr) {\n\t\t\tdev_dbg(hw->parent,\n\t\t\t\t\"unrecognized long address 0x%016llx\\n\",\n\t\t\t\tmac_cb(skb)->dest.extended_addr);\n\t\t\tgoto drop;\n\t\t}\n\n\t\t \n\t\tif ((mac_cb(skb)->type == IEEE802154_FC_TYPE_DATA ||\n\t\t     mac_cb(skb)->type == IEEE802154_FC_TYPE_MAC_CMD) &&\n\t\t    mac_cb(skb)->dest.mode == IEEE802154_ADDR_NONE) {\n\t\t\tdev_dbg(hw->parent,\n\t\t\t\t\"relaying is not supported\\n\");\n\t\t\tgoto drop;\n\t\t}\n\n\t\t \n\t\tif (mac_cb(skb)->type == IEEE802154_FC_TYPE_BEACON &&\n\t\t    pib->filt.pan_id != cpu_to_le16(IEEE802154_PANID_BROADCAST) &&\n\t\t    mac_cb(skb)->dest.pan_id != pib->filt.pan_id) {\n\t\t\tdev_dbg(hw->parent,\n\t\t\t\t\"invalid beacon PAN ID %04x\\n\",\n\t\t\t\tle16_to_cpu(mac_cb(skb)->dest.pan_id));\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\tieee802154_rx_irqsafe(hw, skb, lqi);\n\n\treturn;\n\ndrop:\n\trcu_read_unlock();\n\tkfree_skb(skb);\n}\n\nstatic int hwsim_hw_xmit(struct ieee802154_hw *hw, struct sk_buff *skb)\n{\n\tstruct hwsim_phy *current_phy = hw->priv;\n\tstruct hwsim_pib *current_pib, *endpoint_pib;\n\tstruct hwsim_edge_info *einfo;\n\tstruct hwsim_edge *e;\n\n\tWARN_ON(current_phy->suspended);\n\n\trcu_read_lock();\n\tcurrent_pib = rcu_dereference(current_phy->pib);\n\tlist_for_each_entry_rcu(e, &current_phy->edges, list) {\n\t\t \n\t\tif (e->endpoint->suspended)\n\t\t\tcontinue;\n\n\t\tendpoint_pib = rcu_dereference(e->endpoint->pib);\n\t\tif (current_pib->page == endpoint_pib->page &&\n\t\t    current_pib->channel == endpoint_pib->channel) {\n\t\t\tstruct sk_buff *newskb = pskb_copy(skb, GFP_ATOMIC);\n\n\t\t\teinfo = rcu_dereference(e->info);\n\t\t\tif (newskb)\n\t\t\t\thwsim_hw_receive(e->endpoint->hw, newskb, einfo->lqi);\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tieee802154_xmit_complete(hw, skb, false);\n\treturn 0;\n}\n\nstatic int hwsim_hw_start(struct ieee802154_hw *hw)\n{\n\tstruct hwsim_phy *phy = hw->priv;\n\n\tphy->suspended = false;\n\n\treturn 0;\n}\n\nstatic void hwsim_hw_stop(struct ieee802154_hw *hw)\n{\n\tstruct hwsim_phy *phy = hw->priv;\n\n\tphy->suspended = true;\n}\n\nstatic int\nhwsim_set_promiscuous_mode(struct ieee802154_hw *hw, const bool on)\n{\n\tenum ieee802154_filtering_level filt_level;\n\tstruct hwsim_phy *phy = hw->priv;\n\tstruct hwsim_pib *pib;\n\tint ret;\n\n\tif (on)\n\t\tfilt_level = IEEE802154_FILTERING_NONE;\n\telse\n\t\tfilt_level = IEEE802154_FILTERING_4_FRAME_FIELDS;\n\n\trcu_read_lock();\n\tpib = rcu_dereference(phy->pib);\n\tret = hwsim_update_pib(hw, pib->page, pib->channel, &pib->filt, filt_level);\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nstatic const struct ieee802154_ops hwsim_ops = {\n\t.owner = THIS_MODULE,\n\t.xmit_async = hwsim_hw_xmit,\n\t.ed = hwsim_hw_ed,\n\t.set_channel = hwsim_hw_channel,\n\t.start = hwsim_hw_start,\n\t.stop = hwsim_hw_stop,\n\t.set_promiscuous_mode = hwsim_set_promiscuous_mode,\n\t.set_hw_addr_filt = hwsim_hw_addr_filt,\n};\n\nstatic int hwsim_new_radio_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\treturn hwsim_add_one(info, &mac802154hwsim_dev->dev, false);\n}\n\nstatic int hwsim_del_radio_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct hwsim_phy *phy, *tmp;\n\ts64 idx = -1;\n\n\tif (!info->attrs[MAC802154_HWSIM_ATTR_RADIO_ID])\n\t\treturn -EINVAL;\n\n\tidx = nla_get_u32(info->attrs[MAC802154_HWSIM_ATTR_RADIO_ID]);\n\n\tmutex_lock(&hwsim_phys_lock);\n\tlist_for_each_entry_safe(phy, tmp, &hwsim_phys, list) {\n\t\tif (idx == phy->idx) {\n\t\t\thwsim_del(phy);\n\t\t\tmutex_unlock(&hwsim_phys_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tmutex_unlock(&hwsim_phys_lock);\n\n\treturn -ENODEV;\n}\n\nstatic int append_radio_msg(struct sk_buff *skb, struct hwsim_phy *phy)\n{\n\tstruct nlattr *nl_edges, *nl_edge;\n\tstruct hwsim_edge_info *einfo;\n\tstruct hwsim_edge *e;\n\tint ret;\n\n\tret = nla_put_u32(skb, MAC802154_HWSIM_ATTR_RADIO_ID, phy->idx);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trcu_read_lock();\n\tif (list_empty(&phy->edges)) {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\n\tnl_edges = nla_nest_start_noflag(skb,\n\t\t\t\t\t MAC802154_HWSIM_ATTR_RADIO_EDGES);\n\tif (!nl_edges) {\n\t\trcu_read_unlock();\n\t\treturn -ENOBUFS;\n\t}\n\n\tlist_for_each_entry_rcu(e, &phy->edges, list) {\n\t\tnl_edge = nla_nest_start_noflag(skb,\n\t\t\t\t\t\tMAC802154_HWSIM_ATTR_RADIO_EDGE);\n\t\tif (!nl_edge) {\n\t\t\trcu_read_unlock();\n\t\t\tnla_nest_cancel(skb, nl_edges);\n\t\t\treturn -ENOBUFS;\n\t\t}\n\n\t\tret = nla_put_u32(skb, MAC802154_HWSIM_EDGE_ATTR_ENDPOINT_ID,\n\t\t\t\t  e->endpoint->idx);\n\t\tif (ret < 0) {\n\t\t\trcu_read_unlock();\n\t\t\tnla_nest_cancel(skb, nl_edge);\n\t\t\tnla_nest_cancel(skb, nl_edges);\n\t\t\treturn ret;\n\t\t}\n\n\t\teinfo = rcu_dereference(e->info);\n\t\tret = nla_put_u8(skb, MAC802154_HWSIM_EDGE_ATTR_LQI,\n\t\t\t\t einfo->lqi);\n\t\tif (ret < 0) {\n\t\t\trcu_read_unlock();\n\t\t\tnla_nest_cancel(skb, nl_edge);\n\t\t\tnla_nest_cancel(skb, nl_edges);\n\t\t\treturn ret;\n\t\t}\n\n\t\tnla_nest_end(skb, nl_edge);\n\t}\n\trcu_read_unlock();\n\n\tnla_nest_end(skb, nl_edges);\n\n\treturn 0;\n}\n\nstatic int hwsim_get_radio(struct sk_buff *skb, struct hwsim_phy *phy,\n\t\t\t   u32 portid, u32 seq,\n\t\t\t   struct netlink_callback *cb, int flags)\n{\n\tvoid *hdr;\n\tint res;\n\n\thdr = genlmsg_put(skb, portid, seq, &hwsim_genl_family, flags,\n\t\t\t  MAC802154_HWSIM_CMD_GET_RADIO);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tif (cb)\n\t\tgenl_dump_check_consistent(cb, hdr);\n\n\tres = append_radio_msg(skb, phy);\n\tif (res < 0)\n\t\tgoto out_err;\n\n\tgenlmsg_end(skb, hdr);\n\treturn 0;\n\nout_err:\n\tgenlmsg_cancel(skb, hdr);\n\treturn res;\n}\n\nstatic int hwsim_get_radio_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct hwsim_phy *phy;\n\tstruct sk_buff *skb;\n\tint idx, res = -ENODEV;\n\n\tif (!info->attrs[MAC802154_HWSIM_ATTR_RADIO_ID])\n\t\treturn -EINVAL;\n\tidx = nla_get_u32(info->attrs[MAC802154_HWSIM_ATTR_RADIO_ID]);\n\n\tmutex_lock(&hwsim_phys_lock);\n\tlist_for_each_entry(phy, &hwsim_phys, list) {\n\t\tif (phy->idx != idx)\n\t\t\tcontinue;\n\n\t\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\t\tif (!skb) {\n\t\t\tres = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tres = hwsim_get_radio(skb, phy, info->snd_portid,\n\t\t\t\t      info->snd_seq, NULL, 0);\n\t\tif (res < 0) {\n\t\t\tnlmsg_free(skb);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tres = genlmsg_reply(skb, info);\n\t\tbreak;\n\t}\n\nout_err:\n\tmutex_unlock(&hwsim_phys_lock);\n\n\treturn res;\n}\n\nstatic int hwsim_dump_radio_nl(struct sk_buff *skb,\n\t\t\t       struct netlink_callback *cb)\n{\n\tint idx = cb->args[0];\n\tstruct hwsim_phy *phy;\n\tint res;\n\n\tmutex_lock(&hwsim_phys_lock);\n\n\tif (idx == hwsim_radio_idx)\n\t\tgoto done;\n\n\tlist_for_each_entry(phy, &hwsim_phys, list) {\n\t\tif (phy->idx < idx)\n\t\t\tcontinue;\n\n\t\tres = hwsim_get_radio(skb, phy, NETLINK_CB(cb->skb).portid,\n\t\t\t\t      cb->nlh->nlmsg_seq, cb, NLM_F_MULTI);\n\t\tif (res < 0)\n\t\t\tbreak;\n\n\t\tidx = phy->idx + 1;\n\t}\n\n\tcb->args[0] = idx;\n\ndone:\n\tmutex_unlock(&hwsim_phys_lock);\n\treturn skb->len;\n}\n\n \nstatic struct hwsim_phy *hwsim_get_radio_by_id(uint32_t idx)\n{\n\tstruct hwsim_phy *phy;\n\n\tlist_for_each_entry(phy, &hwsim_phys, list) {\n\t\tif (phy->idx == idx)\n\t\t\treturn phy;\n\t}\n\n\treturn NULL;\n}\n\nstatic const struct nla_policy hwsim_edge_policy[MAC802154_HWSIM_EDGE_ATTR_MAX + 1] = {\n\t[MAC802154_HWSIM_EDGE_ATTR_ENDPOINT_ID] = { .type = NLA_U32 },\n\t[MAC802154_HWSIM_EDGE_ATTR_LQI] = { .type = NLA_U8 },\n};\n\nstatic struct hwsim_edge *hwsim_alloc_edge(struct hwsim_phy *endpoint, u8 lqi)\n{\n\tstruct hwsim_edge_info *einfo;\n\tstruct hwsim_edge *e;\n\n\te = kzalloc(sizeof(*e), GFP_KERNEL);\n\tif (!e)\n\t\treturn NULL;\n\n\teinfo = kzalloc(sizeof(*einfo), GFP_KERNEL);\n\tif (!einfo) {\n\t\tkfree(e);\n\t\treturn NULL;\n\t}\n\n\teinfo->lqi = 0xff;\n\trcu_assign_pointer(e->info, einfo);\n\te->endpoint = endpoint;\n\n\treturn e;\n}\n\nstatic void hwsim_free_edge(struct hwsim_edge *e)\n{\n\tstruct hwsim_edge_info *einfo;\n\n\trcu_read_lock();\n\teinfo = rcu_dereference(e->info);\n\trcu_read_unlock();\n\n\tkfree_rcu(einfo, rcu);\n\tkfree_rcu(e, rcu);\n}\n\nstatic int hwsim_new_edge_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct nlattr *edge_attrs[MAC802154_HWSIM_EDGE_ATTR_MAX + 1];\n\tstruct hwsim_phy *phy_v0, *phy_v1;\n\tstruct hwsim_edge *e;\n\tu32 v0, v1;\n\n\tif (!info->attrs[MAC802154_HWSIM_ATTR_RADIO_ID] ||\n\t    !info->attrs[MAC802154_HWSIM_ATTR_RADIO_EDGE])\n\t\treturn -EINVAL;\n\n\tif (nla_parse_nested_deprecated(edge_attrs, MAC802154_HWSIM_EDGE_ATTR_MAX, info->attrs[MAC802154_HWSIM_ATTR_RADIO_EDGE], hwsim_edge_policy, NULL))\n\t\treturn -EINVAL;\n\n\tif (!edge_attrs[MAC802154_HWSIM_EDGE_ATTR_ENDPOINT_ID])\n\t\treturn -EINVAL;\n\n\tv0 = nla_get_u32(info->attrs[MAC802154_HWSIM_ATTR_RADIO_ID]);\n\tv1 = nla_get_u32(edge_attrs[MAC802154_HWSIM_EDGE_ATTR_ENDPOINT_ID]);\n\n\tif (v0 == v1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&hwsim_phys_lock);\n\tphy_v0 = hwsim_get_radio_by_id(v0);\n\tif (!phy_v0) {\n\t\tmutex_unlock(&hwsim_phys_lock);\n\t\treturn -ENOENT;\n\t}\n\n\tphy_v1 = hwsim_get_radio_by_id(v1);\n\tif (!phy_v1) {\n\t\tmutex_unlock(&hwsim_phys_lock);\n\t\treturn -ENOENT;\n\t}\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &phy_v0->edges, list) {\n\t\tif (e->endpoint->idx == v1) {\n\t\t\tmutex_unlock(&hwsim_phys_lock);\n\t\t\trcu_read_unlock();\n\t\t\treturn -EEXIST;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\te = hwsim_alloc_edge(phy_v1, 0xff);\n\tif (!e) {\n\t\tmutex_unlock(&hwsim_phys_lock);\n\t\treturn -ENOMEM;\n\t}\n\tlist_add_rcu(&e->list, &phy_v0->edges);\n\t \n\tsynchronize_rcu();\n\tmutex_unlock(&hwsim_phys_lock);\n\n\treturn 0;\n}\n\nstatic int hwsim_del_edge_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct nlattr *edge_attrs[MAC802154_HWSIM_EDGE_ATTR_MAX + 1];\n\tstruct hwsim_phy *phy_v0;\n\tstruct hwsim_edge *e;\n\tu32 v0, v1;\n\n\tif (!info->attrs[MAC802154_HWSIM_ATTR_RADIO_ID] ||\n\t    !info->attrs[MAC802154_HWSIM_ATTR_RADIO_EDGE])\n\t\treturn -EINVAL;\n\n\tif (nla_parse_nested_deprecated(edge_attrs, MAC802154_HWSIM_EDGE_ATTR_MAX, info->attrs[MAC802154_HWSIM_ATTR_RADIO_EDGE], hwsim_edge_policy, NULL))\n\t\treturn -EINVAL;\n\n\tif (!edge_attrs[MAC802154_HWSIM_EDGE_ATTR_ENDPOINT_ID])\n\t\treturn -EINVAL;\n\n\tv0 = nla_get_u32(info->attrs[MAC802154_HWSIM_ATTR_RADIO_ID]);\n\tv1 = nla_get_u32(edge_attrs[MAC802154_HWSIM_EDGE_ATTR_ENDPOINT_ID]);\n\n\tmutex_lock(&hwsim_phys_lock);\n\tphy_v0 = hwsim_get_radio_by_id(v0);\n\tif (!phy_v0) {\n\t\tmutex_unlock(&hwsim_phys_lock);\n\t\treturn -ENOENT;\n\t}\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &phy_v0->edges, list) {\n\t\tif (e->endpoint->idx == v1) {\n\t\t\trcu_read_unlock();\n\t\t\tlist_del_rcu(&e->list);\n\t\t\thwsim_free_edge(e);\n\t\t\t \n\t\t\tsynchronize_rcu();\n\t\t\tmutex_unlock(&hwsim_phys_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tmutex_unlock(&hwsim_phys_lock);\n\n\treturn -ENOENT;\n}\n\nstatic int hwsim_set_edge_lqi(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct nlattr *edge_attrs[MAC802154_HWSIM_EDGE_ATTR_MAX + 1];\n\tstruct hwsim_edge_info *einfo, *einfo_old;\n\tstruct hwsim_phy *phy_v0;\n\tstruct hwsim_edge *e;\n\tu32 v0, v1;\n\tu8 lqi;\n\n\tif (!info->attrs[MAC802154_HWSIM_ATTR_RADIO_ID] ||\n\t    !info->attrs[MAC802154_HWSIM_ATTR_RADIO_EDGE])\n\t\treturn -EINVAL;\n\n\tif (nla_parse_nested_deprecated(edge_attrs, MAC802154_HWSIM_EDGE_ATTR_MAX, info->attrs[MAC802154_HWSIM_ATTR_RADIO_EDGE], hwsim_edge_policy, NULL))\n\t\treturn -EINVAL;\n\n\tif (!edge_attrs[MAC802154_HWSIM_EDGE_ATTR_ENDPOINT_ID] ||\n\t    !edge_attrs[MAC802154_HWSIM_EDGE_ATTR_LQI])\n\t\treturn -EINVAL;\n\n\tv0 = nla_get_u32(info->attrs[MAC802154_HWSIM_ATTR_RADIO_ID]);\n\tv1 = nla_get_u32(edge_attrs[MAC802154_HWSIM_EDGE_ATTR_ENDPOINT_ID]);\n\tlqi = nla_get_u8(edge_attrs[MAC802154_HWSIM_EDGE_ATTR_LQI]);\n\n\tmutex_lock(&hwsim_phys_lock);\n\tphy_v0 = hwsim_get_radio_by_id(v0);\n\tif (!phy_v0) {\n\t\tmutex_unlock(&hwsim_phys_lock);\n\t\treturn -ENOENT;\n\t}\n\n\teinfo = kzalloc(sizeof(*einfo), GFP_KERNEL);\n\tif (!einfo) {\n\t\tmutex_unlock(&hwsim_phys_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &phy_v0->edges, list) {\n\t\tif (e->endpoint->idx == v1) {\n\t\t\teinfo->lqi = lqi;\n\t\t\teinfo_old = rcu_replace_pointer(e->info, einfo,\n\t\t\t\t\t\t\tlockdep_is_held(&hwsim_phys_lock));\n\t\t\trcu_read_unlock();\n\t\t\tkfree_rcu(einfo_old, rcu);\n\t\t\tmutex_unlock(&hwsim_phys_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tkfree(einfo);\n\tmutex_unlock(&hwsim_phys_lock);\n\n\treturn -ENOENT;\n}\n\n \n\nstatic const struct nla_policy hwsim_genl_policy[MAC802154_HWSIM_ATTR_MAX + 1] = {\n\t[MAC802154_HWSIM_ATTR_RADIO_ID] = { .type = NLA_U32 },\n\t[MAC802154_HWSIM_ATTR_RADIO_EDGE] = { .type = NLA_NESTED },\n\t[MAC802154_HWSIM_ATTR_RADIO_EDGES] = { .type = NLA_NESTED },\n};\n\n \nstatic const struct genl_small_ops hwsim_nl_ops[] = {\n\t{\n\t\t.cmd = MAC802154_HWSIM_CMD_NEW_RADIO,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = hwsim_new_radio_nl,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = MAC802154_HWSIM_CMD_DEL_RADIO,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = hwsim_del_radio_nl,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = MAC802154_HWSIM_CMD_GET_RADIO,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = hwsim_get_radio_nl,\n\t\t.dumpit = hwsim_dump_radio_nl,\n\t},\n\t{\n\t\t.cmd = MAC802154_HWSIM_CMD_NEW_EDGE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = hwsim_new_edge_nl,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = MAC802154_HWSIM_CMD_DEL_EDGE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = hwsim_del_edge_nl,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = MAC802154_HWSIM_CMD_SET_EDGE,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = hwsim_set_edge_lqi,\n\t\t.flags = GENL_UNS_ADMIN_PERM,\n\t},\n};\n\nstatic struct genl_family hwsim_genl_family __ro_after_init = {\n\t.name = \"MAC802154_HWSIM\",\n\t.version = 1,\n\t.maxattr = MAC802154_HWSIM_ATTR_MAX,\n\t.policy = hwsim_genl_policy,\n\t.module = THIS_MODULE,\n\t.small_ops = hwsim_nl_ops,\n\t.n_small_ops = ARRAY_SIZE(hwsim_nl_ops),\n\t.resv_start_op = MAC802154_HWSIM_CMD_NEW_EDGE + 1,\n\t.mcgrps = hwsim_mcgrps,\n\t.n_mcgrps = ARRAY_SIZE(hwsim_mcgrps),\n};\n\nstatic void hwsim_mcast_config_msg(struct sk_buff *mcast_skb,\n\t\t\t\t   struct genl_info *info)\n{\n\tif (info)\n\t\tgenl_notify(&hwsim_genl_family, mcast_skb, info,\n\t\t\t    HWSIM_MCGRP_CONFIG, GFP_KERNEL);\n\telse\n\t\tgenlmsg_multicast(&hwsim_genl_family, mcast_skb, 0,\n\t\t\t\t  HWSIM_MCGRP_CONFIG, GFP_KERNEL);\n}\n\nstatic void hwsim_mcast_new_radio(struct genl_info *info, struct hwsim_phy *phy)\n{\n\tstruct sk_buff *mcast_skb;\n\tvoid *data;\n\n\tmcast_skb = genlmsg_new(GENLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!mcast_skb)\n\t\treturn;\n\n\tdata = genlmsg_put(mcast_skb, 0, 0, &hwsim_genl_family, 0,\n\t\t\t   MAC802154_HWSIM_CMD_NEW_RADIO);\n\tif (!data)\n\t\tgoto out_err;\n\n\tif (append_radio_msg(mcast_skb, phy) < 0)\n\t\tgoto out_err;\n\n\tgenlmsg_end(mcast_skb, data);\n\n\thwsim_mcast_config_msg(mcast_skb, info);\n\treturn;\n\nout_err:\n\tgenlmsg_cancel(mcast_skb, data);\n\tnlmsg_free(mcast_skb);\n}\n\nstatic void hwsim_edge_unsubscribe_me(struct hwsim_phy *phy)\n{\n\tstruct hwsim_phy *tmp;\n\tstruct hwsim_edge *e;\n\n\trcu_read_lock();\n\t \n\tlist_for_each_entry(tmp, &hwsim_phys, list) {\n\t\tlist_for_each_entry_rcu(e, &tmp->edges, list) {\n\t\t\tif (e->endpoint->idx == phy->idx) {\n\t\t\t\tlist_del_rcu(&e->list);\n\t\t\t\thwsim_free_edge(e);\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tsynchronize_rcu();\n}\n\nstatic int hwsim_subscribe_all_others(struct hwsim_phy *phy)\n{\n\tstruct hwsim_phy *sub;\n\tstruct hwsim_edge *e;\n\n\tlist_for_each_entry(sub, &hwsim_phys, list) {\n\t\te = hwsim_alloc_edge(sub, 0xff);\n\t\tif (!e)\n\t\t\tgoto me_fail;\n\n\t\tlist_add_rcu(&e->list, &phy->edges);\n\t}\n\n\tlist_for_each_entry(sub, &hwsim_phys, list) {\n\t\te = hwsim_alloc_edge(phy, 0xff);\n\t\tif (!e)\n\t\t\tgoto sub_fail;\n\n\t\tlist_add_rcu(&e->list, &sub->edges);\n\t}\n\n\treturn 0;\n\nsub_fail:\n\thwsim_edge_unsubscribe_me(phy);\nme_fail:\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &phy->edges, list) {\n\t\tlist_del_rcu(&e->list);\n\t\thwsim_free_edge(e);\n\t}\n\trcu_read_unlock();\n\treturn -ENOMEM;\n}\n\nstatic int hwsim_add_one(struct genl_info *info, struct device *dev,\n\t\t\t bool init)\n{\n\tstruct ieee802154_hw *hw;\n\tstruct hwsim_phy *phy;\n\tstruct hwsim_pib *pib;\n\tint idx;\n\tint err;\n\n\tidx = hwsim_radio_idx++;\n\n\thw = ieee802154_alloc_hw(sizeof(*phy), &hwsim_ops);\n\tif (!hw)\n\t\treturn -ENOMEM;\n\n\tphy = hw->priv;\n\tphy->hw = hw;\n\n\t \n\thw->phy->supported.channels[0] |= 1;\n\t \n\thw->phy->supported.channels[0] |= 0x7fe;\n\t \n\thw->phy->supported.channels[0] |= 0x7FFF800;\n\t \n\thw->phy->supported.channels[1] |= 1;\n\t \n\thw->phy->supported.channels[1] |= 0x7fe;\n\t \n\thw->phy->supported.channels[2] |= 1;\n\t \n\thw->phy->supported.channels[2] |= 0x7fe;\n\t \n\thw->phy->supported.channels[3] |= 0x3fff;\n\t \n\thw->phy->supported.channels[4] |= 1;\n\t \n\thw->phy->supported.channels[4] |= 0x1e;\n\t \n\thw->phy->supported.channels[4] |= 0xffe0;\n\t \n\thw->phy->supported.channels[5] |= 0xf;\n\t \n\thw->phy->supported.channels[5] |= 0xf0;\n\t \n\thw->phy->supported.channels[6] |= 0x3ff;\n\t \n\thw->phy->supported.channels[6] |= 0x3ffc00;\n\n\tieee802154_random_extended_addr(&hw->phy->perm_extended_addr);\n\n\t \n\thw->phy->current_channel = 13;\n\tpib = kzalloc(sizeof(*pib), GFP_KERNEL);\n\tif (!pib) {\n\t\terr = -ENOMEM;\n\t\tgoto err_pib;\n\t}\n\n\tpib->channel = 13;\n\tpib->filt.short_addr = cpu_to_le16(IEEE802154_ADDR_BROADCAST);\n\tpib->filt.pan_id = cpu_to_le16(IEEE802154_PANID_BROADCAST);\n\trcu_assign_pointer(phy->pib, pib);\n\tphy->idx = idx;\n\tINIT_LIST_HEAD(&phy->edges);\n\n\thw->flags = IEEE802154_HW_PROMISCUOUS;\n\thw->parent = dev;\n\n\terr = ieee802154_register_hw(hw);\n\tif (err)\n\t\tgoto err_reg;\n\n\tmutex_lock(&hwsim_phys_lock);\n\tif (init) {\n\t\terr = hwsim_subscribe_all_others(phy);\n\t\tif (err < 0) {\n\t\t\tmutex_unlock(&hwsim_phys_lock);\n\t\t\tgoto err_subscribe;\n\t\t}\n\t}\n\tlist_add_tail(&phy->list, &hwsim_phys);\n\tmutex_unlock(&hwsim_phys_lock);\n\n\thwsim_mcast_new_radio(info, phy);\n\n\treturn idx;\n\nerr_subscribe:\n\tieee802154_unregister_hw(phy->hw);\nerr_reg:\n\tkfree(pib);\nerr_pib:\n\tieee802154_free_hw(phy->hw);\n\treturn err;\n}\n\nstatic void hwsim_del(struct hwsim_phy *phy)\n{\n\tstruct hwsim_pib *pib;\n\tstruct hwsim_edge *e;\n\n\thwsim_edge_unsubscribe_me(phy);\n\n\tlist_del(&phy->list);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &phy->edges, list) {\n\t\tlist_del_rcu(&e->list);\n\t\thwsim_free_edge(e);\n\t}\n\tpib = rcu_dereference(phy->pib);\n\trcu_read_unlock();\n\n\tkfree_rcu(pib, rcu);\n\n\tieee802154_unregister_hw(phy->hw);\n\tieee802154_free_hw(phy->hw);\n}\n\nstatic int hwsim_probe(struct platform_device *pdev)\n{\n\tstruct hwsim_phy *phy, *tmp;\n\tint err, i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\terr = hwsim_add_one(NULL, &pdev->dev, true);\n\t\tif (err < 0)\n\t\t\tgoto err_slave;\n\t}\n\n\tdev_info(&pdev->dev, \"Added 2 mac802154 hwsim hardware radios\\n\");\n\treturn 0;\n\nerr_slave:\n\tmutex_lock(&hwsim_phys_lock);\n\tlist_for_each_entry_safe(phy, tmp, &hwsim_phys, list)\n\t\thwsim_del(phy);\n\tmutex_unlock(&hwsim_phys_lock);\n\treturn err;\n}\n\nstatic int hwsim_remove(struct platform_device *pdev)\n{\n\tstruct hwsim_phy *phy, *tmp;\n\n\tmutex_lock(&hwsim_phys_lock);\n\tlist_for_each_entry_safe(phy, tmp, &hwsim_phys, list)\n\t\thwsim_del(phy);\n\tmutex_unlock(&hwsim_phys_lock);\n\n\treturn 0;\n}\n\nstatic struct platform_driver mac802154hwsim_driver = {\n\t.probe = hwsim_probe,\n\t.remove = hwsim_remove,\n\t.driver = {\n\t\t\t.name = \"mac802154_hwsim\",\n\t},\n};\n\nstatic __init int hwsim_init_module(void)\n{\n\tint rc;\n\n\trc = genl_register_family(&hwsim_genl_family);\n\tif (rc)\n\t\treturn rc;\n\n\tmac802154hwsim_dev = platform_device_register_simple(\"mac802154_hwsim\",\n\t\t\t\t\t\t\t     -1, NULL, 0);\n\tif (IS_ERR(mac802154hwsim_dev)) {\n\t\trc = PTR_ERR(mac802154hwsim_dev);\n\t\tgoto platform_dev;\n\t}\n\n\trc = platform_driver_register(&mac802154hwsim_driver);\n\tif (rc < 0)\n\t\tgoto platform_drv;\n\n\treturn 0;\n\nplatform_drv:\n\tplatform_device_unregister(mac802154hwsim_dev);\nplatform_dev:\n\tgenl_unregister_family(&hwsim_genl_family);\n\treturn rc;\n}\n\nstatic __exit void hwsim_remove_module(void)\n{\n\tgenl_unregister_family(&hwsim_genl_family);\n\tplatform_driver_unregister(&mac802154hwsim_driver);\n\tplatform_device_unregister(mac802154hwsim_dev);\n}\n\nmodule_init(hwsim_init_module);\nmodule_exit(hwsim_remove_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}