{
  "module_name": "mrf24j40.c",
  "hash_id": "5d05717e47f01ea4b9c6e6545efd0116a4f75112a3795d90033f86bf413fc369",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ieee802154/mrf24j40.c",
  "human_readable_source": "\n \n\n#include <linux/spi/spi.h>\n#include <linux/interrupt.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/ieee802154.h>\n#include <linux/irq.h>\n#include <net/cfg802154.h>\n#include <net/mac802154.h>\n\n \n#define REG_RXMCR\t0x00   \n#define BIT_PROMI\tBIT(0)\n#define BIT_ERRPKT\tBIT(1)\n#define BIT_NOACKRSP\tBIT(5)\n#define BIT_PANCOORD\tBIT(3)\n\n#define REG_PANIDL\t0x01   \n#define REG_PANIDH\t0x02   \n#define REG_SADRL\t0x03   \n#define REG_SADRH\t0x04   \n#define REG_EADR0\t0x05   \n#define REG_EADR1\t0x06\n#define REG_EADR2\t0x07\n#define REG_EADR3\t0x08\n#define REG_EADR4\t0x09\n#define REG_EADR5\t0x0A\n#define REG_EADR6\t0x0B\n#define REG_EADR7\t0x0C\n#define REG_RXFLUSH\t0x0D\n#define REG_ORDER\t0x10\n#define REG_TXMCR\t0x11   \n#define TXMCR_MIN_BE_SHIFT\t\t3\n#define TXMCR_MIN_BE_MASK\t\t0x18\n#define TXMCR_CSMA_RETRIES_SHIFT\t0\n#define TXMCR_CSMA_RETRIES_MASK\t\t0x07\n\n#define REG_ACKTMOUT\t0x12\n#define REG_ESLOTG1\t0x13\n#define REG_SYMTICKL\t0x14\n#define REG_SYMTICKH\t0x15\n#define REG_PACON0\t0x16   \n#define REG_PACON1\t0x17   \n#define REG_PACON2\t0x18   \n#define REG_TXBCON0\t0x1A\n#define REG_TXNCON\t0x1B   \n#define BIT_TXNTRIG\tBIT(0)\n#define BIT_TXNSECEN\tBIT(1)\n#define BIT_TXNACKREQ\tBIT(2)\n\n#define REG_TXG1CON\t0x1C\n#define REG_TXG2CON\t0x1D\n#define REG_ESLOTG23\t0x1E\n#define REG_ESLOTG45\t0x1F\n#define REG_ESLOTG67\t0x20\n#define REG_TXPEND\t0x21\n#define REG_WAKECON\t0x22\n#define REG_FROMOFFSET\t0x23\n#define REG_TXSTAT\t0x24   \n#define REG_TXBCON1\t0x25\n#define REG_GATECLK\t0x26\n#define REG_TXTIME\t0x27\n#define REG_HSYMTMRL\t0x28\n#define REG_HSYMTMRH\t0x29\n#define REG_SOFTRST\t0x2A   \n#define REG_SECCON0\t0x2C\n#define REG_SECCON1\t0x2D\n#define REG_TXSTBL\t0x2E   \n#define REG_RXSR\t0x30\n#define REG_INTSTAT\t0x31   \n#define BIT_TXNIF\tBIT(0)\n#define BIT_RXIF\tBIT(3)\n#define BIT_SECIF\tBIT(4)\n#define BIT_SECIGNORE\tBIT(7)\n\n#define REG_INTCON\t0x32   \n#define BIT_TXNIE\tBIT(0)\n#define BIT_RXIE\tBIT(3)\n#define BIT_SECIE\tBIT(4)\n\n#define REG_GPIO\t0x33   \n#define REG_TRISGPIO\t0x34   \n#define REG_SLPACK\t0x35\n#define REG_RFCTL\t0x36   \n#define BIT_RFRST\tBIT(2)\n\n#define REG_SECCR2\t0x37\n#define REG_BBREG0\t0x38\n#define REG_BBREG1\t0x39   \n#define BIT_RXDECINV\tBIT(2)\n\n#define REG_BBREG2\t0x3A   \n#define BBREG2_CCA_MODE_SHIFT\t6\n#define BBREG2_CCA_MODE_MASK\t0xc0\n\n#define REG_BBREG3\t0x3B\n#define REG_BBREG4\t0x3C\n#define REG_BBREG6\t0x3E   \n#define REG_CCAEDTH\t0x3F   \n\n \n#define REG_RFCON0\t0x200   \n#define RFCON0_CH_SHIFT\t4\n#define RFCON0_CH_MASK\t0xf0\n#define RFOPT_RECOMMEND\t3\n\n#define REG_RFCON1\t0x201\n#define REG_RFCON2\t0x202\n#define REG_RFCON3\t0x203\n\n#define TXPWRL_MASK\t0xc0\n#define TXPWRL_SHIFT\t6\n#define TXPWRL_30\t0x3\n#define TXPWRL_20\t0x2\n#define TXPWRL_10\t0x1\n#define TXPWRL_0\t0x0\n\n#define TXPWRS_MASK\t0x38\n#define TXPWRS_SHIFT\t3\n#define TXPWRS_6_3\t0x7\n#define TXPWRS_4_9\t0x6\n#define TXPWRS_3_7\t0x5\n#define TXPWRS_2_8\t0x4\n#define TXPWRS_1_9\t0x3\n#define TXPWRS_1_2\t0x2\n#define TXPWRS_0_5\t0x1\n#define TXPWRS_0\t0x0\n\n#define REG_RFCON5\t0x205\n#define REG_RFCON6\t0x206\n#define REG_RFCON7\t0x207\n#define REG_RFCON8\t0x208\n#define REG_SLPCAL0\t0x209\n#define REG_SLPCAL1\t0x20A\n#define REG_SLPCAL2\t0x20B\n#define REG_RFSTATE\t0x20F\n#define REG_RSSI\t0x210\n#define REG_SLPCON0\t0x211   \n#define BIT_INTEDGE\tBIT(1)\n\n#define REG_SLPCON1\t0x220\n#define REG_WAKETIMEL\t0x222   \n#define REG_WAKETIMEH\t0x223   \n#define REG_REMCNTL\t0x224\n#define REG_REMCNTH\t0x225\n#define REG_MAINCNT0\t0x226\n#define REG_MAINCNT1\t0x227\n#define REG_MAINCNT2\t0x228\n#define REG_MAINCNT3\t0x229\n#define REG_TESTMODE\t0x22F   \n#define REG_ASSOEAR0\t0x230\n#define REG_ASSOEAR1\t0x231\n#define REG_ASSOEAR2\t0x232\n#define REG_ASSOEAR3\t0x233\n#define REG_ASSOEAR4\t0x234\n#define REG_ASSOEAR5\t0x235\n#define REG_ASSOEAR6\t0x236\n#define REG_ASSOEAR7\t0x237\n#define REG_ASSOSAR0\t0x238\n#define REG_ASSOSAR1\t0x239\n#define REG_UNONCE0\t0x240\n#define REG_UNONCE1\t0x241\n#define REG_UNONCE2\t0x242\n#define REG_UNONCE3\t0x243\n#define REG_UNONCE4\t0x244\n#define REG_UNONCE5\t0x245\n#define REG_UNONCE6\t0x246\n#define REG_UNONCE7\t0x247\n#define REG_UNONCE8\t0x248\n#define REG_UNONCE9\t0x249\n#define REG_UNONCE10\t0x24A\n#define REG_UNONCE11\t0x24B\n#define REG_UNONCE12\t0x24C\n#define REG_RX_FIFO\t0x300   \n\n \n#define MRF24J40_CHAN_MIN 11\n#define MRF24J40_CHAN_MAX 26\n#define CHANNEL_MASK (((u32)1 << (MRF24J40_CHAN_MAX + 1)) \\\n\t\t      - ((u32)1 << MRF24J40_CHAN_MIN))\n\n#define TX_FIFO_SIZE 128  \n#define RX_FIFO_SIZE 144  \n#define SET_CHANNEL_DELAY_US 192  \n\nenum mrf24j40_modules { MRF24J40, MRF24J40MA, MRF24J40MC };\n\n \nstruct mrf24j40 {\n\tstruct spi_device *spi;\n\tstruct ieee802154_hw *hw;\n\n\tstruct regmap *regmap_short;\n\tstruct regmap *regmap_long;\n\n\t \n\tstruct spi_message tx_msg;\n\tu8 tx_hdr_buf[2];\n\tstruct spi_transfer tx_hdr_trx;\n\tu8 tx_len_buf[2];\n\tstruct spi_transfer tx_len_trx;\n\tstruct spi_transfer tx_buf_trx;\n\tstruct sk_buff *tx_skb;\n\n\t \n\tstruct spi_message tx_post_msg;\n\tu8 tx_post_buf[2];\n\tstruct spi_transfer tx_post_trx;\n\n\t \n\tstruct spi_message rx_msg;\n\tu8 rx_buf[3];\n\tstruct spi_transfer rx_trx;\n\n\t \n\tstruct spi_message rx_buf_msg;\n\tu8 rx_addr_buf[2];\n\tstruct spi_transfer rx_addr_trx;\n\tu8 rx_lqi_buf[2];\n\tstruct spi_transfer rx_lqi_trx;\n\tu8 rx_fifo_buf[RX_FIFO_SIZE];\n\tstruct spi_transfer rx_fifo_buf_trx;\n\n\t \n\tstruct spi_message irq_msg;\n\tu8 irq_buf[2];\n\tstruct spi_transfer irq_trx;\n};\n\n \n#define MRF24J40_SHORT_WRITE\t0x01\n#define MRF24J40_SHORT_READ\t0x00\n#define MRF24J40_SHORT_NUMREGS\t0x3F\n\n \n#define MRF24J40_LONG_ACCESS\t0x80\n#define MRF24J40_LONG_NUMREGS\t0x38F\n\n \n#define MRF24J40_READSHORT(reg) ((reg) << 1)\n#define MRF24J40_WRITESHORT(reg) ((reg) << 1 | 1)\n#define MRF24J40_READLONG(reg) (1 << 15 | (reg) << 5)\n#define MRF24J40_WRITELONG(reg) (1 << 15 | (reg) << 5 | 1 << 4)\n\n \n#define MAX_SPI_SPEED_HZ 10000000\n\n#define printdev(X) (&X->spi->dev)\n\nstatic bool\nmrf24j40_short_reg_writeable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase REG_RXMCR:\n\tcase REG_PANIDL:\n\tcase REG_PANIDH:\n\tcase REG_SADRL:\n\tcase REG_SADRH:\n\tcase REG_EADR0:\n\tcase REG_EADR1:\n\tcase REG_EADR2:\n\tcase REG_EADR3:\n\tcase REG_EADR4:\n\tcase REG_EADR5:\n\tcase REG_EADR6:\n\tcase REG_EADR7:\n\tcase REG_RXFLUSH:\n\tcase REG_ORDER:\n\tcase REG_TXMCR:\n\tcase REG_ACKTMOUT:\n\tcase REG_ESLOTG1:\n\tcase REG_SYMTICKL:\n\tcase REG_SYMTICKH:\n\tcase REG_PACON0:\n\tcase REG_PACON1:\n\tcase REG_PACON2:\n\tcase REG_TXBCON0:\n\tcase REG_TXNCON:\n\tcase REG_TXG1CON:\n\tcase REG_TXG2CON:\n\tcase REG_ESLOTG23:\n\tcase REG_ESLOTG45:\n\tcase REG_ESLOTG67:\n\tcase REG_TXPEND:\n\tcase REG_WAKECON:\n\tcase REG_FROMOFFSET:\n\tcase REG_TXBCON1:\n\tcase REG_GATECLK:\n\tcase REG_TXTIME:\n\tcase REG_HSYMTMRL:\n\tcase REG_HSYMTMRH:\n\tcase REG_SOFTRST:\n\tcase REG_SECCON0:\n\tcase REG_SECCON1:\n\tcase REG_TXSTBL:\n\tcase REG_RXSR:\n\tcase REG_INTCON:\n\tcase REG_TRISGPIO:\n\tcase REG_GPIO:\n\tcase REG_RFCTL:\n\tcase REG_SECCR2:\n\tcase REG_SLPACK:\n\tcase REG_BBREG0:\n\tcase REG_BBREG1:\n\tcase REG_BBREG2:\n\tcase REG_BBREG3:\n\tcase REG_BBREG4:\n\tcase REG_BBREG6:\n\tcase REG_CCAEDTH:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool\nmrf24j40_short_reg_readable(struct device *dev, unsigned int reg)\n{\n\tbool rc;\n\n\t \n\trc = mrf24j40_short_reg_writeable(dev, reg);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tswitch (reg) {\n\tcase REG_TXSTAT:\n\tcase REG_INTSTAT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool\nmrf24j40_short_reg_volatile(struct device *dev, unsigned int reg)\n{\n\t \n\tswitch (reg) {\n\tcase REG_TXSTAT:\n\tcase REG_INTSTAT:\n\tcase REG_RXFLUSH:\n\tcase REG_TXNCON:\n\tcase REG_SOFTRST:\n\tcase REG_RFCTL:\n\tcase REG_TXBCON0:\n\tcase REG_TXG1CON:\n\tcase REG_TXG2CON:\n\tcase REG_TXBCON1:\n\tcase REG_SECCON0:\n\tcase REG_RXSR:\n\tcase REG_SLPACK:\n\tcase REG_SECCR2:\n\tcase REG_BBREG6:\n\t \n\tcase REG_BBREG1:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool\nmrf24j40_short_reg_precious(struct device *dev, unsigned int reg)\n{\n\t \n\tswitch (reg) {\n\tcase REG_INTSTAT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config mrf24j40_short_regmap = {\n\t.name = \"mrf24j40_short\",\n\t.reg_bits = 7,\n\t.val_bits = 8,\n\t.pad_bits = 1,\n\t.write_flag_mask = MRF24J40_SHORT_WRITE,\n\t.read_flag_mask = MRF24J40_SHORT_READ,\n\t.cache_type = REGCACHE_RBTREE,\n\t.max_register = MRF24J40_SHORT_NUMREGS,\n\t.writeable_reg = mrf24j40_short_reg_writeable,\n\t.readable_reg = mrf24j40_short_reg_readable,\n\t.volatile_reg = mrf24j40_short_reg_volatile,\n\t.precious_reg = mrf24j40_short_reg_precious,\n};\n\nstatic bool\nmrf24j40_long_reg_writeable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase REG_RFCON0:\n\tcase REG_RFCON1:\n\tcase REG_RFCON2:\n\tcase REG_RFCON3:\n\tcase REG_RFCON5:\n\tcase REG_RFCON6:\n\tcase REG_RFCON7:\n\tcase REG_RFCON8:\n\tcase REG_SLPCAL2:\n\tcase REG_SLPCON0:\n\tcase REG_SLPCON1:\n\tcase REG_WAKETIMEL:\n\tcase REG_WAKETIMEH:\n\tcase REG_REMCNTL:\n\tcase REG_REMCNTH:\n\tcase REG_MAINCNT0:\n\tcase REG_MAINCNT1:\n\tcase REG_MAINCNT2:\n\tcase REG_MAINCNT3:\n\tcase REG_TESTMODE:\n\tcase REG_ASSOEAR0:\n\tcase REG_ASSOEAR1:\n\tcase REG_ASSOEAR2:\n\tcase REG_ASSOEAR3:\n\tcase REG_ASSOEAR4:\n\tcase REG_ASSOEAR5:\n\tcase REG_ASSOEAR6:\n\tcase REG_ASSOEAR7:\n\tcase REG_ASSOSAR0:\n\tcase REG_ASSOSAR1:\n\tcase REG_UNONCE0:\n\tcase REG_UNONCE1:\n\tcase REG_UNONCE2:\n\tcase REG_UNONCE3:\n\tcase REG_UNONCE4:\n\tcase REG_UNONCE5:\n\tcase REG_UNONCE6:\n\tcase REG_UNONCE7:\n\tcase REG_UNONCE8:\n\tcase REG_UNONCE9:\n\tcase REG_UNONCE10:\n\tcase REG_UNONCE11:\n\tcase REG_UNONCE12:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool\nmrf24j40_long_reg_readable(struct device *dev, unsigned int reg)\n{\n\tbool rc;\n\n\t \n\trc = mrf24j40_long_reg_writeable(dev, reg);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tswitch (reg) {\n\tcase REG_SLPCAL0:\n\tcase REG_SLPCAL1:\n\tcase REG_RFSTATE:\n\tcase REG_RSSI:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool\nmrf24j40_long_reg_volatile(struct device *dev, unsigned int reg)\n{\n\t \n\tswitch (reg) {\n\tcase REG_SLPCAL0:\n\tcase REG_SLPCAL1:\n\tcase REG_SLPCAL2:\n\tcase REG_RFSTATE:\n\tcase REG_RSSI:\n\tcase REG_MAINCNT3:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config mrf24j40_long_regmap = {\n\t.name = \"mrf24j40_long\",\n\t.reg_bits = 11,\n\t.val_bits = 8,\n\t.pad_bits = 5,\n\t.write_flag_mask = MRF24J40_LONG_ACCESS,\n\t.read_flag_mask = MRF24J40_LONG_ACCESS,\n\t.cache_type = REGCACHE_RBTREE,\n\t.max_register = MRF24J40_LONG_NUMREGS,\n\t.writeable_reg = mrf24j40_long_reg_writeable,\n\t.readable_reg = mrf24j40_long_reg_readable,\n\t.volatile_reg = mrf24j40_long_reg_volatile,\n};\n\nstatic int mrf24j40_long_regmap_write(void *context, const void *data,\n\t\t\t\t      size_t count)\n{\n\tstruct spi_device *spi = context;\n\tu8 buf[3];\n\n\tif (count > 3)\n\t\treturn -EINVAL;\n\n\t \n\tmemcpy(buf, data, count);\n\tbuf[1] |= (1 << 4);\n\n\treturn spi_write(spi, buf, count);\n}\n\nstatic int\nmrf24j40_long_regmap_read(void *context, const void *reg, size_t reg_size,\n\t\t\t  void *val, size_t val_size)\n{\n\tstruct spi_device *spi = context;\n\n\treturn spi_write_then_read(spi, reg, reg_size, val, val_size);\n}\n\nstatic const struct regmap_bus mrf24j40_long_regmap_bus = {\n\t.write = mrf24j40_long_regmap_write,\n\t.read = mrf24j40_long_regmap_read,\n\t.reg_format_endian_default = REGMAP_ENDIAN_BIG,\n\t.val_format_endian_default = REGMAP_ENDIAN_BIG,\n};\n\nstatic void write_tx_buf_complete(void *context)\n{\n\tstruct mrf24j40 *devrec = context;\n\t__le16 fc = ieee802154_get_fc_from_skb(devrec->tx_skb);\n\tu8 val = BIT_TXNTRIG;\n\tint ret;\n\n\tif (ieee802154_is_secen(fc))\n\t\tval |= BIT_TXNSECEN;\n\n\tif (ieee802154_is_ackreq(fc))\n\t\tval |= BIT_TXNACKREQ;\n\n\tdevrec->tx_post_msg.complete = NULL;\n\tdevrec->tx_post_buf[0] = MRF24J40_WRITESHORT(REG_TXNCON);\n\tdevrec->tx_post_buf[1] = val;\n\n\tret = spi_async(devrec->spi, &devrec->tx_post_msg);\n\tif (ret)\n\t\tdev_err(printdev(devrec), \"SPI write Failed for transmit buf\\n\");\n}\n\n \nstatic int write_tx_buf(struct mrf24j40 *devrec, u16 reg,\n\t\t\tconst u8 *data, size_t length)\n{\n\tu16 cmd;\n\tint ret;\n\n\t \n\tif (length > TX_FIFO_SIZE-2) {\n\t\tdev_err(printdev(devrec), \"write_tx_buf() was passed too large a buffer. Performing short write.\\n\");\n\t\tlength = TX_FIFO_SIZE-2;\n\t}\n\n\tcmd = MRF24J40_WRITELONG(reg);\n\tdevrec->tx_hdr_buf[0] = cmd >> 8 & 0xff;\n\tdevrec->tx_hdr_buf[1] = cmd & 0xff;\n\tdevrec->tx_len_buf[0] = 0x0;  \n\tdevrec->tx_len_buf[1] = length;  \n\tdevrec->tx_buf_trx.tx_buf = data;\n\tdevrec->tx_buf_trx.len = length;\n\n\tret = spi_async(devrec->spi, &devrec->tx_msg);\n\tif (ret)\n\t\tdev_err(printdev(devrec), \"SPI write Failed for TX buf\\n\");\n\n\treturn ret;\n}\n\nstatic int mrf24j40_tx(struct ieee802154_hw *hw, struct sk_buff *skb)\n{\n\tstruct mrf24j40 *devrec = hw->priv;\n\n\tdev_dbg(printdev(devrec), \"tx packet of %d bytes\\n\", skb->len);\n\tdevrec->tx_skb = skb;\n\n\treturn write_tx_buf(devrec, 0x000, skb->data, skb->len);\n}\n\nstatic int mrf24j40_ed(struct ieee802154_hw *hw, u8 *level)\n{\n\t \n\tpr_warn(\"mrf24j40: ed not implemented\\n\");\n\t*level = 0;\n\treturn 0;\n}\n\nstatic int mrf24j40_start(struct ieee802154_hw *hw)\n{\n\tstruct mrf24j40 *devrec = hw->priv;\n\n\tdev_dbg(printdev(devrec), \"start\\n\");\n\n\t \n\treturn regmap_update_bits(devrec->regmap_short, REG_INTCON,\n\t\t\t\t  BIT_TXNIE | BIT_RXIE | BIT_SECIE, 0);\n}\n\nstatic void mrf24j40_stop(struct ieee802154_hw *hw)\n{\n\tstruct mrf24j40 *devrec = hw->priv;\n\n\tdev_dbg(printdev(devrec), \"stop\\n\");\n\n\t \n\tregmap_update_bits(devrec->regmap_short, REG_INTCON,\n\t\t\t   BIT_TXNIE | BIT_RXIE, BIT_TXNIE | BIT_RXIE);\n}\n\nstatic int mrf24j40_set_channel(struct ieee802154_hw *hw, u8 page, u8 channel)\n{\n\tstruct mrf24j40 *devrec = hw->priv;\n\tu8 val;\n\tint ret;\n\n\tdev_dbg(printdev(devrec), \"Set Channel %d\\n\", channel);\n\n\tWARN_ON(page != 0);\n\tWARN_ON(channel < MRF24J40_CHAN_MIN);\n\tWARN_ON(channel > MRF24J40_CHAN_MAX);\n\n\t \n\tval = (channel - 11) << RFCON0_CH_SHIFT | RFOPT_RECOMMEND;\n\tret = regmap_update_bits(devrec->regmap_long, REG_RFCON0,\n\t\t\t\t RFCON0_CH_MASK, val);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(devrec->regmap_short, REG_RFCTL, BIT_RFRST,\n\t\t\t\t BIT_RFRST);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_update_bits(devrec->regmap_short, REG_RFCTL, BIT_RFRST, 0);\n\tif (!ret)\n\t\tudelay(SET_CHANNEL_DELAY_US);  \n\n\treturn ret;\n}\n\nstatic int mrf24j40_filter(struct ieee802154_hw *hw,\n\t\t\t   struct ieee802154_hw_addr_filt *filt,\n\t\t\t   unsigned long changed)\n{\n\tstruct mrf24j40 *devrec = hw->priv;\n\n\tdev_dbg(printdev(devrec), \"filter\\n\");\n\n\tif (changed & IEEE802154_AFILT_SADDR_CHANGED) {\n\t\t \n\t\tu8 addrh, addrl;\n\n\t\taddrh = le16_to_cpu(filt->short_addr) >> 8 & 0xff;\n\t\taddrl = le16_to_cpu(filt->short_addr) & 0xff;\n\n\t\tregmap_write(devrec->regmap_short, REG_SADRH, addrh);\n\t\tregmap_write(devrec->regmap_short, REG_SADRL, addrl);\n\t\tdev_dbg(printdev(devrec),\n\t\t\t\"Set short addr to %04hx\\n\", filt->short_addr);\n\t}\n\n\tif (changed & IEEE802154_AFILT_IEEEADDR_CHANGED) {\n\t\t \n\t\tu8 i, addr[8];\n\n\t\tmemcpy(addr, &filt->ieee_addr, 8);\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tregmap_write(devrec->regmap_short, REG_EADR0 + i,\n\t\t\t\t     addr[i]);\n\n#ifdef DEBUG\n\t\tpr_debug(\"Set long addr to: \");\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tpr_debug(\"%02hhx \", addr[7 - i]);\n\t\tpr_debug(\"\\n\");\n#endif\n\t}\n\n\tif (changed & IEEE802154_AFILT_PANID_CHANGED) {\n\t\t \n\t\tu8 panidl, panidh;\n\n\t\tpanidh = le16_to_cpu(filt->pan_id) >> 8 & 0xff;\n\t\tpanidl = le16_to_cpu(filt->pan_id) & 0xff;\n\t\tregmap_write(devrec->regmap_short, REG_PANIDH, panidh);\n\t\tregmap_write(devrec->regmap_short, REG_PANIDL, panidl);\n\n\t\tdev_dbg(printdev(devrec), \"Set PANID to %04hx\\n\", filt->pan_id);\n\t}\n\n\tif (changed & IEEE802154_AFILT_PANC_CHANGED) {\n\t\t \n\t\tu8 val;\n\t\tint ret;\n\n\t\tif (filt->pan_coord)\n\t\t\tval = BIT_PANCOORD;\n\t\telse\n\t\t\tval = 0;\n\t\tret = regmap_update_bits(devrec->regmap_short, REG_RXMCR,\n\t\t\t\t\t BIT_PANCOORD, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\n\t\tdev_dbg(printdev(devrec), \"Set Pan Coord to %s\\n\",\n\t\t\tfilt->pan_coord ? \"on\" : \"off\");\n\t}\n\n\treturn 0;\n}\n\nstatic void mrf24j40_handle_rx_read_buf_unlock(struct mrf24j40 *devrec)\n{\n\tint ret;\n\n\t \n\tdevrec->rx_msg.complete = NULL;\n\tdevrec->rx_buf[0] = MRF24J40_WRITESHORT(REG_BBREG1);\n\tdevrec->rx_buf[1] = 0x00;  \n\tret = spi_async(devrec->spi, &devrec->rx_msg);\n\tif (ret)\n\t\tdev_err(printdev(devrec), \"failed to unlock rx buffer\\n\");\n}\n\nstatic void mrf24j40_handle_rx_read_buf_complete(void *context)\n{\n\tstruct mrf24j40 *devrec = context;\n\tu8 len = devrec->rx_buf[2];\n\tu8 rx_local_buf[RX_FIFO_SIZE];\n\tstruct sk_buff *skb;\n\n\tmemcpy(rx_local_buf, devrec->rx_fifo_buf, len);\n\tmrf24j40_handle_rx_read_buf_unlock(devrec);\n\n\tskb = dev_alloc_skb(IEEE802154_MTU);\n\tif (!skb) {\n\t\tdev_err(printdev(devrec), \"failed to allocate skb\\n\");\n\t\treturn;\n\t}\n\n\tskb_put_data(skb, rx_local_buf, len);\n\tieee802154_rx_irqsafe(devrec->hw, skb, 0);\n\n#ifdef DEBUG\n\t print_hex_dump(KERN_DEBUG, \"mrf24j40 rx: \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\trx_local_buf, len, 0);\n\t pr_debug(\"mrf24j40 rx: lqi: %02hhx rssi: %02hhx\\n\",\n\t\t  devrec->rx_lqi_buf[0], devrec->rx_lqi_buf[1]);\n#endif\n}\n\nstatic void mrf24j40_handle_rx_read_buf(void *context)\n{\n\tstruct mrf24j40 *devrec = context;\n\tu16 cmd;\n\tint ret;\n\n\t \n\tif (!ieee802154_is_valid_psdu_len(devrec->rx_buf[2]))\n\t\tdevrec->rx_buf[2] = IEEE802154_MTU;\n\n\tcmd = MRF24J40_READLONG(REG_RX_FIFO + 1);\n\tdevrec->rx_addr_buf[0] = cmd >> 8 & 0xff;\n\tdevrec->rx_addr_buf[1] = cmd & 0xff;\n\tdevrec->rx_fifo_buf_trx.len = devrec->rx_buf[2];\n\tret = spi_async(devrec->spi, &devrec->rx_buf_msg);\n\tif (ret) {\n\t\tdev_err(printdev(devrec), \"failed to read rx buffer\\n\");\n\t\tmrf24j40_handle_rx_read_buf_unlock(devrec);\n\t}\n}\n\nstatic void mrf24j40_handle_rx_read_len(void *context)\n{\n\tstruct mrf24j40 *devrec = context;\n\tu16 cmd;\n\tint ret;\n\n\t \n\tdevrec->rx_msg.complete = mrf24j40_handle_rx_read_buf;\n\tdevrec->rx_trx.len = 3;\n\tcmd = MRF24J40_READLONG(REG_RX_FIFO);\n\tdevrec->rx_buf[0] = cmd >> 8 & 0xff;\n\tdevrec->rx_buf[1] = cmd & 0xff;\n\n\tret = spi_async(devrec->spi, &devrec->rx_msg);\n\tif (ret) {\n\t\tdev_err(printdev(devrec), \"failed to read rx buffer length\\n\");\n\t\tmrf24j40_handle_rx_read_buf_unlock(devrec);\n\t}\n}\n\nstatic int mrf24j40_handle_rx(struct mrf24j40 *devrec)\n{\n\t \n\tdevrec->rx_msg.complete = mrf24j40_handle_rx_read_len;\n\tdevrec->rx_trx.len = 2;\n\tdevrec->rx_buf[0] = MRF24J40_WRITESHORT(REG_BBREG1);\n\tdevrec->rx_buf[1] = BIT_RXDECINV;  \n\n\treturn spi_async(devrec->spi, &devrec->rx_msg);\n}\n\nstatic int\nmrf24j40_csma_params(struct ieee802154_hw *hw, u8 min_be, u8 max_be,\n\t\t     u8 retries)\n{\n\tstruct mrf24j40 *devrec = hw->priv;\n\tu8 val;\n\n\t \n\tval = min_be << TXMCR_MIN_BE_SHIFT;\n\t \n\tval |= retries << TXMCR_CSMA_RETRIES_SHIFT;\n\n\treturn regmap_update_bits(devrec->regmap_short, REG_TXMCR,\n\t\t\t\t  TXMCR_MIN_BE_MASK | TXMCR_CSMA_RETRIES_MASK,\n\t\t\t\t  val);\n}\n\nstatic int mrf24j40_set_cca_mode(struct ieee802154_hw *hw,\n\t\t\t\t const struct wpan_phy_cca *cca)\n{\n\tstruct mrf24j40 *devrec = hw->priv;\n\tu8 val;\n\n\t \n\tswitch (cca->mode) {\n\tcase NL802154_CCA_ENERGY:\n\t\tval = 2;\n\t\tbreak;\n\tcase NL802154_CCA_CARRIER:\n\t\tval = 1;\n\t\tbreak;\n\tcase NL802154_CCA_ENERGY_CARRIER:\n\t\tswitch (cca->opt) {\n\t\tcase NL802154_CCA_OPT_ENERGY_CARRIER_AND:\n\t\t\tval = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(devrec->regmap_short, REG_BBREG2,\n\t\t\t\t  BBREG2_CCA_MODE_MASK,\n\t\t\t\t  val << BBREG2_CCA_MODE_SHIFT);\n}\n\n \nstatic const s32 mrf24j40_ed_levels[] = {\n\t-9000, -8900, -8800, -8700, -8600, -8500, -8400, -8300, -8200, -8100,\n\t-8000, -7900, -7800, -7700, -7600, -7500, -7400, -7300, -7200, -7100,\n\t-7000, -6900, -6800, -6700, -6600, -6500, -6400, -6300, -6200, -6100,\n\t-6000, -5900, -5800, -5700, -5600, -5500, -5400, -5300, -5200, -5100,\n\t-5000, -4900, -4800, -4700, -4600, -4500, -4400, -4300, -4200, -4100,\n\t-4000, -3900, -3800, -3700, -3600, -3500\n};\n\n \nstatic const s32 mrf24j40_ed_levels_map[][2] = {\n\t{ -9000, 0 }, { -8900, 1 }, { -8800, 2 }, { -8700, 5 }, { -8600, 9 },\n\t{ -8500, 13 }, { -8400, 18 }, { -8300, 23 }, { -8200, 27 },\n\t{ -8100, 32 }, { -8000, 37 }, { -7900, 43 }, { -7800, 48 },\n\t{ -7700, 53 }, { -7600, 58 }, { -7500, 63 }, { -7400, 68 },\n\t{ -7300, 73 }, { -7200, 78 }, { -7100, 83 }, { -7000, 89 },\n\t{ -6900, 95 }, { -6800, 100 }, { -6700, 107 }, { -6600, 111 },\n\t{ -6500, 117 }, { -6400, 121 }, { -6300, 125 }, { -6200, 129 },\n\t{ -6100, 133 },\t{ -6000, 138 }, { -5900, 143 }, { -5800, 148 },\n\t{ -5700, 153 }, { -5600, 159 },\t{ -5500, 165 }, { -5400, 170 },\n\t{ -5300, 176 }, { -5200, 183 }, { -5100, 188 }, { -5000, 193 },\n\t{ -4900, 198 }, { -4800, 203 }, { -4700, 207 }, { -4600, 212 },\n\t{ -4500, 216 }, { -4400, 221 }, { -4300, 225 }, { -4200, 228 },\n\t{ -4100, 233 }, { -4000, 239 }, { -3900, 245 }, { -3800, 250 },\n\t{ -3700, 253 }, { -3600, 254 }, { -3500, 255 },\n};\n\nstatic int mrf24j40_set_cca_ed_level(struct ieee802154_hw *hw, s32 mbm)\n{\n\tstruct mrf24j40 *devrec = hw->priv;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mrf24j40_ed_levels_map); i++) {\n\t\tif (mrf24j40_ed_levels_map[i][0] == mbm)\n\t\t\treturn regmap_write(devrec->regmap_short, REG_CCAEDTH,\n\t\t\t\t\t    mrf24j40_ed_levels_map[i][1]);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const s32 mrf24j40ma_powers[] = {\n\t0, -50, -120, -190, -280, -370, -490, -630, -1000, -1050, -1120, -1190,\n\t-1280, -1370, -1490, -1630, -2000, -2050, -2120, -2190, -2280, -2370,\n\t-2490, -2630, -3000, -3050, -3120, -3190, -3280, -3370, -3490, -3630,\n};\n\nstatic int mrf24j40_set_txpower(struct ieee802154_hw *hw, s32 mbm)\n{\n\tstruct mrf24j40 *devrec = hw->priv;\n\ts32 small_scale;\n\tu8 val;\n\n\tif (0 >= mbm && mbm > -1000) {\n\t\tval = TXPWRL_0 << TXPWRL_SHIFT;\n\t\tsmall_scale = mbm;\n\t} else if (-1000 >= mbm && mbm > -2000) {\n\t\tval = TXPWRL_10 << TXPWRL_SHIFT;\n\t\tsmall_scale = mbm + 1000;\n\t} else if (-2000 >= mbm && mbm > -3000) {\n\t\tval = TXPWRL_20 << TXPWRL_SHIFT;\n\t\tsmall_scale = mbm + 2000;\n\t} else if (-3000 >= mbm && mbm > -4000) {\n\t\tval = TXPWRL_30 << TXPWRL_SHIFT;\n\t\tsmall_scale = mbm + 3000;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (small_scale) {\n\tcase 0:\n\t\tval |= (TXPWRS_0 << TXPWRS_SHIFT);\n\t\tbreak;\n\tcase -50:\n\t\tval |= (TXPWRS_0_5 << TXPWRS_SHIFT);\n\t\tbreak;\n\tcase -120:\n\t\tval |= (TXPWRS_1_2 << TXPWRS_SHIFT);\n\t\tbreak;\n\tcase -190:\n\t\tval |= (TXPWRS_1_9 << TXPWRS_SHIFT);\n\t\tbreak;\n\tcase -280:\n\t\tval |= (TXPWRS_2_8 << TXPWRS_SHIFT);\n\t\tbreak;\n\tcase -370:\n\t\tval |= (TXPWRS_3_7 << TXPWRS_SHIFT);\n\t\tbreak;\n\tcase -490:\n\t\tval |= (TXPWRS_4_9 << TXPWRS_SHIFT);\n\t\tbreak;\n\tcase -630:\n\t\tval |= (TXPWRS_6_3 << TXPWRS_SHIFT);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_update_bits(devrec->regmap_long, REG_RFCON3,\n\t\t\t\t  TXPWRL_MASK | TXPWRS_MASK, val);\n}\n\nstatic int mrf24j40_set_promiscuous_mode(struct ieee802154_hw *hw, bool on)\n{\n\tstruct mrf24j40 *devrec = hw->priv;\n\tint ret;\n\n\tif (on) {\n\t\t \n\t\tret = regmap_update_bits(devrec->regmap_short, REG_RXMCR,\n\t\t\t\t\t BIT_PROMI | BIT_ERRPKT | BIT_NOACKRSP,\n\t\t\t\t\t BIT_PROMI | BIT_ERRPKT | BIT_NOACKRSP);\n\t} else {\n\t\t \n\t\tret = regmap_update_bits(devrec->regmap_short, REG_RXMCR,\n\t\t\t\t\t BIT_PROMI | BIT_ERRPKT | BIT_NOACKRSP,\n\t\t\t\t\t 0);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct ieee802154_ops mrf24j40_ops = {\n\t.owner = THIS_MODULE,\n\t.xmit_async = mrf24j40_tx,\n\t.ed = mrf24j40_ed,\n\t.start = mrf24j40_start,\n\t.stop = mrf24j40_stop,\n\t.set_channel = mrf24j40_set_channel,\n\t.set_hw_addr_filt = mrf24j40_filter,\n\t.set_csma_params = mrf24j40_csma_params,\n\t.set_cca_mode = mrf24j40_set_cca_mode,\n\t.set_cca_ed_level = mrf24j40_set_cca_ed_level,\n\t.set_txpower = mrf24j40_set_txpower,\n\t.set_promiscuous_mode = mrf24j40_set_promiscuous_mode,\n};\n\nstatic void mrf24j40_intstat_complete(void *context)\n{\n\tstruct mrf24j40 *devrec = context;\n\tu8 intstat = devrec->irq_buf[1];\n\n\tenable_irq(devrec->spi->irq);\n\n\t \n\tif (intstat & BIT_SECIF)\n\t\tregmap_write_async(devrec->regmap_short, REG_SECCON0,\n\t\t\t\t   BIT_SECIGNORE);\n\n\t \n\tif (intstat & BIT_TXNIF)\n\t\tieee802154_xmit_complete(devrec->hw, devrec->tx_skb, false);\n\n\t \n\tif (intstat & BIT_RXIF)\n\t\tmrf24j40_handle_rx(devrec);\n}\n\nstatic irqreturn_t mrf24j40_isr(int irq, void *data)\n{\n\tstruct mrf24j40 *devrec = data;\n\tint ret;\n\n\tdisable_irq_nosync(irq);\n\n\tdevrec->irq_buf[0] = MRF24J40_READSHORT(REG_INTSTAT);\n\tdevrec->irq_buf[1] = 0;\n\n\t \n\tret = spi_async(devrec->spi, &devrec->irq_msg);\n\tif (ret) {\n\t\tenable_irq(irq);\n\t\treturn IRQ_NONE;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int mrf24j40_hw_init(struct mrf24j40 *devrec)\n{\n\tu32 irq_type;\n\tint ret;\n\n\t \n\tret = regmap_write(devrec->regmap_short, REG_SOFTRST, 0x07);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tret = regmap_write(devrec->regmap_short, REG_PACON2, 0x98);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tret = regmap_write(devrec->regmap_short, REG_TXSTBL, 0x95);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tret = regmap_write(devrec->regmap_long, REG_RFCON0, 0x03);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tret = regmap_write(devrec->regmap_long, REG_RFCON1, 0x01);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tret = regmap_write(devrec->regmap_long, REG_RFCON2, 0x80);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tret = regmap_write(devrec->regmap_long, REG_RFCON6, 0x90);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tret = regmap_write(devrec->regmap_long, REG_RFCON7, 0x80);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tret = regmap_write(devrec->regmap_long, REG_RFCON8, 0x10);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tret = regmap_write(devrec->regmap_long, REG_SLPCON1, 0x21);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tret = regmap_write(devrec->regmap_short, REG_BBREG2, 0x80);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tret = regmap_write(devrec->regmap_short, REG_CCAEDTH, 0x60);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tret = regmap_write(devrec->regmap_short, REG_BBREG6, 0x40);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tret = regmap_write(devrec->regmap_short, REG_RFCTL, 0x04);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tret = regmap_write(devrec->regmap_short, REG_RFCTL, 0x0);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tudelay(192);\n\n\t \n\tret = regmap_update_bits(devrec->regmap_short, REG_RXMCR, 0x03, 0x00);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tif (spi_get_device_id(devrec->spi)->driver_data == MRF24J40MC) {\n\t\t \n\t\tregmap_update_bits(devrec->regmap_long, REG_TESTMODE, 0x07,\n\t\t\t\t   0x07);\n\n\t\t \n\t\tregmap_update_bits(devrec->regmap_short, REG_TRISGPIO, 0x08,\n\t\t\t\t   0x08);\n\n\t\t \n\t\tregmap_update_bits(devrec->regmap_short, REG_GPIO, 0x08, 0x08);\n\n\t\t \n\t\tregmap_write(devrec->regmap_long, REG_RFCON3, 0x28);\n\t}\n\n\tirq_type = irq_get_trigger_type(devrec->spi->irq);\n\tif (irq_type == IRQ_TYPE_EDGE_RISING ||\n\t    irq_type == IRQ_TYPE_EDGE_FALLING)\n\t\tdev_warn(&devrec->spi->dev,\n\t\t\t \"Using edge triggered irq's are not recommended, because it can cause races and result in a non-functional driver!\\n\");\n\tswitch (irq_type) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\t \n\t\tret = regmap_update_bits(devrec->regmap_long, REG_SLPCON0,\n\t\t\t\t\t BIT_INTEDGE, BIT_INTEDGE);\n\t\tif (ret)\n\t\t\tgoto err_ret;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn 0;\n\nerr_ret:\n\treturn ret;\n}\n\nstatic void\nmrf24j40_setup_tx_spi_messages(struct mrf24j40 *devrec)\n{\n\tspi_message_init(&devrec->tx_msg);\n\tdevrec->tx_msg.context = devrec;\n\tdevrec->tx_msg.complete = write_tx_buf_complete;\n\tdevrec->tx_hdr_trx.len = 2;\n\tdevrec->tx_hdr_trx.tx_buf = devrec->tx_hdr_buf;\n\tspi_message_add_tail(&devrec->tx_hdr_trx, &devrec->tx_msg);\n\tdevrec->tx_len_trx.len = 2;\n\tdevrec->tx_len_trx.tx_buf = devrec->tx_len_buf;\n\tspi_message_add_tail(&devrec->tx_len_trx, &devrec->tx_msg);\n\tspi_message_add_tail(&devrec->tx_buf_trx, &devrec->tx_msg);\n\n\tspi_message_init(&devrec->tx_post_msg);\n\tdevrec->tx_post_msg.context = devrec;\n\tdevrec->tx_post_trx.len = 2;\n\tdevrec->tx_post_trx.tx_buf = devrec->tx_post_buf;\n\tspi_message_add_tail(&devrec->tx_post_trx, &devrec->tx_post_msg);\n}\n\nstatic void\nmrf24j40_setup_rx_spi_messages(struct mrf24j40 *devrec)\n{\n\tspi_message_init(&devrec->rx_msg);\n\tdevrec->rx_msg.context = devrec;\n\tdevrec->rx_trx.len = 2;\n\tdevrec->rx_trx.tx_buf = devrec->rx_buf;\n\tdevrec->rx_trx.rx_buf = devrec->rx_buf;\n\tspi_message_add_tail(&devrec->rx_trx, &devrec->rx_msg);\n\n\tspi_message_init(&devrec->rx_buf_msg);\n\tdevrec->rx_buf_msg.context = devrec;\n\tdevrec->rx_buf_msg.complete = mrf24j40_handle_rx_read_buf_complete;\n\tdevrec->rx_addr_trx.len = 2;\n\tdevrec->rx_addr_trx.tx_buf = devrec->rx_addr_buf;\n\tspi_message_add_tail(&devrec->rx_addr_trx, &devrec->rx_buf_msg);\n\tdevrec->rx_fifo_buf_trx.rx_buf = devrec->rx_fifo_buf;\n\tspi_message_add_tail(&devrec->rx_fifo_buf_trx, &devrec->rx_buf_msg);\n\tdevrec->rx_lqi_trx.len = 2;\n\tdevrec->rx_lqi_trx.rx_buf = devrec->rx_lqi_buf;\n\tspi_message_add_tail(&devrec->rx_lqi_trx, &devrec->rx_buf_msg);\n}\n\nstatic void\nmrf24j40_setup_irq_spi_messages(struct mrf24j40 *devrec)\n{\n\tspi_message_init(&devrec->irq_msg);\n\tdevrec->irq_msg.context = devrec;\n\tdevrec->irq_msg.complete = mrf24j40_intstat_complete;\n\tdevrec->irq_trx.len = 2;\n\tdevrec->irq_trx.tx_buf = devrec->irq_buf;\n\tdevrec->irq_trx.rx_buf = devrec->irq_buf;\n\tspi_message_add_tail(&devrec->irq_trx, &devrec->irq_msg);\n}\n\nstatic void  mrf24j40_phy_setup(struct mrf24j40 *devrec)\n{\n\tieee802154_random_extended_addr(&devrec->hw->phy->perm_extended_addr);\n\tdevrec->hw->phy->current_channel = 11;\n\n\t \n\tdevrec->hw->phy->supported.max_minbe = 3;\n\t \n\tdevrec->hw->phy->supported.min_maxbe = 5;\n\tdevrec->hw->phy->supported.max_maxbe = 5;\n\n\tdevrec->hw->phy->cca.mode = NL802154_CCA_CARRIER;\n\tdevrec->hw->phy->supported.cca_modes = BIT(NL802154_CCA_ENERGY) |\n\t\t\t\t\t       BIT(NL802154_CCA_CARRIER) |\n\t\t\t\t\t       BIT(NL802154_CCA_ENERGY_CARRIER);\n\tdevrec->hw->phy->supported.cca_opts = BIT(NL802154_CCA_OPT_ENERGY_CARRIER_AND);\n\n\tdevrec->hw->phy->cca_ed_level = -6900;\n\tdevrec->hw->phy->supported.cca_ed_levels = mrf24j40_ed_levels;\n\tdevrec->hw->phy->supported.cca_ed_levels_size = ARRAY_SIZE(mrf24j40_ed_levels);\n\n\tswitch (spi_get_device_id(devrec->spi)->driver_data) {\n\tcase MRF24J40:\n\tcase MRF24J40MA:\n\t\tdevrec->hw->phy->supported.tx_powers = mrf24j40ma_powers;\n\t\tdevrec->hw->phy->supported.tx_powers_size = ARRAY_SIZE(mrf24j40ma_powers);\n\t\tdevrec->hw->phy->flags |= WPAN_PHY_FLAG_TXPOWER;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int mrf24j40_probe(struct spi_device *spi)\n{\n\tint ret = -ENOMEM, irq_type;\n\tstruct ieee802154_hw *hw;\n\tstruct mrf24j40 *devrec;\n\n\tdev_info(&spi->dev, \"probe(). IRQ: %d\\n\", spi->irq);\n\n\t \n\n\thw = ieee802154_alloc_hw(sizeof(*devrec), &mrf24j40_ops);\n\tif (!hw)\n\t\tgoto err_ret;\n\n\tdevrec = hw->priv;\n\tdevrec->spi = spi;\n\tspi_set_drvdata(spi, devrec);\n\tdevrec->hw = hw;\n\tdevrec->hw->parent = &spi->dev;\n\tdevrec->hw->phy->supported.channels[0] = CHANNEL_MASK;\n\tdevrec->hw->flags = IEEE802154_HW_TX_OMIT_CKSUM | IEEE802154_HW_AFILT |\n\t\t\t    IEEE802154_HW_CSMA_PARAMS |\n\t\t\t    IEEE802154_HW_PROMISCUOUS;\n\n\tdevrec->hw->phy->flags = WPAN_PHY_FLAG_CCA_MODE |\n\t\t\t\t WPAN_PHY_FLAG_CCA_ED_LEVEL;\n\n\tmrf24j40_setup_tx_spi_messages(devrec);\n\tmrf24j40_setup_rx_spi_messages(devrec);\n\tmrf24j40_setup_irq_spi_messages(devrec);\n\n\tdevrec->regmap_short = devm_regmap_init_spi(spi,\n\t\t\t\t\t\t    &mrf24j40_short_regmap);\n\tif (IS_ERR(devrec->regmap_short)) {\n\t\tret = PTR_ERR(devrec->regmap_short);\n\t\tdev_err(&spi->dev, \"Failed to allocate short register map: %d\\n\",\n\t\t\tret);\n\t\tgoto err_register_device;\n\t}\n\n\tdevrec->regmap_long = devm_regmap_init(&spi->dev,\n\t\t\t\t\t       &mrf24j40_long_regmap_bus,\n\t\t\t\t\t       spi, &mrf24j40_long_regmap);\n\tif (IS_ERR(devrec->regmap_long)) {\n\t\tret = PTR_ERR(devrec->regmap_long);\n\t\tdev_err(&spi->dev, \"Failed to allocate long register map: %d\\n\",\n\t\t\tret);\n\t\tgoto err_register_device;\n\t}\n\n\tif (spi->max_speed_hz > MAX_SPI_SPEED_HZ) {\n\t\tdev_warn(&spi->dev, \"spi clock above possible maximum: %d\",\n\t\t\t MAX_SPI_SPEED_HZ);\n\t\tret = -EINVAL;\n\t\tgoto err_register_device;\n\t}\n\n\tret = mrf24j40_hw_init(devrec);\n\tif (ret)\n\t\tgoto err_register_device;\n\n\tmrf24j40_phy_setup(devrec);\n\n\t \n\tirq_type = irq_get_trigger_type(spi->irq);\n\tif (!irq_type)\n\t\tirq_type = IRQF_TRIGGER_LOW;\n\n\tret = devm_request_irq(&spi->dev, spi->irq, mrf24j40_isr,\n\t\t\t       irq_type, dev_name(&spi->dev), devrec);\n\tif (ret) {\n\t\tdev_err(printdev(devrec), \"Unable to get IRQ\");\n\t\tgoto err_register_device;\n\t}\n\n\tdev_dbg(printdev(devrec), \"registered mrf24j40\\n\");\n\tret = ieee802154_register_hw(devrec->hw);\n\tif (ret)\n\t\tgoto err_register_device;\n\n\treturn 0;\n\nerr_register_device:\n\tieee802154_free_hw(devrec->hw);\nerr_ret:\n\treturn ret;\n}\n\nstatic void mrf24j40_remove(struct spi_device *spi)\n{\n\tstruct mrf24j40 *devrec = spi_get_drvdata(spi);\n\n\tdev_dbg(printdev(devrec), \"remove\\n\");\n\n\tieee802154_unregister_hw(devrec->hw);\n\tieee802154_free_hw(devrec->hw);\n\t \n}\n\nstatic const struct of_device_id mrf24j40_of_match[] = {\n\t{ .compatible = \"microchip,mrf24j40\", .data = (void *)MRF24J40 },\n\t{ .compatible = \"microchip,mrf24j40ma\", .data = (void *)MRF24J40MA },\n\t{ .compatible = \"microchip,mrf24j40mc\", .data = (void *)MRF24J40MC },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, mrf24j40_of_match);\n\nstatic const struct spi_device_id mrf24j40_ids[] = {\n\t{ \"mrf24j40\", MRF24J40 },\n\t{ \"mrf24j40ma\", MRF24J40MA },\n\t{ \"mrf24j40mc\", MRF24J40MC },\n\t{ },\n};\nMODULE_DEVICE_TABLE(spi, mrf24j40_ids);\n\nstatic struct spi_driver mrf24j40_driver = {\n\t.driver = {\n\t\t.of_match_table = mrf24j40_of_match,\n\t\t.name = \"mrf24j40\",\n\t},\n\t.id_table = mrf24j40_ids,\n\t.probe = mrf24j40_probe,\n\t.remove = mrf24j40_remove,\n};\n\nmodule_spi_driver(mrf24j40_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Alan Ott\");\nMODULE_DESCRIPTION(\"MRF24J40 SPI 802.15.4 Controller Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}