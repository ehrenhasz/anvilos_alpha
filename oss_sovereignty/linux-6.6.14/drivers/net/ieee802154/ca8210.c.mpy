{
  "module_name": "ca8210.c",
  "hash_id": "a0078329da97a07a21c725e65b4d20a78acb39ea9aac5052af86a8c840155679",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ieee802154/ca8210.c",
  "human_readable_source": " \n\n#include <linux/cdev.h>\n#include <linux/clk-provider.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio.h>\n#include <linux/ieee802154.h>\n#include <linux/io.h>\n#include <linux/kfifo.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/poll.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/spi/spi.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/workqueue.h>\n#include <linux/interrupt.h>\n\n#include <net/ieee802154_netdev.h>\n#include <net/mac802154.h>\n\n#define DRIVER_NAME \"ca8210\"\n\n \n#define ONE_MHZ      1000000\n#define TWO_MHZ      (2 * ONE_MHZ)\n#define FOUR_MHZ     (4 * ONE_MHZ)\n#define EIGHT_MHZ    (8 * ONE_MHZ)\n#define SIXTEEN_MHZ  (16 * ONE_MHZ)\n\n \n#define CA8210_SPI_BUF_SIZE 256\n#define CA8210_SYNC_TIMEOUT 1000      \n\n \n#define CA8210_TEST_INT_FILE_NAME \"ca8210_test\"\n#define CA8210_TEST_INT_FIFO_SIZE 256\n\n \n#define HWME_EDTHRESHOLD       (0x04)\n#define HWME_EDVALUE           (0x06)\n#define HWME_SYSCLKOUT         (0x0F)\n#define HWME_LQILIMIT          (0x11)\n\n \n#define TDME_CHANNEL          (0x00)\n#define TDME_ATM_CONFIG       (0x06)\n\n#define MAX_HWME_ATTRIBUTE_SIZE  16\n#define MAX_TDME_ATTRIBUTE_SIZE  2\n\n \n#define PHY_CURRENT_CHANNEL               (0x00)\n#define PHY_TRANSMIT_POWER                (0x02)\n#define PHY_CCA_MODE                      (0x03)\n#define MAC_ASSOCIATION_PERMIT            (0x41)\n#define MAC_AUTO_REQUEST                  (0x42)\n#define MAC_BATT_LIFE_EXT                 (0x43)\n#define MAC_BATT_LIFE_EXT_PERIODS         (0x44)\n#define MAC_BEACON_PAYLOAD                (0x45)\n#define MAC_BEACON_PAYLOAD_LENGTH         (0x46)\n#define MAC_BEACON_ORDER                  (0x47)\n#define MAC_GTS_PERMIT                    (0x4d)\n#define MAC_MAX_CSMA_BACKOFFS             (0x4e)\n#define MAC_MIN_BE                        (0x4f)\n#define MAC_PAN_ID                        (0x50)\n#define MAC_PROMISCUOUS_MODE              (0x51)\n#define MAC_RX_ON_WHEN_IDLE               (0x52)\n#define MAC_SHORT_ADDRESS                 (0x53)\n#define MAC_SUPERFRAME_ORDER              (0x54)\n#define MAC_ASSOCIATED_PAN_COORD          (0x56)\n#define MAC_MAX_BE                        (0x57)\n#define MAC_MAX_FRAME_RETRIES             (0x59)\n#define MAC_RESPONSE_WAIT_TIME            (0x5A)\n#define MAC_SECURITY_ENABLED              (0x5D)\n\n#define MAC_AUTO_REQUEST_SECURITY_LEVEL   (0x78)\n#define MAC_AUTO_REQUEST_KEY_ID_MODE      (0x79)\n\n#define NS_IEEE_ADDRESS                   (0xFF)  \n\n \n#define MAC_MODE_NO_ADDR                (0x00)\n#define MAC_MODE_SHORT_ADDR             (0x02)\n#define MAC_MODE_LONG_ADDR              (0x03)\n\n \n#define MAX_BEACON_OVERHEAD        (75)\n#define MAX_BEACON_PAYLOAD_LENGTH  (IEEE802154_MTU - MAX_BEACON_OVERHEAD)\n\n#define MAX_ATTRIBUTE_SIZE              (122)\n#define MAX_DATA_SIZE                   (114)\n\n#define CA8210_VALID_CHANNELS                 (0x07FFF800)\n\n \n#define CA8210_MAC_WORKAROUNDS (0)\n#define CA8210_MAC_MPW         (0)\n\n \n#define LS_BYTE(x)     ((u8)((x) & 0xFF))\n#define MS_BYTE(x)     ((u8)(((x) >> 8) & 0xFF))\n\n \n \n#define MCPS_DATA_REQUEST                     (0x00)\n#define MLME_ASSOCIATE_REQUEST                (0x02)\n#define MLME_ASSOCIATE_RESPONSE               (0x03)\n#define MLME_DISASSOCIATE_REQUEST             (0x04)\n#define MLME_GET_REQUEST                      (0x05)\n#define MLME_ORPHAN_RESPONSE                  (0x06)\n#define MLME_RESET_REQUEST                    (0x07)\n#define MLME_RX_ENABLE_REQUEST                (0x08)\n#define MLME_SCAN_REQUEST                     (0x09)\n#define MLME_SET_REQUEST                      (0x0A)\n#define MLME_START_REQUEST                    (0x0B)\n#define MLME_POLL_REQUEST                     (0x0D)\n#define HWME_SET_REQUEST                      (0x0E)\n#define HWME_GET_REQUEST                      (0x0F)\n#define TDME_SETSFR_REQUEST                   (0x11)\n#define TDME_GETSFR_REQUEST                   (0x12)\n#define TDME_SET_REQUEST                      (0x14)\n \n#define MCPS_DATA_INDICATION                  (0x00)\n#define MCPS_DATA_CONFIRM                     (0x01)\n#define MLME_RESET_CONFIRM                    (0x0A)\n#define MLME_SET_CONFIRM                      (0x0E)\n#define MLME_START_CONFIRM                    (0x0F)\n#define HWME_SET_CONFIRM                      (0x12)\n#define HWME_GET_CONFIRM                      (0x13)\n#define HWME_WAKEUP_INDICATION\t\t      (0x15)\n#define TDME_SETSFR_CONFIRM                   (0x17)\n\n \n \n#define SPI_S2M                            (0x20)\n \n#define SPI_SYN                            (0x40)\n\n \n#define SPI_IDLE                           (0xFF)\n#define SPI_NACK                           (0xF0)\n\n#define SPI_MCPS_DATA_REQUEST          (MCPS_DATA_REQUEST)\n#define SPI_MCPS_DATA_INDICATION       (MCPS_DATA_INDICATION + SPI_S2M)\n#define SPI_MCPS_DATA_CONFIRM          (MCPS_DATA_CONFIRM + SPI_S2M)\n\n#define SPI_MLME_ASSOCIATE_REQUEST     (MLME_ASSOCIATE_REQUEST)\n#define SPI_MLME_RESET_REQUEST         (MLME_RESET_REQUEST + SPI_SYN)\n#define SPI_MLME_SET_REQUEST           (MLME_SET_REQUEST + SPI_SYN)\n#define SPI_MLME_START_REQUEST         (MLME_START_REQUEST + SPI_SYN)\n#define SPI_MLME_RESET_CONFIRM         (MLME_RESET_CONFIRM + SPI_S2M + SPI_SYN)\n#define SPI_MLME_SET_CONFIRM           (MLME_SET_CONFIRM + SPI_S2M + SPI_SYN)\n#define SPI_MLME_START_CONFIRM         (MLME_START_CONFIRM + SPI_S2M + SPI_SYN)\n\n#define SPI_HWME_SET_REQUEST           (HWME_SET_REQUEST + SPI_SYN)\n#define SPI_HWME_GET_REQUEST           (HWME_GET_REQUEST + SPI_SYN)\n#define SPI_HWME_SET_CONFIRM           (HWME_SET_CONFIRM + SPI_S2M + SPI_SYN)\n#define SPI_HWME_GET_CONFIRM           (HWME_GET_CONFIRM + SPI_S2M + SPI_SYN)\n#define SPI_HWME_WAKEUP_INDICATION     (HWME_WAKEUP_INDICATION + SPI_S2M)\n\n#define SPI_TDME_SETSFR_REQUEST        (TDME_SETSFR_REQUEST + SPI_SYN)\n#define SPI_TDME_SET_REQUEST           (TDME_SET_REQUEST + SPI_SYN)\n#define SPI_TDME_SETSFR_CONFIRM        (TDME_SETSFR_CONFIRM + SPI_S2M + SPI_SYN)\n\n \n \n#define CA8210_SFR_PACFG                   (0xB1)\n#define CA8210_SFR_MACCON                  (0xD8)\n#define CA8210_SFR_PACFGIB                 (0xFE)\n \n#define CA8210_SFR_LOTXCAL                 (0xBF)\n#define CA8210_SFR_PTHRH                   (0xD1)\n#define CA8210_SFR_PRECFG                  (0xD3)\n#define CA8210_SFR_LNAGX40                 (0xE1)\n#define CA8210_SFR_LNAGX41                 (0xE2)\n#define CA8210_SFR_LNAGX42                 (0xE3)\n#define CA8210_SFR_LNAGX43                 (0xE4)\n#define CA8210_SFR_LNAGX44                 (0xE5)\n#define CA8210_SFR_LNAGX45                 (0xE6)\n#define CA8210_SFR_LNAGX46                 (0xE7)\n#define CA8210_SFR_LNAGX47                 (0xE9)\n\n#define PACFGIB_DEFAULT_CURRENT            (0x3F)\n#define PTHRH_DEFAULT_THRESHOLD            (0x5A)\n#define LNAGX40_DEFAULT_GAIN               (0x29)  \n#define LNAGX41_DEFAULT_GAIN               (0x54)  \n#define LNAGX42_DEFAULT_GAIN               (0x6C)  \n#define LNAGX43_DEFAULT_GAIN               (0x7A)  \n#define LNAGX44_DEFAULT_GAIN               (0x84)  \n#define LNAGX45_DEFAULT_GAIN               (0x8B)  \n#define LNAGX46_DEFAULT_GAIN               (0x92)  \n#define LNAGX47_DEFAULT_GAIN               (0x96)  \n\n#define CA8210_IOCTL_HARD_RESET            (0x00)\n\n \n\n \nstruct cas_control {\n\tstruct spi_message msg;\n\tstruct spi_transfer transfer;\n\n\tu8 tx_buf[CA8210_SPI_BUF_SIZE];\n\tu8 tx_in_buf[CA8210_SPI_BUF_SIZE];\n\n\tstruct ca8210_priv *priv;\n};\n\n \nstruct ca8210_test {\n\tstruct dentry *ca8210_dfs_spi_int;\n\tstruct kfifo up_fifo;\n\twait_queue_head_t readq;\n};\n\n \nstruct ca8210_priv {\n\tstruct spi_device *spi;\n\tstruct ieee802154_hw *hw;\n\tbool hw_registered;\n\tspinlock_t lock;\n\tstruct workqueue_struct *mlme_workqueue;\n\tstruct workqueue_struct *irq_workqueue;\n\tstruct sk_buff *tx_skb;\n\tu8 nextmsduhandle;\n\tstruct clk *clk;\n\tint last_dsn;\n\tstruct ca8210_test test;\n\tbool async_tx_pending;\n\tu8 *sync_command_response;\n\tstruct completion ca8210_is_awake;\n\tint sync_down, sync_up;\n\tstruct completion spi_transfer_complete, sync_exchange_complete;\n\tbool promiscuous;\n\tint retries;\n};\n\n \nstruct work_priv_container {\n\tstruct work_struct work;\n\tstruct ca8210_priv *priv;\n};\n\n \nstruct ca8210_platform_data {\n\tbool extclockenable;\n\tunsigned int extclockfreq;\n\tunsigned int extclockgpio;\n\tint gpio_reset;\n\tint gpio_irq;\n\tint irq_id;\n};\n\n \nstruct fulladdr {\n\tu8         mode;\n\tu8         pan_id[2];\n\tu8         address[8];\n};\n\n \nunion macaddr {\n\tu16        short_address;\n\tu8         ieee_address[8];\n};\n\n \nstruct secspec {\n\tu8         security_level;\n\tu8         key_id_mode;\n\tu8         key_source[8];\n\tu8         key_index;\n};\n\n \nstruct mcps_data_request_pset {\n\tu8              src_addr_mode;\n\tstruct fulladdr dst;\n\tu8              msdu_length;\n\tu8              msdu_handle;\n\tu8              tx_options;\n\tu8              msdu[MAX_DATA_SIZE];\n};\n\nstruct mlme_set_request_pset {\n\tu8         pib_attribute;\n\tu8         pib_attribute_index;\n\tu8         pib_attribute_length;\n\tu8         pib_attribute_value[MAX_ATTRIBUTE_SIZE];\n};\n\nstruct hwme_set_request_pset {\n\tu8         hw_attribute;\n\tu8         hw_attribute_length;\n\tu8         hw_attribute_value[MAX_HWME_ATTRIBUTE_SIZE];\n};\n\nstruct hwme_get_request_pset {\n\tu8         hw_attribute;\n};\n\nstruct tdme_setsfr_request_pset {\n\tu8         sfr_page;\n\tu8         sfr_address;\n\tu8         sfr_value;\n};\n\n \nstruct hwme_set_confirm_pset {\n\tu8         status;\n\tu8         hw_attribute;\n};\n\nstruct hwme_get_confirm_pset {\n\tu8         status;\n\tu8         hw_attribute;\n\tu8         hw_attribute_length;\n\tu8         hw_attribute_value[MAX_HWME_ATTRIBUTE_SIZE];\n};\n\nstruct tdme_setsfr_confirm_pset {\n\tu8         status;\n\tu8         sfr_page;\n\tu8         sfr_address;\n};\n\nstruct mac_message {\n\tu8      command_id;\n\tu8      length;\n\tunion {\n\t\tstruct mcps_data_request_pset       data_req;\n\t\tstruct mlme_set_request_pset        set_req;\n\t\tstruct hwme_set_request_pset        hwme_set_req;\n\t\tstruct hwme_get_request_pset        hwme_get_req;\n\t\tstruct tdme_setsfr_request_pset     tdme_set_sfr_req;\n\t\tstruct hwme_set_confirm_pset        hwme_set_cnf;\n\t\tstruct hwme_get_confirm_pset        hwme_get_cnf;\n\t\tstruct tdme_setsfr_confirm_pset     tdme_set_sfr_cnf;\n\t\tu8                                  u8param;\n\t\tu8                                  status;\n\t\tu8                                  payload[148];\n\t} pdata;\n};\n\nunion pa_cfg_sfr {\n\tstruct {\n\t\tu8 bias_current_trim     : 3;\n\t\tu8          : 1;\n\t\tu8 buffer_capacitor_trim : 3;\n\t\tu8 boost                 : 1;\n\t};\n\tu8 paib;\n};\n\nstruct preamble_cfg_sfr {\n\tu8 timeout_symbols      : 3;\n\tu8 acquisition_symbols  : 3;\n\tu8 search_symbols       : 2;\n};\n\nstatic int (*cascoda_api_upstream)(\n\tconst u8 *buf,\n\tsize_t len,\n\tvoid *device_ref\n);\n\n \nstatic int link_to_linux_err(int link_status)\n{\n\tif (link_status < 0) {\n\t\t \n\t\treturn link_status;\n\t}\n\tswitch (link_status) {\n\tcase IEEE802154_SUCCESS:\n\tcase IEEE802154_REALIGNMENT:\n\t\treturn 0;\n\tcase IEEE802154_IMPROPER_KEY_TYPE:\n\t\treturn -EKEYREJECTED;\n\tcase IEEE802154_IMPROPER_SECURITY_LEVEL:\n\tcase IEEE802154_UNSUPPORTED_LEGACY:\n\tcase IEEE802154_DENIED:\n\t\treturn -EACCES;\n\tcase IEEE802154_BEACON_LOST:\n\tcase IEEE802154_NO_ACK:\n\tcase IEEE802154_NO_BEACON:\n\t\treturn -ENETUNREACH;\n\tcase IEEE802154_CHANNEL_ACCESS_FAILURE:\n\tcase IEEE802154_TX_ACTIVE:\n\tcase IEEE802154_SCAN_IN_PROGRESS:\n\t\treturn -EBUSY;\n\tcase IEEE802154_DISABLE_TRX_FAILURE:\n\tcase IEEE802154_OUT_OF_CAP:\n\t\treturn -EAGAIN;\n\tcase IEEE802154_FRAME_TOO_LONG:\n\t\treturn -EMSGSIZE;\n\tcase IEEE802154_INVALID_GTS:\n\tcase IEEE802154_PAST_TIME:\n\t\treturn -EBADSLT;\n\tcase IEEE802154_INVALID_HANDLE:\n\t\treturn -EBADMSG;\n\tcase IEEE802154_INVALID_PARAMETER:\n\tcase IEEE802154_UNSUPPORTED_ATTRIBUTE:\n\tcase IEEE802154_ON_TIME_TOO_LONG:\n\tcase IEEE802154_INVALID_INDEX:\n\t\treturn -EINVAL;\n\tcase IEEE802154_NO_DATA:\n\t\treturn -ENODATA;\n\tcase IEEE802154_NO_SHORT_ADDRESS:\n\t\treturn -EFAULT;\n\tcase IEEE802154_PAN_ID_CONFLICT:\n\t\treturn -EADDRINUSE;\n\tcase IEEE802154_TRANSACTION_EXPIRED:\n\t\treturn -ETIME;\n\tcase IEEE802154_TRANSACTION_OVERFLOW:\n\t\treturn -ENOBUFS;\n\tcase IEEE802154_UNAVAILABLE_KEY:\n\t\treturn -ENOKEY;\n\tcase IEEE802154_INVALID_ADDRESS:\n\t\treturn -ENXIO;\n\tcase IEEE802154_TRACKING_OFF:\n\tcase IEEE802154_SUPERFRAME_OVERLAP:\n\t\treturn -EREMOTEIO;\n\tcase IEEE802154_LIMIT_REACHED:\n\t\treturn -EDQUOT;\n\tcase IEEE802154_READ_ONLY:\n\t\treturn -EROFS;\n\tdefault:\n\t\treturn -EPROTO;\n\t}\n}\n\n \nstatic int ca8210_test_int_driver_write(\n\tconst u8       *buf,\n\tsize_t          len,\n\tvoid           *spi\n)\n{\n\tstruct ca8210_priv *priv = spi_get_drvdata(spi);\n\tstruct ca8210_test *test = &priv->test;\n\tchar *fifo_buffer;\n\tint i;\n\n\tdev_dbg(\n\t\t&priv->spi->dev,\n\t\t\"test_interface: Buffering upstream message:\\n\"\n\t);\n\tfor (i = 0; i < len; i++)\n\t\tdev_dbg(&priv->spi->dev, \"%#03x\\n\", buf[i]);\n\n\tfifo_buffer = kmemdup(buf, len, GFP_KERNEL);\n\tif (!fifo_buffer)\n\t\treturn -ENOMEM;\n\tkfifo_in(&test->up_fifo, &fifo_buffer, 4);\n\twake_up_interruptible(&priv->test.readq);\n\n\treturn 0;\n}\n\n \n\nstatic int ca8210_net_rx(\n\tstruct ieee802154_hw  *hw,\n\tu8                    *command,\n\tsize_t                 len\n);\nstatic u8 mlme_reset_request_sync(\n\tu8       set_default_pib,\n\tvoid    *device_ref\n);\nstatic int ca8210_spi_transfer(\n\tstruct spi_device *spi,\n\tconst u8          *buf,\n\tsize_t             len\n);\n\n \nstatic void ca8210_reset_send(struct spi_device *spi, unsigned int ms)\n{\n\tstruct ca8210_platform_data *pdata = spi->dev.platform_data;\n\tstruct ca8210_priv *priv = spi_get_drvdata(spi);\n\tlong status;\n\n\tgpio_set_value(pdata->gpio_reset, 0);\n\treinit_completion(&priv->ca8210_is_awake);\n\tmsleep(ms);\n\tgpio_set_value(pdata->gpio_reset, 1);\n\tpriv->promiscuous = false;\n\n\t \n\tstatus = wait_for_completion_interruptible_timeout(\n\t\t&priv->ca8210_is_awake,\n\t\tmsecs_to_jiffies(CA8210_SYNC_TIMEOUT)\n\t);\n\tif (status == 0) {\n\t\tdev_crit(\n\t\t\t&spi->dev,\n\t\t\t\"Fatal: No wakeup from ca8210 after reset!\\n\"\n\t\t);\n\t}\n\n\tdev_dbg(&spi->dev, \"Reset the device\\n\");\n}\n\n \nstatic void ca8210_mlme_reset_worker(struct work_struct *work)\n{\n\tstruct work_priv_container *wpc = container_of(\n\t\twork,\n\t\tstruct work_priv_container,\n\t\twork\n\t);\n\tstruct ca8210_priv *priv = wpc->priv;\n\n\tmlme_reset_request_sync(0, priv->spi);\n\tkfree(wpc);\n}\n\n \nstatic void ca8210_rx_done(struct cas_control *cas_ctl)\n{\n\tu8 *buf;\n\tunsigned int len;\n\tstruct work_priv_container *mlme_reset_wpc;\n\tstruct ca8210_priv *priv = cas_ctl->priv;\n\n\tbuf = cas_ctl->tx_in_buf;\n\tlen = buf[1] + 2;\n\tif (len > CA8210_SPI_BUF_SIZE) {\n\t\tdev_crit(\n\t\t\t&priv->spi->dev,\n\t\t\t\"Received packet len (%u) erroneously long\\n\",\n\t\t\tlen\n\t\t);\n\t\tgoto finish;\n\t}\n\n\tif (buf[0] & SPI_SYN) {\n\t\tif (priv->sync_command_response) {\n\t\t\tmemcpy(priv->sync_command_response, buf, len);\n\t\t\tcomplete(&priv->sync_exchange_complete);\n\t\t} else {\n\t\t\tif (cascoda_api_upstream)\n\t\t\t\tcascoda_api_upstream(buf, len, priv->spi);\n\t\t\tpriv->sync_up++;\n\t\t}\n\t} else {\n\t\tif (cascoda_api_upstream)\n\t\t\tcascoda_api_upstream(buf, len, priv->spi);\n\t}\n\n\tca8210_net_rx(priv->hw, buf, len);\n\tif (buf[0] == SPI_MCPS_DATA_CONFIRM) {\n\t\tif (buf[3] == IEEE802154_TRANSACTION_OVERFLOW) {\n\t\t\tdev_info(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Waiting for transaction overflow to stabilise...\\n\");\n\t\t\tmsleep(2000);\n\t\t\tdev_info(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Resetting MAC...\\n\");\n\n\t\t\tmlme_reset_wpc = kmalloc(sizeof(*mlme_reset_wpc),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!mlme_reset_wpc)\n\t\t\t\tgoto finish;\n\t\t\tINIT_WORK(\n\t\t\t\t&mlme_reset_wpc->work,\n\t\t\t\tca8210_mlme_reset_worker\n\t\t\t);\n\t\t\tmlme_reset_wpc->priv = priv;\n\t\t\tqueue_work(priv->mlme_workqueue, &mlme_reset_wpc->work);\n\t\t}\n\t} else if (buf[0] == SPI_HWME_WAKEUP_INDICATION) {\n\t\tdev_notice(\n\t\t\t&priv->spi->dev,\n\t\t\t\"Wakeup indication received, reason:\\n\"\n\t\t);\n\t\tswitch (buf[2]) {\n\t\tcase 0:\n\t\t\tdev_notice(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Transceiver woken up from Power Up / System Reset\\n\"\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tdev_notice(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Watchdog Timer Time-Out\\n\"\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdev_notice(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Transceiver woken up from Power-Off by Sleep Timer Time-Out\\n\");\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdev_notice(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Transceiver woken up from Power-Off by GPIO Activity\\n\"\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdev_notice(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Transceiver woken up from Standby by Sleep Timer Time-Out\\n\"\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tdev_notice(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Transceiver woken up from Standby by GPIO Activity\\n\"\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdev_notice(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"Sleep-Timer Time-Out in Active Mode\\n\"\n\t\t\t);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&priv->spi->dev, \"Wakeup reason unknown\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tcomplete(&priv->ca8210_is_awake);\n\t}\n\nfinish:;\n}\n\nstatic void ca8210_remove(struct spi_device *spi_device);\n\n \nstatic void ca8210_spi_transfer_complete(void *context)\n{\n\tstruct cas_control *cas_ctl = context;\n\tstruct ca8210_priv *priv = cas_ctl->priv;\n\tbool duplex_rx = false;\n\tint i;\n\tu8 retry_buffer[CA8210_SPI_BUF_SIZE];\n\n\tif (\n\t\tcas_ctl->tx_in_buf[0] == SPI_NACK ||\n\t\t(cas_ctl->tx_in_buf[0] == SPI_IDLE &&\n\t\tcas_ctl->tx_in_buf[1] == SPI_NACK)\n\t) {\n\t\t \n\t\tdev_info(&priv->spi->dev, \"ca8210 was busy during attempted write\\n\");\n\t\tif (cas_ctl->tx_buf[0] == SPI_IDLE) {\n\t\t\tdev_warn(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"IRQ servicing NACKd, dropping transfer\\n\"\n\t\t\t);\n\t\t\tkfree(cas_ctl);\n\t\t\treturn;\n\t\t}\n\t\tif (priv->retries > 3) {\n\t\t\tdev_err(&priv->spi->dev, \"too many retries!\\n\");\n\t\t\tkfree(cas_ctl);\n\t\t\tca8210_remove(priv->spi);\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(retry_buffer, cas_ctl->tx_buf, CA8210_SPI_BUF_SIZE);\n\t\tkfree(cas_ctl);\n\t\tca8210_spi_transfer(\n\t\t\tpriv->spi,\n\t\t\tretry_buffer,\n\t\t\tCA8210_SPI_BUF_SIZE\n\t\t);\n\t\tpriv->retries++;\n\t\tdev_info(&priv->spi->dev, \"retried spi write\\n\");\n\t\treturn;\n\t} else if (\n\t\t\tcas_ctl->tx_in_buf[0] != SPI_IDLE &&\n\t\t\tcas_ctl->tx_in_buf[0] != SPI_NACK\n\t\t) {\n\t\tduplex_rx = true;\n\t}\n\n\tif (duplex_rx) {\n\t\tdev_dbg(&priv->spi->dev, \"READ CMD DURING TX\\n\");\n\t\tfor (i = 0; i < cas_ctl->tx_in_buf[1] + 2; i++)\n\t\t\tdev_dbg(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"%#03x\\n\",\n\t\t\t\tcas_ctl->tx_in_buf[i]\n\t\t\t);\n\t\tca8210_rx_done(cas_ctl);\n\t}\n\tcomplete(&priv->spi_transfer_complete);\n\tkfree(cas_ctl);\n\tpriv->retries = 0;\n}\n\n \nstatic int ca8210_spi_transfer(\n\tstruct spi_device  *spi,\n\tconst u8           *buf,\n\tsize_t              len\n)\n{\n\tint i, status = 0;\n\tstruct ca8210_priv *priv;\n\tstruct cas_control *cas_ctl;\n\n\tif (!spi) {\n\t\tpr_crit(\"NULL spi device passed to %s\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = spi_get_drvdata(spi);\n\treinit_completion(&priv->spi_transfer_complete);\n\n\tdev_dbg(&spi->dev, \"%s called\\n\", __func__);\n\n\tcas_ctl = kzalloc(sizeof(*cas_ctl), GFP_ATOMIC);\n\tif (!cas_ctl)\n\t\treturn -ENOMEM;\n\n\tcas_ctl->priv = priv;\n\tmemset(cas_ctl->tx_buf, SPI_IDLE, CA8210_SPI_BUF_SIZE);\n\tmemset(cas_ctl->tx_in_buf, SPI_IDLE, CA8210_SPI_BUF_SIZE);\n\tmemcpy(cas_ctl->tx_buf, buf, len);\n\n\tfor (i = 0; i < len; i++)\n\t\tdev_dbg(&spi->dev, \"%#03x\\n\", cas_ctl->tx_buf[i]);\n\n\tspi_message_init(&cas_ctl->msg);\n\n\tcas_ctl->transfer.tx_nbits = 1;  \n\tcas_ctl->transfer.rx_nbits = 1;  \n\tcas_ctl->transfer.speed_hz = 0;  \n\tcas_ctl->transfer.bits_per_word = 0;  \n\tcas_ctl->transfer.tx_buf = cas_ctl->tx_buf;\n\tcas_ctl->transfer.rx_buf = cas_ctl->tx_in_buf;\n\tcas_ctl->transfer.delay.value = 0;\n\tcas_ctl->transfer.delay.unit = SPI_DELAY_UNIT_USECS;\n\tcas_ctl->transfer.cs_change = 0;\n\tcas_ctl->transfer.len = sizeof(struct mac_message);\n\tcas_ctl->msg.complete = ca8210_spi_transfer_complete;\n\tcas_ctl->msg.context = cas_ctl;\n\n\tspi_message_add_tail(\n\t\t&cas_ctl->transfer,\n\t\t&cas_ctl->msg\n\t);\n\n\tstatus = spi_async(spi, &cas_ctl->msg);\n\tif (status < 0) {\n\t\tdev_crit(\n\t\t\t&spi->dev,\n\t\t\t\"status %d from spi_sync in write\\n\",\n\t\t\tstatus\n\t\t);\n\t}\n\n\treturn status;\n}\n\n \nstatic int ca8210_spi_exchange(\n\tconst u8 *buf,\n\tsize_t len,\n\tu8 *response,\n\tvoid *device_ref\n)\n{\n\tint status = 0;\n\tstruct spi_device *spi = device_ref;\n\tstruct ca8210_priv *priv = spi->dev.driver_data;\n\tlong wait_remaining;\n\n\tif ((buf[0] & SPI_SYN) && response) {  \n\t\treinit_completion(&priv->sync_exchange_complete);\n\t\tpriv->sync_command_response = response;\n\t}\n\n\tdo {\n\t\treinit_completion(&priv->spi_transfer_complete);\n\t\tstatus = ca8210_spi_transfer(priv->spi, buf, len);\n\t\tif (status) {\n\t\t\tdev_warn(\n\t\t\t\t&spi->dev,\n\t\t\t\t\"spi write failed, returned %d\\n\",\n\t\t\t\tstatus\n\t\t\t);\n\t\t\tif (status == -EBUSY)\n\t\t\t\tcontinue;\n\t\t\tif (((buf[0] & SPI_SYN) && response))\n\t\t\t\tcomplete(&priv->sync_exchange_complete);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\twait_remaining = wait_for_completion_interruptible_timeout(\n\t\t\t&priv->spi_transfer_complete,\n\t\t\tmsecs_to_jiffies(1000)\n\t\t);\n\t\tif (wait_remaining == -ERESTARTSYS) {\n\t\t\tstatus = -ERESTARTSYS;\n\t\t} else if (wait_remaining == 0) {\n\t\t\tdev_err(\n\t\t\t\t&spi->dev,\n\t\t\t\t\"SPI downstream transfer timed out!\\n\"\n\t\t\t);\n\t\t\tstatus = -ETIME;\n\t\t\tgoto cleanup;\n\t\t}\n\t} while (status < 0);\n\n\tif (!((buf[0] & SPI_SYN) && response))\n\t\tgoto cleanup;\n\n\twait_remaining = wait_for_completion_interruptible_timeout(\n\t\t&priv->sync_exchange_complete,\n\t\tmsecs_to_jiffies(CA8210_SYNC_TIMEOUT)\n\t);\n\tif (wait_remaining == -ERESTARTSYS) {\n\t\tstatus = -ERESTARTSYS;\n\t} else if (wait_remaining == 0) {\n\t\tdev_err(\n\t\t\t&spi->dev,\n\t\t\t\"Synchronous confirm timeout\\n\"\n\t\t);\n\t\tstatus = -ETIME;\n\t}\n\ncleanup:\n\tpriv->sync_command_response = NULL;\n\treturn status;\n}\n\n \nstatic irqreturn_t ca8210_interrupt_handler(int irq, void *dev_id)\n{\n\tstruct ca8210_priv *priv = dev_id;\n\tint status;\n\n\tdev_dbg(&priv->spi->dev, \"irq: Interrupt occurred\\n\");\n\tdo {\n\t\tstatus = ca8210_spi_transfer(priv->spi, NULL, 0);\n\t\tif (status && (status != -EBUSY)) {\n\t\t\tdev_warn(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"spi read failed, returned %d\\n\",\n\t\t\t\tstatus\n\t\t\t);\n\t\t}\n\t} while (status == -EBUSY);\n\treturn IRQ_HANDLED;\n}\n\nstatic int (*cascoda_api_downstream)(\n\tconst u8 *buf,\n\tsize_t len,\n\tu8 *response,\n\tvoid *device_ref\n) = ca8210_spi_exchange;\n\n \n\n \nstatic u8 tdme_setsfr_request_sync(\n\tu8            sfr_page,\n\tu8            sfr_address,\n\tu8            sfr_value,\n\tvoid         *device_ref\n)\n{\n\tint ret;\n\tstruct mac_message command, response;\n\tstruct spi_device *spi = device_ref;\n\n\tcommand.command_id = SPI_TDME_SETSFR_REQUEST;\n\tcommand.length = 3;\n\tcommand.pdata.tdme_set_sfr_req.sfr_page    = sfr_page;\n\tcommand.pdata.tdme_set_sfr_req.sfr_address = sfr_address;\n\tcommand.pdata.tdme_set_sfr_req.sfr_value   = sfr_value;\n\tresponse.command_id = SPI_IDLE;\n\tret = cascoda_api_downstream(\n\t\t&command.command_id,\n\t\tcommand.length + 2,\n\t\t&response.command_id,\n\t\tdevice_ref\n\t);\n\tif (ret) {\n\t\tdev_crit(&spi->dev, \"cascoda_api_downstream returned %d\", ret);\n\t\treturn IEEE802154_SYSTEM_ERROR;\n\t}\n\n\tif (response.command_id != SPI_TDME_SETSFR_CONFIRM) {\n\t\tdev_crit(\n\t\t\t&spi->dev,\n\t\t\t\"sync response to SPI_TDME_SETSFR_REQUEST was not SPI_TDME_SETSFR_CONFIRM, it was %d\\n\",\n\t\t\tresponse.command_id\n\t\t);\n\t\treturn IEEE802154_SYSTEM_ERROR;\n\t}\n\n\treturn response.pdata.tdme_set_sfr_cnf.status;\n}\n\n \nstatic u8 tdme_chipinit(void *device_ref)\n{\n\tu8 status = IEEE802154_SUCCESS;\n\tu8 sfr_address;\n\tstruct spi_device *spi = device_ref;\n\tstruct preamble_cfg_sfr pre_cfg_value = {\n\t\t.timeout_symbols     = 3,\n\t\t.acquisition_symbols = 3,\n\t\t.search_symbols      = 1,\n\t};\n\t \n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_LNAGX40),\n\t\tLNAGX40_DEFAULT_GAIN, device_ref);\n\tif (status)\n\t\tgoto finish;\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_LNAGX41),\n\t\tLNAGX41_DEFAULT_GAIN, device_ref);\n\tif (status)\n\t\tgoto finish;\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_LNAGX42),\n\t\tLNAGX42_DEFAULT_GAIN, device_ref);\n\tif (status)\n\t\tgoto finish;\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_LNAGX43),\n\t\tLNAGX43_DEFAULT_GAIN, device_ref);\n\tif (status)\n\t\tgoto finish;\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_LNAGX44),\n\t\tLNAGX44_DEFAULT_GAIN, device_ref);\n\tif (status)\n\t\tgoto finish;\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_LNAGX45),\n\t\tLNAGX45_DEFAULT_GAIN, device_ref);\n\tif (status)\n\t\tgoto finish;\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_LNAGX46),\n\t\tLNAGX46_DEFAULT_GAIN, device_ref);\n\tif (status)\n\t\tgoto finish;\n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_LNAGX47),\n\t\tLNAGX47_DEFAULT_GAIN, device_ref);\n\tif (status)\n\t\tgoto finish;\n\t \n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_PRECFG),\n\t\t*((u8 *)&pre_cfg_value), device_ref);\n\tif (status)\n\t\tgoto finish;\n\t \n\tstatus = tdme_setsfr_request_sync(\n\t\t1, (sfr_address = CA8210_SFR_PTHRH),\n\t\tPTHRH_DEFAULT_THRESHOLD, device_ref);\n\tif (status)\n\t\tgoto finish;\n\t \n\tstatus = tdme_setsfr_request_sync(\n\t\t0, (sfr_address = CA8210_SFR_PACFGIB),\n\t\tPACFGIB_DEFAULT_CURRENT, device_ref);\n\tif (status)\n\t\tgoto finish;\n\nfinish:\n\tif (status != IEEE802154_SUCCESS) {\n\t\tdev_err(\n\t\t\t&spi->dev,\n\t\t\t\"failed to set sfr at %#03x, status = %#03x\\n\",\n\t\t\tsfr_address,\n\t\t\tstatus\n\t\t);\n\t}\n\treturn status;\n}\n\n \nstatic u8 tdme_channelinit(u8 channel, void *device_ref)\n{\n\t \n\tu8 txcalval;\n\n\tif (channel >= 25)\n\t\ttxcalval = 0xA7;\n\telse if (channel >= 23)\n\t\ttxcalval = 0xA8;\n\telse if (channel >= 22)\n\t\ttxcalval = 0xA9;\n\telse if (channel >= 20)\n\t\ttxcalval = 0xAA;\n\telse if (channel >= 17)\n\t\ttxcalval = 0xAB;\n\telse if (channel >= 16)\n\t\ttxcalval = 0xAC;\n\telse if (channel >= 14)\n\t\ttxcalval = 0xAD;\n\telse if (channel >= 12)\n\t\ttxcalval = 0xAE;\n\telse\n\t\ttxcalval = 0xAF;\n\n\treturn tdme_setsfr_request_sync(\n\t\t1,\n\t\tCA8210_SFR_LOTXCAL,\n\t\ttxcalval,\n\t\tdevice_ref\n\t);   \n}\n\n \nstatic u8 tdme_checkpibattribute(\n\tu8            pib_attribute,\n\tu8            pib_attribute_length,\n\tconst void   *pib_attribute_value\n)\n{\n\tu8 status = IEEE802154_SUCCESS;\n\tu8 value;\n\n\tvalue  = *((u8 *)pib_attribute_value);\n\n\tswitch (pib_attribute) {\n\t \n\tcase PHY_TRANSMIT_POWER:\n\t\tif (value > 0x3F)\n\t\t\tstatus = IEEE802154_INVALID_PARAMETER;\n\t\tbreak;\n\tcase PHY_CCA_MODE:\n\t\tif (value > 0x03)\n\t\t\tstatus = IEEE802154_INVALID_PARAMETER;\n\t\tbreak;\n\t \n\tcase MAC_BATT_LIFE_EXT_PERIODS:\n\t\tif (value < 6 || value > 41)\n\t\t\tstatus = IEEE802154_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_BEACON_PAYLOAD:\n\t\tif (pib_attribute_length > MAX_BEACON_PAYLOAD_LENGTH)\n\t\t\tstatus = IEEE802154_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_BEACON_PAYLOAD_LENGTH:\n\t\tif (value > MAX_BEACON_PAYLOAD_LENGTH)\n\t\t\tstatus = IEEE802154_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_BEACON_ORDER:\n\t\tif (value > 15)\n\t\t\tstatus = IEEE802154_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_MAX_BE:\n\t\tif (value < 3 || value > 8)\n\t\t\tstatus = IEEE802154_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_MAX_CSMA_BACKOFFS:\n\t\tif (value > 5)\n\t\t\tstatus = IEEE802154_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_MAX_FRAME_RETRIES:\n\t\tif (value > 7)\n\t\t\tstatus = IEEE802154_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_MIN_BE:\n\t\tif (value > 8)\n\t\t\tstatus = IEEE802154_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_RESPONSE_WAIT_TIME:\n\t\tif (value < 2 || value > 64)\n\t\t\tstatus = IEEE802154_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_SUPERFRAME_ORDER:\n\t\tif (value > 15)\n\t\t\tstatus = IEEE802154_INVALID_PARAMETER;\n\t\tbreak;\n\t \n\tcase MAC_ASSOCIATED_PAN_COORD:\n\tcase MAC_ASSOCIATION_PERMIT:\n\tcase MAC_AUTO_REQUEST:\n\tcase MAC_BATT_LIFE_EXT:\n\tcase MAC_GTS_PERMIT:\n\tcase MAC_PROMISCUOUS_MODE:\n\tcase MAC_RX_ON_WHEN_IDLE:\n\tcase MAC_SECURITY_ENABLED:\n\t\tif (value > 1)\n\t\t\tstatus = IEEE802154_INVALID_PARAMETER;\n\t\tbreak;\n\t \n\tcase MAC_AUTO_REQUEST_SECURITY_LEVEL:\n\t\tif (value > 7)\n\t\t\tstatus = IEEE802154_INVALID_PARAMETER;\n\t\tbreak;\n\tcase MAC_AUTO_REQUEST_KEY_ID_MODE:\n\t\tif (value > 3)\n\t\t\tstatus = IEEE802154_INVALID_PARAMETER;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn status;\n}\n\n \nstatic u8 tdme_settxpower(u8 txp, void *device_ref)\n{\n\tu8 status;\n\ts8 txp_val;\n\tu8 txp_ext;\n\tunion pa_cfg_sfr pa_cfg_val;\n\n\t \n\ttxp_ext = 0x3F & txp;\n\tif (txp_ext & 0x20)\n\t\ttxp_ext += 0xC0;\n\ttxp_val = (s8)txp_ext;\n\n\tif (CA8210_MAC_MPW) {\n\t\tif (txp_val > 0) {\n\t\t\t \n\t\t\tpa_cfg_val.bias_current_trim     = 3;\n\t\t\tpa_cfg_val.buffer_capacitor_trim = 5;\n\t\t\tpa_cfg_val.boost                 = 1;\n\t\t} else {\n\t\t\t \n\t\t\tpa_cfg_val.bias_current_trim     = 3;\n\t\t\tpa_cfg_val.buffer_capacitor_trim = 7;\n\t\t\tpa_cfg_val.boost                 = 0;\n\t\t}\n\t\t \n\t\tstatus = tdme_setsfr_request_sync(\n\t\t\t0,\n\t\t\tCA8210_SFR_PACFG,\n\t\t\tpa_cfg_val.paib,\n\t\t\tdevice_ref\n\t\t);\n\t} else {\n\t\t \n\t\tif (txp_val > 8) {\n\t\t\tpa_cfg_val.paib = 0x3F;\n\t\t} else if (txp_val == 8) {\n\t\t\tpa_cfg_val.paib = 0x32;\n\t\t} else if (txp_val == 7) {\n\t\t\tpa_cfg_val.paib = 0x22;\n\t\t} else if (txp_val == 6) {\n\t\t\tpa_cfg_val.paib = 0x18;\n\t\t} else if (txp_val == 5) {\n\t\t\tpa_cfg_val.paib = 0x10;\n\t\t} else if (txp_val == 4) {\n\t\t\tpa_cfg_val.paib = 0x0C;\n\t\t} else if (txp_val == 3) {\n\t\t\tpa_cfg_val.paib = 0x08;\n\t\t} else if (txp_val == 2) {\n\t\t\tpa_cfg_val.paib = 0x05;\n\t\t} else if (txp_val == 1) {\n\t\t\tpa_cfg_val.paib = 0x03;\n\t\t} else if (txp_val == 0) {\n\t\t\tpa_cfg_val.paib = 0x01;\n\t\t} else {  \n\t\t\tpa_cfg_val.paib = 0x00;\n\t\t}\n\t\t \n\t\tstatus = tdme_setsfr_request_sync(\n\t\t\t0,\n\t\t\tCA8210_SFR_PACFGIB,\n\t\t\tpa_cfg_val.paib,\n\t\t\tdevice_ref\n\t\t);\n\t}\n\n\treturn status;\n}\n\n \nstatic u8 mcps_data_request(\n\tu8               src_addr_mode,\n\tu8               dst_address_mode,\n\tu16              dst_pan_id,\n\tunion macaddr   *dst_addr,\n\tu8               msdu_length,\n\tu8              *msdu,\n\tu8               msdu_handle,\n\tu8               tx_options,\n\tstruct secspec  *security,\n\tvoid            *device_ref\n)\n{\n\tstruct secspec *psec;\n\tstruct mac_message command;\n\n\tcommand.command_id = SPI_MCPS_DATA_REQUEST;\n\tcommand.pdata.data_req.src_addr_mode = src_addr_mode;\n\tcommand.pdata.data_req.dst.mode = dst_address_mode;\n\tif (dst_address_mode != MAC_MODE_NO_ADDR) {\n\t\tcommand.pdata.data_req.dst.pan_id[0] = LS_BYTE(dst_pan_id);\n\t\tcommand.pdata.data_req.dst.pan_id[1] = MS_BYTE(dst_pan_id);\n\t\tif (dst_address_mode == MAC_MODE_SHORT_ADDR) {\n\t\t\tcommand.pdata.data_req.dst.address[0] = LS_BYTE(\n\t\t\t\tdst_addr->short_address\n\t\t\t);\n\t\t\tcommand.pdata.data_req.dst.address[1] = MS_BYTE(\n\t\t\t\tdst_addr->short_address\n\t\t\t);\n\t\t} else {    \n\t\t\tmemcpy(\n\t\t\t\tcommand.pdata.data_req.dst.address,\n\t\t\t\tdst_addr->ieee_address,\n\t\t\t\t8\n\t\t\t);\n\t\t}\n\t}\n\tcommand.pdata.data_req.msdu_length = msdu_length;\n\tcommand.pdata.data_req.msdu_handle = msdu_handle;\n\tcommand.pdata.data_req.tx_options = tx_options;\n\tmemcpy(command.pdata.data_req.msdu, msdu, msdu_length);\n\tpsec = (struct secspec *)(command.pdata.data_req.msdu + msdu_length);\n\tcommand.length = sizeof(struct mcps_data_request_pset) -\n\t\tMAX_DATA_SIZE + msdu_length;\n\tif (!security || security->security_level == 0) {\n\t\tpsec->security_level = 0;\n\t\tcommand.length += 1;\n\t} else {\n\t\t*psec = *security;\n\t\tcommand.length += sizeof(struct secspec);\n\t}\n\n\tif (ca8210_spi_transfer(device_ref, &command.command_id,\n\t\t\t\tcommand.length + 2))\n\t\treturn IEEE802154_SYSTEM_ERROR;\n\n\treturn IEEE802154_SUCCESS;\n}\n\n \nstatic u8 mlme_reset_request_sync(\n\tu8    set_default_pib,\n\tvoid *device_ref\n)\n{\n\tu8 status;\n\tstruct mac_message command, response;\n\tstruct spi_device *spi = device_ref;\n\n\tcommand.command_id = SPI_MLME_RESET_REQUEST;\n\tcommand.length = 1;\n\tcommand.pdata.u8param = set_default_pib;\n\n\tif (cascoda_api_downstream(\n\t\t&command.command_id,\n\t\tcommand.length + 2,\n\t\t&response.command_id,\n\t\tdevice_ref)) {\n\t\tdev_err(&spi->dev, \"cascoda_api_downstream failed\\n\");\n\t\treturn IEEE802154_SYSTEM_ERROR;\n\t}\n\n\tif (response.command_id != SPI_MLME_RESET_CONFIRM)\n\t\treturn IEEE802154_SYSTEM_ERROR;\n\n\tstatus = response.pdata.status;\n\n\t \n\tif (CA8210_MAC_WORKAROUNDS && set_default_pib && !status) {\n\t\tstatus = tdme_setsfr_request_sync(\n\t\t\t0,\n\t\t\tCA8210_SFR_MACCON,\n\t\t\t0,\n\t\t\tdevice_ref\n\t\t);\n\t}\n\n\treturn status;\n}\n\n \nstatic u8 mlme_set_request_sync(\n\tu8            pib_attribute,\n\tu8            pib_attribute_index,\n\tu8            pib_attribute_length,\n\tconst void   *pib_attribute_value,\n\tvoid         *device_ref\n)\n{\n\tu8 status;\n\tstruct mac_message command, response;\n\n\t \n\tif (tdme_checkpibattribute(\n\t\tpib_attribute, pib_attribute_length, pib_attribute_value)) {\n\t\treturn IEEE802154_INVALID_PARAMETER;\n\t}\n\n\tif (pib_attribute == PHY_CURRENT_CHANNEL) {\n\t\tstatus = tdme_channelinit(\n\t\t\t*((u8 *)pib_attribute_value),\n\t\t\tdevice_ref\n\t\t);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\tif (pib_attribute == PHY_TRANSMIT_POWER) {\n\t\treturn tdme_settxpower(\n\t\t\t*((u8 *)pib_attribute_value),\n\t\t\tdevice_ref\n\t\t);\n\t}\n\n\tcommand.command_id = SPI_MLME_SET_REQUEST;\n\tcommand.length = sizeof(struct mlme_set_request_pset) -\n\t\tMAX_ATTRIBUTE_SIZE + pib_attribute_length;\n\tcommand.pdata.set_req.pib_attribute = pib_attribute;\n\tcommand.pdata.set_req.pib_attribute_index = pib_attribute_index;\n\tcommand.pdata.set_req.pib_attribute_length = pib_attribute_length;\n\tmemcpy(\n\t\tcommand.pdata.set_req.pib_attribute_value,\n\t\tpib_attribute_value,\n\t\tpib_attribute_length\n\t);\n\n\tif (cascoda_api_downstream(\n\t\t&command.command_id,\n\t\tcommand.length + 2,\n\t\t&response.command_id,\n\t\tdevice_ref)) {\n\t\treturn IEEE802154_SYSTEM_ERROR;\n\t}\n\n\tif (response.command_id != SPI_MLME_SET_CONFIRM)\n\t\treturn IEEE802154_SYSTEM_ERROR;\n\n\treturn response.pdata.status;\n}\n\n \nstatic u8 hwme_set_request_sync(\n\tu8           hw_attribute,\n\tu8           hw_attribute_length,\n\tu8          *hw_attribute_value,\n\tvoid        *device_ref\n)\n{\n\tstruct mac_message command, response;\n\n\tcommand.command_id = SPI_HWME_SET_REQUEST;\n\tcommand.length = 2 + hw_attribute_length;\n\tcommand.pdata.hwme_set_req.hw_attribute = hw_attribute;\n\tcommand.pdata.hwme_set_req.hw_attribute_length = hw_attribute_length;\n\tmemcpy(\n\t\tcommand.pdata.hwme_set_req.hw_attribute_value,\n\t\thw_attribute_value,\n\t\thw_attribute_length\n\t);\n\n\tif (cascoda_api_downstream(\n\t\t&command.command_id,\n\t\tcommand.length + 2,\n\t\t&response.command_id,\n\t\tdevice_ref)) {\n\t\treturn IEEE802154_SYSTEM_ERROR;\n\t}\n\n\tif (response.command_id != SPI_HWME_SET_CONFIRM)\n\t\treturn IEEE802154_SYSTEM_ERROR;\n\n\treturn response.pdata.hwme_set_cnf.status;\n}\n\n \nstatic u8 hwme_get_request_sync(\n\tu8           hw_attribute,\n\tu8          *hw_attribute_length,\n\tu8          *hw_attribute_value,\n\tvoid        *device_ref\n)\n{\n\tstruct mac_message command, response;\n\n\tcommand.command_id = SPI_HWME_GET_REQUEST;\n\tcommand.length = 1;\n\tcommand.pdata.hwme_get_req.hw_attribute = hw_attribute;\n\n\tif (cascoda_api_downstream(\n\t\t&command.command_id,\n\t\tcommand.length + 2,\n\t\t&response.command_id,\n\t\tdevice_ref)) {\n\t\treturn IEEE802154_SYSTEM_ERROR;\n\t}\n\n\tif (response.command_id != SPI_HWME_GET_CONFIRM)\n\t\treturn IEEE802154_SYSTEM_ERROR;\n\n\tif (response.pdata.hwme_get_cnf.status == IEEE802154_SUCCESS) {\n\t\t*hw_attribute_length =\n\t\t\tresponse.pdata.hwme_get_cnf.hw_attribute_length;\n\t\tmemcpy(\n\t\t\thw_attribute_value,\n\t\t\tresponse.pdata.hwme_get_cnf.hw_attribute_value,\n\t\t\t*hw_attribute_length\n\t\t);\n\t}\n\n\treturn response.pdata.hwme_get_cnf.status;\n}\n\n \n\n \nstatic int ca8210_async_xmit_complete(\n\tstruct ieee802154_hw  *hw,\n\tu8                     msduhandle,\n\tu8                     status)\n{\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tif (priv->nextmsduhandle != msduhandle) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"Unexpected msdu_handle on data confirm, Expected %d, got %d\\n\",\n\t\t\tpriv->nextmsduhandle,\n\t\t\tmsduhandle\n\t\t);\n\t\treturn -EIO;\n\t}\n\n\tpriv->async_tx_pending = false;\n\tpriv->nextmsduhandle++;\n\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"Link transmission unsuccessful, status = %d\\n\",\n\t\t\tstatus\n\t\t);\n\t\tif (status != IEEE802154_TRANSACTION_OVERFLOW) {\n\t\t\tieee802154_xmit_error(priv->hw, priv->tx_skb, status);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tieee802154_xmit_complete(priv->hw, priv->tx_skb, true);\n\n\treturn 0;\n}\n\n \nstatic int ca8210_skb_rx(\n\tstruct ieee802154_hw  *hw,\n\tsize_t                 len,\n\tu8                    *data_ind\n)\n{\n\tstruct ieee802154_hdr hdr;\n\tint msdulen;\n\tint hlen;\n\tu8 mpdulinkquality = data_ind[23];\n\tstruct sk_buff *skb;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\t \n\tskb = dev_alloc_skb(IEEE802154_MTU + sizeof(hdr));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, sizeof(hdr));\n\n\tmsdulen = data_ind[22];  \n\tif (msdulen > IEEE802154_MTU) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"received erroneously large msdu length!\\n\"\n\t\t);\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\tdev_dbg(&priv->spi->dev, \"skb buffer length = %d\\n\", msdulen);\n\n\tif (priv->promiscuous)\n\t\tgoto copy_payload;\n\n\t \n\thdr.sec.level = data_ind[29 + msdulen];\n\tdev_dbg(&priv->spi->dev, \"security level: %#03x\\n\", hdr.sec.level);\n\tif (hdr.sec.level > 0) {\n\t\thdr.sec.key_id_mode = data_ind[30 + msdulen];\n\t\tmemcpy(&hdr.sec.extended_src, &data_ind[31 + msdulen], 8);\n\t\thdr.sec.key_id = data_ind[39 + msdulen];\n\t}\n\thdr.source.mode = data_ind[0];\n\tdev_dbg(&priv->spi->dev, \"srcAddrMode: %#03x\\n\", hdr.source.mode);\n\thdr.source.pan_id = *(u16 *)&data_ind[1];\n\tdev_dbg(&priv->spi->dev, \"srcPanId: %#06x\\n\", hdr.source.pan_id);\n\tmemcpy(&hdr.source.extended_addr, &data_ind[3], 8);\n\thdr.dest.mode = data_ind[11];\n\tdev_dbg(&priv->spi->dev, \"dstAddrMode: %#03x\\n\", hdr.dest.mode);\n\thdr.dest.pan_id = *(u16 *)&data_ind[12];\n\tdev_dbg(&priv->spi->dev, \"dstPanId: %#06x\\n\", hdr.dest.pan_id);\n\tmemcpy(&hdr.dest.extended_addr, &data_ind[14], 8);\n\n\t \n\thdr.fc.type = 1;  \n\tif (hdr.sec.level)\n\t\thdr.fc.security_enabled = 1;\n\telse\n\t\thdr.fc.security_enabled = 0;\n\tif (data_ind[1] != data_ind[12] || data_ind[2] != data_ind[13])\n\t\thdr.fc.intra_pan = 1;\n\telse\n\t\thdr.fc.intra_pan = 0;\n\thdr.fc.dest_addr_mode = hdr.dest.mode;\n\thdr.fc.source_addr_mode = hdr.source.mode;\n\n\t \n\thlen = ieee802154_hdr_push(skb, &hdr);\n\n\tif (hlen < 0) {\n\t\tdev_crit(&priv->spi->dev, \"failed to push mac hdr onto skb!\\n\");\n\t\tkfree_skb(skb);\n\t\treturn hlen;\n\t}\n\n\tskb_reset_mac_header(skb);\n\tskb->mac_len = hlen;\n\ncopy_payload:\n\t \n\t \n\tskb_put_data(skb, &data_ind[29], msdulen);\n\n\tieee802154_rx_irqsafe(hw, skb, mpdulinkquality);\n\treturn 0;\n}\n\n \nstatic int ca8210_net_rx(struct ieee802154_hw *hw, u8 *command, size_t len)\n{\n\tstruct ca8210_priv *priv = hw->priv;\n\tunsigned long flags;\n\tu8 status;\n\n\tdev_dbg(&priv->spi->dev, \"%s: CmdID = %d\\n\", __func__, command[0]);\n\n\tif (command[0] == SPI_MCPS_DATA_INDICATION) {\n\t\t \n\t\tspin_lock_irqsave(&priv->lock, flags);\n\t\tif (command[26] == priv->last_dsn) {\n\t\t\tdev_dbg(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"DSN %d resend received, ignoring...\\n\",\n\t\t\t\tcommand[26]\n\t\t\t);\n\t\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\t\treturn 0;\n\t\t}\n\t\tpriv->last_dsn = command[26];\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\treturn ca8210_skb_rx(hw, len - 2, command + 2);\n\t} else if (command[0] == SPI_MCPS_DATA_CONFIRM) {\n\t\tstatus = command[3];\n\t\tif (priv->async_tx_pending) {\n\t\t\treturn ca8210_async_xmit_complete(\n\t\t\t\thw,\n\t\t\t\tcommand[2],\n\t\t\t\tstatus\n\t\t\t);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ca8210_skb_tx(\n\tstruct sk_buff      *skb,\n\tu8                   msduhandle,\n\tstruct ca8210_priv  *priv\n)\n{\n\tstruct ieee802154_hdr header = { };\n\tstruct secspec secspec;\n\tint mac_len, status;\n\n\tdev_dbg(&priv->spi->dev, \"%s called\\n\", __func__);\n\n\t \n\tmac_len = ieee802154_hdr_peek_addrs(skb, &header);\n\tif (mac_len < 0)\n\t\treturn mac_len;\n\n\tsecspec.security_level = header.sec.level;\n\tsecspec.key_id_mode = header.sec.key_id_mode;\n\tif (secspec.key_id_mode == 2)\n\t\tmemcpy(secspec.key_source, &header.sec.short_src, 4);\n\telse if (secspec.key_id_mode == 3)\n\t\tmemcpy(secspec.key_source, &header.sec.extended_src, 8);\n\tsecspec.key_index = header.sec.key_id;\n\n\t \n\tstatus =  mcps_data_request(\n\t\theader.source.mode,\n\t\theader.dest.mode,\n\t\theader.dest.pan_id,\n\t\t(union macaddr *)&header.dest.extended_addr,\n\t\tskb->len - mac_len,\n\t\t&skb->data[mac_len],\n\t\tmsduhandle,\n\t\theader.fc.ack_request,\n\t\t&secspec,\n\t\tpriv->spi\n\t);\n\treturn link_to_linux_err(status);\n}\n\n \nstatic int ca8210_start(struct ieee802154_hw *hw)\n{\n\tint status;\n\tu8 rx_on_when_idle;\n\tu8 lqi_threshold = 0;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tpriv->last_dsn = -1;\n\t \n\trx_on_when_idle = 1;\n\tstatus = mlme_set_request_sync(\n\t\tMAC_RX_ON_WHEN_IDLE,\n\t\t0,\n\t\t1,\n\t\t&rx_on_when_idle,\n\t\tpriv->spi\n\t);\n\tif (status) {\n\t\tdev_crit(\n\t\t\t&priv->spi->dev,\n\t\t\t\"Setting rx_on_when_idle failed, status = %d\\n\",\n\t\t\tstatus\n\t\t);\n\t\treturn link_to_linux_err(status);\n\t}\n\tstatus = hwme_set_request_sync(\n\t\tHWME_LQILIMIT,\n\t\t1,\n\t\t&lqi_threshold,\n\t\tpriv->spi\n\t);\n\tif (status) {\n\t\tdev_crit(\n\t\t\t&priv->spi->dev,\n\t\t\t\"Setting lqilimit failed, status = %d\\n\",\n\t\t\tstatus\n\t\t);\n\t\treturn link_to_linux_err(status);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ca8210_stop(struct ieee802154_hw *hw)\n{\n}\n\n \nstatic int ca8210_xmit_async(struct ieee802154_hw *hw, struct sk_buff *skb)\n{\n\tstruct ca8210_priv *priv = hw->priv;\n\tint status;\n\n\tdev_dbg(&priv->spi->dev, \"calling %s\\n\", __func__);\n\n\tpriv->tx_skb = skb;\n\tpriv->async_tx_pending = true;\n\tstatus = ca8210_skb_tx(skb, priv->nextmsduhandle, priv);\n\treturn status;\n}\n\n \nstatic int ca8210_get_ed(struct ieee802154_hw *hw, u8 *level)\n{\n\tu8 lenvar;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\treturn link_to_linux_err(\n\t\thwme_get_request_sync(HWME_EDVALUE, &lenvar, level, priv->spi)\n\t);\n}\n\n \nstatic int ca8210_set_channel(\n\tstruct ieee802154_hw  *hw,\n\tu8                     page,\n\tu8                     channel\n)\n{\n\tu8 status;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tstatus = mlme_set_request_sync(\n\t\tPHY_CURRENT_CHANNEL,\n\t\t0,\n\t\t1,\n\t\t&channel,\n\t\tpriv->spi\n\t);\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"error setting channel, MLME-SET.confirm status = %d\\n\",\n\t\t\tstatus\n\t\t);\n\t}\n\treturn link_to_linux_err(status);\n}\n\n \nstatic int ca8210_set_hw_addr_filt(\n\tstruct ieee802154_hw            *hw,\n\tstruct ieee802154_hw_addr_filt  *filt,\n\tunsigned long                    changed\n)\n{\n\tu8 status = 0;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tif (changed & IEEE802154_AFILT_PANID_CHANGED) {\n\t\tstatus = mlme_set_request_sync(\n\t\t\tMAC_PAN_ID,\n\t\t\t0,\n\t\t\t2,\n\t\t\t&filt->pan_id, priv->spi\n\t\t);\n\t\tif (status) {\n\t\t\tdev_err(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"error setting pan id, MLME-SET.confirm status = %d\",\n\t\t\t\tstatus\n\t\t\t);\n\t\t\treturn link_to_linux_err(status);\n\t\t}\n\t}\n\tif (changed & IEEE802154_AFILT_SADDR_CHANGED) {\n\t\tstatus = mlme_set_request_sync(\n\t\t\tMAC_SHORT_ADDRESS,\n\t\t\t0,\n\t\t\t2,\n\t\t\t&filt->short_addr, priv->spi\n\t\t);\n\t\tif (status) {\n\t\t\tdev_err(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"error setting short address, MLME-SET.confirm status = %d\",\n\t\t\t\tstatus\n\t\t\t);\n\t\t\treturn link_to_linux_err(status);\n\t\t}\n\t}\n\tif (changed & IEEE802154_AFILT_IEEEADDR_CHANGED) {\n\t\tstatus = mlme_set_request_sync(\n\t\t\tNS_IEEE_ADDRESS,\n\t\t\t0,\n\t\t\t8,\n\t\t\t&filt->ieee_addr,\n\t\t\tpriv->spi\n\t\t);\n\t\tif (status) {\n\t\t\tdev_err(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"error setting ieee address, MLME-SET.confirm status = %d\",\n\t\t\t\tstatus\n\t\t\t);\n\t\t\treturn link_to_linux_err(status);\n\t\t}\n\t}\n\t \n\treturn 0;\n}\n\n \nstatic int ca8210_set_tx_power(struct ieee802154_hw *hw, s32 mbm)\n{\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tmbm /= 100;\n\treturn link_to_linux_err(\n\t\tmlme_set_request_sync(PHY_TRANSMIT_POWER, 0, 1, &mbm, priv->spi)\n\t);\n}\n\n \nstatic int ca8210_set_cca_mode(\n\tstruct ieee802154_hw       *hw,\n\tconst struct wpan_phy_cca  *cca\n)\n{\n\tu8 status;\n\tu8 cca_mode;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tcca_mode = cca->mode & 3;\n\tif (cca_mode == 3 && cca->opt == NL802154_CCA_OPT_ENERGY_CARRIER_OR) {\n\t\t \n\t\tcca_mode = 0;\n\t}\n\tstatus = mlme_set_request_sync(\n\t\tPHY_CCA_MODE,\n\t\t0,\n\t\t1,\n\t\t&cca_mode,\n\t\tpriv->spi\n\t);\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"error setting cca mode, MLME-SET.confirm status = %d\",\n\t\t\tstatus\n\t\t);\n\t}\n\treturn link_to_linux_err(status);\n}\n\n \nstatic int ca8210_set_cca_ed_level(struct ieee802154_hw *hw, s32 level)\n{\n\tu8 status;\n\tu8 ed_threshold = (level / 100) * 2 + 256;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tstatus = hwme_set_request_sync(\n\t\tHWME_EDTHRESHOLD,\n\t\t1,\n\t\t&ed_threshold,\n\t\tpriv->spi\n\t);\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"error setting ed threshold, HWME-SET.confirm status = %d\",\n\t\t\tstatus\n\t\t);\n\t}\n\treturn link_to_linux_err(status);\n}\n\n \nstatic int ca8210_set_csma_params(\n\tstruct ieee802154_hw  *hw,\n\tu8                     min_be,\n\tu8                     max_be,\n\tu8                     retries\n)\n{\n\tu8 status;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tstatus = mlme_set_request_sync(MAC_MIN_BE, 0, 1, &min_be, priv->spi);\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"error setting min be, MLME-SET.confirm status = %d\",\n\t\t\tstatus\n\t\t);\n\t\treturn link_to_linux_err(status);\n\t}\n\tstatus = mlme_set_request_sync(MAC_MAX_BE, 0, 1, &max_be, priv->spi);\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"error setting max be, MLME-SET.confirm status = %d\",\n\t\t\tstatus\n\t\t);\n\t\treturn link_to_linux_err(status);\n\t}\n\tstatus = mlme_set_request_sync(\n\t\tMAC_MAX_CSMA_BACKOFFS,\n\t\t0,\n\t\t1,\n\t\t&retries,\n\t\tpriv->spi\n\t);\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"error setting max csma backoffs, MLME-SET.confirm status = %d\",\n\t\t\tstatus\n\t\t);\n\t}\n\treturn link_to_linux_err(status);\n}\n\n \nstatic int ca8210_set_frame_retries(struct ieee802154_hw *hw, s8 retries)\n{\n\tu8 status;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tstatus = mlme_set_request_sync(\n\t\tMAC_MAX_FRAME_RETRIES,\n\t\t0,\n\t\t1,\n\t\t&retries,\n\t\tpriv->spi\n\t);\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"error setting frame retries, MLME-SET.confirm status = %d\",\n\t\t\tstatus\n\t\t);\n\t}\n\treturn link_to_linux_err(status);\n}\n\nstatic int ca8210_set_promiscuous_mode(struct ieee802154_hw *hw, const bool on)\n{\n\tu8 status;\n\tstruct ca8210_priv *priv = hw->priv;\n\n\tstatus = mlme_set_request_sync(\n\t\tMAC_PROMISCUOUS_MODE,\n\t\t0,\n\t\t1,\n\t\t(const void *)&on,\n\t\tpriv->spi\n\t);\n\tif (status) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"error setting promiscuous mode, MLME-SET.confirm status = %d\",\n\t\t\tstatus\n\t\t);\n\t} else {\n\t\tpriv->promiscuous = on;\n\t}\n\treturn link_to_linux_err(status);\n}\n\nstatic const struct ieee802154_ops ca8210_phy_ops = {\n\t.start = ca8210_start,\n\t.stop = ca8210_stop,\n\t.xmit_async = ca8210_xmit_async,\n\t.ed = ca8210_get_ed,\n\t.set_channel = ca8210_set_channel,\n\t.set_hw_addr_filt = ca8210_set_hw_addr_filt,\n\t.set_txpower = ca8210_set_tx_power,\n\t.set_cca_mode = ca8210_set_cca_mode,\n\t.set_cca_ed_level = ca8210_set_cca_ed_level,\n\t.set_csma_params = ca8210_set_csma_params,\n\t.set_frame_retries = ca8210_set_frame_retries,\n\t.set_promiscuous_mode = ca8210_set_promiscuous_mode\n};\n\n \n\n \nstatic int ca8210_test_int_open(struct inode *inodp, struct file *filp)\n{\n\tstruct ca8210_priv *priv = inodp->i_private;\n\n\tfilp->private_data = priv;\n\treturn 0;\n}\n\n \nstatic int ca8210_test_check_upstream(u8 *buf, void *device_ref)\n{\n\tint ret;\n\tu8 response[CA8210_SPI_BUF_SIZE];\n\n\tif (buf[0] == SPI_MLME_SET_REQUEST) {\n\t\tret = tdme_checkpibattribute(buf[2], buf[4], buf + 5);\n\t\tif (ret) {\n\t\t\tresponse[0]  = SPI_MLME_SET_CONFIRM;\n\t\t\tresponse[1] = 3;\n\t\t\tresponse[2] = IEEE802154_INVALID_PARAMETER;\n\t\t\tresponse[3] = buf[2];\n\t\t\tresponse[4] = buf[3];\n\t\t\tif (cascoda_api_upstream)\n\t\t\t\tcascoda_api_upstream(response, 5, device_ref);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif (buf[0] == SPI_MLME_ASSOCIATE_REQUEST) {\n\t\treturn tdme_channelinit(buf[2], device_ref);\n\t} else if (buf[0] == SPI_MLME_START_REQUEST) {\n\t\treturn tdme_channelinit(buf[4], device_ref);\n\t} else if (\n\t\t(buf[0] == SPI_MLME_SET_REQUEST) &&\n\t\t(buf[2] == PHY_CURRENT_CHANNEL)\n\t) {\n\t\treturn tdme_channelinit(buf[5], device_ref);\n\t} else if (\n\t\t(buf[0] == SPI_TDME_SET_REQUEST) &&\n\t\t(buf[2] == TDME_CHANNEL)\n\t) {\n\t\treturn tdme_channelinit(buf[4], device_ref);\n\t} else if (\n\t\t(CA8210_MAC_WORKAROUNDS) &&\n\t\t(buf[0] == SPI_MLME_RESET_REQUEST) &&\n\t\t(buf[2] == 1)\n\t) {\n\t\t \n\t\treturn tdme_setsfr_request_sync(\n\t\t\t0,\n\t\t\tCA8210_SFR_MACCON,\n\t\t\t0,\n\t\t\tdevice_ref\n\t\t);\n\t}\n\treturn 0;\n}  \n\n \nstatic ssize_t ca8210_test_int_user_write(\n\tstruct file        *filp,\n\tconst char __user  *in_buf,\n\tsize_t              len,\n\tloff_t             *off\n)\n{\n\tint ret;\n\tstruct ca8210_priv *priv = filp->private_data;\n\tu8 command[CA8210_SPI_BUF_SIZE];\n\n\tmemset(command, SPI_IDLE, 6);\n\tif (len > CA8210_SPI_BUF_SIZE || len < 2) {\n\t\tdev_warn(\n\t\t\t&priv->spi->dev,\n\t\t\t\"userspace requested erroneous write length (%zu)\\n\",\n\t\t\tlen\n\t\t);\n\t\treturn -EBADE;\n\t}\n\n\tret = copy_from_user(command, in_buf, len);\n\tif (ret) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"%d bytes could not be copied from userspace\\n\",\n\t\t\tret\n\t\t);\n\t\treturn -EIO;\n\t}\n\tif (len != command[1] + 2) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"write len does not match packet length field\\n\"\n\t\t);\n\t\treturn -EBADE;\n\t}\n\n\tret = ca8210_test_check_upstream(command, priv->spi);\n\tif (ret == 0) {\n\t\tret = ca8210_spi_exchange(\n\t\t\tcommand,\n\t\t\tcommand[1] + 2,\n\t\t\tNULL,\n\t\t\tpriv->spi\n\t\t);\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\tdev_err(\n\t\t\t\t&priv->spi->dev,\n\t\t\t\t\"spi exchange failed\\n\"\n\t\t\t);\n\t\t\treturn ret;\n\t\t}\n\t\tif (command[0] & SPI_SYN)\n\t\t\tpriv->sync_down++;\n\t}\n\n\treturn len;\n}\n\n \nstatic ssize_t ca8210_test_int_user_read(\n\tstruct file  *filp,\n\tchar __user  *buf,\n\tsize_t        len,\n\tloff_t       *offp\n)\n{\n\tint i, cmdlen;\n\tstruct ca8210_priv *priv = filp->private_data;\n\tunsigned char *fifo_buffer;\n\tunsigned long bytes_not_copied;\n\n\tif (filp->f_flags & O_NONBLOCK) {\n\t\t \n\t\tif (kfifo_is_empty(&priv->test.up_fifo))\n\t\t\treturn 0;\n\t} else {\n\t\t \n\t\twait_event_interruptible(\n\t\t\tpriv->test.readq,\n\t\t\t!kfifo_is_empty(&priv->test.up_fifo)\n\t\t);\n\t}\n\n\tif (kfifo_out(&priv->test.up_fifo, &fifo_buffer, 4) != 4) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"test_interface: Wrong number of elements popped from upstream fifo\\n\"\n\t\t);\n\t\treturn 0;\n\t}\n\tcmdlen = fifo_buffer[1];\n\tbytes_not_copied = cmdlen + 2;\n\n\tbytes_not_copied = copy_to_user(buf, fifo_buffer, bytes_not_copied);\n\tif (bytes_not_copied > 0) {\n\t\tdev_err(\n\t\t\t&priv->spi->dev,\n\t\t\t\"%lu bytes could not be copied to user space!\\n\",\n\t\t\tbytes_not_copied\n\t\t);\n\t}\n\n\tdev_dbg(&priv->spi->dev, \"test_interface: Cmd len = %d\\n\", cmdlen);\n\n\tdev_dbg(&priv->spi->dev, \"test_interface: Read\\n\");\n\tfor (i = 0; i < cmdlen + 2; i++)\n\t\tdev_dbg(&priv->spi->dev, \"%#03x\\n\", fifo_buffer[i]);\n\n\tkfree(fifo_buffer);\n\n\treturn cmdlen + 2;\n}\n\n \nstatic long ca8210_test_int_ioctl(\n\tstruct file *filp,\n\tunsigned int ioctl_num,\n\tunsigned long ioctl_param\n)\n{\n\tstruct ca8210_priv *priv = filp->private_data;\n\n\tswitch (ioctl_num) {\n\tcase CA8210_IOCTL_HARD_RESET:\n\t\tca8210_reset_send(priv->spi, ioctl_param);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic __poll_t ca8210_test_int_poll(\n\tstruct file *filp,\n\tstruct poll_table_struct *ptable\n)\n{\n\t__poll_t return_flags = 0;\n\tstruct ca8210_priv *priv = filp->private_data;\n\n\tpoll_wait(filp, &priv->test.readq, ptable);\n\tif (!kfifo_is_empty(&priv->test.up_fifo))\n\t\treturn_flags |= (EPOLLIN | EPOLLRDNORM);\n\tif (wait_event_interruptible(\n\t\tpriv->test.readq,\n\t\t!kfifo_is_empty(&priv->test.up_fifo))) {\n\t\treturn EPOLLERR;\n\t}\n\treturn return_flags;\n}\n\nstatic const struct file_operations test_int_fops = {\n\t.read =           ca8210_test_int_user_read,\n\t.write =          ca8210_test_int_user_write,\n\t.open =           ca8210_test_int_open,\n\t.release =        NULL,\n\t.unlocked_ioctl = ca8210_test_int_ioctl,\n\t.poll =           ca8210_test_int_poll\n};\n\n \n\n \nstatic int ca8210_get_platform_data(\n\tstruct spi_device *spi_device,\n\tstruct ca8210_platform_data *pdata\n)\n{\n\tint ret = 0;\n\n\tif (!spi_device->dev.of_node)\n\t\treturn -EINVAL;\n\n\tpdata->extclockenable = of_property_read_bool(\n\t\tspi_device->dev.of_node,\n\t\t\"extclock-enable\"\n\t);\n\tif (pdata->extclockenable) {\n\t\tret = of_property_read_u32(\n\t\t\tspi_device->dev.of_node,\n\t\t\t\"extclock-freq\",\n\t\t\t&pdata->extclockfreq\n\t\t);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = of_property_read_u32(\n\t\t\tspi_device->dev.of_node,\n\t\t\t\"extclock-gpio\",\n\t\t\t&pdata->extclockgpio\n\t\t);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ca8210_config_extern_clk(\n\tstruct ca8210_platform_data *pdata,\n\tstruct spi_device *spi,\n\tbool on\n)\n{\n\tu8 clkparam[2];\n\n\tif (on) {\n\t\tdev_info(&spi->dev, \"Switching external clock on\\n\");\n\t\tswitch (pdata->extclockfreq) {\n\t\tcase SIXTEEN_MHZ:\n\t\t\tclkparam[0] = 1;\n\t\t\tbreak;\n\t\tcase EIGHT_MHZ:\n\t\t\tclkparam[0] = 2;\n\t\t\tbreak;\n\t\tcase FOUR_MHZ:\n\t\t\tclkparam[0] = 3;\n\t\t\tbreak;\n\t\tcase TWO_MHZ:\n\t\t\tclkparam[0] = 4;\n\t\t\tbreak;\n\t\tcase ONE_MHZ:\n\t\t\tclkparam[0] = 5;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_crit(&spi->dev, \"Invalid extclock-freq\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tclkparam[1] = pdata->extclockgpio;\n\t} else {\n\t\tdev_info(&spi->dev, \"Switching external clock off\\n\");\n\t\tclkparam[0] = 0;  \n\t\tclkparam[1] = 0;\n\t}\n\treturn link_to_linux_err(\n\t\thwme_set_request_sync(HWME_SYSCLKOUT, 2, clkparam, spi)\n\t);\n}\n\n \nstatic int ca8210_register_ext_clock(struct spi_device *spi)\n{\n\tstruct device_node *np = spi->dev.of_node;\n\tstruct ca8210_priv *priv = spi_get_drvdata(spi);\n\tstruct ca8210_platform_data *pdata = spi->dev.platform_data;\n\n\tif (!np)\n\t\treturn -EFAULT;\n\n\tpriv->clk = clk_register_fixed_rate(\n\t\t&spi->dev,\n\t\tnp->name,\n\t\tNULL,\n\t\t0,\n\t\tpdata->extclockfreq\n\t);\n\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_crit(&spi->dev, \"Failed to register external clk\\n\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\n\treturn of_clk_add_provider(np, of_clk_src_simple_get, priv->clk);\n}\n\n \nstatic void ca8210_unregister_ext_clock(struct spi_device *spi)\n{\n\tstruct ca8210_priv *priv = spi_get_drvdata(spi);\n\n\tif (IS_ERR_OR_NULL(priv->clk))\n\t\treturn;\n\n\tof_clk_del_provider(spi->dev.of_node);\n\tclk_unregister(priv->clk);\n\tdev_info(&spi->dev, \"External clock unregistered\\n\");\n}\n\n \nstatic int ca8210_reset_init(struct spi_device *spi)\n{\n\tint ret;\n\tstruct ca8210_platform_data *pdata = spi->dev.platform_data;\n\n\tpdata->gpio_reset = of_get_named_gpio(\n\t\tspi->dev.of_node,\n\t\t\"reset-gpio\",\n\t\t0\n\t);\n\n\tret = gpio_direction_output(pdata->gpio_reset, 1);\n\tif (ret < 0) {\n\t\tdev_crit(\n\t\t\t&spi->dev,\n\t\t\t\"Reset GPIO %d did not set to output mode\\n\",\n\t\t\tpdata->gpio_reset\n\t\t);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ca8210_interrupt_init(struct spi_device *spi)\n{\n\tint ret;\n\tstruct ca8210_platform_data *pdata = spi->dev.platform_data;\n\n\tpdata->gpio_irq = of_get_named_gpio(\n\t\tspi->dev.of_node,\n\t\t\"irq-gpio\",\n\t\t0\n\t);\n\n\tpdata->irq_id = gpio_to_irq(pdata->gpio_irq);\n\tif (pdata->irq_id < 0) {\n\t\tdev_crit(\n\t\t\t&spi->dev,\n\t\t\t\"Could not get irq for gpio pin %d\\n\",\n\t\t\tpdata->gpio_irq\n\t\t);\n\t\tgpio_free(pdata->gpio_irq);\n\t\treturn pdata->irq_id;\n\t}\n\n\tret = request_irq(\n\t\tpdata->irq_id,\n\t\tca8210_interrupt_handler,\n\t\tIRQF_TRIGGER_FALLING,\n\t\t\"ca8210-irq\",\n\t\tspi_get_drvdata(spi)\n\t);\n\tif (ret) {\n\t\tdev_crit(&spi->dev, \"request_irq %d failed\\n\", pdata->irq_id);\n\t\tgpio_free(pdata->gpio_irq);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ca8210_dev_com_init(struct ca8210_priv *priv)\n{\n\tpriv->mlme_workqueue = alloc_ordered_workqueue(\n\t\t\"MLME work queue\",\n\t\tWQ_UNBOUND\n\t);\n\tif (!priv->mlme_workqueue) {\n\t\tdev_crit(&priv->spi->dev, \"alloc of mlme_workqueue failed!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->irq_workqueue = alloc_ordered_workqueue(\n\t\t\"ca8210 irq worker\",\n\t\tWQ_UNBOUND\n\t);\n\tif (!priv->irq_workqueue) {\n\t\tdev_crit(&priv->spi->dev, \"alloc of irq_workqueue failed!\\n\");\n\t\tdestroy_workqueue(priv->mlme_workqueue);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ca8210_dev_com_clear(struct ca8210_priv *priv)\n{\n\tdestroy_workqueue(priv->mlme_workqueue);\n\tdestroy_workqueue(priv->irq_workqueue);\n}\n\n#define CA8210_MAX_TX_POWERS (9)\nstatic const s32 ca8210_tx_powers[CA8210_MAX_TX_POWERS] = {\n\t800, 700, 600, 500, 400, 300, 200, 100, 0\n};\n\n#define CA8210_MAX_ED_LEVELS (21)\nstatic const s32 ca8210_ed_levels[CA8210_MAX_ED_LEVELS] = {\n\t-10300, -10250, -10200, -10150, -10100, -10050, -10000, -9950, -9900,\n\t-9850, -9800, -9750, -9700, -9650, -9600, -9550, -9500, -9450, -9400,\n\t-9350, -9300\n};\n\n \nstatic void ca8210_hw_setup(struct ieee802154_hw *ca8210_hw)\n{\n\t \n\tca8210_hw->phy->supported.channels[0] = CA8210_VALID_CHANNELS;\n\tca8210_hw->phy->supported.tx_powers_size = CA8210_MAX_TX_POWERS;\n\tca8210_hw->phy->supported.tx_powers = ca8210_tx_powers;\n\tca8210_hw->phy->supported.cca_ed_levels_size = CA8210_MAX_ED_LEVELS;\n\tca8210_hw->phy->supported.cca_ed_levels = ca8210_ed_levels;\n\tca8210_hw->phy->current_channel = 18;\n\tca8210_hw->phy->current_page = 0;\n\tca8210_hw->phy->transmit_power = 800;\n\tca8210_hw->phy->cca.mode = NL802154_CCA_ENERGY_CARRIER;\n\tca8210_hw->phy->cca.opt = NL802154_CCA_OPT_ENERGY_CARRIER_AND;\n\tca8210_hw->phy->cca_ed_level = -9800;\n\tca8210_hw->phy->symbol_duration = 16;\n\tca8210_hw->phy->lifs_period = 40 * ca8210_hw->phy->symbol_duration;\n\tca8210_hw->phy->sifs_period = 12 * ca8210_hw->phy->symbol_duration;\n\tca8210_hw->flags =\n\t\tIEEE802154_HW_AFILT |\n\t\tIEEE802154_HW_OMIT_CKSUM |\n\t\tIEEE802154_HW_FRAME_RETRIES |\n\t\tIEEE802154_HW_PROMISCUOUS |\n\t\tIEEE802154_HW_CSMA_PARAMS;\n\tca8210_hw->phy->flags =\n\t\tWPAN_PHY_FLAG_TXPOWER |\n\t\tWPAN_PHY_FLAG_CCA_ED_LEVEL |\n\t\tWPAN_PHY_FLAG_CCA_MODE |\n\t\tWPAN_PHY_FLAG_DATAGRAMS_ONLY;\n}\n\n \nstatic int ca8210_test_interface_init(struct ca8210_priv *priv)\n{\n\tstruct ca8210_test *test = &priv->test;\n\tchar node_name[32];\n\n\tsnprintf(\n\t\tnode_name,\n\t\tsizeof(node_name),\n\t\t\"ca8210@%d_%d\",\n\t\tpriv->spi->master->bus_num,\n\t\tspi_get_chipselect(priv->spi, 0)\n\t);\n\n\ttest->ca8210_dfs_spi_int = debugfs_create_file(\n\t\tnode_name,\n\t\t0600,  \n\t\tNULL,\n\t\tpriv,\n\t\t&test_int_fops\n\t);\n\n\tdebugfs_create_symlink(\"ca8210\", NULL, node_name);\n\tinit_waitqueue_head(&test->readq);\n\treturn kfifo_alloc(\n\t\t&test->up_fifo,\n\t\tCA8210_TEST_INT_FIFO_SIZE,\n\t\tGFP_KERNEL\n\t);\n}\n\n \nstatic void ca8210_test_interface_clear(struct ca8210_priv *priv)\n{\n\tstruct ca8210_test *test = &priv->test;\n\n\tdebugfs_remove(test->ca8210_dfs_spi_int);\n\tkfifo_free(&test->up_fifo);\n\tdev_info(&priv->spi->dev, \"Test interface removed\\n\");\n}\n\n \nstatic void ca8210_remove(struct spi_device *spi_device)\n{\n\tstruct ca8210_priv *priv;\n\tstruct ca8210_platform_data *pdata;\n\n\tdev_info(&spi_device->dev, \"Removing ca8210\\n\");\n\n\tpdata = spi_device->dev.platform_data;\n\tif (pdata) {\n\t\tif (pdata->extclockenable) {\n\t\t\tca8210_unregister_ext_clock(spi_device);\n\t\t\tca8210_config_extern_clk(pdata, spi_device, 0);\n\t\t}\n\t\tfree_irq(pdata->irq_id, spi_device->dev.driver_data);\n\t\tkfree(pdata);\n\t\tspi_device->dev.platform_data = NULL;\n\t}\n\t \n\tpriv = spi_get_drvdata(spi_device);\n\tif (priv) {\n\t\tdev_info(\n\t\t\t&spi_device->dev,\n\t\t\t\"sync_down = %d, sync_up = %d\\n\",\n\t\t\tpriv->sync_down,\n\t\t\tpriv->sync_up\n\t\t);\n\t\tca8210_dev_com_clear(spi_device->dev.driver_data);\n\t\tif (priv->hw) {\n\t\t\tif (priv->hw_registered)\n\t\t\t\tieee802154_unregister_hw(priv->hw);\n\t\t\tieee802154_free_hw(priv->hw);\n\t\t\tpriv->hw = NULL;\n\t\t\tdev_info(\n\t\t\t\t&spi_device->dev,\n\t\t\t\t\"Unregistered & freed ieee802154_hw.\\n\"\n\t\t\t);\n\t\t}\n\t\tif (IS_ENABLED(CONFIG_IEEE802154_CA8210_DEBUGFS))\n\t\t\tca8210_test_interface_clear(priv);\n\t}\n}\n\n \nstatic int ca8210_probe(struct spi_device *spi_device)\n{\n\tstruct ca8210_priv *priv;\n\tstruct ieee802154_hw *hw;\n\tstruct ca8210_platform_data *pdata;\n\tint ret;\n\n\tdev_info(&spi_device->dev, \"Inserting ca8210\\n\");\n\n\t \n\thw = ieee802154_alloc_hw(sizeof(struct ca8210_priv), &ca8210_phy_ops);\n\tif (!hw) {\n\t\tdev_crit(&spi_device->dev, \"ieee802154_alloc_hw failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tpriv = hw->priv;\n\tpriv->hw = hw;\n\tpriv->spi = spi_device;\n\thw->parent = &spi_device->dev;\n\tspin_lock_init(&priv->lock);\n\tpriv->async_tx_pending = false;\n\tpriv->hw_registered = false;\n\tpriv->sync_up = 0;\n\tpriv->sync_down = 0;\n\tpriv->promiscuous = false;\n\tpriv->retries = 0;\n\tinit_completion(&priv->ca8210_is_awake);\n\tinit_completion(&priv->spi_transfer_complete);\n\tinit_completion(&priv->sync_exchange_complete);\n\tspi_set_drvdata(priv->spi, priv);\n\tif (IS_ENABLED(CONFIG_IEEE802154_CA8210_DEBUGFS)) {\n\t\tcascoda_api_upstream = ca8210_test_int_driver_write;\n\t\tca8210_test_interface_init(priv);\n\t} else {\n\t\tcascoda_api_upstream = NULL;\n\t}\n\tca8210_hw_setup(hw);\n\tieee802154_random_extended_addr(&hw->phy->perm_extended_addr);\n\n\tpdata = kmalloc(sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tpriv->spi->dev.platform_data = pdata;\n\tret = ca8210_get_platform_data(priv->spi, pdata);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"ca8210_get_platform_data failed\\n\");\n\t\tgoto error;\n\t}\n\n\tret = ca8210_dev_com_init(priv);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"ca8210_dev_com_init failed\\n\");\n\t\tgoto error;\n\t}\n\tret = ca8210_reset_init(priv->spi);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"ca8210_reset_init failed\\n\");\n\t\tgoto error;\n\t}\n\n\tret = ca8210_interrupt_init(priv->spi);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"ca8210_interrupt_init failed\\n\");\n\t\tgoto error;\n\t}\n\n\tmsleep(100);\n\n\tca8210_reset_send(priv->spi, 1);\n\n\tret = tdme_chipinit(priv->spi);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"tdme_chipinit failed\\n\");\n\t\tgoto error;\n\t}\n\n\tif (pdata->extclockenable) {\n\t\tret = ca8210_config_extern_clk(pdata, priv->spi, 1);\n\t\tif (ret) {\n\t\t\tdev_crit(\n\t\t\t\t&spi_device->dev,\n\t\t\t\t\"ca8210_config_extern_clk failed\\n\"\n\t\t\t);\n\t\t\tgoto error;\n\t\t}\n\t\tret = ca8210_register_ext_clock(priv->spi);\n\t\tif (ret) {\n\t\t\tdev_crit(\n\t\t\t\t&spi_device->dev,\n\t\t\t\t\"ca8210_register_ext_clock failed\\n\"\n\t\t\t);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tret = ieee802154_register_hw(hw);\n\tif (ret) {\n\t\tdev_crit(&spi_device->dev, \"ieee802154_register_hw failed\\n\");\n\t\tgoto error;\n\t}\n\tpriv->hw_registered = true;\n\n\treturn 0;\nerror:\n\tmsleep(100);  \n\tca8210_remove(spi_device);\n\treturn link_to_linux_err(ret);\n}\n\nstatic const struct of_device_id ca8210_of_ids[] = {\n\t{.compatible = \"cascoda,ca8210\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ca8210_of_ids);\n\nstatic struct spi_driver ca8210_spi_driver = {\n\t.driver = {\n\t\t.name =                 DRIVER_NAME,\n\t\t.of_match_table =       ca8210_of_ids,\n\t},\n\t.probe  =                       ca8210_probe,\n\t.remove =                       ca8210_remove\n};\n\nmodule_spi_driver(ca8210_spi_driver);\n\nMODULE_AUTHOR(\"Harry Morris <h.morris@cascoda.com>\");\nMODULE_DESCRIPTION(\"CA-8210 SoftMAC driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_VERSION(\"1.0\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}