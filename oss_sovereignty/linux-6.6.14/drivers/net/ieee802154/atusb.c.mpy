{
  "module_name": "atusb.c",
  "hash_id": "9e0f449a69bb49fc1a389d97a79799d0446295477b7674825f7a17b45c34cf79",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ieee802154/atusb.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/usb.h>\n#include <linux/skbuff.h>\n\n#include <net/cfg802154.h>\n#include <net/mac802154.h>\n\n#include \"at86rf230.h\"\n#include \"atusb.h\"\n\n#define ATUSB_JEDEC_ATMEL\t0x1f\t \n\n#define ATUSB_NUM_RX_URBS\t4\t \n#define ATUSB_ALLOC_DELAY_MS\t100\t \n#define ATUSB_TX_TIMEOUT_MS\t200\t \n\nstruct atusb {\n\tstruct ieee802154_hw *hw;\n\tstruct usb_device *usb_dev;\n\tstruct atusb_chip_data *data;\n\tint shutdown;\t\t\t \n\tint err;\t\t\t \n\n\t \n\tstruct delayed_work work;\t \n\tstruct usb_anchor idle_urbs;\t \n\tstruct usb_anchor rx_urbs;\t \n\n\t \n\tstruct usb_ctrlrequest tx_dr;\n\tstruct urb *tx_urb;\n\tstruct sk_buff *tx_skb;\n\tu8 tx_ack_seq;\t\t \n\n\t \n\tunsigned char fw_ver_maj;\t \n\tunsigned char fw_ver_min;\t \n\tunsigned char fw_hw_type;\t \n};\n\nstruct atusb_chip_data {\n\tu16 t_channel_switch;\n\tint rssi_base_val;\n\n\tint (*set_channel)(struct ieee802154_hw*, u8, u8);\n\tint (*set_txpower)(struct ieee802154_hw*, s32);\n};\n\nstatic int atusb_write_subreg(struct atusb *atusb, u8 reg, u8 mask,\n\t\t\t      u8 shift, u8 value)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tu8 orig, tmp;\n\tint ret = 0;\n\n\tdev_dbg(&usb_dev->dev, \"%s: 0x%02x <- 0x%02x\\n\", __func__, reg, value);\n\n\tret = usb_control_msg_recv(usb_dev, 0, ATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t   0, reg, &orig, 1, 1000, GFP_KERNEL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\ttmp = orig & ~mask;\n\ttmp |= (value << shift) & mask;\n\n\tif (tmp != orig)\n\t\tret = usb_control_msg_send(usb_dev, 0, ATUSB_REG_WRITE, ATUSB_REQ_TO_DEV,\n\t\t\t\t\t   tmp, reg, NULL, 0, 1000, GFP_KERNEL);\n\n\treturn ret;\n}\n\nstatic int atusb_read_subreg(struct atusb *lp,\n\t\t\t     unsigned int addr, unsigned int mask,\n\t\t\t     unsigned int shift)\n{\n\tint reg, ret;\n\n\tret = usb_control_msg_recv(lp->usb_dev, 0, ATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t   0, addr, &reg, 1, 1000, GFP_KERNEL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treg = (reg & mask) >> shift;\n\n\treturn reg;\n}\n\nstatic int atusb_get_and_clear_error(struct atusb *atusb)\n{\n\tint err = atusb->err;\n\n\tatusb->err = 0;\n\treturn err;\n}\n\n \n\n#define MAX_PSDU\t127\n#define MAX_RX_XFER\t(1 + MAX_PSDU + 2 + 1)\t \n\n#define SKB_ATUSB(skb)\t(*(struct atusb **)(skb)->cb)\n\nstatic void atusb_in(struct urb *urb);\n\nstatic int atusb_submit_rx_urb(struct atusb *atusb, struct urb *urb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tstruct sk_buff *skb = urb->context;\n\tint ret;\n\n\tif (!skb) {\n\t\tskb = alloc_skb(MAX_RX_XFER, GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\tdev_warn_ratelimited(&usb_dev->dev,\n\t\t\t\t\t     \"atusb_in: can't allocate skb\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_put(skb, MAX_RX_XFER);\n\t\tSKB_ATUSB(skb) = atusb;\n\t}\n\n\tusb_fill_bulk_urb(urb, usb_dev, usb_rcvbulkpipe(usb_dev, 1),\n\t\t\t  skb->data, MAX_RX_XFER, atusb_in, skb);\n\tusb_anchor_urb(urb, &atusb->rx_urbs);\n\n\tret = usb_submit_urb(urb, GFP_KERNEL);\n\tif (ret) {\n\t\tusb_unanchor_urb(urb);\n\t\tkfree_skb(skb);\n\t\turb->context = NULL;\n\t}\n\treturn ret;\n}\n\nstatic void atusb_work_urbs(struct work_struct *work)\n{\n\tstruct atusb *atusb =\n\t    container_of(to_delayed_work(work), struct atusb, work);\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tstruct urb *urb;\n\tint ret;\n\n\tif (atusb->shutdown)\n\t\treturn;\n\n\tdo {\n\t\turb = usb_get_from_anchor(&atusb->idle_urbs);\n\t\tif (!urb)\n\t\t\treturn;\n\t\tret = atusb_submit_rx_urb(atusb, urb);\n\t} while (!ret);\n\n\tusb_anchor_urb(urb, &atusb->idle_urbs);\n\tdev_warn_ratelimited(&usb_dev->dev,\n\t\t\t     \"atusb_in: can't allocate/submit URB (%d)\\n\", ret);\n\tschedule_delayed_work(&atusb->work,\n\t\t\t      msecs_to_jiffies(ATUSB_ALLOC_DELAY_MS) + 1);\n}\n\n \n\nstatic void atusb_tx_done(struct atusb *atusb, u8 seq, int reason)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tu8 expect = atusb->tx_ack_seq;\n\n\tdev_dbg(&usb_dev->dev, \"%s (0x%02x/0x%02x)\\n\", __func__, seq, expect);\n\tif (seq == expect) {\n\t\t \n\t\tif (reason == IEEE802154_SUCCESS)\n\t\t\tieee802154_xmit_complete(atusb->hw, atusb->tx_skb, false);\n\t\telse\n\t\t\tieee802154_xmit_error(atusb->hw, atusb->tx_skb, reason);\n\t} else {\n\t\t \n\t\tieee802154_xmit_hw_error(atusb->hw, atusb->tx_skb);\n\t}\n}\n\nstatic void atusb_in_good(struct urb *urb)\n{\n\tstruct usb_device *usb_dev = urb->dev;\n\tstruct sk_buff *skb = urb->context;\n\tstruct atusb *atusb = SKB_ATUSB(skb);\n\tint result = IEEE802154_SUCCESS;\n\tu8 len, lqi, trac;\n\n\tif (!urb->actual_length) {\n\t\tdev_dbg(&usb_dev->dev, \"atusb_in: zero-sized URB ?\\n\");\n\t\treturn;\n\t}\n\n\tlen = *skb->data;\n\n\tswitch (urb->actual_length) {\n\tcase 2:\n\t\ttrac = TRAC_MASK(*(skb->data + 1));\n\t\tswitch (trac) {\n\t\tcase TRAC_SUCCESS:\n\t\tcase TRAC_SUCCESS_DATA_PENDING:\n\t\t\t \n\t\t\tbreak;\n\t\tcase TRAC_CHANNEL_ACCESS_FAILURE:\n\t\t\tresult = IEEE802154_CHANNEL_ACCESS_FAILURE;\n\t\t\tbreak;\n\t\tcase TRAC_NO_ACK:\n\t\t\tresult = IEEE802154_NO_ACK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tresult = IEEE802154_SYSTEM_ERROR;\n\t\t}\n\n\t\tfallthrough;\n\tcase 1:\n\t\tatusb_tx_done(atusb, len, result);\n\t\treturn;\n\t}\n\n\tif (len + 1 > urb->actual_length - 1) {\n\t\tdev_dbg(&usb_dev->dev, \"atusb_in: frame len %d+1 > URB %u-1\\n\",\n\t\t\tlen, urb->actual_length);\n\t\treturn;\n\t}\n\n\tif (!ieee802154_is_valid_psdu_len(len)) {\n\t\tdev_dbg(&usb_dev->dev, \"atusb_in: frame corrupted\\n\");\n\t\treturn;\n\t}\n\n\tlqi = skb->data[len + 1];\n\tdev_dbg(&usb_dev->dev, \"atusb_in: rx len %d lqi 0x%02x\\n\", len, lqi);\n\tskb_pull(skb, 1);\t \n\tskb_trim(skb, len);\t \n\tieee802154_rx_irqsafe(atusb->hw, skb, lqi);\n\turb->context = NULL;\t \n}\n\nstatic void atusb_in(struct urb *urb)\n{\n\tstruct usb_device *usb_dev = urb->dev;\n\tstruct sk_buff *skb = urb->context;\n\tstruct atusb *atusb = SKB_ATUSB(skb);\n\n\tdev_dbg(&usb_dev->dev, \"%s: status %d len %d\\n\", __func__,\n\t\turb->status, urb->actual_length);\n\tif (urb->status) {\n\t\tif (urb->status == -ENOENT) {  \n\t\t\tkfree_skb(skb);\n\t\t\turb->context = NULL;\n\t\t\treturn;\n\t\t}\n\t\tdev_dbg(&usb_dev->dev, \"%s: URB error %d\\n\", __func__, urb->status);\n\t} else {\n\t\tatusb_in_good(urb);\n\t}\n\n\tusb_anchor_urb(urb, &atusb->idle_urbs);\n\tif (!atusb->shutdown)\n\t\tschedule_delayed_work(&atusb->work, 0);\n}\n\n \n\nstatic void atusb_free_urbs(struct atusb *atusb)\n{\n\tstruct urb *urb;\n\n\twhile (1) {\n\t\turb = usb_get_from_anchor(&atusb->idle_urbs);\n\t\tif (!urb)\n\t\t\tbreak;\n\t\tkfree_skb(urb->context);\n\t\tusb_free_urb(urb);\n\t}\n}\n\nstatic int atusb_alloc_urbs(struct atusb *atusb, int n)\n{\n\tstruct urb *urb;\n\n\twhile (n) {\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\tatusb_free_urbs(atusb);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tusb_anchor_urb(urb, &atusb->idle_urbs);\n\t\tusb_free_urb(urb);\n\t\tn--;\n\t}\n\treturn 0;\n}\n\n \n\nstatic void atusb_xmit_complete(struct urb *urb)\n{\n\tdev_dbg(&urb->dev->dev, \"atusb_xmit urb completed\");\n}\n\nstatic int atusb_xmit(struct ieee802154_hw *hw, struct sk_buff *skb)\n{\n\tstruct atusb *atusb = hw->priv;\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\n\tdev_dbg(&usb_dev->dev, \"%s (%d)\\n\", __func__, skb->len);\n\tatusb->tx_skb = skb;\n\tatusb->tx_ack_seq++;\n\tatusb->tx_dr.wIndex = cpu_to_le16(atusb->tx_ack_seq);\n\tatusb->tx_dr.wLength = cpu_to_le16(skb->len);\n\n\tusb_fill_control_urb(atusb->tx_urb, usb_dev,\n\t\t\t     usb_sndctrlpipe(usb_dev, 0),\n\t\t\t     (unsigned char *)&atusb->tx_dr, skb->data,\n\t\t\t     skb->len, atusb_xmit_complete, NULL);\n\tret = usb_submit_urb(atusb->tx_urb, GFP_ATOMIC);\n\tdev_dbg(&usb_dev->dev, \"%s done (%d)\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int atusb_ed(struct ieee802154_hw *hw, u8 *level)\n{\n\tWARN_ON(!level);\n\t*level = 0xbe;\n\treturn 0;\n}\n\nstatic int atusb_set_hw_addr_filt(struct ieee802154_hw *hw,\n\t\t\t\t  struct ieee802154_hw_addr_filt *filt,\n\t\t\t\t  unsigned long changed)\n{\n\tstruct atusb *atusb = hw->priv;\n\tstruct device *dev = &atusb->usb_dev->dev;\n\n\tif (changed & IEEE802154_AFILT_SADDR_CHANGED) {\n\t\tu16 addr = le16_to_cpu(filt->short_addr);\n\n\t\tdev_vdbg(dev, \"%s called for saddr\\n\", __func__);\n\t\tusb_control_msg_send(atusb->usb_dev, 0, ATUSB_REG_WRITE, ATUSB_REQ_TO_DEV,\n\t\t\t\t     addr, RG_SHORT_ADDR_0, NULL, 0, 1000, GFP_KERNEL);\n\n\t\tusb_control_msg_send(atusb->usb_dev, 0, ATUSB_REG_WRITE, ATUSB_REQ_TO_DEV,\n\t\t\t\t     addr >> 8, RG_SHORT_ADDR_1, NULL, 0, 1000, GFP_KERNEL);\n\t}\n\n\tif (changed & IEEE802154_AFILT_PANID_CHANGED) {\n\t\tu16 pan = le16_to_cpu(filt->pan_id);\n\n\t\tdev_vdbg(dev, \"%s called for pan id\\n\", __func__);\n\t\tusb_control_msg_send(atusb->usb_dev, 0, ATUSB_REG_WRITE, ATUSB_REQ_TO_DEV,\n\t\t\t\t     pan, RG_PAN_ID_0, NULL, 0, 1000, GFP_KERNEL);\n\n\t\tusb_control_msg_send(atusb->usb_dev, 0, ATUSB_REG_WRITE, ATUSB_REQ_TO_DEV,\n\t\t\t\t     pan >> 8, RG_PAN_ID_1, NULL, 0, 1000, GFP_KERNEL);\n\t}\n\n\tif (changed & IEEE802154_AFILT_IEEEADDR_CHANGED) {\n\t\tu8 i, addr[IEEE802154_EXTENDED_ADDR_LEN];\n\n\t\tmemcpy(addr, &filt->ieee_addr, IEEE802154_EXTENDED_ADDR_LEN);\n\t\tdev_vdbg(dev, \"%s called for IEEE addr\\n\", __func__);\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tusb_control_msg_send(atusb->usb_dev, 0, ATUSB_REG_WRITE, ATUSB_REQ_TO_DEV,\n\t\t\t\t\t     addr[i], RG_IEEE_ADDR_0 + i, NULL, 0,\n\t\t\t\t\t     1000, GFP_KERNEL);\n\t}\n\n\tif (changed & IEEE802154_AFILT_PANC_CHANGED) {\n\t\tdev_vdbg(dev, \"%s called for panc change\\n\", __func__);\n\t\tif (filt->pan_coord)\n\t\t\tatusb_write_subreg(atusb, SR_AACK_I_AM_COORD, 1);\n\t\telse\n\t\t\tatusb_write_subreg(atusb, SR_AACK_I_AM_COORD, 0);\n\t}\n\n\treturn atusb_get_and_clear_error(atusb);\n}\n\nstatic int atusb_start(struct ieee802154_hw *hw)\n{\n\tstruct atusb *atusb = hw->priv;\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\n\tdev_dbg(&usb_dev->dev, \"%s\\n\", __func__);\n\tschedule_delayed_work(&atusb->work, 0);\n\tusb_control_msg_send(atusb->usb_dev, 0, ATUSB_RX_MODE, ATUSB_REQ_TO_DEV, 1, 0,\n\t\t\t     NULL, 0, 1000, GFP_KERNEL);\n\tret = atusb_get_and_clear_error(atusb);\n\tif (ret < 0)\n\t\tusb_kill_anchored_urbs(&atusb->idle_urbs);\n\treturn ret;\n}\n\nstatic void atusb_stop(struct ieee802154_hw *hw)\n{\n\tstruct atusb *atusb = hw->priv;\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\n\tdev_dbg(&usb_dev->dev, \"%s\\n\", __func__);\n\tusb_kill_anchored_urbs(&atusb->idle_urbs);\n\tusb_control_msg_send(atusb->usb_dev, 0, ATUSB_RX_MODE, ATUSB_REQ_TO_DEV, 0, 0,\n\t\t\t     NULL, 0, 1000, GFP_KERNEL);\n\tatusb_get_and_clear_error(atusb);\n}\n\n#define ATUSB_MAX_TX_POWERS 0xF\nstatic const s32 atusb_powers[ATUSB_MAX_TX_POWERS + 1] = {\n\t300, 280, 230, 180, 130, 70, 0, -100, -200, -300, -400, -500, -700,\n\t-900, -1200, -1700,\n};\n\nstatic int\natusb_txpower(struct ieee802154_hw *hw, s32 mbm)\n{\n\tstruct atusb *atusb = hw->priv;\n\n\tif (atusb->data)\n\t\treturn atusb->data->set_txpower(hw, mbm);\n\telse\n\t\treturn -ENOTSUPP;\n}\n\nstatic int\natusb_set_txpower(struct ieee802154_hw *hw, s32 mbm)\n{\n\tstruct atusb *atusb = hw->priv;\n\tu32 i;\n\n\tfor (i = 0; i < hw->phy->supported.tx_powers_size; i++) {\n\t\tif (hw->phy->supported.tx_powers[i] == mbm)\n\t\t\treturn atusb_write_subreg(atusb, SR_TX_PWR_23X, i);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\nhulusb_set_txpower(struct ieee802154_hw *hw, s32 mbm)\n{\n\tu32 i;\n\n\tfor (i = 0; i < hw->phy->supported.tx_powers_size; i++) {\n\t\tif (hw->phy->supported.tx_powers[i] == mbm)\n\t\t\treturn atusb_write_subreg(hw->priv, SR_TX_PWR_212, i);\n\t}\n\n\treturn -EINVAL;\n}\n\n#define ATUSB_MAX_ED_LEVELS 0xF\nstatic const s32 atusb_ed_levels[ATUSB_MAX_ED_LEVELS + 1] = {\n\t-9100, -8900, -8700, -8500, -8300, -8100, -7900, -7700, -7500, -7300,\n\t-7100, -6900, -6700, -6500, -6300, -6100,\n};\n\n#define AT86RF212_MAX_TX_POWERS 0x1F\nstatic const s32 at86rf212_powers[AT86RF212_MAX_TX_POWERS + 1] = {\n\t500, 400, 300, 200, 100, 0, -100, -200, -300, -400, -500, -600, -700,\n\t-800, -900, -1000, -1100, -1200, -1300, -1400, -1500, -1600, -1700,\n\t-1800, -1900, -2000, -2100, -2200, -2300, -2400, -2500, -2600,\n};\n\n#define AT86RF2XX_MAX_ED_LEVELS 0xF\nstatic const s32 at86rf212_ed_levels_100[AT86RF2XX_MAX_ED_LEVELS + 1] = {\n\t-10000, -9800, -9600, -9400, -9200, -9000, -8800, -8600, -8400, -8200,\n\t-8000, -7800, -7600, -7400, -7200, -7000,\n};\n\nstatic const s32 at86rf212_ed_levels_98[AT86RF2XX_MAX_ED_LEVELS + 1] = {\n\t-9800, -9600, -9400, -9200, -9000, -8800, -8600, -8400, -8200, -8000,\n\t-7800, -7600, -7400, -7200, -7000, -6800,\n};\n\nstatic int\natusb_set_cca_mode(struct ieee802154_hw *hw, const struct wpan_phy_cca *cca)\n{\n\tstruct atusb *atusb = hw->priv;\n\tu8 val;\n\n\t \n\tswitch (cca->mode) {\n\tcase NL802154_CCA_ENERGY:\n\t\tval = 1;\n\t\tbreak;\n\tcase NL802154_CCA_CARRIER:\n\t\tval = 2;\n\t\tbreak;\n\tcase NL802154_CCA_ENERGY_CARRIER:\n\t\tswitch (cca->opt) {\n\t\tcase NL802154_CCA_OPT_ENERGY_CARRIER_AND:\n\t\t\tval = 3;\n\t\t\tbreak;\n\t\tcase NL802154_CCA_OPT_ENERGY_CARRIER_OR:\n\t\t\tval = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn atusb_write_subreg(atusb, SR_CCA_MODE, val);\n}\n\nstatic int hulusb_set_cca_ed_level(struct atusb *lp, int rssi_base_val)\n{\n\tint cca_ed_thres;\n\n\tcca_ed_thres = atusb_read_subreg(lp, SR_CCA_ED_THRES);\n\tif (cca_ed_thres < 0)\n\t\treturn cca_ed_thres;\n\n\tswitch (rssi_base_val) {\n\tcase -98:\n\t\tlp->hw->phy->supported.cca_ed_levels = at86rf212_ed_levels_98;\n\t\tlp->hw->phy->supported.cca_ed_levels_size = ARRAY_SIZE(at86rf212_ed_levels_98);\n\t\tlp->hw->phy->cca_ed_level = at86rf212_ed_levels_98[cca_ed_thres];\n\t\tbreak;\n\tcase -100:\n\t\tlp->hw->phy->supported.cca_ed_levels = at86rf212_ed_levels_100;\n\t\tlp->hw->phy->supported.cca_ed_levels_size = ARRAY_SIZE(at86rf212_ed_levels_100);\n\t\tlp->hw->phy->cca_ed_level = at86rf212_ed_levels_100[cca_ed_thres];\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\treturn 0;\n}\n\nstatic int\natusb_set_cca_ed_level(struct ieee802154_hw *hw, s32 mbm)\n{\n\tstruct atusb *atusb = hw->priv;\n\tu32 i;\n\n\tfor (i = 0; i < hw->phy->supported.cca_ed_levels_size; i++) {\n\t\tif (hw->phy->supported.cca_ed_levels[i] == mbm)\n\t\t\treturn atusb_write_subreg(atusb, SR_CCA_ED_THRES, i);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int atusb_channel(struct ieee802154_hw *hw, u8 page, u8 channel)\n{\n\tstruct atusb *atusb = hw->priv;\n\tint ret = -ENOTSUPP;\n\n\tif (atusb->data) {\n\t\tret = atusb->data->set_channel(hw, page, channel);\n\t\t \n\t\tmsleep(atusb->data->t_channel_switch);\n\t}\n\n\treturn ret;\n}\n\nstatic int atusb_set_channel(struct ieee802154_hw *hw, u8 page, u8 channel)\n{\n\tstruct atusb *atusb = hw->priv;\n\tint ret;\n\n\tret = atusb_write_subreg(atusb, SR_CHANNEL, channel);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\nstatic int hulusb_set_channel(struct ieee802154_hw *hw, u8 page, u8 channel)\n{\n\tint rc;\n\tint rssi_base_val;\n\n\tstruct atusb *lp = hw->priv;\n\n\tif (channel == 0)\n\t\trc = atusb_write_subreg(lp, SR_SUB_MODE, 0);\n\telse\n\t\trc = atusb_write_subreg(lp, SR_SUB_MODE, 1);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (page == 0) {\n\t\trc = atusb_write_subreg(lp, SR_BPSK_QPSK, 0);\n\t\trssi_base_val = -100;\n\t} else {\n\t\trc = atusb_write_subreg(lp, SR_BPSK_QPSK, 1);\n\t\trssi_base_val = -98;\n\t}\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = hulusb_set_cca_ed_level(lp, rssi_base_val);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn atusb_write_subreg(lp, SR_CHANNEL, channel);\n}\n\nstatic int\natusb_set_csma_params(struct ieee802154_hw *hw, u8 min_be, u8 max_be, u8 retries)\n{\n\tstruct atusb *atusb = hw->priv;\n\tint ret;\n\n\tret = atusb_write_subreg(atusb, SR_MIN_BE, min_be);\n\tif (ret)\n\t\treturn ret;\n\n\tret = atusb_write_subreg(atusb, SR_MAX_BE, max_be);\n\tif (ret)\n\t\treturn ret;\n\n\treturn atusb_write_subreg(atusb, SR_MAX_CSMA_RETRIES, retries);\n}\n\nstatic int\nhulusb_set_lbt(struct ieee802154_hw *hw, bool on)\n{\n\tstruct atusb *atusb = hw->priv;\n\n\treturn atusb_write_subreg(atusb, SR_CSMA_LBT_MODE, on);\n}\n\nstatic int\natusb_set_frame_retries(struct ieee802154_hw *hw, s8 retries)\n{\n\tstruct atusb *atusb = hw->priv;\n\n\treturn atusb_write_subreg(atusb, SR_MAX_FRAME_RETRIES, retries);\n}\n\nstatic int\natusb_set_promiscuous_mode(struct ieee802154_hw *hw, const bool on)\n{\n\tstruct atusb *atusb = hw->priv;\n\tint ret;\n\n\tif (on) {\n\t\tret = atusb_write_subreg(atusb, SR_AACK_DIS_ACK, 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = atusb_write_subreg(atusb, SR_AACK_PROM_MODE, 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tret = atusb_write_subreg(atusb, SR_AACK_PROM_MODE, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = atusb_write_subreg(atusb, SR_AACK_DIS_ACK, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct atusb_chip_data atusb_chip_data = {\n\t.t_channel_switch = 1,\n\t.rssi_base_val = -91,\n\t.set_txpower = atusb_set_txpower,\n\t.set_channel = atusb_set_channel,\n};\n\nstatic struct atusb_chip_data hulusb_chip_data = {\n\t.t_channel_switch = 11,\n\t.rssi_base_val = -100,\n\t.set_txpower = hulusb_set_txpower,\n\t.set_channel = hulusb_set_channel,\n};\n\nstatic const struct ieee802154_ops atusb_ops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.xmit_async\t\t= atusb_xmit,\n\t.ed\t\t\t= atusb_ed,\n\t.set_channel\t\t= atusb_channel,\n\t.start\t\t\t= atusb_start,\n\t.stop\t\t\t= atusb_stop,\n\t.set_hw_addr_filt\t= atusb_set_hw_addr_filt,\n\t.set_txpower\t\t= atusb_txpower,\n\t.set_lbt\t\t= hulusb_set_lbt,\n\t.set_cca_mode\t\t= atusb_set_cca_mode,\n\t.set_cca_ed_level\t= atusb_set_cca_ed_level,\n\t.set_csma_params\t= atusb_set_csma_params,\n\t.set_frame_retries\t= atusb_set_frame_retries,\n\t.set_promiscuous_mode\t= atusb_set_promiscuous_mode,\n};\n\n \n\nstatic int atusb_get_and_show_revision(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tchar *hw_name;\n\tunsigned char buffer[3];\n\tint ret;\n\n\t \n\tret = usb_control_msg_recv(atusb->usb_dev, 0, ATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\t   buffer, 3, 1000, GFP_KERNEL);\n\tif (!ret) {\n\t\tatusb->fw_ver_maj = buffer[0];\n\t\tatusb->fw_ver_min = buffer[1];\n\t\tatusb->fw_hw_type = buffer[2];\n\n\t\tswitch (atusb->fw_hw_type) {\n\t\tcase ATUSB_HW_TYPE_100813:\n\t\tcase ATUSB_HW_TYPE_101216:\n\t\tcase ATUSB_HW_TYPE_110131:\n\t\t\thw_name = \"ATUSB\";\n\t\t\tatusb->data = &atusb_chip_data;\n\t\t\tbreak;\n\t\tcase ATUSB_HW_TYPE_RZUSB:\n\t\t\thw_name = \"RZUSB\";\n\t\t\tatusb->data = &atusb_chip_data;\n\t\t\tbreak;\n\t\tcase ATUSB_HW_TYPE_HULUSB:\n\t\t\thw_name = \"HULUSB\";\n\t\t\tatusb->data = &hulusb_chip_data;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thw_name = \"UNKNOWN\";\n\t\t\tatusb->err = -ENOTSUPP;\n\t\t\tret = -ENOTSUPP;\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware: major: %u, minor: %u, hardware type: %s (%d)\\n\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min, hw_name,\n\t\t\t atusb->fw_hw_type);\n\t}\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware version (%u.%u) predates our first public release.\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);\n\t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n\t}\n\n\treturn ret;\n}\n\nstatic int atusb_get_and_show_build(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tchar *build;\n\tint ret;\n\n\tbuild = kmalloc(ATUSB_BUILD_SIZE + 1, GFP_KERNEL);\n\tif (!build)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(atusb->usb_dev, usb_rcvctrlpipe(usb_dev, 0), ATUSB_BUILD,\n\t\t\t      ATUSB_REQ_FROM_DEV, 0, 0, build, ATUSB_BUILD_SIZE, 1000);\n\tif (ret >= 0) {\n\t\tbuild[ret] = 0;\n\t\tdev_info(&usb_dev->dev, \"Firmware: build %s\\n\", build);\n\t}\n\n\tkfree(build);\n\treturn ret;\n}\n\nstatic int atusb_get_and_conf_chip(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tu8 man_id_0, man_id_1, part_num, version_num;\n\tconst char *chip;\n\tstruct ieee802154_hw *hw = atusb->hw;\n\tint ret;\n\n\tret = usb_control_msg_recv(usb_dev, 0, ATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t   0, RG_MAN_ID_0, &man_id_0, 1, 1000, GFP_KERNEL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = usb_control_msg_recv(usb_dev, 0, ATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t   0, RG_MAN_ID_1, &man_id_1, 1, 1000, GFP_KERNEL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = usb_control_msg_recv(usb_dev, 0, ATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t   0, RG_PART_NUM, &part_num, 1, 1000, GFP_KERNEL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = usb_control_msg_recv(usb_dev, 0, ATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t   0, RG_VERSION_NUM, &version_num, 1, 1000, GFP_KERNEL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thw->flags = IEEE802154_HW_TX_OMIT_CKSUM | IEEE802154_HW_AFILT |\n\t\t    IEEE802154_HW_PROMISCUOUS | IEEE802154_HW_CSMA_PARAMS;\n\n\thw->phy->flags = WPAN_PHY_FLAG_TXPOWER | WPAN_PHY_FLAG_CCA_ED_LEVEL |\n\t\t\t WPAN_PHY_FLAG_CCA_MODE;\n\n\thw->phy->supported.cca_modes = BIT(NL802154_CCA_ENERGY) |\n\t\t\t\t       BIT(NL802154_CCA_CARRIER) |\n\t\t\t\t       BIT(NL802154_CCA_ENERGY_CARRIER);\n\thw->phy->supported.cca_opts = BIT(NL802154_CCA_OPT_ENERGY_CARRIER_AND) |\n\t\t\t\t      BIT(NL802154_CCA_OPT_ENERGY_CARRIER_OR);\n\n\thw->phy->cca.mode = NL802154_CCA_ENERGY;\n\n\thw->phy->current_page = 0;\n\n\tif ((man_id_1 << 8 | man_id_0) != ATUSB_JEDEC_ATMEL) {\n\t\tdev_err(&usb_dev->dev,\n\t\t\t\"non-Atmel transceiver xxxx%02x%02x\\n\",\n\t\t\tman_id_1, man_id_0);\n\t\tgoto fail;\n\t}\n\n\tswitch (part_num) {\n\tcase 2:\n\t\tchip = \"AT86RF230\";\n\t\tatusb->hw->phy->supported.channels[0] = 0x7FFF800;\n\t\tatusb->hw->phy->current_channel = 11;\t \n\t\tatusb->hw->phy->supported.tx_powers = atusb_powers;\n\t\tatusb->hw->phy->supported.tx_powers_size = ARRAY_SIZE(atusb_powers);\n\t\thw->phy->supported.cca_ed_levels = atusb_ed_levels;\n\t\thw->phy->supported.cca_ed_levels_size = ARRAY_SIZE(atusb_ed_levels);\n\t\tbreak;\n\tcase 3:\n\t\tchip = \"AT86RF231\";\n\t\tatusb->hw->phy->supported.channels[0] = 0x7FFF800;\n\t\tatusb->hw->phy->current_channel = 11;\t \n\t\tatusb->hw->phy->supported.tx_powers = atusb_powers;\n\t\tatusb->hw->phy->supported.tx_powers_size = ARRAY_SIZE(atusb_powers);\n\t\thw->phy->supported.cca_ed_levels = atusb_ed_levels;\n\t\thw->phy->supported.cca_ed_levels_size = ARRAY_SIZE(atusb_ed_levels);\n\t\tbreak;\n\tcase 7:\n\t\tchip = \"AT86RF212\";\n\t\tatusb->hw->flags |= IEEE802154_HW_LBT;\n\t\tatusb->hw->phy->supported.channels[0] = 0x00007FF;\n\t\tatusb->hw->phy->supported.channels[2] = 0x00007FF;\n\t\tatusb->hw->phy->current_channel = 5;\n\t\tatusb->hw->phy->supported.lbt = NL802154_SUPPORTED_BOOL_BOTH;\n\t\tatusb->hw->phy->supported.tx_powers = at86rf212_powers;\n\t\tatusb->hw->phy->supported.tx_powers_size = ARRAY_SIZE(at86rf212_powers);\n\t\tatusb->hw->phy->supported.cca_ed_levels = at86rf212_ed_levels_100;\n\t\tatusb->hw->phy->supported.cca_ed_levels_size = ARRAY_SIZE(at86rf212_ed_levels_100);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&usb_dev->dev,\n\t\t\t\"unexpected transceiver, part 0x%02x version 0x%02x\\n\",\n\t\t\tpart_num, version_num);\n\t\tgoto fail;\n\t}\n\n\thw->phy->transmit_power = hw->phy->supported.tx_powers[0];\n\thw->phy->cca_ed_level = hw->phy->supported.cca_ed_levels[7];\n\n\tdev_info(&usb_dev->dev, \"ATUSB: %s version %d\\n\", chip, version_num);\n\n\treturn 0;\n\nfail:\n\tatusb->err = -ENODEV;\n\treturn -ENODEV;\n}\n\nstatic int atusb_set_extended_addr(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char buffer[IEEE802154_EXTENDED_ADDR_LEN];\n\t__le64 extended_addr;\n\tu64 addr;\n\tint ret;\n\n\t \n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 3) {\n\t\tieee802154_random_extended_addr(&atusb->hw->phy->perm_extended_addr);\n\t\treturn 0;\n\t}\n\n\t \n\tret = usb_control_msg_recv(atusb->usb_dev, 0, ATUSB_EUI64_READ, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\t   buffer, IEEE802154_EXTENDED_ADDR_LEN, 1000, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tdev_err(&usb_dev->dev, \"failed to fetch extended address, random address set\\n\");\n\t\tieee802154_random_extended_addr(&atusb->hw->phy->perm_extended_addr);\n\t\treturn ret;\n\t}\n\n\tmemcpy(&extended_addr, buffer, IEEE802154_EXTENDED_ADDR_LEN);\n\t \n\tif (!ieee802154_is_valid_extended_unicast_addr(extended_addr)) {\n\t\tdev_info(&usb_dev->dev, \"no permanent extended address found, random address set\\n\");\n\t\tieee802154_random_extended_addr(&atusb->hw->phy->perm_extended_addr);\n\t} else {\n\t\tatusb->hw->phy->perm_extended_addr = extended_addr;\n\t\taddr = swab64((__force u64)atusb->hw->phy->perm_extended_addr);\n\t\tdev_info(&usb_dev->dev, \"Read permanent extended address %8phC from device\\n\",\n\t\t\t &addr);\n\t}\n\n\treturn ret;\n}\n\n \n\nstatic int atusb_probe(struct usb_interface *interface,\n\t\t       const struct usb_device_id *id)\n{\n\tstruct usb_device *usb_dev = interface_to_usbdev(interface);\n\tstruct ieee802154_hw *hw;\n\tstruct atusb *atusb = NULL;\n\tint ret = -ENOMEM;\n\n\thw = ieee802154_alloc_hw(sizeof(struct atusb), &atusb_ops);\n\tif (!hw)\n\t\treturn -ENOMEM;\n\n\tatusb = hw->priv;\n\tatusb->hw = hw;\n\tatusb->usb_dev = usb_get_dev(usb_dev);\n\tusb_set_intfdata(interface, atusb);\n\n\tatusb->shutdown = 0;\n\tatusb->err = 0;\n\tINIT_DELAYED_WORK(&atusb->work, atusb_work_urbs);\n\tinit_usb_anchor(&atusb->idle_urbs);\n\tinit_usb_anchor(&atusb->rx_urbs);\n\n\tif (atusb_alloc_urbs(atusb, ATUSB_NUM_RX_URBS))\n\t\tgoto fail;\n\n\tatusb->tx_dr.bRequestType = ATUSB_REQ_TO_DEV;\n\tatusb->tx_dr.bRequest = ATUSB_TX;\n\tatusb->tx_dr.wValue = cpu_to_le16(0);\n\n\tatusb->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!atusb->tx_urb)\n\t\tgoto fail;\n\n\thw->parent = &usb_dev->dev;\n\n\tusb_control_msg_send(atusb->usb_dev, 0, ATUSB_RF_RESET, ATUSB_REQ_TO_DEV, 0, 0,\n\t\t\t     NULL, 0, 1000, GFP_KERNEL);\n\tatusb_get_and_conf_chip(atusb);\n\tatusb_get_and_show_revision(atusb);\n\tatusb_get_and_show_build(atusb);\n\tatusb_set_extended_addr(atusb);\n\n\tif ((atusb->fw_ver_maj == 0 && atusb->fw_ver_min >= 3) || atusb->fw_ver_maj > 0)\n\t\thw->flags |= IEEE802154_HW_FRAME_RETRIES;\n\n\tret = atusb_get_and_clear_error(atusb);\n\tif (ret) {\n\t\tdev_err(&atusb->usb_dev->dev,\n\t\t\t\"%s: initialization failed, error = %d\\n\",\n\t\t\t__func__, ret);\n\t\tgoto fail;\n\t}\n\n\tret = ieee802154_register_hw(hw);\n\tif (ret)\n\t\tgoto fail;\n\n\t \n\tusb_control_msg_send(atusb->usb_dev, 0, ATUSB_REG_WRITE, ATUSB_REQ_TO_DEV,\n\t\t\t     STATE_FORCE_TRX_OFF, RG_TRX_STATE, NULL, 0, 1000, GFP_KERNEL);\n\n\tmsleep(1);\t \n\n#if 0\n\t \n\n\tatusb_write_subreg(atusb, SR_RX_SAFE_MODE, 1);\n#endif\n\tusb_control_msg_send(atusb->usb_dev, 0, ATUSB_REG_WRITE, ATUSB_REQ_TO_DEV,\n\t\t\t     0xff, RG_IRQ_MASK, NULL, 0, 1000, GFP_KERNEL);\n\n\tret = atusb_get_and_clear_error(atusb);\n\tif (!ret)\n\t\treturn 0;\n\n\tdev_err(&atusb->usb_dev->dev,\n\t\t\"%s: setup failed, error = %d\\n\",\n\t\t__func__, ret);\n\n\tieee802154_unregister_hw(hw);\nfail:\n\tatusb_free_urbs(atusb);\n\tusb_kill_urb(atusb->tx_urb);\n\tusb_free_urb(atusb->tx_urb);\n\tusb_put_dev(usb_dev);\n\tieee802154_free_hw(hw);\n\treturn ret;\n}\n\nstatic void atusb_disconnect(struct usb_interface *interface)\n{\n\tstruct atusb *atusb = usb_get_intfdata(interface);\n\n\tdev_dbg(&atusb->usb_dev->dev, \"%s\\n\", __func__);\n\n\tatusb->shutdown = 1;\n\tcancel_delayed_work_sync(&atusb->work);\n\n\tusb_kill_anchored_urbs(&atusb->rx_urbs);\n\tatusb_free_urbs(atusb);\n\tusb_kill_urb(atusb->tx_urb);\n\tusb_free_urb(atusb->tx_urb);\n\n\tieee802154_unregister_hw(atusb->hw);\n\n\tusb_put_dev(atusb->usb_dev);\n\n\tieee802154_free_hw(atusb->hw);\n\n\tusb_set_intfdata(interface, NULL);\n\n\tpr_debug(\"%s done\\n\", __func__);\n}\n\n \nstatic const struct usb_device_id atusb_device_table[] = {\n\t{\n\t\t.match_flags\t\t= USB_DEVICE_ID_MATCH_DEVICE |\n\t\t\t\t\t  USB_DEVICE_ID_MATCH_INT_INFO,\n\t\t.idVendor\t\t= ATUSB_VENDOR_ID,\n\t\t.idProduct\t\t= ATUSB_PRODUCT_ID,\n\t\t.bInterfaceClass\t= USB_CLASS_VENDOR_SPEC\n\t},\n\t \n\t{}\n};\nMODULE_DEVICE_TABLE(usb, atusb_device_table);\n\nstatic struct usb_driver atusb_driver = {\n\t.name\t\t= \"atusb\",\n\t.probe\t\t= atusb_probe,\n\t.disconnect\t= atusb_disconnect,\n\t.id_table\t= atusb_device_table,\n};\nmodule_usb_driver(atusb_driver);\n\nMODULE_AUTHOR(\"Alexander Aring <alex.aring@gmail.com>\");\nMODULE_AUTHOR(\"Richard Sharpe <realrichardsharpe@gmail.com>\");\nMODULE_AUTHOR(\"Stefan Schmidt <stefan@datenfreihafen.org>\");\nMODULE_AUTHOR(\"Werner Almesberger <werner@almesberger.net>\");\nMODULE_AUTHOR(\"Josef Filzmaier <j.filzmaier@gmx.at>\");\nMODULE_DESCRIPTION(\"ATUSB IEEE 802.15.4 Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}