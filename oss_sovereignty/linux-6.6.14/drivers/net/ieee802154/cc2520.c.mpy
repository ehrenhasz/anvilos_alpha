{
  "module_name": "cc2520.c",
  "hash_id": "d543030afbdf1df0a19af67948681a2ccaec7179acc81ef96fdf3ff174d4f351",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ieee802154/cc2520.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/gpio/consumer.h>\n#include <linux/delay.h>\n#include <linux/spi/spi.h>\n#include <linux/property.h>\n#include <linux/workqueue.h>\n#include <linux/interrupt.h>\n#include <linux/skbuff.h>\n#include <linux/ieee802154.h>\n#include <linux/crc-ccitt.h>\n#include <asm/unaligned.h>\n\n#include <net/mac802154.h>\n#include <net/cfg802154.h>\n\n#define\tSPI_COMMAND_BUFFER\t3\n#define\tHIGH\t\t\t1\n#define\tLOW\t\t\t0\n#define\tSTATE_IDLE\t\t0\n#define\tRSSI_VALID\t\t0\n#define\tRSSI_OFFSET\t\t78\n\n#define\tCC2520_RAM_SIZE\t\t640\n#define\tCC2520_FIFO_SIZE\t128\n\n#define\tCC2520RAM_TXFIFO\t0x100\n#define\tCC2520RAM_RXFIFO\t0x180\n#define\tCC2520RAM_IEEEADDR\t0x3EA\n#define\tCC2520RAM_PANID\t\t0x3F2\n#define\tCC2520RAM_SHORTADDR\t0x3F4\n\n#define\tCC2520_FREG_MASK\t0x3F\n\n \n#define\tCC2520_STATUS_XOSC32M_STABLE\tBIT(7)\n#define\tCC2520_STATUS_RSSI_VALID\tBIT(6)\n#define\tCC2520_STATUS_TX_UNDERFLOW\tBIT(3)\n\n \n#define\tCC2520_MINCHANNEL\t\t11\n#define\tCC2520_MAXCHANNEL\t\t26\n#define\tCC2520_CHANNEL_SPACING\t\t5\n\n \n#define\tCC2520_CMD_SNOP\t\t\t0x00\n#define\tCC2520_CMD_IBUFLD\t\t0x02\n#define\tCC2520_CMD_SIBUFEX\t\t0x03\n#define\tCC2520_CMD_SSAMPLECCA\t\t0x04\n#define\tCC2520_CMD_SRES\t\t\t0x0f\n#define\tCC2520_CMD_MEMORY_MASK\t\t0x0f\n#define\tCC2520_CMD_MEMORY_READ\t\t0x10\n#define\tCC2520_CMD_MEMORY_WRITE\t\t0x20\n#define\tCC2520_CMD_RXBUF\t\t0x30\n#define\tCC2520_CMD_RXBUFCP\t\t0x38\n#define\tCC2520_CMD_RXBUFMOV\t\t0x32\n#define\tCC2520_CMD_TXBUF\t\t0x3A\n#define\tCC2520_CMD_TXBUFCP\t\t0x3E\n#define\tCC2520_CMD_RANDOM\t\t0x3C\n#define\tCC2520_CMD_SXOSCON\t\t0x40\n#define\tCC2520_CMD_STXCAL\t\t0x41\n#define\tCC2520_CMD_SRXON\t\t0x42\n#define\tCC2520_CMD_STXON\t\t0x43\n#define\tCC2520_CMD_STXONCCA\t\t0x44\n#define\tCC2520_CMD_SRFOFF\t\t0x45\n#define\tCC2520_CMD_SXOSCOFF\t\t0x46\n#define\tCC2520_CMD_SFLUSHRX\t\t0x47\n#define\tCC2520_CMD_SFLUSHTX\t\t0x48\n#define\tCC2520_CMD_SACK\t\t\t0x49\n#define\tCC2520_CMD_SACKPEND\t\t0x4A\n#define\tCC2520_CMD_SNACK\t\t0x4B\n#define\tCC2520_CMD_SRXMASKBITSET\t0x4C\n#define\tCC2520_CMD_SRXMASKBITCLR\t0x4D\n#define\tCC2520_CMD_RXMASKAND\t\t0x4E\n#define\tCC2520_CMD_RXMASKOR\t\t0x4F\n#define\tCC2520_CMD_MEMCP\t\t0x50\n#define\tCC2520_CMD_MEMCPR\t\t0x52\n#define\tCC2520_CMD_MEMXCP\t\t0x54\n#define\tCC2520_CMD_MEMXWR\t\t0x56\n#define\tCC2520_CMD_BCLR\t\t\t0x58\n#define\tCC2520_CMD_BSET\t\t\t0x59\n#define\tCC2520_CMD_CTR_UCTR\t\t0x60\n#define\tCC2520_CMD_CBCMAC\t\t0x64\n#define\tCC2520_CMD_UCBCMAC\t\t0x66\n#define\tCC2520_CMD_CCM\t\t\t0x68\n#define\tCC2520_CMD_UCCM\t\t\t0x6A\n#define\tCC2520_CMD_ECB\t\t\t0x70\n#define\tCC2520_CMD_ECBO\t\t\t0x72\n#define\tCC2520_CMD_ECBX\t\t\t0x74\n#define\tCC2520_CMD_INC\t\t\t0x78\n#define\tCC2520_CMD_ABORT\t\t0x7F\n#define\tCC2520_CMD_REGISTER_READ\t0x80\n#define\tCC2520_CMD_REGISTER_WRITE\t0xC0\n\n \n#define\tCC2520_CHIPID\t\t\t0x40\n#define\tCC2520_VERSION\t\t\t0x42\n#define\tCC2520_EXTCLOCK\t\t\t0x44\n#define\tCC2520_MDMCTRL0\t\t\t0x46\n#define\tCC2520_MDMCTRL1\t\t\t0x47\n#define\tCC2520_FREQEST\t\t\t0x48\n#define\tCC2520_RXCTRL\t\t\t0x4A\n#define\tCC2520_FSCTRL\t\t\t0x4C\n#define\tCC2520_FSCAL0\t\t\t0x4E\n#define\tCC2520_FSCAL1\t\t\t0x4F\n#define\tCC2520_FSCAL2\t\t\t0x50\n#define\tCC2520_FSCAL3\t\t\t0x51\n#define\tCC2520_AGCCTRL0\t\t\t0x52\n#define\tCC2520_AGCCTRL1\t\t\t0x53\n#define\tCC2520_AGCCTRL2\t\t\t0x54\n#define\tCC2520_AGCCTRL3\t\t\t0x55\n#define\tCC2520_ADCTEST0\t\t\t0x56\n#define\tCC2520_ADCTEST1\t\t\t0x57\n#define\tCC2520_ADCTEST2\t\t\t0x58\n#define\tCC2520_MDMTEST0\t\t\t0x5A\n#define\tCC2520_MDMTEST1\t\t\t0x5B\n#define\tCC2520_DACTEST0\t\t\t0x5C\n#define\tCC2520_DACTEST1\t\t\t0x5D\n#define\tCC2520_ATEST\t\t\t0x5E\n#define\tCC2520_DACTEST2\t\t\t0x5F\n#define\tCC2520_PTEST0\t\t\t0x60\n#define\tCC2520_PTEST1\t\t\t0x61\n#define\tCC2520_RESERVED\t\t\t0x62\n#define\tCC2520_DPUBIST\t\t\t0x7A\n#define\tCC2520_ACTBIST\t\t\t0x7C\n#define\tCC2520_RAMBIST\t\t\t0x7E\n\n \n#define\tCC2520_FRMFILT0\t\t\t0x00\n#define\tCC2520_FRMFILT1\t\t\t0x01\n#define\tCC2520_SRCMATCH\t\t\t0x02\n#define\tCC2520_SRCSHORTEN0\t\t0x04\n#define\tCC2520_SRCSHORTEN1\t\t0x05\n#define\tCC2520_SRCSHORTEN2\t\t0x06\n#define\tCC2520_SRCEXTEN0\t\t0x08\n#define\tCC2520_SRCEXTEN1\t\t0x09\n#define\tCC2520_SRCEXTEN2\t\t0x0A\n#define\tCC2520_FRMCTRL0\t\t\t0x0C\n#define\tCC2520_FRMCTRL1\t\t\t0x0D\n#define\tCC2520_RXENABLE0\t\t0x0E\n#define\tCC2520_RXENABLE1\t\t0x0F\n#define\tCC2520_EXCFLAG0\t\t\t0x10\n#define\tCC2520_EXCFLAG1\t\t\t0x11\n#define\tCC2520_EXCFLAG2\t\t\t0x12\n#define\tCC2520_EXCMASKA0\t\t0x14\n#define\tCC2520_EXCMASKA1\t\t0x15\n#define\tCC2520_EXCMASKA2\t\t0x16\n#define\tCC2520_EXCMASKB0\t\t0x18\n#define\tCC2520_EXCMASKB1\t\t0x19\n#define\tCC2520_EXCMASKB2\t\t0x1A\n#define\tCC2520_EXCBINDX0\t\t0x1C\n#define\tCC2520_EXCBINDX1\t\t0x1D\n#define\tCC2520_EXCBINDY0\t\t0x1E\n#define\tCC2520_EXCBINDY1\t\t0x1F\n#define\tCC2520_GPIOCTRL0\t\t0x20\n#define\tCC2520_GPIOCTRL1\t\t0x21\n#define\tCC2520_GPIOCTRL2\t\t0x22\n#define\tCC2520_GPIOCTRL3\t\t0x23\n#define\tCC2520_GPIOCTRL4\t\t0x24\n#define\tCC2520_GPIOCTRL5\t\t0x25\n#define\tCC2520_GPIOPOLARITY\t\t0x26\n#define\tCC2520_GPIOCTRL\t\t\t0x28\n#define\tCC2520_DPUCON\t\t\t0x2A\n#define\tCC2520_DPUSTAT\t\t\t0x2C\n#define\tCC2520_FREQCTRL\t\t\t0x2E\n#define\tCC2520_FREQTUNE\t\t\t0x2F\n#define\tCC2520_TXPOWER\t\t\t0x30\n#define\tCC2520_TXCTRL\t\t\t0x31\n#define\tCC2520_FSMSTAT0\t\t\t0x32\n#define\tCC2520_FSMSTAT1\t\t\t0x33\n#define\tCC2520_FIFOPCTRL\t\t0x34\n#define\tCC2520_FSMCTRL\t\t\t0x35\n#define\tCC2520_CCACTRL0\t\t\t0x36\n#define\tCC2520_CCACTRL1\t\t\t0x37\n#define\tCC2520_RSSI\t\t\t0x38\n#define\tCC2520_RSSISTAT\t\t\t0x39\n#define\tCC2520_RXFIRST\t\t\t0x3C\n#define\tCC2520_RXFIFOCNT\t\t0x3E\n#define\tCC2520_TXFIFOCNT\t\t0x3F\n\n \n#define FRMFILT0_FRAME_FILTER_EN\tBIT(0)\n#define FRMFILT0_PAN_COORDINATOR\tBIT(1)\n\n \n#define FRMCTRL0_AUTOACK\t\tBIT(5)\n#define FRMCTRL0_AUTOCRC\t\tBIT(6)\n\n \n#define FRMCTRL1_SET_RXENMASK_ON_TX\tBIT(0)\n#define FRMCTRL1_IGNORE_TX_UNDERF\tBIT(1)\n\n \nstruct cc2520_private {\n\tstruct spi_device *spi;\t\t \n\tstruct ieee802154_hw *hw;\t \n\tu8 *buf;\t\t\t \n\tstruct mutex buffer_mutex;\t \n\tbool is_tx;\t\t\t \n\tbool amplified;\t\t\t \n\tstruct gpio_desc *fifo_pin;\t \n\tstruct work_struct fifop_irqwork; \n\tspinlock_t lock;\t\t \n\tstruct completion tx_complete;\t \n\tbool promiscuous;                \n};\n\n \nstatic int\ncc2520_cmd_strobe(struct cc2520_private *priv, u8 cmd)\n{\n\tint ret;\n\tstruct spi_message msg;\n\tstruct spi_transfer xfer = {\n\t\t.len = 0,\n\t\t.tx_buf = priv->buf,\n\t\t.rx_buf = priv->buf,\n\t};\n\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&xfer, &msg);\n\n\tmutex_lock(&priv->buffer_mutex);\n\tpriv->buf[xfer.len++] = cmd;\n\tdev_vdbg(&priv->spi->dev,\n\t\t \"command strobe buf[0] = %02x\\n\",\n\t\t priv->buf[0]);\n\n\tret = spi_sync(priv->spi, &msg);\n\tdev_vdbg(&priv->spi->dev,\n\t\t \"buf[0] = %02x\\n\", priv->buf[0]);\n\tmutex_unlock(&priv->buffer_mutex);\n\n\treturn ret;\n}\n\nstatic int\ncc2520_get_status(struct cc2520_private *priv, u8 *status)\n{\n\tint ret;\n\tstruct spi_message msg;\n\tstruct spi_transfer xfer = {\n\t\t.len = 0,\n\t\t.tx_buf = priv->buf,\n\t\t.rx_buf = priv->buf,\n\t};\n\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&xfer, &msg);\n\n\tmutex_lock(&priv->buffer_mutex);\n\tpriv->buf[xfer.len++] = CC2520_CMD_SNOP;\n\tdev_vdbg(&priv->spi->dev,\n\t\t \"get status command buf[0] = %02x\\n\", priv->buf[0]);\n\n\tret = spi_sync(priv->spi, &msg);\n\tif (!ret)\n\t\t*status = priv->buf[0];\n\tdev_vdbg(&priv->spi->dev,\n\t\t \"buf[0] = %02x\\n\", priv->buf[0]);\n\tmutex_unlock(&priv->buffer_mutex);\n\n\treturn ret;\n}\n\nstatic int\ncc2520_write_register(struct cc2520_private *priv, u8 reg, u8 value)\n{\n\tint status;\n\tstruct spi_message msg;\n\tstruct spi_transfer xfer = {\n\t\t.len = 0,\n\t\t.tx_buf = priv->buf,\n\t\t.rx_buf = priv->buf,\n\t};\n\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&xfer, &msg);\n\n\tmutex_lock(&priv->buffer_mutex);\n\n\tif (reg <= CC2520_FREG_MASK) {\n\t\tpriv->buf[xfer.len++] = CC2520_CMD_REGISTER_WRITE | reg;\n\t\tpriv->buf[xfer.len++] = value;\n\t} else {\n\t\tpriv->buf[xfer.len++] = CC2520_CMD_MEMORY_WRITE;\n\t\tpriv->buf[xfer.len++] = reg;\n\t\tpriv->buf[xfer.len++] = value;\n\t}\n\tstatus = spi_sync(priv->spi, &msg);\n\tif (msg.status)\n\t\tstatus = msg.status;\n\n\tmutex_unlock(&priv->buffer_mutex);\n\n\treturn status;\n}\n\nstatic int\ncc2520_write_ram(struct cc2520_private *priv, u16 reg, u8 len, u8 *data)\n{\n\tint status;\n\tstruct spi_message msg;\n\tstruct spi_transfer xfer_head = {\n\t\t.len        = 0,\n\t\t.tx_buf        = priv->buf,\n\t\t.rx_buf        = priv->buf,\n\t};\n\n\tstruct spi_transfer xfer_buf = {\n\t\t.len = len,\n\t\t.tx_buf = data,\n\t};\n\n\tmutex_lock(&priv->buffer_mutex);\n\tpriv->buf[xfer_head.len++] = (CC2520_CMD_MEMORY_WRITE |\n\t\t\t\t\t\t((reg >> 8) & 0xff));\n\tpriv->buf[xfer_head.len++] = reg & 0xff;\n\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&xfer_head, &msg);\n\tspi_message_add_tail(&xfer_buf, &msg);\n\n\tstatus = spi_sync(priv->spi, &msg);\n\tdev_dbg(&priv->spi->dev, \"spi status = %d\\n\", status);\n\tif (msg.status)\n\t\tstatus = msg.status;\n\n\tmutex_unlock(&priv->buffer_mutex);\n\treturn status;\n}\n\nstatic int\ncc2520_read_register(struct cc2520_private *priv, u8 reg, u8 *data)\n{\n\tint status;\n\tstruct spi_message msg;\n\tstruct spi_transfer xfer1 = {\n\t\t.len = 0,\n\t\t.tx_buf = priv->buf,\n\t\t.rx_buf = priv->buf,\n\t};\n\n\tstruct spi_transfer xfer2 = {\n\t\t.len = 1,\n\t\t.rx_buf = data,\n\t};\n\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&xfer1, &msg);\n\tspi_message_add_tail(&xfer2, &msg);\n\n\tmutex_lock(&priv->buffer_mutex);\n\tpriv->buf[xfer1.len++] = CC2520_CMD_MEMORY_READ;\n\tpriv->buf[xfer1.len++] = reg;\n\n\tstatus = spi_sync(priv->spi, &msg);\n\tdev_dbg(&priv->spi->dev,\n\t\t\"spi status = %d\\n\", status);\n\tif (msg.status)\n\t\tstatus = msg.status;\n\n\tmutex_unlock(&priv->buffer_mutex);\n\n\treturn status;\n}\n\nstatic int\ncc2520_write_txfifo(struct cc2520_private *priv, u8 pkt_len, u8 *data, u8 len)\n{\n\tint status;\n\n\t \n\tint len_byte = pkt_len;\n\n\tstruct spi_message msg;\n\n\tstruct spi_transfer xfer_head = {\n\t\t.len = 0,\n\t\t.tx_buf = priv->buf,\n\t\t.rx_buf = priv->buf,\n\t};\n\tstruct spi_transfer xfer_len = {\n\t\t.len = 1,\n\t\t.tx_buf = &len_byte,\n\t};\n\tstruct spi_transfer xfer_buf = {\n\t\t.len = len,\n\t\t.tx_buf = data,\n\t};\n\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&xfer_head, &msg);\n\tspi_message_add_tail(&xfer_len, &msg);\n\tspi_message_add_tail(&xfer_buf, &msg);\n\n\tmutex_lock(&priv->buffer_mutex);\n\tpriv->buf[xfer_head.len++] = CC2520_CMD_TXBUF;\n\tdev_vdbg(&priv->spi->dev,\n\t\t \"TX_FIFO cmd buf[0] = %02x\\n\", priv->buf[0]);\n\n\tstatus = spi_sync(priv->spi, &msg);\n\tdev_vdbg(&priv->spi->dev, \"status = %d\\n\", status);\n\tif (msg.status)\n\t\tstatus = msg.status;\n\tdev_vdbg(&priv->spi->dev, \"status = %d\\n\", status);\n\tdev_vdbg(&priv->spi->dev, \"buf[0] = %02x\\n\", priv->buf[0]);\n\tmutex_unlock(&priv->buffer_mutex);\n\n\treturn status;\n}\n\nstatic int\ncc2520_read_rxfifo(struct cc2520_private *priv, u8 *data, u8 len)\n{\n\tint status;\n\tstruct spi_message msg;\n\n\tstruct spi_transfer xfer_head = {\n\t\t.len = 0,\n\t\t.tx_buf = priv->buf,\n\t\t.rx_buf = priv->buf,\n\t};\n\tstruct spi_transfer xfer_buf = {\n\t\t.len = len,\n\t\t.rx_buf = data,\n\t};\n\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&xfer_head, &msg);\n\tspi_message_add_tail(&xfer_buf, &msg);\n\n\tmutex_lock(&priv->buffer_mutex);\n\tpriv->buf[xfer_head.len++] = CC2520_CMD_RXBUF;\n\n\tdev_vdbg(&priv->spi->dev, \"read rxfifo buf[0] = %02x\\n\", priv->buf[0]);\n\tdev_vdbg(&priv->spi->dev, \"buf[1] = %02x\\n\", priv->buf[1]);\n\n\tstatus = spi_sync(priv->spi, &msg);\n\tdev_vdbg(&priv->spi->dev, \"status = %d\\n\", status);\n\tif (msg.status)\n\t\tstatus = msg.status;\n\tdev_vdbg(&priv->spi->dev, \"status = %d\\n\", status);\n\tdev_vdbg(&priv->spi->dev,\n\t\t \"return status buf[0] = %02x\\n\", priv->buf[0]);\n\tdev_vdbg(&priv->spi->dev, \"length buf[1] = %02x\\n\", priv->buf[1]);\n\n\tmutex_unlock(&priv->buffer_mutex);\n\n\treturn status;\n}\n\nstatic int cc2520_start(struct ieee802154_hw *hw)\n{\n\treturn cc2520_cmd_strobe(hw->priv, CC2520_CMD_SRXON);\n}\n\nstatic void cc2520_stop(struct ieee802154_hw *hw)\n{\n\tcc2520_cmd_strobe(hw->priv, CC2520_CMD_SRFOFF);\n}\n\nstatic int\ncc2520_tx(struct ieee802154_hw *hw, struct sk_buff *skb)\n{\n\tstruct cc2520_private *priv = hw->priv;\n\tunsigned long flags;\n\tint rc;\n\tu8 status = 0;\n\tu8 pkt_len;\n\n\t \n\tif (priv->promiscuous) {\n\t\tu16 crc = crc_ccitt(0, skb->data, skb->len);\n\n\t\tput_unaligned_le16(crc, skb_put(skb, 2));\n\t\tpkt_len = skb->len;\n\t} else {\n\t\tpkt_len = skb->len + 2;\n\t}\n\n\trc = cc2520_cmd_strobe(priv, CC2520_CMD_SFLUSHTX);\n\tif (rc)\n\t\tgoto err_tx;\n\n\trc = cc2520_write_txfifo(priv, pkt_len, skb->data, skb->len);\n\tif (rc)\n\t\tgoto err_tx;\n\n\trc = cc2520_get_status(priv, &status);\n\tif (rc)\n\t\tgoto err_tx;\n\n\tif (status & CC2520_STATUS_TX_UNDERFLOW) {\n\t\trc = -EINVAL;\n\t\tdev_err(&priv->spi->dev, \"cc2520 tx underflow exception\\n\");\n\t\tgoto err_tx;\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tWARN_ON(priv->is_tx);\n\tpriv->is_tx = 1;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\trc = cc2520_cmd_strobe(priv, CC2520_CMD_STXONCCA);\n\tif (rc)\n\t\tgoto err;\n\n\trc = wait_for_completion_interruptible(&priv->tx_complete);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tcc2520_cmd_strobe(priv, CC2520_CMD_SFLUSHTX);\n\tcc2520_cmd_strobe(priv, CC2520_CMD_SRXON);\n\n\treturn rc;\nerr:\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->is_tx = 0;\n\tspin_unlock_irqrestore(&priv->lock, flags);\nerr_tx:\n\treturn rc;\n}\n\nstatic int cc2520_rx(struct cc2520_private *priv)\n{\n\tu8 len = 0, lqi = 0, bytes = 1;\n\tstruct sk_buff *skb;\n\n\t \n\tcc2520_read_rxfifo(priv, &len, bytes);\n\n\tif (!ieee802154_is_valid_psdu_len(len)) {\n\t\t \n\t\tdev_dbg(&priv->spi->dev, \"corrupted frame received\\n\");\n\t\tlen = IEEE802154_MTU;\n\t}\n\n\tskb = dev_alloc_skb(len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tif (cc2520_read_rxfifo(priv, skb_put(skb, len), len)) {\n\t\tdev_dbg(&priv->spi->dev, \"frame reception failed\\n\");\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!priv->promiscuous) {\n\t\tbool crc_ok;\n\n\t\t \n\t\tcrc_ok = skb->data[len - 1] & BIT(7);\n\n\t\t \n\t\tif (!crc_ok) {\n\t\t\tdev_dbg(&priv->spi->dev, \"CRC check failed\\n\");\n\t\t\tkfree_skb(skb);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tlqi = skb->data[len - 1] & 0x7f;\n\t\tif (lqi < 50)\n\t\t\tlqi = 50;\n\t\telse if (lqi > 113)\n\t\t\tlqi = 113;\n\t\tlqi = (lqi - 50) * 4;\n\t}\n\n\tieee802154_rx_irqsafe(priv->hw, skb, lqi);\n\n\tdev_vdbg(&priv->spi->dev, \"RXFIFO: %x %x\\n\", len, lqi);\n\n\treturn 0;\n}\n\nstatic int\ncc2520_ed(struct ieee802154_hw *hw, u8 *level)\n{\n\tstruct cc2520_private *priv = hw->priv;\n\tu8 status = 0xff;\n\tu8 rssi;\n\tint ret;\n\n\tret = cc2520_read_register(priv, CC2520_RSSISTAT, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tif (status != RSSI_VALID)\n\t\treturn -EINVAL;\n\n\tret = cc2520_read_register(priv, CC2520_RSSI, &rssi);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t*level = rssi - RSSI_OFFSET;\n\n\treturn 0;\n}\n\nstatic int\ncc2520_set_channel(struct ieee802154_hw *hw, u8 page, u8 channel)\n{\n\tstruct cc2520_private *priv = hw->priv;\n\tint ret;\n\n\tdev_dbg(&priv->spi->dev, \"trying to set channel\\n\");\n\n\tWARN_ON(page != 0);\n\tWARN_ON(channel < CC2520_MINCHANNEL);\n\tWARN_ON(channel > CC2520_MAXCHANNEL);\n\n\tret = cc2520_write_register(priv, CC2520_FREQCTRL,\n\t\t\t\t    11 + 5 * (channel - 11));\n\n\treturn ret;\n}\n\nstatic int\ncc2520_filter(struct ieee802154_hw *hw,\n\t      struct ieee802154_hw_addr_filt *filt, unsigned long changed)\n{\n\tstruct cc2520_private *priv = hw->priv;\n\tint ret = 0;\n\n\tif (changed & IEEE802154_AFILT_PANID_CHANGED) {\n\t\tu16 panid = le16_to_cpu(filt->pan_id);\n\n\t\tdev_vdbg(&priv->spi->dev, \"%s called for pan id\\n\", __func__);\n\t\tret = cc2520_write_ram(priv, CC2520RAM_PANID,\n\t\t\t\t       sizeof(panid), (u8 *)&panid);\n\t}\n\n\tif (changed & IEEE802154_AFILT_IEEEADDR_CHANGED) {\n\t\tdev_vdbg(&priv->spi->dev,\n\t\t\t \"%s called for IEEE addr\\n\", __func__);\n\t\tret = cc2520_write_ram(priv, CC2520RAM_IEEEADDR,\n\t\t\t\t       sizeof(filt->ieee_addr),\n\t\t\t\t       (u8 *)&filt->ieee_addr);\n\t}\n\n\tif (changed & IEEE802154_AFILT_SADDR_CHANGED) {\n\t\tu16 addr = le16_to_cpu(filt->short_addr);\n\n\t\tdev_vdbg(&priv->spi->dev, \"%s called for saddr\\n\", __func__);\n\t\tret = cc2520_write_ram(priv, CC2520RAM_SHORTADDR,\n\t\t\t\t       sizeof(addr), (u8 *)&addr);\n\t}\n\n\tif (changed & IEEE802154_AFILT_PANC_CHANGED) {\n\t\tu8 frmfilt0;\n\n\t\tdev_vdbg(&priv->spi->dev,\n\t\t\t \"%s called for panc change\\n\", __func__);\n\n\t\tcc2520_read_register(priv, CC2520_FRMFILT0, &frmfilt0);\n\n\t\tif (filt->pan_coord)\n\t\t\tfrmfilt0 |= FRMFILT0_PAN_COORDINATOR;\n\t\telse\n\t\t\tfrmfilt0 &= ~FRMFILT0_PAN_COORDINATOR;\n\n\t\tret = cc2520_write_register(priv, CC2520_FRMFILT0, frmfilt0);\n\t}\n\n\treturn ret;\n}\n\nstatic inline int cc2520_set_tx_power(struct cc2520_private *priv, s32 mbm)\n{\n\tu8 power;\n\n\tswitch (mbm) {\n\tcase 500:\n\t\tpower = 0xF7;\n\t\tbreak;\n\tcase 300:\n\t\tpower = 0xF2;\n\t\tbreak;\n\tcase 200:\n\t\tpower = 0xAB;\n\t\tbreak;\n\tcase 100:\n\t\tpower = 0x13;\n\t\tbreak;\n\tcase 0:\n\t\tpower = 0x32;\n\t\tbreak;\n\tcase -200:\n\t\tpower = 0x81;\n\t\tbreak;\n\tcase -400:\n\t\tpower = 0x88;\n\t\tbreak;\n\tcase -700:\n\t\tpower = 0x2C;\n\t\tbreak;\n\tcase -1800:\n\t\tpower = 0x03;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn cc2520_write_register(priv, CC2520_TXPOWER, power);\n}\n\nstatic inline int cc2520_cc2591_set_tx_power(struct cc2520_private *priv,\n\t\t\t\t\t     s32 mbm)\n{\n\tu8 power;\n\n\tswitch (mbm) {\n\tcase 1700:\n\t\tpower = 0xF9;\n\t\tbreak;\n\tcase 1600:\n\t\tpower = 0xF0;\n\t\tbreak;\n\tcase 1400:\n\t\tpower = 0xA0;\n\t\tbreak;\n\tcase 1100:\n\t\tpower = 0x2C;\n\t\tbreak;\n\tcase -100:\n\t\tpower = 0x03;\n\t\tbreak;\n\tcase -800:\n\t\tpower = 0x01;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn cc2520_write_register(priv, CC2520_TXPOWER, power);\n}\n\n#define CC2520_MAX_TX_POWERS 0x8\nstatic const s32 cc2520_powers[CC2520_MAX_TX_POWERS + 1] = {\n\t500, 300, 200, 100, 0, -200, -400, -700, -1800,\n};\n\n#define CC2520_CC2591_MAX_TX_POWERS 0x5\nstatic const s32 cc2520_cc2591_powers[CC2520_CC2591_MAX_TX_POWERS + 1] = {\n\t1700, 1600, 1400, 1100, -100, -800,\n};\n\nstatic int\ncc2520_set_txpower(struct ieee802154_hw *hw, s32 mbm)\n{\n\tstruct cc2520_private *priv = hw->priv;\n\n\tif (!priv->amplified)\n\t\treturn cc2520_set_tx_power(priv, mbm);\n\n\treturn cc2520_cc2591_set_tx_power(priv, mbm);\n}\n\nstatic int\ncc2520_set_promiscuous_mode(struct ieee802154_hw *hw, bool on)\n{\n\tstruct cc2520_private *priv = hw->priv;\n\tu8 frmfilt0;\n\n\tdev_dbg(&priv->spi->dev, \"%s : mode %d\\n\", __func__, on);\n\n\tpriv->promiscuous = on;\n\n\tcc2520_read_register(priv, CC2520_FRMFILT0, &frmfilt0);\n\n\tif (on) {\n\t\t \n\t\tcc2520_write_register(priv, CC2520_FRMCTRL0, 0);\n\t\tfrmfilt0 &= ~FRMFILT0_FRAME_FILTER_EN;\n\t} else {\n\t\tcc2520_write_register(priv, CC2520_FRMCTRL0, FRMCTRL0_AUTOACK |\n\t\t\t\t\t\t\t     FRMCTRL0_AUTOCRC);\n\t\tfrmfilt0 |= FRMFILT0_FRAME_FILTER_EN;\n\t}\n\treturn cc2520_write_register(priv, CC2520_FRMFILT0, frmfilt0);\n}\n\nstatic const struct ieee802154_ops cc2520_ops = {\n\t.owner = THIS_MODULE,\n\t.start = cc2520_start,\n\t.stop = cc2520_stop,\n\t.xmit_sync = cc2520_tx,\n\t.ed = cc2520_ed,\n\t.set_channel = cc2520_set_channel,\n\t.set_hw_addr_filt = cc2520_filter,\n\t.set_txpower = cc2520_set_txpower,\n\t.set_promiscuous_mode = cc2520_set_promiscuous_mode,\n};\n\nstatic int cc2520_register(struct cc2520_private *priv)\n{\n\tint ret = -ENOMEM;\n\n\tpriv->hw = ieee802154_alloc_hw(sizeof(*priv), &cc2520_ops);\n\tif (!priv->hw)\n\t\tgoto err_ret;\n\n\tpriv->hw->priv = priv;\n\tpriv->hw->parent = &priv->spi->dev;\n\tpriv->hw->extra_tx_headroom = 0;\n\tieee802154_random_extended_addr(&priv->hw->phy->perm_extended_addr);\n\n\t \n\tpriv->hw->phy->supported.channels[0] = 0x7FFF800;\n\tpriv->hw->flags = IEEE802154_HW_TX_OMIT_CKSUM | IEEE802154_HW_AFILT |\n\t\t\t  IEEE802154_HW_PROMISCUOUS;\n\n\tpriv->hw->phy->flags = WPAN_PHY_FLAG_TXPOWER;\n\n\tif (!priv->amplified) {\n\t\tpriv->hw->phy->supported.tx_powers = cc2520_powers;\n\t\tpriv->hw->phy->supported.tx_powers_size = ARRAY_SIZE(cc2520_powers);\n\t\tpriv->hw->phy->transmit_power = priv->hw->phy->supported.tx_powers[4];\n\t} else {\n\t\tpriv->hw->phy->supported.tx_powers = cc2520_cc2591_powers;\n\t\tpriv->hw->phy->supported.tx_powers_size = ARRAY_SIZE(cc2520_cc2591_powers);\n\t\tpriv->hw->phy->transmit_power = priv->hw->phy->supported.tx_powers[0];\n\t}\n\n\tpriv->hw->phy->current_channel = 11;\n\n\tdev_vdbg(&priv->spi->dev, \"registered cc2520\\n\");\n\tret = ieee802154_register_hw(priv->hw);\n\tif (ret)\n\t\tgoto err_free_device;\n\n\treturn 0;\n\nerr_free_device:\n\tieee802154_free_hw(priv->hw);\nerr_ret:\n\treturn ret;\n}\n\nstatic void cc2520_fifop_irqwork(struct work_struct *work)\n{\n\tstruct cc2520_private *priv\n\t\t= container_of(work, struct cc2520_private, fifop_irqwork);\n\n\tdev_dbg(&priv->spi->dev, \"fifop interrupt received\\n\");\n\n\tif (gpiod_get_value(priv->fifo_pin))\n\t\tcc2520_rx(priv);\n\telse\n\t\tdev_dbg(&priv->spi->dev, \"rxfifo overflow\\n\");\n\n\tcc2520_cmd_strobe(priv, CC2520_CMD_SFLUSHRX);\n\tcc2520_cmd_strobe(priv, CC2520_CMD_SFLUSHRX);\n}\n\nstatic irqreturn_t cc2520_fifop_isr(int irq, void *data)\n{\n\tstruct cc2520_private *priv = data;\n\n\tschedule_work(&priv->fifop_irqwork);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t cc2520_sfd_isr(int irq, void *data)\n{\n\tstruct cc2520_private *priv = data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (priv->is_tx) {\n\t\tpriv->is_tx = 0;\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tdev_dbg(&priv->spi->dev, \"SFD for TX\\n\");\n\t\tcomplete(&priv->tx_complete);\n\t} else {\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tdev_dbg(&priv->spi->dev, \"SFD for RX\\n\");\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int cc2520_hw_init(struct cc2520_private *priv)\n{\n\tu8 status = 0, state = 0xff;\n\tint ret;\n\tint timeout = 100;\n\n\tret = cc2520_read_register(priv, CC2520_FSMSTAT1, &state);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tif (state != STATE_IDLE)\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tret = cc2520_get_status(priv, &status);\n\t\tif (ret)\n\t\t\tgoto err_ret;\n\n\t\tif (timeout-- <= 0) {\n\t\t\tdev_err(&priv->spi->dev, \"oscillator start failed!\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(1);\n\t} while (!(status & CC2520_STATUS_XOSC32M_STABLE));\n\n\tdev_vdbg(&priv->spi->dev, \"oscillator brought up\\n\");\n\n\t \n\tif (priv->amplified) {\n\t\tret = cc2520_write_register(priv, CC2520_AGCCTRL1, 0x16);\n\t\tif (ret)\n\t\t\tgoto err_ret;\n\n\t\tret = cc2520_write_register(priv, CC2520_GPIOCTRL0, 0x46);\n\t\tif (ret)\n\t\t\tgoto err_ret;\n\n\t\tret = cc2520_write_register(priv, CC2520_GPIOCTRL5, 0x47);\n\t\tif (ret)\n\t\t\tgoto err_ret;\n\n\t\tret = cc2520_write_register(priv, CC2520_GPIOPOLARITY, 0x1e);\n\t\tif (ret)\n\t\t\tgoto err_ret;\n\n\t\tret = cc2520_write_register(priv, CC2520_TXCTRL, 0xc1);\n\t\tif (ret)\n\t\t\tgoto err_ret;\n\t} else {\n\t\tret = cc2520_write_register(priv, CC2520_AGCCTRL1, 0x11);\n\t\tif (ret)\n\t\t\tgoto err_ret;\n\t}\n\n\t \n\n\t \n\tret = cc2520_write_register(priv, CC2520_CCACTRL0, 0x1A);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tret = cc2520_write_register(priv, CC2520_MDMCTRL0, 0x85);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tret = cc2520_write_register(priv, CC2520_MDMCTRL1, 0x14);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tret = cc2520_write_register(priv, CC2520_RXCTRL, 0x3f);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tret = cc2520_write_register(priv, CC2520_FSCTRL, 0x5a);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tret = cc2520_write_register(priv, CC2520_FSCAL1, 0x2b);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tret = cc2520_write_register(priv, CC2520_ADCTEST0, 0x10);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tret = cc2520_write_register(priv, CC2520_ADCTEST1, 0x0e);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tret = cc2520_write_register(priv, CC2520_ADCTEST2, 0x03);\n\tif (ret)\n\t\tgoto err_ret;\n\n\t \n\tret = cc2520_write_register(priv, CC2520_FRMCTRL1,\n\t\t\t\t    FRMCTRL1_SET_RXENMASK_ON_TX |\n\t\t\t\t    FRMCTRL1_IGNORE_TX_UNDERF);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tret = cc2520_write_register(priv, CC2520_FIFOPCTRL, 127);\n\tif (ret)\n\t\tgoto err_ret;\n\n\treturn 0;\n\nerr_ret:\n\treturn ret;\n}\n\nstatic int cc2520_probe(struct spi_device *spi)\n{\n\tstruct cc2520_private *priv;\n\tstruct gpio_desc *fifop;\n\tstruct gpio_desc *cca;\n\tstruct gpio_desc *sfd;\n\tstruct gpio_desc *reset;\n\tstruct gpio_desc *vreg;\n\tint ret;\n\n\tpriv = devm_kzalloc(&spi->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tspi_set_drvdata(spi, priv);\n\n\t \n\t \n\tpriv->amplified = false;\n\tif (device_property_read_bool(&spi->dev, \"amplified\"))\n\t\tpriv->amplified = true;\n\n\tpriv->spi = spi;\n\n\tpriv->buf = devm_kzalloc(&spi->dev,\n\t\t\t\t SPI_COMMAND_BUFFER, GFP_KERNEL);\n\tif (!priv->buf)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&priv->buffer_mutex);\n\tINIT_WORK(&priv->fifop_irqwork, cc2520_fifop_irqwork);\n\tspin_lock_init(&priv->lock);\n\tinit_completion(&priv->tx_complete);\n\n\t \n\tpriv->fifo_pin = devm_gpiod_get(&spi->dev, \"fifo\", GPIOD_IN);\n\tif (IS_ERR(priv->fifo_pin)) {\n\t\tdev_err(&spi->dev, \"fifo gpio is not valid\\n\");\n\t\tret = PTR_ERR(priv->fifo_pin);\n\t\tgoto err_hw_init;\n\t}\n\n\tcca = devm_gpiod_get(&spi->dev, \"cca\", GPIOD_IN);\n\tif (IS_ERR(cca)) {\n\t\tdev_err(&spi->dev, \"cca gpio is not valid\\n\");\n\t\tret = PTR_ERR(cca);\n\t\tgoto err_hw_init;\n\t}\n\n\tfifop = devm_gpiod_get(&spi->dev, \"fifop\", GPIOD_IN);\n\tif (IS_ERR(fifop)) {\n\t\tdev_err(&spi->dev, \"fifop gpio is not valid\\n\");\n\t\tret = PTR_ERR(fifop);\n\t\tgoto err_hw_init;\n\t}\n\n\tsfd = devm_gpiod_get(&spi->dev, \"sfd\", GPIOD_IN);\n\tif (IS_ERR(sfd)) {\n\t\tdev_err(&spi->dev, \"sfd gpio is not valid\\n\");\n\t\tret = PTR_ERR(sfd);\n\t\tgoto err_hw_init;\n\t}\n\n\treset = devm_gpiod_get(&spi->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(reset)) {\n\t\tdev_err(&spi->dev, \"reset gpio is not valid\\n\");\n\t\tret = PTR_ERR(reset);\n\t\tgoto err_hw_init;\n\t}\n\n\tvreg = devm_gpiod_get(&spi->dev, \"vreg\", GPIOD_OUT_LOW);\n\tif (IS_ERR(vreg)) {\n\t\tdev_err(&spi->dev, \"vreg gpio is not valid\\n\");\n\t\tret = PTR_ERR(vreg);\n\t\tgoto err_hw_init;\n\t}\n\n\tgpiod_set_value(vreg, HIGH);\n\tusleep_range(100, 150);\n\n\tgpiod_set_value(reset, HIGH);\n\tusleep_range(200, 250);\n\n\tret = cc2520_hw_init(priv);\n\tif (ret)\n\t\tgoto err_hw_init;\n\n\t \n\tret = devm_request_irq(&spi->dev,\n\t\t\t       gpiod_to_irq(fifop),\n\t\t\t       cc2520_fifop_isr,\n\t\t\t       IRQF_TRIGGER_RISING,\n\t\t\t       dev_name(&spi->dev),\n\t\t\t       priv);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"could not get fifop irq\\n\");\n\t\tgoto err_hw_init;\n\t}\n\n\t \n\tret = devm_request_irq(&spi->dev,\n\t\t\t       gpiod_to_irq(sfd),\n\t\t\t       cc2520_sfd_isr,\n\t\t\t       IRQF_TRIGGER_FALLING,\n\t\t\t       dev_name(&spi->dev),\n\t\t\t       priv);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"could not get sfd irq\\n\");\n\t\tgoto err_hw_init;\n\t}\n\n\tret = cc2520_register(priv);\n\tif (ret)\n\t\tgoto err_hw_init;\n\n\treturn 0;\n\nerr_hw_init:\n\tmutex_destroy(&priv->buffer_mutex);\n\tflush_work(&priv->fifop_irqwork);\n\treturn ret;\n}\n\nstatic void cc2520_remove(struct spi_device *spi)\n{\n\tstruct cc2520_private *priv = spi_get_drvdata(spi);\n\n\tmutex_destroy(&priv->buffer_mutex);\n\tflush_work(&priv->fifop_irqwork);\n\n\tieee802154_unregister_hw(priv->hw);\n\tieee802154_free_hw(priv->hw);\n}\n\nstatic const struct spi_device_id cc2520_ids[] = {\n\t{\"cc2520\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(spi, cc2520_ids);\n\nstatic const struct of_device_id cc2520_of_ids[] = {\n\t{.compatible = \"ti,cc2520\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cc2520_of_ids);\n\n \nstatic struct spi_driver cc2520_driver = {\n\t.driver = {\n\t\t.name = \"cc2520\",\n\t\t.of_match_table = cc2520_of_ids,\n\t},\n\t.id_table = cc2520_ids,\n\t.probe = cc2520_probe,\n\t.remove = cc2520_remove,\n};\nmodule_spi_driver(cc2520_driver);\n\nMODULE_AUTHOR(\"Varka Bhadram <varkab@cdac.in>\");\nMODULE_DESCRIPTION(\"CC2520 Transceiver Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}