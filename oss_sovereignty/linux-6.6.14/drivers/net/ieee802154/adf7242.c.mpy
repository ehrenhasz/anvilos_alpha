{
  "module_name": "adf7242.c",
  "hash_id": "46d796acccff5a3c54a9022808c071837911881f82e746ae5a1ba9f059ceae78",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ieee802154/adf7242.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/workqueue.h>\n#include <linux/spinlock.h>\n#include <linux/firmware.h>\n#include <linux/spi/spi.h>\n#include <linux/skbuff.h>\n#include <linux/of.h>\n#include <linux/irq.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/ieee802154.h>\n#include <net/mac802154.h>\n#include <net/cfg802154.h>\n\n#define FIRMWARE \"adf7242_firmware.bin\"\n#define MAX_POLL_LOOPS 200\n\n \n\n#define REG_EXT_CTRL\t0x100\t \n#define REG_TX_FSK_TEST 0x101\t \n#define REG_CCA1\t0x105\t \n#define REG_CCA2\t0x106\t \n#define REG_BUFFERCFG\t0x107\t \n#define REG_PKT_CFG\t0x108\t \n#define REG_DELAYCFG0\t0x109\t \n#define REG_DELAYCFG1\t0x10A\t \n#define REG_DELAYCFG2\t0x10B\t \n#define REG_SYNC_WORD0\t0x10C\t \n#define REG_SYNC_WORD1\t0x10D\t \n#define REG_SYNC_WORD2\t0x10E\t \n#define REG_SYNC_CONFIG\t0x10F\t \n#define REG_RC_CFG\t0x13E\t \n#define REG_RC_VAR44\t0x13F\t \n#define REG_CH_FREQ0\t0x300\t \n#define REG_CH_FREQ1\t0x301\t \n#define REG_CH_FREQ2\t0x302\t \n#define REG_TX_FD\t0x304\t \n#define REG_DM_CFG0\t0x305\t \n#define REG_TX_M\t0x306\t \n#define REG_RX_M\t0x307\t \n#define REG_RRB\t\t0x30C\t \n#define REG_LRB\t\t0x30D\t \n#define REG_DR0\t\t0x30E\t \n#define REG_DR1\t\t0x30F\t \n#define REG_PRAMPG\t0x313\t \n#define REG_TXPB\t0x314\t \n#define REG_RXPB\t0x315\t \n#define REG_TMR_CFG0\t0x316\t \n#define REG_TMR_CFG1\t0x317\t \n#define REG_TMR_RLD0\t0x318\t \n#define REG_TMR_RLD1\t0x319\t \n#define REG_TMR_CTRL\t0x31A\t \n#define REG_PD_AUX\t0x31E\t \n#define REG_GP_CFG\t0x32C\t \n#define REG_GP_OUT\t0x32D\t \n#define REG_GP_IN\t0x32E\t \n#define REG_SYNT\t0x335\t \n#define REG_CAL_CFG\t0x33D\t \n#define REG_PA_BIAS\t0x36E\t \n#define REG_SYNT_CAL\t0x371\t \n#define REG_IIRF_CFG\t0x389\t \n#define REG_CDR_CFG\t0x38A\t \n#define REG_DM_CFG1\t0x38B\t \n#define REG_AGCSTAT\t0x38E\t \n#define REG_RXCAL0\t0x395\t \n#define REG_RXCAL1\t0x396\t \n#define REG_RXFE_CFG\t0x39B\t \n#define REG_PA_RR\t0x3A7\t \n#define REG_PA_CFG\t0x3A8\t \n#define REG_EXTPA_CFG\t0x3A9\t \n#define REG_EXTPA_MSC\t0x3AA\t \n#define REG_ADC_RBK\t0x3AE\t \n#define REG_AGC_CFG1\t0x3B2\t \n#define REG_AGC_MAX\t0x3B4\t \n#define REG_AGC_CFG2\t0x3B6\t \n#define REG_AGC_CFG3\t0x3B7\t \n#define REG_AGC_CFG4\t0x3B8\t \n#define REG_AGC_CFG5\t0x3B9\t \n#define REG_AGC_CFG6\t0x3BA\t \n#define REG_OCL_CFG1\t0x3C4\t \n#define REG_IRQ1_EN0\t0x3C7\t \n#define REG_IRQ1_EN1\t0x3C8\t \n#define REG_IRQ2_EN0\t0x3C9\t \n#define REG_IRQ2_EN1\t0x3CA\t \n#define REG_IRQ1_SRC0\t0x3CB\t \n#define REG_IRQ1_SRC1\t0x3CC\t \n#define REG_OCL_BW0\t0x3D2\t \n#define REG_OCL_BW1\t0x3D3\t \n#define REG_OCL_BW2\t0x3D4\t \n#define REG_OCL_BW3\t0x3D5\t \n#define REG_OCL_BW4\t0x3D6\t \n#define REG_OCL_BWS\t0x3D7\t \n#define REG_OCL_CFG13\t0x3E0\t \n#define REG_GP_DRV\t0x3E3\t \n#define REG_BM_CFG\t0x3E6\t \n#define REG_SFD_15_4\t0x3F4\t \n#define REG_AFC_CFG\t0x3F7\t \n#define REG_AFC_KI_KP\t0x3F8\t \n#define REG_AFC_RANGE\t0x3F9\t \n#define REG_AFC_READ\t0x3FA\t \n\n \n#define PA_PWR(x)\t\t(((x) & 0xF) << 4)\n#define EXTPA_BIAS_SRC\t\tBIT(3)\n#define EXTPA_BIAS_MODE(x)\t(((x) & 0x7) << 0)\n\n \n#define PA_BRIDGE_DBIAS(x)\t(((x) & 0x1F) << 0)\n#define PA_DBIAS_HIGH_POWER\t21\n#define PA_DBIAS_LOW_POWER\t13\n\n \n#define PA_BIAS_CTRL(x)\t\t(((x) & 0x1F) << 1)\n#define REG_PA_BIAS_DFL\t\tBIT(0)\n#define PA_BIAS_HIGH_POWER\t63\n#define PA_BIAS_LOW_POWER\t55\n\n#define REG_PAN_ID0\t\t0x112\n#define REG_PAN_ID1\t\t0x113\n#define REG_SHORT_ADDR_0\t0x114\n#define REG_SHORT_ADDR_1\t0x115\n#define REG_IEEE_ADDR_0\t\t0x116\n#define REG_IEEE_ADDR_1\t\t0x117\n#define REG_IEEE_ADDR_2\t\t0x118\n#define REG_IEEE_ADDR_3\t\t0x119\n#define REG_IEEE_ADDR_4\t\t0x11A\n#define REG_IEEE_ADDR_5\t\t0x11B\n#define REG_IEEE_ADDR_6\t\t0x11C\n#define REG_IEEE_ADDR_7\t\t0x11D\n#define REG_FFILT_CFG\t\t0x11E\n#define REG_AUTO_CFG\t\t0x11F\n#define REG_AUTO_TX1\t\t0x120\n#define REG_AUTO_TX2\t\t0x121\n#define REG_AUTO_STATUS\t\t0x122\n\n \n#define ACCEPT_BEACON_FRAMES   BIT(0)\n#define ACCEPT_DATA_FRAMES     BIT(1)\n#define ACCEPT_ACK_FRAMES      BIT(2)\n#define ACCEPT_MACCMD_FRAMES   BIT(3)\n#define ACCEPT_RESERVED_FRAMES BIT(4)\n#define ACCEPT_ALL_ADDRESS     BIT(5)\n\n \n#define AUTO_ACK_FRAMEPEND     BIT(0)\n#define IS_PANCOORD\t       BIT(1)\n#define RX_AUTO_ACK_EN\t       BIT(3)\n#define CSMA_CA_RX_TURNAROUND  BIT(4)\n\n \n#define MAX_FRAME_RETRIES(x)   ((x) & 0xF)\n#define MAX_CCA_RETRIES(x)     (((x) & 0x7) << 4)\n\n \n#define CSMA_MAX_BE(x)\t       ((x) & 0xF)\n#define CSMA_MIN_BE(x)\t       (((x) & 0xF) << 4)\n\n#define CMD_SPI_NOP\t\t0xFF  \n#define CMD_SPI_PKT_WR\t\t0x10  \n#define CMD_SPI_PKT_RD\t\t0x30  \n#define CMD_SPI_MEM_WR(x)\t(0x18 + (x >> 8))  \n#define CMD_SPI_MEM_RD(x)\t(0x38 + (x >> 8))  \n#define CMD_SPI_MEMR_WR(x)\t(0x08 + (x >> 8))  \n#define CMD_SPI_MEMR_RD(x)\t(0x28 + (x >> 8))  \n#define CMD_SPI_PRAM_WR\t\t0x1E  \n#define CMD_SPI_PRAM_RD\t\t0x3E  \n#define CMD_RC_SLEEP\t\t0xB1  \n#define CMD_RC_IDLE\t\t0xB2  \n#define CMD_RC_PHY_RDY\t\t0xB3  \n#define CMD_RC_RX\t\t0xB4  \n#define CMD_RC_TX\t\t0xB5  \n#define CMD_RC_MEAS\t\t0xB6  \n#define CMD_RC_CCA\t\t0xB7  \n#define CMD_RC_CSMACA\t\t0xC1  \n#define CMD_RC_PC_RESET\t\t0xC7  \n#define CMD_RC_RESET\t\t0xC8  \n#define CMD_RC_PC_RESET_NO_WAIT (CMD_RC_PC_RESET | BIT(31))\n\n \n\n#define STAT_SPI_READY\t\tBIT(7)\n#define STAT_IRQ_STATUS\t\tBIT(6)\n#define STAT_RC_READY\t\tBIT(5)\n#define STAT_CCA_RESULT\t\tBIT(4)\n#define RC_STATUS_IDLE\t\t1\n#define RC_STATUS_MEAS\t\t2\n#define RC_STATUS_PHY_RDY\t3\n#define RC_STATUS_RX\t\t4\n#define RC_STATUS_TX\t\t5\n#define RC_STATUS_MASK\t\t0xF\n\n \n\n#define SUCCESS\t\t\t0\n#define SUCCESS_DATPEND\t\t1\n#define FAILURE_CSMACA\t\t2\n#define FAILURE_NOACK\t\t3\n#define AUTO_STATUS_MASK\t0x3\n\n#define PRAM_PAGESIZE\t\t256\n\n \n\n#define IRQ_CCA_COMPLETE\tBIT(0)\n#define IRQ_SFD_RX\t\tBIT(1)\n#define IRQ_SFD_TX\t\tBIT(2)\n#define IRQ_RX_PKT_RCVD\t\tBIT(3)\n#define IRQ_TX_PKT_SENT\t\tBIT(4)\n#define IRQ_FRAME_VALID\t\tBIT(5)\n#define IRQ_ADDRESS_VALID\tBIT(6)\n#define IRQ_CSMA_CA\t\tBIT(7)\n\n#define AUTO_TX_TURNAROUND\tBIT(3)\n#define ADDON_EN\t\tBIT(4)\n\n#define FLAG_XMIT\t\t0\n#define FLAG_START\t\t1\n\n#define ADF7242_REPORT_CSMA_CA_STAT 0  \n\nstruct adf7242_local {\n\tstruct spi_device *spi;\n\tstruct completion tx_complete;\n\tstruct ieee802154_hw *hw;\n\tstruct mutex bmux;  \n\tstruct spi_message stat_msg;\n\tstruct spi_transfer stat_xfer;\n\tstruct dentry *debugfs_root;\n\tstruct delayed_work work;\n\tstruct workqueue_struct *wqueue;\n\tunsigned long flags;\n\tint tx_stat;\n\tbool promiscuous;\n\ts8 rssi;\n\tu8 max_frame_retries;\n\tu8 max_cca_retries;\n\tu8 max_be;\n\tu8 min_be;\n\n\t \n\n\tu8 buf[3] ____cacheline_aligned;\n\tu8 buf_reg_tx[3];\n\tu8 buf_read_tx[4];\n\tu8 buf_read_rx[4];\n\tu8 buf_stat_rx;\n\tu8 buf_stat_tx;\n\tu8 buf_cmd;\n};\n\nstatic int adf7242_soft_reset(struct adf7242_local *lp, int line);\n\nstatic int adf7242_status(struct adf7242_local *lp, u8 *stat)\n{\n\tint status;\n\n\tmutex_lock(&lp->bmux);\n\tstatus = spi_sync(lp->spi, &lp->stat_msg);\n\t*stat = lp->buf_stat_rx;\n\tmutex_unlock(&lp->bmux);\n\n\treturn status;\n}\n\nstatic int adf7242_wait_status(struct adf7242_local *lp, unsigned int status,\n\t\t\t       unsigned int mask, int line)\n{\n\tint cnt = 0, ret = 0;\n\tu8 stat;\n\n\tdo {\n\t\tadf7242_status(lp, &stat);\n\t\tcnt++;\n\t} while (((stat & mask) != status) && (cnt < MAX_POLL_LOOPS));\n\n\tif (cnt >= MAX_POLL_LOOPS) {\n\t\tret = -ETIMEDOUT;\n\n\t\tif (!(stat & STAT_RC_READY)) {\n\t\t\tadf7242_soft_reset(lp, line);\n\t\t\tadf7242_status(lp, &stat);\n\n\t\t\tif ((stat & mask) == status)\n\t\t\t\tret = 0;\n\t\t}\n\n\t\tif (ret < 0)\n\t\t\tdev_warn(&lp->spi->dev,\n\t\t\t\t \"%s:line %d Timeout status 0x%x (%d)\\n\",\n\t\t\t\t __func__, line, stat, cnt);\n\t}\n\n\tdev_vdbg(&lp->spi->dev, \"%s : loops=%d line %d\\n\", __func__, cnt, line);\n\n\treturn ret;\n}\n\nstatic int adf7242_wait_rc_ready(struct adf7242_local *lp, int line)\n{\n\treturn adf7242_wait_status(lp, STAT_RC_READY | STAT_SPI_READY,\n\t\t\t\t   STAT_RC_READY | STAT_SPI_READY, line);\n}\n\nstatic int adf7242_wait_spi_ready(struct adf7242_local *lp, int line)\n{\n\treturn adf7242_wait_status(lp, STAT_SPI_READY,\n\t\t\t\t   STAT_SPI_READY, line);\n}\n\nstatic int adf7242_write_fbuf(struct adf7242_local *lp, u8 *data, u8 len)\n{\n\tu8 *buf = lp->buf;\n\tint status;\n\tstruct spi_message msg;\n\tstruct spi_transfer xfer_head = {\n\t\t.len = 2,\n\t\t.tx_buf = buf,\n\n\t};\n\tstruct spi_transfer xfer_buf = {\n\t\t.len = len,\n\t\t.tx_buf = data,\n\t};\n\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&xfer_head, &msg);\n\tspi_message_add_tail(&xfer_buf, &msg);\n\n\tadf7242_wait_spi_ready(lp, __LINE__);\n\n\tmutex_lock(&lp->bmux);\n\tbuf[0] = CMD_SPI_PKT_WR;\n\tbuf[1] = len + 2;\n\n\tstatus = spi_sync(lp->spi, &msg);\n\tmutex_unlock(&lp->bmux);\n\n\treturn status;\n}\n\nstatic int adf7242_read_fbuf(struct adf7242_local *lp,\n\t\t\t     u8 *data, size_t len, bool packet_read)\n{\n\tu8 *buf = lp->buf;\n\tint status;\n\tstruct spi_message msg;\n\tstruct spi_transfer xfer_head = {\n\t\t.len = 3,\n\t\t.tx_buf = buf,\n\t\t.rx_buf = buf,\n\t};\n\tstruct spi_transfer xfer_buf = {\n\t\t.len = len,\n\t\t.rx_buf = data,\n\t};\n\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&xfer_head, &msg);\n\tspi_message_add_tail(&xfer_buf, &msg);\n\n\tadf7242_wait_spi_ready(lp, __LINE__);\n\n\tmutex_lock(&lp->bmux);\n\tif (packet_read) {\n\t\tbuf[0] = CMD_SPI_PKT_RD;\n\t\tbuf[1] = CMD_SPI_NOP;\n\t\tbuf[2] = 0;\t \n\t} else {\n\t\tbuf[0] = CMD_SPI_PRAM_RD;\n\t\tbuf[1] = 0;\n\t\tbuf[2] = CMD_SPI_NOP;\n\t}\n\n\tstatus = spi_sync(lp->spi, &msg);\n\n\tmutex_unlock(&lp->bmux);\n\n\treturn status;\n}\n\nstatic int adf7242_read_reg(struct adf7242_local *lp, u16 addr, u8 *data)\n{\n\tint status;\n\tstruct spi_message msg;\n\n\tstruct spi_transfer xfer = {\n\t\t.len = 4,\n\t\t.tx_buf = lp->buf_read_tx,\n\t\t.rx_buf = lp->buf_read_rx,\n\t};\n\n\tadf7242_wait_spi_ready(lp, __LINE__);\n\n\tmutex_lock(&lp->bmux);\n\tlp->buf_read_tx[0] = CMD_SPI_MEM_RD(addr);\n\tlp->buf_read_tx[1] = addr;\n\tlp->buf_read_tx[2] = CMD_SPI_NOP;\n\tlp->buf_read_tx[3] = CMD_SPI_NOP;\n\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&xfer, &msg);\n\n\tstatus = spi_sync(lp->spi, &msg);\n\tif (msg.status)\n\t\tstatus = msg.status;\n\n\tif (!status)\n\t\t*data = lp->buf_read_rx[3];\n\n\tmutex_unlock(&lp->bmux);\n\n\tdev_vdbg(&lp->spi->dev, \"%s : REG 0x%X, VAL 0x%X\\n\", __func__,\n\t\t addr, *data);\n\n\treturn status;\n}\n\nstatic int adf7242_write_reg(struct adf7242_local *lp, u16 addr, u8 data)\n{\n\tint status;\n\n\tadf7242_wait_spi_ready(lp, __LINE__);\n\n\tmutex_lock(&lp->bmux);\n\tlp->buf_reg_tx[0] = CMD_SPI_MEM_WR(addr);\n\tlp->buf_reg_tx[1] = addr;\n\tlp->buf_reg_tx[2] = data;\n\tstatus = spi_write(lp->spi, lp->buf_reg_tx, 3);\n\tmutex_unlock(&lp->bmux);\n\n\tdev_vdbg(&lp->spi->dev, \"%s : REG 0x%X, VAL 0x%X\\n\",\n\t\t __func__, addr, data);\n\n\treturn status;\n}\n\nstatic int adf7242_cmd(struct adf7242_local *lp, unsigned int cmd)\n{\n\tint status;\n\n\tdev_vdbg(&lp->spi->dev, \"%s : CMD=0x%X\\n\", __func__, cmd);\n\n\tif (cmd != CMD_RC_PC_RESET_NO_WAIT)\n\t\tadf7242_wait_rc_ready(lp, __LINE__);\n\n\tmutex_lock(&lp->bmux);\n\tlp->buf_cmd = cmd;\n\tstatus = spi_write(lp->spi, &lp->buf_cmd, 1);\n\tmutex_unlock(&lp->bmux);\n\n\treturn status;\n}\n\nstatic int adf7242_upload_firmware(struct adf7242_local *lp, u8 *data, u16 len)\n{\n\tstruct spi_message msg;\n\tstruct spi_transfer xfer_buf = { };\n\tint status, i, page = 0;\n\tu8 *buf = lp->buf;\n\n\tstruct spi_transfer xfer_head = {\n\t\t.len = 2,\n\t\t.tx_buf = buf,\n\t};\n\n\tbuf[0] = CMD_SPI_PRAM_WR;\n\tbuf[1] = 0;\n\n\tspi_message_init(&msg);\n\tspi_message_add_tail(&xfer_head, &msg);\n\tspi_message_add_tail(&xfer_buf, &msg);\n\n\tfor (i = len; i >= 0; i -= PRAM_PAGESIZE) {\n\t\tadf7242_write_reg(lp, REG_PRAMPG, page);\n\n\t\txfer_buf.len = (i >= PRAM_PAGESIZE) ? PRAM_PAGESIZE : i;\n\t\txfer_buf.tx_buf = &data[page * PRAM_PAGESIZE];\n\n\t\tmutex_lock(&lp->bmux);\n\t\tstatus = spi_sync(lp->spi, &msg);\n\t\tmutex_unlock(&lp->bmux);\n\t\tpage++;\n\t}\n\n\treturn status;\n}\n\nstatic int adf7242_verify_firmware(struct adf7242_local *lp,\n\t\t\t\t   const u8 *data, size_t len)\n{\n#ifdef DEBUG\n\tint i, j;\n\tunsigned int page;\n\tu8 *buf = kmalloc(PRAM_PAGESIZE, GFP_KERNEL);\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tfor (page = 0, i = len; i >= 0; i -= PRAM_PAGESIZE, page++) {\n\t\tsize_t nb = (i >= PRAM_PAGESIZE) ? PRAM_PAGESIZE : i;\n\n\t\tadf7242_write_reg(lp, REG_PRAMPG, page);\n\t\tadf7242_read_fbuf(lp, buf, nb, false);\n\n\t\tfor (j = 0; j < nb; j++) {\n\t\t\tif (buf[j] != data[page * PRAM_PAGESIZE + j]) {\n\t\t\t\tkfree(buf);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t}\n\tkfree(buf);\n#endif\n\treturn 0;\n}\n\nstatic void adf7242_clear_irqstat(struct adf7242_local *lp)\n{\n\tadf7242_write_reg(lp, REG_IRQ1_SRC1, IRQ_CCA_COMPLETE | IRQ_SFD_RX |\n\t\t\t  IRQ_SFD_TX | IRQ_RX_PKT_RCVD | IRQ_TX_PKT_SENT |\n\t\t\t  IRQ_FRAME_VALID | IRQ_ADDRESS_VALID | IRQ_CSMA_CA);\n}\n\nstatic int adf7242_cmd_rx(struct adf7242_local *lp)\n{\n\t \n\tadf7242_wait_status(lp, RC_STATUS_PHY_RDY, RC_STATUS_MASK, __LINE__);\n\tadf7242_clear_irqstat(lp);\n\tmod_delayed_work(lp->wqueue, &lp->work, msecs_to_jiffies(400));\n\n\treturn adf7242_cmd(lp, CMD_RC_RX);\n}\n\nstatic void adf7242_rx_cal_work(struct work_struct *work)\n{\n\tstruct adf7242_local *lp =\n\tcontainer_of(work, struct adf7242_local, work.work);\n\n\t \n\n\tif (!test_bit(FLAG_XMIT, &lp->flags)) {\n\t\tadf7242_cmd(lp, CMD_RC_PHY_RDY);\n\t\tadf7242_cmd_rx(lp);\n\t}\n}\n\nstatic int adf7242_set_txpower(struct ieee802154_hw *hw, int mbm)\n{\n\tstruct adf7242_local *lp = hw->priv;\n\tu8 pwr, bias_ctrl, dbias, tmp;\n\tint db = mbm / 100;\n\n\tdev_vdbg(&lp->spi->dev, \"%s : Power %d dB\\n\", __func__, db);\n\n\tif (db > 5 || db < -26)\n\t\treturn -EINVAL;\n\n\tdb = DIV_ROUND_CLOSEST(db + 29, 2);\n\n\tif (db > 15) {\n\t\tdbias = PA_DBIAS_HIGH_POWER;\n\t\tbias_ctrl = PA_BIAS_HIGH_POWER;\n\t} else {\n\t\tdbias = PA_DBIAS_LOW_POWER;\n\t\tbias_ctrl = PA_BIAS_LOW_POWER;\n\t}\n\n\tpwr = clamp_t(u8, db, 3, 15);\n\n\tadf7242_read_reg(lp, REG_PA_CFG, &tmp);\n\ttmp &= ~PA_BRIDGE_DBIAS(~0);\n\ttmp |= PA_BRIDGE_DBIAS(dbias);\n\tadf7242_write_reg(lp, REG_PA_CFG, tmp);\n\n\tadf7242_read_reg(lp, REG_PA_BIAS, &tmp);\n\ttmp &= ~PA_BIAS_CTRL(~0);\n\ttmp |= PA_BIAS_CTRL(bias_ctrl);\n\tadf7242_write_reg(lp, REG_PA_BIAS, tmp);\n\n\tadf7242_read_reg(lp, REG_EXTPA_MSC, &tmp);\n\ttmp &= ~PA_PWR(~0);\n\ttmp |= PA_PWR(pwr);\n\n\treturn adf7242_write_reg(lp, REG_EXTPA_MSC, tmp);\n}\n\nstatic int adf7242_set_csma_params(struct ieee802154_hw *hw, u8 min_be,\n\t\t\t\t   u8 max_be, u8 retries)\n{\n\tstruct adf7242_local *lp = hw->priv;\n\tint ret;\n\n\tdev_vdbg(&lp->spi->dev, \"%s : min_be=%d max_be=%d retries=%d\\n\",\n\t\t __func__, min_be, max_be, retries);\n\n\tif (min_be > max_be || max_be > 8 || retries > 5)\n\t\treturn -EINVAL;\n\n\tret = adf7242_write_reg(lp, REG_AUTO_TX1,\n\t\t\t\tMAX_FRAME_RETRIES(lp->max_frame_retries) |\n\t\t\t\tMAX_CCA_RETRIES(retries));\n\tif (ret)\n\t\treturn ret;\n\n\tlp->max_cca_retries = retries;\n\tlp->max_be = max_be;\n\tlp->min_be = min_be;\n\n\treturn adf7242_write_reg(lp, REG_AUTO_TX2, CSMA_MAX_BE(max_be) |\n\t\t\tCSMA_MIN_BE(min_be));\n}\n\nstatic int adf7242_set_frame_retries(struct ieee802154_hw *hw, s8 retries)\n{\n\tstruct adf7242_local *lp = hw->priv;\n\tint ret = 0;\n\n\tdev_vdbg(&lp->spi->dev, \"%s : Retries = %d\\n\", __func__, retries);\n\n\tif (retries < -1 || retries > 15)\n\t\treturn -EINVAL;\n\n\tif (retries >= 0)\n\t\tret = adf7242_write_reg(lp, REG_AUTO_TX1,\n\t\t\t\t\tMAX_FRAME_RETRIES(retries) |\n\t\t\t\t\tMAX_CCA_RETRIES(lp->max_cca_retries));\n\n\tlp->max_frame_retries = retries;\n\n\treturn ret;\n}\n\nstatic int adf7242_ed(struct ieee802154_hw *hw, u8 *level)\n{\n\tstruct adf7242_local *lp = hw->priv;\n\n\t*level = lp->rssi;\n\n\tdev_vdbg(&lp->spi->dev, \"%s :Exit level=%d\\n\",\n\t\t __func__, *level);\n\n\treturn 0;\n}\n\nstatic int adf7242_start(struct ieee802154_hw *hw)\n{\n\tstruct adf7242_local *lp = hw->priv;\n\n\tadf7242_cmd(lp, CMD_RC_PHY_RDY);\n\tadf7242_clear_irqstat(lp);\n\tenable_irq(lp->spi->irq);\n\tset_bit(FLAG_START, &lp->flags);\n\n\treturn adf7242_cmd_rx(lp);\n}\n\nstatic void adf7242_stop(struct ieee802154_hw *hw)\n{\n\tstruct adf7242_local *lp = hw->priv;\n\n\tdisable_irq(lp->spi->irq);\n\tcancel_delayed_work_sync(&lp->work);\n\tadf7242_cmd(lp, CMD_RC_IDLE);\n\tclear_bit(FLAG_START, &lp->flags);\n\tadf7242_clear_irqstat(lp);\n}\n\nstatic int adf7242_channel(struct ieee802154_hw *hw, u8 page, u8 channel)\n{\n\tstruct adf7242_local *lp = hw->priv;\n\tunsigned long freq;\n\n\tdev_dbg(&lp->spi->dev, \"%s :Channel=%d\\n\", __func__, channel);\n\n\tmight_sleep();\n\n\tWARN_ON(page != 0);\n\tWARN_ON(channel < 11);\n\tWARN_ON(channel > 26);\n\n\tfreq = (2405 + 5 * (channel - 11)) * 100;\n\tadf7242_cmd(lp, CMD_RC_PHY_RDY);\n\n\tadf7242_write_reg(lp, REG_CH_FREQ0, freq);\n\tadf7242_write_reg(lp, REG_CH_FREQ1, freq >> 8);\n\tadf7242_write_reg(lp, REG_CH_FREQ2, freq >> 16);\n\n\tif (test_bit(FLAG_START, &lp->flags))\n\t\treturn adf7242_cmd_rx(lp);\n\telse\n\t\treturn adf7242_cmd(lp, CMD_RC_PHY_RDY);\n}\n\nstatic int adf7242_set_hw_addr_filt(struct ieee802154_hw *hw,\n\t\t\t\t    struct ieee802154_hw_addr_filt *filt,\n\t\t\t\t    unsigned long changed)\n{\n\tstruct adf7242_local *lp = hw->priv;\n\tu8 reg;\n\n\tdev_dbg(&lp->spi->dev, \"%s :Changed=0x%lX\\n\", __func__, changed);\n\n\tmight_sleep();\n\n\tif (changed & IEEE802154_AFILT_IEEEADDR_CHANGED) {\n\t\tu8 addr[8], i;\n\n\t\tmemcpy(addr, &filt->ieee_addr, 8);\n\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tadf7242_write_reg(lp, REG_IEEE_ADDR_0 + i, addr[i]);\n\t}\n\n\tif (changed & IEEE802154_AFILT_SADDR_CHANGED) {\n\t\tu16 saddr = le16_to_cpu(filt->short_addr);\n\n\t\tadf7242_write_reg(lp, REG_SHORT_ADDR_0, saddr);\n\t\tadf7242_write_reg(lp, REG_SHORT_ADDR_1, saddr >> 8);\n\t}\n\n\tif (changed & IEEE802154_AFILT_PANID_CHANGED) {\n\t\tu16 pan_id = le16_to_cpu(filt->pan_id);\n\n\t\tadf7242_write_reg(lp, REG_PAN_ID0, pan_id);\n\t\tadf7242_write_reg(lp, REG_PAN_ID1, pan_id >> 8);\n\t}\n\n\tif (changed & IEEE802154_AFILT_PANC_CHANGED) {\n\t\tadf7242_read_reg(lp, REG_AUTO_CFG, &reg);\n\t\tif (filt->pan_coord)\n\t\t\treg |= IS_PANCOORD;\n\t\telse\n\t\t\treg &= ~IS_PANCOORD;\n\t\tadf7242_write_reg(lp, REG_AUTO_CFG, reg);\n\t}\n\n\treturn 0;\n}\n\nstatic int adf7242_set_promiscuous_mode(struct ieee802154_hw *hw, bool on)\n{\n\tstruct adf7242_local *lp = hw->priv;\n\n\tdev_dbg(&lp->spi->dev, \"%s : mode %d\\n\", __func__, on);\n\n\tlp->promiscuous = on;\n\n\tif (on) {\n\t\tadf7242_write_reg(lp, REG_AUTO_CFG, 0);\n\t\treturn adf7242_write_reg(lp, REG_FFILT_CFG,\n\t\t\t\t  ACCEPT_BEACON_FRAMES |\n\t\t\t\t  ACCEPT_DATA_FRAMES |\n\t\t\t\t  ACCEPT_MACCMD_FRAMES |\n\t\t\t\t  ACCEPT_ALL_ADDRESS |\n\t\t\t\t  ACCEPT_ACK_FRAMES |\n\t\t\t\t  ACCEPT_RESERVED_FRAMES);\n\t} else {\n\t\tadf7242_write_reg(lp, REG_FFILT_CFG,\n\t\t\t\t  ACCEPT_BEACON_FRAMES |\n\t\t\t\t  ACCEPT_DATA_FRAMES |\n\t\t\t\t  ACCEPT_MACCMD_FRAMES |\n\t\t\t\t  ACCEPT_RESERVED_FRAMES);\n\n\t\treturn adf7242_write_reg(lp, REG_AUTO_CFG, RX_AUTO_ACK_EN);\n\t}\n}\n\nstatic int adf7242_set_cca_ed_level(struct ieee802154_hw *hw, s32 mbm)\n{\n\tstruct adf7242_local *lp = hw->priv;\n\ts8 level = clamp_t(s8, mbm / 100, S8_MIN, S8_MAX);\n\n\tdev_dbg(&lp->spi->dev, \"%s : level %d\\n\", __func__, level);\n\n\treturn adf7242_write_reg(lp, REG_CCA1, level);\n}\n\nstatic int adf7242_xmit(struct ieee802154_hw *hw, struct sk_buff *skb)\n{\n\tstruct adf7242_local *lp = hw->priv;\n\tint ret;\n\n\t \n\tdisable_irq(lp->spi->irq);\n\tset_bit(FLAG_XMIT, &lp->flags);\n\tcancel_delayed_work_sync(&lp->work);\n\treinit_completion(&lp->tx_complete);\n\tadf7242_cmd(lp, CMD_RC_PHY_RDY);\n\tadf7242_clear_irqstat(lp);\n\n\tret = adf7242_write_fbuf(lp, skb->data, skb->len);\n\tif (ret)\n\t\tgoto err;\n\n\tret = adf7242_cmd(lp, CMD_RC_CSMACA);\n\tif (ret)\n\t\tgoto err;\n\tenable_irq(lp->spi->irq);\n\n\tret = wait_for_completion_interruptible_timeout(&lp->tx_complete,\n\t\t\t\t\t\t\tHZ / 10);\n\tif (ret < 0)\n\t\tgoto err;\n\tif (ret == 0) {\n\t\tdev_dbg(&lp->spi->dev, \"Timeout waiting for TX interrupt\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto err;\n\t}\n\n\tif (lp->tx_stat != SUCCESS) {\n\t\tdev_dbg(&lp->spi->dev,\n\t\t\t\"Error xmit: Retry count exceeded Status=0x%x\\n\",\n\t\t\tlp->tx_stat);\n\t\tret = -ECOMM;\n\t} else {\n\t\tret = 0;\n\t}\n\nerr:\n\tclear_bit(FLAG_XMIT, &lp->flags);\n\tadf7242_cmd_rx(lp);\n\n\treturn ret;\n}\n\nstatic int adf7242_rx(struct adf7242_local *lp)\n{\n\tstruct sk_buff *skb;\n\tsize_t len;\n\tint ret;\n\tu8 lqi, len_u8, *data;\n\n\tret = adf7242_read_reg(lp, 0, &len_u8);\n\tif (ret)\n\t\treturn ret;\n\n\tlen = len_u8;\n\n\tif (!ieee802154_is_valid_psdu_len(len)) {\n\t\tdev_dbg(&lp->spi->dev,\n\t\t\t\"corrupted frame received len %d\\n\", (int)len);\n\t\tlen = IEEE802154_MTU;\n\t}\n\n\tskb = dev_alloc_skb(len);\n\tif (!skb) {\n\t\tadf7242_cmd_rx(lp);\n\t\treturn -ENOMEM;\n\t}\n\n\tdata = skb_put(skb, len);\n\tret = adf7242_read_fbuf(lp, data, len, true);\n\tif (ret < 0) {\n\t\tkfree_skb(skb);\n\t\tadf7242_cmd_rx(lp);\n\t\treturn ret;\n\t}\n\n\tlqi = data[len - 2];\n\tlp->rssi = data[len - 1];\n\n\tret = adf7242_cmd_rx(lp);\n\n\tskb_trim(skb, len - 2);\t \n\n\tieee802154_rx_irqsafe(lp->hw, skb, lqi);\n\n\tdev_dbg(&lp->spi->dev, \"%s: ret=%d len=%d lqi=%d rssi=%d\\n\",\n\t\t__func__, ret, (int)len, (int)lqi, lp->rssi);\n\n\treturn ret;\n}\n\nstatic const struct ieee802154_ops adf7242_ops = {\n\t.owner = THIS_MODULE,\n\t.xmit_sync = adf7242_xmit,\n\t.ed = adf7242_ed,\n\t.set_channel = adf7242_channel,\n\t.set_hw_addr_filt = adf7242_set_hw_addr_filt,\n\t.start = adf7242_start,\n\t.stop = adf7242_stop,\n\t.set_csma_params = adf7242_set_csma_params,\n\t.set_frame_retries = adf7242_set_frame_retries,\n\t.set_txpower = adf7242_set_txpower,\n\t.set_promiscuous_mode = adf7242_set_promiscuous_mode,\n\t.set_cca_ed_level = adf7242_set_cca_ed_level,\n};\n\nstatic void adf7242_debug(struct adf7242_local *lp, u8 irq1)\n{\n#ifdef DEBUG\n\tu8 stat;\n\n\tadf7242_status(lp, &stat);\n\n\tdev_dbg(&lp->spi->dev, \"%s IRQ1 = %X:\\n%s%s%s%s%s%s%s%s\\n\",\n\t\t__func__, irq1,\n\t\tirq1 & IRQ_CCA_COMPLETE ? \"IRQ_CCA_COMPLETE\\n\" : \"\",\n\t\tirq1 & IRQ_SFD_RX ? \"IRQ_SFD_RX\\n\" : \"\",\n\t\tirq1 & IRQ_SFD_TX ? \"IRQ_SFD_TX\\n\" : \"\",\n\t\tirq1 & IRQ_RX_PKT_RCVD ? \"IRQ_RX_PKT_RCVD\\n\" : \"\",\n\t\tirq1 & IRQ_TX_PKT_SENT ? \"IRQ_TX_PKT_SENT\\n\" : \"\",\n\t\tirq1 & IRQ_CSMA_CA ? \"IRQ_CSMA_CA\\n\" : \"\",\n\t\tirq1 & IRQ_FRAME_VALID ? \"IRQ_FRAME_VALID\\n\" : \"\",\n\t\tirq1 & IRQ_ADDRESS_VALID ? \"IRQ_ADDRESS_VALID\\n\" : \"\");\n\n\tdev_dbg(&lp->spi->dev, \"%s STATUS = %X:\\n%s\\n%s\\n%s\\n%s\\n%s%s%s%s%s\\n\",\n\t\t__func__, stat,\n\t\tstat & STAT_SPI_READY ? \"SPI_READY\" : \"SPI_BUSY\",\n\t\tstat & STAT_IRQ_STATUS ? \"IRQ_PENDING\" : \"IRQ_CLEAR\",\n\t\tstat & STAT_RC_READY ? \"RC_READY\" : \"RC_BUSY\",\n\t\tstat & STAT_CCA_RESULT ? \"CHAN_IDLE\" : \"CHAN_BUSY\",\n\t\t(stat & 0xf) == RC_STATUS_IDLE ? \"RC_STATUS_IDLE\" : \"\",\n\t\t(stat & 0xf) == RC_STATUS_MEAS ? \"RC_STATUS_MEAS\" : \"\",\n\t\t(stat & 0xf) == RC_STATUS_PHY_RDY ? \"RC_STATUS_PHY_RDY\" : \"\",\n\t\t(stat & 0xf) == RC_STATUS_RX ? \"RC_STATUS_RX\" : \"\",\n\t\t(stat & 0xf) == RC_STATUS_TX ? \"RC_STATUS_TX\" : \"\");\n#endif\n}\n\nstatic irqreturn_t adf7242_isr(int irq, void *data)\n{\n\tstruct adf7242_local *lp = data;\n\tunsigned int xmit;\n\tu8 irq1;\n\n\tmod_delayed_work(lp->wqueue, &lp->work, msecs_to_jiffies(400));\n\tadf7242_read_reg(lp, REG_IRQ1_SRC1, &irq1);\n\n\tif (!(irq1 & (IRQ_RX_PKT_RCVD | IRQ_CSMA_CA)))\n\t\tdev_err(&lp->spi->dev, \"%s :ERROR IRQ1 = 0x%X\\n\",\n\t\t\t__func__, irq1);\n\n\tadf7242_debug(lp, irq1);\n\n\txmit = test_bit(FLAG_XMIT, &lp->flags);\n\n\tif (xmit && (irq1 & IRQ_CSMA_CA)) {\n\t\tadf7242_wait_status(lp, RC_STATUS_PHY_RDY,\n\t\t\t\t    RC_STATUS_MASK, __LINE__);\n\n\t\tif (ADF7242_REPORT_CSMA_CA_STAT) {\n\t\t\tu8 astat;\n\n\t\t\tadf7242_read_reg(lp, REG_AUTO_STATUS, &astat);\n\t\t\tastat &= AUTO_STATUS_MASK;\n\n\t\t\tdev_dbg(&lp->spi->dev, \"AUTO_STATUS = %X:\\n%s%s%s%s\\n\",\n\t\t\t\tastat,\n\t\t\t\tastat == SUCCESS ? \"SUCCESS\" : \"\",\n\t\t\t\tastat ==\n\t\t\t\tSUCCESS_DATPEND ? \"SUCCESS_DATPEND\" : \"\",\n\t\t\t\tastat == FAILURE_CSMACA ? \"FAILURE_CSMACA\" : \"\",\n\t\t\t\tastat == FAILURE_NOACK ? \"FAILURE_NOACK\" : \"\");\n\n\t\t\t \n\t\t\tlp->tx_stat = astat;\n\t\t} else {\n\t\t\tlp->tx_stat = SUCCESS;\n\t\t}\n\t\tcomplete(&lp->tx_complete);\n\t\tadf7242_clear_irqstat(lp);\n\t} else if (!xmit && (irq1 & IRQ_RX_PKT_RCVD) &&\n\t\t   (irq1 & IRQ_FRAME_VALID)) {\n\t\tadf7242_rx(lp);\n\t} else if (!xmit && test_bit(FLAG_START, &lp->flags)) {\n\t\t \n\t\tdev_dbg(&lp->spi->dev, \"%s:%d : ERROR IRQ1 = 0x%X\\n\",\n\t\t\t__func__, __LINE__, irq1);\n\t\tadf7242_cmd(lp, CMD_RC_PHY_RDY);\n\t\tadf7242_cmd_rx(lp);\n\t} else {\n\t\t \n\n\t\tdev_dbg(&lp->spi->dev, \"%s:%d : ERROR IRQ1 = 0x%X, xmit %d\\n\",\n\t\t\t__func__, __LINE__, irq1, xmit);\n\t\tadf7242_wait_status(lp, RC_STATUS_PHY_RDY,\n\t\t\t\t    RC_STATUS_MASK, __LINE__);\n\t\tcomplete(&lp->tx_complete);\n\t\tadf7242_clear_irqstat(lp);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int adf7242_soft_reset(struct adf7242_local *lp, int line)\n{\n\tdev_warn(&lp->spi->dev, \"%s (line %d)\\n\", __func__, line);\n\n\tif (test_bit(FLAG_START, &lp->flags))\n\t\tdisable_irq_nosync(lp->spi->irq);\n\n\tadf7242_cmd(lp, CMD_RC_PC_RESET_NO_WAIT);\n\tusleep_range(200, 250);\n\tadf7242_write_reg(lp, REG_PKT_CFG, ADDON_EN | BIT(2));\n\tadf7242_cmd(lp, CMD_RC_PHY_RDY);\n\tadf7242_set_promiscuous_mode(lp->hw, lp->promiscuous);\n\tadf7242_set_csma_params(lp->hw, lp->min_be, lp->max_be,\n\t\t\t\tlp->max_cca_retries);\n\tadf7242_clear_irqstat(lp);\n\n\tif (test_bit(FLAG_START, &lp->flags)) {\n\t\tenable_irq(lp->spi->irq);\n\t\treturn adf7242_cmd(lp, CMD_RC_RX);\n\t}\n\n\treturn 0;\n}\n\nstatic int adf7242_hw_init(struct adf7242_local *lp)\n{\n\tint ret;\n\tconst struct firmware *fw;\n\n\tadf7242_cmd(lp, CMD_RC_RESET);\n\tadf7242_cmd(lp, CMD_RC_IDLE);\n\n\t \n\tret = request_firmware(&fw, FIRMWARE, &lp->spi->dev);\n\tif (ret) {\n\t\tdev_err(&lp->spi->dev,\n\t\t\t\"request_firmware() failed with %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = adf7242_upload_firmware(lp, (u8 *)fw->data, fw->size);\n\tif (ret) {\n\t\tdev_err(&lp->spi->dev,\n\t\t\t\"upload firmware failed with %d\\n\", ret);\n\t\trelease_firmware(fw);\n\t\treturn ret;\n\t}\n\n\tret = adf7242_verify_firmware(lp, (u8 *)fw->data, fw->size);\n\tif (ret) {\n\t\tdev_err(&lp->spi->dev,\n\t\t\t\"verify firmware failed with %d\\n\", ret);\n\t\trelease_firmware(fw);\n\t\treturn ret;\n\t}\n\n\tadf7242_cmd(lp, CMD_RC_PC_RESET);\n\n\trelease_firmware(fw);\n\n\tadf7242_write_reg(lp, REG_FFILT_CFG,\n\t\t\t  ACCEPT_BEACON_FRAMES |\n\t\t\t  ACCEPT_DATA_FRAMES |\n\t\t\t  ACCEPT_MACCMD_FRAMES |\n\t\t\t  ACCEPT_RESERVED_FRAMES);\n\n\tadf7242_write_reg(lp, REG_AUTO_CFG, RX_AUTO_ACK_EN);\n\n\tadf7242_write_reg(lp, REG_PKT_CFG, ADDON_EN | BIT(2));\n\n\tadf7242_write_reg(lp, REG_EXTPA_MSC, 0xF1);\n\tadf7242_write_reg(lp, REG_RXFE_CFG, 0x1D);\n\n\tadf7242_write_reg(lp, REG_IRQ1_EN0, 0);\n\tadf7242_write_reg(lp, REG_IRQ1_EN1, IRQ_RX_PKT_RCVD | IRQ_CSMA_CA);\n\n\tadf7242_clear_irqstat(lp);\n\tadf7242_write_reg(lp, REG_IRQ1_SRC0, 0xFF);\n\n\tadf7242_cmd(lp, CMD_RC_IDLE);\n\n\treturn 0;\n}\n\nstatic int adf7242_stats_show(struct seq_file *file, void *offset)\n{\n\tstruct adf7242_local *lp = spi_get_drvdata(file->private);\n\tu8 stat, irq1;\n\n\tadf7242_status(lp, &stat);\n\tadf7242_read_reg(lp, REG_IRQ1_SRC1, &irq1);\n\n\tseq_printf(file, \"IRQ1 = %X:\\n%s%s%s%s%s%s%s%s\\n\", irq1,\n\t\t   irq1 & IRQ_CCA_COMPLETE ? \"IRQ_CCA_COMPLETE\\n\" : \"\",\n\t\t   irq1 & IRQ_SFD_RX ? \"IRQ_SFD_RX\\n\" : \"\",\n\t\t   irq1 & IRQ_SFD_TX ? \"IRQ_SFD_TX\\n\" : \"\",\n\t\t   irq1 & IRQ_RX_PKT_RCVD ? \"IRQ_RX_PKT_RCVD\\n\" : \"\",\n\t\t   irq1 & IRQ_TX_PKT_SENT ? \"IRQ_TX_PKT_SENT\\n\" : \"\",\n\t\t   irq1 & IRQ_CSMA_CA ? \"IRQ_CSMA_CA\\n\" : \"\",\n\t\t   irq1 & IRQ_FRAME_VALID ? \"IRQ_FRAME_VALID\\n\" : \"\",\n\t\t   irq1 & IRQ_ADDRESS_VALID ? \"IRQ_ADDRESS_VALID\\n\" : \"\");\n\n\tseq_printf(file, \"STATUS = %X:\\n%s\\n%s\\n%s\\n%s\\n%s%s%s%s%s\\n\", stat,\n\t\t   stat & STAT_SPI_READY ? \"SPI_READY\" : \"SPI_BUSY\",\n\t\t   stat & STAT_IRQ_STATUS ? \"IRQ_PENDING\" : \"IRQ_CLEAR\",\n\t\t   stat & STAT_RC_READY ? \"RC_READY\" : \"RC_BUSY\",\n\t\t   stat & STAT_CCA_RESULT ? \"CHAN_IDLE\" : \"CHAN_BUSY\",\n\t\t   (stat & 0xf) == RC_STATUS_IDLE ? \"RC_STATUS_IDLE\" : \"\",\n\t\t   (stat & 0xf) == RC_STATUS_MEAS ? \"RC_STATUS_MEAS\" : \"\",\n\t\t   (stat & 0xf) == RC_STATUS_PHY_RDY ? \"RC_STATUS_PHY_RDY\" : \"\",\n\t\t   (stat & 0xf) == RC_STATUS_RX ? \"RC_STATUS_RX\" : \"\",\n\t\t   (stat & 0xf) == RC_STATUS_TX ? \"RC_STATUS_TX\" : \"\");\n\n\tseq_printf(file, \"RSSI = %d\\n\", lp->rssi);\n\n\treturn 0;\n}\n\nstatic void adf7242_debugfs_init(struct adf7242_local *lp)\n{\n\tchar debugfs_dir_name[DNAME_INLINE_LEN + 1];\n\n\tsnprintf(debugfs_dir_name, sizeof(debugfs_dir_name),\n\t\t \"adf7242-%s\", dev_name(&lp->spi->dev));\n\n\tlp->debugfs_root = debugfs_create_dir(debugfs_dir_name, NULL);\n\n\tdebugfs_create_devm_seqfile(&lp->spi->dev, \"status\", lp->debugfs_root,\n\t\t\t\t    adf7242_stats_show);\n}\n\nstatic const s32 adf7242_powers[] = {\n\t500, 400, 300, 200, 100, 0, -100, -200, -300, -400, -500, -600, -700,\n\t-800, -900, -1000, -1100, -1200, -1300, -1400, -1500, -1600, -1700,\n\t-1800, -1900, -2000, -2100, -2200, -2300, -2400, -2500, -2600,\n};\n\nstatic const s32 adf7242_ed_levels[] = {\n\t-9000, -8900, -8800, -8700, -8600, -8500, -8400, -8300, -8200, -8100,\n\t-8000, -7900, -7800, -7700, -7600, -7500, -7400, -7300, -7200, -7100,\n\t-7000, -6900, -6800, -6700, -6600, -6500, -6400, -6300, -6200, -6100,\n\t-6000, -5900, -5800, -5700, -5600, -5500, -5400, -5300, -5200, -5100,\n\t-5000, -4900, -4800, -4700, -4600, -4500, -4400, -4300, -4200, -4100,\n\t-4000, -3900, -3800, -3700, -3600, -3500, -3400, -3200, -3100, -3000\n};\n\nstatic int adf7242_probe(struct spi_device *spi)\n{\n\tstruct ieee802154_hw *hw;\n\tstruct adf7242_local *lp;\n\tint ret, irq_type;\n\n\tif (!spi->irq) {\n\t\tdev_err(&spi->dev, \"no IRQ specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thw = ieee802154_alloc_hw(sizeof(*lp), &adf7242_ops);\n\tif (!hw)\n\t\treturn -ENOMEM;\n\n\tlp = hw->priv;\n\tlp->hw = hw;\n\tlp->spi = spi;\n\n\thw->priv = lp;\n\thw->parent = &spi->dev;\n\thw->extra_tx_headroom = 0;\n\n\t \n\thw->phy->supported.channels[0] = 0x7FFF800;\n\n\thw->flags = IEEE802154_HW_OMIT_CKSUM |\n\t\t    IEEE802154_HW_CSMA_PARAMS |\n\t\t    IEEE802154_HW_FRAME_RETRIES | IEEE802154_HW_AFILT |\n\t\t    IEEE802154_HW_PROMISCUOUS;\n\n\thw->phy->flags = WPAN_PHY_FLAG_TXPOWER |\n\t\t\t WPAN_PHY_FLAG_CCA_ED_LEVEL |\n\t\t\t WPAN_PHY_FLAG_CCA_MODE;\n\n\thw->phy->supported.cca_modes = BIT(NL802154_CCA_ENERGY);\n\n\thw->phy->supported.cca_ed_levels = adf7242_ed_levels;\n\thw->phy->supported.cca_ed_levels_size = ARRAY_SIZE(adf7242_ed_levels);\n\n\thw->phy->cca.mode = NL802154_CCA_ENERGY;\n\n\thw->phy->supported.tx_powers = adf7242_powers;\n\thw->phy->supported.tx_powers_size = ARRAY_SIZE(adf7242_powers);\n\n\thw->phy->supported.min_minbe = 0;\n\thw->phy->supported.max_minbe = 8;\n\n\thw->phy->supported.min_maxbe = 3;\n\thw->phy->supported.max_maxbe = 8;\n\n\thw->phy->supported.min_frame_retries = 0;\n\thw->phy->supported.max_frame_retries = 15;\n\n\thw->phy->supported.min_csma_backoffs = 0;\n\thw->phy->supported.max_csma_backoffs = 5;\n\n\tieee802154_random_extended_addr(&hw->phy->perm_extended_addr);\n\n\tmutex_init(&lp->bmux);\n\tinit_completion(&lp->tx_complete);\n\n\t \n\tlp->stat_xfer.len = 1;\n\tlp->stat_xfer.tx_buf = &lp->buf_stat_tx;\n\tlp->stat_xfer.rx_buf = &lp->buf_stat_rx;\n\tlp->buf_stat_tx = CMD_SPI_NOP;\n\n\tspi_message_init(&lp->stat_msg);\n\tspi_message_add_tail(&lp->stat_xfer, &lp->stat_msg);\n\n\tspi_set_drvdata(spi, lp);\n\tINIT_DELAYED_WORK(&lp->work, adf7242_rx_cal_work);\n\tlp->wqueue = alloc_ordered_workqueue(dev_name(&spi->dev),\n\t\t\t\t\t     WQ_MEM_RECLAIM);\n\tif (unlikely(!lp->wqueue)) {\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc_wq;\n\t}\n\n\tret = adf7242_hw_init(lp);\n\tif (ret)\n\t\tgoto err_hw_init;\n\n\tirq_type = irq_get_trigger_type(spi->irq);\n\tif (!irq_type)\n\t\tirq_type = IRQF_TRIGGER_HIGH;\n\n\tret = devm_request_threaded_irq(&spi->dev, spi->irq, NULL, adf7242_isr,\n\t\t\t\t\tirq_type | IRQF_ONESHOT,\n\t\t\t\t\tdev_name(&spi->dev), lp);\n\tif (ret)\n\t\tgoto err_hw_init;\n\n\tdisable_irq(spi->irq);\n\n\tret = ieee802154_register_hw(lp->hw);\n\tif (ret)\n\t\tgoto err_hw_init;\n\n\tdev_set_drvdata(&spi->dev, lp);\n\n\tadf7242_debugfs_init(lp);\n\n\tdev_info(&spi->dev, \"mac802154 IRQ-%d registered\\n\", spi->irq);\n\n\treturn ret;\n\nerr_hw_init:\n\tdestroy_workqueue(lp->wqueue);\nerr_alloc_wq:\n\tmutex_destroy(&lp->bmux);\n\tieee802154_free_hw(lp->hw);\n\n\treturn ret;\n}\n\nstatic void adf7242_remove(struct spi_device *spi)\n{\n\tstruct adf7242_local *lp = spi_get_drvdata(spi);\n\n\tdebugfs_remove_recursive(lp->debugfs_root);\n\n\tieee802154_unregister_hw(lp->hw);\n\n\tcancel_delayed_work_sync(&lp->work);\n\tdestroy_workqueue(lp->wqueue);\n\n\tmutex_destroy(&lp->bmux);\n\tieee802154_free_hw(lp->hw);\n}\n\nstatic const struct of_device_id adf7242_of_match[] = {\n\t{ .compatible = \"adi,adf7242\", },\n\t{ .compatible = \"adi,adf7241\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, adf7242_of_match);\n\nstatic const struct spi_device_id adf7242_device_id[] = {\n\t{ .name = \"adf7242\", },\n\t{ .name = \"adf7241\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(spi, adf7242_device_id);\n\nstatic struct spi_driver adf7242_driver = {\n\t.id_table = adf7242_device_id,\n\t.driver = {\n\t\t   .of_match_table = adf7242_of_match,\n\t\t   .name = \"adf7242\",\n\t\t   },\n\t.probe = adf7242_probe,\n\t.remove = adf7242_remove,\n};\n\nmodule_spi_driver(adf7242_driver);\n\nMODULE_AUTHOR(\"Michael Hennerich <michael.hennerich@analog.com>\");\nMODULE_DESCRIPTION(\"ADF7242 IEEE802.15.4 Transceiver Driver\");\nMODULE_LICENSE(\"GPL\");\n\nMODULE_FIRMWARE(FIRMWARE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}