{
  "module_name": "fakelb.c",
  "hash_id": "133d292e6ee5468834a2dca1efc789552736b379524deb1cc184e3f981897bf5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ieee802154/fakelb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/timer.h>\n#include <linux/platform_device.h>\n#include <linux/netdevice.h>\n#include <linux/device.h>\n#include <linux/spinlock.h>\n#include <net/mac802154.h>\n#include <net/cfg802154.h>\n\nstatic int numlbs = 2;\n\nstatic LIST_HEAD(fakelb_phys);\nstatic DEFINE_MUTEX(fakelb_phys_lock);\n\nstatic LIST_HEAD(fakelb_ifup_phys);\nstatic DEFINE_RWLOCK(fakelb_ifup_phys_lock);\n\nstruct fakelb_phy {\n\tstruct ieee802154_hw *hw;\n\n\tu8 page;\n\tu8 channel;\n\n\tbool suspended;\n\n\tstruct list_head list;\n\tstruct list_head list_ifup;\n};\n\nstatic int fakelb_hw_ed(struct ieee802154_hw *hw, u8 *level)\n{\n\tWARN_ON(!level);\n\t*level = 0xbe;\n\n\treturn 0;\n}\n\nstatic int fakelb_hw_channel(struct ieee802154_hw *hw, u8 page, u8 channel)\n{\n\tstruct fakelb_phy *phy = hw->priv;\n\n\twrite_lock_bh(&fakelb_ifup_phys_lock);\n\tphy->page = page;\n\tphy->channel = channel;\n\twrite_unlock_bh(&fakelb_ifup_phys_lock);\n\treturn 0;\n}\n\nstatic int fakelb_hw_xmit(struct ieee802154_hw *hw, struct sk_buff *skb)\n{\n\tstruct fakelb_phy *current_phy = hw->priv, *phy;\n\n\tread_lock_bh(&fakelb_ifup_phys_lock);\n\tWARN_ON(current_phy->suspended);\n\tlist_for_each_entry(phy, &fakelb_ifup_phys, list_ifup) {\n\t\tif (current_phy == phy)\n\t\t\tcontinue;\n\n\t\tif (current_phy->page == phy->page &&\n\t\t    current_phy->channel == phy->channel) {\n\t\t\tstruct sk_buff *newskb = pskb_copy(skb, GFP_ATOMIC);\n\n\t\t\tif (newskb)\n\t\t\t\tieee802154_rx_irqsafe(phy->hw, newskb, 0xcc);\n\t\t}\n\t}\n\tread_unlock_bh(&fakelb_ifup_phys_lock);\n\n\tieee802154_xmit_complete(hw, skb, false);\n\treturn 0;\n}\n\nstatic int fakelb_hw_start(struct ieee802154_hw *hw)\n{\n\tstruct fakelb_phy *phy = hw->priv;\n\n\twrite_lock_bh(&fakelb_ifup_phys_lock);\n\tphy->suspended = false;\n\tlist_add(&phy->list_ifup, &fakelb_ifup_phys);\n\twrite_unlock_bh(&fakelb_ifup_phys_lock);\n\n\treturn 0;\n}\n\nstatic void fakelb_hw_stop(struct ieee802154_hw *hw)\n{\n\tstruct fakelb_phy *phy = hw->priv;\n\n\twrite_lock_bh(&fakelb_ifup_phys_lock);\n\tphy->suspended = true;\n\tlist_del(&phy->list_ifup);\n\twrite_unlock_bh(&fakelb_ifup_phys_lock);\n}\n\nstatic int\nfakelb_set_promiscuous_mode(struct ieee802154_hw *hw, const bool on)\n{\n\treturn 0;\n}\n\nstatic const struct ieee802154_ops fakelb_ops = {\n\t.owner = THIS_MODULE,\n\t.xmit_async = fakelb_hw_xmit,\n\t.ed = fakelb_hw_ed,\n\t.set_channel = fakelb_hw_channel,\n\t.start = fakelb_hw_start,\n\t.stop = fakelb_hw_stop,\n\t.set_promiscuous_mode = fakelb_set_promiscuous_mode,\n};\n\n \nmodule_param(numlbs, int, 0);\nMODULE_PARM_DESC(numlbs, \" number of pseudo devices\");\n\nstatic int fakelb_add_one(struct device *dev)\n{\n\tstruct ieee802154_hw *hw;\n\tstruct fakelb_phy *phy;\n\tint err;\n\n\thw = ieee802154_alloc_hw(sizeof(*phy), &fakelb_ops);\n\tif (!hw)\n\t\treturn -ENOMEM;\n\n\tphy = hw->priv;\n\tphy->hw = hw;\n\n\t \n\thw->phy->supported.channels[0] |= 1;\n\t \n\thw->phy->supported.channels[0] |= 0x7fe;\n\t \n\thw->phy->supported.channels[0] |= 0x7FFF800;\n\t \n\thw->phy->supported.channels[1] |= 1;\n\t \n\thw->phy->supported.channels[1] |= 0x7fe;\n\t \n\thw->phy->supported.channels[2] |= 1;\n\t \n\thw->phy->supported.channels[2] |= 0x7fe;\n\t \n\thw->phy->supported.channels[3] |= 0x3fff;\n\t \n\thw->phy->supported.channels[4] |= 1;\n\t \n\thw->phy->supported.channels[4] |= 0x1e;\n\t \n\thw->phy->supported.channels[4] |= 0xffe0;\n\t \n\thw->phy->supported.channels[5] |= 0xf;\n\t \n\thw->phy->supported.channels[5] |= 0xf0;\n\t \n\thw->phy->supported.channels[6] |= 0x3ff;\n\t \n\thw->phy->supported.channels[6] |= 0x3ffc00;\n\n\tieee802154_random_extended_addr(&hw->phy->perm_extended_addr);\n\t \n\thw->phy->current_channel = 13;\n\tphy->channel = hw->phy->current_channel;\n\n\thw->flags = IEEE802154_HW_PROMISCUOUS;\n\thw->parent = dev;\n\n\terr = ieee802154_register_hw(hw);\n\tif (err)\n\t\tgoto err_reg;\n\n\tmutex_lock(&fakelb_phys_lock);\n\tlist_add_tail(&phy->list, &fakelb_phys);\n\tmutex_unlock(&fakelb_phys_lock);\n\n\treturn 0;\n\nerr_reg:\n\tieee802154_free_hw(phy->hw);\n\treturn err;\n}\n\nstatic void fakelb_del(struct fakelb_phy *phy)\n{\n\tlist_del(&phy->list);\n\n\tieee802154_unregister_hw(phy->hw);\n\tieee802154_free_hw(phy->hw);\n}\n\nstatic int fakelb_probe(struct platform_device *pdev)\n{\n\tstruct fakelb_phy *phy, *tmp;\n\tint err, i;\n\n\tfor (i = 0; i < numlbs; i++) {\n\t\terr = fakelb_add_one(&pdev->dev);\n\t\tif (err < 0)\n\t\t\tgoto err_slave;\n\t}\n\n\tdev_info(&pdev->dev, \"added %i fake ieee802154 hardware devices\\n\", numlbs);\n\treturn 0;\n\nerr_slave:\n\tmutex_lock(&fakelb_phys_lock);\n\tlist_for_each_entry_safe(phy, tmp, &fakelb_phys, list)\n\t\tfakelb_del(phy);\n\tmutex_unlock(&fakelb_phys_lock);\n\treturn err;\n}\n\nstatic int fakelb_remove(struct platform_device *pdev)\n{\n\tstruct fakelb_phy *phy, *tmp;\n\n\tmutex_lock(&fakelb_phys_lock);\n\tlist_for_each_entry_safe(phy, tmp, &fakelb_phys, list)\n\t\tfakelb_del(phy);\n\tmutex_unlock(&fakelb_phys_lock);\n\treturn 0;\n}\n\nstatic struct platform_device *ieee802154fake_dev;\n\nstatic struct platform_driver ieee802154fake_driver = {\n\t.probe = fakelb_probe,\n\t.remove = fakelb_remove,\n\t.driver = {\n\t\t\t.name = \"ieee802154fakelb\",\n\t},\n};\n\nstatic __init int fakelb_init_module(void)\n{\n\tieee802154fake_dev = platform_device_register_simple(\n\t\t\t     \"ieee802154fakelb\", -1, NULL, 0);\n\n\tpr_warn(\"fakelb driver is marked as deprecated, please use mac802154_hwsim!\\n\");\n\n\treturn platform_driver_register(&ieee802154fake_driver);\n}\n\nstatic __exit void fake_remove_module(void)\n{\n\tplatform_driver_unregister(&ieee802154fake_driver);\n\tplatform_device_unregister(ieee802154fake_dev);\n}\n\nmodule_init(fakelb_init_module);\nmodule_exit(fake_remove_module);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}