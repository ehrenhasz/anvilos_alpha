{
  "module_name": "at86rf230.c",
  "hash_id": "4e58a296f6b036a5e4ac1fc0aa3ad3767399afb4e2be707728226e161afa159d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ieee802154/at86rf230.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/hrtimer.h>\n#include <linux/jiffies.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/gpio.h>\n#include <linux/delay.h>\n#include <linux/property.h>\n#include <linux/spi/spi.h>\n#include <linux/regmap.h>\n#include <linux/skbuff.h>\n#include <linux/of_gpio.h>\n#include <linux/ieee802154.h>\n\n#include <net/mac802154.h>\n#include <net/cfg802154.h>\n\n#include \"at86rf230.h\"\n\nstruct at86rf230_local;\n \nstruct at86rf2xx_chip_data {\n\tu16 t_sleep_cycle;\n\tu16 t_channel_switch;\n\tu16 t_reset_to_off;\n\tu16 t_off_to_aack;\n\tu16 t_off_to_tx_on;\n\tu16 t_off_to_sleep;\n\tu16 t_sleep_to_off;\n\tu16 t_frame;\n\tu16 t_p_ack;\n\tint rssi_base_val;\n\n\tint (*set_channel)(struct at86rf230_local *, u8, u8);\n\tint (*set_txpower)(struct at86rf230_local *, s32);\n};\n\n#define AT86RF2XX_MAX_BUF\t\t(127 + 3)\n \n#define AT86RF2XX_MAX_TX_RETRIES\t7\n \n#define AT86RF2XX_CAL_LOOP_TIMEOUT\t(5 * 60 * HZ)\n\nstruct at86rf230_state_change {\n\tstruct at86rf230_local *lp;\n\tint irq;\n\n\tstruct hrtimer timer;\n\tstruct spi_message msg;\n\tstruct spi_transfer trx;\n\tu8 buf[AT86RF2XX_MAX_BUF];\n\n\tvoid (*complete)(void *context);\n\tu8 from_state;\n\tu8 to_state;\n\tint trac;\n\n\tbool free;\n};\n\nstruct at86rf230_local {\n\tstruct spi_device *spi;\n\n\tstruct ieee802154_hw *hw;\n\tstruct at86rf2xx_chip_data *data;\n\tstruct regmap *regmap;\n\tstruct gpio_desc *slp_tr;\n\tbool sleep;\n\n\tstruct completion state_complete;\n\tstruct at86rf230_state_change state;\n\n\tunsigned long cal_timeout;\n\tbool is_tx;\n\tbool is_tx_from_off;\n\tbool was_tx;\n\tu8 tx_retry;\n\tstruct sk_buff *tx_skb;\n\tstruct at86rf230_state_change tx;\n};\n\n#define AT86RF2XX_NUMREGS 0x3F\n\nstatic void\nat86rf230_async_state_change(struct at86rf230_local *lp,\n\t\t\t     struct at86rf230_state_change *ctx,\n\t\t\t     const u8 state, void (*complete)(void *context));\n\nstatic inline void\nat86rf230_sleep(struct at86rf230_local *lp)\n{\n\tif (lp->slp_tr) {\n\t\tgpiod_set_value(lp->slp_tr, 1);\n\t\tusleep_range(lp->data->t_off_to_sleep,\n\t\t\t     lp->data->t_off_to_sleep + 10);\n\t\tlp->sleep = true;\n\t}\n}\n\nstatic inline void\nat86rf230_awake(struct at86rf230_local *lp)\n{\n\tif (lp->slp_tr) {\n\t\tgpiod_set_value(lp->slp_tr, 0);\n\t\tusleep_range(lp->data->t_sleep_to_off,\n\t\t\t     lp->data->t_sleep_to_off + 100);\n\t\tlp->sleep = false;\n\t}\n}\n\nstatic inline int\n__at86rf230_write(struct at86rf230_local *lp,\n\t\t  unsigned int addr, unsigned int data)\n{\n\tbool sleep = lp->sleep;\n\tint ret;\n\n\t \n\tif (sleep)\n\t\tat86rf230_awake(lp);\n\n\tret = regmap_write(lp->regmap, addr, data);\n\n\t \n\tif (sleep)\n\t\tat86rf230_sleep(lp);\n\n\treturn ret;\n}\n\nstatic inline int\n__at86rf230_read(struct at86rf230_local *lp,\n\t\t unsigned int addr, unsigned int *data)\n{\n\tbool sleep = lp->sleep;\n\tint ret;\n\n\t \n\tif (sleep)\n\t\tat86rf230_awake(lp);\n\n\tret = regmap_read(lp->regmap, addr, data);\n\n\t \n\tif (sleep)\n\t\tat86rf230_sleep(lp);\n\n\treturn ret;\n}\n\nstatic inline int\nat86rf230_read_subreg(struct at86rf230_local *lp,\n\t\t      unsigned int addr, unsigned int mask,\n\t\t      unsigned int shift, unsigned int *data)\n{\n\tint rc;\n\n\trc = __at86rf230_read(lp, addr, data);\n\tif (!rc)\n\t\t*data = (*data & mask) >> shift;\n\n\treturn rc;\n}\n\nstatic inline int\nat86rf230_write_subreg(struct at86rf230_local *lp,\n\t\t       unsigned int addr, unsigned int mask,\n\t\t       unsigned int shift, unsigned int data)\n{\n\tbool sleep = lp->sleep;\n\tint ret;\n\n\t \n\tif (sleep)\n\t\tat86rf230_awake(lp);\n\n\tret = regmap_update_bits(lp->regmap, addr, mask, data << shift);\n\n\t \n\tif (sleep)\n\t\tat86rf230_sleep(lp);\n\n\treturn ret;\n}\n\nstatic inline void\nat86rf230_slp_tr_rising_edge(struct at86rf230_local *lp)\n{\n\tgpiod_set_value(lp->slp_tr, 1);\n\tudelay(1);\n\tgpiod_set_value(lp->slp_tr, 0);\n}\n\nstatic bool\nat86rf230_reg_writeable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase RG_TRX_STATE:\n\tcase RG_TRX_CTRL_0:\n\tcase RG_TRX_CTRL_1:\n\tcase RG_PHY_TX_PWR:\n\tcase RG_PHY_ED_LEVEL:\n\tcase RG_PHY_CC_CCA:\n\tcase RG_CCA_THRES:\n\tcase RG_RX_CTRL:\n\tcase RG_SFD_VALUE:\n\tcase RG_TRX_CTRL_2:\n\tcase RG_ANT_DIV:\n\tcase RG_IRQ_MASK:\n\tcase RG_VREG_CTRL:\n\tcase RG_BATMON:\n\tcase RG_XOSC_CTRL:\n\tcase RG_RX_SYN:\n\tcase RG_XAH_CTRL_1:\n\tcase RG_FTN_CTRL:\n\tcase RG_PLL_CF:\n\tcase RG_PLL_DCU:\n\tcase RG_SHORT_ADDR_0:\n\tcase RG_SHORT_ADDR_1:\n\tcase RG_PAN_ID_0:\n\tcase RG_PAN_ID_1:\n\tcase RG_IEEE_ADDR_0:\n\tcase RG_IEEE_ADDR_1:\n\tcase RG_IEEE_ADDR_2:\n\tcase RG_IEEE_ADDR_3:\n\tcase RG_IEEE_ADDR_4:\n\tcase RG_IEEE_ADDR_5:\n\tcase RG_IEEE_ADDR_6:\n\tcase RG_IEEE_ADDR_7:\n\tcase RG_XAH_CTRL_0:\n\tcase RG_CSMA_SEED_0:\n\tcase RG_CSMA_SEED_1:\n\tcase RG_CSMA_BE:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool\nat86rf230_reg_readable(struct device *dev, unsigned int reg)\n{\n\tbool rc;\n\n\t \n\trc = at86rf230_reg_writeable(dev, reg);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tswitch (reg) {\n\tcase RG_TRX_STATUS:\n\tcase RG_PHY_RSSI:\n\tcase RG_IRQ_STATUS:\n\tcase RG_PART_NUM:\n\tcase RG_VERSION_NUM:\n\tcase RG_MAN_ID_1:\n\tcase RG_MAN_ID_0:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool\nat86rf230_reg_volatile(struct device *dev, unsigned int reg)\n{\n\t \n\tswitch (reg) {\n\tcase RG_TRX_STATUS:\n\tcase RG_TRX_STATE:\n\tcase RG_PHY_RSSI:\n\tcase RG_PHY_ED_LEVEL:\n\tcase RG_IRQ_STATUS:\n\tcase RG_VREG_CTRL:\n\tcase RG_PLL_CF:\n\tcase RG_PLL_DCU:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool\nat86rf230_reg_precious(struct device *dev, unsigned int reg)\n{\n\t \n\tswitch (reg) {\n\tcase RG_IRQ_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config at86rf230_regmap_spi_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.write_flag_mask = CMD_REG | CMD_WRITE,\n\t.read_flag_mask = CMD_REG,\n\t.cache_type = REGCACHE_RBTREE,\n\t.max_register = AT86RF2XX_NUMREGS,\n\t.writeable_reg = at86rf230_reg_writeable,\n\t.readable_reg = at86rf230_reg_readable,\n\t.volatile_reg = at86rf230_reg_volatile,\n\t.precious_reg = at86rf230_reg_precious,\n};\n\nstatic void\nat86rf230_async_error_recover_complete(void *context)\n{\n\tstruct at86rf230_state_change *ctx = context;\n\tstruct at86rf230_local *lp = ctx->lp;\n\n\tif (ctx->free)\n\t\tkfree(ctx);\n\n\tif (lp->was_tx) {\n\t\tlp->was_tx = 0;\n\t\tieee802154_xmit_hw_error(lp->hw, lp->tx_skb);\n\t}\n}\n\nstatic void\nat86rf230_async_error_recover(void *context)\n{\n\tstruct at86rf230_state_change *ctx = context;\n\tstruct at86rf230_local *lp = ctx->lp;\n\n\tif (lp->is_tx) {\n\t\tlp->was_tx = 1;\n\t\tlp->is_tx = 0;\n\t}\n\n\tat86rf230_async_state_change(lp, ctx, STATE_RX_AACK_ON,\n\t\t\t\t     at86rf230_async_error_recover_complete);\n}\n\nstatic inline void\nat86rf230_async_error(struct at86rf230_local *lp,\n\t\t      struct at86rf230_state_change *ctx, int rc)\n{\n\tdev_err(&lp->spi->dev, \"spi_async error %d\\n\", rc);\n\n\tat86rf230_async_state_change(lp, ctx, STATE_FORCE_TRX_OFF,\n\t\t\t\t     at86rf230_async_error_recover);\n}\n\n \nstatic void\nat86rf230_async_read_reg(struct at86rf230_local *lp, u8 reg,\n\t\t\t struct at86rf230_state_change *ctx,\n\t\t\t void (*complete)(void *context))\n{\n\tint rc;\n\n\tu8 *tx_buf = ctx->buf;\n\n\ttx_buf[0] = (reg & CMD_REG_MASK) | CMD_REG;\n\tctx->msg.complete = complete;\n\trc = spi_async(lp->spi, &ctx->msg);\n\tif (rc)\n\t\tat86rf230_async_error(lp, ctx, rc);\n}\n\nstatic void\nat86rf230_async_write_reg(struct at86rf230_local *lp, u8 reg, u8 val,\n\t\t\t  struct at86rf230_state_change *ctx,\n\t\t\t  void (*complete)(void *context))\n{\n\tint rc;\n\n\tctx->buf[0] = (reg & CMD_REG_MASK) | CMD_REG | CMD_WRITE;\n\tctx->buf[1] = val;\n\tctx->msg.complete = complete;\n\trc = spi_async(lp->spi, &ctx->msg);\n\tif (rc)\n\t\tat86rf230_async_error(lp, ctx, rc);\n}\n\nstatic void\nat86rf230_async_state_assert(void *context)\n{\n\tstruct at86rf230_state_change *ctx = context;\n\tstruct at86rf230_local *lp = ctx->lp;\n\tconst u8 *buf = ctx->buf;\n\tconst u8 trx_state = buf[1] & TRX_STATE_MASK;\n\n\t \n\tif (trx_state != ctx->to_state) {\n\t\t \n\t\tif  (trx_state == STATE_BUSY_RX_AACK) {\n\t\t\t \n\t\t\tif (ctx->to_state == STATE_RX_AACK_ON)\n\t\t\t\tgoto done;\n\n\t\t\t \n\t\t\tif (ctx->to_state == STATE_TX_ON ||\n\t\t\t    ctx->to_state == STATE_TRX_OFF) {\n\t\t\t\tu8 state = ctx->to_state;\n\n\t\t\t\tif (lp->tx_retry >= AT86RF2XX_MAX_TX_RETRIES)\n\t\t\t\t\tstate = STATE_FORCE_TRX_OFF;\n\t\t\t\tlp->tx_retry++;\n\n\t\t\t\tat86rf230_async_state_change(lp, ctx, state,\n\t\t\t\t\t\t\t     ctx->complete);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tdev_warn(&lp->spi->dev, \"unexcept state change from 0x%02x to 0x%02x. Actual state: 0x%02x\\n\",\n\t\t\t ctx->from_state, ctx->to_state, trx_state);\n\t}\n\ndone:\n\tif (ctx->complete)\n\t\tctx->complete(context);\n}\n\nstatic enum hrtimer_restart at86rf230_async_state_timer(struct hrtimer *timer)\n{\n\tstruct at86rf230_state_change *ctx =\n\t\tcontainer_of(timer, struct at86rf230_state_change, timer);\n\tstruct at86rf230_local *lp = ctx->lp;\n\n\tat86rf230_async_read_reg(lp, RG_TRX_STATUS, ctx,\n\t\t\t\t at86rf230_async_state_assert);\n\n\treturn HRTIMER_NORESTART;\n}\n\n \nstatic void\nat86rf230_async_state_delay(void *context)\n{\n\tstruct at86rf230_state_change *ctx = context;\n\tstruct at86rf230_local *lp = ctx->lp;\n\tstruct at86rf2xx_chip_data *c = lp->data;\n\tbool force = false;\n\tktime_t tim;\n\n\t \n\tswitch (ctx->to_state) {\n\tcase STATE_FORCE_TX_ON:\n\t\tctx->to_state = STATE_TX_ON;\n\t\tforce = true;\n\t\tbreak;\n\tcase STATE_FORCE_TRX_OFF:\n\t\tctx->to_state = STATE_TRX_OFF;\n\t\tforce = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (ctx->from_state) {\n\tcase STATE_TRX_OFF:\n\t\tswitch (ctx->to_state) {\n\t\tcase STATE_RX_AACK_ON:\n\t\t\ttim = c->t_off_to_aack * NSEC_PER_USEC;\n\t\t\t \n\t\t\tlp->cal_timeout = jiffies + AT86RF2XX_CAL_LOOP_TIMEOUT;\n\t\t\tgoto change;\n\t\tcase STATE_TX_ARET_ON:\n\t\tcase STATE_TX_ON:\n\t\t\ttim = c->t_off_to_tx_on * NSEC_PER_USEC;\n\t\t\t \n\t\t\tlp->cal_timeout = jiffies + AT86RF2XX_CAL_LOOP_TIMEOUT;\n\t\t\tgoto change;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase STATE_BUSY_RX_AACK:\n\t\tswitch (ctx->to_state) {\n\t\tcase STATE_TRX_OFF:\n\t\tcase STATE_TX_ON:\n\t\t\t \n\t\t\tif (!force) {\n\t\t\t\ttim = (c->t_frame + c->t_p_ack) * NSEC_PER_USEC;\n\t\t\t\tgoto change;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t \n\tcase STATE_P_ON:\n\t\tswitch (ctx->to_state) {\n\t\tcase STATE_TRX_OFF:\n\t\t\ttim = c->t_reset_to_off * NSEC_PER_USEC;\n\t\t\tgoto change;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tudelay(1);\n\tat86rf230_async_state_timer(&ctx->timer);\n\treturn;\n\nchange:\n\thrtimer_start(&ctx->timer, tim, HRTIMER_MODE_REL);\n}\n\nstatic void\nat86rf230_async_state_change_start(void *context)\n{\n\tstruct at86rf230_state_change *ctx = context;\n\tstruct at86rf230_local *lp = ctx->lp;\n\tu8 *buf = ctx->buf;\n\tconst u8 trx_state = buf[1] & TRX_STATE_MASK;\n\n\t \n\tif (trx_state == STATE_TRANSITION_IN_PROGRESS) {\n\t\tudelay(1);\n\t\tat86rf230_async_read_reg(lp, RG_TRX_STATUS, ctx,\n\t\t\t\t\t at86rf230_async_state_change_start);\n\t\treturn;\n\t}\n\n\t \n\tif (trx_state == ctx->to_state) {\n\t\tif (ctx->complete)\n\t\t\tctx->complete(context);\n\t\treturn;\n\t}\n\n\t \n\tctx->from_state = trx_state;\n\n\t \n\tat86rf230_async_write_reg(lp, RG_TRX_STATE, ctx->to_state, ctx,\n\t\t\t\t  at86rf230_async_state_delay);\n}\n\nstatic void\nat86rf230_async_state_change(struct at86rf230_local *lp,\n\t\t\t     struct at86rf230_state_change *ctx,\n\t\t\t     const u8 state, void (*complete)(void *context))\n{\n\t \n\tctx->to_state = state;\n\tctx->complete = complete;\n\tat86rf230_async_read_reg(lp, RG_TRX_STATUS, ctx,\n\t\t\t\t at86rf230_async_state_change_start);\n}\n\nstatic void\nat86rf230_sync_state_change_complete(void *context)\n{\n\tstruct at86rf230_state_change *ctx = context;\n\tstruct at86rf230_local *lp = ctx->lp;\n\n\tcomplete(&lp->state_complete);\n}\n\n \nstatic int\nat86rf230_sync_state_change(struct at86rf230_local *lp, unsigned int state)\n{\n\tunsigned long rc;\n\n\tat86rf230_async_state_change(lp, &lp->state, state,\n\t\t\t\t     at86rf230_sync_state_change_complete);\n\n\trc = wait_for_completion_timeout(&lp->state_complete,\n\t\t\t\t\t msecs_to_jiffies(100));\n\tif (!rc) {\n\t\tat86rf230_async_error(lp, &lp->state, -ETIMEDOUT);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nat86rf230_tx_complete(void *context)\n{\n\tstruct at86rf230_state_change *ctx = context;\n\tstruct at86rf230_local *lp = ctx->lp;\n\n\tif (ctx->trac == IEEE802154_SUCCESS)\n\t\tieee802154_xmit_complete(lp->hw, lp->tx_skb, false);\n\telse\n\t\tieee802154_xmit_error(lp->hw, lp->tx_skb, ctx->trac);\n\n\tkfree(ctx);\n}\n\nstatic void\nat86rf230_tx_on(void *context)\n{\n\tstruct at86rf230_state_change *ctx = context;\n\tstruct at86rf230_local *lp = ctx->lp;\n\n\tat86rf230_async_state_change(lp, ctx, STATE_RX_AACK_ON,\n\t\t\t\t     at86rf230_tx_complete);\n}\n\nstatic void\nat86rf230_tx_trac_check(void *context)\n{\n\tstruct at86rf230_state_change *ctx = context;\n\tstruct at86rf230_local *lp = ctx->lp;\n\tu8 trac = TRAC_MASK(ctx->buf[1]);\n\n\tswitch (trac) {\n\tcase TRAC_SUCCESS:\n\tcase TRAC_SUCCESS_DATA_PENDING:\n\t\tctx->trac = IEEE802154_SUCCESS;\n\t\tbreak;\n\tcase TRAC_CHANNEL_ACCESS_FAILURE:\n\t\tctx->trac = IEEE802154_CHANNEL_ACCESS_FAILURE;\n\t\tbreak;\n\tcase TRAC_NO_ACK:\n\t\tctx->trac = IEEE802154_NO_ACK;\n\t\tbreak;\n\tdefault:\n\t\tctx->trac = IEEE802154_SYSTEM_ERROR;\n\t}\n\n\tat86rf230_async_state_change(lp, ctx, STATE_TX_ON, at86rf230_tx_on);\n}\n\nstatic void\nat86rf230_rx_read_frame_complete(void *context)\n{\n\tstruct at86rf230_state_change *ctx = context;\n\tstruct at86rf230_local *lp = ctx->lp;\n\tconst u8 *buf = ctx->buf;\n\tstruct sk_buff *skb;\n\tu8 len, lqi;\n\n\tlen = buf[1];\n\tif (!ieee802154_is_valid_psdu_len(len)) {\n\t\tdev_vdbg(&lp->spi->dev, \"corrupted frame received\\n\");\n\t\tlen = IEEE802154_MTU;\n\t}\n\tlqi = buf[2 + len];\n\n\tskb = dev_alloc_skb(IEEE802154_MTU);\n\tif (!skb) {\n\t\tdev_vdbg(&lp->spi->dev, \"failed to allocate sk_buff\\n\");\n\t\tkfree(ctx);\n\t\treturn;\n\t}\n\n\tskb_put_data(skb, buf + 2, len);\n\tieee802154_rx_irqsafe(lp->hw, skb, lqi);\n\tkfree(ctx);\n}\n\nstatic void\nat86rf230_rx_trac_check(void *context)\n{\n\tstruct at86rf230_state_change *ctx = context;\n\tstruct at86rf230_local *lp = ctx->lp;\n\tu8 *buf = ctx->buf;\n\tint rc;\n\n\tbuf[0] = CMD_FB;\n\tctx->trx.len = AT86RF2XX_MAX_BUF;\n\tctx->msg.complete = at86rf230_rx_read_frame_complete;\n\trc = spi_async(lp->spi, &ctx->msg);\n\tif (rc) {\n\t\tctx->trx.len = 2;\n\t\tat86rf230_async_error(lp, ctx, rc);\n\t}\n}\n\nstatic void\nat86rf230_irq_trx_end(void *context)\n{\n\tstruct at86rf230_state_change *ctx = context;\n\tstruct at86rf230_local *lp = ctx->lp;\n\n\tif (lp->is_tx) {\n\t\tlp->is_tx = 0;\n\t\tat86rf230_async_read_reg(lp, RG_TRX_STATE, ctx,\n\t\t\t\t\t at86rf230_tx_trac_check);\n\t} else {\n\t\tat86rf230_async_read_reg(lp, RG_TRX_STATE, ctx,\n\t\t\t\t\t at86rf230_rx_trac_check);\n\t}\n}\n\nstatic void\nat86rf230_irq_status(void *context)\n{\n\tstruct at86rf230_state_change *ctx = context;\n\tstruct at86rf230_local *lp = ctx->lp;\n\tconst u8 *buf = ctx->buf;\n\tu8 irq = buf[1];\n\n\tenable_irq(lp->spi->irq);\n\n\tif (irq & IRQ_TRX_END) {\n\t\tat86rf230_irq_trx_end(ctx);\n\t} else {\n\t\tdev_err(&lp->spi->dev, \"not supported irq %02x received\\n\",\n\t\t\tirq);\n\t\tkfree(ctx);\n\t}\n}\n\nstatic void\nat86rf230_setup_spi_messages(struct at86rf230_local *lp,\n\t\t\t     struct at86rf230_state_change *state)\n{\n\tstate->lp = lp;\n\tstate->irq = lp->spi->irq;\n\tspi_message_init(&state->msg);\n\tstate->msg.context = state;\n\tstate->trx.len = 2;\n\tstate->trx.tx_buf = state->buf;\n\tstate->trx.rx_buf = state->buf;\n\tspi_message_add_tail(&state->trx, &state->msg);\n\thrtimer_init(&state->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tstate->timer.function = at86rf230_async_state_timer;\n}\n\nstatic irqreturn_t at86rf230_isr(int irq, void *data)\n{\n\tstruct at86rf230_local *lp = data;\n\tstruct at86rf230_state_change *ctx;\n\tint rc;\n\n\tdisable_irq_nosync(irq);\n\n\tctx = kzalloc(sizeof(*ctx), GFP_ATOMIC);\n\tif (!ctx) {\n\t\tenable_irq(irq);\n\t\treturn IRQ_NONE;\n\t}\n\n\tat86rf230_setup_spi_messages(lp, ctx);\n\t \n\tctx->free = true;\n\n\tctx->buf[0] = (RG_IRQ_STATUS & CMD_REG_MASK) | CMD_REG;\n\tctx->msg.complete = at86rf230_irq_status;\n\trc = spi_async(lp->spi, &ctx->msg);\n\tif (rc) {\n\t\tat86rf230_async_error(lp, ctx, rc);\n\t\tenable_irq(irq);\n\t\treturn IRQ_NONE;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void\nat86rf230_write_frame_complete(void *context)\n{\n\tstruct at86rf230_state_change *ctx = context;\n\tstruct at86rf230_local *lp = ctx->lp;\n\n\tctx->trx.len = 2;\n\n\tif (lp->slp_tr)\n\t\tat86rf230_slp_tr_rising_edge(lp);\n\telse\n\t\tat86rf230_async_write_reg(lp, RG_TRX_STATE, STATE_BUSY_TX, ctx,\n\t\t\t\t\t  NULL);\n}\n\nstatic void\nat86rf230_write_frame(void *context)\n{\n\tstruct at86rf230_state_change *ctx = context;\n\tstruct at86rf230_local *lp = ctx->lp;\n\tstruct sk_buff *skb = lp->tx_skb;\n\tu8 *buf = ctx->buf;\n\tint rc;\n\n\tlp->is_tx = 1;\n\n\tbuf[0] = CMD_FB | CMD_WRITE;\n\tbuf[1] = skb->len + 2;\n\tmemcpy(buf + 2, skb->data, skb->len);\n\tctx->trx.len = skb->len + 2;\n\tctx->msg.complete = at86rf230_write_frame_complete;\n\trc = spi_async(lp->spi, &ctx->msg);\n\tif (rc) {\n\t\tctx->trx.len = 2;\n\t\tat86rf230_async_error(lp, ctx, rc);\n\t}\n}\n\nstatic void\nat86rf230_xmit_tx_on(void *context)\n{\n\tstruct at86rf230_state_change *ctx = context;\n\tstruct at86rf230_local *lp = ctx->lp;\n\n\tat86rf230_async_state_change(lp, ctx, STATE_TX_ARET_ON,\n\t\t\t\t     at86rf230_write_frame);\n}\n\nstatic void\nat86rf230_xmit_start(void *context)\n{\n\tstruct at86rf230_state_change *ctx = context;\n\tstruct at86rf230_local *lp = ctx->lp;\n\n\t \n\tif (lp->is_tx_from_off)\n\t\tat86rf230_async_state_change(lp, ctx, STATE_TX_ARET_ON,\n\t\t\t\t\t     at86rf230_write_frame);\n\telse\n\t\tat86rf230_async_state_change(lp, ctx, STATE_TX_ON,\n\t\t\t\t\t     at86rf230_xmit_tx_on);\n}\n\nstatic int\nat86rf230_xmit(struct ieee802154_hw *hw, struct sk_buff *skb)\n{\n\tstruct at86rf230_local *lp = hw->priv;\n\tstruct at86rf230_state_change *ctx = &lp->tx;\n\n\tlp->tx_skb = skb;\n\tlp->tx_retry = 0;\n\n\t \n\tif (time_is_before_jiffies(lp->cal_timeout)) {\n\t\tlp->is_tx_from_off = true;\n\t\tat86rf230_async_state_change(lp, ctx, STATE_TRX_OFF,\n\t\t\t\t\t     at86rf230_xmit_start);\n\t} else {\n\t\tlp->is_tx_from_off = false;\n\t\tat86rf230_xmit_start(ctx);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nat86rf230_ed(struct ieee802154_hw *hw, u8 *level)\n{\n\tWARN_ON(!level);\n\t*level = 0xbe;\n\treturn 0;\n}\n\nstatic int\nat86rf230_start(struct ieee802154_hw *hw)\n{\n\tstruct at86rf230_local *lp = hw->priv;\n\n\tat86rf230_awake(lp);\n\tenable_irq(lp->spi->irq);\n\n\treturn at86rf230_sync_state_change(lp, STATE_RX_AACK_ON);\n}\n\nstatic void\nat86rf230_stop(struct ieee802154_hw *hw)\n{\n\tstruct at86rf230_local *lp = hw->priv;\n\tu8 csma_seed[2];\n\n\tat86rf230_sync_state_change(lp, STATE_FORCE_TRX_OFF);\n\n\tdisable_irq(lp->spi->irq);\n\n\t \n\tget_random_bytes(csma_seed, ARRAY_SIZE(csma_seed));\n\tat86rf230_write_subreg(lp, SR_CSMA_SEED_0, csma_seed[0]);\n\tat86rf230_write_subreg(lp, SR_CSMA_SEED_1, csma_seed[1]);\n\n\tat86rf230_sleep(lp);\n}\n\nstatic int\nat86rf23x_set_channel(struct at86rf230_local *lp, u8 page, u8 channel)\n{\n\treturn at86rf230_write_subreg(lp, SR_CHANNEL, channel);\n}\n\n#define AT86RF2XX_MAX_ED_LEVELS 0xF\nstatic const s32 at86rf233_ed_levels[AT86RF2XX_MAX_ED_LEVELS + 1] = {\n\t-9400, -9200, -9000, -8800, -8600, -8400, -8200, -8000, -7800, -7600,\n\t-7400, -7200, -7000, -6800, -6600, -6400,\n};\n\nstatic const s32 at86rf231_ed_levels[AT86RF2XX_MAX_ED_LEVELS + 1] = {\n\t-9100, -8900, -8700, -8500, -8300, -8100, -7900, -7700, -7500, -7300,\n\t-7100, -6900, -6700, -6500, -6300, -6100,\n};\n\nstatic const s32 at86rf212_ed_levels_100[AT86RF2XX_MAX_ED_LEVELS + 1] = {\n\t-10000, -9800, -9600, -9400, -9200, -9000, -8800, -8600, -8400, -8200,\n\t-8000, -7800, -7600, -7400, -7200, -7000,\n};\n\nstatic const s32 at86rf212_ed_levels_98[AT86RF2XX_MAX_ED_LEVELS + 1] = {\n\t-9800, -9600, -9400, -9200, -9000, -8800, -8600, -8400, -8200, -8000,\n\t-7800, -7600, -7400, -7200, -7000, -6800,\n};\n\nstatic inline int\nat86rf212_update_cca_ed_level(struct at86rf230_local *lp, int rssi_base_val)\n{\n\tunsigned int cca_ed_thres;\n\tint rc;\n\n\trc = at86rf230_read_subreg(lp, SR_CCA_ED_THRES, &cca_ed_thres);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tswitch (rssi_base_val) {\n\tcase -98:\n\t\tlp->hw->phy->supported.cca_ed_levels = at86rf212_ed_levels_98;\n\t\tlp->hw->phy->supported.cca_ed_levels_size = ARRAY_SIZE(at86rf212_ed_levels_98);\n\t\tlp->hw->phy->cca_ed_level = at86rf212_ed_levels_98[cca_ed_thres];\n\t\tbreak;\n\tcase -100:\n\t\tlp->hw->phy->supported.cca_ed_levels = at86rf212_ed_levels_100;\n\t\tlp->hw->phy->supported.cca_ed_levels_size = ARRAY_SIZE(at86rf212_ed_levels_100);\n\t\tlp->hw->phy->cca_ed_level = at86rf212_ed_levels_100[cca_ed_thres];\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nat86rf212_set_channel(struct at86rf230_local *lp, u8 page, u8 channel)\n{\n\tint rc;\n\n\tif (channel == 0)\n\t\trc = at86rf230_write_subreg(lp, SR_SUB_MODE, 0);\n\telse\n\t\trc = at86rf230_write_subreg(lp, SR_SUB_MODE, 1);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (page == 0) {\n\t\trc = at86rf230_write_subreg(lp, SR_BPSK_QPSK, 0);\n\t\tlp->data->rssi_base_val = -100;\n\t} else {\n\t\trc = at86rf230_write_subreg(lp, SR_BPSK_QPSK, 1);\n\t\tlp->data->rssi_base_val = -98;\n\t}\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = at86rf212_update_cca_ed_level(lp, lp->data->rssi_base_val);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn at86rf230_write_subreg(lp, SR_CHANNEL, channel);\n}\n\nstatic int\nat86rf230_channel(struct ieee802154_hw *hw, u8 page, u8 channel)\n{\n\tstruct at86rf230_local *lp = hw->priv;\n\tint rc;\n\n\trc = lp->data->set_channel(lp, page, channel);\n\t \n\tusleep_range(lp->data->t_channel_switch,\n\t\t     lp->data->t_channel_switch + 10);\n\n\tlp->cal_timeout = jiffies + AT86RF2XX_CAL_LOOP_TIMEOUT;\n\treturn rc;\n}\n\nstatic int\nat86rf230_set_hw_addr_filt(struct ieee802154_hw *hw,\n\t\t\t   struct ieee802154_hw_addr_filt *filt,\n\t\t\t   unsigned long changed)\n{\n\tstruct at86rf230_local *lp = hw->priv;\n\n\tif (changed & IEEE802154_AFILT_SADDR_CHANGED) {\n\t\tu16 addr = le16_to_cpu(filt->short_addr);\n\n\t\tdev_vdbg(&lp->spi->dev, \"%s called for saddr\\n\", __func__);\n\t\t__at86rf230_write(lp, RG_SHORT_ADDR_0, addr);\n\t\t__at86rf230_write(lp, RG_SHORT_ADDR_1, addr >> 8);\n\t}\n\n\tif (changed & IEEE802154_AFILT_PANID_CHANGED) {\n\t\tu16 pan = le16_to_cpu(filt->pan_id);\n\n\t\tdev_vdbg(&lp->spi->dev, \"%s called for pan id\\n\", __func__);\n\t\t__at86rf230_write(lp, RG_PAN_ID_0, pan);\n\t\t__at86rf230_write(lp, RG_PAN_ID_1, pan >> 8);\n\t}\n\n\tif (changed & IEEE802154_AFILT_IEEEADDR_CHANGED) {\n\t\tu8 i, addr[8];\n\n\t\tmemcpy(addr, &filt->ieee_addr, 8);\n\t\tdev_vdbg(&lp->spi->dev, \"%s called for IEEE addr\\n\", __func__);\n\t\tfor (i = 0; i < 8; i++)\n\t\t\t__at86rf230_write(lp, RG_IEEE_ADDR_0 + i, addr[i]);\n\t}\n\n\tif (changed & IEEE802154_AFILT_PANC_CHANGED) {\n\t\tdev_vdbg(&lp->spi->dev, \"%s called for panc change\\n\", __func__);\n\t\tif (filt->pan_coord)\n\t\t\tat86rf230_write_subreg(lp, SR_AACK_I_AM_COORD, 1);\n\t\telse\n\t\t\tat86rf230_write_subreg(lp, SR_AACK_I_AM_COORD, 0);\n\t}\n\n\treturn 0;\n}\n\n#define AT86RF23X_MAX_TX_POWERS 0xF\nstatic const s32 at86rf233_powers[AT86RF23X_MAX_TX_POWERS + 1] = {\n\t400, 370, 340, 300, 250, 200, 100, 0, -100, -200, -300, -400, -600,\n\t-800, -1200, -1700,\n};\n\nstatic const s32 at86rf231_powers[AT86RF23X_MAX_TX_POWERS + 1] = {\n\t300, 280, 230, 180, 130, 70, 0, -100, -200, -300, -400, -500, -700,\n\t-900, -1200, -1700,\n};\n\n#define AT86RF212_MAX_TX_POWERS 0x1F\nstatic const s32 at86rf212_powers[AT86RF212_MAX_TX_POWERS + 1] = {\n\t500, 400, 300, 200, 100, 0, -100, -200, -300, -400, -500, -600, -700,\n\t-800, -900, -1000, -1100, -1200, -1300, -1400, -1500, -1600, -1700,\n\t-1800, -1900, -2000, -2100, -2200, -2300, -2400, -2500, -2600,\n};\n\nstatic int\nat86rf23x_set_txpower(struct at86rf230_local *lp, s32 mbm)\n{\n\tu32 i;\n\n\tfor (i = 0; i < lp->hw->phy->supported.tx_powers_size; i++) {\n\t\tif (lp->hw->phy->supported.tx_powers[i] == mbm)\n\t\t\treturn at86rf230_write_subreg(lp, SR_TX_PWR_23X, i);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\nat86rf212_set_txpower(struct at86rf230_local *lp, s32 mbm)\n{\n\tu32 i;\n\n\tfor (i = 0; i < lp->hw->phy->supported.tx_powers_size; i++) {\n\t\tif (lp->hw->phy->supported.tx_powers[i] == mbm)\n\t\t\treturn at86rf230_write_subreg(lp, SR_TX_PWR_212, i);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\nat86rf230_set_txpower(struct ieee802154_hw *hw, s32 mbm)\n{\n\tstruct at86rf230_local *lp = hw->priv;\n\n\treturn lp->data->set_txpower(lp, mbm);\n}\n\nstatic int\nat86rf230_set_lbt(struct ieee802154_hw *hw, bool on)\n{\n\tstruct at86rf230_local *lp = hw->priv;\n\n\treturn at86rf230_write_subreg(lp, SR_CSMA_LBT_MODE, on);\n}\n\nstatic int\nat86rf230_set_cca_mode(struct ieee802154_hw *hw,\n\t\t       const struct wpan_phy_cca *cca)\n{\n\tstruct at86rf230_local *lp = hw->priv;\n\tu8 val;\n\n\t \n\tswitch (cca->mode) {\n\tcase NL802154_CCA_ENERGY:\n\t\tval = 1;\n\t\tbreak;\n\tcase NL802154_CCA_CARRIER:\n\t\tval = 2;\n\t\tbreak;\n\tcase NL802154_CCA_ENERGY_CARRIER:\n\t\tswitch (cca->opt) {\n\t\tcase NL802154_CCA_OPT_ENERGY_CARRIER_AND:\n\t\t\tval = 3;\n\t\t\tbreak;\n\t\tcase NL802154_CCA_OPT_ENERGY_CARRIER_OR:\n\t\t\tval = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn at86rf230_write_subreg(lp, SR_CCA_MODE, val);\n}\n\nstatic int\nat86rf230_set_cca_ed_level(struct ieee802154_hw *hw, s32 mbm)\n{\n\tstruct at86rf230_local *lp = hw->priv;\n\tu32 i;\n\n\tfor (i = 0; i < hw->phy->supported.cca_ed_levels_size; i++) {\n\t\tif (hw->phy->supported.cca_ed_levels[i] == mbm)\n\t\t\treturn at86rf230_write_subreg(lp, SR_CCA_ED_THRES, i);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\nat86rf230_set_csma_params(struct ieee802154_hw *hw, u8 min_be, u8 max_be,\n\t\t\t  u8 retries)\n{\n\tstruct at86rf230_local *lp = hw->priv;\n\tint rc;\n\n\trc = at86rf230_write_subreg(lp, SR_MIN_BE, min_be);\n\tif (rc)\n\t\treturn rc;\n\n\trc = at86rf230_write_subreg(lp, SR_MAX_BE, max_be);\n\tif (rc)\n\t\treturn rc;\n\n\treturn at86rf230_write_subreg(lp, SR_MAX_CSMA_RETRIES, retries);\n}\n\nstatic int\nat86rf230_set_frame_retries(struct ieee802154_hw *hw, s8 retries)\n{\n\tstruct at86rf230_local *lp = hw->priv;\n\n\treturn at86rf230_write_subreg(lp, SR_MAX_FRAME_RETRIES, retries);\n}\n\nstatic int\nat86rf230_set_promiscuous_mode(struct ieee802154_hw *hw, const bool on)\n{\n\tstruct at86rf230_local *lp = hw->priv;\n\tint rc;\n\n\tif (on) {\n\t\trc = at86rf230_write_subreg(lp, SR_AACK_DIS_ACK, 1);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\trc = at86rf230_write_subreg(lp, SR_AACK_PROM_MODE, 1);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t} else {\n\t\trc = at86rf230_write_subreg(lp, SR_AACK_PROM_MODE, 0);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\trc = at86rf230_write_subreg(lp, SR_AACK_DIS_ACK, 0);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct ieee802154_ops at86rf230_ops = {\n\t.owner = THIS_MODULE,\n\t.xmit_async = at86rf230_xmit,\n\t.ed = at86rf230_ed,\n\t.set_channel = at86rf230_channel,\n\t.start = at86rf230_start,\n\t.stop = at86rf230_stop,\n\t.set_hw_addr_filt = at86rf230_set_hw_addr_filt,\n\t.set_txpower = at86rf230_set_txpower,\n\t.set_lbt = at86rf230_set_lbt,\n\t.set_cca_mode = at86rf230_set_cca_mode,\n\t.set_cca_ed_level = at86rf230_set_cca_ed_level,\n\t.set_csma_params = at86rf230_set_csma_params,\n\t.set_frame_retries = at86rf230_set_frame_retries,\n\t.set_promiscuous_mode = at86rf230_set_promiscuous_mode,\n};\n\nstatic struct at86rf2xx_chip_data at86rf233_data = {\n\t.t_sleep_cycle = 330,\n\t.t_channel_switch = 11,\n\t.t_reset_to_off = 26,\n\t.t_off_to_aack = 80,\n\t.t_off_to_tx_on = 80,\n\t.t_off_to_sleep = 35,\n\t.t_sleep_to_off = 1000,\n\t.t_frame = 4096,\n\t.t_p_ack = 545,\n\t.rssi_base_val = -94,\n\t.set_channel = at86rf23x_set_channel,\n\t.set_txpower = at86rf23x_set_txpower,\n};\n\nstatic struct at86rf2xx_chip_data at86rf231_data = {\n\t.t_sleep_cycle = 330,\n\t.t_channel_switch = 24,\n\t.t_reset_to_off = 37,\n\t.t_off_to_aack = 110,\n\t.t_off_to_tx_on = 110,\n\t.t_off_to_sleep = 35,\n\t.t_sleep_to_off = 1000,\n\t.t_frame = 4096,\n\t.t_p_ack = 545,\n\t.rssi_base_val = -91,\n\t.set_channel = at86rf23x_set_channel,\n\t.set_txpower = at86rf23x_set_txpower,\n};\n\nstatic struct at86rf2xx_chip_data at86rf212_data = {\n\t.t_sleep_cycle = 330,\n\t.t_channel_switch = 11,\n\t.t_reset_to_off = 26,\n\t.t_off_to_aack = 200,\n\t.t_off_to_tx_on = 200,\n\t.t_off_to_sleep = 35,\n\t.t_sleep_to_off = 1000,\n\t.t_frame = 4096,\n\t.t_p_ack = 545,\n\t.rssi_base_val = -100,\n\t.set_channel = at86rf212_set_channel,\n\t.set_txpower = at86rf212_set_txpower,\n};\n\nstatic int at86rf230_hw_init(struct at86rf230_local *lp, u8 xtal_trim)\n{\n\tint rc, irq_type, irq_pol = IRQ_ACTIVE_HIGH;\n\tunsigned int dvdd;\n\tu8 csma_seed[2];\n\n\trc = at86rf230_sync_state_change(lp, STATE_FORCE_TRX_OFF);\n\tif (rc)\n\t\treturn rc;\n\n\tirq_type = irq_get_trigger_type(lp->spi->irq);\n\tif (irq_type == IRQ_TYPE_EDGE_FALLING ||\n\t    irq_type == IRQ_TYPE_LEVEL_LOW)\n\t\tirq_pol = IRQ_ACTIVE_LOW;\n\n\trc = at86rf230_write_subreg(lp, SR_IRQ_POLARITY, irq_pol);\n\tif (rc)\n\t\treturn rc;\n\n\trc = at86rf230_write_subreg(lp, SR_RX_SAFE_MODE, 1);\n\tif (rc)\n\t\treturn rc;\n\n\trc = at86rf230_write_subreg(lp, SR_IRQ_MASK, IRQ_TRX_END);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = at86rf230_write_subreg(lp, SR_IRQ_MASK_MODE, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tget_random_bytes(csma_seed, ARRAY_SIZE(csma_seed));\n\trc = at86rf230_write_subreg(lp, SR_CSMA_SEED_0, csma_seed[0]);\n\tif (rc)\n\t\treturn rc;\n\trc = at86rf230_write_subreg(lp, SR_CSMA_SEED_1, csma_seed[1]);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = at86rf230_write_subreg(lp, SR_CLKM_SHA_SEL, 0x00);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\trc = at86rf230_write_subreg(lp, SR_CLKM_CTRL, 0x00);\n\tif (rc)\n\t\treturn rc;\n\t \n\tusleep_range(lp->data->t_sleep_cycle,\n\t\t     lp->data->t_sleep_cycle + 100);\n\n\t \n\trc = at86rf230_write_subreg(lp, SR_XTAL_TRIM, xtal_trim);\n\tif (rc)\n\t\treturn rc;\n\n\trc = at86rf230_read_subreg(lp, SR_DVDD_OK, &dvdd);\n\tif (rc)\n\t\treturn rc;\n\tif (!dvdd) {\n\t\tdev_err(&lp->spi->dev, \"DVDD error\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treturn at86rf230_write_subreg(lp, SR_SLOTTED_OPERATION, 0);\n}\n\nstatic int\nat86rf230_detect_device(struct at86rf230_local *lp)\n{\n\tunsigned int part, version, val;\n\tu16 man_id = 0;\n\tconst char *chip;\n\tint rc;\n\n\trc = __at86rf230_read(lp, RG_MAN_ID_0, &val);\n\tif (rc)\n\t\treturn rc;\n\tman_id |= val;\n\n\trc = __at86rf230_read(lp, RG_MAN_ID_1, &val);\n\tif (rc)\n\t\treturn rc;\n\tman_id |= (val << 8);\n\n\trc = __at86rf230_read(lp, RG_PART_NUM, &part);\n\tif (rc)\n\t\treturn rc;\n\n\trc = __at86rf230_read(lp, RG_VERSION_NUM, &version);\n\tif (rc)\n\t\treturn rc;\n\n\tif (man_id != 0x001f) {\n\t\tdev_err(&lp->spi->dev, \"Non-Atmel dev found (MAN_ID %02x %02x)\\n\",\n\t\t\tman_id >> 8, man_id & 0xFF);\n\t\treturn -EINVAL;\n\t}\n\n\tlp->hw->flags = IEEE802154_HW_TX_OMIT_CKSUM |\n\t\t\tIEEE802154_HW_CSMA_PARAMS |\n\t\t\tIEEE802154_HW_FRAME_RETRIES | IEEE802154_HW_AFILT |\n\t\t\tIEEE802154_HW_PROMISCUOUS;\n\n\tlp->hw->phy->flags = WPAN_PHY_FLAG_TXPOWER |\n\t\t\t     WPAN_PHY_FLAG_CCA_ED_LEVEL |\n\t\t\t     WPAN_PHY_FLAG_CCA_MODE;\n\n\tlp->hw->phy->supported.cca_modes = BIT(NL802154_CCA_ENERGY) |\n\t\tBIT(NL802154_CCA_CARRIER) | BIT(NL802154_CCA_ENERGY_CARRIER);\n\tlp->hw->phy->supported.cca_opts = BIT(NL802154_CCA_OPT_ENERGY_CARRIER_AND) |\n\t\tBIT(NL802154_CCA_OPT_ENERGY_CARRIER_OR);\n\n\tlp->hw->phy->cca.mode = NL802154_CCA_ENERGY;\n\n\tswitch (part) {\n\tcase 2:\n\t\tchip = \"at86rf230\";\n\t\trc = -ENOTSUPP;\n\t\tgoto not_supp;\n\tcase 3:\n\t\tchip = \"at86rf231\";\n\t\tlp->data = &at86rf231_data;\n\t\tlp->hw->phy->supported.channels[0] = 0x7FFF800;\n\t\tlp->hw->phy->current_channel = 11;\n\t\tlp->hw->phy->supported.tx_powers = at86rf231_powers;\n\t\tlp->hw->phy->supported.tx_powers_size = ARRAY_SIZE(at86rf231_powers);\n\t\tlp->hw->phy->supported.cca_ed_levels = at86rf231_ed_levels;\n\t\tlp->hw->phy->supported.cca_ed_levels_size = ARRAY_SIZE(at86rf231_ed_levels);\n\t\tbreak;\n\tcase 7:\n\t\tchip = \"at86rf212\";\n\t\tlp->data = &at86rf212_data;\n\t\tlp->hw->flags |= IEEE802154_HW_LBT;\n\t\tlp->hw->phy->supported.channels[0] = 0x00007FF;\n\t\tlp->hw->phy->supported.channels[2] = 0x00007FF;\n\t\tlp->hw->phy->current_channel = 5;\n\t\tlp->hw->phy->supported.lbt = NL802154_SUPPORTED_BOOL_BOTH;\n\t\tlp->hw->phy->supported.tx_powers = at86rf212_powers;\n\t\tlp->hw->phy->supported.tx_powers_size = ARRAY_SIZE(at86rf212_powers);\n\t\tlp->hw->phy->supported.cca_ed_levels = at86rf212_ed_levels_100;\n\t\tlp->hw->phy->supported.cca_ed_levels_size = ARRAY_SIZE(at86rf212_ed_levels_100);\n\t\tbreak;\n\tcase 11:\n\t\tchip = \"at86rf233\";\n\t\tlp->data = &at86rf233_data;\n\t\tlp->hw->phy->supported.channels[0] = 0x7FFF800;\n\t\tlp->hw->phy->current_channel = 13;\n\t\tlp->hw->phy->supported.tx_powers = at86rf233_powers;\n\t\tlp->hw->phy->supported.tx_powers_size = ARRAY_SIZE(at86rf233_powers);\n\t\tlp->hw->phy->supported.cca_ed_levels = at86rf233_ed_levels;\n\t\tlp->hw->phy->supported.cca_ed_levels_size = ARRAY_SIZE(at86rf233_ed_levels);\n\t\tbreak;\n\tdefault:\n\t\tchip = \"unknown\";\n\t\trc = -ENOTSUPP;\n\t\tgoto not_supp;\n\t}\n\n\tlp->hw->phy->cca_ed_level = lp->hw->phy->supported.cca_ed_levels[7];\n\tlp->hw->phy->transmit_power = lp->hw->phy->supported.tx_powers[0];\n\nnot_supp:\n\tdev_info(&lp->spi->dev, \"Detected %s chip version %d\\n\", chip, version);\n\n\treturn rc;\n}\n\nstatic int at86rf230_probe(struct spi_device *spi)\n{\n\tstruct ieee802154_hw *hw;\n\tstruct at86rf230_local *lp;\n\tstruct gpio_desc *slp_tr;\n\tstruct gpio_desc *rstn;\n\tunsigned int status;\n\tint rc, irq_type;\n\tu8 xtal_trim;\n\n\tif (!spi->irq) {\n\t\tdev_err(&spi->dev, \"no IRQ specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = device_property_read_u8(&spi->dev, \"xtal-trim\", &xtal_trim);\n\tif (rc < 0) {\n\t\tif (rc != -EINVAL) {\n\t\t\tdev_err(&spi->dev,\n\t\t\t\t\"failed to parse xtal-trim: %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t\txtal_trim = 0;\n\t}\n\n\trstn = devm_gpiod_get_optional(&spi->dev, \"reset\", GPIOD_OUT_LOW);\n\trc = PTR_ERR_OR_ZERO(rstn);\n\tif (rc)\n\t\treturn rc;\n\n\tgpiod_set_consumer_name(rstn, \"rstn\");\n\n\tslp_tr = devm_gpiod_get_optional(&spi->dev, \"sleep\", GPIOD_OUT_LOW);\n\trc = PTR_ERR_OR_ZERO(slp_tr);\n\tif (rc)\n\t\treturn rc;\n\n\tgpiod_set_consumer_name(slp_tr, \"slp_tr\");\n\n\t \n\tif (rstn) {\n\t\tudelay(1);\n\t\tgpiod_set_value_cansleep(rstn, 1);\n\t\tudelay(1);\n\t\tgpiod_set_value_cansleep(rstn, 0);\n\t\tusleep_range(120, 240);\n\t}\n\n\thw = ieee802154_alloc_hw(sizeof(*lp), &at86rf230_ops);\n\tif (!hw)\n\t\treturn -ENOMEM;\n\n\tlp = hw->priv;\n\tlp->hw = hw;\n\tlp->spi = spi;\n\tlp->slp_tr = slp_tr;\n\thw->parent = &spi->dev;\n\tieee802154_random_extended_addr(&hw->phy->perm_extended_addr);\n\n\tlp->regmap = devm_regmap_init_spi(spi, &at86rf230_regmap_spi_config);\n\tif (IS_ERR(lp->regmap)) {\n\t\trc = PTR_ERR(lp->regmap);\n\t\tdev_err(&spi->dev, \"Failed to allocate register map: %d\\n\",\n\t\t\trc);\n\t\tgoto free_dev;\n\t}\n\n\tat86rf230_setup_spi_messages(lp, &lp->state);\n\tat86rf230_setup_spi_messages(lp, &lp->tx);\n\n\trc = at86rf230_detect_device(lp);\n\tif (rc < 0)\n\t\tgoto free_dev;\n\n\tinit_completion(&lp->state_complete);\n\n\tspi_set_drvdata(spi, lp);\n\n\trc = at86rf230_hw_init(lp, xtal_trim);\n\tif (rc)\n\t\tgoto free_dev;\n\n\t \n\trc = at86rf230_read_subreg(lp, RG_IRQ_STATUS, 0xff, 0, &status);\n\tif (rc)\n\t\tgoto free_dev;\n\n\tirq_type = irq_get_trigger_type(spi->irq);\n\tif (!irq_type)\n\t\tirq_type = IRQF_TRIGGER_HIGH;\n\n\trc = devm_request_irq(&spi->dev, spi->irq, at86rf230_isr,\n\t\t\t      IRQF_SHARED | irq_type, dev_name(&spi->dev), lp);\n\tif (rc)\n\t\tgoto free_dev;\n\n\t \n\tdisable_irq(spi->irq);\n\n\t \n\tat86rf230_sleep(lp);\n\n\trc = ieee802154_register_hw(lp->hw);\n\tif (rc)\n\t\tgoto free_dev;\n\n\treturn rc;\n\nfree_dev:\n\tieee802154_free_hw(lp->hw);\n\n\treturn rc;\n}\n\nstatic void at86rf230_remove(struct spi_device *spi)\n{\n\tstruct at86rf230_local *lp = spi_get_drvdata(spi);\n\n\t \n\tat86rf230_write_subreg(lp, SR_IRQ_MASK, 0);\n\tieee802154_unregister_hw(lp->hw);\n\tieee802154_free_hw(lp->hw);\n\tdev_dbg(&spi->dev, \"unregistered at86rf230\\n\");\n}\n\nstatic const struct of_device_id at86rf230_of_match[] = {\n\t{ .compatible = \"atmel,at86rf230\", },\n\t{ .compatible = \"atmel,at86rf231\", },\n\t{ .compatible = \"atmel,at86rf233\", },\n\t{ .compatible = \"atmel,at86rf212\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, at86rf230_of_match);\n\nstatic const struct spi_device_id at86rf230_device_id[] = {\n\t{ .name = \"at86rf230\", },\n\t{ .name = \"at86rf231\", },\n\t{ .name = \"at86rf233\", },\n\t{ .name = \"at86rf212\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(spi, at86rf230_device_id);\n\nstatic struct spi_driver at86rf230_driver = {\n\t.id_table = at86rf230_device_id,\n\t.driver = {\n\t\t.of_match_table = at86rf230_of_match,\n\t\t.name\t= \"at86rf230\",\n\t},\n\t.probe      = at86rf230_probe,\n\t.remove     = at86rf230_remove,\n};\n\nmodule_spi_driver(at86rf230_driver);\n\nMODULE_DESCRIPTION(\"AT86RF230 Transceiver Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}