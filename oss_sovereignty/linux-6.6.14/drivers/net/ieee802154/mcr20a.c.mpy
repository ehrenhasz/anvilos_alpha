{
  "module_name": "mcr20a.c",
  "hash_id": "d2bc44d263388aff025e7e6563828c42a2ea24f3b8c53913310b940a6e1e42ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ieee802154/mcr20a.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/gpio/consumer.h>\n#include <linux/spi/spi.h>\n#include <linux/workqueue.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/skbuff.h>\n#include <linux/of_gpio.h>\n#include <linux/regmap.h>\n#include <linux/ieee802154.h>\n#include <linux/debugfs.h>\n\n#include <net/mac802154.h>\n#include <net/cfg802154.h>\n\n#include <linux/device.h>\n\n#include \"mcr20a.h\"\n\n#define\tSPI_COMMAND_BUFFER\t\t3\n\n#define REGISTER_READ\t\t\tBIT(7)\n#define REGISTER_WRITE\t\t\t(0 << 7)\n#define REGISTER_ACCESS\t\t\t(0 << 6)\n#define PACKET_BUFF_BURST_ACCESS\tBIT(6)\n#define PACKET_BUFF_BYTE_ACCESS\t\tBIT(5)\n\n#define MCR20A_WRITE_REG(x)\t\t(x)\n#define MCR20A_READ_REG(x)\t\t(REGISTER_READ | (x))\n#define MCR20A_BURST_READ_PACKET_BUF\t(0xC0)\n#define MCR20A_BURST_WRITE_PACKET_BUF\t(0x40)\n\n#define MCR20A_CMD_REG\t\t0x80\n#define MCR20A_CMD_REG_MASK\t0x3f\n#define MCR20A_CMD_WRITE\t0x40\n#define MCR20A_CMD_FB\t\t0x20\n\n \n#define MCR20A_IRQSTS_NUM 2  \n\n \nenum {\n\tMCR20A_CCA_ED,\t  \n\t\t\t  \n\tMCR20A_CCA_MODE1, \n\tMCR20A_CCA_MODE2, \n\tMCR20A_CCA_MODE3\n};\n\nenum {\n\tMCR20A_XCVSEQ_IDLE\t= 0x00,\n\tMCR20A_XCVSEQ_RX\t= 0x01,\n\tMCR20A_XCVSEQ_TX\t= 0x02,\n\tMCR20A_XCVSEQ_CCA\t= 0x03,\n\tMCR20A_XCVSEQ_TR\t= 0x04,\n\tMCR20A_XCVSEQ_CCCA\t= 0x05,\n};\n\n \n#define\tMCR20A_MIN_CHANNEL\t(11)\n#define\tMCR20A_MAX_CHANNEL\t(26)\n#define\tMCR20A_CHANNEL_SPACING\t(5)\n\n \n#define MCR20A_MIN_CCA_THRESHOLD (0x6EU)\n#define MCR20A_MAX_CCA_THRESHOLD (0x00U)\n\n \n#define MCR20A_OVERWRITE_VERSION (0x0C)\n\n \nstatic const u8  PLL_INT[16] = {\n\t  0x0B,\t  0x0B,\t  0x0B,\n\t  0x0B,\t  0x0B,\t  0x0B,\n\t  0x0C,\t  0x0C,\t  0x0C,\n\t  0x0C,\t  0x0C,\t  0x0C,\n\t  0x0D,\t  0x0D,\t  0x0D,\n\t  0x0D\n};\n\nstatic const u8 PLL_FRAC[16] = {\n\t  0x28,\t  0x50,\t  0x78,\n\t  0xA0,\t  0xC8,\t  0xF0,\n\t  0x18,\t  0x40,\t  0x68,\n\t  0x90,\t  0xB8,\t  0xE0,\n\t  0x08,\t  0x30,\t  0x58,\n\t  0x80\n};\n\nstatic const struct reg_sequence mar20a_iar_overwrites[] = {\n\t{ IAR_MISC_PAD_CTRL,\t0x02 },\n\t{ IAR_VCO_CTRL1,\t0xB3 },\n\t{ IAR_VCO_CTRL2,\t0x07 },\n\t{ IAR_PA_TUNING,\t0x71 },\n\t{ IAR_CHF_IBUF,\t\t0x2F },\n\t{ IAR_CHF_QBUF,\t\t0x2F },\n\t{ IAR_CHF_IRIN,\t\t0x24 },\n\t{ IAR_CHF_QRIN,\t\t0x24 },\n\t{ IAR_CHF_IL,\t\t0x24 },\n\t{ IAR_CHF_QL,\t\t0x24 },\n\t{ IAR_CHF_CC1,\t\t0x32 },\n\t{ IAR_CHF_CCL,\t\t0x1D },\n\t{ IAR_CHF_CC2,\t\t0x2D },\n\t{ IAR_CHF_IROUT,\t0x24 },\n\t{ IAR_CHF_QROUT,\t0x24 },\n\t{ IAR_PA_CAL,\t\t0x28 },\n\t{ IAR_AGC_THR1,\t\t0x55 },\n\t{ IAR_AGC_THR2,\t\t0x2D },\n\t{ IAR_ATT_RSSI1,\t0x5F },\n\t{ IAR_ATT_RSSI2,\t0x8F },\n\t{ IAR_RSSI_OFFSET,\t0x61 },\n\t{ IAR_CHF_PMA_GAIN,\t0x03 },\n\t{ IAR_CCA1_THRESH,\t0x50 },\n\t{ IAR_CORR_NVAL,\t0x13 },\n\t{ IAR_ACKDELAY,\t\t0x3D },\n};\n\n#define MCR20A_VALID_CHANNELS (0x07FFF800)\n#define MCR20A_MAX_BUF\t\t(127)\n\n#define printdev(X) (&X->spi->dev)\n\n \n#define MCR20A_DAR_WRITE\t0x01\n#define MCR20A_DAR_READ\t\t0x00\n#define MCR20A_DAR_NUMREGS\t0x3F\n\n \n#define MCR20A_IAR_ACCESS\t0x80\n#define MCR20A_IAR_NUMREGS\t0xBEFF\n\n \n#define MCR20A_READSHORT(reg)\t((reg) << 1)\n#define MCR20A_WRITESHORT(reg)\t((reg) << 1 | 1)\n#define MCR20A_READLONG(reg)\t(1 << 15 | (reg) << 5)\n#define MCR20A_WRITELONG(reg)\t(1 << 15 | (reg) << 5 | 1 << 4)\n\n \n#define MCR20A_PHY_INDIRECT_QUEUE_SIZE (12)\n\nstatic bool\nmcr20a_dar_writeable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase DAR_IRQ_STS1:\n\tcase DAR_IRQ_STS2:\n\tcase DAR_IRQ_STS3:\n\tcase DAR_PHY_CTRL1:\n\tcase DAR_PHY_CTRL2:\n\tcase DAR_PHY_CTRL3:\n\tcase DAR_PHY_CTRL4:\n\tcase DAR_SRC_CTRL:\n\tcase DAR_SRC_ADDRS_SUM_LSB:\n\tcase DAR_SRC_ADDRS_SUM_MSB:\n\tcase DAR_T3CMP_LSB:\n\tcase DAR_T3CMP_MSB:\n\tcase DAR_T3CMP_USB:\n\tcase DAR_T2PRIMECMP_LSB:\n\tcase DAR_T2PRIMECMP_MSB:\n\tcase DAR_T1CMP_LSB:\n\tcase DAR_T1CMP_MSB:\n\tcase DAR_T1CMP_USB:\n\tcase DAR_T2CMP_LSB:\n\tcase DAR_T2CMP_MSB:\n\tcase DAR_T2CMP_USB:\n\tcase DAR_T4CMP_LSB:\n\tcase DAR_T4CMP_MSB:\n\tcase DAR_T4CMP_USB:\n\tcase DAR_PLL_INT0:\n\tcase DAR_PLL_FRAC0_LSB:\n\tcase DAR_PLL_FRAC0_MSB:\n\tcase DAR_PA_PWR:\n\t \n\tcase DAR_OVERWRITE_VER:\n\tcase DAR_CLK_OUT_CTRL:\n\tcase DAR_PWR_MODES:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool\nmcr20a_dar_readable(struct device *dev, unsigned int reg)\n{\n\tbool rc;\n\n\t \n\trc = mcr20a_dar_writeable(dev, reg);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tswitch (reg) {\n\tcase DAR_RX_FRM_LEN:\n\tcase DAR_CCA1_ED_FNL:\n\tcase DAR_EVENT_TMR_LSB:\n\tcase DAR_EVENT_TMR_MSB:\n\tcase DAR_EVENT_TMR_USB:\n\tcase DAR_TIMESTAMP_LSB:\n\tcase DAR_TIMESTAMP_MSB:\n\tcase DAR_TIMESTAMP_USB:\n\tcase DAR_SEQ_STATE:\n\tcase DAR_LQI_VALUE:\n\tcase DAR_RSSI_CCA_CONT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool\nmcr20a_dar_volatile(struct device *dev, unsigned int reg)\n{\n\t \n\tswitch (reg) {\n\tcase DAR_IRQ_STS1:\n\tcase DAR_IRQ_STS2:\n\tcase DAR_IRQ_STS3:\n\t \n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool\nmcr20a_dar_precious(struct device *dev, unsigned int reg)\n{\n\t \n\tswitch (reg) {\n\tcase DAR_IRQ_STS1:\n\tcase DAR_IRQ_STS2:\n\tcase DAR_IRQ_STS3:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config mcr20a_dar_regmap = {\n\t.name\t\t\t= \"mcr20a_dar\",\n\t.reg_bits\t\t= 8,\n\t.val_bits\t\t= 8,\n\t.write_flag_mask\t= REGISTER_ACCESS | REGISTER_WRITE,\n\t.read_flag_mask\t\t= REGISTER_ACCESS | REGISTER_READ,\n\t.cache_type\t\t= REGCACHE_RBTREE,\n\t.writeable_reg\t\t= mcr20a_dar_writeable,\n\t.readable_reg\t\t= mcr20a_dar_readable,\n\t.volatile_reg\t\t= mcr20a_dar_volatile,\n\t.precious_reg\t\t= mcr20a_dar_precious,\n\t.fast_io\t\t= true,\n\t.can_multi_write\t= true,\n};\n\nstatic bool\nmcr20a_iar_writeable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase IAR_XTAL_TRIM:\n\tcase IAR_PMC_LP_TRIM:\n\tcase IAR_MACPANID0_LSB:\n\tcase IAR_MACPANID0_MSB:\n\tcase IAR_MACSHORTADDRS0_LSB:\n\tcase IAR_MACSHORTADDRS0_MSB:\n\tcase IAR_MACLONGADDRS0_0:\n\tcase IAR_MACLONGADDRS0_8:\n\tcase IAR_MACLONGADDRS0_16:\n\tcase IAR_MACLONGADDRS0_24:\n\tcase IAR_MACLONGADDRS0_32:\n\tcase IAR_MACLONGADDRS0_40:\n\tcase IAR_MACLONGADDRS0_48:\n\tcase IAR_MACLONGADDRS0_56:\n\tcase IAR_RX_FRAME_FILTER:\n\tcase IAR_PLL_INT1:\n\tcase IAR_PLL_FRAC1_LSB:\n\tcase IAR_PLL_FRAC1_MSB:\n\tcase IAR_MACPANID1_LSB:\n\tcase IAR_MACPANID1_MSB:\n\tcase IAR_MACSHORTADDRS1_LSB:\n\tcase IAR_MACSHORTADDRS1_MSB:\n\tcase IAR_MACLONGADDRS1_0:\n\tcase IAR_MACLONGADDRS1_8:\n\tcase IAR_MACLONGADDRS1_16:\n\tcase IAR_MACLONGADDRS1_24:\n\tcase IAR_MACLONGADDRS1_32:\n\tcase IAR_MACLONGADDRS1_40:\n\tcase IAR_MACLONGADDRS1_48:\n\tcase IAR_MACLONGADDRS1_56:\n\tcase IAR_DUAL_PAN_CTRL:\n\tcase IAR_DUAL_PAN_DWELL:\n\tcase IAR_CCA1_THRESH:\n\tcase IAR_CCA1_ED_OFFSET_COMP:\n\tcase IAR_LQI_OFFSET_COMP:\n\tcase IAR_CCA_CTRL:\n\tcase IAR_CCA2_CORR_PEAKS:\n\tcase IAR_CCA2_CORR_THRESH:\n\tcase IAR_TMR_PRESCALE:\n\tcase IAR_ANT_PAD_CTRL:\n\tcase IAR_MISC_PAD_CTRL:\n\tcase IAR_BSM_CTRL:\n\tcase IAR_RNG:\n\tcase IAR_RX_WTR_MARK:\n\tcase IAR_SOFT_RESET:\n\tcase IAR_TXDELAY:\n\tcase IAR_ACKDELAY:\n\tcase IAR_CORR_NVAL:\n\tcase IAR_ANT_AGC_CTRL:\n\tcase IAR_AGC_THR1:\n\tcase IAR_AGC_THR2:\n\tcase IAR_PA_CAL:\n\tcase IAR_ATT_RSSI1:\n\tcase IAR_ATT_RSSI2:\n\tcase IAR_RSSI_OFFSET:\n\tcase IAR_XTAL_CTRL:\n\tcase IAR_CHF_PMA_GAIN:\n\tcase IAR_CHF_IBUF:\n\tcase IAR_CHF_QBUF:\n\tcase IAR_CHF_IRIN:\n\tcase IAR_CHF_QRIN:\n\tcase IAR_CHF_IL:\n\tcase IAR_CHF_QL:\n\tcase IAR_CHF_CC1:\n\tcase IAR_CHF_CCL:\n\tcase IAR_CHF_CC2:\n\tcase IAR_CHF_IROUT:\n\tcase IAR_CHF_QROUT:\n\tcase IAR_PA_TUNING:\n\tcase IAR_VCO_CTRL1:\n\tcase IAR_VCO_CTRL2:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool\nmcr20a_iar_readable(struct device *dev, unsigned int reg)\n{\n\tbool rc;\n\n\t \n\trc = mcr20a_iar_writeable(dev, reg);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tswitch (reg) {\n\tcase IAR_PART_ID:\n\tcase IAR_DUAL_PAN_STS:\n\tcase IAR_RX_BYTE_COUNT:\n\tcase IAR_FILTERFAIL_CODE1:\n\tcase IAR_FILTERFAIL_CODE2:\n\tcase IAR_RSSI:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool\nmcr20a_iar_volatile(struct device *dev, unsigned int reg)\n{\n \n\tswitch (reg) {\n\tcase IAR_DUAL_PAN_STS:\n\tcase IAR_RX_BYTE_COUNT:\n\tcase IAR_FILTERFAIL_CODE1:\n\tcase IAR_FILTERFAIL_CODE2:\n\tcase IAR_RSSI:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config mcr20a_iar_regmap = {\n\t.name\t\t\t= \"mcr20a_iar\",\n\t.reg_bits\t\t= 16,\n\t.val_bits\t\t= 8,\n\t.write_flag_mask\t= REGISTER_ACCESS | REGISTER_WRITE | IAR_INDEX,\n\t.read_flag_mask\t\t= REGISTER_ACCESS | REGISTER_READ  | IAR_INDEX,\n\t.cache_type\t\t= REGCACHE_RBTREE,\n\t.writeable_reg\t\t= mcr20a_iar_writeable,\n\t.readable_reg\t\t= mcr20a_iar_readable,\n\t.volatile_reg\t\t= mcr20a_iar_volatile,\n\t.fast_io\t\t= true,\n};\n\nstruct mcr20a_local {\n\tstruct spi_device *spi;\n\n\tstruct ieee802154_hw *hw;\n\tstruct regmap *regmap_dar;\n\tstruct regmap *regmap_iar;\n\n\tu8 *buf;\n\n\tbool is_tx;\n\n\t \n\tstruct spi_message tx_buf_msg;\n\tu8 tx_header[1];\n\t \n\tstruct spi_transfer tx_xfer_header;\n\tu8 tx_len[1];\n\t \n\tstruct spi_transfer tx_xfer_len;\n\t \n\tstruct spi_transfer tx_xfer_buf;\n\tstruct sk_buff *tx_skb;\n\n\t \n\tstruct spi_message reg_msg;\n\tu8 reg_cmd[1];\n\tu8 reg_data[MCR20A_IRQSTS_NUM];\n\tstruct spi_transfer reg_xfer_cmd;\n\tstruct spi_transfer reg_xfer_data;\n\n\t \n\tstruct spi_message rx_buf_msg;\n\tu8 rx_header[1];\n\tstruct spi_transfer rx_xfer_header;\n\tu8 rx_lqi[1];\n\tstruct spi_transfer rx_xfer_lqi;\n\tu8 rx_buf[MCR20A_MAX_BUF];\n\tstruct spi_transfer rx_xfer_buf;\n\n\t \n\tstruct spi_message irq_msg;\n\tu8 irq_header[1];\n\tu8 irq_data[MCR20A_IRQSTS_NUM];\n\tstruct spi_transfer irq_xfer_data;\n\tstruct spi_transfer irq_xfer_header;\n};\n\nstatic void\nmcr20a_write_tx_buf_complete(void *context)\n{\n\tstruct mcr20a_local *lp = context;\n\tint ret;\n\n\tdev_dbg(printdev(lp), \"%s\\n\", __func__);\n\n\tlp->reg_msg.complete = NULL;\n\tlp->reg_cmd[0]\t= MCR20A_WRITE_REG(DAR_PHY_CTRL1);\n\tlp->reg_data[0] = MCR20A_XCVSEQ_TX;\n\tlp->reg_xfer_data.len = 1;\n\n\tret = spi_async(lp->spi, &lp->reg_msg);\n\tif (ret)\n\t\tdev_err(printdev(lp), \"failed to set SEQ TX\\n\");\n}\n\nstatic int\nmcr20a_xmit(struct ieee802154_hw *hw, struct sk_buff *skb)\n{\n\tstruct mcr20a_local *lp = hw->priv;\n\n\tdev_dbg(printdev(lp), \"%s\\n\", __func__);\n\n\tlp->tx_skb = skb;\n\n\tprint_hex_dump_debug(\"mcr20a tx: \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t     skb->data, skb->len, 0);\n\n\tlp->is_tx = 1;\n\n\tlp->reg_msg.complete\t= NULL;\n\tlp->reg_cmd[0]\t\t= MCR20A_WRITE_REG(DAR_PHY_CTRL1);\n\tlp->reg_data[0]\t\t= MCR20A_XCVSEQ_IDLE;\n\tlp->reg_xfer_data.len\t= 1;\n\n\treturn spi_async(lp->spi, &lp->reg_msg);\n}\n\nstatic int\nmcr20a_ed(struct ieee802154_hw *hw, u8 *level)\n{\n\tWARN_ON(!level);\n\t*level = 0xbe;\n\treturn 0;\n}\n\nstatic int\nmcr20a_set_channel(struct ieee802154_hw *hw, u8 page, u8 channel)\n{\n\tstruct mcr20a_local *lp = hw->priv;\n\tint ret;\n\n\tdev_dbg(printdev(lp), \"%s\\n\", __func__);\n\n\t \n\tret = regmap_write(lp->regmap_dar, DAR_PLL_INT0, PLL_INT[channel - 11]);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_write(lp->regmap_dar, DAR_PLL_FRAC0_LSB, 0x00);\n\tif (ret)\n\t\treturn ret;\n\tret = regmap_write(lp->regmap_dar, DAR_PLL_FRAC0_MSB,\n\t\t\t   PLL_FRAC[channel - 11]);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int\nmcr20a_start(struct ieee802154_hw *hw)\n{\n\tstruct mcr20a_local *lp = hw->priv;\n\tint ret;\n\n\tdev_dbg(printdev(lp), \"%s\\n\", __func__);\n\n\t \n\tdev_dbg(printdev(lp), \"no slotted operation\\n\");\n\tret = regmap_update_bits(lp->regmap_dar, DAR_PHY_CTRL1,\n\t\t\t\t DAR_PHY_CTRL1_SLOTTED, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tenable_irq(lp->spi->irq);\n\n\t \n\tret = regmap_update_bits(lp->regmap_dar, DAR_PHY_CTRL2,\n\t\t\t\t DAR_PHY_CTRL2_SEQMSK, 0x0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tdev_dbg(printdev(lp), \"start the RX sequence\\n\");\n\tret = regmap_update_bits(lp->regmap_dar, DAR_PHY_CTRL1,\n\t\t\t\t DAR_PHY_CTRL1_XCVSEQ_MASK, MCR20A_XCVSEQ_RX);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void\nmcr20a_stop(struct ieee802154_hw *hw)\n{\n\tstruct mcr20a_local *lp = hw->priv;\n\n\tdev_dbg(printdev(lp), \"%s\\n\", __func__);\n\n\t \n\tregmap_update_bits(lp->regmap_dar, DAR_PHY_CTRL1,\n\t\t\t   DAR_PHY_CTRL1_XCVSEQ_MASK, MCR20A_XCVSEQ_IDLE);\n\n\t \n\tdisable_irq(lp->spi->irq);\n}\n\nstatic int\nmcr20a_set_hw_addr_filt(struct ieee802154_hw *hw,\n\t\t\tstruct ieee802154_hw_addr_filt *filt,\n\t\t\tunsigned long changed)\n{\n\tstruct mcr20a_local *lp = hw->priv;\n\n\tdev_dbg(printdev(lp), \"%s\\n\", __func__);\n\n\tif (changed & IEEE802154_AFILT_SADDR_CHANGED) {\n\t\tu16 addr = le16_to_cpu(filt->short_addr);\n\n\t\tregmap_write(lp->regmap_iar, IAR_MACSHORTADDRS0_LSB, addr);\n\t\tregmap_write(lp->regmap_iar, IAR_MACSHORTADDRS0_MSB, addr >> 8);\n\t}\n\n\tif (changed & IEEE802154_AFILT_PANID_CHANGED) {\n\t\tu16 pan = le16_to_cpu(filt->pan_id);\n\n\t\tregmap_write(lp->regmap_iar, IAR_MACPANID0_LSB, pan);\n\t\tregmap_write(lp->regmap_iar, IAR_MACPANID0_MSB, pan >> 8);\n\t}\n\n\tif (changed & IEEE802154_AFILT_IEEEADDR_CHANGED) {\n\t\tu8 addr[8], i;\n\n\t\tmemcpy(addr, &filt->ieee_addr, 8);\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tregmap_write(lp->regmap_iar,\n\t\t\t\t     IAR_MACLONGADDRS0_0 + i, addr[i]);\n\t}\n\n\tif (changed & IEEE802154_AFILT_PANC_CHANGED) {\n\t\tif (filt->pan_coord) {\n\t\t\tregmap_update_bits(lp->regmap_dar, DAR_PHY_CTRL4,\n\t\t\t\t\t   DAR_PHY_CTRL4_PANCORDNTR0, 0x10);\n\t\t} else {\n\t\t\tregmap_update_bits(lp->regmap_dar, DAR_PHY_CTRL4,\n\t\t\t\t\t   DAR_PHY_CTRL4_PANCORDNTR0, 0x00);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n#define MCR20A_MAX_TX_POWERS 0x14\nstatic const s32 mcr20a_powers[MCR20A_MAX_TX_POWERS + 1] = {\n\t-3000, -2800, -2600, -2400, -2200, -2000, -1800, -1600, -1400,\n\t-1200, -1000, -800, -600, -400, -200, 0, 200, 400, 600, 800, 1000\n};\n\nstatic int\nmcr20a_set_txpower(struct ieee802154_hw *hw, s32 mbm)\n{\n\tstruct mcr20a_local *lp = hw->priv;\n\tu32 i;\n\n\tdev_dbg(printdev(lp), \"%s(%d)\\n\", __func__, mbm);\n\n\tfor (i = 0; i < lp->hw->phy->supported.tx_powers_size; i++) {\n\t\tif (lp->hw->phy->supported.tx_powers[i] == mbm)\n\t\t\treturn regmap_write(lp->regmap_dar, DAR_PA_PWR,\n\t\t\t\t\t    ((i + 8) & 0x1F));\n\t}\n\n\treturn -EINVAL;\n}\n\n#define MCR20A_MAX_ED_LEVELS MCR20A_MIN_CCA_THRESHOLD\nstatic s32 mcr20a_ed_levels[MCR20A_MAX_ED_LEVELS + 1];\n\nstatic int\nmcr20a_set_cca_mode(struct ieee802154_hw *hw,\n\t\t    const struct wpan_phy_cca *cca)\n{\n\tstruct mcr20a_local *lp = hw->priv;\n\tunsigned int cca_mode = 0xff;\n\tbool cca_mode_and = false;\n\tint ret;\n\n\tdev_dbg(printdev(lp), \"%s\\n\", __func__);\n\n\t \n\tswitch (cca->mode) {\n\tcase NL802154_CCA_ENERGY:\n\t\tcca_mode = MCR20A_CCA_MODE1;\n\t\tbreak;\n\tcase NL802154_CCA_CARRIER:\n\t\tcca_mode = MCR20A_CCA_MODE2;\n\t\tbreak;\n\tcase NL802154_CCA_ENERGY_CARRIER:\n\t\tswitch (cca->opt) {\n\t\tcase NL802154_CCA_OPT_ENERGY_CARRIER_AND:\n\t\t\tcca_mode = MCR20A_CCA_MODE3;\n\t\t\tcca_mode_and = true;\n\t\t\tbreak;\n\t\tcase NL802154_CCA_OPT_ENERGY_CARRIER_OR:\n\t\t\tcca_mode = MCR20A_CCA_MODE3;\n\t\t\tcca_mode_and = false;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tret = regmap_update_bits(lp->regmap_dar, DAR_PHY_CTRL4,\n\t\t\t\t DAR_PHY_CTRL4_CCATYPE_MASK,\n\t\t\t\t cca_mode << DAR_PHY_CTRL4_CCATYPE_SHIFT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (cca_mode == MCR20A_CCA_MODE3) {\n\t\tif (cca_mode_and) {\n\t\t\tret = regmap_update_bits(lp->regmap_iar, IAR_CCA_CTRL,\n\t\t\t\t\t\t IAR_CCA_CTRL_CCA3_AND_NOT_OR,\n\t\t\t\t\t\t 0x08);\n\t\t} else {\n\t\t\tret = regmap_update_bits(lp->regmap_iar,\n\t\t\t\t\t\t IAR_CCA_CTRL,\n\t\t\t\t\t\t IAR_CCA_CTRL_CCA3_AND_NOT_OR,\n\t\t\t\t\t\t 0x00);\n\t\t}\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int\nmcr20a_set_cca_ed_level(struct ieee802154_hw *hw, s32 mbm)\n{\n\tstruct mcr20a_local *lp = hw->priv;\n\tu32 i;\n\n\tdev_dbg(printdev(lp), \"%s\\n\", __func__);\n\n\tfor (i = 0; i < hw->phy->supported.cca_ed_levels_size; i++) {\n\t\tif (hw->phy->supported.cca_ed_levels[i] == mbm)\n\t\t\treturn regmap_write(lp->regmap_iar, IAR_CCA1_THRESH, i);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmcr20a_set_promiscuous_mode(struct ieee802154_hw *hw, const bool on)\n{\n\tstruct mcr20a_local *lp = hw->priv;\n\tint ret;\n\tu8 rx_frame_filter_reg = 0x0;\n\n\tdev_dbg(printdev(lp), \"%s(%d)\\n\", __func__, on);\n\n\tif (on) {\n\t\t \n\t\trx_frame_filter_reg &= ~(IAR_RX_FRAME_FLT_FRM_VER);\n\t\trx_frame_filter_reg |= (IAR_RX_FRAME_FLT_ACK_FT |\n\t\t\t\t  IAR_RX_FRAME_FLT_NS_FT);\n\n\t\tret = regmap_update_bits(lp->regmap_dar, DAR_PHY_CTRL4,\n\t\t\t\t\t DAR_PHY_CTRL4_PROMISCUOUS,\n\t\t\t\t\t DAR_PHY_CTRL4_PROMISCUOUS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_write(lp->regmap_iar, IAR_RX_FRAME_FILTER,\n\t\t\t\t   rx_frame_filter_reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tret = regmap_update_bits(lp->regmap_dar, DAR_PHY_CTRL4,\n\t\t\t\t\t DAR_PHY_CTRL4_PROMISCUOUS, 0x0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = regmap_write(lp->regmap_iar, IAR_RX_FRAME_FILTER,\n\t\t\t\t   IAR_RX_FRAME_FLT_FRM_VER |\n\t\t\t\t   IAR_RX_FRAME_FLT_BEACON_FT |\n\t\t\t\t   IAR_RX_FRAME_FLT_DATA_FT |\n\t\t\t\t   IAR_RX_FRAME_FLT_CMD_FT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct ieee802154_ops mcr20a_hw_ops = {\n\t.owner\t\t\t= THIS_MODULE,\n\t.xmit_async\t\t= mcr20a_xmit,\n\t.ed\t\t\t= mcr20a_ed,\n\t.set_channel\t\t= mcr20a_set_channel,\n\t.start\t\t\t= mcr20a_start,\n\t.stop\t\t\t= mcr20a_stop,\n\t.set_hw_addr_filt\t= mcr20a_set_hw_addr_filt,\n\t.set_txpower\t\t= mcr20a_set_txpower,\n\t.set_cca_mode\t\t= mcr20a_set_cca_mode,\n\t.set_cca_ed_level\t= mcr20a_set_cca_ed_level,\n\t.set_promiscuous_mode\t= mcr20a_set_promiscuous_mode,\n};\n\nstatic int\nmcr20a_request_rx(struct mcr20a_local *lp)\n{\n\tdev_dbg(printdev(lp), \"%s\\n\", __func__);\n\n\t \n\tregmap_update_bits_async(lp->regmap_dar, DAR_PHY_CTRL1,\n\t\t\t\t DAR_PHY_CTRL1_XCVSEQ_MASK, MCR20A_XCVSEQ_RX);\n\n\treturn 0;\n}\n\nstatic void\nmcr20a_handle_rx_read_buf_complete(void *context)\n{\n\tstruct mcr20a_local *lp = context;\n\tu8 len = lp->reg_data[0] & DAR_RX_FRAME_LENGTH_MASK;\n\tstruct sk_buff *skb;\n\n\tdev_dbg(printdev(lp), \"%s\\n\", __func__);\n\n\tdev_dbg(printdev(lp), \"RX is done\\n\");\n\n\tif (!ieee802154_is_valid_psdu_len(len)) {\n\t\tdev_vdbg(&lp->spi->dev, \"corrupted frame received\\n\");\n\t\tlen = IEEE802154_MTU;\n\t}\n\n\tlen = len - 2;   \n\n\tskb = dev_alloc_skb(len);\n\tif (!skb)\n\t\treturn;\n\n\t__skb_put_data(skb, lp->rx_buf, len);\n\tieee802154_rx_irqsafe(lp->hw, skb, lp->rx_lqi[0]);\n\n\tprint_hex_dump_debug(\"mcr20a rx: \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t     lp->rx_buf, len, 0);\n\tpr_debug(\"mcr20a rx: lqi: %02hhx\\n\", lp->rx_lqi[0]);\n\n\t \n\tmcr20a_request_rx(lp);\n}\n\nstatic void\nmcr20a_handle_rx_read_len_complete(void *context)\n{\n\tstruct mcr20a_local *lp = context;\n\tu8 len;\n\tint ret;\n\n\tdev_dbg(printdev(lp), \"%s\\n\", __func__);\n\n\t \n\tlen = lp->reg_data[0] & DAR_RX_FRAME_LENGTH_MASK;\n\tdev_dbg(printdev(lp), \"frame len : %d\\n\", len);\n\n\t \n\tlp->rx_buf_msg.complete = mcr20a_handle_rx_read_buf_complete;\n\tlp->rx_header[0] = MCR20A_BURST_READ_PACKET_BUF;\n\tlp->rx_xfer_buf.len = len;\n\n\tret = spi_async(lp->spi, &lp->rx_buf_msg);\n\tif (ret)\n\t\tdev_err(printdev(lp), \"failed to read rx buffer length\\n\");\n}\n\nstatic int\nmcr20a_handle_rx(struct mcr20a_local *lp)\n{\n\tdev_dbg(printdev(lp), \"%s\\n\", __func__);\n\tlp->reg_msg.complete = mcr20a_handle_rx_read_len_complete;\n\tlp->reg_cmd[0] = MCR20A_READ_REG(DAR_RX_FRM_LEN);\n\tlp->reg_xfer_data.len\t= 1;\n\n\treturn spi_async(lp->spi, &lp->reg_msg);\n}\n\nstatic int\nmcr20a_handle_tx_complete(struct mcr20a_local *lp)\n{\n\tdev_dbg(printdev(lp), \"%s\\n\", __func__);\n\n\tieee802154_xmit_complete(lp->hw, lp->tx_skb, false);\n\n\treturn mcr20a_request_rx(lp);\n}\n\nstatic int\nmcr20a_handle_tx(struct mcr20a_local *lp)\n{\n\tint ret;\n\n\tdev_dbg(printdev(lp), \"%s\\n\", __func__);\n\n\t \n\tlp->tx_header[0]\t= MCR20A_BURST_WRITE_PACKET_BUF;\n\t \n\tlp->tx_len[0]\t\t= lp->tx_skb->len + 2;\n\tlp->tx_xfer_buf.tx_buf\t= lp->tx_skb->data;\n\t \n\tlp->tx_xfer_buf.len\t= lp->tx_skb->len + 1;\n\n\tret = spi_async(lp->spi, &lp->tx_buf_msg);\n\tif (ret) {\n\t\tdev_err(printdev(lp), \"SPI write Failed for TX buf\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nmcr20a_irq_clean_complete(void *context)\n{\n\tstruct mcr20a_local *lp = context;\n\tu8 seq_state = lp->irq_data[DAR_IRQ_STS1] & DAR_PHY_CTRL1_XCVSEQ_MASK;\n\n\tdev_dbg(printdev(lp), \"%s\\n\", __func__);\n\n\tenable_irq(lp->spi->irq);\n\n\tdev_dbg(printdev(lp), \"IRQ STA1 (%02x) STA2 (%02x)\\n\",\n\t\tlp->irq_data[DAR_IRQ_STS1], lp->irq_data[DAR_IRQ_STS2]);\n\n\tswitch (seq_state) {\n\t \n\tcase (DAR_IRQSTS1_TXIRQ | DAR_IRQSTS1_SEQIRQ):\n\t\tif (lp->is_tx) {\n\t\t\tlp->is_tx = 0;\n\t\t\tdev_dbg(printdev(lp), \"TX is done. No ACK\\n\");\n\t\t\tmcr20a_handle_tx_complete(lp);\n\t\t}\n\t\tbreak;\n\tcase (DAR_IRQSTS1_RXIRQ | DAR_IRQSTS1_SEQIRQ):\n\t\t \n\t\tdev_dbg(printdev(lp), \"RX is starting\\n\");\n\t\tmcr20a_handle_rx(lp);\n\t\tbreak;\n\tcase (DAR_IRQSTS1_RXIRQ | DAR_IRQSTS1_TXIRQ | DAR_IRQSTS1_SEQIRQ):\n\t\tif (lp->is_tx) {\n\t\t\t \n\t\t\tlp->is_tx = 0;\n\t\t\tdev_dbg(printdev(lp), \"TX is done. Get ACK\\n\");\n\t\t\tmcr20a_handle_tx_complete(lp);\n\t\t} else {\n\t\t\t \n\t\t\tdev_dbg(printdev(lp), \"RX is starting\\n\");\n\t\t\tmcr20a_handle_rx(lp);\n\t\t}\n\t\tbreak;\n\tcase (DAR_IRQSTS1_SEQIRQ):\n\t\tif (lp->is_tx) {\n\t\t\tdev_dbg(printdev(lp), \"TX is starting\\n\");\n\t\t\tmcr20a_handle_tx(lp);\n\t\t} else {\n\t\t\tdev_dbg(printdev(lp), \"MCR20A is stop\\n\");\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void mcr20a_irq_status_complete(void *context)\n{\n\tint ret;\n\tstruct mcr20a_local *lp = context;\n\n\tdev_dbg(printdev(lp), \"%s\\n\", __func__);\n\tregmap_update_bits_async(lp->regmap_dar, DAR_PHY_CTRL1,\n\t\t\t\t DAR_PHY_CTRL1_XCVSEQ_MASK, MCR20A_XCVSEQ_IDLE);\n\n\tlp->reg_msg.complete = mcr20a_irq_clean_complete;\n\tlp->reg_cmd[0] = MCR20A_WRITE_REG(DAR_IRQ_STS1);\n\tmemcpy(lp->reg_data, lp->irq_data, MCR20A_IRQSTS_NUM);\n\tlp->reg_xfer_data.len = MCR20A_IRQSTS_NUM;\n\n\tret = spi_async(lp->spi, &lp->reg_msg);\n\n\tif (ret)\n\t\tdev_err(printdev(lp), \"failed to clean irq status\\n\");\n}\n\nstatic irqreturn_t mcr20a_irq_isr(int irq, void *data)\n{\n\tstruct mcr20a_local *lp = data;\n\tint ret;\n\n\tdisable_irq_nosync(irq);\n\n\tlp->irq_header[0] = MCR20A_READ_REG(DAR_IRQ_STS1);\n\t \n\tret = spi_async(lp->spi, &lp->irq_msg);\n\tif (ret) {\n\t\tenable_irq(irq);\n\t\treturn IRQ_NONE;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void mcr20a_hw_setup(struct mcr20a_local *lp)\n{\n\tu8 i;\n\tstruct ieee802154_hw *hw = lp->hw;\n\tstruct wpan_phy *phy = lp->hw->phy;\n\n\tdev_dbg(printdev(lp), \"%s\\n\", __func__);\n\n\thw->flags = IEEE802154_HW_TX_OMIT_CKSUM |\n\t\t\tIEEE802154_HW_AFILT |\n\t\t\tIEEE802154_HW_PROMISCUOUS;\n\n\tphy->flags = WPAN_PHY_FLAG_TXPOWER | WPAN_PHY_FLAG_CCA_ED_LEVEL |\n\t\t\tWPAN_PHY_FLAG_CCA_MODE;\n\n\tphy->supported.cca_modes = BIT(NL802154_CCA_ENERGY) |\n\t\tBIT(NL802154_CCA_CARRIER) | BIT(NL802154_CCA_ENERGY_CARRIER);\n\tphy->supported.cca_opts = BIT(NL802154_CCA_OPT_ENERGY_CARRIER_AND) |\n\t\tBIT(NL802154_CCA_OPT_ENERGY_CARRIER_OR);\n\n\t \n\tfor (i = MCR20A_MAX_CCA_THRESHOLD; i < MCR20A_MIN_CCA_THRESHOLD + 1;\n\t      ++i) {\n\t\tmcr20a_ed_levels[i] =  -i * 100;\n\t}\n\n\tphy->supported.cca_ed_levels = mcr20a_ed_levels;\n\tphy->supported.cca_ed_levels_size = ARRAY_SIZE(mcr20a_ed_levels);\n\n\tphy->cca.mode = NL802154_CCA_ENERGY;\n\n\tphy->supported.channels[0] = MCR20A_VALID_CHANNELS;\n\tphy->current_page = 0;\n\t \n\tphy->current_channel = 20;\n\tphy->supported.tx_powers = mcr20a_powers;\n\tphy->supported.tx_powers_size = ARRAY_SIZE(mcr20a_powers);\n\tphy->cca_ed_level = phy->supported.cca_ed_levels[75];\n\tphy->transmit_power = phy->supported.tx_powers[0x0F];\n}\n\nstatic void\nmcr20a_setup_tx_spi_messages(struct mcr20a_local *lp)\n{\n\tspi_message_init(&lp->tx_buf_msg);\n\tlp->tx_buf_msg.context = lp;\n\tlp->tx_buf_msg.complete = mcr20a_write_tx_buf_complete;\n\n\tlp->tx_xfer_header.len = 1;\n\tlp->tx_xfer_header.tx_buf = lp->tx_header;\n\n\tlp->tx_xfer_len.len = 1;\n\tlp->tx_xfer_len.tx_buf = lp->tx_len;\n\n\tspi_message_add_tail(&lp->tx_xfer_header, &lp->tx_buf_msg);\n\tspi_message_add_tail(&lp->tx_xfer_len, &lp->tx_buf_msg);\n\tspi_message_add_tail(&lp->tx_xfer_buf, &lp->tx_buf_msg);\n}\n\nstatic void\nmcr20a_setup_rx_spi_messages(struct mcr20a_local *lp)\n{\n\tspi_message_init(&lp->reg_msg);\n\tlp->reg_msg.context = lp;\n\n\tlp->reg_xfer_cmd.len = 1;\n\tlp->reg_xfer_cmd.tx_buf = lp->reg_cmd;\n\tlp->reg_xfer_cmd.rx_buf = lp->reg_cmd;\n\n\tlp->reg_xfer_data.rx_buf = lp->reg_data;\n\tlp->reg_xfer_data.tx_buf = lp->reg_data;\n\n\tspi_message_add_tail(&lp->reg_xfer_cmd, &lp->reg_msg);\n\tspi_message_add_tail(&lp->reg_xfer_data, &lp->reg_msg);\n\n\tspi_message_init(&lp->rx_buf_msg);\n\tlp->rx_buf_msg.context = lp;\n\tlp->rx_buf_msg.complete = mcr20a_handle_rx_read_buf_complete;\n\tlp->rx_xfer_header.len = 1;\n\tlp->rx_xfer_header.tx_buf = lp->rx_header;\n\tlp->rx_xfer_header.rx_buf = lp->rx_header;\n\n\tlp->rx_xfer_buf.rx_buf = lp->rx_buf;\n\n\tlp->rx_xfer_lqi.len = 1;\n\tlp->rx_xfer_lqi.rx_buf = lp->rx_lqi;\n\n\tspi_message_add_tail(&lp->rx_xfer_header, &lp->rx_buf_msg);\n\tspi_message_add_tail(&lp->rx_xfer_buf, &lp->rx_buf_msg);\n\tspi_message_add_tail(&lp->rx_xfer_lqi, &lp->rx_buf_msg);\n}\n\nstatic void\nmcr20a_setup_irq_spi_messages(struct mcr20a_local *lp)\n{\n\tspi_message_init(&lp->irq_msg);\n\tlp->irq_msg.context\t\t= lp;\n\tlp->irq_msg.complete\t= mcr20a_irq_status_complete;\n\tlp->irq_xfer_header.len\t= 1;\n\tlp->irq_xfer_header.tx_buf = lp->irq_header;\n\tlp->irq_xfer_header.rx_buf = lp->irq_header;\n\n\tlp->irq_xfer_data.len\t= MCR20A_IRQSTS_NUM;\n\tlp->irq_xfer_data.rx_buf = lp->irq_data;\n\n\tspi_message_add_tail(&lp->irq_xfer_header, &lp->irq_msg);\n\tspi_message_add_tail(&lp->irq_xfer_data, &lp->irq_msg);\n}\n\nstatic int\nmcr20a_phy_init(struct mcr20a_local *lp)\n{\n\tu8 index;\n\tunsigned int phy_reg = 0;\n\tint ret;\n\n\tdev_dbg(printdev(lp), \"%s\\n\", __func__);\n\n\t \n\tret = regmap_write(lp->regmap_iar, IAR_MISC_PAD_CTRL, 0x02);\n\tif (ret)\n\t\tgoto err_ret;\n\n\t \n\tret = regmap_write(lp->regmap_dar, DAR_IRQ_STS1, 0xEF);\n\tif (ret)\n\t\tgoto err_ret;\n\n\t \n\tret = regmap_write(lp->regmap_dar, DAR_IRQ_STS2,\n\t\t\t   DAR_IRQSTS2_ASM_IRQ | DAR_IRQSTS2_PB_ERR_IRQ |\n\t\t\t   DAR_IRQSTS2_WAKE_IRQ);\n\tif (ret)\n\t\tgoto err_ret;\n\n\t \n\tret = regmap_write(lp->regmap_dar, DAR_IRQ_STS3, 0xFF);\n\tif (ret)\n\t\tgoto err_ret;\n\n\t \n\tret = regmap_update_bits(lp->regmap_dar, DAR_PHY_CTRL1,\n\t\t\t\t DAR_PHY_CTRL1_AUTOACK, DAR_PHY_CTRL1_AUTOACK);\n\n\t \n\tret = regmap_write(lp->regmap_dar, DAR_PHY_CTRL2, 0xFF);\n\tif (ret)\n\t\tgoto err_ret;\n\n\t \n\tret = regmap_write(lp->regmap_dar, DAR_PHY_CTRL3,\n\t\t\t   DAR_PHY_CTRL3_ASM_MSK | DAR_PHY_CTRL3_PB_ERR_MSK |\n\t\t\t   DAR_PHY_CTRL3_WAKE_MSK);\n\tif (ret)\n\t\tgoto err_ret;\n\n\t \n\tret = regmap_write(lp->regmap_dar, DAR_SRC_CTRL,\n\t\t\t   DAR_SRC_CTRL_ACK_FRM_PND |\n\t\t\t   (DAR_SRC_CTRL_INDEX << DAR_SRC_CTRL_INDEX_SHIFT));\n\tif (ret)\n\t\tgoto err_ret;\n\n\t \n\t \n\tret = regmap_write(lp->regmap_iar, IAR_RX_FRAME_FILTER,\n\t\t\t   IAR_RX_FRAME_FLT_FRM_VER |\n\t\t\t   IAR_RX_FRAME_FLT_BEACON_FT |\n\t\t\t   IAR_RX_FRAME_FLT_DATA_FT |\n\t\t\t   IAR_RX_FRAME_FLT_CMD_FT);\n\tif (ret)\n\t\tgoto err_ret;\n\n\tdev_info(printdev(lp), \"MCR20A DAR overwrites version: 0x%02x\\n\",\n\t\t MCR20A_OVERWRITE_VERSION);\n\n\t \n\tret = regmap_write(lp->regmap_dar, DAR_OVERWRITE_VER,\n\t\t\t   MCR20A_OVERWRITE_VERSION);\n\tif (ret)\n\t\tgoto err_ret;\n\n\t \n\tret = regmap_multi_reg_write(lp->regmap_iar, mar20a_iar_overwrites,\n\t\t\t\t     ARRAY_SIZE(mar20a_iar_overwrites));\n\tif (ret)\n\t\tgoto err_ret;\n\n\t \n\tdev_dbg(printdev(lp), \"clear HW indirect queue\\n\");\n\tfor (index = 0; index < MCR20A_PHY_INDIRECT_QUEUE_SIZE; index++) {\n\t\tphy_reg = (u8)(((index & DAR_SRC_CTRL_INDEX) <<\n\t\t\t       DAR_SRC_CTRL_INDEX_SHIFT)\n\t\t\t      | (DAR_SRC_CTRL_SRCADDR_EN)\n\t\t\t      | (DAR_SRC_CTRL_INDEX_DISABLE));\n\t\tret = regmap_write(lp->regmap_dar, DAR_SRC_CTRL, phy_reg);\n\t\tif (ret)\n\t\t\tgoto err_ret;\n\t\tphy_reg = 0;\n\t}\n\n\t \n\tret = regmap_read(lp->regmap_iar, IAR_DUAL_PAN_CTRL, &phy_reg);\n\tif (ret)\n\t\tgoto err_ret;\n\n\t \n\tphy_reg &= ~IAR_DUAL_PAN_CTRL_DUAL_PAN_SAM_LVL_MSK;\n\n\t \n\tphy_reg |= MCR20A_PHY_INDIRECT_QUEUE_SIZE <<\n\t\tIAR_DUAL_PAN_CTRL_DUAL_PAN_SAM_LVL_SHIFT;\n\tret = regmap_write(lp->regmap_iar, IAR_DUAL_PAN_CTRL, phy_reg);\n\tif (ret)\n\t\tgoto err_ret;\n\n\t \n\tret = regmap_write(lp->regmap_iar, IAR_CCA1_THRESH, 0x4B);\n\tif (ret)\n\t\tgoto err_ret;\n\n\t \n\tret = regmap_write(lp->regmap_iar, IAR_TMR_PRESCALE, 0x05);\n\tif (ret)\n\t\tgoto err_ret;\n\n\t \n\tret = regmap_update_bits(lp->regmap_dar, DAR_PWR_MODES,\n\t\t\t\t DAR_PWR_MODES_AUTODOZE,\n\t\t\t\t DAR_PWR_MODES_AUTODOZE);\n\tif (ret)\n\t\tgoto err_ret;\n\n\t \n\tret = regmap_update_bits(lp->regmap_dar, DAR_CLK_OUT_CTRL,\n\t\t\t\t DAR_CLK_OUT_CTRL_EN, 0x0);\n\tif (ret)\n\t\tgoto err_ret;\n\n\treturn 0;\n\nerr_ret:\n\treturn ret;\n}\n\nstatic int\nmcr20a_probe(struct spi_device *spi)\n{\n\tstruct ieee802154_hw *hw;\n\tstruct mcr20a_local *lp;\n\tstruct gpio_desc *rst_b;\n\tint irq_type;\n\tint ret = -ENOMEM;\n\n\tdev_dbg(&spi->dev, \"%s\\n\", __func__);\n\n\tif (!spi->irq) {\n\t\tdev_err(&spi->dev, \"no IRQ specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trst_b = devm_gpiod_get(&spi->dev, \"rst_b\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(rst_b))\n\t\treturn dev_err_probe(&spi->dev, PTR_ERR(rst_b),\n\t\t\t\t     \"Failed to get 'rst_b' gpio\");\n\n\t \n\tusleep_range(10, 20);\n\tgpiod_set_value_cansleep(rst_b, 1);\n\tusleep_range(10, 20);\n\tgpiod_set_value_cansleep(rst_b, 0);\n\tusleep_range(120, 240);\n\n\t \n\thw = ieee802154_alloc_hw(sizeof(*lp), &mcr20a_hw_ops);\n\tif (!hw) {\n\t\tdev_crit(&spi->dev, \"ieee802154_alloc_hw failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tlp = hw->priv;\n\tlp->hw = hw;\n\tlp->spi = spi;\n\n\t \n\thw->parent = &spi->dev;\n\tieee802154_random_extended_addr(&hw->phy->perm_extended_addr);\n\n\t \n\tlp->buf = devm_kzalloc(&spi->dev, SPI_COMMAND_BUFFER, GFP_KERNEL);\n\n\tif (!lp->buf) {\n\t\tret = -ENOMEM;\n\t\tgoto free_dev;\n\t}\n\n\tmcr20a_setup_tx_spi_messages(lp);\n\tmcr20a_setup_rx_spi_messages(lp);\n\tmcr20a_setup_irq_spi_messages(lp);\n\n\t \n\tlp->regmap_dar = devm_regmap_init_spi(spi, &mcr20a_dar_regmap);\n\tif (IS_ERR(lp->regmap_dar)) {\n\t\tret = PTR_ERR(lp->regmap_dar);\n\t\tdev_err(&spi->dev, \"Failed to allocate dar map: %d\\n\",\n\t\t\tret);\n\t\tgoto free_dev;\n\t}\n\n\tlp->regmap_iar = devm_regmap_init_spi(spi, &mcr20a_iar_regmap);\n\tif (IS_ERR(lp->regmap_iar)) {\n\t\tret = PTR_ERR(lp->regmap_iar);\n\t\tdev_err(&spi->dev, \"Failed to allocate iar map: %d\\n\", ret);\n\t\tgoto free_dev;\n\t}\n\n\tmcr20a_hw_setup(lp);\n\n\tspi_set_drvdata(spi, lp);\n\n\tret = mcr20a_phy_init(lp);\n\tif (ret < 0) {\n\t\tdev_crit(&spi->dev, \"mcr20a_phy_init failed\\n\");\n\t\tgoto free_dev;\n\t}\n\n\tirq_type = irq_get_trigger_type(spi->irq);\n\tif (!irq_type)\n\t\tirq_type = IRQF_TRIGGER_FALLING;\n\n\tret = devm_request_irq(&spi->dev, spi->irq, mcr20a_irq_isr,\n\t\t\t       irq_type, dev_name(&spi->dev), lp);\n\tif (ret) {\n\t\tdev_err(&spi->dev, \"could not request_irq for mcr20a\\n\");\n\t\tret = -ENODEV;\n\t\tgoto free_dev;\n\t}\n\n\t \n\tdisable_irq(spi->irq);\n\n\tret = ieee802154_register_hw(hw);\n\tif (ret) {\n\t\tdev_crit(&spi->dev, \"ieee802154_register_hw failed\\n\");\n\t\tgoto free_dev;\n\t}\n\n\treturn ret;\n\nfree_dev:\n\tieee802154_free_hw(lp->hw);\n\n\treturn ret;\n}\n\nstatic void mcr20a_remove(struct spi_device *spi)\n{\n\tstruct mcr20a_local *lp = spi_get_drvdata(spi);\n\n\tdev_dbg(&spi->dev, \"%s\\n\", __func__);\n\n\tieee802154_unregister_hw(lp->hw);\n\tieee802154_free_hw(lp->hw);\n}\n\nstatic const struct of_device_id mcr20a_of_match[] = {\n\t{ .compatible = \"nxp,mcr20a\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, mcr20a_of_match);\n\nstatic const struct spi_device_id mcr20a_device_id[] = {\n\t{ .name = \"mcr20a\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(spi, mcr20a_device_id);\n\nstatic struct spi_driver mcr20a_driver = {\n\t.id_table = mcr20a_device_id,\n\t.driver = {\n\t\t.of_match_table = mcr20a_of_match,\n\t\t.name\t= \"mcr20a\",\n\t},\n\t.probe      = mcr20a_probe,\n\t.remove     = mcr20a_remove,\n};\n\nmodule_spi_driver(mcr20a_driver);\n\nMODULE_DESCRIPTION(\"MCR20A Transceiver Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Xue Liu <liuxuenetmail@gmail>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}