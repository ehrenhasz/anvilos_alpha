{
  "module_name": "ntb_netdev.c",
  "hash_id": "862a4169cc02185dd3196d8d9578880db480a125358b15dab895aaccc0734e29",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/ntb_netdev.c",
  "human_readable_source": " \n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/ntb.h>\n#include <linux/ntb_transport.h>\n\n#define NTB_NETDEV_VER\t\"0.7\"\n\nMODULE_DESCRIPTION(KBUILD_MODNAME);\nMODULE_VERSION(NTB_NETDEV_VER);\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Intel Corporation\");\n\n \nstatic unsigned int tx_time = 1;\n\n \nstatic unsigned int tx_start = 10;\n\n \nstatic unsigned int tx_stop = 5;\n\nstruct ntb_netdev {\n\tstruct pci_dev *pdev;\n\tstruct net_device *ndev;\n\tstruct ntb_transport_qp *qp;\n\tstruct timer_list tx_timer;\n};\n\n#define\tNTB_TX_TIMEOUT_MS\t1000\n#define\tNTB_RXQ_SIZE\t\t100\n\nstatic void ntb_netdev_event_handler(void *data, int link_is_up)\n{\n\tstruct net_device *ndev = data;\n\tstruct ntb_netdev *dev = netdev_priv(ndev);\n\n\tnetdev_dbg(ndev, \"Event %x, Link %x\\n\", link_is_up,\n\t\t   ntb_transport_link_query(dev->qp));\n\n\tif (link_is_up) {\n\t\tif (ntb_transport_link_query(dev->qp))\n\t\t\tnetif_carrier_on(ndev);\n\t} else {\n\t\tnetif_carrier_off(ndev);\n\t}\n}\n\nstatic void ntb_netdev_rx_handler(struct ntb_transport_qp *qp, void *qp_data,\n\t\t\t\t  void *data, int len)\n{\n\tstruct net_device *ndev = qp_data;\n\tstruct sk_buff *skb;\n\tint rc;\n\n\tskb = data;\n\tif (!skb)\n\t\treturn;\n\n\tnetdev_dbg(ndev, \"%s: %d byte payload received\\n\", __func__, len);\n\n\tif (len < 0) {\n\t\tndev->stats.rx_errors++;\n\t\tndev->stats.rx_length_errors++;\n\t\tgoto enqueue_again;\n\t}\n\n\tskb_put(skb, len);\n\tskb->protocol = eth_type_trans(skb, ndev);\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\tif (__netif_rx(skb) == NET_RX_DROP) {\n\t\tndev->stats.rx_errors++;\n\t\tndev->stats.rx_dropped++;\n\t} else {\n\t\tndev->stats.rx_packets++;\n\t\tndev->stats.rx_bytes += len;\n\t}\n\n\tskb = netdev_alloc_skb(ndev, ndev->mtu + ETH_HLEN);\n\tif (!skb) {\n\t\tndev->stats.rx_errors++;\n\t\tndev->stats.rx_frame_errors++;\n\t\treturn;\n\t}\n\nenqueue_again:\n\trc = ntb_transport_rx_enqueue(qp, skb, skb->data, ndev->mtu + ETH_HLEN);\n\tif (rc) {\n\t\tdev_kfree_skb_any(skb);\n\t\tndev->stats.rx_errors++;\n\t\tndev->stats.rx_fifo_errors++;\n\t}\n}\n\nstatic int __ntb_netdev_maybe_stop_tx(struct net_device *netdev,\n\t\t\t\t      struct ntb_transport_qp *qp, int size)\n{\n\tstruct ntb_netdev *dev = netdev_priv(netdev);\n\n\tnetif_stop_queue(netdev);\n\t \n\tsmp_mb();\n\n\tif (likely(ntb_transport_tx_free_entry(qp) < size)) {\n\t\tmod_timer(&dev->tx_timer, jiffies + usecs_to_jiffies(tx_time));\n\t\treturn -EBUSY;\n\t}\n\n\tnetif_start_queue(netdev);\n\treturn 0;\n}\n\nstatic int ntb_netdev_maybe_stop_tx(struct net_device *ndev,\n\t\t\t\t    struct ntb_transport_qp *qp, int size)\n{\n\tif (netif_queue_stopped(ndev) ||\n\t    (ntb_transport_tx_free_entry(qp) >= size))\n\t\treturn 0;\n\n\treturn __ntb_netdev_maybe_stop_tx(ndev, qp, size);\n}\n\nstatic void ntb_netdev_tx_handler(struct ntb_transport_qp *qp, void *qp_data,\n\t\t\t\t  void *data, int len)\n{\n\tstruct net_device *ndev = qp_data;\n\tstruct sk_buff *skb;\n\tstruct ntb_netdev *dev = netdev_priv(ndev);\n\n\tskb = data;\n\tif (!skb || !ndev)\n\t\treturn;\n\n\tif (len > 0) {\n\t\tndev->stats.tx_packets++;\n\t\tndev->stats.tx_bytes += skb->len;\n\t} else {\n\t\tndev->stats.tx_errors++;\n\t\tndev->stats.tx_aborted_errors++;\n\t}\n\n\tdev_kfree_skb_any(skb);\n\n\tif (ntb_transport_tx_free_entry(dev->qp) >= tx_start) {\n\t\t \n\t\tsmp_mb();\n\t\tif (netif_queue_stopped(ndev))\n\t\t\tnetif_wake_queue(ndev);\n\t}\n}\n\nstatic netdev_tx_t ntb_netdev_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *ndev)\n{\n\tstruct ntb_netdev *dev = netdev_priv(ndev);\n\tint rc;\n\n\tntb_netdev_maybe_stop_tx(ndev, dev->qp, tx_stop);\n\n\trc = ntb_transport_tx_enqueue(dev->qp, skb, skb->data, skb->len);\n\tif (rc)\n\t\tgoto err;\n\n\t \n\tntb_netdev_maybe_stop_tx(ndev, dev->qp, tx_stop);\n\n\treturn NETDEV_TX_OK;\n\nerr:\n\tndev->stats.tx_dropped++;\n\tndev->stats.tx_errors++;\n\treturn NETDEV_TX_BUSY;\n}\n\nstatic void ntb_netdev_tx_timer(struct timer_list *t)\n{\n\tstruct ntb_netdev *dev = from_timer(dev, t, tx_timer);\n\tstruct net_device *ndev = dev->ndev;\n\n\tif (ntb_transport_tx_free_entry(dev->qp) < tx_stop) {\n\t\tmod_timer(&dev->tx_timer, jiffies + usecs_to_jiffies(tx_time));\n\t} else {\n\t\t \n\t\tsmp_mb();\n\t\tif (netif_queue_stopped(ndev))\n\t\t\tnetif_wake_queue(ndev);\n\t}\n}\n\nstatic int ntb_netdev_open(struct net_device *ndev)\n{\n\tstruct ntb_netdev *dev = netdev_priv(ndev);\n\tstruct sk_buff *skb;\n\tint rc, i, len;\n\n\t \n\tfor (i = 0; i < NTB_RXQ_SIZE; i++) {\n\t\tskb = netdev_alloc_skb(ndev, ndev->mtu + ETH_HLEN);\n\t\tif (!skb) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\trc = ntb_transport_rx_enqueue(dev->qp, skb, skb->data,\n\t\t\t\t\t      ndev->mtu + ETH_HLEN);\n\t\tif (rc) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\ttimer_setup(&dev->tx_timer, ntb_netdev_tx_timer, 0);\n\n\tnetif_carrier_off(ndev);\n\tntb_transport_link_up(dev->qp);\n\tnetif_start_queue(ndev);\n\n\treturn 0;\n\nerr:\n\twhile ((skb = ntb_transport_rx_remove(dev->qp, &len)))\n\t\tdev_kfree_skb(skb);\n\treturn rc;\n}\n\nstatic int ntb_netdev_close(struct net_device *ndev)\n{\n\tstruct ntb_netdev *dev = netdev_priv(ndev);\n\tstruct sk_buff *skb;\n\tint len;\n\n\tntb_transport_link_down(dev->qp);\n\n\twhile ((skb = ntb_transport_rx_remove(dev->qp, &len)))\n\t\tdev_kfree_skb(skb);\n\n\tdel_timer_sync(&dev->tx_timer);\n\n\treturn 0;\n}\n\nstatic int ntb_netdev_change_mtu(struct net_device *ndev, int new_mtu)\n{\n\tstruct ntb_netdev *dev = netdev_priv(ndev);\n\tstruct sk_buff *skb;\n\tint len, rc;\n\n\tif (new_mtu > ntb_transport_max_size(dev->qp) - ETH_HLEN)\n\t\treturn -EINVAL;\n\n\tif (!netif_running(ndev)) {\n\t\tndev->mtu = new_mtu;\n\t\treturn 0;\n\t}\n\n\t \n\tntb_transport_link_down(dev->qp);\n\n\tif (ndev->mtu < new_mtu) {\n\t\tint i;\n\n\t\tfor (i = 0; (skb = ntb_transport_rx_remove(dev->qp, &len)); i++)\n\t\t\tdev_kfree_skb(skb);\n\n\t\tfor (; i; i--) {\n\t\t\tskb = netdev_alloc_skb(ndev, new_mtu + ETH_HLEN);\n\t\t\tif (!skb) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\trc = ntb_transport_rx_enqueue(dev->qp, skb, skb->data,\n\t\t\t\t\t\t      new_mtu + ETH_HLEN);\n\t\t\tif (rc) {\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tndev->mtu = new_mtu;\n\n\tntb_transport_link_up(dev->qp);\n\n\treturn 0;\n\nerr:\n\tntb_transport_link_down(dev->qp);\n\n\twhile ((skb = ntb_transport_rx_remove(dev->qp, &len)))\n\t\tdev_kfree_skb(skb);\n\n\tnetdev_err(ndev, \"Error changing MTU, device inoperable\\n\");\n\treturn rc;\n}\n\nstatic const struct net_device_ops ntb_netdev_ops = {\n\t.ndo_open = ntb_netdev_open,\n\t.ndo_stop = ntb_netdev_close,\n\t.ndo_start_xmit = ntb_netdev_start_xmit,\n\t.ndo_change_mtu = ntb_netdev_change_mtu,\n\t.ndo_set_mac_address = eth_mac_addr,\n};\n\nstatic void ntb_get_drvinfo(struct net_device *ndev,\n\t\t\t    struct ethtool_drvinfo *info)\n{\n\tstruct ntb_netdev *dev = netdev_priv(ndev);\n\n\tstrscpy(info->driver, KBUILD_MODNAME, sizeof(info->driver));\n\tstrscpy(info->version, NTB_NETDEV_VER, sizeof(info->version));\n\tstrscpy(info->bus_info, pci_name(dev->pdev), sizeof(info->bus_info));\n}\n\nstatic int ntb_get_link_ksettings(struct net_device *dev,\n\t\t\t\t  struct ethtool_link_ksettings *cmd)\n{\n\tethtool_link_ksettings_zero_link_mode(cmd, supported);\n\tethtool_link_ksettings_add_link_mode(cmd, supported, Backplane);\n\tethtool_link_ksettings_zero_link_mode(cmd, advertising);\n\tethtool_link_ksettings_add_link_mode(cmd, advertising, Backplane);\n\n\tcmd->base.speed = SPEED_UNKNOWN;\n\tcmd->base.duplex = DUPLEX_FULL;\n\tcmd->base.port = PORT_OTHER;\n\tcmd->base.phy_address = 0;\n\tcmd->base.autoneg = AUTONEG_ENABLE;\n\n\treturn 0;\n}\n\nstatic const struct ethtool_ops ntb_ethtool_ops = {\n\t.get_drvinfo = ntb_get_drvinfo,\n\t.get_link = ethtool_op_get_link,\n\t.get_link_ksettings = ntb_get_link_ksettings,\n};\n\nstatic const struct ntb_queue_handlers ntb_netdev_handlers = {\n\t.tx_handler = ntb_netdev_tx_handler,\n\t.rx_handler = ntb_netdev_rx_handler,\n\t.event_handler = ntb_netdev_event_handler,\n};\n\nstatic int ntb_netdev_probe(struct device *client_dev)\n{\n\tstruct ntb_dev *ntb;\n\tstruct net_device *ndev;\n\tstruct pci_dev *pdev;\n\tstruct ntb_netdev *dev;\n\tint rc;\n\n\tntb = dev_ntb(client_dev->parent);\n\tpdev = ntb->pdev;\n\tif (!pdev)\n\t\treturn -ENODEV;\n\n\tndev = alloc_etherdev(sizeof(*dev));\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\n\tSET_NETDEV_DEV(ndev, client_dev);\n\n\tdev = netdev_priv(ndev);\n\tdev->ndev = ndev;\n\tdev->pdev = pdev;\n\tndev->features = NETIF_F_HIGHDMA;\n\n\tndev->priv_flags |= IFF_LIVE_ADDR_CHANGE;\n\n\tndev->hw_features = ndev->features;\n\tndev->watchdog_timeo = msecs_to_jiffies(NTB_TX_TIMEOUT_MS);\n\n\teth_random_addr(ndev->perm_addr);\n\tdev_addr_set(ndev, ndev->perm_addr);\n\n\tndev->netdev_ops = &ntb_netdev_ops;\n\tndev->ethtool_ops = &ntb_ethtool_ops;\n\n\tndev->min_mtu = 0;\n\tndev->max_mtu = ETH_MAX_MTU;\n\n\tdev->qp = ntb_transport_create_queue(ndev, client_dev,\n\t\t\t\t\t     &ntb_netdev_handlers);\n\tif (!dev->qp) {\n\t\trc = -EIO;\n\t\tgoto err;\n\t}\n\n\tndev->mtu = ntb_transport_max_size(dev->qp) - ETH_HLEN;\n\n\trc = register_netdev(ndev);\n\tif (rc)\n\t\tgoto err1;\n\n\tdev_set_drvdata(client_dev, ndev);\n\tdev_info(&pdev->dev, \"%s created\\n\", ndev->name);\n\treturn 0;\n\nerr1:\n\tntb_transport_free_queue(dev->qp);\nerr:\n\tfree_netdev(ndev);\n\treturn rc;\n}\n\nstatic void ntb_netdev_remove(struct device *client_dev)\n{\n\tstruct net_device *ndev = dev_get_drvdata(client_dev);\n\tstruct ntb_netdev *dev = netdev_priv(ndev);\n\n\tunregister_netdev(ndev);\n\tntb_transport_free_queue(dev->qp);\n\tfree_netdev(ndev);\n}\n\nstatic struct ntb_transport_client ntb_netdev_client = {\n\t.driver.name = KBUILD_MODNAME,\n\t.driver.owner = THIS_MODULE,\n\t.probe = ntb_netdev_probe,\n\t.remove = ntb_netdev_remove,\n};\n\nstatic int __init ntb_netdev_init_module(void)\n{\n\tint rc;\n\n\trc = ntb_transport_register_client_dev(KBUILD_MODNAME);\n\tif (rc)\n\t\treturn rc;\n\n\trc = ntb_transport_register_client(&ntb_netdev_client);\n\tif (rc) {\n\t\tntb_transport_unregister_client_dev(KBUILD_MODNAME);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\nlate_initcall(ntb_netdev_init_module);\n\nstatic void __exit ntb_netdev_exit_module(void)\n{\n\tntb_transport_unregister_client(&ntb_netdev_client);\n\tntb_transport_unregister_client_dev(KBUILD_MODNAME);\n}\nmodule_exit(ntb_netdev_exit_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}