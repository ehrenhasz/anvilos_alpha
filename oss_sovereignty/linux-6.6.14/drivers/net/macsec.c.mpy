{
  "module_name": "macsec.c",
  "hash_id": "8f89cf51500d1011b7236be02669d0463c2f7f1df4b877f02b1527fc32f5a77b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/macsec.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/skbuff.h>\n#include <linux/socket.h>\n#include <linux/module.h>\n#include <crypto/aead.h>\n#include <linux/etherdevice.h>\n#include <linux/netdevice.h>\n#include <linux/rtnetlink.h>\n#include <linux/refcount.h>\n#include <net/genetlink.h>\n#include <net/sock.h>\n#include <net/gro_cells.h>\n#include <net/macsec.h>\n#include <net/dst_metadata.h>\n#include <linux/phy.h>\n#include <linux/byteorder/generic.h>\n#include <linux/if_arp.h>\n\n#include <uapi/linux/if_macsec.h>\n\n \n#define MACSEC_TAG_LEN 6\n\nstruct macsec_eth_header {\n\tstruct ethhdr eth;\n\t \n\tu8  tci_an;\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n\tu8  short_length:6,\n\t\t  unused:2;\n#elif defined(__BIG_ENDIAN_BITFIELD)\n\tu8        unused:2,\n\t    short_length:6;\n#else\n#error\t\"Please fix <asm/byteorder.h>\"\n#endif\n\t__be32 packet_number;\n\tu8 secure_channel_id[8];  \n} __packed;\n\n \n#define MIN_NON_SHORT_LEN 48\n\n#define GCM_AES_IV_LEN 12\n\n#define for_each_rxsc(secy, sc)\t\t\t\t\\\n\tfor (sc = rcu_dereference_bh(secy->rx_sc);\t\\\n\t     sc;\t\t\t\t\t\\\n\t     sc = rcu_dereference_bh(sc->next))\n#define for_each_rxsc_rtnl(secy, sc)\t\t\t\\\n\tfor (sc = rtnl_dereference(secy->rx_sc);\t\\\n\t     sc;\t\t\t\t\t\\\n\t     sc = rtnl_dereference(sc->next))\n\n#define pn_same_half(pn1, pn2) (!(((pn1) >> 31) ^ ((pn2) >> 31)))\n\nstruct gcm_iv_xpn {\n\tunion {\n\t\tu8 short_secure_channel_id[4];\n\t\tssci_t ssci;\n\t};\n\t__be64 pn;\n} __packed;\n\nstruct gcm_iv {\n\tunion {\n\t\tu8 secure_channel_id[8];\n\t\tsci_t sci;\n\t};\n\t__be32 pn;\n};\n\n#define MACSEC_VALIDATE_DEFAULT MACSEC_VALIDATE_STRICT\n\nstruct pcpu_secy_stats {\n\tstruct macsec_dev_stats stats;\n\tstruct u64_stats_sync syncp;\n};\n\n \nstruct macsec_dev {\n\tstruct macsec_secy secy;\n\tstruct net_device *real_dev;\n\tnetdevice_tracker dev_tracker;\n\tstruct pcpu_secy_stats __percpu *stats;\n\tstruct list_head secys;\n\tstruct gro_cells gro_cells;\n\tenum macsec_offload offload;\n};\n\n \nstruct macsec_rxh_data {\n\tstruct list_head secys;\n};\n\nstatic struct macsec_dev *macsec_priv(const struct net_device *dev)\n{\n\treturn (struct macsec_dev *)netdev_priv(dev);\n}\n\nstatic struct macsec_rxh_data *macsec_data_rcu(const struct net_device *dev)\n{\n\treturn rcu_dereference_bh(dev->rx_handler_data);\n}\n\nstatic struct macsec_rxh_data *macsec_data_rtnl(const struct net_device *dev)\n{\n\treturn rtnl_dereference(dev->rx_handler_data);\n}\n\nstruct macsec_cb {\n\tstruct aead_request *req;\n\tunion {\n\t\tstruct macsec_tx_sa *tx_sa;\n\t\tstruct macsec_rx_sa *rx_sa;\n\t};\n\tu8 assoc_num;\n\tbool valid;\n\tbool has_sci;\n};\n\nstatic struct macsec_rx_sa *macsec_rxsa_get(struct macsec_rx_sa __rcu *ptr)\n{\n\tstruct macsec_rx_sa *sa = rcu_dereference_bh(ptr);\n\n\tif (!sa || !sa->active)\n\t\treturn NULL;\n\n\tif (!refcount_inc_not_zero(&sa->refcnt))\n\t\treturn NULL;\n\n\treturn sa;\n}\n\nstatic struct macsec_rx_sa *macsec_active_rxsa_get(struct macsec_rx_sc *rx_sc)\n{\n\tstruct macsec_rx_sa *sa = NULL;\n\tint an;\n\n\tfor (an = 0; an < MACSEC_NUM_AN; an++)\t{\n\t\tsa = macsec_rxsa_get(rx_sc->sa[an]);\n\t\tif (sa)\n\t\t\tbreak;\n\t}\n\treturn sa;\n}\n\nstatic void free_rx_sc_rcu(struct rcu_head *head)\n{\n\tstruct macsec_rx_sc *rx_sc = container_of(head, struct macsec_rx_sc, rcu_head);\n\n\tfree_percpu(rx_sc->stats);\n\tkfree(rx_sc);\n}\n\nstatic struct macsec_rx_sc *macsec_rxsc_get(struct macsec_rx_sc *sc)\n{\n\treturn refcount_inc_not_zero(&sc->refcnt) ? sc : NULL;\n}\n\nstatic void macsec_rxsc_put(struct macsec_rx_sc *sc)\n{\n\tif (refcount_dec_and_test(&sc->refcnt))\n\t\tcall_rcu(&sc->rcu_head, free_rx_sc_rcu);\n}\n\nstatic void free_rxsa(struct rcu_head *head)\n{\n\tstruct macsec_rx_sa *sa = container_of(head, struct macsec_rx_sa, rcu);\n\n\tcrypto_free_aead(sa->key.tfm);\n\tfree_percpu(sa->stats);\n\tkfree(sa);\n}\n\nstatic void macsec_rxsa_put(struct macsec_rx_sa *sa)\n{\n\tif (refcount_dec_and_test(&sa->refcnt))\n\t\tcall_rcu(&sa->rcu, free_rxsa);\n}\n\nstatic struct macsec_tx_sa *macsec_txsa_get(struct macsec_tx_sa __rcu *ptr)\n{\n\tstruct macsec_tx_sa *sa = rcu_dereference_bh(ptr);\n\n\tif (!sa || !sa->active)\n\t\treturn NULL;\n\n\tif (!refcount_inc_not_zero(&sa->refcnt))\n\t\treturn NULL;\n\n\treturn sa;\n}\n\nstatic void free_txsa(struct rcu_head *head)\n{\n\tstruct macsec_tx_sa *sa = container_of(head, struct macsec_tx_sa, rcu);\n\n\tcrypto_free_aead(sa->key.tfm);\n\tfree_percpu(sa->stats);\n\tkfree(sa);\n}\n\nstatic void macsec_txsa_put(struct macsec_tx_sa *sa)\n{\n\tif (refcount_dec_and_test(&sa->refcnt))\n\t\tcall_rcu(&sa->rcu, free_txsa);\n}\n\nstatic struct macsec_cb *macsec_skb_cb(struct sk_buff *skb)\n{\n\tBUILD_BUG_ON(sizeof(struct macsec_cb) > sizeof(skb->cb));\n\treturn (struct macsec_cb *)skb->cb;\n}\n\n#define MACSEC_PORT_SCB (0x0000)\n#define MACSEC_UNDEF_SCI ((__force sci_t)0xffffffffffffffffULL)\n#define MACSEC_UNDEF_SSCI ((__force ssci_t)0xffffffff)\n\n#define MACSEC_GCM_AES_128_SAK_LEN 16\n#define MACSEC_GCM_AES_256_SAK_LEN 32\n\n#define DEFAULT_SAK_LEN MACSEC_GCM_AES_128_SAK_LEN\n#define DEFAULT_XPN false\n#define DEFAULT_SEND_SCI true\n#define DEFAULT_ENCRYPT false\n#define DEFAULT_ENCODING_SA 0\n#define MACSEC_XPN_MAX_REPLAY_WINDOW (((1 << 30) - 1))\n\nstatic sci_t make_sci(const u8 *addr, __be16 port)\n{\n\tsci_t sci;\n\n\tmemcpy(&sci, addr, ETH_ALEN);\n\tmemcpy(((char *)&sci) + ETH_ALEN, &port, sizeof(port));\n\n\treturn sci;\n}\n\nstatic sci_t macsec_frame_sci(struct macsec_eth_header *hdr, bool sci_present)\n{\n\tsci_t sci;\n\n\tif (sci_present)\n\t\tmemcpy(&sci, hdr->secure_channel_id,\n\t\t       sizeof(hdr->secure_channel_id));\n\telse\n\t\tsci = make_sci(hdr->eth.h_source, MACSEC_PORT_ES);\n\n\treturn sci;\n}\n\nstatic unsigned int macsec_sectag_len(bool sci_present)\n{\n\treturn MACSEC_TAG_LEN + (sci_present ? MACSEC_SCI_LEN : 0);\n}\n\nstatic unsigned int macsec_hdr_len(bool sci_present)\n{\n\treturn macsec_sectag_len(sci_present) + ETH_HLEN;\n}\n\nstatic unsigned int macsec_extra_len(bool sci_present)\n{\n\treturn macsec_sectag_len(sci_present) + sizeof(__be16);\n}\n\n \nstatic void macsec_fill_sectag(struct macsec_eth_header *h,\n\t\t\t       const struct macsec_secy *secy, u32 pn,\n\t\t\t       bool sci_present)\n{\n\tconst struct macsec_tx_sc *tx_sc = &secy->tx_sc;\n\n\tmemset(&h->tci_an, 0, macsec_sectag_len(sci_present));\n\th->eth.h_proto = htons(ETH_P_MACSEC);\n\n\tif (sci_present) {\n\t\th->tci_an |= MACSEC_TCI_SC;\n\t\tmemcpy(&h->secure_channel_id, &secy->sci,\n\t\t       sizeof(h->secure_channel_id));\n\t} else {\n\t\tif (tx_sc->end_station)\n\t\t\th->tci_an |= MACSEC_TCI_ES;\n\t\tif (tx_sc->scb)\n\t\t\th->tci_an |= MACSEC_TCI_SCB;\n\t}\n\n\th->packet_number = htonl(pn);\n\n\t \n\tif (tx_sc->encrypt)\n\t\th->tci_an |= MACSEC_TCI_CONFID;\n\telse if (secy->icv_len != MACSEC_DEFAULT_ICV_LEN)\n\t\th->tci_an |= MACSEC_TCI_C;\n\n\th->tci_an |= tx_sc->encoding_sa;\n}\n\nstatic void macsec_set_shortlen(struct macsec_eth_header *h, size_t data_len)\n{\n\tif (data_len < MIN_NON_SHORT_LEN)\n\t\th->short_length = data_len;\n}\n\n \nstatic bool macsec_is_offloaded(struct macsec_dev *macsec)\n{\n\tif (macsec->offload == MACSEC_OFFLOAD_MAC ||\n\t    macsec->offload == MACSEC_OFFLOAD_PHY)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic bool macsec_check_offload(enum macsec_offload offload,\n\t\t\t\t struct macsec_dev *macsec)\n{\n\tif (!macsec || !macsec->real_dev)\n\t\treturn false;\n\n\tif (offload == MACSEC_OFFLOAD_PHY)\n\t\treturn macsec->real_dev->phydev &&\n\t\t       macsec->real_dev->phydev->macsec_ops;\n\telse if (offload == MACSEC_OFFLOAD_MAC)\n\t\treturn macsec->real_dev->features & NETIF_F_HW_MACSEC &&\n\t\t       macsec->real_dev->macsec_ops;\n\n\treturn false;\n}\n\nstatic const struct macsec_ops *__macsec_get_ops(enum macsec_offload offload,\n\t\t\t\t\t\t struct macsec_dev *macsec,\n\t\t\t\t\t\t struct macsec_context *ctx)\n{\n\tif (ctx) {\n\t\tmemset(ctx, 0, sizeof(*ctx));\n\t\tctx->offload = offload;\n\n\t\tif (offload == MACSEC_OFFLOAD_PHY)\n\t\t\tctx->phydev = macsec->real_dev->phydev;\n\t\telse if (offload == MACSEC_OFFLOAD_MAC)\n\t\t\tctx->netdev = macsec->real_dev;\n\t}\n\n\tif (offload == MACSEC_OFFLOAD_PHY)\n\t\treturn macsec->real_dev->phydev->macsec_ops;\n\telse\n\t\treturn macsec->real_dev->macsec_ops;\n}\n\n \nstatic const struct macsec_ops *macsec_get_ops(struct macsec_dev *macsec,\n\t\t\t\t\t       struct macsec_context *ctx)\n{\n\tif (!macsec_check_offload(macsec->offload, macsec))\n\t\treturn NULL;\n\n\treturn __macsec_get_ops(macsec->offload, macsec, ctx);\n}\n\n \nstatic bool macsec_validate_skb(struct sk_buff *skb, u16 icv_len, bool xpn)\n{\n\tstruct macsec_eth_header *h = (struct macsec_eth_header *)skb->data;\n\tint len = skb->len - 2 * ETH_ALEN;\n\tint extra_len = macsec_extra_len(!!(h->tci_an & MACSEC_TCI_SC)) + icv_len;\n\n\t \n\tif (skb->len <= 16)\n\t\treturn false;\n\n\t \n\n\t \n\tif (h->tci_an & MACSEC_TCI_VERSION)\n\t\treturn false;\n\n\t \n\tif ((h->tci_an & MACSEC_TCI_ES || h->tci_an & MACSEC_TCI_SCB) &&\n\t    (h->tci_an & MACSEC_TCI_SC))\n\t\treturn false;\n\n\t \n\tif (h->unused)\n\t\treturn false;\n\n\t \n\tif (!h->packet_number && !xpn)\n\t\treturn false;\n\n\t \n\tif (h->short_length)\n\t\treturn len == extra_len + h->short_length;\n\treturn len >= extra_len + MIN_NON_SHORT_LEN;\n}\n\n#define MACSEC_NEEDED_HEADROOM (macsec_extra_len(true))\n#define MACSEC_NEEDED_TAILROOM MACSEC_STD_ICV_LEN\n\nstatic void macsec_fill_iv_xpn(unsigned char *iv, ssci_t ssci, u64 pn,\n\t\t\t       salt_t salt)\n{\n\tstruct gcm_iv_xpn *gcm_iv = (struct gcm_iv_xpn *)iv;\n\n\tgcm_iv->ssci = ssci ^ salt.ssci;\n\tgcm_iv->pn = cpu_to_be64(pn) ^ salt.pn;\n}\n\nstatic void macsec_fill_iv(unsigned char *iv, sci_t sci, u32 pn)\n{\n\tstruct gcm_iv *gcm_iv = (struct gcm_iv *)iv;\n\n\tgcm_iv->sci = sci;\n\tgcm_iv->pn = htonl(pn);\n}\n\nstatic struct macsec_eth_header *macsec_ethhdr(struct sk_buff *skb)\n{\n\treturn (struct macsec_eth_header *)skb_mac_header(skb);\n}\n\nstatic void __macsec_pn_wrapped(struct macsec_secy *secy,\n\t\t\t\tstruct macsec_tx_sa *tx_sa)\n{\n\tpr_debug(\"PN wrapped, transitioning to !oper\\n\");\n\ttx_sa->active = false;\n\tif (secy->protect_frames)\n\t\tsecy->operational = false;\n}\n\nvoid macsec_pn_wrapped(struct macsec_secy *secy, struct macsec_tx_sa *tx_sa)\n{\n\tspin_lock_bh(&tx_sa->lock);\n\t__macsec_pn_wrapped(secy, tx_sa);\n\tspin_unlock_bh(&tx_sa->lock);\n}\nEXPORT_SYMBOL_GPL(macsec_pn_wrapped);\n\nstatic pn_t tx_sa_update_pn(struct macsec_tx_sa *tx_sa,\n\t\t\t    struct macsec_secy *secy)\n{\n\tpn_t pn;\n\n\tspin_lock_bh(&tx_sa->lock);\n\n\tpn = tx_sa->next_pn_halves;\n\tif (secy->xpn)\n\t\ttx_sa->next_pn++;\n\telse\n\t\ttx_sa->next_pn_halves.lower++;\n\n\tif (tx_sa->next_pn == 0)\n\t\t__macsec_pn_wrapped(secy, tx_sa);\n\tspin_unlock_bh(&tx_sa->lock);\n\n\treturn pn;\n}\n\nstatic void macsec_encrypt_finish(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct macsec_dev *macsec = netdev_priv(dev);\n\n\tskb->dev = macsec->real_dev;\n\tskb_reset_mac_header(skb);\n\tskb->protocol = eth_hdr(skb)->h_proto;\n}\n\nstatic unsigned int macsec_msdu_len(struct sk_buff *skb)\n{\n\tstruct macsec_dev *macsec = macsec_priv(skb->dev);\n\tstruct macsec_secy *secy = &macsec->secy;\n\tbool sci_present = macsec_skb_cb(skb)->has_sci;\n\n\treturn skb->len - macsec_hdr_len(sci_present) - secy->icv_len;\n}\n\nstatic void macsec_count_tx(struct sk_buff *skb, struct macsec_tx_sc *tx_sc,\n\t\t\t    struct macsec_tx_sa *tx_sa)\n{\n\tunsigned int msdu_len = macsec_msdu_len(skb);\n\tstruct pcpu_tx_sc_stats *txsc_stats = this_cpu_ptr(tx_sc->stats);\n\n\tu64_stats_update_begin(&txsc_stats->syncp);\n\tif (tx_sc->encrypt) {\n\t\ttxsc_stats->stats.OutOctetsEncrypted += msdu_len;\n\t\ttxsc_stats->stats.OutPktsEncrypted++;\n\t\tthis_cpu_inc(tx_sa->stats->OutPktsEncrypted);\n\t} else {\n\t\ttxsc_stats->stats.OutOctetsProtected += msdu_len;\n\t\ttxsc_stats->stats.OutPktsProtected++;\n\t\tthis_cpu_inc(tx_sa->stats->OutPktsProtected);\n\t}\n\tu64_stats_update_end(&txsc_stats->syncp);\n}\n\nstatic void count_tx(struct net_device *dev, int ret, int len)\n{\n\tif (likely(ret == NET_XMIT_SUCCESS || ret == NET_XMIT_CN))\n\t\tdev_sw_netstats_tx_add(dev, 1, len);\n}\n\nstatic void macsec_encrypt_done(void *data, int err)\n{\n\tstruct sk_buff *skb = data;\n\tstruct net_device *dev = skb->dev;\n\tstruct macsec_dev *macsec = macsec_priv(dev);\n\tstruct macsec_tx_sa *sa = macsec_skb_cb(skb)->tx_sa;\n\tint len, ret;\n\n\taead_request_free(macsec_skb_cb(skb)->req);\n\n\trcu_read_lock_bh();\n\tmacsec_count_tx(skb, &macsec->secy.tx_sc, macsec_skb_cb(skb)->tx_sa);\n\t \n\tlen = macsec_msdu_len(skb) + 2 * ETH_ALEN;\n\tmacsec_encrypt_finish(skb, dev);\n\tret = dev_queue_xmit(skb);\n\tcount_tx(dev, ret, len);\n\trcu_read_unlock_bh();\n\n\tmacsec_txsa_put(sa);\n\tdev_put(dev);\n}\n\nstatic struct aead_request *macsec_alloc_req(struct crypto_aead *tfm,\n\t\t\t\t\t     unsigned char **iv,\n\t\t\t\t\t     struct scatterlist **sg,\n\t\t\t\t\t     int num_frags)\n{\n\tsize_t size, iv_offset, sg_offset;\n\tstruct aead_request *req;\n\tvoid *tmp;\n\n\tsize = sizeof(struct aead_request) + crypto_aead_reqsize(tfm);\n\tiv_offset = size;\n\tsize += GCM_AES_IV_LEN;\n\n\tsize = ALIGN(size, __alignof__(struct scatterlist));\n\tsg_offset = size;\n\tsize += sizeof(struct scatterlist) * num_frags;\n\n\ttmp = kmalloc(size, GFP_ATOMIC);\n\tif (!tmp)\n\t\treturn NULL;\n\n\t*iv = (unsigned char *)(tmp + iv_offset);\n\t*sg = (struct scatterlist *)(tmp + sg_offset);\n\treq = tmp;\n\n\taead_request_set_tfm(req, tfm);\n\n\treturn req;\n}\n\nstatic struct sk_buff *macsec_encrypt(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev)\n{\n\tint ret;\n\tstruct scatterlist *sg;\n\tstruct sk_buff *trailer;\n\tunsigned char *iv;\n\tstruct ethhdr *eth;\n\tstruct macsec_eth_header *hh;\n\tsize_t unprotected_len;\n\tstruct aead_request *req;\n\tstruct macsec_secy *secy;\n\tstruct macsec_tx_sc *tx_sc;\n\tstruct macsec_tx_sa *tx_sa;\n\tstruct macsec_dev *macsec = macsec_priv(dev);\n\tbool sci_present;\n\tpn_t pn;\n\n\tsecy = &macsec->secy;\n\ttx_sc = &secy->tx_sc;\n\n\t \n\ttx_sa = macsec_txsa_get(tx_sc->sa[tx_sc->encoding_sa]);\n\tif (!tx_sa) {\n\t\tsecy->operational = false;\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (unlikely(skb_headroom(skb) < MACSEC_NEEDED_HEADROOM ||\n\t\t     skb_tailroom(skb) < MACSEC_NEEDED_TAILROOM)) {\n\t\tstruct sk_buff *nskb = skb_copy_expand(skb,\n\t\t\t\t\t\t       MACSEC_NEEDED_HEADROOM,\n\t\t\t\t\t\t       MACSEC_NEEDED_TAILROOM,\n\t\t\t\t\t\t       GFP_ATOMIC);\n\t\tif (likely(nskb)) {\n\t\t\tconsume_skb(skb);\n\t\t\tskb = nskb;\n\t\t} else {\n\t\t\tmacsec_txsa_put(tx_sa);\n\t\t\tkfree_skb(skb);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t} else {\n\t\tskb = skb_unshare(skb, GFP_ATOMIC);\n\t\tif (!skb) {\n\t\t\tmacsec_txsa_put(tx_sa);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\n\tunprotected_len = skb->len;\n\teth = eth_hdr(skb);\n\tsci_present = macsec_send_sci(secy);\n\thh = skb_push(skb, macsec_extra_len(sci_present));\n\tmemmove(hh, eth, 2 * ETH_ALEN);\n\n\tpn = tx_sa_update_pn(tx_sa, secy);\n\tif (pn.full64 == 0) {\n\t\tmacsec_txsa_put(tx_sa);\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(-ENOLINK);\n\t}\n\tmacsec_fill_sectag(hh, secy, pn.lower, sci_present);\n\tmacsec_set_shortlen(hh, unprotected_len - 2 * ETH_ALEN);\n\n\tskb_put(skb, secy->icv_len);\n\n\tif (skb->len - ETH_HLEN > macsec_priv(dev)->real_dev->mtu) {\n\t\tstruct pcpu_secy_stats *secy_stats = this_cpu_ptr(macsec->stats);\n\n\t\tu64_stats_update_begin(&secy_stats->syncp);\n\t\tsecy_stats->stats.OutPktsTooLong++;\n\t\tu64_stats_update_end(&secy_stats->syncp);\n\n\t\tmacsec_txsa_put(tx_sa);\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tret = skb_cow_data(skb, 0, &trailer);\n\tif (unlikely(ret < 0)) {\n\t\tmacsec_txsa_put(tx_sa);\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treq = macsec_alloc_req(tx_sa->key.tfm, &iv, &sg, ret);\n\tif (!req) {\n\t\tmacsec_txsa_put(tx_sa);\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tif (secy->xpn)\n\t\tmacsec_fill_iv_xpn(iv, tx_sa->ssci, pn.full64, tx_sa->key.salt);\n\telse\n\t\tmacsec_fill_iv(iv, secy->sci, pn.lower);\n\n\tsg_init_table(sg, ret);\n\tret = skb_to_sgvec(skb, sg, 0, skb->len);\n\tif (unlikely(ret < 0)) {\n\t\taead_request_free(req);\n\t\tmacsec_txsa_put(tx_sa);\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (tx_sc->encrypt) {\n\t\tint len = skb->len - macsec_hdr_len(sci_present) -\n\t\t\t  secy->icv_len;\n\t\taead_request_set_crypt(req, sg, sg, len, iv);\n\t\taead_request_set_ad(req, macsec_hdr_len(sci_present));\n\t} else {\n\t\taead_request_set_crypt(req, sg, sg, 0, iv);\n\t\taead_request_set_ad(req, skb->len - secy->icv_len);\n\t}\n\n\tmacsec_skb_cb(skb)->req = req;\n\tmacsec_skb_cb(skb)->tx_sa = tx_sa;\n\tmacsec_skb_cb(skb)->has_sci = sci_present;\n\taead_request_set_callback(req, 0, macsec_encrypt_done, skb);\n\n\tdev_hold(skb->dev);\n\tret = crypto_aead_encrypt(req);\n\tif (ret == -EINPROGRESS) {\n\t\treturn ERR_PTR(ret);\n\t} else if (ret != 0) {\n\t\tdev_put(skb->dev);\n\t\tkfree_skb(skb);\n\t\taead_request_free(req);\n\t\tmacsec_txsa_put(tx_sa);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tdev_put(skb->dev);\n\taead_request_free(req);\n\tmacsec_txsa_put(tx_sa);\n\n\treturn skb;\n}\n\nstatic bool macsec_post_decrypt(struct sk_buff *skb, struct macsec_secy *secy, u32 pn)\n{\n\tstruct macsec_rx_sa *rx_sa = macsec_skb_cb(skb)->rx_sa;\n\tstruct pcpu_rx_sc_stats *rxsc_stats = this_cpu_ptr(rx_sa->sc->stats);\n\tstruct macsec_eth_header *hdr = macsec_ethhdr(skb);\n\tu32 lowest_pn = 0;\n\n\tspin_lock(&rx_sa->lock);\n\tif (rx_sa->next_pn_halves.lower >= secy->replay_window)\n\t\tlowest_pn = rx_sa->next_pn_halves.lower - secy->replay_window;\n\n\t \n\tif (secy->replay_protect && pn < lowest_pn &&\n\t    (!secy->xpn || pn_same_half(pn, lowest_pn))) {\n\t\tspin_unlock(&rx_sa->lock);\n\t\tu64_stats_update_begin(&rxsc_stats->syncp);\n\t\trxsc_stats->stats.InPktsLate++;\n\t\tu64_stats_update_end(&rxsc_stats->syncp);\n\t\tDEV_STATS_INC(secy->netdev, rx_dropped);\n\t\treturn false;\n\t}\n\n\tif (secy->validate_frames != MACSEC_VALIDATE_DISABLED) {\n\t\tunsigned int msdu_len = macsec_msdu_len(skb);\n\t\tu64_stats_update_begin(&rxsc_stats->syncp);\n\t\tif (hdr->tci_an & MACSEC_TCI_E)\n\t\t\trxsc_stats->stats.InOctetsDecrypted += msdu_len;\n\t\telse\n\t\t\trxsc_stats->stats.InOctetsValidated += msdu_len;\n\t\tu64_stats_update_end(&rxsc_stats->syncp);\n\t}\n\n\tif (!macsec_skb_cb(skb)->valid) {\n\t\tspin_unlock(&rx_sa->lock);\n\n\t\t \n\t\tif (hdr->tci_an & MACSEC_TCI_C ||\n\t\t    secy->validate_frames == MACSEC_VALIDATE_STRICT) {\n\t\t\tu64_stats_update_begin(&rxsc_stats->syncp);\n\t\t\trxsc_stats->stats.InPktsNotValid++;\n\t\t\tu64_stats_update_end(&rxsc_stats->syncp);\n\t\t\tthis_cpu_inc(rx_sa->stats->InPktsNotValid);\n\t\t\tDEV_STATS_INC(secy->netdev, rx_errors);\n\t\t\treturn false;\n\t\t}\n\n\t\tu64_stats_update_begin(&rxsc_stats->syncp);\n\t\tif (secy->validate_frames == MACSEC_VALIDATE_CHECK) {\n\t\t\trxsc_stats->stats.InPktsInvalid++;\n\t\t\tthis_cpu_inc(rx_sa->stats->InPktsInvalid);\n\t\t} else if (pn < lowest_pn) {\n\t\t\trxsc_stats->stats.InPktsDelayed++;\n\t\t} else {\n\t\t\trxsc_stats->stats.InPktsUnchecked++;\n\t\t}\n\t\tu64_stats_update_end(&rxsc_stats->syncp);\n\t} else {\n\t\tu64_stats_update_begin(&rxsc_stats->syncp);\n\t\tif (pn < lowest_pn) {\n\t\t\trxsc_stats->stats.InPktsDelayed++;\n\t\t} else {\n\t\t\trxsc_stats->stats.InPktsOK++;\n\t\t\tthis_cpu_inc(rx_sa->stats->InPktsOK);\n\t\t}\n\t\tu64_stats_update_end(&rxsc_stats->syncp);\n\n\t\t\n\t\tif (pn + 1 > rx_sa->next_pn_halves.lower) {\n\t\t\trx_sa->next_pn_halves.lower = pn + 1;\n\t\t} else if (secy->xpn &&\n\t\t\t   !pn_same_half(pn, rx_sa->next_pn_halves.lower)) {\n\t\t\trx_sa->next_pn_halves.upper++;\n\t\t\trx_sa->next_pn_halves.lower = pn + 1;\n\t\t}\n\n\t\tspin_unlock(&rx_sa->lock);\n\t}\n\n\treturn true;\n}\n\nstatic void macsec_reset_skb(struct sk_buff *skb, struct net_device *dev)\n{\n\tskb->pkt_type = PACKET_HOST;\n\tskb->protocol = eth_type_trans(skb, dev);\n\n\tskb_reset_network_header(skb);\n\tif (!skb_transport_header_was_set(skb))\n\t\tskb_reset_transport_header(skb);\n\tskb_reset_mac_len(skb);\n}\n\nstatic void macsec_finalize_skb(struct sk_buff *skb, u8 icv_len, u8 hdr_len)\n{\n\tskb->ip_summed = CHECKSUM_NONE;\n\tmemmove(skb->data + hdr_len, skb->data, 2 * ETH_ALEN);\n\tskb_pull(skb, hdr_len);\n\tpskb_trim_unique(skb, skb->len - icv_len);\n}\n\nstatic void count_rx(struct net_device *dev, int len)\n{\n\tdev_sw_netstats_rx_add(dev, len);\n}\n\nstatic void macsec_decrypt_done(void *data, int err)\n{\n\tstruct sk_buff *skb = data;\n\tstruct net_device *dev = skb->dev;\n\tstruct macsec_dev *macsec = macsec_priv(dev);\n\tstruct macsec_rx_sa *rx_sa = macsec_skb_cb(skb)->rx_sa;\n\tstruct macsec_rx_sc *rx_sc = rx_sa->sc;\n\tint len;\n\tu32 pn;\n\n\taead_request_free(macsec_skb_cb(skb)->req);\n\n\tif (!err)\n\t\tmacsec_skb_cb(skb)->valid = true;\n\n\trcu_read_lock_bh();\n\tpn = ntohl(macsec_ethhdr(skb)->packet_number);\n\tif (!macsec_post_decrypt(skb, &macsec->secy, pn)) {\n\t\trcu_read_unlock_bh();\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tmacsec_finalize_skb(skb, macsec->secy.icv_len,\n\t\t\t    macsec_extra_len(macsec_skb_cb(skb)->has_sci));\n\tlen = skb->len;\n\tmacsec_reset_skb(skb, macsec->secy.netdev);\n\n\tif (gro_cells_receive(&macsec->gro_cells, skb) == NET_RX_SUCCESS)\n\t\tcount_rx(dev, len);\n\n\trcu_read_unlock_bh();\n\nout:\n\tmacsec_rxsa_put(rx_sa);\n\tmacsec_rxsc_put(rx_sc);\n\tdev_put(dev);\n}\n\nstatic struct sk_buff *macsec_decrypt(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev,\n\t\t\t\t      struct macsec_rx_sa *rx_sa,\n\t\t\t\t      sci_t sci,\n\t\t\t\t      struct macsec_secy *secy)\n{\n\tint ret;\n\tstruct scatterlist *sg;\n\tstruct sk_buff *trailer;\n\tunsigned char *iv;\n\tstruct aead_request *req;\n\tstruct macsec_eth_header *hdr;\n\tu32 hdr_pn;\n\tu16 icv_len = secy->icv_len;\n\n\tmacsec_skb_cb(skb)->valid = false;\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = skb_cow_data(skb, 0, &trailer);\n\tif (unlikely(ret < 0)) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(ret);\n\t}\n\treq = macsec_alloc_req(rx_sa->key.tfm, &iv, &sg, ret);\n\tif (!req) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\thdr = (struct macsec_eth_header *)skb->data;\n\thdr_pn = ntohl(hdr->packet_number);\n\n\tif (secy->xpn) {\n\t\tpn_t recovered_pn = rx_sa->next_pn_halves;\n\n\t\trecovered_pn.lower = hdr_pn;\n\t\tif (hdr_pn < rx_sa->next_pn_halves.lower &&\n\t\t    !pn_same_half(hdr_pn, rx_sa->next_pn_halves.lower))\n\t\t\trecovered_pn.upper++;\n\n\t\tmacsec_fill_iv_xpn(iv, rx_sa->ssci, recovered_pn.full64,\n\t\t\t\t   rx_sa->key.salt);\n\t} else {\n\t\tmacsec_fill_iv(iv, sci, hdr_pn);\n\t}\n\n\tsg_init_table(sg, ret);\n\tret = skb_to_sgvec(skb, sg, 0, skb->len);\n\tif (unlikely(ret < 0)) {\n\t\taead_request_free(req);\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (hdr->tci_an & MACSEC_TCI_E) {\n\t\t \n\t\tint len = skb->len - macsec_hdr_len(macsec_skb_cb(skb)->has_sci);\n\n\t\taead_request_set_crypt(req, sg, sg, len, iv);\n\t\taead_request_set_ad(req, macsec_hdr_len(macsec_skb_cb(skb)->has_sci));\n\t\tskb = skb_unshare(skb, GFP_ATOMIC);\n\t\tif (!skb) {\n\t\t\taead_request_free(req);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t} else {\n\t\t \n\t\taead_request_set_crypt(req, sg, sg, icv_len, iv);\n\t\taead_request_set_ad(req, skb->len - icv_len);\n\t}\n\n\tmacsec_skb_cb(skb)->req = req;\n\tskb->dev = dev;\n\taead_request_set_callback(req, 0, macsec_decrypt_done, skb);\n\n\tdev_hold(dev);\n\tret = crypto_aead_decrypt(req);\n\tif (ret == -EINPROGRESS) {\n\t\treturn ERR_PTR(ret);\n\t} else if (ret != 0) {\n\t\t \n\t\tif (ret != -EBADMSG) {\n\t\t\tkfree_skb(skb);\n\t\t\tskb = ERR_PTR(ret);\n\t\t}\n\t} else {\n\t\tmacsec_skb_cb(skb)->valid = true;\n\t}\n\tdev_put(dev);\n\n\taead_request_free(req);\n\n\treturn skb;\n}\n\nstatic struct macsec_rx_sc *find_rx_sc(struct macsec_secy *secy, sci_t sci)\n{\n\tstruct macsec_rx_sc *rx_sc;\n\n\tfor_each_rxsc(secy, rx_sc) {\n\t\tif (rx_sc->sci == sci)\n\t\t\treturn rx_sc;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct macsec_rx_sc *find_rx_sc_rtnl(struct macsec_secy *secy, sci_t sci)\n{\n\tstruct macsec_rx_sc *rx_sc;\n\n\tfor_each_rxsc_rtnl(secy, rx_sc) {\n\t\tif (rx_sc->sci == sci)\n\t\t\treturn rx_sc;\n\t}\n\n\treturn NULL;\n}\n\nstatic enum rx_handler_result handle_not_macsec(struct sk_buff *skb)\n{\n\t \n\tenum rx_handler_result ret = RX_HANDLER_PASS;\n\tstruct ethhdr *hdr = eth_hdr(skb);\n\tstruct metadata_dst *md_dst;\n\tstruct macsec_rxh_data *rxd;\n\tstruct macsec_dev *macsec;\n\n\trcu_read_lock();\n\trxd = macsec_data_rcu(skb->dev);\n\tmd_dst = skb_metadata_dst(skb);\n\n\tlist_for_each_entry_rcu(macsec, &rxd->secys, secys) {\n\t\tstruct sk_buff *nskb;\n\t\tstruct pcpu_secy_stats *secy_stats = this_cpu_ptr(macsec->stats);\n\t\tstruct net_device *ndev = macsec->secy.netdev;\n\n\t\t \n\t\tif (macsec_is_offloaded(macsec) && netif_running(ndev)) {\n\t\t\tstruct macsec_rx_sc *rx_sc = NULL;\n\n\t\t\tif (md_dst && md_dst->type == METADATA_MACSEC)\n\t\t\t\trx_sc = find_rx_sc(&macsec->secy, md_dst->u.macsec_info.sci);\n\n\t\t\tif (md_dst && md_dst->type == METADATA_MACSEC && !rx_sc)\n\t\t\t\tcontinue;\n\n\t\t\tif (ether_addr_equal_64bits(hdr->h_dest,\n\t\t\t\t\t\t    ndev->dev_addr)) {\n\t\t\t\t \n\t\t\t\tskb->dev = ndev;\n\t\t\t\tskb->pkt_type = PACKET_HOST;\n\t\t\t\tret = RX_HANDLER_ANOTHER;\n\t\t\t\tgoto out;\n\t\t\t} else if (is_multicast_ether_addr_64bits(\n\t\t\t\t\t   hdr->h_dest)) {\n\t\t\t\t \n\t\t\t\tnskb = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\tif (!nskb)\n\t\t\t\t\tbreak;\n\n\t\t\t\tnskb->dev = ndev;\n\t\t\t\tif (ether_addr_equal_64bits(hdr->h_dest,\n\t\t\t\t\t\t\t    ndev->broadcast))\n\t\t\t\t\tnskb->pkt_type = PACKET_BROADCAST;\n\t\t\t\telse\n\t\t\t\t\tnskb->pkt_type = PACKET_MULTICAST;\n\n\t\t\t\t__netif_rx(nskb);\n\t\t\t} else if (rx_sc || ndev->flags & IFF_PROMISC) {\n\t\t\t\tskb->dev = ndev;\n\t\t\t\tskb->pkt_type = PACKET_HOST;\n\t\t\t\tret = RX_HANDLER_ANOTHER;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (macsec->secy.validate_frames == MACSEC_VALIDATE_STRICT) {\n\t\t\tu64_stats_update_begin(&secy_stats->syncp);\n\t\t\tsecy_stats->stats.InPktsNoTag++;\n\t\t\tu64_stats_update_end(&secy_stats->syncp);\n\t\t\tDEV_STATS_INC(macsec->secy.netdev, rx_dropped);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tnskb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!nskb)\n\t\t\tbreak;\n\n\t\tnskb->dev = ndev;\n\n\t\tif (__netif_rx(nskb) == NET_RX_SUCCESS) {\n\t\t\tu64_stats_update_begin(&secy_stats->syncp);\n\t\t\tsecy_stats->stats.InPktsUntagged++;\n\t\t\tu64_stats_update_end(&secy_stats->syncp);\n\t\t}\n\t}\n\nout:\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic rx_handler_result_t macsec_handle_frame(struct sk_buff **pskb)\n{\n\tstruct sk_buff *skb = *pskb;\n\tstruct net_device *dev = skb->dev;\n\tstruct macsec_eth_header *hdr;\n\tstruct macsec_secy *secy = NULL;\n\tstruct macsec_rx_sc *rx_sc;\n\tstruct macsec_rx_sa *rx_sa;\n\tstruct macsec_rxh_data *rxd;\n\tstruct macsec_dev *macsec;\n\tunsigned int len;\n\tsci_t sci;\n\tu32 hdr_pn;\n\tbool cbit;\n\tstruct pcpu_rx_sc_stats *rxsc_stats;\n\tstruct pcpu_secy_stats *secy_stats;\n\tbool pulled_sci;\n\tint ret;\n\n\tif (skb_headroom(skb) < ETH_HLEN)\n\t\tgoto drop_direct;\n\n\thdr = macsec_ethhdr(skb);\n\tif (hdr->eth.h_proto != htons(ETH_P_MACSEC))\n\t\treturn handle_not_macsec(skb);\n\n\tskb = skb_unshare(skb, GFP_ATOMIC);\n\t*pskb = skb;\n\tif (!skb)\n\t\treturn RX_HANDLER_CONSUMED;\n\n\tpulled_sci = pskb_may_pull(skb, macsec_extra_len(true));\n\tif (!pulled_sci) {\n\t\tif (!pskb_may_pull(skb, macsec_extra_len(false)))\n\t\t\tgoto drop_direct;\n\t}\n\n\thdr = macsec_ethhdr(skb);\n\n\t \n\tif ((hdr->tci_an & (MACSEC_TCI_C | MACSEC_TCI_E)) == MACSEC_TCI_E)\n\t\treturn RX_HANDLER_PASS;\n\n\t \n\tif (hdr->tci_an & MACSEC_TCI_SC) {\n\t\tif (!pulled_sci)\n\t\t\tgoto drop_direct;\n\t}\n\n\t \n\tskb_push(skb, ETH_HLEN);\n\n\tmacsec_skb_cb(skb)->has_sci = !!(hdr->tci_an & MACSEC_TCI_SC);\n\tmacsec_skb_cb(skb)->assoc_num = hdr->tci_an & MACSEC_AN_MASK;\n\tsci = macsec_frame_sci(hdr, macsec_skb_cb(skb)->has_sci);\n\n\trcu_read_lock();\n\trxd = macsec_data_rcu(skb->dev);\n\n\tlist_for_each_entry_rcu(macsec, &rxd->secys, secys) {\n\t\tstruct macsec_rx_sc *sc = find_rx_sc(&macsec->secy, sci);\n\n\t\tsc = sc ? macsec_rxsc_get(sc) : NULL;\n\n\t\tif (sc) {\n\t\t\tsecy = &macsec->secy;\n\t\t\trx_sc = sc;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!secy)\n\t\tgoto nosci;\n\n\tdev = secy->netdev;\n\tmacsec = macsec_priv(dev);\n\tsecy_stats = this_cpu_ptr(macsec->stats);\n\trxsc_stats = this_cpu_ptr(rx_sc->stats);\n\n\tif (!macsec_validate_skb(skb, secy->icv_len, secy->xpn)) {\n\t\tu64_stats_update_begin(&secy_stats->syncp);\n\t\tsecy_stats->stats.InPktsBadTag++;\n\t\tu64_stats_update_end(&secy_stats->syncp);\n\t\tDEV_STATS_INC(secy->netdev, rx_errors);\n\t\tgoto drop_nosa;\n\t}\n\n\trx_sa = macsec_rxsa_get(rx_sc->sa[macsec_skb_cb(skb)->assoc_num]);\n\tif (!rx_sa) {\n\t\t \n\n\t\t \n\t\tstruct macsec_rx_sa *active_rx_sa = macsec_active_rxsa_get(rx_sc);\n\t\tif (hdr->tci_an & MACSEC_TCI_C ||\n\t\t    secy->validate_frames == MACSEC_VALIDATE_STRICT) {\n\t\t\tu64_stats_update_begin(&rxsc_stats->syncp);\n\t\t\trxsc_stats->stats.InPktsNotUsingSA++;\n\t\t\tu64_stats_update_end(&rxsc_stats->syncp);\n\t\t\tDEV_STATS_INC(secy->netdev, rx_errors);\n\t\t\tif (active_rx_sa)\n\t\t\t\tthis_cpu_inc(active_rx_sa->stats->InPktsNotUsingSA);\n\t\t\tgoto drop_nosa;\n\t\t}\n\n\t\t \n\t\tu64_stats_update_begin(&rxsc_stats->syncp);\n\t\trxsc_stats->stats.InPktsUnusedSA++;\n\t\tu64_stats_update_end(&rxsc_stats->syncp);\n\t\tif (active_rx_sa)\n\t\t\tthis_cpu_inc(active_rx_sa->stats->InPktsUnusedSA);\n\t\tgoto deliver;\n\t}\n\n\t \n\thdr_pn = ntohl(hdr->packet_number);\n\tif (secy->replay_protect) {\n\t\tbool late;\n\n\t\tspin_lock(&rx_sa->lock);\n\t\tlate = rx_sa->next_pn_halves.lower >= secy->replay_window &&\n\t\t       hdr_pn < (rx_sa->next_pn_halves.lower - secy->replay_window);\n\n\t\tif (secy->xpn)\n\t\t\tlate = late && pn_same_half(rx_sa->next_pn_halves.lower, hdr_pn);\n\t\tspin_unlock(&rx_sa->lock);\n\n\t\tif (late) {\n\t\t\tu64_stats_update_begin(&rxsc_stats->syncp);\n\t\t\trxsc_stats->stats.InPktsLate++;\n\t\t\tu64_stats_update_end(&rxsc_stats->syncp);\n\t\t\tDEV_STATS_INC(macsec->secy.netdev, rx_dropped);\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tmacsec_skb_cb(skb)->rx_sa = rx_sa;\n\n\t \n\tif (hdr->tci_an & MACSEC_TCI_C ||\n\t    secy->validate_frames != MACSEC_VALIDATE_DISABLED)\n\t\tskb = macsec_decrypt(skb, dev, rx_sa, sci, secy);\n\n\tif (IS_ERR(skb)) {\n\t\t \n\t\tif (PTR_ERR(skb) != -EINPROGRESS) {\n\t\t\tmacsec_rxsa_put(rx_sa);\n\t\t\tmacsec_rxsc_put(rx_sc);\n\t\t}\n\t\trcu_read_unlock();\n\t\t*pskb = NULL;\n\t\treturn RX_HANDLER_CONSUMED;\n\t}\n\n\tif (!macsec_post_decrypt(skb, secy, hdr_pn))\n\t\tgoto drop;\n\ndeliver:\n\tmacsec_finalize_skb(skb, secy->icv_len,\n\t\t\t    macsec_extra_len(macsec_skb_cb(skb)->has_sci));\n\tlen = skb->len;\n\tmacsec_reset_skb(skb, secy->netdev);\n\n\tif (rx_sa)\n\t\tmacsec_rxsa_put(rx_sa);\n\tmacsec_rxsc_put(rx_sc);\n\n\tskb_orphan(skb);\n\tret = gro_cells_receive(&macsec->gro_cells, skb);\n\tif (ret == NET_RX_SUCCESS)\n\t\tcount_rx(dev, len);\n\telse\n\t\tDEV_STATS_INC(macsec->secy.netdev, rx_dropped);\n\n\trcu_read_unlock();\n\n\t*pskb = NULL;\n\treturn RX_HANDLER_CONSUMED;\n\ndrop:\n\tmacsec_rxsa_put(rx_sa);\ndrop_nosa:\n\tmacsec_rxsc_put(rx_sc);\n\trcu_read_unlock();\ndrop_direct:\n\tkfree_skb(skb);\n\t*pskb = NULL;\n\treturn RX_HANDLER_CONSUMED;\n\nnosci:\n\t \n\tcbit = !!(hdr->tci_an & MACSEC_TCI_C);\n\tif (!cbit)\n\t\tmacsec_finalize_skb(skb, MACSEC_DEFAULT_ICV_LEN,\n\t\t\t\t    macsec_extra_len(macsec_skb_cb(skb)->has_sci));\n\n\tlist_for_each_entry_rcu(macsec, &rxd->secys, secys) {\n\t\tstruct sk_buff *nskb;\n\n\t\tsecy_stats = this_cpu_ptr(macsec->stats);\n\n\t\t \n\t\tif (cbit ||\n\t\t    macsec->secy.validate_frames == MACSEC_VALIDATE_STRICT) {\n\t\t\tu64_stats_update_begin(&secy_stats->syncp);\n\t\t\tsecy_stats->stats.InPktsNoSCI++;\n\t\t\tu64_stats_update_end(&secy_stats->syncp);\n\t\t\tDEV_STATS_INC(macsec->secy.netdev, rx_errors);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tnskb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (!nskb)\n\t\t\tbreak;\n\n\t\tmacsec_reset_skb(nskb, macsec->secy.netdev);\n\n\t\tret = __netif_rx(nskb);\n\t\tif (ret == NET_RX_SUCCESS) {\n\t\t\tu64_stats_update_begin(&secy_stats->syncp);\n\t\t\tsecy_stats->stats.InPktsUnknownSCI++;\n\t\t\tu64_stats_update_end(&secy_stats->syncp);\n\t\t} else {\n\t\t\tDEV_STATS_INC(macsec->secy.netdev, rx_dropped);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\t*pskb = skb;\n\treturn RX_HANDLER_PASS;\n}\n\nstatic struct crypto_aead *macsec_alloc_tfm(char *key, int key_len, int icv_len)\n{\n\tstruct crypto_aead *tfm;\n\tint ret;\n\n\ttfm = crypto_alloc_aead(\"gcm(aes)\", 0, 0);\n\n\tif (IS_ERR(tfm))\n\t\treturn tfm;\n\n\tret = crypto_aead_setkey(tfm, key, key_len);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tret = crypto_aead_setauthsize(tfm, icv_len);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\treturn tfm;\nfail:\n\tcrypto_free_aead(tfm);\n\treturn ERR_PTR(ret);\n}\n\nstatic int init_rx_sa(struct macsec_rx_sa *rx_sa, char *sak, int key_len,\n\t\t      int icv_len)\n{\n\trx_sa->stats = alloc_percpu(struct macsec_rx_sa_stats);\n\tif (!rx_sa->stats)\n\t\treturn -ENOMEM;\n\n\trx_sa->key.tfm = macsec_alloc_tfm(sak, key_len, icv_len);\n\tif (IS_ERR(rx_sa->key.tfm)) {\n\t\tfree_percpu(rx_sa->stats);\n\t\treturn PTR_ERR(rx_sa->key.tfm);\n\t}\n\n\trx_sa->ssci = MACSEC_UNDEF_SSCI;\n\trx_sa->active = false;\n\trx_sa->next_pn = 1;\n\trefcount_set(&rx_sa->refcnt, 1);\n\tspin_lock_init(&rx_sa->lock);\n\n\treturn 0;\n}\n\nstatic void clear_rx_sa(struct macsec_rx_sa *rx_sa)\n{\n\trx_sa->active = false;\n\n\tmacsec_rxsa_put(rx_sa);\n}\n\nstatic void free_rx_sc(struct macsec_rx_sc *rx_sc)\n{\n\tint i;\n\n\tfor (i = 0; i < MACSEC_NUM_AN; i++) {\n\t\tstruct macsec_rx_sa *sa = rtnl_dereference(rx_sc->sa[i]);\n\n\t\tRCU_INIT_POINTER(rx_sc->sa[i], NULL);\n\t\tif (sa)\n\t\t\tclear_rx_sa(sa);\n\t}\n\n\tmacsec_rxsc_put(rx_sc);\n}\n\nstatic struct macsec_rx_sc *del_rx_sc(struct macsec_secy *secy, sci_t sci)\n{\n\tstruct macsec_rx_sc *rx_sc, __rcu **rx_scp;\n\n\tfor (rx_scp = &secy->rx_sc, rx_sc = rtnl_dereference(*rx_scp);\n\t     rx_sc;\n\t     rx_scp = &rx_sc->next, rx_sc = rtnl_dereference(*rx_scp)) {\n\t\tif (rx_sc->sci == sci) {\n\t\t\tif (rx_sc->active)\n\t\t\t\tsecy->n_rx_sc--;\n\t\t\trcu_assign_pointer(*rx_scp, rx_sc->next);\n\t\t\treturn rx_sc;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct macsec_rx_sc *create_rx_sc(struct net_device *dev, sci_t sci,\n\t\t\t\t\t bool active)\n{\n\tstruct macsec_rx_sc *rx_sc;\n\tstruct macsec_dev *macsec;\n\tstruct net_device *real_dev = macsec_priv(dev)->real_dev;\n\tstruct macsec_rxh_data *rxd = macsec_data_rtnl(real_dev);\n\tstruct macsec_secy *secy;\n\n\tlist_for_each_entry(macsec, &rxd->secys, secys) {\n\t\tif (find_rx_sc_rtnl(&macsec->secy, sci))\n\t\t\treturn ERR_PTR(-EEXIST);\n\t}\n\n\trx_sc = kzalloc(sizeof(*rx_sc), GFP_KERNEL);\n\tif (!rx_sc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trx_sc->stats = netdev_alloc_pcpu_stats(struct pcpu_rx_sc_stats);\n\tif (!rx_sc->stats) {\n\t\tkfree(rx_sc);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\trx_sc->sci = sci;\n\trx_sc->active = active;\n\trefcount_set(&rx_sc->refcnt, 1);\n\n\tsecy = &macsec_priv(dev)->secy;\n\trcu_assign_pointer(rx_sc->next, secy->rx_sc);\n\trcu_assign_pointer(secy->rx_sc, rx_sc);\n\n\tif (rx_sc->active)\n\t\tsecy->n_rx_sc++;\n\n\treturn rx_sc;\n}\n\nstatic int init_tx_sa(struct macsec_tx_sa *tx_sa, char *sak, int key_len,\n\t\t      int icv_len)\n{\n\ttx_sa->stats = alloc_percpu(struct macsec_tx_sa_stats);\n\tif (!tx_sa->stats)\n\t\treturn -ENOMEM;\n\n\ttx_sa->key.tfm = macsec_alloc_tfm(sak, key_len, icv_len);\n\tif (IS_ERR(tx_sa->key.tfm)) {\n\t\tfree_percpu(tx_sa->stats);\n\t\treturn PTR_ERR(tx_sa->key.tfm);\n\t}\n\n\ttx_sa->ssci = MACSEC_UNDEF_SSCI;\n\ttx_sa->active = false;\n\trefcount_set(&tx_sa->refcnt, 1);\n\tspin_lock_init(&tx_sa->lock);\n\n\treturn 0;\n}\n\nstatic void clear_tx_sa(struct macsec_tx_sa *tx_sa)\n{\n\ttx_sa->active = false;\n\n\tmacsec_txsa_put(tx_sa);\n}\n\nstatic struct genl_family macsec_fam;\n\nstatic struct net_device *get_dev_from_nl(struct net *net,\n\t\t\t\t\t  struct nlattr **attrs)\n{\n\tint ifindex = nla_get_u32(attrs[MACSEC_ATTR_IFINDEX]);\n\tstruct net_device *dev;\n\n\tdev = __dev_get_by_index(net, ifindex);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tif (!netif_is_macsec(dev))\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn dev;\n}\n\nstatic enum macsec_offload nla_get_offload(const struct nlattr *nla)\n{\n\treturn (__force enum macsec_offload)nla_get_u8(nla);\n}\n\nstatic sci_t nla_get_sci(const struct nlattr *nla)\n{\n\treturn (__force sci_t)nla_get_u64(nla);\n}\n\nstatic int nla_put_sci(struct sk_buff *skb, int attrtype, sci_t value,\n\t\t       int padattr)\n{\n\treturn nla_put_u64_64bit(skb, attrtype, (__force u64)value, padattr);\n}\n\nstatic ssci_t nla_get_ssci(const struct nlattr *nla)\n{\n\treturn (__force ssci_t)nla_get_u32(nla);\n}\n\nstatic int nla_put_ssci(struct sk_buff *skb, int attrtype, ssci_t value)\n{\n\treturn nla_put_u32(skb, attrtype, (__force u64)value);\n}\n\nstatic struct macsec_tx_sa *get_txsa_from_nl(struct net *net,\n\t\t\t\t\t     struct nlattr **attrs,\n\t\t\t\t\t     struct nlattr **tb_sa,\n\t\t\t\t\t     struct net_device **devp,\n\t\t\t\t\t     struct macsec_secy **secyp,\n\t\t\t\t\t     struct macsec_tx_sc **scp,\n\t\t\t\t\t     u8 *assoc_num)\n{\n\tstruct net_device *dev;\n\tstruct macsec_secy *secy;\n\tstruct macsec_tx_sc *tx_sc;\n\tstruct macsec_tx_sa *tx_sa;\n\n\tif (!tb_sa[MACSEC_SA_ATTR_AN])\n\t\treturn ERR_PTR(-EINVAL);\n\n\t*assoc_num = nla_get_u8(tb_sa[MACSEC_SA_ATTR_AN]);\n\n\tdev = get_dev_from_nl(net, attrs);\n\tif (IS_ERR(dev))\n\t\treturn ERR_CAST(dev);\n\n\tif (*assoc_num >= MACSEC_NUM_AN)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tsecy = &macsec_priv(dev)->secy;\n\ttx_sc = &secy->tx_sc;\n\n\ttx_sa = rtnl_dereference(tx_sc->sa[*assoc_num]);\n\tif (!tx_sa)\n\t\treturn ERR_PTR(-ENODEV);\n\n\t*devp = dev;\n\t*scp = tx_sc;\n\t*secyp = secy;\n\treturn tx_sa;\n}\n\nstatic struct macsec_rx_sc *get_rxsc_from_nl(struct net *net,\n\t\t\t\t\t     struct nlattr **attrs,\n\t\t\t\t\t     struct nlattr **tb_rxsc,\n\t\t\t\t\t     struct net_device **devp,\n\t\t\t\t\t     struct macsec_secy **secyp)\n{\n\tstruct net_device *dev;\n\tstruct macsec_secy *secy;\n\tstruct macsec_rx_sc *rx_sc;\n\tsci_t sci;\n\n\tdev = get_dev_from_nl(net, attrs);\n\tif (IS_ERR(dev))\n\t\treturn ERR_CAST(dev);\n\n\tsecy = &macsec_priv(dev)->secy;\n\n\tif (!tb_rxsc[MACSEC_RXSC_ATTR_SCI])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tsci = nla_get_sci(tb_rxsc[MACSEC_RXSC_ATTR_SCI]);\n\trx_sc = find_rx_sc_rtnl(secy, sci);\n\tif (!rx_sc)\n\t\treturn ERR_PTR(-ENODEV);\n\n\t*secyp = secy;\n\t*devp = dev;\n\n\treturn rx_sc;\n}\n\nstatic struct macsec_rx_sa *get_rxsa_from_nl(struct net *net,\n\t\t\t\t\t     struct nlattr **attrs,\n\t\t\t\t\t     struct nlattr **tb_rxsc,\n\t\t\t\t\t     struct nlattr **tb_sa,\n\t\t\t\t\t     struct net_device **devp,\n\t\t\t\t\t     struct macsec_secy **secyp,\n\t\t\t\t\t     struct macsec_rx_sc **scp,\n\t\t\t\t\t     u8 *assoc_num)\n{\n\tstruct macsec_rx_sc *rx_sc;\n\tstruct macsec_rx_sa *rx_sa;\n\n\tif (!tb_sa[MACSEC_SA_ATTR_AN])\n\t\treturn ERR_PTR(-EINVAL);\n\n\t*assoc_num = nla_get_u8(tb_sa[MACSEC_SA_ATTR_AN]);\n\tif (*assoc_num >= MACSEC_NUM_AN)\n\t\treturn ERR_PTR(-EINVAL);\n\n\trx_sc = get_rxsc_from_nl(net, attrs, tb_rxsc, devp, secyp);\n\tif (IS_ERR(rx_sc))\n\t\treturn ERR_CAST(rx_sc);\n\n\trx_sa = rtnl_dereference(rx_sc->sa[*assoc_num]);\n\tif (!rx_sa)\n\t\treturn ERR_PTR(-ENODEV);\n\n\t*scp = rx_sc;\n\treturn rx_sa;\n}\n\nstatic const struct nla_policy macsec_genl_policy[NUM_MACSEC_ATTR] = {\n\t[MACSEC_ATTR_IFINDEX] = { .type = NLA_U32 },\n\t[MACSEC_ATTR_RXSC_CONFIG] = { .type = NLA_NESTED },\n\t[MACSEC_ATTR_SA_CONFIG] = { .type = NLA_NESTED },\n\t[MACSEC_ATTR_OFFLOAD] = { .type = NLA_NESTED },\n};\n\nstatic const struct nla_policy macsec_genl_rxsc_policy[NUM_MACSEC_RXSC_ATTR] = {\n\t[MACSEC_RXSC_ATTR_SCI] = { .type = NLA_U64 },\n\t[MACSEC_RXSC_ATTR_ACTIVE] = { .type = NLA_U8 },\n};\n\nstatic const struct nla_policy macsec_genl_sa_policy[NUM_MACSEC_SA_ATTR] = {\n\t[MACSEC_SA_ATTR_AN] = { .type = NLA_U8 },\n\t[MACSEC_SA_ATTR_ACTIVE] = { .type = NLA_U8 },\n\t[MACSEC_SA_ATTR_PN] = NLA_POLICY_MIN_LEN(4),\n\t[MACSEC_SA_ATTR_KEYID] = { .type = NLA_BINARY,\n\t\t\t\t   .len = MACSEC_KEYID_LEN, },\n\t[MACSEC_SA_ATTR_KEY] = { .type = NLA_BINARY,\n\t\t\t\t .len = MACSEC_MAX_KEY_LEN, },\n\t[MACSEC_SA_ATTR_SSCI] = { .type = NLA_U32 },\n\t[MACSEC_SA_ATTR_SALT] = { .type = NLA_BINARY,\n\t\t\t\t  .len = MACSEC_SALT_LEN, },\n};\n\nstatic const struct nla_policy macsec_genl_offload_policy[NUM_MACSEC_OFFLOAD_ATTR] = {\n\t[MACSEC_OFFLOAD_ATTR_TYPE] = { .type = NLA_U8 },\n};\n\n \nstatic int macsec_offload(int (* const func)(struct macsec_context *),\n\t\t\t  struct macsec_context *ctx)\n{\n\tint ret;\n\n\tif (unlikely(!func))\n\t\treturn 0;\n\n\tif (ctx->offload == MACSEC_OFFLOAD_PHY)\n\t\tmutex_lock(&ctx->phydev->lock);\n\n\tret = (*func)(ctx);\n\n\tif (ctx->offload == MACSEC_OFFLOAD_PHY)\n\t\tmutex_unlock(&ctx->phydev->lock);\n\n\treturn ret;\n}\n\nstatic int parse_sa_config(struct nlattr **attrs, struct nlattr **tb_sa)\n{\n\tif (!attrs[MACSEC_ATTR_SA_CONFIG])\n\t\treturn -EINVAL;\n\n\tif (nla_parse_nested_deprecated(tb_sa, MACSEC_SA_ATTR_MAX, attrs[MACSEC_ATTR_SA_CONFIG], macsec_genl_sa_policy, NULL))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int parse_rxsc_config(struct nlattr **attrs, struct nlattr **tb_rxsc)\n{\n\tif (!attrs[MACSEC_ATTR_RXSC_CONFIG])\n\t\treturn -EINVAL;\n\n\tif (nla_parse_nested_deprecated(tb_rxsc, MACSEC_RXSC_ATTR_MAX, attrs[MACSEC_ATTR_RXSC_CONFIG], macsec_genl_rxsc_policy, NULL))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic bool validate_add_rxsa(struct nlattr **attrs)\n{\n\tif (!attrs[MACSEC_SA_ATTR_AN] ||\n\t    !attrs[MACSEC_SA_ATTR_KEY] ||\n\t    !attrs[MACSEC_SA_ATTR_KEYID])\n\t\treturn false;\n\n\tif (nla_get_u8(attrs[MACSEC_SA_ATTR_AN]) >= MACSEC_NUM_AN)\n\t\treturn false;\n\n\tif (attrs[MACSEC_SA_ATTR_PN] &&\n\t    nla_get_u64(attrs[MACSEC_SA_ATTR_PN]) == 0)\n\t\treturn false;\n\n\tif (attrs[MACSEC_SA_ATTR_ACTIVE]) {\n\t\tif (nla_get_u8(attrs[MACSEC_SA_ATTR_ACTIVE]) > 1)\n\t\t\treturn false;\n\t}\n\n\tif (nla_len(attrs[MACSEC_SA_ATTR_KEYID]) != MACSEC_KEYID_LEN)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int macsec_add_rxsa(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct net_device *dev;\n\tstruct nlattr **attrs = info->attrs;\n\tstruct macsec_secy *secy;\n\tstruct macsec_rx_sc *rx_sc;\n\tstruct macsec_rx_sa *rx_sa;\n\tunsigned char assoc_num;\n\tint pn_len;\n\tstruct nlattr *tb_rxsc[MACSEC_RXSC_ATTR_MAX + 1];\n\tstruct nlattr *tb_sa[MACSEC_SA_ATTR_MAX + 1];\n\tint err;\n\n\tif (!attrs[MACSEC_ATTR_IFINDEX])\n\t\treturn -EINVAL;\n\n\tif (parse_sa_config(attrs, tb_sa))\n\t\treturn -EINVAL;\n\n\tif (parse_rxsc_config(attrs, tb_rxsc))\n\t\treturn -EINVAL;\n\n\tif (!validate_add_rxsa(tb_sa))\n\t\treturn -EINVAL;\n\n\trtnl_lock();\n\trx_sc = get_rxsc_from_nl(genl_info_net(info), attrs, tb_rxsc, &dev, &secy);\n\tif (IS_ERR(rx_sc)) {\n\t\trtnl_unlock();\n\t\treturn PTR_ERR(rx_sc);\n\t}\n\n\tassoc_num = nla_get_u8(tb_sa[MACSEC_SA_ATTR_AN]);\n\n\tif (nla_len(tb_sa[MACSEC_SA_ATTR_KEY]) != secy->key_len) {\n\t\tpr_notice(\"macsec: nl: add_rxsa: bad key length: %d != %d\\n\",\n\t\t\t  nla_len(tb_sa[MACSEC_SA_ATTR_KEY]), secy->key_len);\n\t\trtnl_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\tpn_len = secy->xpn ? MACSEC_XPN_PN_LEN : MACSEC_DEFAULT_PN_LEN;\n\tif (tb_sa[MACSEC_SA_ATTR_PN] &&\n\t    nla_len(tb_sa[MACSEC_SA_ATTR_PN]) != pn_len) {\n\t\tpr_notice(\"macsec: nl: add_rxsa: bad pn length: %d != %d\\n\",\n\t\t\t  nla_len(tb_sa[MACSEC_SA_ATTR_PN]), pn_len);\n\t\trtnl_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\tif (secy->xpn) {\n\t\tif (!tb_sa[MACSEC_SA_ATTR_SSCI] || !tb_sa[MACSEC_SA_ATTR_SALT]) {\n\t\t\trtnl_unlock();\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (nla_len(tb_sa[MACSEC_SA_ATTR_SALT]) != MACSEC_SALT_LEN) {\n\t\t\tpr_notice(\"macsec: nl: add_rxsa: bad salt length: %d != %d\\n\",\n\t\t\t\t  nla_len(tb_sa[MACSEC_SA_ATTR_SALT]),\n\t\t\t\t  MACSEC_SALT_LEN);\n\t\t\trtnl_unlock();\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\trx_sa = rtnl_dereference(rx_sc->sa[assoc_num]);\n\tif (rx_sa) {\n\t\trtnl_unlock();\n\t\treturn -EBUSY;\n\t}\n\n\trx_sa = kmalloc(sizeof(*rx_sa), GFP_KERNEL);\n\tif (!rx_sa) {\n\t\trtnl_unlock();\n\t\treturn -ENOMEM;\n\t}\n\n\terr = init_rx_sa(rx_sa, nla_data(tb_sa[MACSEC_SA_ATTR_KEY]),\n\t\t\t secy->key_len, secy->icv_len);\n\tif (err < 0) {\n\t\tkfree(rx_sa);\n\t\trtnl_unlock();\n\t\treturn err;\n\t}\n\n\tif (tb_sa[MACSEC_SA_ATTR_PN]) {\n\t\tspin_lock_bh(&rx_sa->lock);\n\t\trx_sa->next_pn = nla_get_u64(tb_sa[MACSEC_SA_ATTR_PN]);\n\t\tspin_unlock_bh(&rx_sa->lock);\n\t}\n\n\tif (tb_sa[MACSEC_SA_ATTR_ACTIVE])\n\t\trx_sa->active = !!nla_get_u8(tb_sa[MACSEC_SA_ATTR_ACTIVE]);\n\n\trx_sa->sc = rx_sc;\n\n\tif (secy->xpn) {\n\t\trx_sa->ssci = nla_get_ssci(tb_sa[MACSEC_SA_ATTR_SSCI]);\n\t\tnla_memcpy(rx_sa->key.salt.bytes, tb_sa[MACSEC_SA_ATTR_SALT],\n\t\t\t   MACSEC_SALT_LEN);\n\t}\n\n\t \n\tif (macsec_is_offloaded(netdev_priv(dev))) {\n\t\tconst struct macsec_ops *ops;\n\t\tstruct macsec_context ctx;\n\n\t\tops = macsec_get_ops(netdev_priv(dev), &ctx);\n\t\tif (!ops) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tctx.sa.assoc_num = assoc_num;\n\t\tctx.sa.rx_sa = rx_sa;\n\t\tctx.secy = secy;\n\t\tmemcpy(ctx.sa.key, nla_data(tb_sa[MACSEC_SA_ATTR_KEY]),\n\t\t       secy->key_len);\n\n\t\terr = macsec_offload(ops->mdo_add_rxsa, &ctx);\n\t\tmemzero_explicit(ctx.sa.key, secy->key_len);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t}\n\n\tnla_memcpy(rx_sa->key.id, tb_sa[MACSEC_SA_ATTR_KEYID], MACSEC_KEYID_LEN);\n\trcu_assign_pointer(rx_sc->sa[assoc_num], rx_sa);\n\n\trtnl_unlock();\n\n\treturn 0;\n\ncleanup:\n\tmacsec_rxsa_put(rx_sa);\n\trtnl_unlock();\n\treturn err;\n}\n\nstatic bool validate_add_rxsc(struct nlattr **attrs)\n{\n\tif (!attrs[MACSEC_RXSC_ATTR_SCI])\n\t\treturn false;\n\n\tif (attrs[MACSEC_RXSC_ATTR_ACTIVE]) {\n\t\tif (nla_get_u8(attrs[MACSEC_RXSC_ATTR_ACTIVE]) > 1)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int macsec_add_rxsc(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct net_device *dev;\n\tsci_t sci = MACSEC_UNDEF_SCI;\n\tstruct nlattr **attrs = info->attrs;\n\tstruct macsec_rx_sc *rx_sc;\n\tstruct nlattr *tb_rxsc[MACSEC_RXSC_ATTR_MAX + 1];\n\tstruct macsec_secy *secy;\n\tbool active = true;\n\tint ret;\n\n\tif (!attrs[MACSEC_ATTR_IFINDEX])\n\t\treturn -EINVAL;\n\n\tif (parse_rxsc_config(attrs, tb_rxsc))\n\t\treturn -EINVAL;\n\n\tif (!validate_add_rxsc(tb_rxsc))\n\t\treturn -EINVAL;\n\n\trtnl_lock();\n\tdev = get_dev_from_nl(genl_info_net(info), attrs);\n\tif (IS_ERR(dev)) {\n\t\trtnl_unlock();\n\t\treturn PTR_ERR(dev);\n\t}\n\n\tsecy = &macsec_priv(dev)->secy;\n\tsci = nla_get_sci(tb_rxsc[MACSEC_RXSC_ATTR_SCI]);\n\n\tif (tb_rxsc[MACSEC_RXSC_ATTR_ACTIVE])\n\t\tactive = nla_get_u8(tb_rxsc[MACSEC_RXSC_ATTR_ACTIVE]);\n\n\trx_sc = create_rx_sc(dev, sci, active);\n\tif (IS_ERR(rx_sc)) {\n\t\trtnl_unlock();\n\t\treturn PTR_ERR(rx_sc);\n\t}\n\n\tif (macsec_is_offloaded(netdev_priv(dev))) {\n\t\tconst struct macsec_ops *ops;\n\t\tstruct macsec_context ctx;\n\n\t\tops = macsec_get_ops(netdev_priv(dev), &ctx);\n\t\tif (!ops) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tctx.rx_sc = rx_sc;\n\t\tctx.secy = secy;\n\n\t\tret = macsec_offload(ops->mdo_add_rxsc, &ctx);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\trtnl_unlock();\n\n\treturn 0;\n\ncleanup:\n\tdel_rx_sc(secy, sci);\n\tfree_rx_sc(rx_sc);\n\trtnl_unlock();\n\treturn ret;\n}\n\nstatic bool validate_add_txsa(struct nlattr **attrs)\n{\n\tif (!attrs[MACSEC_SA_ATTR_AN] ||\n\t    !attrs[MACSEC_SA_ATTR_PN] ||\n\t    !attrs[MACSEC_SA_ATTR_KEY] ||\n\t    !attrs[MACSEC_SA_ATTR_KEYID])\n\t\treturn false;\n\n\tif (nla_get_u8(attrs[MACSEC_SA_ATTR_AN]) >= MACSEC_NUM_AN)\n\t\treturn false;\n\n\tif (nla_get_u64(attrs[MACSEC_SA_ATTR_PN]) == 0)\n\t\treturn false;\n\n\tif (attrs[MACSEC_SA_ATTR_ACTIVE]) {\n\t\tif (nla_get_u8(attrs[MACSEC_SA_ATTR_ACTIVE]) > 1)\n\t\t\treturn false;\n\t}\n\n\tif (nla_len(attrs[MACSEC_SA_ATTR_KEYID]) != MACSEC_KEYID_LEN)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int macsec_add_txsa(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct net_device *dev;\n\tstruct nlattr **attrs = info->attrs;\n\tstruct macsec_secy *secy;\n\tstruct macsec_tx_sc *tx_sc;\n\tstruct macsec_tx_sa *tx_sa;\n\tunsigned char assoc_num;\n\tint pn_len;\n\tstruct nlattr *tb_sa[MACSEC_SA_ATTR_MAX + 1];\n\tbool was_operational;\n\tint err;\n\n\tif (!attrs[MACSEC_ATTR_IFINDEX])\n\t\treturn -EINVAL;\n\n\tif (parse_sa_config(attrs, tb_sa))\n\t\treturn -EINVAL;\n\n\tif (!validate_add_txsa(tb_sa))\n\t\treturn -EINVAL;\n\n\trtnl_lock();\n\tdev = get_dev_from_nl(genl_info_net(info), attrs);\n\tif (IS_ERR(dev)) {\n\t\trtnl_unlock();\n\t\treturn PTR_ERR(dev);\n\t}\n\n\tsecy = &macsec_priv(dev)->secy;\n\ttx_sc = &secy->tx_sc;\n\n\tassoc_num = nla_get_u8(tb_sa[MACSEC_SA_ATTR_AN]);\n\n\tif (nla_len(tb_sa[MACSEC_SA_ATTR_KEY]) != secy->key_len) {\n\t\tpr_notice(\"macsec: nl: add_txsa: bad key length: %d != %d\\n\",\n\t\t\t  nla_len(tb_sa[MACSEC_SA_ATTR_KEY]), secy->key_len);\n\t\trtnl_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\tpn_len = secy->xpn ? MACSEC_XPN_PN_LEN : MACSEC_DEFAULT_PN_LEN;\n\tif (nla_len(tb_sa[MACSEC_SA_ATTR_PN]) != pn_len) {\n\t\tpr_notice(\"macsec: nl: add_txsa: bad pn length: %d != %d\\n\",\n\t\t\t  nla_len(tb_sa[MACSEC_SA_ATTR_PN]), pn_len);\n\t\trtnl_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\tif (secy->xpn) {\n\t\tif (!tb_sa[MACSEC_SA_ATTR_SSCI] || !tb_sa[MACSEC_SA_ATTR_SALT]) {\n\t\t\trtnl_unlock();\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (nla_len(tb_sa[MACSEC_SA_ATTR_SALT]) != MACSEC_SALT_LEN) {\n\t\t\tpr_notice(\"macsec: nl: add_txsa: bad salt length: %d != %d\\n\",\n\t\t\t\t  nla_len(tb_sa[MACSEC_SA_ATTR_SALT]),\n\t\t\t\t  MACSEC_SALT_LEN);\n\t\t\trtnl_unlock();\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\ttx_sa = rtnl_dereference(tx_sc->sa[assoc_num]);\n\tif (tx_sa) {\n\t\trtnl_unlock();\n\t\treturn -EBUSY;\n\t}\n\n\ttx_sa = kmalloc(sizeof(*tx_sa), GFP_KERNEL);\n\tif (!tx_sa) {\n\t\trtnl_unlock();\n\t\treturn -ENOMEM;\n\t}\n\n\terr = init_tx_sa(tx_sa, nla_data(tb_sa[MACSEC_SA_ATTR_KEY]),\n\t\t\t secy->key_len, secy->icv_len);\n\tif (err < 0) {\n\t\tkfree(tx_sa);\n\t\trtnl_unlock();\n\t\treturn err;\n\t}\n\n\tspin_lock_bh(&tx_sa->lock);\n\ttx_sa->next_pn = nla_get_u64(tb_sa[MACSEC_SA_ATTR_PN]);\n\tspin_unlock_bh(&tx_sa->lock);\n\n\tif (tb_sa[MACSEC_SA_ATTR_ACTIVE])\n\t\ttx_sa->active = !!nla_get_u8(tb_sa[MACSEC_SA_ATTR_ACTIVE]);\n\n\twas_operational = secy->operational;\n\tif (assoc_num == tx_sc->encoding_sa && tx_sa->active)\n\t\tsecy->operational = true;\n\n\tif (secy->xpn) {\n\t\ttx_sa->ssci = nla_get_ssci(tb_sa[MACSEC_SA_ATTR_SSCI]);\n\t\tnla_memcpy(tx_sa->key.salt.bytes, tb_sa[MACSEC_SA_ATTR_SALT],\n\t\t\t   MACSEC_SALT_LEN);\n\t}\n\n\t \n\tif (macsec_is_offloaded(netdev_priv(dev))) {\n\t\tconst struct macsec_ops *ops;\n\t\tstruct macsec_context ctx;\n\n\t\tops = macsec_get_ops(netdev_priv(dev), &ctx);\n\t\tif (!ops) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tctx.sa.assoc_num = assoc_num;\n\t\tctx.sa.tx_sa = tx_sa;\n\t\tctx.secy = secy;\n\t\tmemcpy(ctx.sa.key, nla_data(tb_sa[MACSEC_SA_ATTR_KEY]),\n\t\t       secy->key_len);\n\n\t\terr = macsec_offload(ops->mdo_add_txsa, &ctx);\n\t\tmemzero_explicit(ctx.sa.key, secy->key_len);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t}\n\n\tnla_memcpy(tx_sa->key.id, tb_sa[MACSEC_SA_ATTR_KEYID], MACSEC_KEYID_LEN);\n\trcu_assign_pointer(tx_sc->sa[assoc_num], tx_sa);\n\n\trtnl_unlock();\n\n\treturn 0;\n\ncleanup:\n\tsecy->operational = was_operational;\n\tmacsec_txsa_put(tx_sa);\n\trtnl_unlock();\n\treturn err;\n}\n\nstatic int macsec_del_rxsa(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr **attrs = info->attrs;\n\tstruct net_device *dev;\n\tstruct macsec_secy *secy;\n\tstruct macsec_rx_sc *rx_sc;\n\tstruct macsec_rx_sa *rx_sa;\n\tu8 assoc_num;\n\tstruct nlattr *tb_rxsc[MACSEC_RXSC_ATTR_MAX + 1];\n\tstruct nlattr *tb_sa[MACSEC_SA_ATTR_MAX + 1];\n\tint ret;\n\n\tif (!attrs[MACSEC_ATTR_IFINDEX])\n\t\treturn -EINVAL;\n\n\tif (parse_sa_config(attrs, tb_sa))\n\t\treturn -EINVAL;\n\n\tif (parse_rxsc_config(attrs, tb_rxsc))\n\t\treturn -EINVAL;\n\n\trtnl_lock();\n\trx_sa = get_rxsa_from_nl(genl_info_net(info), attrs, tb_rxsc, tb_sa,\n\t\t\t\t &dev, &secy, &rx_sc, &assoc_num);\n\tif (IS_ERR(rx_sa)) {\n\t\trtnl_unlock();\n\t\treturn PTR_ERR(rx_sa);\n\t}\n\n\tif (rx_sa->active) {\n\t\trtnl_unlock();\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (macsec_is_offloaded(netdev_priv(dev))) {\n\t\tconst struct macsec_ops *ops;\n\t\tstruct macsec_context ctx;\n\n\t\tops = macsec_get_ops(netdev_priv(dev), &ctx);\n\t\tif (!ops) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tctx.sa.assoc_num = assoc_num;\n\t\tctx.sa.rx_sa = rx_sa;\n\t\tctx.secy = secy;\n\n\t\tret = macsec_offload(ops->mdo_del_rxsa, &ctx);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tRCU_INIT_POINTER(rx_sc->sa[assoc_num], NULL);\n\tclear_rx_sa(rx_sa);\n\n\trtnl_unlock();\n\n\treturn 0;\n\ncleanup:\n\trtnl_unlock();\n\treturn ret;\n}\n\nstatic int macsec_del_rxsc(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr **attrs = info->attrs;\n\tstruct net_device *dev;\n\tstruct macsec_secy *secy;\n\tstruct macsec_rx_sc *rx_sc;\n\tsci_t sci;\n\tstruct nlattr *tb_rxsc[MACSEC_RXSC_ATTR_MAX + 1];\n\tint ret;\n\n\tif (!attrs[MACSEC_ATTR_IFINDEX])\n\t\treturn -EINVAL;\n\n\tif (parse_rxsc_config(attrs, tb_rxsc))\n\t\treturn -EINVAL;\n\n\tif (!tb_rxsc[MACSEC_RXSC_ATTR_SCI])\n\t\treturn -EINVAL;\n\n\trtnl_lock();\n\tdev = get_dev_from_nl(genl_info_net(info), info->attrs);\n\tif (IS_ERR(dev)) {\n\t\trtnl_unlock();\n\t\treturn PTR_ERR(dev);\n\t}\n\n\tsecy = &macsec_priv(dev)->secy;\n\tsci = nla_get_sci(tb_rxsc[MACSEC_RXSC_ATTR_SCI]);\n\n\trx_sc = del_rx_sc(secy, sci);\n\tif (!rx_sc) {\n\t\trtnl_unlock();\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (macsec_is_offloaded(netdev_priv(dev))) {\n\t\tconst struct macsec_ops *ops;\n\t\tstruct macsec_context ctx;\n\n\t\tops = macsec_get_ops(netdev_priv(dev), &ctx);\n\t\tif (!ops) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tctx.rx_sc = rx_sc;\n\t\tctx.secy = secy;\n\t\tret = macsec_offload(ops->mdo_del_rxsc, &ctx);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tfree_rx_sc(rx_sc);\n\trtnl_unlock();\n\n\treturn 0;\n\ncleanup:\n\trtnl_unlock();\n\treturn ret;\n}\n\nstatic int macsec_del_txsa(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr **attrs = info->attrs;\n\tstruct net_device *dev;\n\tstruct macsec_secy *secy;\n\tstruct macsec_tx_sc *tx_sc;\n\tstruct macsec_tx_sa *tx_sa;\n\tu8 assoc_num;\n\tstruct nlattr *tb_sa[MACSEC_SA_ATTR_MAX + 1];\n\tint ret;\n\n\tif (!attrs[MACSEC_ATTR_IFINDEX])\n\t\treturn -EINVAL;\n\n\tif (parse_sa_config(attrs, tb_sa))\n\t\treturn -EINVAL;\n\n\trtnl_lock();\n\ttx_sa = get_txsa_from_nl(genl_info_net(info), attrs, tb_sa,\n\t\t\t\t &dev, &secy, &tx_sc, &assoc_num);\n\tif (IS_ERR(tx_sa)) {\n\t\trtnl_unlock();\n\t\treturn PTR_ERR(tx_sa);\n\t}\n\n\tif (tx_sa->active) {\n\t\trtnl_unlock();\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tif (macsec_is_offloaded(netdev_priv(dev))) {\n\t\tconst struct macsec_ops *ops;\n\t\tstruct macsec_context ctx;\n\n\t\tops = macsec_get_ops(netdev_priv(dev), &ctx);\n\t\tif (!ops) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tctx.sa.assoc_num = assoc_num;\n\t\tctx.sa.tx_sa = tx_sa;\n\t\tctx.secy = secy;\n\n\t\tret = macsec_offload(ops->mdo_del_txsa, &ctx);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\tRCU_INIT_POINTER(tx_sc->sa[assoc_num], NULL);\n\tclear_tx_sa(tx_sa);\n\n\trtnl_unlock();\n\n\treturn 0;\n\ncleanup:\n\trtnl_unlock();\n\treturn ret;\n}\n\nstatic bool validate_upd_sa(struct nlattr **attrs)\n{\n\tif (!attrs[MACSEC_SA_ATTR_AN] ||\n\t    attrs[MACSEC_SA_ATTR_KEY] ||\n\t    attrs[MACSEC_SA_ATTR_KEYID] ||\n\t    attrs[MACSEC_SA_ATTR_SSCI] ||\n\t    attrs[MACSEC_SA_ATTR_SALT])\n\t\treturn false;\n\n\tif (nla_get_u8(attrs[MACSEC_SA_ATTR_AN]) >= MACSEC_NUM_AN)\n\t\treturn false;\n\n\tif (attrs[MACSEC_SA_ATTR_PN] && nla_get_u64(attrs[MACSEC_SA_ATTR_PN]) == 0)\n\t\treturn false;\n\n\tif (attrs[MACSEC_SA_ATTR_ACTIVE]) {\n\t\tif (nla_get_u8(attrs[MACSEC_SA_ATTR_ACTIVE]) > 1)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int macsec_upd_txsa(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr **attrs = info->attrs;\n\tstruct net_device *dev;\n\tstruct macsec_secy *secy;\n\tstruct macsec_tx_sc *tx_sc;\n\tstruct macsec_tx_sa *tx_sa;\n\tu8 assoc_num;\n\tstruct nlattr *tb_sa[MACSEC_SA_ATTR_MAX + 1];\n\tbool was_operational, was_active;\n\tpn_t prev_pn;\n\tint ret = 0;\n\n\tprev_pn.full64 = 0;\n\n\tif (!attrs[MACSEC_ATTR_IFINDEX])\n\t\treturn -EINVAL;\n\n\tif (parse_sa_config(attrs, tb_sa))\n\t\treturn -EINVAL;\n\n\tif (!validate_upd_sa(tb_sa))\n\t\treturn -EINVAL;\n\n\trtnl_lock();\n\ttx_sa = get_txsa_from_nl(genl_info_net(info), attrs, tb_sa,\n\t\t\t\t &dev, &secy, &tx_sc, &assoc_num);\n\tif (IS_ERR(tx_sa)) {\n\t\trtnl_unlock();\n\t\treturn PTR_ERR(tx_sa);\n\t}\n\n\tif (tb_sa[MACSEC_SA_ATTR_PN]) {\n\t\tint pn_len;\n\n\t\tpn_len = secy->xpn ? MACSEC_XPN_PN_LEN : MACSEC_DEFAULT_PN_LEN;\n\t\tif (nla_len(tb_sa[MACSEC_SA_ATTR_PN]) != pn_len) {\n\t\t\tpr_notice(\"macsec: nl: upd_txsa: bad pn length: %d != %d\\n\",\n\t\t\t\t  nla_len(tb_sa[MACSEC_SA_ATTR_PN]), pn_len);\n\t\t\trtnl_unlock();\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tspin_lock_bh(&tx_sa->lock);\n\t\tprev_pn = tx_sa->next_pn_halves;\n\t\ttx_sa->next_pn = nla_get_u64(tb_sa[MACSEC_SA_ATTR_PN]);\n\t\tspin_unlock_bh(&tx_sa->lock);\n\t}\n\n\twas_active = tx_sa->active;\n\tif (tb_sa[MACSEC_SA_ATTR_ACTIVE])\n\t\ttx_sa->active = nla_get_u8(tb_sa[MACSEC_SA_ATTR_ACTIVE]);\n\n\twas_operational = secy->operational;\n\tif (assoc_num == tx_sc->encoding_sa)\n\t\tsecy->operational = tx_sa->active;\n\n\t \n\tif (macsec_is_offloaded(netdev_priv(dev))) {\n\t\tconst struct macsec_ops *ops;\n\t\tstruct macsec_context ctx;\n\n\t\tops = macsec_get_ops(netdev_priv(dev), &ctx);\n\t\tif (!ops) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tctx.sa.assoc_num = assoc_num;\n\t\tctx.sa.tx_sa = tx_sa;\n\t\tctx.sa.update_pn = !!prev_pn.full64;\n\t\tctx.secy = secy;\n\n\t\tret = macsec_offload(ops->mdo_upd_txsa, &ctx);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\trtnl_unlock();\n\n\treturn 0;\n\ncleanup:\n\tif (tb_sa[MACSEC_SA_ATTR_PN]) {\n\t\tspin_lock_bh(&tx_sa->lock);\n\t\ttx_sa->next_pn_halves = prev_pn;\n\t\tspin_unlock_bh(&tx_sa->lock);\n\t}\n\ttx_sa->active = was_active;\n\tsecy->operational = was_operational;\n\trtnl_unlock();\n\treturn ret;\n}\n\nstatic int macsec_upd_rxsa(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr **attrs = info->attrs;\n\tstruct net_device *dev;\n\tstruct macsec_secy *secy;\n\tstruct macsec_rx_sc *rx_sc;\n\tstruct macsec_rx_sa *rx_sa;\n\tu8 assoc_num;\n\tstruct nlattr *tb_rxsc[MACSEC_RXSC_ATTR_MAX + 1];\n\tstruct nlattr *tb_sa[MACSEC_SA_ATTR_MAX + 1];\n\tbool was_active;\n\tpn_t prev_pn;\n\tint ret = 0;\n\n\tprev_pn.full64 = 0;\n\n\tif (!attrs[MACSEC_ATTR_IFINDEX])\n\t\treturn -EINVAL;\n\n\tif (parse_rxsc_config(attrs, tb_rxsc))\n\t\treturn -EINVAL;\n\n\tif (parse_sa_config(attrs, tb_sa))\n\t\treturn -EINVAL;\n\n\tif (!validate_upd_sa(tb_sa))\n\t\treturn -EINVAL;\n\n\trtnl_lock();\n\trx_sa = get_rxsa_from_nl(genl_info_net(info), attrs, tb_rxsc, tb_sa,\n\t\t\t\t &dev, &secy, &rx_sc, &assoc_num);\n\tif (IS_ERR(rx_sa)) {\n\t\trtnl_unlock();\n\t\treturn PTR_ERR(rx_sa);\n\t}\n\n\tif (tb_sa[MACSEC_SA_ATTR_PN]) {\n\t\tint pn_len;\n\n\t\tpn_len = secy->xpn ? MACSEC_XPN_PN_LEN : MACSEC_DEFAULT_PN_LEN;\n\t\tif (nla_len(tb_sa[MACSEC_SA_ATTR_PN]) != pn_len) {\n\t\t\tpr_notice(\"macsec: nl: upd_rxsa: bad pn length: %d != %d\\n\",\n\t\t\t\t  nla_len(tb_sa[MACSEC_SA_ATTR_PN]), pn_len);\n\t\t\trtnl_unlock();\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tspin_lock_bh(&rx_sa->lock);\n\t\tprev_pn = rx_sa->next_pn_halves;\n\t\trx_sa->next_pn = nla_get_u64(tb_sa[MACSEC_SA_ATTR_PN]);\n\t\tspin_unlock_bh(&rx_sa->lock);\n\t}\n\n\twas_active = rx_sa->active;\n\tif (tb_sa[MACSEC_SA_ATTR_ACTIVE])\n\t\trx_sa->active = nla_get_u8(tb_sa[MACSEC_SA_ATTR_ACTIVE]);\n\n\t \n\tif (macsec_is_offloaded(netdev_priv(dev))) {\n\t\tconst struct macsec_ops *ops;\n\t\tstruct macsec_context ctx;\n\n\t\tops = macsec_get_ops(netdev_priv(dev), &ctx);\n\t\tif (!ops) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tctx.sa.assoc_num = assoc_num;\n\t\tctx.sa.rx_sa = rx_sa;\n\t\tctx.sa.update_pn = !!prev_pn.full64;\n\t\tctx.secy = secy;\n\n\t\tret = macsec_offload(ops->mdo_upd_rxsa, &ctx);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\trtnl_unlock();\n\treturn 0;\n\ncleanup:\n\tif (tb_sa[MACSEC_SA_ATTR_PN]) {\n\t\tspin_lock_bh(&rx_sa->lock);\n\t\trx_sa->next_pn_halves = prev_pn;\n\t\tspin_unlock_bh(&rx_sa->lock);\n\t}\n\trx_sa->active = was_active;\n\trtnl_unlock();\n\treturn ret;\n}\n\nstatic int macsec_upd_rxsc(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr **attrs = info->attrs;\n\tstruct net_device *dev;\n\tstruct macsec_secy *secy;\n\tstruct macsec_rx_sc *rx_sc;\n\tstruct nlattr *tb_rxsc[MACSEC_RXSC_ATTR_MAX + 1];\n\tunsigned int prev_n_rx_sc;\n\tbool was_active;\n\tint ret;\n\n\tif (!attrs[MACSEC_ATTR_IFINDEX])\n\t\treturn -EINVAL;\n\n\tif (parse_rxsc_config(attrs, tb_rxsc))\n\t\treturn -EINVAL;\n\n\tif (!validate_add_rxsc(tb_rxsc))\n\t\treturn -EINVAL;\n\n\trtnl_lock();\n\trx_sc = get_rxsc_from_nl(genl_info_net(info), attrs, tb_rxsc, &dev, &secy);\n\tif (IS_ERR(rx_sc)) {\n\t\trtnl_unlock();\n\t\treturn PTR_ERR(rx_sc);\n\t}\n\n\twas_active = rx_sc->active;\n\tprev_n_rx_sc = secy->n_rx_sc;\n\tif (tb_rxsc[MACSEC_RXSC_ATTR_ACTIVE]) {\n\t\tbool new = !!nla_get_u8(tb_rxsc[MACSEC_RXSC_ATTR_ACTIVE]);\n\n\t\tif (rx_sc->active != new)\n\t\t\tsecy->n_rx_sc += new ? 1 : -1;\n\n\t\trx_sc->active = new;\n\t}\n\n\t \n\tif (macsec_is_offloaded(netdev_priv(dev))) {\n\t\tconst struct macsec_ops *ops;\n\t\tstruct macsec_context ctx;\n\n\t\tops = macsec_get_ops(netdev_priv(dev), &ctx);\n\t\tif (!ops) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tctx.rx_sc = rx_sc;\n\t\tctx.secy = secy;\n\n\t\tret = macsec_offload(ops->mdo_upd_rxsc, &ctx);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\trtnl_unlock();\n\n\treturn 0;\n\ncleanup:\n\tsecy->n_rx_sc = prev_n_rx_sc;\n\trx_sc->active = was_active;\n\trtnl_unlock();\n\treturn ret;\n}\n\nstatic bool macsec_is_configured(struct macsec_dev *macsec)\n{\n\tstruct macsec_secy *secy = &macsec->secy;\n\tstruct macsec_tx_sc *tx_sc = &secy->tx_sc;\n\tint i;\n\n\tif (secy->rx_sc)\n\t\treturn true;\n\n\tfor (i = 0; i < MACSEC_NUM_AN; i++)\n\t\tif (tx_sc->sa[i])\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic int macsec_update_offload(struct net_device *dev, enum macsec_offload offload)\n{\n\tenum macsec_offload prev_offload;\n\tconst struct macsec_ops *ops;\n\tstruct macsec_context ctx;\n\tstruct macsec_dev *macsec;\n\tint ret = 0;\n\n\tmacsec = macsec_priv(dev);\n\n\t \n\tif (offload != MACSEC_OFFLOAD_OFF &&\n\t    !macsec_check_offload(offload, macsec))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (netif_running(dev))\n\t\treturn -EBUSY;\n\n\t \n\tif (macsec_is_configured(macsec))\n\t\treturn -EBUSY;\n\n\tprev_offload = macsec->offload;\n\n\tops = __macsec_get_ops(offload == MACSEC_OFFLOAD_OFF ? prev_offload : offload,\n\t\t\t       macsec, &ctx);\n\tif (!ops)\n\t\treturn -EOPNOTSUPP;\n\n\tmacsec->offload = offload;\n\n\tctx.secy = &macsec->secy;\n\tret = offload == MACSEC_OFFLOAD_OFF ? macsec_offload(ops->mdo_del_secy, &ctx)\n\t\t\t\t\t    : macsec_offload(ops->mdo_add_secy, &ctx);\n\tif (ret)\n\t\tmacsec->offload = prev_offload;\n\n\treturn ret;\n}\n\nstatic int macsec_upd_offload(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nlattr *tb_offload[MACSEC_OFFLOAD_ATTR_MAX + 1];\n\tstruct nlattr **attrs = info->attrs;\n\tenum macsec_offload offload;\n\tstruct macsec_dev *macsec;\n\tstruct net_device *dev;\n\tint ret = 0;\n\n\tif (!attrs[MACSEC_ATTR_IFINDEX])\n\t\treturn -EINVAL;\n\n\tif (!attrs[MACSEC_ATTR_OFFLOAD])\n\t\treturn -EINVAL;\n\n\tif (nla_parse_nested_deprecated(tb_offload, MACSEC_OFFLOAD_ATTR_MAX,\n\t\t\t\t\tattrs[MACSEC_ATTR_OFFLOAD],\n\t\t\t\t\tmacsec_genl_offload_policy, NULL))\n\t\treturn -EINVAL;\n\n\trtnl_lock();\n\n\tdev = get_dev_from_nl(genl_info_net(info), attrs);\n\tif (IS_ERR(dev)) {\n\t\tret = PTR_ERR(dev);\n\t\tgoto out;\n\t}\n\tmacsec = macsec_priv(dev);\n\n\tif (!tb_offload[MACSEC_OFFLOAD_ATTR_TYPE]) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\toffload = nla_get_u8(tb_offload[MACSEC_OFFLOAD_ATTR_TYPE]);\n\n\tif (macsec->offload != offload)\n\t\tret = macsec_update_offload(dev, offload);\nout:\n\trtnl_unlock();\n\treturn ret;\n}\n\nstatic void get_tx_sa_stats(struct net_device *dev, int an,\n\t\t\t    struct macsec_tx_sa *tx_sa,\n\t\t\t    struct macsec_tx_sa_stats *sum)\n{\n\tstruct macsec_dev *macsec = macsec_priv(dev);\n\tint cpu;\n\n\t \n\tif (macsec_is_offloaded(macsec)) {\n\t\tconst struct macsec_ops *ops;\n\t\tstruct macsec_context ctx;\n\n\t\tops = macsec_get_ops(macsec, &ctx);\n\t\tif (ops) {\n\t\t\tctx.sa.assoc_num = an;\n\t\t\tctx.sa.tx_sa = tx_sa;\n\t\t\tctx.stats.tx_sa_stats = sum;\n\t\t\tctx.secy = &macsec_priv(dev)->secy;\n\t\t\tmacsec_offload(ops->mdo_get_tx_sa_stats, &ctx);\n\t\t}\n\t\treturn;\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tconst struct macsec_tx_sa_stats *stats =\n\t\t\tper_cpu_ptr(tx_sa->stats, cpu);\n\n\t\tsum->OutPktsProtected += stats->OutPktsProtected;\n\t\tsum->OutPktsEncrypted += stats->OutPktsEncrypted;\n\t}\n}\n\nstatic int copy_tx_sa_stats(struct sk_buff *skb, struct macsec_tx_sa_stats *sum)\n{\n\tif (nla_put_u32(skb, MACSEC_SA_STATS_ATTR_OUT_PKTS_PROTECTED,\n\t\t\tsum->OutPktsProtected) ||\n\t    nla_put_u32(skb, MACSEC_SA_STATS_ATTR_OUT_PKTS_ENCRYPTED,\n\t\t\tsum->OutPktsEncrypted))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic void get_rx_sa_stats(struct net_device *dev,\n\t\t\t    struct macsec_rx_sc *rx_sc, int an,\n\t\t\t    struct macsec_rx_sa *rx_sa,\n\t\t\t    struct macsec_rx_sa_stats *sum)\n{\n\tstruct macsec_dev *macsec = macsec_priv(dev);\n\tint cpu;\n\n\t \n\tif (macsec_is_offloaded(macsec)) {\n\t\tconst struct macsec_ops *ops;\n\t\tstruct macsec_context ctx;\n\n\t\tops = macsec_get_ops(macsec, &ctx);\n\t\tif (ops) {\n\t\t\tctx.sa.assoc_num = an;\n\t\t\tctx.sa.rx_sa = rx_sa;\n\t\t\tctx.stats.rx_sa_stats = sum;\n\t\t\tctx.secy = &macsec_priv(dev)->secy;\n\t\t\tctx.rx_sc = rx_sc;\n\t\t\tmacsec_offload(ops->mdo_get_rx_sa_stats, &ctx);\n\t\t}\n\t\treturn;\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tconst struct macsec_rx_sa_stats *stats =\n\t\t\tper_cpu_ptr(rx_sa->stats, cpu);\n\n\t\tsum->InPktsOK         += stats->InPktsOK;\n\t\tsum->InPktsInvalid    += stats->InPktsInvalid;\n\t\tsum->InPktsNotValid   += stats->InPktsNotValid;\n\t\tsum->InPktsNotUsingSA += stats->InPktsNotUsingSA;\n\t\tsum->InPktsUnusedSA   += stats->InPktsUnusedSA;\n\t}\n}\n\nstatic int copy_rx_sa_stats(struct sk_buff *skb,\n\t\t\t    struct macsec_rx_sa_stats *sum)\n{\n\tif (nla_put_u32(skb, MACSEC_SA_STATS_ATTR_IN_PKTS_OK, sum->InPktsOK) ||\n\t    nla_put_u32(skb, MACSEC_SA_STATS_ATTR_IN_PKTS_INVALID,\n\t\t\tsum->InPktsInvalid) ||\n\t    nla_put_u32(skb, MACSEC_SA_STATS_ATTR_IN_PKTS_NOT_VALID,\n\t\t\tsum->InPktsNotValid) ||\n\t    nla_put_u32(skb, MACSEC_SA_STATS_ATTR_IN_PKTS_NOT_USING_SA,\n\t\t\tsum->InPktsNotUsingSA) ||\n\t    nla_put_u32(skb, MACSEC_SA_STATS_ATTR_IN_PKTS_UNUSED_SA,\n\t\t\tsum->InPktsUnusedSA))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic void get_rx_sc_stats(struct net_device *dev,\n\t\t\t    struct macsec_rx_sc *rx_sc,\n\t\t\t    struct macsec_rx_sc_stats *sum)\n{\n\tstruct macsec_dev *macsec = macsec_priv(dev);\n\tint cpu;\n\n\t \n\tif (macsec_is_offloaded(macsec)) {\n\t\tconst struct macsec_ops *ops;\n\t\tstruct macsec_context ctx;\n\n\t\tops = macsec_get_ops(macsec, &ctx);\n\t\tif (ops) {\n\t\t\tctx.stats.rx_sc_stats = sum;\n\t\t\tctx.secy = &macsec_priv(dev)->secy;\n\t\t\tctx.rx_sc = rx_sc;\n\t\t\tmacsec_offload(ops->mdo_get_rx_sc_stats, &ctx);\n\t\t}\n\t\treturn;\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tconst struct pcpu_rx_sc_stats *stats;\n\t\tstruct macsec_rx_sc_stats tmp;\n\t\tunsigned int start;\n\n\t\tstats = per_cpu_ptr(rx_sc->stats, cpu);\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&stats->syncp);\n\t\t\tmemcpy(&tmp, &stats->stats, sizeof(tmp));\n\t\t} while (u64_stats_fetch_retry(&stats->syncp, start));\n\n\t\tsum->InOctetsValidated += tmp.InOctetsValidated;\n\t\tsum->InOctetsDecrypted += tmp.InOctetsDecrypted;\n\t\tsum->InPktsUnchecked   += tmp.InPktsUnchecked;\n\t\tsum->InPktsDelayed     += tmp.InPktsDelayed;\n\t\tsum->InPktsOK          += tmp.InPktsOK;\n\t\tsum->InPktsInvalid     += tmp.InPktsInvalid;\n\t\tsum->InPktsLate        += tmp.InPktsLate;\n\t\tsum->InPktsNotValid    += tmp.InPktsNotValid;\n\t\tsum->InPktsNotUsingSA  += tmp.InPktsNotUsingSA;\n\t\tsum->InPktsUnusedSA    += tmp.InPktsUnusedSA;\n\t}\n}\n\nstatic int copy_rx_sc_stats(struct sk_buff *skb, struct macsec_rx_sc_stats *sum)\n{\n\tif (nla_put_u64_64bit(skb, MACSEC_RXSC_STATS_ATTR_IN_OCTETS_VALIDATED,\n\t\t\t      sum->InOctetsValidated,\n\t\t\t      MACSEC_RXSC_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, MACSEC_RXSC_STATS_ATTR_IN_OCTETS_DECRYPTED,\n\t\t\t      sum->InOctetsDecrypted,\n\t\t\t      MACSEC_RXSC_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, MACSEC_RXSC_STATS_ATTR_IN_PKTS_UNCHECKED,\n\t\t\t      sum->InPktsUnchecked,\n\t\t\t      MACSEC_RXSC_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, MACSEC_RXSC_STATS_ATTR_IN_PKTS_DELAYED,\n\t\t\t      sum->InPktsDelayed,\n\t\t\t      MACSEC_RXSC_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, MACSEC_RXSC_STATS_ATTR_IN_PKTS_OK,\n\t\t\t      sum->InPktsOK,\n\t\t\t      MACSEC_RXSC_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, MACSEC_RXSC_STATS_ATTR_IN_PKTS_INVALID,\n\t\t\t      sum->InPktsInvalid,\n\t\t\t      MACSEC_RXSC_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, MACSEC_RXSC_STATS_ATTR_IN_PKTS_LATE,\n\t\t\t      sum->InPktsLate,\n\t\t\t      MACSEC_RXSC_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, MACSEC_RXSC_STATS_ATTR_IN_PKTS_NOT_VALID,\n\t\t\t      sum->InPktsNotValid,\n\t\t\t      MACSEC_RXSC_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, MACSEC_RXSC_STATS_ATTR_IN_PKTS_NOT_USING_SA,\n\t\t\t      sum->InPktsNotUsingSA,\n\t\t\t      MACSEC_RXSC_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, MACSEC_RXSC_STATS_ATTR_IN_PKTS_UNUSED_SA,\n\t\t\t      sum->InPktsUnusedSA,\n\t\t\t      MACSEC_RXSC_STATS_ATTR_PAD))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic void get_tx_sc_stats(struct net_device *dev,\n\t\t\t    struct macsec_tx_sc_stats *sum)\n{\n\tstruct macsec_dev *macsec = macsec_priv(dev);\n\tint cpu;\n\n\t \n\tif (macsec_is_offloaded(macsec)) {\n\t\tconst struct macsec_ops *ops;\n\t\tstruct macsec_context ctx;\n\n\t\tops = macsec_get_ops(macsec, &ctx);\n\t\tif (ops) {\n\t\t\tctx.stats.tx_sc_stats = sum;\n\t\t\tctx.secy = &macsec_priv(dev)->secy;\n\t\t\tmacsec_offload(ops->mdo_get_tx_sc_stats, &ctx);\n\t\t}\n\t\treturn;\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tconst struct pcpu_tx_sc_stats *stats;\n\t\tstruct macsec_tx_sc_stats tmp;\n\t\tunsigned int start;\n\n\t\tstats = per_cpu_ptr(macsec_priv(dev)->secy.tx_sc.stats, cpu);\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&stats->syncp);\n\t\t\tmemcpy(&tmp, &stats->stats, sizeof(tmp));\n\t\t} while (u64_stats_fetch_retry(&stats->syncp, start));\n\n\t\tsum->OutPktsProtected   += tmp.OutPktsProtected;\n\t\tsum->OutPktsEncrypted   += tmp.OutPktsEncrypted;\n\t\tsum->OutOctetsProtected += tmp.OutOctetsProtected;\n\t\tsum->OutOctetsEncrypted += tmp.OutOctetsEncrypted;\n\t}\n}\n\nstatic int copy_tx_sc_stats(struct sk_buff *skb, struct macsec_tx_sc_stats *sum)\n{\n\tif (nla_put_u64_64bit(skb, MACSEC_TXSC_STATS_ATTR_OUT_PKTS_PROTECTED,\n\t\t\t      sum->OutPktsProtected,\n\t\t\t      MACSEC_TXSC_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, MACSEC_TXSC_STATS_ATTR_OUT_PKTS_ENCRYPTED,\n\t\t\t      sum->OutPktsEncrypted,\n\t\t\t      MACSEC_TXSC_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, MACSEC_TXSC_STATS_ATTR_OUT_OCTETS_PROTECTED,\n\t\t\t      sum->OutOctetsProtected,\n\t\t\t      MACSEC_TXSC_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, MACSEC_TXSC_STATS_ATTR_OUT_OCTETS_ENCRYPTED,\n\t\t\t      sum->OutOctetsEncrypted,\n\t\t\t      MACSEC_TXSC_STATS_ATTR_PAD))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic void get_secy_stats(struct net_device *dev, struct macsec_dev_stats *sum)\n{\n\tstruct macsec_dev *macsec = macsec_priv(dev);\n\tint cpu;\n\n\t \n\tif (macsec_is_offloaded(macsec)) {\n\t\tconst struct macsec_ops *ops;\n\t\tstruct macsec_context ctx;\n\n\t\tops = macsec_get_ops(macsec, &ctx);\n\t\tif (ops) {\n\t\t\tctx.stats.dev_stats = sum;\n\t\t\tctx.secy = &macsec_priv(dev)->secy;\n\t\t\tmacsec_offload(ops->mdo_get_dev_stats, &ctx);\n\t\t}\n\t\treturn;\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tconst struct pcpu_secy_stats *stats;\n\t\tstruct macsec_dev_stats tmp;\n\t\tunsigned int start;\n\n\t\tstats = per_cpu_ptr(macsec_priv(dev)->stats, cpu);\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&stats->syncp);\n\t\t\tmemcpy(&tmp, &stats->stats, sizeof(tmp));\n\t\t} while (u64_stats_fetch_retry(&stats->syncp, start));\n\n\t\tsum->OutPktsUntagged  += tmp.OutPktsUntagged;\n\t\tsum->InPktsUntagged   += tmp.InPktsUntagged;\n\t\tsum->OutPktsTooLong   += tmp.OutPktsTooLong;\n\t\tsum->InPktsNoTag      += tmp.InPktsNoTag;\n\t\tsum->InPktsBadTag     += tmp.InPktsBadTag;\n\t\tsum->InPktsUnknownSCI += tmp.InPktsUnknownSCI;\n\t\tsum->InPktsNoSCI      += tmp.InPktsNoSCI;\n\t\tsum->InPktsOverrun    += tmp.InPktsOverrun;\n\t}\n}\n\nstatic int copy_secy_stats(struct sk_buff *skb, struct macsec_dev_stats *sum)\n{\n\tif (nla_put_u64_64bit(skb, MACSEC_SECY_STATS_ATTR_OUT_PKTS_UNTAGGED,\n\t\t\t      sum->OutPktsUntagged,\n\t\t\t      MACSEC_SECY_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, MACSEC_SECY_STATS_ATTR_IN_PKTS_UNTAGGED,\n\t\t\t      sum->InPktsUntagged,\n\t\t\t      MACSEC_SECY_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, MACSEC_SECY_STATS_ATTR_OUT_PKTS_TOO_LONG,\n\t\t\t      sum->OutPktsTooLong,\n\t\t\t      MACSEC_SECY_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, MACSEC_SECY_STATS_ATTR_IN_PKTS_NO_TAG,\n\t\t\t      sum->InPktsNoTag,\n\t\t\t      MACSEC_SECY_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, MACSEC_SECY_STATS_ATTR_IN_PKTS_BAD_TAG,\n\t\t\t      sum->InPktsBadTag,\n\t\t\t      MACSEC_SECY_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, MACSEC_SECY_STATS_ATTR_IN_PKTS_UNKNOWN_SCI,\n\t\t\t      sum->InPktsUnknownSCI,\n\t\t\t      MACSEC_SECY_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, MACSEC_SECY_STATS_ATTR_IN_PKTS_NO_SCI,\n\t\t\t      sum->InPktsNoSCI,\n\t\t\t      MACSEC_SECY_STATS_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, MACSEC_SECY_STATS_ATTR_IN_PKTS_OVERRUN,\n\t\t\t      sum->InPktsOverrun,\n\t\t\t      MACSEC_SECY_STATS_ATTR_PAD))\n\t\treturn -EMSGSIZE;\n\n\treturn 0;\n}\n\nstatic int nla_put_secy(struct macsec_secy *secy, struct sk_buff *skb)\n{\n\tstruct macsec_tx_sc *tx_sc = &secy->tx_sc;\n\tstruct nlattr *secy_nest = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t\t MACSEC_ATTR_SECY);\n\tu64 csid;\n\n\tif (!secy_nest)\n\t\treturn 1;\n\n\tswitch (secy->key_len) {\n\tcase MACSEC_GCM_AES_128_SAK_LEN:\n\t\tcsid = secy->xpn ? MACSEC_CIPHER_ID_GCM_AES_XPN_128 : MACSEC_DEFAULT_CIPHER_ID;\n\t\tbreak;\n\tcase MACSEC_GCM_AES_256_SAK_LEN:\n\t\tcsid = secy->xpn ? MACSEC_CIPHER_ID_GCM_AES_XPN_256 : MACSEC_CIPHER_ID_GCM_AES_256;\n\t\tbreak;\n\tdefault:\n\t\tgoto cancel;\n\t}\n\n\tif (nla_put_sci(skb, MACSEC_SECY_ATTR_SCI, secy->sci,\n\t\t\tMACSEC_SECY_ATTR_PAD) ||\n\t    nla_put_u64_64bit(skb, MACSEC_SECY_ATTR_CIPHER_SUITE,\n\t\t\t      csid, MACSEC_SECY_ATTR_PAD) ||\n\t    nla_put_u8(skb, MACSEC_SECY_ATTR_ICV_LEN, secy->icv_len) ||\n\t    nla_put_u8(skb, MACSEC_SECY_ATTR_OPER, secy->operational) ||\n\t    nla_put_u8(skb, MACSEC_SECY_ATTR_PROTECT, secy->protect_frames) ||\n\t    nla_put_u8(skb, MACSEC_SECY_ATTR_REPLAY, secy->replay_protect) ||\n\t    nla_put_u8(skb, MACSEC_SECY_ATTR_VALIDATE, secy->validate_frames) ||\n\t    nla_put_u8(skb, MACSEC_SECY_ATTR_ENCRYPT, tx_sc->encrypt) ||\n\t    nla_put_u8(skb, MACSEC_SECY_ATTR_INC_SCI, tx_sc->send_sci) ||\n\t    nla_put_u8(skb, MACSEC_SECY_ATTR_ES, tx_sc->end_station) ||\n\t    nla_put_u8(skb, MACSEC_SECY_ATTR_SCB, tx_sc->scb) ||\n\t    nla_put_u8(skb, MACSEC_SECY_ATTR_ENCODING_SA, tx_sc->encoding_sa))\n\t\tgoto cancel;\n\n\tif (secy->replay_protect) {\n\t\tif (nla_put_u32(skb, MACSEC_SECY_ATTR_WINDOW, secy->replay_window))\n\t\t\tgoto cancel;\n\t}\n\n\tnla_nest_end(skb, secy_nest);\n\treturn 0;\n\ncancel:\n\tnla_nest_cancel(skb, secy_nest);\n\treturn 1;\n}\n\nstatic noinline_for_stack int\ndump_secy(struct macsec_secy *secy, struct net_device *dev,\n\t  struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct macsec_tx_sc_stats tx_sc_stats = {0, };\n\tstruct macsec_tx_sa_stats tx_sa_stats = {0, };\n\tstruct macsec_rx_sc_stats rx_sc_stats = {0, };\n\tstruct macsec_rx_sa_stats rx_sa_stats = {0, };\n\tstruct macsec_dev *macsec = netdev_priv(dev);\n\tstruct macsec_dev_stats dev_stats = {0, };\n\tstruct macsec_tx_sc *tx_sc = &secy->tx_sc;\n\tstruct nlattr *txsa_list, *rxsc_list;\n\tstruct macsec_rx_sc *rx_sc;\n\tstruct nlattr *attr;\n\tvoid *hdr;\n\tint i, j;\n\n\thdr = genlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\t  &macsec_fam, NLM_F_MULTI, MACSEC_CMD_GET_TXSC);\n\tif (!hdr)\n\t\treturn -EMSGSIZE;\n\n\tgenl_dump_check_consistent(cb, hdr);\n\n\tif (nla_put_u32(skb, MACSEC_ATTR_IFINDEX, dev->ifindex))\n\t\tgoto nla_put_failure;\n\n\tattr = nla_nest_start_noflag(skb, MACSEC_ATTR_OFFLOAD);\n\tif (!attr)\n\t\tgoto nla_put_failure;\n\tif (nla_put_u8(skb, MACSEC_OFFLOAD_ATTR_TYPE, macsec->offload))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(skb, attr);\n\n\tif (nla_put_secy(secy, skb))\n\t\tgoto nla_put_failure;\n\n\tattr = nla_nest_start_noflag(skb, MACSEC_ATTR_TXSC_STATS);\n\tif (!attr)\n\t\tgoto nla_put_failure;\n\n\tget_tx_sc_stats(dev, &tx_sc_stats);\n\tif (copy_tx_sc_stats(skb, &tx_sc_stats)) {\n\t\tnla_nest_cancel(skb, attr);\n\t\tgoto nla_put_failure;\n\t}\n\tnla_nest_end(skb, attr);\n\n\tattr = nla_nest_start_noflag(skb, MACSEC_ATTR_SECY_STATS);\n\tif (!attr)\n\t\tgoto nla_put_failure;\n\tget_secy_stats(dev, &dev_stats);\n\tif (copy_secy_stats(skb, &dev_stats)) {\n\t\tnla_nest_cancel(skb, attr);\n\t\tgoto nla_put_failure;\n\t}\n\tnla_nest_end(skb, attr);\n\n\ttxsa_list = nla_nest_start_noflag(skb, MACSEC_ATTR_TXSA_LIST);\n\tif (!txsa_list)\n\t\tgoto nla_put_failure;\n\tfor (i = 0, j = 1; i < MACSEC_NUM_AN; i++) {\n\t\tstruct macsec_tx_sa *tx_sa = rtnl_dereference(tx_sc->sa[i]);\n\t\tstruct nlattr *txsa_nest;\n\t\tu64 pn;\n\t\tint pn_len;\n\n\t\tif (!tx_sa)\n\t\t\tcontinue;\n\n\t\ttxsa_nest = nla_nest_start_noflag(skb, j++);\n\t\tif (!txsa_nest) {\n\t\t\tnla_nest_cancel(skb, txsa_list);\n\t\t\tgoto nla_put_failure;\n\t\t}\n\n\t\tattr = nla_nest_start_noflag(skb, MACSEC_SA_ATTR_STATS);\n\t\tif (!attr) {\n\t\t\tnla_nest_cancel(skb, txsa_nest);\n\t\t\tnla_nest_cancel(skb, txsa_list);\n\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tmemset(&tx_sa_stats, 0, sizeof(tx_sa_stats));\n\t\tget_tx_sa_stats(dev, i, tx_sa, &tx_sa_stats);\n\t\tif (copy_tx_sa_stats(skb, &tx_sa_stats)) {\n\t\t\tnla_nest_cancel(skb, attr);\n\t\t\tnla_nest_cancel(skb, txsa_nest);\n\t\t\tnla_nest_cancel(skb, txsa_list);\n\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tnla_nest_end(skb, attr);\n\n\t\tif (secy->xpn) {\n\t\t\tpn = tx_sa->next_pn;\n\t\t\tpn_len = MACSEC_XPN_PN_LEN;\n\t\t} else {\n\t\t\tpn = tx_sa->next_pn_halves.lower;\n\t\t\tpn_len = MACSEC_DEFAULT_PN_LEN;\n\t\t}\n\n\t\tif (nla_put_u8(skb, MACSEC_SA_ATTR_AN, i) ||\n\t\t    nla_put(skb, MACSEC_SA_ATTR_PN, pn_len, &pn) ||\n\t\t    nla_put(skb, MACSEC_SA_ATTR_KEYID, MACSEC_KEYID_LEN, tx_sa->key.id) ||\n\t\t    (secy->xpn && nla_put_ssci(skb, MACSEC_SA_ATTR_SSCI, tx_sa->ssci)) ||\n\t\t    nla_put_u8(skb, MACSEC_SA_ATTR_ACTIVE, tx_sa->active)) {\n\t\t\tnla_nest_cancel(skb, txsa_nest);\n\t\t\tnla_nest_cancel(skb, txsa_list);\n\t\t\tgoto nla_put_failure;\n\t\t}\n\n\t\tnla_nest_end(skb, txsa_nest);\n\t}\n\tnla_nest_end(skb, txsa_list);\n\n\trxsc_list = nla_nest_start_noflag(skb, MACSEC_ATTR_RXSC_LIST);\n\tif (!rxsc_list)\n\t\tgoto nla_put_failure;\n\n\tj = 1;\n\tfor_each_rxsc_rtnl(secy, rx_sc) {\n\t\tint k;\n\t\tstruct nlattr *rxsa_list;\n\t\tstruct nlattr *rxsc_nest = nla_nest_start_noflag(skb, j++);\n\n\t\tif (!rxsc_nest) {\n\t\t\tnla_nest_cancel(skb, rxsc_list);\n\t\t\tgoto nla_put_failure;\n\t\t}\n\n\t\tif (nla_put_u8(skb, MACSEC_RXSC_ATTR_ACTIVE, rx_sc->active) ||\n\t\t    nla_put_sci(skb, MACSEC_RXSC_ATTR_SCI, rx_sc->sci,\n\t\t\t\tMACSEC_RXSC_ATTR_PAD)) {\n\t\t\tnla_nest_cancel(skb, rxsc_nest);\n\t\t\tnla_nest_cancel(skb, rxsc_list);\n\t\t\tgoto nla_put_failure;\n\t\t}\n\n\t\tattr = nla_nest_start_noflag(skb, MACSEC_RXSC_ATTR_STATS);\n\t\tif (!attr) {\n\t\t\tnla_nest_cancel(skb, rxsc_nest);\n\t\t\tnla_nest_cancel(skb, rxsc_list);\n\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tmemset(&rx_sc_stats, 0, sizeof(rx_sc_stats));\n\t\tget_rx_sc_stats(dev, rx_sc, &rx_sc_stats);\n\t\tif (copy_rx_sc_stats(skb, &rx_sc_stats)) {\n\t\t\tnla_nest_cancel(skb, attr);\n\t\t\tnla_nest_cancel(skb, rxsc_nest);\n\t\t\tnla_nest_cancel(skb, rxsc_list);\n\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tnla_nest_end(skb, attr);\n\n\t\trxsa_list = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t  MACSEC_RXSC_ATTR_SA_LIST);\n\t\tif (!rxsa_list) {\n\t\t\tnla_nest_cancel(skb, rxsc_nest);\n\t\t\tnla_nest_cancel(skb, rxsc_list);\n\t\t\tgoto nla_put_failure;\n\t\t}\n\n\t\tfor (i = 0, k = 1; i < MACSEC_NUM_AN; i++) {\n\t\t\tstruct macsec_rx_sa *rx_sa = rtnl_dereference(rx_sc->sa[i]);\n\t\t\tstruct nlattr *rxsa_nest;\n\t\t\tu64 pn;\n\t\t\tint pn_len;\n\n\t\t\tif (!rx_sa)\n\t\t\t\tcontinue;\n\n\t\t\trxsa_nest = nla_nest_start_noflag(skb, k++);\n\t\t\tif (!rxsa_nest) {\n\t\t\t\tnla_nest_cancel(skb, rxsa_list);\n\t\t\t\tnla_nest_cancel(skb, rxsc_nest);\n\t\t\t\tnla_nest_cancel(skb, rxsc_list);\n\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\n\t\t\tattr = nla_nest_start_noflag(skb,\n\t\t\t\t\t\t     MACSEC_SA_ATTR_STATS);\n\t\t\tif (!attr) {\n\t\t\t\tnla_nest_cancel(skb, rxsa_list);\n\t\t\t\tnla_nest_cancel(skb, rxsc_nest);\n\t\t\t\tnla_nest_cancel(skb, rxsc_list);\n\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t\tmemset(&rx_sa_stats, 0, sizeof(rx_sa_stats));\n\t\t\tget_rx_sa_stats(dev, rx_sc, i, rx_sa, &rx_sa_stats);\n\t\t\tif (copy_rx_sa_stats(skb, &rx_sa_stats)) {\n\t\t\t\tnla_nest_cancel(skb, attr);\n\t\t\t\tnla_nest_cancel(skb, rxsa_list);\n\t\t\t\tnla_nest_cancel(skb, rxsc_nest);\n\t\t\t\tnla_nest_cancel(skb, rxsc_list);\n\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t\tnla_nest_end(skb, attr);\n\n\t\t\tif (secy->xpn) {\n\t\t\t\tpn = rx_sa->next_pn;\n\t\t\t\tpn_len = MACSEC_XPN_PN_LEN;\n\t\t\t} else {\n\t\t\t\tpn = rx_sa->next_pn_halves.lower;\n\t\t\t\tpn_len = MACSEC_DEFAULT_PN_LEN;\n\t\t\t}\n\n\t\t\tif (nla_put_u8(skb, MACSEC_SA_ATTR_AN, i) ||\n\t\t\t    nla_put(skb, MACSEC_SA_ATTR_PN, pn_len, &pn) ||\n\t\t\t    nla_put(skb, MACSEC_SA_ATTR_KEYID, MACSEC_KEYID_LEN, rx_sa->key.id) ||\n\t\t\t    (secy->xpn && nla_put_ssci(skb, MACSEC_SA_ATTR_SSCI, rx_sa->ssci)) ||\n\t\t\t    nla_put_u8(skb, MACSEC_SA_ATTR_ACTIVE, rx_sa->active)) {\n\t\t\t\tnla_nest_cancel(skb, rxsa_nest);\n\t\t\t\tnla_nest_cancel(skb, rxsc_nest);\n\t\t\t\tnla_nest_cancel(skb, rxsc_list);\n\t\t\t\tgoto nla_put_failure;\n\t\t\t}\n\t\t\tnla_nest_end(skb, rxsa_nest);\n\t\t}\n\n\t\tnla_nest_end(skb, rxsa_list);\n\t\tnla_nest_end(skb, rxsc_nest);\n\t}\n\n\tnla_nest_end(skb, rxsc_list);\n\n\tgenlmsg_end(skb, hdr);\n\n\treturn 0;\n\nnla_put_failure:\n\tgenlmsg_cancel(skb, hdr);\n\treturn -EMSGSIZE;\n}\n\nstatic int macsec_generation = 1;  \n\nstatic int macsec_dump_txsc(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct net_device *dev;\n\tint dev_idx, d;\n\n\tdev_idx = cb->args[0];\n\n\td = 0;\n\trtnl_lock();\n\n\tcb->seq = macsec_generation;\n\n\tfor_each_netdev(net, dev) {\n\t\tstruct macsec_secy *secy;\n\n\t\tif (d < dev_idx)\n\t\t\tgoto next;\n\n\t\tif (!netif_is_macsec(dev))\n\t\t\tgoto next;\n\n\t\tsecy = &macsec_priv(dev)->secy;\n\t\tif (dump_secy(secy, dev, skb, cb) < 0)\n\t\t\tgoto done;\nnext:\n\t\td++;\n\t}\n\ndone:\n\trtnl_unlock();\n\tcb->args[0] = d;\n\treturn skb->len;\n}\n\nstatic const struct genl_small_ops macsec_genl_ops[] = {\n\t{\n\t\t.cmd = MACSEC_CMD_GET_TXSC,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.dumpit = macsec_dump_txsc,\n\t},\n\t{\n\t\t.cmd = MACSEC_CMD_ADD_RXSC,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = macsec_add_rxsc,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = MACSEC_CMD_DEL_RXSC,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = macsec_del_rxsc,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = MACSEC_CMD_UPD_RXSC,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = macsec_upd_rxsc,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = MACSEC_CMD_ADD_TXSA,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = macsec_add_txsa,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = MACSEC_CMD_DEL_TXSA,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = macsec_del_txsa,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = MACSEC_CMD_UPD_TXSA,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = macsec_upd_txsa,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = MACSEC_CMD_ADD_RXSA,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = macsec_add_rxsa,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = MACSEC_CMD_DEL_RXSA,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = macsec_del_rxsa,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = MACSEC_CMD_UPD_RXSA,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = macsec_upd_rxsa,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n\t{\n\t\t.cmd = MACSEC_CMD_UPD_OFFLOAD,\n\t\t.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,\n\t\t.doit = macsec_upd_offload,\n\t\t.flags = GENL_ADMIN_PERM,\n\t},\n};\n\nstatic struct genl_family macsec_fam __ro_after_init = {\n\t.name\t\t= MACSEC_GENL_NAME,\n\t.hdrsize\t= 0,\n\t.version\t= MACSEC_GENL_VERSION,\n\t.maxattr\t= MACSEC_ATTR_MAX,\n\t.policy = macsec_genl_policy,\n\t.netnsok\t= true,\n\t.module\t\t= THIS_MODULE,\n\t.small_ops\t= macsec_genl_ops,\n\t.n_small_ops\t= ARRAY_SIZE(macsec_genl_ops),\n\t.resv_start_op\t= MACSEC_CMD_UPD_OFFLOAD + 1,\n};\n\nstatic netdev_tx_t macsec_start_xmit(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev)\n{\n\tstruct macsec_dev *macsec = netdev_priv(dev);\n\tstruct macsec_secy *secy = &macsec->secy;\n\tstruct pcpu_secy_stats *secy_stats;\n\tint ret, len;\n\n\tif (macsec_is_offloaded(netdev_priv(dev))) {\n\t\tstruct metadata_dst *md_dst = secy->tx_sc.md_dst;\n\n\t\tskb_dst_drop(skb);\n\t\tdst_hold(&md_dst->dst);\n\t\tskb_dst_set(skb, &md_dst->dst);\n\t\tskb->dev = macsec->real_dev;\n\t\treturn dev_queue_xmit(skb);\n\t}\n\n\t \n\tif (!secy->protect_frames) {\n\t\tsecy_stats = this_cpu_ptr(macsec->stats);\n\t\tu64_stats_update_begin(&secy_stats->syncp);\n\t\tsecy_stats->stats.OutPktsUntagged++;\n\t\tu64_stats_update_end(&secy_stats->syncp);\n\t\tskb->dev = macsec->real_dev;\n\t\tlen = skb->len;\n\t\tret = dev_queue_xmit(skb);\n\t\tcount_tx(dev, ret, len);\n\t\treturn ret;\n\t}\n\n\tif (!secy->operational) {\n\t\tkfree_skb(skb);\n\t\tDEV_STATS_INC(dev, tx_dropped);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tlen = skb->len;\n\tskb = macsec_encrypt(skb, dev);\n\tif (IS_ERR(skb)) {\n\t\tif (PTR_ERR(skb) != -EINPROGRESS)\n\t\t\tDEV_STATS_INC(dev, tx_dropped);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tmacsec_count_tx(skb, &macsec->secy.tx_sc, macsec_skb_cb(skb)->tx_sa);\n\n\tmacsec_encrypt_finish(skb, dev);\n\tret = dev_queue_xmit(skb);\n\tcount_tx(dev, ret, len);\n\treturn ret;\n}\n\n#define MACSEC_FEATURES \\\n\t(NETIF_F_SG | NETIF_F_HIGHDMA | NETIF_F_FRAGLIST)\n\nstatic int macsec_dev_init(struct net_device *dev)\n{\n\tstruct macsec_dev *macsec = macsec_priv(dev);\n\tstruct net_device *real_dev = macsec->real_dev;\n\tint err;\n\n\tdev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\n\tif (!dev->tstats)\n\t\treturn -ENOMEM;\n\n\terr = gro_cells_init(&macsec->gro_cells, dev);\n\tif (err) {\n\t\tfree_percpu(dev->tstats);\n\t\treturn err;\n\t}\n\n\tdev->features = real_dev->features & MACSEC_FEATURES;\n\tdev->features |= NETIF_F_LLTX | NETIF_F_GSO_SOFTWARE;\n\n\tdev->needed_headroom = real_dev->needed_headroom +\n\t\t\t       MACSEC_NEEDED_HEADROOM;\n\tdev->needed_tailroom = real_dev->needed_tailroom +\n\t\t\t       MACSEC_NEEDED_TAILROOM;\n\n\tif (is_zero_ether_addr(dev->dev_addr))\n\t\teth_hw_addr_inherit(dev, real_dev);\n\tif (is_zero_ether_addr(dev->broadcast))\n\t\tmemcpy(dev->broadcast, real_dev->broadcast, dev->addr_len);\n\n\t \n\tnetdev_hold(real_dev, &macsec->dev_tracker, GFP_KERNEL);\n\n\treturn 0;\n}\n\nstatic void macsec_dev_uninit(struct net_device *dev)\n{\n\tstruct macsec_dev *macsec = macsec_priv(dev);\n\n\tgro_cells_destroy(&macsec->gro_cells);\n\tfree_percpu(dev->tstats);\n}\n\nstatic netdev_features_t macsec_fix_features(struct net_device *dev,\n\t\t\t\t\t     netdev_features_t features)\n{\n\tstruct macsec_dev *macsec = macsec_priv(dev);\n\tstruct net_device *real_dev = macsec->real_dev;\n\n\tfeatures &= (real_dev->features & MACSEC_FEATURES) |\n\t\t    NETIF_F_GSO_SOFTWARE | NETIF_F_SOFT_FEATURES;\n\tfeatures |= NETIF_F_LLTX;\n\n\treturn features;\n}\n\nstatic int macsec_dev_open(struct net_device *dev)\n{\n\tstruct macsec_dev *macsec = macsec_priv(dev);\n\tstruct net_device *real_dev = macsec->real_dev;\n\tint err;\n\n\terr = dev_uc_add(real_dev, dev->dev_addr);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (dev->flags & IFF_ALLMULTI) {\n\t\terr = dev_set_allmulti(real_dev, 1);\n\t\tif (err < 0)\n\t\t\tgoto del_unicast;\n\t}\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\terr = dev_set_promiscuity(real_dev, 1);\n\t\tif (err < 0)\n\t\t\tgoto clear_allmulti;\n\t}\n\n\t \n\tif (macsec_is_offloaded(macsec)) {\n\t\tconst struct macsec_ops *ops;\n\t\tstruct macsec_context ctx;\n\n\t\tops = macsec_get_ops(netdev_priv(dev), &ctx);\n\t\tif (!ops) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto clear_allmulti;\n\t\t}\n\n\t\tctx.secy = &macsec->secy;\n\t\terr = macsec_offload(ops->mdo_dev_open, &ctx);\n\t\tif (err)\n\t\t\tgoto clear_allmulti;\n\t}\n\n\tif (netif_carrier_ok(real_dev))\n\t\tnetif_carrier_on(dev);\n\n\treturn 0;\nclear_allmulti:\n\tif (dev->flags & IFF_ALLMULTI)\n\t\tdev_set_allmulti(real_dev, -1);\ndel_unicast:\n\tdev_uc_del(real_dev, dev->dev_addr);\n\tnetif_carrier_off(dev);\n\treturn err;\n}\n\nstatic int macsec_dev_stop(struct net_device *dev)\n{\n\tstruct macsec_dev *macsec = macsec_priv(dev);\n\tstruct net_device *real_dev = macsec->real_dev;\n\n\tnetif_carrier_off(dev);\n\n\t \n\tif (macsec_is_offloaded(macsec)) {\n\t\tconst struct macsec_ops *ops;\n\t\tstruct macsec_context ctx;\n\n\t\tops = macsec_get_ops(macsec, &ctx);\n\t\tif (ops) {\n\t\t\tctx.secy = &macsec->secy;\n\t\t\tmacsec_offload(ops->mdo_dev_stop, &ctx);\n\t\t}\n\t}\n\n\tdev_mc_unsync(real_dev, dev);\n\tdev_uc_unsync(real_dev, dev);\n\n\tif (dev->flags & IFF_ALLMULTI)\n\t\tdev_set_allmulti(real_dev, -1);\n\n\tif (dev->flags & IFF_PROMISC)\n\t\tdev_set_promiscuity(real_dev, -1);\n\n\tdev_uc_del(real_dev, dev->dev_addr);\n\n\treturn 0;\n}\n\nstatic void macsec_dev_change_rx_flags(struct net_device *dev, int change)\n{\n\tstruct net_device *real_dev = macsec_priv(dev)->real_dev;\n\n\tif (!(dev->flags & IFF_UP))\n\t\treturn;\n\n\tif (change & IFF_ALLMULTI)\n\t\tdev_set_allmulti(real_dev, dev->flags & IFF_ALLMULTI ? 1 : -1);\n\n\tif (change & IFF_PROMISC)\n\t\tdev_set_promiscuity(real_dev,\n\t\t\t\t    dev->flags & IFF_PROMISC ? 1 : -1);\n}\n\nstatic void macsec_dev_set_rx_mode(struct net_device *dev)\n{\n\tstruct net_device *real_dev = macsec_priv(dev)->real_dev;\n\n\tdev_mc_sync(real_dev, dev);\n\tdev_uc_sync(real_dev, dev);\n}\n\nstatic int macsec_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct macsec_dev *macsec = macsec_priv(dev);\n\tstruct net_device *real_dev = macsec->real_dev;\n\tstruct sockaddr *addr = p;\n\tint err;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (!(dev->flags & IFF_UP))\n\t\tgoto out;\n\n\terr = dev_uc_add(real_dev, addr->sa_data);\n\tif (err < 0)\n\t\treturn err;\n\n\tdev_uc_del(real_dev, dev->dev_addr);\n\nout:\n\teth_hw_addr_set(dev, addr->sa_data);\n\n\t \n\tif (macsec_is_offloaded(macsec)) {\n\t\tconst struct macsec_ops *ops;\n\t\tstruct macsec_context ctx;\n\n\t\tops = macsec_get_ops(macsec, &ctx);\n\t\tif (ops) {\n\t\t\tctx.secy = &macsec->secy;\n\t\t\tmacsec_offload(ops->mdo_upd_secy, &ctx);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int macsec_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct macsec_dev *macsec = macsec_priv(dev);\n\tunsigned int extra = macsec->secy.icv_len + macsec_extra_len(true);\n\n\tif (macsec->real_dev->mtu - extra < new_mtu)\n\t\treturn -ERANGE;\n\n\tdev->mtu = new_mtu;\n\n\treturn 0;\n}\n\nstatic void macsec_get_stats64(struct net_device *dev,\n\t\t\t       struct rtnl_link_stats64 *s)\n{\n\tif (!dev->tstats)\n\t\treturn;\n\n\tdev_fetch_sw_netstats(s, dev->tstats);\n\n\ts->rx_dropped = DEV_STATS_READ(dev, rx_dropped);\n\ts->tx_dropped = DEV_STATS_READ(dev, tx_dropped);\n\ts->rx_errors = DEV_STATS_READ(dev, rx_errors);\n}\n\nstatic int macsec_get_iflink(const struct net_device *dev)\n{\n\treturn macsec_priv(dev)->real_dev->ifindex;\n}\n\nstatic const struct net_device_ops macsec_netdev_ops = {\n\t.ndo_init\t\t= macsec_dev_init,\n\t.ndo_uninit\t\t= macsec_dev_uninit,\n\t.ndo_open\t\t= macsec_dev_open,\n\t.ndo_stop\t\t= macsec_dev_stop,\n\t.ndo_fix_features\t= macsec_fix_features,\n\t.ndo_change_mtu\t\t= macsec_change_mtu,\n\t.ndo_set_rx_mode\t= macsec_dev_set_rx_mode,\n\t.ndo_change_rx_flags\t= macsec_dev_change_rx_flags,\n\t.ndo_set_mac_address\t= macsec_set_mac_address,\n\t.ndo_start_xmit\t\t= macsec_start_xmit,\n\t.ndo_get_stats64\t= macsec_get_stats64,\n\t.ndo_get_iflink\t\t= macsec_get_iflink,\n};\n\nstatic const struct device_type macsec_type = {\n\t.name = \"macsec\",\n};\n\nstatic const struct nla_policy macsec_rtnl_policy[IFLA_MACSEC_MAX + 1] = {\n\t[IFLA_MACSEC_SCI] = { .type = NLA_U64 },\n\t[IFLA_MACSEC_PORT] = { .type = NLA_U16 },\n\t[IFLA_MACSEC_ICV_LEN] = { .type = NLA_U8 },\n\t[IFLA_MACSEC_CIPHER_SUITE] = { .type = NLA_U64 },\n\t[IFLA_MACSEC_WINDOW] = { .type = NLA_U32 },\n\t[IFLA_MACSEC_ENCODING_SA] = { .type = NLA_U8 },\n\t[IFLA_MACSEC_ENCRYPT] = { .type = NLA_U8 },\n\t[IFLA_MACSEC_PROTECT] = { .type = NLA_U8 },\n\t[IFLA_MACSEC_INC_SCI] = { .type = NLA_U8 },\n\t[IFLA_MACSEC_ES] = { .type = NLA_U8 },\n\t[IFLA_MACSEC_SCB] = { .type = NLA_U8 },\n\t[IFLA_MACSEC_REPLAY_PROTECT] = { .type = NLA_U8 },\n\t[IFLA_MACSEC_VALIDATION] = { .type = NLA_U8 },\n\t[IFLA_MACSEC_OFFLOAD] = { .type = NLA_U8 },\n};\n\nstatic void macsec_free_netdev(struct net_device *dev)\n{\n\tstruct macsec_dev *macsec = macsec_priv(dev);\n\n\tif (macsec->secy.tx_sc.md_dst)\n\t\tmetadata_dst_free(macsec->secy.tx_sc.md_dst);\n\tfree_percpu(macsec->stats);\n\tfree_percpu(macsec->secy.tx_sc.stats);\n\n\t \n\tnetdev_put(macsec->real_dev, &macsec->dev_tracker);\n}\n\nstatic void macsec_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->min_mtu = 0;\n\tdev->max_mtu = ETH_MAX_MTU;\n\tdev->priv_flags |= IFF_NO_QUEUE;\n\tdev->netdev_ops = &macsec_netdev_ops;\n\tdev->needs_free_netdev = true;\n\tdev->priv_destructor = macsec_free_netdev;\n\tSET_NETDEV_DEVTYPE(dev, &macsec_type);\n\n\teth_zero_addr(dev->broadcast);\n}\n\nstatic int macsec_changelink_common(struct net_device *dev,\n\t\t\t\t    struct nlattr *data[])\n{\n\tstruct macsec_secy *secy;\n\tstruct macsec_tx_sc *tx_sc;\n\n\tsecy = &macsec_priv(dev)->secy;\n\ttx_sc = &secy->tx_sc;\n\n\tif (data[IFLA_MACSEC_ENCODING_SA]) {\n\t\tstruct macsec_tx_sa *tx_sa;\n\n\t\ttx_sc->encoding_sa = nla_get_u8(data[IFLA_MACSEC_ENCODING_SA]);\n\t\ttx_sa = rtnl_dereference(tx_sc->sa[tx_sc->encoding_sa]);\n\n\t\tsecy->operational = tx_sa && tx_sa->active;\n\t}\n\n\tif (data[IFLA_MACSEC_ENCRYPT])\n\t\ttx_sc->encrypt = !!nla_get_u8(data[IFLA_MACSEC_ENCRYPT]);\n\n\tif (data[IFLA_MACSEC_PROTECT])\n\t\tsecy->protect_frames = !!nla_get_u8(data[IFLA_MACSEC_PROTECT]);\n\n\tif (data[IFLA_MACSEC_INC_SCI])\n\t\ttx_sc->send_sci = !!nla_get_u8(data[IFLA_MACSEC_INC_SCI]);\n\n\tif (data[IFLA_MACSEC_ES])\n\t\ttx_sc->end_station = !!nla_get_u8(data[IFLA_MACSEC_ES]);\n\n\tif (data[IFLA_MACSEC_SCB])\n\t\ttx_sc->scb = !!nla_get_u8(data[IFLA_MACSEC_SCB]);\n\n\tif (data[IFLA_MACSEC_REPLAY_PROTECT])\n\t\tsecy->replay_protect = !!nla_get_u8(data[IFLA_MACSEC_REPLAY_PROTECT]);\n\n\tif (data[IFLA_MACSEC_VALIDATION])\n\t\tsecy->validate_frames = nla_get_u8(data[IFLA_MACSEC_VALIDATION]);\n\n\tif (data[IFLA_MACSEC_CIPHER_SUITE]) {\n\t\tswitch (nla_get_u64(data[IFLA_MACSEC_CIPHER_SUITE])) {\n\t\tcase MACSEC_CIPHER_ID_GCM_AES_128:\n\t\tcase MACSEC_DEFAULT_CIPHER_ID:\n\t\t\tsecy->key_len = MACSEC_GCM_AES_128_SAK_LEN;\n\t\t\tsecy->xpn = false;\n\t\t\tbreak;\n\t\tcase MACSEC_CIPHER_ID_GCM_AES_256:\n\t\t\tsecy->key_len = MACSEC_GCM_AES_256_SAK_LEN;\n\t\t\tsecy->xpn = false;\n\t\t\tbreak;\n\t\tcase MACSEC_CIPHER_ID_GCM_AES_XPN_128:\n\t\t\tsecy->key_len = MACSEC_GCM_AES_128_SAK_LEN;\n\t\t\tsecy->xpn = true;\n\t\t\tbreak;\n\t\tcase MACSEC_CIPHER_ID_GCM_AES_XPN_256:\n\t\t\tsecy->key_len = MACSEC_GCM_AES_256_SAK_LEN;\n\t\t\tsecy->xpn = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (data[IFLA_MACSEC_WINDOW]) {\n\t\tsecy->replay_window = nla_get_u32(data[IFLA_MACSEC_WINDOW]);\n\n\t\t \n\t\tif (secy->xpn &&\n\t\t    secy->replay_window > MACSEC_XPN_MAX_REPLAY_WINDOW)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int macsec_changelink(struct net_device *dev, struct nlattr *tb[],\n\t\t\t     struct nlattr *data[],\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct macsec_dev *macsec = macsec_priv(dev);\n\tbool macsec_offload_state_change = false;\n\tenum macsec_offload offload;\n\tstruct macsec_tx_sc tx_sc;\n\tstruct macsec_secy secy;\n\tint ret;\n\n\tif (!data)\n\t\treturn 0;\n\n\tif (data[IFLA_MACSEC_CIPHER_SUITE] ||\n\t    data[IFLA_MACSEC_ICV_LEN] ||\n\t    data[IFLA_MACSEC_SCI] ||\n\t    data[IFLA_MACSEC_PORT])\n\t\treturn -EINVAL;\n\n\t \n\tmemcpy(&secy, &macsec->secy, sizeof(secy));\n\tmemcpy(&tx_sc, &macsec->secy.tx_sc, sizeof(tx_sc));\n\n\tret = macsec_changelink_common(dev, data);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tif (data[IFLA_MACSEC_OFFLOAD]) {\n\t\toffload = nla_get_u8(data[IFLA_MACSEC_OFFLOAD]);\n\t\tif (macsec->offload != offload) {\n\t\t\tmacsec_offload_state_change = true;\n\t\t\tret = macsec_update_offload(dev, offload);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\t \n\tif (!macsec_offload_state_change && macsec_is_offloaded(macsec)) {\n\t\tconst struct macsec_ops *ops;\n\t\tstruct macsec_context ctx;\n\n\t\tops = macsec_get_ops(netdev_priv(dev), &ctx);\n\t\tif (!ops) {\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tctx.secy = &macsec->secy;\n\t\tret = macsec_offload(ops->mdo_upd_secy, &ctx);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\treturn 0;\n\ncleanup:\n\tmemcpy(&macsec->secy.tx_sc, &tx_sc, sizeof(tx_sc));\n\tmemcpy(&macsec->secy, &secy, sizeof(secy));\n\n\treturn ret;\n}\n\nstatic void macsec_del_dev(struct macsec_dev *macsec)\n{\n\tint i;\n\n\twhile (macsec->secy.rx_sc) {\n\t\tstruct macsec_rx_sc *rx_sc = rtnl_dereference(macsec->secy.rx_sc);\n\n\t\trcu_assign_pointer(macsec->secy.rx_sc, rx_sc->next);\n\t\tfree_rx_sc(rx_sc);\n\t}\n\n\tfor (i = 0; i < MACSEC_NUM_AN; i++) {\n\t\tstruct macsec_tx_sa *sa = rtnl_dereference(macsec->secy.tx_sc.sa[i]);\n\n\t\tif (sa) {\n\t\t\tRCU_INIT_POINTER(macsec->secy.tx_sc.sa[i], NULL);\n\t\t\tclear_tx_sa(sa);\n\t\t}\n\t}\n}\n\nstatic void macsec_common_dellink(struct net_device *dev, struct list_head *head)\n{\n\tstruct macsec_dev *macsec = macsec_priv(dev);\n\tstruct net_device *real_dev = macsec->real_dev;\n\n\t \n\tif (macsec_is_offloaded(macsec)) {\n\t\tconst struct macsec_ops *ops;\n\t\tstruct macsec_context ctx;\n\n\t\tops = macsec_get_ops(netdev_priv(dev), &ctx);\n\t\tif (ops) {\n\t\t\tctx.secy = &macsec->secy;\n\t\t\tmacsec_offload(ops->mdo_del_secy, &ctx);\n\t\t}\n\t}\n\n\tunregister_netdevice_queue(dev, head);\n\tlist_del_rcu(&macsec->secys);\n\tmacsec_del_dev(macsec);\n\tnetdev_upper_dev_unlink(real_dev, dev);\n\n\tmacsec_generation++;\n}\n\nstatic void macsec_dellink(struct net_device *dev, struct list_head *head)\n{\n\tstruct macsec_dev *macsec = macsec_priv(dev);\n\tstruct net_device *real_dev = macsec->real_dev;\n\tstruct macsec_rxh_data *rxd = macsec_data_rtnl(real_dev);\n\n\tmacsec_common_dellink(dev, head);\n\n\tif (list_empty(&rxd->secys)) {\n\t\tnetdev_rx_handler_unregister(real_dev);\n\t\tkfree(rxd);\n\t}\n}\n\nstatic int register_macsec_dev(struct net_device *real_dev,\n\t\t\t       struct net_device *dev)\n{\n\tstruct macsec_dev *macsec = macsec_priv(dev);\n\tstruct macsec_rxh_data *rxd = macsec_data_rtnl(real_dev);\n\n\tif (!rxd) {\n\t\tint err;\n\n\t\trxd = kmalloc(sizeof(*rxd), GFP_KERNEL);\n\t\tif (!rxd)\n\t\t\treturn -ENOMEM;\n\n\t\tINIT_LIST_HEAD(&rxd->secys);\n\n\t\terr = netdev_rx_handler_register(real_dev, macsec_handle_frame,\n\t\t\t\t\t\t rxd);\n\t\tif (err < 0) {\n\t\t\tkfree(rxd);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tlist_add_tail_rcu(&macsec->secys, &rxd->secys);\n\treturn 0;\n}\n\nstatic bool sci_exists(struct net_device *dev, sci_t sci)\n{\n\tstruct macsec_rxh_data *rxd = macsec_data_rtnl(dev);\n\tstruct macsec_dev *macsec;\n\n\tlist_for_each_entry(macsec, &rxd->secys, secys) {\n\t\tif (macsec->secy.sci == sci)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic sci_t dev_to_sci(struct net_device *dev, __be16 port)\n{\n\treturn make_sci(dev->dev_addr, port);\n}\n\nstatic int macsec_add_dev(struct net_device *dev, sci_t sci, u8 icv_len)\n{\n\tstruct macsec_dev *macsec = macsec_priv(dev);\n\tstruct macsec_secy *secy = &macsec->secy;\n\n\tmacsec->stats = netdev_alloc_pcpu_stats(struct pcpu_secy_stats);\n\tif (!macsec->stats)\n\t\treturn -ENOMEM;\n\n\tsecy->tx_sc.stats = netdev_alloc_pcpu_stats(struct pcpu_tx_sc_stats);\n\tif (!secy->tx_sc.stats)\n\t\treturn -ENOMEM;\n\n\tsecy->tx_sc.md_dst = metadata_dst_alloc(0, METADATA_MACSEC, GFP_KERNEL);\n\tif (!secy->tx_sc.md_dst)\n\t\t \n\t\treturn -ENOMEM;\n\n\tif (sci == MACSEC_UNDEF_SCI)\n\t\tsci = dev_to_sci(dev, MACSEC_PORT_ES);\n\n\tsecy->netdev = dev;\n\tsecy->operational = true;\n\tsecy->key_len = DEFAULT_SAK_LEN;\n\tsecy->icv_len = icv_len;\n\tsecy->validate_frames = MACSEC_VALIDATE_DEFAULT;\n\tsecy->protect_frames = true;\n\tsecy->replay_protect = false;\n\tsecy->xpn = DEFAULT_XPN;\n\n\tsecy->sci = sci;\n\tsecy->tx_sc.md_dst->u.macsec_info.sci = sci;\n\tsecy->tx_sc.active = true;\n\tsecy->tx_sc.encoding_sa = DEFAULT_ENCODING_SA;\n\tsecy->tx_sc.encrypt = DEFAULT_ENCRYPT;\n\tsecy->tx_sc.send_sci = DEFAULT_SEND_SCI;\n\tsecy->tx_sc.end_station = false;\n\tsecy->tx_sc.scb = false;\n\n\treturn 0;\n}\n\nstatic struct lock_class_key macsec_netdev_addr_lock_key;\n\nstatic int macsec_newlink(struct net *net, struct net_device *dev,\n\t\t\t  struct nlattr *tb[], struct nlattr *data[],\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct macsec_dev *macsec = macsec_priv(dev);\n\trx_handler_func_t *rx_handler;\n\tu8 icv_len = MACSEC_DEFAULT_ICV_LEN;\n\tstruct net_device *real_dev;\n\tint err, mtu;\n\tsci_t sci;\n\n\tif (!tb[IFLA_LINK])\n\t\treturn -EINVAL;\n\treal_dev = __dev_get_by_index(net, nla_get_u32(tb[IFLA_LINK]));\n\tif (!real_dev)\n\t\treturn -ENODEV;\n\tif (real_dev->type != ARPHRD_ETHER)\n\t\treturn -EINVAL;\n\n\tdev->priv_flags |= IFF_MACSEC;\n\n\tmacsec->real_dev = real_dev;\n\n\tif (data && data[IFLA_MACSEC_OFFLOAD])\n\t\tmacsec->offload = nla_get_offload(data[IFLA_MACSEC_OFFLOAD]);\n\telse\n\t\t \n\t\tmacsec->offload = MACSEC_OFFLOAD_OFF;\n\n\t \n\tif (macsec->offload != MACSEC_OFFLOAD_OFF &&\n\t    !macsec_check_offload(macsec->offload, macsec))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif ((data && data[IFLA_MACSEC_SCI]) &&\n\t    (data && data[IFLA_MACSEC_INC_SCI])) {\n\t\tu8 send_sci = !!nla_get_u8(data[IFLA_MACSEC_INC_SCI]);\n\n\t\tif (!send_sci)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (data && data[IFLA_MACSEC_ICV_LEN])\n\t\ticv_len = nla_get_u8(data[IFLA_MACSEC_ICV_LEN]);\n\tmtu = real_dev->mtu - icv_len - macsec_extra_len(true);\n\tif (mtu < 0)\n\t\tdev->mtu = 0;\n\telse\n\t\tdev->mtu = mtu;\n\n\trx_handler = rtnl_dereference(real_dev->rx_handler);\n\tif (rx_handler && rx_handler != macsec_handle_frame)\n\t\treturn -EBUSY;\n\n\terr = register_netdevice(dev);\n\tif (err < 0)\n\t\treturn err;\n\n\tnetdev_lockdep_set_classes(dev);\n\tlockdep_set_class(&dev->addr_list_lock,\n\t\t\t  &macsec_netdev_addr_lock_key);\n\n\terr = netdev_upper_dev_link(real_dev, dev, extack);\n\tif (err < 0)\n\t\tgoto unregister;\n\n\t \n\tif (data && data[IFLA_MACSEC_SCI])\n\t\tsci = nla_get_sci(data[IFLA_MACSEC_SCI]);\n\telse if (data && data[IFLA_MACSEC_PORT])\n\t\tsci = dev_to_sci(dev, nla_get_be16(data[IFLA_MACSEC_PORT]));\n\telse\n\t\tsci = dev_to_sci(dev, MACSEC_PORT_ES);\n\n\tif (rx_handler && sci_exists(real_dev, sci)) {\n\t\terr = -EBUSY;\n\t\tgoto unlink;\n\t}\n\n\terr = macsec_add_dev(dev, sci, icv_len);\n\tif (err)\n\t\tgoto unlink;\n\n\tif (data) {\n\t\terr = macsec_changelink_common(dev, data);\n\t\tif (err)\n\t\t\tgoto del_dev;\n\t}\n\n\t \n\tif (macsec_is_offloaded(macsec)) {\n\t\tconst struct macsec_ops *ops;\n\t\tstruct macsec_context ctx;\n\n\t\tops = macsec_get_ops(macsec, &ctx);\n\t\tif (ops) {\n\t\t\tctx.secy = &macsec->secy;\n\t\t\terr = macsec_offload(ops->mdo_add_secy, &ctx);\n\t\t\tif (err)\n\t\t\t\tgoto del_dev;\n\t\t}\n\t}\n\n\terr = register_macsec_dev(real_dev, dev);\n\tif (err < 0)\n\t\tgoto del_dev;\n\n\tnetif_stacked_transfer_operstate(real_dev, dev);\n\tlinkwatch_fire_event(dev);\n\n\tmacsec_generation++;\n\n\treturn 0;\n\ndel_dev:\n\tmacsec_del_dev(macsec);\nunlink:\n\tnetdev_upper_dev_unlink(real_dev, dev);\nunregister:\n\tunregister_netdevice(dev);\n\treturn err;\n}\n\nstatic int macsec_validate_attr(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tu64 csid = MACSEC_DEFAULT_CIPHER_ID;\n\tu8 icv_len = MACSEC_DEFAULT_ICV_LEN;\n\tint flag;\n\tbool es, scb, sci;\n\n\tif (!data)\n\t\treturn 0;\n\n\tif (data[IFLA_MACSEC_CIPHER_SUITE])\n\t\tcsid = nla_get_u64(data[IFLA_MACSEC_CIPHER_SUITE]);\n\n\tif (data[IFLA_MACSEC_ICV_LEN]) {\n\t\ticv_len = nla_get_u8(data[IFLA_MACSEC_ICV_LEN]);\n\t\tif (icv_len != MACSEC_DEFAULT_ICV_LEN) {\n\t\t\tchar dummy_key[DEFAULT_SAK_LEN] = { 0 };\n\t\t\tstruct crypto_aead *dummy_tfm;\n\n\t\t\tdummy_tfm = macsec_alloc_tfm(dummy_key,\n\t\t\t\t\t\t     DEFAULT_SAK_LEN,\n\t\t\t\t\t\t     icv_len);\n\t\t\tif (IS_ERR(dummy_tfm))\n\t\t\t\treturn PTR_ERR(dummy_tfm);\n\t\t\tcrypto_free_aead(dummy_tfm);\n\t\t}\n\t}\n\n\tswitch (csid) {\n\tcase MACSEC_CIPHER_ID_GCM_AES_128:\n\tcase MACSEC_CIPHER_ID_GCM_AES_256:\n\tcase MACSEC_CIPHER_ID_GCM_AES_XPN_128:\n\tcase MACSEC_CIPHER_ID_GCM_AES_XPN_256:\n\tcase MACSEC_DEFAULT_CIPHER_ID:\n\t\tif (icv_len < MACSEC_MIN_ICV_LEN ||\n\t\t    icv_len > MACSEC_STD_ICV_LEN)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (data[IFLA_MACSEC_ENCODING_SA]) {\n\t\tif (nla_get_u8(data[IFLA_MACSEC_ENCODING_SA]) >= MACSEC_NUM_AN)\n\t\t\treturn -EINVAL;\n\t}\n\n\tfor (flag = IFLA_MACSEC_ENCODING_SA + 1;\n\t     flag < IFLA_MACSEC_VALIDATION;\n\t     flag++) {\n\t\tif (data[flag]) {\n\t\t\tif (nla_get_u8(data[flag]) > 1)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tes  = data[IFLA_MACSEC_ES] ? nla_get_u8(data[IFLA_MACSEC_ES]) : false;\n\tsci = data[IFLA_MACSEC_INC_SCI] ? nla_get_u8(data[IFLA_MACSEC_INC_SCI]) : false;\n\tscb = data[IFLA_MACSEC_SCB] ? nla_get_u8(data[IFLA_MACSEC_SCB]) : false;\n\n\tif ((sci && (scb || es)) || (scb && es))\n\t\treturn -EINVAL;\n\n\tif (data[IFLA_MACSEC_VALIDATION] &&\n\t    nla_get_u8(data[IFLA_MACSEC_VALIDATION]) > MACSEC_VALIDATE_MAX)\n\t\treturn -EINVAL;\n\n\tif ((data[IFLA_MACSEC_REPLAY_PROTECT] &&\n\t     nla_get_u8(data[IFLA_MACSEC_REPLAY_PROTECT])) &&\n\t    !data[IFLA_MACSEC_WINDOW])\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic struct net *macsec_get_link_net(const struct net_device *dev)\n{\n\treturn dev_net(macsec_priv(dev)->real_dev);\n}\n\nstruct net_device *macsec_get_real_dev(const struct net_device *dev)\n{\n\treturn macsec_priv(dev)->real_dev;\n}\nEXPORT_SYMBOL_GPL(macsec_get_real_dev);\n\nbool macsec_netdev_is_offloaded(struct net_device *dev)\n{\n\treturn macsec_is_offloaded(macsec_priv(dev));\n}\nEXPORT_SYMBOL_GPL(macsec_netdev_is_offloaded);\n\nstatic size_t macsec_get_size(const struct net_device *dev)\n{\n\treturn  nla_total_size_64bit(8) +  \n\t\tnla_total_size(1) +  \n\t\tnla_total_size_64bit(8) +  \n\t\tnla_total_size(4) +  \n\t\tnla_total_size(1) +  \n\t\tnla_total_size(1) +  \n\t\tnla_total_size(1) +  \n\t\tnla_total_size(1) +  \n\t\tnla_total_size(1) +  \n\t\tnla_total_size(1) +  \n\t\tnla_total_size(1) +  \n\t\tnla_total_size(1) +  \n\t\tnla_total_size(1) +  \n\t\t0;\n}\n\nstatic int macsec_fill_info(struct sk_buff *skb,\n\t\t\t    const struct net_device *dev)\n{\n\tstruct macsec_tx_sc *tx_sc;\n\tstruct macsec_dev *macsec;\n\tstruct macsec_secy *secy;\n\tu64 csid;\n\n\tmacsec = macsec_priv(dev);\n\tsecy = &macsec->secy;\n\ttx_sc = &secy->tx_sc;\n\n\tswitch (secy->key_len) {\n\tcase MACSEC_GCM_AES_128_SAK_LEN:\n\t\tcsid = secy->xpn ? MACSEC_CIPHER_ID_GCM_AES_XPN_128 : MACSEC_DEFAULT_CIPHER_ID;\n\t\tbreak;\n\tcase MACSEC_GCM_AES_256_SAK_LEN:\n\t\tcsid = secy->xpn ? MACSEC_CIPHER_ID_GCM_AES_XPN_256 : MACSEC_CIPHER_ID_GCM_AES_256;\n\t\tbreak;\n\tdefault:\n\t\tgoto nla_put_failure;\n\t}\n\n\tif (nla_put_sci(skb, IFLA_MACSEC_SCI, secy->sci,\n\t\t\tIFLA_MACSEC_PAD) ||\n\t    nla_put_u8(skb, IFLA_MACSEC_ICV_LEN, secy->icv_len) ||\n\t    nla_put_u64_64bit(skb, IFLA_MACSEC_CIPHER_SUITE,\n\t\t\t      csid, IFLA_MACSEC_PAD) ||\n\t    nla_put_u8(skb, IFLA_MACSEC_ENCODING_SA, tx_sc->encoding_sa) ||\n\t    nla_put_u8(skb, IFLA_MACSEC_ENCRYPT, tx_sc->encrypt) ||\n\t    nla_put_u8(skb, IFLA_MACSEC_PROTECT, secy->protect_frames) ||\n\t    nla_put_u8(skb, IFLA_MACSEC_INC_SCI, tx_sc->send_sci) ||\n\t    nla_put_u8(skb, IFLA_MACSEC_ES, tx_sc->end_station) ||\n\t    nla_put_u8(skb, IFLA_MACSEC_SCB, tx_sc->scb) ||\n\t    nla_put_u8(skb, IFLA_MACSEC_REPLAY_PROTECT, secy->replay_protect) ||\n\t    nla_put_u8(skb, IFLA_MACSEC_VALIDATION, secy->validate_frames) ||\n\t    nla_put_u8(skb, IFLA_MACSEC_OFFLOAD, macsec->offload) ||\n\t    0)\n\t\tgoto nla_put_failure;\n\n\tif (secy->replay_protect) {\n\t\tif (nla_put_u32(skb, IFLA_MACSEC_WINDOW, secy->replay_window))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic struct rtnl_link_ops macsec_link_ops __read_mostly = {\n\t.kind\t\t= \"macsec\",\n\t.priv_size\t= sizeof(struct macsec_dev),\n\t.maxtype\t= IFLA_MACSEC_MAX,\n\t.policy\t\t= macsec_rtnl_policy,\n\t.setup\t\t= macsec_setup,\n\t.validate\t= macsec_validate_attr,\n\t.newlink\t= macsec_newlink,\n\t.changelink\t= macsec_changelink,\n\t.dellink\t= macsec_dellink,\n\t.get_size\t= macsec_get_size,\n\t.fill_info\t= macsec_fill_info,\n\t.get_link_net\t= macsec_get_link_net,\n};\n\nstatic bool is_macsec_master(struct net_device *dev)\n{\n\treturn rcu_access_pointer(dev->rx_handler) == macsec_handle_frame;\n}\n\nstatic int macsec_notify(struct notifier_block *this, unsigned long event,\n\t\t\t void *ptr)\n{\n\tstruct net_device *real_dev = netdev_notifier_info_to_dev(ptr);\n\tLIST_HEAD(head);\n\n\tif (!is_macsec_master(real_dev))\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_DOWN:\n\tcase NETDEV_UP:\n\tcase NETDEV_CHANGE: {\n\t\tstruct macsec_dev *m, *n;\n\t\tstruct macsec_rxh_data *rxd;\n\n\t\trxd = macsec_data_rtnl(real_dev);\n\t\tlist_for_each_entry_safe(m, n, &rxd->secys, secys) {\n\t\t\tstruct net_device *dev = m->secy.netdev;\n\n\t\t\tnetif_stacked_transfer_operstate(real_dev, dev);\n\t\t}\n\t\tbreak;\n\t}\n\tcase NETDEV_UNREGISTER: {\n\t\tstruct macsec_dev *m, *n;\n\t\tstruct macsec_rxh_data *rxd;\n\n\t\trxd = macsec_data_rtnl(real_dev);\n\t\tlist_for_each_entry_safe(m, n, &rxd->secys, secys) {\n\t\t\tmacsec_common_dellink(m->secy.netdev, &head);\n\t\t}\n\n\t\tnetdev_rx_handler_unregister(real_dev);\n\t\tkfree(rxd);\n\n\t\tunregister_netdevice_many(&head);\n\t\tbreak;\n\t}\n\tcase NETDEV_CHANGEMTU: {\n\t\tstruct macsec_dev *m;\n\t\tstruct macsec_rxh_data *rxd;\n\n\t\trxd = macsec_data_rtnl(real_dev);\n\t\tlist_for_each_entry(m, &rxd->secys, secys) {\n\t\t\tstruct net_device *dev = m->secy.netdev;\n\t\t\tunsigned int mtu = real_dev->mtu - (m->secy.icv_len +\n\t\t\t\t\t\t\t    macsec_extra_len(true));\n\n\t\t\tif (dev->mtu > mtu)\n\t\t\t\tdev_set_mtu(dev, mtu);\n\t\t}\n\t}\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block macsec_notifier = {\n\t.notifier_call = macsec_notify,\n};\n\nstatic int __init macsec_init(void)\n{\n\tint err;\n\n\tpr_info(\"MACsec IEEE 802.1AE\\n\");\n\terr = register_netdevice_notifier(&macsec_notifier);\n\tif (err)\n\t\treturn err;\n\n\terr = rtnl_link_register(&macsec_link_ops);\n\tif (err)\n\t\tgoto notifier;\n\n\terr = genl_register_family(&macsec_fam);\n\tif (err)\n\t\tgoto rtnl;\n\n\treturn 0;\n\nrtnl:\n\trtnl_link_unregister(&macsec_link_ops);\nnotifier:\n\tunregister_netdevice_notifier(&macsec_notifier);\n\treturn err;\n}\n\nstatic void __exit macsec_exit(void)\n{\n\tgenl_unregister_family(&macsec_fam);\n\trtnl_link_unregister(&macsec_link_ops);\n\tunregister_netdevice_notifier(&macsec_notifier);\n\trcu_barrier();\n}\n\nmodule_init(macsec_init);\nmodule_exit(macsec_exit);\n\nMODULE_ALIAS_RTNL_LINK(\"macsec\");\nMODULE_ALIAS_GENL_FAMILY(\"macsec\");\n\nMODULE_DESCRIPTION(\"MACsec IEEE 802.1AE\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}