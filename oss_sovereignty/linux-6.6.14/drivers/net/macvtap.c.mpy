{
  "module_name": "macvtap.c",
  "hash_id": "6ebb13c84a046dd9da8b8144bab3bb6b176f825295dfdab7d0d132010fce901a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/macvtap.c",
  "human_readable_source": "\n#include <linux/etherdevice.h>\n#include <linux/if_macvlan.h>\n#include <linux/if_tap.h>\n#include <linux/if_vlan.h>\n#include <linux/interrupt.h>\n#include <linux/nsproxy.h>\n#include <linux/compat.h>\n#include <linux/if_tun.h>\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/cache.h>\n#include <linux/sched/signal.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/cdev.h>\n#include <linux/idr.h>\n#include <linux/fs.h>\n#include <linux/uio.h>\n\n#include <net/net_namespace.h>\n#include <net/rtnetlink.h>\n#include <net/sock.h>\n#include <linux/virtio_net.h>\n#include <linux/skb_array.h>\n\nstruct macvtap_dev {\n\tstruct macvlan_dev vlan;\n\tstruct tap_dev    tap;\n};\n\n \nstatic dev_t macvtap_major;\n\nstatic const void *macvtap_net_namespace(const struct device *d)\n{\n\tconst struct net_device *dev = to_net_dev(d->parent);\n\treturn dev_net(dev);\n}\n\nstatic struct class macvtap_class = {\n\t.name = \"macvtap\",\n\t.ns_type = &net_ns_type_operations,\n\t.namespace = macvtap_net_namespace,\n};\nstatic struct cdev macvtap_cdev;\n\n#define TUN_OFFLOADS (NETIF_F_HW_CSUM | NETIF_F_TSO_ECN | NETIF_F_TSO | \\\n\t\t      NETIF_F_TSO6)\n\nstatic void macvtap_count_tx_dropped(struct tap_dev *tap)\n{\n\tstruct macvtap_dev *vlantap = container_of(tap, struct macvtap_dev, tap);\n\tstruct macvlan_dev *vlan = &vlantap->vlan;\n\n\tthis_cpu_inc(vlan->pcpu_stats->tx_dropped);\n}\n\nstatic void macvtap_count_rx_dropped(struct tap_dev *tap)\n{\n\tstruct macvtap_dev *vlantap = container_of(tap, struct macvtap_dev, tap);\n\tstruct macvlan_dev *vlan = &vlantap->vlan;\n\n\tmacvlan_count_rx(vlan, 0, 0, 0);\n}\n\nstatic void macvtap_update_features(struct tap_dev *tap,\n\t\t\t\t    netdev_features_t features)\n{\n\tstruct macvtap_dev *vlantap = container_of(tap, struct macvtap_dev, tap);\n\tstruct macvlan_dev *vlan = &vlantap->vlan;\n\n\tvlan->set_features = features;\n\tnetdev_update_features(vlan->dev);\n}\n\nstatic int macvtap_newlink(struct net *src_net, struct net_device *dev,\n\t\t\t   struct nlattr *tb[], struct nlattr *data[],\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct macvtap_dev *vlantap = netdev_priv(dev);\n\tint err;\n\n\tINIT_LIST_HEAD(&vlantap->tap.queue_list);\n\n\t \n\tvlantap->tap.tap_features = TUN_OFFLOADS;\n\n\t \n\tvlantap->tap.count_tx_dropped = macvtap_count_tx_dropped;\n\tvlantap->tap.count_rx_dropped = macvtap_count_rx_dropped;\n\tvlantap->tap.update_features  = macvtap_update_features;\n\n\terr = netdev_rx_handler_register(dev, tap_handle_frame, &vlantap->tap);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = macvlan_common_newlink(src_net, dev, tb, data, extack);\n\tif (err) {\n\t\tnetdev_rx_handler_unregister(dev);\n\t\treturn err;\n\t}\n\n\tvlantap->tap.dev = vlantap->vlan.dev;\n\n\treturn 0;\n}\n\nstatic void macvtap_dellink(struct net_device *dev,\n\t\t\t    struct list_head *head)\n{\n\tstruct macvtap_dev *vlantap = netdev_priv(dev);\n\n\tnetdev_rx_handler_unregister(dev);\n\ttap_del_queues(&vlantap->tap);\n\tmacvlan_dellink(dev, head);\n}\n\nstatic void macvtap_setup(struct net_device *dev)\n{\n\tmacvlan_common_setup(dev);\n\tdev->tx_queue_len = TUN_READQ_SIZE;\n}\n\nstatic struct net *macvtap_link_net(const struct net_device *dev)\n{\n\treturn dev_net(macvlan_dev_real_dev(dev));\n}\n\nstatic struct rtnl_link_ops macvtap_link_ops __read_mostly = {\n\t.kind\t\t= \"macvtap\",\n\t.setup\t\t= macvtap_setup,\n\t.newlink\t= macvtap_newlink,\n\t.dellink\t= macvtap_dellink,\n\t.get_link_net\t= macvtap_link_net,\n\t.priv_size      = sizeof(struct macvtap_dev),\n};\n\nstatic int macvtap_device_event(struct notifier_block *unused,\n\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct macvtap_dev *vlantap;\n\tstruct device *classdev;\n\tdev_t devt;\n\tint err;\n\tchar tap_name[IFNAMSIZ];\n\n\tif (dev->rtnl_link_ops != &macvtap_link_ops)\n\t\treturn NOTIFY_DONE;\n\n\tsnprintf(tap_name, IFNAMSIZ, \"tap%d\", dev->ifindex);\n\tvlantap = netdev_priv(dev);\n\n\tswitch (event) {\n\tcase NETDEV_REGISTER:\n\t\t \n\t\terr = tap_get_minor(macvtap_major, &vlantap->tap);\n\t\tif (err)\n\t\t\treturn notifier_from_errno(err);\n\n\t\tdevt = MKDEV(MAJOR(macvtap_major), vlantap->tap.minor);\n\t\tclassdev = device_create(&macvtap_class, &dev->dev, devt,\n\t\t\t\t\t dev, \"%s\", tap_name);\n\t\tif (IS_ERR(classdev)) {\n\t\t\ttap_free_minor(macvtap_major, &vlantap->tap);\n\t\t\treturn notifier_from_errno(PTR_ERR(classdev));\n\t\t}\n\t\terr = sysfs_create_link(&dev->dev.kobj, &classdev->kobj,\n\t\t\t\t\ttap_name);\n\t\tif (err)\n\t\t\treturn notifier_from_errno(err);\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\t\t \n\t\tif (vlantap->tap.minor == 0)\n\t\t\tbreak;\n\t\tsysfs_remove_link(&dev->dev.kobj, tap_name);\n\t\tdevt = MKDEV(MAJOR(macvtap_major), vlantap->tap.minor);\n\t\tdevice_destroy(&macvtap_class, devt);\n\t\ttap_free_minor(macvtap_major, &vlantap->tap);\n\t\tbreak;\n\tcase NETDEV_CHANGE_TX_QUEUE_LEN:\n\t\tif (tap_queue_resize(&vlantap->tap))\n\t\t\treturn NOTIFY_BAD;\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block macvtap_notifier_block __read_mostly = {\n\t.notifier_call\t= macvtap_device_event,\n};\n\nstatic int __init macvtap_init(void)\n{\n\tint err;\n\n\terr = tap_create_cdev(&macvtap_cdev, &macvtap_major, \"macvtap\",\n\t\t\t      THIS_MODULE);\n\tif (err)\n\t\tgoto out1;\n\n\terr = class_register(&macvtap_class);\n\tif (err)\n\t\tgoto out2;\n\n\terr = register_netdevice_notifier(&macvtap_notifier_block);\n\tif (err)\n\t\tgoto out3;\n\n\terr = macvlan_link_register(&macvtap_link_ops);\n\tif (err)\n\t\tgoto out4;\n\n\treturn 0;\n\nout4:\n\tunregister_netdevice_notifier(&macvtap_notifier_block);\nout3:\n\tclass_unregister(&macvtap_class);\nout2:\n\ttap_destroy_cdev(macvtap_major, &macvtap_cdev);\nout1:\n\treturn err;\n}\nmodule_init(macvtap_init);\n\nstatic void __exit macvtap_exit(void)\n{\n\trtnl_link_unregister(&macvtap_link_ops);\n\tunregister_netdevice_notifier(&macvtap_notifier_block);\n\tclass_unregister(&macvtap_class);\n\ttap_destroy_cdev(macvtap_major, &macvtap_cdev);\n}\nmodule_exit(macvtap_exit);\n\nMODULE_ALIAS_RTNL_LINK(\"macvtap\");\nMODULE_AUTHOR(\"Arnd Bergmann <arnd@arndb.de>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}