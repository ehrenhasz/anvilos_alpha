{
  "module_name": "iosm_ipc_trace.c",
  "hash_id": "26f96f2985fa4d5068eb66349453444964e9352daca86d319a6dbda958d226e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wwan/iosm/iosm_ipc_trace.c",
  "human_readable_source": "\n \n\n#include <linux/wwan.h>\n#include \"iosm_ipc_trace.h\"\n\n \n#define IOSM_TRC_SUB_BUFF_SIZE 131072\n#define IOSM_TRC_N_SUB_BUFF 32\n\n#define IOSM_TRC_FILE_PERM 0600\n\n#define IOSM_TRC_DEBUGFS_TRACE \"trace\"\n#define IOSM_TRC_DEBUGFS_TRACE_CTRL \"trace_ctrl\"\n\n \nvoid ipc_trace_port_rx(struct iosm_imem *ipc_imem, struct sk_buff *skb)\n{\n\tstruct iosm_trace *ipc_trace = ipc_imem->trace;\n\n\tif (ipc_trace->ipc_rchan)\n\t\trelay_write(ipc_trace->ipc_rchan, skb->data, skb->len);\n\n\tdev_kfree_skb(skb);\n}\n\n \nstatic struct dentry *\nipc_trace_create_buf_file_handler(const char *filename,\n\t\t\t\t  struct dentry *parent,\n\t\t\t\t  umode_t mode,\n\t\t\t\t  struct rchan_buf *buf,\n\t\t\t\t  int *is_global)\n{\n\t*is_global = 1;\n\treturn debugfs_create_file(filename, mode, parent, buf,\n\t\t\t\t   &relay_file_operations);\n}\n\n \nstatic int ipc_trace_remove_buf_file_handler(struct dentry *dentry)\n{\n\tdebugfs_remove(dentry);\n\treturn 0;\n}\n\nstatic int ipc_trace_subbuf_start_handler(struct rchan_buf *buf, void *subbuf,\n\t\t\t\t\t  void *prev_subbuf,\n\t\t\t\t\t  size_t prev_padding)\n{\n\tif (relay_buf_full(buf)) {\n\t\tpr_err_ratelimited(\"Relay_buf full dropping traces\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nstatic struct rchan_callbacks relay_callbacks = {\n\t.subbuf_start = ipc_trace_subbuf_start_handler,\n\t.create_buf_file = ipc_trace_create_buf_file_handler,\n\t.remove_buf_file = ipc_trace_remove_buf_file_handler,\n};\n\n \nstatic ssize_t ipc_trace_ctrl_file_read(struct file *filp, char __user *buffer,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct iosm_trace *ipc_trace = filp->private_data;\n\tchar buf[16];\n\tint len;\n\n\tmutex_lock(&ipc_trace->trc_mutex);\n\tlen = snprintf(buf, sizeof(buf), \"%d\\n\", ipc_trace->mode);\n\tmutex_unlock(&ipc_trace->trc_mutex);\n\n\treturn simple_read_from_buffer(buffer, count, ppos, buf, len);\n}\n\n \nstatic ssize_t ipc_trace_ctrl_file_write(struct file *filp,\n\t\t\t\t\t const char __user *buffer,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct iosm_trace *ipc_trace = filp->private_data;\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(buffer, count, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&ipc_trace->trc_mutex);\n\tif (val == TRACE_ENABLE && ipc_trace->mode != TRACE_ENABLE) {\n\t\tipc_trace->channel = ipc_imem_sys_port_open(ipc_trace->ipc_imem,\n\t\t\t\t\t\t\t    ipc_trace->chl_id,\n\t\t\t\t\t\t\t    IPC_HP_CDEV_OPEN);\n\t\tif (!ipc_trace->channel) {\n\t\t\tret = -EIO;\n\t\t\tgoto unlock;\n\t\t}\n\t\tipc_trace->mode = TRACE_ENABLE;\n\t} else if (val == TRACE_DISABLE && ipc_trace->mode != TRACE_DISABLE) {\n\t\tipc_trace->mode = TRACE_DISABLE;\n\t\t \n\t\tipc_imem_sys_port_close(ipc_trace->ipc_imem,\n\t\t\t\t\tipc_trace->channel);\n\t\trelay_flush(ipc_trace->ipc_rchan);\n\t}\n\tret = count;\nunlock:\n\tmutex_unlock(&ipc_trace->trc_mutex);\n\treturn ret;\n}\n\nstatic const struct file_operations ipc_trace_fops = {\n\t.open = simple_open,\n\t.write = ipc_trace_ctrl_file_write,\n\t.read  = ipc_trace_ctrl_file_read,\n};\n\n \nstruct iosm_trace *ipc_trace_init(struct iosm_imem *ipc_imem)\n{\n\tstruct ipc_chnl_cfg chnl_cfg = { 0 };\n\tstruct iosm_trace *ipc_trace;\n\n\tipc_chnl_cfg_get(&chnl_cfg, IPC_MEM_CTRL_CHL_ID_3);\n\tipc_imem_channel_init(ipc_imem, IPC_CTYPE_CTRL, chnl_cfg,\n\t\t\t      IRQ_MOD_OFF);\n\n\tipc_trace = kzalloc(sizeof(*ipc_trace), GFP_KERNEL);\n\tif (!ipc_trace)\n\t\treturn NULL;\n\n\tipc_trace->mode = TRACE_DISABLE;\n\tipc_trace->dev = ipc_imem->dev;\n\tipc_trace->ipc_imem = ipc_imem;\n\tipc_trace->chl_id = IPC_MEM_CTRL_CHL_ID_3;\n\n\tmutex_init(&ipc_trace->trc_mutex);\n\n\tipc_trace->ctrl_file = debugfs_create_file(IOSM_TRC_DEBUGFS_TRACE_CTRL,\n\t\t\t\t\t\t   IOSM_TRC_FILE_PERM,\n\t\t\t\t\t\t   ipc_imem->debugfs_dir,\n\t\t\t\t\t\t   ipc_trace, &ipc_trace_fops);\n\n\tipc_trace->ipc_rchan = relay_open(IOSM_TRC_DEBUGFS_TRACE,\n\t\t\t\t\t  ipc_imem->debugfs_dir,\n\t\t\t\t\t  IOSM_TRC_SUB_BUFF_SIZE,\n\t\t\t\t\t  IOSM_TRC_N_SUB_BUFF,\n\t\t\t\t\t  &relay_callbacks, NULL);\n\n\treturn ipc_trace;\n}\n\n \nvoid ipc_trace_deinit(struct iosm_trace *ipc_trace)\n{\n\tif (!ipc_trace)\n\t\treturn;\n\n\tdebugfs_remove(ipc_trace->ctrl_file);\n\trelay_close(ipc_trace->ipc_rchan);\n\tmutex_destroy(&ipc_trace->trc_mutex);\n\tkfree(ipc_trace);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}