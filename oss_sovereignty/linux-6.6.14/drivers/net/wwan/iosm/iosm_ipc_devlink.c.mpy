{
  "module_name": "iosm_ipc_devlink.c",
  "hash_id": "ee379ff6b34db7e7c2cae7c2923236b1317c8ef4d360ce4c37451666fd874243",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wwan/iosm/iosm_ipc_devlink.c",
  "human_readable_source": "\n \n#include <linux/vmalloc.h>\n\n#include \"iosm_ipc_chnl_cfg.h\"\n#include \"iosm_ipc_coredump.h\"\n#include \"iosm_ipc_devlink.h\"\n#include \"iosm_ipc_flash.h\"\n\n \nstatic struct iosm_coredump_file_info list[IOSM_NOF_CD_REGION] = {\n\t{\"report.json\", REPORT_JSON_SIZE,},\n\t{\"coredump.fcd\", COREDUMP_FCD_SIZE,},\n\t{\"cdd.log\", CDD_LOG_SIZE,},\n\t{\"eeprom.bin\", EEPROM_BIN_SIZE,},\n\t{\"bootcore_trace.bin\", BOOTCORE_TRC_BIN_SIZE,},\n\t{\"bootcore_prev_trace.bin\", BOOTCORE_PREV_TRC_BIN_SIZE,},\n};\n\n \nstatic int ipc_devlink_get_param(struct devlink *dl, u32 id,\n\t\t\t\t struct devlink_param_gset_ctx *ctx)\n{\n\tstruct iosm_devlink *ipc_devlink = devlink_priv(dl);\n\n\tif (id == IOSM_DEVLINK_PARAM_ID_ERASE_FULL_FLASH)\n\t\tctx->val.vu8 = ipc_devlink->param.erase_full_flash;\n\n\treturn 0;\n}\n\n \nstatic int ipc_devlink_set_param(struct devlink *dl, u32 id,\n\t\t\t\t struct devlink_param_gset_ctx *ctx)\n{\n\tstruct iosm_devlink *ipc_devlink = devlink_priv(dl);\n\n\tif (id == IOSM_DEVLINK_PARAM_ID_ERASE_FULL_FLASH)\n\t\tipc_devlink->param.erase_full_flash = ctx->val.vu8;\n\n\treturn 0;\n}\n\n \nstatic const struct devlink_param iosm_devlink_params[] = {\n\tDEVLINK_PARAM_DRIVER(IOSM_DEVLINK_PARAM_ID_ERASE_FULL_FLASH,\n\t\t\t     \"erase_full_flash\", DEVLINK_PARAM_TYPE_BOOL,\n\t\t\t     BIT(DEVLINK_PARAM_CMODE_RUNTIME),\n\t\t\t     ipc_devlink_get_param, ipc_devlink_set_param,\n\t\t\t     NULL),\n};\n\n \nstatic enum iosm_flash_comp_type\nipc_devlink_get_flash_comp_type(const char comp_str[], u32 len)\n{\n\tenum iosm_flash_comp_type fls_type;\n\n\tif (!strncmp(\"PSI\", comp_str, len))\n\t\tfls_type = FLASH_COMP_TYPE_PSI;\n\telse if (!strncmp(\"EBL\", comp_str, len))\n\t\tfls_type = FLASH_COMP_TYPE_EBL;\n\telse if (!strncmp(\"FLS\", comp_str, len))\n\t\tfls_type = FLASH_COMP_TYPE_FLS;\n\telse\n\t\tfls_type = FLASH_COMP_TYPE_INVAL;\n\n\treturn fls_type;\n}\n\n \nstatic int ipc_devlink_flash_update(struct devlink *devlink,\n\t\t\t\t    struct devlink_flash_update_params *params,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct iosm_devlink *ipc_devlink = devlink_priv(devlink);\n\tenum iosm_flash_comp_type fls_type;\n\tstruct iosm_devlink_image *header;\n\tint rc = -EINVAL;\n\tu8 *mdm_rsp;\n\n\theader = (struct iosm_devlink_image *)params->fw->data;\n\n\tif (!header || params->fw->size <= IOSM_DEVLINK_HDR_SIZE ||\n\t    (memcmp(header->magic_header, IOSM_DEVLINK_MAGIC_HEADER,\n\t     IOSM_DEVLINK_MAGIC_HEADER_LEN) != 0))\n\t\treturn -EINVAL;\n\n\tmdm_rsp = kzalloc(IOSM_EBL_DW_PACK_SIZE, GFP_KERNEL);\n\tif (!mdm_rsp)\n\t\treturn -ENOMEM;\n\n\tfls_type = ipc_devlink_get_flash_comp_type(header->image_type,\n\t\t\t\t\t\t   IOSM_DEVLINK_MAX_IMG_LEN);\n\n\tswitch (fls_type) {\n\tcase FLASH_COMP_TYPE_PSI:\n\t\trc = ipc_flash_boot_psi(ipc_devlink, params->fw);\n\t\tbreak;\n\tcase FLASH_COMP_TYPE_EBL:\n\t\trc = ipc_flash_boot_ebl(ipc_devlink, params->fw);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = ipc_flash_boot_set_capabilities(ipc_devlink, mdm_rsp);\n\t\tif (rc)\n\t\t\tbreak;\n\t\trc = ipc_flash_read_swid(ipc_devlink, mdm_rsp);\n\t\tbreak;\n\tcase FLASH_COMP_TYPE_FLS:\n\t\trc = ipc_flash_send_fls(ipc_devlink, params->fw, mdm_rsp);\n\t\tbreak;\n\tdefault:\n\t\tdevlink_flash_update_status_notify(devlink, \"Invalid component\",\n\t\t\t\t\t\t   NULL, 0, 0);\n\t\tbreak;\n\t}\n\n\tif (!rc)\n\t\tdevlink_flash_update_status_notify(devlink, \"Flashing success\",\n\t\t\t\t\t\t   header->image_type, 0, 0);\n\telse\n\t\tdevlink_flash_update_status_notify(devlink, \"Flashing failed\",\n\t\t\t\t\t\t   header->image_type, 0, 0);\n\n\tkfree(mdm_rsp);\n\treturn rc;\n}\n\n \nstatic const struct devlink_ops devlink_flash_ops = {\n\t.flash_update = ipc_devlink_flash_update,\n};\n\n \nint ipc_devlink_send_cmd(struct iosm_devlink *ipc_devlink, u16 cmd, u32 entry)\n{\n\tstruct iosm_rpsi_cmd rpsi_cmd;\n\n\trpsi_cmd.param.dword = cpu_to_le32(entry);\n\trpsi_cmd.cmd = cpu_to_le16(cmd);\n\trpsi_cmd.crc = rpsi_cmd.param.word[0] ^ rpsi_cmd.param.word[1] ^\n\t\t       rpsi_cmd.cmd;\n\n\treturn ipc_imem_sys_devlink_write(ipc_devlink, (u8 *)&rpsi_cmd,\n\t\t\t\t\t  sizeof(rpsi_cmd));\n}\n\n \nstatic int ipc_devlink_coredump_snapshot(struct devlink *dl,\n\t\t\t\t\t const struct devlink_region_ops *ops,\n\t\t\t\t\t struct netlink_ext_ack *extack,\n\t\t\t\t\t u8 **data)\n{\n\tstruct iosm_devlink *ipc_devlink = devlink_priv(dl);\n\tstruct iosm_coredump_file_info *cd_list = ops->priv;\n\tu32 region_size;\n\tint rc;\n\n\tdev_dbg(ipc_devlink->dev, \"Region:%s, ID:%d\", ops->name,\n\t\tcd_list->entry);\n\tregion_size = cd_list->default_size;\n\trc = ipc_coredump_collect(ipc_devlink, data, cd_list->entry,\n\t\t\t\t  region_size);\n\tif (rc) {\n\t\tdev_err(ipc_devlink->dev, \"Fail to create snapshot,err %d\", rc);\n\t\tgoto coredump_collect_err;\n\t}\n\n\t \n\tif (cd_list->entry == (IOSM_NOF_CD_REGION - 1))\n\t\tipc_coredump_get_list(ipc_devlink, rpsi_cmd_coredump_end);\n\n\treturn 0;\n\ncoredump_collect_err:\n\tipc_coredump_get_list(ipc_devlink, rpsi_cmd_coredump_end);\n\treturn rc;\n}\n\n \nstatic int ipc_devlink_create_region(struct iosm_devlink *devlink)\n{\n\tstruct devlink_region_ops *mdm_coredump;\n\tint rc = 0;\n\tint i;\n\n\tmdm_coredump = devlink->iosm_devlink_mdm_coredump;\n\tfor (i = 0; i < IOSM_NOF_CD_REGION; i++) {\n\t\tmdm_coredump[i].name = list[i].filename;\n\t\tmdm_coredump[i].snapshot = ipc_devlink_coredump_snapshot;\n\t\tmdm_coredump[i].destructor = vfree;\n\t\tdevlink->cd_regions[i] =\n\t\t\tdevlink_region_create(devlink->devlink_ctx,\n\t\t\t\t\t      &mdm_coredump[i], MAX_SNAPSHOTS,\n\t\t\t\t\t      list[i].default_size);\n\n\t\tif (IS_ERR(devlink->cd_regions[i])) {\n\t\t\trc = PTR_ERR(devlink->cd_regions[i]);\n\t\t\tdev_err(devlink->dev, \"Devlink region fail,err %d\", rc);\n\t\t\t \n\t\t\tfor ( ; i >= 0; i--)\n\t\t\t\tdevlink_region_destroy(devlink->cd_regions[i]);\n\t\t\tgoto region_create_fail;\n\t\t}\n\t\tlist[i].entry = i;\n\t\tmdm_coredump[i].priv = list + i;\n\t}\nregion_create_fail:\n\treturn rc;\n}\n\n \nstatic void ipc_devlink_destroy_region(struct iosm_devlink *ipc_devlink)\n{\n\tu8 i;\n\n\tfor (i = 0; i < IOSM_NOF_CD_REGION; i++)\n\t\tdevlink_region_destroy(ipc_devlink->cd_regions[i]);\n}\n\n \nstruct iosm_devlink *ipc_devlink_init(struct iosm_imem *ipc_imem)\n{\n\tstruct ipc_chnl_cfg chnl_cfg_flash = { 0 };\n\tstruct iosm_devlink *ipc_devlink;\n\tstruct devlink *devlink_ctx;\n\tint rc;\n\n\tdevlink_ctx = devlink_alloc(&devlink_flash_ops,\n\t\t\t\t    sizeof(struct iosm_devlink),\n\t\t\t\t    ipc_imem->dev);\n\tif (!devlink_ctx) {\n\t\tdev_err(ipc_imem->dev, \"devlink_alloc failed\");\n\t\tgoto devlink_alloc_fail;\n\t}\n\n\tipc_devlink = devlink_priv(devlink_ctx);\n\tipc_devlink->devlink_ctx = devlink_ctx;\n\tipc_devlink->pcie = ipc_imem->pcie;\n\tipc_devlink->dev = ipc_imem->dev;\n\n\trc = devlink_params_register(devlink_ctx, iosm_devlink_params,\n\t\t\t\t     ARRAY_SIZE(iosm_devlink_params));\n\tif (rc) {\n\t\tdev_err(ipc_devlink->dev,\n\t\t\t\"devlink_params_register failed. rc %d\", rc);\n\t\tgoto param_reg_fail;\n\t}\n\n\tipc_devlink->cd_file_info = list;\n\n\trc = ipc_devlink_create_region(ipc_devlink);\n\tif (rc) {\n\t\tdev_err(ipc_devlink->dev, \"Devlink Region create failed, rc %d\",\n\t\t\trc);\n\t\tgoto region_create_fail;\n\t}\n\n\tif (ipc_chnl_cfg_get(&chnl_cfg_flash, IPC_MEM_CTRL_CHL_ID_7) < 0)\n\t\tgoto chnl_get_fail;\n\n\tipc_imem_channel_init(ipc_imem, IPC_CTYPE_CTRL,\n\t\t\t      chnl_cfg_flash, IRQ_MOD_OFF);\n\n\tinit_completion(&ipc_devlink->devlink_sio.read_sem);\n\tskb_queue_head_init(&ipc_devlink->devlink_sio.rx_list);\n\n\tdevlink_register(devlink_ctx);\n\tdev_dbg(ipc_devlink->dev, \"iosm devlink register success\");\n\n\treturn ipc_devlink;\n\nchnl_get_fail:\n\tipc_devlink_destroy_region(ipc_devlink);\nregion_create_fail:\n\tdevlink_params_unregister(devlink_ctx, iosm_devlink_params,\n\t\t\t\t  ARRAY_SIZE(iosm_devlink_params));\nparam_reg_fail:\n\tdevlink_free(devlink_ctx);\ndevlink_alloc_fail:\n\treturn NULL;\n}\n\n \nvoid ipc_devlink_deinit(struct iosm_devlink *ipc_devlink)\n{\n\tstruct devlink *devlink_ctx = ipc_devlink->devlink_ctx;\n\n\tdevlink_unregister(devlink_ctx);\n\tipc_devlink_destroy_region(ipc_devlink);\n\tdevlink_params_unregister(devlink_ctx, iosm_devlink_params,\n\t\t\t\t  ARRAY_SIZE(iosm_devlink_params));\n\tif (ipc_devlink->devlink_sio.devlink_read_pend) {\n\t\tcomplete(&ipc_devlink->devlink_sio.read_sem);\n\t\tcomplete(&ipc_devlink->devlink_sio.channel->ul_sem);\n\t}\n\tif (!ipc_devlink->devlink_sio.devlink_read_pend)\n\t\tskb_queue_purge(&ipc_devlink->devlink_sio.rx_list);\n\n\tipc_imem_sys_devlink_close(ipc_devlink);\n\tdevlink_free(devlink_ctx);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}