{
  "module_name": "iosm_ipc_mux.c",
  "hash_id": "0fce04d0b5f924bf46d43e6b3908adb0622aa2647a04f56bcb3dadb74ed26408",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wwan/iosm/iosm_ipc_mux.c",
  "human_readable_source": "\n \n\n#include \"iosm_ipc_mux_codec.h\"\n\n \nstatic int ipc_mux_channel_create(struct iosm_mux *ipc_mux)\n{\n\tint channel_id;\n\n\tchannel_id = ipc_imem_channel_alloc(ipc_mux->imem, ipc_mux->instance_id,\n\t\t\t\t\t    IPC_CTYPE_WWAN);\n\n\tif (channel_id < 0) {\n\t\tdev_err(ipc_mux->dev,\n\t\t\t\"allocation of the MUX channel id failed\");\n\t\tipc_mux->state = MUX_S_ERROR;\n\t\tipc_mux->event = MUX_E_NOT_APPLICABLE;\n\t\tgoto no_channel;\n\t}\n\n\t \n\tipc_mux->channel = ipc_imem_channel_open(ipc_mux->imem, channel_id,\n\t\t\t\t\t\t IPC_HP_NET_CHANNEL_INIT);\n\n\tif (!ipc_mux->channel) {\n\t\tdev_err(ipc_mux->dev, \"ipc_imem_channel_open failed\");\n\t\tipc_mux->state = MUX_S_ERROR;\n\t\tipc_mux->event = MUX_E_NOT_APPLICABLE;\n\t\treturn -ENODEV;  \n\t}\n\n\t \n\tipc_mux->state = MUX_S_ACTIVE;\n\tipc_mux->event = MUX_E_NO_ORDERS;\n\nno_channel:\n\treturn channel_id;\n}\n\n \nstatic void ipc_mux_session_free(struct iosm_mux *ipc_mux, int if_id)\n{\n\tstruct mux_session *if_entry;\n\n\tif_entry = &ipc_mux->session[if_id];\n\t \n\tif_entry->wwan = NULL;\n}\n\n \nstatic struct mux_cmd_open_session_resp *\nipc_mux_session_open_send(struct iosm_mux *ipc_mux, int if_id)\n{\n\tstruct mux_cmd_open_session_resp *open_session_resp;\n\tstruct mux_acb *acb = &ipc_mux->acb;\n\tunion mux_cmd_param param;\n\n\t \n\tparam.open_session.flow_ctrl = 0;\n\tparam.open_session.ipv4v6_hints = 0;\n\tparam.open_session.reserved2 = 0;\n\tparam.open_session.dl_head_pad_len = cpu_to_le32(IPC_MEM_DL_ETH_OFFSET);\n\n\t \n\tacb->wanted_response = MUX_CMD_OPEN_SESSION_RESP;\n\tif (ipc_mux_dl_acb_send_cmds(ipc_mux, MUX_CMD_OPEN_SESSION, if_id, 0,\n\t\t\t\t     &param, sizeof(param.open_session), true,\n\t\t\t\t false) ||\n\t    acb->got_response != MUX_CMD_OPEN_SESSION_RESP) {\n\t\tdev_err(ipc_mux->dev, \"if_id %d: OPEN_SESSION send failed\",\n\t\t\tif_id);\n\t\treturn NULL;\n\t}\n\n\topen_session_resp = &ipc_mux->acb.got_param.open_session_resp;\n\tif (open_session_resp->response != cpu_to_le32(MUX_CMD_RESP_SUCCESS)) {\n\t\tdev_err(ipc_mux->dev,\n\t\t\t\"if_id %d,session open failed,response=%d\", if_id,\n\t\t\topen_session_resp->response);\n\t\treturn NULL;\n\t}\n\n\treturn open_session_resp;\n}\n\n \nstatic bool ipc_mux_session_open(struct iosm_mux *ipc_mux,\n\t\t\t\t struct mux_session_open *session_open)\n{\n\tstruct mux_cmd_open_session_resp *open_session_resp;\n\tint if_id;\n\n\t \n\tif_id = le32_to_cpu(session_open->if_id);\n\tif (if_id < 0 || if_id >= IPC_MEM_MUX_IP_SESSION_ENTRIES) {\n\t\tdev_err(ipc_mux->dev, \"invalid interface id=%d\", if_id);\n\t\treturn false;\n\t}\n\n\t \n\topen_session_resp = ipc_mux_session_open_send(ipc_mux, if_id);\n\tif (!open_session_resp) {\n\t\tipc_mux_session_free(ipc_mux, if_id);\n\t\tsession_open->if_id = cpu_to_le32(-1);\n\t\treturn false;\n\t}\n\n\t \n\tskb_queue_head_init(&ipc_mux->session[if_id].ul_list);\n\n\tipc_mux->session[if_id].dl_head_pad_len = IPC_MEM_DL_ETH_OFFSET;\n\tipc_mux->session[if_id].ul_head_pad_len =\n\t\tle32_to_cpu(open_session_resp->ul_head_pad_len);\n\tipc_mux->session[if_id].wwan = ipc_mux->wwan;\n\n\t \n\tipc_mux->session[if_id].flow_ctl_en_cnt = 0;\n\tipc_mux->session[if_id].flow_ctl_dis_cnt = 0;\n\tipc_mux->session[if_id].ul_flow_credits = 0;\n\tipc_mux->session[if_id].net_tx_stop = false;\n\tipc_mux->session[if_id].flow_ctl_mask = 0;\n\n\t \n\tsession_open->if_id = cpu_to_le32(if_id);\n\tipc_mux->nr_sessions++;\n\n\treturn true;\n}\n\n \nstatic void ipc_mux_session_reset(struct iosm_mux *ipc_mux, int if_id)\n{\n\t \n\tipc_mux_session_free(ipc_mux, if_id);\n\n\t \n\tskb_queue_purge(&ipc_mux->session[if_id].ul_list);\n}\n\nstatic void ipc_mux_session_close(struct iosm_mux *ipc_mux,\n\t\t\t\t  struct mux_session_close *msg)\n{\n\tint if_id;\n\n\t \n\tif_id = le32_to_cpu(msg->if_id);\n\n\tif (if_id < 0 || if_id >= IPC_MEM_MUX_IP_SESSION_ENTRIES) {\n\t\tdev_err(ipc_mux->dev, \"invalid session id %d\", if_id);\n\t\treturn;\n\t}\n\n\t \n\tif (ipc_mux_dl_acb_send_cmds(ipc_mux, MUX_CMD_CLOSE_SESSION, if_id, 0,\n\t\t\t\t     NULL, 0, true, false))\n\t\tdev_err(ipc_mux->dev, \"if_id %d: CLOSE_SESSION send failed\",\n\t\t\tif_id);\n\n\t \n\tipc_mux->session[if_id].flow_ctl_en_cnt = 0;\n\tipc_mux->session[if_id].flow_ctl_dis_cnt = 0;\n\tipc_mux->session[if_id].flow_ctl_mask = 0;\n\n\tipc_mux_session_reset(ipc_mux, if_id);\n\tipc_mux->nr_sessions--;\n}\n\nstatic void ipc_mux_channel_close(struct iosm_mux *ipc_mux,\n\t\t\t\t  struct mux_channel_close *channel_close_p)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < IPC_MEM_MUX_IP_SESSION_ENTRIES; i++)\n\t\tif (ipc_mux->session[i].wwan)\n\t\t\tipc_mux_session_reset(ipc_mux, i);\n\n\tipc_imem_channel_close(ipc_mux->imem, ipc_mux->channel_id);\n\n\t \n\tipc_mux->state = MUX_S_INACTIVE;\n\tipc_mux->event = MUX_E_INACTIVE;\n}\n\n \nstatic int ipc_mux_schedule(struct iosm_mux *ipc_mux, union mux_msg *msg)\n{\n\tenum mux_event order;\n\tbool success;\n\tint ret = -EIO;\n\n\tif (!ipc_mux->initialized) {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\torder = msg->common.event;\n\n\tswitch (ipc_mux->state) {\n\tcase MUX_S_INACTIVE:\n\t\tif (order != MUX_E_MUX_SESSION_OPEN)\n\t\t\tgoto out;  \n\n\t\tif (ipc_mux->event == MUX_E_INACTIVE)\n\t\t\t \n\t\t\tipc_mux->channel_id = ipc_mux_channel_create(ipc_mux);\n\n\t\tif (ipc_mux->state != MUX_S_ACTIVE) {\n\t\t\tret = ipc_mux->channel_id;  \n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tipc_imem_td_update_timer_suspend(ipc_mux->imem, true);\n\t\tipc_mux->event = MUX_E_MUX_SESSION_OPEN;\n\t\tsuccess = ipc_mux_session_open(ipc_mux, &msg->session_open);\n\n\t\tipc_imem_td_update_timer_suspend(ipc_mux->imem, false);\n\t\tif (success)\n\t\t\tret = ipc_mux->channel_id;\n\t\tgoto out;\n\n\tcase MUX_S_ACTIVE:\n\t\tswitch (order) {\n\t\tcase MUX_E_MUX_SESSION_OPEN:\n\t\t\t \n\t\t\tipc_imem_td_update_timer_suspend(ipc_mux->imem, true);\n\t\t\tipc_mux->event = MUX_E_MUX_SESSION_OPEN;\n\t\t\tsuccess = ipc_mux_session_open(ipc_mux,\n\t\t\t\t\t\t       &msg->session_open);\n\t\t\tipc_imem_td_update_timer_suspend(ipc_mux->imem, false);\n\t\t\tif (success)\n\t\t\t\tret = ipc_mux->channel_id;\n\t\t\tgoto out;\n\n\t\tcase MUX_E_MUX_SESSION_CLOSE:\n\t\t\t \n\t\t\tipc_mux->event = MUX_E_MUX_SESSION_CLOSE;\n\t\t\tipc_mux_session_close(ipc_mux, &msg->session_close);\n\t\t\tif (!ipc_mux->nr_sessions) {\n\t\t\t\tipc_mux->event = MUX_E_MUX_CHANNEL_CLOSE;\n\t\t\t\tipc_mux_channel_close(ipc_mux,\n\t\t\t\t\t\t      &msg->channel_close);\n\t\t\t}\n\t\t\tret = ipc_mux->channel_id;\n\t\t\tgoto out;\n\n\t\tcase MUX_E_MUX_CHANNEL_CLOSE:\n\t\t\t \n\t\t\tipc_mux->event = MUX_E_MUX_CHANNEL_CLOSE;\n\t\t\tipc_mux_channel_close(ipc_mux, &msg->channel_close);\n\t\t\tret = ipc_mux->channel_id;\n\t\t\tgoto out;\n\n\t\tdefault:\n\t\t\t \n\t\t\tgoto out;\n\t\t}\n\n\tdefault:\n\t\tdev_err(ipc_mux->dev,\n\t\t\t\"unexpected MUX transition: state=%d, event=%d\",\n\t\t\tipc_mux->state, ipc_mux->event);\n\t}\nout:\n\treturn ret;\n}\n\nstruct iosm_mux *ipc_mux_init(struct ipc_mux_config *mux_cfg,\n\t\t\t      struct iosm_imem *imem)\n{\n\tstruct iosm_mux *ipc_mux = kzalloc(sizeof(*ipc_mux), GFP_KERNEL);\n\tint i, j, ul_tds, ul_td_size;\n\tstruct sk_buff_head *free_list;\n\tstruct sk_buff *skb;\n\tint qlt_size;\n\n\tif (!ipc_mux)\n\t\treturn NULL;\n\n\tipc_mux->protocol = mux_cfg->protocol;\n\tipc_mux->ul_flow = mux_cfg->ul_flow;\n\tipc_mux->instance_id = mux_cfg->instance_id;\n\tipc_mux->wwan_q_offset = 0;\n\n\tipc_mux->pcie = imem->pcie;\n\tipc_mux->imem = imem;\n\tipc_mux->ipc_protocol = imem->ipc_protocol;\n\tipc_mux->dev = imem->dev;\n\tipc_mux->wwan = imem->wwan;\n\n\t \n\tfree_list = &ipc_mux->ul_adb.free_list;\n\n\t \n\tskb_queue_head_init(free_list);\n\n\tul_td_size = IPC_MEM_MAX_DL_MUX_LITE_BUF_SIZE;\n\n\tul_tds = IPC_MEM_MAX_TDS_MUX_LITE_UL;\n\n\tipc_mux->ul_adb.dest_skb = NULL;\n\n\tipc_mux->initialized = true;\n\tipc_mux->adb_prep_ongoing = false;\n\tipc_mux->size_needed = 0;\n\tipc_mux->ul_data_pend_bytes = 0;\n\tipc_mux->state = MUX_S_INACTIVE;\n\tipc_mux->ev_mux_net_transmit_pending = false;\n\tipc_mux->tx_transaction_id = 0;\n\tipc_mux->rr_next_session = 0;\n\tipc_mux->event = MUX_E_INACTIVE;\n\tipc_mux->channel_id = -1;\n\tipc_mux->channel = NULL;\n\n\tif (ipc_mux->protocol != MUX_LITE) {\n\t\tqlt_size = offsetof(struct mux_qlth, ql) +\n\t\t\t\tMUX_QUEUE_LEVEL * sizeof(struct mux_qlth_ql);\n\n\t\tfor (i = 0; i < IPC_MEM_MUX_IP_SESSION_ENTRIES; i++) {\n\t\t\tipc_mux->ul_adb.pp_qlt[i] = kzalloc(qlt_size,\n\t\t\t\t\t\t\t    GFP_ATOMIC);\n\t\t\tif (!ipc_mux->ul_adb.pp_qlt[i]) {\n\t\t\t\tfor (j = i - 1; j >= 0; j--)\n\t\t\t\t\tkfree(ipc_mux->ul_adb.pp_qlt[j]);\n\t\t\t\tkfree(ipc_mux);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\n\t\tul_td_size = IPC_MEM_MAX_UL_ADB_BUF_SIZE;\n\t\tul_tds = IPC_MEM_MAX_TDS_MUX_AGGR_UL;\n\t}\n\n\t \n\tfor (i = 0; i < ul_tds; i++) {\n\t\tdma_addr_t mapping;\n\n\t\tskb = ipc_pcie_alloc_skb(ipc_mux->pcie, ul_td_size, GFP_ATOMIC,\n\t\t\t\t\t &mapping, DMA_TO_DEVICE, 0);\n\t\tif (!skb) {\n\t\t\tipc_mux_deinit(ipc_mux);\n\t\t\treturn NULL;\n\t\t}\n\t\t \n\t\tskb_queue_tail(free_list, skb);\n\t}\n\n\treturn ipc_mux;\n}\n\n \nstatic void ipc_mux_restart_tx_for_all_sessions(struct iosm_mux *ipc_mux)\n{\n\tstruct mux_session *session;\n\tint idx;\n\n\tfor (idx = 0; idx < IPC_MEM_MUX_IP_SESSION_ENTRIES; idx++) {\n\t\tsession = &ipc_mux->session[idx];\n\n\t\tif (!session->wwan)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (session->flow_ctl_mask == 0) {\n\t\t\tsession->net_tx_stop = false;\n\t\t\tipc_mux_netif_tx_flowctrl(session, idx, false);\n\t\t}\n\t}\n}\n\n \nstatic void ipc_mux_stop_netif_for_all_sessions(struct iosm_mux *ipc_mux)\n{\n\tstruct mux_session *session;\n\tint idx;\n\n\tfor (idx = 0; idx < IPC_MEM_MUX_IP_SESSION_ENTRIES; idx++) {\n\t\tsession = &ipc_mux->session[idx];\n\n\t\tif (!session->wwan)\n\t\t\tcontinue;\n\n\t\tipc_mux_netif_tx_flowctrl(session, session->if_id, true);\n\t}\n}\n\nvoid ipc_mux_check_n_restart_tx(struct iosm_mux *ipc_mux)\n{\n\tif (ipc_mux->ul_flow == MUX_UL) {\n\t\tint low_thresh = IPC_MEM_MUX_UL_FLOWCTRL_LOW_B;\n\n\t\tif (ipc_mux->ul_data_pend_bytes < low_thresh)\n\t\t\tipc_mux_restart_tx_for_all_sessions(ipc_mux);\n\t}\n}\n\nint ipc_mux_get_max_sessions(struct iosm_mux *ipc_mux)\n{\n\treturn ipc_mux ? IPC_MEM_MUX_IP_SESSION_ENTRIES : -EFAULT;\n}\n\nenum ipc_mux_protocol ipc_mux_get_active_protocol(struct iosm_mux *ipc_mux)\n{\n\treturn ipc_mux ? ipc_mux->protocol : MUX_UNKNOWN;\n}\n\nint ipc_mux_open_session(struct iosm_mux *ipc_mux, int session_nr)\n{\n\tstruct mux_session_open *session_open;\n\tunion mux_msg mux_msg;\n\n\tsession_open = &mux_msg.session_open;\n\tsession_open->event = MUX_E_MUX_SESSION_OPEN;\n\n\tsession_open->if_id = cpu_to_le32(session_nr);\n\tipc_mux->session[session_nr].flags |= IPC_MEM_WWAN_MUX;\n\treturn ipc_mux_schedule(ipc_mux, &mux_msg);\n}\n\nint ipc_mux_close_session(struct iosm_mux *ipc_mux, int session_nr)\n{\n\tstruct mux_session_close *session_close;\n\tunion mux_msg mux_msg;\n\tint ret_val;\n\n\tsession_close = &mux_msg.session_close;\n\tsession_close->event = MUX_E_MUX_SESSION_CLOSE;\n\n\tsession_close->if_id = cpu_to_le32(session_nr);\n\tret_val = ipc_mux_schedule(ipc_mux, &mux_msg);\n\tipc_mux->session[session_nr].flags &= ~IPC_MEM_WWAN_MUX;\n\n\treturn ret_val;\n}\n\nvoid ipc_mux_deinit(struct iosm_mux *ipc_mux)\n{\n\tstruct mux_channel_close *channel_close;\n\tstruct sk_buff_head *free_list;\n\tunion mux_msg mux_msg;\n\tstruct sk_buff *skb;\n\n\tif (!ipc_mux->initialized)\n\t\treturn;\n\tipc_mux_stop_netif_for_all_sessions(ipc_mux);\n\n\tif (ipc_mux->state == MUX_S_ACTIVE) {\n\t\tchannel_close = &mux_msg.channel_close;\n\t\tchannel_close->event = MUX_E_MUX_CHANNEL_CLOSE;\n\t\tipc_mux_schedule(ipc_mux, &mux_msg);\n\t}\n\n\t \n\tfree_list = &ipc_mux->ul_adb.free_list;\n\n\t \n\twhile ((skb = skb_dequeue(free_list)))\n\t\tipc_pcie_kfree_skb(ipc_mux->pcie, skb);\n\n\tif (ipc_mux->channel) {\n\t\tipc_mux->channel->ul_pipe.is_open = false;\n\t\tipc_mux->channel->dl_pipe.is_open = false;\n\t}\n\n\tkfree(ipc_mux);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}