{
  "module_name": "iosm_ipc_pcie.c",
  "hash_id": "3ad6e0dadce388669299bd3d81cf515bdbae3bd2feaa1a5ba528cb9fe63b6d5b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wwan/iosm/iosm_ipc_pcie.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/bitfield.h>\n#include <linux/module.h>\n#include <net/rtnetlink.h>\n\n#include \"iosm_ipc_imem.h\"\n#include \"iosm_ipc_pcie.h\"\n#include \"iosm_ipc_protocol.h\"\n\nMODULE_DESCRIPTION(\"IOSM Driver\");\nMODULE_LICENSE(\"GPL v2\");\n\n \nstatic guid_t wwan_acpi_guid = GUID_INIT(0xbad01b75, 0x22a8, 0x4f48, 0x87, 0x92,\n\t\t\t\t       0xbd, 0xde, 0x94, 0x67, 0x74, 0x7d);\n\nstatic void ipc_pcie_resources_release(struct iosm_pcie *ipc_pcie)\n{\n\t \n\tipc_release_irq(ipc_pcie);\n\n\t \n\tiounmap(ipc_pcie->scratchpad);\n\n\t \n\tiounmap(ipc_pcie->ipc_regs);\n\n\t \n\tpci_release_regions(ipc_pcie->pci);\n}\n\nstatic void ipc_pcie_cleanup(struct iosm_pcie *ipc_pcie)\n{\n\t \n\tipc_imem_cleanup(ipc_pcie->imem);\n\n\tipc_pcie_resources_release(ipc_pcie);\n\n\t \n\tpci_disable_device(ipc_pcie->pci);\n}\n\nstatic void ipc_pcie_deinit(struct iosm_pcie *ipc_pcie)\n{\n\tkfree(ipc_pcie->imem);\n\tkfree(ipc_pcie);\n}\n\nstatic void ipc_pcie_remove(struct pci_dev *pci)\n{\n\tstruct iosm_pcie *ipc_pcie = pci_get_drvdata(pci);\n\n\tipc_pcie_cleanup(ipc_pcie);\n\n\tipc_pcie_deinit(ipc_pcie);\n}\n\nstatic int ipc_pcie_resources_request(struct iosm_pcie *ipc_pcie)\n{\n\tstruct pci_dev *pci = ipc_pcie->pci;\n\tu32 cap = 0;\n\tu32 ret;\n\n\t \n\tret = pci_request_regions(pci, \"IOSM_IPC\");\n\tif (ret) {\n\t\tdev_err(ipc_pcie->dev, \"failed pci request regions\");\n\t\tgoto pci_request_region_fail;\n\t}\n\n\t \n\tipc_pcie->ipc_regs = pci_ioremap_bar(pci, ipc_pcie->ipc_regs_bar_nr);\n\n\tif (!ipc_pcie->ipc_regs) {\n\t\tdev_err(ipc_pcie->dev, \"IPC REGS ioremap error\");\n\t\tret = -EBUSY;\n\t\tgoto ipc_regs_remap_fail;\n\t}\n\n\t \n\tipc_pcie->scratchpad =\n\t\tpci_ioremap_bar(pci, ipc_pcie->scratchpad_bar_nr);\n\n\tif (!ipc_pcie->scratchpad) {\n\t\tdev_err(ipc_pcie->dev, \"doorbell scratchpad ioremap error\");\n\t\tret = -EBUSY;\n\t\tgoto scratch_remap_fail;\n\t}\n\n\t \n\tret = ipc_acquire_irq(ipc_pcie);\n\tif (ret) {\n\t\tdev_err(ipc_pcie->dev, \"acquiring MSI irq failed!\");\n\t\tgoto irq_acquire_fail;\n\t}\n\n\t \n\tpci_set_master(pci);\n\n\t \n\tpcie_capability_read_dword(ipc_pcie->pci, PCI_EXP_DEVCAP2, &cap);\n\tif (cap & PCI_EXP_DEVCAP2_LTR)\n\t\tpcie_capability_set_word(ipc_pcie->pci, PCI_EXP_DEVCTL2,\n\t\t\t\t\t PCI_EXP_DEVCTL2_LTR_EN);\n\n\tdev_dbg(ipc_pcie->dev, \"link between AP and CP is fully on\");\n\n\treturn ret;\n\nirq_acquire_fail:\n\tiounmap(ipc_pcie->scratchpad);\nscratch_remap_fail:\n\tiounmap(ipc_pcie->ipc_regs);\nipc_regs_remap_fail:\n\tpci_release_regions(pci);\npci_request_region_fail:\n\treturn ret;\n}\n\nbool ipc_pcie_check_aspm_enabled(struct iosm_pcie *ipc_pcie,\n\t\t\t\t bool parent)\n{\n\tstruct pci_dev *pdev;\n\tu16 value = 0;\n\tu32 enabled;\n\n\tif (parent)\n\t\tpdev = ipc_pcie->pci->bus->self;\n\telse\n\t\tpdev = ipc_pcie->pci;\n\n\tpcie_capability_read_word(pdev, PCI_EXP_LNKCTL, &value);\n\tenabled = value & PCI_EXP_LNKCTL_ASPMC;\n\tdev_dbg(ipc_pcie->dev, \"ASPM L1: 0x%04X 0x%03X\", pdev->device, value);\n\n\treturn (enabled == PCI_EXP_LNKCTL_ASPM_L1 ||\n\t\tenabled == PCI_EXP_LNKCTL_ASPMC);\n}\n\nbool ipc_pcie_check_data_link_active(struct iosm_pcie *ipc_pcie)\n{\n\tstruct pci_dev *parent;\n\tu16 link_status = 0;\n\n\tif (!ipc_pcie->pci->bus || !ipc_pcie->pci->bus->self) {\n\t\tdev_err(ipc_pcie->dev, \"root port not found\");\n\t\treturn false;\n\t}\n\n\tparent = ipc_pcie->pci->bus->self;\n\n\tpcie_capability_read_word(parent, PCI_EXP_LNKSTA, &link_status);\n\tdev_dbg(ipc_pcie->dev, \"Link status: 0x%04X\", link_status);\n\n\treturn link_status & PCI_EXP_LNKSTA_DLLLA;\n}\n\nstatic bool ipc_pcie_check_aspm_supported(struct iosm_pcie *ipc_pcie,\n\t\t\t\t\t  bool parent)\n{\n\tstruct pci_dev *pdev;\n\tu32 support;\n\tu32 cap = 0;\n\n\tif (parent)\n\t\tpdev = ipc_pcie->pci->bus->self;\n\telse\n\t\tpdev = ipc_pcie->pci;\n\tpcie_capability_read_dword(pdev, PCI_EXP_LNKCAP, &cap);\n\tsupport = u32_get_bits(cap, PCI_EXP_LNKCAP_ASPMS);\n\tif (support < PCI_EXP_LNKCTL_ASPM_L1) {\n\t\tdev_dbg(ipc_pcie->dev, \"ASPM L1 not supported: 0x%04X\",\n\t\t\tpdev->device);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nvoid ipc_pcie_config_aspm(struct iosm_pcie *ipc_pcie)\n{\n\tbool parent_aspm_enabled, dev_aspm_enabled;\n\n\t \n\tif (!ipc_pcie_check_aspm_supported(ipc_pcie, true) ||\n\t    !ipc_pcie_check_aspm_supported(ipc_pcie, false))\n\t\treturn;\n\n\tparent_aspm_enabled = ipc_pcie_check_aspm_enabled(ipc_pcie, true);\n\tdev_aspm_enabled = ipc_pcie_check_aspm_enabled(ipc_pcie, false);\n\n\tdev_dbg(ipc_pcie->dev, \"ASPM parent: %s device: %s\",\n\t\tparent_aspm_enabled ? \"Enabled\" : \"Disabled\",\n\t\tdev_aspm_enabled ? \"Enabled\" : \"Disabled\");\n}\n\n \nstatic void ipc_pcie_config_init(struct iosm_pcie *ipc_pcie)\n{\n\t \n\tipc_pcie->ipc_regs_bar_nr = IPC_DOORBELL_BAR0;\n\n\t \n\tipc_pcie->scratchpad_bar_nr = IPC_SCRATCHPAD_BAR2;\n\tipc_pcie->doorbell_reg_offset = IPC_DOORBELL_CH_OFFSET;\n\tipc_pcie->doorbell_write = IPC_WRITE_PTR_REG_0;\n\tipc_pcie->doorbell_capture = IPC_CAPTURE_PTR_REG_0;\n}\n\n \nstatic enum ipc_pcie_sleep_state ipc_pcie_read_bios_cfg(struct device *dev)\n{\n\tenum ipc_pcie_sleep_state sleep_state = IPC_PCIE_D0L12;\n\tunion acpi_object *object;\n\tacpi_handle handle_acpi;\n\n\thandle_acpi = ACPI_HANDLE(dev);\n\tif (!handle_acpi) {\n\t\tpr_debug(\"pci device is NOT ACPI supporting device\\n\");\n\t\tgoto default_ret;\n\t}\n\n\tobject = acpi_evaluate_dsm(handle_acpi, &wwan_acpi_guid, 0, 3, NULL);\n\tif (!object)\n\t\tgoto default_ret;\n\n\tif (object->integer.value == 3)\n\t\tsleep_state = IPC_PCIE_D3L2;\n\n\tACPI_FREE(object);\n\ndefault_ret:\n\treturn sleep_state;\n}\n\nstatic int ipc_pcie_probe(struct pci_dev *pci,\n\t\t\t  const struct pci_device_id *pci_id)\n{\n\tstruct iosm_pcie *ipc_pcie = kzalloc(sizeof(*ipc_pcie), GFP_KERNEL);\n\tint ret;\n\n\tpr_debug(\"Probing device 0x%X from the vendor 0x%X\", pci_id->device,\n\t\t pci_id->vendor);\n\n\tif (!ipc_pcie)\n\t\tgoto ret_fail;\n\n\t \n\tipc_pcie->dev = &pci->dev;\n\n\t \n\tpci_set_drvdata(pci, ipc_pcie);\n\n\t \n\tipc_pcie->pci = pci;\n\n\t \n\tipc_pcie_config_init(ipc_pcie);\n\n\t \n\tif (pci_enable_device(pci)) {\n\t\tdev_err(ipc_pcie->dev, \"failed to enable the AP PCIe device\");\n\t\t \n\t\tgoto pci_enable_fail;\n\t}\n\n\tret = dma_set_mask(ipc_pcie->dev, DMA_BIT_MASK(64));\n\tif (ret) {\n\t\tdev_err(ipc_pcie->dev, \"Could not set PCI DMA mask: %d\", ret);\n\t\tgoto set_mask_fail;\n\t}\n\n\tipc_pcie_config_aspm(ipc_pcie);\n\tdev_dbg(ipc_pcie->dev, \"PCIe device enabled.\");\n\n\t \n\tipc_pcie->d3l2_support = ipc_pcie_read_bios_cfg(&pci->dev);\n\n\tipc_pcie->suspend = 0;\n\n\tif (ipc_pcie_resources_request(ipc_pcie))\n\t\tgoto resources_req_fail;\n\n\t \n\tipc_pcie->imem = ipc_imem_init(ipc_pcie, pci->device,\n\t\t\t\t       ipc_pcie->scratchpad, ipc_pcie->dev);\n\tif (!ipc_pcie->imem) {\n\t\tdev_err(ipc_pcie->dev, \"failed to init imem\");\n\t\tgoto imem_init_fail;\n\t}\n\n\treturn 0;\n\nimem_init_fail:\n\tipc_pcie_resources_release(ipc_pcie);\nresources_req_fail:\nset_mask_fail:\n\tpci_disable_device(pci);\npci_enable_fail:\n\tkfree(ipc_pcie);\nret_fail:\n\treturn -EIO;\n}\n\nstatic const struct pci_device_id iosm_ipc_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, INTEL_CP_DEVICE_7560_ID) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, INTEL_CP_DEVICE_7360_ID) },\n\t{}\n};\nMODULE_DEVICE_TABLE(pci, iosm_ipc_ids);\n\n \nstatic int __maybe_unused ipc_pcie_suspend_s2idle(struct iosm_pcie *ipc_pcie)\n{\n\tipc_cp_irq_sleep_control(ipc_pcie, IPC_MEM_DEV_PM_FORCE_SLEEP);\n\n\t \n\tsmp_mb__before_atomic();\n\n\tset_bit(0, &ipc_pcie->suspend);\n\n\t \n\tsmp_mb__after_atomic();\n\n\tipc_imem_pm_s2idle_sleep(ipc_pcie->imem, true);\n\n\treturn 0;\n}\n\n \nstatic int __maybe_unused ipc_pcie_resume_s2idle(struct iosm_pcie *ipc_pcie)\n{\n\tipc_cp_irq_sleep_control(ipc_pcie, IPC_MEM_DEV_PM_FORCE_ACTIVE);\n\n\tipc_imem_pm_s2idle_sleep(ipc_pcie->imem, false);\n\n\t \n\tsmp_mb__before_atomic();\n\n\tclear_bit(0, &ipc_pcie->suspend);\n\n\t \n\tsmp_mb__after_atomic();\n\treturn 0;\n}\n\nint __maybe_unused ipc_pcie_suspend(struct iosm_pcie *ipc_pcie)\n{\n\t \n\tipc_imem_pm_suspend(ipc_pcie->imem);\n\n\tdev_dbg(ipc_pcie->dev, \"SUSPEND done\");\n\treturn 0;\n}\n\nint __maybe_unused ipc_pcie_resume(struct iosm_pcie *ipc_pcie)\n{\n\t \n\tipc_imem_pm_resume(ipc_pcie->imem);\n\n\tdev_dbg(ipc_pcie->dev, \"RESUME done\");\n\treturn 0;\n}\n\nstatic int __maybe_unused ipc_pcie_suspend_cb(struct device *dev)\n{\n\tstruct iosm_pcie *ipc_pcie;\n\tstruct pci_dev *pdev;\n\n\tpdev = to_pci_dev(dev);\n\n\tipc_pcie = pci_get_drvdata(pdev);\n\n\tswitch (ipc_pcie->d3l2_support) {\n\tcase IPC_PCIE_D0L12:\n\t\tipc_pcie_suspend_s2idle(ipc_pcie);\n\t\tbreak;\n\tcase IPC_PCIE_D3L2:\n\t\tipc_pcie_suspend(ipc_pcie);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused ipc_pcie_resume_cb(struct device *dev)\n{\n\tstruct iosm_pcie *ipc_pcie;\n\tstruct pci_dev *pdev;\n\n\tpdev = to_pci_dev(dev);\n\n\tipc_pcie = pci_get_drvdata(pdev);\n\n\tswitch (ipc_pcie->d3l2_support) {\n\tcase IPC_PCIE_D0L12:\n\t\tipc_pcie_resume_s2idle(ipc_pcie);\n\t\tbreak;\n\tcase IPC_PCIE_D3L2:\n\t\tipc_pcie_resume(ipc_pcie);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(iosm_ipc_pm, ipc_pcie_suspend_cb, ipc_pcie_resume_cb);\n\nstatic struct pci_driver iosm_ipc_driver = {\n\t.name = KBUILD_MODNAME,\n\t.probe = ipc_pcie_probe,\n\t.remove = ipc_pcie_remove,\n\t.driver = {\n\t\t.pm = &iosm_ipc_pm,\n\t},\n\t.id_table = iosm_ipc_ids,\n};\nmodule_pci_driver(iosm_ipc_driver);\n\nint ipc_pcie_addr_map(struct iosm_pcie *ipc_pcie, unsigned char *data,\n\t\t      size_t size, dma_addr_t *mapping, int direction)\n{\n\tif (ipc_pcie->pci) {\n\t\t*mapping = dma_map_single(&ipc_pcie->pci->dev, data, size,\n\t\t\t\t\t  direction);\n\t\tif (dma_mapping_error(&ipc_pcie->pci->dev, *mapping)) {\n\t\t\tdev_err(ipc_pcie->dev, \"dma mapping failed\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid ipc_pcie_addr_unmap(struct iosm_pcie *ipc_pcie, size_t size,\n\t\t\t dma_addr_t mapping, int direction)\n{\n\tif (!mapping)\n\t\treturn;\n\tif (ipc_pcie->pci)\n\t\tdma_unmap_single(&ipc_pcie->pci->dev, mapping, size, direction);\n}\n\nstruct sk_buff *ipc_pcie_alloc_local_skb(struct iosm_pcie *ipc_pcie,\n\t\t\t\t\t gfp_t flags, size_t size)\n{\n\tstruct sk_buff *skb;\n\n\tif (!ipc_pcie || !size) {\n\t\tpr_err(\"invalid pcie object or size\");\n\t\treturn NULL;\n\t}\n\n\tskb = __netdev_alloc_skb(NULL, size, flags);\n\tif (!skb)\n\t\treturn NULL;\n\n\tIPC_CB(skb)->op_type = (u8)UL_DEFAULT;\n\tIPC_CB(skb)->mapping = 0;\n\n\treturn skb;\n}\n\nstruct sk_buff *ipc_pcie_alloc_skb(struct iosm_pcie *ipc_pcie, size_t size,\n\t\t\t\t   gfp_t flags, dma_addr_t *mapping,\n\t\t\t\t   int direction, size_t headroom)\n{\n\tstruct sk_buff *skb = ipc_pcie_alloc_local_skb(ipc_pcie, flags,\n\t\t\t\t\t\t       size + headroom);\n\tif (!skb)\n\t\treturn NULL;\n\n\tif (headroom)\n\t\tskb_reserve(skb, headroom);\n\n\tif (ipc_pcie_addr_map(ipc_pcie, skb->data, size, mapping, direction)) {\n\t\tdev_kfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tBUILD_BUG_ON(sizeof(*IPC_CB(skb)) > sizeof(skb->cb));\n\n\t \n\tIPC_CB(skb)->mapping = *mapping;\n\tIPC_CB(skb)->direction = direction;\n\tIPC_CB(skb)->len = size;\n\n\treturn skb;\n}\n\nvoid ipc_pcie_kfree_skb(struct iosm_pcie *ipc_pcie, struct sk_buff *skb)\n{\n\tif (!skb)\n\t\treturn;\n\n\tipc_pcie_addr_unmap(ipc_pcie, IPC_CB(skb)->len, IPC_CB(skb)->mapping,\n\t\t\t    IPC_CB(skb)->direction);\n\tIPC_CB(skb)->mapping = 0;\n\tdev_kfree_skb(skb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}