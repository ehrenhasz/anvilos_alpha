{
  "module_name": "iosm_ipc_protocol_ops.c",
  "hash_id": "eca82fdf8ca08c6f4ef0fee7c9979de7379cf93a13468672df6dd62a655ae04f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wwan/iosm/iosm_ipc_protocol_ops.c",
  "human_readable_source": "\n \n\n#include \"iosm_ipc_protocol.h\"\n#include \"iosm_ipc_protocol_ops.h\"\n\n \nstatic union ipc_mem_msg_entry *\nipc_protocol_free_msg_get(struct iosm_protocol *ipc_protocol, int *index)\n{\n\tu32 head = le32_to_cpu(ipc_protocol->p_ap_shm->msg_head);\n\tu32 new_head = (head + 1) % IPC_MEM_MSG_ENTRIES;\n\tunion ipc_mem_msg_entry *msg;\n\n\tif (new_head == le32_to_cpu(ipc_protocol->p_ap_shm->msg_tail)) {\n\t\tdev_err(ipc_protocol->dev, \"message ring is full\");\n\t\treturn NULL;\n\t}\n\n\t \n\tmsg = &ipc_protocol->p_ap_shm->msg_ring[head];\n\tmemset(msg, 0, sizeof(*msg));\n\n\t \n\t*index = head;\n\n\treturn msg;\n}\n\n \nvoid ipc_protocol_msg_hp_update(struct iosm_imem *ipc_imem)\n{\n\tstruct iosm_protocol *ipc_protocol = ipc_imem->ipc_protocol;\n\tu32 head = le32_to_cpu(ipc_protocol->p_ap_shm->msg_head);\n\tu32 new_head = (head + 1) % IPC_MEM_MSG_ENTRIES;\n\n\t \n\tipc_protocol->p_ap_shm->msg_head = cpu_to_le32(new_head);\n\tipc_protocol->old_msg_tail =\n\t\tle32_to_cpu(ipc_protocol->p_ap_shm->msg_tail);\n\n\tipc_pm_signal_hpda_doorbell(&ipc_protocol->pm, IPC_HP_MR, false);\n}\n\n \nstatic int ipc_protocol_msg_prepipe_open(struct iosm_protocol *ipc_protocol,\n\t\t\t\t\t union ipc_msg_prep_args *args)\n{\n\tint index;\n\tunion ipc_mem_msg_entry *msg =\n\t\tipc_protocol_free_msg_get(ipc_protocol, &index);\n\tstruct ipc_pipe *pipe = args->pipe_open.pipe;\n\tstruct ipc_protocol_td *tdr;\n\tstruct sk_buff **skbr;\n\n\tif (!msg) {\n\t\tdev_err(ipc_protocol->dev, \"failed to get free message\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tskbr = kcalloc(pipe->nr_of_entries, sizeof(*skbr), GFP_ATOMIC);\n\tif (!skbr)\n\t\treturn -ENOMEM;\n\n\t \n\ttdr = dma_alloc_coherent(&ipc_protocol->pcie->pci->dev,\n\t\t\t\t pipe->nr_of_entries * sizeof(*tdr),\n\t\t\t\t &pipe->phy_tdr_start, GFP_ATOMIC);\n\tif (!tdr) {\n\t\tkfree(skbr);\n\t\tdev_err(ipc_protocol->dev, \"tdr alloc error\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpipe->max_nr_of_queued_entries = pipe->nr_of_entries - 1;\n\tpipe->nr_of_queued_entries = 0;\n\tpipe->tdr_start = tdr;\n\tpipe->skbr_start = skbr;\n\tpipe->old_tail = 0;\n\n\tipc_protocol->p_ap_shm->head_array[pipe->pipe_nr] = 0;\n\n\tmsg->open_pipe.type_of_message = IPC_MEM_MSG_OPEN_PIPE;\n\tmsg->open_pipe.pipe_nr = pipe->pipe_nr;\n\tmsg->open_pipe.tdr_addr = cpu_to_le64(pipe->phy_tdr_start);\n\tmsg->open_pipe.tdr_entries = cpu_to_le16(pipe->nr_of_entries);\n\tmsg->open_pipe.accumulation_backoff =\n\t\t\t\tcpu_to_le32(pipe->accumulation_backoff);\n\tmsg->open_pipe.irq_vector = cpu_to_le32(pipe->irq);\n\n\treturn index;\n}\n\nstatic int ipc_protocol_msg_prepipe_close(struct iosm_protocol *ipc_protocol,\n\t\t\t\t\t  union ipc_msg_prep_args *args)\n{\n\tint index = -1;\n\tunion ipc_mem_msg_entry *msg =\n\t\tipc_protocol_free_msg_get(ipc_protocol, &index);\n\tstruct ipc_pipe *pipe = args->pipe_close.pipe;\n\n\tif (!msg)\n\t\treturn -EIO;\n\n\tmsg->close_pipe.type_of_message = IPC_MEM_MSG_CLOSE_PIPE;\n\tmsg->close_pipe.pipe_nr = pipe->pipe_nr;\n\n\tdev_dbg(ipc_protocol->dev, \"IPC_MEM_MSG_CLOSE_PIPE(pipe_nr=%d)\",\n\t\tmsg->close_pipe.pipe_nr);\n\n\treturn index;\n}\n\nstatic int ipc_protocol_msg_prep_sleep(struct iosm_protocol *ipc_protocol,\n\t\t\t\t       union ipc_msg_prep_args *args)\n{\n\tint index = -1;\n\tunion ipc_mem_msg_entry *msg =\n\t\tipc_protocol_free_msg_get(ipc_protocol, &index);\n\n\tif (!msg) {\n\t\tdev_err(ipc_protocol->dev, \"failed to get free message\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tmsg->host_sleep.type_of_message = IPC_MEM_MSG_SLEEP;\n\tmsg->host_sleep.target = args->sleep.target;  \n\n\t \n\tmsg->host_sleep.state = args->sleep.state;\n\n\tdev_dbg(ipc_protocol->dev, \"IPC_MEM_MSG_SLEEP(target=%d; state=%d)\",\n\t\tmsg->host_sleep.target, msg->host_sleep.state);\n\n\treturn index;\n}\n\nstatic int ipc_protocol_msg_prep_feature_set(struct iosm_protocol *ipc_protocol,\n\t\t\t\t\t     union ipc_msg_prep_args *args)\n{\n\tint index = -1;\n\tunion ipc_mem_msg_entry *msg =\n\t\tipc_protocol_free_msg_get(ipc_protocol, &index);\n\n\tif (!msg) {\n\t\tdev_err(ipc_protocol->dev, \"failed to get free message\");\n\t\treturn -EIO;\n\t}\n\n\tmsg->feature_set.type_of_message = IPC_MEM_MSG_FEATURE_SET;\n\tmsg->feature_set.reset_enable = args->feature_set.reset_enable <<\n\t\t\t\t\tRESET_BIT;\n\n\tdev_dbg(ipc_protocol->dev, \"IPC_MEM_MSG_FEATURE_SET(reset_enable=%d)\",\n\t\tmsg->feature_set.reset_enable >> RESET_BIT);\n\n\treturn index;\n}\n\n \nbool ipc_protocol_msg_process(struct iosm_imem *ipc_imem, int irq)\n{\n\tstruct iosm_protocol *ipc_protocol = ipc_imem->ipc_protocol;\n\tstruct ipc_rsp **rsp_ring = ipc_protocol->rsp_ring;\n\tbool msg_processed = false;\n\tu32 i;\n\n\tif (le32_to_cpu(ipc_protocol->p_ap_shm->msg_tail) >=\n\t\t\tIPC_MEM_MSG_ENTRIES) {\n\t\tdev_err(ipc_protocol->dev, \"msg_tail out of range: %d\",\n\t\t\tle32_to_cpu(ipc_protocol->p_ap_shm->msg_tail));\n\t\treturn msg_processed;\n\t}\n\n\tif (irq != IMEM_IRQ_DONT_CARE &&\n\t    irq != ipc_protocol->p_ap_shm->ci.msg_irq_vector)\n\t\treturn msg_processed;\n\n\tfor (i = ipc_protocol->old_msg_tail;\n\t     i != le32_to_cpu(ipc_protocol->p_ap_shm->msg_tail);\n\t     i = (i + 1) % IPC_MEM_MSG_ENTRIES) {\n\t\tunion ipc_mem_msg_entry *msg =\n\t\t\t&ipc_protocol->p_ap_shm->msg_ring[i];\n\n\t\tdev_dbg(ipc_protocol->dev, \"msg[%d]: type=%u status=%d\", i,\n\t\t\tmsg->common.type_of_message,\n\t\t\tmsg->common.completion_status);\n\n\t\t \n\t\tif (rsp_ring[i]) {\n\t\t\trsp_ring[i]->status =\n\t\t\t\tle32_to_cpu(msg->common.completion_status);\n\t\t\tcomplete(&rsp_ring[i]->completion);\n\t\t\trsp_ring[i] = NULL;\n\t\t}\n\t\tmsg_processed = true;\n\t}\n\n\tipc_protocol->old_msg_tail = i;\n\treturn msg_processed;\n}\n\n \nbool ipc_protocol_ul_td_send(struct iosm_protocol *ipc_protocol,\n\t\t\t     struct ipc_pipe *pipe,\n\t\t\t     struct sk_buff_head *p_ul_list)\n{\n\tstruct ipc_protocol_td *td;\n\tbool hpda_pending = false;\n\tstruct sk_buff *skb;\n\ts32 free_elements;\n\tu32 head;\n\tu32 tail;\n\n\tif (!ipc_protocol->p_ap_shm) {\n\t\tdev_err(ipc_protocol->dev, \"driver is not initialized\");\n\t\treturn false;\n\t}\n\n\t \n\thead = le32_to_cpu(ipc_protocol->p_ap_shm->head_array[pipe->pipe_nr]);\n\ttail = pipe->old_tail;\n\n\twhile (!skb_queue_empty(p_ul_list)) {\n\t\tif (head < tail)\n\t\t\tfree_elements = tail - head - 1;\n\t\telse\n\t\t\tfree_elements =\n\t\t\t\tpipe->nr_of_entries - head + ((s32)tail - 1);\n\n\t\tif (free_elements <= 0) {\n\t\t\tdev_dbg(ipc_protocol->dev,\n\t\t\t\t\"no free td elements for UL pipe %d\",\n\t\t\t\tpipe->pipe_nr);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\ttd = &pipe->tdr_start[head];\n\n\t\t \n\t\tskb = skb_dequeue(p_ul_list);\n\t\tif (WARN_ON(!skb))\n\t\t\tbreak;\n\n\t\t \n\t\tpipe->skbr_start[head] = skb;\n\n\t\ttd->buffer.address = IPC_CB(skb)->mapping;\n\t\ttd->scs = cpu_to_le32(skb->len) & cpu_to_le32(SIZE_MASK);\n\t\ttd->next = 0;\n\n\t\tpipe->nr_of_queued_entries++;\n\n\t\t \n\t\thead++;\n\t\tif (head >= pipe->nr_of_entries)\n\t\t\thead = 0;\n\n\t\tipc_protocol->p_ap_shm->head_array[pipe->pipe_nr] =\n\t\t\tcpu_to_le32(head);\n\t}\n\n\tif (pipe->old_head != head) {\n\t\tdev_dbg(ipc_protocol->dev, \"New UL TDs Pipe:%d\", pipe->pipe_nr);\n\n\t\tpipe->old_head = head;\n\t\t \n\t\thpda_pending = true;\n\t}\n\n\treturn hpda_pending;\n}\n\n \nstruct sk_buff *ipc_protocol_ul_td_process(struct iosm_protocol *ipc_protocol,\n\t\t\t\t\t   struct ipc_pipe *pipe)\n{\n\tstruct ipc_protocol_td *p_td = &pipe->tdr_start[pipe->old_tail];\n\tstruct sk_buff *skb = pipe->skbr_start[pipe->old_tail];\n\n\tpipe->nr_of_queued_entries--;\n\tpipe->old_tail++;\n\tif (pipe->old_tail >= pipe->nr_of_entries)\n\t\tpipe->old_tail = 0;\n\n\tif (!p_td->buffer.address) {\n\t\tdev_err(ipc_protocol->dev, \"Td buffer address is NULL\");\n\t\treturn NULL;\n\t}\n\n\tif (p_td->buffer.address != IPC_CB(skb)->mapping) {\n\t\tdev_err(ipc_protocol->dev,\n\t\t\t\"pipe %d: invalid buf_addr or skb_data\",\n\t\t\tpipe->pipe_nr);\n\t\treturn NULL;\n\t}\n\n\treturn skb;\n}\n\n \nbool ipc_protocol_dl_td_prepare(struct iosm_protocol *ipc_protocol,\n\t\t\t\tstruct ipc_pipe *pipe)\n{\n\tstruct ipc_protocol_td *td;\n\tdma_addr_t mapping = 0;\n\tu32 head, new_head;\n\tstruct sk_buff *skb;\n\tu32 tail;\n\n\t \n\thead = le32_to_cpu(ipc_protocol->p_ap_shm->head_array[pipe->pipe_nr]);\n\ttail = le32_to_cpu(ipc_protocol->p_ap_shm->tail_array[pipe->pipe_nr]);\n\n\tnew_head = head + 1;\n\tif (new_head >= pipe->nr_of_entries)\n\t\tnew_head = 0;\n\n\tif (new_head == tail)\n\t\treturn false;\n\n\t \n\ttd = &pipe->tdr_start[head];\n\n\t \n\tskb = ipc_pcie_alloc_skb(ipc_protocol->pcie, pipe->buf_size, GFP_ATOMIC,\n\t\t\t\t &mapping, DMA_FROM_DEVICE,\n\t\t\t\t IPC_MEM_DL_ETH_OFFSET);\n\tif (!skb)\n\t\treturn false;\n\n\ttd->buffer.address = mapping;\n\ttd->scs = cpu_to_le32(pipe->buf_size) & cpu_to_le32(SIZE_MASK);\n\ttd->next = 0;\n\n\t \n\tipc_protocol->p_ap_shm->head_array[pipe->pipe_nr] =\n\t\tcpu_to_le32(new_head);\n\n\t \n\tpipe->skbr_start[head] = skb;\n\n\tpipe->nr_of_queued_entries++;\n\n\treturn true;\n}\n\n \nstruct sk_buff *ipc_protocol_dl_td_process(struct iosm_protocol *ipc_protocol,\n\t\t\t\t\t   struct ipc_pipe *pipe)\n{\n\tstruct ipc_protocol_td *p_td;\n\tstruct sk_buff *skb;\n\n\tif (!pipe->tdr_start)\n\t\treturn NULL;\n\n\t \n\tp_td = &pipe->tdr_start[pipe->old_tail];\n\tskb = pipe->skbr_start[pipe->old_tail];\n\n\t \n\tpipe->skbr_start[pipe->old_tail] = NULL;\n\n\tpipe->nr_of_queued_entries--;\n\n\tpipe->old_tail++;\n\tif (pipe->old_tail >= pipe->nr_of_entries)\n\t\tpipe->old_tail = 0;\n\n\tif (!skb) {\n\t\tdev_err(ipc_protocol->dev, \"skb is null\");\n\t\tgoto ret;\n\t} else if (!p_td->buffer.address) {\n\t\tdev_err(ipc_protocol->dev, \"td/buffer address is null\");\n\t\tipc_pcie_kfree_skb(ipc_protocol->pcie, skb);\n\t\tskb = NULL;\n\t\tgoto ret;\n\t}\n\n\tif (p_td->buffer.address != IPC_CB(skb)->mapping) {\n\t\tdev_err(ipc_protocol->dev, \"invalid buf=%llx or skb=%p\",\n\t\t\t(unsigned long long)p_td->buffer.address, skb->data);\n\t\tipc_pcie_kfree_skb(ipc_protocol->pcie, skb);\n\t\tskb = NULL;\n\t\tgoto ret;\n\t} else if ((le32_to_cpu(p_td->scs) & SIZE_MASK) > pipe->buf_size) {\n\t\tdev_err(ipc_protocol->dev, \"invalid buffer size %d > %d\",\n\t\t\tle32_to_cpu(p_td->scs) & SIZE_MASK,\n\t\t\tpipe->buf_size);\n\t\tipc_pcie_kfree_skb(ipc_protocol->pcie, skb);\n\t\tskb = NULL;\n\t\tgoto ret;\n\t} else if (le32_to_cpu(p_td->scs) >> COMPLETION_STATUS ==\n\t\t  IPC_MEM_TD_CS_ABORT) {\n\t\t \n\t\tdev_dbg(ipc_protocol->dev, \"discard 'aborted' buffers\");\n\t\tipc_pcie_kfree_skb(ipc_protocol->pcie, skb);\n\t\tskb = NULL;\n\t\tgoto ret;\n\t}\n\n\t \n\tskb_put(skb, le32_to_cpu(p_td->scs) & SIZE_MASK);\n\nret:\n\treturn skb;\n}\n\nvoid ipc_protocol_get_head_tail_index(struct iosm_protocol *ipc_protocol,\n\t\t\t\t      struct ipc_pipe *pipe, u32 *head,\n\t\t\t\t      u32 *tail)\n{\n\tstruct ipc_protocol_ap_shm *ipc_ap_shm = ipc_protocol->p_ap_shm;\n\n\tif (head)\n\t\t*head = le32_to_cpu(ipc_ap_shm->head_array[pipe->pipe_nr]);\n\n\tif (tail)\n\t\t*tail = le32_to_cpu(ipc_ap_shm->tail_array[pipe->pipe_nr]);\n}\n\n \nvoid ipc_protocol_pipe_cleanup(struct iosm_protocol *ipc_protocol,\n\t\t\t       struct ipc_pipe *pipe)\n{\n\tstruct sk_buff *skb;\n\tu32 head;\n\tu32 tail;\n\n\t \n\thead = le32_to_cpu(ipc_protocol->p_ap_shm->head_array[pipe->pipe_nr]);\n\ttail = pipe->old_tail;\n\n\t \n\tipc_protocol->p_ap_shm->tail_array[pipe->pipe_nr] = 0;\n\tipc_protocol->p_ap_shm->head_array[pipe->pipe_nr] = 0;\n\n\t \n\tif (pipe->skbr_start) {\n\t\twhile (head != tail) {\n\t\t\t \n\t\t\tskb = pipe->skbr_start[tail];\n\t\t\tif (skb)\n\t\t\t\tipc_pcie_kfree_skb(ipc_protocol->pcie, skb);\n\n\t\t\ttail++;\n\t\t\tif (tail >= pipe->nr_of_entries)\n\t\t\t\ttail = 0;\n\t\t}\n\n\t\tkfree(pipe->skbr_start);\n\t\tpipe->skbr_start = NULL;\n\t}\n\n\tpipe->old_tail = 0;\n\n\t \n\tif (pipe->tdr_start) {\n\t\tdma_free_coherent(&ipc_protocol->pcie->pci->dev,\n\t\t\t\t  sizeof(*pipe->tdr_start) * pipe->nr_of_entries,\n\t\t\t\t  pipe->tdr_start, pipe->phy_tdr_start);\n\n\t\tpipe->tdr_start = NULL;\n\t}\n}\n\nenum ipc_mem_device_ipc_state ipc_protocol_get_ipc_status(struct iosm_protocol\n\t\t\t\t\t\t\t  *ipc_protocol)\n{\n\treturn (enum ipc_mem_device_ipc_state)\n\t\tle32_to_cpu(ipc_protocol->p_ap_shm->device_info.ipc_status);\n}\n\nenum ipc_mem_exec_stage\nipc_protocol_get_ap_exec_stage(struct iosm_protocol *ipc_protocol)\n{\n\treturn le32_to_cpu(ipc_protocol->p_ap_shm->device_info.execution_stage);\n}\n\nint ipc_protocol_msg_prep(struct iosm_imem *ipc_imem,\n\t\t\t  enum ipc_msg_prep_type msg_type,\n\t\t\t  union ipc_msg_prep_args *args)\n{\n\tstruct iosm_protocol *ipc_protocol = ipc_imem->ipc_protocol;\n\n\tswitch (msg_type) {\n\tcase IPC_MSG_PREP_SLEEP:\n\t\treturn ipc_protocol_msg_prep_sleep(ipc_protocol, args);\n\n\tcase IPC_MSG_PREP_PIPE_OPEN:\n\t\treturn ipc_protocol_msg_prepipe_open(ipc_protocol, args);\n\n\tcase IPC_MSG_PREP_PIPE_CLOSE:\n\t\treturn ipc_protocol_msg_prepipe_close(ipc_protocol, args);\n\n\tcase IPC_MSG_PREP_FEATURE_SET:\n\t\treturn ipc_protocol_msg_prep_feature_set(ipc_protocol, args);\n\n\t\t \n\tcase IPC_MSG_PREP_MAP:\n\tcase IPC_MSG_PREP_UNMAP:\n\tdefault:\n\t\tdev_err(ipc_protocol->dev,\n\t\t\t\"unsupported message type: %d in protocol\", msg_type);\n\t\treturn -EINVAL;\n\t}\n}\n\nu32\nipc_protocol_pm_dev_get_sleep_notification(struct iosm_protocol *ipc_protocol)\n{\n\tstruct ipc_protocol_ap_shm *ipc_ap_shm = ipc_protocol->p_ap_shm;\n\n\treturn le32_to_cpu(ipc_ap_shm->device_info.device_sleep_notification);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}