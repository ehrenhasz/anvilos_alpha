{
  "module_name": "iosm_ipc_mmio.c",
  "hash_id": "11782c27949b14b9ed9ac4867d2d67e074719b4bc651c94b2f1880f07d808bb1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wwan/iosm/iosm_ipc_mmio.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/slab.h>\n\n#include \"iosm_ipc_mmio.h\"\n#include \"iosm_ipc_mux.h\"\n\n \n\n \n#define MMIO_CHIP_INFO_SIZE 60\n\n \n#define MMIO_OFFSET_EXECUTION_STAGE 0x00\n\n \n#define MMIO_OFFSET_CHIP_INFO 0x04\n\n#define MMIO_OFFSET_ROM_EXIT_CODE 0x40\n\n#define MMIO_OFFSET_PSI_ADDRESS 0x54\n\n#define MMIO_OFFSET_PSI_SIZE 0x5C\n\n#define MMIO_OFFSET_IPC_STATUS 0x60\n\n#define MMIO_OFFSET_CONTEXT_INFO 0x64\n\n#define MMIO_OFFSET_BASE_ADDR 0x6C\n\n#define MMIO_OFFSET_END_ADDR 0x74\n\n#define MMIO_OFFSET_CP_VERSION 0xF0\n\n#define MMIO_OFFSET_CP_CAPABILITIES 0xF4\n\n \n#define IPC_MMIO_EXEC_STAGE_TIMEOUT 50\n\n \nstatic bool ipc_mmio_is_valid_exec_stage(enum ipc_mem_exec_stage stage)\n{\n\tswitch (stage) {\n\tcase IPC_MEM_EXEC_STAGE_BOOT:\n\tcase IPC_MEM_EXEC_STAGE_PSI:\n\tcase IPC_MEM_EXEC_STAGE_EBL:\n\tcase IPC_MEM_EXEC_STAGE_RUN:\n\tcase IPC_MEM_EXEC_STAGE_CRASH:\n\tcase IPC_MEM_EXEC_STAGE_CD_READY:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nvoid ipc_mmio_update_cp_capability(struct iosm_mmio *ipc_mmio)\n{\n\tu32 cp_cap;\n\tunsigned int ver;\n\n\tver = ipc_mmio_get_cp_version(ipc_mmio);\n\tcp_cap = ioread32(ipc_mmio->base + ipc_mmio->offset.cp_capability);\n\n\tipc_mmio->mux_protocol = ((ver >= IOSM_CP_VERSION) && (cp_cap &\n\t\t\t\t (UL_AGGR | DL_AGGR))) ? MUX_AGGREGATION\n\t\t\t\t : MUX_LITE;\n\n\tipc_mmio->has_ul_flow_credit =\n\t\t(ver >= IOSM_CP_VERSION) && (cp_cap & UL_FLOW_CREDIT);\n}\n\nstruct iosm_mmio *ipc_mmio_init(void __iomem *mmio, struct device *dev)\n{\n\tstruct iosm_mmio *ipc_mmio = kzalloc(sizeof(*ipc_mmio), GFP_KERNEL);\n\tint retries = IPC_MMIO_EXEC_STAGE_TIMEOUT;\n\tenum ipc_mem_exec_stage stage;\n\n\tif (!ipc_mmio)\n\t\treturn NULL;\n\n\tipc_mmio->dev = dev;\n\n\tipc_mmio->base = mmio;\n\n\tipc_mmio->offset.exec_stage = MMIO_OFFSET_EXECUTION_STAGE;\n\n\t \n\tdo {\n\t\tstage = ipc_mmio_get_exec_stage(ipc_mmio);\n\t\tif (ipc_mmio_is_valid_exec_stage(stage))\n\t\t\tbreak;\n\n\t\tmsleep(20);\n\t} while (retries-- > 0);\n\n\tif (!retries) {\n\t\tdev_err(ipc_mmio->dev, \"invalid exec stage %X\", stage);\n\t\tgoto init_fail;\n\t}\n\n\tipc_mmio->offset.chip_info = MMIO_OFFSET_CHIP_INFO;\n\n\t \n\tipc_mmio->chip_info_version =\n\t\tioread8(ipc_mmio->base + ipc_mmio->offset.chip_info);\n\n\t \n\tipc_mmio->chip_info_size =\n\t\tioread8(ipc_mmio->base + ipc_mmio->offset.chip_info + 1) + 2;\n\n\tif (ipc_mmio->chip_info_size != MMIO_CHIP_INFO_SIZE) {\n\t\tdev_err(ipc_mmio->dev, \"Unexpected Chip Info\");\n\t\tgoto init_fail;\n\t}\n\n\tipc_mmio->offset.rom_exit_code = MMIO_OFFSET_ROM_EXIT_CODE;\n\n\tipc_mmio->offset.psi_address = MMIO_OFFSET_PSI_ADDRESS;\n\tipc_mmio->offset.psi_size = MMIO_OFFSET_PSI_SIZE;\n\tipc_mmio->offset.ipc_status = MMIO_OFFSET_IPC_STATUS;\n\tipc_mmio->offset.context_info = MMIO_OFFSET_CONTEXT_INFO;\n\tipc_mmio->offset.ap_win_base = MMIO_OFFSET_BASE_ADDR;\n\tipc_mmio->offset.ap_win_end = MMIO_OFFSET_END_ADDR;\n\n\tipc_mmio->offset.cp_version = MMIO_OFFSET_CP_VERSION;\n\tipc_mmio->offset.cp_capability = MMIO_OFFSET_CP_CAPABILITIES;\n\n\treturn ipc_mmio;\n\ninit_fail:\n\tkfree(ipc_mmio);\n\treturn NULL;\n}\n\nenum ipc_mem_exec_stage ipc_mmio_get_exec_stage(struct iosm_mmio *ipc_mmio)\n{\n\tif (!ipc_mmio)\n\t\treturn IPC_MEM_EXEC_STAGE_INVALID;\n\n\treturn (enum ipc_mem_exec_stage)ioread32(ipc_mmio->base +\n\t\t\t\t\t\t ipc_mmio->offset.exec_stage);\n}\n\nvoid ipc_mmio_copy_chip_info(struct iosm_mmio *ipc_mmio, void *dest,\n\t\t\t     size_t size)\n{\n\tif (ipc_mmio && dest)\n\t\tmemcpy_fromio(dest, ipc_mmio->base + ipc_mmio->offset.chip_info,\n\t\t\t      size);\n}\n\nenum ipc_mem_device_ipc_state ipc_mmio_get_ipc_state(struct iosm_mmio *ipc_mmio)\n{\n\tif (!ipc_mmio)\n\t\treturn IPC_MEM_DEVICE_IPC_INVALID;\n\n\treturn (enum ipc_mem_device_ipc_state)ioread32(ipc_mmio->base +\n\t\t\t\t\t\t       ipc_mmio->offset.ipc_status);\n}\n\nenum rom_exit_code ipc_mmio_get_rom_exit_code(struct iosm_mmio *ipc_mmio)\n{\n\tif (!ipc_mmio)\n\t\treturn IMEM_ROM_EXIT_FAIL;\n\n\treturn (enum rom_exit_code)ioread32(ipc_mmio->base +\n\t\t\t\t\t    ipc_mmio->offset.rom_exit_code);\n}\n\nvoid ipc_mmio_config(struct iosm_mmio *ipc_mmio)\n{\n\tif (!ipc_mmio)\n\t\treturn;\n\n\t \n\tiowrite64(0, ipc_mmio->base + ipc_mmio->offset.ap_win_base);\n\tiowrite64(0, ipc_mmio->base + ipc_mmio->offset.ap_win_end);\n\n\tiowrite64(ipc_mmio->context_info_addr,\n\t\t  ipc_mmio->base + ipc_mmio->offset.context_info);\n}\n\nvoid ipc_mmio_set_psi_addr_and_size(struct iosm_mmio *ipc_mmio, dma_addr_t addr,\n\t\t\t\t    u32 size)\n{\n\tif (!ipc_mmio)\n\t\treturn;\n\n\tiowrite64(addr, ipc_mmio->base + ipc_mmio->offset.psi_address);\n\tiowrite32(size, ipc_mmio->base + ipc_mmio->offset.psi_size);\n}\n\nvoid ipc_mmio_set_contex_info_addr(struct iosm_mmio *ipc_mmio, phys_addr_t addr)\n{\n\tif (!ipc_mmio)\n\t\treturn;\n\n\t \n\tipc_mmio->context_info_addr = addr;\n}\n\nint ipc_mmio_get_cp_version(struct iosm_mmio *ipc_mmio)\n{\n\tif (ipc_mmio)\n\t\treturn ioread32(ipc_mmio->base + ipc_mmio->offset.cp_version);\n\n\treturn -EFAULT;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}