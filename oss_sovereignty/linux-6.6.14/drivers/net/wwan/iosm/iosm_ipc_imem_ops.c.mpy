{
  "module_name": "iosm_ipc_imem_ops.c",
  "hash_id": "b563884740bb695630a5ca63c1d10ac0843dc500f2a7caa2b6c363ec58fa7f74",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wwan/iosm/iosm_ipc_imem_ops.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n\n#include \"iosm_ipc_chnl_cfg.h\"\n#include \"iosm_ipc_devlink.h\"\n#include \"iosm_ipc_imem.h\"\n#include \"iosm_ipc_imem_ops.h\"\n#include \"iosm_ipc_port.h\"\n#include \"iosm_ipc_task_queue.h\"\n\n \nint ipc_imem_sys_wwan_open(struct iosm_imem *ipc_imem, int if_id)\n{\n\tdev_dbg(ipc_imem->dev, \"%s if id: %d\",\n\t\tipc_imem_phase_get_string(ipc_imem->phase), if_id);\n\n\t \n\tif (ipc_imem_phase_update(ipc_imem) != IPC_P_RUN) {\n\t\tdev_err(ipc_imem->dev, \"net:%d : refused phase %s\", if_id,\n\t\t\tipc_imem_phase_get_string(ipc_imem->phase));\n\t\treturn -EIO;\n\t}\n\n\treturn ipc_mux_open_session(ipc_imem->mux, if_id);\n}\n\n \nvoid ipc_imem_sys_wwan_close(struct iosm_imem *ipc_imem, int if_id,\n\t\t\t     int channel_id)\n{\n\tif (ipc_imem->mux && if_id >= IP_MUX_SESSION_START &&\n\t    if_id <= IP_MUX_SESSION_END)\n\t\tipc_mux_close_session(ipc_imem->mux, if_id);\n}\n\n \nstatic int ipc_imem_tq_cdev_write(struct iosm_imem *ipc_imem, int arg,\n\t\t\t\t  void *msg, size_t size)\n{\n\tipc_imem_ul_send(ipc_imem);\n\n\treturn 0;\n}\n\n \nstatic int ipc_imem_call_cdev_write(struct iosm_imem *ipc_imem)\n{\n\treturn ipc_task_queue_send_task(ipc_imem, ipc_imem_tq_cdev_write, 0,\n\t\t\t\t\tNULL, 0, false);\n}\n\n \nint ipc_imem_sys_wwan_transmit(struct iosm_imem *ipc_imem,\n\t\t\t       int if_id, int channel_id, struct sk_buff *skb)\n{\n\tint ret = -EINVAL;\n\n\tif (!ipc_imem || channel_id < 0)\n\t\tgoto out;\n\n\t \n\tif (ipc_imem->phase != IPC_P_RUN) {\n\t\tdev_dbg(ipc_imem->dev, \"phase %s transmit\",\n\t\t\tipc_imem_phase_get_string(ipc_imem->phase));\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tret = ipc_mux_ul_trigger_encode(ipc_imem->mux, if_id, skb);\nout:\n\treturn ret;\n}\n\n \nint ipc_imem_wwan_channel_init(struct iosm_imem *ipc_imem,\n\t\t\t       enum ipc_mux_protocol mux_type)\n{\n\tstruct ipc_chnl_cfg chnl_cfg = { 0 };\n\n\tipc_imem->cp_version = ipc_mmio_get_cp_version(ipc_imem->mmio);\n\n\t \n\tif (ipc_imem->cp_version == -1) {\n\t\tdev_err(ipc_imem->dev, \"invalid CP version\");\n\t\treturn -EIO;\n\t}\n\n\tipc_chnl_cfg_get(&chnl_cfg, ipc_imem->nr_of_channels);\n\n\tif (ipc_imem->mmio->mux_protocol == MUX_AGGREGATION &&\n\t    ipc_imem->nr_of_channels == IPC_MEM_IP_CHL_ID_0) {\n\t\tchnl_cfg.ul_nr_of_entries = IPC_MEM_MAX_TDS_MUX_AGGR_UL;\n\t\tchnl_cfg.dl_nr_of_entries = IPC_MEM_MAX_TDS_MUX_AGGR_DL;\n\t\tchnl_cfg.dl_buf_size = IPC_MEM_MAX_ADB_BUF_SIZE;\n\t}\n\n\tipc_imem_channel_init(ipc_imem, IPC_CTYPE_WWAN, chnl_cfg,\n\t\t\t      IRQ_MOD_OFF);\n\n\t \n\tipc_imem->wwan = ipc_wwan_init(ipc_imem, ipc_imem->dev);\n\tif (!ipc_imem->wwan) {\n\t\tdev_err(ipc_imem->dev,\n\t\t\t\"failed to register the ipc_wwan interfaces\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ipc_imem_map_skb_to_dma(struct iosm_imem *ipc_imem,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct iosm_pcie *ipc_pcie = ipc_imem->pcie;\n\tchar *buf = skb->data;\n\tint len = skb->len;\n\tdma_addr_t mapping;\n\tint ret;\n\n\tret = ipc_pcie_addr_map(ipc_pcie, buf, len, &mapping, DMA_TO_DEVICE);\n\n\tif (ret)\n\t\tgoto err;\n\n\tBUILD_BUG_ON(sizeof(*IPC_CB(skb)) > sizeof(skb->cb));\n\n\tIPC_CB(skb)->mapping = mapping;\n\tIPC_CB(skb)->direction = DMA_TO_DEVICE;\n\tIPC_CB(skb)->len = len;\n\tIPC_CB(skb)->op_type = (u8)UL_DEFAULT;\n\nerr:\n\treturn ret;\n}\n\n \nstatic bool ipc_imem_is_channel_active(struct iosm_imem *ipc_imem,\n\t\t\t\t       struct ipc_mem_channel *channel)\n{\n\tenum ipc_phase phase;\n\n\t \n\tphase = ipc_imem->phase;\n\n\t \n\tswitch (phase) {\n\tcase IPC_P_RUN:\n\tcase IPC_P_PSI:\n\tcase IPC_P_EBL:\n\t\tbreak;\n\n\tcase IPC_P_ROM:\n\t\t \n\t\tif (channel->state != IMEM_CHANNEL_RESERVED) {\n\t\t\tdev_err(ipc_imem->dev,\n\t\t\t\t\"ch[%d]:invalid channel state %d,expected %d\",\n\t\t\t\tchannel->channel_id, channel->state,\n\t\t\t\tIMEM_CHANNEL_RESERVED);\n\t\t\tgoto channel_unavailable;\n\t\t}\n\t\tgoto channel_available;\n\n\tdefault:\n\t\t \n\t\tdev_err(ipc_imem->dev, \"ch[%d]: confused phase %d\",\n\t\t\tchannel->channel_id, phase);\n\t\tgoto channel_unavailable;\n\t}\n\t \n\tif (channel->state != IMEM_CHANNEL_ACTIVE) {\n\t\tdev_err(ipc_imem->dev, \"ch[%d]: confused channel state %d\",\n\t\t\tchannel->channel_id, channel->state);\n\t\tgoto channel_unavailable;\n\t}\n\nchannel_available:\n\treturn true;\n\nchannel_unavailable:\n\treturn false;\n}\n\n \nvoid ipc_imem_sys_port_close(struct iosm_imem *ipc_imem,\n\t\t\t     struct ipc_mem_channel *channel)\n{\n\tenum ipc_phase curr_phase;\n\tint status = 0;\n\tu32 tail = 0;\n\n\tcurr_phase = ipc_imem->phase;\n\n\t \n\tif (curr_phase == IPC_P_OFF) {\n\t\tdev_err(ipc_imem->dev,\n\t\t\t\"nothing to do. Current Phase: %s\",\n\t\t\tipc_imem_phase_get_string(curr_phase));\n\t\treturn;\n\t}\n\n\tif (channel->state == IMEM_CHANNEL_FREE) {\n\t\tdev_err(ipc_imem->dev, \"ch[%d]: invalid channel state %d\",\n\t\t\tchannel->channel_id, channel->state);\n\t\treturn;\n\t}\n\n\t \n\tif (channel->ul_pipe.old_tail != channel->ul_pipe.old_head) {\n\t\tipc_imem->app_notify_ul_pend = 1;\n\n\t\t \n\t\tstatus = wait_for_completion_interruptible_timeout\n\t\t\t (&ipc_imem->ul_pend_sem,\n\t\t\t  msecs_to_jiffies(IPC_PEND_DATA_TIMEOUT));\n\t\tif (status == 0) {\n\t\t\tdev_dbg(ipc_imem->dev,\n\t\t\t\t\"Pend data Timeout UL-Pipe:%d Head:%d Tail:%d\",\n\t\t\t\tchannel->ul_pipe.pipe_nr,\n\t\t\t\tchannel->ul_pipe.old_head,\n\t\t\t\tchannel->ul_pipe.old_tail);\n\t\t}\n\n\t\tipc_imem->app_notify_ul_pend = 0;\n\t}\n\n\t \n\tipc_protocol_get_head_tail_index(ipc_imem->ipc_protocol,\n\t\t\t\t\t &channel->dl_pipe, NULL, &tail);\n\n\tif (tail != channel->dl_pipe.old_tail) {\n\t\tipc_imem->app_notify_dl_pend = 1;\n\n\t\t \n\t\tstatus = wait_for_completion_interruptible_timeout\n\t\t\t (&ipc_imem->dl_pend_sem,\n\t\t\t  msecs_to_jiffies(IPC_PEND_DATA_TIMEOUT));\n\t\tif (status == 0) {\n\t\t\tdev_dbg(ipc_imem->dev,\n\t\t\t\t\"Pend data Timeout DL-Pipe:%d Head:%d Tail:%d\",\n\t\t\t\tchannel->dl_pipe.pipe_nr,\n\t\t\t\tchannel->dl_pipe.old_head,\n\t\t\t\tchannel->dl_pipe.old_tail);\n\t\t}\n\n\t\tipc_imem->app_notify_dl_pend = 0;\n\t}\n\n\t \n\tchannel->state = IMEM_CHANNEL_CLOSING;\n\n\tipc_imem_pipe_close(ipc_imem, &channel->ul_pipe);\n\tipc_imem_pipe_close(ipc_imem, &channel->dl_pipe);\n\n\tipc_imem_channel_free(channel);\n}\n\n \nstruct ipc_mem_channel *ipc_imem_sys_port_open(struct iosm_imem *ipc_imem,\n\t\t\t\t\t       int chl_id, int hp_id)\n{\n\tstruct ipc_mem_channel *channel;\n\tint ch_id;\n\n\t \n\tif (ipc_imem_phase_update(ipc_imem) != IPC_P_RUN) {\n\t\tdev_err(ipc_imem->dev, \"PORT open refused, phase %s\",\n\t\t\tipc_imem_phase_get_string(ipc_imem->phase));\n\t\treturn NULL;\n\t}\n\n\tch_id = ipc_imem_channel_alloc(ipc_imem, chl_id, IPC_CTYPE_CTRL);\n\n\tif (ch_id < 0) {\n\t\tdev_err(ipc_imem->dev, \"reservation of an PORT chnl id failed\");\n\t\treturn NULL;\n\t}\n\n\tchannel = ipc_imem_channel_open(ipc_imem, ch_id, hp_id);\n\n\tif (!channel) {\n\t\tdev_err(ipc_imem->dev, \"PORT channel id open failed\");\n\t\treturn NULL;\n\t}\n\n\treturn channel;\n}\n\n \nint ipc_imem_sys_cdev_write(struct iosm_cdev *ipc_cdev, struct sk_buff *skb)\n{\n\tstruct ipc_mem_channel *channel = ipc_cdev->channel;\n\tstruct iosm_imem *ipc_imem = ipc_cdev->ipc_imem;\n\tint ret = -EIO;\n\n\tif (!ipc_imem_is_channel_active(ipc_imem, channel) ||\n\t    ipc_imem->phase == IPC_P_OFF_REQ)\n\t\tgoto out;\n\n\tret = ipc_imem_map_skb_to_dma(ipc_imem, skb);\n\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tskb_queue_tail(&channel->ul_list, skb);\n\n\tret = ipc_imem_call_cdev_write(ipc_imem);\n\n\tif (ret) {\n\t\tskb_dequeue_tail(&channel->ul_list);\n\t\tdev_err(ipc_cdev->dev, \"channel id[%d] write failed\\n\",\n\t\t\tipc_cdev->channel->channel_id);\n\t}\nout:\n\treturn ret;\n}\n\n \nstruct ipc_mem_channel *ipc_imem_sys_devlink_open(struct iosm_imem *ipc_imem)\n{\n\tstruct ipc_mem_channel *channel;\n\tenum ipc_phase phase;\n\tint channel_id;\n\n\tphase = ipc_imem_phase_update(ipc_imem);\n\tswitch (phase) {\n\tcase IPC_P_OFF:\n\tcase IPC_P_ROM:\n\t\t \n\t\tchannel_id = ipc_imem_channel_alloc(ipc_imem,\n\t\t\t\t\t\t    IPC_MEM_CTRL_CHL_ID_7,\n\t\t\t\t\t\t    IPC_CTYPE_CTRL);\n\n\t\tif (channel_id < 0) {\n\t\t\tdev_err(ipc_imem->dev,\n\t\t\t\t\"reservation of a flash channel id failed\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tipc_imem->ipc_devlink->devlink_sio.channel_id = channel_id;\n\t\tchannel = &ipc_imem->channels[channel_id];\n\n\t\t \n\t\tif (ipc_imem_devlink_trigger_chip_info(ipc_imem)) {\n\t\t\tdev_err(ipc_imem->dev, \"Enqueue of chip info failed\");\n\t\t\tchannel->state = IMEM_CHANNEL_FREE;\n\t\t\tgoto error;\n\t\t}\n\n\t\treturn channel;\n\n\tcase IPC_P_PSI:\n\tcase IPC_P_EBL:\n\t\tipc_imem->cp_version = ipc_mmio_get_cp_version(ipc_imem->mmio);\n\t\tif (ipc_imem->cp_version == -1) {\n\t\t\tdev_err(ipc_imem->dev, \"invalid CP version\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tchannel_id = ipc_imem->ipc_devlink->devlink_sio.channel_id;\n\t\treturn ipc_imem_channel_open(ipc_imem, channel_id,\n\t\t\t\t\t     IPC_HP_CDEV_OPEN);\n\n\tdefault:\n\t\t \n\t\tdev_err(ipc_imem->dev, \"SIO open refused, phase %d\", phase);\n\t}\nerror:\n\treturn NULL;\n}\n\n \nvoid ipc_imem_sys_devlink_close(struct iosm_devlink *ipc_devlink)\n{\n\tstruct iosm_imem *ipc_imem = ipc_devlink->pcie->imem;\n\tint boot_check_timeout = BOOT_CHECK_DEFAULT_TIMEOUT;\n\tenum ipc_mem_exec_stage exec_stage;\n\tstruct ipc_mem_channel *channel;\n\tint status = 0;\n\tu32 tail = 0;\n\n\tchannel = ipc_imem->ipc_devlink->devlink_sio.channel;\n\t \n\tdo {\n\t\texec_stage = ipc_mmio_get_exec_stage(ipc_imem->mmio);\n\t\tif (exec_stage == IPC_MEM_EXEC_STAGE_RUN ||\n\t\t    exec_stage == IPC_MEM_EXEC_STAGE_PSI)\n\t\t\tbreak;\n\t\tmsleep(20);\n\t\tboot_check_timeout -= 20;\n\t} while (boot_check_timeout > 0);\n\n\t \n\tif (channel->ul_pipe.old_tail != channel->ul_pipe.old_head) {\n\t\tstatus = wait_for_completion_interruptible_timeout\n\t\t\t(&ipc_imem->ul_pend_sem,\n\t\t\t msecs_to_jiffies(IPC_PEND_DATA_TIMEOUT));\n\t\tif (status == 0) {\n\t\t\tdev_dbg(ipc_imem->dev,\n\t\t\t\t\"Data Timeout on UL-Pipe:%d Head:%d Tail:%d\",\n\t\t\t\tchannel->ul_pipe.pipe_nr,\n\t\t\t\tchannel->ul_pipe.old_head,\n\t\t\t\tchannel->ul_pipe.old_tail);\n\t\t}\n\t}\n\n\tipc_protocol_get_head_tail_index(ipc_imem->ipc_protocol,\n\t\t\t\t\t &channel->dl_pipe, NULL, &tail);\n\n\tif (tail != channel->dl_pipe.old_tail) {\n\t\tstatus = wait_for_completion_interruptible_timeout\n\t\t\t(&ipc_imem->dl_pend_sem,\n\t\t\t msecs_to_jiffies(IPC_PEND_DATA_TIMEOUT));\n\t\tif (status == 0) {\n\t\t\tdev_dbg(ipc_imem->dev,\n\t\t\t\t\"Data Timeout on DL-Pipe:%d Head:%d Tail:%d\",\n\t\t\t\tchannel->dl_pipe.pipe_nr,\n\t\t\t\tchannel->dl_pipe.old_head,\n\t\t\t\tchannel->dl_pipe.old_tail);\n\t\t}\n\t}\n\n\t \n\tchannel->state = IMEM_CHANNEL_CLOSING;\n\t \n\tipc_imem_pipe_cleanup(ipc_imem, &channel->ul_pipe);\n\tipc_imem_pipe_cleanup(ipc_imem, &channel->dl_pipe);\n\tipc_imem->nr_of_channels--;\n}\n\nvoid ipc_imem_sys_devlink_notify_rx(struct iosm_devlink *ipc_devlink,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tskb_queue_tail(&ipc_devlink->devlink_sio.rx_list, skb);\n\tcomplete(&ipc_devlink->devlink_sio.read_sem);\n}\n\n \nstatic int ipc_imem_sys_psi_transfer(struct iosm_imem *ipc_imem,\n\t\t\t\t     struct ipc_mem_channel *channel,\n\t\t\t\t     unsigned char *buf, int count)\n{\n\tint psi_start_timeout = PSI_START_DEFAULT_TIMEOUT;\n\tenum ipc_mem_exec_stage exec_stage;\n\n\tdma_addr_t mapping = 0;\n\tint ret;\n\n\tret = ipc_pcie_addr_map(ipc_imem->pcie, buf, count, &mapping,\n\t\t\t\tDMA_TO_DEVICE);\n\tif (ret)\n\t\tgoto pcie_addr_map_fail;\n\n\t \n\tipc_mmio_set_psi_addr_and_size(ipc_imem->mmio, mapping, count);\n\tipc_doorbell_fire(ipc_imem->pcie, 0, IPC_MEM_EXEC_STAGE_BOOT);\n\n\tret = wait_for_completion_interruptible_timeout\n\t\t(&channel->ul_sem,\n\t\t msecs_to_jiffies(IPC_PSI_TRANSFER_TIMEOUT));\n\n\tif (ret <= 0) {\n\t\tdev_err(ipc_imem->dev, \"Failed PSI transfer to CP, Error-%d\",\n\t\t\tret);\n\t\tgoto psi_transfer_fail;\n\t}\n\t \n\tif (ipc_imem->rom_exit_code != IMEM_ROM_EXIT_OPEN_EXT &&\n\t    ipc_imem->rom_exit_code != IMEM_ROM_EXIT_CERT_EXT) {\n\t\tret = (-1) * ((int)ipc_imem->rom_exit_code);\n\t\tgoto psi_transfer_fail;\n\t}\n\n\tdev_dbg(ipc_imem->dev, \"PSI image successfully downloaded\");\n\n\t \n\tdo {\n\t\texec_stage = ipc_mmio_get_exec_stage(ipc_imem->mmio);\n\n\t\tif (exec_stage == IPC_MEM_EXEC_STAGE_PSI)\n\t\t\tbreak;\n\n\t\tmsleep(20);\n\t\tpsi_start_timeout -= 20;\n\t} while (psi_start_timeout > 0);\n\n\tif (exec_stage != IPC_MEM_EXEC_STAGE_PSI)\n\t\tgoto psi_transfer_fail;  \n\n\tipc_imem->phase = IPC_P_PSI;\n\n\t \n\tdev_dbg(ipc_imem->dev, \"execution_stage[%X] eq. PSI\", exec_stage);\n\n\t \n\tipc_imem_ipc_init_check(ipc_imem);\n\n\tret = wait_for_completion_interruptible_timeout\n\t\t(&channel->ul_sem, msecs_to_jiffies(IPC_PSI_TRANSFER_TIMEOUT));\n\tif (ret <= 0) {\n\t\tdev_err(ipc_imem->dev,\n\t\t\t\"Failed PSI RUNNING state on CP, Error-%d\", ret);\n\t\tgoto psi_transfer_fail;\n\t}\n\n\tif (ipc_mmio_get_ipc_state(ipc_imem->mmio) !=\n\t\t\tIPC_MEM_DEVICE_IPC_RUNNING) {\n\t\tdev_err(ipc_imem->dev,\n\t\t\t\"ch[%d] %s: unexpected CP IPC state %d, not RUNNING\",\n\t\t\tchannel->channel_id,\n\t\t\tipc_imem_phase_get_string(ipc_imem->phase),\n\t\t\tipc_mmio_get_ipc_state(ipc_imem->mmio));\n\n\t\tgoto psi_transfer_fail;\n\t}\n\n\t \n\tif (!ipc_imem_sys_devlink_open(ipc_imem)) {\n\t\tdev_err(ipc_imem->dev, \"can't open flash_channel\");\n\t\tgoto psi_transfer_fail;\n\t}\n\n\tret = 0;\npsi_transfer_fail:\n\tipc_pcie_addr_unmap(ipc_imem->pcie, count, mapping, DMA_TO_DEVICE);\npcie_addr_map_fail:\n\treturn ret;\n}\n\nint ipc_imem_sys_devlink_write(struct iosm_devlink *ipc_devlink,\n\t\t\t       unsigned char *buf, int count)\n{\n\tstruct iosm_imem *ipc_imem = ipc_devlink->pcie->imem;\n\tstruct ipc_mem_channel *channel;\n\tstruct sk_buff *skb;\n\tdma_addr_t mapping;\n\tint ret;\n\n\tchannel = ipc_imem->ipc_devlink->devlink_sio.channel;\n\n\t \n\tif (ipc_imem->phase == IPC_P_ROM) {\n\t\tret = ipc_imem_sys_psi_transfer(ipc_imem, channel, buf, count);\n\t\t \n\t\tif (ret > 0)\n\t\t\tipc_imem_msg_send_feature_set(ipc_imem,\n\t\t\t\t\t\t      IPC_MEM_INBAND_CRASH_SIG,\n\t\t\t\t\t\t      false);\n\t\tgoto out;\n\t}\n\n\t \n\tskb = ipc_pcie_alloc_skb(ipc_devlink->pcie, count, GFP_KERNEL, &mapping,\n\t\t\t\t DMA_TO_DEVICE, 0);\n\tif (!skb) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tskb_put_data(skb, buf, count);\n\n\tIPC_CB(skb)->op_type = UL_USR_OP_BLOCKED;\n\n\t \n\tskb_queue_tail(&channel->ul_list, skb);\n\n\t \n\tif (!ipc_imem_call_cdev_write(ipc_imem)) {\n\t\tret = wait_for_completion_interruptible(&channel->ul_sem);\n\n\t\tif (ret < 0) {\n\t\t\tdev_err(ipc_imem->dev,\n\t\t\t\t\"ch[%d] no CP confirmation, status = %d\",\n\t\t\t\tchannel->channel_id, ret);\n\t\t\tipc_pcie_kfree_skb(ipc_devlink->pcie, skb);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 0;\nout:\n\treturn ret;\n}\n\nint ipc_imem_sys_devlink_read(struct iosm_devlink *devlink, u8 *data,\n\t\t\t      u32 bytes_to_read, u32 *bytes_read)\n{\n\tstruct sk_buff *skb = NULL;\n\tint rc = 0;\n\n\t \n\tdevlink->devlink_sio.devlink_read_pend = 1;\n\twhile (!skb && !(skb = skb_dequeue(&devlink->devlink_sio.rx_list))) {\n\t\tif (!wait_for_completion_interruptible_timeout\n\t\t\t\t(&devlink->devlink_sio.read_sem,\n\t\t\t\t msecs_to_jiffies(IPC_READ_TIMEOUT))) {\n\t\t\tdev_err(devlink->dev, \"Read timedout\");\n\t\t\trc =  -ETIMEDOUT;\n\t\t\tgoto devlink_read_fail;\n\t\t}\n\t}\n\tdevlink->devlink_sio.devlink_read_pend = 0;\n\tif (bytes_to_read < skb->len) {\n\t\tdev_err(devlink->dev, \"Invalid size,expected len %d\", skb->len);\n\t\trc = -EINVAL;\n\t\tgoto devlink_read_fail;\n\t}\n\t*bytes_read = skb->len;\n\tmemcpy(data, skb->data, skb->len);\n\ndevlink_read_fail:\n\tdev_kfree_skb(skb);\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}