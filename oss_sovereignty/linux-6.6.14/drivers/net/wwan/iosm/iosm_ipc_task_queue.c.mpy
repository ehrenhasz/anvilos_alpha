{
  "module_name": "iosm_ipc_task_queue.c",
  "hash_id": "7dc998bbbc27500d08b734ce0ff74eb68bfda254b056d9804fad8938ab575850",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wwan/iosm/iosm_ipc_task_queue.c",
  "human_readable_source": "\n \n\n#include \"iosm_ipc_imem.h\"\n#include \"iosm_ipc_task_queue.h\"\n\n \nstatic void ipc_task_queue_handler(unsigned long data)\n{\n\tstruct ipc_task_queue *ipc_task = (struct ipc_task_queue *)data;\n\tunsigned int q_rpos = ipc_task->q_rpos;\n\n\t \n\twhile (q_rpos != ipc_task->q_wpos) {\n\t\t \n\t\tstruct ipc_task_queue_args *args = &ipc_task->args[q_rpos];\n\n\t\t \n\t\tif (args->func)\n\t\t\targs->response = args->func(args->ipc_imem, args->arg,\n\t\t\t\t\t\t    args->msg, args->size);\n\n\t\t \n\t\tif (args->completion)\n\t\t\tcomplete(args->completion);\n\n\t\t \n\t\tif (args->is_copy)\n\t\t\tkfree(args->msg);\n\n\t\t \n\t\targs->completion = NULL;\n\t\targs->func = NULL;\n\t\targs->msg = NULL;\n\t\targs->size = 0;\n\t\targs->is_copy = false;\n\n\t\t \n\t\tq_rpos = (q_rpos + 1) % IPC_THREAD_QUEUE_SIZE;\n\t\tipc_task->q_rpos = q_rpos;\n\t}\n}\n\n \nstatic void ipc_task_queue_cleanup(struct ipc_task_queue *ipc_task)\n{\n\tunsigned int q_rpos = ipc_task->q_rpos;\n\n\twhile (q_rpos != ipc_task->q_wpos) {\n\t\tstruct ipc_task_queue_args *args = &ipc_task->args[q_rpos];\n\n\t\tif (args->completion)\n\t\t\tcomplete(args->completion);\n\n\t\tif (args->is_copy)\n\t\t\tkfree(args->msg);\n\n\t\tq_rpos = (q_rpos + 1) % IPC_THREAD_QUEUE_SIZE;\n\t\tipc_task->q_rpos = q_rpos;\n\t}\n}\n\n \nstatic int\nipc_task_queue_add_task(struct iosm_imem *ipc_imem,\n\t\t\tint arg, void *msg,\n\t\t\tint (*func)(struct iosm_imem *ipc_imem, int arg,\n\t\t\t\t    void *msg, size_t size),\n\t\t\tsize_t size, bool is_copy, bool wait)\n{\n\tstruct tasklet_struct *ipc_tasklet = ipc_imem->ipc_task->ipc_tasklet;\n\tstruct ipc_task_queue *ipc_task = &ipc_imem->ipc_task->ipc_queue;\n\tstruct completion completion;\n\tunsigned int pos, nextpos;\n\tunsigned long flags;\n\tint result = -EIO;\n\n\tinit_completion(&completion);\n\n\t \n\tspin_lock_irqsave(&ipc_task->q_lock, flags);\n\n\tpos = ipc_task->q_wpos;\n\tnextpos = (pos + 1) % IPC_THREAD_QUEUE_SIZE;\n\n\t \n\tif (nextpos != ipc_task->q_rpos) {\n\t\t \n\t\tipc_task->args[pos].arg = arg;\n\t\tipc_task->args[pos].msg = msg;\n\t\tipc_task->args[pos].func = func;\n\t\tipc_task->args[pos].ipc_imem = ipc_imem;\n\t\tipc_task->args[pos].size = size;\n\t\tipc_task->args[pos].is_copy = is_copy;\n\t\tipc_task->args[pos].completion = wait ? &completion : NULL;\n\t\tipc_task->args[pos].response = -1;\n\n\t\t \n\t\tsmp_wmb();\n\n\t\t \n\t\tipc_task->q_wpos = nextpos;\n\t\tresult = 0;\n\t}\n\n\tspin_unlock_irqrestore(&ipc_task->q_lock, flags);\n\n\tif (result == 0) {\n\t\ttasklet_schedule(ipc_tasklet);\n\n\t\tif (wait) {\n\t\t\twait_for_completion(&completion);\n\t\t\tresult = ipc_task->args[pos].response;\n\t\t}\n\t} else {\n\t\tdev_err(ipc_imem->ipc_task->dev, \"queue is full\");\n\t}\n\n\treturn result;\n}\n\nint ipc_task_queue_send_task(struct iosm_imem *imem,\n\t\t\t     int (*func)(struct iosm_imem *ipc_imem, int arg,\n\t\t\t\t\t void *msg, size_t size),\n\t\t\t     int arg, void *msg, size_t size, bool wait)\n{\n\tbool is_copy = false;\n\tvoid *copy = msg;\n\tint ret = -ENOMEM;\n\n\tif (size > 0) {\n\t\tcopy = kmemdup(msg, size, GFP_ATOMIC);\n\t\tif (!copy)\n\t\t\tgoto out;\n\n\t\tis_copy = true;\n\t}\n\n\tret = ipc_task_queue_add_task(imem, arg, copy, func,\n\t\t\t\t      size, is_copy, wait);\n\tif (ret < 0) {\n\t\tdev_err(imem->ipc_task->dev,\n\t\t\t\"add task failed for %ps %d, %p, %zu, %d\", func, arg,\n\t\t\tcopy, size, is_copy);\n\t\tif (is_copy)\n\t\t\tkfree(copy);\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\treturn ret;\n}\n\nint ipc_task_init(struct ipc_task *ipc_task)\n{\n\tstruct ipc_task_queue *ipc_queue = &ipc_task->ipc_queue;\n\n\tipc_task->ipc_tasklet = kzalloc(sizeof(*ipc_task->ipc_tasklet),\n\t\t\t\t\tGFP_KERNEL);\n\n\tif (!ipc_task->ipc_tasklet)\n\t\treturn -ENOMEM;\n\n\t \n\tspin_lock_init(&ipc_queue->q_lock);\n\n\ttasklet_init(ipc_task->ipc_tasklet, ipc_task_queue_handler,\n\t\t     (unsigned long)ipc_queue);\n\treturn 0;\n}\n\nvoid ipc_task_deinit(struct ipc_task *ipc_task)\n{\n\ttasklet_kill(ipc_task->ipc_tasklet);\n\n\tkfree(ipc_task->ipc_tasklet);\n\t \n\tipc_task_queue_cleanup(&ipc_task->ipc_queue);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}