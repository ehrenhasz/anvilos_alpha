{
  "module_name": "iosm_ipc_pm.c",
  "hash_id": "606fce7c820594bd6f858e047b676b9108bc71d67e524496e2d10e31ddd07432",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wwan/iosm/iosm_ipc_pm.c",
  "human_readable_source": "\n \n\n#include \"iosm_ipc_protocol.h\"\n\n \n#define IPC_PM_ACTIVE_TIMEOUT_MS (500)\n\n \n#define IPC_PM_SLEEP (0)\n#define CONSUME_STATE (0)\n#define IPC_PM_ACTIVE (1)\n\nvoid ipc_pm_signal_hpda_doorbell(struct iosm_pm *ipc_pm, u32 identifier,\n\t\t\t\t bool host_slp_check)\n{\n\tif (host_slp_check && ipc_pm->host_pm_state != IPC_MEM_HOST_PM_ACTIVE &&\n\t    ipc_pm->host_pm_state != IPC_MEM_HOST_PM_ACTIVE_WAIT) {\n\t\tipc_pm->pending_hpda_update = true;\n\t\tdev_dbg(ipc_pm->dev,\n\t\t\t\"Pend HPDA update set. Host PM_State: %d identifier:%d\",\n\t\t\tipc_pm->host_pm_state, identifier);\n\t\treturn;\n\t}\n\n\tif (!ipc_pm_trigger(ipc_pm, IPC_PM_UNIT_IRQ, true)) {\n\t\tipc_pm->pending_hpda_update = true;\n\t\tdev_dbg(ipc_pm->dev, \"Pending HPDA update set. identifier:%d\",\n\t\t\tidentifier);\n\t\treturn;\n\t}\n\tipc_pm->pending_hpda_update = false;\n\n\t \n\tipc_cp_irq_hpda_update(ipc_pm->pcie, identifier);\n\n\tipc_pm_trigger(ipc_pm, IPC_PM_UNIT_IRQ, false);\n}\n\n \nstatic bool ipc_pm_link_activate(struct iosm_pm *ipc_pm)\n{\n\tif (ipc_pm->cp_state == IPC_MEM_DEV_PM_ACTIVE)\n\t\treturn true;\n\n\tif (ipc_pm->cp_state == IPC_MEM_DEV_PM_SLEEP) {\n\t\tif (ipc_pm->ap_state == IPC_MEM_DEV_PM_SLEEP) {\n\t\t\t \n\t\t\tipc_cp_irq_sleep_control(ipc_pm->pcie,\n\t\t\t\t\t\t IPC_MEM_DEV_PM_WAKEUP);\n\t\t\tipc_pm->ap_state = IPC_MEM_DEV_PM_ACTIVE_WAIT;\n\n\t\t\tgoto not_active;\n\t\t}\n\n\t\tif (ipc_pm->ap_state == IPC_MEM_DEV_PM_ACTIVE_WAIT)\n\t\t\tgoto not_active;\n\n\t\treturn true;\n\t}\n\nnot_active:\n\t \n\treturn false;\n}\n\nbool ipc_pm_wait_for_device_active(struct iosm_pm *ipc_pm)\n{\n\tbool ret_val = false;\n\n\tif (ipc_pm->ap_state != IPC_MEM_DEV_PM_ACTIVE) {\n\t\t \n\t\tsmp_mb__before_atomic();\n\n\t\t \n\t\tset_bit(0, &ipc_pm->host_sleep_pend);\n\n\t\t \n\t\tsmp_mb__after_atomic();\n\n\t\tif (!wait_for_completion_interruptible_timeout\n\t\t   (&ipc_pm->host_sleep_complete,\n\t\t    msecs_to_jiffies(IPC_PM_ACTIVE_TIMEOUT_MS))) {\n\t\t\tdev_err(ipc_pm->dev,\n\t\t\t\t\"PM timeout. Expected State:%d. Actual: %d\",\n\t\t\t\tIPC_MEM_DEV_PM_ACTIVE, ipc_pm->ap_state);\n\t\t\tgoto  active_timeout;\n\t\t}\n\t}\n\n\tret_val = true;\nactive_timeout:\n\t \n\tsmp_mb__before_atomic();\n\n\t \n\tclear_bit(0, &ipc_pm->host_sleep_pend);\n\n\t \n\tsmp_mb__after_atomic();\n\n\treturn ret_val;\n}\n\nstatic void ipc_pm_on_link_sleep(struct iosm_pm *ipc_pm)\n{\n\t \n\tipc_pm->cp_state = IPC_MEM_DEV_PM_SLEEP;\n\tipc_pm->ap_state = IPC_MEM_DEV_PM_SLEEP;\n\n\tipc_cp_irq_sleep_control(ipc_pm->pcie, IPC_MEM_DEV_PM_SLEEP);\n}\n\nstatic void ipc_pm_on_link_wake(struct iosm_pm *ipc_pm, bool ack)\n{\n\tipc_pm->ap_state = IPC_MEM_DEV_PM_ACTIVE;\n\n\tif (ack) {\n\t\tipc_pm->cp_state = IPC_MEM_DEV_PM_ACTIVE;\n\n\t\tipc_cp_irq_sleep_control(ipc_pm->pcie, IPC_MEM_DEV_PM_ACTIVE);\n\n\t\t \n\t\tif (test_bit(CONSUME_STATE, &ipc_pm->host_sleep_pend))\n\t\t\tcomplete(&ipc_pm->host_sleep_complete);\n\t}\n\n\t \n\tif (ipc_pm->pending_hpda_update &&\n\t    ipc_pm->host_pm_state == IPC_MEM_HOST_PM_ACTIVE)\n\t\tipc_pm_signal_hpda_doorbell(ipc_pm, IPC_HP_PM_TRIGGER, true);\n}\n\nbool ipc_pm_trigger(struct iosm_pm *ipc_pm, enum ipc_pm_unit unit, bool active)\n{\n\tunion ipc_pm_cond old_cond;\n\tunion ipc_pm_cond new_cond;\n\tbool link_active;\n\n\t \n\tnew_cond = ipc_pm->pm_cond;\n\told_cond = ipc_pm->pm_cond;\n\n\t \n\tswitch (unit) {\n\tcase IPC_PM_UNIT_IRQ:  \n\t\tnew_cond.irq = active;\n\t\tbreak;\n\n\tcase IPC_PM_UNIT_LINK:  \n\t\tnew_cond.link = active;\n\t\tbreak;\n\n\tcase IPC_PM_UNIT_HS:  \n\t\tnew_cond.hs = active;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (old_cond.raw == new_cond.raw) {\n\t\t \n\t\tlink_active = old_cond.link == IPC_PM_ACTIVE;\n\t\tgoto ret;\n\t}\n\n\tipc_pm->pm_cond = new_cond;\n\n\tif (new_cond.link)\n\t\tipc_pm_on_link_wake(ipc_pm, unit == IPC_PM_UNIT_LINK);\n\telse if (unit == IPC_PM_UNIT_LINK)\n\t\tipc_pm_on_link_sleep(ipc_pm);\n\n\tif (old_cond.link == IPC_PM_SLEEP && new_cond.raw) {\n\t\tlink_active = ipc_pm_link_activate(ipc_pm);\n\t\tgoto ret;\n\t}\n\n\tlink_active = old_cond.link == IPC_PM_ACTIVE;\n\nret:\n\treturn link_active;\n}\n\nbool ipc_pm_prepare_host_sleep(struct iosm_pm *ipc_pm)\n{\n\t \n\tif (ipc_pm->host_pm_state != IPC_MEM_HOST_PM_ACTIVE) {\n\t\tdev_err(ipc_pm->dev, \"host_pm_state=%d\\tExpected to be: %d\",\n\t\t\tipc_pm->host_pm_state, IPC_MEM_HOST_PM_ACTIVE);\n\t\treturn false;\n\t}\n\n\tipc_pm->host_pm_state = IPC_MEM_HOST_PM_SLEEP_WAIT_D3;\n\n\treturn true;\n}\n\nbool ipc_pm_prepare_host_active(struct iosm_pm *ipc_pm)\n{\n\tif (ipc_pm->host_pm_state != IPC_MEM_HOST_PM_SLEEP) {\n\t\tdev_err(ipc_pm->dev, \"host_pm_state=%d\\tExpected to be: %d\",\n\t\t\tipc_pm->host_pm_state, IPC_MEM_HOST_PM_SLEEP);\n\t\treturn false;\n\t}\n\n\t \n\tipc_pm->host_pm_state = IPC_MEM_HOST_PM_ACTIVE_WAIT;\n\n\treturn true;\n}\n\nvoid ipc_pm_set_s2idle_sleep(struct iosm_pm *ipc_pm, bool sleep)\n{\n\tif (sleep) {\n\t\tipc_pm->ap_state = IPC_MEM_DEV_PM_SLEEP;\n\t\tipc_pm->cp_state = IPC_MEM_DEV_PM_SLEEP;\n\t\tipc_pm->device_sleep_notification = IPC_MEM_DEV_PM_SLEEP;\n\t} else {\n\t\tipc_pm->ap_state = IPC_MEM_DEV_PM_ACTIVE;\n\t\tipc_pm->cp_state = IPC_MEM_DEV_PM_ACTIVE;\n\t\tipc_pm->device_sleep_notification = IPC_MEM_DEV_PM_ACTIVE;\n\t\tipc_pm->pm_cond.link = IPC_PM_ACTIVE;\n\t}\n}\n\nbool ipc_pm_dev_slp_notification(struct iosm_pm *ipc_pm, u32 cp_pm_req)\n{\n\tif (cp_pm_req == ipc_pm->device_sleep_notification)\n\t\treturn false;\n\n\tipc_pm->device_sleep_notification = cp_pm_req;\n\n\t \n\tswitch (ipc_pm->cp_state) {\n\tcase IPC_MEM_DEV_PM_ACTIVE:\n\t\tswitch (cp_pm_req) {\n\t\tcase IPC_MEM_DEV_PM_ACTIVE:\n\t\t\tbreak;\n\n\t\tcase IPC_MEM_DEV_PM_SLEEP:\n\t\t\t \n\t\t\tipc_pm_trigger(ipc_pm, IPC_PM_UNIT_LINK, false);\n\t\t\treturn true;\n\n\t\tdefault:\n\t\t\tdev_err(ipc_pm->dev,\n\t\t\t\t\"loc-pm=%d active: confused req-pm=%d\",\n\t\t\t\tipc_pm->cp_state, cp_pm_req);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase IPC_MEM_DEV_PM_SLEEP:\n\t\tswitch (cp_pm_req) {\n\t\tcase IPC_MEM_DEV_PM_ACTIVE:\n\t\t\t \n\t\t\tipc_pm_trigger(ipc_pm, IPC_PM_UNIT_LINK, true);\n\t\t\tbreak;\n\n\t\tcase IPC_MEM_DEV_PM_SLEEP:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(ipc_pm->dev,\n\t\t\t\t\"loc-pm=%d sleep: confused req-pm=%d\",\n\t\t\t\tipc_pm->cp_state, cp_pm_req);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(ipc_pm->dev, \"confused loc-pm=%d, req-pm=%d\",\n\t\t\tipc_pm->cp_state, cp_pm_req);\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nvoid ipc_pm_init(struct iosm_protocol *ipc_protocol)\n{\n\tstruct iosm_imem *ipc_imem = ipc_protocol->imem;\n\tstruct iosm_pm *ipc_pm = &ipc_protocol->pm;\n\n\tipc_pm->pcie = ipc_imem->pcie;\n\tipc_pm->dev = ipc_imem->dev;\n\n\tipc_pm->pm_cond.irq = IPC_PM_SLEEP;\n\tipc_pm->pm_cond.hs = IPC_PM_SLEEP;\n\tipc_pm->pm_cond.link = IPC_PM_ACTIVE;\n\n\tipc_pm->cp_state = IPC_MEM_DEV_PM_ACTIVE;\n\tipc_pm->ap_state = IPC_MEM_DEV_PM_ACTIVE;\n\tipc_pm->host_pm_state = IPC_MEM_HOST_PM_ACTIVE;\n\n\t \n\tinit_completion(&ipc_pm->host_sleep_complete);\n\n\t \n\tsmp_mb__before_atomic();\n\n\tclear_bit(0, &ipc_pm->host_sleep_pend);\n\n\t \n\tsmp_mb__after_atomic();\n}\n\nvoid ipc_pm_deinit(struct iosm_protocol *proto)\n{\n\tstruct iosm_pm *ipc_pm = &proto->pm;\n\n\tcomplete(&ipc_pm->host_sleep_complete);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}