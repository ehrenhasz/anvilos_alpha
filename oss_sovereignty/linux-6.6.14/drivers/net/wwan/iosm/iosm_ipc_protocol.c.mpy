{
  "module_name": "iosm_ipc_protocol.c",
  "hash_id": "97011c26a6b05d6b21f58bf6f52b1d1fde88c6f2c9c7e6e2efc36ef85b851e89",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wwan/iosm/iosm_ipc_protocol.c",
  "human_readable_source": "\n \n\n#include \"iosm_ipc_imem.h\"\n#include \"iosm_ipc_protocol.h\"\n#include \"iosm_ipc_protocol_ops.h\"\n#include \"iosm_ipc_pm.h\"\n#include \"iosm_ipc_task_queue.h\"\n\nint ipc_protocol_tq_msg_send(struct iosm_protocol *ipc_protocol,\n\t\t\t     enum ipc_msg_prep_type msg_type,\n\t\t\t     union ipc_msg_prep_args *prep_args,\n\t\t\t     struct ipc_rsp *response)\n{\n\tint index = ipc_protocol_msg_prep(ipc_protocol->imem, msg_type,\n\t\t\t\t\t  prep_args);\n\n\t \n\tif (index >= 0 && index < IPC_MEM_MSG_ENTRIES) {\n\t\tipc_protocol->rsp_ring[index] = response;\n\t\tipc_protocol_msg_hp_update(ipc_protocol->imem);\n\t}\n\n\treturn index;\n}\n\n \nstatic int ipc_protocol_tq_msg_send_cb(struct iosm_imem *ipc_imem, int arg,\n\t\t\t\t       void *msg, size_t size)\n{\n\tstruct ipc_call_msg_send_args *send_args = msg;\n\tstruct iosm_protocol *ipc_protocol = ipc_imem->ipc_protocol;\n\n\treturn ipc_protocol_tq_msg_send(ipc_protocol, send_args->msg_type,\n\t\t\t\t\tsend_args->prep_args,\n\t\t\t\t\tsend_args->response);\n}\n\n \nstatic int ipc_protocol_tq_msg_remove(struct iosm_imem *ipc_imem, int arg,\n\t\t\t\t      void *msg, size_t size)\n{\n\tstruct iosm_protocol *ipc_protocol = ipc_imem->ipc_protocol;\n\n\tipc_protocol->rsp_ring[arg] = NULL;\n\treturn 0;\n}\n\nint ipc_protocol_msg_send(struct iosm_protocol *ipc_protocol,\n\t\t\t  enum ipc_msg_prep_type prep,\n\t\t\t  union ipc_msg_prep_args *prep_args)\n{\n\tstruct ipc_call_msg_send_args send_args;\n\tunsigned int exec_timeout;\n\tstruct ipc_rsp response;\n\tint index;\n\n\texec_timeout = (ipc_protocol_get_ap_exec_stage(ipc_protocol) ==\n\t\t\t\t\tIPC_MEM_EXEC_STAGE_RUN ?\n\t\t\t\tIPC_MSG_COMPLETE_RUN_DEFAULT_TIMEOUT :\n\t\t\t\tIPC_MSG_COMPLETE_BOOT_DEFAULT_TIMEOUT);\n\n\t \n\tmight_sleep();\n\n\tresponse.status = IPC_MEM_MSG_CS_INVALID;\n\tinit_completion(&response.completion);\n\n\tsend_args.msg_type = prep;\n\tsend_args.prep_args = prep_args;\n\tsend_args.response = &response;\n\n\t \n\tindex = ipc_task_queue_send_task(ipc_protocol->imem,\n\t\t\t\t\t ipc_protocol_tq_msg_send_cb, 0,\n\t\t\t\t\t &send_args, 0, true);\n\n\tif (index < 0) {\n\t\tdev_err(ipc_protocol->dev, \"msg %d failed\", prep);\n\t\treturn index;\n\t}\n\n\t \n\tswitch (wait_for_completion_timeout(&response.completion,\n\t\t\t\t\t    msecs_to_jiffies(exec_timeout))) {\n\tcase 0:\n\t\t \n\t\tipc_task_queue_send_task(ipc_protocol->imem,\n\t\t\t\t\t ipc_protocol_tq_msg_remove, index,\n\t\t\t\t\t NULL, 0, true);\n\t\tdev_err(ipc_protocol->dev, \"msg timeout\");\n\t\tipc_uevent_send(ipc_protocol->pcie->dev, UEVENT_MDM_TIMEOUT);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif (response.status != IPC_MEM_MSG_CS_SUCCESS) {\n\t\t\tdev_err(ipc_protocol->dev,\n\t\t\t\t\"msg completion status error %d\",\n\t\t\t\tresponse.status);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ipc_protocol_msg_send_host_sleep(struct iosm_protocol *ipc_protocol,\n\t\t\t\t\t    u32 state)\n{\n\tunion ipc_msg_prep_args prep_args = {\n\t\t.sleep.target = 0,\n\t\t.sleep.state = state,\n\t};\n\n\treturn ipc_protocol_msg_send(ipc_protocol, IPC_MSG_PREP_SLEEP,\n\t\t\t\t     &prep_args);\n}\n\nvoid ipc_protocol_doorbell_trigger(struct iosm_protocol *ipc_protocol,\n\t\t\t\t   u32 identifier)\n{\n\tipc_pm_signal_hpda_doorbell(&ipc_protocol->pm, identifier, true);\n}\n\nbool ipc_protocol_pm_dev_sleep_handle(struct iosm_protocol *ipc_protocol)\n{\n\tu32 ipc_status = ipc_protocol_get_ipc_status(ipc_protocol);\n\tu32 requested;\n\n\tif (ipc_status != IPC_MEM_DEVICE_IPC_RUNNING) {\n\t\tdev_err(ipc_protocol->dev,\n\t\t\t\"irq ignored, CP IPC state is %d, should be RUNNING\",\n\t\t\tipc_status);\n\n\t\t \n\t\treturn false;\n\t}\n\n\t \n\trequested = ipc_protocol_pm_dev_get_sleep_notification(ipc_protocol);\n\n\treturn ipc_pm_dev_slp_notification(&ipc_protocol->pm, requested);\n}\n\nstatic int ipc_protocol_tq_wakeup_dev_slp(struct iosm_imem *ipc_imem, int arg,\n\t\t\t\t\t  void *msg, size_t size)\n{\n\tstruct iosm_pm *ipc_pm = &ipc_imem->ipc_protocol->pm;\n\n\t \n\tipc_pm_trigger(ipc_pm, IPC_PM_UNIT_HS, true);\n\n\tipc_pm_trigger(ipc_pm, IPC_PM_UNIT_HS, false);\n\n\treturn 0;\n}\n\nvoid ipc_protocol_s2idle_sleep(struct iosm_protocol *ipc_protocol, bool sleep)\n{\n\tipc_pm_set_s2idle_sleep(&ipc_protocol->pm, sleep);\n}\n\nbool ipc_protocol_suspend(struct iosm_protocol *ipc_protocol)\n{\n\tif (!ipc_pm_prepare_host_sleep(&ipc_protocol->pm))\n\t\tgoto err;\n\n\tipc_task_queue_send_task(ipc_protocol->imem,\n\t\t\t\t ipc_protocol_tq_wakeup_dev_slp, 0, NULL, 0,\n\t\t\t\t true);\n\n\tif (!ipc_pm_wait_for_device_active(&ipc_protocol->pm)) {\n\t\tipc_uevent_send(ipc_protocol->pcie->dev, UEVENT_MDM_TIMEOUT);\n\t\tgoto err;\n\t}\n\n\t \n\tdev_dbg(ipc_protocol->dev, \"send TARGET_HOST, ENTER_SLEEP\");\n\tif (ipc_protocol_msg_send_host_sleep(ipc_protocol,\n\t\t\t\t\t     IPC_HOST_SLEEP_ENTER_SLEEP)) {\n\t\t \n\t\tipc_protocol->pm.host_pm_state = IPC_MEM_HOST_PM_ACTIVE;\n\t\tgoto err;\n\t}\n\n\tipc_protocol->pm.host_pm_state = IPC_MEM_HOST_PM_SLEEP;\n\treturn true;\nerr:\n\treturn false;\n}\n\nbool ipc_protocol_resume(struct iosm_protocol *ipc_protocol)\n{\n\tif (!ipc_pm_prepare_host_active(&ipc_protocol->pm))\n\t\treturn false;\n\n\tdev_dbg(ipc_protocol->dev, \"send TARGET_HOST, EXIT_SLEEP\");\n\tif (ipc_protocol_msg_send_host_sleep(ipc_protocol,\n\t\t\t\t\t     IPC_HOST_SLEEP_EXIT_SLEEP)) {\n\t\tipc_protocol->pm.host_pm_state = IPC_MEM_HOST_PM_SLEEP;\n\t\treturn false;\n\t}\n\n\tipc_protocol->pm.host_pm_state = IPC_MEM_HOST_PM_ACTIVE;\n\n\treturn true;\n}\n\nstruct iosm_protocol *ipc_protocol_init(struct iosm_imem *ipc_imem)\n{\n\tstruct iosm_protocol *ipc_protocol =\n\t\tkzalloc(sizeof(*ipc_protocol), GFP_KERNEL);\n\tstruct ipc_protocol_context_info *p_ci;\n\tu64 addr;\n\n\tif (!ipc_protocol)\n\t\treturn NULL;\n\n\tipc_protocol->dev = ipc_imem->dev;\n\tipc_protocol->pcie = ipc_imem->pcie;\n\tipc_protocol->imem = ipc_imem;\n\tipc_protocol->p_ap_shm = NULL;\n\tipc_protocol->phy_ap_shm = 0;\n\n\tipc_protocol->old_msg_tail = 0;\n\n\tipc_protocol->p_ap_shm =\n\t\tdma_alloc_coherent(&ipc_protocol->pcie->pci->dev,\n\t\t\t\t   sizeof(*ipc_protocol->p_ap_shm),\n\t\t\t\t   &ipc_protocol->phy_ap_shm, GFP_KERNEL);\n\n\tif (!ipc_protocol->p_ap_shm) {\n\t\tdev_err(ipc_protocol->dev, \"pci shm alloc error\");\n\t\tkfree(ipc_protocol);\n\t\treturn NULL;\n\t}\n\n\t \n\taddr = ipc_protocol->phy_ap_shm;\n\tp_ci = &ipc_protocol->p_ap_shm->ci;\n\tp_ci->device_info_addr =\n\t\taddr + offsetof(struct ipc_protocol_ap_shm, device_info);\n\tp_ci->head_array =\n\t\taddr + offsetof(struct ipc_protocol_ap_shm, head_array);\n\tp_ci->tail_array =\n\t\taddr + offsetof(struct ipc_protocol_ap_shm, tail_array);\n\tp_ci->msg_head = addr + offsetof(struct ipc_protocol_ap_shm, msg_head);\n\tp_ci->msg_tail = addr + offsetof(struct ipc_protocol_ap_shm, msg_tail);\n\tp_ci->msg_ring_addr =\n\t\taddr + offsetof(struct ipc_protocol_ap_shm, msg_ring);\n\tp_ci->msg_ring_entries = cpu_to_le16(IPC_MEM_MSG_ENTRIES);\n\tp_ci->msg_irq_vector = IPC_MSG_IRQ_VECTOR;\n\tp_ci->device_info_irq_vector = IPC_DEVICE_IRQ_VECTOR;\n\n\tipc_mmio_set_contex_info_addr(ipc_imem->mmio, addr);\n\n\tipc_pm_init(ipc_protocol);\n\n\treturn ipc_protocol;\n}\n\nvoid ipc_protocol_deinit(struct iosm_protocol *proto)\n{\n\tdma_free_coherent(&proto->pcie->pci->dev, sizeof(*proto->p_ap_shm),\n\t\t\t  proto->p_ap_shm, proto->phy_ap_shm);\n\n\tipc_pm_deinit(proto);\n\tkfree(proto);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}