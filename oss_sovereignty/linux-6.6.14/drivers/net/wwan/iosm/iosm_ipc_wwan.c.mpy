{
  "module_name": "iosm_ipc_wwan.c",
  "hash_id": "fa5b52425e0bfcec56d9946ea02b0dfb9b2386e0c613ae8a7c9a1a32e0e30cb9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wwan/iosm/iosm_ipc_wwan.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/if_arp.h>\n#include <linux/if_link.h>\n#include <linux/rtnetlink.h>\n#include <linux/wwan.h>\n#include <net/pkt_sched.h>\n\n#include \"iosm_ipc_chnl_cfg.h\"\n#include \"iosm_ipc_imem_ops.h\"\n#include \"iosm_ipc_wwan.h\"\n\n#define IOSM_IP_TYPE_MASK 0xF0\n#define IOSM_IP_TYPE_IPV4 0x40\n#define IOSM_IP_TYPE_IPV6 0x60\n\n \nstruct iosm_netdev_priv {\n\tstruct iosm_wwan *ipc_wwan;\n\tstruct net_device *netdev;\n\tint if_id;\n\tint ch_id;\n};\n\n \nstruct iosm_wwan {\n\tstruct iosm_imem *ipc_imem;\n\tstruct iosm_netdev_priv __rcu *sub_netlist[IP_MUX_SESSION_END + 1];\n\tstruct device *dev;\n};\n\n \nstatic int ipc_wwan_link_open(struct net_device *netdev)\n{\n\tstruct iosm_netdev_priv *priv = wwan_netdev_drvpriv(netdev);\n\tstruct iosm_wwan *ipc_wwan = priv->ipc_wwan;\n\tint if_id = priv->if_id;\n\n\tif (if_id < IP_MUX_SESSION_START ||\n\t    if_id >= ARRAY_SIZE(ipc_wwan->sub_netlist))\n\t\treturn -EINVAL;\n\n\t \n\tpriv->ch_id = ipc_imem_sys_wwan_open(ipc_wwan->ipc_imem, if_id);\n\n\tif (priv->ch_id < 0) {\n\t\tdev_err(ipc_wwan->dev,\n\t\t\t\"cannot connect wwan0 & id %d to the IPC mem layer\",\n\t\t\tif_id);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tnetif_start_queue(netdev);\n\n\tdev_dbg(ipc_wwan->dev, \"Channel id %d allocated to if_id %d\",\n\t\tpriv->ch_id, priv->if_id);\n\n\treturn 0;\n}\n\n \nstatic int ipc_wwan_link_stop(struct net_device *netdev)\n{\n\tstruct iosm_netdev_priv *priv = wwan_netdev_drvpriv(netdev);\n\n\tnetif_stop_queue(netdev);\n\n\tipc_imem_sys_wwan_close(priv->ipc_wwan->ipc_imem, priv->if_id,\n\t\t\t\tpriv->ch_id);\n\tpriv->ch_id = -1;\n\n\treturn 0;\n}\n\n \nstatic netdev_tx_t ipc_wwan_link_transmit(struct sk_buff *skb,\n\t\t\t\t\t  struct net_device *netdev)\n{\n\tstruct iosm_netdev_priv *priv = wwan_netdev_drvpriv(netdev);\n\tstruct iosm_wwan *ipc_wwan = priv->ipc_wwan;\n\tunsigned int len = skb->len;\n\tint if_id = priv->if_id;\n\tint ret;\n\n\t \n\tif (if_id < IP_MUX_SESSION_START ||\n\t    if_id >= ARRAY_SIZE(ipc_wwan->sub_netlist))\n\t\treturn -EINVAL;\n\n\t \n\tret = ipc_imem_sys_wwan_transmit(ipc_wwan->ipc_imem,\n\t\t\t\t\t if_id, priv->ch_id, skb);\n\n\t \n\tif (ret == 0) {\n\t\tnetdev->stats.tx_packets++;\n\t\tnetdev->stats.tx_bytes += len;\n\t\tret = NETDEV_TX_OK;\n\t} else if (ret == -EBUSY) {\n\t\tret = NETDEV_TX_BUSY;\n\t\tdev_err(ipc_wwan->dev, \"unable to push packets\");\n\t} else {\n\t\tgoto exit;\n\t}\n\n\treturn ret;\n\nexit:\n\t \n\tif (if_id)\n\t\tdev_dbg(ipc_wwan->dev, \"skb dropped. IF_ID: %d, ret: %d\", if_id,\n\t\t\tret);\n\n\tdev_kfree_skb_any(skb);\n\tnetdev->stats.tx_dropped++;\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic const struct net_device_ops ipc_inm_ops = {\n\t.ndo_open = ipc_wwan_link_open,\n\t.ndo_stop = ipc_wwan_link_stop,\n\t.ndo_start_xmit = ipc_wwan_link_transmit,\n};\n\n \nstatic void ipc_wwan_setup(struct net_device *iosm_dev)\n{\n\tiosm_dev->header_ops = NULL;\n\tiosm_dev->hard_header_len = 0;\n\tiosm_dev->tx_queue_len = DEFAULT_TX_QUEUE_LEN;\n\n\tiosm_dev->type = ARPHRD_NONE;\n\tiosm_dev->mtu = ETH_DATA_LEN;\n\tiosm_dev->min_mtu = ETH_MIN_MTU;\n\tiosm_dev->max_mtu = ETH_MAX_MTU;\n\n\tiosm_dev->flags = IFF_POINTOPOINT | IFF_NOARP;\n\tiosm_dev->needs_free_netdev = true;\n\n\tiosm_dev->netdev_ops = &ipc_inm_ops;\n}\n\n \nstatic int ipc_wwan_newlink(void *ctxt, struct net_device *dev,\n\t\t\t    u32 if_id, struct netlink_ext_ack *extack)\n{\n\tstruct iosm_wwan *ipc_wwan = ctxt;\n\tstruct iosm_netdev_priv *priv;\n\tint err;\n\n\tif (if_id < IP_MUX_SESSION_START ||\n\t    if_id >= ARRAY_SIZE(ipc_wwan->sub_netlist))\n\t\treturn -EINVAL;\n\n\tpriv = wwan_netdev_drvpriv(dev);\n\tpriv->if_id = if_id;\n\tpriv->netdev = dev;\n\tpriv->ipc_wwan = ipc_wwan;\n\n\tif (rcu_access_pointer(ipc_wwan->sub_netlist[if_id]))\n\t\treturn -EBUSY;\n\n\terr = register_netdevice(dev);\n\tif (err)\n\t\treturn err;\n\n\trcu_assign_pointer(ipc_wwan->sub_netlist[if_id], priv);\n\tnetif_device_attach(dev);\n\n\treturn 0;\n}\n\nstatic void ipc_wwan_dellink(void *ctxt, struct net_device *dev,\n\t\t\t     struct list_head *head)\n{\n\tstruct iosm_netdev_priv *priv = wwan_netdev_drvpriv(dev);\n\tstruct iosm_wwan *ipc_wwan = ctxt;\n\tint if_id = priv->if_id;\n\n\tif (WARN_ON(if_id < IP_MUX_SESSION_START ||\n\t\t    if_id >= ARRAY_SIZE(ipc_wwan->sub_netlist)))\n\t\treturn;\n\n\tif (WARN_ON(rcu_access_pointer(ipc_wwan->sub_netlist[if_id]) != priv))\n\t\treturn;\n\n\tRCU_INIT_POINTER(ipc_wwan->sub_netlist[if_id], NULL);\n\t \n\tunregister_netdevice_queue(dev, head);\n}\n\nstatic const struct wwan_ops iosm_wwan_ops = {\n\t.priv_size = sizeof(struct iosm_netdev_priv),\n\t.setup = ipc_wwan_setup,\n\t.newlink = ipc_wwan_newlink,\n\t.dellink = ipc_wwan_dellink,\n};\n\nint ipc_wwan_receive(struct iosm_wwan *ipc_wwan, struct sk_buff *skb_arg,\n\t\t     bool dss, int if_id)\n{\n\tstruct sk_buff *skb = skb_arg;\n\tstruct net_device_stats *stats;\n\tstruct iosm_netdev_priv *priv;\n\tint ret;\n\n\tif ((skb->data[0] & IOSM_IP_TYPE_MASK) == IOSM_IP_TYPE_IPV4)\n\t\tskb->protocol = htons(ETH_P_IP);\n\telse if ((skb->data[0] & IOSM_IP_TYPE_MASK) ==\n\t\t IOSM_IP_TYPE_IPV6)\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\n\tskb->pkt_type = PACKET_HOST;\n\n\tif (if_id < IP_MUX_SESSION_START ||\n\t    if_id > IP_MUX_SESSION_END) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\trcu_read_lock();\n\tpriv = rcu_dereference(ipc_wwan->sub_netlist[if_id]);\n\tif (!priv) {\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\tskb->dev = priv->netdev;\n\tstats = &priv->netdev->stats;\n\tstats->rx_packets++;\n\tstats->rx_bytes += skb->len;\n\n\tret = netif_rx(skb);\n\tskb = NULL;\nunlock:\n\trcu_read_unlock();\nfree:\n\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nvoid ipc_wwan_tx_flowctrl(struct iosm_wwan *ipc_wwan, int if_id, bool on)\n{\n\tstruct net_device *netdev;\n\tstruct iosm_netdev_priv *priv;\n\tbool is_tx_blk;\n\n\trcu_read_lock();\n\tpriv = rcu_dereference(ipc_wwan->sub_netlist[if_id]);\n\tif (!priv) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tnetdev = priv->netdev;\n\n\tis_tx_blk = netif_queue_stopped(netdev);\n\n\tif (on)\n\t\tdev_dbg(ipc_wwan->dev, \"session id[%d]: flowctrl enable\",\n\t\t\tif_id);\n\n\tif (on && !is_tx_blk)\n\t\tnetif_stop_queue(netdev);\n\telse if (!on && is_tx_blk)\n\t\tnetif_wake_queue(netdev);\n\trcu_read_unlock();\n}\n\nstruct iosm_wwan *ipc_wwan_init(struct iosm_imem *ipc_imem, struct device *dev)\n{\n\tstruct iosm_wwan *ipc_wwan;\n\n\tipc_wwan = kzalloc(sizeof(*ipc_wwan), GFP_KERNEL);\n\tif (!ipc_wwan)\n\t\treturn NULL;\n\n\tipc_wwan->dev = dev;\n\tipc_wwan->ipc_imem = ipc_imem;\n\n\t \n\tif (wwan_register_ops(ipc_wwan->dev, &iosm_wwan_ops, ipc_wwan,\n\t\t\t      IP_MUX_SESSION_DEFAULT)) {\n\t\tkfree(ipc_wwan);\n\t\treturn NULL;\n\t}\n\n\treturn ipc_wwan;\n}\n\nvoid ipc_wwan_deinit(struct iosm_wwan *ipc_wwan)\n{\n\t \n\twwan_unregister_ops(ipc_wwan->dev);\n\n\tkfree(ipc_wwan);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}