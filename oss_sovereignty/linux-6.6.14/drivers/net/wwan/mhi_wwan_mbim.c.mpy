{
  "module_name": "mhi_wwan_mbim.c",
  "hash_id": "8f7c730481c759ddff7a31db0367a6c2775662e3f63b826a44ef0016988c7faa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wwan/mhi_wwan_mbim.c",
  "human_readable_source": "\n \n\n#include <linux/ethtool.h>\n#include <linux/if_arp.h>\n#include <linux/if_vlan.h>\n#include <linux/ip.h>\n#include <linux/mhi.h>\n#include <linux/mii.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/u64_stats_sync.h>\n#include <linux/usb.h>\n#include <linux/usb/cdc.h>\n#include <linux/usb/usbnet.h>\n#include <linux/usb/cdc_ncm.h>\n#include <linux/wwan.h>\n\n \n#define MHI_DEFAULT_MRU 3500\n\n#define MHI_MBIM_DEFAULT_MTU 1500\n#define MHI_MAX_BUF_SZ 0xffff\n\n#define MBIM_NDP16_SIGN_MASK 0x00ffffff\n\n#define MHI_MBIM_LINK_HASH_SIZE 8\n#define LINK_HASH(session) ((session) % MHI_MBIM_LINK_HASH_SIZE)\n\nstruct mhi_mbim_link {\n\tstruct mhi_mbim_context *mbim;\n\tstruct net_device *ndev;\n\tunsigned int session;\n\n\t \n\tu64_stats_t rx_packets;\n\tu64_stats_t rx_bytes;\n\tu64_stats_t rx_errors;\n\tu64_stats_t tx_packets;\n\tu64_stats_t tx_bytes;\n\tu64_stats_t tx_errors;\n\tu64_stats_t tx_dropped;\n\tstruct u64_stats_sync tx_syncp;\n\tstruct u64_stats_sync rx_syncp;\n\n\tstruct hlist_node hlnode;\n};\n\nstruct mhi_mbim_context {\n\tstruct mhi_device *mdev;\n\tstruct sk_buff *skbagg_head;\n\tstruct sk_buff *skbagg_tail;\n\tunsigned int mru;\n\tu32 rx_queue_sz;\n\tu16 rx_seq;\n\tu16 tx_seq;\n\tstruct delayed_work rx_refill;\n\tspinlock_t tx_lock;\n\tstruct hlist_head link_list[MHI_MBIM_LINK_HASH_SIZE];\n};\n\nstruct mbim_tx_hdr {\n\tstruct usb_cdc_ncm_nth16 nth16;\n\tstruct usb_cdc_ncm_ndp16 ndp16;\n\tstruct usb_cdc_ncm_dpe16 dpe16[2];\n} __packed;\n\nstatic struct mhi_mbim_link *mhi_mbim_get_link_rcu(struct mhi_mbim_context *mbim,\n\t\t\t\t\t\t   unsigned int session)\n{\n\tstruct mhi_mbim_link *link;\n\n\thlist_for_each_entry_rcu(link, &mbim->link_list[LINK_HASH(session)], hlnode) {\n\t\tif (link->session == session)\n\t\t\treturn link;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct sk_buff *mbim_tx_fixup(struct sk_buff *skb, unsigned int session,\n\t\t\t\t     u16 tx_seq)\n{\n\tunsigned int dgram_size = skb->len;\n\tstruct usb_cdc_ncm_nth16 *nth16;\n\tstruct usb_cdc_ncm_ndp16 *ndp16;\n\tstruct mbim_tx_hdr *mbim_hdr;\n\n\t \n\n\t \n\tif (skb_cow_head(skb, sizeof(struct mbim_tx_hdr))) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NULL;\n\t}\n\n\tmbim_hdr = skb_push(skb, sizeof(struct mbim_tx_hdr));\n\n\t \n\tnth16 = &mbim_hdr->nth16;\n\tnth16->dwSignature = cpu_to_le32(USB_CDC_NCM_NTH16_SIGN);\n\tnth16->wHeaderLength = cpu_to_le16(sizeof(struct usb_cdc_ncm_nth16));\n\tnth16->wSequence = cpu_to_le16(tx_seq);\n\tnth16->wBlockLength = cpu_to_le16(skb->len);\n\tnth16->wNdpIndex = cpu_to_le16(sizeof(struct usb_cdc_ncm_nth16));\n\n\t \n\tndp16 = &mbim_hdr->ndp16;\n\tndp16->dwSignature = cpu_to_le32(USB_CDC_MBIM_NDP16_IPS_SIGN | (session << 24));\n\tndp16->wLength = cpu_to_le16(sizeof(struct usb_cdc_ncm_ndp16)\n\t\t\t\t\t+ sizeof(struct usb_cdc_ncm_dpe16) * 2);\n\tndp16->wNextNdpIndex = 0;\n\n\t \n\tndp16->dpe16[0].wDatagramIndex = cpu_to_le16(sizeof(struct mbim_tx_hdr));\n\tndp16->dpe16[0].wDatagramLength = cpu_to_le16(dgram_size);\n\n\t \n\tndp16->dpe16[1].wDatagramIndex = 0;\n\tndp16->dpe16[1].wDatagramLength = 0;\n\n\treturn skb;\n}\n\nstatic netdev_tx_t mhi_mbim_ndo_xmit(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct mhi_mbim_link *link = wwan_netdev_drvpriv(ndev);\n\tstruct mhi_mbim_context *mbim = link->mbim;\n\tunsigned long flags;\n\tint err = -ENOMEM;\n\n\t \n\tspin_lock_irqsave(&mbim->tx_lock, flags);\n\n\tskb = mbim_tx_fixup(skb, link->session, mbim->tx_seq);\n\tif (unlikely(!skb))\n\t\tgoto exit_unlock;\n\n\terr = mhi_queue_skb(mbim->mdev, DMA_TO_DEVICE, skb, skb->len, MHI_EOT);\n\n\tif (mhi_queue_is_full(mbim->mdev, DMA_TO_DEVICE))\n\t\tnetif_stop_queue(ndev);\n\n\tif (!err)\n\t\tmbim->tx_seq++;\n\nexit_unlock:\n\tspin_unlock_irqrestore(&mbim->tx_lock, flags);\n\n\tif (unlikely(err)) {\n\t\tnet_err_ratelimited(\"%s: Failed to queue TX buf (%d)\\n\",\n\t\t\t\t    ndev->name, err);\n\t\tdev_kfree_skb_any(skb);\n\t\tgoto exit_drop;\n\t}\n\n\treturn NETDEV_TX_OK;\n\nexit_drop:\n\tu64_stats_update_begin(&link->tx_syncp);\n\tu64_stats_inc(&link->tx_dropped);\n\tu64_stats_update_end(&link->tx_syncp);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int mbim_rx_verify_nth16(struct mhi_mbim_context *mbim, struct sk_buff *skb)\n{\n\tstruct usb_cdc_ncm_nth16 *nth16;\n\tint len;\n\n\tif (skb->len < sizeof(struct usb_cdc_ncm_nth16) +\n\t\t\tsizeof(struct usb_cdc_ncm_ndp16)) {\n\t\tnet_err_ratelimited(\"frame too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnth16 = (struct usb_cdc_ncm_nth16 *)skb->data;\n\n\tif (nth16->dwSignature != cpu_to_le32(USB_CDC_NCM_NTH16_SIGN)) {\n\t\tnet_err_ratelimited(\"invalid NTH16 signature <%#010x>\\n\",\n\t\t\t\t    le32_to_cpu(nth16->dwSignature));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tlen = le16_to_cpu(nth16->wBlockLength);\n\tif (len > skb->len) {\n\t\tnet_err_ratelimited(\"NTB does not fit into the skb %u/%u\\n\",\n\t\t\t\t    len, skb->len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mbim->rx_seq + 1 != le16_to_cpu(nth16->wSequence) &&\n\t    (mbim->rx_seq || le16_to_cpu(nth16->wSequence)) &&\n\t    !(mbim->rx_seq == 0xffff && !le16_to_cpu(nth16->wSequence))) {\n\t\tnet_err_ratelimited(\"sequence number glitch prev=%d curr=%d\\n\",\n\t\t\t\t    mbim->rx_seq, le16_to_cpu(nth16->wSequence));\n\t}\n\tmbim->rx_seq = le16_to_cpu(nth16->wSequence);\n\n\treturn le16_to_cpu(nth16->wNdpIndex);\n}\n\nstatic int mbim_rx_verify_ndp16(struct sk_buff *skb, struct usb_cdc_ncm_ndp16 *ndp16)\n{\n\tint ret;\n\n\tif (le16_to_cpu(ndp16->wLength) < USB_CDC_NCM_NDP16_LENGTH_MIN) {\n\t\tnet_err_ratelimited(\"invalid DPT16 length <%u>\\n\",\n\t\t\t\t    le16_to_cpu(ndp16->wLength));\n\t\treturn -EINVAL;\n\t}\n\n\tret = ((le16_to_cpu(ndp16->wLength) - sizeof(struct usb_cdc_ncm_ndp16))\n\t\t\t/ sizeof(struct usb_cdc_ncm_dpe16));\n\tret--;  \n\n\tif (sizeof(struct usb_cdc_ncm_ndp16) +\n\t     ret * sizeof(struct usb_cdc_ncm_dpe16) > skb->len) {\n\t\tnet_err_ratelimited(\"Invalid nframes = %d\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic void mhi_mbim_rx(struct mhi_mbim_context *mbim, struct sk_buff *skb)\n{\n\tint ndpoffset;\n\n\t \n\tndpoffset = mbim_rx_verify_nth16(mbim, skb);\n\tif (ndpoffset < 0) {\n\t\tnet_err_ratelimited(\"mbim: Incorrect NTB header\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\twhile (1) {\n\t\tstruct usb_cdc_ncm_ndp16 ndp16;\n\t\tstruct usb_cdc_ncm_dpe16 dpe16;\n\t\tstruct mhi_mbim_link *link;\n\t\tint nframes, n, dpeoffset;\n\t\tunsigned int session;\n\n\t\tif (skb_copy_bits(skb, ndpoffset, &ndp16, sizeof(ndp16))) {\n\t\t\tnet_err_ratelimited(\"mbim: Incorrect NDP offset (%u)\\n\",\n\t\t\t\t\t    ndpoffset);\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tnframes = mbim_rx_verify_ndp16(skb, &ndp16);\n\t\tif (nframes < 0) {\n\t\t\tnet_err_ratelimited(\"mbim: Incorrect NDP16\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\t  \n\t\tif ((ndp16.dwSignature & cpu_to_le32(MBIM_NDP16_SIGN_MASK))\n\t\t\t\t!= cpu_to_le32(USB_CDC_MBIM_NDP16_IPS_SIGN)) {\n\t\t\tnet_err_ratelimited(\"mbim: Unsupported NDP type\\n\");\n\t\t\tgoto next_ndp;\n\t\t}\n\n\t\tsession = (le32_to_cpu(ndp16.dwSignature) & ~MBIM_NDP16_SIGN_MASK) >> 24;\n\n\t\trcu_read_lock();\n\n\t\tlink = mhi_mbim_get_link_rcu(mbim, session);\n\t\tif (!link) {\n\t\t\tnet_err_ratelimited(\"mbim: bad packet session (%u)\\n\", session);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\t \n\t\tdpeoffset = ndpoffset + sizeof(struct usb_cdc_ncm_ndp16);\n\t\tfor (n = 0; n < nframes; n++, dpeoffset += sizeof(dpe16)) {\n\t\t\tu16 dgram_offset, dgram_len;\n\t\t\tstruct sk_buff *skbn;\n\n\t\t\tif (skb_copy_bits(skb, dpeoffset, &dpe16, sizeof(dpe16)))\n\t\t\t\tbreak;\n\n\t\t\tdgram_offset = le16_to_cpu(dpe16.wDatagramIndex);\n\t\t\tdgram_len = le16_to_cpu(dpe16.wDatagramLength);\n\n\t\t\tif (!dgram_offset || !dgram_len)\n\t\t\t\tbreak;  \n\n\t\t\tskbn = netdev_alloc_skb(link->ndev, dgram_len);\n\t\t\tif (!skbn)\n\t\t\t\tcontinue;\n\n\t\t\tskb_put(skbn, dgram_len);\n\t\t\tskb_copy_bits(skb, dgram_offset, skbn->data, dgram_len);\n\n\t\t\tswitch (skbn->data[0] & 0xf0) {\n\t\t\tcase 0x40:\n\t\t\t\tskbn->protocol = htons(ETH_P_IP);\n\t\t\t\tbreak;\n\t\t\tcase 0x60:\n\t\t\t\tskbn->protocol = htons(ETH_P_IPV6);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tnet_err_ratelimited(\"%s: unknown protocol\\n\",\n\t\t\t\t\t\t    link->ndev->name);\n\t\t\t\tdev_kfree_skb_any(skbn);\n\t\t\t\tu64_stats_update_begin(&link->rx_syncp);\n\t\t\t\tu64_stats_inc(&link->rx_errors);\n\t\t\t\tu64_stats_update_end(&link->rx_syncp);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tu64_stats_update_begin(&link->rx_syncp);\n\t\t\tu64_stats_inc(&link->rx_packets);\n\t\t\tu64_stats_add(&link->rx_bytes, skbn->len);\n\t\t\tu64_stats_update_end(&link->rx_syncp);\n\n\t\t\tnetif_rx(skbn);\n\t\t}\nunlock:\n\t\trcu_read_unlock();\nnext_ndp:\n\t\t \n\t\tndpoffset = (int)le16_to_cpu(ndp16.wNextNdpIndex);\n\t\tif (!ndpoffset)\n\t\t\tbreak;\n\t}\n\n\t \n\tdev_consume_skb_any(skb);\n\treturn;\nerror:\n\tdev_kfree_skb_any(skb);\n}\n\nstatic struct sk_buff *mhi_net_skb_agg(struct mhi_mbim_context *mbim,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct sk_buff *head = mbim->skbagg_head;\n\tstruct sk_buff *tail = mbim->skbagg_tail;\n\n\t \n\tif (!head) {\n\t\tmbim->skbagg_head = skb;\n\t\treturn skb;\n\t}\n\n\tif (!skb_shinfo(head)->frag_list)\n\t\tskb_shinfo(head)->frag_list = skb;\n\telse\n\t\ttail->next = skb;\n\n\thead->len += skb->len;\n\thead->data_len += skb->len;\n\thead->truesize += skb->truesize;\n\n\tmbim->skbagg_tail = skb;\n\n\treturn mbim->skbagg_head;\n}\n\nstatic void mhi_net_rx_refill_work(struct work_struct *work)\n{\n\tstruct mhi_mbim_context *mbim = container_of(work, struct mhi_mbim_context,\n\t\t\t\t\t\t     rx_refill.work);\n\tstruct mhi_device *mdev = mbim->mdev;\n\tint err;\n\n\twhile (!mhi_queue_is_full(mdev, DMA_FROM_DEVICE)) {\n\t\tstruct sk_buff *skb = alloc_skb(mbim->mru, GFP_KERNEL);\n\n\t\tif (unlikely(!skb))\n\t\t\tbreak;\n\n\t\terr = mhi_queue_skb(mdev, DMA_FROM_DEVICE, skb,\n\t\t\t\t    mbim->mru, MHI_EOT);\n\t\tif (unlikely(err)) {\n\t\t\tkfree_skb(skb);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tcond_resched();\n\t}\n\n\t \n\tif (mhi_get_free_desc_count(mdev, DMA_FROM_DEVICE) == mbim->rx_queue_sz)\n\t\tschedule_delayed_work(&mbim->rx_refill, HZ / 2);\n}\n\nstatic void mhi_mbim_dl_callback(struct mhi_device *mhi_dev,\n\t\t\t\t struct mhi_result *mhi_res)\n{\n\tstruct mhi_mbim_context *mbim = dev_get_drvdata(&mhi_dev->dev);\n\tstruct sk_buff *skb = mhi_res->buf_addr;\n\tint free_desc_count;\n\n\tfree_desc_count = mhi_get_free_desc_count(mhi_dev, DMA_FROM_DEVICE);\n\n\tif (unlikely(mhi_res->transaction_status)) {\n\t\tswitch (mhi_res->transaction_status) {\n\t\tcase -EOVERFLOW:\n\t\t\t \n\t\t\tskb_put(skb, mhi_res->bytes_xferd);\n\t\t\tmhi_net_skb_agg(mbim, skb);\n\t\t\tbreak;\n\t\tcase -ENOTCONN:\n\t\t\t \n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn;\n\t\tdefault:\n\t\t\t \n\t\t\tdev_kfree_skb_any(skb);\n\t\t}\n\t} else {\n\t\tskb_put(skb, mhi_res->bytes_xferd);\n\n\t\tif (mbim->skbagg_head) {\n\t\t\t \n\t\t\tskb = mhi_net_skb_agg(mbim, skb);\n\t\t\tmbim->skbagg_head = NULL;\n\t\t}\n\n\t\tmhi_mbim_rx(mbim, skb);\n\t}\n\n\t \n\tif (free_desc_count >= mbim->rx_queue_sz / 2)\n\t\tschedule_delayed_work(&mbim->rx_refill, 0);\n}\n\nstatic void mhi_mbim_ndo_get_stats64(struct net_device *ndev,\n\t\t\t\t     struct rtnl_link_stats64 *stats)\n{\n\tstruct mhi_mbim_link *link = wwan_netdev_drvpriv(ndev);\n\tunsigned int start;\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin(&link->rx_syncp);\n\t\tstats->rx_packets = u64_stats_read(&link->rx_packets);\n\t\tstats->rx_bytes = u64_stats_read(&link->rx_bytes);\n\t\tstats->rx_errors = u64_stats_read(&link->rx_errors);\n\t} while (u64_stats_fetch_retry(&link->rx_syncp, start));\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin(&link->tx_syncp);\n\t\tstats->tx_packets = u64_stats_read(&link->tx_packets);\n\t\tstats->tx_bytes = u64_stats_read(&link->tx_bytes);\n\t\tstats->tx_errors = u64_stats_read(&link->tx_errors);\n\t\tstats->tx_dropped = u64_stats_read(&link->tx_dropped);\n\t} while (u64_stats_fetch_retry(&link->tx_syncp, start));\n}\n\nstatic void mhi_mbim_ul_callback(struct mhi_device *mhi_dev,\n\t\t\t\t struct mhi_result *mhi_res)\n{\n\tstruct mhi_mbim_context *mbim = dev_get_drvdata(&mhi_dev->dev);\n\tstruct sk_buff *skb = mhi_res->buf_addr;\n\tstruct net_device *ndev = skb->dev;\n\tstruct mhi_mbim_link *link = wwan_netdev_drvpriv(ndev);\n\n\t \n\tdev_consume_skb_any(skb);\n\n\tu64_stats_update_begin(&link->tx_syncp);\n\tif (unlikely(mhi_res->transaction_status)) {\n\t\t \n\t\tif (mhi_res->transaction_status == -ENOTCONN) {\n\t\t\tu64_stats_update_end(&link->tx_syncp);\n\t\t\treturn;\n\t\t}\n\n\t\tu64_stats_inc(&link->tx_errors);\n\t} else {\n\t\tu64_stats_inc(&link->tx_packets);\n\t\tu64_stats_add(&link->tx_bytes, mhi_res->bytes_xferd);\n\t}\n\tu64_stats_update_end(&link->tx_syncp);\n\n\tif (netif_queue_stopped(ndev) && !mhi_queue_is_full(mbim->mdev, DMA_TO_DEVICE))\n\t\tnetif_wake_queue(ndev);\n}\n\nstatic int mhi_mbim_ndo_open(struct net_device *ndev)\n{\n\tstruct mhi_mbim_link *link = wwan_netdev_drvpriv(ndev);\n\n\t \n\tschedule_delayed_work(&link->mbim->rx_refill, 0);\n\n\t \n\tnetif_carrier_on(ndev);\n\n\tnetif_start_queue(ndev);\n\n\treturn 0;\n}\n\nstatic int mhi_mbim_ndo_stop(struct net_device *ndev)\n{\n\tnetif_stop_queue(ndev);\n\tnetif_carrier_off(ndev);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops mhi_mbim_ndo = {\n\t.ndo_open = mhi_mbim_ndo_open,\n\t.ndo_stop = mhi_mbim_ndo_stop,\n\t.ndo_start_xmit = mhi_mbim_ndo_xmit,\n\t.ndo_get_stats64 = mhi_mbim_ndo_get_stats64,\n};\n\nstatic int mhi_mbim_newlink(void *ctxt, struct net_device *ndev, u32 if_id,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct mhi_mbim_link *link = wwan_netdev_drvpriv(ndev);\n\tstruct mhi_mbim_context *mbim = ctxt;\n\n\tlink->session = if_id;\n\tlink->mbim = mbim;\n\tlink->ndev = ndev;\n\tu64_stats_init(&link->rx_syncp);\n\tu64_stats_init(&link->tx_syncp);\n\n\trcu_read_lock();\n\tif (mhi_mbim_get_link_rcu(mbim, if_id)) {\n\t\trcu_read_unlock();\n\t\treturn -EEXIST;\n\t}\n\trcu_read_unlock();\n\n\t \n\thlist_add_head_rcu(&link->hlnode, &mbim->link_list[LINK_HASH(if_id)]);\n\n\treturn register_netdevice(ndev);\n}\n\nstatic void mhi_mbim_dellink(void *ctxt, struct net_device *ndev,\n\t\t\t     struct list_head *head)\n{\n\tstruct mhi_mbim_link *link = wwan_netdev_drvpriv(ndev);\n\n\thlist_del_init_rcu(&link->hlnode);\n\tsynchronize_rcu();\n\n\tunregister_netdevice_queue(ndev, head);\n}\n\nstatic void mhi_mbim_setup(struct net_device *ndev)\n{\n\tndev->header_ops = NULL;   \n\tndev->type = ARPHRD_RAWIP;\n\tndev->needed_headroom = sizeof(struct mbim_tx_hdr);\n\tndev->hard_header_len = 0;\n\tndev->addr_len = 0;\n\tndev->flags = IFF_POINTOPOINT | IFF_NOARP;\n\tndev->netdev_ops = &mhi_mbim_ndo;\n\tndev->mtu = MHI_MBIM_DEFAULT_MTU;\n\tndev->min_mtu = ETH_MIN_MTU;\n\tndev->max_mtu = MHI_MAX_BUF_SZ - ndev->needed_headroom;\n\tndev->tx_queue_len = 1000;\n\tndev->needs_free_netdev = true;\n}\n\nstatic const struct wwan_ops mhi_mbim_wwan_ops = {\n\t.priv_size = sizeof(struct mhi_mbim_link),\n\t.setup = mhi_mbim_setup,\n\t.newlink = mhi_mbim_newlink,\n\t.dellink = mhi_mbim_dellink,\n};\n\nstatic int mhi_mbim_probe(struct mhi_device *mhi_dev, const struct mhi_device_id *id)\n{\n\tstruct mhi_controller *cntrl = mhi_dev->mhi_cntrl;\n\tstruct mhi_mbim_context *mbim;\n\tint err;\n\n\tmbim = devm_kzalloc(&mhi_dev->dev, sizeof(*mbim), GFP_KERNEL);\n\tif (!mbim)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&mbim->tx_lock);\n\tdev_set_drvdata(&mhi_dev->dev, mbim);\n\tmbim->mdev = mhi_dev;\n\tmbim->mru = mhi_dev->mhi_cntrl->mru ? mhi_dev->mhi_cntrl->mru : MHI_DEFAULT_MRU;\n\n\tINIT_DELAYED_WORK(&mbim->rx_refill, mhi_net_rx_refill_work);\n\n\t \n\terr = mhi_prepare_for_transfer(mhi_dev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tmbim->rx_queue_sz = mhi_get_free_desc_count(mhi_dev, DMA_FROM_DEVICE);\n\n\t \n\treturn wwan_register_ops(&cntrl->mhi_dev->dev, &mhi_mbim_wwan_ops, mbim, 0);\n}\n\nstatic void mhi_mbim_remove(struct mhi_device *mhi_dev)\n{\n\tstruct mhi_mbim_context *mbim = dev_get_drvdata(&mhi_dev->dev);\n\tstruct mhi_controller *cntrl = mhi_dev->mhi_cntrl;\n\n\tmhi_unprepare_from_transfer(mhi_dev);\n\tcancel_delayed_work_sync(&mbim->rx_refill);\n\twwan_unregister_ops(&cntrl->mhi_dev->dev);\n\tkfree_skb(mbim->skbagg_head);\n\tdev_set_drvdata(&mhi_dev->dev, NULL);\n}\n\nstatic const struct mhi_device_id mhi_mbim_id_table[] = {\n\t \n\t{ .chan = \"IP_HW0_MBIM\", .driver_data = 0 },\n\t{}\n};\nMODULE_DEVICE_TABLE(mhi, mhi_mbim_id_table);\n\nstatic struct mhi_driver mhi_mbim_driver = {\n\t.probe = mhi_mbim_probe,\n\t.remove = mhi_mbim_remove,\n\t.dl_xfer_cb = mhi_mbim_dl_callback,\n\t.ul_xfer_cb = mhi_mbim_ul_callback,\n\t.id_table = mhi_mbim_id_table,\n\t.driver = {\n\t\t.name = \"mhi_wwan_mbim\",\n\t\t.owner = THIS_MODULE,\n\t},\n};\n\nmodule_mhi_driver(mhi_mbim_driver);\n\nMODULE_AUTHOR(\"Loic Poulain <loic.poulain@linaro.org>\");\nMODULE_DESCRIPTION(\"Network/MBIM over MHI\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}