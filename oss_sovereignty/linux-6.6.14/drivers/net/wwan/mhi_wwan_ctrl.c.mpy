{
  "module_name": "mhi_wwan_ctrl.c",
  "hash_id": "317774ba004992a86424af4987ace2b8226cc9e87aa10bed11813d0038f963a0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wwan/mhi_wwan_ctrl.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/mhi.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/wwan.h>\n\n \nenum mhi_wwan_flags {\n\tMHI_WWAN_DL_CAP,\n\tMHI_WWAN_UL_CAP,\n\tMHI_WWAN_RX_REFILL,\n};\n\n#define MHI_WWAN_MAX_MTU\t0x8000\n\nstruct mhi_wwan_dev {\n\t \n\tstruct mhi_device *mhi_dev;\n\tstruct wwan_port *wwan_port;\n\n\t \n\tunsigned long flags;\n\tsize_t mtu;\n\n\t \n\tspinlock_t tx_lock;\n\n\t \n\tspinlock_t rx_lock;\n\tstruct work_struct rx_refill;\n\n\t \n\tunsigned int rx_budget;\n};\n\n \nstatic void mhi_wwan_rx_budget_inc(struct mhi_wwan_dev *mhiwwan)\n{\n\tspin_lock_bh(&mhiwwan->rx_lock);\n\n\tmhiwwan->rx_budget++;\n\n\tif (test_bit(MHI_WWAN_RX_REFILL, &mhiwwan->flags))\n\t\tschedule_work(&mhiwwan->rx_refill);\n\n\tspin_unlock_bh(&mhiwwan->rx_lock);\n}\n\n \nstatic bool mhi_wwan_rx_budget_dec(struct mhi_wwan_dev *mhiwwan)\n{\n\tbool ret = false;\n\n\tspin_lock_bh(&mhiwwan->rx_lock);\n\n\tif (mhiwwan->rx_budget) {\n\t\tmhiwwan->rx_budget--;\n\t\tif (test_bit(MHI_WWAN_RX_REFILL, &mhiwwan->flags))\n\t\t\tret = true;\n\t}\n\n\tspin_unlock_bh(&mhiwwan->rx_lock);\n\n\treturn ret;\n}\n\nstatic void __mhi_skb_destructor(struct sk_buff *skb)\n{\n\t \n\tmhi_wwan_rx_budget_inc(skb_shinfo(skb)->destructor_arg);\n}\n\nstatic void mhi_wwan_ctrl_refill_work(struct work_struct *work)\n{\n\tstruct mhi_wwan_dev *mhiwwan = container_of(work, struct mhi_wwan_dev, rx_refill);\n\tstruct mhi_device *mhi_dev = mhiwwan->mhi_dev;\n\n\twhile (mhi_wwan_rx_budget_dec(mhiwwan)) {\n\t\tstruct sk_buff *skb;\n\n\t\tskb = alloc_skb(mhiwwan->mtu, GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\tmhi_wwan_rx_budget_inc(mhiwwan);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tskb->destructor = __mhi_skb_destructor;\n\t\tskb_shinfo(skb)->destructor_arg = mhiwwan;\n\n\t\tif (mhi_queue_skb(mhi_dev, DMA_FROM_DEVICE, skb, mhiwwan->mtu, MHI_EOT)) {\n\t\t\tdev_err(&mhi_dev->dev, \"Failed to queue buffer\\n\");\n\t\t\tkfree_skb(skb);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic int mhi_wwan_ctrl_start(struct wwan_port *port)\n{\n\tstruct mhi_wwan_dev *mhiwwan = wwan_port_get_drvdata(port);\n\tint ret;\n\n\t \n\tret = mhi_prepare_for_transfer(mhiwwan->mhi_dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmhiwwan->rx_budget = mhi_get_free_desc_count(mhiwwan->mhi_dev, DMA_FROM_DEVICE);\n\n\t \n\tif (test_bit(MHI_WWAN_DL_CAP, &mhiwwan->flags)) {\n\t\tset_bit(MHI_WWAN_RX_REFILL, &mhiwwan->flags);\n\t\tmhi_wwan_ctrl_refill_work(&mhiwwan->rx_refill);\n\t}\n\n\treturn 0;\n}\n\nstatic void mhi_wwan_ctrl_stop(struct wwan_port *port)\n{\n\tstruct mhi_wwan_dev *mhiwwan = wwan_port_get_drvdata(port);\n\n\tspin_lock_bh(&mhiwwan->rx_lock);\n\tclear_bit(MHI_WWAN_RX_REFILL, &mhiwwan->flags);\n\tspin_unlock_bh(&mhiwwan->rx_lock);\n\n\tcancel_work_sync(&mhiwwan->rx_refill);\n\n\tmhi_unprepare_from_transfer(mhiwwan->mhi_dev);\n}\n\nstatic int mhi_wwan_ctrl_tx(struct wwan_port *port, struct sk_buff *skb)\n{\n\tstruct mhi_wwan_dev *mhiwwan = wwan_port_get_drvdata(port);\n\tint ret;\n\n\tif (skb->len > mhiwwan->mtu)\n\t\treturn -EMSGSIZE;\n\n\tif (!test_bit(MHI_WWAN_UL_CAP, &mhiwwan->flags))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tspin_lock_bh(&mhiwwan->tx_lock);\n\tret = mhi_queue_skb(mhiwwan->mhi_dev, DMA_TO_DEVICE, skb, skb->len, MHI_EOT);\n\tif (mhi_queue_is_full(mhiwwan->mhi_dev, DMA_TO_DEVICE))\n\t\twwan_port_txoff(port);\n\tspin_unlock_bh(&mhiwwan->tx_lock);\n\n\treturn ret;\n}\n\nstatic const struct wwan_port_ops wwan_pops = {\n\t.start = mhi_wwan_ctrl_start,\n\t.stop = mhi_wwan_ctrl_stop,\n\t.tx = mhi_wwan_ctrl_tx,\n};\n\nstatic void mhi_ul_xfer_cb(struct mhi_device *mhi_dev,\n\t\t\t   struct mhi_result *mhi_result)\n{\n\tstruct mhi_wwan_dev *mhiwwan = dev_get_drvdata(&mhi_dev->dev);\n\tstruct wwan_port *port = mhiwwan->wwan_port;\n\tstruct sk_buff *skb = mhi_result->buf_addr;\n\n\tdev_dbg(&mhi_dev->dev, \"%s: status: %d xfer_len: %zu\\n\", __func__,\n\t\tmhi_result->transaction_status, mhi_result->bytes_xferd);\n\n\t \n\tconsume_skb(skb);\n\n\t \n\tspin_lock_bh(&mhiwwan->tx_lock);\n\tif (!mhi_queue_is_full(mhiwwan->mhi_dev, DMA_TO_DEVICE))\n\t\twwan_port_txon(port);\n\tspin_unlock_bh(&mhiwwan->tx_lock);\n}\n\nstatic void mhi_dl_xfer_cb(struct mhi_device *mhi_dev,\n\t\t\t   struct mhi_result *mhi_result)\n{\n\tstruct mhi_wwan_dev *mhiwwan = dev_get_drvdata(&mhi_dev->dev);\n\tstruct wwan_port *port = mhiwwan->wwan_port;\n\tstruct sk_buff *skb = mhi_result->buf_addr;\n\n\tdev_dbg(&mhi_dev->dev, \"%s: status: %d receive_len: %zu\\n\", __func__,\n\t\tmhi_result->transaction_status, mhi_result->bytes_xferd);\n\n\tif (mhi_result->transaction_status &&\n\t    mhi_result->transaction_status != -EOVERFLOW) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\t \n\tskb_put(skb, mhi_result->bytes_xferd);\n\twwan_port_rx(port, skb);\n\n\t \n}\n\nstatic int mhi_wwan_ctrl_probe(struct mhi_device *mhi_dev,\n\t\t\t       const struct mhi_device_id *id)\n{\n\tstruct mhi_controller *cntrl = mhi_dev->mhi_cntrl;\n\tstruct mhi_wwan_dev *mhiwwan;\n\tstruct wwan_port *port;\n\n\tmhiwwan = kzalloc(sizeof(*mhiwwan), GFP_KERNEL);\n\tif (!mhiwwan)\n\t\treturn -ENOMEM;\n\n\tmhiwwan->mhi_dev = mhi_dev;\n\tmhiwwan->mtu = MHI_WWAN_MAX_MTU;\n\tINIT_WORK(&mhiwwan->rx_refill, mhi_wwan_ctrl_refill_work);\n\tspin_lock_init(&mhiwwan->tx_lock);\n\tspin_lock_init(&mhiwwan->rx_lock);\n\n\tif (mhi_dev->dl_chan)\n\t\tset_bit(MHI_WWAN_DL_CAP, &mhiwwan->flags);\n\tif (mhi_dev->ul_chan)\n\t\tset_bit(MHI_WWAN_UL_CAP, &mhiwwan->flags);\n\n\tdev_set_drvdata(&mhi_dev->dev, mhiwwan);\n\n\t \n\tport = wwan_create_port(&cntrl->mhi_dev->dev, id->driver_data,\n\t\t\t\t&wwan_pops, NULL, mhiwwan);\n\tif (IS_ERR(port)) {\n\t\tkfree(mhiwwan);\n\t\treturn PTR_ERR(port);\n\t}\n\n\tmhiwwan->wwan_port = port;\n\n\treturn 0;\n};\n\nstatic void mhi_wwan_ctrl_remove(struct mhi_device *mhi_dev)\n{\n\tstruct mhi_wwan_dev *mhiwwan = dev_get_drvdata(&mhi_dev->dev);\n\n\twwan_remove_port(mhiwwan->wwan_port);\n\tkfree(mhiwwan);\n}\n\nstatic const struct mhi_device_id mhi_wwan_ctrl_match_table[] = {\n\t{ .chan = \"DUN\", .driver_data = WWAN_PORT_AT },\n\t{ .chan = \"DUN2\", .driver_data = WWAN_PORT_AT },\n\t{ .chan = \"MBIM\", .driver_data = WWAN_PORT_MBIM },\n\t{ .chan = \"QMI\", .driver_data = WWAN_PORT_QMI },\n\t{ .chan = \"DIAG\", .driver_data = WWAN_PORT_QCDM },\n\t{ .chan = \"FIREHOSE\", .driver_data = WWAN_PORT_FIREHOSE },\n\t{},\n};\nMODULE_DEVICE_TABLE(mhi, mhi_wwan_ctrl_match_table);\n\nstatic struct mhi_driver mhi_wwan_ctrl_driver = {\n\t.id_table = mhi_wwan_ctrl_match_table,\n\t.remove = mhi_wwan_ctrl_remove,\n\t.probe = mhi_wwan_ctrl_probe,\n\t.ul_xfer_cb = mhi_ul_xfer_cb,\n\t.dl_xfer_cb = mhi_dl_xfer_cb,\n\t.driver = {\n\t\t.name = \"mhi_wwan_ctrl\",\n\t},\n};\n\nmodule_mhi_driver(mhi_wwan_ctrl_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"MHI WWAN CTRL Driver\");\nMODULE_AUTHOR(\"Loic Poulain <loic.poulain@linaro.org>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}