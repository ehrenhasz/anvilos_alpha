{
  "module_name": "wwan_core.c",
  "hash_id": "3fbd83409061456b677efd090d7b2deed21307e26309b9733b6d6cf0c344d910",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wwan/wwan_core.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/poll.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n#include <linux/termios.h>\n#include <linux/wwan.h>\n#include <net/rtnetlink.h>\n#include <uapi/linux/wwan.h>\n\n \n#define WWAN_MAX_MINORS\t\t(1 << MINORBITS)\n\nstatic DEFINE_MUTEX(wwan_register_lock);  \nstatic DEFINE_IDA(minors);  \nstatic DEFINE_IDA(wwan_dev_ids);  \nstatic struct class *wwan_class;\nstatic int wwan_major;\nstatic struct dentry *wwan_debugfs_dir;\n\n#define to_wwan_dev(d) container_of(d, struct wwan_device, dev)\n#define to_wwan_port(d) container_of(d, struct wwan_port, dev)\n\n \n#define WWAN_PORT_TX_OFF\t0\n\n \nstruct wwan_device {\n\tunsigned int id;\n\tstruct device dev;\n\tatomic_t port_id;\n\tconst struct wwan_ops *ops;\n\tvoid *ops_ctxt;\n#ifdef CONFIG_WWAN_DEBUGFS\n\tstruct dentry *debugfs_dir;\n#endif\n};\n\n \nstruct wwan_port {\n\tenum wwan_port_type type;\n\tunsigned int start_count;\n\tunsigned long flags;\n\tconst struct wwan_port_ops *ops;\n\tstruct mutex ops_lock;  \n\tstruct device dev;\n\tstruct sk_buff_head rxq;\n\twait_queue_head_t waitqueue;\n\tstruct mutex data_lock;\t \n\tsize_t headroom_len;\n\tsize_t frag_len;\n\tunion {\n\t\tstruct {\n\t\t\tstruct ktermios termios;\n\t\t\tint mdmbits;\n\t\t} at_data;\n\t};\n};\n\nstatic ssize_t index_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct wwan_device *wwan = to_wwan_dev(dev);\n\n\treturn sprintf(buf, \"%d\\n\", wwan->id);\n}\nstatic DEVICE_ATTR_RO(index);\n\nstatic struct attribute *wwan_dev_attrs[] = {\n\t&dev_attr_index.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(wwan_dev);\n\nstatic void wwan_dev_destroy(struct device *dev)\n{\n\tstruct wwan_device *wwandev = to_wwan_dev(dev);\n\n\tida_free(&wwan_dev_ids, wwandev->id);\n\tkfree(wwandev);\n}\n\nstatic const struct device_type wwan_dev_type = {\n\t.name    = \"wwan_dev\",\n\t.release = wwan_dev_destroy,\n\t.groups = wwan_dev_groups,\n};\n\nstatic int wwan_dev_parent_match(struct device *dev, const void *parent)\n{\n\treturn (dev->type == &wwan_dev_type &&\n\t\t(dev->parent == parent || dev == parent));\n}\n\nstatic struct wwan_device *wwan_dev_get_by_parent(struct device *parent)\n{\n\tstruct device *dev;\n\n\tdev = class_find_device(wwan_class, NULL, parent, wwan_dev_parent_match);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn to_wwan_dev(dev);\n}\n\nstatic int wwan_dev_name_match(struct device *dev, const void *name)\n{\n\treturn dev->type == &wwan_dev_type &&\n\t       strcmp(dev_name(dev), name) == 0;\n}\n\nstatic struct wwan_device *wwan_dev_get_by_name(const char *name)\n{\n\tstruct device *dev;\n\n\tdev = class_find_device(wwan_class, NULL, name, wwan_dev_name_match);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn to_wwan_dev(dev);\n}\n\n#ifdef CONFIG_WWAN_DEBUGFS\nstruct dentry *wwan_get_debugfs_dir(struct device *parent)\n{\n\tstruct wwan_device *wwandev;\n\n\twwandev = wwan_dev_get_by_parent(parent);\n\tif (IS_ERR(wwandev))\n\t\treturn ERR_CAST(wwandev);\n\n\treturn wwandev->debugfs_dir;\n}\nEXPORT_SYMBOL_GPL(wwan_get_debugfs_dir);\n\nstatic int wwan_dev_debugfs_match(struct device *dev, const void *dir)\n{\n\tstruct wwan_device *wwandev;\n\n\tif (dev->type != &wwan_dev_type)\n\t\treturn 0;\n\n\twwandev = to_wwan_dev(dev);\n\n\treturn wwandev->debugfs_dir == dir;\n}\n\nstatic struct wwan_device *wwan_dev_get_by_debugfs(struct dentry *dir)\n{\n\tstruct device *dev;\n\n\tdev = class_find_device(wwan_class, NULL, dir, wwan_dev_debugfs_match);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn to_wwan_dev(dev);\n}\n\nvoid wwan_put_debugfs_dir(struct dentry *dir)\n{\n\tstruct wwan_device *wwandev = wwan_dev_get_by_debugfs(dir);\n\n\tif (WARN_ON(IS_ERR(wwandev)))\n\t\treturn;\n\n\t \n\tput_device(&wwandev->dev);\n\tput_device(&wwandev->dev);\n}\nEXPORT_SYMBOL_GPL(wwan_put_debugfs_dir);\n#endif\n\n \nstatic struct wwan_device *wwan_create_dev(struct device *parent)\n{\n\tstruct wwan_device *wwandev;\n\tint err, id;\n\n\t \n\tmutex_lock(&wwan_register_lock);\n\n\t \n\twwandev = wwan_dev_get_by_parent(parent);\n\tif (!IS_ERR(wwandev))\n\t\tgoto done_unlock;\n\n\tid = ida_alloc(&wwan_dev_ids, GFP_KERNEL);\n\tif (id < 0) {\n\t\twwandev = ERR_PTR(id);\n\t\tgoto done_unlock;\n\t}\n\n\twwandev = kzalloc(sizeof(*wwandev), GFP_KERNEL);\n\tif (!wwandev) {\n\t\twwandev = ERR_PTR(-ENOMEM);\n\t\tida_free(&wwan_dev_ids, id);\n\t\tgoto done_unlock;\n\t}\n\n\twwandev->dev.parent = parent;\n\twwandev->dev.class = wwan_class;\n\twwandev->dev.type = &wwan_dev_type;\n\twwandev->id = id;\n\tdev_set_name(&wwandev->dev, \"wwan%d\", wwandev->id);\n\n\terr = device_register(&wwandev->dev);\n\tif (err) {\n\t\tput_device(&wwandev->dev);\n\t\twwandev = ERR_PTR(err);\n\t\tgoto done_unlock;\n\t}\n\n#ifdef CONFIG_WWAN_DEBUGFS\n\twwandev->debugfs_dir =\n\t\t\tdebugfs_create_dir(kobject_name(&wwandev->dev.kobj),\n\t\t\t\t\t   wwan_debugfs_dir);\n#endif\n\ndone_unlock:\n\tmutex_unlock(&wwan_register_lock);\n\n\treturn wwandev;\n}\n\nstatic int is_wwan_child(struct device *dev, void *data)\n{\n\treturn dev->class == wwan_class;\n}\n\nstatic void wwan_remove_dev(struct wwan_device *wwandev)\n{\n\tint ret;\n\n\t \n\tmutex_lock(&wwan_register_lock);\n\n\t \n\tif (wwandev->ops)\n\t\tret = 1;\n\telse\n\t\tret = device_for_each_child(&wwandev->dev, NULL, is_wwan_child);\n\n\tif (!ret) {\n#ifdef CONFIG_WWAN_DEBUGFS\n\t\tdebugfs_remove_recursive(wwandev->debugfs_dir);\n#endif\n\t\tdevice_unregister(&wwandev->dev);\n\t} else {\n\t\tput_device(&wwandev->dev);\n\t}\n\n\tmutex_unlock(&wwan_register_lock);\n}\n\n \n\nstatic const struct {\n\tconst char * const name;\t \n\tconst char * const devsuf;\t \n} wwan_port_types[WWAN_PORT_MAX + 1] = {\n\t[WWAN_PORT_AT] = {\n\t\t.name = \"AT\",\n\t\t.devsuf = \"at\",\n\t},\n\t[WWAN_PORT_MBIM] = {\n\t\t.name = \"MBIM\",\n\t\t.devsuf = \"mbim\",\n\t},\n\t[WWAN_PORT_QMI] = {\n\t\t.name = \"QMI\",\n\t\t.devsuf = \"qmi\",\n\t},\n\t[WWAN_PORT_QCDM] = {\n\t\t.name = \"QCDM\",\n\t\t.devsuf = \"qcdm\",\n\t},\n\t[WWAN_PORT_FIREHOSE] = {\n\t\t.name = \"FIREHOSE\",\n\t\t.devsuf = \"firehose\",\n\t},\n\t[WWAN_PORT_XMMRPC] = {\n\t\t.name = \"XMMRPC\",\n\t\t.devsuf = \"xmmrpc\",\n\t},\n};\n\nstatic ssize_t type_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct wwan_port *port = to_wwan_port(dev);\n\n\treturn sprintf(buf, \"%s\\n\", wwan_port_types[port->type].name);\n}\nstatic DEVICE_ATTR_RO(type);\n\nstatic struct attribute *wwan_port_attrs[] = {\n\t&dev_attr_type.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(wwan_port);\n\nstatic void wwan_port_destroy(struct device *dev)\n{\n\tstruct wwan_port *port = to_wwan_port(dev);\n\n\tida_free(&minors, MINOR(port->dev.devt));\n\tmutex_destroy(&port->data_lock);\n\tmutex_destroy(&port->ops_lock);\n\tkfree(port);\n}\n\nstatic const struct device_type wwan_port_dev_type = {\n\t.name = \"wwan_port\",\n\t.release = wwan_port_destroy,\n\t.groups = wwan_port_groups,\n};\n\nstatic int wwan_port_minor_match(struct device *dev, const void *minor)\n{\n\treturn (dev->type == &wwan_port_dev_type &&\n\t\tMINOR(dev->devt) == *(unsigned int *)minor);\n}\n\nstatic struct wwan_port *wwan_port_get_by_minor(unsigned int minor)\n{\n\tstruct device *dev;\n\n\tdev = class_find_device(wwan_class, NULL, &minor, wwan_port_minor_match);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn to_wwan_port(dev);\n}\n\n \nstatic int __wwan_port_dev_assign_name(struct wwan_port *port, const char *fmt)\n{\n\tstruct wwan_device *wwandev = to_wwan_dev(port->dev.parent);\n\tconst unsigned int max_ports = PAGE_SIZE * 8;\n\tstruct class_dev_iter iter;\n\tunsigned long *idmap;\n\tstruct device *dev;\n\tchar buf[0x20];\n\tint id;\n\n\tidmap = (unsigned long *)get_zeroed_page(GFP_KERNEL);\n\tif (!idmap)\n\t\treturn -ENOMEM;\n\n\t \n\tclass_dev_iter_init(&iter, wwan_class, NULL, &wwan_port_dev_type);\n\twhile ((dev = class_dev_iter_next(&iter))) {\n\t\tif (dev->parent != &wwandev->dev)\n\t\t\tcontinue;\n\t\tif (sscanf(dev_name(dev), fmt, &id) != 1)\n\t\t\tcontinue;\n\t\tif (id < 0 || id >= max_ports)\n\t\t\tcontinue;\n\t\tset_bit(id, idmap);\n\t}\n\tclass_dev_iter_exit(&iter);\n\n\t \n\tid = find_first_zero_bit(idmap, max_ports);\n\tfree_page((unsigned long)idmap);\n\n\tsnprintf(buf, sizeof(buf), fmt, id);\t \n\n\tdev = device_find_child_by_name(&wwandev->dev, buf);\n\tif (dev) {\n\t\tput_device(dev);\n\t\treturn -ENFILE;\n\t}\n\n\treturn dev_set_name(&port->dev, buf);\n}\n\nstruct wwan_port *wwan_create_port(struct device *parent,\n\t\t\t\t   enum wwan_port_type type,\n\t\t\t\t   const struct wwan_port_ops *ops,\n\t\t\t\t   struct wwan_port_caps *caps,\n\t\t\t\t   void *drvdata)\n{\n\tstruct wwan_device *wwandev;\n\tstruct wwan_port *port;\n\tchar namefmt[0x20];\n\tint minor, err;\n\n\tif (type > WWAN_PORT_MAX || !ops)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\twwandev = wwan_create_dev(parent);\n\tif (IS_ERR(wwandev))\n\t\treturn ERR_CAST(wwandev);\n\n\t \n\tminor = ida_alloc_range(&minors, 0, WWAN_MAX_MINORS - 1, GFP_KERNEL);\n\tif (minor < 0) {\n\t\terr = minor;\n\t\tgoto error_wwandev_remove;\n\t}\n\n\tport = kzalloc(sizeof(*port), GFP_KERNEL);\n\tif (!port) {\n\t\terr = -ENOMEM;\n\t\tida_free(&minors, minor);\n\t\tgoto error_wwandev_remove;\n\t}\n\n\tport->type = type;\n\tport->ops = ops;\n\tport->frag_len = caps ? caps->frag_len : SIZE_MAX;\n\tport->headroom_len = caps ? caps->headroom_len : 0;\n\tmutex_init(&port->ops_lock);\n\tskb_queue_head_init(&port->rxq);\n\tinit_waitqueue_head(&port->waitqueue);\n\tmutex_init(&port->data_lock);\n\n\tport->dev.parent = &wwandev->dev;\n\tport->dev.class = wwan_class;\n\tport->dev.type = &wwan_port_dev_type;\n\tport->dev.devt = MKDEV(wwan_major, minor);\n\tdev_set_drvdata(&port->dev, drvdata);\n\n\t \n\tsnprintf(namefmt, sizeof(namefmt), \"wwan%u%s%%d\", wwandev->id,\n\t\t wwan_port_types[port->type].devsuf);\n\n\t \n\tmutex_lock(&wwan_register_lock);\n\n\t__wwan_port_dev_assign_name(port, namefmt);\n\terr = device_register(&port->dev);\n\n\tmutex_unlock(&wwan_register_lock);\n\n\tif (err)\n\t\tgoto error_put_device;\n\n\tdev_info(&wwandev->dev, \"port %s attached\\n\", dev_name(&port->dev));\n\treturn port;\n\nerror_put_device:\n\tput_device(&port->dev);\nerror_wwandev_remove:\n\twwan_remove_dev(wwandev);\n\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(wwan_create_port);\n\nvoid wwan_remove_port(struct wwan_port *port)\n{\n\tstruct wwan_device *wwandev = to_wwan_dev(port->dev.parent);\n\n\tmutex_lock(&port->ops_lock);\n\tif (port->start_count)\n\t\tport->ops->stop(port);\n\tport->ops = NULL;  \n\tmutex_unlock(&port->ops_lock);\n\n\twake_up_interruptible(&port->waitqueue);\n\n\tskb_queue_purge(&port->rxq);\n\tdev_set_drvdata(&port->dev, NULL);\n\n\tdev_info(&wwandev->dev, \"port %s disconnected\\n\", dev_name(&port->dev));\n\tdevice_unregister(&port->dev);\n\n\t \n\twwan_remove_dev(wwandev);\n}\nEXPORT_SYMBOL_GPL(wwan_remove_port);\n\nvoid wwan_port_rx(struct wwan_port *port, struct sk_buff *skb)\n{\n\tskb_queue_tail(&port->rxq, skb);\n\twake_up_interruptible(&port->waitqueue);\n}\nEXPORT_SYMBOL_GPL(wwan_port_rx);\n\nvoid wwan_port_txon(struct wwan_port *port)\n{\n\tclear_bit(WWAN_PORT_TX_OFF, &port->flags);\n\twake_up_interruptible(&port->waitqueue);\n}\nEXPORT_SYMBOL_GPL(wwan_port_txon);\n\nvoid wwan_port_txoff(struct wwan_port *port)\n{\n\tset_bit(WWAN_PORT_TX_OFF, &port->flags);\n}\nEXPORT_SYMBOL_GPL(wwan_port_txoff);\n\nvoid *wwan_port_get_drvdata(struct wwan_port *port)\n{\n\treturn dev_get_drvdata(&port->dev);\n}\nEXPORT_SYMBOL_GPL(wwan_port_get_drvdata);\n\nstatic int wwan_port_op_start(struct wwan_port *port)\n{\n\tint ret = 0;\n\n\tmutex_lock(&port->ops_lock);\n\tif (!port->ops) {  \n\t\tret = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tif (!port->start_count)\n\t\tret = port->ops->start(port);\n\n\tif (!ret)\n\t\tport->start_count++;\n\nout_unlock:\n\tmutex_unlock(&port->ops_lock);\n\n\treturn ret;\n}\n\nstatic void wwan_port_op_stop(struct wwan_port *port)\n{\n\tmutex_lock(&port->ops_lock);\n\tport->start_count--;\n\tif (!port->start_count) {\n\t\tif (port->ops)\n\t\t\tport->ops->stop(port);\n\t\tskb_queue_purge(&port->rxq);\n\t}\n\tmutex_unlock(&port->ops_lock);\n}\n\nstatic int wwan_port_op_tx(struct wwan_port *port, struct sk_buff *skb,\n\t\t\t   bool nonblock)\n{\n\tint ret;\n\n\tmutex_lock(&port->ops_lock);\n\tif (!port->ops) {  \n\t\tret = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tif (nonblock || !port->ops->tx_blocking)\n\t\tret = port->ops->tx(port, skb);\n\telse\n\t\tret = port->ops->tx_blocking(port, skb);\n\nout_unlock:\n\tmutex_unlock(&port->ops_lock);\n\n\treturn ret;\n}\n\nstatic bool is_read_blocked(struct wwan_port *port)\n{\n\treturn skb_queue_empty(&port->rxq) && port->ops;\n}\n\nstatic bool is_write_blocked(struct wwan_port *port)\n{\n\treturn test_bit(WWAN_PORT_TX_OFF, &port->flags) && port->ops;\n}\n\nstatic int wwan_wait_rx(struct wwan_port *port, bool nonblock)\n{\n\tif (!is_read_blocked(port))\n\t\treturn 0;\n\n\tif (nonblock)\n\t\treturn -EAGAIN;\n\n\tif (wait_event_interruptible(port->waitqueue, !is_read_blocked(port)))\n\t\treturn -ERESTARTSYS;\n\n\treturn 0;\n}\n\nstatic int wwan_wait_tx(struct wwan_port *port, bool nonblock)\n{\n\tif (!is_write_blocked(port))\n\t\treturn 0;\n\n\tif (nonblock)\n\t\treturn -EAGAIN;\n\n\tif (wait_event_interruptible(port->waitqueue, !is_write_blocked(port)))\n\t\treturn -ERESTARTSYS;\n\n\treturn 0;\n}\n\nstatic int wwan_port_fops_open(struct inode *inode, struct file *file)\n{\n\tstruct wwan_port *port;\n\tint err = 0;\n\n\tport = wwan_port_get_by_minor(iminor(inode));\n\tif (IS_ERR(port))\n\t\treturn PTR_ERR(port);\n\n\tfile->private_data = port;\n\tstream_open(inode, file);\n\n\terr = wwan_port_op_start(port);\n\tif (err)\n\t\tput_device(&port->dev);\n\n\treturn err;\n}\n\nstatic int wwan_port_fops_release(struct inode *inode, struct file *filp)\n{\n\tstruct wwan_port *port = filp->private_data;\n\n\twwan_port_op_stop(port);\n\tput_device(&port->dev);\n\n\treturn 0;\n}\n\nstatic ssize_t wwan_port_fops_read(struct file *filp, char __user *buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct wwan_port *port = filp->private_data;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint ret;\n\n\tret = wwan_wait_rx(port, !!(filp->f_flags & O_NONBLOCK));\n\tif (ret)\n\t\treturn ret;\n\n\tskb = skb_dequeue(&port->rxq);\n\tif (!skb)\n\t\treturn -EIO;\n\n\tcopied = min_t(size_t, count, skb->len);\n\tif (copy_to_user(buf, skb->data, copied)) {\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\tskb_pull(skb, copied);\n\n\t \n\tif (skb->len)\n\t\tskb_queue_head(&port->rxq, skb);\n\telse\n\t\tconsume_skb(skb);\n\n\treturn copied;\n}\n\nstatic ssize_t wwan_port_fops_write(struct file *filp, const char __user *buf,\n\t\t\t\t    size_t count, loff_t *offp)\n{\n\tstruct sk_buff *skb, *head = NULL, *tail = NULL;\n\tstruct wwan_port *port = filp->private_data;\n\tsize_t frag_len, remain = count;\n\tint ret;\n\n\tret = wwan_wait_tx(port, !!(filp->f_flags & O_NONBLOCK));\n\tif (ret)\n\t\treturn ret;\n\n\tdo {\n\t\tfrag_len = min(remain, port->frag_len);\n\t\tskb = alloc_skb(frag_len + port->headroom_len, GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto freeskb;\n\t\t}\n\t\tskb_reserve(skb, port->headroom_len);\n\n\t\tif (!head) {\n\t\t\thead = skb;\n\t\t} else if (!tail) {\n\t\t\tskb_shinfo(head)->frag_list = skb;\n\t\t\ttail = skb;\n\t\t} else {\n\t\t\ttail->next = skb;\n\t\t\ttail = skb;\n\t\t}\n\n\t\tif (copy_from_user(skb_put(skb, frag_len), buf + count - remain, frag_len)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto freeskb;\n\t\t}\n\n\t\tif (skb != head) {\n\t\t\thead->data_len += skb->len;\n\t\t\thead->len += skb->len;\n\t\t\thead->truesize += skb->truesize;\n\t\t}\n\t} while (remain -= frag_len);\n\n\tret = wwan_port_op_tx(port, head, !!(filp->f_flags & O_NONBLOCK));\n\tif (!ret)\n\t\treturn count;\n\nfreeskb:\n\tkfree_skb(head);\n\treturn ret;\n}\n\nstatic __poll_t wwan_port_fops_poll(struct file *filp, poll_table *wait)\n{\n\tstruct wwan_port *port = filp->private_data;\n\t__poll_t mask = 0;\n\n\tpoll_wait(filp, &port->waitqueue, wait);\n\n\tmutex_lock(&port->ops_lock);\n\tif (port->ops && port->ops->tx_poll)\n\t\tmask |= port->ops->tx_poll(port, filp, wait);\n\telse if (!is_write_blocked(port))\n\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\tif (!is_read_blocked(port))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\tif (!port->ops)\n\t\tmask |= EPOLLHUP | EPOLLERR;\n\tmutex_unlock(&port->ops_lock);\n\n\treturn mask;\n}\n\n \nstatic long wwan_port_fops_at_ioctl(struct wwan_port *port, unsigned int cmd,\n\t\t\t\t    unsigned long arg)\n{\n\tint ret = 0;\n\n\tmutex_lock(&port->data_lock);\n\n\tswitch (cmd) {\n\tcase TCFLSH:\n\t\tbreak;\n\n\tcase TCGETS:\n\t\tif (copy_to_user((void __user *)arg, &port->at_data.termios,\n\t\t\t\t sizeof(struct termios)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase TCSETS:\n\tcase TCSETSW:\n\tcase TCSETSF:\n\t\tif (copy_from_user(&port->at_data.termios, (void __user *)arg,\n\t\t\t\t   sizeof(struct termios)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n#ifdef TCGETS2\n\tcase TCGETS2:\n\t\tif (copy_to_user((void __user *)arg, &port->at_data.termios,\n\t\t\t\t sizeof(struct termios2)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase TCSETS2:\n\tcase TCSETSW2:\n\tcase TCSETSF2:\n\t\tif (copy_from_user(&port->at_data.termios, (void __user *)arg,\n\t\t\t\t   sizeof(struct termios2)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n#endif\n\n\tcase TIOCMGET:\n\t\tret = put_user(port->at_data.mdmbits, (int __user *)arg);\n\t\tbreak;\n\n\tcase TIOCMSET:\n\tcase TIOCMBIC:\n\tcase TIOCMBIS: {\n\t\tint mdmbits;\n\n\t\tif (copy_from_user(&mdmbits, (int __user *)arg, sizeof(int))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (cmd == TIOCMBIC)\n\t\t\tport->at_data.mdmbits &= ~mdmbits;\n\t\telse if (cmd == TIOCMBIS)\n\t\t\tport->at_data.mdmbits |= mdmbits;\n\t\telse\n\t\t\tport->at_data.mdmbits = mdmbits;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tret = -ENOIOCTLCMD;\n\t}\n\n\tmutex_unlock(&port->data_lock);\n\n\treturn ret;\n}\n\nstatic long wwan_port_fops_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct wwan_port *port = filp->private_data;\n\tint res;\n\n\tif (port->type == WWAN_PORT_AT) {\t \n\t\tres = wwan_port_fops_at_ioctl(port, cmd, arg);\n\t\tif (res != -ENOIOCTLCMD)\n\t\t\treturn res;\n\t}\n\n\tswitch (cmd) {\n\tcase TIOCINQ: {\t \n\t\tunsigned long flags;\n\t\tstruct sk_buff *skb;\n\t\tint amount = 0;\n\n\t\tspin_lock_irqsave(&port->rxq.lock, flags);\n\t\tskb_queue_walk(&port->rxq, skb)\n\t\t\tamount += skb->len;\n\t\tspin_unlock_irqrestore(&port->rxq.lock, flags);\n\n\t\treturn put_user(amount, (int __user *)arg);\n\t}\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\nstatic const struct file_operations wwan_port_fops = {\n\t.owner = THIS_MODULE,\n\t.open = wwan_port_fops_open,\n\t.release = wwan_port_fops_release,\n\t.read = wwan_port_fops_read,\n\t.write = wwan_port_fops_write,\n\t.poll = wwan_port_fops_poll,\n\t.unlocked_ioctl = wwan_port_fops_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = compat_ptr_ioctl,\n#endif\n\t.llseek = noop_llseek,\n};\n\nstatic int wwan_rtnl_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tif (!tb[IFLA_PARENT_DEV_NAME])\n\t\treturn -EINVAL;\n\n\tif (!data[IFLA_WWAN_LINK_ID])\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic struct device_type wwan_type = { .name = \"wwan\" };\n\nstatic struct net_device *wwan_rtnl_alloc(struct nlattr *tb[],\n\t\t\t\t\t  const char *ifname,\n\t\t\t\t\t  unsigned char name_assign_type,\n\t\t\t\t\t  unsigned int num_tx_queues,\n\t\t\t\t\t  unsigned int num_rx_queues)\n{\n\tconst char *devname = nla_data(tb[IFLA_PARENT_DEV_NAME]);\n\tstruct wwan_device *wwandev = wwan_dev_get_by_name(devname);\n\tstruct net_device *dev;\n\tunsigned int priv_size;\n\n\tif (IS_ERR(wwandev))\n\t\treturn ERR_CAST(wwandev);\n\n\t \n\tif (!wwandev->ops) {\n\t\tdev = ERR_PTR(-EOPNOTSUPP);\n\t\tgoto out;\n\t}\n\n\tpriv_size = sizeof(struct wwan_netdev_priv) + wwandev->ops->priv_size;\n\tdev = alloc_netdev_mqs(priv_size, ifname, name_assign_type,\n\t\t\t       wwandev->ops->setup, num_tx_queues, num_rx_queues);\n\n\tif (dev) {\n\t\tSET_NETDEV_DEV(dev, &wwandev->dev);\n\t\tSET_NETDEV_DEVTYPE(dev, &wwan_type);\n\t}\n\nout:\n\t \n\tput_device(&wwandev->dev);\n\treturn dev;\n}\n\nstatic int wwan_rtnl_newlink(struct net *src_net, struct net_device *dev,\n\t\t\t     struct nlattr *tb[], struct nlattr *data[],\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct wwan_device *wwandev = wwan_dev_get_by_parent(dev->dev.parent);\n\tu32 link_id = nla_get_u32(data[IFLA_WWAN_LINK_ID]);\n\tstruct wwan_netdev_priv *priv = netdev_priv(dev);\n\tint ret;\n\n\tif (IS_ERR(wwandev))\n\t\treturn PTR_ERR(wwandev);\n\n\t \n\tif (WARN_ON(!wwandev->ops)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tpriv->link_id = link_id;\n\tif (wwandev->ops->newlink)\n\t\tret = wwandev->ops->newlink(wwandev->ops_ctxt, dev,\n\t\t\t\t\t    link_id, extack);\n\telse\n\t\tret = register_netdevice(dev);\n\nout:\n\t \n\tput_device(&wwandev->dev);\n\treturn ret;\n}\n\nstatic void wwan_rtnl_dellink(struct net_device *dev, struct list_head *head)\n{\n\tstruct wwan_device *wwandev = wwan_dev_get_by_parent(dev->dev.parent);\n\n\tif (IS_ERR(wwandev))\n\t\treturn;\n\n\t \n\tif (WARN_ON(!wwandev->ops))\n\t\tgoto out;\n\n\tif (wwandev->ops->dellink)\n\t\twwandev->ops->dellink(wwandev->ops_ctxt, dev, head);\n\telse\n\t\tunregister_netdevice_queue(dev, head);\n\nout:\n\t \n\tput_device(&wwandev->dev);\n}\n\nstatic size_t wwan_rtnl_get_size(const struct net_device *dev)\n{\n\treturn\n\t\tnla_total_size(4) +\t \n\t\t0;\n}\n\nstatic int wwan_rtnl_fill_info(struct sk_buff *skb,\n\t\t\t       const struct net_device *dev)\n{\n\tstruct wwan_netdev_priv *priv = netdev_priv(dev);\n\n\tif (nla_put_u32(skb, IFLA_WWAN_LINK_ID, priv->link_id))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic const struct nla_policy wwan_rtnl_policy[IFLA_WWAN_MAX + 1] = {\n\t[IFLA_WWAN_LINK_ID] = { .type = NLA_U32 },\n};\n\nstatic struct rtnl_link_ops wwan_rtnl_link_ops __read_mostly = {\n\t.kind = \"wwan\",\n\t.maxtype = __IFLA_WWAN_MAX,\n\t.alloc = wwan_rtnl_alloc,\n\t.validate = wwan_rtnl_validate,\n\t.newlink = wwan_rtnl_newlink,\n\t.dellink = wwan_rtnl_dellink,\n\t.get_size = wwan_rtnl_get_size,\n\t.fill_info = wwan_rtnl_fill_info,\n\t.policy = wwan_rtnl_policy,\n};\n\nstatic void wwan_create_default_link(struct wwan_device *wwandev,\n\t\t\t\t     u32 def_link_id)\n{\n\tstruct nlattr *tb[IFLA_MAX + 1], *linkinfo[IFLA_INFO_MAX + 1];\n\tstruct nlattr *data[IFLA_WWAN_MAX + 1];\n\tstruct net_device *dev;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *msg;\n\n\t \n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (WARN_ON(!msg))\n\t\treturn;\n\tnlh = nlmsg_put(msg, 0, 0, RTM_NEWLINK, 0, 0);\n\tif (WARN_ON(!nlh))\n\t\tgoto free_attrs;\n\n\tif (nla_put_string(msg, IFLA_PARENT_DEV_NAME, dev_name(&wwandev->dev)))\n\t\tgoto free_attrs;\n\ttb[IFLA_LINKINFO] = nla_nest_start(msg, IFLA_LINKINFO);\n\tif (!tb[IFLA_LINKINFO])\n\t\tgoto free_attrs;\n\tlinkinfo[IFLA_INFO_DATA] = nla_nest_start(msg, IFLA_INFO_DATA);\n\tif (!linkinfo[IFLA_INFO_DATA])\n\t\tgoto free_attrs;\n\tif (nla_put_u32(msg, IFLA_WWAN_LINK_ID, def_link_id))\n\t\tgoto free_attrs;\n\tnla_nest_end(msg, linkinfo[IFLA_INFO_DATA]);\n\tnla_nest_end(msg, tb[IFLA_LINKINFO]);\n\n\tnlmsg_end(msg, nlh);\n\n\t \n\tnlmsg_parse_deprecated(nlh, 0, tb, IFLA_MAX, NULL, NULL);\n\tnla_parse_nested_deprecated(linkinfo, IFLA_INFO_MAX, tb[IFLA_LINKINFO],\n\t\t\t\t    NULL, NULL);\n\tnla_parse_nested_deprecated(data, IFLA_WWAN_MAX,\n\t\t\t\t    linkinfo[IFLA_INFO_DATA], NULL, NULL);\n\n\trtnl_lock();\n\n\tdev = rtnl_create_link(&init_net, \"wwan%d\", NET_NAME_ENUM,\n\t\t\t       &wwan_rtnl_link_ops, tb, NULL);\n\tif (WARN_ON(IS_ERR(dev)))\n\t\tgoto unlock;\n\n\tif (WARN_ON(wwan_rtnl_newlink(&init_net, dev, tb, data, NULL))) {\n\t\tfree_netdev(dev);\n\t\tgoto unlock;\n\t}\n\n\trtnl_configure_link(dev, NULL, 0, NULL);  \n\nunlock:\n\trtnl_unlock();\n\nfree_attrs:\n\tnlmsg_free(msg);\n}\n\n \nint wwan_register_ops(struct device *parent, const struct wwan_ops *ops,\n\t\t      void *ctxt, u32 def_link_id)\n{\n\tstruct wwan_device *wwandev;\n\n\tif (WARN_ON(!parent || !ops || !ops->setup))\n\t\treturn -EINVAL;\n\n\twwandev = wwan_create_dev(parent);\n\tif (IS_ERR(wwandev))\n\t\treturn PTR_ERR(wwandev);\n\n\tif (WARN_ON(wwandev->ops)) {\n\t\twwan_remove_dev(wwandev);\n\t\treturn -EBUSY;\n\t}\n\n\twwandev->ops = ops;\n\twwandev->ops_ctxt = ctxt;\n\n\t \n\tif (def_link_id != WWAN_NO_DEFAULT_LINK)\n\t\twwan_create_default_link(wwandev, def_link_id);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(wwan_register_ops);\n\n \nstatic int wwan_child_dellink(struct device *dev, void *data)\n{\n\tstruct list_head *kill_list = data;\n\n\tif (dev->type == &wwan_type)\n\t\twwan_rtnl_dellink(to_net_dev(dev), kill_list);\n\n\treturn 0;\n}\n\n \nvoid wwan_unregister_ops(struct device *parent)\n{\n\tstruct wwan_device *wwandev = wwan_dev_get_by_parent(parent);\n\tLIST_HEAD(kill_list);\n\n\tif (WARN_ON(IS_ERR(wwandev)))\n\t\treturn;\n\tif (WARN_ON(!wwandev->ops)) {\n\t\tput_device(&wwandev->dev);\n\t\treturn;\n\t}\n\n\t \n\tput_device(&wwandev->dev);\n\n\trtnl_lock();\t \n\n\t \n\tdevice_for_each_child(&wwandev->dev, &kill_list,\n\t\t\t      wwan_child_dellink);\n\tunregister_netdevice_many(&kill_list);\n\n\twwandev->ops = NULL;\t \n\n\trtnl_unlock();\n\n\twwandev->ops_ctxt = NULL;\n\twwan_remove_dev(wwandev);\n}\nEXPORT_SYMBOL_GPL(wwan_unregister_ops);\n\nstatic int __init wwan_init(void)\n{\n\tint err;\n\n\terr = rtnl_link_register(&wwan_rtnl_link_ops);\n\tif (err)\n\t\treturn err;\n\n\twwan_class = class_create(\"wwan\");\n\tif (IS_ERR(wwan_class)) {\n\t\terr = PTR_ERR(wwan_class);\n\t\tgoto unregister;\n\t}\n\n\t \n\twwan_major = __register_chrdev(0, 0, WWAN_MAX_MINORS, \"wwan_port\",\n\t\t\t\t       &wwan_port_fops);\n\tif (wwan_major < 0) {\n\t\terr = wwan_major;\n\t\tgoto destroy;\n\t}\n\n#ifdef CONFIG_WWAN_DEBUGFS\n\twwan_debugfs_dir = debugfs_create_dir(\"wwan\", NULL);\n#endif\n\n\treturn 0;\n\ndestroy:\n\tclass_destroy(wwan_class);\nunregister:\n\trtnl_link_unregister(&wwan_rtnl_link_ops);\n\treturn err;\n}\n\nstatic void __exit wwan_exit(void)\n{\n\tdebugfs_remove_recursive(wwan_debugfs_dir);\n\t__unregister_chrdev(wwan_major, 0, WWAN_MAX_MINORS, \"wwan_port\");\n\trtnl_link_unregister(&wwan_rtnl_link_ops);\n\tclass_destroy(wwan_class);\n}\n\nmodule_init(wwan_init);\nmodule_exit(wwan_exit);\n\nMODULE_AUTHOR(\"Loic Poulain <loic.poulain@linaro.org>\");\nMODULE_DESCRIPTION(\"WWAN core\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}