{
  "module_name": "rpmsg_wwan_ctrl.c",
  "hash_id": "9bf90b41a69f24b3b927e8bb70d58c5adf2a28dcfc2f779b10dcf92a3df99ce0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wwan/rpmsg_wwan_ctrl.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/rpmsg.h>\n#include <linux/wwan.h>\n\nstruct rpmsg_wwan_dev {\n\t \n\tstruct rpmsg_device *rpdev;\n\tstruct wwan_port *wwan_port;\n\tstruct rpmsg_endpoint *ept;\n};\n\nstatic int rpmsg_wwan_ctrl_callback(struct rpmsg_device *rpdev,\n\t\t\t\t    void *buf, int len, void *priv, u32 src)\n{\n\tstruct rpmsg_wwan_dev *rpwwan = priv;\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(len, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_data(skb, buf, len);\n\twwan_port_rx(rpwwan->wwan_port, skb);\n\treturn 0;\n}\n\nstatic int rpmsg_wwan_ctrl_start(struct wwan_port *port)\n{\n\tstruct rpmsg_wwan_dev *rpwwan = wwan_port_get_drvdata(port);\n\tstruct rpmsg_channel_info chinfo = {\n\t\t.src = rpwwan->rpdev->src,\n\t\t.dst = RPMSG_ADDR_ANY,\n\t};\n\n\tstrncpy(chinfo.name, rpwwan->rpdev->id.name, RPMSG_NAME_SIZE);\n\trpwwan->ept = rpmsg_create_ept(rpwwan->rpdev, rpmsg_wwan_ctrl_callback,\n\t\t\t\t       rpwwan, chinfo);\n\tif (!rpwwan->ept)\n\t\treturn -EREMOTEIO;\n\n\treturn 0;\n}\n\nstatic void rpmsg_wwan_ctrl_stop(struct wwan_port *port)\n{\n\tstruct rpmsg_wwan_dev *rpwwan = wwan_port_get_drvdata(port);\n\n\trpmsg_destroy_ept(rpwwan->ept);\n\trpwwan->ept = NULL;\n}\n\nstatic int rpmsg_wwan_ctrl_tx(struct wwan_port *port, struct sk_buff *skb)\n{\n\tstruct rpmsg_wwan_dev *rpwwan = wwan_port_get_drvdata(port);\n\tint ret;\n\n\tret = rpmsg_trysend(rpwwan->ept, skb->data, skb->len);\n\tif (ret)\n\t\treturn ret;\n\n\tconsume_skb(skb);\n\treturn 0;\n}\n\nstatic int rpmsg_wwan_ctrl_tx_blocking(struct wwan_port *port, struct sk_buff *skb)\n{\n\tstruct rpmsg_wwan_dev *rpwwan = wwan_port_get_drvdata(port);\n\tint ret;\n\n\tret = rpmsg_send(rpwwan->ept, skb->data, skb->len);\n\tif (ret)\n\t\treturn ret;\n\n\tconsume_skb(skb);\n\treturn 0;\n}\n\nstatic __poll_t rpmsg_wwan_ctrl_tx_poll(struct wwan_port *port,\n\t\t\t\t\tstruct file *filp, poll_table *wait)\n{\n\tstruct rpmsg_wwan_dev *rpwwan = wwan_port_get_drvdata(port);\n\n\treturn rpmsg_poll(rpwwan->ept, filp, wait);\n}\n\nstatic const struct wwan_port_ops rpmsg_wwan_pops = {\n\t.start = rpmsg_wwan_ctrl_start,\n\t.stop = rpmsg_wwan_ctrl_stop,\n\t.tx = rpmsg_wwan_ctrl_tx,\n\t.tx_blocking = rpmsg_wwan_ctrl_tx_blocking,\n\t.tx_poll = rpmsg_wwan_ctrl_tx_poll,\n};\n\nstatic struct device *rpmsg_wwan_find_parent(struct device *dev)\n{\n\t \n\tfor (dev = dev->parent; dev; dev = dev->parent) {\n\t\tif (dev_is_platform(dev))\n\t\t\treturn dev;\n\t}\n\treturn NULL;\n}\n\nstatic int rpmsg_wwan_ctrl_probe(struct rpmsg_device *rpdev)\n{\n\tstruct rpmsg_wwan_dev *rpwwan;\n\tstruct wwan_port *port;\n\tstruct device *parent;\n\n\tparent = rpmsg_wwan_find_parent(&rpdev->dev);\n\tif (!parent)\n\t\treturn -ENODEV;\n\n\trpwwan = devm_kzalloc(&rpdev->dev, sizeof(*rpwwan), GFP_KERNEL);\n\tif (!rpwwan)\n\t\treturn -ENOMEM;\n\n\trpwwan->rpdev = rpdev;\n\tdev_set_drvdata(&rpdev->dev, rpwwan);\n\n\t \n\tport = wwan_create_port(parent, rpdev->id.driver_data,\n\t\t\t\t&rpmsg_wwan_pops, NULL, rpwwan);\n\tif (IS_ERR(port))\n\t\treturn PTR_ERR(port);\n\n\trpwwan->wwan_port = port;\n\n\treturn 0;\n};\n\nstatic void rpmsg_wwan_ctrl_remove(struct rpmsg_device *rpdev)\n{\n\tstruct rpmsg_wwan_dev *rpwwan = dev_get_drvdata(&rpdev->dev);\n\n\twwan_remove_port(rpwwan->wwan_port);\n}\n\nstatic const struct rpmsg_device_id rpmsg_wwan_ctrl_id_table[] = {\n\t \n\t{ .name = \"DATA5_CNTL\", .driver_data = WWAN_PORT_QMI },\n\t{ .name = \"DATA4\", .driver_data = WWAN_PORT_AT },\n\t{ .name = \"DATA1\", .driver_data = WWAN_PORT_AT },\n\t{},\n};\nMODULE_DEVICE_TABLE(rpmsg, rpmsg_wwan_ctrl_id_table);\n\nstatic struct rpmsg_driver rpmsg_wwan_ctrl_driver = {\n\t.drv.name = \"rpmsg_wwan_ctrl\",\n\t.id_table = rpmsg_wwan_ctrl_id_table,\n\t.probe = rpmsg_wwan_ctrl_probe,\n\t.remove = rpmsg_wwan_ctrl_remove,\n};\nmodule_rpmsg_driver(rpmsg_wwan_ctrl_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"RPMSG WWAN CTRL Driver\");\nMODULE_AUTHOR(\"Stephan Gerhold <stephan@gerhold.net>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}