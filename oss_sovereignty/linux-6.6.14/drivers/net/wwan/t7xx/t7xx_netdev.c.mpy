{
  "module_name": "t7xx_netdev.c",
  "hash_id": "9f56b009190996961f9d65f865436ea8d8db2d482341e08f13e3b557c16b1e80",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wwan/t7xx/t7xx_netdev.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/device.h>\n#include <linux/gfp.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/ip.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/netdev_features.h>\n#include <linux/netdevice.h>\n#include <linux/pm_runtime.h>\n#include <linux/skbuff.h>\n#include <linux/types.h>\n#include <linux/wwan.h>\n#include <net/ipv6.h>\n#include <net/pkt_sched.h>\n\n#include \"t7xx_hif_dpmaif_rx.h\"\n#include \"t7xx_hif_dpmaif_tx.h\"\n#include \"t7xx_netdev.h\"\n#include \"t7xx_pci.h\"\n#include \"t7xx_port_proxy.h\"\n#include \"t7xx_state_monitor.h\"\n\n#define IP_MUX_SESSION_DEFAULT\t0\n#define SBD_PACKET_TYPE_MASK\tGENMASK(7, 4)\n\nstatic void t7xx_ccmni_enable_napi(struct t7xx_ccmni_ctrl *ctlb)\n{\n\tstruct dpmaif_ctrl *ctrl;\n\tint i, ret;\n\n\tctrl =  ctlb->hif_ctrl;\n\n\tif (ctlb->is_napi_en)\n\t\treturn;\n\n\tfor (i = 0; i < RXQ_NUM; i++) {\n\t\t \n\t\tret = pm_runtime_resume_and_get(ctrl->dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ctrl->dev, \"Failed to resume device: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn;\n\t\t}\n\t\tnapi_enable(ctlb->napi[i]);\n\t\tnapi_schedule(ctlb->napi[i]);\n\t}\n\tctlb->is_napi_en = true;\n}\n\nstatic void t7xx_ccmni_disable_napi(struct t7xx_ccmni_ctrl *ctlb)\n{\n\tint i;\n\n\tif (!ctlb->is_napi_en)\n\t\treturn;\n\n\tfor (i = 0; i < RXQ_NUM; i++) {\n\t\tnapi_synchronize(ctlb->napi[i]);\n\t\tnapi_disable(ctlb->napi[i]);\n\t}\n\n\tctlb->is_napi_en = false;\n}\n\nstatic int t7xx_ccmni_open(struct net_device *dev)\n{\n\tstruct t7xx_ccmni *ccmni = wwan_netdev_drvpriv(dev);\n\tstruct t7xx_ccmni_ctrl *ccmni_ctl = ccmni->ctlb;\n\n\tnetif_carrier_on(dev);\n\tnetif_tx_start_all_queues(dev);\n\tif (!atomic_fetch_inc(&ccmni_ctl->napi_usr_refcnt))\n\t\tt7xx_ccmni_enable_napi(ccmni_ctl);\n\n\tatomic_inc(&ccmni->usage);\n\treturn 0;\n}\n\nstatic int t7xx_ccmni_close(struct net_device *dev)\n{\n\tstruct t7xx_ccmni *ccmni = wwan_netdev_drvpriv(dev);\n\tstruct t7xx_ccmni_ctrl *ccmni_ctl = ccmni->ctlb;\n\n\tatomic_dec(&ccmni->usage);\n\tif (atomic_dec_and_test(&ccmni_ctl->napi_usr_refcnt))\n\t\tt7xx_ccmni_disable_napi(ccmni_ctl);\n\n\tnetif_carrier_off(dev);\n\tnetif_tx_disable(dev);\n\treturn 0;\n}\n\nstatic int t7xx_ccmni_send_packet(struct t7xx_ccmni *ccmni, struct sk_buff *skb,\n\t\t\t\t  unsigned int txq_number)\n{\n\tstruct t7xx_ccmni_ctrl *ctlb = ccmni->ctlb;\n\tstruct t7xx_skb_cb *skb_cb = T7XX_SKB_CB(skb);\n\n\tskb_cb->netif_idx = ccmni->index;\n\n\tif (t7xx_dpmaif_tx_send_skb(ctlb->hif_ctrl, txq_number, skb))\n\t\treturn NETDEV_TX_BUSY;\n\n\treturn 0;\n}\n\nstatic netdev_tx_t t7xx_ccmni_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct t7xx_ccmni *ccmni = wwan_netdev_drvpriv(dev);\n\tint skb_len = skb->len;\n\n\t \n\tif (skb->len > dev->mtu || skb_headroom(skb) < sizeof(struct ccci_header)) {\n\t\tdev_kfree_skb(skb);\n\t\tdev->stats.tx_dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (t7xx_ccmni_send_packet(ccmni, skb, DPMAIF_TX_DEFAULT_QUEUE))\n\t\treturn NETDEV_TX_BUSY;\n\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += skb_len;\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void t7xx_ccmni_tx_timeout(struct net_device *dev, unsigned int __always_unused txqueue)\n{\n\tstruct t7xx_ccmni *ccmni = netdev_priv(dev);\n\n\tdev->stats.tx_errors++;\n\n\tif (atomic_read(&ccmni->usage) > 0)\n\t\tnetif_tx_wake_all_queues(dev);\n}\n\nstatic const struct net_device_ops ccmni_netdev_ops = {\n\t.ndo_open\t  = t7xx_ccmni_open,\n\t.ndo_stop\t  = t7xx_ccmni_close,\n\t.ndo_start_xmit   = t7xx_ccmni_start_xmit,\n\t.ndo_tx_timeout   = t7xx_ccmni_tx_timeout,\n};\n\nstatic void t7xx_ccmni_start(struct t7xx_ccmni_ctrl *ctlb)\n{\n\tstruct t7xx_ccmni *ccmni;\n\tint i;\n\n\tfor (i = 0; i < ctlb->nic_dev_num; i++) {\n\t\tccmni = ctlb->ccmni_inst[i];\n\t\tif (!ccmni)\n\t\t\tcontinue;\n\n\t\tif (atomic_read(&ccmni->usage) > 0) {\n\t\t\tnetif_tx_start_all_queues(ccmni->dev);\n\t\t\tnetif_carrier_on(ccmni->dev);\n\t\t}\n\t}\n\n\tif (atomic_read(&ctlb->napi_usr_refcnt))\n\t\tt7xx_ccmni_enable_napi(ctlb);\n}\n\nstatic void t7xx_ccmni_pre_stop(struct t7xx_ccmni_ctrl *ctlb)\n{\n\tstruct t7xx_ccmni *ccmni;\n\tint i;\n\n\tfor (i = 0; i < ctlb->nic_dev_num; i++) {\n\t\tccmni = ctlb->ccmni_inst[i];\n\t\tif (!ccmni)\n\t\t\tcontinue;\n\n\t\tif (atomic_read(&ccmni->usage) > 0)\n\t\t\tnetif_tx_disable(ccmni->dev);\n\t}\n}\n\nstatic void t7xx_ccmni_post_stop(struct t7xx_ccmni_ctrl *ctlb)\n{\n\tstruct t7xx_ccmni *ccmni;\n\tint i;\n\n\tif (atomic_read(&ctlb->napi_usr_refcnt))\n\t\tt7xx_ccmni_disable_napi(ctlb);\n\n\tfor (i = 0; i < ctlb->nic_dev_num; i++) {\n\t\tccmni = ctlb->ccmni_inst[i];\n\t\tif (!ccmni)\n\t\t\tcontinue;\n\n\t\tif (atomic_read(&ccmni->usage) > 0)\n\t\t\tnetif_carrier_off(ccmni->dev);\n\t}\n}\n\nstatic void t7xx_ccmni_wwan_setup(struct net_device *dev)\n{\n\tdev->needed_headroom += sizeof(struct ccci_header);\n\n\tdev->mtu = ETH_DATA_LEN;\n\tdev->max_mtu = CCMNI_MTU_MAX;\n\tBUILD_BUG_ON(CCMNI_MTU_MAX > DPMAIF_HW_MTU_SIZE);\n\n\tdev->tx_queue_len = DEFAULT_TX_QUEUE_LEN;\n\tdev->watchdog_timeo = CCMNI_NETDEV_WDT_TO;\n\n\tdev->flags = IFF_POINTOPOINT | IFF_NOARP;\n\n\tdev->features = NETIF_F_VLAN_CHALLENGED;\n\n\tdev->features |= NETIF_F_SG;\n\tdev->hw_features |= NETIF_F_SG;\n\n\tdev->features |= NETIF_F_HW_CSUM;\n\tdev->hw_features |= NETIF_F_HW_CSUM;\n\n\tdev->features |= NETIF_F_RXCSUM;\n\tdev->hw_features |= NETIF_F_RXCSUM;\n\n\tdev->features |= NETIF_F_GRO;\n\tdev->hw_features |= NETIF_F_GRO;\n\n\tdev->needs_free_netdev = true;\n\n\tdev->type = ARPHRD_NONE;\n\n\tdev->netdev_ops = &ccmni_netdev_ops;\n}\n\nstatic void t7xx_init_netdev_napi(struct t7xx_ccmni_ctrl *ctlb)\n{\n\tint i;\n\n\t \n\tinit_dummy_netdev(&ctlb->dummy_dev);\n\tatomic_set(&ctlb->napi_usr_refcnt, 0);\n\tctlb->is_napi_en = false;\n\n\tfor (i = 0; i < RXQ_NUM; i++) {\n\t\tctlb->napi[i] = &ctlb->hif_ctrl->rxq[i].napi;\n\t\tnetif_napi_add_weight(&ctlb->dummy_dev, ctlb->napi[i], t7xx_dpmaif_napi_rx_poll,\n\t\t\t\t      NIC_NAPI_POLL_BUDGET);\n\t}\n}\n\nstatic void t7xx_uninit_netdev_napi(struct t7xx_ccmni_ctrl *ctlb)\n{\n\tint i;\n\n\tfor (i = 0; i < RXQ_NUM; i++) {\n\t\tnetif_napi_del(ctlb->napi[i]);\n\t\tctlb->napi[i] = NULL;\n\t}\n}\n\nstatic int t7xx_ccmni_wwan_newlink(void *ctxt, struct net_device *dev, u32 if_id,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct t7xx_ccmni_ctrl *ctlb = ctxt;\n\tstruct t7xx_ccmni *ccmni;\n\tint ret;\n\n\tif (if_id >= ARRAY_SIZE(ctlb->ccmni_inst))\n\t\treturn -EINVAL;\n\n\tccmni = wwan_netdev_drvpriv(dev);\n\tccmni->index = if_id;\n\tccmni->ctlb = ctlb;\n\tccmni->dev = dev;\n\tatomic_set(&ccmni->usage, 0);\n\tctlb->ccmni_inst[if_id] = ccmni;\n\n\tret = register_netdevice(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tnetif_device_attach(dev);\n\treturn 0;\n}\n\nstatic void t7xx_ccmni_wwan_dellink(void *ctxt, struct net_device *dev, struct list_head *head)\n{\n\tstruct t7xx_ccmni *ccmni = wwan_netdev_drvpriv(dev);\n\tstruct t7xx_ccmni_ctrl *ctlb = ctxt;\n\tu8 if_id = ccmni->index;\n\n\tif (if_id >= ARRAY_SIZE(ctlb->ccmni_inst))\n\t\treturn;\n\n\tif (WARN_ON(ctlb->ccmni_inst[if_id] != ccmni))\n\t\treturn;\n\n\tunregister_netdevice(dev);\n}\n\nstatic const struct wwan_ops ccmni_wwan_ops = {\n\t.priv_size = sizeof(struct t7xx_ccmni),\n\t.setup     = t7xx_ccmni_wwan_setup,\n\t.newlink   = t7xx_ccmni_wwan_newlink,\n\t.dellink   = t7xx_ccmni_wwan_dellink,\n};\n\nstatic int t7xx_ccmni_register_wwan(struct t7xx_ccmni_ctrl *ctlb)\n{\n\tstruct device *dev = ctlb->hif_ctrl->dev;\n\tint ret;\n\n\tif (ctlb->wwan_is_registered)\n\t\treturn 0;\n\n\t \n\tret = wwan_register_ops(dev, &ccmni_wwan_ops, ctlb, IP_MUX_SESSION_DEFAULT);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Unable to register WWAN ops, %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tctlb->wwan_is_registered = true;\n\treturn 0;\n}\n\nstatic int t7xx_ccmni_md_state_callback(enum md_state state, void *para)\n{\n\tstruct t7xx_ccmni_ctrl *ctlb = para;\n\tstruct device *dev;\n\tint ret = 0;\n\n\tdev = ctlb->hif_ctrl->dev;\n\tctlb->md_sta = state;\n\n\tswitch (state) {\n\tcase MD_STATE_READY:\n\t\tret = t7xx_ccmni_register_wwan(ctlb);\n\t\tif (!ret)\n\t\t\tt7xx_ccmni_start(ctlb);\n\t\tbreak;\n\n\tcase MD_STATE_EXCEPTION:\n\tcase MD_STATE_STOPPED:\n\t\tt7xx_ccmni_pre_stop(ctlb);\n\n\t\tret = t7xx_dpmaif_md_state_callback(ctlb->hif_ctrl, state);\n\t\tif (ret < 0)\n\t\t\tdev_err(dev, \"DPMAIF md state callback err, state=%d\\n\", state);\n\n\t\tt7xx_ccmni_post_stop(ctlb);\n\t\tbreak;\n\n\tcase MD_STATE_WAITING_FOR_HS1:\n\tcase MD_STATE_WAITING_TO_STOP:\n\t\tret = t7xx_dpmaif_md_state_callback(ctlb->hif_ctrl, state);\n\t\tif (ret < 0)\n\t\t\tdev_err(dev, \"DPMAIF md state callback err, state=%d\\n\", state);\n\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void init_md_status_notifier(struct t7xx_pci_dev *t7xx_dev)\n{\n\tstruct t7xx_ccmni_ctrl\t*ctlb = t7xx_dev->ccmni_ctlb;\n\tstruct t7xx_fsm_notifier *md_status_notifier;\n\n\tmd_status_notifier = &ctlb->md_status_notify;\n\tINIT_LIST_HEAD(&md_status_notifier->entry);\n\tmd_status_notifier->notifier_fn = t7xx_ccmni_md_state_callback;\n\tmd_status_notifier->data = ctlb;\n\n\tt7xx_fsm_notifier_register(t7xx_dev->md, md_status_notifier);\n}\n\nstatic void t7xx_ccmni_recv_skb(struct t7xx_ccmni_ctrl *ccmni_ctlb, struct sk_buff *skb,\n\t\t\t\tstruct napi_struct *napi)\n{\n\tstruct t7xx_skb_cb *skb_cb;\n\tstruct net_device *net_dev;\n\tstruct t7xx_ccmni *ccmni;\n\tint pkt_type, skb_len;\n\tu8 netif_id;\n\n\tskb_cb = T7XX_SKB_CB(skb);\n\tnetif_id = skb_cb->netif_idx;\n\tccmni = ccmni_ctlb->ccmni_inst[netif_id];\n\tif (!ccmni) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n\tnet_dev = ccmni->dev;\n\tpkt_type = skb_cb->rx_pkt_type;\n\tskb->dev = net_dev;\n\tif (pkt_type == PKT_TYPE_IP6)\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\telse\n\t\tskb->protocol = htons(ETH_P_IP);\n\n\tskb_len = skb->len;\n\tnapi_gro_receive(napi, skb);\n\tnet_dev->stats.rx_packets++;\n\tnet_dev->stats.rx_bytes += skb_len;\n}\n\nstatic void t7xx_ccmni_queue_tx_irq_notify(struct t7xx_ccmni_ctrl *ctlb, int qno)\n{\n\tstruct t7xx_ccmni *ccmni = ctlb->ccmni_inst[0];\n\tstruct netdev_queue *net_queue;\n\n\tif (netif_running(ccmni->dev) && atomic_read(&ccmni->usage) > 0) {\n\t\tnet_queue = netdev_get_tx_queue(ccmni->dev, qno);\n\t\tif (netif_tx_queue_stopped(net_queue))\n\t\t\tnetif_tx_wake_queue(net_queue);\n\t}\n}\n\nstatic void t7xx_ccmni_queue_tx_full_notify(struct t7xx_ccmni_ctrl *ctlb, int qno)\n{\n\tstruct t7xx_ccmni *ccmni = ctlb->ccmni_inst[0];\n\tstruct netdev_queue *net_queue;\n\n\tif (atomic_read(&ccmni->usage) > 0) {\n\t\tnetdev_err(ccmni->dev, \"TX queue %d is full\\n\", qno);\n\t\tnet_queue = netdev_get_tx_queue(ccmni->dev, qno);\n\t\tnetif_tx_stop_queue(net_queue);\n\t}\n}\n\nstatic void t7xx_ccmni_queue_state_notify(struct t7xx_pci_dev *t7xx_dev,\n\t\t\t\t\t  enum dpmaif_txq_state state, int qno)\n{\n\tstruct t7xx_ccmni_ctrl *ctlb = t7xx_dev->ccmni_ctlb;\n\n\tif (ctlb->md_sta != MD_STATE_READY)\n\t\treturn;\n\n\tif (!ctlb->ccmni_inst[0]) {\n\t\tdev_warn(&t7xx_dev->pdev->dev, \"No netdev registered yet\\n\");\n\t\treturn;\n\t}\n\n\tif (state == DMPAIF_TXQ_STATE_IRQ)\n\t\tt7xx_ccmni_queue_tx_irq_notify(ctlb, qno);\n\telse if (state == DMPAIF_TXQ_STATE_FULL)\n\t\tt7xx_ccmni_queue_tx_full_notify(ctlb, qno);\n}\n\nint t7xx_ccmni_init(struct t7xx_pci_dev *t7xx_dev)\n{\n\tstruct device *dev = &t7xx_dev->pdev->dev;\n\tstruct t7xx_ccmni_ctrl *ctlb;\n\n\tctlb = devm_kzalloc(dev, sizeof(*ctlb), GFP_KERNEL);\n\tif (!ctlb)\n\t\treturn -ENOMEM;\n\n\tt7xx_dev->ccmni_ctlb = ctlb;\n\tctlb->t7xx_dev = t7xx_dev;\n\tctlb->callbacks.state_notify = t7xx_ccmni_queue_state_notify;\n\tctlb->callbacks.recv_skb = t7xx_ccmni_recv_skb;\n\tctlb->nic_dev_num = NIC_DEV_DEFAULT;\n\n\tctlb->hif_ctrl = t7xx_dpmaif_hif_init(t7xx_dev, &ctlb->callbacks);\n\tif (!ctlb->hif_ctrl)\n\t\treturn -ENOMEM;\n\n\tt7xx_init_netdev_napi(ctlb);\n\tinit_md_status_notifier(t7xx_dev);\n\treturn 0;\n}\n\nvoid t7xx_ccmni_exit(struct t7xx_pci_dev *t7xx_dev)\n{\n\tstruct t7xx_ccmni_ctrl *ctlb = t7xx_dev->ccmni_ctlb;\n\n\tt7xx_fsm_notifier_unregister(t7xx_dev->md, &ctlb->md_status_notify);\n\n\tif (ctlb->wwan_is_registered) {\n\t\twwan_unregister_ops(&t7xx_dev->pdev->dev);\n\t\tctlb->wwan_is_registered = false;\n\t}\n\n\tt7xx_uninit_netdev_napi(ctlb);\n\tt7xx_dpmaif_hif_exit(ctlb->hif_ctrl);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}