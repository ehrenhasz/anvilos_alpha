{
  "module_name": "t7xx_port_wwan.c",
  "hash_id": "e536c79135541cd2e117111cf13a7d1b53a9f777c3598730073cd1396fedc7e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wwan/t7xx/t7xx_port_wwan.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/bitfield.h>\n#include <linux/dev_printk.h>\n#include <linux/err.h>\n#include <linux/gfp.h>\n#include <linux/minmax.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/wwan.h>\n\n#include \"t7xx_port.h\"\n#include \"t7xx_port_proxy.h\"\n#include \"t7xx_state_monitor.h\"\n\nstatic int t7xx_port_ctrl_start(struct wwan_port *port)\n{\n\tstruct t7xx_port *port_mtk = wwan_port_get_drvdata(port);\n\n\tif (atomic_read(&port_mtk->usage_cnt))\n\t\treturn -EBUSY;\n\n\tatomic_inc(&port_mtk->usage_cnt);\n\treturn 0;\n}\n\nstatic void t7xx_port_ctrl_stop(struct wwan_port *port)\n{\n\tstruct t7xx_port *port_mtk = wwan_port_get_drvdata(port);\n\n\tatomic_dec(&port_mtk->usage_cnt);\n}\n\nstatic int t7xx_port_ctrl_tx(struct wwan_port *port, struct sk_buff *skb)\n{\n\tstruct t7xx_port *port_private = wwan_port_get_drvdata(port);\n\tconst struct t7xx_port_conf *port_conf;\n\tstruct sk_buff *cur = skb, *cloned;\n\tstruct t7xx_fsm_ctl *ctl;\n\tenum md_state md_state;\n\tint cnt = 0, ret;\n\n\tif (!port_private->chan_enable)\n\t\treturn -EINVAL;\n\n\tport_conf = port_private->port_conf;\n\tctl = port_private->t7xx_dev->md->fsm_ctl;\n\tmd_state = t7xx_fsm_get_md_state(ctl);\n\tif (md_state == MD_STATE_WAITING_FOR_HS1 || md_state == MD_STATE_WAITING_FOR_HS2) {\n\t\tdev_warn(port_private->dev, \"Cannot write to %s port when md_state=%d\\n\",\n\t\t\t port_conf->name, md_state);\n\t\treturn -ENODEV;\n\t}\n\n\twhile (cur) {\n\t\tcloned = skb_clone(cur, GFP_KERNEL);\n\t\tcloned->len = skb_headlen(cur);\n\t\tret = t7xx_port_send_skb(port_private, cloned, 0, 0);\n\t\tif (ret) {\n\t\t\tdev_kfree_skb(cloned);\n\t\t\tdev_err(port_private->dev, \"Write error on %s port, %d\\n\",\n\t\t\t\tport_conf->name, ret);\n\t\t\treturn cnt ? cnt + ret : ret;\n\t\t}\n\t\tcnt += cur->len;\n\t\tif (cur == skb)\n\t\t\tcur = skb_shinfo(skb)->frag_list;\n\t\telse\n\t\t\tcur = cur->next;\n\t}\n\n\tdev_kfree_skb(skb);\n\treturn 0;\n}\n\nstatic const struct wwan_port_ops wwan_ops = {\n\t.start = t7xx_port_ctrl_start,\n\t.stop = t7xx_port_ctrl_stop,\n\t.tx = t7xx_port_ctrl_tx,\n};\n\nstatic int t7xx_port_wwan_init(struct t7xx_port *port)\n{\n\tport->rx_length_th = RX_QUEUE_MAXLEN;\n\treturn 0;\n}\n\nstatic void t7xx_port_wwan_uninit(struct t7xx_port *port)\n{\n\tif (!port->wwan.wwan_port)\n\t\treturn;\n\n\tport->rx_length_th = 0;\n\twwan_remove_port(port->wwan.wwan_port);\n\tport->wwan.wwan_port = NULL;\n}\n\nstatic int t7xx_port_wwan_recv_skb(struct t7xx_port *port, struct sk_buff *skb)\n{\n\tif (!atomic_read(&port->usage_cnt) || !port->chan_enable) {\n\t\tconst struct t7xx_port_conf *port_conf = port->port_conf;\n\n\t\tdev_kfree_skb_any(skb);\n\t\tdev_err_ratelimited(port->dev, \"Port %s is not opened, drop packets\\n\",\n\t\t\t\t    port_conf->name);\n\t\t \n\t\treturn 0;\n\t}\n\n\twwan_port_rx(port->wwan.wwan_port, skb);\n\treturn 0;\n}\n\nstatic int t7xx_port_wwan_enable_chl(struct t7xx_port *port)\n{\n\tspin_lock(&port->port_update_lock);\n\tport->chan_enable = true;\n\tspin_unlock(&port->port_update_lock);\n\n\treturn 0;\n}\n\nstatic int t7xx_port_wwan_disable_chl(struct t7xx_port *port)\n{\n\tspin_lock(&port->port_update_lock);\n\tport->chan_enable = false;\n\tspin_unlock(&port->port_update_lock);\n\n\treturn 0;\n}\n\nstatic void t7xx_port_wwan_md_state_notify(struct t7xx_port *port, unsigned int state)\n{\n\tconst struct t7xx_port_conf *port_conf = port->port_conf;\n\tunsigned int header_len = sizeof(struct ccci_header);\n\tstruct wwan_port_caps caps;\n\n\tif (state != MD_STATE_READY)\n\t\treturn;\n\n\tif (!port->wwan.wwan_port) {\n\t\tcaps.frag_len = CLDMA_MTU - header_len;\n\t\tcaps.headroom_len = header_len;\n\t\tport->wwan.wwan_port = wwan_create_port(port->dev, port_conf->port_type,\n\t\t\t\t\t\t\t&wwan_ops, &caps, port);\n\t\tif (IS_ERR(port->wwan.wwan_port))\n\t\t\tdev_err(port->dev, \"Unable to create WWWAN port %s\", port_conf->name);\n\t}\n}\n\nstruct port_ops wwan_sub_port_ops = {\n\t.init = t7xx_port_wwan_init,\n\t.recv_skb = t7xx_port_wwan_recv_skb,\n\t.uninit = t7xx_port_wwan_uninit,\n\t.enable_chl = t7xx_port_wwan_enable_chl,\n\t.disable_chl = t7xx_port_wwan_disable_chl,\n\t.md_state_notify = t7xx_port_wwan_md_state_notify,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}