{
  "module_name": "t7xx_port_ctrl_msg.c",
  "hash_id": "8993775afb40dafbc2ed699d36a02a2ad039375ea2332d8cf717e856fb8f2239",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wwan/t7xx/t7xx_port_ctrl_msg.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n\n#include \"t7xx_port.h\"\n#include \"t7xx_port_proxy.h\"\n#include \"t7xx_state_monitor.h\"\n\n#define PORT_MSG_VERSION\tGENMASK(31, 16)\n#define PORT_MSG_PRT_CNT\tGENMASK(15, 0)\n\nstruct port_msg {\n\t__le32\thead_pattern;\n\t__le32\tinfo;\n\t__le32\ttail_pattern;\n\t__le32\tdata[];\n};\n\nstatic int port_ctl_send_msg_to_md(struct t7xx_port *port, unsigned int msg, unsigned int ex_msg)\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = t7xx_ctrl_alloc_skb(0);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tret = t7xx_port_send_ctl_skb(port, skb, msg, ex_msg);\n\tif (ret)\n\t\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\nstatic int fsm_ee_message_handler(struct t7xx_port *port, struct t7xx_fsm_ctl *ctl,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct ctrl_msg_header *ctrl_msg_h = (struct ctrl_msg_header *)skb->data;\n\tstruct device *dev = &ctl->md->t7xx_dev->pdev->dev;\n\tenum md_state md_state;\n\tint ret = -EINVAL;\n\n\tmd_state = t7xx_fsm_get_md_state(ctl);\n\tif (md_state != MD_STATE_EXCEPTION) {\n\t\tdev_err(dev, \"Receive invalid MD_EX %x when MD state is %d\\n\",\n\t\t\tctrl_msg_h->ex_msg, md_state);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (le32_to_cpu(ctrl_msg_h->ctrl_msg_id)) {\n\tcase CTL_ID_MD_EX:\n\t\tif (le32_to_cpu(ctrl_msg_h->ex_msg) != MD_EX_CHK_ID) {\n\t\t\tdev_err(dev, \"Receive invalid MD_EX %x\\n\", ctrl_msg_h->ex_msg);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = port_ctl_send_msg_to_md(port, CTL_ID_MD_EX, MD_EX_CHK_ID);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to send exception message to modem\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tret = t7xx_fsm_append_event(ctl, FSM_EVENT_MD_EX, NULL, 0);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Failed to append Modem Exception event\");\n\n\t\tbreak;\n\n\tcase CTL_ID_MD_EX_ACK:\n\t\tif (le32_to_cpu(ctrl_msg_h->ex_msg) != MD_EX_CHK_ACK_ID) {\n\t\t\tdev_err(dev, \"Receive invalid MD_EX_ACK %x\\n\", ctrl_msg_h->ex_msg);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = t7xx_fsm_append_event(ctl, FSM_EVENT_MD_EX_REC_OK, NULL, 0);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Failed to append Modem Exception Received event\");\n\n\t\tbreak;\n\n\tcase CTL_ID_MD_EX_PASS:\n\t\tret = t7xx_fsm_append_event(ctl, FSM_EVENT_MD_EX_PASS, NULL, 0);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Failed to append Modem Exception Passed event\");\n\n\t\tbreak;\n\n\tcase CTL_ID_DRV_VER_ERROR:\n\t\tdev_err(dev, \"AP/MD driver version mismatch\\n\");\n\t}\n\n\treturn ret;\n}\n\n \nint t7xx_port_enum_msg_handler(struct t7xx_modem *md, void *msg)\n{\n\tstruct device *dev = &md->t7xx_dev->pdev->dev;\n\tunsigned int version, port_count, i;\n\tstruct port_msg *port_msg = msg;\n\n\tversion = FIELD_GET(PORT_MSG_VERSION, le32_to_cpu(port_msg->info));\n\tif (version != PORT_ENUM_VER ||\n\t    le32_to_cpu(port_msg->head_pattern) != PORT_ENUM_HEAD_PATTERN ||\n\t    le32_to_cpu(port_msg->tail_pattern) != PORT_ENUM_TAIL_PATTERN) {\n\t\tdev_err(dev, \"Invalid port control message %x:%x:%x\\n\",\n\t\t\tversion, le32_to_cpu(port_msg->head_pattern),\n\t\t\tle32_to_cpu(port_msg->tail_pattern));\n\t\treturn -EFAULT;\n\t}\n\n\tport_count = FIELD_GET(PORT_MSG_PRT_CNT, le32_to_cpu(port_msg->info));\n\tfor (i = 0; i < port_count; i++) {\n\t\tu32 port_info = le32_to_cpu(port_msg->data[i]);\n\t\tunsigned int ch_id;\n\t\tbool en_flag;\n\n\t\tch_id = FIELD_GET(PORT_INFO_CH_ID, port_info);\n\t\ten_flag = port_info & PORT_INFO_ENFLG;\n\t\tif (t7xx_port_proxy_chl_enable_disable(md->port_prox, ch_id, en_flag))\n\t\t\tdev_dbg(dev, \"Port:%x not found\\n\", ch_id);\n\t}\n\n\treturn 0;\n}\n\nstatic int control_msg_handler(struct t7xx_port *port, struct sk_buff *skb)\n{\n\tconst struct t7xx_port_conf *port_conf = port->port_conf;\n\tstruct t7xx_fsm_ctl *ctl = port->t7xx_dev->md->fsm_ctl;\n\tstruct ctrl_msg_header *ctrl_msg_h;\n\tint ret = 0;\n\n\tctrl_msg_h = (struct ctrl_msg_header *)skb->data;\n\tswitch (le32_to_cpu(ctrl_msg_h->ctrl_msg_id)) {\n\tcase CTL_ID_HS2_MSG:\n\t\tskb_pull(skb, sizeof(*ctrl_msg_h));\n\n\t\tif (port_conf->rx_ch == PORT_CH_CONTROL_RX ||\n\t\t    port_conf->rx_ch == PORT_CH_AP_CONTROL_RX) {\n\t\t\tint event = port_conf->rx_ch == PORT_CH_CONTROL_RX ?\n\t\t\t\t    FSM_EVENT_MD_HS2 : FSM_EVENT_AP_HS2;\n\n\t\t\tret = t7xx_fsm_append_event(ctl, event, skb->data,\n\t\t\t\t\t\t    le32_to_cpu(ctrl_msg_h->data_length));\n\t\t\tif (ret)\n\t\t\t\tdev_err(port->dev, \"Failed to append Handshake 2 event\");\n\t\t}\n\n\t\tdev_kfree_skb_any(skb);\n\t\tbreak;\n\n\tcase CTL_ID_MD_EX:\n\tcase CTL_ID_MD_EX_ACK:\n\tcase CTL_ID_MD_EX_PASS:\n\tcase CTL_ID_DRV_VER_ERROR:\n\t\tret = fsm_ee_message_handler(port, ctl, skb);\n\t\tdev_kfree_skb_any(skb);\n\t\tbreak;\n\n\tcase CTL_ID_PORT_ENUM:\n\t\tskb_pull(skb, sizeof(*ctrl_msg_h));\n\t\tret = t7xx_port_enum_msg_handler(ctl->md, (struct port_msg *)skb->data);\n\t\tif (!ret)\n\t\t\tret = port_ctl_send_msg_to_md(port, CTL_ID_PORT_ENUM, 0);\n\t\telse\n\t\t\tret = port_ctl_send_msg_to_md(port, CTL_ID_PORT_ENUM,\n\t\t\t\t\t\t      PORT_ENUM_VER_MISMATCH);\n\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tdev_err(port->dev, \"Unknown control message ID to FSM %x\\n\",\n\t\t\tle32_to_cpu(ctrl_msg_h->ctrl_msg_id));\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\tdev_err(port->dev, \"%s control message handle error: %d\\n\", port_conf->name, ret);\n\n\treturn ret;\n}\n\nstatic int port_ctl_rx_thread(void *arg)\n{\n\twhile (!kthread_should_stop()) {\n\t\tstruct t7xx_port *port = arg;\n\t\tstruct sk_buff *skb;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&port->rx_wq.lock, flags);\n\t\tif (skb_queue_empty(&port->rx_skb_list) &&\n\t\t    wait_event_interruptible_locked_irq(port->rx_wq,\n\t\t\t\t\t\t\t!skb_queue_empty(&port->rx_skb_list) ||\n\t\t\t\t\t\t\tkthread_should_stop())) {\n\t\t\tspin_unlock_irqrestore(&port->rx_wq.lock, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tif (kthread_should_stop()) {\n\t\t\tspin_unlock_irqrestore(&port->rx_wq.lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\tskb = __skb_dequeue(&port->rx_skb_list);\n\t\tspin_unlock_irqrestore(&port->rx_wq.lock, flags);\n\n\t\tcontrol_msg_handler(port, skb);\n\t}\n\n\treturn 0;\n}\n\nstatic int port_ctl_init(struct t7xx_port *port)\n{\n\tconst struct t7xx_port_conf *port_conf = port->port_conf;\n\n\tport->thread = kthread_run(port_ctl_rx_thread, port, \"%s\", port_conf->name);\n\tif (IS_ERR(port->thread)) {\n\t\tdev_err(port->dev, \"Failed to start port control thread\\n\");\n\t\treturn PTR_ERR(port->thread);\n\t}\n\n\tport->rx_length_th = CTRL_QUEUE_MAXLEN;\n\treturn 0;\n}\n\nstatic void port_ctl_uninit(struct t7xx_port *port)\n{\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\n\tif (port->thread)\n\t\tkthread_stop(port->thread);\n\n\tspin_lock_irqsave(&port->rx_wq.lock, flags);\n\tport->rx_length_th = 0;\n\twhile ((skb = __skb_dequeue(&port->rx_skb_list)) != NULL)\n\t\tdev_kfree_skb_any(skb);\n\tspin_unlock_irqrestore(&port->rx_wq.lock, flags);\n}\n\nstruct port_ops ctl_port_ops = {\n\t.init = port_ctl_init,\n\t.recv_skb = t7xx_port_enqueue_skb,\n\t.uninit = port_ctl_uninit,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}