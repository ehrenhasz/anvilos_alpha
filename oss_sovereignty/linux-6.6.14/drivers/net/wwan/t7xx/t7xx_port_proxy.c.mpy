{
  "module_name": "t7xx_port_proxy.c",
  "hash_id": "9cd095952b44ec9d905b1248c6d975abe6602538c93c1edb9baa90d7e8cd9048",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wwan/t7xx/t7xx_port_proxy.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/wait.h>\n#include <linux/wwan.h>\n\n#include \"t7xx_hif_cldma.h\"\n#include \"t7xx_modem_ops.h\"\n#include \"t7xx_port.h\"\n#include \"t7xx_port_proxy.h\"\n#include \"t7xx_state_monitor.h\"\n\n#define Q_IDX_CTRL\t\t\t0\n#define Q_IDX_MBIM\t\t\t2\n#define Q_IDX_AT_CMD\t\t\t5\n\n#define INVALID_SEQ_NUM\t\t\tGENMASK(15, 0)\n\n#define for_each_proxy_port(i, p, proxy)\t\\\n\tfor (i = 0, (p) = &(proxy)->ports[i];\t\\\n\t     i < (proxy)->port_count;\t\t\\\n\t     i++, (p) = &(proxy)->ports[i])\n\nstatic const struct t7xx_port_conf t7xx_port_conf[] = {\n\t{\n\t\t.tx_ch = PORT_CH_UART2_TX,\n\t\t.rx_ch = PORT_CH_UART2_RX,\n\t\t.txq_index = Q_IDX_AT_CMD,\n\t\t.rxq_index = Q_IDX_AT_CMD,\n\t\t.txq_exp_index = 0xff,\n\t\t.rxq_exp_index = 0xff,\n\t\t.path_id = CLDMA_ID_MD,\n\t\t.ops = &wwan_sub_port_ops,\n\t\t.name = \"AT\",\n\t\t.port_type = WWAN_PORT_AT,\n\t}, {\n\t\t.tx_ch = PORT_CH_MBIM_TX,\n\t\t.rx_ch = PORT_CH_MBIM_RX,\n\t\t.txq_index = Q_IDX_MBIM,\n\t\t.rxq_index = Q_IDX_MBIM,\n\t\t.path_id = CLDMA_ID_MD,\n\t\t.ops = &wwan_sub_port_ops,\n\t\t.name = \"MBIM\",\n\t\t.port_type = WWAN_PORT_MBIM,\n\t}, {\n#ifdef CONFIG_WWAN_DEBUGFS\n\t\t.tx_ch = PORT_CH_MD_LOG_TX,\n\t\t.rx_ch = PORT_CH_MD_LOG_RX,\n\t\t.txq_index = 7,\n\t\t.rxq_index = 7,\n\t\t.txq_exp_index = 7,\n\t\t.rxq_exp_index = 7,\n\t\t.path_id = CLDMA_ID_MD,\n\t\t.ops = &t7xx_trace_port_ops,\n\t\t.name = \"mdlog\",\n\t}, {\n#endif\n\t\t.tx_ch = PORT_CH_CONTROL_TX,\n\t\t.rx_ch = PORT_CH_CONTROL_RX,\n\t\t.txq_index = Q_IDX_CTRL,\n\t\t.rxq_index = Q_IDX_CTRL,\n\t\t.path_id = CLDMA_ID_MD,\n\t\t.ops = &ctl_port_ops,\n\t\t.name = \"t7xx_ctrl\",\n\t}, {\n\t\t.tx_ch = PORT_CH_AP_CONTROL_TX,\n\t\t.rx_ch = PORT_CH_AP_CONTROL_RX,\n\t\t.txq_index = Q_IDX_CTRL,\n\t\t.rxq_index = Q_IDX_CTRL,\n\t\t.path_id = CLDMA_ID_AP,\n\t\t.ops = &ctl_port_ops,\n\t\t.name = \"t7xx_ap_ctrl\",\n\t},\n};\n\nstatic struct t7xx_port *t7xx_proxy_get_port_by_ch(struct port_proxy *port_prox, enum port_ch ch)\n{\n\tconst struct t7xx_port_conf *port_conf;\n\tstruct t7xx_port *port;\n\tint i;\n\n\tfor_each_proxy_port(i, port, port_prox) {\n\t\tport_conf = port->port_conf;\n\t\tif (port_conf->rx_ch == ch || port_conf->tx_ch == ch)\n\t\t\treturn port;\n\t}\n\n\treturn NULL;\n}\n\nstatic u16 t7xx_port_next_rx_seq_num(struct t7xx_port *port, struct ccci_header *ccci_h)\n{\n\tu32 status = le32_to_cpu(ccci_h->status);\n\tu16 seq_num, next_seq_num;\n\tbool assert_bit;\n\n\tseq_num = FIELD_GET(CCCI_H_SEQ_FLD, status);\n\tnext_seq_num = (seq_num + 1) & FIELD_MAX(CCCI_H_SEQ_FLD);\n\tassert_bit = status & CCCI_H_AST_BIT;\n\tif (!assert_bit || port->seq_nums[MTK_RX] == INVALID_SEQ_NUM)\n\t\treturn next_seq_num;\n\n\tif (seq_num != port->seq_nums[MTK_RX])\n\t\tdev_warn_ratelimited(port->dev,\n\t\t\t\t     \"seq num out-of-order %u != %u (header %X, len %X)\\n\",\n\t\t\t\t     seq_num, port->seq_nums[MTK_RX],\n\t\t\t\t     le32_to_cpu(ccci_h->packet_header),\n\t\t\t\t     le32_to_cpu(ccci_h->packet_len));\n\n\treturn next_seq_num;\n}\n\nvoid t7xx_port_proxy_reset(struct port_proxy *port_prox)\n{\n\tstruct t7xx_port *port;\n\tint i;\n\n\tfor_each_proxy_port(i, port, port_prox) {\n\t\tport->seq_nums[MTK_RX] = INVALID_SEQ_NUM;\n\t\tport->seq_nums[MTK_TX] = 0;\n\t}\n}\n\nstatic int t7xx_port_get_queue_no(struct t7xx_port *port)\n{\n\tconst struct t7xx_port_conf *port_conf = port->port_conf;\n\tstruct t7xx_fsm_ctl *ctl = port->t7xx_dev->md->fsm_ctl;\n\n\treturn t7xx_fsm_get_md_state(ctl) == MD_STATE_EXCEPTION ?\n\t\tport_conf->txq_exp_index : port_conf->txq_index;\n}\n\nstatic void t7xx_port_struct_init(struct t7xx_port *port)\n{\n\tINIT_LIST_HEAD(&port->entry);\n\tINIT_LIST_HEAD(&port->queue_entry);\n\tskb_queue_head_init(&port->rx_skb_list);\n\tinit_waitqueue_head(&port->rx_wq);\n\tport->seq_nums[MTK_RX] = INVALID_SEQ_NUM;\n\tport->seq_nums[MTK_TX] = 0;\n\tatomic_set(&port->usage_cnt, 0);\n}\n\nstruct sk_buff *t7xx_port_alloc_skb(int payload)\n{\n\tstruct sk_buff *skb = __dev_alloc_skb(payload + sizeof(struct ccci_header), GFP_KERNEL);\n\n\tif (skb)\n\t\tskb_reserve(skb, sizeof(struct ccci_header));\n\n\treturn skb;\n}\n\nstruct sk_buff *t7xx_ctrl_alloc_skb(int payload)\n{\n\tstruct sk_buff *skb = t7xx_port_alloc_skb(payload + sizeof(struct ctrl_msg_header));\n\n\tif (skb)\n\t\tskb_reserve(skb, sizeof(struct ctrl_msg_header));\n\n\treturn skb;\n}\n\n \nint t7xx_port_enqueue_skb(struct t7xx_port *port, struct sk_buff *skb)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->rx_wq.lock, flags);\n\tif (port->rx_skb_list.qlen >= port->rx_length_th) {\n\t\tspin_unlock_irqrestore(&port->rx_wq.lock, flags);\n\n\t\treturn -ENOBUFS;\n\t}\n\t__skb_queue_tail(&port->rx_skb_list, skb);\n\tspin_unlock_irqrestore(&port->rx_wq.lock, flags);\n\n\twake_up_all(&port->rx_wq);\n\treturn 0;\n}\n\nstatic int t7xx_port_send_raw_skb(struct t7xx_port *port, struct sk_buff *skb)\n{\n\tenum cldma_id path_id = port->port_conf->path_id;\n\tstruct cldma_ctrl *md_ctrl;\n\tint ret, tx_qno;\n\n\tmd_ctrl = port->t7xx_dev->md->md_ctrl[path_id];\n\ttx_qno = t7xx_port_get_queue_no(port);\n\tret = t7xx_cldma_send_skb(md_ctrl, tx_qno, skb);\n\tif (ret)\n\t\tdev_err(port->dev, \"Failed to send skb: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int t7xx_port_send_ccci_skb(struct t7xx_port *port, struct sk_buff *skb,\n\t\t\t\t   unsigned int pkt_header, unsigned int ex_msg)\n{\n\tconst struct t7xx_port_conf *port_conf = port->port_conf;\n\tstruct ccci_header *ccci_h;\n\tu32 status;\n\tint ret;\n\n\tccci_h = skb_push(skb, sizeof(*ccci_h));\n\tstatus = FIELD_PREP(CCCI_H_CHN_FLD, port_conf->tx_ch) |\n\t\t FIELD_PREP(CCCI_H_SEQ_FLD, port->seq_nums[MTK_TX]) | CCCI_H_AST_BIT;\n\tccci_h->status = cpu_to_le32(status);\n\tccci_h->packet_header = cpu_to_le32(pkt_header);\n\tccci_h->packet_len = cpu_to_le32(skb->len);\n\tccci_h->ex_msg = cpu_to_le32(ex_msg);\n\n\tret = t7xx_port_send_raw_skb(port, skb);\n\tif (ret)\n\t\treturn ret;\n\n\tport->seq_nums[MTK_TX]++;\n\treturn 0;\n}\n\nint t7xx_port_send_ctl_skb(struct t7xx_port *port, struct sk_buff *skb, unsigned int msg,\n\t\t\t   unsigned int ex_msg)\n{\n\tstruct ctrl_msg_header *ctrl_msg_h;\n\tunsigned int msg_len = skb->len;\n\tu32 pkt_header = 0;\n\n\tctrl_msg_h = skb_push(skb, sizeof(*ctrl_msg_h));\n\tctrl_msg_h->ctrl_msg_id = cpu_to_le32(msg);\n\tctrl_msg_h->ex_msg = cpu_to_le32(ex_msg);\n\tctrl_msg_h->data_length = cpu_to_le32(msg_len);\n\n\tif (!msg_len)\n\t\tpkt_header = CCCI_HEADER_NO_DATA;\n\n\treturn t7xx_port_send_ccci_skb(port, skb, pkt_header, ex_msg);\n}\n\nint t7xx_port_send_skb(struct t7xx_port *port, struct sk_buff *skb, unsigned int pkt_header,\n\t\t       unsigned int ex_msg)\n{\n\tstruct t7xx_fsm_ctl *ctl = port->t7xx_dev->md->fsm_ctl;\n\tunsigned int fsm_state;\n\n\tfsm_state = t7xx_fsm_get_ctl_state(ctl);\n\tif (fsm_state != FSM_STATE_PRE_START) {\n\t\tconst struct t7xx_port_conf *port_conf = port->port_conf;\n\t\tenum md_state md_state = t7xx_fsm_get_md_state(ctl);\n\n\t\tswitch (md_state) {\n\t\tcase MD_STATE_EXCEPTION:\n\t\t\tif (port_conf->tx_ch != PORT_CH_MD_LOG_TX)\n\t\t\t\treturn -EBUSY;\n\t\t\tbreak;\n\n\t\tcase MD_STATE_WAITING_FOR_HS1:\n\t\tcase MD_STATE_WAITING_FOR_HS2:\n\t\tcase MD_STATE_STOPPED:\n\t\tcase MD_STATE_WAITING_TO_STOP:\n\t\tcase MD_STATE_INVALID:\n\t\t\treturn -ENODEV;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn t7xx_port_send_ccci_skb(port, skb, pkt_header, ex_msg);\n}\n\nstatic void t7xx_proxy_setup_ch_mapping(struct port_proxy *port_prox)\n{\n\tstruct t7xx_port *port;\n\n\tint i, j;\n\n\tfor (i = 0; i < ARRAY_SIZE(port_prox->rx_ch_ports); i++)\n\t\tINIT_LIST_HEAD(&port_prox->rx_ch_ports[i]);\n\n\tfor (j = 0; j < ARRAY_SIZE(port_prox->queue_ports); j++) {\n\t\tfor (i = 0; i < ARRAY_SIZE(port_prox->queue_ports[j]); i++)\n\t\t\tINIT_LIST_HEAD(&port_prox->queue_ports[j][i]);\n\t}\n\n\tfor_each_proxy_port(i, port, port_prox) {\n\t\tconst struct t7xx_port_conf *port_conf = port->port_conf;\n\t\tenum cldma_id path_id = port_conf->path_id;\n\t\tu8 ch_id;\n\n\t\tch_id = FIELD_GET(PORT_CH_ID_MASK, port_conf->rx_ch);\n\t\tlist_add_tail(&port->entry, &port_prox->rx_ch_ports[ch_id]);\n\t\tlist_add_tail(&port->queue_entry,\n\t\t\t      &port_prox->queue_ports[path_id][port_conf->rxq_index]);\n\t}\n}\n\nstatic struct t7xx_port *t7xx_port_proxy_find_port(struct t7xx_pci_dev *t7xx_dev,\n\t\t\t\t\t\t   struct cldma_queue *queue, u16 channel)\n{\n\tstruct port_proxy *port_prox = t7xx_dev->md->port_prox;\n\tstruct list_head *port_list;\n\tstruct t7xx_port *port;\n\tu8 ch_id;\n\n\tch_id = FIELD_GET(PORT_CH_ID_MASK, channel);\n\tport_list = &port_prox->rx_ch_ports[ch_id];\n\tlist_for_each_entry(port, port_list, entry) {\n\t\tconst struct t7xx_port_conf *port_conf = port->port_conf;\n\n\t\tif (queue->md_ctrl->hif_id == port_conf->path_id &&\n\t\t    channel == port_conf->rx_ch)\n\t\t\treturn port;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int t7xx_port_proxy_recv_skb(struct cldma_queue *queue, struct sk_buff *skb)\n{\n\tstruct ccci_header *ccci_h = (struct ccci_header *)skb->data;\n\tstruct t7xx_pci_dev *t7xx_dev = queue->md_ctrl->t7xx_dev;\n\tstruct t7xx_fsm_ctl *ctl = t7xx_dev->md->fsm_ctl;\n\tstruct device *dev = queue->md_ctrl->dev;\n\tconst struct t7xx_port_conf *port_conf;\n\tstruct t7xx_port *port;\n\tu16 seq_num, channel;\n\tint ret;\n\n\tchannel = FIELD_GET(CCCI_H_CHN_FLD, le32_to_cpu(ccci_h->status));\n\tif (t7xx_fsm_get_md_state(ctl) == MD_STATE_INVALID) {\n\t\tdev_err_ratelimited(dev, \"Packet drop on channel 0x%x, modem not ready\\n\", channel);\n\t\tgoto drop_skb;\n\t}\n\n\tport = t7xx_port_proxy_find_port(t7xx_dev, queue, channel);\n\tif (!port) {\n\t\tdev_err_ratelimited(dev, \"Packet drop on channel 0x%x, port not found\\n\", channel);\n\t\tgoto drop_skb;\n\t}\n\n\tseq_num = t7xx_port_next_rx_seq_num(port, ccci_h);\n\tport_conf = port->port_conf;\n\tskb_pull(skb, sizeof(*ccci_h));\n\n\tret = port_conf->ops->recv_skb(port, skb);\n\t \n\tif (ret) {\n\t\tskb_push(skb, sizeof(*ccci_h));\n\t\treturn ret;\n\t}\n\n\tport->seq_nums[MTK_RX] = seq_num;\n\treturn 0;\n\ndrop_skb:\n\tdev_kfree_skb_any(skb);\n\treturn 0;\n}\n\n \nvoid t7xx_port_proxy_md_status_notify(struct port_proxy *port_prox, unsigned int state)\n{\n\tstruct t7xx_port *port;\n\tint i;\n\n\tfor_each_proxy_port(i, port, port_prox) {\n\t\tconst struct t7xx_port_conf *port_conf = port->port_conf;\n\n\t\tif (port_conf->ops->md_state_notify)\n\t\t\tport_conf->ops->md_state_notify(port, state);\n\t}\n}\n\nstatic void t7xx_proxy_init_all_ports(struct t7xx_modem *md)\n{\n\tstruct port_proxy *port_prox = md->port_prox;\n\tstruct t7xx_port *port;\n\tint i;\n\n\tfor_each_proxy_port(i, port, port_prox) {\n\t\tconst struct t7xx_port_conf *port_conf = port->port_conf;\n\n\t\tt7xx_port_struct_init(port);\n\n\t\tif (port_conf->tx_ch == PORT_CH_CONTROL_TX)\n\t\t\tmd->core_md.ctl_port = port;\n\n\t\tif (port_conf->tx_ch == PORT_CH_AP_CONTROL_TX)\n\t\t\tmd->core_ap.ctl_port = port;\n\n\t\tport->t7xx_dev = md->t7xx_dev;\n\t\tport->dev = &md->t7xx_dev->pdev->dev;\n\t\tspin_lock_init(&port->port_update_lock);\n\t\tport->chan_enable = false;\n\n\t\tif (port_conf->ops->init)\n\t\t\tport_conf->ops->init(port);\n\t}\n\n\tt7xx_proxy_setup_ch_mapping(port_prox);\n}\n\nstatic int t7xx_proxy_alloc(struct t7xx_modem *md)\n{\n\tunsigned int port_count = ARRAY_SIZE(t7xx_port_conf);\n\tstruct device *dev = &md->t7xx_dev->pdev->dev;\n\tstruct port_proxy *port_prox;\n\tint i;\n\n\tport_prox = devm_kzalloc(dev, sizeof(*port_prox) + sizeof(struct t7xx_port) * port_count,\n\t\t\t\t GFP_KERNEL);\n\tif (!port_prox)\n\t\treturn -ENOMEM;\n\n\tmd->port_prox = port_prox;\n\tport_prox->dev = dev;\n\n\tfor (i = 0; i < port_count; i++)\n\t\tport_prox->ports[i].port_conf = &t7xx_port_conf[i];\n\n\tport_prox->port_count = port_count;\n\tt7xx_proxy_init_all_ports(md);\n\treturn 0;\n}\n\n \nint t7xx_port_proxy_init(struct t7xx_modem *md)\n{\n\tint ret;\n\n\tret = t7xx_proxy_alloc(md);\n\tif (ret)\n\t\treturn ret;\n\n\tt7xx_cldma_set_recv_skb(md->md_ctrl[CLDMA_ID_AP], t7xx_port_proxy_recv_skb);\n\tt7xx_cldma_set_recv_skb(md->md_ctrl[CLDMA_ID_MD], t7xx_port_proxy_recv_skb);\n\treturn 0;\n}\n\nvoid t7xx_port_proxy_uninit(struct port_proxy *port_prox)\n{\n\tstruct t7xx_port *port;\n\tint i;\n\n\tfor_each_proxy_port(i, port, port_prox) {\n\t\tconst struct t7xx_port_conf *port_conf = port->port_conf;\n\n\t\tif (port_conf->ops->uninit)\n\t\t\tport_conf->ops->uninit(port);\n\t}\n}\n\nint t7xx_port_proxy_chl_enable_disable(struct port_proxy *port_prox, unsigned int ch_id,\n\t\t\t\t       bool en_flag)\n{\n\tstruct t7xx_port *port = t7xx_proxy_get_port_by_ch(port_prox, ch_id);\n\tconst struct t7xx_port_conf *port_conf;\n\n\tif (!port)\n\t\treturn -EINVAL;\n\n\tport_conf = port->port_conf;\n\n\tif (en_flag) {\n\t\tif (port_conf->ops->enable_chl)\n\t\t\tport_conf->ops->enable_chl(port);\n\t} else {\n\t\tif (port_conf->ops->disable_chl)\n\t\t\tport_conf->ops->disable_chl(port);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}