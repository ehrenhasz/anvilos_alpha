{
  "module_name": "t7xx_mhccif.c",
  "hash_id": "c4a8a4a10497f3e47212232492a6f0b0e00f08c13ac56d40b1b07b9e92ef64c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wwan/t7xx/t7xx_mhccif.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/completion.h>\n#include <linux/dev_printk.h>\n#include <linux/io.h>\n#include <linux/irqreturn.h>\n\n#include \"t7xx_mhccif.h\"\n#include \"t7xx_modem_ops.h\"\n#include \"t7xx_pci.h\"\n#include \"t7xx_pcie_mac.h\"\n#include \"t7xx_reg.h\"\n\n#define D2H_INT_SR_ACK\t\t(D2H_INT_SUSPEND_ACK |\t\t\\\n\t\t\t\t D2H_INT_RESUME_ACK |\t\t\\\n\t\t\t\t D2H_INT_SUSPEND_ACK_AP |\t\\\n\t\t\t\t D2H_INT_RESUME_ACK_AP)\n\nstatic void t7xx_mhccif_clear_interrupts(struct t7xx_pci_dev *t7xx_dev, u32 mask)\n{\n\tvoid __iomem *mhccif_pbase = t7xx_dev->base_addr.mhccif_rc_base;\n\n\t \n\tiowrite32(mask, mhccif_pbase + REG_EP2RC_SW_INT_ACK);\n\t \n\tt7xx_mhccif_read_sw_int_sts(t7xx_dev);\n\t \n\tt7xx_pcie_mac_clear_int_status(t7xx_dev, MHCCIF_INT);\n}\n\nstatic irqreturn_t t7xx_mhccif_isr_thread(int irq, void *data)\n{\n\tstruct t7xx_pci_dev *t7xx_dev = data;\n\tu32 int_status, val;\n\n\tval = T7XX_L1_1_BIT(1) | T7XX_L1_2_BIT(1);\n\tiowrite32(val, IREG_BASE(t7xx_dev) + DISABLE_ASPM_LOWPWR);\n\n\tint_status = t7xx_mhccif_read_sw_int_sts(t7xx_dev);\n\tif (int_status & D2H_SW_INT_MASK) {\n\t\tint ret = t7xx_pci_mhccif_isr(t7xx_dev);\n\n\t\tif (ret)\n\t\t\tdev_err(&t7xx_dev->pdev->dev, \"PCI MHCCIF ISR failure: %d\", ret);\n\t}\n\n\tt7xx_mhccif_clear_interrupts(t7xx_dev, int_status);\n\n\tif (int_status & D2H_INT_DS_LOCK_ACK)\n\t\tcomplete_all(&t7xx_dev->sleep_lock_acquire);\n\n\tif (int_status & D2H_INT_SR_ACK)\n\t\tcomplete(&t7xx_dev->pm_sr_ack);\n\n\tiowrite32(T7XX_L1_BIT(1), IREG_BASE(t7xx_dev) + ENABLE_ASPM_LOWPWR);\n\n\tint_status = t7xx_mhccif_read_sw_int_sts(t7xx_dev);\n\tif (!int_status) {\n\t\tval = T7XX_L1_1_BIT(1) | T7XX_L1_2_BIT(1);\n\t\tiowrite32(val, IREG_BASE(t7xx_dev) + ENABLE_ASPM_LOWPWR);\n\t}\n\n\tt7xx_pcie_mac_set_int(t7xx_dev, MHCCIF_INT);\n\treturn IRQ_HANDLED;\n}\n\nu32 t7xx_mhccif_read_sw_int_sts(struct t7xx_pci_dev *t7xx_dev)\n{\n\treturn ioread32(t7xx_dev->base_addr.mhccif_rc_base + REG_EP2RC_SW_INT_STS);\n}\n\nvoid t7xx_mhccif_mask_set(struct t7xx_pci_dev *t7xx_dev, u32 val)\n{\n\tiowrite32(val, t7xx_dev->base_addr.mhccif_rc_base + REG_EP2RC_SW_INT_EAP_MASK_SET);\n}\n\nvoid t7xx_mhccif_mask_clr(struct t7xx_pci_dev *t7xx_dev, u32 val)\n{\n\tiowrite32(val, t7xx_dev->base_addr.mhccif_rc_base + REG_EP2RC_SW_INT_EAP_MASK_CLR);\n}\n\nu32 t7xx_mhccif_mask_get(struct t7xx_pci_dev *t7xx_dev)\n{\n\treturn ioread32(t7xx_dev->base_addr.mhccif_rc_base + REG_EP2RC_SW_INT_EAP_MASK);\n}\n\nstatic irqreturn_t t7xx_mhccif_isr_handler(int irq, void *data)\n{\n\treturn IRQ_WAKE_THREAD;\n}\n\nvoid t7xx_mhccif_init(struct t7xx_pci_dev *t7xx_dev)\n{\n\tt7xx_dev->base_addr.mhccif_rc_base = t7xx_dev->base_addr.pcie_ext_reg_base +\n\t\t\t\t\t    MHCCIF_RC_DEV_BASE -\n\t\t\t\t\t    t7xx_dev->base_addr.pcie_dev_reg_trsl_addr;\n\n\tt7xx_dev->intr_handler[MHCCIF_INT] = t7xx_mhccif_isr_handler;\n\tt7xx_dev->intr_thread[MHCCIF_INT] = t7xx_mhccif_isr_thread;\n\tt7xx_dev->callback_param[MHCCIF_INT] = t7xx_dev;\n}\n\nvoid t7xx_mhccif_h2d_swint_trigger(struct t7xx_pci_dev *t7xx_dev, u32 channel)\n{\n\tvoid __iomem *mhccif_pbase = t7xx_dev->base_addr.mhccif_rc_base;\n\n\tiowrite32(BIT(channel), mhccif_pbase + REG_RC2EP_SW_BSY);\n\tiowrite32(channel, mhccif_pbase + REG_RC2EP_SW_TCHNUM);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}