{
  "module_name": "t7xx_hif_dpmaif.c",
  "hash_id": "47b47fbc3070690abc595a2e06f975f2414cbf9ce8b96b1b711a0684e24aa991",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wwan/t7xx/t7xx_hif_dpmaif.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/gfp.h>\n#include <linux/irqreturn.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/wait.h>\n#include <linux/workqueue.h>\n\n#include \"t7xx_dpmaif.h\"\n#include \"t7xx_hif_dpmaif.h\"\n#include \"t7xx_hif_dpmaif_rx.h\"\n#include \"t7xx_hif_dpmaif_tx.h\"\n#include \"t7xx_pci.h\"\n#include \"t7xx_pcie_mac.h\"\n#include \"t7xx_state_monitor.h\"\n\nunsigned int t7xx_ring_buf_get_next_wr_idx(unsigned int buf_len, unsigned int buf_idx)\n{\n\tbuf_idx++;\n\n\treturn buf_idx < buf_len ? buf_idx : 0;\n}\n\nunsigned int t7xx_ring_buf_rd_wr_count(unsigned int total_cnt, unsigned int rd_idx,\n\t\t\t\t       unsigned int wr_idx, enum dpmaif_rdwr rd_wr)\n{\n\tint pkt_cnt;\n\n\tif (rd_wr == DPMAIF_READ)\n\t\tpkt_cnt = wr_idx - rd_idx;\n\telse\n\t\tpkt_cnt = rd_idx - wr_idx - 1;\n\n\tif (pkt_cnt < 0)\n\t\tpkt_cnt += total_cnt;\n\n\treturn (unsigned int)pkt_cnt;\n}\n\nstatic void t7xx_dpmaif_enable_irq(struct dpmaif_ctrl *dpmaif_ctrl)\n{\n\tstruct dpmaif_isr_para *isr_para;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dpmaif_ctrl->isr_para); i++) {\n\t\tisr_para = &dpmaif_ctrl->isr_para[i];\n\t\tt7xx_pcie_mac_set_int(dpmaif_ctrl->t7xx_dev, isr_para->pcie_int);\n\t}\n}\n\nstatic void t7xx_dpmaif_disable_irq(struct dpmaif_ctrl *dpmaif_ctrl)\n{\n\tstruct dpmaif_isr_para *isr_para;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dpmaif_ctrl->isr_para); i++) {\n\t\tisr_para = &dpmaif_ctrl->isr_para[i];\n\t\tt7xx_pcie_mac_clear_int(dpmaif_ctrl->t7xx_dev, isr_para->pcie_int);\n\t}\n}\n\nstatic void t7xx_dpmaif_irq_cb(struct dpmaif_isr_para *isr_para)\n{\n\tstruct dpmaif_ctrl *dpmaif_ctrl = isr_para->dpmaif_ctrl;\n\tstruct dpmaif_hw_intr_st_para intr_status;\n\tstruct device *dev = dpmaif_ctrl->dev;\n\tstruct dpmaif_hw_info *hw_info;\n\tint i;\n\n\tmemset(&intr_status, 0, sizeof(intr_status));\n\thw_info = &dpmaif_ctrl->hw_info;\n\n\tif (t7xx_dpmaif_hw_get_intr_cnt(hw_info, &intr_status, isr_para->dlq_id) < 0) {\n\t\tdev_err(dev, \"Failed to get HW interrupt count\\n\");\n\t\treturn;\n\t}\n\n\tt7xx_pcie_mac_clear_int_status(dpmaif_ctrl->t7xx_dev, isr_para->pcie_int);\n\n\tfor (i = 0; i < intr_status.intr_cnt; i++) {\n\t\tswitch (intr_status.intr_types[i]) {\n\t\tcase DPF_INTR_UL_DONE:\n\t\t\tt7xx_dpmaif_irq_tx_done(dpmaif_ctrl, intr_status.intr_queues[i]);\n\t\t\tbreak;\n\n\t\tcase DPF_INTR_UL_DRB_EMPTY:\n\t\tcase DPF_INTR_UL_MD_NOTREADY:\n\t\tcase DPF_INTR_UL_MD_PWR_NOTREADY:\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase DPF_INTR_DL_BATCNT_LEN_ERR:\n\t\t\tdev_err_ratelimited(dev, \"DL interrupt: packet BAT count length error\\n\");\n\t\t\tt7xx_dpmaif_dl_unmask_batcnt_len_err_intr(hw_info);\n\t\t\tbreak;\n\n\t\tcase DPF_INTR_DL_PITCNT_LEN_ERR:\n\t\t\tdev_err_ratelimited(dev, \"DL interrupt: PIT count length error\\n\");\n\t\t\tt7xx_dpmaif_dl_unmask_pitcnt_len_err_intr(hw_info);\n\t\t\tbreak;\n\n\t\tcase DPF_INTR_DL_Q0_PITCNT_LEN_ERR:\n\t\t\tdev_err_ratelimited(dev, \"DL interrupt: DLQ0 PIT count length error\\n\");\n\t\t\tt7xx_dpmaif_dlq_unmask_pitcnt_len_err_intr(hw_info, DPF_RX_QNO_DFT);\n\t\t\tbreak;\n\n\t\tcase DPF_INTR_DL_Q1_PITCNT_LEN_ERR:\n\t\t\tdev_err_ratelimited(dev, \"DL interrupt: DLQ1 PIT count length error\\n\");\n\t\t\tt7xx_dpmaif_dlq_unmask_pitcnt_len_err_intr(hw_info, DPF_RX_QNO1);\n\t\t\tbreak;\n\n\t\tcase DPF_INTR_DL_DONE:\n\t\tcase DPF_INTR_DL_Q0_DONE:\n\t\tcase DPF_INTR_DL_Q1_DONE:\n\t\t\tt7xx_dpmaif_irq_rx_done(dpmaif_ctrl, intr_status.intr_queues[i]);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err_ratelimited(dev, \"DL interrupt error: unknown type : %d\\n\",\n\t\t\t\t\t    intr_status.intr_types[i]);\n\t\t}\n\t}\n}\n\nstatic irqreturn_t t7xx_dpmaif_isr_handler(int irq, void *data)\n{\n\tstruct dpmaif_isr_para *isr_para = data;\n\tstruct dpmaif_ctrl *dpmaif_ctrl;\n\n\tdpmaif_ctrl = isr_para->dpmaif_ctrl;\n\tif (dpmaif_ctrl->state != DPMAIF_STATE_PWRON) {\n\t\tdev_err(dpmaif_ctrl->dev, \"Interrupt received before initializing DPMAIF\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tt7xx_pcie_mac_clear_int(dpmaif_ctrl->t7xx_dev, isr_para->pcie_int);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t t7xx_dpmaif_isr_thread(int irq, void *data)\n{\n\tstruct dpmaif_isr_para *isr_para = data;\n\tstruct dpmaif_ctrl *dpmaif_ctrl = isr_para->dpmaif_ctrl;\n\n\tt7xx_dpmaif_irq_cb(isr_para);\n\tt7xx_pcie_mac_set_int(dpmaif_ctrl->t7xx_dev, isr_para->pcie_int);\n\treturn IRQ_HANDLED;\n}\n\nstatic void t7xx_dpmaif_isr_parameter_init(struct dpmaif_ctrl *dpmaif_ctrl)\n{\n\tstruct dpmaif_isr_para *isr_para;\n\tunsigned char i;\n\n\tdpmaif_ctrl->rxq_int_mapping[DPF_RX_QNO0] = DPMAIF_INT;\n\tdpmaif_ctrl->rxq_int_mapping[DPF_RX_QNO1] = DPMAIF2_INT;\n\n\tfor (i = 0; i < DPMAIF_RXQ_NUM; i++) {\n\t\tisr_para = &dpmaif_ctrl->isr_para[i];\n\t\tisr_para->dpmaif_ctrl = dpmaif_ctrl;\n\t\tisr_para->dlq_id = i;\n\t\tisr_para->pcie_int = dpmaif_ctrl->rxq_int_mapping[i];\n\t}\n}\n\nstatic void t7xx_dpmaif_register_pcie_irq(struct dpmaif_ctrl *dpmaif_ctrl)\n{\n\tstruct t7xx_pci_dev *t7xx_dev = dpmaif_ctrl->t7xx_dev;\n\tstruct dpmaif_isr_para *isr_para;\n\tenum t7xx_int int_type;\n\tint i;\n\n\tt7xx_dpmaif_isr_parameter_init(dpmaif_ctrl);\n\n\tfor (i = 0; i < DPMAIF_RXQ_NUM; i++) {\n\t\tisr_para = &dpmaif_ctrl->isr_para[i];\n\t\tint_type = isr_para->pcie_int;\n\t\tt7xx_pcie_mac_clear_int(t7xx_dev, int_type);\n\n\t\tt7xx_dev->intr_handler[int_type] = t7xx_dpmaif_isr_handler;\n\t\tt7xx_dev->intr_thread[int_type] = t7xx_dpmaif_isr_thread;\n\t\tt7xx_dev->callback_param[int_type] = isr_para;\n\n\t\tt7xx_pcie_mac_clear_int_status(t7xx_dev, int_type);\n\t\tt7xx_pcie_mac_set_int(t7xx_dev, int_type);\n\t}\n}\n\nstatic int t7xx_dpmaif_rxtx_sw_allocs(struct dpmaif_ctrl *dpmaif_ctrl)\n{\n\tstruct dpmaif_rx_queue *rx_q;\n\tstruct dpmaif_tx_queue *tx_q;\n\tint ret, rx_idx, tx_idx, i;\n\n\tret = t7xx_dpmaif_bat_alloc(dpmaif_ctrl, &dpmaif_ctrl->bat_req, BAT_TYPE_NORMAL);\n\tif (ret) {\n\t\tdev_err(dpmaif_ctrl->dev, \"Failed to allocate normal BAT table: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = t7xx_dpmaif_bat_alloc(dpmaif_ctrl, &dpmaif_ctrl->bat_frag, BAT_TYPE_FRAG);\n\tif (ret) {\n\t\tdev_err(dpmaif_ctrl->dev, \"Failed to allocate frag BAT table: %d\\n\", ret);\n\t\tgoto err_free_normal_bat;\n\t}\n\n\tfor (rx_idx = 0; rx_idx < DPMAIF_RXQ_NUM; rx_idx++) {\n\t\trx_q = &dpmaif_ctrl->rxq[rx_idx];\n\t\trx_q->index = rx_idx;\n\t\trx_q->dpmaif_ctrl = dpmaif_ctrl;\n\t\tret = t7xx_dpmaif_rxq_init(rx_q);\n\t\tif (ret)\n\t\t\tgoto err_free_rxq;\n\t}\n\n\tfor (tx_idx = 0; tx_idx < DPMAIF_TXQ_NUM; tx_idx++) {\n\t\ttx_q = &dpmaif_ctrl->txq[tx_idx];\n\t\ttx_q->index = tx_idx;\n\t\ttx_q->dpmaif_ctrl = dpmaif_ctrl;\n\t\tret = t7xx_dpmaif_txq_init(tx_q);\n\t\tif (ret)\n\t\t\tgoto err_free_txq;\n\t}\n\n\tret = t7xx_dpmaif_tx_thread_init(dpmaif_ctrl);\n\tif (ret) {\n\t\tdev_err(dpmaif_ctrl->dev, \"Failed to start TX thread\\n\");\n\t\tgoto err_free_txq;\n\t}\n\n\tret = t7xx_dpmaif_bat_rel_wq_alloc(dpmaif_ctrl);\n\tif (ret)\n\t\tgoto err_thread_rel;\n\n\treturn 0;\n\nerr_thread_rel:\n\tt7xx_dpmaif_tx_thread_rel(dpmaif_ctrl);\n\nerr_free_txq:\n\tfor (i = 0; i < tx_idx; i++) {\n\t\ttx_q = &dpmaif_ctrl->txq[i];\n\t\tt7xx_dpmaif_txq_free(tx_q);\n\t}\n\nerr_free_rxq:\n\tfor (i = 0; i < rx_idx; i++) {\n\t\trx_q = &dpmaif_ctrl->rxq[i];\n\t\tt7xx_dpmaif_rxq_free(rx_q);\n\t}\n\n\tt7xx_dpmaif_bat_free(dpmaif_ctrl, &dpmaif_ctrl->bat_frag);\n\nerr_free_normal_bat:\n\tt7xx_dpmaif_bat_free(dpmaif_ctrl, &dpmaif_ctrl->bat_req);\n\n\treturn ret;\n}\n\nstatic void t7xx_dpmaif_sw_release(struct dpmaif_ctrl *dpmaif_ctrl)\n{\n\tstruct dpmaif_rx_queue *rx_q;\n\tstruct dpmaif_tx_queue *tx_q;\n\tint i;\n\n\tt7xx_dpmaif_tx_thread_rel(dpmaif_ctrl);\n\tt7xx_dpmaif_bat_wq_rel(dpmaif_ctrl);\n\n\tfor (i = 0; i < DPMAIF_TXQ_NUM; i++) {\n\t\ttx_q = &dpmaif_ctrl->txq[i];\n\t\tt7xx_dpmaif_txq_free(tx_q);\n\t}\n\n\tfor (i = 0; i < DPMAIF_RXQ_NUM; i++) {\n\t\trx_q = &dpmaif_ctrl->rxq[i];\n\t\tt7xx_dpmaif_rxq_free(rx_q);\n\t}\n}\n\nstatic int t7xx_dpmaif_start(struct dpmaif_ctrl *dpmaif_ctrl)\n{\n\tstruct dpmaif_hw_info *hw_info = &dpmaif_ctrl->hw_info;\n\tstruct dpmaif_hw_params hw_init_para;\n\tstruct dpmaif_rx_queue *rxq;\n\tstruct dpmaif_tx_queue *txq;\n\tunsigned int buf_cnt;\n\tint i, ret = 0;\n\n\tif (dpmaif_ctrl->state == DPMAIF_STATE_PWRON)\n\t\treturn -EFAULT;\n\n\tmemset(&hw_init_para, 0, sizeof(hw_init_para));\n\n\tfor (i = 0; i < DPMAIF_RXQ_NUM; i++) {\n\t\trxq = &dpmaif_ctrl->rxq[i];\n\t\trxq->que_started = true;\n\t\trxq->index = i;\n\t\trxq->budget = rxq->bat_req->bat_size_cnt - 1;\n\n\t\thw_init_para.pkt_bat_base_addr[i] = rxq->bat_req->bat_bus_addr;\n\t\thw_init_para.pkt_bat_size_cnt[i] = rxq->bat_req->bat_size_cnt;\n\t\thw_init_para.pit_base_addr[i] = rxq->pit_bus_addr;\n\t\thw_init_para.pit_size_cnt[i] = rxq->pit_size_cnt;\n\t\thw_init_para.frg_bat_base_addr[i] = rxq->bat_frag->bat_bus_addr;\n\t\thw_init_para.frg_bat_size_cnt[i] = rxq->bat_frag->bat_size_cnt;\n\t}\n\n\tbitmap_zero(dpmaif_ctrl->bat_req.bat_bitmap, dpmaif_ctrl->bat_req.bat_size_cnt);\n\tbuf_cnt = dpmaif_ctrl->bat_req.bat_size_cnt - 1;\n\tret = t7xx_dpmaif_rx_buf_alloc(dpmaif_ctrl, &dpmaif_ctrl->bat_req, 0, buf_cnt, true);\n\tif (ret) {\n\t\tdev_err(dpmaif_ctrl->dev, \"Failed to allocate RX buffer: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tbuf_cnt = dpmaif_ctrl->bat_frag.bat_size_cnt - 1;\n\tret = t7xx_dpmaif_rx_frag_alloc(dpmaif_ctrl, &dpmaif_ctrl->bat_frag, buf_cnt, true);\n\tif (ret) {\n\t\tdev_err(dpmaif_ctrl->dev, \"Failed to allocate frag RX buffer: %d\\n\", ret);\n\t\tgoto err_free_normal_bat;\n\t}\n\n\tfor (i = 0; i < DPMAIF_TXQ_NUM; i++) {\n\t\ttxq = &dpmaif_ctrl->txq[i];\n\t\ttxq->que_started = true;\n\n\t\thw_init_para.drb_base_addr[i] = txq->drb_bus_addr;\n\t\thw_init_para.drb_size_cnt[i] = txq->drb_size_cnt;\n\t}\n\n\tret = t7xx_dpmaif_hw_init(hw_info, &hw_init_para);\n\tif (ret) {\n\t\tdev_err(dpmaif_ctrl->dev, \"Failed to initialize DPMAIF HW: %d\\n\", ret);\n\t\tgoto err_free_frag_bat;\n\t}\n\n\tret = t7xx_dpmaif_dl_snd_hw_bat_cnt(hw_info, rxq->bat_req->bat_size_cnt - 1);\n\tif (ret)\n\t\tgoto err_free_frag_bat;\n\n\tret = t7xx_dpmaif_dl_snd_hw_frg_cnt(hw_info, rxq->bat_frag->bat_size_cnt - 1);\n\tif (ret)\n\t\tgoto err_free_frag_bat;\n\n\tt7xx_dpmaif_ul_clr_all_intr(hw_info);\n\tt7xx_dpmaif_dl_clr_all_intr(hw_info);\n\tdpmaif_ctrl->state = DPMAIF_STATE_PWRON;\n\tt7xx_dpmaif_enable_irq(dpmaif_ctrl);\n\twake_up(&dpmaif_ctrl->tx_wq);\n\treturn 0;\n\nerr_free_frag_bat:\n\tt7xx_dpmaif_bat_free(rxq->dpmaif_ctrl, rxq->bat_frag);\n\nerr_free_normal_bat:\n\tt7xx_dpmaif_bat_free(rxq->dpmaif_ctrl, rxq->bat_req);\n\n\treturn ret;\n}\n\nstatic void t7xx_dpmaif_stop_sw(struct dpmaif_ctrl *dpmaif_ctrl)\n{\n\tt7xx_dpmaif_tx_stop(dpmaif_ctrl);\n\tt7xx_dpmaif_rx_stop(dpmaif_ctrl);\n}\n\nstatic void t7xx_dpmaif_stop_hw(struct dpmaif_ctrl *dpmaif_ctrl)\n{\n\tt7xx_dpmaif_hw_stop_all_txq(&dpmaif_ctrl->hw_info);\n\tt7xx_dpmaif_hw_stop_all_rxq(&dpmaif_ctrl->hw_info);\n}\n\nstatic int t7xx_dpmaif_stop(struct dpmaif_ctrl *dpmaif_ctrl)\n{\n\tif (!dpmaif_ctrl->dpmaif_sw_init_done) {\n\t\tdev_err(dpmaif_ctrl->dev, \"dpmaif SW init fail\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (dpmaif_ctrl->state == DPMAIF_STATE_PWROFF)\n\t\treturn -EFAULT;\n\n\tt7xx_dpmaif_disable_irq(dpmaif_ctrl);\n\tdpmaif_ctrl->state = DPMAIF_STATE_PWROFF;\n\tt7xx_dpmaif_stop_sw(dpmaif_ctrl);\n\tt7xx_dpmaif_tx_clear(dpmaif_ctrl);\n\tt7xx_dpmaif_rx_clear(dpmaif_ctrl);\n\treturn 0;\n}\n\nstatic int t7xx_dpmaif_suspend(struct t7xx_pci_dev *t7xx_dev, void *param)\n{\n\tstruct dpmaif_ctrl *dpmaif_ctrl = param;\n\n\tt7xx_dpmaif_tx_stop(dpmaif_ctrl);\n\tt7xx_dpmaif_hw_stop_all_txq(&dpmaif_ctrl->hw_info);\n\tt7xx_dpmaif_hw_stop_all_rxq(&dpmaif_ctrl->hw_info);\n\tt7xx_dpmaif_disable_irq(dpmaif_ctrl);\n\tt7xx_dpmaif_rx_stop(dpmaif_ctrl);\n\treturn 0;\n}\n\nstatic void t7xx_dpmaif_unmask_dlq_intr(struct dpmaif_ctrl *dpmaif_ctrl)\n{\n\tint qno;\n\n\tfor (qno = 0; qno < DPMAIF_RXQ_NUM; qno++)\n\t\tt7xx_dpmaif_dlq_unmask_rx_done(&dpmaif_ctrl->hw_info, qno);\n}\n\nstatic void t7xx_dpmaif_start_txrx_qs(struct dpmaif_ctrl *dpmaif_ctrl)\n{\n\tstruct dpmaif_rx_queue *rxq;\n\tstruct dpmaif_tx_queue *txq;\n\tunsigned int que_cnt;\n\n\tfor (que_cnt = 0; que_cnt < DPMAIF_TXQ_NUM; que_cnt++) {\n\t\ttxq = &dpmaif_ctrl->txq[que_cnt];\n\t\ttxq->que_started = true;\n\t}\n\n\tfor (que_cnt = 0; que_cnt < DPMAIF_RXQ_NUM; que_cnt++) {\n\t\trxq = &dpmaif_ctrl->rxq[que_cnt];\n\t\trxq->que_started = true;\n\t}\n}\n\nstatic int t7xx_dpmaif_resume(struct t7xx_pci_dev *t7xx_dev, void *param)\n{\n\tstruct dpmaif_ctrl *dpmaif_ctrl = param;\n\n\tif (!dpmaif_ctrl)\n\t\treturn 0;\n\n\tt7xx_dpmaif_start_txrx_qs(dpmaif_ctrl);\n\tt7xx_dpmaif_enable_irq(dpmaif_ctrl);\n\tt7xx_dpmaif_unmask_dlq_intr(dpmaif_ctrl);\n\tt7xx_dpmaif_start_hw(&dpmaif_ctrl->hw_info);\n\twake_up(&dpmaif_ctrl->tx_wq);\n\treturn 0;\n}\n\nstatic int t7xx_dpmaif_pm_entity_init(struct dpmaif_ctrl *dpmaif_ctrl)\n{\n\tstruct md_pm_entity *dpmaif_pm_entity = &dpmaif_ctrl->dpmaif_pm_entity;\n\tint ret;\n\n\tINIT_LIST_HEAD(&dpmaif_pm_entity->entity);\n\tdpmaif_pm_entity->suspend = &t7xx_dpmaif_suspend;\n\tdpmaif_pm_entity->suspend_late = NULL;\n\tdpmaif_pm_entity->resume_early = NULL;\n\tdpmaif_pm_entity->resume = &t7xx_dpmaif_resume;\n\tdpmaif_pm_entity->id = PM_ENTITY_ID_DATA;\n\tdpmaif_pm_entity->entity_param = dpmaif_ctrl;\n\n\tret = t7xx_pci_pm_entity_register(dpmaif_ctrl->t7xx_dev, dpmaif_pm_entity);\n\tif (ret)\n\t\tdev_err(dpmaif_ctrl->dev, \"dpmaif register pm_entity fail\\n\");\n\n\treturn ret;\n}\n\nstatic int t7xx_dpmaif_pm_entity_release(struct dpmaif_ctrl *dpmaif_ctrl)\n{\n\tstruct md_pm_entity *dpmaif_pm_entity = &dpmaif_ctrl->dpmaif_pm_entity;\n\tint ret;\n\n\tret = t7xx_pci_pm_entity_unregister(dpmaif_ctrl->t7xx_dev, dpmaif_pm_entity);\n\tif (ret < 0)\n\t\tdev_err(dpmaif_ctrl->dev, \"dpmaif register pm_entity fail\\n\");\n\n\treturn ret;\n}\n\nint t7xx_dpmaif_md_state_callback(struct dpmaif_ctrl *dpmaif_ctrl, enum md_state state)\n{\n\tint ret = 0;\n\n\tswitch (state) {\n\tcase MD_STATE_WAITING_FOR_HS1:\n\t\tret = t7xx_dpmaif_start(dpmaif_ctrl);\n\t\tbreak;\n\n\tcase MD_STATE_EXCEPTION:\n\t\tret = t7xx_dpmaif_stop(dpmaif_ctrl);\n\t\tbreak;\n\n\tcase MD_STATE_STOPPED:\n\t\tret = t7xx_dpmaif_stop(dpmaif_ctrl);\n\t\tbreak;\n\n\tcase MD_STATE_WAITING_TO_STOP:\n\t\tt7xx_dpmaif_stop_hw(dpmaif_ctrl);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstruct dpmaif_ctrl *t7xx_dpmaif_hif_init(struct t7xx_pci_dev *t7xx_dev,\n\t\t\t\t\t struct dpmaif_callbacks *callbacks)\n{\n\tstruct device *dev = &t7xx_dev->pdev->dev;\n\tstruct dpmaif_ctrl *dpmaif_ctrl;\n\tint ret;\n\n\tif (!callbacks)\n\t\treturn NULL;\n\n\tdpmaif_ctrl = devm_kzalloc(dev, sizeof(*dpmaif_ctrl), GFP_KERNEL);\n\tif (!dpmaif_ctrl)\n\t\treturn NULL;\n\n\tdpmaif_ctrl->t7xx_dev = t7xx_dev;\n\tdpmaif_ctrl->callbacks = callbacks;\n\tdpmaif_ctrl->dev = dev;\n\tdpmaif_ctrl->dpmaif_sw_init_done = false;\n\tdpmaif_ctrl->hw_info.dev = dev;\n\tdpmaif_ctrl->hw_info.pcie_base = t7xx_dev->base_addr.pcie_ext_reg_base -\n\t\t\t\t\t t7xx_dev->base_addr.pcie_dev_reg_trsl_addr;\n\n\tret = t7xx_dpmaif_pm_entity_init(dpmaif_ctrl);\n\tif (ret)\n\t\treturn NULL;\n\n\tt7xx_dpmaif_register_pcie_irq(dpmaif_ctrl);\n\tt7xx_dpmaif_disable_irq(dpmaif_ctrl);\n\n\tret = t7xx_dpmaif_rxtx_sw_allocs(dpmaif_ctrl);\n\tif (ret) {\n\t\tt7xx_dpmaif_pm_entity_release(dpmaif_ctrl);\n\t\tdev_err(dev, \"Failed to allocate RX/TX SW resources: %d\\n\", ret);\n\t\treturn NULL;\n\t}\n\n\tdpmaif_ctrl->dpmaif_sw_init_done = true;\n\treturn dpmaif_ctrl;\n}\n\nvoid t7xx_dpmaif_hif_exit(struct dpmaif_ctrl *dpmaif_ctrl)\n{\n\tif (dpmaif_ctrl->dpmaif_sw_init_done) {\n\t\tt7xx_dpmaif_stop(dpmaif_ctrl);\n\t\tt7xx_dpmaif_pm_entity_release(dpmaif_ctrl);\n\t\tt7xx_dpmaif_sw_release(dpmaif_ctrl);\n\t\tdpmaif_ctrl->dpmaif_sw_init_done = false;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}