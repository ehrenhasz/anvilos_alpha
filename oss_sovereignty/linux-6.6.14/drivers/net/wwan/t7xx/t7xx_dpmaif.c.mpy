{
  "module_name": "t7xx_dpmaif.c",
  "hash_id": "191dea39bd7c84c446772103ead4e892e8cc5e44943c9bd6cc70d825d9d8235b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wwan/t7xx/t7xx_dpmaif.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/dev_printk.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/types.h>\n\n#include \"t7xx_dpmaif.h\"\n#include \"t7xx_reg.h\"\n\n#define ioread32_poll_timeout_atomic(addr, val, cond, delay_us, timeout_us) \\\n\treadx_poll_timeout_atomic(ioread32, addr, val, cond, delay_us, timeout_us)\n\nstatic int t7xx_dpmaif_init_intr(struct dpmaif_hw_info *hw_info)\n{\n\tstruct dpmaif_isr_en_mask *isr_en_msk = &hw_info->isr_en_mask;\n\tu32 value, ul_intr_enable, dl_intr_enable;\n\tint ret;\n\n\tul_intr_enable = DP_UL_INT_ERR_MSK | DP_UL_INT_QDONE_MSK;\n\tisr_en_msk->ap_ul_l2intr_en_msk = ul_intr_enable;\n\tiowrite32(DPMAIF_AP_ALL_L2TISAR0_MASK, hw_info->pcie_base + DPMAIF_AP_L2TISAR0);\n\n\t \n\tiowrite32(ul_intr_enable, hw_info->pcie_base + DPMAIF_AO_UL_AP_L2TIMCR0);\n\tiowrite32(~ul_intr_enable, hw_info->pcie_base + DPMAIF_AO_UL_AP_L2TIMSR0);\n\n\t \n\tret = ioread32_poll_timeout_atomic(hw_info->pcie_base + DPMAIF_AO_UL_AP_L2TIMR0,\n\t\t\t\t\t   value, (value & ul_intr_enable) != ul_intr_enable, 0,\n\t\t\t\t\t   DPMAIF_CHECK_INIT_TIMEOUT_US);\n\tif (ret)\n\t\treturn ret;\n\n\tdl_intr_enable = DP_DL_INT_PITCNT_LEN_ERR | DP_DL_INT_BATCNT_LEN_ERR;\n\tisr_en_msk->ap_dl_l2intr_err_en_msk = dl_intr_enable;\n\tul_intr_enable = DPMAIF_DL_INT_DLQ0_QDONE | DPMAIF_DL_INT_DLQ0_PITCNT_LEN |\n\t\t    DPMAIF_DL_INT_DLQ1_QDONE | DPMAIF_DL_INT_DLQ1_PITCNT_LEN;\n\tisr_en_msk->ap_ul_l2intr_en_msk = ul_intr_enable;\n\tiowrite32(DPMAIF_AP_APDL_ALL_L2TISAR0_MASK, hw_info->pcie_base + DPMAIF_AP_APDL_L2TISAR0);\n\n\t \n\tiowrite32(~ul_intr_enable, hw_info->pcie_base + DPMAIF_AO_UL_APDL_L2TIMSR0);\n\tret = ioread32_poll_timeout_atomic(hw_info->pcie_base + DPMAIF_AO_UL_APDL_L2TIMR0,\n\t\t\t\t\t   value, (value & ul_intr_enable) != ul_intr_enable, 0,\n\t\t\t\t\t   DPMAIF_CHECK_INIT_TIMEOUT_US);\n\tif (ret)\n\t\treturn ret;\n\n\tisr_en_msk->ap_udl_ip_busy_en_msk = DPMAIF_UDL_IP_BUSY;\n\tiowrite32(DPMAIF_AP_IP_BUSY_MASK, hw_info->pcie_base + DPMAIF_AP_IP_BUSY);\n\tiowrite32(isr_en_msk->ap_udl_ip_busy_en_msk,\n\t\t  hw_info->pcie_base + DPMAIF_AO_AP_DLUL_IP_BUSY_MASK);\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_AO_UL_AP_L1TIMR0);\n\tvalue |= DPMAIF_DL_INT_Q2APTOP | DPMAIF_DL_INT_Q2TOQ1;\n\tiowrite32(value, hw_info->pcie_base + DPMAIF_AO_UL_AP_L1TIMR0);\n\tiowrite32(DPMA_HPC_ALL_INT_MASK, hw_info->pcie_base + DPMAIF_HPC_INTR_MASK);\n\n\treturn 0;\n}\n\nstatic void t7xx_dpmaif_mask_ulq_intr(struct dpmaif_hw_info *hw_info, unsigned int q_num)\n{\n\tstruct dpmaif_isr_en_mask *isr_en_msk;\n\tu32 value, ul_int_que_done;\n\tint ret;\n\n\tisr_en_msk = &hw_info->isr_en_mask;\n\tul_int_que_done = BIT(q_num + DP_UL_INT_DONE_OFFSET) & DP_UL_INT_QDONE_MSK;\n\tisr_en_msk->ap_ul_l2intr_en_msk &= ~ul_int_que_done;\n\tiowrite32(ul_int_que_done, hw_info->pcie_base + DPMAIF_AO_UL_AP_L2TIMSR0);\n\n\tret = ioread32_poll_timeout_atomic(hw_info->pcie_base + DPMAIF_AO_UL_AP_L2TIMR0,\n\t\t\t\t\t   value, (value & ul_int_que_done) == ul_int_que_done, 0,\n\t\t\t\t\t   DPMAIF_CHECK_TIMEOUT_US);\n\tif (ret)\n\t\tdev_err(hw_info->dev,\n\t\t\t\"Could not mask the UL interrupt. DPMAIF_AO_UL_AP_L2TIMR0 is 0x%x\\n\",\n\t\t\tvalue);\n}\n\nvoid t7xx_dpmaif_unmask_ulq_intr(struct dpmaif_hw_info *hw_info, unsigned int q_num)\n{\n\tstruct dpmaif_isr_en_mask *isr_en_msk;\n\tu32 value, ul_int_que_done;\n\tint ret;\n\n\tisr_en_msk = &hw_info->isr_en_mask;\n\tul_int_que_done = BIT(q_num + DP_UL_INT_DONE_OFFSET) & DP_UL_INT_QDONE_MSK;\n\tisr_en_msk->ap_ul_l2intr_en_msk |= ul_int_que_done;\n\tiowrite32(ul_int_que_done, hw_info->pcie_base + DPMAIF_AO_UL_AP_L2TIMCR0);\n\n\tret = ioread32_poll_timeout_atomic(hw_info->pcie_base + DPMAIF_AO_UL_AP_L2TIMR0,\n\t\t\t\t\t   value, (value & ul_int_que_done) != ul_int_que_done, 0,\n\t\t\t\t\t   DPMAIF_CHECK_TIMEOUT_US);\n\tif (ret)\n\t\tdev_err(hw_info->dev,\n\t\t\t\"Could not unmask the UL interrupt. DPMAIF_AO_UL_AP_L2TIMR0 is 0x%x\\n\",\n\t\t\tvalue);\n}\n\nvoid t7xx_dpmaif_dl_unmask_batcnt_len_err_intr(struct dpmaif_hw_info *hw_info)\n{\n\thw_info->isr_en_mask.ap_dl_l2intr_en_msk |= DP_DL_INT_BATCNT_LEN_ERR;\n\tiowrite32(DP_DL_INT_BATCNT_LEN_ERR, hw_info->pcie_base + DPMAIF_AO_UL_APDL_L2TIMCR0);\n}\n\nvoid t7xx_dpmaif_dl_unmask_pitcnt_len_err_intr(struct dpmaif_hw_info *hw_info)\n{\n\thw_info->isr_en_mask.ap_dl_l2intr_en_msk |= DP_DL_INT_PITCNT_LEN_ERR;\n\tiowrite32(DP_DL_INT_PITCNT_LEN_ERR, hw_info->pcie_base + DPMAIF_AO_UL_APDL_L2TIMCR0);\n}\n\nstatic u32 t7xx_update_dlq_intr(struct dpmaif_hw_info *hw_info, u32 q_done)\n{\n\tu32 value;\n\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_AO_UL_AP_L2TIMR0);\n\tiowrite32(q_done, hw_info->pcie_base + DPMAIF_AO_UL_APDL_L2TIMSR0);\n\treturn value;\n}\n\nstatic int t7xx_mask_dlq_intr(struct dpmaif_hw_info *hw_info, unsigned int qno)\n{\n\tu32 value, q_done;\n\tint ret;\n\n\tq_done = qno == DPF_RX_QNO0 ? DPMAIF_DL_INT_DLQ0_QDONE : DPMAIF_DL_INT_DLQ1_QDONE;\n\tiowrite32(q_done, hw_info->pcie_base + DPMAIF_AO_UL_APDL_L2TIMSR0);\n\n\tret = read_poll_timeout_atomic(t7xx_update_dlq_intr, value, value & q_done,\n\t\t\t\t       0, DPMAIF_CHECK_TIMEOUT_US, false, hw_info, q_done);\n\tif (ret) {\n\t\tdev_err(hw_info->dev,\n\t\t\t\"Could not mask the DL interrupt. DPMAIF_AO_UL_AP_L2TIMR0 is 0x%x\\n\",\n\t\t\tvalue);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\thw_info->isr_en_mask.ap_dl_l2intr_en_msk &= ~q_done;\n\treturn 0;\n}\n\nvoid t7xx_dpmaif_dlq_unmask_rx_done(struct dpmaif_hw_info *hw_info, unsigned int qno)\n{\n\tu32 mask;\n\n\tmask = qno == DPF_RX_QNO0 ? DPMAIF_DL_INT_DLQ0_QDONE : DPMAIF_DL_INT_DLQ1_QDONE;\n\tiowrite32(mask, hw_info->pcie_base + DPMAIF_AO_UL_APDL_L2TIMCR0);\n\thw_info->isr_en_mask.ap_dl_l2intr_en_msk |= mask;\n}\n\nvoid t7xx_dpmaif_clr_ip_busy_sts(struct dpmaif_hw_info *hw_info)\n{\n\tu32 ip_busy_sts;\n\n\tip_busy_sts = ioread32(hw_info->pcie_base + DPMAIF_AP_IP_BUSY);\n\tiowrite32(ip_busy_sts, hw_info->pcie_base + DPMAIF_AP_IP_BUSY);\n}\n\nstatic void t7xx_dpmaif_dlq_mask_rx_pitcnt_len_err_intr(struct dpmaif_hw_info *hw_info,\n\t\t\t\t\t\t\tunsigned int qno)\n{\n\tif (qno == DPF_RX_QNO0)\n\t\tiowrite32(DPMAIF_DL_INT_DLQ0_PITCNT_LEN,\n\t\t\t  hw_info->pcie_base + DPMAIF_AO_UL_APDL_L2TIMSR0);\n\telse\n\t\tiowrite32(DPMAIF_DL_INT_DLQ1_PITCNT_LEN,\n\t\t\t  hw_info->pcie_base + DPMAIF_AO_UL_APDL_L2TIMSR0);\n}\n\nvoid t7xx_dpmaif_dlq_unmask_pitcnt_len_err_intr(struct dpmaif_hw_info *hw_info,\n\t\t\t\t\t\tunsigned int qno)\n{\n\tif (qno == DPF_RX_QNO0)\n\t\tiowrite32(DPMAIF_DL_INT_DLQ0_PITCNT_LEN,\n\t\t\t  hw_info->pcie_base + DPMAIF_AO_UL_APDL_L2TIMCR0);\n\telse\n\t\tiowrite32(DPMAIF_DL_INT_DLQ1_PITCNT_LEN,\n\t\t\t  hw_info->pcie_base + DPMAIF_AO_UL_APDL_L2TIMCR0);\n}\n\nvoid t7xx_dpmaif_ul_clr_all_intr(struct dpmaif_hw_info *hw_info)\n{\n\tiowrite32(DPMAIF_AP_ALL_L2TISAR0_MASK, hw_info->pcie_base + DPMAIF_AP_L2TISAR0);\n}\n\nvoid t7xx_dpmaif_dl_clr_all_intr(struct dpmaif_hw_info *hw_info)\n{\n\tiowrite32(DPMAIF_AP_APDL_ALL_L2TISAR0_MASK, hw_info->pcie_base + DPMAIF_AP_APDL_L2TISAR0);\n}\n\nstatic void t7xx_dpmaif_set_intr_para(struct dpmaif_hw_intr_st_para *para,\n\t\t\t\t      enum dpmaif_hw_intr_type intr_type, unsigned int intr_queue)\n{\n\tpara->intr_types[para->intr_cnt] = intr_type;\n\tpara->intr_queues[para->intr_cnt] = intr_queue;\n\tpara->intr_cnt++;\n}\n\n \nstatic void t7xx_dpmaif_hw_check_tx_intr(struct dpmaif_hw_info *hw_info,\n\t\t\t\t\t unsigned int intr_status,\n\t\t\t\t\t struct dpmaif_hw_intr_st_para *para)\n{\n\tunsigned long value;\n\n\tvalue = FIELD_GET(DP_UL_INT_QDONE_MSK, intr_status);\n\tif (value) {\n\t\tunsigned int index;\n\n\t\tt7xx_dpmaif_set_intr_para(para, DPF_INTR_UL_DONE, value);\n\n\t\tfor_each_set_bit(index, &value, DPMAIF_TXQ_NUM)\n\t\t\tt7xx_dpmaif_mask_ulq_intr(hw_info, index);\n\t}\n\n\tvalue = FIELD_GET(DP_UL_INT_EMPTY_MSK, intr_status);\n\tif (value)\n\t\tt7xx_dpmaif_set_intr_para(para, DPF_INTR_UL_DRB_EMPTY, value);\n\n\tvalue = FIELD_GET(DP_UL_INT_MD_NOTREADY_MSK, intr_status);\n\tif (value)\n\t\tt7xx_dpmaif_set_intr_para(para, DPF_INTR_UL_MD_NOTREADY, value);\n\n\tvalue = FIELD_GET(DP_UL_INT_MD_PWR_NOTREADY_MSK, intr_status);\n\tif (value)\n\t\tt7xx_dpmaif_set_intr_para(para, DPF_INTR_UL_MD_PWR_NOTREADY, value);\n\n\tvalue = FIELD_GET(DP_UL_INT_ERR_MSK, intr_status);\n\tif (value)\n\t\tt7xx_dpmaif_set_intr_para(para, DPF_INTR_UL_LEN_ERR, value);\n\n\t \n\tiowrite32(intr_status, hw_info->pcie_base + DPMAIF_AP_L2TISAR0);\n}\n\n \nstatic void t7xx_dpmaif_hw_check_rx_intr(struct dpmaif_hw_info *hw_info,\n\t\t\t\t\t unsigned int intr_status,\n\t\t\t\t\t struct dpmaif_hw_intr_st_para *para, int qno)\n{\n\tif (qno == DPF_RX_QNO_DFT) {\n\t\tif (intr_status & DP_DL_INT_SKB_LEN_ERR)\n\t\t\tt7xx_dpmaif_set_intr_para(para, DPF_INTR_DL_SKB_LEN_ERR, DPF_RX_QNO_DFT);\n\n\t\tif (intr_status & DP_DL_INT_BATCNT_LEN_ERR) {\n\t\t\tt7xx_dpmaif_set_intr_para(para, DPF_INTR_DL_BATCNT_LEN_ERR, DPF_RX_QNO_DFT);\n\t\t\thw_info->isr_en_mask.ap_dl_l2intr_en_msk &= ~DP_DL_INT_BATCNT_LEN_ERR;\n\t\t\tiowrite32(DP_DL_INT_BATCNT_LEN_ERR,\n\t\t\t\t  hw_info->pcie_base + DPMAIF_AO_UL_APDL_L2TIMSR0);\n\t\t}\n\n\t\tif (intr_status & DP_DL_INT_PITCNT_LEN_ERR) {\n\t\t\tt7xx_dpmaif_set_intr_para(para, DPF_INTR_DL_PITCNT_LEN_ERR, DPF_RX_QNO_DFT);\n\t\t\thw_info->isr_en_mask.ap_dl_l2intr_en_msk &= ~DP_DL_INT_PITCNT_LEN_ERR;\n\t\t\tiowrite32(DP_DL_INT_PITCNT_LEN_ERR,\n\t\t\t\t  hw_info->pcie_base + DPMAIF_AO_UL_APDL_L2TIMSR0);\n\t\t}\n\n\t\tif (intr_status & DP_DL_INT_PKT_EMPTY_MSK)\n\t\t\tt7xx_dpmaif_set_intr_para(para, DPF_INTR_DL_PKT_EMPTY_SET, DPF_RX_QNO_DFT);\n\n\t\tif (intr_status & DP_DL_INT_FRG_EMPTY_MSK)\n\t\t\tt7xx_dpmaif_set_intr_para(para, DPF_INTR_DL_FRG_EMPTY_SET, DPF_RX_QNO_DFT);\n\n\t\tif (intr_status & DP_DL_INT_MTU_ERR_MSK)\n\t\t\tt7xx_dpmaif_set_intr_para(para, DPF_INTR_DL_MTU_ERR, DPF_RX_QNO_DFT);\n\n\t\tif (intr_status & DP_DL_INT_FRG_LEN_ERR_MSK)\n\t\t\tt7xx_dpmaif_set_intr_para(para, DPF_INTR_DL_FRGCNT_LEN_ERR, DPF_RX_QNO_DFT);\n\n\t\tif (intr_status & DP_DL_INT_Q0_PITCNT_LEN_ERR) {\n\t\t\tt7xx_dpmaif_set_intr_para(para, DPF_INTR_DL_Q0_PITCNT_LEN_ERR, BIT(qno));\n\t\t\tt7xx_dpmaif_dlq_mask_rx_pitcnt_len_err_intr(hw_info, qno);\n\t\t}\n\n\t\tif (intr_status & DP_DL_INT_HPC_ENT_TYPE_ERR)\n\t\t\tt7xx_dpmaif_set_intr_para(para, DPF_INTR_DL_HPC_ENT_TYPE_ERR,\n\t\t\t\t\t\t  DPF_RX_QNO_DFT);\n\n\t\tif (intr_status & DP_DL_INT_Q0_DONE) {\n\t\t\t \n\t\t\tif (!t7xx_mask_dlq_intr(hw_info, qno))\n\t\t\t\tt7xx_dpmaif_set_intr_para(para, DPF_INTR_DL_Q0_DONE, BIT(qno));\n\t\t\telse\n\t\t\t\tintr_status &= ~DP_DL_INT_Q0_DONE;\n\t\t}\n\t} else {\n\t\tif (intr_status & DP_DL_INT_Q1_PITCNT_LEN_ERR) {\n\t\t\tt7xx_dpmaif_set_intr_para(para, DPF_INTR_DL_Q1_PITCNT_LEN_ERR, BIT(qno));\n\t\t\tt7xx_dpmaif_dlq_mask_rx_pitcnt_len_err_intr(hw_info, qno);\n\t\t}\n\n\t\tif (intr_status & DP_DL_INT_Q1_DONE) {\n\t\t\tif (!t7xx_mask_dlq_intr(hw_info, qno))\n\t\t\t\tt7xx_dpmaif_set_intr_para(para, DPF_INTR_DL_Q1_DONE, BIT(qno));\n\t\t\telse\n\t\t\t\tintr_status &= ~DP_DL_INT_Q1_DONE;\n\t\t}\n\t}\n\n\tintr_status |= DP_DL_INT_BATCNT_LEN_ERR;\n\t \n\tiowrite32(intr_status, hw_info->pcie_base + DPMAIF_AP_APDL_L2TISAR0);\n}\n\n \nint t7xx_dpmaif_hw_get_intr_cnt(struct dpmaif_hw_info *hw_info,\n\t\t\t\tstruct dpmaif_hw_intr_st_para *para, int qno)\n{\n\tu32 rx_intr_status, tx_intr_status = 0;\n\tu32 rx_intr_qdone, tx_intr_qdone = 0;\n\n\trx_intr_status = ioread32(hw_info->pcie_base + DPMAIF_AP_APDL_L2TISAR0);\n\trx_intr_qdone = ioread32(hw_info->pcie_base + DPMAIF_AO_UL_APDL_L2TIMR0);\n\n\t \n\tif (qno == DPF_RX_QNO_DFT) {\n\t\t \n\t\ttx_intr_status = ioread32(hw_info->pcie_base + DPMAIF_AP_L2TISAR0);\n\t\ttx_intr_qdone = ioread32(hw_info->pcie_base + DPMAIF_AO_UL_AP_L2TIMR0);\n\t}\n\n\tt7xx_dpmaif_clr_ip_busy_sts(hw_info);\n\n\tif (qno == DPF_RX_QNO_DFT) {\n\t\t \n\t\ttx_intr_status &= ~tx_intr_qdone;\n\t\tif (tx_intr_status)\n\t\t\tt7xx_dpmaif_hw_check_tx_intr(hw_info, tx_intr_status, para);\n\t}\n\n\tif (rx_intr_status) {\n\t\tif (qno == DPF_RX_QNO0) {\n\t\t\trx_intr_status &= DP_DL_Q0_STATUS_MASK;\n\t\t\tif (rx_intr_qdone & DPMAIF_DL_INT_DLQ0_QDONE)\n\t\t\t\t \n\t\t\t\trx_intr_status &= ~DP_DL_INT_Q0_DONE;\n\t\t} else {\n\t\t\trx_intr_status &= DP_DL_Q1_STATUS_MASK;\n\t\t\tif (rx_intr_qdone & DPMAIF_DL_INT_DLQ1_QDONE)\n\t\t\t\trx_intr_status &= ~DP_DL_INT_Q1_DONE;\n\t\t}\n\n\t\tif (rx_intr_status)\n\t\t\tt7xx_dpmaif_hw_check_rx_intr(hw_info, rx_intr_status, para, qno);\n\t}\n\n\treturn para->intr_cnt;\n}\n\nstatic int t7xx_dpmaif_sram_init(struct dpmaif_hw_info *hw_info)\n{\n\tu32 value;\n\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_AP_MEM_CLR);\n\tvalue |= DPMAIF_MEM_CLR;\n\tiowrite32(value, hw_info->pcie_base + DPMAIF_AP_MEM_CLR);\n\n\treturn ioread32_poll_timeout_atomic(hw_info->pcie_base + DPMAIF_AP_MEM_CLR,\n\t\t\t\t\t    value, !(value & DPMAIF_MEM_CLR), 0,\n\t\t\t\t\t    DPMAIF_CHECK_INIT_TIMEOUT_US);\n}\n\nstatic void t7xx_dpmaif_hw_reset(struct dpmaif_hw_info *hw_info)\n{\n\tiowrite32(DPMAIF_AP_AO_RST_BIT, hw_info->pcie_base + DPMAIF_AP_AO_RGU_ASSERT);\n\tudelay(2);\n\tiowrite32(DPMAIF_AP_RST_BIT, hw_info->pcie_base + DPMAIF_AP_RGU_ASSERT);\n\tudelay(2);\n\tiowrite32(DPMAIF_AP_AO_RST_BIT, hw_info->pcie_base + DPMAIF_AP_AO_RGU_DEASSERT);\n\tudelay(2);\n\tiowrite32(DPMAIF_AP_RST_BIT, hw_info->pcie_base + DPMAIF_AP_RGU_DEASSERT);\n\tudelay(2);\n}\n\nstatic int t7xx_dpmaif_hw_config(struct dpmaif_hw_info *hw_info)\n{\n\tu32 ap_port_mode;\n\tint ret;\n\n\tt7xx_dpmaif_hw_reset(hw_info);\n\n\tret = t7xx_dpmaif_sram_init(hw_info);\n\tif (ret)\n\t\treturn ret;\n\n\tap_port_mode = ioread32(hw_info->pcie_base + DPMAIF_AO_DL_RDY_CHK_THRES);\n\tap_port_mode |= DPMAIF_PORT_MODE_PCIE;\n\tiowrite32(ap_port_mode, hw_info->pcie_base + DPMAIF_AO_DL_RDY_CHK_THRES);\n\tiowrite32(DPMAIF_CG_EN, hw_info->pcie_base + DPMAIF_AP_CG_EN);\n\treturn 0;\n}\n\nstatic void t7xx_dpmaif_pcie_dpmaif_sign(struct dpmaif_hw_info *hw_info)\n{\n\tiowrite32(DPMAIF_PCIE_MODE_SET_VALUE, hw_info->pcie_base + DPMAIF_UL_RESERVE_AO_RW);\n}\n\nstatic void t7xx_dpmaif_dl_performance(struct dpmaif_hw_info *hw_info)\n{\n\tu32 enable_bat_cache, enable_pit_burst;\n\n\tenable_bat_cache = ioread32(hw_info->pcie_base + DPMAIF_DL_BAT_INIT_CON1);\n\tenable_bat_cache |= DPMAIF_DL_BAT_CACHE_PRI;\n\tiowrite32(enable_bat_cache, hw_info->pcie_base + DPMAIF_DL_BAT_INIT_CON1);\n\n\tenable_pit_burst = ioread32(hw_info->pcie_base + DPMAIF_AO_DL_RDY_CHK_THRES);\n\tenable_pit_burst |= DPMAIF_DL_BURST_PIT_EN;\n\tiowrite32(enable_pit_burst, hw_info->pcie_base + DPMAIF_AO_DL_RDY_CHK_THRES);\n}\n\n  \n\nstatic void t7xx_dpmaif_hw_hpc_cntl_set(struct dpmaif_hw_info *hw_info)\n{\n\tunsigned int value;\n\n\tvalue = DPMAIF_HPC_DLQ_PATH_MODE | DPMAIF_HPC_ADD_MODE_DF << 2;\n\tvalue |= DPMAIF_HASH_PRIME_DF << 4;\n\tvalue |= DPMAIF_HPC_TOTAL_NUM << 8;\n\tiowrite32(value, hw_info->pcie_base + DPMAIF_AO_DL_HPC_CNTL);\n}\n\nstatic void t7xx_dpmaif_hw_agg_cfg_set(struct dpmaif_hw_info *hw_info)\n{\n\tunsigned int value;\n\n\tvalue = DPMAIF_AGG_MAX_LEN_DF | DPMAIF_AGG_TBL_ENT_NUM_DF << 16;\n\tiowrite32(value, hw_info->pcie_base + DPMAIF_AO_DL_DLQ_AGG_CFG);\n}\n\nstatic void t7xx_dpmaif_hw_hash_bit_choose_set(struct dpmaif_hw_info *hw_info)\n{\n\tiowrite32(DPMAIF_DLQ_HASH_BIT_CHOOSE_DF,\n\t\t  hw_info->pcie_base + DPMAIF_AO_DL_DLQPIT_INIT_CON5);\n}\n\nstatic void t7xx_dpmaif_hw_mid_pit_timeout_thres_set(struct dpmaif_hw_info *hw_info)\n{\n\tiowrite32(DPMAIF_MID_TIMEOUT_THRES_DF, hw_info->pcie_base + DPMAIF_AO_DL_DLQPIT_TIMEOUT0);\n}\n\nstatic void t7xx_dpmaif_hw_dlq_timeout_thres_set(struct dpmaif_hw_info *hw_info)\n{\n\tunsigned int value, i;\n\n\t \n\tfor (i = 0; i < DPMAIF_HPC_MAX_TOTAL_NUM / 2; i++) {\n\t\tvalue = FIELD_PREP(DPMAIF_DLQ_LOW_TIMEOUT_THRES_MKS, DPMAIF_DLQ_TIMEOUT_THRES_DF);\n\t\tvalue |= FIELD_PREP(DPMAIF_DLQ_HIGH_TIMEOUT_THRES_MSK,\n\t\t\t\t    DPMAIF_DLQ_TIMEOUT_THRES_DF);\n\t\tiowrite32(value,\n\t\t\t  hw_info->pcie_base + DPMAIF_AO_DL_DLQPIT_TIMEOUT1 + sizeof(u32) * i);\n\t}\n}\n\nstatic void t7xx_dpmaif_hw_dlq_start_prs_thres_set(struct dpmaif_hw_info *hw_info)\n{\n\tiowrite32(DPMAIF_DLQ_PRS_THRES_DF, hw_info->pcie_base + DPMAIF_AO_DL_DLQPIT_TRIG_THRES);\n}\n\nstatic void t7xx_dpmaif_dl_dlq_hpc_hw_init(struct dpmaif_hw_info *hw_info)\n{\n\tt7xx_dpmaif_hw_hpc_cntl_set(hw_info);\n\tt7xx_dpmaif_hw_agg_cfg_set(hw_info);\n\tt7xx_dpmaif_hw_hash_bit_choose_set(hw_info);\n\tt7xx_dpmaif_hw_mid_pit_timeout_thres_set(hw_info);\n\tt7xx_dpmaif_hw_dlq_timeout_thres_set(hw_info);\n\tt7xx_dpmaif_hw_dlq_start_prs_thres_set(hw_info);\n}\n\nstatic int t7xx_dpmaif_dl_bat_init_done(struct dpmaif_hw_info *hw_info, bool frg_en)\n{\n\tu32 value, dl_bat_init = 0;\n\tint ret;\n\n\tif (frg_en)\n\t\tdl_bat_init = DPMAIF_DL_BAT_FRG_INIT;\n\n\tdl_bat_init |= DPMAIF_DL_BAT_INIT_ALLSET;\n\tdl_bat_init |= DPMAIF_DL_BAT_INIT_EN;\n\n\tret = ioread32_poll_timeout_atomic(hw_info->pcie_base + DPMAIF_DL_BAT_INIT,\n\t\t\t\t\t   value, !(value & DPMAIF_DL_BAT_INIT_NOT_READY), 0,\n\t\t\t\t\t   DPMAIF_CHECK_INIT_TIMEOUT_US);\n\tif (ret) {\n\t\tdev_err(hw_info->dev, \"Data plane modem DL BAT is not ready\\n\");\n\t\treturn ret;\n\t}\n\n\tiowrite32(dl_bat_init, hw_info->pcie_base + DPMAIF_DL_BAT_INIT);\n\n\tret = ioread32_poll_timeout_atomic(hw_info->pcie_base + DPMAIF_DL_BAT_INIT,\n\t\t\t\t\t   value, !(value & DPMAIF_DL_BAT_INIT_NOT_READY), 0,\n\t\t\t\t\t   DPMAIF_CHECK_INIT_TIMEOUT_US);\n\tif (ret)\n\t\tdev_err(hw_info->dev, \"Data plane modem DL BAT initialization failed\\n\");\n\n\treturn ret;\n}\n\nstatic void t7xx_dpmaif_dl_set_bat_base_addr(struct dpmaif_hw_info *hw_info,\n\t\t\t\t\t     dma_addr_t addr)\n{\n\tiowrite32(lower_32_bits(addr), hw_info->pcie_base + DPMAIF_DL_BAT_INIT_CON0);\n\tiowrite32(upper_32_bits(addr), hw_info->pcie_base + DPMAIF_DL_BAT_INIT_CON3);\n}\n\nstatic void t7xx_dpmaif_dl_set_bat_size(struct dpmaif_hw_info *hw_info, unsigned int size)\n{\n\tunsigned int value;\n\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_DL_BAT_INIT_CON1);\n\tvalue &= ~DPMAIF_BAT_SIZE_MSK;\n\tvalue |= size & DPMAIF_BAT_SIZE_MSK;\n\tiowrite32(value, hw_info->pcie_base + DPMAIF_DL_BAT_INIT_CON1);\n}\n\nstatic void t7xx_dpmaif_dl_bat_en(struct dpmaif_hw_info *hw_info, bool enable)\n{\n\tunsigned int value;\n\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_DL_BAT_INIT_CON1);\n\n\tif (enable)\n\t\tvalue |= DPMAIF_BAT_EN_MSK;\n\telse\n\t\tvalue &= ~DPMAIF_BAT_EN_MSK;\n\n\tiowrite32(value, hw_info->pcie_base + DPMAIF_DL_BAT_INIT_CON1);\n}\n\nstatic void t7xx_dpmaif_dl_set_ao_bid_maxcnt(struct dpmaif_hw_info *hw_info)\n{\n\tunsigned int value;\n\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_AO_DL_PKTINFO_CON0);\n\tvalue &= ~DPMAIF_BAT_BID_MAXCNT_MSK;\n\tvalue |= FIELD_PREP(DPMAIF_BAT_BID_MAXCNT_MSK, DPMAIF_HW_PKT_BIDCNT);\n\tiowrite32(value, hw_info->pcie_base + DPMAIF_AO_DL_PKTINFO_CON0);\n}\n\nstatic void t7xx_dpmaif_dl_set_ao_mtu(struct dpmaif_hw_info *hw_info)\n{\n\tiowrite32(DPMAIF_HW_MTU_SIZE, hw_info->pcie_base + DPMAIF_AO_DL_PKTINFO_CON1);\n}\n\nstatic void t7xx_dpmaif_dl_set_ao_pit_chknum(struct dpmaif_hw_info *hw_info)\n{\n\tunsigned int value;\n\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_AO_DL_PKTINFO_CON2);\n\tvalue &= ~DPMAIF_PIT_CHK_NUM_MSK;\n\tvalue |= FIELD_PREP(DPMAIF_PIT_CHK_NUM_MSK, DPMAIF_HW_CHK_PIT_NUM);\n\tiowrite32(value, hw_info->pcie_base + DPMAIF_AO_DL_PKTINFO_CON2);\n}\n\nstatic void t7xx_dpmaif_dl_set_ao_remain_minsz(struct dpmaif_hw_info *hw_info)\n{\n\tunsigned int value;\n\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_AO_DL_PKTINFO_CON0);\n\tvalue &= ~DPMAIF_BAT_REMAIN_MINSZ_MSK;\n\tvalue |= FIELD_PREP(DPMAIF_BAT_REMAIN_MINSZ_MSK,\n\t\t\t    DPMAIF_HW_BAT_REMAIN / DPMAIF_BAT_REMAIN_SZ_BASE);\n\tiowrite32(value, hw_info->pcie_base + DPMAIF_AO_DL_PKTINFO_CON0);\n}\n\nstatic void t7xx_dpmaif_dl_set_ao_bat_bufsz(struct dpmaif_hw_info *hw_info)\n{\n\tunsigned int value;\n\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_AO_DL_PKTINFO_CON2);\n\tvalue &= ~DPMAIF_BAT_BUF_SZ_MSK;\n\tvalue |= FIELD_PREP(DPMAIF_BAT_BUF_SZ_MSK,\n\t\t\t    DPMAIF_HW_BAT_PKTBUF / DPMAIF_BAT_BUFFER_SZ_BASE);\n\tiowrite32(value, hw_info->pcie_base + DPMAIF_AO_DL_PKTINFO_CON2);\n}\n\nstatic void t7xx_dpmaif_dl_set_ao_bat_rsv_length(struct dpmaif_hw_info *hw_info)\n{\n\tunsigned int value;\n\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_AO_DL_PKTINFO_CON2);\n\tvalue &= ~DPMAIF_BAT_RSV_LEN_MSK;\n\tvalue |= DPMAIF_HW_BAT_RSVLEN;\n\tiowrite32(value, hw_info->pcie_base + DPMAIF_AO_DL_PKTINFO_CON2);\n}\n\nstatic void t7xx_dpmaif_dl_set_pkt_alignment(struct dpmaif_hw_info *hw_info)\n{\n\tunsigned int value;\n\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_AO_DL_RDY_CHK_THRES);\n\tvalue &= ~DPMAIF_PKT_ALIGN_MSK;\n\tvalue |= DPMAIF_PKT_ALIGN_EN;\n\tiowrite32(value, hw_info->pcie_base + DPMAIF_AO_DL_RDY_CHK_THRES);\n}\n\nstatic void t7xx_dpmaif_dl_set_pkt_checksum(struct dpmaif_hw_info *hw_info)\n{\n\tunsigned int value;\n\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_AO_DL_RDY_CHK_THRES);\n\tvalue |= DPMAIF_DL_PKT_CHECKSUM_EN;\n\tiowrite32(value, hw_info->pcie_base + DPMAIF_AO_DL_RDY_CHK_THRES);\n}\n\nstatic void t7xx_dpmaif_dl_set_ao_frg_check_thres(struct dpmaif_hw_info *hw_info)\n{\n\tunsigned int value;\n\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_AO_DL_RDY_CHK_FRG_THRES);\n\tvalue &= ~DPMAIF_FRG_CHECK_THRES_MSK;\n\tvalue |= DPMAIF_HW_CHK_FRG_NUM;\n\tiowrite32(value, hw_info->pcie_base + DPMAIF_AO_DL_RDY_CHK_FRG_THRES);\n}\n\nstatic void t7xx_dpmaif_dl_set_ao_frg_bufsz(struct dpmaif_hw_info *hw_info)\n{\n\tunsigned int value;\n\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_AO_DL_RDY_CHK_FRG_THRES);\n\tvalue &= ~DPMAIF_FRG_BUF_SZ_MSK;\n\tvalue |= FIELD_PREP(DPMAIF_FRG_BUF_SZ_MSK,\n\t\t\t    DPMAIF_HW_FRG_PKTBUF / DPMAIF_FRG_BUFFER_SZ_BASE);\n\tiowrite32(value, hw_info->pcie_base + DPMAIF_AO_DL_RDY_CHK_FRG_THRES);\n}\n\nstatic void t7xx_dpmaif_dl_frg_ao_en(struct dpmaif_hw_info *hw_info, bool enable)\n{\n\tunsigned int value;\n\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_AO_DL_RDY_CHK_FRG_THRES);\n\n\tif (enable)\n\t\tvalue |= DPMAIF_FRG_EN_MSK;\n\telse\n\t\tvalue &= ~DPMAIF_FRG_EN_MSK;\n\n\tiowrite32(value, hw_info->pcie_base + DPMAIF_AO_DL_RDY_CHK_FRG_THRES);\n}\n\nstatic void t7xx_dpmaif_dl_set_ao_bat_check_thres(struct dpmaif_hw_info *hw_info)\n{\n\tunsigned int value;\n\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_AO_DL_RDY_CHK_THRES);\n\tvalue &= ~DPMAIF_BAT_CHECK_THRES_MSK;\n\tvalue |= FIELD_PREP(DPMAIF_BAT_CHECK_THRES_MSK, DPMAIF_HW_CHK_BAT_NUM);\n\tiowrite32(value, hw_info->pcie_base + DPMAIF_AO_DL_RDY_CHK_THRES);\n}\n\nstatic void t7xx_dpmaif_dl_set_pit_seqnum(struct dpmaif_hw_info *hw_info)\n{\n\tunsigned int value;\n\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_AO_DL_PIT_SEQ_END);\n\tvalue &= ~DPMAIF_DL_PIT_SEQ_MSK;\n\tvalue |= DPMAIF_DL_PIT_SEQ_VALUE;\n\tiowrite32(value, hw_info->pcie_base + DPMAIF_AO_DL_PIT_SEQ_END);\n}\n\nstatic void t7xx_dpmaif_dl_set_dlq_pit_base_addr(struct dpmaif_hw_info *hw_info,\n\t\t\t\t\t\t dma_addr_t addr)\n{\n\tiowrite32(lower_32_bits(addr), hw_info->pcie_base + DPMAIF_DL_DLQPIT_INIT_CON0);\n\tiowrite32(upper_32_bits(addr), hw_info->pcie_base + DPMAIF_DL_DLQPIT_INIT_CON4);\n}\n\nstatic void t7xx_dpmaif_dl_set_dlq_pit_size(struct dpmaif_hw_info *hw_info, unsigned int size)\n{\n\tunsigned int value;\n\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_DL_DLQPIT_INIT_CON1);\n\tvalue &= ~DPMAIF_PIT_SIZE_MSK;\n\tvalue |= size & DPMAIF_PIT_SIZE_MSK;\n\tiowrite32(value, hw_info->pcie_base + DPMAIF_DL_DLQPIT_INIT_CON1);\n\tiowrite32(0, hw_info->pcie_base + DPMAIF_DL_DLQPIT_INIT_CON2);\n\tiowrite32(0, hw_info->pcie_base + DPMAIF_DL_DLQPIT_INIT_CON3);\n\tiowrite32(0, hw_info->pcie_base + DPMAIF_DL_DLQPIT_INIT_CON5);\n\tiowrite32(0, hw_info->pcie_base + DPMAIF_DL_DLQPIT_INIT_CON6);\n}\n\nstatic void t7xx_dpmaif_dl_dlq_pit_en(struct dpmaif_hw_info *hw_info)\n{\n\tunsigned int value;\n\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_DL_DLQPIT_INIT_CON3);\n\tvalue |= DPMAIF_DLQPIT_EN_MSK;\n\tiowrite32(value, hw_info->pcie_base + DPMAIF_DL_DLQPIT_INIT_CON3);\n}\n\nstatic void t7xx_dpmaif_dl_dlq_pit_init_done(struct dpmaif_hw_info *hw_info,\n\t\t\t\t\t     unsigned int pit_idx)\n{\n\tunsigned int dl_pit_init;\n\tint timeout;\n\tu32 value;\n\n\tdl_pit_init = DPMAIF_DL_PIT_INIT_ALLSET;\n\tdl_pit_init |= (pit_idx << DPMAIF_DLQPIT_CHAN_OFS);\n\tdl_pit_init |= DPMAIF_DL_PIT_INIT_EN;\n\n\ttimeout = ioread32_poll_timeout_atomic(hw_info->pcie_base + DPMAIF_DL_DLQPIT_INIT,\n\t\t\t\t\t       value, !(value & DPMAIF_DL_PIT_INIT_NOT_READY),\n\t\t\t\t\t       DPMAIF_CHECK_DELAY_US,\n\t\t\t\t\t       DPMAIF_CHECK_INIT_TIMEOUT_US);\n\tif (timeout) {\n\t\tdev_err(hw_info->dev, \"Data plane modem DL PIT is not ready\\n\");\n\t\treturn;\n\t}\n\n\tiowrite32(dl_pit_init, hw_info->pcie_base + DPMAIF_DL_DLQPIT_INIT);\n\ttimeout = ioread32_poll_timeout_atomic(hw_info->pcie_base + DPMAIF_DL_DLQPIT_INIT,\n\t\t\t\t\t       value, !(value & DPMAIF_DL_PIT_INIT_NOT_READY),\n\t\t\t\t\t       DPMAIF_CHECK_DELAY_US,\n\t\t\t\t\t       DPMAIF_CHECK_INIT_TIMEOUT_US);\n\tif (timeout)\n\t\tdev_err(hw_info->dev, \"Data plane modem DL PIT initialization failed\\n\");\n}\n\nstatic void t7xx_dpmaif_config_dlq_pit_hw(struct dpmaif_hw_info *hw_info, unsigned int q_num,\n\t\t\t\t\t  struct dpmaif_dl *dl_que)\n{\n\tt7xx_dpmaif_dl_set_dlq_pit_base_addr(hw_info, dl_que->pit_base);\n\tt7xx_dpmaif_dl_set_dlq_pit_size(hw_info, dl_que->pit_size_cnt);\n\tt7xx_dpmaif_dl_dlq_pit_en(hw_info);\n\tt7xx_dpmaif_dl_dlq_pit_init_done(hw_info, q_num);\n}\n\nstatic void t7xx_dpmaif_config_all_dlq_hw(struct dpmaif_hw_info *hw_info)\n{\n\tint i;\n\n\tfor (i = 0; i < DPMAIF_RXQ_NUM; i++)\n\t\tt7xx_dpmaif_config_dlq_pit_hw(hw_info, i, &hw_info->dl_que[i]);\n}\n\nstatic void t7xx_dpmaif_dl_all_q_en(struct dpmaif_hw_info *hw_info, bool enable)\n{\n\tu32 dl_bat_init, value;\n\tint timeout;\n\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_DL_BAT_INIT_CON1);\n\n\tif (enable)\n\t\tvalue |= DPMAIF_BAT_EN_MSK;\n\telse\n\t\tvalue &= ~DPMAIF_BAT_EN_MSK;\n\n\tiowrite32(value, hw_info->pcie_base + DPMAIF_DL_BAT_INIT_CON1);\n\tdl_bat_init = DPMAIF_DL_BAT_INIT_ONLY_ENABLE_BIT;\n\tdl_bat_init |= DPMAIF_DL_BAT_INIT_EN;\n\n\ttimeout = ioread32_poll_timeout_atomic(hw_info->pcie_base + DPMAIF_DL_BAT_INIT,\n\t\t\t\t\t       value, !(value & DPMAIF_DL_BAT_INIT_NOT_READY), 0,\n\t\t\t\t\t       DPMAIF_CHECK_TIMEOUT_US);\n\tif (timeout)\n\t\tdev_err(hw_info->dev, \"Timeout updating BAT setting to HW\\n\");\n\n\tiowrite32(dl_bat_init, hw_info->pcie_base + DPMAIF_DL_BAT_INIT);\n\ttimeout = ioread32_poll_timeout_atomic(hw_info->pcie_base + DPMAIF_DL_BAT_INIT,\n\t\t\t\t\t       value, !(value & DPMAIF_DL_BAT_INIT_NOT_READY), 0,\n\t\t\t\t\t       DPMAIF_CHECK_TIMEOUT_US);\n\tif (timeout)\n\t\tdev_err(hw_info->dev, \"Data plane modem DL BAT is not ready\\n\");\n}\n\nstatic int t7xx_dpmaif_config_dlq_hw(struct dpmaif_hw_info *hw_info)\n{\n\tstruct dpmaif_dl *dl_que;\n\tint ret;\n\n\tt7xx_dpmaif_dl_dlq_hpc_hw_init(hw_info);\n\n\tdl_que = &hw_info->dl_que[0];  \n\tif (!dl_que->que_started)\n\t\treturn -EBUSY;\n\n\tt7xx_dpmaif_dl_set_ao_remain_minsz(hw_info);\n\tt7xx_dpmaif_dl_set_ao_bat_bufsz(hw_info);\n\tt7xx_dpmaif_dl_set_ao_frg_bufsz(hw_info);\n\tt7xx_dpmaif_dl_set_ao_bat_rsv_length(hw_info);\n\tt7xx_dpmaif_dl_set_ao_bid_maxcnt(hw_info);\n\tt7xx_dpmaif_dl_set_pkt_alignment(hw_info);\n\tt7xx_dpmaif_dl_set_pit_seqnum(hw_info);\n\tt7xx_dpmaif_dl_set_ao_mtu(hw_info);\n\tt7xx_dpmaif_dl_set_ao_pit_chknum(hw_info);\n\tt7xx_dpmaif_dl_set_ao_bat_check_thres(hw_info);\n\tt7xx_dpmaif_dl_set_ao_frg_check_thres(hw_info);\n\tt7xx_dpmaif_dl_frg_ao_en(hw_info, true);\n\n\tt7xx_dpmaif_dl_set_bat_base_addr(hw_info, dl_que->frg_base);\n\tt7xx_dpmaif_dl_set_bat_size(hw_info, dl_que->frg_size_cnt);\n\tt7xx_dpmaif_dl_bat_en(hw_info, true);\n\n\tret = t7xx_dpmaif_dl_bat_init_done(hw_info, true);\n\tif (ret)\n\t\treturn ret;\n\n\tt7xx_dpmaif_dl_set_bat_base_addr(hw_info, dl_que->bat_base);\n\tt7xx_dpmaif_dl_set_bat_size(hw_info, dl_que->bat_size_cnt);\n\tt7xx_dpmaif_dl_bat_en(hw_info, false);\n\n\tret = t7xx_dpmaif_dl_bat_init_done(hw_info, false);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tt7xx_dpmaif_config_all_dlq_hw(hw_info);\n\tt7xx_dpmaif_dl_all_q_en(hw_info, true);\n\tt7xx_dpmaif_dl_set_pkt_checksum(hw_info);\n\treturn 0;\n}\n\nstatic void t7xx_dpmaif_ul_update_drb_size(struct dpmaif_hw_info *hw_info,\n\t\t\t\t\t   unsigned int q_num, unsigned int size)\n{\n\tunsigned int value;\n\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_UL_DRBSIZE_ADDRH_n(q_num));\n\tvalue &= ~DPMAIF_DRB_SIZE_MSK;\n\tvalue |= size & DPMAIF_DRB_SIZE_MSK;\n\tiowrite32(value, hw_info->pcie_base + DPMAIF_UL_DRBSIZE_ADDRH_n(q_num));\n}\n\nstatic void t7xx_dpmaif_ul_update_drb_base_addr(struct dpmaif_hw_info *hw_info,\n\t\t\t\t\t\tunsigned int q_num, dma_addr_t addr)\n{\n\tiowrite32(lower_32_bits(addr), hw_info->pcie_base + DPMAIF_ULQSAR_n(q_num));\n\tiowrite32(upper_32_bits(addr), hw_info->pcie_base + DPMAIF_UL_DRB_ADDRH_n(q_num));\n}\n\nstatic void t7xx_dpmaif_ul_rdy_en(struct dpmaif_hw_info *hw_info,\n\t\t\t\t  unsigned int q_num, bool ready)\n{\n\tu32 value;\n\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_AO_UL_CHNL_ARB0);\n\n\tif (ready)\n\t\tvalue |= BIT(q_num);\n\telse\n\t\tvalue &= ~BIT(q_num);\n\n\tiowrite32(value, hw_info->pcie_base + DPMAIF_AO_UL_CHNL_ARB0);\n}\n\nstatic void t7xx_dpmaif_ul_arb_en(struct dpmaif_hw_info *hw_info,\n\t\t\t\t  unsigned int q_num, bool enable)\n{\n\tu32 value;\n\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_AO_UL_CHNL_ARB0);\n\n\tif (enable)\n\t\tvalue |= BIT(q_num + 8);\n\telse\n\t\tvalue &= ~BIT(q_num + 8);\n\n\tiowrite32(value, hw_info->pcie_base + DPMAIF_AO_UL_CHNL_ARB0);\n}\n\nstatic void t7xx_dpmaif_config_ulq_hw(struct dpmaif_hw_info *hw_info)\n{\n\tstruct dpmaif_ul *ul_que;\n\tint i;\n\n\tfor (i = 0; i < DPMAIF_TXQ_NUM; i++) {\n\t\tul_que = &hw_info->ul_que[i];\n\t\tif (ul_que->que_started) {\n\t\t\tt7xx_dpmaif_ul_update_drb_size(hw_info, i, ul_que->drb_size_cnt *\n\t\t\t\t\t\t       DPMAIF_UL_DRB_SIZE_WORD);\n\t\t\tt7xx_dpmaif_ul_update_drb_base_addr(hw_info, i, ul_que->drb_base);\n\t\t\tt7xx_dpmaif_ul_rdy_en(hw_info, i, true);\n\t\t\tt7xx_dpmaif_ul_arb_en(hw_info, i, true);\n\t\t} else {\n\t\t\tt7xx_dpmaif_ul_arb_en(hw_info, i, false);\n\t\t}\n\t}\n}\n\nstatic int t7xx_dpmaif_hw_init_done(struct dpmaif_hw_info *hw_info)\n{\n\tu32 ap_cfg;\n\tint ret;\n\n\tap_cfg = ioread32(hw_info->pcie_base + DPMAIF_AP_OVERWRITE_CFG);\n\tap_cfg |= DPMAIF_SRAM_SYNC;\n\tiowrite32(ap_cfg, hw_info->pcie_base + DPMAIF_AP_OVERWRITE_CFG);\n\n\tret = ioread32_poll_timeout_atomic(hw_info->pcie_base + DPMAIF_AP_OVERWRITE_CFG,\n\t\t\t\t\t   ap_cfg, !(ap_cfg & DPMAIF_SRAM_SYNC), 0,\n\t\t\t\t\t   DPMAIF_CHECK_TIMEOUT_US);\n\tif (ret)\n\t\treturn ret;\n\n\tiowrite32(DPMAIF_UL_INIT_DONE, hw_info->pcie_base + DPMAIF_AO_UL_INIT_SET);\n\tiowrite32(DPMAIF_DL_INIT_DONE, hw_info->pcie_base + DPMAIF_AO_DL_INIT_SET);\n\treturn 0;\n}\n\nstatic bool t7xx_dpmaif_dl_idle_check(struct dpmaif_hw_info *hw_info)\n{\n\tu32 dpmaif_dl_is_busy = ioread32(hw_info->pcie_base + DPMAIF_DL_CHK_BUSY);\n\n\treturn !(dpmaif_dl_is_busy & DPMAIF_DL_IDLE_STS);\n}\n\nstatic void t7xx_dpmaif_ul_all_q_en(struct dpmaif_hw_info *hw_info, bool enable)\n{\n\tu32 ul_arb_en = ioread32(hw_info->pcie_base + DPMAIF_AO_UL_CHNL_ARB0);\n\n\tif (enable)\n\t\tul_arb_en |= DPMAIF_UL_ALL_QUE_ARB_EN;\n\telse\n\t\tul_arb_en &= ~DPMAIF_UL_ALL_QUE_ARB_EN;\n\n\tiowrite32(ul_arb_en, hw_info->pcie_base + DPMAIF_AO_UL_CHNL_ARB0);\n}\n\nstatic bool t7xx_dpmaif_ul_idle_check(struct dpmaif_hw_info *hw_info)\n{\n\tu32 dpmaif_ul_is_busy = ioread32(hw_info->pcie_base + DPMAIF_UL_CHK_BUSY);\n\n\treturn !(dpmaif_ul_is_busy & DPMAIF_UL_IDLE_STS);\n}\n\nvoid t7xx_dpmaif_ul_update_hw_drb_cnt(struct dpmaif_hw_info *hw_info, unsigned int q_num,\n\t\t\t\t      unsigned int drb_entry_cnt)\n{\n\tu32 ul_update, value;\n\tint err;\n\n\tul_update = drb_entry_cnt & DPMAIF_UL_ADD_COUNT_MASK;\n\tul_update |= DPMAIF_UL_ADD_UPDATE;\n\n\terr = ioread32_poll_timeout_atomic(hw_info->pcie_base + DPMAIF_ULQ_ADD_DESC_CH_n(q_num),\n\t\t\t\t\t   value, !(value & DPMAIF_UL_ADD_NOT_READY), 0,\n\t\t\t\t\t   DPMAIF_CHECK_TIMEOUT_US);\n\tif (err) {\n\t\tdev_err(hw_info->dev, \"UL add is not ready\\n\");\n\t\treturn;\n\t}\n\n\tiowrite32(ul_update, hw_info->pcie_base + DPMAIF_ULQ_ADD_DESC_CH_n(q_num));\n\n\terr = ioread32_poll_timeout_atomic(hw_info->pcie_base + DPMAIF_ULQ_ADD_DESC_CH_n(q_num),\n\t\t\t\t\t   value, !(value & DPMAIF_UL_ADD_NOT_READY), 0,\n\t\t\t\t\t   DPMAIF_CHECK_TIMEOUT_US);\n\tif (err)\n\t\tdev_err(hw_info->dev, \"Timeout updating UL add\\n\");\n}\n\nunsigned int t7xx_dpmaif_ul_get_rd_idx(struct dpmaif_hw_info *hw_info, unsigned int q_num)\n{\n\tunsigned int value = ioread32(hw_info->pcie_base + DPMAIF_ULQ_STA0_n(q_num));\n\n\treturn FIELD_GET(DPMAIF_UL_DRB_RIDX_MSK, value) / DPMAIF_UL_DRB_SIZE_WORD;\n}\n\nint t7xx_dpmaif_dlq_add_pit_remain_cnt(struct dpmaif_hw_info *hw_info, unsigned int dlq_pit_idx,\n\t\t\t\t       unsigned int pit_remain_cnt)\n{\n\tu32 dl_update, value;\n\tint ret;\n\n\tdl_update = pit_remain_cnt & DPMAIF_PIT_REM_CNT_MSK;\n\tdl_update |= DPMAIF_DL_ADD_UPDATE | (dlq_pit_idx << DPMAIF_ADD_DLQ_PIT_CHAN_OFS);\n\n\tret = ioread32_poll_timeout_atomic(hw_info->pcie_base + DPMAIF_DL_DLQPIT_ADD,\n\t\t\t\t\t   value, !(value & DPMAIF_DL_ADD_NOT_READY), 0,\n\t\t\t\t\t   DPMAIF_CHECK_TIMEOUT_US);\n\tif (ret) {\n\t\tdev_err(hw_info->dev, \"Data plane modem is not ready to add dlq\\n\");\n\t\treturn ret;\n\t}\n\n\tiowrite32(dl_update, hw_info->pcie_base + DPMAIF_DL_DLQPIT_ADD);\n\n\tret = ioread32_poll_timeout_atomic(hw_info->pcie_base + DPMAIF_DL_DLQPIT_ADD,\n\t\t\t\t\t   value, !(value & DPMAIF_DL_ADD_NOT_READY), 0,\n\t\t\t\t\t   DPMAIF_CHECK_TIMEOUT_US);\n\tif (ret) {\n\t\tdev_err(hw_info->dev, \"Data plane modem add dlq failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nunsigned int t7xx_dpmaif_dl_dlq_pit_get_wr_idx(struct dpmaif_hw_info *hw_info,\n\t\t\t\t\t       unsigned int dlq_pit_idx)\n{\n\tu32 value;\n\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_AO_DL_DLQ_WR_IDX +\n\t\t\t dlq_pit_idx * DLQ_PIT_IDX_SIZE);\n\treturn value & DPMAIF_DL_RD_WR_IDX_MSK;\n}\n\nstatic int t7xx_dl_add_timedout(struct dpmaif_hw_info *hw_info)\n{\n\tu32 value;\n\n\treturn ioread32_poll_timeout_atomic(hw_info->pcie_base + DPMAIF_DL_BAT_ADD,\n\t\t\t\t\t   value, !(value & DPMAIF_DL_ADD_NOT_READY), 0,\n\t\t\t\t\t   DPMAIF_CHECK_TIMEOUT_US);\n}\n\nint t7xx_dpmaif_dl_snd_hw_bat_cnt(struct dpmaif_hw_info *hw_info, unsigned int bat_entry_cnt)\n{\n\tunsigned int value;\n\n\tif (t7xx_dl_add_timedout(hw_info)) {\n\t\tdev_err(hw_info->dev, \"DL add BAT not ready\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tvalue = bat_entry_cnt & DPMAIF_DL_ADD_COUNT_MASK;\n\tvalue |= DPMAIF_DL_ADD_UPDATE;\n\tiowrite32(value, hw_info->pcie_base + DPMAIF_DL_BAT_ADD);\n\n\tif (t7xx_dl_add_timedout(hw_info)) {\n\t\tdev_err(hw_info->dev, \"DL add BAT timeout\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nunsigned int t7xx_dpmaif_dl_get_bat_rd_idx(struct dpmaif_hw_info *hw_info, unsigned int q_num)\n{\n\tu32 value;\n\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_AO_DL_BAT_RD_IDX);\n\treturn value & DPMAIF_DL_RD_WR_IDX_MSK;\n}\n\nunsigned int t7xx_dpmaif_dl_get_bat_wr_idx(struct dpmaif_hw_info *hw_info, unsigned int q_num)\n{\n\tu32 value;\n\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_AO_DL_BAT_WR_IDX);\n\treturn value & DPMAIF_DL_RD_WR_IDX_MSK;\n}\n\nint t7xx_dpmaif_dl_snd_hw_frg_cnt(struct dpmaif_hw_info *hw_info, unsigned int frg_entry_cnt)\n{\n\tunsigned int value;\n\n\tif (t7xx_dl_add_timedout(hw_info)) {\n\t\tdev_err(hw_info->dev, \"Data plane modem is not ready to add frag DLQ\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tvalue = frg_entry_cnt & DPMAIF_DL_ADD_COUNT_MASK;\n\tvalue |= DPMAIF_DL_FRG_ADD_UPDATE | DPMAIF_DL_ADD_UPDATE;\n\tiowrite32(value, hw_info->pcie_base + DPMAIF_DL_BAT_ADD);\n\n\tif (t7xx_dl_add_timedout(hw_info)) {\n\t\tdev_err(hw_info->dev, \"Data plane modem add frag DLQ failed\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nunsigned int t7xx_dpmaif_dl_get_frg_rd_idx(struct dpmaif_hw_info *hw_info, unsigned int q_num)\n{\n\tu32 value;\n\n\tvalue = ioread32(hw_info->pcie_base + DPMAIF_AO_DL_FRGBAT_RD_IDX);\n\treturn value & DPMAIF_DL_RD_WR_IDX_MSK;\n}\n\nstatic void t7xx_dpmaif_set_queue_property(struct dpmaif_hw_info *hw_info,\n\t\t\t\t\t   struct dpmaif_hw_params *init_para)\n{\n\tstruct dpmaif_dl *dl_que;\n\tstruct dpmaif_ul *ul_que;\n\tint i;\n\n\tfor (i = 0; i < DPMAIF_RXQ_NUM; i++) {\n\t\tdl_que = &hw_info->dl_que[i];\n\t\tdl_que->bat_base = init_para->pkt_bat_base_addr[i];\n\t\tdl_que->bat_size_cnt = init_para->pkt_bat_size_cnt[i];\n\t\tdl_que->pit_base = init_para->pit_base_addr[i];\n\t\tdl_que->pit_size_cnt = init_para->pit_size_cnt[i];\n\t\tdl_que->frg_base = init_para->frg_bat_base_addr[i];\n\t\tdl_que->frg_size_cnt = init_para->frg_bat_size_cnt[i];\n\t\tdl_que->que_started = true;\n\t}\n\n\tfor (i = 0; i < DPMAIF_TXQ_NUM; i++) {\n\t\tul_que = &hw_info->ul_que[i];\n\t\tul_que->drb_base = init_para->drb_base_addr[i];\n\t\tul_que->drb_size_cnt = init_para->drb_size_cnt[i];\n\t\tul_que->que_started = true;\n\t}\n}\n\n \nint t7xx_dpmaif_hw_stop_all_txq(struct dpmaif_hw_info *hw_info)\n{\n\tint count = 0;\n\n\tt7xx_dpmaif_ul_all_q_en(hw_info, false);\n\twhile (t7xx_dpmaif_ul_idle_check(hw_info)) {\n\t\tif (++count >= DPMAIF_MAX_CHECK_COUNT) {\n\t\t\tdev_err(hw_info->dev, \"Failed to stop TX, status: 0x%x\\n\",\n\t\t\t\tioread32(hw_info->pcie_base + DPMAIF_UL_CHK_BUSY));\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint t7xx_dpmaif_hw_stop_all_rxq(struct dpmaif_hw_info *hw_info)\n{\n\tunsigned int wr_idx, rd_idx;\n\tint count = 0;\n\n\tt7xx_dpmaif_dl_all_q_en(hw_info, false);\n\twhile (t7xx_dpmaif_dl_idle_check(hw_info)) {\n\t\tif (++count >= DPMAIF_MAX_CHECK_COUNT) {\n\t\t\tdev_err(hw_info->dev, \"Failed to stop RX, status: 0x%x\\n\",\n\t\t\t\tioread32(hw_info->pcie_base + DPMAIF_DL_CHK_BUSY));\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\t \n\tcount = 0;\n\tdo {\n\t\twr_idx = ioread32(hw_info->pcie_base + DPMAIF_AO_DL_PIT_WR_IDX);\n\t\twr_idx &= DPMAIF_DL_RD_WR_IDX_MSK;\n\t\trd_idx = ioread32(hw_info->pcie_base + DPMAIF_AO_DL_PIT_RD_IDX);\n\t\trd_idx &= DPMAIF_DL_RD_WR_IDX_MSK;\n\n\t\tif (wr_idx == rd_idx)\n\t\t\treturn 0;\n\t} while (++count < DPMAIF_MAX_CHECK_COUNT);\n\n\tdev_err(hw_info->dev, \"Check middle PIT sync fail\\n\");\n\treturn -ETIMEDOUT;\n}\n\nvoid t7xx_dpmaif_start_hw(struct dpmaif_hw_info *hw_info)\n{\n\tt7xx_dpmaif_ul_all_q_en(hw_info, true);\n\tt7xx_dpmaif_dl_all_q_en(hw_info, true);\n}\n\n \nint t7xx_dpmaif_hw_init(struct dpmaif_hw_info *hw_info, struct dpmaif_hw_params *init_param)\n{\n\tint ret;\n\n\tret = t7xx_dpmaif_hw_config(hw_info);\n\tif (ret) {\n\t\tdev_err(hw_info->dev, \"DPMAIF HW config failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = t7xx_dpmaif_init_intr(hw_info);\n\tif (ret) {\n\t\tdev_err(hw_info->dev, \"DPMAIF HW interrupts init failed\\n\");\n\t\treturn ret;\n\t}\n\n\tt7xx_dpmaif_set_queue_property(hw_info, init_param);\n\tt7xx_dpmaif_pcie_dpmaif_sign(hw_info);\n\tt7xx_dpmaif_dl_performance(hw_info);\n\n\tret = t7xx_dpmaif_config_dlq_hw(hw_info);\n\tif (ret) {\n\t\tdev_err(hw_info->dev, \"DPMAIF HW dlq config failed\\n\");\n\t\treturn ret;\n\t}\n\n\tt7xx_dpmaif_config_ulq_hw(hw_info);\n\n\tret = t7xx_dpmaif_hw_init_done(hw_info);\n\tif (ret)\n\t\tdev_err(hw_info->dev, \"DPMAIF HW queue init failed\\n\");\n\n\treturn ret;\n}\n\nbool t7xx_dpmaif_ul_clr_done(struct dpmaif_hw_info *hw_info, unsigned int qno)\n{\n\tu32 intr_status;\n\n\tintr_status = ioread32(hw_info->pcie_base + DPMAIF_AP_L2TISAR0);\n\tintr_status &= BIT(DP_UL_INT_DONE_OFFSET + qno);\n\tif (intr_status) {\n\t\tiowrite32(intr_status, hw_info->pcie_base + DPMAIF_AP_L2TISAR0);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}