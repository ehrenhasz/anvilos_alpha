{
  "module_name": "t7xx_pcie_mac.c",
  "hash_id": "ecbc6869c96a21d784083ebf15344e8ce67a574364480d6bd5268035785bec91",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wwan/t7xx/t7xx_pcie_mac.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/pci.h>\n#include <linux/string.h>\n#include <linux/types.h>\n\n#include \"t7xx_pci.h\"\n#include \"t7xx_pcie_mac.h\"\n#include \"t7xx_reg.h\"\n\n#define T7XX_PCIE_REG_BAR\t\t2\n#define T7XX_PCIE_REG_PORT\t\tATR_SRC_PCI_WIN0\n#define T7XX_PCIE_REG_TABLE_NUM\t\t0\n#define T7XX_PCIE_REG_TRSL_PORT\t\tATR_DST_AXIM_0\n\n#define T7XX_PCIE_DEV_DMA_PORT_START\tATR_SRC_AXIS_0\n#define T7XX_PCIE_DEV_DMA_PORT_END\tATR_SRC_AXIS_2\n#define T7XX_PCIE_DEV_DMA_TABLE_NUM\t0\n#define T7XX_PCIE_DEV_DMA_TRSL_ADDR\t0\n#define T7XX_PCIE_DEV_DMA_SRC_ADDR\t0\n#define T7XX_PCIE_DEV_DMA_TRANSPARENT\t1\n#define T7XX_PCIE_DEV_DMA_SIZE\t\t0\n\nenum t7xx_atr_src_port {\n\tATR_SRC_PCI_WIN0,\n\tATR_SRC_PCI_WIN1,\n\tATR_SRC_AXIS_0,\n\tATR_SRC_AXIS_1,\n\tATR_SRC_AXIS_2,\n\tATR_SRC_AXIS_3,\n};\n\nenum t7xx_atr_dst_port {\n\tATR_DST_PCI_TRX,\n\tATR_DST_PCI_CONFIG,\n\tATR_DST_AXIM_0 = 4,\n\tATR_DST_AXIM_1,\n\tATR_DST_AXIM_2,\n\tATR_DST_AXIM_3,\n};\n\nstruct t7xx_atr_config {\n\tu64\t\t\tsrc_addr;\n\tu64\t\t\ttrsl_addr;\n\tu64\t\t\tsize;\n\tu32\t\t\tport;\n\tu32\t\t\ttable;\n\tenum t7xx_atr_dst_port\ttrsl_id;\n\tu32\t\t\ttransparent;\n};\n\nstatic void t7xx_pcie_mac_atr_tables_dis(void __iomem *pbase, enum t7xx_atr_src_port port)\n{\n\tvoid __iomem *reg;\n\tint i, offset;\n\n\tfor (i = 0; i < ATR_TABLE_NUM_PER_ATR; i++) {\n\t\toffset = ATR_PORT_OFFSET * port + ATR_TABLE_OFFSET * i;\n\t\treg = pbase + ATR_PCIE_WIN0_T0_ATR_PARAM_SRC_ADDR + offset;\n\t\tiowrite64(0, reg);\n\t}\n}\n\nstatic int t7xx_pcie_mac_atr_cfg(struct t7xx_pci_dev *t7xx_dev, struct t7xx_atr_config *cfg)\n{\n\tstruct device *dev = &t7xx_dev->pdev->dev;\n\tvoid __iomem *pbase = IREG_BASE(t7xx_dev);\n\tint atr_size, pos, offset;\n\tvoid __iomem *reg;\n\tu64 value;\n\n\tif (cfg->transparent) {\n\t\t \n\t\tatr_size = ATR_TRANSPARENT_SIZE;\n\t} else {\n\t\tif (cfg->src_addr & (cfg->size - 1)) {\n\t\t\tdev_err(dev, \"Source address is not aligned to size\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (cfg->trsl_addr & (cfg->size - 1)) {\n\t\t\tdev_err(dev, \"Translation address %llx is not aligned to size %llx\\n\",\n\t\t\t\tcfg->trsl_addr, cfg->size - 1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpos = __ffs64(cfg->size);\n\n\t\t \n\t\tatr_size = pos - 1;\n\t}\n\n\toffset = ATR_PORT_OFFSET * cfg->port + ATR_TABLE_OFFSET * cfg->table;\n\n\treg = pbase + ATR_PCIE_WIN0_T0_TRSL_ADDR + offset;\n\tvalue = cfg->trsl_addr & ATR_PCIE_WIN0_ADDR_ALGMT;\n\tiowrite64(value, reg);\n\n\treg = pbase + ATR_PCIE_WIN0_T0_TRSL_PARAM + offset;\n\tiowrite32(cfg->trsl_id, reg);\n\n\treg = pbase + ATR_PCIE_WIN0_T0_ATR_PARAM_SRC_ADDR + offset;\n\tvalue = (cfg->src_addr & ATR_PCIE_WIN0_ADDR_ALGMT) | (atr_size << 1) | BIT(0);\n\tiowrite64(value, reg);\n\n\t \n\tioread64(reg);\n\treturn 0;\n}\n\n \nvoid t7xx_pcie_mac_atr_init(struct t7xx_pci_dev *t7xx_dev)\n{\n\tstruct t7xx_atr_config cfg;\n\tu32 i;\n\n\t \n\tfor (i = ATR_SRC_PCI_WIN0; i <= ATR_SRC_AXIS_3; i++)\n\t\tt7xx_pcie_mac_atr_tables_dis(IREG_BASE(t7xx_dev), i);\n\n\tmemset(&cfg, 0, sizeof(cfg));\n\t \n\tcfg.src_addr = pci_resource_start(t7xx_dev->pdev, T7XX_PCIE_REG_BAR);\n\tcfg.size = T7XX_PCIE_REG_SIZE_CHIP;\n\tcfg.trsl_addr = T7XX_PCIE_REG_TRSL_ADDR_CHIP;\n\tcfg.port = T7XX_PCIE_REG_PORT;\n\tcfg.table = T7XX_PCIE_REG_TABLE_NUM;\n\tcfg.trsl_id = T7XX_PCIE_REG_TRSL_PORT;\n\tt7xx_pcie_mac_atr_tables_dis(IREG_BASE(t7xx_dev), cfg.port);\n\tt7xx_pcie_mac_atr_cfg(t7xx_dev, &cfg);\n\n\tt7xx_dev->base_addr.pcie_dev_reg_trsl_addr = T7XX_PCIE_REG_TRSL_ADDR_CHIP;\n\n\t \n\tfor (i = T7XX_PCIE_DEV_DMA_PORT_START; i <= T7XX_PCIE_DEV_DMA_PORT_END; i++) {\n\t\tcfg.src_addr = T7XX_PCIE_DEV_DMA_SRC_ADDR;\n\t\tcfg.size = T7XX_PCIE_DEV_DMA_SIZE;\n\t\tcfg.trsl_addr = T7XX_PCIE_DEV_DMA_TRSL_ADDR;\n\t\tcfg.port = i;\n\t\tcfg.table = T7XX_PCIE_DEV_DMA_TABLE_NUM;\n\t\tcfg.trsl_id = ATR_DST_PCI_TRX;\n\t\tcfg.transparent = T7XX_PCIE_DEV_DMA_TRANSPARENT;\n\t\tt7xx_pcie_mac_atr_tables_dis(IREG_BASE(t7xx_dev), cfg.port);\n\t\tt7xx_pcie_mac_atr_cfg(t7xx_dev, &cfg);\n\t}\n}\n\n \nstatic void t7xx_pcie_mac_enable_disable_int(struct t7xx_pci_dev *t7xx_dev, bool enable)\n{\n\tu32 value;\n\n\tvalue = ioread32(IREG_BASE(t7xx_dev) + ISTAT_HST_CTRL);\n\n\tif (enable)\n\t\tvalue &= ~ISTAT_HST_CTRL_DIS;\n\telse\n\t\tvalue |= ISTAT_HST_CTRL_DIS;\n\n\tiowrite32(value, IREG_BASE(t7xx_dev) + ISTAT_HST_CTRL);\n}\n\nvoid t7xx_pcie_mac_interrupts_en(struct t7xx_pci_dev *t7xx_dev)\n{\n\tt7xx_pcie_mac_enable_disable_int(t7xx_dev, true);\n}\n\nvoid t7xx_pcie_mac_interrupts_dis(struct t7xx_pci_dev *t7xx_dev)\n{\n\tt7xx_pcie_mac_enable_disable_int(t7xx_dev, false);\n}\n\n \nstatic void t7xx_pcie_mac_clear_set_int(struct t7xx_pci_dev *t7xx_dev,\n\t\t\t\t\tenum t7xx_int int_type, bool clear)\n{\n\tvoid __iomem *reg;\n\tu32 val;\n\n\tif (clear)\n\t\treg = IREG_BASE(t7xx_dev) + IMASK_HOST_MSIX_CLR_GRP0_0;\n\telse\n\t\treg = IREG_BASE(t7xx_dev) + IMASK_HOST_MSIX_SET_GRP0_0;\n\n\tval = BIT(EXT_INT_START + int_type);\n\tiowrite32(val, reg);\n}\n\nvoid t7xx_pcie_mac_clear_int(struct t7xx_pci_dev *t7xx_dev, enum t7xx_int int_type)\n{\n\tt7xx_pcie_mac_clear_set_int(t7xx_dev, int_type, true);\n}\n\nvoid t7xx_pcie_mac_set_int(struct t7xx_pci_dev *t7xx_dev, enum t7xx_int int_type)\n{\n\tt7xx_pcie_mac_clear_set_int(t7xx_dev, int_type, false);\n}\n\n \nvoid t7xx_pcie_mac_clear_int_status(struct t7xx_pci_dev *t7xx_dev, enum t7xx_int int_type)\n{\n\tvoid __iomem *reg = IREG_BASE(t7xx_dev) + MSIX_ISTAT_HST_GRP0_0;\n\tu32 val = BIT(EXT_INT_START + int_type);\n\n\tiowrite32(val, reg);\n}\n\n \nvoid t7xx_pcie_set_mac_msix_cfg(struct t7xx_pci_dev *t7xx_dev, unsigned int irq_count)\n{\n\tu32 val = ffs(irq_count) * 2 - 1;\n\n\tiowrite32(val, IREG_BASE(t7xx_dev) + T7XX_PCIE_CFG_MSIX);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}