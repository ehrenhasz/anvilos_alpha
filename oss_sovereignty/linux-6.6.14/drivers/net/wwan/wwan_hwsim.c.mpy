{
  "module_name": "wwan_hwsim.c",
  "hash_id": "600b86c1994ea1a488bebd762d3348e07f63ea13a59afa9eb6553e6092c16d66",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wwan/wwan_hwsim.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/wwan.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n\n#include <net/arp.h>\n\nstatic int wwan_hwsim_devsnum = 2;\nmodule_param_named(devices, wwan_hwsim_devsnum, int, 0444);\nMODULE_PARM_DESC(devices, \"Number of simulated devices\");\n\nstatic struct class *wwan_hwsim_class;\n\nstatic struct dentry *wwan_hwsim_debugfs_topdir;\nstatic struct dentry *wwan_hwsim_debugfs_devcreate;\n\nstatic DEFINE_SPINLOCK(wwan_hwsim_devs_lock);\nstatic LIST_HEAD(wwan_hwsim_devs);\nstatic unsigned int wwan_hwsim_dev_idx;\nstatic struct workqueue_struct *wwan_wq;\n\nstruct wwan_hwsim_dev {\n\tstruct list_head list;\n\tunsigned int id;\n\tstruct device dev;\n\tstruct work_struct del_work;\n\tstruct dentry *debugfs_topdir;\n\tstruct dentry *debugfs_portcreate;\n\tspinlock_t ports_lock;\t \n\tunsigned int port_idx;\n\tstruct list_head ports;\n};\n\nstruct wwan_hwsim_port {\n\tstruct list_head list;\n\tunsigned int id;\n\tstruct wwan_hwsim_dev *dev;\n\tstruct wwan_port *wwan;\n\tstruct work_struct del_work;\n\tstruct dentry *debugfs_topdir;\n\tenum {\t\t\t \n\t\tAT_PARSER_WAIT_A,\n\t\tAT_PARSER_WAIT_T,\n\t\tAT_PARSER_WAIT_TERM,\n\t\tAT_PARSER_SKIP_LINE,\n\t} pstate;\n};\n\nstatic const struct file_operations wwan_hwsim_debugfs_portdestroy_fops;\nstatic const struct file_operations wwan_hwsim_debugfs_portcreate_fops;\nstatic const struct file_operations wwan_hwsim_debugfs_devdestroy_fops;\nstatic void wwan_hwsim_port_del_work(struct work_struct *work);\nstatic void wwan_hwsim_dev_del_work(struct work_struct *work);\n\nstatic netdev_tx_t wwan_hwsim_netdev_xmit(struct sk_buff *skb,\n\t\t\t\t\t  struct net_device *ndev)\n{\n\tndev->stats.tx_packets++;\n\tndev->stats.tx_bytes += skb->len;\n\tconsume_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic const struct net_device_ops wwan_hwsim_netdev_ops = {\n\t.ndo_start_xmit = wwan_hwsim_netdev_xmit,\n};\n\nstatic void wwan_hwsim_netdev_setup(struct net_device *ndev)\n{\n\tndev->netdev_ops = &wwan_hwsim_netdev_ops;\n\tndev->needs_free_netdev = true;\n\n\tndev->mtu = ETH_DATA_LEN;\n\tndev->min_mtu = ETH_MIN_MTU;\n\tndev->max_mtu = ETH_MAX_MTU;\n\n\tndev->type = ARPHRD_NONE;\n\tndev->flags = IFF_POINTOPOINT | IFF_NOARP;\n}\n\nstatic const struct wwan_ops wwan_hwsim_wwan_rtnl_ops = {\n\t.priv_size = 0,\t\t\t \n\t.setup = wwan_hwsim_netdev_setup,\n};\n\nstatic int wwan_hwsim_port_start(struct wwan_port *wport)\n{\n\tstruct wwan_hwsim_port *port = wwan_port_get_drvdata(wport);\n\n\tport->pstate = AT_PARSER_WAIT_A;\n\n\treturn 0;\n}\n\nstatic void wwan_hwsim_port_stop(struct wwan_port *wport)\n{\n}\n\n \nstatic int wwan_hwsim_port_tx(struct wwan_port *wport, struct sk_buff *in)\n{\n\tstruct wwan_hwsim_port *port = wwan_port_get_drvdata(wport);\n\tstruct sk_buff *out;\n\tint i, n, s;\n\n\t \n\tfor (i = 0, n = 0; i < in->len; ++i)\n\t\tif (in->data[i] == '\\r')\n\t\t\tn++;\n\tn = in->len + n * (2 + 2 + 2);\t \n\tout = alloc_skb(n, GFP_KERNEL);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, s = 0; i < in->len; ++i) {\n\t\tchar c = in->data[i];\n\n\t\tif (port->pstate == AT_PARSER_WAIT_A) {\n\t\t\tif (c == 'A' || c == 'a')\n\t\t\t\tport->pstate = AT_PARSER_WAIT_T;\n\t\t\telse if (c != '\\n')\t \n\t\t\t\tport->pstate = AT_PARSER_SKIP_LINE;\n\t\t} else if (port->pstate == AT_PARSER_WAIT_T) {\n\t\t\tif (c == 'T' || c == 't')\n\t\t\t\tport->pstate = AT_PARSER_WAIT_TERM;\n\t\t\telse\n\t\t\t\tport->pstate = AT_PARSER_SKIP_LINE;\n\t\t} else if (port->pstate == AT_PARSER_WAIT_TERM) {\n\t\t\tif (c != '\\r')\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif ((i + 1) < in->len && in->data[i + 1] == '\\n')\n\t\t\t\ti++;\n\t\t\tn = i - s + 1;\n\t\t\tskb_put_data(out, &in->data[s], n); \n\t\t\tskb_put_data(out, \"\\r\\nOK\\r\\n\", 6);\n\t\t\ts = i + 1;\n\t\t\tport->pstate = AT_PARSER_WAIT_A;\n\t\t} else if (port->pstate == AT_PARSER_SKIP_LINE) {\n\t\t\tif (c != '\\r')\n\t\t\t\tcontinue;\n\t\t\tport->pstate = AT_PARSER_WAIT_A;\n\t\t}\n\t}\n\n\tif (i > s) {\n\t\t \n\t\tn = i - s;\n\t\tskb_put_data(out, &in->data[s], n);\n\t}\n\n\tconsume_skb(in);\n\n\twwan_port_rx(wport, out);\n\n\treturn 0;\n}\n\nstatic const struct wwan_port_ops wwan_hwsim_port_ops = {\n\t.start = wwan_hwsim_port_start,\n\t.stop = wwan_hwsim_port_stop,\n\t.tx = wwan_hwsim_port_tx,\n};\n\nstatic struct wwan_hwsim_port *wwan_hwsim_port_new(struct wwan_hwsim_dev *dev)\n{\n\tstruct wwan_hwsim_port *port;\n\tchar name[0x10];\n\tint err;\n\n\tport = kzalloc(sizeof(*port), GFP_KERNEL);\n\tif (!port)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tport->dev = dev;\n\n\tspin_lock(&dev->ports_lock);\n\tport->id = dev->port_idx++;\n\tspin_unlock(&dev->ports_lock);\n\n\tport->wwan = wwan_create_port(&dev->dev, WWAN_PORT_AT,\n\t\t\t\t      &wwan_hwsim_port_ops,\n\t\t\t\t      NULL, port);\n\tif (IS_ERR(port->wwan)) {\n\t\terr = PTR_ERR(port->wwan);\n\t\tgoto err_free_port;\n\t}\n\n\tINIT_WORK(&port->del_work, wwan_hwsim_port_del_work);\n\n\tsnprintf(name, sizeof(name), \"port%u\", port->id);\n\tport->debugfs_topdir = debugfs_create_dir(name, dev->debugfs_topdir);\n\tdebugfs_create_file(\"destroy\", 0200, port->debugfs_topdir, port,\n\t\t\t    &wwan_hwsim_debugfs_portdestroy_fops);\n\n\treturn port;\n\nerr_free_port:\n\tkfree(port);\n\n\treturn ERR_PTR(err);\n}\n\nstatic void wwan_hwsim_port_del(struct wwan_hwsim_port *port)\n{\n\tdebugfs_remove(port->debugfs_topdir);\n\n\t \n\tif (current_work() != &port->del_work)\n\t\tcancel_work_sync(&port->del_work);\n\n\twwan_remove_port(port->wwan);\n\tkfree(port);\n}\n\nstatic void wwan_hwsim_port_del_work(struct work_struct *work)\n{\n\tstruct wwan_hwsim_port *port =\n\t\t\t\tcontainer_of(work, typeof(*port), del_work);\n\tstruct wwan_hwsim_dev *dev = port->dev;\n\n\tspin_lock(&dev->ports_lock);\n\tif (list_empty(&port->list)) {\n\t\t \n\t\tspin_unlock(&dev->ports_lock);\n\t\treturn;\n\t}\n\tlist_del_init(&port->list);\n\tspin_unlock(&dev->ports_lock);\n\n\twwan_hwsim_port_del(port);\n}\n\nstatic void wwan_hwsim_dev_release(struct device *sysdev)\n{\n\tstruct wwan_hwsim_dev *dev = container_of(sysdev, typeof(*dev), dev);\n\n\tkfree(dev);\n}\n\nstatic struct wwan_hwsim_dev *wwan_hwsim_dev_new(void)\n{\n\tstruct wwan_hwsim_dev *dev;\n\tint err;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock(&wwan_hwsim_devs_lock);\n\tdev->id = wwan_hwsim_dev_idx++;\n\tspin_unlock(&wwan_hwsim_devs_lock);\n\n\tdev->dev.release = wwan_hwsim_dev_release;\n\tdev->dev.class = wwan_hwsim_class;\n\tdev_set_name(&dev->dev, \"hwsim%u\", dev->id);\n\n\tspin_lock_init(&dev->ports_lock);\n\tINIT_LIST_HEAD(&dev->ports);\n\n\terr = device_register(&dev->dev);\n\tif (err)\n\t\tgoto err_free_dev;\n\n\tINIT_WORK(&dev->del_work, wwan_hwsim_dev_del_work);\n\n\terr = wwan_register_ops(&dev->dev, &wwan_hwsim_wwan_rtnl_ops, dev, 1);\n\tif (err)\n\t\tgoto err_unreg_dev;\n\n\tdev->debugfs_topdir = debugfs_create_dir(dev_name(&dev->dev),\n\t\t\t\t\t\t wwan_hwsim_debugfs_topdir);\n\tdebugfs_create_file(\"destroy\", 0200, dev->debugfs_topdir, dev,\n\t\t\t    &wwan_hwsim_debugfs_devdestroy_fops);\n\tdev->debugfs_portcreate =\n\t\tdebugfs_create_file(\"portcreate\", 0200,\n\t\t\t\t    dev->debugfs_topdir, dev,\n\t\t\t\t    &wwan_hwsim_debugfs_portcreate_fops);\n\n\treturn dev;\n\nerr_unreg_dev:\n\tdevice_unregister(&dev->dev);\n\t \n\n\treturn ERR_PTR(err);\n\nerr_free_dev:\n\tput_device(&dev->dev);\n\n\treturn ERR_PTR(err);\n}\n\nstatic void wwan_hwsim_dev_del(struct wwan_hwsim_dev *dev)\n{\n\tdebugfs_remove(dev->debugfs_portcreate);\t \n\n\tspin_lock(&dev->ports_lock);\n\twhile (!list_empty(&dev->ports)) {\n\t\tstruct wwan_hwsim_port *port;\n\n\t\tport = list_first_entry(&dev->ports, struct wwan_hwsim_port,\n\t\t\t\t\tlist);\n\t\tlist_del_init(&port->list);\n\t\tspin_unlock(&dev->ports_lock);\n\t\twwan_hwsim_port_del(port);\n\t\tspin_lock(&dev->ports_lock);\n\t}\n\tspin_unlock(&dev->ports_lock);\n\n\tdebugfs_remove(dev->debugfs_topdir);\n\n\t \n\twwan_unregister_ops(&dev->dev);\n\n\t \n\tif (current_work() != &dev->del_work)\n\t\tcancel_work_sync(&dev->del_work);\n\n\tdevice_unregister(&dev->dev);\n\t \n}\n\nstatic void wwan_hwsim_dev_del_work(struct work_struct *work)\n{\n\tstruct wwan_hwsim_dev *dev = container_of(work, typeof(*dev), del_work);\n\n\tspin_lock(&wwan_hwsim_devs_lock);\n\tif (list_empty(&dev->list)) {\n\t\t \n\t\tspin_unlock(&wwan_hwsim_devs_lock);\n\t\treturn;\n\t}\n\tlist_del_init(&dev->list);\n\tspin_unlock(&wwan_hwsim_devs_lock);\n\n\twwan_hwsim_dev_del(dev);\n}\n\nstatic ssize_t wwan_hwsim_debugfs_portdestroy_write(struct file *file,\n\t\t\t\t\t\t    const char __user *usrbuf,\n\t\t\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct wwan_hwsim_port *port = file->private_data;\n\n\t \n\tqueue_work(wwan_wq, &port->del_work);\n\n\treturn count;\n}\n\nstatic const struct file_operations wwan_hwsim_debugfs_portdestroy_fops = {\n\t.write = wwan_hwsim_debugfs_portdestroy_write,\n\t.open = simple_open,\n\t.llseek = noop_llseek,\n};\n\nstatic ssize_t wwan_hwsim_debugfs_portcreate_write(struct file *file,\n\t\t\t\t\t\t   const char __user *usrbuf,\n\t\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct wwan_hwsim_dev *dev = file->private_data;\n\tstruct wwan_hwsim_port *port;\n\n\tport = wwan_hwsim_port_new(dev);\n\tif (IS_ERR(port))\n\t\treturn PTR_ERR(port);\n\n\tspin_lock(&dev->ports_lock);\n\tlist_add_tail(&port->list, &dev->ports);\n\tspin_unlock(&dev->ports_lock);\n\n\treturn count;\n}\n\nstatic const struct file_operations wwan_hwsim_debugfs_portcreate_fops = {\n\t.write = wwan_hwsim_debugfs_portcreate_write,\n\t.open = simple_open,\n\t.llseek = noop_llseek,\n};\n\nstatic ssize_t wwan_hwsim_debugfs_devdestroy_write(struct file *file,\n\t\t\t\t\t\t   const char __user *usrbuf,\n\t\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct wwan_hwsim_dev *dev = file->private_data;\n\n\t \n\tqueue_work(wwan_wq, &dev->del_work);\n\n\treturn count;\n}\n\nstatic const struct file_operations wwan_hwsim_debugfs_devdestroy_fops = {\n\t.write = wwan_hwsim_debugfs_devdestroy_write,\n\t.open = simple_open,\n\t.llseek = noop_llseek,\n};\n\nstatic ssize_t wwan_hwsim_debugfs_devcreate_write(struct file *file,\n\t\t\t\t\t\t  const char __user *usrbuf,\n\t\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct wwan_hwsim_dev *dev;\n\n\tdev = wwan_hwsim_dev_new();\n\tif (IS_ERR(dev))\n\t\treturn PTR_ERR(dev);\n\n\tspin_lock(&wwan_hwsim_devs_lock);\n\tlist_add_tail(&dev->list, &wwan_hwsim_devs);\n\tspin_unlock(&wwan_hwsim_devs_lock);\n\n\treturn count;\n}\n\nstatic const struct file_operations wwan_hwsim_debugfs_devcreate_fops = {\n\t.write = wwan_hwsim_debugfs_devcreate_write,\n\t.open = simple_open,\n\t.llseek = noop_llseek,\n};\n\nstatic int __init wwan_hwsim_init_devs(void)\n{\n\tstruct wwan_hwsim_dev *dev;\n\tint i, j;\n\n\tfor (i = 0; i < wwan_hwsim_devsnum; ++i) {\n\t\tdev = wwan_hwsim_dev_new();\n\t\tif (IS_ERR(dev))\n\t\t\treturn PTR_ERR(dev);\n\n\t\tspin_lock(&wwan_hwsim_devs_lock);\n\t\tlist_add_tail(&dev->list, &wwan_hwsim_devs);\n\t\tspin_unlock(&wwan_hwsim_devs_lock);\n\n\t\t \n\t\tfor (j = 0; j < 2; ++j) {\n\t\t\tstruct wwan_hwsim_port *port;\n\n\t\t\tport = wwan_hwsim_port_new(dev);\n\t\t\tif (IS_ERR(port))\n\t\t\t\treturn PTR_ERR(port);\n\n\t\t\tspin_lock(&dev->ports_lock);\n\t\t\tlist_add_tail(&port->list, &dev->ports);\n\t\t\tspin_unlock(&dev->ports_lock);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void wwan_hwsim_free_devs(void)\n{\n\tstruct wwan_hwsim_dev *dev;\n\n\tspin_lock(&wwan_hwsim_devs_lock);\n\twhile (!list_empty(&wwan_hwsim_devs)) {\n\t\tdev = list_first_entry(&wwan_hwsim_devs, struct wwan_hwsim_dev,\n\t\t\t\t       list);\n\t\tlist_del_init(&dev->list);\n\t\tspin_unlock(&wwan_hwsim_devs_lock);\n\t\twwan_hwsim_dev_del(dev);\n\t\tspin_lock(&wwan_hwsim_devs_lock);\n\t}\n\tspin_unlock(&wwan_hwsim_devs_lock);\n}\n\nstatic int __init wwan_hwsim_init(void)\n{\n\tint err;\n\n\tif (wwan_hwsim_devsnum < 0 || wwan_hwsim_devsnum > 128)\n\t\treturn -EINVAL;\n\n\twwan_wq = alloc_workqueue(\"wwan_wq\", 0, 0);\n\tif (!wwan_wq)\n\t\treturn -ENOMEM;\n\n\twwan_hwsim_class = class_create(\"wwan_hwsim\");\n\tif (IS_ERR(wwan_hwsim_class)) {\n\t\terr = PTR_ERR(wwan_hwsim_class);\n\t\tgoto err_wq_destroy;\n\t}\n\n\twwan_hwsim_debugfs_topdir = debugfs_create_dir(\"wwan_hwsim\", NULL);\n\twwan_hwsim_debugfs_devcreate =\n\t\t\tdebugfs_create_file(\"devcreate\", 0200,\n\t\t\t\t\t    wwan_hwsim_debugfs_topdir, NULL,\n\t\t\t\t\t    &wwan_hwsim_debugfs_devcreate_fops);\n\n\terr = wwan_hwsim_init_devs();\n\tif (err)\n\t\tgoto err_clean_devs;\n\n\treturn 0;\n\nerr_clean_devs:\n\tdebugfs_remove(wwan_hwsim_debugfs_devcreate);\t \n\twwan_hwsim_free_devs();\n\tflush_workqueue(wwan_wq);\t \n\tdebugfs_remove(wwan_hwsim_debugfs_topdir);\n\tclass_destroy(wwan_hwsim_class);\nerr_wq_destroy:\n\tdestroy_workqueue(wwan_wq);\n\n\treturn err;\n}\n\nstatic void __exit wwan_hwsim_exit(void)\n{\n\tdebugfs_remove(wwan_hwsim_debugfs_devcreate);\t \n\twwan_hwsim_free_devs();\n\tflush_workqueue(wwan_wq);\t \n\tdebugfs_remove(wwan_hwsim_debugfs_topdir);\n\tclass_destroy(wwan_hwsim_class);\n\tdestroy_workqueue(wwan_wq);\n}\n\nmodule_init(wwan_hwsim_init);\nmodule_exit(wwan_hwsim_exit);\n\nMODULE_AUTHOR(\"Sergey Ryazanov\");\nMODULE_DESCRIPTION(\"Device simulator for WWAN framework\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}