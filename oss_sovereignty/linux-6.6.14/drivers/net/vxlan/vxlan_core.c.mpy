{
  "module_name": "vxlan_core.c",
  "hash_id": "e7fe9e800f43a30cfefd343cb2ec898556d2a48fb642e826100273a3ec887733",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/vxlan/vxlan_core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/udp.h>\n#include <linux/igmp.h>\n#include <linux/if_ether.h>\n#include <linux/ethtool.h>\n#include <net/arp.h>\n#include <net/ndisc.h>\n#include <net/gro.h>\n#include <net/ipv6_stubs.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/rtnetlink.h>\n#include <net/inet_ecn.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/tun_proto.h>\n#include <net/vxlan.h>\n#include <net/nexthop.h>\n\n#if IS_ENABLED(CONFIG_IPV6)\n#include <net/ip6_tunnel.h>\n#include <net/ip6_checksum.h>\n#endif\n\n#include \"vxlan_private.h\"\n\n#define VXLAN_VERSION\t\"0.1\"\n\n#define FDB_AGE_DEFAULT 300  \n#define FDB_AGE_INTERVAL (10 * HZ)\t \n\n \nstatic unsigned short vxlan_port __read_mostly = 8472;\nmodule_param_named(udp_port, vxlan_port, ushort, 0444);\nMODULE_PARM_DESC(udp_port, \"Destination UDP port\");\n\nstatic bool log_ecn_error = true;\nmodule_param(log_ecn_error, bool, 0644);\nMODULE_PARM_DESC(log_ecn_error, \"Log packets received with corrupted ECN\");\n\nunsigned int vxlan_net_id;\n\nconst u8 all_zeros_mac[ETH_ALEN + 2];\nstatic struct rtnl_link_ops vxlan_link_ops;\n\nstatic int vxlan_sock_add(struct vxlan_dev *vxlan);\n\nstatic void vxlan_vs_del_dev(struct vxlan_dev *vxlan);\n\n \nstatic u32 vxlan_salt __read_mostly;\n\nstatic inline bool vxlan_collect_metadata(struct vxlan_sock *vs)\n{\n\treturn vs->flags & VXLAN_F_COLLECT_METADATA ||\n\t       ip_tunnel_collect_metadata();\n}\n\n \nstatic struct vxlan_sock *vxlan_find_sock(struct net *net, sa_family_t family,\n\t\t\t\t\t  __be16 port, u32 flags, int ifindex)\n{\n\tstruct vxlan_sock *vs;\n\n\tflags &= VXLAN_F_RCV_FLAGS;\n\n\thlist_for_each_entry_rcu(vs, vs_head(net, port), hlist) {\n\t\tif (inet_sk(vs->sock->sk)->inet_sport == port &&\n\t\t    vxlan_get_sk_family(vs) == family &&\n\t\t    vs->flags == flags &&\n\t\t    vs->sock->sk->sk_bound_dev_if == ifindex)\n\t\t\treturn vs;\n\t}\n\treturn NULL;\n}\n\nstatic struct vxlan_dev *vxlan_vs_find_vni(struct vxlan_sock *vs,\n\t\t\t\t\t   int ifindex, __be32 vni,\n\t\t\t\t\t   struct vxlan_vni_node **vninode)\n{\n\tstruct vxlan_vni_node *vnode;\n\tstruct vxlan_dev_node *node;\n\n\t \n\tif (vs->flags & VXLAN_F_COLLECT_METADATA &&\n\t    !(vs->flags & VXLAN_F_VNIFILTER))\n\t\tvni = 0;\n\n\thlist_for_each_entry_rcu(node, vni_head(vs, vni), hlist) {\n\t\tif (!node->vxlan)\n\t\t\tcontinue;\n\t\tvnode = NULL;\n\t\tif (node->vxlan->cfg.flags & VXLAN_F_VNIFILTER) {\n\t\t\tvnode = vxlan_vnifilter_lookup(node->vxlan, vni);\n\t\t\tif (!vnode)\n\t\t\t\tcontinue;\n\t\t} else if (node->vxlan->default_dst.remote_vni != vni) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (IS_ENABLED(CONFIG_IPV6)) {\n\t\t\tconst struct vxlan_config *cfg = &node->vxlan->cfg;\n\n\t\t\tif ((cfg->flags & VXLAN_F_IPV6_LINKLOCAL) &&\n\t\t\t    cfg->remote_ifindex != ifindex)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (vninode)\n\t\t\t*vninode = vnode;\n\t\treturn node->vxlan;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct vxlan_dev *vxlan_find_vni(struct net *net, int ifindex,\n\t\t\t\t\t__be32 vni, sa_family_t family,\n\t\t\t\t\t__be16 port, u32 flags)\n{\n\tstruct vxlan_sock *vs;\n\n\tvs = vxlan_find_sock(net, family, port, flags, ifindex);\n\tif (!vs)\n\t\treturn NULL;\n\n\treturn vxlan_vs_find_vni(vs, ifindex, vni, NULL);\n}\n\n \nstatic int vxlan_fdb_info(struct sk_buff *skb, struct vxlan_dev *vxlan,\n\t\t\t  const struct vxlan_fdb *fdb,\n\t\t\t  u32 portid, u32 seq, int type, unsigned int flags,\n\t\t\t  const struct vxlan_rdst *rdst)\n{\n\tunsigned long now = jiffies;\n\tstruct nda_cacheinfo ci;\n\tbool send_ip, send_eth;\n\tstruct nlmsghdr *nlh;\n\tstruct nexthop *nh;\n\tstruct ndmsg *ndm;\n\tint nh_family;\n\tu32 nh_id;\n\n\tnlh = nlmsg_put(skb, portid, seq, type, sizeof(*ndm), flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tndm = nlmsg_data(nlh);\n\tmemset(ndm, 0, sizeof(*ndm));\n\n\tsend_eth = send_ip = true;\n\n\trcu_read_lock();\n\tnh = rcu_dereference(fdb->nh);\n\tif (nh) {\n\t\tnh_family = nexthop_get_family(nh);\n\t\tnh_id = nh->id;\n\t}\n\trcu_read_unlock();\n\n\tif (type == RTM_GETNEIGH) {\n\t\tif (rdst) {\n\t\t\tsend_ip = !vxlan_addr_any(&rdst->remote_ip);\n\t\t\tndm->ndm_family = send_ip ? rdst->remote_ip.sa.sa_family : AF_INET;\n\t\t} else if (nh) {\n\t\t\tndm->ndm_family = nh_family;\n\t\t}\n\t\tsend_eth = !is_zero_ether_addr(fdb->eth_addr);\n\t} else\n\t\tndm->ndm_family\t= AF_BRIDGE;\n\tndm->ndm_state = fdb->state;\n\tndm->ndm_ifindex = vxlan->dev->ifindex;\n\tndm->ndm_flags = fdb->flags;\n\tif (rdst && rdst->offloaded)\n\t\tndm->ndm_flags |= NTF_OFFLOADED;\n\tndm->ndm_type = RTN_UNICAST;\n\n\tif (!net_eq(dev_net(vxlan->dev), vxlan->net) &&\n\t    nla_put_s32(skb, NDA_LINK_NETNSID,\n\t\t\tpeernet2id(dev_net(vxlan->dev), vxlan->net)))\n\t\tgoto nla_put_failure;\n\n\tif (send_eth && nla_put(skb, NDA_LLADDR, ETH_ALEN, &fdb->eth_addr))\n\t\tgoto nla_put_failure;\n\tif (nh) {\n\t\tif (nla_put_u32(skb, NDA_NH_ID, nh_id))\n\t\t\tgoto nla_put_failure;\n\t} else if (rdst) {\n\t\tif (send_ip && vxlan_nla_put_addr(skb, NDA_DST,\n\t\t\t\t\t\t  &rdst->remote_ip))\n\t\t\tgoto nla_put_failure;\n\n\t\tif (rdst->remote_port &&\n\t\t    rdst->remote_port != vxlan->cfg.dst_port &&\n\t\t    nla_put_be16(skb, NDA_PORT, rdst->remote_port))\n\t\t\tgoto nla_put_failure;\n\t\tif (rdst->remote_vni != vxlan->default_dst.remote_vni &&\n\t\t    nla_put_u32(skb, NDA_VNI, be32_to_cpu(rdst->remote_vni)))\n\t\t\tgoto nla_put_failure;\n\t\tif (rdst->remote_ifindex &&\n\t\t    nla_put_u32(skb, NDA_IFINDEX, rdst->remote_ifindex))\n\t\t\tgoto nla_put_failure;\n\t}\n\n\tif ((vxlan->cfg.flags & VXLAN_F_COLLECT_METADATA) && fdb->vni &&\n\t    nla_put_u32(skb, NDA_SRC_VNI,\n\t\t\tbe32_to_cpu(fdb->vni)))\n\t\tgoto nla_put_failure;\n\n\tci.ndm_used\t = jiffies_to_clock_t(now - fdb->used);\n\tci.ndm_confirmed = 0;\n\tci.ndm_updated\t = jiffies_to_clock_t(now - fdb->updated);\n\tci.ndm_refcnt\t = 0;\n\n\tif (nla_put(skb, NDA_CACHEINFO, sizeof(ci), &ci))\n\t\tgoto nla_put_failure;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nnla_put_failure:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic inline size_t vxlan_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct ndmsg))\n\t\t+ nla_total_size(ETH_ALEN)  \n\t\t+ nla_total_size(sizeof(struct in6_addr))  \n\t\t+ nla_total_size(sizeof(__be16))  \n\t\t+ nla_total_size(sizeof(__be32))  \n\t\t+ nla_total_size(sizeof(__u32))  \n\t\t+ nla_total_size(sizeof(__s32))  \n\t\t+ nla_total_size(sizeof(struct nda_cacheinfo));\n}\n\nstatic void __vxlan_fdb_notify(struct vxlan_dev *vxlan, struct vxlan_fdb *fdb,\n\t\t\t       struct vxlan_rdst *rd, int type)\n{\n\tstruct net *net = dev_net(vxlan->dev);\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(vxlan_nlmsg_size(), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\tgoto errout;\n\n\terr = vxlan_fdb_info(skb, vxlan, fdb, 0, 0, type, 0, rd);\n\tif (err < 0) {\n\t\t \n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\n\trtnl_notify(skb, net, 0, RTNLGRP_NEIGH, NULL, GFP_ATOMIC);\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_NEIGH, err);\n}\n\nstatic void vxlan_fdb_switchdev_notifier_info(const struct vxlan_dev *vxlan,\n\t\t\t    const struct vxlan_fdb *fdb,\n\t\t\t    const struct vxlan_rdst *rd,\n\t\t\t    struct netlink_ext_ack *extack,\n\t\t\t    struct switchdev_notifier_vxlan_fdb_info *fdb_info)\n{\n\tfdb_info->info.dev = vxlan->dev;\n\tfdb_info->info.extack = extack;\n\tfdb_info->remote_ip = rd->remote_ip;\n\tfdb_info->remote_port = rd->remote_port;\n\tfdb_info->remote_vni = rd->remote_vni;\n\tfdb_info->remote_ifindex = rd->remote_ifindex;\n\tmemcpy(fdb_info->eth_addr, fdb->eth_addr, ETH_ALEN);\n\tfdb_info->vni = fdb->vni;\n\tfdb_info->offloaded = rd->offloaded;\n\tfdb_info->added_by_user = fdb->flags & NTF_VXLAN_ADDED_BY_USER;\n}\n\nstatic int vxlan_fdb_switchdev_call_notifiers(struct vxlan_dev *vxlan,\n\t\t\t\t\t      struct vxlan_fdb *fdb,\n\t\t\t\t\t      struct vxlan_rdst *rd,\n\t\t\t\t\t      bool adding,\n\t\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct switchdev_notifier_vxlan_fdb_info info;\n\tenum switchdev_notifier_type notifier_type;\n\tint ret;\n\n\tif (WARN_ON(!rd))\n\t\treturn 0;\n\n\tnotifier_type = adding ? SWITCHDEV_VXLAN_FDB_ADD_TO_DEVICE\n\t\t\t       : SWITCHDEV_VXLAN_FDB_DEL_TO_DEVICE;\n\tvxlan_fdb_switchdev_notifier_info(vxlan, fdb, rd, NULL, &info);\n\tret = call_switchdev_notifiers(notifier_type, vxlan->dev,\n\t\t\t\t       &info.info, extack);\n\treturn notifier_to_errno(ret);\n}\n\nstatic int vxlan_fdb_notify(struct vxlan_dev *vxlan, struct vxlan_fdb *fdb,\n\t\t\t    struct vxlan_rdst *rd, int type, bool swdev_notify,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\tif (swdev_notify && rd) {\n\t\tswitch (type) {\n\t\tcase RTM_NEWNEIGH:\n\t\t\terr = vxlan_fdb_switchdev_call_notifiers(vxlan, fdb, rd,\n\t\t\t\t\t\t\t\t true, extack);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tbreak;\n\t\tcase RTM_DELNEIGH:\n\t\t\tvxlan_fdb_switchdev_call_notifiers(vxlan, fdb, rd,\n\t\t\t\t\t\t\t   false, extack);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t__vxlan_fdb_notify(vxlan, fdb, rd, type);\n\treturn 0;\n}\n\nstatic void vxlan_ip_miss(struct net_device *dev, union vxlan_addr *ipa)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tstruct vxlan_fdb f = {\n\t\t.state = NUD_STALE,\n\t};\n\tstruct vxlan_rdst remote = {\n\t\t.remote_ip = *ipa,  \n\t\t.remote_vni = cpu_to_be32(VXLAN_N_VID),\n\t};\n\n\tvxlan_fdb_notify(vxlan, &f, &remote, RTM_GETNEIGH, true, NULL);\n}\n\nstatic void vxlan_fdb_miss(struct vxlan_dev *vxlan, const u8 eth_addr[ETH_ALEN])\n{\n\tstruct vxlan_fdb f = {\n\t\t.state = NUD_STALE,\n\t};\n\tstruct vxlan_rdst remote = { };\n\n\tmemcpy(f.eth_addr, eth_addr, ETH_ALEN);\n\n\tvxlan_fdb_notify(vxlan, &f, &remote, RTM_GETNEIGH, true, NULL);\n}\n\n \nstatic u32 eth_hash(const unsigned char *addr)\n{\n\tu64 value = get_unaligned((u64 *)addr);\n\n\t \n#ifdef __BIG_ENDIAN\n\tvalue >>= 16;\n#else\n\tvalue <<= 16;\n#endif\n\treturn hash_64(value, FDB_HASH_BITS);\n}\n\nu32 eth_vni_hash(const unsigned char *addr, __be32 vni)\n{\n\t \n\tu32 key = get_unaligned((u32 *)(addr + 2));\n\n\treturn jhash_2words(key, vni, vxlan_salt) & (FDB_HASH_SIZE - 1);\n}\n\nu32 fdb_head_index(struct vxlan_dev *vxlan, const u8 *mac, __be32 vni)\n{\n\tif (vxlan->cfg.flags & VXLAN_F_COLLECT_METADATA)\n\t\treturn eth_vni_hash(mac, vni);\n\telse\n\t\treturn eth_hash(mac);\n}\n\n \nstatic inline struct hlist_head *vxlan_fdb_head(struct vxlan_dev *vxlan,\n\t\t\t\t\t\tconst u8 *mac, __be32 vni)\n{\n\treturn &vxlan->fdb_head[fdb_head_index(vxlan, mac, vni)];\n}\n\n \nstatic struct vxlan_fdb *__vxlan_find_mac(struct vxlan_dev *vxlan,\n\t\t\t\t\t  const u8 *mac, __be32 vni)\n{\n\tstruct hlist_head *head = vxlan_fdb_head(vxlan, mac, vni);\n\tstruct vxlan_fdb *f;\n\n\thlist_for_each_entry_rcu(f, head, hlist) {\n\t\tif (ether_addr_equal(mac, f->eth_addr)) {\n\t\t\tif (vxlan->cfg.flags & VXLAN_F_COLLECT_METADATA) {\n\t\t\t\tif (vni == f->vni)\n\t\t\t\t\treturn f;\n\t\t\t} else {\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic struct vxlan_fdb *vxlan_find_mac(struct vxlan_dev *vxlan,\n\t\t\t\t\tconst u8 *mac, __be32 vni)\n{\n\tstruct vxlan_fdb *f;\n\n\tf = __vxlan_find_mac(vxlan, mac, vni);\n\tif (f && f->used != jiffies)\n\t\tf->used = jiffies;\n\n\treturn f;\n}\n\n \nstatic struct vxlan_rdst *vxlan_fdb_find_rdst(struct vxlan_fdb *f,\n\t\t\t\t\t      union vxlan_addr *ip, __be16 port,\n\t\t\t\t\t      __be32 vni, __u32 ifindex)\n{\n\tstruct vxlan_rdst *rd;\n\n\tlist_for_each_entry(rd, &f->remotes, list) {\n\t\tif (vxlan_addr_equal(&rd->remote_ip, ip) &&\n\t\t    rd->remote_port == port &&\n\t\t    rd->remote_vni == vni &&\n\t\t    rd->remote_ifindex == ifindex)\n\t\t\treturn rd;\n\t}\n\n\treturn NULL;\n}\n\nint vxlan_fdb_find_uc(struct net_device *dev, const u8 *mac, __be32 vni,\n\t\t      struct switchdev_notifier_vxlan_fdb_info *fdb_info)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tu8 eth_addr[ETH_ALEN + 2] = { 0 };\n\tstruct vxlan_rdst *rdst;\n\tstruct vxlan_fdb *f;\n\tint rc = 0;\n\n\tif (is_multicast_ether_addr(mac) ||\n\t    is_zero_ether_addr(mac))\n\t\treturn -EINVAL;\n\n\tether_addr_copy(eth_addr, mac);\n\n\trcu_read_lock();\n\n\tf = __vxlan_find_mac(vxlan, eth_addr, vni);\n\tif (!f) {\n\t\trc = -ENOENT;\n\t\tgoto out;\n\t}\n\n\trdst = first_remote_rcu(f);\n\tvxlan_fdb_switchdev_notifier_info(vxlan, f, rdst, NULL, fdb_info);\n\nout:\n\trcu_read_unlock();\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(vxlan_fdb_find_uc);\n\nstatic int vxlan_fdb_notify_one(struct notifier_block *nb,\n\t\t\t\tconst struct vxlan_dev *vxlan,\n\t\t\t\tconst struct vxlan_fdb *f,\n\t\t\t\tconst struct vxlan_rdst *rdst,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct switchdev_notifier_vxlan_fdb_info fdb_info;\n\tint rc;\n\n\tvxlan_fdb_switchdev_notifier_info(vxlan, f, rdst, extack, &fdb_info);\n\trc = nb->notifier_call(nb, SWITCHDEV_VXLAN_FDB_ADD_TO_DEVICE,\n\t\t\t       &fdb_info);\n\treturn notifier_to_errno(rc);\n}\n\nint vxlan_fdb_replay(const struct net_device *dev, __be32 vni,\n\t\t     struct notifier_block *nb,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_dev *vxlan;\n\tstruct vxlan_rdst *rdst;\n\tstruct vxlan_fdb *f;\n\tunsigned int h;\n\tint rc = 0;\n\n\tif (!netif_is_vxlan(dev))\n\t\treturn -EINVAL;\n\tvxlan = netdev_priv(dev);\n\n\tfor (h = 0; h < FDB_HASH_SIZE; ++h) {\n\t\tspin_lock_bh(&vxlan->hash_lock[h]);\n\t\thlist_for_each_entry(f, &vxlan->fdb_head[h], hlist) {\n\t\t\tif (f->vni == vni) {\n\t\t\t\tlist_for_each_entry(rdst, &f->remotes, list) {\n\t\t\t\t\trc = vxlan_fdb_notify_one(nb, vxlan,\n\t\t\t\t\t\t\t\t  f, rdst,\n\t\t\t\t\t\t\t\t  extack);\n\t\t\t\t\tif (rc)\n\t\t\t\t\t\tgoto unlock;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&vxlan->hash_lock[h]);\n\t}\n\treturn 0;\n\nunlock:\n\tspin_unlock_bh(&vxlan->hash_lock[h]);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(vxlan_fdb_replay);\n\nvoid vxlan_fdb_clear_offload(const struct net_device *dev, __be32 vni)\n{\n\tstruct vxlan_dev *vxlan;\n\tstruct vxlan_rdst *rdst;\n\tstruct vxlan_fdb *f;\n\tunsigned int h;\n\n\tif (!netif_is_vxlan(dev))\n\t\treturn;\n\tvxlan = netdev_priv(dev);\n\n\tfor (h = 0; h < FDB_HASH_SIZE; ++h) {\n\t\tspin_lock_bh(&vxlan->hash_lock[h]);\n\t\thlist_for_each_entry(f, &vxlan->fdb_head[h], hlist)\n\t\t\tif (f->vni == vni)\n\t\t\t\tlist_for_each_entry(rdst, &f->remotes, list)\n\t\t\t\t\trdst->offloaded = false;\n\t\tspin_unlock_bh(&vxlan->hash_lock[h]);\n\t}\n\n}\nEXPORT_SYMBOL_GPL(vxlan_fdb_clear_offload);\n\n \nstatic int vxlan_fdb_replace(struct vxlan_fdb *f,\n\t\t\t     union vxlan_addr *ip, __be16 port, __be32 vni,\n\t\t\t     __u32 ifindex, struct vxlan_rdst *oldrd)\n{\n\tstruct vxlan_rdst *rd;\n\n\trd = vxlan_fdb_find_rdst(f, ip, port, vni, ifindex);\n\tif (rd)\n\t\treturn 0;\n\n\trd = list_first_entry_or_null(&f->remotes, struct vxlan_rdst, list);\n\tif (!rd)\n\t\treturn 0;\n\n\t*oldrd = *rd;\n\tdst_cache_reset(&rd->dst_cache);\n\trd->remote_ip = *ip;\n\trd->remote_port = port;\n\trd->remote_vni = vni;\n\trd->remote_ifindex = ifindex;\n\trd->offloaded = false;\n\treturn 1;\n}\n\n \nstatic int vxlan_fdb_append(struct vxlan_fdb *f,\n\t\t\t    union vxlan_addr *ip, __be16 port, __be32 vni,\n\t\t\t    __u32 ifindex, struct vxlan_rdst **rdp)\n{\n\tstruct vxlan_rdst *rd;\n\n\trd = vxlan_fdb_find_rdst(f, ip, port, vni, ifindex);\n\tif (rd)\n\t\treturn 0;\n\n\trd = kmalloc(sizeof(*rd), GFP_ATOMIC);\n\tif (rd == NULL)\n\t\treturn -ENOMEM;\n\n\tif (dst_cache_init(&rd->dst_cache, GFP_ATOMIC)) {\n\t\tkfree(rd);\n\t\treturn -ENOMEM;\n\t}\n\n\trd->remote_ip = *ip;\n\trd->remote_port = port;\n\trd->offloaded = false;\n\trd->remote_vni = vni;\n\trd->remote_ifindex = ifindex;\n\n\tlist_add_tail_rcu(&rd->list, &f->remotes);\n\n\t*rdp = rd;\n\treturn 1;\n}\n\nstatic bool vxlan_parse_gpe_proto(struct vxlanhdr *hdr, __be16 *protocol)\n{\n\tstruct vxlanhdr_gpe *gpe = (struct vxlanhdr_gpe *)hdr;\n\n\t \n\tif (!gpe->np_applied)\n\t\treturn false;\n\t \n\tif (gpe->version != 0)\n\t\treturn false;\n\t \n\tif (gpe->oam_flag)\n\t\treturn false;\n\n\t*protocol = tun_p_to_eth_p(gpe->next_protocol);\n\tif (!*protocol)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic struct vxlanhdr *vxlan_gro_remcsum(struct sk_buff *skb,\n\t\t\t\t\t  unsigned int off,\n\t\t\t\t\t  struct vxlanhdr *vh, size_t hdrlen,\n\t\t\t\t\t  __be32 vni_field,\n\t\t\t\t\t  struct gro_remcsum *grc,\n\t\t\t\t\t  bool nopartial)\n{\n\tsize_t start, offset;\n\n\tif (skb->remcsum_offload)\n\t\treturn vh;\n\n\tif (!NAPI_GRO_CB(skb)->csum_valid)\n\t\treturn NULL;\n\n\tstart = vxlan_rco_start(vni_field);\n\toffset = start + vxlan_rco_offset(vni_field);\n\n\tvh = skb_gro_remcsum_process(skb, (void *)vh, off, hdrlen,\n\t\t\t\t     start, offset, grc, nopartial);\n\n\tskb->remcsum_offload = 1;\n\n\treturn vh;\n}\n\nstatic struct vxlanhdr *vxlan_gro_prepare_receive(struct sock *sk,\n\t\t\t\t\t\t  struct list_head *head,\n\t\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t\t  struct gro_remcsum *grc)\n{\n\tstruct sk_buff *p;\n\tstruct vxlanhdr *vh, *vh2;\n\tunsigned int hlen, off_vx;\n\tstruct vxlan_sock *vs = rcu_dereference_sk_user_data(sk);\n\t__be32 flags;\n\n\tskb_gro_remcsum_init(grc);\n\n\toff_vx = skb_gro_offset(skb);\n\thlen = off_vx + sizeof(*vh);\n\tvh = skb_gro_header(skb, hlen, off_vx);\n\tif (unlikely(!vh))\n\t\treturn NULL;\n\n\tskb_gro_postpull_rcsum(skb, vh, sizeof(struct vxlanhdr));\n\n\tflags = vh->vx_flags;\n\n\tif ((flags & VXLAN_HF_RCO) && (vs->flags & VXLAN_F_REMCSUM_RX)) {\n\t\tvh = vxlan_gro_remcsum(skb, off_vx, vh, sizeof(struct vxlanhdr),\n\t\t\t\t       vh->vx_vni, grc,\n\t\t\t\t       !!(vs->flags &\n\t\t\t\t\t  VXLAN_F_REMCSUM_NOPARTIAL));\n\n\t\tif (!vh)\n\t\t\treturn NULL;\n\t}\n\n\tskb_gro_pull(skb, sizeof(struct vxlanhdr));  \n\n\tlist_for_each_entry(p, head, list) {\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\n\t\tvh2 = (struct vxlanhdr *)(p->data + off_vx);\n\t\tif (vh->vx_flags != vh2->vx_flags ||\n\t\t    vh->vx_vni != vh2->vx_vni) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn vh;\n}\n\nstatic struct sk_buff *vxlan_gro_receive(struct sock *sk,\n\t\t\t\t\t struct list_head *head,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct sk_buff *pp = NULL;\n\tstruct gro_remcsum grc;\n\tint flush = 1;\n\n\tif (vxlan_gro_prepare_receive(sk, head, skb, &grc)) {\n\t\tpp = call_gro_receive(eth_gro_receive, head, skb);\n\t\tflush = 0;\n\t}\n\tskb_gro_flush_final_remcsum(skb, pp, flush, &grc);\n\treturn pp;\n}\n\nstatic struct sk_buff *vxlan_gpe_gro_receive(struct sock *sk,\n\t\t\t\t\t     struct list_head *head,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tconst struct packet_offload *ptype;\n\tstruct sk_buff *pp = NULL;\n\tstruct gro_remcsum grc;\n\tstruct vxlanhdr *vh;\n\t__be16 protocol;\n\tint flush = 1;\n\n\tvh = vxlan_gro_prepare_receive(sk, head, skb, &grc);\n\tif (vh) {\n\t\tif (!vxlan_parse_gpe_proto(vh, &protocol))\n\t\t\tgoto out;\n\t\tptype = gro_find_receive_by_type(protocol);\n\t\tif (!ptype)\n\t\t\tgoto out;\n\t\tpp = call_gro_receive(ptype->callbacks.gro_receive, head, skb);\n\t\tflush = 0;\n\t}\nout:\n\tskb_gro_flush_final_remcsum(skb, pp, flush, &grc);\n\treturn pp;\n}\n\nstatic int vxlan_gro_complete(struct sock *sk, struct sk_buff *skb, int nhoff)\n{\n\t \n\treturn eth_gro_complete(skb, nhoff + sizeof(struct vxlanhdr));\n}\n\nstatic int vxlan_gpe_gro_complete(struct sock *sk, struct sk_buff *skb, int nhoff)\n{\n\tstruct vxlanhdr *vh = (struct vxlanhdr *)(skb->data + nhoff);\n\tconst struct packet_offload *ptype;\n\tint err = -ENOSYS;\n\t__be16 protocol;\n\n\tif (!vxlan_parse_gpe_proto(vh, &protocol))\n\t\treturn err;\n\tptype = gro_find_complete_by_type(protocol);\n\tif (ptype)\n\t\terr = ptype->callbacks.gro_complete(skb, nhoff + sizeof(struct vxlanhdr));\n\treturn err;\n}\n\nstatic struct vxlan_fdb *vxlan_fdb_alloc(struct vxlan_dev *vxlan, const u8 *mac,\n\t\t\t\t\t __u16 state, __be32 src_vni,\n\t\t\t\t\t __u16 ndm_flags)\n{\n\tstruct vxlan_fdb *f;\n\n\tf = kmalloc(sizeof(*f), GFP_ATOMIC);\n\tif (!f)\n\t\treturn NULL;\n\tf->state = state;\n\tf->flags = ndm_flags;\n\tf->updated = f->used = jiffies;\n\tf->vni = src_vni;\n\tf->nh = NULL;\n\tRCU_INIT_POINTER(f->vdev, vxlan);\n\tINIT_LIST_HEAD(&f->nh_list);\n\tINIT_LIST_HEAD(&f->remotes);\n\tmemcpy(f->eth_addr, mac, ETH_ALEN);\n\n\treturn f;\n}\n\nstatic void vxlan_fdb_insert(struct vxlan_dev *vxlan, const u8 *mac,\n\t\t\t     __be32 src_vni, struct vxlan_fdb *f)\n{\n\t++vxlan->addrcnt;\n\thlist_add_head_rcu(&f->hlist,\n\t\t\t   vxlan_fdb_head(vxlan, mac, src_vni));\n}\n\nstatic int vxlan_fdb_nh_update(struct vxlan_dev *vxlan, struct vxlan_fdb *fdb,\n\t\t\t       u32 nhid, struct netlink_ext_ack *extack)\n{\n\tstruct nexthop *old_nh = rtnl_dereference(fdb->nh);\n\tstruct nexthop *nh;\n\tint err = -EINVAL;\n\n\tif (old_nh && old_nh->id == nhid)\n\t\treturn 0;\n\n\tnh = nexthop_find_by_id(vxlan->net, nhid);\n\tif (!nh) {\n\t\tNL_SET_ERR_MSG(extack, \"Nexthop id does not exist\");\n\t\tgoto err_inval;\n\t}\n\n\tif (!nexthop_get(nh)) {\n\t\tNL_SET_ERR_MSG(extack, \"Nexthop has been deleted\");\n\t\tnh = NULL;\n\t\tgoto err_inval;\n\t}\n\tif (!nexthop_is_fdb(nh)) {\n\t\tNL_SET_ERR_MSG(extack, \"Nexthop is not a fdb nexthop\");\n\t\tgoto err_inval;\n\t}\n\n\tif (!nexthop_is_multipath(nh)) {\n\t\tNL_SET_ERR_MSG(extack, \"Nexthop is not a multipath group\");\n\t\tgoto err_inval;\n\t}\n\n\t \n\tswitch (vxlan->default_dst.remote_ip.sa.sa_family) {\n\tcase AF_INET:\n\t\tif (!nexthop_has_v4(nh)) {\n\t\t\terr = -EAFNOSUPPORT;\n\t\t\tNL_SET_ERR_MSG(extack, \"Nexthop group family not supported\");\n\t\t\tgoto err_inval;\n\t\t}\n\t\tbreak;\n\tcase AF_INET6:\n\t\tif (nexthop_has_v4(nh)) {\n\t\t\terr = -EAFNOSUPPORT;\n\t\t\tNL_SET_ERR_MSG(extack, \"Nexthop group family not supported\");\n\t\t\tgoto err_inval;\n\t\t}\n\t}\n\n\tif (old_nh) {\n\t\tlist_del_rcu(&fdb->nh_list);\n\t\tnexthop_put(old_nh);\n\t}\n\trcu_assign_pointer(fdb->nh, nh);\n\tlist_add_tail_rcu(&fdb->nh_list, &nh->fdb_list);\n\treturn 1;\n\nerr_inval:\n\tif (nh)\n\t\tnexthop_put(nh);\n\treturn err;\n}\n\nint vxlan_fdb_create(struct vxlan_dev *vxlan,\n\t\t     const u8 *mac, union vxlan_addr *ip,\n\t\t     __u16 state, __be16 port, __be32 src_vni,\n\t\t     __be32 vni, __u32 ifindex, __u16 ndm_flags,\n\t\t     u32 nhid, struct vxlan_fdb **fdb,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_rdst *rd = NULL;\n\tstruct vxlan_fdb *f;\n\tint rc;\n\n\tif (vxlan->cfg.addrmax &&\n\t    vxlan->addrcnt >= vxlan->cfg.addrmax)\n\t\treturn -ENOSPC;\n\n\tnetdev_dbg(vxlan->dev, \"add %pM -> %pIS\\n\", mac, ip);\n\tf = vxlan_fdb_alloc(vxlan, mac, state, src_vni, ndm_flags);\n\tif (!f)\n\t\treturn -ENOMEM;\n\n\tif (nhid)\n\t\trc = vxlan_fdb_nh_update(vxlan, f, nhid, extack);\n\telse\n\t\trc = vxlan_fdb_append(f, ip, port, vni, ifindex, &rd);\n\tif (rc < 0)\n\t\tgoto errout;\n\n\t*fdb = f;\n\n\treturn 0;\n\nerrout:\n\tkfree(f);\n\treturn rc;\n}\n\nstatic void __vxlan_fdb_free(struct vxlan_fdb *f)\n{\n\tstruct vxlan_rdst *rd, *nd;\n\tstruct nexthop *nh;\n\n\tnh = rcu_dereference_raw(f->nh);\n\tif (nh) {\n\t\trcu_assign_pointer(f->nh, NULL);\n\t\trcu_assign_pointer(f->vdev, NULL);\n\t\tnexthop_put(nh);\n\t}\n\n\tlist_for_each_entry_safe(rd, nd, &f->remotes, list) {\n\t\tdst_cache_destroy(&rd->dst_cache);\n\t\tkfree(rd);\n\t}\n\tkfree(f);\n}\n\nstatic void vxlan_fdb_free(struct rcu_head *head)\n{\n\tstruct vxlan_fdb *f = container_of(head, struct vxlan_fdb, rcu);\n\n\t__vxlan_fdb_free(f);\n}\n\nstatic void vxlan_fdb_destroy(struct vxlan_dev *vxlan, struct vxlan_fdb *f,\n\t\t\t      bool do_notify, bool swdev_notify)\n{\n\tstruct vxlan_rdst *rd;\n\n\tnetdev_dbg(vxlan->dev, \"delete %pM\\n\", f->eth_addr);\n\n\t--vxlan->addrcnt;\n\tif (do_notify) {\n\t\tif (rcu_access_pointer(f->nh))\n\t\t\tvxlan_fdb_notify(vxlan, f, NULL, RTM_DELNEIGH,\n\t\t\t\t\t swdev_notify, NULL);\n\t\telse\n\t\t\tlist_for_each_entry(rd, &f->remotes, list)\n\t\t\t\tvxlan_fdb_notify(vxlan, f, rd, RTM_DELNEIGH,\n\t\t\t\t\t\t swdev_notify, NULL);\n\t}\n\n\thlist_del_rcu(&f->hlist);\n\tlist_del_rcu(&f->nh_list);\n\tcall_rcu(&f->rcu, vxlan_fdb_free);\n}\n\nstatic void vxlan_dst_free(struct rcu_head *head)\n{\n\tstruct vxlan_rdst *rd = container_of(head, struct vxlan_rdst, rcu);\n\n\tdst_cache_destroy(&rd->dst_cache);\n\tkfree(rd);\n}\n\nstatic int vxlan_fdb_update_existing(struct vxlan_dev *vxlan,\n\t\t\t\t     union vxlan_addr *ip,\n\t\t\t\t     __u16 state, __u16 flags,\n\t\t\t\t     __be16 port, __be32 vni,\n\t\t\t\t     __u32 ifindex, __u16 ndm_flags,\n\t\t\t\t     struct vxlan_fdb *f, u32 nhid,\n\t\t\t\t     bool swdev_notify,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\t__u16 fdb_flags = (ndm_flags & ~NTF_USE);\n\tstruct vxlan_rdst *rd = NULL;\n\tstruct vxlan_rdst oldrd;\n\tint notify = 0;\n\tint rc = 0;\n\tint err;\n\n\tif (nhid && !rcu_access_pointer(f->nh)) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Cannot replace an existing non nexthop fdb with a nexthop\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (nhid && (flags & NLM_F_APPEND)) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Cannot append to a nexthop fdb\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (!(fdb_flags & NTF_EXT_LEARNED) ||\n\t    !(f->flags & NTF_VXLAN_ADDED_BY_USER)) {\n\t\tif (f->state != state) {\n\t\t\tf->state = state;\n\t\t\tf->updated = jiffies;\n\t\t\tnotify = 1;\n\t\t}\n\t\tif (f->flags != fdb_flags) {\n\t\t\tf->flags = fdb_flags;\n\t\t\tf->updated = jiffies;\n\t\t\tnotify = 1;\n\t\t}\n\t}\n\n\tif ((flags & NLM_F_REPLACE)) {\n\t\t \n\t\tif (!(is_multicast_ether_addr(f->eth_addr) ||\n\t\t      is_zero_ether_addr(f->eth_addr))) {\n\t\t\tif (nhid) {\n\t\t\t\trc = vxlan_fdb_nh_update(vxlan, f, nhid, extack);\n\t\t\t\tif (rc < 0)\n\t\t\t\t\treturn rc;\n\t\t\t} else {\n\t\t\t\trc = vxlan_fdb_replace(f, ip, port, vni,\n\t\t\t\t\t\t       ifindex, &oldrd);\n\t\t\t}\n\t\t\tnotify |= rc;\n\t\t} else {\n\t\t\tNL_SET_ERR_MSG(extack, \"Cannot replace non-unicast fdb entries\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\tif ((flags & NLM_F_APPEND) &&\n\t    (is_multicast_ether_addr(f->eth_addr) ||\n\t     is_zero_ether_addr(f->eth_addr))) {\n\t\trc = vxlan_fdb_append(f, ip, port, vni, ifindex, &rd);\n\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tnotify |= rc;\n\t}\n\n\tif (ndm_flags & NTF_USE)\n\t\tf->used = jiffies;\n\n\tif (notify) {\n\t\tif (rd == NULL)\n\t\t\trd = first_remote_rtnl(f);\n\n\t\terr = vxlan_fdb_notify(vxlan, f, rd, RTM_NEWNEIGH,\n\t\t\t\t       swdev_notify, extack);\n\t\tif (err)\n\t\t\tgoto err_notify;\n\t}\n\n\treturn 0;\n\nerr_notify:\n\tif (nhid)\n\t\treturn err;\n\tif ((flags & NLM_F_REPLACE) && rc)\n\t\t*rd = oldrd;\n\telse if ((flags & NLM_F_APPEND) && rc) {\n\t\tlist_del_rcu(&rd->list);\n\t\tcall_rcu(&rd->rcu, vxlan_dst_free);\n\t}\n\treturn err;\n}\n\nstatic int vxlan_fdb_update_create(struct vxlan_dev *vxlan,\n\t\t\t\t   const u8 *mac, union vxlan_addr *ip,\n\t\t\t\t   __u16 state, __u16 flags,\n\t\t\t\t   __be16 port, __be32 src_vni, __be32 vni,\n\t\t\t\t   __u32 ifindex, __u16 ndm_flags, u32 nhid,\n\t\t\t\t   bool swdev_notify,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\t__u16 fdb_flags = (ndm_flags & ~NTF_USE);\n\tstruct vxlan_fdb *f;\n\tint rc;\n\n\t \n\tif ((flags & NLM_F_REPLACE) &&\n\t    (is_multicast_ether_addr(mac) || is_zero_ether_addr(mac)))\n\t\treturn -EOPNOTSUPP;\n\n\tnetdev_dbg(vxlan->dev, \"add %pM -> %pIS\\n\", mac, ip);\n\trc = vxlan_fdb_create(vxlan, mac, ip, state, port, src_vni,\n\t\t\t      vni, ifindex, fdb_flags, nhid, &f, extack);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tvxlan_fdb_insert(vxlan, mac, src_vni, f);\n\trc = vxlan_fdb_notify(vxlan, f, first_remote_rtnl(f), RTM_NEWNEIGH,\n\t\t\t      swdev_notify, extack);\n\tif (rc)\n\t\tgoto err_notify;\n\n\treturn 0;\n\nerr_notify:\n\tvxlan_fdb_destroy(vxlan, f, false, false);\n\treturn rc;\n}\n\n \nint vxlan_fdb_update(struct vxlan_dev *vxlan,\n\t\t     const u8 *mac, union vxlan_addr *ip,\n\t\t     __u16 state, __u16 flags,\n\t\t     __be16 port, __be32 src_vni, __be32 vni,\n\t\t     __u32 ifindex, __u16 ndm_flags, u32 nhid,\n\t\t     bool swdev_notify,\n\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_fdb *f;\n\n\tf = __vxlan_find_mac(vxlan, mac, src_vni);\n\tif (f) {\n\t\tif (flags & NLM_F_EXCL) {\n\t\t\tnetdev_dbg(vxlan->dev,\n\t\t\t\t   \"lost race to create %pM\\n\", mac);\n\t\t\treturn -EEXIST;\n\t\t}\n\n\t\treturn vxlan_fdb_update_existing(vxlan, ip, state, flags, port,\n\t\t\t\t\t\t vni, ifindex, ndm_flags, f,\n\t\t\t\t\t\t nhid, swdev_notify, extack);\n\t} else {\n\t\tif (!(flags & NLM_F_CREATE))\n\t\t\treturn -ENOENT;\n\n\t\treturn vxlan_fdb_update_create(vxlan, mac, ip, state, flags,\n\t\t\t\t\t       port, src_vni, vni, ifindex,\n\t\t\t\t\t       ndm_flags, nhid, swdev_notify,\n\t\t\t\t\t       extack);\n\t}\n}\n\nstatic void vxlan_fdb_dst_destroy(struct vxlan_dev *vxlan, struct vxlan_fdb *f,\n\t\t\t\t  struct vxlan_rdst *rd, bool swdev_notify)\n{\n\tlist_del_rcu(&rd->list);\n\tvxlan_fdb_notify(vxlan, f, rd, RTM_DELNEIGH, swdev_notify, NULL);\n\tcall_rcu(&rd->rcu, vxlan_dst_free);\n}\n\nstatic int vxlan_fdb_parse(struct nlattr *tb[], struct vxlan_dev *vxlan,\n\t\t\t   union vxlan_addr *ip, __be16 *port, __be32 *src_vni,\n\t\t\t   __be32 *vni, u32 *ifindex, u32 *nhid,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct net *net = dev_net(vxlan->dev);\n\tint err;\n\n\tif (tb[NDA_NH_ID] &&\n\t    (tb[NDA_DST] || tb[NDA_VNI] || tb[NDA_IFINDEX] || tb[NDA_PORT])) {\n\t\tNL_SET_ERR_MSG(extack, \"DST, VNI, ifindex and port are mutually exclusive with NH_ID\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (tb[NDA_DST]) {\n\t\terr = vxlan_nla_get_addr(ip, tb[NDA_DST]);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Unsupported address family\");\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tunion vxlan_addr *remote = &vxlan->default_dst.remote_ip;\n\n\t\tif (remote->sa.sa_family == AF_INET) {\n\t\t\tip->sin.sin_addr.s_addr = htonl(INADDR_ANY);\n\t\t\tip->sa.sa_family = AF_INET;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t} else {\n\t\t\tip->sin6.sin6_addr = in6addr_any;\n\t\t\tip->sa.sa_family = AF_INET6;\n#endif\n\t\t}\n\t}\n\n\tif (tb[NDA_PORT]) {\n\t\tif (nla_len(tb[NDA_PORT]) != sizeof(__be16)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid vxlan port\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*port = nla_get_be16(tb[NDA_PORT]);\n\t} else {\n\t\t*port = vxlan->cfg.dst_port;\n\t}\n\n\tif (tb[NDA_VNI]) {\n\t\tif (nla_len(tb[NDA_VNI]) != sizeof(u32)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid vni\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*vni = cpu_to_be32(nla_get_u32(tb[NDA_VNI]));\n\t} else {\n\t\t*vni = vxlan->default_dst.remote_vni;\n\t}\n\n\tif (tb[NDA_SRC_VNI]) {\n\t\tif (nla_len(tb[NDA_SRC_VNI]) != sizeof(u32)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid src vni\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*src_vni = cpu_to_be32(nla_get_u32(tb[NDA_SRC_VNI]));\n\t} else {\n\t\t*src_vni = vxlan->default_dst.remote_vni;\n\t}\n\n\tif (tb[NDA_IFINDEX]) {\n\t\tstruct net_device *tdev;\n\n\t\tif (nla_len(tb[NDA_IFINDEX]) != sizeof(u32)) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Invalid ifindex\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*ifindex = nla_get_u32(tb[NDA_IFINDEX]);\n\t\ttdev = __dev_get_by_index(net, *ifindex);\n\t\tif (!tdev) {\n\t\t\tNL_SET_ERR_MSG(extack, \"Device not found\");\n\t\t\treturn -EADDRNOTAVAIL;\n\t\t}\n\t} else {\n\t\t*ifindex = 0;\n\t}\n\n\tif (tb[NDA_NH_ID])\n\t\t*nhid = nla_get_u32(tb[NDA_NH_ID]);\n\telse\n\t\t*nhid = 0;\n\n\treturn 0;\n}\n\n \nstatic int vxlan_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],\n\t\t\t struct net_device *dev,\n\t\t\t const unsigned char *addr, u16 vid, u16 flags,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\t \n\tunion vxlan_addr ip;\n\t__be16 port;\n\t__be32 src_vni, vni;\n\tu32 ifindex, nhid;\n\tu32 hash_index;\n\tint err;\n\n\tif (!(ndm->ndm_state & (NUD_PERMANENT|NUD_REACHABLE))) {\n\t\tpr_info(\"RTM_NEWNEIGH with invalid state %#x\\n\",\n\t\t\tndm->ndm_state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!tb || (!tb[NDA_DST] && !tb[NDA_NH_ID]))\n\t\treturn -EINVAL;\n\n\terr = vxlan_fdb_parse(tb, vxlan, &ip, &port, &src_vni, &vni, &ifindex,\n\t\t\t      &nhid, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (vxlan->default_dst.remote_ip.sa.sa_family != ip.sa.sa_family)\n\t\treturn -EAFNOSUPPORT;\n\n\thash_index = fdb_head_index(vxlan, addr, src_vni);\n\tspin_lock_bh(&vxlan->hash_lock[hash_index]);\n\terr = vxlan_fdb_update(vxlan, addr, &ip, ndm->ndm_state, flags,\n\t\t\t       port, src_vni, vni, ifindex,\n\t\t\t       ndm->ndm_flags | NTF_VXLAN_ADDED_BY_USER,\n\t\t\t       nhid, true, extack);\n\tspin_unlock_bh(&vxlan->hash_lock[hash_index]);\n\n\treturn err;\n}\n\nint __vxlan_fdb_delete(struct vxlan_dev *vxlan,\n\t\t       const unsigned char *addr, union vxlan_addr ip,\n\t\t       __be16 port, __be32 src_vni, __be32 vni,\n\t\t       u32 ifindex, bool swdev_notify)\n{\n\tstruct vxlan_rdst *rd = NULL;\n\tstruct vxlan_fdb *f;\n\tint err = -ENOENT;\n\n\tf = vxlan_find_mac(vxlan, addr, src_vni);\n\tif (!f)\n\t\treturn err;\n\n\tif (!vxlan_addr_any(&ip)) {\n\t\trd = vxlan_fdb_find_rdst(f, &ip, port, vni, ifindex);\n\t\tif (!rd)\n\t\t\tgoto out;\n\t}\n\n\t \n\tif (rd && !list_is_singular(&f->remotes)) {\n\t\tvxlan_fdb_dst_destroy(vxlan, f, rd, swdev_notify);\n\t\tgoto out;\n\t}\n\n\tvxlan_fdb_destroy(vxlan, f, true, swdev_notify);\n\nout:\n\treturn 0;\n}\n\n \nstatic int vxlan_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],\n\t\t\t    struct net_device *dev,\n\t\t\t    const unsigned char *addr, u16 vid,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tunion vxlan_addr ip;\n\t__be32 src_vni, vni;\n\tu32 ifindex, nhid;\n\tu32 hash_index;\n\t__be16 port;\n\tint err;\n\n\terr = vxlan_fdb_parse(tb, vxlan, &ip, &port, &src_vni, &vni, &ifindex,\n\t\t\t      &nhid, extack);\n\tif (err)\n\t\treturn err;\n\n\thash_index = fdb_head_index(vxlan, addr, src_vni);\n\tspin_lock_bh(&vxlan->hash_lock[hash_index]);\n\terr = __vxlan_fdb_delete(vxlan, addr, ip, port, src_vni, vni, ifindex,\n\t\t\t\t true);\n\tspin_unlock_bh(&vxlan->hash_lock[hash_index]);\n\n\treturn err;\n}\n\n \nstatic int vxlan_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb,\n\t\t\t  struct net_device *dev,\n\t\t\t  struct net_device *filter_dev, int *idx)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tunsigned int h;\n\tint err = 0;\n\n\tfor (h = 0; h < FDB_HASH_SIZE; ++h) {\n\t\tstruct vxlan_fdb *f;\n\n\t\trcu_read_lock();\n\t\thlist_for_each_entry_rcu(f, &vxlan->fdb_head[h], hlist) {\n\t\t\tstruct vxlan_rdst *rd;\n\n\t\t\tif (rcu_access_pointer(f->nh)) {\n\t\t\t\tif (*idx < cb->args[2])\n\t\t\t\t\tgoto skip_nh;\n\t\t\t\terr = vxlan_fdb_info(skb, vxlan, f,\n\t\t\t\t\t\t     NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t     cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t     RTM_NEWNEIGH,\n\t\t\t\t\t\t     NLM_F_MULTI, NULL);\n\t\t\t\tif (err < 0) {\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\tgoto out;\n\t\t\t\t}\nskip_nh:\n\t\t\t\t*idx += 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlist_for_each_entry_rcu(rd, &f->remotes, list) {\n\t\t\t\tif (*idx < cb->args[2])\n\t\t\t\t\tgoto skip;\n\n\t\t\t\terr = vxlan_fdb_info(skb, vxlan, f,\n\t\t\t\t\t\t     NETLINK_CB(cb->skb).portid,\n\t\t\t\t\t\t     cb->nlh->nlmsg_seq,\n\t\t\t\t\t\t     RTM_NEWNEIGH,\n\t\t\t\t\t\t     NLM_F_MULTI, rd);\n\t\t\t\tif (err < 0) {\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\tgoto out;\n\t\t\t\t}\nskip:\n\t\t\t\t*idx += 1;\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\t}\nout:\n\treturn err;\n}\n\nstatic int vxlan_fdb_get(struct sk_buff *skb,\n\t\t\t struct nlattr *tb[],\n\t\t\t struct net_device *dev,\n\t\t\t const unsigned char *addr,\n\t\t\t u16 vid, u32 portid, u32 seq,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tstruct vxlan_fdb *f;\n\t__be32 vni;\n\tint err;\n\n\tif (tb[NDA_VNI])\n\t\tvni = cpu_to_be32(nla_get_u32(tb[NDA_VNI]));\n\telse\n\t\tvni = vxlan->default_dst.remote_vni;\n\n\trcu_read_lock();\n\n\tf = __vxlan_find_mac(vxlan, addr, vni);\n\tif (!f) {\n\t\tNL_SET_ERR_MSG(extack, \"Fdb entry not found\");\n\t\terr = -ENOENT;\n\t\tgoto errout;\n\t}\n\n\terr = vxlan_fdb_info(skb, vxlan, f, portid, seq,\n\t\t\t     RTM_NEWNEIGH, 0, first_remote_rcu(f));\nerrout:\n\trcu_read_unlock();\n\treturn err;\n}\n\n \nstatic bool vxlan_snoop(struct net_device *dev,\n\t\t\tunion vxlan_addr *src_ip, const u8 *src_mac,\n\t\t\tu32 src_ifindex, __be32 vni)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tstruct vxlan_fdb *f;\n\tu32 ifindex = 0;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (src_ip->sa.sa_family == AF_INET6 &&\n\t    (ipv6_addr_type(&src_ip->sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL))\n\t\tifindex = src_ifindex;\n#endif\n\n\tf = vxlan_find_mac(vxlan, src_mac, vni);\n\tif (likely(f)) {\n\t\tstruct vxlan_rdst *rdst = first_remote_rcu(f);\n\n\t\tif (likely(vxlan_addr_equal(&rdst->remote_ip, src_ip) &&\n\t\t\t   rdst->remote_ifindex == ifindex))\n\t\t\treturn false;\n\n\t\t \n\t\tif (f->state & (NUD_PERMANENT | NUD_NOARP))\n\t\t\treturn true;\n\n\t\t \n\t\tif (rcu_access_pointer(f->nh))\n\t\t\treturn true;\n\n\t\tif (net_ratelimit())\n\t\t\tnetdev_info(dev,\n\t\t\t\t    \"%pM migrated from %pIS to %pIS\\n\",\n\t\t\t\t    src_mac, &rdst->remote_ip.sa, &src_ip->sa);\n\n\t\trdst->remote_ip = *src_ip;\n\t\tf->updated = jiffies;\n\t\tvxlan_fdb_notify(vxlan, f, rdst, RTM_NEWNEIGH, true, NULL);\n\t} else {\n\t\tu32 hash_index = fdb_head_index(vxlan, src_mac, vni);\n\n\t\t \n\t\tspin_lock(&vxlan->hash_lock[hash_index]);\n\n\t\t \n\t\tif (netif_running(dev))\n\t\t\tvxlan_fdb_update(vxlan, src_mac, src_ip,\n\t\t\t\t\t NUD_REACHABLE,\n\t\t\t\t\t NLM_F_EXCL|NLM_F_CREATE,\n\t\t\t\t\t vxlan->cfg.dst_port,\n\t\t\t\t\t vni,\n\t\t\t\t\t vxlan->default_dst.remote_vni,\n\t\t\t\t\t ifindex, NTF_SELF, 0, true, NULL);\n\t\tspin_unlock(&vxlan->hash_lock[hash_index]);\n\t}\n\n\treturn false;\n}\n\nstatic bool __vxlan_sock_release_prep(struct vxlan_sock *vs)\n{\n\tstruct vxlan_net *vn;\n\n\tif (!vs)\n\t\treturn false;\n\tif (!refcount_dec_and_test(&vs->refcnt))\n\t\treturn false;\n\n\tvn = net_generic(sock_net(vs->sock->sk), vxlan_net_id);\n\tspin_lock(&vn->sock_lock);\n\thlist_del_rcu(&vs->hlist);\n\tudp_tunnel_notify_del_rx_port(vs->sock,\n\t\t\t\t      (vs->flags & VXLAN_F_GPE) ?\n\t\t\t\t      UDP_TUNNEL_TYPE_VXLAN_GPE :\n\t\t\t\t      UDP_TUNNEL_TYPE_VXLAN);\n\tspin_unlock(&vn->sock_lock);\n\n\treturn true;\n}\n\nstatic void vxlan_sock_release(struct vxlan_dev *vxlan)\n{\n\tstruct vxlan_sock *sock4 = rtnl_dereference(vxlan->vn4_sock);\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct vxlan_sock *sock6 = rtnl_dereference(vxlan->vn6_sock);\n\n\tRCU_INIT_POINTER(vxlan->vn6_sock, NULL);\n#endif\n\n\tRCU_INIT_POINTER(vxlan->vn4_sock, NULL);\n\tsynchronize_net();\n\n\tif (vxlan->cfg.flags & VXLAN_F_VNIFILTER)\n\t\tvxlan_vs_del_vnigrp(vxlan);\n\telse\n\t\tvxlan_vs_del_dev(vxlan);\n\n\tif (__vxlan_sock_release_prep(sock4)) {\n\t\tudp_tunnel_sock_release(sock4->sock);\n\t\tkfree(sock4);\n\t}\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (__vxlan_sock_release_prep(sock6)) {\n\t\tudp_tunnel_sock_release(sock6->sock);\n\t\tkfree(sock6);\n\t}\n#endif\n}\n\nstatic bool vxlan_remcsum(struct vxlanhdr *unparsed,\n\t\t\t  struct sk_buff *skb, u32 vxflags)\n{\n\tsize_t start, offset;\n\n\tif (!(unparsed->vx_flags & VXLAN_HF_RCO) || skb->remcsum_offload)\n\t\tgoto out;\n\n\tstart = vxlan_rco_start(unparsed->vx_vni);\n\toffset = start + vxlan_rco_offset(unparsed->vx_vni);\n\n\tif (!pskb_may_pull(skb, offset + sizeof(u16)))\n\t\treturn false;\n\n\tskb_remcsum_process(skb, (void *)(vxlan_hdr(skb) + 1), start, offset,\n\t\t\t    !!(vxflags & VXLAN_F_REMCSUM_NOPARTIAL));\nout:\n\tunparsed->vx_flags &= ~VXLAN_HF_RCO;\n\tunparsed->vx_vni &= VXLAN_VNI_MASK;\n\treturn true;\n}\n\nstatic void vxlan_parse_gbp_hdr(struct vxlanhdr *unparsed,\n\t\t\t\tstruct sk_buff *skb, u32 vxflags,\n\t\t\t\tstruct vxlan_metadata *md)\n{\n\tstruct vxlanhdr_gbp *gbp = (struct vxlanhdr_gbp *)unparsed;\n\tstruct metadata_dst *tun_dst;\n\n\tif (!(unparsed->vx_flags & VXLAN_HF_GBP))\n\t\tgoto out;\n\n\tmd->gbp = ntohs(gbp->policy_id);\n\n\ttun_dst = (struct metadata_dst *)skb_dst(skb);\n\tif (tun_dst) {\n\t\ttun_dst->u.tun_info.key.tun_flags |= TUNNEL_VXLAN_OPT;\n\t\ttun_dst->u.tun_info.options_len = sizeof(*md);\n\t}\n\tif (gbp->dont_learn)\n\t\tmd->gbp |= VXLAN_GBP_DONT_LEARN;\n\n\tif (gbp->policy_applied)\n\t\tmd->gbp |= VXLAN_GBP_POLICY_APPLIED;\n\n\t \n\tif (!(vxflags & VXLAN_F_COLLECT_METADATA))\n\t\tskb->mark = md->gbp;\nout:\n\tunparsed->vx_flags &= ~VXLAN_GBP_USED_BITS;\n}\n\nstatic bool vxlan_set_mac(struct vxlan_dev *vxlan,\n\t\t\t  struct vxlan_sock *vs,\n\t\t\t  struct sk_buff *skb, __be32 vni)\n{\n\tunion vxlan_addr saddr;\n\tu32 ifindex = skb->dev->ifindex;\n\n\tskb_reset_mac_header(skb);\n\tskb->protocol = eth_type_trans(skb, vxlan->dev);\n\tskb_postpull_rcsum(skb, eth_hdr(skb), ETH_HLEN);\n\n\t \n\tif (ether_addr_equal(eth_hdr(skb)->h_source, vxlan->dev->dev_addr))\n\t\treturn false;\n\n\t \n\tif (vxlan_get_sk_family(vs) == AF_INET) {\n\t\tsaddr.sin.sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tsaddr.sa.sa_family = AF_INET;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else {\n\t\tsaddr.sin6.sin6_addr = ipv6_hdr(skb)->saddr;\n\t\tsaddr.sa.sa_family = AF_INET6;\n#endif\n\t}\n\n\tif ((vxlan->cfg.flags & VXLAN_F_LEARN) &&\n\t    vxlan_snoop(skb->dev, &saddr, eth_hdr(skb)->h_source, ifindex, vni))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool vxlan_ecn_decapsulate(struct vxlan_sock *vs, void *oiph,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tint err = 0;\n\n\tif (vxlan_get_sk_family(vs) == AF_INET)\n\t\terr = IP_ECN_decapsulate(oiph, skb);\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\terr = IP6_ECN_decapsulate(oiph, skb);\n#endif\n\n\tif (unlikely(err) && log_ecn_error) {\n\t\tif (vxlan_get_sk_family(vs) == AF_INET)\n\t\t\tnet_info_ratelimited(\"non-ECT from %pI4 with TOS=%#x\\n\",\n\t\t\t\t\t     &((struct iphdr *)oiph)->saddr,\n\t\t\t\t\t     ((struct iphdr *)oiph)->tos);\n\t\telse\n\t\t\tnet_info_ratelimited(\"non-ECT from %pI6\\n\",\n\t\t\t\t\t     &((struct ipv6hdr *)oiph)->saddr);\n\t}\n\treturn err <= 1;\n}\n\n \nstatic int vxlan_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct vxlan_vni_node *vninode = NULL;\n\tstruct vxlan_dev *vxlan;\n\tstruct vxlan_sock *vs;\n\tstruct vxlanhdr unparsed;\n\tstruct vxlan_metadata _md;\n\tstruct vxlan_metadata *md = &_md;\n\t__be16 protocol = htons(ETH_P_TEB);\n\tbool raw_proto = false;\n\tvoid *oiph;\n\t__be32 vni = 0;\n\n\t \n\tif (!pskb_may_pull(skb, VXLAN_HLEN))\n\t\tgoto drop;\n\n\tunparsed = *vxlan_hdr(skb);\n\t \n\tif (!(unparsed.vx_flags & VXLAN_HF_VNI)) {\n\t\tnetdev_dbg(skb->dev, \"invalid vxlan flags=%#x vni=%#x\\n\",\n\t\t\t   ntohl(vxlan_hdr(skb)->vx_flags),\n\t\t\t   ntohl(vxlan_hdr(skb)->vx_vni));\n\t\t \n\t\tgoto drop;\n\t}\n\tunparsed.vx_flags &= ~VXLAN_HF_VNI;\n\tunparsed.vx_vni &= ~VXLAN_VNI_MASK;\n\n\tvs = rcu_dereference_sk_user_data(sk);\n\tif (!vs)\n\t\tgoto drop;\n\n\tvni = vxlan_vni(vxlan_hdr(skb)->vx_vni);\n\n\tvxlan = vxlan_vs_find_vni(vs, skb->dev->ifindex, vni, &vninode);\n\tif (!vxlan)\n\t\tgoto drop;\n\n\t \n\tif (vs->flags & VXLAN_F_GPE) {\n\t\tif (!vxlan_parse_gpe_proto(&unparsed, &protocol))\n\t\t\tgoto drop;\n\t\tunparsed.vx_flags &= ~VXLAN_GPE_USED_BITS;\n\t\traw_proto = true;\n\t}\n\n\tif (__iptunnel_pull_header(skb, VXLAN_HLEN, protocol, raw_proto,\n\t\t\t\t   !net_eq(vxlan->net, dev_net(vxlan->dev))))\n\t\tgoto drop;\n\n\tif (vs->flags & VXLAN_F_REMCSUM_RX)\n\t\tif (unlikely(!vxlan_remcsum(&unparsed, skb, vs->flags)))\n\t\t\tgoto drop;\n\n\tif (vxlan_collect_metadata(vs)) {\n\t\tstruct metadata_dst *tun_dst;\n\n\t\ttun_dst = udp_tun_rx_dst(skb, vxlan_get_sk_family(vs), TUNNEL_KEY,\n\t\t\t\t\t key32_to_tunnel_id(vni), sizeof(*md));\n\n\t\tif (!tun_dst)\n\t\t\tgoto drop;\n\n\t\tmd = ip_tunnel_info_opts(&tun_dst->u.tun_info);\n\n\t\tskb_dst_set(skb, (struct dst_entry *)tun_dst);\n\t} else {\n\t\tmemset(md, 0, sizeof(*md));\n\t}\n\n\tif (vs->flags & VXLAN_F_GBP)\n\t\tvxlan_parse_gbp_hdr(&unparsed, skb, vs->flags, md);\n\t \n\n\tif (unparsed.vx_flags || unparsed.vx_vni) {\n\t\t \n\t\tgoto drop;\n\t}\n\n\tif (!raw_proto) {\n\t\tif (!vxlan_set_mac(vxlan, vs, skb, vni))\n\t\t\tgoto drop;\n\t} else {\n\t\tskb_reset_mac_header(skb);\n\t\tskb->dev = vxlan->dev;\n\t\tskb->pkt_type = PACKET_HOST;\n\t}\n\n\toiph = skb_network_header(skb);\n\tskb_reset_network_header(skb);\n\n\tif (!vxlan_ecn_decapsulate(vs, oiph, skb)) {\n\t\t++vxlan->dev->stats.rx_frame_errors;\n\t\t++vxlan->dev->stats.rx_errors;\n\t\tvxlan_vnifilter_count(vxlan, vni, vninode,\n\t\t\t\t      VXLAN_VNI_STATS_RX_ERRORS, 0);\n\t\tgoto drop;\n\t}\n\n\trcu_read_lock();\n\n\tif (unlikely(!(vxlan->dev->flags & IFF_UP))) {\n\t\trcu_read_unlock();\n\t\tdev_core_stats_rx_dropped_inc(vxlan->dev);\n\t\tvxlan_vnifilter_count(vxlan, vni, vninode,\n\t\t\t\t      VXLAN_VNI_STATS_RX_DROPS, 0);\n\t\tgoto drop;\n\t}\n\n\tdev_sw_netstats_rx_add(vxlan->dev, skb->len);\n\tvxlan_vnifilter_count(vxlan, vni, vninode, VXLAN_VNI_STATS_RX, skb->len);\n\tgro_cells_receive(&vxlan->gro_cells, skb);\n\n\trcu_read_unlock();\n\n\treturn 0;\n\ndrop:\n\t \n\tkfree_skb(skb);\n\treturn 0;\n}\n\n \nstatic int vxlan_err_lookup(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct vxlan_dev *vxlan;\n\tstruct vxlan_sock *vs;\n\tstruct vxlanhdr *hdr;\n\t__be32 vni;\n\n\tif (!pskb_may_pull(skb, skb_transport_offset(skb) + VXLAN_HLEN))\n\t\treturn -EINVAL;\n\n\thdr = vxlan_hdr(skb);\n\n\tif (!(hdr->vx_flags & VXLAN_HF_VNI))\n\t\treturn -EINVAL;\n\n\tvs = rcu_dereference_sk_user_data(sk);\n\tif (!vs)\n\t\treturn -ENOENT;\n\n\tvni = vxlan_vni(hdr->vx_vni);\n\tvxlan = vxlan_vs_find_vni(vs, skb->dev->ifindex, vni, NULL);\n\tif (!vxlan)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\nstatic int arp_reduce(struct net_device *dev, struct sk_buff *skb, __be32 vni)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tstruct arphdr *parp;\n\tu8 *arpptr, *sha;\n\t__be32 sip, tip;\n\tstruct neighbour *n;\n\n\tif (dev->flags & IFF_NOARP)\n\t\tgoto out;\n\n\tif (!pskb_may_pull(skb, arp_hdr_len(dev))) {\n\t\tdev->stats.tx_dropped++;\n\t\tgoto out;\n\t}\n\tparp = arp_hdr(skb);\n\n\tif ((parp->ar_hrd != htons(ARPHRD_ETHER) &&\n\t     parp->ar_hrd != htons(ARPHRD_IEEE802)) ||\n\t    parp->ar_pro != htons(ETH_P_IP) ||\n\t    parp->ar_op != htons(ARPOP_REQUEST) ||\n\t    parp->ar_hln != dev->addr_len ||\n\t    parp->ar_pln != 4)\n\t\tgoto out;\n\tarpptr = (u8 *)parp + sizeof(struct arphdr);\n\tsha = arpptr;\n\tarpptr += dev->addr_len;\t \n\tmemcpy(&sip, arpptr, sizeof(sip));\n\tarpptr += sizeof(sip);\n\tarpptr += dev->addr_len;\t \n\tmemcpy(&tip, arpptr, sizeof(tip));\n\n\tif (ipv4_is_loopback(tip) ||\n\t    ipv4_is_multicast(tip))\n\t\tgoto out;\n\n\tn = neigh_lookup(&arp_tbl, &tip, dev);\n\n\tif (n) {\n\t\tstruct vxlan_fdb *f;\n\t\tstruct sk_buff\t*reply;\n\n\t\tif (!(READ_ONCE(n->nud_state) & NUD_CONNECTED)) {\n\t\t\tneigh_release(n);\n\t\t\tgoto out;\n\t\t}\n\n\t\tf = vxlan_find_mac(vxlan, n->ha, vni);\n\t\tif (f && vxlan_addr_any(&(first_remote_rcu(f)->remote_ip))) {\n\t\t\t \n\t\t\tneigh_release(n);\n\t\t\tgoto out;\n\t\t}\n\n\t\treply = arp_create(ARPOP_REPLY, ETH_P_ARP, sip, dev, tip, sha,\n\t\t\t\tn->ha, sha);\n\n\t\tneigh_release(n);\n\n\t\tif (reply == NULL)\n\t\t\tgoto out;\n\n\t\tskb_reset_mac_header(reply);\n\t\t__skb_pull(reply, skb_network_offset(reply));\n\t\treply->ip_summed = CHECKSUM_UNNECESSARY;\n\t\treply->pkt_type = PACKET_HOST;\n\n\t\tif (netif_rx(reply) == NET_RX_DROP) {\n\t\t\tdev->stats.rx_dropped++;\n\t\t\tvxlan_vnifilter_count(vxlan, vni, NULL,\n\t\t\t\t\t      VXLAN_VNI_STATS_RX_DROPS, 0);\n\t\t}\n\n\t} else if (vxlan->cfg.flags & VXLAN_F_L3MISS) {\n\t\tunion vxlan_addr ipa = {\n\t\t\t.sin.sin_addr.s_addr = tip,\n\t\t\t.sin.sin_family = AF_INET,\n\t\t};\n\n\t\tvxlan_ip_miss(dev, &ipa);\n\t}\nout:\n\tconsume_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic struct sk_buff *vxlan_na_create(struct sk_buff *request,\n\tstruct neighbour *n, bool isrouter)\n{\n\tstruct net_device *dev = request->dev;\n\tstruct sk_buff *reply;\n\tstruct nd_msg *ns, *na;\n\tstruct ipv6hdr *pip6;\n\tu8 *daddr;\n\tint na_olen = 8;  \n\tint ns_olen;\n\tint i, len;\n\n\tif (dev == NULL || !pskb_may_pull(request, request->len))\n\t\treturn NULL;\n\n\tlen = LL_RESERVED_SPACE(dev) + sizeof(struct ipv6hdr) +\n\t\tsizeof(*na) + na_olen + dev->needed_tailroom;\n\treply = alloc_skb(len, GFP_ATOMIC);\n\tif (reply == NULL)\n\t\treturn NULL;\n\n\treply->protocol = htons(ETH_P_IPV6);\n\treply->dev = dev;\n\tskb_reserve(reply, LL_RESERVED_SPACE(request->dev));\n\tskb_push(reply, sizeof(struct ethhdr));\n\tskb_reset_mac_header(reply);\n\n\tns = (struct nd_msg *)(ipv6_hdr(request) + 1);\n\n\tdaddr = eth_hdr(request)->h_source;\n\tns_olen = request->len - skb_network_offset(request) -\n\t\tsizeof(struct ipv6hdr) - sizeof(*ns);\n\tfor (i = 0; i < ns_olen-1; i += (ns->opt[i+1]<<3)) {\n\t\tif (!ns->opt[i + 1]) {\n\t\t\tkfree_skb(reply);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (ns->opt[i] == ND_OPT_SOURCE_LL_ADDR) {\n\t\t\tdaddr = ns->opt + i + sizeof(struct nd_opt_hdr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tether_addr_copy(eth_hdr(reply)->h_dest, daddr);\n\tether_addr_copy(eth_hdr(reply)->h_source, n->ha);\n\teth_hdr(reply)->h_proto = htons(ETH_P_IPV6);\n\treply->protocol = htons(ETH_P_IPV6);\n\n\tskb_pull(reply, sizeof(struct ethhdr));\n\tskb_reset_network_header(reply);\n\tskb_put(reply, sizeof(struct ipv6hdr));\n\n\t \n\n\tpip6 = ipv6_hdr(reply);\n\tmemset(pip6, 0, sizeof(struct ipv6hdr));\n\tpip6->version = 6;\n\tpip6->priority = ipv6_hdr(request)->priority;\n\tpip6->nexthdr = IPPROTO_ICMPV6;\n\tpip6->hop_limit = 255;\n\tpip6->daddr = ipv6_hdr(request)->saddr;\n\tpip6->saddr = *(struct in6_addr *)n->primary_key;\n\n\tskb_pull(reply, sizeof(struct ipv6hdr));\n\tskb_reset_transport_header(reply);\n\n\t \n\tna = skb_put_zero(reply, sizeof(*na) + na_olen);\n\tna->icmph.icmp6_type = NDISC_NEIGHBOUR_ADVERTISEMENT;\n\tna->icmph.icmp6_router = isrouter;\n\tna->icmph.icmp6_override = 1;\n\tna->icmph.icmp6_solicited = 1;\n\tna->target = ns->target;\n\tether_addr_copy(&na->opt[2], n->ha);\n\tna->opt[0] = ND_OPT_TARGET_LL_ADDR;\n\tna->opt[1] = na_olen >> 3;\n\n\tna->icmph.icmp6_cksum = csum_ipv6_magic(&pip6->saddr,\n\t\t&pip6->daddr, sizeof(*na)+na_olen, IPPROTO_ICMPV6,\n\t\tcsum_partial(na, sizeof(*na)+na_olen, 0));\n\n\tpip6->payload_len = htons(sizeof(*na)+na_olen);\n\n\tskb_push(reply, sizeof(struct ipv6hdr));\n\n\treply->ip_summed = CHECKSUM_UNNECESSARY;\n\n\treturn reply;\n}\n\nstatic int neigh_reduce(struct net_device *dev, struct sk_buff *skb, __be32 vni)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tconst struct in6_addr *daddr;\n\tconst struct ipv6hdr *iphdr;\n\tstruct inet6_dev *in6_dev;\n\tstruct neighbour *n;\n\tstruct nd_msg *msg;\n\n\trcu_read_lock();\n\tin6_dev = __in6_dev_get(dev);\n\tif (!in6_dev)\n\t\tgoto out;\n\n\tiphdr = ipv6_hdr(skb);\n\tdaddr = &iphdr->daddr;\n\tmsg = (struct nd_msg *)(iphdr + 1);\n\n\tif (ipv6_addr_loopback(daddr) ||\n\t    ipv6_addr_is_multicast(&msg->target))\n\t\tgoto out;\n\n\tn = neigh_lookup(ipv6_stub->nd_tbl, &msg->target, dev);\n\n\tif (n) {\n\t\tstruct vxlan_fdb *f;\n\t\tstruct sk_buff *reply;\n\n\t\tif (!(READ_ONCE(n->nud_state) & NUD_CONNECTED)) {\n\t\t\tneigh_release(n);\n\t\t\tgoto out;\n\t\t}\n\n\t\tf = vxlan_find_mac(vxlan, n->ha, vni);\n\t\tif (f && vxlan_addr_any(&(first_remote_rcu(f)->remote_ip))) {\n\t\t\t \n\t\t\tneigh_release(n);\n\t\t\tgoto out;\n\t\t}\n\n\t\treply = vxlan_na_create(skb, n,\n\t\t\t\t\t!!(f ? f->flags & NTF_ROUTER : 0));\n\n\t\tneigh_release(n);\n\n\t\tif (reply == NULL)\n\t\t\tgoto out;\n\n\t\tif (netif_rx(reply) == NET_RX_DROP) {\n\t\t\tdev->stats.rx_dropped++;\n\t\t\tvxlan_vnifilter_count(vxlan, vni, NULL,\n\t\t\t\t\t      VXLAN_VNI_STATS_RX_DROPS, 0);\n\t\t}\n\t} else if (vxlan->cfg.flags & VXLAN_F_L3MISS) {\n\t\tunion vxlan_addr ipa = {\n\t\t\t.sin6.sin6_addr = msg->target,\n\t\t\t.sin6.sin6_family = AF_INET6,\n\t\t};\n\n\t\tvxlan_ip_miss(dev, &ipa);\n\t}\n\nout:\n\trcu_read_unlock();\n\tconsume_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n#endif\n\nstatic bool route_shortcircuit(struct net_device *dev, struct sk_buff *skb)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tstruct neighbour *n;\n\n\tif (is_multicast_ether_addr(eth_hdr(skb)->h_dest))\n\t\treturn false;\n\n\tn = NULL;\n\tswitch (ntohs(eth_hdr(skb)->h_proto)) {\n\tcase ETH_P_IP:\n\t{\n\t\tstruct iphdr *pip;\n\n\t\tif (!pskb_may_pull(skb, sizeof(struct iphdr)))\n\t\t\treturn false;\n\t\tpip = ip_hdr(skb);\n\t\tn = neigh_lookup(&arp_tbl, &pip->daddr, dev);\n\t\tif (!n && (vxlan->cfg.flags & VXLAN_F_L3MISS)) {\n\t\t\tunion vxlan_addr ipa = {\n\t\t\t\t.sin.sin_addr.s_addr = pip->daddr,\n\t\t\t\t.sin.sin_family = AF_INET,\n\t\t\t};\n\n\t\t\tvxlan_ip_miss(dev, &ipa);\n\t\t\treturn false;\n\t\t}\n\n\t\tbreak;\n\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase ETH_P_IPV6:\n\t{\n\t\tstruct ipv6hdr *pip6;\n\n\t\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\t\treturn false;\n\t\tpip6 = ipv6_hdr(skb);\n\t\tn = neigh_lookup(ipv6_stub->nd_tbl, &pip6->daddr, dev);\n\t\tif (!n && (vxlan->cfg.flags & VXLAN_F_L3MISS)) {\n\t\t\tunion vxlan_addr ipa = {\n\t\t\t\t.sin6.sin6_addr = pip6->daddr,\n\t\t\t\t.sin6.sin6_family = AF_INET6,\n\t\t\t};\n\n\t\t\tvxlan_ip_miss(dev, &ipa);\n\t\t\treturn false;\n\t\t}\n\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\treturn false;\n\t}\n\n\tif (n) {\n\t\tbool diff;\n\n\t\tdiff = !ether_addr_equal(eth_hdr(skb)->h_dest, n->ha);\n\t\tif (diff) {\n\t\t\tmemcpy(eth_hdr(skb)->h_source, eth_hdr(skb)->h_dest,\n\t\t\t\tdev->addr_len);\n\t\t\tmemcpy(eth_hdr(skb)->h_dest, n->ha, dev->addr_len);\n\t\t}\n\t\tneigh_release(n);\n\t\treturn diff;\n\t}\n\n\treturn false;\n}\n\nstatic int vxlan_build_gpe_hdr(struct vxlanhdr *vxh, __be16 protocol)\n{\n\tstruct vxlanhdr_gpe *gpe = (struct vxlanhdr_gpe *)vxh;\n\n\tgpe->np_applied = 1;\n\tgpe->next_protocol = tun_p_from_eth_p(protocol);\n\tif (!gpe->next_protocol)\n\t\treturn -EPFNOSUPPORT;\n\treturn 0;\n}\n\nstatic int vxlan_build_skb(struct sk_buff *skb, struct dst_entry *dst,\n\t\t\t   int iphdr_len, __be32 vni,\n\t\t\t   struct vxlan_metadata *md, u32 vxflags,\n\t\t\t   bool udp_sum)\n{\n\tstruct vxlanhdr *vxh;\n\tint min_headroom;\n\tint err;\n\tint type = udp_sum ? SKB_GSO_UDP_TUNNEL_CSUM : SKB_GSO_UDP_TUNNEL;\n\t__be16 inner_protocol = htons(ETH_P_TEB);\n\n\tif ((vxflags & VXLAN_F_REMCSUM_TX) &&\n\t    skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\tint csum_start = skb_checksum_start_offset(skb);\n\n\t\tif (csum_start <= VXLAN_MAX_REMCSUM_START &&\n\t\t    !(csum_start & VXLAN_RCO_SHIFT_MASK) &&\n\t\t    (skb->csum_offset == offsetof(struct udphdr, check) ||\n\t\t     skb->csum_offset == offsetof(struct tcphdr, check)))\n\t\t\ttype |= SKB_GSO_TUNNEL_REMCSUM;\n\t}\n\n\tmin_headroom = LL_RESERVED_SPACE(dst->dev) + dst->header_len\n\t\t\t+ VXLAN_HLEN + iphdr_len;\n\n\t \n\terr = skb_cow_head(skb, min_headroom);\n\tif (unlikely(err))\n\t\treturn err;\n\n\terr = iptunnel_handle_offloads(skb, type);\n\tif (err)\n\t\treturn err;\n\n\tvxh = __skb_push(skb, sizeof(*vxh));\n\tvxh->vx_flags = VXLAN_HF_VNI;\n\tvxh->vx_vni = vxlan_vni_field(vni);\n\n\tif (type & SKB_GSO_TUNNEL_REMCSUM) {\n\t\tunsigned int start;\n\n\t\tstart = skb_checksum_start_offset(skb) - sizeof(struct vxlanhdr);\n\t\tvxh->vx_vni |= vxlan_compute_rco(start, skb->csum_offset);\n\t\tvxh->vx_flags |= VXLAN_HF_RCO;\n\n\t\tif (!skb_is_gso(skb)) {\n\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t\tskb->encapsulation = 0;\n\t\t}\n\t}\n\n\tif (vxflags & VXLAN_F_GBP)\n\t\tvxlan_build_gbp_hdr(vxh, md);\n\tif (vxflags & VXLAN_F_GPE) {\n\t\terr = vxlan_build_gpe_hdr(vxh, skb->protocol);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tinner_protocol = skb->protocol;\n\t}\n\n\tskb_set_inner_protocol(skb, inner_protocol);\n\treturn 0;\n}\n\nstatic struct rtable *vxlan_get_route(struct vxlan_dev *vxlan, struct net_device *dev,\n\t\t\t\t      struct vxlan_sock *sock4,\n\t\t\t\t      struct sk_buff *skb, int oif, u8 tos,\n\t\t\t\t      __be32 daddr, __be32 *saddr, __be16 dport, __be16 sport,\n\t\t\t\t      __u8 flow_flags, struct dst_cache *dst_cache,\n\t\t\t\t      const struct ip_tunnel_info *info)\n{\n\tbool use_cache = ip_tunnel_dst_cache_usable(skb, info);\n\tstruct rtable *rt = NULL;\n\tstruct flowi4 fl4;\n\n\tif (!sock4)\n\t\treturn ERR_PTR(-EIO);\n\n\tif (tos && !info)\n\t\tuse_cache = false;\n\tif (use_cache) {\n\t\trt = dst_cache_get_ip4(dst_cache, saddr);\n\t\tif (rt)\n\t\t\treturn rt;\n\t}\n\n\tmemset(&fl4, 0, sizeof(fl4));\n\tfl4.flowi4_oif = oif;\n\tfl4.flowi4_tos = RT_TOS(tos);\n\tfl4.flowi4_mark = skb->mark;\n\tfl4.flowi4_proto = IPPROTO_UDP;\n\tfl4.daddr = daddr;\n\tfl4.saddr = *saddr;\n\tfl4.fl4_dport = dport;\n\tfl4.fl4_sport = sport;\n\tfl4.flowi4_flags = flow_flags;\n\n\trt = ip_route_output_key(vxlan->net, &fl4);\n\tif (!IS_ERR(rt)) {\n\t\tif (rt->dst.dev == dev) {\n\t\t\tnetdev_dbg(dev, \"circular route to %pI4\\n\", &daddr);\n\t\t\tip_rt_put(rt);\n\t\t\treturn ERR_PTR(-ELOOP);\n\t\t}\n\n\t\t*saddr = fl4.saddr;\n\t\tif (use_cache)\n\t\t\tdst_cache_set_ip4(dst_cache, &rt->dst, fl4.saddr);\n\t} else {\n\t\tnetdev_dbg(dev, \"no route to %pI4\\n\", &daddr);\n\t\treturn ERR_PTR(-ENETUNREACH);\n\t}\n\treturn rt;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic struct dst_entry *vxlan6_get_route(struct vxlan_dev *vxlan,\n\t\t\t\t\t  struct net_device *dev,\n\t\t\t\t\t  struct vxlan_sock *sock6,\n\t\t\t\t\t  struct sk_buff *skb, int oif, u8 tos,\n\t\t\t\t\t  __be32 label,\n\t\t\t\t\t  const struct in6_addr *daddr,\n\t\t\t\t\t  struct in6_addr *saddr,\n\t\t\t\t\t  __be16 dport, __be16 sport,\n\t\t\t\t\t  struct dst_cache *dst_cache,\n\t\t\t\t\t  const struct ip_tunnel_info *info)\n{\n\tbool use_cache = ip_tunnel_dst_cache_usable(skb, info);\n\tstruct dst_entry *ndst;\n\tstruct flowi6 fl6;\n\n\tif (!sock6)\n\t\treturn ERR_PTR(-EIO);\n\n\tif (tos && !info)\n\t\tuse_cache = false;\n\tif (use_cache) {\n\t\tndst = dst_cache_get_ip6(dst_cache, saddr);\n\t\tif (ndst)\n\t\t\treturn ndst;\n\t}\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_oif = oif;\n\tfl6.daddr = *daddr;\n\tfl6.saddr = *saddr;\n\tfl6.flowlabel = ip6_make_flowinfo(tos, label);\n\tfl6.flowi6_mark = skb->mark;\n\tfl6.flowi6_proto = IPPROTO_UDP;\n\tfl6.fl6_dport = dport;\n\tfl6.fl6_sport = sport;\n\n\tndst = ipv6_stub->ipv6_dst_lookup_flow(vxlan->net, sock6->sock->sk,\n\t\t\t\t\t       &fl6, NULL);\n\tif (IS_ERR(ndst)) {\n\t\tnetdev_dbg(dev, \"no route to %pI6\\n\", daddr);\n\t\treturn ERR_PTR(-ENETUNREACH);\n\t}\n\n\tif (unlikely(ndst->dev == dev)) {\n\t\tnetdev_dbg(dev, \"circular route to %pI6\\n\", daddr);\n\t\tdst_release(ndst);\n\t\treturn ERR_PTR(-ELOOP);\n\t}\n\n\t*saddr = fl6.saddr;\n\tif (use_cache)\n\t\tdst_cache_set_ip6(dst_cache, ndst, saddr);\n\treturn ndst;\n}\n#endif\n\n \nstatic void vxlan_encap_bypass(struct sk_buff *skb, struct vxlan_dev *src_vxlan,\n\t\t\t       struct vxlan_dev *dst_vxlan, __be32 vni,\n\t\t\t       bool snoop)\n{\n\tunion vxlan_addr loopback;\n\tunion vxlan_addr *remote_ip = &dst_vxlan->default_dst.remote_ip;\n\tstruct net_device *dev;\n\tint len = skb->len;\n\n\tskb->pkt_type = PACKET_HOST;\n\tskb->encapsulation = 0;\n\tskb->dev = dst_vxlan->dev;\n\t__skb_pull(skb, skb_network_offset(skb));\n\n\tif (remote_ip->sa.sa_family == AF_INET) {\n\t\tloopback.sin.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\t\tloopback.sa.sa_family =  AF_INET;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else {\n\t\tloopback.sin6.sin6_addr = in6addr_loopback;\n\t\tloopback.sa.sa_family =  AF_INET6;\n#endif\n\t}\n\n\trcu_read_lock();\n\tdev = skb->dev;\n\tif (unlikely(!(dev->flags & IFF_UP))) {\n\t\tkfree_skb(skb);\n\t\tgoto drop;\n\t}\n\n\tif ((dst_vxlan->cfg.flags & VXLAN_F_LEARN) && snoop)\n\t\tvxlan_snoop(dev, &loopback, eth_hdr(skb)->h_source, 0, vni);\n\n\tdev_sw_netstats_tx_add(src_vxlan->dev, 1, len);\n\tvxlan_vnifilter_count(src_vxlan, vni, NULL, VXLAN_VNI_STATS_TX, len);\n\n\tif (__netif_rx(skb) == NET_RX_SUCCESS) {\n\t\tdev_sw_netstats_rx_add(dst_vxlan->dev, len);\n\t\tvxlan_vnifilter_count(dst_vxlan, vni, NULL, VXLAN_VNI_STATS_RX,\n\t\t\t\t      len);\n\t} else {\ndrop:\n\t\tdev->stats.rx_dropped++;\n\t\tvxlan_vnifilter_count(dst_vxlan, vni, NULL,\n\t\t\t\t      VXLAN_VNI_STATS_RX_DROPS, 0);\n\t}\n\trcu_read_unlock();\n}\n\nstatic int encap_bypass_if_local(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t struct vxlan_dev *vxlan,\n\t\t\t\t union vxlan_addr *daddr,\n\t\t\t\t __be16 dst_port, int dst_ifindex, __be32 vni,\n\t\t\t\t struct dst_entry *dst,\n\t\t\t\t u32 rt_flags)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\t \n\tBUILD_BUG_ON(RTCF_LOCAL != RTF_LOCAL);\n#endif\n\t \n\tif (rt_flags & RTCF_LOCAL &&\n\t    !(rt_flags & (RTCF_BROADCAST | RTCF_MULTICAST)) &&\n\t    vxlan->cfg.flags & VXLAN_F_LOCALBYPASS) {\n\t\tstruct vxlan_dev *dst_vxlan;\n\n\t\tdst_release(dst);\n\t\tdst_vxlan = vxlan_find_vni(vxlan->net, dst_ifindex, vni,\n\t\t\t\t\t   daddr->sa.sa_family, dst_port,\n\t\t\t\t\t   vxlan->cfg.flags);\n\t\tif (!dst_vxlan) {\n\t\t\tdev->stats.tx_errors++;\n\t\t\tvxlan_vnifilter_count(vxlan, vni, NULL,\n\t\t\t\t\t      VXLAN_VNI_STATS_TX_ERRORS, 0);\n\t\t\tkfree_skb(skb);\n\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tvxlan_encap_bypass(skb, vxlan, dst_vxlan, vni, true);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nvoid vxlan_xmit_one(struct sk_buff *skb, struct net_device *dev,\n\t\t    __be32 default_vni, struct vxlan_rdst *rdst, bool did_rsc)\n{\n\tstruct dst_cache *dst_cache;\n\tstruct ip_tunnel_info *info;\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tconst struct iphdr *old_iph = ip_hdr(skb);\n\tunion vxlan_addr *dst;\n\tunion vxlan_addr remote_ip, local_ip;\n\tstruct vxlan_metadata _md;\n\tstruct vxlan_metadata *md = &_md;\n\tunsigned int pkt_len = skb->len;\n\t__be16 src_port = 0, dst_port;\n\tstruct dst_entry *ndst = NULL;\n\t__u8 tos, ttl, flow_flags = 0;\n\tint ifindex;\n\tint err;\n\tu32 flags = vxlan->cfg.flags;\n\tbool udp_sum = false;\n\tbool xnet = !net_eq(vxlan->net, dev_net(vxlan->dev));\n\t__be32 vni = 0;\n#if IS_ENABLED(CONFIG_IPV6)\n\t__be32 label;\n#endif\n\n\tinfo = skb_tunnel_info(skb);\n\n\tif (rdst) {\n\t\tdst = &rdst->remote_ip;\n\t\tif (vxlan_addr_any(dst)) {\n\t\t\tif (did_rsc) {\n\t\t\t\t \n\t\t\t\tvxlan_encap_bypass(skb, vxlan, vxlan,\n\t\t\t\t\t\t   default_vni, true);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgoto drop;\n\t\t}\n\n\t\tdst_port = rdst->remote_port ? rdst->remote_port : vxlan->cfg.dst_port;\n\t\tvni = (rdst->remote_vni) ? : default_vni;\n\t\tifindex = rdst->remote_ifindex;\n\t\tlocal_ip = vxlan->cfg.saddr;\n\t\tdst_cache = &rdst->dst_cache;\n\t\tmd->gbp = skb->mark;\n\t\tif (flags & VXLAN_F_TTL_INHERIT) {\n\t\t\tttl = ip_tunnel_get_ttl(old_iph, skb);\n\t\t} else {\n\t\t\tttl = vxlan->cfg.ttl;\n\t\t\tif (!ttl && vxlan_addr_multicast(dst))\n\t\t\t\tttl = 1;\n\t\t}\n\n\t\ttos = vxlan->cfg.tos;\n\t\tif (tos == 1)\n\t\t\ttos = ip_tunnel_get_dsfield(old_iph, skb);\n\n\t\tif (dst->sa.sa_family == AF_INET)\n\t\t\tudp_sum = !(flags & VXLAN_F_UDP_ZERO_CSUM_TX);\n\t\telse\n\t\t\tudp_sum = !(flags & VXLAN_F_UDP_ZERO_CSUM6_TX);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tlabel = vxlan->cfg.label;\n#endif\n\t} else {\n\t\tif (!info) {\n\t\t\tWARN_ONCE(1, \"%s: Missing encapsulation instructions\\n\",\n\t\t\t\t  dev->name);\n\t\t\tgoto drop;\n\t\t}\n\t\tremote_ip.sa.sa_family = ip_tunnel_info_af(info);\n\t\tif (remote_ip.sa.sa_family == AF_INET) {\n\t\t\tremote_ip.sin.sin_addr.s_addr = info->key.u.ipv4.dst;\n\t\t\tlocal_ip.sin.sin_addr.s_addr = info->key.u.ipv4.src;\n\t\t} else {\n\t\t\tremote_ip.sin6.sin6_addr = info->key.u.ipv6.dst;\n\t\t\tlocal_ip.sin6.sin6_addr = info->key.u.ipv6.src;\n\t\t}\n\t\tdst = &remote_ip;\n\t\tdst_port = info->key.tp_dst ? : vxlan->cfg.dst_port;\n\t\tflow_flags = info->key.flow_flags;\n\t\tvni = tunnel_id_to_key32(info->key.tun_id);\n\t\tifindex = 0;\n\t\tdst_cache = &info->dst_cache;\n\t\tif (info->key.tun_flags & TUNNEL_VXLAN_OPT) {\n\t\t\tif (info->options_len < sizeof(*md))\n\t\t\t\tgoto drop;\n\t\t\tmd = ip_tunnel_info_opts(info);\n\t\t}\n\t\tttl = info->key.ttl;\n\t\ttos = info->key.tos;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tlabel = info->key.label;\n#endif\n\t\tudp_sum = !!(info->key.tun_flags & TUNNEL_CSUM);\n\t}\n\tsrc_port = udp_flow_src_port(dev_net(dev), skb, vxlan->cfg.port_min,\n\t\t\t\t     vxlan->cfg.port_max, true);\n\n\trcu_read_lock();\n\tif (dst->sa.sa_family == AF_INET) {\n\t\tstruct vxlan_sock *sock4 = rcu_dereference(vxlan->vn4_sock);\n\t\tstruct rtable *rt;\n\t\t__be16 df = 0;\n\n\t\tif (!ifindex)\n\t\t\tifindex = sock4->sock->sk->sk_bound_dev_if;\n\n\t\trt = vxlan_get_route(vxlan, dev, sock4, skb, ifindex, tos,\n\t\t\t\t     dst->sin.sin_addr.s_addr,\n\t\t\t\t     &local_ip.sin.sin_addr.s_addr,\n\t\t\t\t     dst_port, src_port, flow_flags,\n\t\t\t\t     dst_cache, info);\n\t\tif (IS_ERR(rt)) {\n\t\t\terr = PTR_ERR(rt);\n\t\t\tgoto tx_error;\n\t\t}\n\n\t\tif (!info) {\n\t\t\t \n\t\t\terr = encap_bypass_if_local(skb, dev, vxlan, dst,\n\t\t\t\t\t\t    dst_port, ifindex, vni,\n\t\t\t\t\t\t    &rt->dst, rt->rt_flags);\n\t\t\tif (err)\n\t\t\t\tgoto out_unlock;\n\n\t\t\tif (vxlan->cfg.df == VXLAN_DF_SET) {\n\t\t\t\tdf = htons(IP_DF);\n\t\t\t} else if (vxlan->cfg.df == VXLAN_DF_INHERIT) {\n\t\t\t\tstruct ethhdr *eth = eth_hdr(skb);\n\n\t\t\t\tif (ntohs(eth->h_proto) == ETH_P_IPV6 ||\n\t\t\t\t    (ntohs(eth->h_proto) == ETH_P_IP &&\n\t\t\t\t     old_iph->frag_off & htons(IP_DF)))\n\t\t\t\t\tdf = htons(IP_DF);\n\t\t\t}\n\t\t} else if (info->key.tun_flags & TUNNEL_DONT_FRAGMENT) {\n\t\t\tdf = htons(IP_DF);\n\t\t}\n\n\t\tndst = &rt->dst;\n\t\terr = skb_tunnel_check_pmtu(skb, ndst, vxlan_headroom(flags & VXLAN_F_GPE),\n\t\t\t\t\t    netif_is_any_bridge_port(dev));\n\t\tif (err < 0) {\n\t\t\tgoto tx_error;\n\t\t} else if (err) {\n\t\t\tif (info) {\n\t\t\t\tstruct ip_tunnel_info *unclone;\n\t\t\t\tstruct in_addr src, dst;\n\n\t\t\t\tunclone = skb_tunnel_info_unclone(skb);\n\t\t\t\tif (unlikely(!unclone))\n\t\t\t\t\tgoto tx_error;\n\n\t\t\t\tsrc = remote_ip.sin.sin_addr;\n\t\t\t\tdst = local_ip.sin.sin_addr;\n\t\t\t\tunclone->key.u.ipv4.src = src.s_addr;\n\t\t\t\tunclone->key.u.ipv4.dst = dst.s_addr;\n\t\t\t}\n\t\t\tvxlan_encap_bypass(skb, vxlan, vxlan, vni, false);\n\t\t\tdst_release(ndst);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\ttos = ip_tunnel_ecn_encap(tos, old_iph, skb);\n\t\tttl = ttl ? : ip4_dst_hoplimit(&rt->dst);\n\t\terr = vxlan_build_skb(skb, ndst, sizeof(struct iphdr),\n\t\t\t\t      vni, md, flags, udp_sum);\n\t\tif (err < 0)\n\t\t\tgoto tx_error;\n\n\t\tudp_tunnel_xmit_skb(rt, sock4->sock->sk, skb, local_ip.sin.sin_addr.s_addr,\n\t\t\t\t    dst->sin.sin_addr.s_addr, tos, ttl, df,\n\t\t\t\t    src_port, dst_port, xnet, !udp_sum);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else {\n\t\tstruct vxlan_sock *sock6 = rcu_dereference(vxlan->vn6_sock);\n\n\t\tif (!ifindex)\n\t\t\tifindex = sock6->sock->sk->sk_bound_dev_if;\n\n\t\tndst = vxlan6_get_route(vxlan, dev, sock6, skb, ifindex, tos,\n\t\t\t\t\tlabel, &dst->sin6.sin6_addr,\n\t\t\t\t\t&local_ip.sin6.sin6_addr,\n\t\t\t\t\tdst_port, src_port,\n\t\t\t\t\tdst_cache, info);\n\t\tif (IS_ERR(ndst)) {\n\t\t\terr = PTR_ERR(ndst);\n\t\t\tndst = NULL;\n\t\t\tgoto tx_error;\n\t\t}\n\n\t\tif (!info) {\n\t\t\tu32 rt6i_flags = ((struct rt6_info *)ndst)->rt6i_flags;\n\n\t\t\terr = encap_bypass_if_local(skb, dev, vxlan, dst,\n\t\t\t\t\t\t    dst_port, ifindex, vni,\n\t\t\t\t\t\t    ndst, rt6i_flags);\n\t\t\tif (err)\n\t\t\t\tgoto out_unlock;\n\t\t}\n\n\t\terr = skb_tunnel_check_pmtu(skb, ndst,\n\t\t\t\t\t    vxlan_headroom((flags & VXLAN_F_GPE) | VXLAN_F_IPV6),\n\t\t\t\t\t    netif_is_any_bridge_port(dev));\n\t\tif (err < 0) {\n\t\t\tgoto tx_error;\n\t\t} else if (err) {\n\t\t\tif (info) {\n\t\t\t\tstruct ip_tunnel_info *unclone;\n\t\t\t\tstruct in6_addr src, dst;\n\n\t\t\t\tunclone = skb_tunnel_info_unclone(skb);\n\t\t\t\tif (unlikely(!unclone))\n\t\t\t\t\tgoto tx_error;\n\n\t\t\t\tsrc = remote_ip.sin6.sin6_addr;\n\t\t\t\tdst = local_ip.sin6.sin6_addr;\n\t\t\t\tunclone->key.u.ipv6.src = src;\n\t\t\t\tunclone->key.u.ipv6.dst = dst;\n\t\t\t}\n\n\t\t\tvxlan_encap_bypass(skb, vxlan, vxlan, vni, false);\n\t\t\tdst_release(ndst);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\ttos = ip_tunnel_ecn_encap(tos, old_iph, skb);\n\t\tttl = ttl ? : ip6_dst_hoplimit(ndst);\n\t\tskb_scrub_packet(skb, xnet);\n\t\terr = vxlan_build_skb(skb, ndst, sizeof(struct ipv6hdr),\n\t\t\t\t      vni, md, flags, udp_sum);\n\t\tif (err < 0)\n\t\t\tgoto tx_error;\n\n\t\tudp_tunnel6_xmit_skb(ndst, sock6->sock->sk, skb, dev,\n\t\t\t\t     &local_ip.sin6.sin6_addr,\n\t\t\t\t     &dst->sin6.sin6_addr, tos, ttl,\n\t\t\t\t     label, src_port, dst_port, !udp_sum);\n#endif\n\t}\n\tvxlan_vnifilter_count(vxlan, vni, NULL, VXLAN_VNI_STATS_TX, pkt_len);\nout_unlock:\n\trcu_read_unlock();\n\treturn;\n\ndrop:\n\tdev->stats.tx_dropped++;\n\tvxlan_vnifilter_count(vxlan, vni, NULL, VXLAN_VNI_STATS_TX_DROPS, 0);\n\tdev_kfree_skb(skb);\n\treturn;\n\ntx_error:\n\trcu_read_unlock();\n\tif (err == -ELOOP)\n\t\tdev->stats.collisions++;\n\telse if (err == -ENETUNREACH)\n\t\tdev->stats.tx_carrier_errors++;\n\tdst_release(ndst);\n\tdev->stats.tx_errors++;\n\tvxlan_vnifilter_count(vxlan, vni, NULL, VXLAN_VNI_STATS_TX_ERRORS, 0);\n\tkfree_skb(skb);\n}\n\nstatic void vxlan_xmit_nh(struct sk_buff *skb, struct net_device *dev,\n\t\t\t  struct vxlan_fdb *f, __be32 vni, bool did_rsc)\n{\n\tstruct vxlan_rdst nh_rdst;\n\tstruct nexthop *nh;\n\tbool do_xmit;\n\tu32 hash;\n\n\tmemset(&nh_rdst, 0, sizeof(struct vxlan_rdst));\n\thash = skb_get_hash(skb);\n\n\trcu_read_lock();\n\tnh = rcu_dereference(f->nh);\n\tif (!nh) {\n\t\trcu_read_unlock();\n\t\tgoto drop;\n\t}\n\tdo_xmit = vxlan_fdb_nh_path_select(nh, hash, &nh_rdst);\n\trcu_read_unlock();\n\n\tif (likely(do_xmit))\n\t\tvxlan_xmit_one(skb, dev, vni, &nh_rdst, did_rsc);\n\telse\n\t\tgoto drop;\n\n\treturn;\n\ndrop:\n\tdev->stats.tx_dropped++;\n\tvxlan_vnifilter_count(netdev_priv(dev), vni, NULL,\n\t\t\t      VXLAN_VNI_STATS_TX_DROPS, 0);\n\tdev_kfree_skb(skb);\n}\n\nstatic netdev_tx_t vxlan_xmit_nhid(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\t   u32 nhid, __be32 vni)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tstruct vxlan_rdst nh_rdst;\n\tstruct nexthop *nh;\n\tbool do_xmit;\n\tu32 hash;\n\n\tmemset(&nh_rdst, 0, sizeof(struct vxlan_rdst));\n\thash = skb_get_hash(skb);\n\n\trcu_read_lock();\n\tnh = nexthop_find_by_id(dev_net(dev), nhid);\n\tif (unlikely(!nh || !nexthop_is_fdb(nh) || !nexthop_is_multipath(nh))) {\n\t\trcu_read_unlock();\n\t\tgoto drop;\n\t}\n\tdo_xmit = vxlan_fdb_nh_path_select(nh, hash, &nh_rdst);\n\trcu_read_unlock();\n\n\tif (vxlan->cfg.saddr.sa.sa_family != nh_rdst.remote_ip.sa.sa_family)\n\t\tgoto drop;\n\n\tif (likely(do_xmit))\n\t\tvxlan_xmit_one(skb, dev, vni, &nh_rdst, false);\n\telse\n\t\tgoto drop;\n\n\treturn NETDEV_TX_OK;\n\ndrop:\n\tdev->stats.tx_dropped++;\n\tvxlan_vnifilter_count(netdev_priv(dev), vni, NULL,\n\t\t\t      VXLAN_VNI_STATS_TX_DROPS, 0);\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic netdev_tx_t vxlan_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tstruct vxlan_rdst *rdst, *fdst = NULL;\n\tconst struct ip_tunnel_info *info;\n\tbool did_rsc = false;\n\tstruct vxlan_fdb *f;\n\tstruct ethhdr *eth;\n\t__be32 vni = 0;\n\tu32 nhid = 0;\n\n\tinfo = skb_tunnel_info(skb);\n\n\tskb_reset_mac_header(skb);\n\n\tif (vxlan->cfg.flags & VXLAN_F_COLLECT_METADATA) {\n\t\tif (info && info->mode & IP_TUNNEL_INFO_BRIDGE &&\n\t\t    info->mode & IP_TUNNEL_INFO_TX) {\n\t\t\tvni = tunnel_id_to_key32(info->key.tun_id);\n\t\t\tnhid = info->key.nhid;\n\t\t} else {\n\t\t\tif (info && info->mode & IP_TUNNEL_INFO_TX)\n\t\t\t\tvxlan_xmit_one(skb, dev, vni, NULL, false);\n\t\t\telse\n\t\t\t\tkfree_skb(skb);\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t}\n\n\tif (vxlan->cfg.flags & VXLAN_F_PROXY) {\n\t\teth = eth_hdr(skb);\n\t\tif (ntohs(eth->h_proto) == ETH_P_ARP)\n\t\t\treturn arp_reduce(dev, skb, vni);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\telse if (ntohs(eth->h_proto) == ETH_P_IPV6 &&\n\t\t\t pskb_may_pull(skb, sizeof(struct ipv6hdr) +\n\t\t\t\t\t    sizeof(struct nd_msg)) &&\n\t\t\t ipv6_hdr(skb)->nexthdr == IPPROTO_ICMPV6) {\n\t\t\tstruct nd_msg *m = (struct nd_msg *)(ipv6_hdr(skb) + 1);\n\n\t\t\tif (m->icmph.icmp6_code == 0 &&\n\t\t\t    m->icmph.icmp6_type == NDISC_NEIGHBOUR_SOLICITATION)\n\t\t\t\treturn neigh_reduce(dev, skb, vni);\n\t\t}\n#endif\n\t}\n\n\tif (nhid)\n\t\treturn vxlan_xmit_nhid(skb, dev, nhid, vni);\n\n\tif (vxlan->cfg.flags & VXLAN_F_MDB) {\n\t\tstruct vxlan_mdb_entry *mdb_entry;\n\n\t\trcu_read_lock();\n\t\tmdb_entry = vxlan_mdb_entry_skb_get(vxlan, skb, vni);\n\t\tif (mdb_entry) {\n\t\t\tnetdev_tx_t ret;\n\n\t\t\tret = vxlan_mdb_xmit(vxlan, mdb_entry, skb);\n\t\t\trcu_read_unlock();\n\t\t\treturn ret;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\teth = eth_hdr(skb);\n\tf = vxlan_find_mac(vxlan, eth->h_dest, vni);\n\tdid_rsc = false;\n\n\tif (f && (f->flags & NTF_ROUTER) && (vxlan->cfg.flags & VXLAN_F_RSC) &&\n\t    (ntohs(eth->h_proto) == ETH_P_IP ||\n\t     ntohs(eth->h_proto) == ETH_P_IPV6)) {\n\t\tdid_rsc = route_shortcircuit(dev, skb);\n\t\tif (did_rsc)\n\t\t\tf = vxlan_find_mac(vxlan, eth->h_dest, vni);\n\t}\n\n\tif (f == NULL) {\n\t\tf = vxlan_find_mac(vxlan, all_zeros_mac, vni);\n\t\tif (f == NULL) {\n\t\t\tif ((vxlan->cfg.flags & VXLAN_F_L2MISS) &&\n\t\t\t    !is_multicast_ether_addr(eth->h_dest))\n\t\t\t\tvxlan_fdb_miss(vxlan, eth->h_dest);\n\n\t\t\tdev->stats.tx_dropped++;\n\t\t\tvxlan_vnifilter_count(vxlan, vni, NULL,\n\t\t\t\t\t      VXLAN_VNI_STATS_TX_DROPS, 0);\n\t\t\tkfree_skb(skb);\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t}\n\n\tif (rcu_access_pointer(f->nh)) {\n\t\tvxlan_xmit_nh(skb, dev, f,\n\t\t\t      (vni ? : vxlan->default_dst.remote_vni), did_rsc);\n\t} else {\n\t\tlist_for_each_entry_rcu(rdst, &f->remotes, list) {\n\t\t\tstruct sk_buff *skb1;\n\n\t\t\tif (!fdst) {\n\t\t\t\tfdst = rdst;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tskb1 = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (skb1)\n\t\t\t\tvxlan_xmit_one(skb1, dev, vni, rdst, did_rsc);\n\t\t}\n\t\tif (fdst)\n\t\t\tvxlan_xmit_one(skb, dev, vni, fdst, did_rsc);\n\t\telse\n\t\t\tkfree_skb(skb);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic void vxlan_cleanup(struct timer_list *t)\n{\n\tstruct vxlan_dev *vxlan = from_timer(vxlan, t, age_timer);\n\tunsigned long next_timer = jiffies + FDB_AGE_INTERVAL;\n\tunsigned int h;\n\n\tif (!netif_running(vxlan->dev))\n\t\treturn;\n\n\tfor (h = 0; h < FDB_HASH_SIZE; ++h) {\n\t\tstruct hlist_node *p, *n;\n\n\t\tspin_lock(&vxlan->hash_lock[h]);\n\t\thlist_for_each_safe(p, n, &vxlan->fdb_head[h]) {\n\t\t\tstruct vxlan_fdb *f\n\t\t\t\t= container_of(p, struct vxlan_fdb, hlist);\n\t\t\tunsigned long timeout;\n\n\t\t\tif (f->state & (NUD_PERMANENT | NUD_NOARP))\n\t\t\t\tcontinue;\n\n\t\t\tif (f->flags & NTF_EXT_LEARNED)\n\t\t\t\tcontinue;\n\n\t\t\ttimeout = f->used + vxlan->cfg.age_interval * HZ;\n\t\t\tif (time_before_eq(timeout, jiffies)) {\n\t\t\t\tnetdev_dbg(vxlan->dev,\n\t\t\t\t\t   \"garbage collect %pM\\n\",\n\t\t\t\t\t   f->eth_addr);\n\t\t\t\tf->state = NUD_STALE;\n\t\t\t\tvxlan_fdb_destroy(vxlan, f, true, true);\n\t\t\t} else if (time_before(timeout, next_timer))\n\t\t\t\tnext_timer = timeout;\n\t\t}\n\t\tspin_unlock(&vxlan->hash_lock[h]);\n\t}\n\n\tmod_timer(&vxlan->age_timer, next_timer);\n}\n\nstatic void vxlan_vs_del_dev(struct vxlan_dev *vxlan)\n{\n\tstruct vxlan_net *vn = net_generic(vxlan->net, vxlan_net_id);\n\n\tspin_lock(&vn->sock_lock);\n\thlist_del_init_rcu(&vxlan->hlist4.hlist);\n#if IS_ENABLED(CONFIG_IPV6)\n\thlist_del_init_rcu(&vxlan->hlist6.hlist);\n#endif\n\tspin_unlock(&vn->sock_lock);\n}\n\nstatic void vxlan_vs_add_dev(struct vxlan_sock *vs, struct vxlan_dev *vxlan,\n\t\t\t     struct vxlan_dev_node *node)\n{\n\tstruct vxlan_net *vn = net_generic(vxlan->net, vxlan_net_id);\n\t__be32 vni = vxlan->default_dst.remote_vni;\n\n\tnode->vxlan = vxlan;\n\tspin_lock(&vn->sock_lock);\n\thlist_add_head_rcu(&node->hlist, vni_head(vs, vni));\n\tspin_unlock(&vn->sock_lock);\n}\n\n \nstatic int vxlan_init(struct net_device *dev)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tint err;\n\n\tif (vxlan->cfg.flags & VXLAN_F_VNIFILTER)\n\t\tvxlan_vnigroup_init(vxlan);\n\n\tdev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\n\tif (!dev->tstats) {\n\t\terr = -ENOMEM;\n\t\tgoto err_vnigroup_uninit;\n\t}\n\n\terr = gro_cells_init(&vxlan->gro_cells, dev);\n\tif (err)\n\t\tgoto err_free_percpu;\n\n\terr = vxlan_mdb_init(vxlan);\n\tif (err)\n\t\tgoto err_gro_cells_destroy;\n\n\treturn 0;\n\nerr_gro_cells_destroy:\n\tgro_cells_destroy(&vxlan->gro_cells);\nerr_free_percpu:\n\tfree_percpu(dev->tstats);\nerr_vnigroup_uninit:\n\tif (vxlan->cfg.flags & VXLAN_F_VNIFILTER)\n\t\tvxlan_vnigroup_uninit(vxlan);\n\treturn err;\n}\n\nstatic void vxlan_fdb_delete_default(struct vxlan_dev *vxlan, __be32 vni)\n{\n\tstruct vxlan_fdb *f;\n\tu32 hash_index = fdb_head_index(vxlan, all_zeros_mac, vni);\n\n\tspin_lock_bh(&vxlan->hash_lock[hash_index]);\n\tf = __vxlan_find_mac(vxlan, all_zeros_mac, vni);\n\tif (f)\n\t\tvxlan_fdb_destroy(vxlan, f, true, true);\n\tspin_unlock_bh(&vxlan->hash_lock[hash_index]);\n}\n\nstatic void vxlan_uninit(struct net_device *dev)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\n\tvxlan_mdb_fini(vxlan);\n\n\tif (vxlan->cfg.flags & VXLAN_F_VNIFILTER)\n\t\tvxlan_vnigroup_uninit(vxlan);\n\n\tgro_cells_destroy(&vxlan->gro_cells);\n\n\tvxlan_fdb_delete_default(vxlan, vxlan->cfg.vni);\n\n\tfree_percpu(dev->tstats);\n}\n\n \nstatic int vxlan_open(struct net_device *dev)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tint ret;\n\n\tret = vxlan_sock_add(vxlan);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = vxlan_multicast_join(vxlan);\n\tif (ret) {\n\t\tvxlan_sock_release(vxlan);\n\t\treturn ret;\n\t}\n\n\tif (vxlan->cfg.age_interval)\n\t\tmod_timer(&vxlan->age_timer, jiffies + FDB_AGE_INTERVAL);\n\n\treturn ret;\n}\n\n \nstatic void vxlan_flush(struct vxlan_dev *vxlan, bool do_all)\n{\n\tunsigned int h;\n\n\tfor (h = 0; h < FDB_HASH_SIZE; ++h) {\n\t\tstruct hlist_node *p, *n;\n\n\t\tspin_lock_bh(&vxlan->hash_lock[h]);\n\t\thlist_for_each_safe(p, n, &vxlan->fdb_head[h]) {\n\t\t\tstruct vxlan_fdb *f\n\t\t\t\t= container_of(p, struct vxlan_fdb, hlist);\n\t\t\tif (!do_all && (f->state & (NUD_PERMANENT | NUD_NOARP)))\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (is_zero_ether_addr(f->eth_addr) &&\n\t\t\t    f->vni == vxlan->cfg.vni)\n\t\t\t\tcontinue;\n\t\t\tvxlan_fdb_destroy(vxlan, f, true, true);\n\t\t}\n\t\tspin_unlock_bh(&vxlan->hash_lock[h]);\n\t}\n}\n\n \nstatic int vxlan_stop(struct net_device *dev)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\n\tvxlan_multicast_leave(vxlan);\n\n\tdel_timer_sync(&vxlan->age_timer);\n\n\tvxlan_flush(vxlan, false);\n\tvxlan_sock_release(vxlan);\n\n\treturn 0;\n}\n\n \nstatic void vxlan_set_multicast_list(struct net_device *dev)\n{\n}\n\nstatic int vxlan_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tstruct vxlan_rdst *dst = &vxlan->default_dst;\n\tstruct net_device *lowerdev = __dev_get_by_index(vxlan->net,\n\t\t\t\t\t\t\t dst->remote_ifindex);\n\n\t \n\tif (lowerdev) {\n\t\tint max_mtu = lowerdev->mtu - vxlan_headroom(vxlan->cfg.flags);\n\t\tif (new_mtu > max_mtu)\n\t\t\treturn -EINVAL;\n\t}\n\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\nstatic int vxlan_fill_metadata_dst(struct net_device *dev, struct sk_buff *skb)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tstruct ip_tunnel_info *info = skb_tunnel_info(skb);\n\t__be16 sport, dport;\n\n\tsport = udp_flow_src_port(dev_net(dev), skb, vxlan->cfg.port_min,\n\t\t\t\t  vxlan->cfg.port_max, true);\n\tdport = info->key.tp_dst ? : vxlan->cfg.dst_port;\n\n\tif (ip_tunnel_info_af(info) == AF_INET) {\n\t\tstruct vxlan_sock *sock4 = rcu_dereference(vxlan->vn4_sock);\n\t\tstruct rtable *rt;\n\n\t\trt = vxlan_get_route(vxlan, dev, sock4, skb, 0, info->key.tos,\n\t\t\t\t     info->key.u.ipv4.dst,\n\t\t\t\t     &info->key.u.ipv4.src, dport, sport,\n\t\t\t\t     info->key.flow_flags, &info->dst_cache,\n\t\t\t\t     info);\n\t\tif (IS_ERR(rt))\n\t\t\treturn PTR_ERR(rt);\n\t\tip_rt_put(rt);\n\t} else {\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tstruct vxlan_sock *sock6 = rcu_dereference(vxlan->vn6_sock);\n\t\tstruct dst_entry *ndst;\n\n\t\tndst = vxlan6_get_route(vxlan, dev, sock6, skb, 0, info->key.tos,\n\t\t\t\t\tinfo->key.label, &info->key.u.ipv6.dst,\n\t\t\t\t\t&info->key.u.ipv6.src, dport, sport,\n\t\t\t\t\t&info->dst_cache, info);\n\t\tif (IS_ERR(ndst))\n\t\t\treturn PTR_ERR(ndst);\n\t\tdst_release(ndst);\n#else  \n\t\treturn -EPFNOSUPPORT;\n#endif\n\t}\n\tinfo->key.tp_src = sport;\n\tinfo->key.tp_dst = dport;\n\treturn 0;\n}\n\nstatic const struct net_device_ops vxlan_netdev_ether_ops = {\n\t.ndo_init\t\t= vxlan_init,\n\t.ndo_uninit\t\t= vxlan_uninit,\n\t.ndo_open\t\t= vxlan_open,\n\t.ndo_stop\t\t= vxlan_stop,\n\t.ndo_start_xmit\t\t= vxlan_xmit,\n\t.ndo_get_stats64\t= dev_get_tstats64,\n\t.ndo_set_rx_mode\t= vxlan_set_multicast_list,\n\t.ndo_change_mtu\t\t= vxlan_change_mtu,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_fdb_add\t\t= vxlan_fdb_add,\n\t.ndo_fdb_del\t\t= vxlan_fdb_delete,\n\t.ndo_fdb_dump\t\t= vxlan_fdb_dump,\n\t.ndo_fdb_get\t\t= vxlan_fdb_get,\n\t.ndo_mdb_add\t\t= vxlan_mdb_add,\n\t.ndo_mdb_del\t\t= vxlan_mdb_del,\n\t.ndo_mdb_dump\t\t= vxlan_mdb_dump,\n\t.ndo_fill_metadata_dst\t= vxlan_fill_metadata_dst,\n};\n\nstatic const struct net_device_ops vxlan_netdev_raw_ops = {\n\t.ndo_init\t\t= vxlan_init,\n\t.ndo_uninit\t\t= vxlan_uninit,\n\t.ndo_open\t\t= vxlan_open,\n\t.ndo_stop\t\t= vxlan_stop,\n\t.ndo_start_xmit\t\t= vxlan_xmit,\n\t.ndo_get_stats64\t= dev_get_tstats64,\n\t.ndo_change_mtu\t\t= vxlan_change_mtu,\n\t.ndo_fill_metadata_dst\t= vxlan_fill_metadata_dst,\n};\n\n \nstatic struct device_type vxlan_type = {\n\t.name = \"vxlan\",\n};\n\n \nstatic void vxlan_offload_rx_ports(struct net_device *dev, bool push)\n{\n\tstruct vxlan_sock *vs;\n\tstruct net *net = dev_net(dev);\n\tstruct vxlan_net *vn = net_generic(net, vxlan_net_id);\n\tunsigned int i;\n\n\tspin_lock(&vn->sock_lock);\n\tfor (i = 0; i < PORT_HASH_SIZE; ++i) {\n\t\thlist_for_each_entry_rcu(vs, &vn->sock_list[i], hlist) {\n\t\t\tunsigned short type;\n\n\t\t\tif (vs->flags & VXLAN_F_GPE)\n\t\t\t\ttype = UDP_TUNNEL_TYPE_VXLAN_GPE;\n\t\t\telse\n\t\t\t\ttype = UDP_TUNNEL_TYPE_VXLAN;\n\n\t\t\tif (push)\n\t\t\t\tudp_tunnel_push_rx_port(dev, vs->sock, type);\n\t\t\telse\n\t\t\t\tudp_tunnel_drop_rx_port(dev, vs->sock, type);\n\t\t}\n\t}\n\tspin_unlock(&vn->sock_lock);\n}\n\n \nstatic void vxlan_setup(struct net_device *dev)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tunsigned int h;\n\n\teth_hw_addr_random(dev);\n\tether_setup(dev);\n\n\tdev->needs_free_netdev = true;\n\tSET_NETDEV_DEVTYPE(dev, &vxlan_type);\n\n\tdev->features\t|= NETIF_F_LLTX;\n\tdev->features\t|= NETIF_F_SG | NETIF_F_HW_CSUM | NETIF_F_FRAGLIST;\n\tdev->features   |= NETIF_F_RXCSUM;\n\tdev->features   |= NETIF_F_GSO_SOFTWARE;\n\n\tdev->vlan_features = dev->features;\n\tdev->hw_features |= NETIF_F_SG | NETIF_F_HW_CSUM | NETIF_F_FRAGLIST;\n\tdev->hw_features |= NETIF_F_RXCSUM;\n\tdev->hw_features |= NETIF_F_GSO_SOFTWARE;\n\tnetif_keep_dst(dev);\n\tdev->priv_flags |= IFF_NO_QUEUE | IFF_CHANGE_PROTO_DOWN;\n\n\t \n\tdev->min_mtu = ETH_MIN_MTU;\n\tdev->max_mtu = ETH_MAX_MTU;\n\n\tINIT_LIST_HEAD(&vxlan->next);\n\n\ttimer_setup(&vxlan->age_timer, vxlan_cleanup, TIMER_DEFERRABLE);\n\n\tvxlan->dev = dev;\n\n\tfor (h = 0; h < FDB_HASH_SIZE; ++h) {\n\t\tspin_lock_init(&vxlan->hash_lock[h]);\n\t\tINIT_HLIST_HEAD(&vxlan->fdb_head[h]);\n\t}\n}\n\nstatic void vxlan_ether_setup(struct net_device *dev)\n{\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->priv_flags |= IFF_LIVE_ADDR_CHANGE;\n\tdev->netdev_ops = &vxlan_netdev_ether_ops;\n}\n\nstatic void vxlan_raw_setup(struct net_device *dev)\n{\n\tdev->header_ops = NULL;\n\tdev->type = ARPHRD_NONE;\n\tdev->hard_header_len = 0;\n\tdev->addr_len = 0;\n\tdev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\tdev->netdev_ops = &vxlan_netdev_raw_ops;\n}\n\nstatic const struct nla_policy vxlan_policy[IFLA_VXLAN_MAX + 1] = {\n\t[IFLA_VXLAN_UNSPEC]     = { .strict_start_type = IFLA_VXLAN_LOCALBYPASS },\n\t[IFLA_VXLAN_ID]\t\t= { .type = NLA_U32 },\n\t[IFLA_VXLAN_GROUP]\t= { .len = sizeof_field(struct iphdr, daddr) },\n\t[IFLA_VXLAN_GROUP6]\t= { .len = sizeof(struct in6_addr) },\n\t[IFLA_VXLAN_LINK]\t= { .type = NLA_U32 },\n\t[IFLA_VXLAN_LOCAL]\t= { .len = sizeof_field(struct iphdr, saddr) },\n\t[IFLA_VXLAN_LOCAL6]\t= { .len = sizeof(struct in6_addr) },\n\t[IFLA_VXLAN_TOS]\t= { .type = NLA_U8 },\n\t[IFLA_VXLAN_TTL]\t= { .type = NLA_U8 },\n\t[IFLA_VXLAN_LABEL]\t= { .type = NLA_U32 },\n\t[IFLA_VXLAN_LEARNING]\t= { .type = NLA_U8 },\n\t[IFLA_VXLAN_AGEING]\t= { .type = NLA_U32 },\n\t[IFLA_VXLAN_LIMIT]\t= { .type = NLA_U32 },\n\t[IFLA_VXLAN_PORT_RANGE] = { .len  = sizeof(struct ifla_vxlan_port_range) },\n\t[IFLA_VXLAN_PROXY]\t= { .type = NLA_U8 },\n\t[IFLA_VXLAN_RSC]\t= { .type = NLA_U8 },\n\t[IFLA_VXLAN_L2MISS]\t= { .type = NLA_U8 },\n\t[IFLA_VXLAN_L3MISS]\t= { .type = NLA_U8 },\n\t[IFLA_VXLAN_COLLECT_METADATA]\t= { .type = NLA_U8 },\n\t[IFLA_VXLAN_PORT]\t= { .type = NLA_U16 },\n\t[IFLA_VXLAN_UDP_CSUM]\t= { .type = NLA_U8 },\n\t[IFLA_VXLAN_UDP_ZERO_CSUM6_TX]\t= { .type = NLA_U8 },\n\t[IFLA_VXLAN_UDP_ZERO_CSUM6_RX]\t= { .type = NLA_U8 },\n\t[IFLA_VXLAN_REMCSUM_TX]\t= { .type = NLA_U8 },\n\t[IFLA_VXLAN_REMCSUM_RX]\t= { .type = NLA_U8 },\n\t[IFLA_VXLAN_GBP]\t= { .type = NLA_FLAG, },\n\t[IFLA_VXLAN_GPE]\t= { .type = NLA_FLAG, },\n\t[IFLA_VXLAN_REMCSUM_NOPARTIAL]\t= { .type = NLA_FLAG },\n\t[IFLA_VXLAN_TTL_INHERIT]\t= { .type = NLA_FLAG },\n\t[IFLA_VXLAN_DF]\t\t= { .type = NLA_U8 },\n\t[IFLA_VXLAN_VNIFILTER]\t= { .type = NLA_U8 },\n\t[IFLA_VXLAN_LOCALBYPASS]\t= NLA_POLICY_MAX(NLA_U8, 1),\n};\n\nstatic int vxlan_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tif (tb[IFLA_ADDRESS]) {\n\t\tif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, tb[IFLA_ADDRESS],\n\t\t\t\t\t    \"Provided link layer address is not Ethernet\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS]))) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, tb[IFLA_ADDRESS],\n\t\t\t\t\t    \"Provided Ethernet address is not unicast\");\n\t\t\treturn -EADDRNOTAVAIL;\n\t\t}\n\t}\n\n\tif (tb[IFLA_MTU]) {\n\t\tu32 mtu = nla_get_u32(tb[IFLA_MTU]);\n\n\t\tif (mtu < ETH_MIN_MTU || mtu > ETH_MAX_MTU) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, tb[IFLA_MTU],\n\t\t\t\t\t    \"MTU must be between 68 and 65535\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!data) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Required attributes not provided to perform the operation\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (data[IFLA_VXLAN_ID]) {\n\t\tu32 id = nla_get_u32(data[IFLA_VXLAN_ID]);\n\n\t\tif (id >= VXLAN_N_VID) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, data[IFLA_VXLAN_ID],\n\t\t\t\t\t    \"VXLAN ID must be lower than 16777216\");\n\t\t\treturn -ERANGE;\n\t\t}\n\t}\n\n\tif (data[IFLA_VXLAN_PORT_RANGE]) {\n\t\tconst struct ifla_vxlan_port_range *p\n\t\t\t= nla_data(data[IFLA_VXLAN_PORT_RANGE]);\n\n\t\tif (ntohs(p->high) < ntohs(p->low)) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, data[IFLA_VXLAN_PORT_RANGE],\n\t\t\t\t\t    \"Invalid source port range\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (data[IFLA_VXLAN_DF]) {\n\t\tenum ifla_vxlan_df df = nla_get_u8(data[IFLA_VXLAN_DF]);\n\n\t\tif (df < 0 || df > VXLAN_DF_MAX) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, data[IFLA_VXLAN_DF],\n\t\t\t\t\t    \"Invalid DF attribute\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void vxlan_get_drvinfo(struct net_device *netdev,\n\t\t\t      struct ethtool_drvinfo *drvinfo)\n{\n\tstrscpy(drvinfo->version, VXLAN_VERSION, sizeof(drvinfo->version));\n\tstrscpy(drvinfo->driver, \"vxlan\", sizeof(drvinfo->driver));\n}\n\nstatic int vxlan_get_link_ksettings(struct net_device *dev,\n\t\t\t\t    struct ethtool_link_ksettings *cmd)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tstruct vxlan_rdst *dst = &vxlan->default_dst;\n\tstruct net_device *lowerdev = __dev_get_by_index(vxlan->net,\n\t\t\t\t\t\t\t dst->remote_ifindex);\n\n\tif (!lowerdev) {\n\t\tcmd->base.duplex = DUPLEX_UNKNOWN;\n\t\tcmd->base.port = PORT_OTHER;\n\t\tcmd->base.speed = SPEED_UNKNOWN;\n\n\t\treturn 0;\n\t}\n\n\treturn __ethtool_get_link_ksettings(lowerdev, cmd);\n}\n\nstatic const struct ethtool_ops vxlan_ethtool_ops = {\n\t.get_drvinfo\t\t= vxlan_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_link_ksettings\t= vxlan_get_link_ksettings,\n};\n\nstatic struct socket *vxlan_create_sock(struct net *net, bool ipv6,\n\t\t\t\t\t__be16 port, u32 flags, int ifindex)\n{\n\tstruct socket *sock;\n\tstruct udp_port_cfg udp_conf;\n\tint err;\n\n\tmemset(&udp_conf, 0, sizeof(udp_conf));\n\n\tif (ipv6) {\n\t\tudp_conf.family = AF_INET6;\n\t\tudp_conf.use_udp6_rx_checksums =\n\t\t    !(flags & VXLAN_F_UDP_ZERO_CSUM6_RX);\n\t\tudp_conf.ipv6_v6only = 1;\n\t} else {\n\t\tudp_conf.family = AF_INET;\n\t}\n\n\tudp_conf.local_udp_port = port;\n\tudp_conf.bind_ifindex = ifindex;\n\n\t \n\terr = udp_sock_create(net, &udp_conf, &sock);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\tudp_allow_gso(sock->sk);\n\treturn sock;\n}\n\n \nstatic struct vxlan_sock *vxlan_socket_create(struct net *net, bool ipv6,\n\t\t\t\t\t      __be16 port, u32 flags,\n\t\t\t\t\t      int ifindex)\n{\n\tstruct vxlan_net *vn = net_generic(net, vxlan_net_id);\n\tstruct vxlan_sock *vs;\n\tstruct socket *sock;\n\tunsigned int h;\n\tstruct udp_tunnel_sock_cfg tunnel_cfg;\n\n\tvs = kzalloc(sizeof(*vs), GFP_KERNEL);\n\tif (!vs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (h = 0; h < VNI_HASH_SIZE; ++h)\n\t\tINIT_HLIST_HEAD(&vs->vni_list[h]);\n\n\tsock = vxlan_create_sock(net, ipv6, port, flags, ifindex);\n\tif (IS_ERR(sock)) {\n\t\tkfree(vs);\n\t\treturn ERR_CAST(sock);\n\t}\n\n\tvs->sock = sock;\n\trefcount_set(&vs->refcnt, 1);\n\tvs->flags = (flags & VXLAN_F_RCV_FLAGS);\n\n\tspin_lock(&vn->sock_lock);\n\thlist_add_head_rcu(&vs->hlist, vs_head(net, port));\n\tudp_tunnel_notify_add_rx_port(sock,\n\t\t\t\t      (vs->flags & VXLAN_F_GPE) ?\n\t\t\t\t      UDP_TUNNEL_TYPE_VXLAN_GPE :\n\t\t\t\t      UDP_TUNNEL_TYPE_VXLAN);\n\tspin_unlock(&vn->sock_lock);\n\n\t \n\tmemset(&tunnel_cfg, 0, sizeof(tunnel_cfg));\n\ttunnel_cfg.sk_user_data = vs;\n\ttunnel_cfg.encap_type = 1;\n\ttunnel_cfg.encap_rcv = vxlan_rcv;\n\ttunnel_cfg.encap_err_lookup = vxlan_err_lookup;\n\ttunnel_cfg.encap_destroy = NULL;\n\tif (vs->flags & VXLAN_F_GPE) {\n\t\ttunnel_cfg.gro_receive = vxlan_gpe_gro_receive;\n\t\ttunnel_cfg.gro_complete = vxlan_gpe_gro_complete;\n\t} else {\n\t\ttunnel_cfg.gro_receive = vxlan_gro_receive;\n\t\ttunnel_cfg.gro_complete = vxlan_gro_complete;\n\t}\n\n\tsetup_udp_tunnel_sock(net, sock, &tunnel_cfg);\n\n\treturn vs;\n}\n\nstatic int __vxlan_sock_add(struct vxlan_dev *vxlan, bool ipv6)\n{\n\tstruct vxlan_net *vn = net_generic(vxlan->net, vxlan_net_id);\n\tbool metadata = vxlan->cfg.flags & VXLAN_F_COLLECT_METADATA;\n\tstruct vxlan_sock *vs = NULL;\n\tstruct vxlan_dev_node *node;\n\tint l3mdev_index = 0;\n\n\tif (vxlan->cfg.remote_ifindex)\n\t\tl3mdev_index = l3mdev_master_upper_ifindex_by_index(\n\t\t\tvxlan->net, vxlan->cfg.remote_ifindex);\n\n\tif (!vxlan->cfg.no_share) {\n\t\tspin_lock(&vn->sock_lock);\n\t\tvs = vxlan_find_sock(vxlan->net, ipv6 ? AF_INET6 : AF_INET,\n\t\t\t\t     vxlan->cfg.dst_port, vxlan->cfg.flags,\n\t\t\t\t     l3mdev_index);\n\t\tif (vs && !refcount_inc_not_zero(&vs->refcnt)) {\n\t\t\tspin_unlock(&vn->sock_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tspin_unlock(&vn->sock_lock);\n\t}\n\tif (!vs)\n\t\tvs = vxlan_socket_create(vxlan->net, ipv6,\n\t\t\t\t\t vxlan->cfg.dst_port, vxlan->cfg.flags,\n\t\t\t\t\t l3mdev_index);\n\tif (IS_ERR(vs))\n\t\treturn PTR_ERR(vs);\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (ipv6) {\n\t\trcu_assign_pointer(vxlan->vn6_sock, vs);\n\t\tnode = &vxlan->hlist6;\n\t} else\n#endif\n\t{\n\t\trcu_assign_pointer(vxlan->vn4_sock, vs);\n\t\tnode = &vxlan->hlist4;\n\t}\n\n\tif (metadata && (vxlan->cfg.flags & VXLAN_F_VNIFILTER))\n\t\tvxlan_vs_add_vnigrp(vxlan, vs, ipv6);\n\telse\n\t\tvxlan_vs_add_dev(vs, vxlan, node);\n\n\treturn 0;\n}\n\nstatic int vxlan_sock_add(struct vxlan_dev *vxlan)\n{\n\tbool metadata = vxlan->cfg.flags & VXLAN_F_COLLECT_METADATA;\n\tbool ipv6 = vxlan->cfg.flags & VXLAN_F_IPV6 || metadata;\n\tbool ipv4 = !ipv6 || metadata;\n\tint ret = 0;\n\n\tRCU_INIT_POINTER(vxlan->vn4_sock, NULL);\n#if IS_ENABLED(CONFIG_IPV6)\n\tRCU_INIT_POINTER(vxlan->vn6_sock, NULL);\n\tif (ipv6) {\n\t\tret = __vxlan_sock_add(vxlan, true);\n\t\tif (ret < 0 && ret != -EAFNOSUPPORT)\n\t\t\tipv4 = false;\n\t}\n#endif\n\tif (ipv4)\n\t\tret = __vxlan_sock_add(vxlan, false);\n\tif (ret < 0)\n\t\tvxlan_sock_release(vxlan);\n\treturn ret;\n}\n\nint vxlan_vni_in_use(struct net *src_net, struct vxlan_dev *vxlan,\n\t\t     struct vxlan_config *conf, __be32 vni)\n{\n\tstruct vxlan_net *vn = net_generic(src_net, vxlan_net_id);\n\tstruct vxlan_dev *tmp;\n\n\tlist_for_each_entry(tmp, &vn->vxlan_list, next) {\n\t\tif (tmp == vxlan)\n\t\t\tcontinue;\n\t\tif (tmp->cfg.flags & VXLAN_F_VNIFILTER) {\n\t\t\tif (!vxlan_vnifilter_lookup(tmp, vni))\n\t\t\t\tcontinue;\n\t\t} else if (tmp->cfg.vni != vni) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (tmp->cfg.dst_port != conf->dst_port)\n\t\t\tcontinue;\n\t\tif ((tmp->cfg.flags & (VXLAN_F_RCV_FLAGS | VXLAN_F_IPV6)) !=\n\t\t    (conf->flags & (VXLAN_F_RCV_FLAGS | VXLAN_F_IPV6)))\n\t\t\tcontinue;\n\n\t\tif ((conf->flags & VXLAN_F_IPV6_LINKLOCAL) &&\n\t\t    tmp->cfg.remote_ifindex != conf->remote_ifindex)\n\t\t\tcontinue;\n\n\t\treturn -EEXIST;\n\t}\n\n\treturn 0;\n}\n\nstatic int vxlan_config_validate(struct net *src_net, struct vxlan_config *conf,\n\t\t\t\t struct net_device **lower,\n\t\t\t\t struct vxlan_dev *old,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tbool use_ipv6 = false;\n\n\tif (conf->flags & VXLAN_F_GPE) {\n\t\t \n\t\tif ((conf->flags & ~VXLAN_F_ALLOWED_GPE) ||\n\t\t    !(conf->flags & VXLAN_F_COLLECT_METADATA)) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"VXLAN GPE does not support this combination of attributes\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!conf->remote_ip.sa.sa_family && !conf->saddr.sa.sa_family) {\n\t\t \n\t\tconf->remote_ip.sa.sa_family = AF_INET;\n\t\tconf->saddr.sa.sa_family = AF_INET;\n\t} else if (!conf->remote_ip.sa.sa_family) {\n\t\tconf->remote_ip.sa.sa_family = conf->saddr.sa.sa_family;\n\t} else if (!conf->saddr.sa.sa_family) {\n\t\tconf->saddr.sa.sa_family = conf->remote_ip.sa.sa_family;\n\t}\n\n\tif (conf->saddr.sa.sa_family != conf->remote_ip.sa.sa_family) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Local and remote address must be from the same family\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (vxlan_addr_multicast(&conf->saddr)) {\n\t\tNL_SET_ERR_MSG(extack, \"Local address cannot be multicast\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (conf->saddr.sa.sa_family == AF_INET6) {\n\t\tif (!IS_ENABLED(CONFIG_IPV6)) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"IPv6 support not enabled in the kernel\");\n\t\t\treturn -EPFNOSUPPORT;\n\t\t}\n\t\tuse_ipv6 = true;\n\t\tconf->flags |= VXLAN_F_IPV6;\n\n\t\tif (!(conf->flags & VXLAN_F_COLLECT_METADATA)) {\n\t\t\tint local_type =\n\t\t\t\tipv6_addr_type(&conf->saddr.sin6.sin6_addr);\n\t\t\tint remote_type =\n\t\t\t\tipv6_addr_type(&conf->remote_ip.sin6.sin6_addr);\n\n\t\t\tif (local_type & IPV6_ADDR_LINKLOCAL) {\n\t\t\t\tif (!(remote_type & IPV6_ADDR_LINKLOCAL) &&\n\t\t\t\t    (remote_type != IPV6_ADDR_ANY)) {\n\t\t\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t\t\t       \"Invalid combination of local and remote address scopes\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tconf->flags |= VXLAN_F_IPV6_LINKLOCAL;\n\t\t\t} else {\n\t\t\t\tif (remote_type ==\n\t\t\t\t    (IPV6_ADDR_UNICAST | IPV6_ADDR_LINKLOCAL)) {\n\t\t\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t\t\t       \"Invalid combination of local and remote address scopes\");\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tconf->flags &= ~VXLAN_F_IPV6_LINKLOCAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (conf->label && !use_ipv6) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Label attribute only applies to IPv6 VXLAN devices\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (conf->remote_ifindex) {\n\t\tstruct net_device *lowerdev;\n\n\t\tlowerdev = __dev_get_by_index(src_net, conf->remote_ifindex);\n\t\tif (!lowerdev) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Invalid local interface, device not found\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (use_ipv6) {\n\t\t\tstruct inet6_dev *idev = __in6_dev_get(lowerdev);\n\n\t\t\tif (idev && idev->cnf.disable_ipv6) {\n\t\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t\t       \"IPv6 support disabled by administrator\");\n\t\t\t\treturn -EPERM;\n\t\t\t}\n\t\t}\n#endif\n\n\t\t*lower = lowerdev;\n\t} else {\n\t\tif (vxlan_addr_multicast(&conf->remote_ip)) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Local interface required for multicast remote destination\");\n\n\t\t\treturn -EINVAL;\n\t\t}\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (conf->flags & VXLAN_F_IPV6_LINKLOCAL) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"Local interface required for link-local local/remote addresses\");\n\t\t\treturn -EINVAL;\n\t\t}\n#endif\n\n\t\t*lower = NULL;\n\t}\n\n\tif (!conf->dst_port) {\n\t\tif (conf->flags & VXLAN_F_GPE)\n\t\t\tconf->dst_port = htons(IANA_VXLAN_GPE_UDP_PORT);\n\t\telse\n\t\t\tconf->dst_port = htons(vxlan_port);\n\t}\n\n\tif (!conf->age_interval)\n\t\tconf->age_interval = FDB_AGE_DEFAULT;\n\n\tif (vxlan_vni_in_use(src_net, old, conf, conf->vni)) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"A VXLAN device with the specified VNI already exists\");\n\t\treturn -EEXIST;\n\t}\n\n\treturn 0;\n}\n\nstatic void vxlan_config_apply(struct net_device *dev,\n\t\t\t       struct vxlan_config *conf,\n\t\t\t       struct net_device *lowerdev,\n\t\t\t       struct net *src_net,\n\t\t\t       bool changelink)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tstruct vxlan_rdst *dst = &vxlan->default_dst;\n\tunsigned short needed_headroom = ETH_HLEN;\n\tint max_mtu = ETH_MAX_MTU;\n\tu32 flags = conf->flags;\n\n\tif (!changelink) {\n\t\tif (flags & VXLAN_F_GPE)\n\t\t\tvxlan_raw_setup(dev);\n\t\telse\n\t\t\tvxlan_ether_setup(dev);\n\n\t\tif (conf->mtu)\n\t\t\tdev->mtu = conf->mtu;\n\n\t\tvxlan->net = src_net;\n\t}\n\n\tdst->remote_vni = conf->vni;\n\n\tmemcpy(&dst->remote_ip, &conf->remote_ip, sizeof(conf->remote_ip));\n\n\tif (lowerdev) {\n\t\tdst->remote_ifindex = conf->remote_ifindex;\n\n\t\tnetif_inherit_tso_max(dev, lowerdev);\n\n\t\tneeded_headroom = lowerdev->hard_header_len;\n\t\tneeded_headroom += lowerdev->needed_headroom;\n\n\t\tdev->needed_tailroom = lowerdev->needed_tailroom;\n\n\t\tmax_mtu = lowerdev->mtu - vxlan_headroom(flags);\n\t\tif (max_mtu < ETH_MIN_MTU)\n\t\t\tmax_mtu = ETH_MIN_MTU;\n\n\t\tif (!changelink && !conf->mtu)\n\t\t\tdev->mtu = max_mtu;\n\t}\n\n\tif (dev->mtu > max_mtu)\n\t\tdev->mtu = max_mtu;\n\n\tif (flags & VXLAN_F_COLLECT_METADATA)\n\t\tflags |= VXLAN_F_IPV6;\n\tneeded_headroom += vxlan_headroom(flags);\n\tdev->needed_headroom = needed_headroom;\n\n\tmemcpy(&vxlan->cfg, conf, sizeof(*conf));\n}\n\nstatic int vxlan_dev_configure(struct net *src_net, struct net_device *dev,\n\t\t\t       struct vxlan_config *conf, bool changelink,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tstruct net_device *lowerdev;\n\tint ret;\n\n\tret = vxlan_config_validate(src_net, conf, &lowerdev, vxlan, extack);\n\tif (ret)\n\t\treturn ret;\n\n\tvxlan_config_apply(dev, conf, lowerdev, src_net, changelink);\n\n\treturn 0;\n}\n\nstatic int __vxlan_dev_create(struct net *net, struct net_device *dev,\n\t\t\t      struct vxlan_config *conf,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_net *vn = net_generic(net, vxlan_net_id);\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tstruct net_device *remote_dev = NULL;\n\tstruct vxlan_fdb *f = NULL;\n\tbool unregister = false;\n\tstruct vxlan_rdst *dst;\n\tint err;\n\n\tdst = &vxlan->default_dst;\n\terr = vxlan_dev_configure(net, dev, conf, false, extack);\n\tif (err)\n\t\treturn err;\n\n\tdev->ethtool_ops = &vxlan_ethtool_ops;\n\n\t \n\tif (!vxlan_addr_any(&dst->remote_ip)) {\n\t\terr = vxlan_fdb_create(vxlan, all_zeros_mac,\n\t\t\t\t       &dst->remote_ip,\n\t\t\t\t       NUD_REACHABLE | NUD_PERMANENT,\n\t\t\t\t       vxlan->cfg.dst_port,\n\t\t\t\t       dst->remote_vni,\n\t\t\t\t       dst->remote_vni,\n\t\t\t\t       dst->remote_ifindex,\n\t\t\t\t       NTF_SELF, 0, &f, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = register_netdevice(dev);\n\tif (err)\n\t\tgoto errout;\n\tunregister = true;\n\n\tif (dst->remote_ifindex) {\n\t\tremote_dev = __dev_get_by_index(net, dst->remote_ifindex);\n\t\tif (!remote_dev) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto errout;\n\t\t}\n\n\t\terr = netdev_upper_dev_link(remote_dev, dev, extack);\n\t\tif (err)\n\t\t\tgoto errout;\n\t}\n\n\terr = rtnl_configure_link(dev, NULL, 0, NULL);\n\tif (err < 0)\n\t\tgoto unlink;\n\n\tif (f) {\n\t\tvxlan_fdb_insert(vxlan, all_zeros_mac, dst->remote_vni, f);\n\n\t\t \n\t\terr = vxlan_fdb_notify(vxlan, f, first_remote_rtnl(f),\n\t\t\t\t       RTM_NEWNEIGH, true, extack);\n\t\tif (err) {\n\t\t\tvxlan_fdb_destroy(vxlan, f, false, false);\n\t\t\tif (remote_dev)\n\t\t\t\tnetdev_upper_dev_unlink(remote_dev, dev);\n\t\t\tgoto unregister;\n\t\t}\n\t}\n\n\tlist_add(&vxlan->next, &vn->vxlan_list);\n\tif (remote_dev)\n\t\tdst->remote_dev = remote_dev;\n\treturn 0;\nunlink:\n\tif (remote_dev)\n\t\tnetdev_upper_dev_unlink(remote_dev, dev);\nerrout:\n\t \n\tif (f)\n\t\t__vxlan_fdb_free(f);\nunregister:\n\tif (unregister)\n\t\tunregister_netdevice(dev);\n\treturn err;\n}\n\n \nstatic int vxlan_nl2flag(struct vxlan_config *conf, struct nlattr *tb[],\n\t\t\t  int attrtype, unsigned long mask, bool changelink,\n\t\t\t  bool changelink_supported,\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tunsigned long flags;\n\n\tif (!tb[attrtype])\n\t\treturn 0;\n\n\tif (changelink && !changelink_supported) {\n\t\tvxlan_flag_attr_error(attrtype, extack);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (vxlan_policy[attrtype].type == NLA_FLAG)\n\t\tflags = conf->flags | mask;\n\telse if (nla_get_u8(tb[attrtype]))\n\t\tflags = conf->flags | mask;\n\telse\n\t\tflags = conf->flags & ~mask;\n\n\tconf->flags = flags;\n\n\treturn 0;\n}\n\nstatic int vxlan_nl2conf(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t struct net_device *dev, struct vxlan_config *conf,\n\t\t\t bool changelink, struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tint err = 0;\n\n\tmemset(conf, 0, sizeof(*conf));\n\n\t \n\tif (changelink)\n\t\tmemcpy(conf, &vxlan->cfg, sizeof(*conf));\n\n\tif (data[IFLA_VXLAN_ID]) {\n\t\t__be32 vni = cpu_to_be32(nla_get_u32(data[IFLA_VXLAN_ID]));\n\n\t\tif (changelink && (vni != conf->vni)) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, tb[IFLA_VXLAN_ID], \"Cannot change VNI\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tconf->vni = cpu_to_be32(nla_get_u32(data[IFLA_VXLAN_ID]));\n\t}\n\n\tif (data[IFLA_VXLAN_GROUP]) {\n\t\tif (changelink && (conf->remote_ip.sa.sa_family != AF_INET)) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, tb[IFLA_VXLAN_GROUP], \"New group address family does not match old group\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tconf->remote_ip.sin.sin_addr.s_addr = nla_get_in_addr(data[IFLA_VXLAN_GROUP]);\n\t\tconf->remote_ip.sa.sa_family = AF_INET;\n\t} else if (data[IFLA_VXLAN_GROUP6]) {\n\t\tif (!IS_ENABLED(CONFIG_IPV6)) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, tb[IFLA_VXLAN_GROUP6], \"IPv6 support not enabled in the kernel\");\n\t\t\treturn -EPFNOSUPPORT;\n\t\t}\n\n\t\tif (changelink && (conf->remote_ip.sa.sa_family != AF_INET6)) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, tb[IFLA_VXLAN_GROUP6], \"New group address family does not match old group\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tconf->remote_ip.sin6.sin6_addr = nla_get_in6_addr(data[IFLA_VXLAN_GROUP6]);\n\t\tconf->remote_ip.sa.sa_family = AF_INET6;\n\t}\n\n\tif (data[IFLA_VXLAN_LOCAL]) {\n\t\tif (changelink && (conf->saddr.sa.sa_family != AF_INET)) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, tb[IFLA_VXLAN_LOCAL], \"New local address family does not match old\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tconf->saddr.sin.sin_addr.s_addr = nla_get_in_addr(data[IFLA_VXLAN_LOCAL]);\n\t\tconf->saddr.sa.sa_family = AF_INET;\n\t} else if (data[IFLA_VXLAN_LOCAL6]) {\n\t\tif (!IS_ENABLED(CONFIG_IPV6)) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, tb[IFLA_VXLAN_LOCAL6], \"IPv6 support not enabled in the kernel\");\n\t\t\treturn -EPFNOSUPPORT;\n\t\t}\n\n\t\tif (changelink && (conf->saddr.sa.sa_family != AF_INET6)) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, tb[IFLA_VXLAN_LOCAL6], \"New local address family does not match old\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\t \n\t\tconf->saddr.sin6.sin6_addr = nla_get_in6_addr(data[IFLA_VXLAN_LOCAL6]);\n\t\tconf->saddr.sa.sa_family = AF_INET6;\n\t}\n\n\tif (data[IFLA_VXLAN_LINK])\n\t\tconf->remote_ifindex = nla_get_u32(data[IFLA_VXLAN_LINK]);\n\n\tif (data[IFLA_VXLAN_TOS])\n\t\tconf->tos  = nla_get_u8(data[IFLA_VXLAN_TOS]);\n\n\tif (data[IFLA_VXLAN_TTL])\n\t\tconf->ttl = nla_get_u8(data[IFLA_VXLAN_TTL]);\n\n\tif (data[IFLA_VXLAN_TTL_INHERIT]) {\n\t\terr = vxlan_nl2flag(conf, data, IFLA_VXLAN_TTL_INHERIT,\n\t\t\t\t    VXLAN_F_TTL_INHERIT, changelink, false,\n\t\t\t\t    extack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t}\n\n\tif (data[IFLA_VXLAN_LABEL])\n\t\tconf->label = nla_get_be32(data[IFLA_VXLAN_LABEL]) &\n\t\t\t     IPV6_FLOWLABEL_MASK;\n\n\tif (data[IFLA_VXLAN_LEARNING]) {\n\t\terr = vxlan_nl2flag(conf, data, IFLA_VXLAN_LEARNING,\n\t\t\t\t    VXLAN_F_LEARN, changelink, true,\n\t\t\t\t    extack);\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (!changelink) {\n\t\t \n\t\tconf->flags |= VXLAN_F_LEARN;\n\t}\n\n\tif (data[IFLA_VXLAN_AGEING])\n\t\tconf->age_interval = nla_get_u32(data[IFLA_VXLAN_AGEING]);\n\n\tif (data[IFLA_VXLAN_PROXY]) {\n\t\terr = vxlan_nl2flag(conf, data, IFLA_VXLAN_PROXY,\n\t\t\t\t    VXLAN_F_PROXY, changelink, false,\n\t\t\t\t    extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_VXLAN_RSC]) {\n\t\terr = vxlan_nl2flag(conf, data, IFLA_VXLAN_RSC,\n\t\t\t\t    VXLAN_F_RSC, changelink, false,\n\t\t\t\t    extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_VXLAN_L2MISS]) {\n\t\terr = vxlan_nl2flag(conf, data, IFLA_VXLAN_L2MISS,\n\t\t\t\t    VXLAN_F_L2MISS, changelink, false,\n\t\t\t\t    extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_VXLAN_L3MISS]) {\n\t\terr = vxlan_nl2flag(conf, data, IFLA_VXLAN_L3MISS,\n\t\t\t\t    VXLAN_F_L3MISS, changelink, false,\n\t\t\t\t    extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_VXLAN_LIMIT]) {\n\t\tif (changelink) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, tb[IFLA_VXLAN_LIMIT],\n\t\t\t\t\t    \"Cannot change limit\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tconf->addrmax = nla_get_u32(data[IFLA_VXLAN_LIMIT]);\n\t}\n\n\tif (data[IFLA_VXLAN_COLLECT_METADATA]) {\n\t\terr = vxlan_nl2flag(conf, data, IFLA_VXLAN_COLLECT_METADATA,\n\t\t\t\t    VXLAN_F_COLLECT_METADATA, changelink, false,\n\t\t\t\t    extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_VXLAN_PORT_RANGE]) {\n\t\tif (!changelink) {\n\t\t\tconst struct ifla_vxlan_port_range *p\n\t\t\t\t= nla_data(data[IFLA_VXLAN_PORT_RANGE]);\n\t\t\tconf->port_min = ntohs(p->low);\n\t\t\tconf->port_max = ntohs(p->high);\n\t\t} else {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, tb[IFLA_VXLAN_PORT_RANGE],\n\t\t\t\t\t    \"Cannot change port range\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t}\n\n\tif (data[IFLA_VXLAN_PORT]) {\n\t\tif (changelink) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, tb[IFLA_VXLAN_PORT],\n\t\t\t\t\t    \"Cannot change port\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tconf->dst_port = nla_get_be16(data[IFLA_VXLAN_PORT]);\n\t}\n\n\tif (data[IFLA_VXLAN_UDP_CSUM]) {\n\t\tif (changelink) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, tb[IFLA_VXLAN_UDP_CSUM],\n\t\t\t\t\t    \"Cannot change UDP_CSUM flag\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif (!nla_get_u8(data[IFLA_VXLAN_UDP_CSUM]))\n\t\t\tconf->flags |= VXLAN_F_UDP_ZERO_CSUM_TX;\n\t}\n\n\tif (data[IFLA_VXLAN_LOCALBYPASS]) {\n\t\terr = vxlan_nl2flag(conf, data, IFLA_VXLAN_LOCALBYPASS,\n\t\t\t\t    VXLAN_F_LOCALBYPASS, changelink,\n\t\t\t\t    true, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (!changelink) {\n\t\t \n\t\tconf->flags |= VXLAN_F_LOCALBYPASS;\n\t}\n\n\tif (data[IFLA_VXLAN_UDP_ZERO_CSUM6_TX]) {\n\t\terr = vxlan_nl2flag(conf, data, IFLA_VXLAN_UDP_ZERO_CSUM6_TX,\n\t\t\t\t    VXLAN_F_UDP_ZERO_CSUM6_TX, changelink,\n\t\t\t\t    false, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_VXLAN_UDP_ZERO_CSUM6_RX]) {\n\t\terr = vxlan_nl2flag(conf, data, IFLA_VXLAN_UDP_ZERO_CSUM6_RX,\n\t\t\t\t    VXLAN_F_UDP_ZERO_CSUM6_RX, changelink,\n\t\t\t\t    false, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_VXLAN_REMCSUM_TX]) {\n\t\terr = vxlan_nl2flag(conf, data, IFLA_VXLAN_REMCSUM_TX,\n\t\t\t\t    VXLAN_F_REMCSUM_TX, changelink, false,\n\t\t\t\t    extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_VXLAN_REMCSUM_RX]) {\n\t\terr = vxlan_nl2flag(conf, data, IFLA_VXLAN_REMCSUM_RX,\n\t\t\t\t    VXLAN_F_REMCSUM_RX, changelink, false,\n\t\t\t\t    extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_VXLAN_GBP]) {\n\t\terr = vxlan_nl2flag(conf, data, IFLA_VXLAN_GBP,\n\t\t\t\t    VXLAN_F_GBP, changelink, false, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_VXLAN_GPE]) {\n\t\terr = vxlan_nl2flag(conf, data, IFLA_VXLAN_GPE,\n\t\t\t\t    VXLAN_F_GPE, changelink, false,\n\t\t\t\t    extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (data[IFLA_VXLAN_REMCSUM_NOPARTIAL]) {\n\t\terr = vxlan_nl2flag(conf, data, IFLA_VXLAN_REMCSUM_NOPARTIAL,\n\t\t\t\t    VXLAN_F_REMCSUM_NOPARTIAL, changelink,\n\t\t\t\t    false, extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (tb[IFLA_MTU]) {\n\t\tif (changelink) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, tb[IFLA_MTU],\n\t\t\t\t\t    \"Cannot change mtu\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tconf->mtu = nla_get_u32(tb[IFLA_MTU]);\n\t}\n\n\tif (data[IFLA_VXLAN_DF])\n\t\tconf->df = nla_get_u8(data[IFLA_VXLAN_DF]);\n\n\tif (data[IFLA_VXLAN_VNIFILTER]) {\n\t\terr = vxlan_nl2flag(conf, data, IFLA_VXLAN_VNIFILTER,\n\t\t\t\t    VXLAN_F_VNIFILTER, changelink, false,\n\t\t\t\t    extack);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif ((conf->flags & VXLAN_F_VNIFILTER) &&\n\t\t    !(conf->flags & VXLAN_F_COLLECT_METADATA)) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, data[IFLA_VXLAN_VNIFILTER],\n\t\t\t\t\t    \"vxlan vnifilter only valid in collect metadata mode\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int vxlan_newlink(struct net *src_net, struct net_device *dev,\n\t\t\t struct nlattr *tb[], struct nlattr *data[],\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_config conf;\n\tint err;\n\n\terr = vxlan_nl2conf(tb, data, dev, &conf, false, extack);\n\tif (err)\n\t\treturn err;\n\n\treturn __vxlan_dev_create(src_net, dev, &conf, extack);\n}\n\nstatic int vxlan_changelink(struct net_device *dev, struct nlattr *tb[],\n\t\t\t    struct nlattr *data[],\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tstruct net_device *lowerdev;\n\tstruct vxlan_config conf;\n\tstruct vxlan_rdst *dst;\n\tint err;\n\n\tdst = &vxlan->default_dst;\n\terr = vxlan_nl2conf(tb, data, dev, &conf, true, extack);\n\tif (err)\n\t\treturn err;\n\n\terr = vxlan_config_validate(vxlan->net, &conf, &lowerdev,\n\t\t\t\t    vxlan, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (dst->remote_dev == lowerdev)\n\t\tlowerdev = NULL;\n\n\terr = netdev_adjacent_change_prepare(dst->remote_dev, lowerdev, dev,\n\t\t\t\t\t     extack);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!vxlan_addr_equal(&conf.remote_ip, &dst->remote_ip)) {\n\t\tu32 hash_index = fdb_head_index(vxlan, all_zeros_mac, conf.vni);\n\n\t\tspin_lock_bh(&vxlan->hash_lock[hash_index]);\n\t\tif (!vxlan_addr_any(&conf.remote_ip)) {\n\t\t\terr = vxlan_fdb_update(vxlan, all_zeros_mac,\n\t\t\t\t\t       &conf.remote_ip,\n\t\t\t\t\t       NUD_REACHABLE | NUD_PERMANENT,\n\t\t\t\t\t       NLM_F_APPEND | NLM_F_CREATE,\n\t\t\t\t\t       vxlan->cfg.dst_port,\n\t\t\t\t\t       conf.vni, conf.vni,\n\t\t\t\t\t       conf.remote_ifindex,\n\t\t\t\t\t       NTF_SELF, 0, true, extack);\n\t\t\tif (err) {\n\t\t\t\tspin_unlock_bh(&vxlan->hash_lock[hash_index]);\n\t\t\t\tnetdev_adjacent_change_abort(dst->remote_dev,\n\t\t\t\t\t\t\t     lowerdev, dev);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tif (!vxlan_addr_any(&dst->remote_ip))\n\t\t\t__vxlan_fdb_delete(vxlan, all_zeros_mac,\n\t\t\t\t\t   dst->remote_ip,\n\t\t\t\t\t   vxlan->cfg.dst_port,\n\t\t\t\t\t   dst->remote_vni,\n\t\t\t\t\t   dst->remote_vni,\n\t\t\t\t\t   dst->remote_ifindex,\n\t\t\t\t\t   true);\n\t\tspin_unlock_bh(&vxlan->hash_lock[hash_index]);\n\n\t\t \n\t\tif (vxlan->cfg.flags & VXLAN_F_VNIFILTER) {\n\t\t\terr = vxlan_vnilist_update_group(vxlan, &dst->remote_ip,\n\t\t\t\t\t\t\t &conf.remote_ip, extack);\n\t\t\tif (err) {\n\t\t\t\tnetdev_adjacent_change_abort(dst->remote_dev,\n\t\t\t\t\t\t\t     lowerdev, dev);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (conf.age_interval != vxlan->cfg.age_interval)\n\t\tmod_timer(&vxlan->age_timer, jiffies);\n\n\tnetdev_adjacent_change_commit(dst->remote_dev, lowerdev, dev);\n\tif (lowerdev && lowerdev != dst->remote_dev)\n\t\tdst->remote_dev = lowerdev;\n\tvxlan_config_apply(dev, &conf, lowerdev, vxlan->net, true);\n\treturn 0;\n}\n\nstatic void vxlan_dellink(struct net_device *dev, struct list_head *head)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\n\tvxlan_flush(vxlan, true);\n\n\tlist_del(&vxlan->next);\n\tunregister_netdevice_queue(dev, head);\n\tif (vxlan->default_dst.remote_dev)\n\t\tnetdev_upper_dev_unlink(vxlan->default_dst.remote_dev, dev);\n}\n\nstatic size_t vxlan_get_size(const struct net_device *dev)\n{\n\n\treturn nla_total_size(sizeof(__u32)) +\t \n\t\tnla_total_size(sizeof(struct in6_addr)) +  \n\t\tnla_total_size(sizeof(__u32)) +\t \n\t\tnla_total_size(sizeof(struct in6_addr)) +  \n\t\tnla_total_size(sizeof(__u8)) +\t \n\t\tnla_total_size(sizeof(__u8)) +\t \n\t\tnla_total_size(sizeof(__u8)) +\t \n\t\tnla_total_size(sizeof(__u8)) +\t \n\t\tnla_total_size(sizeof(__be32)) +  \n\t\tnla_total_size(sizeof(__u8)) +\t \n\t\tnla_total_size(sizeof(__u8)) +\t \n\t\tnla_total_size(sizeof(__u8)) +\t \n\t\tnla_total_size(sizeof(__u8)) +\t \n\t\tnla_total_size(sizeof(__u8)) +\t \n\t\tnla_total_size(sizeof(__u8)) +\t \n\t\tnla_total_size(sizeof(__u32)) +\t \n\t\tnla_total_size(sizeof(__u32)) +\t \n\t\tnla_total_size(sizeof(struct ifla_vxlan_port_range)) +\n\t\tnla_total_size(sizeof(__be16)) +  \n\t\tnla_total_size(sizeof(__u8)) +  \n\t\tnla_total_size(sizeof(__u8)) +  \n\t\tnla_total_size(sizeof(__u8)) +  \n\t\tnla_total_size(sizeof(__u8)) +  \n\t\tnla_total_size(sizeof(__u8)) +  \n\t\tnla_total_size(sizeof(__u8)) +  \n\t\tnla_total_size(0) +  \n\t\tnla_total_size(0) +  \n\t\tnla_total_size(0) +  \n\t\tnla_total_size(sizeof(__u8)) +  \n\t\t0;\n}\n\nstatic int vxlan_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\tconst struct vxlan_dev *vxlan = netdev_priv(dev);\n\tconst struct vxlan_rdst *dst = &vxlan->default_dst;\n\tstruct ifla_vxlan_port_range ports = {\n\t\t.low =  htons(vxlan->cfg.port_min),\n\t\t.high = htons(vxlan->cfg.port_max),\n\t};\n\n\tif (nla_put_u32(skb, IFLA_VXLAN_ID, be32_to_cpu(dst->remote_vni)))\n\t\tgoto nla_put_failure;\n\n\tif (!vxlan_addr_any(&dst->remote_ip)) {\n\t\tif (dst->remote_ip.sa.sa_family == AF_INET) {\n\t\t\tif (nla_put_in_addr(skb, IFLA_VXLAN_GROUP,\n\t\t\t\t\t    dst->remote_ip.sin.sin_addr.s_addr))\n\t\t\t\tgoto nla_put_failure;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t} else {\n\t\t\tif (nla_put_in6_addr(skb, IFLA_VXLAN_GROUP6,\n\t\t\t\t\t     &dst->remote_ip.sin6.sin6_addr))\n\t\t\t\tgoto nla_put_failure;\n#endif\n\t\t}\n\t}\n\n\tif (dst->remote_ifindex && nla_put_u32(skb, IFLA_VXLAN_LINK, dst->remote_ifindex))\n\t\tgoto nla_put_failure;\n\n\tif (!vxlan_addr_any(&vxlan->cfg.saddr)) {\n\t\tif (vxlan->cfg.saddr.sa.sa_family == AF_INET) {\n\t\t\tif (nla_put_in_addr(skb, IFLA_VXLAN_LOCAL,\n\t\t\t\t\t    vxlan->cfg.saddr.sin.sin_addr.s_addr))\n\t\t\t\tgoto nla_put_failure;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t} else {\n\t\t\tif (nla_put_in6_addr(skb, IFLA_VXLAN_LOCAL6,\n\t\t\t\t\t     &vxlan->cfg.saddr.sin6.sin6_addr))\n\t\t\t\tgoto nla_put_failure;\n#endif\n\t\t}\n\t}\n\n\tif (nla_put_u8(skb, IFLA_VXLAN_TTL, vxlan->cfg.ttl) ||\n\t    nla_put_u8(skb, IFLA_VXLAN_TTL_INHERIT,\n\t\t       !!(vxlan->cfg.flags & VXLAN_F_TTL_INHERIT)) ||\n\t    nla_put_u8(skb, IFLA_VXLAN_TOS, vxlan->cfg.tos) ||\n\t    nla_put_u8(skb, IFLA_VXLAN_DF, vxlan->cfg.df) ||\n\t    nla_put_be32(skb, IFLA_VXLAN_LABEL, vxlan->cfg.label) ||\n\t    nla_put_u8(skb, IFLA_VXLAN_LEARNING,\n\t\t       !!(vxlan->cfg.flags & VXLAN_F_LEARN)) ||\n\t    nla_put_u8(skb, IFLA_VXLAN_PROXY,\n\t\t       !!(vxlan->cfg.flags & VXLAN_F_PROXY)) ||\n\t    nla_put_u8(skb, IFLA_VXLAN_RSC,\n\t\t       !!(vxlan->cfg.flags & VXLAN_F_RSC)) ||\n\t    nla_put_u8(skb, IFLA_VXLAN_L2MISS,\n\t\t       !!(vxlan->cfg.flags & VXLAN_F_L2MISS)) ||\n\t    nla_put_u8(skb, IFLA_VXLAN_L3MISS,\n\t\t       !!(vxlan->cfg.flags & VXLAN_F_L3MISS)) ||\n\t    nla_put_u8(skb, IFLA_VXLAN_COLLECT_METADATA,\n\t\t       !!(vxlan->cfg.flags & VXLAN_F_COLLECT_METADATA)) ||\n\t    nla_put_u32(skb, IFLA_VXLAN_AGEING, vxlan->cfg.age_interval) ||\n\t    nla_put_u32(skb, IFLA_VXLAN_LIMIT, vxlan->cfg.addrmax) ||\n\t    nla_put_be16(skb, IFLA_VXLAN_PORT, vxlan->cfg.dst_port) ||\n\t    nla_put_u8(skb, IFLA_VXLAN_UDP_CSUM,\n\t\t       !(vxlan->cfg.flags & VXLAN_F_UDP_ZERO_CSUM_TX)) ||\n\t    nla_put_u8(skb, IFLA_VXLAN_UDP_ZERO_CSUM6_TX,\n\t\t       !!(vxlan->cfg.flags & VXLAN_F_UDP_ZERO_CSUM6_TX)) ||\n\t    nla_put_u8(skb, IFLA_VXLAN_UDP_ZERO_CSUM6_RX,\n\t\t       !!(vxlan->cfg.flags & VXLAN_F_UDP_ZERO_CSUM6_RX)) ||\n\t    nla_put_u8(skb, IFLA_VXLAN_REMCSUM_TX,\n\t\t       !!(vxlan->cfg.flags & VXLAN_F_REMCSUM_TX)) ||\n\t    nla_put_u8(skb, IFLA_VXLAN_REMCSUM_RX,\n\t\t       !!(vxlan->cfg.flags & VXLAN_F_REMCSUM_RX)) ||\n\t    nla_put_u8(skb, IFLA_VXLAN_LOCALBYPASS,\n\t\t       !!(vxlan->cfg.flags & VXLAN_F_LOCALBYPASS)))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put(skb, IFLA_VXLAN_PORT_RANGE, sizeof(ports), &ports))\n\t\tgoto nla_put_failure;\n\n\tif (vxlan->cfg.flags & VXLAN_F_GBP &&\n\t    nla_put_flag(skb, IFLA_VXLAN_GBP))\n\t\tgoto nla_put_failure;\n\n\tif (vxlan->cfg.flags & VXLAN_F_GPE &&\n\t    nla_put_flag(skb, IFLA_VXLAN_GPE))\n\t\tgoto nla_put_failure;\n\n\tif (vxlan->cfg.flags & VXLAN_F_REMCSUM_NOPARTIAL &&\n\t    nla_put_flag(skb, IFLA_VXLAN_REMCSUM_NOPARTIAL))\n\t\tgoto nla_put_failure;\n\n\tif (vxlan->cfg.flags & VXLAN_F_VNIFILTER &&\n\t    nla_put_u8(skb, IFLA_VXLAN_VNIFILTER,\n\t\t       !!(vxlan->cfg.flags & VXLAN_F_VNIFILTER)))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic struct net *vxlan_get_link_net(const struct net_device *dev)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\n\treturn vxlan->net;\n}\n\nstatic struct rtnl_link_ops vxlan_link_ops __read_mostly = {\n\t.kind\t\t= \"vxlan\",\n\t.maxtype\t= IFLA_VXLAN_MAX,\n\t.policy\t\t= vxlan_policy,\n\t.priv_size\t= sizeof(struct vxlan_dev),\n\t.setup\t\t= vxlan_setup,\n\t.validate\t= vxlan_validate,\n\t.newlink\t= vxlan_newlink,\n\t.changelink\t= vxlan_changelink,\n\t.dellink\t= vxlan_dellink,\n\t.get_size\t= vxlan_get_size,\n\t.fill_info\t= vxlan_fill_info,\n\t.get_link_net\t= vxlan_get_link_net,\n};\n\nstruct net_device *vxlan_dev_create(struct net *net, const char *name,\n\t\t\t\t    u8 name_assign_type,\n\t\t\t\t    struct vxlan_config *conf)\n{\n\tstruct nlattr *tb[IFLA_MAX + 1];\n\tstruct net_device *dev;\n\tint err;\n\n\tmemset(&tb, 0, sizeof(tb));\n\n\tdev = rtnl_create_link(net, name, name_assign_type,\n\t\t\t       &vxlan_link_ops, tb, NULL);\n\tif (IS_ERR(dev))\n\t\treturn dev;\n\n\terr = __vxlan_dev_create(net, dev, conf, NULL);\n\tif (err < 0) {\n\t\tfree_netdev(dev);\n\t\treturn ERR_PTR(err);\n\t}\n\n\terr = rtnl_configure_link(dev, NULL, 0, NULL);\n\tif (err < 0) {\n\t\tLIST_HEAD(list_kill);\n\n\t\tvxlan_dellink(dev, &list_kill);\n\t\tunregister_netdevice_many(&list_kill);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn dev;\n}\nEXPORT_SYMBOL_GPL(vxlan_dev_create);\n\nstatic void vxlan_handle_lowerdev_unregister(struct vxlan_net *vn,\n\t\t\t\t\t     struct net_device *dev)\n{\n\tstruct vxlan_dev *vxlan, *next;\n\tLIST_HEAD(list_kill);\n\n\tlist_for_each_entry_safe(vxlan, next, &vn->vxlan_list, next) {\n\t\tstruct vxlan_rdst *dst = &vxlan->default_dst;\n\n\t\t \n\t\tif (dst->remote_ifindex == dev->ifindex)\n\t\t\tvxlan_dellink(vxlan->dev, &list_kill);\n\t}\n\n\tunregister_netdevice_many(&list_kill);\n}\n\nstatic int vxlan_netdevice_event(struct notifier_block *unused,\n\t\t\t\t unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct vxlan_net *vn = net_generic(dev_net(dev), vxlan_net_id);\n\n\tif (event == NETDEV_UNREGISTER)\n\t\tvxlan_handle_lowerdev_unregister(vn, dev);\n\telse if (event == NETDEV_UDP_TUNNEL_PUSH_INFO)\n\t\tvxlan_offload_rx_ports(dev, true);\n\telse if (event == NETDEV_UDP_TUNNEL_DROP_INFO)\n\t\tvxlan_offload_rx_ports(dev, false);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block vxlan_notifier_block __read_mostly = {\n\t.notifier_call = vxlan_netdevice_event,\n};\n\nstatic void\nvxlan_fdb_offloaded_set(struct net_device *dev,\n\t\t\tstruct switchdev_notifier_vxlan_fdb_info *fdb_info)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tstruct vxlan_rdst *rdst;\n\tstruct vxlan_fdb *f;\n\tu32 hash_index;\n\n\thash_index = fdb_head_index(vxlan, fdb_info->eth_addr, fdb_info->vni);\n\n\tspin_lock_bh(&vxlan->hash_lock[hash_index]);\n\n\tf = vxlan_find_mac(vxlan, fdb_info->eth_addr, fdb_info->vni);\n\tif (!f)\n\t\tgoto out;\n\n\trdst = vxlan_fdb_find_rdst(f, &fdb_info->remote_ip,\n\t\t\t\t   fdb_info->remote_port,\n\t\t\t\t   fdb_info->remote_vni,\n\t\t\t\t   fdb_info->remote_ifindex);\n\tif (!rdst)\n\t\tgoto out;\n\n\trdst->offloaded = fdb_info->offloaded;\n\nout:\n\tspin_unlock_bh(&vxlan->hash_lock[hash_index]);\n}\n\nstatic int\nvxlan_fdb_external_learn_add(struct net_device *dev,\n\t\t\t     struct switchdev_notifier_vxlan_fdb_info *fdb_info)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tstruct netlink_ext_ack *extack;\n\tu32 hash_index;\n\tint err;\n\n\thash_index = fdb_head_index(vxlan, fdb_info->eth_addr, fdb_info->vni);\n\textack = switchdev_notifier_info_to_extack(&fdb_info->info);\n\n\tspin_lock_bh(&vxlan->hash_lock[hash_index]);\n\terr = vxlan_fdb_update(vxlan, fdb_info->eth_addr, &fdb_info->remote_ip,\n\t\t\t       NUD_REACHABLE,\n\t\t\t       NLM_F_CREATE | NLM_F_REPLACE,\n\t\t\t       fdb_info->remote_port,\n\t\t\t       fdb_info->vni,\n\t\t\t       fdb_info->remote_vni,\n\t\t\t       fdb_info->remote_ifindex,\n\t\t\t       NTF_USE | NTF_SELF | NTF_EXT_LEARNED,\n\t\t\t       0, false, extack);\n\tspin_unlock_bh(&vxlan->hash_lock[hash_index]);\n\n\treturn err;\n}\n\nstatic int\nvxlan_fdb_external_learn_del(struct net_device *dev,\n\t\t\t     struct switchdev_notifier_vxlan_fdb_info *fdb_info)\n{\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tstruct vxlan_fdb *f;\n\tu32 hash_index;\n\tint err = 0;\n\n\thash_index = fdb_head_index(vxlan, fdb_info->eth_addr, fdb_info->vni);\n\tspin_lock_bh(&vxlan->hash_lock[hash_index]);\n\n\tf = vxlan_find_mac(vxlan, fdb_info->eth_addr, fdb_info->vni);\n\tif (!f)\n\t\terr = -ENOENT;\n\telse if (f->flags & NTF_EXT_LEARNED)\n\t\terr = __vxlan_fdb_delete(vxlan, fdb_info->eth_addr,\n\t\t\t\t\t fdb_info->remote_ip,\n\t\t\t\t\t fdb_info->remote_port,\n\t\t\t\t\t fdb_info->vni,\n\t\t\t\t\t fdb_info->remote_vni,\n\t\t\t\t\t fdb_info->remote_ifindex,\n\t\t\t\t\t false);\n\n\tspin_unlock_bh(&vxlan->hash_lock[hash_index]);\n\n\treturn err;\n}\n\nstatic int vxlan_switchdev_event(struct notifier_block *unused,\n\t\t\t\t unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = switchdev_notifier_info_to_dev(ptr);\n\tstruct switchdev_notifier_vxlan_fdb_info *fdb_info;\n\tint err = 0;\n\n\tswitch (event) {\n\tcase SWITCHDEV_VXLAN_FDB_OFFLOADED:\n\t\tvxlan_fdb_offloaded_set(dev, ptr);\n\t\tbreak;\n\tcase SWITCHDEV_VXLAN_FDB_ADD_TO_BRIDGE:\n\t\tfdb_info = ptr;\n\t\terr = vxlan_fdb_external_learn_add(dev, fdb_info);\n\t\tif (err) {\n\t\t\terr = notifier_from_errno(err);\n\t\t\tbreak;\n\t\t}\n\t\tfdb_info->offloaded = true;\n\t\tvxlan_fdb_offloaded_set(dev, fdb_info);\n\t\tbreak;\n\tcase SWITCHDEV_VXLAN_FDB_DEL_TO_BRIDGE:\n\t\tfdb_info = ptr;\n\t\terr = vxlan_fdb_external_learn_del(dev, fdb_info);\n\t\tif (err) {\n\t\t\terr = notifier_from_errno(err);\n\t\t\tbreak;\n\t\t}\n\t\tfdb_info->offloaded = false;\n\t\tvxlan_fdb_offloaded_set(dev, fdb_info);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic struct notifier_block vxlan_switchdev_notifier_block __read_mostly = {\n\t.notifier_call = vxlan_switchdev_event,\n};\n\nstatic void vxlan_fdb_nh_flush(struct nexthop *nh)\n{\n\tstruct vxlan_fdb *fdb;\n\tstruct vxlan_dev *vxlan;\n\tu32 hash_index;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(fdb, &nh->fdb_list, nh_list) {\n\t\tvxlan = rcu_dereference(fdb->vdev);\n\t\tWARN_ON(!vxlan);\n\t\thash_index = fdb_head_index(vxlan, fdb->eth_addr,\n\t\t\t\t\t    vxlan->default_dst.remote_vni);\n\t\tspin_lock_bh(&vxlan->hash_lock[hash_index]);\n\t\tif (!hlist_unhashed(&fdb->hlist))\n\t\t\tvxlan_fdb_destroy(vxlan, fdb, false, false);\n\t\tspin_unlock_bh(&vxlan->hash_lock[hash_index]);\n\t}\n\trcu_read_unlock();\n}\n\nstatic int vxlan_nexthop_event(struct notifier_block *nb,\n\t\t\t       unsigned long event, void *ptr)\n{\n\tstruct nh_notifier_info *info = ptr;\n\tstruct nexthop *nh;\n\n\tif (event != NEXTHOP_EVENT_DEL)\n\t\treturn NOTIFY_DONE;\n\n\tnh = nexthop_find_by_id(info->net, info->id);\n\tif (!nh)\n\t\treturn NOTIFY_DONE;\n\n\tvxlan_fdb_nh_flush(nh);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic __net_init int vxlan_init_net(struct net *net)\n{\n\tstruct vxlan_net *vn = net_generic(net, vxlan_net_id);\n\tunsigned int h;\n\n\tINIT_LIST_HEAD(&vn->vxlan_list);\n\tspin_lock_init(&vn->sock_lock);\n\tvn->nexthop_notifier_block.notifier_call = vxlan_nexthop_event;\n\n\tfor (h = 0; h < PORT_HASH_SIZE; ++h)\n\t\tINIT_HLIST_HEAD(&vn->sock_list[h]);\n\n\treturn register_nexthop_notifier(net, &vn->nexthop_notifier_block,\n\t\t\t\t\t NULL);\n}\n\nstatic void vxlan_destroy_tunnels(struct net *net, struct list_head *head)\n{\n\tstruct vxlan_net *vn = net_generic(net, vxlan_net_id);\n\tstruct vxlan_dev *vxlan, *next;\n\tstruct net_device *dev, *aux;\n\n\tfor_each_netdev_safe(net, dev, aux)\n\t\tif (dev->rtnl_link_ops == &vxlan_link_ops)\n\t\t\tunregister_netdevice_queue(dev, head);\n\n\tlist_for_each_entry_safe(vxlan, next, &vn->vxlan_list, next) {\n\t\t \n\t\tif (!net_eq(dev_net(vxlan->dev), net))\n\t\t\tunregister_netdevice_queue(vxlan->dev, head);\n\t}\n\n}\n\nstatic void __net_exit vxlan_exit_batch_net(struct list_head *net_list)\n{\n\tstruct net *net;\n\tLIST_HEAD(list);\n\tunsigned int h;\n\n\tlist_for_each_entry(net, net_list, exit_list) {\n\t\tstruct vxlan_net *vn = net_generic(net, vxlan_net_id);\n\n\t\tunregister_nexthop_notifier(net, &vn->nexthop_notifier_block);\n\t}\n\trtnl_lock();\n\tlist_for_each_entry(net, net_list, exit_list)\n\t\tvxlan_destroy_tunnels(net, &list);\n\n\tunregister_netdevice_many(&list);\n\trtnl_unlock();\n\n\tlist_for_each_entry(net, net_list, exit_list) {\n\t\tstruct vxlan_net *vn = net_generic(net, vxlan_net_id);\n\n\t\tfor (h = 0; h < PORT_HASH_SIZE; ++h)\n\t\t\tWARN_ON_ONCE(!hlist_empty(&vn->sock_list[h]));\n\t}\n}\n\nstatic struct pernet_operations vxlan_net_ops = {\n\t.init = vxlan_init_net,\n\t.exit_batch = vxlan_exit_batch_net,\n\t.id   = &vxlan_net_id,\n\t.size = sizeof(struct vxlan_net),\n};\n\nstatic int __init vxlan_init_module(void)\n{\n\tint rc;\n\n\tget_random_bytes(&vxlan_salt, sizeof(vxlan_salt));\n\n\trc = register_pernet_subsys(&vxlan_net_ops);\n\tif (rc)\n\t\tgoto out1;\n\n\trc = register_netdevice_notifier(&vxlan_notifier_block);\n\tif (rc)\n\t\tgoto out2;\n\n\trc = register_switchdev_notifier(&vxlan_switchdev_notifier_block);\n\tif (rc)\n\t\tgoto out3;\n\n\trc = rtnl_link_register(&vxlan_link_ops);\n\tif (rc)\n\t\tgoto out4;\n\n\tvxlan_vnifilter_init();\n\n\treturn 0;\nout4:\n\tunregister_switchdev_notifier(&vxlan_switchdev_notifier_block);\nout3:\n\tunregister_netdevice_notifier(&vxlan_notifier_block);\nout2:\n\tunregister_pernet_subsys(&vxlan_net_ops);\nout1:\n\treturn rc;\n}\nlate_initcall(vxlan_init_module);\n\nstatic void __exit vxlan_cleanup_module(void)\n{\n\tvxlan_vnifilter_uninit();\n\trtnl_link_unregister(&vxlan_link_ops);\n\tunregister_switchdev_notifier(&vxlan_switchdev_notifier_block);\n\tunregister_netdevice_notifier(&vxlan_notifier_block);\n\tunregister_pernet_subsys(&vxlan_net_ops);\n\t \n}\nmodule_exit(vxlan_cleanup_module);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(VXLAN_VERSION);\nMODULE_AUTHOR(\"Stephen Hemminger <stephen@networkplumber.org>\");\nMODULE_DESCRIPTION(\"Driver for VXLAN encapsulated traffic\");\nMODULE_ALIAS_RTNL_LINK(\"vxlan\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}