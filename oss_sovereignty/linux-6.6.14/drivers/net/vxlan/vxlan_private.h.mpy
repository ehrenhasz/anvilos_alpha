{
  "module_name": "vxlan_private.h",
  "hash_id": "77f56f53fb3b165a4b6ca430e78fc4c2170b50a957c10d37ec6fc1376dbb0362",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/vxlan/vxlan_private.h",
  "human_readable_source": " \n \n\n#ifndef _VXLAN_PRIVATE_H\n#define _VXLAN_PRIVATE_H\n\n#include <linux/rhashtable.h>\n\nextern unsigned int vxlan_net_id;\nextern const u8 all_zeros_mac[ETH_ALEN + 2];\nextern const struct rhashtable_params vxlan_vni_rht_params;\n\n#define PORT_HASH_BITS\t8\n#define PORT_HASH_SIZE  (1 << PORT_HASH_BITS)\n\n \nstruct vxlan_net {\n\tstruct list_head  vxlan_list;\n\tstruct hlist_head sock_list[PORT_HASH_SIZE];\n\tspinlock_t\t  sock_lock;\n\tstruct notifier_block nexthop_notifier_block;\n};\n\n \nstruct vxlan_fdb {\n\tstruct hlist_node hlist;\t \n\tstruct rcu_head\t  rcu;\n\tunsigned long\t  updated;\t \n\tunsigned long\t  used;\n\tstruct list_head  remotes;\n\tu8\t\t  eth_addr[ETH_ALEN];\n\tu16\t\t  state;\t \n\t__be32\t\t  vni;\n\tu16\t\t  flags;\t \n\tstruct list_head  nh_list;\n\tstruct nexthop __rcu *nh;\n\tstruct vxlan_dev  __rcu *vdev;\n};\n\n#define NTF_VXLAN_ADDED_BY_USER 0x100\n\n \nstatic inline struct hlist_head *vni_head(struct vxlan_sock *vs, __be32 vni)\n{\n\treturn &vs->vni_list[hash_32((__force u32)vni, VNI_HASH_BITS)];\n}\n\n \nstatic inline struct hlist_head *vs_head(struct net *net, __be16 port)\n{\n\tstruct vxlan_net *vn = net_generic(net, vxlan_net_id);\n\n\treturn &vn->sock_list[hash_32(ntohs(port), PORT_HASH_BITS)];\n}\n\n \nstatic inline struct vxlan_rdst *first_remote_rcu(struct vxlan_fdb *fdb)\n{\n\tif (rcu_access_pointer(fdb->nh))\n\t\treturn NULL;\n\treturn list_entry_rcu(fdb->remotes.next, struct vxlan_rdst, list);\n}\n\nstatic inline struct vxlan_rdst *first_remote_rtnl(struct vxlan_fdb *fdb)\n{\n\tif (rcu_access_pointer(fdb->nh))\n\t\treturn NULL;\n\treturn list_first_entry(&fdb->remotes, struct vxlan_rdst, list);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic inline\nbool vxlan_addr_equal(const union vxlan_addr *a, const union vxlan_addr *b)\n{\n\tif (a->sa.sa_family != b->sa.sa_family)\n\t\treturn false;\n\tif (a->sa.sa_family == AF_INET6)\n\t\treturn ipv6_addr_equal(&a->sin6.sin6_addr, &b->sin6.sin6_addr);\n\telse\n\t\treturn a->sin.sin_addr.s_addr == b->sin.sin_addr.s_addr;\n}\n\nstatic inline int vxlan_nla_get_addr(union vxlan_addr *ip,\n\t\t\t\t     const struct nlattr *nla)\n{\n\tif (nla_len(nla) >= sizeof(struct in6_addr)) {\n\t\tip->sin6.sin6_addr = nla_get_in6_addr(nla);\n\t\tip->sa.sa_family = AF_INET6;\n\t\treturn 0;\n\t} else if (nla_len(nla) >= sizeof(__be32)) {\n\t\tip->sin.sin_addr.s_addr = nla_get_in_addr(nla);\n\t\tip->sa.sa_family = AF_INET;\n\t\treturn 0;\n\t} else {\n\t\treturn -EAFNOSUPPORT;\n\t}\n}\n\nstatic inline int vxlan_nla_put_addr(struct sk_buff *skb, int attr,\n\t\t\t\t     const union vxlan_addr *ip)\n{\n\tif (ip->sa.sa_family == AF_INET6)\n\t\treturn nla_put_in6_addr(skb, attr, &ip->sin6.sin6_addr);\n\telse\n\t\treturn nla_put_in_addr(skb, attr, ip->sin.sin_addr.s_addr);\n}\n\nstatic inline bool vxlan_addr_is_multicast(const union vxlan_addr *ip)\n{\n\tif (ip->sa.sa_family == AF_INET6)\n\t\treturn ipv6_addr_is_multicast(&ip->sin6.sin6_addr);\n\telse\n\t\treturn ipv4_is_multicast(ip->sin.sin_addr.s_addr);\n}\n\n#else  \n\nstatic inline\nbool vxlan_addr_equal(const union vxlan_addr *a, const union vxlan_addr *b)\n{\n\treturn a->sin.sin_addr.s_addr == b->sin.sin_addr.s_addr;\n}\n\nstatic inline int vxlan_nla_get_addr(union vxlan_addr *ip,\n\t\t\t\t     const struct nlattr *nla)\n{\n\tif (nla_len(nla) >= sizeof(struct in6_addr)) {\n\t\treturn -EAFNOSUPPORT;\n\t} else if (nla_len(nla) >= sizeof(__be32)) {\n\t\tip->sin.sin_addr.s_addr = nla_get_in_addr(nla);\n\t\tip->sa.sa_family = AF_INET;\n\t\treturn 0;\n\t} else {\n\t\treturn -EAFNOSUPPORT;\n\t}\n}\n\nstatic inline int vxlan_nla_put_addr(struct sk_buff *skb, int attr,\n\t\t\t\t     const union vxlan_addr *ip)\n{\n\treturn nla_put_in_addr(skb, attr, ip->sin.sin_addr.s_addr);\n}\n\nstatic inline bool vxlan_addr_is_multicast(const union vxlan_addr *ip)\n{\n\treturn ipv4_is_multicast(ip->sin.sin_addr.s_addr);\n}\n\n#endif\n\nstatic inline size_t vxlan_addr_size(const union vxlan_addr *ip)\n{\n\tif (ip->sa.sa_family == AF_INET6)\n\t\treturn sizeof(struct in6_addr);\n\telse\n\t\treturn sizeof(__be32);\n}\n\nstatic inline struct vxlan_vni_node *\nvxlan_vnifilter_lookup(struct vxlan_dev *vxlan, __be32 vni)\n{\n\tstruct vxlan_vni_group *vg;\n\n\tvg = rcu_dereference_rtnl(vxlan->vnigrp);\n\tif (!vg)\n\t\treturn NULL;\n\n\treturn rhashtable_lookup_fast(&vg->vni_hash, &vni,\n\t\t\t\t      vxlan_vni_rht_params);\n}\n\n \nint vxlan_fdb_create(struct vxlan_dev *vxlan,\n\t\t     const u8 *mac, union vxlan_addr *ip,\n\t\t     __u16 state, __be16 port, __be32 src_vni,\n\t\t     __be32 vni, __u32 ifindex, __u16 ndm_flags,\n\t\t     u32 nhid, struct vxlan_fdb **fdb,\n\t\t     struct netlink_ext_ack *extack);\nint __vxlan_fdb_delete(struct vxlan_dev *vxlan,\n\t\t       const unsigned char *addr, union vxlan_addr ip,\n\t\t       __be16 port, __be32 src_vni, __be32 vni,\n\t\t       u32 ifindex, bool swdev_notify);\nu32 eth_vni_hash(const unsigned char *addr, __be32 vni);\nu32 fdb_head_index(struct vxlan_dev *vxlan, const u8 *mac, __be32 vni);\nint vxlan_fdb_update(struct vxlan_dev *vxlan,\n\t\t     const u8 *mac, union vxlan_addr *ip,\n\t\t     __u16 state, __u16 flags,\n\t\t     __be16 port, __be32 src_vni, __be32 vni,\n\t\t     __u32 ifindex, __u16 ndm_flags, u32 nhid,\n\t\t     bool swdev_notify, struct netlink_ext_ack *extack);\nvoid vxlan_xmit_one(struct sk_buff *skb, struct net_device *dev,\n\t\t    __be32 default_vni, struct vxlan_rdst *rdst, bool did_rsc);\nint vxlan_vni_in_use(struct net *src_net, struct vxlan_dev *vxlan,\n\t\t     struct vxlan_config *conf, __be32 vni);\n\n \nint vxlan_vnigroup_init(struct vxlan_dev *vxlan);\nvoid vxlan_vnigroup_uninit(struct vxlan_dev *vxlan);\n\nvoid vxlan_vnifilter_init(void);\nvoid vxlan_vnifilter_uninit(void);\nvoid vxlan_vnifilter_count(struct vxlan_dev *vxlan, __be32 vni,\n\t\t\t   struct vxlan_vni_node *vninode,\n\t\t\t   int type, unsigned int len);\n\nvoid vxlan_vs_add_vnigrp(struct vxlan_dev *vxlan,\n\t\t\t struct vxlan_sock *vs,\n\t\t\t bool ipv6);\nvoid vxlan_vs_del_vnigrp(struct vxlan_dev *vxlan);\nint vxlan_vnilist_update_group(struct vxlan_dev *vxlan,\n\t\t\t       union vxlan_addr *old_remote_ip,\n\t\t\t       union vxlan_addr *new_remote_ip,\n\t\t\t       struct netlink_ext_ack *extack);\n\n\n \nint vxlan_multicast_join(struct vxlan_dev *vxlan);\nint vxlan_multicast_leave(struct vxlan_dev *vxlan);\nbool vxlan_group_used(struct vxlan_net *vn, struct vxlan_dev *dev,\n\t\t      __be32 vni, union vxlan_addr *rip, int rifindex);\nint vxlan_igmp_join(struct vxlan_dev *vxlan, union vxlan_addr *rip,\n\t\t    int rifindex);\nint vxlan_igmp_leave(struct vxlan_dev *vxlan, union vxlan_addr *rip,\n\t\t     int rifindex);\n\n \nint vxlan_mdb_dump(struct net_device *dev, struct sk_buff *skb,\n\t\t   struct netlink_callback *cb);\nint vxlan_mdb_add(struct net_device *dev, struct nlattr *tb[], u16 nlmsg_flags,\n\t\t  struct netlink_ext_ack *extack);\nint vxlan_mdb_del(struct net_device *dev, struct nlattr *tb[],\n\t\t  struct netlink_ext_ack *extack);\nstruct vxlan_mdb_entry *vxlan_mdb_entry_skb_get(struct vxlan_dev *vxlan,\n\t\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\t\t__be32 src_vni);\nnetdev_tx_t vxlan_mdb_xmit(struct vxlan_dev *vxlan,\n\t\t\t   const struct vxlan_mdb_entry *mdb_entry,\n\t\t\t   struct sk_buff *skb);\nint vxlan_mdb_init(struct vxlan_dev *vxlan);\nvoid vxlan_mdb_fini(struct vxlan_dev *vxlan);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}