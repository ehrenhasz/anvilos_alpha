{
  "module_name": "vxlan_mdb.c",
  "hash_id": "cfa8b9deb3fcef01658b7236e986d3f70702adb8d61f78033438652cbe3c9830",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/vxlan/vxlan_mdb.c",
  "human_readable_source": "\n\n#include <linux/if_bridge.h>\n#include <linux/in.h>\n#include <linux/list.h>\n#include <linux/netdevice.h>\n#include <linux/netlink.h>\n#include <linux/rhashtable.h>\n#include <linux/rhashtable-types.h>\n#include <linux/rtnetlink.h>\n#include <linux/skbuff.h>\n#include <linux/types.h>\n#include <net/netlink.h>\n#include <net/vxlan.h>\n\n#include \"vxlan_private.h\"\n\nstruct vxlan_mdb_entry_key {\n\tunion vxlan_addr src;\n\tunion vxlan_addr dst;\n\t__be32 vni;\n};\n\nstruct vxlan_mdb_entry {\n\tstruct rhash_head rhnode;\n\tstruct list_head remotes;\n\tstruct vxlan_mdb_entry_key key;\n\tstruct hlist_node mdb_node;\n\tstruct rcu_head rcu;\n};\n\n#define VXLAN_MDB_REMOTE_F_BLOCKED\tBIT(0)\n\nstruct vxlan_mdb_remote {\n\tstruct list_head list;\n\tstruct vxlan_rdst __rcu *rd;\n\tu8 flags;\n\tu8 filter_mode;\n\tu8 rt_protocol;\n\tstruct hlist_head src_list;\n\tstruct rcu_head rcu;\n};\n\n#define VXLAN_SGRP_F_DELETE\tBIT(0)\n\nstruct vxlan_mdb_src_entry {\n\tstruct hlist_node node;\n\tunion vxlan_addr addr;\n\tu8 flags;\n};\n\nstruct vxlan_mdb_dump_ctx {\n\tlong reserved;\n\tlong entry_idx;\n\tlong remote_idx;\n};\n\nstruct vxlan_mdb_config_src_entry {\n\tunion vxlan_addr addr;\n\tstruct list_head node;\n};\n\nstruct vxlan_mdb_config {\n\tstruct vxlan_dev *vxlan;\n\tstruct vxlan_mdb_entry_key group;\n\tstruct list_head src_list;\n\tunion vxlan_addr remote_ip;\n\tu32 remote_ifindex;\n\t__be32 remote_vni;\n\t__be16 remote_port;\n\tu16 nlflags;\n\tu8 flags;\n\tu8 filter_mode;\n\tu8 rt_protocol;\n};\n\nstatic const struct rhashtable_params vxlan_mdb_rht_params = {\n\t.head_offset = offsetof(struct vxlan_mdb_entry, rhnode),\n\t.key_offset = offsetof(struct vxlan_mdb_entry, key),\n\t.key_len = sizeof(struct vxlan_mdb_entry_key),\n\t.automatic_shrinking = true,\n};\n\nstatic int __vxlan_mdb_add(const struct vxlan_mdb_config *cfg,\n\t\t\t   struct netlink_ext_ack *extack);\nstatic int __vxlan_mdb_del(const struct vxlan_mdb_config *cfg,\n\t\t\t   struct netlink_ext_ack *extack);\n\nstatic void vxlan_br_mdb_entry_fill(const struct vxlan_dev *vxlan,\n\t\t\t\t    const struct vxlan_mdb_entry *mdb_entry,\n\t\t\t\t    const struct vxlan_mdb_remote *remote,\n\t\t\t\t    struct br_mdb_entry *e)\n{\n\tconst union vxlan_addr *dst = &mdb_entry->key.dst;\n\n\tmemset(e, 0, sizeof(*e));\n\te->ifindex = vxlan->dev->ifindex;\n\te->state = MDB_PERMANENT;\n\n\tif (remote->flags & VXLAN_MDB_REMOTE_F_BLOCKED)\n\t\te->flags |= MDB_FLAGS_BLOCKED;\n\n\tswitch (dst->sa.sa_family) {\n\tcase AF_INET:\n\t\te->addr.u.ip4 = dst->sin.sin_addr.s_addr;\n\t\te->addr.proto = htons(ETH_P_IP);\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\te->addr.u.ip6 = dst->sin6.sin6_addr;\n\t\te->addr.proto = htons(ETH_P_IPV6);\n\t\tbreak;\n#endif\n\t}\n}\n\nstatic int vxlan_mdb_entry_info_fill_srcs(struct sk_buff *skb,\n\t\t\t\t\t  const struct vxlan_mdb_remote *remote)\n{\n\tstruct vxlan_mdb_src_entry *ent;\n\tstruct nlattr *nest;\n\n\tif (hlist_empty(&remote->src_list))\n\t\treturn 0;\n\n\tnest = nla_nest_start(skb, MDBA_MDB_EATTR_SRC_LIST);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\thlist_for_each_entry(ent, &remote->src_list, node) {\n\t\tstruct nlattr *nest_ent;\n\n\t\tnest_ent = nla_nest_start(skb, MDBA_MDB_SRCLIST_ENTRY);\n\t\tif (!nest_ent)\n\t\t\tgoto out_cancel_err;\n\n\t\tif (vxlan_nla_put_addr(skb, MDBA_MDB_SRCATTR_ADDRESS,\n\t\t\t\t       &ent->addr) ||\n\t\t    nla_put_u32(skb, MDBA_MDB_SRCATTR_TIMER, 0))\n\t\t\tgoto out_cancel_err;\n\n\t\tnla_nest_end(skb, nest_ent);\n\t}\n\n\tnla_nest_end(skb, nest);\n\n\treturn 0;\n\nout_cancel_err:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int vxlan_mdb_entry_info_fill(const struct vxlan_dev *vxlan,\n\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t     const struct vxlan_mdb_entry *mdb_entry,\n\t\t\t\t     const struct vxlan_mdb_remote *remote)\n{\n\tstruct vxlan_rdst *rd = rtnl_dereference(remote->rd);\n\tstruct br_mdb_entry e;\n\tstruct nlattr *nest;\n\n\tnest = nla_nest_start_noflag(skb, MDBA_MDB_ENTRY_INFO);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tvxlan_br_mdb_entry_fill(vxlan, mdb_entry, remote, &e);\n\n\tif (nla_put_nohdr(skb, sizeof(e), &e) ||\n\t    nla_put_u32(skb, MDBA_MDB_EATTR_TIMER, 0))\n\t\tgoto nest_err;\n\n\tif (!vxlan_addr_any(&mdb_entry->key.src) &&\n\t    vxlan_nla_put_addr(skb, MDBA_MDB_EATTR_SOURCE, &mdb_entry->key.src))\n\t\tgoto nest_err;\n\n\tif (nla_put_u8(skb, MDBA_MDB_EATTR_RTPROT, remote->rt_protocol) ||\n\t    nla_put_u8(skb, MDBA_MDB_EATTR_GROUP_MODE, remote->filter_mode) ||\n\t    vxlan_mdb_entry_info_fill_srcs(skb, remote) ||\n\t    vxlan_nla_put_addr(skb, MDBA_MDB_EATTR_DST, &rd->remote_ip))\n\t\tgoto nest_err;\n\n\tif (rd->remote_port && rd->remote_port != vxlan->cfg.dst_port &&\n\t    nla_put_u16(skb, MDBA_MDB_EATTR_DST_PORT,\n\t\t\tbe16_to_cpu(rd->remote_port)))\n\t\tgoto nest_err;\n\n\tif (rd->remote_vni != vxlan->default_dst.remote_vni &&\n\t    nla_put_u32(skb, MDBA_MDB_EATTR_VNI, be32_to_cpu(rd->remote_vni)))\n\t\tgoto nest_err;\n\n\tif (rd->remote_ifindex &&\n\t    nla_put_u32(skb, MDBA_MDB_EATTR_IFINDEX, rd->remote_ifindex))\n\t\tgoto nest_err;\n\n\tif ((vxlan->cfg.flags & VXLAN_F_COLLECT_METADATA) &&\n\t    mdb_entry->key.vni && nla_put_u32(skb, MDBA_MDB_EATTR_SRC_VNI,\n\t\t\t\t\t      be32_to_cpu(mdb_entry->key.vni)))\n\t\tgoto nest_err;\n\n\tnla_nest_end(skb, nest);\n\n\treturn 0;\n\nnest_err:\n\tnla_nest_cancel(skb, nest);\n\treturn -EMSGSIZE;\n}\n\nstatic int vxlan_mdb_entry_fill(const struct vxlan_dev *vxlan,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct vxlan_mdb_dump_ctx *ctx,\n\t\t\t\tconst struct vxlan_mdb_entry *mdb_entry)\n{\n\tint remote_idx = 0, s_remote_idx = ctx->remote_idx;\n\tstruct vxlan_mdb_remote *remote;\n\tstruct nlattr *nest;\n\tint err = 0;\n\n\tnest = nla_nest_start_noflag(skb, MDBA_MDB_ENTRY);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\tlist_for_each_entry(remote, &mdb_entry->remotes, list) {\n\t\tif (remote_idx < s_remote_idx)\n\t\t\tgoto skip;\n\n\t\terr = vxlan_mdb_entry_info_fill(vxlan, skb, mdb_entry, remote);\n\t\tif (err)\n\t\t\tbreak;\nskip:\n\t\tremote_idx++;\n\t}\n\n\tctx->remote_idx = err ? remote_idx : 0;\n\tnla_nest_end(skb, nest);\n\treturn err;\n}\n\nstatic int vxlan_mdb_fill(const struct vxlan_dev *vxlan, struct sk_buff *skb,\n\t\t\t  struct vxlan_mdb_dump_ctx *ctx)\n{\n\tint entry_idx = 0, s_entry_idx = ctx->entry_idx;\n\tstruct vxlan_mdb_entry *mdb_entry;\n\tstruct nlattr *nest;\n\tint err = 0;\n\n\tnest = nla_nest_start_noflag(skb, MDBA_MDB);\n\tif (!nest)\n\t\treturn -EMSGSIZE;\n\n\thlist_for_each_entry(mdb_entry, &vxlan->mdb_list, mdb_node) {\n\t\tif (entry_idx < s_entry_idx)\n\t\t\tgoto skip;\n\n\t\terr = vxlan_mdb_entry_fill(vxlan, skb, ctx, mdb_entry);\n\t\tif (err)\n\t\t\tbreak;\nskip:\n\t\tentry_idx++;\n\t}\n\n\tctx->entry_idx = err ? entry_idx : 0;\n\tnla_nest_end(skb, nest);\n\treturn err;\n}\n\nint vxlan_mdb_dump(struct net_device *dev, struct sk_buff *skb,\n\t\t   struct netlink_callback *cb)\n{\n\tstruct vxlan_mdb_dump_ctx *ctx = (void *)cb->ctx;\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tstruct br_port_msg *bpm;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tASSERT_RTNL();\n\n\tNL_ASSERT_DUMP_CTX_FITS(struct vxlan_mdb_dump_ctx);\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid,\n\t\t\tcb->nlh->nlmsg_seq, RTM_NEWMDB, sizeof(*bpm),\n\t\t\tNLM_F_MULTI);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tbpm = nlmsg_data(nlh);\n\tmemset(bpm, 0, sizeof(*bpm));\n\tbpm->family = AF_BRIDGE;\n\tbpm->ifindex = dev->ifindex;\n\n\terr = vxlan_mdb_fill(vxlan, skb, ctx);\n\n\tnlmsg_end(skb, nlh);\n\n\tcb->seq = vxlan->mdb_seq;\n\tnl_dump_check_consistent(cb, nlh);\n\n\treturn err;\n}\n\nstatic const struct nla_policy\nvxlan_mdbe_src_list_entry_pol[MDBE_SRCATTR_MAX + 1] = {\n\t[MDBE_SRCATTR_ADDRESS] = NLA_POLICY_RANGE(NLA_BINARY,\n\t\t\t\t\t\t  sizeof(struct in_addr),\n\t\t\t\t\t\t  sizeof(struct in6_addr)),\n};\n\nstatic const struct nla_policy\nvxlan_mdbe_src_list_pol[MDBE_SRC_LIST_MAX + 1] = {\n\t[MDBE_SRC_LIST_ENTRY] = NLA_POLICY_NESTED(vxlan_mdbe_src_list_entry_pol),\n};\n\nstatic struct netlink_range_validation vni_range = {\n\t.max = VXLAN_N_VID - 1,\n};\n\nstatic const struct nla_policy vxlan_mdbe_attrs_pol[MDBE_ATTR_MAX + 1] = {\n\t[MDBE_ATTR_SOURCE] = NLA_POLICY_RANGE(NLA_BINARY,\n\t\t\t\t\t      sizeof(struct in_addr),\n\t\t\t\t\t      sizeof(struct in6_addr)),\n\t[MDBE_ATTR_GROUP_MODE] = NLA_POLICY_RANGE(NLA_U8, MCAST_EXCLUDE,\n\t\t\t\t\t\t  MCAST_INCLUDE),\n\t[MDBE_ATTR_SRC_LIST] = NLA_POLICY_NESTED(vxlan_mdbe_src_list_pol),\n\t[MDBE_ATTR_RTPROT] = NLA_POLICY_MIN(NLA_U8, RTPROT_STATIC),\n\t[MDBE_ATTR_DST] = NLA_POLICY_RANGE(NLA_BINARY,\n\t\t\t\t\t   sizeof(struct in_addr),\n\t\t\t\t\t   sizeof(struct in6_addr)),\n\t[MDBE_ATTR_DST_PORT] = { .type = NLA_U16 },\n\t[MDBE_ATTR_VNI] = NLA_POLICY_FULL_RANGE(NLA_U32, &vni_range),\n\t[MDBE_ATTR_IFINDEX] = NLA_POLICY_MIN(NLA_S32, 1),\n\t[MDBE_ATTR_SRC_VNI] = NLA_POLICY_FULL_RANGE(NLA_U32, &vni_range),\n};\n\nstatic bool vxlan_mdb_is_valid_source(const struct nlattr *attr, __be16 proto,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tswitch (proto) {\n\tcase htons(ETH_P_IP):\n\t\tif (nla_len(attr) != sizeof(struct in_addr)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"IPv4 invalid source address length\");\n\t\t\treturn false;\n\t\t}\n\t\tif (ipv4_is_multicast(nla_get_in_addr(attr))) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"IPv4 multicast source address is not allowed\");\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6): {\n\t\tstruct in6_addr src;\n\n\t\tif (nla_len(attr) != sizeof(struct in6_addr)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"IPv6 invalid source address length\");\n\t\t\treturn false;\n\t\t}\n\t\tsrc = nla_get_in6_addr(attr);\n\t\tif (ipv6_addr_is_multicast(&src)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"IPv6 multicast source address is not allowed\");\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\t}\n#endif\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid protocol used with source address\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void vxlan_mdb_config_group_set(struct vxlan_mdb_config *cfg,\n\t\t\t\t       const struct br_mdb_entry *entry,\n\t\t\t\t       const struct nlattr *source_attr)\n{\n\tstruct vxlan_mdb_entry_key *group = &cfg->group;\n\n\tswitch (entry->addr.proto) {\n\tcase htons(ETH_P_IP):\n\t\tgroup->dst.sa.sa_family = AF_INET;\n\t\tgroup->dst.sin.sin_addr.s_addr = entry->addr.u.ip4;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\tgroup->dst.sa.sa_family = AF_INET6;\n\t\tgroup->dst.sin6.sin6_addr = entry->addr.u.ip6;\n\t\tbreak;\n#endif\n\t}\n\n\tif (source_attr)\n\t\tvxlan_nla_get_addr(&group->src, source_attr);\n}\n\nstatic bool vxlan_mdb_is_star_g(const struct vxlan_mdb_entry_key *group)\n{\n\treturn !vxlan_addr_any(&group->dst) && vxlan_addr_any(&group->src);\n}\n\nstatic bool vxlan_mdb_is_sg(const struct vxlan_mdb_entry_key *group)\n{\n\treturn !vxlan_addr_any(&group->dst) && !vxlan_addr_any(&group->src);\n}\n\nstatic int vxlan_mdb_config_src_entry_init(struct vxlan_mdb_config *cfg,\n\t\t\t\t\t   __be16 proto,\n\t\t\t\t\t   const struct nlattr *src_entry,\n\t\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *tb[MDBE_SRCATTR_MAX + 1];\n\tstruct vxlan_mdb_config_src_entry *src;\n\tint err;\n\n\terr = nla_parse_nested(tb, MDBE_SRCATTR_MAX, src_entry,\n\t\t\t       vxlan_mdbe_src_list_entry_pol, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (NL_REQ_ATTR_CHECK(extack, src_entry, tb, MDBE_SRCATTR_ADDRESS))\n\t\treturn -EINVAL;\n\n\tif (!vxlan_mdb_is_valid_source(tb[MDBE_SRCATTR_ADDRESS], proto,\n\t\t\t\t       extack))\n\t\treturn -EINVAL;\n\n\tsrc = kzalloc(sizeof(*src), GFP_KERNEL);\n\tif (!src)\n\t\treturn -ENOMEM;\n\n\terr = vxlan_nla_get_addr(&src->addr, tb[MDBE_SRCATTR_ADDRESS]);\n\tif (err)\n\t\tgoto err_free_src;\n\n\tlist_add_tail(&src->node, &cfg->src_list);\n\n\treturn 0;\n\nerr_free_src:\n\tkfree(src);\n\treturn err;\n}\n\nstatic void\nvxlan_mdb_config_src_entry_fini(struct vxlan_mdb_config_src_entry *src)\n{\n\tlist_del(&src->node);\n\tkfree(src);\n}\n\nstatic int vxlan_mdb_config_src_list_init(struct vxlan_mdb_config *cfg,\n\t\t\t\t\t  __be16 proto,\n\t\t\t\t\t  const struct nlattr *src_list,\n\t\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_mdb_config_src_entry *src, *tmp;\n\tstruct nlattr *src_entry;\n\tint rem, err;\n\n\tnla_for_each_nested(src_entry, src_list, rem) {\n\t\terr = vxlan_mdb_config_src_entry_init(cfg, proto, src_entry,\n\t\t\t\t\t\t      extack);\n\t\tif (err)\n\t\t\tgoto err_src_entry_init;\n\t}\n\n\treturn 0;\n\nerr_src_entry_init:\n\tlist_for_each_entry_safe_reverse(src, tmp, &cfg->src_list, node)\n\t\tvxlan_mdb_config_src_entry_fini(src);\n\treturn err;\n}\n\nstatic void vxlan_mdb_config_src_list_fini(struct vxlan_mdb_config *cfg)\n{\n\tstruct vxlan_mdb_config_src_entry *src, *tmp;\n\n\tlist_for_each_entry_safe_reverse(src, tmp, &cfg->src_list, node)\n\t\tvxlan_mdb_config_src_entry_fini(src);\n}\n\nstatic int vxlan_mdb_config_attrs_init(struct vxlan_mdb_config *cfg,\n\t\t\t\t       const struct br_mdb_entry *entry,\n\t\t\t\t       const struct nlattr *set_attrs,\n\t\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *mdbe_attrs[MDBE_ATTR_MAX + 1];\n\tint err;\n\n\terr = nla_parse_nested(mdbe_attrs, MDBE_ATTR_MAX, set_attrs,\n\t\t\t       vxlan_mdbe_attrs_pol, extack);\n\tif (err)\n\t\treturn err;\n\n\tif (NL_REQ_ATTR_CHECK(extack, set_attrs, mdbe_attrs, MDBE_ATTR_DST)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Missing remote destination IP address\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (mdbe_attrs[MDBE_ATTR_SOURCE] &&\n\t    !vxlan_mdb_is_valid_source(mdbe_attrs[MDBE_ATTR_SOURCE],\n\t\t\t\t       entry->addr.proto, extack))\n\t\treturn -EINVAL;\n\n\tvxlan_mdb_config_group_set(cfg, entry, mdbe_attrs[MDBE_ATTR_SOURCE]);\n\n\t \n\tif (!vxlan_addr_is_multicast(&cfg->group.dst) &&\n\t    !vxlan_addr_any(&cfg->group.dst)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Group address is not multicast\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (vxlan_addr_any(&cfg->group.dst) &&\n\t    mdbe_attrs[MDBE_ATTR_SOURCE]) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Source cannot be specified for the all-zeros entry\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (vxlan_mdb_is_sg(&cfg->group))\n\t\tcfg->filter_mode = MCAST_INCLUDE;\n\n\tif (mdbe_attrs[MDBE_ATTR_GROUP_MODE]) {\n\t\tif (!vxlan_mdb_is_star_g(&cfg->group)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Filter mode can only be set for (*, G) entries\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tcfg->filter_mode = nla_get_u8(mdbe_attrs[MDBE_ATTR_GROUP_MODE]);\n\t}\n\n\tif (mdbe_attrs[MDBE_ATTR_SRC_LIST]) {\n\t\tif (!vxlan_mdb_is_star_g(&cfg->group)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Source list can only be set for (*, G) entries\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!mdbe_attrs[MDBE_ATTR_GROUP_MODE]) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Source list cannot be set without filter mode\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\terr = vxlan_mdb_config_src_list_init(cfg, entry->addr.proto,\n\t\t\t\t\t\t     mdbe_attrs[MDBE_ATTR_SRC_LIST],\n\t\t\t\t\t\t     extack);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (vxlan_mdb_is_star_g(&cfg->group) && list_empty(&cfg->src_list) &&\n\t    cfg->filter_mode == MCAST_INCLUDE) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Cannot add (*, G) INCLUDE with an empty source list\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (mdbe_attrs[MDBE_ATTR_RTPROT])\n\t\tcfg->rt_protocol = nla_get_u8(mdbe_attrs[MDBE_ATTR_RTPROT]);\n\n\terr = vxlan_nla_get_addr(&cfg->remote_ip, mdbe_attrs[MDBE_ATTR_DST]);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid remote destination address\");\n\t\tgoto err_src_list_fini;\n\t}\n\n\tif (mdbe_attrs[MDBE_ATTR_DST_PORT])\n\t\tcfg->remote_port =\n\t\t\tcpu_to_be16(nla_get_u16(mdbe_attrs[MDBE_ATTR_DST_PORT]));\n\n\tif (mdbe_attrs[MDBE_ATTR_VNI])\n\t\tcfg->remote_vni =\n\t\t\tcpu_to_be32(nla_get_u32(mdbe_attrs[MDBE_ATTR_VNI]));\n\n\tif (mdbe_attrs[MDBE_ATTR_IFINDEX]) {\n\t\tcfg->remote_ifindex =\n\t\t\tnla_get_s32(mdbe_attrs[MDBE_ATTR_IFINDEX]);\n\t\tif (!__dev_get_by_index(cfg->vxlan->net, cfg->remote_ifindex)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Outgoing interface not found\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_src_list_fini;\n\t\t}\n\t}\n\n\tif (mdbe_attrs[MDBE_ATTR_SRC_VNI])\n\t\tcfg->group.vni =\n\t\t\tcpu_to_be32(nla_get_u32(mdbe_attrs[MDBE_ATTR_SRC_VNI]));\n\n\treturn 0;\n\nerr_src_list_fini:\n\tvxlan_mdb_config_src_list_fini(cfg);\n\treturn err;\n}\n\nstatic int vxlan_mdb_config_init(struct vxlan_mdb_config *cfg,\n\t\t\t\t struct net_device *dev, struct nlattr *tb[],\n\t\t\t\t u16 nlmsg_flags,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct br_mdb_entry *entry = nla_data(tb[MDBA_SET_ENTRY]);\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\n\tmemset(cfg, 0, sizeof(*cfg));\n\tcfg->vxlan = vxlan;\n\tcfg->group.vni = vxlan->default_dst.remote_vni;\n\tINIT_LIST_HEAD(&cfg->src_list);\n\tcfg->nlflags = nlmsg_flags;\n\tcfg->filter_mode = MCAST_EXCLUDE;\n\tcfg->rt_protocol = RTPROT_STATIC;\n\tcfg->remote_vni = vxlan->default_dst.remote_vni;\n\tcfg->remote_port = vxlan->cfg.dst_port;\n\n\tif (entry->ifindex != dev->ifindex) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Port net device must be the VXLAN net device\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((nlmsg_flags & (NLM_F_CREATE | NLM_F_REPLACE)) &&\n\t    entry->state != MDB_PERMANENT) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"MDB entry must be permanent\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (entry->flags) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Invalid MDB entry flags\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (entry->vid) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"VID must not be specified\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (entry->addr.proto != htons(ETH_P_IP) &&\n\t    entry->addr.proto != htons(ETH_P_IPV6)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Group address must be an IPv4 / IPv6 address\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (NL_REQ_ATTR_CHECK(extack, NULL, tb, MDBA_SET_ENTRY_ATTRS)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Missing MDBA_SET_ENTRY_ATTRS attribute\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn vxlan_mdb_config_attrs_init(cfg, entry, tb[MDBA_SET_ENTRY_ATTRS],\n\t\t\t\t\t   extack);\n}\n\nstatic void vxlan_mdb_config_fini(struct vxlan_mdb_config *cfg)\n{\n\tvxlan_mdb_config_src_list_fini(cfg);\n}\n\nstatic struct vxlan_mdb_entry *\nvxlan_mdb_entry_lookup(struct vxlan_dev *vxlan,\n\t\t       const struct vxlan_mdb_entry_key *group)\n{\n\treturn rhashtable_lookup_fast(&vxlan->mdb_tbl, group,\n\t\t\t\t      vxlan_mdb_rht_params);\n}\n\nstatic struct vxlan_mdb_remote *\nvxlan_mdb_remote_lookup(const struct vxlan_mdb_entry *mdb_entry,\n\t\t\tconst union vxlan_addr *addr)\n{\n\tstruct vxlan_mdb_remote *remote;\n\n\tlist_for_each_entry(remote, &mdb_entry->remotes, list) {\n\t\tstruct vxlan_rdst *rd = rtnl_dereference(remote->rd);\n\n\t\tif (vxlan_addr_equal(addr, &rd->remote_ip))\n\t\t\treturn remote;\n\t}\n\n\treturn NULL;\n}\n\nstatic void vxlan_mdb_rdst_free(struct rcu_head *head)\n{\n\tstruct vxlan_rdst *rd = container_of(head, struct vxlan_rdst, rcu);\n\n\tdst_cache_destroy(&rd->dst_cache);\n\tkfree(rd);\n}\n\nstatic int vxlan_mdb_remote_rdst_init(const struct vxlan_mdb_config *cfg,\n\t\t\t\t      struct vxlan_mdb_remote *remote)\n{\n\tstruct vxlan_rdst *rd;\n\tint err;\n\n\trd = kzalloc(sizeof(*rd), GFP_KERNEL);\n\tif (!rd)\n\t\treturn -ENOMEM;\n\n\terr = dst_cache_init(&rd->dst_cache, GFP_KERNEL);\n\tif (err)\n\t\tgoto err_free_rdst;\n\n\trd->remote_ip = cfg->remote_ip;\n\trd->remote_port = cfg->remote_port;\n\trd->remote_vni = cfg->remote_vni;\n\trd->remote_ifindex = cfg->remote_ifindex;\n\trcu_assign_pointer(remote->rd, rd);\n\n\treturn 0;\n\nerr_free_rdst:\n\tkfree(rd);\n\treturn err;\n}\n\nstatic void vxlan_mdb_remote_rdst_fini(struct vxlan_rdst *rd)\n{\n\tcall_rcu(&rd->rcu, vxlan_mdb_rdst_free);\n}\n\nstatic int vxlan_mdb_remote_init(const struct vxlan_mdb_config *cfg,\n\t\t\t\t struct vxlan_mdb_remote *remote)\n{\n\tint err;\n\n\terr = vxlan_mdb_remote_rdst_init(cfg, remote);\n\tif (err)\n\t\treturn err;\n\n\tremote->flags = cfg->flags;\n\tremote->filter_mode = cfg->filter_mode;\n\tremote->rt_protocol = cfg->rt_protocol;\n\tINIT_HLIST_HEAD(&remote->src_list);\n\n\treturn 0;\n}\n\nstatic void vxlan_mdb_remote_fini(struct vxlan_dev *vxlan,\n\t\t\t\t  struct vxlan_mdb_remote *remote)\n{\n\tWARN_ON_ONCE(!hlist_empty(&remote->src_list));\n\tvxlan_mdb_remote_rdst_fini(rtnl_dereference(remote->rd));\n}\n\nstatic struct vxlan_mdb_src_entry *\nvxlan_mdb_remote_src_entry_lookup(const struct vxlan_mdb_remote *remote,\n\t\t\t\t  const union vxlan_addr *addr)\n{\n\tstruct vxlan_mdb_src_entry *ent;\n\n\thlist_for_each_entry(ent, &remote->src_list, node) {\n\t\tif (vxlan_addr_equal(&ent->addr, addr))\n\t\t\treturn ent;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct vxlan_mdb_src_entry *\nvxlan_mdb_remote_src_entry_add(struct vxlan_mdb_remote *remote,\n\t\t\t       const union vxlan_addr *addr)\n{\n\tstruct vxlan_mdb_src_entry *ent;\n\n\tent = kzalloc(sizeof(*ent), GFP_KERNEL);\n\tif (!ent)\n\t\treturn NULL;\n\n\tent->addr = *addr;\n\thlist_add_head(&ent->node, &remote->src_list);\n\n\treturn ent;\n}\n\nstatic void\nvxlan_mdb_remote_src_entry_del(struct vxlan_mdb_src_entry *ent)\n{\n\thlist_del(&ent->node);\n\tkfree(ent);\n}\n\nstatic int\nvxlan_mdb_remote_src_fwd_add(const struct vxlan_mdb_config *cfg,\n\t\t\t     const union vxlan_addr *addr,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_mdb_config sg_cfg;\n\n\tmemset(&sg_cfg, 0, sizeof(sg_cfg));\n\tsg_cfg.vxlan = cfg->vxlan;\n\tsg_cfg.group.src = *addr;\n\tsg_cfg.group.dst = cfg->group.dst;\n\tsg_cfg.group.vni = cfg->group.vni;\n\tINIT_LIST_HEAD(&sg_cfg.src_list);\n\tsg_cfg.remote_ip = cfg->remote_ip;\n\tsg_cfg.remote_ifindex = cfg->remote_ifindex;\n\tsg_cfg.remote_vni = cfg->remote_vni;\n\tsg_cfg.remote_port = cfg->remote_port;\n\tsg_cfg.nlflags = cfg->nlflags;\n\tsg_cfg.filter_mode = MCAST_INCLUDE;\n\tif (cfg->filter_mode == MCAST_EXCLUDE)\n\t\tsg_cfg.flags = VXLAN_MDB_REMOTE_F_BLOCKED;\n\tsg_cfg.rt_protocol = cfg->rt_protocol;\n\n\treturn __vxlan_mdb_add(&sg_cfg, extack);\n}\n\nstatic void\nvxlan_mdb_remote_src_fwd_del(struct vxlan_dev *vxlan,\n\t\t\t     const struct vxlan_mdb_entry_key *group,\n\t\t\t     const struct vxlan_mdb_remote *remote,\n\t\t\t     const union vxlan_addr *addr)\n{\n\tstruct vxlan_rdst *rd = rtnl_dereference(remote->rd);\n\tstruct vxlan_mdb_config sg_cfg;\n\n\tmemset(&sg_cfg, 0, sizeof(sg_cfg));\n\tsg_cfg.vxlan = vxlan;\n\tsg_cfg.group.src = *addr;\n\tsg_cfg.group.dst = group->dst;\n\tsg_cfg.group.vni = group->vni;\n\tINIT_LIST_HEAD(&sg_cfg.src_list);\n\tsg_cfg.remote_ip = rd->remote_ip;\n\n\t__vxlan_mdb_del(&sg_cfg, NULL);\n}\n\nstatic int\nvxlan_mdb_remote_src_add(const struct vxlan_mdb_config *cfg,\n\t\t\t struct vxlan_mdb_remote *remote,\n\t\t\t const struct vxlan_mdb_config_src_entry *src,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_mdb_src_entry *ent;\n\tint err;\n\n\tent = vxlan_mdb_remote_src_entry_lookup(remote, &src->addr);\n\tif (!ent) {\n\t\tent = vxlan_mdb_remote_src_entry_add(remote, &src->addr);\n\t\tif (!ent)\n\t\t\treturn -ENOMEM;\n\t} else if (!(cfg->nlflags & NLM_F_REPLACE)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Source entry already exists\");\n\t\treturn -EEXIST;\n\t}\n\n\terr = vxlan_mdb_remote_src_fwd_add(cfg, &ent->addr, extack);\n\tif (err)\n\t\tgoto err_src_del;\n\n\t \n\tent->flags = 0;\n\n\treturn 0;\n\nerr_src_del:\n\tvxlan_mdb_remote_src_entry_del(ent);\n\treturn err;\n}\n\nstatic void vxlan_mdb_remote_src_del(struct vxlan_dev *vxlan,\n\t\t\t\t     const struct vxlan_mdb_entry_key *group,\n\t\t\t\t     const struct vxlan_mdb_remote *remote,\n\t\t\t\t     struct vxlan_mdb_src_entry *ent)\n{\n\tvxlan_mdb_remote_src_fwd_del(vxlan, group, remote, &ent->addr);\n\tvxlan_mdb_remote_src_entry_del(ent);\n}\n\nstatic int vxlan_mdb_remote_srcs_add(const struct vxlan_mdb_config *cfg,\n\t\t\t\t     struct vxlan_mdb_remote *remote,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_mdb_config_src_entry *src;\n\tstruct vxlan_mdb_src_entry *ent;\n\tstruct hlist_node *tmp;\n\tint err;\n\n\tlist_for_each_entry(src, &cfg->src_list, node) {\n\t\terr = vxlan_mdb_remote_src_add(cfg, remote, src, extack);\n\t\tif (err)\n\t\t\tgoto err_src_del;\n\t}\n\n\treturn 0;\n\nerr_src_del:\n\thlist_for_each_entry_safe(ent, tmp, &remote->src_list, node)\n\t\tvxlan_mdb_remote_src_del(cfg->vxlan, &cfg->group, remote, ent);\n\treturn err;\n}\n\nstatic void vxlan_mdb_remote_srcs_del(struct vxlan_dev *vxlan,\n\t\t\t\t      const struct vxlan_mdb_entry_key *group,\n\t\t\t\t      struct vxlan_mdb_remote *remote)\n{\n\tstruct vxlan_mdb_src_entry *ent;\n\tstruct hlist_node *tmp;\n\n\thlist_for_each_entry_safe(ent, tmp, &remote->src_list, node)\n\t\tvxlan_mdb_remote_src_del(vxlan, group, remote, ent);\n}\n\nstatic size_t\nvxlan_mdb_nlmsg_src_list_size(const struct vxlan_mdb_entry_key *group,\n\t\t\t      const struct vxlan_mdb_remote *remote)\n{\n\tstruct vxlan_mdb_src_entry *ent;\n\tsize_t nlmsg_size;\n\n\tif (hlist_empty(&remote->src_list))\n\t\treturn 0;\n\n\t \n\tnlmsg_size = nla_total_size(0);\n\n\thlist_for_each_entry(ent, &remote->src_list, node) {\n\t\t\t       \n\t\tnlmsg_size += nla_total_size(0) +\n\t\t\t       \n\t\t\t      nla_total_size(vxlan_addr_size(&group->dst)) +\n\t\t\t       \n\t\t\t      nla_total_size(sizeof(u8));\n\t}\n\n\treturn nlmsg_size;\n}\n\nstatic size_t vxlan_mdb_nlmsg_size(const struct vxlan_dev *vxlan,\n\t\t\t\t   const struct vxlan_mdb_entry *mdb_entry,\n\t\t\t\t   const struct vxlan_mdb_remote *remote)\n{\n\tconst struct vxlan_mdb_entry_key *group = &mdb_entry->key;\n\tstruct vxlan_rdst *rd = rtnl_dereference(remote->rd);\n\tsize_t nlmsg_size;\n\n\tnlmsg_size = NLMSG_ALIGN(sizeof(struct br_port_msg)) +\n\t\t      \n\t\t     nla_total_size(0) +\n\t\t      \n\t\t     nla_total_size(0) +\n\t\t      \n\t\t     nla_total_size(sizeof(struct br_mdb_entry)) +\n\t\t      \n\t\t     nla_total_size(sizeof(u32));\n\t \n\tif (vxlan_mdb_is_sg(group))\n\t\tnlmsg_size += nla_total_size(vxlan_addr_size(&group->dst));\n\t \n\tnlmsg_size += nla_total_size(sizeof(u8));\n\t \n\tnlmsg_size += vxlan_mdb_nlmsg_src_list_size(group, remote);\n\t \n\tnlmsg_size += nla_total_size(sizeof(u8));\n\t \n\tnlmsg_size += nla_total_size(vxlan_addr_size(&rd->remote_ip));\n\t \n\tif (rd->remote_port && rd->remote_port != vxlan->cfg.dst_port)\n\t\tnlmsg_size += nla_total_size(sizeof(u16));\n\t \n\tif (rd->remote_vni != vxlan->default_dst.remote_vni)\n\t\tnlmsg_size += nla_total_size(sizeof(u32));\n\t \n\tif (rd->remote_ifindex)\n\t\tnlmsg_size += nla_total_size(sizeof(u32));\n\t \n\tif ((vxlan->cfg.flags & VXLAN_F_COLLECT_METADATA) && group->vni)\n\t\tnlmsg_size += nla_total_size(sizeof(u32));\n\n\treturn nlmsg_size;\n}\n\nstatic int vxlan_mdb_nlmsg_fill(const struct vxlan_dev *vxlan,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tconst struct vxlan_mdb_entry *mdb_entry,\n\t\t\t\tconst struct vxlan_mdb_remote *remote,\n\t\t\t\tint type)\n{\n\tstruct nlattr *mdb_nest, *mdb_entry_nest;\n\tstruct br_port_msg *bpm;\n\tstruct nlmsghdr *nlh;\n\n\tnlh = nlmsg_put(skb, 0, 0, type, sizeof(*bpm), 0);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\n\tbpm = nlmsg_data(nlh);\n\tmemset(bpm, 0, sizeof(*bpm));\n\tbpm->family  = AF_BRIDGE;\n\tbpm->ifindex = vxlan->dev->ifindex;\n\n\tmdb_nest = nla_nest_start_noflag(skb, MDBA_MDB);\n\tif (!mdb_nest)\n\t\tgoto cancel;\n\tmdb_entry_nest = nla_nest_start_noflag(skb, MDBA_MDB_ENTRY);\n\tif (!mdb_entry_nest)\n\t\tgoto cancel;\n\n\tif (vxlan_mdb_entry_info_fill(vxlan, skb, mdb_entry, remote))\n\t\tgoto cancel;\n\n\tnla_nest_end(skb, mdb_entry_nest);\n\tnla_nest_end(skb, mdb_nest);\n\tnlmsg_end(skb, nlh);\n\n\treturn 0;\n\ncancel:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}\n\nstatic void vxlan_mdb_remote_notify(const struct vxlan_dev *vxlan,\n\t\t\t\t    const struct vxlan_mdb_entry *mdb_entry,\n\t\t\t\t    const struct vxlan_mdb_remote *remote,\n\t\t\t\t    int type)\n{\n\tstruct net *net = dev_net(vxlan->dev);\n\tstruct sk_buff *skb;\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(vxlan_mdb_nlmsg_size(vxlan, mdb_entry, remote),\n\t\t\tGFP_KERNEL);\n\tif (!skb)\n\t\tgoto errout;\n\n\terr = vxlan_mdb_nlmsg_fill(vxlan, skb, mdb_entry, remote, type);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\n\trtnl_notify(skb, net, 0, RTNLGRP_MDB, NULL, GFP_KERNEL);\n\treturn;\nerrout:\n\trtnl_set_sk_err(net, RTNLGRP_MDB, err);\n}\n\nstatic int\nvxlan_mdb_remote_srcs_replace(const struct vxlan_mdb_config *cfg,\n\t\t\t      const struct vxlan_mdb_entry *mdb_entry,\n\t\t\t      struct vxlan_mdb_remote *remote,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_dev *vxlan = cfg->vxlan;\n\tstruct vxlan_mdb_src_entry *ent;\n\tstruct hlist_node *tmp;\n\tint err;\n\n\thlist_for_each_entry(ent, &remote->src_list, node)\n\t\tent->flags |= VXLAN_SGRP_F_DELETE;\n\n\terr = vxlan_mdb_remote_srcs_add(cfg, remote, extack);\n\tif (err)\n\t\tgoto err_clear_delete;\n\n\thlist_for_each_entry_safe(ent, tmp, &remote->src_list, node) {\n\t\tif (ent->flags & VXLAN_SGRP_F_DELETE)\n\t\t\tvxlan_mdb_remote_src_del(vxlan, &mdb_entry->key, remote,\n\t\t\t\t\t\t ent);\n\t}\n\n\treturn 0;\n\nerr_clear_delete:\n\thlist_for_each_entry(ent, &remote->src_list, node)\n\t\tent->flags &= ~VXLAN_SGRP_F_DELETE;\n\treturn err;\n}\n\nstatic int vxlan_mdb_remote_replace(const struct vxlan_mdb_config *cfg,\n\t\t\t\t    const struct vxlan_mdb_entry *mdb_entry,\n\t\t\t\t    struct vxlan_mdb_remote *remote,\n\t\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_rdst *new_rd, *old_rd = rtnl_dereference(remote->rd);\n\tstruct vxlan_dev *vxlan = cfg->vxlan;\n\tint err;\n\n\terr = vxlan_mdb_remote_rdst_init(cfg, remote);\n\tif (err)\n\t\treturn err;\n\tnew_rd = rtnl_dereference(remote->rd);\n\n\terr = vxlan_mdb_remote_srcs_replace(cfg, mdb_entry, remote, extack);\n\tif (err)\n\t\tgoto err_rdst_reset;\n\n\tWRITE_ONCE(remote->flags, cfg->flags);\n\tWRITE_ONCE(remote->filter_mode, cfg->filter_mode);\n\tremote->rt_protocol = cfg->rt_protocol;\n\tvxlan_mdb_remote_notify(vxlan, mdb_entry, remote, RTM_NEWMDB);\n\n\tvxlan_mdb_remote_rdst_fini(old_rd);\n\n\treturn 0;\n\nerr_rdst_reset:\n\trcu_assign_pointer(remote->rd, old_rd);\n\tvxlan_mdb_remote_rdst_fini(new_rd);\n\treturn err;\n}\n\nstatic int vxlan_mdb_remote_add(const struct vxlan_mdb_config *cfg,\n\t\t\t\tstruct vxlan_mdb_entry *mdb_entry,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct vxlan_mdb_remote *remote;\n\tint err;\n\n\tremote = vxlan_mdb_remote_lookup(mdb_entry, &cfg->remote_ip);\n\tif (remote) {\n\t\tif (!(cfg->nlflags & NLM_F_REPLACE)) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Replace not specified and MDB remote entry already exists\");\n\t\t\treturn -EEXIST;\n\t\t}\n\t\treturn vxlan_mdb_remote_replace(cfg, mdb_entry, remote, extack);\n\t}\n\n\tif (!(cfg->nlflags & NLM_F_CREATE)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Create not specified and entry does not exist\");\n\t\treturn -ENOENT;\n\t}\n\n\tremote = kzalloc(sizeof(*remote), GFP_KERNEL);\n\tif (!remote)\n\t\treturn -ENOMEM;\n\n\terr = vxlan_mdb_remote_init(cfg, remote);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to initialize remote MDB entry\");\n\t\tgoto err_free_remote;\n\t}\n\n\terr = vxlan_mdb_remote_srcs_add(cfg, remote, extack);\n\tif (err)\n\t\tgoto err_remote_fini;\n\n\tlist_add_rcu(&remote->list, &mdb_entry->remotes);\n\tvxlan_mdb_remote_notify(cfg->vxlan, mdb_entry, remote, RTM_NEWMDB);\n\n\treturn 0;\n\nerr_remote_fini:\n\tvxlan_mdb_remote_fini(cfg->vxlan, remote);\nerr_free_remote:\n\tkfree(remote);\n\treturn err;\n}\n\nstatic void vxlan_mdb_remote_del(struct vxlan_dev *vxlan,\n\t\t\t\t struct vxlan_mdb_entry *mdb_entry,\n\t\t\t\t struct vxlan_mdb_remote *remote)\n{\n\tvxlan_mdb_remote_notify(vxlan, mdb_entry, remote, RTM_DELMDB);\n\tlist_del_rcu(&remote->list);\n\tvxlan_mdb_remote_srcs_del(vxlan, &mdb_entry->key, remote);\n\tvxlan_mdb_remote_fini(vxlan, remote);\n\tkfree_rcu(remote, rcu);\n}\n\nstatic struct vxlan_mdb_entry *\nvxlan_mdb_entry_get(struct vxlan_dev *vxlan,\n\t\t    const struct vxlan_mdb_entry_key *group)\n{\n\tstruct vxlan_mdb_entry *mdb_entry;\n\tint err;\n\n\tmdb_entry = vxlan_mdb_entry_lookup(vxlan, group);\n\tif (mdb_entry)\n\t\treturn mdb_entry;\n\n\tmdb_entry = kzalloc(sizeof(*mdb_entry), GFP_KERNEL);\n\tif (!mdb_entry)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&mdb_entry->remotes);\n\tmemcpy(&mdb_entry->key, group, sizeof(mdb_entry->key));\n\thlist_add_head(&mdb_entry->mdb_node, &vxlan->mdb_list);\n\n\terr = rhashtable_lookup_insert_fast(&vxlan->mdb_tbl,\n\t\t\t\t\t    &mdb_entry->rhnode,\n\t\t\t\t\t    vxlan_mdb_rht_params);\n\tif (err)\n\t\tgoto err_free_entry;\n\n\tif (hlist_is_singular_node(&mdb_entry->mdb_node, &vxlan->mdb_list))\n\t\tvxlan->cfg.flags |= VXLAN_F_MDB;\n\n\treturn mdb_entry;\n\nerr_free_entry:\n\thlist_del(&mdb_entry->mdb_node);\n\tkfree(mdb_entry);\n\treturn ERR_PTR(err);\n}\n\nstatic void vxlan_mdb_entry_put(struct vxlan_dev *vxlan,\n\t\t\t\tstruct vxlan_mdb_entry *mdb_entry)\n{\n\tif (!list_empty(&mdb_entry->remotes))\n\t\treturn;\n\n\tif (hlist_is_singular_node(&mdb_entry->mdb_node, &vxlan->mdb_list))\n\t\tvxlan->cfg.flags &= ~VXLAN_F_MDB;\n\n\trhashtable_remove_fast(&vxlan->mdb_tbl, &mdb_entry->rhnode,\n\t\t\t       vxlan_mdb_rht_params);\n\thlist_del(&mdb_entry->mdb_node);\n\tkfree_rcu(mdb_entry, rcu);\n}\n\nstatic int __vxlan_mdb_add(const struct vxlan_mdb_config *cfg,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_dev *vxlan = cfg->vxlan;\n\tstruct vxlan_mdb_entry *mdb_entry;\n\tint err;\n\n\tmdb_entry = vxlan_mdb_entry_get(vxlan, &cfg->group);\n\tif (IS_ERR(mdb_entry))\n\t\treturn PTR_ERR(mdb_entry);\n\n\terr = vxlan_mdb_remote_add(cfg, mdb_entry, extack);\n\tif (err)\n\t\tgoto err_entry_put;\n\n\tvxlan->mdb_seq++;\n\n\treturn 0;\n\nerr_entry_put:\n\tvxlan_mdb_entry_put(vxlan, mdb_entry);\n\treturn err;\n}\n\nstatic int __vxlan_mdb_del(const struct vxlan_mdb_config *cfg,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_dev *vxlan = cfg->vxlan;\n\tstruct vxlan_mdb_entry *mdb_entry;\n\tstruct vxlan_mdb_remote *remote;\n\n\tmdb_entry = vxlan_mdb_entry_lookup(vxlan, &cfg->group);\n\tif (!mdb_entry) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Did not find MDB entry\");\n\t\treturn -ENOENT;\n\t}\n\n\tremote = vxlan_mdb_remote_lookup(mdb_entry, &cfg->remote_ip);\n\tif (!remote) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Did not find MDB remote entry\");\n\t\treturn -ENOENT;\n\t}\n\n\tvxlan_mdb_remote_del(vxlan, mdb_entry, remote);\n\tvxlan_mdb_entry_put(vxlan, mdb_entry);\n\n\tvxlan->mdb_seq++;\n\n\treturn 0;\n}\n\nint vxlan_mdb_add(struct net_device *dev, struct nlattr *tb[], u16 nlmsg_flags,\n\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_mdb_config cfg;\n\tint err;\n\n\tASSERT_RTNL();\n\n\terr = vxlan_mdb_config_init(&cfg, dev, tb, nlmsg_flags, extack);\n\tif (err)\n\t\treturn err;\n\n\terr = __vxlan_mdb_add(&cfg, extack);\n\n\tvxlan_mdb_config_fini(&cfg);\n\treturn err;\n}\n\nint vxlan_mdb_del(struct net_device *dev, struct nlattr *tb[],\n\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_mdb_config cfg;\n\tint err;\n\n\tASSERT_RTNL();\n\n\terr = vxlan_mdb_config_init(&cfg, dev, tb, 0, extack);\n\tif (err)\n\t\treturn err;\n\n\terr = __vxlan_mdb_del(&cfg, extack);\n\n\tvxlan_mdb_config_fini(&cfg);\n\treturn err;\n}\n\nstruct vxlan_mdb_entry *vxlan_mdb_entry_skb_get(struct vxlan_dev *vxlan,\n\t\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\t\t__be32 src_vni)\n{\n\tstruct vxlan_mdb_entry *mdb_entry;\n\tstruct vxlan_mdb_entry_key group;\n\n\tif (!is_multicast_ether_addr(eth_hdr(skb)->h_dest) ||\n\t    is_broadcast_ether_addr(eth_hdr(skb)->h_dest))\n\t\treturn NULL;\n\n\t \n\tif (!(vxlan->cfg.flags & VXLAN_F_COLLECT_METADATA))\n\t\tsrc_vni = vxlan->default_dst.remote_vni;\n\n\tmemset(&group, 0, sizeof(group));\n\tgroup.vni = src_vni;\n\n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tif (!pskb_may_pull(skb, sizeof(struct iphdr)))\n\t\t\treturn NULL;\n\t\tgroup.dst.sa.sa_family = AF_INET;\n\t\tgroup.dst.sin.sin_addr.s_addr = ip_hdr(skb)->daddr;\n\t\tgroup.src.sa.sa_family = AF_INET;\n\t\tgroup.src.sin.sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\tif (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))\n\t\t\treturn NULL;\n\t\tgroup.dst.sa.sa_family = AF_INET6;\n\t\tgroup.dst.sin6.sin6_addr = ipv6_hdr(skb)->daddr;\n\t\tgroup.src.sa.sa_family = AF_INET6;\n\t\tgroup.src.sin6.sin6_addr = ipv6_hdr(skb)->saddr;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\tmdb_entry = vxlan_mdb_entry_lookup(vxlan, &group);\n\tif (mdb_entry)\n\t\treturn mdb_entry;\n\n\tmemset(&group.src, 0, sizeof(group.src));\n\tmdb_entry = vxlan_mdb_entry_lookup(vxlan, &group);\n\tif (mdb_entry)\n\t\treturn mdb_entry;\n\n\t \n\tswitch (skb->protocol) {\n\tcase htons(ETH_P_IP):\n\t\tif (ipv4_is_local_multicast(group.dst.sin.sin_addr.s_addr))\n\t\t\treturn NULL;\n\t\tgroup.dst.sin.sin_addr.s_addr = 0;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase htons(ETH_P_IPV6):\n\t\tif (ipv6_addr_type(&group.dst.sin6.sin6_addr) &\n\t\t    IPV6_ADDR_LINKLOCAL)\n\t\t\treturn NULL;\n\t\tmemset(&group.dst.sin6.sin6_addr, 0,\n\t\t       sizeof(group.dst.sin6.sin6_addr));\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\treturn vxlan_mdb_entry_lookup(vxlan, &group);\n}\n\nnetdev_tx_t vxlan_mdb_xmit(struct vxlan_dev *vxlan,\n\t\t\t   const struct vxlan_mdb_entry *mdb_entry,\n\t\t\t   struct sk_buff *skb)\n{\n\tstruct vxlan_mdb_remote *remote, *fremote = NULL;\n\t__be32 src_vni = mdb_entry->key.vni;\n\n\tlist_for_each_entry_rcu(remote, &mdb_entry->remotes, list) {\n\t\tstruct sk_buff *skb1;\n\n\t\tif ((vxlan_mdb_is_star_g(&mdb_entry->key) &&\n\t\t     READ_ONCE(remote->filter_mode) == MCAST_INCLUDE) ||\n\t\t    (READ_ONCE(remote->flags) & VXLAN_MDB_REMOTE_F_BLOCKED))\n\t\t\tcontinue;\n\n\t\tif (!fremote) {\n\t\t\tfremote = remote;\n\t\t\tcontinue;\n\t\t}\n\n\t\tskb1 = skb_clone(skb, GFP_ATOMIC);\n\t\tif (skb1)\n\t\t\tvxlan_xmit_one(skb1, vxlan->dev, src_vni,\n\t\t\t\t       rcu_dereference(remote->rd), false);\n\t}\n\n\tif (fremote)\n\t\tvxlan_xmit_one(skb, vxlan->dev, src_vni,\n\t\t\t       rcu_dereference(fremote->rd), false);\n\telse\n\t\tkfree_skb(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void vxlan_mdb_check_empty(void *ptr, void *arg)\n{\n\tWARN_ON_ONCE(1);\n}\n\nstatic void vxlan_mdb_remotes_flush(struct vxlan_dev *vxlan,\n\t\t\t\t    struct vxlan_mdb_entry *mdb_entry)\n{\n\tstruct vxlan_mdb_remote *remote, *tmp;\n\n\tlist_for_each_entry_safe(remote, tmp, &mdb_entry->remotes, list)\n\t\tvxlan_mdb_remote_del(vxlan, mdb_entry, remote);\n}\n\nstatic void vxlan_mdb_entries_flush(struct vxlan_dev *vxlan)\n{\n\tstruct vxlan_mdb_entry *mdb_entry;\n\tstruct hlist_node *tmp;\n\n\t \n\thlist_for_each_entry_safe(mdb_entry, tmp, &vxlan->mdb_list, mdb_node) {\n\t\tvxlan_mdb_remotes_flush(vxlan, mdb_entry);\n\t\tvxlan_mdb_entry_put(vxlan, mdb_entry);\n\t}\n}\n\nint vxlan_mdb_init(struct vxlan_dev *vxlan)\n{\n\tint err;\n\n\terr = rhashtable_init(&vxlan->mdb_tbl, &vxlan_mdb_rht_params);\n\tif (err)\n\t\treturn err;\n\n\tINIT_HLIST_HEAD(&vxlan->mdb_list);\n\n\treturn 0;\n}\n\nvoid vxlan_mdb_fini(struct vxlan_dev *vxlan)\n{\n\tvxlan_mdb_entries_flush(vxlan);\n\tWARN_ON_ONCE(vxlan->cfg.flags & VXLAN_F_MDB);\n\trhashtable_free_and_destroy(&vxlan->mdb_tbl, vxlan_mdb_check_empty,\n\t\t\t\t    NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}