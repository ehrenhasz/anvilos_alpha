{
  "module_name": "vxlan_vnifilter.c",
  "hash_id": "22a906e790860f823cd4ffaa4d7733dc8c814ed993b3fd489bb76973b72a3cf5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/vxlan/vxlan_vnifilter.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/etherdevice.h>\n#include <linux/rhashtable.h>\n#include <net/rtnetlink.h>\n#include <net/net_namespace.h>\n#include <net/sock.h>\n#include <net/vxlan.h>\n\n#include \"vxlan_private.h\"\n\nstatic inline int vxlan_vni_cmp(struct rhashtable_compare_arg *arg,\n\t\t\t\tconst void *ptr)\n{\n\tconst struct vxlan_vni_node *vnode = ptr;\n\t__be32 vni = *(__be32 *)arg->key;\n\n\treturn vnode->vni != vni;\n}\n\nconst struct rhashtable_params vxlan_vni_rht_params = {\n\t.head_offset = offsetof(struct vxlan_vni_node, vnode),\n\t.key_offset = offsetof(struct vxlan_vni_node, vni),\n\t.key_len = sizeof(__be32),\n\t.nelem_hint = 3,\n\t.max_size = VXLAN_N_VID,\n\t.obj_cmpfn = vxlan_vni_cmp,\n\t.automatic_shrinking = true,\n};\n\nstatic void vxlan_vs_add_del_vninode(struct vxlan_dev *vxlan,\n\t\t\t\t     struct vxlan_vni_node *v,\n\t\t\t\t     bool del)\n{\n\tstruct vxlan_net *vn = net_generic(vxlan->net, vxlan_net_id);\n\tstruct vxlan_dev_node *node;\n\tstruct vxlan_sock *vs;\n\n\tspin_lock(&vn->sock_lock);\n\tif (del) {\n\t\tif (!hlist_unhashed(&v->hlist4.hlist))\n\t\t\thlist_del_init_rcu(&v->hlist4.hlist);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (!hlist_unhashed(&v->hlist6.hlist))\n\t\t\thlist_del_init_rcu(&v->hlist6.hlist);\n#endif\n\t\tgoto out;\n\t}\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tvs = rtnl_dereference(vxlan->vn6_sock);\n\tif (vs && v) {\n\t\tnode = &v->hlist6;\n\t\thlist_add_head_rcu(&node->hlist, vni_head(vs, v->vni));\n\t}\n#endif\n\tvs = rtnl_dereference(vxlan->vn4_sock);\n\tif (vs && v) {\n\t\tnode = &v->hlist4;\n\t\thlist_add_head_rcu(&node->hlist, vni_head(vs, v->vni));\n\t}\nout:\n\tspin_unlock(&vn->sock_lock);\n}\n\nvoid vxlan_vs_add_vnigrp(struct vxlan_dev *vxlan,\n\t\t\t struct vxlan_sock *vs,\n\t\t\t bool ipv6)\n{\n\tstruct vxlan_net *vn = net_generic(vxlan->net, vxlan_net_id);\n\tstruct vxlan_vni_group *vg = rtnl_dereference(vxlan->vnigrp);\n\tstruct vxlan_vni_node *v, *tmp;\n\tstruct vxlan_dev_node *node;\n\n\tif (!vg)\n\t\treturn;\n\n\tspin_lock(&vn->sock_lock);\n\tlist_for_each_entry_safe(v, tmp, &vg->vni_list, vlist) {\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (ipv6)\n\t\t\tnode = &v->hlist6;\n\t\telse\n#endif\n\t\t\tnode = &v->hlist4;\n\t\tnode->vxlan = vxlan;\n\t\thlist_add_head_rcu(&node->hlist, vni_head(vs, v->vni));\n\t}\n\tspin_unlock(&vn->sock_lock);\n}\n\nvoid vxlan_vs_del_vnigrp(struct vxlan_dev *vxlan)\n{\n\tstruct vxlan_vni_group *vg = rtnl_dereference(vxlan->vnigrp);\n\tstruct vxlan_net *vn = net_generic(vxlan->net, vxlan_net_id);\n\tstruct vxlan_vni_node *v, *tmp;\n\n\tif (!vg)\n\t\treturn;\n\n\tspin_lock(&vn->sock_lock);\n\tlist_for_each_entry_safe(v, tmp, &vg->vni_list, vlist) {\n\t\thlist_del_init_rcu(&v->hlist4.hlist);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\thlist_del_init_rcu(&v->hlist6.hlist);\n#endif\n\t}\n\tspin_unlock(&vn->sock_lock);\n}\n\nstatic void vxlan_vnifilter_stats_get(const struct vxlan_vni_node *vninode,\n\t\t\t\t      struct vxlan_vni_stats *dest)\n{\n\tint i;\n\n\tmemset(dest, 0, sizeof(*dest));\n\tfor_each_possible_cpu(i) {\n\t\tstruct vxlan_vni_stats_pcpu *pstats;\n\t\tstruct vxlan_vni_stats temp;\n\t\tunsigned int start;\n\n\t\tpstats = per_cpu_ptr(vninode->stats, i);\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin(&pstats->syncp);\n\t\t\tmemcpy(&temp, &pstats->stats, sizeof(temp));\n\t\t} while (u64_stats_fetch_retry(&pstats->syncp, start));\n\n\t\tdest->rx_packets += temp.rx_packets;\n\t\tdest->rx_bytes += temp.rx_bytes;\n\t\tdest->rx_drops += temp.rx_drops;\n\t\tdest->rx_errors += temp.rx_errors;\n\t\tdest->tx_packets += temp.tx_packets;\n\t\tdest->tx_bytes += temp.tx_bytes;\n\t\tdest->tx_drops += temp.tx_drops;\n\t\tdest->tx_errors += temp.tx_errors;\n\t}\n}\n\nstatic void vxlan_vnifilter_stats_add(struct vxlan_vni_node *vninode,\n\t\t\t\t      int type, unsigned int len)\n{\n\tstruct vxlan_vni_stats_pcpu *pstats = this_cpu_ptr(vninode->stats);\n\n\tu64_stats_update_begin(&pstats->syncp);\n\tswitch (type) {\n\tcase VXLAN_VNI_STATS_RX:\n\t\tpstats->stats.rx_bytes += len;\n\t\tpstats->stats.rx_packets++;\n\t\tbreak;\n\tcase VXLAN_VNI_STATS_RX_DROPS:\n\t\tpstats->stats.rx_drops++;\n\t\tbreak;\n\tcase VXLAN_VNI_STATS_RX_ERRORS:\n\t\tpstats->stats.rx_errors++;\n\t\tbreak;\n\tcase VXLAN_VNI_STATS_TX:\n\t\tpstats->stats.tx_bytes += len;\n\t\tpstats->stats.tx_packets++;\n\t\tbreak;\n\tcase VXLAN_VNI_STATS_TX_DROPS:\n\t\tpstats->stats.tx_drops++;\n\t\tbreak;\n\tcase VXLAN_VNI_STATS_TX_ERRORS:\n\t\tpstats->stats.tx_errors++;\n\t\tbreak;\n\t}\n\tu64_stats_update_end(&pstats->syncp);\n}\n\nvoid vxlan_vnifilter_count(struct vxlan_dev *vxlan, __be32 vni,\n\t\t\t   struct vxlan_vni_node *vninode,\n\t\t\t   int type, unsigned int len)\n{\n\tstruct vxlan_vni_node *vnode;\n\n\tif (!(vxlan->cfg.flags & VXLAN_F_VNIFILTER))\n\t\treturn;\n\n\tif (vninode) {\n\t\tvnode = vninode;\n\t} else {\n\t\tvnode = vxlan_vnifilter_lookup(vxlan, vni);\n\t\tif (!vnode)\n\t\t\treturn;\n\t}\n\n\tvxlan_vnifilter_stats_add(vnode, type, len);\n}\n\nstatic u32 vnirange(struct vxlan_vni_node *vbegin,\n\t\t    struct vxlan_vni_node *vend)\n{\n\treturn (be32_to_cpu(vend->vni) - be32_to_cpu(vbegin->vni));\n}\n\nstatic size_t vxlan_vnifilter_entry_nlmsg_size(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct tunnel_msg))\n\t\t+ nla_total_size(0)  \n\t\t+ nla_total_size(sizeof(u32))  \n\t\t+ nla_total_size(sizeof(u32))  \n\t\t+ nla_total_size(sizeof(struct in6_addr)); \n}\n\nstatic int __vnifilter_entry_fill_stats(struct sk_buff *skb,\n\t\t\t\t\tconst struct vxlan_vni_node *vbegin)\n{\n\tstruct vxlan_vni_stats vstats;\n\tstruct nlattr *vstats_attr;\n\n\tvstats_attr = nla_nest_start(skb, VXLAN_VNIFILTER_ENTRY_STATS);\n\tif (!vstats_attr)\n\t\tgoto out_stats_err;\n\n\tvxlan_vnifilter_stats_get(vbegin, &vstats);\n\tif (nla_put_u64_64bit(skb, VNIFILTER_ENTRY_STATS_RX_BYTES,\n\t\t\t      vstats.rx_bytes, VNIFILTER_ENTRY_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, VNIFILTER_ENTRY_STATS_RX_PKTS,\n\t\t\t      vstats.rx_packets, VNIFILTER_ENTRY_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, VNIFILTER_ENTRY_STATS_RX_DROPS,\n\t\t\t      vstats.rx_drops, VNIFILTER_ENTRY_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, VNIFILTER_ENTRY_STATS_RX_ERRORS,\n\t\t\t      vstats.rx_errors, VNIFILTER_ENTRY_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, VNIFILTER_ENTRY_STATS_TX_BYTES,\n\t\t\t      vstats.tx_bytes, VNIFILTER_ENTRY_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, VNIFILTER_ENTRY_STATS_TX_PKTS,\n\t\t\t      vstats.tx_packets, VNIFILTER_ENTRY_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, VNIFILTER_ENTRY_STATS_TX_DROPS,\n\t\t\t      vstats.tx_drops, VNIFILTER_ENTRY_STATS_PAD) ||\n\t    nla_put_u64_64bit(skb, VNIFILTER_ENTRY_STATS_TX_ERRORS,\n\t\t\t      vstats.tx_errors, VNIFILTER_ENTRY_STATS_PAD))\n\t\tgoto out_stats_err;\n\n\tnla_nest_end(skb, vstats_attr);\n\n\treturn 0;\n\nout_stats_err:\n\tnla_nest_cancel(skb, vstats_attr);\n\treturn -EMSGSIZE;\n}\n\nstatic bool vxlan_fill_vni_filter_entry(struct sk_buff *skb,\n\t\t\t\t\tstruct vxlan_vni_node *vbegin,\n\t\t\t\t\tstruct vxlan_vni_node *vend,\n\t\t\t\t\tbool fill_stats)\n{\n\tstruct nlattr *ventry;\n\tu32 vs = be32_to_cpu(vbegin->vni);\n\tu32 ve = 0;\n\n\tif (vbegin != vend)\n\t\tve = be32_to_cpu(vend->vni);\n\n\tventry = nla_nest_start(skb, VXLAN_VNIFILTER_ENTRY);\n\tif (!ventry)\n\t\treturn false;\n\n\tif (nla_put_u32(skb, VXLAN_VNIFILTER_ENTRY_START, vs))\n\t\tgoto out_err;\n\n\tif (ve && nla_put_u32(skb, VXLAN_VNIFILTER_ENTRY_END, ve))\n\t\tgoto out_err;\n\n\tif (!vxlan_addr_any(&vbegin->remote_ip)) {\n\t\tif (vbegin->remote_ip.sa.sa_family == AF_INET) {\n\t\t\tif (nla_put_in_addr(skb, VXLAN_VNIFILTER_ENTRY_GROUP,\n\t\t\t\t\t    vbegin->remote_ip.sin.sin_addr.s_addr))\n\t\t\t\tgoto out_err;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t} else {\n\t\t\tif (nla_put_in6_addr(skb, VXLAN_VNIFILTER_ENTRY_GROUP6,\n\t\t\t\t\t     &vbegin->remote_ip.sin6.sin6_addr))\n\t\t\t\tgoto out_err;\n#endif\n\t\t}\n\t}\n\n\tif (fill_stats && __vnifilter_entry_fill_stats(skb, vbegin))\n\t\tgoto out_err;\n\n\tnla_nest_end(skb, ventry);\n\n\treturn true;\n\nout_err:\n\tnla_nest_cancel(skb, ventry);\n\n\treturn false;\n}\n\nstatic void vxlan_vnifilter_notify(const struct vxlan_dev *vxlan,\n\t\t\t\t   struct vxlan_vni_node *vninode, int cmd)\n{\n\tstruct tunnel_msg *tmsg;\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\tstruct net *net = dev_net(vxlan->dev);\n\tint err = -ENOBUFS;\n\n\tskb = nlmsg_new(vxlan_vnifilter_entry_nlmsg_size(), GFP_KERNEL);\n\tif (!skb)\n\t\tgoto out_err;\n\n\terr = -EMSGSIZE;\n\tnlh = nlmsg_put(skb, 0, 0, cmd, sizeof(*tmsg), 0);\n\tif (!nlh)\n\t\tgoto out_err;\n\ttmsg = nlmsg_data(nlh);\n\tmemset(tmsg, 0, sizeof(*tmsg));\n\ttmsg->family = AF_BRIDGE;\n\ttmsg->ifindex = vxlan->dev->ifindex;\n\n\tif (!vxlan_fill_vni_filter_entry(skb, vninode, vninode, false))\n\t\tgoto out_err;\n\n\tnlmsg_end(skb, nlh);\n\trtnl_notify(skb, net, 0, RTNLGRP_TUNNEL, NULL, GFP_KERNEL);\n\n\treturn;\n\nout_err:\n\trtnl_set_sk_err(net, RTNLGRP_TUNNEL, err);\n\n\tkfree_skb(skb);\n}\n\nstatic int vxlan_vnifilter_dump_dev(const struct net_device *dev,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    struct netlink_callback *cb)\n{\n\tstruct vxlan_vni_node *tmp, *v, *vbegin = NULL, *vend = NULL;\n\tstruct vxlan_dev *vxlan = netdev_priv(dev);\n\tstruct tunnel_msg *new_tmsg, *tmsg;\n\tint idx = 0, s_idx = cb->args[1];\n\tstruct vxlan_vni_group *vg;\n\tstruct nlmsghdr *nlh;\n\tbool dump_stats;\n\tint err = 0;\n\n\tif (!(vxlan->cfg.flags & VXLAN_F_VNIFILTER))\n\t\treturn -EINVAL;\n\n\t \n\tvg = rcu_dereference(vxlan->vnigrp);\n\tif (!vg || !vg->num_vnis)\n\t\treturn 0;\n\n\ttmsg = nlmsg_data(cb->nlh);\n\tdump_stats = !!(tmsg->flags & TUNNEL_MSG_FLAG_STATS);\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\n\t\t\tRTM_NEWTUNNEL, sizeof(*new_tmsg), NLM_F_MULTI);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\tnew_tmsg = nlmsg_data(nlh);\n\tmemset(new_tmsg, 0, sizeof(*new_tmsg));\n\tnew_tmsg->family = PF_BRIDGE;\n\tnew_tmsg->ifindex = dev->ifindex;\n\n\tlist_for_each_entry_safe(v, tmp, &vg->vni_list, vlist) {\n\t\tif (idx < s_idx) {\n\t\t\tidx++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!vbegin) {\n\t\t\tvbegin = v;\n\t\t\tvend = v;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!dump_stats && vnirange(vend, v) == 1 &&\n\t\t    vxlan_addr_equal(&v->remote_ip, &vend->remote_ip)) {\n\t\t\tgoto update_end;\n\t\t} else {\n\t\t\tif (!vxlan_fill_vni_filter_entry(skb, vbegin, vend,\n\t\t\t\t\t\t\t dump_stats)) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tidx += vnirange(vbegin, vend) + 1;\n\t\t\tvbegin = v;\n\t\t}\nupdate_end:\n\t\tvend = v;\n\t}\n\n\tif (!err && vbegin) {\n\t\tif (!vxlan_fill_vni_filter_entry(skb, vbegin, vend, dump_stats))\n\t\t\terr = -EMSGSIZE;\n\t}\n\n\tcb->args[1] = err ? idx : 0;\n\n\tnlmsg_end(skb, nlh);\n\n\treturn err;\n}\n\nstatic int vxlan_vnifilter_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint idx = 0, err = 0, s_idx = cb->args[0];\n\tstruct net *net = sock_net(skb->sk);\n\tstruct tunnel_msg *tmsg;\n\tstruct net_device *dev;\n\n\ttmsg = nlmsg_data(cb->nlh);\n\n\tif (tmsg->flags & ~TUNNEL_MSG_VALID_USER_FLAGS) {\n\t\tNL_SET_ERR_MSG(cb->extack, \"Invalid tunnelmsg flags in ancillary header\");\n\t\treturn -EINVAL;\n\t}\n\n\trcu_read_lock();\n\tif (tmsg->ifindex) {\n\t\tdev = dev_get_by_index_rcu(net, tmsg->ifindex);\n\t\tif (!dev) {\n\t\t\terr = -ENODEV;\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (!netif_is_vxlan(dev)) {\n\t\t\tNL_SET_ERR_MSG(cb->extack,\n\t\t\t\t       \"The device is not a vxlan device\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto out_err;\n\t\t}\n\t\terr = vxlan_vnifilter_dump_dev(dev, skb, cb);\n\t\t \n\t\tif (err != -EMSGSIZE)\n\t\t\tgoto out_err;\n\t} else {\n\t\tfor_each_netdev_rcu(net, dev) {\n\t\t\tif (!netif_is_vxlan(dev))\n\t\t\t\tcontinue;\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto skip;\n\t\t\terr = vxlan_vnifilter_dump_dev(dev, skb, cb);\n\t\t\tif (err == -EMSGSIZE)\n\t\t\t\tbreak;\nskip:\n\t\t\tidx++;\n\t\t}\n\t}\n\tcb->args[0] = idx;\n\trcu_read_unlock();\n\n\treturn skb->len;\n\nout_err:\n\trcu_read_unlock();\n\n\treturn err;\n}\n\nstatic const struct nla_policy vni_filter_entry_policy[VXLAN_VNIFILTER_ENTRY_MAX + 1] = {\n\t[VXLAN_VNIFILTER_ENTRY_START] = { .type = NLA_U32 },\n\t[VXLAN_VNIFILTER_ENTRY_END] = { .type = NLA_U32 },\n\t[VXLAN_VNIFILTER_ENTRY_GROUP]\t= { .type = NLA_BINARY,\n\t\t\t\t\t    .len = sizeof_field(struct iphdr, daddr) },\n\t[VXLAN_VNIFILTER_ENTRY_GROUP6]\t= { .type = NLA_BINARY,\n\t\t\t\t\t    .len = sizeof(struct in6_addr) },\n};\n\nstatic const struct nla_policy vni_filter_policy[VXLAN_VNIFILTER_MAX + 1] = {\n\t[VXLAN_VNIFILTER_ENTRY] = { .type = NLA_NESTED },\n};\n\nstatic int vxlan_update_default_fdb_entry(struct vxlan_dev *vxlan, __be32 vni,\n\t\t\t\t\t  union vxlan_addr *old_remote_ip,\n\t\t\t\t\t  union vxlan_addr *remote_ip,\n\t\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_rdst *dst = &vxlan->default_dst;\n\tu32 hash_index;\n\tint err = 0;\n\n\thash_index = fdb_head_index(vxlan, all_zeros_mac, vni);\n\tspin_lock_bh(&vxlan->hash_lock[hash_index]);\n\tif (remote_ip && !vxlan_addr_any(remote_ip)) {\n\t\terr = vxlan_fdb_update(vxlan, all_zeros_mac,\n\t\t\t\t       remote_ip,\n\t\t\t\t       NUD_REACHABLE | NUD_PERMANENT,\n\t\t\t\t       NLM_F_APPEND | NLM_F_CREATE,\n\t\t\t\t       vxlan->cfg.dst_port,\n\t\t\t\t       vni,\n\t\t\t\t       vni,\n\t\t\t\t       dst->remote_ifindex,\n\t\t\t\t       NTF_SELF, 0, true, extack);\n\t\tif (err) {\n\t\t\tspin_unlock_bh(&vxlan->hash_lock[hash_index]);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (old_remote_ip && !vxlan_addr_any(old_remote_ip)) {\n\t\t__vxlan_fdb_delete(vxlan, all_zeros_mac,\n\t\t\t\t   *old_remote_ip,\n\t\t\t\t   vxlan->cfg.dst_port,\n\t\t\t\t   vni, vni,\n\t\t\t\t   dst->remote_ifindex,\n\t\t\t\t   true);\n\t}\n\tspin_unlock_bh(&vxlan->hash_lock[hash_index]);\n\n\treturn err;\n}\n\nstatic int vxlan_vni_update_group(struct vxlan_dev *vxlan,\n\t\t\t\t  struct vxlan_vni_node *vninode,\n\t\t\t\t  union vxlan_addr *group,\n\t\t\t\t  bool create, bool *changed,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_net *vn = net_generic(vxlan->net, vxlan_net_id);\n\tstruct vxlan_rdst *dst = &vxlan->default_dst;\n\tunion vxlan_addr *newrip = NULL, *oldrip = NULL;\n\tunion vxlan_addr old_remote_ip;\n\tint ret = 0;\n\n\tmemcpy(&old_remote_ip, &vninode->remote_ip, sizeof(old_remote_ip));\n\n\t \n\tif (group && !vxlan_addr_any(group)) {\n\t\tnewrip = group;\n\t} else {\n\t\tif (!vxlan_addr_any(&dst->remote_ip))\n\t\t\tnewrip = &dst->remote_ip;\n\t}\n\n\t \n\tif (!newrip && !vxlan_addr_any(&old_remote_ip))\n\t\toldrip = &old_remote_ip;\n\n\tif (!newrip && !oldrip)\n\t\treturn 0;\n\n\tif (!create && oldrip && newrip && vxlan_addr_equal(oldrip, newrip))\n\t\treturn 0;\n\n\tret = vxlan_update_default_fdb_entry(vxlan, vninode->vni,\n\t\t\t\t\t     oldrip, newrip,\n\t\t\t\t\t     extack);\n\tif (ret)\n\t\tgoto out;\n\n\tif (group)\n\t\tmemcpy(&vninode->remote_ip, group, sizeof(vninode->remote_ip));\n\n\tif (vxlan->dev->flags & IFF_UP) {\n\t\tif (vxlan_addr_multicast(&old_remote_ip) &&\n\t\t    !vxlan_group_used(vn, vxlan, vninode->vni,\n\t\t\t\t      &old_remote_ip,\n\t\t\t\t      vxlan->default_dst.remote_ifindex)) {\n\t\t\tret = vxlan_igmp_leave(vxlan, &old_remote_ip,\n\t\t\t\t\t       0);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (vxlan_addr_multicast(&vninode->remote_ip)) {\n\t\t\tret = vxlan_igmp_join(vxlan, &vninode->remote_ip, 0);\n\t\t\tif (ret == -EADDRINUSE)\n\t\t\t\tret = 0;\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*changed = true;\n\n\treturn 0;\nout:\n\treturn ret;\n}\n\nint vxlan_vnilist_update_group(struct vxlan_dev *vxlan,\n\t\t\t       union vxlan_addr *old_remote_ip,\n\t\t\t       union vxlan_addr *new_remote_ip,\n\t\t\t       struct netlink_ext_ack *extack)\n{\n\tstruct list_head *headp, *hpos;\n\tstruct vxlan_vni_group *vg;\n\tstruct vxlan_vni_node *vent;\n\tint ret;\n\n\tvg = rtnl_dereference(vxlan->vnigrp);\n\n\theadp = &vg->vni_list;\n\tlist_for_each_prev(hpos, headp) {\n\t\tvent = list_entry(hpos, struct vxlan_vni_node, vlist);\n\t\tif (vxlan_addr_any(&vent->remote_ip)) {\n\t\t\tret = vxlan_update_default_fdb_entry(vxlan, vent->vni,\n\t\t\t\t\t\t\t     old_remote_ip,\n\t\t\t\t\t\t\t     new_remote_ip,\n\t\t\t\t\t\t\t     extack);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void vxlan_vni_delete_group(struct vxlan_dev *vxlan,\n\t\t\t\t   struct vxlan_vni_node *vninode)\n{\n\tstruct vxlan_net *vn = net_generic(vxlan->net, vxlan_net_id);\n\tstruct vxlan_rdst *dst = &vxlan->default_dst;\n\n\t \n\tif (!vxlan_addr_any(&vninode->remote_ip) ||\n\t    !vxlan_addr_any(&dst->remote_ip))\n\t\t__vxlan_fdb_delete(vxlan, all_zeros_mac,\n\t\t\t\t   (vxlan_addr_any(&vninode->remote_ip) ?\n\t\t\t\t   dst->remote_ip : vninode->remote_ip),\n\t\t\t\t   vxlan->cfg.dst_port,\n\t\t\t\t   vninode->vni, vninode->vni,\n\t\t\t\t   dst->remote_ifindex,\n\t\t\t\t   true);\n\n\tif (vxlan->dev->flags & IFF_UP) {\n\t\tif (vxlan_addr_multicast(&vninode->remote_ip) &&\n\t\t    !vxlan_group_used(vn, vxlan, vninode->vni,\n\t\t\t\t      &vninode->remote_ip,\n\t\t\t\t      dst->remote_ifindex)) {\n\t\t\tvxlan_igmp_leave(vxlan, &vninode->remote_ip, 0);\n\t\t}\n\t}\n}\n\nstatic int vxlan_vni_update(struct vxlan_dev *vxlan,\n\t\t\t    struct vxlan_vni_group *vg,\n\t\t\t    __be32 vni, union vxlan_addr *group,\n\t\t\t    bool *changed,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_vni_node *vninode;\n\tint ret;\n\n\tvninode = rhashtable_lookup_fast(&vg->vni_hash, &vni,\n\t\t\t\t\t vxlan_vni_rht_params);\n\tif (!vninode)\n\t\treturn 0;\n\n\tret = vxlan_vni_update_group(vxlan, vninode, group, false, changed,\n\t\t\t\t     extack);\n\tif (ret)\n\t\treturn ret;\n\n\tif (changed)\n\t\tvxlan_vnifilter_notify(vxlan, vninode, RTM_NEWTUNNEL);\n\n\treturn 0;\n}\n\nstatic void __vxlan_vni_add_list(struct vxlan_vni_group *vg,\n\t\t\t\t struct vxlan_vni_node *v)\n{\n\tstruct list_head *headp, *hpos;\n\tstruct vxlan_vni_node *vent;\n\n\theadp = &vg->vni_list;\n\tlist_for_each_prev(hpos, headp) {\n\t\tvent = list_entry(hpos, struct vxlan_vni_node, vlist);\n\t\tif (be32_to_cpu(v->vni) < be32_to_cpu(vent->vni))\n\t\t\tcontinue;\n\t\telse\n\t\t\tbreak;\n\t}\n\tlist_add_rcu(&v->vlist, hpos);\n\tvg->num_vnis++;\n}\n\nstatic void __vxlan_vni_del_list(struct vxlan_vni_group *vg,\n\t\t\t\t struct vxlan_vni_node *v)\n{\n\tlist_del_rcu(&v->vlist);\n\tvg->num_vnis--;\n}\n\nstatic struct vxlan_vni_node *vxlan_vni_alloc(struct vxlan_dev *vxlan,\n\t\t\t\t\t      __be32 vni)\n{\n\tstruct vxlan_vni_node *vninode;\n\n\tvninode = kzalloc(sizeof(*vninode), GFP_KERNEL);\n\tif (!vninode)\n\t\treturn NULL;\n\tvninode->stats = netdev_alloc_pcpu_stats(struct vxlan_vni_stats_pcpu);\n\tif (!vninode->stats) {\n\t\tkfree(vninode);\n\t\treturn NULL;\n\t}\n\tvninode->vni = vni;\n\tvninode->hlist4.vxlan = vxlan;\n#if IS_ENABLED(CONFIG_IPV6)\n\tvninode->hlist6.vxlan = vxlan;\n#endif\n\n\treturn vninode;\n}\n\nstatic void vxlan_vni_free(struct vxlan_vni_node *vninode)\n{\n\tfree_percpu(vninode->stats);\n\tkfree(vninode);\n}\n\nstatic int vxlan_vni_add(struct vxlan_dev *vxlan,\n\t\t\t struct vxlan_vni_group *vg,\n\t\t\t u32 vni, union vxlan_addr *group,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_vni_node *vninode;\n\t__be32 v = cpu_to_be32(vni);\n\tbool changed = false;\n\tint err = 0;\n\n\tif (vxlan_vnifilter_lookup(vxlan, v))\n\t\treturn vxlan_vni_update(vxlan, vg, v, group, &changed, extack);\n\n\terr = vxlan_vni_in_use(vxlan->net, vxlan, &vxlan->cfg, v);\n\tif (err) {\n\t\tNL_SET_ERR_MSG(extack, \"VNI in use\");\n\t\treturn err;\n\t}\n\n\tvninode = vxlan_vni_alloc(vxlan, v);\n\tif (!vninode)\n\t\treturn -ENOMEM;\n\n\terr = rhashtable_lookup_insert_fast(&vg->vni_hash,\n\t\t\t\t\t    &vninode->vnode,\n\t\t\t\t\t    vxlan_vni_rht_params);\n\tif (err) {\n\t\tvxlan_vni_free(vninode);\n\t\treturn err;\n\t}\n\n\t__vxlan_vni_add_list(vg, vninode);\n\n\tif (vxlan->dev->flags & IFF_UP)\n\t\tvxlan_vs_add_del_vninode(vxlan, vninode, false);\n\n\terr = vxlan_vni_update_group(vxlan, vninode, group, true, &changed,\n\t\t\t\t     extack);\n\n\tif (changed)\n\t\tvxlan_vnifilter_notify(vxlan, vninode, RTM_NEWTUNNEL);\n\n\treturn err;\n}\n\nstatic void vxlan_vni_node_rcu_free(struct rcu_head *rcu)\n{\n\tstruct vxlan_vni_node *v;\n\n\tv = container_of(rcu, struct vxlan_vni_node, rcu);\n\tvxlan_vni_free(v);\n}\n\nstatic int vxlan_vni_del(struct vxlan_dev *vxlan,\n\t\t\t struct vxlan_vni_group *vg,\n\t\t\t u32 vni, struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_vni_node *vninode;\n\t__be32 v = cpu_to_be32(vni);\n\tint err = 0;\n\n\tvg = rtnl_dereference(vxlan->vnigrp);\n\n\tvninode = rhashtable_lookup_fast(&vg->vni_hash, &v,\n\t\t\t\t\t vxlan_vni_rht_params);\n\tif (!vninode) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tvxlan_vni_delete_group(vxlan, vninode);\n\n\terr = rhashtable_remove_fast(&vg->vni_hash,\n\t\t\t\t     &vninode->vnode,\n\t\t\t\t     vxlan_vni_rht_params);\n\tif (err)\n\t\tgoto out;\n\n\t__vxlan_vni_del_list(vg, vninode);\n\n\tvxlan_vnifilter_notify(vxlan, vninode, RTM_DELTUNNEL);\n\n\tif (vxlan->dev->flags & IFF_UP)\n\t\tvxlan_vs_add_del_vninode(vxlan, vninode, true);\n\n\tcall_rcu(&vninode->rcu, vxlan_vni_node_rcu_free);\n\n\treturn 0;\nout:\n\treturn err;\n}\n\nstatic int vxlan_vni_add_del(struct vxlan_dev *vxlan, __u32 start_vni,\n\t\t\t     __u32 end_vni, union vxlan_addr *group,\n\t\t\t     int cmd, struct netlink_ext_ack *extack)\n{\n\tstruct vxlan_vni_group *vg;\n\tint v, err = 0;\n\n\tvg = rtnl_dereference(vxlan->vnigrp);\n\n\tfor (v = start_vni; v <= end_vni; v++) {\n\t\tswitch (cmd) {\n\t\tcase RTM_NEWTUNNEL:\n\t\t\terr = vxlan_vni_add(vxlan, vg, v, group, extack);\n\t\t\tbreak;\n\t\tcase RTM_DELTUNNEL:\n\t\t\terr = vxlan_vni_del(vxlan, vg, v, extack);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\treturn 0;\nout:\n\treturn err;\n}\n\nstatic int vxlan_process_vni_filter(struct vxlan_dev *vxlan,\n\t\t\t\t    struct nlattr *nlvnifilter,\n\t\t\t\t    int cmd, struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *vattrs[VXLAN_VNIFILTER_ENTRY_MAX + 1];\n\tu32 vni_start = 0, vni_end = 0;\n\tunion vxlan_addr group;\n\tint err;\n\n\terr = nla_parse_nested(vattrs,\n\t\t\t       VXLAN_VNIFILTER_ENTRY_MAX,\n\t\t\t       nlvnifilter, vni_filter_entry_policy,\n\t\t\t       extack);\n\tif (err)\n\t\treturn err;\n\n\tif (vattrs[VXLAN_VNIFILTER_ENTRY_START]) {\n\t\tvni_start = nla_get_u32(vattrs[VXLAN_VNIFILTER_ENTRY_START]);\n\t\tvni_end = vni_start;\n\t}\n\n\tif (vattrs[VXLAN_VNIFILTER_ENTRY_END])\n\t\tvni_end = nla_get_u32(vattrs[VXLAN_VNIFILTER_ENTRY_END]);\n\n\tif (!vni_start && !vni_end) {\n\t\tNL_SET_ERR_MSG_ATTR(extack, nlvnifilter,\n\t\t\t\t    \"vni start nor end found in vni entry\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (vattrs[VXLAN_VNIFILTER_ENTRY_GROUP]) {\n\t\tgroup.sin.sin_addr.s_addr =\n\t\t\tnla_get_in_addr(vattrs[VXLAN_VNIFILTER_ENTRY_GROUP]);\n\t\tgroup.sa.sa_family = AF_INET;\n\t} else if (vattrs[VXLAN_VNIFILTER_ENTRY_GROUP6]) {\n\t\tgroup.sin6.sin6_addr =\n\t\t\tnla_get_in6_addr(vattrs[VXLAN_VNIFILTER_ENTRY_GROUP6]);\n\t\tgroup.sa.sa_family = AF_INET6;\n\t} else {\n\t\tmemset(&group, 0, sizeof(group));\n\t}\n\n\tif (vxlan_addr_multicast(&group) && !vxlan->default_dst.remote_ifindex) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Local interface required for multicast remote group\");\n\n\t\treturn -EINVAL;\n\t}\n\n\terr = vxlan_vni_add_del(vxlan, vni_start, vni_end, &group, cmd,\n\t\t\t\textack);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nvoid vxlan_vnigroup_uninit(struct vxlan_dev *vxlan)\n{\n\tstruct vxlan_vni_node *v, *tmp;\n\tstruct vxlan_vni_group *vg;\n\n\tvg = rtnl_dereference(vxlan->vnigrp);\n\tlist_for_each_entry_safe(v, tmp, &vg->vni_list, vlist) {\n\t\trhashtable_remove_fast(&vg->vni_hash, &v->vnode,\n\t\t\t\t       vxlan_vni_rht_params);\n\t\thlist_del_init_rcu(&v->hlist4.hlist);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\thlist_del_init_rcu(&v->hlist6.hlist);\n#endif\n\t\t__vxlan_vni_del_list(vg, v);\n\t\tvxlan_vnifilter_notify(vxlan, v, RTM_DELTUNNEL);\n\t\tcall_rcu(&v->rcu, vxlan_vni_node_rcu_free);\n\t}\n\trhashtable_destroy(&vg->vni_hash);\n\tkfree(vg);\n}\n\nint vxlan_vnigroup_init(struct vxlan_dev *vxlan)\n{\n\tstruct vxlan_vni_group *vg;\n\tint ret;\n\n\tvg = kzalloc(sizeof(*vg), GFP_KERNEL);\n\tif (!vg)\n\t\treturn -ENOMEM;\n\tret = rhashtable_init(&vg->vni_hash, &vxlan_vni_rht_params);\n\tif (ret) {\n\t\tkfree(vg);\n\t\treturn ret;\n\t}\n\tINIT_LIST_HEAD(&vg->vni_list);\n\trcu_assign_pointer(vxlan->vnigrp, vg);\n\n\treturn 0;\n}\n\nstatic int vxlan_vnifilter_process(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct tunnel_msg *tmsg;\n\tstruct vxlan_dev *vxlan;\n\tstruct net_device *dev;\n\tstruct nlattr *attr;\n\tint err, vnis = 0;\n\tint rem;\n\n\t \n\terr = nlmsg_parse(nlh, sizeof(*tmsg), NULL, VXLAN_VNIFILTER_MAX,\n\t\t\t  vni_filter_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\n\ttmsg = nlmsg_data(nlh);\n\tdev = __dev_get_by_index(net, tmsg->ifindex);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tif (!netif_is_vxlan(dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"The device is not a vxlan device\");\n\t\treturn -EINVAL;\n\t}\n\n\tvxlan = netdev_priv(dev);\n\n\tif (!(vxlan->cfg.flags & VXLAN_F_VNIFILTER))\n\t\treturn -EOPNOTSUPP;\n\n\tnlmsg_for_each_attr(attr, nlh, sizeof(*tmsg), rem) {\n\t\tswitch (nla_type(attr)) {\n\t\tcase VXLAN_VNIFILTER_ENTRY:\n\t\t\terr = vxlan_process_vni_filter(vxlan, attr,\n\t\t\t\t\t\t       nlh->nlmsg_type, extack);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tvnis++;\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\n\tif (!vnis) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"No vnis found to process\");\n\t\terr = -EINVAL;\n\t}\n\n\treturn err;\n}\n\nvoid vxlan_vnifilter_init(void)\n{\n\trtnl_register_module(THIS_MODULE, PF_BRIDGE, RTM_GETTUNNEL, NULL,\n\t\t\t     vxlan_vnifilter_dump, 0);\n\trtnl_register_module(THIS_MODULE, PF_BRIDGE, RTM_NEWTUNNEL,\n\t\t\t     vxlan_vnifilter_process, NULL, 0);\n\trtnl_register_module(THIS_MODULE, PF_BRIDGE, RTM_DELTUNNEL,\n\t\t\t     vxlan_vnifilter_process, NULL, 0);\n}\n\nvoid vxlan_vnifilter_uninit(void)\n{\n\trtnl_unregister(PF_BRIDGE, RTM_GETTUNNEL);\n\trtnl_unregister(PF_BRIDGE, RTM_NEWTUNNEL);\n\trtnl_unregister(PF_BRIDGE, RTM_DELTUNNEL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}