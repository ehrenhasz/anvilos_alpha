{
  "module_name": "dummy.c",
  "hash_id": "a284c26fe85368757588bedafb74082d82a7aeef534b89966ba7f7c879ff030c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/dummy.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/init.h>\n#include <linux/moduleparam.h>\n#include <linux/rtnetlink.h>\n#include <linux/net_tstamp.h>\n#include <net/rtnetlink.h>\n#include <linux/u64_stats_sync.h>\n\n#define DRV_NAME\t\"dummy\"\n\nstatic int numdummies = 1;\n\n \nstatic void set_multicast_list(struct net_device *dev)\n{\n}\n\nstatic void dummy_get_stats64(struct net_device *dev,\n\t\t\t      struct rtnl_link_stats64 *stats)\n{\n\tdev_lstats_read(dev, &stats->tx_packets, &stats->tx_bytes);\n}\n\nstatic netdev_tx_t dummy_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tdev_lstats_add(dev, skb->len);\n\n\tskb_tx_timestamp(skb);\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic int dummy_dev_init(struct net_device *dev)\n{\n\tdev->lstats = netdev_alloc_pcpu_stats(struct pcpu_lstats);\n\tif (!dev->lstats)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void dummy_dev_uninit(struct net_device *dev)\n{\n\tfree_percpu(dev->lstats);\n}\n\nstatic int dummy_change_carrier(struct net_device *dev, bool new_carrier)\n{\n\tif (new_carrier)\n\t\tnetif_carrier_on(dev);\n\telse\n\t\tnetif_carrier_off(dev);\n\treturn 0;\n}\n\nstatic const struct net_device_ops dummy_netdev_ops = {\n\t.ndo_init\t\t= dummy_dev_init,\n\t.ndo_uninit\t\t= dummy_dev_uninit,\n\t.ndo_start_xmit\t\t= dummy_xmit,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_rx_mode\t= set_multicast_list,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_get_stats64\t= dummy_get_stats64,\n\t.ndo_change_carrier\t= dummy_change_carrier,\n};\n\nstatic const struct ethtool_ops dummy_ethtool_ops = {\n\t.get_ts_info\t\t= ethtool_op_get_ts_info,\n};\n\nstatic void dummy_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\n\t \n\tdev->netdev_ops = &dummy_netdev_ops;\n\tdev->ethtool_ops = &dummy_ethtool_ops;\n\tdev->needs_free_netdev = true;\n\n\t \n\tdev->flags |= IFF_NOARP;\n\tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags |= IFF_LIVE_ADDR_CHANGE | IFF_NO_QUEUE;\n\tdev->features\t|= NETIF_F_SG | NETIF_F_FRAGLIST;\n\tdev->features\t|= NETIF_F_GSO_SOFTWARE;\n\tdev->features\t|= NETIF_F_HW_CSUM | NETIF_F_HIGHDMA | NETIF_F_LLTX;\n\tdev->features\t|= NETIF_F_GSO_ENCAP_ALL;\n\tdev->hw_features |= dev->features;\n\tdev->hw_enc_features |= dev->features;\n\teth_hw_addr_random(dev);\n\n\tdev->min_mtu = 0;\n\tdev->max_mtu = 0;\n}\n\nstatic int dummy_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tif (tb[IFLA_ADDRESS]) {\n\t\tif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\n\t\t\treturn -EINVAL;\n\t\tif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\treturn 0;\n}\n\nstatic struct rtnl_link_ops dummy_link_ops __read_mostly = {\n\t.kind\t\t= DRV_NAME,\n\t.setup\t\t= dummy_setup,\n\t.validate\t= dummy_validate,\n};\n\n \nmodule_param(numdummies, int, 0);\nMODULE_PARM_DESC(numdummies, \"Number of dummy pseudo devices\");\n\nstatic int __init dummy_init_one(void)\n{\n\tstruct net_device *dev_dummy;\n\tint err;\n\n\tdev_dummy = alloc_netdev(0, \"dummy%d\", NET_NAME_ENUM, dummy_setup);\n\tif (!dev_dummy)\n\t\treturn -ENOMEM;\n\n\tdev_dummy->rtnl_link_ops = &dummy_link_ops;\n\terr = register_netdevice(dev_dummy);\n\tif (err < 0)\n\t\tgoto err;\n\treturn 0;\n\nerr:\n\tfree_netdev(dev_dummy);\n\treturn err;\n}\n\nstatic int __init dummy_init_module(void)\n{\n\tint i, err = 0;\n\n\tdown_write(&pernet_ops_rwsem);\n\trtnl_lock();\n\terr = __rtnl_link_register(&dummy_link_ops);\n\tif (err < 0)\n\t\tgoto out;\n\n\tfor (i = 0; i < numdummies && !err; i++) {\n\t\terr = dummy_init_one();\n\t\tcond_resched();\n\t}\n\tif (err < 0)\n\t\t__rtnl_link_unregister(&dummy_link_ops);\n\nout:\n\trtnl_unlock();\n\tup_write(&pernet_ops_rwsem);\n\n\treturn err;\n}\n\nstatic void __exit dummy_cleanup_module(void)\n{\n\trtnl_link_unregister(&dummy_link_ops);\n}\n\nmodule_init(dummy_init_module);\nmodule_exit(dummy_cleanup_module);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_RTNL_LINK(DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}