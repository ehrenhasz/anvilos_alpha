{
  "module_name": "sb1000.c",
  "hash_id": "0c8f84e60364d78f0e6f7228870cecf5448c0c05c0e7e25b361a0fd192ebdbbc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/sb1000.c",
  "human_readable_source": "\n \n \n\nstatic char version[] = \"sb1000.c:v1.1.2 6/01/98 (fventuri@mediaone.net)\\n\";\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/interrupt.h>\n#include <linux/errno.h>\n#include <linux/if_cablemodem.h>  \n#include <linux/in.h>\n#include <linux/ioport.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <linux/delay.h>\t \n#include <linux/etherdevice.h>\n#include <linux/pnp.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n#include <linux/gfp.h>\n\n#include <asm/io.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n\n#ifdef SB1000_DEBUG\nstatic int sb1000_debug = SB1000_DEBUG;\n#else\nstatic const int sb1000_debug = 1;\n#endif\n\nstatic const int SB1000_IO_EXTENT = 8;\n \nstatic const int SB1000_MRU = 1500;  \n\n#define NPIDS 4\nstruct sb1000_private {\n\tstruct sk_buff *rx_skb[NPIDS];\n\tshort rx_dlen[NPIDS];\n\tunsigned int rx_frames;\n\tshort rx_error_count;\n\tshort rx_error_dpc_count;\n\tunsigned char rx_session_id[NPIDS];\n\tunsigned char rx_frame_id[NPIDS];\n\tunsigned char rx_pkt_type[NPIDS];\n};\n\n \nextern int sb1000_probe(struct net_device *dev);\nstatic int sb1000_open(struct net_device *dev);\nstatic int sb1000_siocdevprivate(struct net_device *dev, struct ifreq *ifr,\n\t\t\t\t void __user *data, int cmd);\nstatic netdev_tx_t sb1000_start_xmit(struct sk_buff *skb,\n\t\t\t\t     struct net_device *dev);\nstatic irqreturn_t sb1000_interrupt(int irq, void *dev_id);\nstatic int sb1000_close(struct net_device *dev);\n\n\n \nstatic int card_wait_for_busy_clear(const int ioaddr[],\n\tconst char* name);\nstatic int card_wait_for_ready(const int ioaddr[], const char* name,\n\tunsigned char in[]);\nstatic int card_send_command(const int ioaddr[], const char* name,\n\tconst unsigned char out[], unsigned char in[]);\n\n \nstatic int sb1000_wait_for_ready(const int ioaddr[], const char* name);\nstatic int sb1000_wait_for_ready_clear(const int ioaddr[],\n\tconst char* name);\nstatic void sb1000_send_command(const int ioaddr[], const char* name,\n\tconst unsigned char out[]);\nstatic void sb1000_read_status(const int ioaddr[], unsigned char in[]);\nstatic void sb1000_issue_read_command(const int ioaddr[],\n\tconst char* name);\n\n \nstatic int sb1000_reset(const int ioaddr[], const char* name);\nstatic int sb1000_check_CRC(const int ioaddr[], const char* name);\nstatic inline int sb1000_start_get_set_command(const int ioaddr[],\n\tconst char* name);\nstatic int sb1000_end_get_set_command(const int ioaddr[],\n\tconst char* name);\nstatic int sb1000_activate(const int ioaddr[], const char* name);\nstatic int sb1000_get_firmware_version(const int ioaddr[],\n\tconst char* name, unsigned char version[], int do_end);\nstatic int sb1000_get_frequency(const int ioaddr[], const char* name,\n\tint* frequency);\nstatic int sb1000_set_frequency(const int ioaddr[], const char* name,\n\tint frequency);\nstatic int sb1000_get_PIDs(const int ioaddr[], const char* name,\n\tshort PID[]);\nstatic int sb1000_set_PIDs(const int ioaddr[], const char* name,\n\tconst short PID[]);\n\n \nstatic int sb1000_rx(struct net_device *dev);\nstatic void sb1000_error_dpc(struct net_device *dev);\n\nstatic const struct pnp_device_id sb1000_pnp_ids[] = {\n\t{ \"GIC1000\", 0 },\n\t{ \"\", 0 }\n};\nMODULE_DEVICE_TABLE(pnp, sb1000_pnp_ids);\n\nstatic const struct net_device_ops sb1000_netdev_ops = {\n\t.ndo_open\t\t= sb1000_open,\n\t.ndo_start_xmit\t\t= sb1000_start_xmit,\n\t.ndo_siocdevprivate\t= sb1000_siocdevprivate,\n\t.ndo_stop\t\t= sb1000_close,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int\nsb1000_probe_one(struct pnp_dev *pdev, const struct pnp_device_id *id)\n{\n\tstruct net_device *dev;\n\tunsigned short ioaddr[2], irq;\n\tunsigned int serial_number;\n\tint error = -ENODEV;\n\tu8 addr[ETH_ALEN];\n\n\tif (pnp_device_attach(pdev) < 0)\n\t\treturn -ENODEV;\n\tif (pnp_activate_dev(pdev) < 0)\n\t\tgoto out_detach;\n\n\tif (!pnp_port_valid(pdev, 0) || !pnp_port_valid(pdev, 1))\n\t\tgoto out_disable;\n\tif (!pnp_irq_valid(pdev, 0))\n\t\tgoto out_disable;\n\n\tserial_number = pdev->card->serial;\n\n\tioaddr[0] = pnp_port_start(pdev, 0);\n\tioaddr[1] = pnp_port_start(pdev, 0);\n\n\tirq = pnp_irq(pdev, 0);\n\n\tif (!request_region(ioaddr[0], 16, \"sb1000\"))\n\t\tgoto out_disable;\n\tif (!request_region(ioaddr[1], 16, \"sb1000\"))\n\t\tgoto out_release_region0;\n\n\tdev = alloc_etherdev(sizeof(struct sb1000_private));\n\tif (!dev) {\n\t\terror = -ENOMEM;\n\t\tgoto out_release_regions;\n\t}\n\n\n\tdev->base_addr = ioaddr[0];\n\t \n\tdev->mem_start = ioaddr[1];\n\tdev->irq = irq;\n\n\tif (sb1000_debug > 0)\n\t\tprintk(KERN_NOTICE \"%s: sb1000 at (%#3.3lx,%#3.3lx), \"\n\t\t\t\"S/N %#8.8x, IRQ %d.\\n\", dev->name, dev->base_addr,\n\t\t\tdev->mem_start, serial_number, dev->irq);\n\n\t \n\tdev->flags = IFF_POINTOPOINT|IFF_NOARP;\n\n\tSET_NETDEV_DEV(dev, &pdev->dev);\n\n\tif (sb1000_debug > 0)\n\t\tprintk(KERN_NOTICE \"%s\", version);\n\n\tdev->netdev_ops\t= &sb1000_netdev_ops;\n\n\t \n\taddr[0] = 0;\n\taddr[1] = 0;\n\taddr[2]\t= serial_number >> 24 & 0xff;\n\taddr[3]\t= serial_number >> 16 & 0xff;\n\taddr[4]\t= serial_number >>  8 & 0xff;\n\taddr[5]\t= serial_number >>  0 & 0xff;\n\teth_hw_addr_set(dev, addr);\n\n\tpnp_set_drvdata(pdev, dev);\n\n\terror = register_netdev(dev);\n\tif (error)\n\t\tgoto out_free_netdev;\n\treturn 0;\n\n out_free_netdev:\n\tfree_netdev(dev);\n out_release_regions:\n\trelease_region(ioaddr[1], 16);\n out_release_region0:\n\trelease_region(ioaddr[0], 16);\n out_disable:\n\tpnp_disable_dev(pdev);\n out_detach:\n\tpnp_device_detach(pdev);\n\treturn error;\n}\n\nstatic void\nsb1000_remove_one(struct pnp_dev *pdev)\n{\n\tstruct net_device *dev = pnp_get_drvdata(pdev);\n\n\tunregister_netdev(dev);\n\trelease_region(dev->base_addr, 16);\n\trelease_region(dev->mem_start, 16);\n\tfree_netdev(dev);\n}\n\nstatic struct pnp_driver sb1000_driver = {\n\t.name\t\t= \"sb1000\",\n\t.id_table\t= sb1000_pnp_ids,\n\t.probe\t\t= sb1000_probe_one,\n\t.remove\t\t= sb1000_remove_one,\n};\n\n\n \n\nstatic const int TimeOutJiffies = (875 * HZ) / 100;\n\n \nstatic int\ncard_wait_for_busy_clear(const int ioaddr[], const char* name)\n{\n\tunsigned char a;\n\tunsigned long timeout;\n\n\ta = inb(ioaddr[0] + 7);\n\ttimeout = jiffies + TimeOutJiffies;\n\twhile (a & 0x80 || a & 0x40) {\n\t\t \n\t\tyield();\n\n\t\ta = inb(ioaddr[0] + 7);\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tprintk(KERN_WARNING \"%s: card_wait_for_busy_clear timeout\\n\",\n\t\t\t\tname);\n\t\t\treturn -ETIME;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\ncard_wait_for_ready(const int ioaddr[], const char* name, unsigned char in[])\n{\n\tunsigned char a;\n\tunsigned long timeout;\n\n\ta = inb(ioaddr[1] + 6);\n\ttimeout = jiffies + TimeOutJiffies;\n\twhile (a & 0x80 || !(a & 0x40)) {\n\t\t \n\t\tyield();\n\n\t\ta = inb(ioaddr[1] + 6);\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tprintk(KERN_WARNING \"%s: card_wait_for_ready timeout\\n\",\n\t\t\t\tname);\n\t\t\treturn -ETIME;\n\t\t}\n\t}\n\n\tin[1] = inb(ioaddr[0] + 1);\n\tin[2] = inb(ioaddr[0] + 2);\n\tin[3] = inb(ioaddr[0] + 3);\n\tin[4] = inb(ioaddr[0] + 4);\n\tin[0] = inb(ioaddr[0] + 5);\n\tin[6] = inb(ioaddr[0] + 6);\n\tin[5] = inb(ioaddr[1] + 6);\n\treturn 0;\n}\n\n \nstatic int\ncard_send_command(const int ioaddr[], const char* name,\n\tconst unsigned char out[], unsigned char in[])\n{\n\tint status;\n\n\tif ((status = card_wait_for_busy_clear(ioaddr, name)))\n\t\treturn status;\n\toutb(0xa0, ioaddr[0] + 6);\n\toutb(out[2], ioaddr[0] + 1);\n\toutb(out[3], ioaddr[0] + 2);\n\toutb(out[4], ioaddr[0] + 3);\n\toutb(out[5], ioaddr[0] + 4);\n\toutb(out[1], ioaddr[0] + 5);\n\toutb(0xa0, ioaddr[0] + 6);\n\toutb(out[0], ioaddr[0] + 7);\n\tif (out[0] != 0x20 && out[0] != 0x30) {\n\t\tif ((status = card_wait_for_ready(ioaddr, name, in)))\n\t\t\treturn status;\n\t\tinb(ioaddr[0] + 7);\n\t\tif (sb1000_debug > 3)\n\t\t\tprintk(KERN_DEBUG \"%s: card_send_command \"\n\t\t\t\t\"out: %02x%02x%02x%02x%02x%02x  \"\n\t\t\t\t\"in: %02x%02x%02x%02x%02x%02x%02x\\n\", name,\n\t\t\t\tout[0], out[1], out[2], out[3], out[4], out[5],\n\t\t\t\tin[0], in[1], in[2], in[3], in[4], in[5], in[6]);\n\t} else {\n\t\tif (sb1000_debug > 3)\n\t\t\tprintk(KERN_DEBUG \"%s: card_send_command \"\n\t\t\t\t\"out: %02x%02x%02x%02x%02x%02x\\n\", name,\n\t\t\t\tout[0], out[1], out[2], out[3], out[4], out[5]);\n\t}\n\n\tif (out[1] != 0x1b) {\n\t\tif (out[0] >= 0x80 && in[0] != (out[1] | 0x80))\n\t\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n\n \nstatic const int Sb1000TimeOutJiffies = 7 * HZ;\n\n \nstatic int\nsb1000_wait_for_ready(const int ioaddr[], const char* name)\n{\n\tunsigned long timeout;\n\n\ttimeout = jiffies + Sb1000TimeOutJiffies;\n\twhile (inb(ioaddr[1] + 6) & 0x80) {\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tprintk(KERN_WARNING \"%s: sb1000_wait_for_ready timeout\\n\",\n\t\t\t\tname);\n\t\t\treturn -ETIME;\n\t\t}\n\t}\n\ttimeout = jiffies + Sb1000TimeOutJiffies;\n\twhile (!(inb(ioaddr[1] + 6) & 0x40)) {\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tprintk(KERN_WARNING \"%s: sb1000_wait_for_ready timeout\\n\",\n\t\t\t\tname);\n\t\t\treturn -ETIME;\n\t\t}\n\t}\n\tinb(ioaddr[0] + 7);\n\treturn 0;\n}\n\n \nstatic int\nsb1000_wait_for_ready_clear(const int ioaddr[], const char* name)\n{\n\tunsigned long timeout;\n\n\ttimeout = jiffies + Sb1000TimeOutJiffies;\n\twhile (inb(ioaddr[1] + 6) & 0x80) {\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tprintk(KERN_WARNING \"%s: sb1000_wait_for_ready_clear timeout\\n\",\n\t\t\t\tname);\n\t\t\treturn -ETIME;\n\t\t}\n\t}\n\ttimeout = jiffies + Sb1000TimeOutJiffies;\n\twhile (inb(ioaddr[1] + 6) & 0x40) {\n\t\tif (time_after_eq(jiffies, timeout)) {\n\t\t\tprintk(KERN_WARNING \"%s: sb1000_wait_for_ready_clear timeout\\n\",\n\t\t\t\tname);\n\t\t\treturn -ETIME;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic void\nsb1000_send_command(const int ioaddr[], const char* name,\n\tconst unsigned char out[])\n{\n\toutb(out[2], ioaddr[0] + 1);\n\toutb(out[3], ioaddr[0] + 2);\n\toutb(out[4], ioaddr[0] + 3);\n\toutb(out[5], ioaddr[0] + 4);\n\toutb(out[1], ioaddr[0] + 5);\n\toutb(out[0], ioaddr[0] + 7);\n\tif (sb1000_debug > 3)\n\t\tprintk(KERN_DEBUG \"%s: sb1000_send_command out: %02x%02x%02x%02x\"\n\t\t\t\"%02x%02x\\n\", name, out[0], out[1], out[2], out[3], out[4], out[5]);\n}\n\n \nstatic void\nsb1000_read_status(const int ioaddr[], unsigned char in[])\n{\n\tin[1] = inb(ioaddr[0] + 1);\n\tin[2] = inb(ioaddr[0] + 2);\n\tin[3] = inb(ioaddr[0] + 3);\n\tin[4] = inb(ioaddr[0] + 4);\n\tin[0] = inb(ioaddr[0] + 5);\n}\n\n \nstatic void\nsb1000_issue_read_command(const int ioaddr[], const char* name)\n{\n\tstatic const unsigned char Command0[6] = {0x20, 0x00, 0x00, 0x01, 0x00, 0x00};\n\n\tsb1000_wait_for_ready_clear(ioaddr, name);\n\toutb(0xa0, ioaddr[0] + 6);\n\tsb1000_send_command(ioaddr, name, Command0);\n}\n\n\n \n \nstatic int\nsb1000_reset(const int ioaddr[], const char* name)\n{\n\tstatic const unsigned char Command0[6] = {0x80, 0x16, 0x00, 0x00, 0x00, 0x00};\n\n\tunsigned char st[7];\n\tint port, status;\n\n\tport = ioaddr[1] + 6;\n\toutb(0x4, port);\n\tinb(port);\n\tudelay(1000);\n\toutb(0x0, port);\n\tinb(port);\n\tssleep(1);\n\toutb(0x4, port);\n\tinb(port);\n\tudelay(1000);\n\toutb(0x0, port);\n\tinb(port);\n\tudelay(0);\n\n\tif ((status = card_send_command(ioaddr, name, Command0, st)))\n\t\treturn status;\n\tif (st[3] != 0xf0)\n\t\treturn -EIO;\n\treturn 0;\n}\n\n \nstatic int\nsb1000_check_CRC(const int ioaddr[], const char* name)\n{\n\tstatic const unsigned char Command0[6] = {0x80, 0x1f, 0x00, 0x00, 0x00, 0x00};\n\n\tunsigned char st[7];\n\tint status;\n\n\t \n\tif ((status = card_send_command(ioaddr, name, Command0, st)))\n\t\treturn status;\n\tif (st[1] != st[3] || st[2] != st[4])\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic inline int\nsb1000_start_get_set_command(const int ioaddr[], const char* name)\n{\n\tstatic const unsigned char Command0[6] = {0x80, 0x1b, 0x00, 0x00, 0x00, 0x00};\n\n\tunsigned char st[7];\n\n\treturn card_send_command(ioaddr, name, Command0, st);\n}\n\nstatic int\nsb1000_end_get_set_command(const int ioaddr[], const char* name)\n{\n\tstatic const unsigned char Command0[6] = {0x80, 0x1b, 0x02, 0x00, 0x00, 0x00};\n\tstatic const unsigned char Command1[6] = {0x20, 0x00, 0x00, 0x00, 0x00, 0x00};\n\n\tunsigned char st[7];\n\tint status;\n\n\tif ((status = card_send_command(ioaddr, name, Command0, st)))\n\t\treturn status;\n\treturn card_send_command(ioaddr, name, Command1, st);\n}\n\nstatic int\nsb1000_activate(const int ioaddr[], const char* name)\n{\n\tstatic const unsigned char Command0[6] = {0x80, 0x11, 0x00, 0x00, 0x00, 0x00};\n\tstatic const unsigned char Command1[6] = {0x80, 0x16, 0x00, 0x00, 0x00, 0x00};\n\n\tunsigned char st[7];\n\tint status;\n\n\tssleep(1);\n\tstatus = card_send_command(ioaddr, name, Command0, st);\n\tif (status)\n\t\treturn status;\n\tstatus = card_send_command(ioaddr, name, Command1, st);\n\tif (status)\n\t\treturn status;\n\tif (st[3] != 0xf1) {\n\t\tstatus = sb1000_start_get_set_command(ioaddr, name);\n\t\tif (status)\n\t\t\treturn status;\n\t\treturn -EIO;\n\t}\n\tudelay(1000);\n\treturn sb1000_start_get_set_command(ioaddr, name);\n}\n\n \nstatic int\nsb1000_get_firmware_version(const int ioaddr[], const char* name,\n\tunsigned char version[], int do_end)\n{\n\tstatic const unsigned char Command0[6] = {0x80, 0x23, 0x00, 0x00, 0x00, 0x00};\n\n\tunsigned char st[7];\n\tint status;\n\n\tif ((status = sb1000_start_get_set_command(ioaddr, name)))\n\t\treturn status;\n\tif ((status = card_send_command(ioaddr, name, Command0, st)))\n\t\treturn status;\n\tif (st[0] != 0xa3)\n\t\treturn -EIO;\n\tversion[0] = st[1];\n\tversion[1] = st[2];\n\tif (do_end)\n\t\treturn sb1000_end_get_set_command(ioaddr, name);\n\telse\n\t\treturn 0;\n}\n\n \nstatic int\nsb1000_get_frequency(const int ioaddr[], const char* name, int* frequency)\n{\n\tstatic const unsigned char Command0[6] = {0x80, 0x44, 0x00, 0x00, 0x00, 0x00};\n\n\tunsigned char st[7];\n\tint status;\n\n\tudelay(1000);\n\tif ((status = sb1000_start_get_set_command(ioaddr, name)))\n\t\treturn status;\n\tif ((status = card_send_command(ioaddr, name, Command0, st)))\n\t\treturn status;\n\t*frequency = ((st[1] << 8 | st[2]) << 8 | st[3]) << 8 | st[4];\n\treturn sb1000_end_get_set_command(ioaddr, name);\n}\n\n \nstatic int\nsb1000_set_frequency(const int ioaddr[], const char* name, int frequency)\n{\n\tunsigned char st[7];\n\tint status;\n\tunsigned char Command0[6] = {0x80, 0x29, 0x00, 0x00, 0x00, 0x00};\n\n\tconst int FrequencyLowerLimit = 57000;\n\tconst int FrequencyUpperLimit = 804000;\n\n\tif (frequency < FrequencyLowerLimit || frequency > FrequencyUpperLimit) {\n\t\tprintk(KERN_ERR \"%s: frequency chosen (%d kHz) is not in the range \"\n\t\t\t\"[%d,%d] kHz\\n\", name, frequency, FrequencyLowerLimit,\n\t\t\tFrequencyUpperLimit);\n\t\treturn -EINVAL;\n\t}\n\tudelay(1000);\n\tif ((status = sb1000_start_get_set_command(ioaddr, name)))\n\t\treturn status;\n\tCommand0[5] = frequency & 0xff;\n\tfrequency >>= 8;\n\tCommand0[4] = frequency & 0xff;\n\tfrequency >>= 8;\n\tCommand0[3] = frequency & 0xff;\n\tfrequency >>= 8;\n\tCommand0[2] = frequency & 0xff;\n\treturn card_send_command(ioaddr, name, Command0, st);\n}\n\n \nstatic int\nsb1000_get_PIDs(const int ioaddr[], const char* name, short PID[])\n{\n\tstatic const unsigned char Command0[6] = {0x80, 0x40, 0x00, 0x00, 0x00, 0x00};\n\tstatic const unsigned char Command1[6] = {0x80, 0x41, 0x00, 0x00, 0x00, 0x00};\n\tstatic const unsigned char Command2[6] = {0x80, 0x42, 0x00, 0x00, 0x00, 0x00};\n\tstatic const unsigned char Command3[6] = {0x80, 0x43, 0x00, 0x00, 0x00, 0x00};\n\n\tunsigned char st[7];\n\tint status;\n\n\tudelay(1000);\n\tif ((status = sb1000_start_get_set_command(ioaddr, name)))\n\t\treturn status;\n\n\tif ((status = card_send_command(ioaddr, name, Command0, st)))\n\t\treturn status;\n\tPID[0] = st[1] << 8 | st[2];\n\n\tif ((status = card_send_command(ioaddr, name, Command1, st)))\n\t\treturn status;\n\tPID[1] = st[1] << 8 | st[2];\n\n\tif ((status = card_send_command(ioaddr, name, Command2, st)))\n\t\treturn status;\n\tPID[2] = st[1] << 8 | st[2];\n\n\tif ((status = card_send_command(ioaddr, name, Command3, st)))\n\t\treturn status;\n\tPID[3] = st[1] << 8 | st[2];\n\n\treturn sb1000_end_get_set_command(ioaddr, name);\n}\n\n \nstatic int\nsb1000_set_PIDs(const int ioaddr[], const char* name, const short PID[])\n{\n\tstatic const unsigned char Command4[6] = {0x80, 0x2e, 0x00, 0x00, 0x00, 0x00};\n\n\tunsigned char st[7];\n\tshort p;\n\tint status;\n\tunsigned char Command0[6] = {0x80, 0x31, 0x00, 0x00, 0x00, 0x00};\n\tunsigned char Command1[6] = {0x80, 0x32, 0x00, 0x00, 0x00, 0x00};\n\tunsigned char Command2[6] = {0x80, 0x33, 0x00, 0x00, 0x00, 0x00};\n\tunsigned char Command3[6] = {0x80, 0x34, 0x00, 0x00, 0x00, 0x00};\n\n\tudelay(1000);\n\tif ((status = sb1000_start_get_set_command(ioaddr, name)))\n\t\treturn status;\n\n\tp = PID[0];\n\tCommand0[3] = p & 0xff;\n\tp >>= 8;\n\tCommand0[2] = p & 0xff;\n\tif ((status = card_send_command(ioaddr, name, Command0, st)))\n\t\treturn status;\n\n\tp = PID[1];\n\tCommand1[3] = p & 0xff;\n\tp >>= 8;\n\tCommand1[2] = p & 0xff;\n\tif ((status = card_send_command(ioaddr, name, Command1, st)))\n\t\treturn status;\n\n\tp = PID[2];\n\tCommand2[3] = p & 0xff;\n\tp >>= 8;\n\tCommand2[2] = p & 0xff;\n\tif ((status = card_send_command(ioaddr, name, Command2, st)))\n\t\treturn status;\n\n\tp = PID[3];\n\tCommand3[3] = p & 0xff;\n\tp >>= 8;\n\tCommand3[2] = p & 0xff;\n\tif ((status = card_send_command(ioaddr, name, Command3, st)))\n\t\treturn status;\n\n\tif ((status = card_send_command(ioaddr, name, Command4, st)))\n\t\treturn status;\n\treturn sb1000_end_get_set_command(ioaddr, name);\n}\n\n\nstatic void\nsb1000_print_status_buffer(const char* name, unsigned char st[],\n\tunsigned char buffer[], int size)\n{\n\tint i, j, k;\n\n\tprintk(KERN_DEBUG \"%s: status: %02x %02x\\n\", name, st[0], st[1]);\n\tif (buffer[24] == 0x08 && buffer[25] == 0x00 && buffer[26] == 0x45) {\n\t\tprintk(KERN_DEBUG \"%s: length: %d protocol: %d from: %d.%d.%d.%d:%d \"\n\t\t\t\"to %d.%d.%d.%d:%d\\n\", name, buffer[28] << 8 | buffer[29],\n\t\t\tbuffer[35], buffer[38], buffer[39], buffer[40], buffer[41],\n            buffer[46] << 8 | buffer[47],\n\t\t\tbuffer[42], buffer[43], buffer[44], buffer[45],\n            buffer[48] << 8 | buffer[49]);\n\t} else {\n\t\tfor (i = 0, k = 0; i < (size + 7) / 8; i++) {\n\t\t\tprintk(KERN_DEBUG \"%s: %s\", name, i ? \"       \" : \"buffer:\");\n\t\t\tfor (j = 0; j < 8 && k < size; j++, k++)\n\t\t\t\tprintk(\" %02x\", buffer[k]);\n\t\t\tprintk(\"\\n\");\n\t\t}\n\t}\n}\n\n \n \nstatic int\nsb1000_rx(struct net_device *dev)\n{\n\n#define FRAMESIZE 184\n\tunsigned char st[2], buffer[FRAMESIZE], session_id, frame_id;\n\tshort dlen;\n\tint ioaddr, ns;\n\tunsigned int skbsize;\n\tstruct sk_buff *skb;\n\tstruct sb1000_private *lp = netdev_priv(dev);\n\tstruct net_device_stats *stats = &dev->stats;\n\n\t \n\tconst int FrameSize = FRAMESIZE;\n\tconst int NewDatagramHeaderSkip = 8;\n\tconst int NewDatagramHeaderSize = NewDatagramHeaderSkip + 18;\n\tconst int NewDatagramDataSize = FrameSize - NewDatagramHeaderSize;\n\tconst int ContDatagramHeaderSkip = 7;\n\tconst int ContDatagramHeaderSize = ContDatagramHeaderSkip + 1;\n\tconst int ContDatagramDataSize = FrameSize - ContDatagramHeaderSize;\n\tconst int TrailerSize = 4;\n\n\tioaddr = dev->base_addr;\n\n\tinsw(ioaddr, (unsigned short*) st, 1);\n#ifdef XXXDEBUG\nprintk(\"cm0: received: %02x %02x\\n\", st[0], st[1]);\n#endif  \n\tlp->rx_frames++;\n\n\t \n\tfor (ns = 0; ns < NPIDS; ns++) {\n\t\tsession_id = lp->rx_session_id[ns];\n\t\tframe_id = lp->rx_frame_id[ns];\n\t\tif (st[0] == session_id) {\n\t\t\tif (st[1] == frame_id || (!frame_id && (st[1] & 0xf0) == 0x30)) {\n\t\t\t\tgoto good_frame;\n\t\t\t} else if ((st[1] & 0xf0) == 0x30 && (st[0] & 0x40)) {\n\t\t\t\tgoto skipped_frame;\n\t\t\t} else {\n\t\t\t\tgoto bad_frame;\n\t\t\t}\n\t\t} else if (st[0] == (session_id | 0x40)) {\n\t\t\tif ((st[1] & 0xf0) == 0x30) {\n\t\t\t\tgoto skipped_frame;\n\t\t\t} else {\n\t\t\t\tgoto bad_frame;\n\t\t\t}\n\t\t}\n\t}\n\tgoto bad_frame;\n\nskipped_frame:\n\tstats->rx_frame_errors++;\n\tskb = lp->rx_skb[ns];\n\tif (sb1000_debug > 1)\n\t\tprintk(KERN_WARNING \"%s: missing frame(s): got %02x %02x \"\n\t\t\t\"expecting %02x %02x\\n\", dev->name, st[0], st[1],\n\t\t\tskb ? session_id : session_id | 0x40, frame_id);\n\tif (skb) {\n\t\tdev_kfree_skb(skb);\n\t\tskb = NULL;\n\t}\n\ngood_frame:\n\tlp->rx_frame_id[ns] = 0x30 | ((st[1] + 1) & 0x0f);\n\t \n\tif (st[0] & 0x40) {\n\t\t \n\t\tinsw(ioaddr, buffer, NewDatagramHeaderSize / 2);\n#ifdef XXXDEBUG\nprintk(\"cm0: IP identification: %02x%02x  fragment offset: %02x%02x\\n\", buffer[30], buffer[31], buffer[32], buffer[33]);\n#endif  \n\t\tif (buffer[0] != NewDatagramHeaderSkip) {\n\t\t\tif (sb1000_debug > 1)\n\t\t\t\tprintk(KERN_WARNING \"%s: new datagram header skip error: \"\n\t\t\t\t\t\"got %02x expecting %02x\\n\", dev->name, buffer[0],\n\t\t\t\t\tNewDatagramHeaderSkip);\n\t\t\tstats->rx_length_errors++;\n\t\t\tinsw(ioaddr, buffer, NewDatagramDataSize / 2);\n\t\t\tgoto bad_frame_next;\n\t\t}\n\t\tdlen = ((buffer[NewDatagramHeaderSkip + 3] & 0x0f) << 8 |\n\t\t\tbuffer[NewDatagramHeaderSkip + 4]) - 17;\n\t\tif (dlen > SB1000_MRU) {\n\t\t\tif (sb1000_debug > 1)\n\t\t\t\tprintk(KERN_WARNING \"%s: datagram length (%d) greater \"\n\t\t\t\t\t\"than MRU (%d)\\n\", dev->name, dlen, SB1000_MRU);\n\t\t\tstats->rx_length_errors++;\n\t\t\tinsw(ioaddr, buffer, NewDatagramDataSize / 2);\n\t\t\tgoto bad_frame_next;\n\t\t}\n\t\tlp->rx_dlen[ns] = dlen;\n\t\t \n\t\tskbsize = dlen + FrameSize;\n\t\tif ((skb = alloc_skb(skbsize, GFP_ATOMIC)) == NULL) {\n\t\t\tif (sb1000_debug > 1)\n\t\t\t\tprintk(KERN_WARNING \"%s: can't allocate %d bytes long \"\n\t\t\t\t\t\"skbuff\\n\", dev->name, skbsize);\n\t\t\tstats->rx_dropped++;\n\t\t\tinsw(ioaddr, buffer, NewDatagramDataSize / 2);\n\t\t\tgoto dropped_frame;\n\t\t}\n\t\tskb->dev = dev;\n\t\tskb_reset_mac_header(skb);\n\t\tskb->protocol = (unsigned short) buffer[NewDatagramHeaderSkip + 16];\n\t\tinsw(ioaddr, skb_put(skb, NewDatagramDataSize),\n\t\t\tNewDatagramDataSize / 2);\n\t\tlp->rx_skb[ns] = skb;\n\t} else {\n\t\t \n\t\tinsw(ioaddr, buffer, ContDatagramHeaderSize / 2);\n\t\tif (buffer[0] != ContDatagramHeaderSkip) {\n\t\t\tif (sb1000_debug > 1)\n\t\t\t\tprintk(KERN_WARNING \"%s: cont datagram header skip error: \"\n\t\t\t\t\t\"got %02x expecting %02x\\n\", dev->name, buffer[0],\n\t\t\t\t\tContDatagramHeaderSkip);\n\t\t\tstats->rx_length_errors++;\n\t\t\tinsw(ioaddr, buffer, ContDatagramDataSize / 2);\n\t\t\tgoto bad_frame_next;\n\t\t}\n\t\tskb = lp->rx_skb[ns];\n\t\tinsw(ioaddr, skb_put(skb, ContDatagramDataSize),\n\t\t\tContDatagramDataSize / 2);\n\t\tdlen = lp->rx_dlen[ns];\n\t}\n\tif (skb->len < dlen + TrailerSize) {\n\t\tlp->rx_session_id[ns] &= ~0x40;\n\t\treturn 0;\n\t}\n\n\t \n\tskb_trim(skb, dlen);\n\t__netif_rx(skb);\n\tstats->rx_bytes+=dlen;\n\tstats->rx_packets++;\n\tlp->rx_skb[ns] = NULL;\n\tlp->rx_session_id[ns] |= 0x40;\n\treturn 0;\n\nbad_frame:\n\tinsw(ioaddr, buffer, FrameSize / 2);\n\tif (sb1000_debug > 1)\n\t\tprintk(KERN_WARNING \"%s: frame error: got %02x %02x\\n\",\n\t\t\tdev->name, st[0], st[1]);\n\tstats->rx_frame_errors++;\nbad_frame_next:\n\tif (sb1000_debug > 2)\n\t\tsb1000_print_status_buffer(dev->name, st, buffer, FrameSize);\ndropped_frame:\n\tstats->rx_errors++;\n\tif (ns < NPIDS) {\n\t\tif ((skb = lp->rx_skb[ns])) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\tlp->rx_skb[ns] = NULL;\n\t\t}\n\t\tlp->rx_session_id[ns] |= 0x40;\n\t}\n\treturn -1;\n}\n\nstatic void\nsb1000_error_dpc(struct net_device *dev)\n{\n\tstatic const unsigned char Command0[6] = {0x80, 0x26, 0x00, 0x00, 0x00, 0x00};\n\n\tchar *name;\n\tunsigned char st[5];\n\tint ioaddr[2];\n\tstruct sb1000_private *lp = netdev_priv(dev);\n\tconst int ErrorDpcCounterInitialize = 200;\n\n\tioaddr[0] = dev->base_addr;\n\t \n\tioaddr[1] = dev->mem_start;\n\tname = dev->name;\n\n\tsb1000_wait_for_ready_clear(ioaddr, name);\n\tsb1000_send_command(ioaddr, name, Command0);\n\tsb1000_wait_for_ready(ioaddr, name);\n\tsb1000_read_status(ioaddr, st);\n\tif (st[1] & 0x10)\n\t\tlp->rx_error_dpc_count = ErrorDpcCounterInitialize;\n}\n\n\n \nstatic int\nsb1000_open(struct net_device *dev)\n{\n\tchar *name;\n\tint ioaddr[2], status;\n\tstruct sb1000_private *lp = netdev_priv(dev);\n\tconst unsigned short FirmwareVersion[] = {0x01, 0x01};\n\n\tioaddr[0] = dev->base_addr;\n\t \n\tioaddr[1] = dev->mem_start;\n\tname = dev->name;\n\n\t \n\tif ((status = sb1000_reset(ioaddr, name)))\n\t\treturn status;\n\tssleep(1);\n\tif ((status = sb1000_check_CRC(ioaddr, name)))\n\t\treturn status;\n\n\t \n\tlp->rx_skb[0] = NULL;\n\tlp->rx_skb[1] = NULL;\n\tlp->rx_skb[2] = NULL;\n\tlp->rx_skb[3] = NULL;\n\tlp->rx_dlen[0] = 0;\n\tlp->rx_dlen[1] = 0;\n\tlp->rx_dlen[2] = 0;\n\tlp->rx_dlen[3] = 0;\n\tlp->rx_frames = 0;\n\tlp->rx_error_count = 0;\n\tlp->rx_error_dpc_count = 0;\n\tlp->rx_session_id[0] = 0x50;\n\tlp->rx_session_id[1] = 0x48;\n\tlp->rx_session_id[2] = 0x44;\n\tlp->rx_session_id[3] = 0x42;\n\tlp->rx_frame_id[0] = 0;\n\tlp->rx_frame_id[1] = 0;\n\tlp->rx_frame_id[2] = 0;\n\tlp->rx_frame_id[3] = 0;\n\tif (request_irq(dev->irq, sb1000_interrupt, 0, \"sb1000\", dev)) {\n\t\treturn -EAGAIN;\n\t}\n\n\tif (sb1000_debug > 2)\n\t\tprintk(KERN_DEBUG \"%s: Opening, IRQ %d\\n\", name, dev->irq);\n\n\t \n\tudelay(1000);\n\tif ((status = sb1000_activate(ioaddr, name)))\n\t\treturn status;\n\tudelay(0);\n\tif ((status = sb1000_get_firmware_version(ioaddr, name, version, 0)))\n\t\treturn status;\n\tif (version[0] != FirmwareVersion[0] || version[1] != FirmwareVersion[1])\n\t\tprintk(KERN_WARNING \"%s: found firmware version %x.%02x \"\n\t\t\t\"(should be %x.%02x)\\n\", name, version[0], version[1],\n\t\t\tFirmwareVersion[0], FirmwareVersion[1]);\n\n\n\tnetif_start_queue(dev);\n\treturn 0;\t\t\t\t\t \n}\n\nstatic int sb1000_siocdevprivate(struct net_device *dev, struct ifreq *ifr,\n\t\t\t\t void __user *data, int cmd)\n{\n\tchar* name;\n\tunsigned char version[2];\n\tshort PID[4];\n\tint ioaddr[2], status, frequency;\n\tunsigned int stats[5];\n\tstruct sb1000_private *lp = netdev_priv(dev);\n\n\tif (!(dev && dev->flags & IFF_UP))\n\t\treturn -ENODEV;\n\n\tioaddr[0] = dev->base_addr;\n\t \n\tioaddr[1] = dev->mem_start;\n\tname = dev->name;\n\n\tswitch (cmd) {\n\tcase SIOCGCMSTATS:\t\t \n\t\tstats[0] = dev->stats.rx_bytes;\n\t\tstats[1] = lp->rx_frames;\n\t\tstats[2] = dev->stats.rx_packets;\n\t\tstats[3] = dev->stats.rx_errors;\n\t\tstats[4] = dev->stats.rx_dropped;\n\t\tif (copy_to_user(data, stats, sizeof(stats)))\n\t\t\treturn -EFAULT;\n\t\tstatus = 0;\n\t\tbreak;\n\n\tcase SIOCGCMFIRMWARE:\t\t \n\t\tif ((status = sb1000_get_firmware_version(ioaddr, name, version, 1)))\n\t\t\treturn status;\n\t\tif (copy_to_user(data, version, sizeof(version)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase SIOCGCMFREQUENCY:\t\t \n\t\tif ((status = sb1000_get_frequency(ioaddr, name, &frequency)))\n\t\t\treturn status;\n\t\tif (put_user(frequency, (int __user *)data))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase SIOCSCMFREQUENCY:\t\t \n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (get_user(frequency, (int __user *)data))\n\t\t\treturn -EFAULT;\n\t\tif ((status = sb1000_set_frequency(ioaddr, name, frequency)))\n\t\t\treturn status;\n\t\tbreak;\n\n\tcase SIOCGCMPIDS:\t\t\t \n\t\tif ((status = sb1000_get_PIDs(ioaddr, name, PID)))\n\t\t\treturn status;\n\t\tif (copy_to_user(data, PID, sizeof(PID)))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tcase SIOCSCMPIDS:\t\t\t \n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(PID, data, sizeof(PID)))\n\t\t\treturn -EFAULT;\n\t\tif ((status = sb1000_set_PIDs(ioaddr, name, PID)))\n\t\t\treturn status;\n\t\t \n\t\tlp->rx_session_id[0] = 0x50 | (PID[0] & 0x0f);\n\t\tlp->rx_session_id[1] = 0x48;\n\t\tlp->rx_session_id[2] = 0x44;\n\t\tlp->rx_session_id[3] = 0x42;\n\t\tlp->rx_frame_id[0] = 0;\n\t\tlp->rx_frame_id[1] = 0;\n\t\tlp->rx_frame_id[2] = 0;\n\t\tlp->rx_frame_id[3] = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EINVAL;\n\t\tbreak;\n\t}\n\treturn status;\n}\n\n \nstatic netdev_tx_t\nsb1000_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tprintk(KERN_WARNING \"%s: trying to transmit!!!\\n\", dev->name);\n\t \n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic irqreturn_t sb1000_interrupt(int irq, void *dev_id)\n{\n\tstatic const unsigned char Command0[6] = {0x80, 0x2c, 0x00, 0x00, 0x00, 0x00};\n\tstatic const unsigned char Command1[6] = {0x80, 0x2e, 0x00, 0x00, 0x00, 0x00};\n\n\tchar *name;\n\tunsigned char st;\n\tint ioaddr[2];\n\tstruct net_device *dev = dev_id;\n\tstruct sb1000_private *lp = netdev_priv(dev);\n\n\tconst int MaxRxErrorCount = 6;\n\n\tioaddr[0] = dev->base_addr;\n\t \n\tioaddr[1] = dev->mem_start;\n\tname = dev->name;\n\n\t \n\tst = inb(ioaddr[1] + 6);\n\tif (!(st & 0x08 && st & 0x20)) {\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (sb1000_debug > 3)\n\t\tprintk(KERN_DEBUG \"%s: entering interrupt\\n\", dev->name);\n\n\tst = inb(ioaddr[0] + 7);\n\tif (sb1000_rx(dev))\n\t\tlp->rx_error_count++;\n#ifdef SB1000_DELAY\n\tudelay(SB1000_DELAY);\n#endif  \n\tsb1000_issue_read_command(ioaddr, name);\n\tif (st & 0x01) {\n\t\tsb1000_error_dpc(dev);\n\t\tsb1000_issue_read_command(ioaddr, name);\n\t}\n\tif (lp->rx_error_dpc_count && !(--lp->rx_error_dpc_count)) {\n\t\tsb1000_wait_for_ready_clear(ioaddr, name);\n\t\tsb1000_send_command(ioaddr, name, Command0);\n\t\tsb1000_wait_for_ready(ioaddr, name);\n\t\tsb1000_issue_read_command(ioaddr, name);\n\t}\n\tif (lp->rx_error_count >= MaxRxErrorCount) {\n\t\tsb1000_wait_for_ready_clear(ioaddr, name);\n\t\tsb1000_send_command(ioaddr, name, Command1);\n\t\tsb1000_wait_for_ready(ioaddr, name);\n\t\tsb1000_issue_read_command(ioaddr, name);\n\t\tlp->rx_error_count = 0;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sb1000_close(struct net_device *dev)\n{\n\tint i;\n\tint ioaddr[2];\n\tstruct sb1000_private *lp = netdev_priv(dev);\n\n\tif (sb1000_debug > 2)\n\t\tprintk(KERN_DEBUG \"%s: Shutting down sb1000.\\n\", dev->name);\n\n\tnetif_stop_queue(dev);\n\n\tioaddr[0] = dev->base_addr;\n\t \n\tioaddr[1] = dev->mem_start;\n\n\tfree_irq(dev->irq, dev);\n\t \n\trelease_region(ioaddr[1], SB1000_IO_EXTENT);\n\trelease_region(ioaddr[0], SB1000_IO_EXTENT);\n\n\t \n\tfor (i=0; i<4; i++) {\n\t\tif (lp->rx_skb[i]) {\n\t\t\tdev_kfree_skb(lp->rx_skb[i]);\n\t\t}\n\t}\n\treturn 0;\n}\n\nMODULE_AUTHOR(\"Franco Venturi <fventuri@mediaone.net>\");\nMODULE_DESCRIPTION(\"General Instruments SB1000 driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_pnp_driver(sb1000_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}