{
  "module_name": "cops.c",
  "hash_id": "9e8fba3a2b2bb765d8e56e5893112213e26dec8d631aae4458775d4412df3eec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/appletalk/cops.c",
  "human_readable_source": " \n\nstatic const char *version =\n\"cops.c:v0.04 6/7/98 Jay Schulist <jschlst@samba.org>\\n\";\n \n\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/ptrace.h>\n#include <linux/ioport.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/if_arp.h>\n#include <linux/if_ltalk.h>\n#include <linux/delay.h>\t \n#include <linux/atalk.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/jiffies.h>\n\n#include <net/Space.h>\n\n#include <asm/io.h>\n#include <asm/dma.h>\n\n#include \"cops.h\"\t\t \n#include \"cops_ltdrv.h\"\t\t \n#include \"cops_ffdrv.h\"\t\t \n\n \n\nstatic const char *cardname = \"cops\";\n\n#ifdef CONFIG_COPS_DAYNA\nstatic int board_type = DAYNA;\t \n#else\nstatic int board_type = TANGENT;\n#endif\n\nstatic int io = 0x240;\t\t \nstatic int irq = 5;\t\t \n\n \n\n \n\nstatic unsigned int ports[] = { \n\t0x240, 0x340, 0x200, 0x210, 0x220, 0x230, 0x260, \n\t0x2A0, 0x300, 0x310, 0x320, 0x330, 0x350, 0x360,\n\t0\n};\n\n \n\nstatic int cops_irqlist[] = {\n\t5, 4, 3, 0 \n};\n\nstatic struct timer_list cops_timer;\nstatic struct net_device *cops_timer_dev;\n\n \n#ifndef COPS_DEBUG\n#define COPS_DEBUG 1 \n#endif\nstatic unsigned int cops_debug = COPS_DEBUG;\n\n \n#define COPS_IO_EXTENT       8\n\n \n\nstruct cops_local\n{\n        int board;\t\t\t \n\tint nodeid;\t\t\t \n        unsigned char node_acquire;\t \n        struct atalk_addr node_addr;\t \n\tspinlock_t lock;\t\t \n};\n\n \nstatic int  cops_probe1 (struct net_device *dev, int ioaddr);\nstatic int  cops_irq (int ioaddr, int board);\n\nstatic int  cops_open (struct net_device *dev);\nstatic int  cops_jumpstart (struct net_device *dev);\nstatic void cops_reset (struct net_device *dev, int sleep);\nstatic void cops_load (struct net_device *dev);\nstatic int  cops_nodeid (struct net_device *dev, int nodeid);\n\nstatic irqreturn_t cops_interrupt (int irq, void *dev_id);\nstatic void cops_poll(struct timer_list *t);\nstatic void cops_timeout(struct net_device *dev, unsigned int txqueue);\nstatic void cops_rx (struct net_device *dev);\nstatic netdev_tx_t  cops_send_packet (struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *dev);\nstatic void set_multicast_list (struct net_device *dev);\nstatic int  cops_ioctl (struct net_device *dev, struct ifreq *rq, int cmd);\nstatic int  cops_close (struct net_device *dev);\n\nstatic void cleanup_card(struct net_device *dev)\n{\n\tif (dev->irq)\n\t\tfree_irq(dev->irq, dev);\n\trelease_region(dev->base_addr, COPS_IO_EXTENT);\n}\n\n \nstruct net_device * __init cops_probe(int unit)\n{\n\tstruct net_device *dev;\n\tunsigned *port;\n\tint base_addr;\n\tint err = 0;\n\n\tdev = alloc_ltalkdev(sizeof(struct cops_local));\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (unit >= 0) {\n\t\tsprintf(dev->name, \"lt%d\", unit);\n\t\tnetdev_boot_setup_check(dev);\n\t\tirq = dev->irq;\n\t\tbase_addr = dev->base_addr;\n\t} else {\n\t\tbase_addr = dev->base_addr = io;\n\t}\n\n\tif (base_addr > 0x1ff) {     \n\t\terr = cops_probe1(dev, base_addr);\n\t} else if (base_addr != 0) {  \n\t\terr = -ENXIO;\n\t} else {\n\t\t \n\t\tfor (port = ports; *port && cops_probe1(dev, *port) < 0; port++)\n\t\t\t;\n\t\tif (!*port)\n\t\t\terr = -ENODEV;\n\t}\n\tif (err)\n\t\tgoto out;\n\terr = register_netdev(dev);\n\tif (err)\n\t\tgoto out1;\n\treturn dev;\nout1:\n\tcleanup_card(dev);\nout:\n\tfree_netdev(dev);\n\treturn ERR_PTR(err);\n}\n\nstatic const struct net_device_ops cops_netdev_ops = {\n\t.ndo_open               = cops_open,\n        .ndo_stop               = cops_close,\n\t.ndo_start_xmit   \t= cops_send_packet,\n\t.ndo_tx_timeout\t\t= cops_timeout,\n        .ndo_do_ioctl           = cops_ioctl,\n\t.ndo_set_rx_mode\t= set_multicast_list,\n};\n\n \nstatic int __init cops_probe1(struct net_device *dev, int ioaddr)\n{\n        struct cops_local *lp;\n\tstatic unsigned version_printed;\n\tint board = board_type;\n\tint retval;\n\t\n        if(cops_debug && version_printed++ == 0)\n\t\tprintk(\"%s\", version);\n\n\t \n\tif (!request_region(ioaddr, COPS_IO_EXTENT, dev->name))\n\t\treturn -EBUSY;\n\n         \n\tdev->irq = irq;\n\tswitch (dev->irq)\n\t{\n\t\tcase 0:\n\t\t\t \n\t\t\tdev->irq = cops_irq(ioaddr, board);\n\t\t\tif (dev->irq)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\t \n\t\tcase 1:\n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_out;\n\n\t\t \n\t\tcase 2:\n\t\t\tdev->irq = 9;\n\t\t\tbreak;\n\n\t\t \n\t\tcase 0xff:\n\t\t\tdev->irq = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tdev->base_addr = ioaddr;\n\n\t \n\tif (dev->irq) {\n\t\tretval = request_irq(dev->irq, cops_interrupt, 0, dev->name, dev);\n\t\tif (retval)\n\t\t\tgoto err_out;\n\t}\n\n        lp = netdev_priv(dev);\n        spin_lock_init(&lp->lock);\n\n\t \n\tlp->board               = board;\n\n\tdev->netdev_ops \t= &cops_netdev_ops;\n\tdev->watchdog_timeo\t= HZ * 2;\n\n\n\t \n\tif(board==DAYNA)\n\t\tprintk(\"%s: %s at %#3x, using IRQ %d, in Dayna mode.\\n\", \n\t\t\tdev->name, cardname, ioaddr, dev->irq);\n\tif(board==TANGENT) {\n\t\tif(dev->irq)\n\t\t\tprintk(\"%s: %s at %#3x, IRQ %d, in Tangent mode\\n\", \n\t\t\t\tdev->name, cardname, ioaddr, dev->irq);\n\t\telse\n\t\t\tprintk(\"%s: %s at %#3x, using polled IO, in Tangent mode.\\n\", \n\t\t\t\tdev->name, cardname, ioaddr);\n\n\t}\n        return 0;\n\nerr_out:\n\trelease_region(ioaddr, COPS_IO_EXTENT);\n\treturn retval;\n}\n\nstatic int __init cops_irq (int ioaddr, int board)\n{        \n        int irqaddr=0;\n        int i, x, status;\n\n        if(board==DAYNA)\n        {\n                outb(0, ioaddr+DAYNA_RESET);\n                inb(ioaddr+DAYNA_RESET);\n                mdelay(333);\n        }\n        if(board==TANGENT)\n        {\n                inb(ioaddr);\n                outb(0, ioaddr);\n                outb(0, ioaddr+TANG_RESET);\n        }\n\n        for(i=0; cops_irqlist[i] !=0; i++)\n        {\n                irqaddr = cops_irqlist[i];\n                for(x = 0xFFFF; x>0; x --)     \n                {\n                        if(board==DAYNA)\n                        {\n                                status = (inb(ioaddr+DAYNA_CARD_STATUS)&3);\n                                if(status == 1)\n                                        return irqaddr;\n                        }\n                        if(board==TANGENT)\n                        {\n                                if((inb(ioaddr+TANG_CARD_STATUS)& TANG_TX_READY) !=0)\n                                        return irqaddr;\n                        }\n                }\n        }\n        return 0;        \n}\n\n \nstatic int cops_open(struct net_device *dev)\n{\n    struct cops_local *lp = netdev_priv(dev);\n\n\tif(dev->irq==0)\n\t{\n\t\t \n\t\tif(lp->board==TANGENT)\t \n\t\t{\n\t\t    cops_timer_dev = dev;\n\t\t    timer_setup(&cops_timer, cops_poll, 0);\n\t\t    cops_timer.expires \t= jiffies + HZ/20;\n\t\t    add_timer(&cops_timer);\n\t\t} \n\t\telse \n\t\t{\n\t\t\tprintk(KERN_WARNING \"%s: No irq line set\\n\", dev->name);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\tcops_jumpstart(dev);\t \n\n\tnetif_start_queue(dev);\n        return 0;\n}\n\n \nstatic int cops_jumpstart(struct net_device *dev)\n{\n\tstruct cops_local *lp = netdev_priv(dev);\n\n\t \n        cops_reset(dev,1);\t \n        cops_load(dev);\t\t \n\n\t \t\n\tif(lp->nodeid == 1)\n\t\tcops_nodeid(dev,lp->node_acquire);\n\n\treturn 0;\n}\n\nstatic void tangent_wait_reset(int ioaddr)\n{\n\tint timeout=0;\n\n\twhile(timeout++ < 5 && (inb(ioaddr+TANG_CARD_STATUS)&TANG_TX_READY)==0)\n\t\tmdelay(1);    \n}\n\n \nstatic void cops_reset(struct net_device *dev, int sleep)\n{\n        struct cops_local *lp = netdev_priv(dev);\n        int ioaddr=dev->base_addr;\n\n        if(lp->board==TANGENT)\n        {\n                inb(ioaddr);\t\t \n                outb(0,ioaddr);\t\t \n                outb(0, ioaddr+TANG_RESET);\t \n\n\t\ttangent_wait_reset(ioaddr);\n                outb(0, ioaddr+TANG_CLEAR_INT);\n        }\n        if(lp->board==DAYNA)\n        {\n                outb(0, ioaddr+DAYNA_RESET);\t \n                inb(ioaddr+DAYNA_RESET);\t \n\t\tif (sleep)\n\t\t\tmsleep(333);\n\t\telse\n\t\t\tmdelay(333);\n        }\n\n\tnetif_wake_queue(dev);\n}\n\nstatic void cops_load (struct net_device *dev)\n{\n        struct ifreq ifr;\n        struct ltfirmware *ltf= (struct ltfirmware *)&ifr.ifr_ifru;\n        struct cops_local *lp = netdev_priv(dev);\n        int ioaddr=dev->base_addr;\n\tint length, i = 0;\n\n        strcpy(ifr.ifr_name,\"lt0\");\n\n         \n#ifdef CONFIG_COPS_DAYNA        \n        if(lp->board==DAYNA)\n        {\n                ltf->length=sizeof(ffdrv_code);\n                ltf->data=ffdrv_code;\n        }\n        else\n#endif        \n#ifdef CONFIG_COPS_TANGENT\n        if(lp->board==TANGENT)\n        {\n                ltf->length=sizeof(ltdrv_code);\n                ltf->data=ltdrv_code;\n        }\n        else\n#endif\n\t{\n\t\tprintk(KERN_INFO \"%s; unsupported board type.\\n\", dev->name);\n\t\treturn;\n\t}\n\t\n         \n        if(lp->board==DAYNA && ltf->length!=5983)\n        {\n                printk(KERN_WARNING \"%s: Firmware is not length of FFDRV.BIN.\\n\", dev->name);\n                return;\n        }\n        if(lp->board==TANGENT && ltf->length!=2501)\n        {\n                printk(KERN_WARNING \"%s: Firmware is not length of DRVCODE.BIN.\\n\", dev->name);\n                return;\n        }\n\n        if(lp->board==DAYNA)\n        {\n                 \n                while(++i<65536)\n                {\n                       if((inb(ioaddr+DAYNA_CARD_STATUS)&3)==1)\n                                break;\n                }\n\n                if(i==65536)\n                        return;\n        }\n\n         \n\ti=0;\n        length = ltf->length;\n        while(length--)\n        {\n                outb(ltf->data[i], ioaddr);\n                i++;\n        }\n\n\tif(cops_debug > 1)\n\t\tprintk(\"%s: Uploaded firmware - %d bytes of %d bytes.\\n\", \n\t\t\tdev->name, i, ltf->length);\n\n        if(lp->board==DAYNA) \t \n                outb(1, ioaddr+DAYNA_INT_CARD);\n\telse\t\t\t \n\t\tinb(ioaddr);\n\n        if(lp->board==TANGENT)\n        {\n                tangent_wait_reset(ioaddr);\n                inb(ioaddr);\t \n        }\n}\n\n \nstatic int cops_nodeid (struct net_device *dev, int nodeid)\n{\n\tstruct cops_local *lp = netdev_priv(dev);\n\tint ioaddr = dev->base_addr;\n\n\tif(lp->board == DAYNA)\n        {\n\t\t \n                while((inb(ioaddr+DAYNA_CARD_STATUS)&DAYNA_TX_READY)==0)\n                {\n\t\t\toutb(0, ioaddr+COPS_CLEAR_INT);\t \n\t\t\tif((inb(ioaddr+DAYNA_CARD_STATUS)&0x03)==DAYNA_RX_REQUEST)\n\t\t\t\tcops_rx(dev);\t \n\t\t\tschedule();\n                }\n\n                outb(2, ioaddr);       \t \n                outb(0, ioaddr);\n                outb(LAP_INIT, ioaddr);\t \n                outb(nodeid, ioaddr);  \t \n        }\n\n\tif(lp->board == TANGENT)\n        {\n                 \n                while(inb(ioaddr+TANG_CARD_STATUS)&TANG_RX_READY)\n                {\n\t\t\toutb(0, ioaddr+COPS_CLEAR_INT);\t \n\t\t\tcops_rx(dev);          \t \n\t\t\tschedule();\n                }\n\n\t\t \n                if(nodeid == 0)\t         \t\t \n\t\t\tnodeid = jiffies&0xFF;\t\t \n                outb(2, ioaddr);        \t\t \n                outb(0, ioaddr);       \t\t\t \n                outb(LAP_INIT, ioaddr); \t\t \n                outb(nodeid, ioaddr); \t\t  \t \n                outb(0xFF, ioaddr);     \t\t \n        }\n\n\tlp->node_acquire=0;\t\t \n        while(lp->node_acquire==0)\t \n\t{\n\t\toutb(0, ioaddr+COPS_CLEAR_INT);\t \n\n\t\tif(lp->board == DAYNA)\n\t\t{\n\t\t\tif((inb(ioaddr+DAYNA_CARD_STATUS)&0x03)==DAYNA_RX_REQUEST)\n\t\t\t\tcops_rx(dev);\t \n\t\t}\n\t\tif(lp->board == TANGENT)\n\t\t{\t\n\t\t\tif(inb(ioaddr+TANG_CARD_STATUS)&TANG_RX_READY)\n\t\t\t\tcops_rx(dev);    \n\t\t}\n\t\tschedule();\n\t}\n\n\tif(cops_debug > 1)\n\t\tprintk(KERN_DEBUG \"%s: Node ID %d has been acquired.\\n\", \n\t\t\tdev->name, lp->node_acquire);\n\n\tlp->nodeid=1;\t \n\n        return 0;\n}\n\n \n \nstatic void cops_poll(struct timer_list *unused)\n{\n\tint ioaddr, status;\n\tint boguscount = 0;\n\tstruct net_device *dev = cops_timer_dev;\n\n\tdel_timer(&cops_timer);\n\n\tif(dev == NULL)\n\t\treturn;\t \n\n\tioaddr = dev->base_addr;\n\tdo {\n\t\tstatus=inb(ioaddr+TANG_CARD_STATUS);\n\t\tif(status & TANG_RX_READY)\n\t\t\tcops_rx(dev);\n\t\tif(status & TANG_TX_READY)\n\t\t\tnetif_wake_queue(dev);\n\t\tstatus = inb(ioaddr+TANG_CARD_STATUS);\n\t} while((++boguscount < 20) && (status&(TANG_RX_READY|TANG_TX_READY)));\n\n\t \n\tcops_timer.expires = jiffies + HZ/20;\n\tadd_timer(&cops_timer);\n}\n\n \nstatic irqreturn_t cops_interrupt(int irq, void *dev_id)\n{\n        struct net_device *dev = dev_id;\n        struct cops_local *lp;\n        int ioaddr, status;\n        int boguscount = 0;\n\n        ioaddr = dev->base_addr;\n        lp = netdev_priv(dev);\n\n\tif(lp->board==DAYNA)\n\t{\n\t\tdo {\n\t\t\toutb(0, ioaddr + COPS_CLEAR_INT);\n\t\t\tstatus=inb(ioaddr+DAYNA_CARD_STATUS);\n\t\t\tif((status&0x03)==DAYNA_RX_REQUEST)\n\t\t\t\tcops_rx(dev);\n\t\t\tnetif_wake_queue(dev);\n\t\t} while(++boguscount < 20);\n\t}\n\telse\n\t{\n\t\tdo {\n\t\t\tstatus=inb(ioaddr+TANG_CARD_STATUS);\n\t\t\tif(status & TANG_RX_READY)\n\t\t\t\tcops_rx(dev);\n\t\t\tif(status & TANG_TX_READY)\n\t\t\t\tnetif_wake_queue(dev);\n\t\t\tstatus=inb(ioaddr+TANG_CARD_STATUS);\n\t\t} while((++boguscount < 20) && (status&(TANG_RX_READY|TANG_TX_READY)));\n\t}\n\n        return IRQ_HANDLED;\n}\n\n \nstatic void cops_rx(struct net_device *dev)\n{\n        int pkt_len = 0;\n        int rsp_type = 0;\n        struct sk_buff *skb = NULL;\n        struct cops_local *lp = netdev_priv(dev);\n        int ioaddr = dev->base_addr;\n        int boguscount = 0;\n        unsigned long flags;\n\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\t\n        if(lp->board==DAYNA)\n        {\n                outb(0, ioaddr);                 \n                outb(0, ioaddr);\n                outb(DATA_READ, ioaddr);         \n\n                 \n                while(++boguscount<1000000)\n                {\n\t\t\tbarrier();\n                        if((inb(ioaddr+DAYNA_CARD_STATUS)&0x03)==DAYNA_RX_READY)\n                                break;\n                }\n\n                if(boguscount==1000000)\n                {\n                        printk(KERN_WARNING \"%s: DMA timed out.\\n\",dev->name);\n\t\t\tspin_unlock_irqrestore(&lp->lock, flags);\n                        return;\n                }\n        }\n\n         \n\tpkt_len = inb(ioaddr);\n        pkt_len |= (inb(ioaddr) << 8);\n         \n        rsp_type=inb(ioaddr);\n\n         \n        skb = dev_alloc_skb(pkt_len);\n        if(skb == NULL)\n        {\n                printk(KERN_WARNING \"%s: Memory squeeze, dropping packet.\\n\",\n\t\t\tdev->name);\n                dev->stats.rx_dropped++;\n                while(pkt_len--)         \n                        inb(ioaddr);\n                spin_unlock_irqrestore(&lp->lock, flags);\n                return;\n        }\n        skb->dev = dev;\n        skb_put(skb, pkt_len);\n        skb->protocol = htons(ETH_P_LOCALTALK);\n\n        insb(ioaddr, skb->data, pkt_len);                \n\n        if(lp->board==DAYNA)\n                outb(1, ioaddr+DAYNA_INT_CARD);          \n\n        spin_unlock_irqrestore(&lp->lock, flags);   \n\n         \n        if(pkt_len < 0 || pkt_len > MAX_LLAP_SIZE)\n        {\n\t\tprintk(KERN_WARNING \"%s: Bad packet length of %d bytes.\\n\", \n\t\t\tdev->name, pkt_len);\n                dev->stats.tx_errors++;\n                dev_kfree_skb_any(skb);\n                return;\n        }\n\n         \n        if(rsp_type == LAP_INIT_RSP)\n        {\t \n                lp->node_acquire = skb->data[0];\n                dev_kfree_skb_any(skb);\n                return;\n        }\n\n         \n        if(rsp_type != LAP_RESPONSE)\n        {\n                printk(KERN_WARNING \"%s: Bad packet type %d.\\n\", dev->name, rsp_type);\n                dev->stats.tx_errors++;\n                dev_kfree_skb_any(skb);\n                return;\n        }\n\n        skb_reset_mac_header(skb);     \n        skb_pull(skb,3);\n        skb_reset_transport_header(skb);     \n\n         \n        dev->stats.rx_packets++;\n        dev->stats.rx_bytes += skb->len;\n\n         \n        netif_rx(skb);\n}\n\nstatic void cops_timeout(struct net_device *dev, unsigned int txqueue)\n{\n        struct cops_local *lp = netdev_priv(dev);\n        int ioaddr = dev->base_addr;\n\n\tdev->stats.tx_errors++;\n        if(lp->board==TANGENT)\n        {\n\t\tif((inb(ioaddr+TANG_CARD_STATUS)&TANG_TX_READY)==0)\n\t\t\tprintk(KERN_WARNING \"%s: No TX complete interrupt.\\n\", dev->name);\n\t}\n\tprintk(KERN_WARNING \"%s: Transmit timed out.\\n\", dev->name);\n\tcops_jumpstart(dev);\t \n\tnetif_trans_update(dev);  \n\tnetif_wake_queue(dev);\n}\n\n\n \n\nstatic netdev_tx_t cops_send_packet(struct sk_buff *skb,\n\t\t\t\t\t  struct net_device *dev)\n{\n        struct cops_local *lp = netdev_priv(dev);\n        int ioaddr = dev->base_addr;\n        unsigned long flags;\n\n         \n\t \n\tnetif_stop_queue(dev);\n\n\tspin_lock_irqsave(&lp->lock, flags);\n\tif(lp->board == DAYNA)\t  \n\t\twhile((inb(ioaddr+DAYNA_CARD_STATUS)&DAYNA_TX_READY)==0)\n\t\t\tcpu_relax();\n\tif(lp->board == TANGENT)  \n\t\twhile((inb(ioaddr+TANG_CARD_STATUS)&TANG_TX_READY)==0)\n\t\t\tcpu_relax();\n\n\t \n\toutb(skb->len, ioaddr);\n\toutb(skb->len >> 8, ioaddr);\n\n\t \n\toutb(LAP_WRITE, ioaddr);\n\n\tif(lp->board == DAYNA)\t \n\t\twhile((inb(ioaddr+DAYNA_CARD_STATUS)&DAYNA_TX_READY)==0);\n\n\toutsb(ioaddr, skb->data, skb->len);\t \n\n\tif(lp->board==DAYNA)\t \n\t\toutb(1, ioaddr+DAYNA_INT_CARD);\n\n\tspin_unlock_irqrestore(&lp->lock, flags);\t \n\n\t \n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += skb->len;\n\tdev_kfree_skb (skb);\n\treturn NETDEV_TX_OK;\n}\n\n \n \nstatic void set_multicast_list(struct net_device *dev)\n{\n        if(cops_debug >= 3)\n\t\tprintk(\"%s: set_multicast_list executed\\n\", dev->name);\n}\n\n \n \nstatic int cops_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n        struct cops_local *lp = netdev_priv(dev);\n        struct sockaddr_at *sa = (struct sockaddr_at *)&ifr->ifr_addr;\n        struct atalk_addr *aa = &lp->node_addr;\n\n        switch(cmd)\n        {\n                case SIOCSIFADDR:\n\t\t\t \n\t\t\tcops_nodeid(dev, sa->sat_addr.s_node);\n\t\t\taa->s_net               = sa->sat_addr.s_net;\n                        aa->s_node              = lp->node_acquire;\n\n\t\t\t \n                        dev->broadcast[0]       = 0xFF;\n\t\t\t\n\t\t\t \n                        dev->addr_len           = 1;\n\t\t\tdev_addr_set(dev, &aa->s_node);\n                        return 0;\n\n                case SIOCGIFADDR:\n                        sa->sat_addr.s_net      = aa->s_net;\n                        sa->sat_addr.s_node     = aa->s_node;\n                        return 0;\n\n                default:\n                        return -EOPNOTSUPP;\n        }\n}\n\n \n \nstatic int cops_close(struct net_device *dev)\n{\n\tstruct cops_local *lp = netdev_priv(dev);\n\n\t \n\tif(lp->board==TANGENT && dev->irq==0)\n\t\tdel_timer(&cops_timer);\n\n\tnetif_stop_queue(dev);\n        return 0;\n}\n\n\n#ifdef MODULE\nstatic struct net_device *cops_dev;\n\nMODULE_LICENSE(\"GPL\");\nmodule_param_hw(io, int, ioport, 0);\nmodule_param_hw(irq, int, irq, 0);\nmodule_param_hw(board_type, int, other, 0);\n\nstatic int __init cops_module_init(void)\n{\n\tif (io == 0)\n\t\tprintk(KERN_WARNING \"%s: You shouldn't autoprobe with insmod\\n\",\n\t\t\tcardname);\n\tcops_dev = cops_probe(-1);\n\treturn PTR_ERR_OR_ZERO(cops_dev);\n}\n\nstatic void __exit cops_module_exit(void)\n{\n\tunregister_netdev(cops_dev);\n\tcleanup_card(cops_dev);\n\tfree_netdev(cops_dev);\n}\nmodule_init(cops_module_init);\nmodule_exit(cops_module_exit);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}