{
  "module_name": "ipddp.c",
  "hash_id": "0e24d39ff1d4405392c9d0aa99418f7ccaba25feeaa63f1f294266a3c7b0f62e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/appletalk/ipddp.c",
  "human_readable_source": " \n\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ip.h>\n#include <linux/atalk.h>\n#include <linux/if_arp.h>\n#include <linux/slab.h>\n#include <net/route.h>\n#include <linux/uaccess.h>\n\n#include \"ipddp.h\"\t\t \n\nstatic const char version[] = KERN_INFO \"ipddp.c:v0.01 8/28/97 Bradford W. Johnson <johns393@maroon.tc.umn.edu>\\n\";\n\nstatic struct ipddp_route *ipddp_route_list;\nstatic DEFINE_SPINLOCK(ipddp_route_lock);\n\n#ifdef CONFIG_IPDDP_ENCAP\nstatic int ipddp_mode = IPDDP_ENCAP;\n#else\nstatic int ipddp_mode = IPDDP_DECAP;\n#endif\n\n \nstatic netdev_tx_t ipddp_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *dev);\nstatic int ipddp_create(struct ipddp_route *new_rt);\nstatic int ipddp_delete(struct ipddp_route *rt);\nstatic struct ipddp_route* __ipddp_find_route(struct ipddp_route *rt);\nstatic int ipddp_siocdevprivate(struct net_device *dev, struct ifreq *ifr,\n\t\t\t\tvoid __user *data, int cmd);\n\nstatic const struct net_device_ops ipddp_netdev_ops = {\n\t.ndo_start_xmit\t\t= ipddp_xmit,\n\t.ndo_siocdevprivate\t= ipddp_siocdevprivate,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic struct net_device * __init ipddp_init(void)\n{\n\tstatic unsigned version_printed;\n\tstruct net_device *dev;\n\tint err;\n\n\tdev = alloc_etherdev(0);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnetif_keep_dst(dev);\n\tstrcpy(dev->name, \"ipddp%d\");\n\n\tif (version_printed++ == 0)\n                printk(version);\n\n\t \n\tdev->netdev_ops = &ipddp_netdev_ops;\n\n        dev->type = ARPHRD_IPDDP;       \t \n        dev->mtu = 585;\n        dev->flags |= IFF_NOARP;\n\n         \n        dev->hard_header_len = 14+8+sizeof(struct ddpehdr)+1;\n\n\terr = register_netdev(dev);\n\tif (err) {\n\t\tfree_netdev(dev);\n\t\treturn ERR_PTR(err);\n\t}\n\n\t \n\tif(ipddp_mode == IPDDP_ENCAP)\n\t\tprintk(\"%s: Appletalk-IP Encap. mode by Bradford W. Johnson <johns393@maroon.tc.umn.edu>\\n\", \n\t\t\tdev->name);\n\tif(ipddp_mode == IPDDP_DECAP)\n\t\tprintk(\"%s: Appletalk-IP Decap. mode by Jay Schulist <jschlst@samba.org>\\n\", \n\t\t\tdev->name);\n\n        return dev;\n}\n\n\n \nstatic netdev_tx_t ipddp_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n        struct rtable *rtable = skb_rtable(skb);\n        __be32 paddr = 0;\n        struct ddpehdr *ddp;\n        struct ipddp_route *rt;\n        struct atalk_addr *our_addr;\n\n\tif (rtable->rt_gw_family == AF_INET)\n\t\tpaddr = rtable->rt_gw4;\n\n\tspin_lock(&ipddp_route_lock);\n\n\t \n        for(rt = ipddp_route_list; rt != NULL; rt = rt->next)\n        {\n                if(rt->ip == paddr)\n                        break;\n        }\n        if(rt == NULL) {\n\t\tspin_unlock(&ipddp_route_lock);\n                return NETDEV_TX_OK;\n\t}\n\n        our_addr = atalk_find_dev_addr(rt->dev);\n\n\tif(ipddp_mode == IPDDP_DECAP)\n\t\t \n\t\tskb_pull(skb, 35-(sizeof(struct ddpehdr)+1));\n\n\t \n\tddp = (struct ddpehdr *)skb->data;\n        ddp->deh_len_hops = htons(skb->len + (1<<10));\n        ddp->deh_sum = 0;\n\n\t \n        if(rt->dev->type == ARPHRD_LOCALTLK)\n        {\n                ddp->deh_dnet  = 0;    \n                ddp->deh_snet  = 0;\n        }\n        else\n        {\n                ddp->deh_dnet  = rt->at.s_net;    \n                ddp->deh_snet  = our_addr->s_net;\n        }\n        ddp->deh_dnode = rt->at.s_node;\n        ddp->deh_snode = our_addr->s_node;\n        ddp->deh_dport = 72;\n        ddp->deh_sport = 72;\n\n        *((__u8 *)(ddp+1)) = 22;        \t \n\n        skb->protocol = htons(ETH_P_ATALK);      \n\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += skb->len;\n\n\taarp_send_ddp(rt->dev, skb, &rt->at, NULL);\n\n\tspin_unlock(&ipddp_route_lock);\n\n        return NETDEV_TX_OK;\n}\n\n \nstatic int ipddp_create(struct ipddp_route *new_rt)\n{\n        struct ipddp_route *rt = kzalloc(sizeof(*rt), GFP_KERNEL);\n\n        if (rt == NULL)\n                return -ENOMEM;\n\n        rt->ip = new_rt->ip;\n        rt->at = new_rt->at;\n        rt->next = NULL;\n        if ((rt->dev = atrtr_get_dev(&rt->at)) == NULL) {\n\t\tkfree(rt);\n                return -ENETUNREACH;\n        }\n\n\tspin_lock_bh(&ipddp_route_lock);\n\tif (__ipddp_find_route(rt)) {\n\t\tspin_unlock_bh(&ipddp_route_lock);\n\t\tkfree(rt);\n\t\treturn -EEXIST;\n\t}\n\n        rt->next = ipddp_route_list;\n        ipddp_route_list = rt;\n\n\tspin_unlock_bh(&ipddp_route_lock);\n\n        return 0;\n}\n\n \nstatic int ipddp_delete(struct ipddp_route *rt)\n{\n        struct ipddp_route **r = &ipddp_route_list;\n        struct ipddp_route *tmp;\n\n\tspin_lock_bh(&ipddp_route_lock);\n        while((tmp = *r) != NULL)\n        {\n                if(tmp->ip == rt->ip &&\n\t\t   tmp->at.s_net == rt->at.s_net &&\n\t\t   tmp->at.s_node == rt->at.s_node)\n                {\n                        *r = tmp->next;\n\t\t\tspin_unlock_bh(&ipddp_route_lock);\n                        kfree(tmp);\n                        return 0;\n                }\n                r = &tmp->next;\n        }\n\n\tspin_unlock_bh(&ipddp_route_lock);\n        return -ENOENT;\n}\n\n \nstatic struct ipddp_route* __ipddp_find_route(struct ipddp_route *rt)\n{\n        struct ipddp_route *f;\n\n        for(f = ipddp_route_list; f != NULL; f = f->next)\n        {\n                if(f->ip == rt->ip &&\n\t\t   f->at.s_net == rt->at.s_net &&\n\t\t   f->at.s_node == rt->at.s_node)\n                        return f;\n        }\n\n        return NULL;\n}\n\nstatic int ipddp_siocdevprivate(struct net_device *dev, struct ifreq *ifr,\n\t\t\t\tvoid __user *data, int cmd)\n{\n        struct ipddp_route rcp, rcp2, *rp;\n\n\tif (in_compat_syscall())\n\t\treturn -EOPNOTSUPP;\n\n        if(!capable(CAP_NET_ADMIN))\n                return -EPERM;\n\n\tif (copy_from_user(&rcp, data, sizeof(rcp)))\n\t\treturn -EFAULT;\n\n        switch(cmd)\n        {\n\t\tcase SIOCADDIPDDPRT:\n                        return ipddp_create(&rcp);\n\n                case SIOCFINDIPDDPRT:\n\t\t\tspin_lock_bh(&ipddp_route_lock);\n\t\t\trp = __ipddp_find_route(&rcp);\n\t\t\tif (rp) {\n\t\t\t\tmemset(&rcp2, 0, sizeof(rcp2));\n\t\t\t\trcp2.ip    = rp->ip;\n\t\t\t\trcp2.at    = rp->at;\n\t\t\t\trcp2.flags = rp->flags;\n\t\t\t}\n\t\t\tspin_unlock_bh(&ipddp_route_lock);\n\n\t\t\tif (rp) {\n\t\t\t\tif (copy_to_user(data, &rcp2,\n\t\t\t\t\t\t sizeof(struct ipddp_route)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -ENOENT;\n\n                case SIOCDELIPDDPRT:\n                        return ipddp_delete(&rcp);\n\n                default:\n                        return -EINVAL;\n        }\n}\n\nstatic struct net_device *dev_ipddp;\n\nMODULE_LICENSE(\"GPL\");\nmodule_param(ipddp_mode, int, 0);\n\nstatic int __init ipddp_init_module(void)\n{\n\tdev_ipddp = ipddp_init();\n\treturn PTR_ERR_OR_ZERO(dev_ipddp);\n}\n\nstatic void __exit ipddp_cleanup_module(void)\n{\n        struct ipddp_route *p;\n\n\tunregister_netdev(dev_ipddp);\n        free_netdev(dev_ipddp);\n\n        while (ipddp_route_list) {\n                p = ipddp_route_list->next;\n                kfree(ipddp_route_list);\n                ipddp_route_list = p;\n        }\n}\n\nmodule_init(ipddp_init_module);\nmodule_exit(ipddp_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}