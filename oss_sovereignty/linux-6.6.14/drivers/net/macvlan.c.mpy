{
  "module_name": "macvlan.c",
  "hash_id": "f23c6f6ec26f404e783a1ef9d94981f5b76dbf091e742420c83f4090293b1752",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/macvlan.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/rculist.h>\n#include <linux/notifier.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/net_tstamp.h>\n#include <linux/ethtool.h>\n#include <linux/if_arp.h>\n#include <linux/if_vlan.h>\n#include <linux/if_link.h>\n#include <linux/if_macvlan.h>\n#include <linux/hash.h>\n#include <linux/workqueue.h>\n#include <net/rtnetlink.h>\n#include <net/xfrm.h>\n#include <linux/netpoll.h>\n#include <linux/phy.h>\n\n#define MACVLAN_HASH_BITS\t8\n#define MACVLAN_HASH_SIZE\t(1<<MACVLAN_HASH_BITS)\n#define MACVLAN_DEFAULT_BC_QUEUE_LEN\t1000\n\n#define MACVLAN_F_PASSTHRU\t1\n#define MACVLAN_F_ADDRCHANGE\t2\n\nstruct macvlan_port {\n\tstruct net_device\t*dev;\n\tstruct hlist_head\tvlan_hash[MACVLAN_HASH_SIZE];\n\tstruct list_head\tvlans;\n\tstruct sk_buff_head\tbc_queue;\n\tstruct work_struct\tbc_work;\n\tu32\t\t\tbc_queue_len_used;\n\tint\t\t\tbc_cutoff;\n\tu32\t\t\tflags;\n\tint\t\t\tcount;\n\tstruct hlist_head\tvlan_source_hash[MACVLAN_HASH_SIZE];\n\tDECLARE_BITMAP(bc_filter, MACVLAN_MC_FILTER_SZ);\n\tDECLARE_BITMAP(mc_filter, MACVLAN_MC_FILTER_SZ);\n\tunsigned char           perm_addr[ETH_ALEN];\n};\n\nstruct macvlan_source_entry {\n\tstruct hlist_node\thlist;\n\tstruct macvlan_dev\t*vlan;\n\tunsigned char\t\taddr[6+2] __aligned(sizeof(u16));\n\tstruct rcu_head\t\trcu;\n};\n\nstruct macvlan_skb_cb {\n\tconst struct macvlan_dev *src;\n};\n\n#define MACVLAN_SKB_CB(__skb) ((struct macvlan_skb_cb *)&((__skb)->cb[0]))\n\nstatic void macvlan_port_destroy(struct net_device *dev);\nstatic void update_port_bc_queue_len(struct macvlan_port *port);\n\nstatic inline bool macvlan_passthru(const struct macvlan_port *port)\n{\n\treturn port->flags & MACVLAN_F_PASSTHRU;\n}\n\nstatic inline void macvlan_set_passthru(struct macvlan_port *port)\n{\n\tport->flags |= MACVLAN_F_PASSTHRU;\n}\n\nstatic inline bool macvlan_addr_change(const struct macvlan_port *port)\n{\n\treturn port->flags & MACVLAN_F_ADDRCHANGE;\n}\n\nstatic inline void macvlan_set_addr_change(struct macvlan_port *port)\n{\n\tport->flags |= MACVLAN_F_ADDRCHANGE;\n}\n\nstatic inline void macvlan_clear_addr_change(struct macvlan_port *port)\n{\n\tport->flags &= ~MACVLAN_F_ADDRCHANGE;\n}\n\n \nstatic u32 macvlan_eth_hash(const unsigned char *addr)\n{\n\tu64 value = get_unaligned((u64 *)addr);\n\n\t \n#ifdef __BIG_ENDIAN\n\tvalue >>= 16;\n#else\n\tvalue <<= 16;\n#endif\n\treturn hash_64(value, MACVLAN_HASH_BITS);\n}\n\nstatic struct macvlan_port *macvlan_port_get_rcu(const struct net_device *dev)\n{\n\treturn rcu_dereference(dev->rx_handler_data);\n}\n\nstatic struct macvlan_port *macvlan_port_get_rtnl(const struct net_device *dev)\n{\n\treturn rtnl_dereference(dev->rx_handler_data);\n}\n\nstatic struct macvlan_dev *macvlan_hash_lookup(const struct macvlan_port *port,\n\t\t\t\t\t       const unsigned char *addr)\n{\n\tstruct macvlan_dev *vlan;\n\tu32 idx = macvlan_eth_hash(addr);\n\n\thlist_for_each_entry_rcu(vlan, &port->vlan_hash[idx], hlist,\n\t\t\t\t lockdep_rtnl_is_held()) {\n\t\tif (ether_addr_equal_64bits(vlan->dev->dev_addr, addr))\n\t\t\treturn vlan;\n\t}\n\treturn NULL;\n}\n\nstatic struct macvlan_source_entry *macvlan_hash_lookup_source(\n\tconst struct macvlan_dev *vlan,\n\tconst unsigned char *addr)\n{\n\tstruct macvlan_source_entry *entry;\n\tu32 idx = macvlan_eth_hash(addr);\n\tstruct hlist_head *h = &vlan->port->vlan_source_hash[idx];\n\n\thlist_for_each_entry_rcu(entry, h, hlist, lockdep_rtnl_is_held()) {\n\t\tif (ether_addr_equal_64bits(entry->addr, addr) &&\n\t\t    entry->vlan == vlan)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}\n\nstatic int macvlan_hash_add_source(struct macvlan_dev *vlan,\n\t\t\t\t   const unsigned char *addr)\n{\n\tstruct macvlan_port *port = vlan->port;\n\tstruct macvlan_source_entry *entry;\n\tstruct hlist_head *h;\n\n\tentry = macvlan_hash_lookup_source(vlan, addr);\n\tif (entry)\n\t\treturn 0;\n\n\tentry = kmalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tether_addr_copy(entry->addr, addr);\n\tentry->vlan = vlan;\n\th = &port->vlan_source_hash[macvlan_eth_hash(addr)];\n\thlist_add_head_rcu(&entry->hlist, h);\n\tvlan->macaddr_count++;\n\n\treturn 0;\n}\n\nstatic void macvlan_hash_add(struct macvlan_dev *vlan)\n{\n\tstruct macvlan_port *port = vlan->port;\n\tconst unsigned char *addr = vlan->dev->dev_addr;\n\tu32 idx = macvlan_eth_hash(addr);\n\n\thlist_add_head_rcu(&vlan->hlist, &port->vlan_hash[idx]);\n}\n\nstatic void macvlan_hash_del_source(struct macvlan_source_entry *entry)\n{\n\thlist_del_rcu(&entry->hlist);\n\tkfree_rcu(entry, rcu);\n}\n\nstatic void macvlan_hash_del(struct macvlan_dev *vlan, bool sync)\n{\n\thlist_del_rcu(&vlan->hlist);\n\tif (sync)\n\t\tsynchronize_rcu();\n}\n\nstatic void macvlan_hash_change_addr(struct macvlan_dev *vlan,\n\t\t\t\t\tconst unsigned char *addr)\n{\n\tmacvlan_hash_del(vlan, true);\n\t \n\teth_hw_addr_set(vlan->dev, addr);\n\tmacvlan_hash_add(vlan);\n}\n\nstatic bool macvlan_addr_busy(const struct macvlan_port *port,\n\t\t\t      const unsigned char *addr)\n{\n\t \n\tif (!macvlan_passthru(port) && !macvlan_addr_change(port) &&\n\t    ether_addr_equal_64bits(port->dev->dev_addr, addr))\n\t\treturn true;\n\n\tif (macvlan_hash_lookup(port, addr))\n\t\treturn true;\n\n\treturn false;\n}\n\n\nstatic int macvlan_broadcast_one(struct sk_buff *skb,\n\t\t\t\t const struct macvlan_dev *vlan,\n\t\t\t\t const struct ethhdr *eth, bool local)\n{\n\tstruct net_device *dev = vlan->dev;\n\n\tif (local)\n\t\treturn __dev_forward_skb(dev, skb);\n\n\tskb->dev = dev;\n\tif (ether_addr_equal_64bits(eth->h_dest, dev->broadcast))\n\t\tskb->pkt_type = PACKET_BROADCAST;\n\telse\n\t\tskb->pkt_type = PACKET_MULTICAST;\n\n\treturn 0;\n}\n\nstatic u32 macvlan_hash_mix(const struct macvlan_dev *vlan)\n{\n\treturn (u32)(((unsigned long)vlan) >> L1_CACHE_SHIFT);\n}\n\n\nstatic unsigned int mc_hash(const struct macvlan_dev *vlan,\n\t\t\t    const unsigned char *addr)\n{\n\tu32 val = __get_unaligned_cpu32(addr + 2);\n\n\tval ^= macvlan_hash_mix(vlan);\n\treturn hash_32(val, MACVLAN_MC_FILTER_BITS);\n}\n\nstatic void macvlan_broadcast(struct sk_buff *skb,\n\t\t\t      const struct macvlan_port *port,\n\t\t\t      struct net_device *src,\n\t\t\t      enum macvlan_mode mode)\n{\n\tconst struct ethhdr *eth = eth_hdr(skb);\n\tconst struct macvlan_dev *vlan;\n\tstruct sk_buff *nskb;\n\tunsigned int i;\n\tint err;\n\tunsigned int hash;\n\n\tif (skb->protocol == htons(ETH_P_PAUSE))\n\t\treturn;\n\n\thash_for_each_rcu(port->vlan_hash, i, vlan, hlist) {\n\t\tif (vlan->dev == src || !(vlan->mode & mode))\n\t\t\tcontinue;\n\n\t\thash = mc_hash(vlan, eth->h_dest);\n\t\tif (!test_bit(hash, vlan->mc_filter))\n\t\t\tcontinue;\n\n\t\terr = NET_RX_DROP;\n\t\tnskb = skb_clone(skb, GFP_ATOMIC);\n\t\tif (likely(nskb))\n\t\t\terr = macvlan_broadcast_one(nskb, vlan, eth,\n\t\t\t\t\tmode == MACVLAN_MODE_BRIDGE) ?:\n\t\t\t      netif_rx(nskb);\n\t\tmacvlan_count_rx(vlan, skb->len + ETH_HLEN,\n\t\t\t\t err == NET_RX_SUCCESS, true);\n\t}\n}\n\nstatic void macvlan_multicast_rx(const struct macvlan_port *port,\n\t\t\t\t const struct macvlan_dev *src,\n\t\t\t\t struct sk_buff *skb)\n{\n\tif (!src)\n\t\t \n\t\tmacvlan_broadcast(skb, port, NULL,\n\t\t\t\t  MACVLAN_MODE_PRIVATE |\n\t\t\t\t  MACVLAN_MODE_VEPA    |\n\t\t\t\t  MACVLAN_MODE_PASSTHRU|\n\t\t\t\t  MACVLAN_MODE_BRIDGE);\n\telse if (src->mode == MACVLAN_MODE_VEPA)\n\t\t \n\t\tmacvlan_broadcast(skb, port, src->dev,\n\t\t\t\t  MACVLAN_MODE_VEPA |\n\t\t\t\t  MACVLAN_MODE_BRIDGE);\n\telse\n\t\t \n\t\tmacvlan_broadcast(skb, port, src->dev,\n\t\t\t\t  MACVLAN_MODE_VEPA);\n}\n\nstatic void macvlan_process_broadcast(struct work_struct *w)\n{\n\tstruct macvlan_port *port = container_of(w, struct macvlan_port,\n\t\t\t\t\t\t bc_work);\n\tstruct sk_buff *skb;\n\tstruct sk_buff_head list;\n\n\t__skb_queue_head_init(&list);\n\n\tspin_lock_bh(&port->bc_queue.lock);\n\tskb_queue_splice_tail_init(&port->bc_queue, &list);\n\tspin_unlock_bh(&port->bc_queue.lock);\n\n\twhile ((skb = __skb_dequeue(&list))) {\n\t\tconst struct macvlan_dev *src = MACVLAN_SKB_CB(skb)->src;\n\n\t\trcu_read_lock();\n\t\tmacvlan_multicast_rx(port, src, skb);\n\t\trcu_read_unlock();\n\n\t\tif (src)\n\t\t\tdev_put(src->dev);\n\t\tconsume_skb(skb);\n\n\t\tcond_resched();\n\t}\n}\n\nstatic void macvlan_broadcast_enqueue(struct macvlan_port *port,\n\t\t\t\t      const struct macvlan_dev *src,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct sk_buff *nskb;\n\tint err = -ENOMEM;\n\n\tnskb = skb_clone(skb, GFP_ATOMIC);\n\tif (!nskb)\n\t\tgoto err;\n\n\tMACVLAN_SKB_CB(nskb)->src = src;\n\n\tspin_lock(&port->bc_queue.lock);\n\tif (skb_queue_len(&port->bc_queue) < port->bc_queue_len_used) {\n\t\tif (src)\n\t\t\tdev_hold(src->dev);\n\t\t__skb_queue_tail(&port->bc_queue, nskb);\n\t\terr = 0;\n\t}\n\tspin_unlock(&port->bc_queue.lock);\n\n\tqueue_work(system_unbound_wq, &port->bc_work);\n\n\tif (err)\n\t\tgoto free_nskb;\n\n\treturn;\n\nfree_nskb:\n\tkfree_skb(nskb);\nerr:\n\tdev_core_stats_rx_dropped_inc(skb->dev);\n}\n\nstatic void macvlan_flush_sources(struct macvlan_port *port,\n\t\t\t\t  struct macvlan_dev *vlan)\n{\n\tstruct macvlan_source_entry *entry;\n\tstruct hlist_node *next;\n\tint i;\n\n\thash_for_each_safe(port->vlan_source_hash, i, next, entry, hlist)\n\t\tif (entry->vlan == vlan)\n\t\t\tmacvlan_hash_del_source(entry);\n\n\tvlan->macaddr_count = 0;\n}\n\nstatic void macvlan_forward_source_one(struct sk_buff *skb,\n\t\t\t\t       struct macvlan_dev *vlan)\n{\n\tstruct sk_buff *nskb;\n\tstruct net_device *dev;\n\tint len;\n\tint ret;\n\n\tdev = vlan->dev;\n\tif (unlikely(!(dev->flags & IFF_UP)))\n\t\treturn;\n\n\tnskb = skb_clone(skb, GFP_ATOMIC);\n\tif (!nskb)\n\t\treturn;\n\n\tlen = nskb->len + ETH_HLEN;\n\tnskb->dev = dev;\n\n\tif (ether_addr_equal_64bits(eth_hdr(skb)->h_dest, dev->dev_addr))\n\t\tnskb->pkt_type = PACKET_HOST;\n\n\tret = __netif_rx(nskb);\n\tmacvlan_count_rx(vlan, len, ret == NET_RX_SUCCESS, false);\n}\n\nstatic bool macvlan_forward_source(struct sk_buff *skb,\n\t\t\t\t   struct macvlan_port *port,\n\t\t\t\t   const unsigned char *addr)\n{\n\tstruct macvlan_source_entry *entry;\n\tu32 idx = macvlan_eth_hash(addr);\n\tstruct hlist_head *h = &port->vlan_source_hash[idx];\n\tbool consume = false;\n\n\thlist_for_each_entry_rcu(entry, h, hlist) {\n\t\tif (ether_addr_equal_64bits(entry->addr, addr)) {\n\t\t\tif (entry->vlan->flags & MACVLAN_FLAG_NODST)\n\t\t\t\tconsume = true;\n\t\t\tmacvlan_forward_source_one(skb, entry->vlan);\n\t\t}\n\t}\n\n\treturn consume;\n}\n\n \nstatic rx_handler_result_t macvlan_handle_frame(struct sk_buff **pskb)\n{\n\tstruct macvlan_port *port;\n\tstruct sk_buff *skb = *pskb;\n\tconst struct ethhdr *eth = eth_hdr(skb);\n\tconst struct macvlan_dev *vlan;\n\tconst struct macvlan_dev *src;\n\tstruct net_device *dev;\n\tunsigned int len = 0;\n\tint ret;\n\trx_handler_result_t handle_res;\n\n\t \n\tif (unlikely(skb->pkt_type == PACKET_LOOPBACK))\n\t\treturn RX_HANDLER_PASS;\n\n\tport = macvlan_port_get_rcu(skb->dev);\n\tif (is_multicast_ether_addr(eth->h_dest)) {\n\t\tunsigned int hash;\n\n\t\tskb = ip_check_defrag(dev_net(skb->dev), skb, IP_DEFRAG_MACVLAN);\n\t\tif (!skb)\n\t\t\treturn RX_HANDLER_CONSUMED;\n\t\t*pskb = skb;\n\t\teth = eth_hdr(skb);\n\t\tif (macvlan_forward_source(skb, port, eth->h_source)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn RX_HANDLER_CONSUMED;\n\t\t}\n\t\tsrc = macvlan_hash_lookup(port, eth->h_source);\n\t\tif (src && src->mode != MACVLAN_MODE_VEPA &&\n\t\t    src->mode != MACVLAN_MODE_BRIDGE) {\n\t\t\t \n\t\t\tvlan = src;\n\t\t\tret = macvlan_broadcast_one(skb, vlan, eth, 0) ?:\n\t\t\t      __netif_rx(skb);\n\t\t\thandle_res = RX_HANDLER_CONSUMED;\n\t\t\tgoto out;\n\t\t}\n\n\t\thash = mc_hash(NULL, eth->h_dest);\n\t\tif (test_bit(hash, port->bc_filter))\n\t\t\tmacvlan_broadcast_enqueue(port, src, skb);\n\t\telse if (test_bit(hash, port->mc_filter))\n\t\t\tmacvlan_multicast_rx(port, src, skb);\n\n\t\treturn RX_HANDLER_PASS;\n\t}\n\n\tif (macvlan_forward_source(skb, port, eth->h_source)) {\n\t\tkfree_skb(skb);\n\t\treturn RX_HANDLER_CONSUMED;\n\t}\n\tif (macvlan_passthru(port))\n\t\tvlan = list_first_or_null_rcu(&port->vlans,\n\t\t\t\t\t      struct macvlan_dev, list);\n\telse\n\t\tvlan = macvlan_hash_lookup(port, eth->h_dest);\n\tif (!vlan || vlan->mode == MACVLAN_MODE_SOURCE)\n\t\treturn RX_HANDLER_PASS;\n\n\tdev = vlan->dev;\n\tif (unlikely(!(dev->flags & IFF_UP))) {\n\t\tkfree_skb(skb);\n\t\treturn RX_HANDLER_CONSUMED;\n\t}\n\tlen = skb->len + ETH_HLEN;\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb) {\n\t\tret = NET_RX_DROP;\n\t\thandle_res = RX_HANDLER_CONSUMED;\n\t\tgoto out;\n\t}\n\n\t*pskb = skb;\n\tskb->dev = dev;\n\tskb->pkt_type = PACKET_HOST;\n\n\tret = NET_RX_SUCCESS;\n\thandle_res = RX_HANDLER_ANOTHER;\nout:\n\tmacvlan_count_rx(vlan, len, ret == NET_RX_SUCCESS, false);\n\treturn handle_res;\n}\n\nstatic int macvlan_queue_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tconst struct macvlan_dev *vlan = netdev_priv(dev);\n\tconst struct macvlan_port *port = vlan->port;\n\tconst struct macvlan_dev *dest;\n\n\tif (vlan->mode == MACVLAN_MODE_BRIDGE) {\n\t\tconst struct ethhdr *eth = skb_eth_hdr(skb);\n\n\t\t \n\t\tif (is_multicast_ether_addr(eth->h_dest)) {\n\t\t\tskb_reset_mac_header(skb);\n\t\t\tmacvlan_broadcast(skb, port, dev, MACVLAN_MODE_BRIDGE);\n\t\t\tgoto xmit_world;\n\t\t}\n\n\t\tdest = macvlan_hash_lookup(port, eth->h_dest);\n\t\tif (dest && dest->mode == MACVLAN_MODE_BRIDGE) {\n\t\t\t \n\t\t\tdev_forward_skb(vlan->lowerdev, skb);\n\n\t\t\treturn NET_XMIT_SUCCESS;\n\t\t}\n\t}\nxmit_world:\n\tskb->dev = vlan->lowerdev;\n\treturn dev_queue_xmit_accel(skb,\n\t\t\t\t    netdev_get_sb_channel(dev) ? dev : NULL);\n}\n\nstatic inline netdev_tx_t macvlan_netpoll_send_skb(struct macvlan_dev *vlan, struct sk_buff *skb)\n{\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\treturn netpoll_send_skb(vlan->netpoll, skb);\n#else\n\tBUG();\n\treturn NETDEV_TX_OK;\n#endif\n}\n\nstatic netdev_tx_t macvlan_start_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *dev)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tunsigned int len = skb->len;\n\tint ret;\n\n\tif (unlikely(netpoll_tx_running(dev)))\n\t\treturn macvlan_netpoll_send_skb(vlan, skb);\n\n\tret = macvlan_queue_xmit(skb, dev);\n\n\tif (likely(ret == NET_XMIT_SUCCESS || ret == NET_XMIT_CN)) {\n\t\tstruct vlan_pcpu_stats *pcpu_stats;\n\n\t\tpcpu_stats = this_cpu_ptr(vlan->pcpu_stats);\n\t\tu64_stats_update_begin(&pcpu_stats->syncp);\n\t\tu64_stats_inc(&pcpu_stats->tx_packets);\n\t\tu64_stats_add(&pcpu_stats->tx_bytes, len);\n\t\tu64_stats_update_end(&pcpu_stats->syncp);\n\t} else {\n\t\tthis_cpu_inc(vlan->pcpu_stats->tx_dropped);\n\t}\n\treturn ret;\n}\n\nstatic int macvlan_hard_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\t       unsigned short type, const void *daddr,\n\t\t\t       const void *saddr, unsigned len)\n{\n\tconst struct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct net_device *lowerdev = vlan->lowerdev;\n\n\treturn dev_hard_header(skb, lowerdev, type, daddr,\n\t\t\t       saddr ? : dev->dev_addr, len);\n}\n\nstatic const struct header_ops macvlan_hard_header_ops = {\n\t.create  \t= macvlan_hard_header,\n\t.parse\t\t= eth_header_parse,\n\t.cache\t\t= eth_header_cache,\n\t.cache_update\t= eth_header_cache_update,\n};\n\nstatic int macvlan_open(struct net_device *dev)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct net_device *lowerdev = vlan->lowerdev;\n\tint err;\n\n\tif (macvlan_passthru(vlan->port)) {\n\t\tif (!(vlan->flags & MACVLAN_FLAG_NOPROMISC)) {\n\t\t\terr = dev_set_promiscuity(lowerdev, 1);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t\tgoto hash_add;\n\t}\n\n\terr = -EADDRINUSE;\n\tif (macvlan_addr_busy(vlan->port, dev->dev_addr))\n\t\tgoto out;\n\n\t \n\tif (lowerdev->features & NETIF_F_HW_L2FW_DOFFLOAD)\n\t\tvlan->accel_priv =\n\t\t      lowerdev->netdev_ops->ndo_dfwd_add_station(lowerdev, dev);\n\n\t \n\tif (IS_ERR_OR_NULL(vlan->accel_priv)) {\n\t\tvlan->accel_priv = NULL;\n\t\terr = dev_uc_add(lowerdev, dev->dev_addr);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (dev->flags & IFF_ALLMULTI) {\n\t\terr = dev_set_allmulti(lowerdev, 1);\n\t\tif (err < 0)\n\t\t\tgoto del_unicast;\n\t}\n\n\tif (dev->flags & IFF_PROMISC) {\n\t\terr = dev_set_promiscuity(lowerdev, 1);\n\t\tif (err < 0)\n\t\t\tgoto clear_multi;\n\t}\n\nhash_add:\n\tmacvlan_hash_add(vlan);\n\treturn 0;\n\nclear_multi:\n\tif (dev->flags & IFF_ALLMULTI)\n\t\tdev_set_allmulti(lowerdev, -1);\ndel_unicast:\n\tif (vlan->accel_priv) {\n\t\tlowerdev->netdev_ops->ndo_dfwd_del_station(lowerdev,\n\t\t\t\t\t\t\t   vlan->accel_priv);\n\t\tvlan->accel_priv = NULL;\n\t} else {\n\t\tdev_uc_del(lowerdev, dev->dev_addr);\n\t}\nout:\n\treturn err;\n}\n\nstatic int macvlan_stop(struct net_device *dev)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct net_device *lowerdev = vlan->lowerdev;\n\n\tif (vlan->accel_priv) {\n\t\tlowerdev->netdev_ops->ndo_dfwd_del_station(lowerdev,\n\t\t\t\t\t\t\t   vlan->accel_priv);\n\t\tvlan->accel_priv = NULL;\n\t}\n\n\tdev_uc_unsync(lowerdev, dev);\n\tdev_mc_unsync(lowerdev, dev);\n\n\tif (macvlan_passthru(vlan->port)) {\n\t\tif (!(vlan->flags & MACVLAN_FLAG_NOPROMISC))\n\t\t\tdev_set_promiscuity(lowerdev, -1);\n\t\tgoto hash_del;\n\t}\n\n\tif (dev->flags & IFF_ALLMULTI)\n\t\tdev_set_allmulti(lowerdev, -1);\n\n\tif (dev->flags & IFF_PROMISC)\n\t\tdev_set_promiscuity(lowerdev, -1);\n\n\tdev_uc_del(lowerdev, dev->dev_addr);\n\nhash_del:\n\tmacvlan_hash_del(vlan, !dev->dismantle);\n\treturn 0;\n}\n\nstatic int macvlan_sync_address(struct net_device *dev,\n\t\t\t\tconst unsigned char *addr)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct net_device *lowerdev = vlan->lowerdev;\n\tstruct macvlan_port *port = vlan->port;\n\tint err;\n\n\tif (!(dev->flags & IFF_UP)) {\n\t\t \n\t\teth_hw_addr_set(dev, addr);\n\t} else {\n\t\t \n\t\tif (macvlan_addr_busy(vlan->port, addr))\n\t\t\treturn -EADDRINUSE;\n\n\t\tif (!macvlan_passthru(port)) {\n\t\t\terr = dev_uc_add(lowerdev, addr);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tdev_uc_del(lowerdev, dev->dev_addr);\n\t\t}\n\n\t\tmacvlan_hash_change_addr(vlan, addr);\n\t}\n\tif (macvlan_passthru(port) && !macvlan_addr_change(port)) {\n\t\t \n\t\tether_addr_copy(vlan->port->perm_addr,\n\t\t\t\tlowerdev->dev_addr);\n\t}\n\tmacvlan_clear_addr_change(port);\n\treturn 0;\n}\n\nstatic int macvlan_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct sockaddr *addr = p;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\t \n\tif (ether_addr_equal(dev->dev_addr, addr->sa_data))\n\t\treturn 0;\n\n\tif (vlan->mode == MACVLAN_MODE_PASSTHRU) {\n\t\tmacvlan_set_addr_change(vlan->port);\n\t\treturn dev_set_mac_address(vlan->lowerdev, addr, NULL);\n\t}\n\n\tif (macvlan_addr_busy(vlan->port, addr->sa_data))\n\t\treturn -EADDRINUSE;\n\n\treturn macvlan_sync_address(dev, addr->sa_data);\n}\n\nstatic void macvlan_change_rx_flags(struct net_device *dev, int change)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct net_device *lowerdev = vlan->lowerdev;\n\n\tif (dev->flags & IFF_UP) {\n\t\tif (change & IFF_ALLMULTI)\n\t\t\tdev_set_allmulti(lowerdev, dev->flags & IFF_ALLMULTI ? 1 : -1);\n\t\tif (!macvlan_passthru(vlan->port) && change & IFF_PROMISC)\n\t\t\tdev_set_promiscuity(lowerdev,\n\t\t\t\t\t    dev->flags & IFF_PROMISC ? 1 : -1);\n\n\t}\n}\n\nstatic void macvlan_compute_filter(unsigned long *mc_filter,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   struct macvlan_dev *vlan, int cutoff)\n{\n\tif (dev->flags & (IFF_PROMISC | IFF_ALLMULTI)) {\n\t\tbitmap_fill(mc_filter, MACVLAN_MC_FILTER_SZ);\n\t} else {\n\t\tDECLARE_BITMAP(filter, MACVLAN_MC_FILTER_SZ);\n\t\tstruct netdev_hw_addr *ha;\n\n\t\tbitmap_zero(filter, MACVLAN_MC_FILTER_SZ);\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tif (!vlan && ha->synced <= cutoff)\n\t\t\t\tcontinue;\n\n\t\t\t__set_bit(mc_hash(vlan, ha->addr), filter);\n\t\t}\n\n\t\t__set_bit(mc_hash(vlan, dev->broadcast), filter);\n\n\t\tbitmap_copy(mc_filter, filter, MACVLAN_MC_FILTER_SZ);\n\t}\n}\n\nstatic void macvlan_recompute_bc_filter(struct macvlan_dev *vlan)\n{\n\tif (vlan->port->bc_cutoff < 0) {\n\t\tbitmap_zero(vlan->port->bc_filter, MACVLAN_MC_FILTER_SZ);\n\t\treturn;\n\t}\n\n\tmacvlan_compute_filter(vlan->port->bc_filter, vlan->lowerdev, NULL,\n\t\t\t       vlan->port->bc_cutoff);\n}\n\nstatic void macvlan_set_mac_lists(struct net_device *dev)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\n\tmacvlan_compute_filter(vlan->mc_filter, dev, vlan, 0);\n\n\tdev_uc_sync(vlan->lowerdev, dev);\n\tdev_mc_sync(vlan->lowerdev, dev);\n\n\t \n\tmacvlan_compute_filter(vlan->port->mc_filter, vlan->lowerdev, NULL,\n\t\t\t       0);\n\tmacvlan_recompute_bc_filter(vlan);\n}\n\nstatic void update_port_bc_cutoff(struct macvlan_dev *vlan, int cutoff)\n{\n\tif (vlan->port->bc_cutoff == cutoff)\n\t\treturn;\n\n\tvlan->port->bc_cutoff = cutoff;\n\tmacvlan_recompute_bc_filter(vlan);\n}\n\nstatic int macvlan_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\n\tif (vlan->lowerdev->mtu < new_mtu)\n\t\treturn -EINVAL;\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\nstatic int macvlan_hwtstamp_get(struct net_device *dev,\n\t\t\t\tstruct kernel_hwtstamp_config *cfg)\n{\n\tstruct net_device *real_dev = macvlan_dev_real_dev(dev);\n\n\treturn generic_hwtstamp_get_lower(real_dev, cfg);\n}\n\nstatic int macvlan_hwtstamp_set(struct net_device *dev,\n\t\t\t\tstruct kernel_hwtstamp_config *cfg,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net_device *real_dev = macvlan_dev_real_dev(dev);\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\treturn -EOPNOTSUPP;\n\n\treturn generic_hwtstamp_set_lower(real_dev, cfg, extack);\n}\n\n \nstatic struct lock_class_key macvlan_netdev_addr_lock_key;\n\n#define ALWAYS_ON_OFFLOADS \\\n\t(NETIF_F_SG | NETIF_F_HW_CSUM | NETIF_F_GSO_SOFTWARE | \\\n\t NETIF_F_GSO_ROBUST | NETIF_F_GSO_ENCAP_ALL)\n\n#define ALWAYS_ON_FEATURES (ALWAYS_ON_OFFLOADS | NETIF_F_LLTX)\n\n#define MACVLAN_FEATURES \\\n\t(NETIF_F_SG | NETIF_F_HW_CSUM | NETIF_F_HIGHDMA | NETIF_F_FRAGLIST | \\\n\t NETIF_F_GSO | NETIF_F_TSO | NETIF_F_LRO | \\\n\t NETIF_F_TSO_ECN | NETIF_F_TSO6 | NETIF_F_GRO | NETIF_F_RXCSUM | \\\n\t NETIF_F_HW_VLAN_CTAG_FILTER | NETIF_F_HW_VLAN_STAG_FILTER)\n\n#define MACVLAN_STATE_MASK \\\n\t((1<<__LINK_STATE_NOCARRIER) | (1<<__LINK_STATE_DORMANT))\n\nstatic void macvlan_set_lockdep_class(struct net_device *dev)\n{\n\tnetdev_lockdep_set_classes(dev);\n\tlockdep_set_class(&dev->addr_list_lock,\n\t\t\t  &macvlan_netdev_addr_lock_key);\n}\n\nstatic int macvlan_init(struct net_device *dev)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct net_device *lowerdev = vlan->lowerdev;\n\tstruct macvlan_port *port = vlan->port;\n\n\tdev->state\t\t= (dev->state & ~MACVLAN_STATE_MASK) |\n\t\t\t\t  (lowerdev->state & MACVLAN_STATE_MASK);\n\tdev->features \t\t= lowerdev->features & MACVLAN_FEATURES;\n\tdev->features\t\t|= ALWAYS_ON_FEATURES;\n\tdev->hw_features\t|= NETIF_F_LRO;\n\tdev->vlan_features\t= lowerdev->vlan_features & MACVLAN_FEATURES;\n\tdev->vlan_features\t|= ALWAYS_ON_OFFLOADS;\n\tdev->hw_enc_features    |= dev->features;\n\tnetif_inherit_tso_max(dev, lowerdev);\n\tdev->hard_header_len\t= lowerdev->hard_header_len;\n\tmacvlan_set_lockdep_class(dev);\n\n\tvlan->pcpu_stats = netdev_alloc_pcpu_stats(struct vlan_pcpu_stats);\n\tif (!vlan->pcpu_stats)\n\t\treturn -ENOMEM;\n\n\tport->count += 1;\n\n\t \n\tnetdev_hold(lowerdev, &vlan->dev_tracker, GFP_KERNEL);\n\n\treturn 0;\n}\n\nstatic void macvlan_uninit(struct net_device *dev)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct macvlan_port *port = vlan->port;\n\n\tfree_percpu(vlan->pcpu_stats);\n\n\tmacvlan_flush_sources(port, vlan);\n\tport->count -= 1;\n\tif (!port->count)\n\t\tmacvlan_port_destroy(port->dev);\n}\n\nstatic void macvlan_dev_get_stats64(struct net_device *dev,\n\t\t\t\t    struct rtnl_link_stats64 *stats)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\n\tif (vlan->pcpu_stats) {\n\t\tstruct vlan_pcpu_stats *p;\n\t\tu64 rx_packets, rx_bytes, rx_multicast, tx_packets, tx_bytes;\n\t\tu32 rx_errors = 0, tx_dropped = 0;\n\t\tunsigned int start;\n\t\tint i;\n\n\t\tfor_each_possible_cpu(i) {\n\t\t\tp = per_cpu_ptr(vlan->pcpu_stats, i);\n\t\t\tdo {\n\t\t\t\tstart = u64_stats_fetch_begin(&p->syncp);\n\t\t\t\trx_packets\t= u64_stats_read(&p->rx_packets);\n\t\t\t\trx_bytes\t= u64_stats_read(&p->rx_bytes);\n\t\t\t\trx_multicast\t= u64_stats_read(&p->rx_multicast);\n\t\t\t\ttx_packets\t= u64_stats_read(&p->tx_packets);\n\t\t\t\ttx_bytes\t= u64_stats_read(&p->tx_bytes);\n\t\t\t} while (u64_stats_fetch_retry(&p->syncp, start));\n\n\t\t\tstats->rx_packets\t+= rx_packets;\n\t\t\tstats->rx_bytes\t\t+= rx_bytes;\n\t\t\tstats->multicast\t+= rx_multicast;\n\t\t\tstats->tx_packets\t+= tx_packets;\n\t\t\tstats->tx_bytes\t\t+= tx_bytes;\n\t\t\t \n\t\t\trx_errors\t+= READ_ONCE(p->rx_errors);\n\t\t\ttx_dropped\t+= READ_ONCE(p->tx_dropped);\n\t\t}\n\t\tstats->rx_errors\t= rx_errors;\n\t\tstats->rx_dropped\t= rx_errors;\n\t\tstats->tx_dropped\t= tx_dropped;\n\t}\n}\n\nstatic int macvlan_vlan_rx_add_vid(struct net_device *dev,\n\t\t\t\t   __be16 proto, u16 vid)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct net_device *lowerdev = vlan->lowerdev;\n\n\treturn vlan_vid_add(lowerdev, proto, vid);\n}\n\nstatic int macvlan_vlan_rx_kill_vid(struct net_device *dev,\n\t\t\t\t    __be16 proto, u16 vid)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct net_device *lowerdev = vlan->lowerdev;\n\n\tvlan_vid_del(lowerdev, proto, vid);\n\treturn 0;\n}\n\nstatic int macvlan_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],\n\t\t\t   struct net_device *dev,\n\t\t\t   const unsigned char *addr, u16 vid,\n\t\t\t   u16 flags,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tint err = -EINVAL;\n\n\t \n\tif (!macvlan_passthru(vlan->port) && is_unicast_ether_addr(addr))\n\t\treturn -EOPNOTSUPP;\n\n\tif (flags & NLM_F_REPLACE)\n\t\treturn -EOPNOTSUPP;\n\n\tif (is_unicast_ether_addr(addr))\n\t\terr = dev_uc_add_excl(dev, addr);\n\telse if (is_multicast_ether_addr(addr))\n\t\terr = dev_mc_add_excl(dev, addr);\n\n\treturn err;\n}\n\nstatic int macvlan_fdb_del(struct ndmsg *ndm, struct nlattr *tb[],\n\t\t\t   struct net_device *dev,\n\t\t\t   const unsigned char *addr, u16 vid,\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tint err = -EINVAL;\n\n\t \n\tif (!macvlan_passthru(vlan->port) && is_unicast_ether_addr(addr))\n\t\treturn -EOPNOTSUPP;\n\n\tif (is_unicast_ether_addr(addr))\n\t\terr = dev_uc_del(dev, addr);\n\telse if (is_multicast_ether_addr(addr))\n\t\terr = dev_mc_del(dev, addr);\n\n\treturn err;\n}\n\nstatic void macvlan_ethtool_get_drvinfo(struct net_device *dev,\n\t\t\t\t\tstruct ethtool_drvinfo *drvinfo)\n{\n\tstrscpy(drvinfo->driver, \"macvlan\", sizeof(drvinfo->driver));\n\tstrscpy(drvinfo->version, \"0.1\", sizeof(drvinfo->version));\n}\n\nstatic int macvlan_ethtool_get_link_ksettings(struct net_device *dev,\n\t\t\t\t\t      struct ethtool_link_ksettings *cmd)\n{\n\tconst struct macvlan_dev *vlan = netdev_priv(dev);\n\n\treturn __ethtool_get_link_ksettings(vlan->lowerdev, cmd);\n}\n\nstatic int macvlan_ethtool_get_ts_info(struct net_device *dev,\n\t\t\t\t       struct ethtool_ts_info *info)\n{\n\tstruct net_device *real_dev = macvlan_dev_real_dev(dev);\n\tconst struct ethtool_ops *ops = real_dev->ethtool_ops;\n\tstruct phy_device *phydev = real_dev->phydev;\n\n\tif (phy_has_tsinfo(phydev)) {\n\t\treturn phy_ts_info(phydev, info);\n\t} else if (ops->get_ts_info) {\n\t\treturn ops->get_ts_info(real_dev, info);\n\t} else {\n\t\tinfo->so_timestamping = SOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\tSOF_TIMESTAMPING_SOFTWARE;\n\t\tinfo->phc_index = -1;\n\t}\n\n\treturn 0;\n}\n\nstatic netdev_features_t macvlan_fix_features(struct net_device *dev,\n\t\t\t\t\t      netdev_features_t features)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tnetdev_features_t lowerdev_features = vlan->lowerdev->features;\n\tnetdev_features_t mask;\n\n\tfeatures |= NETIF_F_ALL_FOR_ALL;\n\tfeatures &= (vlan->set_features | ~MACVLAN_FEATURES);\n\tmask = features;\n\n\tlowerdev_features &= (features | ~NETIF_F_LRO);\n\tfeatures = netdev_increment_features(lowerdev_features, features, mask);\n\tfeatures |= ALWAYS_ON_FEATURES;\n\tfeatures &= (ALWAYS_ON_FEATURES | MACVLAN_FEATURES);\n\n\treturn features;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void macvlan_dev_poll_controller(struct net_device *dev)\n{\n\treturn;\n}\n\nstatic int macvlan_dev_netpoll_setup(struct net_device *dev, struct netpoll_info *npinfo)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct net_device *real_dev = vlan->lowerdev;\n\tstruct netpoll *netpoll;\n\tint err;\n\n\tnetpoll = kzalloc(sizeof(*netpoll), GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!netpoll)\n\t\tgoto out;\n\n\terr = __netpoll_setup(netpoll, real_dev);\n\tif (err) {\n\t\tkfree(netpoll);\n\t\tgoto out;\n\t}\n\n\tvlan->netpoll = netpoll;\n\nout:\n\treturn err;\n}\n\nstatic void macvlan_dev_netpoll_cleanup(struct net_device *dev)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct netpoll *netpoll = vlan->netpoll;\n\n\tif (!netpoll)\n\t\treturn;\n\n\tvlan->netpoll = NULL;\n\n\t__netpoll_free(netpoll);\n}\n#endif\t \n\nstatic int macvlan_dev_get_iflink(const struct net_device *dev)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\n\treturn vlan->lowerdev->ifindex;\n}\n\nstatic const struct ethtool_ops macvlan_ethtool_ops = {\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_link_ksettings\t= macvlan_ethtool_get_link_ksettings,\n\t.get_drvinfo\t\t= macvlan_ethtool_get_drvinfo,\n\t.get_ts_info\t\t= macvlan_ethtool_get_ts_info,\n};\n\nstatic const struct net_device_ops macvlan_netdev_ops = {\n\t.ndo_init\t\t= macvlan_init,\n\t.ndo_uninit\t\t= macvlan_uninit,\n\t.ndo_open\t\t= macvlan_open,\n\t.ndo_stop\t\t= macvlan_stop,\n\t.ndo_start_xmit\t\t= macvlan_start_xmit,\n\t.ndo_change_mtu\t\t= macvlan_change_mtu,\n\t.ndo_fix_features\t= macvlan_fix_features,\n\t.ndo_change_rx_flags\t= macvlan_change_rx_flags,\n\t.ndo_set_mac_address\t= macvlan_set_mac_address,\n\t.ndo_set_rx_mode\t= macvlan_set_mac_lists,\n\t.ndo_get_stats64\t= macvlan_dev_get_stats64,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_vlan_rx_add_vid\t= macvlan_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= macvlan_vlan_rx_kill_vid,\n\t.ndo_fdb_add\t\t= macvlan_fdb_add,\n\t.ndo_fdb_del\t\t= macvlan_fdb_del,\n\t.ndo_fdb_dump\t\t= ndo_dflt_fdb_dump,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= macvlan_dev_poll_controller,\n\t.ndo_netpoll_setup\t= macvlan_dev_netpoll_setup,\n\t.ndo_netpoll_cleanup\t= macvlan_dev_netpoll_cleanup,\n#endif\n\t.ndo_get_iflink\t\t= macvlan_dev_get_iflink,\n\t.ndo_features_check\t= passthru_features_check,\n\t.ndo_hwtstamp_get\t= macvlan_hwtstamp_get,\n\t.ndo_hwtstamp_set\t= macvlan_hwtstamp_set,\n};\n\nstatic void macvlan_dev_free(struct net_device *dev)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\n\t \n\tnetdev_put(vlan->lowerdev, &vlan->dev_tracker);\n}\n\nvoid macvlan_common_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\n\t \n\tdev->max_mtu\t\t= ETH_MAX_MTU;\n\tdev->priv_flags\t       &= ~IFF_TX_SKB_SHARING;\n\tnetif_keep_dst(dev);\n\tdev->priv_flags\t       |= IFF_UNICAST_FLT | IFF_CHANGE_PROTO_DOWN;\n\tdev->netdev_ops\t\t= &macvlan_netdev_ops;\n\tdev->needs_free_netdev\t= true;\n\tdev->priv_destructor\t= macvlan_dev_free;\n\tdev->header_ops\t\t= &macvlan_hard_header_ops;\n\tdev->ethtool_ops\t= &macvlan_ethtool_ops;\n}\nEXPORT_SYMBOL_GPL(macvlan_common_setup);\n\nstatic void macvlan_setup(struct net_device *dev)\n{\n\tmacvlan_common_setup(dev);\n\tdev->priv_flags |= IFF_NO_QUEUE;\n}\n\nstatic int macvlan_port_create(struct net_device *dev)\n{\n\tstruct macvlan_port *port;\n\tunsigned int i;\n\tint err;\n\n\tif (dev->type != ARPHRD_ETHER || dev->flags & IFF_LOOPBACK)\n\t\treturn -EINVAL;\n\n\tif (netdev_is_rx_handler_busy(dev))\n\t\treturn -EBUSY;\n\n\tport = kzalloc(sizeof(*port), GFP_KERNEL);\n\tif (port == NULL)\n\t\treturn -ENOMEM;\n\n\tport->dev = dev;\n\tether_addr_copy(port->perm_addr, dev->dev_addr);\n\tINIT_LIST_HEAD(&port->vlans);\n\tfor (i = 0; i < MACVLAN_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&port->vlan_hash[i]);\n\tfor (i = 0; i < MACVLAN_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&port->vlan_source_hash[i]);\n\n\tport->bc_queue_len_used = 0;\n\tport->bc_cutoff = 1;\n\tskb_queue_head_init(&port->bc_queue);\n\tINIT_WORK(&port->bc_work, macvlan_process_broadcast);\n\n\terr = netdev_rx_handler_register(dev, macvlan_handle_frame, port);\n\tif (err)\n\t\tkfree(port);\n\telse\n\t\tdev->priv_flags |= IFF_MACVLAN_PORT;\n\treturn err;\n}\n\nstatic void macvlan_port_destroy(struct net_device *dev)\n{\n\tstruct macvlan_port *port = macvlan_port_get_rtnl(dev);\n\tstruct sk_buff *skb;\n\n\tdev->priv_flags &= ~IFF_MACVLAN_PORT;\n\tnetdev_rx_handler_unregister(dev);\n\n\t \n\tcancel_work_sync(&port->bc_work);\n\n\twhile ((skb = __skb_dequeue(&port->bc_queue))) {\n\t\tconst struct macvlan_dev *src = MACVLAN_SKB_CB(skb)->src;\n\n\t\tif (src)\n\t\t\tdev_put(src->dev);\n\n\t\tkfree_skb(skb);\n\t}\n\n\t \n\tif (macvlan_passthru(port) &&\n\t    !ether_addr_equal(port->dev->dev_addr, port->perm_addr)) {\n\t\tstruct sockaddr sa;\n\n\t\tsa.sa_family = port->dev->type;\n\t\tmemcpy(&sa.sa_data, port->perm_addr, port->dev->addr_len);\n\t\tdev_set_mac_address(port->dev, &sa, NULL);\n\t}\n\n\tkfree(port);\n}\n\nstatic int macvlan_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct nlattr *nla, *head;\n\tint rem, len;\n\n\tif (tb[IFLA_ADDRESS]) {\n\t\tif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\n\t\t\treturn -EINVAL;\n\t\tif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tif (!data)\n\t\treturn 0;\n\n\tif (data[IFLA_MACVLAN_FLAGS] &&\n\t    nla_get_u16(data[IFLA_MACVLAN_FLAGS]) & ~(MACVLAN_FLAG_NOPROMISC |\n\t\t\t\t\t\t      MACVLAN_FLAG_NODST))\n\t\treturn -EINVAL;\n\n\tif (data[IFLA_MACVLAN_MODE]) {\n\t\tswitch (nla_get_u32(data[IFLA_MACVLAN_MODE])) {\n\t\tcase MACVLAN_MODE_PRIVATE:\n\t\tcase MACVLAN_MODE_VEPA:\n\t\tcase MACVLAN_MODE_BRIDGE:\n\t\tcase MACVLAN_MODE_PASSTHRU:\n\t\tcase MACVLAN_MODE_SOURCE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (data[IFLA_MACVLAN_MACADDR_MODE]) {\n\t\tswitch (nla_get_u32(data[IFLA_MACVLAN_MACADDR_MODE])) {\n\t\tcase MACVLAN_MACADDR_ADD:\n\t\tcase MACVLAN_MACADDR_DEL:\n\t\tcase MACVLAN_MACADDR_FLUSH:\n\t\tcase MACVLAN_MACADDR_SET:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (data[IFLA_MACVLAN_MACADDR]) {\n\t\tif (nla_len(data[IFLA_MACVLAN_MACADDR]) != ETH_ALEN)\n\t\t\treturn -EINVAL;\n\n\t\tif (!is_valid_ether_addr(nla_data(data[IFLA_MACVLAN_MACADDR])))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tif (data[IFLA_MACVLAN_MACADDR_DATA]) {\n\t\thead = nla_data(data[IFLA_MACVLAN_MACADDR_DATA]);\n\t\tlen = nla_len(data[IFLA_MACVLAN_MACADDR_DATA]);\n\n\t\tnla_for_each_attr(nla, head, len, rem) {\n\t\t\tif (nla_type(nla) != IFLA_MACVLAN_MACADDR ||\n\t\t\t    nla_len(nla) != ETH_ALEN)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (!is_valid_ether_addr(nla_data(nla)))\n\t\t\t\treturn -EADDRNOTAVAIL;\n\t\t}\n\t}\n\n\tif (data[IFLA_MACVLAN_MACADDR_COUNT])\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int macvlan_changelink_sources(struct macvlan_dev *vlan, u32 mode,\n\t\t\t\t      struct nlattr *data[])\n{\n\tchar *addr = NULL;\n\tint ret, rem, len;\n\tstruct nlattr *nla, *head;\n\tstruct macvlan_source_entry *entry;\n\n\tif (data[IFLA_MACVLAN_MACADDR])\n\t\taddr = nla_data(data[IFLA_MACVLAN_MACADDR]);\n\n\tif (mode == MACVLAN_MACADDR_ADD) {\n\t\tif (!addr)\n\t\t\treturn -EINVAL;\n\n\t\treturn macvlan_hash_add_source(vlan, addr);\n\n\t} else if (mode == MACVLAN_MACADDR_DEL) {\n\t\tif (!addr)\n\t\t\treturn -EINVAL;\n\n\t\tentry = macvlan_hash_lookup_source(vlan, addr);\n\t\tif (entry) {\n\t\t\tmacvlan_hash_del_source(entry);\n\t\t\tvlan->macaddr_count--;\n\t\t}\n\t} else if (mode == MACVLAN_MACADDR_FLUSH) {\n\t\tmacvlan_flush_sources(vlan->port, vlan);\n\t} else if (mode == MACVLAN_MACADDR_SET) {\n\t\tmacvlan_flush_sources(vlan->port, vlan);\n\n\t\tif (addr) {\n\t\t\tret = macvlan_hash_add_source(vlan, addr);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (!data[IFLA_MACVLAN_MACADDR_DATA])\n\t\t\treturn 0;\n\n\t\thead = nla_data(data[IFLA_MACVLAN_MACADDR_DATA]);\n\t\tlen = nla_len(data[IFLA_MACVLAN_MACADDR_DATA]);\n\n\t\tnla_for_each_attr(nla, head, len, rem) {\n\t\t\taddr = nla_data(nla);\n\t\t\tret = macvlan_hash_add_source(vlan, addr);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint macvlan_common_newlink(struct net *src_net, struct net_device *dev,\n\t\t\t   struct nlattr *tb[], struct nlattr *data[],\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct macvlan_port *port;\n\tstruct net_device *lowerdev;\n\tint err;\n\tint macmode;\n\tbool create = false;\n\n\tif (!tb[IFLA_LINK])\n\t\treturn -EINVAL;\n\n\tlowerdev = __dev_get_by_index(src_net, nla_get_u32(tb[IFLA_LINK]));\n\tif (lowerdev == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tif (netif_is_macvlan(lowerdev))\n\t\tlowerdev = macvlan_dev_real_dev(lowerdev);\n\n\tif (!tb[IFLA_MTU])\n\t\tdev->mtu = lowerdev->mtu;\n\telse if (dev->mtu > lowerdev->mtu)\n\t\treturn -EINVAL;\n\n\t \n\tdev->min_mtu = ETH_MIN_MTU;\n\tdev->max_mtu = lowerdev->max_mtu;\n\n\tif (!tb[IFLA_ADDRESS])\n\t\teth_hw_addr_random(dev);\n\n\tif (!netif_is_macvlan_port(lowerdev)) {\n\t\terr = macvlan_port_create(lowerdev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tcreate = true;\n\t}\n\tport = macvlan_port_get_rtnl(lowerdev);\n\n\t \n\tif (macvlan_passthru(port)) {\n\t\t \n\t\terr = -EINVAL;\n\t\tgoto destroy_macvlan_port;\n\t}\n\n\tvlan->lowerdev = lowerdev;\n\tvlan->dev      = dev;\n\tvlan->port     = port;\n\tvlan->set_features = MACVLAN_FEATURES;\n\n\tvlan->mode     = MACVLAN_MODE_VEPA;\n\tif (data && data[IFLA_MACVLAN_MODE])\n\t\tvlan->mode = nla_get_u32(data[IFLA_MACVLAN_MODE]);\n\n\tif (data && data[IFLA_MACVLAN_FLAGS])\n\t\tvlan->flags = nla_get_u16(data[IFLA_MACVLAN_FLAGS]);\n\n\tif (vlan->mode == MACVLAN_MODE_PASSTHRU) {\n\t\tif (port->count) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto destroy_macvlan_port;\n\t\t}\n\t\tmacvlan_set_passthru(port);\n\t\teth_hw_addr_inherit(dev, lowerdev);\n\t}\n\n\tif (data && data[IFLA_MACVLAN_MACADDR_MODE]) {\n\t\tif (vlan->mode != MACVLAN_MODE_SOURCE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto destroy_macvlan_port;\n\t\t}\n\t\tmacmode = nla_get_u32(data[IFLA_MACVLAN_MACADDR_MODE]);\n\t\terr = macvlan_changelink_sources(vlan, macmode, data);\n\t\tif (err)\n\t\t\tgoto destroy_macvlan_port;\n\t}\n\n\tvlan->bc_queue_len_req = MACVLAN_DEFAULT_BC_QUEUE_LEN;\n\tif (data && data[IFLA_MACVLAN_BC_QUEUE_LEN])\n\t\tvlan->bc_queue_len_req = nla_get_u32(data[IFLA_MACVLAN_BC_QUEUE_LEN]);\n\n\tif (data && data[IFLA_MACVLAN_BC_CUTOFF])\n\t\tupdate_port_bc_cutoff(\n\t\t\tvlan, nla_get_s32(data[IFLA_MACVLAN_BC_CUTOFF]));\n\n\terr = register_netdevice(dev);\n\tif (err < 0)\n\t\tgoto destroy_macvlan_port;\n\n\tdev->priv_flags |= IFF_MACVLAN;\n\terr = netdev_upper_dev_link(lowerdev, dev, extack);\n\tif (err)\n\t\tgoto unregister_netdev;\n\n\tlist_add_tail_rcu(&vlan->list, &port->vlans);\n\tupdate_port_bc_queue_len(vlan->port);\n\tnetif_stacked_transfer_operstate(lowerdev, dev);\n\tlinkwatch_fire_event(dev);\n\n\treturn 0;\n\nunregister_netdev:\n\t \n\tunregister_netdevice(dev);\n\treturn err;\ndestroy_macvlan_port:\n\t \n\tif (create && macvlan_port_get_rtnl(lowerdev)) {\n\t\tmacvlan_flush_sources(port, vlan);\n\t\tmacvlan_port_destroy(port->dev);\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(macvlan_common_newlink);\n\nstatic int macvlan_newlink(struct net *src_net, struct net_device *dev,\n\t\t\t   struct nlattr *tb[], struct nlattr *data[],\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\treturn macvlan_common_newlink(src_net, dev, tb, data, extack);\n}\n\nvoid macvlan_dellink(struct net_device *dev, struct list_head *head)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\n\tif (vlan->mode == MACVLAN_MODE_SOURCE)\n\t\tmacvlan_flush_sources(vlan->port, vlan);\n\tlist_del_rcu(&vlan->list);\n\tupdate_port_bc_queue_len(vlan->port);\n\tunregister_netdevice_queue(dev, head);\n\tnetdev_upper_dev_unlink(vlan->lowerdev, dev);\n}\nEXPORT_SYMBOL_GPL(macvlan_dellink);\n\nstatic int macvlan_changelink(struct net_device *dev,\n\t\t\t      struct nlattr *tb[], struct nlattr *data[],\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tenum macvlan_mode mode;\n\tbool set_mode = false;\n\tenum macvlan_macaddr_mode macmode;\n\tint ret;\n\n\t \n\tif (data && data[IFLA_MACVLAN_MODE]) {\n\t\tset_mode = true;\n\t\tmode = nla_get_u32(data[IFLA_MACVLAN_MODE]);\n\t\t \n\t\tif ((mode == MACVLAN_MODE_PASSTHRU) !=\n\t\t    (vlan->mode == MACVLAN_MODE_PASSTHRU))\n\t\t\treturn -EINVAL;\n\t\tif (vlan->mode == MACVLAN_MODE_SOURCE &&\n\t\t    vlan->mode != mode)\n\t\t\tmacvlan_flush_sources(vlan->port, vlan);\n\t}\n\n\tif (data && data[IFLA_MACVLAN_FLAGS]) {\n\t\t__u16 flags = nla_get_u16(data[IFLA_MACVLAN_FLAGS]);\n\t\tbool promisc = (flags ^ vlan->flags) & MACVLAN_FLAG_NOPROMISC;\n\t\tif (macvlan_passthru(vlan->port) && promisc) {\n\t\t\tint err;\n\n\t\t\tif (flags & MACVLAN_FLAG_NOPROMISC)\n\t\t\t\terr = dev_set_promiscuity(vlan->lowerdev, -1);\n\t\t\telse\n\t\t\t\terr = dev_set_promiscuity(vlan->lowerdev, 1);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tvlan->flags = flags;\n\t}\n\n\tif (data && data[IFLA_MACVLAN_BC_QUEUE_LEN]) {\n\t\tvlan->bc_queue_len_req = nla_get_u32(data[IFLA_MACVLAN_BC_QUEUE_LEN]);\n\t\tupdate_port_bc_queue_len(vlan->port);\n\t}\n\n\tif (data && data[IFLA_MACVLAN_BC_CUTOFF])\n\t\tupdate_port_bc_cutoff(\n\t\t\tvlan, nla_get_s32(data[IFLA_MACVLAN_BC_CUTOFF]));\n\n\tif (set_mode)\n\t\tvlan->mode = mode;\n\tif (data && data[IFLA_MACVLAN_MACADDR_MODE]) {\n\t\tif (vlan->mode != MACVLAN_MODE_SOURCE)\n\t\t\treturn -EINVAL;\n\t\tmacmode = nla_get_u32(data[IFLA_MACVLAN_MACADDR_MODE]);\n\t\tret = macvlan_changelink_sources(vlan, macmode, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic size_t macvlan_get_size_mac(const struct macvlan_dev *vlan)\n{\n\tif (vlan->macaddr_count == 0)\n\t\treturn 0;\n\treturn nla_total_size(0)  \n\t\t+ vlan->macaddr_count * nla_total_size(sizeof(u8) * ETH_ALEN);\n}\n\nstatic size_t macvlan_get_size(const struct net_device *dev)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\n\treturn (0\n\t\t+ nla_total_size(4)  \n\t\t+ nla_total_size(2)  \n\t\t+ nla_total_size(4)  \n\t\t+ macvlan_get_size_mac(vlan)  \n\t\t+ nla_total_size(4)  \n\t\t+ nla_total_size(4)  \n\t\t);\n}\n\nstatic int macvlan_fill_info_macaddr(struct sk_buff *skb,\n\t\t\t\t     const struct macvlan_dev *vlan,\n\t\t\t\t     const int i)\n{\n\tstruct hlist_head *h = &vlan->port->vlan_source_hash[i];\n\tstruct macvlan_source_entry *entry;\n\n\thlist_for_each_entry_rcu(entry, h, hlist, lockdep_rtnl_is_held()) {\n\t\tif (entry->vlan != vlan)\n\t\t\tcontinue;\n\t\tif (nla_put(skb, IFLA_MACVLAN_MACADDR, ETH_ALEN, entry->addr))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int macvlan_fill_info(struct sk_buff *skb,\n\t\t\t\tconst struct net_device *dev)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct macvlan_port *port = vlan->port;\n\tint i;\n\tstruct nlattr *nest;\n\n\tif (nla_put_u32(skb, IFLA_MACVLAN_MODE, vlan->mode))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u16(skb, IFLA_MACVLAN_FLAGS, vlan->flags))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(skb, IFLA_MACVLAN_MACADDR_COUNT, vlan->macaddr_count))\n\t\tgoto nla_put_failure;\n\tif (vlan->macaddr_count > 0) {\n\t\tnest = nla_nest_start_noflag(skb, IFLA_MACVLAN_MACADDR_DATA);\n\t\tif (nest == NULL)\n\t\t\tgoto nla_put_failure;\n\n\t\tfor (i = 0; i < MACVLAN_HASH_SIZE; i++) {\n\t\t\tif (macvlan_fill_info_macaddr(skb, vlan, i))\n\t\t\t\tgoto nla_put_failure;\n\t\t}\n\t\tnla_nest_end(skb, nest);\n\t}\n\tif (nla_put_u32(skb, IFLA_MACVLAN_BC_QUEUE_LEN, vlan->bc_queue_len_req))\n\t\tgoto nla_put_failure;\n\tif (nla_put_u32(skb, IFLA_MACVLAN_BC_QUEUE_LEN_USED, port->bc_queue_len_used))\n\t\tgoto nla_put_failure;\n\tif (port->bc_cutoff != 1 &&\n\t    nla_put_s32(skb, IFLA_MACVLAN_BC_CUTOFF, port->bc_cutoff))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic const struct nla_policy macvlan_policy[IFLA_MACVLAN_MAX + 1] = {\n\t[IFLA_MACVLAN_MODE]  = { .type = NLA_U32 },\n\t[IFLA_MACVLAN_FLAGS] = { .type = NLA_U16 },\n\t[IFLA_MACVLAN_MACADDR_MODE] = { .type = NLA_U32 },\n\t[IFLA_MACVLAN_MACADDR] = { .type = NLA_BINARY, .len = MAX_ADDR_LEN },\n\t[IFLA_MACVLAN_MACADDR_DATA] = { .type = NLA_NESTED },\n\t[IFLA_MACVLAN_MACADDR_COUNT] = { .type = NLA_U32 },\n\t[IFLA_MACVLAN_BC_QUEUE_LEN] = { .type = NLA_U32 },\n\t[IFLA_MACVLAN_BC_QUEUE_LEN_USED] = { .type = NLA_REJECT },\n\t[IFLA_MACVLAN_BC_CUTOFF] = { .type = NLA_S32 },\n};\n\nint macvlan_link_register(struct rtnl_link_ops *ops)\n{\n\t \n\tops->validate\t\t= macvlan_validate;\n\tops->maxtype\t\t= IFLA_MACVLAN_MAX;\n\tops->policy\t\t= macvlan_policy;\n\tops->changelink\t\t= macvlan_changelink;\n\tops->get_size\t\t= macvlan_get_size;\n\tops->fill_info\t\t= macvlan_fill_info;\n\n\treturn rtnl_link_register(ops);\n};\nEXPORT_SYMBOL_GPL(macvlan_link_register);\n\nstatic struct net *macvlan_get_link_net(const struct net_device *dev)\n{\n\treturn dev_net(macvlan_dev_real_dev(dev));\n}\n\nstatic struct rtnl_link_ops macvlan_link_ops = {\n\t.kind\t\t= \"macvlan\",\n\t.setup\t\t= macvlan_setup,\n\t.newlink\t= macvlan_newlink,\n\t.dellink\t= macvlan_dellink,\n\t.get_link_net\t= macvlan_get_link_net,\n\t.priv_size      = sizeof(struct macvlan_dev),\n};\n\nstatic void update_port_bc_queue_len(struct macvlan_port *port)\n{\n\tu32 max_bc_queue_len_req = 0;\n\tstruct macvlan_dev *vlan;\n\n\tlist_for_each_entry(vlan, &port->vlans, list) {\n\t\tif (vlan->bc_queue_len_req > max_bc_queue_len_req)\n\t\t\tmax_bc_queue_len_req = vlan->bc_queue_len_req;\n\t}\n\tport->bc_queue_len_used = max_bc_queue_len_req;\n}\n\nstatic int macvlan_device_event(struct notifier_block *unused,\n\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct macvlan_dev *vlan, *next;\n\tstruct macvlan_port *port;\n\tLIST_HEAD(list_kill);\n\n\tif (!netif_is_macvlan_port(dev))\n\t\treturn NOTIFY_DONE;\n\n\tport = macvlan_port_get_rtnl(dev);\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\tcase NETDEV_DOWN:\n\tcase NETDEV_CHANGE:\n\t\tlist_for_each_entry(vlan, &port->vlans, list)\n\t\t\tnetif_stacked_transfer_operstate(vlan->lowerdev,\n\t\t\t\t\t\t\t vlan->dev);\n\t\tbreak;\n\tcase NETDEV_FEAT_CHANGE:\n\t\tlist_for_each_entry(vlan, &port->vlans, list) {\n\t\t\tnetif_inherit_tso_max(vlan->dev, dev);\n\t\t\tnetdev_update_features(vlan->dev);\n\t\t}\n\t\tbreak;\n\tcase NETDEV_CHANGEMTU:\n\t\tlist_for_each_entry(vlan, &port->vlans, list) {\n\t\t\tif (vlan->dev->mtu <= dev->mtu)\n\t\t\t\tcontinue;\n\t\t\tdev_set_mtu(vlan->dev, dev->mtu);\n\t\t}\n\t\tbreak;\n\tcase NETDEV_CHANGEADDR:\n\t\tif (!macvlan_passthru(port))\n\t\t\treturn NOTIFY_DONE;\n\n\t\tvlan = list_first_entry_or_null(&port->vlans,\n\t\t\t\t\t\tstruct macvlan_dev,\n\t\t\t\t\t\tlist);\n\n\t\tif (vlan && macvlan_sync_address(vlan->dev, dev->dev_addr))\n\t\t\treturn NOTIFY_BAD;\n\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\t\t \n\t\tif (dev->reg_state != NETREG_UNREGISTERING)\n\t\t\tbreak;\n\n\t\tlist_for_each_entry_safe(vlan, next, &port->vlans, list)\n\t\t\tvlan->dev->rtnl_link_ops->dellink(vlan->dev, &list_kill);\n\t\tunregister_netdevice_many(&list_kill);\n\t\tbreak;\n\tcase NETDEV_PRE_TYPE_CHANGE:\n\t\t \n\t\treturn NOTIFY_BAD;\n\n\tcase NETDEV_NOTIFY_PEERS:\n\tcase NETDEV_BONDING_FAILOVER:\n\tcase NETDEV_RESEND_IGMP:\n\t\t \n\t\tlist_for_each_entry(vlan, &port->vlans, list)\n\t\t\tcall_netdevice_notifiers(event, vlan->dev);\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block macvlan_notifier_block __read_mostly = {\n\t.notifier_call\t= macvlan_device_event,\n};\n\nstatic int __init macvlan_init_module(void)\n{\n\tint err;\n\n\tregister_netdevice_notifier(&macvlan_notifier_block);\n\n\terr = macvlan_link_register(&macvlan_link_ops);\n\tif (err < 0)\n\t\tgoto err1;\n\treturn 0;\nerr1:\n\tunregister_netdevice_notifier(&macvlan_notifier_block);\n\treturn err;\n}\n\nstatic void __exit macvlan_cleanup_module(void)\n{\n\trtnl_link_unregister(&macvlan_link_ops);\n\tunregister_netdevice_notifier(&macvlan_notifier_block);\n}\n\nmodule_init(macvlan_init_module);\nmodule_exit(macvlan_cleanup_module);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Patrick McHardy <kaber@trash.net>\");\nMODULE_DESCRIPTION(\"Driver for MAC address based VLANs\");\nMODULE_ALIAS_RTNL_LINK(\"macvlan\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}