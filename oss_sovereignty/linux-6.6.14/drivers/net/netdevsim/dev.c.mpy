{
  "module_name": "dev.c",
  "hash_id": "60fbf6ee5a9f0ed142660f49744054f5f5a457eaca026573bba66ab363eb1ce1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/netdevsim/dev.c",
  "human_readable_source": " \n\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/etherdevice.h>\n#include <linux/inet.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/random.h>\n#include <linux/rtnetlink.h>\n#include <linux/workqueue.h>\n#include <net/devlink.h>\n#include <net/ip.h>\n#include <net/flow_offload.h>\n#include <uapi/linux/devlink.h>\n#include <uapi/linux/ip.h>\n#include <uapi/linux/udp.h>\n\n#include \"netdevsim.h\"\n\nstatic unsigned int\nnsim_dev_port_index(enum nsim_dev_port_type type, unsigned int port_index)\n{\n\tswitch (type) {\n\tcase NSIM_DEV_PORT_TYPE_VF:\n\t\tport_index = NSIM_DEV_VF_PORT_INDEX_BASE + port_index;\n\t\tbreak;\n\tcase NSIM_DEV_PORT_TYPE_PF:\n\t\tbreak;\n\t}\n\n\treturn port_index;\n}\n\nstatic inline unsigned int nsim_dev_port_index_to_vf_index(unsigned int port_index)\n{\n\treturn port_index - NSIM_DEV_VF_PORT_INDEX_BASE;\n}\n\nstatic struct dentry *nsim_dev_ddir;\n\nunsigned int nsim_dev_get_vfs(struct nsim_dev *nsim_dev)\n{\n\tWARN_ON(!lockdep_rtnl_is_held() &&\n\t\t!devl_lock_is_held(priv_to_devlink(nsim_dev)));\n\n\treturn nsim_dev->nsim_bus_dev->num_vfs;\n}\n\nstatic void\nnsim_bus_dev_set_vfs(struct nsim_bus_dev *nsim_bus_dev, unsigned int num_vfs)\n{\n\trtnl_lock();\n\tnsim_bus_dev->num_vfs = num_vfs;\n\trtnl_unlock();\n}\n\n#define NSIM_DEV_DUMMY_REGION_SIZE (1024 * 32)\n\nstatic int\nnsim_dev_take_snapshot(struct devlink *devlink,\n\t\t       const struct devlink_region_ops *ops,\n\t\t       struct netlink_ext_ack *extack,\n\t\t       u8 **data)\n{\n\tvoid *dummy_data;\n\n\tdummy_data = kmalloc(NSIM_DEV_DUMMY_REGION_SIZE, GFP_KERNEL);\n\tif (!dummy_data)\n\t\treturn -ENOMEM;\n\n\tget_random_bytes(dummy_data, NSIM_DEV_DUMMY_REGION_SIZE);\n\n\t*data = dummy_data;\n\n\treturn 0;\n}\n\nstatic ssize_t nsim_dev_take_snapshot_write(struct file *file,\n\t\t\t\t\t    const char __user *data,\n\t\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct nsim_dev *nsim_dev = file->private_data;\n\tstruct devlink *devlink;\n\tu8 *dummy_data;\n\tint err;\n\tu32 id;\n\n\tdevlink = priv_to_devlink(nsim_dev);\n\n\terr = nsim_dev_take_snapshot(devlink, NULL, NULL, &dummy_data);\n\tif (err)\n\t\treturn err;\n\n\terr = devlink_region_snapshot_id_get(devlink, &id);\n\tif (err) {\n\t\tpr_err(\"Failed to get snapshot id\\n\");\n\t\tkfree(dummy_data);\n\t\treturn err;\n\t}\n\terr = devlink_region_snapshot_create(nsim_dev->dummy_region,\n\t\t\t\t\t     dummy_data, id);\n\tdevlink_region_snapshot_id_put(devlink, id);\n\tif (err) {\n\t\tpr_err(\"Failed to create region snapshot\\n\");\n\t\tkfree(dummy_data);\n\t\treturn err;\n\t}\n\n\treturn count;\n}\n\nstatic const struct file_operations nsim_dev_take_snapshot_fops = {\n\t.open = simple_open,\n\t.write = nsim_dev_take_snapshot_write,\n\t.llseek = generic_file_llseek,\n\t.owner = THIS_MODULE,\n};\n\nstatic ssize_t nsim_dev_trap_fa_cookie_read(struct file *file,\n\t\t\t\t\t    char __user *data,\n\t\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct nsim_dev *nsim_dev = file->private_data;\n\tstruct flow_action_cookie *fa_cookie;\n\tunsigned int buf_len;\n\tssize_t ret;\n\tchar *buf;\n\n\tspin_lock(&nsim_dev->fa_cookie_lock);\n\tfa_cookie = nsim_dev->fa_cookie;\n\tif (!fa_cookie) {\n\t\tret = -EINVAL;\n\t\tgoto errout;\n\t}\n\tbuf_len = fa_cookie->cookie_len * 2;\n\tbuf = kmalloc(buf_len, GFP_ATOMIC);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto errout;\n\t}\n\tbin2hex(buf, fa_cookie->cookie, fa_cookie->cookie_len);\n\tspin_unlock(&nsim_dev->fa_cookie_lock);\n\n\tret = simple_read_from_buffer(data, count, ppos, buf, buf_len);\n\n\tkfree(buf);\n\treturn ret;\n\nerrout:\n\tspin_unlock(&nsim_dev->fa_cookie_lock);\n\treturn ret;\n}\n\nstatic ssize_t nsim_dev_trap_fa_cookie_write(struct file *file,\n\t\t\t\t\t     const char __user *data,\n\t\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct nsim_dev *nsim_dev = file->private_data;\n\tstruct flow_action_cookie *fa_cookie;\n\tsize_t cookie_len;\n\tssize_t ret;\n\tchar *buf;\n\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\tcookie_len = (count - 1) / 2;\n\tif ((count - 1) % 2)\n\t\treturn -EINVAL;\n\n\tbuf = memdup_user(data, count);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tfa_cookie = kmalloc(sizeof(*fa_cookie) + cookie_len,\n\t\t\t    GFP_KERNEL | __GFP_NOWARN);\n\tif (!fa_cookie) {\n\t\tret = -ENOMEM;\n\t\tgoto free_buf;\n\t}\n\n\tfa_cookie->cookie_len = cookie_len;\n\tret = hex2bin(fa_cookie->cookie, buf, cookie_len);\n\tif (ret)\n\t\tgoto free_fa_cookie;\n\tkfree(buf);\n\n\tspin_lock(&nsim_dev->fa_cookie_lock);\n\tkfree(nsim_dev->fa_cookie);\n\tnsim_dev->fa_cookie = fa_cookie;\n\tspin_unlock(&nsim_dev->fa_cookie_lock);\n\n\treturn count;\n\nfree_fa_cookie:\n\tkfree(fa_cookie);\nfree_buf:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic const struct file_operations nsim_dev_trap_fa_cookie_fops = {\n\t.open = simple_open,\n\t.read = nsim_dev_trap_fa_cookie_read,\n\t.write = nsim_dev_trap_fa_cookie_write,\n\t.llseek = generic_file_llseek,\n\t.owner = THIS_MODULE,\n};\n\nstatic ssize_t nsim_bus_dev_max_vfs_read(struct file *file, char __user *data,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct nsim_dev *nsim_dev = file->private_data;\n\tchar buf[11];\n\tssize_t len;\n\n\tlen = scnprintf(buf, sizeof(buf), \"%u\\n\",\n\t\t\tREAD_ONCE(nsim_dev->nsim_bus_dev->max_vfs));\n\n\treturn simple_read_from_buffer(data, count, ppos, buf, len);\n}\n\nstatic ssize_t nsim_bus_dev_max_vfs_write(struct file *file,\n\t\t\t\t\t  const char __user *data,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct nsim_vf_config *vfconfigs;\n\tstruct nsim_dev *nsim_dev;\n\tchar buf[10];\n\tssize_t ret;\n\tu32 val;\n\n\tif (*ppos != 0)\n\t\treturn 0;\n\n\tif (count >= sizeof(buf))\n\t\treturn -ENOSPC;\n\n\tret = copy_from_user(buf, data, count);\n\tif (ret)\n\t\treturn -EFAULT;\n\tbuf[count] = '\\0';\n\n\tret = kstrtouint(buf, 10, &val);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\t \n\tif (val > NSIM_DEV_VF_PORT_INDEX_MAX - NSIM_DEV_VF_PORT_INDEX_BASE)\n\t\treturn -ERANGE;\n\n\tvfconfigs = kcalloc(val, sizeof(struct nsim_vf_config),\n\t\t\t    GFP_KERNEL | __GFP_NOWARN);\n\tif (!vfconfigs)\n\t\treturn -ENOMEM;\n\n\tnsim_dev = file->private_data;\n\tdevl_lock(priv_to_devlink(nsim_dev));\n\t \n\tif (nsim_dev_get_vfs(nsim_dev)) {\n\t\tret = -EBUSY;\n\t} else {\n\t\tswap(nsim_dev->vfconfigs, vfconfigs);\n\t\tWRITE_ONCE(nsim_dev->nsim_bus_dev->max_vfs, val);\n\t\t*ppos += count;\n\t\tret = count;\n\t}\n\tdevl_unlock(priv_to_devlink(nsim_dev));\n\n\tkfree(vfconfigs);\n\treturn ret;\n}\n\nstatic const struct file_operations nsim_dev_max_vfs_fops = {\n\t.open = simple_open,\n\t.read = nsim_bus_dev_max_vfs_read,\n\t.write = nsim_bus_dev_max_vfs_write,\n\t.llseek = generic_file_llseek,\n\t.owner = THIS_MODULE,\n};\n\nstatic int nsim_dev_debugfs_init(struct nsim_dev *nsim_dev)\n{\n\tchar dev_ddir_name[sizeof(DRV_NAME) + 10];\n\tint err;\n\n\tsprintf(dev_ddir_name, DRV_NAME \"%u\", nsim_dev->nsim_bus_dev->dev.id);\n\tnsim_dev->ddir = debugfs_create_dir(dev_ddir_name, nsim_dev_ddir);\n\tif (IS_ERR(nsim_dev->ddir))\n\t\treturn PTR_ERR(nsim_dev->ddir);\n\tnsim_dev->ports_ddir = debugfs_create_dir(\"ports\", nsim_dev->ddir);\n\tif (IS_ERR(nsim_dev->ports_ddir)) {\n\t\terr = PTR_ERR(nsim_dev->ports_ddir);\n\t\tgoto err_ddir;\n\t}\n\tdebugfs_create_bool(\"fw_update_status\", 0600, nsim_dev->ddir,\n\t\t\t    &nsim_dev->fw_update_status);\n\tdebugfs_create_u32(\"fw_update_overwrite_mask\", 0600, nsim_dev->ddir,\n\t\t\t    &nsim_dev->fw_update_overwrite_mask);\n\tdebugfs_create_u32(\"max_macs\", 0600, nsim_dev->ddir,\n\t\t\t   &nsim_dev->max_macs);\n\tdebugfs_create_bool(\"test1\", 0600, nsim_dev->ddir,\n\t\t\t    &nsim_dev->test1);\n\tnsim_dev->take_snapshot = debugfs_create_file(\"take_snapshot\",\n\t\t\t\t\t\t      0200,\n\t\t\t\t\t\t      nsim_dev->ddir,\n\t\t\t\t\t\t      nsim_dev,\n\t\t\t\t\t\t&nsim_dev_take_snapshot_fops);\n\tdebugfs_create_bool(\"dont_allow_reload\", 0600, nsim_dev->ddir,\n\t\t\t    &nsim_dev->dont_allow_reload);\n\tdebugfs_create_bool(\"fail_reload\", 0600, nsim_dev->ddir,\n\t\t\t    &nsim_dev->fail_reload);\n\tdebugfs_create_file(\"trap_flow_action_cookie\", 0600, nsim_dev->ddir,\n\t\t\t    nsim_dev, &nsim_dev_trap_fa_cookie_fops);\n\tdebugfs_create_bool(\"fail_trap_group_set\", 0600,\n\t\t\t    nsim_dev->ddir,\n\t\t\t    &nsim_dev->fail_trap_group_set);\n\tdebugfs_create_bool(\"fail_trap_policer_set\", 0600,\n\t\t\t    nsim_dev->ddir,\n\t\t\t    &nsim_dev->fail_trap_policer_set);\n\tdebugfs_create_bool(\"fail_trap_policer_counter_get\", 0600,\n\t\t\t    nsim_dev->ddir,\n\t\t\t    &nsim_dev->fail_trap_policer_counter_get);\n\t \n\tdebugfs_create_file(\"max_vfs\", 0600, nsim_dev->ddir,\n\t\t\t    nsim_dev, &nsim_dev_max_vfs_fops);\n\n\tnsim_dev->nodes_ddir = debugfs_create_dir(\"rate_nodes\", nsim_dev->ddir);\n\tif (IS_ERR(nsim_dev->nodes_ddir)) {\n\t\terr = PTR_ERR(nsim_dev->nodes_ddir);\n\t\tgoto err_ports_ddir;\n\t}\n\tdebugfs_create_bool(\"fail_trap_drop_counter_get\", 0600,\n\t\t\t    nsim_dev->ddir,\n\t\t\t    &nsim_dev->fail_trap_drop_counter_get);\n\tnsim_udp_tunnels_debugfs_create(nsim_dev);\n\treturn 0;\n\nerr_ports_ddir:\n\tdebugfs_remove_recursive(nsim_dev->ports_ddir);\nerr_ddir:\n\tdebugfs_remove_recursive(nsim_dev->ddir);\n\treturn err;\n}\n\nstatic void nsim_dev_debugfs_exit(struct nsim_dev *nsim_dev)\n{\n\tdebugfs_remove_recursive(nsim_dev->nodes_ddir);\n\tdebugfs_remove_recursive(nsim_dev->ports_ddir);\n\tdebugfs_remove_recursive(nsim_dev->ddir);\n}\n\nstatic ssize_t nsim_dev_rate_parent_read(struct file *file,\n\t\t\t\t\t char __user *data,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tchar **name_ptr = file->private_data;\n\tsize_t len;\n\n\tif (!*name_ptr)\n\t\treturn 0;\n\n\tlen = strlen(*name_ptr);\n\treturn simple_read_from_buffer(data, count, ppos, *name_ptr, len);\n}\n\nstatic const struct file_operations nsim_dev_rate_parent_fops = {\n\t.open = simple_open,\n\t.read = nsim_dev_rate_parent_read,\n\t.llseek = generic_file_llseek,\n\t.owner = THIS_MODULE,\n};\n\nstatic int nsim_dev_port_debugfs_init(struct nsim_dev *nsim_dev,\n\t\t\t\t      struct nsim_dev_port *nsim_dev_port)\n{\n\tstruct nsim_bus_dev *nsim_bus_dev = nsim_dev->nsim_bus_dev;\n\tunsigned int port_index = nsim_dev_port->port_index;\n\tchar port_ddir_name[16];\n\tchar dev_link_name[32];\n\n\tsprintf(port_ddir_name, \"%u\", port_index);\n\tnsim_dev_port->ddir = debugfs_create_dir(port_ddir_name,\n\t\t\t\t\t\t nsim_dev->ports_ddir);\n\tif (IS_ERR(nsim_dev_port->ddir))\n\t\treturn PTR_ERR(nsim_dev_port->ddir);\n\n\tsprintf(dev_link_name, \"../../../\" DRV_NAME \"%u\", nsim_bus_dev->dev.id);\n\tif (nsim_dev_port_is_vf(nsim_dev_port)) {\n\t\tunsigned int vf_id = nsim_dev_port_index_to_vf_index(port_index);\n\n\t\tdebugfs_create_u16(\"tx_share\", 0400, nsim_dev_port->ddir,\n\t\t\t\t   &nsim_dev->vfconfigs[vf_id].min_tx_rate);\n\t\tdebugfs_create_u16(\"tx_max\", 0400, nsim_dev_port->ddir,\n\t\t\t\t   &nsim_dev->vfconfigs[vf_id].max_tx_rate);\n\t\tnsim_dev_port->rate_parent = debugfs_create_file(\"rate_parent\",\n\t\t\t\t\t\t\t\t 0400,\n\t\t\t\t\t\t\t\t nsim_dev_port->ddir,\n\t\t\t\t\t\t\t\t &nsim_dev_port->parent_name,\n\t\t\t\t\t\t\t\t &nsim_dev_rate_parent_fops);\n\t}\n\tdebugfs_create_symlink(\"dev\", nsim_dev_port->ddir, dev_link_name);\n\n\treturn 0;\n}\n\nstatic void nsim_dev_port_debugfs_exit(struct nsim_dev_port *nsim_dev_port)\n{\n\tdebugfs_remove_recursive(nsim_dev_port->ddir);\n}\n\nstatic int nsim_dev_resources_register(struct devlink *devlink)\n{\n\tstruct devlink_resource_size_params params = {\n\t\t.size_max = (u64)-1,\n\t\t.size_granularity = 1,\n\t\t.unit = DEVLINK_RESOURCE_UNIT_ENTRY\n\t};\n\tint err;\n\n\t \n\terr = devl_resource_register(devlink, \"IPv4\", (u64)-1,\n\t\t\t\t     NSIM_RESOURCE_IPV4,\n\t\t\t\t     DEVLINK_RESOURCE_ID_PARENT_TOP,\n\t\t\t\t     &params);\n\tif (err) {\n\t\tpr_err(\"Failed to register IPv4 top resource\\n\");\n\t\tgoto err_out;\n\t}\n\n\terr = devl_resource_register(devlink, \"fib\", (u64)-1,\n\t\t\t\t     NSIM_RESOURCE_IPV4_FIB,\n\t\t\t\t     NSIM_RESOURCE_IPV4, &params);\n\tif (err) {\n\t\tpr_err(\"Failed to register IPv4 FIB resource\\n\");\n\t\tgoto err_out;\n\t}\n\n\terr = devl_resource_register(devlink, \"fib-rules\", (u64)-1,\n\t\t\t\t     NSIM_RESOURCE_IPV4_FIB_RULES,\n\t\t\t\t     NSIM_RESOURCE_IPV4, &params);\n\tif (err) {\n\t\tpr_err(\"Failed to register IPv4 FIB rules resource\\n\");\n\t\tgoto err_out;\n\t}\n\n\t \n\terr = devl_resource_register(devlink, \"IPv6\", (u64)-1,\n\t\t\t\t     NSIM_RESOURCE_IPV6,\n\t\t\t\t     DEVLINK_RESOURCE_ID_PARENT_TOP,\n\t\t\t\t     &params);\n\tif (err) {\n\t\tpr_err(\"Failed to register IPv6 top resource\\n\");\n\t\tgoto err_out;\n\t}\n\n\terr = devl_resource_register(devlink, \"fib\", (u64)-1,\n\t\t\t\t     NSIM_RESOURCE_IPV6_FIB,\n\t\t\t\t     NSIM_RESOURCE_IPV6, &params);\n\tif (err) {\n\t\tpr_err(\"Failed to register IPv6 FIB resource\\n\");\n\t\tgoto err_out;\n\t}\n\n\terr = devl_resource_register(devlink, \"fib-rules\", (u64)-1,\n\t\t\t\t     NSIM_RESOURCE_IPV6_FIB_RULES,\n\t\t\t\t     NSIM_RESOURCE_IPV6, &params);\n\tif (err) {\n\t\tpr_err(\"Failed to register IPv6 FIB rules resource\\n\");\n\t\tgoto err_out;\n\t}\n\n\t \n\terr = devl_resource_register(devlink, \"nexthops\", (u64)-1,\n\t\t\t\t     NSIM_RESOURCE_NEXTHOPS,\n\t\t\t\t     DEVLINK_RESOURCE_ID_PARENT_TOP,\n\t\t\t\t     &params);\n\tif (err) {\n\t\tpr_err(\"Failed to register NEXTHOPS resource\\n\");\n\t\tgoto err_out;\n\t}\n\treturn 0;\n\nerr_out:\n\tdevl_resources_unregister(devlink);\n\treturn err;\n}\n\nenum nsim_devlink_param_id {\n\tNSIM_DEVLINK_PARAM_ID_BASE = DEVLINK_PARAM_GENERIC_ID_MAX,\n\tNSIM_DEVLINK_PARAM_ID_TEST1,\n};\n\nstatic const struct devlink_param nsim_devlink_params[] = {\n\tDEVLINK_PARAM_GENERIC(MAX_MACS,\n\t\t\t      BIT(DEVLINK_PARAM_CMODE_DRIVERINIT),\n\t\t\t      NULL, NULL, NULL),\n\tDEVLINK_PARAM_DRIVER(NSIM_DEVLINK_PARAM_ID_TEST1,\n\t\t\t     \"test1\", DEVLINK_PARAM_TYPE_BOOL,\n\t\t\t     BIT(DEVLINK_PARAM_CMODE_DRIVERINIT),\n\t\t\t     NULL, NULL, NULL),\n};\n\nstatic void nsim_devlink_set_params_init_values(struct nsim_dev *nsim_dev,\n\t\t\t\t\t\tstruct devlink *devlink)\n{\n\tunion devlink_param_value value;\n\n\tvalue.vu32 = nsim_dev->max_macs;\n\tdevl_param_driverinit_value_set(devlink,\n\t\t\t\t\tDEVLINK_PARAM_GENERIC_ID_MAX_MACS,\n\t\t\t\t\tvalue);\n\tvalue.vbool = nsim_dev->test1;\n\tdevl_param_driverinit_value_set(devlink,\n\t\t\t\t\tNSIM_DEVLINK_PARAM_ID_TEST1,\n\t\t\t\t\tvalue);\n}\n\nstatic void nsim_devlink_param_load_driverinit_values(struct devlink *devlink)\n{\n\tstruct nsim_dev *nsim_dev = devlink_priv(devlink);\n\tunion devlink_param_value saved_value;\n\tint err;\n\n\terr = devl_param_driverinit_value_get(devlink,\n\t\t\t\t\t      DEVLINK_PARAM_GENERIC_ID_MAX_MACS,\n\t\t\t\t\t      &saved_value);\n\tif (!err)\n\t\tnsim_dev->max_macs = saved_value.vu32;\n\terr = devl_param_driverinit_value_get(devlink,\n\t\t\t\t\t      NSIM_DEVLINK_PARAM_ID_TEST1,\n\t\t\t\t\t      &saved_value);\n\tif (!err)\n\t\tnsim_dev->test1 = saved_value.vbool;\n}\n\n#define NSIM_DEV_DUMMY_REGION_SNAPSHOT_MAX 16\n\nstatic const struct devlink_region_ops dummy_region_ops = {\n\t.name = \"dummy\",\n\t.destructor = &kfree,\n\t.snapshot = nsim_dev_take_snapshot,\n};\n\nstatic int nsim_dev_dummy_region_init(struct nsim_dev *nsim_dev,\n\t\t\t\t      struct devlink *devlink)\n{\n\tnsim_dev->dummy_region =\n\t\tdevl_region_create(devlink, &dummy_region_ops,\n\t\t\t\t   NSIM_DEV_DUMMY_REGION_SNAPSHOT_MAX,\n\t\t\t\t   NSIM_DEV_DUMMY_REGION_SIZE);\n\treturn PTR_ERR_OR_ZERO(nsim_dev->dummy_region);\n}\n\nstatic void nsim_dev_dummy_region_exit(struct nsim_dev *nsim_dev)\n{\n\tdevl_region_destroy(nsim_dev->dummy_region);\n}\n\nstatic int\n__nsim_dev_port_add(struct nsim_dev *nsim_dev, enum nsim_dev_port_type type,\n\t\t    unsigned int port_index);\nstatic void __nsim_dev_port_del(struct nsim_dev_port *nsim_dev_port);\n\nstatic int nsim_esw_legacy_enable(struct nsim_dev *nsim_dev,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct devlink *devlink = priv_to_devlink(nsim_dev);\n\tstruct nsim_dev_port *nsim_dev_port, *tmp;\n\n\tdevl_rate_nodes_destroy(devlink);\n\tlist_for_each_entry_safe(nsim_dev_port, tmp, &nsim_dev->port_list, list)\n\t\tif (nsim_dev_port_is_vf(nsim_dev_port))\n\t\t\t__nsim_dev_port_del(nsim_dev_port);\n\tnsim_dev->esw_mode = DEVLINK_ESWITCH_MODE_LEGACY;\n\treturn 0;\n}\n\nstatic int nsim_esw_switchdev_enable(struct nsim_dev *nsim_dev,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct nsim_dev_port *nsim_dev_port, *tmp;\n\tint i, err;\n\n\tfor (i = 0; i < nsim_dev_get_vfs(nsim_dev); i++) {\n\t\terr = __nsim_dev_port_add(nsim_dev, NSIM_DEV_PORT_TYPE_VF, i);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to initialize VFs' netdevsim ports\");\n\t\t\tpr_err(\"Failed to initialize VF id=%d. %d.\\n\", i, err);\n\t\t\tgoto err_port_add_vfs;\n\t\t}\n\t}\n\tnsim_dev->esw_mode = DEVLINK_ESWITCH_MODE_SWITCHDEV;\n\treturn 0;\n\nerr_port_add_vfs:\n\tlist_for_each_entry_safe(nsim_dev_port, tmp, &nsim_dev->port_list, list)\n\t\tif (nsim_dev_port_is_vf(nsim_dev_port))\n\t\t\t__nsim_dev_port_del(nsim_dev_port);\n\treturn err;\n}\n\nstatic int nsim_devlink_eswitch_mode_set(struct devlink *devlink, u16 mode,\n\t\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct nsim_dev *nsim_dev = devlink_priv(devlink);\n\n\tif (mode == nsim_dev->esw_mode)\n\t\treturn 0;\n\n\tif (mode == DEVLINK_ESWITCH_MODE_LEGACY)\n\t\treturn nsim_esw_legacy_enable(nsim_dev, extack);\n\tif (mode == DEVLINK_ESWITCH_MODE_SWITCHDEV)\n\t\treturn nsim_esw_switchdev_enable(nsim_dev, extack);\n\n\treturn -EINVAL;\n}\n\nstatic int nsim_devlink_eswitch_mode_get(struct devlink *devlink, u16 *mode)\n{\n\tstruct nsim_dev *nsim_dev = devlink_priv(devlink);\n\n\t*mode = nsim_dev->esw_mode;\n\treturn 0;\n}\n\nstruct nsim_trap_item {\n\tvoid *trap_ctx;\n\tenum devlink_trap_action action;\n};\n\nstruct nsim_trap_data {\n\tstruct delayed_work trap_report_dw;\n\tstruct nsim_trap_item *trap_items_arr;\n\tu64 *trap_policers_cnt_arr;\n\tu64 trap_pkt_cnt;\n\tstruct nsim_dev *nsim_dev;\n\tspinlock_t trap_lock;\t \n};\n\n \nenum {\n\tNSIM_TRAP_ID_BASE = DEVLINK_TRAP_GENERIC_ID_MAX,\n\tNSIM_TRAP_ID_FID_MISS,\n};\n\n#define NSIM_TRAP_NAME_FID_MISS \"fid_miss\"\n\n#define NSIM_TRAP_METADATA DEVLINK_TRAP_METADATA_TYPE_F_IN_PORT\n\n#define NSIM_TRAP_DROP(_id, _group_id)\t\t\t\t\t      \\\n\tDEVLINK_TRAP_GENERIC(DROP, DROP, _id,\t\t\t\t      \\\n\t\t\t     DEVLINK_TRAP_GROUP_GENERIC_ID_##_group_id,\t      \\\n\t\t\t     NSIM_TRAP_METADATA)\n#define NSIM_TRAP_DROP_EXT(_id, _group_id, _metadata)\t\t\t      \\\n\tDEVLINK_TRAP_GENERIC(DROP, DROP, _id,\t\t\t\t      \\\n\t\t\t     DEVLINK_TRAP_GROUP_GENERIC_ID_##_group_id,\t      \\\n\t\t\t     NSIM_TRAP_METADATA | (_metadata))\n#define NSIM_TRAP_EXCEPTION(_id, _group_id)\t\t\t\t      \\\n\tDEVLINK_TRAP_GENERIC(EXCEPTION, TRAP, _id,\t\t\t      \\\n\t\t\t     DEVLINK_TRAP_GROUP_GENERIC_ID_##_group_id,\t      \\\n\t\t\t     NSIM_TRAP_METADATA)\n#define NSIM_TRAP_CONTROL(_id, _group_id, _action)\t\t\t      \\\n\tDEVLINK_TRAP_GENERIC(CONTROL, _action, _id,\t\t\t      \\\n\t\t\t     DEVLINK_TRAP_GROUP_GENERIC_ID_##_group_id,\t      \\\n\t\t\t     NSIM_TRAP_METADATA)\n#define NSIM_TRAP_DRIVER_EXCEPTION(_id, _group_id)\t\t\t      \\\n\tDEVLINK_TRAP_DRIVER(EXCEPTION, TRAP, NSIM_TRAP_ID_##_id,\t      \\\n\t\t\t    NSIM_TRAP_NAME_##_id,\t\t\t      \\\n\t\t\t    DEVLINK_TRAP_GROUP_GENERIC_ID_##_group_id,\t      \\\n\t\t\t    NSIM_TRAP_METADATA)\n\n#define NSIM_DEV_TRAP_POLICER_MIN_RATE\t1\n#define NSIM_DEV_TRAP_POLICER_MAX_RATE\t8000\n#define NSIM_DEV_TRAP_POLICER_MIN_BURST\t8\n#define NSIM_DEV_TRAP_POLICER_MAX_BURST\t65536\n\n#define NSIM_TRAP_POLICER(_id, _rate, _burst)\t\t\t\t      \\\n\tDEVLINK_TRAP_POLICER(_id, _rate, _burst,\t\t\t      \\\n\t\t\t     NSIM_DEV_TRAP_POLICER_MAX_RATE,\t\t      \\\n\t\t\t     NSIM_DEV_TRAP_POLICER_MIN_RATE,\t\t      \\\n\t\t\t     NSIM_DEV_TRAP_POLICER_MAX_BURST,\t\t      \\\n\t\t\t     NSIM_DEV_TRAP_POLICER_MIN_BURST)\n\nstatic const struct devlink_trap_policer nsim_trap_policers_arr[] = {\n\tNSIM_TRAP_POLICER(1, 1000, 128),\n\tNSIM_TRAP_POLICER(2, 2000, 256),\n\tNSIM_TRAP_POLICER(3, 3000, 512),\n};\n\nstatic const struct devlink_trap_group nsim_trap_groups_arr[] = {\n\tDEVLINK_TRAP_GROUP_GENERIC(L2_DROPS, 0),\n\tDEVLINK_TRAP_GROUP_GENERIC(L3_DROPS, 1),\n\tDEVLINK_TRAP_GROUP_GENERIC(L3_EXCEPTIONS, 1),\n\tDEVLINK_TRAP_GROUP_GENERIC(BUFFER_DROPS, 2),\n\tDEVLINK_TRAP_GROUP_GENERIC(ACL_DROPS, 3),\n\tDEVLINK_TRAP_GROUP_GENERIC(MC_SNOOPING, 3),\n};\n\nstatic const struct devlink_trap nsim_traps_arr[] = {\n\tNSIM_TRAP_DROP(SMAC_MC, L2_DROPS),\n\tNSIM_TRAP_DROP(VLAN_TAG_MISMATCH, L2_DROPS),\n\tNSIM_TRAP_DROP(INGRESS_VLAN_FILTER, L2_DROPS),\n\tNSIM_TRAP_DROP(INGRESS_STP_FILTER, L2_DROPS),\n\tNSIM_TRAP_DROP(EMPTY_TX_LIST, L2_DROPS),\n\tNSIM_TRAP_DROP(PORT_LOOPBACK_FILTER, L2_DROPS),\n\tNSIM_TRAP_DRIVER_EXCEPTION(FID_MISS, L2_DROPS),\n\tNSIM_TRAP_DROP(BLACKHOLE_ROUTE, L3_DROPS),\n\tNSIM_TRAP_EXCEPTION(TTL_ERROR, L3_EXCEPTIONS),\n\tNSIM_TRAP_DROP(TAIL_DROP, BUFFER_DROPS),\n\tNSIM_TRAP_DROP_EXT(INGRESS_FLOW_ACTION_DROP, ACL_DROPS,\n\t\t\t   DEVLINK_TRAP_METADATA_TYPE_F_FA_COOKIE),\n\tNSIM_TRAP_DROP_EXT(EGRESS_FLOW_ACTION_DROP, ACL_DROPS,\n\t\t\t   DEVLINK_TRAP_METADATA_TYPE_F_FA_COOKIE),\n\tNSIM_TRAP_CONTROL(IGMP_QUERY, MC_SNOOPING, MIRROR),\n\tNSIM_TRAP_CONTROL(IGMP_V1_REPORT, MC_SNOOPING, TRAP),\n};\n\n#define NSIM_TRAP_L4_DATA_LEN 100\n\nstatic struct sk_buff *nsim_dev_trap_skb_build(void)\n{\n\tint tot_len, data_len = NSIM_TRAP_L4_DATA_LEN;\n\tstruct sk_buff *skb;\n\tstruct udphdr *udph;\n\tstruct ethhdr *eth;\n\tstruct iphdr *iph;\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn NULL;\n\ttot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + data_len;\n\n\tskb_reset_mac_header(skb);\n\teth = skb_put(skb, sizeof(struct ethhdr));\n\teth_random_addr(eth->h_dest);\n\teth_random_addr(eth->h_source);\n\teth->h_proto = htons(ETH_P_IP);\n\tskb->protocol = htons(ETH_P_IP);\n\n\tskb_set_network_header(skb, skb->len);\n\tiph = skb_put(skb, sizeof(struct iphdr));\n\tiph->protocol = IPPROTO_UDP;\n\tiph->saddr = in_aton(\"192.0.2.1\");\n\tiph->daddr = in_aton(\"198.51.100.1\");\n\tiph->version = 0x4;\n\tiph->frag_off = 0;\n\tiph->ihl = 0x5;\n\tiph->tot_len = htons(tot_len);\n\tiph->ttl = 100;\n\tiph->check = 0;\n\tiph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);\n\n\tskb_set_transport_header(skb, skb->len);\n\tudph = skb_put_zero(skb, sizeof(struct udphdr) + data_len);\n\tget_random_bytes(&udph->source, sizeof(u16));\n\tget_random_bytes(&udph->dest, sizeof(u16));\n\tudph->len = htons(sizeof(struct udphdr) + data_len);\n\n\treturn skb;\n}\n\nstatic void nsim_dev_trap_report(struct nsim_dev_port *nsim_dev_port)\n{\n\tstruct nsim_dev *nsim_dev = nsim_dev_port->ns->nsim_dev;\n\tstruct devlink *devlink = priv_to_devlink(nsim_dev);\n\tstruct nsim_trap_data *nsim_trap_data;\n\tint i;\n\n\tnsim_trap_data = nsim_dev->trap_data;\n\n\tspin_lock(&nsim_trap_data->trap_lock);\n\tfor (i = 0; i < ARRAY_SIZE(nsim_traps_arr); i++) {\n\t\tstruct flow_action_cookie *fa_cookie = NULL;\n\t\tstruct nsim_trap_item *nsim_trap_item;\n\t\tstruct sk_buff *skb;\n\t\tbool has_fa_cookie;\n\n\t\thas_fa_cookie = nsim_traps_arr[i].metadata_cap &\n\t\t\t\tDEVLINK_TRAP_METADATA_TYPE_F_FA_COOKIE;\n\n\t\tnsim_trap_item = &nsim_trap_data->trap_items_arr[i];\n\t\tif (nsim_trap_item->action == DEVLINK_TRAP_ACTION_DROP)\n\t\t\tcontinue;\n\n\t\tskb = nsim_dev_trap_skb_build();\n\t\tif (!skb)\n\t\t\tcontinue;\n\t\tskb->dev = nsim_dev_port->ns->netdev;\n\n\t\t \n\n\t\tspin_lock_bh(&nsim_dev->fa_cookie_lock);\n\t\tfa_cookie = has_fa_cookie ? nsim_dev->fa_cookie : NULL;\n\t\tdevlink_trap_report(devlink, skb, nsim_trap_item->trap_ctx,\n\t\t\t\t    &nsim_dev_port->devlink_port, fa_cookie);\n\t\tspin_unlock_bh(&nsim_dev->fa_cookie_lock);\n\t\tconsume_skb(skb);\n\t}\n\tspin_unlock(&nsim_trap_data->trap_lock);\n}\n\n#define NSIM_TRAP_REPORT_INTERVAL_MS\t100\n\nstatic void nsim_dev_trap_report_work(struct work_struct *work)\n{\n\tstruct nsim_trap_data *nsim_trap_data;\n\tstruct nsim_dev_port *nsim_dev_port;\n\tstruct nsim_dev *nsim_dev;\n\n\tnsim_trap_data = container_of(work, struct nsim_trap_data,\n\t\t\t\t      trap_report_dw.work);\n\tnsim_dev = nsim_trap_data->nsim_dev;\n\n\t \n\tif (!devl_trylock(priv_to_devlink(nsim_dev))) {\n\t\tschedule_delayed_work(&nsim_dev->trap_data->trap_report_dw, 0);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(nsim_dev_port, &nsim_dev->port_list, list) {\n\t\tif (!netif_running(nsim_dev_port->ns->netdev))\n\t\t\tcontinue;\n\n\t\tnsim_dev_trap_report(nsim_dev_port);\n\t}\n\tdevl_unlock(priv_to_devlink(nsim_dev));\n\n\tschedule_delayed_work(&nsim_dev->trap_data->trap_report_dw,\n\t\t\t      msecs_to_jiffies(NSIM_TRAP_REPORT_INTERVAL_MS));\n}\n\nstatic int nsim_dev_traps_init(struct devlink *devlink)\n{\n\tsize_t policers_count = ARRAY_SIZE(nsim_trap_policers_arr);\n\tstruct nsim_dev *nsim_dev = devlink_priv(devlink);\n\tstruct nsim_trap_data *nsim_trap_data;\n\tint err;\n\n\tnsim_trap_data = kzalloc(sizeof(*nsim_trap_data), GFP_KERNEL);\n\tif (!nsim_trap_data)\n\t\treturn -ENOMEM;\n\n\tnsim_trap_data->trap_items_arr = kcalloc(ARRAY_SIZE(nsim_traps_arr),\n\t\t\t\t\t\t sizeof(struct nsim_trap_item),\n\t\t\t\t\t\t GFP_KERNEL);\n\tif (!nsim_trap_data->trap_items_arr) {\n\t\terr = -ENOMEM;\n\t\tgoto err_trap_data_free;\n\t}\n\n\tnsim_trap_data->trap_policers_cnt_arr = kcalloc(policers_count,\n\t\t\t\t\t\t\tsizeof(u64),\n\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!nsim_trap_data->trap_policers_cnt_arr) {\n\t\terr = -ENOMEM;\n\t\tgoto err_trap_items_free;\n\t}\n\n\t \n\tspin_lock_init(&nsim_trap_data->trap_lock);\n\tnsim_trap_data->nsim_dev = nsim_dev;\n\tnsim_dev->trap_data = nsim_trap_data;\n\n\terr = devl_trap_policers_register(devlink, nsim_trap_policers_arr,\n\t\t\t\t\t  policers_count);\n\tif (err)\n\t\tgoto err_trap_policers_cnt_free;\n\n\terr = devl_trap_groups_register(devlink, nsim_trap_groups_arr,\n\t\t\t\t\tARRAY_SIZE(nsim_trap_groups_arr));\n\tif (err)\n\t\tgoto err_trap_policers_unregister;\n\n\terr = devl_traps_register(devlink, nsim_traps_arr,\n\t\t\t\t  ARRAY_SIZE(nsim_traps_arr), NULL);\n\tif (err)\n\t\tgoto err_trap_groups_unregister;\n\n\tINIT_DELAYED_WORK(&nsim_dev->trap_data->trap_report_dw,\n\t\t\t  nsim_dev_trap_report_work);\n\tschedule_delayed_work(&nsim_dev->trap_data->trap_report_dw,\n\t\t\t      msecs_to_jiffies(NSIM_TRAP_REPORT_INTERVAL_MS));\n\n\treturn 0;\n\nerr_trap_groups_unregister:\n\tdevl_trap_groups_unregister(devlink, nsim_trap_groups_arr,\n\t\t\t\t    ARRAY_SIZE(nsim_trap_groups_arr));\nerr_trap_policers_unregister:\n\tdevl_trap_policers_unregister(devlink, nsim_trap_policers_arr,\n\t\t\t\t      ARRAY_SIZE(nsim_trap_policers_arr));\nerr_trap_policers_cnt_free:\n\tkfree(nsim_trap_data->trap_policers_cnt_arr);\nerr_trap_items_free:\n\tkfree(nsim_trap_data->trap_items_arr);\nerr_trap_data_free:\n\tkfree(nsim_trap_data);\n\treturn err;\n}\n\nstatic void nsim_dev_traps_exit(struct devlink *devlink)\n{\n\tstruct nsim_dev *nsim_dev = devlink_priv(devlink);\n\n\t \n\tcancel_delayed_work_sync(&nsim_dev->trap_data->trap_report_dw);\n\tdevl_traps_unregister(devlink, nsim_traps_arr,\n\t\t\t      ARRAY_SIZE(nsim_traps_arr));\n\tdevl_trap_groups_unregister(devlink, nsim_trap_groups_arr,\n\t\t\t\t    ARRAY_SIZE(nsim_trap_groups_arr));\n\tdevl_trap_policers_unregister(devlink, nsim_trap_policers_arr,\n\t\t\t\t      ARRAY_SIZE(nsim_trap_policers_arr));\n\tkfree(nsim_dev->trap_data->trap_policers_cnt_arr);\n\tkfree(nsim_dev->trap_data->trap_items_arr);\n\tkfree(nsim_dev->trap_data);\n}\n\nstatic int nsim_dev_reload_create(struct nsim_dev *nsim_dev,\n\t\t\t\t  struct netlink_ext_ack *extack);\nstatic void nsim_dev_reload_destroy(struct nsim_dev *nsim_dev);\n\nstatic int nsim_dev_reload_down(struct devlink *devlink, bool netns_change,\n\t\t\t\tenum devlink_reload_action action, enum devlink_reload_limit limit,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct nsim_dev *nsim_dev = devlink_priv(devlink);\n\n\tif (nsim_dev->dont_allow_reload) {\n\t\t \n\t\tNL_SET_ERR_MSG_MOD(extack, \"User forbid the reload for testing purposes\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tnsim_dev_reload_destroy(nsim_dev);\n\treturn 0;\n}\n\nstatic int nsim_dev_reload_up(struct devlink *devlink, enum devlink_reload_action action,\n\t\t\t      enum devlink_reload_limit limit, u32 *actions_performed,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct nsim_dev *nsim_dev = devlink_priv(devlink);\n\n\tif (nsim_dev->fail_reload) {\n\t\t \n\t\tNL_SET_ERR_MSG_MOD(extack, \"User setup the reload to fail for testing purposes\");\n\t\treturn -EINVAL;\n\t}\n\n\t*actions_performed = BIT(DEVLINK_RELOAD_ACTION_DRIVER_REINIT);\n\n\treturn nsim_dev_reload_create(nsim_dev, extack);\n}\n\nstatic int nsim_dev_info_get(struct devlink *devlink,\n\t\t\t     struct devlink_info_req *req,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tint err;\n\n\terr = devlink_info_version_stored_put_ext(req, \"fw.mgmt\", \"10.20.30\",\n\t\t\t\t\t\t  DEVLINK_INFO_VERSION_TYPE_COMPONENT);\n\tif (err)\n\t\treturn err;\n\treturn devlink_info_version_running_put_ext(req, \"fw.mgmt\", \"10.20.30\",\n\t\t\t\t\t\t    DEVLINK_INFO_VERSION_TYPE_COMPONENT);\n}\n\n#define NSIM_DEV_FLASH_SIZE 500000\n#define NSIM_DEV_FLASH_CHUNK_SIZE 1000\n#define NSIM_DEV_FLASH_CHUNK_TIME_MS 10\n\nstatic int nsim_dev_flash_update(struct devlink *devlink,\n\t\t\t\t struct devlink_flash_update_params *params,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct nsim_dev *nsim_dev = devlink_priv(devlink);\n\tint i;\n\n\tif ((params->overwrite_mask & ~nsim_dev->fw_update_overwrite_mask) != 0)\n\t\treturn -EOPNOTSUPP;\n\n\tif (nsim_dev->fw_update_status) {\n\t\tdevlink_flash_update_status_notify(devlink,\n\t\t\t\t\t\t   \"Preparing to flash\",\n\t\t\t\t\t\t   params->component, 0, 0);\n\t}\n\n\tfor (i = 0; i < NSIM_DEV_FLASH_SIZE / NSIM_DEV_FLASH_CHUNK_SIZE; i++) {\n\t\tif (nsim_dev->fw_update_status)\n\t\t\tdevlink_flash_update_status_notify(devlink, \"Flashing\",\n\t\t\t\t\t\t\t   params->component,\n\t\t\t\t\t\t\t   i * NSIM_DEV_FLASH_CHUNK_SIZE,\n\t\t\t\t\t\t\t   NSIM_DEV_FLASH_SIZE);\n\t\tmsleep(NSIM_DEV_FLASH_CHUNK_TIME_MS);\n\t}\n\n\tif (nsim_dev->fw_update_status) {\n\t\tdevlink_flash_update_status_notify(devlink, \"Flashing\",\n\t\t\t\t\t\t   params->component,\n\t\t\t\t\t\t   NSIM_DEV_FLASH_SIZE,\n\t\t\t\t\t\t   NSIM_DEV_FLASH_SIZE);\n\t\tdevlink_flash_update_timeout_notify(devlink, \"Flash select\",\n\t\t\t\t\t\t    params->component, 81);\n\t\tdevlink_flash_update_status_notify(devlink, \"Flashing done\",\n\t\t\t\t\t\t   params->component, 0, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic struct nsim_trap_item *\nnsim_dev_trap_item_lookup(struct nsim_dev *nsim_dev, u16 trap_id)\n{\n\tstruct nsim_trap_data *nsim_trap_data = nsim_dev->trap_data;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(nsim_traps_arr); i++) {\n\t\tif (nsim_traps_arr[i].id == trap_id)\n\t\t\treturn &nsim_trap_data->trap_items_arr[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic int nsim_dev_devlink_trap_init(struct devlink *devlink,\n\t\t\t\t      const struct devlink_trap *trap,\n\t\t\t\t      void *trap_ctx)\n{\n\tstruct nsim_dev *nsim_dev = devlink_priv(devlink);\n\tstruct nsim_trap_item *nsim_trap_item;\n\n\tnsim_trap_item = nsim_dev_trap_item_lookup(nsim_dev, trap->id);\n\tif (WARN_ON(!nsim_trap_item))\n\t\treturn -ENOENT;\n\n\tnsim_trap_item->trap_ctx = trap_ctx;\n\tnsim_trap_item->action = trap->init_action;\n\n\treturn 0;\n}\n\nstatic int\nnsim_dev_devlink_trap_action_set(struct devlink *devlink,\n\t\t\t\t const struct devlink_trap *trap,\n\t\t\t\t enum devlink_trap_action action,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct nsim_dev *nsim_dev = devlink_priv(devlink);\n\tstruct nsim_trap_item *nsim_trap_item;\n\n\tnsim_trap_item = nsim_dev_trap_item_lookup(nsim_dev, trap->id);\n\tif (WARN_ON(!nsim_trap_item))\n\t\treturn -ENOENT;\n\n\tspin_lock(&nsim_dev->trap_data->trap_lock);\n\tnsim_trap_item->action = action;\n\tspin_unlock(&nsim_dev->trap_data->trap_lock);\n\n\treturn 0;\n}\n\nstatic int\nnsim_dev_devlink_trap_group_set(struct devlink *devlink,\n\t\t\t\tconst struct devlink_trap_group *group,\n\t\t\t\tconst struct devlink_trap_policer *policer,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct nsim_dev *nsim_dev = devlink_priv(devlink);\n\n\tif (nsim_dev->fail_trap_group_set)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int\nnsim_dev_devlink_trap_policer_set(struct devlink *devlink,\n\t\t\t\t  const struct devlink_trap_policer *policer,\n\t\t\t\t  u64 rate, u64 burst,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct nsim_dev *nsim_dev = devlink_priv(devlink);\n\n\tif (nsim_dev->fail_trap_policer_set) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"User setup the operation to fail for testing purposes\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnsim_dev_devlink_trap_policer_counter_get(struct devlink *devlink,\n\t\t\t\t\t  const struct devlink_trap_policer *policer,\n\t\t\t\t\t  u64 *p_drops)\n{\n\tstruct nsim_dev *nsim_dev = devlink_priv(devlink);\n\tu64 *cnt;\n\n\tif (nsim_dev->fail_trap_policer_counter_get)\n\t\treturn -EINVAL;\n\n\tcnt = &nsim_dev->trap_data->trap_policers_cnt_arr[policer->id - 1];\n\t*p_drops = (*cnt)++;\n\n\treturn 0;\n}\n\n#define NSIM_LINK_SPEED_MAX     5000  \n#define NSIM_LINK_SPEED_UNIT    125000  \n\nstatic int nsim_rate_bytes_to_units(char *name, u64 *rate, struct netlink_ext_ack *extack)\n{\n\tu64 val;\n\tu32 rem;\n\n\tval = div_u64_rem(*rate, NSIM_LINK_SPEED_UNIT, &rem);\n\tif (rem) {\n\t\tpr_err(\"%s rate value %lluBps not in link speed units of 1Mbps.\\n\",\n\t\t       name, *rate);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"TX rate value not in link speed units of 1Mbps.\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (val > NSIM_LINK_SPEED_MAX) {\n\t\tpr_err(\"%s rate value %lluMbps exceed link maximum speed 5000Mbps.\\n\",\n\t\t       name, val);\n\t\tNL_SET_ERR_MSG_MOD(extack, \"TX rate value exceed link maximum speed 5000Mbps.\");\n\t\treturn -EINVAL;\n\t}\n\t*rate = val;\n\treturn 0;\n}\n\nstatic int nsim_leaf_tx_share_set(struct devlink_rate *devlink_rate, void *priv,\n\t\t\t\t  u64 tx_share, struct netlink_ext_ack *extack)\n{\n\tstruct nsim_dev_port *nsim_dev_port = priv;\n\tstruct nsim_dev *nsim_dev = nsim_dev_port->ns->nsim_dev;\n\tint vf_id = nsim_dev_port_index_to_vf_index(nsim_dev_port->port_index);\n\tint err;\n\n\terr = nsim_rate_bytes_to_units(\"tx_share\", &tx_share, extack);\n\tif (err)\n\t\treturn err;\n\n\tnsim_dev->vfconfigs[vf_id].min_tx_rate = tx_share;\n\treturn 0;\n}\n\nstatic int nsim_leaf_tx_max_set(struct devlink_rate *devlink_rate, void *priv,\n\t\t\t\tu64 tx_max, struct netlink_ext_ack *extack)\n{\n\tstruct nsim_dev_port *nsim_dev_port = priv;\n\tstruct nsim_dev *nsim_dev = nsim_dev_port->ns->nsim_dev;\n\tint vf_id = nsim_dev_port_index_to_vf_index(nsim_dev_port->port_index);\n\tint err;\n\n\terr = nsim_rate_bytes_to_units(\"tx_max\", &tx_max, extack);\n\tif (err)\n\t\treturn err;\n\n\tnsim_dev->vfconfigs[vf_id].max_tx_rate = tx_max;\n\treturn 0;\n}\n\nstruct nsim_rate_node {\n\tstruct dentry *ddir;\n\tstruct dentry *rate_parent;\n\tchar *parent_name;\n\tu16 tx_share;\n\tu16 tx_max;\n};\n\nstatic int nsim_node_tx_share_set(struct devlink_rate *devlink_rate, void *priv,\n\t\t\t\t  u64 tx_share, struct netlink_ext_ack *extack)\n{\n\tstruct nsim_rate_node *nsim_node = priv;\n\tint err;\n\n\terr = nsim_rate_bytes_to_units(\"tx_share\", &tx_share, extack);\n\tif (err)\n\t\treturn err;\n\n\tnsim_node->tx_share = tx_share;\n\treturn 0;\n}\n\nstatic int nsim_node_tx_max_set(struct devlink_rate *devlink_rate, void *priv,\n\t\t\t\tu64 tx_max, struct netlink_ext_ack *extack)\n{\n\tstruct nsim_rate_node *nsim_node = priv;\n\tint err;\n\n\terr = nsim_rate_bytes_to_units(\"tx_max\", &tx_max, extack);\n\tif (err)\n\t\treturn err;\n\n\tnsim_node->tx_max = tx_max;\n\treturn 0;\n}\n\nstatic int nsim_rate_node_new(struct devlink_rate *node, void **priv,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct nsim_dev *nsim_dev = devlink_priv(node->devlink);\n\tstruct nsim_rate_node *nsim_node;\n\n\tif (!nsim_esw_mode_is_switchdev(nsim_dev)) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Node creation allowed only in switchdev mode.\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tnsim_node = kzalloc(sizeof(*nsim_node), GFP_KERNEL);\n\tif (!nsim_node)\n\t\treturn -ENOMEM;\n\n\tnsim_node->ddir = debugfs_create_dir(node->name, nsim_dev->nodes_ddir);\n\n\tdebugfs_create_u16(\"tx_share\", 0400, nsim_node->ddir, &nsim_node->tx_share);\n\tdebugfs_create_u16(\"tx_max\", 0400, nsim_node->ddir, &nsim_node->tx_max);\n\tnsim_node->rate_parent = debugfs_create_file(\"rate_parent\", 0400,\n\t\t\t\t\t\t     nsim_node->ddir,\n\t\t\t\t\t\t     &nsim_node->parent_name,\n\t\t\t\t\t\t     &nsim_dev_rate_parent_fops);\n\n\t*priv = nsim_node;\n\treturn 0;\n}\n\nstatic int nsim_rate_node_del(struct devlink_rate *node, void *priv,\n\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct nsim_rate_node *nsim_node = priv;\n\n\tdebugfs_remove(nsim_node->rate_parent);\n\tdebugfs_remove_recursive(nsim_node->ddir);\n\tkfree(nsim_node);\n\treturn 0;\n}\n\nstatic int nsim_rate_leaf_parent_set(struct devlink_rate *child,\n\t\t\t\t     struct devlink_rate *parent,\n\t\t\t\t     void *priv_child, void *priv_parent,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct nsim_dev_port *nsim_dev_port = priv_child;\n\n\tif (parent)\n\t\tnsim_dev_port->parent_name = parent->name;\n\telse\n\t\tnsim_dev_port->parent_name = NULL;\n\treturn 0;\n}\n\nstatic int nsim_rate_node_parent_set(struct devlink_rate *child,\n\t\t\t\t     struct devlink_rate *parent,\n\t\t\t\t     void *priv_child, void *priv_parent,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct nsim_rate_node *nsim_node = priv_child;\n\n\tif (parent)\n\t\tnsim_node->parent_name = parent->name;\n\telse\n\t\tnsim_node->parent_name = NULL;\n\treturn 0;\n}\n\nstatic int\nnsim_dev_devlink_trap_drop_counter_get(struct devlink *devlink,\n\t\t\t\t       const struct devlink_trap *trap,\n\t\t\t\t       u64 *p_drops)\n{\n\tstruct nsim_dev *nsim_dev = devlink_priv(devlink);\n\tu64 *cnt;\n\n\tif (nsim_dev->fail_trap_drop_counter_get)\n\t\treturn -EINVAL;\n\n\tcnt = &nsim_dev->trap_data->trap_pkt_cnt;\n\t*p_drops = (*cnt)++;\n\n\treturn 0;\n}\n\nstatic const struct devlink_ops nsim_dev_devlink_ops = {\n\t.eswitch_mode_set = nsim_devlink_eswitch_mode_set,\n\t.eswitch_mode_get = nsim_devlink_eswitch_mode_get,\n\t.supported_flash_update_params = DEVLINK_SUPPORT_FLASH_UPDATE_OVERWRITE_MASK,\n\t.reload_actions = BIT(DEVLINK_RELOAD_ACTION_DRIVER_REINIT),\n\t.reload_down = nsim_dev_reload_down,\n\t.reload_up = nsim_dev_reload_up,\n\t.info_get = nsim_dev_info_get,\n\t.flash_update = nsim_dev_flash_update,\n\t.trap_init = nsim_dev_devlink_trap_init,\n\t.trap_action_set = nsim_dev_devlink_trap_action_set,\n\t.trap_group_set = nsim_dev_devlink_trap_group_set,\n\t.trap_policer_set = nsim_dev_devlink_trap_policer_set,\n\t.trap_policer_counter_get = nsim_dev_devlink_trap_policer_counter_get,\n\t.rate_leaf_tx_share_set = nsim_leaf_tx_share_set,\n\t.rate_leaf_tx_max_set = nsim_leaf_tx_max_set,\n\t.rate_node_tx_share_set = nsim_node_tx_share_set,\n\t.rate_node_tx_max_set = nsim_node_tx_max_set,\n\t.rate_node_new = nsim_rate_node_new,\n\t.rate_node_del = nsim_rate_node_del,\n\t.rate_leaf_parent_set = nsim_rate_leaf_parent_set,\n\t.rate_node_parent_set = nsim_rate_node_parent_set,\n\t.trap_drop_counter_get = nsim_dev_devlink_trap_drop_counter_get,\n};\n\n#define NSIM_DEV_MAX_MACS_DEFAULT 32\n#define NSIM_DEV_TEST1_DEFAULT true\n\nstatic int __nsim_dev_port_add(struct nsim_dev *nsim_dev, enum nsim_dev_port_type type,\n\t\t\t       unsigned int port_index)\n{\n\tstruct devlink_port_attrs attrs = {};\n\tstruct nsim_dev_port *nsim_dev_port;\n\tstruct devlink_port *devlink_port;\n\tint err;\n\n\tif (type == NSIM_DEV_PORT_TYPE_VF && !nsim_dev_get_vfs(nsim_dev))\n\t\treturn -EINVAL;\n\n\tnsim_dev_port = kzalloc(sizeof(*nsim_dev_port), GFP_KERNEL);\n\tif (!nsim_dev_port)\n\t\treturn -ENOMEM;\n\tnsim_dev_port->port_index = nsim_dev_port_index(type, port_index);\n\tnsim_dev_port->port_type = type;\n\n\tdevlink_port = &nsim_dev_port->devlink_port;\n\tif (nsim_dev_port_is_pf(nsim_dev_port)) {\n\t\tattrs.flavour = DEVLINK_PORT_FLAVOUR_PHYSICAL;\n\t\tattrs.phys.port_number = port_index + 1;\n\t} else {\n\t\tattrs.flavour = DEVLINK_PORT_FLAVOUR_PCI_VF;\n\t\tattrs.pci_vf.pf = 0;\n\t\tattrs.pci_vf.vf = port_index;\n\t}\n\tmemcpy(attrs.switch_id.id, nsim_dev->switch_id.id, nsim_dev->switch_id.id_len);\n\tattrs.switch_id.id_len = nsim_dev->switch_id.id_len;\n\tdevlink_port_attrs_set(devlink_port, &attrs);\n\terr = devl_port_register(priv_to_devlink(nsim_dev), devlink_port,\n\t\t\t\t nsim_dev_port->port_index);\n\tif (err)\n\t\tgoto err_port_free;\n\n\terr = nsim_dev_port_debugfs_init(nsim_dev, nsim_dev_port);\n\tif (err)\n\t\tgoto err_dl_port_unregister;\n\n\tnsim_dev_port->ns = nsim_create(nsim_dev, nsim_dev_port);\n\tif (IS_ERR(nsim_dev_port->ns)) {\n\t\terr = PTR_ERR(nsim_dev_port->ns);\n\t\tgoto err_port_debugfs_exit;\n\t}\n\n\tif (nsim_dev_port_is_vf(nsim_dev_port)) {\n\t\terr = devl_rate_leaf_create(&nsim_dev_port->devlink_port,\n\t\t\t\t\t    nsim_dev_port, NULL);\n\t\tif (err)\n\t\t\tgoto err_nsim_destroy;\n\t}\n\n\tlist_add(&nsim_dev_port->list, &nsim_dev->port_list);\n\n\treturn 0;\n\nerr_nsim_destroy:\n\tnsim_destroy(nsim_dev_port->ns);\nerr_port_debugfs_exit:\n\tnsim_dev_port_debugfs_exit(nsim_dev_port);\nerr_dl_port_unregister:\n\tdevl_port_unregister(devlink_port);\nerr_port_free:\n\tkfree(nsim_dev_port);\n\treturn err;\n}\n\nstatic void __nsim_dev_port_del(struct nsim_dev_port *nsim_dev_port)\n{\n\tstruct devlink_port *devlink_port = &nsim_dev_port->devlink_port;\n\n\tlist_del(&nsim_dev_port->list);\n\tif (nsim_dev_port_is_vf(nsim_dev_port))\n\t\tdevl_rate_leaf_destroy(&nsim_dev_port->devlink_port);\n\tnsim_destroy(nsim_dev_port->ns);\n\tnsim_dev_port_debugfs_exit(nsim_dev_port);\n\tdevl_port_unregister(devlink_port);\n\tkfree(nsim_dev_port);\n}\n\nstatic void nsim_dev_port_del_all(struct nsim_dev *nsim_dev)\n{\n\tstruct nsim_dev_port *nsim_dev_port, *tmp;\n\n\tlist_for_each_entry_safe(nsim_dev_port, tmp,\n\t\t\t\t &nsim_dev->port_list, list)\n\t\t__nsim_dev_port_del(nsim_dev_port);\n}\n\nstatic int nsim_dev_port_add_all(struct nsim_dev *nsim_dev,\n\t\t\t\t unsigned int port_count)\n{\n\tint i, err;\n\n\tfor (i = 0; i < port_count; i++) {\n\t\terr = __nsim_dev_port_add(nsim_dev, NSIM_DEV_PORT_TYPE_PF, i);\n\t\tif (err)\n\t\t\tgoto err_port_del_all;\n\t}\n\treturn 0;\n\nerr_port_del_all:\n\tnsim_dev_port_del_all(nsim_dev);\n\treturn err;\n}\n\nstatic int nsim_dev_reload_create(struct nsim_dev *nsim_dev,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct nsim_bus_dev *nsim_bus_dev = nsim_dev->nsim_bus_dev;\n\tstruct devlink *devlink;\n\tint err;\n\n\tdevlink = priv_to_devlink(nsim_dev);\n\tnsim_dev = devlink_priv(devlink);\n\tINIT_LIST_HEAD(&nsim_dev->port_list);\n\tnsim_dev->fw_update_status = true;\n\tnsim_dev->fw_update_overwrite_mask = 0;\n\n\tnsim_devlink_param_load_driverinit_values(devlink);\n\n\terr = nsim_dev_dummy_region_init(nsim_dev, devlink);\n\tif (err)\n\t\treturn err;\n\n\terr = nsim_dev_traps_init(devlink);\n\tif (err)\n\t\tgoto err_dummy_region_exit;\n\n\tnsim_dev->fib_data = nsim_fib_create(devlink, extack);\n\tif (IS_ERR(nsim_dev->fib_data)) {\n\t\terr = PTR_ERR(nsim_dev->fib_data);\n\t\tgoto err_traps_exit;\n\t}\n\n\terr = nsim_dev_health_init(nsim_dev, devlink);\n\tif (err)\n\t\tgoto err_fib_destroy;\n\n\terr = nsim_dev_psample_init(nsim_dev);\n\tif (err)\n\t\tgoto err_health_exit;\n\n\terr = nsim_dev_hwstats_init(nsim_dev);\n\tif (err)\n\t\tgoto err_psample_exit;\n\n\terr = nsim_dev_port_add_all(nsim_dev, nsim_bus_dev->port_count);\n\tif (err)\n\t\tgoto err_hwstats_exit;\n\n\tnsim_dev->take_snapshot = debugfs_create_file(\"take_snapshot\",\n\t\t\t\t\t\t      0200,\n\t\t\t\t\t\t      nsim_dev->ddir,\n\t\t\t\t\t\t      nsim_dev,\n\t\t\t\t\t\t&nsim_dev_take_snapshot_fops);\n\treturn 0;\n\nerr_hwstats_exit:\n\tnsim_dev_hwstats_exit(nsim_dev);\nerr_psample_exit:\n\tnsim_dev_psample_exit(nsim_dev);\nerr_health_exit:\n\tnsim_dev_health_exit(nsim_dev);\nerr_fib_destroy:\n\tnsim_fib_destroy(devlink, nsim_dev->fib_data);\nerr_traps_exit:\n\tnsim_dev_traps_exit(devlink);\nerr_dummy_region_exit:\n\tnsim_dev_dummy_region_exit(nsim_dev);\n\treturn err;\n}\n\nint nsim_drv_probe(struct nsim_bus_dev *nsim_bus_dev)\n{\n\tstruct nsim_dev *nsim_dev;\n\tstruct devlink *devlink;\n\tint err;\n\n\tdevlink = devlink_alloc_ns(&nsim_dev_devlink_ops, sizeof(*nsim_dev),\n\t\t\t\t nsim_bus_dev->initial_net, &nsim_bus_dev->dev);\n\tif (!devlink)\n\t\treturn -ENOMEM;\n\tdevl_lock(devlink);\n\tnsim_dev = devlink_priv(devlink);\n\tnsim_dev->nsim_bus_dev = nsim_bus_dev;\n\tnsim_dev->switch_id.id_len = sizeof(nsim_dev->switch_id.id);\n\tget_random_bytes(nsim_dev->switch_id.id, nsim_dev->switch_id.id_len);\n\tINIT_LIST_HEAD(&nsim_dev->port_list);\n\tnsim_dev->fw_update_status = true;\n\tnsim_dev->fw_update_overwrite_mask = 0;\n\tnsim_dev->max_macs = NSIM_DEV_MAX_MACS_DEFAULT;\n\tnsim_dev->test1 = NSIM_DEV_TEST1_DEFAULT;\n\tspin_lock_init(&nsim_dev->fa_cookie_lock);\n\n\tdev_set_drvdata(&nsim_bus_dev->dev, nsim_dev);\n\n\tnsim_dev->vfconfigs = kcalloc(nsim_bus_dev->max_vfs,\n\t\t\t\t      sizeof(struct nsim_vf_config),\n\t\t\t\t      GFP_KERNEL | __GFP_NOWARN);\n\tif (!nsim_dev->vfconfigs) {\n\t\terr = -ENOMEM;\n\t\tgoto err_devlink_unlock;\n\t}\n\n\terr = devl_register(devlink);\n\tif (err)\n\t\tgoto err_vfc_free;\n\n\terr = nsim_dev_resources_register(devlink);\n\tif (err)\n\t\tgoto err_dl_unregister;\n\n\terr = devl_params_register(devlink, nsim_devlink_params,\n\t\t\t\t   ARRAY_SIZE(nsim_devlink_params));\n\tif (err)\n\t\tgoto err_resource_unregister;\n\tnsim_devlink_set_params_init_values(nsim_dev, devlink);\n\n\terr = nsim_dev_dummy_region_init(nsim_dev, devlink);\n\tif (err)\n\t\tgoto err_params_unregister;\n\n\terr = nsim_dev_traps_init(devlink);\n\tif (err)\n\t\tgoto err_dummy_region_exit;\n\n\terr = nsim_dev_debugfs_init(nsim_dev);\n\tif (err)\n\t\tgoto err_traps_exit;\n\n\tnsim_dev->fib_data = nsim_fib_create(devlink, NULL);\n\tif (IS_ERR(nsim_dev->fib_data)) {\n\t\terr = PTR_ERR(nsim_dev->fib_data);\n\t\tgoto err_debugfs_exit;\n\t}\n\n\terr = nsim_dev_health_init(nsim_dev, devlink);\n\tif (err)\n\t\tgoto err_fib_destroy;\n\n\terr = nsim_bpf_dev_init(nsim_dev);\n\tif (err)\n\t\tgoto err_health_exit;\n\n\terr = nsim_dev_psample_init(nsim_dev);\n\tif (err)\n\t\tgoto err_bpf_dev_exit;\n\n\terr = nsim_dev_hwstats_init(nsim_dev);\n\tif (err)\n\t\tgoto err_psample_exit;\n\n\terr = nsim_dev_port_add_all(nsim_dev, nsim_bus_dev->port_count);\n\tif (err)\n\t\tgoto err_hwstats_exit;\n\n\tnsim_dev->esw_mode = DEVLINK_ESWITCH_MODE_LEGACY;\n\tdevl_unlock(devlink);\n\treturn 0;\n\nerr_hwstats_exit:\n\tnsim_dev_hwstats_exit(nsim_dev);\nerr_psample_exit:\n\tnsim_dev_psample_exit(nsim_dev);\nerr_bpf_dev_exit:\n\tnsim_bpf_dev_exit(nsim_dev);\nerr_health_exit:\n\tnsim_dev_health_exit(nsim_dev);\nerr_fib_destroy:\n\tnsim_fib_destroy(devlink, nsim_dev->fib_data);\nerr_debugfs_exit:\n\tnsim_dev_debugfs_exit(nsim_dev);\nerr_traps_exit:\n\tnsim_dev_traps_exit(devlink);\nerr_dummy_region_exit:\n\tnsim_dev_dummy_region_exit(nsim_dev);\nerr_params_unregister:\n\tdevl_params_unregister(devlink, nsim_devlink_params,\n\t\t\t       ARRAY_SIZE(nsim_devlink_params));\nerr_resource_unregister:\n\tdevl_resources_unregister(devlink);\nerr_dl_unregister:\n\tdevl_unregister(devlink);\nerr_vfc_free:\n\tkfree(nsim_dev->vfconfigs);\nerr_devlink_unlock:\n\tdevl_unlock(devlink);\n\tdevlink_free(devlink);\n\tdev_set_drvdata(&nsim_bus_dev->dev, NULL);\n\treturn err;\n}\n\nstatic void nsim_dev_reload_destroy(struct nsim_dev *nsim_dev)\n{\n\tstruct devlink *devlink = priv_to_devlink(nsim_dev);\n\n\tif (devlink_is_reload_failed(devlink))\n\t\treturn;\n\tdebugfs_remove(nsim_dev->take_snapshot);\n\n\tif (nsim_dev_get_vfs(nsim_dev)) {\n\t\tnsim_bus_dev_set_vfs(nsim_dev->nsim_bus_dev, 0);\n\t\tif (nsim_esw_mode_is_switchdev(nsim_dev))\n\t\t\tnsim_esw_legacy_enable(nsim_dev, NULL);\n\t}\n\n\tnsim_dev_port_del_all(nsim_dev);\n\tnsim_dev_hwstats_exit(nsim_dev);\n\tnsim_dev_psample_exit(nsim_dev);\n\tnsim_dev_health_exit(nsim_dev);\n\tnsim_fib_destroy(devlink, nsim_dev->fib_data);\n\tnsim_dev_traps_exit(devlink);\n\tnsim_dev_dummy_region_exit(nsim_dev);\n}\n\nvoid nsim_drv_remove(struct nsim_bus_dev *nsim_bus_dev)\n{\n\tstruct nsim_dev *nsim_dev = dev_get_drvdata(&nsim_bus_dev->dev);\n\tstruct devlink *devlink = priv_to_devlink(nsim_dev);\n\n\tdevl_lock(devlink);\n\tnsim_dev_reload_destroy(nsim_dev);\n\n\tnsim_bpf_dev_exit(nsim_dev);\n\tnsim_dev_debugfs_exit(nsim_dev);\n\tdevl_params_unregister(devlink, nsim_devlink_params,\n\t\t\t       ARRAY_SIZE(nsim_devlink_params));\n\tdevl_resources_unregister(devlink);\n\tdevl_unregister(devlink);\n\tkfree(nsim_dev->vfconfigs);\n\tkfree(nsim_dev->fa_cookie);\n\tdevl_unlock(devlink);\n\tdevlink_free(devlink);\n\tdev_set_drvdata(&nsim_bus_dev->dev, NULL);\n}\n\nstatic struct nsim_dev_port *\n__nsim_dev_port_lookup(struct nsim_dev *nsim_dev, enum nsim_dev_port_type type,\n\t\t       unsigned int port_index)\n{\n\tstruct nsim_dev_port *nsim_dev_port;\n\n\tport_index = nsim_dev_port_index(type, port_index);\n\tlist_for_each_entry(nsim_dev_port, &nsim_dev->port_list, list)\n\t\tif (nsim_dev_port->port_index == port_index)\n\t\t\treturn nsim_dev_port;\n\treturn NULL;\n}\n\nint nsim_drv_port_add(struct nsim_bus_dev *nsim_bus_dev, enum nsim_dev_port_type type,\n\t\t      unsigned int port_index)\n{\n\tstruct nsim_dev *nsim_dev = dev_get_drvdata(&nsim_bus_dev->dev);\n\tint err;\n\n\tdevl_lock(priv_to_devlink(nsim_dev));\n\tif (__nsim_dev_port_lookup(nsim_dev, type, port_index))\n\t\terr = -EEXIST;\n\telse\n\t\terr = __nsim_dev_port_add(nsim_dev, type, port_index);\n\tdevl_unlock(priv_to_devlink(nsim_dev));\n\treturn err;\n}\n\nint nsim_drv_port_del(struct nsim_bus_dev *nsim_bus_dev, enum nsim_dev_port_type type,\n\t\t      unsigned int port_index)\n{\n\tstruct nsim_dev *nsim_dev = dev_get_drvdata(&nsim_bus_dev->dev);\n\tstruct nsim_dev_port *nsim_dev_port;\n\tint err = 0;\n\n\tdevl_lock(priv_to_devlink(nsim_dev));\n\tnsim_dev_port = __nsim_dev_port_lookup(nsim_dev, type, port_index);\n\tif (!nsim_dev_port)\n\t\terr = -ENOENT;\n\telse\n\t\t__nsim_dev_port_del(nsim_dev_port);\n\tdevl_unlock(priv_to_devlink(nsim_dev));\n\treturn err;\n}\n\nint nsim_drv_configure_vfs(struct nsim_bus_dev *nsim_bus_dev,\n\t\t\t   unsigned int num_vfs)\n{\n\tstruct nsim_dev *nsim_dev = dev_get_drvdata(&nsim_bus_dev->dev);\n\tstruct devlink *devlink = priv_to_devlink(nsim_dev);\n\tint ret = 0;\n\n\tdevl_lock(devlink);\n\tif (nsim_bus_dev->num_vfs == num_vfs)\n\t\tgoto exit_unlock;\n\tif (nsim_bus_dev->num_vfs && num_vfs) {\n\t\tret = -EBUSY;\n\t\tgoto exit_unlock;\n\t}\n\tif (nsim_bus_dev->max_vfs < num_vfs) {\n\t\tret = -ENOMEM;\n\t\tgoto exit_unlock;\n\t}\n\n\tnsim_bus_dev_set_vfs(nsim_bus_dev, num_vfs);\n\tif (nsim_esw_mode_is_switchdev(nsim_dev)) {\n\t\tif (num_vfs) {\n\t\t\tret = nsim_esw_switchdev_enable(nsim_dev, NULL);\n\t\t\tif (ret) {\n\t\t\t\tnsim_bus_dev_set_vfs(nsim_bus_dev, 0);\n\t\t\t\tgoto exit_unlock;\n\t\t\t}\n\t\t} else {\n\t\t\tnsim_esw_legacy_enable(nsim_dev, NULL);\n\t\t}\n\t}\n\nexit_unlock:\n\tdevl_unlock(devlink);\n\n\treturn ret;\n}\n\nint nsim_dev_init(void)\n{\n\tnsim_dev_ddir = debugfs_create_dir(DRV_NAME, NULL);\n\treturn PTR_ERR_OR_ZERO(nsim_dev_ddir);\n}\n\nvoid nsim_dev_exit(void)\n{\n\tdebugfs_remove_recursive(nsim_dev_ddir);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}