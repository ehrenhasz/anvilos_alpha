{
  "module_name": "bus.c",
  "hash_id": "ec615293fba21c29e8369e3c6bd23e6c96972db61fbaf6ed3e0ae93183befb19",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/netdevsim/bus.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n\n#include \"netdevsim.h\"\n\nstatic DEFINE_IDA(nsim_bus_dev_ids);\nstatic LIST_HEAD(nsim_bus_dev_list);\nstatic DEFINE_MUTEX(nsim_bus_dev_list_lock);\nstatic bool nsim_bus_enable;\n\nstatic struct nsim_bus_dev *to_nsim_bus_dev(struct device *dev)\n{\n\treturn container_of(dev, struct nsim_bus_dev, dev);\n}\n\nstatic ssize_t\nnsim_bus_dev_numvfs_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct nsim_bus_dev *nsim_bus_dev = to_nsim_bus_dev(dev);\n\tunsigned int num_vfs;\n\tint ret;\n\n\tret = kstrtouint(buf, 0, &num_vfs);\n\tif (ret)\n\t\treturn ret;\n\n\tdevice_lock(dev);\n\tret = -ENOENT;\n\tif (dev_get_drvdata(dev))\n\t\tret = nsim_drv_configure_vfs(nsim_bus_dev, num_vfs);\n\tdevice_unlock(dev);\n\n\treturn ret ? ret : count;\n}\n\nstatic ssize_t\nnsim_bus_dev_numvfs_show(struct device *dev,\n\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct nsim_bus_dev *nsim_bus_dev = to_nsim_bus_dev(dev);\n\n\treturn sprintf(buf, \"%u\\n\", nsim_bus_dev->num_vfs);\n}\n\nstatic struct device_attribute nsim_bus_dev_numvfs_attr =\n\t__ATTR(sriov_numvfs, 0664, nsim_bus_dev_numvfs_show,\n\t       nsim_bus_dev_numvfs_store);\n\nstatic ssize_t\nnew_port_store(struct device *dev, struct device_attribute *attr,\n\t       const char *buf, size_t count)\n{\n\tstruct nsim_bus_dev *nsim_bus_dev = to_nsim_bus_dev(dev);\n\tunsigned int port_index;\n\tint ret;\n\n\t \n\tif (!smp_load_acquire(&nsim_bus_dev->init))\n\t\treturn -EBUSY;\n\tret = kstrtouint(buf, 0, &port_index);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nsim_drv_port_add(nsim_bus_dev, NSIM_DEV_PORT_TYPE_PF, port_index);\n\treturn ret ? ret : count;\n}\n\nstatic struct device_attribute nsim_bus_dev_new_port_attr = __ATTR_WO(new_port);\n\nstatic ssize_t\ndel_port_store(struct device *dev, struct device_attribute *attr,\n\t       const char *buf, size_t count)\n{\n\tstruct nsim_bus_dev *nsim_bus_dev = to_nsim_bus_dev(dev);\n\tunsigned int port_index;\n\tint ret;\n\n\t \n\tif (!smp_load_acquire(&nsim_bus_dev->init))\n\t\treturn -EBUSY;\n\tret = kstrtouint(buf, 0, &port_index);\n\tif (ret)\n\t\treturn ret;\n\n\tret = nsim_drv_port_del(nsim_bus_dev, NSIM_DEV_PORT_TYPE_PF, port_index);\n\treturn ret ? ret : count;\n}\n\nstatic struct device_attribute nsim_bus_dev_del_port_attr = __ATTR_WO(del_port);\n\nstatic struct attribute *nsim_bus_dev_attrs[] = {\n\t&nsim_bus_dev_numvfs_attr.attr,\n\t&nsim_bus_dev_new_port_attr.attr,\n\t&nsim_bus_dev_del_port_attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group nsim_bus_dev_attr_group = {\n\t.attrs = nsim_bus_dev_attrs,\n};\n\nstatic const struct attribute_group *nsim_bus_dev_attr_groups[] = {\n\t&nsim_bus_dev_attr_group,\n\tNULL,\n};\n\nstatic void nsim_bus_dev_release(struct device *dev)\n{\n\tstruct nsim_bus_dev *nsim_bus_dev;\n\n\tnsim_bus_dev = container_of(dev, struct nsim_bus_dev, dev);\n\tkfree(nsim_bus_dev);\n}\n\nstatic struct device_type nsim_bus_dev_type = {\n\t.groups = nsim_bus_dev_attr_groups,\n\t.release = nsim_bus_dev_release,\n};\n\nstatic struct nsim_bus_dev *\nnsim_bus_dev_new(unsigned int id, unsigned int port_count, unsigned int num_queues);\n\nstatic ssize_t\nnew_device_store(const struct bus_type *bus, const char *buf, size_t count)\n{\n\tunsigned int id, port_count, num_queues;\n\tstruct nsim_bus_dev *nsim_bus_dev;\n\tint err;\n\n\terr = sscanf(buf, \"%u %u %u\", &id, &port_count, &num_queues);\n\tswitch (err) {\n\tcase 1:\n\t\tport_count = 1;\n\t\tfallthrough;\n\tcase 2:\n\t\tnum_queues = 1;\n\t\tfallthrough;\n\tcase 3:\n\t\tif (id > INT_MAX) {\n\t\t\tpr_err(\"Value of \\\"id\\\" is too big.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Format for adding new device is \\\"id port_count num_queues\\\" (uint uint unit).\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&nsim_bus_dev_list_lock);\n\t \n\tif (!smp_load_acquire(&nsim_bus_enable)) {\n\t\terr = -EBUSY;\n\t\tgoto err;\n\t}\n\n\tnsim_bus_dev = nsim_bus_dev_new(id, port_count, num_queues);\n\tif (IS_ERR(nsim_bus_dev)) {\n\t\terr = PTR_ERR(nsim_bus_dev);\n\t\tgoto err;\n\t}\n\n\t \n\tsmp_store_release(&nsim_bus_dev->init, true);\n\n\tlist_add_tail(&nsim_bus_dev->list, &nsim_bus_dev_list);\n\tmutex_unlock(&nsim_bus_dev_list_lock);\n\n\treturn count;\nerr:\n\tmutex_unlock(&nsim_bus_dev_list_lock);\n\treturn err;\n}\nstatic BUS_ATTR_WO(new_device);\n\nstatic void nsim_bus_dev_del(struct nsim_bus_dev *nsim_bus_dev);\n\nstatic ssize_t\ndel_device_store(const struct bus_type *bus, const char *buf, size_t count)\n{\n\tstruct nsim_bus_dev *nsim_bus_dev, *tmp;\n\tunsigned int id;\n\tint err;\n\n\terr = sscanf(buf, \"%u\", &id);\n\tswitch (err) {\n\tcase 1:\n\t\tif (id > INT_MAX) {\n\t\t\tpr_err(\"Value of \\\"id\\\" is too big.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Format for deleting device is \\\"id\\\" (uint).\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = -ENOENT;\n\tmutex_lock(&nsim_bus_dev_list_lock);\n\t \n\tif (!smp_load_acquire(&nsim_bus_enable)) {\n\t\tmutex_unlock(&nsim_bus_dev_list_lock);\n\t\treturn -EBUSY;\n\t}\n\tlist_for_each_entry_safe(nsim_bus_dev, tmp, &nsim_bus_dev_list, list) {\n\t\tif (nsim_bus_dev->dev.id != id)\n\t\t\tcontinue;\n\t\tlist_del(&nsim_bus_dev->list);\n\t\tnsim_bus_dev_del(nsim_bus_dev);\n\t\terr = 0;\n\t\tbreak;\n\t}\n\tmutex_unlock(&nsim_bus_dev_list_lock);\n\treturn !err ? count : err;\n}\nstatic BUS_ATTR_WO(del_device);\n\nstatic struct attribute *nsim_bus_attrs[] = {\n\t&bus_attr_new_device.attr,\n\t&bus_attr_del_device.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(nsim_bus);\n\nstatic int nsim_bus_probe(struct device *dev)\n{\n\tstruct nsim_bus_dev *nsim_bus_dev = to_nsim_bus_dev(dev);\n\n\treturn nsim_drv_probe(nsim_bus_dev);\n}\n\nstatic void nsim_bus_remove(struct device *dev)\n{\n\tstruct nsim_bus_dev *nsim_bus_dev = to_nsim_bus_dev(dev);\n\n\tnsim_drv_remove(nsim_bus_dev);\n}\n\nstatic int nsim_num_vf(struct device *dev)\n{\n\tstruct nsim_bus_dev *nsim_bus_dev = to_nsim_bus_dev(dev);\n\n\treturn nsim_bus_dev->num_vfs;\n}\n\nstatic struct bus_type nsim_bus = {\n\t.name\t\t= DRV_NAME,\n\t.dev_name\t= DRV_NAME,\n\t.bus_groups\t= nsim_bus_groups,\n\t.probe\t\t= nsim_bus_probe,\n\t.remove\t\t= nsim_bus_remove,\n\t.num_vf\t\t= nsim_num_vf,\n};\n\n#define NSIM_BUS_DEV_MAX_VFS 4\n\nstatic struct nsim_bus_dev *\nnsim_bus_dev_new(unsigned int id, unsigned int port_count, unsigned int num_queues)\n{\n\tstruct nsim_bus_dev *nsim_bus_dev;\n\tint err;\n\n\tnsim_bus_dev = kzalloc(sizeof(*nsim_bus_dev), GFP_KERNEL);\n\tif (!nsim_bus_dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = ida_alloc_range(&nsim_bus_dev_ids, id, id, GFP_KERNEL);\n\tif (err < 0)\n\t\tgoto err_nsim_bus_dev_free;\n\tnsim_bus_dev->dev.id = err;\n\tnsim_bus_dev->dev.bus = &nsim_bus;\n\tnsim_bus_dev->dev.type = &nsim_bus_dev_type;\n\tnsim_bus_dev->port_count = port_count;\n\tnsim_bus_dev->num_queues = num_queues;\n\tnsim_bus_dev->initial_net = current->nsproxy->net_ns;\n\tnsim_bus_dev->max_vfs = NSIM_BUS_DEV_MAX_VFS;\n\t \n\tsmp_store_release(&nsim_bus_dev->init, false);\n\n\terr = device_register(&nsim_bus_dev->dev);\n\tif (err)\n\t\tgoto err_nsim_bus_dev_id_free;\n\n\treturn nsim_bus_dev;\n\nerr_nsim_bus_dev_id_free:\n\tida_free(&nsim_bus_dev_ids, nsim_bus_dev->dev.id);\n\tput_device(&nsim_bus_dev->dev);\n\tnsim_bus_dev = NULL;\nerr_nsim_bus_dev_free:\n\tkfree(nsim_bus_dev);\n\treturn ERR_PTR(err);\n}\n\nstatic void nsim_bus_dev_del(struct nsim_bus_dev *nsim_bus_dev)\n{\n\t \n\tsmp_store_release(&nsim_bus_dev->init, false);\n\tida_free(&nsim_bus_dev_ids, nsim_bus_dev->dev.id);\n\tdevice_unregister(&nsim_bus_dev->dev);\n}\n\nstatic struct device_driver nsim_driver = {\n\t.name\t\t= DRV_NAME,\n\t.bus\t\t= &nsim_bus,\n\t.owner\t\t= THIS_MODULE,\n};\n\nint nsim_bus_init(void)\n{\n\tint err;\n\n\terr = bus_register(&nsim_bus);\n\tif (err)\n\t\treturn err;\n\terr = driver_register(&nsim_driver);\n\tif (err)\n\t\tgoto err_bus_unregister;\n\t \n\tsmp_store_release(&nsim_bus_enable, true);\n\treturn 0;\n\nerr_bus_unregister:\n\tbus_unregister(&nsim_bus);\n\treturn err;\n}\n\nvoid nsim_bus_exit(void)\n{\n\tstruct nsim_bus_dev *nsim_bus_dev, *tmp;\n\n\t \n\tsmp_store_release(&nsim_bus_enable, false);\n\n\tmutex_lock(&nsim_bus_dev_list_lock);\n\tlist_for_each_entry_safe(nsim_bus_dev, tmp, &nsim_bus_dev_list, list) {\n\t\tlist_del(&nsim_bus_dev->list);\n\t\tnsim_bus_dev_del(nsim_bus_dev);\n\t}\n\tmutex_unlock(&nsim_bus_dev_list_lock);\n\n\tdriver_unregister(&nsim_driver);\n\tbus_unregister(&nsim_bus);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}