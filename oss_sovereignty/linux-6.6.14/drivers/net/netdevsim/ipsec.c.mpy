{
  "module_name": "ipsec.c",
  "hash_id": "87db4f03834839780ecb219138ffa009711d20f897eddb0eb1529059e9ecede5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/netdevsim/ipsec.c",
  "human_readable_source": "\n \n\n#include <crypto/aead.h>\n#include <linux/debugfs.h>\n#include <net/xfrm.h>\n\n#include \"netdevsim.h\"\n\n#define NSIM_IPSEC_AUTH_BITS\t128\n\nstatic ssize_t nsim_dbg_netdev_ops_read(struct file *filp,\n\t\t\t\t\tchar __user *buffer,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct netdevsim *ns = filp->private_data;\n\tstruct nsim_ipsec *ipsec = &ns->ipsec;\n\tsize_t bufsize;\n\tchar *buf, *p;\n\tint len;\n\tint i;\n\n\t \n\tbufsize = (ipsec->count * 4 * 60) + 60;\n\tbuf = kzalloc(bufsize, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tp = buf;\n\tp += scnprintf(p, bufsize - (p - buf),\n\t\t       \"SA count=%u tx=%u\\n\",\n\t\t       ipsec->count, ipsec->tx);\n\n\tfor (i = 0; i < NSIM_IPSEC_MAX_SA_COUNT; i++) {\n\t\tstruct nsim_sa *sap = &ipsec->sa[i];\n\n\t\tif (!sap->used)\n\t\t\tcontinue;\n\n\t\tp += scnprintf(p, bufsize - (p - buf),\n\t\t\t       \"sa[%i] %cx ipaddr=0x%08x %08x %08x %08x\\n\",\n\t\t\t       i, (sap->rx ? 'r' : 't'), sap->ipaddr[0],\n\t\t\t       sap->ipaddr[1], sap->ipaddr[2], sap->ipaddr[3]);\n\t\tp += scnprintf(p, bufsize - (p - buf),\n\t\t\t       \"sa[%i]    spi=0x%08x proto=0x%x salt=0x%08x crypt=%d\\n\",\n\t\t\t       i, be32_to_cpu(sap->xs->id.spi),\n\t\t\t       sap->xs->id.proto, sap->salt, sap->crypt);\n\t\tp += scnprintf(p, bufsize - (p - buf),\n\t\t\t       \"sa[%i]    key=0x%08x %08x %08x %08x\\n\",\n\t\t\t       i, sap->key[0], sap->key[1],\n\t\t\t       sap->key[2], sap->key[3]);\n\t}\n\n\tlen = simple_read_from_buffer(buffer, count, ppos, buf, p - buf);\n\n\tkfree(buf);\n\treturn len;\n}\n\nstatic const struct file_operations ipsec_dbg_fops = {\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.read = nsim_dbg_netdev_ops_read,\n};\n\nstatic int nsim_ipsec_find_empty_idx(struct nsim_ipsec *ipsec)\n{\n\tu32 i;\n\n\tif (ipsec->count == NSIM_IPSEC_MAX_SA_COUNT)\n\t\treturn -ENOSPC;\n\n\t \n\tfor (i = 0; i < NSIM_IPSEC_MAX_SA_COUNT; i++) {\n\t\tif (!ipsec->sa[i].used)\n\t\t\treturn i;\n\t}\n\n\treturn -ENOSPC;\n}\n\nstatic int nsim_ipsec_parse_proto_keys(struct xfrm_state *xs,\n\t\t\t\t       u32 *mykey, u32 *mysalt)\n{\n\tconst char aes_gcm_name[] = \"rfc4106(gcm(aes))\";\n\tstruct net_device *dev = xs->xso.real_dev;\n\tunsigned char *key_data;\n\tchar *alg_name = NULL;\n\tint key_len;\n\n\tif (!xs->aead) {\n\t\tnetdev_err(dev, \"Unsupported IPsec algorithm\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (xs->aead->alg_icv_len != NSIM_IPSEC_AUTH_BITS) {\n\t\tnetdev_err(dev, \"IPsec offload requires %d bit authentication\\n\",\n\t\t\t   NSIM_IPSEC_AUTH_BITS);\n\t\treturn -EINVAL;\n\t}\n\n\tkey_data = &xs->aead->alg_key[0];\n\tkey_len = xs->aead->alg_key_len;\n\talg_name = xs->aead->alg_name;\n\n\tif (strcmp(alg_name, aes_gcm_name)) {\n\t\tnetdev_err(dev, \"Unsupported IPsec algorithm - please use %s\\n\",\n\t\t\t   aes_gcm_name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (key_len > NSIM_IPSEC_AUTH_BITS) {\n\t\t*mysalt = ((u32 *)key_data)[4];\n\t} else if (key_len == NSIM_IPSEC_AUTH_BITS) {\n\t\t*mysalt = 0;\n\t} else {\n\t\tnetdev_err(dev, \"IPsec hw offload only supports 128 bit keys with optional 32 bit salt\\n\");\n\t\treturn -EINVAL;\n\t}\n\tmemcpy(mykey, key_data, 16);\n\n\treturn 0;\n}\n\nstatic int nsim_ipsec_add_sa(struct xfrm_state *xs,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct nsim_ipsec *ipsec;\n\tstruct net_device *dev;\n\tstruct netdevsim *ns;\n\tstruct nsim_sa sa;\n\tu16 sa_idx;\n\tint ret;\n\n\tdev = xs->xso.real_dev;\n\tns = netdev_priv(dev);\n\tipsec = &ns->ipsec;\n\n\tif (xs->id.proto != IPPROTO_ESP && xs->id.proto != IPPROTO_AH) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported protocol for ipsec offload\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (xs->calg) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Compression offload not supported\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (xs->xso.type != XFRM_DEV_OFFLOAD_CRYPTO) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Unsupported ipsec offload type\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = nsim_ipsec_find_empty_idx(ipsec);\n\tif (ret < 0) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"No space for SA in Rx table!\");\n\t\treturn ret;\n\t}\n\tsa_idx = (u16)ret;\n\n\tmemset(&sa, 0, sizeof(sa));\n\tsa.used = true;\n\tsa.xs = xs;\n\n\tif (sa.xs->id.proto & IPPROTO_ESP)\n\t\tsa.crypt = xs->ealg || xs->aead;\n\n\t \n\tret = nsim_ipsec_parse_proto_keys(xs, sa.key, &sa.salt);\n\tif (ret) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to get key data for SA table\");\n\t\treturn ret;\n\t}\n\n\tif (xs->xso.dir == XFRM_DEV_OFFLOAD_IN) {\n\t\tsa.rx = true;\n\n\t\tif (xs->props.family == AF_INET6)\n\t\t\tmemcpy(sa.ipaddr, &xs->id.daddr.a6, 16);\n\t\telse\n\t\t\tmemcpy(&sa.ipaddr[3], &xs->id.daddr.a4, 4);\n\t}\n\n\t \n\tmemcpy(&ipsec->sa[sa_idx], &sa, sizeof(sa));\n\n\t \n\txs->xso.offload_handle = sa_idx | NSIM_IPSEC_VALID;\n\tipsec->count++;\n\n\treturn 0;\n}\n\nstatic void nsim_ipsec_del_sa(struct xfrm_state *xs)\n{\n\tstruct netdevsim *ns = netdev_priv(xs->xso.real_dev);\n\tstruct nsim_ipsec *ipsec = &ns->ipsec;\n\tu16 sa_idx;\n\n\tsa_idx = xs->xso.offload_handle & ~NSIM_IPSEC_VALID;\n\tif (!ipsec->sa[sa_idx].used) {\n\t\tnetdev_err(ns->netdev, \"Invalid SA for delete sa_idx=%d\\n\",\n\t\t\t   sa_idx);\n\t\treturn;\n\t}\n\n\tmemset(&ipsec->sa[sa_idx], 0, sizeof(struct nsim_sa));\n\tipsec->count--;\n}\n\nstatic bool nsim_ipsec_offload_ok(struct sk_buff *skb, struct xfrm_state *xs)\n{\n\tstruct netdevsim *ns = netdev_priv(xs->xso.real_dev);\n\tstruct nsim_ipsec *ipsec = &ns->ipsec;\n\n\tipsec->ok++;\n\n\treturn true;\n}\n\nstatic const struct xfrmdev_ops nsim_xfrmdev_ops = {\n\t.xdo_dev_state_add\t= nsim_ipsec_add_sa,\n\t.xdo_dev_state_delete\t= nsim_ipsec_del_sa,\n\t.xdo_dev_offload_ok\t= nsim_ipsec_offload_ok,\n};\n\nbool nsim_ipsec_tx(struct netdevsim *ns, struct sk_buff *skb)\n{\n\tstruct sec_path *sp = skb_sec_path(skb);\n\tstruct nsim_ipsec *ipsec = &ns->ipsec;\n\tstruct xfrm_state *xs;\n\tstruct nsim_sa *tsa;\n\tu32 sa_idx;\n\n\t \n\tif (!sp)\n\t\treturn true;\n\n\tif (unlikely(!sp->len)) {\n\t\tnetdev_err(ns->netdev, \"no xfrm state len = %d\\n\",\n\t\t\t   sp->len);\n\t\treturn false;\n\t}\n\n\txs = xfrm_input_state(skb);\n\tif (unlikely(!xs)) {\n\t\tnetdev_err(ns->netdev, \"no xfrm_input_state() xs = %p\\n\", xs);\n\t\treturn false;\n\t}\n\n\tsa_idx = xs->xso.offload_handle & ~NSIM_IPSEC_VALID;\n\tif (unlikely(sa_idx >= NSIM_IPSEC_MAX_SA_COUNT)) {\n\t\tnetdev_err(ns->netdev, \"bad sa_idx=%d max=%d\\n\",\n\t\t\t   sa_idx, NSIM_IPSEC_MAX_SA_COUNT);\n\t\treturn false;\n\t}\n\n\ttsa = &ipsec->sa[sa_idx];\n\tif (unlikely(!tsa->used)) {\n\t\tnetdev_err(ns->netdev, \"unused sa_idx=%d\\n\", sa_idx);\n\t\treturn false;\n\t}\n\n\tif (xs->id.proto != IPPROTO_ESP && xs->id.proto != IPPROTO_AH) {\n\t\tnetdev_err(ns->netdev, \"unexpected proto=%d\\n\", xs->id.proto);\n\t\treturn false;\n\t}\n\n\tipsec->tx++;\n\n\treturn true;\n}\n\nvoid nsim_ipsec_init(struct netdevsim *ns)\n{\n\tns->netdev->xfrmdev_ops = &nsim_xfrmdev_ops;\n\n#define NSIM_ESP_FEATURES\t(NETIF_F_HW_ESP | \\\n\t\t\t\t NETIF_F_HW_ESP_TX_CSUM | \\\n\t\t\t\t NETIF_F_GSO_ESP)\n\n\tns->netdev->features |= NSIM_ESP_FEATURES;\n\tns->netdev->hw_enc_features |= NSIM_ESP_FEATURES;\n\n\tns->ipsec.pfile = debugfs_create_file(\"ipsec\", 0400,\n\t\t\t\t\t      ns->nsim_dev_port->ddir, ns,\n\t\t\t\t\t      &ipsec_dbg_fops);\n}\n\nvoid nsim_ipsec_teardown(struct netdevsim *ns)\n{\n\tstruct nsim_ipsec *ipsec = &ns->ipsec;\n\n\tif (ipsec->count)\n\t\tnetdev_err(ns->netdev, \"tearing down IPsec offload with %d SAs left\\n\",\n\t\t\t   ipsec->count);\n\tdebugfs_remove_recursive(ipsec->pfile);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}