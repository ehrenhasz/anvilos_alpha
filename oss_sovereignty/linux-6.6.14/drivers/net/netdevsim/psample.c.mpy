{
  "module_name": "psample.c",
  "hash_id": "83fb8d5608aefb657dd916058eea393a250a4b9ed09ec7be304d9b9cbde0ecfe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/netdevsim/psample.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/etherdevice.h>\n#include <linux/inet.h>\n#include <linux/kernel.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <net/devlink.h>\n#include <net/ip.h>\n#include <net/psample.h>\n#include <uapi/linux/ip.h>\n#include <uapi/linux/udp.h>\n\n#include \"netdevsim.h\"\n\n#define NSIM_PSAMPLE_REPORT_INTERVAL_MS\t100\n#define NSIM_PSAMPLE_INVALID_TC\t\t0xFFFF\n#define NSIM_PSAMPLE_L4_DATA_LEN\t100\n\nstruct nsim_dev_psample {\n\tstruct delayed_work psample_dw;\n\tstruct dentry *ddir;\n\tstruct psample_group *group;\n\tu32 rate;\n\tu32 group_num;\n\tu32 trunc_size;\n\tint in_ifindex;\n\tint out_ifindex;\n\tu16 out_tc;\n\tu64 out_tc_occ_max;\n\tu64 latency_max;\n\tbool is_active;\n};\n\nstatic struct sk_buff *nsim_dev_psample_skb_build(void)\n{\n\tint tot_len, data_len = NSIM_PSAMPLE_L4_DATA_LEN;\n\tstruct sk_buff *skb;\n\tstruct udphdr *udph;\n\tstruct ethhdr *eth;\n\tstruct iphdr *iph;\n\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\ttot_len = sizeof(struct iphdr) + sizeof(struct udphdr) + data_len;\n\n\tskb_reset_mac_header(skb);\n\teth = skb_put(skb, sizeof(struct ethhdr));\n\teth_random_addr(eth->h_dest);\n\teth_random_addr(eth->h_source);\n\teth->h_proto = htons(ETH_P_IP);\n\tskb->protocol = htons(ETH_P_IP);\n\n\tskb_set_network_header(skb, skb->len);\n\tiph = skb_put(skb, sizeof(struct iphdr));\n\tiph->protocol = IPPROTO_UDP;\n\tiph->saddr = in_aton(\"192.0.2.1\");\n\tiph->daddr = in_aton(\"198.51.100.1\");\n\tiph->version = 0x4;\n\tiph->frag_off = 0;\n\tiph->ihl = 0x5;\n\tiph->tot_len = htons(tot_len);\n\tiph->id = 0;\n\tiph->ttl = 100;\n\tiph->check = 0;\n\tiph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);\n\n\tskb_set_transport_header(skb, skb->len);\n\tudph = skb_put_zero(skb, sizeof(struct udphdr) + data_len);\n\tget_random_bytes(&udph->source, sizeof(u16));\n\tget_random_bytes(&udph->dest, sizeof(u16));\n\tudph->len = htons(sizeof(struct udphdr) + data_len);\n\n\treturn skb;\n}\n\nstatic void nsim_dev_psample_md_prepare(const struct nsim_dev_psample *psample,\n\t\t\t\t\tstruct psample_metadata *md,\n\t\t\t\t\tunsigned int len)\n{\n\tmd->trunc_size = psample->trunc_size ? psample->trunc_size : len;\n\tmd->in_ifindex = psample->in_ifindex;\n\tmd->out_ifindex = psample->out_ifindex;\n\n\tif (psample->out_tc != NSIM_PSAMPLE_INVALID_TC) {\n\t\tmd->out_tc = psample->out_tc;\n\t\tmd->out_tc_valid = 1;\n\t}\n\n\tif (psample->out_tc_occ_max) {\n\t\tu64 out_tc_occ;\n\n\t\tget_random_bytes(&out_tc_occ, sizeof(u64));\n\t\tmd->out_tc_occ = out_tc_occ & (psample->out_tc_occ_max - 1);\n\t\tmd->out_tc_occ_valid = 1;\n\t}\n\n\tif (psample->latency_max) {\n\t\tu64 latency;\n\n\t\tget_random_bytes(&latency, sizeof(u64));\n\t\tmd->latency = latency & (psample->latency_max - 1);\n\t\tmd->latency_valid = 1;\n\t}\n}\n\nstatic void nsim_dev_psample_report_work(struct work_struct *work)\n{\n\tstruct nsim_dev_psample *psample;\n\tstruct psample_metadata md = {};\n\tstruct sk_buff *skb;\n\tunsigned long delay;\n\n\tpsample = container_of(work, struct nsim_dev_psample, psample_dw.work);\n\n\tskb = nsim_dev_psample_skb_build();\n\tif (!skb)\n\t\tgoto out;\n\n\tnsim_dev_psample_md_prepare(psample, &md, skb->len);\n\tpsample_sample_packet(psample->group, skb, psample->rate, &md);\n\tconsume_skb(skb);\n\nout:\n\tdelay = msecs_to_jiffies(NSIM_PSAMPLE_REPORT_INTERVAL_MS);\n\tschedule_delayed_work(&psample->psample_dw, delay);\n}\n\nstatic int nsim_dev_psample_enable(struct nsim_dev *nsim_dev)\n{\n\tstruct nsim_dev_psample *psample = nsim_dev->psample;\n\tstruct devlink *devlink;\n\tunsigned long delay;\n\n\tif (psample->is_active)\n\t\treturn -EBUSY;\n\n\tdevlink = priv_to_devlink(nsim_dev);\n\tpsample->group = psample_group_get(devlink_net(devlink),\n\t\t\t\t\t   psample->group_num);\n\tif (!psample->group)\n\t\treturn -EINVAL;\n\n\tdelay = msecs_to_jiffies(NSIM_PSAMPLE_REPORT_INTERVAL_MS);\n\tschedule_delayed_work(&psample->psample_dw, delay);\n\n\tpsample->is_active = true;\n\n\treturn 0;\n}\n\nstatic int nsim_dev_psample_disable(struct nsim_dev *nsim_dev)\n{\n\tstruct nsim_dev_psample *psample = nsim_dev->psample;\n\n\tif (!psample->is_active)\n\t\treturn -EINVAL;\n\n\tpsample->is_active = false;\n\n\tcancel_delayed_work_sync(&psample->psample_dw);\n\tpsample_group_put(psample->group);\n\n\treturn 0;\n}\n\nstatic ssize_t nsim_dev_psample_enable_write(struct file *file,\n\t\t\t\t\t     const char __user *data,\n\t\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct nsim_dev *nsim_dev = file->private_data;\n\tbool enable;\n\tint err;\n\n\terr = kstrtobool_from_user(data, count, &enable);\n\tif (err)\n\t\treturn err;\n\n\tif (enable)\n\t\terr = nsim_dev_psample_enable(nsim_dev);\n\telse\n\t\terr = nsim_dev_psample_disable(nsim_dev);\n\n\treturn err ? err : count;\n}\n\nstatic const struct file_operations nsim_psample_enable_fops = {\n\t.open = simple_open,\n\t.write = nsim_dev_psample_enable_write,\n\t.llseek = generic_file_llseek,\n\t.owner = THIS_MODULE,\n};\n\nint nsim_dev_psample_init(struct nsim_dev *nsim_dev)\n{\n\tstruct nsim_dev_psample *psample;\n\tint err;\n\n\tpsample = kzalloc(sizeof(*psample), GFP_KERNEL);\n\tif (!psample)\n\t\treturn -ENOMEM;\n\tnsim_dev->psample = psample;\n\n\tINIT_DELAYED_WORK(&psample->psample_dw, nsim_dev_psample_report_work);\n\n\tpsample->ddir = debugfs_create_dir(\"psample\", nsim_dev->ddir);\n\tif (IS_ERR(psample->ddir)) {\n\t\terr = PTR_ERR(psample->ddir);\n\t\tgoto err_psample_free;\n\t}\n\n\t \n\tpsample->rate = 100;\n\tdebugfs_create_u32(\"rate\", 0600, psample->ddir, &psample->rate);\n\n\tpsample->group_num = 10;\n\tdebugfs_create_u32(\"group_num\", 0600, psample->ddir,\n\t\t\t   &psample->group_num);\n\n\tpsample->trunc_size = 0;\n\tdebugfs_create_u32(\"trunc_size\", 0600, psample->ddir,\n\t\t\t   &psample->trunc_size);\n\n\tpsample->in_ifindex = 1;\n\tdebugfs_create_u32(\"in_ifindex\", 0600, psample->ddir,\n\t\t\t   &psample->in_ifindex);\n\n\tpsample->out_ifindex = 2;\n\tdebugfs_create_u32(\"out_ifindex\", 0600, psample->ddir,\n\t\t\t   &psample->out_ifindex);\n\n\tpsample->out_tc = 0;\n\tdebugfs_create_u16(\"out_tc\", 0600, psample->ddir, &psample->out_tc);\n\n\tpsample->out_tc_occ_max = 10000;\n\tdebugfs_create_u64(\"out_tc_occ_max\", 0600, psample->ddir,\n\t\t\t   &psample->out_tc_occ_max);\n\n\tpsample->latency_max = 50;\n\tdebugfs_create_u64(\"latency_max\", 0600, psample->ddir,\n\t\t\t   &psample->latency_max);\n\n\tdebugfs_create_file(\"enable\", 0200, psample->ddir, nsim_dev,\n\t\t\t    &nsim_psample_enable_fops);\n\n\treturn 0;\n\nerr_psample_free:\n\tkfree(nsim_dev->psample);\n\treturn err;\n}\n\nvoid nsim_dev_psample_exit(struct nsim_dev *nsim_dev)\n{\n\tdebugfs_remove_recursive(nsim_dev->psample->ddir);\n\tif (nsim_dev->psample->is_active) {\n\t\tcancel_delayed_work_sync(&nsim_dev->psample->psample_dw);\n\t\tpsample_group_put(nsim_dev->psample->group);\n\t}\n\tkfree(nsim_dev->psample);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}