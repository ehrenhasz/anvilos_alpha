{
  "module_name": "netdevsim.h",
  "hash_id": "32edac2b27997ce4ef3b759ac72c228e4db2c2df05ecfe2b068e4fe6e85408e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/netdevsim/netdevsim.h",
  "human_readable_source": " \n\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/ethtool.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/netdevice.h>\n#include <linux/ptp_mock.h>\n#include <linux/u64_stats_sync.h>\n#include <net/devlink.h>\n#include <net/udp_tunnel.h>\n#include <net/xdp.h>\n#include <net/macsec.h>\n\n#define DRV_NAME\t\"netdevsim\"\n\n#define NSIM_XDP_MAX_MTU\t4000\n\n#define NSIM_EA(extack, msg)\tNL_SET_ERR_MSG_MOD((extack), msg)\n\n#define NSIM_IPSEC_MAX_SA_COUNT\t\t33\n#define NSIM_IPSEC_VALID\t\tBIT(31)\n#define NSIM_UDP_TUNNEL_N_PORTS\t\t4\n\nstruct nsim_sa {\n\tstruct xfrm_state *xs;\n\t__be32 ipaddr[4];\n\tu32 key[4];\n\tu32 salt;\n\tbool used;\n\tbool crypt;\n\tbool rx;\n};\n\nstruct nsim_ipsec {\n\tstruct nsim_sa sa[NSIM_IPSEC_MAX_SA_COUNT];\n\tstruct dentry *pfile;\n\tu32 count;\n\tu32 tx;\n\tu32 ok;\n};\n\n#define NSIM_MACSEC_MAX_SECY_COUNT 3\n#define NSIM_MACSEC_MAX_RXSC_COUNT 1\nstruct nsim_rxsc {\n\tsci_t sci;\n\tbool used;\n};\n\nstruct nsim_secy {\n\tsci_t sci;\n\tstruct nsim_rxsc nsim_rxsc[NSIM_MACSEC_MAX_RXSC_COUNT];\n\tu8 nsim_rxsc_count;\n\tbool used;\n};\n\nstruct nsim_macsec {\n\tstruct nsim_secy nsim_secy[NSIM_MACSEC_MAX_SECY_COUNT];\n\tu8 nsim_secy_count;\n};\n\nstruct nsim_ethtool_pauseparam {\n\tbool rx;\n\tbool tx;\n\tbool report_stats_rx;\n\tbool report_stats_tx;\n};\n\nstruct nsim_ethtool {\n\tu32 get_err;\n\tu32 set_err;\n\tu32 channels;\n\tstruct nsim_ethtool_pauseparam pauseparam;\n\tstruct ethtool_coalesce coalesce;\n\tstruct ethtool_ringparam ring;\n\tstruct ethtool_fecparam fec;\n};\n\nstruct netdevsim {\n\tstruct net_device *netdev;\n\tstruct nsim_dev *nsim_dev;\n\tstruct nsim_dev_port *nsim_dev_port;\n\tstruct mock_phc *phc;\n\n\tu64 tx_packets;\n\tu64 tx_bytes;\n\tstruct u64_stats_sync syncp;\n\n\tstruct nsim_bus_dev *nsim_bus_dev;\n\n\tstruct bpf_prog\t*bpf_offloaded;\n\tu32 bpf_offloaded_id;\n\n\tstruct xdp_attachment_info xdp;\n\tstruct xdp_attachment_info xdp_hw;\n\n\tbool bpf_tc_accept;\n\tbool bpf_tc_non_bound_accept;\n\tbool bpf_xdpdrv_accept;\n\tbool bpf_xdpoffload_accept;\n\n\tbool bpf_map_accept;\n\tstruct nsim_ipsec ipsec;\n\tstruct nsim_macsec macsec;\n\tstruct {\n\t\tu32 inject_error;\n\t\tu32 sleep;\n\t\tu32 __ports[2][NSIM_UDP_TUNNEL_N_PORTS];\n\t\tu32 (*ports)[NSIM_UDP_TUNNEL_N_PORTS];\n\t\tstruct debugfs_u32_array dfs_ports[2];\n\t} udp_ports;\n\n\tstruct nsim_ethtool ethtool;\n};\n\nstruct netdevsim *\nnsim_create(struct nsim_dev *nsim_dev, struct nsim_dev_port *nsim_dev_port);\nvoid nsim_destroy(struct netdevsim *ns);\n\nvoid nsim_ethtool_init(struct netdevsim *ns);\n\nvoid nsim_udp_tunnels_debugfs_create(struct nsim_dev *nsim_dev);\nint nsim_udp_tunnels_info_create(struct nsim_dev *nsim_dev,\n\t\t\t\t struct net_device *dev);\nvoid nsim_udp_tunnels_info_destroy(struct net_device *dev);\n\n#ifdef CONFIG_BPF_SYSCALL\nint nsim_bpf_dev_init(struct nsim_dev *nsim_dev);\nvoid nsim_bpf_dev_exit(struct nsim_dev *nsim_dev);\nint nsim_bpf_init(struct netdevsim *ns);\nvoid nsim_bpf_uninit(struct netdevsim *ns);\nint nsim_bpf(struct net_device *dev, struct netdev_bpf *bpf);\nint nsim_bpf_disable_tc(struct netdevsim *ns);\nint nsim_bpf_setup_tc_block_cb(enum tc_setup_type type,\n\t\t\t       void *type_data, void *cb_priv);\n#else\n\nstatic inline int nsim_bpf_dev_init(struct nsim_dev *nsim_dev)\n{\n\treturn 0;\n}\n\nstatic inline void nsim_bpf_dev_exit(struct nsim_dev *nsim_dev)\n{\n}\nstatic inline int nsim_bpf_init(struct netdevsim *ns)\n{\n\treturn 0;\n}\n\nstatic inline void nsim_bpf_uninit(struct netdevsim *ns)\n{\n}\n\nstatic inline int nsim_bpf(struct net_device *dev, struct netdev_bpf *bpf)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic inline int nsim_bpf_disable_tc(struct netdevsim *ns)\n{\n\treturn 0;\n}\n\nstatic inline int\nnsim_bpf_setup_tc_block_cb(enum tc_setup_type type, void *type_data,\n\t\t\t   void *cb_priv)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\nenum nsim_resource_id {\n\tNSIM_RESOURCE_NONE,    \n\tNSIM_RESOURCE_IPV4,\n\tNSIM_RESOURCE_IPV4_FIB,\n\tNSIM_RESOURCE_IPV4_FIB_RULES,\n\tNSIM_RESOURCE_IPV6,\n\tNSIM_RESOURCE_IPV6_FIB,\n\tNSIM_RESOURCE_IPV6_FIB_RULES,\n\tNSIM_RESOURCE_NEXTHOPS,\n};\n\nstruct nsim_dev_health {\n\tstruct devlink_health_reporter *empty_reporter;\n\tstruct devlink_health_reporter *dummy_reporter;\n\tstruct dentry *ddir;\n\tchar *recovered_break_msg;\n\tu32 binary_len;\n\tbool fail_recover;\n};\n\nint nsim_dev_health_init(struct nsim_dev *nsim_dev, struct devlink *devlink);\nvoid nsim_dev_health_exit(struct nsim_dev *nsim_dev);\n\nstruct nsim_dev_hwstats_netdev {\n\tstruct list_head list;\n\tstruct net_device *netdev;\n\tstruct rtnl_hw_stats64 stats;\n\tbool enabled;\n\tbool fail_enable;\n};\n\nstruct nsim_dev_hwstats {\n\tstruct dentry *ddir;\n\tstruct dentry *l3_ddir;\n\n\tstruct mutex hwsdev_list_lock;  \n\tstruct list_head l3_list;\n\n\tstruct notifier_block netdevice_nb;\n\tstruct delayed_work traffic_dw;\n};\n\nint nsim_dev_hwstats_init(struct nsim_dev *nsim_dev);\nvoid nsim_dev_hwstats_exit(struct nsim_dev *nsim_dev);\n\n#if IS_ENABLED(CONFIG_PSAMPLE)\nint nsim_dev_psample_init(struct nsim_dev *nsim_dev);\nvoid nsim_dev_psample_exit(struct nsim_dev *nsim_dev);\n#else\nstatic inline int nsim_dev_psample_init(struct nsim_dev *nsim_dev)\n{\n\treturn 0;\n}\n\nstatic inline void nsim_dev_psample_exit(struct nsim_dev *nsim_dev)\n{\n}\n#endif\n\nenum nsim_dev_port_type {\n\tNSIM_DEV_PORT_TYPE_PF,\n\tNSIM_DEV_PORT_TYPE_VF,\n};\n\n#define NSIM_DEV_VF_PORT_INDEX_BASE 128\n#define NSIM_DEV_VF_PORT_INDEX_MAX UINT_MAX\n\nstruct nsim_dev_port {\n\tstruct list_head list;\n\tstruct devlink_port devlink_port;\n\tunsigned int port_index;\n\tenum nsim_dev_port_type port_type;\n\tstruct dentry *ddir;\n\tstruct dentry *rate_parent;\n\tchar *parent_name;\n\tstruct netdevsim *ns;\n};\n\nstruct nsim_vf_config {\n\tint link_state;\n\tu16 min_tx_rate;\n\tu16 max_tx_rate;\n\tu16 vlan;\n\t__be16 vlan_proto;\n\tu16 qos;\n\tu8 vf_mac[ETH_ALEN];\n\tbool spoofchk_enabled;\n\tbool trusted;\n\tbool rss_query_enabled;\n};\n\nstruct nsim_dev {\n\tstruct nsim_bus_dev *nsim_bus_dev;\n\tstruct nsim_fib_data *fib_data;\n\tstruct nsim_trap_data *trap_data;\n\tstruct dentry *ddir;\n\tstruct dentry *ports_ddir;\n\tstruct dentry *take_snapshot;\n\tstruct dentry *nodes_ddir;\n\n\tstruct nsim_vf_config *vfconfigs;\n\n\tstruct bpf_offload_dev *bpf_dev;\n\tbool bpf_bind_accept;\n\tbool bpf_bind_verifier_accept;\n\tu32 bpf_bind_verifier_delay;\n\tstruct dentry *ddir_bpf_bound_progs;\n\tu32 prog_id_gen;\n\tstruct list_head bpf_bound_progs;\n\tstruct list_head bpf_bound_maps;\n\tstruct netdev_phys_item_id switch_id;\n\tstruct list_head port_list;\n\tbool fw_update_status;\n\tu32 fw_update_overwrite_mask;\n\tu32 max_macs;\n\tbool test1;\n\tbool dont_allow_reload;\n\tbool fail_reload;\n\tstruct devlink_region *dummy_region;\n\tstruct nsim_dev_health health;\n\tstruct nsim_dev_hwstats hwstats;\n\tstruct flow_action_cookie *fa_cookie;\n\tspinlock_t fa_cookie_lock;  \n\tbool fail_trap_group_set;\n\tbool fail_trap_policer_set;\n\tbool fail_trap_policer_counter_get;\n\tbool fail_trap_drop_counter_get;\n\tstruct {\n\t\tstruct udp_tunnel_nic_shared utn_shared;\n\t\tu32 __ports[2][NSIM_UDP_TUNNEL_N_PORTS];\n\t\tbool sync_all;\n\t\tbool open_only;\n\t\tbool ipv4_only;\n\t\tbool shared;\n\t\tbool static_iana_vxlan;\n\t\tu32 sleep;\n\t} udp_ports;\n\tstruct nsim_dev_psample *psample;\n\tu16 esw_mode;\n};\n\nstatic inline bool nsim_esw_mode_is_legacy(struct nsim_dev *nsim_dev)\n{\n\treturn nsim_dev->esw_mode == DEVLINK_ESWITCH_MODE_LEGACY;\n}\n\nstatic inline bool nsim_esw_mode_is_switchdev(struct nsim_dev *nsim_dev)\n{\n\treturn nsim_dev->esw_mode == DEVLINK_ESWITCH_MODE_SWITCHDEV;\n}\n\nstatic inline struct net *nsim_dev_net(struct nsim_dev *nsim_dev)\n{\n\treturn devlink_net(priv_to_devlink(nsim_dev));\n}\n\nint nsim_dev_init(void);\nvoid nsim_dev_exit(void);\nint nsim_drv_probe(struct nsim_bus_dev *nsim_bus_dev);\nvoid nsim_drv_remove(struct nsim_bus_dev *nsim_bus_dev);\nint nsim_drv_port_add(struct nsim_bus_dev *nsim_bus_dev,\n\t\t      enum nsim_dev_port_type type,\n\t\t      unsigned int port_index);\nint nsim_drv_port_del(struct nsim_bus_dev *nsim_bus_dev,\n\t\t      enum nsim_dev_port_type type,\n\t\t      unsigned int port_index);\nint nsim_drv_configure_vfs(struct nsim_bus_dev *nsim_bus_dev,\n\t\t\t   unsigned int num_vfs);\n\nunsigned int nsim_dev_get_vfs(struct nsim_dev *nsim_dev);\n\nstruct nsim_fib_data *nsim_fib_create(struct devlink *devlink,\n\t\t\t\t      struct netlink_ext_ack *extack);\nvoid nsim_fib_destroy(struct devlink *devlink, struct nsim_fib_data *fib_data);\nu64 nsim_fib_get_val(struct nsim_fib_data *fib_data,\n\t\t     enum nsim_resource_id res_id, bool max);\n\nstatic inline bool nsim_dev_port_is_pf(struct nsim_dev_port *nsim_dev_port)\n{\n\treturn nsim_dev_port->port_type == NSIM_DEV_PORT_TYPE_PF;\n}\n\nstatic inline bool nsim_dev_port_is_vf(struct nsim_dev_port *nsim_dev_port)\n{\n\treturn nsim_dev_port->port_type == NSIM_DEV_PORT_TYPE_VF;\n}\n#if IS_ENABLED(CONFIG_XFRM_OFFLOAD)\nvoid nsim_ipsec_init(struct netdevsim *ns);\nvoid nsim_ipsec_teardown(struct netdevsim *ns);\nbool nsim_ipsec_tx(struct netdevsim *ns, struct sk_buff *skb);\n#else\nstatic inline void nsim_ipsec_init(struct netdevsim *ns)\n{\n}\n\nstatic inline void nsim_ipsec_teardown(struct netdevsim *ns)\n{\n}\n\nstatic inline bool nsim_ipsec_tx(struct netdevsim *ns, struct sk_buff *skb)\n{\n\treturn true;\n}\n#endif\n\n#if IS_ENABLED(CONFIG_MACSEC)\nvoid nsim_macsec_init(struct netdevsim *ns);\nvoid nsim_macsec_teardown(struct netdevsim *ns);\n#else\nstatic inline void nsim_macsec_init(struct netdevsim *ns)\n{\n}\n\nstatic inline void nsim_macsec_teardown(struct netdevsim *ns)\n{\n}\n#endif\n\nstruct nsim_bus_dev {\n\tstruct device dev;\n\tstruct list_head list;\n\tunsigned int port_count;\n\tunsigned int num_queues;  \n\tstruct net *initial_net;  \n\tunsigned int max_vfs;\n\tunsigned int num_vfs;\n\tbool init;\n};\n\nint nsim_bus_init(void);\nvoid nsim_bus_exit(void);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}