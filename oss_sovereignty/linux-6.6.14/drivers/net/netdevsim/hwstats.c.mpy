{
  "module_name": "hwstats.c",
  "hash_id": "bd9e44c84ebd7044e8e41e8f6649884061b97ea1513b98070c3cf733fd2dfbb3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/netdevsim/hwstats.c",
  "human_readable_source": "\n\n#include <linux/debugfs.h>\n\n#include \"netdevsim.h\"\n\n#define NSIM_DEV_HWSTATS_TRAFFIC_MS\t100\n\nstatic struct list_head *\nnsim_dev_hwstats_get_list_head(struct nsim_dev_hwstats *hwstats,\n\t\t\t       enum netdev_offload_xstats_type type)\n{\n\tswitch (type) {\n\tcase NETDEV_OFFLOAD_XSTATS_TYPE_L3:\n\t\treturn &hwstats->l3_list;\n\t}\n\n\tWARN_ON_ONCE(1);\n\treturn NULL;\n}\n\nstatic void nsim_dev_hwstats_traffic_bump(struct nsim_dev_hwstats *hwstats,\n\t\t\t\t\t  enum netdev_offload_xstats_type type)\n{\n\tstruct nsim_dev_hwstats_netdev *hwsdev;\n\tstruct list_head *hwsdev_list;\n\n\thwsdev_list = nsim_dev_hwstats_get_list_head(hwstats, type);\n\tif (WARN_ON(!hwsdev_list))\n\t\treturn;\n\n\tlist_for_each_entry(hwsdev, hwsdev_list, list) {\n\t\tif (hwsdev->enabled) {\n\t\t\thwsdev->stats.rx_packets += 1;\n\t\t\thwsdev->stats.tx_packets += 2;\n\t\t\thwsdev->stats.rx_bytes += 100;\n\t\t\thwsdev->stats.tx_bytes += 300;\n\t\t}\n\t}\n}\n\nstatic void nsim_dev_hwstats_traffic_work(struct work_struct *work)\n{\n\tstruct nsim_dev_hwstats *hwstats;\n\n\thwstats = container_of(work, struct nsim_dev_hwstats, traffic_dw.work);\n\tmutex_lock(&hwstats->hwsdev_list_lock);\n\tnsim_dev_hwstats_traffic_bump(hwstats, NETDEV_OFFLOAD_XSTATS_TYPE_L3);\n\tmutex_unlock(&hwstats->hwsdev_list_lock);\n\n\tschedule_delayed_work(&hwstats->traffic_dw,\n\t\t\t      msecs_to_jiffies(NSIM_DEV_HWSTATS_TRAFFIC_MS));\n}\n\nstatic struct nsim_dev_hwstats_netdev *\nnsim_dev_hwslist_find_hwsdev(struct list_head *hwsdev_list,\n\t\t\t     int ifindex)\n{\n\tstruct nsim_dev_hwstats_netdev *hwsdev;\n\n\tlist_for_each_entry(hwsdev, hwsdev_list, list) {\n\t\tif (hwsdev->netdev->ifindex == ifindex)\n\t\t\treturn hwsdev;\n\t}\n\n\treturn NULL;\n}\n\nstatic int nsim_dev_hwsdev_enable(struct nsim_dev_hwstats_netdev *hwsdev,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\tif (hwsdev->fail_enable) {\n\t\thwsdev->fail_enable = false;\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Stats enablement set to fail\");\n\t\treturn -ECANCELED;\n\t}\n\n\thwsdev->enabled = true;\n\treturn 0;\n}\n\nstatic void nsim_dev_hwsdev_disable(struct nsim_dev_hwstats_netdev *hwsdev)\n{\n\thwsdev->enabled = false;\n\tmemset(&hwsdev->stats, 0, sizeof(hwsdev->stats));\n}\n\nstatic int\nnsim_dev_hwsdev_report_delta(struct nsim_dev_hwstats_netdev *hwsdev,\n\t\t\t     struct netdev_notifier_offload_xstats_info *info)\n{\n\tnetdev_offload_xstats_report_delta(info->report_delta, &hwsdev->stats);\n\tmemset(&hwsdev->stats, 0, sizeof(hwsdev->stats));\n\treturn 0;\n}\n\nstatic void\nnsim_dev_hwsdev_report_used(struct nsim_dev_hwstats_netdev *hwsdev,\n\t\t\t    struct netdev_notifier_offload_xstats_info *info)\n{\n\tif (hwsdev->enabled)\n\t\tnetdev_offload_xstats_report_used(info->report_used);\n}\n\nstatic int nsim_dev_hwstats_event_off_xstats(struct nsim_dev_hwstats *hwstats,\n\t\t\t\t\t     struct net_device *dev,\n\t\t\t\t\t     unsigned long event, void *ptr)\n{\n\tstruct netdev_notifier_offload_xstats_info *info;\n\tstruct nsim_dev_hwstats_netdev *hwsdev;\n\tstruct list_head *hwsdev_list;\n\tint err = 0;\n\n\tinfo = ptr;\n\thwsdev_list = nsim_dev_hwstats_get_list_head(hwstats, info->type);\n\tif (!hwsdev_list)\n\t\treturn 0;\n\n\tmutex_lock(&hwstats->hwsdev_list_lock);\n\n\thwsdev = nsim_dev_hwslist_find_hwsdev(hwsdev_list, dev->ifindex);\n\tif (!hwsdev)\n\t\tgoto out;\n\n\tswitch (event) {\n\tcase NETDEV_OFFLOAD_XSTATS_ENABLE:\n\t\terr = nsim_dev_hwsdev_enable(hwsdev, info->info.extack);\n\t\tbreak;\n\tcase NETDEV_OFFLOAD_XSTATS_DISABLE:\n\t\tnsim_dev_hwsdev_disable(hwsdev);\n\t\tbreak;\n\tcase NETDEV_OFFLOAD_XSTATS_REPORT_USED:\n\t\tnsim_dev_hwsdev_report_used(hwsdev, info);\n\t\tbreak;\n\tcase NETDEV_OFFLOAD_XSTATS_REPORT_DELTA:\n\t\terr = nsim_dev_hwsdev_report_delta(hwsdev, info);\n\t\tbreak;\n\t}\n\nout:\n\tmutex_unlock(&hwstats->hwsdev_list_lock);\n\treturn err;\n}\n\nstatic void nsim_dev_hwsdev_fini(struct nsim_dev_hwstats_netdev *hwsdev)\n{\n\tdev_put(hwsdev->netdev);\n\tkfree(hwsdev);\n}\n\nstatic void\n__nsim_dev_hwstats_event_unregister(struct nsim_dev_hwstats *hwstats,\n\t\t\t\t    struct net_device *dev,\n\t\t\t\t    enum netdev_offload_xstats_type type)\n{\n\tstruct nsim_dev_hwstats_netdev *hwsdev;\n\tstruct list_head *hwsdev_list;\n\n\thwsdev_list = nsim_dev_hwstats_get_list_head(hwstats, type);\n\tif (WARN_ON(!hwsdev_list))\n\t\treturn;\n\n\thwsdev = nsim_dev_hwslist_find_hwsdev(hwsdev_list, dev->ifindex);\n\tif (!hwsdev)\n\t\treturn;\n\n\tlist_del(&hwsdev->list);\n\tnsim_dev_hwsdev_fini(hwsdev);\n}\n\nstatic void nsim_dev_hwstats_event_unregister(struct nsim_dev_hwstats *hwstats,\n\t\t\t\t\t      struct net_device *dev)\n{\n\tmutex_lock(&hwstats->hwsdev_list_lock);\n\t__nsim_dev_hwstats_event_unregister(hwstats, dev,\n\t\t\t\t\t    NETDEV_OFFLOAD_XSTATS_TYPE_L3);\n\tmutex_unlock(&hwstats->hwsdev_list_lock);\n}\n\nstatic int nsim_dev_hwstats_event(struct nsim_dev_hwstats *hwstats,\n\t\t\t\t  struct net_device *dev,\n\t\t\t\t  unsigned long event, void *ptr)\n{\n\tswitch (event) {\n\tcase NETDEV_OFFLOAD_XSTATS_ENABLE:\n\tcase NETDEV_OFFLOAD_XSTATS_DISABLE:\n\tcase NETDEV_OFFLOAD_XSTATS_REPORT_USED:\n\tcase NETDEV_OFFLOAD_XSTATS_REPORT_DELTA:\n\t\treturn nsim_dev_hwstats_event_off_xstats(hwstats, dev,\n\t\t\t\t\t\t\t event, ptr);\n\tcase NETDEV_UNREGISTER:\n\t\tnsim_dev_hwstats_event_unregister(hwstats, dev);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int nsim_dev_netdevice_event(struct notifier_block *nb,\n\t\t\t\t    unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct nsim_dev_hwstats *hwstats;\n\tint err = 0;\n\n\thwstats = container_of(nb, struct nsim_dev_hwstats, netdevice_nb);\n\terr = nsim_dev_hwstats_event(hwstats, dev, event, ptr);\n\tif (err)\n\t\treturn notifier_from_errno(err);\n\n\treturn NOTIFY_OK;\n}\n\nstatic int\nnsim_dev_hwstats_enable_ifindex(struct nsim_dev_hwstats *hwstats,\n\t\t\t\tint ifindex,\n\t\t\t\tenum netdev_offload_xstats_type type,\n\t\t\t\tstruct list_head *hwsdev_list)\n{\n\tstruct nsim_dev_hwstats_netdev *hwsdev;\n\tstruct nsim_dev *nsim_dev;\n\tstruct net_device *netdev;\n\tbool notify = false;\n\tstruct net *net;\n\tint err = 0;\n\n\tnsim_dev = container_of(hwstats, struct nsim_dev, hwstats);\n\tnet = nsim_dev_net(nsim_dev);\n\n\trtnl_lock();\n\tmutex_lock(&hwstats->hwsdev_list_lock);\n\thwsdev = nsim_dev_hwslist_find_hwsdev(hwsdev_list, ifindex);\n\tif (hwsdev)\n\t\tgoto out_unlock_list;\n\n\tnetdev = dev_get_by_index(net, ifindex);\n\tif (!netdev) {\n\t\terr = -ENODEV;\n\t\tgoto out_unlock_list;\n\t}\n\n\thwsdev = kzalloc(sizeof(*hwsdev), GFP_KERNEL);\n\tif (!hwsdev) {\n\t\terr = -ENOMEM;\n\t\tgoto out_put_netdev;\n\t}\n\n\thwsdev->netdev = netdev;\n\tlist_add_tail(&hwsdev->list, hwsdev_list);\n\tmutex_unlock(&hwstats->hwsdev_list_lock);\n\n\tif (netdev_offload_xstats_enabled(netdev, type)) {\n\t\tnsim_dev_hwsdev_enable(hwsdev, NULL);\n\t\tnotify = true;\n\t}\n\n\tif (notify)\n\t\trtnl_offload_xstats_notify(netdev);\n\trtnl_unlock();\n\treturn err;\n\nout_put_netdev:\n\tdev_put(netdev);\nout_unlock_list:\n\tmutex_unlock(&hwstats->hwsdev_list_lock);\n\trtnl_unlock();\n\treturn err;\n}\n\nstatic int\nnsim_dev_hwstats_disable_ifindex(struct nsim_dev_hwstats *hwstats,\n\t\t\t\t int ifindex,\n\t\t\t\t enum netdev_offload_xstats_type type,\n\t\t\t\t struct list_head *hwsdev_list)\n{\n\tstruct nsim_dev_hwstats_netdev *hwsdev;\n\tint err = 0;\n\n\trtnl_lock();\n\tmutex_lock(&hwstats->hwsdev_list_lock);\n\thwsdev = nsim_dev_hwslist_find_hwsdev(hwsdev_list, ifindex);\n\tif (hwsdev)\n\t\tlist_del(&hwsdev->list);\n\tmutex_unlock(&hwstats->hwsdev_list_lock);\n\n\tif (!hwsdev) {\n\t\terr = -ENOENT;\n\t\tgoto unlock_out;\n\t}\n\n\tif (netdev_offload_xstats_enabled(hwsdev->netdev, type)) {\n\t\tnetdev_offload_xstats_push_delta(hwsdev->netdev, type,\n\t\t\t\t\t\t &hwsdev->stats);\n\t\trtnl_offload_xstats_notify(hwsdev->netdev);\n\t}\n\tnsim_dev_hwsdev_fini(hwsdev);\n\nunlock_out:\n\trtnl_unlock();\n\treturn err;\n}\n\nstatic int\nnsim_dev_hwstats_fail_ifindex(struct nsim_dev_hwstats *hwstats,\n\t\t\t      int ifindex,\n\t\t\t      enum netdev_offload_xstats_type type,\n\t\t\t      struct list_head *hwsdev_list)\n{\n\tstruct nsim_dev_hwstats_netdev *hwsdev;\n\tint err = 0;\n\n\tmutex_lock(&hwstats->hwsdev_list_lock);\n\n\thwsdev = nsim_dev_hwslist_find_hwsdev(hwsdev_list, ifindex);\n\tif (!hwsdev) {\n\t\terr = -ENOENT;\n\t\tgoto err_hwsdev_list_unlock;\n\t}\n\n\thwsdev->fail_enable = true;\n\nerr_hwsdev_list_unlock:\n\tmutex_unlock(&hwstats->hwsdev_list_lock);\n\treturn err;\n}\n\nenum nsim_dev_hwstats_do {\n\tNSIM_DEV_HWSTATS_DO_DISABLE,\n\tNSIM_DEV_HWSTATS_DO_ENABLE,\n\tNSIM_DEV_HWSTATS_DO_FAIL,\n};\n\nstruct nsim_dev_hwstats_fops {\n\tconst struct file_operations fops;\n\tenum nsim_dev_hwstats_do action;\n\tenum netdev_offload_xstats_type type;\n};\n\nstatic ssize_t\nnsim_dev_hwstats_do_write(struct file *file,\n\t\t\t  const char __user *data,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct nsim_dev_hwstats *hwstats = file->private_data;\n\tstruct nsim_dev_hwstats_fops *hwsfops;\n\tstruct list_head *hwsdev_list;\n\tint ifindex;\n\tint err;\n\n\thwsfops = container_of(debugfs_real_fops(file),\n\t\t\t       struct nsim_dev_hwstats_fops, fops);\n\n\terr = kstrtoint_from_user(data, count, 0, &ifindex);\n\tif (err)\n\t\treturn err;\n\n\thwsdev_list = nsim_dev_hwstats_get_list_head(hwstats, hwsfops->type);\n\tif (WARN_ON(!hwsdev_list))\n\t\treturn -EINVAL;\n\n\tswitch (hwsfops->action) {\n\tcase NSIM_DEV_HWSTATS_DO_DISABLE:\n\t\terr = nsim_dev_hwstats_disable_ifindex(hwstats, ifindex,\n\t\t\t\t\t\t       hwsfops->type,\n\t\t\t\t\t\t       hwsdev_list);\n\t\tbreak;\n\tcase NSIM_DEV_HWSTATS_DO_ENABLE:\n\t\terr = nsim_dev_hwstats_enable_ifindex(hwstats, ifindex,\n\t\t\t\t\t\t      hwsfops->type,\n\t\t\t\t\t\t      hwsdev_list);\n\t\tbreak;\n\tcase NSIM_DEV_HWSTATS_DO_FAIL:\n\t\terr = nsim_dev_hwstats_fail_ifindex(hwstats, ifindex,\n\t\t\t\t\t\t    hwsfops->type,\n\t\t\t\t\t\t    hwsdev_list);\n\t\tbreak;\n\t}\n\tif (err)\n\t\treturn err;\n\n\treturn count;\n}\n\n#define NSIM_DEV_HWSTATS_FOPS(ACTION, TYPE)\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\t.fops = {\t\t\t\t\t\\\n\t\t\t.open = simple_open,\t\t\t\\\n\t\t\t.write = nsim_dev_hwstats_do_write,\t\\\n\t\t\t.llseek = generic_file_llseek,\t\t\\\n\t\t\t.owner = THIS_MODULE,\t\t\t\\\n\t\t},\t\t\t\t\t\t\\\n\t\t.action = ACTION,\t\t\t\t\\\n\t\t.type = TYPE,\t\t\t\t\t\\\n\t}\n\nstatic const struct nsim_dev_hwstats_fops nsim_dev_hwstats_l3_disable_fops =\n\tNSIM_DEV_HWSTATS_FOPS(NSIM_DEV_HWSTATS_DO_DISABLE,\n\t\t\t      NETDEV_OFFLOAD_XSTATS_TYPE_L3);\n\nstatic const struct nsim_dev_hwstats_fops nsim_dev_hwstats_l3_enable_fops =\n\tNSIM_DEV_HWSTATS_FOPS(NSIM_DEV_HWSTATS_DO_ENABLE,\n\t\t\t      NETDEV_OFFLOAD_XSTATS_TYPE_L3);\n\nstatic const struct nsim_dev_hwstats_fops nsim_dev_hwstats_l3_fail_fops =\n\tNSIM_DEV_HWSTATS_FOPS(NSIM_DEV_HWSTATS_DO_FAIL,\n\t\t\t      NETDEV_OFFLOAD_XSTATS_TYPE_L3);\n\n#undef NSIM_DEV_HWSTATS_FOPS\n\nint nsim_dev_hwstats_init(struct nsim_dev *nsim_dev)\n{\n\tstruct nsim_dev_hwstats *hwstats = &nsim_dev->hwstats;\n\tstruct net *net = nsim_dev_net(nsim_dev);\n\tint err;\n\n\tmutex_init(&hwstats->hwsdev_list_lock);\n\tINIT_LIST_HEAD(&hwstats->l3_list);\n\n\thwstats->netdevice_nb.notifier_call = nsim_dev_netdevice_event;\n\terr = register_netdevice_notifier_net(net, &hwstats->netdevice_nb);\n\tif (err)\n\t\tgoto err_mutex_destroy;\n\n\thwstats->ddir = debugfs_create_dir(\"hwstats\", nsim_dev->ddir);\n\tif (IS_ERR(hwstats->ddir)) {\n\t\terr = PTR_ERR(hwstats->ddir);\n\t\tgoto err_unregister_notifier;\n\t}\n\n\thwstats->l3_ddir = debugfs_create_dir(\"l3\", hwstats->ddir);\n\tif (IS_ERR(hwstats->l3_ddir)) {\n\t\terr = PTR_ERR(hwstats->l3_ddir);\n\t\tgoto err_remove_hwstats_recursive;\n\t}\n\n\tdebugfs_create_file(\"enable_ifindex\", 0200, hwstats->l3_ddir, hwstats,\n\t\t\t    &nsim_dev_hwstats_l3_enable_fops.fops);\n\tdebugfs_create_file(\"disable_ifindex\", 0200, hwstats->l3_ddir, hwstats,\n\t\t\t    &nsim_dev_hwstats_l3_disable_fops.fops);\n\tdebugfs_create_file(\"fail_next_enable\", 0200, hwstats->l3_ddir, hwstats,\n\t\t\t    &nsim_dev_hwstats_l3_fail_fops.fops);\n\n\tINIT_DELAYED_WORK(&hwstats->traffic_dw,\n\t\t\t  &nsim_dev_hwstats_traffic_work);\n\tschedule_delayed_work(&hwstats->traffic_dw,\n\t\t\t      msecs_to_jiffies(NSIM_DEV_HWSTATS_TRAFFIC_MS));\n\treturn 0;\n\nerr_remove_hwstats_recursive:\n\tdebugfs_remove_recursive(hwstats->ddir);\nerr_unregister_notifier:\n\tunregister_netdevice_notifier_net(net, &hwstats->netdevice_nb);\nerr_mutex_destroy:\n\tmutex_destroy(&hwstats->hwsdev_list_lock);\n\treturn err;\n}\n\nstatic void nsim_dev_hwsdev_list_wipe(struct nsim_dev_hwstats *hwstats,\n\t\t\t\t      enum netdev_offload_xstats_type type)\n{\n\tstruct nsim_dev_hwstats_netdev *hwsdev, *tmp;\n\tstruct list_head *hwsdev_list;\n\n\thwsdev_list = nsim_dev_hwstats_get_list_head(hwstats, type);\n\tif (WARN_ON(!hwsdev_list))\n\t\treturn;\n\n\tmutex_lock(&hwstats->hwsdev_list_lock);\n\tlist_for_each_entry_safe(hwsdev, tmp, hwsdev_list, list) {\n\t\tlist_del(&hwsdev->list);\n\t\tnsim_dev_hwsdev_fini(hwsdev);\n\t}\n\tmutex_unlock(&hwstats->hwsdev_list_lock);\n}\n\nvoid nsim_dev_hwstats_exit(struct nsim_dev *nsim_dev)\n{\n\tstruct nsim_dev_hwstats *hwstats = &nsim_dev->hwstats;\n\tstruct net *net = nsim_dev_net(nsim_dev);\n\n\tcancel_delayed_work_sync(&hwstats->traffic_dw);\n\tdebugfs_remove_recursive(hwstats->ddir);\n\tunregister_netdevice_notifier_net(net, &hwstats->netdevice_nb);\n\tnsim_dev_hwsdev_list_wipe(hwstats, NETDEV_OFFLOAD_XSTATS_TYPE_L3);\n\tmutex_destroy(&hwstats->hwsdev_list_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}