{
  "module_name": "bpf.c",
  "hash_id": "cfca98968ea952d9a94637483acb216a1c5b01db423e375ee963823dd0060116",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/netdevsim/bpf.c",
  "human_readable_source": " \n\n#include <linux/bpf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/debugfs.h>\n#include <linux/kernel.h>\n#include <linux/mutex.h>\n#include <linux/rtnetlink.h>\n#include <net/pkt_cls.h>\n\n#include \"netdevsim.h\"\n\n#define pr_vlog(env, fmt, ...)\t\\\n\tbpf_verifier_log_write(env, \"[netdevsim] \" fmt, ##__VA_ARGS__)\n\nstruct nsim_bpf_bound_prog {\n\tstruct nsim_dev *nsim_dev;\n\tstruct bpf_prog *prog;\n\tstruct dentry *ddir;\n\tconst char *state;\n\tbool is_loaded;\n\tstruct list_head l;\n};\n\n#define NSIM_BPF_MAX_KEYS\t\t2\n\nstruct nsim_bpf_bound_map {\n\tstruct netdevsim *ns;\n\tstruct bpf_offloaded_map *map;\n\tstruct mutex mutex;\n\tstruct nsim_map_entry {\n\t\tvoid *key;\n\t\tvoid *value;\n\t} entry[NSIM_BPF_MAX_KEYS];\n\tstruct list_head l;\n};\n\nstatic int nsim_bpf_string_show(struct seq_file *file, void *data)\n{\n\tconst char **str = file->private;\n\n\tif (*str)\n\t\tseq_printf(file, \"%s\\n\", *str);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(nsim_bpf_string);\n\nstatic int\nnsim_bpf_verify_insn(struct bpf_verifier_env *env, int insn_idx, int prev_insn)\n{\n\tstruct nsim_bpf_bound_prog *state;\n\tint ret = 0;\n\n\tstate = env->prog->aux->offload->dev_priv;\n\tif (state->nsim_dev->bpf_bind_verifier_delay && !insn_idx)\n\t\tmsleep(state->nsim_dev->bpf_bind_verifier_delay);\n\n\tif (insn_idx == env->prog->len - 1) {\n\t\tpr_vlog(env, \"Hello from netdevsim!\\n\");\n\n\t\tif (!state->nsim_dev->bpf_bind_verifier_accept)\n\t\t\tret = -EOPNOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstatic int nsim_bpf_finalize(struct bpf_verifier_env *env)\n{\n\treturn 0;\n}\n\nstatic bool nsim_xdp_offload_active(struct netdevsim *ns)\n{\n\treturn ns->xdp_hw.prog;\n}\n\nstatic void nsim_prog_set_loaded(struct bpf_prog *prog, bool loaded)\n{\n\tstruct nsim_bpf_bound_prog *state;\n\n\tif (!prog || !bpf_prog_is_offloaded(prog->aux))\n\t\treturn;\n\n\tstate = prog->aux->offload->dev_priv;\n\tstate->is_loaded = loaded;\n}\n\nstatic int\nnsim_bpf_offload(struct netdevsim *ns, struct bpf_prog *prog, bool oldprog)\n{\n\tnsim_prog_set_loaded(ns->bpf_offloaded, false);\n\n\tWARN(!!ns->bpf_offloaded != oldprog,\n\t     \"bad offload state, expected offload %sto be active\",\n\t     oldprog ? \"\" : \"not \");\n\tns->bpf_offloaded = prog;\n\tns->bpf_offloaded_id = prog ? prog->aux->id : 0;\n\tnsim_prog_set_loaded(prog, true);\n\n\treturn 0;\n}\n\nint nsim_bpf_setup_tc_block_cb(enum tc_setup_type type,\n\t\t\t       void *type_data, void *cb_priv)\n{\n\tstruct tc_cls_bpf_offload *cls_bpf = type_data;\n\tstruct bpf_prog *prog = cls_bpf->prog;\n\tstruct netdevsim *ns = cb_priv;\n\tstruct bpf_prog *oldprog;\n\n\tif (type != TC_SETUP_CLSBPF) {\n\t\tNSIM_EA(cls_bpf->common.extack,\n\t\t\t\"only offload of BPF classifiers supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!tc_cls_can_offload_and_chain0(ns->netdev, &cls_bpf->common))\n\t\treturn -EOPNOTSUPP;\n\n\tif (cls_bpf->common.protocol != htons(ETH_P_ALL)) {\n\t\tNSIM_EA(cls_bpf->common.extack,\n\t\t\t\"only ETH_P_ALL supported as filter protocol\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!ns->bpf_tc_accept) {\n\t\tNSIM_EA(cls_bpf->common.extack,\n\t\t\t\"netdevsim configured to reject BPF TC offload\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\t \n\tif (prog && !prog->aux->offload && !ns->bpf_tc_non_bound_accept) {\n\t\tNSIM_EA(cls_bpf->common.extack,\n\t\t\t\"netdevsim configured to reject unbound programs\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (cls_bpf->command != TC_CLSBPF_OFFLOAD)\n\t\treturn -EOPNOTSUPP;\n\n\toldprog = cls_bpf->oldprog;\n\n\t \n\tif (ns->bpf_offloaded != oldprog) {\n\t\toldprog = NULL;\n\t\tif (!cls_bpf->prog)\n\t\t\treturn 0;\n\t\tif (ns->bpf_offloaded) {\n\t\t\tNSIM_EA(cls_bpf->common.extack,\n\t\t\t\t\"driver and netdev offload states mismatch\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\treturn nsim_bpf_offload(ns, cls_bpf->prog, oldprog);\n}\n\nint nsim_bpf_disable_tc(struct netdevsim *ns)\n{\n\tif (ns->bpf_offloaded && !nsim_xdp_offload_active(ns))\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\nstatic int nsim_xdp_offload_prog(struct netdevsim *ns, struct netdev_bpf *bpf)\n{\n\tif (!nsim_xdp_offload_active(ns) && !bpf->prog)\n\t\treturn 0;\n\tif (!nsim_xdp_offload_active(ns) && bpf->prog && ns->bpf_offloaded) {\n\t\tNSIM_EA(bpf->extack, \"TC program is already loaded\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn nsim_bpf_offload(ns, bpf->prog, nsim_xdp_offload_active(ns));\n}\n\nstatic int\nnsim_xdp_set_prog(struct netdevsim *ns, struct netdev_bpf *bpf,\n\t\t  struct xdp_attachment_info *xdp)\n{\n\tint err;\n\n\tif (bpf->command == XDP_SETUP_PROG && !ns->bpf_xdpdrv_accept) {\n\t\tNSIM_EA(bpf->extack, \"driver XDP disabled in DebugFS\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (bpf->command == XDP_SETUP_PROG_HW && !ns->bpf_xdpoffload_accept) {\n\t\tNSIM_EA(bpf->extack, \"XDP offload disabled in DebugFS\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (bpf->command == XDP_SETUP_PROG_HW) {\n\t\terr = nsim_xdp_offload_prog(ns, bpf);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\txdp_attachment_setup(xdp, bpf);\n\n\treturn 0;\n}\n\nstatic int nsim_bpf_create_prog(struct nsim_dev *nsim_dev,\n\t\t\t\tstruct bpf_prog *prog)\n{\n\tstruct nsim_bpf_bound_prog *state;\n\tchar name[16];\n\tint ret;\n\n\tstate = kzalloc(sizeof(*state), GFP_KERNEL);\n\tif (!state)\n\t\treturn -ENOMEM;\n\n\tstate->nsim_dev = nsim_dev;\n\tstate->prog = prog;\n\tstate->state = \"verify\";\n\n\t \n\tsprintf(name, \"%u\", nsim_dev->prog_id_gen++);\n\tstate->ddir = debugfs_create_dir(name, nsim_dev->ddir_bpf_bound_progs);\n\tif (IS_ERR(state->ddir)) {\n\t\tret = PTR_ERR(state->ddir);\n\t\tkfree(state);\n\t\treturn ret;\n\t}\n\n\tdebugfs_create_u32(\"id\", 0400, state->ddir, &prog->aux->id);\n\tdebugfs_create_file(\"state\", 0400, state->ddir,\n\t\t\t    &state->state, &nsim_bpf_string_fops);\n\tdebugfs_create_bool(\"loaded\", 0400, state->ddir, &state->is_loaded);\n\n\tlist_add_tail(&state->l, &nsim_dev->bpf_bound_progs);\n\n\tprog->aux->offload->dev_priv = state;\n\n\treturn 0;\n}\n\nstatic int nsim_bpf_verifier_prep(struct bpf_prog *prog)\n{\n\tstruct nsim_dev *nsim_dev =\n\t\t\tbpf_offload_dev_priv(prog->aux->offload->offdev);\n\n\tif (!nsim_dev->bpf_bind_accept)\n\t\treturn -EOPNOTSUPP;\n\n\treturn nsim_bpf_create_prog(nsim_dev, prog);\n}\n\nstatic int nsim_bpf_translate(struct bpf_prog *prog)\n{\n\tstruct nsim_bpf_bound_prog *state = prog->aux->offload->dev_priv;\n\n\tstate->state = \"xlated\";\n\treturn 0;\n}\n\nstatic void nsim_bpf_destroy_prog(struct bpf_prog *prog)\n{\n\tstruct nsim_bpf_bound_prog *state;\n\n\tstate = prog->aux->offload->dev_priv;\n\tWARN(state->is_loaded,\n\t     \"offload state destroyed while program still bound\");\n\tdebugfs_remove_recursive(state->ddir);\n\tlist_del(&state->l);\n\tkfree(state);\n}\n\nstatic const struct bpf_prog_offload_ops nsim_bpf_dev_ops = {\n\t.insn_hook\t= nsim_bpf_verify_insn,\n\t.finalize\t= nsim_bpf_finalize,\n\t.prepare\t= nsim_bpf_verifier_prep,\n\t.translate\t= nsim_bpf_translate,\n\t.destroy\t= nsim_bpf_destroy_prog,\n};\n\nstatic int nsim_setup_prog_checks(struct netdevsim *ns, struct netdev_bpf *bpf)\n{\n\tif (bpf->prog && bpf->prog->aux->offload) {\n\t\tNSIM_EA(bpf->extack, \"attempt to load offloaded prog to drv\");\n\t\treturn -EINVAL;\n\t}\n\tif (ns->netdev->mtu > NSIM_XDP_MAX_MTU) {\n\t\tNSIM_EA(bpf->extack, \"MTU too large w/ XDP enabled\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int\nnsim_setup_prog_hw_checks(struct netdevsim *ns, struct netdev_bpf *bpf)\n{\n\tstruct nsim_bpf_bound_prog *state;\n\n\tif (!bpf->prog)\n\t\treturn 0;\n\n\tif (!bpf_prog_is_offloaded(bpf->prog->aux)) {\n\t\tNSIM_EA(bpf->extack, \"xdpoffload of non-bound program\");\n\t\treturn -EINVAL;\n\t}\n\n\tstate = bpf->prog->aux->offload->dev_priv;\n\tif (WARN_ON(strcmp(state->state, \"xlated\"))) {\n\t\tNSIM_EA(bpf->extack, \"offloading program in bad state\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic bool\nnsim_map_key_match(struct bpf_map *map, struct nsim_map_entry *e, void *key)\n{\n\treturn e->key && !memcmp(key, e->key, map->key_size);\n}\n\nstatic int nsim_map_key_find(struct bpf_offloaded_map *offmap, void *key)\n{\n\tstruct nsim_bpf_bound_map *nmap = offmap->dev_priv;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(nmap->entry); i++)\n\t\tif (nsim_map_key_match(&offmap->map, &nmap->entry[i], key))\n\t\t\treturn i;\n\n\treturn -ENOENT;\n}\n\nstatic int\nnsim_map_alloc_elem(struct bpf_offloaded_map *offmap, unsigned int idx)\n{\n\tstruct nsim_bpf_bound_map *nmap = offmap->dev_priv;\n\n\tnmap->entry[idx].key = kmalloc(offmap->map.key_size,\n\t\t\t\t       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);\n\tif (!nmap->entry[idx].key)\n\t\treturn -ENOMEM;\n\tnmap->entry[idx].value = kmalloc(offmap->map.value_size,\n\t\t\t\t\t GFP_KERNEL_ACCOUNT | __GFP_NOWARN);\n\tif (!nmap->entry[idx].value) {\n\t\tkfree(nmap->entry[idx].key);\n\t\tnmap->entry[idx].key = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nnsim_map_get_next_key(struct bpf_offloaded_map *offmap,\n\t\t      void *key, void *next_key)\n{\n\tstruct nsim_bpf_bound_map *nmap = offmap->dev_priv;\n\tint idx = -ENOENT;\n\n\tmutex_lock(&nmap->mutex);\n\n\tif (key)\n\t\tidx = nsim_map_key_find(offmap, key);\n\tif (idx == -ENOENT)\n\t\tidx = 0;\n\telse\n\t\tidx++;\n\n\tfor (; idx < ARRAY_SIZE(nmap->entry); idx++) {\n\t\tif (nmap->entry[idx].key) {\n\t\t\tmemcpy(next_key, nmap->entry[idx].key,\n\t\t\t       offmap->map.key_size);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&nmap->mutex);\n\n\tif (idx == ARRAY_SIZE(nmap->entry))\n\t\treturn -ENOENT;\n\treturn 0;\n}\n\nstatic int\nnsim_map_lookup_elem(struct bpf_offloaded_map *offmap, void *key, void *value)\n{\n\tstruct nsim_bpf_bound_map *nmap = offmap->dev_priv;\n\tint idx;\n\n\tmutex_lock(&nmap->mutex);\n\n\tidx = nsim_map_key_find(offmap, key);\n\tif (idx >= 0)\n\t\tmemcpy(value, nmap->entry[idx].value, offmap->map.value_size);\n\n\tmutex_unlock(&nmap->mutex);\n\n\treturn idx < 0 ? idx : 0;\n}\n\nstatic int\nnsim_map_update_elem(struct bpf_offloaded_map *offmap,\n\t\t     void *key, void *value, u64 flags)\n{\n\tstruct nsim_bpf_bound_map *nmap = offmap->dev_priv;\n\tint idx, err = 0;\n\n\tmutex_lock(&nmap->mutex);\n\n\tidx = nsim_map_key_find(offmap, key);\n\tif (idx < 0 && flags == BPF_EXIST) {\n\t\terr = idx;\n\t\tgoto exit_unlock;\n\t}\n\tif (idx >= 0 && flags == BPF_NOEXIST) {\n\t\terr = -EEXIST;\n\t\tgoto exit_unlock;\n\t}\n\n\tif (idx < 0) {\n\t\tfor (idx = 0; idx < ARRAY_SIZE(nmap->entry); idx++)\n\t\t\tif (!nmap->entry[idx].key)\n\t\t\t\tbreak;\n\t\tif (idx == ARRAY_SIZE(nmap->entry)) {\n\t\t\terr = -E2BIG;\n\t\t\tgoto exit_unlock;\n\t\t}\n\n\t\terr = nsim_map_alloc_elem(offmap, idx);\n\t\tif (err)\n\t\t\tgoto exit_unlock;\n\t}\n\n\tmemcpy(nmap->entry[idx].key, key, offmap->map.key_size);\n\tmemcpy(nmap->entry[idx].value, value, offmap->map.value_size);\nexit_unlock:\n\tmutex_unlock(&nmap->mutex);\n\n\treturn err;\n}\n\nstatic int nsim_map_delete_elem(struct bpf_offloaded_map *offmap, void *key)\n{\n\tstruct nsim_bpf_bound_map *nmap = offmap->dev_priv;\n\tint idx;\n\n\tif (offmap->map.map_type == BPF_MAP_TYPE_ARRAY)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&nmap->mutex);\n\n\tidx = nsim_map_key_find(offmap, key);\n\tif (idx >= 0) {\n\t\tkfree(nmap->entry[idx].key);\n\t\tkfree(nmap->entry[idx].value);\n\t\tmemset(&nmap->entry[idx], 0, sizeof(nmap->entry[idx]));\n\t}\n\n\tmutex_unlock(&nmap->mutex);\n\n\treturn idx < 0 ? idx : 0;\n}\n\nstatic const struct bpf_map_dev_ops nsim_bpf_map_ops = {\n\t.map_get_next_key\t= nsim_map_get_next_key,\n\t.map_lookup_elem\t= nsim_map_lookup_elem,\n\t.map_update_elem\t= nsim_map_update_elem,\n\t.map_delete_elem\t= nsim_map_delete_elem,\n};\n\nstatic int\nnsim_bpf_map_alloc(struct netdevsim *ns, struct bpf_offloaded_map *offmap)\n{\n\tstruct nsim_bpf_bound_map *nmap;\n\tint i, err;\n\n\tif (WARN_ON(offmap->map.map_type != BPF_MAP_TYPE_ARRAY &&\n\t\t    offmap->map.map_type != BPF_MAP_TYPE_HASH))\n\t\treturn -EINVAL;\n\tif (offmap->map.max_entries > NSIM_BPF_MAX_KEYS)\n\t\treturn -ENOMEM;\n\tif (offmap->map.map_flags)\n\t\treturn -EINVAL;\n\n\tnmap = kzalloc(sizeof(*nmap), GFP_KERNEL_ACCOUNT);\n\tif (!nmap)\n\t\treturn -ENOMEM;\n\n\toffmap->dev_priv = nmap;\n\tnmap->ns = ns;\n\tnmap->map = offmap;\n\tmutex_init(&nmap->mutex);\n\n\tif (offmap->map.map_type == BPF_MAP_TYPE_ARRAY) {\n\t\tfor (i = 0; i < ARRAY_SIZE(nmap->entry); i++) {\n\t\t\tu32 *key;\n\n\t\t\terr = nsim_map_alloc_elem(offmap, i);\n\t\t\tif (err)\n\t\t\t\tgoto err_free;\n\t\t\tkey = nmap->entry[i].key;\n\t\t\t*key = i;\n\t\t\tmemset(nmap->entry[i].value, 0, offmap->map.value_size);\n\t\t}\n\t}\n\n\toffmap->dev_ops = &nsim_bpf_map_ops;\n\tlist_add_tail(&nmap->l, &ns->nsim_dev->bpf_bound_maps);\n\n\treturn 0;\n\nerr_free:\n\twhile (--i >= 0) {\n\t\tkfree(nmap->entry[i].key);\n\t\tkfree(nmap->entry[i].value);\n\t}\n\tkfree(nmap);\n\treturn err;\n}\n\nstatic void nsim_bpf_map_free(struct bpf_offloaded_map *offmap)\n{\n\tstruct nsim_bpf_bound_map *nmap = offmap->dev_priv;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(nmap->entry); i++) {\n\t\tkfree(nmap->entry[i].key);\n\t\tkfree(nmap->entry[i].value);\n\t}\n\tlist_del_init(&nmap->l);\n\tmutex_destroy(&nmap->mutex);\n\tkfree(nmap);\n}\n\nint nsim_bpf(struct net_device *dev, struct netdev_bpf *bpf)\n{\n\tstruct netdevsim *ns = netdev_priv(dev);\n\tint err;\n\n\tASSERT_RTNL();\n\n\tswitch (bpf->command) {\n\tcase XDP_SETUP_PROG:\n\t\terr = nsim_setup_prog_checks(ns, bpf);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn nsim_xdp_set_prog(ns, bpf, &ns->xdp);\n\tcase XDP_SETUP_PROG_HW:\n\t\terr = nsim_setup_prog_hw_checks(ns, bpf);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn nsim_xdp_set_prog(ns, bpf, &ns->xdp_hw);\n\tcase BPF_OFFLOAD_MAP_ALLOC:\n\t\tif (!ns->bpf_map_accept)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\treturn nsim_bpf_map_alloc(ns, bpf->offmap);\n\tcase BPF_OFFLOAD_MAP_FREE:\n\t\tnsim_bpf_map_free(bpf->offmap);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nint nsim_bpf_dev_init(struct nsim_dev *nsim_dev)\n{\n\tint err;\n\n\tINIT_LIST_HEAD(&nsim_dev->bpf_bound_progs);\n\tINIT_LIST_HEAD(&nsim_dev->bpf_bound_maps);\n\n\tnsim_dev->ddir_bpf_bound_progs = debugfs_create_dir(\"bpf_bound_progs\",\n\t\t\t\t\t\t\t    nsim_dev->ddir);\n\tif (IS_ERR(nsim_dev->ddir_bpf_bound_progs))\n\t\treturn PTR_ERR(nsim_dev->ddir_bpf_bound_progs);\n\n\tnsim_dev->bpf_dev = bpf_offload_dev_create(&nsim_bpf_dev_ops, nsim_dev);\n\terr = PTR_ERR_OR_ZERO(nsim_dev->bpf_dev);\n\tif (err)\n\t\treturn err;\n\n\tnsim_dev->bpf_bind_accept = true;\n\tdebugfs_create_bool(\"bpf_bind_accept\", 0600, nsim_dev->ddir,\n\t\t\t    &nsim_dev->bpf_bind_accept);\n\tdebugfs_create_u32(\"bpf_bind_verifier_delay\", 0600, nsim_dev->ddir,\n\t\t\t   &nsim_dev->bpf_bind_verifier_delay);\n\tnsim_dev->bpf_bind_verifier_accept = true;\n\tdebugfs_create_bool(\"bpf_bind_verifier_accept\", 0600, nsim_dev->ddir,\n\t\t\t    &nsim_dev->bpf_bind_verifier_accept);\n\treturn 0;\n}\n\nvoid nsim_bpf_dev_exit(struct nsim_dev *nsim_dev)\n{\n\tWARN_ON(!list_empty(&nsim_dev->bpf_bound_progs));\n\tWARN_ON(!list_empty(&nsim_dev->bpf_bound_maps));\n\tbpf_offload_dev_destroy(nsim_dev->bpf_dev);\n}\n\nint nsim_bpf_init(struct netdevsim *ns)\n{\n\tstruct dentry *ddir = ns->nsim_dev_port->ddir;\n\tint err;\n\n\terr = bpf_offload_dev_netdev_register(ns->nsim_dev->bpf_dev,\n\t\t\t\t\t      ns->netdev);\n\tif (err)\n\t\treturn err;\n\n\tdebugfs_create_u32(\"bpf_offloaded_id\", 0400, ddir,\n\t\t\t   &ns->bpf_offloaded_id);\n\n\tns->bpf_tc_accept = true;\n\tdebugfs_create_bool(\"bpf_tc_accept\", 0600, ddir,\n\t\t\t    &ns->bpf_tc_accept);\n\tdebugfs_create_bool(\"bpf_tc_non_bound_accept\", 0600, ddir,\n\t\t\t    &ns->bpf_tc_non_bound_accept);\n\tns->bpf_xdpdrv_accept = true;\n\tdebugfs_create_bool(\"bpf_xdpdrv_accept\", 0600, ddir,\n\t\t\t    &ns->bpf_xdpdrv_accept);\n\tns->bpf_xdpoffload_accept = true;\n\tdebugfs_create_bool(\"bpf_xdpoffload_accept\", 0600, ddir,\n\t\t\t    &ns->bpf_xdpoffload_accept);\n\n\tns->bpf_map_accept = true;\n\tdebugfs_create_bool(\"bpf_map_accept\", 0600, ddir,\n\t\t\t    &ns->bpf_map_accept);\n\n\treturn 0;\n}\n\nvoid nsim_bpf_uninit(struct netdevsim *ns)\n{\n\tWARN_ON(ns->xdp.prog);\n\tWARN_ON(ns->xdp_hw.prog);\n\tWARN_ON(ns->bpf_offloaded);\n\tbpf_offload_dev_netdev_unregister(ns->nsim_dev->bpf_dev, ns->netdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}