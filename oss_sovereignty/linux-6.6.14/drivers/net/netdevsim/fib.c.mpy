{
  "module_name": "fib.c",
  "hash_id": "41b9d995c626945d5e7f825aca3f514c5f5752a3d6c41fc6919465b40b5581dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/netdevsim/fib.c",
  "human_readable_source": " \n\n#include <linux/bitmap.h>\n#include <linux/in6.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/rhashtable.h>\n#include <linux/spinlock_types.h>\n#include <linux/types.h>\n#include <net/fib_notifier.h>\n#include <net/inet_dscp.h>\n#include <net/ip_fib.h>\n#include <net/ip6_fib.h>\n#include <net/fib_rules.h>\n#include <net/net_namespace.h>\n#include <net/nexthop.h>\n#include <linux/debugfs.h>\n\n#include \"netdevsim.h\"\n\nstruct nsim_fib_entry {\n\tu64 max;\n\tatomic64_t num;\n};\n\nstruct nsim_per_fib_data {\n\tstruct nsim_fib_entry fib;\n\tstruct nsim_fib_entry rules;\n};\n\nstruct nsim_fib_data {\n\tstruct notifier_block fib_nb;\n\tstruct nsim_per_fib_data ipv4;\n\tstruct nsim_per_fib_data ipv6;\n\tstruct nsim_fib_entry nexthops;\n\tstruct rhashtable fib_rt_ht;\n\tstruct list_head fib_rt_list;\n\tstruct mutex fib_lock;  \n\tstruct notifier_block nexthop_nb;\n\tstruct rhashtable nexthop_ht;\n\tstruct devlink *devlink;\n\tstruct work_struct fib_event_work;\n\tstruct work_struct fib_flush_work;\n\tstruct list_head fib_event_queue;\n\tspinlock_t fib_event_queue_lock;  \n\tstruct mutex nh_lock;  \n\tstruct dentry *ddir;\n\tbool fail_route_offload;\n\tbool fail_res_nexthop_group_replace;\n\tbool fail_nexthop_bucket_replace;\n\tbool fail_route_delete;\n};\n\nstruct nsim_fib_rt_key {\n\tunsigned char addr[sizeof(struct in6_addr)];\n\tunsigned char prefix_len;\n\tint family;\n\tu32 tb_id;\n};\n\nstruct nsim_fib_rt {\n\tstruct nsim_fib_rt_key key;\n\tstruct rhash_head ht_node;\n\tstruct list_head list;\t \n};\n\nstruct nsim_fib4_rt {\n\tstruct nsim_fib_rt common;\n\tstruct fib_info *fi;\n\tdscp_t dscp;\n\tu8 type;\n};\n\nstruct nsim_fib6_rt {\n\tstruct nsim_fib_rt common;\n\tstruct list_head nh_list;\n\tunsigned int nhs;\n};\n\nstruct nsim_fib6_rt_nh {\n\tstruct list_head list;\t \n\tstruct fib6_info *rt;\n};\n\nstruct nsim_fib6_event {\n\tstruct fib6_info **rt_arr;\n\tunsigned int nrt6;\n};\n\nstruct nsim_fib_event {\n\tstruct list_head list;  \n\tunion {\n\t\tstruct fib_entry_notifier_info fen_info;\n\t\tstruct nsim_fib6_event fib6_event;\n\t};\n\tstruct nsim_fib_data *data;\n\tunsigned long event;\n\tint family;\n};\n\nstatic const struct rhashtable_params nsim_fib_rt_ht_params = {\n\t.key_offset = offsetof(struct nsim_fib_rt, key),\n\t.head_offset = offsetof(struct nsim_fib_rt, ht_node),\n\t.key_len = sizeof(struct nsim_fib_rt_key),\n\t.automatic_shrinking = true,\n};\n\nstruct nsim_nexthop {\n\tstruct rhash_head ht_node;\n\tu64 occ;\n\tu32 id;\n\tbool is_resilient;\n};\n\nstatic const struct rhashtable_params nsim_nexthop_ht_params = {\n\t.key_offset = offsetof(struct nsim_nexthop, id),\n\t.head_offset = offsetof(struct nsim_nexthop, ht_node),\n\t.key_len = sizeof(u32),\n\t.automatic_shrinking = true,\n};\n\nu64 nsim_fib_get_val(struct nsim_fib_data *fib_data,\n\t\t     enum nsim_resource_id res_id, bool max)\n{\n\tstruct nsim_fib_entry *entry;\n\n\tswitch (res_id) {\n\tcase NSIM_RESOURCE_IPV4_FIB:\n\t\tentry = &fib_data->ipv4.fib;\n\t\tbreak;\n\tcase NSIM_RESOURCE_IPV4_FIB_RULES:\n\t\tentry = &fib_data->ipv4.rules;\n\t\tbreak;\n\tcase NSIM_RESOURCE_IPV6_FIB:\n\t\tentry = &fib_data->ipv6.fib;\n\t\tbreak;\n\tcase NSIM_RESOURCE_IPV6_FIB_RULES:\n\t\tentry = &fib_data->ipv6.rules;\n\t\tbreak;\n\tcase NSIM_RESOURCE_NEXTHOPS:\n\t\tentry = &fib_data->nexthops;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn max ? entry->max : atomic64_read(&entry->num);\n}\n\nstatic void nsim_fib_set_max(struct nsim_fib_data *fib_data,\n\t\t\t     enum nsim_resource_id res_id, u64 val)\n{\n\tstruct nsim_fib_entry *entry;\n\n\tswitch (res_id) {\n\tcase NSIM_RESOURCE_IPV4_FIB:\n\t\tentry = &fib_data->ipv4.fib;\n\t\tbreak;\n\tcase NSIM_RESOURCE_IPV4_FIB_RULES:\n\t\tentry = &fib_data->ipv4.rules;\n\t\tbreak;\n\tcase NSIM_RESOURCE_IPV6_FIB:\n\t\tentry = &fib_data->ipv6.fib;\n\t\tbreak;\n\tcase NSIM_RESOURCE_IPV6_FIB_RULES:\n\t\tentry = &fib_data->ipv6.rules;\n\t\tbreak;\n\tcase NSIM_RESOURCE_NEXTHOPS:\n\t\tentry = &fib_data->nexthops;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\tentry->max = val;\n}\n\nstatic int nsim_fib_rule_account(struct nsim_fib_entry *entry, bool add,\n\t\t\t\t struct netlink_ext_ack *extack)\n{\n\tint err = 0;\n\n\tif (add) {\n\t\tif (!atomic64_add_unless(&entry->num, 1, entry->max)) {\n\t\t\terr = -ENOSPC;\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Exceeded number of supported fib rule entries\");\n\t\t}\n\t} else {\n\t\tatomic64_dec_if_positive(&entry->num);\n\t}\n\n\treturn err;\n}\n\nstatic int nsim_fib_rule_event(struct nsim_fib_data *data,\n\t\t\t       struct fib_notifier_info *info, bool add)\n{\n\tstruct netlink_ext_ack *extack = info->extack;\n\tint err = 0;\n\n\tswitch (info->family) {\n\tcase AF_INET:\n\t\terr = nsim_fib_rule_account(&data->ipv4.rules, add, extack);\n\t\tbreak;\n\tcase AF_INET6:\n\t\terr = nsim_fib_rule_account(&data->ipv6.rules, add, extack);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int nsim_fib_account(struct nsim_fib_entry *entry, bool add)\n{\n\tint err = 0;\n\n\tif (add) {\n\t\tif (!atomic64_add_unless(&entry->num, 1, entry->max))\n\t\t\terr = -ENOSPC;\n\t} else {\n\t\tatomic64_dec_if_positive(&entry->num);\n\t}\n\n\treturn err;\n}\n\nstatic void nsim_fib_rt_init(struct nsim_fib_data *data,\n\t\t\t     struct nsim_fib_rt *fib_rt, const void *addr,\n\t\t\t     size_t addr_len, unsigned int prefix_len,\n\t\t\t     int family, u32 tb_id)\n{\n\tmemcpy(fib_rt->key.addr, addr, addr_len);\n\tfib_rt->key.prefix_len = prefix_len;\n\tfib_rt->key.family = family;\n\tfib_rt->key.tb_id = tb_id;\n\tlist_add(&fib_rt->list, &data->fib_rt_list);\n}\n\nstatic void nsim_fib_rt_fini(struct nsim_fib_rt *fib_rt)\n{\n\tlist_del(&fib_rt->list);\n}\n\nstatic struct nsim_fib_rt *nsim_fib_rt_lookup(struct rhashtable *fib_rt_ht,\n\t\t\t\t\t      const void *addr, size_t addr_len,\n\t\t\t\t\t      unsigned int prefix_len,\n\t\t\t\t\t      int family, u32 tb_id)\n{\n\tstruct nsim_fib_rt_key key;\n\n\tmemset(&key, 0, sizeof(key));\n\tmemcpy(key.addr, addr, addr_len);\n\tkey.prefix_len = prefix_len;\n\tkey.family = family;\n\tkey.tb_id = tb_id;\n\n\treturn rhashtable_lookup_fast(fib_rt_ht, &key, nsim_fib_rt_ht_params);\n}\n\nstatic struct nsim_fib4_rt *\nnsim_fib4_rt_create(struct nsim_fib_data *data,\n\t\t    struct fib_entry_notifier_info *fen_info)\n{\n\tstruct nsim_fib4_rt *fib4_rt;\n\n\tfib4_rt = kzalloc(sizeof(*fib4_rt), GFP_KERNEL);\n\tif (!fib4_rt)\n\t\treturn NULL;\n\n\tnsim_fib_rt_init(data, &fib4_rt->common, &fen_info->dst, sizeof(u32),\n\t\t\t fen_info->dst_len, AF_INET, fen_info->tb_id);\n\n\tfib4_rt->fi = fen_info->fi;\n\tfib_info_hold(fib4_rt->fi);\n\tfib4_rt->dscp = fen_info->dscp;\n\tfib4_rt->type = fen_info->type;\n\n\treturn fib4_rt;\n}\n\nstatic void nsim_fib4_rt_destroy(struct nsim_fib4_rt *fib4_rt)\n{\n\tfib_info_put(fib4_rt->fi);\n\tnsim_fib_rt_fini(&fib4_rt->common);\n\tkfree(fib4_rt);\n}\n\nstatic struct nsim_fib4_rt *\nnsim_fib4_rt_lookup(struct rhashtable *fib_rt_ht,\n\t\t    const struct fib_entry_notifier_info *fen_info)\n{\n\tstruct nsim_fib_rt *fib_rt;\n\n\tfib_rt = nsim_fib_rt_lookup(fib_rt_ht, &fen_info->dst, sizeof(u32),\n\t\t\t\t    fen_info->dst_len, AF_INET,\n\t\t\t\t    fen_info->tb_id);\n\tif (!fib_rt)\n\t\treturn NULL;\n\n\treturn container_of(fib_rt, struct nsim_fib4_rt, common);\n}\n\nstatic void\nnsim_fib4_rt_offload_failed_flag_set(struct net *net,\n\t\t\t\t     struct fib_entry_notifier_info *fen_info)\n{\n\tu32 *p_dst = (u32 *)&fen_info->dst;\n\tstruct fib_rt_info fri;\n\n\tfri.fi = fen_info->fi;\n\tfri.tb_id = fen_info->tb_id;\n\tfri.dst = cpu_to_be32(*p_dst);\n\tfri.dst_len = fen_info->dst_len;\n\tfri.dscp = fen_info->dscp;\n\tfri.type = fen_info->type;\n\tfri.offload = false;\n\tfri.trap = false;\n\tfri.offload_failed = true;\n\tfib_alias_hw_flags_set(net, &fri);\n}\n\nstatic void nsim_fib4_rt_hw_flags_set(struct net *net,\n\t\t\t\t      const struct nsim_fib4_rt *fib4_rt,\n\t\t\t\t      bool trap)\n{\n\tu32 *p_dst = (u32 *) fib4_rt->common.key.addr;\n\tint dst_len = fib4_rt->common.key.prefix_len;\n\tstruct fib_rt_info fri;\n\n\tfri.fi = fib4_rt->fi;\n\tfri.tb_id = fib4_rt->common.key.tb_id;\n\tfri.dst = cpu_to_be32(*p_dst);\n\tfri.dst_len = dst_len;\n\tfri.dscp = fib4_rt->dscp;\n\tfri.type = fib4_rt->type;\n\tfri.offload = false;\n\tfri.trap = trap;\n\tfri.offload_failed = false;\n\tfib_alias_hw_flags_set(net, &fri);\n}\n\nstatic int nsim_fib4_rt_add(struct nsim_fib_data *data,\n\t\t\t    struct nsim_fib4_rt *fib4_rt)\n{\n\tstruct net *net = devlink_net(data->devlink);\n\tint err;\n\n\terr = rhashtable_insert_fast(&data->fib_rt_ht,\n\t\t\t\t     &fib4_rt->common.ht_node,\n\t\t\t\t     nsim_fib_rt_ht_params);\n\tif (err)\n\t\tgoto err_fib_dismiss;\n\n\t \n\tmsleep(1);\n\tnsim_fib4_rt_hw_flags_set(net, fib4_rt, true);\n\n\treturn 0;\n\nerr_fib_dismiss:\n\t \n\tnsim_fib_account(&data->ipv4.fib, false);\n\treturn err;\n}\n\nstatic int nsim_fib4_rt_replace(struct nsim_fib_data *data,\n\t\t\t\tstruct nsim_fib4_rt *fib4_rt,\n\t\t\t\tstruct nsim_fib4_rt *fib4_rt_old)\n{\n\tstruct net *net = devlink_net(data->devlink);\n\tint err;\n\n\t \n\terr = nsim_fib_account(&data->ipv4.fib, false);\n\tif (err)\n\t\treturn err;\n\terr = rhashtable_replace_fast(&data->fib_rt_ht,\n\t\t\t\t      &fib4_rt_old->common.ht_node,\n\t\t\t\t      &fib4_rt->common.ht_node,\n\t\t\t\t      nsim_fib_rt_ht_params);\n\tif (err)\n\t\treturn err;\n\n\tmsleep(1);\n\tnsim_fib4_rt_hw_flags_set(net, fib4_rt, true);\n\n\tnsim_fib4_rt_hw_flags_set(net, fib4_rt_old, false);\n\tnsim_fib4_rt_destroy(fib4_rt_old);\n\n\treturn 0;\n}\n\nstatic int nsim_fib4_rt_insert(struct nsim_fib_data *data,\n\t\t\t       struct fib_entry_notifier_info *fen_info)\n{\n\tstruct nsim_fib4_rt *fib4_rt, *fib4_rt_old;\n\tint err;\n\n\tif (data->fail_route_offload) {\n\t\t \n\t\tmsleep(1);\n\t\treturn -EINVAL;\n\t}\n\n\tfib4_rt = nsim_fib4_rt_create(data, fen_info);\n\tif (!fib4_rt)\n\t\treturn -ENOMEM;\n\n\tfib4_rt_old = nsim_fib4_rt_lookup(&data->fib_rt_ht, fen_info);\n\tif (!fib4_rt_old)\n\t\terr = nsim_fib4_rt_add(data, fib4_rt);\n\telse\n\t\terr = nsim_fib4_rt_replace(data, fib4_rt, fib4_rt_old);\n\n\tif (err)\n\t\tnsim_fib4_rt_destroy(fib4_rt);\n\n\treturn err;\n}\n\nstatic void nsim_fib4_rt_remove(struct nsim_fib_data *data,\n\t\t\t\tconst struct fib_entry_notifier_info *fen_info)\n{\n\tstruct nsim_fib4_rt *fib4_rt;\n\n\tfib4_rt = nsim_fib4_rt_lookup(&data->fib_rt_ht, fen_info);\n\tif (!fib4_rt)\n\t\treturn;\n\n\trhashtable_remove_fast(&data->fib_rt_ht, &fib4_rt->common.ht_node,\n\t\t\t       nsim_fib_rt_ht_params);\n\tnsim_fib4_rt_destroy(fib4_rt);\n}\n\nstatic int nsim_fib4_event(struct nsim_fib_data *data,\n\t\t\t   struct fib_entry_notifier_info *fen_info,\n\t\t\t   unsigned long event)\n{\n\tint err = 0;\n\n\tswitch (event) {\n\tcase FIB_EVENT_ENTRY_REPLACE:\n\t\terr = nsim_fib4_rt_insert(data, fen_info);\n\t\tif (err) {\n\t\t\tstruct net *net = devlink_net(data->devlink);\n\n\t\t\tnsim_fib4_rt_offload_failed_flag_set(net, fen_info);\n\t\t}\n\t\tbreak;\n\tcase FIB_EVENT_ENTRY_DEL:\n\t\tnsim_fib4_rt_remove(data, fen_info);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic struct nsim_fib6_rt_nh *\nnsim_fib6_rt_nh_find(const struct nsim_fib6_rt *fib6_rt,\n\t\t     const struct fib6_info *rt)\n{\n\tstruct nsim_fib6_rt_nh *fib6_rt_nh;\n\n\tlist_for_each_entry(fib6_rt_nh, &fib6_rt->nh_list, list) {\n\t\tif (fib6_rt_nh->rt == rt)\n\t\t\treturn fib6_rt_nh;\n\t}\n\n\treturn NULL;\n}\n\nstatic int nsim_fib6_rt_nh_add(struct nsim_fib6_rt *fib6_rt,\n\t\t\t       struct fib6_info *rt)\n{\n\tstruct nsim_fib6_rt_nh *fib6_rt_nh;\n\n\tfib6_rt_nh = kzalloc(sizeof(*fib6_rt_nh), GFP_KERNEL);\n\tif (!fib6_rt_nh)\n\t\treturn -ENOMEM;\n\n\tfib6_info_hold(rt);\n\tfib6_rt_nh->rt = rt;\n\tlist_add_tail(&fib6_rt_nh->list, &fib6_rt->nh_list);\n\tfib6_rt->nhs++;\n\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void nsim_rt6_release(struct fib6_info *rt)\n{\n\tfib6_info_release(rt);\n}\n#else\nstatic void nsim_rt6_release(struct fib6_info *rt)\n{\n}\n#endif\n\nstatic void nsim_fib6_rt_nh_del(struct nsim_fib6_rt *fib6_rt,\n\t\t\t\tconst struct fib6_info *rt)\n{\n\tstruct nsim_fib6_rt_nh *fib6_rt_nh;\n\n\tfib6_rt_nh = nsim_fib6_rt_nh_find(fib6_rt, rt);\n\tif (!fib6_rt_nh)\n\t\treturn;\n\n\tfib6_rt->nhs--;\n\tlist_del(&fib6_rt_nh->list);\n\tnsim_rt6_release(fib6_rt_nh->rt);\n\tkfree(fib6_rt_nh);\n}\n\nstatic struct nsim_fib6_rt *\nnsim_fib6_rt_create(struct nsim_fib_data *data,\n\t\t    struct fib6_info **rt_arr, unsigned int nrt6)\n{\n\tstruct fib6_info *rt = rt_arr[0];\n\tstruct nsim_fib6_rt *fib6_rt;\n\tint i = 0;\n\tint err;\n\n\tfib6_rt = kzalloc(sizeof(*fib6_rt), GFP_KERNEL);\n\tif (!fib6_rt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnsim_fib_rt_init(data, &fib6_rt->common, &rt->fib6_dst.addr,\n\t\t\t sizeof(rt->fib6_dst.addr), rt->fib6_dst.plen, AF_INET6,\n\t\t\t rt->fib6_table->tb6_id);\n\n\t \n\tINIT_LIST_HEAD(&fib6_rt->nh_list);\n\n\tfor (i = 0; i < nrt6; i++) {\n\t\terr = nsim_fib6_rt_nh_add(fib6_rt, rt_arr[i]);\n\t\tif (err)\n\t\t\tgoto err_fib6_rt_nh_del;\n\t}\n\n\treturn fib6_rt;\n\nerr_fib6_rt_nh_del:\n\tfor (i--; i >= 0; i--) {\n\t\tnsim_fib6_rt_nh_del(fib6_rt, rt_arr[i]);\n\t}\n\tnsim_fib_rt_fini(&fib6_rt->common);\n\tkfree(fib6_rt);\n\treturn ERR_PTR(err);\n}\n\nstatic void nsim_fib6_rt_destroy(struct nsim_fib6_rt *fib6_rt)\n{\n\tstruct nsim_fib6_rt_nh *iter, *tmp;\n\n\tlist_for_each_entry_safe(iter, tmp, &fib6_rt->nh_list, list)\n\t\tnsim_fib6_rt_nh_del(fib6_rt, iter->rt);\n\tWARN_ON_ONCE(!list_empty(&fib6_rt->nh_list));\n\tnsim_fib_rt_fini(&fib6_rt->common);\n\tkfree(fib6_rt);\n}\n\nstatic struct nsim_fib6_rt *\nnsim_fib6_rt_lookup(struct rhashtable *fib_rt_ht, const struct fib6_info *rt)\n{\n\tstruct nsim_fib_rt *fib_rt;\n\n\tfib_rt = nsim_fib_rt_lookup(fib_rt_ht, &rt->fib6_dst.addr,\n\t\t\t\t    sizeof(rt->fib6_dst.addr),\n\t\t\t\t    rt->fib6_dst.plen, AF_INET6,\n\t\t\t\t    rt->fib6_table->tb6_id);\n\tif (!fib_rt)\n\t\treturn NULL;\n\n\treturn container_of(fib_rt, struct nsim_fib6_rt, common);\n}\n\nstatic int nsim_fib6_rt_append(struct nsim_fib_data *data,\n\t\t\t       struct nsim_fib6_event *fib6_event)\n{\n\tstruct fib6_info *rt = fib6_event->rt_arr[0];\n\tstruct nsim_fib6_rt *fib6_rt;\n\tint i, err;\n\n\tif (data->fail_route_offload) {\n\t\t \n\t\tmsleep(1);\n\t\treturn -EINVAL;\n\t}\n\n\tfib6_rt = nsim_fib6_rt_lookup(&data->fib_rt_ht, rt);\n\tif (!fib6_rt)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < fib6_event->nrt6; i++) {\n\t\terr = nsim_fib6_rt_nh_add(fib6_rt, fib6_event->rt_arr[i]);\n\t\tif (err)\n\t\t\tgoto err_fib6_rt_nh_del;\n\n\t\tWRITE_ONCE(fib6_event->rt_arr[i]->trap, true);\n\t}\n\n\treturn 0;\n\nerr_fib6_rt_nh_del:\n\tfor (i--; i >= 0; i--) {\n\t\tWRITE_ONCE(fib6_event->rt_arr[i]->trap, false);\n\t\tnsim_fib6_rt_nh_del(fib6_rt, fib6_event->rt_arr[i]);\n\t}\n\treturn err;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void nsim_fib6_rt_offload_failed_flag_set(struct nsim_fib_data *data,\n\t\t\t\t\t\t struct fib6_info **rt_arr,\n\t\t\t\t\t\t unsigned int nrt6)\n\n{\n\tstruct net *net = devlink_net(data->devlink);\n\tint i;\n\n\tfor (i = 0; i < nrt6; i++)\n\t\tfib6_info_hw_flags_set(net, rt_arr[i], false, false, true);\n}\n#else\nstatic void nsim_fib6_rt_offload_failed_flag_set(struct nsim_fib_data *data,\n\t\t\t\t\t\t struct fib6_info **rt_arr,\n\t\t\t\t\t\t unsigned int nrt6)\n{\n}\n#endif\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void nsim_fib6_rt_hw_flags_set(struct nsim_fib_data *data,\n\t\t\t\t      const struct nsim_fib6_rt *fib6_rt,\n\t\t\t\t      bool trap)\n{\n\tstruct net *net = devlink_net(data->devlink);\n\tstruct nsim_fib6_rt_nh *fib6_rt_nh;\n\n\tlist_for_each_entry(fib6_rt_nh, &fib6_rt->nh_list, list)\n\t\tfib6_info_hw_flags_set(net, fib6_rt_nh->rt, false, trap, false);\n}\n#else\nstatic void nsim_fib6_rt_hw_flags_set(struct nsim_fib_data *data,\n\t\t\t\t      const struct nsim_fib6_rt *fib6_rt,\n\t\t\t\t      bool trap)\n{\n}\n#endif\n\nstatic int nsim_fib6_rt_add(struct nsim_fib_data *data,\n\t\t\t    struct nsim_fib6_rt *fib6_rt)\n{\n\tint err;\n\n\terr = rhashtable_insert_fast(&data->fib_rt_ht,\n\t\t\t\t     &fib6_rt->common.ht_node,\n\t\t\t\t     nsim_fib_rt_ht_params);\n\n\tif (err)\n\t\tgoto err_fib_dismiss;\n\n\tmsleep(1);\n\tnsim_fib6_rt_hw_flags_set(data, fib6_rt, true);\n\n\treturn 0;\n\nerr_fib_dismiss:\n\t \n\tnsim_fib_account(&data->ipv6.fib, false);\n\treturn err;\n}\n\nstatic int nsim_fib6_rt_replace(struct nsim_fib_data *data,\n\t\t\t\tstruct nsim_fib6_rt *fib6_rt,\n\t\t\t\tstruct nsim_fib6_rt *fib6_rt_old)\n{\n\tint err;\n\n\t \n\terr = nsim_fib_account(&data->ipv6.fib, false);\n\tif (err)\n\t\treturn err;\n\n\terr = rhashtable_replace_fast(&data->fib_rt_ht,\n\t\t\t\t      &fib6_rt_old->common.ht_node,\n\t\t\t\t      &fib6_rt->common.ht_node,\n\t\t\t\t      nsim_fib_rt_ht_params);\n\n\tif (err)\n\t\treturn err;\n\n\tmsleep(1);\n\tnsim_fib6_rt_hw_flags_set(data, fib6_rt, true);\n\n\tnsim_fib6_rt_hw_flags_set(data, fib6_rt_old, false);\n\tnsim_fib6_rt_destroy(fib6_rt_old);\n\n\treturn 0;\n}\n\nstatic int nsim_fib6_rt_insert(struct nsim_fib_data *data,\n\t\t\t       struct nsim_fib6_event *fib6_event)\n{\n\tstruct fib6_info *rt = fib6_event->rt_arr[0];\n\tstruct nsim_fib6_rt *fib6_rt, *fib6_rt_old;\n\tint err;\n\n\tif (data->fail_route_offload) {\n\t\t \n\t\tmsleep(1);\n\t\treturn -EINVAL;\n\t}\n\n\tfib6_rt = nsim_fib6_rt_create(data, fib6_event->rt_arr,\n\t\t\t\t      fib6_event->nrt6);\n\tif (IS_ERR(fib6_rt))\n\t\treturn PTR_ERR(fib6_rt);\n\n\tfib6_rt_old = nsim_fib6_rt_lookup(&data->fib_rt_ht, rt);\n\tif (!fib6_rt_old)\n\t\terr = nsim_fib6_rt_add(data, fib6_rt);\n\telse\n\t\terr = nsim_fib6_rt_replace(data, fib6_rt, fib6_rt_old);\n\n\tif (err)\n\t\tnsim_fib6_rt_destroy(fib6_rt);\n\n\treturn err;\n}\n\nstatic void nsim_fib6_rt_remove(struct nsim_fib_data *data,\n\t\t\t\tstruct nsim_fib6_event *fib6_event)\n{\n\tstruct fib6_info *rt = fib6_event->rt_arr[0];\n\tstruct nsim_fib6_rt *fib6_rt;\n\tint i;\n\n\t \n\tfib6_rt = nsim_fib6_rt_lookup(&data->fib_rt_ht, rt);\n\tif (!fib6_rt)\n\t\treturn;\n\n\t \n\tif (fib6_event->nrt6 != fib6_rt->nhs) {\n\t\tfor (i = 0; i < fib6_event->nrt6; i++)\n\t\t\tnsim_fib6_rt_nh_del(fib6_rt, fib6_event->rt_arr[i]);\n\t\treturn;\n\t}\n\n\trhashtable_remove_fast(&data->fib_rt_ht, &fib6_rt->common.ht_node,\n\t\t\t       nsim_fib_rt_ht_params);\n\tnsim_fib6_rt_destroy(fib6_rt);\n}\n\nstatic int nsim_fib6_event_init(struct nsim_fib6_event *fib6_event,\n\t\t\t\tstruct fib6_entry_notifier_info *fen6_info)\n{\n\tstruct fib6_info *rt = fen6_info->rt;\n\tstruct fib6_info **rt_arr;\n\tstruct fib6_info *iter;\n\tunsigned int nrt6;\n\tint i = 0;\n\n\tnrt6 = fen6_info->nsiblings + 1;\n\n\trt_arr = kcalloc(nrt6, sizeof(struct fib6_info *), GFP_ATOMIC);\n\tif (!rt_arr)\n\t\treturn -ENOMEM;\n\n\tfib6_event->rt_arr = rt_arr;\n\tfib6_event->nrt6 = nrt6;\n\n\trt_arr[0] = rt;\n\tfib6_info_hold(rt);\n\n\tif (!fen6_info->nsiblings)\n\t\treturn 0;\n\n\tlist_for_each_entry(iter, &rt->fib6_siblings, fib6_siblings) {\n\t\tif (i == fen6_info->nsiblings)\n\t\t\tbreak;\n\n\t\trt_arr[i + 1] = iter;\n\t\tfib6_info_hold(iter);\n\t\ti++;\n\t}\n\tWARN_ON_ONCE(i != fen6_info->nsiblings);\n\n\treturn 0;\n}\n\nstatic void nsim_fib6_event_fini(struct nsim_fib6_event *fib6_event)\n{\n\tint i;\n\n\tfor (i = 0; i < fib6_event->nrt6; i++)\n\t\tnsim_rt6_release(fib6_event->rt_arr[i]);\n\tkfree(fib6_event->rt_arr);\n}\n\nstatic int nsim_fib6_event(struct nsim_fib_data *data,\n\t\t\t   struct nsim_fib6_event *fib6_event,\n\t\t\t   unsigned long event)\n{\n\tint err;\n\n\tif (fib6_event->rt_arr[0]->fib6_src.plen)\n\t\treturn 0;\n\n\tswitch (event) {\n\tcase FIB_EVENT_ENTRY_REPLACE:\n\t\terr = nsim_fib6_rt_insert(data, fib6_event);\n\t\tif (err)\n\t\t\tgoto err_rt_offload_failed_flag_set;\n\t\tbreak;\n\tcase FIB_EVENT_ENTRY_APPEND:\n\t\terr = nsim_fib6_rt_append(data, fib6_event);\n\t\tif (err)\n\t\t\tgoto err_rt_offload_failed_flag_set;\n\t\tbreak;\n\tcase FIB_EVENT_ENTRY_DEL:\n\t\tnsim_fib6_rt_remove(data, fib6_event);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n\nerr_rt_offload_failed_flag_set:\n\tnsim_fib6_rt_offload_failed_flag_set(data, fib6_event->rt_arr,\n\t\t\t\t\t     fib6_event->nrt6);\n\treturn err;\n}\n\nstatic void nsim_fib_event(struct nsim_fib_event *fib_event)\n{\n\tswitch (fib_event->family) {\n\tcase AF_INET:\n\t\tnsim_fib4_event(fib_event->data, &fib_event->fen_info,\n\t\t\t\tfib_event->event);\n\t\tfib_info_put(fib_event->fen_info.fi);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tnsim_fib6_event(fib_event->data, &fib_event->fib6_event,\n\t\t\t\tfib_event->event);\n\t\tnsim_fib6_event_fini(&fib_event->fib6_event);\n\t\tbreak;\n\t}\n}\n\nstatic int nsim_fib4_prepare_event(struct fib_notifier_info *info,\n\t\t\t\t   struct nsim_fib_event *fib_event,\n\t\t\t\t   unsigned long event)\n{\n\tstruct nsim_fib_data *data = fib_event->data;\n\tstruct fib_entry_notifier_info *fen_info;\n\tstruct netlink_ext_ack *extack;\n\tint err = 0;\n\n\tfen_info = container_of(info, struct fib_entry_notifier_info,\n\t\t\t\tinfo);\n\tfib_event->fen_info = *fen_info;\n\textack = info->extack;\n\n\tswitch (event) {\n\tcase FIB_EVENT_ENTRY_REPLACE:\n\t\terr = nsim_fib_account(&data->ipv4.fib, true);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Exceeded number of supported fib entries\");\n\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tcase FIB_EVENT_ENTRY_DEL:\n\t\tif (data->fail_route_delete) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to process route deletion\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tnsim_fib_account(&data->ipv4.fib, false);\n\t\tbreak;\n\t}\n\n\t \n\tfib_info_hold(fib_event->fen_info.fi);\n\n\treturn 0;\n}\n\nstatic int nsim_fib6_prepare_event(struct fib_notifier_info *info,\n\t\t\t\t   struct nsim_fib_event *fib_event,\n\t\t\t\t   unsigned long event)\n{\n\tstruct nsim_fib_data *data = fib_event->data;\n\tstruct fib6_entry_notifier_info *fen6_info;\n\tstruct netlink_ext_ack *extack;\n\tint err = 0;\n\n\tfen6_info = container_of(info, struct fib6_entry_notifier_info,\n\t\t\t\t info);\n\n\terr = nsim_fib6_event_init(&fib_event->fib6_event, fen6_info);\n\tif (err)\n\t\treturn err;\n\n\textack = info->extack;\n\tswitch (event) {\n\tcase FIB_EVENT_ENTRY_REPLACE:\n\t\terr = nsim_fib_account(&data->ipv6.fib, true);\n\t\tif (err) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Exceeded number of supported fib entries\");\n\t\t\tgoto err_fib6_event_fini;\n\t\t}\n\t\tbreak;\n\tcase FIB_EVENT_ENTRY_DEL:\n\t\tif (data->fail_route_delete) {\n\t\t\terr = -EINVAL;\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to process route deletion\");\n\t\t\tgoto err_fib6_event_fini;\n\t\t}\n\t\tnsim_fib_account(&data->ipv6.fib, false);\n\t\tbreak;\n\t}\n\n\treturn 0;\n\nerr_fib6_event_fini:\n\tnsim_fib6_event_fini(&fib_event->fib6_event);\n\treturn err;\n}\n\nstatic int nsim_fib_event_schedule_work(struct nsim_fib_data *data,\n\t\t\t\t\tstruct fib_notifier_info *info,\n\t\t\t\t\tunsigned long event)\n{\n\tstruct nsim_fib_event *fib_event;\n\tint err;\n\n\tif (info->family != AF_INET && info->family != AF_INET6)\n\t\t \n\t\treturn NOTIFY_DONE;\n\n\tfib_event = kzalloc(sizeof(*fib_event), GFP_ATOMIC);\n\tif (!fib_event)\n\t\tgoto err_fib_event_alloc;\n\n\tfib_event->data = data;\n\tfib_event->event = event;\n\tfib_event->family = info->family;\n\n\tswitch (info->family) {\n\tcase AF_INET:\n\t\terr = nsim_fib4_prepare_event(info, fib_event, event);\n\t\tbreak;\n\tcase AF_INET6:\n\t\terr = nsim_fib6_prepare_event(info, fib_event, event);\n\t\tbreak;\n\t}\n\n\tif (err)\n\t\tgoto err_fib_prepare_event;\n\n\t \n\tspin_lock_bh(&data->fib_event_queue_lock);\n\tlist_add_tail(&fib_event->list, &data->fib_event_queue);\n\tspin_unlock_bh(&data->fib_event_queue_lock);\n\tschedule_work(&data->fib_event_work);\n\n\treturn NOTIFY_DONE;\n\nerr_fib_prepare_event:\n\tkfree(fib_event);\nerr_fib_event_alloc:\n\tif (event == FIB_EVENT_ENTRY_DEL)\n\t\tschedule_work(&data->fib_flush_work);\n\treturn NOTIFY_BAD;\n}\n\nstatic int nsim_fib_event_nb(struct notifier_block *nb, unsigned long event,\n\t\t\t     void *ptr)\n{\n\tstruct nsim_fib_data *data = container_of(nb, struct nsim_fib_data,\n\t\t\t\t\t\t  fib_nb);\n\tstruct fib_notifier_info *info = ptr;\n\tint err;\n\n\tswitch (event) {\n\tcase FIB_EVENT_RULE_ADD:\n\tcase FIB_EVENT_RULE_DEL:\n\t\terr = nsim_fib_rule_event(data, info,\n\t\t\t\t\t  event == FIB_EVENT_RULE_ADD);\n\t\treturn notifier_from_errno(err);\n\tcase FIB_EVENT_ENTRY_REPLACE:\n\tcase FIB_EVENT_ENTRY_APPEND:\n\tcase FIB_EVENT_ENTRY_DEL:\n\t\treturn nsim_fib_event_schedule_work(data, info, event);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic void nsim_fib4_rt_free(struct nsim_fib_rt *fib_rt,\n\t\t\t      struct nsim_fib_data *data)\n{\n\tstruct devlink *devlink = data->devlink;\n\tstruct nsim_fib4_rt *fib4_rt;\n\n\tfib4_rt = container_of(fib_rt, struct nsim_fib4_rt, common);\n\tnsim_fib4_rt_hw_flags_set(devlink_net(devlink), fib4_rt, false);\n\tnsim_fib_account(&data->ipv4.fib, false);\n\tnsim_fib4_rt_destroy(fib4_rt);\n}\n\nstatic void nsim_fib6_rt_free(struct nsim_fib_rt *fib_rt,\n\t\t\t      struct nsim_fib_data *data)\n{\n\tstruct nsim_fib6_rt *fib6_rt;\n\n\tfib6_rt = container_of(fib_rt, struct nsim_fib6_rt, common);\n\tnsim_fib6_rt_hw_flags_set(data, fib6_rt, false);\n\tnsim_fib_account(&data->ipv6.fib, false);\n\tnsim_fib6_rt_destroy(fib6_rt);\n}\n\nstatic void nsim_fib_rt_free(void *ptr, void *arg)\n{\n\tstruct nsim_fib_rt *fib_rt = ptr;\n\tstruct nsim_fib_data *data = arg;\n\n\tswitch (fib_rt->key.family) {\n\tcase AF_INET:\n\t\tnsim_fib4_rt_free(fib_rt, data);\n\t\tbreak;\n\tcase AF_INET6:\n\t\tnsim_fib6_rt_free(fib_rt, data);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n}\n\n \nstatic void nsim_fib_dump_inconsistent(struct notifier_block *nb)\n{\n\tstruct nsim_fib_data *data = container_of(nb, struct nsim_fib_data,\n\t\t\t\t\t\t  fib_nb);\n\tstruct nsim_fib_rt *fib_rt, *fib_rt_tmp;\n\n\t \n\tflush_work(&data->fib_event_work);\n\n\t \n\tlist_for_each_entry_safe(fib_rt, fib_rt_tmp, &data->fib_rt_list, list) {\n\t\trhashtable_remove_fast(&data->fib_rt_ht, &fib_rt->ht_node,\n\t\t\t\t       nsim_fib_rt_ht_params);\n\t\tnsim_fib_rt_free(fib_rt, data);\n\t}\n\n\tatomic64_set(&data->ipv4.rules.num, 0ULL);\n\tatomic64_set(&data->ipv6.rules.num, 0ULL);\n}\n\nstatic struct nsim_nexthop *nsim_nexthop_create(struct nsim_fib_data *data,\n\t\t\t\t\t\tstruct nh_notifier_info *info)\n{\n\tstruct nsim_nexthop *nexthop;\n\tu64 occ = 0;\n\tint i;\n\n\tnexthop = kzalloc(sizeof(*nexthop), GFP_KERNEL);\n\tif (!nexthop)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tnexthop->id = info->id;\n\n\t \n\n\tswitch (info->type) {\n\tcase NH_NOTIFIER_INFO_TYPE_SINGLE:\n\t\tocc = 1;\n\t\tbreak;\n\tcase NH_NOTIFIER_INFO_TYPE_GRP:\n\t\tfor (i = 0; i < info->nh_grp->num_nh; i++)\n\t\t\tocc += info->nh_grp->nh_entries[i].weight;\n\t\tbreak;\n\tcase NH_NOTIFIER_INFO_TYPE_RES_TABLE:\n\t\tocc = info->nh_res_table->num_nh_buckets;\n\t\tnexthop->is_resilient = true;\n\t\tbreak;\n\tdefault:\n\t\tNL_SET_ERR_MSG_MOD(info->extack, \"Unsupported nexthop type\");\n\t\tkfree(nexthop);\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\n\tnexthop->occ = occ;\n\treturn nexthop;\n}\n\nstatic void nsim_nexthop_destroy(struct nsim_nexthop *nexthop)\n{\n\tkfree(nexthop);\n}\n\nstatic int nsim_nexthop_account(struct nsim_fib_data *data, u64 occ,\n\t\t\t\tbool add, struct netlink_ext_ack *extack)\n{\n\tint i, err = 0;\n\n\tif (add) {\n\t\tfor (i = 0; i < occ; i++)\n\t\t\tif (!atomic64_add_unless(&data->nexthops.num, 1,\n\t\t\t\t\t\t data->nexthops.max)) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tNL_SET_ERR_MSG_MOD(extack, \"Exceeded number of supported nexthops\");\n\t\t\t\tgoto err_num_decrease;\n\t\t\t}\n\t} else {\n\t\tif (WARN_ON(occ > atomic64_read(&data->nexthops.num)))\n\t\t\treturn -EINVAL;\n\t\tatomic64_sub(occ, &data->nexthops.num);\n\t}\n\n\treturn err;\n\nerr_num_decrease:\n\tatomic64_sub(i, &data->nexthops.num);\n\treturn err;\n\n}\n\nstatic void nsim_nexthop_hw_flags_set(struct net *net,\n\t\t\t\t      const struct nsim_nexthop *nexthop,\n\t\t\t\t      bool trap)\n{\n\tint i;\n\n\tnexthop_set_hw_flags(net, nexthop->id, false, trap);\n\n\tif (!nexthop->is_resilient)\n\t\treturn;\n\n\tfor (i = 0; i < nexthop->occ; i++)\n\t\tnexthop_bucket_set_hw_flags(net, nexthop->id, i, false, trap);\n}\n\nstatic int nsim_nexthop_add(struct nsim_fib_data *data,\n\t\t\t    struct nsim_nexthop *nexthop,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct net *net = devlink_net(data->devlink);\n\tint err;\n\n\terr = nsim_nexthop_account(data, nexthop->occ, true, extack);\n\tif (err)\n\t\treturn err;\n\n\terr = rhashtable_insert_fast(&data->nexthop_ht, &nexthop->ht_node,\n\t\t\t\t     nsim_nexthop_ht_params);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to insert nexthop\");\n\t\tgoto err_nexthop_dismiss;\n\t}\n\n\tnsim_nexthop_hw_flags_set(net, nexthop, true);\n\n\treturn 0;\n\nerr_nexthop_dismiss:\n\tnsim_nexthop_account(data, nexthop->occ, false, extack);\n\treturn err;\n}\n\nstatic int nsim_nexthop_replace(struct nsim_fib_data *data,\n\t\t\t\tstruct nsim_nexthop *nexthop,\n\t\t\t\tstruct nsim_nexthop *nexthop_old,\n\t\t\t\tstruct netlink_ext_ack *extack)\n{\n\tstruct net *net = devlink_net(data->devlink);\n\tint err;\n\n\terr = nsim_nexthop_account(data, nexthop->occ, true, extack);\n\tif (err)\n\t\treturn err;\n\n\terr = rhashtable_replace_fast(&data->nexthop_ht,\n\t\t\t\t      &nexthop_old->ht_node, &nexthop->ht_node,\n\t\t\t\t      nsim_nexthop_ht_params);\n\tif (err) {\n\t\tNL_SET_ERR_MSG_MOD(extack, \"Failed to replace nexthop\");\n\t\tgoto err_nexthop_dismiss;\n\t}\n\n\tnsim_nexthop_hw_flags_set(net, nexthop, true);\n\tnsim_nexthop_account(data, nexthop_old->occ, false, extack);\n\tnsim_nexthop_destroy(nexthop_old);\n\n\treturn 0;\n\nerr_nexthop_dismiss:\n\tnsim_nexthop_account(data, nexthop->occ, false, extack);\n\treturn err;\n}\n\nstatic int nsim_nexthop_insert(struct nsim_fib_data *data,\n\t\t\t       struct nh_notifier_info *info)\n{\n\tstruct nsim_nexthop *nexthop, *nexthop_old;\n\tint err;\n\n\tnexthop = nsim_nexthop_create(data, info);\n\tif (IS_ERR(nexthop))\n\t\treturn PTR_ERR(nexthop);\n\n\tnexthop_old = rhashtable_lookup_fast(&data->nexthop_ht, &info->id,\n\t\t\t\t\t     nsim_nexthop_ht_params);\n\tif (!nexthop_old)\n\t\terr = nsim_nexthop_add(data, nexthop, info->extack);\n\telse\n\t\terr = nsim_nexthop_replace(data, nexthop, nexthop_old,\n\t\t\t\t\t   info->extack);\n\n\tif (err)\n\t\tnsim_nexthop_destroy(nexthop);\n\n\treturn err;\n}\n\nstatic void nsim_nexthop_remove(struct nsim_fib_data *data,\n\t\t\t\tstruct nh_notifier_info *info)\n{\n\tstruct nsim_nexthop *nexthop;\n\n\tnexthop = rhashtable_lookup_fast(&data->nexthop_ht, &info->id,\n\t\t\t\t\t nsim_nexthop_ht_params);\n\tif (!nexthop)\n\t\treturn;\n\n\trhashtable_remove_fast(&data->nexthop_ht, &nexthop->ht_node,\n\t\t\t       nsim_nexthop_ht_params);\n\tnsim_nexthop_account(data, nexthop->occ, false, info->extack);\n\tnsim_nexthop_destroy(nexthop);\n}\n\nstatic int nsim_nexthop_res_table_pre_replace(struct nsim_fib_data *data,\n\t\t\t\t\t      struct nh_notifier_info *info)\n{\n\tif (data->fail_res_nexthop_group_replace) {\n\t\tNL_SET_ERR_MSG_MOD(info->extack, \"Failed to replace a resilient nexthop group\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nsim_nexthop_bucket_replace(struct nsim_fib_data *data,\n\t\t\t\t       struct nh_notifier_info *info)\n{\n\tif (data->fail_nexthop_bucket_replace) {\n\t\tNL_SET_ERR_MSG_MOD(info->extack, \"Failed to replace nexthop bucket\");\n\t\treturn -EINVAL;\n\t}\n\n\tnexthop_bucket_set_hw_flags(info->net, info->id,\n\t\t\t\t    info->nh_res_bucket->bucket_index,\n\t\t\t\t    false, true);\n\n\treturn 0;\n}\n\nstatic int nsim_nexthop_event_nb(struct notifier_block *nb, unsigned long event,\n\t\t\t\t void *ptr)\n{\n\tstruct nsim_fib_data *data = container_of(nb, struct nsim_fib_data,\n\t\t\t\t\t\t  nexthop_nb);\n\tstruct nh_notifier_info *info = ptr;\n\tint err = 0;\n\n\tmutex_lock(&data->nh_lock);\n\tswitch (event) {\n\tcase NEXTHOP_EVENT_REPLACE:\n\t\terr = nsim_nexthop_insert(data, info);\n\t\tbreak;\n\tcase NEXTHOP_EVENT_DEL:\n\t\tnsim_nexthop_remove(data, info);\n\t\tbreak;\n\tcase NEXTHOP_EVENT_RES_TABLE_PRE_REPLACE:\n\t\terr = nsim_nexthop_res_table_pre_replace(data, info);\n\t\tbreak;\n\tcase NEXTHOP_EVENT_BUCKET_REPLACE:\n\t\terr = nsim_nexthop_bucket_replace(data, info);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&data->nh_lock);\n\treturn notifier_from_errno(err);\n}\n\nstatic void nsim_nexthop_free(void *ptr, void *arg)\n{\n\tstruct nsim_nexthop *nexthop = ptr;\n\tstruct nsim_fib_data *data = arg;\n\tstruct net *net;\n\n\tnet = devlink_net(data->devlink);\n\tnsim_nexthop_hw_flags_set(net, nexthop, false);\n\tnsim_nexthop_account(data, nexthop->occ, false, NULL);\n\tnsim_nexthop_destroy(nexthop);\n}\n\nstatic ssize_t nsim_nexthop_bucket_activity_write(struct file *file,\n\t\t\t\t\t\t  const char __user *user_buf,\n\t\t\t\t\t\t  size_t size, loff_t *ppos)\n{\n\tstruct nsim_fib_data *data = file->private_data;\n\tstruct net *net = devlink_net(data->devlink);\n\tstruct nsim_nexthop *nexthop;\n\tunsigned long *activity;\n\tloff_t pos = *ppos;\n\tu16 bucket_index;\n\tchar buf[128];\n\tint err = 0;\n\tu32 nhid;\n\n\tif (pos != 0)\n\t\treturn -EINVAL;\n\tif (size > sizeof(buf))\n\t\treturn -EINVAL;\n\tif (copy_from_user(buf, user_buf, size))\n\t\treturn -EFAULT;\n\tif (sscanf(buf, \"%u %hu\", &nhid, &bucket_index) != 2)\n\t\treturn -EINVAL;\n\n\trtnl_lock();\n\n\tnexthop = rhashtable_lookup_fast(&data->nexthop_ht, &nhid,\n\t\t\t\t\t nsim_nexthop_ht_params);\n\tif (!nexthop || !nexthop->is_resilient ||\n\t    bucket_index >= nexthop->occ) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tactivity = bitmap_zalloc(nexthop->occ, GFP_KERNEL);\n\tif (!activity) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tbitmap_set(activity, bucket_index, 1);\n\tnexthop_res_grp_activity_update(net, nhid, nexthop->occ, activity);\n\tbitmap_free(activity);\n\nout:\n\trtnl_unlock();\n\n\t*ppos = size;\n\treturn err ?: size;\n}\n\nstatic const struct file_operations nsim_nexthop_bucket_activity_fops = {\n\t.open = simple_open,\n\t.write = nsim_nexthop_bucket_activity_write,\n\t.llseek = no_llseek,\n\t.owner = THIS_MODULE,\n};\n\nstatic u64 nsim_fib_ipv4_resource_occ_get(void *priv)\n{\n\tstruct nsim_fib_data *data = priv;\n\n\treturn nsim_fib_get_val(data, NSIM_RESOURCE_IPV4_FIB, false);\n}\n\nstatic u64 nsim_fib_ipv4_rules_res_occ_get(void *priv)\n{\n\tstruct nsim_fib_data *data = priv;\n\n\treturn nsim_fib_get_val(data, NSIM_RESOURCE_IPV4_FIB_RULES, false);\n}\n\nstatic u64 nsim_fib_ipv6_resource_occ_get(void *priv)\n{\n\tstruct nsim_fib_data *data = priv;\n\n\treturn nsim_fib_get_val(data, NSIM_RESOURCE_IPV6_FIB, false);\n}\n\nstatic u64 nsim_fib_ipv6_rules_res_occ_get(void *priv)\n{\n\tstruct nsim_fib_data *data = priv;\n\n\treturn nsim_fib_get_val(data, NSIM_RESOURCE_IPV6_FIB_RULES, false);\n}\n\nstatic u64 nsim_fib_nexthops_res_occ_get(void *priv)\n{\n\tstruct nsim_fib_data *data = priv;\n\n\treturn nsim_fib_get_val(data, NSIM_RESOURCE_NEXTHOPS, false);\n}\n\nstatic void nsim_fib_set_max_all(struct nsim_fib_data *data,\n\t\t\t\t struct devlink *devlink)\n{\n\tstatic const enum nsim_resource_id res_ids[] = {\n\t\tNSIM_RESOURCE_IPV4_FIB, NSIM_RESOURCE_IPV4_FIB_RULES,\n\t\tNSIM_RESOURCE_IPV6_FIB, NSIM_RESOURCE_IPV6_FIB_RULES,\n\t\tNSIM_RESOURCE_NEXTHOPS,\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(res_ids); i++) {\n\t\tint err;\n\t\tu64 val;\n\n\t\terr = devl_resource_size_get(devlink, res_ids[i], &val);\n\t\tif (err)\n\t\t\tval = (u64) -1;\n\t\tnsim_fib_set_max(data, res_ids[i], val);\n\t}\n}\n\nstatic void nsim_fib_event_work(struct work_struct *work)\n{\n\tstruct nsim_fib_data *data = container_of(work, struct nsim_fib_data,\n\t\t\t\t\t\t  fib_event_work);\n\tstruct nsim_fib_event *fib_event, *next_fib_event;\n\n\tLIST_HEAD(fib_event_queue);\n\n\tspin_lock_bh(&data->fib_event_queue_lock);\n\tlist_splice_init(&data->fib_event_queue, &fib_event_queue);\n\tspin_unlock_bh(&data->fib_event_queue_lock);\n\n\tmutex_lock(&data->fib_lock);\n\tlist_for_each_entry_safe(fib_event, next_fib_event, &fib_event_queue,\n\t\t\t\t list) {\n\t\tnsim_fib_event(fib_event);\n\t\tlist_del(&fib_event->list);\n\t\tkfree(fib_event);\n\t\tcond_resched();\n\t}\n\tmutex_unlock(&data->fib_lock);\n}\n\nstatic void nsim_fib_flush_work(struct work_struct *work)\n{\n\tstruct nsim_fib_data *data = container_of(work, struct nsim_fib_data,\n\t\t\t\t\t\t  fib_flush_work);\n\tstruct nsim_fib_rt *fib_rt, *fib_rt_tmp;\n\n\t \n\tflush_work(&data->fib_event_work);\n\n\tmutex_lock(&data->fib_lock);\n\tlist_for_each_entry_safe(fib_rt, fib_rt_tmp, &data->fib_rt_list, list) {\n\t\trhashtable_remove_fast(&data->fib_rt_ht, &fib_rt->ht_node,\n\t\t\t\t       nsim_fib_rt_ht_params);\n\t\tnsim_fib_rt_free(fib_rt, data);\n\t}\n\tmutex_unlock(&data->fib_lock);\n}\n\nstatic int\nnsim_fib_debugfs_init(struct nsim_fib_data *data, struct nsim_dev *nsim_dev)\n{\n\tdata->ddir = debugfs_create_dir(\"fib\", nsim_dev->ddir);\n\tif (IS_ERR(data->ddir))\n\t\treturn PTR_ERR(data->ddir);\n\n\tdata->fail_route_offload = false;\n\tdebugfs_create_bool(\"fail_route_offload\", 0600, data->ddir,\n\t\t\t    &data->fail_route_offload);\n\n\tdata->fail_res_nexthop_group_replace = false;\n\tdebugfs_create_bool(\"fail_res_nexthop_group_replace\", 0600, data->ddir,\n\t\t\t    &data->fail_res_nexthop_group_replace);\n\n\tdata->fail_nexthop_bucket_replace = false;\n\tdebugfs_create_bool(\"fail_nexthop_bucket_replace\", 0600, data->ddir,\n\t\t\t    &data->fail_nexthop_bucket_replace);\n\n\tdebugfs_create_file(\"nexthop_bucket_activity\", 0200, data->ddir,\n\t\t\t    data, &nsim_nexthop_bucket_activity_fops);\n\n\tdata->fail_route_delete = false;\n\tdebugfs_create_bool(\"fail_route_delete\", 0600, data->ddir,\n\t\t\t    &data->fail_route_delete);\n\treturn 0;\n}\n\nstatic void nsim_fib_debugfs_exit(struct nsim_fib_data *data)\n{\n\tdebugfs_remove_recursive(data->ddir);\n}\n\nstruct nsim_fib_data *nsim_fib_create(struct devlink *devlink,\n\t\t\t\t      struct netlink_ext_ack *extack)\n{\n\tstruct nsim_fib_data *data;\n\tstruct nsim_dev *nsim_dev;\n\tint err;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\tdata->devlink = devlink;\n\n\tnsim_dev = devlink_priv(devlink);\n\terr = nsim_fib_debugfs_init(data, nsim_dev);\n\tif (err)\n\t\tgoto err_data_free;\n\n\tmutex_init(&data->nh_lock);\n\terr = rhashtable_init(&data->nexthop_ht, &nsim_nexthop_ht_params);\n\tif (err)\n\t\tgoto err_debugfs_exit;\n\n\tmutex_init(&data->fib_lock);\n\tINIT_LIST_HEAD(&data->fib_rt_list);\n\terr = rhashtable_init(&data->fib_rt_ht, &nsim_fib_rt_ht_params);\n\tif (err)\n\t\tgoto err_rhashtable_nexthop_destroy;\n\n\tINIT_WORK(&data->fib_event_work, nsim_fib_event_work);\n\tINIT_WORK(&data->fib_flush_work, nsim_fib_flush_work);\n\tINIT_LIST_HEAD(&data->fib_event_queue);\n\tspin_lock_init(&data->fib_event_queue_lock);\n\n\tnsim_fib_set_max_all(data, devlink);\n\n\tdata->nexthop_nb.notifier_call = nsim_nexthop_event_nb;\n\terr = register_nexthop_notifier(devlink_net(devlink), &data->nexthop_nb,\n\t\t\t\t\textack);\n\tif (err) {\n\t\tpr_err(\"Failed to register nexthop notifier\\n\");\n\t\tgoto err_rhashtable_fib_destroy;\n\t}\n\n\tdata->fib_nb.notifier_call = nsim_fib_event_nb;\n\terr = register_fib_notifier(devlink_net(devlink), &data->fib_nb,\n\t\t\t\t    nsim_fib_dump_inconsistent, extack);\n\tif (err) {\n\t\tpr_err(\"Failed to register fib notifier\\n\");\n\t\tgoto err_nexthop_nb_unregister;\n\t}\n\n\tdevl_resource_occ_get_register(devlink,\n\t\t\t\t       NSIM_RESOURCE_IPV4_FIB,\n\t\t\t\t       nsim_fib_ipv4_resource_occ_get,\n\t\t\t\t       data);\n\tdevl_resource_occ_get_register(devlink,\n\t\t\t\t       NSIM_RESOURCE_IPV4_FIB_RULES,\n\t\t\t\t       nsim_fib_ipv4_rules_res_occ_get,\n\t\t\t\t       data);\n\tdevl_resource_occ_get_register(devlink,\n\t\t\t\t       NSIM_RESOURCE_IPV6_FIB,\n\t\t\t\t       nsim_fib_ipv6_resource_occ_get,\n\t\t\t\t       data);\n\tdevl_resource_occ_get_register(devlink,\n\t\t\t\t       NSIM_RESOURCE_IPV6_FIB_RULES,\n\t\t\t\t       nsim_fib_ipv6_rules_res_occ_get,\n\t\t\t\t       data);\n\tdevl_resource_occ_get_register(devlink,\n\t\t\t\t       NSIM_RESOURCE_NEXTHOPS,\n\t\t\t\t       nsim_fib_nexthops_res_occ_get,\n\t\t\t\t       data);\n\treturn data;\n\nerr_nexthop_nb_unregister:\n\tunregister_nexthop_notifier(devlink_net(devlink), &data->nexthop_nb);\nerr_rhashtable_fib_destroy:\n\tcancel_work_sync(&data->fib_flush_work);\n\tflush_work(&data->fib_event_work);\n\trhashtable_free_and_destroy(&data->fib_rt_ht, nsim_fib_rt_free,\n\t\t\t\t    data);\nerr_rhashtable_nexthop_destroy:\n\trhashtable_free_and_destroy(&data->nexthop_ht, nsim_nexthop_free,\n\t\t\t\t    data);\n\tmutex_destroy(&data->fib_lock);\nerr_debugfs_exit:\n\tmutex_destroy(&data->nh_lock);\n\tnsim_fib_debugfs_exit(data);\nerr_data_free:\n\tkfree(data);\n\treturn ERR_PTR(err);\n}\n\nvoid nsim_fib_destroy(struct devlink *devlink, struct nsim_fib_data *data)\n{\n\tdevl_resource_occ_get_unregister(devlink,\n\t\t\t\t\t NSIM_RESOURCE_NEXTHOPS);\n\tdevl_resource_occ_get_unregister(devlink,\n\t\t\t\t\t NSIM_RESOURCE_IPV6_FIB_RULES);\n\tdevl_resource_occ_get_unregister(devlink,\n\t\t\t\t\t NSIM_RESOURCE_IPV6_FIB);\n\tdevl_resource_occ_get_unregister(devlink,\n\t\t\t\t\t NSIM_RESOURCE_IPV4_FIB_RULES);\n\tdevl_resource_occ_get_unregister(devlink,\n\t\t\t\t\t NSIM_RESOURCE_IPV4_FIB);\n\tunregister_fib_notifier(devlink_net(devlink), &data->fib_nb);\n\tunregister_nexthop_notifier(devlink_net(devlink), &data->nexthop_nb);\n\tcancel_work_sync(&data->fib_flush_work);\n\tflush_work(&data->fib_event_work);\n\trhashtable_free_and_destroy(&data->fib_rt_ht, nsim_fib_rt_free,\n\t\t\t\t    data);\n\trhashtable_free_and_destroy(&data->nexthop_ht, nsim_nexthop_free,\n\t\t\t\t    data);\n\tWARN_ON_ONCE(!list_empty(&data->fib_event_queue));\n\tWARN_ON_ONCE(!list_empty(&data->fib_rt_list));\n\tmutex_destroy(&data->fib_lock);\n\tmutex_destroy(&data->nh_lock);\n\tnsim_fib_debugfs_exit(data);\n\tkfree(data);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}