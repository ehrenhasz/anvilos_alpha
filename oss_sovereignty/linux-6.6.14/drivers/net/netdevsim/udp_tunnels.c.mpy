{
  "module_name": "udp_tunnels.c",
  "hash_id": "be9562c7c602266e6a813c8c5fe5483fc9bf8e56ff02fcc1719d8c6c86f7ade1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/netdevsim/udp_tunnels.c",
  "human_readable_source": "\n\n\n#include <linux/debugfs.h>\n#include <linux/netdevice.h>\n#include <linux/slab.h>\n#include <net/udp_tunnel.h>\n\n#include \"netdevsim.h\"\n\nstatic int\nnsim_udp_tunnel_set_port(struct net_device *dev, unsigned int table,\n\t\t\t unsigned int entry, struct udp_tunnel_info *ti)\n{\n\tstruct netdevsim *ns = netdev_priv(dev);\n\tint ret;\n\n\tret = -ns->udp_ports.inject_error;\n\tns->udp_ports.inject_error = 0;\n\n\tif (ns->udp_ports.sleep)\n\t\tmsleep(ns->udp_ports.sleep);\n\n\tif (!ret) {\n\t\tif (ns->udp_ports.ports[table][entry]) {\n\t\t\tWARN(1, \"entry already in use\\n\");\n\t\t\tret = -EBUSY;\n\t\t} else {\n\t\t\tns->udp_ports.ports[table][entry] =\n\t\t\t\tbe16_to_cpu(ti->port) << 16 | ti->type;\n\t\t}\n\t}\n\n\tnetdev_info(dev, \"set [%d, %d] type %d family %d port %d - %d\\n\",\n\t\t    table, entry, ti->type, ti->sa_family, ntohs(ti->port),\n\t\t    ret);\n\treturn ret;\n}\n\nstatic int\nnsim_udp_tunnel_unset_port(struct net_device *dev, unsigned int table,\n\t\t\t   unsigned int entry, struct udp_tunnel_info *ti)\n{\n\tstruct netdevsim *ns = netdev_priv(dev);\n\tint ret;\n\n\tret = -ns->udp_ports.inject_error;\n\tns->udp_ports.inject_error = 0;\n\n\tif (ns->udp_ports.sleep)\n\t\tmsleep(ns->udp_ports.sleep);\n\tif (!ret) {\n\t\tu32 val = be16_to_cpu(ti->port) << 16 | ti->type;\n\n\t\tif (val == ns->udp_ports.ports[table][entry]) {\n\t\t\tns->udp_ports.ports[table][entry] = 0;\n\t\t} else {\n\t\t\tWARN(1, \"entry not installed %x vs %x\\n\",\n\t\t\t     val, ns->udp_ports.ports[table][entry]);\n\t\t\tret = -ENOENT;\n\t\t}\n\t}\n\n\tnetdev_info(dev, \"unset [%d, %d] type %d family %d port %d - %d\\n\",\n\t\t    table, entry, ti->type, ti->sa_family, ntohs(ti->port),\n\t\t    ret);\n\treturn ret;\n}\n\nstatic int\nnsim_udp_tunnel_sync_table(struct net_device *dev, unsigned int table)\n{\n\tstruct netdevsim *ns = netdev_priv(dev);\n\tstruct udp_tunnel_info ti;\n\tunsigned int i;\n\tint ret;\n\n\tret = -ns->udp_ports.inject_error;\n\tns->udp_ports.inject_error = 0;\n\n\tfor (i = 0; i < NSIM_UDP_TUNNEL_N_PORTS; i++) {\n\t\tudp_tunnel_nic_get_port(dev, table, i, &ti);\n\t\tns->udp_ports.ports[table][i] =\n\t\t\tbe16_to_cpu(ti.port) << 16 | ti.type;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct udp_tunnel_nic_info nsim_udp_tunnel_info = {\n\t.set_port\t= nsim_udp_tunnel_set_port,\n\t.unset_port\t= nsim_udp_tunnel_unset_port,\n\t.sync_table\t= nsim_udp_tunnel_sync_table,\n\n\t.tables = {\n\t\t{\n\t\t\t.n_entries\t= NSIM_UDP_TUNNEL_N_PORTS,\n\t\t\t.tunnel_types\t= UDP_TUNNEL_TYPE_VXLAN,\n\t\t},\n\t\t{\n\t\t\t.n_entries\t= NSIM_UDP_TUNNEL_N_PORTS,\n\t\t\t.tunnel_types\t= UDP_TUNNEL_TYPE_GENEVE |\n\t\t\t\t\t  UDP_TUNNEL_TYPE_VXLAN_GPE,\n\t\t},\n\t},\n};\n\nstatic ssize_t\nnsim_udp_tunnels_info_reset_write(struct file *file, const char __user *data,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct net_device *dev = file->private_data;\n\tstruct netdevsim *ns = netdev_priv(dev);\n\n\tmemset(ns->udp_ports.ports, 0, sizeof(ns->udp_ports.__ports));\n\trtnl_lock();\n\tudp_tunnel_nic_reset_ntf(dev);\n\trtnl_unlock();\n\n\treturn count;\n}\n\nstatic const struct file_operations nsim_udp_tunnels_info_reset_fops = {\n\t.open = simple_open,\n\t.write = nsim_udp_tunnels_info_reset_write,\n\t.llseek = generic_file_llseek,\n\t.owner = THIS_MODULE,\n};\n\nint nsim_udp_tunnels_info_create(struct nsim_dev *nsim_dev,\n\t\t\t\t struct net_device *dev)\n{\n\tstruct netdevsim *ns = netdev_priv(dev);\n\tstruct udp_tunnel_nic_info *info;\n\n\tif (nsim_dev->udp_ports.shared && nsim_dev->udp_ports.open_only) {\n\t\tdev_err(&nsim_dev->nsim_bus_dev->dev,\n\t\t\t\"shared can't be used in conjunction with open_only\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!nsim_dev->udp_ports.shared)\n\t\tns->udp_ports.ports = ns->udp_ports.__ports;\n\telse\n\t\tns->udp_ports.ports = nsim_dev->udp_ports.__ports;\n\n\tdebugfs_create_u32(\"udp_ports_inject_error\", 0600,\n\t\t\t   ns->nsim_dev_port->ddir,\n\t\t\t   &ns->udp_ports.inject_error);\n\n\tns->udp_ports.dfs_ports[0].array = ns->udp_ports.ports[0];\n\tns->udp_ports.dfs_ports[0].n_elements = NSIM_UDP_TUNNEL_N_PORTS;\n\tdebugfs_create_u32_array(\"udp_ports_table0\", 0400,\n\t\t\t\t ns->nsim_dev_port->ddir,\n\t\t\t\t &ns->udp_ports.dfs_ports[0]);\n\n\tns->udp_ports.dfs_ports[1].array = ns->udp_ports.ports[1];\n\tns->udp_ports.dfs_ports[1].n_elements = NSIM_UDP_TUNNEL_N_PORTS;\n\tdebugfs_create_u32_array(\"udp_ports_table1\", 0400,\n\t\t\t\t ns->nsim_dev_port->ddir,\n\t\t\t\t &ns->udp_ports.dfs_ports[1]);\n\n\tdebugfs_create_file(\"udp_ports_reset\", 0200, ns->nsim_dev_port->ddir,\n\t\t\t    dev, &nsim_udp_tunnels_info_reset_fops);\n\n\t \n\tinfo = kmemdup(&nsim_udp_tunnel_info, sizeof(nsim_udp_tunnel_info),\n\t\t       GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tns->udp_ports.sleep = nsim_dev->udp_ports.sleep;\n\n\tif (nsim_dev->udp_ports.sync_all) {\n\t\tinfo->set_port = NULL;\n\t\tinfo->unset_port = NULL;\n\t} else {\n\t\tinfo->sync_table = NULL;\n\t}\n\n\tif (ns->udp_ports.sleep)\n\t\tinfo->flags |= UDP_TUNNEL_NIC_INFO_MAY_SLEEP;\n\tif (nsim_dev->udp_ports.open_only)\n\t\tinfo->flags |= UDP_TUNNEL_NIC_INFO_OPEN_ONLY;\n\tif (nsim_dev->udp_ports.ipv4_only)\n\t\tinfo->flags |= UDP_TUNNEL_NIC_INFO_IPV4_ONLY;\n\tif (nsim_dev->udp_ports.shared)\n\t\tinfo->shared = &nsim_dev->udp_ports.utn_shared;\n\tif (nsim_dev->udp_ports.static_iana_vxlan)\n\t\tinfo->flags |= UDP_TUNNEL_NIC_INFO_STATIC_IANA_VXLAN;\n\n\tdev->udp_tunnel_nic_info = info;\n\treturn 0;\n}\n\nvoid nsim_udp_tunnels_info_destroy(struct net_device *dev)\n{\n\tkfree(dev->udp_tunnel_nic_info);\n\tdev->udp_tunnel_nic_info = NULL;\n}\n\nvoid nsim_udp_tunnels_debugfs_create(struct nsim_dev *nsim_dev)\n{\n\tdebugfs_create_bool(\"udp_ports_sync_all\", 0600, nsim_dev->ddir,\n\t\t\t    &nsim_dev->udp_ports.sync_all);\n\tdebugfs_create_bool(\"udp_ports_open_only\", 0600, nsim_dev->ddir,\n\t\t\t    &nsim_dev->udp_ports.open_only);\n\tdebugfs_create_bool(\"udp_ports_ipv4_only\", 0600, nsim_dev->ddir,\n\t\t\t    &nsim_dev->udp_ports.ipv4_only);\n\tdebugfs_create_bool(\"udp_ports_shared\", 0600, nsim_dev->ddir,\n\t\t\t    &nsim_dev->udp_ports.shared);\n\tdebugfs_create_bool(\"udp_ports_static_iana_vxlan\", 0600, nsim_dev->ddir,\n\t\t\t    &nsim_dev->udp_ports.static_iana_vxlan);\n\tdebugfs_create_u32(\"udp_ports_sleep\", 0600, nsim_dev->ddir,\n\t\t\t   &nsim_dev->udp_ports.sleep);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}