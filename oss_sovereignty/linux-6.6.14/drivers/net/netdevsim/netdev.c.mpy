{
  "module_name": "netdev.c",
  "hash_id": "e20cdcc1de467337268d052bb1def730451e2cfedd0ee12bbc6c7a5191c88481",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/netdevsim/netdev.c",
  "human_readable_source": " \n\n#include <linux/debugfs.h>\n#include <linux/etherdevice.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/slab.h>\n#include <net/netlink.h>\n#include <net/pkt_cls.h>\n#include <net/rtnetlink.h>\n#include <net/udp_tunnel.h>\n\n#include \"netdevsim.h\"\n\nstatic netdev_tx_t nsim_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct netdevsim *ns = netdev_priv(dev);\n\n\tif (!nsim_ipsec_tx(ns, skb))\n\t\tgoto out;\n\n\tu64_stats_update_begin(&ns->syncp);\n\tns->tx_packets++;\n\tns->tx_bytes += skb->len;\n\tu64_stats_update_end(&ns->syncp);\n\nout:\n\tdev_kfree_skb(skb);\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic void nsim_set_rx_mode(struct net_device *dev)\n{\n}\n\nstatic int nsim_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct netdevsim *ns = netdev_priv(dev);\n\n\tif (ns->xdp.prog && new_mtu > NSIM_XDP_MAX_MTU)\n\t\treturn -EBUSY;\n\n\tdev->mtu = new_mtu;\n\n\treturn 0;\n}\n\nstatic void\nnsim_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)\n{\n\tstruct netdevsim *ns = netdev_priv(dev);\n\tunsigned int start;\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin(&ns->syncp);\n\t\tstats->tx_bytes = ns->tx_bytes;\n\t\tstats->tx_packets = ns->tx_packets;\n\t} while (u64_stats_fetch_retry(&ns->syncp, start));\n}\n\nstatic int\nnsim_setup_tc_block_cb(enum tc_setup_type type, void *type_data, void *cb_priv)\n{\n\treturn nsim_bpf_setup_tc_block_cb(type, type_data, cb_priv);\n}\n\nstatic int nsim_set_vf_mac(struct net_device *dev, int vf, u8 *mac)\n{\n\tstruct netdevsim *ns = netdev_priv(dev);\n\tstruct nsim_dev *nsim_dev = ns->nsim_dev;\n\n\t \n\tif (vf >= nsim_dev_get_vfs(nsim_dev) || is_multicast_ether_addr(mac))\n\t\treturn -EINVAL;\n\tmemcpy(nsim_dev->vfconfigs[vf].vf_mac, mac, ETH_ALEN);\n\n\treturn 0;\n}\n\nstatic int nsim_set_vf_vlan(struct net_device *dev, int vf,\n\t\t\t    u16 vlan, u8 qos, __be16 vlan_proto)\n{\n\tstruct netdevsim *ns = netdev_priv(dev);\n\tstruct nsim_dev *nsim_dev = ns->nsim_dev;\n\n\tif (vf >= nsim_dev_get_vfs(nsim_dev) || vlan > 4095 || qos > 7)\n\t\treturn -EINVAL;\n\n\tnsim_dev->vfconfigs[vf].vlan = vlan;\n\tnsim_dev->vfconfigs[vf].qos = qos;\n\tnsim_dev->vfconfigs[vf].vlan_proto = vlan_proto;\n\n\treturn 0;\n}\n\nstatic int nsim_set_vf_rate(struct net_device *dev, int vf, int min, int max)\n{\n\tstruct netdevsim *ns = netdev_priv(dev);\n\tstruct nsim_dev *nsim_dev = ns->nsim_dev;\n\n\tif (nsim_esw_mode_is_switchdev(ns->nsim_dev)) {\n\t\tpr_err(\"Not supported in switchdev mode. Please use devlink API.\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (vf >= nsim_dev_get_vfs(nsim_dev))\n\t\treturn -EINVAL;\n\n\tnsim_dev->vfconfigs[vf].min_tx_rate = min;\n\tnsim_dev->vfconfigs[vf].max_tx_rate = max;\n\n\treturn 0;\n}\n\nstatic int nsim_set_vf_spoofchk(struct net_device *dev, int vf, bool val)\n{\n\tstruct netdevsim *ns = netdev_priv(dev);\n\tstruct nsim_dev *nsim_dev = ns->nsim_dev;\n\n\tif (vf >= nsim_dev_get_vfs(nsim_dev))\n\t\treturn -EINVAL;\n\tnsim_dev->vfconfigs[vf].spoofchk_enabled = val;\n\n\treturn 0;\n}\n\nstatic int nsim_set_vf_rss_query_en(struct net_device *dev, int vf, bool val)\n{\n\tstruct netdevsim *ns = netdev_priv(dev);\n\tstruct nsim_dev *nsim_dev = ns->nsim_dev;\n\n\tif (vf >= nsim_dev_get_vfs(nsim_dev))\n\t\treturn -EINVAL;\n\tnsim_dev->vfconfigs[vf].rss_query_enabled = val;\n\n\treturn 0;\n}\n\nstatic int nsim_set_vf_trust(struct net_device *dev, int vf, bool val)\n{\n\tstruct netdevsim *ns = netdev_priv(dev);\n\tstruct nsim_dev *nsim_dev = ns->nsim_dev;\n\n\tif (vf >= nsim_dev_get_vfs(nsim_dev))\n\t\treturn -EINVAL;\n\tnsim_dev->vfconfigs[vf].trusted = val;\n\n\treturn 0;\n}\n\nstatic int\nnsim_get_vf_config(struct net_device *dev, int vf, struct ifla_vf_info *ivi)\n{\n\tstruct netdevsim *ns = netdev_priv(dev);\n\tstruct nsim_dev *nsim_dev = ns->nsim_dev;\n\n\tif (vf >= nsim_dev_get_vfs(nsim_dev))\n\t\treturn -EINVAL;\n\n\tivi->vf = vf;\n\tivi->linkstate = nsim_dev->vfconfigs[vf].link_state;\n\tivi->min_tx_rate = nsim_dev->vfconfigs[vf].min_tx_rate;\n\tivi->max_tx_rate = nsim_dev->vfconfigs[vf].max_tx_rate;\n\tivi->vlan = nsim_dev->vfconfigs[vf].vlan;\n\tivi->vlan_proto = nsim_dev->vfconfigs[vf].vlan_proto;\n\tivi->qos = nsim_dev->vfconfigs[vf].qos;\n\tmemcpy(&ivi->mac, nsim_dev->vfconfigs[vf].vf_mac, ETH_ALEN);\n\tivi->spoofchk = nsim_dev->vfconfigs[vf].spoofchk_enabled;\n\tivi->trusted = nsim_dev->vfconfigs[vf].trusted;\n\tivi->rss_query_en = nsim_dev->vfconfigs[vf].rss_query_enabled;\n\n\treturn 0;\n}\n\nstatic int nsim_set_vf_link_state(struct net_device *dev, int vf, int state)\n{\n\tstruct netdevsim *ns = netdev_priv(dev);\n\tstruct nsim_dev *nsim_dev = ns->nsim_dev;\n\n\tif (vf >= nsim_dev_get_vfs(nsim_dev))\n\t\treturn -EINVAL;\n\n\tswitch (state) {\n\tcase IFLA_VF_LINK_STATE_AUTO:\n\tcase IFLA_VF_LINK_STATE_ENABLE:\n\tcase IFLA_VF_LINK_STATE_DISABLE:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tnsim_dev->vfconfigs[vf].link_state = state;\n\n\treturn 0;\n}\n\nstatic void nsim_taprio_stats(struct tc_taprio_qopt_stats *stats)\n{\n\tstats->window_drops = 0;\n\tstats->tx_overruns = 0;\n}\n\nstatic int nsim_setup_tc_taprio(struct net_device *dev,\n\t\t\t\tstruct tc_taprio_qopt_offload *offload)\n{\n\tint err = 0;\n\n\tswitch (offload->cmd) {\n\tcase TAPRIO_CMD_REPLACE:\n\tcase TAPRIO_CMD_DESTROY:\n\t\tbreak;\n\tcase TAPRIO_CMD_STATS:\n\t\tnsim_taprio_stats(&offload->stats);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t}\n\n\treturn err;\n}\n\nstatic LIST_HEAD(nsim_block_cb_list);\n\nstatic int\nnsim_setup_tc(struct net_device *dev, enum tc_setup_type type, void *type_data)\n{\n\tstruct netdevsim *ns = netdev_priv(dev);\n\n\tswitch (type) {\n\tcase TC_SETUP_QDISC_TAPRIO:\n\t\treturn nsim_setup_tc_taprio(dev, type_data);\n\tcase TC_SETUP_BLOCK:\n\t\treturn flow_block_cb_setup_simple(type_data,\n\t\t\t\t\t\t  &nsim_block_cb_list,\n\t\t\t\t\t\t  nsim_setup_tc_block_cb,\n\t\t\t\t\t\t  ns, ns, true);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int\nnsim_set_features(struct net_device *dev, netdev_features_t features)\n{\n\tstruct netdevsim *ns = netdev_priv(dev);\n\n\tif ((dev->features & NETIF_F_HW_TC) > (features & NETIF_F_HW_TC))\n\t\treturn nsim_bpf_disable_tc(ns);\n\n\treturn 0;\n}\n\nstatic const struct net_device_ops nsim_netdev_ops = {\n\t.ndo_start_xmit\t\t= nsim_start_xmit,\n\t.ndo_set_rx_mode\t= nsim_set_rx_mode,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_change_mtu\t\t= nsim_change_mtu,\n\t.ndo_get_stats64\t= nsim_get_stats64,\n\t.ndo_set_vf_mac\t\t= nsim_set_vf_mac,\n\t.ndo_set_vf_vlan\t= nsim_set_vf_vlan,\n\t.ndo_set_vf_rate\t= nsim_set_vf_rate,\n\t.ndo_set_vf_spoofchk\t= nsim_set_vf_spoofchk,\n\t.ndo_set_vf_trust\t= nsim_set_vf_trust,\n\t.ndo_get_vf_config\t= nsim_get_vf_config,\n\t.ndo_set_vf_link_state\t= nsim_set_vf_link_state,\n\t.ndo_set_vf_rss_query_en = nsim_set_vf_rss_query_en,\n\t.ndo_setup_tc\t\t= nsim_setup_tc,\n\t.ndo_set_features\t= nsim_set_features,\n\t.ndo_bpf\t\t= nsim_bpf,\n};\n\nstatic const struct net_device_ops nsim_vf_netdev_ops = {\n\t.ndo_start_xmit\t\t= nsim_start_xmit,\n\t.ndo_set_rx_mode\t= nsim_set_rx_mode,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_change_mtu\t\t= nsim_change_mtu,\n\t.ndo_get_stats64\t= nsim_get_stats64,\n\t.ndo_setup_tc\t\t= nsim_setup_tc,\n\t.ndo_set_features\t= nsim_set_features,\n};\n\nstatic void nsim_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\teth_hw_addr_random(dev);\n\n\tdev->tx_queue_len = 0;\n\tdev->flags |= IFF_NOARP;\n\tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags |= IFF_LIVE_ADDR_CHANGE |\n\t\t\t   IFF_NO_QUEUE;\n\tdev->features |= NETIF_F_HIGHDMA |\n\t\t\t NETIF_F_SG |\n\t\t\t NETIF_F_FRAGLIST |\n\t\t\t NETIF_F_HW_CSUM |\n\t\t\t NETIF_F_TSO;\n\tdev->hw_features |= NETIF_F_HW_TC;\n\tdev->max_mtu = ETH_MAX_MTU;\n\tdev->xdp_features = NETDEV_XDP_ACT_HW_OFFLOAD;\n}\n\nstatic int nsim_init_netdevsim(struct netdevsim *ns)\n{\n\tstruct mock_phc *phc;\n\tint err;\n\n\tphc = mock_phc_create(&ns->nsim_bus_dev->dev);\n\tif (IS_ERR(phc))\n\t\treturn PTR_ERR(phc);\n\n\tns->phc = phc;\n\tns->netdev->netdev_ops = &nsim_netdev_ops;\n\n\terr = nsim_udp_tunnels_info_create(ns->nsim_dev, ns->netdev);\n\tif (err)\n\t\tgoto err_phc_destroy;\n\n\trtnl_lock();\n\terr = nsim_bpf_init(ns);\n\tif (err)\n\t\tgoto err_utn_destroy;\n\n\tnsim_macsec_init(ns);\n\tnsim_ipsec_init(ns);\n\n\terr = register_netdevice(ns->netdev);\n\tif (err)\n\t\tgoto err_ipsec_teardown;\n\trtnl_unlock();\n\treturn 0;\n\nerr_ipsec_teardown:\n\tnsim_ipsec_teardown(ns);\n\tnsim_macsec_teardown(ns);\n\tnsim_bpf_uninit(ns);\nerr_utn_destroy:\n\trtnl_unlock();\n\tnsim_udp_tunnels_info_destroy(ns->netdev);\nerr_phc_destroy:\n\tmock_phc_destroy(ns->phc);\n\treturn err;\n}\n\nstatic int nsim_init_netdevsim_vf(struct netdevsim *ns)\n{\n\tint err;\n\n\tns->netdev->netdev_ops = &nsim_vf_netdev_ops;\n\trtnl_lock();\n\terr = register_netdevice(ns->netdev);\n\trtnl_unlock();\n\treturn err;\n}\n\nstatic void nsim_exit_netdevsim(struct netdevsim *ns)\n{\n\tnsim_udp_tunnels_info_destroy(ns->netdev);\n\tmock_phc_destroy(ns->phc);\n}\n\nstruct netdevsim *\nnsim_create(struct nsim_dev *nsim_dev, struct nsim_dev_port *nsim_dev_port)\n{\n\tstruct net_device *dev;\n\tstruct netdevsim *ns;\n\tint err;\n\n\tdev = alloc_netdev_mq(sizeof(*ns), \"eth%d\", NET_NAME_UNKNOWN, nsim_setup,\n\t\t\t      nsim_dev->nsim_bus_dev->num_queues);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdev_net_set(dev, nsim_dev_net(nsim_dev));\n\tns = netdev_priv(dev);\n\tns->netdev = dev;\n\tu64_stats_init(&ns->syncp);\n\tns->nsim_dev = nsim_dev;\n\tns->nsim_dev_port = nsim_dev_port;\n\tns->nsim_bus_dev = nsim_dev->nsim_bus_dev;\n\tSET_NETDEV_DEV(dev, &ns->nsim_bus_dev->dev);\n\tSET_NETDEV_DEVLINK_PORT(dev, &nsim_dev_port->devlink_port);\n\tnsim_ethtool_init(ns);\n\tif (nsim_dev_port_is_pf(nsim_dev_port))\n\t\terr = nsim_init_netdevsim(ns);\n\telse\n\t\terr = nsim_init_netdevsim_vf(ns);\n\tif (err)\n\t\tgoto err_free_netdev;\n\treturn ns;\n\nerr_free_netdev:\n\tfree_netdev(dev);\n\treturn ERR_PTR(err);\n}\n\nvoid nsim_destroy(struct netdevsim *ns)\n{\n\tstruct net_device *dev = ns->netdev;\n\n\trtnl_lock();\n\tunregister_netdevice(dev);\n\tif (nsim_dev_port_is_pf(ns->nsim_dev_port)) {\n\t\tnsim_macsec_teardown(ns);\n\t\tnsim_ipsec_teardown(ns);\n\t\tnsim_bpf_uninit(ns);\n\t}\n\trtnl_unlock();\n\tif (nsim_dev_port_is_pf(ns->nsim_dev_port))\n\t\tnsim_exit_netdevsim(ns);\n\tfree_netdev(dev);\n}\n\nstatic int nsim_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tNL_SET_ERR_MSG_MOD(extack,\n\t\t\t   \"Please use: echo \\\"[ID] [PORT_COUNT] [NUM_QUEUES]\\\" > /sys/bus/netdevsim/new_device\");\n\treturn -EOPNOTSUPP;\n}\n\nstatic struct rtnl_link_ops nsim_link_ops __read_mostly = {\n\t.kind\t\t= DRV_NAME,\n\t.validate\t= nsim_validate,\n};\n\nstatic int __init nsim_module_init(void)\n{\n\tint err;\n\n\terr = nsim_dev_init();\n\tif (err)\n\t\treturn err;\n\n\terr = nsim_bus_init();\n\tif (err)\n\t\tgoto err_dev_exit;\n\n\terr = rtnl_link_register(&nsim_link_ops);\n\tif (err)\n\t\tgoto err_bus_exit;\n\n\treturn 0;\n\nerr_bus_exit:\n\tnsim_bus_exit();\nerr_dev_exit:\n\tnsim_dev_exit();\n\treturn err;\n}\n\nstatic void __exit nsim_module_exit(void)\n{\n\trtnl_link_unregister(&nsim_link_ops);\n\tnsim_bus_exit();\n\tnsim_dev_exit();\n}\n\nmodule_init(nsim_module_init);\nmodule_exit(nsim_module_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_RTNL_LINK(DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}