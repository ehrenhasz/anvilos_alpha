{
  "module_name": "geneve.c",
  "hash_id": "9c25cfde2ee062069d98fc1eb1b2ad1e4c091b378e305c421f47e0d725eab4e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/geneve.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/ethtool.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/etherdevice.h>\n#include <linux/hash.h>\n#include <net/ipv6_stubs.h>\n#include <net/dst_metadata.h>\n#include <net/gro_cells.h>\n#include <net/rtnetlink.h>\n#include <net/geneve.h>\n#include <net/gro.h>\n#include <net/protocol.h>\n\n#define GENEVE_NETDEV_VER\t\"0.6\"\n\n#define GENEVE_N_VID\t\t(1u << 24)\n#define GENEVE_VID_MASK\t\t(GENEVE_N_VID - 1)\n\n#define VNI_HASH_BITS\t\t10\n#define VNI_HASH_SIZE\t\t(1<<VNI_HASH_BITS)\n\nstatic bool log_ecn_error = true;\nmodule_param(log_ecn_error, bool, 0644);\nMODULE_PARM_DESC(log_ecn_error, \"Log packets received with corrupted ECN\");\n\n#define GENEVE_VER 0\n#define GENEVE_BASE_HLEN (sizeof(struct udphdr) + sizeof(struct genevehdr))\n#define GENEVE_IPV4_HLEN (ETH_HLEN + sizeof(struct iphdr) + GENEVE_BASE_HLEN)\n#define GENEVE_IPV6_HLEN (ETH_HLEN + sizeof(struct ipv6hdr) + GENEVE_BASE_HLEN)\n\n \nstruct geneve_net {\n\tstruct list_head\tgeneve_list;\n\tstruct list_head\tsock_list;\n};\n\nstatic unsigned int geneve_net_id;\n\nstruct geneve_dev_node {\n\tstruct hlist_node hlist;\n\tstruct geneve_dev *geneve;\n};\n\nstruct geneve_config {\n\tstruct ip_tunnel_info\tinfo;\n\tbool\t\t\tcollect_md;\n\tbool\t\t\tuse_udp6_rx_checksums;\n\tbool\t\t\tttl_inherit;\n\tenum ifla_geneve_df\tdf;\n\tbool\t\t\tinner_proto_inherit;\n};\n\n \nstruct geneve_dev {\n\tstruct geneve_dev_node hlist4;\t \n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct geneve_dev_node hlist6;\t \n#endif\n\tstruct net\t   *net;\t \n\tstruct net_device  *dev;\t \n\tstruct geneve_sock __rcu *sock4;\t \n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct geneve_sock __rcu *sock6;\t \n#endif\n\tstruct list_head   next;\t \n\tstruct gro_cells   gro_cells;\n\tstruct geneve_config cfg;\n};\n\nstruct geneve_sock {\n\tbool\t\t\tcollect_md;\n\tstruct list_head\tlist;\n\tstruct socket\t\t*sock;\n\tstruct rcu_head\t\trcu;\n\tint\t\t\trefcnt;\n\tstruct hlist_head\tvni_list[VNI_HASH_SIZE];\n};\n\nstatic inline __u32 geneve_net_vni_hash(u8 vni[3])\n{\n\t__u32 vnid;\n\n\tvnid = (vni[0] << 16) | (vni[1] << 8) | vni[2];\n\treturn hash_32(vnid, VNI_HASH_BITS);\n}\n\nstatic __be64 vni_to_tunnel_id(const __u8 *vni)\n{\n#ifdef __BIG_ENDIAN\n\treturn (vni[0] << 16) | (vni[1] << 8) | vni[2];\n#else\n\treturn (__force __be64)(((__force u64)vni[0] << 40) |\n\t\t\t\t((__force u64)vni[1] << 48) |\n\t\t\t\t((__force u64)vni[2] << 56));\n#endif\n}\n\n \nstatic void tunnel_id_to_vni(__be64 tun_id, __u8 *vni)\n{\n#ifdef __BIG_ENDIAN\n\tvni[0] = (__force __u8)(tun_id >> 16);\n\tvni[1] = (__force __u8)(tun_id >> 8);\n\tvni[2] = (__force __u8)tun_id;\n#else\n\tvni[0] = (__force __u8)((__force u64)tun_id >> 40);\n\tvni[1] = (__force __u8)((__force u64)tun_id >> 48);\n\tvni[2] = (__force __u8)((__force u64)tun_id >> 56);\n#endif\n}\n\nstatic bool eq_tun_id_and_vni(u8 *tun_id, u8 *vni)\n{\n\treturn !memcmp(vni, &tun_id[5], 3);\n}\n\nstatic sa_family_t geneve_get_sk_family(struct geneve_sock *gs)\n{\n\treturn gs->sock->sk->sk_family;\n}\n\nstatic struct geneve_dev *geneve_lookup(struct geneve_sock *gs,\n\t\t\t\t\t__be32 addr, u8 vni[])\n{\n\tstruct hlist_head *vni_list_head;\n\tstruct geneve_dev_node *node;\n\t__u32 hash;\n\n\t \n\thash = geneve_net_vni_hash(vni);\n\tvni_list_head = &gs->vni_list[hash];\n\thlist_for_each_entry_rcu(node, vni_list_head, hlist) {\n\t\tif (eq_tun_id_and_vni((u8 *)&node->geneve->cfg.info.key.tun_id, vni) &&\n\t\t    addr == node->geneve->cfg.info.key.u.ipv4.dst)\n\t\t\treturn node->geneve;\n\t}\n\treturn NULL;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic struct geneve_dev *geneve6_lookup(struct geneve_sock *gs,\n\t\t\t\t\t struct in6_addr addr6, u8 vni[])\n{\n\tstruct hlist_head *vni_list_head;\n\tstruct geneve_dev_node *node;\n\t__u32 hash;\n\n\t \n\thash = geneve_net_vni_hash(vni);\n\tvni_list_head = &gs->vni_list[hash];\n\thlist_for_each_entry_rcu(node, vni_list_head, hlist) {\n\t\tif (eq_tun_id_and_vni((u8 *)&node->geneve->cfg.info.key.tun_id, vni) &&\n\t\t    ipv6_addr_equal(&addr6, &node->geneve->cfg.info.key.u.ipv6.dst))\n\t\t\treturn node->geneve;\n\t}\n\treturn NULL;\n}\n#endif\n\nstatic inline struct genevehdr *geneve_hdr(const struct sk_buff *skb)\n{\n\treturn (struct genevehdr *)(udp_hdr(skb) + 1);\n}\n\nstatic struct geneve_dev *geneve_lookup_skb(struct geneve_sock *gs,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstatic u8 zero_vni[3];\n\tu8 *vni;\n\n\tif (geneve_get_sk_family(gs) == AF_INET) {\n\t\tstruct iphdr *iph;\n\t\t__be32 addr;\n\n\t\tiph = ip_hdr(skb);  \n\n\t\tif (gs->collect_md) {\n\t\t\tvni = zero_vni;\n\t\t\taddr = 0;\n\t\t} else {\n\t\t\tvni = geneve_hdr(skb)->vni;\n\t\t\taddr = iph->saddr;\n\t\t}\n\n\t\treturn geneve_lookup(gs, addr, vni);\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (geneve_get_sk_family(gs) == AF_INET6) {\n\t\tstatic struct in6_addr zero_addr6;\n\t\tstruct ipv6hdr *ip6h;\n\t\tstruct in6_addr addr6;\n\n\t\tip6h = ipv6_hdr(skb);  \n\n\t\tif (gs->collect_md) {\n\t\t\tvni = zero_vni;\n\t\t\taddr6 = zero_addr6;\n\t\t} else {\n\t\t\tvni = geneve_hdr(skb)->vni;\n\t\t\taddr6 = ip6h->saddr;\n\t\t}\n\n\t\treturn geneve6_lookup(gs, addr6, vni);\n#endif\n\t}\n\treturn NULL;\n}\n\n \nstatic void geneve_rx(struct geneve_dev *geneve, struct geneve_sock *gs,\n\t\t      struct sk_buff *skb)\n{\n\tstruct genevehdr *gnvh = geneve_hdr(skb);\n\tstruct metadata_dst *tun_dst = NULL;\n\tunsigned int len;\n\tint err = 0;\n\tvoid *oiph;\n\n\tif (ip_tunnel_collect_metadata() || gs->collect_md) {\n\t\t__be16 flags;\n\n\t\tflags = TUNNEL_KEY | (gnvh->oam ? TUNNEL_OAM : 0) |\n\t\t\t(gnvh->critical ? TUNNEL_CRIT_OPT : 0);\n\n\t\ttun_dst = udp_tun_rx_dst(skb, geneve_get_sk_family(gs), flags,\n\t\t\t\t\t vni_to_tunnel_id(gnvh->vni),\n\t\t\t\t\t gnvh->opt_len * 4);\n\t\tif (!tun_dst) {\n\t\t\tgeneve->dev->stats.rx_dropped++;\n\t\t\tgoto drop;\n\t\t}\n\t\t \n\t\tip_tunnel_info_opts_set(&tun_dst->u.tun_info,\n\t\t\t\t\tgnvh->options, gnvh->opt_len * 4,\n\t\t\t\t\tTUNNEL_GENEVE_OPT);\n\t} else {\n\t\t \n\t\tif (gnvh->critical) {\n\t\t\tgeneve->dev->stats.rx_frame_errors++;\n\t\t\tgeneve->dev->stats.rx_errors++;\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif (tun_dst)\n\t\tskb_dst_set(skb, &tun_dst->dst);\n\n\tif (gnvh->proto_type == htons(ETH_P_TEB)) {\n\t\tskb_reset_mac_header(skb);\n\t\tskb->protocol = eth_type_trans(skb, geneve->dev);\n\t\tskb_postpull_rcsum(skb, eth_hdr(skb), ETH_HLEN);\n\n\t\t \n\t\tif (ether_addr_equal(eth_hdr(skb)->h_source,\n\t\t\t\t     geneve->dev->dev_addr)) {\n\t\t\tgeneve->dev->stats.rx_errors++;\n\t\t\tgoto drop;\n\t\t}\n\t} else {\n\t\tskb_reset_mac_header(skb);\n\t\tskb->dev = geneve->dev;\n\t\tskb->pkt_type = PACKET_HOST;\n\t}\n\n\toiph = skb_network_header(skb);\n\tskb_reset_network_header(skb);\n\n\tif (geneve_get_sk_family(gs) == AF_INET)\n\t\terr = IP_ECN_decapsulate(oiph, skb);\n#if IS_ENABLED(CONFIG_IPV6)\n\telse\n\t\terr = IP6_ECN_decapsulate(oiph, skb);\n#endif\n\n\tif (unlikely(err)) {\n\t\tif (log_ecn_error) {\n\t\t\tif (geneve_get_sk_family(gs) == AF_INET)\n\t\t\t\tnet_info_ratelimited(\"non-ECT from %pI4 \"\n\t\t\t\t\t\t     \"with TOS=%#x\\n\",\n\t\t\t\t\t\t     &((struct iphdr *)oiph)->saddr,\n\t\t\t\t\t\t     ((struct iphdr *)oiph)->tos);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\telse\n\t\t\t\tnet_info_ratelimited(\"non-ECT from %pI6\\n\",\n\t\t\t\t\t\t     &((struct ipv6hdr *)oiph)->saddr);\n#endif\n\t\t}\n\t\tif (err > 1) {\n\t\t\t++geneve->dev->stats.rx_frame_errors;\n\t\t\t++geneve->dev->stats.rx_errors;\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tlen = skb->len;\n\terr = gro_cells_receive(&geneve->gro_cells, skb);\n\tif (likely(err == NET_RX_SUCCESS))\n\t\tdev_sw_netstats_rx_add(geneve->dev, len);\n\n\treturn;\ndrop:\n\t \n\tkfree_skb(skb);\n}\n\n \nstatic int geneve_init(struct net_device *dev)\n{\n\tstruct geneve_dev *geneve = netdev_priv(dev);\n\tint err;\n\n\tdev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);\n\tif (!dev->tstats)\n\t\treturn -ENOMEM;\n\n\terr = gro_cells_init(&geneve->gro_cells, dev);\n\tif (err) {\n\t\tfree_percpu(dev->tstats);\n\t\treturn err;\n\t}\n\n\terr = dst_cache_init(&geneve->cfg.info.dst_cache, GFP_KERNEL);\n\tif (err) {\n\t\tfree_percpu(dev->tstats);\n\t\tgro_cells_destroy(&geneve->gro_cells);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic void geneve_uninit(struct net_device *dev)\n{\n\tstruct geneve_dev *geneve = netdev_priv(dev);\n\n\tdst_cache_destroy(&geneve->cfg.info.dst_cache);\n\tgro_cells_destroy(&geneve->gro_cells);\n\tfree_percpu(dev->tstats);\n}\n\n \nstatic int geneve_udp_encap_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct genevehdr *geneveh;\n\tstruct geneve_dev *geneve;\n\tstruct geneve_sock *gs;\n\t__be16 inner_proto;\n\tint opts_len;\n\n\t \n\tif (unlikely(!pskb_may_pull(skb, GENEVE_BASE_HLEN)))\n\t\tgoto drop;\n\n\t \n\tgeneveh = geneve_hdr(skb);\n\tif (unlikely(geneveh->ver != GENEVE_VER))\n\t\tgoto drop;\n\n\tgs = rcu_dereference_sk_user_data(sk);\n\tif (!gs)\n\t\tgoto drop;\n\n\tgeneve = geneve_lookup_skb(gs, skb);\n\tif (!geneve)\n\t\tgoto drop;\n\n\tinner_proto = geneveh->proto_type;\n\n\tif (unlikely((!geneve->cfg.inner_proto_inherit &&\n\t\t      inner_proto != htons(ETH_P_TEB)))) {\n\t\tgeneve->dev->stats.rx_dropped++;\n\t\tgoto drop;\n\t}\n\n\topts_len = geneveh->opt_len * 4;\n\tif (iptunnel_pull_header(skb, GENEVE_BASE_HLEN + opts_len, inner_proto,\n\t\t\t\t !net_eq(geneve->net, dev_net(geneve->dev)))) {\n\t\tgeneve->dev->stats.rx_dropped++;\n\t\tgoto drop;\n\t}\n\n\tgeneve_rx(geneve, gs, skb);\n\treturn 0;\n\ndrop:\n\t \n\tkfree_skb(skb);\n\treturn 0;\n}\n\n \nstatic int geneve_udp_encap_err_lookup(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct genevehdr *geneveh;\n\tstruct geneve_sock *gs;\n\tu8 zero_vni[3] = { 0 };\n\tu8 *vni = zero_vni;\n\n\tif (!pskb_may_pull(skb, skb_transport_offset(skb) + GENEVE_BASE_HLEN))\n\t\treturn -EINVAL;\n\n\tgeneveh = geneve_hdr(skb);\n\tif (geneveh->ver != GENEVE_VER)\n\t\treturn -EINVAL;\n\n\tif (geneveh->proto_type != htons(ETH_P_TEB))\n\t\treturn -EINVAL;\n\n\tgs = rcu_dereference_sk_user_data(sk);\n\tif (!gs)\n\t\treturn -ENOENT;\n\n\tif (geneve_get_sk_family(gs) == AF_INET) {\n\t\tstruct iphdr *iph = ip_hdr(skb);\n\t\t__be32 addr4 = 0;\n\n\t\tif (!gs->collect_md) {\n\t\t\tvni = geneve_hdr(skb)->vni;\n\t\t\taddr4 = iph->daddr;\n\t\t}\n\n\t\treturn geneve_lookup(gs, addr4, vni) ? 0 : -ENOENT;\n\t}\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (geneve_get_sk_family(gs) == AF_INET6) {\n\t\tstruct ipv6hdr *ip6h = ipv6_hdr(skb);\n\t\tstruct in6_addr addr6;\n\n\t\tmemset(&addr6, 0, sizeof(struct in6_addr));\n\n\t\tif (!gs->collect_md) {\n\t\t\tvni = geneve_hdr(skb)->vni;\n\t\t\taddr6 = ip6h->daddr;\n\t\t}\n\n\t\treturn geneve6_lookup(gs, addr6, vni) ? 0 : -ENOENT;\n\t}\n#endif\n\n\treturn -EPFNOSUPPORT;\n}\n\nstatic struct socket *geneve_create_sock(struct net *net, bool ipv6,\n\t\t\t\t\t __be16 port, bool ipv6_rx_csum)\n{\n\tstruct socket *sock;\n\tstruct udp_port_cfg udp_conf;\n\tint err;\n\n\tmemset(&udp_conf, 0, sizeof(udp_conf));\n\n\tif (ipv6) {\n\t\tudp_conf.family = AF_INET6;\n\t\tudp_conf.ipv6_v6only = 1;\n\t\tudp_conf.use_udp6_rx_checksums = ipv6_rx_csum;\n\t} else {\n\t\tudp_conf.family = AF_INET;\n\t\tudp_conf.local_ip.s_addr = htonl(INADDR_ANY);\n\t}\n\n\tudp_conf.local_udp_port = port;\n\n\t \n\terr = udp_sock_create(net, &udp_conf, &sock);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\tudp_allow_gso(sock->sk);\n\treturn sock;\n}\n\nstatic int geneve_hlen(struct genevehdr *gh)\n{\n\treturn sizeof(*gh) + gh->opt_len * 4;\n}\n\nstatic struct sk_buff *geneve_gro_receive(struct sock *sk,\n\t\t\t\t\t  struct list_head *head,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct sk_buff *pp = NULL;\n\tstruct sk_buff *p;\n\tstruct genevehdr *gh, *gh2;\n\tunsigned int hlen, gh_len, off_gnv;\n\tconst struct packet_offload *ptype;\n\t__be16 type;\n\tint flush = 1;\n\n\toff_gnv = skb_gro_offset(skb);\n\thlen = off_gnv + sizeof(*gh);\n\tgh = skb_gro_header(skb, hlen, off_gnv);\n\tif (unlikely(!gh))\n\t\tgoto out;\n\n\tif (gh->ver != GENEVE_VER || gh->oam)\n\t\tgoto out;\n\tgh_len = geneve_hlen(gh);\n\n\thlen = off_gnv + gh_len;\n\tif (skb_gro_header_hard(skb, hlen)) {\n\t\tgh = skb_gro_header_slow(skb, hlen, off_gnv);\n\t\tif (unlikely(!gh))\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(p, head, list) {\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\n\t\tgh2 = (struct genevehdr *)(p->data + off_gnv);\n\t\tif (gh->opt_len != gh2->opt_len ||\n\t\t    memcmp(gh, gh2, gh_len)) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tskb_gro_pull(skb, gh_len);\n\tskb_gro_postpull_rcsum(skb, gh, gh_len);\n\ttype = gh->proto_type;\n\tif (likely(type == htons(ETH_P_TEB)))\n\t\treturn call_gro_receive(eth_gro_receive, head, skb);\n\n\tptype = gro_find_receive_by_type(type);\n\tif (!ptype)\n\t\tgoto out;\n\n\tpp = call_gro_receive(ptype->callbacks.gro_receive, head, skb);\n\tflush = 0;\n\nout:\n\tskb_gro_flush_final(skb, pp, flush);\n\n\treturn pp;\n}\n\nstatic int geneve_gro_complete(struct sock *sk, struct sk_buff *skb,\n\t\t\t       int nhoff)\n{\n\tstruct genevehdr *gh;\n\tstruct packet_offload *ptype;\n\t__be16 type;\n\tint gh_len;\n\tint err = -ENOSYS;\n\n\tgh = (struct genevehdr *)(skb->data + nhoff);\n\tgh_len = geneve_hlen(gh);\n\ttype = gh->proto_type;\n\n\t \n\tif (likely(type == htons(ETH_P_TEB)))\n\t\treturn eth_gro_complete(skb, nhoff + gh_len);\n\n\tptype = gro_find_complete_by_type(type);\n\tif (ptype)\n\t\terr = ptype->callbacks.gro_complete(skb, nhoff + gh_len);\n\n\tskb_set_inner_mac_header(skb, nhoff + gh_len);\n\n\treturn err;\n}\n\n \nstatic struct geneve_sock *geneve_socket_create(struct net *net, __be16 port,\n\t\t\t\t\t\tbool ipv6, bool ipv6_rx_csum)\n{\n\tstruct geneve_net *gn = net_generic(net, geneve_net_id);\n\tstruct geneve_sock *gs;\n\tstruct socket *sock;\n\tstruct udp_tunnel_sock_cfg tunnel_cfg;\n\tint h;\n\n\tgs = kzalloc(sizeof(*gs), GFP_KERNEL);\n\tif (!gs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsock = geneve_create_sock(net, ipv6, port, ipv6_rx_csum);\n\tif (IS_ERR(sock)) {\n\t\tkfree(gs);\n\t\treturn ERR_CAST(sock);\n\t}\n\n\tgs->sock = sock;\n\tgs->refcnt = 1;\n\tfor (h = 0; h < VNI_HASH_SIZE; ++h)\n\t\tINIT_HLIST_HEAD(&gs->vni_list[h]);\n\n\t \n\tudp_tunnel_notify_add_rx_port(gs->sock, UDP_TUNNEL_TYPE_GENEVE);\n\n\t \n\tmemset(&tunnel_cfg, 0, sizeof(tunnel_cfg));\n\ttunnel_cfg.sk_user_data = gs;\n\ttunnel_cfg.encap_type = 1;\n\ttunnel_cfg.gro_receive = geneve_gro_receive;\n\ttunnel_cfg.gro_complete = geneve_gro_complete;\n\ttunnel_cfg.encap_rcv = geneve_udp_encap_recv;\n\ttunnel_cfg.encap_err_lookup = geneve_udp_encap_err_lookup;\n\ttunnel_cfg.encap_destroy = NULL;\n\tsetup_udp_tunnel_sock(net, sock, &tunnel_cfg);\n\tlist_add(&gs->list, &gn->sock_list);\n\treturn gs;\n}\n\nstatic void __geneve_sock_release(struct geneve_sock *gs)\n{\n\tif (!gs || --gs->refcnt)\n\t\treturn;\n\n\tlist_del(&gs->list);\n\tudp_tunnel_notify_del_rx_port(gs->sock, UDP_TUNNEL_TYPE_GENEVE);\n\tudp_tunnel_sock_release(gs->sock);\n\tkfree_rcu(gs, rcu);\n}\n\nstatic void geneve_sock_release(struct geneve_dev *geneve)\n{\n\tstruct geneve_sock *gs4 = rtnl_dereference(geneve->sock4);\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct geneve_sock *gs6 = rtnl_dereference(geneve->sock6);\n\n\trcu_assign_pointer(geneve->sock6, NULL);\n#endif\n\n\trcu_assign_pointer(geneve->sock4, NULL);\n\tsynchronize_net();\n\n\t__geneve_sock_release(gs4);\n#if IS_ENABLED(CONFIG_IPV6)\n\t__geneve_sock_release(gs6);\n#endif\n}\n\nstatic struct geneve_sock *geneve_find_sock(struct geneve_net *gn,\n\t\t\t\t\t    sa_family_t family,\n\t\t\t\t\t    __be16 dst_port)\n{\n\tstruct geneve_sock *gs;\n\n\tlist_for_each_entry(gs, &gn->sock_list, list) {\n\t\tif (inet_sk(gs->sock->sk)->inet_sport == dst_port &&\n\t\t    geneve_get_sk_family(gs) == family) {\n\t\t\treturn gs;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic int geneve_sock_add(struct geneve_dev *geneve, bool ipv6)\n{\n\tstruct net *net = geneve->net;\n\tstruct geneve_net *gn = net_generic(net, geneve_net_id);\n\tstruct geneve_dev_node *node;\n\tstruct geneve_sock *gs;\n\t__u8 vni[3];\n\t__u32 hash;\n\n\tgs = geneve_find_sock(gn, ipv6 ? AF_INET6 : AF_INET, geneve->cfg.info.key.tp_dst);\n\tif (gs) {\n\t\tgs->refcnt++;\n\t\tgoto out;\n\t}\n\n\tgs = geneve_socket_create(net, geneve->cfg.info.key.tp_dst, ipv6,\n\t\t\t\t  geneve->cfg.use_udp6_rx_checksums);\n\tif (IS_ERR(gs))\n\t\treturn PTR_ERR(gs);\n\nout:\n\tgs->collect_md = geneve->cfg.collect_md;\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (ipv6) {\n\t\trcu_assign_pointer(geneve->sock6, gs);\n\t\tnode = &geneve->hlist6;\n\t} else\n#endif\n\t{\n\t\trcu_assign_pointer(geneve->sock4, gs);\n\t\tnode = &geneve->hlist4;\n\t}\n\tnode->geneve = geneve;\n\n\ttunnel_id_to_vni(geneve->cfg.info.key.tun_id, vni);\n\thash = geneve_net_vni_hash(vni);\n\thlist_add_head_rcu(&node->hlist, &gs->vni_list[hash]);\n\treturn 0;\n}\n\nstatic int geneve_open(struct net_device *dev)\n{\n\tstruct geneve_dev *geneve = netdev_priv(dev);\n\tbool metadata = geneve->cfg.collect_md;\n\tbool ipv4, ipv6;\n\tint ret = 0;\n\n\tipv6 = geneve->cfg.info.mode & IP_TUNNEL_INFO_IPV6 || metadata;\n\tipv4 = !ipv6 || metadata;\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (ipv6) {\n\t\tret = geneve_sock_add(geneve, true);\n\t\tif (ret < 0 && ret != -EAFNOSUPPORT)\n\t\t\tipv4 = false;\n\t}\n#endif\n\tif (ipv4)\n\t\tret = geneve_sock_add(geneve, false);\n\tif (ret < 0)\n\t\tgeneve_sock_release(geneve);\n\n\treturn ret;\n}\n\nstatic int geneve_stop(struct net_device *dev)\n{\n\tstruct geneve_dev *geneve = netdev_priv(dev);\n\n\thlist_del_init_rcu(&geneve->hlist4.hlist);\n#if IS_ENABLED(CONFIG_IPV6)\n\thlist_del_init_rcu(&geneve->hlist6.hlist);\n#endif\n\tgeneve_sock_release(geneve);\n\treturn 0;\n}\n\nstatic void geneve_build_header(struct genevehdr *geneveh,\n\t\t\t\tconst struct ip_tunnel_info *info,\n\t\t\t\t__be16 inner_proto)\n{\n\tgeneveh->ver = GENEVE_VER;\n\tgeneveh->opt_len = info->options_len / 4;\n\tgeneveh->oam = !!(info->key.tun_flags & TUNNEL_OAM);\n\tgeneveh->critical = !!(info->key.tun_flags & TUNNEL_CRIT_OPT);\n\tgeneveh->rsvd1 = 0;\n\ttunnel_id_to_vni(info->key.tun_id, geneveh->vni);\n\tgeneveh->proto_type = inner_proto;\n\tgeneveh->rsvd2 = 0;\n\n\tif (info->key.tun_flags & TUNNEL_GENEVE_OPT)\n\t\tip_tunnel_info_opts_get(geneveh->options, info);\n}\n\nstatic int geneve_build_skb(struct dst_entry *dst, struct sk_buff *skb,\n\t\t\t    const struct ip_tunnel_info *info,\n\t\t\t    bool xnet, int ip_hdr_len,\n\t\t\t    bool inner_proto_inherit)\n{\n\tbool udp_sum = !!(info->key.tun_flags & TUNNEL_CSUM);\n\tstruct genevehdr *gnvh;\n\t__be16 inner_proto;\n\tint min_headroom;\n\tint err;\n\n\tskb_reset_mac_header(skb);\n\tskb_scrub_packet(skb, xnet);\n\n\tmin_headroom = LL_RESERVED_SPACE(dst->dev) + dst->header_len +\n\t\t       GENEVE_BASE_HLEN + info->options_len + ip_hdr_len;\n\terr = skb_cow_head(skb, min_headroom);\n\tif (unlikely(err))\n\t\tgoto free_dst;\n\n\terr = udp_tunnel_handle_offloads(skb, udp_sum);\n\tif (err)\n\t\tgoto free_dst;\n\n\tgnvh = __skb_push(skb, sizeof(*gnvh) + info->options_len);\n\tinner_proto = inner_proto_inherit ? skb->protocol : htons(ETH_P_TEB);\n\tgeneve_build_header(gnvh, info, inner_proto);\n\tskb_set_inner_protocol(skb, inner_proto);\n\treturn 0;\n\nfree_dst:\n\tdst_release(dst);\n\treturn err;\n}\n\nstatic struct rtable *geneve_get_v4_rt(struct sk_buff *skb,\n\t\t\t\t       struct net_device *dev,\n\t\t\t\t       struct geneve_sock *gs4,\n\t\t\t\t       struct flowi4 *fl4,\n\t\t\t\t       const struct ip_tunnel_info *info,\n\t\t\t\t       __be16 dport, __be16 sport,\n\t\t\t\t       __u8 *full_tos)\n{\n\tbool use_cache = ip_tunnel_dst_cache_usable(skb, info);\n\tstruct geneve_dev *geneve = netdev_priv(dev);\n\tstruct dst_cache *dst_cache;\n\tstruct rtable *rt = NULL;\n\t__u8 tos;\n\n\tif (!gs4)\n\t\treturn ERR_PTR(-EIO);\n\n\tmemset(fl4, 0, sizeof(*fl4));\n\tfl4->flowi4_mark = skb->mark;\n\tfl4->flowi4_proto = IPPROTO_UDP;\n\tfl4->daddr = info->key.u.ipv4.dst;\n\tfl4->saddr = info->key.u.ipv4.src;\n\tfl4->fl4_dport = dport;\n\tfl4->fl4_sport = sport;\n\tfl4->flowi4_flags = info->key.flow_flags;\n\n\ttos = info->key.tos;\n\tif ((tos == 1) && !geneve->cfg.collect_md) {\n\t\ttos = ip_tunnel_get_dsfield(ip_hdr(skb), skb);\n\t\tuse_cache = false;\n\t}\n\tfl4->flowi4_tos = RT_TOS(tos);\n\tif (full_tos)\n\t\t*full_tos = tos;\n\n\tdst_cache = (struct dst_cache *)&info->dst_cache;\n\tif (use_cache) {\n\t\trt = dst_cache_get_ip4(dst_cache, &fl4->saddr);\n\t\tif (rt)\n\t\t\treturn rt;\n\t}\n\trt = ip_route_output_key(geneve->net, fl4);\n\tif (IS_ERR(rt)) {\n\t\tnetdev_dbg(dev, \"no route to %pI4\\n\", &fl4->daddr);\n\t\treturn ERR_PTR(-ENETUNREACH);\n\t}\n\tif (rt->dst.dev == dev) {  \n\t\tnetdev_dbg(dev, \"circular route to %pI4\\n\", &fl4->daddr);\n\t\tip_rt_put(rt);\n\t\treturn ERR_PTR(-ELOOP);\n\t}\n\tif (use_cache)\n\t\tdst_cache_set_ip4(dst_cache, &rt->dst, fl4->saddr);\n\treturn rt;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic struct dst_entry *geneve_get_v6_dst(struct sk_buff *skb,\n\t\t\t\t\t   struct net_device *dev,\n\t\t\t\t\t   struct geneve_sock *gs6,\n\t\t\t\t\t   struct flowi6 *fl6,\n\t\t\t\t\t   const struct ip_tunnel_info *info,\n\t\t\t\t\t   __be16 dport, __be16 sport)\n{\n\tbool use_cache = ip_tunnel_dst_cache_usable(skb, info);\n\tstruct geneve_dev *geneve = netdev_priv(dev);\n\tstruct dst_entry *dst = NULL;\n\tstruct dst_cache *dst_cache;\n\t__u8 prio;\n\n\tif (!gs6)\n\t\treturn ERR_PTR(-EIO);\n\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->flowi6_mark = skb->mark;\n\tfl6->flowi6_proto = IPPROTO_UDP;\n\tfl6->daddr = info->key.u.ipv6.dst;\n\tfl6->saddr = info->key.u.ipv6.src;\n\tfl6->fl6_dport = dport;\n\tfl6->fl6_sport = sport;\n\n\tprio = info->key.tos;\n\tif ((prio == 1) && !geneve->cfg.collect_md) {\n\t\tprio = ip_tunnel_get_dsfield(ip_hdr(skb), skb);\n\t\tuse_cache = false;\n\t}\n\n\tfl6->flowlabel = ip6_make_flowinfo(prio, info->key.label);\n\tdst_cache = (struct dst_cache *)&info->dst_cache;\n\tif (use_cache) {\n\t\tdst = dst_cache_get_ip6(dst_cache, &fl6->saddr);\n\t\tif (dst)\n\t\t\treturn dst;\n\t}\n\tdst = ipv6_stub->ipv6_dst_lookup_flow(geneve->net, gs6->sock->sk, fl6,\n\t\t\t\t\t      NULL);\n\tif (IS_ERR(dst)) {\n\t\tnetdev_dbg(dev, \"no route to %pI6\\n\", &fl6->daddr);\n\t\treturn ERR_PTR(-ENETUNREACH);\n\t}\n\tif (dst->dev == dev) {  \n\t\tnetdev_dbg(dev, \"circular route to %pI6\\n\", &fl6->daddr);\n\t\tdst_release(dst);\n\t\treturn ERR_PTR(-ELOOP);\n\t}\n\n\tif (use_cache)\n\t\tdst_cache_set_ip6(dst_cache, dst, &fl6->saddr);\n\treturn dst;\n}\n#endif\n\nstatic int geneve_xmit_skb(struct sk_buff *skb, struct net_device *dev,\n\t\t\t   struct geneve_dev *geneve,\n\t\t\t   const struct ip_tunnel_info *info)\n{\n\tbool xnet = !net_eq(geneve->net, dev_net(geneve->dev));\n\tstruct geneve_sock *gs4 = rcu_dereference(geneve->sock4);\n\tconst struct ip_tunnel_key *key = &info->key;\n\tstruct rtable *rt;\n\tstruct flowi4 fl4;\n\t__u8 full_tos;\n\t__u8 tos, ttl;\n\t__be16 df = 0;\n\t__be16 sport;\n\tint err;\n\n\tif (!pskb_inet_may_pull(skb))\n\t\treturn -EINVAL;\n\n\tsport = udp_flow_src_port(geneve->net, skb, 1, USHRT_MAX, true);\n\trt = geneve_get_v4_rt(skb, dev, gs4, &fl4, info,\n\t\t\t      geneve->cfg.info.key.tp_dst, sport, &full_tos);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\n\terr = skb_tunnel_check_pmtu(skb, &rt->dst,\n\t\t\t\t    GENEVE_IPV4_HLEN + info->options_len,\n\t\t\t\t    netif_is_any_bridge_port(dev));\n\tif (err < 0) {\n\t\tdst_release(&rt->dst);\n\t\treturn err;\n\t} else if (err) {\n\t\tstruct ip_tunnel_info *info;\n\n\t\tinfo = skb_tunnel_info(skb);\n\t\tif (info) {\n\t\t\tstruct ip_tunnel_info *unclone;\n\n\t\t\tunclone = skb_tunnel_info_unclone(skb);\n\t\t\tif (unlikely(!unclone)) {\n\t\t\t\tdst_release(&rt->dst);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tunclone->key.u.ipv4.dst = fl4.saddr;\n\t\t\tunclone->key.u.ipv4.src = fl4.daddr;\n\t\t}\n\n\t\tif (!pskb_may_pull(skb, ETH_HLEN)) {\n\t\t\tdst_release(&rt->dst);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tskb->protocol = eth_type_trans(skb, geneve->dev);\n\t\t__netif_rx(skb);\n\t\tdst_release(&rt->dst);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tif (geneve->cfg.collect_md) {\n\t\ttos = ip_tunnel_ecn_encap(key->tos, ip_hdr(skb), skb);\n\t\tttl = key->ttl;\n\n\t\tdf = key->tun_flags & TUNNEL_DONT_FRAGMENT ? htons(IP_DF) : 0;\n\t} else {\n\t\ttos = ip_tunnel_ecn_encap(full_tos, ip_hdr(skb), skb);\n\t\tif (geneve->cfg.ttl_inherit)\n\t\t\tttl = ip_tunnel_get_ttl(ip_hdr(skb), skb);\n\t\telse\n\t\t\tttl = key->ttl;\n\t\tttl = ttl ? : ip4_dst_hoplimit(&rt->dst);\n\n\t\tif (geneve->cfg.df == GENEVE_DF_SET) {\n\t\t\tdf = htons(IP_DF);\n\t\t} else if (geneve->cfg.df == GENEVE_DF_INHERIT) {\n\t\t\tstruct ethhdr *eth = eth_hdr(skb);\n\n\t\t\tif (ntohs(eth->h_proto) == ETH_P_IPV6) {\n\t\t\t\tdf = htons(IP_DF);\n\t\t\t} else if (ntohs(eth->h_proto) == ETH_P_IP) {\n\t\t\t\tstruct iphdr *iph = ip_hdr(skb);\n\n\t\t\t\tif (iph->frag_off & htons(IP_DF))\n\t\t\t\t\tdf = htons(IP_DF);\n\t\t\t}\n\t\t}\n\t}\n\n\terr = geneve_build_skb(&rt->dst, skb, info, xnet, sizeof(struct iphdr),\n\t\t\t       geneve->cfg.inner_proto_inherit);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tudp_tunnel_xmit_skb(rt, gs4->sock->sk, skb, fl4.saddr, fl4.daddr,\n\t\t\t    tos, ttl, df, sport, geneve->cfg.info.key.tp_dst,\n\t\t\t    !net_eq(geneve->net, dev_net(geneve->dev)),\n\t\t\t    !(info->key.tun_flags & TUNNEL_CSUM));\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int geneve6_xmit_skb(struct sk_buff *skb, struct net_device *dev,\n\t\t\t    struct geneve_dev *geneve,\n\t\t\t    const struct ip_tunnel_info *info)\n{\n\tbool xnet = !net_eq(geneve->net, dev_net(geneve->dev));\n\tstruct geneve_sock *gs6 = rcu_dereference(geneve->sock6);\n\tconst struct ip_tunnel_key *key = &info->key;\n\tstruct dst_entry *dst = NULL;\n\tstruct flowi6 fl6;\n\t__u8 prio, ttl;\n\t__be16 sport;\n\tint err;\n\n\tif (!pskb_inet_may_pull(skb))\n\t\treturn -EINVAL;\n\n\tsport = udp_flow_src_port(geneve->net, skb, 1, USHRT_MAX, true);\n\tdst = geneve_get_v6_dst(skb, dev, gs6, &fl6, info,\n\t\t\t\tgeneve->cfg.info.key.tp_dst, sport);\n\tif (IS_ERR(dst))\n\t\treturn PTR_ERR(dst);\n\n\terr = skb_tunnel_check_pmtu(skb, dst,\n\t\t\t\t    GENEVE_IPV6_HLEN + info->options_len,\n\t\t\t\t    netif_is_any_bridge_port(dev));\n\tif (err < 0) {\n\t\tdst_release(dst);\n\t\treturn err;\n\t} else if (err) {\n\t\tstruct ip_tunnel_info *info = skb_tunnel_info(skb);\n\n\t\tif (info) {\n\t\t\tstruct ip_tunnel_info *unclone;\n\n\t\t\tunclone = skb_tunnel_info_unclone(skb);\n\t\t\tif (unlikely(!unclone)) {\n\t\t\t\tdst_release(dst);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tunclone->key.u.ipv6.dst = fl6.saddr;\n\t\t\tunclone->key.u.ipv6.src = fl6.daddr;\n\t\t}\n\n\t\tif (!pskb_may_pull(skb, ETH_HLEN)) {\n\t\t\tdst_release(dst);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tskb->protocol = eth_type_trans(skb, geneve->dev);\n\t\t__netif_rx(skb);\n\t\tdst_release(dst);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tif (geneve->cfg.collect_md) {\n\t\tprio = ip_tunnel_ecn_encap(key->tos, ip_hdr(skb), skb);\n\t\tttl = key->ttl;\n\t} else {\n\t\tprio = ip_tunnel_ecn_encap(ip6_tclass(fl6.flowlabel),\n\t\t\t\t\t   ip_hdr(skb), skb);\n\t\tif (geneve->cfg.ttl_inherit)\n\t\t\tttl = ip_tunnel_get_ttl(ip_hdr(skb), skb);\n\t\telse\n\t\t\tttl = key->ttl;\n\t\tttl = ttl ? : ip6_dst_hoplimit(dst);\n\t}\n\terr = geneve_build_skb(dst, skb, info, xnet, sizeof(struct ipv6hdr),\n\t\t\t       geneve->cfg.inner_proto_inherit);\n\tif (unlikely(err))\n\t\treturn err;\n\n\tudp_tunnel6_xmit_skb(dst, gs6->sock->sk, skb, dev,\n\t\t\t     &fl6.saddr, &fl6.daddr, prio, ttl,\n\t\t\t     info->key.label, sport, geneve->cfg.info.key.tp_dst,\n\t\t\t     !(info->key.tun_flags & TUNNEL_CSUM));\n\treturn 0;\n}\n#endif\n\nstatic netdev_tx_t geneve_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct geneve_dev *geneve = netdev_priv(dev);\n\tstruct ip_tunnel_info *info = NULL;\n\tint err;\n\n\tif (geneve->cfg.collect_md) {\n\t\tinfo = skb_tunnel_info(skb);\n\t\tif (unlikely(!info || !(info->mode & IP_TUNNEL_INFO_TX))) {\n\t\t\tnetdev_dbg(dev, \"no tunnel metadata\\n\");\n\t\t\tdev_kfree_skb(skb);\n\t\t\tdev->stats.tx_dropped++;\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t} else {\n\t\tinfo = &geneve->cfg.info;\n\t}\n\n\trcu_read_lock();\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (info->mode & IP_TUNNEL_INFO_IPV6)\n\t\terr = geneve6_xmit_skb(skb, dev, geneve, info);\n\telse\n#endif\n\t\terr = geneve_xmit_skb(skb, dev, geneve, info);\n\trcu_read_unlock();\n\n\tif (likely(!err))\n\t\treturn NETDEV_TX_OK;\n\n\tif (err != -EMSGSIZE)\n\t\tdev_kfree_skb(skb);\n\n\tif (err == -ELOOP)\n\t\tdev->stats.collisions++;\n\telse if (err == -ENETUNREACH)\n\t\tdev->stats.tx_carrier_errors++;\n\n\tdev->stats.tx_errors++;\n\treturn NETDEV_TX_OK;\n}\n\nstatic int geneve_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tif (new_mtu > dev->max_mtu)\n\t\tnew_mtu = dev->max_mtu;\n\telse if (new_mtu < dev->min_mtu)\n\t\tnew_mtu = dev->min_mtu;\n\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\nstatic int geneve_fill_metadata_dst(struct net_device *dev, struct sk_buff *skb)\n{\n\tstruct ip_tunnel_info *info = skb_tunnel_info(skb);\n\tstruct geneve_dev *geneve = netdev_priv(dev);\n\t__be16 sport;\n\n\tif (ip_tunnel_info_af(info) == AF_INET) {\n\t\tstruct rtable *rt;\n\t\tstruct flowi4 fl4;\n\n\t\tstruct geneve_sock *gs4 = rcu_dereference(geneve->sock4);\n\t\tsport = udp_flow_src_port(geneve->net, skb,\n\t\t\t\t\t  1, USHRT_MAX, true);\n\n\t\trt = geneve_get_v4_rt(skb, dev, gs4, &fl4, info,\n\t\t\t\t      geneve->cfg.info.key.tp_dst, sport, NULL);\n\t\tif (IS_ERR(rt))\n\t\t\treturn PTR_ERR(rt);\n\n\t\tip_rt_put(rt);\n\t\tinfo->key.u.ipv4.src = fl4.saddr;\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (ip_tunnel_info_af(info) == AF_INET6) {\n\t\tstruct dst_entry *dst;\n\t\tstruct flowi6 fl6;\n\n\t\tstruct geneve_sock *gs6 = rcu_dereference(geneve->sock6);\n\t\tsport = udp_flow_src_port(geneve->net, skb,\n\t\t\t\t\t  1, USHRT_MAX, true);\n\n\t\tdst = geneve_get_v6_dst(skb, dev, gs6, &fl6, info,\n\t\t\t\t\tgeneve->cfg.info.key.tp_dst, sport);\n\t\tif (IS_ERR(dst))\n\t\t\treturn PTR_ERR(dst);\n\n\t\tdst_release(dst);\n\t\tinfo->key.u.ipv6.src = fl6.saddr;\n#endif\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tinfo->key.tp_src = sport;\n\tinfo->key.tp_dst = geneve->cfg.info.key.tp_dst;\n\treturn 0;\n}\n\nstatic const struct net_device_ops geneve_netdev_ops = {\n\t.ndo_init\t\t= geneve_init,\n\t.ndo_uninit\t\t= geneve_uninit,\n\t.ndo_open\t\t= geneve_open,\n\t.ndo_stop\t\t= geneve_stop,\n\t.ndo_start_xmit\t\t= geneve_xmit,\n\t.ndo_get_stats64\t= dev_get_tstats64,\n\t.ndo_change_mtu\t\t= geneve_change_mtu,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_fill_metadata_dst\t= geneve_fill_metadata_dst,\n};\n\nstatic void geneve_get_drvinfo(struct net_device *dev,\n\t\t\t       struct ethtool_drvinfo *drvinfo)\n{\n\tstrscpy(drvinfo->version, GENEVE_NETDEV_VER, sizeof(drvinfo->version));\n\tstrscpy(drvinfo->driver, \"geneve\", sizeof(drvinfo->driver));\n}\n\nstatic const struct ethtool_ops geneve_ethtool_ops = {\n\t.get_drvinfo\t= geneve_get_drvinfo,\n\t.get_link\t= ethtool_op_get_link,\n};\n\n \nstatic struct device_type geneve_type = {\n\t.name = \"geneve\",\n};\n\n \nstatic void geneve_offload_rx_ports(struct net_device *dev, bool push)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct geneve_net *gn = net_generic(net, geneve_net_id);\n\tstruct geneve_sock *gs;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(gs, &gn->sock_list, list) {\n\t\tif (push) {\n\t\t\tudp_tunnel_push_rx_port(dev, gs->sock,\n\t\t\t\t\t\tUDP_TUNNEL_TYPE_GENEVE);\n\t\t} else {\n\t\t\tudp_tunnel_drop_rx_port(dev, gs->sock,\n\t\t\t\t\t\tUDP_TUNNEL_TYPE_GENEVE);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\n \nstatic void geneve_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\n\tdev->netdev_ops = &geneve_netdev_ops;\n\tdev->ethtool_ops = &geneve_ethtool_ops;\n\tdev->needs_free_netdev = true;\n\n\tSET_NETDEV_DEVTYPE(dev, &geneve_type);\n\n\tdev->features    |= NETIF_F_LLTX;\n\tdev->features    |= NETIF_F_SG | NETIF_F_HW_CSUM | NETIF_F_FRAGLIST;\n\tdev->features    |= NETIF_F_RXCSUM;\n\tdev->features    |= NETIF_F_GSO_SOFTWARE;\n\n\tdev->hw_features |= NETIF_F_SG | NETIF_F_HW_CSUM | NETIF_F_FRAGLIST;\n\tdev->hw_features |= NETIF_F_RXCSUM;\n\tdev->hw_features |= NETIF_F_GSO_SOFTWARE;\n\n\t \n\tdev->min_mtu = ETH_MIN_MTU;\n\t \n\tdev->max_mtu = IP_MAX_MTU - GENEVE_BASE_HLEN - dev->hard_header_len;\n\n\tnetif_keep_dst(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->priv_flags |= IFF_LIVE_ADDR_CHANGE | IFF_NO_QUEUE;\n\teth_hw_addr_random(dev);\n}\n\nstatic const struct nla_policy geneve_policy[IFLA_GENEVE_MAX + 1] = {\n\t[IFLA_GENEVE_UNSPEC]\t\t= { .strict_start_type = IFLA_GENEVE_INNER_PROTO_INHERIT },\n\t[IFLA_GENEVE_ID]\t\t= { .type = NLA_U32 },\n\t[IFLA_GENEVE_REMOTE]\t\t= { .len = sizeof_field(struct iphdr, daddr) },\n\t[IFLA_GENEVE_REMOTE6]\t\t= { .len = sizeof(struct in6_addr) },\n\t[IFLA_GENEVE_TTL]\t\t= { .type = NLA_U8 },\n\t[IFLA_GENEVE_TOS]\t\t= { .type = NLA_U8 },\n\t[IFLA_GENEVE_LABEL]\t\t= { .type = NLA_U32 },\n\t[IFLA_GENEVE_PORT]\t\t= { .type = NLA_U16 },\n\t[IFLA_GENEVE_COLLECT_METADATA]\t= { .type = NLA_FLAG },\n\t[IFLA_GENEVE_UDP_CSUM]\t\t= { .type = NLA_U8 },\n\t[IFLA_GENEVE_UDP_ZERO_CSUM6_TX]\t= { .type = NLA_U8 },\n\t[IFLA_GENEVE_UDP_ZERO_CSUM6_RX]\t= { .type = NLA_U8 },\n\t[IFLA_GENEVE_TTL_INHERIT]\t= { .type = NLA_U8 },\n\t[IFLA_GENEVE_DF]\t\t= { .type = NLA_U8 },\n\t[IFLA_GENEVE_INNER_PROTO_INHERIT]\t= { .type = NLA_FLAG },\n};\n\nstatic int geneve_validate(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t   struct netlink_ext_ack *extack)\n{\n\tif (tb[IFLA_ADDRESS]) {\n\t\tif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, tb[IFLA_ADDRESS],\n\t\t\t\t\t    \"Provided link layer address is not Ethernet\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS]))) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, tb[IFLA_ADDRESS],\n\t\t\t\t\t    \"Provided Ethernet address is not unicast\");\n\t\t\treturn -EADDRNOTAVAIL;\n\t\t}\n\t}\n\n\tif (!data) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Not enough attributes provided to perform the operation\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (data[IFLA_GENEVE_ID]) {\n\t\t__u32 vni =  nla_get_u32(data[IFLA_GENEVE_ID]);\n\n\t\tif (vni >= GENEVE_N_VID) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, data[IFLA_GENEVE_ID],\n\t\t\t\t\t    \"Geneve ID must be lower than 16777216\");\n\t\t\treturn -ERANGE;\n\t\t}\n\t}\n\n\tif (data[IFLA_GENEVE_DF]) {\n\t\tenum ifla_geneve_df df = nla_get_u8(data[IFLA_GENEVE_DF]);\n\n\t\tif (df < 0 || df > GENEVE_DF_MAX) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, data[IFLA_GENEVE_DF],\n\t\t\t\t\t    \"Invalid DF attribute\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic struct geneve_dev *geneve_find_dev(struct geneve_net *gn,\n\t\t\t\t\t  const struct ip_tunnel_info *info,\n\t\t\t\t\t  bool *tun_on_same_port,\n\t\t\t\t\t  bool *tun_collect_md)\n{\n\tstruct geneve_dev *geneve, *t = NULL;\n\n\t*tun_on_same_port = false;\n\t*tun_collect_md = false;\n\tlist_for_each_entry(geneve, &gn->geneve_list, next) {\n\t\tif (info->key.tp_dst == geneve->cfg.info.key.tp_dst) {\n\t\t\t*tun_collect_md = geneve->cfg.collect_md;\n\t\t\t*tun_on_same_port = true;\n\t\t}\n\t\tif (info->key.tun_id == geneve->cfg.info.key.tun_id &&\n\t\t    info->key.tp_dst == geneve->cfg.info.key.tp_dst &&\n\t\t    !memcmp(&info->key.u, &geneve->cfg.info.key.u, sizeof(info->key.u)))\n\t\t\tt = geneve;\n\t}\n\treturn t;\n}\n\nstatic bool is_tnl_info_zero(const struct ip_tunnel_info *info)\n{\n\treturn !(info->key.tun_id || info->key.tun_flags || info->key.tos ||\n\t\t info->key.ttl || info->key.label || info->key.tp_src ||\n\t\t memchr_inv(&info->key.u, 0, sizeof(info->key.u)));\n}\n\nstatic bool geneve_dst_addr_equal(struct ip_tunnel_info *a,\n\t\t\t\t  struct ip_tunnel_info *b)\n{\n\tif (ip_tunnel_info_af(a) == AF_INET)\n\t\treturn a->key.u.ipv4.dst == b->key.u.ipv4.dst;\n\telse\n\t\treturn ipv6_addr_equal(&a->key.u.ipv6.dst, &b->key.u.ipv6.dst);\n}\n\nstatic int geneve_configure(struct net *net, struct net_device *dev,\n\t\t\t    struct netlink_ext_ack *extack,\n\t\t\t    const struct geneve_config *cfg)\n{\n\tstruct geneve_net *gn = net_generic(net, geneve_net_id);\n\tstruct geneve_dev *t, *geneve = netdev_priv(dev);\n\tconst struct ip_tunnel_info *info = &cfg->info;\n\tbool tun_collect_md, tun_on_same_port;\n\tint err, encap_len;\n\n\tif (cfg->collect_md && !is_tnl_info_zero(info)) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Device is externally controlled, so attributes (VNI, Port, and so on) must not be specified\");\n\t\treturn -EINVAL;\n\t}\n\n\tgeneve->net = net;\n\tgeneve->dev = dev;\n\n\tt = geneve_find_dev(gn, info, &tun_on_same_port, &tun_collect_md);\n\tif (t)\n\t\treturn -EBUSY;\n\n\t \n\tencap_len = GENEVE_BASE_HLEN + ETH_HLEN;\n\tif (!cfg->collect_md && ip_tunnel_info_af(info) == AF_INET) {\n\t\tencap_len += sizeof(struct iphdr);\n\t\tdev->max_mtu -= sizeof(struct iphdr);\n\t} else {\n\t\tencap_len += sizeof(struct ipv6hdr);\n\t\tdev->max_mtu -= sizeof(struct ipv6hdr);\n\t}\n\tdev->needed_headroom = encap_len + ETH_HLEN;\n\n\tif (cfg->collect_md) {\n\t\tif (tun_on_same_port) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"There can be only one externally controlled device on a destination port\");\n\t\t\treturn -EPERM;\n\t\t}\n\t} else {\n\t\tif (tun_collect_md) {\n\t\t\tNL_SET_ERR_MSG(extack,\n\t\t\t\t       \"There already exists an externally controlled device on this destination port\");\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\tdst_cache_reset(&geneve->cfg.info.dst_cache);\n\tmemcpy(&geneve->cfg, cfg, sizeof(*cfg));\n\n\tif (geneve->cfg.inner_proto_inherit) {\n\t\tdev->header_ops = NULL;\n\t\tdev->type = ARPHRD_NONE;\n\t\tdev->hard_header_len = 0;\n\t\tdev->addr_len = 0;\n\t\tdev->flags = IFF_POINTOPOINT | IFF_NOARP;\n\t}\n\n\terr = register_netdevice(dev);\n\tif (err)\n\t\treturn err;\n\n\tlist_add(&geneve->next, &gn->geneve_list);\n\treturn 0;\n}\n\nstatic void init_tnl_info(struct ip_tunnel_info *info, __u16 dst_port)\n{\n\tmemset(info, 0, sizeof(*info));\n\tinfo->key.tp_dst = htons(dst_port);\n}\n\nstatic int geneve_nl2info(struct nlattr *tb[], struct nlattr *data[],\n\t\t\t  struct netlink_ext_ack *extack,\n\t\t\t  struct geneve_config *cfg, bool changelink)\n{\n\tstruct ip_tunnel_info *info = &cfg->info;\n\tint attrtype;\n\n\tif (data[IFLA_GENEVE_REMOTE] && data[IFLA_GENEVE_REMOTE6]) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Cannot specify both IPv4 and IPv6 Remote addresses\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (data[IFLA_GENEVE_REMOTE]) {\n\t\tif (changelink && (ip_tunnel_info_af(info) == AF_INET6)) {\n\t\t\tattrtype = IFLA_GENEVE_REMOTE;\n\t\t\tgoto change_notsup;\n\t\t}\n\n\t\tinfo->key.u.ipv4.dst =\n\t\t\tnla_get_in_addr(data[IFLA_GENEVE_REMOTE]);\n\n\t\tif (ipv4_is_multicast(info->key.u.ipv4.dst)) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, data[IFLA_GENEVE_REMOTE],\n\t\t\t\t\t    \"Remote IPv4 address cannot be Multicast\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (data[IFLA_GENEVE_REMOTE6]) {\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (changelink && (ip_tunnel_info_af(info) == AF_INET)) {\n\t\t\tattrtype = IFLA_GENEVE_REMOTE6;\n\t\t\tgoto change_notsup;\n\t\t}\n\n\t\tinfo->mode = IP_TUNNEL_INFO_IPV6;\n\t\tinfo->key.u.ipv6.dst =\n\t\t\tnla_get_in6_addr(data[IFLA_GENEVE_REMOTE6]);\n\n\t\tif (ipv6_addr_type(&info->key.u.ipv6.dst) &\n\t\t    IPV6_ADDR_LINKLOCAL) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, data[IFLA_GENEVE_REMOTE6],\n\t\t\t\t\t    \"Remote IPv6 address cannot be link-local\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ipv6_addr_is_multicast(&info->key.u.ipv6.dst)) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, data[IFLA_GENEVE_REMOTE6],\n\t\t\t\t\t    \"Remote IPv6 address cannot be Multicast\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tinfo->key.tun_flags |= TUNNEL_CSUM;\n\t\tcfg->use_udp6_rx_checksums = true;\n#else\n\t\tNL_SET_ERR_MSG_ATTR(extack, data[IFLA_GENEVE_REMOTE6],\n\t\t\t\t    \"IPv6 support not enabled in the kernel\");\n\t\treturn -EPFNOSUPPORT;\n#endif\n\t}\n\n\tif (data[IFLA_GENEVE_ID]) {\n\t\t__u32 vni;\n\t\t__u8 tvni[3];\n\t\t__be64 tunid;\n\n\t\tvni = nla_get_u32(data[IFLA_GENEVE_ID]);\n\t\ttvni[0] = (vni & 0x00ff0000) >> 16;\n\t\ttvni[1] = (vni & 0x0000ff00) >> 8;\n\t\ttvni[2] =  vni & 0x000000ff;\n\n\t\ttunid = vni_to_tunnel_id(tvni);\n\t\tif (changelink && (tunid != info->key.tun_id)) {\n\t\t\tattrtype = IFLA_GENEVE_ID;\n\t\t\tgoto change_notsup;\n\t\t}\n\t\tinfo->key.tun_id = tunid;\n\t}\n\n\tif (data[IFLA_GENEVE_TTL_INHERIT]) {\n\t\tif (nla_get_u8(data[IFLA_GENEVE_TTL_INHERIT]))\n\t\t\tcfg->ttl_inherit = true;\n\t\telse\n\t\t\tcfg->ttl_inherit = false;\n\t} else if (data[IFLA_GENEVE_TTL]) {\n\t\tinfo->key.ttl = nla_get_u8(data[IFLA_GENEVE_TTL]);\n\t\tcfg->ttl_inherit = false;\n\t}\n\n\tif (data[IFLA_GENEVE_TOS])\n\t\tinfo->key.tos = nla_get_u8(data[IFLA_GENEVE_TOS]);\n\n\tif (data[IFLA_GENEVE_DF])\n\t\tcfg->df = nla_get_u8(data[IFLA_GENEVE_DF]);\n\n\tif (data[IFLA_GENEVE_LABEL]) {\n\t\tinfo->key.label = nla_get_be32(data[IFLA_GENEVE_LABEL]) &\n\t\t\t\t  IPV6_FLOWLABEL_MASK;\n\t\tif (info->key.label && (!(info->mode & IP_TUNNEL_INFO_IPV6))) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, data[IFLA_GENEVE_LABEL],\n\t\t\t\t\t    \"Label attribute only applies for IPv6 Geneve devices\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (data[IFLA_GENEVE_PORT]) {\n\t\tif (changelink) {\n\t\t\tattrtype = IFLA_GENEVE_PORT;\n\t\t\tgoto change_notsup;\n\t\t}\n\t\tinfo->key.tp_dst = nla_get_be16(data[IFLA_GENEVE_PORT]);\n\t}\n\n\tif (data[IFLA_GENEVE_COLLECT_METADATA]) {\n\t\tif (changelink) {\n\t\t\tattrtype = IFLA_GENEVE_COLLECT_METADATA;\n\t\t\tgoto change_notsup;\n\t\t}\n\t\tcfg->collect_md = true;\n\t}\n\n\tif (data[IFLA_GENEVE_UDP_CSUM]) {\n\t\tif (changelink) {\n\t\t\tattrtype = IFLA_GENEVE_UDP_CSUM;\n\t\t\tgoto change_notsup;\n\t\t}\n\t\tif (nla_get_u8(data[IFLA_GENEVE_UDP_CSUM]))\n\t\t\tinfo->key.tun_flags |= TUNNEL_CSUM;\n\t}\n\n\tif (data[IFLA_GENEVE_UDP_ZERO_CSUM6_TX]) {\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (changelink) {\n\t\t\tattrtype = IFLA_GENEVE_UDP_ZERO_CSUM6_TX;\n\t\t\tgoto change_notsup;\n\t\t}\n\t\tif (nla_get_u8(data[IFLA_GENEVE_UDP_ZERO_CSUM6_TX]))\n\t\t\tinfo->key.tun_flags &= ~TUNNEL_CSUM;\n#else\n\t\tNL_SET_ERR_MSG_ATTR(extack, data[IFLA_GENEVE_UDP_ZERO_CSUM6_TX],\n\t\t\t\t    \"IPv6 support not enabled in the kernel\");\n\t\treturn -EPFNOSUPPORT;\n#endif\n\t}\n\n\tif (data[IFLA_GENEVE_UDP_ZERO_CSUM6_RX]) {\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (changelink) {\n\t\t\tattrtype = IFLA_GENEVE_UDP_ZERO_CSUM6_RX;\n\t\t\tgoto change_notsup;\n\t\t}\n\t\tif (nla_get_u8(data[IFLA_GENEVE_UDP_ZERO_CSUM6_RX]))\n\t\t\tcfg->use_udp6_rx_checksums = false;\n#else\n\t\tNL_SET_ERR_MSG_ATTR(extack, data[IFLA_GENEVE_UDP_ZERO_CSUM6_RX],\n\t\t\t\t    \"IPv6 support not enabled in the kernel\");\n\t\treturn -EPFNOSUPPORT;\n#endif\n\t}\n\n\tif (data[IFLA_GENEVE_INNER_PROTO_INHERIT]) {\n\t\tif (changelink) {\n\t\t\tattrtype = IFLA_GENEVE_INNER_PROTO_INHERIT;\n\t\t\tgoto change_notsup;\n\t\t}\n\t\tcfg->inner_proto_inherit = true;\n\t}\n\n\treturn 0;\nchange_notsup:\n\tNL_SET_ERR_MSG_ATTR(extack, data[attrtype],\n\t\t\t    \"Changing VNI, Port, endpoint IP address family, external, inner_proto_inherit, and UDP checksum attributes are not supported\");\n\treturn -EOPNOTSUPP;\n}\n\nstatic void geneve_link_config(struct net_device *dev,\n\t\t\t       struct ip_tunnel_info *info, struct nlattr *tb[])\n{\n\tstruct geneve_dev *geneve = netdev_priv(dev);\n\tint ldev_mtu = 0;\n\n\tif (tb[IFLA_MTU]) {\n\t\tgeneve_change_mtu(dev, nla_get_u32(tb[IFLA_MTU]));\n\t\treturn;\n\t}\n\n\tswitch (ip_tunnel_info_af(info)) {\n\tcase AF_INET: {\n\t\tstruct flowi4 fl4 = { .daddr = info->key.u.ipv4.dst };\n\t\tstruct rtable *rt = ip_route_output_key(geneve->net, &fl4);\n\n\t\tif (!IS_ERR(rt) && rt->dst.dev) {\n\t\t\tldev_mtu = rt->dst.dev->mtu - GENEVE_IPV4_HLEN;\n\t\t\tip_rt_put(rt);\n\t\t}\n\t\tbreak;\n\t}\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6: {\n\t\tstruct rt6_info *rt;\n\n\t\tif (!__in6_dev_get(dev))\n\t\t\tbreak;\n\n\t\trt = rt6_lookup(geneve->net, &info->key.u.ipv6.dst, NULL, 0,\n\t\t\t\tNULL, 0);\n\n\t\tif (rt && rt->dst.dev)\n\t\t\tldev_mtu = rt->dst.dev->mtu - GENEVE_IPV6_HLEN;\n\t\tip6_rt_put(rt);\n\t\tbreak;\n\t}\n#endif\n\t}\n\n\tif (ldev_mtu <= 0)\n\t\treturn;\n\n\tgeneve_change_mtu(dev, ldev_mtu - info->options_len);\n}\n\nstatic int geneve_newlink(struct net *net, struct net_device *dev,\n\t\t\t  struct nlattr *tb[], struct nlattr *data[],\n\t\t\t  struct netlink_ext_ack *extack)\n{\n\tstruct geneve_config cfg = {\n\t\t.df = GENEVE_DF_UNSET,\n\t\t.use_udp6_rx_checksums = false,\n\t\t.ttl_inherit = false,\n\t\t.collect_md = false,\n\t};\n\tint err;\n\n\tinit_tnl_info(&cfg.info, GENEVE_UDP_PORT);\n\terr = geneve_nl2info(tb, data, extack, &cfg, false);\n\tif (err)\n\t\treturn err;\n\n\terr = geneve_configure(net, dev, extack, &cfg);\n\tif (err)\n\t\treturn err;\n\n\tgeneve_link_config(dev, &cfg.info, tb);\n\n\treturn 0;\n}\n\n \nstatic void geneve_quiesce(struct geneve_dev *geneve, struct geneve_sock **gs4,\n\t\t\t   struct geneve_sock **gs6)\n{\n\t*gs4 = rtnl_dereference(geneve->sock4);\n\trcu_assign_pointer(geneve->sock4, NULL);\n\tif (*gs4)\n\t\trcu_assign_sk_user_data((*gs4)->sock->sk, NULL);\n#if IS_ENABLED(CONFIG_IPV6)\n\t*gs6 = rtnl_dereference(geneve->sock6);\n\trcu_assign_pointer(geneve->sock6, NULL);\n\tif (*gs6)\n\t\trcu_assign_sk_user_data((*gs6)->sock->sk, NULL);\n#else\n\t*gs6 = NULL;\n#endif\n\tsynchronize_net();\n}\n\n \nstatic void geneve_unquiesce(struct geneve_dev *geneve, struct geneve_sock *gs4,\n\t\t\t     struct geneve_sock __maybe_unused *gs6)\n{\n\trcu_assign_pointer(geneve->sock4, gs4);\n\tif (gs4)\n\t\trcu_assign_sk_user_data(gs4->sock->sk, gs4);\n#if IS_ENABLED(CONFIG_IPV6)\n\trcu_assign_pointer(geneve->sock6, gs6);\n\tif (gs6)\n\t\trcu_assign_sk_user_data(gs6->sock->sk, gs6);\n#endif\n\tsynchronize_net();\n}\n\nstatic int geneve_changelink(struct net_device *dev, struct nlattr *tb[],\n\t\t\t     struct nlattr *data[],\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct geneve_dev *geneve = netdev_priv(dev);\n\tstruct geneve_sock *gs4, *gs6;\n\tstruct geneve_config cfg;\n\tint err;\n\n\t \n\tif (geneve->cfg.collect_md)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tmemcpy(&cfg, &geneve->cfg, sizeof(cfg));\n\terr = geneve_nl2info(tb, data, extack, &cfg, true);\n\tif (err)\n\t\treturn err;\n\n\tif (!geneve_dst_addr_equal(&geneve->cfg.info, &cfg.info)) {\n\t\tdst_cache_reset(&cfg.info.dst_cache);\n\t\tgeneve_link_config(dev, &cfg.info, tb);\n\t}\n\n\tgeneve_quiesce(geneve, &gs4, &gs6);\n\tmemcpy(&geneve->cfg, &cfg, sizeof(cfg));\n\tgeneve_unquiesce(geneve, gs4, gs6);\n\n\treturn 0;\n}\n\nstatic void geneve_dellink(struct net_device *dev, struct list_head *head)\n{\n\tstruct geneve_dev *geneve = netdev_priv(dev);\n\n\tlist_del(&geneve->next);\n\tunregister_netdevice_queue(dev, head);\n}\n\nstatic size_t geneve_get_size(const struct net_device *dev)\n{\n\treturn nla_total_size(sizeof(__u32)) +\t \n\t\tnla_total_size(sizeof(struct in6_addr)) +  \n\t\tnla_total_size(sizeof(__u8)) +   \n\t\tnla_total_size(sizeof(__u8)) +   \n\t\tnla_total_size(sizeof(__u8)) +\t \n\t\tnla_total_size(sizeof(__be32)) +   \n\t\tnla_total_size(sizeof(__be16)) +   \n\t\tnla_total_size(0) +\t  \n\t\tnla_total_size(sizeof(__u8)) +  \n\t\tnla_total_size(sizeof(__u8)) +  \n\t\tnla_total_size(sizeof(__u8)) +  \n\t\tnla_total_size(sizeof(__u8)) +  \n\t\tnla_total_size(0) +\t  \n\t\t0;\n}\n\nstatic int geneve_fill_info(struct sk_buff *skb, const struct net_device *dev)\n{\n\tstruct geneve_dev *geneve = netdev_priv(dev);\n\tstruct ip_tunnel_info *info = &geneve->cfg.info;\n\tbool ttl_inherit = geneve->cfg.ttl_inherit;\n\tbool metadata = geneve->cfg.collect_md;\n\t__u8 tmp_vni[3];\n\t__u32 vni;\n\n\ttunnel_id_to_vni(info->key.tun_id, tmp_vni);\n\tvni = (tmp_vni[0] << 16) | (tmp_vni[1] << 8) | tmp_vni[2];\n\tif (nla_put_u32(skb, IFLA_GENEVE_ID, vni))\n\t\tgoto nla_put_failure;\n\n\tif (!metadata && ip_tunnel_info_af(info) == AF_INET) {\n\t\tif (nla_put_in_addr(skb, IFLA_GENEVE_REMOTE,\n\t\t\t\t    info->key.u.ipv4.dst))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u8(skb, IFLA_GENEVE_UDP_CSUM,\n\t\t\t       !!(info->key.tun_flags & TUNNEL_CSUM)))\n\t\t\tgoto nla_put_failure;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (!metadata) {\n\t\tif (nla_put_in6_addr(skb, IFLA_GENEVE_REMOTE6,\n\t\t\t\t     &info->key.u.ipv6.dst))\n\t\t\tgoto nla_put_failure;\n\t\tif (nla_put_u8(skb, IFLA_GENEVE_UDP_ZERO_CSUM6_TX,\n\t\t\t       !(info->key.tun_flags & TUNNEL_CSUM)))\n\t\t\tgoto nla_put_failure;\n#endif\n\t}\n\n\tif (nla_put_u8(skb, IFLA_GENEVE_TTL, info->key.ttl) ||\n\t    nla_put_u8(skb, IFLA_GENEVE_TOS, info->key.tos) ||\n\t    nla_put_be32(skb, IFLA_GENEVE_LABEL, info->key.label))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_u8(skb, IFLA_GENEVE_DF, geneve->cfg.df))\n\t\tgoto nla_put_failure;\n\n\tif (nla_put_be16(skb, IFLA_GENEVE_PORT, info->key.tp_dst))\n\t\tgoto nla_put_failure;\n\n\tif (metadata && nla_put_flag(skb, IFLA_GENEVE_COLLECT_METADATA))\n\t\tgoto nla_put_failure;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tif (nla_put_u8(skb, IFLA_GENEVE_UDP_ZERO_CSUM6_RX,\n\t\t       !geneve->cfg.use_udp6_rx_checksums))\n\t\tgoto nla_put_failure;\n#endif\n\n\tif (nla_put_u8(skb, IFLA_GENEVE_TTL_INHERIT, ttl_inherit))\n\t\tgoto nla_put_failure;\n\n\tif (geneve->cfg.inner_proto_inherit &&\n\t    nla_put_flag(skb, IFLA_GENEVE_INNER_PROTO_INHERIT))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic struct rtnl_link_ops geneve_link_ops __read_mostly = {\n\t.kind\t\t= \"geneve\",\n\t.maxtype\t= IFLA_GENEVE_MAX,\n\t.policy\t\t= geneve_policy,\n\t.priv_size\t= sizeof(struct geneve_dev),\n\t.setup\t\t= geneve_setup,\n\t.validate\t= geneve_validate,\n\t.newlink\t= geneve_newlink,\n\t.changelink\t= geneve_changelink,\n\t.dellink\t= geneve_dellink,\n\t.get_size\t= geneve_get_size,\n\t.fill_info\t= geneve_fill_info,\n};\n\nstruct net_device *geneve_dev_create_fb(struct net *net, const char *name,\n\t\t\t\t\tu8 name_assign_type, u16 dst_port)\n{\n\tstruct nlattr *tb[IFLA_MAX + 1];\n\tstruct net_device *dev;\n\tLIST_HEAD(list_kill);\n\tint err;\n\tstruct geneve_config cfg = {\n\t\t.df = GENEVE_DF_UNSET,\n\t\t.use_udp6_rx_checksums = true,\n\t\t.ttl_inherit = false,\n\t\t.collect_md = true,\n\t};\n\n\tmemset(tb, 0, sizeof(tb));\n\tdev = rtnl_create_link(net, name, name_assign_type,\n\t\t\t       &geneve_link_ops, tb, NULL);\n\tif (IS_ERR(dev))\n\t\treturn dev;\n\n\tinit_tnl_info(&cfg.info, dst_port);\n\terr = geneve_configure(net, dev, NULL, &cfg);\n\tif (err) {\n\t\tfree_netdev(dev);\n\t\treturn ERR_PTR(err);\n\t}\n\n\t \n\terr = geneve_change_mtu(dev, IP_MAX_MTU);\n\tif (err)\n\t\tgoto err;\n\n\terr = rtnl_configure_link(dev, NULL, 0, NULL);\n\tif (err < 0)\n\t\tgoto err;\n\n\treturn dev;\nerr:\n\tgeneve_dellink(dev, &list_kill);\n\tunregister_netdevice_many(&list_kill);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(geneve_dev_create_fb);\n\nstatic int geneve_netdevice_event(struct notifier_block *unused,\n\t\t\t\t  unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tif (event == NETDEV_UDP_TUNNEL_PUSH_INFO)\n\t\tgeneve_offload_rx_ports(dev, true);\n\telse if (event == NETDEV_UDP_TUNNEL_DROP_INFO)\n\t\tgeneve_offload_rx_ports(dev, false);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block geneve_notifier_block __read_mostly = {\n\t.notifier_call = geneve_netdevice_event,\n};\n\nstatic __net_init int geneve_init_net(struct net *net)\n{\n\tstruct geneve_net *gn = net_generic(net, geneve_net_id);\n\n\tINIT_LIST_HEAD(&gn->geneve_list);\n\tINIT_LIST_HEAD(&gn->sock_list);\n\treturn 0;\n}\n\nstatic void geneve_destroy_tunnels(struct net *net, struct list_head *head)\n{\n\tstruct geneve_net *gn = net_generic(net, geneve_net_id);\n\tstruct geneve_dev *geneve, *next;\n\tstruct net_device *dev, *aux;\n\n\t \n\tfor_each_netdev_safe(net, dev, aux)\n\t\tif (dev->rtnl_link_ops == &geneve_link_ops)\n\t\t\tunregister_netdevice_queue(dev, head);\n\n\t \n\tlist_for_each_entry_safe(geneve, next, &gn->geneve_list, next) {\n\t\t \n\t\tif (!net_eq(dev_net(geneve->dev), net))\n\t\t\tunregister_netdevice_queue(geneve->dev, head);\n\t}\n}\n\nstatic void __net_exit geneve_exit_batch_net(struct list_head *net_list)\n{\n\tstruct net *net;\n\tLIST_HEAD(list);\n\n\trtnl_lock();\n\tlist_for_each_entry(net, net_list, exit_list)\n\t\tgeneve_destroy_tunnels(net, &list);\n\n\t \n\tunregister_netdevice_many(&list);\n\trtnl_unlock();\n\n\tlist_for_each_entry(net, net_list, exit_list) {\n\t\tconst struct geneve_net *gn = net_generic(net, geneve_net_id);\n\n\t\tWARN_ON_ONCE(!list_empty(&gn->sock_list));\n\t}\n}\n\nstatic struct pernet_operations geneve_net_ops = {\n\t.init = geneve_init_net,\n\t.exit_batch = geneve_exit_batch_net,\n\t.id   = &geneve_net_id,\n\t.size = sizeof(struct geneve_net),\n};\n\nstatic int __init geneve_init_module(void)\n{\n\tint rc;\n\n\trc = register_pernet_subsys(&geneve_net_ops);\n\tif (rc)\n\t\tgoto out1;\n\n\trc = register_netdevice_notifier(&geneve_notifier_block);\n\tif (rc)\n\t\tgoto out2;\n\n\trc = rtnl_link_register(&geneve_link_ops);\n\tif (rc)\n\t\tgoto out3;\n\n\treturn 0;\nout3:\n\tunregister_netdevice_notifier(&geneve_notifier_block);\nout2:\n\tunregister_pernet_subsys(&geneve_net_ops);\nout1:\n\treturn rc;\n}\nlate_initcall(geneve_init_module);\n\nstatic void __exit geneve_cleanup_module(void)\n{\n\trtnl_link_unregister(&geneve_link_ops);\n\tunregister_netdevice_notifier(&geneve_notifier_block);\n\tunregister_pernet_subsys(&geneve_net_ops);\n}\nmodule_exit(geneve_cleanup_module);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(GENEVE_NETDEV_VER);\nMODULE_AUTHOR(\"John W. Linville <linville@tuxdriver.com>\");\nMODULE_DESCRIPTION(\"Interface driver for GENEVE encapsulated traffic\");\nMODULE_ALIAS_RTNL_LINK(\"geneve\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}