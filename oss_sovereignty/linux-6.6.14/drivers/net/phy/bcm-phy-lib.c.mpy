{
  "module_name": "bcm-phy-lib.c",
  "hash_id": "86ea9b36e69de33f9af499371bed9c0bbcb3e7ae0110d4043dff58c5143a24a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/bcm-phy-lib.c",
  "human_readable_source": "\n \n\n#include \"bcm-phy-lib.h\"\n#include <linux/bitfield.h>\n#include <linux/brcmphy.h>\n#include <linux/etherdevice.h>\n#include <linux/export.h>\n#include <linux/mdio.h>\n#include <linux/module.h>\n#include <linux/phy.h>\n#include <linux/ethtool.h>\n#include <linux/ethtool_netlink.h>\n#include <linux/netdevice.h>\n\n#define MII_BCM_CHANNEL_WIDTH     0x2000\n#define BCM_CL45VEN_EEE_ADV       0x3c\n\nint __bcm_phy_write_exp(struct phy_device *phydev, u16 reg, u16 val)\n{\n\tint rc;\n\n\trc = __phy_write(phydev, MII_BCM54XX_EXP_SEL, reg);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn __phy_write(phydev, MII_BCM54XX_EXP_DATA, val);\n}\nEXPORT_SYMBOL_GPL(__bcm_phy_write_exp);\n\nint bcm_phy_write_exp(struct phy_device *phydev, u16 reg, u16 val)\n{\n\tint rc;\n\n\tphy_lock_mdio_bus(phydev);\n\trc = __bcm_phy_write_exp(phydev, reg, val);\n\tphy_unlock_mdio_bus(phydev);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(bcm_phy_write_exp);\n\nint __bcm_phy_read_exp(struct phy_device *phydev, u16 reg)\n{\n\tint val;\n\n\tval = __phy_write(phydev, MII_BCM54XX_EXP_SEL, reg);\n\tif (val < 0)\n\t\treturn val;\n\n\tval = __phy_read(phydev, MII_BCM54XX_EXP_DATA);\n\n\t \n\t__phy_write(phydev, MII_BCM54XX_EXP_SEL, 0);\n\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(__bcm_phy_read_exp);\n\nint bcm_phy_read_exp(struct phy_device *phydev, u16 reg)\n{\n\tint rc;\n\n\tphy_lock_mdio_bus(phydev);\n\trc = __bcm_phy_read_exp(phydev, reg);\n\tphy_unlock_mdio_bus(phydev);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(bcm_phy_read_exp);\n\nint __bcm_phy_modify_exp(struct phy_device *phydev, u16 reg, u16 mask, u16 set)\n{\n\tint new, ret;\n\n\tret = __phy_write(phydev, MII_BCM54XX_EXP_SEL, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = __phy_read(phydev, MII_BCM54XX_EXP_DATA);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnew = (ret & ~mask) | set;\n\tif (new == ret)\n\t\treturn 0;\n\n\treturn __phy_write(phydev, MII_BCM54XX_EXP_DATA, new);\n}\nEXPORT_SYMBOL_GPL(__bcm_phy_modify_exp);\n\nint bcm_phy_modify_exp(struct phy_device *phydev, u16 reg, u16 mask, u16 set)\n{\n\tint ret;\n\n\tphy_lock_mdio_bus(phydev);\n\tret = __bcm_phy_modify_exp(phydev, reg, mask, set);\n\tphy_unlock_mdio_bus(phydev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(bcm_phy_modify_exp);\n\nint bcm54xx_auxctl_read(struct phy_device *phydev, u16 regnum)\n{\n\t \n\tphy_write(phydev, MII_BCM54XX_AUX_CTL, MII_BCM54XX_AUXCTL_SHDWSEL_MASK |\n\t\t  regnum << MII_BCM54XX_AUXCTL_SHDWSEL_READ_SHIFT);\n\treturn phy_read(phydev, MII_BCM54XX_AUX_CTL);\n}\nEXPORT_SYMBOL_GPL(bcm54xx_auxctl_read);\n\nint bcm54xx_auxctl_write(struct phy_device *phydev, u16 regnum, u16 val)\n{\n\treturn phy_write(phydev, MII_BCM54XX_AUX_CTL, regnum | val);\n}\nEXPORT_SYMBOL(bcm54xx_auxctl_write);\n\nint bcm_phy_write_misc(struct phy_device *phydev,\n\t\t       u16 reg, u16 chl, u16 val)\n{\n\tint rc;\n\tint tmp;\n\n\trc = phy_write(phydev, MII_BCM54XX_AUX_CTL,\n\t\t       MII_BCM54XX_AUXCTL_SHDWSEL_MISC);\n\tif (rc < 0)\n\t\treturn rc;\n\n\ttmp = phy_read(phydev, MII_BCM54XX_AUX_CTL);\n\ttmp |= MII_BCM54XX_AUXCTL_ACTL_SMDSP_ENA;\n\trc = phy_write(phydev, MII_BCM54XX_AUX_CTL, tmp);\n\tif (rc < 0)\n\t\treturn rc;\n\n\ttmp = (chl * MII_BCM_CHANNEL_WIDTH) | reg;\n\trc = bcm_phy_write_exp(phydev, tmp, val);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(bcm_phy_write_misc);\n\nint bcm_phy_read_misc(struct phy_device *phydev,\n\t\t      u16 reg, u16 chl)\n{\n\tint rc;\n\tint tmp;\n\n\trc = phy_write(phydev, MII_BCM54XX_AUX_CTL,\n\t\t       MII_BCM54XX_AUXCTL_SHDWSEL_MISC);\n\tif (rc < 0)\n\t\treturn rc;\n\n\ttmp = phy_read(phydev, MII_BCM54XX_AUX_CTL);\n\ttmp |= MII_BCM54XX_AUXCTL_ACTL_SMDSP_ENA;\n\trc = phy_write(phydev, MII_BCM54XX_AUX_CTL, tmp);\n\tif (rc < 0)\n\t\treturn rc;\n\n\ttmp = (chl * MII_BCM_CHANNEL_WIDTH) | reg;\n\trc = bcm_phy_read_exp(phydev, tmp);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(bcm_phy_read_misc);\n\nint bcm_phy_ack_intr(struct phy_device *phydev)\n{\n\tint reg;\n\n\t \n\treg = phy_read(phydev, MII_BCM54XX_ISR);\n\tif (reg < 0)\n\t\treturn reg;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(bcm_phy_ack_intr);\n\nint bcm_phy_config_intr(struct phy_device *phydev)\n{\n\tint reg, err;\n\n\treg = phy_read(phydev, MII_BCM54XX_ECR);\n\tif (reg < 0)\n\t\treturn reg;\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\terr = bcm_phy_ack_intr(phydev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treg &= ~MII_BCM54XX_ECR_IM;\n\t\terr = phy_write(phydev, MII_BCM54XX_ECR, reg);\n\t} else {\n\t\treg |= MII_BCM54XX_ECR_IM;\n\t\terr = phy_write(phydev, MII_BCM54XX_ECR, reg);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = bcm_phy_ack_intr(phydev);\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(bcm_phy_config_intr);\n\nirqreturn_t bcm_phy_handle_interrupt(struct phy_device *phydev)\n{\n\tint irq_status, irq_mask;\n\n\tirq_status = phy_read(phydev, MII_BCM54XX_ISR);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tirq_mask = phy_read(phydev, MII_BCM54XX_IMR);\n\tif (irq_mask < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\tirq_mask = ~irq_mask;\n\n\tif (!(irq_status & irq_mask))\n\t\treturn IRQ_NONE;\n\n\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\nEXPORT_SYMBOL_GPL(bcm_phy_handle_interrupt);\n\nint bcm_phy_read_shadow(struct phy_device *phydev, u16 shadow)\n{\n\tphy_write(phydev, MII_BCM54XX_SHD, MII_BCM54XX_SHD_VAL(shadow));\n\treturn MII_BCM54XX_SHD_DATA(phy_read(phydev, MII_BCM54XX_SHD));\n}\nEXPORT_SYMBOL_GPL(bcm_phy_read_shadow);\n\nint bcm_phy_write_shadow(struct phy_device *phydev, u16 shadow,\n\t\t\t u16 val)\n{\n\treturn phy_write(phydev, MII_BCM54XX_SHD,\n\t\t\t MII_BCM54XX_SHD_WRITE |\n\t\t\t MII_BCM54XX_SHD_VAL(shadow) |\n\t\t\t MII_BCM54XX_SHD_DATA(val));\n}\nEXPORT_SYMBOL_GPL(bcm_phy_write_shadow);\n\nint __bcm_phy_read_rdb(struct phy_device *phydev, u16 rdb)\n{\n\tint val;\n\n\tval = __phy_write(phydev, MII_BCM54XX_RDB_ADDR, rdb);\n\tif (val < 0)\n\t\treturn val;\n\n\treturn __phy_read(phydev, MII_BCM54XX_RDB_DATA);\n}\nEXPORT_SYMBOL_GPL(__bcm_phy_read_rdb);\n\nint bcm_phy_read_rdb(struct phy_device *phydev, u16 rdb)\n{\n\tint ret;\n\n\tphy_lock_mdio_bus(phydev);\n\tret = __bcm_phy_read_rdb(phydev, rdb);\n\tphy_unlock_mdio_bus(phydev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(bcm_phy_read_rdb);\n\nint __bcm_phy_write_rdb(struct phy_device *phydev, u16 rdb, u16 val)\n{\n\tint ret;\n\n\tret = __phy_write(phydev, MII_BCM54XX_RDB_ADDR, rdb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn __phy_write(phydev, MII_BCM54XX_RDB_DATA, val);\n}\nEXPORT_SYMBOL_GPL(__bcm_phy_write_rdb);\n\nint bcm_phy_write_rdb(struct phy_device *phydev, u16 rdb, u16 val)\n{\n\tint ret;\n\n\tphy_lock_mdio_bus(phydev);\n\tret = __bcm_phy_write_rdb(phydev, rdb, val);\n\tphy_unlock_mdio_bus(phydev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(bcm_phy_write_rdb);\n\nint __bcm_phy_modify_rdb(struct phy_device *phydev, u16 rdb, u16 mask, u16 set)\n{\n\tint new, ret;\n\n\tret = __phy_write(phydev, MII_BCM54XX_RDB_ADDR, rdb);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = __phy_read(phydev, MII_BCM54XX_RDB_DATA);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnew = (ret & ~mask) | set;\n\tif (new == ret)\n\t\treturn 0;\n\n\treturn __phy_write(phydev, MII_BCM54XX_RDB_DATA, new);\n}\nEXPORT_SYMBOL_GPL(__bcm_phy_modify_rdb);\n\nint bcm_phy_modify_rdb(struct phy_device *phydev, u16 rdb, u16 mask, u16 set)\n{\n\tint ret;\n\n\tphy_lock_mdio_bus(phydev);\n\tret = __bcm_phy_modify_rdb(phydev, rdb, mask, set);\n\tphy_unlock_mdio_bus(phydev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(bcm_phy_modify_rdb);\n\nint bcm_phy_enable_apd(struct phy_device *phydev, bool dll_pwr_down)\n{\n\tint val;\n\n\tif (dll_pwr_down) {\n\t\tval = bcm_phy_read_shadow(phydev, BCM54XX_SHD_SCR3);\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tval |= BCM54XX_SHD_SCR3_DLLAPD_DIS;\n\t\tbcm_phy_write_shadow(phydev, BCM54XX_SHD_SCR3, val);\n\t}\n\n\tval = bcm_phy_read_shadow(phydev, BCM54XX_SHD_APD);\n\tif (val < 0)\n\t\treturn val;\n\n\t \n\tval &= BCM_APD_CLR_MASK;\n\n\tif (phydev->autoneg == AUTONEG_ENABLE)\n\t\tval |= BCM54XX_SHD_APD_EN;\n\telse\n\t\tval |= BCM_NO_ANEG_APD_EN;\n\n\t \n\tval |= BCM_APD_SINGLELP_EN;\n\n\t \n\treturn bcm_phy_write_shadow(phydev, BCM54XX_SHD_APD, val);\n}\nEXPORT_SYMBOL_GPL(bcm_phy_enable_apd);\n\nint bcm_phy_set_eee(struct phy_device *phydev, bool enable)\n{\n\tint val, mask = 0;\n\n\t \n\tval = phy_read_mmd(phydev, MDIO_MMD_AN, BRCM_CL45VEN_EEE_CONTROL);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (enable)\n\t\tval |= LPI_FEATURE_EN | LPI_FEATURE_EN_DIG1000X;\n\telse\n\t\tval &= ~(LPI_FEATURE_EN | LPI_FEATURE_EN_DIG1000X);\n\n\tphy_write_mmd(phydev, MDIO_MMD_AN, BRCM_CL45VEN_EEE_CONTROL, (u32)val);\n\n\t \n\tval = phy_read_mmd(phydev, MDIO_MMD_AN, BCM_CL45VEN_EEE_ADV);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (linkmode_test_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,\n\t\t\t      phydev->supported))\n\t\tmask |= MDIO_EEE_1000T;\n\tif (linkmode_test_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT,\n\t\t\t      phydev->supported))\n\t\tmask |= MDIO_EEE_100TX;\n\n\tif (enable)\n\t\tval |= mask;\n\telse\n\t\tval &= ~mask;\n\n\tphy_write_mmd(phydev, MDIO_MMD_AN, BCM_CL45VEN_EEE_ADV, (u32)val);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(bcm_phy_set_eee);\n\nint bcm_phy_downshift_get(struct phy_device *phydev, u8 *count)\n{\n\tint val;\n\n\tval = bcm54xx_auxctl_read(phydev, MII_BCM54XX_AUXCTL_SHDWSEL_MISC);\n\tif (val < 0)\n\t\treturn val;\n\n\t \n\tif (!(val & MII_BCM54XX_AUXCTL_SHDWSEL_MISC_WIRESPEED_EN)) {\n\t\t*count = DOWNSHIFT_DEV_DISABLE;\n\t\treturn 0;\n\t}\n\n\tval = bcm_phy_read_shadow(phydev, BCM54XX_SHD_SCR2);\n\tif (val < 0)\n\t\treturn val;\n\n\t \n\tif (val & BCM54XX_SHD_SCR2_WSPD_RTRY_DIS) {\n\t\t*count = 1;\n\t} else {\n\t\t \n\t\tval >>= BCM54XX_SHD_SCR2_WSPD_RTRY_LMT_SHIFT;\n\t\tval &= BCM54XX_SHD_SCR2_WSPD_RTRY_LMT_MASK;\n\t\t*count = val + BCM54XX_SHD_SCR2_WSPD_RTRY_LMT_OFFSET;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(bcm_phy_downshift_get);\n\nint bcm_phy_downshift_set(struct phy_device *phydev, u8 count)\n{\n\tint val = 0, ret = 0;\n\n\t \n\tif (count - BCM54XX_SHD_SCR2_WSPD_RTRY_LMT_OFFSET >\n\t    BCM54XX_SHD_SCR2_WSPD_RTRY_LMT_MASK &&\n\t    count != DOWNSHIFT_DEV_DEFAULT_COUNT) {\n\t\treturn -ERANGE;\n\t}\n\n\tval = bcm54xx_auxctl_read(phydev, MII_BCM54XX_AUXCTL_SHDWSEL_MISC);\n\tif (val < 0)\n\t\treturn val;\n\n\t \n\tval |= MII_BCM54XX_AUXCTL_MISC_WREN;\n\n\tif (count == DOWNSHIFT_DEV_DISABLE) {\n\t\tval &= ~MII_BCM54XX_AUXCTL_SHDWSEL_MISC_WIRESPEED_EN;\n\t\treturn bcm54xx_auxctl_write(phydev,\n\t\t\t\t\t    MII_BCM54XX_AUXCTL_SHDWSEL_MISC,\n\t\t\t\t\t    val);\n\t} else {\n\t\tval |= MII_BCM54XX_AUXCTL_SHDWSEL_MISC_WIRESPEED_EN;\n\t\tret = bcm54xx_auxctl_write(phydev,\n\t\t\t\t\t   MII_BCM54XX_AUXCTL_SHDWSEL_MISC,\n\t\t\t\t\t   val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tval = bcm_phy_read_shadow(phydev, BCM54XX_SHD_SCR2);\n\tval &= ~(BCM54XX_SHD_SCR2_WSPD_RTRY_LMT_MASK <<\n\t\t BCM54XX_SHD_SCR2_WSPD_RTRY_LMT_SHIFT |\n\t\t BCM54XX_SHD_SCR2_WSPD_RTRY_DIS);\n\n\tswitch (count) {\n\tcase 1:\n\t\tval |= BCM54XX_SHD_SCR2_WSPD_RTRY_DIS;\n\t\tbreak;\n\tcase DOWNSHIFT_DEV_DEFAULT_COUNT:\n\t\tval |= 1 << BCM54XX_SHD_SCR2_WSPD_RTRY_LMT_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\tval |= (count - BCM54XX_SHD_SCR2_WSPD_RTRY_LMT_OFFSET) <<\n\t\t\tBCM54XX_SHD_SCR2_WSPD_RTRY_LMT_SHIFT;\n\t\tbreak;\n\t}\n\n\treturn bcm_phy_write_shadow(phydev, BCM54XX_SHD_SCR2, val);\n}\nEXPORT_SYMBOL_GPL(bcm_phy_downshift_set);\n\nstruct bcm_phy_hw_stat {\n\tconst char *string;\n\tint devad;\n\tu16 reg;\n\tu8 shift;\n\tu8 bits;\n};\n\n \nstatic const struct bcm_phy_hw_stat bcm_phy_hw_stats[] = {\n\t{ \"phy_receive_errors\", -1, MII_BRCM_CORE_BASE12, 0, 16 },\n\t{ \"phy_serdes_ber_errors\", -1, MII_BRCM_CORE_BASE13, 8, 8 },\n\t{ \"phy_false_carrier_sense_errors\", -1, MII_BRCM_CORE_BASE13, 0, 8 },\n\t{ \"phy_local_rcvr_nok\", -1, MII_BRCM_CORE_BASE14, 8, 8 },\n\t{ \"phy_remote_rcv_nok\", -1, MII_BRCM_CORE_BASE14, 0, 8 },\n\t{ \"phy_lpi_count\", MDIO_MMD_AN, BRCM_CL45VEN_EEE_LPI_CNT, 0, 16 },\n};\n\nint bcm_phy_get_sset_count(struct phy_device *phydev)\n{\n\treturn ARRAY_SIZE(bcm_phy_hw_stats);\n}\nEXPORT_SYMBOL_GPL(bcm_phy_get_sset_count);\n\nvoid bcm_phy_get_strings(struct phy_device *phydev, u8 *data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bcm_phy_hw_stats); i++)\n\t\tstrscpy(data + i * ETH_GSTRING_LEN,\n\t\t\tbcm_phy_hw_stats[i].string, ETH_GSTRING_LEN);\n}\nEXPORT_SYMBOL_GPL(bcm_phy_get_strings);\n\n \nstatic u64 bcm_phy_get_stat(struct phy_device *phydev, u64 *shadow,\n\t\t\t    unsigned int i)\n{\n\tstruct bcm_phy_hw_stat stat = bcm_phy_hw_stats[i];\n\tint val;\n\tu64 ret;\n\n\tif (stat.devad < 0)\n\t\tval = phy_read(phydev, stat.reg);\n\telse\n\t\tval = phy_read_mmd(phydev, stat.devad, stat.reg);\n\tif (val < 0) {\n\t\tret = U64_MAX;\n\t} else {\n\t\tval >>= stat.shift;\n\t\tval = val & ((1 << stat.bits) - 1);\n\t\tshadow[i] += val;\n\t\tret = shadow[i];\n\t}\n\n\treturn ret;\n}\n\nvoid bcm_phy_get_stats(struct phy_device *phydev, u64 *shadow,\n\t\t       struct ethtool_stats *stats, u64 *data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(bcm_phy_hw_stats); i++)\n\t\tdata[i] = bcm_phy_get_stat(phydev, shadow, i);\n}\nEXPORT_SYMBOL_GPL(bcm_phy_get_stats);\n\nvoid bcm_phy_r_rc_cal_reset(struct phy_device *phydev)\n{\n\t \n\tbcm_phy_write_exp_sel(phydev, 0x00b0, 0x0010);\n\n\t \n\tbcm_phy_write_exp_sel(phydev, 0x00b0, 0x0000);\n}\nEXPORT_SYMBOL_GPL(bcm_phy_r_rc_cal_reset);\n\nint bcm_phy_28nm_a0b0_afe_config_init(struct phy_device *phydev)\n{\n\t \n\tbcm_phy_write_misc(phydev, PLL_PLLCTRL_1, 0x0048);\n\n\t \n\tbcm_phy_write_misc(phydev, PLL_PLLCTRL_2, 0x021b);\n\n\t \n\tbcm_phy_write_misc(phydev, PLL_PLLCTRL_4, 0x0e20);\n\n\t \n\tbcm_phy_write_misc(phydev, DSP_TAP10, 0x690b);\n\n\t \n\tphy_write(phydev, MII_BRCM_CORE_BASE1E, 0xd);\n\n\tbcm_phy_r_rc_cal_reset(phydev);\n\n\t \n\tbcm_phy_write_misc(phydev, AFE_RXCONFIG_0, 0xeb19);\n\n\t \n\tbcm_phy_write_misc(phydev, AFE_RXCONFIG_1, 0x9a3f);\n\n\t \n\tbcm_phy_write_misc(phydev, AFE_RX_LP_COUNTER, 0x7fc0);\n\n\t \n\tbcm_phy_write_misc(phydev, AFE_HPF_TRIM_OTHERS, 0x000b);\n\n\t \n\tbcm_phy_write_misc(phydev, AFE_TX_CONFIG, 0x0800);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(bcm_phy_28nm_a0b0_afe_config_init);\n\nint bcm_phy_enable_jumbo(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = bcm54xx_auxctl_read(phydev, MII_BCM54XX_AUXCTL_SHDWSEL_AUXCTL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = bcm54xx_auxctl_write(phydev, MII_BCM54XX_AUXCTL_SHDWSEL_AUXCTL,\n\t\t\t\t   ret | MII_BCM54XX_AUXCTL_ACTL_EXT_PKT_LEN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn phy_set_bits(phydev, MII_BCM54XX_ECR, MII_BCM54XX_ECR_FIFOE);\n}\nEXPORT_SYMBOL_GPL(bcm_phy_enable_jumbo);\n\nstatic int __bcm_phy_enable_rdb_access(struct phy_device *phydev)\n{\n\treturn __bcm_phy_write_exp(phydev, BCM54XX_EXP_REG7E, 0);\n}\n\nstatic int __bcm_phy_enable_legacy_access(struct phy_device *phydev)\n{\n\treturn __bcm_phy_write_rdb(phydev, BCM54XX_RDB_REG0087,\n\t\t\t\t   BCM54XX_ACCESS_MODE_LEGACY_EN);\n}\n\nstatic int _bcm_phy_cable_test_start(struct phy_device *phydev, bool is_rdb)\n{\n\tu16 mask, set;\n\tint ret;\n\n\t \n\tphy_write(phydev, MII_BMCR, BMCR_ANENABLE);\n\tphy_write(phydev, MII_ADVERTISE, ADVERTISE_CSMA);\n\tphy_write(phydev, MII_CTRL1000, 0);\n\n\tphy_lock_mdio_bus(phydev);\n\tif (is_rdb) {\n\t\tret = __bcm_phy_enable_legacy_access(phydev);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tmask = BCM54XX_ECD_CTRL_CROSS_SHORT_DIS | BCM54XX_ECD_CTRL_UNIT_MASK;\n\tset = BCM54XX_ECD_CTRL_RUN | BCM54XX_ECD_CTRL_BREAK_LINK |\n\t      FIELD_PREP(BCM54XX_ECD_CTRL_UNIT_MASK,\n\t\t\t BCM54XX_ECD_CTRL_UNIT_CM);\n\n\tret = __bcm_phy_modify_exp(phydev, BCM54XX_EXP_ECD_CTRL, mask, set);\n\nout:\n\t \n\tif (is_rdb)\n\t\tret = __bcm_phy_enable_rdb_access(phydev) ? : ret;\n\n\tphy_unlock_mdio_bus(phydev);\n\n\treturn ret;\n}\n\nstatic int bcm_phy_cable_test_report_trans(int result)\n{\n\tswitch (result) {\n\tcase BCM54XX_ECD_FAULT_TYPE_OK:\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_OK;\n\tcase BCM54XX_ECD_FAULT_TYPE_OPEN:\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_OPEN;\n\tcase BCM54XX_ECD_FAULT_TYPE_SAME_SHORT:\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_SAME_SHORT;\n\tcase BCM54XX_ECD_FAULT_TYPE_CROSS_SHORT:\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_CROSS_SHORT;\n\tcase BCM54XX_ECD_FAULT_TYPE_INVALID:\n\tcase BCM54XX_ECD_FAULT_TYPE_BUSY:\n\tdefault:\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_UNSPEC;\n\t}\n}\n\nstatic bool bcm_phy_distance_valid(int result)\n{\n\tswitch (result) {\n\tcase BCM54XX_ECD_FAULT_TYPE_OPEN:\n\tcase BCM54XX_ECD_FAULT_TYPE_SAME_SHORT:\n\tcase BCM54XX_ECD_FAULT_TYPE_CROSS_SHORT:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int bcm_phy_report_length(struct phy_device *phydev, int pair)\n{\n\tint val;\n\n\tval = __bcm_phy_read_exp(phydev,\n\t\t\t\t BCM54XX_EXP_ECD_PAIR_A_LENGTH_RESULTS + pair);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (val == BCM54XX_ECD_LENGTH_RESULTS_INVALID)\n\t\treturn 0;\n\n\tethnl_cable_test_fault_length(phydev, pair, val);\n\n\treturn 0;\n}\n\nstatic int _bcm_phy_cable_test_get_status(struct phy_device *phydev,\n\t\t\t\t\t  bool *finished, bool is_rdb)\n{\n\tint pair_a, pair_b, pair_c, pair_d, ret;\n\n\t*finished = false;\n\n\tphy_lock_mdio_bus(phydev);\n\n\tif (is_rdb) {\n\t\tret = __bcm_phy_enable_legacy_access(phydev);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = __bcm_phy_read_exp(phydev, BCM54XX_EXP_ECD_CTRL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (ret & BCM54XX_ECD_CTRL_IN_PROGRESS) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = __bcm_phy_read_exp(phydev, BCM54XX_EXP_ECD_FAULT_TYPE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tpair_a = FIELD_GET(BCM54XX_ECD_FAULT_TYPE_PAIR_A_MASK, ret);\n\tpair_b = FIELD_GET(BCM54XX_ECD_FAULT_TYPE_PAIR_B_MASK, ret);\n\tpair_c = FIELD_GET(BCM54XX_ECD_FAULT_TYPE_PAIR_C_MASK, ret);\n\tpair_d = FIELD_GET(BCM54XX_ECD_FAULT_TYPE_PAIR_D_MASK, ret);\n\n\tethnl_cable_test_result(phydev, ETHTOOL_A_CABLE_PAIR_A,\n\t\t\t\tbcm_phy_cable_test_report_trans(pair_a));\n\tethnl_cable_test_result(phydev, ETHTOOL_A_CABLE_PAIR_B,\n\t\t\t\tbcm_phy_cable_test_report_trans(pair_b));\n\tethnl_cable_test_result(phydev, ETHTOOL_A_CABLE_PAIR_C,\n\t\t\t\tbcm_phy_cable_test_report_trans(pair_c));\n\tethnl_cable_test_result(phydev, ETHTOOL_A_CABLE_PAIR_D,\n\t\t\t\tbcm_phy_cable_test_report_trans(pair_d));\n\n\tif (bcm_phy_distance_valid(pair_a))\n\t\tbcm_phy_report_length(phydev, 0);\n\tif (bcm_phy_distance_valid(pair_b))\n\t\tbcm_phy_report_length(phydev, 1);\n\tif (bcm_phy_distance_valid(pair_c))\n\t\tbcm_phy_report_length(phydev, 2);\n\tif (bcm_phy_distance_valid(pair_d))\n\t\tbcm_phy_report_length(phydev, 3);\n\n\tret = 0;\n\t*finished = true;\nout:\n\t \n\tif (is_rdb)\n\t\tret = __bcm_phy_enable_rdb_access(phydev) ? : ret;\n\n\tphy_unlock_mdio_bus(phydev);\n\n\treturn ret;\n}\n\nint bcm_phy_cable_test_start(struct phy_device *phydev)\n{\n\treturn _bcm_phy_cable_test_start(phydev, false);\n}\nEXPORT_SYMBOL_GPL(bcm_phy_cable_test_start);\n\nint bcm_phy_cable_test_get_status(struct phy_device *phydev, bool *finished)\n{\n\treturn _bcm_phy_cable_test_get_status(phydev, finished, false);\n}\nEXPORT_SYMBOL_GPL(bcm_phy_cable_test_get_status);\n\n \nint bcm_phy_cable_test_start_rdb(struct phy_device *phydev)\n{\n\treturn _bcm_phy_cable_test_start(phydev, true);\n}\nEXPORT_SYMBOL_GPL(bcm_phy_cable_test_start_rdb);\n\nint bcm_phy_cable_test_get_status_rdb(struct phy_device *phydev,\n\t\t\t\t      bool *finished)\n{\n\treturn _bcm_phy_cable_test_get_status(phydev, finished, true);\n}\nEXPORT_SYMBOL_GPL(bcm_phy_cable_test_get_status_rdb);\n\n#define BCM54XX_WOL_SUPPORTED_MASK\t(WAKE_UCAST | \\\n\t\t\t\t\t WAKE_MCAST | \\\n\t\t\t\t\t WAKE_BCAST | \\\n\t\t\t\t\t WAKE_MAGIC | \\\n\t\t\t\t\t WAKE_MAGICSECURE)\n\nint bcm_phy_set_wol(struct phy_device *phydev, struct ethtool_wolinfo *wol)\n{\n\tstruct net_device *ndev = phydev->attached_dev;\n\tu8 da[ETH_ALEN], mask[ETH_ALEN];\n\tunsigned int i;\n\tu16 ctl;\n\tint ret;\n\n\t \n\tif (wol->wolopts & ~BCM54XX_WOL_SUPPORTED_MASK)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tBUILD_BUG_ON(sizeof(wol->sopass) != ETH_ALEN);\n\n\t \n\tret = bcm_phy_read_exp(phydev, BCM54XX_WOL_INT_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = bcm_phy_read_exp(phydev, BCM54XX_WOL_MAIN_CTL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tctl = ret;\n\n\tif (!wol->wolopts) {\n\t\tif (phy_interrupt_is_valid(phydev))\n\t\t\tdisable_irq_wake(phydev->irq);\n\n\t\t \n\t\tret = bcm_phy_write_exp(phydev, BCM54XX_WOL_INT_MASK,\n\t\t\t\t\tBCM54XX_WOL_ALL_INTRS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tctl &= ~BCM54XX_WOL_EN;\n\n\t\treturn bcm_phy_write_exp(phydev, BCM54XX_WOL_MAIN_CTL, ctl);\n\t}\n\n\t \n\tctl &= ~(BCM54XX_WOL_MODE_MASK << BCM54XX_WOL_MODE_SHIFT);\n\tctl &= ~(BCM54XX_WOL_MASK_MODE_MASK << BCM54XX_WOL_MASK_MODE_SHIFT);\n\tctl &= ~BCM54XX_WOL_DIR_PKT_EN;\n\tctl &= ~(BCM54XX_WOL_SECKEY_OPT_MASK << BCM54XX_WOL_SECKEY_OPT_SHIFT);\n\n\t \n\tmemset(mask, 0, sizeof(mask));\n\n\tif (wol->wolopts & WAKE_MCAST) {\n\t\tmemset(da, 0, sizeof(da));\n\t\tmemset(mask, 0xff, sizeof(mask));\n\t\tda[0] = 0x01;\n\t\tmask[0] = ~da[0];\n\t} else {\n\t\tif (wol->wolopts & WAKE_UCAST) {\n\t\t\tether_addr_copy(da, ndev->dev_addr);\n\t\t} else if (wol->wolopts & WAKE_BCAST) {\n\t\t\teth_broadcast_addr(da);\n\t\t} else if (wol->wolopts & WAKE_MAGICSECURE) {\n\t\t\tether_addr_copy(da, wol->sopass);\n\t\t} else if (wol->wolopts & WAKE_MAGIC) {\n\t\t\tmemset(da, 0, sizeof(da));\n\t\t\tmemset(mask, 0xff, sizeof(mask));\n\t\t}\n\t}\n\n\tfor (i = 0; i < ETH_ALEN / 2; i++) {\n\t\tif (wol->wolopts & (WAKE_MAGIC | WAKE_MAGICSECURE)) {\n\t\t\tret = bcm_phy_write_exp(phydev,\n\t\t\t\t\t\tBCM54XX_WOL_MPD_DATA1(2 - i),\n\t\t\t\t\t\tndev->dev_addr[i * 2] << 8 |\n\t\t\t\t\t\tndev->dev_addr[i * 2 + 1]);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tret = bcm_phy_write_exp(phydev, BCM54XX_WOL_MPD_DATA2(2 - i),\n\t\t\t\t\tda[i * 2] << 8 | da[i * 2 + 1]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = bcm_phy_write_exp(phydev, BCM54XX_WOL_MASK(2 - i),\n\t\t\t\t\tmask[i * 2] << 8 | mask[i * 2 + 1]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (wol->wolopts & WAKE_MAGICSECURE) {\n\t\tctl |= BCM54XX_WOL_SECKEY_OPT_6B <<\n\t\t       BCM54XX_WOL_SECKEY_OPT_SHIFT;\n\t\tctl |= BCM54XX_WOL_MODE_SINGLE_MPDSEC << BCM54XX_WOL_MODE_SHIFT;\n\t\tctl |= BCM54XX_WOL_MASK_MODE_DA_FF <<\n\t\t       BCM54XX_WOL_MASK_MODE_SHIFT;\n\t} else {\n\t\tif (wol->wolopts & WAKE_MAGIC)\n\t\t\tctl |= BCM54XX_WOL_MODE_SINGLE_MPD;\n\t\telse\n\t\t\tctl |= BCM54XX_WOL_DIR_PKT_EN;\n\t\tctl |= BCM54XX_WOL_MASK_MODE_DA_ONLY <<\n\t\t       BCM54XX_WOL_MASK_MODE_SHIFT;\n\t}\n\n\t \n\tctl |= BCM54XX_WOL_EN | BCM54XX_WOL_CRC_CHK;\n\n\tret = bcm_phy_write_exp(phydev, BCM54XX_WOL_MAIN_CTL, ctl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = bcm_phy_read_exp(phydev, BCM54XX_TOP_MISC_LED_CTL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret |= BCM54XX_LED4_SEL_INTR;\n\tret = bcm_phy_write_exp(phydev, BCM54XX_TOP_MISC_LED_CTL, ret);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = bcm_phy_write_exp(phydev, BCM54XX_WOL_INT_MASK, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (phy_interrupt_is_valid(phydev))\n\t\tenable_irq_wake(phydev->irq);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(bcm_phy_set_wol);\n\nvoid bcm_phy_get_wol(struct phy_device *phydev, struct ethtool_wolinfo *wol)\n{\n\tstruct net_device *ndev = phydev->attached_dev;\n\tu8 da[ETH_ALEN];\n\tunsigned int i;\n\tint ret;\n\tu16 ctl;\n\n\twol->supported = BCM54XX_WOL_SUPPORTED_MASK;\n\twol->wolopts = 0;\n\n\tret = bcm_phy_read_exp(phydev, BCM54XX_WOL_MAIN_CTL);\n\tif (ret < 0)\n\t\treturn;\n\n\tctl = ret;\n\n\tif (!(ctl & BCM54XX_WOL_EN))\n\t\treturn;\n\n\tfor (i = 0; i < sizeof(da) / 2; i++) {\n\t\tret = bcm_phy_read_exp(phydev,\n\t\t\t\t       BCM54XX_WOL_MPD_DATA2(2 - i));\n\t\tif (ret < 0)\n\t\t\treturn;\n\n\t\tda[i * 2] = ret >> 8;\n\t\tda[i * 2 + 1] = ret & 0xff;\n\t}\n\n\tif (ctl & BCM54XX_WOL_DIR_PKT_EN) {\n\t\tif (is_broadcast_ether_addr(da))\n\t\t\twol->wolopts |= WAKE_BCAST;\n\t\telse if (is_multicast_ether_addr(da))\n\t\t\twol->wolopts |= WAKE_MCAST;\n\t\telse if (ether_addr_equal(da, ndev->dev_addr))\n\t\t\twol->wolopts |= WAKE_UCAST;\n\t} else {\n\t\tctl = (ctl >> BCM54XX_WOL_MODE_SHIFT) & BCM54XX_WOL_MODE_MASK;\n\t\tswitch (ctl) {\n\t\tcase BCM54XX_WOL_MODE_SINGLE_MPD:\n\t\t\twol->wolopts |= WAKE_MAGIC;\n\t\t\tbreak;\n\t\tcase BCM54XX_WOL_MODE_SINGLE_MPDSEC:\n\t\t\twol->wolopts |= WAKE_MAGICSECURE;\n\t\t\tmemcpy(wol->sopass, da, sizeof(da));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(bcm_phy_get_wol);\n\nirqreturn_t bcm_phy_wol_isr(int irq, void *dev_id)\n{\n\treturn IRQ_HANDLED;\n}\nEXPORT_SYMBOL_GPL(bcm_phy_wol_isr);\n\nint bcm_phy_led_brightness_set(struct phy_device *phydev,\n\t\t\t       u8 index, enum led_brightness value)\n{\n\tu8 led_num;\n\tint ret;\n\tu16 reg;\n\n\tif (index >= 4)\n\t\treturn -EINVAL;\n\n\t \n\tled_num = index % 2;\n\treg = index >= 2 ? BCM54XX_SHD_LEDS2 : BCM54XX_SHD_LEDS1;\n\n\tret = bcm_phy_read_shadow(phydev, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret &= ~(BCM_LED_SRC_MASK << BCM54XX_SHD_LEDS_SHIFT(led_num));\n\tif (value == LED_OFF)\n\t\tret |= BCM_LED_SRC_OFF << BCM54XX_SHD_LEDS_SHIFT(led_num);\n\telse\n\t\tret |= BCM_LED_SRC_ON << BCM54XX_SHD_LEDS_SHIFT(led_num);\n\treturn bcm_phy_write_shadow(phydev, reg, ret);\n}\nEXPORT_SYMBOL_GPL(bcm_phy_led_brightness_set);\n\nMODULE_DESCRIPTION(\"Broadcom PHY Library\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Broadcom Corporation\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}