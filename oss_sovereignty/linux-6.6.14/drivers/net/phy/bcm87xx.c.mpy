{
  "module_name": "bcm87xx.c",
  "hash_id": "27a28ac5946992450dda8c5311ab5b09e86781dd9051071f1f921f2bcd05a533",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/bcm87xx.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/phy.h>\n#include <linux/of.h>\n\n#define PHY_ID_BCM8706\t0x0143bdc1\n#define PHY_ID_BCM8727\t0x0143bff0\n\n#define BCM87XX_PMD_RX_SIGNAL_DETECT\t0x000a\n#define BCM87XX_10GBASER_PCS_STATUS\t0x0020\n#define BCM87XX_XGXS_LANE_STATUS\t0x0018\n\n#define BCM87XX_LASI_CONTROL\t\t0x9002\n#define BCM87XX_LASI_STATUS\t\t0x9005\n\n#if IS_ENABLED(CONFIG_OF_MDIO)\n \nstatic int bcm87xx_of_reg_init(struct phy_device *phydev)\n{\n\tconst __be32 *paddr;\n\tconst __be32 *paddr_end;\n\tint len, ret;\n\n\tif (!phydev->mdio.dev.of_node)\n\t\treturn 0;\n\n\tpaddr = of_get_property(phydev->mdio.dev.of_node,\n\t\t\t\t\"broadcom,c45-reg-init\", &len);\n\tif (!paddr)\n\t\treturn 0;\n\n\tpaddr_end = paddr + (len /= sizeof(*paddr));\n\n\tret = 0;\n\n\twhile (paddr + 3 < paddr_end) {\n\t\tu16 devid\t= be32_to_cpup(paddr++);\n\t\tu16 reg\t\t= be32_to_cpup(paddr++);\n\t\tu16 mask\t= be32_to_cpup(paddr++);\n\t\tu16 val_bits\t= be32_to_cpup(paddr++);\n\t\tint val = 0;\n\n\t\tif (mask) {\n\t\t\tval = phy_read_mmd(phydev, devid, reg);\n\t\t\tif (val < 0) {\n\t\t\t\tret = val;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tval &= mask;\n\t\t}\n\t\tval |= val_bits;\n\n\t\tret = phy_write_mmd(phydev, devid, reg, val);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t}\nerr:\n\treturn ret;\n}\n#else\nstatic int bcm87xx_of_reg_init(struct phy_device *phydev)\n{\n\treturn 0;\n}\n#endif  \n\nstatic int bcm87xx_get_features(struct phy_device *phydev)\n{\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_10000baseR_FEC_BIT,\n\t\t\t phydev->supported);\n\treturn 0;\n}\n\nstatic int bcm87xx_config_init(struct phy_device *phydev)\n{\n\treturn bcm87xx_of_reg_init(phydev);\n}\n\nstatic int bcm87xx_config_aneg(struct phy_device *phydev)\n{\n\treturn -EINVAL;\n}\n\nstatic int bcm87xx_read_status(struct phy_device *phydev)\n{\n\tint rx_signal_detect;\n\tint pcs_status;\n\tint xgxs_lane_status;\n\n\trx_signal_detect = phy_read_mmd(phydev, MDIO_MMD_PMAPMD,\n\t\t\t\t\tBCM87XX_PMD_RX_SIGNAL_DETECT);\n\tif (rx_signal_detect < 0)\n\t\treturn rx_signal_detect;\n\n\tif ((rx_signal_detect & 1) == 0)\n\t\tgoto no_link;\n\n\tpcs_status = phy_read_mmd(phydev, MDIO_MMD_PCS,\n\t\t\t\t  BCM87XX_10GBASER_PCS_STATUS);\n\tif (pcs_status < 0)\n\t\treturn pcs_status;\n\n\tif ((pcs_status & 1) == 0)\n\t\tgoto no_link;\n\n\txgxs_lane_status = phy_read_mmd(phydev, MDIO_MMD_PHYXS,\n\t\t\t\t\tBCM87XX_XGXS_LANE_STATUS);\n\tif (xgxs_lane_status < 0)\n\t\treturn xgxs_lane_status;\n\n\tif ((xgxs_lane_status & 0x1000) == 0)\n\t\tgoto no_link;\n\n\tphydev->speed = 10000;\n\tphydev->link = 1;\n\tphydev->duplex = 1;\n\treturn 0;\n\nno_link:\n\tphydev->link = 0;\n\treturn 0;\n}\n\nstatic int bcm87xx_config_intr(struct phy_device *phydev)\n{\n\tint reg, err;\n\n\treg = phy_read_mmd(phydev, MDIO_MMD_PCS, BCM87XX_LASI_CONTROL);\n\n\tif (reg < 0)\n\t\treturn reg;\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\terr = phy_read_mmd(phydev, MDIO_MMD_PCS, BCM87XX_LASI_STATUS);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treg |= 1;\n\t\terr = phy_write_mmd(phydev, MDIO_MMD_PCS,\n\t\t\t\t    BCM87XX_LASI_CONTROL, reg);\n\t} else {\n\t\treg &= ~1;\n\t\terr = phy_write_mmd(phydev, MDIO_MMD_PCS,\n\t\t\t\t    BCM87XX_LASI_CONTROL, reg);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = phy_read_mmd(phydev, MDIO_MMD_PCS, BCM87XX_LASI_STATUS);\n\t}\n\n\treturn err;\n}\n\nstatic irqreturn_t bcm87xx_handle_interrupt(struct phy_device *phydev)\n{\n\tint irq_status;\n\n\tirq_status = phy_read(phydev, BCM87XX_LASI_STATUS);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (irq_status == 0)\n\t\treturn IRQ_NONE;\n\n\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bcm8706_match_phy_device(struct phy_device *phydev)\n{\n\treturn phydev->c45_ids.device_ids[4] == PHY_ID_BCM8706;\n}\n\nstatic int bcm8727_match_phy_device(struct phy_device *phydev)\n{\n\treturn phydev->c45_ids.device_ids[4] == PHY_ID_BCM8727;\n}\n\nstatic struct phy_driver bcm87xx_driver[] = {\n{\n\t.phy_id\t\t= PHY_ID_BCM8706,\n\t.phy_id_mask\t= 0xffffffff,\n\t.name\t\t= \"Broadcom BCM8706\",\n\t.get_features\t= bcm87xx_get_features,\n\t.config_init\t= bcm87xx_config_init,\n\t.config_aneg\t= bcm87xx_config_aneg,\n\t.read_status\t= bcm87xx_read_status,\n\t.config_intr\t= bcm87xx_config_intr,\n\t.handle_interrupt = bcm87xx_handle_interrupt,\n\t.match_phy_device = bcm8706_match_phy_device,\n}, {\n\t.phy_id\t\t= PHY_ID_BCM8727,\n\t.phy_id_mask\t= 0xffffffff,\n\t.name\t\t= \"Broadcom BCM8727\",\n\t.get_features\t= bcm87xx_get_features,\n\t.config_init\t= bcm87xx_config_init,\n\t.config_aneg\t= bcm87xx_config_aneg,\n\t.read_status\t= bcm87xx_read_status,\n\t.config_intr\t= bcm87xx_config_intr,\n\t.handle_interrupt = bcm87xx_handle_interrupt,\n\t.match_phy_device = bcm8727_match_phy_device,\n} };\n\nmodule_phy_driver(bcm87xx_driver);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}