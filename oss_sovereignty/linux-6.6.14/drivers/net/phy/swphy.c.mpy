{
  "module_name": "swphy.c",
  "hash_id": "9cd84c21a0b1e390e787db6d22362701750e6b0fd8229ab30a52b3765d9856c9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/swphy.c",
  "human_readable_source": "\n \n#include <linux/export.h>\n#include <linux/mii.h>\n#include <linux/phy.h>\n#include <linux/phy_fixed.h>\n\n#include \"swphy.h\"\n\n#define MII_REGS_NUM 29\n\nstruct swmii_regs {\n\tu16 bmsr;\n\tu16 lpa;\n\tu16 lpagb;\n\tu16 estat;\n};\n\nenum {\n\tSWMII_SPEED_10 = 0,\n\tSWMII_SPEED_100,\n\tSWMII_SPEED_1000,\n\tSWMII_DUPLEX_HALF = 0,\n\tSWMII_DUPLEX_FULL,\n};\n\n \nstatic const struct swmii_regs speed[] = {\n\t[SWMII_SPEED_10] = {\n\t\t.lpa   = LPA_10FULL | LPA_10HALF,\n\t},\n\t[SWMII_SPEED_100] = {\n\t\t.bmsr  = BMSR_100FULL | BMSR_100HALF,\n\t\t.lpa   = LPA_100FULL | LPA_100HALF,\n\t},\n\t[SWMII_SPEED_1000] = {\n\t\t.bmsr  = BMSR_ESTATEN,\n\t\t.lpagb = LPA_1000FULL | LPA_1000HALF,\n\t\t.estat = ESTATUS_1000_TFULL | ESTATUS_1000_THALF,\n\t},\n};\n\nstatic const struct swmii_regs duplex[] = {\n\t[SWMII_DUPLEX_HALF] = {\n\t\t.bmsr  = BMSR_ESTATEN | BMSR_100HALF,\n\t\t.lpa   = LPA_10HALF | LPA_100HALF,\n\t\t.lpagb = LPA_1000HALF,\n\t\t.estat = ESTATUS_1000_THALF,\n\t},\n\t[SWMII_DUPLEX_FULL] = {\n\t\t.bmsr  = BMSR_ESTATEN | BMSR_100FULL,\n\t\t.lpa   = LPA_10FULL | LPA_100FULL,\n\t\t.lpagb = LPA_1000FULL,\n\t\t.estat = ESTATUS_1000_TFULL,\n\t},\n};\n\nstatic int swphy_decode_speed(int speed)\n{\n\tswitch (speed) {\n\tcase 1000:\n\t\treturn SWMII_SPEED_1000;\n\tcase 100:\n\t\treturn SWMII_SPEED_100;\n\tcase 10:\n\t\treturn SWMII_SPEED_10;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nint swphy_validate_state(const struct fixed_phy_status *state)\n{\n\tint err;\n\n\tif (state->link) {\n\t\terr = swphy_decode_speed(state->speed);\n\t\tif (err < 0) {\n\t\t\tpr_warn(\"swphy: unknown speed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(swphy_validate_state);\n\n \nint swphy_read_reg(int reg, const struct fixed_phy_status *state)\n{\n\tint speed_index, duplex_index;\n\tu16 bmsr = BMSR_ANEGCAPABLE;\n\tu16 estat = 0;\n\tu16 lpagb = 0;\n\tu16 lpa = 0;\n\n\tif (reg > MII_REGS_NUM)\n\t\treturn -1;\n\n\tspeed_index = swphy_decode_speed(state->speed);\n\tif (WARN_ON(speed_index < 0))\n\t\treturn 0;\n\n\tduplex_index = state->duplex ? SWMII_DUPLEX_FULL : SWMII_DUPLEX_HALF;\n\n\tbmsr |= speed[speed_index].bmsr & duplex[duplex_index].bmsr;\n\testat |= speed[speed_index].estat & duplex[duplex_index].estat;\n\n\tif (state->link) {\n\t\tbmsr |= BMSR_LSTATUS | BMSR_ANEGCOMPLETE;\n\n\t\tlpa   |= speed[speed_index].lpa   & duplex[duplex_index].lpa;\n\t\tlpagb |= speed[speed_index].lpagb & duplex[duplex_index].lpagb;\n\n\t\tif (state->pause)\n\t\t\tlpa |= LPA_PAUSE_CAP;\n\n\t\tif (state->asym_pause)\n\t\t\tlpa |= LPA_PAUSE_ASYM;\n\t}\n\n\tswitch (reg) {\n\tcase MII_BMCR:\n\t\treturn BMCR_ANENABLE;\n\tcase MII_BMSR:\n\t\treturn bmsr;\n\tcase MII_PHYSID1:\n\tcase MII_PHYSID2:\n\t\treturn 0;\n\tcase MII_LPA:\n\t\treturn lpa;\n\tcase MII_STAT1000:\n\t\treturn lpagb;\n\tcase MII_ESTATUS:\n\t\treturn estat;\n\n\t \n\tcase MII_MMD_CTRL:\n\tcase MII_MMD_DATA:\n\t\treturn -1;\n\n\tdefault:\n\t\treturn 0xffff;\n\t}\n}\nEXPORT_SYMBOL_GPL(swphy_read_reg);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}