{
  "module_name": "phy_led_triggers.c",
  "hash_id": "4c92effdcc43289a0453f9e757f83b2d4ecda4b6ff9f5d95e65b0d1345b3bf52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/phy_led_triggers.c",
  "human_readable_source": "\n \n#include <linux/leds.h>\n#include <linux/phy.h>\n#include <linux/phy_led_triggers.h>\n#include <linux/netdevice.h>\n\nstatic struct phy_led_trigger *phy_speed_to_led_trigger(struct phy_device *phy,\n\t\t\t\t\t\t\tunsigned int speed)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < phy->phy_num_led_triggers; i++) {\n\t\tif (phy->phy_led_triggers[i].speed == speed)\n\t\t\treturn &phy->phy_led_triggers[i];\n\t}\n\treturn NULL;\n}\n\nstatic void phy_led_trigger_no_link(struct phy_device *phy)\n{\n\tif (phy->last_triggered) {\n\t\tled_trigger_event(&phy->last_triggered->trigger, LED_OFF);\n\t\tled_trigger_event(&phy->led_link_trigger->trigger, LED_OFF);\n\t\tphy->last_triggered = NULL;\n\t}\n}\n\nvoid phy_led_trigger_change_speed(struct phy_device *phy)\n{\n\tstruct phy_led_trigger *plt;\n\n\tif (!phy->link)\n\t\treturn phy_led_trigger_no_link(phy);\n\n\tif (phy->speed == 0)\n\t\treturn;\n\n\tplt = phy_speed_to_led_trigger(phy, phy->speed);\n\tif (!plt) {\n\t\tnetdev_alert(phy->attached_dev,\n\t\t\t     \"No phy led trigger registered for speed(%d)\\n\",\n\t\t\t     phy->speed);\n\t\treturn phy_led_trigger_no_link(phy);\n\t}\n\n\tif (plt != phy->last_triggered) {\n\t\tif (!phy->last_triggered)\n\t\t\tled_trigger_event(&phy->led_link_trigger->trigger,\n\t\t\t\t\t  LED_FULL);\n\t\telse\n\t\t\tled_trigger_event(&phy->last_triggered->trigger, LED_OFF);\n\n\t\tled_trigger_event(&plt->trigger, LED_FULL);\n\t\tphy->last_triggered = plt;\n\t}\n}\nEXPORT_SYMBOL_GPL(phy_led_trigger_change_speed);\n\nstatic void phy_led_trigger_format_name(struct phy_device *phy, char *buf,\n\t\t\t\t\tsize_t size, const char *suffix)\n{\n\tsnprintf(buf, size, PHY_ID_FMT \":%s\",\n\t\t phy->mdio.bus->id, phy->mdio.addr, suffix);\n}\n\nstatic int phy_led_trigger_register(struct phy_device *phy,\n\t\t\t\t    struct phy_led_trigger *plt,\n\t\t\t\t    unsigned int speed,\n\t\t\t\t    const char *suffix)\n{\n\tplt->speed = speed;\n\tphy_led_trigger_format_name(phy, plt->name, sizeof(plt->name), suffix);\n\tplt->trigger.name = plt->name;\n\n\treturn led_trigger_register(&plt->trigger);\n}\n\nstatic void phy_led_trigger_unregister(struct phy_led_trigger *plt)\n{\n\tled_trigger_unregister(&plt->trigger);\n}\n\nint phy_led_triggers_register(struct phy_device *phy)\n{\n\tint i, err;\n\tunsigned int speeds[50];\n\n\tphy->phy_num_led_triggers = phy_supported_speeds(phy, speeds,\n\t\t\t\t\t\t\t ARRAY_SIZE(speeds));\n\tif (!phy->phy_num_led_triggers)\n\t\treturn 0;\n\n\tphy->led_link_trigger = devm_kzalloc(&phy->mdio.dev,\n\t\t\t\t\t     sizeof(*phy->led_link_trigger),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!phy->led_link_trigger) {\n\t\terr = -ENOMEM;\n\t\tgoto out_clear;\n\t}\n\n\terr = phy_led_trigger_register(phy, phy->led_link_trigger, 0, \"link\");\n\tif (err)\n\t\tgoto out_free_link;\n\n\tphy->phy_led_triggers = devm_kcalloc(&phy->mdio.dev,\n\t\t\t\t\t    phy->phy_num_led_triggers,\n\t\t\t\t\t    sizeof(struct phy_led_trigger),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!phy->phy_led_triggers) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unreg_link;\n\t}\n\n\tfor (i = 0; i < phy->phy_num_led_triggers; i++) {\n\t\terr = phy_led_trigger_register(phy, &phy->phy_led_triggers[i],\n\t\t\t\t\t       speeds[i],\n\t\t\t\t\t       phy_speed_to_str(speeds[i]));\n\t\tif (err)\n\t\t\tgoto out_unreg;\n\t}\n\n\tphy->last_triggered = NULL;\n\tphy_led_trigger_change_speed(phy);\n\n\treturn 0;\nout_unreg:\n\twhile (i--)\n\t\tphy_led_trigger_unregister(&phy->phy_led_triggers[i]);\n\tdevm_kfree(&phy->mdio.dev, phy->phy_led_triggers);\nout_unreg_link:\n\tphy_led_trigger_unregister(phy->led_link_trigger);\nout_free_link:\n\tdevm_kfree(&phy->mdio.dev, phy->led_link_trigger);\n\tphy->led_link_trigger = NULL;\nout_clear:\n\tphy->phy_num_led_triggers = 0;\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(phy_led_triggers_register);\n\nvoid phy_led_triggers_unregister(struct phy_device *phy)\n{\n\tint i;\n\n\tfor (i = 0; i < phy->phy_num_led_triggers; i++)\n\t\tphy_led_trigger_unregister(&phy->phy_led_triggers[i]);\n\n\tif (phy->led_link_trigger)\n\t\tphy_led_trigger_unregister(phy->led_link_trigger);\n}\nEXPORT_SYMBOL_GPL(phy_led_triggers_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}