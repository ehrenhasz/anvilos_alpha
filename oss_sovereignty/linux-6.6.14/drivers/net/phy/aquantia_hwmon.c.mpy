{
  "module_name": "aquantia_hwmon.c",
  "hash_id": "5c964a07ce301be8207b563ba8e24498bfd789918a5af0b93ed94f767b8d41b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/aquantia_hwmon.c",
  "human_readable_source": "\n \n\n#include <linux/phy.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/hwmon.h>\n\n#include \"aquantia.h\"\n\n \n#define VEND1_THERMAL_PROV_HIGH_TEMP_FAIL\t0xc421\n#define VEND1_THERMAL_PROV_LOW_TEMP_FAIL\t0xc422\n#define VEND1_THERMAL_PROV_HIGH_TEMP_WARN\t0xc423\n#define VEND1_THERMAL_PROV_LOW_TEMP_WARN\t0xc424\n#define VEND1_THERMAL_STAT1\t\t\t0xc820\n#define VEND1_THERMAL_STAT2\t\t\t0xc821\n#define VEND1_THERMAL_STAT2_VALID\t\tBIT(0)\n#define VEND1_GENERAL_STAT1\t\t\t0xc830\n#define VEND1_GENERAL_STAT1_HIGH_TEMP_FAIL\tBIT(14)\n#define VEND1_GENERAL_STAT1_LOW_TEMP_FAIL\tBIT(13)\n#define VEND1_GENERAL_STAT1_HIGH_TEMP_WARN\tBIT(12)\n#define VEND1_GENERAL_STAT1_LOW_TEMP_WARN\tBIT(11)\n\n#if IS_REACHABLE(CONFIG_HWMON)\n\nstatic umode_t aqr_hwmon_is_visible(const void *data,\n\t\t\t\t    enum hwmon_sensor_types type,\n\t\t\t\t    u32 attr, int channel)\n{\n\tif (type != hwmon_temp)\n\t\treturn 0;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\tcase hwmon_temp_min_alarm:\n\tcase hwmon_temp_max_alarm:\n\tcase hwmon_temp_lcrit_alarm:\n\tcase hwmon_temp_crit_alarm:\n\t\treturn 0444;\n\tcase hwmon_temp_min:\n\tcase hwmon_temp_max:\n\tcase hwmon_temp_lcrit:\n\tcase hwmon_temp_crit:\n\t\treturn 0644;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int aqr_hwmon_get(struct phy_device *phydev, int reg, long *value)\n{\n\tint temp = phy_read_mmd(phydev, MDIO_MMD_VEND1, reg);\n\n\tif (temp < 0)\n\t\treturn temp;\n\n\t \n\t*value = (s16)temp * 1000 / 256;\n\n\treturn 0;\n}\n\nstatic int aqr_hwmon_set(struct phy_device *phydev, int reg, long value)\n{\n\tint temp;\n\n\tif (value >= 128000 || value < -128000)\n\t\treturn -ERANGE;\n\n\ttemp = value * 256 / 1000;\n\n\t \n\treturn phy_write_mmd(phydev, MDIO_MMD_VEND1, reg, (u16)temp);\n}\n\nstatic int aqr_hwmon_test_bit(struct phy_device *phydev, int reg, int bit)\n{\n\tint val = phy_read_mmd(phydev, MDIO_MMD_VEND1, reg);\n\n\tif (val < 0)\n\t\treturn val;\n\n\treturn !!(val & bit);\n}\n\nstatic int aqr_hwmon_status1(struct phy_device *phydev, int bit, long *value)\n{\n\tint val = aqr_hwmon_test_bit(phydev, VEND1_GENERAL_STAT1, bit);\n\n\tif (val < 0)\n\t\treturn val;\n\n\t*value = val;\n\n\treturn 0;\n}\n\nstatic int aqr_hwmon_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t  u32 attr, int channel, long *value)\n{\n\tstruct phy_device *phydev = dev_get_drvdata(dev);\n\tint reg;\n\n\tif (type != hwmon_temp)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\treg = aqr_hwmon_test_bit(phydev, VEND1_THERMAL_STAT2,\n\t\t\t\t\t VEND1_THERMAL_STAT2_VALID);\n\t\tif (reg < 0)\n\t\t\treturn reg;\n\t\tif (!reg)\n\t\t\treturn -EBUSY;\n\n\t\treturn aqr_hwmon_get(phydev, VEND1_THERMAL_STAT1, value);\n\n\tcase hwmon_temp_lcrit:\n\t\treturn aqr_hwmon_get(phydev, VEND1_THERMAL_PROV_LOW_TEMP_FAIL,\n\t\t\t\t     value);\n\tcase hwmon_temp_min:\n\t\treturn aqr_hwmon_get(phydev, VEND1_THERMAL_PROV_LOW_TEMP_WARN,\n\t\t\t\t     value);\n\tcase hwmon_temp_max:\n\t\treturn aqr_hwmon_get(phydev, VEND1_THERMAL_PROV_HIGH_TEMP_WARN,\n\t\t\t\t     value);\n\tcase hwmon_temp_crit:\n\t\treturn aqr_hwmon_get(phydev, VEND1_THERMAL_PROV_HIGH_TEMP_FAIL,\n\t\t\t\t     value);\n\tcase hwmon_temp_lcrit_alarm:\n\t\treturn aqr_hwmon_status1(phydev,\n\t\t\t\t\t VEND1_GENERAL_STAT1_LOW_TEMP_FAIL,\n\t\t\t\t\t value);\n\tcase hwmon_temp_min_alarm:\n\t\treturn aqr_hwmon_status1(phydev,\n\t\t\t\t\t VEND1_GENERAL_STAT1_LOW_TEMP_WARN,\n\t\t\t\t\t value);\n\tcase hwmon_temp_max_alarm:\n\t\treturn aqr_hwmon_status1(phydev,\n\t\t\t\t\t VEND1_GENERAL_STAT1_HIGH_TEMP_WARN,\n\t\t\t\t\t value);\n\tcase hwmon_temp_crit_alarm:\n\t\treturn aqr_hwmon_status1(phydev,\n\t\t\t\t\t VEND1_GENERAL_STAT1_HIGH_TEMP_FAIL,\n\t\t\t\t\t value);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int aqr_hwmon_write(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t   u32 attr, int channel, long value)\n{\n\tstruct phy_device *phydev = dev_get_drvdata(dev);\n\n\tif (type != hwmon_temp)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (attr) {\n\tcase hwmon_temp_lcrit:\n\t\treturn aqr_hwmon_set(phydev, VEND1_THERMAL_PROV_LOW_TEMP_FAIL,\n\t\t\t\t     value);\n\tcase hwmon_temp_min:\n\t\treturn aqr_hwmon_set(phydev, VEND1_THERMAL_PROV_LOW_TEMP_WARN,\n\t\t\t\t     value);\n\tcase hwmon_temp_max:\n\t\treturn aqr_hwmon_set(phydev, VEND1_THERMAL_PROV_HIGH_TEMP_WARN,\n\t\t\t\t     value);\n\tcase hwmon_temp_crit:\n\t\treturn aqr_hwmon_set(phydev, VEND1_THERMAL_PROV_HIGH_TEMP_FAIL,\n\t\t\t\t     value);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct hwmon_ops aqr_hwmon_ops = {\n\t.is_visible = aqr_hwmon_is_visible,\n\t.read = aqr_hwmon_read,\n\t.write = aqr_hwmon_write,\n};\n\nstatic u32 aqr_hwmon_chip_config[] = {\n\tHWMON_C_REGISTER_TZ,\n\t0,\n};\n\nstatic const struct hwmon_channel_info aqr_hwmon_chip = {\n\t.type = hwmon_chip,\n\t.config = aqr_hwmon_chip_config,\n};\n\nstatic u32 aqr_hwmon_temp_config[] = {\n\tHWMON_T_INPUT |\n\tHWMON_T_MAX | HWMON_T_MIN |\n\tHWMON_T_MAX_ALARM | HWMON_T_MIN_ALARM |\n\tHWMON_T_CRIT | HWMON_T_LCRIT |\n\tHWMON_T_CRIT_ALARM | HWMON_T_LCRIT_ALARM,\n\t0,\n};\n\nstatic const struct hwmon_channel_info aqr_hwmon_temp = {\n\t.type = hwmon_temp,\n\t.config = aqr_hwmon_temp_config,\n};\n\nstatic const struct hwmon_channel_info * const aqr_hwmon_info[] = {\n\t&aqr_hwmon_chip,\n\t&aqr_hwmon_temp,\n\tNULL,\n};\n\nstatic const struct hwmon_chip_info aqr_hwmon_chip_info = {\n\t.ops = &aqr_hwmon_ops,\n\t.info = aqr_hwmon_info,\n};\n\nint aqr_hwmon_probe(struct phy_device *phydev)\n{\n\tstruct device *dev = &phydev->mdio.dev;\n\tstruct device *hwmon_dev;\n\tchar *hwmon_name;\n\tint i, j;\n\n\thwmon_name = devm_kstrdup(dev, dev_name(dev), GFP_KERNEL);\n\tif (!hwmon_name)\n\t\treturn -ENOMEM;\n\n\tfor (i = j = 0; hwmon_name[i]; i++) {\n\t\tif (isalnum(hwmon_name[i])) {\n\t\t\tif (i != j)\n\t\t\t\thwmon_name[j] = hwmon_name[i];\n\t\t\tj++;\n\t\t}\n\t}\n\thwmon_name[j] = '\\0';\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, hwmon_name,\n\t\t\t\t\tphydev, &aqr_hwmon_chip_info, NULL);\n\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}