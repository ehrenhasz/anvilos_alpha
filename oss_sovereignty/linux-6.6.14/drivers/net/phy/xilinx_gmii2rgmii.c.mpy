{
  "module_name": "xilinx_gmii2rgmii.c",
  "hash_id": "23459b3902533eaf9f0f0ba5eaa4bfb69ed373230cac583313e8e8f376a23247",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/xilinx_gmii2rgmii.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/mii.h>\n#include <linux/mdio.h>\n#include <linux/phy.h>\n#include <linux/of_mdio.h>\n\n#define XILINX_GMII2RGMII_REG\t\t0x10\n#define XILINX_GMII2RGMII_SPEED_MASK\t(BMCR_SPEED1000 | BMCR_SPEED100)\n\nstruct gmii2rgmii {\n\tstruct phy_device *phy_dev;\n\tstruct phy_driver *phy_drv;\n\tstruct phy_driver conv_phy_drv;\n\tstruct mdio_device *mdio;\n};\n\nstatic void xgmiitorgmii_configure(struct gmii2rgmii *priv, int speed)\n{\n\tstruct mii_bus *bus = priv->mdio->bus;\n\tint addr = priv->mdio->addr;\n\tu16 val;\n\n\tval = mdiobus_read(bus, addr, XILINX_GMII2RGMII_REG);\n\tval &= ~XILINX_GMII2RGMII_SPEED_MASK;\n\n\tif (speed == SPEED_1000)\n\t\tval |= BMCR_SPEED1000;\n\telse if (speed == SPEED_100)\n\t\tval |= BMCR_SPEED100;\n\telse\n\t\tval |= BMCR_SPEED10;\n\n\tmdiobus_write(bus, addr, XILINX_GMII2RGMII_REG, val);\n}\n\nstatic int xgmiitorgmii_read_status(struct phy_device *phydev)\n{\n\tstruct gmii2rgmii *priv = mdiodev_get_drvdata(&phydev->mdio);\n\tint err;\n\n\tif (priv->phy_drv->read_status)\n\t\terr = priv->phy_drv->read_status(phydev);\n\telse\n\t\terr = genphy_read_status(phydev);\n\tif (err < 0)\n\t\treturn err;\n\n\txgmiitorgmii_configure(priv, phydev->speed);\n\n\treturn 0;\n}\n\nstatic int xgmiitorgmii_set_loopback(struct phy_device *phydev, bool enable)\n{\n\tstruct gmii2rgmii *priv = mdiodev_get_drvdata(&phydev->mdio);\n\tint err;\n\n\tif (priv->phy_drv->set_loopback)\n\t\terr = priv->phy_drv->set_loopback(phydev, enable);\n\telse\n\t\terr = genphy_loopback(phydev, enable);\n\tif (err < 0)\n\t\treturn err;\n\n\txgmiitorgmii_configure(priv, phydev->speed);\n\n\treturn 0;\n}\n\nstatic int xgmiitorgmii_probe(struct mdio_device *mdiodev)\n{\n\tstruct device *dev = &mdiodev->dev;\n\tstruct device_node *np = dev->of_node, *phy_node;\n\tstruct gmii2rgmii *priv;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tphy_node = of_parse_phandle(np, \"phy-handle\", 0);\n\tif (!phy_node) {\n\t\tdev_err(dev, \"Couldn't parse phy-handle\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv->phy_dev = of_phy_find_device(phy_node);\n\tof_node_put(phy_node);\n\tif (!priv->phy_dev) {\n\t\tdev_info(dev, \"Couldn't find phydev\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tif (!priv->phy_dev->drv) {\n\t\tdev_info(dev, \"Attached phy not ready\\n\");\n\t\tput_device(&priv->phy_dev->mdio.dev);\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tpriv->mdio = mdiodev;\n\tpriv->phy_drv = priv->phy_dev->drv;\n\tmemcpy(&priv->conv_phy_drv, priv->phy_dev->drv,\n\t       sizeof(struct phy_driver));\n\tpriv->conv_phy_drv.read_status = xgmiitorgmii_read_status;\n\tpriv->conv_phy_drv.set_loopback = xgmiitorgmii_set_loopback;\n\tmdiodev_set_drvdata(&priv->phy_dev->mdio, priv);\n\tpriv->phy_dev->drv = &priv->conv_phy_drv;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id xgmiitorgmii_of_match[] = {\n\t{ .compatible = \"xlnx,gmii-to-rgmii-1.0\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, xgmiitorgmii_of_match);\n\nstatic struct mdio_driver xgmiitorgmii_driver = {\n\t.probe\t= xgmiitorgmii_probe,\n\t.mdiodrv.driver = {\n\t\t.name = \"xgmiitorgmii\",\n\t\t.of_match_table = xgmiitorgmii_of_match,\n\t},\n};\n\nmdio_module_driver(xgmiitorgmii_driver);\n\nMODULE_DESCRIPTION(\"Xilinx GMII2RGMII converter driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}