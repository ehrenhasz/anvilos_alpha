{
  "module_name": "spi_ks8995.c",
  "hash_id": "19530fb0377f608c1f1333437943ec97d6b95cb53a42546351594bd1fd98947b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/spi_ks8995.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of.h>\n\n#include <linux/spi/spi.h>\n\n#define DRV_VERSION\t\t\"0.1.1\"\n#define DRV_DESC\t\t\"Micrel KS8995 Ethernet switch SPI driver\"\n\n \n\n#define KS8995_REG_ID0\t\t0x00     \n#define KS8995_REG_ID1\t\t0x01     \n\n#define KS8995_REG_GC0\t\t0x02     \n#define KS8995_REG_GC1\t\t0x03     \n#define KS8995_REG_GC2\t\t0x04     \n#define KS8995_REG_GC3\t\t0x05     \n#define KS8995_REG_GC4\t\t0x06     \n#define KS8995_REG_GC5\t\t0x07     \n#define KS8995_REG_GC6\t\t0x08     \n#define KS8995_REG_GC7\t\t0x09     \n#define KS8995_REG_GC8\t\t0x0a     \n#define KS8995_REG_GC9\t\t0x0b     \n\n#define KS8995_REG_PC(p, r)\t((0x10 * p) + r)\t  \n#define KS8995_REG_PS(p, r)\t((0x10 * p) + r + 0xe)   \n\n#define KS8995_REG_TPC0\t\t0x60     \n#define KS8995_REG_TPC1\t\t0x61     \n#define KS8995_REG_TPC2\t\t0x62     \n#define KS8995_REG_TPC3\t\t0x63     \n#define KS8995_REG_TPC4\t\t0x64     \n#define KS8995_REG_TPC5\t\t0x65     \n#define KS8995_REG_TPC6\t\t0x66     \n#define KS8995_REG_TPC7\t\t0x67     \n\n#define KS8995_REG_MAC0\t\t0x68     \n#define KS8995_REG_MAC1\t\t0x69     \n#define KS8995_REG_MAC2\t\t0x6a     \n#define KS8995_REG_MAC3\t\t0x6b     \n#define KS8995_REG_MAC4\t\t0x6c     \n#define KS8995_REG_MAC5\t\t0x6d     \n\n#define KS8995_REG_IAC0\t\t0x6e     \n#define KS8995_REG_IAC1\t\t0x6f     \n#define KS8995_REG_IAD7\t\t0x70     \n#define KS8995_REG_IAD6\t\t0x71     \n#define KS8995_REG_IAD5\t\t0x72     \n#define KS8995_REG_IAD4\t\t0x73     \n#define KS8995_REG_IAD3\t\t0x74     \n#define KS8995_REG_IAD2\t\t0x75     \n#define KS8995_REG_IAD1\t\t0x76     \n#define KS8995_REG_IAD0\t\t0x77     \n\n#define KSZ8864_REG_ID1\t\t0xfe\t \n\n#define KS8995_REGS_SIZE\t0x80\n#define KSZ8864_REGS_SIZE\t0x100\n#define KSZ8795_REGS_SIZE\t0x100\n\n#define ID1_CHIPID_M\t\t0xf\n#define ID1_CHIPID_S\t\t4\n#define ID1_REVISION_M\t\t0x7\n#define ID1_REVISION_S\t\t1\n#define ID1_START_SW\t\t1\t \n\n#define FAMILY_KS8995\t\t0x95\n#define FAMILY_KSZ8795\t\t0x87\n#define CHIPID_M\t\t0\n#define KS8995_CHIP_ID\t\t0x00\n#define KSZ8864_CHIP_ID\t\t0x01\n#define KSZ8795_CHIP_ID\t\t0x09\n\n#define KS8995_CMD_WRITE\t0x02U\n#define KS8995_CMD_READ\t\t0x03U\n\n#define KS8995_RESET_DELAY\t10  \n\nenum ks8995_chip_variant {\n\tks8995,\n\tksz8864,\n\tksz8795,\n\tmax_variant\n};\n\nstruct ks8995_chip_params {\n\tchar *name;\n\tint family_id;\n\tint chip_id;\n\tint regs_size;\n\tint addr_width;\n\tint addr_shift;\n};\n\nstatic const struct ks8995_chip_params ks8995_chip[] = {\n\t[ks8995] = {\n\t\t.name = \"KS8995MA\",\n\t\t.family_id = FAMILY_KS8995,\n\t\t.chip_id = KS8995_CHIP_ID,\n\t\t.regs_size = KS8995_REGS_SIZE,\n\t\t.addr_width = 8,\n\t\t.addr_shift = 0,\n\t},\n\t[ksz8864] = {\n\t\t.name = \"KSZ8864RMN\",\n\t\t.family_id = FAMILY_KS8995,\n\t\t.chip_id = KSZ8864_CHIP_ID,\n\t\t.regs_size = KSZ8864_REGS_SIZE,\n\t\t.addr_width = 8,\n\t\t.addr_shift = 0,\n\t},\n\t[ksz8795] = {\n\t\t.name = \"KSZ8795CLX\",\n\t\t.family_id = FAMILY_KSZ8795,\n\t\t.chip_id = KSZ8795_CHIP_ID,\n\t\t.regs_size = KSZ8795_REGS_SIZE,\n\t\t.addr_width = 12,\n\t\t.addr_shift = 1,\n\t},\n};\n\nstruct ks8995_switch {\n\tstruct spi_device\t*spi;\n\tstruct mutex\t\tlock;\n\tstruct gpio_desc\t*reset_gpio;\n\tstruct bin_attribute\tregs_attr;\n\tconst struct ks8995_chip_params\t*chip;\n\tint\t\t\trevision_id;\n};\n\nstatic const struct spi_device_id ks8995_id[] = {\n\t{\"ks8995\", ks8995},\n\t{\"ksz8864\", ksz8864},\n\t{\"ksz8795\", ksz8795},\n\t{ }\n};\nMODULE_DEVICE_TABLE(spi, ks8995_id);\n\nstatic const struct of_device_id ks8895_spi_of_match[] = {\n\t{ .compatible = \"micrel,ks8995\" },\n\t{ .compatible = \"micrel,ksz8864\" },\n\t{ .compatible = \"micrel,ksz8795\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, ks8895_spi_of_match);\n\nstatic inline u8 get_chip_id(u8 val)\n{\n\treturn (val >> ID1_CHIPID_S) & ID1_CHIPID_M;\n}\n\nstatic inline u8 get_chip_rev(u8 val)\n{\n\treturn (val >> ID1_REVISION_S) & ID1_REVISION_M;\n}\n\n \nstatic inline __be16 create_spi_cmd(struct ks8995_switch *ks, int cmd,\n\t\t\t\t    unsigned address)\n{\n\tu16 result = cmd;\n\n\t \n\tresult <<= ks->chip->addr_width + ks->chip->addr_shift;\n\t \n\tresult |= address << ks->chip->addr_shift;\n\t \n\treturn cpu_to_be16(result);\n}\n \nstatic int ks8995_read(struct ks8995_switch *ks, char *buf,\n\t\t unsigned offset, size_t count)\n{\n\t__be16 cmd;\n\tstruct spi_transfer t[2];\n\tstruct spi_message m;\n\tint err;\n\n\tcmd = create_spi_cmd(ks, KS8995_CMD_READ, offset);\n\tspi_message_init(&m);\n\n\tmemset(&t, 0, sizeof(t));\n\n\tt[0].tx_buf = &cmd;\n\tt[0].len = sizeof(cmd);\n\tspi_message_add_tail(&t[0], &m);\n\n\tt[1].rx_buf = buf;\n\tt[1].len = count;\n\tspi_message_add_tail(&t[1], &m);\n\n\tmutex_lock(&ks->lock);\n\terr = spi_sync(ks->spi, &m);\n\tmutex_unlock(&ks->lock);\n\n\treturn err ? err : count;\n}\n\nstatic int ks8995_write(struct ks8995_switch *ks, char *buf,\n\t\t unsigned offset, size_t count)\n{\n\t__be16 cmd;\n\tstruct spi_transfer t[2];\n\tstruct spi_message m;\n\tint err;\n\n\tcmd = create_spi_cmd(ks, KS8995_CMD_WRITE, offset);\n\tspi_message_init(&m);\n\n\tmemset(&t, 0, sizeof(t));\n\n\tt[0].tx_buf = &cmd;\n\tt[0].len = sizeof(cmd);\n\tspi_message_add_tail(&t[0], &m);\n\n\tt[1].tx_buf = buf;\n\tt[1].len = count;\n\tspi_message_add_tail(&t[1], &m);\n\n\tmutex_lock(&ks->lock);\n\terr = spi_sync(ks->spi, &m);\n\tmutex_unlock(&ks->lock);\n\n\treturn err ? err : count;\n}\n\nstatic inline int ks8995_read_reg(struct ks8995_switch *ks, u8 addr, u8 *buf)\n{\n\treturn ks8995_read(ks, buf, addr, 1) != 1;\n}\n\nstatic inline int ks8995_write_reg(struct ks8995_switch *ks, u8 addr, u8 val)\n{\n\tchar buf = val;\n\n\treturn ks8995_write(ks, &buf, addr, 1) != 1;\n}\n\n \n\nstatic int ks8995_stop(struct ks8995_switch *ks)\n{\n\treturn ks8995_write_reg(ks, KS8995_REG_ID1, 0);\n}\n\nstatic int ks8995_start(struct ks8995_switch *ks)\n{\n\treturn ks8995_write_reg(ks, KS8995_REG_ID1, 1);\n}\n\nstatic int ks8995_reset(struct ks8995_switch *ks)\n{\n\tint err;\n\n\terr = ks8995_stop(ks);\n\tif (err)\n\t\treturn err;\n\n\tudelay(KS8995_RESET_DELAY);\n\n\treturn ks8995_start(ks);\n}\n\nstatic ssize_t ks8995_registers_read(struct file *filp, struct kobject *kobj,\n\tstruct bin_attribute *bin_attr, char *buf, loff_t off, size_t count)\n{\n\tstruct device *dev;\n\tstruct ks8995_switch *ks8995;\n\n\tdev = kobj_to_dev(kobj);\n\tks8995 = dev_get_drvdata(dev);\n\n\treturn ks8995_read(ks8995, buf, off, count);\n}\n\nstatic ssize_t ks8995_registers_write(struct file *filp, struct kobject *kobj,\n\tstruct bin_attribute *bin_attr, char *buf, loff_t off, size_t count)\n{\n\tstruct device *dev;\n\tstruct ks8995_switch *ks8995;\n\n\tdev = kobj_to_dev(kobj);\n\tks8995 = dev_get_drvdata(dev);\n\n\treturn ks8995_write(ks8995, buf, off, count);\n}\n\n \nstatic int ks8995_get_revision(struct ks8995_switch *ks)\n{\n\tint err;\n\tu8 id0, id1, ksz8864_id;\n\n\t \n\terr = ks8995_read_reg(ks, KS8995_REG_ID0, &id0);\n\tif (err) {\n\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\n\t \n\tif (id0 != ks->chip->family_id) {\n\t\tdev_err(&ks->spi->dev, \"chip family id mismatch: expected 0x%02x but 0x%02x read\\n\",\n\t\t\tks->chip->family_id, id0);\n\t\terr = -ENODEV;\n\t\tgoto err_out;\n\t}\n\n\tswitch (ks->chip->family_id) {\n\tcase FAMILY_KS8995:\n\t\t \n\t\terr = ks8995_read_reg(ks, KS8995_REG_ID1, &id1);\n\t\tif (err) {\n\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\t \n\t\tif ((get_chip_id(id1) == CHIPID_M) &&\n\t\t    (get_chip_id(id1) == ks->chip->chip_id)) {\n\t\t\t \n\t\t\tks->revision_id = get_chip_rev(id1);\n\t\t} else if (get_chip_id(id1) != CHIPID_M) {\n\t\t\t \n\t\t\terr = ks8995_read_reg(ks, KS8995_REG_ID1, &ksz8864_id);\n\t\t\tif (err) {\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\tif ((ksz8864_id & 0x80) &&\n\t\t\t    (ks->chip->chip_id == KSZ8864_CHIP_ID)) {\n\t\t\t\tks->revision_id = get_chip_rev(id1);\n\t\t\t}\n\n\t\t} else {\n\t\t\tdev_err(&ks->spi->dev, \"unsupported chip id for KS8995 family: 0x%02x\\n\",\n\t\t\t\tid1);\n\t\t\terr = -ENODEV;\n\t\t}\n\t\tbreak;\n\tcase FAMILY_KSZ8795:\n\t\t \n\t\terr = ks8995_read_reg(ks, KS8995_REG_ID1, &id1);\n\t\tif (err) {\n\t\t\terr = -EIO;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (get_chip_id(id1) == ks->chip->chip_id) {\n\t\t\tks->revision_id = get_chip_rev(id1);\n\t\t} else {\n\t\t\tdev_err(&ks->spi->dev, \"unsupported chip id for KSZ8795 family: 0x%02x\\n\",\n\t\t\t\tid1);\n\t\t\terr = -ENODEV;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&ks->spi->dev, \"unsupported family id: 0x%02x\\n\", id0);\n\t\terr = -ENODEV;\n\t\tbreak;\n\t}\nerr_out:\n\treturn err;\n}\n\nstatic const struct bin_attribute ks8995_registers_attr = {\n\t.attr = {\n\t\t.name   = \"registers\",\n\t\t.mode   = 0600,\n\t},\n\t.size   = KS8995_REGS_SIZE,\n\t.read   = ks8995_registers_read,\n\t.write  = ks8995_registers_write,\n};\n\n \nstatic int ks8995_probe(struct spi_device *spi)\n{\n\tstruct ks8995_switch *ks;\n\tint err;\n\tint variant = spi_get_device_id(spi)->driver_data;\n\n\tif (variant >= max_variant) {\n\t\tdev_err(&spi->dev, \"bad chip variant %d\\n\", variant);\n\t\treturn -ENODEV;\n\t}\n\n\tks = devm_kzalloc(&spi->dev, sizeof(*ks), GFP_KERNEL);\n\tif (!ks)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&ks->lock);\n\tks->spi = spi;\n\tks->chip = &ks8995_chip[variant];\n\n\tks->reset_gpio = devm_gpiod_get_optional(&spi->dev, \"reset\",\n\t\t\t\t\t\t GPIOD_OUT_HIGH);\n\terr = PTR_ERR_OR_ZERO(ks->reset_gpio);\n\tif (err) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"failed to get reset gpio: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = gpiod_set_consumer_name(ks->reset_gpio, \"switch-reset\");\n\tif (err)\n\t\treturn err;\n\n\t \n\t \n\tgpiod_set_value_cansleep(ks->reset_gpio, 0);\n\n\tspi_set_drvdata(spi, ks);\n\n\tspi->mode = SPI_MODE_0;\n\tspi->bits_per_word = 8;\n\terr = spi_setup(spi);\n\tif (err) {\n\t\tdev_err(&spi->dev, \"spi_setup failed, err=%d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = ks8995_get_revision(ks);\n\tif (err)\n\t\treturn err;\n\n\tmemcpy(&ks->regs_attr, &ks8995_registers_attr, sizeof(ks->regs_attr));\n\tks->regs_attr.size = ks->chip->regs_size;\n\n\terr = ks8995_reset(ks);\n\tif (err)\n\t\treturn err;\n\n\tsysfs_attr_init(&ks->regs_attr.attr);\n\terr = sysfs_create_bin_file(&spi->dev.kobj, &ks->regs_attr);\n\tif (err) {\n\t\tdev_err(&spi->dev, \"unable to create sysfs file, err=%d\\n\",\n\t\t\t\t    err);\n\t\treturn err;\n\t}\n\n\tdev_info(&spi->dev, \"%s device found, Chip ID:%x, Revision:%x\\n\",\n\t\t ks->chip->name, ks->chip->chip_id, ks->revision_id);\n\n\treturn 0;\n}\n\nstatic void ks8995_remove(struct spi_device *spi)\n{\n\tstruct ks8995_switch *ks = spi_get_drvdata(spi);\n\n\tsysfs_remove_bin_file(&spi->dev.kobj, &ks->regs_attr);\n\n\t \n\tgpiod_set_value_cansleep(ks->reset_gpio, 1);\n}\n\n \nstatic struct spi_driver ks8995_driver = {\n\t.driver = {\n\t\t.name\t    = \"spi-ks8995\",\n\t\t.of_match_table = ks8895_spi_of_match,\n\t},\n\t.probe\t  = ks8995_probe,\n\t.remove\t  = ks8995_remove,\n\t.id_table = ks8995_id,\n};\n\nmodule_spi_driver(ks8995_driver);\n\nMODULE_DESCRIPTION(DRV_DESC);\nMODULE_VERSION(DRV_VERSION);\nMODULE_AUTHOR(\"Gabor Juhos <juhosg at openwrt.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}