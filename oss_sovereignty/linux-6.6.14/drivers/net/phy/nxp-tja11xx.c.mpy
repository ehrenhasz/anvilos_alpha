{
  "module_name": "nxp-tja11xx.c",
  "hash_id": "26727ed8856039aed09eceee503b69408fb05af88a5a6feb47c165220f76213e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/nxp-tja11xx.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/ethtool.h>\n#include <linux/ethtool_netlink.h>\n#include <linux/kernel.h>\n#include <linux/mdio.h>\n#include <linux/mii.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy.h>\n#include <linux/hwmon.h>\n#include <linux/bitfield.h>\n#include <linux/of_mdio.h>\n#include <linux/of_irq.h>\n\n#define PHY_ID_MASK\t\t\t0xfffffff0\n#define PHY_ID_TJA1100\t\t\t0x0180dc40\n#define PHY_ID_TJA1101\t\t\t0x0180dd00\n#define PHY_ID_TJA1102\t\t\t0x0180dc80\n\n#define MII_ECTRL\t\t\t17\n#define MII_ECTRL_LINK_CONTROL\t\tBIT(15)\n#define MII_ECTRL_POWER_MODE_MASK\tGENMASK(14, 11)\n#define MII_ECTRL_POWER_MODE_NO_CHANGE\t(0x0 << 11)\n#define MII_ECTRL_POWER_MODE_NORMAL\t(0x3 << 11)\n#define MII_ECTRL_POWER_MODE_STANDBY\t(0xc << 11)\n#define MII_ECTRL_CABLE_TEST\t\tBIT(5)\n#define MII_ECTRL_CONFIG_EN\t\tBIT(2)\n#define MII_ECTRL_WAKE_REQUEST\t\tBIT(0)\n\n#define MII_CFG1\t\t\t18\n#define MII_CFG1_MASTER_SLAVE\t\tBIT(15)\n#define MII_CFG1_AUTO_OP\t\tBIT(14)\n#define MII_CFG1_INTERFACE_MODE_MASK\tGENMASK(9, 8)\n#define MII_CFG1_MII_MODE\t\t\t\t(0x0 << 8)\n#define MII_CFG1_RMII_MODE_REFCLK_IN\tBIT(8)\n#define MII_CFG1_RMII_MODE_REFCLK_OUT\tBIT(9)\n#define MII_CFG1_REVMII_MODE\t\t\tGENMASK(9, 8)\n#define MII_CFG1_SLEEP_CONFIRM\t\tBIT(6)\n#define MII_CFG1_LED_MODE_MASK\t\tGENMASK(5, 4)\n#define MII_CFG1_LED_MODE_LINKUP\t0\n#define MII_CFG1_LED_ENABLE\t\tBIT(3)\n\n#define MII_CFG2\t\t\t19\n#define MII_CFG2_SLEEP_REQUEST_TO\tGENMASK(1, 0)\n#define MII_CFG2_SLEEP_REQUEST_TO_16MS\t0x3\n\n#define MII_INTSRC\t\t\t21\n#define MII_INTSRC_LINK_FAIL\t\tBIT(10)\n#define MII_INTSRC_LINK_UP\t\tBIT(9)\n#define MII_INTSRC_MASK\t\t\t(MII_INTSRC_LINK_FAIL | MII_INTSRC_LINK_UP)\n#define MII_INTSRC_UV_ERR\t\tBIT(3)\n#define MII_INTSRC_TEMP_ERR\t\tBIT(1)\n\n#define MII_INTEN\t\t\t22\n#define MII_INTEN_LINK_FAIL\t\tBIT(10)\n#define MII_INTEN_LINK_UP\t\tBIT(9)\n#define MII_INTEN_UV_ERR\t\tBIT(3)\n#define MII_INTEN_TEMP_ERR\t\tBIT(1)\n\n#define MII_COMMSTAT\t\t\t23\n#define MII_COMMSTAT_LINK_UP\t\tBIT(15)\n#define MII_COMMSTAT_SQI_STATE\t\tGENMASK(7, 5)\n#define MII_COMMSTAT_SQI_MAX\t\t7\n\n#define MII_GENSTAT\t\t\t24\n#define MII_GENSTAT_PLL_LOCKED\t\tBIT(14)\n\n#define MII_EXTSTAT\t\t\t25\n#define MII_EXTSTAT_SHORT_DETECT\tBIT(8)\n#define MII_EXTSTAT_OPEN_DETECT\t\tBIT(7)\n#define MII_EXTSTAT_POLARITY_DETECT\tBIT(6)\n\n#define MII_COMMCFG\t\t\t27\n#define MII_COMMCFG_AUTO_OP\t\tBIT(15)\n\n \n#define TJA110X_RMII_MODE_REFCLK_IN       BIT(0)\n\nstruct tja11xx_priv {\n\tchar\t\t*hwmon_name;\n\tstruct device\t*hwmon_dev;\n\tstruct phy_device *phydev;\n\tstruct work_struct phy_register_work;\n\tu32 flags;\n};\n\nstruct tja11xx_phy_stats {\n\tconst char\t*string;\n\tu8\t\treg;\n\tu8\t\toff;\n\tu16\t\tmask;\n};\n\nstatic struct tja11xx_phy_stats tja11xx_hw_stats[] = {\n\t{ \"phy_symbol_error_count\", 20, 0, GENMASK(15, 0) },\n\t{ \"phy_polarity_detect\", 25, 6, BIT(6) },\n\t{ \"phy_open_detect\", 25, 7, BIT(7) },\n\t{ \"phy_short_detect\", 25, 8, BIT(8) },\n\t{ \"phy_rem_rcvr_count\", 26, 0, GENMASK(7, 0) },\n\t{ \"phy_loc_rcvr_count\", 26, 8, GENMASK(15, 8) },\n};\n\nstatic int tja11xx_check(struct phy_device *phydev, u8 reg, u16 mask, u16 set)\n{\n\tint val;\n\n\treturn phy_read_poll_timeout(phydev, reg, val, (val & mask) == set,\n\t\t\t\t     150, 30000, false);\n}\n\nstatic int phy_modify_check(struct phy_device *phydev, u8 reg,\n\t\t\t    u16 mask, u16 set)\n{\n\tint ret;\n\n\tret = phy_modify(phydev, reg, mask, set);\n\tif (ret)\n\t\treturn ret;\n\n\treturn tja11xx_check(phydev, reg, mask, set);\n}\n\nstatic int tja11xx_enable_reg_write(struct phy_device *phydev)\n{\n\treturn phy_set_bits(phydev, MII_ECTRL, MII_ECTRL_CONFIG_EN);\n}\n\nstatic int tja11xx_enable_link_control(struct phy_device *phydev)\n{\n\treturn phy_set_bits(phydev, MII_ECTRL, MII_ECTRL_LINK_CONTROL);\n}\n\nstatic int tja11xx_disable_link_control(struct phy_device *phydev)\n{\n\treturn phy_clear_bits(phydev, MII_ECTRL, MII_ECTRL_LINK_CONTROL);\n}\n\nstatic int tja11xx_wakeup(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = phy_read(phydev, MII_ECTRL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (ret & MII_ECTRL_POWER_MODE_MASK) {\n\tcase MII_ECTRL_POWER_MODE_NO_CHANGE:\n\t\tbreak;\n\tcase MII_ECTRL_POWER_MODE_NORMAL:\n\t\tret = phy_set_bits(phydev, MII_ECTRL, MII_ECTRL_WAKE_REQUEST);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = phy_clear_bits(phydev, MII_ECTRL, MII_ECTRL_WAKE_REQUEST);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase MII_ECTRL_POWER_MODE_STANDBY:\n\t\tret = phy_modify_check(phydev, MII_ECTRL,\n\t\t\t\t       MII_ECTRL_POWER_MODE_MASK,\n\t\t\t\t       MII_ECTRL_POWER_MODE_STANDBY);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = phy_modify(phydev, MII_ECTRL, MII_ECTRL_POWER_MODE_MASK,\n\t\t\t\t MII_ECTRL_POWER_MODE_NORMAL);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = phy_modify_check(phydev, MII_GENSTAT,\n\t\t\t\t       MII_GENSTAT_PLL_LOCKED,\n\t\t\t\t       MII_GENSTAT_PLL_LOCKED);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn tja11xx_enable_link_control(phydev);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int tja11xx_soft_reset(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = tja11xx_enable_reg_write(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn genphy_soft_reset(phydev);\n}\n\nstatic int tja11xx_config_aneg_cable_test(struct phy_device *phydev)\n{\n\tbool finished = false;\n\tint ret;\n\n\tif (phydev->link)\n\t\treturn 0;\n\n\tif (!phydev->drv->cable_test_start ||\n\t    !phydev->drv->cable_test_get_status)\n\t\treturn 0;\n\n\tret = ethnl_cable_test_alloc(phydev, ETHTOOL_MSG_CABLE_TEST_NTF);\n\tif (ret)\n\t\treturn ret;\n\n\tret = phydev->drv->cable_test_start(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tusleep_range(100, 200);\n\n\tret = phydev->drv->cable_test_get_status(phydev, &finished);\n\tif (ret)\n\t\treturn ret;\n\n\tif (finished)\n\t\tethnl_cable_test_finished(phydev);\n\n\treturn 0;\n}\n\nstatic int tja11xx_config_aneg(struct phy_device *phydev)\n{\n\tint ret, changed = 0;\n\tu16 ctl = 0;\n\n\tswitch (phydev->master_slave_set) {\n\tcase MASTER_SLAVE_CFG_MASTER_FORCE:\n\t\tctl |= MII_CFG1_MASTER_SLAVE;\n\t\tbreak;\n\tcase MASTER_SLAVE_CFG_SLAVE_FORCE:\n\t\tbreak;\n\tcase MASTER_SLAVE_CFG_UNKNOWN:\n\tcase MASTER_SLAVE_CFG_UNSUPPORTED:\n\t\tgoto do_test;\n\tdefault:\n\t\tphydev_warn(phydev, \"Unsupported Master/Slave mode\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tchanged = phy_modify_changed(phydev, MII_CFG1, MII_CFG1_MASTER_SLAVE, ctl);\n\tif (changed < 0)\n\t\treturn changed;\n\ndo_test:\n\tret = tja11xx_config_aneg_cable_test(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __genphy_config_aneg(phydev, changed);\n}\n\nstatic int tja11xx_get_interface_mode(struct phy_device *phydev)\n{\n\tstruct tja11xx_priv *priv = phydev->priv;\n\tint mii_mode;\n\n\tswitch (phydev->interface) {\n\tcase PHY_INTERFACE_MODE_MII:\n\t\tmii_mode = MII_CFG1_MII_MODE;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_REVMII:\n\t\tmii_mode = MII_CFG1_REVMII_MODE;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tif (priv->flags & TJA110X_RMII_MODE_REFCLK_IN)\n\t\t\tmii_mode = MII_CFG1_RMII_MODE_REFCLK_IN;\n\t\telse\n\t\t\tmii_mode = MII_CFG1_RMII_MODE_REFCLK_OUT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn mii_mode;\n}\n\nstatic int tja11xx_config_init(struct phy_device *phydev)\n{\n\tu16 reg_mask, reg_val;\n\tint ret;\n\n\tret = tja11xx_enable_reg_write(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tphydev->autoneg = AUTONEG_DISABLE;\n\tphydev->speed = SPEED_100;\n\tphydev->duplex = DUPLEX_FULL;\n\n\tswitch (phydev->phy_id & PHY_ID_MASK) {\n\tcase PHY_ID_TJA1100:\n\t\treg_mask = MII_CFG1_AUTO_OP | MII_CFG1_LED_MODE_MASK |\n\t\t\t   MII_CFG1_LED_ENABLE;\n\t\treg_val = MII_CFG1_AUTO_OP | MII_CFG1_LED_MODE_LINKUP |\n\t\t\t  MII_CFG1_LED_ENABLE;\n\n\t\treg_mask |= MII_CFG1_INTERFACE_MODE_MASK;\n\t\tret = tja11xx_get_interface_mode(phydev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treg_val |= (ret & 0xffff);\n\t\tret = phy_modify(phydev, MII_CFG1, reg_mask, reg_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase PHY_ID_TJA1101:\n\t\treg_mask = MII_CFG1_INTERFACE_MODE_MASK;\n\t\tret = tja11xx_get_interface_mode(phydev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\treg_val = ret & 0xffff;\n\t\tret = phy_modify(phydev, MII_CFG1, reg_mask, reg_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tfallthrough;\n\tcase PHY_ID_TJA1102:\n\t\tret = phy_set_bits(phydev, MII_COMMCFG, MII_COMMCFG_AUTO_OP);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = phy_clear_bits(phydev, MII_CFG1, MII_CFG1_SLEEP_CONFIRM);\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_modify(phydev, MII_CFG2, MII_CFG2_SLEEP_REQUEST_TO,\n\t\t\t MII_CFG2_SLEEP_REQUEST_TO_16MS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tja11xx_wakeup(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = phy_read(phydev, MII_INTSRC);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int tja11xx_read_status(struct phy_device *phydev)\n{\n\tint ret;\n\n\tphydev->master_slave_get = MASTER_SLAVE_CFG_UNKNOWN;\n\tphydev->master_slave_state = MASTER_SLAVE_STATE_UNSUPPORTED;\n\n\tret = genphy_update_link(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_read(phydev, MII_CFG1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & MII_CFG1_MASTER_SLAVE)\n\t\tphydev->master_slave_get = MASTER_SLAVE_CFG_MASTER_FORCE;\n\telse\n\t\tphydev->master_slave_get = MASTER_SLAVE_CFG_SLAVE_FORCE;\n\n\tif (phydev->link) {\n\t\tret = phy_read(phydev, MII_COMMSTAT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (!(ret & MII_COMMSTAT_LINK_UP))\n\t\t\tphydev->link = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int tja11xx_get_sqi(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = phy_read(phydev, MII_COMMSTAT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn FIELD_GET(MII_COMMSTAT_SQI_STATE, ret);\n}\n\nstatic int tja11xx_get_sqi_max(struct phy_device *phydev)\n{\n\treturn MII_COMMSTAT_SQI_MAX;\n}\n\nstatic int tja11xx_get_sset_count(struct phy_device *phydev)\n{\n\treturn ARRAY_SIZE(tja11xx_hw_stats);\n}\n\nstatic void tja11xx_get_strings(struct phy_device *phydev, u8 *data)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(tja11xx_hw_stats); i++) {\n\t\tstrncpy(data + i * ETH_GSTRING_LEN,\n\t\t\ttja11xx_hw_stats[i].string, ETH_GSTRING_LEN);\n\t}\n}\n\nstatic void tja11xx_get_stats(struct phy_device *phydev,\n\t\t\t      struct ethtool_stats *stats, u64 *data)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(tja11xx_hw_stats); i++) {\n\t\tret = phy_read(phydev, tja11xx_hw_stats[i].reg);\n\t\tif (ret < 0)\n\t\t\tdata[i] = U64_MAX;\n\t\telse {\n\t\t\tdata[i] = ret & tja11xx_hw_stats[i].mask;\n\t\t\tdata[i] >>= tja11xx_hw_stats[i].off;\n\t\t}\n\t}\n}\n\nstatic int tja11xx_hwmon_read(struct device *dev,\n\t\t\t      enum hwmon_sensor_types type,\n\t\t\t      u32 attr, int channel, long *value)\n{\n\tstruct phy_device *phydev = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (type == hwmon_in && attr == hwmon_in_lcrit_alarm) {\n\t\tret = phy_read(phydev, MII_INTSRC);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*value = !!(ret & MII_INTSRC_TEMP_ERR);\n\t\treturn 0;\n\t}\n\n\tif (type == hwmon_temp && attr == hwmon_temp_crit_alarm) {\n\t\tret = phy_read(phydev, MII_INTSRC);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t*value = !!(ret & MII_INTSRC_UV_ERR);\n\t\treturn 0;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic umode_t tja11xx_hwmon_is_visible(const void *data,\n\t\t\t\t\tenum hwmon_sensor_types type,\n\t\t\t\t\tu32 attr, int channel)\n{\n\tif (type == hwmon_in && attr == hwmon_in_lcrit_alarm)\n\t\treturn 0444;\n\n\tif (type == hwmon_temp && attr == hwmon_temp_crit_alarm)\n\t\treturn 0444;\n\n\treturn 0;\n}\n\nstatic const struct hwmon_channel_info * const tja11xx_hwmon_info[] = {\n\tHWMON_CHANNEL_INFO(in, HWMON_I_LCRIT_ALARM),\n\tHWMON_CHANNEL_INFO(temp, HWMON_T_CRIT_ALARM),\n\tNULL\n};\n\nstatic const struct hwmon_ops tja11xx_hwmon_hwmon_ops = {\n\t.is_visible\t= tja11xx_hwmon_is_visible,\n\t.read\t\t= tja11xx_hwmon_read,\n};\n\nstatic const struct hwmon_chip_info tja11xx_hwmon_chip_info = {\n\t.ops\t\t= &tja11xx_hwmon_hwmon_ops,\n\t.info\t\t= tja11xx_hwmon_info,\n};\n\nstatic int tja11xx_hwmon_register(struct phy_device *phydev,\n\t\t\t\t  struct tja11xx_priv *priv)\n{\n\tstruct device *dev = &phydev->mdio.dev;\n\n\tpriv->hwmon_name = devm_hwmon_sanitize_name(dev, dev_name(dev));\n\tif (IS_ERR(priv->hwmon_name))\n\t\treturn PTR_ERR(priv->hwmon_name);\n\n\tpriv->hwmon_dev =\n\t\tdevm_hwmon_device_register_with_info(dev, priv->hwmon_name,\n\t\t\t\t\t\t     phydev,\n\t\t\t\t\t\t     &tja11xx_hwmon_chip_info,\n\t\t\t\t\t\t     NULL);\n\n\treturn PTR_ERR_OR_ZERO(priv->hwmon_dev);\n}\n\nstatic int tja11xx_parse_dt(struct phy_device *phydev)\n{\n\tstruct device_node *node = phydev->mdio.dev.of_node;\n\tstruct tja11xx_priv *priv = phydev->priv;\n\n\tif (!IS_ENABLED(CONFIG_OF_MDIO))\n\t\treturn 0;\n\n\tif (of_property_read_bool(node, \"nxp,rmii-refclk-in\"))\n\t\tpriv->flags |= TJA110X_RMII_MODE_REFCLK_IN;\n\n\treturn 0;\n}\n\nstatic int tja11xx_probe(struct phy_device *phydev)\n{\n\tstruct device *dev = &phydev->mdio.dev;\n\tstruct tja11xx_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->phydev = phydev;\n\tphydev->priv = priv;\n\n\tret = tja11xx_parse_dt(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn tja11xx_hwmon_register(phydev, priv);\n}\n\nstatic void tja1102_p1_register(struct work_struct *work)\n{\n\tstruct tja11xx_priv *priv = container_of(work, struct tja11xx_priv,\n\t\t\t\t\t\t phy_register_work);\n\tstruct phy_device *phydev_phy0 = priv->phydev;\n\tstruct mii_bus *bus = phydev_phy0->mdio.bus;\n\tstruct device *dev = &phydev_phy0->mdio.dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *child;\n\tint ret;\n\n\tfor_each_available_child_of_node(np, child) {\n\t\tstruct phy_device *phy;\n\t\tint addr;\n\n\t\taddr = of_mdio_parse_addr(dev, child);\n\t\tif (addr < 0) {\n\t\t\tdev_err(dev, \"Can't parse addr\\n\");\n\t\t\tcontinue;\n\t\t} else if (addr != phydev_phy0->mdio.addr + 1) {\n\t\t\t \n\t\t\tdev_err(dev, \"Unexpected address. Should be: %i\\n\",\n\t\t\t\tphydev_phy0->mdio.addr + 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (mdiobus_is_registered_device(bus, addr)) {\n\t\t\tdev_err(dev, \"device is already registered\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tphy = phy_device_create(bus, addr, PHY_ID_TJA1102, false, NULL);\n\t\tif (IS_ERR(phy)) {\n\t\t\tdev_err(dev, \"Can't create PHY device for Port 1: %i\\n\",\n\t\t\t\taddr);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tphy->mdio.dev.parent = dev;\n\n\t\tret = of_mdiobus_phy_device_register(bus, phy, child, addr);\n\t\tif (ret) {\n\t\t\t \n\t\t\tdev_err(dev, \"Can't register Port 1. Unexpected error: %i\\n\",\n\t\t\t\tret);\n\t\t\tphy_device_free(phy);\n\t\t}\n\t}\n}\n\nstatic int tja1102_p0_probe(struct phy_device *phydev)\n{\n\tstruct device *dev = &phydev->mdio.dev;\n\tstruct tja11xx_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->phydev = phydev;\n\tINIT_WORK(&priv->phy_register_work, tja1102_p1_register);\n\n\tret = tja11xx_hwmon_register(phydev, priv);\n\tif (ret)\n\t\treturn ret;\n\n\tschedule_work(&priv->phy_register_work);\n\n\treturn 0;\n}\n\nstatic int tja1102_match_phy_device(struct phy_device *phydev, bool port0)\n{\n\tint ret;\n\n\tif ((phydev->phy_id & PHY_ID_MASK) != PHY_ID_TJA1102)\n\t\treturn 0;\n\n\tret = phy_read(phydev, MII_PHYSID2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (port0)\n\t\treturn ret ? 1 : 0;\n\n\treturn !ret;\n}\n\nstatic int tja1102_p0_match_phy_device(struct phy_device *phydev)\n{\n\treturn tja1102_match_phy_device(phydev, true);\n}\n\nstatic int tja1102_p1_match_phy_device(struct phy_device *phydev)\n{\n\treturn tja1102_match_phy_device(phydev, false);\n}\n\nstatic int tja11xx_ack_interrupt(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = phy_read(phydev, MII_INTSRC);\n\n\treturn (ret < 0) ? ret : 0;\n}\n\nstatic int tja11xx_config_intr(struct phy_device *phydev)\n{\n\tint value = 0;\n\tint err;\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\terr = tja11xx_ack_interrupt(phydev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tvalue = MII_INTEN_LINK_FAIL | MII_INTEN_LINK_UP |\n\t\t\tMII_INTEN_UV_ERR | MII_INTEN_TEMP_ERR;\n\t\terr = phy_write(phydev, MII_INTEN, value);\n\t} else {\n\t\terr = phy_write(phydev, MII_INTEN, value);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = tja11xx_ack_interrupt(phydev);\n\t}\n\n\treturn err;\n}\n\nstatic irqreturn_t tja11xx_handle_interrupt(struct phy_device *phydev)\n{\n\tstruct device *dev = &phydev->mdio.dev;\n\tint irq_status;\n\n\tirq_status = phy_read(phydev, MII_INTSRC);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (irq_status & MII_INTSRC_TEMP_ERR)\n\t\tdev_warn(dev, \"Overtemperature error detected (temp > 155C\u00b0).\\n\");\n\tif (irq_status & MII_INTSRC_UV_ERR)\n\t\tdev_warn(dev, \"Undervoltage error detected.\\n\");\n\n\tif (!(irq_status & MII_INTSRC_MASK))\n\t\treturn IRQ_NONE;\n\n\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int tja11xx_cable_test_start(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = phy_clear_bits(phydev, MII_COMMCFG, MII_COMMCFG_AUTO_OP);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tja11xx_wakeup(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = tja11xx_disable_link_control(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn phy_set_bits(phydev, MII_ECTRL, MII_ECTRL_CABLE_TEST);\n}\n\n \nstatic int tja11xx_cable_test_report_trans(u32 result)\n{\n\tu32 mask = MII_EXTSTAT_SHORT_DETECT | MII_EXTSTAT_OPEN_DETECT;\n\n\tif ((result & mask) == mask) {\n\t\t \n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_UNSPEC;\n\t} else if ((result & mask) == 0) {\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_OK;\n\t} else if (result & MII_EXTSTAT_SHORT_DETECT) {\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_SAME_SHORT;\n\t} else if (result & MII_EXTSTAT_OPEN_DETECT) {\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_OPEN;\n\t} else {\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_UNSPEC;\n\t}\n}\n\nstatic int tja11xx_cable_test_report(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = phy_read(phydev, MII_EXTSTAT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tethnl_cable_test_result(phydev, ETHTOOL_A_CABLE_PAIR_A,\n\t\t\t\ttja11xx_cable_test_report_trans(ret));\n\n\treturn 0;\n}\n\nstatic int tja11xx_cable_test_get_status(struct phy_device *phydev,\n\t\t\t\t\t bool *finished)\n{\n\tint ret;\n\n\t*finished = false;\n\n\tret = phy_read(phydev, MII_ECTRL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!(ret & MII_ECTRL_CABLE_TEST)) {\n\t\t*finished = true;\n\n\t\tret = phy_set_bits(phydev, MII_COMMCFG, MII_COMMCFG_AUTO_OP);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn tja11xx_cable_test_report(phydev);\n\t}\n\n\treturn 0;\n}\n\nstatic struct phy_driver tja11xx_driver[] = {\n\t{\n\t\tPHY_ID_MATCH_MODEL(PHY_ID_TJA1100),\n\t\t.name\t\t= \"NXP TJA1100\",\n\t\t.features       = PHY_BASIC_T1_FEATURES,\n\t\t.probe\t\t= tja11xx_probe,\n\t\t.soft_reset\t= tja11xx_soft_reset,\n\t\t.config_aneg\t= tja11xx_config_aneg,\n\t\t.config_init\t= tja11xx_config_init,\n\t\t.read_status\t= tja11xx_read_status,\n\t\t.get_sqi\t= tja11xx_get_sqi,\n\t\t.get_sqi_max\t= tja11xx_get_sqi_max,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= genphy_resume,\n\t\t.set_loopback   = genphy_loopback,\n\t\t \n\t\t.get_sset_count = tja11xx_get_sset_count,\n\t\t.get_strings\t= tja11xx_get_strings,\n\t\t.get_stats\t= tja11xx_get_stats,\n\t}, {\n\t\tPHY_ID_MATCH_MODEL(PHY_ID_TJA1101),\n\t\t.name\t\t= \"NXP TJA1101\",\n\t\t.features       = PHY_BASIC_T1_FEATURES,\n\t\t.probe\t\t= tja11xx_probe,\n\t\t.soft_reset\t= tja11xx_soft_reset,\n\t\t.config_aneg\t= tja11xx_config_aneg,\n\t\t.config_init\t= tja11xx_config_init,\n\t\t.read_status\t= tja11xx_read_status,\n\t\t.get_sqi\t= tja11xx_get_sqi,\n\t\t.get_sqi_max\t= tja11xx_get_sqi_max,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= genphy_resume,\n\t\t.set_loopback   = genphy_loopback,\n\t\t \n\t\t.get_sset_count = tja11xx_get_sset_count,\n\t\t.get_strings\t= tja11xx_get_strings,\n\t\t.get_stats\t= tja11xx_get_stats,\n\t}, {\n\t\t.name\t\t= \"NXP TJA1102 Port 0\",\n\t\t.features       = PHY_BASIC_T1_FEATURES,\n\t\t.flags          = PHY_POLL_CABLE_TEST,\n\t\t.probe\t\t= tja1102_p0_probe,\n\t\t.soft_reset\t= tja11xx_soft_reset,\n\t\t.config_aneg\t= tja11xx_config_aneg,\n\t\t.config_init\t= tja11xx_config_init,\n\t\t.read_status\t= tja11xx_read_status,\n\t\t.get_sqi\t= tja11xx_get_sqi,\n\t\t.get_sqi_max\t= tja11xx_get_sqi_max,\n\t\t.match_phy_device = tja1102_p0_match_phy_device,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= genphy_resume,\n\t\t.set_loopback   = genphy_loopback,\n\t\t \n\t\t.get_sset_count = tja11xx_get_sset_count,\n\t\t.get_strings\t= tja11xx_get_strings,\n\t\t.get_stats\t= tja11xx_get_stats,\n\t\t.config_intr\t= tja11xx_config_intr,\n\t\t.handle_interrupt = tja11xx_handle_interrupt,\n\t\t.cable_test_start = tja11xx_cable_test_start,\n\t\t.cable_test_get_status = tja11xx_cable_test_get_status,\n\t}, {\n\t\t.name\t\t= \"NXP TJA1102 Port 1\",\n\t\t.features       = PHY_BASIC_T1_FEATURES,\n\t\t.flags          = PHY_POLL_CABLE_TEST,\n\t\t \n\t\t.soft_reset\t= tja11xx_soft_reset,\n\t\t.config_aneg\t= tja11xx_config_aneg,\n\t\t.config_init\t= tja11xx_config_init,\n\t\t.read_status\t= tja11xx_read_status,\n\t\t.get_sqi\t= tja11xx_get_sqi,\n\t\t.get_sqi_max\t= tja11xx_get_sqi_max,\n\t\t.match_phy_device = tja1102_p1_match_phy_device,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= genphy_resume,\n\t\t.set_loopback   = genphy_loopback,\n\t\t \n\t\t.get_sset_count = tja11xx_get_sset_count,\n\t\t.get_strings\t= tja11xx_get_strings,\n\t\t.get_stats\t= tja11xx_get_stats,\n\t\t.config_intr\t= tja11xx_config_intr,\n\t\t.handle_interrupt = tja11xx_handle_interrupt,\n\t\t.cable_test_start = tja11xx_cable_test_start,\n\t\t.cable_test_get_status = tja11xx_cable_test_get_status,\n\t}\n};\n\nmodule_phy_driver(tja11xx_driver);\n\nstatic struct mdio_device_id __maybe_unused tja11xx_tbl[] = {\n\t{ PHY_ID_MATCH_MODEL(PHY_ID_TJA1100) },\n\t{ PHY_ID_MATCH_MODEL(PHY_ID_TJA1101) },\n\t{ PHY_ID_MATCH_MODEL(PHY_ID_TJA1102) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(mdio, tja11xx_tbl);\n\nMODULE_AUTHOR(\"Marek Vasut <marex@denx.de>\");\nMODULE_DESCRIPTION(\"NXP TJA11xx BoardR-Reach PHY driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}