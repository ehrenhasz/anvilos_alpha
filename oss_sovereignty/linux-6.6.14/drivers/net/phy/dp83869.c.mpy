{
  "module_name": "dp83869.c",
  "hash_id": "bc3641b8590afd4e3ad6de9294e1d4b500d4f874f065e80b19caee2e42c2dbd8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/dp83869.c",
  "human_readable_source": "\n \n\n#include <linux/ethtool.h>\n#include <linux/etherdevice.h>\n#include <linux/kernel.h>\n#include <linux/mii.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy.h>\n#include <linux/delay.h>\n#include <linux/bitfield.h>\n\n#include <dt-bindings/net/ti-dp83869.h>\n\n#define DP83869_PHY_ID\t\t0x2000a0f1\n#define DP83561_PHY_ID\t\t0x2000a1a4\n#define DP83869_DEVADDR\t\t0x1f\n\n#define MII_DP83869_PHYCTRL\t0x10\n#define MII_DP83869_MICR\t0x12\n#define MII_DP83869_ISR\t\t0x13\n#define DP83869_CFG2\t\t0x14\n#define DP83869_CTRL\t\t0x1f\n#define DP83869_CFG4\t\t0x1e\n\n \n#define DP83869_GEN_CFG3        0x0031\n#define DP83869_RGMIICTL\t0x0032\n#define DP83869_STRAP_STS1\t0x006e\n#define DP83869_RGMIIDCTL\t0x0086\n#define DP83869_RXFCFG\t\t0x0134\n#define DP83869_RXFPMD1\t\t0x0136\n#define DP83869_RXFPMD2\t\t0x0137\n#define DP83869_RXFPMD3\t\t0x0138\n#define DP83869_RXFSOP1\t\t0x0139\n#define DP83869_RXFSOP2\t\t0x013A\n#define DP83869_RXFSOP3\t\t0x013B\n#define DP83869_IO_MUX_CFG\t0x0170\n#define DP83869_OP_MODE\t\t0x01df\n#define DP83869_FX_CTRL\t\t0x0c00\n\n#define DP83869_SW_RESET\tBIT(15)\n#define DP83869_SW_RESTART\tBIT(14)\n\n \n#define MII_DP83869_MICR_AN_ERR_INT_EN\t\tBIT(15)\n#define MII_DP83869_MICR_SPEED_CHNG_INT_EN\tBIT(14)\n#define MII_DP83869_MICR_DUP_MODE_CHNG_INT_EN\tBIT(13)\n#define MII_DP83869_MICR_PAGE_RXD_INT_EN\tBIT(12)\n#define MII_DP83869_MICR_AUTONEG_COMP_INT_EN\tBIT(11)\n#define MII_DP83869_MICR_LINK_STS_CHNG_INT_EN\tBIT(10)\n#define MII_DP83869_MICR_FALSE_CARRIER_INT_EN\tBIT(8)\n#define MII_DP83869_MICR_SLEEP_MODE_CHNG_INT_EN\tBIT(4)\n#define MII_DP83869_MICR_WOL_INT_EN\t\tBIT(3)\n#define MII_DP83869_MICR_XGMII_ERR_INT_EN\tBIT(2)\n#define MII_DP83869_MICR_POL_CHNG_INT_EN\tBIT(1)\n#define MII_DP83869_MICR_JABBER_INT_EN\t\tBIT(0)\n\n#define MII_DP83869_BMCR_DEFAULT\t(BMCR_ANENABLE | \\\n\t\t\t\t\t BMCR_FULLDPLX | \\\n\t\t\t\t\t BMCR_SPEED1000)\n\n#define MII_DP83869_FIBER_ADVERTISE    (ADVERTISED_FIBRE | \\\n\t\t\t\t\tADVERTISED_Pause | \\\n\t\t\t\t\tADVERTISED_Asym_Pause)\n\n \n#define DP83869_FX_CTRL_DEFAULT\tMII_DP83869_BMCR_DEFAULT\n\n \n#define DP83869_CFG1_DEFAULT\t(ADVERTISE_1000HALF | \\\n\t\t\t\t ADVERTISE_1000FULL | \\\n\t\t\t\t CTL1000_AS_MASTER)\n\n \n#define DP83869_RGMII_TX_CLK_DELAY_EN\t\tBIT(1)\n#define DP83869_RGMII_RX_CLK_DELAY_EN\t\tBIT(0)\n\n \n#define DP83869_RGMII_CLK_DELAY_SHIFT\t\t4\n#define DP83869_CLK_DELAY_DEF\t\t\t7\n\n \n#define DP83869_STRAP_OP_MODE_MASK\t\tGENMASK(2, 0)\n#define DP83869_STRAP_STS1_RESERVED\t\tBIT(11)\n#define DP83869_STRAP_MIRROR_ENABLED           BIT(12)\n\n \n#define DP83869_RX_FIFO_SHIFT\t12\n#define DP83869_TX_FIFO_SHIFT\t14\n\n \n#define DP83869_PHY_CTRL_DEFAULT\t0x48\n#define DP83869_PHYCR_FIFO_DEPTH_MASK\tGENMASK(15, 12)\n#define DP83869_PHYCR_RESERVED_MASK\tBIT(11)\n\n \n#define DP83869_IO_MUX_CFG_IO_IMPEDANCE_CTRL\t0x1f\n\n#define DP83869_IO_MUX_CFG_IO_IMPEDANCE_MAX\t0x0\n#define DP83869_IO_MUX_CFG_IO_IMPEDANCE_MIN\t0x1f\n#define DP83869_IO_MUX_CFG_CLK_O_SEL_MASK\t(0x1f << 8)\n#define DP83869_IO_MUX_CFG_CLK_O_SEL_SHIFT\t8\n\n \n#define DP83869_CFG3_PORT_MIRROR_EN              BIT(0)\n\n \n#define DP83869_INT_OE\tBIT(7)\n\n \n#define DP83869_OP_MODE_MII\t\t\tBIT(5)\n#define DP83869_SGMII_RGMII_BRIDGE\t\tBIT(6)\n\n \n#define DP83869_WOL_MAGIC_EN\t\tBIT(0)\n#define DP83869_WOL_PATTERN_EN\t\tBIT(1)\n#define DP83869_WOL_BCAST_EN\t\tBIT(2)\n#define DP83869_WOL_UCAST_EN\t\tBIT(4)\n#define DP83869_WOL_SEC_EN\t\tBIT(5)\n#define DP83869_WOL_ENH_MAC\t\tBIT(7)\n\n \n#define DP83869_DOWNSHIFT_EN\t\t(BIT(8) | BIT(9))\n#define DP83869_DOWNSHIFT_ATTEMPT_MASK\t(BIT(10) | BIT(11))\n#define DP83869_DOWNSHIFT_1_COUNT_VAL\t0\n#define DP83869_DOWNSHIFT_2_COUNT_VAL\t1\n#define DP83869_DOWNSHIFT_4_COUNT_VAL\t2\n#define DP83869_DOWNSHIFT_8_COUNT_VAL\t3\n#define DP83869_DOWNSHIFT_1_COUNT\t1\n#define DP83869_DOWNSHIFT_2_COUNT\t2\n#define DP83869_DOWNSHIFT_4_COUNT\t4\n#define DP83869_DOWNSHIFT_8_COUNT\t8\n\nenum {\n\tDP83869_PORT_MIRRORING_KEEP,\n\tDP83869_PORT_MIRRORING_EN,\n\tDP83869_PORT_MIRRORING_DIS,\n};\n\nstruct dp83869_private {\n\tint tx_fifo_depth;\n\tint rx_fifo_depth;\n\ts32 rx_int_delay;\n\ts32 tx_int_delay;\n\tint io_impedance;\n\tint port_mirroring;\n\tbool rxctrl_strap_quirk;\n\tint clk_output_sel;\n\tint mode;\n};\n\nstatic int dp83869_read_status(struct phy_device *phydev)\n{\n\tstruct dp83869_private *dp83869 = phydev->priv;\n\tint ret;\n\n\tret = genphy_read_status(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (linkmode_test_bit(ETHTOOL_LINK_MODE_FIBRE_BIT, phydev->supported)) {\n\t\tif (phydev->link) {\n\t\t\tif (dp83869->mode == DP83869_RGMII_100_BASE)\n\t\t\t\tphydev->speed = SPEED_100;\n\t\t} else {\n\t\t\tphydev->speed = SPEED_UNKNOWN;\n\t\t\tphydev->duplex = DUPLEX_UNKNOWN;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dp83869_ack_interrupt(struct phy_device *phydev)\n{\n\tint err = phy_read(phydev, MII_DP83869_ISR);\n\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int dp83869_config_intr(struct phy_device *phydev)\n{\n\tint micr_status = 0, err;\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\terr = dp83869_ack_interrupt(phydev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tmicr_status = phy_read(phydev, MII_DP83869_MICR);\n\t\tif (micr_status < 0)\n\t\t\treturn micr_status;\n\n\t\tmicr_status |=\n\t\t\t(MII_DP83869_MICR_AN_ERR_INT_EN |\n\t\t\tMII_DP83869_MICR_SPEED_CHNG_INT_EN |\n\t\t\tMII_DP83869_MICR_AUTONEG_COMP_INT_EN |\n\t\t\tMII_DP83869_MICR_LINK_STS_CHNG_INT_EN |\n\t\t\tMII_DP83869_MICR_DUP_MODE_CHNG_INT_EN |\n\t\t\tMII_DP83869_MICR_SLEEP_MODE_CHNG_INT_EN);\n\n\t\terr = phy_write(phydev, MII_DP83869_MICR, micr_status);\n\t} else {\n\t\terr = phy_write(phydev, MII_DP83869_MICR, micr_status);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = dp83869_ack_interrupt(phydev);\n\t}\n\n\treturn err;\n}\n\nstatic irqreturn_t dp83869_handle_interrupt(struct phy_device *phydev)\n{\n\tint irq_status, irq_enabled;\n\n\tirq_status = phy_read(phydev, MII_DP83869_ISR);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tirq_enabled = phy_read(phydev, MII_DP83869_MICR);\n\tif (irq_enabled < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (!(irq_status & irq_enabled))\n\t\treturn IRQ_NONE;\n\n\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int dp83869_set_wol(struct phy_device *phydev,\n\t\t\t   struct ethtool_wolinfo *wol)\n{\n\tstruct net_device *ndev = phydev->attached_dev;\n\tint val_rxcfg, val_micr;\n\tconst u8 *mac;\n\tint ret;\n\n\tval_rxcfg = phy_read_mmd(phydev, DP83869_DEVADDR, DP83869_RXFCFG);\n\tif (val_rxcfg < 0)\n\t\treturn val_rxcfg;\n\n\tval_micr = phy_read(phydev, MII_DP83869_MICR);\n\tif (val_micr < 0)\n\t\treturn val_micr;\n\n\tif (wol->wolopts & (WAKE_MAGIC | WAKE_MAGICSECURE | WAKE_UCAST |\n\t\t\t    WAKE_BCAST)) {\n\t\tval_rxcfg |= DP83869_WOL_ENH_MAC;\n\t\tval_micr |= MII_DP83869_MICR_WOL_INT_EN;\n\n\t\tif (wol->wolopts & WAKE_MAGIC ||\n\t\t    wol->wolopts & WAKE_MAGICSECURE) {\n\t\t\tmac = (const u8 *)ndev->dev_addr;\n\n\t\t\tif (!is_valid_ether_addr(mac))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tret = phy_write_mmd(phydev, DP83869_DEVADDR,\n\t\t\t\t\t    DP83869_RXFPMD1,\n\t\t\t\t\t    mac[1] << 8 | mac[0]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = phy_write_mmd(phydev, DP83869_DEVADDR,\n\t\t\t\t\t    DP83869_RXFPMD2,\n\t\t\t\t\t    mac[3] << 8 | mac[2]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = phy_write_mmd(phydev, DP83869_DEVADDR,\n\t\t\t\t\t    DP83869_RXFPMD3,\n\t\t\t\t\t    mac[5] << 8 | mac[4]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tval_rxcfg |= DP83869_WOL_MAGIC_EN;\n\t\t} else {\n\t\t\tval_rxcfg &= ~DP83869_WOL_MAGIC_EN;\n\t\t}\n\n\t\tif (wol->wolopts & WAKE_MAGICSECURE) {\n\t\t\tret = phy_write_mmd(phydev, DP83869_DEVADDR,\n\t\t\t\t\t    DP83869_RXFSOP1,\n\t\t\t\t\t    (wol->sopass[1] << 8) | wol->sopass[0]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = phy_write_mmd(phydev, DP83869_DEVADDR,\n\t\t\t\t\t    DP83869_RXFSOP2,\n\t\t\t\t\t    (wol->sopass[3] << 8) | wol->sopass[2]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tret = phy_write_mmd(phydev, DP83869_DEVADDR,\n\t\t\t\t\t    DP83869_RXFSOP3,\n\t\t\t\t\t    (wol->sopass[5] << 8) | wol->sopass[4]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tval_rxcfg |= DP83869_WOL_SEC_EN;\n\t\t} else {\n\t\t\tval_rxcfg &= ~DP83869_WOL_SEC_EN;\n\t\t}\n\n\t\tif (wol->wolopts & WAKE_UCAST)\n\t\t\tval_rxcfg |= DP83869_WOL_UCAST_EN;\n\t\telse\n\t\t\tval_rxcfg &= ~DP83869_WOL_UCAST_EN;\n\n\t\tif (wol->wolopts & WAKE_BCAST)\n\t\t\tval_rxcfg |= DP83869_WOL_BCAST_EN;\n\t\telse\n\t\t\tval_rxcfg &= ~DP83869_WOL_BCAST_EN;\n\t} else {\n\t\tval_rxcfg &= ~DP83869_WOL_ENH_MAC;\n\t\tval_micr &= ~MII_DP83869_MICR_WOL_INT_EN;\n\t}\n\n\tret = phy_write_mmd(phydev, DP83869_DEVADDR, DP83869_RXFCFG, val_rxcfg);\n\tif (ret)\n\t\treturn ret;\n\n\treturn phy_write(phydev, MII_DP83869_MICR, val_micr);\n}\n\nstatic void dp83869_get_wol(struct phy_device *phydev,\n\t\t\t    struct ethtool_wolinfo *wol)\n{\n\tint value, sopass_val;\n\n\twol->supported = (WAKE_UCAST | WAKE_BCAST | WAKE_MAGIC |\n\t\t\tWAKE_MAGICSECURE);\n\twol->wolopts = 0;\n\n\tvalue = phy_read_mmd(phydev, DP83869_DEVADDR, DP83869_RXFCFG);\n\tif (value < 0) {\n\t\tphydev_err(phydev, \"Failed to read RX CFG\\n\");\n\t\treturn;\n\t}\n\n\tif (value & DP83869_WOL_UCAST_EN)\n\t\twol->wolopts |= WAKE_UCAST;\n\n\tif (value & DP83869_WOL_BCAST_EN)\n\t\twol->wolopts |= WAKE_BCAST;\n\n\tif (value & DP83869_WOL_MAGIC_EN)\n\t\twol->wolopts |= WAKE_MAGIC;\n\n\tif (value & DP83869_WOL_SEC_EN) {\n\t\tsopass_val = phy_read_mmd(phydev, DP83869_DEVADDR,\n\t\t\t\t\t  DP83869_RXFSOP1);\n\t\tif (sopass_val < 0) {\n\t\t\tphydev_err(phydev, \"Failed to read RX SOP 1\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\twol->sopass[0] = (sopass_val & 0xff);\n\t\twol->sopass[1] = (sopass_val >> 8);\n\n\t\tsopass_val = phy_read_mmd(phydev, DP83869_DEVADDR,\n\t\t\t\t\t  DP83869_RXFSOP2);\n\t\tif (sopass_val < 0) {\n\t\t\tphydev_err(phydev, \"Failed to read RX SOP 2\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\twol->sopass[2] = (sopass_val & 0xff);\n\t\twol->sopass[3] = (sopass_val >> 8);\n\n\t\tsopass_val = phy_read_mmd(phydev, DP83869_DEVADDR,\n\t\t\t\t\t  DP83869_RXFSOP3);\n\t\tif (sopass_val < 0) {\n\t\t\tphydev_err(phydev, \"Failed to read RX SOP 3\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\twol->sopass[4] = (sopass_val & 0xff);\n\t\twol->sopass[5] = (sopass_val >> 8);\n\n\t\twol->wolopts |= WAKE_MAGICSECURE;\n\t}\n\n\tif (!(value & DP83869_WOL_ENH_MAC))\n\t\twol->wolopts = 0;\n}\n\nstatic int dp83869_get_downshift(struct phy_device *phydev, u8 *data)\n{\n\tint val, cnt, enable, count;\n\n\tval = phy_read(phydev, DP83869_CFG2);\n\tif (val < 0)\n\t\treturn val;\n\n\tenable = FIELD_GET(DP83869_DOWNSHIFT_EN, val);\n\tcnt = FIELD_GET(DP83869_DOWNSHIFT_ATTEMPT_MASK, val);\n\n\tswitch (cnt) {\n\tcase DP83869_DOWNSHIFT_1_COUNT_VAL:\n\t\tcount = DP83869_DOWNSHIFT_1_COUNT;\n\t\tbreak;\n\tcase DP83869_DOWNSHIFT_2_COUNT_VAL:\n\t\tcount = DP83869_DOWNSHIFT_2_COUNT;\n\t\tbreak;\n\tcase DP83869_DOWNSHIFT_4_COUNT_VAL:\n\t\tcount = DP83869_DOWNSHIFT_4_COUNT;\n\t\tbreak;\n\tcase DP83869_DOWNSHIFT_8_COUNT_VAL:\n\t\tcount = DP83869_DOWNSHIFT_8_COUNT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*data = enable ? count : DOWNSHIFT_DEV_DISABLE;\n\n\treturn 0;\n}\n\nstatic int dp83869_set_downshift(struct phy_device *phydev, u8 cnt)\n{\n\tint val, count;\n\n\tif (cnt > DP83869_DOWNSHIFT_8_COUNT)\n\t\treturn -EINVAL;\n\n\tif (!cnt)\n\t\treturn phy_clear_bits(phydev, DP83869_CFG2,\n\t\t\t\t      DP83869_DOWNSHIFT_EN);\n\n\tswitch (cnt) {\n\tcase DP83869_DOWNSHIFT_1_COUNT:\n\t\tcount = DP83869_DOWNSHIFT_1_COUNT_VAL;\n\t\tbreak;\n\tcase DP83869_DOWNSHIFT_2_COUNT:\n\t\tcount = DP83869_DOWNSHIFT_2_COUNT_VAL;\n\t\tbreak;\n\tcase DP83869_DOWNSHIFT_4_COUNT:\n\t\tcount = DP83869_DOWNSHIFT_4_COUNT_VAL;\n\t\tbreak;\n\tcase DP83869_DOWNSHIFT_8_COUNT:\n\t\tcount = DP83869_DOWNSHIFT_8_COUNT_VAL;\n\t\tbreak;\n\tdefault:\n\t\tphydev_err(phydev,\n\t\t\t   \"Downshift count must be 1, 2, 4 or 8\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tval = DP83869_DOWNSHIFT_EN;\n\tval |= FIELD_PREP(DP83869_DOWNSHIFT_ATTEMPT_MASK, count);\n\n\treturn phy_modify(phydev, DP83869_CFG2,\n\t\t\t  DP83869_DOWNSHIFT_EN | DP83869_DOWNSHIFT_ATTEMPT_MASK,\n\t\t\t  val);\n}\n\nstatic int dp83869_get_tunable(struct phy_device *phydev,\n\t\t\t       struct ethtool_tunable *tuna, void *data)\n{\n\tswitch (tuna->id) {\n\tcase ETHTOOL_PHY_DOWNSHIFT:\n\t\treturn dp83869_get_downshift(phydev, data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int dp83869_set_tunable(struct phy_device *phydev,\n\t\t\t       struct ethtool_tunable *tuna, const void *data)\n{\n\tswitch (tuna->id) {\n\tcase ETHTOOL_PHY_DOWNSHIFT:\n\t\treturn dp83869_set_downshift(phydev, *(const u8 *)data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int dp83869_config_port_mirroring(struct phy_device *phydev)\n{\n\tstruct dp83869_private *dp83869 = phydev->priv;\n\n\tif (dp83869->port_mirroring == DP83869_PORT_MIRRORING_EN)\n\t\treturn phy_set_bits_mmd(phydev, DP83869_DEVADDR,\n\t\t\t\t\tDP83869_GEN_CFG3,\n\t\t\t\t\tDP83869_CFG3_PORT_MIRROR_EN);\n\telse\n\t\treturn phy_clear_bits_mmd(phydev, DP83869_DEVADDR,\n\t\t\t\t\t  DP83869_GEN_CFG3,\n\t\t\t\t\t  DP83869_CFG3_PORT_MIRROR_EN);\n}\n\nstatic int dp83869_set_strapped_mode(struct phy_device *phydev)\n{\n\tstruct dp83869_private *dp83869 = phydev->priv;\n\tint val;\n\n\tval = phy_read_mmd(phydev, DP83869_DEVADDR, DP83869_STRAP_STS1);\n\tif (val < 0)\n\t\treturn val;\n\n\tdp83869->mode = val & DP83869_STRAP_OP_MODE_MASK;\n\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_OF_MDIO)\nstatic const int dp83869_internal_delay[] = {250, 500, 750, 1000, 1250, 1500,\n\t\t\t\t\t     1750, 2000, 2250, 2500, 2750, 3000,\n\t\t\t\t\t     3250, 3500, 3750, 4000};\n\nstatic int dp83869_of_init(struct phy_device *phydev)\n{\n\tstruct dp83869_private *dp83869 = phydev->priv;\n\tstruct device *dev = &phydev->mdio.dev;\n\tstruct device_node *of_node = dev->of_node;\n\tint delay_size = ARRAY_SIZE(dp83869_internal_delay);\n\tint ret;\n\n\tif (!of_node)\n\t\treturn -ENODEV;\n\n\tdp83869->io_impedance = -EINVAL;\n\n\t \n\tret = of_property_read_u32(of_node, \"ti,clk-output-sel\",\n\t\t\t\t   &dp83869->clk_output_sel);\n\tif (ret || dp83869->clk_output_sel > DP83869_CLK_O_SEL_REF_CLK)\n\t\tdp83869->clk_output_sel = DP83869_CLK_O_SEL_REF_CLK;\n\n\tret = of_property_read_u32(of_node, \"ti,op-mode\", &dp83869->mode);\n\tif (ret == 0) {\n\t\tif (dp83869->mode < DP83869_RGMII_COPPER_ETHERNET ||\n\t\t    dp83869->mode > DP83869_SGMII_COPPER_ETHERNET)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tret = dp83869_set_strapped_mode(phydev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (of_property_read_bool(of_node, \"ti,max-output-impedance\"))\n\t\tdp83869->io_impedance = DP83869_IO_MUX_CFG_IO_IMPEDANCE_MAX;\n\telse if (of_property_read_bool(of_node, \"ti,min-output-impedance\"))\n\t\tdp83869->io_impedance = DP83869_IO_MUX_CFG_IO_IMPEDANCE_MIN;\n\n\tif (of_property_read_bool(of_node, \"enet-phy-lane-swap\")) {\n\t\tdp83869->port_mirroring = DP83869_PORT_MIRRORING_EN;\n\t} else {\n\t\t \n\t\tret = phy_read_mmd(phydev, DP83869_DEVADDR, DP83869_STRAP_STS1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (ret & DP83869_STRAP_MIRROR_ENABLED)\n\t\t\tdp83869->port_mirroring = DP83869_PORT_MIRRORING_EN;\n\t\telse\n\t\t\tdp83869->port_mirroring = DP83869_PORT_MIRRORING_DIS;\n\n\t\tret = 0;\n\t}\n\n\tif (of_property_read_u32(of_node, \"rx-fifo-depth\",\n\t\t\t\t &dp83869->rx_fifo_depth))\n\t\tdp83869->rx_fifo_depth = DP83869_PHYCR_FIFO_DEPTH_4_B_NIB;\n\n\tif (of_property_read_u32(of_node, \"tx-fifo-depth\",\n\t\t\t\t &dp83869->tx_fifo_depth))\n\t\tdp83869->tx_fifo_depth = DP83869_PHYCR_FIFO_DEPTH_4_B_NIB;\n\n\tdp83869->rx_int_delay = phy_get_internal_delay(phydev, dev,\n\t\t\t\t\t\t       &dp83869_internal_delay[0],\n\t\t\t\t\t\t       delay_size, true);\n\tif (dp83869->rx_int_delay < 0)\n\t\tdp83869->rx_int_delay = DP83869_CLK_DELAY_DEF;\n\n\tdp83869->tx_int_delay = phy_get_internal_delay(phydev, dev,\n\t\t\t\t\t\t       &dp83869_internal_delay[0],\n\t\t\t\t\t\t       delay_size, false);\n\tif (dp83869->tx_int_delay < 0)\n\t\tdp83869->tx_int_delay = DP83869_CLK_DELAY_DEF;\n\n\treturn ret;\n}\n#else\nstatic int dp83869_of_init(struct phy_device *phydev)\n{\n\treturn dp83869_set_strapped_mode(phydev);\n}\n#endif  \n\nstatic int dp83869_configure_rgmii(struct phy_device *phydev,\n\t\t\t\t   struct dp83869_private *dp83869)\n{\n\tint ret = 0, val;\n\n\tif (phy_interface_is_rgmii(phydev)) {\n\t\tval = phy_read(phydev, MII_DP83869_PHYCTRL);\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tval &= ~DP83869_PHYCR_FIFO_DEPTH_MASK;\n\t\tval |= (dp83869->tx_fifo_depth << DP83869_TX_FIFO_SHIFT);\n\t\tval |= (dp83869->rx_fifo_depth << DP83869_RX_FIFO_SHIFT);\n\n\t\tret = phy_write(phydev, MII_DP83869_PHYCTRL, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (dp83869->io_impedance >= 0)\n\t\tret = phy_modify_mmd(phydev, DP83869_DEVADDR,\n\t\t\t\t     DP83869_IO_MUX_CFG,\n\t\t\t\t     DP83869_IO_MUX_CFG_IO_IMPEDANCE_CTRL,\n\t\t\t\t     dp83869->io_impedance &\n\t\t\t\t     DP83869_IO_MUX_CFG_IO_IMPEDANCE_CTRL);\n\n\treturn ret;\n}\n\nstatic int dp83869_configure_fiber(struct phy_device *phydev,\n\t\t\t\t   struct dp83869_private *dp83869)\n{\n\tint bmcr;\n\tint ret;\n\n\t \n\tlinkmode_and(phydev->advertising, phydev->advertising,\n\t\t     phydev->supported);\n\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FIBRE_BIT, phydev->supported);\n\tlinkmode_set_bit(ADVERTISED_FIBRE, phydev->advertising);\n\n\tif (dp83869->mode == DP83869_RGMII_1000_BASE) {\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT,\n\t\t\t\t phydev->supported);\n\t} else {\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100baseFX_Full_BIT,\n\t\t\t\t phydev->supported);\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100baseFX_Half_BIT,\n\t\t\t\t phydev->supported);\n\n\t\t \n\t\tbmcr = phy_read(phydev, MII_BMCR);\n\t\tif (bmcr < 0)\n\t\t\treturn bmcr;\n\n\t\tphydev->autoneg = AUTONEG_DISABLE;\n\t\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, phydev->supported);\n\t\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, phydev->advertising);\n\n\t\tif (bmcr & BMCR_ANENABLE) {\n\t\t\tret =  phy_modify(phydev, MII_BMCR, BMCR_ANENABLE, 0);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tlinkmode_or(phydev->advertising, phydev->advertising,\n\t\t    phydev->supported);\n\n\treturn 0;\n}\n\nstatic int dp83869_configure_mode(struct phy_device *phydev,\n\t\t\t\t  struct dp83869_private *dp83869)\n{\n\tint phy_ctrl_val;\n\tint ret;\n\n\tif (dp83869->mode < DP83869_RGMII_COPPER_ETHERNET ||\n\t    dp83869->mode > DP83869_SGMII_COPPER_ETHERNET)\n\t\treturn -EINVAL;\n\n\t \n\tphy_ctrl_val = dp83869->mode;\n\tif (phydev->interface == PHY_INTERFACE_MODE_MII) {\n\t\tif (dp83869->mode == DP83869_100M_MEDIA_CONVERT ||\n\t\t    dp83869->mode == DP83869_RGMII_100_BASE) {\n\t\t\tphy_ctrl_val |= DP83869_OP_MODE_MII;\n\t\t} else {\n\t\t\tphydev_err(phydev, \"selected op-mode is not valid with MII mode\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tret = phy_write_mmd(phydev, DP83869_DEVADDR, DP83869_OP_MODE,\n\t\t\t    phy_ctrl_val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_write(phydev, MII_BMCR, MII_DP83869_BMCR_DEFAULT);\n\tif (ret)\n\t\treturn ret;\n\n\tphy_ctrl_val = (dp83869->rx_fifo_depth << DP83869_RX_FIFO_SHIFT |\n\t\t\tdp83869->tx_fifo_depth << DP83869_TX_FIFO_SHIFT |\n\t\t\tDP83869_PHY_CTRL_DEFAULT);\n\n\tswitch (dp83869->mode) {\n\tcase DP83869_RGMII_COPPER_ETHERNET:\n\t\tret = phy_write(phydev, MII_DP83869_PHYCTRL,\n\t\t\t\tphy_ctrl_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = phy_write(phydev, MII_CTRL1000, DP83869_CFG1_DEFAULT);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = dp83869_configure_rgmii(phydev, dp83869);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase DP83869_RGMII_SGMII_BRIDGE:\n\t\tret = phy_modify_mmd(phydev, DP83869_DEVADDR, DP83869_OP_MODE,\n\t\t\t\t     DP83869_SGMII_RGMII_BRIDGE,\n\t\t\t\t     DP83869_SGMII_RGMII_BRIDGE);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = phy_write_mmd(phydev, DP83869_DEVADDR,\n\t\t\t\t    DP83869_FX_CTRL, DP83869_FX_CTRL_DEFAULT);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbreak;\n\tcase DP83869_1000M_MEDIA_CONVERT:\n\t\tret = phy_write(phydev, MII_DP83869_PHYCTRL,\n\t\t\t\tphy_ctrl_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = phy_write_mmd(phydev, DP83869_DEVADDR,\n\t\t\t\t    DP83869_FX_CTRL, DP83869_FX_CTRL_DEFAULT);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase DP83869_100M_MEDIA_CONVERT:\n\t\tret = phy_write(phydev, MII_DP83869_PHYCTRL,\n\t\t\t\tphy_ctrl_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase DP83869_SGMII_COPPER_ETHERNET:\n\t\tret = phy_write(phydev, MII_DP83869_PHYCTRL,\n\t\t\t\tphy_ctrl_val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = phy_write(phydev, MII_CTRL1000, DP83869_CFG1_DEFAULT);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = phy_write_mmd(phydev, DP83869_DEVADDR,\n\t\t\t\t    DP83869_FX_CTRL, DP83869_FX_CTRL_DEFAULT);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tbreak;\n\tcase DP83869_RGMII_1000_BASE:\n\tcase DP83869_RGMII_100_BASE:\n\t\tret = dp83869_configure_fiber(phydev, dp83869);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int dp83869_config_init(struct phy_device *phydev)\n{\n\tstruct dp83869_private *dp83869 = phydev->priv;\n\tint ret, val;\n\n\t \n\tret = phy_modify(phydev, DP83869_CFG2, DP83869_DOWNSHIFT_EN,\n\t\t\t DP83869_DOWNSHIFT_EN);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dp83869_configure_mode(phydev, dp83869);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (phy_interrupt_is_valid(phydev)) {\n\t\tval = phy_read(phydev, DP83869_CFG4);\n\t\tval |= DP83869_INT_OE;\n\t\tphy_write(phydev, DP83869_CFG4, val);\n\t}\n\n\tif (dp83869->port_mirroring != DP83869_PORT_MIRRORING_KEEP)\n\t\tdp83869_config_port_mirroring(phydev);\n\n\t \n\tif (dp83869->clk_output_sel != DP83869_CLK_O_SEL_REF_CLK)\n\t\tret = phy_modify_mmd(phydev,\n\t\t\t\t     DP83869_DEVADDR, DP83869_IO_MUX_CFG,\n\t\t\t\t     DP83869_IO_MUX_CFG_CLK_O_SEL_MASK,\n\t\t\t\t     dp83869->clk_output_sel <<\n\t\t\t\t     DP83869_IO_MUX_CFG_CLK_O_SEL_SHIFT);\n\n\tif (phy_interface_is_rgmii(phydev)) {\n\t\tret = phy_write_mmd(phydev, DP83869_DEVADDR, DP83869_RGMIIDCTL,\n\t\t\t\t    dp83869->rx_int_delay |\n\t\t\tdp83869->tx_int_delay << DP83869_RGMII_CLK_DELAY_SHIFT);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval = phy_read_mmd(phydev, DP83869_DEVADDR, DP83869_RGMIICTL);\n\t\tval |= (DP83869_RGMII_TX_CLK_DELAY_EN |\n\t\t\tDP83869_RGMII_RX_CLK_DELAY_EN);\n\n\t\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID)\n\t\t\tval &= ~(DP83869_RGMII_TX_CLK_DELAY_EN |\n\t\t\t\t DP83869_RGMII_RX_CLK_DELAY_EN);\n\n\t\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID)\n\t\t\tval &= ~DP83869_RGMII_TX_CLK_DELAY_EN;\n\n\t\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID)\n\t\t\tval &= ~DP83869_RGMII_RX_CLK_DELAY_EN;\n\n\t\tret = phy_write_mmd(phydev, DP83869_DEVADDR, DP83869_RGMIICTL,\n\t\t\t\t    val);\n\t}\n\n\treturn ret;\n}\n\nstatic int dp83869_probe(struct phy_device *phydev)\n{\n\tstruct dp83869_private *dp83869;\n\tint ret;\n\n\tdp83869 = devm_kzalloc(&phydev->mdio.dev, sizeof(*dp83869),\n\t\t\t       GFP_KERNEL);\n\tif (!dp83869)\n\t\treturn -ENOMEM;\n\n\tphydev->priv = dp83869;\n\n\tret = dp83869_of_init(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (dp83869->mode == DP83869_RGMII_100_BASE ||\n\t    dp83869->mode == DP83869_RGMII_1000_BASE)\n\t\tphydev->port = PORT_FIBRE;\n\n\treturn dp83869_config_init(phydev);\n}\n\nstatic int dp83869_phy_reset(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = phy_write(phydev, DP83869_CTRL, DP83869_SW_RESET);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(10, 20);\n\n\t \n\treturn dp83869_config_init(phydev);\n}\n\n\n#define DP83869_PHY_DRIVER(_id, _name)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tPHY_ID_MATCH_MODEL(_id),\t\t\t\t\\\n\t.name\t\t= (_name),\t\t\t\t\\\n\t.probe          = dp83869_probe,\t\t\t\\\n\t.config_init\t= dp83869_config_init,\t\t\t\\\n\t.soft_reset\t= dp83869_phy_reset,\t\t\t\\\n\t.config_intr\t= dp83869_config_intr,\t\t\t\\\n\t.handle_interrupt = dp83869_handle_interrupt,\t\t\\\n\t.read_status\t= dp83869_read_status,\t\t\t\\\n\t.get_tunable\t= dp83869_get_tunable,\t\t\t\\\n\t.set_tunable\t= dp83869_set_tunable,\t\t\t\\\n\t.get_wol\t= dp83869_get_wol,\t\t\t\\\n\t.set_wol\t= dp83869_set_wol,\t\t\t\\\n\t.suspend\t= genphy_suspend,\t\t\t\\\n\t.resume\t\t= genphy_resume,\t\t\t\\\n}\n\nstatic struct phy_driver dp83869_driver[] = {\n\tDP83869_PHY_DRIVER(DP83869_PHY_ID, \"TI DP83869\"),\n\tDP83869_PHY_DRIVER(DP83561_PHY_ID, \"TI DP83561-SP\"),\n\n};\nmodule_phy_driver(dp83869_driver);\n\nstatic struct mdio_device_id __maybe_unused dp83869_tbl[] = {\n\t{ PHY_ID_MATCH_MODEL(DP83869_PHY_ID) },\n\t{ PHY_ID_MATCH_MODEL(DP83561_PHY_ID) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(mdio, dp83869_tbl);\n\nMODULE_DESCRIPTION(\"Texas Instruments DP83869 PHY driver\");\nMODULE_AUTHOR(\"Dan Murphy <dmurphy@ti.com\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}