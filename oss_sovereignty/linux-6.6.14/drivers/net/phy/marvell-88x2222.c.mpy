{
  "module_name": "marvell-88x2222.c",
  "hash_id": "dd93aa2c32cec05481d1c3ffe6708417a731f7beec41d0f7b1b780de14eb4e7d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/marvell-88x2222.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/phy.h>\n#include <linux/gpio.h>\n#include <linux/delay.h>\n#include <linux/mdio.h>\n#include <linux/marvell_phy.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/sfp.h>\n#include <linux/netdevice.h>\n\n \n#define\tMV_PCS_CONFIG\t\t0xF002\n#define\tMV_PCS_HOST_XAUI\t0x73\n#define\tMV_PCS_LINE_10GBR\t(0x71 << 8)\n#define\tMV_PCS_LINE_1GBX_AN\t(0x7B << 8)\n#define\tMV_PCS_LINE_SGMII_AN\t(0x7F << 8)\n\n \n#define\tMV_PORT_RST\t0xF003\n#define\tMV_LINE_RST_SW\tBIT(15)\n#define\tMV_HOST_RST_SW\tBIT(7)\n#define\tMV_PORT_RST_SW\t(MV_LINE_RST_SW | MV_HOST_RST_SW)\n\n \n#define\tMV_RX_SIGNAL_DETECT\t\t0x000A\n#define\tMV_RX_SIGNAL_DETECT_GLOBAL\tBIT(0)\n\n \n#define\tMV_1GBX_CTRL\t\t(0x2000 + MII_BMCR)\n\n \n#define\tMV_1GBX_STAT\t\t(0x2000 + MII_BMSR)\n\n \n#define\tMV_1GBX_ADVERTISE\t(0x2000 + MII_ADVERTISE)\n\n \n#define\tMV_1GBX_PHY_STAT\t\t0xA003\n#define\tMV_1GBX_PHY_STAT_AN_RESOLVED\tBIT(11)\n#define\tMV_1GBX_PHY_STAT_DUPLEX\t\tBIT(13)\n#define\tMV_1GBX_PHY_STAT_SPEED100\tBIT(14)\n#define\tMV_1GBX_PHY_STAT_SPEED1000\tBIT(15)\n\n#define\tAUTONEG_TIMEOUT\t3\n\nstruct mv2222_data {\n\tphy_interface_t line_interface;\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(supported);\n\tbool sfp_link;\n};\n\n \nstatic int mv2222_tx_enable(struct phy_device *phydev)\n{\n\treturn phy_clear_bits_mmd(phydev, MDIO_MMD_PMAPMD, MDIO_PMA_TXDIS,\n\t\t\t\t  MDIO_PMD_TXDIS_GLOBAL);\n}\n\n \nstatic int mv2222_tx_disable(struct phy_device *phydev)\n{\n\treturn phy_set_bits_mmd(phydev, MDIO_MMD_PMAPMD, MDIO_PMA_TXDIS,\n\t\t\t\tMDIO_PMD_TXDIS_GLOBAL);\n}\n\nstatic int mv2222_soft_reset(struct phy_device *phydev)\n{\n\tint val, ret;\n\n\tret = phy_write_mmd(phydev, MDIO_MMD_VEND2, MV_PORT_RST,\n\t\t\t    MV_PORT_RST_SW);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn phy_read_mmd_poll_timeout(phydev, MDIO_MMD_VEND2, MV_PORT_RST,\n\t\t\t\t\t val, !(val & MV_PORT_RST_SW),\n\t\t\t\t\t 5000, 1000000, true);\n}\n\nstatic int mv2222_disable_aneg(struct phy_device *phydev)\n{\n\tint ret = phy_clear_bits_mmd(phydev, MDIO_MMD_PCS, MV_1GBX_CTRL,\n\t\t\t\t     BMCR_ANENABLE | BMCR_ANRESTART);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn mv2222_soft_reset(phydev);\n}\n\nstatic int mv2222_enable_aneg(struct phy_device *phydev)\n{\n\tint ret = phy_set_bits_mmd(phydev, MDIO_MMD_PCS, MV_1GBX_CTRL,\n\t\t\t\t   BMCR_ANENABLE | BMCR_RESET);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn mv2222_soft_reset(phydev);\n}\n\nstatic int mv2222_set_sgmii_speed(struct phy_device *phydev)\n{\n\tstruct mv2222_data *priv = phydev->priv;\n\n\tswitch (phydev->speed) {\n\tdefault:\n\tcase SPEED_1000:\n\t\tif ((linkmode_test_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,\n\t\t\t\t       priv->supported) ||\n\t\t     linkmode_test_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT,\n\t\t\t\t       priv->supported)))\n\t\t\treturn phy_modify_mmd(phydev, MDIO_MMD_PCS,\n\t\t\t\t\t      MV_1GBX_CTRL,\n\t\t\t\t\t      BMCR_SPEED1000 | BMCR_SPEED100,\n\t\t\t\t\t      BMCR_SPEED1000);\n\n\t\tfallthrough;\n\tcase SPEED_100:\n\t\tif ((linkmode_test_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT,\n\t\t\t\t       priv->supported) ||\n\t\t     linkmode_test_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT,\n\t\t\t\t       priv->supported)))\n\t\t\treturn phy_modify_mmd(phydev, MDIO_MMD_PCS,\n\t\t\t\t\t      MV_1GBX_CTRL,\n\t\t\t\t\t      BMCR_SPEED1000 | BMCR_SPEED100,\n\t\t\t\t\t      BMCR_SPEED100);\n\t\tfallthrough;\n\tcase SPEED_10:\n\t\tif ((linkmode_test_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT,\n\t\t\t\t       priv->supported) ||\n\t\t     linkmode_test_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT,\n\t\t\t\t       priv->supported)))\n\t\t\treturn phy_modify_mmd(phydev, MDIO_MMD_PCS,\n\t\t\t\t\t      MV_1GBX_CTRL,\n\t\t\t\t\t      BMCR_SPEED1000 | BMCR_SPEED100,\n\t\t\t\t\t      BMCR_SPEED10);\n\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic bool mv2222_is_10g_capable(struct phy_device *phydev)\n{\n\tstruct mv2222_data *priv = phydev->priv;\n\n\treturn (linkmode_test_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT,\n\t\t\t\t  priv->supported) ||\n\t\tlinkmode_test_bit(ETHTOOL_LINK_MODE_10000baseCR_Full_BIT,\n\t\t\t\t  priv->supported) ||\n\t\tlinkmode_test_bit(ETHTOOL_LINK_MODE_10000baseSR_Full_BIT,\n\t\t\t\t  priv->supported) ||\n\t\tlinkmode_test_bit(ETHTOOL_LINK_MODE_10000baseLR_Full_BIT,\n\t\t\t\t  priv->supported) ||\n\t\tlinkmode_test_bit(ETHTOOL_LINK_MODE_10000baseLRM_Full_BIT,\n\t\t\t\t  priv->supported) ||\n\t\tlinkmode_test_bit(ETHTOOL_LINK_MODE_10000baseER_Full_BIT,\n\t\t\t\t  priv->supported));\n}\n\nstatic bool mv2222_is_1gbx_capable(struct phy_device *phydev)\n{\n\tstruct mv2222_data *priv = phydev->priv;\n\n\treturn linkmode_test_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT,\n\t\t\t\t priv->supported);\n}\n\nstatic bool mv2222_is_sgmii_capable(struct phy_device *phydev)\n{\n\tstruct mv2222_data *priv = phydev->priv;\n\n\treturn (linkmode_test_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,\n\t\t\t\t  priv->supported) ||\n\t\tlinkmode_test_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT,\n\t\t\t\t  priv->supported) ||\n\t\tlinkmode_test_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT,\n\t\t\t\t  priv->supported) ||\n\t\tlinkmode_test_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT,\n\t\t\t\t  priv->supported) ||\n\t\tlinkmode_test_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT,\n\t\t\t\t  priv->supported) ||\n\t\tlinkmode_test_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT,\n\t\t\t\t  priv->supported));\n}\n\nstatic int mv2222_config_line(struct phy_device *phydev)\n{\n\tstruct mv2222_data *priv = phydev->priv;\n\n\tswitch (priv->line_interface) {\n\tcase PHY_INTERFACE_MODE_10GBASER:\n\t\treturn phy_write_mmd(phydev, MDIO_MMD_VEND2, MV_PCS_CONFIG,\n\t\t\t\t     MV_PCS_HOST_XAUI | MV_PCS_LINE_10GBR);\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\t\treturn phy_write_mmd(phydev, MDIO_MMD_VEND2, MV_PCS_CONFIG,\n\t\t\t\t     MV_PCS_HOST_XAUI | MV_PCS_LINE_1GBX_AN);\n\tcase PHY_INTERFACE_MODE_SGMII:\n\t\treturn phy_write_mmd(phydev, MDIO_MMD_VEND2, MV_PCS_CONFIG,\n\t\t\t\t     MV_PCS_HOST_XAUI | MV_PCS_LINE_SGMII_AN);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic int mv2222_swap_line_type(struct phy_device *phydev)\n{\n\tstruct mv2222_data *priv = phydev->priv;\n\tbool changed = false;\n\tint ret;\n\n\tswitch (priv->line_interface) {\n\tcase PHY_INTERFACE_MODE_10GBASER:\n\t\tif (mv2222_is_1gbx_capable(phydev)) {\n\t\t\tpriv->line_interface = PHY_INTERFACE_MODE_1000BASEX;\n\t\t\tchanged = true;\n\t\t}\n\n\t\tif (mv2222_is_sgmii_capable(phydev)) {\n\t\t\tpriv->line_interface = PHY_INTERFACE_MODE_SGMII;\n\t\t\tchanged = true;\n\t\t}\n\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\tcase PHY_INTERFACE_MODE_SGMII:\n\t\tif (mv2222_is_10g_capable(phydev)) {\n\t\t\tpriv->line_interface = PHY_INTERFACE_MODE_10GBASER;\n\t\t\tchanged = true;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (changed) {\n\t\tret = mv2222_config_line(phydev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mv2222_setup_forced(struct phy_device *phydev)\n{\n\tstruct mv2222_data *priv = phydev->priv;\n\tint ret;\n\n\tif (priv->line_interface == PHY_INTERFACE_MODE_10GBASER) {\n\t\tif (phydev->speed < SPEED_10000 &&\n\t\t    phydev->speed != SPEED_UNKNOWN) {\n\t\t\tret = mv2222_swap_line_type(phydev);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (priv->line_interface == PHY_INTERFACE_MODE_SGMII) {\n\t\tret = mv2222_set_sgmii_speed(phydev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn mv2222_disable_aneg(phydev);\n}\n\nstatic int mv2222_config_aneg(struct phy_device *phydev)\n{\n\tstruct mv2222_data *priv = phydev->priv;\n\tint ret, adv;\n\n\t \n\tif (priv->line_interface == PHY_INTERFACE_MODE_NA)\n\t\treturn 0;\n\n\tif (phydev->autoneg == AUTONEG_DISABLE ||\n\t    priv->line_interface == PHY_INTERFACE_MODE_10GBASER)\n\t\treturn mv2222_setup_forced(phydev);\n\n\tadv = linkmode_adv_to_mii_adv_x(priv->supported,\n\t\t\t\t\tETHTOOL_LINK_MODE_1000baseX_Full_BIT);\n\n\tret = phy_modify_mmd(phydev, MDIO_MMD_PCS, MV_1GBX_ADVERTISE,\n\t\t\t     ADVERTISE_1000XFULL |\n\t\t\t     ADVERTISE_1000XPAUSE | ADVERTISE_1000XPSE_ASYM,\n\t\t\t     adv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn mv2222_enable_aneg(phydev);\n}\n\nstatic int mv2222_aneg_done(struct phy_device *phydev)\n{\n\tint ret;\n\n\tif (mv2222_is_10g_capable(phydev)) {\n\t\tret = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_STAT1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (ret & MDIO_STAT1_LSTATUS)\n\t\t\treturn 1;\n\t}\n\n\tret = phy_read_mmd(phydev, MDIO_MMD_PCS, MV_1GBX_STAT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn (ret & BMSR_ANEGCOMPLETE);\n}\n\n \nstatic int mv2222_read_status_10g(struct phy_device *phydev)\n{\n\tstatic int timeout;\n\tint val, link = 0;\n\n\tval = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_STAT1);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (val & MDIO_STAT1_LSTATUS) {\n\t\tlink = 1;\n\n\t\t \n\t\tphydev->autoneg = AUTONEG_DISABLE;\n\t\tphydev->speed = SPEED_10000;\n\t\tphydev->duplex = DUPLEX_FULL;\n\t} else {\n\t\tif (phydev->autoneg == AUTONEG_ENABLE) {\n\t\t\ttimeout++;\n\n\t\t\tif (timeout > AUTONEG_TIMEOUT) {\n\t\t\t\ttimeout = 0;\n\n\t\t\t\tval = mv2222_swap_line_type(phydev);\n\t\t\t\tif (val < 0)\n\t\t\t\t\treturn val;\n\n\t\t\t\treturn mv2222_config_aneg(phydev);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn link;\n}\n\n \nstatic int mv2222_read_status_1g(struct phy_device *phydev)\n{\n\tstatic int timeout;\n\tint val, link = 0;\n\n\tval = phy_read_mmd(phydev, MDIO_MMD_PCS, MV_1GBX_STAT);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (phydev->autoneg == AUTONEG_ENABLE &&\n\t    !(val & BMSR_ANEGCOMPLETE)) {\n\t\ttimeout++;\n\n\t\tif (timeout > AUTONEG_TIMEOUT) {\n\t\t\ttimeout = 0;\n\n\t\t\tval = mv2222_swap_line_type(phydev);\n\t\t\tif (val < 0)\n\t\t\t\treturn val;\n\n\t\t\treturn mv2222_config_aneg(phydev);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (!(val & BMSR_LSTATUS))\n\t\treturn 0;\n\n\tlink = 1;\n\n\tval = phy_read_mmd(phydev, MDIO_MMD_PCS, MV_1GBX_PHY_STAT);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (val & MV_1GBX_PHY_STAT_AN_RESOLVED) {\n\t\tif (val & MV_1GBX_PHY_STAT_DUPLEX)\n\t\t\tphydev->duplex = DUPLEX_FULL;\n\t\telse\n\t\t\tphydev->duplex = DUPLEX_HALF;\n\n\t\tif (val & MV_1GBX_PHY_STAT_SPEED1000)\n\t\t\tphydev->speed = SPEED_1000;\n\t\telse if (val & MV_1GBX_PHY_STAT_SPEED100)\n\t\t\tphydev->speed = SPEED_100;\n\t\telse\n\t\t\tphydev->speed = SPEED_10;\n\t}\n\n\treturn link;\n}\n\nstatic bool mv2222_link_is_operational(struct phy_device *phydev)\n{\n\tstruct mv2222_data *priv = phydev->priv;\n\tint val;\n\n\tval = phy_read_mmd(phydev, MDIO_MMD_PMAPMD, MV_RX_SIGNAL_DETECT);\n\tif (val < 0 || !(val & MV_RX_SIGNAL_DETECT_GLOBAL))\n\t\treturn false;\n\n\tif (phydev->sfp_bus && !priv->sfp_link)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int mv2222_read_status(struct phy_device *phydev)\n{\n\tstruct mv2222_data *priv = phydev->priv;\n\tint link;\n\n\tphydev->link = 0;\n\tphydev->speed = SPEED_UNKNOWN;\n\tphydev->duplex = DUPLEX_UNKNOWN;\n\n\tif (!mv2222_link_is_operational(phydev))\n\t\treturn 0;\n\n\tif (priv->line_interface == PHY_INTERFACE_MODE_10GBASER)\n\t\tlink = mv2222_read_status_10g(phydev);\n\telse\n\t\tlink = mv2222_read_status_1g(phydev);\n\n\tif (link < 0)\n\t\treturn link;\n\n\tphydev->link = link;\n\n\treturn 0;\n}\n\nstatic int mv2222_resume(struct phy_device *phydev)\n{\n\treturn mv2222_tx_enable(phydev);\n}\n\nstatic int mv2222_suspend(struct phy_device *phydev)\n{\n\treturn mv2222_tx_disable(phydev);\n}\n\nstatic int mv2222_get_features(struct phy_device *phydev)\n{\n\t \n\n\treturn 0;\n}\n\nstatic int mv2222_config_init(struct phy_device *phydev)\n{\n\tif (phydev->interface != PHY_INTERFACE_MODE_XAUI)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int mv2222_sfp_insert(void *upstream, const struct sfp_eeprom_id *id)\n{\n\tDECLARE_PHY_INTERFACE_MASK(interfaces);\n\tstruct phy_device *phydev = upstream;\n\tphy_interface_t sfp_interface;\n\tstruct mv2222_data *priv;\n\tstruct device *dev;\n\tint ret;\n\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(sfp_supported) = { 0, };\n\n\tpriv = phydev->priv;\n\tdev = &phydev->mdio.dev;\n\n\tsfp_parse_support(phydev->sfp_bus, id, sfp_supported, interfaces);\n\tphydev->port = sfp_parse_port(phydev->sfp_bus, id, sfp_supported);\n\tsfp_interface = sfp_select_interface(phydev->sfp_bus, sfp_supported);\n\n\tdev_info(dev, \"%s SFP module inserted\\n\", phy_modes(sfp_interface));\n\n\tif (sfp_interface != PHY_INTERFACE_MODE_10GBASER &&\n\t    sfp_interface != PHY_INTERFACE_MODE_1000BASEX &&\n\t    sfp_interface != PHY_INTERFACE_MODE_SGMII) {\n\t\tdev_err(dev, \"Incompatible SFP module inserted\\n\");\n\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->line_interface = sfp_interface;\n\tlinkmode_and(priv->supported, phydev->supported, sfp_supported);\n\n\tret = mv2222_config_line(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (mutex_trylock(&phydev->lock)) {\n\t\tret = mv2222_config_aneg(phydev);\n\t\tmutex_unlock(&phydev->lock);\n\t}\n\n\treturn ret;\n}\n\nstatic void mv2222_sfp_remove(void *upstream)\n{\n\tstruct phy_device *phydev = upstream;\n\tstruct mv2222_data *priv;\n\n\tpriv = phydev->priv;\n\n\tpriv->line_interface = PHY_INTERFACE_MODE_NA;\n\tlinkmode_zero(priv->supported);\n\tphydev->port = PORT_NONE;\n}\n\nstatic void mv2222_sfp_link_up(void *upstream)\n{\n\tstruct phy_device *phydev = upstream;\n\tstruct mv2222_data *priv;\n\n\tpriv = phydev->priv;\n\tpriv->sfp_link = true;\n}\n\nstatic void mv2222_sfp_link_down(void *upstream)\n{\n\tstruct phy_device *phydev = upstream;\n\tstruct mv2222_data *priv;\n\n\tpriv = phydev->priv;\n\tpriv->sfp_link = false;\n}\n\nstatic const struct sfp_upstream_ops sfp_phy_ops = {\n\t.module_insert = mv2222_sfp_insert,\n\t.module_remove = mv2222_sfp_remove,\n\t.link_up = mv2222_sfp_link_up,\n\t.link_down = mv2222_sfp_link_down,\n\t.attach = phy_sfp_attach,\n\t.detach = phy_sfp_detach,\n};\n\nstatic int mv2222_probe(struct phy_device *phydev)\n{\n\tstruct device *dev = &phydev->mdio.dev;\n\tstruct mv2222_data *priv = NULL;\n\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(supported) = { 0, };\n\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, supported);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_Pause_BIT, supported);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, supported);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FIBRE_BIT, supported);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_TP_BIT, supported);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT, supported);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT, supported);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT, supported);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, supported);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT, supported);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, supported);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT, supported);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT, supported);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_10000baseCR_Full_BIT, supported);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_10000baseSR_Full_BIT, supported);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_10000baseLR_Full_BIT, supported);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_10000baseLRM_Full_BIT, supported);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_10000baseER_Full_BIT, supported);\n\n\tlinkmode_copy(phydev->supported, supported);\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->line_interface = PHY_INTERFACE_MODE_NA;\n\tphydev->priv = priv;\n\n\treturn phy_sfp_probe(phydev, &sfp_phy_ops);\n}\n\nstatic struct phy_driver mv2222_drivers[] = {\n\t{\n\t\t.phy_id = MARVELL_PHY_ID_88X2222,\n\t\t.phy_id_mask = MARVELL_PHY_ID_MASK,\n\t\t.name = \"Marvell 88X2222\",\n\t\t.get_features = mv2222_get_features,\n\t\t.soft_reset = mv2222_soft_reset,\n\t\t.config_init = mv2222_config_init,\n\t\t.config_aneg = mv2222_config_aneg,\n\t\t.aneg_done = mv2222_aneg_done,\n\t\t.probe = mv2222_probe,\n\t\t.suspend = mv2222_suspend,\n\t\t.resume = mv2222_resume,\n\t\t.read_status = mv2222_read_status,\n\t},\n};\nmodule_phy_driver(mv2222_drivers);\n\nstatic struct mdio_device_id __maybe_unused mv2222_tbl[] = {\n\t{ MARVELL_PHY_ID_88X2222, MARVELL_PHY_ID_MASK },\n\t{ }\n};\nMODULE_DEVICE_TABLE(mdio, mv2222_tbl);\n\nMODULE_DESCRIPTION(\"Marvell 88x2222 ethernet transceiver driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}