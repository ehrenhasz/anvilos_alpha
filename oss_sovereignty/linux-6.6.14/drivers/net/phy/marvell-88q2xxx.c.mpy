{
  "module_name": "marvell-88q2xxx.c",
  "hash_id": "372ea57ef5cdd27c89be77360e939c5c811da92e710f6d345dfd6211988d6538",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/marvell-88q2xxx.c",
  "human_readable_source": "\n \n#include <linux/ethtool_netlink.h>\n#include <linux/marvell_phy.h>\n#include <linux/phy.h>\n\n#define MDIO_MMD_AN_MV_STAT\t\t\t32769\n#define MDIO_MMD_AN_MV_STAT_ANEG\t\t0x0100\n#define MDIO_MMD_AN_MV_STAT_LOCAL_RX\t\t0x1000\n#define MDIO_MMD_AN_MV_STAT_REMOTE_RX\t\t0x2000\n#define MDIO_MMD_AN_MV_STAT_LOCAL_MASTER\t0x4000\n#define MDIO_MMD_AN_MV_STAT_MS_CONF_FAULT\t0x8000\n\n#define MDIO_MMD_PCS_MV_100BT1_STAT1\t\t\t33032\n#define MDIO_MMD_PCS_MV_100BT1_STAT1_IDLE_ERROR\t0x00FF\n#define MDIO_MMD_PCS_MV_100BT1_STAT1_JABBER\t\t0x0100\n#define MDIO_MMD_PCS_MV_100BT1_STAT1_LINK\t\t0x0200\n#define MDIO_MMD_PCS_MV_100BT1_STAT1_LOCAL_RX\t\t0x1000\n#define MDIO_MMD_PCS_MV_100BT1_STAT1_REMOTE_RX\t\t0x2000\n#define MDIO_MMD_PCS_MV_100BT1_STAT1_LOCAL_MASTER\t0x4000\n\n#define MDIO_MMD_PCS_MV_100BT1_STAT2\t\t33033\n#define MDIO_MMD_PCS_MV_100BT1_STAT2_JABBER\t0x0001\n#define MDIO_MMD_PCS_MV_100BT1_STAT2_POL\t0x0002\n#define MDIO_MMD_PCS_MV_100BT1_STAT2_LINK\t0x0004\n#define MDIO_MMD_PCS_MV_100BT1_STAT2_ANGE\t0x0008\n\nstatic int mv88q2xxx_soft_reset(struct phy_device *phydev)\n{\n\tint ret;\n\tint val;\n\n\tret = phy_write_mmd(phydev, MDIO_MMD_PCS,\n\t\t\t    MDIO_PCS_1000BT1_CTRL, MDIO_PCS_1000BT1_CTRL_RESET);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn phy_read_mmd_poll_timeout(phydev, MDIO_MMD_PCS,\n\t\t\t\t\t MDIO_PCS_1000BT1_CTRL, val,\n\t\t\t\t\t !(val & MDIO_PCS_1000BT1_CTRL_RESET),\n\t\t\t\t\t 50000, 600000, true);\n}\n\nstatic int mv88q2xxx_read_link_gbit(struct phy_device *phydev)\n{\n\tint ret;\n\tbool link = false;\n\n\t \n\tret = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_MMD_AN_MV_STAT);\n\tif (ret < 0) {\n\t\treturn ret;\n\t} else if ((ret & MDIO_MMD_AN_MV_STAT_LOCAL_RX) &&\n\t\t   (ret & MDIO_MMD_AN_MV_STAT_REMOTE_RX)) {\n\t\t \n\t\tif (!phy_polling_mode(phydev) || !phydev->link) {\n\t\t\tret = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_PCS_1000BT1_STAT);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\telse if (ret & MDIO_PCS_1000BT1_STAT_LINK)\n\t\t\t\tlink = true;\n\t\t}\n\n\t\tif (!link) {\n\t\t\tret = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_PCS_1000BT1_STAT);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\telse if (ret & MDIO_PCS_1000BT1_STAT_LINK)\n\t\t\t\tlink = true;\n\t\t}\n\t}\n\n\tphydev->link = link;\n\n\treturn 0;\n}\n\nstatic int mv88q2xxx_read_link_100m(struct phy_device *phydev)\n{\n\tint ret;\n\n\t \n\tif (!phy_polling_mode(phydev) || !phydev->link) {\n\t\tret = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_MMD_PCS_MV_100BT1_STAT1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret & MDIO_MMD_PCS_MV_100BT1_STAT1_LINK)\n\t\t\tgoto out;\n\t}\n\n\tret = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_MMD_PCS_MV_100BT1_STAT1);\n\tif (ret < 0)\n\t\treturn ret;\n\nout:\n\t \n\tif ((ret & MDIO_MMD_PCS_MV_100BT1_STAT1_LINK) &&\n\t    (ret & MDIO_MMD_PCS_MV_100BT1_STAT1_LOCAL_RX) &&\n\t    (ret & MDIO_MMD_PCS_MV_100BT1_STAT1_REMOTE_RX))\n\t\tphydev->link = true;\n\telse\n\t\tphydev->link = false;\n\n\treturn 0;\n}\n\nstatic int mv88q2xxx_read_link(struct phy_device *phydev)\n{\n\tint ret;\n\n\t \n\tif (phydev->speed == SPEED_1000)\n\t\tret = mv88q2xxx_read_link_gbit(phydev);\n\telse\n\t\tret = mv88q2xxx_read_link_100m(phydev);\n\n\treturn ret;\n}\n\nstatic int mv88q2xxx_read_status(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = mv88q2xxx_read_link(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn genphy_c45_read_pma(phydev);\n}\n\nstatic int mv88q2xxx_get_features(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = genphy_c45_pma_read_abilities(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = genphy_c45_pma_baset1_read_abilities(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, phydev->supported);\n\n\treturn 0;\n}\n\nstatic int mv88q2xxx_config_aneg(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = genphy_c45_config_aneg(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mv88q2xxx_soft_reset(phydev);\n}\n\nstatic int mv88q2xxx_config_init(struct phy_device *phydev)\n{\n\tint ret;\n\n\t \n\tphydev->pma_extable = MDIO_PMA_EXTABLE_BT1;\n\n\t \n\tret = genphy_c45_read_pma(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mv88q2xxx_config_aneg(phydev);\n}\n\nstatic int mv88q2xxxx_get_sqi(struct phy_device *phydev)\n{\n\tint ret;\n\n\tif (phydev->speed == SPEED_100) {\n\t\t \n\t\tret = phy_read_mmd(phydev, MDIO_MMD_PCS, 0x8230);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = ret >> 12;\n\t} else {\n\t\t \n\t\tret = phy_modify_mmd(phydev, MDIO_MMD_PCS, 0xFC5D, 0x00FF, 0x00AC);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = phy_read_mmd(phydev, MDIO_MMD_PCS, 0xfc88);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn ret & 0x0F;\n}\n\nstatic int mv88q2xxxx_get_sqi_max(struct phy_device *phydev)\n{\n\treturn 15;\n}\n\nstatic struct phy_driver mv88q2xxx_driver[] = {\n\t{\n\t\t.phy_id\t\t\t= MARVELL_PHY_ID_88Q2110,\n\t\t.phy_id_mask\t\t= MARVELL_PHY_ID_MASK,\n\t\t.name\t\t\t= \"mv88q2110\",\n\t\t.get_features\t\t= mv88q2xxx_get_features,\n\t\t.config_aneg\t\t= mv88q2xxx_config_aneg,\n\t\t.config_init\t\t= mv88q2xxx_config_init,\n\t\t.read_status\t\t= mv88q2xxx_read_status,\n\t\t.soft_reset\t\t= mv88q2xxx_soft_reset,\n\t\t.set_loopback\t\t= genphy_c45_loopback,\n\t\t.get_sqi\t\t= mv88q2xxxx_get_sqi,\n\t\t.get_sqi_max\t\t= mv88q2xxxx_get_sqi_max,\n\t},\n};\n\nmodule_phy_driver(mv88q2xxx_driver);\n\nstatic struct mdio_device_id __maybe_unused mv88q2xxx_tbl[] = {\n\t{ MARVELL_PHY_ID_88Q2110, MARVELL_PHY_ID_MASK },\n\t{   }\n};\nMODULE_DEVICE_TABLE(mdio, mv88q2xxx_tbl);\n\nMODULE_DESCRIPTION(\"Marvell 88Q2XXX 100/1000BASE-T1 Automotive Ethernet PHY driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}