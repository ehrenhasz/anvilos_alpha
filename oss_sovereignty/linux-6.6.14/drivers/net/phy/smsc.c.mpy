{
  "module_name": "smsc.c",
  "hash_id": "3a281a043e8788b32944d96a1f563f331e3c1f3de6c8ec43f7a41e6e78d214e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/smsc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/of.h>\n#include <linux/phy.h>\n#include <linux/netdevice.h>\n#include <linux/crc16.h>\n#include <linux/etherdevice.h>\n#include <linux/smscphy.h>\n\n \n \n#define PHY_EDPD_CONFIG\t\t\t16\n#define PHY_EDPD_CONFIG_EXT_CROSSOVER_\t0x0001\n\n \n#define SPECIAL_CTRL_STS\t\t27\n#define SPECIAL_CTRL_STS_OVRRD_AMDIX_\t0x8000\n#define SPECIAL_CTRL_STS_AMDIX_ENABLE_\t0x4000\n#define SPECIAL_CTRL_STS_AMDIX_STATE_\t0x2000\n\n#define EDPD_MAX_WAIT_DFLT_MS\t\t640\n \n#define PHY_STATE_MACH_MS\t\t1000\n\nstruct smsc_hw_stat {\n\tconst char *string;\n\tu8 reg;\n\tu8 bits;\n};\n\nstatic struct smsc_hw_stat smsc_hw_stats[] = {\n\t{ \"phy_symbol_errors\", 26, 16},\n};\n\nstruct smsc_phy_priv {\n\tunsigned int edpd_enable:1;\n\tunsigned int edpd_mode_set_by_user:1;\n\tunsigned int edpd_max_wait_ms;\n\tbool wol_arp;\n};\n\nstatic int smsc_phy_ack_interrupt(struct phy_device *phydev)\n{\n\tint rc = phy_read(phydev, MII_LAN83C185_ISF);\n\n\treturn rc < 0 ? rc : 0;\n}\n\nint smsc_phy_config_intr(struct phy_device *phydev)\n{\n\tint rc;\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\trc = smsc_phy_ack_interrupt(phydev);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\trc = phy_write(phydev, MII_LAN83C185_IM,\n\t\t\t       MII_LAN83C185_ISF_INT_PHYLIB_EVENTS);\n\t} else {\n\t\trc = phy_write(phydev, MII_LAN83C185_IM, 0);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\trc = smsc_phy_ack_interrupt(phydev);\n\t}\n\n\treturn rc < 0 ? rc : 0;\n}\nEXPORT_SYMBOL_GPL(smsc_phy_config_intr);\n\nstatic int smsc_phy_config_edpd(struct phy_device *phydev)\n{\n\tstruct smsc_phy_priv *priv = phydev->priv;\n\n\tif (priv->edpd_enable)\n\t\treturn phy_set_bits(phydev, MII_LAN83C185_CTRL_STATUS,\n\t\t\t\t    MII_LAN83C185_EDPWRDOWN);\n\telse\n\t\treturn phy_clear_bits(phydev, MII_LAN83C185_CTRL_STATUS,\n\t\t\t\t      MII_LAN83C185_EDPWRDOWN);\n}\n\nirqreturn_t smsc_phy_handle_interrupt(struct phy_device *phydev)\n{\n\tint irq_status;\n\n\tirq_status = phy_read(phydev, MII_LAN83C185_ISF);\n\tif (irq_status < 0) {\n\t\tif (irq_status != -ENODEV)\n\t\t\tphy_error(phydev);\n\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (!(irq_status & MII_LAN83C185_ISF_INT_PHYLIB_EVENTS))\n\t\treturn IRQ_NONE;\n\n\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\nEXPORT_SYMBOL_GPL(smsc_phy_handle_interrupt);\n\nint smsc_phy_config_init(struct phy_device *phydev)\n{\n\tstruct smsc_phy_priv *priv = phydev->priv;\n\n\tif (!priv)\n\t\treturn 0;\n\n\t \n\tif (!priv->edpd_mode_set_by_user && phydev->irq != PHY_POLL)\n\t\tpriv->edpd_enable = false;\n\n\treturn smsc_phy_config_edpd(phydev);\n}\nEXPORT_SYMBOL_GPL(smsc_phy_config_init);\n\nstatic int smsc_phy_reset(struct phy_device *phydev)\n{\n\tint rc = phy_read(phydev, MII_LAN83C185_SPECIAL_MODES);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tif ((rc & MII_LAN83C185_MODE_MASK) == MII_LAN83C185_MODE_POWERDOWN) {\n\t\t \n\t\trc |= MII_LAN83C185_MODE_ALL;\n\t\tphy_write(phydev, MII_LAN83C185_SPECIAL_MODES, rc);\n\t}\n\n\t \n\treturn genphy_soft_reset(phydev);\n}\n\nstatic int lan87xx_config_aneg(struct phy_device *phydev)\n{\n\tint rc;\n\tint val;\n\n\tswitch (phydev->mdix_ctrl) {\n\tcase ETH_TP_MDI:\n\t\tval = SPECIAL_CTRL_STS_OVRRD_AMDIX_;\n\t\tbreak;\n\tcase ETH_TP_MDI_X:\n\t\tval = SPECIAL_CTRL_STS_OVRRD_AMDIX_ |\n\t\t\tSPECIAL_CTRL_STS_AMDIX_STATE_;\n\t\tbreak;\n\tcase ETH_TP_MDI_AUTO:\n\t\tval = SPECIAL_CTRL_STS_AMDIX_ENABLE_;\n\t\tbreak;\n\tdefault:\n\t\treturn genphy_config_aneg(phydev);\n\t}\n\n\trc = phy_read(phydev, SPECIAL_CTRL_STS);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc &= ~(SPECIAL_CTRL_STS_OVRRD_AMDIX_ |\n\t\tSPECIAL_CTRL_STS_AMDIX_ENABLE_ |\n\t\tSPECIAL_CTRL_STS_AMDIX_STATE_);\n\trc |= val;\n\tphy_write(phydev, SPECIAL_CTRL_STS, rc);\n\n\tphydev->mdix = phydev->mdix_ctrl;\n\treturn genphy_config_aneg(phydev);\n}\n\nstatic int lan95xx_config_aneg_ext(struct phy_device *phydev)\n{\n\tif (phydev->phy_id == 0x0007c0f0) {  \n\t\t \n\t\tint rc = phy_set_bits(phydev, PHY_EDPD_CONFIG,\n\t\t\t\t      PHY_EDPD_CONFIG_EXT_CROSSOVER_);\n\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\n\treturn lan87xx_config_aneg(phydev);\n}\n\n \nint lan87xx_read_status(struct phy_device *phydev)\n{\n\tstruct smsc_phy_priv *priv = phydev->priv;\n\tint err;\n\n\terr = genphy_read_status(phydev);\n\tif (err)\n\t\treturn err;\n\n\tif (!phydev->link && priv && priv->edpd_enable &&\n\t    priv->edpd_max_wait_ms) {\n\t\tunsigned int max_wait = priv->edpd_max_wait_ms * 1000;\n\t\tint rc;\n\n\t\t \n\t\trc = phy_read(phydev, MII_LAN83C185_CTRL_STATUS);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\trc = phy_write(phydev, MII_LAN83C185_CTRL_STATUS,\n\t\t\t       rc & ~MII_LAN83C185_EDPWRDOWN);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t \n\t\tread_poll_timeout(phy_read, rc,\n\t\t\t\t  rc & MII_LAN83C185_ENERGYON || rc < 0,\n\t\t\t\t  10000, max_wait, true, phydev,\n\t\t\t\t  MII_LAN83C185_CTRL_STATUS);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\t \n\t\trc = phy_read(phydev, MII_LAN83C185_CTRL_STATUS);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\trc = phy_write(phydev, MII_LAN83C185_CTRL_STATUS,\n\t\t\t       rc | MII_LAN83C185_EDPWRDOWN);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t}\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(lan87xx_read_status);\n\nstatic int lan874x_phy_config_init(struct phy_device *phydev)\n{\n\tu16 val;\n\tint rc;\n\n\t \n\tval = MII_LAN874X_PHY_PME2_SET;\n\n\t \n\tval |= MII_LAN874X_PHY_PME_SELF_CLEAR;\n\trc = phy_write_mmd(phydev, MDIO_MMD_PCS, MII_LAN874X_PHY_MMD_WOL_WUCSR,\n\t\t\t   val);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\trc = phy_write_mmd(phydev, MDIO_MMD_PCS, MII_LAN874X_PHY_MMD_MCFGR,\n\t\t\t   MII_LAN874X_PHY_PME_SELF_CLEAR_DELAY);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn smsc_phy_config_init(phydev);\n}\n\nstatic void lan874x_get_wol(struct phy_device *phydev,\n\t\t\t    struct ethtool_wolinfo *wol)\n{\n\tstruct smsc_phy_priv *priv = phydev->priv;\n\tint rc;\n\n\twol->supported = (WAKE_UCAST | WAKE_BCAST | WAKE_MAGIC |\n\t\t\t  WAKE_ARP | WAKE_MCAST);\n\twol->wolopts = 0;\n\n\trc = phy_read_mmd(phydev, MDIO_MMD_PCS, MII_LAN874X_PHY_MMD_WOL_WUCSR);\n\tif (rc < 0)\n\t\treturn;\n\n\tif (rc & MII_LAN874X_PHY_WOL_PFDAEN)\n\t\twol->wolopts |= WAKE_UCAST;\n\n\tif (rc & MII_LAN874X_PHY_WOL_BCSTEN)\n\t\twol->wolopts |= WAKE_BCAST;\n\n\tif (rc & MII_LAN874X_PHY_WOL_MPEN)\n\t\twol->wolopts |= WAKE_MAGIC;\n\n\tif (rc & MII_LAN874X_PHY_WOL_WUEN) {\n\t\tif (priv->wol_arp)\n\t\t\twol->wolopts |= WAKE_ARP;\n\t\telse\n\t\t\twol->wolopts |= WAKE_MCAST;\n\t}\n}\n\nstatic u16 smsc_crc16(const u8 *buffer, size_t len)\n{\n\treturn bitrev16(crc16(0xFFFF, buffer, len));\n}\n\nstatic int lan874x_chk_wol_pattern(const u8 pattern[], const u16 *mask,\n\t\t\t\t   u8 len, u8 *data, u8 *datalen)\n{\n\tsize_t i, j, k;\n\tint ret = 0;\n\tu16 bits;\n\n\t \n\ti = 0;\n\tk = 0;\n\twhile (len > 0) {\n\t\tbits = *mask;\n\t\tfor (j = 0; j < 16; j++, i++, len--) {\n\t\t\t \n\t\t\tif (!len) {\n\t\t\t\t \n\t\t\t\tif (bits)\n\t\t\t\t\tret = i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (bits & 1)\n\t\t\t\tdata[k++] = pattern[i];\n\t\t\tbits >>= 1;\n\t\t}\n\t\tmask++;\n\t}\n\t*datalen = k;\n\treturn ret;\n}\n\nstatic int lan874x_set_wol_pattern(struct phy_device *phydev, u16 val,\n\t\t\t\t   const u8 data[], u8 datalen,\n\t\t\t\t   const u16 *mask, u8 masklen)\n{\n\tu16 crc, reg;\n\tint rc;\n\n\t \n\tval |= MII_LAN874X_PHY_WOL_FILTER_EN;\n\trc = phy_write_mmd(phydev, MDIO_MMD_PCS,\n\t\t\t   MII_LAN874X_PHY_MMD_WOL_WUF_CFGA, val);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tcrc = smsc_crc16(data, datalen);\n\trc = phy_write_mmd(phydev, MDIO_MMD_PCS,\n\t\t\t   MII_LAN874X_PHY_MMD_WOL_WUF_CFGB, crc);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tmasklen = (masklen + 15) & ~0xf;\n\treg = MII_LAN874X_PHY_MMD_WOL_WUF_MASK7;\n\twhile (masklen >= 16) {\n\t\trc = phy_write_mmd(phydev, MDIO_MMD_PCS, reg, *mask);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\treg--;\n\t\tmask++;\n\t\tmasklen -= 16;\n\t}\n\n\t \n\twhile (reg != MII_LAN874X_PHY_MMD_WOL_WUF_MASK0) {\n\t\tphy_write_mmd(phydev, MDIO_MMD_PCS, reg, 0);\n\t\treg--;\n\t}\n\treturn rc;\n}\n\nstatic int lan874x_set_wol(struct phy_device *phydev,\n\t\t\t   struct ethtool_wolinfo *wol)\n{\n\tstruct net_device *ndev = phydev->attached_dev;\n\tstruct smsc_phy_priv *priv = phydev->priv;\n\tu16 val, val_wucsr;\n\tu8 data[128];\n\tu8 datalen;\n\tint rc;\n\n\t \n\tif ((wol->wolopts & (WAKE_ARP | WAKE_MCAST)) ==\n\t    (WAKE_ARP | WAKE_MCAST)) {\n\t\tphydev_info(phydev,\n\t\t\t    \"lan874x WoL supports one of ARP|MCAST at a time\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\trc = phy_read_mmd(phydev, MDIO_MMD_PCS, MII_LAN874X_PHY_MMD_WOL_WUCSR);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tval_wucsr = rc;\n\n\tif (wol->wolopts & WAKE_UCAST)\n\t\tval_wucsr |= MII_LAN874X_PHY_WOL_PFDAEN;\n\telse\n\t\tval_wucsr &= ~MII_LAN874X_PHY_WOL_PFDAEN;\n\n\tif (wol->wolopts & WAKE_BCAST)\n\t\tval_wucsr |= MII_LAN874X_PHY_WOL_BCSTEN;\n\telse\n\t\tval_wucsr &= ~MII_LAN874X_PHY_WOL_BCSTEN;\n\n\tif (wol->wolopts & WAKE_MAGIC)\n\t\tval_wucsr |= MII_LAN874X_PHY_WOL_MPEN;\n\telse\n\t\tval_wucsr &= ~MII_LAN874X_PHY_WOL_MPEN;\n\n\t \n\tif (wol->wolopts & (WAKE_ARP | WAKE_MCAST))\n\t\tval_wucsr |= MII_LAN874X_PHY_WOL_WUEN;\n\telse\n\t\tval_wucsr &= ~MII_LAN874X_PHY_WOL_WUEN;\n\n\tif (wol->wolopts & WAKE_ARP) {\n\t\tconst u8 pattern[2] = { 0x08, 0x06 };\n\t\tconst u16 mask[1] = { 0x0003 };\n\n\t\trc = lan874x_chk_wol_pattern(pattern, mask, 2, data,\n\t\t\t\t\t     &datalen);\n\t\tif (rc)\n\t\t\tphydev_dbg(phydev, \"pattern not valid at %d\\n\", rc);\n\n\t\t \n\t\tval = 12 | MII_LAN874X_PHY_WOL_FILTER_BCSTEN;\n\t\trc = lan874x_set_wol_pattern(phydev, val, data, datalen, mask,\n\t\t\t\t\t     2);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tpriv->wol_arp = true;\n\t}\n\n\tif (wol->wolopts & WAKE_MCAST) {\n\t\t \n\t\tval = MII_LAN874X_PHY_WOL_FILTER_MCASTTEN;\n\t\trc = lan874x_set_wol_pattern(phydev, val, data, 0, NULL, 0);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\tpriv->wol_arp = false;\n\t}\n\n\tif (wol->wolopts & (WAKE_MAGIC | WAKE_UCAST)) {\n\t\tconst u8 *mac = (const u8 *)ndev->dev_addr;\n\t\tint i, reg;\n\n\t\treg = MII_LAN874X_PHY_MMD_WOL_RX_ADDRC;\n\t\tfor (i = 0; i < 6; i += 2, reg--) {\n\t\t\trc = phy_write_mmd(phydev, MDIO_MMD_PCS, reg,\n\t\t\t\t\t   ((mac[i + 1] << 8) | mac[i]));\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\n\trc = phy_write_mmd(phydev, MDIO_MMD_PCS, MII_LAN874X_PHY_MMD_WOL_WUCSR,\n\t\t\t   val_wucsr);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic int smsc_get_sset_count(struct phy_device *phydev)\n{\n\treturn ARRAY_SIZE(smsc_hw_stats);\n}\n\nstatic void smsc_get_strings(struct phy_device *phydev, u8 *data)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(smsc_hw_stats); i++) {\n\t\tstrncpy(data + i * ETH_GSTRING_LEN,\n\t\t       smsc_hw_stats[i].string, ETH_GSTRING_LEN);\n\t}\n}\n\nstatic u64 smsc_get_stat(struct phy_device *phydev, int i)\n{\n\tstruct smsc_hw_stat stat = smsc_hw_stats[i];\n\tint val;\n\tu64 ret;\n\n\tval = phy_read(phydev, stat.reg);\n\tif (val < 0)\n\t\tret = U64_MAX;\n\telse\n\t\tret = val;\n\n\treturn ret;\n}\n\nstatic void smsc_get_stats(struct phy_device *phydev,\n\t\t\t   struct ethtool_stats *stats, u64 *data)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(smsc_hw_stats); i++)\n\t\tdata[i] = smsc_get_stat(phydev, i);\n}\n\nstatic int smsc_phy_get_edpd(struct phy_device *phydev, u16 *edpd)\n{\n\tstruct smsc_phy_priv *priv = phydev->priv;\n\n\tif (!priv)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!priv->edpd_enable)\n\t\t*edpd = ETHTOOL_PHY_EDPD_DISABLE;\n\telse if (!priv->edpd_max_wait_ms)\n\t\t*edpd = ETHTOOL_PHY_EDPD_NO_TX;\n\telse\n\t\t*edpd = PHY_STATE_MACH_MS + priv->edpd_max_wait_ms;\n\n\treturn 0;\n}\n\nstatic int smsc_phy_set_edpd(struct phy_device *phydev, u16 edpd)\n{\n\tstruct smsc_phy_priv *priv = phydev->priv;\n\n\tif (!priv)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (edpd) {\n\tcase ETHTOOL_PHY_EDPD_DISABLE:\n\t\tpriv->edpd_enable = false;\n\t\tbreak;\n\tcase ETHTOOL_PHY_EDPD_NO_TX:\n\t\tpriv->edpd_enable = true;\n\t\tpriv->edpd_max_wait_ms = 0;\n\t\tbreak;\n\tcase ETHTOOL_PHY_EDPD_DFLT_TX_MSECS:\n\t\tedpd = PHY_STATE_MACH_MS + EDPD_MAX_WAIT_DFLT_MS;\n\t\tfallthrough;\n\tdefault:\n\t\tif (phydev->irq != PHY_POLL)\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (edpd < PHY_STATE_MACH_MS || edpd > PHY_STATE_MACH_MS + 1000)\n\t\t\treturn -EINVAL;\n\t\tpriv->edpd_enable = true;\n\t\tpriv->edpd_max_wait_ms = edpd - PHY_STATE_MACH_MS;\n\t}\n\n\tpriv->edpd_mode_set_by_user = true;\n\n\treturn smsc_phy_config_edpd(phydev);\n}\n\nint smsc_phy_get_tunable(struct phy_device *phydev,\n\t\t\t struct ethtool_tunable *tuna, void *data)\n{\n\tswitch (tuna->id) {\n\tcase ETHTOOL_PHY_EDPD:\n\t\treturn smsc_phy_get_edpd(phydev, data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\nEXPORT_SYMBOL_GPL(smsc_phy_get_tunable);\n\nint smsc_phy_set_tunable(struct phy_device *phydev,\n\t\t\t struct ethtool_tunable *tuna, const void *data)\n{\n\tswitch (tuna->id) {\n\tcase ETHTOOL_PHY_EDPD:\n\t\treturn smsc_phy_set_edpd(phydev, *(u16 *)data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\nEXPORT_SYMBOL_GPL(smsc_phy_set_tunable);\n\nint smsc_phy_probe(struct phy_device *phydev)\n{\n\tstruct device *dev = &phydev->mdio.dev;\n\tstruct smsc_phy_priv *priv;\n\tstruct clk *refclk;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->edpd_enable = true;\n\tpriv->edpd_max_wait_ms = EDPD_MAX_WAIT_DFLT_MS;\n\n\tif (device_property_present(dev, \"smsc,disable-energy-detect\"))\n\t\tpriv->edpd_enable = false;\n\n\tphydev->priv = priv;\n\n\t \n\trefclk = devm_clk_get_optional_enabled(dev, NULL);\n\tif (IS_ERR(refclk))\n\t\treturn dev_err_probe(dev, PTR_ERR(refclk),\n\t\t\t\t     \"Failed to request clock\\n\");\n\n\treturn clk_set_rate(refclk, 50 * 1000 * 1000);\n}\nEXPORT_SYMBOL_GPL(smsc_phy_probe);\n\nstatic struct phy_driver smsc_phy_driver[] = {\n{\n\t.phy_id\t\t= 0x0007c0a0,  \n\t.phy_id_mask\t= 0xfffffff0,\n\t.name\t\t= \"SMSC LAN83C185\",\n\n\t \n\n\t.probe\t\t= smsc_phy_probe,\n\n\t \n\t.config_init\t= smsc_phy_config_init,\n\t.soft_reset\t= smsc_phy_reset,\n\n\t \n\t.config_intr\t= smsc_phy_config_intr,\n\t.handle_interrupt = smsc_phy_handle_interrupt,\n\n\t.suspend\t= genphy_suspend,\n\t.resume\t\t= genphy_resume,\n}, {\n\t.phy_id\t\t= 0x0007c0b0,  \n\t.phy_id_mask\t= 0xfffffff0,\n\t.name\t\t= \"SMSC LAN8187\",\n\n\t \n\n\t.probe\t\t= smsc_phy_probe,\n\n\t \n\t.config_init\t= smsc_phy_config_init,\n\t.soft_reset\t= smsc_phy_reset,\n\n\t \n\t.config_intr\t= smsc_phy_config_intr,\n\t.handle_interrupt = smsc_phy_handle_interrupt,\n\n\t \n\t.get_sset_count = smsc_get_sset_count,\n\t.get_strings\t= smsc_get_strings,\n\t.get_stats\t= smsc_get_stats,\n\n\t.suspend\t= genphy_suspend,\n\t.resume\t\t= genphy_resume,\n}, {\n\t \n\t.phy_id\t\t= 0x0007c0c0,  \n\t.phy_id_mask\t= 0xfffffff0,\n\t.name\t\t= \"SMSC LAN8700\",\n\n\t \n\n\t.probe\t\t= smsc_phy_probe,\n\n\t \n\t.read_status\t= lan87xx_read_status,\n\t.config_init\t= smsc_phy_config_init,\n\t.soft_reset\t= smsc_phy_reset,\n\t.config_aneg\t= lan87xx_config_aneg,\n\n\t \n\t.config_intr\t= smsc_phy_config_intr,\n\t.handle_interrupt = smsc_phy_handle_interrupt,\n\n\t \n\t.get_sset_count = smsc_get_sset_count,\n\t.get_strings\t= smsc_get_strings,\n\t.get_stats\t= smsc_get_stats,\n\n\t.get_tunable\t= smsc_phy_get_tunable,\n\t.set_tunable\t= smsc_phy_set_tunable,\n\n\t.suspend\t= genphy_suspend,\n\t.resume\t\t= genphy_resume,\n}, {\n\t.phy_id\t\t= 0x0007c0d0,  \n\t.phy_id_mask\t= 0xfffffff0,\n\t.name\t\t= \"SMSC LAN911x Internal PHY\",\n\n\t \n\n\t.probe\t\t= smsc_phy_probe,\n\n\t \n\t.config_intr\t= smsc_phy_config_intr,\n\t.handle_interrupt = smsc_phy_handle_interrupt,\n\n\t.suspend\t= genphy_suspend,\n\t.resume\t\t= genphy_resume,\n}, {\n\t \n\t.phy_id\t\t= 0x0007c0f0,  \n\t.phy_id_mask\t= 0xfffffff0,\n\t.name\t\t= \"SMSC LAN8710/LAN8720\",\n\n\t \n\n\t.probe\t\t= smsc_phy_probe,\n\n\t \n\t.read_status\t= lan87xx_read_status,\n\t.config_init\t= smsc_phy_config_init,\n\t.soft_reset\t= smsc_phy_reset,\n\t.config_aneg\t= lan95xx_config_aneg_ext,\n\n\t \n\t.config_intr\t= smsc_phy_config_intr,\n\t.handle_interrupt = smsc_phy_handle_interrupt,\n\n\t \n\t.get_sset_count = smsc_get_sset_count,\n\t.get_strings\t= smsc_get_strings,\n\t.get_stats\t= smsc_get_stats,\n\n\t.get_tunable\t= smsc_phy_get_tunable,\n\t.set_tunable\t= smsc_phy_set_tunable,\n\n\t.suspend\t= genphy_suspend,\n\t.resume\t\t= genphy_resume,\n}, {\n\t.phy_id\t\t= 0x0007c110,\n\t.phy_id_mask\t= 0xfffffff0,\n\t.name\t\t= \"SMSC LAN8740\",\n\n\t \n\t.flags\t\t= PHY_RST_AFTER_CLK_EN,\n\n\t.probe\t\t= smsc_phy_probe,\n\n\t \n\t.read_status\t= lan87xx_read_status,\n\t.config_init\t= lan874x_phy_config_init,\n\t.soft_reset\t= smsc_phy_reset,\n\n\t \n\t.config_intr\t= smsc_phy_config_intr,\n\t.handle_interrupt = smsc_phy_handle_interrupt,\n\n\t \n\t.get_sset_count = smsc_get_sset_count,\n\t.get_strings\t= smsc_get_strings,\n\t.get_stats\t= smsc_get_stats,\n\n\t.get_tunable\t= smsc_phy_get_tunable,\n\t.set_tunable\t= smsc_phy_set_tunable,\n\n\t \n\t.set_wol\t= lan874x_set_wol,\n\t.get_wol\t= lan874x_get_wol,\n\n\t.suspend\t= genphy_suspend,\n\t.resume\t\t= genphy_resume,\n}, {\n\t.phy_id\t\t= 0x0007c130,\t \n\t \n\t.phy_id_mask\t= 0xfffffff2,\n\t.name\t\t= \"Microchip LAN8742\",\n\n\t \n\t.flags\t\t= PHY_RST_AFTER_CLK_EN,\n\n\t.probe\t\t= smsc_phy_probe,\n\n\t \n\t.read_status\t= lan87xx_read_status,\n\t.config_init\t= lan874x_phy_config_init,\n\t.soft_reset\t= smsc_phy_reset,\n\n\t \n\t.config_intr\t= smsc_phy_config_intr,\n\t.handle_interrupt = smsc_phy_handle_interrupt,\n\n\t \n\t.get_sset_count = smsc_get_sset_count,\n\t.get_strings\t= smsc_get_strings,\n\t.get_stats\t= smsc_get_stats,\n\n\t.get_tunable\t= smsc_phy_get_tunable,\n\t.set_tunable\t= smsc_phy_set_tunable,\n\n\t \n\t.set_wol\t= lan874x_set_wol,\n\t.get_wol\t= lan874x_get_wol,\n\n\t.suspend\t= genphy_suspend,\n\t.resume\t\t= genphy_resume,\n} };\n\nmodule_phy_driver(smsc_phy_driver);\n\nMODULE_DESCRIPTION(\"SMSC PHY driver\");\nMODULE_AUTHOR(\"Herbert Valerio Riedel\");\nMODULE_LICENSE(\"GPL\");\n\nstatic struct mdio_device_id __maybe_unused smsc_tbl[] = {\n\t{ 0x0007c0a0, 0xfffffff0 },\n\t{ 0x0007c0b0, 0xfffffff0 },\n\t{ 0x0007c0c0, 0xfffffff0 },\n\t{ 0x0007c0d0, 0xfffffff0 },\n\t{ 0x0007c0f0, 0xfffffff0 },\n\t{ 0x0007c110, 0xfffffff0 },\n\t{ 0x0007c130, 0xfffffff2 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(mdio, smsc_tbl);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}