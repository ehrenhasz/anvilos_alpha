{
  "module_name": "mdio_bus.c",
  "hash_id": "a124184f2d43b797ba6446e449813760386b598a0973a386a03d4ee783dd40d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/mdio_bus.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/micrel_phy.h>\n#include <linux/mii.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/of_device.h>\n#include <linux/of_gpio.h>\n#include <linux/of_mdio.h>\n#include <linux/phy.h>\n#include <linux/reset.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/unistd.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/mdio.h>\n\n#include \"mdio-boardinfo.h\"\n\nstatic int mdiobus_register_gpiod(struct mdio_device *mdiodev)\n{\n\t \n\tmdiodev->reset_gpio = gpiod_get_optional(&mdiodev->dev,\n\t\t\t\t\t\t \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(mdiodev->reset_gpio))\n\t\treturn PTR_ERR(mdiodev->reset_gpio);\n\n\tif (mdiodev->reset_gpio)\n\t\tgpiod_set_consumer_name(mdiodev->reset_gpio, \"PHY reset\");\n\n\treturn 0;\n}\n\nstatic int mdiobus_register_reset(struct mdio_device *mdiodev)\n{\n\tstruct reset_control *reset;\n\n\treset = reset_control_get_optional_exclusive(&mdiodev->dev, \"phy\");\n\tif (IS_ERR(reset))\n\t\treturn PTR_ERR(reset);\n\n\tmdiodev->reset_ctrl = reset;\n\n\treturn 0;\n}\n\nint mdiobus_register_device(struct mdio_device *mdiodev)\n{\n\tint err;\n\n\tif (mdiodev->bus->mdio_map[mdiodev->addr])\n\t\treturn -EBUSY;\n\n\tif (mdiodev->flags & MDIO_DEVICE_FLAG_PHY) {\n\t\terr = mdiobus_register_gpiod(mdiodev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mdiobus_register_reset(mdiodev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tmdio_device_reset(mdiodev, 1);\n\t}\n\n\tmdiodev->bus->mdio_map[mdiodev->addr] = mdiodev;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mdiobus_register_device);\n\nint mdiobus_unregister_device(struct mdio_device *mdiodev)\n{\n\tif (mdiodev->bus->mdio_map[mdiodev->addr] != mdiodev)\n\t\treturn -EINVAL;\n\n\treset_control_put(mdiodev->reset_ctrl);\n\n\tmdiodev->bus->mdio_map[mdiodev->addr] = NULL;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mdiobus_unregister_device);\n\nstatic struct mdio_device *mdiobus_find_device(struct mii_bus *bus, int addr)\n{\n\tbool addr_valid = addr >= 0 && addr < ARRAY_SIZE(bus->mdio_map);\n\n\tif (WARN_ONCE(!addr_valid, \"addr %d out of range\\n\", addr))\n\t\treturn NULL;\n\n\treturn bus->mdio_map[addr];\n}\n\nstruct phy_device *mdiobus_get_phy(struct mii_bus *bus, int addr)\n{\n\tstruct mdio_device *mdiodev;\n\n\tmdiodev = mdiobus_find_device(bus, addr);\n\tif (!mdiodev)\n\t\treturn NULL;\n\n\tif (!(mdiodev->flags & MDIO_DEVICE_FLAG_PHY))\n\t\treturn NULL;\n\n\treturn container_of(mdiodev, struct phy_device, mdio);\n}\nEXPORT_SYMBOL(mdiobus_get_phy);\n\nbool mdiobus_is_registered_device(struct mii_bus *bus, int addr)\n{\n\treturn mdiobus_find_device(bus, addr) != NULL;\n}\nEXPORT_SYMBOL(mdiobus_is_registered_device);\n\n \nstruct mii_bus *mdiobus_alloc_size(size_t size)\n{\n\tstruct mii_bus *bus;\n\tsize_t aligned_size = ALIGN(sizeof(*bus), NETDEV_ALIGN);\n\tsize_t alloc_size;\n\tint i;\n\n\t \n\tif (size)\n\t\talloc_size = aligned_size + size;\n\telse\n\t\talloc_size = sizeof(*bus);\n\n\tbus = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!bus)\n\t\treturn NULL;\n\n\tbus->state = MDIOBUS_ALLOCATED;\n\tif (size)\n\t\tbus->priv = (void *)bus + aligned_size;\n\n\t \n\tfor (i = 0; i < PHY_MAX_ADDR; i++) {\n\t\tbus->irq[i] = PHY_POLL;\n\t\tu64_stats_init(&bus->stats[i].syncp);\n\t}\n\n\treturn bus;\n}\nEXPORT_SYMBOL(mdiobus_alloc_size);\n\n \nstatic void mdiobus_release(struct device *d)\n{\n\tstruct mii_bus *bus = to_mii_bus(d);\n\n\tWARN(bus->state != MDIOBUS_RELEASED &&\n\t      \n\t     bus->state != MDIOBUS_ALLOCATED,\n\t     \"%s: not in RELEASED or ALLOCATED state\\n\",\n\t     bus->id);\n\tkfree(bus);\n}\n\nstruct mdio_bus_stat_attr {\n\tint addr;\n\tunsigned int field_offset;\n};\n\nstatic u64 mdio_bus_get_stat(struct mdio_bus_stats *s, unsigned int offset)\n{\n\tconst char *p = (const char *)s + offset;\n\tunsigned int start;\n\tu64 val = 0;\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin(&s->syncp);\n\t\tval = u64_stats_read((const u64_stats_t *)p);\n\t} while (u64_stats_fetch_retry(&s->syncp, start));\n\n\treturn val;\n}\n\nstatic u64 mdio_bus_get_global_stat(struct mii_bus *bus, unsigned int offset)\n{\n\tunsigned int i;\n\tu64 val = 0;\n\n\tfor (i = 0; i < PHY_MAX_ADDR; i++)\n\t\tval += mdio_bus_get_stat(&bus->stats[i], offset);\n\n\treturn val;\n}\n\nstatic ssize_t mdio_bus_stat_field_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct mii_bus *bus = to_mii_bus(dev);\n\tstruct mdio_bus_stat_attr *sattr;\n\tstruct dev_ext_attribute *eattr;\n\tu64 val;\n\n\teattr = container_of(attr, struct dev_ext_attribute, attr);\n\tsattr = eattr->var;\n\n\tif (sattr->addr < 0)\n\t\tval = mdio_bus_get_global_stat(bus, sattr->field_offset);\n\telse\n\t\tval = mdio_bus_get_stat(&bus->stats[sattr->addr],\n\t\t\t\t\tsattr->field_offset);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", val);\n}\n\nstatic ssize_t mdio_bus_device_stat_field_show(struct device *dev,\n\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t       char *buf)\n{\n\tstruct mdio_device *mdiodev = to_mdio_device(dev);\n\tstruct mii_bus *bus = mdiodev->bus;\n\tstruct mdio_bus_stat_attr *sattr;\n\tstruct dev_ext_attribute *eattr;\n\tint addr = mdiodev->addr;\n\tu64 val;\n\n\teattr = container_of(attr, struct dev_ext_attribute, attr);\n\tsattr = eattr->var;\n\n\tval = mdio_bus_get_stat(&bus->stats[addr], sattr->field_offset);\n\n\treturn sysfs_emit(buf, \"%llu\\n\", val);\n}\n\n#define MDIO_BUS_STATS_ATTR_DECL(field, file)\t\t\t\t\\\nstatic struct dev_ext_attribute dev_attr_mdio_bus_##field = {\t\t\\\n\t.attr = { .attr = { .name = file, .mode = 0444 },\t\t\\\n\t\t     .show = mdio_bus_stat_field_show,\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.var = &((struct mdio_bus_stat_attr) {\t\t\t\t\\\n\t\t-1, offsetof(struct mdio_bus_stats, field)\t\t\\\n\t}),\t\t\t\t\t\t\t\t\\\n};\t\t\t\t\t\t\t\t\t\\\nstatic struct dev_ext_attribute dev_attr_mdio_bus_device_##field = {\t\\\n\t.attr = { .attr = { .name = file, .mode = 0444 },\t\t\\\n\t\t     .show = mdio_bus_device_stat_field_show,\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.var = &((struct mdio_bus_stat_attr) {\t\t\t\t\\\n\t\t-1, offsetof(struct mdio_bus_stats, field)\t\t\\\n\t}),\t\t\t\t\t\t\t\t\\\n};\n\n#define MDIO_BUS_STATS_ATTR(field)\t\t\t\t\t\\\n\tMDIO_BUS_STATS_ATTR_DECL(field, __stringify(field))\n\nMDIO_BUS_STATS_ATTR(transfers);\nMDIO_BUS_STATS_ATTR(errors);\nMDIO_BUS_STATS_ATTR(writes);\nMDIO_BUS_STATS_ATTR(reads);\n\n#define MDIO_BUS_STATS_ADDR_ATTR_DECL(field, addr, file)\t\t\\\nstatic struct dev_ext_attribute dev_attr_mdio_bus_addr_##field##_##addr = { \\\n\t.attr = { .attr = { .name = file, .mode = 0444 },\t\t\\\n\t\t     .show = mdio_bus_stat_field_show,\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n\t.var = &((struct mdio_bus_stat_attr) {\t\t\t\t\\\n\t\taddr, offsetof(struct mdio_bus_stats, field)\t\t\\\n\t}),\t\t\t\t\t\t\t\t\\\n}\n\n#define MDIO_BUS_STATS_ADDR_ATTR(field, addr)\t\t\t\t\\\n\tMDIO_BUS_STATS_ADDR_ATTR_DECL(field, addr,\t\t\t\\\n\t\t\t\t __stringify(field) \"_\" __stringify(addr))\n\n#define MDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(addr)\t\t\t\\\n\tMDIO_BUS_STATS_ADDR_ATTR(transfers, addr);\t\t\t\\\n\tMDIO_BUS_STATS_ADDR_ATTR(errors, addr);\t\t\t\t\\\n\tMDIO_BUS_STATS_ADDR_ATTR(writes, addr);\t\t\t\t\\\n\tMDIO_BUS_STATS_ADDR_ATTR(reads, addr)\t\t\t\t\\\n\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(0);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(1);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(2);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(3);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(4);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(5);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(6);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(7);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(8);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(9);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(10);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(11);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(12);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(13);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(14);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(15);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(16);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(17);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(18);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(19);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(20);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(21);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(22);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(23);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(24);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(25);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(26);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(27);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(28);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(29);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(30);\nMDIO_BUS_STATS_ADDR_ATTR_GROUP_DECL(31);\n\n#define MDIO_BUS_STATS_ADDR_ATTR_GROUP(addr)\t\t\t\t\\\n\t&dev_attr_mdio_bus_addr_transfers_##addr.attr.attr,\t\t\\\n\t&dev_attr_mdio_bus_addr_errors_##addr.attr.attr,\t\t\\\n\t&dev_attr_mdio_bus_addr_writes_##addr.attr.attr,\t\t\\\n\t&dev_attr_mdio_bus_addr_reads_##addr.attr.attr\t\t\t\\\n\nstatic struct attribute *mdio_bus_statistics_attrs[] = {\n\t&dev_attr_mdio_bus_transfers.attr.attr,\n\t&dev_attr_mdio_bus_errors.attr.attr,\n\t&dev_attr_mdio_bus_writes.attr.attr,\n\t&dev_attr_mdio_bus_reads.attr.attr,\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(0),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(1),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(2),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(3),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(4),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(5),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(6),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(7),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(8),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(9),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(10),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(11),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(12),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(13),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(14),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(15),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(16),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(17),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(18),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(19),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(20),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(21),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(22),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(23),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(24),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(25),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(26),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(27),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(28),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(29),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(30),\n\tMDIO_BUS_STATS_ADDR_ATTR_GROUP(31),\n\tNULL,\n};\n\nstatic const struct attribute_group mdio_bus_statistics_group = {\n\t.name\t= \"statistics\",\n\t.attrs\t= mdio_bus_statistics_attrs,\n};\n\nstatic const struct attribute_group *mdio_bus_groups[] = {\n\t&mdio_bus_statistics_group,\n\tNULL,\n};\n\nstatic struct class mdio_bus_class = {\n\t.name\t\t= \"mdio_bus\",\n\t.dev_release\t= mdiobus_release,\n\t.dev_groups\t= mdio_bus_groups,\n};\n\n \nstruct mii_bus *mdio_find_bus(const char *mdio_name)\n{\n\tstruct device *d;\n\n\td = class_find_device_by_name(&mdio_bus_class, mdio_name);\n\treturn d ? to_mii_bus(d) : NULL;\n}\nEXPORT_SYMBOL(mdio_find_bus);\n\n#if IS_ENABLED(CONFIG_OF_MDIO)\n \nstruct mii_bus *of_mdio_find_bus(struct device_node *mdio_bus_np)\n{\n\tstruct device *d;\n\n\tif (!mdio_bus_np)\n\t\treturn NULL;\n\n\td = class_find_device_by_of_node(&mdio_bus_class, mdio_bus_np);\n\treturn d ? to_mii_bus(d) : NULL;\n}\nEXPORT_SYMBOL(of_mdio_find_bus);\n\n \nstatic void of_mdiobus_link_mdiodev(struct mii_bus *bus,\n\t\t\t\t    struct mdio_device *mdiodev)\n{\n\tstruct device *dev = &mdiodev->dev;\n\tstruct device_node *child;\n\n\tif (dev->of_node || !bus->dev.of_node)\n\t\treturn;\n\n\tfor_each_available_child_of_node(bus->dev.of_node, child) {\n\t\tint addr;\n\n\t\taddr = of_mdio_parse_addr(dev, child);\n\t\tif (addr < 0)\n\t\t\tcontinue;\n\n\t\tif (addr == mdiodev->addr) {\n\t\t\tdevice_set_node(dev, of_fwnode_handle(child));\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t}\n}\n#else  \nstatic inline void of_mdiobus_link_mdiodev(struct mii_bus *mdio,\n\t\t\t\t\t   struct mdio_device *mdiodev)\n{\n}\n#endif\n\n \nstatic int mdiobus_create_device(struct mii_bus *bus,\n\t\t\t\t struct mdio_board_info *bi)\n{\n\tstruct mdio_device *mdiodev;\n\tint ret = 0;\n\n\tmdiodev = mdio_device_create(bus, bi->mdio_addr);\n\tif (IS_ERR(mdiodev))\n\t\treturn -ENODEV;\n\n\tstrncpy(mdiodev->modalias, bi->modalias,\n\t\tsizeof(mdiodev->modalias));\n\tmdiodev->bus_match = mdio_device_bus_match;\n\tmdiodev->dev.platform_data = (void *)bi->platform_data;\n\n\tret = mdio_device_register(mdiodev);\n\tif (ret)\n\t\tmdio_device_free(mdiodev);\n\n\treturn ret;\n}\n\nstatic struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr, bool c45)\n{\n\tstruct phy_device *phydev = ERR_PTR(-ENODEV);\n\tint err;\n\n\tphydev = get_phy_device(bus, addr, c45);\n\tif (IS_ERR(phydev))\n\t\treturn phydev;\n\n\t \n\tof_mdiobus_link_mdiodev(bus, &phydev->mdio);\n\n\terr = phy_device_register(phydev);\n\tif (err) {\n\t\tphy_device_free(phydev);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\treturn phydev;\n}\n\n \nstruct phy_device *mdiobus_scan_c22(struct mii_bus *bus, int addr)\n{\n\treturn mdiobus_scan(bus, addr, false);\n}\nEXPORT_SYMBOL(mdiobus_scan_c22);\n\n \nstatic struct phy_device *mdiobus_scan_c45(struct mii_bus *bus, int addr)\n{\n\treturn mdiobus_scan(bus, addr, true);\n}\n\nstatic int mdiobus_scan_bus_c22(struct mii_bus *bus)\n{\n\tint i;\n\n\tfor (i = 0; i < PHY_MAX_ADDR; i++) {\n\t\tif ((bus->phy_mask & BIT(i)) == 0) {\n\t\t\tstruct phy_device *phydev;\n\n\t\t\tphydev = mdiobus_scan_c22(bus, i);\n\t\t\tif (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV))\n\t\t\t\treturn PTR_ERR(phydev);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int mdiobus_scan_bus_c45(struct mii_bus *bus)\n{\n\tint i;\n\n\tfor (i = 0; i < PHY_MAX_ADDR; i++) {\n\t\tif ((bus->phy_mask & BIT(i)) == 0) {\n\t\t\tstruct phy_device *phydev;\n\n\t\t\t \n\t\t\tif (bus->mdio_map[i])\n\t\t\t\tcontinue;\n\n\t\t\tphydev = mdiobus_scan_c45(bus, i);\n\t\t\tif (IS_ERR(phydev) && (PTR_ERR(phydev) != -ENODEV))\n\t\t\t\treturn PTR_ERR(phydev);\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic bool mdiobus_prevent_c45_scan(struct mii_bus *bus)\n{\n\tint i;\n\n\tfor (i = 0; i < PHY_MAX_ADDR; i++) {\n\t\tstruct phy_device *phydev;\n\t\tu32 oui;\n\n\t\tphydev = mdiobus_get_phy(bus, i);\n\t\tif (!phydev)\n\t\t\tcontinue;\n\t\toui = phydev->phy_id >> 10;\n\n\t\tif (oui == MICREL_OUI)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nint __mdiobus_register(struct mii_bus *bus, struct module *owner)\n{\n\tstruct mdio_device *mdiodev;\n\tstruct gpio_desc *gpiod;\n\tbool prevent_c45_scan;\n\tint i, err;\n\n\tif (!bus || !bus->name)\n\t\treturn -EINVAL;\n\n\t \n\tif (!!bus->read != !!bus->write || !!bus->read_c45 != !!bus->write_c45)\n\t\treturn -EINVAL;\n\n\t \n\tif (!bus->read && !bus->read_c45)\n\t\treturn -EINVAL;\n\n\tif (bus->parent && bus->parent->of_node)\n\t\tbus->parent->of_node->fwnode.flags |=\n\t\t\t\t\tFWNODE_FLAG_NEEDS_CHILD_BOUND_ON_ADD;\n\n\tWARN(bus->state != MDIOBUS_ALLOCATED &&\n\t     bus->state != MDIOBUS_UNREGISTERED,\n\t     \"%s: not in ALLOCATED or UNREGISTERED state\\n\", bus->id);\n\n\tbus->owner = owner;\n\tbus->dev.parent = bus->parent;\n\tbus->dev.class = &mdio_bus_class;\n\tbus->dev.groups = NULL;\n\tdev_set_name(&bus->dev, \"%s\", bus->id);\n\n\t \n\tbus->state = MDIOBUS_UNREGISTERED;\n\n\terr = device_register(&bus->dev);\n\tif (err) {\n\t\tpr_err(\"mii_bus %s failed to register\\n\", bus->id);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_init(&bus->mdio_lock);\n\tmutex_init(&bus->shared_lock);\n\n\t \n\tgpiod = devm_gpiod_get_optional(&bus->dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(gpiod)) {\n\t\terr = dev_err_probe(&bus->dev, PTR_ERR(gpiod),\n\t\t\t\t    \"mii_bus %s couldn't get reset GPIO\\n\",\n\t\t\t\t    bus->id);\n\t\tdevice_del(&bus->dev);\n\t\treturn err;\n\t} else\tif (gpiod) {\n\t\tbus->reset_gpiod = gpiod;\n\t\tfsleep(bus->reset_delay_us);\n\t\tgpiod_set_value_cansleep(gpiod, 0);\n\t\tif (bus->reset_post_delay_us > 0)\n\t\t\tfsleep(bus->reset_post_delay_us);\n\t}\n\n\tif (bus->reset) {\n\t\terr = bus->reset(bus);\n\t\tif (err)\n\t\t\tgoto error_reset_gpiod;\n\t}\n\n\tif (bus->read) {\n\t\terr = mdiobus_scan_bus_c22(bus);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\n\tprevent_c45_scan = mdiobus_prevent_c45_scan(bus);\n\n\tif (!prevent_c45_scan && bus->read_c45) {\n\t\terr = mdiobus_scan_bus_c45(bus);\n\t\tif (err)\n\t\t\tgoto error;\n\t}\n\n\tmdiobus_setup_mdiodev_from_board_info(bus, mdiobus_create_device);\n\n\tbus->state = MDIOBUS_REGISTERED;\n\tdev_dbg(&bus->dev, \"probed\\n\");\n\treturn 0;\n\nerror:\n\tfor (i = 0; i < PHY_MAX_ADDR; i++) {\n\t\tmdiodev = bus->mdio_map[i];\n\t\tif (!mdiodev)\n\t\t\tcontinue;\n\n\t\tmdiodev->device_remove(mdiodev);\n\t\tmdiodev->device_free(mdiodev);\n\t}\nerror_reset_gpiod:\n\t \n\tif (bus->reset_gpiod)\n\t\tgpiod_set_value_cansleep(bus->reset_gpiod, 1);\n\n\tdevice_del(&bus->dev);\n\treturn err;\n}\nEXPORT_SYMBOL(__mdiobus_register);\n\nvoid mdiobus_unregister(struct mii_bus *bus)\n{\n\tstruct mdio_device *mdiodev;\n\tint i;\n\n\tif (WARN_ON_ONCE(bus->state != MDIOBUS_REGISTERED))\n\t\treturn;\n\tbus->state = MDIOBUS_UNREGISTERED;\n\n\tfor (i = 0; i < PHY_MAX_ADDR; i++) {\n\t\tmdiodev = bus->mdio_map[i];\n\t\tif (!mdiodev)\n\t\t\tcontinue;\n\n\t\tif (mdiodev->reset_gpio)\n\t\t\tgpiod_put(mdiodev->reset_gpio);\n\n\t\tmdiodev->device_remove(mdiodev);\n\t\tmdiodev->device_free(mdiodev);\n\t}\n\n\t \n\tif (bus->reset_gpiod)\n\t\tgpiod_set_value_cansleep(bus->reset_gpiod, 1);\n\n\tdevice_del(&bus->dev);\n}\nEXPORT_SYMBOL(mdiobus_unregister);\n\n \nvoid mdiobus_free(struct mii_bus *bus)\n{\n\t \n\tif (bus->state == MDIOBUS_ALLOCATED) {\n\t\tkfree(bus);\n\t\treturn;\n\t}\n\n\tWARN(bus->state != MDIOBUS_UNREGISTERED,\n\t     \"%s: not in UNREGISTERED state\\n\", bus->id);\n\tbus->state = MDIOBUS_RELEASED;\n\n\tput_device(&bus->dev);\n}\nEXPORT_SYMBOL(mdiobus_free);\n\nstatic void mdiobus_stats_acct(struct mdio_bus_stats *stats, bool op, int ret)\n{\n\tpreempt_disable();\n\tu64_stats_update_begin(&stats->syncp);\n\n\tu64_stats_inc(&stats->transfers);\n\tif (ret < 0) {\n\t\tu64_stats_inc(&stats->errors);\n\t\tgoto out;\n\t}\n\n\tif (op)\n\t\tu64_stats_inc(&stats->reads);\n\telse\n\t\tu64_stats_inc(&stats->writes);\nout:\n\tu64_stats_update_end(&stats->syncp);\n\tpreempt_enable();\n}\n\n \nint __mdiobus_read(struct mii_bus *bus, int addr, u32 regnum)\n{\n\tint retval;\n\n\tlockdep_assert_held_once(&bus->mdio_lock);\n\n\tif (bus->read)\n\t\tretval = bus->read(bus, addr, regnum);\n\telse\n\t\tretval = -EOPNOTSUPP;\n\n\ttrace_mdio_access(bus, 1, addr, regnum, retval, retval);\n\tmdiobus_stats_acct(&bus->stats[addr], true, retval);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(__mdiobus_read);\n\n \nint __mdiobus_write(struct mii_bus *bus, int addr, u32 regnum, u16 val)\n{\n\tint err;\n\n\tlockdep_assert_held_once(&bus->mdio_lock);\n\n\tif (bus->write)\n\t\terr = bus->write(bus, addr, regnum, val);\n\telse\n\t\terr = -EOPNOTSUPP;\n\n\ttrace_mdio_access(bus, 0, addr, regnum, val, err);\n\tmdiobus_stats_acct(&bus->stats[addr], false, err);\n\n\treturn err;\n}\nEXPORT_SYMBOL(__mdiobus_write);\n\n \nint __mdiobus_modify_changed(struct mii_bus *bus, int addr, u32 regnum,\n\t\t\t     u16 mask, u16 set)\n{\n\tint new, ret;\n\n\tret = __mdiobus_read(bus, addr, regnum);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnew = (ret & ~mask) | set;\n\tif (new == ret)\n\t\treturn 0;\n\n\tret = __mdiobus_write(bus, addr, regnum, new);\n\n\treturn ret < 0 ? ret : 1;\n}\nEXPORT_SYMBOL_GPL(__mdiobus_modify_changed);\n\n \nint __mdiobus_c45_read(struct mii_bus *bus, int addr, int devad, u32 regnum)\n{\n\tint retval;\n\n\tlockdep_assert_held_once(&bus->mdio_lock);\n\n\tif (bus->read_c45)\n\t\tretval = bus->read_c45(bus, addr, devad, regnum);\n\telse\n\t\tretval = -EOPNOTSUPP;\n\n\ttrace_mdio_access(bus, 1, addr, regnum, retval, retval);\n\tmdiobus_stats_acct(&bus->stats[addr], true, retval);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(__mdiobus_c45_read);\n\n \nint __mdiobus_c45_write(struct mii_bus *bus, int addr, int devad, u32 regnum,\n\t\t\tu16 val)\n{\n\tint err;\n\n\tlockdep_assert_held_once(&bus->mdio_lock);\n\n\tif (bus->write_c45)\n\t\terr = bus->write_c45(bus, addr, devad, regnum, val);\n\telse\n\t\terr = -EOPNOTSUPP;\n\n\ttrace_mdio_access(bus, 0, addr, regnum, val, err);\n\tmdiobus_stats_acct(&bus->stats[addr], false, err);\n\n\treturn err;\n}\nEXPORT_SYMBOL(__mdiobus_c45_write);\n\n \nstatic int __mdiobus_c45_modify_changed(struct mii_bus *bus, int addr,\n\t\t\t\t\tint devad, u32 regnum, u16 mask,\n\t\t\t\t\tu16 set)\n{\n\tint new, ret;\n\n\tret = __mdiobus_c45_read(bus, addr, devad, regnum);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnew = (ret & ~mask) | set;\n\tif (new == ret)\n\t\treturn 0;\n\n\tret = __mdiobus_c45_write(bus, addr, devad, regnum, new);\n\n\treturn ret < 0 ? ret : 1;\n}\n\n \nint mdiobus_read_nested(struct mii_bus *bus, int addr, u32 regnum)\n{\n\tint retval;\n\n\tmutex_lock_nested(&bus->mdio_lock, MDIO_MUTEX_NESTED);\n\tretval = __mdiobus_read(bus, addr, regnum);\n\tmutex_unlock(&bus->mdio_lock);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(mdiobus_read_nested);\n\n \nint mdiobus_read(struct mii_bus *bus, int addr, u32 regnum)\n{\n\tint retval;\n\n\tmutex_lock(&bus->mdio_lock);\n\tretval = __mdiobus_read(bus, addr, regnum);\n\tmutex_unlock(&bus->mdio_lock);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(mdiobus_read);\n\n \nint mdiobus_c45_read(struct mii_bus *bus, int addr, int devad, u32 regnum)\n{\n\tint retval;\n\n\tmutex_lock(&bus->mdio_lock);\n\tretval = __mdiobus_c45_read(bus, addr, devad, regnum);\n\tmutex_unlock(&bus->mdio_lock);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(mdiobus_c45_read);\n\n \nint mdiobus_c45_read_nested(struct mii_bus *bus, int addr, int devad,\n\t\t\t    u32 regnum)\n{\n\tint retval;\n\n\tmutex_lock_nested(&bus->mdio_lock, MDIO_MUTEX_NESTED);\n\tretval = __mdiobus_c45_read(bus, addr, devad, regnum);\n\tmutex_unlock(&bus->mdio_lock);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(mdiobus_c45_read_nested);\n\n \nint mdiobus_write_nested(struct mii_bus *bus, int addr, u32 regnum, u16 val)\n{\n\tint err;\n\n\tmutex_lock_nested(&bus->mdio_lock, MDIO_MUTEX_NESTED);\n\terr = __mdiobus_write(bus, addr, regnum, val);\n\tmutex_unlock(&bus->mdio_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL(mdiobus_write_nested);\n\n \nint mdiobus_write(struct mii_bus *bus, int addr, u32 regnum, u16 val)\n{\n\tint err;\n\n\tmutex_lock(&bus->mdio_lock);\n\terr = __mdiobus_write(bus, addr, regnum, val);\n\tmutex_unlock(&bus->mdio_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL(mdiobus_write);\n\n \nint mdiobus_c45_write(struct mii_bus *bus, int addr, int devad, u32 regnum,\n\t\t      u16 val)\n{\n\tint err;\n\n\tmutex_lock(&bus->mdio_lock);\n\terr = __mdiobus_c45_write(bus, addr, devad, regnum, val);\n\tmutex_unlock(&bus->mdio_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL(mdiobus_c45_write);\n\n \nint mdiobus_c45_write_nested(struct mii_bus *bus, int addr, int devad,\n\t\t\t     u32 regnum, u16 val)\n{\n\tint err;\n\n\tmutex_lock_nested(&bus->mdio_lock, MDIO_MUTEX_NESTED);\n\terr = __mdiobus_c45_write(bus, addr, devad, regnum, val);\n\tmutex_unlock(&bus->mdio_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL(mdiobus_c45_write_nested);\n\n \nint __mdiobus_modify(struct mii_bus *bus, int addr, u32 regnum, u16 mask,\n\t\t     u16 set)\n{\n\tint err;\n\n\terr = __mdiobus_modify_changed(bus, addr, regnum, mask, set);\n\n\treturn err < 0 ? err : 0;\n}\nEXPORT_SYMBOL_GPL(__mdiobus_modify);\n\n \nint mdiobus_modify(struct mii_bus *bus, int addr, u32 regnum, u16 mask, u16 set)\n{\n\tint err;\n\n\tmutex_lock(&bus->mdio_lock);\n\terr = __mdiobus_modify(bus, addr, regnum, mask, set);\n\tmutex_unlock(&bus->mdio_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mdiobus_modify);\n\n \nint mdiobus_c45_modify(struct mii_bus *bus, int addr, int devad, u32 regnum,\n\t\t       u16 mask, u16 set)\n{\n\tint err;\n\n\tmutex_lock(&bus->mdio_lock);\n\terr = __mdiobus_c45_modify_changed(bus, addr, devad, regnum,\n\t\t\t\t\t   mask, set);\n\tmutex_unlock(&bus->mdio_lock);\n\n\treturn err < 0 ? err : 0;\n}\nEXPORT_SYMBOL_GPL(mdiobus_c45_modify);\n\n \nint mdiobus_modify_changed(struct mii_bus *bus, int addr, u32 regnum,\n\t\t\t   u16 mask, u16 set)\n{\n\tint err;\n\n\tmutex_lock(&bus->mdio_lock);\n\terr = __mdiobus_modify_changed(bus, addr, regnum, mask, set);\n\tmutex_unlock(&bus->mdio_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mdiobus_modify_changed);\n\n \nint mdiobus_c45_modify_changed(struct mii_bus *bus, int addr, int devad,\n\t\t\t       u32 regnum, u16 mask, u16 set)\n{\n\tint err;\n\n\tmutex_lock(&bus->mdio_lock);\n\terr = __mdiobus_c45_modify_changed(bus, addr, devad, regnum, mask, set);\n\tmutex_unlock(&bus->mdio_lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mdiobus_c45_modify_changed);\n\n \nstatic int mdio_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct mdio_driver *mdiodrv = to_mdio_driver(drv);\n\tstruct mdio_device *mdio = to_mdio_device(dev);\n\n\t \n\tif (!(mdiodrv->mdiodrv.flags & MDIO_DEVICE_IS_PHY) !=\n\t    !(mdio->flags & MDIO_DEVICE_FLAG_PHY))\n\t\treturn 0;\n\n\tif (of_driver_match_device(dev, drv))\n\t\treturn 1;\n\n\tif (mdio->bus_match)\n\t\treturn mdio->bus_match(dev, drv);\n\n\treturn 0;\n}\n\nstatic int mdio_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tint rc;\n\n\t \n\trc = of_device_uevent_modalias(dev, env);\n\tif (rc != -ENODEV)\n\t\treturn rc;\n\n\treturn 0;\n}\n\nstatic struct attribute *mdio_bus_device_statistics_attrs[] = {\n\t&dev_attr_mdio_bus_device_transfers.attr.attr,\n\t&dev_attr_mdio_bus_device_errors.attr.attr,\n\t&dev_attr_mdio_bus_device_writes.attr.attr,\n\t&dev_attr_mdio_bus_device_reads.attr.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group mdio_bus_device_statistics_group = {\n\t.name\t= \"statistics\",\n\t.attrs\t= mdio_bus_device_statistics_attrs,\n};\n\nstatic const struct attribute_group *mdio_bus_dev_groups[] = {\n\t&mdio_bus_device_statistics_group,\n\tNULL,\n};\n\nstruct bus_type mdio_bus_type = {\n\t.name\t\t= \"mdio_bus\",\n\t.dev_groups\t= mdio_bus_dev_groups,\n\t.match\t\t= mdio_bus_match,\n\t.uevent\t\t= mdio_uevent,\n};\nEXPORT_SYMBOL(mdio_bus_type);\n\nint __init mdio_bus_init(void)\n{\n\tint ret;\n\n\tret = class_register(&mdio_bus_class);\n\tif (!ret) {\n\t\tret = bus_register(&mdio_bus_type);\n\t\tif (ret)\n\t\t\tclass_unregister(&mdio_bus_class);\n\t}\n\n\treturn ret;\n}\n\n#if IS_ENABLED(CONFIG_PHYLIB)\nvoid mdio_bus_exit(void)\n{\n\tclass_unregister(&mdio_bus_class);\n\tbus_unregister(&mdio_bus_type);\n}\nEXPORT_SYMBOL_GPL(mdio_bus_exit);\n#else\nmodule_init(mdio_bus_init);\n \nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"MDIO bus/device layer\");\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}