{
  "module_name": "cicada.c",
  "hash_id": "c19c4633e1ea7f710bea3885db99c92812e5d292a426dda3026ef56b35544fc9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/cicada.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/unistd.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/phy.h>\n\n#include <linux/io.h>\n#include <asm/irq.h>\n#include <linux/uaccess.h>\n\n \n#define MII_CIS8201_EXT_CON1           0x17\n#define MII_CIS8201_EXTCON1_INIT       0x0000\n\n \n#define MII_CIS8201_IMASK\t\t0x19\n#define MII_CIS8201_IMASK_IEN\t\t0x8000\n#define MII_CIS8201_IMASK_SPEED\t0x4000\n#define MII_CIS8201_IMASK_LINK\t\t0x2000\n#define MII_CIS8201_IMASK_DUPLEX\t0x1000\n#define MII_CIS8201_IMASK_MASK\t\t0xf000\n\n \n#define MII_CIS8201_ISTAT\t\t0x1a\n#define MII_CIS8201_ISTAT_STATUS\t0x8000\n#define MII_CIS8201_ISTAT_SPEED\t0x4000\n#define MII_CIS8201_ISTAT_LINK\t\t0x2000\n#define MII_CIS8201_ISTAT_DUPLEX\t0x1000\n\n \n#define MII_CIS8201_AUX_CONSTAT        0x1c\n#define MII_CIS8201_AUXCONSTAT_INIT    0x0004\n#define MII_CIS8201_AUXCONSTAT_DUPLEX  0x0020\n#define MII_CIS8201_AUXCONSTAT_SPEED   0x0018\n#define MII_CIS8201_AUXCONSTAT_GBIT    0x0010\n#define MII_CIS8201_AUXCONSTAT_100     0x0008\n\nMODULE_DESCRIPTION(\"Cicadia PHY driver\");\nMODULE_AUTHOR(\"Andy Fleming\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int cis820x_config_init(struct phy_device *phydev)\n{\n\tint err;\n\n\terr = phy_write(phydev, MII_CIS8201_AUX_CONSTAT,\n\t\t\tMII_CIS8201_AUXCONSTAT_INIT);\n\n\tif (err < 0)\n\t\treturn err;\n\n\terr = phy_write(phydev, MII_CIS8201_EXT_CON1,\n\t\t\tMII_CIS8201_EXTCON1_INIT);\n\n\treturn err;\n}\n\nstatic int cis820x_ack_interrupt(struct phy_device *phydev)\n{\n\tint err = phy_read(phydev, MII_CIS8201_ISTAT);\n\n\treturn (err < 0) ? err : 0;\n}\n\nstatic int cis820x_config_intr(struct phy_device *phydev)\n{\n\tint err;\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\terr = cis820x_ack_interrupt(phydev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = phy_write(phydev, MII_CIS8201_IMASK,\n\t\t\t\tMII_CIS8201_IMASK_MASK);\n\t} else {\n\t\terr = phy_write(phydev, MII_CIS8201_IMASK, 0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = cis820x_ack_interrupt(phydev);\n\t}\n\n\treturn err;\n}\n\nstatic irqreturn_t cis820x_handle_interrupt(struct phy_device *phydev)\n{\n\tint irq_status;\n\n\tirq_status = phy_read(phydev, MII_CIS8201_ISTAT);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (!(irq_status & MII_CIS8201_IMASK_MASK))\n\t\treturn IRQ_NONE;\n\n\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic struct phy_driver cis820x_driver[] = {\n{\n\t.phy_id\t\t= 0x000fc410,\n\t.name\t\t= \"Cicada Cis8201\",\n\t.phy_id_mask\t= 0x000ffff0,\n\t \n\t.config_init\t= &cis820x_config_init,\n\t.config_intr\t= &cis820x_config_intr,\n\t.handle_interrupt = &cis820x_handle_interrupt,\n}, {\n\t.phy_id\t\t= 0x000fc440,\n\t.name\t\t= \"Cicada Cis8204\",\n\t.phy_id_mask\t= 0x000fffc0,\n\t \n\t.config_init\t= &cis820x_config_init,\n\t.config_intr\t= &cis820x_config_intr,\n\t.handle_interrupt = &cis820x_handle_interrupt,\n} };\n\nmodule_phy_driver(cis820x_driver);\n\nstatic struct mdio_device_id __maybe_unused cicada_tbl[] = {\n\t{ 0x000fc410, 0x000ffff0 },\n\t{ 0x000fc440, 0x000fffc0 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(mdio, cicada_tbl);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}