{
  "module_name": "phy_device.c",
  "hash_id": "d27f8a10430fac3797e4ac5defa75b134e5860f62f21e1862245cc5b66912cf4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/phy_device.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/acpi.h>\n#include <linux/bitmap.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/mdio.h>\n#include <linux/mii.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/netdevice.h>\n#include <linux/phy.h>\n#include <linux/phylib_stubs.h>\n#include <linux/phy_led_triggers.h>\n#include <linux/pse-pd/pse.h>\n#include <linux/property.h>\n#include <linux/rtnetlink.h>\n#include <linux/sfp.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/unistd.h>\n\nMODULE_DESCRIPTION(\"PHY library\");\nMODULE_AUTHOR(\"Andy Fleming\");\nMODULE_LICENSE(\"GPL\");\n\n__ETHTOOL_DECLARE_LINK_MODE_MASK(phy_basic_features) __ro_after_init;\nEXPORT_SYMBOL_GPL(phy_basic_features);\n\n__ETHTOOL_DECLARE_LINK_MODE_MASK(phy_basic_t1_features) __ro_after_init;\nEXPORT_SYMBOL_GPL(phy_basic_t1_features);\n\n__ETHTOOL_DECLARE_LINK_MODE_MASK(phy_basic_t1s_p2mp_features) __ro_after_init;\nEXPORT_SYMBOL_GPL(phy_basic_t1s_p2mp_features);\n\n__ETHTOOL_DECLARE_LINK_MODE_MASK(phy_gbit_features) __ro_after_init;\nEXPORT_SYMBOL_GPL(phy_gbit_features);\n\n__ETHTOOL_DECLARE_LINK_MODE_MASK(phy_gbit_fibre_features) __ro_after_init;\nEXPORT_SYMBOL_GPL(phy_gbit_fibre_features);\n\n__ETHTOOL_DECLARE_LINK_MODE_MASK(phy_gbit_all_ports_features) __ro_after_init;\nEXPORT_SYMBOL_GPL(phy_gbit_all_ports_features);\n\n__ETHTOOL_DECLARE_LINK_MODE_MASK(phy_10gbit_features) __ro_after_init;\nEXPORT_SYMBOL_GPL(phy_10gbit_features);\n\n__ETHTOOL_DECLARE_LINK_MODE_MASK(phy_10gbit_fec_features) __ro_after_init;\nEXPORT_SYMBOL_GPL(phy_10gbit_fec_features);\n\nconst int phy_basic_ports_array[3] = {\n\tETHTOOL_LINK_MODE_Autoneg_BIT,\n\tETHTOOL_LINK_MODE_TP_BIT,\n\tETHTOOL_LINK_MODE_MII_BIT,\n};\nEXPORT_SYMBOL_GPL(phy_basic_ports_array);\n\nconst int phy_fibre_port_array[1] = {\n\tETHTOOL_LINK_MODE_FIBRE_BIT,\n};\nEXPORT_SYMBOL_GPL(phy_fibre_port_array);\n\nconst int phy_all_ports_features_array[7] = {\n\tETHTOOL_LINK_MODE_Autoneg_BIT,\n\tETHTOOL_LINK_MODE_TP_BIT,\n\tETHTOOL_LINK_MODE_MII_BIT,\n\tETHTOOL_LINK_MODE_FIBRE_BIT,\n\tETHTOOL_LINK_MODE_AUI_BIT,\n\tETHTOOL_LINK_MODE_BNC_BIT,\n\tETHTOOL_LINK_MODE_Backplane_BIT,\n};\nEXPORT_SYMBOL_GPL(phy_all_ports_features_array);\n\nconst int phy_10_100_features_array[4] = {\n\tETHTOOL_LINK_MODE_10baseT_Half_BIT,\n\tETHTOOL_LINK_MODE_10baseT_Full_BIT,\n\tETHTOOL_LINK_MODE_100baseT_Half_BIT,\n\tETHTOOL_LINK_MODE_100baseT_Full_BIT,\n};\nEXPORT_SYMBOL_GPL(phy_10_100_features_array);\n\nconst int phy_basic_t1_features_array[3] = {\n\tETHTOOL_LINK_MODE_TP_BIT,\n\tETHTOOL_LINK_MODE_10baseT1L_Full_BIT,\n\tETHTOOL_LINK_MODE_100baseT1_Full_BIT,\n};\nEXPORT_SYMBOL_GPL(phy_basic_t1_features_array);\n\nconst int phy_basic_t1s_p2mp_features_array[2] = {\n\tETHTOOL_LINK_MODE_TP_BIT,\n\tETHTOOL_LINK_MODE_10baseT1S_P2MP_Half_BIT,\n};\nEXPORT_SYMBOL_GPL(phy_basic_t1s_p2mp_features_array);\n\nconst int phy_gbit_features_array[2] = {\n\tETHTOOL_LINK_MODE_1000baseT_Half_BIT,\n\tETHTOOL_LINK_MODE_1000baseT_Full_BIT,\n};\nEXPORT_SYMBOL_GPL(phy_gbit_features_array);\n\nconst int phy_10gbit_features_array[1] = {\n\tETHTOOL_LINK_MODE_10000baseT_Full_BIT,\n};\nEXPORT_SYMBOL_GPL(phy_10gbit_features_array);\n\nstatic const int phy_10gbit_fec_features_array[1] = {\n\tETHTOOL_LINK_MODE_10000baseR_FEC_BIT,\n};\n\n__ETHTOOL_DECLARE_LINK_MODE_MASK(phy_10gbit_full_features) __ro_after_init;\nEXPORT_SYMBOL_GPL(phy_10gbit_full_features);\n\nstatic const int phy_10gbit_full_features_array[] = {\n\tETHTOOL_LINK_MODE_10baseT_Full_BIT,\n\tETHTOOL_LINK_MODE_100baseT_Full_BIT,\n\tETHTOOL_LINK_MODE_1000baseT_Full_BIT,\n\tETHTOOL_LINK_MODE_10000baseT_Full_BIT,\n};\n\nstatic const int phy_eee_cap1_features_array[] = {\n\tETHTOOL_LINK_MODE_100baseT_Full_BIT,\n\tETHTOOL_LINK_MODE_1000baseT_Full_BIT,\n\tETHTOOL_LINK_MODE_10000baseT_Full_BIT,\n\tETHTOOL_LINK_MODE_1000baseKX_Full_BIT,\n\tETHTOOL_LINK_MODE_10000baseKX4_Full_BIT,\n\tETHTOOL_LINK_MODE_10000baseKR_Full_BIT,\n};\n\n__ETHTOOL_DECLARE_LINK_MODE_MASK(phy_eee_cap1_features) __ro_after_init;\nEXPORT_SYMBOL_GPL(phy_eee_cap1_features);\n\nstatic void features_init(void)\n{\n\t \n\tlinkmode_set_bit_array(phy_basic_ports_array,\n\t\t\t       ARRAY_SIZE(phy_basic_ports_array),\n\t\t\t       phy_basic_features);\n\tlinkmode_set_bit_array(phy_10_100_features_array,\n\t\t\t       ARRAY_SIZE(phy_10_100_features_array),\n\t\t\t       phy_basic_features);\n\n\t \n\tlinkmode_set_bit_array(phy_basic_t1_features_array,\n\t\t\t       ARRAY_SIZE(phy_basic_t1_features_array),\n\t\t\t       phy_basic_t1_features);\n\n\t \n\tlinkmode_set_bit_array(phy_basic_t1s_p2mp_features_array,\n\t\t\t       ARRAY_SIZE(phy_basic_t1s_p2mp_features_array),\n\t\t\t       phy_basic_t1s_p2mp_features);\n\n\t \n\tlinkmode_set_bit_array(phy_basic_ports_array,\n\t\t\t       ARRAY_SIZE(phy_basic_ports_array),\n\t\t\t       phy_gbit_features);\n\tlinkmode_set_bit_array(phy_10_100_features_array,\n\t\t\t       ARRAY_SIZE(phy_10_100_features_array),\n\t\t\t       phy_gbit_features);\n\tlinkmode_set_bit_array(phy_gbit_features_array,\n\t\t\t       ARRAY_SIZE(phy_gbit_features_array),\n\t\t\t       phy_gbit_features);\n\n\t \n\tlinkmode_set_bit_array(phy_basic_ports_array,\n\t\t\t       ARRAY_SIZE(phy_basic_ports_array),\n\t\t\t       phy_gbit_fibre_features);\n\tlinkmode_set_bit_array(phy_10_100_features_array,\n\t\t\t       ARRAY_SIZE(phy_10_100_features_array),\n\t\t\t       phy_gbit_fibre_features);\n\tlinkmode_set_bit_array(phy_gbit_features_array,\n\t\t\t       ARRAY_SIZE(phy_gbit_features_array),\n\t\t\t       phy_gbit_fibre_features);\n\tlinkmode_set_bit_array(phy_fibre_port_array,\n\t\t\t       ARRAY_SIZE(phy_fibre_port_array),\n\t\t\t       phy_gbit_fibre_features);\n\n\t \n\tlinkmode_set_bit_array(phy_all_ports_features_array,\n\t\t\t       ARRAY_SIZE(phy_all_ports_features_array),\n\t\t\t       phy_gbit_all_ports_features);\n\tlinkmode_set_bit_array(phy_10_100_features_array,\n\t\t\t       ARRAY_SIZE(phy_10_100_features_array),\n\t\t\t       phy_gbit_all_ports_features);\n\tlinkmode_set_bit_array(phy_gbit_features_array,\n\t\t\t       ARRAY_SIZE(phy_gbit_features_array),\n\t\t\t       phy_gbit_all_ports_features);\n\n\t \n\tlinkmode_set_bit_array(phy_all_ports_features_array,\n\t\t\t       ARRAY_SIZE(phy_all_ports_features_array),\n\t\t\t       phy_10gbit_features);\n\tlinkmode_set_bit_array(phy_10_100_features_array,\n\t\t\t       ARRAY_SIZE(phy_10_100_features_array),\n\t\t\t       phy_10gbit_features);\n\tlinkmode_set_bit_array(phy_gbit_features_array,\n\t\t\t       ARRAY_SIZE(phy_gbit_features_array),\n\t\t\t       phy_10gbit_features);\n\tlinkmode_set_bit_array(phy_10gbit_features_array,\n\t\t\t       ARRAY_SIZE(phy_10gbit_features_array),\n\t\t\t       phy_10gbit_features);\n\n\t \n\tlinkmode_set_bit_array(phy_all_ports_features_array,\n\t\t\t       ARRAY_SIZE(phy_all_ports_features_array),\n\t\t\t       phy_10gbit_full_features);\n\tlinkmode_set_bit_array(phy_10gbit_full_features_array,\n\t\t\t       ARRAY_SIZE(phy_10gbit_full_features_array),\n\t\t\t       phy_10gbit_full_features);\n\t \n\tlinkmode_set_bit_array(phy_10gbit_fec_features_array,\n\t\t\t       ARRAY_SIZE(phy_10gbit_fec_features_array),\n\t\t\t       phy_10gbit_fec_features);\n\tlinkmode_set_bit_array(phy_eee_cap1_features_array,\n\t\t\t       ARRAY_SIZE(phy_eee_cap1_features_array),\n\t\t\t       phy_eee_cap1_features);\n\n}\n\nvoid phy_device_free(struct phy_device *phydev)\n{\n\tput_device(&phydev->mdio.dev);\n}\nEXPORT_SYMBOL(phy_device_free);\n\nstatic void phy_mdio_device_free(struct mdio_device *mdiodev)\n{\n\tstruct phy_device *phydev;\n\n\tphydev = container_of(mdiodev, struct phy_device, mdio);\n\tphy_device_free(phydev);\n}\n\nstatic void phy_device_release(struct device *dev)\n{\n\tfwnode_handle_put(dev->fwnode);\n\tkfree(to_phy_device(dev));\n}\n\nstatic void phy_mdio_device_remove(struct mdio_device *mdiodev)\n{\n\tstruct phy_device *phydev;\n\n\tphydev = container_of(mdiodev, struct phy_device, mdio);\n\tphy_device_remove(phydev);\n}\n\nstatic struct phy_driver genphy_driver;\n\nstatic LIST_HEAD(phy_fixup_list);\nstatic DEFINE_MUTEX(phy_fixup_lock);\n\nstatic bool mdio_bus_phy_may_suspend(struct phy_device *phydev)\n{\n\tstruct device_driver *drv = phydev->mdio.dev.driver;\n\tstruct phy_driver *phydrv = to_phy_driver(drv);\n\tstruct net_device *netdev = phydev->attached_dev;\n\n\tif (!drv || !phydrv->suspend)\n\t\treturn false;\n\n\t \n\tif (!netdev)\n\t\tgoto out;\n\n\tif (netdev->wol_enabled)\n\t\treturn false;\n\n\t \n\tif (netdev->dev.parent && device_may_wakeup(netdev->dev.parent))\n\t\treturn false;\n\n\t \n\tif (device_may_wakeup(&netdev->dev))\n\t\treturn false;\n\nout:\n\treturn !phydev->suspended;\n}\n\nstatic __maybe_unused int mdio_bus_phy_suspend(struct device *dev)\n{\n\tstruct phy_device *phydev = to_phy_device(dev);\n\n\tif (phydev->mac_managed_pm)\n\t\treturn 0;\n\n\t \n\tif (phy_interrupt_is_valid(phydev)) {\n\t\tphydev->irq_suspended = 1;\n\t\tsynchronize_irq(phydev->irq);\n\t}\n\n\t \n\tif (phydev->attached_dev && phydev->adjust_link)\n\t\tphy_stop_machine(phydev);\n\n\tif (!mdio_bus_phy_may_suspend(phydev))\n\t\treturn 0;\n\n\tphydev->suspended_by_mdio_bus = 1;\n\n\treturn phy_suspend(phydev);\n}\n\nstatic __maybe_unused int mdio_bus_phy_resume(struct device *dev)\n{\n\tstruct phy_device *phydev = to_phy_device(dev);\n\tint ret;\n\n\tif (phydev->mac_managed_pm)\n\t\treturn 0;\n\n\tif (!phydev->suspended_by_mdio_bus)\n\t\tgoto no_resume;\n\n\tphydev->suspended_by_mdio_bus = 0;\n\n\t \n\tWARN_ON(phydev->state != PHY_HALTED && phydev->state != PHY_READY &&\n\t\tphydev->state != PHY_UP);\n\n\tret = phy_init_hw(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = phy_resume(phydev);\n\tif (ret < 0)\n\t\treturn ret;\nno_resume:\n\tif (phy_interrupt_is_valid(phydev)) {\n\t\tphydev->irq_suspended = 0;\n\t\tsynchronize_irq(phydev->irq);\n\n\t\t \n\t\tif (phydev->irq_rerun) {\n\t\t\tphydev->irq_rerun = 0;\n\t\t\tenable_irq(phydev->irq);\n\t\t\tirq_wake_thread(phydev->irq, phydev);\n\t\t}\n\t}\n\n\tif (phydev->attached_dev && phydev->adjust_link)\n\t\tphy_start_machine(phydev);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(mdio_bus_phy_pm_ops, mdio_bus_phy_suspend,\n\t\t\t mdio_bus_phy_resume);\n\n \nint phy_register_fixup(const char *bus_id, u32 phy_uid, u32 phy_uid_mask,\n\t\t       int (*run)(struct phy_device *))\n{\n\tstruct phy_fixup *fixup = kzalloc(sizeof(*fixup), GFP_KERNEL);\n\n\tif (!fixup)\n\t\treturn -ENOMEM;\n\n\tstrscpy(fixup->bus_id, bus_id, sizeof(fixup->bus_id));\n\tfixup->phy_uid = phy_uid;\n\tfixup->phy_uid_mask = phy_uid_mask;\n\tfixup->run = run;\n\n\tmutex_lock(&phy_fixup_lock);\n\tlist_add_tail(&fixup->list, &phy_fixup_list);\n\tmutex_unlock(&phy_fixup_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(phy_register_fixup);\n\n \nint phy_register_fixup_for_uid(u32 phy_uid, u32 phy_uid_mask,\n\t\t\t       int (*run)(struct phy_device *))\n{\n\treturn phy_register_fixup(PHY_ANY_ID, phy_uid, phy_uid_mask, run);\n}\nEXPORT_SYMBOL(phy_register_fixup_for_uid);\n\n \nint phy_register_fixup_for_id(const char *bus_id,\n\t\t\t      int (*run)(struct phy_device *))\n{\n\treturn phy_register_fixup(bus_id, PHY_ANY_UID, 0xffffffff, run);\n}\nEXPORT_SYMBOL(phy_register_fixup_for_id);\n\n \nint phy_unregister_fixup(const char *bus_id, u32 phy_uid, u32 phy_uid_mask)\n{\n\tstruct list_head *pos, *n;\n\tstruct phy_fixup *fixup;\n\tint ret;\n\n\tret = -ENODEV;\n\n\tmutex_lock(&phy_fixup_lock);\n\tlist_for_each_safe(pos, n, &phy_fixup_list) {\n\t\tfixup = list_entry(pos, struct phy_fixup, list);\n\n\t\tif ((!strcmp(fixup->bus_id, bus_id)) &&\n\t\t    phy_id_compare(fixup->phy_uid, phy_uid, phy_uid_mask)) {\n\t\t\tlist_del(&fixup->list);\n\t\t\tkfree(fixup);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&phy_fixup_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(phy_unregister_fixup);\n\n \nint phy_unregister_fixup_for_uid(u32 phy_uid, u32 phy_uid_mask)\n{\n\treturn phy_unregister_fixup(PHY_ANY_ID, phy_uid, phy_uid_mask);\n}\nEXPORT_SYMBOL(phy_unregister_fixup_for_uid);\n\n \nint phy_unregister_fixup_for_id(const char *bus_id)\n{\n\treturn phy_unregister_fixup(bus_id, PHY_ANY_UID, 0xffffffff);\n}\nEXPORT_SYMBOL(phy_unregister_fixup_for_id);\n\n \nstatic int phy_needs_fixup(struct phy_device *phydev, struct phy_fixup *fixup)\n{\n\tif (strcmp(fixup->bus_id, phydev_name(phydev)) != 0)\n\t\tif (strcmp(fixup->bus_id, PHY_ANY_ID) != 0)\n\t\t\treturn 0;\n\n\tif (!phy_id_compare(phydev->phy_id, fixup->phy_uid,\n\t\t\t    fixup->phy_uid_mask))\n\t\tif (fixup->phy_uid != PHY_ANY_UID)\n\t\t\treturn 0;\n\n\treturn 1;\n}\n\n \nstatic int phy_scan_fixups(struct phy_device *phydev)\n{\n\tstruct phy_fixup *fixup;\n\n\tmutex_lock(&phy_fixup_lock);\n\tlist_for_each_entry(fixup, &phy_fixup_list, list) {\n\t\tif (phy_needs_fixup(phydev, fixup)) {\n\t\t\tint err = fixup->run(phydev);\n\n\t\t\tif (err < 0) {\n\t\t\t\tmutex_unlock(&phy_fixup_lock);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tphydev->has_fixups = true;\n\t\t}\n\t}\n\tmutex_unlock(&phy_fixup_lock);\n\n\treturn 0;\n}\n\nstatic int phy_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct phy_device *phydev = to_phy_device(dev);\n\tstruct phy_driver *phydrv = to_phy_driver(drv);\n\tconst int num_ids = ARRAY_SIZE(phydev->c45_ids.device_ids);\n\tint i;\n\n\tif (!(phydrv->mdiodrv.flags & MDIO_DEVICE_IS_PHY))\n\t\treturn 0;\n\n\tif (phydrv->match_phy_device)\n\t\treturn phydrv->match_phy_device(phydev);\n\n\tif (phydev->is_c45) {\n\t\tfor (i = 1; i < num_ids; i++) {\n\t\t\tif (phydev->c45_ids.device_ids[i] == 0xffffffff)\n\t\t\t\tcontinue;\n\n\t\t\tif (phy_id_compare(phydev->c45_ids.device_ids[i],\n\t\t\t\t\t   phydrv->phy_id, phydrv->phy_id_mask))\n\t\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t} else {\n\t\treturn phy_id_compare(phydev->phy_id, phydrv->phy_id,\n\t\t\t\t      phydrv->phy_id_mask);\n\t}\n}\n\nstatic ssize_t\nphy_id_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct phy_device *phydev = to_phy_device(dev);\n\n\treturn sysfs_emit(buf, \"0x%.8lx\\n\", (unsigned long)phydev->phy_id);\n}\nstatic DEVICE_ATTR_RO(phy_id);\n\nstatic ssize_t\nphy_interface_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct phy_device *phydev = to_phy_device(dev);\n\tconst char *mode = NULL;\n\n\tif (phy_is_internal(phydev))\n\t\tmode = \"internal\";\n\telse\n\t\tmode = phy_modes(phydev->interface);\n\n\treturn sysfs_emit(buf, \"%s\\n\", mode);\n}\nstatic DEVICE_ATTR_RO(phy_interface);\n\nstatic ssize_t\nphy_has_fixups_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct phy_device *phydev = to_phy_device(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", phydev->has_fixups);\n}\nstatic DEVICE_ATTR_RO(phy_has_fixups);\n\nstatic ssize_t phy_dev_flags_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tstruct phy_device *phydev = to_phy_device(dev);\n\n\treturn sysfs_emit(buf, \"0x%08x\\n\", phydev->dev_flags);\n}\nstatic DEVICE_ATTR_RO(phy_dev_flags);\n\nstatic struct attribute *phy_dev_attrs[] = {\n\t&dev_attr_phy_id.attr,\n\t&dev_attr_phy_interface.attr,\n\t&dev_attr_phy_has_fixups.attr,\n\t&dev_attr_phy_dev_flags.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(phy_dev);\n\nstatic const struct device_type mdio_bus_phy_type = {\n\t.name = \"PHY\",\n\t.groups = phy_dev_groups,\n\t.release = phy_device_release,\n\t.pm = pm_ptr(&mdio_bus_phy_pm_ops),\n};\n\nstatic int phy_request_driver_module(struct phy_device *dev, u32 phy_id)\n{\n\tint ret;\n\n\tret = request_module(MDIO_MODULE_PREFIX MDIO_ID_FMT,\n\t\t\t     MDIO_ID_ARGS(phy_id));\n\t \n\tif (IS_ENABLED(CONFIG_MODULES) && ret < 0 && ret != -ENOENT) {\n\t\tphydev_err(dev, \"error %d loading PHY driver module for ID 0x%08lx\\n\",\n\t\t\t   ret, (unsigned long)phy_id);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstruct phy_device *phy_device_create(struct mii_bus *bus, int addr, u32 phy_id,\n\t\t\t\t     bool is_c45,\n\t\t\t\t     struct phy_c45_device_ids *c45_ids)\n{\n\tstruct phy_device *dev;\n\tstruct mdio_device *mdiodev;\n\tint ret = 0;\n\n\t \n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmdiodev = &dev->mdio;\n\tmdiodev->dev.parent = &bus->dev;\n\tmdiodev->dev.bus = &mdio_bus_type;\n\tmdiodev->dev.type = &mdio_bus_phy_type;\n\tmdiodev->bus = bus;\n\tmdiodev->bus_match = phy_bus_match;\n\tmdiodev->addr = addr;\n\tmdiodev->flags = MDIO_DEVICE_FLAG_PHY;\n\tmdiodev->device_free = phy_mdio_device_free;\n\tmdiodev->device_remove = phy_mdio_device_remove;\n\n\tdev->speed = SPEED_UNKNOWN;\n\tdev->duplex = DUPLEX_UNKNOWN;\n\tdev->pause = 0;\n\tdev->asym_pause = 0;\n\tdev->link = 0;\n\tdev->port = PORT_TP;\n\tdev->interface = PHY_INTERFACE_MODE_GMII;\n\n\tdev->autoneg = AUTONEG_ENABLE;\n\n\tdev->pma_extable = -ENODATA;\n\tdev->is_c45 = is_c45;\n\tdev->phy_id = phy_id;\n\tif (c45_ids)\n\t\tdev->c45_ids = *c45_ids;\n\tdev->irq = bus->irq[addr];\n\n\tdev_set_name(&mdiodev->dev, PHY_ID_FMT, bus->id, addr);\n\tdevice_initialize(&mdiodev->dev);\n\n\tdev->state = PHY_DOWN;\n\tINIT_LIST_HEAD(&dev->leds);\n\n\tmutex_init(&dev->lock);\n\tINIT_DELAYED_WORK(&dev->state_queue, phy_state_machine);\n\n\t \n\tif (is_c45 && c45_ids) {\n\t\tconst int num_ids = ARRAY_SIZE(c45_ids->device_ids);\n\t\tint i;\n\n\t\tfor (i = 1; i < num_ids; i++) {\n\t\t\tif (c45_ids->device_ids[i] == 0xffffffff)\n\t\t\t\tcontinue;\n\n\t\t\tret = phy_request_driver_module(dev,\n\t\t\t\t\t\tc45_ids->device_ids[i]);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tret = phy_request_driver_module(dev, phy_id);\n\t}\n\n\tif (ret) {\n\t\tput_device(&mdiodev->dev);\n\t\tdev = ERR_PTR(ret);\n\t}\n\n\treturn dev;\n}\nEXPORT_SYMBOL(phy_device_create);\n\n \nstatic int phy_c45_probe_present(struct mii_bus *bus, int prtad, int devad)\n{\n\tint stat2;\n\n\tstat2 = mdiobus_c45_read(bus, prtad, devad, MDIO_STAT2);\n\tif (stat2 < 0)\n\t\treturn stat2;\n\n\treturn (stat2 & MDIO_STAT2_DEVPRST) == MDIO_STAT2_DEVPRST_VAL;\n}\n\n \nstatic int get_phy_c45_devs_in_pkg(struct mii_bus *bus, int addr, int dev_addr,\n\t\t\t\t   u32 *devices_in_package)\n{\n\tint phy_reg;\n\n\tphy_reg = mdiobus_c45_read(bus, addr, dev_addr, MDIO_DEVS2);\n\tif (phy_reg < 0)\n\t\treturn -EIO;\n\t*devices_in_package = phy_reg << 16;\n\n\tphy_reg = mdiobus_c45_read(bus, addr, dev_addr, MDIO_DEVS1);\n\tif (phy_reg < 0)\n\t\treturn -EIO;\n\t*devices_in_package |= phy_reg;\n\n\treturn 0;\n}\n\n \nstatic int get_phy_c45_ids(struct mii_bus *bus, int addr,\n\t\t\t   struct phy_c45_device_ids *c45_ids)\n{\n\tconst int num_ids = ARRAY_SIZE(c45_ids->device_ids);\n\tu32 devs_in_pkg = 0;\n\tint i, ret, phy_reg;\n\n\t \n\tfor (i = 1; i < MDIO_MMD_NUM && (devs_in_pkg == 0 ||\n\t     (devs_in_pkg & 0x1fffffff) == 0x1fffffff); i++) {\n\t\tif (i == MDIO_MMD_VEND1 || i == MDIO_MMD_VEND2) {\n\t\t\t \n\t\t\tret = phy_c45_probe_present(bus, addr, i);\n\t\t\tif (ret < 0)\n\t\t\t\treturn -EIO;\n\n\t\t\tif (!ret)\n\t\t\t\tcontinue;\n\t\t}\n\t\tphy_reg = get_phy_c45_devs_in_pkg(bus, addr, i, &devs_in_pkg);\n\t\tif (phy_reg < 0)\n\t\t\treturn -EIO;\n\t}\n\n\tif ((devs_in_pkg & 0x1fffffff) == 0x1fffffff) {\n\t\t \n\t\tphy_reg = get_phy_c45_devs_in_pkg(bus, addr, 0, &devs_in_pkg);\n\t\tif (phy_reg < 0)\n\t\t\treturn -EIO;\n\n\t\t \n\t\tif ((devs_in_pkg & 0x1fffffff) == 0x1fffffff)\n\t\t\treturn -ENODEV;\n\t}\n\n\t \n\tfor (i = 1; i < num_ids; i++) {\n\t\tif (!(devs_in_pkg & (1 << i)))\n\t\t\tcontinue;\n\n\t\tif (i == MDIO_MMD_VEND1 || i == MDIO_MMD_VEND2) {\n\t\t\t \n\t\t\tret = phy_c45_probe_present(bus, addr, i);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tif (!ret)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tphy_reg = mdiobus_c45_read(bus, addr, i, MII_PHYSID1);\n\t\tif (phy_reg < 0)\n\t\t\treturn -EIO;\n\t\tc45_ids->device_ids[i] = phy_reg << 16;\n\n\t\tphy_reg = mdiobus_c45_read(bus, addr, i, MII_PHYSID2);\n\t\tif (phy_reg < 0)\n\t\t\treturn -EIO;\n\t\tc45_ids->device_ids[i] |= phy_reg;\n\t}\n\n\tc45_ids->devices_in_package = devs_in_pkg;\n\t \n\tc45_ids->mmds_present = devs_in_pkg & ~BIT(0);\n\n\treturn 0;\n}\n\n \nstatic int get_phy_c22_id(struct mii_bus *bus, int addr, u32 *phy_id)\n{\n\tint phy_reg;\n\n\t \n\tphy_reg = mdiobus_read(bus, addr, MII_PHYSID1);\n\tif (phy_reg < 0) {\n\t\t \n\t\treturn (phy_reg == -EIO || phy_reg == -ENODEV) ? -ENODEV : -EIO;\n\t}\n\n\t*phy_id = phy_reg << 16;\n\n\t \n\tphy_reg = mdiobus_read(bus, addr, MII_PHYSID2);\n\tif (phy_reg < 0) {\n\t\t \n\t\treturn (phy_reg == -EIO || phy_reg == -ENODEV) ? -ENODEV : -EIO;\n\t}\n\n\t*phy_id |= phy_reg;\n\n\t \n\tif ((*phy_id & 0x1fffffff) == 0x1fffffff)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\n \nint fwnode_get_phy_id(struct fwnode_handle *fwnode, u32 *phy_id)\n{\n\tunsigned int upper, lower;\n\tconst char *cp;\n\tint ret;\n\n\tret = fwnode_property_read_string(fwnode, \"compatible\", &cp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sscanf(cp, \"ethernet-phy-id%4x.%4x\", &upper, &lower) != 2)\n\t\treturn -EINVAL;\n\n\t*phy_id = ((upper & GENMASK(15, 0)) << 16) | (lower & GENMASK(15, 0));\n\treturn 0;\n}\nEXPORT_SYMBOL(fwnode_get_phy_id);\n\n \nstruct phy_device *get_phy_device(struct mii_bus *bus, int addr, bool is_c45)\n{\n\tstruct phy_c45_device_ids c45_ids;\n\tu32 phy_id = 0;\n\tint r;\n\n\tc45_ids.devices_in_package = 0;\n\tc45_ids.mmds_present = 0;\n\tmemset(c45_ids.device_ids, 0xff, sizeof(c45_ids.device_ids));\n\n\tif (is_c45)\n\t\tr = get_phy_c45_ids(bus, addr, &c45_ids);\n\telse\n\t\tr = get_phy_c22_id(bus, addr, &phy_id);\n\n\tif (r)\n\t\treturn ERR_PTR(r);\n\n\t \n\tif (!is_c45 && phy_id == 0 && bus->read_c45) {\n\t\tr = get_phy_c45_ids(bus, addr, &c45_ids);\n\t\tif (!r)\n\t\t\treturn phy_device_create(bus, addr, phy_id,\n\t\t\t\t\t\t true, &c45_ids);\n\t}\n\n\treturn phy_device_create(bus, addr, phy_id, is_c45, &c45_ids);\n}\nEXPORT_SYMBOL(get_phy_device);\n\n \nint phy_device_register(struct phy_device *phydev)\n{\n\tint err;\n\n\terr = mdiobus_register_device(&phydev->mdio);\n\tif (err)\n\t\treturn err;\n\n\t \n\tphy_device_reset(phydev, 0);\n\n\t \n\terr = phy_scan_fixups(phydev);\n\tif (err) {\n\t\tphydev_err(phydev, \"failed to initialize\\n\");\n\t\tgoto out;\n\t}\n\n\terr = device_add(&phydev->mdio.dev);\n\tif (err) {\n\t\tphydev_err(phydev, \"failed to add\\n\");\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\n out:\n\t \n\tphy_device_reset(phydev, 1);\n\n\tmdiobus_unregister_device(&phydev->mdio);\n\treturn err;\n}\nEXPORT_SYMBOL(phy_device_register);\n\n \nvoid phy_device_remove(struct phy_device *phydev)\n{\n\tunregister_mii_timestamper(phydev->mii_ts);\n\tpse_control_put(phydev->psec);\n\n\tdevice_del(&phydev->mdio.dev);\n\n\t \n\tphy_device_reset(phydev, 1);\n\n\tmdiobus_unregister_device(&phydev->mdio);\n}\nEXPORT_SYMBOL(phy_device_remove);\n\n \nint phy_get_c45_ids(struct phy_device *phydev)\n{\n\treturn get_phy_c45_ids(phydev->mdio.bus, phydev->mdio.addr,\n\t\t\t       &phydev->c45_ids);\n}\nEXPORT_SYMBOL(phy_get_c45_ids);\n\n \nstruct phy_device *phy_find_first(struct mii_bus *bus)\n{\n\tstruct phy_device *phydev;\n\tint addr;\n\n\tfor (addr = 0; addr < PHY_MAX_ADDR; addr++) {\n\t\tphydev = mdiobus_get_phy(bus, addr);\n\t\tif (phydev)\n\t\t\treturn phydev;\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL(phy_find_first);\n\nstatic void phy_link_change(struct phy_device *phydev, bool up)\n{\n\tstruct net_device *netdev = phydev->attached_dev;\n\n\tif (up)\n\t\tnetif_carrier_on(netdev);\n\telse\n\t\tnetif_carrier_off(netdev);\n\tphydev->adjust_link(netdev);\n\tif (phydev->mii_ts && phydev->mii_ts->link_state)\n\t\tphydev->mii_ts->link_state(phydev->mii_ts, phydev);\n}\n\n \nstatic void phy_prepare_link(struct phy_device *phydev,\n\t\t\t     void (*handler)(struct net_device *))\n{\n\tphydev->adjust_link = handler;\n}\n\n \nint phy_connect_direct(struct net_device *dev, struct phy_device *phydev,\n\t\t       void (*handler)(struct net_device *),\n\t\t       phy_interface_t interface)\n{\n\tint rc;\n\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\trc = phy_attach_direct(dev, phydev, phydev->dev_flags, interface);\n\tif (rc)\n\t\treturn rc;\n\n\tphy_prepare_link(phydev, handler);\n\tif (phy_interrupt_is_valid(phydev))\n\t\tphy_request_interrupt(phydev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(phy_connect_direct);\n\n \nstruct phy_device *phy_connect(struct net_device *dev, const char *bus_id,\n\t\t\t       void (*handler)(struct net_device *),\n\t\t\t       phy_interface_t interface)\n{\n\tstruct phy_device *phydev;\n\tstruct device *d;\n\tint rc;\n\n\t \n\td = bus_find_device_by_name(&mdio_bus_type, NULL, bus_id);\n\tif (!d) {\n\t\tpr_err(\"PHY %s not found\\n\", bus_id);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\tphydev = to_phy_device(d);\n\n\trc = phy_connect_direct(dev, phydev, handler, interface);\n\tput_device(d);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\n\treturn phydev;\n}\nEXPORT_SYMBOL(phy_connect);\n\n \nvoid phy_disconnect(struct phy_device *phydev)\n{\n\tif (phy_is_started(phydev))\n\t\tphy_stop(phydev);\n\n\tif (phy_interrupt_is_valid(phydev))\n\t\tphy_free_interrupt(phydev);\n\n\tphydev->adjust_link = NULL;\n\n\tphy_detach(phydev);\n}\nEXPORT_SYMBOL(phy_disconnect);\n\n \nstatic int phy_poll_reset(struct phy_device *phydev)\n{\n\t \n\tint ret, val;\n\n\tret = phy_read_poll_timeout(phydev, MII_BMCR, val, !(val & BMCR_RESET),\n\t\t\t\t    50000, 600000, true);\n\tif (ret)\n\t\treturn ret;\n\t \n\tmsleep(1);\n\treturn 0;\n}\n\nint phy_init_hw(struct phy_device *phydev)\n{\n\tint ret = 0;\n\n\t \n\tphy_device_reset(phydev, 0);\n\n\tif (!phydev->drv)\n\t\treturn 0;\n\n\tif (phydev->drv->soft_reset) {\n\t\tret = phydev->drv->soft_reset(phydev);\n\t\t \n\t\tif (!ret)\n\t\t\tphydev->suspended = 0;\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = phy_scan_fixups(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (phydev->drv->config_init) {\n\t\tret = phydev->drv->config_init(phydev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (phydev->drv->config_intr) {\n\t\tret = phydev->drv->config_intr(phydev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(phy_init_hw);\n\nvoid phy_attached_info(struct phy_device *phydev)\n{\n\tphy_attached_print(phydev, NULL);\n}\nEXPORT_SYMBOL(phy_attached_info);\n\n#define ATTACHED_FMT \"attached PHY driver %s(mii_bus:phy_addr=%s, irq=%s)\"\nchar *phy_attached_info_irq(struct phy_device *phydev)\n{\n\tchar *irq_str;\n\tchar irq_num[8];\n\n\tswitch(phydev->irq) {\n\tcase PHY_POLL:\n\t\tirq_str = \"POLL\";\n\t\tbreak;\n\tcase PHY_MAC_INTERRUPT:\n\t\tirq_str = \"MAC\";\n\t\tbreak;\n\tdefault:\n\t\tsnprintf(irq_num, sizeof(irq_num), \"%d\", phydev->irq);\n\t\tirq_str = irq_num;\n\t\tbreak;\n\t}\n\n\treturn kasprintf(GFP_KERNEL, \"%s\", irq_str);\n}\nEXPORT_SYMBOL(phy_attached_info_irq);\n\nvoid phy_attached_print(struct phy_device *phydev, const char *fmt, ...)\n{\n\tconst char *unbound = phydev->drv ? \"\" : \"[unbound] \";\n\tchar *irq_str = phy_attached_info_irq(phydev);\n\n\tif (!fmt) {\n\t\tphydev_info(phydev, ATTACHED_FMT \"\\n\", unbound,\n\t\t\t    phydev_name(phydev), irq_str);\n\t} else {\n\t\tva_list ap;\n\n\t\tphydev_info(phydev, ATTACHED_FMT, unbound,\n\t\t\t    phydev_name(phydev), irq_str);\n\n\t\tva_start(ap, fmt);\n\t\tvprintk(fmt, ap);\n\t\tva_end(ap);\n\t}\n\tkfree(irq_str);\n}\nEXPORT_SYMBOL(phy_attached_print);\n\nstatic void phy_sysfs_create_links(struct phy_device *phydev)\n{\n\tstruct net_device *dev = phydev->attached_dev;\n\tint err;\n\n\tif (!dev)\n\t\treturn;\n\n\terr = sysfs_create_link(&phydev->mdio.dev.kobj, &dev->dev.kobj,\n\t\t\t\t\"attached_dev\");\n\tif (err)\n\t\treturn;\n\n\terr = sysfs_create_link_nowarn(&dev->dev.kobj,\n\t\t\t\t       &phydev->mdio.dev.kobj,\n\t\t\t\t       \"phydev\");\n\tif (err) {\n\t\tdev_err(&dev->dev, \"could not add device link to %s err %d\\n\",\n\t\t\tkobject_name(&phydev->mdio.dev.kobj),\n\t\t\terr);\n\t\t \n\t}\n\n\tphydev->sysfs_links = true;\n}\n\nstatic ssize_t\nphy_standalone_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct phy_device *phydev = to_phy_device(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", !phydev->attached_dev);\n}\nstatic DEVICE_ATTR_RO(phy_standalone);\n\n \nvoid phy_sfp_attach(void *upstream, struct sfp_bus *bus)\n{\n\tstruct phy_device *phydev = upstream;\n\n\tif (phydev->attached_dev)\n\t\tphydev->attached_dev->sfp_bus = bus;\n\tphydev->sfp_bus_attached = true;\n}\nEXPORT_SYMBOL(phy_sfp_attach);\n\n \nvoid phy_sfp_detach(void *upstream, struct sfp_bus *bus)\n{\n\tstruct phy_device *phydev = upstream;\n\n\tif (phydev->attached_dev)\n\t\tphydev->attached_dev->sfp_bus = NULL;\n\tphydev->sfp_bus_attached = false;\n}\nEXPORT_SYMBOL(phy_sfp_detach);\n\n \nint phy_sfp_probe(struct phy_device *phydev,\n\t\t  const struct sfp_upstream_ops *ops)\n{\n\tstruct sfp_bus *bus;\n\tint ret = 0;\n\n\tif (phydev->mdio.dev.fwnode) {\n\t\tbus = sfp_bus_find_fwnode(phydev->mdio.dev.fwnode);\n\t\tif (IS_ERR(bus))\n\t\t\treturn PTR_ERR(bus);\n\n\t\tphydev->sfp_bus = bus;\n\n\t\tret = sfp_bus_add_upstream(bus, phydev, ops);\n\t\tsfp_bus_put(bus);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(phy_sfp_probe);\n\n \nint phy_attach_direct(struct net_device *dev, struct phy_device *phydev,\n\t\t      u32 flags, phy_interface_t interface)\n{\n\tstruct mii_bus *bus = phydev->mdio.bus;\n\tstruct device *d = &phydev->mdio.dev;\n\tstruct module *ndev_owner = NULL;\n\tbool using_genphy = false;\n\tint err;\n\n\t \n\tif (dev)\n\t\tndev_owner = dev->dev.parent->driver->owner;\n\tif (ndev_owner != bus->owner && !try_module_get(bus->owner)) {\n\t\tphydev_err(phydev, \"failed to get the bus module\\n\");\n\t\treturn -EIO;\n\t}\n\n\tget_device(d);\n\n\t \n\tif (!d->driver) {\n\t\tif (phydev->is_c45)\n\t\t\td->driver = &genphy_c45_driver.mdiodrv.driver;\n\t\telse\n\t\t\td->driver = &genphy_driver.mdiodrv.driver;\n\n\t\tusing_genphy = true;\n\t}\n\n\tif (!try_module_get(d->driver->owner)) {\n\t\tphydev_err(phydev, \"failed to get the device driver module\\n\");\n\t\terr = -EIO;\n\t\tgoto error_put_device;\n\t}\n\n\tif (using_genphy) {\n\t\terr = d->driver->probe(d);\n\t\tif (err >= 0)\n\t\t\terr = device_bind_driver(d);\n\n\t\tif (err)\n\t\t\tgoto error_module_put;\n\t}\n\n\tif (phydev->attached_dev) {\n\t\tdev_err(&dev->dev, \"PHY already attached\\n\");\n\t\terr = -EBUSY;\n\t\tgoto error;\n\t}\n\n\tphydev->phy_link_change = phy_link_change;\n\tif (dev) {\n\t\tphydev->attached_dev = dev;\n\t\tdev->phydev = phydev;\n\n\t\tif (phydev->sfp_bus_attached)\n\t\t\tdev->sfp_bus = phydev->sfp_bus;\n\t}\n\n\t \n\tphydev->sysfs_links = false;\n\n\tphy_sysfs_create_links(phydev);\n\n\tif (!phydev->attached_dev) {\n\t\terr = sysfs_create_file(&phydev->mdio.dev.kobj,\n\t\t\t\t\t&dev_attr_phy_standalone.attr);\n\t\tif (err)\n\t\t\tphydev_err(phydev, \"error creating 'phy_standalone' sysfs entry\\n\");\n\t}\n\n\tphydev->dev_flags |= flags;\n\n\tphydev->interface = interface;\n\n\tphydev->state = PHY_READY;\n\n\tphydev->interrupts = PHY_INTERRUPT_DISABLED;\n\n\t \n\tif (phydev->dev_flags & PHY_F_NO_IRQ)\n\t\tphydev->irq = PHY_POLL;\n\n\t \n\tif (using_genphy)\n\t\tphydev->port = PORT_MII;\n\n\t \n\tif (dev)\n\t\tnetif_carrier_off(phydev->attached_dev);\n\n\t \n\terr = phy_init_hw(phydev);\n\tif (err)\n\t\tgoto error;\n\n\tphy_resume(phydev);\n\tif (!phydev->is_on_sfp_module)\n\t\tphy_led_triggers_register(phydev);\n\n\t \n\tif (dev && phydev->mdio.bus->parent && dev->dev.parent != phydev->mdio.bus->parent)\n\t\tphydev->devlink = device_link_add(dev->dev.parent, &phydev->mdio.dev,\n\t\t\t\t\t\t  DL_FLAG_PM_RUNTIME | DL_FLAG_STATELESS);\n\n\treturn err;\n\nerror:\n\t \n\tphy_detach(phydev);\n\treturn err;\n\nerror_module_put:\n\tmodule_put(d->driver->owner);\n\td->driver = NULL;\nerror_put_device:\n\tput_device(d);\n\tif (ndev_owner != bus->owner)\n\t\tmodule_put(bus->owner);\n\treturn err;\n}\nEXPORT_SYMBOL(phy_attach_direct);\n\n \nstruct phy_device *phy_attach(struct net_device *dev, const char *bus_id,\n\t\t\t      phy_interface_t interface)\n{\n\tstruct bus_type *bus = &mdio_bus_type;\n\tstruct phy_device *phydev;\n\tstruct device *d;\n\tint rc;\n\n\tif (!dev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\td = bus_find_device_by_name(bus, NULL, bus_id);\n\tif (!d) {\n\t\tpr_err(\"PHY %s not found\\n\", bus_id);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\tphydev = to_phy_device(d);\n\n\trc = phy_attach_direct(dev, phydev, phydev->dev_flags, interface);\n\tput_device(d);\n\tif (rc)\n\t\treturn ERR_PTR(rc);\n\n\treturn phydev;\n}\nEXPORT_SYMBOL(phy_attach);\n\nstatic bool phy_driver_is_genphy_kind(struct phy_device *phydev,\n\t\t\t\t      struct device_driver *driver)\n{\n\tstruct device *d = &phydev->mdio.dev;\n\tbool ret = false;\n\n\tif (!phydev->drv)\n\t\treturn ret;\n\n\tget_device(d);\n\tret = d->driver == driver;\n\tput_device(d);\n\n\treturn ret;\n}\n\nbool phy_driver_is_genphy(struct phy_device *phydev)\n{\n\treturn phy_driver_is_genphy_kind(phydev,\n\t\t\t\t\t &genphy_driver.mdiodrv.driver);\n}\nEXPORT_SYMBOL_GPL(phy_driver_is_genphy);\n\nbool phy_driver_is_genphy_10g(struct phy_device *phydev)\n{\n\treturn phy_driver_is_genphy_kind(phydev,\n\t\t\t\t\t &genphy_c45_driver.mdiodrv.driver);\n}\nEXPORT_SYMBOL_GPL(phy_driver_is_genphy_10g);\n\n \nint phy_package_join(struct phy_device *phydev, int addr, size_t priv_size)\n{\n\tstruct mii_bus *bus = phydev->mdio.bus;\n\tstruct phy_package_shared *shared;\n\tint ret;\n\n\tif (addr < 0 || addr >= PHY_MAX_ADDR)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&bus->shared_lock);\n\tshared = bus->shared[addr];\n\tif (!shared) {\n\t\tret = -ENOMEM;\n\t\tshared = kzalloc(sizeof(*shared), GFP_KERNEL);\n\t\tif (!shared)\n\t\t\tgoto err_unlock;\n\t\tif (priv_size) {\n\t\t\tshared->priv = kzalloc(priv_size, GFP_KERNEL);\n\t\t\tif (!shared->priv)\n\t\t\t\tgoto err_free;\n\t\t\tshared->priv_size = priv_size;\n\t\t}\n\t\tshared->addr = addr;\n\t\trefcount_set(&shared->refcnt, 1);\n\t\tbus->shared[addr] = shared;\n\t} else {\n\t\tret = -EINVAL;\n\t\tif (priv_size && priv_size != shared->priv_size)\n\t\t\tgoto err_unlock;\n\t\trefcount_inc(&shared->refcnt);\n\t}\n\tmutex_unlock(&bus->shared_lock);\n\n\tphydev->shared = shared;\n\n\treturn 0;\n\nerr_free:\n\tkfree(shared);\nerr_unlock:\n\tmutex_unlock(&bus->shared_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phy_package_join);\n\n \nvoid phy_package_leave(struct phy_device *phydev)\n{\n\tstruct phy_package_shared *shared = phydev->shared;\n\tstruct mii_bus *bus = phydev->mdio.bus;\n\n\tif (!shared)\n\t\treturn;\n\n\tif (refcount_dec_and_mutex_lock(&shared->refcnt, &bus->shared_lock)) {\n\t\tbus->shared[shared->addr] = NULL;\n\t\tmutex_unlock(&bus->shared_lock);\n\t\tkfree(shared->priv);\n\t\tkfree(shared);\n\t}\n\n\tphydev->shared = NULL;\n}\nEXPORT_SYMBOL_GPL(phy_package_leave);\n\nstatic void devm_phy_package_leave(struct device *dev, void *res)\n{\n\tphy_package_leave(*(struct phy_device **)res);\n}\n\n \nint devm_phy_package_join(struct device *dev, struct phy_device *phydev,\n\t\t\t  int addr, size_t priv_size)\n{\n\tstruct phy_device **ptr;\n\tint ret;\n\n\tptr = devres_alloc(devm_phy_package_leave, sizeof(*ptr),\n\t\t\t   GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\tret = phy_package_join(phydev, addr, priv_size);\n\n\tif (!ret) {\n\t\t*ptr = phydev;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(devm_phy_package_join);\n\n \nvoid phy_detach(struct phy_device *phydev)\n{\n\tstruct net_device *dev = phydev->attached_dev;\n\tstruct module *ndev_owner = NULL;\n\tstruct mii_bus *bus;\n\n\tif (phydev->devlink)\n\t\tdevice_link_del(phydev->devlink);\n\n\tif (phydev->sysfs_links) {\n\t\tif (dev)\n\t\t\tsysfs_remove_link(&dev->dev.kobj, \"phydev\");\n\t\tsysfs_remove_link(&phydev->mdio.dev.kobj, \"attached_dev\");\n\t}\n\n\tif (!phydev->attached_dev)\n\t\tsysfs_remove_file(&phydev->mdio.dev.kobj,\n\t\t\t\t  &dev_attr_phy_standalone.attr);\n\n\tphy_suspend(phydev);\n\tif (dev) {\n\t\tphydev->attached_dev->phydev = NULL;\n\t\tphydev->attached_dev = NULL;\n\t}\n\tphydev->phylink = NULL;\n\n\tif (!phydev->is_on_sfp_module)\n\t\tphy_led_triggers_unregister(phydev);\n\n\tif (phydev->mdio.dev.driver)\n\t\tmodule_put(phydev->mdio.dev.driver->owner);\n\n\t \n\tif (phy_driver_is_genphy(phydev) ||\n\t    phy_driver_is_genphy_10g(phydev))\n\t\tdevice_release_driver(&phydev->mdio.dev);\n\n\t \n\tphy_device_reset(phydev, 1);\n\n\t \n\tbus = phydev->mdio.bus;\n\n\tput_device(&phydev->mdio.dev);\n\tif (dev)\n\t\tndev_owner = dev->dev.parent->driver->owner;\n\tif (ndev_owner != bus->owner)\n\t\tmodule_put(bus->owner);\n}\nEXPORT_SYMBOL(phy_detach);\n\nint phy_suspend(struct phy_device *phydev)\n{\n\tstruct ethtool_wolinfo wol = { .cmd = ETHTOOL_GWOL };\n\tstruct net_device *netdev = phydev->attached_dev;\n\tstruct phy_driver *phydrv = phydev->drv;\n\tint ret;\n\n\tif (phydev->suspended)\n\t\treturn 0;\n\n\tphy_ethtool_get_wol(phydev, &wol);\n\tphydev->wol_enabled = wol.wolopts || (netdev && netdev->wol_enabled);\n\t \n\tif (phydev->wol_enabled && !(phydrv->flags & PHY_ALWAYS_CALL_SUSPEND))\n\t\treturn -EBUSY;\n\n\tif (!phydrv || !phydrv->suspend)\n\t\treturn 0;\n\n\tret = phydrv->suspend(phydev);\n\tif (!ret)\n\t\tphydev->suspended = true;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(phy_suspend);\n\nint __phy_resume(struct phy_device *phydev)\n{\n\tstruct phy_driver *phydrv = phydev->drv;\n\tint ret;\n\n\tlockdep_assert_held(&phydev->lock);\n\n\tif (!phydrv || !phydrv->resume)\n\t\treturn 0;\n\n\tret = phydrv->resume(phydev);\n\tif (!ret)\n\t\tphydev->suspended = false;\n\n\treturn ret;\n}\nEXPORT_SYMBOL(__phy_resume);\n\nint phy_resume(struct phy_device *phydev)\n{\n\tint ret;\n\n\tmutex_lock(&phydev->lock);\n\tret = __phy_resume(phydev);\n\tmutex_unlock(&phydev->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(phy_resume);\n\nint phy_loopback(struct phy_device *phydev, bool enable)\n{\n\tint ret = 0;\n\n\tif (!phydev->drv)\n\t\treturn -EIO;\n\n\tmutex_lock(&phydev->lock);\n\n\tif (enable && phydev->loopback_enabled) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (!enable && !phydev->loopback_enabled) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (phydev->drv->set_loopback)\n\t\tret = phydev->drv->set_loopback(phydev, enable);\n\telse\n\t\tret = genphy_loopback(phydev, enable);\n\n\tif (ret)\n\t\tgoto out;\n\n\tphydev->loopback_enabled = enable;\n\nout:\n\tmutex_unlock(&phydev->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(phy_loopback);\n\n \nint phy_reset_after_clk_enable(struct phy_device *phydev)\n{\n\tif (!phydev || !phydev->drv)\n\t\treturn -ENODEV;\n\n\tif (phydev->drv->flags & PHY_RST_AFTER_CLK_EN) {\n\t\tphy_device_reset(phydev, 1);\n\t\tphy_device_reset(phydev, 0);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(phy_reset_after_clk_enable);\n\n \n\n \nstatic int genphy_config_advert(struct phy_device *phydev)\n{\n\tint err, bmsr, changed = 0;\n\tu32 adv;\n\n\t \n\tlinkmode_and(phydev->advertising, phydev->advertising,\n\t\t     phydev->supported);\n\n\tadv = linkmode_adv_to_mii_adv_t(phydev->advertising);\n\n\t \n\terr = phy_modify_changed(phydev, MII_ADVERTISE,\n\t\t\t\t ADVERTISE_ALL | ADVERTISE_100BASE4 |\n\t\t\t\t ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM,\n\t\t\t\t adv);\n\tif (err < 0)\n\t\treturn err;\n\tif (err > 0)\n\t\tchanged = 1;\n\n\tbmsr = phy_read(phydev, MII_BMSR);\n\tif (bmsr < 0)\n\t\treturn bmsr;\n\n\t \n\tif (!(bmsr & BMSR_ESTATEN))\n\t\treturn changed;\n\n\tadv = linkmode_adv_to_mii_ctrl1000_t(phydev->advertising);\n\n\terr = phy_modify_changed(phydev, MII_CTRL1000,\n\t\t\t\t ADVERTISE_1000FULL | ADVERTISE_1000HALF,\n\t\t\t\t adv);\n\tif (err < 0)\n\t\treturn err;\n\tif (err > 0)\n\t\tchanged = 1;\n\n\treturn changed;\n}\n\n \nstatic int genphy_c37_config_advert(struct phy_device *phydev)\n{\n\tu16 adv = 0;\n\n\t \n\tlinkmode_and(phydev->advertising, phydev->advertising,\n\t\t     phydev->supported);\n\n\tif (linkmode_test_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT,\n\t\t\t      phydev->advertising))\n\t\tadv |= ADVERTISE_1000XFULL;\n\tif (linkmode_test_bit(ETHTOOL_LINK_MODE_Pause_BIT,\n\t\t\t      phydev->advertising))\n\t\tadv |= ADVERTISE_1000XPAUSE;\n\tif (linkmode_test_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,\n\t\t\t      phydev->advertising))\n\t\tadv |= ADVERTISE_1000XPSE_ASYM;\n\n\treturn phy_modify_changed(phydev, MII_ADVERTISE,\n\t\t\t\t  ADVERTISE_1000XFULL | ADVERTISE_1000XPAUSE |\n\t\t\t\t  ADVERTISE_1000XHALF | ADVERTISE_1000XPSE_ASYM,\n\t\t\t\t  adv);\n}\n\n \nint genphy_config_eee_advert(struct phy_device *phydev)\n{\n\tint err;\n\n\t \n\tif (!phydev->eee_broken_modes)\n\t\treturn 0;\n\n\terr = phy_modify_mmd_changed(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV,\n\t\t\t\t     phydev->eee_broken_modes, 0);\n\t \n\treturn err < 0 ? 0 : err;\n}\nEXPORT_SYMBOL(genphy_config_eee_advert);\n\n \nint genphy_setup_forced(struct phy_device *phydev)\n{\n\tu16 ctl;\n\n\tphydev->pause = 0;\n\tphydev->asym_pause = 0;\n\n\tctl = mii_bmcr_encode_fixed(phydev->speed, phydev->duplex);\n\n\treturn phy_modify(phydev, MII_BMCR,\n\t\t\t  ~(BMCR_LOOPBACK | BMCR_ISOLATE | BMCR_PDOWN), ctl);\n}\nEXPORT_SYMBOL(genphy_setup_forced);\n\nstatic int genphy_setup_master_slave(struct phy_device *phydev)\n{\n\tu16 ctl = 0;\n\n\tif (!phydev->is_gigabit_capable)\n\t\treturn 0;\n\n\tswitch (phydev->master_slave_set) {\n\tcase MASTER_SLAVE_CFG_MASTER_PREFERRED:\n\t\tctl |= CTL1000_PREFER_MASTER;\n\t\tbreak;\n\tcase MASTER_SLAVE_CFG_SLAVE_PREFERRED:\n\t\tbreak;\n\tcase MASTER_SLAVE_CFG_MASTER_FORCE:\n\t\tctl |= CTL1000_AS_MASTER;\n\t\tfallthrough;\n\tcase MASTER_SLAVE_CFG_SLAVE_FORCE:\n\t\tctl |= CTL1000_ENABLE_MASTER;\n\t\tbreak;\n\tcase MASTER_SLAVE_CFG_UNKNOWN:\n\tcase MASTER_SLAVE_CFG_UNSUPPORTED:\n\t\treturn 0;\n\tdefault:\n\t\tphydev_warn(phydev, \"Unsupported Master/Slave mode\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn phy_modify_changed(phydev, MII_CTRL1000,\n\t\t\t\t  (CTL1000_ENABLE_MASTER | CTL1000_AS_MASTER |\n\t\t\t\t   CTL1000_PREFER_MASTER), ctl);\n}\n\nint genphy_read_master_slave(struct phy_device *phydev)\n{\n\tint cfg, state;\n\tint val;\n\n\tphydev->master_slave_get = MASTER_SLAVE_CFG_UNKNOWN;\n\tphydev->master_slave_state = MASTER_SLAVE_STATE_UNKNOWN;\n\n\tval = phy_read(phydev, MII_CTRL1000);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (val & CTL1000_ENABLE_MASTER) {\n\t\tif (val & CTL1000_AS_MASTER)\n\t\t\tcfg = MASTER_SLAVE_CFG_MASTER_FORCE;\n\t\telse\n\t\t\tcfg = MASTER_SLAVE_CFG_SLAVE_FORCE;\n\t} else {\n\t\tif (val & CTL1000_PREFER_MASTER)\n\t\t\tcfg = MASTER_SLAVE_CFG_MASTER_PREFERRED;\n\t\telse\n\t\t\tcfg = MASTER_SLAVE_CFG_SLAVE_PREFERRED;\n\t}\n\n\tval = phy_read(phydev, MII_STAT1000);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (val & LPA_1000MSFAIL) {\n\t\tstate = MASTER_SLAVE_STATE_ERR;\n\t} else if (phydev->link) {\n\t\t \n\t\tif (val & LPA_1000MSRES)\n\t\t\tstate = MASTER_SLAVE_STATE_MASTER;\n\t\telse\n\t\t\tstate = MASTER_SLAVE_STATE_SLAVE;\n\t} else {\n\t\tstate = MASTER_SLAVE_STATE_UNKNOWN;\n\t}\n\n\tphydev->master_slave_get = cfg;\n\tphydev->master_slave_state = state;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(genphy_read_master_slave);\n\n \nint genphy_restart_aneg(struct phy_device *phydev)\n{\n\t \n\treturn phy_modify(phydev, MII_BMCR, BMCR_ISOLATE,\n\t\t\t  BMCR_ANENABLE | BMCR_ANRESTART);\n}\nEXPORT_SYMBOL(genphy_restart_aneg);\n\n \nint genphy_check_and_restart_aneg(struct phy_device *phydev, bool restart)\n{\n\tint ret;\n\n\tif (!restart) {\n\t\t \n\t\tret = phy_read(phydev, MII_BMCR);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (!(ret & BMCR_ANENABLE) || (ret & BMCR_ISOLATE))\n\t\t\trestart = true;\n\t}\n\n\tif (restart)\n\t\treturn genphy_restart_aneg(phydev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(genphy_check_and_restart_aneg);\n\n \nint __genphy_config_aneg(struct phy_device *phydev, bool changed)\n{\n\tint err;\n\n\terr = genphy_c45_an_config_eee_aneg(phydev);\n\tif (err < 0)\n\t\treturn err;\n\telse if (err)\n\t\tchanged = true;\n\n\terr = genphy_setup_master_slave(phydev);\n\tif (err < 0)\n\t\treturn err;\n\telse if (err)\n\t\tchanged = true;\n\n\tif (AUTONEG_ENABLE != phydev->autoneg)\n\t\treturn genphy_setup_forced(phydev);\n\n\terr = genphy_config_advert(phydev);\n\tif (err < 0)  \n\t\treturn err;\n\telse if (err)\n\t\tchanged = true;\n\n\treturn genphy_check_and_restart_aneg(phydev, changed);\n}\nEXPORT_SYMBOL(__genphy_config_aneg);\n\n \nint genphy_c37_config_aneg(struct phy_device *phydev)\n{\n\tint err, changed;\n\n\tif (phydev->autoneg != AUTONEG_ENABLE)\n\t\treturn genphy_setup_forced(phydev);\n\n\terr = phy_modify(phydev, MII_BMCR, BMCR_SPEED1000 | BMCR_SPEED100,\n\t\t\t BMCR_SPEED1000);\n\tif (err)\n\t\treturn err;\n\n\tchanged = genphy_c37_config_advert(phydev);\n\tif (changed < 0)  \n\t\treturn changed;\n\n\tif (!changed) {\n\t\t \n\t\tint ctl = phy_read(phydev, MII_BMCR);\n\n\t\tif (ctl < 0)\n\t\t\treturn ctl;\n\n\t\tif (!(ctl & BMCR_ANENABLE) || (ctl & BMCR_ISOLATE))\n\t\t\tchanged = 1;  \n\t}\n\n\t \n\tif (changed > 0)\n\t\treturn genphy_restart_aneg(phydev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(genphy_c37_config_aneg);\n\n \nint genphy_aneg_done(struct phy_device *phydev)\n{\n\tint retval = phy_read(phydev, MII_BMSR);\n\n\treturn (retval < 0) ? retval : (retval & BMSR_ANEGCOMPLETE);\n}\nEXPORT_SYMBOL(genphy_aneg_done);\n\n \nint genphy_update_link(struct phy_device *phydev)\n{\n\tint status = 0, bmcr;\n\n\tbmcr = phy_read(phydev, MII_BMCR);\n\tif (bmcr < 0)\n\t\treturn bmcr;\n\n\t \n\tif (bmcr & BMCR_ANRESTART)\n\t\tgoto done;\n\n\t \n\tif (!phy_polling_mode(phydev) || !phydev->link) {\n\t\tstatus = phy_read(phydev, MII_BMSR);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\telse if (status & BMSR_LSTATUS)\n\t\t\tgoto done;\n\t}\n\n\t \n\tstatus = phy_read(phydev, MII_BMSR);\n\tif (status < 0)\n\t\treturn status;\ndone:\n\tphydev->link = status & BMSR_LSTATUS ? 1 : 0;\n\tphydev->autoneg_complete = status & BMSR_ANEGCOMPLETE ? 1 : 0;\n\n\t \n\tif (phydev->autoneg == AUTONEG_ENABLE && !phydev->autoneg_complete)\n\t\tphydev->link = 0;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(genphy_update_link);\n\nint genphy_read_lpa(struct phy_device *phydev)\n{\n\tint lpa, lpagb;\n\n\tif (phydev->autoneg == AUTONEG_ENABLE) {\n\t\tif (!phydev->autoneg_complete) {\n\t\t\tmii_stat1000_mod_linkmode_lpa_t(phydev->lp_advertising,\n\t\t\t\t\t\t\t0);\n\t\t\tmii_lpa_mod_linkmode_lpa_t(phydev->lp_advertising, 0);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (phydev->is_gigabit_capable) {\n\t\t\tlpagb = phy_read(phydev, MII_STAT1000);\n\t\t\tif (lpagb < 0)\n\t\t\t\treturn lpagb;\n\n\t\t\tif (lpagb & LPA_1000MSFAIL) {\n\t\t\t\tint adv = phy_read(phydev, MII_CTRL1000);\n\n\t\t\t\tif (adv < 0)\n\t\t\t\t\treturn adv;\n\n\t\t\t\tif (adv & CTL1000_ENABLE_MASTER)\n\t\t\t\t\tphydev_err(phydev, \"Master/Slave resolution failed, maybe conflicting manual settings?\\n\");\n\t\t\t\telse\n\t\t\t\t\tphydev_err(phydev, \"Master/Slave resolution failed\\n\");\n\t\t\t\treturn -ENOLINK;\n\t\t\t}\n\n\t\t\tmii_stat1000_mod_linkmode_lpa_t(phydev->lp_advertising,\n\t\t\t\t\t\t\tlpagb);\n\t\t}\n\n\t\tlpa = phy_read(phydev, MII_LPA);\n\t\tif (lpa < 0)\n\t\t\treturn lpa;\n\n\t\tmii_lpa_mod_linkmode_lpa_t(phydev->lp_advertising, lpa);\n\t} else {\n\t\tlinkmode_zero(phydev->lp_advertising);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(genphy_read_lpa);\n\n \nint genphy_read_status_fixed(struct phy_device *phydev)\n{\n\tint bmcr = phy_read(phydev, MII_BMCR);\n\n\tif (bmcr < 0)\n\t\treturn bmcr;\n\n\tif (bmcr & BMCR_FULLDPLX)\n\t\tphydev->duplex = DUPLEX_FULL;\n\telse\n\t\tphydev->duplex = DUPLEX_HALF;\n\n\tif (bmcr & BMCR_SPEED1000)\n\t\tphydev->speed = SPEED_1000;\n\telse if (bmcr & BMCR_SPEED100)\n\t\tphydev->speed = SPEED_100;\n\telse\n\t\tphydev->speed = SPEED_10;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(genphy_read_status_fixed);\n\n \nint genphy_read_status(struct phy_device *phydev)\n{\n\tint err, old_link = phydev->link;\n\n\t \n\terr = genphy_update_link(phydev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (phydev->autoneg == AUTONEG_ENABLE && old_link && phydev->link)\n\t\treturn 0;\n\n\tphydev->master_slave_get = MASTER_SLAVE_CFG_UNSUPPORTED;\n\tphydev->master_slave_state = MASTER_SLAVE_STATE_UNSUPPORTED;\n\tphydev->speed = SPEED_UNKNOWN;\n\tphydev->duplex = DUPLEX_UNKNOWN;\n\tphydev->pause = 0;\n\tphydev->asym_pause = 0;\n\n\tif (phydev->is_gigabit_capable) {\n\t\terr = genphy_read_master_slave(phydev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = genphy_read_lpa(phydev);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (phydev->autoneg == AUTONEG_ENABLE && phydev->autoneg_complete) {\n\t\tphy_resolve_aneg_linkmode(phydev);\n\t} else if (phydev->autoneg == AUTONEG_DISABLE) {\n\t\terr = genphy_read_status_fixed(phydev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(genphy_read_status);\n\n \nint genphy_c37_read_status(struct phy_device *phydev)\n{\n\tint lpa, err, old_link = phydev->link;\n\n\t \n\terr = genphy_update_link(phydev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (phydev->autoneg == AUTONEG_ENABLE && old_link && phydev->link)\n\t\treturn 0;\n\n\tphydev->duplex = DUPLEX_UNKNOWN;\n\tphydev->pause = 0;\n\tphydev->asym_pause = 0;\n\n\tif (phydev->autoneg == AUTONEG_ENABLE && phydev->autoneg_complete) {\n\t\tlpa = phy_read(phydev, MII_LPA);\n\t\tif (lpa < 0)\n\t\t\treturn lpa;\n\n\t\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,\n\t\t\t\t phydev->lp_advertising, lpa & LPA_LPACK);\n\t\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT,\n\t\t\t\t phydev->lp_advertising, lpa & LPA_1000XFULL);\n\t\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_Pause_BIT,\n\t\t\t\t phydev->lp_advertising, lpa & LPA_1000XPAUSE);\n\t\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,\n\t\t\t\t phydev->lp_advertising,\n\t\t\t\t lpa & LPA_1000XPAUSE_ASYM);\n\n\t\tphy_resolve_aneg_linkmode(phydev);\n\t} else if (phydev->autoneg == AUTONEG_DISABLE) {\n\t\tint bmcr = phy_read(phydev, MII_BMCR);\n\n\t\tif (bmcr < 0)\n\t\t\treturn bmcr;\n\n\t\tif (bmcr & BMCR_FULLDPLX)\n\t\t\tphydev->duplex = DUPLEX_FULL;\n\t\telse\n\t\t\tphydev->duplex = DUPLEX_HALF;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(genphy_c37_read_status);\n\n \nint genphy_soft_reset(struct phy_device *phydev)\n{\n\tu16 res = BMCR_RESET;\n\tint ret;\n\n\tif (phydev->autoneg == AUTONEG_ENABLE)\n\t\tres |= BMCR_ANRESTART;\n\n\tret = phy_modify(phydev, MII_BMCR, BMCR_ISOLATE, res);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tphydev->suspended = 0;\n\n\tret = phy_poll_reset(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (phydev->autoneg == AUTONEG_DISABLE)\n\t\tret = genphy_setup_forced(phydev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(genphy_soft_reset);\n\nirqreturn_t genphy_handle_interrupt_no_ack(struct phy_device *phydev)\n{\n\t \n\tphy_trigger_machine(phydev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(genphy_handle_interrupt_no_ack);\n\n \nint genphy_read_abilities(struct phy_device *phydev)\n{\n\tint val;\n\n\tlinkmode_set_bit_array(phy_basic_ports_array,\n\t\t\t       ARRAY_SIZE(phy_basic_ports_array),\n\t\t\t       phydev->supported);\n\n\tval = phy_read(phydev, MII_BMSR);\n\tif (val < 0)\n\t\treturn val;\n\n\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, phydev->supported,\n\t\t\t val & BMSR_ANEGCAPABLE);\n\n\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, phydev->supported,\n\t\t\t val & BMSR_100FULL);\n\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT, phydev->supported,\n\t\t\t val & BMSR_100HALF);\n\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT, phydev->supported,\n\t\t\t val & BMSR_10FULL);\n\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT, phydev->supported,\n\t\t\t val & BMSR_10HALF);\n\n\tif (val & BMSR_ESTATEN) {\n\t\tval = phy_read(phydev, MII_ESTATUS);\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,\n\t\t\t\t phydev->supported, val & ESTATUS_1000_TFULL);\n\t\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT,\n\t\t\t\t phydev->supported, val & ESTATUS_1000_THALF);\n\t\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT,\n\t\t\t\t phydev->supported, val & ESTATUS_1000_XFULL);\n\t}\n\n\t \n\tgenphy_c45_read_eee_abilities(phydev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(genphy_read_abilities);\n\n \nint genphy_read_mmd_unsupported(struct phy_device *phdev, int devad, u16 regnum)\n{\n\treturn -EOPNOTSUPP;\n}\nEXPORT_SYMBOL(genphy_read_mmd_unsupported);\n\nint genphy_write_mmd_unsupported(struct phy_device *phdev, int devnum,\n\t\t\t\t u16 regnum, u16 val)\n{\n\treturn -EOPNOTSUPP;\n}\nEXPORT_SYMBOL(genphy_write_mmd_unsupported);\n\nint genphy_suspend(struct phy_device *phydev)\n{\n\treturn phy_set_bits(phydev, MII_BMCR, BMCR_PDOWN);\n}\nEXPORT_SYMBOL(genphy_suspend);\n\nint genphy_resume(struct phy_device *phydev)\n{\n\treturn phy_clear_bits(phydev, MII_BMCR, BMCR_PDOWN);\n}\nEXPORT_SYMBOL(genphy_resume);\n\nint genphy_loopback(struct phy_device *phydev, bool enable)\n{\n\tif (enable) {\n\t\tu16 val, ctl = BMCR_LOOPBACK;\n\t\tint ret;\n\n\t\tctl |= mii_bmcr_encode_fixed(phydev->speed, phydev->duplex);\n\n\t\tphy_modify(phydev, MII_BMCR, ~0, ctl);\n\n\t\tret = phy_read_poll_timeout(phydev, MII_BMSR, val,\n\t\t\t\t\t    val & BMSR_LSTATUS,\n\t\t\t\t    5000, 500000, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tphy_modify(phydev, MII_BMCR, BMCR_LOOPBACK, 0);\n\n\t\tphy_config_aneg(phydev);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(genphy_loopback);\n\n \nvoid phy_remove_link_mode(struct phy_device *phydev, u32 link_mode)\n{\n\tlinkmode_clear_bit(link_mode, phydev->supported);\n\tphy_advertise_supported(phydev);\n}\nEXPORT_SYMBOL(phy_remove_link_mode);\n\nstatic void phy_copy_pause_bits(unsigned long *dst, unsigned long *src)\n{\n\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, dst,\n\t\tlinkmode_test_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, src));\n\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_Pause_BIT, dst,\n\t\tlinkmode_test_bit(ETHTOOL_LINK_MODE_Pause_BIT, src));\n}\n\n \nvoid phy_advertise_supported(struct phy_device *phydev)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(new);\n\n\tlinkmode_copy(new, phydev->supported);\n\tphy_copy_pause_bits(new, phydev->advertising);\n\tlinkmode_copy(phydev->advertising, new);\n}\nEXPORT_SYMBOL(phy_advertise_supported);\n\n \nvoid phy_support_sym_pause(struct phy_device *phydev)\n{\n\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, phydev->supported);\n\tphy_copy_pause_bits(phydev->advertising, phydev->supported);\n}\nEXPORT_SYMBOL(phy_support_sym_pause);\n\n \nvoid phy_support_asym_pause(struct phy_device *phydev)\n{\n\tphy_copy_pause_bits(phydev->advertising, phydev->supported);\n}\nEXPORT_SYMBOL(phy_support_asym_pause);\n\n \nvoid phy_set_sym_pause(struct phy_device *phydev, bool rx, bool tx,\n\t\t       bool autoneg)\n{\n\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_Pause_BIT, phydev->supported);\n\n\tif (rx && tx && autoneg)\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_Pause_BIT,\n\t\t\t\t phydev->supported);\n\n\tlinkmode_copy(phydev->advertising, phydev->supported);\n}\nEXPORT_SYMBOL(phy_set_sym_pause);\n\n \nvoid phy_set_asym_pause(struct phy_device *phydev, bool rx, bool tx)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(oldadv);\n\n\tlinkmode_copy(oldadv, phydev->advertising);\n\tlinkmode_set_pause(phydev->advertising, tx, rx);\n\n\tif (!linkmode_equal(oldadv, phydev->advertising) &&\n\t    phydev->autoneg)\n\t\tphy_start_aneg(phydev);\n}\nEXPORT_SYMBOL(phy_set_asym_pause);\n\n \nbool phy_validate_pause(struct phy_device *phydev,\n\t\t\tstruct ethtool_pauseparam *pp)\n{\n\tif (!linkmode_test_bit(ETHTOOL_LINK_MODE_Pause_BIT,\n\t\t\t       phydev->supported) && pp->rx_pause)\n\t\treturn false;\n\n\tif (!linkmode_test_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,\n\t\t\t       phydev->supported) &&\n\t    pp->rx_pause != pp->tx_pause)\n\t\treturn false;\n\n\treturn true;\n}\nEXPORT_SYMBOL(phy_validate_pause);\n\n \nvoid phy_get_pause(struct phy_device *phydev, bool *tx_pause, bool *rx_pause)\n{\n\tif (phydev->duplex != DUPLEX_FULL) {\n\t\t*tx_pause = false;\n\t\t*rx_pause = false;\n\t\treturn;\n\t}\n\n\treturn linkmode_resolve_pause(phydev->advertising,\n\t\t\t\t      phydev->lp_advertising,\n\t\t\t\t      tx_pause, rx_pause);\n}\nEXPORT_SYMBOL(phy_get_pause);\n\n#if IS_ENABLED(CONFIG_OF_MDIO)\nstatic int phy_get_int_delay_property(struct device *dev, const char *name)\n{\n\ts32 int_delay;\n\tint ret;\n\n\tret = device_property_read_u32(dev, name, &int_delay);\n\tif (ret)\n\t\treturn ret;\n\n\treturn int_delay;\n}\n#else\nstatic int phy_get_int_delay_property(struct device *dev, const char *name)\n{\n\treturn -EINVAL;\n}\n#endif\n\n \ns32 phy_get_internal_delay(struct phy_device *phydev, struct device *dev,\n\t\t\t   const int *delay_values, int size, bool is_rx)\n{\n\ts32 delay;\n\tint i;\n\n\tif (is_rx) {\n\t\tdelay = phy_get_int_delay_property(dev, \"rx-internal-delay-ps\");\n\t\tif (delay < 0 && size == 0) {\n\t\t\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID ||\n\t\t\t    phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\n\t} else {\n\t\tdelay = phy_get_int_delay_property(dev, \"tx-internal-delay-ps\");\n\t\tif (delay < 0 && size == 0) {\n\t\t\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID ||\n\t\t\t    phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (delay < 0)\n\t\treturn delay;\n\n\tif (delay && size == 0)\n\t\treturn delay;\n\n\tif (delay < delay_values[0] || delay > delay_values[size - 1]) {\n\t\tphydev_err(phydev, \"Delay %d is out of range\\n\", delay);\n\t\treturn -EINVAL;\n\t}\n\n\tif (delay == delay_values[0])\n\t\treturn 0;\n\n\tfor (i = 1; i < size; i++) {\n\t\tif (delay == delay_values[i])\n\t\t\treturn i;\n\n\t\t \n\t\tif (delay > delay_values[i - 1] &&\n\t\t    delay < delay_values[i]) {\n\t\t\tif (delay - delay_values[i - 1] <\n\t\t\t    delay_values[i] - delay)\n\t\t\t\treturn i - 1;\n\t\t\telse\n\t\t\t\treturn i;\n\t\t}\n\t}\n\n\tphydev_err(phydev, \"error finding internal delay index for %d\\n\",\n\t\t   delay);\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(phy_get_internal_delay);\n\nstatic bool phy_drv_supports_irq(struct phy_driver *phydrv)\n{\n\treturn phydrv->config_intr && phydrv->handle_interrupt;\n}\n\nstatic int phy_led_set_brightness(struct led_classdev *led_cdev,\n\t\t\t\t  enum led_brightness value)\n{\n\tstruct phy_led *phyled = to_phy_led(led_cdev);\n\tstruct phy_device *phydev = phyled->phydev;\n\tint err;\n\n\tmutex_lock(&phydev->lock);\n\terr = phydev->drv->led_brightness_set(phydev, phyled->index, value);\n\tmutex_unlock(&phydev->lock);\n\n\treturn err;\n}\n\nstatic int phy_led_blink_set(struct led_classdev *led_cdev,\n\t\t\t     unsigned long *delay_on,\n\t\t\t     unsigned long *delay_off)\n{\n\tstruct phy_led *phyled = to_phy_led(led_cdev);\n\tstruct phy_device *phydev = phyled->phydev;\n\tint err;\n\n\tmutex_lock(&phydev->lock);\n\terr = phydev->drv->led_blink_set(phydev, phyled->index,\n\t\t\t\t\t delay_on, delay_off);\n\tmutex_unlock(&phydev->lock);\n\n\treturn err;\n}\n\nstatic __maybe_unused struct device *\nphy_led_hw_control_get_device(struct led_classdev *led_cdev)\n{\n\tstruct phy_led *phyled = to_phy_led(led_cdev);\n\tstruct phy_device *phydev = phyled->phydev;\n\n\tif (phydev->attached_dev)\n\t\treturn &phydev->attached_dev->dev;\n\treturn NULL;\n}\n\nstatic int __maybe_unused\nphy_led_hw_control_get(struct led_classdev *led_cdev,\n\t\t       unsigned long *rules)\n{\n\tstruct phy_led *phyled = to_phy_led(led_cdev);\n\tstruct phy_device *phydev = phyled->phydev;\n\tint err;\n\n\tmutex_lock(&phydev->lock);\n\terr = phydev->drv->led_hw_control_get(phydev, phyled->index, rules);\n\tmutex_unlock(&phydev->lock);\n\n\treturn err;\n}\n\nstatic int __maybe_unused\nphy_led_hw_control_set(struct led_classdev *led_cdev,\n\t\t       unsigned long rules)\n{\n\tstruct phy_led *phyled = to_phy_led(led_cdev);\n\tstruct phy_device *phydev = phyled->phydev;\n\tint err;\n\n\tmutex_lock(&phydev->lock);\n\terr = phydev->drv->led_hw_control_set(phydev, phyled->index, rules);\n\tmutex_unlock(&phydev->lock);\n\n\treturn err;\n}\n\nstatic __maybe_unused int phy_led_hw_is_supported(struct led_classdev *led_cdev,\n\t\t\t\t\t\t  unsigned long rules)\n{\n\tstruct phy_led *phyled = to_phy_led(led_cdev);\n\tstruct phy_device *phydev = phyled->phydev;\n\tint err;\n\n\tmutex_lock(&phydev->lock);\n\terr = phydev->drv->led_hw_is_supported(phydev, phyled->index, rules);\n\tmutex_unlock(&phydev->lock);\n\n\treturn err;\n}\n\nstatic void phy_leds_unregister(struct phy_device *phydev)\n{\n\tstruct phy_led *phyled;\n\n\tlist_for_each_entry(phyled, &phydev->leds, list) {\n\t\tled_classdev_unregister(&phyled->led_cdev);\n\t}\n}\n\nstatic int of_phy_led(struct phy_device *phydev,\n\t\t      struct device_node *led)\n{\n\tstruct device *dev = &phydev->mdio.dev;\n\tstruct led_init_data init_data = {};\n\tstruct led_classdev *cdev;\n\tstruct phy_led *phyled;\n\tu32 index;\n\tint err;\n\n\tphyled = devm_kzalloc(dev, sizeof(*phyled), GFP_KERNEL);\n\tif (!phyled)\n\t\treturn -ENOMEM;\n\n\tcdev = &phyled->led_cdev;\n\tphyled->phydev = phydev;\n\n\terr = of_property_read_u32(led, \"reg\", &index);\n\tif (err)\n\t\treturn err;\n\tif (index > U8_MAX)\n\t\treturn -EINVAL;\n\n\tphyled->index = index;\n\tif (phydev->drv->led_brightness_set)\n\t\tcdev->brightness_set_blocking = phy_led_set_brightness;\n\tif (phydev->drv->led_blink_set)\n\t\tcdev->blink_set = phy_led_blink_set;\n\n#ifdef CONFIG_LEDS_TRIGGERS\n\tif (phydev->drv->led_hw_is_supported &&\n\t    phydev->drv->led_hw_control_set &&\n\t    phydev->drv->led_hw_control_get) {\n\t\tcdev->hw_control_is_supported = phy_led_hw_is_supported;\n\t\tcdev->hw_control_set = phy_led_hw_control_set;\n\t\tcdev->hw_control_get = phy_led_hw_control_get;\n\t\tcdev->hw_control_trigger = \"netdev\";\n\t}\n\n\tcdev->hw_control_get_device = phy_led_hw_control_get_device;\n#endif\n\tcdev->max_brightness = 1;\n\tinit_data.devicename = dev_name(&phydev->mdio.dev);\n\tinit_data.fwnode = of_fwnode_handle(led);\n\tinit_data.devname_mandatory = true;\n\n\terr = led_classdev_register_ext(dev, cdev, &init_data);\n\tif (err)\n\t\treturn err;\n\n\tlist_add(&phyled->list, &phydev->leds);\n\n\treturn 0;\n}\n\nstatic int of_phy_leds(struct phy_device *phydev)\n{\n\tstruct device_node *node = phydev->mdio.dev.of_node;\n\tstruct device_node *leds, *led;\n\tint err;\n\n\tif (!IS_ENABLED(CONFIG_OF_MDIO))\n\t\treturn 0;\n\n\tif (!node)\n\t\treturn 0;\n\n\tleds = of_get_child_by_name(node, \"leds\");\n\tif (!leds)\n\t\treturn 0;\n\n\tfor_each_available_child_of_node(leds, led) {\n\t\terr = of_phy_led(phydev, led);\n\t\tif (err) {\n\t\t\tof_node_put(led);\n\t\t\tphy_leds_unregister(phydev);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstruct mdio_device *fwnode_mdio_find_device(struct fwnode_handle *fwnode)\n{\n\tstruct device *d;\n\n\tif (!fwnode)\n\t\treturn NULL;\n\n\td = bus_find_device_by_fwnode(&mdio_bus_type, fwnode);\n\tif (!d)\n\t\treturn NULL;\n\n\treturn to_mdio_device(d);\n}\nEXPORT_SYMBOL(fwnode_mdio_find_device);\n\n \nstruct phy_device *fwnode_phy_find_device(struct fwnode_handle *phy_fwnode)\n{\n\tstruct mdio_device *mdiodev;\n\n\tmdiodev = fwnode_mdio_find_device(phy_fwnode);\n\tif (!mdiodev)\n\t\treturn NULL;\n\n\tif (mdiodev->flags & MDIO_DEVICE_FLAG_PHY)\n\t\treturn to_phy_device(&mdiodev->dev);\n\n\tput_device(&mdiodev->dev);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(fwnode_phy_find_device);\n\n \nstruct phy_device *device_phy_find_device(struct device *dev)\n{\n\treturn fwnode_phy_find_device(dev_fwnode(dev));\n}\nEXPORT_SYMBOL_GPL(device_phy_find_device);\n\n \nstruct fwnode_handle *fwnode_get_phy_node(const struct fwnode_handle *fwnode)\n{\n\tstruct fwnode_handle *phy_node;\n\n\t \n\tphy_node = fwnode_find_reference(fwnode, \"phy-handle\", 0);\n\tif (is_acpi_node(fwnode) || !IS_ERR(phy_node))\n\t\treturn phy_node;\n\tphy_node = fwnode_find_reference(fwnode, \"phy\", 0);\n\tif (IS_ERR(phy_node))\n\t\tphy_node = fwnode_find_reference(fwnode, \"phy-device\", 0);\n\treturn phy_node;\n}\nEXPORT_SYMBOL_GPL(fwnode_get_phy_node);\n\n \nstatic int phy_probe(struct device *dev)\n{\n\tstruct phy_device *phydev = to_phy_device(dev);\n\tstruct device_driver *drv = phydev->mdio.dev.driver;\n\tstruct phy_driver *phydrv = to_phy_driver(drv);\n\tint err = 0;\n\n\tphydev->drv = phydrv;\n\n\t \n\tif (!phy_drv_supports_irq(phydrv) && phy_interrupt_is_valid(phydev))\n\t\tphydev->irq = PHY_POLL;\n\n\tif (phydrv->flags & PHY_IS_INTERNAL)\n\t\tphydev->is_internal = true;\n\n\t \n\tphy_device_reset(phydev, 0);\n\n\tif (phydev->drv->probe) {\n\t\terr = phydev->drv->probe(phydev);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tphy_disable_interrupts(phydev);\n\n\t \n\tif (phydrv->features) {\n\t\tlinkmode_copy(phydev->supported, phydrv->features);\n\t\tgenphy_c45_read_eee_abilities(phydev);\n\t}\n\telse if (phydrv->get_features)\n\t\terr = phydrv->get_features(phydev);\n\telse if (phydev->is_c45)\n\t\terr = genphy_c45_pma_read_abilities(phydev);\n\telse\n\t\terr = genphy_read_abilities(phydev);\n\n\tif (err)\n\t\tgoto out;\n\n\tif (!linkmode_test_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,\n\t\t\t       phydev->supported))\n\t\tphydev->autoneg = 0;\n\n\tif (linkmode_test_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT,\n\t\t\t      phydev->supported))\n\t\tphydev->is_gigabit_capable = 1;\n\tif (linkmode_test_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,\n\t\t\t      phydev->supported))\n\t\tphydev->is_gigabit_capable = 1;\n\n\tof_set_phy_supported(phydev);\n\tphy_advertise_supported(phydev);\n\n\t \n\terr = genphy_c45_read_eee_adv(phydev, phydev->advertising_eee);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tphydev->eee_enabled = !linkmode_empty(phydev->advertising_eee);\n\n\t \n\tif (phydev->eee_enabled)\n\t\tlinkmode_and(phydev->advertising_eee, phydev->supported_eee,\n\t\t\t     phydev->advertising_eee);\n\n\t \n\tof_set_phy_eee_broken(phydev);\n\n\t \n\tif (!test_bit(ETHTOOL_LINK_MODE_Pause_BIT, phydev->supported) &&\n\t    !test_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, phydev->supported)) {\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_Pause_BIT,\n\t\t\t\t phydev->supported);\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,\n\t\t\t\t phydev->supported);\n\t}\n\n\t \n\tphydev->state = PHY_READY;\n\n\t \n\tif (IS_ENABLED(CONFIG_PHYLIB_LEDS))\n\t\terr = of_phy_leds(phydev);\n\nout:\n\t \n\tif (err)\n\t\tphy_device_reset(phydev, 1);\n\n\treturn err;\n}\n\nstatic int phy_remove(struct device *dev)\n{\n\tstruct phy_device *phydev = to_phy_device(dev);\n\n\tcancel_delayed_work_sync(&phydev->state_queue);\n\n\tif (IS_ENABLED(CONFIG_PHYLIB_LEDS))\n\t\tphy_leds_unregister(phydev);\n\n\tphydev->state = PHY_DOWN;\n\n\tsfp_bus_del_upstream(phydev->sfp_bus);\n\tphydev->sfp_bus = NULL;\n\n\tif (phydev->drv && phydev->drv->remove)\n\t\tphydev->drv->remove(phydev);\n\n\t \n\tphy_device_reset(phydev, 1);\n\n\tphydev->drv = NULL;\n\n\treturn 0;\n}\n\n \nint phy_driver_register(struct phy_driver *new_driver, struct module *owner)\n{\n\tint retval;\n\n\t \n\tif (WARN_ON(new_driver->features && new_driver->get_features)) {\n\t\tpr_err(\"%s: features and get_features must not both be set\\n\",\n\t\t       new_driver->name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (WARN(new_driver->mdiodrv.driver.of_match_table,\n\t\t \"%s: driver must not provide a DT match table\\n\",\n\t\t new_driver->name))\n\t\treturn -EINVAL;\n\n\tnew_driver->mdiodrv.flags |= MDIO_DEVICE_IS_PHY;\n\tnew_driver->mdiodrv.driver.name = new_driver->name;\n\tnew_driver->mdiodrv.driver.bus = &mdio_bus_type;\n\tnew_driver->mdiodrv.driver.probe = phy_probe;\n\tnew_driver->mdiodrv.driver.remove = phy_remove;\n\tnew_driver->mdiodrv.driver.owner = owner;\n\tnew_driver->mdiodrv.driver.probe_type = PROBE_FORCE_SYNCHRONOUS;\n\n\tretval = driver_register(&new_driver->mdiodrv.driver);\n\tif (retval) {\n\t\tpr_err(\"%s: Error %d in registering driver\\n\",\n\t\t       new_driver->name, retval);\n\n\t\treturn retval;\n\t}\n\n\tpr_debug(\"%s: Registered new driver\\n\", new_driver->name);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(phy_driver_register);\n\nint phy_drivers_register(struct phy_driver *new_driver, int n,\n\t\t\t struct module *owner)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; i < n; i++) {\n\t\tret = phy_driver_register(new_driver + i, owner);\n\t\tif (ret) {\n\t\t\twhile (i-- > 0)\n\t\t\t\tphy_driver_unregister(new_driver + i);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(phy_drivers_register);\n\nvoid phy_driver_unregister(struct phy_driver *drv)\n{\n\tdriver_unregister(&drv->mdiodrv.driver);\n}\nEXPORT_SYMBOL(phy_driver_unregister);\n\nvoid phy_drivers_unregister(struct phy_driver *drv, int n)\n{\n\tint i;\n\n\tfor (i = 0; i < n; i++)\n\t\tphy_driver_unregister(drv + i);\n}\nEXPORT_SYMBOL(phy_drivers_unregister);\n\nstatic struct phy_driver genphy_driver = {\n\t.phy_id\t\t= 0xffffffff,\n\t.phy_id_mask\t= 0xffffffff,\n\t.name\t\t= \"Generic PHY\",\n\t.get_features\t= genphy_read_abilities,\n\t.suspend\t= genphy_suspend,\n\t.resume\t\t= genphy_resume,\n\t.set_loopback   = genphy_loopback,\n};\n\nstatic const struct ethtool_phy_ops phy_ethtool_phy_ops = {\n\t.get_sset_count\t\t= phy_ethtool_get_sset_count,\n\t.get_strings\t\t= phy_ethtool_get_strings,\n\t.get_stats\t\t= phy_ethtool_get_stats,\n\t.get_plca_cfg\t\t= phy_ethtool_get_plca_cfg,\n\t.set_plca_cfg\t\t= phy_ethtool_set_plca_cfg,\n\t.get_plca_status\t= phy_ethtool_get_plca_status,\n\t.start_cable_test\t= phy_start_cable_test,\n\t.start_cable_test_tdr\t= phy_start_cable_test_tdr,\n};\n\nstatic const struct phylib_stubs __phylib_stubs = {\n\t.hwtstamp_get = __phy_hwtstamp_get,\n\t.hwtstamp_set = __phy_hwtstamp_set,\n};\n\nstatic void phylib_register_stubs(void)\n{\n\tphylib_stubs = &__phylib_stubs;\n}\n\nstatic void phylib_unregister_stubs(void)\n{\n\tphylib_stubs = NULL;\n}\n\nstatic int __init phy_init(void)\n{\n\tint rc;\n\n\trtnl_lock();\n\tethtool_set_ethtool_phy_ops(&phy_ethtool_phy_ops);\n\tphylib_register_stubs();\n\trtnl_unlock();\n\n\trc = mdio_bus_init();\n\tif (rc)\n\t\tgoto err_ethtool_phy_ops;\n\n\tfeatures_init();\n\n\trc = phy_driver_register(&genphy_c45_driver, THIS_MODULE);\n\tif (rc)\n\t\tgoto err_mdio_bus;\n\n\trc = phy_driver_register(&genphy_driver, THIS_MODULE);\n\tif (rc)\n\t\tgoto err_c45;\n\n\treturn 0;\n\nerr_c45:\n\tphy_driver_unregister(&genphy_c45_driver);\nerr_mdio_bus:\n\tmdio_bus_exit();\nerr_ethtool_phy_ops:\n\trtnl_lock();\n\tphylib_unregister_stubs();\n\tethtool_set_ethtool_phy_ops(NULL);\n\trtnl_unlock();\n\n\treturn rc;\n}\n\nstatic void __exit phy_exit(void)\n{\n\tphy_driver_unregister(&genphy_c45_driver);\n\tphy_driver_unregister(&genphy_driver);\n\tmdio_bus_exit();\n\trtnl_lock();\n\tphylib_unregister_stubs();\n\tethtool_set_ethtool_phy_ops(NULL);\n\trtnl_unlock();\n}\n\nsubsys_initcall(phy_init);\nmodule_exit(phy_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}