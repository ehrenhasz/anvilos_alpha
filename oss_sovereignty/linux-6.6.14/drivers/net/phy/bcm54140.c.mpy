{
  "module_name": "bcm54140.c",
  "hash_id": "bcda711e2a6dc93280f220d735736f7b9e5bf1baf1525d8ef3326849aa1beba7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/bcm54140.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/brcmphy.h>\n#include <linux/hwmon.h>\n#include <linux/module.h>\n#include <linux/phy.h>\n\n#include \"bcm-phy-lib.h\"\n\n \n#define BCM54140_RDB_ISR\t\t0x00a\t \n#define BCM54140_RDB_IMR\t\t0x00b\t \n#define  BCM54140_RDB_INT_LINK\t\tBIT(1)\t \n#define  BCM54140_RDB_INT_SPEED\t\tBIT(2)\t \n#define  BCM54140_RDB_INT_DUPLEX\tBIT(3)\t \n#define BCM54140_RDB_SPARE1\t\t0x012\t \n#define  BCM54140_RDB_SPARE1_LSLM\tBIT(2)\t \n#define BCM54140_RDB_SPARE2\t\t0x014\t \n#define  BCM54140_RDB_SPARE2_WS_RTRY_DIS BIT(8)  \n#define  BCM54140_RDB_SPARE2_WS_RTRY_LIMIT GENMASK(4, 2)  \n#define BCM54140_RDB_SPARE3\t\t0x015\t \n#define  BCM54140_RDB_SPARE3_BIT0\tBIT(0)\n#define BCM54140_RDB_LED_CTRL\t\t0x019\t \n#define  BCM54140_RDB_LED_CTRL_ACTLINK0\tBIT(4)\n#define  BCM54140_RDB_LED_CTRL_ACTLINK1\tBIT(8)\n#define BCM54140_RDB_C_APWR\t\t0x01a\t \n#define  BCM54140_RDB_C_APWR_SINGLE_PULSE\tBIT(8)\t \n#define  BCM54140_RDB_C_APWR_APD_MODE_DIS\t0  \n#define  BCM54140_RDB_C_APWR_APD_MODE_EN\t1  \n#define  BCM54140_RDB_C_APWR_APD_MODE_DIS2\t2  \n#define  BCM54140_RDB_C_APWR_APD_MODE_EN_ANEG\t3  \n#define  BCM54140_RDB_C_APWR_APD_MODE_MASK\tGENMASK(6, 5)\n#define  BCM54140_RDB_C_APWR_SLP_TIM_MASK BIT(4) \n#define  BCM54140_RDB_C_APWR_SLP_TIM_2_7 0\t \n#define  BCM54140_RDB_C_APWR_SLP_TIM_5_4 1\t \n#define BCM54140_RDB_C_PWR\t\t0x02a\t \n#define  BCM54140_RDB_C_PWR_ISOLATE\tBIT(5)\t \n#define BCM54140_RDB_C_MISC_CTRL\t0x02f\t \n#define  BCM54140_RDB_C_MISC_CTRL_WS_EN BIT(4)\t \n\n \n#define BCM54140_RDB_TOP_IMR\t\t0x82d\t \n#define  BCM54140_RDB_TOP_IMR_PORT0\tBIT(4)\n#define  BCM54140_RDB_TOP_IMR_PORT1\tBIT(5)\n#define  BCM54140_RDB_TOP_IMR_PORT2\tBIT(6)\n#define  BCM54140_RDB_TOP_IMR_PORT3\tBIT(7)\n#define BCM54140_RDB_MON_CTRL\t\t0x831\t \n#define  BCM54140_RDB_MON_CTRL_V_MODE\tBIT(3)\t \n#define  BCM54140_RDB_MON_CTRL_SEL_MASK\tGENMASK(2, 1)\n#define  BCM54140_RDB_MON_CTRL_SEL_TEMP\t0\t \n#define  BCM54140_RDB_MON_CTRL_SEL_1V0\t1\t \n#define  BCM54140_RDB_MON_CTRL_SEL_3V3\t2\t \n#define  BCM54140_RDB_MON_CTRL_SEL_RR\t3\t \n#define  BCM54140_RDB_MON_CTRL_PWR_DOWN\tBIT(0)\t \n#define BCM54140_RDB_MON_TEMP_VAL\t0x832\t \n#define BCM54140_RDB_MON_TEMP_MAX\t0x833\t \n#define BCM54140_RDB_MON_TEMP_MIN\t0x834\t \n#define  BCM54140_RDB_MON_TEMP_DATA_MASK GENMASK(9, 0)\n#define BCM54140_RDB_MON_1V0_VAL\t0x835\t \n#define BCM54140_RDB_MON_1V0_MAX\t0x836\t \n#define BCM54140_RDB_MON_1V0_MIN\t0x837\t \n#define  BCM54140_RDB_MON_1V0_DATA_MASK\tGENMASK(10, 0)\n#define BCM54140_RDB_MON_3V3_VAL\t0x838\t \n#define BCM54140_RDB_MON_3V3_MAX\t0x839\t \n#define BCM54140_RDB_MON_3V3_MIN\t0x83a\t \n#define  BCM54140_RDB_MON_3V3_DATA_MASK\tGENMASK(11, 0)\n#define BCM54140_RDB_MON_ISR\t\t0x83b\t \n#define  BCM54140_RDB_MON_ISR_3V3\tBIT(2)\t \n#define  BCM54140_RDB_MON_ISR_1V0\tBIT(1)\t \n#define  BCM54140_RDB_MON_ISR_TEMP\tBIT(0)\t \n\n \n#define BCM54140_HWMON_TO_TEMP(v) (413350L - (v) * 491)\n#define BCM54140_HWMON_FROM_TEMP(v) DIV_ROUND_CLOSEST_ULL(413350L - (v), 491)\n\n \n#define BCM54140_HWMON_TO_IN_1V0(v) ((v) * 2514 >> 11)\n#define BCM54140_HWMON_FROM_IN_1V0(v) DIV_ROUND_CLOSEST_ULL(((v) << 11), 2514)\n\n \n#define BCM54140_HWMON_TO_IN_3V3(v) ((v) * 4400 >> 12)\n#define BCM54140_HWMON_FROM_IN_3V3(v) DIV_ROUND_CLOSEST_ULL(((v) << 12), 4400)\n\n#define BCM54140_HWMON_TO_IN(ch, v) ((ch) ? BCM54140_HWMON_TO_IN_3V3(v) \\\n\t\t\t\t\t  : BCM54140_HWMON_TO_IN_1V0(v))\n#define BCM54140_HWMON_FROM_IN(ch, v) ((ch) ? BCM54140_HWMON_FROM_IN_3V3(v) \\\n\t\t\t\t\t    : BCM54140_HWMON_FROM_IN_1V0(v))\n#define BCM54140_HWMON_IN_MASK(ch) ((ch) ? BCM54140_RDB_MON_3V3_DATA_MASK \\\n\t\t\t\t\t : BCM54140_RDB_MON_1V0_DATA_MASK)\n#define BCM54140_HWMON_IN_VAL_REG(ch) ((ch) ? BCM54140_RDB_MON_3V3_VAL \\\n\t\t\t\t\t    : BCM54140_RDB_MON_1V0_VAL)\n#define BCM54140_HWMON_IN_MIN_REG(ch) ((ch) ? BCM54140_RDB_MON_3V3_MIN \\\n\t\t\t\t\t    : BCM54140_RDB_MON_1V0_MIN)\n#define BCM54140_HWMON_IN_MAX_REG(ch) ((ch) ? BCM54140_RDB_MON_3V3_MAX \\\n\t\t\t\t\t    : BCM54140_RDB_MON_1V0_MAX)\n#define BCM54140_HWMON_IN_ALARM_BIT(ch) ((ch) ? BCM54140_RDB_MON_ISR_3V3 \\\n\t\t\t\t\t      : BCM54140_RDB_MON_ISR_1V0)\n\n \n#define BCM54140_PHY_ID_MASK\t0xffffffe8\n\n#define BCM54140_PHY_ID_REV(phy_id)\t((phy_id) & 0x7)\n#define BCM54140_REV_B0\t\t\t1\n\n#define BCM54140_DEFAULT_DOWNSHIFT 5\n#define BCM54140_MAX_DOWNSHIFT 9\n\nstruct bcm54140_priv {\n\tint port;\n\tint base_addr;\n#if IS_ENABLED(CONFIG_HWMON)\n\t \n\tstruct mutex alarm_lock;\n\tu16 alarm;\n#endif\n};\n\n#if IS_ENABLED(CONFIG_HWMON)\nstatic umode_t bcm54140_hwmon_is_visible(const void *data,\n\t\t\t\t\t enum hwmon_sensor_types type,\n\t\t\t\t\t u32 attr, int channel)\n{\n\tswitch (type) {\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_min:\n\t\tcase hwmon_in_max:\n\t\t\treturn 0644;\n\t\tcase hwmon_in_label:\n\t\tcase hwmon_in_input:\n\t\tcase hwmon_in_alarm:\n\t\t\treturn 0444;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_min:\n\t\tcase hwmon_temp_max:\n\t\t\treturn 0644;\n\t\tcase hwmon_temp_input:\n\t\tcase hwmon_temp_alarm:\n\t\t\treturn 0444;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int bcm54140_hwmon_read_alarm(struct device *dev, unsigned int bit,\n\t\t\t\t     long *val)\n{\n\tstruct phy_device *phydev = dev_get_drvdata(dev);\n\tstruct bcm54140_priv *priv = phydev->priv;\n\tint tmp, ret = 0;\n\n\tmutex_lock(&priv->alarm_lock);\n\n\t \n\ttmp = bcm_phy_read_rdb(phydev, BCM54140_RDB_MON_ISR);\n\tif (tmp < 0) {\n\t\tret = tmp;\n\t\tgoto out;\n\t}\n\tpriv->alarm |= tmp;\n\n\t*val = !!(priv->alarm & bit);\n\tpriv->alarm &= ~bit;\n\nout:\n\tmutex_unlock(&priv->alarm_lock);\n\treturn ret;\n}\n\nstatic int bcm54140_hwmon_read_temp(struct device *dev, u32 attr, long *val)\n{\n\tstruct phy_device *phydev = dev_get_drvdata(dev);\n\tu16 reg;\n\tint tmp;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\treg = BCM54140_RDB_MON_TEMP_VAL;\n\t\tbreak;\n\tcase hwmon_temp_min:\n\t\treg = BCM54140_RDB_MON_TEMP_MIN;\n\t\tbreak;\n\tcase hwmon_temp_max:\n\t\treg = BCM54140_RDB_MON_TEMP_MAX;\n\t\tbreak;\n\tcase hwmon_temp_alarm:\n\t\treturn bcm54140_hwmon_read_alarm(dev,\n\t\t\t\t\t\t BCM54140_RDB_MON_ISR_TEMP,\n\t\t\t\t\t\t val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\ttmp = bcm_phy_read_rdb(phydev, reg);\n\tif (tmp < 0)\n\t\treturn tmp;\n\n\t*val = BCM54140_HWMON_TO_TEMP(tmp & BCM54140_RDB_MON_TEMP_DATA_MASK);\n\n\treturn 0;\n}\n\nstatic int bcm54140_hwmon_read_in(struct device *dev, u32 attr,\n\t\t\t\t  int channel, long *val)\n{\n\tstruct phy_device *phydev = dev_get_drvdata(dev);\n\tu16 bit, reg;\n\tint tmp;\n\n\tswitch (attr) {\n\tcase hwmon_in_input:\n\t\treg = BCM54140_HWMON_IN_VAL_REG(channel);\n\t\tbreak;\n\tcase hwmon_in_min:\n\t\treg = BCM54140_HWMON_IN_MIN_REG(channel);\n\t\tbreak;\n\tcase hwmon_in_max:\n\t\treg = BCM54140_HWMON_IN_MAX_REG(channel);\n\t\tbreak;\n\tcase hwmon_in_alarm:\n\t\tbit = BCM54140_HWMON_IN_ALARM_BIT(channel);\n\t\treturn bcm54140_hwmon_read_alarm(dev, bit, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\ttmp = bcm_phy_read_rdb(phydev, reg);\n\tif (tmp < 0)\n\t\treturn tmp;\n\n\ttmp &= BCM54140_HWMON_IN_MASK(channel);\n\t*val = BCM54140_HWMON_TO_IN(channel, tmp);\n\n\treturn 0;\n}\n\nstatic int bcm54140_hwmon_read(struct device *dev,\n\t\t\t       enum hwmon_sensor_types type, u32 attr,\n\t\t\t       int channel, long *val)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\treturn bcm54140_hwmon_read_temp(dev, attr, val);\n\tcase hwmon_in:\n\t\treturn bcm54140_hwmon_read_in(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const char *const bcm54140_hwmon_in_labels[] = {\n\t\"AVDDL\",\n\t\"AVDDH\",\n};\n\nstatic int bcm54140_hwmon_read_string(struct device *dev,\n\t\t\t\t      enum hwmon_sensor_types type, u32 attr,\n\t\t\t\t      int channel, const char **str)\n{\n\tswitch (type) {\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_label:\n\t\t\t*str = bcm54140_hwmon_in_labels[channel];\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int bcm54140_hwmon_write_temp(struct device *dev, u32 attr,\n\t\t\t\t     int channel, long val)\n{\n\tstruct phy_device *phydev = dev_get_drvdata(dev);\n\tu16 mask = BCM54140_RDB_MON_TEMP_DATA_MASK;\n\tu16 reg;\n\n\tval = clamp_val(val, BCM54140_HWMON_TO_TEMP(mask),\n\t\t\tBCM54140_HWMON_TO_TEMP(0));\n\n\tswitch (attr) {\n\tcase hwmon_temp_min:\n\t\treg = BCM54140_RDB_MON_TEMP_MIN;\n\t\tbreak;\n\tcase hwmon_temp_max:\n\t\treg = BCM54140_RDB_MON_TEMP_MAX;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn bcm_phy_modify_rdb(phydev, reg, mask,\n\t\t\t\t  BCM54140_HWMON_FROM_TEMP(val));\n}\n\nstatic int bcm54140_hwmon_write_in(struct device *dev, u32 attr,\n\t\t\t\t   int channel, long val)\n{\n\tstruct phy_device *phydev = dev_get_drvdata(dev);\n\tu16 mask = BCM54140_HWMON_IN_MASK(channel);\n\tu16 reg;\n\n\tval = clamp_val(val, 0, BCM54140_HWMON_TO_IN(channel, mask));\n\n\tswitch (attr) {\n\tcase hwmon_in_min:\n\t\treg = BCM54140_HWMON_IN_MIN_REG(channel);\n\t\tbreak;\n\tcase hwmon_in_max:\n\t\treg = BCM54140_HWMON_IN_MAX_REG(channel);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn bcm_phy_modify_rdb(phydev, reg, mask,\n\t\t\t\t  BCM54140_HWMON_FROM_IN(channel, val));\n}\n\nstatic int bcm54140_hwmon_write(struct device *dev,\n\t\t\t\tenum hwmon_sensor_types type, u32 attr,\n\t\t\t\tint channel, long val)\n{\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\treturn bcm54140_hwmon_write_temp(dev, attr, channel, val);\n\tcase hwmon_in:\n\t\treturn bcm54140_hwmon_write_in(dev, attr, channel, val);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const struct hwmon_channel_info * const bcm54140_hwmon_info[] = {\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT | HWMON_T_MIN | HWMON_T_MAX |\n\t\t\t   HWMON_T_ALARM),\n\tHWMON_CHANNEL_INFO(in,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |\n\t\t\t   HWMON_I_ALARM | HWMON_I_LABEL,\n\t\t\t   HWMON_I_INPUT | HWMON_I_MIN | HWMON_I_MAX |\n\t\t\t   HWMON_I_ALARM | HWMON_I_LABEL),\n\tNULL\n};\n\nstatic const struct hwmon_ops bcm54140_hwmon_ops = {\n\t.is_visible = bcm54140_hwmon_is_visible,\n\t.read = bcm54140_hwmon_read,\n\t.read_string = bcm54140_hwmon_read_string,\n\t.write = bcm54140_hwmon_write,\n};\n\nstatic const struct hwmon_chip_info bcm54140_chip_info = {\n\t.ops = &bcm54140_hwmon_ops,\n\t.info = bcm54140_hwmon_info,\n};\n\nstatic int bcm54140_enable_monitoring(struct phy_device *phydev)\n{\n\tu16 mask, set;\n\n\t \n\tset = BCM54140_RDB_MON_CTRL_V_MODE;\n\n\t \n\tmask = BCM54140_RDB_MON_CTRL_SEL_MASK;\n\tset |= FIELD_PREP(BCM54140_RDB_MON_CTRL_SEL_MASK,\n\t\t\t  BCM54140_RDB_MON_CTRL_SEL_RR);\n\n\t \n\tmask |= BCM54140_RDB_MON_CTRL_PWR_DOWN;\n\n\treturn bcm_phy_modify_rdb(phydev, BCM54140_RDB_MON_CTRL, mask, set);\n}\n\nstatic int bcm54140_probe_once(struct phy_device *phydev)\n{\n\tstruct device *hwmon;\n\tint ret;\n\n\t \n\tret = bcm54140_enable_monitoring(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\thwmon = devm_hwmon_device_register_with_info(&phydev->mdio.dev,\n\t\t\t\t\t\t     \"BCM54140\", phydev,\n\t\t\t\t\t\t     &bcm54140_chip_info,\n\t\t\t\t\t\t     NULL);\n\treturn PTR_ERR_OR_ZERO(hwmon);\n}\n#endif\n\nstatic int bcm54140_base_read_rdb(struct phy_device *phydev, u16 rdb)\n{\n\tint ret;\n\n\tphy_lock_mdio_bus(phydev);\n\tret = __phy_package_write(phydev, MII_BCM54XX_RDB_ADDR, rdb);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = __phy_package_read(phydev, MII_BCM54XX_RDB_DATA);\n\nout:\n\tphy_unlock_mdio_bus(phydev);\n\treturn ret;\n}\n\nstatic int bcm54140_base_write_rdb(struct phy_device *phydev,\n\t\t\t\t   u16 rdb, u16 val)\n{\n\tint ret;\n\n\tphy_lock_mdio_bus(phydev);\n\tret = __phy_package_write(phydev, MII_BCM54XX_RDB_ADDR, rdb);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = __phy_package_write(phydev, MII_BCM54XX_RDB_DATA, val);\n\nout:\n\tphy_unlock_mdio_bus(phydev);\n\treturn ret;\n}\n\n \nstatic int bcm54140_b0_workaround(struct phy_device *phydev)\n{\n\tint spare3;\n\tint ret;\n\n\tspare3 = bcm_phy_read_rdb(phydev, BCM54140_RDB_SPARE3);\n\tif (spare3 < 0)\n\t\treturn spare3;\n\n\tspare3 &= ~BCM54140_RDB_SPARE3_BIT0;\n\n\tret = bcm_phy_write_rdb(phydev, BCM54140_RDB_SPARE3, spare3);\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_modify(phydev, MII_BMCR, 0, BMCR_PDOWN);\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_modify(phydev, MII_BMCR, BMCR_PDOWN, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tspare3 |= BCM54140_RDB_SPARE3_BIT0;\n\n\treturn bcm_phy_write_rdb(phydev, BCM54140_RDB_SPARE3, spare3);\n}\n\n \nstatic int bcm54140_get_base_addr_and_port(struct phy_device *phydev)\n{\n\tstruct bcm54140_priv *priv = phydev->priv;\n\tstruct mii_bus *bus = phydev->mdio.bus;\n\tint addr, min_addr, max_addr;\n\tint step = 1;\n\tu32 phy_id;\n\tint tmp;\n\n\tmin_addr = phydev->mdio.addr;\n\tmax_addr = phydev->mdio.addr;\n\taddr = phydev->mdio.addr;\n\n\t \n\n\twhile (1) {\n\t\tif (step == 3) {\n\t\t\tbreak;\n\t\t} else if (step == 1) {\n\t\t\tmax_addr = addr;\n\t\t\taddr++;\n\t\t} else {\n\t\t\tmin_addr = addr;\n\t\t\taddr--;\n\t\t}\n\n\t\tif (addr < 0 || addr >= PHY_MAX_ADDR) {\n\t\t\taddr = phydev->mdio.addr;\n\t\t\tstep++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\ttmp = mdiobus_read(bus, addr, MII_PHYSID1);\n\t\tif (tmp < 0)\n\t\t\treturn tmp;\n\t\tphy_id = tmp << 16;\n\t\ttmp = mdiobus_read(bus, addr, MII_PHYSID2);\n\t\tif (tmp < 0)\n\t\t\treturn tmp;\n\t\tphy_id |= tmp;\n\n\t\t \n\t\tif ((phy_id & phydev->drv->phy_id_mask) !=\n\t\t    (phydev->drv->phy_id & phydev->drv->phy_id_mask)) {\n\t\t\taddr = phydev->mdio.addr;\n\t\t\tstep++;\n\t\t}\n\t}\n\n\t \n\tif ((max_addr - min_addr + 1) % 4) {\n\t\tdev_err(&phydev->mdio.dev,\n\t\t\t\"Detected Quad PHY IDs %d..%d doesn't make sense.\\n\",\n\t\t\tmin_addr, max_addr);\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->port = (phydev->mdio.addr - min_addr) % 4;\n\tpriv->base_addr = phydev->mdio.addr - priv->port;\n\n\treturn 0;\n}\n\nstatic int bcm54140_probe(struct phy_device *phydev)\n{\n\tstruct bcm54140_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(&phydev->mdio.dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tphydev->priv = priv;\n\n\tret = bcm54140_get_base_addr_and_port(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tdevm_phy_package_join(&phydev->mdio.dev, phydev, priv->base_addr, 0);\n\n#if IS_ENABLED(CONFIG_HWMON)\n\tmutex_init(&priv->alarm_lock);\n\n\tif (phy_package_init_once(phydev)) {\n\t\tret = bcm54140_probe_once(phydev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n#endif\n\n\tphydev_dbg(phydev, \"probed (port %d, base PHY address %d)\\n\",\n\t\t   priv->port, priv->base_addr);\n\n\treturn 0;\n}\n\nstatic int bcm54140_config_init(struct phy_device *phydev)\n{\n\tu16 reg = 0xffff;\n\tint ret;\n\n\t \n\tif (BCM54140_PHY_ID_REV(phydev->phy_id) == BCM54140_REV_B0) {\n\t\tret = bcm54140_b0_workaround(phydev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\treg &= ~(BCM54140_RDB_INT_DUPLEX |\n\t\t BCM54140_RDB_INT_SPEED |\n\t\t BCM54140_RDB_INT_LINK);\n\tret = bcm_phy_write_rdb(phydev, BCM54140_RDB_IMR, reg);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = bcm_phy_modify_rdb(phydev, BCM54140_RDB_SPARE1,\n\t\t\t\t 0, BCM54140_RDB_SPARE1_LSLM);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bcm_phy_modify_rdb(phydev, BCM54140_RDB_LED_CTRL,\n\t\t\t\t 0, BCM54140_RDB_LED_CTRL_ACTLINK0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn bcm_phy_modify_rdb(phydev, BCM54140_RDB_C_PWR,\n\t\t\t\t  BCM54140_RDB_C_PWR_ISOLATE, 0);\n}\n\nstatic irqreturn_t bcm54140_handle_interrupt(struct phy_device *phydev)\n{\n\tint irq_status, irq_mask;\n\n\tirq_status = bcm_phy_read_rdb(phydev, BCM54140_RDB_ISR);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tirq_mask = bcm_phy_read_rdb(phydev, BCM54140_RDB_IMR);\n\tif (irq_mask < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\tirq_mask = ~irq_mask;\n\n\tif (!(irq_status & irq_mask))\n\t\treturn IRQ_NONE;\n\n\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bcm54140_ack_intr(struct phy_device *phydev)\n{\n\tint reg;\n\n\t \n\treg = bcm_phy_read_rdb(phydev, BCM54140_RDB_ISR);\n\tif (reg < 0)\n\t\treturn reg;\n\n\treturn 0;\n}\n\nstatic int bcm54140_config_intr(struct phy_device *phydev)\n{\n\tstruct bcm54140_priv *priv = phydev->priv;\n\tstatic const u16 port_to_imr_bit[] = {\n\t\tBCM54140_RDB_TOP_IMR_PORT0, BCM54140_RDB_TOP_IMR_PORT1,\n\t\tBCM54140_RDB_TOP_IMR_PORT2, BCM54140_RDB_TOP_IMR_PORT3,\n\t};\n\tint reg, err;\n\n\tif (priv->port >= ARRAY_SIZE(port_to_imr_bit))\n\t\treturn -EINVAL;\n\n\treg = bcm54140_base_read_rdb(phydev, BCM54140_RDB_TOP_IMR);\n\tif (reg < 0)\n\t\treturn reg;\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\terr = bcm54140_ack_intr(phydev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treg &= ~port_to_imr_bit[priv->port];\n\t\terr = bcm54140_base_write_rdb(phydev, BCM54140_RDB_TOP_IMR, reg);\n\t} else {\n\t\treg |= port_to_imr_bit[priv->port];\n\t\terr = bcm54140_base_write_rdb(phydev, BCM54140_RDB_TOP_IMR, reg);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = bcm54140_ack_intr(phydev);\n\t}\n\n\treturn err;\n}\n\nstatic int bcm54140_get_downshift(struct phy_device *phydev, u8 *data)\n{\n\tint val;\n\n\tval = bcm_phy_read_rdb(phydev, BCM54140_RDB_C_MISC_CTRL);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (!(val & BCM54140_RDB_C_MISC_CTRL_WS_EN)) {\n\t\t*data = DOWNSHIFT_DEV_DISABLE;\n\t\treturn 0;\n\t}\n\n\tval = bcm_phy_read_rdb(phydev, BCM54140_RDB_SPARE2);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (val & BCM54140_RDB_SPARE2_WS_RTRY_DIS)\n\t\t*data = 1;\n\telse\n\t\t*data = FIELD_GET(BCM54140_RDB_SPARE2_WS_RTRY_LIMIT, val) + 2;\n\n\treturn 0;\n}\n\nstatic int bcm54140_set_downshift(struct phy_device *phydev, u8 cnt)\n{\n\tu16 mask, set;\n\tint ret;\n\n\tif (cnt > BCM54140_MAX_DOWNSHIFT && cnt != DOWNSHIFT_DEV_DEFAULT_COUNT)\n\t\treturn -EINVAL;\n\n\tif (!cnt)\n\t\treturn bcm_phy_modify_rdb(phydev, BCM54140_RDB_C_MISC_CTRL,\n\t\t\t\t\t  BCM54140_RDB_C_MISC_CTRL_WS_EN, 0);\n\n\tif (cnt == DOWNSHIFT_DEV_DEFAULT_COUNT)\n\t\tcnt = BCM54140_DEFAULT_DOWNSHIFT;\n\n\tif (cnt == 1) {\n\t\tmask = 0;\n\t\tset = BCM54140_RDB_SPARE2_WS_RTRY_DIS;\n\t} else {\n\t\tmask = BCM54140_RDB_SPARE2_WS_RTRY_DIS;\n\t\tmask |= BCM54140_RDB_SPARE2_WS_RTRY_LIMIT;\n\t\tset = FIELD_PREP(BCM54140_RDB_SPARE2_WS_RTRY_LIMIT, cnt - 2);\n\t}\n\tret = bcm_phy_modify_rdb(phydev, BCM54140_RDB_SPARE2,\n\t\t\t\t mask, set);\n\tif (ret)\n\t\treturn ret;\n\n\treturn bcm_phy_modify_rdb(phydev, BCM54140_RDB_C_MISC_CTRL,\n\t\t\t\t  0, BCM54140_RDB_C_MISC_CTRL_WS_EN);\n}\n\nstatic int bcm54140_get_edpd(struct phy_device *phydev, u16 *tx_interval)\n{\n\tint val;\n\n\tval = bcm_phy_read_rdb(phydev, BCM54140_RDB_C_APWR);\n\tif (val < 0)\n\t\treturn val;\n\n\tswitch (FIELD_GET(BCM54140_RDB_C_APWR_APD_MODE_MASK, val)) {\n\tcase BCM54140_RDB_C_APWR_APD_MODE_DIS:\n\tcase BCM54140_RDB_C_APWR_APD_MODE_DIS2:\n\t\t*tx_interval = ETHTOOL_PHY_EDPD_DISABLE;\n\t\tbreak;\n\tcase BCM54140_RDB_C_APWR_APD_MODE_EN:\n\tcase BCM54140_RDB_C_APWR_APD_MODE_EN_ANEG:\n\t\tswitch (FIELD_GET(BCM54140_RDB_C_APWR_SLP_TIM_MASK, val)) {\n\t\tcase BCM54140_RDB_C_APWR_SLP_TIM_2_7:\n\t\t\t*tx_interval = 2700;\n\t\t\tbreak;\n\t\tcase BCM54140_RDB_C_APWR_SLP_TIM_5_4:\n\t\t\t*tx_interval = 5400;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int bcm54140_set_edpd(struct phy_device *phydev, u16 tx_interval)\n{\n\tu16 mask, set;\n\n\tmask = BCM54140_RDB_C_APWR_APD_MODE_MASK;\n\tif (tx_interval == ETHTOOL_PHY_EDPD_DISABLE)\n\t\tset = FIELD_PREP(BCM54140_RDB_C_APWR_APD_MODE_MASK,\n\t\t\t\t BCM54140_RDB_C_APWR_APD_MODE_DIS);\n\telse\n\t\tset = FIELD_PREP(BCM54140_RDB_C_APWR_APD_MODE_MASK,\n\t\t\t\t BCM54140_RDB_C_APWR_APD_MODE_EN_ANEG);\n\n\t \n\tset |= BCM54140_RDB_C_APWR_SINGLE_PULSE;\n\n\t \n\tmask |= BCM54140_RDB_C_APWR_SLP_TIM_MASK;\n\tswitch (tx_interval) {\n\tcase ETHTOOL_PHY_EDPD_DFLT_TX_MSECS:\n\tcase ETHTOOL_PHY_EDPD_DISABLE:\n\tcase 2700:\n\t\tset |= BCM54140_RDB_C_APWR_SLP_TIM_2_7;\n\t\tbreak;\n\tcase 5400:\n\t\tset |= BCM54140_RDB_C_APWR_SLP_TIM_5_4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn bcm_phy_modify_rdb(phydev, BCM54140_RDB_C_APWR, mask, set);\n}\n\nstatic int bcm54140_get_tunable(struct phy_device *phydev,\n\t\t\t\tstruct ethtool_tunable *tuna, void *data)\n{\n\tswitch (tuna->id) {\n\tcase ETHTOOL_PHY_DOWNSHIFT:\n\t\treturn bcm54140_get_downshift(phydev, data);\n\tcase ETHTOOL_PHY_EDPD:\n\t\treturn bcm54140_get_edpd(phydev, data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int bcm54140_set_tunable(struct phy_device *phydev,\n\t\t\t\tstruct ethtool_tunable *tuna, const void *data)\n{\n\tswitch (tuna->id) {\n\tcase ETHTOOL_PHY_DOWNSHIFT:\n\t\treturn bcm54140_set_downshift(phydev, *(const u8 *)data);\n\tcase ETHTOOL_PHY_EDPD:\n\t\treturn bcm54140_set_edpd(phydev, *(const u16 *)data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic struct phy_driver bcm54140_drivers[] = {\n\t{\n\t\t.phy_id         = PHY_ID_BCM54140,\n\t\t.phy_id_mask    = BCM54140_PHY_ID_MASK,\n\t\t.name           = \"Broadcom BCM54140\",\n\t\t.flags\t\t= PHY_POLL_CABLE_TEST,\n\t\t.features       = PHY_GBIT_FEATURES,\n\t\t.config_init    = bcm54140_config_init,\n\t\t.handle_interrupt = bcm54140_handle_interrupt,\n\t\t.config_intr    = bcm54140_config_intr,\n\t\t.probe\t\t= bcm54140_probe,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= genphy_resume,\n\t\t.soft_reset\t= genphy_soft_reset,\n\t\t.get_tunable\t= bcm54140_get_tunable,\n\t\t.set_tunable\t= bcm54140_set_tunable,\n\t\t.cable_test_start = bcm_phy_cable_test_start_rdb,\n\t\t.cable_test_get_status = bcm_phy_cable_test_get_status_rdb,\n\t},\n};\nmodule_phy_driver(bcm54140_drivers);\n\nstatic struct mdio_device_id __maybe_unused bcm54140_tbl[] = {\n\t{ PHY_ID_BCM54140, BCM54140_PHY_ID_MASK },\n\t{ }\n};\n\nMODULE_AUTHOR(\"Michael Walle\");\nMODULE_DESCRIPTION(\"Broadcom BCM54140 PHY driver\");\nMODULE_DEVICE_TABLE(mdio, bcm54140_tbl);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}