{
  "module_name": "dp83tc811.c",
  "hash_id": "e60597b9dfce22b2326de11245ac465e346f3625ab31a8fc6dd1eee339f5583a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/dp83tc811.c",
  "human_readable_source": "\n \n\n#include <linux/ethtool.h>\n#include <linux/etherdevice.h>\n#include <linux/kernel.h>\n#include <linux/mii.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy.h>\n#include <linux/netdevice.h>\n\n#define DP83TC811_PHY_ID\t0x2000a253\n#define DP83811_DEVADDR\t\t0x1f\n\n#define MII_DP83811_SGMII_CTRL\t0x09\n#define MII_DP83811_INT_STAT1\t0x12\n#define MII_DP83811_INT_STAT2\t0x13\n#define MII_DP83811_INT_STAT3\t0x18\n#define MII_DP83811_RESET_CTRL\t0x1f\n\n#define DP83811_HW_RESET\tBIT(15)\n#define DP83811_SW_RESET\tBIT(14)\n\n \n#define DP83811_RX_ERR_HF_INT_EN\tBIT(0)\n#define DP83811_MS_TRAINING_INT_EN\tBIT(1)\n#define DP83811_ANEG_COMPLETE_INT_EN\tBIT(2)\n#define DP83811_ESD_EVENT_INT_EN\tBIT(3)\n#define DP83811_WOL_INT_EN\t\tBIT(4)\n#define DP83811_LINK_STAT_INT_EN\tBIT(5)\n#define DP83811_ENERGY_DET_INT_EN\tBIT(6)\n#define DP83811_LINK_QUAL_INT_EN\tBIT(7)\n\n \n#define DP83811_JABBER_DET_INT_EN\tBIT(0)\n#define DP83811_POLARITY_INT_EN\t\tBIT(1)\n#define DP83811_SLEEP_MODE_INT_EN\tBIT(2)\n#define DP83811_OVERTEMP_INT_EN\t\tBIT(3)\n#define DP83811_OVERVOLTAGE_INT_EN\tBIT(6)\n#define DP83811_UNDERVOLTAGE_INT_EN\tBIT(7)\n\n \n#define DP83811_LPS_INT_EN\tBIT(0)\n#define DP83811_NO_FRAME_INT_EN\tBIT(3)\n#define DP83811_POR_DONE_INT_EN\tBIT(4)\n\n#define MII_DP83811_RXSOP1\t0x04a5\n#define MII_DP83811_RXSOP2\t0x04a6\n#define MII_DP83811_RXSOP3\t0x04a7\n\n \n#define MII_DP83811_WOL_CFG\t0x04a0\n#define MII_DP83811_WOL_STAT\t0x04a1\n#define MII_DP83811_WOL_DA1\t0x04a2\n#define MII_DP83811_WOL_DA2\t0x04a3\n#define MII_DP83811_WOL_DA3\t0x04a4\n\n \n#define DP83811_WOL_MAGIC_EN\tBIT(0)\n#define DP83811_WOL_SECURE_ON\tBIT(5)\n#define DP83811_WOL_EN\t\tBIT(7)\n#define DP83811_WOL_INDICATION_SEL BIT(8)\n#define DP83811_WOL_CLR_INDICATION BIT(11)\n\n \n#define DP83811_TDR_AUTO\t\tBIT(8)\n#define DP83811_SGMII_EN\t\tBIT(12)\n#define DP83811_SGMII_AUTO_NEG_EN\tBIT(13)\n#define DP83811_SGMII_TX_ERR_DIS\tBIT(14)\n#define DP83811_SGMII_SOFT_RESET\tBIT(15)\n\nstatic int dp83811_ack_interrupt(struct phy_device *phydev)\n{\n\tint err;\n\n\terr = phy_read(phydev, MII_DP83811_INT_STAT1);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = phy_read(phydev, MII_DP83811_INT_STAT2);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = phy_read(phydev, MII_DP83811_INT_STAT3);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int dp83811_set_wol(struct phy_device *phydev,\n\t\t\t   struct ethtool_wolinfo *wol)\n{\n\tstruct net_device *ndev = phydev->attached_dev;\n\tconst u8 *mac;\n\tu16 value;\n\n\tif (wol->wolopts & (WAKE_MAGIC | WAKE_MAGICSECURE)) {\n\t\tmac = (const u8 *)ndev->dev_addr;\n\n\t\tif (!is_valid_ether_addr(mac))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tphy_write_mmd(phydev, DP83811_DEVADDR, MII_DP83811_WOL_DA1,\n\t\t\t      (mac[1] << 8) | mac[0]);\n\t\tphy_write_mmd(phydev, DP83811_DEVADDR, MII_DP83811_WOL_DA2,\n\t\t\t      (mac[3] << 8) | mac[2]);\n\t\tphy_write_mmd(phydev, DP83811_DEVADDR, MII_DP83811_WOL_DA3,\n\t\t\t      (mac[5] << 8) | mac[4]);\n\n\t\tvalue = phy_read_mmd(phydev, DP83811_DEVADDR,\n\t\t\t\t     MII_DP83811_WOL_CFG);\n\t\tif (wol->wolopts & WAKE_MAGIC)\n\t\t\tvalue |= DP83811_WOL_MAGIC_EN;\n\t\telse\n\t\t\tvalue &= ~DP83811_WOL_MAGIC_EN;\n\n\t\tif (wol->wolopts & WAKE_MAGICSECURE) {\n\t\t\tphy_write_mmd(phydev, DP83811_DEVADDR,\n\t\t\t\t      MII_DP83811_RXSOP1,\n\t\t\t\t      (wol->sopass[1] << 8) | wol->sopass[0]);\n\t\t\tphy_write_mmd(phydev, DP83811_DEVADDR,\n\t\t\t\t      MII_DP83811_RXSOP2,\n\t\t\t\t      (wol->sopass[3] << 8) | wol->sopass[2]);\n\t\t\tphy_write_mmd(phydev, DP83811_DEVADDR,\n\t\t\t\t      MII_DP83811_RXSOP3,\n\t\t\t\t      (wol->sopass[5] << 8) | wol->sopass[4]);\n\t\t\tvalue |= DP83811_WOL_SECURE_ON;\n\t\t} else {\n\t\t\tvalue &= ~DP83811_WOL_SECURE_ON;\n\t\t}\n\n\t\t \n\t\tphy_read(phydev, MII_DP83811_INT_STAT1);\n\n\t\tvalue |= DP83811_WOL_EN | DP83811_WOL_INDICATION_SEL |\n\t\t\t DP83811_WOL_CLR_INDICATION;\n\n\t\treturn phy_write_mmd(phydev, DP83811_DEVADDR,\n\t\t\t\t     MII_DP83811_WOL_CFG, value);\n\t} else {\n\t\treturn phy_clear_bits_mmd(phydev, DP83811_DEVADDR,\n\t\t\t\t\t  MII_DP83811_WOL_CFG, DP83811_WOL_EN);\n\t}\n\n}\n\nstatic void dp83811_get_wol(struct phy_device *phydev,\n\t\t\t    struct ethtool_wolinfo *wol)\n{\n\tu16 sopass_val;\n\tint value;\n\n\twol->supported = (WAKE_MAGIC | WAKE_MAGICSECURE);\n\twol->wolopts = 0;\n\n\tvalue = phy_read_mmd(phydev, DP83811_DEVADDR, MII_DP83811_WOL_CFG);\n\n\tif (value & DP83811_WOL_MAGIC_EN)\n\t\twol->wolopts |= WAKE_MAGIC;\n\n\tif (value & DP83811_WOL_SECURE_ON) {\n\t\tsopass_val = phy_read_mmd(phydev, DP83811_DEVADDR,\n\t\t\t\t\t  MII_DP83811_RXSOP1);\n\t\twol->sopass[0] = (sopass_val & 0xff);\n\t\twol->sopass[1] = (sopass_val >> 8);\n\n\t\tsopass_val = phy_read_mmd(phydev, DP83811_DEVADDR,\n\t\t\t\t\t  MII_DP83811_RXSOP2);\n\t\twol->sopass[2] = (sopass_val & 0xff);\n\t\twol->sopass[3] = (sopass_val >> 8);\n\n\t\tsopass_val = phy_read_mmd(phydev, DP83811_DEVADDR,\n\t\t\t\t\t  MII_DP83811_RXSOP3);\n\t\twol->sopass[4] = (sopass_val & 0xff);\n\t\twol->sopass[5] = (sopass_val >> 8);\n\n\t\twol->wolopts |= WAKE_MAGICSECURE;\n\t}\n\n\t \n\tif (!(value & DP83811_WOL_EN))\n\t\twol->wolopts = 0;\n}\n\nstatic int dp83811_config_intr(struct phy_device *phydev)\n{\n\tint misr_status, err;\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\terr = dp83811_ack_interrupt(phydev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tmisr_status = phy_read(phydev, MII_DP83811_INT_STAT1);\n\t\tif (misr_status < 0)\n\t\t\treturn misr_status;\n\n\t\tmisr_status |= (DP83811_RX_ERR_HF_INT_EN |\n\t\t\t\tDP83811_MS_TRAINING_INT_EN |\n\t\t\t\tDP83811_ANEG_COMPLETE_INT_EN |\n\t\t\t\tDP83811_ESD_EVENT_INT_EN |\n\t\t\t\tDP83811_WOL_INT_EN |\n\t\t\t\tDP83811_LINK_STAT_INT_EN |\n\t\t\t\tDP83811_ENERGY_DET_INT_EN |\n\t\t\t\tDP83811_LINK_QUAL_INT_EN);\n\n\t\terr = phy_write(phydev, MII_DP83811_INT_STAT1, misr_status);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tmisr_status = phy_read(phydev, MII_DP83811_INT_STAT2);\n\t\tif (misr_status < 0)\n\t\t\treturn misr_status;\n\n\t\tmisr_status |= (DP83811_JABBER_DET_INT_EN |\n\t\t\t\tDP83811_POLARITY_INT_EN |\n\t\t\t\tDP83811_SLEEP_MODE_INT_EN |\n\t\t\t\tDP83811_OVERTEMP_INT_EN |\n\t\t\t\tDP83811_OVERVOLTAGE_INT_EN |\n\t\t\t\tDP83811_UNDERVOLTAGE_INT_EN);\n\n\t\terr = phy_write(phydev, MII_DP83811_INT_STAT2, misr_status);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tmisr_status = phy_read(phydev, MII_DP83811_INT_STAT3);\n\t\tif (misr_status < 0)\n\t\t\treturn misr_status;\n\n\t\tmisr_status |= (DP83811_LPS_INT_EN |\n\t\t\t\tDP83811_NO_FRAME_INT_EN |\n\t\t\t\tDP83811_POR_DONE_INT_EN);\n\n\t\terr = phy_write(phydev, MII_DP83811_INT_STAT3, misr_status);\n\n\t} else {\n\t\terr = phy_write(phydev, MII_DP83811_INT_STAT1, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = phy_write(phydev, MII_DP83811_INT_STAT2, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = phy_write(phydev, MII_DP83811_INT_STAT3, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = dp83811_ack_interrupt(phydev);\n\t}\n\n\treturn err;\n}\n\nstatic irqreturn_t dp83811_handle_interrupt(struct phy_device *phydev)\n{\n\tbool trigger_machine = false;\n\tint irq_status;\n\n\t \n\tirq_status = phy_read(phydev, MII_DP83811_INT_STAT1);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\tif (irq_status & ((irq_status & GENMASK(7, 0)) << 8))\n\t\ttrigger_machine = true;\n\n\tirq_status = phy_read(phydev, MII_DP83811_INT_STAT2);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\tif (irq_status & ((irq_status & GENMASK(7, 0)) << 8))\n\t\ttrigger_machine = true;\n\n\tirq_status = phy_read(phydev, MII_DP83811_INT_STAT3);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\tif (irq_status & ((irq_status & GENMASK(7, 0)) << 8))\n\t\ttrigger_machine = true;\n\n\tif (!trigger_machine)\n\t\treturn IRQ_NONE;\n\n\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int dp83811_config_aneg(struct phy_device *phydev)\n{\n\tint value, err;\n\n\tif (phydev->interface == PHY_INTERFACE_MODE_SGMII) {\n\t\tvalue = phy_read(phydev, MII_DP83811_SGMII_CTRL);\n\t\tif (phydev->autoneg == AUTONEG_ENABLE) {\n\t\t\terr = phy_write(phydev, MII_DP83811_SGMII_CTRL,\n\t\t\t\t\t(DP83811_SGMII_AUTO_NEG_EN | value));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\terr = phy_write(phydev, MII_DP83811_SGMII_CTRL,\n\t\t\t\t\t(~DP83811_SGMII_AUTO_NEG_EN & value));\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn genphy_config_aneg(phydev);\n}\n\nstatic int dp83811_config_init(struct phy_device *phydev)\n{\n\tint value, err;\n\n\tvalue = phy_read(phydev, MII_DP83811_SGMII_CTRL);\n\tif (phydev->interface == PHY_INTERFACE_MODE_SGMII) {\n\t\terr = phy_write(phydev, MII_DP83811_SGMII_CTRL,\n\t\t\t\t\t(DP83811_SGMII_EN | value));\n\t} else {\n\t\terr = phy_write(phydev, MII_DP83811_SGMII_CTRL,\n\t\t\t\t(~DP83811_SGMII_EN & value));\n\t}\n\n\tif (err < 0)\n\n\t\treturn err;\n\n\tvalue = DP83811_WOL_MAGIC_EN | DP83811_WOL_SECURE_ON | DP83811_WOL_EN;\n\n\treturn phy_clear_bits_mmd(phydev, DP83811_DEVADDR, MII_DP83811_WOL_CFG,\n\t\t\t\t  value);\n}\n\nstatic int dp83811_phy_reset(struct phy_device *phydev)\n{\n\tint err;\n\n\terr = phy_write(phydev, MII_DP83811_RESET_CTRL, DP83811_HW_RESET);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int dp83811_suspend(struct phy_device *phydev)\n{\n\tint value;\n\n\tvalue = phy_read_mmd(phydev, DP83811_DEVADDR, MII_DP83811_WOL_CFG);\n\n\tif (!(value & DP83811_WOL_EN))\n\t\tgenphy_suspend(phydev);\n\n\treturn 0;\n}\n\nstatic int dp83811_resume(struct phy_device *phydev)\n{\n\tgenphy_resume(phydev);\n\n\tphy_set_bits_mmd(phydev, DP83811_DEVADDR, MII_DP83811_WOL_CFG,\n\t\t\t DP83811_WOL_CLR_INDICATION);\n\n\treturn 0;\n}\n\nstatic struct phy_driver dp83811_driver[] = {\n\t{\n\t\t.phy_id = DP83TC811_PHY_ID,\n\t\t.phy_id_mask = 0xfffffff0,\n\t\t.name = \"TI DP83TC811\",\n\t\t \n\t\t.config_init = dp83811_config_init,\n\t\t.config_aneg = dp83811_config_aneg,\n\t\t.soft_reset = dp83811_phy_reset,\n\t\t.get_wol = dp83811_get_wol,\n\t\t.set_wol = dp83811_set_wol,\n\t\t.config_intr = dp83811_config_intr,\n\t\t.handle_interrupt = dp83811_handle_interrupt,\n\t\t.suspend = dp83811_suspend,\n\t\t.resume = dp83811_resume,\n\t },\n};\nmodule_phy_driver(dp83811_driver);\n\nstatic struct mdio_device_id __maybe_unused dp83811_tbl[] = {\n\t{ DP83TC811_PHY_ID, 0xfffffff0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(mdio, dp83811_tbl);\n\nMODULE_DESCRIPTION(\"Texas Instruments DP83TC811 PHY driver\");\nMODULE_AUTHOR(\"Dan Murphy <dmurphy@ti.com\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}