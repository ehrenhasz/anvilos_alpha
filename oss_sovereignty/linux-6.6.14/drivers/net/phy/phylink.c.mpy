{
  "module_name": "phylink.c",
  "hash_id": "41184bce221f5de859cb092f9a15aecbcfc6b416821f8b9cb8f3d32b77b85dea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/phylink.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/ethtool.h>\n#include <linux/export.h>\n#include <linux/gpio/consumer.h>\n#include <linux/netdevice.h>\n#include <linux/of.h>\n#include <linux/of_mdio.h>\n#include <linux/phy.h>\n#include <linux/phy_fixed.h>\n#include <linux/phylink.h>\n#include <linux/rtnetlink.h>\n#include <linux/spinlock.h>\n#include <linux/timer.h>\n#include <linux/workqueue.h>\n\n#include \"sfp.h\"\n#include \"swphy.h\"\n\n#define SUPPORTED_INTERFACES \\\n\t(SUPPORTED_TP | SUPPORTED_MII | SUPPORTED_FIBRE | \\\n\t SUPPORTED_BNC | SUPPORTED_AUI | SUPPORTED_Backplane)\n#define ADVERTISED_INTERFACES \\\n\t(ADVERTISED_TP | ADVERTISED_MII | ADVERTISED_FIBRE | \\\n\t ADVERTISED_BNC | ADVERTISED_AUI | ADVERTISED_Backplane)\n\nenum {\n\tPHYLINK_DISABLE_STOPPED,\n\tPHYLINK_DISABLE_LINK,\n\tPHYLINK_DISABLE_MAC_WOL,\n\n\tPCS_STATE_DOWN = 0,\n\tPCS_STATE_STARTING,\n\tPCS_STATE_STARTED,\n};\n\n \nstruct phylink {\n\t \n\tstruct net_device *netdev;\n\tconst struct phylink_mac_ops *mac_ops;\n\tstruct phylink_config *config;\n\tstruct phylink_pcs *pcs;\n\tstruct device *dev;\n\tunsigned int old_link_state:1;\n\n\tunsigned long phylink_disable_state;  \n\tstruct phy_device *phydev;\n\tphy_interface_t link_interface;\t \n\tu8 cfg_link_an_mode;\t\t \n\tu8 cur_link_an_mode;\n\tu8 link_port;\t\t\t \n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(supported);\n\n\t \n\tstruct phylink_link_state link_config;\n\n\t \n\tphy_interface_t cur_interface;\n\n\tstruct gpio_desc *link_gpio;\n\tunsigned int link_irq;\n\tstruct timer_list link_poll;\n\tvoid (*get_fixed_state)(struct net_device *dev,\n\t\t\t\tstruct phylink_link_state *s);\n\n\tstruct mutex state_mutex;\n\tstruct phylink_link_state phy_state;\n\tstruct work_struct resolve;\n\tunsigned int pcs_neg_mode;\n\tunsigned int pcs_state;\n\n\tbool mac_link_dropped;\n\tbool using_mac_select_pcs;\n\n\tstruct sfp_bus *sfp_bus;\n\tbool sfp_may_have_phy;\n\tDECLARE_PHY_INTERFACE_MASK(sfp_interfaces);\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(sfp_support);\n\tu8 sfp_port;\n};\n\n#define phylink_printk(level, pl, fmt, ...) \\\n\tdo { \\\n\t\tif ((pl)->config->type == PHYLINK_NETDEV) \\\n\t\t\tnetdev_printk(level, (pl)->netdev, fmt, ##__VA_ARGS__); \\\n\t\telse if ((pl)->config->type == PHYLINK_DEV) \\\n\t\t\tdev_printk(level, (pl)->dev, fmt, ##__VA_ARGS__); \\\n\t} while (0)\n\n#define phylink_err(pl, fmt, ...) \\\n\tphylink_printk(KERN_ERR, pl, fmt, ##__VA_ARGS__)\n#define phylink_warn(pl, fmt, ...) \\\n\tphylink_printk(KERN_WARNING, pl, fmt, ##__VA_ARGS__)\n#define phylink_info(pl, fmt, ...) \\\n\tphylink_printk(KERN_INFO, pl, fmt, ##__VA_ARGS__)\n#if defined(CONFIG_DYNAMIC_DEBUG)\n#define phylink_dbg(pl, fmt, ...) \\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tif ((pl)->config->type == PHYLINK_NETDEV)\t\t\t\\\n\t\tnetdev_dbg((pl)->netdev, fmt, ##__VA_ARGS__);\t\t\\\n\telse if ((pl)->config->type == PHYLINK_DEV)\t\t\t\\\n\t\tdev_dbg((pl)->dev, fmt, ##__VA_ARGS__);\t\t\t\\\n} while (0)\n#elif defined(DEBUG)\n#define phylink_dbg(pl, fmt, ...)\t\t\t\t\t\\\n\tphylink_printk(KERN_DEBUG, pl, fmt, ##__VA_ARGS__)\n#else\n#define phylink_dbg(pl, fmt, ...)\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\t\t\\\n\t\tphylink_printk(KERN_DEBUG, pl, fmt, ##__VA_ARGS__);\t\\\n})\n#endif\n\n \nvoid phylink_set_port_modes(unsigned long *mask)\n{\n\tphylink_set(mask, TP);\n\tphylink_set(mask, AUI);\n\tphylink_set(mask, MII);\n\tphylink_set(mask, FIBRE);\n\tphylink_set(mask, BNC);\n\tphylink_set(mask, Backplane);\n}\nEXPORT_SYMBOL_GPL(phylink_set_port_modes);\n\nstatic int phylink_is_empty_linkmode(const unsigned long *linkmode)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(tmp) = { 0, };\n\n\tphylink_set_port_modes(tmp);\n\tphylink_set(tmp, Autoneg);\n\tphylink_set(tmp, Pause);\n\tphylink_set(tmp, Asym_Pause);\n\n\treturn linkmode_subset(linkmode, tmp);\n}\n\nstatic const char *phylink_an_mode_str(unsigned int mode)\n{\n\tstatic const char *modestr[] = {\n\t\t[MLO_AN_PHY] = \"phy\",\n\t\t[MLO_AN_FIXED] = \"fixed\",\n\t\t[MLO_AN_INBAND] = \"inband\",\n\t};\n\n\treturn mode < ARRAY_SIZE(modestr) ? modestr[mode] : \"unknown\";\n}\n\nstatic unsigned int phylink_interface_signal_rate(phy_interface_t interface)\n{\n\tswitch (interface) {\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_1000BASEX:  \n\t\treturn 1250;\n\tcase PHY_INTERFACE_MODE_2500BASEX:  \n\t\treturn 3125;\n\tcase PHY_INTERFACE_MODE_5GBASER:  \n\t\treturn 5156;\n\tcase PHY_INTERFACE_MODE_10GBASER:  \n\t\treturn 10313;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n \nstatic int phylink_interface_max_speed(phy_interface_t interface)\n{\n\tswitch (interface) {\n\tcase PHY_INTERFACE_MODE_100BASEX:\n\tcase PHY_INTERFACE_MODE_REVRMII:\n\tcase PHY_INTERFACE_MODE_RMII:\n\tcase PHY_INTERFACE_MODE_SMII:\n\tcase PHY_INTERFACE_MODE_REVMII:\n\tcase PHY_INTERFACE_MODE_MII:\n\t\treturn SPEED_100;\n\n\tcase PHY_INTERFACE_MODE_TBI:\n\tcase PHY_INTERFACE_MODE_MOCA:\n\tcase PHY_INTERFACE_MODE_RTBI:\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\tcase PHY_INTERFACE_MODE_1000BASEKX:\n\tcase PHY_INTERFACE_MODE_TRGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_PSGMII:\n\tcase PHY_INTERFACE_MODE_QSGMII:\n\tcase PHY_INTERFACE_MODE_QUSGMII:\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_GMII:\n\t\treturn SPEED_1000;\n\n\tcase PHY_INTERFACE_MODE_2500BASEX:\n\t\treturn SPEED_2500;\n\n\tcase PHY_INTERFACE_MODE_5GBASER:\n\t\treturn SPEED_5000;\n\n\tcase PHY_INTERFACE_MODE_XGMII:\n\tcase PHY_INTERFACE_MODE_RXAUI:\n\tcase PHY_INTERFACE_MODE_XAUI:\n\tcase PHY_INTERFACE_MODE_10GBASER:\n\tcase PHY_INTERFACE_MODE_10GKR:\n\tcase PHY_INTERFACE_MODE_USXGMII:\n\t\treturn SPEED_10000;\n\n\tcase PHY_INTERFACE_MODE_25GBASER:\n\t\treturn SPEED_25000;\n\n\tcase PHY_INTERFACE_MODE_XLGMII:\n\t\treturn SPEED_40000;\n\n\tcase PHY_INTERFACE_MODE_INTERNAL:\n\tcase PHY_INTERFACE_MODE_NA:\n\tcase PHY_INTERFACE_MODE_MAX:\n\t\t \n\t\treturn SPEED_UNKNOWN;\n\t}\n\n\t \n\tWARN_ON_ONCE(1);\n\treturn SPEED_UNKNOWN;\n}\n\n \nvoid phylink_caps_to_linkmodes(unsigned long *linkmodes, unsigned long caps)\n{\n\tif (caps & MAC_SYM_PAUSE)\n\t\t__set_bit(ETHTOOL_LINK_MODE_Pause_BIT, linkmodes);\n\n\tif (caps & MAC_ASYM_PAUSE)\n\t\t__set_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, linkmodes);\n\n\tif (caps & MAC_10HD) {\n\t\t__set_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_10baseT1S_Half_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_10baseT1S_P2MP_Half_BIT, linkmodes);\n\t}\n\n\tif (caps & MAC_10FD) {\n\t\t__set_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_10baseT1L_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_10baseT1S_Full_BIT, linkmodes);\n\t}\n\n\tif (caps & MAC_100HD) {\n\t\t__set_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_100baseFX_Half_BIT, linkmodes);\n\t}\n\n\tif (caps & MAC_100FD) {\n\t\t__set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_100baseT1_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_100baseFX_Full_BIT, linkmodes);\n\t}\n\n\tif (caps & MAC_1000HD)\n\t\t__set_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT, linkmodes);\n\n\tif (caps & MAC_1000FD) {\n\t\t__set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_1000baseKX_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_1000baseT1_Full_BIT, linkmodes);\n\t}\n\n\tif (caps & MAC_2500FD) {\n\t\t__set_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_2500baseX_Full_BIT, linkmodes);\n\t}\n\n\tif (caps & MAC_5000FD)\n\t\t__set_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT, linkmodes);\n\n\tif (caps & MAC_10000FD) {\n\t\t__set_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_10000baseKR_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_10000baseR_FEC_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_10000baseCR_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_10000baseSR_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_10000baseLR_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_10000baseLRM_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_10000baseER_Full_BIT, linkmodes);\n\t}\n\n\tif (caps & MAC_25000FD) {\n\t\t__set_bit(ETHTOOL_LINK_MODE_25000baseCR_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_25000baseKR_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_25000baseSR_Full_BIT, linkmodes);\n\t}\n\n\tif (caps & MAC_40000FD) {\n\t\t__set_bit(ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT, linkmodes);\n\t}\n\n\tif (caps & MAC_50000FD) {\n\t\t__set_bit(ETHTOOL_LINK_MODE_50000baseCR2_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_50000baseKR2_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_50000baseSR2_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_50000baseKR_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_50000baseSR_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_50000baseCR_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT,\n\t\t\t  linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_50000baseDR_Full_BIT, linkmodes);\n\t}\n\n\tif (caps & MAC_56000FD) {\n\t\t__set_bit(ETHTOOL_LINK_MODE_56000baseKR4_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_56000baseCR4_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_56000baseSR4_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_56000baseLR4_Full_BIT, linkmodes);\n\t}\n\n\tif (caps & MAC_100000FD) {\n\t\t__set_bit(ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_100000baseSR4_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT,\n\t\t\t  linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_100000baseKR2_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_100000baseSR2_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_100000baseCR2_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_100000baseLR2_ER2_FR2_Full_BIT,\n\t\t\t  linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_100000baseDR2_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_100000baseKR_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_100000baseSR_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_100000baseLR_ER_FR_Full_BIT,\n\t\t\t  linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_100000baseCR_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_100000baseDR_Full_BIT, linkmodes);\n\t}\n\n\tif (caps & MAC_200000FD) {\n\t\t__set_bit(ETHTOOL_LINK_MODE_200000baseKR4_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_200000baseSR4_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_200000baseLR4_ER4_FR4_Full_BIT,\n\t\t\t  linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_200000baseDR4_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_200000baseCR4_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_200000baseKR2_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_200000baseSR2_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_200000baseLR2_ER2_FR2_Full_BIT,\n\t\t\t  linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_200000baseDR2_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_200000baseCR2_Full_BIT, linkmodes);\n\t}\n\n\tif (caps & MAC_400000FD) {\n\t\t__set_bit(ETHTOOL_LINK_MODE_400000baseKR8_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_400000baseSR8_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_400000baseLR8_ER8_FR8_Full_BIT,\n\t\t\t  linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_400000baseDR8_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_400000baseCR8_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_400000baseKR4_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_400000baseSR4_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_400000baseLR4_ER4_FR4_Full_BIT,\n\t\t\t  linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_400000baseDR4_Full_BIT, linkmodes);\n\t\t__set_bit(ETHTOOL_LINK_MODE_400000baseCR4_Full_BIT, linkmodes);\n\t}\n}\nEXPORT_SYMBOL_GPL(phylink_caps_to_linkmodes);\n\nstatic struct {\n\tunsigned long mask;\n\tint speed;\n\tunsigned int duplex;\n} phylink_caps_params[] = {\n\t{ MAC_400000FD, SPEED_400000, DUPLEX_FULL },\n\t{ MAC_200000FD, SPEED_200000, DUPLEX_FULL },\n\t{ MAC_100000FD, SPEED_100000, DUPLEX_FULL },\n\t{ MAC_56000FD,  SPEED_56000,  DUPLEX_FULL },\n\t{ MAC_50000FD,  SPEED_50000,  DUPLEX_FULL },\n\t{ MAC_40000FD,  SPEED_40000,  DUPLEX_FULL },\n\t{ MAC_25000FD,  SPEED_25000,  DUPLEX_FULL },\n\t{ MAC_20000FD,  SPEED_20000,  DUPLEX_FULL },\n\t{ MAC_10000FD,  SPEED_10000,  DUPLEX_FULL },\n\t{ MAC_5000FD,   SPEED_5000,   DUPLEX_FULL },\n\t{ MAC_2500FD,   SPEED_2500,   DUPLEX_FULL },\n\t{ MAC_1000FD,   SPEED_1000,   DUPLEX_FULL },\n\t{ MAC_1000HD,   SPEED_1000,   DUPLEX_HALF },\n\t{ MAC_100FD,    SPEED_100,    DUPLEX_FULL },\n\t{ MAC_100HD,    SPEED_100,    DUPLEX_HALF },\n\t{ MAC_10FD,     SPEED_10,     DUPLEX_FULL },\n\t{ MAC_10HD,     SPEED_10,     DUPLEX_HALF },\n};\n\n \nvoid phylink_limit_mac_speed(struct phylink_config *config, u32 max_speed)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(phylink_caps_params) &&\n\t\t    phylink_caps_params[i].speed > max_speed; i++)\n\t\tconfig->mac_capabilities &= ~phylink_caps_params[i].mask;\n}\nEXPORT_SYMBOL_GPL(phylink_limit_mac_speed);\n\n \nstatic unsigned long phylink_cap_from_speed_duplex(int speed,\n\t\t\t\t\t\t   unsigned int duplex)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(phylink_caps_params); i++) {\n\t\tif (speed == phylink_caps_params[i].speed &&\n\t\t    duplex == phylink_caps_params[i].duplex)\n\t\t\treturn phylink_caps_params[i].mask;\n\t}\n\n\treturn 0;\n}\n\n \nunsigned long phylink_get_capabilities(phy_interface_t interface,\n\t\t\t\t       unsigned long mac_capabilities,\n\t\t\t\t       int rate_matching)\n{\n\tint max_speed = phylink_interface_max_speed(interface);\n\tunsigned long caps = MAC_SYM_PAUSE | MAC_ASYM_PAUSE;\n\tunsigned long matched_caps = 0;\n\n\tswitch (interface) {\n\tcase PHY_INTERFACE_MODE_USXGMII:\n\t\tcaps |= MAC_10000FD | MAC_5000FD | MAC_2500FD;\n\t\tfallthrough;\n\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_PSGMII:\n\tcase PHY_INTERFACE_MODE_QSGMII:\n\tcase PHY_INTERFACE_MODE_QUSGMII:\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_GMII:\n\t\tcaps |= MAC_1000HD | MAC_1000FD;\n\t\tfallthrough;\n\n\tcase PHY_INTERFACE_MODE_REVRMII:\n\tcase PHY_INTERFACE_MODE_RMII:\n\tcase PHY_INTERFACE_MODE_SMII:\n\tcase PHY_INTERFACE_MODE_REVMII:\n\tcase PHY_INTERFACE_MODE_MII:\n\t\tcaps |= MAC_10HD | MAC_10FD;\n\t\tfallthrough;\n\n\tcase PHY_INTERFACE_MODE_100BASEX:\n\t\tcaps |= MAC_100HD | MAC_100FD;\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_TBI:\n\tcase PHY_INTERFACE_MODE_MOCA:\n\tcase PHY_INTERFACE_MODE_RTBI:\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\t\tcaps |= MAC_1000HD;\n\t\tfallthrough;\n\tcase PHY_INTERFACE_MODE_1000BASEKX:\n\tcase PHY_INTERFACE_MODE_TRGMII:\n\t\tcaps |= MAC_1000FD;\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_2500BASEX:\n\t\tcaps |= MAC_2500FD;\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_5GBASER:\n\t\tcaps |= MAC_5000FD;\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_XGMII:\n\tcase PHY_INTERFACE_MODE_RXAUI:\n\tcase PHY_INTERFACE_MODE_XAUI:\n\tcase PHY_INTERFACE_MODE_10GBASER:\n\tcase PHY_INTERFACE_MODE_10GKR:\n\t\tcaps |= MAC_10000FD;\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_25GBASER:\n\t\tcaps |= MAC_25000FD;\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_XLGMII:\n\t\tcaps |= MAC_40000FD;\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_INTERNAL:\n\t\tcaps |= ~0;\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_NA:\n\tcase PHY_INTERFACE_MODE_MAX:\n\t\tbreak;\n\t}\n\n\tswitch (rate_matching) {\n\tcase RATE_MATCH_OPEN_LOOP:\n\t\t \n\t\tfallthrough;\n\tcase RATE_MATCH_NONE:\n\t\tmatched_caps = 0;\n\t\tbreak;\n\tcase RATE_MATCH_PAUSE: {\n\t\t \n\t\tif (!(mac_capabilities & MAC_SYM_PAUSE) ||\n\t\t    !(mac_capabilities & MAC_ASYM_PAUSE))\n\t\t\tbreak;\n\n\t\t \n\t\tif (mac_capabilities &\n\t\t    phylink_cap_from_speed_duplex(max_speed, DUPLEX_FULL)) {\n\t\t\t \n\t\t\tmatched_caps = GENMASK(__fls(caps), __fls(MAC_10HD));\n\t\t\tmatched_caps &= ~(MAC_1000HD | MAC_100HD | MAC_10HD);\n\t\t}\n\t\tbreak;\n\t}\n\tcase RATE_MATCH_CRS:\n\t\t \n\t\tif (mac_capabilities &\n\t\t    phylink_cap_from_speed_duplex(max_speed, DUPLEX_HALF)) {\n\t\t\tmatched_caps = GENMASK(__fls(caps), __fls(MAC_10HD));\n\t\t\tmatched_caps &= mac_capabilities;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn (caps & mac_capabilities) | matched_caps;\n}\nEXPORT_SYMBOL_GPL(phylink_get_capabilities);\n\n \nvoid phylink_validate_mask_caps(unsigned long *supported,\n\t\t\t\tstruct phylink_link_state *state,\n\t\t\t\tunsigned long mac_capabilities)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };\n\tunsigned long caps;\n\n\tphylink_set_port_modes(mask);\n\tphylink_set(mask, Autoneg);\n\tcaps = phylink_get_capabilities(state->interface, mac_capabilities,\n\t\t\t\t\tstate->rate_matching);\n\tphylink_caps_to_linkmodes(mask, caps);\n\n\tlinkmode_and(supported, supported, mask);\n\tlinkmode_and(state->advertising, state->advertising, mask);\n}\nEXPORT_SYMBOL_GPL(phylink_validate_mask_caps);\n\n \nvoid phylink_generic_validate(struct phylink_config *config,\n\t\t\t      unsigned long *supported,\n\t\t\t      struct phylink_link_state *state)\n{\n\tphylink_validate_mask_caps(supported, state, config->mac_capabilities);\n}\nEXPORT_SYMBOL_GPL(phylink_generic_validate);\n\nstatic int phylink_validate_mac_and_pcs(struct phylink *pl,\n\t\t\t\t\tunsigned long *supported,\n\t\t\t\t\tstruct phylink_link_state *state)\n{\n\tstruct phylink_pcs *pcs;\n\tint ret;\n\n\t \n\tif (pl->using_mac_select_pcs) {\n\t\tpcs = pl->mac_ops->mac_select_pcs(pl->config, state->interface);\n\t\tif (IS_ERR(pcs))\n\t\t\treturn PTR_ERR(pcs);\n\t} else {\n\t\tpcs = pl->pcs;\n\t}\n\n\tif (pcs) {\n\t\t \n\t\tif (!pcs->ops) {\n\t\t\tphylink_err(pl, \"interface %s: uninitialised PCS\\n\",\n\t\t\t\t    phy_modes(state->interface));\n\t\t\tdump_stack();\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (pcs->ops->pcs_validate) {\n\t\t\tret = pcs->ops->pcs_validate(pcs, supported, state);\n\t\t\tif (ret < 0 || phylink_is_empty_linkmode(supported))\n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\t\t\tlinkmode_and(state->advertising, state->advertising,\n\t\t\t\t     supported);\n\t\t}\n\t}\n\n\t \n\tif (pl->mac_ops->validate)\n\t\tpl->mac_ops->validate(pl->config, supported, state);\n\telse\n\t\tphylink_generic_validate(pl->config, supported, state);\n\n\treturn phylink_is_empty_linkmode(supported) ? -EINVAL : 0;\n}\n\nstatic int phylink_validate_mask(struct phylink *pl, unsigned long *supported,\n\t\t\t\t struct phylink_link_state *state,\n\t\t\t\t const unsigned long *interfaces)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(all_adv) = { 0, };\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(all_s) = { 0, };\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(s);\n\tstruct phylink_link_state t;\n\tint intf;\n\n\tfor (intf = 0; intf < PHY_INTERFACE_MODE_MAX; intf++) {\n\t\tif (test_bit(intf, interfaces)) {\n\t\t\tlinkmode_copy(s, supported);\n\n\t\t\tt = *state;\n\t\t\tt.interface = intf;\n\t\t\tif (!phylink_validate_mac_and_pcs(pl, s, &t)) {\n\t\t\t\tlinkmode_or(all_s, all_s, s);\n\t\t\t\tlinkmode_or(all_adv, all_adv, t.advertising);\n\t\t\t}\n\t\t}\n\t}\n\n\tlinkmode_copy(supported, all_s);\n\tlinkmode_copy(state->advertising, all_adv);\n\n\treturn phylink_is_empty_linkmode(supported) ? -EINVAL : 0;\n}\n\nstatic int phylink_validate(struct phylink *pl, unsigned long *supported,\n\t\t\t    struct phylink_link_state *state)\n{\n\tconst unsigned long *interfaces = pl->config->supported_interfaces;\n\n\tif (state->interface == PHY_INTERFACE_MODE_NA)\n\t\treturn phylink_validate_mask(pl, supported, state, interfaces);\n\n\tif (!test_bit(state->interface, interfaces))\n\t\treturn -EINVAL;\n\n\treturn phylink_validate_mac_and_pcs(pl, supported, state);\n}\n\nstatic int phylink_parse_fixedlink(struct phylink *pl,\n\t\t\t\t   const struct fwnode_handle *fwnode)\n{\n\tstruct fwnode_handle *fixed_node;\n\tbool pause, asym_pause, autoneg;\n\tconst struct phy_setting *s;\n\tstruct gpio_desc *desc;\n\tu32 speed;\n\tint ret;\n\n\tfixed_node = fwnode_get_named_child_node(fwnode, \"fixed-link\");\n\tif (fixed_node) {\n\t\tret = fwnode_property_read_u32(fixed_node, \"speed\", &speed);\n\n\t\tpl->link_config.speed = speed;\n\t\tpl->link_config.duplex = DUPLEX_HALF;\n\n\t\tif (fwnode_property_read_bool(fixed_node, \"full-duplex\"))\n\t\t\tpl->link_config.duplex = DUPLEX_FULL;\n\n\t\t \n\t\tif (fwnode_property_read_bool(fixed_node, \"pause\"))\n\t\t\t__set_bit(ETHTOOL_LINK_MODE_Pause_BIT,\n\t\t\t\t  pl->link_config.lp_advertising);\n\t\tif (fwnode_property_read_bool(fixed_node, \"asym-pause\"))\n\t\t\t__set_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,\n\t\t\t\t  pl->link_config.lp_advertising);\n\n\t\tif (ret == 0) {\n\t\t\tdesc = fwnode_gpiod_get_index(fixed_node, \"link\", 0,\n\t\t\t\t\t\t      GPIOD_IN, \"?\");\n\n\t\t\tif (!IS_ERR(desc))\n\t\t\t\tpl->link_gpio = desc;\n\t\t\telse if (desc == ERR_PTR(-EPROBE_DEFER))\n\t\t\t\tret = -EPROBE_DEFER;\n\t\t}\n\t\tfwnode_handle_put(fixed_node);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tu32 prop[5];\n\n\t\tret = fwnode_property_read_u32_array(fwnode, \"fixed-link\",\n\t\t\t\t\t\t     NULL, 0);\n\t\tif (ret != ARRAY_SIZE(prop)) {\n\t\t\tphylink_err(pl, \"broken fixed-link?\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = fwnode_property_read_u32_array(fwnode, \"fixed-link\",\n\t\t\t\t\t\t     prop, ARRAY_SIZE(prop));\n\t\tif (!ret) {\n\t\t\tpl->link_config.duplex = prop[1] ?\n\t\t\t\t\t\tDUPLEX_FULL : DUPLEX_HALF;\n\t\t\tpl->link_config.speed = prop[2];\n\t\t\tif (prop[3])\n\t\t\t\t__set_bit(ETHTOOL_LINK_MODE_Pause_BIT,\n\t\t\t\t\t  pl->link_config.lp_advertising);\n\t\t\tif (prop[4])\n\t\t\t\t__set_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,\n\t\t\t\t\t  pl->link_config.lp_advertising);\n\t\t}\n\t}\n\n\tif (pl->link_config.speed > SPEED_1000 &&\n\t    pl->link_config.duplex != DUPLEX_FULL)\n\t\tphylink_warn(pl, \"fixed link specifies half duplex for %dMbps link?\\n\",\n\t\t\t     pl->link_config.speed);\n\n\tbitmap_fill(pl->supported, __ETHTOOL_LINK_MODE_MASK_NBITS);\n\tlinkmode_copy(pl->link_config.advertising, pl->supported);\n\tphylink_validate(pl, pl->supported, &pl->link_config);\n\n\tpause = phylink_test(pl->supported, Pause);\n\tasym_pause = phylink_test(pl->supported, Asym_Pause);\n\tautoneg = phylink_test(pl->supported, Autoneg);\n\ts = phy_lookup_setting(pl->link_config.speed, pl->link_config.duplex,\n\t\t\t       pl->supported, true);\n\tlinkmode_zero(pl->supported);\n\tphylink_set(pl->supported, MII);\n\n\tif (pause)\n\t\tphylink_set(pl->supported, Pause);\n\n\tif (asym_pause)\n\t\tphylink_set(pl->supported, Asym_Pause);\n\n\tif (autoneg)\n\t\tphylink_set(pl->supported, Autoneg);\n\n\tif (s) {\n\t\t__set_bit(s->bit, pl->supported);\n\t\t__set_bit(s->bit, pl->link_config.lp_advertising);\n\t} else {\n\t\tphylink_warn(pl, \"fixed link %s duplex %dMbps not recognised\\n\",\n\t\t\t     pl->link_config.duplex == DUPLEX_FULL ? \"full\" : \"half\",\n\t\t\t     pl->link_config.speed);\n\t}\n\n\tlinkmode_and(pl->link_config.advertising, pl->link_config.advertising,\n\t\t     pl->supported);\n\n\tpl->link_config.link = 1;\n\tpl->link_config.an_complete = 1;\n\n\treturn 0;\n}\n\nstatic int phylink_parse_mode(struct phylink *pl,\n\t\t\t      const struct fwnode_handle *fwnode)\n{\n\tstruct fwnode_handle *dn;\n\tconst char *managed;\n\n\tdn = fwnode_get_named_child_node(fwnode, \"fixed-link\");\n\tif (dn || fwnode_property_present(fwnode, \"fixed-link\"))\n\t\tpl->cfg_link_an_mode = MLO_AN_FIXED;\n\tfwnode_handle_put(dn);\n\n\tif ((fwnode_property_read_string(fwnode, \"managed\", &managed) == 0 &&\n\t     strcmp(managed, \"in-band-status\") == 0) ||\n\t    pl->config->ovr_an_inband) {\n\t\tif (pl->cfg_link_an_mode == MLO_AN_FIXED) {\n\t\t\tphylink_err(pl,\n\t\t\t\t    \"can't use both fixed-link and in-band-status\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tlinkmode_zero(pl->supported);\n\t\tphylink_set(pl->supported, MII);\n\t\tphylink_set(pl->supported, Autoneg);\n\t\tphylink_set(pl->supported, Asym_Pause);\n\t\tphylink_set(pl->supported, Pause);\n\t\tpl->cfg_link_an_mode = MLO_AN_INBAND;\n\n\t\tswitch (pl->link_config.interface) {\n\t\tcase PHY_INTERFACE_MODE_SGMII:\n\t\tcase PHY_INTERFACE_MODE_PSGMII:\n\t\tcase PHY_INTERFACE_MODE_QSGMII:\n\t\tcase PHY_INTERFACE_MODE_QUSGMII:\n\t\tcase PHY_INTERFACE_MODE_RGMII:\n\t\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\t\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tcase PHY_INTERFACE_MODE_RTBI:\n\t\t\tphylink_set(pl->supported, 10baseT_Half);\n\t\t\tphylink_set(pl->supported, 10baseT_Full);\n\t\t\tphylink_set(pl->supported, 100baseT_Half);\n\t\t\tphylink_set(pl->supported, 100baseT_Full);\n\t\t\tphylink_set(pl->supported, 1000baseT_Half);\n\t\t\tphylink_set(pl->supported, 1000baseT_Full);\n\t\t\tbreak;\n\n\t\tcase PHY_INTERFACE_MODE_1000BASEX:\n\t\t\tphylink_set(pl->supported, 1000baseX_Full);\n\t\t\tbreak;\n\n\t\tcase PHY_INTERFACE_MODE_2500BASEX:\n\t\t\tphylink_set(pl->supported, 2500baseX_Full);\n\t\t\tbreak;\n\n\t\tcase PHY_INTERFACE_MODE_5GBASER:\n\t\t\tphylink_set(pl->supported, 5000baseT_Full);\n\t\t\tbreak;\n\n\t\tcase PHY_INTERFACE_MODE_25GBASER:\n\t\t\tphylink_set(pl->supported, 25000baseCR_Full);\n\t\t\tphylink_set(pl->supported, 25000baseKR_Full);\n\t\t\tphylink_set(pl->supported, 25000baseSR_Full);\n\t\t\tfallthrough;\n\t\tcase PHY_INTERFACE_MODE_USXGMII:\n\t\tcase PHY_INTERFACE_MODE_10GKR:\n\t\tcase PHY_INTERFACE_MODE_10GBASER:\n\t\t\tphylink_set(pl->supported, 10baseT_Half);\n\t\t\tphylink_set(pl->supported, 10baseT_Full);\n\t\t\tphylink_set(pl->supported, 100baseT_Half);\n\t\t\tphylink_set(pl->supported, 100baseT_Full);\n\t\t\tphylink_set(pl->supported, 1000baseT_Half);\n\t\t\tphylink_set(pl->supported, 1000baseT_Full);\n\t\t\tphylink_set(pl->supported, 1000baseX_Full);\n\t\t\tphylink_set(pl->supported, 1000baseKX_Full);\n\t\t\tphylink_set(pl->supported, 2500baseT_Full);\n\t\t\tphylink_set(pl->supported, 2500baseX_Full);\n\t\t\tphylink_set(pl->supported, 5000baseT_Full);\n\t\t\tphylink_set(pl->supported, 10000baseT_Full);\n\t\t\tphylink_set(pl->supported, 10000baseKR_Full);\n\t\t\tphylink_set(pl->supported, 10000baseKX4_Full);\n\t\t\tphylink_set(pl->supported, 10000baseCR_Full);\n\t\t\tphylink_set(pl->supported, 10000baseSR_Full);\n\t\t\tphylink_set(pl->supported, 10000baseLR_Full);\n\t\t\tphylink_set(pl->supported, 10000baseLRM_Full);\n\t\t\tphylink_set(pl->supported, 10000baseER_Full);\n\t\t\tbreak;\n\n\t\tcase PHY_INTERFACE_MODE_XLGMII:\n\t\t\tphylink_set(pl->supported, 25000baseCR_Full);\n\t\t\tphylink_set(pl->supported, 25000baseKR_Full);\n\t\t\tphylink_set(pl->supported, 25000baseSR_Full);\n\t\t\tphylink_set(pl->supported, 40000baseKR4_Full);\n\t\t\tphylink_set(pl->supported, 40000baseCR4_Full);\n\t\t\tphylink_set(pl->supported, 40000baseSR4_Full);\n\t\t\tphylink_set(pl->supported, 40000baseLR4_Full);\n\t\t\tphylink_set(pl->supported, 50000baseCR2_Full);\n\t\t\tphylink_set(pl->supported, 50000baseKR2_Full);\n\t\t\tphylink_set(pl->supported, 50000baseSR2_Full);\n\t\t\tphylink_set(pl->supported, 50000baseKR_Full);\n\t\t\tphylink_set(pl->supported, 50000baseSR_Full);\n\t\t\tphylink_set(pl->supported, 50000baseCR_Full);\n\t\t\tphylink_set(pl->supported, 50000baseLR_ER_FR_Full);\n\t\t\tphylink_set(pl->supported, 50000baseDR_Full);\n\t\t\tphylink_set(pl->supported, 100000baseKR4_Full);\n\t\t\tphylink_set(pl->supported, 100000baseSR4_Full);\n\t\t\tphylink_set(pl->supported, 100000baseCR4_Full);\n\t\t\tphylink_set(pl->supported, 100000baseLR4_ER4_Full);\n\t\t\tphylink_set(pl->supported, 100000baseKR2_Full);\n\t\t\tphylink_set(pl->supported, 100000baseSR2_Full);\n\t\t\tphylink_set(pl->supported, 100000baseCR2_Full);\n\t\t\tphylink_set(pl->supported, 100000baseLR2_ER2_FR2_Full);\n\t\t\tphylink_set(pl->supported, 100000baseDR2_Full);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tphylink_err(pl,\n\t\t\t\t    \"incorrect link mode %s for in-band status\\n\",\n\t\t\t\t    phy_modes(pl->link_config.interface));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tlinkmode_copy(pl->link_config.advertising, pl->supported);\n\n\t\tif (phylink_validate(pl, pl->supported, &pl->link_config)) {\n\t\t\tphylink_err(pl,\n\t\t\t\t    \"failed to validate link configuration for in-band status\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void phylink_apply_manual_flow(struct phylink *pl,\n\t\t\t\t      struct phylink_link_state *state)\n{\n\t \n\tif (!linkmode_test_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,\n\t\t\t       state->advertising))\n\t\tstate->pause &= ~MLO_PAUSE_AN;\n\n\t \n\tif (!(pl->link_config.pause & MLO_PAUSE_AN))\n\t\tstate->pause = pl->link_config.pause;\n}\n\nstatic void phylink_resolve_an_pause(struct phylink_link_state *state)\n{\n\tbool tx_pause, rx_pause;\n\n\tif (state->duplex == DUPLEX_FULL) {\n\t\tlinkmode_resolve_pause(state->advertising,\n\t\t\t\t       state->lp_advertising,\n\t\t\t\t       &tx_pause, &rx_pause);\n\t\tif (tx_pause)\n\t\t\tstate->pause |= MLO_PAUSE_TX;\n\t\tif (rx_pause)\n\t\t\tstate->pause |= MLO_PAUSE_RX;\n\t}\n}\n\nstatic void phylink_pcs_pre_config(struct phylink_pcs *pcs,\n\t\t\t\t   phy_interface_t interface)\n{\n\tif (pcs && pcs->ops->pcs_pre_config)\n\t\tpcs->ops->pcs_pre_config(pcs, interface);\n}\n\nstatic int phylink_pcs_post_config(struct phylink_pcs *pcs,\n\t\t\t\t   phy_interface_t interface)\n{\n\tint err = 0;\n\n\tif (pcs && pcs->ops->pcs_post_config)\n\t\terr = pcs->ops->pcs_post_config(pcs, interface);\n\n\treturn err;\n}\n\nstatic void phylink_pcs_disable(struct phylink_pcs *pcs)\n{\n\tif (pcs && pcs->ops->pcs_disable)\n\t\tpcs->ops->pcs_disable(pcs);\n}\n\nstatic int phylink_pcs_enable(struct phylink_pcs *pcs)\n{\n\tint err = 0;\n\n\tif (pcs && pcs->ops->pcs_enable)\n\t\terr = pcs->ops->pcs_enable(pcs);\n\n\treturn err;\n}\n\nstatic int phylink_pcs_config(struct phylink_pcs *pcs, unsigned int neg_mode,\n\t\t\t      const struct phylink_link_state *state,\n\t\t\t      bool permit_pause_to_mac)\n{\n\tif (!pcs)\n\t\treturn 0;\n\n\treturn pcs->ops->pcs_config(pcs, neg_mode, state->interface,\n\t\t\t\t    state->advertising, permit_pause_to_mac);\n}\n\nstatic void phylink_pcs_link_up(struct phylink_pcs *pcs, unsigned int neg_mode,\n\t\t\t\tphy_interface_t interface, int speed,\n\t\t\t\tint duplex)\n{\n\tif (pcs && pcs->ops->pcs_link_up)\n\t\tpcs->ops->pcs_link_up(pcs, neg_mode, interface, speed, duplex);\n}\n\nstatic void phylink_pcs_poll_stop(struct phylink *pl)\n{\n\tif (pl->cfg_link_an_mode == MLO_AN_INBAND)\n\t\tdel_timer(&pl->link_poll);\n}\n\nstatic void phylink_pcs_poll_start(struct phylink *pl)\n{\n\tif (pl->pcs && pl->pcs->poll && pl->cfg_link_an_mode == MLO_AN_INBAND)\n\t\tmod_timer(&pl->link_poll, jiffies + HZ);\n}\n\nstatic void phylink_mac_config(struct phylink *pl,\n\t\t\t       const struct phylink_link_state *state)\n{\n\tstruct phylink_link_state st = *state;\n\n\t \n\tlinkmode_zero(st.lp_advertising);\n\tst.speed = SPEED_UNKNOWN;\n\tst.duplex = DUPLEX_UNKNOWN;\n\tst.an_complete = false;\n\tst.link = false;\n\n\tphylink_dbg(pl,\n\t\t    \"%s: mode=%s/%s/%s adv=%*pb pause=%02x\\n\",\n\t\t    __func__, phylink_an_mode_str(pl->cur_link_an_mode),\n\t\t    phy_modes(st.interface),\n\t\t    phy_rate_matching_to_str(st.rate_matching),\n\t\t    __ETHTOOL_LINK_MODE_MASK_NBITS, st.advertising,\n\t\t    st.pause);\n\n\tpl->mac_ops->mac_config(pl->config, pl->cur_link_an_mode, &st);\n}\n\nstatic void phylink_pcs_an_restart(struct phylink *pl)\n{\n\tif (pl->pcs && linkmode_test_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,\n\t\t\t\t\t pl->link_config.advertising) &&\n\t    phy_interface_mode_is_8023z(pl->link_config.interface) &&\n\t    phylink_autoneg_inband(pl->cur_link_an_mode))\n\t\tpl->pcs->ops->pcs_an_restart(pl->pcs);\n}\n\nstatic void phylink_major_config(struct phylink *pl, bool restart,\n\t\t\t\t  const struct phylink_link_state *state)\n{\n\tstruct phylink_pcs *pcs = NULL;\n\tbool pcs_changed = false;\n\tunsigned int rate_kbd;\n\tunsigned int neg_mode;\n\tint err;\n\n\tphylink_dbg(pl, \"major config %s\\n\", phy_modes(state->interface));\n\n\tpl->pcs_neg_mode = phylink_pcs_neg_mode(pl->cur_link_an_mode,\n\t\t\t\t\t\tstate->interface,\n\t\t\t\t\t\tstate->advertising);\n\n\tif (pl->using_mac_select_pcs) {\n\t\tpcs = pl->mac_ops->mac_select_pcs(pl->config, state->interface);\n\t\tif (IS_ERR(pcs)) {\n\t\t\tphylink_err(pl,\n\t\t\t\t    \"mac_select_pcs unexpectedly failed: %pe\\n\",\n\t\t\t\t    pcs);\n\t\t\treturn;\n\t\t}\n\n\t\tpcs_changed = pcs && pl->pcs != pcs;\n\t}\n\n\tphylink_pcs_poll_stop(pl);\n\n\tif (pl->mac_ops->mac_prepare) {\n\t\terr = pl->mac_ops->mac_prepare(pl->config, pl->cur_link_an_mode,\n\t\t\t\t\t       state->interface);\n\t\tif (err < 0) {\n\t\t\tphylink_err(pl, \"mac_prepare failed: %pe\\n\",\n\t\t\t\t    ERR_PTR(err));\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tif (pcs_changed) {\n\t\tphylink_pcs_disable(pl->pcs);\n\n\t\tif (pl->pcs)\n\t\t\tpl->pcs->phylink = NULL;\n\n\t\tpcs->phylink = pl;\n\n\t\tpl->pcs = pcs;\n\t}\n\n\tif (pl->pcs)\n\t\tphylink_pcs_pre_config(pl->pcs, state->interface);\n\n\tphylink_mac_config(pl, state);\n\n\tif (pl->pcs)\n\t\tphylink_pcs_post_config(pl->pcs, state->interface);\n\n\tif (pl->pcs_state == PCS_STATE_STARTING || pcs_changed)\n\t\tphylink_pcs_enable(pl->pcs);\n\n\tneg_mode = pl->cur_link_an_mode;\n\tif (pl->pcs && pl->pcs->neg_mode)\n\t\tneg_mode = pl->pcs_neg_mode;\n\n\terr = phylink_pcs_config(pl->pcs, neg_mode, state,\n\t\t\t\t !!(pl->link_config.pause & MLO_PAUSE_AN));\n\tif (err < 0)\n\t\tphylink_err(pl, \"pcs_config failed: %pe\\n\",\n\t\t\t    ERR_PTR(err));\n\telse if (err > 0)\n\t\trestart = true;\n\n\tif (restart)\n\t\tphylink_pcs_an_restart(pl);\n\n\tif (pl->mac_ops->mac_finish) {\n\t\terr = pl->mac_ops->mac_finish(pl->config, pl->cur_link_an_mode,\n\t\t\t\t\t      state->interface);\n\t\tif (err < 0)\n\t\t\tphylink_err(pl, \"mac_finish failed: %pe\\n\",\n\t\t\t\t    ERR_PTR(err));\n\t}\n\n\tif (pl->sfp_bus) {\n\t\trate_kbd = phylink_interface_signal_rate(state->interface);\n\t\tif (rate_kbd)\n\t\t\tsfp_upstream_set_signal_rate(pl->sfp_bus, rate_kbd);\n\t}\n\n\tphylink_pcs_poll_start(pl);\n}\n\n \nstatic int phylink_change_inband_advert(struct phylink *pl)\n{\n\tunsigned int neg_mode;\n\tint ret;\n\n\tif (test_bit(PHYLINK_DISABLE_STOPPED, &pl->phylink_disable_state))\n\t\treturn 0;\n\n\tphylink_dbg(pl, \"%s: mode=%s/%s adv=%*pb pause=%02x\\n\", __func__,\n\t\t    phylink_an_mode_str(pl->cur_link_an_mode),\n\t\t    phy_modes(pl->link_config.interface),\n\t\t    __ETHTOOL_LINK_MODE_MASK_NBITS, pl->link_config.advertising,\n\t\t    pl->link_config.pause);\n\n\t \n\tpl->pcs_neg_mode = phylink_pcs_neg_mode(pl->cur_link_an_mode,\n\t\t\t\t\tpl->link_config.interface,\n\t\t\t\t\tpl->link_config.advertising);\n\n\tneg_mode = pl->cur_link_an_mode;\n\tif (pl->pcs->neg_mode)\n\t\tneg_mode = pl->pcs_neg_mode;\n\n\t \n\tret = phylink_pcs_config(pl->pcs, neg_mode, &pl->link_config,\n\t\t\t\t !!(pl->link_config.pause & MLO_PAUSE_AN));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret > 0)\n\t\tphylink_pcs_an_restart(pl);\n\n\treturn 0;\n}\n\nstatic void phylink_mac_pcs_get_state(struct phylink *pl,\n\t\t\t\t      struct phylink_link_state *state)\n{\n\tlinkmode_copy(state->advertising, pl->link_config.advertising);\n\tlinkmode_zero(state->lp_advertising);\n\tstate->interface = pl->link_config.interface;\n\tstate->rate_matching = pl->link_config.rate_matching;\n\tif (linkmode_test_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,\n\t\t\t      state->advertising)) {\n\t\tstate->speed = SPEED_UNKNOWN;\n\t\tstate->duplex = DUPLEX_UNKNOWN;\n\t\tstate->pause = MLO_PAUSE_NONE;\n\t} else {\n\t\tstate->speed =  pl->link_config.speed;\n\t\tstate->duplex = pl->link_config.duplex;\n\t\tstate->pause = pl->link_config.pause;\n\t}\n\tstate->an_complete = 0;\n\tstate->link = 1;\n\n\tif (pl->pcs)\n\t\tpl->pcs->ops->pcs_get_state(pl->pcs, state);\n\telse\n\t\tstate->link = 0;\n}\n\n \nstatic void phylink_get_fixed_state(struct phylink *pl,\n\t\t\t\t    struct phylink_link_state *state)\n{\n\t*state = pl->link_config;\n\tif (pl->config->get_fixed_state)\n\t\tpl->config->get_fixed_state(pl->config, state);\n\telse if (pl->link_gpio)\n\t\tstate->link = !!gpiod_get_value_cansleep(pl->link_gpio);\n\n\tstate->pause = MLO_PAUSE_NONE;\n\tphylink_resolve_an_pause(state);\n}\n\nstatic void phylink_mac_initial_config(struct phylink *pl, bool force_restart)\n{\n\tstruct phylink_link_state link_state;\n\n\tswitch (pl->cur_link_an_mode) {\n\tcase MLO_AN_PHY:\n\t\tlink_state = pl->phy_state;\n\t\tbreak;\n\n\tcase MLO_AN_FIXED:\n\t\tphylink_get_fixed_state(pl, &link_state);\n\t\tbreak;\n\n\tcase MLO_AN_INBAND:\n\t\tlink_state = pl->link_config;\n\t\tif (link_state.interface == PHY_INTERFACE_MODE_SGMII)\n\t\t\tlink_state.pause = MLO_PAUSE_NONE;\n\t\tbreak;\n\n\tdefault:  \n\t\treturn;\n\t}\n\n\tlink_state.link = false;\n\n\tphylink_apply_manual_flow(pl, &link_state);\n\tphylink_major_config(pl, force_restart, &link_state);\n}\n\nstatic const char *phylink_pause_to_str(int pause)\n{\n\tswitch (pause & MLO_PAUSE_TXRX_MASK) {\n\tcase MLO_PAUSE_TX | MLO_PAUSE_RX:\n\t\treturn \"rx/tx\";\n\tcase MLO_PAUSE_TX:\n\t\treturn \"tx\";\n\tcase MLO_PAUSE_RX:\n\t\treturn \"rx\";\n\tdefault:\n\t\treturn \"off\";\n\t}\n}\n\nstatic void phylink_link_up(struct phylink *pl,\n\t\t\t    struct phylink_link_state link_state)\n{\n\tstruct net_device *ndev = pl->netdev;\n\tunsigned int neg_mode;\n\tint speed, duplex;\n\tbool rx_pause;\n\n\tspeed = link_state.speed;\n\tduplex = link_state.duplex;\n\trx_pause = !!(link_state.pause & MLO_PAUSE_RX);\n\n\tswitch (link_state.rate_matching) {\n\tcase RATE_MATCH_PAUSE:\n\t\t \n\t\tspeed = phylink_interface_max_speed(link_state.interface);\n\t\tduplex = DUPLEX_FULL;\n\t\trx_pause = true;\n\t\tbreak;\n\n\tcase RATE_MATCH_CRS:\n\t\t \n\t\tspeed = phylink_interface_max_speed(link_state.interface);\n\t\tduplex = DUPLEX_HALF;\n\t\tbreak;\n\t}\n\n\tpl->cur_interface = link_state.interface;\n\n\tneg_mode = pl->cur_link_an_mode;\n\tif (pl->pcs && pl->pcs->neg_mode)\n\t\tneg_mode = pl->pcs_neg_mode;\n\n\tphylink_pcs_link_up(pl->pcs, neg_mode, pl->cur_interface, speed,\n\t\t\t    duplex);\n\n\tpl->mac_ops->mac_link_up(pl->config, pl->phydev, pl->cur_link_an_mode,\n\t\t\t\t pl->cur_interface, speed, duplex,\n\t\t\t\t !!(link_state.pause & MLO_PAUSE_TX), rx_pause);\n\n\tif (ndev)\n\t\tnetif_carrier_on(ndev);\n\n\tphylink_info(pl,\n\t\t     \"Link is Up - %s/%s - flow control %s\\n\",\n\t\t     phy_speed_to_str(link_state.speed),\n\t\t     phy_duplex_to_str(link_state.duplex),\n\t\t     phylink_pause_to_str(link_state.pause));\n}\n\nstatic void phylink_link_down(struct phylink *pl)\n{\n\tstruct net_device *ndev = pl->netdev;\n\n\tif (ndev)\n\t\tnetif_carrier_off(ndev);\n\tpl->mac_ops->mac_link_down(pl->config, pl->cur_link_an_mode,\n\t\t\t\t   pl->cur_interface);\n\tphylink_info(pl, \"Link is Down\\n\");\n}\n\nstatic void phylink_resolve(struct work_struct *w)\n{\n\tstruct phylink *pl = container_of(w, struct phylink, resolve);\n\tstruct phylink_link_state link_state;\n\tstruct net_device *ndev = pl->netdev;\n\tbool mac_config = false;\n\tbool retrigger = false;\n\tbool cur_link_state;\n\n\tmutex_lock(&pl->state_mutex);\n\tif (pl->netdev)\n\t\tcur_link_state = netif_carrier_ok(ndev);\n\telse\n\t\tcur_link_state = pl->old_link_state;\n\n\tif (pl->phylink_disable_state) {\n\t\tpl->mac_link_dropped = false;\n\t\tlink_state.link = false;\n\t} else if (pl->mac_link_dropped) {\n\t\tlink_state.link = false;\n\t\tretrigger = true;\n\t} else {\n\t\tswitch (pl->cur_link_an_mode) {\n\t\tcase MLO_AN_PHY:\n\t\t\tlink_state = pl->phy_state;\n\t\t\tphylink_apply_manual_flow(pl, &link_state);\n\t\t\tmac_config = link_state.link;\n\t\t\tbreak;\n\n\t\tcase MLO_AN_FIXED:\n\t\t\tphylink_get_fixed_state(pl, &link_state);\n\t\t\tmac_config = link_state.link;\n\t\t\tbreak;\n\n\t\tcase MLO_AN_INBAND:\n\t\t\tphylink_mac_pcs_get_state(pl, &link_state);\n\n\t\t\t \n\t\t\tif (!link_state.link) {\n\t\t\t\tif (cur_link_state)\n\t\t\t\t\tretrigger = true;\n\t\t\t\telse\n\t\t\t\t\tphylink_mac_pcs_get_state(pl,\n\t\t\t\t\t\t\t\t  &link_state);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (pl->phydev)\n\t\t\t\tlink_state.link &= pl->phy_state.link;\n\n\t\t\t \n\t\t\tif (pl->phydev && pl->phy_state.link) {\n\t\t\t\t \n\t\t\t\tif (link_state.interface !=\n\t\t\t\t    pl->phy_state.interface) {\n\t\t\t\t\tretrigger = true;\n\t\t\t\t\tlink_state.link = false;\n\t\t\t\t}\n\t\t\t\tlink_state.interface = pl->phy_state.interface;\n\n\t\t\t\t \n\t\t\t\tif (pl->phy_state.rate_matching) {\n\t\t\t\t\tlink_state.rate_matching =\n\t\t\t\t\t\tpl->phy_state.rate_matching;\n\t\t\t\t\tlink_state.speed = pl->phy_state.speed;\n\t\t\t\t\tlink_state.duplex =\n\t\t\t\t\t\tpl->phy_state.duplex;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tlink_state.pause = pl->phy_state.pause;\n\t\t\t\tmac_config = true;\n\t\t\t}\n\t\t\tphylink_apply_manual_flow(pl, &link_state);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (mac_config) {\n\t\tif (link_state.interface != pl->link_config.interface) {\n\t\t\t \n\t\t\tif (cur_link_state) {\n\t\t\t\tphylink_link_down(pl);\n\t\t\t\tcur_link_state = false;\n\t\t\t}\n\t\t\tphylink_major_config(pl, false, &link_state);\n\t\t\tpl->link_config.interface = link_state.interface;\n\t\t}\n\t}\n\n\tif (link_state.link != cur_link_state) {\n\t\tpl->old_link_state = link_state.link;\n\t\tif (!link_state.link)\n\t\t\tphylink_link_down(pl);\n\t\telse\n\t\t\tphylink_link_up(pl, link_state);\n\t}\n\tif (!link_state.link && retrigger) {\n\t\tpl->mac_link_dropped = false;\n\t\tqueue_work(system_power_efficient_wq, &pl->resolve);\n\t}\n\tmutex_unlock(&pl->state_mutex);\n}\n\nstatic void phylink_run_resolve(struct phylink *pl)\n{\n\tif (!pl->phylink_disable_state)\n\t\tqueue_work(system_power_efficient_wq, &pl->resolve);\n}\n\nstatic void phylink_run_resolve_and_disable(struct phylink *pl, int bit)\n{\n\tunsigned long state = pl->phylink_disable_state;\n\n\tset_bit(bit, &pl->phylink_disable_state);\n\tif (state == 0) {\n\t\tqueue_work(system_power_efficient_wq, &pl->resolve);\n\t\tflush_work(&pl->resolve);\n\t}\n}\n\nstatic void phylink_enable_and_run_resolve(struct phylink *pl, int bit)\n{\n\tclear_bit(bit, &pl->phylink_disable_state);\n\tphylink_run_resolve(pl);\n}\n\nstatic void phylink_fixed_poll(struct timer_list *t)\n{\n\tstruct phylink *pl = container_of(t, struct phylink, link_poll);\n\n\tmod_timer(t, jiffies + HZ);\n\n\tphylink_run_resolve(pl);\n}\n\nstatic const struct sfp_upstream_ops sfp_phylink_ops;\n\nstatic int phylink_register_sfp(struct phylink *pl,\n\t\t\t\tconst struct fwnode_handle *fwnode)\n{\n\tstruct sfp_bus *bus;\n\tint ret;\n\n\tif (!fwnode)\n\t\treturn 0;\n\n\tbus = sfp_bus_find_fwnode(fwnode);\n\tif (IS_ERR(bus)) {\n\t\tphylink_err(pl, \"unable to attach SFP bus: %pe\\n\", bus);\n\t\treturn PTR_ERR(bus);\n\t}\n\n\tpl->sfp_bus = bus;\n\n\tret = sfp_bus_add_upstream(bus, pl, &sfp_phylink_ops);\n\tsfp_bus_put(bus);\n\n\treturn ret;\n}\n\n \nstruct phylink *phylink_create(struct phylink_config *config,\n\t\t\t       const struct fwnode_handle *fwnode,\n\t\t\t       phy_interface_t iface,\n\t\t\t       const struct phylink_mac_ops *mac_ops)\n{\n\tbool using_mac_select_pcs = false;\n\tstruct phylink *pl;\n\tint ret;\n\n\t \n\tif (phy_interface_empty(config->supported_interfaces)) {\n\t\tdev_err(config->dev,\n\t\t\t\"phylink: error: empty supported_interfaces\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (mac_ops->mac_select_pcs &&\n\t    mac_ops->mac_select_pcs(config, PHY_INTERFACE_MODE_NA) !=\n\t      ERR_PTR(-EOPNOTSUPP))\n\t\tusing_mac_select_pcs = true;\n\n\tpl = kzalloc(sizeof(*pl), GFP_KERNEL);\n\tif (!pl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&pl->state_mutex);\n\tINIT_WORK(&pl->resolve, phylink_resolve);\n\n\tpl->config = config;\n\tif (config->type == PHYLINK_NETDEV) {\n\t\tpl->netdev = to_net_dev(config->dev);\n\t\tnetif_carrier_off(pl->netdev);\n\t} else if (config->type == PHYLINK_DEV) {\n\t\tpl->dev = config->dev;\n\t} else {\n\t\tkfree(pl);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tpl->using_mac_select_pcs = using_mac_select_pcs;\n\tpl->phy_state.interface = iface;\n\tpl->link_interface = iface;\n\tif (iface == PHY_INTERFACE_MODE_MOCA)\n\t\tpl->link_port = PORT_BNC;\n\telse\n\t\tpl->link_port = PORT_MII;\n\tpl->link_config.interface = iface;\n\tpl->link_config.pause = MLO_PAUSE_AN;\n\tpl->link_config.speed = SPEED_UNKNOWN;\n\tpl->link_config.duplex = DUPLEX_UNKNOWN;\n\tpl->pcs_state = PCS_STATE_DOWN;\n\tpl->mac_ops = mac_ops;\n\t__set_bit(PHYLINK_DISABLE_STOPPED, &pl->phylink_disable_state);\n\ttimer_setup(&pl->link_poll, phylink_fixed_poll, 0);\n\n\tbitmap_fill(pl->supported, __ETHTOOL_LINK_MODE_MASK_NBITS);\n\tlinkmode_copy(pl->link_config.advertising, pl->supported);\n\tphylink_validate(pl, pl->supported, &pl->link_config);\n\n\tret = phylink_parse_mode(pl, fwnode);\n\tif (ret < 0) {\n\t\tkfree(pl);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tif (pl->cfg_link_an_mode == MLO_AN_FIXED) {\n\t\tret = phylink_parse_fixedlink(pl, fwnode);\n\t\tif (ret < 0) {\n\t\t\tkfree(pl);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\n\tpl->cur_link_an_mode = pl->cfg_link_an_mode;\n\n\tret = phylink_register_sfp(pl, fwnode);\n\tif (ret < 0) {\n\t\tkfree(pl);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn pl;\n}\nEXPORT_SYMBOL_GPL(phylink_create);\n\n \nvoid phylink_destroy(struct phylink *pl)\n{\n\tsfp_bus_del_upstream(pl->sfp_bus);\n\tif (pl->link_gpio)\n\t\tgpiod_put(pl->link_gpio);\n\n\tcancel_work_sync(&pl->resolve);\n\tkfree(pl);\n}\nEXPORT_SYMBOL_GPL(phylink_destroy);\n\n \nbool phylink_expects_phy(struct phylink *pl)\n{\n\tif (pl->cfg_link_an_mode == MLO_AN_FIXED ||\n\t    (pl->cfg_link_an_mode == MLO_AN_INBAND &&\n\t     phy_interface_mode_is_8023z(pl->link_config.interface)))\n\t\treturn false;\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(phylink_expects_phy);\n\nstatic void phylink_phy_change(struct phy_device *phydev, bool up)\n{\n\tstruct phylink *pl = phydev->phylink;\n\tbool tx_pause, rx_pause;\n\n\tphy_get_pause(phydev, &tx_pause, &rx_pause);\n\n\tmutex_lock(&pl->state_mutex);\n\tpl->phy_state.speed = phydev->speed;\n\tpl->phy_state.duplex = phydev->duplex;\n\tpl->phy_state.rate_matching = phydev->rate_matching;\n\tpl->phy_state.pause = MLO_PAUSE_NONE;\n\tif (tx_pause)\n\t\tpl->phy_state.pause |= MLO_PAUSE_TX;\n\tif (rx_pause)\n\t\tpl->phy_state.pause |= MLO_PAUSE_RX;\n\tpl->phy_state.interface = phydev->interface;\n\tpl->phy_state.link = up;\n\tmutex_unlock(&pl->state_mutex);\n\n\tphylink_run_resolve(pl);\n\n\tphylink_dbg(pl, \"phy link %s %s/%s/%s/%s/%s\\n\", up ? \"up\" : \"down\",\n\t\t    phy_modes(phydev->interface),\n\t\t    phy_speed_to_str(phydev->speed),\n\t\t    phy_duplex_to_str(phydev->duplex),\n\t\t    phy_rate_matching_to_str(phydev->rate_matching),\n\t\t    phylink_pause_to_str(pl->phy_state.pause));\n}\n\nstatic int phylink_bringup_phy(struct phylink *pl, struct phy_device *phy,\n\t\t\t       phy_interface_t interface)\n{\n\tstruct phylink_link_state config;\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(supported);\n\tchar *irq_str;\n\tint ret;\n\n\t \n\tphy_support_asym_pause(phy);\n\n\tmemset(&config, 0, sizeof(config));\n\tlinkmode_copy(supported, phy->supported);\n\tlinkmode_copy(config.advertising, phy->advertising);\n\n\t \n\tconfig.rate_matching = phy_get_rate_matching(phy, interface);\n\n\t \n\tif (phy->is_c45 && config.rate_matching == RATE_MATCH_NONE &&\n\t    interface != PHY_INTERFACE_MODE_RXAUI &&\n\t    interface != PHY_INTERFACE_MODE_XAUI &&\n\t    interface != PHY_INTERFACE_MODE_USXGMII)\n\t\tconfig.interface = PHY_INTERFACE_MODE_NA;\n\telse\n\t\tconfig.interface = interface;\n\n\tret = phylink_validate(pl, supported, &config);\n\tif (ret) {\n\t\tphylink_warn(pl, \"validation of %s with support %*pb and advertisement %*pb failed: %pe\\n\",\n\t\t\t     phy_modes(config.interface),\n\t\t\t     __ETHTOOL_LINK_MODE_MASK_NBITS, phy->supported,\n\t\t\t     __ETHTOOL_LINK_MODE_MASK_NBITS, config.advertising,\n\t\t\t     ERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\tphy->phylink = pl;\n\tphy->phy_link_change = phylink_phy_change;\n\n\tirq_str = phy_attached_info_irq(phy);\n\tphylink_info(pl,\n\t\t     \"PHY [%s] driver [%s] (irq=%s)\\n\",\n\t\t     dev_name(&phy->mdio.dev), phy->drv->name, irq_str);\n\tkfree(irq_str);\n\n\tmutex_lock(&phy->lock);\n\tmutex_lock(&pl->state_mutex);\n\tpl->phydev = phy;\n\tpl->phy_state.interface = interface;\n\tpl->phy_state.pause = MLO_PAUSE_NONE;\n\tpl->phy_state.speed = SPEED_UNKNOWN;\n\tpl->phy_state.duplex = DUPLEX_UNKNOWN;\n\tpl->phy_state.rate_matching = RATE_MATCH_NONE;\n\tlinkmode_copy(pl->supported, supported);\n\tlinkmode_copy(pl->link_config.advertising, config.advertising);\n\n\t \n\tlinkmode_copy(phy->advertising, config.advertising);\n\tmutex_unlock(&pl->state_mutex);\n\tmutex_unlock(&phy->lock);\n\n\tphylink_dbg(pl,\n\t\t    \"phy: %s setting supported %*pb advertising %*pb\\n\",\n\t\t    phy_modes(interface),\n\t\t    __ETHTOOL_LINK_MODE_MASK_NBITS, pl->supported,\n\t\t    __ETHTOOL_LINK_MODE_MASK_NBITS, phy->advertising);\n\n\tif (phy_interrupt_is_valid(phy))\n\t\tphy_request_interrupt(phy);\n\n\tif (pl->config->mac_managed_pm)\n\t\tphy->mac_managed_pm = true;\n\n\treturn 0;\n}\n\nstatic int phylink_attach_phy(struct phylink *pl, struct phy_device *phy,\n\t\t\t      phy_interface_t interface)\n{\n\tif (WARN_ON(pl->cfg_link_an_mode == MLO_AN_FIXED ||\n\t\t    (pl->cfg_link_an_mode == MLO_AN_INBAND &&\n\t\t     phy_interface_mode_is_8023z(interface) && !pl->sfp_bus)))\n\t\treturn -EINVAL;\n\n\tif (pl->phydev)\n\t\treturn -EBUSY;\n\n\treturn phy_attach_direct(pl->netdev, phy, 0, interface);\n}\n\n \nint phylink_connect_phy(struct phylink *pl, struct phy_device *phy)\n{\n\tint ret;\n\n\t \n\tif (pl->link_interface == PHY_INTERFACE_MODE_NA) {\n\t\tpl->link_interface = phy->interface;\n\t\tpl->link_config.interface = pl->link_interface;\n\t}\n\n\tret = phylink_attach_phy(pl, phy, pl->link_interface);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = phylink_bringup_phy(pl, phy, pl->link_config.interface);\n\tif (ret)\n\t\tphy_detach(phy);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phylink_connect_phy);\n\n \nint phylink_of_phy_connect(struct phylink *pl, struct device_node *dn,\n\t\t\t   u32 flags)\n{\n\treturn phylink_fwnode_phy_connect(pl, of_fwnode_handle(dn), flags);\n}\nEXPORT_SYMBOL_GPL(phylink_of_phy_connect);\n\n \nint phylink_fwnode_phy_connect(struct phylink *pl,\n\t\t\t       const struct fwnode_handle *fwnode,\n\t\t\t       u32 flags)\n{\n\tstruct fwnode_handle *phy_fwnode;\n\tstruct phy_device *phy_dev;\n\tint ret;\n\n\t \n\tif (pl->cfg_link_an_mode == MLO_AN_FIXED ||\n\t    (pl->cfg_link_an_mode == MLO_AN_INBAND &&\n\t     phy_interface_mode_is_8023z(pl->link_interface)))\n\t\treturn 0;\n\n\tphy_fwnode = fwnode_get_phy_node(fwnode);\n\tif (IS_ERR(phy_fwnode)) {\n\t\tif (pl->cfg_link_an_mode == MLO_AN_PHY)\n\t\t\treturn -ENODEV;\n\t\treturn 0;\n\t}\n\n\tphy_dev = fwnode_phy_find_device(phy_fwnode);\n\t \n\tfwnode_handle_put(phy_fwnode);\n\tif (!phy_dev)\n\t\treturn -ENODEV;\n\n\t \n\tif (pl->link_interface == PHY_INTERFACE_MODE_NA) {\n\t\tpl->link_interface = phy_dev->interface;\n\t\tpl->link_config.interface = pl->link_interface;\n\t}\n\n\tret = phy_attach_direct(pl->netdev, phy_dev, flags,\n\t\t\t\tpl->link_interface);\n\tphy_device_free(phy_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = phylink_bringup_phy(pl, phy_dev, pl->link_config.interface);\n\tif (ret)\n\t\tphy_detach(phy_dev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phylink_fwnode_phy_connect);\n\n \nvoid phylink_disconnect_phy(struct phylink *pl)\n{\n\tstruct phy_device *phy;\n\n\tASSERT_RTNL();\n\n\tphy = pl->phydev;\n\tif (phy) {\n\t\tmutex_lock(&phy->lock);\n\t\tmutex_lock(&pl->state_mutex);\n\t\tpl->phydev = NULL;\n\t\tmutex_unlock(&pl->state_mutex);\n\t\tmutex_unlock(&phy->lock);\n\t\tflush_work(&pl->resolve);\n\n\t\tphy_disconnect(phy);\n\t}\n}\nEXPORT_SYMBOL_GPL(phylink_disconnect_phy);\n\nstatic void phylink_link_changed(struct phylink *pl, bool up, const char *what)\n{\n\tif (!up)\n\t\tpl->mac_link_dropped = true;\n\tphylink_run_resolve(pl);\n\tphylink_dbg(pl, \"%s link %s\\n\", what, up ? \"up\" : \"down\");\n}\n\n \nvoid phylink_mac_change(struct phylink *pl, bool up)\n{\n\tphylink_link_changed(pl, up, \"mac\");\n}\nEXPORT_SYMBOL_GPL(phylink_mac_change);\n\n \nvoid phylink_pcs_change(struct phylink_pcs *pcs, bool up)\n{\n\tstruct phylink *pl = pcs->phylink;\n\n\tif (pl)\n\t\tphylink_link_changed(pl, up, \"pcs\");\n}\nEXPORT_SYMBOL_GPL(phylink_pcs_change);\n\nstatic irqreturn_t phylink_link_handler(int irq, void *data)\n{\n\tstruct phylink *pl = data;\n\n\tphylink_run_resolve(pl);\n\n\treturn IRQ_HANDLED;\n}\n\n \nvoid phylink_start(struct phylink *pl)\n{\n\tbool poll = false;\n\n\tASSERT_RTNL();\n\n\tphylink_info(pl, \"configuring for %s/%s link mode\\n\",\n\t\t     phylink_an_mode_str(pl->cur_link_an_mode),\n\t\t     phy_modes(pl->link_config.interface));\n\n\t \n\tif (pl->netdev)\n\t\tnetif_carrier_off(pl->netdev);\n\n\tpl->pcs_state = PCS_STATE_STARTING;\n\n\t \n\tphylink_mac_initial_config(pl, true);\n\n\tpl->pcs_state = PCS_STATE_STARTED;\n\n\tphylink_enable_and_run_resolve(pl, PHYLINK_DISABLE_STOPPED);\n\n\tif (pl->cfg_link_an_mode == MLO_AN_FIXED && pl->link_gpio) {\n\t\tint irq = gpiod_to_irq(pl->link_gpio);\n\n\t\tif (irq > 0) {\n\t\t\tif (!request_irq(irq, phylink_link_handler,\n\t\t\t\t\t IRQF_TRIGGER_RISING |\n\t\t\t\t\t IRQF_TRIGGER_FALLING,\n\t\t\t\t\t \"netdev link\", pl))\n\t\t\t\tpl->link_irq = irq;\n\t\t\telse\n\t\t\t\tirq = 0;\n\t\t}\n\t\tif (irq <= 0)\n\t\t\tpoll = true;\n\t}\n\n\tif (pl->cfg_link_an_mode == MLO_AN_FIXED)\n\t\tpoll |= pl->config->poll_fixed_state;\n\n\tif (poll)\n\t\tmod_timer(&pl->link_poll, jiffies + HZ);\n\tif (pl->phydev)\n\t\tphy_start(pl->phydev);\n\tif (pl->sfp_bus)\n\t\tsfp_upstream_start(pl->sfp_bus);\n}\nEXPORT_SYMBOL_GPL(phylink_start);\n\n \nvoid phylink_stop(struct phylink *pl)\n{\n\tASSERT_RTNL();\n\n\tif (pl->sfp_bus)\n\t\tsfp_upstream_stop(pl->sfp_bus);\n\tif (pl->phydev)\n\t\tphy_stop(pl->phydev);\n\tdel_timer_sync(&pl->link_poll);\n\tif (pl->link_irq) {\n\t\tfree_irq(pl->link_irq, pl);\n\t\tpl->link_irq = 0;\n\t}\n\n\tphylink_run_resolve_and_disable(pl, PHYLINK_DISABLE_STOPPED);\n\n\tpl->pcs_state = PCS_STATE_DOWN;\n\n\tphylink_pcs_disable(pl->pcs);\n}\nEXPORT_SYMBOL_GPL(phylink_stop);\n\n \nvoid phylink_suspend(struct phylink *pl, bool mac_wol)\n{\n\tASSERT_RTNL();\n\n\tif (mac_wol && (!pl->netdev || pl->netdev->wol_enabled)) {\n\t\t \n\t\tmutex_lock(&pl->state_mutex);\n\n\t\t \n\t\t__set_bit(PHYLINK_DISABLE_MAC_WOL, &pl->phylink_disable_state);\n\n\t\t \n\t\tif (pl->netdev)\n\t\t\tnetif_carrier_off(pl->netdev);\n\t\telse\n\t\t\tpl->old_link_state = false;\n\n\t\t \n\t\tmutex_unlock(&pl->state_mutex);\n\t} else {\n\t\tphylink_stop(pl);\n\t}\n}\nEXPORT_SYMBOL_GPL(phylink_suspend);\n\n \nvoid phylink_resume(struct phylink *pl)\n{\n\tASSERT_RTNL();\n\n\tif (test_bit(PHYLINK_DISABLE_MAC_WOL, &pl->phylink_disable_state)) {\n\t\t \n\n\t\t \n\t\tmutex_lock(&pl->state_mutex);\n\t\tphylink_link_down(pl);\n\t\tmutex_unlock(&pl->state_mutex);\n\n\t\t \n\t\tphylink_mac_initial_config(pl, true);\n\n\t\t \n\t\tphylink_enable_and_run_resolve(pl, PHYLINK_DISABLE_MAC_WOL);\n\t} else {\n\t\tphylink_start(pl);\n\t}\n}\nEXPORT_SYMBOL_GPL(phylink_resume);\n\n \nvoid phylink_ethtool_get_wol(struct phylink *pl, struct ethtool_wolinfo *wol)\n{\n\tASSERT_RTNL();\n\n\twol->supported = 0;\n\twol->wolopts = 0;\n\n\tif (pl->phydev)\n\t\tphy_ethtool_get_wol(pl->phydev, wol);\n}\nEXPORT_SYMBOL_GPL(phylink_ethtool_get_wol);\n\n \nint phylink_ethtool_set_wol(struct phylink *pl, struct ethtool_wolinfo *wol)\n{\n\tint ret = -EOPNOTSUPP;\n\n\tASSERT_RTNL();\n\n\tif (pl->phydev)\n\t\tret = phy_ethtool_set_wol(pl->phydev, wol);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phylink_ethtool_set_wol);\n\nstatic void phylink_merge_link_mode(unsigned long *dst, const unsigned long *b)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(mask);\n\n\tlinkmode_zero(mask);\n\tphylink_set_port_modes(mask);\n\n\tlinkmode_and(dst, dst, mask);\n\tlinkmode_or(dst, dst, b);\n}\n\nstatic void phylink_get_ksettings(const struct phylink_link_state *state,\n\t\t\t\t  struct ethtool_link_ksettings *kset)\n{\n\tphylink_merge_link_mode(kset->link_modes.advertising, state->advertising);\n\tlinkmode_copy(kset->link_modes.lp_advertising, state->lp_advertising);\n\tif (kset->base.rate_matching == RATE_MATCH_NONE) {\n\t\tkset->base.speed = state->speed;\n\t\tkset->base.duplex = state->duplex;\n\t}\n\tkset->base.autoneg = linkmode_test_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,\n\t\t\t\t\t       state->advertising) ?\n\t\t\t\tAUTONEG_ENABLE : AUTONEG_DISABLE;\n}\n\n \nint phylink_ethtool_ksettings_get(struct phylink *pl,\n\t\t\t\t  struct ethtool_link_ksettings *kset)\n{\n\tstruct phylink_link_state link_state;\n\n\tASSERT_RTNL();\n\n\tif (pl->phydev)\n\t\tphy_ethtool_ksettings_get(pl->phydev, kset);\n\telse\n\t\tkset->base.port = pl->link_port;\n\n\tlinkmode_copy(kset->link_modes.supported, pl->supported);\n\n\tswitch (pl->cur_link_an_mode) {\n\tcase MLO_AN_FIXED:\n\t\t \n\t\tphylink_get_fixed_state(pl, &link_state);\n\t\tphylink_get_ksettings(&link_state, kset);\n\t\tbreak;\n\n\tcase MLO_AN_INBAND:\n\t\t \n\t\tif (pl->phydev)\n\t\t\tbreak;\n\n\t\tphylink_mac_pcs_get_state(pl, &link_state);\n\n\t\t \n\t\tphylink_get_ksettings(&link_state, kset);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(phylink_ethtool_ksettings_get);\n\n \nint phylink_ethtool_ksettings_set(struct phylink *pl,\n\t\t\t\t  const struct ethtool_link_ksettings *kset)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(support);\n\tstruct phylink_link_state config;\n\tconst struct phy_setting *s;\n\n\tASSERT_RTNL();\n\n\tif (pl->phydev) {\n\t\tstruct ethtool_link_ksettings phy_kset = *kset;\n\n\t\tlinkmode_and(phy_kset.link_modes.advertising,\n\t\t\t     phy_kset.link_modes.advertising,\n\t\t\t     pl->supported);\n\n\t\t \n\t\treturn phy_ethtool_ksettings_set(pl->phydev, &phy_kset);\n\t}\n\n\tconfig = pl->link_config;\n\t \n\tlinkmode_and(config.advertising, kset->link_modes.advertising,\n\t\t     pl->supported);\n\n\t \n\tswitch (kset->base.autoneg) {\n\tcase AUTONEG_DISABLE:\n\t\t \n\t\ts = phy_lookup_setting(kset->base.speed, kset->base.duplex,\n\t\t\t\t       pl->supported, false);\n\t\tif (!s)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (pl->cur_link_an_mode == MLO_AN_FIXED) {\n\t\t\tif (s->speed != pl->link_config.speed ||\n\t\t\t    s->duplex != pl->link_config.duplex)\n\t\t\t\treturn -EINVAL;\n\t\t\treturn 0;\n\t\t}\n\n\t\tconfig.speed = s->speed;\n\t\tconfig.duplex = s->duplex;\n\t\tbreak;\n\n\tcase AUTONEG_ENABLE:\n\t\t \n\t\tif (pl->cur_link_an_mode == MLO_AN_FIXED) {\n\t\t\tif (!linkmode_equal(config.advertising,\n\t\t\t\t\t    pl->link_config.advertising))\n\t\t\t\treturn -EINVAL;\n\t\t\treturn 0;\n\t\t}\n\n\t\tconfig.speed = SPEED_UNKNOWN;\n\t\tconfig.duplex = DUPLEX_UNKNOWN;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, config.advertising,\n\t\t\t kset->base.autoneg == AUTONEG_ENABLE);\n\n\t \n\tif (pl->sfp_bus) {\n\t\tconfig.interface = sfp_select_interface(pl->sfp_bus,\n\t\t\t\t\t\t\tconfig.advertising);\n\t\tif (config.interface == PHY_INTERFACE_MODE_NA) {\n\t\t\tphylink_err(pl,\n\t\t\t\t    \"selection of interface failed, advertisement %*pb\\n\",\n\t\t\t\t    __ETHTOOL_LINK_MODE_MASK_NBITS,\n\t\t\t\t    config.advertising);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tlinkmode_copy(support, pl->supported);\n\t\tif (phylink_validate(pl, support, &config)) {\n\t\t\tphylink_err(pl, \"validation of %s/%s with support %*pb failed\\n\",\n\t\t\t\t    phylink_an_mode_str(pl->cur_link_an_mode),\n\t\t\t\t    phy_modes(config.interface),\n\t\t\t\t    __ETHTOOL_LINK_MODE_MASK_NBITS, support);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t \n\t\tlinkmode_copy(support, pl->supported);\n\t\tif (phylink_validate(pl, support, &config))\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (linkmode_test_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,\n\t\t\t      config.advertising) &&\n\t    phylink_is_empty_linkmode(config.advertising))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&pl->state_mutex);\n\tpl->link_config.speed = config.speed;\n\tpl->link_config.duplex = config.duplex;\n\n\tif (pl->link_config.interface != config.interface) {\n\t\t \n\t\t \n\t\tif (pl->old_link_state) {\n\t\t\tphylink_link_down(pl);\n\t\t\tpl->old_link_state = false;\n\t\t}\n\t\tif (!test_bit(PHYLINK_DISABLE_STOPPED,\n\t\t\t      &pl->phylink_disable_state))\n\t\t\tphylink_major_config(pl, false, &config);\n\t\tpl->link_config.interface = config.interface;\n\t\tlinkmode_copy(pl->link_config.advertising, config.advertising);\n\t} else if (!linkmode_equal(pl->link_config.advertising,\n\t\t\t\t   config.advertising)) {\n\t\tlinkmode_copy(pl->link_config.advertising, config.advertising);\n\t\tphylink_change_inband_advert(pl);\n\t}\n\tmutex_unlock(&pl->state_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(phylink_ethtool_ksettings_set);\n\n \nint phylink_ethtool_nway_reset(struct phylink *pl)\n{\n\tint ret = 0;\n\n\tASSERT_RTNL();\n\n\tif (pl->phydev)\n\t\tret = phy_restart_aneg(pl->phydev);\n\tphylink_pcs_an_restart(pl);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phylink_ethtool_nway_reset);\n\n \nvoid phylink_ethtool_get_pauseparam(struct phylink *pl,\n\t\t\t\t    struct ethtool_pauseparam *pause)\n{\n\tASSERT_RTNL();\n\n\tpause->autoneg = !!(pl->link_config.pause & MLO_PAUSE_AN);\n\tpause->rx_pause = !!(pl->link_config.pause & MLO_PAUSE_RX);\n\tpause->tx_pause = !!(pl->link_config.pause & MLO_PAUSE_TX);\n}\nEXPORT_SYMBOL_GPL(phylink_ethtool_get_pauseparam);\n\n \nint phylink_ethtool_set_pauseparam(struct phylink *pl,\n\t\t\t\t   struct ethtool_pauseparam *pause)\n{\n\tstruct phylink_link_state *config = &pl->link_config;\n\tbool manual_changed;\n\tint pause_state;\n\n\tASSERT_RTNL();\n\n\tif (pl->cur_link_an_mode == MLO_AN_FIXED)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!phylink_test(pl->supported, Pause) &&\n\t    !phylink_test(pl->supported, Asym_Pause))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!phylink_test(pl->supported, Asym_Pause) &&\n\t    pause->rx_pause != pause->tx_pause)\n\t\treturn -EINVAL;\n\n\tpause_state = 0;\n\tif (pause->autoneg)\n\t\tpause_state |= MLO_PAUSE_AN;\n\tif (pause->rx_pause)\n\t\tpause_state |= MLO_PAUSE_RX;\n\tif (pause->tx_pause)\n\t\tpause_state |= MLO_PAUSE_TX;\n\n\tmutex_lock(&pl->state_mutex);\n\t \n\tlinkmode_set_pause(config->advertising, pause->tx_pause,\n\t\t\t   pause->rx_pause);\n\n\tmanual_changed = (config->pause ^ pause_state) & MLO_PAUSE_AN ||\n\t\t\t (!(pause_state & MLO_PAUSE_AN) &&\n\t\t\t   (config->pause ^ pause_state) & MLO_PAUSE_TXRX_MASK);\n\n\tconfig->pause = pause_state;\n\n\t \n\tif (!pl->phydev)\n\t\tphylink_change_inband_advert(pl);\n\n\tmutex_unlock(&pl->state_mutex);\n\n\t \n\tif (pl->phydev)\n\t\tphy_set_asym_pause(pl->phydev, pause->rx_pause,\n\t\t\t\t   pause->tx_pause);\n\n\t \n\tif (manual_changed) {\n\t\tpl->mac_link_dropped = true;\n\t\tphylink_run_resolve(pl);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(phylink_ethtool_set_pauseparam);\n\n \nint phylink_get_eee_err(struct phylink *pl)\n{\n\tint ret = 0;\n\n\tASSERT_RTNL();\n\n\tif (pl->phydev)\n\t\tret = phy_get_eee_err(pl->phydev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phylink_get_eee_err);\n\n \nint phylink_init_eee(struct phylink *pl, bool clk_stop_enable)\n{\n\tint ret = -EOPNOTSUPP;\n\n\tif (pl->phydev)\n\t\tret = phy_init_eee(pl->phydev, clk_stop_enable);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phylink_init_eee);\n\n \nint phylink_ethtool_get_eee(struct phylink *pl, struct ethtool_eee *eee)\n{\n\tint ret = -EOPNOTSUPP;\n\n\tASSERT_RTNL();\n\n\tif (pl->phydev)\n\t\tret = phy_ethtool_get_eee(pl->phydev, eee);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phylink_ethtool_get_eee);\n\n \nint phylink_ethtool_set_eee(struct phylink *pl, struct ethtool_eee *eee)\n{\n\tint ret = -EOPNOTSUPP;\n\n\tASSERT_RTNL();\n\n\tif (pl->phydev)\n\t\tret = phy_ethtool_set_eee(pl->phydev, eee);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phylink_ethtool_set_eee);\n\n \nstatic int phylink_mii_emul_read(unsigned int reg,\n\t\t\t\t struct phylink_link_state *state)\n{\n\tstruct fixed_phy_status fs;\n\tunsigned long *lpa = state->lp_advertising;\n\tint val;\n\n\tfs.link = state->link;\n\tfs.speed = state->speed;\n\tfs.duplex = state->duplex;\n\tfs.pause = test_bit(ETHTOOL_LINK_MODE_Pause_BIT, lpa);\n\tfs.asym_pause = test_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, lpa);\n\n\tval = swphy_read_reg(reg, &fs);\n\tif (reg == MII_BMSR) {\n\t\tif (!state->an_complete)\n\t\t\tval &= ~BMSR_ANEGCOMPLETE;\n\t}\n\treturn val;\n}\n\nstatic int phylink_phy_read(struct phylink *pl, unsigned int phy_id,\n\t\t\t    unsigned int reg)\n{\n\tstruct phy_device *phydev = pl->phydev;\n\tint prtad, devad;\n\n\tif (mdio_phy_id_is_c45(phy_id)) {\n\t\tprtad = mdio_phy_id_prtad(phy_id);\n\t\tdevad = mdio_phy_id_devad(phy_id);\n\t\treturn mdiobus_c45_read(pl->phydev->mdio.bus, prtad, devad,\n\t\t\t\t\treg);\n\t}\n\n\tif (phydev->is_c45) {\n\t\tswitch (reg) {\n\t\tcase MII_BMCR:\n\t\tcase MII_BMSR:\n\t\tcase MII_PHYSID1:\n\t\tcase MII_PHYSID2:\n\t\t\tdevad = __ffs(phydev->c45_ids.mmds_present);\n\t\t\tbreak;\n\t\tcase MII_ADVERTISE:\n\t\tcase MII_LPA:\n\t\t\tif (!(phydev->c45_ids.mmds_present & MDIO_DEVS_AN))\n\t\t\t\treturn -EINVAL;\n\t\t\tdevad = MDIO_MMD_AN;\n\t\t\tif (reg == MII_ADVERTISE)\n\t\t\t\treg = MDIO_AN_ADVERTISE;\n\t\t\telse\n\t\t\t\treg = MDIO_AN_LPA;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tprtad = phy_id;\n\t\treturn mdiobus_c45_read(pl->phydev->mdio.bus, prtad, devad,\n\t\t\t\t\treg);\n\t}\n\n\treturn mdiobus_read(pl->phydev->mdio.bus, phy_id, reg);\n}\n\nstatic int phylink_phy_write(struct phylink *pl, unsigned int phy_id,\n\t\t\t     unsigned int reg, unsigned int val)\n{\n\tstruct phy_device *phydev = pl->phydev;\n\tint prtad, devad;\n\n\tif (mdio_phy_id_is_c45(phy_id)) {\n\t\tprtad = mdio_phy_id_prtad(phy_id);\n\t\tdevad = mdio_phy_id_devad(phy_id);\n\t\treturn mdiobus_c45_write(pl->phydev->mdio.bus, prtad, devad,\n\t\t\t\t\t reg, val);\n\t}\n\n\tif (phydev->is_c45) {\n\t\tswitch (reg) {\n\t\tcase MII_BMCR:\n\t\tcase MII_BMSR:\n\t\tcase MII_PHYSID1:\n\t\tcase MII_PHYSID2:\n\t\t\tdevad = __ffs(phydev->c45_ids.mmds_present);\n\t\t\tbreak;\n\t\tcase MII_ADVERTISE:\n\t\tcase MII_LPA:\n\t\t\tif (!(phydev->c45_ids.mmds_present & MDIO_DEVS_AN))\n\t\t\t\treturn -EINVAL;\n\t\t\tdevad = MDIO_MMD_AN;\n\t\t\tif (reg == MII_ADVERTISE)\n\t\t\t\treg = MDIO_AN_ADVERTISE;\n\t\t\telse\n\t\t\t\treg = MDIO_AN_LPA;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn mdiobus_c45_write(pl->phydev->mdio.bus, phy_id, devad,\n\t\t\t\t\t reg, val);\n\t}\n\n\treturn mdiobus_write(phydev->mdio.bus, phy_id, reg, val);\n}\n\nstatic int phylink_mii_read(struct phylink *pl, unsigned int phy_id,\n\t\t\t    unsigned int reg)\n{\n\tstruct phylink_link_state state;\n\tint val = 0xffff;\n\n\tswitch (pl->cur_link_an_mode) {\n\tcase MLO_AN_FIXED:\n\t\tif (phy_id == 0) {\n\t\t\tphylink_get_fixed_state(pl, &state);\n\t\t\tval = phylink_mii_emul_read(reg, &state);\n\t\t}\n\t\tbreak;\n\n\tcase MLO_AN_PHY:\n\t\treturn -EOPNOTSUPP;\n\n\tcase MLO_AN_INBAND:\n\t\tif (phy_id == 0) {\n\t\t\tphylink_mac_pcs_get_state(pl, &state);\n\t\t\tval = phylink_mii_emul_read(reg, &state);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn val & 0xffff;\n}\n\nstatic int phylink_mii_write(struct phylink *pl, unsigned int phy_id,\n\t\t\t     unsigned int reg, unsigned int val)\n{\n\tswitch (pl->cur_link_an_mode) {\n\tcase MLO_AN_FIXED:\n\t\tbreak;\n\n\tcase MLO_AN_PHY:\n\t\treturn -EOPNOTSUPP;\n\n\tcase MLO_AN_INBAND:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nint phylink_mii_ioctl(struct phylink *pl, struct ifreq *ifr, int cmd)\n{\n\tstruct mii_ioctl_data *mii = if_mii(ifr);\n\tint  ret;\n\n\tASSERT_RTNL();\n\n\tif (pl->phydev) {\n\t\t \n\t\tswitch (cmd) {\n\t\tcase SIOCGMIIPHY:\n\t\t\tmii->phy_id = pl->phydev->mdio.addr;\n\t\t\tfallthrough;\n\n\t\tcase SIOCGMIIREG:\n\t\t\tret = phylink_phy_read(pl, mii->phy_id, mii->reg_num);\n\t\t\tif (ret >= 0) {\n\t\t\t\tmii->val_out = ret;\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SIOCSMIIREG:\n\t\t\tret = phylink_phy_write(pl, mii->phy_id, mii->reg_num,\n\t\t\t\t\t\tmii->val_in);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tret = phy_mii_ioctl(pl->phydev, ifr, cmd);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (cmd) {\n\t\tcase SIOCGMIIPHY:\n\t\t\tmii->phy_id = 0;\n\t\t\tfallthrough;\n\n\t\tcase SIOCGMIIREG:\n\t\t\tret = phylink_mii_read(pl, mii->phy_id, mii->reg_num);\n\t\t\tif (ret >= 0) {\n\t\t\t\tmii->val_out = ret;\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SIOCSMIIREG:\n\t\t\tret = phylink_mii_write(pl, mii->phy_id, mii->reg_num,\n\t\t\t\t\t\tmii->val_in);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phylink_mii_ioctl);\n\n \nint phylink_speed_down(struct phylink *pl, bool sync)\n{\n\tint ret = 0;\n\n\tASSERT_RTNL();\n\n\tif (!pl->sfp_bus && pl->phydev)\n\t\tret = phy_speed_down(pl->phydev, sync);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phylink_speed_down);\n\n \nint phylink_speed_up(struct phylink *pl)\n{\n\tint ret = 0;\n\n\tASSERT_RTNL();\n\n\tif (!pl->sfp_bus && pl->phydev)\n\t\tret = phy_speed_up(pl->phydev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phylink_speed_up);\n\nstatic void phylink_sfp_attach(void *upstream, struct sfp_bus *bus)\n{\n\tstruct phylink *pl = upstream;\n\n\tpl->netdev->sfp_bus = bus;\n}\n\nstatic void phylink_sfp_detach(void *upstream, struct sfp_bus *bus)\n{\n\tstruct phylink *pl = upstream;\n\n\tpl->netdev->sfp_bus = NULL;\n}\n\nstatic const phy_interface_t phylink_sfp_interface_preference[] = {\n\tPHY_INTERFACE_MODE_25GBASER,\n\tPHY_INTERFACE_MODE_USXGMII,\n\tPHY_INTERFACE_MODE_10GBASER,\n\tPHY_INTERFACE_MODE_5GBASER,\n\tPHY_INTERFACE_MODE_2500BASEX,\n\tPHY_INTERFACE_MODE_SGMII,\n\tPHY_INTERFACE_MODE_1000BASEX,\n\tPHY_INTERFACE_MODE_100BASEX,\n};\n\nstatic DECLARE_PHY_INTERFACE_MASK(phylink_sfp_interfaces);\n\nstatic phy_interface_t phylink_choose_sfp_interface(struct phylink *pl,\n\t\t\t\t\t\t    const unsigned long *intf)\n{\n\tphy_interface_t interface;\n\tsize_t i;\n\n\tinterface = PHY_INTERFACE_MODE_NA;\n\tfor (i = 0; i < ARRAY_SIZE(phylink_sfp_interface_preference); i++)\n\t\tif (test_bit(phylink_sfp_interface_preference[i], intf)) {\n\t\t\tinterface = phylink_sfp_interface_preference[i];\n\t\t\tbreak;\n\t\t}\n\n\treturn interface;\n}\n\nstatic void phylink_sfp_set_config(struct phylink *pl, u8 mode,\n\t\t\t\t   unsigned long *supported,\n\t\t\t\t   struct phylink_link_state *state)\n{\n\tbool changed = false;\n\n\tphylink_dbg(pl, \"requesting link mode %s/%s with support %*pb\\n\",\n\t\t    phylink_an_mode_str(mode), phy_modes(state->interface),\n\t\t    __ETHTOOL_LINK_MODE_MASK_NBITS, supported);\n\n\tif (!linkmode_equal(pl->supported, supported)) {\n\t\tlinkmode_copy(pl->supported, supported);\n\t\tchanged = true;\n\t}\n\n\tif (!linkmode_equal(pl->link_config.advertising, state->advertising)) {\n\t\tlinkmode_copy(pl->link_config.advertising, state->advertising);\n\t\tchanged = true;\n\t}\n\n\tif (pl->cur_link_an_mode != mode ||\n\t    pl->link_config.interface != state->interface) {\n\t\tpl->cur_link_an_mode = mode;\n\t\tpl->link_config.interface = state->interface;\n\n\t\tchanged = true;\n\n\t\tphylink_info(pl, \"switched to %s/%s link mode\\n\",\n\t\t\t     phylink_an_mode_str(mode),\n\t\t\t     phy_modes(state->interface));\n\t}\n\n\tif (changed && !test_bit(PHYLINK_DISABLE_STOPPED,\n\t\t\t\t &pl->phylink_disable_state))\n\t\tphylink_mac_initial_config(pl, false);\n}\n\nstatic int phylink_sfp_config_phy(struct phylink *pl, u8 mode,\n\t\t\t\t  struct phy_device *phy)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(support1);\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(support);\n\tstruct phylink_link_state config;\n\tphy_interface_t iface;\n\tint ret;\n\n\tlinkmode_copy(support, phy->supported);\n\n\tmemset(&config, 0, sizeof(config));\n\tlinkmode_copy(config.advertising, phy->advertising);\n\tconfig.interface = PHY_INTERFACE_MODE_NA;\n\tconfig.speed = SPEED_UNKNOWN;\n\tconfig.duplex = DUPLEX_UNKNOWN;\n\tconfig.pause = MLO_PAUSE_AN;\n\n\t \n\tret = phylink_validate(pl, support, &config);\n\tif (ret) {\n\t\tphylink_err(pl, \"validation with support %*pb failed: %pe\\n\",\n\t\t\t    __ETHTOOL_LINK_MODE_MASK_NBITS, support,\n\t\t\t    ERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\tiface = sfp_select_interface(pl->sfp_bus, config.advertising);\n\tif (iface == PHY_INTERFACE_MODE_NA) {\n\t\tphylink_err(pl,\n\t\t\t    \"selection of interface failed, advertisement %*pb\\n\",\n\t\t\t    __ETHTOOL_LINK_MODE_MASK_NBITS, config.advertising);\n\t\treturn -EINVAL;\n\t}\n\n\tconfig.interface = iface;\n\tlinkmode_copy(support1, support);\n\tret = phylink_validate(pl, support1, &config);\n\tif (ret) {\n\t\tphylink_err(pl,\n\t\t\t    \"validation of %s/%s with support %*pb failed: %pe\\n\",\n\t\t\t    phylink_an_mode_str(mode),\n\t\t\t    phy_modes(config.interface),\n\t\t\t    __ETHTOOL_LINK_MODE_MASK_NBITS, support,\n\t\t\t    ERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\tpl->link_port = pl->sfp_port;\n\n\tphylink_sfp_set_config(pl, mode, support, &config);\n\n\treturn 0;\n}\n\nstatic int phylink_sfp_config_optical(struct phylink *pl)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(support);\n\tDECLARE_PHY_INTERFACE_MASK(interfaces);\n\tstruct phylink_link_state config;\n\tphy_interface_t interface;\n\tint ret;\n\n\tphylink_dbg(pl, \"optical SFP: interfaces=[mac=%*pbl, sfp=%*pbl]\\n\",\n\t\t    (int)PHY_INTERFACE_MODE_MAX,\n\t\t    pl->config->supported_interfaces,\n\t\t    (int)PHY_INTERFACE_MODE_MAX,\n\t\t    pl->sfp_interfaces);\n\n\t \n\tphy_interface_and(interfaces, pl->config->supported_interfaces,\n\t\t\t  pl->sfp_interfaces);\n\tif (phy_interface_empty(interfaces)) {\n\t\tphylink_err(pl, \"unsupported SFP module: no common interface modes\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&config, 0, sizeof(config));\n\tlinkmode_copy(support, pl->sfp_support);\n\tlinkmode_copy(config.advertising, pl->sfp_support);\n\tconfig.speed = SPEED_UNKNOWN;\n\tconfig.duplex = DUPLEX_UNKNOWN;\n\tconfig.pause = MLO_PAUSE_AN;\n\n\t \n\tret = phylink_validate_mask(pl, pl->sfp_support, &config, interfaces);\n\tif (ret) {\n\t\tphylink_err(pl, \"unsupported SFP module: validation with support %*pb failed\\n\",\n\t\t\t    __ETHTOOL_LINK_MODE_MASK_NBITS, support);\n\t\treturn ret;\n\t}\n\n\tinterface = phylink_choose_sfp_interface(pl, interfaces);\n\tif (interface == PHY_INTERFACE_MODE_NA) {\n\t\tphylink_err(pl, \"failed to select SFP interface\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tphylink_dbg(pl, \"optical SFP: chosen %s interface\\n\",\n\t\t    phy_modes(interface));\n\n\tconfig.interface = interface;\n\n\t \n\tret = phylink_validate(pl, support, &config);\n\tif (ret) {\n\t\tphylink_err(pl, \"validation with support %*pb failed: %pe\\n\",\n\t\t\t    __ETHTOOL_LINK_MODE_MASK_NBITS, support,\n\t\t\t    ERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\tpl->link_port = pl->sfp_port;\n\n\tphylink_sfp_set_config(pl, MLO_AN_INBAND, pl->sfp_support, &config);\n\n\treturn 0;\n}\n\nstatic int phylink_sfp_module_insert(void *upstream,\n\t\t\t\t     const struct sfp_eeprom_id *id)\n{\n\tstruct phylink *pl = upstream;\n\n\tASSERT_RTNL();\n\n\tlinkmode_zero(pl->sfp_support);\n\tphy_interface_zero(pl->sfp_interfaces);\n\tsfp_parse_support(pl->sfp_bus, id, pl->sfp_support, pl->sfp_interfaces);\n\tpl->sfp_port = sfp_parse_port(pl->sfp_bus, id, pl->sfp_support);\n\n\t \n\tpl->sfp_may_have_phy = sfp_may_have_phy(pl->sfp_bus, id);\n\tif (pl->sfp_may_have_phy)\n\t\treturn 0;\n\n\treturn phylink_sfp_config_optical(pl);\n}\n\nstatic int phylink_sfp_module_start(void *upstream)\n{\n\tstruct phylink *pl = upstream;\n\n\t \n\tif (pl->phydev) {\n\t\tphy_start(pl->phydev);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!pl->sfp_may_have_phy)\n\t\treturn 0;\n\n\treturn phylink_sfp_config_optical(pl);\n}\n\nstatic void phylink_sfp_module_stop(void *upstream)\n{\n\tstruct phylink *pl = upstream;\n\n\t \n\tif (pl->phydev)\n\t\tphy_stop(pl->phydev);\n}\n\nstatic void phylink_sfp_link_down(void *upstream)\n{\n\tstruct phylink *pl = upstream;\n\n\tASSERT_RTNL();\n\n\tphylink_run_resolve_and_disable(pl, PHYLINK_DISABLE_LINK);\n}\n\nstatic void phylink_sfp_link_up(void *upstream)\n{\n\tstruct phylink *pl = upstream;\n\n\tASSERT_RTNL();\n\n\tphylink_enable_and_run_resolve(pl, PHYLINK_DISABLE_LINK);\n}\n\n \nstatic bool phylink_phy_no_inband(struct phy_device *phy)\n{\n\treturn phy->is_c45 && phy_id_compare(phy->c45_ids.device_ids[1],\n\t\t\t\t\t     0xae025150, 0xfffffff0);\n}\n\nstatic int phylink_sfp_connect_phy(void *upstream, struct phy_device *phy)\n{\n\tstruct phylink *pl = upstream;\n\tphy_interface_t interface;\n\tu8 mode;\n\tint ret;\n\n\t \n\tphy_support_asym_pause(phy);\n\n\tif (phylink_phy_no_inband(phy))\n\t\tmode = MLO_AN_PHY;\n\telse\n\t\tmode = MLO_AN_INBAND;\n\n\t \n\tphy_interface_and(phy->host_interfaces, phylink_sfp_interfaces,\n\t\t\t  pl->config->supported_interfaces);\n\n\t \n\tret = phylink_sfp_config_phy(pl, mode, phy);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tinterface = pl->link_config.interface;\n\tret = phylink_attach_phy(pl, phy, interface);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = phylink_bringup_phy(pl, phy, interface);\n\tif (ret)\n\t\tphy_detach(phy);\n\n\treturn ret;\n}\n\nstatic void phylink_sfp_disconnect_phy(void *upstream)\n{\n\tphylink_disconnect_phy(upstream);\n}\n\nstatic const struct sfp_upstream_ops sfp_phylink_ops = {\n\t.attach = phylink_sfp_attach,\n\t.detach = phylink_sfp_detach,\n\t.module_insert = phylink_sfp_module_insert,\n\t.module_start = phylink_sfp_module_start,\n\t.module_stop = phylink_sfp_module_stop,\n\t.link_up = phylink_sfp_link_up,\n\t.link_down = phylink_sfp_link_down,\n\t.connect_phy = phylink_sfp_connect_phy,\n\t.disconnect_phy = phylink_sfp_disconnect_phy,\n};\n\n \n\nstatic struct {\n\tint bit;\n\tint speed;\n} phylink_c73_priority_resolution[] = {\n\t{ ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT, SPEED_100000 },\n\t{ ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT, SPEED_100000 },\n\t \n\t{ ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT, SPEED_40000 },\n\t{ ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT, SPEED_40000 },\n\t{ ETHTOOL_LINK_MODE_10000baseKR_Full_BIT, SPEED_10000 },\n\t{ ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT, SPEED_10000 },\n\t \n\t{ ETHTOOL_LINK_MODE_2500baseX_Full_BIT, SPEED_2500 },\n\t{ ETHTOOL_LINK_MODE_1000baseKX_Full_BIT, SPEED_1000 },\n};\n\nvoid phylink_resolve_c73(struct phylink_link_state *state)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(phylink_c73_priority_resolution); i++) {\n\t\tint bit = phylink_c73_priority_resolution[i].bit;\n\t\tif (linkmode_test_bit(bit, state->advertising) &&\n\t\t    linkmode_test_bit(bit, state->lp_advertising))\n\t\t\tbreak;\n\t}\n\n\tif (i < ARRAY_SIZE(phylink_c73_priority_resolution)) {\n\t\tstate->speed = phylink_c73_priority_resolution[i].speed;\n\t\tstate->duplex = DUPLEX_FULL;\n\t} else {\n\t\t \n\t\tstate->link = false;\n\t}\n\n\tphylink_resolve_an_pause(state);\n}\nEXPORT_SYMBOL_GPL(phylink_resolve_c73);\n\nstatic void phylink_decode_c37_word(struct phylink_link_state *state,\n\t\t\t\t    uint16_t config_reg, int speed)\n{\n\tint fd_bit;\n\n\tif (speed == SPEED_2500)\n\t\tfd_bit = ETHTOOL_LINK_MODE_2500baseX_Full_BIT;\n\telse\n\t\tfd_bit = ETHTOOL_LINK_MODE_1000baseX_Full_BIT;\n\n\tmii_lpa_mod_linkmode_x(state->lp_advertising, config_reg, fd_bit);\n\n\tif (linkmode_test_bit(fd_bit, state->advertising) &&\n\t    linkmode_test_bit(fd_bit, state->lp_advertising)) {\n\t\tstate->speed = speed;\n\t\tstate->duplex = DUPLEX_FULL;\n\t} else {\n\t\t \n\t\tstate->link = false;\n\t}\n\n\tphylink_resolve_an_pause(state);\n}\n\nstatic void phylink_decode_sgmii_word(struct phylink_link_state *state,\n\t\t\t\t      uint16_t config_reg)\n{\n\tif (!(config_reg & LPA_SGMII_LINK)) {\n\t\tstate->link = false;\n\t\treturn;\n\t}\n\n\tswitch (config_reg & LPA_SGMII_SPD_MASK) {\n\tcase LPA_SGMII_10:\n\t\tstate->speed = SPEED_10;\n\t\tbreak;\n\tcase LPA_SGMII_100:\n\t\tstate->speed = SPEED_100;\n\t\tbreak;\n\tcase LPA_SGMII_1000:\n\t\tstate->speed = SPEED_1000;\n\t\tbreak;\n\tdefault:\n\t\tstate->link = false;\n\t\treturn;\n\t}\n\tif (config_reg & LPA_SGMII_FULL_DUPLEX)\n\t\tstate->duplex = DUPLEX_FULL;\n\telse\n\t\tstate->duplex = DUPLEX_HALF;\n}\n\n \nvoid phylink_decode_usxgmii_word(struct phylink_link_state *state,\n\t\t\t\t uint16_t lpa)\n{\n\tswitch (lpa & MDIO_USXGMII_SPD_MASK) {\n\tcase MDIO_USXGMII_10:\n\t\tstate->speed = SPEED_10;\n\t\tbreak;\n\tcase MDIO_USXGMII_100:\n\t\tstate->speed = SPEED_100;\n\t\tbreak;\n\tcase MDIO_USXGMII_1000:\n\t\tstate->speed = SPEED_1000;\n\t\tbreak;\n\tcase MDIO_USXGMII_2500:\n\t\tstate->speed = SPEED_2500;\n\t\tbreak;\n\tcase MDIO_USXGMII_5000:\n\t\tstate->speed = SPEED_5000;\n\t\tbreak;\n\tcase MDIO_USXGMII_10G:\n\t\tstate->speed = SPEED_10000;\n\t\tbreak;\n\tdefault:\n\t\tstate->link = false;\n\t\treturn;\n\t}\n\n\tif (lpa & MDIO_USXGMII_FULL_DUPLEX)\n\t\tstate->duplex = DUPLEX_FULL;\n\telse\n\t\tstate->duplex = DUPLEX_HALF;\n}\nEXPORT_SYMBOL_GPL(phylink_decode_usxgmii_word);\n\n \nstatic void phylink_decode_usgmii_word(struct phylink_link_state *state,\n\t\t\t\t       uint16_t lpa)\n{\n\tswitch (lpa & MDIO_USXGMII_SPD_MASK) {\n\tcase MDIO_USXGMII_10:\n\t\tstate->speed = SPEED_10;\n\t\tbreak;\n\tcase MDIO_USXGMII_100:\n\t\tstate->speed = SPEED_100;\n\t\tbreak;\n\tcase MDIO_USXGMII_1000:\n\t\tstate->speed = SPEED_1000;\n\t\tbreak;\n\tdefault:\n\t\tstate->link = false;\n\t\treturn;\n\t}\n\n\tif (lpa & MDIO_USXGMII_FULL_DUPLEX)\n\t\tstate->duplex = DUPLEX_FULL;\n\telse\n\t\tstate->duplex = DUPLEX_HALF;\n}\n\n \nvoid phylink_mii_c22_pcs_decode_state(struct phylink_link_state *state,\n\t\t\t\t      u16 bmsr, u16 lpa)\n{\n\tstate->link = !!(bmsr & BMSR_LSTATUS);\n\tstate->an_complete = !!(bmsr & BMSR_ANEGCOMPLETE);\n\t \n\tif (!state->link || !linkmode_test_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,\n\t\t\t\t\t       state->advertising))\n\t\treturn;\n\n\tswitch (state->interface) {\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\t\tphylink_decode_c37_word(state, lpa, SPEED_1000);\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_2500BASEX:\n\t\tphylink_decode_c37_word(state, lpa, SPEED_2500);\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_QSGMII:\n\t\tphylink_decode_sgmii_word(state, lpa);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_QUSGMII:\n\t\tphylink_decode_usgmii_word(state, lpa);\n\t\tbreak;\n\n\tdefault:\n\t\tstate->link = false;\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(phylink_mii_c22_pcs_decode_state);\n\n \nvoid phylink_mii_c22_pcs_get_state(struct mdio_device *pcs,\n\t\t\t\t   struct phylink_link_state *state)\n{\n\tint bmsr, lpa;\n\n\tbmsr = mdiodev_read(pcs, MII_BMSR);\n\tlpa = mdiodev_read(pcs, MII_LPA);\n\tif (bmsr < 0 || lpa < 0) {\n\t\tstate->link = false;\n\t\treturn;\n\t}\n\n\tphylink_mii_c22_pcs_decode_state(state, bmsr, lpa);\n}\nEXPORT_SYMBOL_GPL(phylink_mii_c22_pcs_get_state);\n\n \nint phylink_mii_c22_pcs_encode_advertisement(phy_interface_t interface,\n\t\t\t\t\t     const unsigned long *advertising)\n{\n\tu16 adv;\n\n\tswitch (interface) {\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\tcase PHY_INTERFACE_MODE_2500BASEX:\n\t\tadv = ADVERTISE_1000XFULL;\n\t\tif (linkmode_test_bit(ETHTOOL_LINK_MODE_Pause_BIT,\n\t\t\t\t      advertising))\n\t\t\tadv |= ADVERTISE_1000XPAUSE;\n\t\tif (linkmode_test_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,\n\t\t\t\t      advertising))\n\t\t\tadv |= ADVERTISE_1000XPSE_ASYM;\n\t\treturn adv;\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_QSGMII:\n\t\treturn 0x0001;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n}\nEXPORT_SYMBOL_GPL(phylink_mii_c22_pcs_encode_advertisement);\n\n \nint phylink_mii_c22_pcs_config(struct mdio_device *pcs,\n\t\t\t       phy_interface_t interface,\n\t\t\t       const unsigned long *advertising,\n\t\t\t       unsigned int neg_mode)\n{\n\tbool changed = 0;\n\tu16 bmcr;\n\tint ret, adv;\n\n\tadv = phylink_mii_c22_pcs_encode_advertisement(interface, advertising);\n\tif (adv >= 0) {\n\t\tret = mdiobus_modify_changed(pcs->bus, pcs->addr,\n\t\t\t\t\t     MII_ADVERTISE, 0xffff, adv);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tchanged = ret;\n\t}\n\n\tif (neg_mode == PHYLINK_PCS_NEG_INBAND_ENABLED)\n\t\tbmcr = BMCR_ANENABLE;\n\telse\n\t\tbmcr = 0;\n\n\t \n\tret = mdiodev_modify(pcs, MII_BMCR, BMCR_ANENABLE | BMCR_ISOLATE, bmcr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn changed;\n}\nEXPORT_SYMBOL_GPL(phylink_mii_c22_pcs_config);\n\n \nvoid phylink_mii_c22_pcs_an_restart(struct mdio_device *pcs)\n{\n\tint val = mdiodev_read(pcs, MII_BMCR);\n\n\tif (val >= 0) {\n\t\tval |= BMCR_ANRESTART;\n\n\t\tmdiodev_write(pcs, MII_BMCR, val);\n\t}\n}\nEXPORT_SYMBOL_GPL(phylink_mii_c22_pcs_an_restart);\n\nvoid phylink_mii_c45_pcs_get_state(struct mdio_device *pcs,\n\t\t\t\t   struct phylink_link_state *state)\n{\n\tstruct mii_bus *bus = pcs->bus;\n\tint addr = pcs->addr;\n\tint stat;\n\n\tstat = mdiobus_c45_read(bus, addr, MDIO_MMD_PCS, MDIO_STAT1);\n\tif (stat < 0) {\n\t\tstate->link = false;\n\t\treturn;\n\t}\n\n\tstate->link = !!(stat & MDIO_STAT1_LSTATUS);\n\tif (!state->link)\n\t\treturn;\n\n\tswitch (state->interface) {\n\tcase PHY_INTERFACE_MODE_10GBASER:\n\t\tstate->speed = SPEED_10000;\n\t\tstate->duplex = DUPLEX_FULL;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(phylink_mii_c45_pcs_get_state);\n\nstatic int __init phylink_init(void)\n{\n\tfor (int i = 0; i < ARRAY_SIZE(phylink_sfp_interface_preference); ++i)\n\t\t__set_bit(phylink_sfp_interface_preference[i],\n\t\t\t  phylink_sfp_interfaces);\n\n\treturn 0;\n}\n\nmodule_init(phylink_init);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}