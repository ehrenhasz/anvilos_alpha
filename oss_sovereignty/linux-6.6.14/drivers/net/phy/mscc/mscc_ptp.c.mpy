{
  "module_name": "mscc_ptp.c",
  "hash_id": "959d54e6721a2f367b2f12c5de96dac0ea1230a4a802933caa75ad1d66b2386d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/mscc/mscc_ptp.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/consumer.h>\n#include <linux/ip.h>\n#include <linux/net_tstamp.h>\n#include <linux/mii.h>\n#include <linux/phy.h>\n#include <linux/ptp_classify.h>\n#include <linux/ptp_clock_kernel.h>\n#include <linux/udp.h>\n#include <asm/unaligned.h>\n\n#include \"mscc.h\"\n#include \"mscc_ptp.h\"\n\n \n \nstatic int phy_ts_base_write(struct phy_device *phydev, u32 regnum, u16 val)\n{\n\tstruct vsc8531_private *priv = phydev->priv;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&phydev->mdio.bus->mdio_lock));\n\treturn __mdiobus_write(phydev->mdio.bus, priv->ts_base_addr, regnum,\n\t\t\t       val);\n}\n\n \nstatic int phy_ts_base_read(struct phy_device *phydev, u32 regnum)\n{\n\tstruct vsc8531_private *priv = phydev->priv;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&phydev->mdio.bus->mdio_lock));\n\treturn __mdiobus_read(phydev->mdio.bus, priv->ts_base_addr, regnum);\n}\n\nenum ts_blk_hw {\n\tINGRESS_ENGINE_0,\n\tEGRESS_ENGINE_0,\n\tINGRESS_ENGINE_1,\n\tEGRESS_ENGINE_1,\n\tINGRESS_ENGINE_2,\n\tEGRESS_ENGINE_2,\n\tPROCESSOR_0,\n\tPROCESSOR_1,\n};\n\nenum ts_blk {\n\tINGRESS,\n\tEGRESS,\n\tPROCESSOR,\n};\n\nstatic u32 vsc85xx_ts_read_csr(struct phy_device *phydev, enum ts_blk blk,\n\t\t\t       u16 addr)\n{\n\tstruct vsc8531_private *priv = phydev->priv;\n\tbool base_port = phydev->mdio.addr == priv->ts_base_addr;\n\tu32 val, cnt = 0;\n\tenum ts_blk_hw blk_hw;\n\n\tswitch (blk) {\n\tcase INGRESS:\n\t\tblk_hw = base_port ? INGRESS_ENGINE_0 : INGRESS_ENGINE_1;\n\t\tbreak;\n\tcase EGRESS:\n\t\tblk_hw = base_port ? EGRESS_ENGINE_0 : EGRESS_ENGINE_1;\n\t\tbreak;\n\tcase PROCESSOR:\n\tdefault:\n\t\tblk_hw = base_port ? PROCESSOR_0 : PROCESSOR_1;\n\t\tbreak;\n\t}\n\n\tphy_lock_mdio_bus(phydev);\n\n\tphy_ts_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_1588);\n\n\tphy_ts_base_write(phydev, MSCC_PHY_TS_BIU_ADDR_CNTL, BIU_ADDR_EXE |\n\t\t\t  BIU_ADDR_READ | BIU_BLK_ID(blk_hw) |\n\t\t\t  BIU_CSR_ADDR(addr));\n\n\tdo {\n\t\tval = phy_ts_base_read(phydev, MSCC_PHY_TS_BIU_ADDR_CNTL);\n\t} while (!(val & BIU_ADDR_EXE) && cnt++ < BIU_ADDR_CNT_MAX);\n\n\tval = phy_ts_base_read(phydev, MSCC_PHY_TS_CSR_DATA_MSB);\n\tval <<= 16;\n\tval |= phy_ts_base_read(phydev, MSCC_PHY_TS_CSR_DATA_LSB);\n\n\tphy_ts_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_STANDARD);\n\n\tphy_unlock_mdio_bus(phydev);\n\n\treturn val;\n}\n\nstatic void vsc85xx_ts_write_csr(struct phy_device *phydev, enum ts_blk blk,\n\t\t\t\t u16 addr, u32 val)\n{\n\tstruct vsc8531_private *priv = phydev->priv;\n\tbool base_port = phydev->mdio.addr == priv->ts_base_addr;\n\tu32 reg, bypass, cnt = 0, lower = val & 0xffff, upper = val >> 16;\n\tbool cond = (addr == MSCC_PHY_PTP_LTC_CTRL ||\n\t\t     addr == MSCC_PHY_1588_INGR_VSC85XX_INT_MASK ||\n\t\t     addr == MSCC_PHY_1588_VSC85XX_INT_MASK ||\n\t\t     addr == MSCC_PHY_1588_INGR_VSC85XX_INT_STATUS ||\n\t\t     addr == MSCC_PHY_1588_VSC85XX_INT_STATUS) &&\n\t\t    blk == PROCESSOR;\n\tenum ts_blk_hw blk_hw;\n\n\tswitch (blk) {\n\tcase INGRESS:\n\t\tblk_hw = base_port ? INGRESS_ENGINE_0 : INGRESS_ENGINE_1;\n\t\tbreak;\n\tcase EGRESS:\n\t\tblk_hw = base_port ? EGRESS_ENGINE_0 : EGRESS_ENGINE_1;\n\t\tbreak;\n\tcase PROCESSOR:\n\tdefault:\n\t\tblk_hw = base_port ? PROCESSOR_0 : PROCESSOR_1;\n\t\tbreak;\n\t}\n\n\tphy_lock_mdio_bus(phydev);\n\n\tbypass = phy_ts_base_read(phydev, MSCC_PHY_BYPASS_CONTROL);\n\n\tphy_ts_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_1588);\n\n\tif (!cond || upper)\n\t\tphy_ts_base_write(phydev, MSCC_PHY_TS_CSR_DATA_MSB, upper);\n\n\tphy_ts_base_write(phydev, MSCC_PHY_TS_CSR_DATA_LSB, lower);\n\n\tphy_ts_base_write(phydev, MSCC_PHY_TS_BIU_ADDR_CNTL, BIU_ADDR_EXE |\n\t\t\t  BIU_ADDR_WRITE | BIU_BLK_ID(blk_hw) |\n\t\t\t  BIU_CSR_ADDR(addr));\n\n\tdo {\n\t\treg = phy_ts_base_read(phydev, MSCC_PHY_TS_BIU_ADDR_CNTL);\n\t} while (!(reg & BIU_ADDR_EXE) && cnt++ < BIU_ADDR_CNT_MAX);\n\n\tphy_ts_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_STANDARD);\n\n\tif (cond && upper)\n\t\tphy_ts_base_write(phydev, MSCC_PHY_BYPASS_CONTROL, bypass);\n\n\tphy_unlock_mdio_bus(phydev);\n}\n\n \n#define PTP_HEADER_TRNSP_MSG\t\t26\n#define PTP_HEADER_DOMAIN_NUM\t\t25\n#define PTP_HEADER_BYTE_8_31(x)\t\t(31 - (x))\n#define MAC_ADDRESS_BYTE(x)\t\t((x) + (35 - ETH_ALEN + 1))\n\nstatic int vsc85xx_ts_fsb_init(struct phy_device *phydev)\n{\n\tu8 sig_sel[16] = {};\n\tsigned char i, pos = 0;\n\n\t \n\tfor (i = 1; i >= 0; i--)\n\t\tsig_sel[pos++] = PTP_HEADER_BYTE_8_31(30 + i);\n\n\t \n\tsig_sel[pos++] = PTP_HEADER_DOMAIN_NUM;\n\n\t \n\tsig_sel[pos++] = PTP_HEADER_TRNSP_MSG;\n\n\t \n\tfor (i = ETH_ALEN - 1; i >= 0; i--)\n\t\tsig_sel[pos++] = MAC_ADDRESS_BYTE(i);\n\n\t \n\tfor (; pos < ARRAY_SIZE(sig_sel); pos++)\n\t\tsig_sel[pos] = PTP_HEADER_TRNSP_MSG;\n\n\tfor (i = 0; i <= 2; i++) {\n\t\tu32 val = 0;\n\n\t\tfor (pos = i * 5 + 4; pos >= i * 5; pos--)\n\t\t\tval = (val << 6) | sig_sel[pos];\n\n\t\tvsc85xx_ts_write_csr(phydev, EGRESS, MSCC_PHY_ANA_FSB_REG(i),\n\t\t\t\t     val);\n\t}\n\n\tvsc85xx_ts_write_csr(phydev, EGRESS, MSCC_PHY_ANA_FSB_REG(3),\n\t\t\t     sig_sel[15]);\n\n\treturn 0;\n}\n\nstatic const u32 vsc85xx_egr_latency[] = {\n\t \n\t1272,  \n\t12516,  \n\t125444,  \n\t \n\t1277,  \n\t12537,  \n};\n\nstatic const u32 vsc85xx_egr_latency_macsec[] = {\n\t \n\t3496,  \n\t34760,  \n\t347844,  \n\t \n\t3502,  \n\t34780,  \n};\n\nstatic const u32 vsc85xx_ingr_latency[] = {\n\t \n\t208,  \n\t304,  \n\t2023,  \n\t \n\t98,  \n\t197,  \n};\n\nstatic const u32 vsc85xx_ingr_latency_macsec[] = {\n\t \n\t2408,  \n\t22300,  \n\t222009,  \n\t \n\t2299,  \n\t22192,  \n};\n\nstatic void vsc85xx_ts_set_latencies(struct phy_device *phydev)\n{\n\tu32 val, ingr_latency, egr_latency;\n\tu8 idx;\n\n\t \n\tif (!phydev->link)\n\t\treturn;\n\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_EGR_STALL_LATENCY,\n\t\t\t     STALL_EGR_LATENCY(phydev->speed));\n\n\tswitch (phydev->speed) {\n\tcase SPEED_100:\n\t\tidx = 1;\n\t\tbreak;\n\tcase SPEED_1000:\n\t\tidx = 0;\n\t\tbreak;\n\tdefault:\n\t\tidx = 2;\n\t\tbreak;\n\t}\n\n\tingr_latency = IS_ENABLED(CONFIG_MACSEC) ?\n\t\tvsc85xx_ingr_latency_macsec[idx] : vsc85xx_ingr_latency[idx];\n\tegr_latency = IS_ENABLED(CONFIG_MACSEC) ?\n\t\tvsc85xx_egr_latency_macsec[idx] : vsc85xx_egr_latency[idx];\n\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_INGR_LOCAL_LATENCY,\n\t\t\t     PTP_INGR_LOCAL_LATENCY(ingr_latency));\n\n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t  MSCC_PHY_PTP_INGR_TSP_CTRL);\n\tval |= PHY_PTP_INGR_TSP_CTRL_LOAD_DELAYS;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_INGR_TSP_CTRL,\n\t\t\t     val);\n\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_EGR_LOCAL_LATENCY,\n\t\t\t     PTP_EGR_LOCAL_LATENCY(egr_latency));\n\n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR, MSCC_PHY_PTP_EGR_TSP_CTRL);\n\tval |= PHY_PTP_EGR_TSP_CTRL_LOAD_DELAYS;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_EGR_TSP_CTRL, val);\n}\n\nstatic int vsc85xx_ts_disable_flows(struct phy_device *phydev, enum ts_blk blk)\n{\n\tu8 i;\n\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_IP1_NXT_PROT_NXT_COMP, 0);\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_IP1_NXT_PROT_UDP_CHKSUM,\n\t\t\t     IP1_NXT_PROT_UDP_CHKSUM_WIDTH(2));\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_IP2_NXT_PROT_NXT_COMP, 0);\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_IP2_NXT_PROT_UDP_CHKSUM,\n\t\t\t     IP2_NXT_PROT_UDP_CHKSUM_WIDTH(2));\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_PHY_ANA_MPLS_COMP_NXT_COMP, 0);\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_PHY_ANA_ETH1_NTX_PROT, 0);\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_PHY_ANA_ETH2_NTX_PROT, 0);\n\n\tfor (i = 0; i < COMP_MAX_FLOWS; i++) {\n\t\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_IP1_FLOW_ENA(i),\n\t\t\t\t     IP1_FLOW_VALID_CH0 | IP1_FLOW_VALID_CH1);\n\t\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_IP2_FLOW_ENA(i),\n\t\t\t\t     IP2_FLOW_VALID_CH0 | IP2_FLOW_VALID_CH1);\n\t\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_ETH1_FLOW_ENA(i),\n\t\t\t\t     ETH1_FLOW_VALID_CH0 | ETH1_FLOW_VALID_CH1);\n\t\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_ETH2_FLOW_ENA(i),\n\t\t\t\t     ETH2_FLOW_VALID_CH0 | ETH2_FLOW_VALID_CH1);\n\t\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_MPLS_FLOW_CTRL(i),\n\t\t\t\t     MPLS_FLOW_VALID_CH0 | MPLS_FLOW_VALID_CH1);\n\n\t\tif (i >= PTP_COMP_MAX_FLOWS)\n\t\t\tcontinue;\n\n\t\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_PTP_FLOW_ENA(i), 0);\n\t\tvsc85xx_ts_write_csr(phydev, blk,\n\t\t\t\t     MSCC_ANA_PTP_FLOW_DOMAIN_RANGE(i), 0);\n\t\tvsc85xx_ts_write_csr(phydev, blk,\n\t\t\t\t     MSCC_ANA_PTP_FLOW_MASK_UPPER(i), 0);\n\t\tvsc85xx_ts_write_csr(phydev, blk,\n\t\t\t\t     MSCC_ANA_PTP_FLOW_MASK_LOWER(i), 0);\n\t\tvsc85xx_ts_write_csr(phydev, blk,\n\t\t\t\t     MSCC_ANA_PTP_FLOW_MATCH_UPPER(i), 0);\n\t\tvsc85xx_ts_write_csr(phydev, blk,\n\t\t\t\t     MSCC_ANA_PTP_FLOW_MATCH_LOWER(i), 0);\n\t\tvsc85xx_ts_write_csr(phydev, blk,\n\t\t\t\t     MSCC_ANA_PTP_FLOW_PTP_ACTION(i), 0);\n\t\tvsc85xx_ts_write_csr(phydev, blk,\n\t\t\t\t     MSCC_ANA_PTP_FLOW_PTP_ACTION2(i), 0);\n\t\tvsc85xx_ts_write_csr(phydev, blk,\n\t\t\t\t     MSCC_ANA_PTP_FLOW_PTP_0_FIELD(i), 0);\n\t\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_OAM_PTP_FLOW_ENA(i),\n\t\t\t\t     0);\n\t}\n\n\treturn 0;\n}\n\nstatic int vsc85xx_ts_eth_cmp1_sig(struct phy_device *phydev)\n{\n\tu32 val;\n\n\tval = vsc85xx_ts_read_csr(phydev, EGRESS, MSCC_PHY_ANA_ETH1_NTX_PROT);\n\tval &= ~ANA_ETH1_NTX_PROT_SIG_OFF_MASK;\n\tval |= ANA_ETH1_NTX_PROT_SIG_OFF(0);\n\tvsc85xx_ts_write_csr(phydev, EGRESS, MSCC_PHY_ANA_ETH1_NTX_PROT, val);\n\n\tval = vsc85xx_ts_read_csr(phydev, EGRESS, MSCC_PHY_ANA_FSB_CFG);\n\tval &= ~ANA_FSB_ADDR_FROM_BLOCK_SEL_MASK;\n\tval |= ANA_FSB_ADDR_FROM_ETH1;\n\tvsc85xx_ts_write_csr(phydev, EGRESS, MSCC_PHY_ANA_FSB_CFG, val);\n\n\treturn 0;\n}\n\nstatic struct vsc85xx_ptphdr *get_ptp_header_l4(struct sk_buff *skb,\n\t\t\t\t\t\tstruct iphdr *iphdr,\n\t\t\t\t\t\tstruct udphdr *udphdr)\n{\n\tif (iphdr->version != 4 || iphdr->protocol != IPPROTO_UDP)\n\t\treturn NULL;\n\n\treturn (struct vsc85xx_ptphdr *)(((unsigned char *)udphdr) + UDP_HLEN);\n}\n\nstatic struct vsc85xx_ptphdr *get_ptp_header_tx(struct sk_buff *skb)\n{\n\tstruct ethhdr *ethhdr = eth_hdr(skb);\n\tstruct udphdr *udphdr;\n\tstruct iphdr *iphdr;\n\n\tif (ethhdr->h_proto == htons(ETH_P_1588))\n\t\treturn (struct vsc85xx_ptphdr *)(((unsigned char *)ethhdr) +\n\t\t\t\t\t\t skb_mac_header_len(skb));\n\n\tif (ethhdr->h_proto != htons(ETH_P_IP))\n\t\treturn NULL;\n\n\tiphdr = ip_hdr(skb);\n\tudphdr = udp_hdr(skb);\n\n\treturn get_ptp_header_l4(skb, iphdr, udphdr);\n}\n\nstatic struct vsc85xx_ptphdr *get_ptp_header_rx(struct sk_buff *skb,\n\t\t\t\t\t\tenum hwtstamp_rx_filters rx_filter)\n{\n\tstruct udphdr *udphdr;\n\tstruct iphdr *iphdr;\n\n\tif (rx_filter == HWTSTAMP_FILTER_PTP_V2_L2_EVENT)\n\t\treturn (struct vsc85xx_ptphdr *)skb->data;\n\n\tiphdr = (struct iphdr *)skb->data;\n\tudphdr = (struct udphdr *)(skb->data + iphdr->ihl * 4);\n\n\treturn get_ptp_header_l4(skb, iphdr, udphdr);\n}\n\nstatic int get_sig(struct sk_buff *skb, u8 *sig)\n{\n\tstruct vsc85xx_ptphdr *ptphdr = get_ptp_header_tx(skb);\n\tstruct ethhdr *ethhdr = eth_hdr(skb);\n\tunsigned int i;\n\n\tif (!ptphdr)\n\t\treturn -EOPNOTSUPP;\n\n\tsig[0] = (__force u16)ptphdr->seq_id >> 8;\n\tsig[1] = (__force u16)ptphdr->seq_id & GENMASK(7, 0);\n\tsig[2] = ptphdr->domain;\n\tsig[3] = ptphdr->tsmt & GENMASK(3, 0);\n\n\tmemcpy(&sig[4], ethhdr->h_dest, ETH_ALEN);\n\n\t \n\tfor (i = 10; i < 16; i++)\n\t\tsig[i] = ptphdr->tsmt & GENMASK(3, 0);\n\n\treturn 0;\n}\n\nstatic void vsc85xx_dequeue_skb(struct vsc85xx_ptp *ptp)\n{\n\tstruct skb_shared_hwtstamps shhwtstamps;\n\tstruct vsc85xx_ts_fifo fifo;\n\tstruct sk_buff *skb;\n\tu8 skb_sig[16], *p;\n\tint i, len;\n\tu32 reg;\n\n\tmemset(&fifo, 0, sizeof(fifo));\n\tp = (u8 *)&fifo;\n\n\treg = vsc85xx_ts_read_csr(ptp->phydev, PROCESSOR,\n\t\t\t\t  MSCC_PHY_PTP_EGR_TS_FIFO(0));\n\tif (reg & PTP_EGR_TS_FIFO_EMPTY)\n\t\treturn;\n\n\t*p++ = reg & 0xff;\n\t*p++ = (reg >> 8) & 0xff;\n\n\t \n\tfor (i = 1; i < 7; i++) {\n\t\treg = vsc85xx_ts_read_csr(ptp->phydev, PROCESSOR,\n\t\t\t\t\t  MSCC_PHY_PTP_EGR_TS_FIFO(i));\n\t\t*p++ = reg & 0xff;\n\t\t*p++ = (reg >> 8) & 0xff;\n\t\t*p++ = (reg >> 16) & 0xff;\n\t\t*p++ = (reg >> 24) & 0xff;\n\t}\n\n\tlen = skb_queue_len(&ptp->tx_queue);\n\tif (len < 1)\n\t\treturn;\n\n\twhile (len--) {\n\t\tskb = __skb_dequeue(&ptp->tx_queue);\n\t\tif (!skb)\n\t\t\treturn;\n\n\t\t \n\t\tif (get_sig(skb, skb_sig) < 0) {\n\t\t\tkfree_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!memcmp(skb_sig, fifo.sig, sizeof(fifo.sig))) {\n\t\t\tmemset(&shhwtstamps, 0, sizeof(shhwtstamps));\n\t\t\tshhwtstamps.hwtstamp = ktime_set(fifo.secs, fifo.ns);\n\t\t\tskb_complete_tx_timestamp(skb, &shhwtstamps);\n\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\t__skb_queue_tail(&ptp->tx_queue, skb);\n\t}\n}\n\nstatic void vsc85xx_get_tx_ts(struct vsc85xx_ptp *ptp)\n{\n\tu32 reg;\n\n\tdo {\n\t\tvsc85xx_dequeue_skb(ptp);\n\n\t\t \n\t\treg = vsc85xx_ts_read_csr(ptp->phydev, PROCESSOR,\n\t\t\t\t\t  MSCC_PHY_PTP_EGR_TS_FIFO_CTRL);\n\t} while (PTP_EGR_FIFO_LEVEL_LAST_READ(reg) > 1);\n}\n\nstatic int vsc85xx_ptp_cmp_init(struct phy_device *phydev, enum ts_blk blk)\n{\n\tstruct vsc8531_private *vsc8531 = phydev->priv;\n\tbool base = phydev->mdio.addr == vsc8531->ts_base_addr;\n\tstatic const u8 msgs[] = {\n\t\tPTP_MSGTYPE_SYNC,\n\t\tPTP_MSGTYPE_DELAY_REQ\n\t};\n\tu32 val;\n\tu8 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(msgs); i++) {\n\t\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_PTP_FLOW_ENA(i),\n\t\t\t\t     base ? PTP_FLOW_VALID_CH0 :\n\t\t\t\t     PTP_FLOW_VALID_CH1);\n\n\t\tval = vsc85xx_ts_read_csr(phydev, blk,\n\t\t\t\t\t  MSCC_ANA_PTP_FLOW_DOMAIN_RANGE(i));\n\t\tval &= ~PTP_FLOW_DOMAIN_RANGE_ENA;\n\t\tvsc85xx_ts_write_csr(phydev, blk,\n\t\t\t\t     MSCC_ANA_PTP_FLOW_DOMAIN_RANGE(i), val);\n\n\t\tvsc85xx_ts_write_csr(phydev, blk,\n\t\t\t\t     MSCC_ANA_PTP_FLOW_MATCH_UPPER(i),\n\t\t\t\t     msgs[i] << 24);\n\n\t\tvsc85xx_ts_write_csr(phydev, blk,\n\t\t\t\t     MSCC_ANA_PTP_FLOW_MASK_UPPER(i),\n\t\t\t\t     PTP_FLOW_MSG_TYPE_MASK);\n\t}\n\n\treturn 0;\n}\n\nstatic int vsc85xx_eth_cmp1_init(struct phy_device *phydev, enum ts_blk blk)\n{\n\tstruct vsc8531_private *vsc8531 = phydev->priv;\n\tbool base = phydev->mdio.addr == vsc8531->ts_base_addr;\n\tu32 val;\n\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_PHY_ANA_ETH1_NXT_PROT_TAG, 0);\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_PHY_ANA_ETH1_NTX_PROT_VLAN_TPID,\n\t\t\t     ANA_ETH1_NTX_PROT_VLAN_TPID(ETH_P_8021AD));\n\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_ETH1_FLOW_ENA(0),\n\t\t\t     base ? ETH1_FLOW_VALID_CH0 : ETH1_FLOW_VALID_CH1);\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_ETH1_FLOW_MATCH_MODE(0),\n\t\t\t     ANA_ETH1_FLOW_MATCH_VLAN_TAG2);\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_ETH1_FLOW_ADDR_MATCH1(0), 0);\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_ETH1_FLOW_ADDR_MATCH2(0), 0);\n\tvsc85xx_ts_write_csr(phydev, blk,\n\t\t\t     MSCC_ANA_ETH1_FLOW_VLAN_RANGE_I_TAG(0), 0);\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_ETH1_FLOW_VLAN_TAG1(0), 0);\n\tvsc85xx_ts_write_csr(phydev, blk,\n\t\t\t     MSCC_ANA_ETH1_FLOW_VLAN_TAG2_I_TAG(0), 0);\n\n\tval = vsc85xx_ts_read_csr(phydev, blk,\n\t\t\t\t  MSCC_ANA_ETH1_FLOW_MATCH_MODE(0));\n\tval &= ~ANA_ETH1_FLOW_MATCH_VLAN_TAG_MASK;\n\tval |= ANA_ETH1_FLOW_MATCH_VLAN_VERIFY;\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_ETH1_FLOW_MATCH_MODE(0),\n\t\t\t     val);\n\n\treturn 0;\n}\n\nstatic int vsc85xx_ip_cmp1_init(struct phy_device *phydev, enum ts_blk blk)\n{\n\tstruct vsc8531_private *vsc8531 = phydev->priv;\n\tbool base = phydev->mdio.addr == vsc8531->ts_base_addr;\n\tu32 val;\n\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_IP1_NXT_PROT_MATCH2_UPPER,\n\t\t\t     PTP_EV_PORT);\n\t \n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_IP1_NXT_PROT_MASK2_UPPER,\n\t\t\t     0xffff);\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_IP1_NXT_PROT_MATCH2_LOWER,\n\t\t\t     0);\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_IP1_NXT_PROT_MASK2_LOWER, 0);\n\n\tval = vsc85xx_ts_read_csr(phydev, blk, MSCC_ANA_IP1_FLOW_ENA(0));\n\tval &= ~IP1_FLOW_ENA_CHANNEL_MASK_MASK;\n\tval |= base ? IP1_FLOW_VALID_CH0 : IP1_FLOW_VALID_CH1;\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_IP1_FLOW_ENA(0), val);\n\n\t \n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_IP1_FLOW_MATCH_UPPER(0), 0);\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_IP1_FLOW_MASK_UPPER(0), 0);\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_IP1_FLOW_MATCH_UPPER_MID(0),\n\t\t\t     0);\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_IP1_FLOW_MASK_UPPER_MID(0),\n\t\t\t     0);\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_IP1_FLOW_MATCH_LOWER_MID(0),\n\t\t\t     0);\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_IP1_FLOW_MASK_LOWER_MID(0),\n\t\t\t     0);\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_IP1_FLOW_MATCH_LOWER(0), 0);\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_IP1_FLOW_MASK_LOWER(0), 0);\n\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_PTP_IP_CHKSUM_SEL, 0);\n\n\treturn 0;\n}\n\nstatic int vsc85xx_adjfine(struct ptp_clock_info *info, long scaled_ppm)\n{\n\tstruct vsc85xx_ptp *ptp = container_of(info, struct vsc85xx_ptp, caps);\n\tstruct phy_device *phydev = ptp->phydev;\n\tstruct vsc8531_private *priv = phydev->priv;\n\tu64 adj = 0;\n\tu32 val;\n\n\tif (abs(scaled_ppm) < 66 || abs(scaled_ppm) > 65536UL * 1000000UL)\n\t\treturn 0;\n\n\tadj = div64_u64(1000000ULL * 65536ULL, abs(scaled_ppm));\n\tif (adj > 1000000000L)\n\t\tadj = 1000000000L;\n\n\tval = PTP_AUTO_ADJ_NS_ROLLOVER(adj);\n\tval |= scaled_ppm > 0 ? PTP_AUTO_ADJ_ADD_1NS : PTP_AUTO_ADJ_SUB_1NS;\n\n\tmutex_lock(&priv->phc_lock);\n\n\t \n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_LTC_AUTO_ADJ,\n\t\t\t     val);\n\n\t \n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR, MSCC_PHY_PTP_LTC_CTRL);\n\tval |= PTP_LTC_CTRL_AUTO_ADJ_UPDATE;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_LTC_CTRL, val);\n\n\tmutex_unlock(&priv->phc_lock);\n\n\treturn 0;\n}\n\nstatic int __vsc85xx_gettime(struct ptp_clock_info *info, struct timespec64 *ts)\n{\n\tstruct vsc85xx_ptp *ptp = container_of(info, struct vsc85xx_ptp, caps);\n\tstruct phy_device *phydev = ptp->phydev;\n\tstruct vsc85xx_shared_private *shared =\n\t\t(struct vsc85xx_shared_private *)phydev->shared->priv;\n\tstruct vsc8531_private *priv = phydev->priv;\n\tu32 val;\n\n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR, MSCC_PHY_PTP_LTC_CTRL);\n\tval |= PTP_LTC_CTRL_SAVE_ENA;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_LTC_CTRL, val);\n\n\t \n\tmutex_lock(&shared->gpio_lock);\n\tgpiod_set_value(priv->load_save, 1);\n\n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t  MSCC_PHY_PTP_LTC_SAVED_SEC_MSB);\n\n\tts->tv_sec = ((time64_t)val) << 32;\n\n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t  MSCC_PHY_PTP_LTC_SAVED_SEC_LSB);\n\tts->tv_sec += val;\n\n\tts->tv_nsec = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t\t  MSCC_PHY_PTP_LTC_SAVED_NS);\n\n\tgpiod_set_value(priv->load_save, 0);\n\tmutex_unlock(&shared->gpio_lock);\n\n\treturn 0;\n}\n\nstatic int vsc85xx_gettime(struct ptp_clock_info *info, struct timespec64 *ts)\n{\n\tstruct vsc85xx_ptp *ptp = container_of(info, struct vsc85xx_ptp, caps);\n\tstruct phy_device *phydev = ptp->phydev;\n\tstruct vsc8531_private *priv = phydev->priv;\n\n\tmutex_lock(&priv->phc_lock);\n\t__vsc85xx_gettime(info, ts);\n\tmutex_unlock(&priv->phc_lock);\n\n\treturn 0;\n}\n\nstatic int __vsc85xx_settime(struct ptp_clock_info *info,\n\t\t\t     const struct timespec64 *ts)\n{\n\tstruct vsc85xx_ptp *ptp = container_of(info, struct vsc85xx_ptp, caps);\n\tstruct phy_device *phydev = ptp->phydev;\n\tstruct vsc85xx_shared_private *shared =\n\t\t(struct vsc85xx_shared_private *)phydev->shared->priv;\n\tstruct vsc8531_private *priv = phydev->priv;\n\tu32 val;\n\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_LTC_LOAD_SEC_MSB,\n\t\t\t     PTP_LTC_LOAD_SEC_MSB(ts->tv_sec));\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_LTC_LOAD_SEC_LSB,\n\t\t\t     PTP_LTC_LOAD_SEC_LSB(ts->tv_sec));\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_LTC_LOAD_NS,\n\t\t\t     PTP_LTC_LOAD_NS(ts->tv_nsec));\n\n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR, MSCC_PHY_PTP_LTC_CTRL);\n\tval |= PTP_LTC_CTRL_LOAD_ENA;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_LTC_CTRL, val);\n\n\t \n\tmutex_lock(&shared->gpio_lock);\n\tgpiod_set_value(priv->load_save, 1);\n\n\tval &= ~PTP_LTC_CTRL_LOAD_ENA;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_LTC_CTRL, val);\n\n\tgpiod_set_value(priv->load_save, 0);\n\tmutex_unlock(&shared->gpio_lock);\n\n\treturn 0;\n}\n\nstatic int vsc85xx_settime(struct ptp_clock_info *info,\n\t\t\t   const struct timespec64 *ts)\n{\n\tstruct vsc85xx_ptp *ptp = container_of(info, struct vsc85xx_ptp, caps);\n\tstruct phy_device *phydev = ptp->phydev;\n\tstruct vsc8531_private *priv = phydev->priv;\n\n\tmutex_lock(&priv->phc_lock);\n\t__vsc85xx_settime(info, ts);\n\tmutex_unlock(&priv->phc_lock);\n\n\treturn 0;\n}\n\nstatic int vsc85xx_adjtime(struct ptp_clock_info *info, s64 delta)\n{\n\tstruct vsc85xx_ptp *ptp = container_of(info, struct vsc85xx_ptp, caps);\n\tstruct phy_device *phydev = ptp->phydev;\n\tstruct vsc8531_private *priv = phydev->priv;\n\tu32 val;\n\n\t \n\tif (abs(delta) >= NSEC_PER_SEC) {\n\t\tstruct timespec64 ts;\n\t\tu64 now;\n\n\t\tmutex_lock(&priv->phc_lock);\n\n\t\t__vsc85xx_gettime(info, &ts);\n\t\tnow = ktime_to_ns(timespec64_to_ktime(ts));\n\t\tts = ns_to_timespec64(now + delta);\n\t\t__vsc85xx_settime(info, &ts);\n\n\t\tmutex_unlock(&priv->phc_lock);\n\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&priv->phc_lock);\n\n\tval = PTP_LTC_OFFSET_VAL(abs(delta)) | PTP_LTC_OFFSET_ADJ;\n\tif (delta > 0)\n\t\tval |= PTP_LTC_OFFSET_ADD;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_LTC_OFFSET, val);\n\n\tmutex_unlock(&priv->phc_lock);\n\n\treturn 0;\n}\n\nstatic int vsc85xx_eth1_next_comp(struct phy_device *phydev, enum ts_blk blk,\n\t\t\t\t  u32 next_comp, u32 etype)\n{\n\tu32 val;\n\n\tval = vsc85xx_ts_read_csr(phydev, blk, MSCC_PHY_ANA_ETH1_NTX_PROT);\n\tval &= ~ANA_ETH1_NTX_PROT_COMPARATOR_MASK;\n\tval |= next_comp;\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_PHY_ANA_ETH1_NTX_PROT, val);\n\n\tval = ANA_ETH1_NXT_PROT_ETYPE_MATCH(etype) |\n\t\tANA_ETH1_NXT_PROT_ETYPE_MATCH_ENA;\n\tvsc85xx_ts_write_csr(phydev, blk,\n\t\t\t     MSCC_PHY_ANA_ETH1_NXT_PROT_ETYPE_MATCH, val);\n\n\treturn 0;\n}\n\nstatic int vsc85xx_ip1_next_comp(struct phy_device *phydev, enum ts_blk blk,\n\t\t\t\t u32 next_comp, u32 header)\n{\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_IP1_NXT_PROT_NXT_COMP,\n\t\t\t     ANA_IP1_NXT_PROT_NXT_COMP_BYTES_HDR(header) |\n\t\t\t     next_comp);\n\n\treturn 0;\n}\n\nstatic int vsc85xx_ts_ptp_action_flow(struct phy_device *phydev, enum ts_blk blk, u8 flow, enum ptp_cmd cmd)\n{\n\tu32 val;\n\n\t \n\tval = PTP_FLOW_PTP_0_FIELD_PTP_FRAME | PTP_FLOW_PTP_0_FIELD_RSVRD_CHECK;\n\tvsc85xx_ts_write_csr(phydev, blk,\n\t\t\t     MSCC_ANA_PTP_FLOW_PTP_0_FIELD(flow), val);\n\n\tval = PTP_FLOW_PTP_ACTION_CORR_OFFSET(8) |\n\t      PTP_FLOW_PTP_ACTION_TIME_OFFSET(8) |\n\t      PTP_FLOW_PTP_ACTION_PTP_CMD(cmd == PTP_SAVE_IN_TS_FIFO ?\n\t\t\t\t\t  PTP_NOP : cmd);\n\tif (cmd == PTP_SAVE_IN_TS_FIFO)\n\t\tval |= PTP_FLOW_PTP_ACTION_SAVE_LOCAL_TIME;\n\telse if (cmd == PTP_WRITE_NS)\n\t\tval |= PTP_FLOW_PTP_ACTION_MOD_FRAME_STATUS_UPDATE |\n\t\t       PTP_FLOW_PTP_ACTION_MOD_FRAME_STATUS_BYTE_OFFSET(6);\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_PTP_FLOW_PTP_ACTION(flow),\n\t\t\t     val);\n\n\tif (cmd == PTP_WRITE_1588)\n\t\t \n\t\tval = PTP_FLOW_PTP_ACTION2_REWRITE_OFFSET(34) |\n\t\t      PTP_FLOW_PTP_ACTION2_REWRITE_BYTES(10);\n\telse if (cmd == PTP_SAVE_IN_TS_FIFO)\n\t\t \n\t\tval = PTP_FLOW_PTP_ACTION2_REWRITE_OFFSET(0) |\n\t\t      PTP_FLOW_PTP_ACTION2_REWRITE_BYTES(0);\n\telse\n\t\t \n\t\tval = PTP_FLOW_PTP_ACTION2_REWRITE_OFFSET(16) |\n\t\t      PTP_FLOW_PTP_ACTION2_REWRITE_BYTES(4);\n\tvsc85xx_ts_write_csr(phydev, blk,\n\t\t\t     MSCC_ANA_PTP_FLOW_PTP_ACTION2(flow), val);\n\n\treturn 0;\n}\n\nstatic int vsc85xx_ptp_conf(struct phy_device *phydev, enum ts_blk blk,\n\t\t\t    bool one_step, bool enable)\n{\n\tstatic const u8 msgs[] = {\n\t\tPTP_MSGTYPE_SYNC,\n\t\tPTP_MSGTYPE_DELAY_REQ\n\t};\n\tu32 val;\n\tu8 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(msgs); i++) {\n\t\tif (blk == INGRESS)\n\t\t\tvsc85xx_ts_ptp_action_flow(phydev, blk, msgs[i],\n\t\t\t\t\t\t   PTP_WRITE_NS);\n\t\telse if (msgs[i] == PTP_MSGTYPE_SYNC && one_step)\n\t\t\t \n\t\t\tvsc85xx_ts_ptp_action_flow(phydev, blk, msgs[i],\n\t\t\t\t\t\t   PTP_WRITE_1588);\n\t\telse\n\t\t\tvsc85xx_ts_ptp_action_flow(phydev, blk, msgs[i],\n\t\t\t\t\t\t   PTP_SAVE_IN_TS_FIFO);\n\n\t\tval = vsc85xx_ts_read_csr(phydev, blk,\n\t\t\t\t\t  MSCC_ANA_PTP_FLOW_ENA(i));\n\t\tval &= ~PTP_FLOW_ENA;\n\t\tif (enable)\n\t\t\tval |= PTP_FLOW_ENA;\n\t\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_PTP_FLOW_ENA(i),\n\t\t\t\t     val);\n\t}\n\n\treturn 0;\n}\n\nstatic int vsc85xx_eth1_conf(struct phy_device *phydev, enum ts_blk blk,\n\t\t\t     bool enable)\n{\n\tstruct vsc8531_private *vsc8531 = phydev->priv;\n\tu32 val = ANA_ETH1_FLOW_ADDR_MATCH2_DEST;\n\n\tif (vsc8531->ptp->rx_filter == HWTSTAMP_FILTER_PTP_V2_L2_EVENT) {\n\t\t \n\t\tu8 ptp_multicast[6] = {0x01, 0x1b, 0x19, 0x00, 0x00, 0x00};\n\n\t\tval |= ANA_ETH1_FLOW_ADDR_MATCH2_FULL_ADDR |\n\t\t       get_unaligned_be16(&ptp_multicast[4]);\n\t\tvsc85xx_ts_write_csr(phydev, blk,\n\t\t\t\t     MSCC_ANA_ETH1_FLOW_ADDR_MATCH2(0), val);\n\t\tvsc85xx_ts_write_csr(phydev, blk,\n\t\t\t\t     MSCC_ANA_ETH1_FLOW_ADDR_MATCH1(0),\n\t\t\t\t     get_unaligned_be32(ptp_multicast));\n\t} else {\n\t\tval |= ANA_ETH1_FLOW_ADDR_MATCH2_ANY_MULTICAST;\n\t\tvsc85xx_ts_write_csr(phydev, blk,\n\t\t\t\t     MSCC_ANA_ETH1_FLOW_ADDR_MATCH2(0), val);\n\t\tvsc85xx_ts_write_csr(phydev, blk,\n\t\t\t\t     MSCC_ANA_ETH1_FLOW_ADDR_MATCH1(0), 0);\n\t}\n\n\tval = vsc85xx_ts_read_csr(phydev, blk, MSCC_ANA_ETH1_FLOW_ENA(0));\n\tval &= ~ETH1_FLOW_ENA;\n\tif (enable)\n\t\tval |= ETH1_FLOW_ENA;\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_ETH1_FLOW_ENA(0), val);\n\n\treturn 0;\n}\n\nstatic int vsc85xx_ip1_conf(struct phy_device *phydev, enum ts_blk blk,\n\t\t\t    bool enable)\n{\n\tu32 val;\n\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_IP1_NXT_PROT_IP1_MODE,\n\t\t\t     ANA_IP1_NXT_PROT_IPV4 |\n\t\t\t     ANA_IP1_NXT_PROT_FLOW_OFFSET_IPV4);\n\n\t \n\tval = ANA_IP1_NXT_PROT_IP_MATCH1_PROT_MASK(0xff) |\n\t      ANA_IP1_NXT_PROT_IP_MATCH1_PROT_MATCH(IPPROTO_UDP) |\n\t      ANA_IP1_NXT_PROT_IP_MATCH1_PROT_OFF(9);\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_IP1_NXT_PROT_IP_MATCH1,\n\t\t\t     val);\n\n\t \n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_IP1_NXT_PROT_OFFSET2,\n\t\t\t     ANA_IP1_NXT_PROT_OFFSET2(20));\n\n\tval = vsc85xx_ts_read_csr(phydev, blk,\n\t\t\t\t  MSCC_ANA_IP1_NXT_PROT_UDP_CHKSUM);\n\tval &= ~(IP1_NXT_PROT_UDP_CHKSUM_OFF_MASK |\n\t\t IP1_NXT_PROT_UDP_CHKSUM_WIDTH_MASK);\n\tval |= IP1_NXT_PROT_UDP_CHKSUM_WIDTH(2);\n\n\tval &= ~(IP1_NXT_PROT_UDP_CHKSUM_UPDATE |\n\t\t IP1_NXT_PROT_UDP_CHKSUM_CLEAR);\n\t \n\tval |= IP1_NXT_PROT_UDP_CHKSUM_OFF(26) | IP1_NXT_PROT_UDP_CHKSUM_CLEAR;\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_IP1_NXT_PROT_UDP_CHKSUM,\n\t\t\t     val);\n\n\tval = vsc85xx_ts_read_csr(phydev, blk, MSCC_ANA_IP1_FLOW_ENA(0));\n\tval &= ~(IP1_FLOW_MATCH_ADDR_MASK | IP1_FLOW_ENA);\n\tval |= IP1_FLOW_MATCH_DEST_SRC_ADDR;\n\tif (enable)\n\t\tval |= IP1_FLOW_ENA;\n\tvsc85xx_ts_write_csr(phydev, blk, MSCC_ANA_IP1_FLOW_ENA(0), val);\n\n\treturn 0;\n}\n\nstatic int vsc85xx_ts_engine_init(struct phy_device *phydev, bool one_step)\n{\n\tstruct vsc8531_private *vsc8531 = phydev->priv;\n\tbool ptp_l4, base = phydev->mdio.addr == vsc8531->ts_base_addr;\n\tu8 eng_id = base ? 0 : 1;\n\tu32 val;\n\n\tptp_l4 = vsc8531->ptp->rx_filter == HWTSTAMP_FILTER_PTP_V2_L4_EVENT;\n\n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t  MSCC_PHY_PTP_ANALYZER_MODE);\n\t \n\tval &= ~(PTP_ANALYZER_MODE_EGR_ENA(BIT(eng_id)) |\n\t\t PTP_ANALYZER_MODE_INGR_ENA(BIT(eng_id)));\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_ANALYZER_MODE,\n\t\t\t     val);\n\n\tif (vsc8531->ptp->rx_filter == HWTSTAMP_FILTER_PTP_V2_L2_EVENT) {\n\t\tvsc85xx_eth1_next_comp(phydev, INGRESS,\n\t\t\t\t       ANA_ETH1_NTX_PROT_PTP_OAM, ETH_P_1588);\n\t\tvsc85xx_eth1_next_comp(phydev, EGRESS,\n\t\t\t\t       ANA_ETH1_NTX_PROT_PTP_OAM, ETH_P_1588);\n\t} else {\n\t\tvsc85xx_eth1_next_comp(phydev, INGRESS,\n\t\t\t\t       ANA_ETH1_NTX_PROT_IP_UDP_ACH_1,\n\t\t\t\t       ETH_P_IP);\n\t\tvsc85xx_eth1_next_comp(phydev, EGRESS,\n\t\t\t\t       ANA_ETH1_NTX_PROT_IP_UDP_ACH_1,\n\t\t\t\t       ETH_P_IP);\n\t\t \n\t\tvsc85xx_ip1_next_comp(phydev, INGRESS,\n\t\t\t\t      ANA_ETH1_NTX_PROT_PTP_OAM, 28);\n\t\tvsc85xx_ip1_next_comp(phydev, EGRESS,\n\t\t\t\t      ANA_ETH1_NTX_PROT_PTP_OAM, 28);\n\t}\n\n\tvsc85xx_eth1_conf(phydev, INGRESS,\n\t\t\t  vsc8531->ptp->rx_filter != HWTSTAMP_FILTER_NONE);\n\tvsc85xx_ip1_conf(phydev, INGRESS,\n\t\t\t ptp_l4 && vsc8531->ptp->rx_filter != HWTSTAMP_FILTER_NONE);\n\tvsc85xx_ptp_conf(phydev, INGRESS, one_step,\n\t\t\t vsc8531->ptp->rx_filter != HWTSTAMP_FILTER_NONE);\n\n\tvsc85xx_eth1_conf(phydev, EGRESS,\n\t\t\t  vsc8531->ptp->tx_type != HWTSTAMP_TX_OFF);\n\tvsc85xx_ip1_conf(phydev, EGRESS,\n\t\t\t ptp_l4 && vsc8531->ptp->tx_type != HWTSTAMP_TX_OFF);\n\tvsc85xx_ptp_conf(phydev, EGRESS, one_step,\n\t\t\t vsc8531->ptp->tx_type != HWTSTAMP_TX_OFF);\n\n\tval &= ~PTP_ANALYZER_MODE_EGR_ENA(BIT(eng_id));\n\tif (vsc8531->ptp->tx_type != HWTSTAMP_TX_OFF)\n\t\tval |= PTP_ANALYZER_MODE_EGR_ENA(BIT(eng_id));\n\n\tval &= ~PTP_ANALYZER_MODE_INGR_ENA(BIT(eng_id));\n\tif (vsc8531->ptp->rx_filter != HWTSTAMP_FILTER_NONE)\n\t\tval |= PTP_ANALYZER_MODE_INGR_ENA(BIT(eng_id));\n\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_ANALYZER_MODE,\n\t\t\t     val);\n\n\treturn 0;\n}\n\nvoid vsc85xx_link_change_notify(struct phy_device *phydev)\n{\n\tstruct vsc8531_private *priv = phydev->priv;\n\n\tmutex_lock(&priv->ts_lock);\n\tvsc85xx_ts_set_latencies(phydev);\n\tmutex_unlock(&priv->ts_lock);\n}\n\nstatic void vsc85xx_ts_reset_fifo(struct phy_device *phydev)\n{\n\tu32 val;\n\n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t  MSCC_PHY_PTP_EGR_TS_FIFO_CTRL);\n\tval |= PTP_EGR_TS_FIFO_RESET;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_EGR_TS_FIFO_CTRL,\n\t\t\t     val);\n\n\tval &= ~PTP_EGR_TS_FIFO_RESET;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_EGR_TS_FIFO_CTRL,\n\t\t\t     val);\n}\n\nstatic int vsc85xx_hwtstamp(struct mii_timestamper *mii_ts, struct ifreq *ifr)\n{\n\tstruct vsc8531_private *vsc8531 =\n\t\tcontainer_of(mii_ts, struct vsc8531_private, mii_ts);\n\tstruct phy_device *phydev = vsc8531->ptp->phydev;\n\tstruct hwtstamp_config cfg;\n\tbool one_step = false;\n\tu32 val;\n\n\tif (copy_from_user(&cfg, ifr->ifr_data, sizeof(cfg)))\n\t\treturn -EFAULT;\n\n\tswitch (cfg.tx_type) {\n\tcase HWTSTAMP_TX_ONESTEP_SYNC:\n\t\tone_step = true;\n\t\tbreak;\n\tcase HWTSTAMP_TX_ON:\n\t\tbreak;\n\tcase HWTSTAMP_TX_OFF:\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tvsc8531->ptp->tx_type = cfg.tx_type;\n\n\tswitch (cfg.rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\t\t \n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tvsc8531->ptp->rx_filter = cfg.rx_filter;\n\n\tmutex_lock(&vsc8531->ts_lock);\n\n\t__skb_queue_purge(&vsc8531->ptp->tx_queue);\n\t__skb_queue_head_init(&vsc8531->ptp->tx_queue);\n\n\t \n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t  MSCC_PHY_PTP_INGR_PREDICTOR);\n\tval &= ~PTP_INGR_PREDICTOR_EN;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_INGR_PREDICTOR,\n\t\t\t     val);\n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t  MSCC_PHY_PTP_EGR_PREDICTOR);\n\tval &= ~PTP_EGR_PREDICTOR_EN;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_EGR_PREDICTOR,\n\t\t\t     val);\n\n\t \n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR, MSCC_PHY_PTP_IFACE_CTRL);\n\tval &= ~(PTP_IFACE_CTRL_EGR_BYPASS | PTP_IFACE_CTRL_INGR_BYPASS);\n\tif (vsc8531->ptp->tx_type == HWTSTAMP_TX_OFF)\n\t\tval |= PTP_IFACE_CTRL_EGR_BYPASS;\n\tif (vsc8531->ptp->rx_filter == HWTSTAMP_FILTER_NONE)\n\t\tval |= PTP_IFACE_CTRL_INGR_BYPASS;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_IFACE_CTRL, val);\n\n\t \n\tvsc85xx_ts_reset_fifo(phydev);\n\n\tvsc85xx_ts_engine_init(phydev, one_step);\n\n\t \n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t  MSCC_PHY_PTP_INGR_PREDICTOR);\n\tval |= PTP_INGR_PREDICTOR_EN;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_INGR_PREDICTOR,\n\t\t\t     val);\n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t  MSCC_PHY_PTP_EGR_PREDICTOR);\n\tval |= PTP_EGR_PREDICTOR_EN;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_EGR_PREDICTOR,\n\t\t\t     val);\n\n\tvsc8531->ptp->configured = 1;\n\tmutex_unlock(&vsc8531->ts_lock);\n\n\treturn copy_to_user(ifr->ifr_data, &cfg, sizeof(cfg)) ? -EFAULT : 0;\n}\n\nstatic int vsc85xx_ts_info(struct mii_timestamper *mii_ts,\n\t\t\t   struct ethtool_ts_info *info)\n{\n\tstruct vsc8531_private *vsc8531 =\n\t\tcontainer_of(mii_ts, struct vsc8531_private, mii_ts);\n\n\tinfo->phc_index = ptp_clock_index(vsc8531->ptp->ptp_clock);\n\tinfo->so_timestamping =\n\t\tSOF_TIMESTAMPING_TX_HARDWARE |\n\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\tinfo->tx_types =\n\t\t(1 << HWTSTAMP_TX_OFF) |\n\t\t(1 << HWTSTAMP_TX_ON) |\n\t\t(1 << HWTSTAMP_TX_ONESTEP_SYNC);\n\tinfo->rx_filters =\n\t\t(1 << HWTSTAMP_FILTER_NONE) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L2_EVENT) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT);\n\n\treturn 0;\n}\n\nstatic void vsc85xx_txtstamp(struct mii_timestamper *mii_ts,\n\t\t\t     struct sk_buff *skb, int type)\n{\n\tstruct vsc8531_private *vsc8531 =\n\t\tcontainer_of(mii_ts, struct vsc8531_private, mii_ts);\n\n\tif (!vsc8531->ptp->configured)\n\t\treturn;\n\n\tif (vsc8531->ptp->tx_type == HWTSTAMP_TX_OFF) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\n\tmutex_lock(&vsc8531->ts_lock);\n\t__skb_queue_tail(&vsc8531->ptp->tx_queue, skb);\n\tmutex_unlock(&vsc8531->ts_lock);\n}\n\nstatic bool vsc85xx_rxtstamp(struct mii_timestamper *mii_ts,\n\t\t\t     struct sk_buff *skb, int type)\n{\n\tstruct vsc8531_private *vsc8531 =\n\t\tcontainer_of(mii_ts, struct vsc8531_private, mii_ts);\n\tstruct skb_shared_hwtstamps *shhwtstamps = NULL;\n\tstruct vsc85xx_ptphdr *ptphdr;\n\tstruct timespec64 ts;\n\tunsigned long ns;\n\n\tif (!vsc8531->ptp->configured)\n\t\treturn false;\n\n\tif (vsc8531->ptp->rx_filter == HWTSTAMP_FILTER_NONE ||\n\t    type == PTP_CLASS_NONE)\n\t\treturn false;\n\n\tvsc85xx_gettime(&vsc8531->ptp->caps, &ts);\n\n\tptphdr = get_ptp_header_rx(skb, vsc8531->ptp->rx_filter);\n\tif (!ptphdr)\n\t\treturn false;\n\n\tshhwtstamps = skb_hwtstamps(skb);\n\tmemset(shhwtstamps, 0, sizeof(struct skb_shared_hwtstamps));\n\n\tns = ntohl(ptphdr->rsrvd2);\n\n\t \n\tif (ts.tv_nsec < ns)\n\t\tts.tv_sec--;\n\n\tshhwtstamps->hwtstamp = ktime_set(ts.tv_sec, ns);\n\tnetif_rx(skb);\n\n\treturn true;\n}\n\nstatic const struct ptp_clock_info vsc85xx_clk_caps = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"VSC85xx timer\",\n\t.max_adj\t= S32_MAX,\n\t.n_alarm\t= 0,\n\t.n_pins\t\t= 0,\n\t.n_ext_ts\t= 0,\n\t.n_per_out\t= 0,\n\t.pps\t\t= 0,\n\t.adjtime        = &vsc85xx_adjtime,\n\t.adjfine\t= &vsc85xx_adjfine,\n\t.gettime64\t= &vsc85xx_gettime,\n\t.settime64\t= &vsc85xx_settime,\n};\n\nstatic struct vsc8531_private *vsc8584_base_priv(struct phy_device *phydev)\n{\n\tstruct vsc8531_private *vsc8531 = phydev->priv;\n\n\tif (vsc8531->ts_base_addr != phydev->mdio.addr) {\n\t\tstruct mdio_device *dev;\n\n\t\tdev = phydev->mdio.bus->mdio_map[vsc8531->ts_base_addr];\n\t\tphydev = container_of(dev, struct phy_device, mdio);\n\n\t\treturn phydev->priv;\n\t}\n\n\treturn vsc8531;\n}\n\nstatic bool vsc8584_is_1588_input_clk_configured(struct phy_device *phydev)\n{\n\tstruct vsc8531_private *vsc8531 = vsc8584_base_priv(phydev);\n\n\treturn vsc8531->input_clk_init;\n}\n\nstatic void vsc8584_set_input_clk_configured(struct phy_device *phydev)\n{\n\tstruct vsc8531_private *vsc8531 = vsc8584_base_priv(phydev);\n\n\tvsc8531->input_clk_init = true;\n}\n\nstatic int __vsc8584_init_ptp(struct phy_device *phydev)\n{\n\tstruct vsc8531_private *vsc8531 = phydev->priv;\n\tstatic const u32 ltc_seq_e[] = { 0, 400000, 0, 0, 0 };\n\tstatic const u8  ltc_seq_a[] = { 8, 6, 5, 4, 2 };\n\tu32 val;\n\n\tif (!vsc8584_is_1588_input_clk_configured(phydev)) {\n\t\tphy_lock_mdio_bus(phydev);\n\n\t\t \n\t\tphy_ts_base_write(phydev, MSCC_EXT_PAGE_ACCESS,\n\t\t\t\t  MSCC_PHY_PAGE_1588);\n\t\tphy_ts_base_write(phydev, 29, 0x7ae0);\n\t\tphy_ts_base_write(phydev, 30, 0xb71c);\n\t\tphy_ts_base_write(phydev, MSCC_EXT_PAGE_ACCESS,\n\t\t\t\t  MSCC_PHY_PAGE_STANDARD);\n\n\t\tphy_unlock_mdio_bus(phydev);\n\n\t\tvsc8584_set_input_clk_configured(phydev);\n\t}\n\n\t \n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t  MSCC_PHY_PTP_INGR_PREDICTOR);\n\tval &= ~PTP_INGR_PREDICTOR_EN;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_INGR_PREDICTOR,\n\t\t\t     val);\n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t  MSCC_PHY_PTP_EGR_PREDICTOR);\n\tval &= ~PTP_EGR_PREDICTOR_EN;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_EGR_PREDICTOR,\n\t\t\t     val);\n\n\t \n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR, MSCC_PHY_PTP_LTC_CTRL);\n\tval &= ~PTP_LTC_CTRL_CLK_SEL_MASK;\n\tval |= PTP_LTC_CTRL_CLK_SEL_INTERNAL_250;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_LTC_CTRL, val);\n\n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR, MSCC_PHY_PTP_LTC_SEQUENCE);\n\tval &= ~PTP_LTC_SEQUENCE_A_MASK;\n\tval |= PTP_LTC_SEQUENCE_A(ltc_seq_a[PHC_CLK_250MHZ]);\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_LTC_SEQUENCE, val);\n\n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR, MSCC_PHY_PTP_LTC_SEQ);\n\tval &= ~(PTP_LTC_SEQ_ERR_MASK | PTP_LTC_SEQ_ADD_SUB);\n\tif (ltc_seq_e[PHC_CLK_250MHZ])\n\t\tval |= PTP_LTC_SEQ_ADD_SUB;\n\tval |= PTP_LTC_SEQ_ERR(ltc_seq_e[PHC_CLK_250MHZ]);\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_LTC_SEQ, val);\n\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_LTC_1PPS_WIDTH_ADJ,\n\t\t\t     PPS_WIDTH_ADJ);\n\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_INGR_DELAY_FIFO,\n\t\t\t     IS_ENABLED(CONFIG_MACSEC) ?\n\t\t\t     PTP_INGR_DELAY_FIFO_DEPTH_MACSEC :\n\t\t\t     PTP_INGR_DELAY_FIFO_DEPTH_DEFAULT);\n\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_EGR_DELAY_FIFO,\n\t\t\t     IS_ENABLED(CONFIG_MACSEC) ?\n\t\t\t     PTP_EGR_DELAY_FIFO_DEPTH_MACSEC :\n\t\t\t     PTP_EGR_DELAY_FIFO_DEPTH_DEFAULT);\n\n\t \n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t  MSCC_PHY_PTP_ACCUR_CFG_STATUS);\n\tval &= ~(PTP_ACCUR_PPS_OUT_BYPASS | PTP_ACCUR_PPS_IN_BYPASS |\n\t\t PTP_ACCUR_EGR_SOF_BYPASS | PTP_ACCUR_INGR_SOF_BYPASS |\n\t\t PTP_ACCUR_LOAD_SAVE_BYPASS);\n\tval |= PTP_ACCUR_PPS_OUT_CALIB_ERR | PTP_ACCUR_PPS_OUT_CALIB_DONE |\n\t       PTP_ACCUR_PPS_IN_CALIB_ERR | PTP_ACCUR_PPS_IN_CALIB_DONE |\n\t       PTP_ACCUR_EGR_SOF_CALIB_ERR | PTP_ACCUR_EGR_SOF_CALIB_DONE |\n\t       PTP_ACCUR_INGR_SOF_CALIB_ERR | PTP_ACCUR_INGR_SOF_CALIB_DONE |\n\t       PTP_ACCUR_LOAD_SAVE_CALIB_ERR | PTP_ACCUR_LOAD_SAVE_CALIB_DONE;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_ACCUR_CFG_STATUS,\n\t\t\t     val);\n\n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t  MSCC_PHY_PTP_ACCUR_CFG_STATUS);\n\tval |= PTP_ACCUR_CALIB_TRIGG;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_ACCUR_CFG_STATUS,\n\t\t\t     val);\n\n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t  MSCC_PHY_PTP_ACCUR_CFG_STATUS);\n\tval &= ~PTP_ACCUR_CALIB_TRIGG;\n\tval |= PTP_ACCUR_PPS_OUT_CALIB_ERR | PTP_ACCUR_PPS_OUT_CALIB_DONE |\n\t       PTP_ACCUR_PPS_IN_CALIB_ERR | PTP_ACCUR_PPS_IN_CALIB_DONE |\n\t       PTP_ACCUR_EGR_SOF_CALIB_ERR | PTP_ACCUR_EGR_SOF_CALIB_DONE |\n\t       PTP_ACCUR_INGR_SOF_CALIB_ERR | PTP_ACCUR_INGR_SOF_CALIB_DONE |\n\t       PTP_ACCUR_LOAD_SAVE_CALIB_ERR | PTP_ACCUR_LOAD_SAVE_CALIB_DONE;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_ACCUR_CFG_STATUS,\n\t\t\t     val);\n\n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t  MSCC_PHY_PTP_ACCUR_CFG_STATUS);\n\tval |= PTP_ACCUR_CALIB_TRIGG;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_ACCUR_CFG_STATUS,\n\t\t\t     val);\n\n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t  MSCC_PHY_PTP_ACCUR_CFG_STATUS);\n\tval &= ~PTP_ACCUR_CALIB_TRIGG;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_ACCUR_CFG_STATUS,\n\t\t\t     val);\n\n\t \n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t  MSCC_PHY_PTP_TSTAMP_FIFO_SI);\n\tval &= ~PTP_TSTAMP_FIFO_SI_EN;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_TSTAMP_FIFO_SI,\n\t\t\t     val);\n\n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t  MSCC_PHY_PTP_INGR_REWRITER_CTRL);\n\tval &= ~PTP_INGR_REWRITER_REDUCE_PREAMBLE;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_INGR_REWRITER_CTRL,\n\t\t\t     val);\n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t  MSCC_PHY_PTP_EGR_REWRITER_CTRL);\n\tval &= ~PTP_EGR_REWRITER_REDUCE_PREAMBLE;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_EGR_REWRITER_CTRL,\n\t\t\t     val);\n\n\t \n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t  MSCC_PHY_PTP_INGR_REWRITER_CTRL);\n\tval |= PTP_INGR_REWRITER_FLAG_BIT_OFF(7) | PTP_INGR_REWRITER_FLAG_VAL;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_INGR_REWRITER_CTRL,\n\t\t\t     val);\n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t  MSCC_PHY_PTP_EGR_REWRITER_CTRL);\n\tval |= PTP_EGR_REWRITER_FLAG_BIT_OFF(7);\n\tval &= ~PTP_EGR_REWRITER_FLAG_VAL;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_EGR_REWRITER_CTRL,\n\t\t\t     val);\n\n\t \n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t  MSCC_PHY_PTP_INGR_TSP_CTRL);\n\tval |= PHY_PTP_INGR_TSP_CTRL_FRACT_NS;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_INGR_TSP_CTRL,\n\t\t\t     val);\n\n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR, MSCC_PHY_PTP_EGR_TSP_CTRL);\n\tval |= PHY_PTP_EGR_TSP_CTRL_FRACT_NS;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_EGR_TSP_CTRL, val);\n\n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t  MSCC_PHY_PTP_SERIAL_TOD_IFACE);\n\tval |= PTP_SERIAL_TOD_IFACE_LS_AUTO_CLR;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_SERIAL_TOD_IFACE,\n\t\t\t     val);\n\n\tvsc85xx_ts_fsb_init(phydev);\n\n\t \n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t  MSCC_PHY_PTP_EGR_TS_FIFO_CTRL);\n\tval &= ~(PTP_EGR_TS_FIFO_SIG_BYTES_MASK | PTP_EGR_TS_FIFO_THRESH_MASK);\n\t \n\tval |= PTP_EGR_TS_FIFO_SIG_BYTES(16) | PTP_EGR_TS_FIFO_THRESH(7);\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_EGR_TS_FIFO_CTRL,\n\t\t\t     val);\n\n\tvsc85xx_ts_reset_fifo(phydev);\n\n\tval = PTP_IFACE_CTRL_CLK_ENA;\n\tif (!IS_ENABLED(CONFIG_MACSEC))\n\t\tval |= PTP_IFACE_CTRL_GMII_PROT;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_IFACE_CTRL, val);\n\n\tvsc85xx_ts_set_latencies(phydev);\n\n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR, MSCC_PHY_PTP_VERSION_CODE);\n\n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR, MSCC_PHY_PTP_IFACE_CTRL);\n\tval |= PTP_IFACE_CTRL_EGR_BYPASS;\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_IFACE_CTRL, val);\n\n\tvsc85xx_ts_disable_flows(phydev, EGRESS);\n\tvsc85xx_ts_disable_flows(phydev, INGRESS);\n\n\tval = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t  MSCC_PHY_PTP_ANALYZER_MODE);\n\t \n\tval &= ~(PTP_ANALYZER_MODE_EGR_ENA_MASK |\n\t\t PTP_ANALYZER_MODE_INGR_ENA_MASK |\n\t\t PTP_ANA_INGR_ENCAP_FLOW_MODE_MASK |\n\t\t PTP_ANA_EGR_ENCAP_FLOW_MODE_MASK);\n\t \n\tval |= PTP_ANA_SPLIT_ENCAP_FLOW | PTP_ANA_INGR_ENCAP_FLOW_MODE(0x7) |\n\t       PTP_ANA_EGR_ENCAP_FLOW_MODE(0x7);\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_PTP_ANALYZER_MODE,\n\t\t\t     val);\n\n\t \n\tvsc85xx_eth_cmp1_init(phydev, INGRESS);\n\tvsc85xx_ip_cmp1_init(phydev, INGRESS);\n\tvsc85xx_ptp_cmp_init(phydev, INGRESS);\n\tvsc85xx_eth_cmp1_init(phydev, EGRESS);\n\tvsc85xx_ip_cmp1_init(phydev, EGRESS);\n\tvsc85xx_ptp_cmp_init(phydev, EGRESS);\n\n\tvsc85xx_ts_eth_cmp1_sig(phydev);\n\n\tvsc8531->mii_ts.rxtstamp = vsc85xx_rxtstamp;\n\tvsc8531->mii_ts.txtstamp = vsc85xx_txtstamp;\n\tvsc8531->mii_ts.hwtstamp = vsc85xx_hwtstamp;\n\tvsc8531->mii_ts.ts_info  = vsc85xx_ts_info;\n\tphydev->mii_ts = &vsc8531->mii_ts;\n\n\tmemcpy(&vsc8531->ptp->caps, &vsc85xx_clk_caps, sizeof(vsc85xx_clk_caps));\n\n\tvsc8531->ptp->ptp_clock = ptp_clock_register(&vsc8531->ptp->caps,\n\t\t\t\t\t\t     &phydev->mdio.dev);\n\treturn PTR_ERR_OR_ZERO(vsc8531->ptp->ptp_clock);\n}\n\nvoid vsc8584_config_ts_intr(struct phy_device *phydev)\n{\n\tstruct vsc8531_private *priv = phydev->priv;\n\n\tmutex_lock(&priv->ts_lock);\n\tvsc85xx_ts_write_csr(phydev, PROCESSOR, MSCC_PHY_1588_VSC85XX_INT_MASK,\n\t\t\t     VSC85XX_1588_INT_MASK_MASK);\n\tmutex_unlock(&priv->ts_lock);\n}\n\nint vsc8584_ptp_init(struct phy_device *phydev)\n{\n\tswitch (phydev->phy_id & phydev->drv->phy_id_mask) {\n\tcase PHY_ID_VSC8572:\n\tcase PHY_ID_VSC8574:\n\tcase PHY_ID_VSC8575:\n\tcase PHY_ID_VSC8582:\n\tcase PHY_ID_VSC8584:\n\t\treturn __vsc8584_init_ptp(phydev);\n\t}\n\n\treturn 0;\n}\n\nirqreturn_t vsc8584_handle_ts_interrupt(struct phy_device *phydev)\n{\n\tstruct vsc8531_private *priv = phydev->priv;\n\tint rc;\n\n\tmutex_lock(&priv->ts_lock);\n\trc = vsc85xx_ts_read_csr(phydev, PROCESSOR,\n\t\t\t\t MSCC_PHY_1588_VSC85XX_INT_STATUS);\n\t \n\tvsc85xx_ts_write_csr(phydev, PROCESSOR,\n\t\t\t     MSCC_PHY_1588_VSC85XX_INT_STATUS, rc);\n\n\tif (!(rc & VSC85XX_1588_INT_MASK_MASK)) {\n\t\tmutex_unlock(&priv->ts_lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (rc & VSC85XX_1588_INT_FIFO_ADD) {\n\t\tvsc85xx_get_tx_ts(priv->ptp);\n\t} else if (rc & VSC85XX_1588_INT_FIFO_OVERFLOW) {\n\t\t__skb_queue_purge(&priv->ptp->tx_queue);\n\t\tvsc85xx_ts_reset_fifo(phydev);\n\t}\n\n\tmutex_unlock(&priv->ts_lock);\n\treturn IRQ_HANDLED;\n}\n\nint vsc8584_ptp_probe(struct phy_device *phydev)\n{\n\tstruct vsc8531_private *vsc8531 = phydev->priv;\n\n\tvsc8531->ptp = devm_kzalloc(&phydev->mdio.dev, sizeof(*vsc8531->ptp),\n\t\t\t\t    GFP_KERNEL);\n\tif (!vsc8531->ptp)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&vsc8531->phc_lock);\n\tmutex_init(&vsc8531->ts_lock);\n\n\t \n\tvsc8531->load_save = devm_gpiod_get_optional(&phydev->mdio.dev, \"load-save\",\n\t\t\t\t\t\t     GPIOD_FLAGS_BIT_NONEXCLUSIVE |\n\t\t\t\t\t\t     GPIOD_OUT_LOW);\n\tif (IS_ERR(vsc8531->load_save)) {\n\t\tphydev_err(phydev, \"Can't get load-save GPIO (%ld)\\n\",\n\t\t\t   PTR_ERR(vsc8531->load_save));\n\t\treturn PTR_ERR(vsc8531->load_save);\n\t}\n\n\tvsc8531->ptp->phydev = phydev;\n\n\treturn 0;\n}\n\nint vsc8584_ptp_probe_once(struct phy_device *phydev)\n{\n\tstruct vsc85xx_shared_private *shared =\n\t\t(struct vsc85xx_shared_private *)phydev->shared->priv;\n\n\t \n\tmutex_init(&shared->gpio_lock);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}