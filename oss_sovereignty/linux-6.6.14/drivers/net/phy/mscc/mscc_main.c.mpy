{
  "module_name": "mscc_main.c",
  "hash_id": "c9652a0ed76f011301034c303362fb5f34fdb8669806ac5af1c8411e8ae34db5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/mscc/mscc_main.c",
  "human_readable_source": "\n \n\n#include <linux/firmware.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mdio.h>\n#include <linux/mii.h>\n#include <linux/phy.h>\n#include <linux/of.h>\n#include <linux/netdevice.h>\n#include <dt-bindings/net/mscc-phy-vsc8531.h>\n#include \"mscc_serdes.h\"\n#include \"mscc.h\"\n\nstatic const struct vsc85xx_hw_stat vsc85xx_hw_stats[] = {\n\t{\n\t\t.string\t= \"phy_receive_errors\",\n\t\t.reg\t= MSCC_PHY_ERR_RX_CNT,\n\t\t.page\t= MSCC_PHY_PAGE_STANDARD,\n\t\t.mask\t= ERR_CNT_MASK,\n\t}, {\n\t\t.string\t= \"phy_false_carrier\",\n\t\t.reg\t= MSCC_PHY_ERR_FALSE_CARRIER_CNT,\n\t\t.page\t= MSCC_PHY_PAGE_STANDARD,\n\t\t.mask\t= ERR_CNT_MASK,\n\t}, {\n\t\t.string\t= \"phy_cu_media_link_disconnect\",\n\t\t.reg\t= MSCC_PHY_ERR_LINK_DISCONNECT_CNT,\n\t\t.page\t= MSCC_PHY_PAGE_STANDARD,\n\t\t.mask\t= ERR_CNT_MASK,\n\t}, {\n\t\t.string\t= \"phy_cu_media_crc_good_count\",\n\t\t.reg\t= MSCC_PHY_CU_MEDIA_CRC_VALID_CNT,\n\t\t.page\t= MSCC_PHY_PAGE_EXTENDED,\n\t\t.mask\t= VALID_CRC_CNT_CRC_MASK,\n\t}, {\n\t\t.string\t= \"phy_cu_media_crc_error_count\",\n\t\t.reg\t= MSCC_PHY_EXT_PHY_CNTL_4,\n\t\t.page\t= MSCC_PHY_PAGE_EXTENDED,\n\t\t.mask\t= ERR_CNT_MASK,\n\t},\n};\n\nstatic const struct vsc85xx_hw_stat vsc8584_hw_stats[] = {\n\t{\n\t\t.string\t= \"phy_receive_errors\",\n\t\t.reg\t= MSCC_PHY_ERR_RX_CNT,\n\t\t.page\t= MSCC_PHY_PAGE_STANDARD,\n\t\t.mask\t= ERR_CNT_MASK,\n\t}, {\n\t\t.string\t= \"phy_false_carrier\",\n\t\t.reg\t= MSCC_PHY_ERR_FALSE_CARRIER_CNT,\n\t\t.page\t= MSCC_PHY_PAGE_STANDARD,\n\t\t.mask\t= ERR_CNT_MASK,\n\t}, {\n\t\t.string\t= \"phy_cu_media_link_disconnect\",\n\t\t.reg\t= MSCC_PHY_ERR_LINK_DISCONNECT_CNT,\n\t\t.page\t= MSCC_PHY_PAGE_STANDARD,\n\t\t.mask\t= ERR_CNT_MASK,\n\t}, {\n\t\t.string\t= \"phy_cu_media_crc_good_count\",\n\t\t.reg\t= MSCC_PHY_CU_MEDIA_CRC_VALID_CNT,\n\t\t.page\t= MSCC_PHY_PAGE_EXTENDED,\n\t\t.mask\t= VALID_CRC_CNT_CRC_MASK,\n\t}, {\n\t\t.string\t= \"phy_cu_media_crc_error_count\",\n\t\t.reg\t= MSCC_PHY_EXT_PHY_CNTL_4,\n\t\t.page\t= MSCC_PHY_PAGE_EXTENDED,\n\t\t.mask\t= ERR_CNT_MASK,\n\t}, {\n\t\t.string\t= \"phy_serdes_tx_good_pkt_count\",\n\t\t.reg\t= MSCC_PHY_SERDES_TX_VALID_CNT,\n\t\t.page\t= MSCC_PHY_PAGE_EXTENDED_3,\n\t\t.mask\t= VALID_CRC_CNT_CRC_MASK,\n\t}, {\n\t\t.string\t= \"phy_serdes_tx_bad_crc_count\",\n\t\t.reg\t= MSCC_PHY_SERDES_TX_CRC_ERR_CNT,\n\t\t.page\t= MSCC_PHY_PAGE_EXTENDED_3,\n\t\t.mask\t= ERR_CNT_MASK,\n\t}, {\n\t\t.string\t= \"phy_serdes_rx_good_pkt_count\",\n\t\t.reg\t= MSCC_PHY_SERDES_RX_VALID_CNT,\n\t\t.page\t= MSCC_PHY_PAGE_EXTENDED_3,\n\t\t.mask\t= VALID_CRC_CNT_CRC_MASK,\n\t}, {\n\t\t.string\t= \"phy_serdes_rx_bad_crc_count\",\n\t\t.reg\t= MSCC_PHY_SERDES_RX_CRC_ERR_CNT,\n\t\t.page\t= MSCC_PHY_PAGE_EXTENDED_3,\n\t\t.mask\t= ERR_CNT_MASK,\n\t},\n};\n\n#if IS_ENABLED(CONFIG_OF_MDIO)\nstatic const struct vsc8531_edge_rate_table edge_table[] = {\n\t{MSCC_VDDMAC_3300, { 0, 2,  4,  7, 10, 17, 29, 53} },\n\t{MSCC_VDDMAC_2500, { 0, 3,  6, 10, 14, 23, 37, 63} },\n\t{MSCC_VDDMAC_1800, { 0, 5,  9, 16, 23, 35, 52, 76} },\n\t{MSCC_VDDMAC_1500, { 0, 6, 14, 21, 29, 42, 58, 77} },\n};\n#endif\n\nstatic const int vsc85xx_internal_delay[] = {200, 800, 1100, 1700, 2000, 2300,\n\t\t\t\t\t     2600, 3400};\n\nstatic int vsc85xx_phy_read_page(struct phy_device *phydev)\n{\n\treturn __phy_read(phydev, MSCC_EXT_PAGE_ACCESS);\n}\n\nstatic int vsc85xx_phy_write_page(struct phy_device *phydev, int page)\n{\n\treturn __phy_write(phydev, MSCC_EXT_PAGE_ACCESS, page);\n}\n\nstatic int vsc85xx_get_sset_count(struct phy_device *phydev)\n{\n\tstruct vsc8531_private *priv = phydev->priv;\n\n\tif (!priv)\n\t\treturn 0;\n\n\treturn priv->nstats;\n}\n\nstatic void vsc85xx_get_strings(struct phy_device *phydev, u8 *data)\n{\n\tstruct vsc8531_private *priv = phydev->priv;\n\tint i;\n\n\tif (!priv)\n\t\treturn;\n\n\tfor (i = 0; i < priv->nstats; i++)\n\t\tstrscpy(data + i * ETH_GSTRING_LEN, priv->hw_stats[i].string,\n\t\t\tETH_GSTRING_LEN);\n}\n\nstatic u64 vsc85xx_get_stat(struct phy_device *phydev, int i)\n{\n\tstruct vsc8531_private *priv = phydev->priv;\n\tint val;\n\n\tval = phy_read_paged(phydev, priv->hw_stats[i].page,\n\t\t\t     priv->hw_stats[i].reg);\n\tif (val < 0)\n\t\treturn U64_MAX;\n\n\tval = val & priv->hw_stats[i].mask;\n\tpriv->stats[i] += val;\n\n\treturn priv->stats[i];\n}\n\nstatic void vsc85xx_get_stats(struct phy_device *phydev,\n\t\t\t      struct ethtool_stats *stats, u64 *data)\n{\n\tstruct vsc8531_private *priv = phydev->priv;\n\tint i;\n\n\tif (!priv)\n\t\treturn;\n\n\tfor (i = 0; i < priv->nstats; i++)\n\t\tdata[i] = vsc85xx_get_stat(phydev, i);\n}\n\nstatic int vsc85xx_led_cntl_set(struct phy_device *phydev,\n\t\t\t\tu8 led_num,\n\t\t\t\tu8 mode)\n{\n\tint rc;\n\tu16 reg_val;\n\n\tmutex_lock(&phydev->lock);\n\treg_val = phy_read(phydev, MSCC_PHY_LED_MODE_SEL);\n\treg_val &= ~LED_MODE_SEL_MASK(led_num);\n\treg_val |= LED_MODE_SEL(led_num, (u16)mode);\n\trc = phy_write(phydev, MSCC_PHY_LED_MODE_SEL, reg_val);\n\tmutex_unlock(&phydev->lock);\n\n\treturn rc;\n}\n\nstatic int vsc85xx_mdix_get(struct phy_device *phydev, u8 *mdix)\n{\n\tu16 reg_val;\n\n\treg_val = phy_read(phydev, MSCC_PHY_DEV_AUX_CNTL);\n\tif (reg_val & HP_AUTO_MDIX_X_OVER_IND_MASK)\n\t\t*mdix = ETH_TP_MDI_X;\n\telse\n\t\t*mdix = ETH_TP_MDI;\n\n\treturn 0;\n}\n\nstatic int vsc85xx_mdix_set(struct phy_device *phydev, u8 mdix)\n{\n\tint rc;\n\tu16 reg_val;\n\n\treg_val = phy_read(phydev, MSCC_PHY_BYPASS_CONTROL);\n\tif (mdix == ETH_TP_MDI || mdix == ETH_TP_MDI_X) {\n\t\treg_val |= (DISABLE_PAIR_SWAP_CORR_MASK |\n\t\t\t    DISABLE_POLARITY_CORR_MASK  |\n\t\t\t    DISABLE_HP_AUTO_MDIX_MASK);\n\t} else {\n\t\treg_val &= ~(DISABLE_PAIR_SWAP_CORR_MASK |\n\t\t\t     DISABLE_POLARITY_CORR_MASK  |\n\t\t\t     DISABLE_HP_AUTO_MDIX_MASK);\n\t}\n\trc = phy_write(phydev, MSCC_PHY_BYPASS_CONTROL, reg_val);\n\tif (rc)\n\t\treturn rc;\n\n\treg_val = 0;\n\n\tif (mdix == ETH_TP_MDI)\n\t\treg_val = FORCE_MDI_CROSSOVER_MDI;\n\telse if (mdix == ETH_TP_MDI_X)\n\t\treg_val = FORCE_MDI_CROSSOVER_MDIX;\n\n\trc = phy_modify_paged(phydev, MSCC_PHY_PAGE_EXTENDED,\n\t\t\t      MSCC_PHY_EXT_MODE_CNTL, FORCE_MDI_CROSSOVER_MASK,\n\t\t\t      reg_val);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn genphy_restart_aneg(phydev);\n}\n\nstatic int vsc85xx_downshift_get(struct phy_device *phydev, u8 *count)\n{\n\tint reg_val;\n\n\treg_val = phy_read_paged(phydev, MSCC_PHY_PAGE_EXTENDED,\n\t\t\t\t MSCC_PHY_ACTIPHY_CNTL);\n\tif (reg_val < 0)\n\t\treturn reg_val;\n\n\treg_val &= DOWNSHIFT_CNTL_MASK;\n\tif (!(reg_val & DOWNSHIFT_EN))\n\t\t*count = DOWNSHIFT_DEV_DISABLE;\n\telse\n\t\t*count = ((reg_val & ~DOWNSHIFT_EN) >> DOWNSHIFT_CNTL_POS) + 2;\n\n\treturn 0;\n}\n\nstatic int vsc85xx_downshift_set(struct phy_device *phydev, u8 count)\n{\n\tif (count == DOWNSHIFT_DEV_DEFAULT_COUNT) {\n\t\t \n\t\tcount = ((1 << DOWNSHIFT_CNTL_POS) | DOWNSHIFT_EN);\n\t} else if (count > DOWNSHIFT_COUNT_MAX || count == 1) {\n\t\tphydev_err(phydev, \"Downshift count should be 2,3,4 or 5\\n\");\n\t\treturn -ERANGE;\n\t} else if (count) {\n\t\t \n\t\tcount = (((count - 2) << DOWNSHIFT_CNTL_POS) | DOWNSHIFT_EN);\n\t}\n\n\treturn phy_modify_paged(phydev, MSCC_PHY_PAGE_EXTENDED,\n\t\t\t\tMSCC_PHY_ACTIPHY_CNTL, DOWNSHIFT_CNTL_MASK,\n\t\t\t\tcount);\n}\n\nstatic int vsc85xx_wol_set(struct phy_device *phydev,\n\t\t\t   struct ethtool_wolinfo *wol)\n{\n\tconst u8 *mac_addr = phydev->attached_dev->dev_addr;\n\tint rc;\n\tu16 reg_val;\n\tu8  i;\n\tu16 pwd[3] = {0, 0, 0};\n\tstruct ethtool_wolinfo *wol_conf = wol;\n\n\trc = phy_select_page(phydev, MSCC_PHY_PAGE_EXTENDED_2);\n\tif (rc < 0)\n\t\treturn phy_restore_page(phydev, rc, rc);\n\n\tif (wol->wolopts & WAKE_MAGIC) {\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(pwd); i++)\n\t\t\tpwd[i] = mac_addr[5 - (i * 2 + 1)] << 8 |\n\t\t\t\t mac_addr[5 - i * 2];\n\t\t__phy_write(phydev, MSCC_PHY_WOL_LOWER_MAC_ADDR, pwd[0]);\n\t\t__phy_write(phydev, MSCC_PHY_WOL_MID_MAC_ADDR, pwd[1]);\n\t\t__phy_write(phydev, MSCC_PHY_WOL_UPPER_MAC_ADDR, pwd[2]);\n\t} else {\n\t\t__phy_write(phydev, MSCC_PHY_WOL_LOWER_MAC_ADDR, 0);\n\t\t__phy_write(phydev, MSCC_PHY_WOL_MID_MAC_ADDR, 0);\n\t\t__phy_write(phydev, MSCC_PHY_WOL_UPPER_MAC_ADDR, 0);\n\t}\n\n\tif (wol_conf->wolopts & WAKE_MAGICSECURE) {\n\t\tfor (i = 0; i < ARRAY_SIZE(pwd); i++)\n\t\t\tpwd[i] = wol_conf->sopass[5 - (i * 2 + 1)] << 8 |\n\t\t\t\t wol_conf->sopass[5 - i * 2];\n\t\t__phy_write(phydev, MSCC_PHY_WOL_LOWER_PASSWD, pwd[0]);\n\t\t__phy_write(phydev, MSCC_PHY_WOL_MID_PASSWD, pwd[1]);\n\t\t__phy_write(phydev, MSCC_PHY_WOL_UPPER_PASSWD, pwd[2]);\n\t} else {\n\t\t__phy_write(phydev, MSCC_PHY_WOL_LOWER_PASSWD, 0);\n\t\t__phy_write(phydev, MSCC_PHY_WOL_MID_PASSWD, 0);\n\t\t__phy_write(phydev, MSCC_PHY_WOL_UPPER_PASSWD, 0);\n\t}\n\n\treg_val = __phy_read(phydev, MSCC_PHY_WOL_MAC_CONTROL);\n\tif (wol_conf->wolopts & WAKE_MAGICSECURE)\n\t\treg_val |= SECURE_ON_ENABLE;\n\telse\n\t\treg_val &= ~SECURE_ON_ENABLE;\n\t__phy_write(phydev, MSCC_PHY_WOL_MAC_CONTROL, reg_val);\n\n\trc = phy_restore_page(phydev, rc, rc > 0 ? 0 : rc);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (wol->wolopts & WAKE_MAGIC) {\n\t\t \n\t\treg_val = phy_read(phydev, MII_VSC85XX_INT_MASK);\n\t\treg_val |= MII_VSC85XX_INT_MASK_WOL;\n\t\trc = phy_write(phydev, MII_VSC85XX_INT_MASK, reg_val);\n\t\tif (rc)\n\t\t\treturn rc;\n\t} else {\n\t\t \n\t\treg_val = phy_read(phydev, MII_VSC85XX_INT_MASK);\n\t\treg_val &= (~MII_VSC85XX_INT_MASK_WOL);\n\t\trc = phy_write(phydev, MII_VSC85XX_INT_MASK, reg_val);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\t \n\treg_val = phy_read(phydev, MII_VSC85XX_INT_STATUS);\n\n\treturn 0;\n}\n\nstatic void vsc85xx_wol_get(struct phy_device *phydev,\n\t\t\t    struct ethtool_wolinfo *wol)\n{\n\tint rc;\n\tu16 reg_val;\n\tu8  i;\n\tu16 pwd[3] = {0, 0, 0};\n\tstruct ethtool_wolinfo *wol_conf = wol;\n\n\trc = phy_select_page(phydev, MSCC_PHY_PAGE_EXTENDED_2);\n\tif (rc < 0)\n\t\tgoto out_restore_page;\n\n\treg_val = __phy_read(phydev, MSCC_PHY_WOL_MAC_CONTROL);\n\tif (reg_val & SECURE_ON_ENABLE)\n\t\twol_conf->wolopts |= WAKE_MAGICSECURE;\n\tif (wol_conf->wolopts & WAKE_MAGICSECURE) {\n\t\tpwd[0] = __phy_read(phydev, MSCC_PHY_WOL_LOWER_PASSWD);\n\t\tpwd[1] = __phy_read(phydev, MSCC_PHY_WOL_MID_PASSWD);\n\t\tpwd[2] = __phy_read(phydev, MSCC_PHY_WOL_UPPER_PASSWD);\n\t\tfor (i = 0; i < ARRAY_SIZE(pwd); i++) {\n\t\t\twol_conf->sopass[5 - i * 2] = pwd[i] & 0x00ff;\n\t\t\twol_conf->sopass[5 - (i * 2 + 1)] = (pwd[i] & 0xff00)\n\t\t\t\t\t\t\t    >> 8;\n\t\t}\n\t}\n\nout_restore_page:\n\tphy_restore_page(phydev, rc, rc > 0 ? 0 : rc);\n}\n\n#if IS_ENABLED(CONFIG_OF_MDIO)\nstatic int vsc85xx_edge_rate_magic_get(struct phy_device *phydev)\n{\n\tu32 vdd, sd;\n\tint i, j;\n\tstruct device *dev = &phydev->mdio.dev;\n\tstruct device_node *of_node = dev->of_node;\n\tu8 sd_array_size = ARRAY_SIZE(edge_table[0].slowdown);\n\n\tif (!of_node)\n\t\treturn -ENODEV;\n\n\tif (of_property_read_u32(of_node, \"vsc8531,vddmac\", &vdd))\n\t\tvdd = MSCC_VDDMAC_3300;\n\n\tif (of_property_read_u32(of_node, \"vsc8531,edge-slowdown\", &sd))\n\t\tsd = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(edge_table); i++)\n\t\tif (edge_table[i].vddmac == vdd)\n\t\t\tfor (j = 0; j < sd_array_size; j++)\n\t\t\t\tif (edge_table[i].slowdown[j] == sd)\n\t\t\t\t\treturn (sd_array_size - j - 1);\n\n\treturn -EINVAL;\n}\n\nstatic int vsc85xx_dt_led_mode_get(struct phy_device *phydev,\n\t\t\t\t   char *led,\n\t\t\t\t   u32 default_mode)\n{\n\tstruct vsc8531_private *priv = phydev->priv;\n\tstruct device *dev = &phydev->mdio.dev;\n\tstruct device_node *of_node = dev->of_node;\n\tu32 led_mode;\n\tint err;\n\n\tif (!of_node)\n\t\treturn -ENODEV;\n\n\tled_mode = default_mode;\n\terr = of_property_read_u32(of_node, led, &led_mode);\n\tif (!err && !(BIT(led_mode) & priv->supp_led_modes)) {\n\t\tphydev_err(phydev, \"DT %s invalid\\n\", led);\n\t\treturn -EINVAL;\n\t}\n\n\treturn led_mode;\n}\n\n#else\nstatic int vsc85xx_edge_rate_magic_get(struct phy_device *phydev)\n{\n\treturn 0;\n}\n\nstatic int vsc85xx_dt_led_mode_get(struct phy_device *phydev,\n\t\t\t\t   char *led,\n\t\t\t\t   u8 default_mode)\n{\n\treturn default_mode;\n}\n#endif  \n\nstatic int vsc85xx_dt_led_modes_get(struct phy_device *phydev,\n\t\t\t\t    u32 *default_mode)\n{\n\tstruct vsc8531_private *priv = phydev->priv;\n\tchar led_dt_prop[28];\n\tint i, ret;\n\n\tfor (i = 0; i < priv->nleds; i++) {\n\t\tret = sprintf(led_dt_prop, \"vsc8531,led-%d-mode\", i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = vsc85xx_dt_led_mode_get(phydev, led_dt_prop,\n\t\t\t\t\t      default_mode[i]);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tpriv->leds_mode[i] = ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int vsc85xx_edge_rate_cntl_set(struct phy_device *phydev, u8 edge_rate)\n{\n\tint rc;\n\n\tmutex_lock(&phydev->lock);\n\trc = phy_modify_paged(phydev, MSCC_PHY_PAGE_EXTENDED_2,\n\t\t\t      MSCC_PHY_WOL_MAC_CONTROL, EDGE_RATE_CNTL_MASK,\n\t\t\t      edge_rate << EDGE_RATE_CNTL_POS);\n\tmutex_unlock(&phydev->lock);\n\n\treturn rc;\n}\n\nstatic int vsc85xx_mac_if_set(struct phy_device *phydev,\n\t\t\t      phy_interface_t interface)\n{\n\tint rc;\n\tu16 reg_val;\n\n\tmutex_lock(&phydev->lock);\n\treg_val = phy_read(phydev, MSCC_PHY_EXT_PHY_CNTL_1);\n\treg_val &= ~(MAC_IF_SELECTION_MASK);\n\tswitch (interface) {\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII:\n\t\treg_val |= (MAC_IF_SELECTION_RGMII << MAC_IF_SELECTION_POS);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\treg_val |= (MAC_IF_SELECTION_RMII << MAC_IF_SELECTION_POS);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_MII:\n\tcase PHY_INTERFACE_MODE_GMII:\n\t\treg_val |= (MAC_IF_SELECTION_GMII << MAC_IF_SELECTION_POS);\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\trc = phy_write(phydev, MSCC_PHY_EXT_PHY_CNTL_1, reg_val);\n\tif (rc)\n\t\tgoto out_unlock;\n\n\trc = genphy_soft_reset(phydev);\n\nout_unlock:\n\tmutex_unlock(&phydev->lock);\n\n\treturn rc;\n}\n\n \nstatic int vsc85xx_update_rgmii_cntl(struct phy_device *phydev, u32 rgmii_cntl,\n\t\t\t\t     u16 rgmii_rx_delay_mask,\n\t\t\t\t     u16 rgmii_tx_delay_mask)\n{\n\tu16 rgmii_rx_delay_pos = ffs(rgmii_rx_delay_mask) - 1;\n\tu16 rgmii_tx_delay_pos = ffs(rgmii_tx_delay_mask) - 1;\n\tint delay_size = ARRAY_SIZE(vsc85xx_internal_delay);\n\tstruct device *dev = &phydev->mdio.dev;\n\tu16 reg_val = 0;\n\tu16 mask = 0;\n\ts32 rx_delay;\n\ts32 tx_delay;\n\tint rc = 0;\n\n\t \n\tif (rgmii_cntl == VSC8502_RGMII_CNTL)\n\t\tmask |= VSC8502_RGMII_RX_CLK_DISABLE;\n\n\tif (phy_interface_is_rgmii(phydev))\n\t\tmask |= rgmii_rx_delay_mask | rgmii_tx_delay_mask;\n\n\trx_delay = phy_get_internal_delay(phydev, dev, vsc85xx_internal_delay,\n\t\t\t\t\t  delay_size, true);\n\tif (rx_delay < 0) {\n\t\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID ||\n\t\t    phydev->interface == PHY_INTERFACE_MODE_RGMII_ID)\n\t\t\trx_delay = RGMII_CLK_DELAY_2_0_NS;\n\t\telse\n\t\t\trx_delay = RGMII_CLK_DELAY_0_2_NS;\n\t}\n\n\ttx_delay = phy_get_internal_delay(phydev, dev, vsc85xx_internal_delay,\n\t\t\t\t\t  delay_size, false);\n\tif (tx_delay < 0) {\n\t\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID ||\n\t\t    phydev->interface == PHY_INTERFACE_MODE_RGMII_ID)\n\t\t\ttx_delay = RGMII_CLK_DELAY_2_0_NS;\n\t\telse\n\t\t\ttx_delay = RGMII_CLK_DELAY_0_2_NS;\n\t}\n\n\treg_val |= rx_delay << rgmii_rx_delay_pos;\n\treg_val |= tx_delay << rgmii_tx_delay_pos;\n\n\tif (mask)\n\t\trc = phy_modify_paged(phydev, MSCC_PHY_PAGE_EXTENDED_2,\n\t\t\t\t      rgmii_cntl, mask, reg_val);\n\n\treturn rc;\n}\n\nstatic int vsc85xx_default_config(struct phy_device *phydev)\n{\n\tphydev->mdix_ctrl = ETH_TP_MDI_AUTO;\n\n\treturn vsc85xx_update_rgmii_cntl(phydev, VSC8502_RGMII_CNTL,\n\t\t\t\t\t VSC8502_RGMII_RX_DELAY_MASK,\n\t\t\t\t\t VSC8502_RGMII_TX_DELAY_MASK);\n}\n\nstatic int vsc85xx_get_tunable(struct phy_device *phydev,\n\t\t\t       struct ethtool_tunable *tuna, void *data)\n{\n\tswitch (tuna->id) {\n\tcase ETHTOOL_PHY_DOWNSHIFT:\n\t\treturn vsc85xx_downshift_get(phydev, (u8 *)data);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int vsc85xx_set_tunable(struct phy_device *phydev,\n\t\t\t       struct ethtool_tunable *tuna,\n\t\t\t       const void *data)\n{\n\tswitch (tuna->id) {\n\tcase ETHTOOL_PHY_DOWNSHIFT:\n\t\treturn vsc85xx_downshift_set(phydev, *(u8 *)data);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n \nstatic void vsc85xx_tr_write(struct phy_device *phydev, u16 addr, u32 val)\n{\n\t__phy_write(phydev, MSCC_PHY_TR_MSB, val >> 16);\n\t__phy_write(phydev, MSCC_PHY_TR_LSB, val & GENMASK(15, 0));\n\t__phy_write(phydev, MSCC_PHY_TR_CNTL, TR_WRITE | TR_ADDR(addr));\n}\n\nstatic int vsc8531_pre_init_seq_set(struct phy_device *phydev)\n{\n\tint rc;\n\tstatic const struct reg_val init_seq[] = {\n\t\t{0x0f90, 0x00688980},\n\t\t{0x0696, 0x00000003},\n\t\t{0x07fa, 0x0050100f},\n\t\t{0x1686, 0x00000004},\n\t};\n\tunsigned int i;\n\tint oldpage;\n\n\trc = phy_modify_paged(phydev, MSCC_PHY_PAGE_STANDARD,\n\t\t\t      MSCC_PHY_EXT_CNTL_STATUS, SMI_BROADCAST_WR_EN,\n\t\t\t      SMI_BROADCAST_WR_EN);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = phy_modify_paged(phydev, MSCC_PHY_PAGE_TEST,\n\t\t\t      MSCC_PHY_TEST_PAGE_24, 0, 0x0400);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = phy_modify_paged(phydev, MSCC_PHY_PAGE_TEST,\n\t\t\t      MSCC_PHY_TEST_PAGE_5, 0x0a00, 0x0e00);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = phy_modify_paged(phydev, MSCC_PHY_PAGE_TEST,\n\t\t\t      MSCC_PHY_TEST_PAGE_8, TR_CLK_DISABLE, TR_CLK_DISABLE);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tmutex_lock(&phydev->lock);\n\toldpage = phy_select_page(phydev, MSCC_PHY_PAGE_TR);\n\tif (oldpage < 0)\n\t\tgoto out_unlock;\n\n\tfor (i = 0; i < ARRAY_SIZE(init_seq); i++)\n\t\tvsc85xx_tr_write(phydev, init_seq[i].reg, init_seq[i].val);\n\nout_unlock:\n\toldpage = phy_restore_page(phydev, oldpage, oldpage);\n\tmutex_unlock(&phydev->lock);\n\n\treturn oldpage;\n}\n\nstatic int vsc85xx_eee_init_seq_set(struct phy_device *phydev)\n{\n\tstatic const struct reg_val init_eee[] = {\n\t\t{0x0f82, 0x0012b00a},\n\t\t{0x1686, 0x00000004},\n\t\t{0x168c, 0x00d2c46f},\n\t\t{0x17a2, 0x00000620},\n\t\t{0x16a0, 0x00eeffdd},\n\t\t{0x16a6, 0x00071448},\n\t\t{0x16a4, 0x0013132f},\n\t\t{0x16a8, 0x00000000},\n\t\t{0x0ffc, 0x00c0a028},\n\t\t{0x0fe8, 0x0091b06c},\n\t\t{0x0fea, 0x00041600},\n\t\t{0x0f80, 0x00000af4},\n\t\t{0x0fec, 0x00901809},\n\t\t{0x0fee, 0x0000a6a1},\n\t\t{0x0ffe, 0x00b01007},\n\t\t{0x16b0, 0x00eeff00},\n\t\t{0x16b2, 0x00007000},\n\t\t{0x16b4, 0x00000814},\n\t};\n\tunsigned int i;\n\tint oldpage;\n\n\tmutex_lock(&phydev->lock);\n\toldpage = phy_select_page(phydev, MSCC_PHY_PAGE_TR);\n\tif (oldpage < 0)\n\t\tgoto out_unlock;\n\n\tfor (i = 0; i < ARRAY_SIZE(init_eee); i++)\n\t\tvsc85xx_tr_write(phydev, init_eee[i].reg, init_eee[i].val);\n\nout_unlock:\n\toldpage = phy_restore_page(phydev, oldpage, oldpage);\n\tmutex_unlock(&phydev->lock);\n\n\treturn oldpage;\n}\n\n \nint phy_base_write(struct phy_device *phydev, u32 regnum, u16 val)\n{\n\tif (unlikely(!mutex_is_locked(&phydev->mdio.bus->mdio_lock))) {\n\t\tdev_err(&phydev->mdio.dev, \"MDIO bus lock not held!\\n\");\n\t\tdump_stack();\n\t}\n\n\treturn __phy_package_write(phydev, regnum, val);\n}\n\n \nint phy_base_read(struct phy_device *phydev, u32 regnum)\n{\n\tif (unlikely(!mutex_is_locked(&phydev->mdio.bus->mdio_lock))) {\n\t\tdev_err(&phydev->mdio.dev, \"MDIO bus lock not held!\\n\");\n\t\tdump_stack();\n\t}\n\n\treturn __phy_package_read(phydev, regnum);\n}\n\nu32 vsc85xx_csr_read(struct phy_device *phydev,\n\t\t     enum csr_target target, u32 reg)\n{\n\tunsigned long deadline;\n\tu32 val, val_l, val_h;\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_CSR_CNTL);\n\n\t \n\n\t \n\tphy_base_write(phydev, MSCC_EXT_PAGE_CSR_CNTL_20,\n\t\t       MSCC_PHY_CSR_CNTL_20_TARGET(target >> 2));\n\n\tif ((target >> 2 == 0x1) || (target >> 2 == 0x3))\n\t\t \n\t\ttarget &= 0x3;\n\telse\n\t\ttarget = 0;\n\n\t \n\tphy_base_write(phydev, MSCC_EXT_PAGE_CSR_CNTL_19,\n\t\t       MSCC_PHY_CSR_CNTL_19_CMD | MSCC_PHY_CSR_CNTL_19_READ |\n\t\t       MSCC_PHY_CSR_CNTL_19_REG_ADDR(reg) |\n\t\t       MSCC_PHY_CSR_CNTL_19_TARGET(target));\n\n\t \n\tdeadline = jiffies + msecs_to_jiffies(PROC_CMD_NCOMPLETED_TIMEOUT_MS);\n\tdo {\n\t\tusleep_range(500, 1000);\n\t\tval = phy_base_read(phydev, MSCC_EXT_PAGE_CSR_CNTL_19);\n\t} while (time_before(jiffies, deadline) &&\n\t\t!(val & MSCC_PHY_CSR_CNTL_19_CMD));\n\n\tif (!(val & MSCC_PHY_CSR_CNTL_19_CMD))\n\t\treturn 0xffffffff;\n\n\t \n\tval_l = phy_base_read(phydev, MSCC_EXT_PAGE_CSR_CNTL_17);\n\n\t \n\tval_h = phy_base_read(phydev, MSCC_EXT_PAGE_CSR_CNTL_18);\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS,\n\t\t       MSCC_PHY_PAGE_STANDARD);\n\n\treturn (val_h << 16) | val_l;\n}\n\nint vsc85xx_csr_write(struct phy_device *phydev,\n\t\t      enum csr_target target, u32 reg, u32 val)\n{\n\tunsigned long deadline;\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_CSR_CNTL);\n\n\t \n\n\t \n\tphy_base_write(phydev, MSCC_EXT_PAGE_CSR_CNTL_20,\n\t\t       MSCC_PHY_CSR_CNTL_20_TARGET(target >> 2));\n\n\t \n\tphy_base_write(phydev, MSCC_EXT_PAGE_CSR_CNTL_17, (u16)val);\n\n\t \n\tphy_base_write(phydev, MSCC_EXT_PAGE_CSR_CNTL_18, (u16)(val >> 16));\n\n\tif ((target >> 2 == 0x1) || (target >> 2 == 0x3))\n\t\t \n\t\ttarget &= 0x3;\n\telse\n\t\ttarget = 0;\n\n\t \n\tphy_base_write(phydev, MSCC_EXT_PAGE_CSR_CNTL_19,\n\t\t       MSCC_PHY_CSR_CNTL_19_CMD |\n\t\t       MSCC_PHY_CSR_CNTL_19_REG_ADDR(reg) |\n\t\t       MSCC_PHY_CSR_CNTL_19_TARGET(target));\n\n\t \n\tdeadline = jiffies + msecs_to_jiffies(PROC_CMD_NCOMPLETED_TIMEOUT_MS);\n\tdo {\n\t\tusleep_range(500, 1000);\n\t\tval = phy_base_read(phydev, MSCC_EXT_PAGE_CSR_CNTL_19);\n\t} while (time_before(jiffies, deadline) &&\n\t\t !(val & MSCC_PHY_CSR_CNTL_19_CMD));\n\n\tif (!(val & MSCC_PHY_CSR_CNTL_19_CMD))\n\t\treturn -ETIMEDOUT;\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS,\n\t\t       MSCC_PHY_PAGE_STANDARD);\n\n\treturn 0;\n}\n\n \nstatic void vsc8584_csr_write(struct phy_device *phydev, u16 addr, u32 val)\n{\n\tphy_base_write(phydev, MSCC_PHY_TR_MSB, val >> 16);\n\tphy_base_write(phydev, MSCC_PHY_TR_LSB, val & GENMASK(15, 0));\n\tphy_base_write(phydev, MSCC_PHY_TR_CNTL, TR_WRITE | TR_ADDR(addr));\n}\n\n \nint vsc8584_cmd(struct phy_device *phydev, u16 val)\n{\n\tunsigned long deadline;\n\tu16 reg_val;\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS,\n\t\t       MSCC_PHY_PAGE_EXTENDED_GPIO);\n\n\tphy_base_write(phydev, MSCC_PHY_PROC_CMD, PROC_CMD_NCOMPLETED | val);\n\n\tdeadline = jiffies + msecs_to_jiffies(PROC_CMD_NCOMPLETED_TIMEOUT_MS);\n\tdo {\n\t\treg_val = phy_base_read(phydev, MSCC_PHY_PROC_CMD);\n\t} while (time_before(jiffies, deadline) &&\n\t\t (reg_val & PROC_CMD_NCOMPLETED) &&\n\t\t !(reg_val & PROC_CMD_FAILED));\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_STANDARD);\n\n\tif (reg_val & PROC_CMD_FAILED)\n\t\treturn -EIO;\n\n\tif (reg_val & PROC_CMD_NCOMPLETED)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\n \nstatic int vsc8584_micro_deassert_reset(struct phy_device *phydev,\n\t\t\t\t\tbool patch_en)\n{\n\tu32 enable, release;\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS,\n\t\t       MSCC_PHY_PAGE_EXTENDED_GPIO);\n\n\tenable = RUN_FROM_INT_ROM | MICRO_CLK_EN | DW8051_CLK_EN;\n\trelease = MICRO_NSOFT_RESET | RUN_FROM_INT_ROM | DW8051_CLK_EN |\n\t\tMICRO_CLK_EN;\n\n\tif (patch_en) {\n\t\tenable |= MICRO_PATCH_EN;\n\t\trelease |= MICRO_PATCH_EN;\n\n\t\t \n\t\tphy_base_write(phydev, MSCC_INT_MEM_CNTL, READ_RAM);\n\t}\n\n\t \n\tphy_base_write(phydev, MSCC_DW8051_CNTL_STATUS, enable);\n\t \n\tphy_base_write(phydev, MSCC_DW8051_CNTL_STATUS, release);\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_STANDARD);\n\n\treturn 0;\n}\n\n \nstatic int vsc8584_micro_assert_reset(struct phy_device *phydev)\n{\n\tint ret;\n\tu16 reg;\n\n\tret = vsc8584_cmd(phydev, PROC_CMD_NOP);\n\tif (ret)\n\t\treturn ret;\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS,\n\t\t       MSCC_PHY_PAGE_EXTENDED_GPIO);\n\n\treg = phy_base_read(phydev, MSCC_INT_MEM_CNTL);\n\treg &= ~EN_PATCH_RAM_TRAP_ADDR(4);\n\tphy_base_write(phydev, MSCC_INT_MEM_CNTL, reg);\n\n\tphy_base_write(phydev, MSCC_TRAP_ROM_ADDR(4), 0x005b);\n\tphy_base_write(phydev, MSCC_PATCH_RAM_ADDR(4), 0x005b);\n\n\treg = phy_base_read(phydev, MSCC_INT_MEM_CNTL);\n\treg |= EN_PATCH_RAM_TRAP_ADDR(4);\n\tphy_base_write(phydev, MSCC_INT_MEM_CNTL, reg);\n\n\tphy_base_write(phydev, MSCC_PHY_PROC_CMD, PROC_CMD_NOP);\n\n\treg = phy_base_read(phydev, MSCC_DW8051_CNTL_STATUS);\n\treg &= ~MICRO_NSOFT_RESET;\n\tphy_base_write(phydev, MSCC_DW8051_CNTL_STATUS, reg);\n\n\tphy_base_write(phydev, MSCC_PHY_PROC_CMD, PROC_CMD_MCB_ACCESS_MAC_CONF |\n\t\t       PROC_CMD_SGMII_PORT(0) | PROC_CMD_NO_MAC_CONF |\n\t\t       PROC_CMD_READ);\n\n\treg = phy_base_read(phydev, MSCC_INT_MEM_CNTL);\n\treg &= ~EN_PATCH_RAM_TRAP_ADDR(4);\n\tphy_base_write(phydev, MSCC_INT_MEM_CNTL, reg);\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_STANDARD);\n\n\treturn 0;\n}\n\n \nstatic int vsc8584_get_fw_crc(struct phy_device *phydev, u16 start, u16 size,\n\t\t\t      u16 *crc)\n{\n\tint ret;\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_EXTENDED);\n\n\tphy_base_write(phydev, MSCC_PHY_VERIPHY_CNTL_2, start);\n\tphy_base_write(phydev, MSCC_PHY_VERIPHY_CNTL_3, size);\n\n\t \n\tret = vsc8584_cmd(phydev, PROC_CMD_CRC16);\n\tif (ret)\n\t\tgoto out;\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_EXTENDED);\n\n\t*crc = phy_base_read(phydev, MSCC_PHY_VERIPHY_CNTL_2);\n\nout:\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_STANDARD);\n\n\treturn ret;\n}\n\n \nstatic int vsc8584_patch_fw(struct phy_device *phydev,\n\t\t\t    const struct firmware *fw)\n{\n\tint i, ret;\n\n\tret = vsc8584_micro_assert_reset(phydev);\n\tif (ret) {\n\t\tdev_err(&phydev->mdio.dev,\n\t\t\t\"%s: failed to assert reset of micro\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS,\n\t\t       MSCC_PHY_PAGE_EXTENDED_GPIO);\n\n\t \n\tphy_base_write(phydev, MSCC_DW8051_CNTL_STATUS, RUN_FROM_INT_ROM |\n\t\t       AUTOINC_ADDR | PATCH_RAM_CLK | MICRO_CLK_EN |\n\t\t       MICRO_CLK_DIVIDE(2));\n\tphy_base_write(phydev, MSCC_INT_MEM_CNTL, READ_PRAM | INT_MEM_WRITE_EN |\n\t\t       INT_MEM_DATA(2));\n\tphy_base_write(phydev, MSCC_INT_MEM_ADDR, 0x0000);\n\n\tfor (i = 0; i < fw->size; i++)\n\t\tphy_base_write(phydev, MSCC_INT_MEM_CNTL, READ_PRAM |\n\t\t\t       INT_MEM_WRITE_EN | fw->data[i]);\n\n\t \n\tphy_base_write(phydev, MSCC_INT_MEM_CNTL, READ_RAM);\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_STANDARD);\n\n\treturn 0;\n}\n\n \nstatic bool vsc8574_is_serdes_init(struct phy_device *phydev)\n{\n\tu16 reg;\n\tbool ret;\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS,\n\t\t       MSCC_PHY_PAGE_EXTENDED_GPIO);\n\n\treg = phy_base_read(phydev, MSCC_TRAP_ROM_ADDR(1));\n\tif (reg != 0x3eb7) {\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\treg = phy_base_read(phydev, MSCC_PATCH_RAM_ADDR(1));\n\tif (reg != 0x4012) {\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\treg = phy_base_read(phydev, MSCC_INT_MEM_CNTL);\n\tif (reg != EN_PATCH_RAM_TRAP_ADDR(1)) {\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\treg = phy_base_read(phydev, MSCC_DW8051_CNTL_STATUS);\n\tif ((MICRO_NSOFT_RESET | RUN_FROM_INT_ROM |  DW8051_CLK_EN |\n\t     MICRO_CLK_EN) != (reg & MSCC_DW8051_VLD_MASK)) {\n\t\tret = false;\n\t\tgoto out;\n\t}\n\n\tret = true;\nout:\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_STANDARD);\n\n\treturn ret;\n}\n\n \nstatic int vsc8574_config_pre_init(struct phy_device *phydev)\n{\n\tstatic const struct reg_val pre_init1[] = {\n\t\t{0x0fae, 0x000401bd},\n\t\t{0x0fac, 0x000f000f},\n\t\t{0x17a0, 0x00a0f147},\n\t\t{0x0fe4, 0x00052f54},\n\t\t{0x1792, 0x0027303d},\n\t\t{0x07fe, 0x00000704},\n\t\t{0x0fe0, 0x00060150},\n\t\t{0x0f82, 0x0012b00a},\n\t\t{0x0f80, 0x00000d74},\n\t\t{0x02e0, 0x00000012},\n\t\t{0x03a2, 0x00050208},\n\t\t{0x03b2, 0x00009186},\n\t\t{0x0fb0, 0x000e3700},\n\t\t{0x1688, 0x00049f81},\n\t\t{0x0fd2, 0x0000ffff},\n\t\t{0x168a, 0x00039fa2},\n\t\t{0x1690, 0x0020640b},\n\t\t{0x0258, 0x00002220},\n\t\t{0x025a, 0x00002a20},\n\t\t{0x025c, 0x00003060},\n\t\t{0x025e, 0x00003fa0},\n\t\t{0x03a6, 0x0000e0f0},\n\t\t{0x0f92, 0x00001489},\n\t\t{0x16a2, 0x00007000},\n\t\t{0x16a6, 0x00071448},\n\t\t{0x16a0, 0x00eeffdd},\n\t\t{0x0fe8, 0x0091b06c},\n\t\t{0x0fea, 0x00041600},\n\t\t{0x16b0, 0x00eeff00},\n\t\t{0x16b2, 0x00007000},\n\t\t{0x16b4, 0x00000814},\n\t\t{0x0f90, 0x00688980},\n\t\t{0x03a4, 0x0000d8f0},\n\t\t{0x0fc0, 0x00000400},\n\t\t{0x07fa, 0x0050100f},\n\t\t{0x0796, 0x00000003},\n\t\t{0x07f8, 0x00c3ff98},\n\t\t{0x0fa4, 0x0018292a},\n\t\t{0x168c, 0x00d2c46f},\n\t\t{0x17a2, 0x00000620},\n\t\t{0x16a4, 0x0013132f},\n\t\t{0x16a8, 0x00000000},\n\t\t{0x0ffc, 0x00c0a028},\n\t\t{0x0fec, 0x00901c09},\n\t\t{0x0fee, 0x0004a6a1},\n\t\t{0x0ffe, 0x00b01807},\n\t};\n\tstatic const struct reg_val pre_init2[] = {\n\t\t{0x0486, 0x0008a518},\n\t\t{0x0488, 0x006dc696},\n\t\t{0x048a, 0x00000912},\n\t\t{0x048e, 0x00000db6},\n\t\t{0x049c, 0x00596596},\n\t\t{0x049e, 0x00000514},\n\t\t{0x04a2, 0x00410280},\n\t\t{0x04a4, 0x00000000},\n\t\t{0x04a6, 0x00000000},\n\t\t{0x04a8, 0x00000000},\n\t\t{0x04aa, 0x00000000},\n\t\t{0x04ae, 0x007df7dd},\n\t\t{0x04b0, 0x006d95d4},\n\t\t{0x04b2, 0x00492410},\n\t};\n\tstruct device *dev = &phydev->mdio.dev;\n\tconst struct firmware *fw;\n\tunsigned int i;\n\tu16 crc, reg;\n\tbool serdes_init;\n\tint ret;\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_STANDARD);\n\n\t \n\treg = phy_base_read(phydev, MSCC_PHY_EXT_CNTL_STATUS);\n\treg |= SMI_BROADCAST_WR_EN;\n\tphy_base_write(phydev, MSCC_PHY_EXT_CNTL_STATUS, reg);\n\n\tphy_base_write(phydev, MII_VSC85XX_INT_MASK, 0);\n\n\t \n\tphy_base_write(phydev, MSCC_PHY_EXT_PHY_CNTL_2, 0x0040);\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_TEST);\n\n\tphy_base_write(phydev, MSCC_PHY_TEST_PAGE_20, 0x4320);\n\tphy_base_write(phydev, MSCC_PHY_TEST_PAGE_24, 0x0c00);\n\tphy_base_write(phydev, MSCC_PHY_TEST_PAGE_9, 0x18ca);\n\tphy_base_write(phydev, MSCC_PHY_TEST_PAGE_5, 0x1b20);\n\n\treg = phy_base_read(phydev, MSCC_PHY_TEST_PAGE_8);\n\treg |= TR_CLK_DISABLE;\n\tphy_base_write(phydev, MSCC_PHY_TEST_PAGE_8, reg);\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_TR);\n\n\tfor (i = 0; i < ARRAY_SIZE(pre_init1); i++)\n\t\tvsc8584_csr_write(phydev, pre_init1[i].reg, pre_init1[i].val);\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_EXTENDED_2);\n\n\tphy_base_write(phydev, MSCC_PHY_CU_PMD_TX_CNTL, 0x028e);\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_TR);\n\n\tfor (i = 0; i < ARRAY_SIZE(pre_init2); i++)\n\t\tvsc8584_csr_write(phydev, pre_init2[i].reg, pre_init2[i].val);\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_TEST);\n\n\treg = phy_base_read(phydev, MSCC_PHY_TEST_PAGE_8);\n\treg &= ~TR_CLK_DISABLE;\n\tphy_base_write(phydev, MSCC_PHY_TEST_PAGE_8, reg);\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_STANDARD);\n\n\t \n\treg = phy_base_read(phydev, MSCC_PHY_EXT_CNTL_STATUS);\n\treg &= ~SMI_BROADCAST_WR_EN;\n\tphy_base_write(phydev, MSCC_PHY_EXT_CNTL_STATUS, reg);\n\n\tret = request_firmware(&fw, MSCC_VSC8574_REVB_INT8051_FW, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to load firmware %s, ret: %d\\n\",\n\t\t\tMSCC_VSC8574_REVB_INT8051_FW, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = vsc8584_get_fw_crc(phydev,\n\t\t\t\t MSCC_VSC8574_REVB_INT8051_FW_START_ADDR,\n\t\t\t\t fw->size + 1, &crc);\n\tif (ret)\n\t\tgoto out;\n\n\tif (crc == MSCC_VSC8574_REVB_INT8051_FW_CRC) {\n\t\tserdes_init = vsc8574_is_serdes_init(phydev);\n\n\t\tif (!serdes_init) {\n\t\t\tret = vsc8584_micro_assert_reset(phydev);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"%s: failed to assert reset of micro\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdev_dbg(dev, \"FW CRC is not the expected one, patching FW\\n\");\n\n\t\tserdes_init = false;\n\n\t\tif (vsc8584_patch_fw(phydev, fw))\n\t\t\tdev_warn(dev,\n\t\t\t\t \"failed to patch FW, expect non-optimal device\\n\");\n\t}\n\n\tif (!serdes_init) {\n\t\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS,\n\t\t\t       MSCC_PHY_PAGE_EXTENDED_GPIO);\n\n\t\tphy_base_write(phydev, MSCC_TRAP_ROM_ADDR(1), 0x3eb7);\n\t\tphy_base_write(phydev, MSCC_PATCH_RAM_ADDR(1), 0x4012);\n\t\tphy_base_write(phydev, MSCC_INT_MEM_CNTL,\n\t\t\t       EN_PATCH_RAM_TRAP_ADDR(1));\n\n\t\tvsc8584_micro_deassert_reset(phydev, false);\n\n\t\t \n\t\tret = vsc8584_get_fw_crc(phydev,\n\t\t\t\t\t MSCC_VSC8574_REVB_INT8051_FW_START_ADDR,\n\t\t\t\t\t fw->size + 1, &crc);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (crc != MSCC_VSC8574_REVB_INT8051_FW_CRC)\n\t\t\tdev_warn(dev,\n\t\t\t\t \"FW CRC after patching is not the expected one, expect non-optimal device\\n\");\n\t}\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS,\n\t\t       MSCC_PHY_PAGE_EXTENDED_GPIO);\n\n\tret = vsc8584_cmd(phydev, PROC_CMD_1588_DEFAULT_INIT |\n\t\t\t  PROC_CMD_PHY_INIT);\n\nout:\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_STANDARD);\n\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\n \nstatic void vsc8584_pll5g_cfg2_wr(struct phy_device *phydev,\n\t\t\t\t  bool disable_fsm)\n{\n\tu32 rd_dat;\n\n\trd_dat = vsc85xx_csr_read(phydev, MACRO_CTRL, PHY_S6G_PLL5G_CFG2);\n\trd_dat &= ~BIT(PHY_S6G_CFG2_FSM_DIS);\n\trd_dat |= (disable_fsm << PHY_S6G_CFG2_FSM_DIS);\n\tvsc85xx_csr_write(phydev, MACRO_CTRL, PHY_S6G_PLL5G_CFG2, rd_dat);\n}\n\n \nstatic int vsc8584_mcb_rd_trig(struct phy_device *phydev,\n\t\t\t       u32 mcb_reg_addr, u8 mcb_slave_num)\n{\n\tu32 rd_dat = 0;\n\n\t \n\tvsc85xx_csr_write(phydev, MACRO_CTRL, mcb_reg_addr,\n\t\t\t  (0x40000000 | (1L << mcb_slave_num)));\n\n\treturn read_poll_timeout(vsc85xx_csr_read, rd_dat,\n\t\t\t\t !(rd_dat & 0x40000000),\n\t\t\t\t 4000, 200000, 0,\n\t\t\t\t phydev, MACRO_CTRL, mcb_reg_addr);\n}\n\n \nstatic int vsc8584_mcb_wr_trig(struct phy_device *phydev,\n\t\t\t       u32 mcb_reg_addr,\n\t\t\t       u8 mcb_slave_num)\n{\n\tu32 rd_dat = 0;\n\n\t \n\tvsc85xx_csr_write(phydev, MACRO_CTRL, mcb_reg_addr,\n\t\t\t  (0x80000000 | (1L << mcb_slave_num)));\n\n\treturn read_poll_timeout(vsc85xx_csr_read, rd_dat,\n\t\t\t\t !(rd_dat & 0x80000000),\n\t\t\t\t 4000, 200000, 0,\n\t\t\t\t phydev, MACRO_CTRL, mcb_reg_addr);\n}\n\n \nstatic int vsc8584_pll5g_reset(struct phy_device *phydev)\n{\n\tbool dis_fsm;\n\tint ret = 0;\n\n\tret = vsc8584_mcb_rd_trig(phydev, 0x11, 0);\n\tif (ret < 0)\n\t\tgoto done;\n\tdis_fsm = 1;\n\n\t \n\tvsc8584_pll5g_cfg2_wr(phydev, dis_fsm);\n\n\t \n\tret = vsc8584_mcb_wr_trig(phydev, 0x11, 0);\n\tif (ret < 0)\n\t\tgoto done;\n\n\t \n\tusleep_range(10000, 20000);\n\n\t \n\tret = vsc8584_mcb_rd_trig(phydev, 0x11, 0);\n\tif (ret < 0)\n\t\tgoto done;\n\tdis_fsm = 0;\n\n\t \n\tvsc8584_pll5g_cfg2_wr(phydev, dis_fsm);\n\n\t \n\tret = vsc8584_mcb_wr_trig(phydev, 0x11, 0);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tusleep_range(110000, 200000);\ndone:\n\treturn ret;\n}\n\n \nstatic int vsc8584_config_pre_init(struct phy_device *phydev)\n{\n\tstatic const struct reg_val pre_init1[] = {\n\t\t{0x07fa, 0x0050100f},\n\t\t{0x1688, 0x00049f81},\n\t\t{0x0f90, 0x00688980},\n\t\t{0x03a4, 0x0000d8f0},\n\t\t{0x0fc0, 0x00000400},\n\t\t{0x0f82, 0x0012b002},\n\t\t{0x1686, 0x00000004},\n\t\t{0x168c, 0x00d2c46f},\n\t\t{0x17a2, 0x00000620},\n\t\t{0x16a0, 0x00eeffdd},\n\t\t{0x16a6, 0x00071448},\n\t\t{0x16a4, 0x0013132f},\n\t\t{0x16a8, 0x00000000},\n\t\t{0x0ffc, 0x00c0a028},\n\t\t{0x0fe8, 0x0091b06c},\n\t\t{0x0fea, 0x00041600},\n\t\t{0x0f80, 0x00fffaff},\n\t\t{0x0fec, 0x00901809},\n\t\t{0x0ffe, 0x00b01007},\n\t\t{0x16b0, 0x00eeff00},\n\t\t{0x16b2, 0x00007000},\n\t\t{0x16b4, 0x00000814},\n\t};\n\tstatic const struct reg_val pre_init2[] = {\n\t\t{0x0486, 0x0008a518},\n\t\t{0x0488, 0x006dc696},\n\t\t{0x048a, 0x00000912},\n\t};\n\tconst struct firmware *fw;\n\tstruct device *dev = &phydev->mdio.dev;\n\tunsigned int i;\n\tu16 crc, reg;\n\tint ret;\n\n\tret = vsc8584_pll5g_reset(phydev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed LCPLL reset, ret: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_STANDARD);\n\n\t \n\treg = phy_base_read(phydev, MSCC_PHY_EXT_CNTL_STATUS);\n\treg |= SMI_BROADCAST_WR_EN;\n\tphy_base_write(phydev, MSCC_PHY_EXT_CNTL_STATUS, reg);\n\n\tphy_base_write(phydev, MII_VSC85XX_INT_MASK, 0);\n\n\treg = phy_base_read(phydev,  MSCC_PHY_BYPASS_CONTROL);\n\treg |= PARALLEL_DET_IGNORE_ADVERTISED;\n\tphy_base_write(phydev, MSCC_PHY_BYPASS_CONTROL, reg);\n\n\t \n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_EXTENDED_3);\n\n\tphy_base_write(phydev, MSCC_PHY_SERDES_TX_CRC_ERR_CNT, 0x2000);\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_TEST);\n\n\tphy_base_write(phydev, MSCC_PHY_TEST_PAGE_5, 0x1f20);\n\n\treg = phy_base_read(phydev, MSCC_PHY_TEST_PAGE_8);\n\treg |= TR_CLK_DISABLE;\n\tphy_base_write(phydev, MSCC_PHY_TEST_PAGE_8, reg);\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_TR);\n\n\tphy_base_write(phydev, MSCC_PHY_TR_CNTL, TR_WRITE | TR_ADDR(0x2fa4));\n\n\treg = phy_base_read(phydev, MSCC_PHY_TR_MSB);\n\treg &= ~0x007f;\n\treg |= 0x0019;\n\tphy_base_write(phydev, MSCC_PHY_TR_MSB, reg);\n\n\tphy_base_write(phydev, MSCC_PHY_TR_CNTL, TR_WRITE | TR_ADDR(0x0fa4));\n\n\tfor (i = 0; i < ARRAY_SIZE(pre_init1); i++)\n\t\tvsc8584_csr_write(phydev, pre_init1[i].reg, pre_init1[i].val);\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_EXTENDED_2);\n\n\tphy_base_write(phydev, MSCC_PHY_CU_PMD_TX_CNTL, 0x028e);\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_TR);\n\n\tfor (i = 0; i < ARRAY_SIZE(pre_init2); i++)\n\t\tvsc8584_csr_write(phydev, pre_init2[i].reg, pre_init2[i].val);\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_TEST);\n\n\treg = phy_base_read(phydev, MSCC_PHY_TEST_PAGE_8);\n\treg &= ~TR_CLK_DISABLE;\n\tphy_base_write(phydev, MSCC_PHY_TEST_PAGE_8, reg);\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_STANDARD);\n\n\t \n\treg = phy_base_read(phydev, MSCC_PHY_EXT_CNTL_STATUS);\n\treg &= ~SMI_BROADCAST_WR_EN;\n\tphy_base_write(phydev, MSCC_PHY_EXT_CNTL_STATUS, reg);\n\n\tret = request_firmware(&fw, MSCC_VSC8584_REVB_INT8051_FW, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to load firmware %s, ret: %d\\n\",\n\t\t\tMSCC_VSC8584_REVB_INT8051_FW, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = vsc8584_get_fw_crc(phydev,\n\t\t\t\t MSCC_VSC8584_REVB_INT8051_FW_START_ADDR,\n\t\t\t\t fw->size + 1, &crc);\n\tif (ret)\n\t\tgoto out;\n\n\tif (crc != MSCC_VSC8584_REVB_INT8051_FW_CRC) {\n\t\tdev_dbg(dev, \"FW CRC is not the expected one, patching FW\\n\");\n\t\tif (vsc8584_patch_fw(phydev, fw))\n\t\t\tdev_warn(dev,\n\t\t\t\t \"failed to patch FW, expect non-optimal device\\n\");\n\t}\n\n\tvsc8584_micro_deassert_reset(phydev, false);\n\n\t \n\tret = vsc8584_get_fw_crc(phydev,\n\t\t\t\t MSCC_VSC8584_REVB_INT8051_FW_START_ADDR,\n\t\t\t\t fw->size + 1, &crc);\n\tif (ret)\n\t\tgoto out;\n\n\tif (crc != MSCC_VSC8584_REVB_INT8051_FW_CRC)\n\t\tdev_warn(dev,\n\t\t\t \"FW CRC after patching is not the expected one, expect non-optimal device\\n\");\n\n\tret = vsc8584_micro_assert_reset(phydev);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_EXTENDED_GPIO);\n\treg = MSCC_ROM_TRAP_SERDES_6G_CFG;  \n\tret = phy_base_write(phydev, MSCC_TRAP_ROM_ADDR(1), reg);\n\tif (ret)\n\t\tgoto out;\n\n\treg = MSCC_RAM_TRAP_SERDES_6G_CFG;  \n\tret = phy_base_write(phydev, MSCC_PATCH_RAM_ADDR(1), reg);\n\tif (ret)\n\t\tgoto out;\n\n\treg = phy_base_read(phydev, MSCC_INT_MEM_CNTL);\n\treg |= PATCH_VEC_ZERO_EN;  \n\tret = phy_base_write(phydev, MSCC_INT_MEM_CNTL, reg);\n\tif (ret)\n\t\tgoto out;\n\n\tvsc8584_micro_deassert_reset(phydev, true);\n\nout:\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_STANDARD);\n\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\nstatic void vsc8584_get_base_addr(struct phy_device *phydev)\n{\n\tstruct vsc8531_private *vsc8531 = phydev->priv;\n\tu16 val, addr;\n\n\tphy_lock_mdio_bus(phydev);\n\t__phy_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_EXTENDED);\n\n\taddr = __phy_read(phydev, MSCC_PHY_EXT_PHY_CNTL_4);\n\taddr >>= PHY_CNTL_4_ADDR_POS;\n\n\tval = __phy_read(phydev, MSCC_PHY_ACTIPHY_CNTL);\n\n\t__phy_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_STANDARD);\n\tphy_unlock_mdio_bus(phydev);\n\n\t \n\tvsc8531->ts_base_addr = phydev->mdio.addr;\n\tvsc8531->ts_base_phy = addr;\n\n\tif (val & PHY_ADDR_REVERSED) {\n\t\tvsc8531->base_addr = phydev->mdio.addr + addr;\n\t\tif (addr > 1) {\n\t\t\tvsc8531->ts_base_addr += 2;\n\t\t\tvsc8531->ts_base_phy += 2;\n\t\t}\n\t} else {\n\t\tvsc8531->base_addr = phydev->mdio.addr - addr;\n\t\tif (addr > 1) {\n\t\t\tvsc8531->ts_base_addr -= 2;\n\t\t\tvsc8531->ts_base_phy -= 2;\n\t\t}\n\t}\n\n\tvsc8531->addr = addr;\n}\n\nstatic void vsc85xx_coma_mode_release(struct phy_device *phydev)\n{\n\t \n\n\t \n\tvsc85xx_phy_write_page(phydev, MSCC_PHY_PAGE_EXTENDED_GPIO);\n\t__phy_modify(phydev, MSCC_PHY_GPIO_CONTROL_2,\n\t\t     MSCC_PHY_COMA_MODE | MSCC_PHY_COMA_OUTPUT, 0);\n\tvsc85xx_phy_write_page(phydev, MSCC_PHY_PAGE_STANDARD);\n}\n\nstatic int vsc8584_config_host_serdes(struct phy_device *phydev)\n{\n\tstruct vsc8531_private *vsc8531 = phydev->priv;\n\tint ret;\n\tu16 val;\n\n\tret = phy_base_write(phydev, MSCC_EXT_PAGE_ACCESS,\n\t\t\t     MSCC_PHY_PAGE_EXTENDED_GPIO);\n\tif (ret)\n\t\treturn ret;\n\n\tval = phy_base_read(phydev, MSCC_PHY_MAC_CFG_FASTLINK);\n\tval &= ~MAC_CFG_MASK;\n\tif (phydev->interface == PHY_INTERFACE_MODE_QSGMII) {\n\t\tval |= MAC_CFG_QSGMII;\n\t} else if (phydev->interface == PHY_INTERFACE_MODE_SGMII) {\n\t\tval |= MAC_CFG_SGMII;\n\t} else {\n\t\tret = -EINVAL;\n\t\treturn ret;\n\t}\n\n\tret = phy_base_write(phydev, MSCC_PHY_MAC_CFG_FASTLINK, val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_base_write(phydev, MSCC_EXT_PAGE_ACCESS,\n\t\t\t     MSCC_PHY_PAGE_STANDARD);\n\tif (ret)\n\t\treturn ret;\n\n\tval = PROC_CMD_MCB_ACCESS_MAC_CONF | PROC_CMD_RST_CONF_PORT |\n\t\tPROC_CMD_READ_MOD_WRITE_PORT;\n\tif (phydev->interface == PHY_INTERFACE_MODE_QSGMII)\n\t\tval |= PROC_CMD_QSGMII_MAC;\n\telse\n\t\tval |= PROC_CMD_SGMII_MAC;\n\n\tret = vsc8584_cmd(phydev, val);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(10000, 20000);\n\n\t \n\tret = vsc8584_cmd(phydev, PROC_CMD_FIBER_MEDIA_CONF |\n\t\t\t  PROC_CMD_FIBER_PORT(vsc8531->addr) |\n\t\t\t  PROC_CMD_FIBER_DISABLE |\n\t\t\t  PROC_CMD_READ_MOD_WRITE_PORT |\n\t\t\t  PROC_CMD_RST_CONF_PORT | PROC_CMD_FIBER_100BASE_FX);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = vsc8584_cmd(phydev, PROC_CMD_FIBER_MEDIA_CONF |\n\t\t\t  PROC_CMD_FIBER_PORT(vsc8531->addr) |\n\t\t\t  PROC_CMD_FIBER_DISABLE |\n\t\t\t  PROC_CMD_READ_MOD_WRITE_PORT |\n\t\t\t  PROC_CMD_RST_CONF_PORT | PROC_CMD_FIBER_1000BASE_X);\n\tif (ret)\n\t\treturn ret;\n\n\treturn vsc85xx_sd6g_config_v2(phydev);\n}\n\nstatic int vsc8574_config_host_serdes(struct phy_device *phydev)\n{\n\tstruct vsc8531_private *vsc8531 = phydev->priv;\n\tint ret;\n\tu16 val;\n\n\tret = phy_base_write(phydev, MSCC_EXT_PAGE_ACCESS,\n\t\t\t     MSCC_PHY_PAGE_EXTENDED_GPIO);\n\tif (ret)\n\t\treturn ret;\n\n\tval = phy_base_read(phydev, MSCC_PHY_MAC_CFG_FASTLINK);\n\tval &= ~MAC_CFG_MASK;\n\tif (phydev->interface == PHY_INTERFACE_MODE_QSGMII) {\n\t\tval |= MAC_CFG_QSGMII;\n\t} else if (phydev->interface == PHY_INTERFACE_MODE_SGMII) {\n\t\tval |= MAC_CFG_SGMII;\n\t} else if (phy_interface_is_rgmii(phydev)) {\n\t\tval |= MAC_CFG_RGMII;\n\t} else {\n\t\tret = -EINVAL;\n\t\treturn ret;\n\t}\n\n\tret = phy_base_write(phydev, MSCC_PHY_MAC_CFG_FASTLINK, val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_base_write(phydev, MSCC_EXT_PAGE_ACCESS,\n\t\t\t     MSCC_PHY_PAGE_STANDARD);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!phy_interface_is_rgmii(phydev)) {\n\t\tval = PROC_CMD_MCB_ACCESS_MAC_CONF | PROC_CMD_RST_CONF_PORT |\n\t\t\tPROC_CMD_READ_MOD_WRITE_PORT;\n\t\tif (phydev->interface == PHY_INTERFACE_MODE_QSGMII)\n\t\t\tval |= PROC_CMD_QSGMII_MAC;\n\t\telse\n\t\t\tval |= PROC_CMD_SGMII_MAC;\n\n\t\tret = vsc8584_cmd(phydev, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tusleep_range(10000, 20000);\n\t}\n\n\t \n\tret = vsc8584_cmd(phydev, PROC_CMD_FIBER_MEDIA_CONF |\n\t\t\t  PROC_CMD_FIBER_PORT(vsc8531->addr) |\n\t\t\t  PROC_CMD_FIBER_DISABLE |\n\t\t\t  PROC_CMD_READ_MOD_WRITE_PORT |\n\t\t\t  PROC_CMD_RST_CONF_PORT | PROC_CMD_FIBER_100BASE_FX);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn vsc8584_cmd(phydev, PROC_CMD_FIBER_MEDIA_CONF |\n\t\t\t   PROC_CMD_FIBER_PORT(vsc8531->addr) |\n\t\t\t   PROC_CMD_FIBER_DISABLE |\n\t\t\t   PROC_CMD_READ_MOD_WRITE_PORT |\n\t\t\t   PROC_CMD_RST_CONF_PORT | PROC_CMD_FIBER_1000BASE_X);\n}\n\nstatic int vsc8584_config_init(struct phy_device *phydev)\n{\n\tstruct vsc8531_private *vsc8531 = phydev->priv;\n\tint ret, i;\n\tu16 val;\n\n\tphydev->mdix_ctrl = ETH_TP_MDI_AUTO;\n\n\tphy_lock_mdio_bus(phydev);\n\n\t \n\tif (phy_package_init_once(phydev)) {\n\t\t \n\t\tWARN_ON(phydev->drv->phy_id_mask & 0xf);\n\n\t\tswitch (phydev->phy_id & phydev->drv->phy_id_mask) {\n\t\tcase PHY_ID_VSC8504:\n\t\tcase PHY_ID_VSC8552:\n\t\tcase PHY_ID_VSC8572:\n\t\tcase PHY_ID_VSC8574:\n\t\t\tret = vsc8574_config_pre_init(phydev);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t\tret = vsc8574_config_host_serdes(phydev);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\tcase PHY_ID_VSC856X:\n\t\tcase PHY_ID_VSC8575:\n\t\tcase PHY_ID_VSC8582:\n\t\tcase PHY_ID_VSC8584:\n\t\t\tret = vsc8584_config_pre_init(phydev);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t\tret = vsc8584_config_host_serdes(phydev);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t\tvsc85xx_coma_mode_release(phydev);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tphy_unlock_mdio_bus(phydev);\n\n\tret = vsc8584_macsec_init(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vsc8584_ptp_init(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tval = phy_read(phydev, MSCC_PHY_EXT_PHY_CNTL_1);\n\tval &= ~(MEDIA_OP_MODE_MASK | VSC8584_MAC_IF_SELECTION_MASK);\n\tval |= (MEDIA_OP_MODE_COPPER << MEDIA_OP_MODE_POS) |\n\t       (VSC8584_MAC_IF_SELECTION_SGMII << VSC8584_MAC_IF_SELECTION_POS);\n\tret = phy_write(phydev, MSCC_PHY_EXT_PHY_CNTL_1, val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vsc85xx_update_rgmii_cntl(phydev, VSC8572_RGMII_CNTL,\n\t\t\t\t\tVSC8572_RGMII_RX_DELAY_MASK,\n\t\t\t\t\tVSC8572_RGMII_TX_DELAY_MASK);\n\tif (ret)\n\t\treturn ret;\n\n\tret = genphy_soft_reset(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < vsc8531->nleds; i++) {\n\t\tret = vsc85xx_led_cntl_set(phydev, i, vsc8531->leds_mode[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n\nerr:\n\tphy_unlock_mdio_bus(phydev);\n\treturn ret;\n}\n\nstatic irqreturn_t vsc8584_handle_interrupt(struct phy_device *phydev)\n{\n\tirqreturn_t ret;\n\tint irq_status;\n\n\tirq_status = phy_read(phydev, MII_VSC85XX_INT_STATUS);\n\tif (irq_status < 0)\n\t\treturn IRQ_NONE;\n\n\t \n\tret = vsc8584_handle_ts_interrupt(phydev);\n\tif (!(irq_status & MII_VSC85XX_INT_MASK_MASK))\n\t\treturn ret;\n\n\tif (irq_status & MII_VSC85XX_INT_MASK_EXT)\n\t\tvsc8584_handle_macsec_interrupt(phydev);\n\n\tif (irq_status & MII_VSC85XX_INT_MASK_LINK_CHG)\n\t\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int vsc85xx_config_init(struct phy_device *phydev)\n{\n\tint rc, i, phy_id;\n\tstruct vsc8531_private *vsc8531 = phydev->priv;\n\n\trc = vsc85xx_default_config(phydev);\n\tif (rc)\n\t\treturn rc;\n\n\trc = vsc85xx_mac_if_set(phydev, phydev->interface);\n\tif (rc)\n\t\treturn rc;\n\n\trc = vsc85xx_edge_rate_cntl_set(phydev, vsc8531->rate_magic);\n\tif (rc)\n\t\treturn rc;\n\n\tphy_id = phydev->drv->phy_id & phydev->drv->phy_id_mask;\n\tif (PHY_ID_VSC8531 == phy_id || PHY_ID_VSC8541 == phy_id ||\n\t    PHY_ID_VSC8530 == phy_id || PHY_ID_VSC8540 == phy_id) {\n\t\trc = vsc8531_pre_init_seq_set(phydev);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = vsc85xx_eee_init_seq_set(phydev);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < vsc8531->nleds; i++) {\n\t\trc = vsc85xx_led_cntl_set(phydev, i, vsc8531->leds_mode[i]);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int __phy_write_mcb_s6g(struct phy_device *phydev, u32 reg, u8 mcb,\n\t\t\t       u32 op)\n{\n\tunsigned long deadline;\n\tu32 val;\n\tint ret;\n\n\tret = vsc85xx_csr_write(phydev, PHY_MCB_TARGET, reg,\n\t\t\t\top | (1 << mcb));\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tdeadline = jiffies + msecs_to_jiffies(PROC_CMD_NCOMPLETED_TIMEOUT_MS);\n\tdo {\n\t\tusleep_range(500, 1000);\n\t\tval = vsc85xx_csr_read(phydev, PHY_MCB_TARGET, reg);\n\n\t\tif (val == 0xffffffff)\n\t\t\treturn -EIO;\n\n\t} while (time_before(jiffies, deadline) && (val & op));\n\n\tif (val & op)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\n \nint phy_update_mcb_s6g(struct phy_device *phydev, u32 reg, u8 mcb)\n{\n\treturn __phy_write_mcb_s6g(phydev, reg, mcb, PHY_MCB_S6G_READ);\n}\n\n \nint phy_commit_mcb_s6g(struct phy_device *phydev, u32 reg, u8 mcb)\n{\n\treturn __phy_write_mcb_s6g(phydev, reg, mcb, PHY_MCB_S6G_WRITE);\n}\n\nstatic int vsc8514_config_host_serdes(struct phy_device *phydev)\n{\n\tint ret;\n\tu16 val;\n\n\tret = phy_base_write(phydev, MSCC_EXT_PAGE_ACCESS,\n\t\t\t     MSCC_PHY_PAGE_EXTENDED_GPIO);\n\tif (ret)\n\t\treturn ret;\n\n\tval = phy_base_read(phydev, MSCC_PHY_MAC_CFG_FASTLINK);\n\tval &= ~MAC_CFG_MASK;\n\tval |= MAC_CFG_QSGMII;\n\tret = phy_base_write(phydev, MSCC_PHY_MAC_CFG_FASTLINK, val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_base_write(phydev, MSCC_EXT_PAGE_ACCESS,\n\t\t\t     MSCC_PHY_PAGE_STANDARD);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vsc8584_cmd(phydev, PROC_CMD_NOP);\n\tif (ret)\n\t\treturn ret;\n\n\tret = vsc8584_cmd(phydev,\n\t\t\t  PROC_CMD_MCB_ACCESS_MAC_CONF |\n\t\t\t  PROC_CMD_RST_CONF_PORT |\n\t\t\t  PROC_CMD_READ_MOD_WRITE_PORT | PROC_CMD_QSGMII_MAC);\n\tif (ret) {\n\t\tdev_err(&phydev->mdio.dev, \"%s: QSGMII error: %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tvsc8584_micro_assert_reset(phydev);\n\tval = phy_base_read(phydev, MSCC_INT_MEM_CNTL);\n\t \n\tval &= ~PATCH_VEC_ZERO_EN;\n\tret = phy_base_write(phydev, MSCC_INT_MEM_CNTL, val);\n\t \n\tvsc8584_micro_deassert_reset(phydev, false);\n\n\treturn vsc85xx_sd6g_config_v2(phydev);\n}\n\nstatic int vsc8514_config_pre_init(struct phy_device *phydev)\n{\n\t \n\tstatic const struct reg_val pre_init1[] = {\n\t\t{0x0f90, 0x00688980},\n\t\t{0x0786, 0x00000003},\n\t\t{0x07fa, 0x0050100f},\n\t\t{0x0f82, 0x0012b002},\n\t\t{0x1686, 0x00000004},\n\t\t{0x168c, 0x00d2c46f},\n\t\t{0x17a2, 0x00000620},\n\t\t{0x16a0, 0x00eeffdd},\n\t\t{0x16a6, 0x00071448},\n\t\t{0x16a4, 0x0013132f},\n\t\t{0x16a8, 0x00000000},\n\t\t{0x0ffc, 0x00c0a028},\n\t\t{0x0fe8, 0x0091b06c},\n\t\t{0x0fea, 0x00041600},\n\t\t{0x0f80, 0x00fffaff},\n\t\t{0x0fec, 0x00901809},\n\t\t{0x0ffe, 0x00b01007},\n\t\t{0x16b0, 0x00eeff00},\n\t\t{0x16b2, 0x00007000},\n\t\t{0x16b4, 0x00000814},\n\t};\n\tstruct device *dev = &phydev->mdio.dev;\n\tunsigned int i;\n\tu16 reg;\n\tint ret;\n\n\tret = vsc8584_pll5g_reset(phydev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed LCPLL reset, ret: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_STANDARD);\n\n\t \n\treg = phy_base_read(phydev, MSCC_PHY_EXT_CNTL_STATUS);\n\treg |= SMI_BROADCAST_WR_EN;\n\tphy_base_write(phydev, MSCC_PHY_EXT_CNTL_STATUS, reg);\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_TEST);\n\n\treg = phy_base_read(phydev, MSCC_PHY_TEST_PAGE_8);\n\treg |= BIT(15);\n\tphy_base_write(phydev, MSCC_PHY_TEST_PAGE_8, reg);\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_TR);\n\n\tfor (i = 0; i < ARRAY_SIZE(pre_init1); i++)\n\t\tvsc8584_csr_write(phydev, pre_init1[i].reg, pre_init1[i].val);\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_TEST);\n\n\treg = phy_base_read(phydev, MSCC_PHY_TEST_PAGE_8);\n\treg &= ~BIT(15);\n\tphy_base_write(phydev, MSCC_PHY_TEST_PAGE_8, reg);\n\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS, MSCC_PHY_PAGE_STANDARD);\n\n\treg = phy_base_read(phydev, MSCC_PHY_EXT_CNTL_STATUS);\n\treg &= ~SMI_BROADCAST_WR_EN;\n\tphy_base_write(phydev, MSCC_PHY_EXT_CNTL_STATUS, reg);\n\n\t \n\tvsc8584_micro_deassert_reset(phydev, false);\n\n\tvsc8584_micro_assert_reset(phydev);\n\tphy_base_write(phydev, MSCC_EXT_PAGE_ACCESS,\n\t\t       MSCC_PHY_PAGE_EXTENDED_GPIO);\n\t \n\treg = MSCC_ROM_TRAP_SERDES_6G_CFG;\n\tret = phy_base_write(phydev, MSCC_TRAP_ROM_ADDR(1), reg);\n\tif (ret)\n\t\tgoto err;\n\t \n\treg = MSCC_RAM_TRAP_SERDES_6G_CFG;\n\tret = phy_base_write(phydev, MSCC_PATCH_RAM_ADDR(1), reg);\n\tif (ret)\n\t\tgoto err;\n\treg = phy_base_read(phydev, MSCC_INT_MEM_CNTL);\n\treg |= PATCH_VEC_ZERO_EN;  \n\tret = phy_base_write(phydev, MSCC_INT_MEM_CNTL, reg);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tvsc8584_micro_deassert_reset(phydev, false);\n\treturn ret;\n err:\n\t \n\tvsc8584_micro_deassert_reset(phydev, false);\n\treturn ret;\n}\n\nstatic int vsc8514_config_init(struct phy_device *phydev)\n{\n\tstruct vsc8531_private *vsc8531 = phydev->priv;\n\tint ret, i;\n\n\tphydev->mdix_ctrl = ETH_TP_MDI_AUTO;\n\n\tphy_lock_mdio_bus(phydev);\n\n\t \n\tif (phy_package_init_once(phydev)) {\n\t\tret = vsc8514_config_pre_init(phydev);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = vsc8514_config_host_serdes(phydev);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tvsc85xx_coma_mode_release(phydev);\n\t}\n\n\tphy_unlock_mdio_bus(phydev);\n\n\tret = phy_modify(phydev, MSCC_PHY_EXT_PHY_CNTL_1, MEDIA_OP_MODE_MASK,\n\t\t\t MEDIA_OP_MODE_COPPER << MEDIA_OP_MODE_POS);\n\n\tif (ret)\n\t\treturn ret;\n\n\tret = genphy_soft_reset(phydev);\n\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < vsc8531->nleds; i++) {\n\t\tret = vsc85xx_led_cntl_set(phydev, i, vsc8531->leds_mode[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n\nerr:\n\tphy_unlock_mdio_bus(phydev);\n\treturn ret;\n}\n\nstatic int vsc85xx_ack_interrupt(struct phy_device *phydev)\n{\n\tint rc = 0;\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED)\n\t\trc = phy_read(phydev, MII_VSC85XX_INT_STATUS);\n\n\treturn (rc < 0) ? rc : 0;\n}\n\nstatic int vsc85xx_config_intr(struct phy_device *phydev)\n{\n\tint rc;\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\trc = vsc85xx_ack_interrupt(phydev);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tvsc8584_config_macsec_intr(phydev);\n\t\tvsc8584_config_ts_intr(phydev);\n\n\t\trc = phy_write(phydev, MII_VSC85XX_INT_MASK,\n\t\t\t       MII_VSC85XX_INT_MASK_MASK);\n\t} else {\n\t\trc = phy_write(phydev, MII_VSC85XX_INT_MASK, 0);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\trc = phy_read(phydev, MII_VSC85XX_INT_STATUS);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\trc = vsc85xx_ack_interrupt(phydev);\n\t}\n\n\treturn rc;\n}\n\nstatic irqreturn_t vsc85xx_handle_interrupt(struct phy_device *phydev)\n{\n\tint irq_status;\n\n\tirq_status = phy_read(phydev, MII_VSC85XX_INT_STATUS);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (!(irq_status & MII_VSC85XX_INT_MASK_MASK))\n\t\treturn IRQ_NONE;\n\n\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int vsc85xx_config_aneg(struct phy_device *phydev)\n{\n\tint rc;\n\n\trc = vsc85xx_mdix_set(phydev, phydev->mdix_ctrl);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn genphy_config_aneg(phydev);\n}\n\nstatic int vsc85xx_read_status(struct phy_device *phydev)\n{\n\tint rc;\n\n\trc = vsc85xx_mdix_get(phydev, &phydev->mdix);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn genphy_read_status(phydev);\n}\n\nstatic int vsc8514_probe(struct phy_device *phydev)\n{\n\tstruct vsc8531_private *vsc8531;\n\tu32 default_mode[4] = {VSC8531_LINK_1000_ACTIVITY,\n\t   VSC8531_LINK_100_ACTIVITY, VSC8531_LINK_ACTIVITY,\n\t   VSC8531_DUPLEX_COLLISION};\n\n\tvsc8531 = devm_kzalloc(&phydev->mdio.dev, sizeof(*vsc8531), GFP_KERNEL);\n\tif (!vsc8531)\n\t\treturn -ENOMEM;\n\n\tphydev->priv = vsc8531;\n\n\tvsc8584_get_base_addr(phydev);\n\tdevm_phy_package_join(&phydev->mdio.dev, phydev,\n\t\t\t      vsc8531->base_addr, 0);\n\n\tvsc8531->nleds = 4;\n\tvsc8531->supp_led_modes = VSC85XX_SUPP_LED_MODES;\n\tvsc8531->hw_stats = vsc85xx_hw_stats;\n\tvsc8531->nstats = ARRAY_SIZE(vsc85xx_hw_stats);\n\tvsc8531->stats = devm_kcalloc(&phydev->mdio.dev, vsc8531->nstats,\n\t\t\t\t      sizeof(u64), GFP_KERNEL);\n\tif (!vsc8531->stats)\n\t\treturn -ENOMEM;\n\n\treturn vsc85xx_dt_led_modes_get(phydev, default_mode);\n}\n\nstatic int vsc8574_probe(struct phy_device *phydev)\n{\n\tstruct vsc8531_private *vsc8531;\n\tu32 default_mode[4] = {VSC8531_LINK_1000_ACTIVITY,\n\t   VSC8531_LINK_100_ACTIVITY, VSC8531_LINK_ACTIVITY,\n\t   VSC8531_DUPLEX_COLLISION};\n\n\tvsc8531 = devm_kzalloc(&phydev->mdio.dev, sizeof(*vsc8531), GFP_KERNEL);\n\tif (!vsc8531)\n\t\treturn -ENOMEM;\n\n\tphydev->priv = vsc8531;\n\n\tvsc8584_get_base_addr(phydev);\n\tdevm_phy_package_join(&phydev->mdio.dev, phydev,\n\t\t\t      vsc8531->base_addr, 0);\n\n\tvsc8531->nleds = 4;\n\tvsc8531->supp_led_modes = VSC8584_SUPP_LED_MODES;\n\tvsc8531->hw_stats = vsc8584_hw_stats;\n\tvsc8531->nstats = ARRAY_SIZE(vsc8584_hw_stats);\n\tvsc8531->stats = devm_kcalloc(&phydev->mdio.dev, vsc8531->nstats,\n\t\t\t\t      sizeof(u64), GFP_KERNEL);\n\tif (!vsc8531->stats)\n\t\treturn -ENOMEM;\n\n\treturn vsc85xx_dt_led_modes_get(phydev, default_mode);\n}\n\nstatic int vsc8584_probe(struct phy_device *phydev)\n{\n\tstruct vsc8531_private *vsc8531;\n\tu32 default_mode[4] = {VSC8531_LINK_1000_ACTIVITY,\n\t   VSC8531_LINK_100_ACTIVITY, VSC8531_LINK_ACTIVITY,\n\t   VSC8531_DUPLEX_COLLISION};\n\tint ret;\n\n\tif ((phydev->phy_id & MSCC_DEV_REV_MASK) != VSC8584_REVB) {\n\t\tdev_err(&phydev->mdio.dev, \"Only VSC8584 revB is supported.\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tvsc8531 = devm_kzalloc(&phydev->mdio.dev, sizeof(*vsc8531), GFP_KERNEL);\n\tif (!vsc8531)\n\t\treturn -ENOMEM;\n\n\tphydev->priv = vsc8531;\n\n\tvsc8584_get_base_addr(phydev);\n\tdevm_phy_package_join(&phydev->mdio.dev, phydev, vsc8531->base_addr,\n\t\t\t      sizeof(struct vsc85xx_shared_private));\n\n\tvsc8531->nleds = 4;\n\tvsc8531->supp_led_modes = VSC8584_SUPP_LED_MODES;\n\tvsc8531->hw_stats = vsc8584_hw_stats;\n\tvsc8531->nstats = ARRAY_SIZE(vsc8584_hw_stats);\n\tvsc8531->stats = devm_kcalloc(&phydev->mdio.dev, vsc8531->nstats,\n\t\t\t\t      sizeof(u64), GFP_KERNEL);\n\tif (!vsc8531->stats)\n\t\treturn -ENOMEM;\n\n\tif (phy_package_probe_once(phydev)) {\n\t\tret = vsc8584_ptp_probe_once(phydev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = vsc8584_ptp_probe(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn vsc85xx_dt_led_modes_get(phydev, default_mode);\n}\n\nstatic int vsc85xx_probe(struct phy_device *phydev)\n{\n\tstruct vsc8531_private *vsc8531;\n\tint rate_magic;\n\tu32 default_mode[2] = {VSC8531_LINK_1000_ACTIVITY,\n\t   VSC8531_LINK_100_ACTIVITY};\n\n\trate_magic = vsc85xx_edge_rate_magic_get(phydev);\n\tif (rate_magic < 0)\n\t\treturn rate_magic;\n\n\tvsc8531 = devm_kzalloc(&phydev->mdio.dev, sizeof(*vsc8531), GFP_KERNEL);\n\tif (!vsc8531)\n\t\treturn -ENOMEM;\n\n\tphydev->priv = vsc8531;\n\n\tvsc8531->rate_magic = rate_magic;\n\tvsc8531->nleds = 2;\n\tvsc8531->supp_led_modes = VSC85XX_SUPP_LED_MODES;\n\tvsc8531->hw_stats = vsc85xx_hw_stats;\n\tvsc8531->nstats = ARRAY_SIZE(vsc85xx_hw_stats);\n\tvsc8531->stats = devm_kcalloc(&phydev->mdio.dev, vsc8531->nstats,\n\t\t\t\t      sizeof(u64), GFP_KERNEL);\n\tif (!vsc8531->stats)\n\t\treturn -ENOMEM;\n\n\treturn vsc85xx_dt_led_modes_get(phydev, default_mode);\n}\n\n \nstatic struct phy_driver vsc85xx_driver[] = {\n{\n\t.phy_id\t\t= PHY_ID_VSC8501,\n\t.name\t\t= \"Microsemi GE VSC8501 SyncE\",\n\t.phy_id_mask\t= 0xfffffff0,\n\t \n\t.soft_reset\t= &genphy_soft_reset,\n\t.config_init\t= &vsc85xx_config_init,\n\t.config_aneg    = &vsc85xx_config_aneg,\n\t.read_status\t= &vsc85xx_read_status,\n\t.handle_interrupt = vsc85xx_handle_interrupt,\n\t.config_intr\t= &vsc85xx_config_intr,\n\t.suspend\t= &genphy_suspend,\n\t.resume\t\t= &genphy_resume,\n\t.probe\t\t= &vsc85xx_probe,\n\t.set_wol\t= &vsc85xx_wol_set,\n\t.get_wol\t= &vsc85xx_wol_get,\n\t.get_tunable\t= &vsc85xx_get_tunable,\n\t.set_tunable\t= &vsc85xx_set_tunable,\n\t.read_page\t= &vsc85xx_phy_read_page,\n\t.write_page\t= &vsc85xx_phy_write_page,\n\t.get_sset_count = &vsc85xx_get_sset_count,\n\t.get_strings    = &vsc85xx_get_strings,\n\t.get_stats      = &vsc85xx_get_stats,\n},\n{\n\t.phy_id\t\t= PHY_ID_VSC8502,\n\t.name\t\t= \"Microsemi GE VSC8502 SyncE\",\n\t.phy_id_mask\t= 0xfffffff0,\n\t \n\t.soft_reset\t= &genphy_soft_reset,\n\t.config_init\t= &vsc85xx_config_init,\n\t.config_aneg    = &vsc85xx_config_aneg,\n\t.read_status\t= &vsc85xx_read_status,\n\t.handle_interrupt = vsc85xx_handle_interrupt,\n\t.config_intr\t= &vsc85xx_config_intr,\n\t.suspend\t= &genphy_suspend,\n\t.resume\t\t= &genphy_resume,\n\t.probe\t\t= &vsc85xx_probe,\n\t.set_wol\t= &vsc85xx_wol_set,\n\t.get_wol\t= &vsc85xx_wol_get,\n\t.get_tunable\t= &vsc85xx_get_tunable,\n\t.set_tunable\t= &vsc85xx_set_tunable,\n\t.read_page\t= &vsc85xx_phy_read_page,\n\t.write_page\t= &vsc85xx_phy_write_page,\n\t.get_sset_count = &vsc85xx_get_sset_count,\n\t.get_strings    = &vsc85xx_get_strings,\n\t.get_stats      = &vsc85xx_get_stats,\n},\n{\n\t.phy_id\t\t= PHY_ID_VSC8504,\n\t.name\t\t= \"Microsemi GE VSC8504 SyncE\",\n\t.phy_id_mask\t= 0xfffffff0,\n\t \n\t.soft_reset\t= &genphy_soft_reset,\n\t.config_init    = &vsc8584_config_init,\n\t.config_aneg    = &vsc85xx_config_aneg,\n\t.aneg_done\t= &genphy_aneg_done,\n\t.read_status\t= &vsc85xx_read_status,\n\t.handle_interrupt = vsc85xx_handle_interrupt,\n\t.config_intr    = &vsc85xx_config_intr,\n\t.suspend\t= &genphy_suspend,\n\t.resume\t\t= &genphy_resume,\n\t.probe\t\t= &vsc8574_probe,\n\t.set_wol\t= &vsc85xx_wol_set,\n\t.get_wol\t= &vsc85xx_wol_get,\n\t.get_tunable\t= &vsc85xx_get_tunable,\n\t.set_tunable\t= &vsc85xx_set_tunable,\n\t.read_page\t= &vsc85xx_phy_read_page,\n\t.write_page\t= &vsc85xx_phy_write_page,\n\t.get_sset_count = &vsc85xx_get_sset_count,\n\t.get_strings    = &vsc85xx_get_strings,\n\t.get_stats      = &vsc85xx_get_stats,\n},\n{\n\t.phy_id\t\t= PHY_ID_VSC8514,\n\t.name\t\t= \"Microsemi GE VSC8514 SyncE\",\n\t.phy_id_mask\t= 0xfffffff0,\n\t.soft_reset\t= &genphy_soft_reset,\n\t.config_init    = &vsc8514_config_init,\n\t.config_aneg    = &vsc85xx_config_aneg,\n\t.read_status\t= &vsc85xx_read_status,\n\t.handle_interrupt = vsc85xx_handle_interrupt,\n\t.config_intr    = &vsc85xx_config_intr,\n\t.suspend\t= &genphy_suspend,\n\t.resume\t\t= &genphy_resume,\n\t.probe\t\t= &vsc8514_probe,\n\t.set_wol\t= &vsc85xx_wol_set,\n\t.get_wol\t= &vsc85xx_wol_get,\n\t.get_tunable\t= &vsc85xx_get_tunable,\n\t.set_tunable\t= &vsc85xx_set_tunable,\n\t.read_page      = &vsc85xx_phy_read_page,\n\t.write_page     = &vsc85xx_phy_write_page,\n\t.get_sset_count = &vsc85xx_get_sset_count,\n\t.get_strings    = &vsc85xx_get_strings,\n\t.get_stats      = &vsc85xx_get_stats,\n},\n{\n\t.phy_id\t\t= PHY_ID_VSC8530,\n\t.name\t\t= \"Microsemi FE VSC8530\",\n\t.phy_id_mask\t= 0xfffffff0,\n\t \n\t.soft_reset\t= &genphy_soft_reset,\n\t.config_init\t= &vsc85xx_config_init,\n\t.config_aneg    = &vsc85xx_config_aneg,\n\t.read_status\t= &vsc85xx_read_status,\n\t.handle_interrupt = vsc85xx_handle_interrupt,\n\t.config_intr\t= &vsc85xx_config_intr,\n\t.suspend\t= &genphy_suspend,\n\t.resume\t\t= &genphy_resume,\n\t.probe\t\t= &vsc85xx_probe,\n\t.set_wol\t= &vsc85xx_wol_set,\n\t.get_wol\t= &vsc85xx_wol_get,\n\t.get_tunable\t= &vsc85xx_get_tunable,\n\t.set_tunable\t= &vsc85xx_set_tunable,\n\t.read_page\t= &vsc85xx_phy_read_page,\n\t.write_page\t= &vsc85xx_phy_write_page,\n\t.get_sset_count = &vsc85xx_get_sset_count,\n\t.get_strings    = &vsc85xx_get_strings,\n\t.get_stats      = &vsc85xx_get_stats,\n},\n{\n\t.phy_id\t\t= PHY_ID_VSC8531,\n\t.name\t\t= \"Microsemi VSC8531\",\n\t.phy_id_mask    = 0xfffffff0,\n\t \n\t.soft_reset\t= &genphy_soft_reset,\n\t.config_init    = &vsc85xx_config_init,\n\t.config_aneg    = &vsc85xx_config_aneg,\n\t.read_status\t= &vsc85xx_read_status,\n\t.handle_interrupt = vsc85xx_handle_interrupt,\n\t.config_intr    = &vsc85xx_config_intr,\n\t.suspend\t= &genphy_suspend,\n\t.resume\t\t= &genphy_resume,\n\t.probe\t\t= &vsc85xx_probe,\n\t.set_wol\t= &vsc85xx_wol_set,\n\t.get_wol\t= &vsc85xx_wol_get,\n\t.get_tunable\t= &vsc85xx_get_tunable,\n\t.set_tunable\t= &vsc85xx_set_tunable,\n\t.read_page\t= &vsc85xx_phy_read_page,\n\t.write_page\t= &vsc85xx_phy_write_page,\n\t.get_sset_count = &vsc85xx_get_sset_count,\n\t.get_strings    = &vsc85xx_get_strings,\n\t.get_stats      = &vsc85xx_get_stats,\n},\n{\n\t.phy_id\t\t= PHY_ID_VSC8540,\n\t.name\t\t= \"Microsemi FE VSC8540 SyncE\",\n\t.phy_id_mask\t= 0xfffffff0,\n\t \n\t.soft_reset\t= &genphy_soft_reset,\n\t.config_init\t= &vsc85xx_config_init,\n\t.config_aneg\t= &vsc85xx_config_aneg,\n\t.read_status\t= &vsc85xx_read_status,\n\t.handle_interrupt = vsc85xx_handle_interrupt,\n\t.config_intr\t= &vsc85xx_config_intr,\n\t.suspend\t= &genphy_suspend,\n\t.resume\t\t= &genphy_resume,\n\t.probe\t\t= &vsc85xx_probe,\n\t.set_wol\t= &vsc85xx_wol_set,\n\t.get_wol\t= &vsc85xx_wol_get,\n\t.get_tunable\t= &vsc85xx_get_tunable,\n\t.set_tunable\t= &vsc85xx_set_tunable,\n\t.read_page\t= &vsc85xx_phy_read_page,\n\t.write_page\t= &vsc85xx_phy_write_page,\n\t.get_sset_count = &vsc85xx_get_sset_count,\n\t.get_strings    = &vsc85xx_get_strings,\n\t.get_stats      = &vsc85xx_get_stats,\n},\n{\n\t.phy_id\t\t= PHY_ID_VSC8541,\n\t.name\t\t= \"Microsemi VSC8541 SyncE\",\n\t.phy_id_mask    = 0xfffffff0,\n\t \n\t.soft_reset\t= &genphy_soft_reset,\n\t.config_init    = &vsc85xx_config_init,\n\t.config_aneg    = &vsc85xx_config_aneg,\n\t.read_status\t= &vsc85xx_read_status,\n\t.handle_interrupt = vsc85xx_handle_interrupt,\n\t.config_intr    = &vsc85xx_config_intr,\n\t.suspend\t= &genphy_suspend,\n\t.resume\t\t= &genphy_resume,\n\t.probe\t\t= &vsc85xx_probe,\n\t.set_wol\t= &vsc85xx_wol_set,\n\t.get_wol\t= &vsc85xx_wol_get,\n\t.get_tunable\t= &vsc85xx_get_tunable,\n\t.set_tunable\t= &vsc85xx_set_tunable,\n\t.read_page\t= &vsc85xx_phy_read_page,\n\t.write_page\t= &vsc85xx_phy_write_page,\n\t.get_sset_count = &vsc85xx_get_sset_count,\n\t.get_strings    = &vsc85xx_get_strings,\n\t.get_stats      = &vsc85xx_get_stats,\n},\n{\n\t.phy_id\t\t= PHY_ID_VSC8552,\n\t.name\t\t= \"Microsemi GE VSC8552 SyncE\",\n\t.phy_id_mask\t= 0xfffffff0,\n\t \n\t.soft_reset\t= &genphy_soft_reset,\n\t.config_init    = &vsc8584_config_init,\n\t.config_aneg    = &vsc85xx_config_aneg,\n\t.read_status\t= &vsc85xx_read_status,\n\t.handle_interrupt = vsc85xx_handle_interrupt,\n\t.config_intr    = &vsc85xx_config_intr,\n\t.suspend\t= &genphy_suspend,\n\t.resume\t\t= &genphy_resume,\n\t.probe\t\t= &vsc8574_probe,\n\t.set_wol\t= &vsc85xx_wol_set,\n\t.get_wol\t= &vsc85xx_wol_get,\n\t.get_tunable\t= &vsc85xx_get_tunable,\n\t.set_tunable\t= &vsc85xx_set_tunable,\n\t.read_page\t= &vsc85xx_phy_read_page,\n\t.write_page\t= &vsc85xx_phy_write_page,\n\t.get_sset_count = &vsc85xx_get_sset_count,\n\t.get_strings    = &vsc85xx_get_strings,\n\t.get_stats      = &vsc85xx_get_stats,\n},\n{\n\t.phy_id\t\t= PHY_ID_VSC856X,\n\t.name\t\t= \"Microsemi GE VSC856X SyncE\",\n\t.phy_id_mask\t= 0xfffffff0,\n\t \n\t.soft_reset\t= &genphy_soft_reset,\n\t.config_init    = &vsc8584_config_init,\n\t.config_aneg    = &vsc85xx_config_aneg,\n\t.read_status\t= &vsc85xx_read_status,\n\t.handle_interrupt = vsc85xx_handle_interrupt,\n\t.config_intr    = &vsc85xx_config_intr,\n\t.suspend\t= &genphy_suspend,\n\t.resume\t\t= &genphy_resume,\n\t.probe\t\t= &vsc8584_probe,\n\t.get_tunable\t= &vsc85xx_get_tunable,\n\t.set_tunable\t= &vsc85xx_set_tunable,\n\t.read_page\t= &vsc85xx_phy_read_page,\n\t.write_page\t= &vsc85xx_phy_write_page,\n\t.get_sset_count = &vsc85xx_get_sset_count,\n\t.get_strings    = &vsc85xx_get_strings,\n\t.get_stats      = &vsc85xx_get_stats,\n},\n{\n\t.phy_id\t\t= PHY_ID_VSC8572,\n\t.name\t\t= \"Microsemi GE VSC8572 SyncE\",\n\t.phy_id_mask\t= 0xfffffff0,\n\t \n\t.soft_reset\t= &genphy_soft_reset,\n\t.config_init    = &vsc8584_config_init,\n\t.config_aneg    = &vsc85xx_config_aneg,\n\t.aneg_done\t= &genphy_aneg_done,\n\t.read_status\t= &vsc85xx_read_status,\n\t.handle_interrupt = &vsc8584_handle_interrupt,\n\t.config_intr    = &vsc85xx_config_intr,\n\t.suspend\t= &genphy_suspend,\n\t.resume\t\t= &genphy_resume,\n\t.probe\t\t= &vsc8574_probe,\n\t.set_wol\t= &vsc85xx_wol_set,\n\t.get_wol\t= &vsc85xx_wol_get,\n\t.get_tunable\t= &vsc85xx_get_tunable,\n\t.set_tunable\t= &vsc85xx_set_tunable,\n\t.read_page\t= &vsc85xx_phy_read_page,\n\t.write_page\t= &vsc85xx_phy_write_page,\n\t.get_sset_count = &vsc85xx_get_sset_count,\n\t.get_strings    = &vsc85xx_get_strings,\n\t.get_stats      = &vsc85xx_get_stats,\n},\n{\n\t.phy_id\t\t= PHY_ID_VSC8574,\n\t.name\t\t= \"Microsemi GE VSC8574 SyncE\",\n\t.phy_id_mask\t= 0xfffffff0,\n\t \n\t.soft_reset\t= &genphy_soft_reset,\n\t.config_init    = &vsc8584_config_init,\n\t.config_aneg    = &vsc85xx_config_aneg,\n\t.aneg_done\t= &genphy_aneg_done,\n\t.read_status\t= &vsc85xx_read_status,\n\t.handle_interrupt = vsc85xx_handle_interrupt,\n\t.config_intr    = &vsc85xx_config_intr,\n\t.suspend\t= &genphy_suspend,\n\t.resume\t\t= &genphy_resume,\n\t.probe\t\t= &vsc8574_probe,\n\t.set_wol\t= &vsc85xx_wol_set,\n\t.get_wol\t= &vsc85xx_wol_get,\n\t.get_tunable\t= &vsc85xx_get_tunable,\n\t.set_tunable\t= &vsc85xx_set_tunable,\n\t.read_page\t= &vsc85xx_phy_read_page,\n\t.write_page\t= &vsc85xx_phy_write_page,\n\t.get_sset_count = &vsc85xx_get_sset_count,\n\t.get_strings    = &vsc85xx_get_strings,\n\t.get_stats      = &vsc85xx_get_stats,\n},\n{\n\t.phy_id\t\t= PHY_ID_VSC8575,\n\t.name\t\t= \"Microsemi GE VSC8575 SyncE\",\n\t.phy_id_mask\t= 0xfffffff0,\n\t \n\t.soft_reset\t= &genphy_soft_reset,\n\t.config_init    = &vsc8584_config_init,\n\t.config_aneg    = &vsc85xx_config_aneg,\n\t.aneg_done\t= &genphy_aneg_done,\n\t.read_status\t= &vsc85xx_read_status,\n\t.handle_interrupt = &vsc8584_handle_interrupt,\n\t.config_intr    = &vsc85xx_config_intr,\n\t.suspend\t= &genphy_suspend,\n\t.resume\t\t= &genphy_resume,\n\t.probe\t\t= &vsc8584_probe,\n\t.get_tunable\t= &vsc85xx_get_tunable,\n\t.set_tunable\t= &vsc85xx_set_tunable,\n\t.read_page\t= &vsc85xx_phy_read_page,\n\t.write_page\t= &vsc85xx_phy_write_page,\n\t.get_sset_count = &vsc85xx_get_sset_count,\n\t.get_strings    = &vsc85xx_get_strings,\n\t.get_stats      = &vsc85xx_get_stats,\n},\n{\n\t.phy_id\t\t= PHY_ID_VSC8582,\n\t.name\t\t= \"Microsemi GE VSC8582 SyncE\",\n\t.phy_id_mask\t= 0xfffffff0,\n\t \n\t.soft_reset\t= &genphy_soft_reset,\n\t.config_init    = &vsc8584_config_init,\n\t.config_aneg    = &vsc85xx_config_aneg,\n\t.aneg_done\t= &genphy_aneg_done,\n\t.read_status\t= &vsc85xx_read_status,\n\t.handle_interrupt = &vsc8584_handle_interrupt,\n\t.config_intr    = &vsc85xx_config_intr,\n\t.suspend\t= &genphy_suspend,\n\t.resume\t\t= &genphy_resume,\n\t.probe\t\t= &vsc8584_probe,\n\t.get_tunable\t= &vsc85xx_get_tunable,\n\t.set_tunable\t= &vsc85xx_set_tunable,\n\t.read_page\t= &vsc85xx_phy_read_page,\n\t.write_page\t= &vsc85xx_phy_write_page,\n\t.get_sset_count = &vsc85xx_get_sset_count,\n\t.get_strings    = &vsc85xx_get_strings,\n\t.get_stats      = &vsc85xx_get_stats,\n},\n{\n\t.phy_id\t\t= PHY_ID_VSC8584,\n\t.name\t\t= \"Microsemi GE VSC8584 SyncE\",\n\t.phy_id_mask\t= 0xfffffff0,\n\t \n\t.soft_reset\t= &genphy_soft_reset,\n\t.config_init    = &vsc8584_config_init,\n\t.config_aneg    = &vsc85xx_config_aneg,\n\t.aneg_done\t= &genphy_aneg_done,\n\t.read_status\t= &vsc85xx_read_status,\n\t.handle_interrupt = &vsc8584_handle_interrupt,\n\t.config_intr    = &vsc85xx_config_intr,\n\t.suspend\t= &genphy_suspend,\n\t.resume\t\t= &genphy_resume,\n\t.probe\t\t= &vsc8584_probe,\n\t.get_tunable\t= &vsc85xx_get_tunable,\n\t.set_tunable\t= &vsc85xx_set_tunable,\n\t.read_page\t= &vsc85xx_phy_read_page,\n\t.write_page\t= &vsc85xx_phy_write_page,\n\t.get_sset_count = &vsc85xx_get_sset_count,\n\t.get_strings    = &vsc85xx_get_strings,\n\t.get_stats      = &vsc85xx_get_stats,\n\t.link_change_notify = &vsc85xx_link_change_notify,\n}\n\n};\n\nmodule_phy_driver(vsc85xx_driver);\n\nstatic struct mdio_device_id __maybe_unused vsc85xx_tbl[] = {\n\t{ PHY_ID_MATCH_VENDOR(PHY_VENDOR_MSCC) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(mdio, vsc85xx_tbl);\n\nMODULE_DESCRIPTION(\"Microsemi VSC85xx PHY driver\");\nMODULE_AUTHOR(\"Nagaraju Lakkaraju\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\n\nMODULE_FIRMWARE(MSCC_VSC8584_REVB_INT8051_FW);\nMODULE_FIRMWARE(MSCC_VSC8574_REVB_INT8051_FW);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}