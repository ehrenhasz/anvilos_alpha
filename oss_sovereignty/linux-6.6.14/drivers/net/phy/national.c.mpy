{
  "module_name": "national.c",
  "hash_id": "0c22ce865db53e81fabd0159352eda0b84fa07ebe474716d107621fc3690812e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/national.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/phy.h>\n#include <linux/netdevice.h>\n\n \n#define DP83865_PHY_ID\t0x20005c7a\n\n#define DP83865_INT_STATUS\t0x14\n#define DP83865_INT_MASK\t0x15\n#define DP83865_INT_CLEAR\t0x17\n\n#define DP83865_INT_REMOTE_FAULT 0x0008\n#define DP83865_INT_ANE_COMPLETED 0x0010\n#define DP83865_INT_LINK_CHANGE\t0xe000\n#define DP83865_INT_MASK_DEFAULT (DP83865_INT_REMOTE_FAULT | \\\n\t\t\t\tDP83865_INT_ANE_COMPLETED | \\\n\t\t\t\tDP83865_INT_LINK_CHANGE)\n\n \n#define NS_EXP_MEM_CTL\t0x16\n#define NS_EXP_MEM_DATA\t0x1d\n#define NS_EXP_MEM_ADD\t0x1e\n\n#define LED_CTRL_REG 0x13\n#define AN_FALLBACK_AN 0x0001\n#define AN_FALLBACK_CRC 0x0002\n#define AN_FALLBACK_IE 0x0004\n#define ALL_FALLBACK_ON (AN_FALLBACK_AN |  AN_FALLBACK_CRC | AN_FALLBACK_IE)\n\nenum hdx_loopback {\n\thdx_loopback_on = 0,\n\thdx_loopback_off = 1,\n};\n\nstatic u8 ns_exp_read(struct phy_device *phydev, u16 reg)\n{\n\tphy_write(phydev, NS_EXP_MEM_ADD, reg);\n\treturn phy_read(phydev, NS_EXP_MEM_DATA);\n}\n\nstatic void ns_exp_write(struct phy_device *phydev, u16 reg, u8 data)\n{\n\tphy_write(phydev, NS_EXP_MEM_ADD, reg);\n\tphy_write(phydev, NS_EXP_MEM_DATA, data);\n}\n\nstatic int ns_ack_interrupt(struct phy_device *phydev)\n{\n\tint ret = phy_read(phydev, DP83865_INT_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = phy_write(phydev, DP83865_INT_CLEAR, ret & ~0x7);\n\n\treturn ret;\n}\n\nstatic irqreturn_t ns_handle_interrupt(struct phy_device *phydev)\n{\n\tint irq_status;\n\n\tirq_status = phy_read(phydev, DP83865_INT_STATUS);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (!(irq_status & DP83865_INT_MASK_DEFAULT))\n\t\treturn IRQ_NONE;\n\n\t \n\tphy_write(phydev, DP83865_INT_CLEAR, irq_status & ~0x7);\n\n\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ns_config_intr(struct phy_device *phydev)\n{\n\tint err;\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\terr = ns_ack_interrupt(phydev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = phy_write(phydev, DP83865_INT_MASK,\n\t\t\t\tDP83865_INT_MASK_DEFAULT);\n\t} else {\n\t\terr = phy_write(phydev, DP83865_INT_MASK, 0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = ns_ack_interrupt(phydev);\n\t}\n\n\treturn err;\n}\n\nstatic void ns_giga_speed_fallback(struct phy_device *phydev, int mode)\n{\n\tint bmcr = phy_read(phydev, MII_BMCR);\n\n\tphy_write(phydev, MII_BMCR, (bmcr | BMCR_PDOWN));\n\n\t \n\tphy_write(phydev, NS_EXP_MEM_CTL, 0);\n\tphy_write(phydev, NS_EXP_MEM_ADD, 0x1C0);\n\tphy_write(phydev, NS_EXP_MEM_DATA, 0x0008);\n\tphy_write(phydev, MII_BMCR, (bmcr & ~BMCR_PDOWN));\n\tphy_write(phydev, LED_CTRL_REG, mode);\n}\n\nstatic void ns_10_base_t_hdx_loopack(struct phy_device *phydev, int disable)\n{\n\tu16 lb_dis = BIT(1);\n\n\tif (disable)\n\t\tns_exp_write(phydev, 0x1c0,\n\t\t\t     ns_exp_read(phydev, 0x1c0) | lb_dis);\n\telse\n\t\tns_exp_write(phydev, 0x1c0,\n\t\t\t     ns_exp_read(phydev, 0x1c0) & ~lb_dis);\n\n\tpr_debug(\"10BASE-T HDX loopback %s\\n\",\n\t\t (ns_exp_read(phydev, 0x1c0) & lb_dis) ? \"off\" : \"on\");\n}\n\nstatic int ns_config_init(struct phy_device *phydev)\n{\n\tns_giga_speed_fallback(phydev, ALL_FALLBACK_ON);\n\t \n\tns_10_base_t_hdx_loopack(phydev, hdx_loopback_off);\n\treturn ns_ack_interrupt(phydev);\n}\n\nstatic struct phy_driver dp83865_driver[] = { {\n\t.phy_id = DP83865_PHY_ID,\n\t.phy_id_mask = 0xfffffff0,\n\t.name = \"NatSemi DP83865\",\n\t \n\t.config_init = ns_config_init,\n\t.config_intr = ns_config_intr,\n\t.handle_interrupt = ns_handle_interrupt,\n} };\n\nmodule_phy_driver(dp83865_driver);\n\nMODULE_DESCRIPTION(\"NatSemi PHY driver\");\nMODULE_AUTHOR(\"Stuart Menefy\");\nMODULE_LICENSE(\"GPL\");\n\nstatic struct mdio_device_id __maybe_unused ns_tbl[] = {\n\t{ DP83865_PHY_ID, 0xfffffff0 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(mdio, ns_tbl);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}