{
  "module_name": "mii_timestamper.c",
  "hash_id": "02e06dfb755a9c037d2c9e98cf5e61de32cba337f1a54dd62e64cae81e8d596a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/mii_timestamper.c",
  "human_readable_source": "\n\n\n\n\n\n#include <linux/mii_timestamper.h>\n\nstatic LIST_HEAD(mii_timestamping_devices);\nstatic DEFINE_MUTEX(tstamping_devices_lock);\n\nstruct mii_timestamping_desc {\n\tstruct list_head list;\n\tstruct mii_timestamping_ctrl *ctrl;\n\tstruct device *device;\n};\n\n \nint register_mii_tstamp_controller(struct device *device,\n\t\t\t\t   struct mii_timestamping_ctrl *ctrl)\n{\n\tstruct mii_timestamping_desc *desc;\n\n\tdesc = kzalloc(sizeof(*desc), GFP_KERNEL);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&desc->list);\n\tdesc->ctrl = ctrl;\n\tdesc->device = device;\n\n\tmutex_lock(&tstamping_devices_lock);\n\tlist_add_tail(&mii_timestamping_devices, &desc->list);\n\tmutex_unlock(&tstamping_devices_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(register_mii_tstamp_controller);\n\n \nvoid unregister_mii_tstamp_controller(struct device *device)\n{\n\tstruct mii_timestamping_desc *desc;\n\tstruct list_head *this, *next;\n\n\tmutex_lock(&tstamping_devices_lock);\n\tlist_for_each_safe(this, next, &mii_timestamping_devices) {\n\t\tdesc = list_entry(this, struct mii_timestamping_desc, list);\n\t\tif (desc->device == device) {\n\t\t\tlist_del_init(&desc->list);\n\t\t\tkfree(desc);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&tstamping_devices_lock);\n}\nEXPORT_SYMBOL(unregister_mii_tstamp_controller);\n\n \nstruct mii_timestamper *register_mii_timestamper(struct device_node *node,\n\t\t\t\t\t\t unsigned int port)\n{\n\tstruct mii_timestamper *mii_ts = NULL;\n\tstruct mii_timestamping_desc *desc;\n\tstruct list_head *this;\n\n\tmutex_lock(&tstamping_devices_lock);\n\tlist_for_each(this, &mii_timestamping_devices) {\n\t\tdesc = list_entry(this, struct mii_timestamping_desc, list);\n\t\tif (desc->device->of_node == node) {\n\t\t\tmii_ts = desc->ctrl->probe_channel(desc->device, port);\n\t\t\tif (!IS_ERR(mii_ts)) {\n\t\t\t\tmii_ts->device = desc->device;\n\t\t\t\tget_device(desc->device);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&tstamping_devices_lock);\n\n\treturn mii_ts ? mii_ts : ERR_PTR(-EPROBE_DEFER);\n}\nEXPORT_SYMBOL(register_mii_timestamper);\n\n \nvoid unregister_mii_timestamper(struct mii_timestamper *mii_ts)\n{\n\tstruct mii_timestamping_desc *desc;\n\tstruct list_head *this;\n\n\tif (!mii_ts)\n\t\treturn;\n\n\t \n\tif (!mii_ts->device)\n\t\treturn;\n\n\tmutex_lock(&tstamping_devices_lock);\n\tlist_for_each(this, &mii_timestamping_devices) {\n\t\tdesc = list_entry(this, struct mii_timestamping_desc, list);\n\t\tif (desc->device == mii_ts->device) {\n\t\t\tdesc->ctrl->release_channel(desc->device, mii_ts);\n\t\t\tput_device(desc->device);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&tstamping_devices_lock);\n}\nEXPORT_SYMBOL(unregister_mii_timestamper);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}