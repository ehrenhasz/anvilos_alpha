{
  "module_name": "bcm84881.c",
  "hash_id": "4f1d3b9c43846e75a1f74edf1ead64b5fe9512474bdd6de876f54e7987e1eb06",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/bcm84881.c",
  "human_readable_source": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/phy.h>\n\nenum {\n\tMDIO_AN_C22 = 0xffe0,\n};\n\nstatic int bcm84881_wait_init(struct phy_device *phydev)\n{\n\tint val;\n\n\treturn phy_read_mmd_poll_timeout(phydev, MDIO_MMD_PMAPMD, MDIO_CTRL1,\n\t\t\t\t\t val, !(val & MDIO_CTRL1_RESET),\n\t\t\t\t\t 100000, 2000000, false);\n}\n\nstatic int bcm84881_config_init(struct phy_device *phydev)\n{\n\tswitch (phydev->interface) {\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_2500BASEX:\n\tcase PHY_INTERFACE_MODE_10GBASER:\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic int bcm84881_probe(struct phy_device *phydev)\n{\n\t \n\tconst u32 mmd_mask = MDIO_DEVS_PMAPMD | MDIO_DEVS_AN;\n\n\tif (!phydev->is_c45 ||\n\t    (phydev->c45_ids.devices_in_package & mmd_mask) != mmd_mask)\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int bcm84881_get_features(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = genphy_c45_pma_read_abilities(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT,\n\t\t\t   phydev->supported);\n\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT,\n\t\t\t   phydev->supported);\n\n\treturn 0;\n}\n\nstatic int bcm84881_config_aneg(struct phy_device *phydev)\n{\n\tbool changed = false;\n\tu32 adv;\n\tint ret;\n\n\t \n\tret = bcm84881_wait_init(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tphydev->mdix_ctrl = ETH_TP_MDI_AUTO;\n\n\t \n\tif (phydev->autoneg == AUTONEG_DISABLE)\n\t\treturn -EINVAL;\n\n\tret = genphy_c45_an_config_aneg(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret > 0)\n\t\tchanged = true;\n\n\tadv = linkmode_adv_to_mii_ctrl1000_t(phydev->advertising);\n\tret = phy_modify_mmd_changed(phydev, MDIO_MMD_AN,\n\t\t\t\t     MDIO_AN_C22 + MII_CTRL1000,\n\t\t\t\t     ADVERTISE_1000FULL | ADVERTISE_1000HALF,\n\t\t\t\t     adv);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret > 0)\n\t\tchanged = true;\n\n\treturn genphy_c45_check_and_restart_aneg(phydev, changed);\n}\n\nstatic int bcm84881_aneg_done(struct phy_device *phydev)\n{\n\tint bmsr, val;\n\n\tval = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_STAT1);\n\tif (val < 0)\n\t\treturn val;\n\n\tbmsr = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_C22 + MII_BMSR);\n\tif (bmsr < 0)\n\t\treturn val;\n\n\treturn !!(val & MDIO_AN_STAT1_COMPLETE) &&\n\t       !!(bmsr & BMSR_ANEGCOMPLETE);\n}\n\nstatic int bcm84881_read_status(struct phy_device *phydev)\n{\n\tunsigned int mode;\n\tint bmsr, val;\n\n\tval = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_CTRL1);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (val & MDIO_AN_CTRL1_RESTART) {\n\t\tphydev->link = 0;\n\t\treturn 0;\n\t}\n\n\tval = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_STAT1);\n\tif (val < 0)\n\t\treturn val;\n\n\tbmsr = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_C22 + MII_BMSR);\n\tif (bmsr < 0)\n\t\treturn val;\n\n\tphydev->autoneg_complete = !!(val & MDIO_AN_STAT1_COMPLETE) &&\n\t\t\t\t   !!(bmsr & BMSR_ANEGCOMPLETE);\n\tphydev->link = !!(val & MDIO_STAT1_LSTATUS) &&\n\t\t       !!(bmsr & BMSR_LSTATUS);\n\tif (phydev->autoneg == AUTONEG_ENABLE && !phydev->autoneg_complete)\n\t\tphydev->link = false;\n\n\tlinkmode_zero(phydev->lp_advertising);\n\tphydev->speed = SPEED_UNKNOWN;\n\tphydev->duplex = DUPLEX_UNKNOWN;\n\tphydev->pause = 0;\n\tphydev->asym_pause = 0;\n\tphydev->mdix = 0;\n\n\tif (!phydev->link)\n\t\treturn 0;\n\n\tif (phydev->autoneg_complete) {\n\t\tval = genphy_c45_read_lpa(phydev);\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tval = phy_read_mmd(phydev, MDIO_MMD_AN,\n\t\t\t\t   MDIO_AN_C22 + MII_STAT1000);\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tmii_stat1000_mod_linkmode_lpa_t(phydev->lp_advertising, val);\n\n\t\tif (phydev->autoneg == AUTONEG_ENABLE)\n\t\t\tphy_resolve_aneg_linkmode(phydev);\n\t}\n\n\tif (phydev->autoneg == AUTONEG_DISABLE) {\n\t\t \n\t\tphydev->link = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tval = phy_read_mmd(phydev, MDIO_MMD_VEND1, 0x4011);\n\tmode = (val & 0x1e) >> 1;\n\tif (mode == 1 || mode == 2)\n\t\tphydev->interface = PHY_INTERFACE_MODE_SGMII;\n\telse if (mode == 3)\n\t\tphydev->interface = PHY_INTERFACE_MODE_10GBASER;\n\telse if (mode == 4)\n\t\tphydev->interface = PHY_INTERFACE_MODE_2500BASEX;\n\tswitch (mode & 7) {\n\tcase 1:\n\t\tphydev->speed = SPEED_100;\n\t\tbreak;\n\tcase 2:\n\t\tphydev->speed = SPEED_1000;\n\t\tbreak;\n\tcase 3:\n\t\tphydev->speed = SPEED_10000;\n\t\tbreak;\n\tcase 4:\n\t\tphydev->speed = SPEED_2500;\n\t\tbreak;\n\tcase 5:\n\t\tphydev->speed = SPEED_5000;\n\t\tbreak;\n\t}\n\n\treturn genphy_c45_read_mdix(phydev);\n}\n\nstatic struct phy_driver bcm84881_drivers[] = {\n\t{\n\t\t.phy_id\t\t= 0xae025150,\n\t\t.phy_id_mask\t= 0xfffffff0,\n\t\t.name\t\t= \"Broadcom BCM84881\",\n\t\t.config_init\t= bcm84881_config_init,\n\t\t.probe\t\t= bcm84881_probe,\n\t\t.get_features\t= bcm84881_get_features,\n\t\t.config_aneg\t= bcm84881_config_aneg,\n\t\t.aneg_done\t= bcm84881_aneg_done,\n\t\t.read_status\t= bcm84881_read_status,\n\t},\n};\n\nmodule_phy_driver(bcm84881_drivers);\n\n \nstatic struct mdio_device_id __maybe_unused bcm84881_tbl[] = {\n\t{ 0xae025150, 0xfffffff0 },\n\t{ },\n};\nMODULE_AUTHOR(\"Russell King\");\nMODULE_DESCRIPTION(\"Broadcom BCM84881 PHY driver\");\nMODULE_DEVICE_TABLE(mdio, bcm84881_tbl);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}