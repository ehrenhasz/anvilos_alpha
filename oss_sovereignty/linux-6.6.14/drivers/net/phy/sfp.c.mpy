{
  "module_name": "sfp.c",
  "hash_id": "010c70155c7e555698041fcc96c675bbe2eb1170086166b13a9411edfba43ae5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/sfp.c",
  "human_readable_source": "\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/hwmon.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/jiffies.h>\n#include <linux/mdio/mdio-i2c.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/phy.h>\n#include <linux/platform_device.h>\n#include <linux/rtnetlink.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n\n#include \"sfp.h\"\n#include \"swphy.h\"\n\nenum {\n\tGPIO_MODDEF0,\n\tGPIO_LOS,\n\tGPIO_TX_FAULT,\n\tGPIO_TX_DISABLE,\n\tGPIO_RS0,\n\tGPIO_RS1,\n\tGPIO_MAX,\n\n\tSFP_F_PRESENT = BIT(GPIO_MODDEF0),\n\tSFP_F_LOS = BIT(GPIO_LOS),\n\tSFP_F_TX_FAULT = BIT(GPIO_TX_FAULT),\n\tSFP_F_TX_DISABLE = BIT(GPIO_TX_DISABLE),\n\tSFP_F_RS0 = BIT(GPIO_RS0),\n\tSFP_F_RS1 = BIT(GPIO_RS1),\n\n\tSFP_F_OUTPUTS = SFP_F_TX_DISABLE | SFP_F_RS0 | SFP_F_RS1,\n\n\tSFP_E_INSERT = 0,\n\tSFP_E_REMOVE,\n\tSFP_E_DEV_ATTACH,\n\tSFP_E_DEV_DETACH,\n\tSFP_E_DEV_DOWN,\n\tSFP_E_DEV_UP,\n\tSFP_E_TX_FAULT,\n\tSFP_E_TX_CLEAR,\n\tSFP_E_LOS_HIGH,\n\tSFP_E_LOS_LOW,\n\tSFP_E_TIMEOUT,\n\n\tSFP_MOD_EMPTY = 0,\n\tSFP_MOD_ERROR,\n\tSFP_MOD_PROBE,\n\tSFP_MOD_WAITDEV,\n\tSFP_MOD_HPOWER,\n\tSFP_MOD_WAITPWR,\n\tSFP_MOD_PRESENT,\n\n\tSFP_DEV_DETACHED = 0,\n\tSFP_DEV_DOWN,\n\tSFP_DEV_UP,\n\n\tSFP_S_DOWN = 0,\n\tSFP_S_FAIL,\n\tSFP_S_WAIT,\n\tSFP_S_INIT,\n\tSFP_S_INIT_PHY,\n\tSFP_S_INIT_TX_FAULT,\n\tSFP_S_WAIT_LOS,\n\tSFP_S_LINK_UP,\n\tSFP_S_TX_FAULT,\n\tSFP_S_REINIT,\n\tSFP_S_TX_DISABLE,\n};\n\nstatic const char  * const mod_state_strings[] = {\n\t[SFP_MOD_EMPTY] = \"empty\",\n\t[SFP_MOD_ERROR] = \"error\",\n\t[SFP_MOD_PROBE] = \"probe\",\n\t[SFP_MOD_WAITDEV] = \"waitdev\",\n\t[SFP_MOD_HPOWER] = \"hpower\",\n\t[SFP_MOD_WAITPWR] = \"waitpwr\",\n\t[SFP_MOD_PRESENT] = \"present\",\n};\n\nstatic const char *mod_state_to_str(unsigned short mod_state)\n{\n\tif (mod_state >= ARRAY_SIZE(mod_state_strings))\n\t\treturn \"Unknown module state\";\n\treturn mod_state_strings[mod_state];\n}\n\nstatic const char * const dev_state_strings[] = {\n\t[SFP_DEV_DETACHED] = \"detached\",\n\t[SFP_DEV_DOWN] = \"down\",\n\t[SFP_DEV_UP] = \"up\",\n};\n\nstatic const char *dev_state_to_str(unsigned short dev_state)\n{\n\tif (dev_state >= ARRAY_SIZE(dev_state_strings))\n\t\treturn \"Unknown device state\";\n\treturn dev_state_strings[dev_state];\n}\n\nstatic const char * const event_strings[] = {\n\t[SFP_E_INSERT] = \"insert\",\n\t[SFP_E_REMOVE] = \"remove\",\n\t[SFP_E_DEV_ATTACH] = \"dev_attach\",\n\t[SFP_E_DEV_DETACH] = \"dev_detach\",\n\t[SFP_E_DEV_DOWN] = \"dev_down\",\n\t[SFP_E_DEV_UP] = \"dev_up\",\n\t[SFP_E_TX_FAULT] = \"tx_fault\",\n\t[SFP_E_TX_CLEAR] = \"tx_clear\",\n\t[SFP_E_LOS_HIGH] = \"los_high\",\n\t[SFP_E_LOS_LOW] = \"los_low\",\n\t[SFP_E_TIMEOUT] = \"timeout\",\n};\n\nstatic const char *event_to_str(unsigned short event)\n{\n\tif (event >= ARRAY_SIZE(event_strings))\n\t\treturn \"Unknown event\";\n\treturn event_strings[event];\n}\n\nstatic const char * const sm_state_strings[] = {\n\t[SFP_S_DOWN] = \"down\",\n\t[SFP_S_FAIL] = \"fail\",\n\t[SFP_S_WAIT] = \"wait\",\n\t[SFP_S_INIT] = \"init\",\n\t[SFP_S_INIT_PHY] = \"init_phy\",\n\t[SFP_S_INIT_TX_FAULT] = \"init_tx_fault\",\n\t[SFP_S_WAIT_LOS] = \"wait_los\",\n\t[SFP_S_LINK_UP] = \"link_up\",\n\t[SFP_S_TX_FAULT] = \"tx_fault\",\n\t[SFP_S_REINIT] = \"reinit\",\n\t[SFP_S_TX_DISABLE] = \"tx_disable\",\n};\n\nstatic const char *sm_state_to_str(unsigned short sm_state)\n{\n\tif (sm_state >= ARRAY_SIZE(sm_state_strings))\n\t\treturn \"Unknown state\";\n\treturn sm_state_strings[sm_state];\n}\n\nstatic const char *gpio_names[] = {\n\t\"mod-def0\",\n\t\"los\",\n\t\"tx-fault\",\n\t\"tx-disable\",\n\t\"rate-select0\",\n\t\"rate-select1\",\n};\n\nstatic const enum gpiod_flags gpio_flags[] = {\n\tGPIOD_IN,\n\tGPIOD_IN,\n\tGPIOD_IN,\n\tGPIOD_ASIS,\n\tGPIOD_ASIS,\n\tGPIOD_ASIS,\n};\n\n \n#define T_WAIT\t\t\tmsecs_to_jiffies(50)\n#define T_START_UP\t\tmsecs_to_jiffies(300)\n#define T_START_UP_BAD_GPON\tmsecs_to_jiffies(60000)\n\n \n#define T_RESET_US\t\t10\n#define T_FAULT_RECOVER\t\tmsecs_to_jiffies(1000)\n\n \n#define N_FAULT_INIT\t\t5\n#define N_FAULT\t\t\t5\n\n \n#define T_PHY_RETRY\t\tmsecs_to_jiffies(50)\n#define R_PHY_RETRY\t\t12\n\n \n#define T_SERIAL\t\tmsecs_to_jiffies(300)\n#define T_HPOWER_LEVEL\t\tmsecs_to_jiffies(300)\n#define T_PROBE_RETRY_INIT\tmsecs_to_jiffies(100)\n#define R_PROBE_RETRY_INIT\t10\n#define T_PROBE_RETRY_SLOW\tmsecs_to_jiffies(5000)\n#define R_PROBE_RETRY_SLOW\t12\n\n \n#define SFP_PHY_ADDR\t\t22\n#define SFP_PHY_ADDR_ROLLBALL\t17\n\n \n#define SFP_EEPROM_BLOCK_SIZE\t16\n\nstruct sff_data {\n\tunsigned int gpios;\n\tbool (*module_supported)(const struct sfp_eeprom_id *id);\n};\n\nstruct sfp {\n\tstruct device *dev;\n\tstruct i2c_adapter *i2c;\n\tstruct mii_bus *i2c_mii;\n\tstruct sfp_bus *sfp_bus;\n\tenum mdio_i2c_proto mdio_protocol;\n\tstruct phy_device *mod_phy;\n\tconst struct sff_data *type;\n\tsize_t i2c_block_size;\n\tu32 max_power_mW;\n\n\tunsigned int (*get_state)(struct sfp *);\n\tvoid (*set_state)(struct sfp *, unsigned int);\n\tint (*read)(struct sfp *, bool, u8, void *, size_t);\n\tint (*write)(struct sfp *, bool, u8, void *, size_t);\n\n\tstruct gpio_desc *gpio[GPIO_MAX];\n\tint gpio_irq[GPIO_MAX];\n\n\tbool need_poll;\n\n\t \n\tstruct mutex st_mutex;\t\t\t \n\tunsigned int state_hw_drive;\n\tunsigned int state_hw_mask;\n\tunsigned int state_soft_mask;\n\tunsigned int state;\n\n\tstruct delayed_work poll;\n\tstruct delayed_work timeout;\n\tstruct mutex sm_mutex;\t\t\t \n\tunsigned char sm_mod_state;\n\tunsigned char sm_mod_tries_init;\n\tunsigned char sm_mod_tries;\n\tunsigned char sm_dev_state;\n\tunsigned short sm_state;\n\tunsigned char sm_fault_retries;\n\tunsigned char sm_phy_retries;\n\n\tstruct sfp_eeprom_id id;\n\tunsigned int module_power_mW;\n\tunsigned int module_t_start_up;\n\tunsigned int module_t_wait;\n\n\tunsigned int rate_kbd;\n\tunsigned int rs_threshold_kbd;\n\tunsigned int rs_state_mask;\n\n\tbool have_a2;\n\tbool tx_fault_ignore;\n\n\tconst struct sfp_quirk *quirk;\n\n#if IS_ENABLED(CONFIG_HWMON)\n\tstruct sfp_diag diag;\n\tstruct delayed_work hwmon_probe;\n\tunsigned int hwmon_tries;\n\tstruct device *hwmon_dev;\n\tchar *hwmon_name;\n#endif\n\n#if IS_ENABLED(CONFIG_DEBUG_FS)\n\tstruct dentry *debugfs_dir;\n#endif\n};\n\nstatic bool sff_module_supported(const struct sfp_eeprom_id *id)\n{\n\treturn id->base.phys_id == SFF8024_ID_SFF_8472 &&\n\t       id->base.phys_ext_id == SFP_PHYS_EXT_ID_SFP;\n}\n\nstatic const struct sff_data sff_data = {\n\t.gpios = SFP_F_LOS | SFP_F_TX_FAULT | SFP_F_TX_DISABLE,\n\t.module_supported = sff_module_supported,\n};\n\nstatic bool sfp_module_supported(const struct sfp_eeprom_id *id)\n{\n\tif (id->base.phys_id == SFF8024_ID_SFP &&\n\t    id->base.phys_ext_id == SFP_PHYS_EXT_ID_SFP)\n\t\treturn true;\n\n\t \n\tif (id->base.phys_id == SFF8024_ID_SFF_8472 &&\n\t    id->base.phys_ext_id == SFP_PHYS_EXT_ID_SFP &&\n\t    !memcmp(id->base.vendor_name, \"UBNT            \", 16) &&\n\t    !memcmp(id->base.vendor_pn, \"UF-INSTANT      \", 16))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic const struct sff_data sfp_data = {\n\t.gpios = SFP_F_PRESENT | SFP_F_LOS | SFP_F_TX_FAULT |\n\t\t SFP_F_TX_DISABLE | SFP_F_RS0 | SFP_F_RS1,\n\t.module_supported = sfp_module_supported,\n};\n\nstatic const struct of_device_id sfp_of_match[] = {\n\t{ .compatible = \"sff,sff\", .data = &sff_data, },\n\t{ .compatible = \"sff,sfp\", .data = &sfp_data, },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, sfp_of_match);\n\nstatic void sfp_fixup_long_startup(struct sfp *sfp)\n{\n\tsfp->module_t_start_up = T_START_UP_BAD_GPON;\n}\n\nstatic void sfp_fixup_ignore_tx_fault(struct sfp *sfp)\n{\n\tsfp->tx_fault_ignore = true;\n}\n\n\nstatic void sfp_fixup_10gbaset_30m(struct sfp *sfp)\n{\n\tsfp->id.base.connector = SFF8024_CONNECTOR_RJ45;\n\tsfp->id.base.extended_cc = SFF8024_ECC_10GBASE_T_SR;\n}\n\nstatic void sfp_fixup_rollball_proto(struct sfp *sfp, unsigned int secs)\n{\n\tsfp->mdio_protocol = MDIO_I2C_ROLLBALL;\n\tsfp->module_t_wait = msecs_to_jiffies(secs * 1000);\n}\n\nstatic void sfp_fixup_fs_10gt(struct sfp *sfp)\n{\n\tsfp_fixup_10gbaset_30m(sfp);\n\n\t\n\tsfp_fixup_rollball_proto(sfp, 4);\n}\n\nstatic void sfp_fixup_halny_gsfp(struct sfp *sfp)\n{\n\t \n\tsfp->state_hw_mask &= ~(SFP_F_TX_FAULT | SFP_F_LOS);\n}\n\nstatic void sfp_fixup_rollball(struct sfp *sfp)\n{\n\t\n\tsfp_fixup_rollball_proto(sfp, 25);\n}\n\nstatic void sfp_fixup_rollball_cc(struct sfp *sfp)\n{\n\tsfp_fixup_rollball(sfp);\n\n\t \n\tsfp->id.base.extended_cc = SFF8024_ECC_10GBASE_T_SFI;\n}\n\nstatic void sfp_quirk_2500basex(const struct sfp_eeprom_id *id,\n\t\t\t\tunsigned long *modes,\n\t\t\t\tunsigned long *interfaces)\n{\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_2500baseX_Full_BIT, modes);\n\t__set_bit(PHY_INTERFACE_MODE_2500BASEX, interfaces);\n}\n\nstatic void sfp_quirk_disable_autoneg(const struct sfp_eeprom_id *id,\n\t\t\t\t      unsigned long *modes,\n\t\t\t\t      unsigned long *interfaces)\n{\n\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, modes);\n}\n\nstatic void sfp_quirk_oem_2_5g(const struct sfp_eeprom_id *id,\n\t\t\t       unsigned long *modes,\n\t\t\t       unsigned long *interfaces)\n{\n\t \n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT, modes);\n\t__set_bit(PHY_INTERFACE_MODE_2500BASEX, interfaces);\n\tsfp_quirk_disable_autoneg(id, modes, interfaces);\n}\n\nstatic void sfp_quirk_ubnt_uf_instant(const struct sfp_eeprom_id *id,\n\t\t\t\t      unsigned long *modes,\n\t\t\t\t      unsigned long *interfaces)\n{\n\t \n\tlinkmode_zero(modes);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT, modes);\n}\n\n#define SFP_QUIRK(_v, _p, _m, _f) \\\n\t{ .vendor = _v, .part = _p, .modes = _m, .fixup = _f, }\n#define SFP_QUIRK_M(_v, _p, _m) SFP_QUIRK(_v, _p, _m, NULL)\n#define SFP_QUIRK_F(_v, _p, _f) SFP_QUIRK(_v, _p, NULL, _f)\n\nstatic const struct sfp_quirk sfp_quirks[] = {\n\t\n\t\n\tSFP_QUIRK_M(\"ALCATELLUCENT\", \"G010SP\", sfp_quirk_2500basex),\n\n\t\n\t\n\tSFP_QUIRK(\"ALCATELLUCENT\", \"3FE46541AA\", sfp_quirk_2500basex,\n\t\t  sfp_fixup_long_startup),\n\n\t\n\t\n\tSFP_QUIRK_F(\"FS\", \"SFP-10G-T\", sfp_fixup_fs_10gt),\n\n\t\n\t\n\tSFP_QUIRK(\"FS\", \"GPON-ONU-34-20BI\", sfp_quirk_2500basex,\n\t\t  sfp_fixup_ignore_tx_fault),\n\n\tSFP_QUIRK_F(\"HALNy\", \"HL-GSFP\", sfp_fixup_halny_gsfp),\n\n\t\n\t\n\tSFP_QUIRK_M(\"HG GENUINE\", \"MXPD-483II\", sfp_quirk_2500basex),\n\n\t\n\t\n\tSFP_QUIRK(\"HUAWEI\", \"MA5671A\", sfp_quirk_2500basex,\n\t\t  sfp_fixup_ignore_tx_fault),\n\n\t\n\tSFP_QUIRK_M(\"FS\", \"SFP-2.5G-T\", sfp_quirk_oem_2_5g),\n\n\t\n\t\n\tSFP_QUIRK_M(\"Lantech\", \"8330-262D-E\", sfp_quirk_2500basex),\n\n\tSFP_QUIRK_M(\"UBNT\", \"UF-INSTANT\", sfp_quirk_ubnt_uf_instant),\n\n\t\n\t\n\tSFP_QUIRK_F(\"Walsun\", \"HXSX-ATRC-1\", sfp_fixup_fs_10gt),\n\tSFP_QUIRK_F(\"Walsun\", \"HXSX-ATRI-1\", sfp_fixup_fs_10gt),\n\n\tSFP_QUIRK_F(\"OEM\", \"SFP-10G-T\", sfp_fixup_rollball_cc),\n\tSFP_QUIRK_M(\"OEM\", \"SFP-2.5G-T\", sfp_quirk_oem_2_5g),\n\tSFP_QUIRK_F(\"OEM\", \"RTSFP-10\", sfp_fixup_rollball_cc),\n\tSFP_QUIRK_F(\"OEM\", \"RTSFP-10G\", sfp_fixup_rollball_cc),\n\tSFP_QUIRK_F(\"Turris\", \"RTSFP-10\", sfp_fixup_rollball),\n\tSFP_QUIRK_F(\"Turris\", \"RTSFP-10G\", sfp_fixup_rollball),\n};\n\nstatic size_t sfp_strlen(const char *str, size_t maxlen)\n{\n\tsize_t size, i;\n\n\t \n\tfor (i = 0, size = 0; i < maxlen; i++)\n\t\tif (str[i] != ' ' && str[i] != '\\0')\n\t\t\tsize = i + 1;\n\n\treturn size;\n}\n\nstatic bool sfp_match(const char *qs, const char *str, size_t len)\n{\n\tif (!qs)\n\t\treturn true;\n\tif (strlen(qs) != len)\n\t\treturn false;\n\treturn !strncmp(qs, str, len);\n}\n\nstatic const struct sfp_quirk *sfp_lookup_quirk(const struct sfp_eeprom_id *id)\n{\n\tconst struct sfp_quirk *q;\n\tunsigned int i;\n\tsize_t vs, ps;\n\n\tvs = sfp_strlen(id->base.vendor_name, ARRAY_SIZE(id->base.vendor_name));\n\tps = sfp_strlen(id->base.vendor_pn, ARRAY_SIZE(id->base.vendor_pn));\n\n\tfor (i = 0, q = sfp_quirks; i < ARRAY_SIZE(sfp_quirks); i++, q++)\n\t\tif (sfp_match(q->vendor, id->base.vendor_name, vs) &&\n\t\t    sfp_match(q->part, id->base.vendor_pn, ps))\n\t\t\treturn q;\n\n\treturn NULL;\n}\n\nstatic unsigned long poll_jiffies;\n\nstatic unsigned int sfp_gpio_get_state(struct sfp *sfp)\n{\n\tunsigned int i, state, v;\n\n\tfor (i = state = 0; i < GPIO_MAX; i++) {\n\t\tif (gpio_flags[i] != GPIOD_IN || !sfp->gpio[i])\n\t\t\tcontinue;\n\n\t\tv = gpiod_get_value_cansleep(sfp->gpio[i]);\n\t\tif (v)\n\t\t\tstate |= BIT(i);\n\t}\n\n\treturn state;\n}\n\nstatic unsigned int sff_gpio_get_state(struct sfp *sfp)\n{\n\treturn sfp_gpio_get_state(sfp) | SFP_F_PRESENT;\n}\n\nstatic void sfp_gpio_set_state(struct sfp *sfp, unsigned int state)\n{\n\tunsigned int drive;\n\n\tif (state & SFP_F_PRESENT)\n\t\t \n\t\tdrive = sfp->state_hw_drive;\n\telse\n\t\t \n\t\tdrive = 0;\n\n\tif (sfp->gpio[GPIO_TX_DISABLE]) {\n\t\tif (drive & SFP_F_TX_DISABLE)\n\t\t\tgpiod_direction_output(sfp->gpio[GPIO_TX_DISABLE],\n\t\t\t\t\t       state & SFP_F_TX_DISABLE);\n\t\telse\n\t\t\tgpiod_direction_input(sfp->gpio[GPIO_TX_DISABLE]);\n\t}\n\n\tif (sfp->gpio[GPIO_RS0]) {\n\t\tif (drive & SFP_F_RS0)\n\t\t\tgpiod_direction_output(sfp->gpio[GPIO_RS0],\n\t\t\t\t\t       state & SFP_F_RS0);\n\t\telse\n\t\t\tgpiod_direction_input(sfp->gpio[GPIO_RS0]);\n\t}\n\n\tif (sfp->gpio[GPIO_RS1]) {\n\t\tif (drive & SFP_F_RS1)\n\t\t\tgpiod_direction_output(sfp->gpio[GPIO_RS1],\n\t\t\t\t\t       state & SFP_F_RS1);\n\t\telse\n\t\t\tgpiod_direction_input(sfp->gpio[GPIO_RS1]);\n\t}\n}\n\nstatic int sfp_i2c_read(struct sfp *sfp, bool a2, u8 dev_addr, void *buf,\n\t\t\tsize_t len)\n{\n\tstruct i2c_msg msgs[2];\n\tu8 bus_addr = a2 ? 0x51 : 0x50;\n\tsize_t block_size = sfp->i2c_block_size;\n\tsize_t this_len;\n\tint ret;\n\n\tmsgs[0].addr = bus_addr;\n\tmsgs[0].flags = 0;\n\tmsgs[0].len = 1;\n\tmsgs[0].buf = &dev_addr;\n\tmsgs[1].addr = bus_addr;\n\tmsgs[1].flags = I2C_M_RD;\n\tmsgs[1].len = len;\n\tmsgs[1].buf = buf;\n\n\twhile (len) {\n\t\tthis_len = len;\n\t\tif (this_len > block_size)\n\t\t\tthis_len = block_size;\n\n\t\tmsgs[1].len = this_len;\n\n\t\tret = i2c_transfer(sfp->i2c, msgs, ARRAY_SIZE(msgs));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (ret != ARRAY_SIZE(msgs))\n\t\t\tbreak;\n\n\t\tmsgs[1].buf += this_len;\n\t\tdev_addr += this_len;\n\t\tlen -= this_len;\n\t}\n\n\treturn msgs[1].buf - (u8 *)buf;\n}\n\nstatic int sfp_i2c_write(struct sfp *sfp, bool a2, u8 dev_addr, void *buf,\n\tsize_t len)\n{\n\tstruct i2c_msg msgs[1];\n\tu8 bus_addr = a2 ? 0x51 : 0x50;\n\tint ret;\n\n\tmsgs[0].addr = bus_addr;\n\tmsgs[0].flags = 0;\n\tmsgs[0].len = 1 + len;\n\tmsgs[0].buf = kmalloc(1 + len, GFP_KERNEL);\n\tif (!msgs[0].buf)\n\t\treturn -ENOMEM;\n\n\tmsgs[0].buf[0] = dev_addr;\n\tmemcpy(&msgs[0].buf[1], buf, len);\n\n\tret = i2c_transfer(sfp->i2c, msgs, ARRAY_SIZE(msgs));\n\n\tkfree(msgs[0].buf);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret == ARRAY_SIZE(msgs) ? len : 0;\n}\n\nstatic int sfp_i2c_configure(struct sfp *sfp, struct i2c_adapter *i2c)\n{\n\tif (!i2c_check_functionality(i2c, I2C_FUNC_I2C))\n\t\treturn -EINVAL;\n\n\tsfp->i2c = i2c;\n\tsfp->read = sfp_i2c_read;\n\tsfp->write = sfp_i2c_write;\n\n\treturn 0;\n}\n\nstatic int sfp_i2c_mdiobus_create(struct sfp *sfp)\n{\n\tstruct mii_bus *i2c_mii;\n\tint ret;\n\n\ti2c_mii = mdio_i2c_alloc(sfp->dev, sfp->i2c, sfp->mdio_protocol);\n\tif (IS_ERR(i2c_mii))\n\t\treturn PTR_ERR(i2c_mii);\n\n\ti2c_mii->name = \"SFP I2C Bus\";\n\ti2c_mii->phy_mask = ~0;\n\n\tret = mdiobus_register(i2c_mii);\n\tif (ret < 0) {\n\t\tmdiobus_free(i2c_mii);\n\t\treturn ret;\n\t}\n\n\tsfp->i2c_mii = i2c_mii;\n\n\treturn 0;\n}\n\nstatic void sfp_i2c_mdiobus_destroy(struct sfp *sfp)\n{\n\tmdiobus_unregister(sfp->i2c_mii);\n\tsfp->i2c_mii = NULL;\n}\n\n \nstatic int sfp_read(struct sfp *sfp, bool a2, u8 addr, void *buf, size_t len)\n{\n\treturn sfp->read(sfp, a2, addr, buf, len);\n}\n\nstatic int sfp_write(struct sfp *sfp, bool a2, u8 addr, void *buf, size_t len)\n{\n\treturn sfp->write(sfp, a2, addr, buf, len);\n}\n\nstatic int sfp_modify_u8(struct sfp *sfp, bool a2, u8 addr, u8 mask, u8 val)\n{\n\tint ret;\n\tu8 old, v;\n\n\tret = sfp_read(sfp, a2, addr, &old, sizeof(old));\n\tif (ret != sizeof(old))\n\t\treturn ret;\n\n\tv = (old & ~mask) | (val & mask);\n\tif (v == old)\n\t\treturn sizeof(v);\n\n\treturn sfp_write(sfp, a2, addr, &v, sizeof(v));\n}\n\nstatic unsigned int sfp_soft_get_state(struct sfp *sfp)\n{\n\tunsigned int state = 0;\n\tu8 status;\n\tint ret;\n\n\tret = sfp_read(sfp, true, SFP_STATUS, &status, sizeof(status));\n\tif (ret == sizeof(status)) {\n\t\tif (status & SFP_STATUS_RX_LOS)\n\t\t\tstate |= SFP_F_LOS;\n\t\tif (status & SFP_STATUS_TX_FAULT)\n\t\t\tstate |= SFP_F_TX_FAULT;\n\t} else {\n\t\tdev_err_ratelimited(sfp->dev,\n\t\t\t\t    \"failed to read SFP soft status: %pe\\n\",\n\t\t\t\t    ERR_PTR(ret));\n\t\t \n\t\tstate = sfp->state;\n\t}\n\n\treturn state & sfp->state_soft_mask;\n}\n\nstatic void sfp_soft_set_state(struct sfp *sfp, unsigned int state,\n\t\t\t       unsigned int soft)\n{\n\tu8 mask = 0;\n\tu8 val = 0;\n\n\tif (soft & SFP_F_TX_DISABLE)\n\t\tmask |= SFP_STATUS_TX_DISABLE_FORCE;\n\tif (state & SFP_F_TX_DISABLE)\n\t\tval |= SFP_STATUS_TX_DISABLE_FORCE;\n\n\tif (soft & SFP_F_RS0)\n\t\tmask |= SFP_STATUS_RS0_SELECT;\n\tif (state & SFP_F_RS0)\n\t\tval |= SFP_STATUS_RS0_SELECT;\n\n\tif (mask)\n\t\tsfp_modify_u8(sfp, true, SFP_STATUS, mask, val);\n\n\tval = mask = 0;\n\tif (soft & SFP_F_RS1)\n\t\tmask |= SFP_EXT_STATUS_RS1_SELECT;\n\tif (state & SFP_F_RS1)\n\t\tval |= SFP_EXT_STATUS_RS1_SELECT;\n\n\tif (mask)\n\t\tsfp_modify_u8(sfp, true, SFP_EXT_STATUS, mask, val);\n}\n\nstatic void sfp_soft_start_poll(struct sfp *sfp)\n{\n\tconst struct sfp_eeprom_id *id = &sfp->id;\n\tunsigned int mask = 0;\n\n\tif (id->ext.enhopts & SFP_ENHOPTS_SOFT_TX_DISABLE)\n\t\tmask |= SFP_F_TX_DISABLE;\n\tif (id->ext.enhopts & SFP_ENHOPTS_SOFT_TX_FAULT)\n\t\tmask |= SFP_F_TX_FAULT;\n\tif (id->ext.enhopts & SFP_ENHOPTS_SOFT_RX_LOS)\n\t\tmask |= SFP_F_LOS;\n\tif (id->ext.enhopts & SFP_ENHOPTS_SOFT_RATE_SELECT)\n\t\tmask |= sfp->rs_state_mask;\n\n\tmutex_lock(&sfp->st_mutex);\n\t \n\tsfp->state_soft_mask = ~sfp->state_hw_mask & mask;\n\n\tif (sfp->state_soft_mask & (SFP_F_LOS | SFP_F_TX_FAULT) &&\n\t    !sfp->need_poll)\n\t\tmod_delayed_work(system_wq, &sfp->poll, poll_jiffies);\n\tmutex_unlock(&sfp->st_mutex);\n}\n\nstatic void sfp_soft_stop_poll(struct sfp *sfp)\n{\n\tmutex_lock(&sfp->st_mutex);\n\tsfp->state_soft_mask = 0;\n\tmutex_unlock(&sfp->st_mutex);\n}\n\n \nstatic unsigned int sfp_get_state(struct sfp *sfp)\n{\n\tunsigned int soft = sfp->state_soft_mask & (SFP_F_LOS | SFP_F_TX_FAULT);\n\tunsigned int state;\n\n\tstate = sfp->get_state(sfp) & sfp->state_hw_mask;\n\tif (state & SFP_F_PRESENT && soft)\n\t\tstate |= sfp_soft_get_state(sfp);\n\n\treturn state;\n}\n\n \nstatic void sfp_set_state(struct sfp *sfp, unsigned int state)\n{\n\tunsigned int soft;\n\n\tsfp->set_state(sfp, state);\n\n\tsoft = sfp->state_soft_mask & SFP_F_OUTPUTS;\n\tif (state & SFP_F_PRESENT && soft)\n\t\tsfp_soft_set_state(sfp, state, soft);\n}\n\nstatic void sfp_mod_state(struct sfp *sfp, unsigned int mask, unsigned int set)\n{\n\tmutex_lock(&sfp->st_mutex);\n\tsfp->state = (sfp->state & ~mask) | set;\n\tsfp_set_state(sfp, sfp->state);\n\tmutex_unlock(&sfp->st_mutex);\n}\n\nstatic unsigned int sfp_check(void *buf, size_t len)\n{\n\tu8 *p, check;\n\n\tfor (p = buf, check = 0; len; p++, len--)\n\t\tcheck += *p;\n\n\treturn check;\n}\n\n \n#if IS_ENABLED(CONFIG_HWMON)\nstatic umode_t sfp_hwmon_is_visible(const void *data,\n\t\t\t\t    enum hwmon_sensor_types type,\n\t\t\t\t    u32 attr, int channel)\n{\n\tconst struct sfp *sfp = data;\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_min_alarm:\n\t\tcase hwmon_temp_max_alarm:\n\t\tcase hwmon_temp_lcrit_alarm:\n\t\tcase hwmon_temp_crit_alarm:\n\t\tcase hwmon_temp_min:\n\t\tcase hwmon_temp_max:\n\t\tcase hwmon_temp_lcrit:\n\t\tcase hwmon_temp_crit:\n\t\t\tif (!(sfp->id.ext.enhopts & SFP_ENHOPTS_ALARMWARN))\n\t\t\t\treturn 0;\n\t\t\tfallthrough;\n\t\tcase hwmon_temp_input:\n\t\tcase hwmon_temp_label:\n\t\t\treturn 0444;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_min_alarm:\n\t\tcase hwmon_in_max_alarm:\n\t\tcase hwmon_in_lcrit_alarm:\n\t\tcase hwmon_in_crit_alarm:\n\t\tcase hwmon_in_min:\n\t\tcase hwmon_in_max:\n\t\tcase hwmon_in_lcrit:\n\t\tcase hwmon_in_crit:\n\t\t\tif (!(sfp->id.ext.enhopts & SFP_ENHOPTS_ALARMWARN))\n\t\t\t\treturn 0;\n\t\t\tfallthrough;\n\t\tcase hwmon_in_input:\n\t\tcase hwmon_in_label:\n\t\t\treturn 0444;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase hwmon_curr:\n\t\tswitch (attr) {\n\t\tcase hwmon_curr_min_alarm:\n\t\tcase hwmon_curr_max_alarm:\n\t\tcase hwmon_curr_lcrit_alarm:\n\t\tcase hwmon_curr_crit_alarm:\n\t\tcase hwmon_curr_min:\n\t\tcase hwmon_curr_max:\n\t\tcase hwmon_curr_lcrit:\n\t\tcase hwmon_curr_crit:\n\t\t\tif (!(sfp->id.ext.enhopts & SFP_ENHOPTS_ALARMWARN))\n\t\t\t\treturn 0;\n\t\t\tfallthrough;\n\t\tcase hwmon_curr_input:\n\t\tcase hwmon_curr_label:\n\t\t\treturn 0444;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tcase hwmon_power:\n\t\t \n\t\tif (sfp->id.ext.diagmon & SFP_DIAGMON_EXT_CAL &&\n\t\t    channel == 1)\n\t\t\treturn 0;\n\t\tswitch (attr) {\n\t\tcase hwmon_power_min_alarm:\n\t\tcase hwmon_power_max_alarm:\n\t\tcase hwmon_power_lcrit_alarm:\n\t\tcase hwmon_power_crit_alarm:\n\t\tcase hwmon_power_min:\n\t\tcase hwmon_power_max:\n\t\tcase hwmon_power_lcrit:\n\t\tcase hwmon_power_crit:\n\t\t\tif (!(sfp->id.ext.enhopts & SFP_ENHOPTS_ALARMWARN))\n\t\t\t\treturn 0;\n\t\t\tfallthrough;\n\t\tcase hwmon_power_input:\n\t\tcase hwmon_power_label:\n\t\t\treturn 0444;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int sfp_hwmon_read_sensor(struct sfp *sfp, int reg, long *value)\n{\n\t__be16 val;\n\tint err;\n\n\terr = sfp_read(sfp, true, reg, &val, sizeof(val));\n\tif (err < 0)\n\t\treturn err;\n\n\t*value = be16_to_cpu(val);\n\n\treturn 0;\n}\n\nstatic void sfp_hwmon_to_rx_power(long *value)\n{\n\t*value = DIV_ROUND_CLOSEST(*value, 10);\n}\n\nstatic void sfp_hwmon_calibrate(struct sfp *sfp, unsigned int slope, int offset,\n\t\t\t\tlong *value)\n{\n\tif (sfp->id.ext.diagmon & SFP_DIAGMON_EXT_CAL)\n\t\t*value = DIV_ROUND_CLOSEST(*value * slope, 256) + offset;\n}\n\nstatic void sfp_hwmon_calibrate_temp(struct sfp *sfp, long *value)\n{\n\tsfp_hwmon_calibrate(sfp, be16_to_cpu(sfp->diag.cal_t_slope),\n\t\t\t    be16_to_cpu(sfp->diag.cal_t_offset), value);\n\n\tif (*value >= 0x8000)\n\t\t*value -= 0x10000;\n\n\t*value = DIV_ROUND_CLOSEST(*value * 1000, 256);\n}\n\nstatic void sfp_hwmon_calibrate_vcc(struct sfp *sfp, long *value)\n{\n\tsfp_hwmon_calibrate(sfp, be16_to_cpu(sfp->diag.cal_v_slope),\n\t\t\t    be16_to_cpu(sfp->diag.cal_v_offset), value);\n\n\t*value = DIV_ROUND_CLOSEST(*value, 10);\n}\n\nstatic void sfp_hwmon_calibrate_bias(struct sfp *sfp, long *value)\n{\n\tsfp_hwmon_calibrate(sfp, be16_to_cpu(sfp->diag.cal_txi_slope),\n\t\t\t    be16_to_cpu(sfp->diag.cal_txi_offset), value);\n\n\t*value = DIV_ROUND_CLOSEST(*value, 500);\n}\n\nstatic void sfp_hwmon_calibrate_tx_power(struct sfp *sfp, long *value)\n{\n\tsfp_hwmon_calibrate(sfp, be16_to_cpu(sfp->diag.cal_txpwr_slope),\n\t\t\t    be16_to_cpu(sfp->diag.cal_txpwr_offset), value);\n\n\t*value = DIV_ROUND_CLOSEST(*value, 10);\n}\n\nstatic int sfp_hwmon_read_temp(struct sfp *sfp, int reg, long *value)\n{\n\tint err;\n\n\terr = sfp_hwmon_read_sensor(sfp, reg, value);\n\tif (err < 0)\n\t\treturn err;\n\n\tsfp_hwmon_calibrate_temp(sfp, value);\n\n\treturn 0;\n}\n\nstatic int sfp_hwmon_read_vcc(struct sfp *sfp, int reg, long *value)\n{\n\tint err;\n\n\terr = sfp_hwmon_read_sensor(sfp, reg, value);\n\tif (err < 0)\n\t\treturn err;\n\n\tsfp_hwmon_calibrate_vcc(sfp, value);\n\n\treturn 0;\n}\n\nstatic int sfp_hwmon_read_bias(struct sfp *sfp, int reg, long *value)\n{\n\tint err;\n\n\terr = sfp_hwmon_read_sensor(sfp, reg, value);\n\tif (err < 0)\n\t\treturn err;\n\n\tsfp_hwmon_calibrate_bias(sfp, value);\n\n\treturn 0;\n}\n\nstatic int sfp_hwmon_read_tx_power(struct sfp *sfp, int reg, long *value)\n{\n\tint err;\n\n\terr = sfp_hwmon_read_sensor(sfp, reg, value);\n\tif (err < 0)\n\t\treturn err;\n\n\tsfp_hwmon_calibrate_tx_power(sfp, value);\n\n\treturn 0;\n}\n\nstatic int sfp_hwmon_read_rx_power(struct sfp *sfp, int reg, long *value)\n{\n\tint err;\n\n\terr = sfp_hwmon_read_sensor(sfp, reg, value);\n\tif (err < 0)\n\t\treturn err;\n\n\tsfp_hwmon_to_rx_power(value);\n\n\treturn 0;\n}\n\nstatic int sfp_hwmon_temp(struct sfp *sfp, u32 attr, long *value)\n{\n\tu8 status;\n\tint err;\n\n\tswitch (attr) {\n\tcase hwmon_temp_input:\n\t\treturn sfp_hwmon_read_temp(sfp, SFP_TEMP, value);\n\n\tcase hwmon_temp_lcrit:\n\t\t*value = be16_to_cpu(sfp->diag.temp_low_alarm);\n\t\tsfp_hwmon_calibrate_temp(sfp, value);\n\t\treturn 0;\n\n\tcase hwmon_temp_min:\n\t\t*value = be16_to_cpu(sfp->diag.temp_low_warn);\n\t\tsfp_hwmon_calibrate_temp(sfp, value);\n\t\treturn 0;\n\tcase hwmon_temp_max:\n\t\t*value = be16_to_cpu(sfp->diag.temp_high_warn);\n\t\tsfp_hwmon_calibrate_temp(sfp, value);\n\t\treturn 0;\n\n\tcase hwmon_temp_crit:\n\t\t*value = be16_to_cpu(sfp->diag.temp_high_alarm);\n\t\tsfp_hwmon_calibrate_temp(sfp, value);\n\t\treturn 0;\n\n\tcase hwmon_temp_lcrit_alarm:\n\t\terr = sfp_read(sfp, true, SFP_ALARM0, &status, sizeof(status));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t*value = !!(status & SFP_ALARM0_TEMP_LOW);\n\t\treturn 0;\n\n\tcase hwmon_temp_min_alarm:\n\t\terr = sfp_read(sfp, true, SFP_WARN0, &status, sizeof(status));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t*value = !!(status & SFP_WARN0_TEMP_LOW);\n\t\treturn 0;\n\n\tcase hwmon_temp_max_alarm:\n\t\terr = sfp_read(sfp, true, SFP_WARN0, &status, sizeof(status));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t*value = !!(status & SFP_WARN0_TEMP_HIGH);\n\t\treturn 0;\n\n\tcase hwmon_temp_crit_alarm:\n\t\terr = sfp_read(sfp, true, SFP_ALARM0, &status, sizeof(status));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t*value = !!(status & SFP_ALARM0_TEMP_HIGH);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int sfp_hwmon_vcc(struct sfp *sfp, u32 attr, long *value)\n{\n\tu8 status;\n\tint err;\n\n\tswitch (attr) {\n\tcase hwmon_in_input:\n\t\treturn sfp_hwmon_read_vcc(sfp, SFP_VCC, value);\n\n\tcase hwmon_in_lcrit:\n\t\t*value = be16_to_cpu(sfp->diag.volt_low_alarm);\n\t\tsfp_hwmon_calibrate_vcc(sfp, value);\n\t\treturn 0;\n\n\tcase hwmon_in_min:\n\t\t*value = be16_to_cpu(sfp->diag.volt_low_warn);\n\t\tsfp_hwmon_calibrate_vcc(sfp, value);\n\t\treturn 0;\n\n\tcase hwmon_in_max:\n\t\t*value = be16_to_cpu(sfp->diag.volt_high_warn);\n\t\tsfp_hwmon_calibrate_vcc(sfp, value);\n\t\treturn 0;\n\n\tcase hwmon_in_crit:\n\t\t*value = be16_to_cpu(sfp->diag.volt_high_alarm);\n\t\tsfp_hwmon_calibrate_vcc(sfp, value);\n\t\treturn 0;\n\n\tcase hwmon_in_lcrit_alarm:\n\t\terr = sfp_read(sfp, true, SFP_ALARM0, &status, sizeof(status));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t*value = !!(status & SFP_ALARM0_VCC_LOW);\n\t\treturn 0;\n\n\tcase hwmon_in_min_alarm:\n\t\terr = sfp_read(sfp, true, SFP_WARN0, &status, sizeof(status));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t*value = !!(status & SFP_WARN0_VCC_LOW);\n\t\treturn 0;\n\n\tcase hwmon_in_max_alarm:\n\t\terr = sfp_read(sfp, true, SFP_WARN0, &status, sizeof(status));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t*value = !!(status & SFP_WARN0_VCC_HIGH);\n\t\treturn 0;\n\n\tcase hwmon_in_crit_alarm:\n\t\terr = sfp_read(sfp, true, SFP_ALARM0, &status, sizeof(status));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t*value = !!(status & SFP_ALARM0_VCC_HIGH);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int sfp_hwmon_bias(struct sfp *sfp, u32 attr, long *value)\n{\n\tu8 status;\n\tint err;\n\n\tswitch (attr) {\n\tcase hwmon_curr_input:\n\t\treturn sfp_hwmon_read_bias(sfp, SFP_TX_BIAS, value);\n\n\tcase hwmon_curr_lcrit:\n\t\t*value = be16_to_cpu(sfp->diag.bias_low_alarm);\n\t\tsfp_hwmon_calibrate_bias(sfp, value);\n\t\treturn 0;\n\n\tcase hwmon_curr_min:\n\t\t*value = be16_to_cpu(sfp->diag.bias_low_warn);\n\t\tsfp_hwmon_calibrate_bias(sfp, value);\n\t\treturn 0;\n\n\tcase hwmon_curr_max:\n\t\t*value = be16_to_cpu(sfp->diag.bias_high_warn);\n\t\tsfp_hwmon_calibrate_bias(sfp, value);\n\t\treturn 0;\n\n\tcase hwmon_curr_crit:\n\t\t*value = be16_to_cpu(sfp->diag.bias_high_alarm);\n\t\tsfp_hwmon_calibrate_bias(sfp, value);\n\t\treturn 0;\n\n\tcase hwmon_curr_lcrit_alarm:\n\t\terr = sfp_read(sfp, true, SFP_ALARM0, &status, sizeof(status));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t*value = !!(status & SFP_ALARM0_TX_BIAS_LOW);\n\t\treturn 0;\n\n\tcase hwmon_curr_min_alarm:\n\t\terr = sfp_read(sfp, true, SFP_WARN0, &status, sizeof(status));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t*value = !!(status & SFP_WARN0_TX_BIAS_LOW);\n\t\treturn 0;\n\n\tcase hwmon_curr_max_alarm:\n\t\terr = sfp_read(sfp, true, SFP_WARN0, &status, sizeof(status));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t*value = !!(status & SFP_WARN0_TX_BIAS_HIGH);\n\t\treturn 0;\n\n\tcase hwmon_curr_crit_alarm:\n\t\terr = sfp_read(sfp, true, SFP_ALARM0, &status, sizeof(status));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t*value = !!(status & SFP_ALARM0_TX_BIAS_HIGH);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int sfp_hwmon_tx_power(struct sfp *sfp, u32 attr, long *value)\n{\n\tu8 status;\n\tint err;\n\n\tswitch (attr) {\n\tcase hwmon_power_input:\n\t\treturn sfp_hwmon_read_tx_power(sfp, SFP_TX_POWER, value);\n\n\tcase hwmon_power_lcrit:\n\t\t*value = be16_to_cpu(sfp->diag.txpwr_low_alarm);\n\t\tsfp_hwmon_calibrate_tx_power(sfp, value);\n\t\treturn 0;\n\n\tcase hwmon_power_min:\n\t\t*value = be16_to_cpu(sfp->diag.txpwr_low_warn);\n\t\tsfp_hwmon_calibrate_tx_power(sfp, value);\n\t\treturn 0;\n\n\tcase hwmon_power_max:\n\t\t*value = be16_to_cpu(sfp->diag.txpwr_high_warn);\n\t\tsfp_hwmon_calibrate_tx_power(sfp, value);\n\t\treturn 0;\n\n\tcase hwmon_power_crit:\n\t\t*value = be16_to_cpu(sfp->diag.txpwr_high_alarm);\n\t\tsfp_hwmon_calibrate_tx_power(sfp, value);\n\t\treturn 0;\n\n\tcase hwmon_power_lcrit_alarm:\n\t\terr = sfp_read(sfp, true, SFP_ALARM0, &status, sizeof(status));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t*value = !!(status & SFP_ALARM0_TXPWR_LOW);\n\t\treturn 0;\n\n\tcase hwmon_power_min_alarm:\n\t\terr = sfp_read(sfp, true, SFP_WARN0, &status, sizeof(status));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t*value = !!(status & SFP_WARN0_TXPWR_LOW);\n\t\treturn 0;\n\n\tcase hwmon_power_max_alarm:\n\t\terr = sfp_read(sfp, true, SFP_WARN0, &status, sizeof(status));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t*value = !!(status & SFP_WARN0_TXPWR_HIGH);\n\t\treturn 0;\n\n\tcase hwmon_power_crit_alarm:\n\t\terr = sfp_read(sfp, true, SFP_ALARM0, &status, sizeof(status));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t*value = !!(status & SFP_ALARM0_TXPWR_HIGH);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int sfp_hwmon_rx_power(struct sfp *sfp, u32 attr, long *value)\n{\n\tu8 status;\n\tint err;\n\n\tswitch (attr) {\n\tcase hwmon_power_input:\n\t\treturn sfp_hwmon_read_rx_power(sfp, SFP_RX_POWER, value);\n\n\tcase hwmon_power_lcrit:\n\t\t*value = be16_to_cpu(sfp->diag.rxpwr_low_alarm);\n\t\tsfp_hwmon_to_rx_power(value);\n\t\treturn 0;\n\n\tcase hwmon_power_min:\n\t\t*value = be16_to_cpu(sfp->diag.rxpwr_low_warn);\n\t\tsfp_hwmon_to_rx_power(value);\n\t\treturn 0;\n\n\tcase hwmon_power_max:\n\t\t*value = be16_to_cpu(sfp->diag.rxpwr_high_warn);\n\t\tsfp_hwmon_to_rx_power(value);\n\t\treturn 0;\n\n\tcase hwmon_power_crit:\n\t\t*value = be16_to_cpu(sfp->diag.rxpwr_high_alarm);\n\t\tsfp_hwmon_to_rx_power(value);\n\t\treturn 0;\n\n\tcase hwmon_power_lcrit_alarm:\n\t\terr = sfp_read(sfp, true, SFP_ALARM1, &status, sizeof(status));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t*value = !!(status & SFP_ALARM1_RXPWR_LOW);\n\t\treturn 0;\n\n\tcase hwmon_power_min_alarm:\n\t\terr = sfp_read(sfp, true, SFP_WARN1, &status, sizeof(status));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t*value = !!(status & SFP_WARN1_RXPWR_LOW);\n\t\treturn 0;\n\n\tcase hwmon_power_max_alarm:\n\t\terr = sfp_read(sfp, true, SFP_WARN1, &status, sizeof(status));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t*value = !!(status & SFP_WARN1_RXPWR_HIGH);\n\t\treturn 0;\n\n\tcase hwmon_power_crit_alarm:\n\t\terr = sfp_read(sfp, true, SFP_ALARM1, &status, sizeof(status));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t*value = !!(status & SFP_ALARM1_RXPWR_HIGH);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int sfp_hwmon_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t  u32 attr, int channel, long *value)\n{\n\tstruct sfp *sfp = dev_get_drvdata(dev);\n\n\tswitch (type) {\n\tcase hwmon_temp:\n\t\treturn sfp_hwmon_temp(sfp, attr, value);\n\tcase hwmon_in:\n\t\treturn sfp_hwmon_vcc(sfp, attr, value);\n\tcase hwmon_curr:\n\t\treturn sfp_hwmon_bias(sfp, attr, value);\n\tcase hwmon_power:\n\t\tswitch (channel) {\n\t\tcase 0:\n\t\t\treturn sfp_hwmon_tx_power(sfp, attr, value);\n\t\tcase 1:\n\t\t\treturn sfp_hwmon_rx_power(sfp, attr, value);\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic const char *const sfp_hwmon_power_labels[] = {\n\t\"TX_power\",\n\t\"RX_power\",\n};\n\nstatic int sfp_hwmon_read_string(struct device *dev,\n\t\t\t\t enum hwmon_sensor_types type,\n\t\t\t\t u32 attr, int channel, const char **str)\n{\n\tswitch (type) {\n\tcase hwmon_curr:\n\t\tswitch (attr) {\n\t\tcase hwmon_curr_label:\n\t\t\t*str = \"bias\";\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase hwmon_temp:\n\t\tswitch (attr) {\n\t\tcase hwmon_temp_label:\n\t\t\t*str = \"temperature\";\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase hwmon_in:\n\t\tswitch (attr) {\n\t\tcase hwmon_in_label:\n\t\t\t*str = \"VCC\";\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase hwmon_power:\n\t\tswitch (attr) {\n\t\tcase hwmon_power_label:\n\t\t\t*str = sfp_hwmon_power_labels[channel];\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct hwmon_ops sfp_hwmon_ops = {\n\t.is_visible = sfp_hwmon_is_visible,\n\t.read = sfp_hwmon_read,\n\t.read_string = sfp_hwmon_read_string,\n};\n\nstatic const struct hwmon_channel_info * const sfp_hwmon_info[] = {\n\tHWMON_CHANNEL_INFO(chip,\n\t\t\t   HWMON_C_REGISTER_TZ),\n\tHWMON_CHANNEL_INFO(in,\n\t\t\t   HWMON_I_INPUT |\n\t\t\t   HWMON_I_MAX | HWMON_I_MIN |\n\t\t\t   HWMON_I_MAX_ALARM | HWMON_I_MIN_ALARM |\n\t\t\t   HWMON_I_CRIT | HWMON_I_LCRIT |\n\t\t\t   HWMON_I_CRIT_ALARM | HWMON_I_LCRIT_ALARM |\n\t\t\t   HWMON_I_LABEL),\n\tHWMON_CHANNEL_INFO(temp,\n\t\t\t   HWMON_T_INPUT |\n\t\t\t   HWMON_T_MAX | HWMON_T_MIN |\n\t\t\t   HWMON_T_MAX_ALARM | HWMON_T_MIN_ALARM |\n\t\t\t   HWMON_T_CRIT | HWMON_T_LCRIT |\n\t\t\t   HWMON_T_CRIT_ALARM | HWMON_T_LCRIT_ALARM |\n\t\t\t   HWMON_T_LABEL),\n\tHWMON_CHANNEL_INFO(curr,\n\t\t\t   HWMON_C_INPUT |\n\t\t\t   HWMON_C_MAX | HWMON_C_MIN |\n\t\t\t   HWMON_C_MAX_ALARM | HWMON_C_MIN_ALARM |\n\t\t\t   HWMON_C_CRIT | HWMON_C_LCRIT |\n\t\t\t   HWMON_C_CRIT_ALARM | HWMON_C_LCRIT_ALARM |\n\t\t\t   HWMON_C_LABEL),\n\tHWMON_CHANNEL_INFO(power,\n\t\t\t    \n\t\t\t   HWMON_P_INPUT |\n\t\t\t   HWMON_P_MAX | HWMON_P_MIN |\n\t\t\t   HWMON_P_MAX_ALARM | HWMON_P_MIN_ALARM |\n\t\t\t   HWMON_P_CRIT | HWMON_P_LCRIT |\n\t\t\t   HWMON_P_CRIT_ALARM | HWMON_P_LCRIT_ALARM |\n\t\t\t   HWMON_P_LABEL,\n\t\t\t    \n\t\t\t   HWMON_P_INPUT |\n\t\t\t   HWMON_P_MAX | HWMON_P_MIN |\n\t\t\t   HWMON_P_MAX_ALARM | HWMON_P_MIN_ALARM |\n\t\t\t   HWMON_P_CRIT | HWMON_P_LCRIT |\n\t\t\t   HWMON_P_CRIT_ALARM | HWMON_P_LCRIT_ALARM |\n\t\t\t   HWMON_P_LABEL),\n\tNULL,\n};\n\nstatic const struct hwmon_chip_info sfp_hwmon_chip_info = {\n\t.ops = &sfp_hwmon_ops,\n\t.info = sfp_hwmon_info,\n};\n\nstatic void sfp_hwmon_probe(struct work_struct *work)\n{\n\tstruct sfp *sfp = container_of(work, struct sfp, hwmon_probe.work);\n\tint err;\n\n\t \n\tif (sfp->i2c_block_size < 2) {\n\t\tdev_info(sfp->dev,\n\t\t\t \"skipping hwmon device registration due to broken EEPROM\\n\");\n\t\tdev_info(sfp->dev,\n\t\t\t \"diagnostic EEPROM area cannot be read atomically to guarantee data coherency\\n\");\n\t\treturn;\n\t}\n\n\terr = sfp_read(sfp, true, 0, &sfp->diag, sizeof(sfp->diag));\n\tif (err < 0) {\n\t\tif (sfp->hwmon_tries--) {\n\t\t\tmod_delayed_work(system_wq, &sfp->hwmon_probe,\n\t\t\t\t\t T_PROBE_RETRY_SLOW);\n\t\t} else {\n\t\t\tdev_warn(sfp->dev, \"hwmon probe failed: %pe\\n\",\n\t\t\t\t ERR_PTR(err));\n\t\t}\n\t\treturn;\n\t}\n\n\tsfp->hwmon_name = hwmon_sanitize_name(dev_name(sfp->dev));\n\tif (IS_ERR(sfp->hwmon_name)) {\n\t\tdev_err(sfp->dev, \"out of memory for hwmon name\\n\");\n\t\treturn;\n\t}\n\n\tsfp->hwmon_dev = hwmon_device_register_with_info(sfp->dev,\n\t\t\t\t\t\t\t sfp->hwmon_name, sfp,\n\t\t\t\t\t\t\t &sfp_hwmon_chip_info,\n\t\t\t\t\t\t\t NULL);\n\tif (IS_ERR(sfp->hwmon_dev))\n\t\tdev_err(sfp->dev, \"failed to register hwmon device: %ld\\n\",\n\t\t\tPTR_ERR(sfp->hwmon_dev));\n}\n\nstatic int sfp_hwmon_insert(struct sfp *sfp)\n{\n\tif (sfp->have_a2 && sfp->id.ext.diagmon & SFP_DIAGMON_DDM) {\n\t\tmod_delayed_work(system_wq, &sfp->hwmon_probe, 1);\n\t\tsfp->hwmon_tries = R_PROBE_RETRY_SLOW;\n\t}\n\n\treturn 0;\n}\n\nstatic void sfp_hwmon_remove(struct sfp *sfp)\n{\n\tcancel_delayed_work_sync(&sfp->hwmon_probe);\n\tif (!IS_ERR_OR_NULL(sfp->hwmon_dev)) {\n\t\thwmon_device_unregister(sfp->hwmon_dev);\n\t\tsfp->hwmon_dev = NULL;\n\t\tkfree(sfp->hwmon_name);\n\t}\n}\n\nstatic int sfp_hwmon_init(struct sfp *sfp)\n{\n\tINIT_DELAYED_WORK(&sfp->hwmon_probe, sfp_hwmon_probe);\n\n\treturn 0;\n}\n\nstatic void sfp_hwmon_exit(struct sfp *sfp)\n{\n\tcancel_delayed_work_sync(&sfp->hwmon_probe);\n}\n#else\nstatic int sfp_hwmon_insert(struct sfp *sfp)\n{\n\treturn 0;\n}\n\nstatic void sfp_hwmon_remove(struct sfp *sfp)\n{\n}\n\nstatic int sfp_hwmon_init(struct sfp *sfp)\n{\n\treturn 0;\n}\n\nstatic void sfp_hwmon_exit(struct sfp *sfp)\n{\n}\n#endif\n\n \nstatic void sfp_module_tx_disable(struct sfp *sfp)\n{\n\tdev_dbg(sfp->dev, \"tx disable %u -> %u\\n\",\n\t\tsfp->state & SFP_F_TX_DISABLE ? 1 : 0, 1);\n\tsfp_mod_state(sfp, SFP_F_TX_DISABLE, SFP_F_TX_DISABLE);\n}\n\nstatic void sfp_module_tx_enable(struct sfp *sfp)\n{\n\tdev_dbg(sfp->dev, \"tx disable %u -> %u\\n\",\n\t\tsfp->state & SFP_F_TX_DISABLE ? 1 : 0, 0);\n\tsfp_mod_state(sfp, SFP_F_TX_DISABLE, 0);\n}\n\n#if IS_ENABLED(CONFIG_DEBUG_FS)\nstatic int sfp_debug_state_show(struct seq_file *s, void *data)\n{\n\tstruct sfp *sfp = s->private;\n\n\tseq_printf(s, \"Module state: %s\\n\",\n\t\t   mod_state_to_str(sfp->sm_mod_state));\n\tseq_printf(s, \"Module probe attempts: %d %d\\n\",\n\t\t   R_PROBE_RETRY_INIT - sfp->sm_mod_tries_init,\n\t\t   R_PROBE_RETRY_SLOW - sfp->sm_mod_tries);\n\tseq_printf(s, \"Device state: %s\\n\",\n\t\t   dev_state_to_str(sfp->sm_dev_state));\n\tseq_printf(s, \"Main state: %s\\n\",\n\t\t   sm_state_to_str(sfp->sm_state));\n\tseq_printf(s, \"Fault recovery remaining retries: %d\\n\",\n\t\t   sfp->sm_fault_retries);\n\tseq_printf(s, \"PHY probe remaining retries: %d\\n\",\n\t\t   sfp->sm_phy_retries);\n\tseq_printf(s, \"Signalling rate: %u kBd\\n\", sfp->rate_kbd);\n\tseq_printf(s, \"Rate select threshold: %u kBd\\n\",\n\t\t   sfp->rs_threshold_kbd);\n\tseq_printf(s, \"moddef0: %d\\n\", !!(sfp->state & SFP_F_PRESENT));\n\tseq_printf(s, \"rx_los: %d\\n\", !!(sfp->state & SFP_F_LOS));\n\tseq_printf(s, \"tx_fault: %d\\n\", !!(sfp->state & SFP_F_TX_FAULT));\n\tseq_printf(s, \"tx_disable: %d\\n\", !!(sfp->state & SFP_F_TX_DISABLE));\n\tseq_printf(s, \"rs0: %d\\n\", !!(sfp->state & SFP_F_RS0));\n\tseq_printf(s, \"rs1: %d\\n\", !!(sfp->state & SFP_F_RS1));\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(sfp_debug_state);\n\nstatic void sfp_debugfs_init(struct sfp *sfp)\n{\n\tsfp->debugfs_dir = debugfs_create_dir(dev_name(sfp->dev), NULL);\n\n\tdebugfs_create_file(\"state\", 0600, sfp->debugfs_dir, sfp,\n\t\t\t    &sfp_debug_state_fops);\n}\n\nstatic void sfp_debugfs_exit(struct sfp *sfp)\n{\n\tdebugfs_remove_recursive(sfp->debugfs_dir);\n}\n#else\nstatic void sfp_debugfs_init(struct sfp *sfp)\n{\n}\n\nstatic void sfp_debugfs_exit(struct sfp *sfp)\n{\n}\n#endif\n\nstatic void sfp_module_tx_fault_reset(struct sfp *sfp)\n{\n\tunsigned int state;\n\n\tmutex_lock(&sfp->st_mutex);\n\tstate = sfp->state;\n\tif (!(state & SFP_F_TX_DISABLE)) {\n\t\tsfp_set_state(sfp, state | SFP_F_TX_DISABLE);\n\n\t\tudelay(T_RESET_US);\n\n\t\tsfp_set_state(sfp, state);\n\t}\n\tmutex_unlock(&sfp->st_mutex);\n}\n\n \nstatic void sfp_sm_set_timer(struct sfp *sfp, unsigned int timeout)\n{\n\tif (timeout)\n\t\tmod_delayed_work(system_power_efficient_wq, &sfp->timeout,\n\t\t\t\t timeout);\n\telse\n\t\tcancel_delayed_work(&sfp->timeout);\n}\n\nstatic void sfp_sm_next(struct sfp *sfp, unsigned int state,\n\t\t\tunsigned int timeout)\n{\n\tsfp->sm_state = state;\n\tsfp_sm_set_timer(sfp, timeout);\n}\n\nstatic void sfp_sm_mod_next(struct sfp *sfp, unsigned int state,\n\t\t\t    unsigned int timeout)\n{\n\tsfp->sm_mod_state = state;\n\tsfp_sm_set_timer(sfp, timeout);\n}\n\nstatic void sfp_sm_phy_detach(struct sfp *sfp)\n{\n\tsfp_remove_phy(sfp->sfp_bus);\n\tphy_device_remove(sfp->mod_phy);\n\tphy_device_free(sfp->mod_phy);\n\tsfp->mod_phy = NULL;\n}\n\nstatic int sfp_sm_probe_phy(struct sfp *sfp, int addr, bool is_c45)\n{\n\tstruct phy_device *phy;\n\tint err;\n\n\tphy = get_phy_device(sfp->i2c_mii, addr, is_c45);\n\tif (phy == ERR_PTR(-ENODEV))\n\t\treturn PTR_ERR(phy);\n\tif (IS_ERR(phy)) {\n\t\tdev_err(sfp->dev, \"mdiobus scan returned %pe\\n\", phy);\n\t\treturn PTR_ERR(phy);\n\t}\n\n\t \n\tphy->is_on_sfp_module = true;\n\n\terr = phy_device_register(phy);\n\tif (err) {\n\t\tphy_device_free(phy);\n\t\tdev_err(sfp->dev, \"phy_device_register failed: %pe\\n\",\n\t\t\tERR_PTR(err));\n\t\treturn err;\n\t}\n\n\terr = sfp_add_phy(sfp->sfp_bus, phy);\n\tif (err) {\n\t\tphy_device_remove(phy);\n\t\tphy_device_free(phy);\n\t\tdev_err(sfp->dev, \"sfp_add_phy failed: %pe\\n\", ERR_PTR(err));\n\t\treturn err;\n\t}\n\n\tsfp->mod_phy = phy;\n\n\treturn 0;\n}\n\nstatic void sfp_sm_link_up(struct sfp *sfp)\n{\n\tsfp_link_up(sfp->sfp_bus);\n\tsfp_sm_next(sfp, SFP_S_LINK_UP, 0);\n}\n\nstatic void sfp_sm_link_down(struct sfp *sfp)\n{\n\tsfp_link_down(sfp->sfp_bus);\n}\n\nstatic void sfp_sm_link_check_los(struct sfp *sfp)\n{\n\tconst __be16 los_inverted = cpu_to_be16(SFP_OPTIONS_LOS_INVERTED);\n\tconst __be16 los_normal = cpu_to_be16(SFP_OPTIONS_LOS_NORMAL);\n\t__be16 los_options = sfp->id.ext.options & (los_inverted | los_normal);\n\tbool los = false;\n\n\t \n\tif (los_options == los_inverted)\n\t\tlos = !(sfp->state & SFP_F_LOS);\n\telse if (los_options == los_normal)\n\t\tlos = !!(sfp->state & SFP_F_LOS);\n\n\tif (los)\n\t\tsfp_sm_next(sfp, SFP_S_WAIT_LOS, 0);\n\telse\n\t\tsfp_sm_link_up(sfp);\n}\n\nstatic bool sfp_los_event_active(struct sfp *sfp, unsigned int event)\n{\n\tconst __be16 los_inverted = cpu_to_be16(SFP_OPTIONS_LOS_INVERTED);\n\tconst __be16 los_normal = cpu_to_be16(SFP_OPTIONS_LOS_NORMAL);\n\t__be16 los_options = sfp->id.ext.options & (los_inverted | los_normal);\n\n\treturn (los_options == los_inverted && event == SFP_E_LOS_LOW) ||\n\t       (los_options == los_normal && event == SFP_E_LOS_HIGH);\n}\n\nstatic bool sfp_los_event_inactive(struct sfp *sfp, unsigned int event)\n{\n\tconst __be16 los_inverted = cpu_to_be16(SFP_OPTIONS_LOS_INVERTED);\n\tconst __be16 los_normal = cpu_to_be16(SFP_OPTIONS_LOS_NORMAL);\n\t__be16 los_options = sfp->id.ext.options & (los_inverted | los_normal);\n\n\treturn (los_options == los_inverted && event == SFP_E_LOS_HIGH) ||\n\t       (los_options == los_normal && event == SFP_E_LOS_LOW);\n}\n\nstatic void sfp_sm_fault(struct sfp *sfp, unsigned int next_state, bool warn)\n{\n\tif (sfp->sm_fault_retries && !--sfp->sm_fault_retries) {\n\t\tdev_err(sfp->dev,\n\t\t\t\"module persistently indicates fault, disabling\\n\");\n\t\tsfp_sm_next(sfp, SFP_S_TX_DISABLE, 0);\n\t} else {\n\t\tif (warn)\n\t\t\tdev_err(sfp->dev, \"module transmit fault indicated\\n\");\n\n\t\tsfp_sm_next(sfp, next_state, T_FAULT_RECOVER);\n\t}\n}\n\nstatic int sfp_sm_add_mdio_bus(struct sfp *sfp)\n{\n\tif (sfp->mdio_protocol != MDIO_I2C_NONE)\n\t\treturn sfp_i2c_mdiobus_create(sfp);\n\n\treturn 0;\n}\n\n \nstatic int sfp_sm_probe_for_phy(struct sfp *sfp)\n{\n\tint err = 0;\n\n\tswitch (sfp->mdio_protocol) {\n\tcase MDIO_I2C_NONE:\n\t\tbreak;\n\n\tcase MDIO_I2C_MARVELL_C22:\n\t\terr = sfp_sm_probe_phy(sfp, SFP_PHY_ADDR, false);\n\t\tbreak;\n\n\tcase MDIO_I2C_C45:\n\t\terr = sfp_sm_probe_phy(sfp, SFP_PHY_ADDR, true);\n\t\tbreak;\n\n\tcase MDIO_I2C_ROLLBALL:\n\t\terr = sfp_sm_probe_phy(sfp, SFP_PHY_ADDR_ROLLBALL, true);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\nstatic int sfp_module_parse_power(struct sfp *sfp)\n{\n\tu32 power_mW = 1000;\n\tbool supports_a2;\n\n\tif (sfp->id.ext.sff8472_compliance >= SFP_SFF8472_COMPLIANCE_REV10_2 &&\n\t    sfp->id.ext.options & cpu_to_be16(SFP_OPTIONS_POWER_DECL))\n\t\tpower_mW = 1500;\n\t \n\tif (sfp->id.ext.sff8472_compliance >= SFP_SFF8472_COMPLIANCE_REV11_4 &&\n\t    sfp->id.ext.options & cpu_to_be16(SFP_OPTIONS_HIGH_POWER_LEVEL))\n\t\tpower_mW = 2000;\n\n\t \n\tif (power_mW <= 1000) {\n\t\tsfp->module_power_mW = power_mW;\n\t\treturn 0;\n\t}\n\n\tsupports_a2 = sfp->id.ext.sff8472_compliance !=\n\t\t\t\tSFP_SFF8472_COMPLIANCE_NONE ||\n\t\t      sfp->id.ext.diagmon & SFP_DIAGMON_DDM;\n\n\tif (power_mW > sfp->max_power_mW) {\n\t\t \n\t\tif (!supports_a2) {\n\t\t\t \n\t\t\tdev_err(sfp->dev,\n\t\t\t\t\"Host does not support %u.%uW modules\\n\",\n\t\t\t\tpower_mW / 1000, (power_mW / 100) % 10);\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tdev_warn(sfp->dev,\n\t\t\t\t \"Host does not support %u.%uW modules, module left in power mode 1\\n\",\n\t\t\t\t power_mW / 1000, (power_mW / 100) % 10);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!supports_a2) {\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tif (sfp->id.ext.diagmon & SFP_DIAGMON_ADDRMODE) {\n\t\tdev_warn(sfp->dev,\n\t\t\t \"Address Change Sequence not supported but module requires %u.%uW, module may not be functional\\n\",\n\t\t\t power_mW / 1000, (power_mW / 100) % 10);\n\t\treturn 0;\n\t}\n\n\tsfp->module_power_mW = power_mW;\n\n\treturn 0;\n}\n\nstatic int sfp_sm_mod_hpower(struct sfp *sfp, bool enable)\n{\n\tint err;\n\n\terr = sfp_modify_u8(sfp, true, SFP_EXT_STATUS,\n\t\t\t    SFP_EXT_STATUS_PWRLVL_SELECT,\n\t\t\t    enable ? SFP_EXT_STATUS_PWRLVL_SELECT : 0);\n\tif (err != sizeof(u8)) {\n\t\tdev_err(sfp->dev, \"failed to %sable high power: %pe\\n\",\n\t\t\tenable ? \"en\" : \"dis\", ERR_PTR(err));\n\t\treturn -EAGAIN;\n\t}\n\n\tif (enable)\n\t\tdev_info(sfp->dev, \"Module switched to %u.%uW power level\\n\",\n\t\t\t sfp->module_power_mW / 1000,\n\t\t\t (sfp->module_power_mW / 100) % 10);\n\n\treturn 0;\n}\n\nstatic void sfp_module_parse_rate_select(struct sfp *sfp)\n{\n\tu8 rate_id;\n\n\tsfp->rs_threshold_kbd = 0;\n\tsfp->rs_state_mask = 0;\n\n\tif (!(sfp->id.ext.options & cpu_to_be16(SFP_OPTIONS_RATE_SELECT)))\n\t\t \n\t\treturn;\n\n\t \n\tsfp->rs_state_mask = SFP_F_RS0;\n\tsfp->rs_threshold_kbd = 1594;\n\n\t \n\trate_id = sfp->id.base.rate_id;\n\tif (rate_id == 0)\n\t\t \n\t\treturn;\n\n\t \n\tif (sfp->id.ext.sff8472_compliance >= SFP_SFF8472_COMPLIANCE_REV10_2 &&\n\t    sfp->id.ext.sff8472_compliance < SFP_SFF8472_COMPLIANCE_REV11_0 &&\n\t    rate_id == 3)\n\t\trate_id = SFF_RID_8431;\n\n\tif (rate_id & SFF_RID_8079) {\n\t\t \n\t\tif (!(sfp->id.ext.enhopts & SFP_ENHOPTS_APP_SELECT_SFF8079)) {\n\t\t\t \n\t\t\tsfp->rs_threshold_kbd = 2125 - 1;\n\t\t\tsfp->rs_state_mask = SFP_F_RS0;\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tif (sfp->id.ext.sff8472_compliance <= SFP_SFF8472_COMPLIANCE_REV9_5)\n\t\treturn;\n\n\t \n\tswitch (rate_id) {\n\tcase SFF_RID_8431_RX_ONLY:\n\t\tsfp->rs_threshold_kbd = 4250;\n\t\tsfp->rs_state_mask = SFP_F_RS0;\n\t\tbreak;\n\n\tcase SFF_RID_8431_TX_ONLY:\n\t\tsfp->rs_threshold_kbd = 4250;\n\t\tsfp->rs_state_mask = SFP_F_RS1;\n\t\tbreak;\n\n\tcase SFF_RID_8431:\n\t\tsfp->rs_threshold_kbd = 4250;\n\t\tsfp->rs_state_mask = SFP_F_RS0 | SFP_F_RS1;\n\t\tbreak;\n\n\tcase SFF_RID_10G8G:\n\t\tsfp->rs_threshold_kbd = 9000;\n\t\tsfp->rs_state_mask = SFP_F_RS0 | SFP_F_RS1;\n\t\tbreak;\n\t}\n}\n\n \nstatic bool sfp_id_needs_byte_io(struct sfp *sfp, void *buf, size_t len)\n{\n\tsize_t i, block_size = sfp->i2c_block_size;\n\n\t \n\tif (block_size == 1)\n\t\treturn false;\n\n\tfor (i = 1; i < len; i += block_size) {\n\t\tif (memchr_inv(buf + i, '\\0', min(block_size - 1, len - i)))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int sfp_cotsworks_fixup_check(struct sfp *sfp, struct sfp_eeprom_id *id)\n{\n\tu8 check;\n\tint err;\n\n\tif (id->base.phys_id != SFF8024_ID_SFF_8472 ||\n\t    id->base.phys_ext_id != SFP_PHYS_EXT_ID_SFP ||\n\t    id->base.connector != SFF8024_CONNECTOR_LC) {\n\t\tdev_warn(sfp->dev, \"Rewriting fiber module EEPROM with corrected values\\n\");\n\t\tid->base.phys_id = SFF8024_ID_SFF_8472;\n\t\tid->base.phys_ext_id = SFP_PHYS_EXT_ID_SFP;\n\t\tid->base.connector = SFF8024_CONNECTOR_LC;\n\t\terr = sfp_write(sfp, false, SFP_PHYS_ID, &id->base, 3);\n\t\tif (err != 3) {\n\t\t\tdev_err(sfp->dev,\n\t\t\t\t\"Failed to rewrite module EEPROM: %pe\\n\",\n\t\t\t\tERR_PTR(err));\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tmdelay(50);\n\n\t\t \n\t\tcheck = sfp_check(&id->base, sizeof(id->base) - 1);\n\t\terr = sfp_write(sfp, false, SFP_CC_BASE, &check, 1);\n\t\tif (err != 1) {\n\t\t\tdev_err(sfp->dev,\n\t\t\t\t\"Failed to update base structure checksum in fiber module EEPROM: %pe\\n\",\n\t\t\t\tERR_PTR(err));\n\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int sfp_module_parse_sff8472(struct sfp *sfp)\n{\n\t \n\tif (sfp->id.ext.diagmon & SFP_DIAGMON_ADDRMODE)\n\t\tdev_warn(sfp->dev,\n\t\t\t \"module address swap to access page 0xA2 is not supported.\\n\");\n\telse\n\t\tsfp->have_a2 = true;\n\n\treturn 0;\n}\n\nstatic int sfp_sm_mod_probe(struct sfp *sfp, bool report)\n{\n\t \n\tstruct sfp_eeprom_id id;\n\tbool cotsworks_sfbg;\n\tunsigned int mask;\n\tbool cotsworks;\n\tu8 check;\n\tint ret;\n\n\tsfp->i2c_block_size = SFP_EEPROM_BLOCK_SIZE;\n\n\tret = sfp_read(sfp, false, 0, &id.base, sizeof(id.base));\n\tif (ret < 0) {\n\t\tif (report)\n\t\t\tdev_err(sfp->dev, \"failed to read EEPROM: %pe\\n\",\n\t\t\t\tERR_PTR(ret));\n\t\treturn -EAGAIN;\n\t}\n\n\tif (ret != sizeof(id.base)) {\n\t\tdev_err(sfp->dev, \"EEPROM short read: %pe\\n\", ERR_PTR(ret));\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tif (sfp_id_needs_byte_io(sfp, &id.base, sizeof(id.base))) {\n\t\tdev_info(sfp->dev,\n\t\t\t \"Detected broken RTL8672/RTL9601C emulated EEPROM\\n\");\n\t\tdev_info(sfp->dev,\n\t\t\t \"Switching to reading EEPROM to one byte at a time\\n\");\n\t\tsfp->i2c_block_size = 1;\n\n\t\tret = sfp_read(sfp, false, 0, &id.base, sizeof(id.base));\n\t\tif (ret < 0) {\n\t\t\tif (report)\n\t\t\t\tdev_err(sfp->dev,\n\t\t\t\t\t\"failed to read EEPROM: %pe\\n\",\n\t\t\t\t\tERR_PTR(ret));\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tif (ret != sizeof(id.base)) {\n\t\t\tdev_err(sfp->dev, \"EEPROM short read: %pe\\n\",\n\t\t\t\tERR_PTR(ret));\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\t \n\tcotsworks = !memcmp(id.base.vendor_name, \"COTSWORKS       \", 16);\n\tcotsworks_sfbg = !memcmp(id.base.vendor_pn, \"SFBG\", 4);\n\n\t \n\tif (cotsworks && cotsworks_sfbg) {\n\t\tret = sfp_cotsworks_fixup_check(sfp, &id);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tcheck = sfp_check(&id.base, sizeof(id.base) - 1);\n\tif (check != id.base.cc_base) {\n\t\tif (cotsworks) {\n\t\t\tdev_warn(sfp->dev,\n\t\t\t\t \"EEPROM base structure checksum failure (0x%02x != 0x%02x)\\n\",\n\t\t\t\t check, id.base.cc_base);\n\t\t} else {\n\t\t\tdev_err(sfp->dev,\n\t\t\t\t\"EEPROM base structure checksum failure: 0x%02x != 0x%02x\\n\",\n\t\t\t\tcheck, id.base.cc_base);\n\t\t\tprint_hex_dump(KERN_ERR, \"sfp EE: \", DUMP_PREFIX_OFFSET,\n\t\t\t\t       16, 1, &id, sizeof(id), true);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tret = sfp_read(sfp, false, SFP_CC_BASE + 1, &id.ext, sizeof(id.ext));\n\tif (ret < 0) {\n\t\tif (report)\n\t\t\tdev_err(sfp->dev, \"failed to read EEPROM: %pe\\n\",\n\t\t\t\tERR_PTR(ret));\n\t\treturn -EAGAIN;\n\t}\n\n\tif (ret != sizeof(id.ext)) {\n\t\tdev_err(sfp->dev, \"EEPROM short read: %pe\\n\", ERR_PTR(ret));\n\t\treturn -EAGAIN;\n\t}\n\n\tcheck = sfp_check(&id.ext, sizeof(id.ext) - 1);\n\tif (check != id.ext.cc_ext) {\n\t\tif (cotsworks) {\n\t\t\tdev_warn(sfp->dev,\n\t\t\t\t \"EEPROM extended structure checksum failure (0x%02x != 0x%02x)\\n\",\n\t\t\t\t check, id.ext.cc_ext);\n\t\t} else {\n\t\t\tdev_err(sfp->dev,\n\t\t\t\t\"EEPROM extended structure checksum failure: 0x%02x != 0x%02x\\n\",\n\t\t\t\tcheck, id.ext.cc_ext);\n\t\t\tprint_hex_dump(KERN_ERR, \"sfp EE: \", DUMP_PREFIX_OFFSET,\n\t\t\t\t       16, 1, &id, sizeof(id), true);\n\t\t\tmemset(&id.ext, 0, sizeof(id.ext));\n\t\t}\n\t}\n\n\tsfp->id = id;\n\n\tdev_info(sfp->dev, \"module %.*s %.*s rev %.*s sn %.*s dc %.*s\\n\",\n\t\t (int)sizeof(id.base.vendor_name), id.base.vendor_name,\n\t\t (int)sizeof(id.base.vendor_pn), id.base.vendor_pn,\n\t\t (int)sizeof(id.base.vendor_rev), id.base.vendor_rev,\n\t\t (int)sizeof(id.ext.vendor_sn), id.ext.vendor_sn,\n\t\t (int)sizeof(id.ext.datecode), id.ext.datecode);\n\n\t \n\tif (!sfp->type->module_supported(&id)) {\n\t\tdev_err(sfp->dev,\n\t\t\t\"module is not supported - phys id 0x%02x 0x%02x\\n\",\n\t\t\tsfp->id.base.phys_id, sfp->id.base.phys_ext_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sfp->id.ext.sff8472_compliance != SFP_SFF8472_COMPLIANCE_NONE) {\n\t\tret = sfp_module_parse_sff8472(sfp);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = sfp_module_parse_power(sfp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsfp_module_parse_rate_select(sfp);\n\n\tmask = SFP_F_PRESENT;\n\tif (sfp->gpio[GPIO_TX_DISABLE])\n\t\tmask |= SFP_F_TX_DISABLE;\n\tif (sfp->gpio[GPIO_TX_FAULT])\n\t\tmask |= SFP_F_TX_FAULT;\n\tif (sfp->gpio[GPIO_LOS])\n\t\tmask |= SFP_F_LOS;\n\tif (sfp->gpio[GPIO_RS0])\n\t\tmask |= SFP_F_RS0;\n\tif (sfp->gpio[GPIO_RS1])\n\t\tmask |= SFP_F_RS1;\n\n\tsfp->module_t_start_up = T_START_UP;\n\tsfp->module_t_wait = T_WAIT;\n\n\tsfp->tx_fault_ignore = false;\n\n\tif (sfp->id.base.extended_cc == SFF8024_ECC_10GBASE_T_SFI ||\n\t    sfp->id.base.extended_cc == SFF8024_ECC_10GBASE_T_SR ||\n\t    sfp->id.base.extended_cc == SFF8024_ECC_5GBASE_T ||\n\t    sfp->id.base.extended_cc == SFF8024_ECC_2_5GBASE_T)\n\t\tsfp->mdio_protocol = MDIO_I2C_C45;\n\telse if (sfp->id.base.e1000_base_t)\n\t\tsfp->mdio_protocol = MDIO_I2C_MARVELL_C22;\n\telse\n\t\tsfp->mdio_protocol = MDIO_I2C_NONE;\n\n\tsfp->quirk = sfp_lookup_quirk(&id);\n\n\tmutex_lock(&sfp->st_mutex);\n\t \n\tsfp->state_hw_mask = mask;\n\n\t \n\tsfp->state_hw_drive |= sfp->rs_state_mask;\n\n\tif (sfp->quirk && sfp->quirk->fixup)\n\t\tsfp->quirk->fixup(sfp);\n\tmutex_unlock(&sfp->st_mutex);\n\n\treturn 0;\n}\n\nstatic void sfp_sm_mod_remove(struct sfp *sfp)\n{\n\tif (sfp->sm_mod_state > SFP_MOD_WAITDEV)\n\t\tsfp_module_remove(sfp->sfp_bus);\n\n\tsfp_hwmon_remove(sfp);\n\n\tmemset(&sfp->id, 0, sizeof(sfp->id));\n\tsfp->module_power_mW = 0;\n\tsfp->state_hw_drive = SFP_F_TX_DISABLE;\n\tsfp->have_a2 = false;\n\n\tdev_info(sfp->dev, \"module removed\\n\");\n}\n\n \nstatic void sfp_sm_device(struct sfp *sfp, unsigned int event)\n{\n\tswitch (sfp->sm_dev_state) {\n\tdefault:\n\t\tif (event == SFP_E_DEV_ATTACH)\n\t\t\tsfp->sm_dev_state = SFP_DEV_DOWN;\n\t\tbreak;\n\n\tcase SFP_DEV_DOWN:\n\t\tif (event == SFP_E_DEV_DETACH)\n\t\t\tsfp->sm_dev_state = SFP_DEV_DETACHED;\n\t\telse if (event == SFP_E_DEV_UP)\n\t\t\tsfp->sm_dev_state = SFP_DEV_UP;\n\t\tbreak;\n\n\tcase SFP_DEV_UP:\n\t\tif (event == SFP_E_DEV_DETACH)\n\t\t\tsfp->sm_dev_state = SFP_DEV_DETACHED;\n\t\telse if (event == SFP_E_DEV_DOWN)\n\t\t\tsfp->sm_dev_state = SFP_DEV_DOWN;\n\t\tbreak;\n\t}\n}\n\n \nstatic void sfp_sm_module(struct sfp *sfp, unsigned int event)\n{\n\tint err;\n\n\t \n\tif (event == SFP_E_REMOVE) {\n\t\tif (sfp->sm_mod_state > SFP_MOD_PROBE)\n\t\t\tsfp_sm_mod_remove(sfp);\n\t\tsfp_sm_mod_next(sfp, SFP_MOD_EMPTY, 0);\n\t\treturn;\n\t}\n\n\t \n\tif (sfp->sm_dev_state < SFP_DEV_DOWN &&\n\t    sfp->sm_mod_state > SFP_MOD_WAITDEV) {\n\t\tif (sfp->module_power_mW > 1000 &&\n\t\t    sfp->sm_mod_state > SFP_MOD_HPOWER)\n\t\t\tsfp_sm_mod_hpower(sfp, false);\n\t\tsfp_sm_mod_next(sfp, SFP_MOD_WAITDEV, 0);\n\t\treturn;\n\t}\n\n\tswitch (sfp->sm_mod_state) {\n\tdefault:\n\t\tif (event == SFP_E_INSERT) {\n\t\t\tsfp_sm_mod_next(sfp, SFP_MOD_PROBE, T_SERIAL);\n\t\t\tsfp->sm_mod_tries_init = R_PROBE_RETRY_INIT;\n\t\t\tsfp->sm_mod_tries = R_PROBE_RETRY_SLOW;\n\t\t}\n\t\tbreak;\n\n\tcase SFP_MOD_PROBE:\n\t\t \n\t\tif (event != SFP_E_TIMEOUT)\n\t\t\tbreak;\n\n\t\terr = sfp_sm_mod_probe(sfp, sfp->sm_mod_tries == 1);\n\t\tif (err == -EAGAIN) {\n\t\t\tif (sfp->sm_mod_tries_init &&\n\t\t\t   --sfp->sm_mod_tries_init) {\n\t\t\t\tsfp_sm_set_timer(sfp, T_PROBE_RETRY_INIT);\n\t\t\t\tbreak;\n\t\t\t} else if (sfp->sm_mod_tries && --sfp->sm_mod_tries) {\n\t\t\t\tif (sfp->sm_mod_tries == R_PROBE_RETRY_SLOW - 1)\n\t\t\t\t\tdev_warn(sfp->dev,\n\t\t\t\t\t\t \"please wait, module slow to respond\\n\");\n\t\t\t\tsfp_sm_set_timer(sfp, T_PROBE_RETRY_SLOW);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (err < 0) {\n\t\t\tsfp_sm_mod_next(sfp, SFP_MOD_ERROR, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tmod_delayed_work(system_wq, &sfp->poll, 1);\n\n\t\terr = sfp_hwmon_insert(sfp);\n\t\tif (err)\n\t\t\tdev_warn(sfp->dev, \"hwmon probe failed: %pe\\n\",\n\t\t\t\t ERR_PTR(err));\n\n\t\tsfp_sm_mod_next(sfp, SFP_MOD_WAITDEV, 0);\n\t\tfallthrough;\n\tcase SFP_MOD_WAITDEV:\n\t\t \n\t\tif (sfp->sm_dev_state < SFP_DEV_DOWN)\n\t\t\tbreak;\n\n\t\t \n\t\terr = sfp_module_insert(sfp->sfp_bus, &sfp->id,\n\t\t\t\t\tsfp->quirk);\n\t\tif (err < 0) {\n\t\t\tsfp_sm_mod_next(sfp, SFP_MOD_ERROR, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (sfp->module_power_mW <= 1000)\n\t\t\tgoto insert;\n\n\t\tsfp_sm_mod_next(sfp, SFP_MOD_HPOWER, 0);\n\t\tfallthrough;\n\tcase SFP_MOD_HPOWER:\n\t\t \n\t\terr = sfp_sm_mod_hpower(sfp, true);\n\t\tif (err < 0) {\n\t\t\tif (err != -EAGAIN) {\n\t\t\t\tsfp_module_remove(sfp->sfp_bus);\n\t\t\t\tsfp_sm_mod_next(sfp, SFP_MOD_ERROR, 0);\n\t\t\t} else {\n\t\t\t\tsfp_sm_set_timer(sfp, T_PROBE_RETRY_INIT);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tsfp_sm_mod_next(sfp, SFP_MOD_WAITPWR, T_HPOWER_LEVEL);\n\t\tbreak;\n\n\tcase SFP_MOD_WAITPWR:\n\t\t \n\t\tif (event != SFP_E_TIMEOUT)\n\t\t\tbreak;\n\n\tinsert:\n\t\tsfp_sm_mod_next(sfp, SFP_MOD_PRESENT, 0);\n\t\tbreak;\n\n\tcase SFP_MOD_PRESENT:\n\tcase SFP_MOD_ERROR:\n\t\tbreak;\n\t}\n}\n\nstatic void sfp_sm_main(struct sfp *sfp, unsigned int event)\n{\n\tunsigned long timeout;\n\tint ret;\n\n\t \n\tif (sfp->sm_state != SFP_S_DOWN &&\n\t    (sfp->sm_mod_state != SFP_MOD_PRESENT ||\n\t     sfp->sm_dev_state != SFP_DEV_UP)) {\n\t\tif (sfp->sm_state == SFP_S_LINK_UP &&\n\t\t    sfp->sm_dev_state == SFP_DEV_UP)\n\t\t\tsfp_sm_link_down(sfp);\n\t\tif (sfp->sm_state > SFP_S_INIT)\n\t\t\tsfp_module_stop(sfp->sfp_bus);\n\t\tif (sfp->mod_phy)\n\t\t\tsfp_sm_phy_detach(sfp);\n\t\tif (sfp->i2c_mii)\n\t\t\tsfp_i2c_mdiobus_destroy(sfp);\n\t\tsfp_module_tx_disable(sfp);\n\t\tsfp_soft_stop_poll(sfp);\n\t\tsfp_sm_next(sfp, SFP_S_DOWN, 0);\n\t\treturn;\n\t}\n\n\t \n\tswitch (sfp->sm_state) {\n\tcase SFP_S_DOWN:\n\t\tif (sfp->sm_mod_state != SFP_MOD_PRESENT ||\n\t\t    sfp->sm_dev_state != SFP_DEV_UP)\n\t\t\tbreak;\n\n\t\t \n\t\tif (sfp->have_a2)\n\t\t\tsfp_soft_start_poll(sfp);\n\n\t\tsfp_module_tx_enable(sfp);\n\n\t\t \n\t\tsfp->sm_fault_retries = N_FAULT_INIT;\n\n\t\t \n\t\tsfp_sm_next(sfp, SFP_S_WAIT, sfp->module_t_wait);\n\t\tbreak;\n\n\tcase SFP_S_WAIT:\n\t\tif (event != SFP_E_TIMEOUT)\n\t\t\tbreak;\n\n\t\tif (sfp->state & SFP_F_TX_FAULT) {\n\t\t\t \n\t\t\ttimeout = sfp->module_t_start_up;\n\t\t\tif (timeout > sfp->module_t_wait)\n\t\t\t\ttimeout -= sfp->module_t_wait;\n\t\t\telse\n\t\t\t\ttimeout = 1;\n\n\t\t\tsfp_sm_next(sfp, SFP_S_INIT, timeout);\n\t\t} else {\n\t\t\t \n\t\t\tgoto init_done;\n\t\t}\n\t\tbreak;\n\n\tcase SFP_S_INIT:\n\t\tif (event == SFP_E_TIMEOUT && sfp->state & SFP_F_TX_FAULT) {\n\t\t\t \n\t\t\tsfp_sm_fault(sfp, SFP_S_INIT_TX_FAULT,\n\t\t\t\t     sfp->sm_fault_retries == N_FAULT_INIT);\n\t\t} else if (event == SFP_E_TIMEOUT || event == SFP_E_TX_CLEAR) {\n\tinit_done:\n\t\t\t \n\t\t\tret = sfp_sm_add_mdio_bus(sfp);\n\t\t\tif (ret < 0) {\n\t\t\t\tsfp_sm_next(sfp, SFP_S_FAIL, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsfp->sm_phy_retries = R_PHY_RETRY;\n\t\t\tgoto phy_probe;\n\t\t}\n\t\tbreak;\n\n\tcase SFP_S_INIT_PHY:\n\t\tif (event != SFP_E_TIMEOUT)\n\t\t\tbreak;\n\tphy_probe:\n\t\t \n\t\tret = sfp_sm_probe_for_phy(sfp);\n\t\tif (ret == -ENODEV) {\n\t\t\tif (--sfp->sm_phy_retries) {\n\t\t\t\tsfp_sm_next(sfp, SFP_S_INIT_PHY, T_PHY_RETRY);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tdev_info(sfp->dev, \"no PHY detected\\n\");\n\t\t\t}\n\t\t} else if (ret) {\n\t\t\tsfp_sm_next(sfp, SFP_S_FAIL, 0);\n\t\t\tbreak;\n\t\t}\n\t\tif (sfp_module_start(sfp->sfp_bus)) {\n\t\t\tsfp_sm_next(sfp, SFP_S_FAIL, 0);\n\t\t\tbreak;\n\t\t}\n\t\tsfp_sm_link_check_los(sfp);\n\n\t\t \n\t\tsfp->sm_fault_retries = N_FAULT;\n\t\tbreak;\n\n\tcase SFP_S_INIT_TX_FAULT:\n\t\tif (event == SFP_E_TIMEOUT) {\n\t\t\tsfp_module_tx_fault_reset(sfp);\n\t\t\tsfp_sm_next(sfp, SFP_S_INIT, sfp->module_t_start_up);\n\t\t}\n\t\tbreak;\n\n\tcase SFP_S_WAIT_LOS:\n\t\tif (event == SFP_E_TX_FAULT)\n\t\t\tsfp_sm_fault(sfp, SFP_S_TX_FAULT, true);\n\t\telse if (sfp_los_event_inactive(sfp, event))\n\t\t\tsfp_sm_link_up(sfp);\n\t\tbreak;\n\n\tcase SFP_S_LINK_UP:\n\t\tif (event == SFP_E_TX_FAULT) {\n\t\t\tsfp_sm_link_down(sfp);\n\t\t\tsfp_sm_fault(sfp, SFP_S_TX_FAULT, true);\n\t\t} else if (sfp_los_event_active(sfp, event)) {\n\t\t\tsfp_sm_link_down(sfp);\n\t\t\tsfp_sm_next(sfp, SFP_S_WAIT_LOS, 0);\n\t\t}\n\t\tbreak;\n\n\tcase SFP_S_TX_FAULT:\n\t\tif (event == SFP_E_TIMEOUT) {\n\t\t\tsfp_module_tx_fault_reset(sfp);\n\t\t\tsfp_sm_next(sfp, SFP_S_REINIT, sfp->module_t_start_up);\n\t\t}\n\t\tbreak;\n\n\tcase SFP_S_REINIT:\n\t\tif (event == SFP_E_TIMEOUT && sfp->state & SFP_F_TX_FAULT) {\n\t\t\tsfp_sm_fault(sfp, SFP_S_TX_FAULT, false);\n\t\t} else if (event == SFP_E_TIMEOUT || event == SFP_E_TX_CLEAR) {\n\t\t\tdev_info(sfp->dev, \"module transmit fault recovered\\n\");\n\t\t\tsfp_sm_link_check_los(sfp);\n\t\t}\n\t\tbreak;\n\n\tcase SFP_S_TX_DISABLE:\n\t\tbreak;\n\t}\n}\n\nstatic void __sfp_sm_event(struct sfp *sfp, unsigned int event)\n{\n\tdev_dbg(sfp->dev, \"SM: enter %s:%s:%s event %s\\n\",\n\t\tmod_state_to_str(sfp->sm_mod_state),\n\t\tdev_state_to_str(sfp->sm_dev_state),\n\t\tsm_state_to_str(sfp->sm_state),\n\t\tevent_to_str(event));\n\n\tsfp_sm_device(sfp, event);\n\tsfp_sm_module(sfp, event);\n\tsfp_sm_main(sfp, event);\n\n\tdev_dbg(sfp->dev, \"SM: exit %s:%s:%s\\n\",\n\t\tmod_state_to_str(sfp->sm_mod_state),\n\t\tdev_state_to_str(sfp->sm_dev_state),\n\t\tsm_state_to_str(sfp->sm_state));\n}\n\nstatic void sfp_sm_event(struct sfp *sfp, unsigned int event)\n{\n\tmutex_lock(&sfp->sm_mutex);\n\t__sfp_sm_event(sfp, event);\n\tmutex_unlock(&sfp->sm_mutex);\n}\n\nstatic void sfp_attach(struct sfp *sfp)\n{\n\tsfp_sm_event(sfp, SFP_E_DEV_ATTACH);\n}\n\nstatic void sfp_detach(struct sfp *sfp)\n{\n\tsfp_sm_event(sfp, SFP_E_DEV_DETACH);\n}\n\nstatic void sfp_start(struct sfp *sfp)\n{\n\tsfp_sm_event(sfp, SFP_E_DEV_UP);\n}\n\nstatic void sfp_stop(struct sfp *sfp)\n{\n\tsfp_sm_event(sfp, SFP_E_DEV_DOWN);\n}\n\nstatic void sfp_set_signal_rate(struct sfp *sfp, unsigned int rate_kbd)\n{\n\tunsigned int set;\n\n\tsfp->rate_kbd = rate_kbd;\n\n\tif (rate_kbd > sfp->rs_threshold_kbd)\n\t\tset = sfp->rs_state_mask;\n\telse\n\t\tset = 0;\n\n\tsfp_mod_state(sfp, SFP_F_RS0 | SFP_F_RS1, set);\n}\n\nstatic int sfp_module_info(struct sfp *sfp, struct ethtool_modinfo *modinfo)\n{\n\t \n\n\tif (sfp->id.ext.sff8472_compliance &&\n\t    !(sfp->id.ext.diagmon & SFP_DIAGMON_ADDRMODE)) {\n\t\tmodinfo->type = ETH_MODULE_SFF_8472;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN;\n\t} else {\n\t\tmodinfo->type = ETH_MODULE_SFF_8079;\n\t\tmodinfo->eeprom_len = ETH_MODULE_SFF_8079_LEN;\n\t}\n\treturn 0;\n}\n\nstatic int sfp_module_eeprom(struct sfp *sfp, struct ethtool_eeprom *ee,\n\t\t\t     u8 *data)\n{\n\tunsigned int first, last, len;\n\tint ret;\n\n\tif (!(sfp->state & SFP_F_PRESENT))\n\t\treturn -ENODEV;\n\n\tif (ee->len == 0)\n\t\treturn -EINVAL;\n\n\tfirst = ee->offset;\n\tlast = ee->offset + ee->len;\n\tif (first < ETH_MODULE_SFF_8079_LEN) {\n\t\tlen = min_t(unsigned int, last, ETH_MODULE_SFF_8079_LEN);\n\t\tlen -= first;\n\n\t\tret = sfp_read(sfp, false, first, data, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tfirst += len;\n\t\tdata += len;\n\t}\n\tif (first < ETH_MODULE_SFF_8472_LEN && last > ETH_MODULE_SFF_8079_LEN) {\n\t\tlen = min_t(unsigned int, last, ETH_MODULE_SFF_8472_LEN);\n\t\tlen -= first;\n\t\tfirst -= ETH_MODULE_SFF_8079_LEN;\n\n\t\tret = sfp_read(sfp, true, first, data, len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int sfp_module_eeprom_by_page(struct sfp *sfp,\n\t\t\t\t     const struct ethtool_module_eeprom *page,\n\t\t\t\t     struct netlink_ext_ack *extack)\n{\n\tif (!(sfp->state & SFP_F_PRESENT))\n\t\treturn -ENODEV;\n\n\tif (page->bank) {\n\t\tNL_SET_ERR_MSG(extack, \"Banks not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (page->page) {\n\t\tNL_SET_ERR_MSG(extack, \"Only page 0 supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (page->i2c_address != 0x50 &&\n\t    page->i2c_address != 0x51) {\n\t\tNL_SET_ERR_MSG(extack, \"Only address 0x50 and 0x51 supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn sfp_read(sfp, page->i2c_address == 0x51, page->offset,\n\t\t\tpage->data, page->length);\n};\n\nstatic const struct sfp_socket_ops sfp_module_ops = {\n\t.attach = sfp_attach,\n\t.detach = sfp_detach,\n\t.start = sfp_start,\n\t.stop = sfp_stop,\n\t.set_signal_rate = sfp_set_signal_rate,\n\t.module_info = sfp_module_info,\n\t.module_eeprom = sfp_module_eeprom,\n\t.module_eeprom_by_page = sfp_module_eeprom_by_page,\n};\n\nstatic void sfp_timeout(struct work_struct *work)\n{\n\tstruct sfp *sfp = container_of(work, struct sfp, timeout.work);\n\n\trtnl_lock();\n\tsfp_sm_event(sfp, SFP_E_TIMEOUT);\n\trtnl_unlock();\n}\n\nstatic void sfp_check_state(struct sfp *sfp)\n{\n\tunsigned int state, i, changed;\n\n\trtnl_lock();\n\tmutex_lock(&sfp->st_mutex);\n\tstate = sfp_get_state(sfp);\n\tchanged = state ^ sfp->state;\n\tif (sfp->tx_fault_ignore)\n\t\tchanged &= SFP_F_PRESENT | SFP_F_LOS;\n\telse\n\t\tchanged &= SFP_F_PRESENT | SFP_F_LOS | SFP_F_TX_FAULT;\n\n\tfor (i = 0; i < GPIO_MAX; i++)\n\t\tif (changed & BIT(i))\n\t\t\tdev_dbg(sfp->dev, \"%s %u -> %u\\n\", gpio_names[i],\n\t\t\t\t!!(sfp->state & BIT(i)), !!(state & BIT(i)));\n\n\tstate |= sfp->state & SFP_F_OUTPUTS;\n\tsfp->state = state;\n\tmutex_unlock(&sfp->st_mutex);\n\n\tmutex_lock(&sfp->sm_mutex);\n\tif (changed & SFP_F_PRESENT)\n\t\t__sfp_sm_event(sfp, state & SFP_F_PRESENT ?\n\t\t\t\t    SFP_E_INSERT : SFP_E_REMOVE);\n\n\tif (changed & SFP_F_TX_FAULT)\n\t\t__sfp_sm_event(sfp, state & SFP_F_TX_FAULT ?\n\t\t\t\t    SFP_E_TX_FAULT : SFP_E_TX_CLEAR);\n\n\tif (changed & SFP_F_LOS)\n\t\t__sfp_sm_event(sfp, state & SFP_F_LOS ?\n\t\t\t\t    SFP_E_LOS_HIGH : SFP_E_LOS_LOW);\n\tmutex_unlock(&sfp->sm_mutex);\n\trtnl_unlock();\n}\n\nstatic irqreturn_t sfp_irq(int irq, void *data)\n{\n\tstruct sfp *sfp = data;\n\n\tsfp_check_state(sfp);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void sfp_poll(struct work_struct *work)\n{\n\tstruct sfp *sfp = container_of(work, struct sfp, poll.work);\n\n\tsfp_check_state(sfp);\n\n\t \n\t\n\tif (sfp->state_soft_mask & (SFP_F_LOS | SFP_F_TX_FAULT) ||\n\t    sfp->need_poll)\n\t\tmod_delayed_work(system_wq, &sfp->poll, poll_jiffies);\n}\n\nstatic struct sfp *sfp_alloc(struct device *dev)\n{\n\tstruct sfp *sfp;\n\n\tsfp = kzalloc(sizeof(*sfp), GFP_KERNEL);\n\tif (!sfp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsfp->dev = dev;\n\tsfp->i2c_block_size = SFP_EEPROM_BLOCK_SIZE;\n\n\tmutex_init(&sfp->sm_mutex);\n\tmutex_init(&sfp->st_mutex);\n\tINIT_DELAYED_WORK(&sfp->poll, sfp_poll);\n\tINIT_DELAYED_WORK(&sfp->timeout, sfp_timeout);\n\n\tsfp_hwmon_init(sfp);\n\n\treturn sfp;\n}\n\nstatic void sfp_cleanup(void *data)\n{\n\tstruct sfp *sfp = data;\n\n\tsfp_hwmon_exit(sfp);\n\n\tcancel_delayed_work_sync(&sfp->poll);\n\tcancel_delayed_work_sync(&sfp->timeout);\n\tif (sfp->i2c_mii) {\n\t\tmdiobus_unregister(sfp->i2c_mii);\n\t\tmdiobus_free(sfp->i2c_mii);\n\t}\n\tif (sfp->i2c)\n\t\ti2c_put_adapter(sfp->i2c);\n\tkfree(sfp);\n}\n\nstatic int sfp_i2c_get(struct sfp *sfp)\n{\n\tstruct fwnode_handle *h;\n\tstruct i2c_adapter *i2c;\n\tint err;\n\n\th = fwnode_find_reference(dev_fwnode(sfp->dev), \"i2c-bus\", 0);\n\tif (IS_ERR(h)) {\n\t\tdev_err(sfp->dev, \"missing 'i2c-bus' property\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\ti2c = i2c_get_adapter_by_fwnode(h);\n\tif (!i2c) {\n\t\terr = -EPROBE_DEFER;\n\t\tgoto put;\n\t}\n\n\terr = sfp_i2c_configure(sfp, i2c);\n\tif (err)\n\t\ti2c_put_adapter(i2c);\nput:\n\tfwnode_handle_put(h);\n\treturn err;\n}\n\nstatic int sfp_probe(struct platform_device *pdev)\n{\n\tconst struct sff_data *sff;\n\tchar *sfp_irq_name;\n\tstruct sfp *sfp;\n\tint err, i;\n\n\tsfp = sfp_alloc(&pdev->dev);\n\tif (IS_ERR(sfp))\n\t\treturn PTR_ERR(sfp);\n\n\tplatform_set_drvdata(pdev, sfp);\n\n\terr = devm_add_action_or_reset(sfp->dev, sfp_cleanup, sfp);\n\tif (err < 0)\n\t\treturn err;\n\n\tsff = device_get_match_data(sfp->dev);\n\tif (!sff)\n\t\tsff = &sfp_data;\n\n\tsfp->type = sff;\n\n\terr = sfp_i2c_get(sfp);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < GPIO_MAX; i++)\n\t\tif (sff->gpios & BIT(i)) {\n\t\t\tsfp->gpio[i] = devm_gpiod_get_optional(sfp->dev,\n\t\t\t\t\t   gpio_names[i], gpio_flags[i]);\n\t\t\tif (IS_ERR(sfp->gpio[i]))\n\t\t\t\treturn PTR_ERR(sfp->gpio[i]);\n\t\t}\n\n\tsfp->state_hw_mask = SFP_F_PRESENT;\n\tsfp->state_hw_drive = SFP_F_TX_DISABLE;\n\n\tsfp->get_state = sfp_gpio_get_state;\n\tsfp->set_state = sfp_gpio_set_state;\n\n\t \n\tif (!(sfp->gpio[GPIO_MODDEF0]))\n\t\tsfp->get_state = sff_gpio_get_state;\n\n\tdevice_property_read_u32(&pdev->dev, \"maximum-power-milliwatt\",\n\t\t\t\t &sfp->max_power_mW);\n\tif (sfp->max_power_mW < 1000) {\n\t\tif (sfp->max_power_mW)\n\t\t\tdev_warn(sfp->dev,\n\t\t\t\t \"Firmware bug: host maximum power should be at least 1W\\n\");\n\t\tsfp->max_power_mW = 1000;\n\t}\n\n\tdev_info(sfp->dev, \"Host maximum power %u.%uW\\n\",\n\t\t sfp->max_power_mW / 1000, (sfp->max_power_mW / 100) % 10);\n\n\t \n\tsfp->state = sfp_get_state(sfp) | SFP_F_TX_DISABLE;\n\n\tif (sfp->gpio[GPIO_RS0] &&\n\t    gpiod_get_value_cansleep(sfp->gpio[GPIO_RS0]))\n\t\tsfp->state |= SFP_F_RS0;\n\tsfp_set_state(sfp, sfp->state);\n\tsfp_module_tx_disable(sfp);\n\tif (sfp->state & SFP_F_PRESENT) {\n\t\trtnl_lock();\n\t\tsfp_sm_event(sfp, SFP_E_INSERT);\n\t\trtnl_unlock();\n\t}\n\n\tfor (i = 0; i < GPIO_MAX; i++) {\n\t\tif (gpio_flags[i] != GPIOD_IN || !sfp->gpio[i])\n\t\t\tcontinue;\n\n\t\tsfp->gpio_irq[i] = gpiod_to_irq(sfp->gpio[i]);\n\t\tif (sfp->gpio_irq[i] < 0) {\n\t\t\tsfp->gpio_irq[i] = 0;\n\t\t\tsfp->need_poll = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsfp_irq_name = devm_kasprintf(sfp->dev, GFP_KERNEL,\n\t\t\t\t\t      \"%s-%s\", dev_name(sfp->dev),\n\t\t\t\t\t      gpio_names[i]);\n\n\t\tif (!sfp_irq_name)\n\t\t\treturn -ENOMEM;\n\n\t\terr = devm_request_threaded_irq(sfp->dev, sfp->gpio_irq[i],\n\t\t\t\t\t\tNULL, sfp_irq,\n\t\t\t\t\t\tIRQF_ONESHOT |\n\t\t\t\t\t\tIRQF_TRIGGER_RISING |\n\t\t\t\t\t\tIRQF_TRIGGER_FALLING,\n\t\t\t\t\t\tsfp_irq_name, sfp);\n\t\tif (err) {\n\t\t\tsfp->gpio_irq[i] = 0;\n\t\t\tsfp->need_poll = true;\n\t\t}\n\t}\n\n\tif (sfp->need_poll)\n\t\tmod_delayed_work(system_wq, &sfp->poll, poll_jiffies);\n\n\t \n\tif (!sfp->gpio[GPIO_TX_DISABLE])\n\t\tdev_warn(sfp->dev,\n\t\t\t \"No tx_disable pin: SFP modules will always be emitting.\\n\");\n\n\tsfp->sfp_bus = sfp_register_socket(sfp->dev, sfp, &sfp_module_ops);\n\tif (!sfp->sfp_bus)\n\t\treturn -ENOMEM;\n\n\tsfp_debugfs_init(sfp);\n\n\treturn 0;\n}\n\nstatic int sfp_remove(struct platform_device *pdev)\n{\n\tstruct sfp *sfp = platform_get_drvdata(pdev);\n\n\tsfp_debugfs_exit(sfp);\n\tsfp_unregister_socket(sfp->sfp_bus);\n\n\trtnl_lock();\n\tsfp_sm_event(sfp, SFP_E_REMOVE);\n\trtnl_unlock();\n\n\treturn 0;\n}\n\nstatic void sfp_shutdown(struct platform_device *pdev)\n{\n\tstruct sfp *sfp = platform_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < GPIO_MAX; i++) {\n\t\tif (!sfp->gpio_irq[i])\n\t\t\tcontinue;\n\n\t\tdevm_free_irq(sfp->dev, sfp->gpio_irq[i], sfp);\n\t}\n\n\tcancel_delayed_work_sync(&sfp->poll);\n\tcancel_delayed_work_sync(&sfp->timeout);\n}\n\nstatic struct platform_driver sfp_driver = {\n\t.probe = sfp_probe,\n\t.remove = sfp_remove,\n\t.shutdown = sfp_shutdown,\n\t.driver = {\n\t\t.name = \"sfp\",\n\t\t.of_match_table = sfp_of_match,\n\t},\n};\n\nstatic int sfp_init(void)\n{\n\tpoll_jiffies = msecs_to_jiffies(100);\n\n\treturn platform_driver_register(&sfp_driver);\n}\nmodule_init(sfp_init);\n\nstatic void sfp_exit(void)\n{\n\tplatform_driver_unregister(&sfp_driver);\n}\nmodule_exit(sfp_exit);\n\nMODULE_ALIAS(\"platform:sfp\");\nMODULE_AUTHOR(\"Russell King\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}