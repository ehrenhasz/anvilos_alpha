{
  "module_name": "adin1100.c",
  "hash_id": "6229584367cb2041a83e0a57e9963979782c2b3ba1354a7bd339600292f05e4c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/adin1100.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/mii.h>\n#include <linux/phy.h>\n#include <linux/property.h>\n\n#define PHY_ID_ADIN1100\t\t\t\t0x0283bc81\n#define PHY_ID_ADIN1110\t\t\t\t0x0283bc91\n#define PHY_ID_ADIN2111\t\t\t\t0x0283bca1\n\n#define ADIN_FORCED_MODE\t\t\t0x8000\n#define   ADIN_FORCED_MODE_EN\t\t\tBIT(0)\n\n#define ADIN_CRSM_SFT_RST\t\t\t0x8810\n#define   ADIN_CRSM_SFT_RST_EN\t\t\tBIT(0)\n\n#define ADIN_CRSM_SFT_PD_CNTRL\t\t\t0x8812\n#define   ADIN_CRSM_SFT_PD_CNTRL_EN\t\tBIT(0)\n\n#define ADIN_AN_PHY_INST_STATUS\t\t\t0x8030\n#define   ADIN_IS_CFG_SLV\t\t\tBIT(2)\n#define   ADIN_IS_CFG_MST\t\t\tBIT(3)\n\n#define ADIN_CRSM_STAT\t\t\t\t0x8818\n#define   ADIN_CRSM_SFT_PD_RDY\t\t\tBIT(1)\n#define   ADIN_CRSM_SYS_RDY\t\t\tBIT(0)\n\n#define ADIN_MSE_VAL\t\t\t\t0x830B\n\n#define ADIN_SQI_MAX\t7\n\nstruct adin_mse_sqi_range {\n\tu16 start;\n\tu16 end;\n};\n\nstatic const struct adin_mse_sqi_range adin_mse_sqi_map[] = {\n\t{ 0x0A74, 0xFFFF },\n\t{ 0x084E, 0x0A74 },\n\t{ 0x0698, 0x084E },\n\t{ 0x053D, 0x0698 },\n\t{ 0x0429, 0x053D },\n\t{ 0x034E, 0x0429 },\n\t{ 0x02A0, 0x034E },\n\t{ 0x0000, 0x02A0 },\n};\n\n \nstruct adin_priv {\n\tunsigned int\t\ttx_level_2v4_able:1;\n\tunsigned int\t\ttx_level_2v4:1;\n\tunsigned int\t\ttx_level_prop_present:1;\n};\n\nstatic int adin_read_status(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = genphy_c45_read_status(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_read_mmd(phydev, MDIO_MMD_AN, ADIN_AN_PHY_INST_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & ADIN_IS_CFG_SLV)\n\t\tphydev->master_slave_state = MASTER_SLAVE_STATE_SLAVE;\n\n\tif (ret & ADIN_IS_CFG_MST)\n\t\tphydev->master_slave_state = MASTER_SLAVE_STATE_MASTER;\n\n\treturn 0;\n}\n\nstatic int adin_config_aneg(struct phy_device *phydev)\n{\n\tstruct adin_priv *priv = phydev->priv;\n\tint ret;\n\n\tif (phydev->autoneg == AUTONEG_DISABLE) {\n\t\tret = genphy_c45_pma_setup_forced(phydev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (priv->tx_level_prop_present && priv->tx_level_2v4)\n\t\t\tret = phy_set_bits_mmd(phydev, MDIO_MMD_PMAPMD, MDIO_B10L_PMA_CTRL,\n\t\t\t\t\t       MDIO_PMA_10T1L_CTRL_2V4_EN);\n\t\telse\n\t\t\tret = phy_clear_bits_mmd(phydev, MDIO_MMD_PMAPMD, MDIO_B10L_PMA_CTRL,\n\t\t\t\t\t\t MDIO_PMA_10T1L_CTRL_2V4_EN);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\treturn phy_set_bits_mmd(phydev, MDIO_MMD_AN, ADIN_FORCED_MODE, ADIN_FORCED_MODE_EN);\n\t}\n\n\tret = phy_clear_bits_mmd(phydev, MDIO_MMD_AN, ADIN_FORCED_MODE, ADIN_FORCED_MODE_EN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (priv->tx_level_prop_present && priv->tx_level_2v4) {\n\t\tret = phy_set_bits_mmd(phydev, MDIO_MMD_AN, MDIO_AN_T1_ADV_H,\n\t\t\t\t       MDIO_AN_T1_ADV_H_10L_TX_HI |\n\t\t\t\t       MDIO_AN_T1_ADV_H_10L_TX_HI_REQ);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif ((priv->tx_level_prop_present && !priv->tx_level_2v4) || !priv->tx_level_2v4_able) {\n\t\tret = phy_clear_bits_mmd(phydev, MDIO_MMD_AN, MDIO_AN_T1_ADV_H,\n\t\t\t\t\t MDIO_AN_T1_ADV_H_10L_TX_HI |\n\t\t\t\t\t MDIO_AN_T1_ADV_H_10L_TX_HI_REQ);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn genphy_c45_config_aneg(phydev);\n}\n\nstatic int adin_set_powerdown_mode(struct phy_device *phydev, bool en)\n{\n\tint ret;\n\tint val;\n\n\tval = en ? ADIN_CRSM_SFT_PD_CNTRL_EN : 0;\n\tret = phy_write_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t    ADIN_CRSM_SFT_PD_CNTRL, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn phy_read_mmd_poll_timeout(phydev, MDIO_MMD_VEND1, ADIN_CRSM_STAT, ret,\n\t\t\t\t\t (ret & ADIN_CRSM_SFT_PD_RDY) == val,\n\t\t\t\t\t 1000, 30000, true);\n}\n\nstatic int adin_suspend(struct phy_device *phydev)\n{\n\treturn adin_set_powerdown_mode(phydev, true);\n}\n\nstatic int adin_resume(struct phy_device *phydev)\n{\n\treturn adin_set_powerdown_mode(phydev, false);\n}\n\nstatic int adin_set_loopback(struct phy_device *phydev, bool enable)\n{\n\tif (enable)\n\t\treturn phy_set_bits_mmd(phydev, MDIO_MMD_PCS, MDIO_PCS_10T1L_CTRL,\n\t\t\t\t\tBMCR_LOOPBACK);\n\n\t \n\treturn phy_clear_bits_mmd(phydev, MDIO_MMD_PCS, MDIO_PCS_10T1L_CTRL,\n\t\t\t\t BMCR_LOOPBACK);\n}\n\nstatic int adin_soft_reset(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = phy_set_bits_mmd(phydev, MDIO_MMD_VEND1, ADIN_CRSM_SFT_RST, ADIN_CRSM_SFT_RST_EN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn phy_read_mmd_poll_timeout(phydev, MDIO_MMD_VEND1, ADIN_CRSM_STAT, ret,\n\t\t\t\t\t (ret & ADIN_CRSM_SYS_RDY),\n\t\t\t\t\t 10000, 30000, true);\n}\n\nstatic int adin_get_features(struct phy_device *phydev)\n{\n\tstruct adin_priv *priv = phydev->priv;\n\tstruct device *dev = &phydev->mdio.dev;\n\tint ret;\n\tu8 val;\n\n\tret = phy_read_mmd(phydev, MDIO_MMD_PMAPMD, MDIO_PMA_10T1L_STAT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tpriv->tx_level_2v4_able = !!(ret & MDIO_PMA_10T1L_STAT_2V4_ABLE);\n\n\tphydev_dbg(phydev, \"PHY supports 2.4V TX level: %s\\n\",\n\t\t   priv->tx_level_2v4_able ? \"yes\" : \"no\");\n\n\tpriv->tx_level_prop_present = device_property_present(dev, \"phy-10base-t1l-2.4vpp\");\n\tif (priv->tx_level_prop_present) {\n\t\tret = device_property_read_u8(dev, \"phy-10base-t1l-2.4vpp\", &val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tpriv->tx_level_2v4 = val;\n\t\tif (!priv->tx_level_2v4 && priv->tx_level_2v4_able)\n\t\t\tphydev_info(phydev,\n\t\t\t\t    \"PHY supports 2.4V TX level, but disabled via config\\n\");\n\t}\n\n\tlinkmode_set_bit_array(phy_basic_ports_array, ARRAY_SIZE(phy_basic_ports_array),\n\t\t\t       phydev->supported);\n\n\treturn genphy_c45_pma_read_abilities(phydev);\n}\n\nstatic int adin_get_sqi(struct phy_device *phydev)\n{\n\tu16 mse_val;\n\tint sqi;\n\tint ret;\n\n\tret = phy_read_mmd(phydev, MDIO_MMD_PMAPMD, MDIO_STAT1);\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (!(ret & MDIO_STAT1_LSTATUS))\n\t\treturn 0;\n\n\tret = phy_read_mmd(phydev, MDIO_STAT1, ADIN_MSE_VAL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmse_val = 0xFFFF & ret;\n\tfor (sqi = 0; sqi < ARRAY_SIZE(adin_mse_sqi_map); sqi++) {\n\t\tif (mse_val >= adin_mse_sqi_map[sqi].start && mse_val <= adin_mse_sqi_map[sqi].end)\n\t\t\treturn sqi;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int adin_get_sqi_max(struct phy_device *phydev)\n{\n\treturn ADIN_SQI_MAX;\n}\n\nstatic int adin_probe(struct phy_device *phydev)\n{\n\tstruct device *dev = &phydev->mdio.dev;\n\tstruct adin_priv *priv;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tphydev->priv = priv;\n\n\treturn 0;\n}\n\nstatic struct phy_driver adin_driver[] = {\n\t{\n\t\t.phy_id\t\t\t= PHY_ID_ADIN1100,\n\t\t.phy_id_mask\t\t= 0xffffffcf,\n\t\t.name\t\t\t= \"ADIN1100\",\n\t\t.get_features\t\t= adin_get_features,\n\t\t.soft_reset\t\t= adin_soft_reset,\n\t\t.probe\t\t\t= adin_probe,\n\t\t.config_aneg\t\t= adin_config_aneg,\n\t\t.read_status\t\t= adin_read_status,\n\t\t.set_loopback\t\t= adin_set_loopback,\n\t\t.suspend\t\t= adin_suspend,\n\t\t.resume\t\t\t= adin_resume,\n\t\t.get_sqi\t\t= adin_get_sqi,\n\t\t.get_sqi_max\t\t= adin_get_sqi_max,\n\t},\n};\n\nmodule_phy_driver(adin_driver);\n\nstatic struct mdio_device_id __maybe_unused adin_tbl[] = {\n\t{ PHY_ID_MATCH_MODEL(PHY_ID_ADIN1100) },\n\t{ PHY_ID_MATCH_MODEL(PHY_ID_ADIN1110) },\n\t{ PHY_ID_MATCH_MODEL(PHY_ID_ADIN2111) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(mdio, adin_tbl);\nMODULE_DESCRIPTION(\"Analog Devices Industrial Ethernet T1L PHY driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}