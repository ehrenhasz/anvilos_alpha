{
  "module_name": "mxl-gpy.c",
  "hash_id": "b8929308887c3e054d55c8f4c4b94b2315b87cf0ab8264a65037993c1818ab3c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/mxl-gpy.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/bitfield.h>\n#include <linux/hwmon.h>\n#include <linux/mutex.h>\n#include <linux/phy.h>\n#include <linux/polynomial.h>\n#include <linux/property.h>\n#include <linux/netdevice.h>\n\n \n#define PHY_ID_GPYx15B_MASK\t0xFFFFFFFC\n#define PHY_ID_GPY21xB_MASK\t0xFFFFFFF9\n#define PHY_ID_GPY2xx\t\t0x67C9DC00\n#define PHY_ID_GPY115B\t\t0x67C9DF00\n#define PHY_ID_GPY115C\t\t0x67C9DF10\n#define PHY_ID_GPY211B\t\t0x67C9DE08\n#define PHY_ID_GPY211C\t\t0x67C9DE10\n#define PHY_ID_GPY212B\t\t0x67C9DE09\n#define PHY_ID_GPY212C\t\t0x67C9DE20\n#define PHY_ID_GPY215B\t\t0x67C9DF04\n#define PHY_ID_GPY215C\t\t0x67C9DF20\n#define PHY_ID_GPY241B\t\t0x67C9DE40\n#define PHY_ID_GPY241BM\t\t0x67C9DE80\n#define PHY_ID_GPY245B\t\t0x67C9DEC0\n\n#define PHY_CTL1\t\t0x13\n#define PHY_CTL1_MDICD\t\tBIT(3)\n#define PHY_CTL1_MDIAB\t\tBIT(2)\n#define PHY_CTL1_AMDIX\t\tBIT(0)\n#define PHY_MIISTAT\t\t0x18\t \n#define PHY_IMASK\t\t0x19\t \n#define PHY_ISTAT\t\t0x1A\t \n#define PHY_FWV\t\t\t0x1E\t \n\n#define PHY_MIISTAT_SPD_MASK\tGENMASK(2, 0)\n#define PHY_MIISTAT_DPX\t\tBIT(3)\n#define PHY_MIISTAT_LS\t\tBIT(10)\n\n#define PHY_MIISTAT_SPD_10\t0\n#define PHY_MIISTAT_SPD_100\t1\n#define PHY_MIISTAT_SPD_1000\t2\n#define PHY_MIISTAT_SPD_2500\t4\n\n#define PHY_IMASK_WOL\t\tBIT(15)\t \n#define PHY_IMASK_ANC\t\tBIT(10)\t \n#define PHY_IMASK_ADSC\t\tBIT(5)\t \n#define PHY_IMASK_DXMC\t\tBIT(2)\t \n#define PHY_IMASK_LSPC\t\tBIT(1)\t \n#define PHY_IMASK_LSTC\t\tBIT(0)\t \n#define PHY_IMASK_MASK\t\t(PHY_IMASK_LSTC | \\\n\t\t\t\t PHY_IMASK_LSPC | \\\n\t\t\t\t PHY_IMASK_DXMC | \\\n\t\t\t\t PHY_IMASK_ADSC | \\\n\t\t\t\t PHY_IMASK_ANC)\n\n#define PHY_FWV_REL_MASK\tBIT(15)\n#define PHY_FWV_MAJOR_MASK\tGENMASK(11, 8)\n#define PHY_FWV_MINOR_MASK\tGENMASK(7, 0)\n\n#define PHY_PMA_MGBT_POLARITY\t0x82\n#define PHY_MDI_MDI_X_MASK\tGENMASK(1, 0)\n#define PHY_MDI_MDI_X_NORMAL\t0x3\n#define PHY_MDI_MDI_X_AB\t0x2\n#define PHY_MDI_MDI_X_CD\t0x1\n#define PHY_MDI_MDI_X_CROSS\t0x0\n\n \n#define VSPEC1_SGMII_CTRL\t0x08\n#define VSPEC1_SGMII_CTRL_ANEN\tBIT(12)\t\t \n#define VSPEC1_SGMII_CTRL_ANRS\tBIT(9)\t\t \n#define VSPEC1_SGMII_ANEN_ANRS\t(VSPEC1_SGMII_CTRL_ANEN | \\\n\t\t\t\t VSPEC1_SGMII_CTRL_ANRS)\n\n \n#define VSPEC1_TEMP_STA\t0x0E\n#define VSPEC1_TEMP_STA_DATA\tGENMASK(9, 0)\n\n \n#define VSPEC1_MBOX_DATA\t0x5\n#define VSPEC1_MBOX_ADDRLO\t0x6\n#define VSPEC1_MBOX_CMD\t\t0x7\n#define VSPEC1_MBOX_CMD_ADDRHI\tGENMASK(7, 0)\n#define VSPEC1_MBOX_CMD_RD\t(0 << 8)\n#define VSPEC1_MBOX_CMD_READY\tBIT(15)\n\n \n#define VPSPEC2_WOL_CTL\t\t0x0E06\n#define VPSPEC2_WOL_AD01\t0x0E08\n#define VPSPEC2_WOL_AD23\t0x0E09\n#define VPSPEC2_WOL_AD45\t0x0E0A\n#define WOL_EN\t\t\tBIT(0)\n\n \n#define REG_GPIO0_OUT\t\t0xd3ce00\n\nstruct gpy_priv {\n\t \n\tstruct mutex mbox_lock;\n\n\tu8 fw_major;\n\tu8 fw_minor;\n\n\t \n\tu64 lb_dis_to;\n};\n\nstatic const struct {\n\tint major;\n\tint minor;\n} ver_need_sgmii_reaneg[] = {\n\t{7, 0x6D},\n\t{8, 0x6D},\n\t{9, 0x73},\n};\n\n#if IS_ENABLED(CONFIG_HWMON)\n \nstatic const struct polynomial poly_N_to_temp = {\n\t.terms = {\n\t\t{4,  -25761, 1000, 1},\n\t\t{3,   97332, 1000, 1},\n\t\t{2, -191650, 1000, 1},\n\t\t{1,  307620, 1000, 1},\n\t\t{0,  -52156,    1, 1}\n\t}\n};\n\nstatic int gpy_hwmon_read(struct device *dev,\n\t\t\t  enum hwmon_sensor_types type,\n\t\t\t  u32 attr, int channel, long *value)\n{\n\tstruct phy_device *phydev = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = phy_read_mmd(phydev, MDIO_MMD_VEND1, VSPEC1_TEMP_STA);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!ret)\n\t\treturn -ENODATA;\n\n\t*value = polynomial_calc(&poly_N_to_temp,\n\t\t\t\t FIELD_GET(VSPEC1_TEMP_STA_DATA, ret));\n\n\treturn 0;\n}\n\nstatic umode_t gpy_hwmon_is_visible(const void *data,\n\t\t\t\t    enum hwmon_sensor_types type,\n\t\t\t\t    u32 attr, int channel)\n{\n\treturn 0444;\n}\n\nstatic const struct hwmon_channel_info * const gpy_hwmon_info[] = {\n\tHWMON_CHANNEL_INFO(temp, HWMON_T_INPUT),\n\tNULL\n};\n\nstatic const struct hwmon_ops gpy_hwmon_hwmon_ops = {\n\t.is_visible\t= gpy_hwmon_is_visible,\n\t.read\t\t= gpy_hwmon_read,\n};\n\nstatic const struct hwmon_chip_info gpy_hwmon_chip_info = {\n\t.ops\t\t= &gpy_hwmon_hwmon_ops,\n\t.info\t\t= gpy_hwmon_info,\n};\n\nstatic int gpy_hwmon_register(struct phy_device *phydev)\n{\n\tstruct device *dev = &phydev->mdio.dev;\n\tstruct device *hwmon_dev;\n\tchar *hwmon_name;\n\n\thwmon_name = devm_hwmon_sanitize_name(dev, dev_name(dev));\n\tif (IS_ERR(hwmon_name))\n\t\treturn PTR_ERR(hwmon_name);\n\n\thwmon_dev = devm_hwmon_device_register_with_info(dev, hwmon_name,\n\t\t\t\t\t\t\t phydev,\n\t\t\t\t\t\t\t &gpy_hwmon_chip_info,\n\t\t\t\t\t\t\t NULL);\n\n\treturn PTR_ERR_OR_ZERO(hwmon_dev);\n}\n#else\nstatic int gpy_hwmon_register(struct phy_device *phydev)\n{\n\treturn 0;\n}\n#endif\n\nstatic int gpy_mbox_read(struct phy_device *phydev, u32 addr)\n{\n\tstruct gpy_priv *priv = phydev->priv;\n\tint val, ret;\n\tu16 cmd;\n\n\tmutex_lock(&priv->mbox_lock);\n\n\tret = phy_write_mmd(phydev, MDIO_MMD_VEND1, VSPEC1_MBOX_ADDRLO,\n\t\t\t    addr);\n\tif (ret)\n\t\tgoto out;\n\n\tcmd = VSPEC1_MBOX_CMD_RD;\n\tcmd |= FIELD_PREP(VSPEC1_MBOX_CMD_ADDRHI, addr >> 16);\n\n\tret = phy_write_mmd(phydev, MDIO_MMD_VEND1, VSPEC1_MBOX_CMD, cmd);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = phy_read_mmd_poll_timeout(phydev, MDIO_MMD_VEND1,\n\t\t\t\t\tVSPEC1_MBOX_CMD, val,\n\t\t\t\t\t(val & VSPEC1_MBOX_CMD_READY),\n\t\t\t\t\t500, 10000, false);\n\tif (ret)\n\t\tgoto out;\n\n\tret = phy_read_mmd(phydev, MDIO_MMD_VEND1, VSPEC1_MBOX_DATA);\n\nout:\n\tmutex_unlock(&priv->mbox_lock);\n\treturn ret;\n}\n\nstatic int gpy_config_init(struct phy_device *phydev)\n{\n\tint ret;\n\n\t \n\tret = phy_write(phydev, PHY_IMASK, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = phy_read(phydev, PHY_ISTAT);\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int gpy_probe(struct phy_device *phydev)\n{\n\tstruct device *dev = &phydev->mdio.dev;\n\tstruct gpy_priv *priv;\n\tint fw_version;\n\tint ret;\n\n\tif (!phydev->is_c45) {\n\t\tret = phy_get_c45_ids(phydev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tphydev->priv = priv;\n\tmutex_init(&priv->mbox_lock);\n\n\tif (!device_property_present(dev, \"maxlinear,use-broken-interrupts\"))\n\t\tphydev->dev_flags |= PHY_F_NO_IRQ;\n\n\tfw_version = phy_read(phydev, PHY_FWV);\n\tif (fw_version < 0)\n\t\treturn fw_version;\n\tpriv->fw_major = FIELD_GET(PHY_FWV_MAJOR_MASK, fw_version);\n\tpriv->fw_minor = FIELD_GET(PHY_FWV_MINOR_MASK, fw_version);\n\n\tret = gpy_hwmon_register(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tphydev_info(phydev, \"Firmware Version: %d.%d (0x%04X%s)\\n\",\n\t\t    priv->fw_major, priv->fw_minor, fw_version,\n\t\t    fw_version & PHY_FWV_REL_MASK ? \"\" : \" test version\");\n\n\treturn 0;\n}\n\nstatic bool gpy_sgmii_need_reaneg(struct phy_device *phydev)\n{\n\tstruct gpy_priv *priv = phydev->priv;\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ver_need_sgmii_reaneg); i++) {\n\t\tif (priv->fw_major != ver_need_sgmii_reaneg[i].major)\n\t\t\tcontinue;\n\t\tif (priv->fw_minor < ver_need_sgmii_reaneg[i].minor)\n\t\t\treturn true;\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic bool gpy_2500basex_chk(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = phy_read(phydev, PHY_MIISTAT);\n\tif (ret < 0) {\n\t\tphydev_err(phydev, \"Error: MDIO register access failed: %d\\n\",\n\t\t\t   ret);\n\t\treturn false;\n\t}\n\n\tif (!(ret & PHY_MIISTAT_LS) ||\n\t    FIELD_GET(PHY_MIISTAT_SPD_MASK, ret) != PHY_MIISTAT_SPD_2500)\n\t\treturn false;\n\n\tphydev->speed = SPEED_2500;\n\tphydev->interface = PHY_INTERFACE_MODE_2500BASEX;\n\tphy_modify_mmd(phydev, MDIO_MMD_VEND1, VSPEC1_SGMII_CTRL,\n\t\t       VSPEC1_SGMII_CTRL_ANEN, 0);\n\treturn true;\n}\n\nstatic bool gpy_sgmii_aneg_en(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = phy_read_mmd(phydev, MDIO_MMD_VEND1, VSPEC1_SGMII_CTRL);\n\tif (ret < 0) {\n\t\tphydev_err(phydev, \"Error: MMD register access failed: %d\\n\",\n\t\t\t   ret);\n\t\treturn true;\n\t}\n\n\treturn (ret & VSPEC1_SGMII_CTRL_ANEN) ? true : false;\n}\n\nstatic int gpy_config_mdix(struct phy_device *phydev, u8 ctrl)\n{\n\tint ret;\n\tu16 val;\n\n\tswitch (ctrl) {\n\tcase ETH_TP_MDI_AUTO:\n\t\tval = PHY_CTL1_AMDIX;\n\t\tbreak;\n\tcase ETH_TP_MDI_X:\n\t\tval = (PHY_CTL1_MDIAB | PHY_CTL1_MDICD);\n\t\tbreak;\n\tcase ETH_TP_MDI:\n\t\tval = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tret =  phy_modify(phydev, PHY_CTL1, PHY_CTL1_AMDIX | PHY_CTL1_MDIAB |\n\t\t\t  PHY_CTL1_MDICD, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn genphy_c45_restart_aneg(phydev);\n}\n\nstatic int gpy_config_aneg(struct phy_device *phydev)\n{\n\tbool changed = false;\n\tu32 adv;\n\tint ret;\n\n\tif (phydev->autoneg == AUTONEG_DISABLE) {\n\t\t \n\t\treturn phydev->duplex != DUPLEX_FULL\n\t\t\t? genphy_setup_forced(phydev)\n\t\t\t: genphy_c45_pma_setup_forced(phydev);\n\t}\n\n\tret = gpy_config_mdix(phydev,  phydev->mdix_ctrl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = genphy_c45_an_config_aneg(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret > 0)\n\t\tchanged = true;\n\n\tadv = linkmode_adv_to_mii_ctrl1000_t(phydev->advertising);\n\tret = phy_modify_changed(phydev, MII_CTRL1000,\n\t\t\t\t ADVERTISE_1000FULL | ADVERTISE_1000HALF,\n\t\t\t\t adv);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret > 0)\n\t\tchanged = true;\n\n\tret = genphy_c45_check_and_restart_aneg(phydev, changed);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (phydev->interface == PHY_INTERFACE_MODE_USXGMII ||\n\t    phydev->interface == PHY_INTERFACE_MODE_INTERNAL)\n\t\treturn 0;\n\n\t \n\tif (!gpy_sgmii_need_reaneg(phydev) || gpy_2500basex_chk(phydev) ||\n\t    !gpy_sgmii_aneg_en(phydev))\n\t\treturn 0;\n\n\t \n\n\tif (phydev->state != PHY_UP)\n\t\treturn 0;\n\n\tret = phy_read_poll_timeout(phydev, MII_BMSR, ret, ret & BMSR_LSTATUS,\n\t\t\t\t    20000, 4000000, false);\n\tif (ret == -ETIMEDOUT)\n\t\treturn 0;\n\telse if (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn phy_modify_mmd(phydev, MDIO_MMD_VEND1, VSPEC1_SGMII_CTRL,\n\t\t\t      VSPEC1_SGMII_CTRL_ANRS, VSPEC1_SGMII_CTRL_ANRS);\n}\n\nstatic int gpy_update_mdix(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = phy_read(phydev, PHY_CTL1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & PHY_CTL1_AMDIX)\n\t\tphydev->mdix_ctrl = ETH_TP_MDI_AUTO;\n\telse\n\t\tif (ret & PHY_CTL1_MDICD || ret & PHY_CTL1_MDIAB)\n\t\t\tphydev->mdix_ctrl = ETH_TP_MDI_X;\n\t\telse\n\t\t\tphydev->mdix_ctrl = ETH_TP_MDI;\n\n\tret = phy_read_mmd(phydev, MDIO_MMD_PMAPMD, PHY_PMA_MGBT_POLARITY);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif ((ret & PHY_MDI_MDI_X_MASK) < PHY_MDI_MDI_X_NORMAL)\n\t\tphydev->mdix = ETH_TP_MDI_X;\n\telse\n\t\tphydev->mdix = ETH_TP_MDI;\n\n\treturn 0;\n}\n\nstatic int gpy_update_interface(struct phy_device *phydev)\n{\n\tint ret;\n\n\t \n\tif (phydev->interface == PHY_INTERFACE_MODE_USXGMII ||\n\t    phydev->interface == PHY_INTERFACE_MODE_INTERNAL)\n\t\treturn -EINVAL;\n\n\t \n\tswitch (phydev->speed) {\n\tcase SPEED_2500:\n\t\tphydev->interface = PHY_INTERFACE_MODE_2500BASEX;\n\t\tret = phy_modify_mmd(phydev, MDIO_MMD_VEND1, VSPEC1_SGMII_CTRL,\n\t\t\t\t     VSPEC1_SGMII_CTRL_ANEN, 0);\n\t\tif (ret < 0) {\n\t\t\tphydev_err(phydev,\n\t\t\t\t   \"Error: Disable of SGMII ANEG failed: %d\\n\",\n\t\t\t\t   ret);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase SPEED_1000:\n\tcase SPEED_100:\n\tcase SPEED_10:\n\t\tphydev->interface = PHY_INTERFACE_MODE_SGMII;\n\t\tif (gpy_sgmii_aneg_en(phydev))\n\t\t\tbreak;\n\t\t \n\t\tret = phy_modify_mmd(phydev, MDIO_MMD_VEND1, VSPEC1_SGMII_CTRL,\n\t\t\t\t     VSPEC1_SGMII_ANEN_ANRS,\n\t\t\t\t     VSPEC1_SGMII_ANEN_ANRS);\n\t\tif (ret < 0) {\n\t\t\tphydev_err(phydev,\n\t\t\t\t   \"Error: Enable of SGMII ANEG failed: %d\\n\",\n\t\t\t\t   ret);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (phydev->speed == SPEED_2500 || phydev->speed == SPEED_1000) {\n\t\tret = genphy_read_master_slave(phydev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn gpy_update_mdix(phydev);\n}\n\nstatic int gpy_read_status(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = genphy_update_link(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tphydev->speed = SPEED_UNKNOWN;\n\tphydev->duplex = DUPLEX_UNKNOWN;\n\tphydev->pause = 0;\n\tphydev->asym_pause = 0;\n\n\tif (phydev->autoneg == AUTONEG_ENABLE && phydev->autoneg_complete) {\n\t\tret = genphy_c45_read_lpa(phydev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = phy_read(phydev, MII_STAT1000);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tmii_stat1000_mod_linkmode_lpa_t(phydev->lp_advertising, ret);\n\t} else if (phydev->autoneg == AUTONEG_DISABLE) {\n\t\tlinkmode_zero(phydev->lp_advertising);\n\t}\n\n\tret = phy_read(phydev, PHY_MIISTAT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tphydev->link = (ret & PHY_MIISTAT_LS) ? 1 : 0;\n\tphydev->duplex = (ret & PHY_MIISTAT_DPX) ? DUPLEX_FULL : DUPLEX_HALF;\n\tswitch (FIELD_GET(PHY_MIISTAT_SPD_MASK, ret)) {\n\tcase PHY_MIISTAT_SPD_10:\n\t\tphydev->speed = SPEED_10;\n\t\tbreak;\n\tcase PHY_MIISTAT_SPD_100:\n\t\tphydev->speed = SPEED_100;\n\t\tbreak;\n\tcase PHY_MIISTAT_SPD_1000:\n\t\tphydev->speed = SPEED_1000;\n\t\tbreak;\n\tcase PHY_MIISTAT_SPD_2500:\n\t\tphydev->speed = SPEED_2500;\n\t\tbreak;\n\t}\n\n\tif (phydev->link) {\n\t\tret = gpy_update_interface(phydev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int gpy_config_intr(struct phy_device *phydev)\n{\n\tu16 mask = 0;\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED)\n\t\tmask = PHY_IMASK_MASK;\n\n\treturn phy_write(phydev, PHY_IMASK, mask);\n}\n\nstatic irqreturn_t gpy_handle_interrupt(struct phy_device *phydev)\n{\n\tint reg;\n\n\treg = phy_read(phydev, PHY_ISTAT);\n\tif (reg < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (!(reg & PHY_IMASK_MASK))\n\t\treturn IRQ_NONE;\n\n\t \n\tif (reg & (PHY_IMASK_LSTC | PHY_IMASK_LSPC)) {\n\t\treg = gpy_mbox_read(phydev, REG_GPIO0_OUT);\n\t\tif (reg < 0) {\n\t\t\tphy_error(phydev);\n\t\t\treturn IRQ_NONE;\n\t\t}\n\t}\n\n\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int gpy_set_wol(struct phy_device *phydev,\n\t\t       struct ethtool_wolinfo *wol)\n{\n\tstruct net_device *attach_dev = phydev->attached_dev;\n\tint ret;\n\n\tif (wol->wolopts & WAKE_MAGIC) {\n\t\t \n\t\tret = phy_set_bits_mmd(phydev, MDIO_MMD_VEND2,\n\t\t\t\t       VPSPEC2_WOL_AD45,\n\t\t\t\t       ((attach_dev->dev_addr[0] << 8) |\n\t\t\t\t       attach_dev->dev_addr[1]));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = phy_set_bits_mmd(phydev, MDIO_MMD_VEND2,\n\t\t\t\t       VPSPEC2_WOL_AD23,\n\t\t\t\t       ((attach_dev->dev_addr[2] << 8) |\n\t\t\t\t       attach_dev->dev_addr[3]));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = phy_set_bits_mmd(phydev, MDIO_MMD_VEND2,\n\t\t\t\t       VPSPEC2_WOL_AD01,\n\t\t\t\t       ((attach_dev->dev_addr[4] << 8) |\n\t\t\t\t       attach_dev->dev_addr[5]));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = phy_write(phydev, PHY_IMASK, PHY_IMASK_WOL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = phy_set_bits_mmd(phydev, MDIO_MMD_VEND2,\n\t\t\t\t       VPSPEC2_WOL_CTL,\n\t\t\t\t       WOL_EN);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = phy_read(phydev, PHY_ISTAT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\t \n\t\tret = phy_clear_bits_mmd(phydev, MDIO_MMD_VEND2,\n\t\t\t\t\t VPSPEC2_WOL_CTL,\n\t\t\t\t\t WOL_EN);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (wol->wolopts & WAKE_PHY) {\n\t\t \n\t\tret = phy_set_bits(phydev, PHY_IMASK, PHY_IMASK_LSTC);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = phy_read(phydev, PHY_ISTAT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (ret & (PHY_IMASK_MASK & ~PHY_IMASK_LSTC))\n\t\t\tphy_trigger_machine(phydev);\n\n\t\treturn 0;\n\t}\n\n\t \n\treturn phy_clear_bits(phydev, PHY_IMASK, PHY_IMASK_LSTC);\n}\n\nstatic void gpy_get_wol(struct phy_device *phydev,\n\t\t\tstruct ethtool_wolinfo *wol)\n{\n\tint ret;\n\n\twol->supported = WAKE_MAGIC | WAKE_PHY;\n\twol->wolopts = 0;\n\n\tret = phy_read_mmd(phydev, MDIO_MMD_VEND2, VPSPEC2_WOL_CTL);\n\tif (ret & WOL_EN)\n\t\twol->wolopts |= WAKE_MAGIC;\n\n\tret = phy_read(phydev, PHY_IMASK);\n\tif (ret & PHY_IMASK_LSTC)\n\t\twol->wolopts |= WAKE_PHY;\n}\n\nstatic int gpy_loopback(struct phy_device *phydev, bool enable)\n{\n\tstruct gpy_priv *priv = phydev->priv;\n\tu16 set = 0;\n\tint ret;\n\n\tif (enable) {\n\t\tu64 now = get_jiffies_64();\n\n\t\t \n\t\tif (time_before64(now, priv->lb_dis_to))\n\t\t\tmsleep(jiffies64_to_msecs(priv->lb_dis_to - now));\n\n\t\tset = BMCR_LOOPBACK;\n\t}\n\n\tret = phy_modify(phydev, MII_BMCR, BMCR_LOOPBACK, set);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tif (enable) {\n\t\t \n\t\tmsleep(100);\n\t} else {\n\t\tpriv->lb_dis_to = get_jiffies_64() + HZ * 3;\n\t}\n\n\treturn 0;\n}\n\nstatic int gpy115_loopback(struct phy_device *phydev, bool enable)\n{\n\tstruct gpy_priv *priv = phydev->priv;\n\n\tif (enable)\n\t\treturn gpy_loopback(phydev, enable);\n\n\tif (priv->fw_minor > 0x76)\n\t\treturn gpy_loopback(phydev, 0);\n\n\treturn genphy_soft_reset(phydev);\n}\n\nstatic struct phy_driver gpy_drivers[] = {\n\t{\n\t\tPHY_ID_MATCH_MODEL(PHY_ID_GPY2xx),\n\t\t.name\t\t= \"Maxlinear Ethernet GPY2xx\",\n\t\t.get_features\t= genphy_c45_pma_read_abilities,\n\t\t.config_init\t= gpy_config_init,\n\t\t.probe\t\t= gpy_probe,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= genphy_resume,\n\t\t.config_aneg\t= gpy_config_aneg,\n\t\t.aneg_done\t= genphy_c45_aneg_done,\n\t\t.read_status\t= gpy_read_status,\n\t\t.config_intr\t= gpy_config_intr,\n\t\t.handle_interrupt = gpy_handle_interrupt,\n\t\t.set_wol\t= gpy_set_wol,\n\t\t.get_wol\t= gpy_get_wol,\n\t\t.set_loopback\t= gpy_loopback,\n\t},\n\t{\n\t\t.phy_id\t\t= PHY_ID_GPY115B,\n\t\t.phy_id_mask\t= PHY_ID_GPYx15B_MASK,\n\t\t.name\t\t= \"Maxlinear Ethernet GPY115B\",\n\t\t.get_features\t= genphy_c45_pma_read_abilities,\n\t\t.config_init\t= gpy_config_init,\n\t\t.probe\t\t= gpy_probe,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= genphy_resume,\n\t\t.config_aneg\t= gpy_config_aneg,\n\t\t.aneg_done\t= genphy_c45_aneg_done,\n\t\t.read_status\t= gpy_read_status,\n\t\t.config_intr\t= gpy_config_intr,\n\t\t.handle_interrupt = gpy_handle_interrupt,\n\t\t.set_wol\t= gpy_set_wol,\n\t\t.get_wol\t= gpy_get_wol,\n\t\t.set_loopback\t= gpy115_loopback,\n\t},\n\t{\n\t\tPHY_ID_MATCH_MODEL(PHY_ID_GPY115C),\n\t\t.name\t\t= \"Maxlinear Ethernet GPY115C\",\n\t\t.get_features\t= genphy_c45_pma_read_abilities,\n\t\t.config_init\t= gpy_config_init,\n\t\t.probe\t\t= gpy_probe,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= genphy_resume,\n\t\t.config_aneg\t= gpy_config_aneg,\n\t\t.aneg_done\t= genphy_c45_aneg_done,\n\t\t.read_status\t= gpy_read_status,\n\t\t.config_intr\t= gpy_config_intr,\n\t\t.handle_interrupt = gpy_handle_interrupt,\n\t\t.set_wol\t= gpy_set_wol,\n\t\t.get_wol\t= gpy_get_wol,\n\t\t.set_loopback\t= gpy115_loopback,\n\t},\n\t{\n\t\t.phy_id\t\t= PHY_ID_GPY211B,\n\t\t.phy_id_mask\t= PHY_ID_GPY21xB_MASK,\n\t\t.name\t\t= \"Maxlinear Ethernet GPY211B\",\n\t\t.get_features\t= genphy_c45_pma_read_abilities,\n\t\t.config_init\t= gpy_config_init,\n\t\t.probe\t\t= gpy_probe,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= genphy_resume,\n\t\t.config_aneg\t= gpy_config_aneg,\n\t\t.aneg_done\t= genphy_c45_aneg_done,\n\t\t.read_status\t= gpy_read_status,\n\t\t.config_intr\t= gpy_config_intr,\n\t\t.handle_interrupt = gpy_handle_interrupt,\n\t\t.set_wol\t= gpy_set_wol,\n\t\t.get_wol\t= gpy_get_wol,\n\t\t.set_loopback\t= gpy_loopback,\n\t},\n\t{\n\t\tPHY_ID_MATCH_MODEL(PHY_ID_GPY211C),\n\t\t.name\t\t= \"Maxlinear Ethernet GPY211C\",\n\t\t.get_features\t= genphy_c45_pma_read_abilities,\n\t\t.config_init\t= gpy_config_init,\n\t\t.probe\t\t= gpy_probe,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= genphy_resume,\n\t\t.config_aneg\t= gpy_config_aneg,\n\t\t.aneg_done\t= genphy_c45_aneg_done,\n\t\t.read_status\t= gpy_read_status,\n\t\t.config_intr\t= gpy_config_intr,\n\t\t.handle_interrupt = gpy_handle_interrupt,\n\t\t.set_wol\t= gpy_set_wol,\n\t\t.get_wol\t= gpy_get_wol,\n\t\t.set_loopback\t= gpy_loopback,\n\t},\n\t{\n\t\t.phy_id\t\t= PHY_ID_GPY212B,\n\t\t.phy_id_mask\t= PHY_ID_GPY21xB_MASK,\n\t\t.name\t\t= \"Maxlinear Ethernet GPY212B\",\n\t\t.get_features\t= genphy_c45_pma_read_abilities,\n\t\t.config_init\t= gpy_config_init,\n\t\t.probe\t\t= gpy_probe,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= genphy_resume,\n\t\t.config_aneg\t= gpy_config_aneg,\n\t\t.aneg_done\t= genphy_c45_aneg_done,\n\t\t.read_status\t= gpy_read_status,\n\t\t.config_intr\t= gpy_config_intr,\n\t\t.handle_interrupt = gpy_handle_interrupt,\n\t\t.set_wol\t= gpy_set_wol,\n\t\t.get_wol\t= gpy_get_wol,\n\t\t.set_loopback\t= gpy_loopback,\n\t},\n\t{\n\t\tPHY_ID_MATCH_MODEL(PHY_ID_GPY212C),\n\t\t.name\t\t= \"Maxlinear Ethernet GPY212C\",\n\t\t.get_features\t= genphy_c45_pma_read_abilities,\n\t\t.config_init\t= gpy_config_init,\n\t\t.probe\t\t= gpy_probe,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= genphy_resume,\n\t\t.config_aneg\t= gpy_config_aneg,\n\t\t.aneg_done\t= genphy_c45_aneg_done,\n\t\t.read_status\t= gpy_read_status,\n\t\t.config_intr\t= gpy_config_intr,\n\t\t.handle_interrupt = gpy_handle_interrupt,\n\t\t.set_wol\t= gpy_set_wol,\n\t\t.get_wol\t= gpy_get_wol,\n\t\t.set_loopback\t= gpy_loopback,\n\t},\n\t{\n\t\t.phy_id\t\t= PHY_ID_GPY215B,\n\t\t.phy_id_mask\t= PHY_ID_GPYx15B_MASK,\n\t\t.name\t\t= \"Maxlinear Ethernet GPY215B\",\n\t\t.get_features\t= genphy_c45_pma_read_abilities,\n\t\t.config_init\t= gpy_config_init,\n\t\t.probe\t\t= gpy_probe,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= genphy_resume,\n\t\t.config_aneg\t= gpy_config_aneg,\n\t\t.aneg_done\t= genphy_c45_aneg_done,\n\t\t.read_status\t= gpy_read_status,\n\t\t.config_intr\t= gpy_config_intr,\n\t\t.handle_interrupt = gpy_handle_interrupt,\n\t\t.set_wol\t= gpy_set_wol,\n\t\t.get_wol\t= gpy_get_wol,\n\t\t.set_loopback\t= gpy_loopback,\n\t},\n\t{\n\t\tPHY_ID_MATCH_MODEL(PHY_ID_GPY215C),\n\t\t.name\t\t= \"Maxlinear Ethernet GPY215C\",\n\t\t.get_features\t= genphy_c45_pma_read_abilities,\n\t\t.config_init\t= gpy_config_init,\n\t\t.probe\t\t= gpy_probe,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= genphy_resume,\n\t\t.config_aneg\t= gpy_config_aneg,\n\t\t.aneg_done\t= genphy_c45_aneg_done,\n\t\t.read_status\t= gpy_read_status,\n\t\t.config_intr\t= gpy_config_intr,\n\t\t.handle_interrupt = gpy_handle_interrupt,\n\t\t.set_wol\t= gpy_set_wol,\n\t\t.get_wol\t= gpy_get_wol,\n\t\t.set_loopback\t= gpy_loopback,\n\t},\n\t{\n\t\tPHY_ID_MATCH_MODEL(PHY_ID_GPY241B),\n\t\t.name\t\t= \"Maxlinear Ethernet GPY241B\",\n\t\t.get_features\t= genphy_c45_pma_read_abilities,\n\t\t.config_init\t= gpy_config_init,\n\t\t.probe\t\t= gpy_probe,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= genphy_resume,\n\t\t.config_aneg\t= gpy_config_aneg,\n\t\t.aneg_done\t= genphy_c45_aneg_done,\n\t\t.read_status\t= gpy_read_status,\n\t\t.config_intr\t= gpy_config_intr,\n\t\t.handle_interrupt = gpy_handle_interrupt,\n\t\t.set_wol\t= gpy_set_wol,\n\t\t.get_wol\t= gpy_get_wol,\n\t\t.set_loopback\t= gpy_loopback,\n\t},\n\t{\n\t\tPHY_ID_MATCH_MODEL(PHY_ID_GPY241BM),\n\t\t.name\t\t= \"Maxlinear Ethernet GPY241BM\",\n\t\t.get_features\t= genphy_c45_pma_read_abilities,\n\t\t.config_init\t= gpy_config_init,\n\t\t.probe\t\t= gpy_probe,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= genphy_resume,\n\t\t.config_aneg\t= gpy_config_aneg,\n\t\t.aneg_done\t= genphy_c45_aneg_done,\n\t\t.read_status\t= gpy_read_status,\n\t\t.config_intr\t= gpy_config_intr,\n\t\t.handle_interrupt = gpy_handle_interrupt,\n\t\t.set_wol\t= gpy_set_wol,\n\t\t.get_wol\t= gpy_get_wol,\n\t\t.set_loopback\t= gpy_loopback,\n\t},\n\t{\n\t\tPHY_ID_MATCH_MODEL(PHY_ID_GPY245B),\n\t\t.name\t\t= \"Maxlinear Ethernet GPY245B\",\n\t\t.get_features\t= genphy_c45_pma_read_abilities,\n\t\t.config_init\t= gpy_config_init,\n\t\t.probe\t\t= gpy_probe,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= genphy_resume,\n\t\t.config_aneg\t= gpy_config_aneg,\n\t\t.aneg_done\t= genphy_c45_aneg_done,\n\t\t.read_status\t= gpy_read_status,\n\t\t.config_intr\t= gpy_config_intr,\n\t\t.handle_interrupt = gpy_handle_interrupt,\n\t\t.set_wol\t= gpy_set_wol,\n\t\t.get_wol\t= gpy_get_wol,\n\t\t.set_loopback\t= gpy_loopback,\n\t},\n};\nmodule_phy_driver(gpy_drivers);\n\nstatic struct mdio_device_id __maybe_unused gpy_tbl[] = {\n\t{PHY_ID_MATCH_MODEL(PHY_ID_GPY2xx)},\n\t{PHY_ID_GPY115B, PHY_ID_GPYx15B_MASK},\n\t{PHY_ID_MATCH_MODEL(PHY_ID_GPY115C)},\n\t{PHY_ID_GPY211B, PHY_ID_GPY21xB_MASK},\n\t{PHY_ID_MATCH_MODEL(PHY_ID_GPY211C)},\n\t{PHY_ID_GPY212B, PHY_ID_GPY21xB_MASK},\n\t{PHY_ID_MATCH_MODEL(PHY_ID_GPY212C)},\n\t{PHY_ID_GPY215B, PHY_ID_GPYx15B_MASK},\n\t{PHY_ID_MATCH_MODEL(PHY_ID_GPY215C)},\n\t{PHY_ID_MATCH_MODEL(PHY_ID_GPY241B)},\n\t{PHY_ID_MATCH_MODEL(PHY_ID_GPY241BM)},\n\t{PHY_ID_MATCH_MODEL(PHY_ID_GPY245B)},\n\t{ }\n};\nMODULE_DEVICE_TABLE(mdio, gpy_tbl);\n\nMODULE_DESCRIPTION(\"Maxlinear Ethernet GPY Driver\");\nMODULE_AUTHOR(\"Xu Liang\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}