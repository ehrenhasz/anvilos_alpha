{
  "module_name": "phy-core.c",
  "hash_id": "87ebb2d1020566ac2e01a814a3b1a80062bb3ddb6aa40b4499af216f0f988c5c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/phy-core.c",
  "human_readable_source": "\n \n#include <linux/export.h>\n#include <linux/phy.h>\n#include <linux/of.h>\n\n \nconst char *phy_speed_to_str(int speed)\n{\n\tBUILD_BUG_ON_MSG(__ETHTOOL_LINK_MODE_MASK_NBITS != 102,\n\t\t\"Enum ethtool_link_mode_bit_indices and phylib are out of sync. \"\n\t\t\"If a speed or mode has been added please update phy_speed_to_str \"\n\t\t\"and the PHY settings array.\\n\");\n\n\tswitch (speed) {\n\tcase SPEED_10:\n\t\treturn \"10Mbps\";\n\tcase SPEED_100:\n\t\treturn \"100Mbps\";\n\tcase SPEED_1000:\n\t\treturn \"1Gbps\";\n\tcase SPEED_2500:\n\t\treturn \"2.5Gbps\";\n\tcase SPEED_5000:\n\t\treturn \"5Gbps\";\n\tcase SPEED_10000:\n\t\treturn \"10Gbps\";\n\tcase SPEED_14000:\n\t\treturn \"14Gbps\";\n\tcase SPEED_20000:\n\t\treturn \"20Gbps\";\n\tcase SPEED_25000:\n\t\treturn \"25Gbps\";\n\tcase SPEED_40000:\n\t\treturn \"40Gbps\";\n\tcase SPEED_50000:\n\t\treturn \"50Gbps\";\n\tcase SPEED_56000:\n\t\treturn \"56Gbps\";\n\tcase SPEED_100000:\n\t\treturn \"100Gbps\";\n\tcase SPEED_200000:\n\t\treturn \"200Gbps\";\n\tcase SPEED_400000:\n\t\treturn \"400Gbps\";\n\tcase SPEED_800000:\n\t\treturn \"800Gbps\";\n\tcase SPEED_UNKNOWN:\n\t\treturn \"Unknown\";\n\tdefault:\n\t\treturn \"Unsupported (update phy-core.c)\";\n\t}\n}\nEXPORT_SYMBOL_GPL(phy_speed_to_str);\n\n \nconst char *phy_duplex_to_str(unsigned int duplex)\n{\n\tif (duplex == DUPLEX_HALF)\n\t\treturn \"Half\";\n\tif (duplex == DUPLEX_FULL)\n\t\treturn \"Full\";\n\tif (duplex == DUPLEX_UNKNOWN)\n\t\treturn \"Unknown\";\n\treturn \"Unsupported (update phy-core.c)\";\n}\nEXPORT_SYMBOL_GPL(phy_duplex_to_str);\n\n \nconst char *phy_rate_matching_to_str(int rate_matching)\n{\n\tswitch (rate_matching) {\n\tcase RATE_MATCH_NONE:\n\t\treturn \"none\";\n\tcase RATE_MATCH_PAUSE:\n\t\treturn \"pause\";\n\tcase RATE_MATCH_CRS:\n\t\treturn \"crs\";\n\tcase RATE_MATCH_OPEN_LOOP:\n\t\treturn \"open-loop\";\n\t}\n\treturn \"Unsupported (update phy-core.c)\";\n}\nEXPORT_SYMBOL_GPL(phy_rate_matching_to_str);\n\n \nint phy_interface_num_ports(phy_interface_t interface)\n{\n\tswitch (interface) {\n\tcase PHY_INTERFACE_MODE_NA:\n\t\treturn 0;\n\tcase PHY_INTERFACE_MODE_INTERNAL:\n\tcase PHY_INTERFACE_MODE_MII:\n\tcase PHY_INTERFACE_MODE_GMII:\n\tcase PHY_INTERFACE_MODE_TBI:\n\tcase PHY_INTERFACE_MODE_REVMII:\n\tcase PHY_INTERFACE_MODE_RMII:\n\tcase PHY_INTERFACE_MODE_REVRMII:\n\tcase PHY_INTERFACE_MODE_RGMII:\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\tcase PHY_INTERFACE_MODE_RTBI:\n\tcase PHY_INTERFACE_MODE_XGMII:\n\tcase PHY_INTERFACE_MODE_XLGMII:\n\tcase PHY_INTERFACE_MODE_MOCA:\n\tcase PHY_INTERFACE_MODE_TRGMII:\n\tcase PHY_INTERFACE_MODE_USXGMII:\n\tcase PHY_INTERFACE_MODE_SGMII:\n\tcase PHY_INTERFACE_MODE_SMII:\n\tcase PHY_INTERFACE_MODE_1000BASEX:\n\tcase PHY_INTERFACE_MODE_2500BASEX:\n\tcase PHY_INTERFACE_MODE_5GBASER:\n\tcase PHY_INTERFACE_MODE_10GBASER:\n\tcase PHY_INTERFACE_MODE_25GBASER:\n\tcase PHY_INTERFACE_MODE_10GKR:\n\tcase PHY_INTERFACE_MODE_100BASEX:\n\tcase PHY_INTERFACE_MODE_RXAUI:\n\tcase PHY_INTERFACE_MODE_XAUI:\n\tcase PHY_INTERFACE_MODE_1000BASEKX:\n\t\treturn 1;\n\tcase PHY_INTERFACE_MODE_QSGMII:\n\tcase PHY_INTERFACE_MODE_QUSGMII:\n\t\treturn 4;\n\tcase PHY_INTERFACE_MODE_PSGMII:\n\t\treturn 5;\n\tcase PHY_INTERFACE_MODE_MAX:\n\t\tWARN_ONCE(1, \"PHY_INTERFACE_MODE_MAX isn't a valid interface mode\");\n\t\treturn 0;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(phy_interface_num_ports);\n\n \n\n#define PHY_SETTING(s, d, b) { .speed = SPEED_ ## s, .duplex = DUPLEX_ ## d, \\\n\t\t\t       .bit = ETHTOOL_LINK_MODE_ ## b ## _BIT}\n\nstatic const struct phy_setting settings[] = {\n\t \n\tPHY_SETTING( 800000, FULL, 800000baseCR8_Full\t\t),\n\tPHY_SETTING( 800000, FULL, 800000baseKR8_Full\t\t),\n\tPHY_SETTING( 800000, FULL, 800000baseDR8_Full\t\t),\n\tPHY_SETTING( 800000, FULL, 800000baseDR8_2_Full\t\t),\n\tPHY_SETTING( 800000, FULL, 800000baseSR8_Full\t\t),\n\tPHY_SETTING( 800000, FULL, 800000baseVR8_Full\t\t),\n\t \n\tPHY_SETTING( 400000, FULL, 400000baseCR8_Full\t\t),\n\tPHY_SETTING( 400000, FULL, 400000baseKR8_Full\t\t),\n\tPHY_SETTING( 400000, FULL, 400000baseLR8_ER8_FR8_Full\t),\n\tPHY_SETTING( 400000, FULL, 400000baseDR8_Full\t\t),\n\tPHY_SETTING( 400000, FULL, 400000baseSR8_Full\t\t),\n\tPHY_SETTING( 400000, FULL, 400000baseCR4_Full\t\t),\n\tPHY_SETTING( 400000, FULL, 400000baseKR4_Full\t\t),\n\tPHY_SETTING( 400000, FULL, 400000baseLR4_ER4_FR4_Full\t),\n\tPHY_SETTING( 400000, FULL, 400000baseDR4_Full\t\t),\n\tPHY_SETTING( 400000, FULL, 400000baseSR4_Full\t\t),\n\t \n\tPHY_SETTING( 200000, FULL, 200000baseCR4_Full\t\t),\n\tPHY_SETTING( 200000, FULL, 200000baseKR4_Full\t\t),\n\tPHY_SETTING( 200000, FULL, 200000baseLR4_ER4_FR4_Full\t),\n\tPHY_SETTING( 200000, FULL, 200000baseDR4_Full\t\t),\n\tPHY_SETTING( 200000, FULL, 200000baseSR4_Full\t\t),\n\tPHY_SETTING( 200000, FULL, 200000baseCR2_Full\t\t),\n\tPHY_SETTING( 200000, FULL, 200000baseKR2_Full\t\t),\n\tPHY_SETTING( 200000, FULL, 200000baseLR2_ER2_FR2_Full\t),\n\tPHY_SETTING( 200000, FULL, 200000baseDR2_Full\t\t),\n\tPHY_SETTING( 200000, FULL, 200000baseSR2_Full\t\t),\n\t \n\tPHY_SETTING( 100000, FULL, 100000baseCR4_Full\t\t),\n\tPHY_SETTING( 100000, FULL, 100000baseKR4_Full\t\t),\n\tPHY_SETTING( 100000, FULL, 100000baseLR4_ER4_Full\t),\n\tPHY_SETTING( 100000, FULL, 100000baseSR4_Full\t\t),\n\tPHY_SETTING( 100000, FULL, 100000baseCR2_Full\t\t),\n\tPHY_SETTING( 100000, FULL, 100000baseKR2_Full\t\t),\n\tPHY_SETTING( 100000, FULL, 100000baseLR2_ER2_FR2_Full\t),\n\tPHY_SETTING( 100000, FULL, 100000baseDR2_Full\t\t),\n\tPHY_SETTING( 100000, FULL, 100000baseSR2_Full\t\t),\n\tPHY_SETTING( 100000, FULL, 100000baseCR_Full\t\t),\n\tPHY_SETTING( 100000, FULL, 100000baseKR_Full\t\t),\n\tPHY_SETTING( 100000, FULL, 100000baseLR_ER_FR_Full\t),\n\tPHY_SETTING( 100000, FULL, 100000baseDR_Full\t\t),\n\tPHY_SETTING( 100000, FULL, 100000baseSR_Full\t\t),\n\t \n\tPHY_SETTING(  56000, FULL,  56000baseCR4_Full\t  \t),\n\tPHY_SETTING(  56000, FULL,  56000baseKR4_Full\t  \t),\n\tPHY_SETTING(  56000, FULL,  56000baseLR4_Full\t  \t),\n\tPHY_SETTING(  56000, FULL,  56000baseSR4_Full\t  \t),\n\t \n\tPHY_SETTING(  50000, FULL,  50000baseCR2_Full\t\t),\n\tPHY_SETTING(  50000, FULL,  50000baseKR2_Full\t\t),\n\tPHY_SETTING(  50000, FULL,  50000baseSR2_Full\t\t),\n\tPHY_SETTING(  50000, FULL,  50000baseCR_Full\t\t),\n\tPHY_SETTING(  50000, FULL,  50000baseKR_Full\t\t),\n\tPHY_SETTING(  50000, FULL,  50000baseLR_ER_FR_Full\t),\n\tPHY_SETTING(  50000, FULL,  50000baseDR_Full\t\t),\n\tPHY_SETTING(  50000, FULL,  50000baseSR_Full\t\t),\n\t \n\tPHY_SETTING(  40000, FULL,  40000baseCR4_Full\t\t),\n\tPHY_SETTING(  40000, FULL,  40000baseKR4_Full\t\t),\n\tPHY_SETTING(  40000, FULL,  40000baseLR4_Full\t\t),\n\tPHY_SETTING(  40000, FULL,  40000baseSR4_Full\t\t),\n\t \n\tPHY_SETTING(  25000, FULL,  25000baseCR_Full\t\t),\n\tPHY_SETTING(  25000, FULL,  25000baseKR_Full\t\t),\n\tPHY_SETTING(  25000, FULL,  25000baseSR_Full\t\t),\n\t \n\tPHY_SETTING(  20000, FULL,  20000baseKR2_Full\t\t),\n\tPHY_SETTING(  20000, FULL,  20000baseMLD2_Full\t\t),\n\t \n\tPHY_SETTING(  10000, FULL,  10000baseCR_Full\t\t),\n\tPHY_SETTING(  10000, FULL,  10000baseER_Full\t\t),\n\tPHY_SETTING(  10000, FULL,  10000baseKR_Full\t\t),\n\tPHY_SETTING(  10000, FULL,  10000baseKX4_Full\t\t),\n\tPHY_SETTING(  10000, FULL,  10000baseLR_Full\t\t),\n\tPHY_SETTING(  10000, FULL,  10000baseLRM_Full\t\t),\n\tPHY_SETTING(  10000, FULL,  10000baseR_FEC\t\t),\n\tPHY_SETTING(  10000, FULL,  10000baseSR_Full\t\t),\n\tPHY_SETTING(  10000, FULL,  10000baseT_Full\t\t),\n\t \n\tPHY_SETTING(   5000, FULL,   5000baseT_Full\t\t),\n\t \n\tPHY_SETTING(   2500, FULL,   2500baseT_Full\t\t),\n\tPHY_SETTING(   2500, FULL,   2500baseX_Full\t\t),\n\t \n\tPHY_SETTING(   1000, FULL,   1000baseT_Full\t\t),\n\tPHY_SETTING(   1000, HALF,   1000baseT_Half\t\t),\n\tPHY_SETTING(   1000, FULL,   1000baseT1_Full\t\t),\n\tPHY_SETTING(   1000, FULL,   1000baseX_Full\t\t),\n\tPHY_SETTING(   1000, FULL,   1000baseKX_Full\t\t),\n\t \n\tPHY_SETTING(    100, FULL,    100baseT_Full\t\t),\n\tPHY_SETTING(    100, FULL,    100baseT1_Full\t\t),\n\tPHY_SETTING(    100, HALF,    100baseT_Half\t\t),\n\tPHY_SETTING(    100, HALF,    100baseFX_Half\t\t),\n\tPHY_SETTING(    100, FULL,    100baseFX_Full\t\t),\n\t \n\tPHY_SETTING(     10, FULL,     10baseT_Full\t\t),\n\tPHY_SETTING(     10, HALF,     10baseT_Half\t\t),\n\tPHY_SETTING(     10, FULL,     10baseT1L_Full\t\t),\n\tPHY_SETTING(     10, FULL,     10baseT1S_Full\t\t),\n\tPHY_SETTING(     10, HALF,     10baseT1S_Half\t\t),\n\tPHY_SETTING(     10, HALF,     10baseT1S_P2MP_Half\t),\n};\n#undef PHY_SETTING\n\n \nconst struct phy_setting *\nphy_lookup_setting(int speed, int duplex, const unsigned long *mask, bool exact)\n{\n\tconst struct phy_setting *p, *match = NULL, *last = NULL;\n\tint i;\n\n\tfor (i = 0, p = settings; i < ARRAY_SIZE(settings); i++, p++) {\n\t\tif (p->bit < __ETHTOOL_LINK_MODE_MASK_NBITS &&\n\t\t    test_bit(p->bit, mask)) {\n\t\t\tlast = p;\n\t\t\tif (p->speed == speed && p->duplex == duplex) {\n\t\t\t\t \n\t\t\t\tmatch = p;\n\t\t\t\tbreak;\n\t\t\t} else if (!exact) {\n\t\t\t\tif (!match && p->speed <= speed)\n\t\t\t\t\t \n\t\t\t\t\tmatch = p;\n\n\t\t\t\tif (p->speed < speed)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!match && !exact)\n\t\tmatch = last;\n\n\treturn match;\n}\nEXPORT_SYMBOL_GPL(phy_lookup_setting);\n\nsize_t phy_speeds(unsigned int *speeds, size_t size,\n\t\t  unsigned long *mask)\n{\n\tsize_t count;\n\tint i;\n\n\tfor (i = 0, count = 0; i < ARRAY_SIZE(settings) && count < size; i++)\n\t\tif (settings[i].bit < __ETHTOOL_LINK_MODE_MASK_NBITS &&\n\t\t    test_bit(settings[i].bit, mask) &&\n\t\t    (count == 0 || speeds[count - 1] != settings[i].speed))\n\t\t\tspeeds[count++] = settings[i].speed;\n\n\treturn count;\n}\n\nstatic void __set_linkmode_max_speed(u32 max_speed, unsigned long *addr)\n{\n\tconst struct phy_setting *p;\n\tint i;\n\n\tfor (i = 0, p = settings; i < ARRAY_SIZE(settings); i++, p++) {\n\t\tif (p->speed > max_speed)\n\t\t\tlinkmode_clear_bit(p->bit, addr);\n\t\telse\n\t\t\tbreak;\n\t}\n}\n\nstatic void __set_phy_supported(struct phy_device *phydev, u32 max_speed)\n{\n\t__set_linkmode_max_speed(max_speed, phydev->supported);\n}\n\n \nvoid phy_set_max_speed(struct phy_device *phydev, u32 max_speed)\n{\n\t__set_phy_supported(phydev, max_speed);\n\n\tphy_advertise_supported(phydev);\n}\nEXPORT_SYMBOL(phy_set_max_speed);\n\nvoid of_set_phy_supported(struct phy_device *phydev)\n{\n\tstruct device_node *node = phydev->mdio.dev.of_node;\n\tu32 max_speed;\n\n\tif (!IS_ENABLED(CONFIG_OF_MDIO))\n\t\treturn;\n\n\tif (!node)\n\t\treturn;\n\n\tif (!of_property_read_u32(node, \"max-speed\", &max_speed))\n\t\t__set_phy_supported(phydev, max_speed);\n}\n\nvoid of_set_phy_eee_broken(struct phy_device *phydev)\n{\n\tstruct device_node *node = phydev->mdio.dev.of_node;\n\tu32 broken = 0;\n\n\tif (!IS_ENABLED(CONFIG_OF_MDIO))\n\t\treturn;\n\n\tif (!node)\n\t\treturn;\n\n\tif (of_property_read_bool(node, \"eee-broken-100tx\"))\n\t\tbroken |= MDIO_EEE_100TX;\n\tif (of_property_read_bool(node, \"eee-broken-1000t\"))\n\t\tbroken |= MDIO_EEE_1000T;\n\tif (of_property_read_bool(node, \"eee-broken-10gt\"))\n\t\tbroken |= MDIO_EEE_10GT;\n\tif (of_property_read_bool(node, \"eee-broken-1000kx\"))\n\t\tbroken |= MDIO_EEE_1000KX;\n\tif (of_property_read_bool(node, \"eee-broken-10gkx4\"))\n\t\tbroken |= MDIO_EEE_10GKX4;\n\tif (of_property_read_bool(node, \"eee-broken-10gkr\"))\n\t\tbroken |= MDIO_EEE_10GKR;\n\n\tphydev->eee_broken_modes = broken;\n}\n\n \n\nvoid phy_resolve_aneg_pause(struct phy_device *phydev)\n{\n\tif (phydev->duplex == DUPLEX_FULL) {\n\t\tphydev->pause = linkmode_test_bit(ETHTOOL_LINK_MODE_Pause_BIT,\n\t\t\t\t\t\t  phydev->lp_advertising);\n\t\tphydev->asym_pause = linkmode_test_bit(\n\t\t\tETHTOOL_LINK_MODE_Asym_Pause_BIT,\n\t\t\tphydev->lp_advertising);\n\t}\n}\nEXPORT_SYMBOL_GPL(phy_resolve_aneg_pause);\n\n \nvoid phy_resolve_aneg_linkmode(struct phy_device *phydev)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(common);\n\tint i;\n\n\tlinkmode_and(common, phydev->lp_advertising, phydev->advertising);\n\n\tfor (i = 0; i < ARRAY_SIZE(settings); i++)\n\t\tif (test_bit(settings[i].bit, common)) {\n\t\t\tphydev->speed = settings[i].speed;\n\t\t\tphydev->duplex = settings[i].duplex;\n\t\t\tbreak;\n\t\t}\n\n\tphy_resolve_aneg_pause(phydev);\n}\nEXPORT_SYMBOL_GPL(phy_resolve_aneg_linkmode);\n\n \nvoid phy_check_downshift(struct phy_device *phydev)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(common);\n\tint i, speed = SPEED_UNKNOWN;\n\n\tphydev->downshifted_rate = 0;\n\n\tif (phydev->autoneg == AUTONEG_DISABLE ||\n\t    phydev->speed == SPEED_UNKNOWN)\n\t\treturn;\n\n\tlinkmode_and(common, phydev->lp_advertising, phydev->advertising);\n\n\tfor (i = 0; i < ARRAY_SIZE(settings); i++)\n\t\tif (test_bit(settings[i].bit, common)) {\n\t\t\tspeed = settings[i].speed;\n\t\t\tbreak;\n\t\t}\n\n\tif (speed == SPEED_UNKNOWN || phydev->speed >= speed)\n\t\treturn;\n\n\tphydev_warn(phydev, \"Downshift occurred from negotiated speed %s to actual speed %s, check cabling!\\n\",\n\t\t    phy_speed_to_str(speed), phy_speed_to_str(phydev->speed));\n\n\tphydev->downshifted_rate = 1;\n}\nEXPORT_SYMBOL_GPL(phy_check_downshift);\n\nstatic int phy_resolve_min_speed(struct phy_device *phydev, bool fdx_only)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(common);\n\tint i = ARRAY_SIZE(settings);\n\n\tlinkmode_and(common, phydev->lp_advertising, phydev->advertising);\n\n\twhile (--i >= 0) {\n\t\tif (test_bit(settings[i].bit, common)) {\n\t\t\tif (fdx_only && settings[i].duplex != DUPLEX_FULL)\n\t\t\t\tcontinue;\n\t\t\treturn settings[i].speed;\n\t\t}\n\t}\n\n\treturn SPEED_UNKNOWN;\n}\n\nint phy_speed_down_core(struct phy_device *phydev)\n{\n\tint min_common_speed = phy_resolve_min_speed(phydev, true);\n\n\tif (min_common_speed == SPEED_UNKNOWN)\n\t\treturn -EINVAL;\n\n\t__set_linkmode_max_speed(min_common_speed, phydev->advertising);\n\n\treturn 0;\n}\n\nstatic void mmd_phy_indirect(struct mii_bus *bus, int phy_addr, int devad,\n\t\t\t     u16 regnum)\n{\n\t \n\t__mdiobus_write(bus, phy_addr, MII_MMD_CTRL, devad);\n\n\t \n\t__mdiobus_write(bus, phy_addr, MII_MMD_DATA, regnum);\n\n\t \n\t__mdiobus_write(bus, phy_addr, MII_MMD_CTRL,\n\t\t\tdevad | MII_MMD_CTRL_NOINCR);\n}\n\n \nint __phy_read_mmd(struct phy_device *phydev, int devad, u32 regnum)\n{\n\tint val;\n\n\tif (regnum > (u16)~0 || devad > 32)\n\t\treturn -EINVAL;\n\n\tif (phydev->drv && phydev->drv->read_mmd) {\n\t\tval = phydev->drv->read_mmd(phydev, devad, regnum);\n\t} else if (phydev->is_c45) {\n\t\tval = __mdiobus_c45_read(phydev->mdio.bus, phydev->mdio.addr,\n\t\t\t\t\t devad, regnum);\n\t} else {\n\t\tstruct mii_bus *bus = phydev->mdio.bus;\n\t\tint phy_addr = phydev->mdio.addr;\n\n\t\tmmd_phy_indirect(bus, phy_addr, devad, regnum);\n\n\t\t \n\t\tval = __mdiobus_read(bus, phy_addr, MII_MMD_DATA);\n\t}\n\treturn val;\n}\nEXPORT_SYMBOL(__phy_read_mmd);\n\n \nint phy_read_mmd(struct phy_device *phydev, int devad, u32 regnum)\n{\n\tint ret;\n\n\tphy_lock_mdio_bus(phydev);\n\tret = __phy_read_mmd(phydev, devad, regnum);\n\tphy_unlock_mdio_bus(phydev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(phy_read_mmd);\n\n \nint __phy_write_mmd(struct phy_device *phydev, int devad, u32 regnum, u16 val)\n{\n\tint ret;\n\n\tif (regnum > (u16)~0 || devad > 32)\n\t\treturn -EINVAL;\n\n\tif (phydev->drv && phydev->drv->write_mmd) {\n\t\tret = phydev->drv->write_mmd(phydev, devad, regnum, val);\n\t} else if (phydev->is_c45) {\n\t\tret = __mdiobus_c45_write(phydev->mdio.bus, phydev->mdio.addr,\n\t\t\t\t\t  devad, regnum, val);\n\t} else {\n\t\tstruct mii_bus *bus = phydev->mdio.bus;\n\t\tint phy_addr = phydev->mdio.addr;\n\n\t\tmmd_phy_indirect(bus, phy_addr, devad, regnum);\n\n\t\t \n\t\t__mdiobus_write(bus, phy_addr, MII_MMD_DATA, val);\n\n\t\tret = 0;\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(__phy_write_mmd);\n\n \nint phy_write_mmd(struct phy_device *phydev, int devad, u32 regnum, u16 val)\n{\n\tint ret;\n\n\tphy_lock_mdio_bus(phydev);\n\tret = __phy_write_mmd(phydev, devad, regnum, val);\n\tphy_unlock_mdio_bus(phydev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(phy_write_mmd);\n\n \nint phy_modify_changed(struct phy_device *phydev, u32 regnum, u16 mask, u16 set)\n{\n\tint ret;\n\n\tphy_lock_mdio_bus(phydev);\n\tret = __phy_modify_changed(phydev, regnum, mask, set);\n\tphy_unlock_mdio_bus(phydev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phy_modify_changed);\n\n \nint __phy_modify(struct phy_device *phydev, u32 regnum, u16 mask, u16 set)\n{\n\tint ret;\n\n\tret = __phy_modify_changed(phydev, regnum, mask, set);\n\n\treturn ret < 0 ? ret : 0;\n}\nEXPORT_SYMBOL_GPL(__phy_modify);\n\n \nint phy_modify(struct phy_device *phydev, u32 regnum, u16 mask, u16 set)\n{\n\tint ret;\n\n\tphy_lock_mdio_bus(phydev);\n\tret = __phy_modify(phydev, regnum, mask, set);\n\tphy_unlock_mdio_bus(phydev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phy_modify);\n\n \nint __phy_modify_mmd_changed(struct phy_device *phydev, int devad, u32 regnum,\n\t\t\t     u16 mask, u16 set)\n{\n\tint new, ret;\n\n\tret = __phy_read_mmd(phydev, devad, regnum);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnew = (ret & ~mask) | set;\n\tif (new == ret)\n\t\treturn 0;\n\n\tret = __phy_write_mmd(phydev, devad, regnum, new);\n\n\treturn ret < 0 ? ret : 1;\n}\nEXPORT_SYMBOL_GPL(__phy_modify_mmd_changed);\n\n \nint phy_modify_mmd_changed(struct phy_device *phydev, int devad, u32 regnum,\n\t\t\t   u16 mask, u16 set)\n{\n\tint ret;\n\n\tphy_lock_mdio_bus(phydev);\n\tret = __phy_modify_mmd_changed(phydev, devad, regnum, mask, set);\n\tphy_unlock_mdio_bus(phydev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phy_modify_mmd_changed);\n\n \nint __phy_modify_mmd(struct phy_device *phydev, int devad, u32 regnum,\n\t\t     u16 mask, u16 set)\n{\n\tint ret;\n\n\tret = __phy_modify_mmd_changed(phydev, devad, regnum, mask, set);\n\n\treturn ret < 0 ? ret : 0;\n}\nEXPORT_SYMBOL_GPL(__phy_modify_mmd);\n\n \nint phy_modify_mmd(struct phy_device *phydev, int devad, u32 regnum,\n\t\t   u16 mask, u16 set)\n{\n\tint ret;\n\n\tphy_lock_mdio_bus(phydev);\n\tret = __phy_modify_mmd(phydev, devad, regnum, mask, set);\n\tphy_unlock_mdio_bus(phydev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phy_modify_mmd);\n\nstatic int __phy_read_page(struct phy_device *phydev)\n{\n\tif (WARN_ONCE(!phydev->drv->read_page, \"read_page callback not available, PHY driver not loaded?\\n\"))\n\t\treturn -EOPNOTSUPP;\n\n\treturn phydev->drv->read_page(phydev);\n}\n\nstatic int __phy_write_page(struct phy_device *phydev, int page)\n{\n\tif (WARN_ONCE(!phydev->drv->write_page, \"write_page callback not available, PHY driver not loaded?\\n\"))\n\t\treturn -EOPNOTSUPP;\n\n\treturn phydev->drv->write_page(phydev, page);\n}\n\n \nint phy_save_page(struct phy_device *phydev)\n{\n\tphy_lock_mdio_bus(phydev);\n\treturn __phy_read_page(phydev);\n}\nEXPORT_SYMBOL_GPL(phy_save_page);\n\n \nint phy_select_page(struct phy_device *phydev, int page)\n{\n\tint ret, oldpage;\n\n\toldpage = ret = phy_save_page(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (oldpage != page) {\n\t\tret = __phy_write_page(phydev, page);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn oldpage;\n}\nEXPORT_SYMBOL_GPL(phy_select_page);\n\n \nint phy_restore_page(struct phy_device *phydev, int oldpage, int ret)\n{\n\tint r;\n\n\tif (oldpage >= 0) {\n\t\tr = __phy_write_page(phydev, oldpage);\n\n\t\t \n\t\tif (ret >= 0 && r < 0)\n\t\t\tret = r;\n\t} else {\n\t\t \n\t\tret = oldpage;\n\t}\n\n\tphy_unlock_mdio_bus(phydev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phy_restore_page);\n\n \nint phy_read_paged(struct phy_device *phydev, int page, u32 regnum)\n{\n\tint ret = 0, oldpage;\n\n\toldpage = phy_select_page(phydev, page);\n\tif (oldpage >= 0)\n\t\tret = __phy_read(phydev, regnum);\n\n\treturn phy_restore_page(phydev, oldpage, ret);\n}\nEXPORT_SYMBOL(phy_read_paged);\n\n \nint phy_write_paged(struct phy_device *phydev, int page, u32 regnum, u16 val)\n{\n\tint ret = 0, oldpage;\n\n\toldpage = phy_select_page(phydev, page);\n\tif (oldpage >= 0)\n\t\tret = __phy_write(phydev, regnum, val);\n\n\treturn phy_restore_page(phydev, oldpage, ret);\n}\nEXPORT_SYMBOL(phy_write_paged);\n\n \nint phy_modify_paged_changed(struct phy_device *phydev, int page, u32 regnum,\n\t\t\t     u16 mask, u16 set)\n{\n\tint ret = 0, oldpage;\n\n\toldpage = phy_select_page(phydev, page);\n\tif (oldpage >= 0)\n\t\tret = __phy_modify_changed(phydev, regnum, mask, set);\n\n\treturn phy_restore_page(phydev, oldpage, ret);\n}\nEXPORT_SYMBOL(phy_modify_paged_changed);\n\n \nint phy_modify_paged(struct phy_device *phydev, int page, u32 regnum,\n\t\t     u16 mask, u16 set)\n{\n\tint ret = phy_modify_paged_changed(phydev, page, regnum, mask, set);\n\n\treturn ret < 0 ? ret : 0;\n}\nEXPORT_SYMBOL(phy_modify_paged);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}