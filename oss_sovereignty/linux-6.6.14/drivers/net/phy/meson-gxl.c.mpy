{
  "module_name": "meson-gxl.c",
  "hash_id": "d9e33c8e010c14a285857ae43bd528a2d7bde5cf2743c55f7d1109d58482c846",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/meson-gxl.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/phy.h>\n#include <linux/netdevice.h>\n#include <linux/bitfield.h>\n#include <linux/smscphy.h>\n\n#define TSTCNTL\t\t20\n#define  TSTCNTL_READ\t\tBIT(15)\n#define  TSTCNTL_WRITE\t\tBIT(14)\n#define  TSTCNTL_REG_BANK_SEL\tGENMASK(12, 11)\n#define  TSTCNTL_TEST_MODE\tBIT(10)\n#define  TSTCNTL_READ_ADDRESS\tGENMASK(9, 5)\n#define  TSTCNTL_WRITE_ADDRESS\tGENMASK(4, 0)\n#define TSTREAD1\t21\n#define TSTWRITE\t23\n\n#define BANK_ANALOG_DSP\t\t0\n#define BANK_WOL\t\t1\n#define BANK_BIST\t\t3\n\n \n#define LPI_STATUS\t0xc\n#define  LPI_STATUS_RSV12\tBIT(12)\n\n \n#define FR_PLL_CONTROL\t0x1b\n#define FR_PLL_DIV0\t0x1c\n#define FR_PLL_DIV1\t0x1d\n\nstatic int meson_gxl_open_banks(struct phy_device *phydev)\n{\n\tint ret;\n\n\t \n\tret = phy_write(phydev, TSTCNTL, 0);\n\tif (ret)\n\t\treturn ret;\n\tret = phy_write(phydev, TSTCNTL, TSTCNTL_TEST_MODE);\n\tif (ret)\n\t\treturn ret;\n\tret = phy_write(phydev, TSTCNTL, 0);\n\tif (ret)\n\t\treturn ret;\n\treturn phy_write(phydev, TSTCNTL, TSTCNTL_TEST_MODE);\n}\n\nstatic void meson_gxl_close_banks(struct phy_device *phydev)\n{\n\tphy_write(phydev, TSTCNTL, 0);\n}\n\nstatic int meson_gxl_read_reg(struct phy_device *phydev,\n\t\t\t      unsigned int bank, unsigned int reg)\n{\n\tint ret;\n\n\tret = meson_gxl_open_banks(phydev);\n\tif (ret)\n\t\tgoto out;\n\n\tret = phy_write(phydev, TSTCNTL, TSTCNTL_READ |\n\t\t\tFIELD_PREP(TSTCNTL_REG_BANK_SEL, bank) |\n\t\t\tTSTCNTL_TEST_MODE |\n\t\t\tFIELD_PREP(TSTCNTL_READ_ADDRESS, reg));\n\tif (ret)\n\t\tgoto out;\n\n\tret = phy_read(phydev, TSTREAD1);\nout:\n\t \n\tmeson_gxl_close_banks(phydev);\n\treturn ret;\n}\n\nstatic int meson_gxl_write_reg(struct phy_device *phydev,\n\t\t\t       unsigned int bank, unsigned int reg,\n\t\t\t       uint16_t value)\n{\n\tint ret;\n\n\tret = meson_gxl_open_banks(phydev);\n\tif (ret)\n\t\tgoto out;\n\n\tret = phy_write(phydev, TSTWRITE, value);\n\tif (ret)\n\t\tgoto out;\n\n\tret = phy_write(phydev, TSTCNTL, TSTCNTL_WRITE |\n\t\t\tFIELD_PREP(TSTCNTL_REG_BANK_SEL, bank) |\n\t\t\tTSTCNTL_TEST_MODE |\n\t\t\tFIELD_PREP(TSTCNTL_WRITE_ADDRESS, reg));\n\nout:\n\t \n\tmeson_gxl_close_banks(phydev);\n\treturn ret;\n}\n\nstatic int meson_gxl_config_init(struct phy_device *phydev)\n{\n\tint ret;\n\n\t \n\tret = meson_gxl_write_reg(phydev, BANK_BIST, FR_PLL_CONTROL, 0x5);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = meson_gxl_write_reg(phydev, BANK_BIST, FR_PLL_DIV1, 0x029a);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = meson_gxl_write_reg(phydev, BANK_BIST, FR_PLL_DIV0, 0xaaaa);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic int meson_gxl_read_status(struct phy_device *phydev)\n{\n\tint ret, wol, lpa, exp;\n\n\tif (phydev->autoneg == AUTONEG_ENABLE) {\n\t\tret = genphy_aneg_done(phydev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (!ret)\n\t\t\tgoto read_status_continue;\n\n\t\t \n\t\twol = meson_gxl_read_reg(phydev, BANK_WOL, LPI_STATUS);\n\t\tif (wol < 0)\n\t\t\treturn wol;\n\n\t\tlpa = phy_read(phydev, MII_LPA);\n\t\tif (lpa < 0)\n\t\t\treturn lpa;\n\n\t\texp = phy_read(phydev, MII_EXPANSION);\n\t\tif (exp < 0)\n\t\t\treturn exp;\n\n\t\tif (!(wol & LPI_STATUS_RSV12) ||\n\t\t    ((exp & EXPANSION_NWAY) && !(lpa & LPA_LPACK))) {\n\t\t\t \n\t\t\tphydev_dbg(phydev, \"LPA corruption - aneg restart\\n\");\n\t\t\treturn genphy_restart_aneg(phydev);\n\t\t}\n\t}\n\nread_status_continue:\n\treturn genphy_read_status(phydev);\n}\n\nstatic struct phy_driver meson_gxl_phy[] = {\n\t{\n\t\tPHY_ID_MATCH_EXACT(0x01814400),\n\t\t.name\t\t= \"Meson GXL Internal PHY\",\n\t\t \n\t\t.flags\t\t= PHY_IS_INTERNAL,\n\t\t.soft_reset     = genphy_soft_reset,\n\t\t.config_init\t= meson_gxl_config_init,\n\t\t.read_status\t= meson_gxl_read_status,\n\t\t.config_intr\t= smsc_phy_config_intr,\n\t\t.handle_interrupt = smsc_phy_handle_interrupt,\n\t\t.suspend        = genphy_suspend,\n\t\t.resume         = genphy_resume,\n\t\t.read_mmd\t= genphy_read_mmd_unsupported,\n\t\t.write_mmd\t= genphy_write_mmd_unsupported,\n\t}, {\n\t\tPHY_ID_MATCH_EXACT(0x01803301),\n\t\t.name\t\t= \"Meson G12A Internal PHY\",\n\t\t \n\t\t.flags\t\t= PHY_IS_INTERNAL,\n\t\t.probe\t\t= smsc_phy_probe,\n\t\t.config_init\t= smsc_phy_config_init,\n\t\t.soft_reset     = genphy_soft_reset,\n\t\t.read_status\t= lan87xx_read_status,\n\t\t.config_intr\t= smsc_phy_config_intr,\n\t\t.handle_interrupt = smsc_phy_handle_interrupt,\n\n\t\t.get_tunable\t= smsc_phy_get_tunable,\n\t\t.set_tunable\t= smsc_phy_set_tunable,\n\n\t\t.suspend        = genphy_suspend,\n\t\t.resume         = genphy_resume,\n\t\t.read_mmd\t= genphy_read_mmd_unsupported,\n\t\t.write_mmd\t= genphy_write_mmd_unsupported,\n\t},\n};\n\nstatic struct mdio_device_id __maybe_unused meson_gxl_tbl[] = {\n\t{ PHY_ID_MATCH_VENDOR(0x01814400) },\n\t{ PHY_ID_MATCH_VENDOR(0x01803301) },\n\t{ }\n};\n\nmodule_phy_driver(meson_gxl_phy);\n\nMODULE_DEVICE_TABLE(mdio, meson_gxl_tbl);\n\nMODULE_DESCRIPTION(\"Amlogic Meson GXL Internal PHY driver\");\nMODULE_AUTHOR(\"Baoqi wang\");\nMODULE_AUTHOR(\"Neil Armstrong <narmstrong@baylibre.com>\");\nMODULE_AUTHOR(\"Jerome Brunet <jbrunet@baylibre.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}