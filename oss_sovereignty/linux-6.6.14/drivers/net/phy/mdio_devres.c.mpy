{
  "module_name": "mdio_devres.c",
  "hash_id": "3582539bf94e8d777b2751f4f44b8fb1b44834cdf36f09cc3fdd8887f4f9f1eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/mdio_devres.c",
  "human_readable_source": "\n\n#include <linux/device.h>\n#include <linux/of_mdio.h>\n#include <linux/phy.h>\n#include <linux/stddef.h>\n\nstruct mdiobus_devres {\n\tstruct mii_bus *mii;\n};\n\nstatic void devm_mdiobus_free(struct device *dev, void *this)\n{\n\tstruct mdiobus_devres *dr = this;\n\n\tmdiobus_free(dr->mii);\n}\n\n \nstruct mii_bus *devm_mdiobus_alloc_size(struct device *dev, int sizeof_priv)\n{\n\tstruct mdiobus_devres *dr;\n\n\tdr = devres_alloc(devm_mdiobus_free, sizeof(*dr), GFP_KERNEL);\n\tif (!dr)\n\t\treturn NULL;\n\n\tdr->mii = mdiobus_alloc_size(sizeof_priv);\n\tif (!dr->mii) {\n\t\tdevres_free(dr);\n\t\treturn NULL;\n\t}\n\n\tdevres_add(dev, dr);\n\treturn dr->mii;\n}\nEXPORT_SYMBOL(devm_mdiobus_alloc_size);\n\nstatic void devm_mdiobus_unregister(struct device *dev, void *this)\n{\n\tstruct mdiobus_devres *dr = this;\n\n\tmdiobus_unregister(dr->mii);\n}\n\nstatic int mdiobus_devres_match(struct device *dev,\n\t\t\t\tvoid *this, void *match_data)\n{\n\tstruct mdiobus_devres *res = this;\n\tstruct mii_bus *mii = match_data;\n\n\treturn mii == res->mii;\n}\n\n \nint __devm_mdiobus_register(struct device *dev, struct mii_bus *bus,\n\t\t\t    struct module *owner)\n{\n\tstruct mdiobus_devres *dr;\n\tint ret;\n\n\tif (WARN_ON(!devres_find(dev, devm_mdiobus_free,\n\t\t\t\t mdiobus_devres_match, bus)))\n\t\treturn -EINVAL;\n\n\tdr = devres_alloc(devm_mdiobus_unregister, sizeof(*dr), GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tret = __mdiobus_register(bus, owner);\n\tif (ret) {\n\t\tdevres_free(dr);\n\t\treturn ret;\n\t}\n\n\tdr->mii = bus;\n\tdevres_add(dev, dr);\n\treturn 0;\n}\nEXPORT_SYMBOL(__devm_mdiobus_register);\n\n#if IS_ENABLED(CONFIG_OF_MDIO)\n \nint __devm_of_mdiobus_register(struct device *dev, struct mii_bus *mdio,\n\t\t\t       struct device_node *np, struct module *owner)\n{\n\tstruct mdiobus_devres *dr;\n\tint ret;\n\n\tif (WARN_ON(!devres_find(dev, devm_mdiobus_free,\n\t\t\t\t mdiobus_devres_match, mdio)))\n\t\treturn -EINVAL;\n\n\tdr = devres_alloc(devm_mdiobus_unregister, sizeof(*dr), GFP_KERNEL);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tret = __of_mdiobus_register(mdio, np, owner);\n\tif (ret) {\n\t\tdevres_free(dr);\n\t\treturn ret;\n\t}\n\n\tdr->mii = mdio;\n\tdevres_add(dev, dr);\n\treturn 0;\n}\nEXPORT_SYMBOL(__devm_of_mdiobus_register);\n#endif  \n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}