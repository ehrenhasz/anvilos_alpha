{
  "module_name": "dp83640.c",
  "hash_id": "f95e2f15cd7eba752fc883e865f55e7d749c10f675b5c9b5e3fb474df3e2d1d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/dp83640.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/crc32.h>\n#include <linux/ethtool.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/mii.h>\n#include <linux/module.h>\n#include <linux/net_tstamp.h>\n#include <linux/netdevice.h>\n#include <linux/if_vlan.h>\n#include <linux/phy.h>\n#include <linux/ptp_classify.h>\n#include <linux/ptp_clock_kernel.h>\n\n#include \"dp83640_reg.h\"\n\n#define DP83640_PHY_ID\t0x20005ce1\n#define PAGESEL\t\t0x13\n#define MAX_RXTS\t64\n#define N_EXT_TS\t6\n#define N_PER_OUT\t7\n#define PSF_PTPVER\t2\n#define PSF_EVNT\t0x4000\n#define PSF_RX\t\t0x2000\n#define PSF_TX\t\t0x1000\n#define EXT_EVENT\t1\n#define CAL_EVENT\t7\n#define CAL_TRIGGER\t1\n#define DP83640_N_PINS\t12\n\n#define MII_DP83640_MICR 0x11\n#define MII_DP83640_MISR 0x12\n\n#define MII_DP83640_MICR_OE 0x1\n#define MII_DP83640_MICR_IE 0x2\n\n#define MII_DP83640_MISR_RHF_INT_EN 0x01\n#define MII_DP83640_MISR_FHF_INT_EN 0x02\n#define MII_DP83640_MISR_ANC_INT_EN 0x04\n#define MII_DP83640_MISR_DUP_INT_EN 0x08\n#define MII_DP83640_MISR_SPD_INT_EN 0x10\n#define MII_DP83640_MISR_LINK_INT_EN 0x20\n#define MII_DP83640_MISR_ED_INT_EN 0x40\n#define MII_DP83640_MISR_LQ_INT_EN 0x80\n#define MII_DP83640_MISR_ANC_INT 0x400\n#define MII_DP83640_MISR_DUP_INT 0x800\n#define MII_DP83640_MISR_SPD_INT 0x1000\n#define MII_DP83640_MISR_LINK_INT 0x2000\n#define MII_DP83640_MISR_INT_MASK (MII_DP83640_MISR_ANC_INT |\\\n\t\t\t\t   MII_DP83640_MISR_DUP_INT |\\\n\t\t\t\t   MII_DP83640_MISR_SPD_INT |\\\n\t\t\t\t   MII_DP83640_MISR_LINK_INT)\n\n \n#define ADJTIME_FIX\t16\n\n#define SKB_TIMESTAMP_TIMEOUT\t2  \n\n#if defined(__BIG_ENDIAN)\n#define ENDIAN_FLAG\t0\n#elif defined(__LITTLE_ENDIAN)\n#define ENDIAN_FLAG\tPSF_ENDIAN\n#endif\n\nstruct dp83640_skb_info {\n\tint ptp_type;\n\tunsigned long tmo;\n};\n\nstruct phy_rxts {\n\tu16 ns_lo;    \n\tu16 ns_hi;    \n\tu16 sec_lo;   \n\tu16 sec_hi;   \n\tu16 seqid;    \n\tu16 msgtype;  \n};\n\nstruct phy_txts {\n\tu16 ns_lo;    \n\tu16 ns_hi;    \n\tu16 sec_lo;   \n\tu16 sec_hi;   \n};\n\nstruct rxts {\n\tstruct list_head list;\n\tunsigned long tmo;\n\tu64 ns;\n\tu16 seqid;\n\tu8  msgtype;\n\tu16 hash;\n};\n\nstruct dp83640_clock;\n\nstruct dp83640_private {\n\tstruct list_head list;\n\tstruct dp83640_clock *clock;\n\tstruct phy_device *phydev;\n\tstruct mii_timestamper mii_ts;\n\tstruct delayed_work ts_work;\n\tint hwts_tx_en;\n\tint hwts_rx_en;\n\tint layer;\n\tint version;\n\t \n\tint cfg0;\n\t \n\tstruct phy_txts edata;\n\t \n\tstruct list_head rxts;\n\tstruct list_head rxpool;\n\tstruct rxts rx_pool_data[MAX_RXTS];\n\t \n\tspinlock_t rx_lock;\n\t \n\tstruct sk_buff_head rx_queue;\n\tstruct sk_buff_head tx_queue;\n};\n\nstruct dp83640_clock {\n\t \n\tstruct list_head list;\n\t \n\tstruct mii_bus *bus;\n\t \n\tstruct mutex extreg_lock;\n\t \n\tint page;\n\t \n\tstruct ptp_clock_info caps;\n\t \n\tstruct mutex clock_lock;\n\t \n\tstruct dp83640_private *chosen;\n\t \n\tstruct list_head phylist;\n\t \n\tstruct ptp_clock *ptp_clock;\n};\n\n \n\nenum {\n\tCALIBRATE_GPIO,\n\tPEROUT_GPIO,\n\tEXTTS0_GPIO,\n\tEXTTS1_GPIO,\n\tEXTTS2_GPIO,\n\tEXTTS3_GPIO,\n\tEXTTS4_GPIO,\n\tEXTTS5_GPIO,\n\tGPIO_TABLE_SIZE\n};\n\nstatic int chosen_phy = -1;\nstatic ushort gpio_tab[GPIO_TABLE_SIZE] = {\n\t1, 2, 3, 4, 8, 9, 10, 11\n};\n\nmodule_param(chosen_phy, int, 0444);\nmodule_param_array(gpio_tab, ushort, NULL, 0444);\n\nMODULE_PARM_DESC(chosen_phy,\n\t\"The address of the PHY to use for the ancillary clock features\");\nMODULE_PARM_DESC(gpio_tab,\n\t\"Which GPIO line to use for which purpose: cal,perout,extts1,...,extts6\");\n\nstatic void dp83640_gpio_defaults(struct ptp_pin_desc *pd)\n{\n\tint i, index;\n\n\tfor (i = 0; i < DP83640_N_PINS; i++) {\n\t\tsnprintf(pd[i].name, sizeof(pd[i].name), \"GPIO%d\", 1 + i);\n\t\tpd[i].index = i;\n\t}\n\n\tfor (i = 0; i < GPIO_TABLE_SIZE; i++) {\n\t\tif (gpio_tab[i] < 1 || gpio_tab[i] > DP83640_N_PINS) {\n\t\t\tpr_err(\"gpio_tab[%d]=%hu out of range\", i, gpio_tab[i]);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tindex = gpio_tab[CALIBRATE_GPIO] - 1;\n\tpd[index].func = PTP_PF_PHYSYNC;\n\tpd[index].chan = 0;\n\n\tindex = gpio_tab[PEROUT_GPIO] - 1;\n\tpd[index].func = PTP_PF_PEROUT;\n\tpd[index].chan = 0;\n\n\tfor (i = EXTTS0_GPIO; i < GPIO_TABLE_SIZE; i++) {\n\t\tindex = gpio_tab[i] - 1;\n\t\tpd[index].func = PTP_PF_EXTTS;\n\t\tpd[index].chan = i - EXTTS0_GPIO;\n\t}\n}\n\n \nstatic LIST_HEAD(phyter_clocks);\nstatic DEFINE_MUTEX(phyter_clocks_lock);\n\nstatic void rx_timestamp_work(struct work_struct *work);\n\n \n\n#define BROADCAST_ADDR 31\n\nstatic inline int broadcast_write(struct phy_device *phydev, u32 regnum,\n\t\t\t\t  u16 val)\n{\n\treturn mdiobus_write(phydev->mdio.bus, BROADCAST_ADDR, regnum, val);\n}\n\n \nstatic int ext_read(struct phy_device *phydev, int page, u32 regnum)\n{\n\tstruct dp83640_private *dp83640 = phydev->priv;\n\tint val;\n\n\tif (dp83640->clock->page != page) {\n\t\tbroadcast_write(phydev, PAGESEL, page);\n\t\tdp83640->clock->page = page;\n\t}\n\tval = phy_read(phydev, regnum);\n\n\treturn val;\n}\n\n \nstatic void ext_write(int broadcast, struct phy_device *phydev,\n\t\t      int page, u32 regnum, u16 val)\n{\n\tstruct dp83640_private *dp83640 = phydev->priv;\n\n\tif (dp83640->clock->page != page) {\n\t\tbroadcast_write(phydev, PAGESEL, page);\n\t\tdp83640->clock->page = page;\n\t}\n\tif (broadcast)\n\t\tbroadcast_write(phydev, regnum, val);\n\telse\n\t\tphy_write(phydev, regnum, val);\n}\n\n \nstatic int tdr_write(int bc, struct phy_device *dev,\n\t\t     const struct timespec64 *ts, u16 cmd)\n{\n\text_write(bc, dev, PAGE4, PTP_TDR, ts->tv_nsec & 0xffff); \n\text_write(bc, dev, PAGE4, PTP_TDR, ts->tv_nsec >> 16);    \n\text_write(bc, dev, PAGE4, PTP_TDR, ts->tv_sec & 0xffff);  \n\text_write(bc, dev, PAGE4, PTP_TDR, ts->tv_sec >> 16);     \n\n\text_write(bc, dev, PAGE4, PTP_CTL, cmd);\n\n\treturn 0;\n}\n\n \n\nstatic void phy2rxts(struct phy_rxts *p, struct rxts *rxts)\n{\n\tu32 sec;\n\n\tsec = p->sec_lo;\n\tsec |= p->sec_hi << 16;\n\n\trxts->ns = p->ns_lo;\n\trxts->ns |= (p->ns_hi & 0x3fff) << 16;\n\trxts->ns += ((u64)sec) * 1000000000ULL;\n\trxts->seqid = p->seqid;\n\trxts->msgtype = (p->msgtype >> 12) & 0xf;\n\trxts->hash = p->msgtype & 0x0fff;\n\trxts->tmo = jiffies + SKB_TIMESTAMP_TIMEOUT;\n}\n\nstatic u64 phy2txts(struct phy_txts *p)\n{\n\tu64 ns;\n\tu32 sec;\n\n\tsec = p->sec_lo;\n\tsec |= p->sec_hi << 16;\n\n\tns = p->ns_lo;\n\tns |= (p->ns_hi & 0x3fff) << 16;\n\tns += ((u64)sec) * 1000000000ULL;\n\n\treturn ns;\n}\n\nstatic int periodic_output(struct dp83640_clock *clock,\n\t\t\t   struct ptp_clock_request *clkreq, bool on,\n\t\t\t   int trigger)\n{\n\tstruct dp83640_private *dp83640 = clock->chosen;\n\tstruct phy_device *phydev = dp83640->phydev;\n\tu32 sec, nsec, pwidth;\n\tu16 gpio, ptp_trig, val;\n\n\tif (on) {\n\t\tgpio = 1 + ptp_find_pin(clock->ptp_clock, PTP_PF_PEROUT,\n\t\t\t\t\ttrigger);\n\t\tif (gpio < 1)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tgpio = 0;\n\t}\n\n\tptp_trig = TRIG_WR |\n\t\t(trigger & TRIG_CSEL_MASK) << TRIG_CSEL_SHIFT |\n\t\t(gpio & TRIG_GPIO_MASK) << TRIG_GPIO_SHIFT |\n\t\tTRIG_PER |\n\t\tTRIG_PULSE;\n\n\tval = (trigger & TRIG_SEL_MASK) << TRIG_SEL_SHIFT;\n\n\tif (!on) {\n\t\tval |= TRIG_DIS;\n\t\tmutex_lock(&clock->extreg_lock);\n\t\text_write(0, phydev, PAGE5, PTP_TRIG, ptp_trig);\n\t\text_write(0, phydev, PAGE4, PTP_CTL, val);\n\t\tmutex_unlock(&clock->extreg_lock);\n\t\treturn 0;\n\t}\n\n\tsec = clkreq->perout.start.sec;\n\tnsec = clkreq->perout.start.nsec;\n\tpwidth = clkreq->perout.period.sec * 1000000000UL;\n\tpwidth += clkreq->perout.period.nsec;\n\tpwidth /= 2;\n\n\tmutex_lock(&clock->extreg_lock);\n\n\text_write(0, phydev, PAGE5, PTP_TRIG, ptp_trig);\n\n\t \n\tval |= TRIG_LOAD;\n\text_write(0, phydev, PAGE4, PTP_CTL, val);\n\text_write(0, phydev, PAGE4, PTP_TDR, nsec & 0xffff);    \n\text_write(0, phydev, PAGE4, PTP_TDR, nsec >> 16);       \n\text_write(0, phydev, PAGE4, PTP_TDR, sec & 0xffff);     \n\text_write(0, phydev, PAGE4, PTP_TDR, sec >> 16);        \n\text_write(0, phydev, PAGE4, PTP_TDR, pwidth & 0xffff);  \n\text_write(0, phydev, PAGE4, PTP_TDR, pwidth >> 16);     \n\t \n\tif (trigger < 2) {\n\t\text_write(0, phydev, PAGE4, PTP_TDR, pwidth & 0xffff);\n\t\text_write(0, phydev, PAGE4, PTP_TDR, pwidth >> 16);\n\t}\n\n\t \n\tval &= ~TRIG_LOAD;\n\tval |= TRIG_EN;\n\text_write(0, phydev, PAGE4, PTP_CTL, val);\n\n\tmutex_unlock(&clock->extreg_lock);\n\treturn 0;\n}\n\n \n\nstatic int ptp_dp83640_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct dp83640_clock *clock =\n\t\tcontainer_of(ptp, struct dp83640_clock, caps);\n\tstruct phy_device *phydev = clock->chosen->phydev;\n\tu64 rate;\n\tint neg_adj = 0;\n\tu16 hi, lo;\n\n\tif (scaled_ppm < 0) {\n\t\tneg_adj = 1;\n\t\tscaled_ppm = -scaled_ppm;\n\t}\n\trate = scaled_ppm;\n\trate <<= 13;\n\trate = div_u64(rate, 15625);\n\n\thi = (rate >> 16) & PTP_RATE_HI_MASK;\n\tif (neg_adj)\n\t\thi |= PTP_RATE_DIR;\n\n\tlo = rate & 0xffff;\n\n\tmutex_lock(&clock->extreg_lock);\n\n\text_write(1, phydev, PAGE4, PTP_RATEH, hi);\n\text_write(1, phydev, PAGE4, PTP_RATEL, lo);\n\n\tmutex_unlock(&clock->extreg_lock);\n\n\treturn 0;\n}\n\nstatic int ptp_dp83640_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct dp83640_clock *clock =\n\t\tcontainer_of(ptp, struct dp83640_clock, caps);\n\tstruct phy_device *phydev = clock->chosen->phydev;\n\tstruct timespec64 ts;\n\tint err;\n\n\tdelta += ADJTIME_FIX;\n\n\tts = ns_to_timespec64(delta);\n\n\tmutex_lock(&clock->extreg_lock);\n\n\terr = tdr_write(1, phydev, &ts, PTP_STEP_CLK);\n\n\tmutex_unlock(&clock->extreg_lock);\n\n\treturn err;\n}\n\nstatic int ptp_dp83640_gettime(struct ptp_clock_info *ptp,\n\t\t\t       struct timespec64 *ts)\n{\n\tstruct dp83640_clock *clock =\n\t\tcontainer_of(ptp, struct dp83640_clock, caps);\n\tstruct phy_device *phydev = clock->chosen->phydev;\n\tunsigned int val[4];\n\n\tmutex_lock(&clock->extreg_lock);\n\n\text_write(0, phydev, PAGE4, PTP_CTL, PTP_RD_CLK);\n\n\tval[0] = ext_read(phydev, PAGE4, PTP_TDR);  \n\tval[1] = ext_read(phydev, PAGE4, PTP_TDR);  \n\tval[2] = ext_read(phydev, PAGE4, PTP_TDR);  \n\tval[3] = ext_read(phydev, PAGE4, PTP_TDR);  \n\n\tmutex_unlock(&clock->extreg_lock);\n\n\tts->tv_nsec = val[0] | (val[1] << 16);\n\tts->tv_sec  = val[2] | (val[3] << 16);\n\n\treturn 0;\n}\n\nstatic int ptp_dp83640_settime(struct ptp_clock_info *ptp,\n\t\t\t       const struct timespec64 *ts)\n{\n\tstruct dp83640_clock *clock =\n\t\tcontainer_of(ptp, struct dp83640_clock, caps);\n\tstruct phy_device *phydev = clock->chosen->phydev;\n\tint err;\n\n\tmutex_lock(&clock->extreg_lock);\n\n\terr = tdr_write(1, phydev, ts, PTP_LOAD_CLK);\n\n\tmutex_unlock(&clock->extreg_lock);\n\n\treturn err;\n}\n\nstatic int ptp_dp83640_enable(struct ptp_clock_info *ptp,\n\t\t\t      struct ptp_clock_request *rq, int on)\n{\n\tstruct dp83640_clock *clock =\n\t\tcontainer_of(ptp, struct dp83640_clock, caps);\n\tstruct phy_device *phydev = clock->chosen->phydev;\n\tunsigned int index;\n\tu16 evnt, event_num, gpio_num;\n\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_EXTTS:\n\t\t \n\t\tif (rq->extts.flags & ~(PTP_ENABLE_FEATURE |\n\t\t\t\t\tPTP_RISING_EDGE |\n\t\t\t\t\tPTP_FALLING_EDGE |\n\t\t\t\t\tPTP_STRICT_FLAGS))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tif ((rq->extts.flags & PTP_STRICT_FLAGS) &&\n\t\t    (rq->extts.flags & PTP_ENABLE_FEATURE) &&\n\t\t    (rq->extts.flags & PTP_EXTTS_EDGES) == PTP_EXTTS_EDGES)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tindex = rq->extts.index;\n\t\tif (index >= N_EXT_TS)\n\t\t\treturn -EINVAL;\n\t\tevent_num = EXT_EVENT + index;\n\t\tevnt = EVNT_WR | (event_num & EVNT_SEL_MASK) << EVNT_SEL_SHIFT;\n\t\tif (on) {\n\t\t\tgpio_num = 1 + ptp_find_pin(clock->ptp_clock,\n\t\t\t\t\t\t    PTP_PF_EXTTS, index);\n\t\t\tif (gpio_num < 1)\n\t\t\t\treturn -EINVAL;\n\t\t\tevnt |= (gpio_num & EVNT_GPIO_MASK) << EVNT_GPIO_SHIFT;\n\t\t\tif (rq->extts.flags & PTP_FALLING_EDGE)\n\t\t\t\tevnt |= EVNT_FALL;\n\t\t\telse\n\t\t\t\tevnt |= EVNT_RISE;\n\t\t}\n\t\tmutex_lock(&clock->extreg_lock);\n\t\text_write(0, phydev, PAGE5, PTP_EVNT, evnt);\n\t\tmutex_unlock(&clock->extreg_lock);\n\t\treturn 0;\n\n\tcase PTP_CLK_REQ_PEROUT:\n\t\t \n\t\tif (rq->perout.flags)\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (rq->perout.index >= N_PER_OUT)\n\t\t\treturn -EINVAL;\n\t\treturn periodic_output(clock, rq, on, rq->perout.index);\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ptp_dp83640_verify(struct ptp_clock_info *ptp, unsigned int pin,\n\t\t\t      enum ptp_pin_function func, unsigned int chan)\n{\n\tstruct dp83640_clock *clock =\n\t\tcontainer_of(ptp, struct dp83640_clock, caps);\n\n\tif (clock->caps.pin_config[pin].func == PTP_PF_PHYSYNC &&\n\t    !list_empty(&clock->phylist))\n\t\treturn 1;\n\n\tif (func == PTP_PF_PHYSYNC)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic u8 status_frame_dst[6] = { 0x01, 0x1B, 0x19, 0x00, 0x00, 0x00 };\nstatic u8 status_frame_src[6] = { 0x08, 0x00, 0x17, 0x0B, 0x6B, 0x0F };\n\nstatic void enable_status_frames(struct phy_device *phydev, bool on)\n{\n\tstruct dp83640_private *dp83640 = phydev->priv;\n\tstruct dp83640_clock *clock = dp83640->clock;\n\tu16 cfg0 = 0, ver;\n\n\tif (on)\n\t\tcfg0 = PSF_EVNT_EN | PSF_RXTS_EN | PSF_TXTS_EN | ENDIAN_FLAG;\n\n\tver = (PSF_PTPVER & VERSIONPTP_MASK) << VERSIONPTP_SHIFT;\n\n\tmutex_lock(&clock->extreg_lock);\n\n\text_write(0, phydev, PAGE5, PSF_CFG0, cfg0);\n\text_write(0, phydev, PAGE6, PSF_CFG1, ver);\n\n\tmutex_unlock(&clock->extreg_lock);\n\n\tif (!phydev->attached_dev) {\n\t\tphydev_warn(phydev,\n\t\t\t    \"expected to find an attached netdevice\\n\");\n\t\treturn;\n\t}\n\n\tif (on) {\n\t\tif (dev_mc_add(phydev->attached_dev, status_frame_dst))\n\t\t\tphydev_warn(phydev, \"failed to add mc address\\n\");\n\t} else {\n\t\tif (dev_mc_del(phydev->attached_dev, status_frame_dst))\n\t\t\tphydev_warn(phydev, \"failed to delete mc address\\n\");\n\t}\n}\n\nstatic bool is_status_frame(struct sk_buff *skb, int type)\n{\n\tstruct ethhdr *h = eth_hdr(skb);\n\n\tif (PTP_CLASS_V2_L2 == type &&\n\t    !memcmp(h->h_source, status_frame_src, sizeof(status_frame_src)))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic int expired(struct rxts *rxts)\n{\n\treturn time_after(jiffies, rxts->tmo);\n}\n\n \nstatic void prune_rx_ts(struct dp83640_private *dp83640)\n{\n\tstruct list_head *this, *next;\n\tstruct rxts *rxts;\n\n\tlist_for_each_safe(this, next, &dp83640->rxts) {\n\t\trxts = list_entry(this, struct rxts, list);\n\t\tif (expired(rxts)) {\n\t\t\tlist_del_init(&rxts->list);\n\t\t\tlist_add(&rxts->list, &dp83640->rxpool);\n\t\t}\n\t}\n}\n\n \n\nstatic void enable_broadcast(struct phy_device *phydev, int init_page, int on)\n{\n\tint val;\n\n\tphy_write(phydev, PAGESEL, 0);\n\tval = phy_read(phydev, PHYCR2);\n\tif (on)\n\t\tval |= BC_WRITE;\n\telse\n\t\tval &= ~BC_WRITE;\n\tphy_write(phydev, PHYCR2, val);\n\tphy_write(phydev, PAGESEL, init_page);\n}\n\nstatic void recalibrate(struct dp83640_clock *clock)\n{\n\ts64 now, diff;\n\tstruct phy_txts event_ts;\n\tstruct timespec64 ts;\n\tstruct dp83640_private *tmp;\n\tstruct phy_device *master = clock->chosen->phydev;\n\tu16 cal_gpio, cfg0, evnt, ptp_trig, trigger, val;\n\n\ttrigger = CAL_TRIGGER;\n\tcal_gpio = 1 + ptp_find_pin_unlocked(clock->ptp_clock, PTP_PF_PHYSYNC, 0);\n\tif (cal_gpio < 1) {\n\t\tpr_err(\"PHY calibration pin not available - PHY is not calibrated.\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&clock->extreg_lock);\n\n\t \n\tlist_for_each_entry(tmp, &clock->phylist, list) {\n\t\tenable_broadcast(tmp->phydev, clock->page, 1);\n\t\ttmp->cfg0 = ext_read(tmp->phydev, PAGE5, PSF_CFG0);\n\t\text_write(0, tmp->phydev, PAGE5, PSF_CFG0, 0);\n\t\text_write(0, tmp->phydev, PAGE4, PTP_CTL, PTP_ENABLE);\n\t}\n\tenable_broadcast(master, clock->page, 1);\n\tcfg0 = ext_read(master, PAGE5, PSF_CFG0);\n\text_write(0, master, PAGE5, PSF_CFG0, 0);\n\text_write(0, master, PAGE4, PTP_CTL, PTP_ENABLE);\n\n\t \n\tevnt = EVNT_WR | EVNT_RISE | EVNT_SINGLE;\n\tevnt |= (CAL_EVENT & EVNT_SEL_MASK) << EVNT_SEL_SHIFT;\n\tevnt |= (cal_gpio & EVNT_GPIO_MASK) << EVNT_GPIO_SHIFT;\n\n\tlist_for_each_entry(tmp, &clock->phylist, list)\n\t\text_write(0, tmp->phydev, PAGE5, PTP_EVNT, evnt);\n\text_write(0, master, PAGE5, PTP_EVNT, evnt);\n\n\t \n\tptp_trig = TRIG_WR | TRIG_IF_LATE | TRIG_PULSE;\n\tptp_trig |= (trigger  & TRIG_CSEL_MASK) << TRIG_CSEL_SHIFT;\n\tptp_trig |= (cal_gpio & TRIG_GPIO_MASK) << TRIG_GPIO_SHIFT;\n\text_write(0, master, PAGE5, PTP_TRIG, ptp_trig);\n\n\t \n\tval = (trigger & TRIG_SEL_MASK) << TRIG_SEL_SHIFT;\n\tval |= TRIG_LOAD;\n\text_write(0, master, PAGE4, PTP_CTL, val);\n\n\t \n\tval &= ~TRIG_LOAD;\n\tval |= TRIG_EN;\n\text_write(0, master, PAGE4, PTP_CTL, val);\n\n\t \n\tval = (trigger & TRIG_SEL_MASK) << TRIG_SEL_SHIFT;\n\tval |= TRIG_DIS;\n\text_write(0, master, PAGE4, PTP_CTL, val);\n\n\t \n\tval = ext_read(master, PAGE4, PTP_STS);\n\tphydev_info(master, \"master PTP_STS  0x%04hx\\n\", val);\n\tval = ext_read(master, PAGE4, PTP_ESTS);\n\tphydev_info(master, \"master PTP_ESTS 0x%04hx\\n\", val);\n\tevent_ts.ns_lo  = ext_read(master, PAGE4, PTP_EDATA);\n\tevent_ts.ns_hi  = ext_read(master, PAGE4, PTP_EDATA);\n\tevent_ts.sec_lo = ext_read(master, PAGE4, PTP_EDATA);\n\tevent_ts.sec_hi = ext_read(master, PAGE4, PTP_EDATA);\n\tnow = phy2txts(&event_ts);\n\n\tlist_for_each_entry(tmp, &clock->phylist, list) {\n\t\tval = ext_read(tmp->phydev, PAGE4, PTP_STS);\n\t\tphydev_info(tmp->phydev, \"slave  PTP_STS  0x%04hx\\n\", val);\n\t\tval = ext_read(tmp->phydev, PAGE4, PTP_ESTS);\n\t\tphydev_info(tmp->phydev, \"slave  PTP_ESTS 0x%04hx\\n\", val);\n\t\tevent_ts.ns_lo  = ext_read(tmp->phydev, PAGE4, PTP_EDATA);\n\t\tevent_ts.ns_hi  = ext_read(tmp->phydev, PAGE4, PTP_EDATA);\n\t\tevent_ts.sec_lo = ext_read(tmp->phydev, PAGE4, PTP_EDATA);\n\t\tevent_ts.sec_hi = ext_read(tmp->phydev, PAGE4, PTP_EDATA);\n\t\tdiff = now - (s64) phy2txts(&event_ts);\n\t\tphydev_info(tmp->phydev, \"slave offset %lld nanoseconds\\n\",\n\t\t\t    diff);\n\t\tdiff += ADJTIME_FIX;\n\t\tts = ns_to_timespec64(diff);\n\t\ttdr_write(0, tmp->phydev, &ts, PTP_STEP_CLK);\n\t}\n\n\t \n\tlist_for_each_entry(tmp, &clock->phylist, list)\n\t\text_write(0, tmp->phydev, PAGE5, PSF_CFG0, tmp->cfg0);\n\text_write(0, master, PAGE5, PSF_CFG0, cfg0);\n\n\tmutex_unlock(&clock->extreg_lock);\n}\n\n \n\nstatic inline u16 exts_chan_to_edata(int ch)\n{\n\treturn 1 << ((ch + EXT_EVENT) * 2);\n}\n\nstatic int decode_evnt(struct dp83640_private *dp83640,\n\t\t       void *data, int len, u16 ests)\n{\n\tstruct phy_txts *phy_txts;\n\tstruct ptp_clock_event event;\n\tint i, parsed;\n\tint words = (ests >> EVNT_TS_LEN_SHIFT) & EVNT_TS_LEN_MASK;\n\tu16 ext_status = 0;\n\n\t \n\tif (ests & MULT_EVNT)\n\t\tparsed = (words + 2) * sizeof(u16);\n\telse\n\t\tparsed = (words + 1) * sizeof(u16);\n\n\t \n\tif (len < parsed)\n\t\treturn len;\n\n\tif (ests & MULT_EVNT) {\n\t\text_status = *(u16 *) data;\n\t\tdata += sizeof(ext_status);\n\t}\n\n\tphy_txts = data;\n\n\tswitch (words) {\n\tcase 3:\n\t\tdp83640->edata.sec_hi = phy_txts->sec_hi;\n\t\tfallthrough;\n\tcase 2:\n\t\tdp83640->edata.sec_lo = phy_txts->sec_lo;\n\t\tfallthrough;\n\tcase 1:\n\t\tdp83640->edata.ns_hi = phy_txts->ns_hi;\n\t\tfallthrough;\n\tcase 0:\n\t\tdp83640->edata.ns_lo = phy_txts->ns_lo;\n\t}\n\n\tif (!ext_status) {\n\t\ti = ((ests >> EVNT_NUM_SHIFT) & EVNT_NUM_MASK) - EXT_EVENT;\n\t\text_status = exts_chan_to_edata(i);\n\t}\n\n\tevent.type = PTP_CLOCK_EXTTS;\n\tevent.timestamp = phy2txts(&dp83640->edata);\n\n\t \n\tevent.timestamp -= 35;\n\n\tfor (i = 0; i < N_EXT_TS; i++) {\n\t\tif (ext_status & exts_chan_to_edata(i)) {\n\t\t\tevent.index = i;\n\t\t\tptp_clock_event(dp83640->clock->ptp_clock, &event);\n\t\t}\n\t}\n\n\treturn parsed;\n}\n\n#define DP83640_PACKET_HASH_LEN\t\t10\n\nstatic int match(struct sk_buff *skb, unsigned int type, struct rxts *rxts)\n{\n\tstruct ptp_header *hdr;\n\tu8 msgtype;\n\tu16 seqid;\n\tu16 hash;\n\n\t \n\n\thdr = ptp_parse_header(skb, type);\n\tif (!hdr)\n\t\treturn 0;\n\n\tmsgtype = ptp_get_msgtype(hdr, type);\n\n\tif (rxts->msgtype != (msgtype & 0xf))\n\t\treturn 0;\n\n\tseqid = be16_to_cpu(hdr->sequence_id);\n\tif (rxts->seqid != seqid)\n\t\treturn 0;\n\n\thash = ether_crc(DP83640_PACKET_HASH_LEN,\n\t\t\t (unsigned char *)&hdr->source_port_identity) >> 20;\n\tif (rxts->hash != hash)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic void decode_rxts(struct dp83640_private *dp83640,\n\t\t\tstruct phy_rxts *phy_rxts)\n{\n\tstruct rxts *rxts;\n\tstruct skb_shared_hwtstamps *shhwtstamps = NULL;\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\tu8 overflow;\n\n\toverflow = (phy_rxts->ns_hi >> 14) & 0x3;\n\tif (overflow)\n\t\tpr_debug(\"rx timestamp queue overflow, count %d\\n\", overflow);\n\n\tspin_lock_irqsave(&dp83640->rx_lock, flags);\n\n\tprune_rx_ts(dp83640);\n\n\tif (list_empty(&dp83640->rxpool)) {\n\t\tpr_debug(\"rx timestamp pool is empty\\n\");\n\t\tgoto out;\n\t}\n\trxts = list_first_entry(&dp83640->rxpool, struct rxts, list);\n\tlist_del_init(&rxts->list);\n\tphy2rxts(phy_rxts, rxts);\n\n\tspin_lock(&dp83640->rx_queue.lock);\n\tskb_queue_walk(&dp83640->rx_queue, skb) {\n\t\tstruct dp83640_skb_info *skb_info;\n\n\t\tskb_info = (struct dp83640_skb_info *)skb->cb;\n\t\tif (match(skb, skb_info->ptp_type, rxts)) {\n\t\t\t__skb_unlink(skb, &dp83640->rx_queue);\n\t\t\tshhwtstamps = skb_hwtstamps(skb);\n\t\t\tmemset(shhwtstamps, 0, sizeof(*shhwtstamps));\n\t\t\tshhwtstamps->hwtstamp = ns_to_ktime(rxts->ns);\n\t\t\tlist_add(&rxts->list, &dp83640->rxpool);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&dp83640->rx_queue.lock);\n\n\tif (!shhwtstamps)\n\t\tlist_add_tail(&rxts->list, &dp83640->rxts);\nout:\n\tspin_unlock_irqrestore(&dp83640->rx_lock, flags);\n\n\tif (shhwtstamps)\n\t\tnetif_rx(skb);\n}\n\nstatic void decode_txts(struct dp83640_private *dp83640,\n\t\t\tstruct phy_txts *phy_txts)\n{\n\tstruct skb_shared_hwtstamps shhwtstamps;\n\tstruct dp83640_skb_info *skb_info;\n\tstruct sk_buff *skb;\n\tu8 overflow;\n\tu64 ns;\n\n\t \nagain:\n\tskb = skb_dequeue(&dp83640->tx_queue);\n\tif (!skb) {\n\t\tpr_debug(\"have timestamp but tx_queue empty\\n\");\n\t\treturn;\n\t}\n\n\toverflow = (phy_txts->ns_hi >> 14) & 0x3;\n\tif (overflow) {\n\t\tpr_debug(\"tx timestamp queue overflow, count %d\\n\", overflow);\n\t\twhile (skb) {\n\t\t\tkfree_skb(skb);\n\t\t\tskb = skb_dequeue(&dp83640->tx_queue);\n\t\t}\n\t\treturn;\n\t}\n\tskb_info = (struct dp83640_skb_info *)skb->cb;\n\tif (time_after(jiffies, skb_info->tmo)) {\n\t\tkfree_skb(skb);\n\t\tgoto again;\n\t}\n\n\tns = phy2txts(phy_txts);\n\tmemset(&shhwtstamps, 0, sizeof(shhwtstamps));\n\tshhwtstamps.hwtstamp = ns_to_ktime(ns);\n\tskb_complete_tx_timestamp(skb, &shhwtstamps);\n}\n\nstatic void decode_status_frame(struct dp83640_private *dp83640,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct phy_rxts *phy_rxts;\n\tstruct phy_txts *phy_txts;\n\tu8 *ptr;\n\tint len, size;\n\tu16 ests, type;\n\n\tptr = skb->data + 2;\n\n\tfor (len = skb_headlen(skb) - 2; len > sizeof(type); len -= size) {\n\n\t\ttype = *(u16 *)ptr;\n\t\tests = type & 0x0fff;\n\t\ttype = type & 0xf000;\n\t\tlen -= sizeof(type);\n\t\tptr += sizeof(type);\n\n\t\tif (PSF_RX == type && len >= sizeof(*phy_rxts)) {\n\n\t\t\tphy_rxts = (struct phy_rxts *) ptr;\n\t\t\tdecode_rxts(dp83640, phy_rxts);\n\t\t\tsize = sizeof(*phy_rxts);\n\n\t\t} else if (PSF_TX == type && len >= sizeof(*phy_txts)) {\n\n\t\t\tphy_txts = (struct phy_txts *) ptr;\n\t\t\tdecode_txts(dp83640, phy_txts);\n\t\t\tsize = sizeof(*phy_txts);\n\n\t\t} else if (PSF_EVNT == type) {\n\n\t\t\tsize = decode_evnt(dp83640, ptr, len, ests);\n\n\t\t} else {\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\t}\n\t\tptr += size;\n\t}\n}\n\nstatic void dp83640_free_clocks(void)\n{\n\tstruct dp83640_clock *clock;\n\tstruct list_head *this, *next;\n\n\tmutex_lock(&phyter_clocks_lock);\n\n\tlist_for_each_safe(this, next, &phyter_clocks) {\n\t\tclock = list_entry(this, struct dp83640_clock, list);\n\t\tif (!list_empty(&clock->phylist)) {\n\t\t\tpr_warn(\"phy list non-empty while unloading\\n\");\n\t\t\tBUG();\n\t\t}\n\t\tlist_del(&clock->list);\n\t\tmutex_destroy(&clock->extreg_lock);\n\t\tmutex_destroy(&clock->clock_lock);\n\t\tput_device(&clock->bus->dev);\n\t\tkfree(clock->caps.pin_config);\n\t\tkfree(clock);\n\t}\n\n\tmutex_unlock(&phyter_clocks_lock);\n}\n\nstatic void dp83640_clock_init(struct dp83640_clock *clock, struct mii_bus *bus)\n{\n\tINIT_LIST_HEAD(&clock->list);\n\tclock->bus = bus;\n\tmutex_init(&clock->extreg_lock);\n\tmutex_init(&clock->clock_lock);\n\tINIT_LIST_HEAD(&clock->phylist);\n\tclock->caps.owner = THIS_MODULE;\n\tsprintf(clock->caps.name, \"dp83640 timer\");\n\tclock->caps.max_adj\t= 1953124;\n\tclock->caps.n_alarm\t= 0;\n\tclock->caps.n_ext_ts\t= N_EXT_TS;\n\tclock->caps.n_per_out\t= N_PER_OUT;\n\tclock->caps.n_pins\t= DP83640_N_PINS;\n\tclock->caps.pps\t\t= 0;\n\tclock->caps.adjfine\t= ptp_dp83640_adjfine;\n\tclock->caps.adjtime\t= ptp_dp83640_adjtime;\n\tclock->caps.gettime64\t= ptp_dp83640_gettime;\n\tclock->caps.settime64\t= ptp_dp83640_settime;\n\tclock->caps.enable\t= ptp_dp83640_enable;\n\tclock->caps.verify\t= ptp_dp83640_verify;\n\t \n\tdp83640_gpio_defaults(clock->caps.pin_config);\n\t \n\tget_device(&bus->dev);\n}\n\nstatic int choose_this_phy(struct dp83640_clock *clock,\n\t\t\t   struct phy_device *phydev)\n{\n\tif (chosen_phy == -1 && !clock->chosen)\n\t\treturn 1;\n\n\tif (chosen_phy == phydev->mdio.addr)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic struct dp83640_clock *dp83640_clock_get(struct dp83640_clock *clock)\n{\n\tif (clock)\n\t\tmutex_lock(&clock->clock_lock);\n\treturn clock;\n}\n\n \nstatic struct dp83640_clock *dp83640_clock_get_bus(struct mii_bus *bus)\n{\n\tstruct dp83640_clock *clock = NULL, *tmp;\n\tstruct list_head *this;\n\n\tmutex_lock(&phyter_clocks_lock);\n\n\tlist_for_each(this, &phyter_clocks) {\n\t\ttmp = list_entry(this, struct dp83640_clock, list);\n\t\tif (tmp->bus == bus) {\n\t\t\tclock = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (clock)\n\t\tgoto out;\n\n\tclock = kzalloc(sizeof(struct dp83640_clock), GFP_KERNEL);\n\tif (!clock)\n\t\tgoto out;\n\n\tclock->caps.pin_config = kcalloc(DP83640_N_PINS,\n\t\t\t\t\t sizeof(struct ptp_pin_desc),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!clock->caps.pin_config) {\n\t\tkfree(clock);\n\t\tclock = NULL;\n\t\tgoto out;\n\t}\n\tdp83640_clock_init(clock, bus);\n\tlist_add_tail(&clock->list, &phyter_clocks);\nout:\n\tmutex_unlock(&phyter_clocks_lock);\n\n\treturn dp83640_clock_get(clock);\n}\n\nstatic void dp83640_clock_put(struct dp83640_clock *clock)\n{\n\tmutex_unlock(&clock->clock_lock);\n}\n\nstatic int dp83640_soft_reset(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = genphy_soft_reset(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tudelay(10);\t\t \n\n\treturn 0;\n}\n\nstatic int dp83640_config_init(struct phy_device *phydev)\n{\n\tstruct dp83640_private *dp83640 = phydev->priv;\n\tstruct dp83640_clock *clock = dp83640->clock;\n\n\tif (clock->chosen && !list_empty(&clock->phylist))\n\t\trecalibrate(clock);\n\telse {\n\t\tmutex_lock(&clock->extreg_lock);\n\t\tenable_broadcast(phydev, clock->page, 1);\n\t\tmutex_unlock(&clock->extreg_lock);\n\t}\n\n\tenable_status_frames(phydev, true);\n\n\tmutex_lock(&clock->extreg_lock);\n\text_write(0, phydev, PAGE4, PTP_CTL, PTP_ENABLE);\n\tmutex_unlock(&clock->extreg_lock);\n\n\treturn 0;\n}\n\nstatic int dp83640_ack_interrupt(struct phy_device *phydev)\n{\n\tint err = phy_read(phydev, MII_DP83640_MISR);\n\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int dp83640_config_intr(struct phy_device *phydev)\n{\n\tint micr;\n\tint misr;\n\tint err;\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\terr = dp83640_ack_interrupt(phydev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tmisr = phy_read(phydev, MII_DP83640_MISR);\n\t\tif (misr < 0)\n\t\t\treturn misr;\n\t\tmisr |=\n\t\t\t(MII_DP83640_MISR_ANC_INT_EN |\n\t\t\tMII_DP83640_MISR_DUP_INT_EN |\n\t\t\tMII_DP83640_MISR_SPD_INT_EN |\n\t\t\tMII_DP83640_MISR_LINK_INT_EN);\n\t\terr = phy_write(phydev, MII_DP83640_MISR, misr);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tmicr = phy_read(phydev, MII_DP83640_MICR);\n\t\tif (micr < 0)\n\t\t\treturn micr;\n\t\tmicr |=\n\t\t\t(MII_DP83640_MICR_OE |\n\t\t\tMII_DP83640_MICR_IE);\n\t\treturn phy_write(phydev, MII_DP83640_MICR, micr);\n\t} else {\n\t\tmicr = phy_read(phydev, MII_DP83640_MICR);\n\t\tif (micr < 0)\n\t\t\treturn micr;\n\t\tmicr &=\n\t\t\t~(MII_DP83640_MICR_OE |\n\t\t\tMII_DP83640_MICR_IE);\n\t\terr = phy_write(phydev, MII_DP83640_MICR, micr);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tmisr = phy_read(phydev, MII_DP83640_MISR);\n\t\tif (misr < 0)\n\t\t\treturn misr;\n\t\tmisr &=\n\t\t\t~(MII_DP83640_MISR_ANC_INT_EN |\n\t\t\tMII_DP83640_MISR_DUP_INT_EN |\n\t\t\tMII_DP83640_MISR_SPD_INT_EN |\n\t\t\tMII_DP83640_MISR_LINK_INT_EN);\n\t\terr = phy_write(phydev, MII_DP83640_MISR, misr);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn dp83640_ack_interrupt(phydev);\n\t}\n}\n\nstatic irqreturn_t dp83640_handle_interrupt(struct phy_device *phydev)\n{\n\tint irq_status;\n\n\tirq_status = phy_read(phydev, MII_DP83640_MISR);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (!(irq_status & MII_DP83640_MISR_INT_MASK))\n\t\treturn IRQ_NONE;\n\n\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int dp83640_hwtstamp(struct mii_timestamper *mii_ts, struct ifreq *ifr)\n{\n\tstruct dp83640_private *dp83640 =\n\t\tcontainer_of(mii_ts, struct dp83640_private, mii_ts);\n\tstruct hwtstamp_config cfg;\n\tu16 txcfg0, rxcfg0;\n\n\tif (copy_from_user(&cfg, ifr->ifr_data, sizeof(cfg)))\n\t\treturn -EFAULT;\n\n\tif (cfg.tx_type < 0 || cfg.tx_type > HWTSTAMP_TX_ONESTEP_SYNC)\n\t\treturn -ERANGE;\n\n\tdp83640->hwts_tx_en = cfg.tx_type;\n\n\tswitch (cfg.rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tdp83640->hwts_rx_en = 0;\n\t\tdp83640->layer = 0;\n\t\tdp83640->version = 0;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\n\t\tdp83640->hwts_rx_en = 1;\n\t\tdp83640->layer = PTP_CLASS_L4;\n\t\tdp83640->version = PTP_CLASS_V1;\n\t\tcfg.rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_EVENT;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\t\tdp83640->hwts_rx_en = 1;\n\t\tdp83640->layer = PTP_CLASS_L4;\n\t\tdp83640->version = PTP_CLASS_V2;\n\t\tcfg.rx_filter = HWTSTAMP_FILTER_PTP_V2_L4_EVENT;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\t\tdp83640->hwts_rx_en = 1;\n\t\tdp83640->layer = PTP_CLASS_L2;\n\t\tdp83640->version = PTP_CLASS_V2;\n\t\tcfg.rx_filter = HWTSTAMP_FILTER_PTP_V2_L2_EVENT;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\t\tdp83640->hwts_rx_en = 1;\n\t\tdp83640->layer = PTP_CLASS_L4 | PTP_CLASS_L2;\n\t\tdp83640->version = PTP_CLASS_V2;\n\t\tcfg.rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\ttxcfg0 = (dp83640->version & TX_PTP_VER_MASK) << TX_PTP_VER_SHIFT;\n\trxcfg0 = (dp83640->version & TX_PTP_VER_MASK) << TX_PTP_VER_SHIFT;\n\n\tif (dp83640->layer & PTP_CLASS_L2) {\n\t\ttxcfg0 |= TX_L2_EN;\n\t\trxcfg0 |= RX_L2_EN;\n\t}\n\tif (dp83640->layer & PTP_CLASS_L4) {\n\t\ttxcfg0 |= TX_IPV6_EN | TX_IPV4_EN;\n\t\trxcfg0 |= RX_IPV6_EN | RX_IPV4_EN;\n\t}\n\n\tif (dp83640->hwts_tx_en)\n\t\ttxcfg0 |= TX_TS_EN;\n\n\tif (dp83640->hwts_tx_en == HWTSTAMP_TX_ONESTEP_SYNC)\n\t\ttxcfg0 |= SYNC_1STEP | CHK_1STEP;\n\n\tif (dp83640->hwts_rx_en)\n\t\trxcfg0 |= RX_TS_EN;\n\n\tmutex_lock(&dp83640->clock->extreg_lock);\n\n\text_write(0, dp83640->phydev, PAGE5, PTP_TXCFG0, txcfg0);\n\text_write(0, dp83640->phydev, PAGE5, PTP_RXCFG0, rxcfg0);\n\n\tmutex_unlock(&dp83640->clock->extreg_lock);\n\n\treturn copy_to_user(ifr->ifr_data, &cfg, sizeof(cfg)) ? -EFAULT : 0;\n}\n\nstatic void rx_timestamp_work(struct work_struct *work)\n{\n\tstruct dp83640_private *dp83640 =\n\t\tcontainer_of(work, struct dp83640_private, ts_work.work);\n\tstruct sk_buff *skb;\n\n\t \n\twhile ((skb = skb_dequeue(&dp83640->rx_queue))) {\n\t\tstruct dp83640_skb_info *skb_info;\n\n\t\tskb_info = (struct dp83640_skb_info *)skb->cb;\n\t\tif (!time_after(jiffies, skb_info->tmo)) {\n\t\t\tskb_queue_head(&dp83640->rx_queue, skb);\n\t\t\tbreak;\n\t\t}\n\n\t\tnetif_rx(skb);\n\t}\n\n\tif (!skb_queue_empty(&dp83640->rx_queue))\n\t\tschedule_delayed_work(&dp83640->ts_work, SKB_TIMESTAMP_TIMEOUT);\n}\n\nstatic bool dp83640_rxtstamp(struct mii_timestamper *mii_ts,\n\t\t\t     struct sk_buff *skb, int type)\n{\n\tstruct dp83640_private *dp83640 =\n\t\tcontainer_of(mii_ts, struct dp83640_private, mii_ts);\n\tstruct dp83640_skb_info *skb_info = (struct dp83640_skb_info *)skb->cb;\n\tstruct list_head *this, *next;\n\tstruct rxts *rxts;\n\tstruct skb_shared_hwtstamps *shhwtstamps = NULL;\n\tunsigned long flags;\n\n\tif (is_status_frame(skb, type)) {\n\t\tdecode_status_frame(dp83640, skb);\n\t\tkfree_skb(skb);\n\t\treturn true;\n\t}\n\n\tif (!dp83640->hwts_rx_en)\n\t\treturn false;\n\n\tif ((type & dp83640->version) == 0 || (type & dp83640->layer) == 0)\n\t\treturn false;\n\n\tspin_lock_irqsave(&dp83640->rx_lock, flags);\n\tprune_rx_ts(dp83640);\n\tlist_for_each_safe(this, next, &dp83640->rxts) {\n\t\trxts = list_entry(this, struct rxts, list);\n\t\tif (match(skb, type, rxts)) {\n\t\t\tshhwtstamps = skb_hwtstamps(skb);\n\t\t\tmemset(shhwtstamps, 0, sizeof(*shhwtstamps));\n\t\t\tshhwtstamps->hwtstamp = ns_to_ktime(rxts->ns);\n\t\t\tlist_del_init(&rxts->list);\n\t\t\tlist_add(&rxts->list, &dp83640->rxpool);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dp83640->rx_lock, flags);\n\n\tif (!shhwtstamps) {\n\t\tskb_info->ptp_type = type;\n\t\tskb_info->tmo = jiffies + SKB_TIMESTAMP_TIMEOUT;\n\t\tskb_queue_tail(&dp83640->rx_queue, skb);\n\t\tschedule_delayed_work(&dp83640->ts_work, SKB_TIMESTAMP_TIMEOUT);\n\t} else {\n\t\tnetif_rx(skb);\n\t}\n\n\treturn true;\n}\n\nstatic void dp83640_txtstamp(struct mii_timestamper *mii_ts,\n\t\t\t     struct sk_buff *skb, int type)\n{\n\tstruct dp83640_skb_info *skb_info = (struct dp83640_skb_info *)skb->cb;\n\tstruct dp83640_private *dp83640 =\n\t\tcontainer_of(mii_ts, struct dp83640_private, mii_ts);\n\n\tswitch (dp83640->hwts_tx_en) {\n\n\tcase HWTSTAMP_TX_ONESTEP_SYNC:\n\t\tif (ptp_msg_is_sync(skb, type)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t\tfallthrough;\n\tcase HWTSTAMP_TX_ON:\n\t\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\t\tskb_info->tmo = jiffies + SKB_TIMESTAMP_TIMEOUT;\n\t\tskb_queue_tail(&dp83640->tx_queue, skb);\n\t\tbreak;\n\n\tcase HWTSTAMP_TX_OFF:\n\tdefault:\n\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n}\n\nstatic int dp83640_ts_info(struct mii_timestamper *mii_ts,\n\t\t\t   struct ethtool_ts_info *info)\n{\n\tstruct dp83640_private *dp83640 =\n\t\tcontainer_of(mii_ts, struct dp83640_private, mii_ts);\n\n\tinfo->so_timestamping =\n\t\tSOF_TIMESTAMPING_TX_HARDWARE |\n\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\tinfo->phc_index = ptp_clock_index(dp83640->clock->ptp_clock);\n\tinfo->tx_types =\n\t\t(1 << HWTSTAMP_TX_OFF) |\n\t\t(1 << HWTSTAMP_TX_ON) |\n\t\t(1 << HWTSTAMP_TX_ONESTEP_SYNC);\n\tinfo->rx_filters =\n\t\t(1 << HWTSTAMP_FILTER_NONE) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V1_L4_EVENT) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L2_EVENT) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_EVENT);\n\treturn 0;\n}\n\nstatic int dp83640_probe(struct phy_device *phydev)\n{\n\tstruct dp83640_clock *clock;\n\tstruct dp83640_private *dp83640;\n\tint err = -ENOMEM, i;\n\n\tif (phydev->mdio.addr == BROADCAST_ADDR)\n\t\treturn 0;\n\n\tclock = dp83640_clock_get_bus(phydev->mdio.bus);\n\tif (!clock)\n\t\tgoto no_clock;\n\n\tdp83640 = kzalloc(sizeof(struct dp83640_private), GFP_KERNEL);\n\tif (!dp83640)\n\t\tgoto no_memory;\n\n\tdp83640->phydev = phydev;\n\tdp83640->mii_ts.rxtstamp = dp83640_rxtstamp;\n\tdp83640->mii_ts.txtstamp = dp83640_txtstamp;\n\tdp83640->mii_ts.hwtstamp = dp83640_hwtstamp;\n\tdp83640->mii_ts.ts_info  = dp83640_ts_info;\n\n\tINIT_DELAYED_WORK(&dp83640->ts_work, rx_timestamp_work);\n\tINIT_LIST_HEAD(&dp83640->rxts);\n\tINIT_LIST_HEAD(&dp83640->rxpool);\n\tfor (i = 0; i < MAX_RXTS; i++)\n\t\tlist_add(&dp83640->rx_pool_data[i].list, &dp83640->rxpool);\n\n\tphydev->mii_ts = &dp83640->mii_ts;\n\tphydev->priv = dp83640;\n\n\tspin_lock_init(&dp83640->rx_lock);\n\tskb_queue_head_init(&dp83640->rx_queue);\n\tskb_queue_head_init(&dp83640->tx_queue);\n\n\tdp83640->clock = clock;\n\n\tif (choose_this_phy(clock, phydev)) {\n\t\tclock->chosen = dp83640;\n\t\tclock->ptp_clock = ptp_clock_register(&clock->caps,\n\t\t\t\t\t\t      &phydev->mdio.dev);\n\t\tif (IS_ERR(clock->ptp_clock)) {\n\t\t\terr = PTR_ERR(clock->ptp_clock);\n\t\t\tgoto no_register;\n\t\t}\n\t} else\n\t\tlist_add_tail(&dp83640->list, &clock->phylist);\n\n\tdp83640_clock_put(clock);\n\treturn 0;\n\nno_register:\n\tclock->chosen = NULL;\n\tkfree(dp83640);\nno_memory:\n\tdp83640_clock_put(clock);\nno_clock:\n\treturn err;\n}\n\nstatic void dp83640_remove(struct phy_device *phydev)\n{\n\tstruct dp83640_clock *clock;\n\tstruct list_head *this, *next;\n\tstruct dp83640_private *tmp, *dp83640 = phydev->priv;\n\n\tif (phydev->mdio.addr == BROADCAST_ADDR)\n\t\treturn;\n\n\tphydev->mii_ts = NULL;\n\n\tenable_status_frames(phydev, false);\n\tcancel_delayed_work_sync(&dp83640->ts_work);\n\n\tskb_queue_purge(&dp83640->rx_queue);\n\tskb_queue_purge(&dp83640->tx_queue);\n\n\tclock = dp83640_clock_get(dp83640->clock);\n\n\tif (dp83640 == clock->chosen) {\n\t\tptp_clock_unregister(clock->ptp_clock);\n\t\tclock->chosen = NULL;\n\t} else {\n\t\tlist_for_each_safe(this, next, &clock->phylist) {\n\t\t\ttmp = list_entry(this, struct dp83640_private, list);\n\t\t\tif (tmp == dp83640) {\n\t\t\t\tlist_del_init(&tmp->list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tdp83640_clock_put(clock);\n\tkfree(dp83640);\n}\n\nstatic struct phy_driver dp83640_driver = {\n\t.phy_id\t\t= DP83640_PHY_ID,\n\t.phy_id_mask\t= 0xfffffff0,\n\t.name\t\t= \"NatSemi DP83640\",\n\t \n\t.probe\t\t= dp83640_probe,\n\t.remove\t\t= dp83640_remove,\n\t.soft_reset\t= dp83640_soft_reset,\n\t.config_init\t= dp83640_config_init,\n\t.config_intr    = dp83640_config_intr,\n\t.handle_interrupt = dp83640_handle_interrupt,\n};\n\nstatic int __init dp83640_init(void)\n{\n\treturn phy_driver_register(&dp83640_driver, THIS_MODULE);\n}\n\nstatic void __exit dp83640_exit(void)\n{\n\tdp83640_free_clocks();\n\tphy_driver_unregister(&dp83640_driver);\n}\n\nMODULE_DESCRIPTION(\"National Semiconductor DP83640 PHY driver\");\nMODULE_AUTHOR(\"Richard Cochran <richardcochran@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(dp83640_init);\nmodule_exit(dp83640_exit);\n\nstatic struct mdio_device_id __maybe_unused dp83640_tbl[] = {\n\t{ DP83640_PHY_ID, 0xfffffff0 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(mdio, dp83640_tbl);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}