{
  "module_name": "at803x.c",
  "hash_id": "a35cd779da6783ea65878062fc89ea41e7016b61f2cf6fefa1a8d8de21aa6bbf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/at803x.c",
  "human_readable_source": "\n \n\n#include <linux/phy.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool_netlink.h>\n#include <linux/bitfield.h>\n#include <linux/regulator/of_regulator.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/consumer.h>\n#include <linux/of.h>\n#include <linux/phylink.h>\n#include <linux/sfp.h>\n#include <dt-bindings/net/qca-ar803x.h>\n\n#define AT803X_SPECIFIC_FUNCTION_CONTROL\t0x10\n#define AT803X_SFC_ASSERT_CRS\t\t\tBIT(11)\n#define AT803X_SFC_FORCE_LINK\t\t\tBIT(10)\n#define AT803X_SFC_MDI_CROSSOVER_MODE_M\t\tGENMASK(6, 5)\n#define AT803X_SFC_AUTOMATIC_CROSSOVER\t\t0x3\n#define AT803X_SFC_MANUAL_MDIX\t\t\t0x1\n#define AT803X_SFC_MANUAL_MDI\t\t\t0x0\n#define AT803X_SFC_SQE_TEST\t\t\tBIT(2)\n#define AT803X_SFC_POLARITY_REVERSAL\t\tBIT(1)\n#define AT803X_SFC_DISABLE_JABBER\t\tBIT(0)\n\n#define AT803X_SPECIFIC_STATUS\t\t\t0x11\n#define AT803X_SS_SPEED_MASK\t\t\tGENMASK(15, 14)\n#define AT803X_SS_SPEED_1000\t\t\t2\n#define AT803X_SS_SPEED_100\t\t\t1\n#define AT803X_SS_SPEED_10\t\t\t0\n#define AT803X_SS_DUPLEX\t\t\tBIT(13)\n#define AT803X_SS_SPEED_DUPLEX_RESOLVED\t\tBIT(11)\n#define AT803X_SS_MDIX\t\t\t\tBIT(6)\n\n#define QCA808X_SS_SPEED_MASK\t\t\tGENMASK(9, 7)\n#define QCA808X_SS_SPEED_2500\t\t\t4\n\n#define AT803X_INTR_ENABLE\t\t\t0x12\n#define AT803X_INTR_ENABLE_AUTONEG_ERR\t\tBIT(15)\n#define AT803X_INTR_ENABLE_SPEED_CHANGED\tBIT(14)\n#define AT803X_INTR_ENABLE_DUPLEX_CHANGED\tBIT(13)\n#define AT803X_INTR_ENABLE_PAGE_RECEIVED\tBIT(12)\n#define AT803X_INTR_ENABLE_LINK_FAIL\t\tBIT(11)\n#define AT803X_INTR_ENABLE_LINK_SUCCESS\t\tBIT(10)\n#define AT803X_INTR_ENABLE_LINK_FAIL_BX\t\tBIT(8)\n#define AT803X_INTR_ENABLE_LINK_SUCCESS_BX\tBIT(7)\n#define AT803X_INTR_ENABLE_WIRESPEED_DOWNGRADE\tBIT(5)\n#define AT803X_INTR_ENABLE_POLARITY_CHANGED\tBIT(1)\n#define AT803X_INTR_ENABLE_WOL\t\t\tBIT(0)\n\n#define AT803X_INTR_STATUS\t\t\t0x13\n\n#define AT803X_SMART_SPEED\t\t\t0x14\n#define AT803X_SMART_SPEED_ENABLE\t\tBIT(5)\n#define AT803X_SMART_SPEED_RETRY_LIMIT_MASK\tGENMASK(4, 2)\n#define AT803X_SMART_SPEED_BYPASS_TIMER\t\tBIT(1)\n#define AT803X_CDT\t\t\t\t0x16\n#define AT803X_CDT_MDI_PAIR_MASK\t\tGENMASK(9, 8)\n#define AT803X_CDT_ENABLE_TEST\t\t\tBIT(0)\n#define AT803X_CDT_STATUS\t\t\t0x1c\n#define AT803X_CDT_STATUS_STAT_NORMAL\t\t0\n#define AT803X_CDT_STATUS_STAT_SHORT\t\t1\n#define AT803X_CDT_STATUS_STAT_OPEN\t\t2\n#define AT803X_CDT_STATUS_STAT_FAIL\t\t3\n#define AT803X_CDT_STATUS_STAT_MASK\t\tGENMASK(9, 8)\n#define AT803X_CDT_STATUS_DELTA_TIME_MASK\tGENMASK(7, 0)\n#define AT803X_LED_CONTROL\t\t\t0x18\n\n#define AT803X_PHY_MMD3_WOL_CTRL\t\t0x8012\n#define AT803X_WOL_EN\t\t\t\tBIT(5)\n#define AT803X_LOC_MAC_ADDR_0_15_OFFSET\t\t0x804C\n#define AT803X_LOC_MAC_ADDR_16_31_OFFSET\t0x804B\n#define AT803X_LOC_MAC_ADDR_32_47_OFFSET\t0x804A\n#define AT803X_REG_CHIP_CONFIG\t\t\t0x1f\n#define AT803X_BT_BX_REG_SEL\t\t\t0x8000\n\n#define AT803X_DEBUG_ADDR\t\t\t0x1D\n#define AT803X_DEBUG_DATA\t\t\t0x1E\n\n#define AT803X_MODE_CFG_MASK\t\t\t0x0F\n#define AT803X_MODE_CFG_BASET_RGMII\t\t0x00\n#define AT803X_MODE_CFG_BASET_SGMII\t\t0x01\n#define AT803X_MODE_CFG_BX1000_RGMII_50OHM\t0x02\n#define AT803X_MODE_CFG_BX1000_RGMII_75OHM\t0x03\n#define AT803X_MODE_CFG_BX1000_CONV_50OHM\t0x04\n#define AT803X_MODE_CFG_BX1000_CONV_75OHM\t0x05\n#define AT803X_MODE_CFG_FX100_RGMII_50OHM\t0x06\n#define AT803X_MODE_CFG_FX100_CONV_50OHM\t0x07\n#define AT803X_MODE_CFG_RGMII_AUTO_MDET\t\t0x0B\n#define AT803X_MODE_CFG_FX100_RGMII_75OHM\t0x0E\n#define AT803X_MODE_CFG_FX100_CONV_75OHM\t0x0F\n\n#define AT803X_PSSR\t\t\t\t0x11\t \n#define AT803X_PSSR_MR_AN_COMPLETE\t\t0x0200\n\n#define AT803X_DEBUG_ANALOG_TEST_CTRL\t\t0x00\n#define QCA8327_DEBUG_MANU_CTRL_EN\t\tBIT(2)\n#define QCA8337_DEBUG_MANU_CTRL_EN\t\tGENMASK(3, 2)\n#define AT803X_DEBUG_RX_CLK_DLY_EN\t\tBIT(15)\n\n#define AT803X_DEBUG_SYSTEM_CTRL_MODE\t\t0x05\n#define AT803X_DEBUG_TX_CLK_DLY_EN\t\tBIT(8)\n\n#define AT803X_DEBUG_REG_HIB_CTRL\t\t0x0b\n#define   AT803X_DEBUG_HIB_CTRL_SEL_RST_80U\tBIT(10)\n#define   AT803X_DEBUG_HIB_CTRL_EN_ANY_CHANGE\tBIT(13)\n#define   AT803X_DEBUG_HIB_CTRL_PS_HIB_EN\tBIT(15)\n\n#define AT803X_DEBUG_REG_3C\t\t\t0x3C\n\n#define AT803X_DEBUG_REG_GREEN\t\t\t0x3D\n#define   AT803X_DEBUG_GATE_CLK_IN1000\t\tBIT(6)\n\n#define AT803X_DEBUG_REG_1F\t\t\t0x1F\n#define AT803X_DEBUG_PLL_ON\t\t\tBIT(2)\n#define AT803X_DEBUG_RGMII_1V8\t\t\tBIT(3)\n\n#define MDIO_AZ_DEBUG\t\t\t\t0x800D\n\n \n#define AT803X_MMD7_CLK25M\t\t\t0x8016\n#define AT803X_CLK_OUT_MASK\t\t\tGENMASK(4, 2)\n#define AT803X_CLK_OUT_25MHZ_XTAL\t\t0\n#define AT803X_CLK_OUT_25MHZ_DSP\t\t1\n#define AT803X_CLK_OUT_50MHZ_PLL\t\t2\n#define AT803X_CLK_OUT_50MHZ_DSP\t\t3\n#define AT803X_CLK_OUT_62_5MHZ_PLL\t\t4\n#define AT803X_CLK_OUT_62_5MHZ_DSP\t\t5\n#define AT803X_CLK_OUT_125MHZ_PLL\t\t6\n#define AT803X_CLK_OUT_125MHZ_DSP\t\t7\n\n \n#define AT8035_CLK_OUT_MASK\t\t\tGENMASK(4, 3)\n\n#define AT803X_CLK_OUT_STRENGTH_MASK\t\tGENMASK(8, 7)\n#define AT803X_CLK_OUT_STRENGTH_FULL\t\t0\n#define AT803X_CLK_OUT_STRENGTH_HALF\t\t1\n#define AT803X_CLK_OUT_STRENGTH_QUARTER\t\t2\n\n#define AT803X_DEFAULT_DOWNSHIFT\t\t5\n#define AT803X_MIN_DOWNSHIFT\t\t\t2\n#define AT803X_MAX_DOWNSHIFT\t\t\t9\n\n#define AT803X_MMD3_SMARTEEE_CTL1\t\t0x805b\n#define AT803X_MMD3_SMARTEEE_CTL2\t\t0x805c\n#define AT803X_MMD3_SMARTEEE_CTL3\t\t0x805d\n#define AT803X_MMD3_SMARTEEE_CTL3_LPI_EN\tBIT(8)\n\n#define ATH9331_PHY_ID\t\t\t\t0x004dd041\n#define ATH8030_PHY_ID\t\t\t\t0x004dd076\n#define ATH8031_PHY_ID\t\t\t\t0x004dd074\n#define ATH8032_PHY_ID\t\t\t\t0x004dd023\n#define ATH8035_PHY_ID\t\t\t\t0x004dd072\n#define AT8030_PHY_ID_MASK\t\t\t0xffffffef\n\n#define QCA8081_PHY_ID\t\t\t\t0x004dd101\n\n#define QCA8327_A_PHY_ID\t\t\t0x004dd033\n#define QCA8327_B_PHY_ID\t\t\t0x004dd034\n#define QCA8337_PHY_ID\t\t\t\t0x004dd036\n#define QCA9561_PHY_ID\t\t\t\t0x004dd042\n#define QCA8K_PHY_ID_MASK\t\t\t0xffffffff\n\n#define QCA8K_DEVFLAGS_REVISION_MASK\t\tGENMASK(2, 0)\n\n#define AT803X_PAGE_FIBER\t\t\t0\n#define AT803X_PAGE_COPPER\t\t\t1\n\n \n#define AT803X_KEEP_PLL_ENABLED\t\t\tBIT(0)\n#define AT803X_DISABLE_SMARTEEE\t\t\tBIT(1)\n\n \n#define AT803X_DISABLE_HIBERNATION_MODE\t\tBIT(2)\n\n \n#define QCA808X_PHY_DEBUG_ADC_THRESHOLD\t\t0x2c80\n#define QCA808X_ADC_THRESHOLD_MASK\t\tGENMASK(7, 0)\n#define QCA808X_ADC_THRESHOLD_80MV\t\t0\n#define QCA808X_ADC_THRESHOLD_100MV\t\t0xf0\n#define QCA808X_ADC_THRESHOLD_200MV\t\t0x0f\n#define QCA808X_ADC_THRESHOLD_300MV\t\t0xff\n\n \n#define QCA808X_PHY_MMD3_ADDR_CLD_CTRL7\t\t0x8007\n#define QCA808X_8023AZ_AFE_CTRL_MASK\t\tGENMASK(8, 4)\n#define QCA808X_8023AZ_AFE_EN\t\t\t0x90\n\n \n#define QCA808X_PHY_MMD3_AZ_TRAINING_CTRL\t0x8008\n#define QCA808X_MMD3_AZ_TRAINING_VAL\t\t0x1c32\n\n#define QCA808X_PHY_MMD1_MSE_THRESHOLD_20DB\t0x8014\n#define QCA808X_MSE_THRESHOLD_20DB_VALUE\t0x529\n\n#define QCA808X_PHY_MMD1_MSE_THRESHOLD_17DB\t0x800E\n#define QCA808X_MSE_THRESHOLD_17DB_VALUE\t0x341\n\n#define QCA808X_PHY_MMD1_MSE_THRESHOLD_27DB\t0x801E\n#define QCA808X_MSE_THRESHOLD_27DB_VALUE\t0x419\n\n#define QCA808X_PHY_MMD1_MSE_THRESHOLD_28DB\t0x8020\n#define QCA808X_MSE_THRESHOLD_28DB_VALUE\t0x341\n\n#define QCA808X_PHY_MMD7_TOP_OPTION1\t\t0x901c\n#define QCA808X_TOP_OPTION1_DATA\t\t0x0\n\n#define QCA808X_PHY_MMD3_DEBUG_1\t\t0xa100\n#define QCA808X_MMD3_DEBUG_1_VALUE\t\t0x9203\n#define QCA808X_PHY_MMD3_DEBUG_2\t\t0xa101\n#define QCA808X_MMD3_DEBUG_2_VALUE\t\t0x48ad\n#define QCA808X_PHY_MMD3_DEBUG_3\t\t0xa103\n#define QCA808X_MMD3_DEBUG_3_VALUE\t\t0x1698\n#define QCA808X_PHY_MMD3_DEBUG_4\t\t0xa105\n#define QCA808X_MMD3_DEBUG_4_VALUE\t\t0x8001\n#define QCA808X_PHY_MMD3_DEBUG_5\t\t0xa106\n#define QCA808X_MMD3_DEBUG_5_VALUE\t\t0x1111\n#define QCA808X_PHY_MMD3_DEBUG_6\t\t0xa011\n#define QCA808X_MMD3_DEBUG_6_VALUE\t\t0x5f85\n\n \n#define QCA808X_PHY_DEBUG_LOCAL_SEED\t\t9\n#define QCA808X_MASTER_SLAVE_SEED_ENABLE\tBIT(1)\n#define QCA808X_MASTER_SLAVE_SEED_CFG\t\tGENMASK(12, 2)\n#define QCA808X_MASTER_SLAVE_SEED_RANGE\t\t0x32\n\n \n#define QCA808X_DBG_AN_TEST\t\t\t0xb\n#define QCA808X_HIBERNATION_EN\t\t\tBIT(15)\n\n#define QCA808X_CDT_ENABLE_TEST\t\t\tBIT(15)\n#define QCA808X_CDT_INTER_CHECK_DIS\t\tBIT(13)\n#define QCA808X_CDT_LENGTH_UNIT\t\t\tBIT(10)\n\n#define QCA808X_MMD3_CDT_STATUS\t\t\t0x8064\n#define QCA808X_MMD3_CDT_DIAG_PAIR_A\t\t0x8065\n#define QCA808X_MMD3_CDT_DIAG_PAIR_B\t\t0x8066\n#define QCA808X_MMD3_CDT_DIAG_PAIR_C\t\t0x8067\n#define QCA808X_MMD3_CDT_DIAG_PAIR_D\t\t0x8068\n#define QCA808X_CDT_DIAG_LENGTH\t\t\tGENMASK(7, 0)\n\n#define QCA808X_CDT_CODE_PAIR_A\t\t\tGENMASK(15, 12)\n#define QCA808X_CDT_CODE_PAIR_B\t\t\tGENMASK(11, 8)\n#define QCA808X_CDT_CODE_PAIR_C\t\t\tGENMASK(7, 4)\n#define QCA808X_CDT_CODE_PAIR_D\t\t\tGENMASK(3, 0)\n#define QCA808X_CDT_STATUS_STAT_FAIL\t\t0\n#define QCA808X_CDT_STATUS_STAT_NORMAL\t\t1\n#define QCA808X_CDT_STATUS_STAT_OPEN\t\t2\n#define QCA808X_CDT_STATUS_STAT_SHORT\t\t3\n\n \n#define QCA808X_PHY_MMD7_CHIP_TYPE\t\t0x901d\n#define QCA808X_PHY_CHIP_TYPE_1G\t\tBIT(0)\n\n#define QCA8081_PHY_SERDES_MMD1_FIFO_CTRL\t0x9072\n#define QCA8081_PHY_FIFO_RSTN\t\t\tBIT(11)\n\nMODULE_DESCRIPTION(\"Qualcomm Atheros AR803x and QCA808X PHY driver\");\nMODULE_AUTHOR(\"Matus Ujhelyi\");\nMODULE_LICENSE(\"GPL\");\n\nenum stat_access_type {\n\tPHY,\n\tMMD\n};\n\nstruct at803x_hw_stat {\n\tconst char *string;\n\tu8 reg;\n\tu32 mask;\n\tenum stat_access_type access_type;\n};\n\nstatic struct at803x_hw_stat at803x_hw_stats[] = {\n\t{ \"phy_idle_errors\", 0xa, GENMASK(7, 0), PHY},\n\t{ \"phy_receive_errors\", 0x15, GENMASK(15, 0), PHY},\n\t{ \"eee_wake_errors\", 0x16, GENMASK(15, 0), MMD},\n};\n\nstruct at803x_priv {\n\tint flags;\n\tu16 clk_25m_reg;\n\tu16 clk_25m_mask;\n\tu8 smarteee_lpi_tw_1g;\n\tu8 smarteee_lpi_tw_100m;\n\tbool is_fiber;\n\tbool is_1000basex;\n\tstruct regulator_dev *vddio_rdev;\n\tstruct regulator_dev *vddh_rdev;\n\tu64 stats[ARRAY_SIZE(at803x_hw_stats)];\n};\n\nstruct at803x_context {\n\tu16 bmcr;\n\tu16 advertise;\n\tu16 control1000;\n\tu16 int_enable;\n\tu16 smart_speed;\n\tu16 led_control;\n};\n\nstatic int at803x_debug_reg_write(struct phy_device *phydev, u16 reg, u16 data)\n{\n\tint ret;\n\n\tret = phy_write(phydev, AT803X_DEBUG_ADDR, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn phy_write(phydev, AT803X_DEBUG_DATA, data);\n}\n\nstatic int at803x_debug_reg_read(struct phy_device *phydev, u16 reg)\n{\n\tint ret;\n\n\tret = phy_write(phydev, AT803X_DEBUG_ADDR, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn phy_read(phydev, AT803X_DEBUG_DATA);\n}\n\nstatic int at803x_debug_reg_mask(struct phy_device *phydev, u16 reg,\n\t\t\t\t u16 clear, u16 set)\n{\n\tu16 val;\n\tint ret;\n\n\tret = at803x_debug_reg_read(phydev, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = ret & 0xffff;\n\tval &= ~clear;\n\tval |= set;\n\n\treturn phy_write(phydev, AT803X_DEBUG_DATA, val);\n}\n\nstatic int at803x_write_page(struct phy_device *phydev, int page)\n{\n\tint mask;\n\tint set;\n\n\tif (page == AT803X_PAGE_COPPER) {\n\t\tset = AT803X_BT_BX_REG_SEL;\n\t\tmask = 0;\n\t} else {\n\t\tset = 0;\n\t\tmask = AT803X_BT_BX_REG_SEL;\n\t}\n\n\treturn __phy_modify(phydev, AT803X_REG_CHIP_CONFIG, mask, set);\n}\n\nstatic int at803x_read_page(struct phy_device *phydev)\n{\n\tint ccr = __phy_read(phydev, AT803X_REG_CHIP_CONFIG);\n\n\tif (ccr < 0)\n\t\treturn ccr;\n\n\tif (ccr & AT803X_BT_BX_REG_SEL)\n\t\treturn AT803X_PAGE_COPPER;\n\n\treturn AT803X_PAGE_FIBER;\n}\n\nstatic int at803x_enable_rx_delay(struct phy_device *phydev)\n{\n\treturn at803x_debug_reg_mask(phydev, AT803X_DEBUG_ANALOG_TEST_CTRL, 0,\n\t\t\t\t     AT803X_DEBUG_RX_CLK_DLY_EN);\n}\n\nstatic int at803x_enable_tx_delay(struct phy_device *phydev)\n{\n\treturn at803x_debug_reg_mask(phydev, AT803X_DEBUG_SYSTEM_CTRL_MODE, 0,\n\t\t\t\t     AT803X_DEBUG_TX_CLK_DLY_EN);\n}\n\nstatic int at803x_disable_rx_delay(struct phy_device *phydev)\n{\n\treturn at803x_debug_reg_mask(phydev, AT803X_DEBUG_ANALOG_TEST_CTRL,\n\t\t\t\t     AT803X_DEBUG_RX_CLK_DLY_EN, 0);\n}\n\nstatic int at803x_disable_tx_delay(struct phy_device *phydev)\n{\n\treturn at803x_debug_reg_mask(phydev, AT803X_DEBUG_SYSTEM_CTRL_MODE,\n\t\t\t\t     AT803X_DEBUG_TX_CLK_DLY_EN, 0);\n}\n\n \nstatic void at803x_context_save(struct phy_device *phydev,\n\t\t\t\tstruct at803x_context *context)\n{\n\tcontext->bmcr = phy_read(phydev, MII_BMCR);\n\tcontext->advertise = phy_read(phydev, MII_ADVERTISE);\n\tcontext->control1000 = phy_read(phydev, MII_CTRL1000);\n\tcontext->int_enable = phy_read(phydev, AT803X_INTR_ENABLE);\n\tcontext->smart_speed = phy_read(phydev, AT803X_SMART_SPEED);\n\tcontext->led_control = phy_read(phydev, AT803X_LED_CONTROL);\n}\n\n \nstatic void at803x_context_restore(struct phy_device *phydev,\n\t\t\t\t   const struct at803x_context *context)\n{\n\tphy_write(phydev, MII_BMCR, context->bmcr);\n\tphy_write(phydev, MII_ADVERTISE, context->advertise);\n\tphy_write(phydev, MII_CTRL1000, context->control1000);\n\tphy_write(phydev, AT803X_INTR_ENABLE, context->int_enable);\n\tphy_write(phydev, AT803X_SMART_SPEED, context->smart_speed);\n\tphy_write(phydev, AT803X_LED_CONTROL, context->led_control);\n}\n\nstatic int at803x_set_wol(struct phy_device *phydev,\n\t\t\t  struct ethtool_wolinfo *wol)\n{\n\tint ret, irq_enabled;\n\n\tif (wol->wolopts & WAKE_MAGIC) {\n\t\tstruct net_device *ndev = phydev->attached_dev;\n\t\tconst u8 *mac;\n\t\tunsigned int i;\n\t\tstatic const unsigned int offsets[] = {\n\t\t\tAT803X_LOC_MAC_ADDR_32_47_OFFSET,\n\t\t\tAT803X_LOC_MAC_ADDR_16_31_OFFSET,\n\t\t\tAT803X_LOC_MAC_ADDR_0_15_OFFSET,\n\t\t};\n\n\t\tif (!ndev)\n\t\t\treturn -ENODEV;\n\n\t\tmac = (const u8 *) ndev->dev_addr;\n\n\t\tif (!is_valid_ether_addr(mac))\n\t\t\treturn -EINVAL;\n\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tphy_write_mmd(phydev, MDIO_MMD_PCS, offsets[i],\n\t\t\t\t      mac[(i * 2) + 1] | (mac[(i * 2)] << 8));\n\n\t\t \n\t\tif (phydev->drv->phy_id == ATH8031_PHY_ID) {\n\t\t\tret = phy_modify_mmd(phydev, MDIO_MMD_PCS,\n\t\t\t\t\t     AT803X_PHY_MMD3_WOL_CTRL,\n\t\t\t\t\t     0, AT803X_WOL_EN);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tret = phy_modify(phydev, AT803X_INTR_ENABLE, 0, AT803X_INTR_ENABLE_WOL);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\t \n\t\tif (phydev->drv->phy_id == ATH8031_PHY_ID) {\n\t\t\tret = phy_modify_mmd(phydev, MDIO_MMD_PCS,\n\t\t\t\t\t     AT803X_PHY_MMD3_WOL_CTRL,\n\t\t\t\t\t     AT803X_WOL_EN, 0);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tret = phy_modify(phydev, AT803X_INTR_ENABLE, AT803X_INTR_ENABLE_WOL, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = phy_read(phydev, AT803X_INTR_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tirq_enabled = phy_read(phydev, AT803X_INTR_ENABLE);\n\tif (irq_enabled < 0)\n\t\treturn irq_enabled;\n\n\tirq_enabled &= ~AT803X_INTR_ENABLE_WOL;\n\tif (ret & irq_enabled && !phy_polling_mode(phydev))\n\t\tphy_trigger_machine(phydev);\n\n\treturn 0;\n}\n\nstatic void at803x_get_wol(struct phy_device *phydev,\n\t\t\t   struct ethtool_wolinfo *wol)\n{\n\tint value;\n\n\twol->supported = WAKE_MAGIC;\n\twol->wolopts = 0;\n\n\tvalue = phy_read(phydev, AT803X_INTR_ENABLE);\n\tif (value < 0)\n\t\treturn;\n\n\tif (value & AT803X_INTR_ENABLE_WOL)\n\t\twol->wolopts |= WAKE_MAGIC;\n}\n\nstatic int at803x_get_sset_count(struct phy_device *phydev)\n{\n\treturn ARRAY_SIZE(at803x_hw_stats);\n}\n\nstatic void at803x_get_strings(struct phy_device *phydev, u8 *data)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(at803x_hw_stats); i++) {\n\t\tstrscpy(data + i * ETH_GSTRING_LEN,\n\t\t\tat803x_hw_stats[i].string, ETH_GSTRING_LEN);\n\t}\n}\n\nstatic u64 at803x_get_stat(struct phy_device *phydev, int i)\n{\n\tstruct at803x_hw_stat stat = at803x_hw_stats[i];\n\tstruct at803x_priv *priv = phydev->priv;\n\tint val;\n\tu64 ret;\n\n\tif (stat.access_type == MMD)\n\t\tval = phy_read_mmd(phydev, MDIO_MMD_PCS, stat.reg);\n\telse\n\t\tval = phy_read(phydev, stat.reg);\n\n\tif (val < 0) {\n\t\tret = U64_MAX;\n\t} else {\n\t\tval = val & stat.mask;\n\t\tpriv->stats[i] += val;\n\t\tret = priv->stats[i];\n\t}\n\n\treturn ret;\n}\n\nstatic void at803x_get_stats(struct phy_device *phydev,\n\t\t\t     struct ethtool_stats *stats, u64 *data)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(at803x_hw_stats); i++)\n\t\tdata[i] = at803x_get_stat(phydev, i);\n}\n\nstatic int at803x_suspend(struct phy_device *phydev)\n{\n\tint value;\n\tint wol_enabled;\n\n\tvalue = phy_read(phydev, AT803X_INTR_ENABLE);\n\twol_enabled = value & AT803X_INTR_ENABLE_WOL;\n\n\tif (wol_enabled)\n\t\tvalue = BMCR_ISOLATE;\n\telse\n\t\tvalue = BMCR_PDOWN;\n\n\tphy_modify(phydev, MII_BMCR, 0, value);\n\n\treturn 0;\n}\n\nstatic int at803x_resume(struct phy_device *phydev)\n{\n\treturn phy_modify(phydev, MII_BMCR, BMCR_PDOWN | BMCR_ISOLATE, 0);\n}\n\nstatic int at803x_rgmii_reg_set_voltage_sel(struct regulator_dev *rdev,\n\t\t\t\t\t    unsigned int selector)\n{\n\tstruct phy_device *phydev = rdev_get_drvdata(rdev);\n\n\tif (selector)\n\t\treturn at803x_debug_reg_mask(phydev, AT803X_DEBUG_REG_1F,\n\t\t\t\t\t     0, AT803X_DEBUG_RGMII_1V8);\n\telse\n\t\treturn at803x_debug_reg_mask(phydev, AT803X_DEBUG_REG_1F,\n\t\t\t\t\t     AT803X_DEBUG_RGMII_1V8, 0);\n}\n\nstatic int at803x_rgmii_reg_get_voltage_sel(struct regulator_dev *rdev)\n{\n\tstruct phy_device *phydev = rdev_get_drvdata(rdev);\n\tint val;\n\n\tval = at803x_debug_reg_read(phydev, AT803X_DEBUG_REG_1F);\n\tif (val < 0)\n\t\treturn val;\n\n\treturn (val & AT803X_DEBUG_RGMII_1V8) ? 1 : 0;\n}\n\nstatic const struct regulator_ops vddio_regulator_ops = {\n\t.list_voltage = regulator_list_voltage_table,\n\t.set_voltage_sel = at803x_rgmii_reg_set_voltage_sel,\n\t.get_voltage_sel = at803x_rgmii_reg_get_voltage_sel,\n};\n\nstatic const unsigned int vddio_voltage_table[] = {\n\t1500000,\n\t1800000,\n};\n\nstatic const struct regulator_desc vddio_desc = {\n\t.name = \"vddio\",\n\t.of_match = of_match_ptr(\"vddio-regulator\"),\n\t.n_voltages = ARRAY_SIZE(vddio_voltage_table),\n\t.volt_table = vddio_voltage_table,\n\t.ops = &vddio_regulator_ops,\n\t.type = REGULATOR_VOLTAGE,\n\t.owner = THIS_MODULE,\n};\n\nstatic const struct regulator_ops vddh_regulator_ops = {\n};\n\nstatic const struct regulator_desc vddh_desc = {\n\t.name = \"vddh\",\n\t.of_match = of_match_ptr(\"vddh-regulator\"),\n\t.n_voltages = 1,\n\t.fixed_uV = 2500000,\n\t.ops = &vddh_regulator_ops,\n\t.type = REGULATOR_VOLTAGE,\n\t.owner = THIS_MODULE,\n};\n\nstatic int at8031_register_regulators(struct phy_device *phydev)\n{\n\tstruct at803x_priv *priv = phydev->priv;\n\tstruct device *dev = &phydev->mdio.dev;\n\tstruct regulator_config config = { };\n\n\tconfig.dev = dev;\n\tconfig.driver_data = phydev;\n\n\tpriv->vddio_rdev = devm_regulator_register(dev, &vddio_desc, &config);\n\tif (IS_ERR(priv->vddio_rdev)) {\n\t\tphydev_err(phydev, \"failed to register VDDIO regulator\\n\");\n\t\treturn PTR_ERR(priv->vddio_rdev);\n\t}\n\n\tpriv->vddh_rdev = devm_regulator_register(dev, &vddh_desc, &config);\n\tif (IS_ERR(priv->vddh_rdev)) {\n\t\tphydev_err(phydev, \"failed to register VDDH regulator\\n\");\n\t\treturn PTR_ERR(priv->vddh_rdev);\n\t}\n\n\treturn 0;\n}\n\nstatic int at803x_sfp_insert(void *upstream, const struct sfp_eeprom_id *id)\n{\n\tstruct phy_device *phydev = upstream;\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(phy_support);\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(sfp_support);\n\tDECLARE_PHY_INTERFACE_MASK(interfaces);\n\tphy_interface_t iface;\n\n\tlinkmode_zero(phy_support);\n\tphylink_set(phy_support, 1000baseX_Full);\n\tphylink_set(phy_support, 1000baseT_Full);\n\tphylink_set(phy_support, Autoneg);\n\tphylink_set(phy_support, Pause);\n\tphylink_set(phy_support, Asym_Pause);\n\n\tlinkmode_zero(sfp_support);\n\tsfp_parse_support(phydev->sfp_bus, id, sfp_support, interfaces);\n\t \n\tlinkmode_and(sfp_support, phy_support, sfp_support);\n\n\tif (linkmode_empty(sfp_support)) {\n\t\tdev_err(&phydev->mdio.dev, \"incompatible SFP module inserted\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tiface = sfp_select_interface(phydev->sfp_bus, sfp_support);\n\n\t \n\tif (iface == PHY_INTERFACE_MODE_SGMII)\n\t\tdev_warn(&phydev->mdio.dev, \"module may not function if 1000Base-X not supported\\n\");\n\telse if (iface != PHY_INTERFACE_MODE_1000BASEX)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic const struct sfp_upstream_ops at803x_sfp_ops = {\n\t.attach = phy_sfp_attach,\n\t.detach = phy_sfp_detach,\n\t.module_insert = at803x_sfp_insert,\n};\n\nstatic int at803x_parse_dt(struct phy_device *phydev)\n{\n\tstruct device_node *node = phydev->mdio.dev.of_node;\n\tstruct at803x_priv *priv = phydev->priv;\n\tu32 freq, strength, tw;\n\tunsigned int sel;\n\tint ret;\n\n\tif (!IS_ENABLED(CONFIG_OF_MDIO))\n\t\treturn 0;\n\n\tif (of_property_read_bool(node, \"qca,disable-smarteee\"))\n\t\tpriv->flags |= AT803X_DISABLE_SMARTEEE;\n\n\tif (of_property_read_bool(node, \"qca,disable-hibernation-mode\"))\n\t\tpriv->flags |= AT803X_DISABLE_HIBERNATION_MODE;\n\n\tif (!of_property_read_u32(node, \"qca,smarteee-tw-us-1g\", &tw)) {\n\t\tif (!tw || tw > 255) {\n\t\t\tphydev_err(phydev, \"invalid qca,smarteee-tw-us-1g\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpriv->smarteee_lpi_tw_1g = tw;\n\t}\n\n\tif (!of_property_read_u32(node, \"qca,smarteee-tw-us-100m\", &tw)) {\n\t\tif (!tw || tw > 255) {\n\t\t\tphydev_err(phydev, \"invalid qca,smarteee-tw-us-100m\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpriv->smarteee_lpi_tw_100m = tw;\n\t}\n\n\tret = of_property_read_u32(node, \"qca,clk-out-frequency\", &freq);\n\tif (!ret) {\n\t\tswitch (freq) {\n\t\tcase 25000000:\n\t\t\tsel = AT803X_CLK_OUT_25MHZ_XTAL;\n\t\t\tbreak;\n\t\tcase 50000000:\n\t\t\tsel = AT803X_CLK_OUT_50MHZ_PLL;\n\t\t\tbreak;\n\t\tcase 62500000:\n\t\t\tsel = AT803X_CLK_OUT_62_5MHZ_PLL;\n\t\t\tbreak;\n\t\tcase 125000000:\n\t\t\tsel = AT803X_CLK_OUT_125MHZ_PLL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphydev_err(phydev, \"invalid qca,clk-out-frequency\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpriv->clk_25m_reg |= FIELD_PREP(AT803X_CLK_OUT_MASK, sel);\n\t\tpriv->clk_25m_mask |= AT803X_CLK_OUT_MASK;\n\n\t\t \n\t\tif (phydev->drv->phy_id == ATH8030_PHY_ID ||\n\t\t    phydev->drv->phy_id == ATH8035_PHY_ID) {\n\t\t\tpriv->clk_25m_reg &= AT8035_CLK_OUT_MASK;\n\t\t\tpriv->clk_25m_mask &= AT8035_CLK_OUT_MASK;\n\t\t}\n\t}\n\n\tret = of_property_read_u32(node, \"qca,clk-out-strength\", &strength);\n\tif (!ret) {\n\t\tpriv->clk_25m_mask |= AT803X_CLK_OUT_STRENGTH_MASK;\n\t\tswitch (strength) {\n\t\tcase AR803X_STRENGTH_FULL:\n\t\t\tpriv->clk_25m_reg |= AT803X_CLK_OUT_STRENGTH_FULL;\n\t\t\tbreak;\n\t\tcase AR803X_STRENGTH_HALF:\n\t\t\tpriv->clk_25m_reg |= AT803X_CLK_OUT_STRENGTH_HALF;\n\t\t\tbreak;\n\t\tcase AR803X_STRENGTH_QUARTER:\n\t\t\tpriv->clk_25m_reg |= AT803X_CLK_OUT_STRENGTH_QUARTER;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphydev_err(phydev, \"invalid qca,clk-out-strength\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (phydev->drv->phy_id == ATH8031_PHY_ID) {\n\t\tif (of_property_read_bool(node, \"qca,keep-pll-enabled\"))\n\t\t\tpriv->flags |= AT803X_KEEP_PLL_ENABLED;\n\n\t\tret = at8031_register_regulators(phydev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = devm_regulator_get_enable_optional(&phydev->mdio.dev,\n\t\t\t\t\t\t\t \"vddio\");\n\t\tif (ret) {\n\t\t\tphydev_err(phydev, \"failed to get VDDIO regulator\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = phy_sfp_probe(phydev, &at803x_sfp_ops);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int at803x_probe(struct phy_device *phydev)\n{\n\tstruct device *dev = &phydev->mdio.dev;\n\tstruct at803x_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tphydev->priv = priv;\n\n\tret = at803x_parse_dt(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (phydev->drv->phy_id == ATH8031_PHY_ID) {\n\t\tint ccr = phy_read(phydev, AT803X_REG_CHIP_CONFIG);\n\t\tint mode_cfg;\n\n\t\tif (ccr < 0)\n\t\t\treturn ccr;\n\t\tmode_cfg = ccr & AT803X_MODE_CFG_MASK;\n\n\t\tswitch (mode_cfg) {\n\t\tcase AT803X_MODE_CFG_BX1000_RGMII_50OHM:\n\t\tcase AT803X_MODE_CFG_BX1000_RGMII_75OHM:\n\t\t\tpriv->is_1000basex = true;\n\t\t\tfallthrough;\n\t\tcase AT803X_MODE_CFG_FX100_RGMII_50OHM:\n\t\tcase AT803X_MODE_CFG_FX100_RGMII_75OHM:\n\t\t\tpriv->is_fiber = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tret = phy_modify_mmd(phydev, MDIO_MMD_PCS,\n\t\t\t\t     AT803X_PHY_MMD3_WOL_CTRL,\n\t\t\t\t     AT803X_WOL_EN, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int at803x_get_features(struct phy_device *phydev)\n{\n\tstruct at803x_priv *priv = phydev->priv;\n\tint err;\n\n\terr = genphy_read_abilities(phydev);\n\tif (err)\n\t\treturn err;\n\n\tif (phydev->drv->phy_id != ATH8031_PHY_ID)\n\t\treturn 0;\n\n\t \n\tif (!priv->is_1000basex)\n\t\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT,\n\t\t\t\t   phydev->supported);\n\n\treturn 0;\n}\n\nstatic int at803x_smarteee_config(struct phy_device *phydev)\n{\n\tstruct at803x_priv *priv = phydev->priv;\n\tu16 mask = 0, val = 0;\n\tint ret;\n\n\tif (priv->flags & AT803X_DISABLE_SMARTEEE)\n\t\treturn phy_modify_mmd(phydev, MDIO_MMD_PCS,\n\t\t\t\t      AT803X_MMD3_SMARTEEE_CTL3,\n\t\t\t\t      AT803X_MMD3_SMARTEEE_CTL3_LPI_EN, 0);\n\n\tif (priv->smarteee_lpi_tw_1g) {\n\t\tmask |= 0xff00;\n\t\tval |= priv->smarteee_lpi_tw_1g << 8;\n\t}\n\tif (priv->smarteee_lpi_tw_100m) {\n\t\tmask |= 0x00ff;\n\t\tval |= priv->smarteee_lpi_tw_100m;\n\t}\n\tif (!mask)\n\t\treturn 0;\n\n\tret = phy_modify_mmd(phydev, MDIO_MMD_PCS, AT803X_MMD3_SMARTEEE_CTL1,\n\t\t\t     mask, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn phy_modify_mmd(phydev, MDIO_MMD_PCS, AT803X_MMD3_SMARTEEE_CTL3,\n\t\t\t      AT803X_MMD3_SMARTEEE_CTL3_LPI_EN,\n\t\t\t      AT803X_MMD3_SMARTEEE_CTL3_LPI_EN);\n}\n\nstatic int at803x_clk_out_config(struct phy_device *phydev)\n{\n\tstruct at803x_priv *priv = phydev->priv;\n\n\tif (!priv->clk_25m_mask)\n\t\treturn 0;\n\n\treturn phy_modify_mmd(phydev, MDIO_MMD_AN, AT803X_MMD7_CLK25M,\n\t\t\t      priv->clk_25m_mask, priv->clk_25m_reg);\n}\n\nstatic int at8031_pll_config(struct phy_device *phydev)\n{\n\tstruct at803x_priv *priv = phydev->priv;\n\n\t \n\tif (priv->flags & AT803X_KEEP_PLL_ENABLED)\n\t\treturn at803x_debug_reg_mask(phydev, AT803X_DEBUG_REG_1F,\n\t\t\t\t\t     0, AT803X_DEBUG_PLL_ON);\n\telse\n\t\treturn at803x_debug_reg_mask(phydev, AT803X_DEBUG_REG_1F,\n\t\t\t\t\t     AT803X_DEBUG_PLL_ON, 0);\n}\n\nstatic int at803x_hibernation_mode_config(struct phy_device *phydev)\n{\n\tstruct at803x_priv *priv = phydev->priv;\n\n\t \n\tif (!(priv->flags & AT803X_DISABLE_HIBERNATION_MODE))\n\t\treturn 0;\n\n\treturn at803x_debug_reg_mask(phydev, AT803X_DEBUG_REG_HIB_CTRL,\n\t\t\t\t\t AT803X_DEBUG_HIB_CTRL_PS_HIB_EN, 0);\n}\n\nstatic int at803x_config_init(struct phy_device *phydev)\n{\n\tstruct at803x_priv *priv = phydev->priv;\n\tint ret;\n\n\tif (phydev->drv->phy_id == ATH8031_PHY_ID) {\n\t\t \n\t\tphy_lock_mdio_bus(phydev);\n\t\tret = at803x_write_page(phydev,\n\t\t\t\t\tpriv->is_fiber ? AT803X_PAGE_FIBER :\n\t\t\t\t\t\t\t AT803X_PAGE_COPPER);\n\t\tphy_unlock_mdio_bus(phydev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = at8031_pll_config(phydev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID ||\n\t    phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID)\n\t\tret = at803x_enable_rx_delay(phydev);\n\telse\n\t\tret = at803x_disable_rx_delay(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID ||\n\t    phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID)\n\t\tret = at803x_enable_tx_delay(phydev);\n\telse\n\t\tret = at803x_disable_tx_delay(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = at803x_smarteee_config(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = at803x_clk_out_config(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = at803x_hibernation_mode_config(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn phy_modify(phydev, MII_ADVERTISE, MDIO_AN_CTRL1_XNP, 0);\n}\n\nstatic int at803x_ack_interrupt(struct phy_device *phydev)\n{\n\tint err;\n\n\terr = phy_read(phydev, AT803X_INTR_STATUS);\n\n\treturn (err < 0) ? err : 0;\n}\n\nstatic int at803x_config_intr(struct phy_device *phydev)\n{\n\tstruct at803x_priv *priv = phydev->priv;\n\tint err;\n\tint value;\n\n\tvalue = phy_read(phydev, AT803X_INTR_ENABLE);\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\t \n\t\terr = at803x_ack_interrupt(phydev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tvalue |= AT803X_INTR_ENABLE_AUTONEG_ERR;\n\t\tvalue |= AT803X_INTR_ENABLE_SPEED_CHANGED;\n\t\tvalue |= AT803X_INTR_ENABLE_DUPLEX_CHANGED;\n\t\tvalue |= AT803X_INTR_ENABLE_LINK_FAIL;\n\t\tvalue |= AT803X_INTR_ENABLE_LINK_SUCCESS;\n\t\tif (priv->is_fiber) {\n\t\t\tvalue |= AT803X_INTR_ENABLE_LINK_FAIL_BX;\n\t\t\tvalue |= AT803X_INTR_ENABLE_LINK_SUCCESS_BX;\n\t\t}\n\n\t\terr = phy_write(phydev, AT803X_INTR_ENABLE, value);\n\t} else {\n\t\terr = phy_write(phydev, AT803X_INTR_ENABLE, 0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\terr = at803x_ack_interrupt(phydev);\n\t}\n\n\treturn err;\n}\n\nstatic irqreturn_t at803x_handle_interrupt(struct phy_device *phydev)\n{\n\tint irq_status, int_enabled;\n\n\tirq_status = phy_read(phydev, AT803X_INTR_STATUS);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tint_enabled = phy_read(phydev, AT803X_INTR_ENABLE);\n\tif (int_enabled < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tif (!(irq_status & int_enabled))\n\t\treturn IRQ_NONE;\n\n\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void at803x_link_change_notify(struct phy_device *phydev)\n{\n\t \n\tif (phydev->state == PHY_NOLINK && phydev->mdio.reset_gpio) {\n\t\tstruct at803x_context context;\n\n\t\tat803x_context_save(phydev, &context);\n\n\t\tphy_device_reset(phydev, 1);\n\t\tmsleep(1);\n\t\tphy_device_reset(phydev, 0);\n\t\tmsleep(1);\n\n\t\tat803x_context_restore(phydev, &context);\n\n\t\tphydev_dbg(phydev, \"%s(): phy was reset\\n\", __func__);\n\t}\n}\n\nstatic int at803x_read_specific_status(struct phy_device *phydev)\n{\n\tint ss;\n\n\t \n\tss = phy_read(phydev, AT803X_SPECIFIC_STATUS);\n\tif (ss < 0)\n\t\treturn ss;\n\n\tif (ss & AT803X_SS_SPEED_DUPLEX_RESOLVED) {\n\t\tint sfc, speed;\n\n\t\tsfc = phy_read(phydev, AT803X_SPECIFIC_FUNCTION_CONTROL);\n\t\tif (sfc < 0)\n\t\t\treturn sfc;\n\n\t\t \n\t\tif (phydev->drv->phy_id == QCA8081_PHY_ID)\n\t\t\tspeed = FIELD_GET(QCA808X_SS_SPEED_MASK, ss);\n\t\telse\n\t\t\tspeed = FIELD_GET(AT803X_SS_SPEED_MASK, ss);\n\n\t\tswitch (speed) {\n\t\tcase AT803X_SS_SPEED_10:\n\t\t\tphydev->speed = SPEED_10;\n\t\t\tbreak;\n\t\tcase AT803X_SS_SPEED_100:\n\t\t\tphydev->speed = SPEED_100;\n\t\t\tbreak;\n\t\tcase AT803X_SS_SPEED_1000:\n\t\t\tphydev->speed = SPEED_1000;\n\t\t\tbreak;\n\t\tcase QCA808X_SS_SPEED_2500:\n\t\t\tphydev->speed = SPEED_2500;\n\t\t\tbreak;\n\t\t}\n\t\tif (ss & AT803X_SS_DUPLEX)\n\t\t\tphydev->duplex = DUPLEX_FULL;\n\t\telse\n\t\t\tphydev->duplex = DUPLEX_HALF;\n\n\t\tif (ss & AT803X_SS_MDIX)\n\t\t\tphydev->mdix = ETH_TP_MDI_X;\n\t\telse\n\t\t\tphydev->mdix = ETH_TP_MDI;\n\n\t\tswitch (FIELD_GET(AT803X_SFC_MDI_CROSSOVER_MODE_M, sfc)) {\n\t\tcase AT803X_SFC_MANUAL_MDI:\n\t\t\tphydev->mdix_ctrl = ETH_TP_MDI;\n\t\t\tbreak;\n\t\tcase AT803X_SFC_MANUAL_MDIX:\n\t\t\tphydev->mdix_ctrl = ETH_TP_MDI_X;\n\t\t\tbreak;\n\t\tcase AT803X_SFC_AUTOMATIC_CROSSOVER:\n\t\t\tphydev->mdix_ctrl = ETH_TP_MDI_AUTO;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int at803x_read_status(struct phy_device *phydev)\n{\n\tstruct at803x_priv *priv = phydev->priv;\n\tint err, old_link = phydev->link;\n\n\tif (priv->is_1000basex)\n\t\treturn genphy_c37_read_status(phydev);\n\n\t \n\terr = genphy_update_link(phydev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (phydev->autoneg == AUTONEG_ENABLE && old_link && phydev->link)\n\t\treturn 0;\n\n\tphydev->speed = SPEED_UNKNOWN;\n\tphydev->duplex = DUPLEX_UNKNOWN;\n\tphydev->pause = 0;\n\tphydev->asym_pause = 0;\n\n\terr = genphy_read_lpa(phydev);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = at803x_read_specific_status(phydev);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (phydev->autoneg == AUTONEG_ENABLE && phydev->autoneg_complete)\n\t\tphy_resolve_aneg_pause(phydev);\n\n\treturn 0;\n}\n\nstatic int at803x_config_mdix(struct phy_device *phydev, u8 ctrl)\n{\n\tu16 val;\n\n\tswitch (ctrl) {\n\tcase ETH_TP_MDI:\n\t\tval = AT803X_SFC_MANUAL_MDI;\n\t\tbreak;\n\tcase ETH_TP_MDI_X:\n\t\tval = AT803X_SFC_MANUAL_MDIX;\n\t\tbreak;\n\tcase ETH_TP_MDI_AUTO:\n\t\tval = AT803X_SFC_AUTOMATIC_CROSSOVER;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn phy_modify_changed(phydev, AT803X_SPECIFIC_FUNCTION_CONTROL,\n\t\t\t  AT803X_SFC_MDI_CROSSOVER_MODE_M,\n\t\t\t  FIELD_PREP(AT803X_SFC_MDI_CROSSOVER_MODE_M, val));\n}\n\nstatic int at803x_config_aneg(struct phy_device *phydev)\n{\n\tstruct at803x_priv *priv = phydev->priv;\n\tint ret;\n\n\tret = at803x_config_mdix(phydev, phydev->mdix_ctrl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (ret == 1) {\n\t\tret = genphy_soft_reset(phydev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (priv->is_1000basex)\n\t\treturn genphy_c37_config_aneg(phydev);\n\n\t \n\tret = 0;\n\n\tif (phydev->drv->phy_id == QCA8081_PHY_ID) {\n\t\tint phy_ctrl = 0;\n\n\t\t \n\t\tif (phydev->autoneg == AUTONEG_DISABLE)\n\t\t\tgenphy_c45_pma_setup_forced(phydev);\n\n\t\tif (linkmode_test_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT, phydev->advertising))\n\t\t\tphy_ctrl = MDIO_AN_10GBT_CTRL_ADV2_5G;\n\n\t\tret = phy_modify_mmd_changed(phydev, MDIO_MMD_AN, MDIO_AN_10GBT_CTRL,\n\t\t\t\tMDIO_AN_10GBT_CTRL_ADV2_5G, phy_ctrl);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn __genphy_config_aneg(phydev, ret);\n}\n\nstatic int at803x_get_downshift(struct phy_device *phydev, u8 *d)\n{\n\tint val;\n\n\tval = phy_read(phydev, AT803X_SMART_SPEED);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (val & AT803X_SMART_SPEED_ENABLE)\n\t\t*d = FIELD_GET(AT803X_SMART_SPEED_RETRY_LIMIT_MASK, val) + 2;\n\telse\n\t\t*d = DOWNSHIFT_DEV_DISABLE;\n\n\treturn 0;\n}\n\nstatic int at803x_set_downshift(struct phy_device *phydev, u8 cnt)\n{\n\tu16 mask, set;\n\tint ret;\n\n\tswitch (cnt) {\n\tcase DOWNSHIFT_DEV_DEFAULT_COUNT:\n\t\tcnt = AT803X_DEFAULT_DOWNSHIFT;\n\t\tfallthrough;\n\tcase AT803X_MIN_DOWNSHIFT ... AT803X_MAX_DOWNSHIFT:\n\t\tset = AT803X_SMART_SPEED_ENABLE |\n\t\t      AT803X_SMART_SPEED_BYPASS_TIMER |\n\t\t      FIELD_PREP(AT803X_SMART_SPEED_RETRY_LIMIT_MASK, cnt - 2);\n\t\tmask = AT803X_SMART_SPEED_RETRY_LIMIT_MASK;\n\t\tbreak;\n\tcase DOWNSHIFT_DEV_DISABLE:\n\t\tset = 0;\n\t\tmask = AT803X_SMART_SPEED_ENABLE |\n\t\t       AT803X_SMART_SPEED_BYPASS_TIMER;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = phy_modify_changed(phydev, AT803X_SMART_SPEED, mask, set);\n\n\t \n\tif (ret == 1)\n\t\tret = phy_init_hw(phydev);\n\n\treturn ret;\n}\n\nstatic int at803x_get_tunable(struct phy_device *phydev,\n\t\t\t      struct ethtool_tunable *tuna, void *data)\n{\n\tswitch (tuna->id) {\n\tcase ETHTOOL_PHY_DOWNSHIFT:\n\t\treturn at803x_get_downshift(phydev, data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int at803x_set_tunable(struct phy_device *phydev,\n\t\t\t      struct ethtool_tunable *tuna, const void *data)\n{\n\tswitch (tuna->id) {\n\tcase ETHTOOL_PHY_DOWNSHIFT:\n\t\treturn at803x_set_downshift(phydev, *(const u8 *)data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int at803x_cable_test_result_trans(u16 status)\n{\n\tswitch (FIELD_GET(AT803X_CDT_STATUS_STAT_MASK, status)) {\n\tcase AT803X_CDT_STATUS_STAT_NORMAL:\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_OK;\n\tcase AT803X_CDT_STATUS_STAT_SHORT:\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_SAME_SHORT;\n\tcase AT803X_CDT_STATUS_STAT_OPEN:\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_OPEN;\n\tcase AT803X_CDT_STATUS_STAT_FAIL:\n\tdefault:\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_UNSPEC;\n\t}\n}\n\nstatic bool at803x_cdt_test_failed(u16 status)\n{\n\treturn FIELD_GET(AT803X_CDT_STATUS_STAT_MASK, status) ==\n\t\tAT803X_CDT_STATUS_STAT_FAIL;\n}\n\nstatic bool at803x_cdt_fault_length_valid(u16 status)\n{\n\tswitch (FIELD_GET(AT803X_CDT_STATUS_STAT_MASK, status)) {\n\tcase AT803X_CDT_STATUS_STAT_OPEN:\n\tcase AT803X_CDT_STATUS_STAT_SHORT:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int at803x_cdt_fault_length(u16 status)\n{\n\tint dt;\n\n\t \n\tdt = FIELD_GET(AT803X_CDT_STATUS_DELTA_TIME_MASK, status);\n\n\treturn (dt * 824) / 10;\n}\n\nstatic int at803x_cdt_start(struct phy_device *phydev, int pair)\n{\n\tu16 cdt;\n\n\t \n\tif (phydev->drv->phy_id == QCA8081_PHY_ID)\n\t\tcdt = QCA808X_CDT_ENABLE_TEST |\n\t\t\tQCA808X_CDT_LENGTH_UNIT |\n\t\t\tQCA808X_CDT_INTER_CHECK_DIS;\n\telse\n\t\tcdt = FIELD_PREP(AT803X_CDT_MDI_PAIR_MASK, pair) |\n\t\t\tAT803X_CDT_ENABLE_TEST;\n\n\treturn phy_write(phydev, AT803X_CDT, cdt);\n}\n\nstatic int at803x_cdt_wait_for_completion(struct phy_device *phydev)\n{\n\tint val, ret;\n\tu16 cdt_en;\n\n\tif (phydev->drv->phy_id == QCA8081_PHY_ID)\n\t\tcdt_en = QCA808X_CDT_ENABLE_TEST;\n\telse\n\t\tcdt_en = AT803X_CDT_ENABLE_TEST;\n\n\t \n\tret = phy_read_poll_timeout(phydev, AT803X_CDT, val,\n\t\t\t\t    !(val & cdt_en),\n\t\t\t\t    30000, 100000, true);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int at803x_cable_test_one_pair(struct phy_device *phydev, int pair)\n{\n\tstatic const int ethtool_pair[] = {\n\t\tETHTOOL_A_CABLE_PAIR_A,\n\t\tETHTOOL_A_CABLE_PAIR_B,\n\t\tETHTOOL_A_CABLE_PAIR_C,\n\t\tETHTOOL_A_CABLE_PAIR_D,\n\t};\n\tint ret, val;\n\n\tret = at803x_cdt_start(phydev, pair);\n\tif (ret)\n\t\treturn ret;\n\n\tret = at803x_cdt_wait_for_completion(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tval = phy_read(phydev, AT803X_CDT_STATUS);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (at803x_cdt_test_failed(val))\n\t\treturn 0;\n\n\tethnl_cable_test_result(phydev, ethtool_pair[pair],\n\t\t\t\tat803x_cable_test_result_trans(val));\n\n\tif (at803x_cdt_fault_length_valid(val))\n\t\tethnl_cable_test_fault_length(phydev, ethtool_pair[pair],\n\t\t\t\t\t      at803x_cdt_fault_length(val));\n\n\treturn 1;\n}\n\nstatic int at803x_cable_test_get_status(struct phy_device *phydev,\n\t\t\t\t\tbool *finished)\n{\n\tunsigned long pair_mask;\n\tint retries = 20;\n\tint pair, ret;\n\n\tif (phydev->phy_id == ATH9331_PHY_ID ||\n\t    phydev->phy_id == ATH8032_PHY_ID ||\n\t    phydev->phy_id == QCA9561_PHY_ID)\n\t\tpair_mask = 0x3;\n\telse\n\t\tpair_mask = 0xf;\n\n\t*finished = false;\n\n\t \n\twhile (pair_mask && retries--) {\n\t\tfor_each_set_bit(pair, &pair_mask, 4) {\n\t\t\tret = at803x_cable_test_one_pair(phydev, pair);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret)\n\t\t\t\tclear_bit(pair, &pair_mask);\n\t\t}\n\t\tif (pair_mask)\n\t\t\tmsleep(250);\n\t}\n\n\t*finished = true;\n\n\treturn 0;\n}\n\nstatic int at803x_cable_test_start(struct phy_device *phydev)\n{\n\t \n\tphy_write(phydev, MII_BMCR, BMCR_ANENABLE);\n\tphy_write(phydev, MII_ADVERTISE, ADVERTISE_CSMA);\n\tif (phydev->phy_id != ATH9331_PHY_ID &&\n\t    phydev->phy_id != ATH8032_PHY_ID &&\n\t    phydev->phy_id != QCA9561_PHY_ID)\n\t\tphy_write(phydev, MII_CTRL1000, 0);\n\n\t \n\treturn 0;\n}\n\nstatic int qca83xx_config_init(struct phy_device *phydev)\n{\n\tu8 switch_revision;\n\n\tswitch_revision = phydev->dev_flags & QCA8K_DEVFLAGS_REVISION_MASK;\n\n\tswitch (switch_revision) {\n\tcase 1:\n\t\t \n\t\tat803x_debug_reg_write(phydev, AT803X_DEBUG_ANALOG_TEST_CTRL, 0x02ea);\n\t\t \n\t\tat803x_debug_reg_write(phydev, AT803X_DEBUG_REG_GREEN, 0x68a0);\n\t\tbreak;\n\n\tcase 2:\n\t\tphy_write_mmd(phydev, MDIO_MMD_AN, MDIO_AN_EEE_ADV, 0x0);\n\t\tfallthrough;\n\tcase 4:\n\t\tphy_write_mmd(phydev, MDIO_MMD_PCS, MDIO_AZ_DEBUG, 0x803f);\n\t\tat803x_debug_reg_write(phydev, AT803X_DEBUG_REG_GREEN, 0x6860);\n\t\tat803x_debug_reg_write(phydev, AT803X_DEBUG_SYSTEM_CTRL_MODE, 0x2c46);\n\t\tat803x_debug_reg_write(phydev, AT803X_DEBUG_REG_3C, 0x6000);\n\t\tbreak;\n\t}\n\n\t \n\tif (phydev->drv->phy_id == QCA8327_A_PHY_ID ||\n\t    phydev->drv->phy_id == QCA8327_B_PHY_ID)\n\t\tat803x_debug_reg_mask(phydev, AT803X_DEBUG_ANALOG_TEST_CTRL,\n\t\t\t\t      QCA8327_DEBUG_MANU_CTRL_EN, 0);\n\n\t \n\tphy_set_bits(phydev, MII_CTRL1000, CTL1000_PREFER_MASTER);\n\n\treturn 0;\n}\n\nstatic void qca83xx_link_change_notify(struct phy_device *phydev)\n{\n\t \n\tif (phydev->drv->phy_id == QCA8337_PHY_ID)\n\t\treturn;\n\n\t \n\tif (phydev->state == PHY_RUNNING) {\n\t\tif (phydev->speed == SPEED_100)\n\t\t\tat803x_debug_reg_mask(phydev, AT803X_DEBUG_ANALOG_TEST_CTRL,\n\t\t\t\t\t      QCA8327_DEBUG_MANU_CTRL_EN,\n\t\t\t\t\t      QCA8327_DEBUG_MANU_CTRL_EN);\n\t} else {\n\t\t \n\t\tat803x_debug_reg_mask(phydev, AT803X_DEBUG_ANALOG_TEST_CTRL,\n\t\t\t\t      QCA8327_DEBUG_MANU_CTRL_EN, 0);\n\t}\n}\n\nstatic int qca83xx_resume(struct phy_device *phydev)\n{\n\tint ret, val;\n\n\t \n\tif (!phydev->suspended)\n\t\treturn 0;\n\n\t \n\tqca83xx_config_init(phydev);\n\n\t \n\tphy_set_bits(phydev, MII_BMCR, BMCR_RESET | BMCR_ANENABLE);\n\n\t \n\tret = phy_read_poll_timeout(phydev, MII_BMCR, val, !(val & BMCR_RESET),\n\t\t\t\t    50000, 600000, true);\n\tif (ret)\n\t\treturn ret;\n\n\tmsleep(1);\n\n\treturn 0;\n}\n\nstatic int qca83xx_suspend(struct phy_device *phydev)\n{\n\tu16 mask = 0;\n\n\t \n\tif (phydev->drv->phy_id == QCA8337_PHY_ID) {\n\t\tgenphy_suspend(phydev);\n\t} else {\n\t\tmask |= ~(BMCR_SPEED1000 | BMCR_FULLDPLX);\n\t\tphy_modify(phydev, MII_BMCR, mask, 0);\n\t}\n\n\tat803x_debug_reg_mask(phydev, AT803X_DEBUG_REG_GREEN,\n\t\t\t      AT803X_DEBUG_GATE_CLK_IN1000, 0);\n\n\tat803x_debug_reg_mask(phydev, AT803X_DEBUG_REG_HIB_CTRL,\n\t\t\t      AT803X_DEBUG_HIB_CTRL_EN_ANY_CHANGE |\n\t\t\t      AT803X_DEBUG_HIB_CTRL_SEL_RST_80U, 0);\n\n\treturn 0;\n}\n\nstatic int qca808x_phy_fast_retrain_config(struct phy_device *phydev)\n{\n\tint ret;\n\n\t \n\tret = genphy_c45_fast_retrain(phydev, true);\n\tif (ret)\n\t\treturn ret;\n\n\tphy_write_mmd(phydev, MDIO_MMD_AN, QCA808X_PHY_MMD7_TOP_OPTION1,\n\t\t\tQCA808X_TOP_OPTION1_DATA);\n\tphy_write_mmd(phydev, MDIO_MMD_PMAPMD, QCA808X_PHY_MMD1_MSE_THRESHOLD_20DB,\n\t\t\tQCA808X_MSE_THRESHOLD_20DB_VALUE);\n\tphy_write_mmd(phydev, MDIO_MMD_PMAPMD, QCA808X_PHY_MMD1_MSE_THRESHOLD_17DB,\n\t\t\tQCA808X_MSE_THRESHOLD_17DB_VALUE);\n\tphy_write_mmd(phydev, MDIO_MMD_PMAPMD, QCA808X_PHY_MMD1_MSE_THRESHOLD_27DB,\n\t\t\tQCA808X_MSE_THRESHOLD_27DB_VALUE);\n\tphy_write_mmd(phydev, MDIO_MMD_PMAPMD, QCA808X_PHY_MMD1_MSE_THRESHOLD_28DB,\n\t\t\tQCA808X_MSE_THRESHOLD_28DB_VALUE);\n\tphy_write_mmd(phydev, MDIO_MMD_PCS, QCA808X_PHY_MMD3_DEBUG_1,\n\t\t\tQCA808X_MMD3_DEBUG_1_VALUE);\n\tphy_write_mmd(phydev, MDIO_MMD_PCS, QCA808X_PHY_MMD3_DEBUG_4,\n\t\t\tQCA808X_MMD3_DEBUG_4_VALUE);\n\tphy_write_mmd(phydev, MDIO_MMD_PCS, QCA808X_PHY_MMD3_DEBUG_5,\n\t\t\tQCA808X_MMD3_DEBUG_5_VALUE);\n\tphy_write_mmd(phydev, MDIO_MMD_PCS, QCA808X_PHY_MMD3_DEBUG_3,\n\t\t\tQCA808X_MMD3_DEBUG_3_VALUE);\n\tphy_write_mmd(phydev, MDIO_MMD_PCS, QCA808X_PHY_MMD3_DEBUG_6,\n\t\t\tQCA808X_MMD3_DEBUG_6_VALUE);\n\tphy_write_mmd(phydev, MDIO_MMD_PCS, QCA808X_PHY_MMD3_DEBUG_2,\n\t\t\tQCA808X_MMD3_DEBUG_2_VALUE);\n\n\treturn 0;\n}\n\nstatic int qca808x_phy_ms_seed_enable(struct phy_device *phydev, bool enable)\n{\n\tu16 seed_value;\n\n\tif (!enable)\n\t\treturn at803x_debug_reg_mask(phydev, QCA808X_PHY_DEBUG_LOCAL_SEED,\n\t\t\t\tQCA808X_MASTER_SLAVE_SEED_ENABLE, 0);\n\n\tseed_value = get_random_u32_below(QCA808X_MASTER_SLAVE_SEED_RANGE);\n\treturn at803x_debug_reg_mask(phydev, QCA808X_PHY_DEBUG_LOCAL_SEED,\n\t\t\tQCA808X_MASTER_SLAVE_SEED_CFG | QCA808X_MASTER_SLAVE_SEED_ENABLE,\n\t\t\tFIELD_PREP(QCA808X_MASTER_SLAVE_SEED_CFG, seed_value) |\n\t\t\tQCA808X_MASTER_SLAVE_SEED_ENABLE);\n}\n\nstatic bool qca808x_is_prefer_master(struct phy_device *phydev)\n{\n\treturn (phydev->master_slave_get == MASTER_SLAVE_CFG_MASTER_FORCE) ||\n\t\t(phydev->master_slave_get == MASTER_SLAVE_CFG_MASTER_PREFERRED);\n}\n\nstatic bool qca808x_has_fast_retrain_or_slave_seed(struct phy_device *phydev)\n{\n\treturn linkmode_test_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT, phydev->supported);\n}\n\nstatic int qca808x_config_init(struct phy_device *phydev)\n{\n\tint ret;\n\n\t \n\tret = phy_modify_mmd(phydev, MDIO_MMD_PCS, QCA808X_PHY_MMD3_ADDR_CLD_CTRL7,\n\t\t\tQCA808X_8023AZ_AFE_CTRL_MASK, QCA808X_8023AZ_AFE_EN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = phy_write_mmd(phydev, MDIO_MMD_PCS,\n\t\t\tQCA808X_PHY_MMD3_AZ_TRAINING_CTRL, QCA808X_MMD3_AZ_TRAINING_VAL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (qca808x_has_fast_retrain_or_slave_seed(phydev)) {\n\t\t \n\t\tret = qca808x_phy_fast_retrain_config(phydev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = genphy_read_master_slave(phydev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (!qca808x_is_prefer_master(phydev)) {\n\t\t\t \n\t\t\tret = qca808x_phy_ms_seed_enable(phydev, true);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\treturn at803x_debug_reg_mask(phydev, QCA808X_PHY_DEBUG_ADC_THRESHOLD,\n\t\t\tQCA808X_ADC_THRESHOLD_MASK, QCA808X_ADC_THRESHOLD_100MV);\n}\n\nstatic int qca808x_read_status(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_10GBT_STAT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT, phydev->lp_advertising,\n\t\t\tret & MDIO_AN_10GBT_STAT_LP2_5G);\n\n\tret = genphy_read_status(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = at803x_read_specific_status(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (phydev->link) {\n\t\tif (phydev->speed == SPEED_2500)\n\t\t\tphydev->interface = PHY_INTERFACE_MODE_2500BASEX;\n\t\telse\n\t\t\tphydev->interface = PHY_INTERFACE_MODE_SGMII;\n\t} else {\n\t\t \n\t\tif (qca808x_has_fast_retrain_or_slave_seed(phydev)) {\n\t\t\tif (phydev->master_slave_state == MASTER_SLAVE_STATE_ERR ||\n\t\t\t\t\tqca808x_is_prefer_master(phydev)) {\n\t\t\t\tqca808x_phy_ms_seed_enable(phydev, false);\n\t\t\t} else {\n\t\t\t\tqca808x_phy_ms_seed_enable(phydev, true);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int qca808x_soft_reset(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = genphy_soft_reset(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (qca808x_has_fast_retrain_or_slave_seed(phydev))\n\t\tret = qca808x_phy_ms_seed_enable(phydev, true);\n\n\treturn ret;\n}\n\nstatic bool qca808x_cdt_fault_length_valid(int cdt_code)\n{\n\tswitch (cdt_code) {\n\tcase QCA808X_CDT_STATUS_STAT_SHORT:\n\tcase QCA808X_CDT_STATUS_STAT_OPEN:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int qca808x_cable_test_result_trans(int cdt_code)\n{\n\tswitch (cdt_code) {\n\tcase QCA808X_CDT_STATUS_STAT_NORMAL:\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_OK;\n\tcase QCA808X_CDT_STATUS_STAT_SHORT:\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_SAME_SHORT;\n\tcase QCA808X_CDT_STATUS_STAT_OPEN:\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_OPEN;\n\tcase QCA808X_CDT_STATUS_STAT_FAIL:\n\tdefault:\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_UNSPEC;\n\t}\n}\n\nstatic int qca808x_cdt_fault_length(struct phy_device *phydev, int pair)\n{\n\tint val;\n\tu32 cdt_length_reg = 0;\n\n\tswitch (pair) {\n\tcase ETHTOOL_A_CABLE_PAIR_A:\n\t\tcdt_length_reg = QCA808X_MMD3_CDT_DIAG_PAIR_A;\n\t\tbreak;\n\tcase ETHTOOL_A_CABLE_PAIR_B:\n\t\tcdt_length_reg = QCA808X_MMD3_CDT_DIAG_PAIR_B;\n\t\tbreak;\n\tcase ETHTOOL_A_CABLE_PAIR_C:\n\t\tcdt_length_reg = QCA808X_MMD3_CDT_DIAG_PAIR_C;\n\t\tbreak;\n\tcase ETHTOOL_A_CABLE_PAIR_D:\n\t\tcdt_length_reg = QCA808X_MMD3_CDT_DIAG_PAIR_D;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tval = phy_read_mmd(phydev, MDIO_MMD_PCS, cdt_length_reg);\n\tif (val < 0)\n\t\treturn val;\n\n\treturn (FIELD_GET(QCA808X_CDT_DIAG_LENGTH, val) * 824) / 10;\n}\n\nstatic int qca808x_cable_test_start(struct phy_device *phydev)\n{\n\tint ret;\n\n\t \n\n\tret = at803x_debug_reg_mask(phydev, QCA808X_DBG_AN_TEST, QCA808X_HIBERNATION_EN, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = at803x_config_mdix(phydev, ETH_TP_MDI);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tphydev->duplex = DUPLEX_FULL;\n\tphydev->speed = SPEED_1000;\n\tret = genphy_c45_pma_setup_forced(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = genphy_setup_forced(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tphy_write_mmd(phydev, MDIO_MMD_PCS, 0x8074, 0xc040);\n\tphy_write_mmd(phydev, MDIO_MMD_PCS, 0x8076, 0xc040);\n\tphy_write_mmd(phydev, MDIO_MMD_PCS, 0x8077, 0xa060);\n\tphy_write_mmd(phydev, MDIO_MMD_PCS, 0x8078, 0xc050);\n\tphy_write_mmd(phydev, MDIO_MMD_PCS, 0x807a, 0xc060);\n\tphy_write_mmd(phydev, MDIO_MMD_PCS, 0x807e, 0xb060);\n\n\treturn 0;\n}\n\nstatic int qca808x_cable_test_get_status(struct phy_device *phydev, bool *finished)\n{\n\tint ret, val;\n\tint pair_a, pair_b, pair_c, pair_d;\n\n\t*finished = false;\n\n\tret = at803x_cdt_start(phydev, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = at803x_cdt_wait_for_completion(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tval = phy_read_mmd(phydev, MDIO_MMD_PCS, QCA808X_MMD3_CDT_STATUS);\n\tif (val < 0)\n\t\treturn val;\n\n\tpair_a = FIELD_GET(QCA808X_CDT_CODE_PAIR_A, val);\n\tpair_b = FIELD_GET(QCA808X_CDT_CODE_PAIR_B, val);\n\tpair_c = FIELD_GET(QCA808X_CDT_CODE_PAIR_C, val);\n\tpair_d = FIELD_GET(QCA808X_CDT_CODE_PAIR_D, val);\n\n\tethnl_cable_test_result(phydev, ETHTOOL_A_CABLE_PAIR_A,\n\t\t\t\tqca808x_cable_test_result_trans(pair_a));\n\tethnl_cable_test_result(phydev, ETHTOOL_A_CABLE_PAIR_B,\n\t\t\t\tqca808x_cable_test_result_trans(pair_b));\n\tethnl_cable_test_result(phydev, ETHTOOL_A_CABLE_PAIR_C,\n\t\t\t\tqca808x_cable_test_result_trans(pair_c));\n\tethnl_cable_test_result(phydev, ETHTOOL_A_CABLE_PAIR_D,\n\t\t\t\tqca808x_cable_test_result_trans(pair_d));\n\n\tif (qca808x_cdt_fault_length_valid(pair_a))\n\t\tethnl_cable_test_fault_length(phydev, ETHTOOL_A_CABLE_PAIR_A,\n\t\t\t\tqca808x_cdt_fault_length(phydev, ETHTOOL_A_CABLE_PAIR_A));\n\tif (qca808x_cdt_fault_length_valid(pair_b))\n\t\tethnl_cable_test_fault_length(phydev, ETHTOOL_A_CABLE_PAIR_B,\n\t\t\t\tqca808x_cdt_fault_length(phydev, ETHTOOL_A_CABLE_PAIR_B));\n\tif (qca808x_cdt_fault_length_valid(pair_c))\n\t\tethnl_cable_test_fault_length(phydev, ETHTOOL_A_CABLE_PAIR_C,\n\t\t\t\tqca808x_cdt_fault_length(phydev, ETHTOOL_A_CABLE_PAIR_C));\n\tif (qca808x_cdt_fault_length_valid(pair_d))\n\t\tethnl_cable_test_fault_length(phydev, ETHTOOL_A_CABLE_PAIR_D,\n\t\t\t\tqca808x_cdt_fault_length(phydev, ETHTOOL_A_CABLE_PAIR_D));\n\n\t*finished = true;\n\n\treturn 0;\n}\n\nstatic int qca808x_get_features(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = genphy_c45_pma_read_abilities(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, phydev->supported);\n\n\t \n\tret = phy_read_mmd(phydev, MDIO_MMD_AN, QCA808X_PHY_MMD7_CHIP_TYPE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (QCA808X_PHY_CHIP_TYPE_1G & ret)\n\t\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT, phydev->supported);\n\n\treturn 0;\n}\n\nstatic void qca808x_link_change_notify(struct phy_device *phydev)\n{\n\t \n\tmdiobus_c45_modify_changed(phydev->mdio.bus, phydev->mdio.addr + 1,\n\t\t\tMDIO_MMD_PMAPMD, QCA8081_PHY_SERDES_MMD1_FIFO_CTRL,\n\t\t\tQCA8081_PHY_FIFO_RSTN, phydev->link ? QCA8081_PHY_FIFO_RSTN : 0);\n}\n\nstatic struct phy_driver at803x_driver[] = {\n{\n\t \n\tPHY_ID_MATCH_EXACT(ATH8035_PHY_ID),\n\t.name\t\t\t= \"Qualcomm Atheros AR8035\",\n\t.flags\t\t\t= PHY_POLL_CABLE_TEST,\n\t.probe\t\t\t= at803x_probe,\n\t.config_aneg\t\t= at803x_config_aneg,\n\t.config_init\t\t= at803x_config_init,\n\t.soft_reset\t\t= genphy_soft_reset,\n\t.set_wol\t\t= at803x_set_wol,\n\t.get_wol\t\t= at803x_get_wol,\n\t.suspend\t\t= at803x_suspend,\n\t.resume\t\t\t= at803x_resume,\n\t \n\t.read_status\t\t= at803x_read_status,\n\t.config_intr\t\t= at803x_config_intr,\n\t.handle_interrupt\t= at803x_handle_interrupt,\n\t.get_tunable\t\t= at803x_get_tunable,\n\t.set_tunable\t\t= at803x_set_tunable,\n\t.cable_test_start\t= at803x_cable_test_start,\n\t.cable_test_get_status\t= at803x_cable_test_get_status,\n}, {\n\t \n\t.phy_id\t\t\t= ATH8030_PHY_ID,\n\t.name\t\t\t= \"Qualcomm Atheros AR8030\",\n\t.phy_id_mask\t\t= AT8030_PHY_ID_MASK,\n\t.probe\t\t\t= at803x_probe,\n\t.config_init\t\t= at803x_config_init,\n\t.link_change_notify\t= at803x_link_change_notify,\n\t.set_wol\t\t= at803x_set_wol,\n\t.get_wol\t\t= at803x_get_wol,\n\t.suspend\t\t= at803x_suspend,\n\t.resume\t\t\t= at803x_resume,\n\t \n\t.config_intr\t\t= at803x_config_intr,\n\t.handle_interrupt\t= at803x_handle_interrupt,\n}, {\n\t \n\tPHY_ID_MATCH_EXACT(ATH8031_PHY_ID),\n\t.name\t\t\t= \"Qualcomm Atheros AR8031/AR8033\",\n\t.flags\t\t\t= PHY_POLL_CABLE_TEST,\n\t.probe\t\t\t= at803x_probe,\n\t.config_init\t\t= at803x_config_init,\n\t.config_aneg\t\t= at803x_config_aneg,\n\t.soft_reset\t\t= genphy_soft_reset,\n\t.set_wol\t\t= at803x_set_wol,\n\t.get_wol\t\t= at803x_get_wol,\n\t.suspend\t\t= at803x_suspend,\n\t.resume\t\t\t= at803x_resume,\n\t.read_page\t\t= at803x_read_page,\n\t.write_page\t\t= at803x_write_page,\n\t.get_features\t\t= at803x_get_features,\n\t.read_status\t\t= at803x_read_status,\n\t.config_intr\t\t= &at803x_config_intr,\n\t.handle_interrupt\t= at803x_handle_interrupt,\n\t.get_tunable\t\t= at803x_get_tunable,\n\t.set_tunable\t\t= at803x_set_tunable,\n\t.cable_test_start\t= at803x_cable_test_start,\n\t.cable_test_get_status\t= at803x_cable_test_get_status,\n}, {\n\t \n\tPHY_ID_MATCH_EXACT(ATH8032_PHY_ID),\n\t.name\t\t\t= \"Qualcomm Atheros AR8032\",\n\t.probe\t\t\t= at803x_probe,\n\t.flags\t\t\t= PHY_POLL_CABLE_TEST,\n\t.config_init\t\t= at803x_config_init,\n\t.link_change_notify\t= at803x_link_change_notify,\n\t.suspend\t\t= at803x_suspend,\n\t.resume\t\t\t= at803x_resume,\n\t \n\t.config_intr\t\t= at803x_config_intr,\n\t.handle_interrupt\t= at803x_handle_interrupt,\n\t.cable_test_start\t= at803x_cable_test_start,\n\t.cable_test_get_status\t= at803x_cable_test_get_status,\n}, {\n\t \n\tPHY_ID_MATCH_EXACT(ATH9331_PHY_ID),\n\t.name\t\t\t= \"Qualcomm Atheros AR9331 built-in PHY\",\n\t.probe\t\t\t= at803x_probe,\n\t.suspend\t\t= at803x_suspend,\n\t.resume\t\t\t= at803x_resume,\n\t.flags\t\t\t= PHY_POLL_CABLE_TEST,\n\t \n\t.config_intr\t\t= &at803x_config_intr,\n\t.handle_interrupt\t= at803x_handle_interrupt,\n\t.cable_test_start\t= at803x_cable_test_start,\n\t.cable_test_get_status\t= at803x_cable_test_get_status,\n\t.read_status\t\t= at803x_read_status,\n\t.soft_reset\t\t= genphy_soft_reset,\n\t.config_aneg\t\t= at803x_config_aneg,\n}, {\n\t \n\tPHY_ID_MATCH_EXACT(QCA9561_PHY_ID),\n\t.name\t\t\t= \"Qualcomm Atheros QCA9561 built-in PHY\",\n\t.probe\t\t\t= at803x_probe,\n\t.suspend\t\t= at803x_suspend,\n\t.resume\t\t\t= at803x_resume,\n\t.flags\t\t\t= PHY_POLL_CABLE_TEST,\n\t \n\t.config_intr\t\t= &at803x_config_intr,\n\t.handle_interrupt\t= at803x_handle_interrupt,\n\t.cable_test_start\t= at803x_cable_test_start,\n\t.cable_test_get_status\t= at803x_cable_test_get_status,\n\t.read_status\t\t= at803x_read_status,\n\t.soft_reset\t\t= genphy_soft_reset,\n\t.config_aneg\t\t= at803x_config_aneg,\n}, {\n\t \n\t.phy_id\t\t\t= QCA8337_PHY_ID,\n\t.phy_id_mask\t\t= QCA8K_PHY_ID_MASK,\n\t.name\t\t\t= \"Qualcomm Atheros 8337 internal PHY\",\n\t \n\t.link_change_notify\t= qca83xx_link_change_notify,\n\t.probe\t\t\t= at803x_probe,\n\t.flags\t\t\t= PHY_IS_INTERNAL,\n\t.config_init\t\t= qca83xx_config_init,\n\t.soft_reset\t\t= genphy_soft_reset,\n\t.get_sset_count\t\t= at803x_get_sset_count,\n\t.get_strings\t\t= at803x_get_strings,\n\t.get_stats\t\t= at803x_get_stats,\n\t.suspend\t\t= qca83xx_suspend,\n\t.resume\t\t\t= qca83xx_resume,\n}, {\n\t \n\t.phy_id\t\t\t= QCA8327_A_PHY_ID,\n\t.phy_id_mask\t\t= QCA8K_PHY_ID_MASK,\n\t.name\t\t\t= \"Qualcomm Atheros 8327-A internal PHY\",\n\t \n\t.link_change_notify\t= qca83xx_link_change_notify,\n\t.probe\t\t\t= at803x_probe,\n\t.flags\t\t\t= PHY_IS_INTERNAL,\n\t.config_init\t\t= qca83xx_config_init,\n\t.soft_reset\t\t= genphy_soft_reset,\n\t.get_sset_count\t\t= at803x_get_sset_count,\n\t.get_strings\t\t= at803x_get_strings,\n\t.get_stats\t\t= at803x_get_stats,\n\t.suspend\t\t= qca83xx_suspend,\n\t.resume\t\t\t= qca83xx_resume,\n}, {\n\t \n\t.phy_id\t\t\t= QCA8327_B_PHY_ID,\n\t.phy_id_mask\t\t= QCA8K_PHY_ID_MASK,\n\t.name\t\t\t= \"Qualcomm Atheros 8327-B internal PHY\",\n\t \n\t.link_change_notify\t= qca83xx_link_change_notify,\n\t.probe\t\t\t= at803x_probe,\n\t.flags\t\t\t= PHY_IS_INTERNAL,\n\t.config_init\t\t= qca83xx_config_init,\n\t.soft_reset\t\t= genphy_soft_reset,\n\t.get_sset_count\t\t= at803x_get_sset_count,\n\t.get_strings\t\t= at803x_get_strings,\n\t.get_stats\t\t= at803x_get_stats,\n\t.suspend\t\t= qca83xx_suspend,\n\t.resume\t\t\t= qca83xx_resume,\n}, {\n\t \n\tPHY_ID_MATCH_EXACT(QCA8081_PHY_ID),\n\t.name\t\t\t= \"Qualcomm QCA8081\",\n\t.flags\t\t\t= PHY_POLL_CABLE_TEST,\n\t.probe\t\t\t= at803x_probe,\n\t.config_intr\t\t= at803x_config_intr,\n\t.handle_interrupt\t= at803x_handle_interrupt,\n\t.get_tunable\t\t= at803x_get_tunable,\n\t.set_tunable\t\t= at803x_set_tunable,\n\t.set_wol\t\t= at803x_set_wol,\n\t.get_wol\t\t= at803x_get_wol,\n\t.get_features\t\t= qca808x_get_features,\n\t.config_aneg\t\t= at803x_config_aneg,\n\t.suspend\t\t= genphy_suspend,\n\t.resume\t\t\t= genphy_resume,\n\t.read_status\t\t= qca808x_read_status,\n\t.config_init\t\t= qca808x_config_init,\n\t.soft_reset\t\t= qca808x_soft_reset,\n\t.cable_test_start\t= qca808x_cable_test_start,\n\t.cable_test_get_status\t= qca808x_cable_test_get_status,\n\t.link_change_notify\t= qca808x_link_change_notify,\n}, };\n\nmodule_phy_driver(at803x_driver);\n\nstatic struct mdio_device_id __maybe_unused atheros_tbl[] = {\n\t{ ATH8030_PHY_ID, AT8030_PHY_ID_MASK },\n\t{ PHY_ID_MATCH_EXACT(ATH8031_PHY_ID) },\n\t{ PHY_ID_MATCH_EXACT(ATH8032_PHY_ID) },\n\t{ PHY_ID_MATCH_EXACT(ATH8035_PHY_ID) },\n\t{ PHY_ID_MATCH_EXACT(ATH9331_PHY_ID) },\n\t{ PHY_ID_MATCH_EXACT(QCA8337_PHY_ID) },\n\t{ PHY_ID_MATCH_EXACT(QCA8327_A_PHY_ID) },\n\t{ PHY_ID_MATCH_EXACT(QCA8327_B_PHY_ID) },\n\t{ PHY_ID_MATCH_EXACT(QCA9561_PHY_ID) },\n\t{ PHY_ID_MATCH_EXACT(QCA8081_PHY_ID) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(mdio, atheros_tbl);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}