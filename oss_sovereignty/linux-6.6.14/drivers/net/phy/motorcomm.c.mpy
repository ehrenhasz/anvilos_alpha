{
  "module_name": "motorcomm.c",
  "hash_id": "6a7785594b427ed2716163873d44caa9f819005711ada178609f826439dfd6e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/motorcomm.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/phy.h>\n#include <linux/of.h>\n\n#define PHY_ID_YT8511\t\t0x0000010a\n#define PHY_ID_YT8521\t\t0x0000011a\n#define PHY_ID_YT8531\t\t0x4f51e91b\n#define PHY_ID_YT8531S\t\t0x4f51e91a\n\n \n\n \n\n \n#define YTPHY_SPECIFIC_FUNCTION_CONTROL_REG\t0x10\n\n \n#define YTPHY_SFCR_MDI_CROSSOVER_MODE_MASK\t(BIT(6) | BIT(5))\n#define YTPHY_SFCR_CROSSOVER_EN\t\t\tBIT(3)\n#define YTPHY_SFCR_SQE_TEST_EN\t\t\tBIT(2)\n#define YTPHY_SFCR_POLARITY_REVERSAL_EN\t\tBIT(1)\n#define YTPHY_SFCR_JABBER_DIS\t\t\tBIT(0)\n\n \n#define YTPHY_SPECIFIC_STATUS_REG\t\t0x11\n#define YTPHY_SSR_SPEED_MODE_OFFSET\t\t14\n\n#define YTPHY_SSR_SPEED_MODE_MASK\t\t(BIT(15) | BIT(14))\n#define YTPHY_SSR_SPEED_10M\t\t\t0x0\n#define YTPHY_SSR_SPEED_100M\t\t\t0x1\n#define YTPHY_SSR_SPEED_1000M\t\t\t0x2\n#define YTPHY_SSR_DUPLEX_OFFSET\t\t\t13\n#define YTPHY_SSR_DUPLEX\t\t\tBIT(13)\n#define YTPHY_SSR_PAGE_RECEIVED\t\t\tBIT(12)\n#define YTPHY_SSR_SPEED_DUPLEX_RESOLVED\t\tBIT(11)\n#define YTPHY_SSR_LINK\t\t\t\tBIT(10)\n#define YTPHY_SSR_MDIX_CROSSOVER\t\tBIT(6)\n#define YTPHY_SSR_DOWNGRADE\t\t\tBIT(5)\n#define YTPHY_SSR_TRANSMIT_PAUSE\t\tBIT(3)\n#define YTPHY_SSR_RECEIVE_PAUSE\t\t\tBIT(2)\n#define YTPHY_SSR_POLARITY\t\t\tBIT(1)\n#define YTPHY_SSR_JABBER\t\t\tBIT(0)\n\n \n#define YTPHY_INTERRUPT_ENABLE_REG\t\t0x12\n#define YTPHY_IER_WOL\t\t\t\tBIT(6)\n\n \n#define YTPHY_INTERRUPT_STATUS_REG\t\t0x13\n#define YTPHY_ISR_AUTONEG_ERR\t\t\tBIT(15)\n#define YTPHY_ISR_SPEED_CHANGED\t\t\tBIT(14)\n#define YTPHY_ISR_DUPLEX_CHANGED\t\tBIT(13)\n#define YTPHY_ISR_PAGE_RECEIVED\t\t\tBIT(12)\n#define YTPHY_ISR_LINK_FAILED\t\t\tBIT(11)\n#define YTPHY_ISR_LINK_SUCCESSED\t\tBIT(10)\n#define YTPHY_ISR_WOL\t\t\t\tBIT(6)\n#define YTPHY_ISR_WIRESPEED_DOWNGRADE\t\tBIT(5)\n#define YTPHY_ISR_SERDES_LINK_FAILED\t\tBIT(3)\n#define YTPHY_ISR_SERDES_LINK_SUCCESSED\t\tBIT(2)\n#define YTPHY_ISR_POLARITY_CHANGED\t\tBIT(1)\n#define YTPHY_ISR_JABBER_HAPPENED\t\tBIT(0)\n\n \n#define YTPHY_SPEED_AUTO_DOWNGRADE_CONTROL_REG\t0x14\n#define YTPHY_SADCR_SPEED_DOWNGRADE_EN\t\tBIT(5)\n\n \n#define YTPHY_SADCR_SPEED_RETRY_LIMIT\t\t(0x3 << 2)\n\n \n#define YTPHY_RX_ERROR_COUNTER_REG\t\t0x15\n\n \n#define YTPHY_PAGE_SELECT\t\t\t0x1E\n\n \n#define YTPHY_PAGE_DATA\t\t\t\t0x1F\n\n \n#define YTPHY_FLPA_PAUSE\t\t\t(0x3 << 7)\n#define YTPHY_FLPA_ASYM_PAUSE\t\t\t(0x2 << 7)\n\n#define YT8511_PAGE_SELECT\t0x1e\n#define YT8511_PAGE\t\t0x1f\n#define YT8511_EXT_CLK_GATE\t0x0c\n#define YT8511_EXT_DELAY_DRIVE\t0x0d\n#define YT8511_EXT_SLEEP_CTRL\t0x27\n\n \n#define YT8511_CLK_125M\t\t(BIT(2) | BIT(1))\n#define YT8511_PLLON_SLP\tBIT(14)\n\n \n#define YT8511_DELAY_RX\t\tBIT(0)\n\n \n#define YT8511_DELAY_GE_TX_EN\t(0xf << 4)\n#define YT8511_DELAY_GE_TX_DIS\t(0x2 << 4)\n#define YT8511_DELAY_FE_TX_EN\t(0xf << 12)\n#define YT8511_DELAY_FE_TX_DIS\t(0x2 << 12)\n\n \n\n \n#define YT8521_CLOCK_GATING_REG\t\t\t0xC\n#define YT8521_CGR_RX_CLK_EN\t\t\tBIT(12)\n\n#define YT8521_EXTREG_SLEEP_CONTROL1_REG\t0x27\n#define YT8521_ESC1R_SLEEP_SW\t\t\tBIT(15)\n#define YT8521_ESC1R_PLLON_SLP\t\t\tBIT(14)\n\n \n#define YT8521_LINK_TIMER_CFG2_REG\t\t0xA5\n#define YT8521_LTCR_EN_AUTOSEN\t\t\tBIT(15)\n\n \n\n#define YT8521_REG_SPACE_SELECT_REG\t\t0xA000\n#define YT8521_RSSR_SPACE_MASK\t\t\tBIT(1)\n#define YT8521_RSSR_FIBER_SPACE\t\t\t(0x1 << 1)\n#define YT8521_RSSR_UTP_SPACE\t\t\t(0x0 << 1)\n#define YT8521_RSSR_TO_BE_ARBITRATED\t\t(0xFF)\n\n#define YT8521_CHIP_CONFIG_REG\t\t\t0xA001\n#define YT8521_CCR_SW_RST\t\t\tBIT(15)\n#define YT8531_RGMII_LDO_VOL_MASK\t\tGENMASK(5, 4)\n#define YT8531_LDO_VOL_3V3\t\t\t0x0\n#define YT8531_LDO_VOL_1V8\t\t\t0x2\n\n \n#define YT8521_CCR_RXC_DLY_EN\t\t\tBIT(8)\n#define YT8521_CCR_RXC_DLY_1_900_NS\t\t1900\n\n#define YT8521_CCR_MODE_SEL_MASK\t\t(BIT(2) | BIT(1) | BIT(0))\n#define YT8521_CCR_MODE_UTP_TO_RGMII\t\t0\n#define YT8521_CCR_MODE_FIBER_TO_RGMII\t\t1\n#define YT8521_CCR_MODE_UTP_FIBER_TO_RGMII\t2\n#define YT8521_CCR_MODE_UTP_TO_SGMII\t\t3\n#define YT8521_CCR_MODE_SGPHY_TO_RGMAC\t\t4\n#define YT8521_CCR_MODE_SGMAC_TO_RGPHY\t\t5\n#define YT8521_CCR_MODE_UTP_TO_FIBER_AUTO\t6\n#define YT8521_CCR_MODE_UTP_TO_FIBER_FORCE\t7\n\n \n#define YT8521_MODE_FIBER\t\t\t0x1\n#define YT8521_MODE_UTP\t\t\t\t0x2\n#define YT8521_MODE_POLL\t\t\t0x3\n\n#define YT8521_RGMII_CONFIG1_REG\t\t0xA003\n \n#define YT8521_RC1R_TX_CLK_SEL_INVERTED\t\tBIT(14)\n#define YT8521_RC1R_RX_DELAY_MASK\t\tGENMASK(13, 10)\n#define YT8521_RC1R_FE_TX_DELAY_MASK\t\tGENMASK(7, 4)\n#define YT8521_RC1R_GE_TX_DELAY_MASK\t\tGENMASK(3, 0)\n#define YT8521_RC1R_RGMII_0_000_NS\t\t0\n#define YT8521_RC1R_RGMII_0_150_NS\t\t1\n#define YT8521_RC1R_RGMII_0_300_NS\t\t2\n#define YT8521_RC1R_RGMII_0_450_NS\t\t3\n#define YT8521_RC1R_RGMII_0_600_NS\t\t4\n#define YT8521_RC1R_RGMII_0_750_NS\t\t5\n#define YT8521_RC1R_RGMII_0_900_NS\t\t6\n#define YT8521_RC1R_RGMII_1_050_NS\t\t7\n#define YT8521_RC1R_RGMII_1_200_NS\t\t8\n#define YT8521_RC1R_RGMII_1_350_NS\t\t9\n#define YT8521_RC1R_RGMII_1_500_NS\t\t10\n#define YT8521_RC1R_RGMII_1_650_NS\t\t11\n#define YT8521_RC1R_RGMII_1_800_NS\t\t12\n#define YT8521_RC1R_RGMII_1_950_NS\t\t13\n#define YT8521_RC1R_RGMII_2_100_NS\t\t14\n#define YT8521_RC1R_RGMII_2_250_NS\t\t15\n\n#define YTPHY_MISC_CONFIG_REG\t\t\t0xA006\n#define YTPHY_MCR_FIBER_SPEED_MASK\t\tBIT(0)\n#define YTPHY_MCR_FIBER_1000BX\t\t\t(0x1 << 0)\n#define YTPHY_MCR_FIBER_100FX\t\t\t(0x0 << 0)\n\n \n#define YTPHY_WOL_MACADDR2_REG\t\t\t0xA007\n#define YTPHY_WOL_MACADDR1_REG\t\t\t0xA008\n#define YTPHY_WOL_MACADDR0_REG\t\t\t0xA009\n\n#define YTPHY_WOL_CONFIG_REG\t\t\t0xA00A\n#define YTPHY_WCR_INTR_SEL\t\t\tBIT(6)\n#define YTPHY_WCR_ENABLE\t\t\tBIT(3)\n\n \n#define YTPHY_WCR_PULSE_WIDTH_MASK\t\t(BIT(2) | BIT(1))\n#define YTPHY_WCR_PULSE_WIDTH_672MS\t\t(BIT(2) | BIT(1))\n\n \n#define YTPHY_WCR_TYPE_PULSE\t\t\tBIT(0)\n\n#define YTPHY_PAD_DRIVE_STRENGTH_REG\t\t0xA010\n#define YT8531_RGMII_RXC_DS_MASK\t\tGENMASK(15, 13)\n#define YT8531_RGMII_RXD_DS_HI_MASK\t\tBIT(12)\t\t \n#define YT8531_RGMII_RXD_DS_LOW_MASK\t\tGENMASK(5, 4)\t \n#define YT8531_RGMII_RX_DS_DEFAULT\t\t0x3\n\n#define YTPHY_SYNCE_CFG_REG\t\t\t0xA012\n#define YT8521_SCR_SYNCE_ENABLE\t\t\tBIT(5)\n \n#define YT8521_SCR_CLK_FRE_SEL_125M\t\tBIT(3)\n#define YT8521_SCR_CLK_SRC_MASK\t\t\tGENMASK(2, 1)\n#define YT8521_SCR_CLK_SRC_PLL_125M\t\t0\n#define YT8521_SCR_CLK_SRC_UTP_RX\t\t1\n#define YT8521_SCR_CLK_SRC_SDS_RX\t\t2\n#define YT8521_SCR_CLK_SRC_REF_25M\t\t3\n#define YT8531_SCR_SYNCE_ENABLE\t\t\tBIT(6)\n \n#define YT8531_SCR_CLK_FRE_SEL_125M\t\tBIT(4)\n#define YT8531_SCR_CLK_SRC_MASK\t\t\tGENMASK(3, 1)\n#define YT8531_SCR_CLK_SRC_PLL_125M\t\t0\n#define YT8531_SCR_CLK_SRC_UTP_RX\t\t1\n#define YT8531_SCR_CLK_SRC_SDS_RX\t\t2\n#define YT8531_SCR_CLK_SRC_CLOCK_FROM_DIGITAL\t3\n#define YT8531_SCR_CLK_SRC_REF_25M\t\t4\n#define YT8531_SCR_CLK_SRC_SSC_25M\t\t5\n\n \n\n#define YTPHY_DTS_OUTPUT_CLK_DIS\t\t0\n#define YTPHY_DTS_OUTPUT_CLK_25M\t\t25000000\n#define YTPHY_DTS_OUTPUT_CLK_125M\t\t125000000\n\nstruct yt8521_priv {\n\t \n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(combo_advertising);\n\n\t \n\tu8 polling_mode;\n\tu8 strap_mode;  \n\t \n\tu8 reg_page;\n};\n\n \nstatic int ytphy_read_ext(struct phy_device *phydev, u16 regnum)\n{\n\tint ret;\n\n\tret = __phy_write(phydev, YTPHY_PAGE_SELECT, regnum);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn __phy_read(phydev, YTPHY_PAGE_DATA);\n}\n\n \nstatic int ytphy_read_ext_with_lock(struct phy_device *phydev, u16 regnum)\n{\n\tint ret;\n\n\tphy_lock_mdio_bus(phydev);\n\tret = ytphy_read_ext(phydev, regnum);\n\tphy_unlock_mdio_bus(phydev);\n\n\treturn ret;\n}\n\n \nstatic int ytphy_write_ext(struct phy_device *phydev, u16 regnum, u16 val)\n{\n\tint ret;\n\n\tret = __phy_write(phydev, YTPHY_PAGE_SELECT, regnum);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn __phy_write(phydev, YTPHY_PAGE_DATA, val);\n}\n\n \nstatic int ytphy_write_ext_with_lock(struct phy_device *phydev, u16 regnum,\n\t\t\t\t     u16 val)\n{\n\tint ret;\n\n\tphy_lock_mdio_bus(phydev);\n\tret = ytphy_write_ext(phydev, regnum, val);\n\tphy_unlock_mdio_bus(phydev);\n\n\treturn ret;\n}\n\n \nstatic int ytphy_modify_ext(struct phy_device *phydev, u16 regnum, u16 mask,\n\t\t\t    u16 set)\n{\n\tint ret;\n\n\tret = __phy_write(phydev, YTPHY_PAGE_SELECT, regnum);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn __phy_modify(phydev, YTPHY_PAGE_DATA, mask, set);\n}\n\n \nstatic int ytphy_modify_ext_with_lock(struct phy_device *phydev, u16 regnum,\n\t\t\t\t      u16 mask, u16 set)\n{\n\tint ret;\n\n\tphy_lock_mdio_bus(phydev);\n\tret = ytphy_modify_ext(phydev, regnum, mask, set);\n\tphy_unlock_mdio_bus(phydev);\n\n\treturn ret;\n}\n\n \nstatic void ytphy_get_wol(struct phy_device *phydev,\n\t\t\t  struct ethtool_wolinfo *wol)\n{\n\tint wol_config;\n\n\twol->supported = WAKE_MAGIC;\n\twol->wolopts = 0;\n\n\twol_config = ytphy_read_ext_with_lock(phydev, YTPHY_WOL_CONFIG_REG);\n\tif (wol_config < 0)\n\t\treturn;\n\n\tif (wol_config & YTPHY_WCR_ENABLE)\n\t\twol->wolopts |= WAKE_MAGIC;\n}\n\n \nstatic int ytphy_set_wol(struct phy_device *phydev, struct ethtool_wolinfo *wol)\n{\n\tstruct net_device *p_attached_dev;\n\tconst u16 mac_addr_reg[] = {\n\t\tYTPHY_WOL_MACADDR2_REG,\n\t\tYTPHY_WOL_MACADDR1_REG,\n\t\tYTPHY_WOL_MACADDR0_REG,\n\t};\n\tconst u8 *mac_addr;\n\tint old_page;\n\tint ret = 0;\n\tu16 mask;\n\tu16 val;\n\tu8 i;\n\n\tif (wol->wolopts & WAKE_MAGIC) {\n\t\tp_attached_dev = phydev->attached_dev;\n\t\tif (!p_attached_dev)\n\t\t\treturn -ENODEV;\n\n\t\tmac_addr = (const u8 *)p_attached_dev->dev_addr;\n\t\tif (!is_valid_ether_addr(mac_addr))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\told_page = phy_select_page(phydev, YT8521_RSSR_UTP_SPACE);\n\t\tif (old_page < 0)\n\t\t\tgoto err_restore_page;\n\n\t\t \n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tret = ytphy_write_ext(phydev, mac_addr_reg[i],\n\t\t\t\t\t      ((mac_addr[i * 2] << 8)) |\n\t\t\t\t\t\t      (mac_addr[i * 2 + 1]));\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err_restore_page;\n\t\t}\n\n\t\t \n\t\tmask = YTPHY_WCR_PULSE_WIDTH_MASK | YTPHY_WCR_INTR_SEL;\n\t\tval = YTPHY_WCR_ENABLE | YTPHY_WCR_INTR_SEL;\n\t\tval |= YTPHY_WCR_TYPE_PULSE | YTPHY_WCR_PULSE_WIDTH_672MS;\n\t\tret = ytphy_modify_ext(phydev, YTPHY_WOL_CONFIG_REG, mask, val);\n\t\tif (ret < 0)\n\t\t\tgoto err_restore_page;\n\n\t\t \n\t\tret = __phy_modify(phydev, YTPHY_INTERRUPT_ENABLE_REG, 0,\n\t\t\t\t   YTPHY_IER_WOL);\n\t\tif (ret < 0)\n\t\t\tgoto err_restore_page;\n\n\t} else {\n\t\told_page = phy_select_page(phydev, YT8521_RSSR_UTP_SPACE);\n\t\tif (old_page < 0)\n\t\t\tgoto err_restore_page;\n\n\t\t \n\t\tmask = YTPHY_WCR_ENABLE | YTPHY_WCR_INTR_SEL;\n\t\tret = ytphy_modify_ext(phydev, YTPHY_WOL_CONFIG_REG, mask, 0);\n\n\t\t \n\t\tret = __phy_modify(phydev, YTPHY_INTERRUPT_ENABLE_REG,\n\t\t\t\t   YTPHY_IER_WOL, 0);\n\t\tif (ret < 0)\n\t\t\tgoto err_restore_page;\n\t}\n\nerr_restore_page:\n\treturn phy_restore_page(phydev, old_page, ret);\n}\n\nstatic int yt8531_set_wol(struct phy_device *phydev,\n\t\t\t  struct ethtool_wolinfo *wol)\n{\n\tconst u16 mac_addr_reg[] = {\n\t\tYTPHY_WOL_MACADDR2_REG,\n\t\tYTPHY_WOL_MACADDR1_REG,\n\t\tYTPHY_WOL_MACADDR0_REG,\n\t};\n\tconst u8 *mac_addr;\n\tu16 mask, val;\n\tint ret;\n\tu8 i;\n\n\tif (wol->wolopts & WAKE_MAGIC) {\n\t\tmac_addr = phydev->attached_dev->dev_addr;\n\n\t\t \n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tret = ytphy_write_ext_with_lock(phydev, mac_addr_reg[i],\n\t\t\t\t\t\t\t((mac_addr[i * 2] << 8)) |\n\t\t\t\t\t\t\t(mac_addr[i * 2 + 1]));\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tmask = YTPHY_WCR_PULSE_WIDTH_MASK | YTPHY_WCR_INTR_SEL;\n\t\tval = YTPHY_WCR_ENABLE | YTPHY_WCR_INTR_SEL;\n\t\tval |= YTPHY_WCR_TYPE_PULSE | YTPHY_WCR_PULSE_WIDTH_672MS;\n\t\tret = ytphy_modify_ext_with_lock(phydev, YTPHY_WOL_CONFIG_REG,\n\t\t\t\t\t\t mask, val);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = phy_modify(phydev, YTPHY_INTERRUPT_ENABLE_REG, 0,\n\t\t\t\t YTPHY_IER_WOL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\t \n\t\tmask = YTPHY_WCR_ENABLE | YTPHY_WCR_INTR_SEL;\n\t\tret = ytphy_modify_ext_with_lock(phydev, YTPHY_WOL_CONFIG_REG,\n\t\t\t\t\t\t mask, 0);\n\n\t\t \n\t\tret = phy_modify(phydev, YTPHY_INTERRUPT_ENABLE_REG,\n\t\t\t\t YTPHY_IER_WOL, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int yt8511_read_page(struct phy_device *phydev)\n{\n\treturn __phy_read(phydev, YT8511_PAGE_SELECT);\n};\n\nstatic int yt8511_write_page(struct phy_device *phydev, int page)\n{\n\treturn __phy_write(phydev, YT8511_PAGE_SELECT, page);\n};\n\nstatic int yt8511_config_init(struct phy_device *phydev)\n{\n\tint oldpage, ret = 0;\n\tunsigned int ge, fe;\n\n\toldpage = phy_select_page(phydev, YT8511_EXT_CLK_GATE);\n\tif (oldpage < 0)\n\t\tgoto err_restore_page;\n\n\t \n\tswitch (phydev->interface) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\t\tge = YT8511_DELAY_GE_TX_DIS;\n\t\tfe = YT8511_DELAY_FE_TX_DIS;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\tge = YT8511_DELAY_RX | YT8511_DELAY_GE_TX_DIS;\n\t\tfe = YT8511_DELAY_FE_TX_DIS;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tge = YT8511_DELAY_GE_TX_EN;\n\t\tfe = YT8511_DELAY_FE_TX_EN;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\t\tge = YT8511_DELAY_RX | YT8511_DELAY_GE_TX_EN;\n\t\tfe = YT8511_DELAY_FE_TX_EN;\n\t\tbreak;\n\tdefault:  \n\t\tret = -EOPNOTSUPP;\n\t\tgoto err_restore_page;\n\t}\n\n\tret = __phy_modify(phydev, YT8511_PAGE, (YT8511_DELAY_RX | YT8511_DELAY_GE_TX_EN), ge);\n\tif (ret < 0)\n\t\tgoto err_restore_page;\n\n\t \n\tret = __phy_modify(phydev, YT8511_PAGE, 0, YT8511_CLK_125M);\n\tif (ret < 0)\n\t\tgoto err_restore_page;\n\n\t \n\tret = __phy_write(phydev, YT8511_PAGE_SELECT, YT8511_EXT_DELAY_DRIVE);\n\tif (ret < 0)\n\t\tgoto err_restore_page;\n\n\tret = __phy_modify(phydev, YT8511_PAGE, YT8511_DELAY_FE_TX_EN, fe);\n\tif (ret < 0)\n\t\tgoto err_restore_page;\n\n\t \n\tret = __phy_write(phydev, YT8511_PAGE_SELECT, YT8511_EXT_SLEEP_CTRL);\n\tif (ret < 0)\n\t\tgoto err_restore_page;\n\n\tret = __phy_modify(phydev, YT8511_PAGE, 0, YT8511_PLLON_SLP);\n\tif (ret < 0)\n\t\tgoto err_restore_page;\n\nerr_restore_page:\n\treturn phy_restore_page(phydev, oldpage, ret);\n}\n\n \nstatic int yt8521_read_page(struct phy_device *phydev)\n{\n\tint old_page;\n\n\told_page = ytphy_read_ext(phydev, YT8521_REG_SPACE_SELECT_REG);\n\tif (old_page < 0)\n\t\treturn old_page;\n\n\tif ((old_page & YT8521_RSSR_SPACE_MASK) == YT8521_RSSR_FIBER_SPACE)\n\t\treturn YT8521_RSSR_FIBER_SPACE;\n\n\treturn YT8521_RSSR_UTP_SPACE;\n};\n\n \nstatic int yt8521_write_page(struct phy_device *phydev, int page)\n{\n\tint mask = YT8521_RSSR_SPACE_MASK;\n\tint set;\n\n\tif ((page & YT8521_RSSR_SPACE_MASK) == YT8521_RSSR_FIBER_SPACE)\n\t\tset = YT8521_RSSR_FIBER_SPACE;\n\telse\n\t\tset = YT8521_RSSR_UTP_SPACE;\n\n\treturn ytphy_modify_ext(phydev, YT8521_REG_SPACE_SELECT_REG, mask, set);\n};\n\n \nstruct ytphy_cfg_reg_map {\n\tu32 cfg;\n\tu32 reg;\n};\n\nstatic const struct ytphy_cfg_reg_map ytphy_rgmii_delays[] = {\n\t \n\t{ 0,\tYT8521_RC1R_RGMII_0_000_NS },\n\t{ 150,\tYT8521_RC1R_RGMII_0_150_NS },\n\t{ 300,\tYT8521_RC1R_RGMII_0_300_NS },\n\t{ 450,\tYT8521_RC1R_RGMII_0_450_NS },\n\t{ 600,\tYT8521_RC1R_RGMII_0_600_NS },\n\t{ 750,\tYT8521_RC1R_RGMII_0_750_NS },\n\t{ 900,\tYT8521_RC1R_RGMII_0_900_NS },\n\t{ 1050,\tYT8521_RC1R_RGMII_1_050_NS },\n\t{ 1200,\tYT8521_RC1R_RGMII_1_200_NS },\n\t{ 1350,\tYT8521_RC1R_RGMII_1_350_NS },\n\t{ 1500,\tYT8521_RC1R_RGMII_1_500_NS },\n\t{ 1650,\tYT8521_RC1R_RGMII_1_650_NS },\n\t{ 1800,\tYT8521_RC1R_RGMII_1_800_NS },\n\t{ 1950,\tYT8521_RC1R_RGMII_1_950_NS },\t \n\t{ 2100,\tYT8521_RC1R_RGMII_2_100_NS },\n\t{ 2250,\tYT8521_RC1R_RGMII_2_250_NS },\n\n\t \n\t{ 0    + YT8521_CCR_RXC_DLY_1_900_NS,\tYT8521_RC1R_RGMII_0_000_NS },\n\t{ 150  + YT8521_CCR_RXC_DLY_1_900_NS,\tYT8521_RC1R_RGMII_0_150_NS },\n\t{ 300  + YT8521_CCR_RXC_DLY_1_900_NS,\tYT8521_RC1R_RGMII_0_300_NS },\n\t{ 450  + YT8521_CCR_RXC_DLY_1_900_NS,\tYT8521_RC1R_RGMII_0_450_NS },\n\t{ 600  + YT8521_CCR_RXC_DLY_1_900_NS,\tYT8521_RC1R_RGMII_0_600_NS },\n\t{ 750  + YT8521_CCR_RXC_DLY_1_900_NS,\tYT8521_RC1R_RGMII_0_750_NS },\n\t{ 900  + YT8521_CCR_RXC_DLY_1_900_NS,\tYT8521_RC1R_RGMII_0_900_NS },\n\t{ 1050 + YT8521_CCR_RXC_DLY_1_900_NS,\tYT8521_RC1R_RGMII_1_050_NS },\n\t{ 1200 + YT8521_CCR_RXC_DLY_1_900_NS,\tYT8521_RC1R_RGMII_1_200_NS },\n\t{ 1350 + YT8521_CCR_RXC_DLY_1_900_NS,\tYT8521_RC1R_RGMII_1_350_NS },\n\t{ 1500 + YT8521_CCR_RXC_DLY_1_900_NS,\tYT8521_RC1R_RGMII_1_500_NS },\n\t{ 1650 + YT8521_CCR_RXC_DLY_1_900_NS,\tYT8521_RC1R_RGMII_1_650_NS },\n\t{ 1800 + YT8521_CCR_RXC_DLY_1_900_NS,\tYT8521_RC1R_RGMII_1_800_NS },\n\t{ 1950 + YT8521_CCR_RXC_DLY_1_900_NS,\tYT8521_RC1R_RGMII_1_950_NS },\n\t{ 2100 + YT8521_CCR_RXC_DLY_1_900_NS,\tYT8521_RC1R_RGMII_2_100_NS },\n\t{ 2250 + YT8521_CCR_RXC_DLY_1_900_NS,\tYT8521_RC1R_RGMII_2_250_NS }\n};\n\nstatic u32 ytphy_get_delay_reg_value(struct phy_device *phydev,\n\t\t\t\t     const char *prop_name,\n\t\t\t\t     const struct ytphy_cfg_reg_map *tbl,\n\t\t\t\t     int tb_size,\n\t\t\t\t     u16 *rxc_dly_en,\n\t\t\t\t     u32 dflt)\n{\n\tstruct device_node *node = phydev->mdio.dev.of_node;\n\tint tb_size_half = tb_size / 2;\n\tu32 val;\n\tint i;\n\n\tif (of_property_read_u32(node, prop_name, &val))\n\t\tgoto err_dts_val;\n\n\t \n\tif (!rxc_dly_en)\n\t\ttb_size = tb_size_half;\n\n\tfor (i = 0; i < tb_size; i++) {\n\t\tif (tbl[i].cfg == val) {\n\t\t\tif (rxc_dly_en && i < tb_size_half)\n\t\t\t\t*rxc_dly_en = 0;\n\t\t\treturn tbl[i].reg;\n\t\t}\n\t}\n\n\tphydev_warn(phydev, \"Unsupported value %d for %s using default (%u)\\n\",\n\t\t    val, prop_name, dflt);\n\nerr_dts_val:\n\t \n\tif (rxc_dly_en)\n\t\t*rxc_dly_en = 0;\n\n\treturn dflt;\n}\n\nstatic int ytphy_rgmii_clk_delay_config(struct phy_device *phydev)\n{\n\tint tb_size = ARRAY_SIZE(ytphy_rgmii_delays);\n\tu16 rxc_dly_en = YT8521_CCR_RXC_DLY_EN;\n\tu32 rx_reg, tx_reg;\n\tu16 mask, val = 0;\n\tint ret;\n\n\trx_reg = ytphy_get_delay_reg_value(phydev, \"rx-internal-delay-ps\",\n\t\t\t\t\t   ytphy_rgmii_delays, tb_size,\n\t\t\t\t\t   &rxc_dly_en,\n\t\t\t\t\t   YT8521_RC1R_RGMII_1_950_NS);\n\ttx_reg = ytphy_get_delay_reg_value(phydev, \"tx-internal-delay-ps\",\n\t\t\t\t\t   ytphy_rgmii_delays, tb_size, NULL,\n\t\t\t\t\t   YT8521_RC1R_RGMII_1_950_NS);\n\n\tswitch (phydev->interface) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\t\trxc_dly_en = 0;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\tval |= FIELD_PREP(YT8521_RC1R_RX_DELAY_MASK, rx_reg);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\trxc_dly_en = 0;\n\t\tval |= FIELD_PREP(YT8521_RC1R_GE_TX_DELAY_MASK, tx_reg);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\t\tval |= FIELD_PREP(YT8521_RC1R_RX_DELAY_MASK, rx_reg) |\n\t\t       FIELD_PREP(YT8521_RC1R_GE_TX_DELAY_MASK, tx_reg);\n\t\tbreak;\n\tdefault:  \n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = ytphy_modify_ext(phydev, YT8521_CHIP_CONFIG_REG,\n\t\t\t       YT8521_CCR_RXC_DLY_EN, rxc_dly_en);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmask = YT8521_RC1R_RX_DELAY_MASK | YT8521_RC1R_GE_TX_DELAY_MASK;\n\treturn ytphy_modify_ext(phydev, YT8521_RGMII_CONFIG1_REG, mask, val);\n}\n\nstatic int ytphy_rgmii_clk_delay_config_with_lock(struct phy_device *phydev)\n{\n\tint ret;\n\n\tphy_lock_mdio_bus(phydev);\n\tret = ytphy_rgmii_clk_delay_config(phydev);\n\tphy_unlock_mdio_bus(phydev);\n\n\treturn ret;\n}\n\n \nstruct ytphy_ldo_vol_map {\n\tu32 vol;\n\tu32 ds;\n\tu32 cur;\n};\n\nstatic const struct ytphy_ldo_vol_map yt8531_ldo_vol[] = {\n\t{.vol = YT8531_LDO_VOL_1V8, .ds = 0, .cur = 1200},\n\t{.vol = YT8531_LDO_VOL_1V8, .ds = 1, .cur = 2100},\n\t{.vol = YT8531_LDO_VOL_1V8, .ds = 2, .cur = 2700},\n\t{.vol = YT8531_LDO_VOL_1V8, .ds = 3, .cur = 2910},\n\t{.vol = YT8531_LDO_VOL_1V8, .ds = 4, .cur = 3110},\n\t{.vol = YT8531_LDO_VOL_1V8, .ds = 5, .cur = 3600},\n\t{.vol = YT8531_LDO_VOL_1V8, .ds = 6, .cur = 3970},\n\t{.vol = YT8531_LDO_VOL_1V8, .ds = 7, .cur = 4350},\n\t{.vol = YT8531_LDO_VOL_3V3, .ds = 0, .cur = 3070},\n\t{.vol = YT8531_LDO_VOL_3V3, .ds = 1, .cur = 4080},\n\t{.vol = YT8531_LDO_VOL_3V3, .ds = 2, .cur = 4370},\n\t{.vol = YT8531_LDO_VOL_3V3, .ds = 3, .cur = 4680},\n\t{.vol = YT8531_LDO_VOL_3V3, .ds = 4, .cur = 5020},\n\t{.vol = YT8531_LDO_VOL_3V3, .ds = 5, .cur = 5450},\n\t{.vol = YT8531_LDO_VOL_3V3, .ds = 6, .cur = 5740},\n\t{.vol = YT8531_LDO_VOL_3V3, .ds = 7, .cur = 6140},\n};\n\nstatic u32 yt8531_get_ldo_vol(struct phy_device *phydev)\n{\n\tu32 val;\n\n\tval = ytphy_read_ext_with_lock(phydev, YT8521_CHIP_CONFIG_REG);\n\tval = FIELD_GET(YT8531_RGMII_LDO_VOL_MASK, val);\n\n\treturn val <= YT8531_LDO_VOL_1V8 ? val : YT8531_LDO_VOL_1V8;\n}\n\nstatic int yt8531_get_ds_map(struct phy_device *phydev, u32 cur)\n{\n\tu32 vol;\n\tint i;\n\n\tvol = yt8531_get_ldo_vol(phydev);\n\tfor (i = 0; i < ARRAY_SIZE(yt8531_ldo_vol); i++) {\n\t\tif (yt8531_ldo_vol[i].vol == vol && yt8531_ldo_vol[i].cur == cur)\n\t\t\treturn yt8531_ldo_vol[i].ds;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int yt8531_set_ds(struct phy_device *phydev)\n{\n\tstruct device_node *node = phydev->mdio.dev.of_node;\n\tu32 ds_field_low, ds_field_hi, val;\n\tint ret, ds;\n\n\t \n\tif (!of_property_read_u32(node, \"motorcomm,rx-clk-drv-microamp\", &val)) {\n\t\tds = yt8531_get_ds_map(phydev, val);\n\t\tif (ds < 0)\n\t\t\treturn dev_err_probe(&phydev->mdio.dev, ds,\n\t\t\t\t\t     \"No matching current value was found.\\n\");\n\t} else {\n\t\tds = YT8531_RGMII_RX_DS_DEFAULT;\n\t}\n\n\tret = ytphy_modify_ext_with_lock(phydev,\n\t\t\t\t\t YTPHY_PAD_DRIVE_STRENGTH_REG,\n\t\t\t\t\t YT8531_RGMII_RXC_DS_MASK,\n\t\t\t\t\t FIELD_PREP(YT8531_RGMII_RXC_DS_MASK, ds));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (!of_property_read_u32(node, \"motorcomm,rx-data-drv-microamp\", &val)) {\n\t\tds = yt8531_get_ds_map(phydev, val);\n\t\tif (ds < 0)\n\t\t\treturn dev_err_probe(&phydev->mdio.dev, ds,\n\t\t\t\t\t     \"No matching current value was found.\\n\");\n\t} else {\n\t\tds = YT8531_RGMII_RX_DS_DEFAULT;\n\t}\n\n\tds_field_hi = FIELD_GET(BIT(2), ds);\n\tds_field_hi = FIELD_PREP(YT8531_RGMII_RXD_DS_HI_MASK, ds_field_hi);\n\n\tds_field_low = FIELD_GET(GENMASK(1, 0), ds);\n\tds_field_low = FIELD_PREP(YT8531_RGMII_RXD_DS_LOW_MASK, ds_field_low);\n\n\tret = ytphy_modify_ext_with_lock(phydev,\n\t\t\t\t\t YTPHY_PAD_DRIVE_STRENGTH_REG,\n\t\t\t\t\t YT8531_RGMII_RXD_DS_LOW_MASK | YT8531_RGMII_RXD_DS_HI_MASK,\n\t\t\t\t\t ds_field_low | ds_field_hi);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic int yt8521_probe(struct phy_device *phydev)\n{\n\tstruct device_node *node = phydev->mdio.dev.of_node;\n\tstruct device *dev = &phydev->mdio.dev;\n\tstruct yt8521_priv *priv;\n\tint chip_config;\n\tu16 mask, val;\n\tu32 freq;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tphydev->priv = priv;\n\n\tchip_config = ytphy_read_ext_with_lock(phydev, YT8521_CHIP_CONFIG_REG);\n\tif (chip_config < 0)\n\t\treturn chip_config;\n\n\tpriv->strap_mode = chip_config & YT8521_CCR_MODE_SEL_MASK;\n\tswitch (priv->strap_mode) {\n\tcase YT8521_CCR_MODE_FIBER_TO_RGMII:\n\tcase YT8521_CCR_MODE_SGPHY_TO_RGMAC:\n\tcase YT8521_CCR_MODE_SGMAC_TO_RGPHY:\n\t\tpriv->polling_mode = YT8521_MODE_FIBER;\n\t\tpriv->reg_page = YT8521_RSSR_FIBER_SPACE;\n\t\tphydev->port = PORT_FIBRE;\n\t\tbreak;\n\tcase YT8521_CCR_MODE_UTP_FIBER_TO_RGMII:\n\tcase YT8521_CCR_MODE_UTP_TO_FIBER_AUTO:\n\tcase YT8521_CCR_MODE_UTP_TO_FIBER_FORCE:\n\t\tpriv->polling_mode = YT8521_MODE_POLL;\n\t\tpriv->reg_page = YT8521_RSSR_TO_BE_ARBITRATED;\n\t\tphydev->port = PORT_NONE;\n\t\tbreak;\n\tcase YT8521_CCR_MODE_UTP_TO_SGMII:\n\tcase YT8521_CCR_MODE_UTP_TO_RGMII:\n\t\tpriv->polling_mode = YT8521_MODE_UTP;\n\t\tpriv->reg_page = YT8521_RSSR_UTP_SPACE;\n\t\tphydev->port = PORT_TP;\n\t\tbreak;\n\t}\n\t \n\tif (priv->reg_page != YT8521_RSSR_TO_BE_ARBITRATED) {\n\t\tret = ytphy_write_ext_with_lock(phydev,\n\t\t\t\t\t\tYT8521_REG_SPACE_SELECT_REG,\n\t\t\t\t\t\tpriv->reg_page);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (of_property_read_u32(node, \"motorcomm,clk-out-frequency-hz\", &freq))\n\t\tfreq = YTPHY_DTS_OUTPUT_CLK_DIS;\n\n\tif (phydev->drv->phy_id == PHY_ID_YT8521) {\n\t\tswitch (freq) {\n\t\tcase YTPHY_DTS_OUTPUT_CLK_DIS:\n\t\t\tmask = YT8521_SCR_SYNCE_ENABLE;\n\t\t\tval = 0;\n\t\t\tbreak;\n\t\tcase YTPHY_DTS_OUTPUT_CLK_25M:\n\t\t\tmask = YT8521_SCR_SYNCE_ENABLE |\n\t\t\t       YT8521_SCR_CLK_SRC_MASK |\n\t\t\t       YT8521_SCR_CLK_FRE_SEL_125M;\n\t\t\tval = YT8521_SCR_SYNCE_ENABLE |\n\t\t\t      FIELD_PREP(YT8521_SCR_CLK_SRC_MASK,\n\t\t\t\t\t YT8521_SCR_CLK_SRC_REF_25M);\n\t\t\tbreak;\n\t\tcase YTPHY_DTS_OUTPUT_CLK_125M:\n\t\t\tmask = YT8521_SCR_SYNCE_ENABLE |\n\t\t\t       YT8521_SCR_CLK_SRC_MASK |\n\t\t\t       YT8521_SCR_CLK_FRE_SEL_125M;\n\t\t\tval = YT8521_SCR_SYNCE_ENABLE |\n\t\t\t      YT8521_SCR_CLK_FRE_SEL_125M |\n\t\t\t      FIELD_PREP(YT8521_SCR_CLK_SRC_MASK,\n\t\t\t\t\t YT8521_SCR_CLK_SRC_PLL_125M);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphydev_warn(phydev, \"Freq err:%u\\n\", freq);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (phydev->drv->phy_id == PHY_ID_YT8531S) {\n\t\tswitch (freq) {\n\t\tcase YTPHY_DTS_OUTPUT_CLK_DIS:\n\t\t\tmask = YT8531_SCR_SYNCE_ENABLE;\n\t\t\tval = 0;\n\t\t\tbreak;\n\t\tcase YTPHY_DTS_OUTPUT_CLK_25M:\n\t\t\tmask = YT8531_SCR_SYNCE_ENABLE |\n\t\t\t       YT8531_SCR_CLK_SRC_MASK |\n\t\t\t       YT8531_SCR_CLK_FRE_SEL_125M;\n\t\t\tval = YT8531_SCR_SYNCE_ENABLE |\n\t\t\t      FIELD_PREP(YT8531_SCR_CLK_SRC_MASK,\n\t\t\t\t\t YT8531_SCR_CLK_SRC_REF_25M);\n\t\t\tbreak;\n\t\tcase YTPHY_DTS_OUTPUT_CLK_125M:\n\t\t\tmask = YT8531_SCR_SYNCE_ENABLE |\n\t\t\t       YT8531_SCR_CLK_SRC_MASK |\n\t\t\t       YT8531_SCR_CLK_FRE_SEL_125M;\n\t\t\tval = YT8531_SCR_SYNCE_ENABLE |\n\t\t\t      YT8531_SCR_CLK_FRE_SEL_125M |\n\t\t\t      FIELD_PREP(YT8531_SCR_CLK_SRC_MASK,\n\t\t\t\t\t YT8531_SCR_CLK_SRC_PLL_125M);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphydev_warn(phydev, \"Freq err:%u\\n\", freq);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tphydev_warn(phydev, \"PHY id err\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn ytphy_modify_ext_with_lock(phydev, YTPHY_SYNCE_CFG_REG, mask,\n\t\t\t\t\t  val);\n}\n\nstatic int yt8531_probe(struct phy_device *phydev)\n{\n\tstruct device_node *node = phydev->mdio.dev.of_node;\n\tu16 mask, val;\n\tu32 freq;\n\n\tif (of_property_read_u32(node, \"motorcomm,clk-out-frequency-hz\", &freq))\n\t\tfreq = YTPHY_DTS_OUTPUT_CLK_DIS;\n\n\tswitch (freq) {\n\tcase YTPHY_DTS_OUTPUT_CLK_DIS:\n\t\tmask = YT8531_SCR_SYNCE_ENABLE;\n\t\tval = 0;\n\t\tbreak;\n\tcase YTPHY_DTS_OUTPUT_CLK_25M:\n\t\tmask = YT8531_SCR_SYNCE_ENABLE | YT8531_SCR_CLK_SRC_MASK |\n\t\t       YT8531_SCR_CLK_FRE_SEL_125M;\n\t\tval = YT8531_SCR_SYNCE_ENABLE |\n\t\t      FIELD_PREP(YT8531_SCR_CLK_SRC_MASK,\n\t\t\t\t YT8531_SCR_CLK_SRC_REF_25M);\n\t\tbreak;\n\tcase YTPHY_DTS_OUTPUT_CLK_125M:\n\t\tmask = YT8531_SCR_SYNCE_ENABLE | YT8531_SCR_CLK_SRC_MASK |\n\t\t       YT8531_SCR_CLK_FRE_SEL_125M;\n\t\tval = YT8531_SCR_SYNCE_ENABLE | YT8531_SCR_CLK_FRE_SEL_125M |\n\t\t      FIELD_PREP(YT8531_SCR_CLK_SRC_MASK,\n\t\t\t\t YT8531_SCR_CLK_SRC_PLL_125M);\n\t\tbreak;\n\tdefault:\n\t\tphydev_warn(phydev, \"Freq err:%u\\n\", freq);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ytphy_modify_ext_with_lock(phydev, YTPHY_SYNCE_CFG_REG, mask,\n\t\t\t\t\t  val);\n}\n\n \nstatic int ytphy_utp_read_lpa(struct phy_device *phydev)\n{\n\tint lpa, lpagb;\n\n\tif (phydev->autoneg == AUTONEG_ENABLE) {\n\t\tif (!phydev->autoneg_complete) {\n\t\t\tmii_stat1000_mod_linkmode_lpa_t(phydev->lp_advertising,\n\t\t\t\t\t\t\t0);\n\t\t\tmii_lpa_mod_linkmode_lpa_t(phydev->lp_advertising, 0);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (phydev->is_gigabit_capable) {\n\t\t\tlpagb = __phy_read(phydev, MII_STAT1000);\n\t\t\tif (lpagb < 0)\n\t\t\t\treturn lpagb;\n\n\t\t\tif (lpagb & LPA_1000MSFAIL) {\n\t\t\t\tint adv = __phy_read(phydev, MII_CTRL1000);\n\n\t\t\t\tif (adv < 0)\n\t\t\t\t\treturn adv;\n\n\t\t\t\tif (adv & CTL1000_ENABLE_MASTER)\n\t\t\t\t\tphydev_err(phydev, \"Master/Slave resolution failed, maybe conflicting manual settings?\\n\");\n\t\t\t\telse\n\t\t\t\t\tphydev_err(phydev, \"Master/Slave resolution failed\\n\");\n\t\t\t\treturn -ENOLINK;\n\t\t\t}\n\n\t\t\tmii_stat1000_mod_linkmode_lpa_t(phydev->lp_advertising,\n\t\t\t\t\t\t\tlpagb);\n\t\t}\n\n\t\tlpa = __phy_read(phydev, MII_LPA);\n\t\tif (lpa < 0)\n\t\t\treturn lpa;\n\n\t\tmii_lpa_mod_linkmode_lpa_t(phydev->lp_advertising, lpa);\n\t} else {\n\t\tlinkmode_zero(phydev->lp_advertising);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int yt8521_adjust_status(struct phy_device *phydev, int status,\n\t\t\t\tbool is_utp)\n{\n\tint speed_mode, duplex;\n\tint speed;\n\tint err;\n\tint lpa;\n\n\tif (is_utp)\n\t\tduplex = (status & YTPHY_SSR_DUPLEX) >> YTPHY_SSR_DUPLEX_OFFSET;\n\telse\n\t\tduplex = DUPLEX_FULL;\t \n\n\tspeed_mode = (status & YTPHY_SSR_SPEED_MODE_MASK) >>\n\t\t     YTPHY_SSR_SPEED_MODE_OFFSET;\n\n\tswitch (speed_mode) {\n\tcase YTPHY_SSR_SPEED_10M:\n\t\tif (is_utp)\n\t\t\tspeed = SPEED_10;\n\t\telse\n\t\t\t \n\t\t\tspeed = SPEED_UNKNOWN;\n\t\tbreak;\n\tcase YTPHY_SSR_SPEED_100M:\n\t\tspeed = SPEED_100;\n\t\tbreak;\n\tcase YTPHY_SSR_SPEED_1000M:\n\t\tspeed = SPEED_1000;\n\t\tbreak;\n\tdefault:\n\t\tspeed = SPEED_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tphydev->speed = speed;\n\tphydev->duplex = duplex;\n\n\tif (is_utp) {\n\t\terr = ytphy_utp_read_lpa(phydev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tphy_resolve_aneg_pause(phydev);\n\t} else {\n\t\tlpa = __phy_read(phydev, MII_LPA);\n\t\tif (lpa < 0)\n\t\t\treturn lpa;\n\n\t\t \n\t\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT,\n\t\t\t\t phydev->lp_advertising, lpa & LPA_1000XFULL);\n\n\t\tif (!(lpa & YTPHY_FLPA_PAUSE)) {\n\t\t\tphydev->pause = 0;\n\t\t\tphydev->asym_pause = 0;\n\t\t} else if ((lpa & YTPHY_FLPA_ASYM_PAUSE)) {\n\t\t\tphydev->pause = 1;\n\t\t\tphydev->asym_pause = 1;\n\t\t} else {\n\t\t\tphydev->pause = 1;\n\t\t\tphydev->asym_pause = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int yt8521_read_status_paged(struct phy_device *phydev, int page)\n{\n\tint fiber_latch_val;\n\tint fiber_curr_val;\n\tint old_page;\n\tint ret = 0;\n\tint status;\n\tint link;\n\n\tlinkmode_zero(phydev->lp_advertising);\n\tphydev->duplex = DUPLEX_UNKNOWN;\n\tphydev->speed = SPEED_UNKNOWN;\n\tphydev->asym_pause = 0;\n\tphydev->pause = 0;\n\n\t \n\n\tpage &= YT8521_RSSR_SPACE_MASK;\n\told_page = phy_select_page(phydev, page);\n\tif (old_page < 0)\n\t\tgoto err_restore_page;\n\n\t \n\tret = __phy_read(phydev, YTPHY_SPECIFIC_STATUS_REG);\n\tif (ret < 0)\n\t\tgoto err_restore_page;\n\n\tstatus = ret;\n\tlink = !!(status & YTPHY_SSR_LINK);\n\n\t \n\tif (page == YT8521_RSSR_FIBER_SPACE) {\n\t\tret = __phy_read(phydev, MII_BMSR);\n\t\tif (ret < 0)\n\t\t\tgoto err_restore_page;\n\n\t\tfiber_latch_val = ret;\n\t\tret = __phy_read(phydev, MII_BMSR);\n\t\tif (ret < 0)\n\t\t\tgoto err_restore_page;\n\n\t\tfiber_curr_val = ret;\n\t\tif (link && fiber_latch_val != fiber_curr_val) {\n\t\t\tlink = 0;\n\t\t\tphydev_info(phydev,\n\t\t\t\t    \"%s, fiber link down detect, latch = %04x, curr = %04x\\n\",\n\t\t\t\t    __func__, fiber_latch_val, fiber_curr_val);\n\t\t}\n\t} else {\n\t\t \n\t\tret = __phy_read(phydev, MII_BMSR);\n\t\tif (ret < 0)\n\t\t\tgoto err_restore_page;\n\n\t\tphydev->autoneg_complete = ret & BMSR_ANEGCOMPLETE ? 1 : 0;\n\t}\n\n\tif (link) {\n\t\tif (page == YT8521_RSSR_UTP_SPACE)\n\t\t\tyt8521_adjust_status(phydev, status, true);\n\t\telse\n\t\t\tyt8521_adjust_status(phydev, status, false);\n\t}\n\treturn phy_restore_page(phydev, old_page, link);\n\nerr_restore_page:\n\treturn phy_restore_page(phydev, old_page, ret);\n}\n\n \nstatic int yt8521_read_status(struct phy_device *phydev)\n{\n\tstruct yt8521_priv *priv = phydev->priv;\n\tint link_fiber = 0;\n\tint link_utp;\n\tint link;\n\tint ret;\n\n\tif (priv->reg_page != YT8521_RSSR_TO_BE_ARBITRATED) {\n\t\tlink = yt8521_read_status_paged(phydev, priv->reg_page);\n\t\tif (link < 0)\n\t\t\treturn link;\n\t} else {\n\t\t \n\n\t\tlink_utp = yt8521_read_status_paged(phydev,\n\t\t\t\t\t\t    YT8521_RSSR_UTP_SPACE);\n\t\tif (link_utp < 0)\n\t\t\treturn link_utp;\n\n\t\tif (!link_utp) {\n\t\t\tlink_fiber = yt8521_read_status_paged(phydev,\n\t\t\t\t\t\t\t      YT8521_RSSR_FIBER_SPACE);\n\t\t\tif (link_fiber < 0)\n\t\t\t\treturn link_fiber;\n\t\t}\n\n\t\tlink = link_utp || link_fiber;\n\t}\n\n\tif (link) {\n\t\tif (phydev->link == 0) {\n\t\t\t \n\t\t\tif (priv->polling_mode == YT8521_MODE_POLL &&\n\t\t\t    priv->reg_page == YT8521_RSSR_TO_BE_ARBITRATED) {\n\t\t\t\tif (link_fiber)\n\t\t\t\t\tpriv->reg_page =\n\t\t\t\t\t\tYT8521_RSSR_FIBER_SPACE;\n\t\t\t\telse\n\t\t\t\t\tpriv->reg_page = YT8521_RSSR_UTP_SPACE;\n\n\t\t\t\tret = ytphy_write_ext_with_lock(phydev,\n\t\t\t\t\t\t\t\tYT8521_REG_SPACE_SELECT_REG,\n\t\t\t\t\t\t\t\tpriv->reg_page);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\n\t\t\t\tphydev->port = link_fiber ? PORT_FIBRE : PORT_TP;\n\n\t\t\t\tphydev_info(phydev, \"%s, link up, media: %s\\n\",\n\t\t\t\t\t    __func__,\n\t\t\t\t\t    (phydev->port == PORT_TP) ?\n\t\t\t\t\t    \"UTP\" : \"Fiber\");\n\t\t\t}\n\t\t}\n\t\tphydev->link = 1;\n\t} else {\n\t\tif (phydev->link == 1) {\n\t\t\tphydev_info(phydev, \"%s, link down, media: %s\\n\",\n\t\t\t\t    __func__, (phydev->port == PORT_TP) ?\n\t\t\t\t    \"UTP\" : \"Fiber\");\n\n\t\t\t \n\t\t\tif (priv->polling_mode == YT8521_MODE_POLL) {\n\t\t\t\tpriv->reg_page = YT8521_RSSR_TO_BE_ARBITRATED;\n\t\t\t\tphydev->port = PORT_NONE;\n\t\t\t}\n\t\t}\n\n\t\tphydev->link = 0;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int yt8521_modify_bmcr_paged(struct phy_device *phydev, int page,\n\t\t\t\t    u16 mask, u16 set)\n{\n\tint max_cnt = 500;  \n\tint old_page;\n\tint ret = 0;\n\n\told_page = phy_select_page(phydev, page & YT8521_RSSR_SPACE_MASK);\n\tif (old_page < 0)\n\t\tgoto err_restore_page;\n\n\tret = __phy_modify(phydev, MII_BMCR, mask, set);\n\tif (ret < 0)\n\t\tgoto err_restore_page;\n\n\t \n\tif (set == BMCR_RESET) {\n\t\twhile (max_cnt--) {\n\t\t\tusleep_range(1000, 1100);\n\t\t\tret = __phy_read(phydev, MII_BMCR);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto err_restore_page;\n\n\t\t\tif (!(ret & BMCR_RESET))\n\t\t\t\treturn phy_restore_page(phydev, old_page, 0);\n\t\t}\n\t}\n\nerr_restore_page:\n\treturn phy_restore_page(phydev, old_page, ret);\n}\n\n \nstatic int yt8521_modify_utp_fiber_bmcr(struct phy_device *phydev, u16 mask,\n\t\t\t\t\tu16 set)\n{\n\tstruct yt8521_priv *priv = phydev->priv;\n\tint ret;\n\n\tif (priv->reg_page != YT8521_RSSR_TO_BE_ARBITRATED) {\n\t\tret = yt8521_modify_bmcr_paged(phydev, priv->reg_page, mask,\n\t\t\t\t\t       set);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tret = yt8521_modify_bmcr_paged(phydev, YT8521_RSSR_UTP_SPACE,\n\t\t\t\t\t       mask, set);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = yt8521_modify_bmcr_paged(phydev, YT8521_RSSR_FIBER_SPACE,\n\t\t\t\t\t       mask, set);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nstatic int yt8521_soft_reset(struct phy_device *phydev)\n{\n\treturn yt8521_modify_utp_fiber_bmcr(phydev, 0, BMCR_RESET);\n}\n\n \nstatic int yt8521_suspend(struct phy_device *phydev)\n{\n\tint wol_config;\n\n\t \n\twol_config = ytphy_read_ext_with_lock(phydev, YTPHY_WOL_CONFIG_REG);\n\tif (wol_config < 0)\n\t\treturn wol_config;\n\n\t \n\tif (wol_config & YTPHY_WCR_ENABLE)\n\t\treturn 0;\n\n\treturn yt8521_modify_utp_fiber_bmcr(phydev, 0, BMCR_PDOWN);\n}\n\n \nstatic int yt8521_resume(struct phy_device *phydev)\n{\n\tint ret;\n\tint wol_config;\n\n\t \n\tret = ytphy_modify_ext_with_lock(phydev,\n\t\t\t\t\t YT8521_EXTREG_SLEEP_CONTROL1_REG,\n\t\t\t\t\t YT8521_ESC1R_SLEEP_SW, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twol_config = ytphy_read_ext_with_lock(phydev, YTPHY_WOL_CONFIG_REG);\n\tif (wol_config < 0)\n\t\treturn wol_config;\n\n\t \n\tif (wol_config & YTPHY_WCR_ENABLE)\n\t\treturn 0;\n\n\treturn yt8521_modify_utp_fiber_bmcr(phydev, BMCR_PDOWN, 0);\n}\n\n \nstatic int yt8521_config_init(struct phy_device *phydev)\n{\n\tstruct device_node *node = phydev->mdio.dev.of_node;\n\tint old_page;\n\tint ret = 0;\n\n\told_page = phy_select_page(phydev, YT8521_RSSR_UTP_SPACE);\n\tif (old_page < 0)\n\t\tgoto err_restore_page;\n\n\t \n\tif (phydev->interface != PHY_INTERFACE_MODE_SGMII) {\n\t\tret = ytphy_rgmii_clk_delay_config(phydev);\n\t\tif (ret < 0)\n\t\t\tgoto err_restore_page;\n\t}\n\n\tif (of_property_read_bool(node, \"motorcomm,auto-sleep-disabled\")) {\n\t\t \n\t\tret = ytphy_modify_ext(phydev, YT8521_EXTREG_SLEEP_CONTROL1_REG,\n\t\t\t\t       YT8521_ESC1R_SLEEP_SW, 0);\n\t\tif (ret < 0)\n\t\t\tgoto err_restore_page;\n\t}\n\n\tif (of_property_read_bool(node, \"motorcomm,keep-pll-enabled\")) {\n\t\t \n\t\tret = ytphy_modify_ext(phydev, YT8521_CLOCK_GATING_REG,\n\t\t\t\t       YT8521_CGR_RX_CLK_EN, 0);\n\t\tif (ret < 0)\n\t\t\tgoto err_restore_page;\n\t}\nerr_restore_page:\n\treturn phy_restore_page(phydev, old_page, ret);\n}\n\nstatic int yt8531_config_init(struct phy_device *phydev)\n{\n\tstruct device_node *node = phydev->mdio.dev.of_node;\n\tint ret;\n\n\tret = ytphy_rgmii_clk_delay_config_with_lock(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (of_property_read_bool(node, \"motorcomm,auto-sleep-disabled\")) {\n\t\t \n\t\tret = ytphy_modify_ext_with_lock(phydev,\n\t\t\t\t\t\t YT8521_EXTREG_SLEEP_CONTROL1_REG,\n\t\t\t\t\t\t YT8521_ESC1R_SLEEP_SW, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (of_property_read_bool(node, \"motorcomm,keep-pll-enabled\")) {\n\t\t \n\t\tret = ytphy_modify_ext_with_lock(phydev,\n\t\t\t\t\t\t YT8521_CLOCK_GATING_REG,\n\t\t\t\t\t\t YT8521_CGR_RX_CLK_EN, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = yt8531_set_ds(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic void yt8531_link_change_notify(struct phy_device *phydev)\n{\n\tstruct device_node *node = phydev->mdio.dev.of_node;\n\tbool tx_clk_1000_inverted = false;\n\tbool tx_clk_100_inverted = false;\n\tbool tx_clk_10_inverted = false;\n\tbool tx_clk_adj_enabled = false;\n\tu16 val = 0;\n\tint ret;\n\n\tif (of_property_read_bool(node, \"motorcomm,tx-clk-adj-enabled\"))\n\t\ttx_clk_adj_enabled = true;\n\n\tif (!tx_clk_adj_enabled)\n\t\treturn;\n\n\tif (of_property_read_bool(node, \"motorcomm,tx-clk-10-inverted\"))\n\t\ttx_clk_10_inverted = true;\n\tif (of_property_read_bool(node, \"motorcomm,tx-clk-100-inverted\"))\n\t\ttx_clk_100_inverted = true;\n\tif (of_property_read_bool(node, \"motorcomm,tx-clk-1000-inverted\"))\n\t\ttx_clk_1000_inverted = true;\n\n\tif (phydev->speed < 0)\n\t\treturn;\n\n\tswitch (phydev->speed) {\n\tcase SPEED_1000:\n\t\tif (tx_clk_1000_inverted)\n\t\t\tval = YT8521_RC1R_TX_CLK_SEL_INVERTED;\n\t\tbreak;\n\tcase SPEED_100:\n\t\tif (tx_clk_100_inverted)\n\t\t\tval = YT8521_RC1R_TX_CLK_SEL_INVERTED;\n\t\tbreak;\n\tcase SPEED_10:\n\t\tif (tx_clk_10_inverted)\n\t\t\tval = YT8521_RC1R_TX_CLK_SEL_INVERTED;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tret = ytphy_modify_ext_with_lock(phydev, YT8521_RGMII_CONFIG1_REG,\n\t\t\t\t\t YT8521_RC1R_TX_CLK_SEL_INVERTED, val);\n\tif (ret < 0)\n\t\tphydev_warn(phydev, \"Modify TX_CLK_SEL err:%d\\n\", ret);\n}\n\n \nstatic void yt8521_prepare_fiber_features(struct phy_device *phydev,\n\t\t\t\t\t  unsigned long *dst)\n{\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100baseFX_Full_BIT, dst);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT, dst);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, dst);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FIBRE_BIT, dst);\n}\n\n \nstatic int yt8521_fiber_setup_forced(struct phy_device *phydev)\n{\n\tu16 val;\n\tint ret;\n\n\tif (phydev->speed == SPEED_1000)\n\t\tval = YTPHY_MCR_FIBER_1000BX;\n\telse if (phydev->speed == SPEED_100)\n\t\tval = YTPHY_MCR_FIBER_100FX;\n\telse\n\t\treturn -EINVAL;\n\n\tret =  __phy_modify(phydev, MII_BMCR, BMCR_ANENABLE, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret =  ytphy_modify_ext(phydev, YT8521_LINK_TIMER_CFG2_REG,\n\t\t\t\tYT8521_LTCR_EN_AUTOSEN, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret =  ytphy_modify_ext(phydev, YTPHY_MISC_CONFIG_REG,\n\t\t\t\tYTPHY_MCR_FIBER_SPEED_MASK, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ytphy_modify_ext(phydev, YT8521_CHIP_CONFIG_REG,\n\t\t\t\tYT8521_CCR_SW_RST, 0);\n}\n\n \nstatic int ytphy_check_and_restart_aneg(struct phy_device *phydev, bool restart)\n{\n\tint ret;\n\n\tif (!restart) {\n\t\t \n\t\tret = __phy_read(phydev, MII_BMCR);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (!(ret & BMCR_ANENABLE) || (ret & BMCR_ISOLATE))\n\t\t\trestart = true;\n\t}\n\t \n\tif (restart)\n\t\treturn __phy_modify(phydev, MII_BMCR, BMCR_ISOLATE,\n\t\t\t\t    BMCR_ANENABLE | BMCR_ANRESTART);\n\n\treturn 0;\n}\n\n \nstatic int yt8521_fiber_config_aneg(struct phy_device *phydev)\n{\n\tint err, changed = 0;\n\tint bmcr;\n\tu16 adv;\n\n\tif (phydev->autoneg != AUTONEG_ENABLE)\n\t\treturn yt8521_fiber_setup_forced(phydev);\n\n\t \n\terr =  ytphy_modify_ext(phydev, YT8521_LINK_TIMER_CFG2_REG,\n\t\t\t\t0, YT8521_LTCR_EN_AUTOSEN);\n\tif (err < 0)\n\t\treturn err;\n\n\terr =  ytphy_modify_ext(phydev, YT8521_CHIP_CONFIG_REG,\n\t\t\t\tYT8521_CCR_SW_RST, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tbmcr = __phy_read(phydev, MII_BMCR);\n\tif (bmcr < 0)\n\t\treturn bmcr;\n\n\t \n\tif (!(bmcr & BMCR_ANENABLE)) {\n\t\t__phy_modify(phydev, MII_BMCR, 0, BMCR_PDOWN);\n\t\tusleep_range(1000, 1100);\n\t\t__phy_modify(phydev, MII_BMCR, BMCR_PDOWN, 0);\n\t}\n\n\tadv = linkmode_adv_to_mii_adv_x(phydev->advertising,\n\t\t\t\t\tETHTOOL_LINK_MODE_1000baseX_Full_BIT);\n\n\t \n\terr = __phy_modify_changed(phydev, MII_ADVERTISE,\n\t\t\t\t   ADVERTISE_1000XHALF | ADVERTISE_1000XFULL |\n\t\t\t\t   ADVERTISE_1000XPAUSE |\n\t\t\t\t   ADVERTISE_1000XPSE_ASYM,\n\t\t\t\t   adv);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (err > 0)\n\t\tchanged = 1;\n\n\treturn ytphy_check_and_restart_aneg(phydev, changed);\n}\n\n \nstatic int ytphy_setup_master_slave(struct phy_device *phydev)\n{\n\tu16 ctl = 0;\n\n\tif (!phydev->is_gigabit_capable)\n\t\treturn 0;\n\n\tswitch (phydev->master_slave_set) {\n\tcase MASTER_SLAVE_CFG_MASTER_PREFERRED:\n\t\tctl |= CTL1000_PREFER_MASTER;\n\t\tbreak;\n\tcase MASTER_SLAVE_CFG_SLAVE_PREFERRED:\n\t\tbreak;\n\tcase MASTER_SLAVE_CFG_MASTER_FORCE:\n\t\tctl |= CTL1000_AS_MASTER;\n\t\tfallthrough;\n\tcase MASTER_SLAVE_CFG_SLAVE_FORCE:\n\t\tctl |= CTL1000_ENABLE_MASTER;\n\t\tbreak;\n\tcase MASTER_SLAVE_CFG_UNKNOWN:\n\tcase MASTER_SLAVE_CFG_UNSUPPORTED:\n\t\treturn 0;\n\tdefault:\n\t\tphydev_warn(phydev, \"Unsupported Master/Slave mode\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn __phy_modify_changed(phydev, MII_CTRL1000,\n\t\t\t\t    (CTL1000_ENABLE_MASTER | CTL1000_AS_MASTER |\n\t\t\t\t    CTL1000_PREFER_MASTER), ctl);\n}\n\n \nstatic int ytphy_utp_config_advert(struct phy_device *phydev)\n{\n\tint err, bmsr, changed = 0;\n\tu32 adv;\n\n\t \n\tlinkmode_and(phydev->advertising, phydev->advertising,\n\t\t     phydev->supported);\n\n\tadv = linkmode_adv_to_mii_adv_t(phydev->advertising);\n\n\t \n\terr = __phy_modify_changed(phydev, MII_ADVERTISE,\n\t\t\t\t   ADVERTISE_ALL | ADVERTISE_100BASE4 |\n\t\t\t\t   ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM,\n\t\t\t\t   adv);\n\tif (err < 0)\n\t\treturn err;\n\tif (err > 0)\n\t\tchanged = 1;\n\n\tbmsr = __phy_read(phydev, MII_BMSR);\n\tif (bmsr < 0)\n\t\treturn bmsr;\n\n\t \n\tif (!(bmsr & BMSR_ESTATEN))\n\t\treturn changed;\n\n\tadv = linkmode_adv_to_mii_ctrl1000_t(phydev->advertising);\n\n\terr = __phy_modify_changed(phydev, MII_CTRL1000,\n\t\t\t\t   ADVERTISE_1000FULL | ADVERTISE_1000HALF,\n\t\t\t\t   adv);\n\tif (err < 0)\n\t\treturn err;\n\tif (err > 0)\n\t\tchanged = 1;\n\n\treturn changed;\n}\n\n \nstatic int ytphy_utp_config_aneg(struct phy_device *phydev, bool changed)\n{\n\tint err;\n\tu16 ctl;\n\n\terr = ytphy_setup_master_slave(phydev);\n\tif (err < 0)\n\t\treturn err;\n\telse if (err)\n\t\tchanged = true;\n\n\tif (phydev->autoneg != AUTONEG_ENABLE) {\n\t\t \n\n\t\tctl = mii_bmcr_encode_fixed(phydev->speed, phydev->duplex);\n\n\t\treturn __phy_modify(phydev, MII_BMCR, ~(BMCR_LOOPBACK |\n\t\t\t\t    BMCR_ISOLATE | BMCR_PDOWN), ctl);\n\t}\n\n\terr = ytphy_utp_config_advert(phydev);\n\tif (err < 0)  \n\t\treturn err;\n\telse if (err)\n\t\tchanged = true;\n\n\treturn ytphy_check_and_restart_aneg(phydev, changed);\n}\n\n \nstatic int yt8521_config_aneg_paged(struct phy_device *phydev, int page)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(fiber_supported);\n\tstruct yt8521_priv *priv = phydev->priv;\n\tint old_page;\n\tint ret = 0;\n\n\tpage &= YT8521_RSSR_SPACE_MASK;\n\n\told_page = phy_select_page(phydev, page);\n\tif (old_page < 0)\n\t\tgoto err_restore_page;\n\n\t \n\tif (priv->reg_page == YT8521_RSSR_TO_BE_ARBITRATED) {\n\t\tlinkmode_zero(fiber_supported);\n\t\tyt8521_prepare_fiber_features(phydev, fiber_supported);\n\n\t\t \n\t\tif (page == YT8521_RSSR_FIBER_SPACE) {\n\t\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_Pause_BIT,\n\t\t\t\t\t fiber_supported);\n\t\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,\n\t\t\t\t\t fiber_supported);\n\t\t\tlinkmode_and(phydev->advertising,\n\t\t\t\t     priv->combo_advertising, fiber_supported);\n\t\t} else {\n\t\t\t \n\t\t\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,\n\t\t\t\t\t   fiber_supported);\n\t\t\tlinkmode_andnot(phydev->advertising,\n\t\t\t\t\tpriv->combo_advertising,\n\t\t\t\t\tfiber_supported);\n\t\t}\n\t}\n\n\tif (page == YT8521_RSSR_FIBER_SPACE)\n\t\tret = yt8521_fiber_config_aneg(phydev);\n\telse\n\t\tret = ytphy_utp_config_aneg(phydev, false);\n\nerr_restore_page:\n\treturn phy_restore_page(phydev, old_page, ret);\n}\n\n \nstatic int yt8521_config_aneg(struct phy_device *phydev)\n{\n\tstruct yt8521_priv *priv = phydev->priv;\n\tint ret;\n\n\tif (priv->reg_page != YT8521_RSSR_TO_BE_ARBITRATED) {\n\t\tret = yt8521_config_aneg_paged(phydev, priv->reg_page);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\t \n\t\tif (linkmode_empty(priv->combo_advertising)) {\n\t\t\tlinkmode_copy(priv->combo_advertising,\n\t\t\t\t      phydev->advertising);\n\t\t}\n\n\t\tret = yt8521_config_aneg_paged(phydev, YT8521_RSSR_UTP_SPACE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = yt8521_config_aneg_paged(phydev, YT8521_RSSR_FIBER_SPACE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tlinkmode_copy(phydev->advertising, priv->combo_advertising);\n\t}\n\treturn 0;\n}\n\n \nstatic int yt8521_aneg_done_paged(struct phy_device *phydev, int page)\n{\n\tint old_page;\n\tint ret = 0;\n\tint link;\n\n\told_page = phy_select_page(phydev, page & YT8521_RSSR_SPACE_MASK);\n\tif (old_page < 0)\n\t\tgoto err_restore_page;\n\n\tret = __phy_read(phydev, YTPHY_SPECIFIC_STATUS_REG);\n\tif (ret < 0)\n\t\tgoto err_restore_page;\n\n\tlink = !!(ret & YTPHY_SSR_LINK);\n\tret = link;\n\nerr_restore_page:\n\treturn phy_restore_page(phydev, old_page, ret);\n}\n\n \nstatic int yt8521_aneg_done(struct phy_device *phydev)\n{\n\tstruct yt8521_priv *priv = phydev->priv;\n\tint link_fiber = 0;\n\tint link_utp;\n\tint link;\n\n\tif (priv->reg_page != YT8521_RSSR_TO_BE_ARBITRATED) {\n\t\tlink = yt8521_aneg_done_paged(phydev, priv->reg_page);\n\t} else {\n\t\tlink_utp = yt8521_aneg_done_paged(phydev,\n\t\t\t\t\t\t  YT8521_RSSR_UTP_SPACE);\n\t\tif (link_utp < 0)\n\t\t\treturn link_utp;\n\n\t\tif (!link_utp) {\n\t\t\tlink_fiber = yt8521_aneg_done_paged(phydev,\n\t\t\t\t\t\t\t    YT8521_RSSR_FIBER_SPACE);\n\t\t\tif (link_fiber < 0)\n\t\t\t\treturn link_fiber;\n\t\t}\n\t\tlink = link_fiber || link_utp;\n\t\tphydev_info(phydev, \"%s, link_fiber: %d, link_utp: %d\\n\",\n\t\t\t    __func__, link_fiber, link_utp);\n\t}\n\n\treturn link;\n}\n\n \nstatic int ytphy_utp_read_abilities(struct phy_device *phydev)\n{\n\tint val;\n\n\tlinkmode_set_bit_array(phy_basic_ports_array,\n\t\t\t       ARRAY_SIZE(phy_basic_ports_array),\n\t\t\t       phydev->supported);\n\n\tval = __phy_read(phydev, MII_BMSR);\n\tif (val < 0)\n\t\treturn val;\n\n\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, phydev->supported,\n\t\t\t val & BMSR_ANEGCAPABLE);\n\n\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, phydev->supported,\n\t\t\t val & BMSR_100FULL);\n\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT, phydev->supported,\n\t\t\t val & BMSR_100HALF);\n\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT, phydev->supported,\n\t\t\t val & BMSR_10FULL);\n\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT, phydev->supported,\n\t\t\t val & BMSR_10HALF);\n\n\tif (val & BMSR_ESTATEN) {\n\t\tval = __phy_read(phydev, MII_ESTATUS);\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,\n\t\t\t\t phydev->supported, val & ESTATUS_1000_TFULL);\n\t\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT,\n\t\t\t\t phydev->supported, val & ESTATUS_1000_THALF);\n\t\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT,\n\t\t\t\t phydev->supported, val & ESTATUS_1000_XFULL);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int yt8521_get_features_paged(struct phy_device *phydev, int page)\n{\n\tint old_page;\n\tint ret = 0;\n\n\tpage &= YT8521_RSSR_SPACE_MASK;\n\told_page = phy_select_page(phydev, page);\n\tif (old_page < 0)\n\t\tgoto err_restore_page;\n\n\tif (page == YT8521_RSSR_FIBER_SPACE) {\n\t\tlinkmode_zero(phydev->supported);\n\t\tyt8521_prepare_fiber_features(phydev, phydev->supported);\n\t} else {\n\t\tret = ytphy_utp_read_abilities(phydev);\n\t\tif (ret < 0)\n\t\t\tgoto err_restore_page;\n\t}\n\nerr_restore_page:\n\treturn phy_restore_page(phydev, old_page, ret);\n}\n\n \nstatic int yt8521_get_features(struct phy_device *phydev)\n{\n\tstruct yt8521_priv *priv = phydev->priv;\n\tint ret;\n\n\tif (priv->reg_page != YT8521_RSSR_TO_BE_ARBITRATED) {\n\t\tret = yt8521_get_features_paged(phydev, priv->reg_page);\n\t} else {\n\t\tret = yt8521_get_features_paged(phydev,\n\t\t\t\t\t\tYT8521_RSSR_UTP_SPACE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tyt8521_prepare_fiber_features(phydev, phydev->supported);\n\t}\n\treturn ret;\n}\n\nstatic struct phy_driver motorcomm_phy_drvs[] = {\n\t{\n\t\tPHY_ID_MATCH_EXACT(PHY_ID_YT8511),\n\t\t.name\t\t= \"YT8511 Gigabit Ethernet\",\n\t\t.config_init\t= yt8511_config_init,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= genphy_resume,\n\t\t.read_page\t= yt8511_read_page,\n\t\t.write_page\t= yt8511_write_page,\n\t},\n\t{\n\t\tPHY_ID_MATCH_EXACT(PHY_ID_YT8521),\n\t\t.name\t\t= \"YT8521 Gigabit Ethernet\",\n\t\t.get_features\t= yt8521_get_features,\n\t\t.probe\t\t= yt8521_probe,\n\t\t.read_page\t= yt8521_read_page,\n\t\t.write_page\t= yt8521_write_page,\n\t\t.get_wol\t= ytphy_get_wol,\n\t\t.set_wol\t= ytphy_set_wol,\n\t\t.config_aneg\t= yt8521_config_aneg,\n\t\t.aneg_done\t= yt8521_aneg_done,\n\t\t.config_init\t= yt8521_config_init,\n\t\t.read_status\t= yt8521_read_status,\n\t\t.soft_reset\t= yt8521_soft_reset,\n\t\t.suspend\t= yt8521_suspend,\n\t\t.resume\t\t= yt8521_resume,\n\t},\n\t{\n\t\tPHY_ID_MATCH_EXACT(PHY_ID_YT8531),\n\t\t.name\t\t= \"YT8531 Gigabit Ethernet\",\n\t\t.probe\t\t= yt8531_probe,\n\t\t.config_init\t= yt8531_config_init,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= genphy_resume,\n\t\t.get_wol\t= ytphy_get_wol,\n\t\t.set_wol\t= yt8531_set_wol,\n\t\t.link_change_notify = yt8531_link_change_notify,\n\t},\n\t{\n\t\tPHY_ID_MATCH_EXACT(PHY_ID_YT8531S),\n\t\t.name\t\t= \"YT8531S Gigabit Ethernet\",\n\t\t.get_features\t= yt8521_get_features,\n\t\t.probe\t\t= yt8521_probe,\n\t\t.read_page\t= yt8521_read_page,\n\t\t.write_page\t= yt8521_write_page,\n\t\t.get_wol\t= ytphy_get_wol,\n\t\t.set_wol\t= ytphy_set_wol,\n\t\t.config_aneg\t= yt8521_config_aneg,\n\t\t.aneg_done\t= yt8521_aneg_done,\n\t\t.config_init\t= yt8521_config_init,\n\t\t.read_status\t= yt8521_read_status,\n\t\t.soft_reset\t= yt8521_soft_reset,\n\t\t.suspend\t= yt8521_suspend,\n\t\t.resume\t\t= yt8521_resume,\n\t},\n};\n\nmodule_phy_driver(motorcomm_phy_drvs);\n\nMODULE_DESCRIPTION(\"Motorcomm 8511/8521/8531/8531S PHY driver\");\nMODULE_AUTHOR(\"Peter Geis\");\nMODULE_AUTHOR(\"Frank\");\nMODULE_LICENSE(\"GPL\");\n\nstatic const struct mdio_device_id __maybe_unused motorcomm_tbl[] = {\n\t{ PHY_ID_MATCH_EXACT(PHY_ID_YT8511) },\n\t{ PHY_ID_MATCH_EXACT(PHY_ID_YT8521) },\n\t{ PHY_ID_MATCH_EXACT(PHY_ID_YT8531) },\n\t{ PHY_ID_MATCH_EXACT(PHY_ID_YT8531S) },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(mdio, motorcomm_tbl);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}