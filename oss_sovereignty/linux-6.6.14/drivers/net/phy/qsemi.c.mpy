{
  "module_name": "qsemi.c",
  "hash_id": "2a29c5701d322711502f4aa7c7c1e80623cf6dd3aad9cb5762bd3c82ffc0c0f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/qsemi.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/unistd.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/phy.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <linux/uaccess.h>\n\n \n \n\n \n\n#define MII_QS6612_MCR\t\t17   \n#define MII_QS6612_FTR\t\t27   \n#define MII_QS6612_MCO\t\t28   \n#define MII_QS6612_ISR\t\t29   \n#define MII_QS6612_IMR\t\t30   \n#define MII_QS6612_IMR_INIT\t0x003a\n#define MII_QS6612_PCR\t\t31   \n\n#define QS6612_PCR_AN_COMPLETE\t0x1000\n#define QS6612_PCR_RLBEN\t0x0200\n#define QS6612_PCR_DCREN\t0x0100\n#define QS6612_PCR_4B5BEN\t0x0040\n#define QS6612_PCR_TX_ISOLATE\t0x0020\n#define QS6612_PCR_MLT3_DIS\t0x0002\n#define QS6612_PCR_SCRM_DESCRM\t0x0001\n\nMODULE_DESCRIPTION(\"Quality Semiconductor PHY driver\");\nMODULE_AUTHOR(\"Andy Fleming\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic int qs6612_config_init(struct phy_device *phydev)\n{\n\t \n\treturn phy_write(phydev, MII_QS6612_PCR, 0x0dc0);\n}\n\nstatic int qs6612_ack_interrupt(struct phy_device *phydev)\n{\n\tint err;\n\n\t \n\terr = phy_read(phydev, MII_QS6612_ISR);\n\n\tif (err < 0)\n\t\treturn err;\n\n\terr = phy_read(phydev, MII_BMSR);\n\n\tif (err < 0)\n\t\treturn err;\n\n\terr = phy_read(phydev, MII_EXPANSION);\n\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int qs6612_config_intr(struct phy_device *phydev)\n{\n\tint err;\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\t \n\t\terr = qs6612_ack_interrupt(phydev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = phy_write(phydev, MII_QS6612_IMR,\n\t\t\t\tMII_QS6612_IMR_INIT);\n\t} else {\n\t\terr = phy_write(phydev, MII_QS6612_IMR, 0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\terr = qs6612_ack_interrupt(phydev);\n\t}\n\n\treturn err;\n\n}\n\nstatic irqreturn_t qs6612_handle_interrupt(struct phy_device *phydev)\n{\n\tint irq_status;\n\n\tirq_status = phy_read(phydev, MII_QS6612_ISR);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (!(irq_status & MII_QS6612_IMR_INIT))\n\t\treturn IRQ_NONE;\n\n\t \n\tqs6612_ack_interrupt(phydev);\n\n\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct phy_driver qs6612_driver[] = { {\n\t.phy_id\t\t= 0x00181440,\n\t.name\t\t= \"QS6612\",\n\t.phy_id_mask\t= 0xfffffff0,\n\t \n\t.config_init\t= qs6612_config_init,\n\t.config_intr\t= qs6612_config_intr,\n\t.handle_interrupt = qs6612_handle_interrupt,\n} };\n\nmodule_phy_driver(qs6612_driver);\n\nstatic struct mdio_device_id __maybe_unused qs6612_tbl[] = {\n\t{ 0x00181440, 0xfffffff0 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(mdio, qs6612_tbl);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}