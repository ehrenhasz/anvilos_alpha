{
  "module_name": "realtek.c",
  "hash_id": "5098148f13ef2c66bf19c66b7e3be1b38309585f407ef63569dfb19188fa8525",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/realtek.c",
  "human_readable_source": "\n \n#include <linux/bitops.h>\n#include <linux/of.h>\n#include <linux/phy.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/clk.h>\n\n#define RTL821x_PHYSR\t\t\t\t0x11\n#define RTL821x_PHYSR_DUPLEX\t\t\tBIT(13)\n#define RTL821x_PHYSR_SPEED\t\t\tGENMASK(15, 14)\n\n#define RTL821x_INER\t\t\t\t0x12\n#define RTL8211B_INER_INIT\t\t\t0x6400\n#define RTL8211E_INER_LINK_STATUS\t\tBIT(10)\n#define RTL8211F_INER_LINK_STATUS\t\tBIT(4)\n\n#define RTL821x_INSR\t\t\t\t0x13\n\n#define RTL821x_EXT_PAGE_SELECT\t\t\t0x1e\n#define RTL821x_PAGE_SELECT\t\t\t0x1f\n\n#define RTL8211F_PHYCR1\t\t\t\t0x18\n#define RTL8211F_PHYCR2\t\t\t\t0x19\n#define RTL8211F_INSR\t\t\t\t0x1d\n\n#define RTL8211F_TX_DELAY\t\t\tBIT(8)\n#define RTL8211F_RX_DELAY\t\t\tBIT(3)\n\n#define RTL8211F_ALDPS_PLL_OFF\t\t\tBIT(1)\n#define RTL8211F_ALDPS_ENABLE\t\t\tBIT(2)\n#define RTL8211F_ALDPS_XTAL_OFF\t\t\tBIT(12)\n\n#define RTL8211E_CTRL_DELAY\t\t\tBIT(13)\n#define RTL8211E_TX_DELAY\t\t\tBIT(12)\n#define RTL8211E_RX_DELAY\t\t\tBIT(11)\n\n#define RTL8211F_CLKOUT_EN\t\t\tBIT(0)\n\n#define RTL8201F_ISR\t\t\t\t0x1e\n#define RTL8201F_ISR_ANERR\t\t\tBIT(15)\n#define RTL8201F_ISR_DUPLEX\t\t\tBIT(13)\n#define RTL8201F_ISR_LINK\t\t\tBIT(11)\n#define RTL8201F_ISR_MASK\t\t\t(RTL8201F_ISR_ANERR | \\\n\t\t\t\t\t\t RTL8201F_ISR_DUPLEX | \\\n\t\t\t\t\t\t RTL8201F_ISR_LINK)\n#define RTL8201F_IER\t\t\t\t0x13\n\n#define RTL8366RB_POWER_SAVE\t\t\t0x15\n#define RTL8366RB_POWER_SAVE_ON\t\t\tBIT(12)\n\n#define RTL_SUPPORTS_5000FULL\t\t\tBIT(14)\n#define RTL_SUPPORTS_2500FULL\t\t\tBIT(13)\n#define RTL_SUPPORTS_10000FULL\t\t\tBIT(0)\n#define RTL_ADV_2500FULL\t\t\tBIT(7)\n#define RTL_LPADV_10000FULL\t\t\tBIT(11)\n#define RTL_LPADV_5000FULL\t\t\tBIT(6)\n#define RTL_LPADV_2500FULL\t\t\tBIT(5)\n\n#define RTL9000A_GINMR\t\t\t\t0x14\n#define RTL9000A_GINMR_LINK_STATUS\t\tBIT(4)\n\n#define RTLGEN_SPEED_MASK\t\t\t0x0630\n\n#define RTL_GENERIC_PHYID\t\t\t0x001cc800\n#define RTL_8211FVD_PHYID\t\t\t0x001cc878\n\nMODULE_DESCRIPTION(\"Realtek PHY driver\");\nMODULE_AUTHOR(\"Johnson Leung\");\nMODULE_LICENSE(\"GPL\");\n\nstruct rtl821x_priv {\n\tu16 phycr1;\n\tu16 phycr2;\n\tbool has_phycr2;\n\tstruct clk *clk;\n};\n\nstatic int rtl821x_read_page(struct phy_device *phydev)\n{\n\treturn __phy_read(phydev, RTL821x_PAGE_SELECT);\n}\n\nstatic int rtl821x_write_page(struct phy_device *phydev, int page)\n{\n\treturn __phy_write(phydev, RTL821x_PAGE_SELECT, page);\n}\n\nstatic int rtl821x_probe(struct phy_device *phydev)\n{\n\tstruct device *dev = &phydev->mdio.dev;\n\tstruct rtl821x_priv *priv;\n\tu32 phy_id = phydev->drv->phy_id;\n\tint ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->clk = devm_clk_get_optional_enabled(dev, NULL);\n\tif (IS_ERR(priv->clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->clk),\n\t\t\t\t     \"failed to get phy clock\\n\");\n\n\tret = phy_read_paged(phydev, 0xa43, RTL8211F_PHYCR1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpriv->phycr1 = ret & (RTL8211F_ALDPS_PLL_OFF | RTL8211F_ALDPS_ENABLE | RTL8211F_ALDPS_XTAL_OFF);\n\tif (of_property_read_bool(dev->of_node, \"realtek,aldps-enable\"))\n\t\tpriv->phycr1 |= RTL8211F_ALDPS_PLL_OFF | RTL8211F_ALDPS_ENABLE | RTL8211F_ALDPS_XTAL_OFF;\n\n\tpriv->has_phycr2 = !(phy_id == RTL_8211FVD_PHYID);\n\tif (priv->has_phycr2) {\n\t\tret = phy_read_paged(phydev, 0xa43, RTL8211F_PHYCR2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tpriv->phycr2 = ret & RTL8211F_CLKOUT_EN;\n\t\tif (of_property_read_bool(dev->of_node, \"realtek,clkout-disable\"))\n\t\t\tpriv->phycr2 &= ~RTL8211F_CLKOUT_EN;\n\t}\n\n\tphydev->priv = priv;\n\n\treturn 0;\n}\n\nstatic int rtl8201_ack_interrupt(struct phy_device *phydev)\n{\n\tint err;\n\n\terr = phy_read(phydev, RTL8201F_ISR);\n\n\treturn (err < 0) ? err : 0;\n}\n\nstatic int rtl821x_ack_interrupt(struct phy_device *phydev)\n{\n\tint err;\n\n\terr = phy_read(phydev, RTL821x_INSR);\n\n\treturn (err < 0) ? err : 0;\n}\n\nstatic int rtl8211f_ack_interrupt(struct phy_device *phydev)\n{\n\tint err;\n\n\terr = phy_read_paged(phydev, 0xa43, RTL8211F_INSR);\n\n\treturn (err < 0) ? err : 0;\n}\n\nstatic int rtl8201_config_intr(struct phy_device *phydev)\n{\n\tu16 val;\n\tint err;\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\terr = rtl8201_ack_interrupt(phydev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tval = BIT(13) | BIT(12) | BIT(11);\n\t\terr = phy_write_paged(phydev, 0x7, RTL8201F_IER, val);\n\t} else {\n\t\tval = 0;\n\t\terr = phy_write_paged(phydev, 0x7, RTL8201F_IER, val);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = rtl8201_ack_interrupt(phydev);\n\t}\n\n\treturn err;\n}\n\nstatic int rtl8211b_config_intr(struct phy_device *phydev)\n{\n\tint err;\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\terr = rtl821x_ack_interrupt(phydev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = phy_write(phydev, RTL821x_INER,\n\t\t\t\tRTL8211B_INER_INIT);\n\t} else {\n\t\terr = phy_write(phydev, RTL821x_INER, 0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = rtl821x_ack_interrupt(phydev);\n\t}\n\n\treturn err;\n}\n\nstatic int rtl8211e_config_intr(struct phy_device *phydev)\n{\n\tint err;\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\terr = rtl821x_ack_interrupt(phydev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = phy_write(phydev, RTL821x_INER,\n\t\t\t\tRTL8211E_INER_LINK_STATUS);\n\t} else {\n\t\terr = phy_write(phydev, RTL821x_INER, 0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = rtl821x_ack_interrupt(phydev);\n\t}\n\n\treturn err;\n}\n\nstatic int rtl8211f_config_intr(struct phy_device *phydev)\n{\n\tu16 val;\n\tint err;\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\terr = rtl8211f_ack_interrupt(phydev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tval = RTL8211F_INER_LINK_STATUS;\n\t\terr = phy_write_paged(phydev, 0xa42, RTL821x_INER, val);\n\t} else {\n\t\tval = 0;\n\t\terr = phy_write_paged(phydev, 0xa42, RTL821x_INER, val);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = rtl8211f_ack_interrupt(phydev);\n\t}\n\n\treturn err;\n}\n\nstatic irqreturn_t rtl8201_handle_interrupt(struct phy_device *phydev)\n{\n\tint irq_status;\n\n\tirq_status = phy_read(phydev, RTL8201F_ISR);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (!(irq_status & RTL8201F_ISR_MASK))\n\t\treturn IRQ_NONE;\n\n\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t rtl821x_handle_interrupt(struct phy_device *phydev)\n{\n\tint irq_status, irq_enabled;\n\n\tirq_status = phy_read(phydev, RTL821x_INSR);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tirq_enabled = phy_read(phydev, RTL821x_INER);\n\tif (irq_enabled < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (!(irq_status & irq_enabled))\n\t\treturn IRQ_NONE;\n\n\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t rtl8211f_handle_interrupt(struct phy_device *phydev)\n{\n\tint irq_status;\n\n\tirq_status = phy_read_paged(phydev, 0xa43, RTL8211F_INSR);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (!(irq_status & RTL8211F_INER_LINK_STATUS))\n\t\treturn IRQ_NONE;\n\n\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rtl8211_config_aneg(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = genphy_config_aneg(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (phydev->speed == SPEED_100 && phydev->autoneg == AUTONEG_DISABLE) {\n\t\tphy_write(phydev, 0x17, 0x2138);\n\t\tphy_write(phydev, 0x0e, 0x0260);\n\t} else {\n\t\tphy_write(phydev, 0x17, 0x2108);\n\t\tphy_write(phydev, 0x0e, 0x0000);\n\t}\n\n\treturn 0;\n}\n\nstatic int rtl8211c_config_init(struct phy_device *phydev)\n{\n\t \n\treturn phy_set_bits(phydev, MII_CTRL1000,\n\t\t\t    CTL1000_ENABLE_MASTER | CTL1000_AS_MASTER);\n}\n\nstatic int rtl8211f_config_init(struct phy_device *phydev)\n{\n\tstruct rtl821x_priv *priv = phydev->priv;\n\tstruct device *dev = &phydev->mdio.dev;\n\tu16 val_txdly, val_rxdly;\n\tint ret;\n\n\tret = phy_modify_paged_changed(phydev, 0xa43, RTL8211F_PHYCR1,\n\t\t\t\t       RTL8211F_ALDPS_PLL_OFF | RTL8211F_ALDPS_ENABLE | RTL8211F_ALDPS_XTAL_OFF,\n\t\t\t\t       priv->phycr1);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"aldps mode  configuration failed: %pe\\n\",\n\t\t\tERR_PTR(ret));\n\t\treturn ret;\n\t}\n\n\tswitch (phydev->interface) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\t\tval_txdly = 0;\n\t\tval_rxdly = 0;\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\tval_txdly = 0;\n\t\tval_rxdly = RTL8211F_RX_DELAY;\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tval_txdly = RTL8211F_TX_DELAY;\n\t\tval_rxdly = 0;\n\t\tbreak;\n\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\t\tval_txdly = RTL8211F_TX_DELAY;\n\t\tval_rxdly = RTL8211F_RX_DELAY;\n\t\tbreak;\n\n\tdefault:  \n\t\treturn 0;\n\t}\n\n\tret = phy_modify_paged_changed(phydev, 0xd08, 0x11, RTL8211F_TX_DELAY,\n\t\t\t\t       val_txdly);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to update the TX delay register\\n\");\n\t\treturn ret;\n\t} else if (ret) {\n\t\tdev_dbg(dev,\n\t\t\t\"%s 2ns TX delay (and changing the value from pin-strapping RXD1 or the bootloader)\\n\",\n\t\t\tval_txdly ? \"Enabling\" : \"Disabling\");\n\t} else {\n\t\tdev_dbg(dev,\n\t\t\t\"2ns TX delay was already %s (by pin-strapping RXD1 or bootloader configuration)\\n\",\n\t\t\tval_txdly ? \"enabled\" : \"disabled\");\n\t}\n\n\tret = phy_modify_paged_changed(phydev, 0xd08, 0x15, RTL8211F_RX_DELAY,\n\t\t\t\t       val_rxdly);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to update the RX delay register\\n\");\n\t\treturn ret;\n\t} else if (ret) {\n\t\tdev_dbg(dev,\n\t\t\t\"%s 2ns RX delay (and changing the value from pin-strapping RXD0 or the bootloader)\\n\",\n\t\t\tval_rxdly ? \"Enabling\" : \"Disabling\");\n\t} else {\n\t\tdev_dbg(dev,\n\t\t\t\"2ns RX delay was already %s (by pin-strapping RXD0 or bootloader configuration)\\n\",\n\t\t\tval_rxdly ? \"enabled\" : \"disabled\");\n\t}\n\n\tif (priv->has_phycr2) {\n\t\tret = phy_modify_paged(phydev, 0xa43, RTL8211F_PHYCR2,\n\t\t\t\t       RTL8211F_CLKOUT_EN, priv->phycr2);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"clkout configuration failed: %pe\\n\",\n\t\t\t\tERR_PTR(ret));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn genphy_soft_reset(phydev);\n}\n\nstatic int rtl821x_suspend(struct phy_device *phydev)\n{\n\tstruct rtl821x_priv *priv = phydev->priv;\n\tint ret = 0;\n\n\tif (!phydev->wol_enabled) {\n\t\tret = genphy_suspend(phydev);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tclk_disable_unprepare(priv->clk);\n\t}\n\n\treturn ret;\n}\n\nstatic int rtl821x_resume(struct phy_device *phydev)\n{\n\tstruct rtl821x_priv *priv = phydev->priv;\n\tint ret;\n\n\tif (!phydev->wol_enabled)\n\t\tclk_prepare_enable(priv->clk);\n\n\tret = genphy_resume(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmsleep(20);\n\n\treturn 0;\n}\n\nstatic int rtl8211e_config_init(struct phy_device *phydev)\n{\n\tint ret = 0, oldpage;\n\tu16 val;\n\n\t \n\tswitch (phydev->interface) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\t\tval = RTL8211E_CTRL_DELAY | 0;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\t\tval = RTL8211E_CTRL_DELAY | RTL8211E_TX_DELAY | RTL8211E_RX_DELAY;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\tval = RTL8211E_CTRL_DELAY | RTL8211E_RX_DELAY;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\tval = RTL8211E_CTRL_DELAY | RTL8211E_TX_DELAY;\n\t\tbreak;\n\tdefault:  \n\t\treturn 0;\n\t}\n\n\t \n\toldpage = phy_select_page(phydev, 0x7);\n\tif (oldpage < 0)\n\t\tgoto err_restore_page;\n\n\tret = __phy_write(phydev, RTL821x_EXT_PAGE_SELECT, 0xa4);\n\tif (ret)\n\t\tgoto err_restore_page;\n\n\tret = __phy_modify(phydev, 0x1c, RTL8211E_CTRL_DELAY\n\t\t\t   | RTL8211E_TX_DELAY | RTL8211E_RX_DELAY,\n\t\t\t   val);\n\nerr_restore_page:\n\treturn phy_restore_page(phydev, oldpage, ret);\n}\n\nstatic int rtl8211b_suspend(struct phy_device *phydev)\n{\n\tphy_write(phydev, MII_MMD_DATA, BIT(9));\n\n\treturn genphy_suspend(phydev);\n}\n\nstatic int rtl8211b_resume(struct phy_device *phydev)\n{\n\tphy_write(phydev, MII_MMD_DATA, 0);\n\n\treturn genphy_resume(phydev);\n}\n\nstatic int rtl8366rb_config_init(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = phy_set_bits(phydev, RTL8366RB_POWER_SAVE,\n\t\t\t   RTL8366RB_POWER_SAVE_ON);\n\tif (ret) {\n\t\tdev_err(&phydev->mdio.dev,\n\t\t\t\"error enabling power management\\n\");\n\t}\n\n\treturn ret;\n}\n\n \nstatic int rtlgen_get_speed(struct phy_device *phydev)\n{\n\tint val;\n\n\tif (!phydev->link)\n\t\treturn 0;\n\n\tval = phy_read_paged(phydev, 0xa43, 0x12);\n\tif (val < 0)\n\t\treturn val;\n\n\tswitch (val & RTLGEN_SPEED_MASK) {\n\tcase 0x0000:\n\t\tphydev->speed = SPEED_10;\n\t\tbreak;\n\tcase 0x0010:\n\t\tphydev->speed = SPEED_100;\n\t\tbreak;\n\tcase 0x0020:\n\t\tphydev->speed = SPEED_1000;\n\t\tbreak;\n\tcase 0x0200:\n\t\tphydev->speed = SPEED_10000;\n\t\tbreak;\n\tcase 0x0210:\n\t\tphydev->speed = SPEED_2500;\n\t\tbreak;\n\tcase 0x0220:\n\t\tphydev->speed = SPEED_5000;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtlgen_read_status(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = genphy_read_status(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn rtlgen_get_speed(phydev);\n}\n\nstatic int rtlgen_read_mmd(struct phy_device *phydev, int devnum, u16 regnum)\n{\n\tint ret;\n\n\tif (devnum == MDIO_MMD_PCS && regnum == MDIO_PCS_EEE_ABLE) {\n\t\trtl821x_write_page(phydev, 0xa5c);\n\t\tret = __phy_read(phydev, 0x12);\n\t\trtl821x_write_page(phydev, 0);\n\t} else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_ADV) {\n\t\trtl821x_write_page(phydev, 0xa5d);\n\t\tret = __phy_read(phydev, 0x10);\n\t\trtl821x_write_page(phydev, 0);\n\t} else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_LPABLE) {\n\t\trtl821x_write_page(phydev, 0xa5d);\n\t\tret = __phy_read(phydev, 0x11);\n\t\trtl821x_write_page(phydev, 0);\n\t} else {\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstatic int rtlgen_write_mmd(struct phy_device *phydev, int devnum, u16 regnum,\n\t\t\t    u16 val)\n{\n\tint ret;\n\n\tif (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_ADV) {\n\t\trtl821x_write_page(phydev, 0xa5d);\n\t\tret = __phy_write(phydev, 0x10, val);\n\t\trtl821x_write_page(phydev, 0);\n\t} else {\n\t\tret = -EOPNOTSUPP;\n\t}\n\n\treturn ret;\n}\n\nstatic int rtl822x_read_mmd(struct phy_device *phydev, int devnum, u16 regnum)\n{\n\tint ret = rtlgen_read_mmd(phydev, devnum, regnum);\n\n\tif (ret != -EOPNOTSUPP)\n\t\treturn ret;\n\n\tif (devnum == MDIO_MMD_PCS && regnum == MDIO_PCS_EEE_ABLE2) {\n\t\trtl821x_write_page(phydev, 0xa6e);\n\t\tret = __phy_read(phydev, 0x16);\n\t\trtl821x_write_page(phydev, 0);\n\t} else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_ADV2) {\n\t\trtl821x_write_page(phydev, 0xa6d);\n\t\tret = __phy_read(phydev, 0x12);\n\t\trtl821x_write_page(phydev, 0);\n\t} else if (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_LPABLE2) {\n\t\trtl821x_write_page(phydev, 0xa6d);\n\t\tret = __phy_read(phydev, 0x10);\n\t\trtl821x_write_page(phydev, 0);\n\t}\n\n\treturn ret;\n}\n\nstatic int rtl822x_write_mmd(struct phy_device *phydev, int devnum, u16 regnum,\n\t\t\t     u16 val)\n{\n\tint ret = rtlgen_write_mmd(phydev, devnum, regnum, val);\n\n\tif (ret != -EOPNOTSUPP)\n\t\treturn ret;\n\n\tif (devnum == MDIO_MMD_AN && regnum == MDIO_AN_EEE_ADV2) {\n\t\trtl821x_write_page(phydev, 0xa6d);\n\t\tret = __phy_write(phydev, 0x12, val);\n\t\trtl821x_write_page(phydev, 0);\n\t}\n\n\treturn ret;\n}\n\nstatic int rtl822x_get_features(struct phy_device *phydev)\n{\n\tint val;\n\n\tval = phy_read_paged(phydev, 0xa61, 0x13);\n\tif (val < 0)\n\t\treturn val;\n\n\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,\n\t\t\t phydev->supported, val & RTL_SUPPORTS_2500FULL);\n\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT,\n\t\t\t phydev->supported, val & RTL_SUPPORTS_5000FULL);\n\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT,\n\t\t\t phydev->supported, val & RTL_SUPPORTS_10000FULL);\n\n\treturn genphy_read_abilities(phydev);\n}\n\nstatic int rtl822x_config_aneg(struct phy_device *phydev)\n{\n\tint ret = 0;\n\n\tif (phydev->autoneg == AUTONEG_ENABLE) {\n\t\tu16 adv2500 = 0;\n\n\t\tif (linkmode_test_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,\n\t\t\t\t      phydev->advertising))\n\t\t\tadv2500 = RTL_ADV_2500FULL;\n\n\t\tret = phy_modify_paged_changed(phydev, 0xa5d, 0x12,\n\t\t\t\t\t       RTL_ADV_2500FULL, adv2500);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn __genphy_config_aneg(phydev, ret);\n}\n\nstatic int rtl822x_read_status(struct phy_device *phydev)\n{\n\tint ret;\n\n\tif (phydev->autoneg == AUTONEG_ENABLE) {\n\t\tint lpadv = phy_read_paged(phydev, 0xa5d, 0x13);\n\n\t\tif (lpadv < 0)\n\t\t\treturn lpadv;\n\n\t\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT,\n\t\t\tphydev->lp_advertising, lpadv & RTL_LPADV_10000FULL);\n\t\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT,\n\t\t\tphydev->lp_advertising, lpadv & RTL_LPADV_5000FULL);\n\t\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,\n\t\t\tphydev->lp_advertising, lpadv & RTL_LPADV_2500FULL);\n\t}\n\n\tret = genphy_read_status(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn rtlgen_get_speed(phydev);\n}\n\nstatic bool rtlgen_supports_2_5gbps(struct phy_device *phydev)\n{\n\tint val;\n\n\tphy_write(phydev, RTL821x_PAGE_SELECT, 0xa61);\n\tval = phy_read(phydev, 0x13);\n\tphy_write(phydev, RTL821x_PAGE_SELECT, 0);\n\n\treturn val >= 0 && val & RTL_SUPPORTS_2500FULL;\n}\n\nstatic int rtlgen_match_phy_device(struct phy_device *phydev)\n{\n\treturn phydev->phy_id == RTL_GENERIC_PHYID &&\n\t       !rtlgen_supports_2_5gbps(phydev);\n}\n\nstatic int rtl8226_match_phy_device(struct phy_device *phydev)\n{\n\treturn phydev->phy_id == RTL_GENERIC_PHYID &&\n\t       rtlgen_supports_2_5gbps(phydev);\n}\n\nstatic int rtlgen_resume(struct phy_device *phydev)\n{\n\tint ret = genphy_resume(phydev);\n\n\t \n\tmsleep(20);\n\n\treturn ret;\n}\n\nstatic int rtl9000a_config_init(struct phy_device *phydev)\n{\n\tphydev->autoneg = AUTONEG_DISABLE;\n\tphydev->speed = SPEED_100;\n\tphydev->duplex = DUPLEX_FULL;\n\n\treturn 0;\n}\n\nstatic int rtl9000a_config_aneg(struct phy_device *phydev)\n{\n\tint ret;\n\tu16 ctl = 0;\n\n\tswitch (phydev->master_slave_set) {\n\tcase MASTER_SLAVE_CFG_MASTER_FORCE:\n\t\tctl |= CTL1000_AS_MASTER;\n\t\tbreak;\n\tcase MASTER_SLAVE_CFG_SLAVE_FORCE:\n\t\tbreak;\n\tcase MASTER_SLAVE_CFG_UNKNOWN:\n\tcase MASTER_SLAVE_CFG_UNSUPPORTED:\n\t\treturn 0;\n\tdefault:\n\t\tphydev_warn(phydev, \"Unsupported Master/Slave mode\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = phy_modify_changed(phydev, MII_CTRL1000, CTL1000_AS_MASTER, ctl);\n\tif (ret == 1)\n\t\tret = genphy_soft_reset(phydev);\n\n\treturn ret;\n}\n\nstatic int rtl9000a_read_status(struct phy_device *phydev)\n{\n\tint ret;\n\n\tphydev->master_slave_get = MASTER_SLAVE_CFG_UNKNOWN;\n\tphydev->master_slave_state = MASTER_SLAVE_STATE_UNKNOWN;\n\n\tret = genphy_update_link(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_read(phydev, MII_CTRL1000);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret & CTL1000_AS_MASTER)\n\t\tphydev->master_slave_get = MASTER_SLAVE_CFG_MASTER_FORCE;\n\telse\n\t\tphydev->master_slave_get = MASTER_SLAVE_CFG_SLAVE_FORCE;\n\n\tret = phy_read(phydev, MII_STAT1000);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret & LPA_1000MSRES)\n\t\tphydev->master_slave_state = MASTER_SLAVE_STATE_MASTER;\n\telse\n\t\tphydev->master_slave_state = MASTER_SLAVE_STATE_SLAVE;\n\n\treturn 0;\n}\n\nstatic int rtl9000a_ack_interrupt(struct phy_device *phydev)\n{\n\tint err;\n\n\terr = phy_read(phydev, RTL8211F_INSR);\n\n\treturn (err < 0) ? err : 0;\n}\n\nstatic int rtl9000a_config_intr(struct phy_device *phydev)\n{\n\tu16 val;\n\tint err;\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\terr = rtl9000a_ack_interrupt(phydev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tval = (u16)~RTL9000A_GINMR_LINK_STATUS;\n\t\terr = phy_write_paged(phydev, 0xa42, RTL9000A_GINMR, val);\n\t} else {\n\t\tval = ~0;\n\t\terr = phy_write_paged(phydev, 0xa42, RTL9000A_GINMR, val);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = rtl9000a_ack_interrupt(phydev);\n\t}\n\n\treturn phy_write_paged(phydev, 0xa42, RTL9000A_GINMR, val);\n}\n\nstatic irqreturn_t rtl9000a_handle_interrupt(struct phy_device *phydev)\n{\n\tint irq_status;\n\n\tirq_status = phy_read(phydev, RTL8211F_INSR);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (!(irq_status & RTL8211F_INER_LINK_STATUS))\n\t\treturn IRQ_NONE;\n\n\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct phy_driver realtek_drvs[] = {\n\t{\n\t\tPHY_ID_MATCH_EXACT(0x00008201),\n\t\t.name           = \"RTL8201CP Ethernet\",\n\t\t.read_page\t= rtl821x_read_page,\n\t\t.write_page\t= rtl821x_write_page,\n\t}, {\n\t\tPHY_ID_MATCH_EXACT(0x001cc816),\n\t\t.name\t\t= \"RTL8201F Fast Ethernet\",\n\t\t.config_intr\t= &rtl8201_config_intr,\n\t\t.handle_interrupt = rtl8201_handle_interrupt,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= genphy_resume,\n\t\t.read_page\t= rtl821x_read_page,\n\t\t.write_page\t= rtl821x_write_page,\n\t}, {\n\t\tPHY_ID_MATCH_MODEL(0x001cc880),\n\t\t.name\t\t= \"RTL8208 Fast Ethernet\",\n\t\t.read_mmd\t= genphy_read_mmd_unsupported,\n\t\t.write_mmd\t= genphy_write_mmd_unsupported,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= genphy_resume,\n\t\t.read_page\t= rtl821x_read_page,\n\t\t.write_page\t= rtl821x_write_page,\n\t}, {\n\t\tPHY_ID_MATCH_EXACT(0x001cc910),\n\t\t.name\t\t= \"RTL8211 Gigabit Ethernet\",\n\t\t.config_aneg\t= rtl8211_config_aneg,\n\t\t.read_mmd\t= &genphy_read_mmd_unsupported,\n\t\t.write_mmd\t= &genphy_write_mmd_unsupported,\n\t\t.read_page\t= rtl821x_read_page,\n\t\t.write_page\t= rtl821x_write_page,\n\t}, {\n\t\tPHY_ID_MATCH_EXACT(0x001cc912),\n\t\t.name\t\t= \"RTL8211B Gigabit Ethernet\",\n\t\t.config_intr\t= &rtl8211b_config_intr,\n\t\t.handle_interrupt = rtl821x_handle_interrupt,\n\t\t.read_mmd\t= &genphy_read_mmd_unsupported,\n\t\t.write_mmd\t= &genphy_write_mmd_unsupported,\n\t\t.suspend\t= rtl8211b_suspend,\n\t\t.resume\t\t= rtl8211b_resume,\n\t\t.read_page\t= rtl821x_read_page,\n\t\t.write_page\t= rtl821x_write_page,\n\t}, {\n\t\tPHY_ID_MATCH_EXACT(0x001cc913),\n\t\t.name\t\t= \"RTL8211C Gigabit Ethernet\",\n\t\t.config_init\t= rtl8211c_config_init,\n\t\t.read_mmd\t= &genphy_read_mmd_unsupported,\n\t\t.write_mmd\t= &genphy_write_mmd_unsupported,\n\t\t.read_page\t= rtl821x_read_page,\n\t\t.write_page\t= rtl821x_write_page,\n\t}, {\n\t\tPHY_ID_MATCH_EXACT(0x001cc914),\n\t\t.name\t\t= \"RTL8211DN Gigabit Ethernet\",\n\t\t.config_intr\t= rtl8211e_config_intr,\n\t\t.handle_interrupt = rtl821x_handle_interrupt,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= genphy_resume,\n\t\t.read_page\t= rtl821x_read_page,\n\t\t.write_page\t= rtl821x_write_page,\n\t}, {\n\t\tPHY_ID_MATCH_EXACT(0x001cc915),\n\t\t.name\t\t= \"RTL8211E Gigabit Ethernet\",\n\t\t.config_init\t= &rtl8211e_config_init,\n\t\t.config_intr\t= &rtl8211e_config_intr,\n\t\t.handle_interrupt = rtl821x_handle_interrupt,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= genphy_resume,\n\t\t.read_page\t= rtl821x_read_page,\n\t\t.write_page\t= rtl821x_write_page,\n\t}, {\n\t\tPHY_ID_MATCH_EXACT(0x001cc916),\n\t\t.name\t\t= \"RTL8211F Gigabit Ethernet\",\n\t\t.probe\t\t= rtl821x_probe,\n\t\t.config_init\t= &rtl8211f_config_init,\n\t\t.read_status\t= rtlgen_read_status,\n\t\t.config_intr\t= &rtl8211f_config_intr,\n\t\t.handle_interrupt = rtl8211f_handle_interrupt,\n\t\t.suspend\t= rtl821x_suspend,\n\t\t.resume\t\t= rtl821x_resume,\n\t\t.read_page\t= rtl821x_read_page,\n\t\t.write_page\t= rtl821x_write_page,\n\t\t.flags\t\t= PHY_ALWAYS_CALL_SUSPEND,\n\t}, {\n\t\tPHY_ID_MATCH_EXACT(RTL_8211FVD_PHYID),\n\t\t.name\t\t= \"RTL8211F-VD Gigabit Ethernet\",\n\t\t.probe\t\t= rtl821x_probe,\n\t\t.config_init\t= &rtl8211f_config_init,\n\t\t.read_status\t= rtlgen_read_status,\n\t\t.config_intr\t= &rtl8211f_config_intr,\n\t\t.handle_interrupt = rtl8211f_handle_interrupt,\n\t\t.suspend\t= rtl821x_suspend,\n\t\t.resume\t\t= rtl821x_resume,\n\t\t.read_page\t= rtl821x_read_page,\n\t\t.write_page\t= rtl821x_write_page,\n\t\t.flags\t\t= PHY_ALWAYS_CALL_SUSPEND,\n\t}, {\n\t\t.name\t\t= \"Generic FE-GE Realtek PHY\",\n\t\t.match_phy_device = rtlgen_match_phy_device,\n\t\t.read_status\t= rtlgen_read_status,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= rtlgen_resume,\n\t\t.read_page\t= rtl821x_read_page,\n\t\t.write_page\t= rtl821x_write_page,\n\t\t.read_mmd\t= rtlgen_read_mmd,\n\t\t.write_mmd\t= rtlgen_write_mmd,\n\t}, {\n\t\t.name\t\t= \"RTL8226 2.5Gbps PHY\",\n\t\t.match_phy_device = rtl8226_match_phy_device,\n\t\t.get_features\t= rtl822x_get_features,\n\t\t.config_aneg\t= rtl822x_config_aneg,\n\t\t.read_status\t= rtl822x_read_status,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= rtlgen_resume,\n\t\t.read_page\t= rtl821x_read_page,\n\t\t.write_page\t= rtl821x_write_page,\n\t\t.read_mmd\t= rtl822x_read_mmd,\n\t\t.write_mmd\t= rtl822x_write_mmd,\n\t}, {\n\t\tPHY_ID_MATCH_EXACT(0x001cc840),\n\t\t.name\t\t= \"RTL8226B_RTL8221B 2.5Gbps PHY\",\n\t\t.get_features\t= rtl822x_get_features,\n\t\t.config_aneg\t= rtl822x_config_aneg,\n\t\t.read_status\t= rtl822x_read_status,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= rtlgen_resume,\n\t\t.read_page\t= rtl821x_read_page,\n\t\t.write_page\t= rtl821x_write_page,\n\t\t.read_mmd\t= rtl822x_read_mmd,\n\t\t.write_mmd\t= rtl822x_write_mmd,\n\t}, {\n\t\tPHY_ID_MATCH_EXACT(0x001cc838),\n\t\t.name           = \"RTL8226-CG 2.5Gbps PHY\",\n\t\t.get_features   = rtl822x_get_features,\n\t\t.config_aneg    = rtl822x_config_aneg,\n\t\t.read_status    = rtl822x_read_status,\n\t\t.suspend        = genphy_suspend,\n\t\t.resume         = rtlgen_resume,\n\t\t.read_page      = rtl821x_read_page,\n\t\t.write_page     = rtl821x_write_page,\n\t}, {\n\t\tPHY_ID_MATCH_EXACT(0x001cc848),\n\t\t.name           = \"RTL8226B-CG_RTL8221B-CG 2.5Gbps PHY\",\n\t\t.get_features   = rtl822x_get_features,\n\t\t.config_aneg    = rtl822x_config_aneg,\n\t\t.read_status    = rtl822x_read_status,\n\t\t.suspend        = genphy_suspend,\n\t\t.resume         = rtlgen_resume,\n\t\t.read_page      = rtl821x_read_page,\n\t\t.write_page     = rtl821x_write_page,\n\t}, {\n\t\tPHY_ID_MATCH_EXACT(0x001cc849),\n\t\t.name           = \"RTL8221B-VB-CG 2.5Gbps PHY\",\n\t\t.get_features   = rtl822x_get_features,\n\t\t.config_aneg    = rtl822x_config_aneg,\n\t\t.read_status    = rtl822x_read_status,\n\t\t.suspend        = genphy_suspend,\n\t\t.resume         = rtlgen_resume,\n\t\t.read_page      = rtl821x_read_page,\n\t\t.write_page     = rtl821x_write_page,\n\t}, {\n\t\tPHY_ID_MATCH_EXACT(0x001cc84a),\n\t\t.name           = \"RTL8221B-VM-CG 2.5Gbps PHY\",\n\t\t.get_features   = rtl822x_get_features,\n\t\t.config_aneg    = rtl822x_config_aneg,\n\t\t.read_status    = rtl822x_read_status,\n\t\t.suspend        = genphy_suspend,\n\t\t.resume         = rtlgen_resume,\n\t\t.read_page      = rtl821x_read_page,\n\t\t.write_page     = rtl821x_write_page,\n\t}, {\n\t\tPHY_ID_MATCH_EXACT(0x001cc961),\n\t\t.name\t\t= \"RTL8366RB Gigabit Ethernet\",\n\t\t.config_init\t= &rtl8366rb_config_init,\n\t\t \n\t\t.config_intr\t= genphy_no_config_intr,\n\t\t.handle_interrupt = genphy_handle_interrupt_no_ack,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= genphy_resume,\n\t}, {\n\t\tPHY_ID_MATCH_EXACT(0x001ccb00),\n\t\t.name\t\t= \"RTL9000AA_RTL9000AN Ethernet\",\n\t\t.features       = PHY_BASIC_T1_FEATURES,\n\t\t.config_init\t= rtl9000a_config_init,\n\t\t.config_aneg\t= rtl9000a_config_aneg,\n\t\t.read_status\t= rtl9000a_read_status,\n\t\t.config_intr\t= rtl9000a_config_intr,\n\t\t.handle_interrupt = rtl9000a_handle_interrupt,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= genphy_resume,\n\t\t.read_page\t= rtl821x_read_page,\n\t\t.write_page\t= rtl821x_write_page,\n\t}, {\n\t\tPHY_ID_MATCH_EXACT(0x001cc942),\n\t\t.name\t\t= \"RTL8365MB-VC Gigabit Ethernet\",\n\t\t \n\t\t.config_intr\t= genphy_no_config_intr,\n\t\t.handle_interrupt = genphy_handle_interrupt_no_ack,\n\t\t.suspend\t= genphy_suspend,\n\t\t.resume\t\t= genphy_resume,\n\t},\n};\n\nmodule_phy_driver(realtek_drvs);\n\nstatic const struct mdio_device_id __maybe_unused realtek_tbl[] = {\n\t{ PHY_ID_MATCH_VENDOR(0x001cc800) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(mdio, realtek_tbl);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}