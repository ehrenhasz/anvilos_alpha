{
  "module_name": "nxp-c45-tja11xx.c",
  "hash_id": "4c05dc48d19e8a122c92ae6cbad2fc8556366aff16a12e31c2dd4b166035d407",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/nxp-c45-tja11xx.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/ethtool.h>\n#include <linux/ethtool_netlink.h>\n#include <linux/kernel.h>\n#include <linux/mii.h>\n#include <linux/module.h>\n#include <linux/phy.h>\n#include <linux/processor.h>\n#include <linux/property.h>\n#include <linux/ptp_classify.h>\n#include <linux/ptp_clock_kernel.h>\n#include <linux/net_tstamp.h>\n\n#define PHY_ID_TJA_1103\t\t\t0x001BB010\n#define PHY_ID_TJA_1120\t\t\t0x001BB031\n\n#define VEND1_DEVICE_CONTROL\t\t0x0040\n#define DEVICE_CONTROL_RESET\t\tBIT(15)\n#define DEVICE_CONTROL_CONFIG_GLOBAL_EN\tBIT(14)\n#define DEVICE_CONTROL_CONFIG_ALL_EN\tBIT(13)\n\n#define VEND1_DEVICE_CONFIG\t\t0x0048\n\n#define TJA1120_VEND1_EXT_TS_MODE\t0x1012\n\n#define TJA1120_GLOBAL_INFRA_IRQ_ACK\t0x2C08\n#define TJA1120_GLOBAL_INFRA_IRQ_EN\t0x2C0A\n#define TJA1120_GLOBAL_INFRA_IRQ_STATUS\t0x2C0C\n#define TJA1120_DEV_BOOT_DONE\t\tBIT(1)\n\n#define TJA1120_VEND1_PTP_TRIG_DATA_S\t0x1070\n\n#define TJA1120_EGRESS_TS_DATA_S\t0x9060\n#define TJA1120_EGRESS_TS_END\t\t0x9067\n#define TJA1120_TS_VALID\t\tBIT(0)\n#define TJA1120_MORE_TS\t\t\tBIT(15)\n\n#define VEND1_PHY_IRQ_ACK\t\t0x80A0\n#define VEND1_PHY_IRQ_EN\t\t0x80A1\n#define VEND1_PHY_IRQ_STATUS\t\t0x80A2\n#define PHY_IRQ_LINK_EVENT\t\tBIT(1)\n\n#define VEND1_ALWAYS_ACCESSIBLE\t\t0x801F\n#define FUSA_PASS\t\t\tBIT(4)\n\n#define VEND1_PHY_CONTROL\t\t0x8100\n#define PHY_CONFIG_EN\t\t\tBIT(14)\n#define PHY_START_OP\t\t\tBIT(0)\n\n#define VEND1_PHY_CONFIG\t\t0x8108\n#define PHY_CONFIG_AUTO\t\t\tBIT(0)\n\n#define TJA1120_EPHY_RESETS\t\t0x810A\n#define EPHY_PCS_RESET\t\t\tBIT(3)\n\n#define VEND1_SIGNAL_QUALITY\t\t0x8320\n#define SQI_VALID\t\t\tBIT(14)\n#define SQI_MASK\t\t\tGENMASK(2, 0)\n#define MAX_SQI\t\t\t\tSQI_MASK\n\n#define CABLE_TEST_ENABLE\t\tBIT(15)\n#define CABLE_TEST_START\t\tBIT(14)\n#define CABLE_TEST_OK\t\t\t0x00\n#define CABLE_TEST_SHORTED\t\t0x01\n#define CABLE_TEST_OPEN\t\t\t0x02\n#define CABLE_TEST_UNKNOWN\t\t0x07\n\n#define VEND1_PORT_CONTROL\t\t0x8040\n#define PORT_CONTROL_EN\t\t\tBIT(14)\n\n#define VEND1_PORT_ABILITIES\t\t0x8046\n#define PTP_ABILITY\t\t\tBIT(3)\n\n#define VEND1_PORT_FUNC_IRQ_EN\t\t0x807A\n#define PTP_IRQS\t\t\tBIT(3)\n\n#define VEND1_PTP_IRQ_ACK\t\t0x9008\n#define EGR_TS_IRQ\t\t\tBIT(1)\n\n#define VEND1_PORT_INFRA_CONTROL\t0xAC00\n#define PORT_INFRA_CONTROL_EN\t\tBIT(14)\n\n#define VEND1_RXID\t\t\t0xAFCC\n#define VEND1_TXID\t\t\t0xAFCD\n#define ID_ENABLE\t\t\tBIT(15)\n\n#define VEND1_ABILITIES\t\t\t0xAFC4\n#define RGMII_ID_ABILITY\t\tBIT(15)\n#define RGMII_ABILITY\t\t\tBIT(14)\n#define RMII_ABILITY\t\t\tBIT(10)\n#define REVMII_ABILITY\t\t\tBIT(9)\n#define MII_ABILITY\t\t\tBIT(8)\n#define SGMII_ABILITY\t\t\tBIT(0)\n\n#define VEND1_MII_BASIC_CONFIG\t\t0xAFC6\n#define MII_BASIC_CONFIG_REV\t\tBIT(4)\n#define MII_BASIC_CONFIG_SGMII\t\t0x9\n#define MII_BASIC_CONFIG_RGMII\t\t0x7\n#define MII_BASIC_CONFIG_RMII\t\t0x5\n#define MII_BASIC_CONFIG_MII\t\t0x4\n\n#define VEND1_SYMBOL_ERROR_CNT_XTD\t0x8351\n#define EXTENDED_CNT_EN\t\t\tBIT(15)\n#define VEND1_MONITOR_STATUS\t\t0xAC80\n#define MONITOR_RESET\t\t\tBIT(15)\n#define VEND1_MONITOR_CONFIG\t\t0xAC86\n#define LOST_FRAMES_CNT_EN\t\tBIT(9)\n#define ALL_FRAMES_CNT_EN\t\tBIT(8)\n\n#define VEND1_SYMBOL_ERROR_COUNTER\t0x8350\n#define VEND1_LINK_DROP_COUNTER\t\t0x8352\n#define VEND1_LINK_LOSSES_AND_FAILURES\t0x8353\n#define VEND1_RX_PREAMBLE_COUNT\t\t0xAFCE\n#define VEND1_TX_PREAMBLE_COUNT\t\t0xAFCF\n#define VEND1_RX_IPG_LENGTH\t\t0xAFD0\n#define VEND1_TX_IPG_LENGTH\t\t0xAFD1\n#define COUNTER_EN\t\t\tBIT(15)\n\n#define VEND1_PTP_CONFIG\t\t0x1102\n#define EXT_TRG_EDGE\t\t\tBIT(1)\n\n#define TJA1120_SYNC_TRIG_FILTER\t0x1010\n#define PTP_TRIG_RISE_TS\t\tBIT(3)\n#define PTP_TRIG_FALLING_TS\t\tBIT(2)\n\n#define CLK_RATE_ADJ_LD\t\t\tBIT(15)\n#define CLK_RATE_ADJ_DIR\t\tBIT(14)\n\n#define VEND1_RX_TS_INSRT_CTRL\t\t0x114D\n#define TJA1103_RX_TS_INSRT_MODE2\t0x02\n\n#define TJA1120_RX_TS_INSRT_CTRL\t0x9012\n#define TJA1120_RX_TS_INSRT_EN\t\tBIT(15)\n#define TJA1120_TS_INSRT_MODE\t\tBIT(4)\n\n#define VEND1_EGR_RING_DATA_0\t\t0x114E\n#define VEND1_EGR_RING_CTRL\t\t0x1154\n\n#define RING_DATA_0_TS_VALID\t\tBIT(15)\n\n#define RING_DONE\t\t\tBIT(0)\n\n#define TS_SEC_MASK\t\t\tGENMASK(1, 0)\n\n#define VEND1_PORT_FUNC_ENABLES\t\t0x8048\n#define PTP_ENABLE\t\t\tBIT(3)\n#define PHY_TEST_ENABLE\t\t\tBIT(0)\n\n#define VEND1_PORT_PTP_CONTROL\t\t0x9000\n#define PORT_PTP_CONTROL_BYPASS\t\tBIT(11)\n\n#define PTP_CLK_PERIOD_100BT1\t\t15ULL\n#define PTP_CLK_PERIOD_1000BT1\t\t8ULL\n\n#define EVENT_MSG_FILT_ALL\t\t0x0F\n#define EVENT_MSG_FILT_NONE\t\t0x00\n\n#define VEND1_GPIO_FUNC_CONFIG_BASE\t0x2C40\n#define GPIO_FUNC_EN\t\t\tBIT(15)\n#define GPIO_FUNC_PTP\t\t\tBIT(6)\n#define GPIO_SIGNAL_PTP_TRIGGER\t\t0x01\n#define GPIO_SIGNAL_PPS_OUT\t\t0x12\n#define GPIO_DISABLE\t\t\t0\n#define GPIO_PPS_OUT_CFG\t\t(GPIO_FUNC_EN | GPIO_FUNC_PTP | \\\n\tGPIO_SIGNAL_PPS_OUT)\n#define GPIO_EXTTS_OUT_CFG\t\t(GPIO_FUNC_EN | GPIO_FUNC_PTP | \\\n\tGPIO_SIGNAL_PTP_TRIGGER)\n\n#define RGMII_PERIOD_PS\t\t\t8000U\n#define PS_PER_DEGREE\t\t\tdiv_u64(RGMII_PERIOD_PS, 360)\n#define MIN_ID_PS\t\t\t1644U\n#define MAX_ID_PS\t\t\t2260U\n#define DEFAULT_ID_PS\t\t\t2000U\n\n#define PPM_TO_SUBNS_INC(ppb, ptp_clk_period) div_u64(GENMASK_ULL(31, 0) * \\\n\t(ppb) * (ptp_clk_period), NSEC_PER_SEC)\n\n#define NXP_C45_SKB_CB(skb)\t((struct nxp_c45_skb_cb *)(skb)->cb)\n\nstruct nxp_c45_phy;\n\nstruct nxp_c45_skb_cb {\n\tstruct ptp_header *header;\n\tunsigned int type;\n};\n\n#define NXP_C45_REG_FIELD(_reg, _devad, _offset, _size)\t\\\n\t((struct nxp_c45_reg_field) {\t\t\t\\\n\t\t.reg = _reg,\t\t\t\t\\\n\t\t.devad =  _devad,\t\t\t\\\n\t\t.offset = _offset,\t\t\t\\\n\t\t.size = _size,\t\t\t\t\\\n\t})\n\nstruct nxp_c45_reg_field {\n\tu16 reg;\n\tu8 devad;\n\tu8 offset;\n\tu8 size;\n};\n\nstruct nxp_c45_hwts {\n\tu32\tnsec;\n\tu32\tsec;\n\tu8\tdomain_number;\n\tu16\tsequence_id;\n\tu8\tmsg_type;\n};\n\nstruct nxp_c45_regmap {\n\t \n\tu16 vend1_ptp_clk_period;\n\tu16 vend1_event_msg_filt;\n\n\t \n\tstruct nxp_c45_reg_field ltc_read;\n\tstruct nxp_c45_reg_field ltc_write;\n\tstruct nxp_c45_reg_field ltc_lock_ctrl;\n\tu16 vend1_ltc_wr_nsec_0;\n\tu16 vend1_ltc_wr_nsec_1;\n\tu16 vend1_ltc_wr_sec_0;\n\tu16 vend1_ltc_wr_sec_1;\n\tu16 vend1_ltc_rd_nsec_0;\n\tu16 vend1_ltc_rd_nsec_1;\n\tu16 vend1_ltc_rd_sec_0;\n\tu16 vend1_ltc_rd_sec_1;\n\tu16 vend1_rate_adj_subns_0;\n\tu16 vend1_rate_adj_subns_1;\n\n\t \n\tstruct nxp_c45_reg_field irq_egr_ts_en;\n\tstruct nxp_c45_reg_field irq_egr_ts_status;\n\tstruct nxp_c45_reg_field domain_number;\n\tstruct nxp_c45_reg_field msg_type;\n\tstruct nxp_c45_reg_field sequence_id;\n\tstruct nxp_c45_reg_field sec_1_0;\n\tstruct nxp_c45_reg_field sec_4_2;\n\tstruct nxp_c45_reg_field nsec_15_0;\n\tstruct nxp_c45_reg_field nsec_29_16;\n\n\t \n\tstruct nxp_c45_reg_field pps_enable;\n\tstruct nxp_c45_reg_field pps_polarity;\n\tu16 vend1_ext_trg_data_0;\n\tu16 vend1_ext_trg_data_1;\n\tu16 vend1_ext_trg_data_2;\n\tu16 vend1_ext_trg_data_3;\n\tu16 vend1_ext_trg_ctrl;\n\n\t \n\tu16 cable_test;\n\tstruct nxp_c45_reg_field cable_test_valid;\n\tstruct nxp_c45_reg_field cable_test_result;\n};\n\nstruct nxp_c45_phy_stats {\n\tconst char\t*name;\n\tconst struct nxp_c45_reg_field counter;\n};\n\nstruct nxp_c45_phy_data {\n\tconst struct nxp_c45_regmap *regmap;\n\tconst struct nxp_c45_phy_stats *stats;\n\tint n_stats;\n\tu8 ptp_clk_period;\n\tbool ext_ts_both_edges;\n\tbool ack_ptp_irq;\n\tvoid (*counters_enable)(struct phy_device *phydev);\n\tbool (*get_egressts)(struct nxp_c45_phy *priv,\n\t\t\t     struct nxp_c45_hwts *hwts);\n\tbool (*get_extts)(struct nxp_c45_phy *priv, struct timespec64 *extts);\n\tvoid (*ptp_init)(struct phy_device *phydev);\n\tvoid (*ptp_enable)(struct phy_device *phydev, bool enable);\n\tvoid (*nmi_handler)(struct phy_device *phydev,\n\t\t\t    irqreturn_t *irq_status);\n};\n\nstruct nxp_c45_phy {\n\tconst struct nxp_c45_phy_data *phy_data;\n\tstruct phy_device *phydev;\n\tstruct mii_timestamper mii_ts;\n\tstruct ptp_clock *ptp_clock;\n\tstruct ptp_clock_info caps;\n\tstruct sk_buff_head tx_queue;\n\tstruct sk_buff_head rx_queue;\n\t \n\tstruct mutex ptp_lock;\n\tint hwts_tx;\n\tint hwts_rx;\n\tu32 tx_delay;\n\tu32 rx_delay;\n\tstruct timespec64 extts_ts;\n\tint extts_index;\n\tbool extts;\n};\n\nstatic const\nstruct nxp_c45_phy_data *nxp_c45_get_data(struct phy_device *phydev)\n{\n\treturn phydev->drv->driver_data;\n}\n\nstatic const\nstruct nxp_c45_regmap *nxp_c45_get_regmap(struct phy_device *phydev)\n{\n\tconst struct nxp_c45_phy_data *phy_data = nxp_c45_get_data(phydev);\n\n\treturn phy_data->regmap;\n}\n\nstatic int nxp_c45_read_reg_field(struct phy_device *phydev,\n\t\t\t\t  const struct nxp_c45_reg_field *reg_field)\n{\n\tu16 mask;\n\tint ret;\n\n\tif (reg_field->size == 0) {\n\t\tphydev_err(phydev, \"Trying to read a reg field of size 0.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = phy_read_mmd(phydev, reg_field->devad, reg_field->reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmask = reg_field->size == 1 ? BIT(reg_field->offset) :\n\t\tGENMASK(reg_field->offset + reg_field->size - 1,\n\t\t\treg_field->offset);\n\tret &= mask;\n\tret >>= reg_field->offset;\n\n\treturn ret;\n}\n\nstatic int nxp_c45_write_reg_field(struct phy_device *phydev,\n\t\t\t\t   const struct nxp_c45_reg_field *reg_field,\n\t\t\t\t   u16 val)\n{\n\tu16 mask;\n\tu16 set;\n\n\tif (reg_field->size == 0) {\n\t\tphydev_err(phydev, \"Trying to write a reg field of size 0.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmask = reg_field->size == 1 ? BIT(reg_field->offset) :\n\t\tGENMASK(reg_field->offset + reg_field->size - 1,\n\t\t\treg_field->offset);\n\tset = val << reg_field->offset;\n\n\treturn phy_modify_mmd_changed(phydev, reg_field->devad,\n\t\t\t\t      reg_field->reg, mask, set);\n}\n\nstatic int nxp_c45_set_reg_field(struct phy_device *phydev,\n\t\t\t\t const struct nxp_c45_reg_field *reg_field)\n{\n\tif (reg_field->size != 1) {\n\t\tphydev_err(phydev, \"Trying to set a reg field of size different than 1.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn nxp_c45_write_reg_field(phydev, reg_field, 1);\n}\n\nstatic int nxp_c45_clear_reg_field(struct phy_device *phydev,\n\t\t\t\t   const struct nxp_c45_reg_field *reg_field)\n{\n\tif (reg_field->size != 1) {\n\t\tphydev_err(phydev, \"Trying to set a reg field of size different than 1.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn nxp_c45_write_reg_field(phydev, reg_field, 0);\n}\n\nstatic bool nxp_c45_poll_txts(struct phy_device *phydev)\n{\n\treturn phydev->irq <= 0;\n}\n\nstatic int _nxp_c45_ptp_gettimex64(struct ptp_clock_info *ptp,\n\t\t\t\t   struct timespec64 *ts,\n\t\t\t\t   struct ptp_system_timestamp *sts)\n{\n\tstruct nxp_c45_phy *priv = container_of(ptp, struct nxp_c45_phy, caps);\n\tconst struct nxp_c45_regmap *regmap = nxp_c45_get_regmap(priv->phydev);\n\n\tnxp_c45_set_reg_field(priv->phydev, &regmap->ltc_read);\n\tts->tv_nsec = phy_read_mmd(priv->phydev, MDIO_MMD_VEND1,\n\t\t\t\t   regmap->vend1_ltc_rd_nsec_0);\n\tts->tv_nsec |= phy_read_mmd(priv->phydev, MDIO_MMD_VEND1,\n\t\t\t\t    regmap->vend1_ltc_rd_nsec_1) << 16;\n\tts->tv_sec = phy_read_mmd(priv->phydev, MDIO_MMD_VEND1,\n\t\t\t\t  regmap->vend1_ltc_rd_sec_0);\n\tts->tv_sec |= phy_read_mmd(priv->phydev, MDIO_MMD_VEND1,\n\t\t\t\t   regmap->vend1_ltc_rd_sec_1) << 16;\n\n\treturn 0;\n}\n\nstatic int nxp_c45_ptp_gettimex64(struct ptp_clock_info *ptp,\n\t\t\t\t  struct timespec64 *ts,\n\t\t\t\t  struct ptp_system_timestamp *sts)\n{\n\tstruct nxp_c45_phy *priv = container_of(ptp, struct nxp_c45_phy, caps);\n\n\tmutex_lock(&priv->ptp_lock);\n\t_nxp_c45_ptp_gettimex64(ptp, ts, sts);\n\tmutex_unlock(&priv->ptp_lock);\n\n\treturn 0;\n}\n\nstatic int _nxp_c45_ptp_settime64(struct ptp_clock_info *ptp,\n\t\t\t\t  const struct timespec64 *ts)\n{\n\tstruct nxp_c45_phy *priv = container_of(ptp, struct nxp_c45_phy, caps);\n\tconst struct nxp_c45_regmap *regmap = nxp_c45_get_regmap(priv->phydev);\n\n\tphy_write_mmd(priv->phydev, MDIO_MMD_VEND1, regmap->vend1_ltc_wr_nsec_0,\n\t\t      ts->tv_nsec);\n\tphy_write_mmd(priv->phydev, MDIO_MMD_VEND1, regmap->vend1_ltc_wr_nsec_1,\n\t\t      ts->tv_nsec >> 16);\n\tphy_write_mmd(priv->phydev, MDIO_MMD_VEND1, regmap->vend1_ltc_wr_sec_0,\n\t\t      ts->tv_sec);\n\tphy_write_mmd(priv->phydev, MDIO_MMD_VEND1, regmap->vend1_ltc_wr_sec_1,\n\t\t      ts->tv_sec >> 16);\n\tnxp_c45_set_reg_field(priv->phydev, &regmap->ltc_write);\n\n\treturn 0;\n}\n\nstatic int nxp_c45_ptp_settime64(struct ptp_clock_info *ptp,\n\t\t\t\t const struct timespec64 *ts)\n{\n\tstruct nxp_c45_phy *priv = container_of(ptp, struct nxp_c45_phy, caps);\n\n\tmutex_lock(&priv->ptp_lock);\n\t_nxp_c45_ptp_settime64(ptp, ts);\n\tmutex_unlock(&priv->ptp_lock);\n\n\treturn 0;\n}\n\nstatic int nxp_c45_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct nxp_c45_phy *priv = container_of(ptp, struct nxp_c45_phy, caps);\n\tconst struct nxp_c45_phy_data *data = nxp_c45_get_data(priv->phydev);\n\tconst struct nxp_c45_regmap *regmap = data->regmap;\n\ts32 ppb = scaled_ppm_to_ppb(scaled_ppm);\n\tu64 subns_inc_val;\n\tbool inc;\n\n\tmutex_lock(&priv->ptp_lock);\n\tinc = ppb >= 0;\n\tppb = abs(ppb);\n\n\tsubns_inc_val = PPM_TO_SUBNS_INC(ppb, data->ptp_clk_period);\n\n\tphy_write_mmd(priv->phydev, MDIO_MMD_VEND1,\n\t\t      regmap->vend1_rate_adj_subns_0,\n\t\t      subns_inc_val);\n\tsubns_inc_val >>= 16;\n\tsubns_inc_val |= CLK_RATE_ADJ_LD;\n\tif (inc)\n\t\tsubns_inc_val |= CLK_RATE_ADJ_DIR;\n\n\tphy_write_mmd(priv->phydev, MDIO_MMD_VEND1,\n\t\t      regmap->vend1_rate_adj_subns_1,\n\t\t      subns_inc_val);\n\tmutex_unlock(&priv->ptp_lock);\n\n\treturn 0;\n}\n\nstatic int nxp_c45_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct nxp_c45_phy *priv = container_of(ptp, struct nxp_c45_phy, caps);\n\tstruct timespec64 now, then;\n\n\tmutex_lock(&priv->ptp_lock);\n\tthen = ns_to_timespec64(delta);\n\t_nxp_c45_ptp_gettimex64(ptp, &now, NULL);\n\tnow = timespec64_add(now, then);\n\t_nxp_c45_ptp_settime64(ptp, &now);\n\tmutex_unlock(&priv->ptp_lock);\n\n\treturn 0;\n}\n\nstatic void nxp_c45_reconstruct_ts(struct timespec64 *ts,\n\t\t\t\t   struct nxp_c45_hwts *hwts)\n{\n\tts->tv_nsec = hwts->nsec;\n\tif ((ts->tv_sec & TS_SEC_MASK) < (hwts->sec & TS_SEC_MASK))\n\t\tts->tv_sec -= TS_SEC_MASK + 1;\n\tts->tv_sec &= ~TS_SEC_MASK;\n\tts->tv_sec |= hwts->sec & TS_SEC_MASK;\n}\n\nstatic bool nxp_c45_match_ts(struct ptp_header *header,\n\t\t\t     struct nxp_c45_hwts *hwts,\n\t\t\t     unsigned int type)\n{\n\treturn ntohs(header->sequence_id) == hwts->sequence_id &&\n\t       ptp_get_msgtype(header, type) == hwts->msg_type &&\n\t       header->domain_number  == hwts->domain_number;\n}\n\nstatic bool nxp_c45_get_extts(struct nxp_c45_phy *priv,\n\t\t\t      struct timespec64 *extts)\n{\n\tconst struct nxp_c45_regmap *regmap = nxp_c45_get_regmap(priv->phydev);\n\n\textts->tv_nsec = phy_read_mmd(priv->phydev, MDIO_MMD_VEND1,\n\t\t\t\t      regmap->vend1_ext_trg_data_0);\n\textts->tv_nsec |= phy_read_mmd(priv->phydev, MDIO_MMD_VEND1,\n\t\t\t\t       regmap->vend1_ext_trg_data_1) << 16;\n\textts->tv_sec = phy_read_mmd(priv->phydev, MDIO_MMD_VEND1,\n\t\t\t\t     regmap->vend1_ext_trg_data_2);\n\textts->tv_sec |= phy_read_mmd(priv->phydev, MDIO_MMD_VEND1,\n\t\t\t\t      regmap->vend1_ext_trg_data_3) << 16;\n\tphy_write_mmd(priv->phydev, MDIO_MMD_VEND1,\n\t\t      regmap->vend1_ext_trg_ctrl, RING_DONE);\n\n\treturn true;\n}\n\nstatic bool tja1120_extts_is_valid(struct phy_device *phydev)\n{\n\tbool valid;\n\tint reg;\n\n\treg = phy_read_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t   TJA1120_VEND1_PTP_TRIG_DATA_S);\n\tvalid = !!(reg & TJA1120_TS_VALID);\n\n\treturn valid;\n}\n\nstatic bool tja1120_get_extts(struct nxp_c45_phy *priv,\n\t\t\t      struct timespec64 *extts)\n{\n\tconst struct nxp_c45_regmap *regmap = nxp_c45_get_regmap(priv->phydev);\n\tstruct phy_device *phydev = priv->phydev;\n\tbool more_ts;\n\tbool valid;\n\tu16 reg;\n\n\treg = phy_read_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t   regmap->vend1_ext_trg_ctrl);\n\tmore_ts = !!(reg & TJA1120_MORE_TS);\n\n\tvalid = tja1120_extts_is_valid(phydev);\n\tif (!valid) {\n\t\tif (!more_ts)\n\t\t\tgoto tja1120_get_extts_out;\n\n\t\t \n\t\tphy_write_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t      regmap->vend1_ext_trg_ctrl, RING_DONE);\n\t\tvalid = tja1120_extts_is_valid(phydev);\n\t\tif (!valid)\n\t\t\tgoto tja1120_get_extts_out;\n\t}\n\n\tnxp_c45_get_extts(priv, extts);\ntja1120_get_extts_out:\n\treturn valid;\n}\n\nstatic void nxp_c45_read_egress_ts(struct nxp_c45_phy *priv,\n\t\t\t\t   struct nxp_c45_hwts *hwts)\n{\n\tconst struct nxp_c45_regmap *regmap = nxp_c45_get_regmap(priv->phydev);\n\tstruct phy_device *phydev = priv->phydev;\n\n\thwts->domain_number =\n\t\tnxp_c45_read_reg_field(phydev, &regmap->domain_number);\n\thwts->msg_type =\n\t\tnxp_c45_read_reg_field(phydev, &regmap->msg_type);\n\thwts->sequence_id =\n\t\tnxp_c45_read_reg_field(phydev, &regmap->sequence_id);\n\thwts->nsec =\n\t\tnxp_c45_read_reg_field(phydev, &regmap->nsec_15_0);\n\thwts->nsec |=\n\t\tnxp_c45_read_reg_field(phydev, &regmap->nsec_29_16) << 16;\n\thwts->sec = nxp_c45_read_reg_field(phydev, &regmap->sec_1_0);\n\thwts->sec |= nxp_c45_read_reg_field(phydev, &regmap->sec_4_2) << 2;\n}\n\nstatic bool nxp_c45_get_hwtxts(struct nxp_c45_phy *priv,\n\t\t\t       struct nxp_c45_hwts *hwts)\n{\n\tbool valid;\n\tu16 reg;\n\n\tmutex_lock(&priv->ptp_lock);\n\tphy_write_mmd(priv->phydev, MDIO_MMD_VEND1, VEND1_EGR_RING_CTRL,\n\t\t      RING_DONE);\n\treg = phy_read_mmd(priv->phydev, MDIO_MMD_VEND1, VEND1_EGR_RING_DATA_0);\n\tvalid = !!(reg & RING_DATA_0_TS_VALID);\n\tif (!valid)\n\t\tgoto nxp_c45_get_hwtxts_out;\n\n\tnxp_c45_read_egress_ts(priv, hwts);\nnxp_c45_get_hwtxts_out:\n\tmutex_unlock(&priv->ptp_lock);\n\treturn valid;\n}\n\nstatic bool tja1120_egress_ts_is_valid(struct phy_device *phydev)\n{\n\tbool valid;\n\tu16 reg;\n\n\treg = phy_read_mmd(phydev, MDIO_MMD_VEND1, TJA1120_EGRESS_TS_DATA_S);\n\tvalid = !!(reg & TJA1120_TS_VALID);\n\n\treturn valid;\n}\n\nstatic bool tja1120_get_hwtxts(struct nxp_c45_phy *priv,\n\t\t\t       struct nxp_c45_hwts *hwts)\n{\n\tstruct phy_device *phydev = priv->phydev;\n\tbool more_ts;\n\tbool valid;\n\tu16 reg;\n\n\tmutex_lock(&priv->ptp_lock);\n\treg = phy_read_mmd(phydev, MDIO_MMD_VEND1, TJA1120_EGRESS_TS_END);\n\tmore_ts = !!(reg & TJA1120_MORE_TS);\n\tvalid = tja1120_egress_ts_is_valid(phydev);\n\tif (!valid) {\n\t\tif (!more_ts)\n\t\t\tgoto tja1120_get_hwtxts_out;\n\n\t\t \n\t\tphy_write_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t      TJA1120_EGRESS_TS_END, TJA1120_TS_VALID);\n\t\tvalid = tja1120_egress_ts_is_valid(phydev);\n\t\tif (!valid)\n\t\t\tgoto tja1120_get_hwtxts_out;\n\t}\n\tnxp_c45_read_egress_ts(priv, hwts);\n\tphy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, TJA1120_EGRESS_TS_DATA_S,\n\t\t\t   TJA1120_TS_VALID);\ntja1120_get_hwtxts_out:\n\tmutex_unlock(&priv->ptp_lock);\n\treturn valid;\n}\n\nstatic void nxp_c45_process_txts(struct nxp_c45_phy *priv,\n\t\t\t\t struct nxp_c45_hwts *txts)\n{\n\tstruct sk_buff *skb, *tmp, *skb_match = NULL;\n\tstruct skb_shared_hwtstamps shhwtstamps;\n\tstruct timespec64 ts;\n\tunsigned long flags;\n\tbool ts_match;\n\ts64 ts_ns;\n\n\tspin_lock_irqsave(&priv->tx_queue.lock, flags);\n\tskb_queue_walk_safe(&priv->tx_queue, skb, tmp) {\n\t\tts_match = nxp_c45_match_ts(NXP_C45_SKB_CB(skb)->header, txts,\n\t\t\t\t\t    NXP_C45_SKB_CB(skb)->type);\n\t\tif (!ts_match)\n\t\t\tcontinue;\n\t\tskb_match = skb;\n\t\t__skb_unlink(skb, &priv->tx_queue);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&priv->tx_queue.lock, flags);\n\n\tif (skb_match) {\n\t\tnxp_c45_ptp_gettimex64(&priv->caps, &ts, NULL);\n\t\tnxp_c45_reconstruct_ts(&ts, txts);\n\t\tmemset(&shhwtstamps, 0, sizeof(shhwtstamps));\n\t\tts_ns = timespec64_to_ns(&ts);\n\t\tshhwtstamps.hwtstamp = ns_to_ktime(ts_ns);\n\t\tskb_complete_tx_timestamp(skb_match, &shhwtstamps);\n\t} else {\n\t\tphydev_warn(priv->phydev,\n\t\t\t    \"the tx timestamp doesn't match with any skb\\n\");\n\t}\n}\n\nstatic long nxp_c45_do_aux_work(struct ptp_clock_info *ptp)\n{\n\tstruct nxp_c45_phy *priv = container_of(ptp, struct nxp_c45_phy, caps);\n\tconst struct nxp_c45_phy_data *data = nxp_c45_get_data(priv->phydev);\n\tbool poll_txts = nxp_c45_poll_txts(priv->phydev);\n\tstruct skb_shared_hwtstamps *shhwtstamps_rx;\n\tstruct ptp_clock_event event;\n\tstruct nxp_c45_hwts hwts;\n\tbool reschedule = false;\n\tstruct timespec64 ts;\n\tstruct sk_buff *skb;\n\tbool ts_valid;\n\tu32 ts_raw;\n\n\twhile (!skb_queue_empty_lockless(&priv->tx_queue) && poll_txts) {\n\t\tts_valid = data->get_egressts(priv, &hwts);\n\t\tif (unlikely(!ts_valid)) {\n\t\t\t \n\t\t\treschedule = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tnxp_c45_process_txts(priv, &hwts);\n\t}\n\n\twhile ((skb = skb_dequeue(&priv->rx_queue)) != NULL) {\n\t\tnxp_c45_ptp_gettimex64(&priv->caps, &ts, NULL);\n\t\tts_raw = __be32_to_cpu(NXP_C45_SKB_CB(skb)->header->reserved2);\n\t\thwts.sec = ts_raw >> 30;\n\t\thwts.nsec = ts_raw & GENMASK(29, 0);\n\t\tnxp_c45_reconstruct_ts(&ts, &hwts);\n\t\tshhwtstamps_rx = skb_hwtstamps(skb);\n\t\tshhwtstamps_rx->hwtstamp = ns_to_ktime(timespec64_to_ns(&ts));\n\t\tNXP_C45_SKB_CB(skb)->header->reserved2 = 0;\n\t\tnetif_rx(skb);\n\t}\n\n\tif (priv->extts) {\n\t\tts_valid = data->get_extts(priv, &ts);\n\t\tif (ts_valid && timespec64_compare(&ts, &priv->extts_ts) != 0) {\n\t\t\tpriv->extts_ts = ts;\n\t\t\tevent.index = priv->extts_index;\n\t\t\tevent.type = PTP_CLOCK_EXTTS;\n\t\t\tevent.timestamp = ns_to_ktime(timespec64_to_ns(&ts));\n\t\t\tptp_clock_event(priv->ptp_clock, &event);\n\t\t}\n\t\treschedule = true;\n\t}\n\n\treturn reschedule ? 1 : -1;\n}\n\nstatic void nxp_c45_gpio_config(struct nxp_c45_phy *priv,\n\t\t\t\tint pin, u16 pin_cfg)\n{\n\tstruct phy_device *phydev = priv->phydev;\n\n\tphy_write_mmd(phydev, MDIO_MMD_VEND1,\n\t\t      VEND1_GPIO_FUNC_CONFIG_BASE + pin, pin_cfg);\n}\n\nstatic int nxp_c45_perout_enable(struct nxp_c45_phy *priv,\n\t\t\t\t struct ptp_perout_request *perout, int on)\n{\n\tconst struct nxp_c45_regmap *regmap = nxp_c45_get_regmap(priv->phydev);\n\tstruct phy_device *phydev = priv->phydev;\n\tint pin;\n\n\tif (perout->flags & ~PTP_PEROUT_PHASE)\n\t\treturn -EOPNOTSUPP;\n\n\tpin = ptp_find_pin(priv->ptp_clock, PTP_PF_PEROUT, perout->index);\n\tif (pin < 0)\n\t\treturn pin;\n\n\tif (!on) {\n\t\tnxp_c45_clear_reg_field(priv->phydev,\n\t\t\t\t\t&regmap->pps_enable);\n\t\tnxp_c45_clear_reg_field(priv->phydev,\n\t\t\t\t\t&regmap->pps_polarity);\n\n\t\tnxp_c45_gpio_config(priv, pin, GPIO_DISABLE);\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (perout->period.sec != 1 || perout->period.nsec != 0) {\n\t\tphydev_warn(phydev, \"The period can be set only to 1 second.\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(perout->flags & PTP_PEROUT_PHASE)) {\n\t\tif (perout->start.sec != 0 || perout->start.nsec != 0) {\n\t\t\tphydev_warn(phydev, \"The start time is not configurable. Should be set to 0 seconds and 0 nanoseconds.\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (perout->phase.nsec != 0 &&\n\t\t    perout->phase.nsec != (NSEC_PER_SEC >> 1)) {\n\t\t\tphydev_warn(phydev, \"The phase can be set only to 0 or 500000000 nanoseconds.\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (perout->phase.nsec == 0)\n\t\t\tnxp_c45_clear_reg_field(priv->phydev,\n\t\t\t\t\t\t&regmap->pps_polarity);\n\t\telse\n\t\t\tnxp_c45_set_reg_field(priv->phydev,\n\t\t\t\t\t      &regmap->pps_polarity);\n\t}\n\n\tnxp_c45_gpio_config(priv, pin, GPIO_PPS_OUT_CFG);\n\n\tnxp_c45_set_reg_field(priv->phydev, &regmap->pps_enable);\n\n\treturn 0;\n}\n\nstatic void nxp_c45_set_rising_or_falling(struct phy_device *phydev,\n\t\t\t\t\t  struct ptp_extts_request *extts)\n{\n\tif (extts->flags & PTP_RISING_EDGE)\n\t\tphy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t\t   VEND1_PTP_CONFIG, EXT_TRG_EDGE);\n\n\tif (extts->flags & PTP_FALLING_EDGE)\n\t\tphy_set_bits_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t\t VEND1_PTP_CONFIG, EXT_TRG_EDGE);\n}\n\nstatic void nxp_c45_set_rising_and_falling(struct phy_device *phydev,\n\t\t\t\t\t   struct ptp_extts_request *extts)\n{\n\t \n\tif (extts->flags & PTP_RISING_EDGE ||\n\t    extts->flags == PTP_ENABLE_FEATURE)\n\t\tphy_set_bits_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t\t TJA1120_SYNC_TRIG_FILTER,\n\t\t\t\t PTP_TRIG_RISE_TS);\n\telse\n\t\tphy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t\t   TJA1120_SYNC_TRIG_FILTER,\n\t\t\t\t   PTP_TRIG_RISE_TS);\n\n\tif (extts->flags & PTP_FALLING_EDGE)\n\t\tphy_set_bits_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t\t TJA1120_SYNC_TRIG_FILTER,\n\t\t\t\t PTP_TRIG_FALLING_TS);\n\telse\n\t\tphy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t\t   TJA1120_SYNC_TRIG_FILTER,\n\t\t\t\t   PTP_TRIG_FALLING_TS);\n}\n\nstatic int nxp_c45_extts_enable(struct nxp_c45_phy *priv,\n\t\t\t\tstruct ptp_extts_request *extts, int on)\n{\n\tconst struct nxp_c45_phy_data *data = nxp_c45_get_data(priv->phydev);\n\tint pin;\n\n\tif (extts->flags & ~(PTP_ENABLE_FEATURE |\n\t\t\t      PTP_RISING_EDGE |\n\t\t\t      PTP_FALLING_EDGE |\n\t\t\t      PTP_STRICT_FLAGS))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif ((extts->flags & PTP_RISING_EDGE) &&\n\t    (extts->flags & PTP_FALLING_EDGE) &&\n\t    !data->ext_ts_both_edges)\n\t\treturn -EOPNOTSUPP;\n\n\tpin = ptp_find_pin(priv->ptp_clock, PTP_PF_EXTTS, extts->index);\n\tif (pin < 0)\n\t\treturn pin;\n\n\tif (!on) {\n\t\tnxp_c45_gpio_config(priv, pin, GPIO_DISABLE);\n\t\tpriv->extts = false;\n\n\t\treturn 0;\n\t}\n\n\tif (data->ext_ts_both_edges)\n\t\tnxp_c45_set_rising_and_falling(priv->phydev, extts);\n\telse\n\t\tnxp_c45_set_rising_or_falling(priv->phydev, extts);\n\n\tnxp_c45_gpio_config(priv, pin, GPIO_EXTTS_OUT_CFG);\n\tpriv->extts = true;\n\tpriv->extts_index = extts->index;\n\tptp_schedule_worker(priv->ptp_clock, 0);\n\n\treturn 0;\n}\n\nstatic int nxp_c45_ptp_enable(struct ptp_clock_info *ptp,\n\t\t\t      struct ptp_clock_request *req, int on)\n{\n\tstruct nxp_c45_phy *priv = container_of(ptp, struct nxp_c45_phy, caps);\n\n\tswitch (req->type) {\n\tcase PTP_CLK_REQ_EXTTS:\n\t\treturn nxp_c45_extts_enable(priv, &req->extts, on);\n\tcase PTP_CLK_REQ_PEROUT:\n\t\treturn nxp_c45_perout_enable(priv, &req->perout, on);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic struct ptp_pin_desc nxp_c45_ptp_pins[] = {\n\t{ \"nxp_c45_gpio0\", 0, PTP_PF_NONE},\n\t{ \"nxp_c45_gpio1\", 1, PTP_PF_NONE},\n\t{ \"nxp_c45_gpio2\", 2, PTP_PF_NONE},\n\t{ \"nxp_c45_gpio3\", 3, PTP_PF_NONE},\n\t{ \"nxp_c45_gpio4\", 4, PTP_PF_NONE},\n\t{ \"nxp_c45_gpio5\", 5, PTP_PF_NONE},\n\t{ \"nxp_c45_gpio6\", 6, PTP_PF_NONE},\n\t{ \"nxp_c45_gpio7\", 7, PTP_PF_NONE},\n\t{ \"nxp_c45_gpio8\", 8, PTP_PF_NONE},\n\t{ \"nxp_c45_gpio9\", 9, PTP_PF_NONE},\n\t{ \"nxp_c45_gpio10\", 10, PTP_PF_NONE},\n\t{ \"nxp_c45_gpio11\", 11, PTP_PF_NONE},\n};\n\nstatic int nxp_c45_ptp_verify_pin(struct ptp_clock_info *ptp, unsigned int pin,\n\t\t\t\t  enum ptp_pin_function func, unsigned int chan)\n{\n\tif (pin >= ARRAY_SIZE(nxp_c45_ptp_pins))\n\t\treturn -EINVAL;\n\n\tswitch (func) {\n\tcase PTP_PF_NONE:\n\tcase PTP_PF_PEROUT:\n\tcase PTP_PF_EXTTS:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int nxp_c45_init_ptp_clock(struct nxp_c45_phy *priv)\n{\n\tpriv->caps = (struct ptp_clock_info) {\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.name\t\t= \"NXP C45 PHC\",\n\t\t.max_adj\t= 16666666,\n\t\t.adjfine\t= nxp_c45_ptp_adjfine,\n\t\t.adjtime\t= nxp_c45_ptp_adjtime,\n\t\t.gettimex64\t= nxp_c45_ptp_gettimex64,\n\t\t.settime64\t= nxp_c45_ptp_settime64,\n\t\t.enable\t\t= nxp_c45_ptp_enable,\n\t\t.verify\t\t= nxp_c45_ptp_verify_pin,\n\t\t.do_aux_work\t= nxp_c45_do_aux_work,\n\t\t.pin_config\t= nxp_c45_ptp_pins,\n\t\t.n_pins\t\t= ARRAY_SIZE(nxp_c45_ptp_pins),\n\t\t.n_ext_ts\t= 1,\n\t\t.n_per_out\t= 1,\n\t};\n\n\tpriv->ptp_clock = ptp_clock_register(&priv->caps,\n\t\t\t\t\t     &priv->phydev->mdio.dev);\n\n\tif (IS_ERR(priv->ptp_clock))\n\t\treturn PTR_ERR(priv->ptp_clock);\n\n\tif (!priv->ptp_clock)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void nxp_c45_txtstamp(struct mii_timestamper *mii_ts,\n\t\t\t     struct sk_buff *skb, int type)\n{\n\tstruct nxp_c45_phy *priv = container_of(mii_ts, struct nxp_c45_phy,\n\t\t\t\t\t\tmii_ts);\n\n\tswitch (priv->hwts_tx) {\n\tcase HWTSTAMP_TX_ON:\n\t\tNXP_C45_SKB_CB(skb)->type = type;\n\t\tNXP_C45_SKB_CB(skb)->header = ptp_parse_header(skb, type);\n\t\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\t\tskb_queue_tail(&priv->tx_queue, skb);\n\t\tif (nxp_c45_poll_txts(priv->phydev))\n\t\t\tptp_schedule_worker(priv->ptp_clock, 0);\n\t\tbreak;\n\tcase HWTSTAMP_TX_OFF:\n\tdefault:\n\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n}\n\nstatic bool nxp_c45_rxtstamp(struct mii_timestamper *mii_ts,\n\t\t\t     struct sk_buff *skb, int type)\n{\n\tstruct nxp_c45_phy *priv = container_of(mii_ts, struct nxp_c45_phy,\n\t\t\t\t\t\tmii_ts);\n\tstruct ptp_header *header = ptp_parse_header(skb, type);\n\n\tif (!header)\n\t\treturn false;\n\n\tif (!priv->hwts_rx)\n\t\treturn false;\n\n\tNXP_C45_SKB_CB(skb)->header = header;\n\tskb_queue_tail(&priv->rx_queue, skb);\n\tptp_schedule_worker(priv->ptp_clock, 0);\n\n\treturn true;\n}\n\nstatic int nxp_c45_hwtstamp(struct mii_timestamper *mii_ts,\n\t\t\t    struct ifreq *ifreq)\n{\n\tstruct nxp_c45_phy *priv = container_of(mii_ts, struct nxp_c45_phy,\n\t\t\t\t\t\tmii_ts);\n\tstruct phy_device *phydev = priv->phydev;\n\tconst struct nxp_c45_phy_data *data;\n\tstruct hwtstamp_config cfg;\n\n\tif (copy_from_user(&cfg, ifreq->ifr_data, sizeof(cfg)))\n\t\treturn -EFAULT;\n\n\tif (cfg.tx_type < 0 || cfg.tx_type > HWTSTAMP_TX_ON)\n\t\treturn -ERANGE;\n\n\tdata = nxp_c45_get_data(phydev);\n\tpriv->hwts_tx = cfg.tx_type;\n\n\tswitch (cfg.rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tpriv->hwts_rx = 0;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\t\tpriv->hwts_rx = 1;\n\t\tcfg.rx_filter = HWTSTAMP_FILTER_PTP_V2_L2_EVENT;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tif (priv->hwts_rx || priv->hwts_tx) {\n\t\tphy_write_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t      data->regmap->vend1_event_msg_filt,\n\t\t\t      EVENT_MSG_FILT_ALL);\n\t\tdata->ptp_enable(phydev, true);\n\t} else {\n\t\tphy_write_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t      data->regmap->vend1_event_msg_filt,\n\t\t\t      EVENT_MSG_FILT_NONE);\n\t\tdata->ptp_enable(phydev, false);\n\t}\n\n\tif (nxp_c45_poll_txts(priv->phydev))\n\t\tgoto nxp_c45_no_ptp_irq;\n\n\tif (priv->hwts_tx)\n\t\tnxp_c45_set_reg_field(phydev, &data->regmap->irq_egr_ts_en);\n\telse\n\t\tnxp_c45_clear_reg_field(phydev, &data->regmap->irq_egr_ts_en);\n\nnxp_c45_no_ptp_irq:\n\treturn copy_to_user(ifreq->ifr_data, &cfg, sizeof(cfg)) ? -EFAULT : 0;\n}\n\nstatic int nxp_c45_ts_info(struct mii_timestamper *mii_ts,\n\t\t\t   struct ethtool_ts_info *ts_info)\n{\n\tstruct nxp_c45_phy *priv = container_of(mii_ts, struct nxp_c45_phy,\n\t\t\t\t\t\tmii_ts);\n\n\tts_info->so_timestamping = SOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\tts_info->phc_index = ptp_clock_index(priv->ptp_clock);\n\tts_info->tx_types = (1 << HWTSTAMP_TX_OFF) | (1 << HWTSTAMP_TX_ON);\n\tts_info->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |\n\t\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L2_SYNC) |\n\t\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ) |\n\t\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L2_EVENT);\n\n\treturn 0;\n}\n\nstatic const struct nxp_c45_phy_stats common_hw_stats[] = {\n\t{ \"phy_link_status_drop_cnt\",\n\t\tNXP_C45_REG_FIELD(0x8352, MDIO_MMD_VEND1, 8, 6), },\n\t{ \"phy_link_availability_drop_cnt\",\n\t\tNXP_C45_REG_FIELD(0x8352, MDIO_MMD_VEND1, 0, 6), },\n\t{ \"phy_link_loss_cnt\",\n\t\tNXP_C45_REG_FIELD(0x8353, MDIO_MMD_VEND1, 10, 6), },\n\t{ \"phy_link_failure_cnt\",\n\t\tNXP_C45_REG_FIELD(0x8353, MDIO_MMD_VEND1, 0, 10), },\n\t{ \"phy_symbol_error_cnt\",\n\t\tNXP_C45_REG_FIELD(0x8350, MDIO_MMD_VEND1, 0, 16) },\n};\n\nstatic const struct nxp_c45_phy_stats tja1103_hw_stats[] = {\n\t{ \"rx_preamble_count\",\n\t\tNXP_C45_REG_FIELD(0xAFCE, MDIO_MMD_VEND1, 0, 6), },\n\t{ \"tx_preamble_count\",\n\t\tNXP_C45_REG_FIELD(0xAFCF, MDIO_MMD_VEND1, 0, 6), },\n\t{ \"rx_ipg_length\",\n\t\tNXP_C45_REG_FIELD(0xAFD0, MDIO_MMD_VEND1, 0, 9), },\n\t{ \"tx_ipg_length\",\n\t\tNXP_C45_REG_FIELD(0xAFD1, MDIO_MMD_VEND1, 0, 9), },\n};\n\nstatic const struct nxp_c45_phy_stats tja1120_hw_stats[] = {\n\t{ \"phy_symbol_error_cnt_ext\",\n\t\tNXP_C45_REG_FIELD(0x8351, MDIO_MMD_VEND1, 0, 14) },\n\t{ \"tx_frames_xtd\",\n\t\tNXP_C45_REG_FIELD(0xACA1, MDIO_MMD_VEND1, 0, 8), },\n\t{ \"tx_frames\",\n\t\tNXP_C45_REG_FIELD(0xACA0, MDIO_MMD_VEND1, 0, 16), },\n\t{ \"rx_frames_xtd\",\n\t\tNXP_C45_REG_FIELD(0xACA3, MDIO_MMD_VEND1, 0, 8), },\n\t{ \"rx_frames\",\n\t\tNXP_C45_REG_FIELD(0xACA2, MDIO_MMD_VEND1, 0, 16), },\n\t{ \"tx_lost_frames_xtd\",\n\t\tNXP_C45_REG_FIELD(0xACA5, MDIO_MMD_VEND1, 0, 8), },\n\t{ \"tx_lost_frames\",\n\t\tNXP_C45_REG_FIELD(0xACA4, MDIO_MMD_VEND1, 0, 16), },\n\t{ \"rx_lost_frames_xtd\",\n\t\tNXP_C45_REG_FIELD(0xACA7, MDIO_MMD_VEND1, 0, 8), },\n\t{ \"rx_lost_frames\",\n\t\tNXP_C45_REG_FIELD(0xACA6, MDIO_MMD_VEND1, 0, 16), },\n};\n\nstatic int nxp_c45_get_sset_count(struct phy_device *phydev)\n{\n\tconst struct nxp_c45_phy_data *phy_data = nxp_c45_get_data(phydev);\n\n\treturn ARRAY_SIZE(common_hw_stats) + (phy_data ? phy_data->n_stats : 0);\n}\n\nstatic void nxp_c45_get_strings(struct phy_device *phydev, u8 *data)\n{\n\tconst struct nxp_c45_phy_data *phy_data = nxp_c45_get_data(phydev);\n\tsize_t count = nxp_c45_get_sset_count(phydev);\n\tsize_t idx;\n\tsize_t i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (i < ARRAY_SIZE(common_hw_stats)) {\n\t\t\tstrscpy(data + i * ETH_GSTRING_LEN,\n\t\t\t\tcommon_hw_stats[i].name, ETH_GSTRING_LEN);\n\t\t\tcontinue;\n\t\t}\n\t\tidx = i - ARRAY_SIZE(common_hw_stats);\n\t\tstrscpy(data + i * ETH_GSTRING_LEN,\n\t\t\tphy_data->stats[idx].name, ETH_GSTRING_LEN);\n\t}\n}\n\nstatic void nxp_c45_get_stats(struct phy_device *phydev,\n\t\t\t      struct ethtool_stats *stats, u64 *data)\n{\n\tconst struct nxp_c45_phy_data *phy_data = nxp_c45_get_data(phydev);\n\tsize_t count = nxp_c45_get_sset_count(phydev);\n\tconst struct nxp_c45_reg_field *reg_field;\n\tsize_t idx;\n\tsize_t i;\n\tint ret;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (i < ARRAY_SIZE(common_hw_stats)) {\n\t\t\treg_field = &common_hw_stats[i].counter;\n\t\t} else {\n\t\t\tidx = i - ARRAY_SIZE(common_hw_stats);\n\t\t\treg_field = &phy_data->stats[idx].counter;\n\t\t}\n\n\t\tret = nxp_c45_read_reg_field(phydev, reg_field);\n\t\tif (ret < 0)\n\t\t\tdata[i] = U64_MAX;\n\t\telse\n\t\t\tdata[i] = ret;\n\t}\n}\n\nstatic int nxp_c45_config_enable(struct phy_device *phydev)\n{\n\tphy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_DEVICE_CONTROL,\n\t\t      DEVICE_CONTROL_CONFIG_GLOBAL_EN |\n\t\t      DEVICE_CONTROL_CONFIG_ALL_EN);\n\tusleep_range(400, 450);\n\n\tphy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_PORT_CONTROL,\n\t\t      PORT_CONTROL_EN);\n\tphy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_PHY_CONTROL,\n\t\t      PHY_CONFIG_EN);\n\tphy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_PORT_INFRA_CONTROL,\n\t\t      PORT_INFRA_CONTROL_EN);\n\n\treturn 0;\n}\n\nstatic int nxp_c45_start_op(struct phy_device *phydev)\n{\n\treturn phy_set_bits_mmd(phydev, MDIO_MMD_VEND1, VEND1_PHY_CONTROL,\n\t\t\t\tPHY_START_OP);\n}\n\nstatic int nxp_c45_config_intr(struct phy_device *phydev)\n{\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED)\n\t\treturn phy_set_bits_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t\t\tVEND1_PHY_IRQ_EN, PHY_IRQ_LINK_EVENT);\n\telse\n\t\treturn phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t\t\t  VEND1_PHY_IRQ_EN, PHY_IRQ_LINK_EVENT);\n}\n\nstatic int tja1103_config_intr(struct phy_device *phydev)\n{\n\tint ret;\n\n\t \n\tret = phy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_ALWAYS_ACCESSIBLE,\n\t\t\t    FUSA_PASS);\n\tif (ret)\n\t\treturn ret;\n\n\treturn nxp_c45_config_intr(phydev);\n}\n\nstatic int tja1120_config_intr(struct phy_device *phydev)\n{\n\tint ret;\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED)\n\t\tret = phy_set_bits_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t\t       TJA1120_GLOBAL_INFRA_IRQ_EN,\n\t\t\t\t       TJA1120_DEV_BOOT_DONE);\n\telse\n\t\tret = phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t\t\t TJA1120_GLOBAL_INFRA_IRQ_EN,\n\t\t\t\t\t TJA1120_DEV_BOOT_DONE);\n\tif (ret)\n\t\treturn ret;\n\n\treturn nxp_c45_config_intr(phydev);\n}\n\nstatic irqreturn_t nxp_c45_handle_interrupt(struct phy_device *phydev)\n{\n\tconst struct nxp_c45_phy_data *data = nxp_c45_get_data(phydev);\n\tstruct nxp_c45_phy *priv = phydev->priv;\n\tirqreturn_t ret = IRQ_NONE;\n\tstruct nxp_c45_hwts hwts;\n\tint irq;\n\n\tirq = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_PHY_IRQ_STATUS);\n\tif (irq & PHY_IRQ_LINK_EVENT) {\n\t\tphy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_PHY_IRQ_ACK,\n\t\t\t      PHY_IRQ_LINK_EVENT);\n\t\tphy_trigger_machine(phydev);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tirq = nxp_c45_read_reg_field(phydev, &data->regmap->irq_egr_ts_status);\n\tif (irq) {\n\t\t \n\t\tif (data->ack_ptp_irq)\n\t\t\tphy_write_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t\t      VEND1_PTP_IRQ_ACK, EGR_TS_IRQ);\n\t\twhile (data->get_egressts(priv, &hwts))\n\t\t\tnxp_c45_process_txts(priv, &hwts);\n\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tdata->nmi_handler(phydev, &ret);\n\n\treturn ret;\n}\n\nstatic int nxp_c45_soft_reset(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = phy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_DEVICE_CONTROL,\n\t\t\t    DEVICE_CONTROL_RESET);\n\tif (ret)\n\t\treturn ret;\n\n\treturn phy_read_mmd_poll_timeout(phydev, MDIO_MMD_VEND1,\n\t\t\t\t\t VEND1_DEVICE_CONTROL, ret,\n\t\t\t\t\t !(ret & DEVICE_CONTROL_RESET), 20000,\n\t\t\t\t\t 240000, false);\n}\n\nstatic int nxp_c45_cable_test_start(struct phy_device *phydev)\n{\n\tconst struct nxp_c45_regmap *regmap = nxp_c45_get_regmap(phydev);\n\n\tphy_set_bits_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t VEND1_PORT_FUNC_ENABLES, PHY_TEST_ENABLE);\n\treturn phy_set_bits_mmd(phydev, MDIO_MMD_VEND1, regmap->cable_test,\n\t\t\t\tCABLE_TEST_ENABLE | CABLE_TEST_START);\n}\n\nstatic int nxp_c45_cable_test_get_status(struct phy_device *phydev,\n\t\t\t\t\t bool *finished)\n{\n\tconst struct nxp_c45_regmap *regmap = nxp_c45_get_regmap(phydev);\n\tint ret;\n\tu8 cable_test_result;\n\n\tret = nxp_c45_read_reg_field(phydev, &regmap->cable_test_valid);\n\tif (!ret) {\n\t\t*finished = false;\n\t\treturn 0;\n\t}\n\n\t*finished = true;\n\tcable_test_result = nxp_c45_read_reg_field(phydev,\n\t\t\t\t\t\t   &regmap->cable_test_result);\n\n\tswitch (cable_test_result) {\n\tcase CABLE_TEST_OK:\n\t\tethnl_cable_test_result(phydev, ETHTOOL_A_CABLE_PAIR_A,\n\t\t\t\t\tETHTOOL_A_CABLE_RESULT_CODE_OK);\n\t\tbreak;\n\tcase CABLE_TEST_SHORTED:\n\t\tethnl_cable_test_result(phydev, ETHTOOL_A_CABLE_PAIR_A,\n\t\t\t\t\tETHTOOL_A_CABLE_RESULT_CODE_SAME_SHORT);\n\t\tbreak;\n\tcase CABLE_TEST_OPEN:\n\t\tethnl_cable_test_result(phydev, ETHTOOL_A_CABLE_PAIR_A,\n\t\t\t\t\tETHTOOL_A_CABLE_RESULT_CODE_OPEN);\n\t\tbreak;\n\tdefault:\n\t\tethnl_cable_test_result(phydev, ETHTOOL_A_CABLE_PAIR_A,\n\t\t\t\t\tETHTOOL_A_CABLE_RESULT_CODE_UNSPEC);\n\t}\n\n\tphy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, regmap->cable_test,\n\t\t\t   CABLE_TEST_ENABLE);\n\tphy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t   VEND1_PORT_FUNC_ENABLES, PHY_TEST_ENABLE);\n\n\treturn nxp_c45_start_op(phydev);\n}\n\nstatic int nxp_c45_get_sqi(struct phy_device *phydev)\n{\n\tint reg;\n\n\treg = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_SIGNAL_QUALITY);\n\tif (!(reg & SQI_VALID))\n\t\treturn -EINVAL;\n\n\treg &= SQI_MASK;\n\n\treturn reg;\n}\n\nstatic void tja1120_link_change_notify(struct phy_device *phydev)\n{\n\t \n\tif (phydev->state == PHY_NOLINK) {\n\t\tphy_set_bits_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t\t TJA1120_EPHY_RESETS, EPHY_PCS_RESET);\n\t\tphy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t\t   TJA1120_EPHY_RESETS, EPHY_PCS_RESET);\n\t}\n}\n\nstatic int nxp_c45_get_sqi_max(struct phy_device *phydev)\n{\n\treturn MAX_SQI;\n}\n\nstatic int nxp_c45_check_delay(struct phy_device *phydev, u32 delay)\n{\n\tif (delay < MIN_ID_PS) {\n\t\tphydev_err(phydev, \"delay value smaller than %u\\n\", MIN_ID_PS);\n\t\treturn -EINVAL;\n\t}\n\n\tif (delay > MAX_ID_PS) {\n\t\tphydev_err(phydev, \"delay value higher than %u\\n\", MAX_ID_PS);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void nxp_c45_counters_enable(struct phy_device *phydev)\n{\n\tconst struct nxp_c45_phy_data *data = nxp_c45_get_data(phydev);\n\n\tphy_set_bits_mmd(phydev, MDIO_MMD_VEND1, VEND1_LINK_DROP_COUNTER,\n\t\t\t COUNTER_EN);\n\n\tdata->counters_enable(phydev);\n}\n\nstatic void nxp_c45_ptp_init(struct phy_device *phydev)\n{\n\tconst struct nxp_c45_phy_data *data = nxp_c45_get_data(phydev);\n\n\tphy_write_mmd(phydev, MDIO_MMD_VEND1,\n\t\t      data->regmap->vend1_ptp_clk_period,\n\t\t      data->ptp_clk_period);\n\tnxp_c45_clear_reg_field(phydev, &data->regmap->ltc_lock_ctrl);\n\n\tdata->ptp_init(phydev);\n}\n\nstatic u64 nxp_c45_get_phase_shift(u64 phase_offset_raw)\n{\n\t \n\tphase_offset_raw *= 10;\n\tphase_offset_raw -= 738;\n\treturn div_u64(phase_offset_raw, 9);\n}\n\nstatic void nxp_c45_disable_delays(struct phy_device *phydev)\n{\n\tphy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, VEND1_TXID, ID_ENABLE);\n\tphy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, VEND1_RXID, ID_ENABLE);\n}\n\nstatic void nxp_c45_set_delays(struct phy_device *phydev)\n{\n\tstruct nxp_c45_phy *priv = phydev->priv;\n\tu64 tx_delay = priv->tx_delay;\n\tu64 rx_delay = priv->rx_delay;\n\tu64 degree;\n\n\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID ||\n\t    phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID) {\n\t\tdegree = div_u64(tx_delay, PS_PER_DEGREE);\n\t\tphy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_TXID,\n\t\t\t      ID_ENABLE | nxp_c45_get_phase_shift(degree));\n\t} else {\n\t\tphy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, VEND1_TXID,\n\t\t\t\t   ID_ENABLE);\n\t}\n\n\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID ||\n\t    phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID) {\n\t\tdegree = div_u64(rx_delay, PS_PER_DEGREE);\n\t\tphy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_RXID,\n\t\t\t      ID_ENABLE | nxp_c45_get_phase_shift(degree));\n\t} else {\n\t\tphy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, VEND1_RXID,\n\t\t\t\t   ID_ENABLE);\n\t}\n}\n\nstatic int nxp_c45_get_delays(struct phy_device *phydev)\n{\n\tstruct nxp_c45_phy *priv = phydev->priv;\n\tint ret;\n\n\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID ||\n\t    phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID) {\n\t\tret = device_property_read_u32(&phydev->mdio.dev,\n\t\t\t\t\t       \"tx-internal-delay-ps\",\n\t\t\t\t\t       &priv->tx_delay);\n\t\tif (ret)\n\t\t\tpriv->tx_delay = DEFAULT_ID_PS;\n\n\t\tret = nxp_c45_check_delay(phydev, priv->tx_delay);\n\t\tif (ret) {\n\t\t\tphydev_err(phydev,\n\t\t\t\t   \"tx-internal-delay-ps invalid value\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID ||\n\t    phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID) {\n\t\tret = device_property_read_u32(&phydev->mdio.dev,\n\t\t\t\t\t       \"rx-internal-delay-ps\",\n\t\t\t\t\t       &priv->rx_delay);\n\t\tif (ret)\n\t\t\tpriv->rx_delay = DEFAULT_ID_PS;\n\n\t\tret = nxp_c45_check_delay(phydev, priv->rx_delay);\n\t\tif (ret) {\n\t\t\tphydev_err(phydev,\n\t\t\t\t   \"rx-internal-delay-ps invalid value\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int nxp_c45_set_phy_mode(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_ABILITIES);\n\tphydev_dbg(phydev, \"Clause 45 managed PHY abilities 0x%x\\n\", ret);\n\n\tswitch (phydev->interface) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\t\tif (!(ret & RGMII_ABILITY)) {\n\t\t\tphydev_err(phydev, \"rgmii mode not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tphy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_MII_BASIC_CONFIG,\n\t\t\t      MII_BASIC_CONFIG_RGMII);\n\t\tnxp_c45_disable_delays(phydev);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\tif (!(ret & RGMII_ID_ABILITY)) {\n\t\t\tphydev_err(phydev, \"rgmii-id, rgmii-txid, rgmii-rxid modes are not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tphy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_MII_BASIC_CONFIG,\n\t\t\t      MII_BASIC_CONFIG_RGMII);\n\t\tret = nxp_c45_get_delays(phydev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tnxp_c45_set_delays(phydev);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_MII:\n\t\tif (!(ret & MII_ABILITY)) {\n\t\t\tphydev_err(phydev, \"mii mode not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tphy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_MII_BASIC_CONFIG,\n\t\t\t      MII_BASIC_CONFIG_MII);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_REVMII:\n\t\tif (!(ret & REVMII_ABILITY)) {\n\t\t\tphydev_err(phydev, \"rev-mii mode not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tphy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_MII_BASIC_CONFIG,\n\t\t\t      MII_BASIC_CONFIG_MII | MII_BASIC_CONFIG_REV);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RMII:\n\t\tif (!(ret & RMII_ABILITY)) {\n\t\t\tphydev_err(phydev, \"rmii mode not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tphy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_MII_BASIC_CONFIG,\n\t\t\t      MII_BASIC_CONFIG_RMII);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_SGMII:\n\t\tif (!(ret & SGMII_ABILITY)) {\n\t\t\tphydev_err(phydev, \"sgmii mode not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tphy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_MII_BASIC_CONFIG,\n\t\t\t      MII_BASIC_CONFIG_SGMII);\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_INTERNAL:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int nxp_c45_config_init(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = nxp_c45_config_enable(phydev);\n\tif (ret) {\n\t\tphydev_err(phydev, \"Failed to enable config\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tphy_write_mmd(phydev, MDIO_MMD_VEND1, 0x01F8, 1);\n\tphy_write_mmd(phydev, MDIO_MMD_VEND1, 0x01F9, 2);\n\n\tphy_set_bits_mmd(phydev, MDIO_MMD_VEND1, VEND1_PHY_CONFIG,\n\t\t\t PHY_CONFIG_AUTO);\n\n\tret = nxp_c45_set_phy_mode(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tphydev->autoneg = AUTONEG_DISABLE;\n\n\tnxp_c45_counters_enable(phydev);\n\tnxp_c45_ptp_init(phydev);\n\n\treturn nxp_c45_start_op(phydev);\n}\n\nstatic int nxp_c45_get_features(struct phy_device *phydev)\n{\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_TP_BIT, phydev->supported);\n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_MII_BIT, phydev->supported);\n\n\treturn genphy_c45_pma_read_abilities(phydev);\n}\n\nstatic int nxp_c45_probe(struct phy_device *phydev)\n{\n\tstruct nxp_c45_phy *priv;\n\tint ptp_ability;\n\tint ret = 0;\n\n\tpriv = devm_kzalloc(&phydev->mdio.dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tskb_queue_head_init(&priv->tx_queue);\n\tskb_queue_head_init(&priv->rx_queue);\n\n\tpriv->phydev = phydev;\n\n\tphydev->priv = priv;\n\n\tmutex_init(&priv->ptp_lock);\n\n\tptp_ability = phy_read_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t\t   VEND1_PORT_ABILITIES);\n\tptp_ability = !!(ptp_ability & PTP_ABILITY);\n\tif (!ptp_ability) {\n\t\tphydev_dbg(phydev, \"the phy does not support PTP\");\n\t\tgoto no_ptp_support;\n\t}\n\n\tif (IS_ENABLED(CONFIG_PTP_1588_CLOCK) &&\n\t    IS_ENABLED(CONFIG_NETWORK_PHY_TIMESTAMPING)) {\n\t\tpriv->mii_ts.rxtstamp = nxp_c45_rxtstamp;\n\t\tpriv->mii_ts.txtstamp = nxp_c45_txtstamp;\n\t\tpriv->mii_ts.hwtstamp = nxp_c45_hwtstamp;\n\t\tpriv->mii_ts.ts_info = nxp_c45_ts_info;\n\t\tphydev->mii_ts = &priv->mii_ts;\n\t\tret = nxp_c45_init_ptp_clock(priv);\n\t} else {\n\t\tphydev_dbg(phydev, \"PTP support not enabled even if the phy supports it\");\n\t}\n\nno_ptp_support:\n\n\treturn ret;\n}\n\nstatic void nxp_c45_remove(struct phy_device *phydev)\n{\n\tstruct nxp_c45_phy *priv = phydev->priv;\n\n\tif (priv->ptp_clock)\n\t\tptp_clock_unregister(priv->ptp_clock);\n\n\tskb_queue_purge(&priv->tx_queue);\n\tskb_queue_purge(&priv->rx_queue);\n}\n\nstatic void tja1103_counters_enable(struct phy_device *phydev)\n{\n\tphy_set_bits_mmd(phydev, MDIO_MMD_VEND1, VEND1_RX_PREAMBLE_COUNT,\n\t\t\t COUNTER_EN);\n\tphy_set_bits_mmd(phydev, MDIO_MMD_VEND1, VEND1_TX_PREAMBLE_COUNT,\n\t\t\t COUNTER_EN);\n\tphy_set_bits_mmd(phydev, MDIO_MMD_VEND1, VEND1_RX_IPG_LENGTH,\n\t\t\t COUNTER_EN);\n\tphy_set_bits_mmd(phydev, MDIO_MMD_VEND1, VEND1_TX_IPG_LENGTH,\n\t\t\t COUNTER_EN);\n}\n\nstatic void tja1103_ptp_init(struct phy_device *phydev)\n{\n\tphy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_RX_TS_INSRT_CTRL,\n\t\t      TJA1103_RX_TS_INSRT_MODE2);\n\tphy_set_bits_mmd(phydev, MDIO_MMD_VEND1, VEND1_PORT_FUNC_ENABLES,\n\t\t\t PTP_ENABLE);\n}\n\nstatic void tja1103_ptp_enable(struct phy_device *phydev, bool enable)\n{\n\tif (enable)\n\t\tphy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t\t   VEND1_PORT_PTP_CONTROL,\n\t\t\t\t   PORT_PTP_CONTROL_BYPASS);\n\telse\n\t\tphy_set_bits_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t\t VEND1_PORT_PTP_CONTROL,\n\t\t\t\t PORT_PTP_CONTROL_BYPASS);\n}\n\nstatic void tja1103_nmi_handler(struct phy_device *phydev,\n\t\t\t\tirqreturn_t *irq_status)\n{\n\tint ret;\n\n\tret = phy_read_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t   VEND1_ALWAYS_ACCESSIBLE);\n\tif (ret & FUSA_PASS) {\n\t\tphy_write_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t      VEND1_ALWAYS_ACCESSIBLE,\n\t\t\t      FUSA_PASS);\n\t\t*irq_status = IRQ_HANDLED;\n\t}\n}\n\nstatic const struct nxp_c45_regmap tja1103_regmap = {\n\t.vend1_ptp_clk_period\t= 0x1104,\n\t.vend1_event_msg_filt\t= 0x1148,\n\t.pps_enable\t\t=\n\t\tNXP_C45_REG_FIELD(0x1102, MDIO_MMD_VEND1, 3, 1),\n\t.pps_polarity\t\t=\n\t\tNXP_C45_REG_FIELD(0x1102, MDIO_MMD_VEND1, 2, 1),\n\t.ltc_lock_ctrl\t\t=\n\t\tNXP_C45_REG_FIELD(0x1115, MDIO_MMD_VEND1, 0, 1),\n\t.ltc_read\t\t=\n\t\tNXP_C45_REG_FIELD(0x1105, MDIO_MMD_VEND1, 2, 1),\n\t.ltc_write\t\t=\n\t\tNXP_C45_REG_FIELD(0x1105, MDIO_MMD_VEND1, 0, 1),\n\t.vend1_ltc_wr_nsec_0\t= 0x1106,\n\t.vend1_ltc_wr_nsec_1\t= 0x1107,\n\t.vend1_ltc_wr_sec_0\t= 0x1108,\n\t.vend1_ltc_wr_sec_1\t= 0x1109,\n\t.vend1_ltc_rd_nsec_0\t= 0x110A,\n\t.vend1_ltc_rd_nsec_1\t= 0x110B,\n\t.vend1_ltc_rd_sec_0\t= 0x110C,\n\t.vend1_ltc_rd_sec_1\t= 0x110D,\n\t.vend1_rate_adj_subns_0\t= 0x110F,\n\t.vend1_rate_adj_subns_1\t= 0x1110,\n\t.irq_egr_ts_en\t\t=\n\t\tNXP_C45_REG_FIELD(0x1131, MDIO_MMD_VEND1, 0, 1),\n\t.irq_egr_ts_status\t=\n\t\tNXP_C45_REG_FIELD(0x1132, MDIO_MMD_VEND1, 0, 1),\n\t.domain_number\t\t=\n\t\tNXP_C45_REG_FIELD(0x114E, MDIO_MMD_VEND1, 0, 8),\n\t.msg_type\t\t=\n\t\tNXP_C45_REG_FIELD(0x114E, MDIO_MMD_VEND1, 8, 4),\n\t.sequence_id\t\t=\n\t\tNXP_C45_REG_FIELD(0x114F, MDIO_MMD_VEND1, 0, 16),\n\t.sec_1_0\t\t=\n\t\tNXP_C45_REG_FIELD(0x1151, MDIO_MMD_VEND1, 14, 2),\n\t.sec_4_2\t\t=\n\t\tNXP_C45_REG_FIELD(0x114E, MDIO_MMD_VEND1, 12, 3),\n\t.nsec_15_0\t\t=\n\t\tNXP_C45_REG_FIELD(0x1150, MDIO_MMD_VEND1, 0, 16),\n\t.nsec_29_16\t\t=\n\t\tNXP_C45_REG_FIELD(0x1151, MDIO_MMD_VEND1, 0, 14),\n\t.vend1_ext_trg_data_0\t= 0x1121,\n\t.vend1_ext_trg_data_1\t= 0x1122,\n\t.vend1_ext_trg_data_2\t= 0x1123,\n\t.vend1_ext_trg_data_3\t= 0x1124,\n\t.vend1_ext_trg_ctrl\t= 0x1126,\n\t.cable_test\t\t= 0x8330,\n\t.cable_test_valid\t=\n\t\tNXP_C45_REG_FIELD(0x8330, MDIO_MMD_VEND1, 13, 1),\n\t.cable_test_result\t=\n\t\tNXP_C45_REG_FIELD(0x8330, MDIO_MMD_VEND1, 0, 3),\n};\n\nstatic const struct nxp_c45_phy_data tja1103_phy_data = {\n\t.regmap = &tja1103_regmap,\n\t.stats = tja1103_hw_stats,\n\t.n_stats = ARRAY_SIZE(tja1103_hw_stats),\n\t.ptp_clk_period = PTP_CLK_PERIOD_100BT1,\n\t.ext_ts_both_edges = false,\n\t.ack_ptp_irq = false,\n\t.counters_enable = tja1103_counters_enable,\n\t.get_egressts = nxp_c45_get_hwtxts,\n\t.get_extts = nxp_c45_get_extts,\n\t.ptp_init = tja1103_ptp_init,\n\t.ptp_enable = tja1103_ptp_enable,\n\t.nmi_handler = tja1103_nmi_handler,\n};\n\nstatic void tja1120_counters_enable(struct phy_device *phydev)\n{\n\tphy_set_bits_mmd(phydev, MDIO_MMD_VEND1, VEND1_SYMBOL_ERROR_CNT_XTD,\n\t\t\t EXTENDED_CNT_EN);\n\tphy_set_bits_mmd(phydev, MDIO_MMD_VEND1, VEND1_MONITOR_STATUS,\n\t\t\t MONITOR_RESET);\n\tphy_set_bits_mmd(phydev, MDIO_MMD_VEND1, VEND1_MONITOR_CONFIG,\n\t\t\t ALL_FRAMES_CNT_EN | LOST_FRAMES_CNT_EN);\n}\n\nstatic void tja1120_ptp_init(struct phy_device *phydev)\n{\n\tphy_write_mmd(phydev, MDIO_MMD_VEND1, TJA1120_RX_TS_INSRT_CTRL,\n\t\t      TJA1120_RX_TS_INSRT_EN | TJA1120_TS_INSRT_MODE);\n\tphy_write_mmd(phydev, MDIO_MMD_VEND1, TJA1120_VEND1_EXT_TS_MODE,\n\t\t      TJA1120_TS_INSRT_MODE);\n\tphy_set_bits_mmd(phydev, MDIO_MMD_VEND1, VEND1_DEVICE_CONFIG,\n\t\t\t PTP_ENABLE);\n}\n\nstatic void tja1120_ptp_enable(struct phy_device *phydev, bool enable)\n{\n\tif (enable)\n\t\tphy_set_bits_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t\t VEND1_PORT_FUNC_ENABLES,\n\t\t\t\t PTP_ENABLE);\n\telse\n\t\tphy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t\t   VEND1_PORT_FUNC_ENABLES,\n\t\t\t\t   PTP_ENABLE);\n}\n\nstatic void tja1120_nmi_handler(struct phy_device *phydev,\n\t\t\t\tirqreturn_t *irq_status)\n{\n\tint ret;\n\n\tret = phy_read_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t   TJA1120_GLOBAL_INFRA_IRQ_STATUS);\n\tif (ret & TJA1120_DEV_BOOT_DONE) {\n\t\tphy_write_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t      TJA1120_GLOBAL_INFRA_IRQ_ACK,\n\t\t\t      TJA1120_DEV_BOOT_DONE);\n\t\t*irq_status = IRQ_HANDLED;\n\t}\n}\n\nstatic const struct nxp_c45_regmap tja1120_regmap = {\n\t.vend1_ptp_clk_period\t= 0x1020,\n\t.vend1_event_msg_filt\t= 0x9010,\n\t.pps_enable\t\t=\n\t\tNXP_C45_REG_FIELD(0x1006, MDIO_MMD_VEND1, 4, 1),\n\t.pps_polarity\t\t=\n\t\tNXP_C45_REG_FIELD(0x1006, MDIO_MMD_VEND1, 5, 1),\n\t.ltc_lock_ctrl\t\t=\n\t\tNXP_C45_REG_FIELD(0x1006, MDIO_MMD_VEND1, 2, 1),\n\t.ltc_read\t\t=\n\t\tNXP_C45_REG_FIELD(0x1000, MDIO_MMD_VEND1, 1, 1),\n\t.ltc_write\t\t=\n\t\tNXP_C45_REG_FIELD(0x1000, MDIO_MMD_VEND1, 2, 1),\n\t.vend1_ltc_wr_nsec_0\t= 0x1040,\n\t.vend1_ltc_wr_nsec_1\t= 0x1041,\n\t.vend1_ltc_wr_sec_0\t= 0x1042,\n\t.vend1_ltc_wr_sec_1\t= 0x1043,\n\t.vend1_ltc_rd_nsec_0\t= 0x1048,\n\t.vend1_ltc_rd_nsec_1\t= 0x1049,\n\t.vend1_ltc_rd_sec_0\t= 0x104A,\n\t.vend1_ltc_rd_sec_1\t= 0x104B,\n\t.vend1_rate_adj_subns_0\t= 0x1030,\n\t.vend1_rate_adj_subns_1\t= 0x1031,\n\t.irq_egr_ts_en\t\t=\n\t\tNXP_C45_REG_FIELD(0x900A, MDIO_MMD_VEND1, 1, 1),\n\t.irq_egr_ts_status\t=\n\t\tNXP_C45_REG_FIELD(0x900C, MDIO_MMD_VEND1, 1, 1),\n\t.domain_number\t\t=\n\t\tNXP_C45_REG_FIELD(0x9061, MDIO_MMD_VEND1, 8, 8),\n\t.msg_type\t\t=\n\t\tNXP_C45_REG_FIELD(0x9061, MDIO_MMD_VEND1, 4, 4),\n\t.sequence_id\t\t=\n\t\tNXP_C45_REG_FIELD(0x9062, MDIO_MMD_VEND1, 0, 16),\n\t.sec_1_0\t\t=\n\t\tNXP_C45_REG_FIELD(0x9065, MDIO_MMD_VEND1, 0, 2),\n\t.sec_4_2\t\t=\n\t\tNXP_C45_REG_FIELD(0x9065, MDIO_MMD_VEND1, 2, 3),\n\t.nsec_15_0\t\t=\n\t\tNXP_C45_REG_FIELD(0x9063, MDIO_MMD_VEND1, 0, 16),\n\t.nsec_29_16\t\t=\n\t\tNXP_C45_REG_FIELD(0x9064, MDIO_MMD_VEND1, 0, 14),\n\t.vend1_ext_trg_data_0\t= 0x1071,\n\t.vend1_ext_trg_data_1\t= 0x1072,\n\t.vend1_ext_trg_data_2\t= 0x1073,\n\t.vend1_ext_trg_data_3\t= 0x1074,\n\t.vend1_ext_trg_ctrl\t= 0x1075,\n\t.cable_test\t\t= 0x8360,\n\t.cable_test_valid\t=\n\t\tNXP_C45_REG_FIELD(0x8361, MDIO_MMD_VEND1, 15, 1),\n\t.cable_test_result\t=\n\t\tNXP_C45_REG_FIELD(0x8361, MDIO_MMD_VEND1, 0, 3),\n};\n\nstatic const struct nxp_c45_phy_data tja1120_phy_data = {\n\t.regmap = &tja1120_regmap,\n\t.stats = tja1120_hw_stats,\n\t.n_stats = ARRAY_SIZE(tja1120_hw_stats),\n\t.ptp_clk_period = PTP_CLK_PERIOD_1000BT1,\n\t.ext_ts_both_edges = true,\n\t.ack_ptp_irq = true,\n\t.counters_enable = tja1120_counters_enable,\n\t.get_egressts = tja1120_get_hwtxts,\n\t.get_extts = tja1120_get_extts,\n\t.ptp_init = tja1120_ptp_init,\n\t.ptp_enable = tja1120_ptp_enable,\n\t.nmi_handler = tja1120_nmi_handler,\n};\n\nstatic struct phy_driver nxp_c45_driver[] = {\n\t{\n\t\tPHY_ID_MATCH_MODEL(PHY_ID_TJA_1103),\n\t\t.name\t\t\t= \"NXP C45 TJA1103\",\n\t\t.get_features\t\t= nxp_c45_get_features,\n\t\t.driver_data\t\t= &tja1103_phy_data,\n\t\t.probe\t\t\t= nxp_c45_probe,\n\t\t.soft_reset\t\t= nxp_c45_soft_reset,\n\t\t.config_aneg\t\t= genphy_c45_config_aneg,\n\t\t.config_init\t\t= nxp_c45_config_init,\n\t\t.config_intr\t\t= tja1103_config_intr,\n\t\t.handle_interrupt\t= nxp_c45_handle_interrupt,\n\t\t.read_status\t\t= genphy_c45_read_status,\n\t\t.suspend\t\t= genphy_c45_pma_suspend,\n\t\t.resume\t\t\t= genphy_c45_pma_resume,\n\t\t.get_sset_count\t\t= nxp_c45_get_sset_count,\n\t\t.get_strings\t\t= nxp_c45_get_strings,\n\t\t.get_stats\t\t= nxp_c45_get_stats,\n\t\t.cable_test_start\t= nxp_c45_cable_test_start,\n\t\t.cable_test_get_status\t= nxp_c45_cable_test_get_status,\n\t\t.set_loopback\t\t= genphy_c45_loopback,\n\t\t.get_sqi\t\t= nxp_c45_get_sqi,\n\t\t.get_sqi_max\t\t= nxp_c45_get_sqi_max,\n\t\t.remove\t\t\t= nxp_c45_remove,\n\t},\n\t{\n\t\tPHY_ID_MATCH_MODEL(PHY_ID_TJA_1120),\n\t\t.name\t\t\t= \"NXP C45 TJA1120\",\n\t\t.get_features\t\t= nxp_c45_get_features,\n\t\t.driver_data\t\t= &tja1120_phy_data,\n\t\t.probe\t\t\t= nxp_c45_probe,\n\t\t.soft_reset\t\t= nxp_c45_soft_reset,\n\t\t.config_aneg\t\t= genphy_c45_config_aneg,\n\t\t.config_init\t\t= nxp_c45_config_init,\n\t\t.config_intr\t\t= tja1120_config_intr,\n\t\t.handle_interrupt\t= nxp_c45_handle_interrupt,\n\t\t.read_status\t\t= genphy_c45_read_status,\n\t\t.link_change_notify\t= tja1120_link_change_notify,\n\t\t.suspend\t\t= genphy_c45_pma_suspend,\n\t\t.resume\t\t\t= genphy_c45_pma_resume,\n\t\t.get_sset_count\t\t= nxp_c45_get_sset_count,\n\t\t.get_strings\t\t= nxp_c45_get_strings,\n\t\t.get_stats\t\t= nxp_c45_get_stats,\n\t\t.cable_test_start\t= nxp_c45_cable_test_start,\n\t\t.cable_test_get_status\t= nxp_c45_cable_test_get_status,\n\t\t.set_loopback\t\t= genphy_c45_loopback,\n\t\t.get_sqi\t\t= nxp_c45_get_sqi,\n\t\t.get_sqi_max\t\t= nxp_c45_get_sqi_max,\n\t\t.remove\t\t\t= nxp_c45_remove,\n\t},\n};\n\nmodule_phy_driver(nxp_c45_driver);\n\nstatic struct mdio_device_id __maybe_unused nxp_c45_tbl[] = {\n\t{ PHY_ID_MATCH_MODEL(PHY_ID_TJA_1103) },\n\t{ PHY_ID_MATCH_MODEL(PHY_ID_TJA_1120) },\n\t{   },\n};\n\nMODULE_DEVICE_TABLE(mdio, nxp_c45_tbl);\n\nMODULE_AUTHOR(\"Radu Pirea <radu-nicolae.pirea@oss.nxp.com>\");\nMODULE_DESCRIPTION(\"NXP C45 PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}