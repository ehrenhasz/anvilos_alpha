{
  "module_name": "dp83822.c",
  "hash_id": "d96d4e04246a230684580186eec32016a14e37883e1f1afb9b2467b1d8ea3a89",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/dp83822.c",
  "human_readable_source": "\n \n\n#include <linux/ethtool.h>\n#include <linux/etherdevice.h>\n#include <linux/kernel.h>\n#include <linux/mii.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy.h>\n#include <linux/netdevice.h>\n\n#define DP83822_PHY_ID\t        0x2000a240\n#define DP83825S_PHY_ID\t\t0x2000a140\n#define DP83825I_PHY_ID\t\t0x2000a150\n#define DP83825CM_PHY_ID\t0x2000a160\n#define DP83825CS_PHY_ID\t0x2000a170\n#define DP83826C_PHY_ID\t\t0x2000a130\n#define DP83826NC_PHY_ID\t0x2000a110\n\n#define DP83822_DEVADDR\t\t0x1f\n\n#define MII_DP83822_CTRL_2\t0x0a\n#define MII_DP83822_PHYSTS\t0x10\n#define MII_DP83822_PHYSCR\t0x11\n#define MII_DP83822_MISR1\t0x12\n#define MII_DP83822_MISR2\t0x13\n#define MII_DP83822_FCSCR\t0x14\n#define MII_DP83822_RCSR\t0x17\n#define MII_DP83822_RESET_CTRL\t0x1f\n#define MII_DP83822_GENCFG\t0x465\n#define MII_DP83822_SOR1\t0x467\n\n \n#define DP83822_SIG_DET_LOW\tBIT(0)\n\n \n#define DP83822_FX_ENABLE\tBIT(14)\n\n#define DP83822_HW_RESET\tBIT(15)\n#define DP83822_SW_RESET\tBIT(14)\n\n \n#define DP83822_PHYSTS_DUPLEX\t\t\tBIT(2)\n#define DP83822_PHYSTS_10\t\t\tBIT(1)\n#define DP83822_PHYSTS_LINK\t\t\tBIT(0)\n\n \n#define DP83822_PHYSCR_INT_OE\t\tBIT(0)  \n#define DP83822_PHYSCR_INTEN\t\tBIT(1)  \n\n \n#define DP83822_RX_ERR_HF_INT_EN\tBIT(0)\n#define DP83822_FALSE_CARRIER_HF_INT_EN\tBIT(1)\n#define DP83822_ANEG_COMPLETE_INT_EN\tBIT(2)\n#define DP83822_DUP_MODE_CHANGE_INT_EN\tBIT(3)\n#define DP83822_SPEED_CHANGED_INT_EN\tBIT(4)\n#define DP83822_LINK_STAT_INT_EN\tBIT(5)\n#define DP83822_ENERGY_DET_INT_EN\tBIT(6)\n#define DP83822_LINK_QUAL_INT_EN\tBIT(7)\n\n \n#define DP83822_JABBER_DET_INT_EN\tBIT(0)\n#define DP83822_WOL_PKT_INT_EN\t\tBIT(1)\n#define DP83822_SLEEP_MODE_INT_EN\tBIT(2)\n#define DP83822_MDI_XOVER_INT_EN\tBIT(3)\n#define DP83822_LB_FIFO_INT_EN\t\tBIT(4)\n#define DP83822_PAGE_RX_INT_EN\t\tBIT(5)\n#define DP83822_ANEG_ERR_INT_EN\t\tBIT(6)\n#define DP83822_EEE_ERROR_CHANGE_INT_EN\tBIT(7)\n\n \n#define DP83822_WOL_INT_EN\tBIT(4)\n#define DP83822_WOL_INT_STAT\tBIT(12)\n\n#define MII_DP83822_RXSOP1\t0x04a5\n#define\tMII_DP83822_RXSOP2\t0x04a6\n#define\tMII_DP83822_RXSOP3\t0x04a7\n\n \n#define\tMII_DP83822_WOL_CFG\t0x04a0\n#define\tMII_DP83822_WOL_STAT\t0x04a1\n#define\tMII_DP83822_WOL_DA1\t0x04a2\n#define\tMII_DP83822_WOL_DA2\t0x04a3\n#define\tMII_DP83822_WOL_DA3\t0x04a4\n\n \n#define DP83822_WOL_MAGIC_EN\tBIT(0)\n#define DP83822_WOL_SECURE_ON\tBIT(5)\n#define DP83822_WOL_EN\t\tBIT(7)\n#define DP83822_WOL_INDICATION_SEL BIT(8)\n#define DP83822_WOL_CLR_INDICATION BIT(11)\n\n \n#define DP83822_RGMII_MODE_EN\tBIT(9)\n#define DP83822_RX_CLK_SHIFT\tBIT(12)\n#define DP83822_TX_CLK_SHIFT\tBIT(11)\n\n \n#define DP83822_STRAP_MODE1\t0\n#define DP83822_STRAP_MODE2\tBIT(0)\n#define DP83822_STRAP_MODE3\tBIT(1)\n#define DP83822_STRAP_MODE4\tGENMASK(1, 0)\n\n#define DP83822_COL_STRAP_MASK\tGENMASK(11, 10)\n#define DP83822_COL_SHIFT\t10\n#define DP83822_RX_ER_STR_MASK\tGENMASK(9, 8)\n#define DP83822_RX_ER_SHIFT\t8\n\n#define MII_DP83822_FIBER_ADVERTISE    (ADVERTISED_TP | ADVERTISED_MII | \\\n\t\t\t\t\tADVERTISED_FIBRE | \\\n\t\t\t\t\tADVERTISED_Pause | ADVERTISED_Asym_Pause)\n\nstruct dp83822_private {\n\tbool fx_signal_det_low;\n\tint fx_enabled;\n\tu16 fx_sd_enable;\n};\n\nstatic int dp83822_set_wol(struct phy_device *phydev,\n\t\t\t   struct ethtool_wolinfo *wol)\n{\n\tstruct net_device *ndev = phydev->attached_dev;\n\tu16 value;\n\tconst u8 *mac;\n\n\tif (wol->wolopts & (WAKE_MAGIC | WAKE_MAGICSECURE)) {\n\t\tmac = (const u8 *)ndev->dev_addr;\n\n\t\tif (!is_valid_ether_addr(mac))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tphy_write_mmd(phydev, DP83822_DEVADDR, MII_DP83822_WOL_DA1,\n\t\t\t      (mac[1] << 8) | mac[0]);\n\t\tphy_write_mmd(phydev, DP83822_DEVADDR, MII_DP83822_WOL_DA2,\n\t\t\t      (mac[3] << 8) | mac[2]);\n\t\tphy_write_mmd(phydev, DP83822_DEVADDR, MII_DP83822_WOL_DA3,\n\t\t\t      (mac[5] << 8) | mac[4]);\n\n\t\tvalue = phy_read_mmd(phydev, DP83822_DEVADDR,\n\t\t\t\t     MII_DP83822_WOL_CFG);\n\t\tif (wol->wolopts & WAKE_MAGIC)\n\t\t\tvalue |= DP83822_WOL_MAGIC_EN;\n\t\telse\n\t\t\tvalue &= ~DP83822_WOL_MAGIC_EN;\n\n\t\tif (wol->wolopts & WAKE_MAGICSECURE) {\n\t\t\tphy_write_mmd(phydev, DP83822_DEVADDR,\n\t\t\t\t      MII_DP83822_RXSOP1,\n\t\t\t\t      (wol->sopass[1] << 8) | wol->sopass[0]);\n\t\t\tphy_write_mmd(phydev, DP83822_DEVADDR,\n\t\t\t\t      MII_DP83822_RXSOP2,\n\t\t\t\t      (wol->sopass[3] << 8) | wol->sopass[2]);\n\t\t\tphy_write_mmd(phydev, DP83822_DEVADDR,\n\t\t\t\t      MII_DP83822_RXSOP3,\n\t\t\t\t      (wol->sopass[5] << 8) | wol->sopass[4]);\n\t\t\tvalue |= DP83822_WOL_SECURE_ON;\n\t\t} else {\n\t\t\tvalue &= ~DP83822_WOL_SECURE_ON;\n\t\t}\n\n\t\t \n\t\tphy_read(phydev, MII_DP83822_MISR2);\n\n\t\tvalue |= DP83822_WOL_EN | DP83822_WOL_INDICATION_SEL |\n\t\t\t DP83822_WOL_CLR_INDICATION;\n\n\t\treturn phy_write_mmd(phydev, DP83822_DEVADDR,\n\t\t\t\t     MII_DP83822_WOL_CFG, value);\n\t} else {\n\t\treturn phy_clear_bits_mmd(phydev, DP83822_DEVADDR,\n\t\t\t\t\t  MII_DP83822_WOL_CFG, DP83822_WOL_EN);\n\t}\n}\n\nstatic void dp83822_get_wol(struct phy_device *phydev,\n\t\t\t    struct ethtool_wolinfo *wol)\n{\n\tint value;\n\tu16 sopass_val;\n\n\twol->supported = (WAKE_MAGIC | WAKE_MAGICSECURE);\n\twol->wolopts = 0;\n\n\tvalue = phy_read_mmd(phydev, DP83822_DEVADDR, MII_DP83822_WOL_CFG);\n\n\tif (value & DP83822_WOL_MAGIC_EN)\n\t\twol->wolopts |= WAKE_MAGIC;\n\n\tif (value & DP83822_WOL_SECURE_ON) {\n\t\tsopass_val = phy_read_mmd(phydev, DP83822_DEVADDR,\n\t\t\t\t\t  MII_DP83822_RXSOP1);\n\t\twol->sopass[0] = (sopass_val & 0xff);\n\t\twol->sopass[1] = (sopass_val >> 8);\n\n\t\tsopass_val = phy_read_mmd(phydev, DP83822_DEVADDR,\n\t\t\t\t\t  MII_DP83822_RXSOP2);\n\t\twol->sopass[2] = (sopass_val & 0xff);\n\t\twol->sopass[3] = (sopass_val >> 8);\n\n\t\tsopass_val = phy_read_mmd(phydev, DP83822_DEVADDR,\n\t\t\t\t\t  MII_DP83822_RXSOP3);\n\t\twol->sopass[4] = (sopass_val & 0xff);\n\t\twol->sopass[5] = (sopass_val >> 8);\n\n\t\twol->wolopts |= WAKE_MAGICSECURE;\n\t}\n\n\t \n\tif (!(value & DP83822_WOL_EN))\n\t\twol->wolopts = 0;\n}\n\nstatic int dp83822_config_intr(struct phy_device *phydev)\n{\n\tstruct dp83822_private *dp83822 = phydev->priv;\n\tint misr_status;\n\tint physcr_status;\n\tint err;\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\tmisr_status = phy_read(phydev, MII_DP83822_MISR1);\n\t\tif (misr_status < 0)\n\t\t\treturn misr_status;\n\n\t\tmisr_status |= (DP83822_LINK_STAT_INT_EN |\n\t\t\t\tDP83822_ENERGY_DET_INT_EN |\n\t\t\t\tDP83822_LINK_QUAL_INT_EN);\n\n\t\t \n\t\tif (!dp83822 || !dp83822->fx_enabled)\n\t\t\tmisr_status |= DP83822_ANEG_COMPLETE_INT_EN |\n\t\t\t\t       DP83822_DUP_MODE_CHANGE_INT_EN |\n\t\t\t\t       DP83822_SPEED_CHANGED_INT_EN;\n\n\n\t\terr = phy_write(phydev, MII_DP83822_MISR1, misr_status);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tmisr_status = phy_read(phydev, MII_DP83822_MISR2);\n\t\tif (misr_status < 0)\n\t\t\treturn misr_status;\n\n\t\tmisr_status |= (DP83822_JABBER_DET_INT_EN |\n\t\t\t\tDP83822_SLEEP_MODE_INT_EN |\n\t\t\t\tDP83822_LB_FIFO_INT_EN |\n\t\t\t\tDP83822_PAGE_RX_INT_EN |\n\t\t\t\tDP83822_EEE_ERROR_CHANGE_INT_EN);\n\n\t\t \n\t\tif (!dp83822 || !dp83822->fx_enabled)\n\t\t\tmisr_status |= DP83822_ANEG_ERR_INT_EN |\n\t\t\t\t       DP83822_WOL_PKT_INT_EN;\n\n\t\terr = phy_write(phydev, MII_DP83822_MISR2, misr_status);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tphyscr_status = phy_read(phydev, MII_DP83822_PHYSCR);\n\t\tif (physcr_status < 0)\n\t\t\treturn physcr_status;\n\n\t\tphyscr_status |= DP83822_PHYSCR_INT_OE | DP83822_PHYSCR_INTEN;\n\n\t} else {\n\t\terr = phy_write(phydev, MII_DP83822_MISR1, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = phy_write(phydev, MII_DP83822_MISR2, 0);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tphyscr_status = phy_read(phydev, MII_DP83822_PHYSCR);\n\t\tif (physcr_status < 0)\n\t\t\treturn physcr_status;\n\n\t\tphyscr_status &= ~DP83822_PHYSCR_INTEN;\n\t}\n\n\treturn phy_write(phydev, MII_DP83822_PHYSCR, physcr_status);\n}\n\nstatic irqreturn_t dp83822_handle_interrupt(struct phy_device *phydev)\n{\n\tbool trigger_machine = false;\n\tint irq_status;\n\n\t \n\tirq_status = phy_read(phydev, MII_DP83822_MISR1);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\tif (irq_status & ((irq_status & GENMASK(7, 0)) << 8))\n\t\ttrigger_machine = true;\n\n\tirq_status = phy_read(phydev, MII_DP83822_MISR2);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\tif (irq_status & ((irq_status & GENMASK(7, 0)) << 8))\n\t\ttrigger_machine = true;\n\n\tif (!trigger_machine)\n\t\treturn IRQ_NONE;\n\n\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int dp8382x_disable_wol(struct phy_device *phydev)\n{\n\treturn phy_clear_bits_mmd(phydev, DP83822_DEVADDR, MII_DP83822_WOL_CFG,\n\t\t\t\t  DP83822_WOL_EN | DP83822_WOL_MAGIC_EN |\n\t\t\t\t  DP83822_WOL_SECURE_ON);\n}\n\nstatic int dp83822_read_status(struct phy_device *phydev)\n{\n\tstruct dp83822_private *dp83822 = phydev->priv;\n\tint status = phy_read(phydev, MII_DP83822_PHYSTS);\n\tint ctrl2;\n\tint ret;\n\n\tif (dp83822->fx_enabled) {\n\t\tif (status & DP83822_PHYSTS_LINK) {\n\t\t\tphydev->speed = SPEED_UNKNOWN;\n\t\t\tphydev->duplex = DUPLEX_UNKNOWN;\n\t\t} else {\n\t\t\tctrl2 = phy_read(phydev, MII_DP83822_CTRL_2);\n\t\t\tif (ctrl2 < 0)\n\t\t\t\treturn ctrl2;\n\n\t\t\tif (!(ctrl2 & DP83822_FX_ENABLE)) {\n\t\t\t\tret = phy_write(phydev, MII_DP83822_CTRL_2,\n\t\t\t\t\t\tDP83822_FX_ENABLE | ctrl2);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = genphy_read_status(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (status < 0)\n\t\treturn status;\n\n\tif (status & DP83822_PHYSTS_DUPLEX)\n\t\tphydev->duplex = DUPLEX_FULL;\n\telse\n\t\tphydev->duplex = DUPLEX_HALF;\n\n\tif (status & DP83822_PHYSTS_10)\n\t\tphydev->speed = SPEED_10;\n\telse\n\t\tphydev->speed = SPEED_100;\n\n\treturn 0;\n}\n\nstatic int dp83822_config_init(struct phy_device *phydev)\n{\n\tstruct dp83822_private *dp83822 = phydev->priv;\n\tstruct device *dev = &phydev->mdio.dev;\n\tint rgmii_delay;\n\ts32 rx_int_delay;\n\ts32 tx_int_delay;\n\tint err = 0;\n\tint bmcr;\n\n\tif (phy_interface_is_rgmii(phydev)) {\n\t\trx_int_delay = phy_get_internal_delay(phydev, dev, NULL, 0,\n\t\t\t\t\t\t      true);\n\n\t\tif (rx_int_delay <= 0)\n\t\t\trgmii_delay = 0;\n\t\telse\n\t\t\trgmii_delay = DP83822_RX_CLK_SHIFT;\n\n\t\ttx_int_delay = phy_get_internal_delay(phydev, dev, NULL, 0,\n\t\t\t\t\t\t      false);\n\t\tif (tx_int_delay <= 0)\n\t\t\trgmii_delay &= ~DP83822_TX_CLK_SHIFT;\n\t\telse\n\t\t\trgmii_delay |= DP83822_TX_CLK_SHIFT;\n\n\t\tif (rgmii_delay) {\n\t\t\terr = phy_set_bits_mmd(phydev, DP83822_DEVADDR,\n\t\t\t\t\t       MII_DP83822_RCSR, rgmii_delay);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tphy_set_bits_mmd(phydev, DP83822_DEVADDR,\n\t\t\t\t\tMII_DP83822_RCSR, DP83822_RGMII_MODE_EN);\n\t} else {\n\t\tphy_clear_bits_mmd(phydev, DP83822_DEVADDR,\n\t\t\t\t\tMII_DP83822_RCSR, DP83822_RGMII_MODE_EN);\n\t}\n\n\tif (dp83822->fx_enabled) {\n\t\terr = phy_modify(phydev, MII_DP83822_CTRL_2,\n\t\t\t\t DP83822_FX_ENABLE, 1);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\tlinkmode_and(phydev->advertising, phydev->advertising,\n\t\t\t     phydev->supported);\n\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FIBRE_BIT,\n\t\t\t\t phydev->supported);\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FIBRE_BIT,\n\t\t\t\t phydev->advertising);\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100baseFX_Full_BIT,\n\t\t\t\t phydev->supported);\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100baseFX_Half_BIT,\n\t\t\t\t phydev->supported);\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100baseFX_Full_BIT,\n\t\t\t\t phydev->advertising);\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100baseFX_Half_BIT,\n\t\t\t\t phydev->advertising);\n\n\t\t \n\t\tbmcr = phy_read(phydev, MII_BMCR);\n\t\tif (bmcr < 0)\n\t\t\treturn bmcr;\n\n\t\tif (bmcr & BMCR_ANENABLE) {\n\t\t\terr =  phy_modify(phydev, MII_BMCR, BMCR_ANENABLE, 0);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tphydev->autoneg = AUTONEG_DISABLE;\n\t\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,\n\t\t\t\t   phydev->supported);\n\t\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,\n\t\t\t\t   phydev->advertising);\n\n\t\t \n\t\terr = phy_modify_changed(phydev, MII_ADVERTISE,\n\t\t\t\t\t MII_DP83822_FIBER_ADVERTISE,\n\t\t\t\t\t MII_DP83822_FIBER_ADVERTISE);\n\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (dp83822->fx_signal_det_low) {\n\t\t\terr = phy_set_bits_mmd(phydev, DP83822_DEVADDR,\n\t\t\t\t\t       MII_DP83822_GENCFG,\n\t\t\t\t\t       DP83822_SIG_DET_LOW);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn dp8382x_disable_wol(phydev);\n}\n\nstatic int dp8382x_config_init(struct phy_device *phydev)\n{\n\treturn dp8382x_disable_wol(phydev);\n}\n\nstatic int dp83822_phy_reset(struct phy_device *phydev)\n{\n\tint err;\n\n\terr = phy_write(phydev, MII_DP83822_RESET_CTRL, DP83822_SW_RESET);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn phydev->drv->config_init(phydev);\n}\n\n#ifdef CONFIG_OF_MDIO\nstatic int dp83822_of_init(struct phy_device *phydev)\n{\n\tstruct dp83822_private *dp83822 = phydev->priv;\n\tstruct device *dev = &phydev->mdio.dev;\n\n\t \n\tif (dp83822->fx_enabled && dp83822->fx_sd_enable)\n\t\tdp83822->fx_signal_det_low = device_property_present(dev,\n\t\t\t\t\t\t\t\t     \"ti,link-loss-low\");\n\tif (!dp83822->fx_enabled)\n\t\tdp83822->fx_enabled = device_property_present(dev,\n\t\t\t\t\t\t\t      \"ti,fiber-mode\");\n\n\treturn 0;\n}\n#else\nstatic int dp83822_of_init(struct phy_device *phydev)\n{\n\treturn 0;\n}\n#endif  \n\nstatic int dp83822_read_straps(struct phy_device *phydev)\n{\n\tstruct dp83822_private *dp83822 = phydev->priv;\n\tint fx_enabled, fx_sd_enable;\n\tint val;\n\n\tval = phy_read_mmd(phydev, DP83822_DEVADDR, MII_DP83822_SOR1);\n\tif (val < 0)\n\t\treturn val;\n\n\tphydev_dbg(phydev, \"SOR1 strap register: 0x%04x\\n\", val);\n\n\tfx_enabled = (val & DP83822_COL_STRAP_MASK) >> DP83822_COL_SHIFT;\n\tif (fx_enabled == DP83822_STRAP_MODE2 ||\n\t    fx_enabled == DP83822_STRAP_MODE3)\n\t\tdp83822->fx_enabled = 1;\n\n\tif (dp83822->fx_enabled) {\n\t\tfx_sd_enable = (val & DP83822_RX_ER_STR_MASK) >> DP83822_RX_ER_SHIFT;\n\t\tif (fx_sd_enable == DP83822_STRAP_MODE3 ||\n\t\t    fx_sd_enable == DP83822_STRAP_MODE4)\n\t\t\tdp83822->fx_sd_enable = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int dp83822_probe(struct phy_device *phydev)\n{\n\tstruct dp83822_private *dp83822;\n\tint ret;\n\n\tdp83822 = devm_kzalloc(&phydev->mdio.dev, sizeof(*dp83822),\n\t\t\t       GFP_KERNEL);\n\tif (!dp83822)\n\t\treturn -ENOMEM;\n\n\tphydev->priv = dp83822;\n\n\tret = dp83822_read_straps(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tdp83822_of_init(phydev);\n\n\tif (dp83822->fx_enabled)\n\t\tphydev->port = PORT_FIBRE;\n\n\treturn 0;\n}\n\nstatic int dp83822_suspend(struct phy_device *phydev)\n{\n\tint value;\n\n\tvalue = phy_read_mmd(phydev, DP83822_DEVADDR, MII_DP83822_WOL_CFG);\n\n\tif (!(value & DP83822_WOL_EN))\n\t\tgenphy_suspend(phydev);\n\n\treturn 0;\n}\n\nstatic int dp83822_resume(struct phy_device *phydev)\n{\n\tint value;\n\n\tgenphy_resume(phydev);\n\n\tvalue = phy_read_mmd(phydev, DP83822_DEVADDR, MII_DP83822_WOL_CFG);\n\n\tphy_write_mmd(phydev, DP83822_DEVADDR, MII_DP83822_WOL_CFG, value |\n\t\t      DP83822_WOL_CLR_INDICATION);\n\n\treturn 0;\n}\n\n#define DP83822_PHY_DRIVER(_id, _name)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\tPHY_ID_MATCH_MODEL(_id),\t\t\t\\\n\t\t.name\t\t= (_name),\t\t\t\\\n\t\t \t\t\t\\\n\t\t.probe          = dp83822_probe,\t\t\\\n\t\t.soft_reset\t= dp83822_phy_reset,\t\t\\\n\t\t.config_init\t= dp83822_config_init,\t\t\\\n\t\t.read_status\t= dp83822_read_status,\t\t\\\n\t\t.get_wol = dp83822_get_wol,\t\t\t\\\n\t\t.set_wol = dp83822_set_wol,\t\t\t\\\n\t\t.config_intr = dp83822_config_intr,\t\t\\\n\t\t.handle_interrupt = dp83822_handle_interrupt,\t\\\n\t\t.suspend = dp83822_suspend,\t\t\t\\\n\t\t.resume = dp83822_resume,\t\t\t\\\n\t}\n\n#define DP8382X_PHY_DRIVER(_id, _name)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\\\n\t\tPHY_ID_MATCH_MODEL(_id),\t\t\t\\\n\t\t.name\t\t= (_name),\t\t\t\\\n\t\t \t\t\t\\\n\t\t.soft_reset\t= dp83822_phy_reset,\t\t\\\n\t\t.config_init\t= dp8382x_config_init,\t\t\\\n\t\t.get_wol = dp83822_get_wol,\t\t\t\\\n\t\t.set_wol = dp83822_set_wol,\t\t\t\\\n\t\t.config_intr = dp83822_config_intr,\t\t\\\n\t\t.handle_interrupt = dp83822_handle_interrupt,\t\\\n\t\t.suspend = dp83822_suspend,\t\t\t\\\n\t\t.resume = dp83822_resume,\t\t\t\\\n\t}\n\nstatic struct phy_driver dp83822_driver[] = {\n\tDP83822_PHY_DRIVER(DP83822_PHY_ID, \"TI DP83822\"),\n\tDP8382X_PHY_DRIVER(DP83825I_PHY_ID, \"TI DP83825I\"),\n\tDP8382X_PHY_DRIVER(DP83826C_PHY_ID, \"TI DP83826C\"),\n\tDP8382X_PHY_DRIVER(DP83826NC_PHY_ID, \"TI DP83826NC\"),\n\tDP8382X_PHY_DRIVER(DP83825S_PHY_ID, \"TI DP83825S\"),\n\tDP8382X_PHY_DRIVER(DP83825CM_PHY_ID, \"TI DP83825M\"),\n\tDP8382X_PHY_DRIVER(DP83825CS_PHY_ID, \"TI DP83825CS\"),\n};\nmodule_phy_driver(dp83822_driver);\n\nstatic struct mdio_device_id __maybe_unused dp83822_tbl[] = {\n\t{ DP83822_PHY_ID, 0xfffffff0 },\n\t{ DP83825I_PHY_ID, 0xfffffff0 },\n\t{ DP83826C_PHY_ID, 0xfffffff0 },\n\t{ DP83826NC_PHY_ID, 0xfffffff0 },\n\t{ DP83825S_PHY_ID, 0xfffffff0 },\n\t{ DP83825CM_PHY_ID, 0xfffffff0 },\n\t{ DP83825CS_PHY_ID, 0xfffffff0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(mdio, dp83822_tbl);\n\nMODULE_DESCRIPTION(\"Texas Instruments DP83822 PHY driver\");\nMODULE_AUTHOR(\"Dan Murphy <dmurphy@ti.com\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}