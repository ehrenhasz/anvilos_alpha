{
  "module_name": "mdio_device.c",
  "hash_id": "6dba529c2e773c73bf8f9da9589d1827ffa130295f08971a063fcb002fdc4915",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/mdio_device.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mdio.h>\n#include <linux/mii.h>\n#include <linux/module.h>\n#include <linux/phy.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/unistd.h>\n#include <linux/property.h>\n\nvoid mdio_device_free(struct mdio_device *mdiodev)\n{\n\tput_device(&mdiodev->dev);\n}\nEXPORT_SYMBOL(mdio_device_free);\n\nstatic void mdio_device_release(struct device *dev)\n{\n\tfwnode_handle_put(dev->fwnode);\n\tkfree(to_mdio_device(dev));\n}\n\nint mdio_device_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct mdio_device *mdiodev = to_mdio_device(dev);\n\tstruct mdio_driver *mdiodrv = to_mdio_driver(drv);\n\n\tif (mdiodrv->mdiodrv.flags & MDIO_DEVICE_IS_PHY)\n\t\treturn 0;\n\n\treturn strcmp(mdiodev->modalias, drv->name) == 0;\n}\n\nstruct mdio_device *mdio_device_create(struct mii_bus *bus, int addr)\n{\n\tstruct mdio_device *mdiodev;\n\n\t \n\tmdiodev = kzalloc(sizeof(*mdiodev), GFP_KERNEL);\n\tif (!mdiodev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmdiodev->dev.release = mdio_device_release;\n\tmdiodev->dev.parent = &bus->dev;\n\tmdiodev->dev.bus = &mdio_bus_type;\n\tmdiodev->device_free = mdio_device_free;\n\tmdiodev->device_remove = mdio_device_remove;\n\tmdiodev->bus = bus;\n\tmdiodev->addr = addr;\n\n\tdev_set_name(&mdiodev->dev, PHY_ID_FMT, bus->id, addr);\n\n\tdevice_initialize(&mdiodev->dev);\n\n\treturn mdiodev;\n}\nEXPORT_SYMBOL(mdio_device_create);\n\n \nint mdio_device_register(struct mdio_device *mdiodev)\n{\n\tint err;\n\n\tdev_dbg(&mdiodev->dev, \"%s\\n\", __func__);\n\n\terr = mdiobus_register_device(mdiodev);\n\tif (err)\n\t\treturn err;\n\n\terr = device_add(&mdiodev->dev);\n\tif (err) {\n\t\tpr_err(\"MDIO %d failed to add\\n\", mdiodev->addr);\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\n out:\n\tmdiobus_unregister_device(mdiodev);\n\treturn err;\n}\nEXPORT_SYMBOL(mdio_device_register);\n\n \nvoid mdio_device_remove(struct mdio_device *mdiodev)\n{\n\tdevice_del(&mdiodev->dev);\n\tmdiobus_unregister_device(mdiodev);\n}\nEXPORT_SYMBOL(mdio_device_remove);\n\nvoid mdio_device_reset(struct mdio_device *mdiodev, int value)\n{\n\tunsigned int d;\n\n\tif (!mdiodev->reset_gpio && !mdiodev->reset_ctrl)\n\t\treturn;\n\n\tif (mdiodev->reset_gpio)\n\t\tgpiod_set_value_cansleep(mdiodev->reset_gpio, value);\n\n\tif (mdiodev->reset_ctrl) {\n\t\tif (value)\n\t\t\treset_control_assert(mdiodev->reset_ctrl);\n\t\telse\n\t\t\treset_control_deassert(mdiodev->reset_ctrl);\n\t}\n\n\td = value ? mdiodev->reset_assert_delay : mdiodev->reset_deassert_delay;\n\tif (d)\n\t\tfsleep(d);\n}\nEXPORT_SYMBOL(mdio_device_reset);\n\n \nstatic int mdio_probe(struct device *dev)\n{\n\tstruct mdio_device *mdiodev = to_mdio_device(dev);\n\tstruct device_driver *drv = mdiodev->dev.driver;\n\tstruct mdio_driver *mdiodrv = to_mdio_driver(drv);\n\tint err = 0;\n\n\t \n\tmdio_device_reset(mdiodev, 0);\n\n\tif (mdiodrv->probe) {\n\t\terr = mdiodrv->probe(mdiodev);\n\t\tif (err) {\n\t\t\t \n\t\t\tmdio_device_reset(mdiodev, 1);\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic int mdio_remove(struct device *dev)\n{\n\tstruct mdio_device *mdiodev = to_mdio_device(dev);\n\tstruct device_driver *drv = mdiodev->dev.driver;\n\tstruct mdio_driver *mdiodrv = to_mdio_driver(drv);\n\n\tif (mdiodrv->remove)\n\t\tmdiodrv->remove(mdiodev);\n\n\t \n\tmdio_device_reset(mdiodev, 1);\n\n\treturn 0;\n}\n\nstatic void mdio_shutdown(struct device *dev)\n{\n\tstruct mdio_device *mdiodev = to_mdio_device(dev);\n\tstruct device_driver *drv = mdiodev->dev.driver;\n\tstruct mdio_driver *mdiodrv = to_mdio_driver(drv);\n\n\tif (mdiodrv->shutdown)\n\t\tmdiodrv->shutdown(mdiodev);\n}\n\n \nint mdio_driver_register(struct mdio_driver *drv)\n{\n\tstruct mdio_driver_common *mdiodrv = &drv->mdiodrv;\n\tint retval;\n\n\tpr_debug(\"%s: %s\\n\", __func__, mdiodrv->driver.name);\n\n\tmdiodrv->driver.bus = &mdio_bus_type;\n\tmdiodrv->driver.probe = mdio_probe;\n\tmdiodrv->driver.remove = mdio_remove;\n\tmdiodrv->driver.shutdown = mdio_shutdown;\n\n\tretval = driver_register(&mdiodrv->driver);\n\tif (retval) {\n\t\tpr_err(\"%s: Error %d in registering driver\\n\",\n\t\t       mdiodrv->driver.name, retval);\n\n\t\treturn retval;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mdio_driver_register);\n\nvoid mdio_driver_unregister(struct mdio_driver *drv)\n{\n\tstruct mdio_driver_common *mdiodrv = &drv->mdiodrv;\n\n\tdriver_unregister(&mdiodrv->driver);\n}\nEXPORT_SYMBOL(mdio_driver_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}