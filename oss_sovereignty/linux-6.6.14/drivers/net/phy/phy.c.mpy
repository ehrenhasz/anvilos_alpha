{
  "module_name": "phy.c",
  "hash_id": "b4ee3d2499036d51b98c7b84a33f5ecbd5e9c116516ce2133ee894b569622447",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/phy.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/unistd.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/netlink.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/ethtool_netlink.h>\n#include <linux/phy.h>\n#include <linux/phy_led_triggers.h>\n#include <linux/sfp.h>\n#include <linux/workqueue.h>\n#include <linux/mdio.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/atomic.h>\n#include <linux/suspend.h>\n#include <net/netlink.h>\n#include <net/genetlink.h>\n#include <net/sock.h>\n\n#define PHY_STATE_TIME\tHZ\n\n#define PHY_STATE_STR(_state)\t\t\t\\\n\tcase PHY_##_state:\t\t\t\\\n\t\treturn __stringify(_state);\t\\\n\nstatic const char *phy_state_to_str(enum phy_state st)\n{\n\tswitch (st) {\n\tPHY_STATE_STR(DOWN)\n\tPHY_STATE_STR(READY)\n\tPHY_STATE_STR(UP)\n\tPHY_STATE_STR(RUNNING)\n\tPHY_STATE_STR(NOLINK)\n\tPHY_STATE_STR(CABLETEST)\n\tPHY_STATE_STR(HALTED)\n\tPHY_STATE_STR(ERROR)\n\t}\n\n\treturn NULL;\n}\n\nstatic void phy_process_state_change(struct phy_device *phydev,\n\t\t\t\t     enum phy_state old_state)\n{\n\tif (old_state != phydev->state) {\n\t\tphydev_dbg(phydev, \"PHY state change %s -> %s\\n\",\n\t\t\t   phy_state_to_str(old_state),\n\t\t\t   phy_state_to_str(phydev->state));\n\t\tif (phydev->drv && phydev->drv->link_change_notify)\n\t\t\tphydev->drv->link_change_notify(phydev);\n\t}\n}\n\nstatic void phy_link_up(struct phy_device *phydev)\n{\n\tphydev->phy_link_change(phydev, true);\n\tphy_led_trigger_change_speed(phydev);\n}\n\nstatic void phy_link_down(struct phy_device *phydev)\n{\n\tphydev->phy_link_change(phydev, false);\n\tphy_led_trigger_change_speed(phydev);\n\tWRITE_ONCE(phydev->link_down_events, phydev->link_down_events + 1);\n}\n\nstatic const char *phy_pause_str(struct phy_device *phydev)\n{\n\tbool local_pause, local_asym_pause;\n\n\tif (phydev->autoneg == AUTONEG_DISABLE)\n\t\tgoto no_pause;\n\n\tlocal_pause = linkmode_test_bit(ETHTOOL_LINK_MODE_Pause_BIT,\n\t\t\t\t\tphydev->advertising);\n\tlocal_asym_pause = linkmode_test_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT,\n\t\t\t\t\t     phydev->advertising);\n\n\tif (local_pause && phydev->pause)\n\t\treturn \"rx/tx\";\n\n\tif (local_asym_pause && phydev->asym_pause) {\n\t\tif (local_pause)\n\t\t\treturn \"rx\";\n\t\tif (phydev->pause)\n\t\t\treturn \"tx\";\n\t}\n\nno_pause:\n\treturn \"off\";\n}\n\n \nvoid phy_print_status(struct phy_device *phydev)\n{\n\tif (phydev->link) {\n\t\tnetdev_info(phydev->attached_dev,\n\t\t\t\"Link is Up - %s/%s %s- flow control %s\\n\",\n\t\t\tphy_speed_to_str(phydev->speed),\n\t\t\tphy_duplex_to_str(phydev->duplex),\n\t\t\tphydev->downshifted_rate ? \"(downshifted) \" : \"\",\n\t\t\tphy_pause_str(phydev));\n\t} else\t{\n\t\tnetdev_info(phydev->attached_dev, \"Link is Down\\n\");\n\t}\n}\nEXPORT_SYMBOL(phy_print_status);\n\n \nint phy_get_rate_matching(struct phy_device *phydev,\n\t\t\t  phy_interface_t iface)\n{\n\tint ret = RATE_MATCH_NONE;\n\n\tif (phydev->drv->get_rate_matching) {\n\t\tmutex_lock(&phydev->lock);\n\t\tret = phydev->drv->get_rate_matching(phydev, iface);\n\t\tmutex_unlock(&phydev->lock);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phy_get_rate_matching);\n\n \nstatic int phy_config_interrupt(struct phy_device *phydev, bool interrupts)\n{\n\tphydev->interrupts = interrupts ? 1 : 0;\n\tif (phydev->drv->config_intr)\n\t\treturn phydev->drv->config_intr(phydev);\n\n\treturn 0;\n}\n\n \nint phy_restart_aneg(struct phy_device *phydev)\n{\n\tint ret;\n\n\tif (phydev->is_c45 && !(phydev->c45_ids.devices_in_package & BIT(0)))\n\t\tret = genphy_c45_restart_aneg(phydev);\n\telse\n\t\tret = genphy_restart_aneg(phydev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phy_restart_aneg);\n\n \nint phy_aneg_done(struct phy_device *phydev)\n{\n\tif (phydev->drv && phydev->drv->aneg_done)\n\t\treturn phydev->drv->aneg_done(phydev);\n\telse if (phydev->is_c45)\n\t\treturn genphy_c45_aneg_done(phydev);\n\telse\n\t\treturn genphy_aneg_done(phydev);\n}\nEXPORT_SYMBOL(phy_aneg_done);\n\n \nstatic const struct phy_setting *\nphy_find_valid(int speed, int duplex, unsigned long *supported)\n{\n\treturn phy_lookup_setting(speed, duplex, supported, false);\n}\n\n \nunsigned int phy_supported_speeds(struct phy_device *phy,\n\t\t\t\t  unsigned int *speeds,\n\t\t\t\t  unsigned int size)\n{\n\treturn phy_speeds(speeds, size, phy->supported);\n}\n\n \nbool phy_check_valid(int speed, int duplex, unsigned long *features)\n{\n\treturn !!phy_lookup_setting(speed, duplex, features, true);\n}\nEXPORT_SYMBOL(phy_check_valid);\n\n \nstatic void phy_sanitize_settings(struct phy_device *phydev)\n{\n\tconst struct phy_setting *setting;\n\n\tsetting = phy_find_valid(phydev->speed, phydev->duplex,\n\t\t\t\t phydev->supported);\n\tif (setting) {\n\t\tphydev->speed = setting->speed;\n\t\tphydev->duplex = setting->duplex;\n\t} else {\n\t\t \n\t\tphydev->speed = SPEED_UNKNOWN;\n\t\tphydev->duplex = DUPLEX_UNKNOWN;\n\t}\n}\n\nvoid phy_ethtool_ksettings_get(struct phy_device *phydev,\n\t\t\t       struct ethtool_link_ksettings *cmd)\n{\n\tmutex_lock(&phydev->lock);\n\tlinkmode_copy(cmd->link_modes.supported, phydev->supported);\n\tlinkmode_copy(cmd->link_modes.advertising, phydev->advertising);\n\tlinkmode_copy(cmd->link_modes.lp_advertising, phydev->lp_advertising);\n\n\tcmd->base.speed = phydev->speed;\n\tcmd->base.duplex = phydev->duplex;\n\tcmd->base.master_slave_cfg = phydev->master_slave_get;\n\tcmd->base.master_slave_state = phydev->master_slave_state;\n\tcmd->base.rate_matching = phydev->rate_matching;\n\tif (phydev->interface == PHY_INTERFACE_MODE_MOCA)\n\t\tcmd->base.port = PORT_BNC;\n\telse\n\t\tcmd->base.port = phydev->port;\n\tcmd->base.transceiver = phy_is_internal(phydev) ?\n\t\t\t\tXCVR_INTERNAL : XCVR_EXTERNAL;\n\tcmd->base.phy_address = phydev->mdio.addr;\n\tcmd->base.autoneg = phydev->autoneg;\n\tcmd->base.eth_tp_mdix_ctrl = phydev->mdix_ctrl;\n\tcmd->base.eth_tp_mdix = phydev->mdix;\n\tmutex_unlock(&phydev->lock);\n}\nEXPORT_SYMBOL(phy_ethtool_ksettings_get);\n\n \nint phy_mii_ioctl(struct phy_device *phydev, struct ifreq *ifr, int cmd)\n{\n\tstruct mii_ioctl_data *mii_data = if_mii(ifr);\n\tu16 val = mii_data->val_in;\n\tbool change_autoneg = false;\n\tint prtad, devad;\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tmii_data->phy_id = phydev->mdio.addr;\n\t\tfallthrough;\n\n\tcase SIOCGMIIREG:\n\t\tif (mdio_phy_id_is_c45(mii_data->phy_id)) {\n\t\t\tprtad = mdio_phy_id_prtad(mii_data->phy_id);\n\t\t\tdevad = mdio_phy_id_devad(mii_data->phy_id);\n\t\t\tmii_data->val_out = mdiobus_c45_read(\n\t\t\t\tphydev->mdio.bus, prtad, devad,\n\t\t\t\tmii_data->reg_num);\n\t\t} else {\n\t\t\tmii_data->val_out = mdiobus_read(\n\t\t\t\tphydev->mdio.bus, mii_data->phy_id,\n\t\t\t\tmii_data->reg_num);\n\t\t}\n\t\treturn 0;\n\n\tcase SIOCSMIIREG:\n\t\tif (mdio_phy_id_is_c45(mii_data->phy_id)) {\n\t\t\tprtad = mdio_phy_id_prtad(mii_data->phy_id);\n\t\t\tdevad = mdio_phy_id_devad(mii_data->phy_id);\n\t\t} else {\n\t\t\tprtad = mii_data->phy_id;\n\t\t\tdevad = mii_data->reg_num;\n\t\t}\n\t\tif (prtad == phydev->mdio.addr) {\n\t\t\tswitch (devad) {\n\t\t\tcase MII_BMCR:\n\t\t\t\tif ((val & (BMCR_RESET | BMCR_ANENABLE)) == 0) {\n\t\t\t\t\tif (phydev->autoneg == AUTONEG_ENABLE)\n\t\t\t\t\t\tchange_autoneg = true;\n\t\t\t\t\tphydev->autoneg = AUTONEG_DISABLE;\n\t\t\t\t\tif (val & BMCR_FULLDPLX)\n\t\t\t\t\t\tphydev->duplex = DUPLEX_FULL;\n\t\t\t\t\telse\n\t\t\t\t\t\tphydev->duplex = DUPLEX_HALF;\n\t\t\t\t\tif (val & BMCR_SPEED1000)\n\t\t\t\t\t\tphydev->speed = SPEED_1000;\n\t\t\t\t\telse if (val & BMCR_SPEED100)\n\t\t\t\t\t\tphydev->speed = SPEED_100;\n\t\t\t\t\telse phydev->speed = SPEED_10;\n\t\t\t\t} else {\n\t\t\t\t\tif (phydev->autoneg == AUTONEG_DISABLE)\n\t\t\t\t\t\tchange_autoneg = true;\n\t\t\t\t\tphydev->autoneg = AUTONEG_ENABLE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MII_ADVERTISE:\n\t\t\t\tmii_adv_mod_linkmode_adv_t(phydev->advertising,\n\t\t\t\t\t\t\t   val);\n\t\t\t\tchange_autoneg = true;\n\t\t\t\tbreak;\n\t\t\tcase MII_CTRL1000:\n\t\t\t\tmii_ctrl1000_mod_linkmode_adv_t(phydev->advertising,\n\t\t\t\t\t\t\t        val);\n\t\t\t\tchange_autoneg = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (mdio_phy_id_is_c45(mii_data->phy_id))\n\t\t\tmdiobus_c45_write(phydev->mdio.bus, prtad, devad,\n\t\t\t\t\t  mii_data->reg_num, val);\n\t\telse\n\t\t\tmdiobus_write(phydev->mdio.bus, prtad, devad, val);\n\n\t\tif (prtad == phydev->mdio.addr &&\n\t\t    devad == MII_BMCR &&\n\t\t    val & BMCR_RESET)\n\t\t\treturn phy_init_hw(phydev);\n\n\t\tif (change_autoneg)\n\t\t\treturn phy_start_aneg(phydev);\n\n\t\treturn 0;\n\n\tcase SIOCSHWTSTAMP:\n\t\tif (phydev->mii_ts && phydev->mii_ts->hwtstamp)\n\t\t\treturn phydev->mii_ts->hwtstamp(phydev->mii_ts, ifr);\n\t\tfallthrough;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\nEXPORT_SYMBOL(phy_mii_ioctl);\n\n \nint phy_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tif (!dev->phydev)\n\t\treturn -ENODEV;\n\n\treturn phy_mii_ioctl(dev->phydev, ifr, cmd);\n}\nEXPORT_SYMBOL(phy_do_ioctl);\n\n \nint phy_do_ioctl_running(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tif (!netif_running(dev))\n\t\treturn -ENODEV;\n\n\treturn phy_do_ioctl(dev, ifr, cmd);\n}\nEXPORT_SYMBOL(phy_do_ioctl_running);\n\n \nint __phy_hwtstamp_get(struct phy_device *phydev,\n\t\t       struct kernel_hwtstamp_config *config)\n{\n\tif (!phydev)\n\t\treturn -ENODEV;\n\n\treturn phy_mii_ioctl(phydev, config->ifr, SIOCGHWTSTAMP);\n}\n\n \nint __phy_hwtstamp_set(struct phy_device *phydev,\n\t\t       struct kernel_hwtstamp_config *config,\n\t\t       struct netlink_ext_ack *extack)\n{\n\tif (!phydev)\n\t\treturn -ENODEV;\n\n\treturn phy_mii_ioctl(phydev, config->ifr, SIOCSHWTSTAMP);\n}\n\n \nvoid phy_queue_state_machine(struct phy_device *phydev, unsigned long jiffies)\n{\n\tmod_delayed_work(system_power_efficient_wq, &phydev->state_queue,\n\t\t\t jiffies);\n}\nEXPORT_SYMBOL(phy_queue_state_machine);\n\n \nvoid phy_trigger_machine(struct phy_device *phydev)\n{\n\tphy_queue_state_machine(phydev, 0);\n}\nEXPORT_SYMBOL(phy_trigger_machine);\n\nstatic void phy_abort_cable_test(struct phy_device *phydev)\n{\n\tint err;\n\n\tethnl_cable_test_finished(phydev);\n\n\terr = phy_init_hw(phydev);\n\tif (err)\n\t\tphydev_err(phydev, \"Error while aborting cable test\");\n}\n\n \nint phy_ethtool_get_strings(struct phy_device *phydev, u8 *data)\n{\n\tif (!phydev->drv)\n\t\treturn -EIO;\n\n\tmutex_lock(&phydev->lock);\n\tphydev->drv->get_strings(phydev, data);\n\tmutex_unlock(&phydev->lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(phy_ethtool_get_strings);\n\n \nint phy_ethtool_get_sset_count(struct phy_device *phydev)\n{\n\tint ret;\n\n\tif (!phydev->drv)\n\t\treturn -EIO;\n\n\tif (phydev->drv->get_sset_count &&\n\t    phydev->drv->get_strings &&\n\t    phydev->drv->get_stats) {\n\t\tmutex_lock(&phydev->lock);\n\t\tret = phydev->drv->get_sset_count(phydev);\n\t\tmutex_unlock(&phydev->lock);\n\n\t\treturn ret;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\nEXPORT_SYMBOL(phy_ethtool_get_sset_count);\n\n \nint phy_ethtool_get_stats(struct phy_device *phydev,\n\t\t\t  struct ethtool_stats *stats, u64 *data)\n{\n\tif (!phydev->drv)\n\t\treturn -EIO;\n\n\tmutex_lock(&phydev->lock);\n\tphydev->drv->get_stats(phydev, stats, data);\n\tmutex_unlock(&phydev->lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(phy_ethtool_get_stats);\n\n \nint phy_ethtool_get_plca_cfg(struct phy_device *phydev,\n\t\t\t     struct phy_plca_cfg *plca_cfg)\n{\n\tint ret;\n\n\tif (!phydev->drv) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (!phydev->drv->get_plca_cfg) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&phydev->lock);\n\tret = phydev->drv->get_plca_cfg(phydev, plca_cfg);\n\n\tmutex_unlock(&phydev->lock);\nout:\n\treturn ret;\n}\n\n \nstatic int plca_check_valid(struct phy_device *phydev,\n\t\t\t    const struct phy_plca_cfg *plca_cfg,\n\t\t\t    struct netlink_ext_ack *extack)\n{\n\tint ret = 0;\n\n\tif (!linkmode_test_bit(ETHTOOL_LINK_MODE_10baseT1S_P2MP_Half_BIT,\n\t\t\t       phydev->advertising)) {\n\t\tret = -EOPNOTSUPP;\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"Point to Multi-Point mode is not enabled\");\n\t} else if (plca_cfg->node_id >= 255) {\n\t\tNL_SET_ERR_MSG(extack, \"PLCA node ID is not set\");\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n \nint phy_ethtool_set_plca_cfg(struct phy_device *phydev,\n\t\t\t     const struct phy_plca_cfg *plca_cfg,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct phy_plca_cfg *curr_plca_cfg;\n\tint ret;\n\n\tif (!phydev->drv) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (!phydev->drv->set_plca_cfg ||\n\t    !phydev->drv->get_plca_cfg) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tcurr_plca_cfg = kmalloc(sizeof(*curr_plca_cfg), GFP_KERNEL);\n\tif (!curr_plca_cfg) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&phydev->lock);\n\n\tret = phydev->drv->get_plca_cfg(phydev, curr_plca_cfg);\n\tif (ret)\n\t\tgoto out_drv;\n\n\tif (curr_plca_cfg->enabled < 0 && plca_cfg->enabled >= 0) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"PHY does not support changing the PLCA 'enable' attribute\");\n\t\tret = -EINVAL;\n\t\tgoto out_drv;\n\t}\n\n\tif (curr_plca_cfg->node_id < 0 && plca_cfg->node_id >= 0) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"PHY does not support changing the PLCA 'local node ID' attribute\");\n\t\tret = -EINVAL;\n\t\tgoto out_drv;\n\t}\n\n\tif (curr_plca_cfg->node_cnt < 0 && plca_cfg->node_cnt >= 0) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"PHY does not support changing the PLCA 'node count' attribute\");\n\t\tret = -EINVAL;\n\t\tgoto out_drv;\n\t}\n\n\tif (curr_plca_cfg->to_tmr < 0 && plca_cfg->to_tmr >= 0) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"PHY does not support changing the PLCA 'TO timer' attribute\");\n\t\tret = -EINVAL;\n\t\tgoto out_drv;\n\t}\n\n\tif (curr_plca_cfg->burst_cnt < 0 && plca_cfg->burst_cnt >= 0) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"PHY does not support changing the PLCA 'burst count' attribute\");\n\t\tret = -EINVAL;\n\t\tgoto out_drv;\n\t}\n\n\tif (curr_plca_cfg->burst_tmr < 0 && plca_cfg->burst_tmr >= 0) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"PHY does not support changing the PLCA 'burst timer' attribute\");\n\t\tret = -EINVAL;\n\t\tgoto out_drv;\n\t}\n\n\t \n\tif (plca_cfg->enabled > 0) {\n\t\t \n\t\tif (plca_cfg->node_id >= 0)\n\t\t\tcurr_plca_cfg->node_id = plca_cfg->node_id;\n\n\t\tret = plca_check_valid(phydev, curr_plca_cfg, extack);\n\t\tif (ret)\n\t\t\tgoto out_drv;\n\t}\n\n\tret = phydev->drv->set_plca_cfg(phydev, plca_cfg);\n\nout_drv:\n\tkfree(curr_plca_cfg);\n\tmutex_unlock(&phydev->lock);\nout:\n\treturn ret;\n}\n\n \nint phy_ethtool_get_plca_status(struct phy_device *phydev,\n\t\t\t\tstruct phy_plca_status *plca_st)\n{\n\tint ret;\n\n\tif (!phydev->drv) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (!phydev->drv->get_plca_status) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&phydev->lock);\n\tret = phydev->drv->get_plca_status(phydev, plca_st);\n\n\tmutex_unlock(&phydev->lock);\nout:\n\treturn ret;\n}\n\n \nint phy_start_cable_test(struct phy_device *phydev,\n\t\t\t struct netlink_ext_ack *extack)\n{\n\tstruct net_device *dev = phydev->attached_dev;\n\tint err = -ENOMEM;\n\n\tif (!(phydev->drv &&\n\t      phydev->drv->cable_test_start &&\n\t      phydev->drv->cable_test_get_status)) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"PHY driver does not support cable testing\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmutex_lock(&phydev->lock);\n\tif (phydev->state == PHY_CABLETEST) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"PHY already performing a test\");\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (phydev->state < PHY_UP ||\n\t    phydev->state > PHY_CABLETEST) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"PHY not configured. Try setting interface up\");\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\terr = ethnl_cable_test_alloc(phydev, ETHTOOL_MSG_CABLE_TEST_NTF);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tphy_link_down(phydev);\n\n\tnetif_testing_on(dev);\n\terr = phydev->drv->cable_test_start(phydev);\n\tif (err) {\n\t\tnetif_testing_off(dev);\n\t\tphy_link_up(phydev);\n\t\tgoto out_free;\n\t}\n\n\tphydev->state = PHY_CABLETEST;\n\n\tif (phy_polling_mode(phydev))\n\t\tphy_trigger_machine(phydev);\n\n\tmutex_unlock(&phydev->lock);\n\n\treturn 0;\n\nout_free:\n\tethnl_cable_test_free(phydev);\nout:\n\tmutex_unlock(&phydev->lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL(phy_start_cable_test);\n\n \nint phy_start_cable_test_tdr(struct phy_device *phydev,\n\t\t\t     struct netlink_ext_ack *extack,\n\t\t\t     const struct phy_tdr_config *config)\n{\n\tstruct net_device *dev = phydev->attached_dev;\n\tint err = -ENOMEM;\n\n\tif (!(phydev->drv &&\n\t      phydev->drv->cable_test_tdr_start &&\n\t      phydev->drv->cable_test_get_status)) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"PHY driver does not support cable test TDR\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmutex_lock(&phydev->lock);\n\tif (phydev->state == PHY_CABLETEST) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"PHY already performing a test\");\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (phydev->state < PHY_UP ||\n\t    phydev->state > PHY_CABLETEST) {\n\t\tNL_SET_ERR_MSG(extack,\n\t\t\t       \"PHY not configured. Try setting interface up\");\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\terr = ethnl_cable_test_alloc(phydev, ETHTOOL_MSG_CABLE_TEST_TDR_NTF);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tphy_link_down(phydev);\n\n\tnetif_testing_on(dev);\n\terr = phydev->drv->cable_test_tdr_start(phydev, config);\n\tif (err) {\n\t\tnetif_testing_off(dev);\n\t\tphy_link_up(phydev);\n\t\tgoto out_free;\n\t}\n\n\tphydev->state = PHY_CABLETEST;\n\n\tif (phy_polling_mode(phydev))\n\t\tphy_trigger_machine(phydev);\n\n\tmutex_unlock(&phydev->lock);\n\n\treturn 0;\n\nout_free:\n\tethnl_cable_test_free(phydev);\nout:\n\tmutex_unlock(&phydev->lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL(phy_start_cable_test_tdr);\n\nint phy_config_aneg(struct phy_device *phydev)\n{\n\tif (phydev->drv->config_aneg)\n\t\treturn phydev->drv->config_aneg(phydev);\n\n\t \n\tif (phydev->is_c45 && !(phydev->c45_ids.devices_in_package & BIT(0)))\n\t\treturn genphy_c45_config_aneg(phydev);\n\n\treturn genphy_config_aneg(phydev);\n}\nEXPORT_SYMBOL(phy_config_aneg);\n\n \nstatic int phy_check_link_status(struct phy_device *phydev)\n{\n\tint err;\n\n\tlockdep_assert_held(&phydev->lock);\n\n\t \n\tif (phydev->loopback_enabled)\n\t\treturn 0;\n\n\terr = phy_read_status(phydev);\n\tif (err)\n\t\treturn err;\n\n\tif (phydev->link && phydev->state != PHY_RUNNING) {\n\t\tphy_check_downshift(phydev);\n\t\tphydev->state = PHY_RUNNING;\n\t\tphy_link_up(phydev);\n\t} else if (!phydev->link && phydev->state != PHY_NOLINK) {\n\t\tphydev->state = PHY_NOLINK;\n\t\tphy_link_down(phydev);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int _phy_start_aneg(struct phy_device *phydev)\n{\n\tint err;\n\n\tlockdep_assert_held(&phydev->lock);\n\n\tif (!phydev->drv)\n\t\treturn -EIO;\n\n\tif (AUTONEG_DISABLE == phydev->autoneg)\n\t\tphy_sanitize_settings(phydev);\n\n\terr = phy_config_aneg(phydev);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (phy_is_started(phydev))\n\t\terr = phy_check_link_status(phydev);\n\n\treturn err;\n}\n\n \nint phy_start_aneg(struct phy_device *phydev)\n{\n\tint err;\n\n\tmutex_lock(&phydev->lock);\n\terr = _phy_start_aneg(phydev);\n\tmutex_unlock(&phydev->lock);\n\n\treturn err;\n}\nEXPORT_SYMBOL(phy_start_aneg);\n\nstatic int phy_poll_aneg_done(struct phy_device *phydev)\n{\n\tunsigned int retries = 100;\n\tint ret;\n\n\tdo {\n\t\tmsleep(100);\n\t\tret = phy_aneg_done(phydev);\n\t} while (!ret && --retries);\n\n\tif (!ret)\n\t\treturn -ETIMEDOUT;\n\n\treturn ret < 0 ? ret : 0;\n}\n\nint phy_ethtool_ksettings_set(struct phy_device *phydev,\n\t\t\t      const struct ethtool_link_ksettings *cmd)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(advertising);\n\tu8 autoneg = cmd->base.autoneg;\n\tu8 duplex = cmd->base.duplex;\n\tu32 speed = cmd->base.speed;\n\n\tif (cmd->base.phy_address != phydev->mdio.addr)\n\t\treturn -EINVAL;\n\n\tlinkmode_copy(advertising, cmd->link_modes.advertising);\n\n\t \n\tlinkmode_and(advertising, advertising, phydev->supported);\n\n\t \n\tif (autoneg != AUTONEG_ENABLE && autoneg != AUTONEG_DISABLE)\n\t\treturn -EINVAL;\n\n\tif (autoneg == AUTONEG_ENABLE && linkmode_empty(advertising))\n\t\treturn -EINVAL;\n\n\tif (autoneg == AUTONEG_DISABLE &&\n\t    ((speed != SPEED_1000 &&\n\t      speed != SPEED_100 &&\n\t      speed != SPEED_10) ||\n\t     (duplex != DUPLEX_HALF &&\n\t      duplex != DUPLEX_FULL)))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&phydev->lock);\n\tphydev->autoneg = autoneg;\n\n\tif (autoneg == AUTONEG_DISABLE) {\n\t\tphydev->speed = speed;\n\t\tphydev->duplex = duplex;\n\t}\n\n\tlinkmode_copy(phydev->advertising, advertising);\n\n\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_Autoneg_BIT,\n\t\t\t phydev->advertising, autoneg == AUTONEG_ENABLE);\n\n\tphydev->master_slave_set = cmd->base.master_slave_cfg;\n\tphydev->mdix_ctrl = cmd->base.eth_tp_mdix_ctrl;\n\n\t \n\tif (phy_is_started(phydev)) {\n\t\tphydev->state = PHY_UP;\n\t\tphy_trigger_machine(phydev);\n\t} else {\n\t\t_phy_start_aneg(phydev);\n\t}\n\n\tmutex_unlock(&phydev->lock);\n\treturn 0;\n}\nEXPORT_SYMBOL(phy_ethtool_ksettings_set);\n\n \nint phy_speed_down(struct phy_device *phydev, bool sync)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(adv_tmp);\n\tint ret = 0;\n\n\tmutex_lock(&phydev->lock);\n\n\tif (phydev->autoneg != AUTONEG_ENABLE)\n\t\tgoto out;\n\n\tlinkmode_copy(adv_tmp, phydev->advertising);\n\n\tret = phy_speed_down_core(phydev);\n\tif (ret)\n\t\tgoto out;\n\n\tlinkmode_copy(phydev->adv_old, adv_tmp);\n\n\tif (linkmode_equal(phydev->advertising, adv_tmp)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = phy_config_aneg(phydev);\n\tif (ret)\n\t\tgoto out;\n\n\tret = sync ? phy_poll_aneg_done(phydev) : 0;\nout:\n\tmutex_unlock(&phydev->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phy_speed_down);\n\n \nint phy_speed_up(struct phy_device *phydev)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(adv_tmp);\n\tint ret = 0;\n\n\tmutex_lock(&phydev->lock);\n\n\tif (phydev->autoneg != AUTONEG_ENABLE)\n\t\tgoto out;\n\n\tif (linkmode_empty(phydev->adv_old))\n\t\tgoto out;\n\n\tlinkmode_copy(adv_tmp, phydev->advertising);\n\tlinkmode_copy(phydev->advertising, phydev->adv_old);\n\tlinkmode_zero(phydev->adv_old);\n\n\tif (linkmode_equal(phydev->advertising, adv_tmp))\n\t\tgoto out;\n\n\tret = phy_config_aneg(phydev);\nout:\n\tmutex_unlock(&phydev->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(phy_speed_up);\n\n \nvoid phy_start_machine(struct phy_device *phydev)\n{\n\tphy_trigger_machine(phydev);\n}\nEXPORT_SYMBOL_GPL(phy_start_machine);\n\n \nvoid phy_stop_machine(struct phy_device *phydev)\n{\n\tcancel_delayed_work_sync(&phydev->state_queue);\n\n\tmutex_lock(&phydev->lock);\n\tif (phy_is_started(phydev))\n\t\tphydev->state = PHY_UP;\n\tmutex_unlock(&phydev->lock);\n}\n\nstatic void phy_process_error(struct phy_device *phydev)\n{\n\t \n\tif (!mutex_is_locked(&phydev->lock))\n\t\tphydev_err(phydev, \"PHY-device data unsafe context\\n\");\n\n\tphydev->state = PHY_ERROR;\n\n\tphy_trigger_machine(phydev);\n}\n\nstatic void phy_error_precise(struct phy_device *phydev,\n\t\t\t      const void *func, int err)\n{\n\tWARN(1, \"%pS: returned: %d\\n\", func, err);\n\tmutex_lock(&phydev->lock);\n\tphy_process_error(phydev);\n\tmutex_unlock(&phydev->lock);\n}\n\n \nvoid phy_error(struct phy_device *phydev)\n{\n\tWARN_ON(1);\n\tphy_process_error(phydev);\n}\nEXPORT_SYMBOL(phy_error);\n\n \nint phy_disable_interrupts(struct phy_device *phydev)\n{\n\t \n\treturn phy_config_interrupt(phydev, PHY_INTERRUPT_DISABLED);\n}\n\n \nstatic irqreturn_t phy_interrupt(int irq, void *phy_dat)\n{\n\tstruct phy_device *phydev = phy_dat;\n\tstruct phy_driver *drv = phydev->drv;\n\tirqreturn_t ret;\n\n\t \n\tif (IS_ENABLED(CONFIG_PM_SLEEP) && phydev->irq_suspended) {\n\t\tstruct net_device *netdev = phydev->attached_dev;\n\n\t\tif (netdev) {\n\t\t\tstruct device *parent = netdev->dev.parent;\n\n\t\t\tif (netdev->wol_enabled)\n\t\t\t\tpm_system_wakeup();\n\t\t\telse if (device_may_wakeup(&netdev->dev))\n\t\t\t\tpm_wakeup_dev_event(&netdev->dev, 0, true);\n\t\t\telse if (parent && device_may_wakeup(parent))\n\t\t\t\tpm_wakeup_dev_event(parent, 0, true);\n\t\t}\n\n\t\tphydev->irq_rerun = 1;\n\t\tdisable_irq_nosync(irq);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tmutex_lock(&phydev->lock);\n\tret = drv->handle_interrupt(phydev);\n\tmutex_unlock(&phydev->lock);\n\n\treturn ret;\n}\n\n \nstatic int phy_enable_interrupts(struct phy_device *phydev)\n{\n\treturn phy_config_interrupt(phydev, PHY_INTERRUPT_ENABLED);\n}\n\n \nvoid phy_request_interrupt(struct phy_device *phydev)\n{\n\tint err;\n\n\terr = request_threaded_irq(phydev->irq, NULL, phy_interrupt,\n\t\t\t\t   IRQF_ONESHOT | IRQF_SHARED,\n\t\t\t\t   phydev_name(phydev), phydev);\n\tif (err) {\n\t\tphydev_warn(phydev, \"Error %d requesting IRQ %d, falling back to polling\\n\",\n\t\t\t    err, phydev->irq);\n\t\tphydev->irq = PHY_POLL;\n\t} else {\n\t\tif (phy_enable_interrupts(phydev)) {\n\t\t\tphydev_warn(phydev, \"Can't enable interrupt, falling back to polling\\n\");\n\t\t\tphy_free_interrupt(phydev);\n\t\t\tphydev->irq = PHY_POLL;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(phy_request_interrupt);\n\n \nvoid phy_free_interrupt(struct phy_device *phydev)\n{\n\tphy_disable_interrupts(phydev);\n\tfree_irq(phydev->irq, phydev);\n}\nEXPORT_SYMBOL(phy_free_interrupt);\n\n \nvoid phy_stop(struct phy_device *phydev)\n{\n\tstruct net_device *dev = phydev->attached_dev;\n\tenum phy_state old_state;\n\n\tif (!phy_is_started(phydev) && phydev->state != PHY_DOWN &&\n\t    phydev->state != PHY_ERROR) {\n\t\tWARN(1, \"called from state %s\\n\",\n\t\t     phy_state_to_str(phydev->state));\n\t\treturn;\n\t}\n\n\tmutex_lock(&phydev->lock);\n\told_state = phydev->state;\n\n\tif (phydev->state == PHY_CABLETEST) {\n\t\tphy_abort_cable_test(phydev);\n\t\tnetif_testing_off(dev);\n\t}\n\n\tif (phydev->sfp_bus)\n\t\tsfp_upstream_stop(phydev->sfp_bus);\n\n\tphydev->state = PHY_HALTED;\n\tphy_process_state_change(phydev, old_state);\n\n\tmutex_unlock(&phydev->lock);\n\n\tphy_state_machine(&phydev->state_queue.work);\n\tphy_stop_machine(phydev);\n\n\t \n}\nEXPORT_SYMBOL(phy_stop);\n\n \nvoid phy_start(struct phy_device *phydev)\n{\n\tmutex_lock(&phydev->lock);\n\n\tif (phydev->state != PHY_READY && phydev->state != PHY_HALTED) {\n\t\tWARN(1, \"called from state %s\\n\",\n\t\t     phy_state_to_str(phydev->state));\n\t\tgoto out;\n\t}\n\n\tif (phydev->sfp_bus)\n\t\tsfp_upstream_start(phydev->sfp_bus);\n\n\t \n\t__phy_resume(phydev);\n\n\tphydev->state = PHY_UP;\n\n\tphy_start_machine(phydev);\nout:\n\tmutex_unlock(&phydev->lock);\n}\nEXPORT_SYMBOL(phy_start);\n\n \nvoid phy_state_machine(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct phy_device *phydev =\n\t\t\tcontainer_of(dwork, struct phy_device, state_queue);\n\tstruct net_device *dev = phydev->attached_dev;\n\tbool needs_aneg = false, do_suspend = false;\n\tenum phy_state old_state;\n\tconst void *func = NULL;\n\tbool finished = false;\n\tint err = 0;\n\n\tmutex_lock(&phydev->lock);\n\n\told_state = phydev->state;\n\n\tswitch (phydev->state) {\n\tcase PHY_DOWN:\n\tcase PHY_READY:\n\t\tbreak;\n\tcase PHY_UP:\n\t\tneeds_aneg = true;\n\n\t\tbreak;\n\tcase PHY_NOLINK:\n\tcase PHY_RUNNING:\n\t\terr = phy_check_link_status(phydev);\n\t\tfunc = &phy_check_link_status;\n\t\tbreak;\n\tcase PHY_CABLETEST:\n\t\terr = phydev->drv->cable_test_get_status(phydev, &finished);\n\t\tif (err) {\n\t\t\tphy_abort_cable_test(phydev);\n\t\t\tnetif_testing_off(dev);\n\t\t\tneeds_aneg = true;\n\t\t\tphydev->state = PHY_UP;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (finished) {\n\t\t\tethnl_cable_test_finished(phydev);\n\t\t\tnetif_testing_off(dev);\n\t\t\tneeds_aneg = true;\n\t\t\tphydev->state = PHY_UP;\n\t\t}\n\t\tbreak;\n\tcase PHY_HALTED:\n\tcase PHY_ERROR:\n\t\tif (phydev->link) {\n\t\t\tphydev->link = 0;\n\t\t\tphy_link_down(phydev);\n\t\t}\n\t\tdo_suspend = true;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&phydev->lock);\n\n\tif (needs_aneg) {\n\t\terr = phy_start_aneg(phydev);\n\t\tfunc = &phy_start_aneg;\n\t} else if (do_suspend) {\n\t\tphy_suspend(phydev);\n\t}\n\n\tif (err == -ENODEV)\n\t\treturn;\n\n\tif (err < 0)\n\t\tphy_error_precise(phydev, func, err);\n\n\tphy_process_state_change(phydev, old_state);\n\n\t \n\tmutex_lock(&phydev->lock);\n\tif (phy_polling_mode(phydev) && phy_is_started(phydev))\n\t\tphy_queue_state_machine(phydev, PHY_STATE_TIME);\n\tmutex_unlock(&phydev->lock);\n}\n\n \nvoid phy_mac_interrupt(struct phy_device *phydev)\n{\n\t \n\tphy_trigger_machine(phydev);\n}\nEXPORT_SYMBOL(phy_mac_interrupt);\n\n \nint phy_init_eee(struct phy_device *phydev, bool clk_stop_enable)\n{\n\tint ret;\n\n\tif (!phydev->drv)\n\t\treturn -EIO;\n\n\tret = genphy_c45_eee_is_active(phydev, NULL, NULL, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!ret)\n\t\treturn -EPROTONOSUPPORT;\n\n\tif (clk_stop_enable)\n\t\t \n\t\tret = phy_set_bits_mmd(phydev, MDIO_MMD_PCS, MDIO_CTRL1,\n\t\t\t\t       MDIO_PCS_CTRL1_CLKSTOP_EN);\n\n\treturn ret < 0 ? ret : 0;\n}\nEXPORT_SYMBOL(phy_init_eee);\n\n \nint phy_get_eee_err(struct phy_device *phydev)\n{\n\tint ret;\n\n\tif (!phydev->drv)\n\t\treturn -EIO;\n\n\tmutex_lock(&phydev->lock);\n\tret = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_PCS_EEE_WK_ERR);\n\tmutex_unlock(&phydev->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(phy_get_eee_err);\n\n \nint phy_ethtool_get_eee(struct phy_device *phydev, struct ethtool_eee *data)\n{\n\tint ret;\n\n\tif (!phydev->drv)\n\t\treturn -EIO;\n\n\tmutex_lock(&phydev->lock);\n\tret = genphy_c45_ethtool_get_eee(phydev, data);\n\tmutex_unlock(&phydev->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(phy_ethtool_get_eee);\n\n \nint phy_ethtool_set_eee(struct phy_device *phydev, struct ethtool_eee *data)\n{\n\tint ret;\n\n\tif (!phydev->drv)\n\t\treturn -EIO;\n\n\tmutex_lock(&phydev->lock);\n\tret = genphy_c45_ethtool_set_eee(phydev, data);\n\tmutex_unlock(&phydev->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(phy_ethtool_set_eee);\n\n \nint phy_ethtool_set_wol(struct phy_device *phydev, struct ethtool_wolinfo *wol)\n{\n\tint ret;\n\n\tif (phydev->drv && phydev->drv->set_wol) {\n\t\tmutex_lock(&phydev->lock);\n\t\tret = phydev->drv->set_wol(phydev, wol);\n\t\tmutex_unlock(&phydev->lock);\n\n\t\treturn ret;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\nEXPORT_SYMBOL(phy_ethtool_set_wol);\n\n \nvoid phy_ethtool_get_wol(struct phy_device *phydev, struct ethtool_wolinfo *wol)\n{\n\tif (phydev->drv && phydev->drv->get_wol) {\n\t\tmutex_lock(&phydev->lock);\n\t\tphydev->drv->get_wol(phydev, wol);\n\t\tmutex_unlock(&phydev->lock);\n\t}\n}\nEXPORT_SYMBOL(phy_ethtool_get_wol);\n\nint phy_ethtool_get_link_ksettings(struct net_device *ndev,\n\t\t\t\t   struct ethtool_link_ksettings *cmd)\n{\n\tstruct phy_device *phydev = ndev->phydev;\n\n\tif (!phydev)\n\t\treturn -ENODEV;\n\n\tphy_ethtool_ksettings_get(phydev, cmd);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(phy_ethtool_get_link_ksettings);\n\nint phy_ethtool_set_link_ksettings(struct net_device *ndev,\n\t\t\t\t   const struct ethtool_link_ksettings *cmd)\n{\n\tstruct phy_device *phydev = ndev->phydev;\n\n\tif (!phydev)\n\t\treturn -ENODEV;\n\n\treturn phy_ethtool_ksettings_set(phydev, cmd);\n}\nEXPORT_SYMBOL(phy_ethtool_set_link_ksettings);\n\n \nint phy_ethtool_nway_reset(struct net_device *ndev)\n{\n\tstruct phy_device *phydev = ndev->phydev;\n\tint ret;\n\n\tif (!phydev)\n\t\treturn -ENODEV;\n\n\tif (!phydev->drv)\n\t\treturn -EIO;\n\n\tmutex_lock(&phydev->lock);\n\tret = phy_restart_aneg(phydev);\n\tmutex_unlock(&phydev->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(phy_ethtool_nway_reset);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}