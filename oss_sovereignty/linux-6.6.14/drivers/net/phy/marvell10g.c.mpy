{
  "module_name": "marvell10g.c",
  "hash_id": "d0331f7dcd9f7422a78c3dbab202e9b0956ce06f75f047586099c797f0b17ea1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/marvell10g.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/ctype.h>\n#include <linux/delay.h>\n#include <linux/hwmon.h>\n#include <linux/marvell_phy.h>\n#include <linux/phy.h>\n#include <linux/sfp.h>\n#include <linux/netdevice.h>\n\n#define MV_PHY_ALASKA_NBT_QUIRK_MASK\t0xfffffffe\n#define MV_PHY_ALASKA_NBT_QUIRK_REV\t(MARVELL_PHY_ID_88X3310 | 0xa)\n\n#define MV_VERSION(a,b,c,d) ((a) << 24 | (b) << 16 | (c) << 8 | (d))\n\nenum {\n\tMV_PMA_FW_VER0\t\t= 0xc011,\n\tMV_PMA_FW_VER1\t\t= 0xc012,\n\tMV_PMA_21X0_PORT_CTRL\t= 0xc04a,\n\tMV_PMA_21X0_PORT_CTRL_SWRST\t\t\t\t= BIT(15),\n\tMV_PMA_21X0_PORT_CTRL_MACTYPE_MASK\t\t\t= 0x7,\n\tMV_PMA_21X0_PORT_CTRL_MACTYPE_USXGMII\t\t\t= 0x0,\n\tMV_PMA_2180_PORT_CTRL_MACTYPE_DXGMII\t\t\t= 0x1,\n\tMV_PMA_2180_PORT_CTRL_MACTYPE_QXGMII\t\t\t= 0x2,\n\tMV_PMA_21X0_PORT_CTRL_MACTYPE_5GBASER\t\t\t= 0x4,\n\tMV_PMA_21X0_PORT_CTRL_MACTYPE_5GBASER_NO_SGMII_AN\t= 0x5,\n\tMV_PMA_21X0_PORT_CTRL_MACTYPE_10GBASER_RATE_MATCH\t= 0x6,\n\tMV_PMA_BOOT\t\t= 0xc050,\n\tMV_PMA_BOOT_FATAL\t= BIT(0),\n\n\tMV_PCS_BASE_T\t\t= 0x0000,\n\tMV_PCS_BASE_R\t\t= 0x1000,\n\tMV_PCS_1000BASEX\t= 0x2000,\n\n\tMV_PCS_CSCR1\t\t= 0x8000,\n\tMV_PCS_CSCR1_ED_MASK\t= 0x0300,\n\tMV_PCS_CSCR1_ED_OFF\t= 0x0000,\n\tMV_PCS_CSCR1_ED_RX\t= 0x0200,\n\tMV_PCS_CSCR1_ED_NLP\t= 0x0300,\n\tMV_PCS_CSCR1_MDIX_MASK\t= 0x0060,\n\tMV_PCS_CSCR1_MDIX_MDI\t= 0x0000,\n\tMV_PCS_CSCR1_MDIX_MDIX\t= 0x0020,\n\tMV_PCS_CSCR1_MDIX_AUTO\t= 0x0060,\n\n\tMV_PCS_DSC1\t\t= 0x8003,\n\tMV_PCS_DSC1_ENABLE\t= BIT(9),\n\tMV_PCS_DSC1_10GBT\t= 0x01c0,\n\tMV_PCS_DSC1_1GBR\t= 0x0038,\n\tMV_PCS_DSC1_100BTX\t= 0x0007,\n\tMV_PCS_DSC2\t\t= 0x8004,\n\tMV_PCS_DSC2_2P5G\t= 0xf000,\n\tMV_PCS_DSC2_5G\t\t= 0x0f00,\n\n\tMV_PCS_CSSR1\t\t= 0x8008,\n\tMV_PCS_CSSR1_SPD1_MASK\t= 0xc000,\n\tMV_PCS_CSSR1_SPD1_SPD2\t= 0xc000,\n\tMV_PCS_CSSR1_SPD1_1000\t= 0x8000,\n\tMV_PCS_CSSR1_SPD1_100\t= 0x4000,\n\tMV_PCS_CSSR1_SPD1_10\t= 0x0000,\n\tMV_PCS_CSSR1_DUPLEX_FULL= BIT(13),\n\tMV_PCS_CSSR1_RESOLVED\t= BIT(11),\n\tMV_PCS_CSSR1_MDIX\t= BIT(6),\n\tMV_PCS_CSSR1_SPD2_MASK\t= 0x000c,\n\tMV_PCS_CSSR1_SPD2_5000\t= 0x0008,\n\tMV_PCS_CSSR1_SPD2_2500\t= 0x0004,\n\tMV_PCS_CSSR1_SPD2_10000\t= 0x0000,\n\n\t \n\tMV_PCS_TEMP\t\t= 0x8042,\n\n\t \n\tMV_PCS_PORT_INFO\t= 0xd00d,\n\tMV_PCS_PORT_INFO_NPORTS_MASK\t= 0x0380,\n\tMV_PCS_PORT_INFO_NPORTS_SHIFT\t= 7,\n\n\t \n\tMV_AN_21X0_SERDES_CTRL2\t= 0x800f,\n\tMV_AN_21X0_SERDES_CTRL2_AUTO_INIT_DIS\t= BIT(13),\n\tMV_AN_21X0_SERDES_CTRL2_RUN_INIT\t= BIT(15),\n\n\t \n\tMV_AN_CTRL1000\t\t= 0x8000,  \n\tMV_AN_STAT1000\t\t= 0x8001,  \n\n\t \n\tMV_V2_PORT_CTRL\t\t= 0xf001,\n\tMV_V2_PORT_CTRL_PWRDOWN\t\t\t\t\t= BIT(11),\n\tMV_V2_33X0_PORT_CTRL_SWRST\t\t\t\t= BIT(15),\n\tMV_V2_33X0_PORT_CTRL_MACTYPE_MASK\t\t\t= 0x7,\n\tMV_V2_33X0_PORT_CTRL_MACTYPE_RXAUI\t\t\t= 0x0,\n\tMV_V2_3310_PORT_CTRL_MACTYPE_XAUI_RATE_MATCH\t\t= 0x1,\n\tMV_V2_3340_PORT_CTRL_MACTYPE_RXAUI_NO_SGMII_AN\t\t= 0x1,\n\tMV_V2_33X0_PORT_CTRL_MACTYPE_RXAUI_RATE_MATCH\t\t= 0x2,\n\tMV_V2_3310_PORT_CTRL_MACTYPE_XAUI\t\t\t= 0x3,\n\tMV_V2_33X0_PORT_CTRL_MACTYPE_10GBASER\t\t\t= 0x4,\n\tMV_V2_33X0_PORT_CTRL_MACTYPE_10GBASER_NO_SGMII_AN\t= 0x5,\n\tMV_V2_33X0_PORT_CTRL_MACTYPE_10GBASER_RATE_MATCH\t= 0x6,\n\tMV_V2_33X0_PORT_CTRL_MACTYPE_USXGMII\t\t\t= 0x7,\n\tMV_V2_PORT_INTR_STS\t\t= 0xf040,\n\tMV_V2_PORT_INTR_MASK\t\t= 0xf043,\n\tMV_V2_PORT_INTR_STS_WOL_EN\t= BIT(8),\n\tMV_V2_MAGIC_PKT_WORD0\t\t= 0xf06b,\n\tMV_V2_MAGIC_PKT_WORD1\t\t= 0xf06c,\n\tMV_V2_MAGIC_PKT_WORD2\t\t= 0xf06d,\n\t \n\tMV_V2_WOL_CTRL\t\t\t= 0xf06e,\n\tMV_V2_WOL_CTRL_CLEAR_STS\t= BIT(15),\n\tMV_V2_WOL_CTRL_MAGIC_PKT_EN\t= BIT(0),\n\t \n\tMV_V2_TEMP_CTRL\t\t= 0xf08a,\n\tMV_V2_TEMP_CTRL_MASK\t= 0xc000,\n\tMV_V2_TEMP_CTRL_SAMPLE\t= 0x0000,\n\tMV_V2_TEMP_CTRL_DISABLE\t= 0xc000,\n\tMV_V2_TEMP\t\t= 0xf08c,\n\tMV_V2_TEMP_UNKNOWN\t= 0x9600,  \n};\n\nstruct mv3310_chip {\n\tbool (*has_downshift)(struct phy_device *phydev);\n\tvoid (*init_supported_interfaces)(unsigned long *mask);\n\tint (*get_mactype)(struct phy_device *phydev);\n\tint (*set_mactype)(struct phy_device *phydev, int mactype);\n\tint (*select_mactype)(unsigned long *interfaces);\n\tint (*init_interface)(struct phy_device *phydev, int mactype);\n\n#ifdef CONFIG_HWMON\n\tint (*hwmon_read_temp_reg)(struct phy_device *phydev);\n#endif\n};\n\nstruct mv3310_priv {\n\tDECLARE_BITMAP(supported_interfaces, PHY_INTERFACE_MODE_MAX);\n\n\tu32 firmware_ver;\n\tbool has_downshift;\n\tbool rate_match;\n\tphy_interface_t const_interface;\n\n\tstruct device *hwmon_dev;\n\tchar *hwmon_name;\n};\n\nstatic const struct mv3310_chip *to_mv3310_chip(struct phy_device *phydev)\n{\n\treturn phydev->drv->driver_data;\n}\n\n#ifdef CONFIG_HWMON\nstatic umode_t mv3310_hwmon_is_visible(const void *data,\n\t\t\t\t       enum hwmon_sensor_types type,\n\t\t\t\t       u32 attr, int channel)\n{\n\tif (type == hwmon_chip && attr == hwmon_chip_update_interval)\n\t\treturn 0444;\n\tif (type == hwmon_temp && attr == hwmon_temp_input)\n\t\treturn 0444;\n\treturn 0;\n}\n\nstatic int mv3310_hwmon_read_temp_reg(struct phy_device *phydev)\n{\n\treturn phy_read_mmd(phydev, MDIO_MMD_VEND2, MV_V2_TEMP);\n}\n\nstatic int mv2110_hwmon_read_temp_reg(struct phy_device *phydev)\n{\n\treturn phy_read_mmd(phydev, MDIO_MMD_PCS, MV_PCS_TEMP);\n}\n\nstatic int mv3310_hwmon_read(struct device *dev, enum hwmon_sensor_types type,\n\t\t\t     u32 attr, int channel, long *value)\n{\n\tstruct phy_device *phydev = dev_get_drvdata(dev);\n\tconst struct mv3310_chip *chip = to_mv3310_chip(phydev);\n\tint temp;\n\n\tif (type == hwmon_chip && attr == hwmon_chip_update_interval) {\n\t\t*value = MSEC_PER_SEC;\n\t\treturn 0;\n\t}\n\n\tif (type == hwmon_temp && attr == hwmon_temp_input) {\n\t\ttemp = chip->hwmon_read_temp_reg(phydev);\n\t\tif (temp < 0)\n\t\t\treturn temp;\n\n\t\t*value = ((temp & 0xff) - 75) * 1000;\n\n\t\treturn 0;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic const struct hwmon_ops mv3310_hwmon_ops = {\n\t.is_visible = mv3310_hwmon_is_visible,\n\t.read = mv3310_hwmon_read,\n};\n\nstatic u32 mv3310_hwmon_chip_config[] = {\n\tHWMON_C_REGISTER_TZ | HWMON_C_UPDATE_INTERVAL,\n\t0,\n};\n\nstatic const struct hwmon_channel_info mv3310_hwmon_chip = {\n\t.type = hwmon_chip,\n\t.config = mv3310_hwmon_chip_config,\n};\n\nstatic u32 mv3310_hwmon_temp_config[] = {\n\tHWMON_T_INPUT,\n\t0,\n};\n\nstatic const struct hwmon_channel_info mv3310_hwmon_temp = {\n\t.type = hwmon_temp,\n\t.config = mv3310_hwmon_temp_config,\n};\n\nstatic const struct hwmon_channel_info * const mv3310_hwmon_info[] = {\n\t&mv3310_hwmon_chip,\n\t&mv3310_hwmon_temp,\n\tNULL,\n};\n\nstatic const struct hwmon_chip_info mv3310_hwmon_chip_info = {\n\t.ops = &mv3310_hwmon_ops,\n\t.info = mv3310_hwmon_info,\n};\n\nstatic int mv3310_hwmon_config(struct phy_device *phydev, bool enable)\n{\n\tu16 val;\n\tint ret;\n\n\tif (phydev->drv->phy_id != MARVELL_PHY_ID_88X3310)\n\t\treturn 0;\n\n\tret = phy_write_mmd(phydev, MDIO_MMD_VEND2, MV_V2_TEMP,\n\t\t\t    MV_V2_TEMP_UNKNOWN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval = enable ? MV_V2_TEMP_CTRL_SAMPLE : MV_V2_TEMP_CTRL_DISABLE;\n\n\treturn phy_modify_mmd(phydev, MDIO_MMD_VEND2, MV_V2_TEMP_CTRL,\n\t\t\t      MV_V2_TEMP_CTRL_MASK, val);\n}\n\nstatic int mv3310_hwmon_probe(struct phy_device *phydev)\n{\n\tstruct device *dev = &phydev->mdio.dev;\n\tstruct mv3310_priv *priv = dev_get_drvdata(&phydev->mdio.dev);\n\tint i, j, ret;\n\n\tpriv->hwmon_name = devm_kstrdup(dev, dev_name(dev), GFP_KERNEL);\n\tif (!priv->hwmon_name)\n\t\treturn -ENODEV;\n\n\tfor (i = j = 0; priv->hwmon_name[i]; i++) {\n\t\tif (isalnum(priv->hwmon_name[i])) {\n\t\t\tif (i != j)\n\t\t\t\tpriv->hwmon_name[j] = priv->hwmon_name[i];\n\t\t\tj++;\n\t\t}\n\t}\n\tpriv->hwmon_name[j] = '\\0';\n\n\tret = mv3310_hwmon_config(phydev, true);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->hwmon_dev = devm_hwmon_device_register_with_info(dev,\n\t\t\t\tpriv->hwmon_name, phydev,\n\t\t\t\t&mv3310_hwmon_chip_info, NULL);\n\n\treturn PTR_ERR_OR_ZERO(priv->hwmon_dev);\n}\n#else\nstatic inline int mv3310_hwmon_config(struct phy_device *phydev, bool enable)\n{\n\treturn 0;\n}\n\nstatic int mv3310_hwmon_probe(struct phy_device *phydev)\n{\n\treturn 0;\n}\n#endif\n\nstatic int mv3310_power_down(struct phy_device *phydev)\n{\n\treturn phy_set_bits_mmd(phydev, MDIO_MMD_VEND2, MV_V2_PORT_CTRL,\n\t\t\t\tMV_V2_PORT_CTRL_PWRDOWN);\n}\n\nstatic int mv3310_power_up(struct phy_device *phydev)\n{\n\tstruct mv3310_priv *priv = dev_get_drvdata(&phydev->mdio.dev);\n\tint ret;\n\n\tret = phy_clear_bits_mmd(phydev, MDIO_MMD_VEND2, MV_V2_PORT_CTRL,\n\t\t\t\t MV_V2_PORT_CTRL_PWRDOWN);\n\n\t \n\tudelay(100);\n\n\tif (phydev->drv->phy_id != MARVELL_PHY_ID_88X3310 ||\n\t    priv->firmware_ver < 0x00030000)\n\t\treturn ret;\n\n\treturn phy_set_bits_mmd(phydev, MDIO_MMD_VEND2, MV_V2_PORT_CTRL,\n\t\t\t\tMV_V2_33X0_PORT_CTRL_SWRST);\n}\n\nstatic int mv3310_reset(struct phy_device *phydev, u32 unit)\n{\n\tint val, err;\n\n\terr = phy_modify_mmd(phydev, MDIO_MMD_PCS, unit + MDIO_CTRL1,\n\t\t\t     MDIO_CTRL1_RESET, MDIO_CTRL1_RESET);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn phy_read_mmd_poll_timeout(phydev, MDIO_MMD_PCS,\n\t\t\t\t\t unit + MDIO_CTRL1, val,\n\t\t\t\t\t !(val & MDIO_CTRL1_RESET),\n\t\t\t\t\t 5000, 100000, true);\n}\n\nstatic int mv3310_get_downshift(struct phy_device *phydev, u8 *ds)\n{\n\tstruct mv3310_priv *priv = dev_get_drvdata(&phydev->mdio.dev);\n\tint val;\n\n\tif (!priv->has_downshift)\n\t\treturn -EOPNOTSUPP;\n\n\tval = phy_read_mmd(phydev, MDIO_MMD_PCS, MV_PCS_DSC1);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (val & MV_PCS_DSC1_ENABLE)\n\t\t \n\t\t*ds = 1 + FIELD_GET(MV_PCS_DSC1_10GBT, (u16)val);\n\telse\n\t\t*ds = DOWNSHIFT_DEV_DISABLE;\n\n\treturn 0;\n}\n\nstatic int mv3310_set_downshift(struct phy_device *phydev, u8 ds)\n{\n\tstruct mv3310_priv *priv = dev_get_drvdata(&phydev->mdio.dev);\n\tu16 val;\n\tint err;\n\n\tif (!priv->has_downshift)\n\t\treturn -EOPNOTSUPP;\n\n\tif (ds == DOWNSHIFT_DEV_DISABLE)\n\t\treturn phy_clear_bits_mmd(phydev, MDIO_MMD_PCS, MV_PCS_DSC1,\n\t\t\t\t\t  MV_PCS_DSC1_ENABLE);\n\n\t \n\tif (ds == DOWNSHIFT_DEV_DEFAULT_COUNT)\n\t\tds = 2;\n\n\tif (ds > 8)\n\t\treturn -E2BIG;\n\n\tds -= 1;\n\tval = FIELD_PREP(MV_PCS_DSC2_2P5G, ds);\n\tval |= FIELD_PREP(MV_PCS_DSC2_5G, ds);\n\terr = phy_modify_mmd(phydev, MDIO_MMD_PCS, MV_PCS_DSC2,\n\t\t\t     MV_PCS_DSC2_2P5G | MV_PCS_DSC2_5G, val);\n\tif (err < 0)\n\t\treturn err;\n\n\tval = MV_PCS_DSC1_ENABLE;\n\tval |= FIELD_PREP(MV_PCS_DSC1_10GBT, ds);\n\tval |= FIELD_PREP(MV_PCS_DSC1_1GBR, ds);\n\tval |= FIELD_PREP(MV_PCS_DSC1_100BTX, ds);\n\n\treturn phy_modify_mmd(phydev, MDIO_MMD_PCS, MV_PCS_DSC1,\n\t\t\t      MV_PCS_DSC1_ENABLE | MV_PCS_DSC1_10GBT |\n\t\t\t      MV_PCS_DSC1_1GBR | MV_PCS_DSC1_100BTX, val);\n}\n\nstatic int mv3310_get_edpd(struct phy_device *phydev, u16 *edpd)\n{\n\tint val;\n\n\tval = phy_read_mmd(phydev, MDIO_MMD_PCS, MV_PCS_CSCR1);\n\tif (val < 0)\n\t\treturn val;\n\n\tswitch (val & MV_PCS_CSCR1_ED_MASK) {\n\tcase MV_PCS_CSCR1_ED_NLP:\n\t\t*edpd = 1000;\n\t\tbreak;\n\tcase MV_PCS_CSCR1_ED_RX:\n\t\t*edpd = ETHTOOL_PHY_EDPD_NO_TX;\n\t\tbreak;\n\tdefault:\n\t\t*edpd = ETHTOOL_PHY_EDPD_DISABLE;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int mv3310_set_edpd(struct phy_device *phydev, u16 edpd)\n{\n\tu16 val;\n\tint err;\n\n\tswitch (edpd) {\n\tcase 1000:\n\tcase ETHTOOL_PHY_EDPD_DFLT_TX_MSECS:\n\t\tval = MV_PCS_CSCR1_ED_NLP;\n\t\tbreak;\n\n\tcase ETHTOOL_PHY_EDPD_NO_TX:\n\t\tval = MV_PCS_CSCR1_ED_RX;\n\t\tbreak;\n\n\tcase ETHTOOL_PHY_EDPD_DISABLE:\n\t\tval = MV_PCS_CSCR1_ED_OFF;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\terr = phy_modify_mmd_changed(phydev, MDIO_MMD_PCS, MV_PCS_CSCR1,\n\t\t\t\t     MV_PCS_CSCR1_ED_MASK, val);\n\tif (err > 0)\n\t\terr = mv3310_reset(phydev, MV_PCS_BASE_T);\n\n\treturn err;\n}\n\nstatic int mv3310_sfp_insert(void *upstream, const struct sfp_eeprom_id *id)\n{\n\tstruct phy_device *phydev = upstream;\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(support) = { 0, };\n\tDECLARE_PHY_INTERFACE_MASK(interfaces);\n\tphy_interface_t iface;\n\n\tsfp_parse_support(phydev->sfp_bus, id, support, interfaces);\n\tiface = sfp_select_interface(phydev->sfp_bus, support);\n\n\tif (iface != PHY_INTERFACE_MODE_10GBASER) {\n\t\tdev_err(&phydev->mdio.dev, \"incompatible SFP module inserted\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic const struct sfp_upstream_ops mv3310_sfp_ops = {\n\t.attach = phy_sfp_attach,\n\t.detach = phy_sfp_detach,\n\t.module_insert = mv3310_sfp_insert,\n};\n\nstatic int mv3310_probe(struct phy_device *phydev)\n{\n\tconst struct mv3310_chip *chip = to_mv3310_chip(phydev);\n\tstruct mv3310_priv *priv;\n\tu32 mmd_mask = MDIO_DEVS_PMAPMD | MDIO_DEVS_AN;\n\tint ret;\n\n\tif (!phydev->is_c45 ||\n\t    (phydev->c45_ids.devices_in_package & mmd_mask) != mmd_mask)\n\t\treturn -ENODEV;\n\n\tret = phy_read_mmd(phydev, MDIO_MMD_PMAPMD, MV_PMA_BOOT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & MV_PMA_BOOT_FATAL) {\n\t\tdev_warn(&phydev->mdio.dev,\n\t\t\t \"PHY failed to boot firmware, status=%04x\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = devm_kzalloc(&phydev->mdio.dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&phydev->mdio.dev, priv);\n\n\tret = phy_read_mmd(phydev, MDIO_MMD_PMAPMD, MV_PMA_FW_VER0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpriv->firmware_ver = ret << 16;\n\n\tret = phy_read_mmd(phydev, MDIO_MMD_PMAPMD, MV_PMA_FW_VER1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpriv->firmware_ver |= ret;\n\n\tphydev_info(phydev, \"Firmware version %u.%u.%u.%u\\n\",\n\t\t    priv->firmware_ver >> 24, (priv->firmware_ver >> 16) & 255,\n\t\t    (priv->firmware_ver >> 8) & 255, priv->firmware_ver & 255);\n\n\tif (chip->has_downshift)\n\t\tpriv->has_downshift = chip->has_downshift(phydev);\n\n\t \n\tret = mv3310_power_down(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mv3310_hwmon_probe(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tchip->init_supported_interfaces(priv->supported_interfaces);\n\n\treturn phy_sfp_probe(phydev, &mv3310_sfp_ops);\n}\n\nstatic void mv3310_remove(struct phy_device *phydev)\n{\n\tmv3310_hwmon_config(phydev, false);\n}\n\nstatic int mv3310_suspend(struct phy_device *phydev)\n{\n\treturn mv3310_power_down(phydev);\n}\n\nstatic int mv3310_resume(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = mv3310_power_up(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mv3310_hwmon_config(phydev, true);\n}\n\n \nstatic bool mv3310_has_pma_ngbaset_quirk(struct phy_device *phydev)\n{\n\tif (!(phydev->c45_ids.devices_in_package & MDIO_DEVS_PMAPMD))\n\t\treturn false;\n\n\t \n\treturn (phydev->c45_ids.device_ids[MDIO_MMD_PMAPMD] &\n\t\tMV_PHY_ALASKA_NBT_QUIRK_MASK) == MV_PHY_ALASKA_NBT_QUIRK_REV;\n}\n\nstatic int mv2110_get_mactype(struct phy_device *phydev)\n{\n\tint mactype;\n\n\tmactype = phy_read_mmd(phydev, MDIO_MMD_PMAPMD, MV_PMA_21X0_PORT_CTRL);\n\tif (mactype < 0)\n\t\treturn mactype;\n\n\treturn mactype & MV_PMA_21X0_PORT_CTRL_MACTYPE_MASK;\n}\n\nstatic int mv2110_set_mactype(struct phy_device *phydev, int mactype)\n{\n\tint err, val;\n\n\tmactype &= MV_PMA_21X0_PORT_CTRL_MACTYPE_MASK;\n\terr = phy_modify_mmd(phydev, MDIO_MMD_PMAPMD, MV_PMA_21X0_PORT_CTRL,\n\t\t\t     MV_PMA_21X0_PORT_CTRL_SWRST |\n\t\t\t     MV_PMA_21X0_PORT_CTRL_MACTYPE_MASK,\n\t\t\t     MV_PMA_21X0_PORT_CTRL_SWRST | mactype);\n\tif (err)\n\t\treturn err;\n\n\terr = phy_set_bits_mmd(phydev, MDIO_MMD_AN, MV_AN_21X0_SERDES_CTRL2,\n\t\t\t       MV_AN_21X0_SERDES_CTRL2_AUTO_INIT_DIS |\n\t\t\t       MV_AN_21X0_SERDES_CTRL2_RUN_INIT);\n\tif (err)\n\t\treturn err;\n\n\terr = phy_read_mmd_poll_timeout(phydev, MDIO_MMD_AN,\n\t\t\t\t\tMV_AN_21X0_SERDES_CTRL2, val,\n\t\t\t\t\t!(val &\n\t\t\t\t\t  MV_AN_21X0_SERDES_CTRL2_RUN_INIT),\n\t\t\t\t\t5000, 100000, true);\n\tif (err)\n\t\treturn err;\n\n\treturn phy_clear_bits_mmd(phydev, MDIO_MMD_AN, MV_AN_21X0_SERDES_CTRL2,\n\t\t\t\t  MV_AN_21X0_SERDES_CTRL2_AUTO_INIT_DIS);\n}\n\nstatic int mv2110_select_mactype(unsigned long *interfaces)\n{\n\tif (test_bit(PHY_INTERFACE_MODE_USXGMII, interfaces))\n\t\treturn MV_PMA_21X0_PORT_CTRL_MACTYPE_USXGMII;\n\telse if (test_bit(PHY_INTERFACE_MODE_SGMII, interfaces) &&\n\t\t !test_bit(PHY_INTERFACE_MODE_10GBASER, interfaces))\n\t\treturn MV_PMA_21X0_PORT_CTRL_MACTYPE_5GBASER;\n\telse if (test_bit(PHY_INTERFACE_MODE_10GBASER, interfaces))\n\t\treturn MV_PMA_21X0_PORT_CTRL_MACTYPE_10GBASER_RATE_MATCH;\n\telse\n\t\treturn -1;\n}\n\nstatic int mv3310_get_mactype(struct phy_device *phydev)\n{\n\tint mactype;\n\n\tmactype = phy_read_mmd(phydev, MDIO_MMD_VEND2, MV_V2_PORT_CTRL);\n\tif (mactype < 0)\n\t\treturn mactype;\n\n\treturn mactype & MV_V2_33X0_PORT_CTRL_MACTYPE_MASK;\n}\n\nstatic int mv3310_set_mactype(struct phy_device *phydev, int mactype)\n{\n\tint ret;\n\n\tmactype &= MV_V2_33X0_PORT_CTRL_MACTYPE_MASK;\n\tret = phy_modify_mmd_changed(phydev, MDIO_MMD_VEND2, MV_V2_PORT_CTRL,\n\t\t\t\t     MV_V2_33X0_PORT_CTRL_MACTYPE_MASK,\n\t\t\t\t     mactype);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\treturn phy_set_bits_mmd(phydev, MDIO_MMD_VEND2, MV_V2_PORT_CTRL,\n\t\t\t\tMV_V2_33X0_PORT_CTRL_SWRST);\n}\n\nstatic int mv3310_select_mactype(unsigned long *interfaces)\n{\n\tif (test_bit(PHY_INTERFACE_MODE_USXGMII, interfaces))\n\t\treturn MV_V2_33X0_PORT_CTRL_MACTYPE_USXGMII;\n\telse if (test_bit(PHY_INTERFACE_MODE_SGMII, interfaces) &&\n\t\t test_bit(PHY_INTERFACE_MODE_10GBASER, interfaces))\n\t\treturn MV_V2_33X0_PORT_CTRL_MACTYPE_10GBASER;\n\telse if (test_bit(PHY_INTERFACE_MODE_SGMII, interfaces) &&\n\t\t test_bit(PHY_INTERFACE_MODE_RXAUI, interfaces))\n\t\treturn MV_V2_33X0_PORT_CTRL_MACTYPE_RXAUI;\n\telse if (test_bit(PHY_INTERFACE_MODE_SGMII, interfaces) &&\n\t\t test_bit(PHY_INTERFACE_MODE_XAUI, interfaces))\n\t\treturn MV_V2_3310_PORT_CTRL_MACTYPE_XAUI;\n\telse if (test_bit(PHY_INTERFACE_MODE_10GBASER, interfaces))\n\t\treturn MV_V2_33X0_PORT_CTRL_MACTYPE_10GBASER_RATE_MATCH;\n\telse if (test_bit(PHY_INTERFACE_MODE_RXAUI, interfaces))\n\t\treturn MV_V2_33X0_PORT_CTRL_MACTYPE_RXAUI_RATE_MATCH;\n\telse if (test_bit(PHY_INTERFACE_MODE_XAUI, interfaces))\n\t\treturn MV_V2_3310_PORT_CTRL_MACTYPE_XAUI_RATE_MATCH;\n\telse if (test_bit(PHY_INTERFACE_MODE_SGMII, interfaces))\n\t\treturn MV_V2_33X0_PORT_CTRL_MACTYPE_10GBASER;\n\telse\n\t\treturn -1;\n}\n\nstatic int mv2110_init_interface(struct phy_device *phydev, int mactype)\n{\n\tstruct mv3310_priv *priv = dev_get_drvdata(&phydev->mdio.dev);\n\n\tpriv->rate_match = false;\n\n\tif (mactype == MV_PMA_21X0_PORT_CTRL_MACTYPE_10GBASER_RATE_MATCH)\n\t\tpriv->rate_match = true;\n\n\tif (mactype == MV_PMA_21X0_PORT_CTRL_MACTYPE_USXGMII)\n\t\tpriv->const_interface = PHY_INTERFACE_MODE_USXGMII;\n\telse if (mactype == MV_PMA_21X0_PORT_CTRL_MACTYPE_10GBASER_RATE_MATCH)\n\t\tpriv->const_interface = PHY_INTERFACE_MODE_10GBASER;\n\telse if (mactype == MV_PMA_21X0_PORT_CTRL_MACTYPE_5GBASER ||\n\t\t mactype == MV_PMA_21X0_PORT_CTRL_MACTYPE_5GBASER_NO_SGMII_AN)\n\t\tpriv->const_interface = PHY_INTERFACE_MODE_NA;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int mv3310_init_interface(struct phy_device *phydev, int mactype)\n{\n\tstruct mv3310_priv *priv = dev_get_drvdata(&phydev->mdio.dev);\n\n\tpriv->rate_match = false;\n\n\tif (mactype == MV_V2_33X0_PORT_CTRL_MACTYPE_10GBASER_RATE_MATCH ||\n\t    mactype == MV_V2_33X0_PORT_CTRL_MACTYPE_RXAUI_RATE_MATCH ||\n\t    mactype == MV_V2_3310_PORT_CTRL_MACTYPE_XAUI_RATE_MATCH)\n\t\tpriv->rate_match = true;\n\n\tif (mactype == MV_V2_33X0_PORT_CTRL_MACTYPE_USXGMII)\n\t\tpriv->const_interface = PHY_INTERFACE_MODE_USXGMII;\n\telse if (mactype == MV_V2_33X0_PORT_CTRL_MACTYPE_10GBASER_RATE_MATCH ||\n\t\t mactype == MV_V2_33X0_PORT_CTRL_MACTYPE_10GBASER_NO_SGMII_AN ||\n\t\t mactype == MV_V2_33X0_PORT_CTRL_MACTYPE_10GBASER)\n\t\tpriv->const_interface = PHY_INTERFACE_MODE_10GBASER;\n\telse if (mactype == MV_V2_33X0_PORT_CTRL_MACTYPE_RXAUI_RATE_MATCH ||\n\t\t mactype == MV_V2_33X0_PORT_CTRL_MACTYPE_RXAUI)\n\t\tpriv->const_interface = PHY_INTERFACE_MODE_RXAUI;\n\telse if (mactype == MV_V2_3310_PORT_CTRL_MACTYPE_XAUI_RATE_MATCH ||\n\t\t mactype == MV_V2_3310_PORT_CTRL_MACTYPE_XAUI)\n\t\tpriv->const_interface = PHY_INTERFACE_MODE_XAUI;\n\telse\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int mv3340_init_interface(struct phy_device *phydev, int mactype)\n{\n\tstruct mv3310_priv *priv = dev_get_drvdata(&phydev->mdio.dev);\n\tint err = 0;\n\n\tpriv->rate_match = false;\n\n\tif (mactype == MV_V2_3340_PORT_CTRL_MACTYPE_RXAUI_NO_SGMII_AN)\n\t\tpriv->const_interface = PHY_INTERFACE_MODE_RXAUI;\n\telse\n\t\terr = mv3310_init_interface(phydev, mactype);\n\n\treturn err;\n}\n\nstatic int mv3310_config_init(struct phy_device *phydev)\n{\n\tstruct mv3310_priv *priv = dev_get_drvdata(&phydev->mdio.dev);\n\tconst struct mv3310_chip *chip = to_mv3310_chip(phydev);\n\tint err, mactype;\n\n\t \n\tif (!test_bit(phydev->interface, priv->supported_interfaces))\n\t\treturn -ENODEV;\n\n\tphydev->mdix_ctrl = ETH_TP_MDI_AUTO;\n\n\t \n\terr = mv3310_power_up(phydev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!phy_interface_empty(phydev->host_interfaces)) {\n\t\tmactype = chip->select_mactype(phydev->host_interfaces);\n\t\tif (mactype >= 0) {\n\t\t\tphydev_info(phydev, \"Changing MACTYPE to %i\\n\",\n\t\t\t\t    mactype);\n\t\t\terr = chip->set_mactype(phydev, mactype);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tmactype = chip->get_mactype(phydev);\n\tif (mactype < 0)\n\t\treturn mactype;\n\n\terr = chip->init_interface(phydev, mactype);\n\tif (err) {\n\t\tphydev_err(phydev, \"MACTYPE configuration invalid\\n\");\n\t\treturn err;\n\t}\n\n\t \n\terr = mv3310_set_edpd(phydev, ETHTOOL_PHY_EDPD_DFLT_TX_MSECS);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = mv3310_set_downshift(phydev, DOWNSHIFT_DEV_DEFAULT_COUNT);\n\tif (err && err != -EOPNOTSUPP)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int mv3310_get_features(struct phy_device *phydev)\n{\n\tint ret, val;\n\n\tret = genphy_c45_pma_read_abilities(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mv3310_has_pma_ngbaset_quirk(phydev)) {\n\t\tval = phy_read_mmd(phydev, MDIO_MMD_PMAPMD,\n\t\t\t\t   MDIO_PMA_NG_EXTABLE);\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,\n\t\t\t\t phydev->supported,\n\t\t\t\t val & MDIO_PMA_NG_EXTABLE_2_5GBT);\n\n\t\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT,\n\t\t\t\t phydev->supported,\n\t\t\t\t val & MDIO_PMA_NG_EXTABLE_5GBT);\n\t}\n\n\treturn 0;\n}\n\nstatic int mv3310_config_mdix(struct phy_device *phydev)\n{\n\tu16 val;\n\tint err;\n\n\tswitch (phydev->mdix_ctrl) {\n\tcase ETH_TP_MDI_AUTO:\n\t\tval = MV_PCS_CSCR1_MDIX_AUTO;\n\t\tbreak;\n\tcase ETH_TP_MDI_X:\n\t\tval = MV_PCS_CSCR1_MDIX_MDIX;\n\t\tbreak;\n\tcase ETH_TP_MDI:\n\t\tval = MV_PCS_CSCR1_MDIX_MDI;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\terr = phy_modify_mmd_changed(phydev, MDIO_MMD_PCS, MV_PCS_CSCR1,\n\t\t\t\t     MV_PCS_CSCR1_MDIX_MASK, val);\n\tif (err > 0)\n\t\terr = mv3310_reset(phydev, MV_PCS_BASE_T);\n\n\treturn err;\n}\n\nstatic int mv3310_config_aneg(struct phy_device *phydev)\n{\n\tbool changed = false;\n\tu16 reg;\n\tint ret;\n\n\tret = mv3310_config_mdix(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (phydev->autoneg == AUTONEG_DISABLE)\n\t\treturn genphy_c45_pma_setup_forced(phydev);\n\n\tret = genphy_c45_an_config_aneg(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret > 0)\n\t\tchanged = true;\n\n\t \n\treg = linkmode_adv_to_mii_ctrl1000_t(phydev->advertising);\n\tret = phy_modify_mmd_changed(phydev, MDIO_MMD_AN, MV_AN_CTRL1000,\n\t\t\t     ADVERTISE_1000FULL | ADVERTISE_1000HALF, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret > 0)\n\t\tchanged = true;\n\n\treturn genphy_c45_check_and_restart_aneg(phydev, changed);\n}\n\nstatic int mv3310_aneg_done(struct phy_device *phydev)\n{\n\tint val;\n\n\tval = phy_read_mmd(phydev, MDIO_MMD_PCS, MV_PCS_BASE_R + MDIO_STAT1);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (val & MDIO_STAT1_LSTATUS)\n\t\treturn 1;\n\n\treturn genphy_c45_aneg_done(phydev);\n}\n\nstatic void mv3310_update_interface(struct phy_device *phydev)\n{\n\tstruct mv3310_priv *priv = dev_get_drvdata(&phydev->mdio.dev);\n\n\tif (!phydev->link)\n\t\treturn;\n\n\t \n\tif (priv->rate_match ||\n\t    priv->const_interface == PHY_INTERFACE_MODE_USXGMII) {\n\t\tphydev->interface = priv->const_interface;\n\t\treturn;\n\t}\n\n\t \n\tswitch (phydev->speed) {\n\tcase SPEED_10000:\n\t\tphydev->interface = priv->const_interface;\n\t\tbreak;\n\tcase SPEED_5000:\n\t\tphydev->interface = PHY_INTERFACE_MODE_5GBASER;\n\t\tbreak;\n\tcase SPEED_2500:\n\t\tphydev->interface = PHY_INTERFACE_MODE_2500BASEX;\n\t\tbreak;\n\tcase SPEED_1000:\n\tcase SPEED_100:\n\tcase SPEED_10:\n\t\tphydev->interface = PHY_INTERFACE_MODE_SGMII;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic int mv3310_read_status_10gbaser(struct phy_device *phydev)\n{\n\tphydev->link = 1;\n\tphydev->speed = SPEED_10000;\n\tphydev->duplex = DUPLEX_FULL;\n\tphydev->port = PORT_FIBRE;\n\n\treturn 0;\n}\n\nstatic int mv3310_read_status_copper(struct phy_device *phydev)\n{\n\tint cssr1, speed, val;\n\n\tval = genphy_c45_read_link(phydev);\n\tif (val < 0)\n\t\treturn val;\n\n\tval = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_STAT1);\n\tif (val < 0)\n\t\treturn val;\n\n\tcssr1 = phy_read_mmd(phydev, MDIO_MMD_PCS, MV_PCS_CSSR1);\n\tif (cssr1 < 0)\n\t\treturn cssr1;\n\n\t \n\tif (!(cssr1 & MV_PCS_CSSR1_RESOLVED)) {\n\t\tphydev->link = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tspeed = cssr1 & MV_PCS_CSSR1_SPD1_MASK;\n\tif (speed == MV_PCS_CSSR1_SPD1_SPD2)\n\t\tspeed |= cssr1 & MV_PCS_CSSR1_SPD2_MASK;\n\n\tswitch (speed) {\n\tcase MV_PCS_CSSR1_SPD1_SPD2 | MV_PCS_CSSR1_SPD2_10000:\n\t\tphydev->speed = SPEED_10000;\n\t\tbreak;\n\n\tcase MV_PCS_CSSR1_SPD1_SPD2 | MV_PCS_CSSR1_SPD2_5000:\n\t\tphydev->speed = SPEED_5000;\n\t\tbreak;\n\n\tcase MV_PCS_CSSR1_SPD1_SPD2 | MV_PCS_CSSR1_SPD2_2500:\n\t\tphydev->speed = SPEED_2500;\n\t\tbreak;\n\n\tcase MV_PCS_CSSR1_SPD1_1000:\n\t\tphydev->speed = SPEED_1000;\n\t\tbreak;\n\n\tcase MV_PCS_CSSR1_SPD1_100:\n\t\tphydev->speed = SPEED_100;\n\t\tbreak;\n\n\tcase MV_PCS_CSSR1_SPD1_10:\n\t\tphydev->speed = SPEED_10;\n\t\tbreak;\n\t}\n\n\tphydev->duplex = cssr1 & MV_PCS_CSSR1_DUPLEX_FULL ?\n\t\t\t DUPLEX_FULL : DUPLEX_HALF;\n\tphydev->port = PORT_TP;\n\tphydev->mdix = cssr1 & MV_PCS_CSSR1_MDIX ?\n\t\t       ETH_TP_MDI_X : ETH_TP_MDI;\n\n\tif (val & MDIO_AN_STAT1_COMPLETE) {\n\t\tval = genphy_c45_read_lpa(phydev);\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\t \n\t\tval = phy_read_mmd(phydev, MDIO_MMD_AN, MV_AN_STAT1000);\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tmii_stat1000_mod_linkmode_lpa_t(phydev->lp_advertising, val);\n\n\t\t \n\t\tphy_resolve_aneg_pause(phydev);\n\t}\n\n\treturn 0;\n}\n\nstatic int mv3310_read_status(struct phy_device *phydev)\n{\n\tint err, val;\n\n\tphydev->speed = SPEED_UNKNOWN;\n\tphydev->duplex = DUPLEX_UNKNOWN;\n\tlinkmode_zero(phydev->lp_advertising);\n\tphydev->link = 0;\n\tphydev->pause = 0;\n\tphydev->asym_pause = 0;\n\tphydev->mdix = ETH_TP_MDI_INVALID;\n\n\tval = phy_read_mmd(phydev, MDIO_MMD_PCS, MV_PCS_BASE_R + MDIO_STAT1);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (val & MDIO_STAT1_LSTATUS)\n\t\terr = mv3310_read_status_10gbaser(phydev);\n\telse\n\t\terr = mv3310_read_status_copper(phydev);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (phydev->link)\n\t\tmv3310_update_interface(phydev);\n\n\treturn 0;\n}\n\nstatic int mv3310_get_tunable(struct phy_device *phydev,\n\t\t\t      struct ethtool_tunable *tuna, void *data)\n{\n\tswitch (tuna->id) {\n\tcase ETHTOOL_PHY_DOWNSHIFT:\n\t\treturn mv3310_get_downshift(phydev, data);\n\tcase ETHTOOL_PHY_EDPD:\n\t\treturn mv3310_get_edpd(phydev, data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int mv3310_set_tunable(struct phy_device *phydev,\n\t\t\t      struct ethtool_tunable *tuna, const void *data)\n{\n\tswitch (tuna->id) {\n\tcase ETHTOOL_PHY_DOWNSHIFT:\n\t\treturn mv3310_set_downshift(phydev, *(u8 *)data);\n\tcase ETHTOOL_PHY_EDPD:\n\t\treturn mv3310_set_edpd(phydev, *(u16 *)data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic bool mv3310_has_downshift(struct phy_device *phydev)\n{\n\tstruct mv3310_priv *priv = dev_get_drvdata(&phydev->mdio.dev);\n\n\t \n\treturn priv->firmware_ver >= MV_VERSION(0,3,5,0);\n}\n\nstatic void mv3310_init_supported_interfaces(unsigned long *mask)\n{\n\t__set_bit(PHY_INTERFACE_MODE_SGMII, mask);\n\t__set_bit(PHY_INTERFACE_MODE_2500BASEX, mask);\n\t__set_bit(PHY_INTERFACE_MODE_5GBASER, mask);\n\t__set_bit(PHY_INTERFACE_MODE_XAUI, mask);\n\t__set_bit(PHY_INTERFACE_MODE_RXAUI, mask);\n\t__set_bit(PHY_INTERFACE_MODE_10GBASER, mask);\n\t__set_bit(PHY_INTERFACE_MODE_USXGMII, mask);\n}\n\nstatic void mv3340_init_supported_interfaces(unsigned long *mask)\n{\n\t__set_bit(PHY_INTERFACE_MODE_SGMII, mask);\n\t__set_bit(PHY_INTERFACE_MODE_2500BASEX, mask);\n\t__set_bit(PHY_INTERFACE_MODE_5GBASER, mask);\n\t__set_bit(PHY_INTERFACE_MODE_RXAUI, mask);\n\t__set_bit(PHY_INTERFACE_MODE_10GBASER, mask);\n\t__set_bit(PHY_INTERFACE_MODE_USXGMII, mask);\n}\n\nstatic void mv2110_init_supported_interfaces(unsigned long *mask)\n{\n\t__set_bit(PHY_INTERFACE_MODE_SGMII, mask);\n\t__set_bit(PHY_INTERFACE_MODE_2500BASEX, mask);\n\t__set_bit(PHY_INTERFACE_MODE_5GBASER, mask);\n\t__set_bit(PHY_INTERFACE_MODE_10GBASER, mask);\n\t__set_bit(PHY_INTERFACE_MODE_USXGMII, mask);\n}\n\nstatic void mv2111_init_supported_interfaces(unsigned long *mask)\n{\n\t__set_bit(PHY_INTERFACE_MODE_SGMII, mask);\n\t__set_bit(PHY_INTERFACE_MODE_2500BASEX, mask);\n\t__set_bit(PHY_INTERFACE_MODE_10GBASER, mask);\n\t__set_bit(PHY_INTERFACE_MODE_USXGMII, mask);\n}\n\nstatic const struct mv3310_chip mv3310_type = {\n\t.has_downshift = mv3310_has_downshift,\n\t.init_supported_interfaces = mv3310_init_supported_interfaces,\n\t.get_mactype = mv3310_get_mactype,\n\t.set_mactype = mv3310_set_mactype,\n\t.select_mactype = mv3310_select_mactype,\n\t.init_interface = mv3310_init_interface,\n\n#ifdef CONFIG_HWMON\n\t.hwmon_read_temp_reg = mv3310_hwmon_read_temp_reg,\n#endif\n};\n\nstatic const struct mv3310_chip mv3340_type = {\n\t.has_downshift = mv3310_has_downshift,\n\t.init_supported_interfaces = mv3340_init_supported_interfaces,\n\t.get_mactype = mv3310_get_mactype,\n\t.set_mactype = mv3310_set_mactype,\n\t.select_mactype = mv3310_select_mactype,\n\t.init_interface = mv3340_init_interface,\n\n#ifdef CONFIG_HWMON\n\t.hwmon_read_temp_reg = mv3310_hwmon_read_temp_reg,\n#endif\n};\n\nstatic const struct mv3310_chip mv2110_type = {\n\t.init_supported_interfaces = mv2110_init_supported_interfaces,\n\t.get_mactype = mv2110_get_mactype,\n\t.set_mactype = mv2110_set_mactype,\n\t.select_mactype = mv2110_select_mactype,\n\t.init_interface = mv2110_init_interface,\n\n#ifdef CONFIG_HWMON\n\t.hwmon_read_temp_reg = mv2110_hwmon_read_temp_reg,\n#endif\n};\n\nstatic const struct mv3310_chip mv2111_type = {\n\t.init_supported_interfaces = mv2111_init_supported_interfaces,\n\t.get_mactype = mv2110_get_mactype,\n\t.set_mactype = mv2110_set_mactype,\n\t.select_mactype = mv2110_select_mactype,\n\t.init_interface = mv2110_init_interface,\n\n#ifdef CONFIG_HWMON\n\t.hwmon_read_temp_reg = mv2110_hwmon_read_temp_reg,\n#endif\n};\n\nstatic int mv3310_get_number_of_ports(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = phy_read_mmd(phydev, MDIO_MMD_PCS, MV_PCS_PORT_INFO);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret &= MV_PCS_PORT_INFO_NPORTS_MASK;\n\tret >>= MV_PCS_PORT_INFO_NPORTS_SHIFT;\n\n\treturn ret + 1;\n}\n\nstatic int mv3310_match_phy_device(struct phy_device *phydev)\n{\n\tif ((phydev->c45_ids.device_ids[MDIO_MMD_PMAPMD] &\n\t     MARVELL_PHY_ID_MASK) != MARVELL_PHY_ID_88X3310)\n\t\treturn 0;\n\n\treturn mv3310_get_number_of_ports(phydev) == 1;\n}\n\nstatic int mv3340_match_phy_device(struct phy_device *phydev)\n{\n\tif ((phydev->c45_ids.device_ids[MDIO_MMD_PMAPMD] &\n\t     MARVELL_PHY_ID_MASK) != MARVELL_PHY_ID_88X3310)\n\t\treturn 0;\n\n\treturn mv3310_get_number_of_ports(phydev) == 4;\n}\n\nstatic int mv211x_match_phy_device(struct phy_device *phydev, bool has_5g)\n{\n\tint val;\n\n\tif ((phydev->c45_ids.device_ids[MDIO_MMD_PMAPMD] &\n\t     MARVELL_PHY_ID_MASK) != MARVELL_PHY_ID_88E2110)\n\t\treturn 0;\n\n\tval = phy_read_mmd(phydev, MDIO_MMD_PCS, MDIO_SPEED);\n\tif (val < 0)\n\t\treturn val;\n\n\treturn !!(val & MDIO_PCS_SPEED_5G) == has_5g;\n}\n\nstatic int mv2110_match_phy_device(struct phy_device *phydev)\n{\n\treturn mv211x_match_phy_device(phydev, true);\n}\n\nstatic int mv2111_match_phy_device(struct phy_device *phydev)\n{\n\treturn mv211x_match_phy_device(phydev, false);\n}\n\nstatic void mv3110_get_wol(struct phy_device *phydev,\n\t\t\t   struct ethtool_wolinfo *wol)\n{\n\tint ret;\n\n\twol->supported = WAKE_MAGIC;\n\twol->wolopts = 0;\n\n\tret = phy_read_mmd(phydev, MDIO_MMD_VEND2, MV_V2_WOL_CTRL);\n\tif (ret < 0)\n\t\treturn;\n\n\tif (ret & MV_V2_WOL_CTRL_MAGIC_PKT_EN)\n\t\twol->wolopts |= WAKE_MAGIC;\n}\n\nstatic int mv3110_set_wol(struct phy_device *phydev,\n\t\t\t  struct ethtool_wolinfo *wol)\n{\n\tint ret;\n\n\tif (wol->wolopts & WAKE_MAGIC) {\n\t\t \n\t\tret = phy_set_bits_mmd(phydev, MDIO_MMD_VEND2,\n\t\t\t\t       MV_V2_PORT_INTR_MASK,\n\t\t\t\t       MV_V2_PORT_INTR_STS_WOL_EN);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = phy_write_mmd(phydev, MDIO_MMD_VEND2,\n\t\t\t\t    MV_V2_MAGIC_PKT_WORD2,\n\t\t\t\t    ((phydev->attached_dev->dev_addr[5] << 8) |\n\t\t\t\t    phydev->attached_dev->dev_addr[4]));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = phy_write_mmd(phydev, MDIO_MMD_VEND2,\n\t\t\t\t    MV_V2_MAGIC_PKT_WORD1,\n\t\t\t\t    ((phydev->attached_dev->dev_addr[3] << 8) |\n\t\t\t\t    phydev->attached_dev->dev_addr[2]));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = phy_write_mmd(phydev, MDIO_MMD_VEND2,\n\t\t\t\t    MV_V2_MAGIC_PKT_WORD0,\n\t\t\t\t    ((phydev->attached_dev->dev_addr[1] << 8) |\n\t\t\t\t    phydev->attached_dev->dev_addr[0]));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = phy_set_bits_mmd(phydev, MDIO_MMD_VEND2,\n\t\t\t\t       MV_V2_WOL_CTRL,\n\t\t\t\t       MV_V2_WOL_CTRL_MAGIC_PKT_EN |\n\t\t\t\t       MV_V2_WOL_CTRL_CLEAR_STS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\t \n\t\tret = phy_modify_mmd(phydev, MDIO_MMD_VEND2,\n\t\t\t\t     MV_V2_WOL_CTRL,\n\t\t\t\t     MV_V2_WOL_CTRL_MAGIC_PKT_EN,\n\t\t\t\t     MV_V2_WOL_CTRL_CLEAR_STS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\treturn phy_clear_bits_mmd(phydev, MDIO_MMD_VEND2,\n\t\t\t\t  MV_V2_WOL_CTRL,\n\t\t\t\t  MV_V2_WOL_CTRL_CLEAR_STS);\n}\n\nstatic struct phy_driver mv3310_drivers[] = {\n\t{\n\t\t.phy_id\t\t= MARVELL_PHY_ID_88X3310,\n\t\t.phy_id_mask\t= MARVELL_PHY_ID_MASK,\n\t\t.match_phy_device = mv3310_match_phy_device,\n\t\t.name\t\t= \"mv88x3310\",\n\t\t.driver_data\t= &mv3310_type,\n\t\t.get_features\t= mv3310_get_features,\n\t\t.config_init\t= mv3310_config_init,\n\t\t.probe\t\t= mv3310_probe,\n\t\t.suspend\t= mv3310_suspend,\n\t\t.resume\t\t= mv3310_resume,\n\t\t.config_aneg\t= mv3310_config_aneg,\n\t\t.aneg_done\t= mv3310_aneg_done,\n\t\t.read_status\t= mv3310_read_status,\n\t\t.get_tunable\t= mv3310_get_tunable,\n\t\t.set_tunable\t= mv3310_set_tunable,\n\t\t.remove\t\t= mv3310_remove,\n\t\t.set_loopback\t= genphy_c45_loopback,\n\t\t.get_wol\t= mv3110_get_wol,\n\t\t.set_wol\t= mv3110_set_wol,\n\t},\n\t{\n\t\t.phy_id\t\t= MARVELL_PHY_ID_88X3310,\n\t\t.phy_id_mask\t= MARVELL_PHY_ID_MASK,\n\t\t.match_phy_device = mv3340_match_phy_device,\n\t\t.name\t\t= \"mv88x3340\",\n\t\t.driver_data\t= &mv3340_type,\n\t\t.get_features\t= mv3310_get_features,\n\t\t.config_init\t= mv3310_config_init,\n\t\t.probe\t\t= mv3310_probe,\n\t\t.suspend\t= mv3310_suspend,\n\t\t.resume\t\t= mv3310_resume,\n\t\t.config_aneg\t= mv3310_config_aneg,\n\t\t.aneg_done\t= mv3310_aneg_done,\n\t\t.read_status\t= mv3310_read_status,\n\t\t.get_tunable\t= mv3310_get_tunable,\n\t\t.set_tunable\t= mv3310_set_tunable,\n\t\t.remove\t\t= mv3310_remove,\n\t\t.set_loopback\t= genphy_c45_loopback,\n\t},\n\t{\n\t\t.phy_id\t\t= MARVELL_PHY_ID_88E2110,\n\t\t.phy_id_mask\t= MARVELL_PHY_ID_MASK,\n\t\t.match_phy_device = mv2110_match_phy_device,\n\t\t.name\t\t= \"mv88e2110\",\n\t\t.driver_data\t= &mv2110_type,\n\t\t.probe\t\t= mv3310_probe,\n\t\t.suspend\t= mv3310_suspend,\n\t\t.resume\t\t= mv3310_resume,\n\t\t.config_init\t= mv3310_config_init,\n\t\t.config_aneg\t= mv3310_config_aneg,\n\t\t.aneg_done\t= mv3310_aneg_done,\n\t\t.read_status\t= mv3310_read_status,\n\t\t.get_tunable\t= mv3310_get_tunable,\n\t\t.set_tunable\t= mv3310_set_tunable,\n\t\t.remove\t\t= mv3310_remove,\n\t\t.set_loopback\t= genphy_c45_loopback,\n\t\t.get_wol\t= mv3110_get_wol,\n\t\t.set_wol\t= mv3110_set_wol,\n\t},\n\t{\n\t\t.phy_id\t\t= MARVELL_PHY_ID_88E2110,\n\t\t.phy_id_mask\t= MARVELL_PHY_ID_MASK,\n\t\t.match_phy_device = mv2111_match_phy_device,\n\t\t.name\t\t= \"mv88e2111\",\n\t\t.driver_data\t= &mv2111_type,\n\t\t.probe\t\t= mv3310_probe,\n\t\t.suspend\t= mv3310_suspend,\n\t\t.resume\t\t= mv3310_resume,\n\t\t.config_init\t= mv3310_config_init,\n\t\t.config_aneg\t= mv3310_config_aneg,\n\t\t.aneg_done\t= mv3310_aneg_done,\n\t\t.read_status\t= mv3310_read_status,\n\t\t.get_tunable\t= mv3310_get_tunable,\n\t\t.set_tunable\t= mv3310_set_tunable,\n\t\t.remove\t\t= mv3310_remove,\n\t\t.set_loopback\t= genphy_c45_loopback,\n\t},\n};\n\nmodule_phy_driver(mv3310_drivers);\n\nstatic struct mdio_device_id __maybe_unused mv3310_tbl[] = {\n\t{ MARVELL_PHY_ID_88X3310, MARVELL_PHY_ID_MASK },\n\t{ MARVELL_PHY_ID_88E2110, MARVELL_PHY_ID_MASK },\n\t{ },\n};\nMODULE_DEVICE_TABLE(mdio, mv3310_tbl);\nMODULE_DESCRIPTION(\"Marvell Alaska X/M multi-gigabit Ethernet PHY driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}