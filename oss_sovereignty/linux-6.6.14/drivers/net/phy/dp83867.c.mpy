{
  "module_name": "dp83867.c",
  "hash_id": "c1d9066ffd423341e2be7f1f0bed2a24215b9b2a56f07d1fbb863f1dc9725c9a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/dp83867.c",
  "human_readable_source": "\n \n\n#include <linux/ethtool.h>\n#include <linux/kernel.h>\n#include <linux/mii.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/bitfield.h>\n#include <linux/nvmem-consumer.h>\n\n#include <dt-bindings/net/ti-dp83867.h>\n\n#define DP83867_PHY_ID\t\t0x2000a231\n#define DP83867_DEVADDR\t\t0x1f\n\n#define MII_DP83867_PHYCTRL\t0x10\n#define MII_DP83867_PHYSTS\t0x11\n#define MII_DP83867_MICR\t0x12\n#define MII_DP83867_ISR\t\t0x13\n#define DP83867_CFG2\t\t0x14\n#define DP83867_LEDCR1\t\t0x18\n#define DP83867_LEDCR2\t\t0x19\n#define DP83867_CFG3\t\t0x1e\n#define DP83867_CTRL\t\t0x1f\n\n \n#define DP83867_FLD_THR_CFG\t0x002e\n#define DP83867_CFG4\t\t0x0031\n#define DP83867_CFG4_SGMII_ANEG_MASK (BIT(5) | BIT(6))\n#define DP83867_CFG4_SGMII_ANEG_TIMER_11MS   (3 << 5)\n#define DP83867_CFG4_SGMII_ANEG_TIMER_800US  (2 << 5)\n#define DP83867_CFG4_SGMII_ANEG_TIMER_2US    (1 << 5)\n#define DP83867_CFG4_SGMII_ANEG_TIMER_16MS   (0 << 5)\n\n#define DP83867_RGMIICTL\t0x0032\n#define DP83867_STRAP_STS1\t0x006E\n#define DP83867_STRAP_STS2\t0x006f\n#define DP83867_RGMIIDCTL\t0x0086\n#define DP83867_DSP_FFE_CFG\t0x012c\n#define DP83867_RXFCFG\t\t0x0134\n#define DP83867_RXFPMD1\t0x0136\n#define DP83867_RXFPMD2\t0x0137\n#define DP83867_RXFPMD3\t0x0138\n#define DP83867_RXFSOP1\t0x0139\n#define DP83867_RXFSOP2\t0x013A\n#define DP83867_RXFSOP3\t0x013B\n#define DP83867_IO_MUX_CFG\t0x0170\n#define DP83867_SGMIICTL\t0x00D3\n#define DP83867_10M_SGMII_CFG   0x016F\n#define DP83867_10M_SGMII_RATE_ADAPT_MASK BIT(7)\n\n#define DP83867_SW_RESET\tBIT(15)\n#define DP83867_SW_RESTART\tBIT(14)\n\n \n#define MII_DP83867_MICR_AN_ERR_INT_EN\t\tBIT(15)\n#define MII_DP83867_MICR_SPEED_CHNG_INT_EN\tBIT(14)\n#define MII_DP83867_MICR_DUP_MODE_CHNG_INT_EN\tBIT(13)\n#define MII_DP83867_MICR_PAGE_RXD_INT_EN\tBIT(12)\n#define MII_DP83867_MICR_AUTONEG_COMP_INT_EN\tBIT(11)\n#define MII_DP83867_MICR_LINK_STS_CHNG_INT_EN\tBIT(10)\n#define MII_DP83867_MICR_FALSE_CARRIER_INT_EN\tBIT(8)\n#define MII_DP83867_MICR_SLEEP_MODE_CHNG_INT_EN\tBIT(4)\n#define MII_DP83867_MICR_WOL_INT_EN\t\tBIT(3)\n#define MII_DP83867_MICR_XGMII_ERR_INT_EN\tBIT(2)\n#define MII_DP83867_MICR_POL_CHNG_INT_EN\tBIT(1)\n#define MII_DP83867_MICR_JABBER_INT_EN\t\tBIT(0)\n\n \n#define DP83867_RGMII_TX_CLK_DELAY_EN\t\tBIT(1)\n#define DP83867_RGMII_RX_CLK_DELAY_EN\t\tBIT(0)\n\n \n#define DP83867_SGMII_TYPE\t\tBIT(14)\n\n \n#define DP83867_WOL_MAGIC_EN\t\tBIT(0)\n#define DP83867_WOL_BCAST_EN\t\tBIT(2)\n#define DP83867_WOL_UCAST_EN\t\tBIT(4)\n#define DP83867_WOL_SEC_EN\t\tBIT(5)\n#define DP83867_WOL_ENH_MAC\t\tBIT(7)\n\n \n#define DP83867_STRAP_STS1_RESERVED\t\tBIT(11)\n\n \n#define DP83867_STRAP_STS2_CLK_SKEW_TX_MASK\tGENMASK(6, 4)\n#define DP83867_STRAP_STS2_CLK_SKEW_TX_SHIFT\t4\n#define DP83867_STRAP_STS2_CLK_SKEW_RX_MASK\tGENMASK(2, 0)\n#define DP83867_STRAP_STS2_CLK_SKEW_RX_SHIFT\t0\n#define DP83867_STRAP_STS2_CLK_SKEW_NONE\tBIT(2)\n#define DP83867_STRAP_STS2_STRAP_FLD\t\tBIT(10)\n\n \n#define DP83867_PHYCR_TX_FIFO_DEPTH_SHIFT\t14\n#define DP83867_PHYCR_RX_FIFO_DEPTH_SHIFT\t12\n#define DP83867_PHYCR_FIFO_DEPTH_MAX\t\t0x03\n#define DP83867_PHYCR_TX_FIFO_DEPTH_MASK\tGENMASK(15, 14)\n#define DP83867_PHYCR_RX_FIFO_DEPTH_MASK\tGENMASK(13, 12)\n#define DP83867_PHYCR_RESERVED_MASK\t\tBIT(11)\n#define DP83867_PHYCR_FORCE_LINK_GOOD\t\tBIT(10)\n\n \n#define DP83867_RGMII_TX_CLK_DELAY_MAX\t\t0xf\n#define DP83867_RGMII_TX_CLK_DELAY_SHIFT\t4\n#define DP83867_RGMII_TX_CLK_DELAY_INV\t(DP83867_RGMII_TX_CLK_DELAY_MAX + 1)\n#define DP83867_RGMII_RX_CLK_DELAY_MAX\t\t0xf\n#define DP83867_RGMII_RX_CLK_DELAY_SHIFT\t0\n#define DP83867_RGMII_RX_CLK_DELAY_INV\t(DP83867_RGMII_RX_CLK_DELAY_MAX + 1)\n\n \n#define DP83867_IO_MUX_CFG_IO_IMPEDANCE_MASK\t0x1f\n#define DP83867_IO_MUX_CFG_IO_IMPEDANCE_MAX\t0x0\n#define DP83867_IO_MUX_CFG_IO_IMPEDANCE_MIN\t0x1f\n#define DP83867_IO_MUX_CFG_CLK_O_DISABLE\tBIT(6)\n#define DP83867_IO_MUX_CFG_CLK_O_SEL_MASK\t(0x1f << 8)\n#define DP83867_IO_MUX_CFG_CLK_O_SEL_SHIFT\t8\n\n \n#define DP83867_PHYSTS_1000\t\t\tBIT(15)\n#define DP83867_PHYSTS_100\t\t\tBIT(14)\n#define DP83867_PHYSTS_DUPLEX\t\t\tBIT(13)\n#define DP83867_PHYSTS_LINK\t\t\tBIT(10)\n\n \n#define DP83867_DOWNSHIFT_EN\t\t(BIT(8) | BIT(9))\n#define DP83867_DOWNSHIFT_ATTEMPT_MASK\t(BIT(10) | BIT(11))\n#define DP83867_DOWNSHIFT_1_COUNT_VAL\t0\n#define DP83867_DOWNSHIFT_2_COUNT_VAL\t1\n#define DP83867_DOWNSHIFT_4_COUNT_VAL\t2\n#define DP83867_DOWNSHIFT_8_COUNT_VAL\t3\n#define DP83867_DOWNSHIFT_1_COUNT\t1\n#define DP83867_DOWNSHIFT_2_COUNT\t2\n#define DP83867_DOWNSHIFT_4_COUNT\t4\n#define DP83867_DOWNSHIFT_8_COUNT\t8\n#define DP83867_SGMII_AUTONEG_EN\tBIT(7)\n\n \n#define DP83867_CFG3_INT_OE\t\t\tBIT(7)\n#define DP83867_CFG3_ROBUST_AUTO_MDIX\t\tBIT(9)\n\n \n#define DP83867_CFG4_PORT_MIRROR_EN              BIT(0)\n\n \n#define DP83867_FLD_THR_CFG_ENERGY_LOST_THR_MASK\t0x7\n\n#define DP83867_LED_COUNT\t4\n\n \n#define DP83867_LED_DRV_EN(x)\tBIT((x) * 4)\n#define DP83867_LED_DRV_VAL(x)\tBIT((x) * 4 + 1)\n\nenum {\n\tDP83867_PORT_MIRROING_KEEP,\n\tDP83867_PORT_MIRROING_EN,\n\tDP83867_PORT_MIRROING_DIS,\n};\n\nstruct dp83867_private {\n\tu32 rx_id_delay;\n\tu32 tx_id_delay;\n\tu32 tx_fifo_depth;\n\tu32 rx_fifo_depth;\n\tint io_impedance;\n\tint port_mirroring;\n\tbool rxctrl_strap_quirk;\n\tbool set_clk_output;\n\tu32 clk_output_sel;\n\tbool sgmii_ref_clk_en;\n};\n\nstatic int dp83867_ack_interrupt(struct phy_device *phydev)\n{\n\tint err = phy_read(phydev, MII_DP83867_ISR);\n\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int dp83867_set_wol(struct phy_device *phydev,\n\t\t\t   struct ethtool_wolinfo *wol)\n{\n\tstruct net_device *ndev = phydev->attached_dev;\n\tu16 val_rxcfg, val_micr;\n\tconst u8 *mac;\n\n\tval_rxcfg = phy_read_mmd(phydev, DP83867_DEVADDR, DP83867_RXFCFG);\n\tval_micr = phy_read(phydev, MII_DP83867_MICR);\n\n\tif (wol->wolopts & (WAKE_MAGIC | WAKE_MAGICSECURE | WAKE_UCAST |\n\t\t\t    WAKE_BCAST)) {\n\t\tval_rxcfg |= DP83867_WOL_ENH_MAC;\n\t\tval_micr |= MII_DP83867_MICR_WOL_INT_EN;\n\n\t\tif (wol->wolopts & WAKE_MAGIC) {\n\t\t\tmac = (const u8 *)ndev->dev_addr;\n\n\t\t\tif (!is_valid_ether_addr(mac))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tphy_write_mmd(phydev, DP83867_DEVADDR, DP83867_RXFPMD1,\n\t\t\t\t      (mac[1] << 8 | mac[0]));\n\t\t\tphy_write_mmd(phydev, DP83867_DEVADDR, DP83867_RXFPMD2,\n\t\t\t\t      (mac[3] << 8 | mac[2]));\n\t\t\tphy_write_mmd(phydev, DP83867_DEVADDR, DP83867_RXFPMD3,\n\t\t\t\t      (mac[5] << 8 | mac[4]));\n\n\t\t\tval_rxcfg |= DP83867_WOL_MAGIC_EN;\n\t\t} else {\n\t\t\tval_rxcfg &= ~DP83867_WOL_MAGIC_EN;\n\t\t}\n\n\t\tif (wol->wolopts & WAKE_MAGICSECURE) {\n\t\t\tphy_write_mmd(phydev, DP83867_DEVADDR, DP83867_RXFSOP1,\n\t\t\t\t      (wol->sopass[1] << 8) | wol->sopass[0]);\n\t\t\tphy_write_mmd(phydev, DP83867_DEVADDR, DP83867_RXFSOP2,\n\t\t\t\t      (wol->sopass[3] << 8) | wol->sopass[2]);\n\t\t\tphy_write_mmd(phydev, DP83867_DEVADDR, DP83867_RXFSOP3,\n\t\t\t\t      (wol->sopass[5] << 8) | wol->sopass[4]);\n\n\t\t\tval_rxcfg |= DP83867_WOL_SEC_EN;\n\t\t} else {\n\t\t\tval_rxcfg &= ~DP83867_WOL_SEC_EN;\n\t\t}\n\n\t\tif (wol->wolopts & WAKE_UCAST)\n\t\t\tval_rxcfg |= DP83867_WOL_UCAST_EN;\n\t\telse\n\t\t\tval_rxcfg &= ~DP83867_WOL_UCAST_EN;\n\n\t\tif (wol->wolopts & WAKE_BCAST)\n\t\t\tval_rxcfg |= DP83867_WOL_BCAST_EN;\n\t\telse\n\t\t\tval_rxcfg &= ~DP83867_WOL_BCAST_EN;\n\t} else {\n\t\tval_rxcfg &= ~DP83867_WOL_ENH_MAC;\n\t\tval_micr &= ~MII_DP83867_MICR_WOL_INT_EN;\n\t}\n\n\tphy_write_mmd(phydev, DP83867_DEVADDR, DP83867_RXFCFG, val_rxcfg);\n\tphy_write(phydev, MII_DP83867_MICR, val_micr);\n\n\treturn 0;\n}\n\nstatic void dp83867_get_wol(struct phy_device *phydev,\n\t\t\t    struct ethtool_wolinfo *wol)\n{\n\tu16 value, sopass_val;\n\n\twol->supported = (WAKE_UCAST | WAKE_BCAST | WAKE_MAGIC |\n\t\t\tWAKE_MAGICSECURE);\n\twol->wolopts = 0;\n\n\tvalue = phy_read_mmd(phydev, DP83867_DEVADDR, DP83867_RXFCFG);\n\n\tif (value & DP83867_WOL_UCAST_EN)\n\t\twol->wolopts |= WAKE_UCAST;\n\n\tif (value & DP83867_WOL_BCAST_EN)\n\t\twol->wolopts |= WAKE_BCAST;\n\n\tif (value & DP83867_WOL_MAGIC_EN)\n\t\twol->wolopts |= WAKE_MAGIC;\n\n\tif (value & DP83867_WOL_SEC_EN) {\n\t\tsopass_val = phy_read_mmd(phydev, DP83867_DEVADDR,\n\t\t\t\t\t  DP83867_RXFSOP1);\n\t\twol->sopass[0] = (sopass_val & 0xff);\n\t\twol->sopass[1] = (sopass_val >> 8);\n\n\t\tsopass_val = phy_read_mmd(phydev, DP83867_DEVADDR,\n\t\t\t\t\t  DP83867_RXFSOP2);\n\t\twol->sopass[2] = (sopass_val & 0xff);\n\t\twol->sopass[3] = (sopass_val >> 8);\n\n\t\tsopass_val = phy_read_mmd(phydev, DP83867_DEVADDR,\n\t\t\t\t\t  DP83867_RXFSOP3);\n\t\twol->sopass[4] = (sopass_val & 0xff);\n\t\twol->sopass[5] = (sopass_val >> 8);\n\n\t\twol->wolopts |= WAKE_MAGICSECURE;\n\t}\n\n\tif (!(value & DP83867_WOL_ENH_MAC))\n\t\twol->wolopts = 0;\n}\n\nstatic int dp83867_config_intr(struct phy_device *phydev)\n{\n\tint micr_status, err;\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\terr = dp83867_ack_interrupt(phydev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tmicr_status = phy_read(phydev, MII_DP83867_MICR);\n\t\tif (micr_status < 0)\n\t\t\treturn micr_status;\n\n\t\tmicr_status |=\n\t\t\t(MII_DP83867_MICR_AN_ERR_INT_EN |\n\t\t\tMII_DP83867_MICR_SPEED_CHNG_INT_EN |\n\t\t\tMII_DP83867_MICR_AUTONEG_COMP_INT_EN |\n\t\t\tMII_DP83867_MICR_LINK_STS_CHNG_INT_EN |\n\t\t\tMII_DP83867_MICR_DUP_MODE_CHNG_INT_EN |\n\t\t\tMII_DP83867_MICR_SLEEP_MODE_CHNG_INT_EN);\n\n\t\terr = phy_write(phydev, MII_DP83867_MICR, micr_status);\n\t} else {\n\t\tmicr_status = 0x0;\n\t\terr = phy_write(phydev, MII_DP83867_MICR, micr_status);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = dp83867_ack_interrupt(phydev);\n\t}\n\n\treturn err;\n}\n\nstatic irqreturn_t dp83867_handle_interrupt(struct phy_device *phydev)\n{\n\tint irq_status, irq_enabled;\n\n\tirq_status = phy_read(phydev, MII_DP83867_ISR);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tirq_enabled = phy_read(phydev, MII_DP83867_MICR);\n\tif (irq_enabled < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (!(irq_status & irq_enabled))\n\t\treturn IRQ_NONE;\n\n\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int dp83867_read_status(struct phy_device *phydev)\n{\n\tint status = phy_read(phydev, MII_DP83867_PHYSTS);\n\tint ret;\n\n\tret = genphy_read_status(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (status < 0)\n\t\treturn status;\n\n\tif (status & DP83867_PHYSTS_DUPLEX)\n\t\tphydev->duplex = DUPLEX_FULL;\n\telse\n\t\tphydev->duplex = DUPLEX_HALF;\n\n\tif (status & DP83867_PHYSTS_1000)\n\t\tphydev->speed = SPEED_1000;\n\telse if (status & DP83867_PHYSTS_100)\n\t\tphydev->speed = SPEED_100;\n\telse\n\t\tphydev->speed = SPEED_10;\n\n\treturn 0;\n}\n\nstatic int dp83867_get_downshift(struct phy_device *phydev, u8 *data)\n{\n\tint val, cnt, enable, count;\n\n\tval = phy_read(phydev, DP83867_CFG2);\n\tif (val < 0)\n\t\treturn val;\n\n\tenable = FIELD_GET(DP83867_DOWNSHIFT_EN, val);\n\tcnt = FIELD_GET(DP83867_DOWNSHIFT_ATTEMPT_MASK, val);\n\n\tswitch (cnt) {\n\tcase DP83867_DOWNSHIFT_1_COUNT_VAL:\n\t\tcount = DP83867_DOWNSHIFT_1_COUNT;\n\t\tbreak;\n\tcase DP83867_DOWNSHIFT_2_COUNT_VAL:\n\t\tcount = DP83867_DOWNSHIFT_2_COUNT;\n\t\tbreak;\n\tcase DP83867_DOWNSHIFT_4_COUNT_VAL:\n\t\tcount = DP83867_DOWNSHIFT_4_COUNT;\n\t\tbreak;\n\tcase DP83867_DOWNSHIFT_8_COUNT_VAL:\n\t\tcount = DP83867_DOWNSHIFT_8_COUNT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t*data = enable ? count : DOWNSHIFT_DEV_DISABLE;\n\n\treturn 0;\n}\n\nstatic int dp83867_set_downshift(struct phy_device *phydev, u8 cnt)\n{\n\tint val, count;\n\n\tif (cnt > DP83867_DOWNSHIFT_8_COUNT)\n\t\treturn -E2BIG;\n\n\tif (!cnt)\n\t\treturn phy_clear_bits(phydev, DP83867_CFG2,\n\t\t\t\t      DP83867_DOWNSHIFT_EN);\n\n\tswitch (cnt) {\n\tcase DP83867_DOWNSHIFT_1_COUNT:\n\t\tcount = DP83867_DOWNSHIFT_1_COUNT_VAL;\n\t\tbreak;\n\tcase DP83867_DOWNSHIFT_2_COUNT:\n\t\tcount = DP83867_DOWNSHIFT_2_COUNT_VAL;\n\t\tbreak;\n\tcase DP83867_DOWNSHIFT_4_COUNT:\n\t\tcount = DP83867_DOWNSHIFT_4_COUNT_VAL;\n\t\tbreak;\n\tcase DP83867_DOWNSHIFT_8_COUNT:\n\t\tcount = DP83867_DOWNSHIFT_8_COUNT_VAL;\n\t\tbreak;\n\tdefault:\n\t\tphydev_err(phydev,\n\t\t\t   \"Downshift count must be 1, 2, 4 or 8\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tval = DP83867_DOWNSHIFT_EN;\n\tval |= FIELD_PREP(DP83867_DOWNSHIFT_ATTEMPT_MASK, count);\n\n\treturn phy_modify(phydev, DP83867_CFG2,\n\t\t\t  DP83867_DOWNSHIFT_EN | DP83867_DOWNSHIFT_ATTEMPT_MASK,\n\t\t\t  val);\n}\n\nstatic int dp83867_get_tunable(struct phy_device *phydev,\n\t\t\t       struct ethtool_tunable *tuna, void *data)\n{\n\tswitch (tuna->id) {\n\tcase ETHTOOL_PHY_DOWNSHIFT:\n\t\treturn dp83867_get_downshift(phydev, data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int dp83867_set_tunable(struct phy_device *phydev,\n\t\t\t       struct ethtool_tunable *tuna, const void *data)\n{\n\tswitch (tuna->id) {\n\tcase ETHTOOL_PHY_DOWNSHIFT:\n\t\treturn dp83867_set_downshift(phydev, *(const u8 *)data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int dp83867_config_port_mirroring(struct phy_device *phydev)\n{\n\tstruct dp83867_private *dp83867 = phydev->priv;\n\n\tif (dp83867->port_mirroring == DP83867_PORT_MIRROING_EN)\n\t\tphy_set_bits_mmd(phydev, DP83867_DEVADDR, DP83867_CFG4,\n\t\t\t\t DP83867_CFG4_PORT_MIRROR_EN);\n\telse\n\t\tphy_clear_bits_mmd(phydev, DP83867_DEVADDR, DP83867_CFG4,\n\t\t\t\t   DP83867_CFG4_PORT_MIRROR_EN);\n\treturn 0;\n}\n\nstatic int dp83867_verify_rgmii_cfg(struct phy_device *phydev)\n{\n\tstruct dp83867_private *dp83867 = phydev->priv;\n\n\t \n\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII) {\n\t\tconst u16 val = phy_read_mmd(phydev, DP83867_DEVADDR,\n\t\t\t\t\t     DP83867_STRAP_STS2);\n\t\tconst u16 txskew = (val & DP83867_STRAP_STS2_CLK_SKEW_TX_MASK) >>\n\t\t\t\t   DP83867_STRAP_STS2_CLK_SKEW_TX_SHIFT;\n\t\tconst u16 rxskew = (val & DP83867_STRAP_STS2_CLK_SKEW_RX_MASK) >>\n\t\t\t\t   DP83867_STRAP_STS2_CLK_SKEW_RX_SHIFT;\n\n\t\tif (txskew != DP83867_STRAP_STS2_CLK_SKEW_NONE ||\n\t\t    rxskew != DP83867_STRAP_STS2_CLK_SKEW_NONE)\n\t\t\tphydev_warn(phydev,\n\t\t\t\t    \"PHY has delays via pin strapping, but phy-mode = 'rgmii'\\n\"\n\t\t\t\t    \"Should be 'rgmii-id' to use internal delays txskew:%x rxskew:%x\\n\",\n\t\t\t\t    txskew, rxskew);\n\t}\n\n\t \n\tif ((phydev->interface == PHY_INTERFACE_MODE_RGMII_ID ||\n\t     phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID) &&\n\t     dp83867->rx_id_delay == DP83867_RGMII_RX_CLK_DELAY_INV) {\n\t\tphydev_err(phydev, \"ti,rx-internal-delay must be specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((phydev->interface == PHY_INTERFACE_MODE_RGMII_ID ||\n\t     phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID) &&\n\t     dp83867->tx_id_delay == DP83867_RGMII_TX_CLK_DELAY_INV) {\n\t\tphydev_err(phydev, \"ti,tx-internal-delay must be specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_OF_MDIO)\nstatic int dp83867_of_init_io_impedance(struct phy_device *phydev)\n{\n\tstruct dp83867_private *dp83867 = phydev->priv;\n\tstruct device *dev = &phydev->mdio.dev;\n\tstruct device_node *of_node = dev->of_node;\n\tstruct nvmem_cell *cell;\n\tu8 *buf, val;\n\tint ret;\n\n\tcell = of_nvmem_cell_get(of_node, \"io_impedance_ctrl\");\n\tif (IS_ERR(cell)) {\n\t\tret = PTR_ERR(cell);\n\t\tif (ret != -ENOENT && ret != -EOPNOTSUPP)\n\t\t\treturn phydev_err_probe(phydev, ret,\n\t\t\t\t\t\t\"failed to get nvmem cell io_impedance_ctrl\\n\");\n\n\t\t \n\t\tif (of_property_read_bool(of_node, \"ti,max-output-impedance\"))\n\t\t\tdp83867->io_impedance = DP83867_IO_MUX_CFG_IO_IMPEDANCE_MAX;\n\t\telse if (of_property_read_bool(of_node, \"ti,min-output-impedance\"))\n\t\t\tdp83867->io_impedance = DP83867_IO_MUX_CFG_IO_IMPEDANCE_MIN;\n\t\telse\n\t\t\tdp83867->io_impedance = -1;  \n\n\t\treturn 0;\n\t}\n\n\tbuf = nvmem_cell_read(cell, NULL);\n\tnvmem_cell_put(cell);\n\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tval = *buf;\n\tkfree(buf);\n\n\tif ((val & DP83867_IO_MUX_CFG_IO_IMPEDANCE_MASK) != val) {\n\t\tphydev_err(phydev, \"nvmem cell 'io_impedance_ctrl' contents out of range\\n\");\n\t\treturn -ERANGE;\n\t}\n\tdp83867->io_impedance = val;\n\n\treturn 0;\n}\n\nstatic int dp83867_of_init(struct phy_device *phydev)\n{\n\tstruct dp83867_private *dp83867 = phydev->priv;\n\tstruct device *dev = &phydev->mdio.dev;\n\tstruct device_node *of_node = dev->of_node;\n\tint ret;\n\n\tif (!of_node)\n\t\treturn -ENODEV;\n\n\t \n\tret = of_property_read_u32(of_node, \"ti,clk-output-sel\",\n\t\t\t\t   &dp83867->clk_output_sel);\n\t \n\tif (!ret) {\n\t\tdp83867->set_clk_output = true;\n\t\t \n\t\tif (dp83867->clk_output_sel > DP83867_CLK_O_SEL_REF_CLK &&\n\t\t    dp83867->clk_output_sel != DP83867_CLK_O_SEL_OFF) {\n\t\t\tphydev_err(phydev, \"ti,clk-output-sel value %u out of range\\n\",\n\t\t\t\t   dp83867->clk_output_sel);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tret = dp83867_of_init_io_impedance(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tdp83867->rxctrl_strap_quirk = of_property_read_bool(of_node,\n\t\t\t\t\t\t\t    \"ti,dp83867-rxctrl-strap-quirk\");\n\n\tdp83867->sgmii_ref_clk_en = of_property_read_bool(of_node,\n\t\t\t\t\t\t\t  \"ti,sgmii-ref-clock-output-enable\");\n\n\tdp83867->rx_id_delay = DP83867_RGMII_RX_CLK_DELAY_INV;\n\tret = of_property_read_u32(of_node, \"ti,rx-internal-delay\",\n\t\t\t\t   &dp83867->rx_id_delay);\n\tif (!ret && dp83867->rx_id_delay > DP83867_RGMII_RX_CLK_DELAY_MAX) {\n\t\tphydev_err(phydev,\n\t\t\t   \"ti,rx-internal-delay value of %u out of range\\n\",\n\t\t\t   dp83867->rx_id_delay);\n\t\treturn -EINVAL;\n\t}\n\n\tdp83867->tx_id_delay = DP83867_RGMII_TX_CLK_DELAY_INV;\n\tret = of_property_read_u32(of_node, \"ti,tx-internal-delay\",\n\t\t\t\t   &dp83867->tx_id_delay);\n\tif (!ret && dp83867->tx_id_delay > DP83867_RGMII_TX_CLK_DELAY_MAX) {\n\t\tphydev_err(phydev,\n\t\t\t   \"ti,tx-internal-delay value of %u out of range\\n\",\n\t\t\t   dp83867->tx_id_delay);\n\t\treturn -EINVAL;\n\t}\n\n\tif (of_property_read_bool(of_node, \"enet-phy-lane-swap\"))\n\t\tdp83867->port_mirroring = DP83867_PORT_MIRROING_EN;\n\n\tif (of_property_read_bool(of_node, \"enet-phy-lane-no-swap\"))\n\t\tdp83867->port_mirroring = DP83867_PORT_MIRROING_DIS;\n\n\tret = of_property_read_u32(of_node, \"ti,fifo-depth\",\n\t\t\t\t   &dp83867->tx_fifo_depth);\n\tif (ret) {\n\t\tret = of_property_read_u32(of_node, \"tx-fifo-depth\",\n\t\t\t\t\t   &dp83867->tx_fifo_depth);\n\t\tif (ret)\n\t\t\tdp83867->tx_fifo_depth =\n\t\t\t\t\tDP83867_PHYCR_FIFO_DEPTH_4_B_NIB;\n\t}\n\n\tif (dp83867->tx_fifo_depth > DP83867_PHYCR_FIFO_DEPTH_MAX) {\n\t\tphydev_err(phydev, \"tx-fifo-depth value %u out of range\\n\",\n\t\t\t   dp83867->tx_fifo_depth);\n\t\treturn -EINVAL;\n\t}\n\n\tret = of_property_read_u32(of_node, \"rx-fifo-depth\",\n\t\t\t\t   &dp83867->rx_fifo_depth);\n\tif (ret)\n\t\tdp83867->rx_fifo_depth = DP83867_PHYCR_FIFO_DEPTH_4_B_NIB;\n\n\tif (dp83867->rx_fifo_depth > DP83867_PHYCR_FIFO_DEPTH_MAX) {\n\t\tphydev_err(phydev, \"rx-fifo-depth value %u out of range\\n\",\n\t\t\t   dp83867->rx_fifo_depth);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n#else\nstatic int dp83867_of_init(struct phy_device *phydev)\n{\n\tstruct dp83867_private *dp83867 = phydev->priv;\n\tu16 delay;\n\n\t \n\tdelay = phy_read_mmd(phydev, DP83867_DEVADDR, DP83867_RGMIIDCTL);\n\tdp83867->rx_id_delay = delay & DP83867_RGMII_RX_CLK_DELAY_MAX;\n\tdp83867->tx_id_delay = (delay >> DP83867_RGMII_TX_CLK_DELAY_SHIFT) &\n\t\t\t       DP83867_RGMII_TX_CLK_DELAY_MAX;\n\n\t \n\tdp83867->io_impedance = DP83867_IO_MUX_CFG_IO_IMPEDANCE_MIN / 2;\n\n\t \n\tdp83867->tx_fifo_depth = DP83867_PHYCR_FIFO_DEPTH_4_B_NIB;\n\tdp83867->rx_fifo_depth = DP83867_PHYCR_FIFO_DEPTH_4_B_NIB;\n\n\treturn 0;\n}\n#endif  \n\nstatic int dp83867_suspend(struct phy_device *phydev)\n{\n\t \n\tif (phy_interrupt_is_valid(phydev)) {\n\t\tphydev->interrupts = PHY_INTERRUPT_DISABLED;\n\t\tdp83867_config_intr(phydev);\n\t}\n\n\treturn genphy_suspend(phydev);\n}\n\nstatic int dp83867_resume(struct phy_device *phydev)\n{\n\t \n\tif (phy_interrupt_is_valid(phydev)) {\n\t\tphydev->interrupts = PHY_INTERRUPT_ENABLED;\n\t\tdp83867_config_intr(phydev);\n\t}\n\n\tgenphy_resume(phydev);\n\n\treturn 0;\n}\n\nstatic int dp83867_probe(struct phy_device *phydev)\n{\n\tstruct dp83867_private *dp83867;\n\n\tdp83867 = devm_kzalloc(&phydev->mdio.dev, sizeof(*dp83867),\n\t\t\t       GFP_KERNEL);\n\tif (!dp83867)\n\t\treturn -ENOMEM;\n\n\tphydev->priv = dp83867;\n\n\treturn dp83867_of_init(phydev);\n}\n\nstatic int dp83867_config_init(struct phy_device *phydev)\n{\n\tstruct dp83867_private *dp83867 = phydev->priv;\n\tint ret, val, bs;\n\tu16 delay;\n\n\t \n\tret = phy_modify(phydev, DP83867_CFG2, DP83867_DOWNSHIFT_EN,\n\t\t\t DP83867_DOWNSHIFT_EN);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dp83867_verify_rgmii_cfg(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (dp83867->rxctrl_strap_quirk)\n\t\tphy_clear_bits_mmd(phydev, DP83867_DEVADDR, DP83867_CFG4,\n\t\t\t\t   BIT(7));\n\n\tbs = phy_read_mmd(phydev, DP83867_DEVADDR, DP83867_STRAP_STS2);\n\tif (bs & DP83867_STRAP_STS2_STRAP_FLD) {\n\t\t \n\t\tret = phy_modify_mmd(phydev, DP83867_DEVADDR,\n\t\t\t\t     DP83867_FLD_THR_CFG,\n\t\t\t\t     DP83867_FLD_THR_CFG_ENERGY_LOST_THR_MASK,\n\t\t\t\t     0x1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (phy_interface_is_rgmii(phydev) ||\n\t    phydev->interface == PHY_INTERFACE_MODE_SGMII) {\n\t\tval = phy_read(phydev, MII_DP83867_PHYCTRL);\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tval &= ~DP83867_PHYCR_TX_FIFO_DEPTH_MASK;\n\t\tval |= (dp83867->tx_fifo_depth <<\n\t\t\tDP83867_PHYCR_TX_FIFO_DEPTH_SHIFT);\n\n\t\tif (phydev->interface == PHY_INTERFACE_MODE_SGMII) {\n\t\t\tval &= ~DP83867_PHYCR_RX_FIFO_DEPTH_MASK;\n\t\t\tval |= (dp83867->rx_fifo_depth <<\n\t\t\t\tDP83867_PHYCR_RX_FIFO_DEPTH_SHIFT);\n\t\t}\n\n\t\tret = phy_write(phydev, MII_DP83867_PHYCTRL, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (phy_interface_is_rgmii(phydev)) {\n\t\tval = phy_read(phydev, MII_DP83867_PHYCTRL);\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\t \n\n\t\tbs = phy_read_mmd(phydev, DP83867_DEVADDR, DP83867_STRAP_STS1);\n\t\tif (bs & DP83867_STRAP_STS1_RESERVED)\n\t\t\tval &= ~DP83867_PHYCR_RESERVED_MASK;\n\n\t\tret = phy_write(phydev, MII_DP83867_PHYCTRL, val);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tval = phy_read_mmd(phydev, DP83867_DEVADDR, DP83867_RGMIICTL);\n\n\t\tval &= ~(DP83867_RGMII_TX_CLK_DELAY_EN | DP83867_RGMII_RX_CLK_DELAY_EN);\n\t\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID)\n\t\t\tval |= (DP83867_RGMII_TX_CLK_DELAY_EN | DP83867_RGMII_RX_CLK_DELAY_EN);\n\n\t\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID)\n\t\t\tval |= DP83867_RGMII_TX_CLK_DELAY_EN;\n\n\t\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID)\n\t\t\tval |= DP83867_RGMII_RX_CLK_DELAY_EN;\n\n\t\tphy_write_mmd(phydev, DP83867_DEVADDR, DP83867_RGMIICTL, val);\n\n\t\tdelay = 0;\n\t\tif (dp83867->rx_id_delay != DP83867_RGMII_RX_CLK_DELAY_INV)\n\t\t\tdelay |= dp83867->rx_id_delay;\n\t\tif (dp83867->tx_id_delay != DP83867_RGMII_TX_CLK_DELAY_INV)\n\t\t\tdelay |= dp83867->tx_id_delay <<\n\t\t\t\t DP83867_RGMII_TX_CLK_DELAY_SHIFT;\n\n\t\tphy_write_mmd(phydev, DP83867_DEVADDR, DP83867_RGMIIDCTL,\n\t\t\t      delay);\n\t}\n\n\t \n\tif (dp83867->io_impedance >= 0)\n\t\tphy_modify_mmd(phydev, DP83867_DEVADDR, DP83867_IO_MUX_CFG,\n\t\t\t       DP83867_IO_MUX_CFG_IO_IMPEDANCE_MASK,\n\t\t\t       dp83867->io_impedance);\n\n\tif (phydev->interface == PHY_INTERFACE_MODE_SGMII) {\n\t\t \n\t\tret = phy_modify_mmd(phydev, DP83867_DEVADDR,\n\t\t\t\t     DP83867_10M_SGMII_CFG,\n\t\t\t\t     DP83867_10M_SGMII_RATE_ADAPT_MASK,\n\t\t\t\t     0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = phy_modify_mmd(phydev, DP83867_DEVADDR,\n\t\t\t\t     DP83867_CFG4,\n\t\t\t\t     DP83867_CFG4_SGMII_ANEG_MASK,\n\t\t\t\t     DP83867_CFG4_SGMII_ANEG_TIMER_16MS);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval = phy_read_mmd(phydev, DP83867_DEVADDR, DP83867_SGMIICTL);\n\t\t \n\t\tif (dp83867->sgmii_ref_clk_en)\n\t\t\tval |= DP83867_SGMII_TYPE;\n\t\telse\n\t\t\tval &= ~DP83867_SGMII_TYPE;\n\t\tphy_write_mmd(phydev, DP83867_DEVADDR, DP83867_SGMIICTL, val);\n\n\t\t \n\t\tif (dp83867->rxctrl_strap_quirk)\n\t\t\tphy_set_bits_mmd(phydev, DP83867_DEVADDR, DP83867_CFG4,\n\t\t\t\t\t BIT(8));\n\t}\n\n\tval = phy_read(phydev, DP83867_CFG3);\n\t \n\tif (phy_interrupt_is_valid(phydev))\n\t\tval |= DP83867_CFG3_INT_OE;\n\n\tval |= DP83867_CFG3_ROBUST_AUTO_MDIX;\n\tphy_write(phydev, DP83867_CFG3, val);\n\n\tif (dp83867->port_mirroring != DP83867_PORT_MIRROING_KEEP)\n\t\tdp83867_config_port_mirroring(phydev);\n\n\t \n\tif (dp83867->set_clk_output) {\n\t\tu16 mask = DP83867_IO_MUX_CFG_CLK_O_DISABLE;\n\n\t\tif (dp83867->clk_output_sel == DP83867_CLK_O_SEL_OFF) {\n\t\t\tval = DP83867_IO_MUX_CFG_CLK_O_DISABLE;\n\t\t} else {\n\t\t\tmask |= DP83867_IO_MUX_CFG_CLK_O_SEL_MASK;\n\t\t\tval = dp83867->clk_output_sel <<\n\t\t\t      DP83867_IO_MUX_CFG_CLK_O_SEL_SHIFT;\n\t\t}\n\n\t\tphy_modify_mmd(phydev, DP83867_DEVADDR, DP83867_IO_MUX_CFG,\n\t\t\t       mask, val);\n\t}\n\n\treturn 0;\n}\n\nstatic int dp83867_phy_reset(struct phy_device *phydev)\n{\n\tint err;\n\n\terr = phy_write(phydev, DP83867_CTRL, DP83867_SW_RESET);\n\tif (err < 0)\n\t\treturn err;\n\n\tusleep_range(10, 20);\n\n\terr = phy_modify(phydev, MII_DP83867_PHYCTRL,\n\t\t\t DP83867_PHYCR_FORCE_LINK_GOOD, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\terr = phy_write_mmd(phydev, DP83867_DEVADDR, DP83867_DSP_FFE_CFG,\n\t\t\t    0x0e81);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = phy_write(phydev, DP83867_CTRL, DP83867_SW_RESTART);\n\tif (err < 0)\n\t\treturn err;\n\n\tusleep_range(10, 20);\n\n\treturn 0;\n}\n\nstatic void dp83867_link_change_notify(struct phy_device *phydev)\n{\n\t \n\tif (phydev->interface == PHY_INTERFACE_MODE_SGMII) {\n\t\tint val = 0;\n\n\t\tval = phy_clear_bits(phydev, DP83867_CFG2,\n\t\t\t\t     DP83867_SGMII_AUTONEG_EN);\n\t\tif (val < 0)\n\t\t\treturn;\n\n\t\tphy_set_bits(phydev, DP83867_CFG2,\n\t\t\t     DP83867_SGMII_AUTONEG_EN);\n\t}\n}\n\nstatic int dp83867_loopback(struct phy_device *phydev, bool enable)\n{\n\treturn phy_modify(phydev, MII_BMCR, BMCR_LOOPBACK,\n\t\t\t  enable ? BMCR_LOOPBACK : 0);\n}\n\nstatic int\ndp83867_led_brightness_set(struct phy_device *phydev,\n\t\t\t   u8 index, enum led_brightness brightness)\n{\n\tu32 val;\n\n\tif (index >= DP83867_LED_COUNT)\n\t\treturn -EINVAL;\n\n\t \n\tval = DP83867_LED_DRV_EN(index);\n\n\tif (brightness)\n\t\tval |= DP83867_LED_DRV_VAL(index);\n\n\treturn phy_modify(phydev, DP83867_LEDCR2,\n\t\t\t  DP83867_LED_DRV_VAL(index) |\n\t\t\t  DP83867_LED_DRV_EN(index),\n\t\t\t  val);\n}\n\nstatic struct phy_driver dp83867_driver[] = {\n\t{\n\t\t.phy_id\t\t= DP83867_PHY_ID,\n\t\t.phy_id_mask\t= 0xfffffff0,\n\t\t.name\t\t= \"TI DP83867\",\n\t\t \n\n\t\t.probe          = dp83867_probe,\n\t\t.config_init\t= dp83867_config_init,\n\t\t.soft_reset\t= dp83867_phy_reset,\n\n\t\t.read_status\t= dp83867_read_status,\n\t\t.get_tunable\t= dp83867_get_tunable,\n\t\t.set_tunable\t= dp83867_set_tunable,\n\n\t\t.get_wol\t= dp83867_get_wol,\n\t\t.set_wol\t= dp83867_set_wol,\n\n\t\t \n\t\t.config_intr\t= dp83867_config_intr,\n\t\t.handle_interrupt = dp83867_handle_interrupt,\n\n\t\t.suspend\t= dp83867_suspend,\n\t\t.resume\t\t= dp83867_resume,\n\n\t\t.link_change_notify = dp83867_link_change_notify,\n\t\t.set_loopback\t= dp83867_loopback,\n\n\t\t.led_brightness_set = dp83867_led_brightness_set,\n\t},\n};\nmodule_phy_driver(dp83867_driver);\n\nstatic struct mdio_device_id __maybe_unused dp83867_tbl[] = {\n\t{ DP83867_PHY_ID, 0xfffffff0 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(mdio, dp83867_tbl);\n\nMODULE_DESCRIPTION(\"Texas Instruments DP83867 PHY driver\");\nMODULE_AUTHOR(\"Dan Murphy <dmurphy@ti.com\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}