{
  "module_name": "nxp-cbtx.c",
  "hash_id": "221dcad22b65afc4e06c2a5771b8f53539611bfb66bfb1e23fc1000cb219b54d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/nxp-cbtx.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/mii.h>\n#include <linux/module.h>\n#include <linux/phy.h>\n\n#define PHY_ID_CBTX_SJA1110\t\t\t0x001bb020\n\n \n#define  CBTX_MODE_CTRL_STAT\t\t\t0x11\n#define  CBTX_PDOWN_CTRL\t\t\t0x18\n#define  CBTX_RX_ERR_COUNTER\t\t\t0x1a\n#define  CBTX_IRQ_STAT\t\t\t\t0x1d\n#define  CBTX_IRQ_ENABLE\t\t\t0x1e\n\n \n#define CBTX_MODE_CTRL_STAT_AUTO_MDIX_EN\tBIT(7)\n#define CBTX_MODE_CTRL_STAT_MDIX_MODE\t\tBIT(6)\n\n#define CBTX_PDOWN_CTL_TRUE_PDOWN\t\tBIT(0)\n\n#define CBTX_IRQ_ENERGYON\t\t\tBIT(7)\n#define CBTX_IRQ_AN_COMPLETE\t\t\tBIT(6)\n#define CBTX_IRQ_REM_FAULT\t\t\tBIT(5)\n#define CBTX_IRQ_LINK_DOWN\t\t\tBIT(4)\n#define CBTX_IRQ_AN_LP_ACK\t\t\tBIT(3)\n#define CBTX_IRQ_PARALLEL_DETECT_FAULT\t\tBIT(2)\n#define CBTX_IRQ_AN_PAGE_RECV\t\t\tBIT(1)\n\nstatic int cbtx_soft_reset(struct phy_device *phydev)\n{\n\tint ret;\n\n\t \n\tret = phy_clear_bits(phydev, CBTX_PDOWN_CTRL,\n\t\t\t     CBTX_PDOWN_CTL_TRUE_PDOWN);\n\tif (ret)\n\t\treturn ret;\n\n\treturn genphy_soft_reset(phydev);\n}\n\nstatic int cbtx_config_init(struct phy_device *phydev)\n{\n\t \n\tphydev->mdix_ctrl = ETH_TP_MDI_AUTO;\n\n\treturn 0;\n}\n\nstatic int cbtx_mdix_status(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = phy_read(phydev, CBTX_MODE_CTRL_STAT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & CBTX_MODE_CTRL_STAT_MDIX_MODE)\n\t\tphydev->mdix = ETH_TP_MDI_X;\n\telse\n\t\tphydev->mdix = ETH_TP_MDI;\n\n\treturn 0;\n}\n\nstatic int cbtx_read_status(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = cbtx_mdix_status(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn genphy_read_status(phydev);\n}\n\nstatic int cbtx_mdix_config(struct phy_device *phydev)\n{\n\tint ret;\n\n\tswitch (phydev->mdix_ctrl) {\n\tcase ETH_TP_MDI_AUTO:\n\t\treturn phy_set_bits(phydev, CBTX_MODE_CTRL_STAT,\n\t\t\t\t    CBTX_MODE_CTRL_STAT_AUTO_MDIX_EN);\n\tcase ETH_TP_MDI:\n\t\tret = phy_clear_bits(phydev, CBTX_MODE_CTRL_STAT,\n\t\t\t\t     CBTX_MODE_CTRL_STAT_AUTO_MDIX_EN);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn phy_clear_bits(phydev, CBTX_MODE_CTRL_STAT,\n\t\t\t\t      CBTX_MODE_CTRL_STAT_MDIX_MODE);\n\tcase ETH_TP_MDI_X:\n\t\tret = phy_clear_bits(phydev, CBTX_MODE_CTRL_STAT,\n\t\t\t\t     CBTX_MODE_CTRL_STAT_AUTO_MDIX_EN);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn phy_set_bits(phydev, CBTX_MODE_CTRL_STAT,\n\t\t\t\t    CBTX_MODE_CTRL_STAT_MDIX_MODE);\n\t}\n\n\treturn 0;\n}\n\nstatic int cbtx_config_aneg(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = cbtx_mdix_config(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn genphy_config_aneg(phydev);\n}\n\nstatic int cbtx_ack_interrupts(struct phy_device *phydev)\n{\n\treturn phy_read(phydev, CBTX_IRQ_STAT);\n}\n\nstatic int cbtx_config_intr(struct phy_device *phydev)\n{\n\tint ret;\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\tret = cbtx_ack_interrupts(phydev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = phy_write(phydev, CBTX_IRQ_ENABLE, CBTX_IRQ_LINK_DOWN |\n\t\t\t\tCBTX_IRQ_AN_COMPLETE | CBTX_IRQ_ENERGYON);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = phy_write(phydev, CBTX_IRQ_ENABLE, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = cbtx_ack_interrupts(phydev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t cbtx_handle_interrupt(struct phy_device *phydev)\n{\n\tint irq_stat, irq_enabled;\n\n\tirq_stat = cbtx_ack_interrupts(phydev);\n\tif (irq_stat < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tirq_enabled = phy_read(phydev, CBTX_IRQ_ENABLE);\n\tif (irq_enabled < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (!(irq_enabled & irq_stat))\n\t\treturn IRQ_NONE;\n\n\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int cbtx_get_sset_count(struct phy_device *phydev)\n{\n\treturn 1;\n}\n\nstatic void cbtx_get_strings(struct phy_device *phydev, u8 *data)\n{\n\tstrncpy(data, \"100btx_rx_err\", ETH_GSTRING_LEN);\n}\n\nstatic void cbtx_get_stats(struct phy_device *phydev,\n\t\t\t   struct ethtool_stats *stats, u64 *data)\n{\n\tint ret;\n\n\tret = phy_read(phydev, CBTX_RX_ERR_COUNTER);\n\tdata[0] = (ret < 0) ? U64_MAX : ret;\n}\n\nstatic struct phy_driver cbtx_driver[] = {\n\t{\n\t\tPHY_ID_MATCH_MODEL(PHY_ID_CBTX_SJA1110),\n\t\t.name\t\t\t= \"NXP CBTX (SJA1110)\",\n\t\t \n\t\t.soft_reset\t\t= cbtx_soft_reset,\n\t\t.config_init\t\t= cbtx_config_init,\n\t\t.suspend\t\t= genphy_suspend,\n\t\t.resume\t\t\t= genphy_resume,\n\t\t.config_intr\t\t= cbtx_config_intr,\n\t\t.handle_interrupt\t= cbtx_handle_interrupt,\n\t\t.read_status\t\t= cbtx_read_status,\n\t\t.config_aneg\t\t= cbtx_config_aneg,\n\t\t.get_sset_count\t\t= cbtx_get_sset_count,\n\t\t.get_strings\t\t= cbtx_get_strings,\n\t\t.get_stats\t\t= cbtx_get_stats,\n\t},\n};\n\nmodule_phy_driver(cbtx_driver);\n\nstatic struct mdio_device_id __maybe_unused cbtx_tbl[] = {\n\t{ PHY_ID_MATCH_MODEL(PHY_ID_CBTX_SJA1110) },\n\t{ },\n};\n\nMODULE_DEVICE_TABLE(mdio, cbtx_tbl);\n\nMODULE_AUTHOR(\"Vladimir Oltean <vladimir.oltean@nxp.com>\");\nMODULE_DESCRIPTION(\"NXP CBTX PHY driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}