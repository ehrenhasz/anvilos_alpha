{
  "module_name": "bcm-phy-ptp.c",
  "hash_id": "0c24f477fccbb4f7adcd3e45baefee7aacbec37e320b96270432bbc5bc28fb08",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/bcm-phy-ptp.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/mii.h>\n#include <linux/phy.h>\n#include <linux/ptp_classify.h>\n#include <linux/ptp_clock_kernel.h>\n#include <linux/net_tstamp.h>\n#include <linux/netdevice.h>\n#include <linux/workqueue.h>\n\n#include \"bcm-phy-lib.h\"\n\n \n#define SLICE_CTRL\t\t0x0810\n#define  SLICE_TX_EN\t\t\tBIT(0)\n#define  SLICE_RX_EN\t\t\tBIT(8)\n#define TX_EVENT_MODE\t\t0x0811\n#define  MODE_TX_UPDATE_CF\t\tBIT(0)\n#define  MODE_TX_REPLACE_TS_CF\t\tBIT(1)\n#define  MODE_TX_REPLACE_TS\t\tGENMASK(1, 0)\n#define RX_EVENT_MODE\t\t0x0819\n#define  MODE_RX_UPDATE_CF\t\tBIT(0)\n#define  MODE_RX_INSERT_TS_48\t\tBIT(1)\n#define  MODE_RX_INSERT_TS_64\t\tGENMASK(1, 0)\n\n#define MODE_EVT_SHIFT_SYNC\t\t0\n#define MODE_EVT_SHIFT_DELAY_REQ\t2\n#define MODE_EVT_SHIFT_PDELAY_REQ\t4\n#define MODE_EVT_SHIFT_PDELAY_RESP\t6\n\n#define MODE_SEL_SHIFT_PORT\t\t0\n#define MODE_SEL_SHIFT_CPU\t\t8\n\n#define RX_MODE_SEL(sel, evt, act) \\\n\t(((MODE_RX_##act) << (MODE_EVT_SHIFT_##evt)) << (MODE_SEL_SHIFT_##sel))\n\n#define TX_MODE_SEL(sel, evt, act) \\\n\t(((MODE_TX_##act) << (MODE_EVT_SHIFT_##evt)) << (MODE_SEL_SHIFT_##sel))\n\n \n#define TX_TS_CAPTURE\t\t0x0821\n#define  TX_TS_CAP_EN\t\t\tBIT(0)\n#define RX_TS_CAPTURE\t\t0x0822\n#define  RX_TS_CAP_EN\t\t\tBIT(0)\n\n#define TIME_CODE_0\t\t0x0854\n#define TIME_CODE_1\t\t0x0855\n#define TIME_CODE_2\t\t0x0856\n#define TIME_CODE_3\t\t0x0857\n#define TIME_CODE_4\t\t0x0858\n\n#define DPLL_SELECT\t\t0x085b\n#define  DPLL_HB_MODE2\t\t\tBIT(6)\n\n#define SHADOW_CTRL\t\t0x085c\n#define SHADOW_LOAD\t\t0x085d\n#define  TIME_CODE_LOAD\t\t\tBIT(10)\n#define  SYNC_OUT_LOAD\t\t\tBIT(9)\n#define  NCO_TIME_LOAD\t\t\tBIT(7)\n#define  FREQ_LOAD\t\t\tBIT(6)\n#define INTR_MASK\t\t0x085e\n#define INTR_STATUS\t\t0x085f\n#define  INTC_FSYNC\t\t\tBIT(0)\n#define  INTC_SOP\t\t\tBIT(1)\n\n#define NCO_FREQ_LSB\t\t0x0873\n#define NCO_FREQ_MSB\t\t0x0874\n\n#define NCO_TIME_0\t\t0x0875\n#define NCO_TIME_1\t\t0x0876\n#define NCO_TIME_2_CTRL\t\t0x0877\n#define  FREQ_MDIO_SEL\t\t\tBIT(14)\n\n#define SYNC_OUT_0\t\t0x0878\n#define SYNC_OUT_1\t\t0x0879\n#define SYNC_OUT_2\t\t0x087a\n\n#define SYNC_IN_DIVIDER\t\t0x087b\n\n#define SYNOUT_TS_0\t\t0x087c\n#define SYNOUT_TS_1\t\t0x087d\n#define SYNOUT_TS_2\t\t0x087e\n\n#define NSE_CTRL\t\t0x087f\n#define  NSE_GMODE_EN\t\t\tGENMASK(15, 14)\n#define  NSE_CAPTURE_EN\t\t\tBIT(13)\n#define  NSE_INIT\t\t\tBIT(12)\n#define  NSE_CPU_FRAMESYNC\t\tBIT(5)\n#define  NSE_SYNC1_FRAMESYNC\t\tBIT(3)\n#define  NSE_FRAMESYNC_MASK\t\tGENMASK(5, 2)\n#define  NSE_PEROUT_EN\t\t\tBIT(1)\n#define  NSE_ONESHOT_EN\t\t\tBIT(0)\n#define  NSE_SYNC_OUT_MASK\t\tGENMASK(1, 0)\n\n#define TS_READ_CTRL\t\t0x0885\n#define  TS_READ_START\t\t\tBIT(0)\n#define  TS_READ_END\t\t\tBIT(1)\n\n#define HB_REG_0\t\t0x0886\n#define HB_REG_1\t\t0x0887\n#define HB_REG_2\t\t0x0888\n#define HB_REG_3\t\t0x08ec\n#define HB_REG_4\t\t0x08ed\n#define HB_STAT_CTRL\t\t0x088e\n#define  HB_READ_START\t\t\tBIT(10)\n#define  HB_READ_END\t\t\tBIT(11)\n#define  HB_READ_MASK\t\t\tGENMASK(11, 10)\n\n#define TS_REG_0\t\t0x0889\n#define TS_REG_1\t\t0x088a\n#define TS_REG_2\t\t0x088b\n#define TS_REG_3\t\t0x08c4\n\n#define TS_INFO_0\t\t0x088c\n#define TS_INFO_1\t\t0x088d\n\n#define TIMECODE_CTRL\t\t0x08c3\n#define  TX_TIMECODE_SEL\t\tGENMASK(7, 0)\n#define  RX_TIMECODE_SEL\t\tGENMASK(15, 8)\n\n#define TIME_SYNC\t\t0x0ff5\n#define  TIME_SYNC_EN\t\t\tBIT(0)\n\nstruct bcm_ptp_private {\n\tstruct phy_device *phydev;\n\tstruct mii_timestamper mii_ts;\n\tstruct ptp_clock *ptp_clock;\n\tstruct ptp_clock_info ptp_info;\n\tstruct ptp_pin_desc pin;\n\tstruct mutex mutex;\n\tstruct sk_buff_head tx_queue;\n\tint tx_type;\n\tbool hwts_rx;\n\tu16 nse_ctrl;\n\tbool pin_active;\n\tstruct delayed_work pin_work;\n};\n\nstruct bcm_ptp_skb_cb {\n\tunsigned long timeout;\n\tu16 seq_id;\n\tu8 msgtype;\n\tbool discard;\n};\n\nstruct bcm_ptp_capture {\n\tktime_t\thwtstamp;\n\tu16 seq_id;\n\tu8 msgtype;\n\tbool tx_dir;\n};\n\n#define BCM_SKB_CB(skb)\t\t((struct bcm_ptp_skb_cb *)(skb)->cb)\n#define SKB_TS_TIMEOUT\t\t10\t\t\t \n\n#define BCM_MAX_PULSE_8NS\t((1U << 9) - 1)\n#define BCM_MAX_PERIOD_8NS\t((1U << 30) - 1)\n\n#define BRCM_PHY_MODEL(phydev) \\\n\t((phydev)->drv->phy_id & (phydev)->drv->phy_id_mask)\n\nstatic struct bcm_ptp_private *mii2priv(struct mii_timestamper *mii_ts)\n{\n\treturn container_of(mii_ts, struct bcm_ptp_private, mii_ts);\n}\n\nstatic struct bcm_ptp_private *ptp2priv(struct ptp_clock_info *info)\n{\n\treturn container_of(info, struct bcm_ptp_private, ptp_info);\n}\n\nstatic void bcm_ptp_get_framesync_ts(struct phy_device *phydev,\n\t\t\t\t     struct timespec64 *ts)\n{\n\tu16 hb[4];\n\n\tbcm_phy_write_exp(phydev, HB_STAT_CTRL, HB_READ_START);\n\n\thb[0] = bcm_phy_read_exp(phydev, HB_REG_0);\n\thb[1] = bcm_phy_read_exp(phydev, HB_REG_1);\n\thb[2] = bcm_phy_read_exp(phydev, HB_REG_2);\n\thb[3] = bcm_phy_read_exp(phydev, HB_REG_3);\n\n\tbcm_phy_write_exp(phydev, HB_STAT_CTRL, HB_READ_END);\n\tbcm_phy_write_exp(phydev, HB_STAT_CTRL, 0);\n\n\tts->tv_sec = (hb[3] << 16) | hb[2];\n\tts->tv_nsec = (hb[1] << 16) | hb[0];\n}\n\nstatic u16 bcm_ptp_framesync_disable(struct phy_device *phydev, u16 orig_ctrl)\n{\n\tu16 ctrl = orig_ctrl & ~(NSE_FRAMESYNC_MASK | NSE_CAPTURE_EN);\n\n\tbcm_phy_write_exp(phydev, NSE_CTRL, ctrl);\n\n\treturn ctrl;\n}\n\nstatic void bcm_ptp_framesync_restore(struct phy_device *phydev, u16 orig_ctrl)\n{\n\tif (orig_ctrl & NSE_FRAMESYNC_MASK)\n\t\tbcm_phy_write_exp(phydev, NSE_CTRL, orig_ctrl);\n}\n\nstatic void bcm_ptp_framesync(struct phy_device *phydev, u16 ctrl)\n{\n\t \n\tbcm_phy_write_exp(phydev, NSE_CTRL, ctrl | NSE_CPU_FRAMESYNC);\n}\n\nstatic int bcm_ptp_framesync_ts(struct phy_device *phydev,\n\t\t\t\tstruct ptp_system_timestamp *sts,\n\t\t\t\tstruct timespec64 *ts,\n\t\t\t\tu16 orig_ctrl)\n{\n\tu16 ctrl, reg;\n\tint i;\n\n\tctrl = bcm_ptp_framesync_disable(phydev, orig_ctrl);\n\n\tptp_read_system_prets(sts);\n\n\t \n\tbcm_ptp_framesync(phydev, ctrl | NSE_CAPTURE_EN);\n\n\tptp_read_system_postts(sts);\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\treg = bcm_phy_read_exp(phydev, INTR_STATUS);\n\t\tif (reg & INTC_FSYNC) {\n\t\t\tbcm_ptp_get_framesync_ts(phydev, ts);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tbcm_ptp_framesync_restore(phydev, orig_ctrl);\n\n\treturn reg & INTC_FSYNC ? 0 : -ETIMEDOUT;\n}\n\nstatic int bcm_ptp_gettimex(struct ptp_clock_info *info,\n\t\t\t    struct timespec64 *ts,\n\t\t\t    struct ptp_system_timestamp *sts)\n{\n\tstruct bcm_ptp_private *priv = ptp2priv(info);\n\tint err;\n\n\tmutex_lock(&priv->mutex);\n\terr = bcm_ptp_framesync_ts(priv->phydev, sts, ts, priv->nse_ctrl);\n\tmutex_unlock(&priv->mutex);\n\n\treturn err;\n}\n\nstatic int bcm_ptp_settime_locked(struct bcm_ptp_private *priv,\n\t\t\t\t  const struct timespec64 *ts)\n{\n\tstruct phy_device *phydev = priv->phydev;\n\tu16 ctrl;\n\tu64 ns;\n\n\tctrl = bcm_ptp_framesync_disable(phydev, priv->nse_ctrl);\n\n\t \n\tbcm_phy_write_exp(phydev, TIME_CODE_0, ts->tv_nsec);\n\tbcm_phy_write_exp(phydev, TIME_CODE_1, ts->tv_nsec >> 16);\n\tbcm_phy_write_exp(phydev, TIME_CODE_2, ts->tv_sec);\n\tbcm_phy_write_exp(phydev, TIME_CODE_3, ts->tv_sec >> 16);\n\tbcm_phy_write_exp(phydev, TIME_CODE_4, ts->tv_sec >> 32);\n\n\t \n\tns = timespec64_to_ns(ts);\n\tbcm_phy_write_exp(phydev, NCO_TIME_0, ns >> 4);\n\tbcm_phy_write_exp(phydev, NCO_TIME_1, ns >> 20);\n\tbcm_phy_write_exp(phydev, NCO_TIME_2_CTRL, (ns >> 36) & 0xfff);\n\n\t \n\tbcm_phy_write_exp(phydev, SHADOW_LOAD, TIME_CODE_LOAD | NCO_TIME_LOAD);\n\n\t \n\tbcm_ptp_framesync(phydev, ctrl | NSE_INIT);\n\n\tbcm_ptp_framesync_restore(phydev, priv->nse_ctrl);\n\n\treturn 0;\n}\n\nstatic int bcm_ptp_settime(struct ptp_clock_info *info,\n\t\t\t   const struct timespec64 *ts)\n{\n\tstruct bcm_ptp_private *priv = ptp2priv(info);\n\tint err;\n\n\tmutex_lock(&priv->mutex);\n\terr = bcm_ptp_settime_locked(priv, ts);\n\tmutex_unlock(&priv->mutex);\n\n\treturn err;\n}\n\nstatic int bcm_ptp_adjtime_locked(struct bcm_ptp_private *priv,\n\t\t\t\t  s64 delta_ns)\n{\n\tstruct timespec64 ts;\n\tint err;\n\ts64 ns;\n\n\terr = bcm_ptp_framesync_ts(priv->phydev, NULL, &ts, priv->nse_ctrl);\n\tif (!err) {\n\t\tns = timespec64_to_ns(&ts) + delta_ns;\n\t\tts = ns_to_timespec64(ns);\n\t\terr = bcm_ptp_settime_locked(priv, &ts);\n\t}\n\treturn err;\n}\n\nstatic int bcm_ptp_adjtime(struct ptp_clock_info *info, s64 delta_ns)\n{\n\tstruct bcm_ptp_private *priv = ptp2priv(info);\n\tint err;\n\n\tmutex_lock(&priv->mutex);\n\terr = bcm_ptp_adjtime_locked(priv, delta_ns);\n\tmutex_unlock(&priv->mutex);\n\n\treturn err;\n}\n\n \nstatic int bcm_ptp_adjfine(struct ptp_clock_info *info, long scaled_ppm)\n{\n\tstruct bcm_ptp_private *priv = ptp2priv(info);\n\tint neg_adj = 0;\n\tu32 diff, freq;\n\tu16 ctrl;\n\tu64 adj;\n\n\tif (scaled_ppm < 0) {\n\t\tneg_adj = 1;\n\t\tscaled_ppm = -scaled_ppm;\n\t}\n\n\tadj = scaled_ppm << 9;\n\tdiff = div_u64(adj, 15625);\n\tfreq = (8 << 28) + (neg_adj ? -diff : diff);\n\n\tmutex_lock(&priv->mutex);\n\n\tctrl = bcm_ptp_framesync_disable(priv->phydev, priv->nse_ctrl);\n\n\tbcm_phy_write_exp(priv->phydev, NCO_FREQ_LSB, freq);\n\tbcm_phy_write_exp(priv->phydev, NCO_FREQ_MSB, freq >> 16);\n\n\tbcm_phy_write_exp(priv->phydev, NCO_TIME_2_CTRL, FREQ_MDIO_SEL);\n\n\t \n\tbcm_phy_write_exp(priv->phydev, SHADOW_LOAD, FREQ_LOAD);\n\n\tbcm_ptp_framesync(priv->phydev, ctrl);\n\n\t \n\tbcm_phy_write_exp(priv->phydev, SHADOW_LOAD, 0);\n\n\tbcm_ptp_framesync_restore(priv->phydev, priv->nse_ctrl);\n\n\tmutex_unlock(&priv->mutex);\n\n\treturn 0;\n}\n\nstatic bool bcm_ptp_rxtstamp(struct mii_timestamper *mii_ts,\n\t\t\t     struct sk_buff *skb, int type)\n{\n\tstruct bcm_ptp_private *priv = mii2priv(mii_ts);\n\tstruct skb_shared_hwtstamps *hwts;\n\tstruct ptp_header *header;\n\tu32 sec, nsec;\n\tu8 *data;\n\tint off;\n\n\tif (!priv->hwts_rx)\n\t\treturn false;\n\n\theader = ptp_parse_header(skb, type);\n\tif (!header)\n\t\treturn false;\n\n\tdata = (u8 *)(header + 1);\n\tsec = get_unaligned_be32(data);\n\tnsec = get_unaligned_be32(data + 4);\n\n\thwts = skb_hwtstamps(skb);\n\thwts->hwtstamp = ktime_set(sec, nsec);\n\n\toff = data - skb->data + 8;\n\tif (off < skb->len) {\n\t\tmemmove(data, data + 8, skb->len - off);\n\t\t__pskb_trim(skb, skb->len - 8);\n\t}\n\n\treturn false;\n}\n\nstatic bool bcm_ptp_get_tstamp(struct bcm_ptp_private *priv,\n\t\t\t       struct bcm_ptp_capture *capts)\n{\n\tstruct phy_device *phydev = priv->phydev;\n\tu16 ts[4], reg;\n\tu32 sec, nsec;\n\n\tmutex_lock(&priv->mutex);\n\n\treg = bcm_phy_read_exp(phydev, INTR_STATUS);\n\tif ((reg & INTC_SOP) == 0) {\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn false;\n\t}\n\n\tbcm_phy_write_exp(phydev, TS_READ_CTRL, TS_READ_START);\n\n\tts[0] = bcm_phy_read_exp(phydev, TS_REG_0);\n\tts[1] = bcm_phy_read_exp(phydev, TS_REG_1);\n\tts[2] = bcm_phy_read_exp(phydev, TS_REG_2);\n\tts[3] = bcm_phy_read_exp(phydev, TS_REG_3);\n\n\t \n\tcapts->seq_id = bcm_phy_read_exp(priv->phydev, TS_INFO_0);\n\n\treg = bcm_phy_read_exp(phydev, TS_INFO_1);\n\tcapts->msgtype = reg >> 12;\n\tcapts->tx_dir = !!(reg & BIT(11));\n\n\tbcm_phy_write_exp(phydev, TS_READ_CTRL, TS_READ_END);\n\tbcm_phy_write_exp(phydev, TS_READ_CTRL, 0);\n\n\tmutex_unlock(&priv->mutex);\n\n\tsec = (ts[3] << 16) | ts[2];\n\tnsec = (ts[1] << 16) | ts[0];\n\tcapts->hwtstamp = ktime_set(sec, nsec);\n\n\treturn true;\n}\n\nstatic void bcm_ptp_match_tstamp(struct bcm_ptp_private *priv,\n\t\t\t\t struct bcm_ptp_capture *capts)\n{\n\tstruct skb_shared_hwtstamps hwts;\n\tstruct sk_buff *skb, *ts_skb;\n\tunsigned long flags;\n\tbool first = false;\n\n\tts_skb = NULL;\n\tspin_lock_irqsave(&priv->tx_queue.lock, flags);\n\tskb_queue_walk(&priv->tx_queue, skb) {\n\t\tif (BCM_SKB_CB(skb)->seq_id == capts->seq_id &&\n\t\t    BCM_SKB_CB(skb)->msgtype == capts->msgtype) {\n\t\t\tfirst = skb_queue_is_first(&priv->tx_queue, skb);\n\t\t\t__skb_unlink(skb, &priv->tx_queue);\n\t\t\tts_skb = skb;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&priv->tx_queue.lock, flags);\n\n\t \n\tif (ts_skb) {\n\t\tif (BCM_SKB_CB(ts_skb)->discard) {\n\t\t\tkfree_skb(ts_skb);\n\t\t} else {\n\t\t\tmemset(&hwts, 0, sizeof(hwts));\n\t\t\thwts.hwtstamp = capts->hwtstamp;\n\t\t\tskb_complete_tx_timestamp(ts_skb, &hwts);\n\t\t}\n\t}\n\n\t \n\tif (!first) {\n\t\twhile ((skb = skb_dequeue(&priv->tx_queue))) {\n\t\t\tif (!time_after(jiffies, BCM_SKB_CB(skb)->timeout)) {\n\t\t\t\tskb_queue_head(&priv->tx_queue, skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n}\n\nstatic long bcm_ptp_do_aux_work(struct ptp_clock_info *info)\n{\n\tstruct bcm_ptp_private *priv = ptp2priv(info);\n\tstruct bcm_ptp_capture capts;\n\tbool reschedule = false;\n\n\twhile (!skb_queue_empty_lockless(&priv->tx_queue)) {\n\t\tif (!bcm_ptp_get_tstamp(priv, &capts)) {\n\t\t\treschedule = true;\n\t\t\tbreak;\n\t\t}\n\t\tbcm_ptp_match_tstamp(priv, &capts);\n\t}\n\n\treturn reschedule ? 1 : -1;\n}\n\nstatic int bcm_ptp_cancel_func(struct bcm_ptp_private *priv)\n{\n\tif (!priv->pin_active)\n\t\treturn 0;\n\n\tpriv->pin_active = false;\n\n\tpriv->nse_ctrl &= ~(NSE_SYNC_OUT_MASK | NSE_SYNC1_FRAMESYNC |\n\t\t\t    NSE_CAPTURE_EN);\n\tbcm_phy_write_exp(priv->phydev, NSE_CTRL, priv->nse_ctrl);\n\n\tcancel_delayed_work_sync(&priv->pin_work);\n\n\treturn 0;\n}\n\nstatic void bcm_ptp_perout_work(struct work_struct *pin_work)\n{\n\tstruct bcm_ptp_private *priv =\n\t\tcontainer_of(pin_work, struct bcm_ptp_private, pin_work.work);\n\tstruct phy_device *phydev = priv->phydev;\n\tstruct timespec64 ts;\n\tu64 ns, next;\n\tu16 ctrl;\n\n\tmutex_lock(&priv->mutex);\n\n\t \n\tif (!priv->pin_active) {\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn;\n\t}\n\n\tbcm_ptp_framesync_ts(phydev, NULL, &ts, priv->nse_ctrl);\n\n\t \n\tnext = NSEC_PER_SEC - ts.tv_nsec;\n\tts.tv_sec += next < NSEC_PER_MSEC ? 2 : 1;\n\tts.tv_nsec = 0;\n\n\tns = timespec64_to_ns(&ts);\n\n\t \n\tctrl = bcm_ptp_framesync_disable(phydev,\n\t\t\t\t\t priv->nse_ctrl & ~NSE_ONESHOT_EN);\n\n\tbcm_phy_write_exp(phydev, SYNOUT_TS_0, ns & 0xfff0);\n\tbcm_phy_write_exp(phydev, SYNOUT_TS_1, ns >> 16);\n\tbcm_phy_write_exp(phydev, SYNOUT_TS_2, ns >> 32);\n\n\t \n\tbcm_phy_write_exp(phydev, SHADOW_LOAD, SYNC_OUT_LOAD);\n\n\tbcm_ptp_framesync(phydev, ctrl | NSE_ONESHOT_EN | NSE_INIT);\n\n\tpriv->nse_ctrl |= NSE_ONESHOT_EN;\n\tbcm_ptp_framesync_restore(phydev, priv->nse_ctrl);\n\n\tmutex_unlock(&priv->mutex);\n\n\tnext = next + NSEC_PER_MSEC;\n\tschedule_delayed_work(&priv->pin_work, nsecs_to_jiffies(next));\n}\n\nstatic int bcm_ptp_perout_locked(struct bcm_ptp_private *priv,\n\t\t\t\t struct ptp_perout_request *req, int on)\n{\n\tstruct phy_device *phydev = priv->phydev;\n\tu64 period, pulse;\n\tu16 val;\n\n\tif (!on)\n\t\treturn bcm_ptp_cancel_func(priv);\n\n\t \n\tif (req->period.sec != 1 || req->period.nsec != 0)\n\t\treturn -EINVAL;\n\n\tperiod = BCM_MAX_PERIOD_8NS;\t \n\n\tif (req->flags & PTP_PEROUT_PHASE)\n\t\treturn -EOPNOTSUPP;\n\n\tif (req->flags & PTP_PEROUT_DUTY_CYCLE)\n\t\tpulse = ktime_to_ns(ktime_set(req->on.sec, req->on.nsec));\n\telse\n\t\tpulse = (u64)BCM_MAX_PULSE_8NS << 3;\n\n\t \n\tpulse >>= 3;\n\n\tif (!pulse || pulse > period || pulse > BCM_MAX_PULSE_8NS)\n\t\treturn -EINVAL;\n\n\tbcm_phy_write_exp(phydev, SYNC_OUT_0, period);\n\n\tval = ((pulse & 0x3) << 14) | ((period >> 16) & 0x3fff);\n\tbcm_phy_write_exp(phydev, SYNC_OUT_1, val);\n\n\tval = ((pulse >> 2) & 0x7f) | (pulse << 7);\n\tbcm_phy_write_exp(phydev, SYNC_OUT_2, val);\n\n\tif (priv->pin_active)\n\t\tcancel_delayed_work_sync(&priv->pin_work);\n\n\tpriv->pin_active = true;\n\tINIT_DELAYED_WORK(&priv->pin_work, bcm_ptp_perout_work);\n\tschedule_delayed_work(&priv->pin_work, 0);\n\n\treturn 0;\n}\n\nstatic void bcm_ptp_extts_work(struct work_struct *pin_work)\n{\n\tstruct bcm_ptp_private *priv =\n\t\tcontainer_of(pin_work, struct bcm_ptp_private, pin_work.work);\n\tstruct phy_device *phydev = priv->phydev;\n\tstruct ptp_clock_event event;\n\tstruct timespec64 ts;\n\tu16 reg;\n\n\tmutex_lock(&priv->mutex);\n\n\t \n\tif (!priv->pin_active) {\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn;\n\t}\n\n\treg = bcm_phy_read_exp(phydev, INTR_STATUS);\n\tif ((reg & INTC_FSYNC) == 0)\n\t\tgoto out;\n\n\tbcm_ptp_get_framesync_ts(phydev, &ts);\n\n\tevent.index = 0;\n\tevent.type = PTP_CLOCK_EXTTS;\n\tevent.timestamp = timespec64_to_ns(&ts);\n\tptp_clock_event(priv->ptp_clock, &event);\n\nout:\n\tmutex_unlock(&priv->mutex);\n\tschedule_delayed_work(&priv->pin_work, HZ / 4);\n}\n\nstatic int bcm_ptp_extts_locked(struct bcm_ptp_private *priv, int on)\n{\n\tstruct phy_device *phydev = priv->phydev;\n\n\tif (!on)\n\t\treturn bcm_ptp_cancel_func(priv);\n\n\tif (priv->pin_active)\n\t\tcancel_delayed_work_sync(&priv->pin_work);\n\n\tbcm_ptp_framesync_disable(phydev, priv->nse_ctrl);\n\n\tpriv->nse_ctrl |= NSE_SYNC1_FRAMESYNC | NSE_CAPTURE_EN;\n\n\tbcm_ptp_framesync_restore(phydev, priv->nse_ctrl);\n\n\tpriv->pin_active = true;\n\tINIT_DELAYED_WORK(&priv->pin_work, bcm_ptp_extts_work);\n\tschedule_delayed_work(&priv->pin_work, 0);\n\n\treturn 0;\n}\n\nstatic int bcm_ptp_enable(struct ptp_clock_info *info,\n\t\t\t  struct ptp_clock_request *rq, int on)\n{\n\tstruct bcm_ptp_private *priv = ptp2priv(info);\n\tint err = -EBUSY;\n\n\tmutex_lock(&priv->mutex);\n\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_PEROUT:\n\t\tif (priv->pin.func == PTP_PF_PEROUT)\n\t\t\terr = bcm_ptp_perout_locked(priv, &rq->perout, on);\n\t\tbreak;\n\tcase PTP_CLK_REQ_EXTTS:\n\t\tif (priv->pin.func == PTP_PF_EXTTS)\n\t\t\terr = bcm_ptp_extts_locked(priv, on);\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&priv->mutex);\n\n\treturn err;\n}\n\nstatic int bcm_ptp_verify(struct ptp_clock_info *info, unsigned int pin,\n\t\t\t  enum ptp_pin_function func, unsigned int chan)\n{\n\tswitch (func) {\n\tcase PTP_PF_NONE:\n\tcase PTP_PF_EXTTS:\n\tcase PTP_PF_PEROUT:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic const struct ptp_clock_info bcm_ptp_clock_info = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= KBUILD_MODNAME,\n\t.max_adj\t= 100000000,\n\t.gettimex64\t= bcm_ptp_gettimex,\n\t.settime64\t= bcm_ptp_settime,\n\t.adjtime\t= bcm_ptp_adjtime,\n\t.adjfine\t= bcm_ptp_adjfine,\n\t.enable\t\t= bcm_ptp_enable,\n\t.verify\t\t= bcm_ptp_verify,\n\t.do_aux_work\t= bcm_ptp_do_aux_work,\n\t.n_pins\t\t= 1,\n\t.n_per_out\t= 1,\n\t.n_ext_ts\t= 1,\n};\n\nstatic void bcm_ptp_txtstamp(struct mii_timestamper *mii_ts,\n\t\t\t     struct sk_buff *skb, int type)\n{\n\tstruct bcm_ptp_private *priv = mii2priv(mii_ts);\n\tstruct ptp_header *hdr;\n\tbool discard = false;\n\tint msgtype;\n\n\thdr = ptp_parse_header(skb, type);\n\tif (!hdr)\n\t\tgoto out;\n\tmsgtype = ptp_get_msgtype(hdr, type);\n\n\tswitch (priv->tx_type) {\n\tcase HWTSTAMP_TX_ONESTEP_P2P:\n\t\tif (msgtype == PTP_MSGTYPE_PDELAY_RESP)\n\t\t\tdiscard = true;\n\t\tfallthrough;\n\tcase HWTSTAMP_TX_ONESTEP_SYNC:\n\t\tif (msgtype == PTP_MSGTYPE_SYNC)\n\t\t\tdiscard = true;\n\t\tfallthrough;\n\tcase HWTSTAMP_TX_ON:\n\t\tBCM_SKB_CB(skb)->timeout = jiffies + SKB_TS_TIMEOUT;\n\t\tBCM_SKB_CB(skb)->seq_id = be16_to_cpu(hdr->sequence_id);\n\t\tBCM_SKB_CB(skb)->msgtype = msgtype;\n\t\tBCM_SKB_CB(skb)->discard = discard;\n\t\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\t\tskb_queue_tail(&priv->tx_queue, skb);\n\t\tptp_schedule_worker(priv->ptp_clock, 0);\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\nout:\n\tkfree_skb(skb);\n}\n\nstatic int bcm_ptp_hwtstamp(struct mii_timestamper *mii_ts,\n\t\t\t    struct ifreq *ifr)\n{\n\tstruct bcm_ptp_private *priv = mii2priv(mii_ts);\n\tstruct hwtstamp_config cfg;\n\tu16 mode, ctrl;\n\n\tif (copy_from_user(&cfg, ifr->ifr_data, sizeof(cfg)))\n\t\treturn -EFAULT;\n\n\tswitch (cfg.rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tpriv->hwts_rx = false;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\t\tcfg.rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;\n\t\tpriv->hwts_rx = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tpriv->tx_type = cfg.tx_type;\n\n\tctrl  = priv->hwts_rx ? SLICE_RX_EN : 0;\n\tctrl |= priv->tx_type != HWTSTAMP_TX_OFF ? SLICE_TX_EN : 0;\n\n\tmode = TX_MODE_SEL(PORT, SYNC, REPLACE_TS) |\n\t       TX_MODE_SEL(PORT, DELAY_REQ, REPLACE_TS) |\n\t       TX_MODE_SEL(PORT, PDELAY_REQ, REPLACE_TS) |\n\t       TX_MODE_SEL(PORT, PDELAY_RESP, REPLACE_TS);\n\n\tbcm_phy_write_exp(priv->phydev, TX_EVENT_MODE, mode);\n\n\tmode = RX_MODE_SEL(PORT, SYNC, INSERT_TS_64) |\n\t       RX_MODE_SEL(PORT, DELAY_REQ, INSERT_TS_64) |\n\t       RX_MODE_SEL(PORT, PDELAY_REQ, INSERT_TS_64) |\n\t       RX_MODE_SEL(PORT, PDELAY_RESP, INSERT_TS_64);\n\n\tbcm_phy_write_exp(priv->phydev, RX_EVENT_MODE, mode);\n\n\tbcm_phy_write_exp(priv->phydev, SLICE_CTRL, ctrl);\n\n\tif (ctrl & SLICE_TX_EN)\n\t\tbcm_phy_write_exp(priv->phydev, TX_TS_CAPTURE, TX_TS_CAP_EN);\n\telse\n\t\tptp_cancel_worker_sync(priv->ptp_clock);\n\n\t \n\tskb_queue_purge(&priv->tx_queue);\n\n\treturn copy_to_user(ifr->ifr_data, &cfg, sizeof(cfg)) ? -EFAULT : 0;\n}\n\nstatic int bcm_ptp_ts_info(struct mii_timestamper *mii_ts,\n\t\t\t   struct ethtool_ts_info *ts_info)\n{\n\tstruct bcm_ptp_private *priv = mii2priv(mii_ts);\n\n\tts_info->phc_index = ptp_clock_index(priv->ptp_clock);\n\tts_info->so_timestamping =\n\t\tSOF_TIMESTAMPING_TX_HARDWARE |\n\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\tts_info->tx_types =\n\t\tBIT(HWTSTAMP_TX_ON) |\n\t\tBIT(HWTSTAMP_TX_OFF) |\n\t\tBIT(HWTSTAMP_TX_ONESTEP_SYNC) |\n\t\tBIT(HWTSTAMP_TX_ONESTEP_P2P);\n\tts_info->rx_filters =\n\t\tBIT(HWTSTAMP_FILTER_NONE) |\n\t\tBIT(HWTSTAMP_FILTER_PTP_V2_EVENT);\n\n\treturn 0;\n}\n\nvoid bcm_ptp_stop(struct bcm_ptp_private *priv)\n{\n\tptp_cancel_worker_sync(priv->ptp_clock);\n\tbcm_ptp_cancel_func(priv);\n}\nEXPORT_SYMBOL_GPL(bcm_ptp_stop);\n\nvoid bcm_ptp_config_init(struct phy_device *phydev)\n{\n\t \n\tbcm_phy_write_exp(phydev, NSE_CTRL, NSE_GMODE_EN | NSE_INIT);\n\n\t \n\tbcm_phy_write_exp(phydev, TIME_SYNC, TIME_SYNC_EN);\n\n\t \n\tbcm_phy_write_exp(phydev, DPLL_SELECT, DPLL_HB_MODE2);\n\n\t \n\tbcm_phy_write_exp(phydev, TIMECODE_CTRL, TX_TIMECODE_SEL);\n\n\t \n\tbcm_phy_write_exp(phydev, SHADOW_CTRL, FREQ_LOAD);\n\n\tbcm_phy_write_exp(phydev, SYNC_IN_DIVIDER, 1);\n}\nEXPORT_SYMBOL_GPL(bcm_ptp_config_init);\n\nstatic void bcm_ptp_init(struct bcm_ptp_private *priv)\n{\n\tpriv->nse_ctrl = NSE_GMODE_EN;\n\n\tmutex_init(&priv->mutex);\n\tskb_queue_head_init(&priv->tx_queue);\n\n\tpriv->mii_ts.rxtstamp = bcm_ptp_rxtstamp;\n\tpriv->mii_ts.txtstamp = bcm_ptp_txtstamp;\n\tpriv->mii_ts.hwtstamp = bcm_ptp_hwtstamp;\n\tpriv->mii_ts.ts_info = bcm_ptp_ts_info;\n\n\tpriv->phydev->mii_ts = &priv->mii_ts;\n}\n\nstruct bcm_ptp_private *bcm_ptp_probe(struct phy_device *phydev)\n{\n\tstruct bcm_ptp_private *priv;\n\tstruct ptp_clock *clock;\n\n\tswitch (BRCM_PHY_MODEL(phydev)) {\n\tcase PHY_ID_BCM54210E:\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\tpriv = devm_kzalloc(&phydev->mdio.dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpriv->ptp_info = bcm_ptp_clock_info;\n\n\tsnprintf(priv->pin.name, sizeof(priv->pin.name), \"SYNC_OUT\");\n\tpriv->ptp_info.pin_config = &priv->pin;\n\n\tclock = ptp_clock_register(&priv->ptp_info, &phydev->mdio.dev);\n\tif (IS_ERR(clock))\n\t\treturn ERR_CAST(clock);\n\tpriv->ptp_clock = clock;\n\n\tpriv->phydev = phydev;\n\tbcm_ptp_init(priv);\n\n\treturn priv;\n}\nEXPORT_SYMBOL_GPL(bcm_ptp_probe);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}