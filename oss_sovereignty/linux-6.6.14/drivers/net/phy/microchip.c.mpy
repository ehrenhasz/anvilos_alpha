{
  "module_name": "microchip.c",
  "hash_id": "2f63747854e72a2e109afde5e172e9611fd2b275d7eb94ca1ae2635505c5a5f7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/microchip.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/phy.h>\n#include <linux/microchipphy.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n#include <dt-bindings/net/microchip-lan78xx.h>\n\n#define DRIVER_AUTHOR\t\"WOOJUNG HUH <woojung.huh@microchip.com>\"\n#define DRIVER_DESC\t\"Microchip LAN88XX PHY driver\"\n\nstruct lan88xx_priv {\n\tint\tchip_id;\n\tint\tchip_rev;\n\t__u32\twolopts;\n};\n\nstatic int lan88xx_read_page(struct phy_device *phydev)\n{\n\treturn __phy_read(phydev, LAN88XX_EXT_PAGE_ACCESS);\n}\n\nstatic int lan88xx_write_page(struct phy_device *phydev, int page)\n{\n\treturn __phy_write(phydev, LAN88XX_EXT_PAGE_ACCESS, page);\n}\n\nstatic int lan88xx_phy_config_intr(struct phy_device *phydev)\n{\n\tint rc;\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\t \n\t\trc = phy_write(phydev, LAN88XX_INT_MASK, 0x7FFF);\n\t\trc = phy_read(phydev, LAN88XX_INT_STS);\n\t\trc = phy_write(phydev, LAN88XX_INT_MASK,\n\t\t\t       LAN88XX_INT_MASK_MDINTPIN_EN_ |\n\t\t\t       LAN88XX_INT_MASK_LINK_CHANGE_);\n\t} else {\n\t\trc = phy_write(phydev, LAN88XX_INT_MASK, 0);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\trc = phy_read(phydev, LAN88XX_INT_STS);\n\t}\n\n\treturn rc < 0 ? rc : 0;\n}\n\nstatic irqreturn_t lan88xx_handle_interrupt(struct phy_device *phydev)\n{\n\tint irq_status;\n\n\tirq_status = phy_read(phydev, LAN88XX_INT_STS);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (!(irq_status & LAN88XX_INT_STS_LINK_CHANGE_))\n\t\treturn IRQ_NONE;\n\n\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int lan88xx_suspend(struct phy_device *phydev)\n{\n\tstruct lan88xx_priv *priv = phydev->priv;\n\n\t \n\tif (!priv->wolopts)\n\t\tgenphy_suspend(phydev);\n\n\treturn 0;\n}\n\nstatic int lan88xx_TR_reg_set(struct phy_device *phydev, u16 regaddr,\n\t\t\t      u32 data)\n{\n\tint val, save_page, ret = 0;\n\tu16 buf;\n\n\t \n\tsave_page = phy_save_page(phydev);\n\tif (save_page < 0) {\n\t\tphydev_warn(phydev, \"Failed to get current page\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\tlan88xx_write_page(phydev, LAN88XX_EXT_PAGE_ACCESS_TR);\n\n\tret = __phy_write(phydev, LAN88XX_EXT_PAGE_TR_LOW_DATA,\n\t\t\t  (data & 0xFFFF));\n\tif (ret < 0) {\n\t\tphydev_warn(phydev, \"Failed to write TR low data\\n\");\n\t\tgoto err;\n\t}\n\n\tret = __phy_write(phydev, LAN88XX_EXT_PAGE_TR_HIGH_DATA,\n\t\t\t  (data & 0x00FF0000) >> 16);\n\tif (ret < 0) {\n\t\tphydev_warn(phydev, \"Failed to write TR high data\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\tbuf = (regaddr & ~(0x3 << 13)); \n\tbuf |= 0x8000;  \n\n\tret = __phy_write(phydev, LAN88XX_EXT_PAGE_TR_CR, buf);\n\tif (ret < 0) {\n\t\tphydev_warn(phydev, \"Failed to write data in reg\\n\");\n\t\tgoto err;\n\t}\n\n\tusleep_range(1000, 2000); \n\tval = __phy_read(phydev, LAN88XX_EXT_PAGE_TR_CR);\n\tif (!(val & 0x8000))\n\t\tphydev_warn(phydev, \"TR Register[0x%X] configuration failed\\n\",\n\t\t\t    regaddr);\nerr:\n\treturn phy_restore_page(phydev, save_page, ret);\n}\n\nstatic void lan88xx_config_TR_regs(struct phy_device *phydev)\n{\n\tint err;\n\n\t \n\terr = lan88xx_TR_reg_set(phydev, 0x0F82, 0x12B00A);\n\tif (err < 0)\n\t\tphydev_warn(phydev, \"Failed to Set Register[0x0F82]\\n\");\n\n\t \n\terr = lan88xx_TR_reg_set(phydev, 0x168C, 0xD2C46F);\n\tif (err < 0)\n\t\tphydev_warn(phydev, \"Failed to Set Register[0x168C]\\n\");\n\n\t \n\terr = lan88xx_TR_reg_set(phydev, 0x17A2, 0x620);\n\tif (err < 0)\n\t\tphydev_warn(phydev, \"Failed to Set Register[0x17A2]\\n\");\n\n\t \n\terr = lan88xx_TR_reg_set(phydev, 0x16A0, 0xEEFFDD);\n\tif (err < 0)\n\t\tphydev_warn(phydev, \"Failed to Set Register[0x16A0]\\n\");\n\n\t \n\terr = lan88xx_TR_reg_set(phydev, 0x16A6, 0x071448);\n\tif (err < 0)\n\t\tphydev_warn(phydev, \"Failed to Set Register[0x16A6]\\n\");\n\n\t \n\terr = lan88xx_TR_reg_set(phydev, 0x16A4, 0x13132F);\n\tif (err < 0)\n\t\tphydev_warn(phydev, \"Failed to Set Register[0x16A4]\\n\");\n\n\t \n\terr = lan88xx_TR_reg_set(phydev, 0x16A8, 0x0);\n\tif (err < 0)\n\t\tphydev_warn(phydev, \"Failed to Set Register[0x16A8]\\n\");\n\n\t \n\terr = lan88xx_TR_reg_set(phydev, 0x0FE8, 0x91B06C);\n\tif (err < 0)\n\t\tphydev_warn(phydev, \"Failed to Set Register[0x0FE8]\\n\");\n\n\t \n\terr = lan88xx_TR_reg_set(phydev, 0x0FFC, 0xC0A028);\n\tif (err < 0)\n\t\tphydev_warn(phydev, \"Failed to Set Register[0x0FFC]\\n\");\n\n\t \n\terr = lan88xx_TR_reg_set(phydev, 0x0FEA, 0x041600);\n\tif (err < 0)\n\t\tphydev_warn(phydev, \"Failed to Set Register[0x0FEA]\\n\");\n\n\t \n\terr = lan88xx_TR_reg_set(phydev, 0x1686, 0x000004);\n\tif (err < 0)\n\t\tphydev_warn(phydev, \"Failed to Set Register[0x1686]\\n\");\n}\n\nstatic int lan88xx_probe(struct phy_device *phydev)\n{\n\tstruct device *dev = &phydev->mdio.dev;\n\tstruct lan88xx_priv *priv;\n\tu32 led_modes[4];\n\tint len;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->wolopts = 0;\n\n\tlen = of_property_read_variable_u32_array(dev->of_node,\n\t\t\t\t\t\t  \"microchip,led-modes\",\n\t\t\t\t\t\t  led_modes,\n\t\t\t\t\t\t  0,\n\t\t\t\t\t\t  ARRAY_SIZE(led_modes));\n\tif (len >= 0) {\n\t\tu32 reg = 0;\n\t\tint i;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (led_modes[i] > 15)\n\t\t\t\treturn -EINVAL;\n\t\t\treg |= led_modes[i] << (i * 4);\n\t\t}\n\t\tfor (; i < ARRAY_SIZE(led_modes); i++)\n\t\t\treg |= LAN78XX_FORCE_LED_OFF << (i * 4);\n\t\t(void)phy_write(phydev, LAN78XX_PHY_LED_MODE_SELECT, reg);\n\t} else if (len == -EOVERFLOW) {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpriv->chip_id = phy_read_mmd(phydev, 3, LAN88XX_MMD3_CHIP_ID);\n\tpriv->chip_rev = phy_read_mmd(phydev, 3, LAN88XX_MMD3_CHIP_REV);\n\n\tphydev->priv = priv;\n\n\treturn 0;\n}\n\nstatic void lan88xx_remove(struct phy_device *phydev)\n{\n\tstruct device *dev = &phydev->mdio.dev;\n\tstruct lan88xx_priv *priv = phydev->priv;\n\n\tif (priv)\n\t\tdevm_kfree(dev, priv);\n}\n\nstatic int lan88xx_set_wol(struct phy_device *phydev,\n\t\t\t   struct ethtool_wolinfo *wol)\n{\n\tstruct lan88xx_priv *priv = phydev->priv;\n\n\tpriv->wolopts = wol->wolopts;\n\n\treturn 0;\n}\n\nstatic void lan88xx_set_mdix(struct phy_device *phydev)\n{\n\tint buf;\n\tint val;\n\n\tswitch (phydev->mdix_ctrl) {\n\tcase ETH_TP_MDI:\n\t\tval = LAN88XX_EXT_MODE_CTRL_MDI_;\n\t\tbreak;\n\tcase ETH_TP_MDI_X:\n\t\tval = LAN88XX_EXT_MODE_CTRL_MDI_X_;\n\t\tbreak;\n\tcase ETH_TP_MDI_AUTO:\n\t\tval = LAN88XX_EXT_MODE_CTRL_AUTO_MDIX_;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tphy_write(phydev, LAN88XX_EXT_PAGE_ACCESS, LAN88XX_EXT_PAGE_SPACE_1);\n\tbuf = phy_read(phydev, LAN88XX_EXT_MODE_CTRL);\n\tbuf &= ~LAN88XX_EXT_MODE_CTRL_MDIX_MASK_;\n\tbuf |= val;\n\tphy_write(phydev, LAN88XX_EXT_MODE_CTRL, buf);\n\tphy_write(phydev, LAN88XX_EXT_PAGE_ACCESS, LAN88XX_EXT_PAGE_SPACE_0);\n}\n\nstatic int lan88xx_config_init(struct phy_device *phydev)\n{\n\tint val;\n\n\t \n\tval = phy_read_mmd(phydev, MDIO_MMD_PCS,\n\t\t\t   PHY_ARDENNES_MMD_DEV_3_PHY_CFG);\n\tval |= PHY_ARDENNES_MMD_DEV_3_PHY_CFG_ZD_DLY_EN_;\n\n\tphy_write_mmd(phydev, MDIO_MMD_PCS, PHY_ARDENNES_MMD_DEV_3_PHY_CFG,\n\t\t      val);\n\n\t \n\tlan88xx_config_TR_regs(phydev);\n\n\treturn 0;\n}\n\nstatic int lan88xx_config_aneg(struct phy_device *phydev)\n{\n\tlan88xx_set_mdix(phydev);\n\n\treturn genphy_config_aneg(phydev);\n}\n\nstatic void lan88xx_link_change_notify(struct phy_device *phydev)\n{\n\tint temp;\n\n\t \n\tif (!phydev->autoneg && phydev->speed == 100) {\n\t\t \n\t\ttemp = phy_read(phydev, LAN88XX_INT_MASK);\n\t\ttemp &= ~LAN88XX_INT_MASK_MDINTPIN_EN_;\n\t\tphy_write(phydev, LAN88XX_INT_MASK, temp);\n\n\t\ttemp = phy_read(phydev, MII_BMCR);\n\t\ttemp &= ~(BMCR_SPEED100 | BMCR_SPEED1000);\n\t\tphy_write(phydev, MII_BMCR, temp);  \n\t\ttemp |= BMCR_SPEED100;\n\t\tphy_write(phydev, MII_BMCR, temp);  \n\n\t\t \n\t\ttemp = phy_read(phydev, LAN88XX_INT_STS);\n\n\t\t \n\t\ttemp = phy_read(phydev, LAN88XX_INT_MASK);\n\t\ttemp |= LAN88XX_INT_MASK_MDINTPIN_EN_;\n\t\tphy_write(phydev, LAN88XX_INT_MASK, temp);\n\t}\n}\n\nstatic struct phy_driver microchip_phy_driver[] = {\n{\n\t.phy_id\t\t= 0x0007c132,\n\t \n\t.phy_id_mask\t= 0xfffffff2,\n\t.name\t\t= \"Microchip LAN88xx\",\n\n\t \n\n\t.probe\t\t= lan88xx_probe,\n\t.remove\t\t= lan88xx_remove,\n\n\t.config_init\t= lan88xx_config_init,\n\t.config_aneg\t= lan88xx_config_aneg,\n\t.link_change_notify = lan88xx_link_change_notify,\n\n\t.config_intr\t= lan88xx_phy_config_intr,\n\t.handle_interrupt = lan88xx_handle_interrupt,\n\n\t.suspend\t= lan88xx_suspend,\n\t.resume\t\t= genphy_resume,\n\t.set_wol\t= lan88xx_set_wol,\n\t.read_page\t= lan88xx_read_page,\n\t.write_page\t= lan88xx_write_page,\n} };\n\nmodule_phy_driver(microchip_phy_driver);\n\nstatic struct mdio_device_id __maybe_unused microchip_tbl[] = {\n\t{ 0x0007c132, 0xfffffff2 },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(mdio, microchip_tbl);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}