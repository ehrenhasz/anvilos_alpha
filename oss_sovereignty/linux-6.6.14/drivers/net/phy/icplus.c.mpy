{
  "module_name": "icplus.c",
  "hash_id": "16964ff1004425201c79d6ff76d90bf9abdf7e6ff18aacb23d55f02ac7b23b03",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/icplus.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/unistd.h>\n#include <linux/interrupt.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/phy.h>\n#include <linux/property.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <linux/uaccess.h>\n\nMODULE_DESCRIPTION(\"ICPlus IP175C/IP101A/IP101G/IC1001 PHY drivers\");\nMODULE_AUTHOR(\"Michael Barkowski\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define IP10XX_SPEC_CTRL_STATUS\t\t16\t \n#define IP1001_RXPHASE_SEL\t\tBIT(0)\t \n#define IP1001_TXPHASE_SEL\t\tBIT(1)\t \n#define IP1001_SPEC_CTRL_STATUS_2\t20\t \n#define IP1001_APS_ON\t\t\t11\t \n#define IP101A_G_APS_ON\t\t\tBIT(1)\t \n#define IP101A_G_AUTO_MDIX_DIS\t\tBIT(11)\n#define IP101A_G_IRQ_CONF_STATUS\t0x11\t \n#define\tIP101A_G_IRQ_PIN_USED\t\tBIT(15)  \n#define IP101A_G_IRQ_ALL_MASK\t\tBIT(11)  \n#define IP101A_G_IRQ_SPEED_CHANGE\tBIT(2)\n#define IP101A_G_IRQ_DUPLEX_CHANGE\tBIT(1)\n#define IP101A_G_IRQ_LINK_CHANGE\tBIT(0)\n#define IP101A_G_PHY_STATUS\t\t18\n#define IP101A_G_MDIX\t\t\tBIT(9)\n#define IP101A_G_PHY_SPEC_CTRL\t\t30\n#define IP101A_G_FORCE_MDIX\t\tBIT(3)\n\n#define IP101G_PAGE_CONTROL\t\t\t\t0x14\n#define IP101G_PAGE_CONTROL_MASK\t\t\tGENMASK(4, 0)\n#define IP101G_DIGITAL_IO_SPEC_CTRL\t\t\t0x1d\n#define IP101G_DIGITAL_IO_SPEC_CTRL_SEL_INTR32\t\tBIT(2)\n\n#define IP101G_DEFAULT_PAGE\t\t\t16\n\n#define IP101G_P1_CNT_CTRL\t\t17\n#define CNT_CTRL_RX_EN\t\t\tBIT(13)\n#define IP101G_P8_CNT_CTRL\t\t17\n#define CNT_CTRL_RDCLR_EN\t\tBIT(15)\n#define IP101G_CNT_REG\t\t\t18\n\n#define IP175C_PHY_ID 0x02430d80\n#define IP1001_PHY_ID 0x02430d90\n#define IP101A_PHY_ID 0x02430c54\n\n \nenum ip101gr_sel_intr32 {\n\tIP101GR_SEL_INTR32_KEEP,\n\tIP101GR_SEL_INTR32_INTR,\n\tIP101GR_SEL_INTR32_RXER,\n};\n\nstruct ip101g_hw_stat {\n\tconst char *name;\n\tint page;\n};\n\nstatic struct ip101g_hw_stat ip101g_hw_stats[] = {\n\t{ \"phy_crc_errors\", 1 },\n\t{ \"phy_symbol_errors\", 11, },\n};\n\nstruct ip101a_g_phy_priv {\n\tenum ip101gr_sel_intr32 sel_intr32;\n\tu64 stats[ARRAY_SIZE(ip101g_hw_stats)];\n};\n\nstatic int ip175c_config_init(struct phy_device *phydev)\n{\n\tint err, i;\n\tstatic int full_reset_performed;\n\n\tif (full_reset_performed == 0) {\n\n\t\t \n\t\terr = mdiobus_write(phydev->mdio.bus, 30, 0, 0x175c);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\terr = mdiobus_read(phydev->mdio.bus, 30, 0);\n\n\t\t \n\t\tmdelay(2);\n\n\t\t \n\t\terr = mdiobus_write(phydev->mdio.bus, 29, 31, 0x175c);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\terr = mdiobus_write(phydev->mdio.bus, 29, 22, 0x420);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\tfor (i = 0; i < 5; i++) {\n\t\t\terr = mdiobus_write(phydev->mdio.bus, i,\n\t\t\t\t\t    MII_BMCR, BMCR_RESET);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tfor (i = 0; i < 5; i++)\n\t\t\terr = mdiobus_read(phydev->mdio.bus, i, MII_BMCR);\n\n\t\tmdelay(2);\n\n\t\tfull_reset_performed = 1;\n\t}\n\n\tif (phydev->mdio.addr != 4) {\n\t\tphydev->state = PHY_RUNNING;\n\t\tphydev->speed = SPEED_100;\n\t\tphydev->duplex = DUPLEX_FULL;\n\t\tphydev->link = 1;\n\t\tnetif_carrier_on(phydev->attached_dev);\n\t}\n\n\treturn 0;\n}\n\nstatic int ip1001_config_init(struct phy_device *phydev)\n{\n\tint c;\n\n\t \n\tc = phy_read(phydev, IP1001_SPEC_CTRL_STATUS_2);\n\tif (c < 0)\n\t\treturn c;\n\tc |= IP1001_APS_ON;\n\tc = phy_write(phydev, IP1001_SPEC_CTRL_STATUS_2, c);\n\tif (c < 0)\n\t\treturn c;\n\n\tif (phy_interface_is_rgmii(phydev)) {\n\n\t\tc = phy_read(phydev, IP10XX_SPEC_CTRL_STATUS);\n\t\tif (c < 0)\n\t\t\treturn c;\n\n\t\tc &= ~(IP1001_RXPHASE_SEL | IP1001_TXPHASE_SEL);\n\n\t\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID)\n\t\t\tc |= (IP1001_RXPHASE_SEL | IP1001_TXPHASE_SEL);\n\t\telse if (phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID)\n\t\t\tc |= IP1001_RXPHASE_SEL;\n\t\telse if (phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID)\n\t\t\tc |= IP1001_TXPHASE_SEL;\n\n\t\tc = phy_write(phydev, IP10XX_SPEC_CTRL_STATUS, c);\n\t\tif (c < 0)\n\t\t\treturn c;\n\t}\n\n\treturn 0;\n}\n\nstatic int ip175c_read_status(struct phy_device *phydev)\n{\n\tif (phydev->mdio.addr == 4)  \n\t\tgenphy_read_status(phydev);\n\telse\n\t\t \n\t\tphydev->irq = PHY_MAC_INTERRUPT;\n\n\treturn 0;\n}\n\nstatic int ip175c_config_aneg(struct phy_device *phydev)\n{\n\tif (phydev->mdio.addr == 4)  \n\t\tgenphy_config_aneg(phydev);\n\n\treturn 0;\n}\n\nstatic int ip101a_g_probe(struct phy_device *phydev)\n{\n\tstruct device *dev = &phydev->mdio.dev;\n\tstruct ip101a_g_phy_priv *priv;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t \n\tif (device_property_read_bool(dev, \"icplus,select-rx-error\") &&\n\t    device_property_read_bool(dev, \"icplus,select-interrupt\")) {\n\t\tdev_err(dev,\n\t\t\t\"RXER and INTR mode cannot be selected together\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (device_property_read_bool(dev, \"icplus,select-rx-error\"))\n\t\tpriv->sel_intr32 = IP101GR_SEL_INTR32_RXER;\n\telse if (device_property_read_bool(dev, \"icplus,select-interrupt\"))\n\t\tpriv->sel_intr32 = IP101GR_SEL_INTR32_INTR;\n\telse\n\t\tpriv->sel_intr32 = IP101GR_SEL_INTR32_KEEP;\n\n\tphydev->priv = priv;\n\n\treturn 0;\n}\n\nstatic int ip101a_g_config_intr_pin(struct phy_device *phydev)\n{\n\tstruct ip101a_g_phy_priv *priv = phydev->priv;\n\tint oldpage, err = 0;\n\n\toldpage = phy_select_page(phydev, IP101G_DEFAULT_PAGE);\n\tif (oldpage < 0)\n\t\tgoto out;\n\n\t \n\tswitch (priv->sel_intr32) {\n\tcase IP101GR_SEL_INTR32_RXER:\n\t\terr = __phy_modify(phydev, IP101G_DIGITAL_IO_SPEC_CTRL,\n\t\t\t\t   IP101G_DIGITAL_IO_SPEC_CTRL_SEL_INTR32, 0);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase IP101GR_SEL_INTR32_INTR:\n\t\terr = __phy_modify(phydev, IP101G_DIGITAL_IO_SPEC_CTRL,\n\t\t\t\t   IP101G_DIGITAL_IO_SPEC_CTRL_SEL_INTR32,\n\t\t\t\t   IP101G_DIGITAL_IO_SPEC_CTRL_SEL_INTR32);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\nout:\n\treturn phy_restore_page(phydev, oldpage, err);\n}\n\nstatic int ip101a_config_init(struct phy_device *phydev)\n{\n\tint ret;\n\n\t \n\tret = phy_set_bits(phydev, IP10XX_SPEC_CTRL_STATUS, IP101A_G_APS_ON);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ip101a_g_config_intr_pin(phydev);\n}\n\nstatic int ip101g_config_init(struct phy_device *phydev)\n{\n\tint ret;\n\n\t \n\tret = phy_modify_paged(phydev, 1, IP101G_P1_CNT_CTRL,\n\t\t\t       CNT_CTRL_RX_EN, CNT_CTRL_RX_EN);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = phy_modify_paged(phydev, 8, IP101G_P8_CNT_CTRL,\n\t\t\t       CNT_CTRL_RDCLR_EN, CNT_CTRL_RDCLR_EN);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ip101a_g_config_intr_pin(phydev);\n}\n\nstatic int ip101a_g_read_status(struct phy_device *phydev)\n{\n\tint oldpage, ret, stat1, stat2;\n\n\tret = genphy_read_status(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\toldpage = phy_select_page(phydev, IP101G_DEFAULT_PAGE);\n\tif (oldpage < 0)\n\t\tgoto out;\n\n\tret = __phy_read(phydev, IP10XX_SPEC_CTRL_STATUS);\n\tif (ret < 0)\n\t\tgoto out;\n\tstat1 = ret;\n\n\tret = __phy_read(phydev, IP101A_G_PHY_SPEC_CTRL);\n\tif (ret < 0)\n\t\tgoto out;\n\tstat2 = ret;\n\n\tif (stat1 & IP101A_G_AUTO_MDIX_DIS) {\n\t\tif (stat2 & IP101A_G_FORCE_MDIX)\n\t\t\tphydev->mdix_ctrl = ETH_TP_MDI_X;\n\t\telse\n\t\t\tphydev->mdix_ctrl = ETH_TP_MDI;\n\t} else {\n\t\tphydev->mdix_ctrl = ETH_TP_MDI_AUTO;\n\t}\n\n\tif (stat2 & IP101A_G_MDIX)\n\t\tphydev->mdix = ETH_TP_MDI_X;\n\telse\n\t\tphydev->mdix = ETH_TP_MDI;\n\n\tret = 0;\n\nout:\n\treturn phy_restore_page(phydev, oldpage, ret);\n}\n\nstatic int ip101a_g_config_mdix(struct phy_device *phydev)\n{\n\tu16 ctrl = 0, ctrl2 = 0;\n\tint oldpage;\n\tint ret = 0;\n\n\tswitch (phydev->mdix_ctrl) {\n\tcase ETH_TP_MDI:\n\t\tctrl = IP101A_G_AUTO_MDIX_DIS;\n\t\tbreak;\n\tcase ETH_TP_MDI_X:\n\t\tctrl = IP101A_G_AUTO_MDIX_DIS;\n\t\tctrl2 = IP101A_G_FORCE_MDIX;\n\t\tbreak;\n\tcase ETH_TP_MDI_AUTO:\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\toldpage = phy_select_page(phydev, IP101G_DEFAULT_PAGE);\n\tif (oldpage < 0)\n\t\tgoto out;\n\n\tret = __phy_modify(phydev, IP10XX_SPEC_CTRL_STATUS,\n\t\t\t   IP101A_G_AUTO_MDIX_DIS, ctrl);\n\tif (ret)\n\t\tgoto out;\n\n\tret = __phy_modify(phydev, IP101A_G_PHY_SPEC_CTRL,\n\t\t\t   IP101A_G_FORCE_MDIX, ctrl2);\n\nout:\n\treturn phy_restore_page(phydev, oldpage, ret);\n}\n\nstatic int ip101a_g_config_aneg(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = ip101a_g_config_mdix(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn genphy_config_aneg(phydev);\n}\n\nstatic int ip101a_g_ack_interrupt(struct phy_device *phydev)\n{\n\tint err;\n\n\terr = phy_read_paged(phydev, IP101G_DEFAULT_PAGE,\n\t\t\t     IP101A_G_IRQ_CONF_STATUS);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int ip101a_g_config_intr(struct phy_device *phydev)\n{\n\tu16 val;\n\tint err;\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\terr = ip101a_g_ack_interrupt(phydev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tval = IP101A_G_IRQ_PIN_USED;\n\t\terr = phy_write_paged(phydev, IP101G_DEFAULT_PAGE,\n\t\t\t\t      IP101A_G_IRQ_CONF_STATUS, val);\n\t} else {\n\t\tval = IP101A_G_IRQ_ALL_MASK;\n\t\terr = phy_write_paged(phydev, IP101G_DEFAULT_PAGE,\n\t\t\t\t      IP101A_G_IRQ_CONF_STATUS, val);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = ip101a_g_ack_interrupt(phydev);\n\t}\n\n\treturn err;\n}\n\nstatic irqreturn_t ip101a_g_handle_interrupt(struct phy_device *phydev)\n{\n\tint irq_status;\n\n\tirq_status = phy_read_paged(phydev, IP101G_DEFAULT_PAGE,\n\t\t\t\t    IP101A_G_IRQ_CONF_STATUS);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (!(irq_status & (IP101A_G_IRQ_SPEED_CHANGE |\n\t\t\t    IP101A_G_IRQ_DUPLEX_CHANGE |\n\t\t\t    IP101A_G_IRQ_LINK_CHANGE)))\n\t\treturn IRQ_NONE;\n\n\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int ip101a_read_page(struct phy_device *phydev)\n{\n\treturn IP101G_DEFAULT_PAGE;\n}\n\nstatic int ip101a_write_page(struct phy_device *phydev, int page)\n{\n\tWARN_ONCE(page != IP101G_DEFAULT_PAGE, \"wrong page selected\\n\");\n\n\treturn 0;\n}\n\nstatic int ip101g_read_page(struct phy_device *phydev)\n{\n\treturn __phy_read(phydev, IP101G_PAGE_CONTROL);\n}\n\nstatic int ip101g_write_page(struct phy_device *phydev, int page)\n{\n\treturn __phy_write(phydev, IP101G_PAGE_CONTROL, page);\n}\n\nstatic int ip101a_g_has_page_register(struct phy_device *phydev)\n{\n\tint oldval, val, ret;\n\n\toldval = phy_read(phydev, IP101G_PAGE_CONTROL);\n\tif (oldval < 0)\n\t\treturn oldval;\n\n\tret = phy_write(phydev, IP101G_PAGE_CONTROL, 0xffff);\n\tif (ret)\n\t\treturn ret;\n\n\tval = phy_read(phydev, IP101G_PAGE_CONTROL);\n\tif (val < 0)\n\t\treturn val;\n\n\tret = phy_write(phydev, IP101G_PAGE_CONTROL, oldval);\n\tif (ret)\n\t\treturn ret;\n\n\treturn val == IP101G_PAGE_CONTROL_MASK;\n}\n\nstatic int ip101a_g_match_phy_device(struct phy_device *phydev, bool ip101a)\n{\n\tint ret;\n\n\tif (phydev->phy_id != IP101A_PHY_ID)\n\t\treturn 0;\n\n\t \n\tret = ip101a_g_has_page_register(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ip101a == !ret;\n}\n\nstatic int ip101a_match_phy_device(struct phy_device *phydev)\n{\n\treturn ip101a_g_match_phy_device(phydev, true);\n}\n\nstatic int ip101g_match_phy_device(struct phy_device *phydev)\n{\n\treturn ip101a_g_match_phy_device(phydev, false);\n}\n\nstatic int ip101g_get_sset_count(struct phy_device *phydev)\n{\n\treturn ARRAY_SIZE(ip101g_hw_stats);\n}\n\nstatic void ip101g_get_strings(struct phy_device *phydev, u8 *data)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ip101g_hw_stats); i++)\n\t\tstrscpy(data + i * ETH_GSTRING_LEN,\n\t\t\tip101g_hw_stats[i].name, ETH_GSTRING_LEN);\n}\n\nstatic u64 ip101g_get_stat(struct phy_device *phydev, int i)\n{\n\tstruct ip101g_hw_stat stat = ip101g_hw_stats[i];\n\tstruct ip101a_g_phy_priv *priv = phydev->priv;\n\tint val;\n\tu64 ret;\n\n\tval = phy_read_paged(phydev, stat.page, IP101G_CNT_REG);\n\tif (val < 0) {\n\t\tret = U64_MAX;\n\t} else {\n\t\tpriv->stats[i] += val;\n\t\tret = priv->stats[i];\n\t}\n\n\treturn ret;\n}\n\nstatic void ip101g_get_stats(struct phy_device *phydev,\n\t\t\t     struct ethtool_stats *stats, u64 *data)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ip101g_hw_stats); i++)\n\t\tdata[i] = ip101g_get_stat(phydev, i);\n}\n\nstatic struct phy_driver icplus_driver[] = {\n{\n\tPHY_ID_MATCH_MODEL(IP175C_PHY_ID),\n\t.name\t\t= \"ICPlus IP175C\",\n\t \n\t.config_init\t= ip175c_config_init,\n\t.config_aneg\t= ip175c_config_aneg,\n\t.read_status\t= ip175c_read_status,\n\t.suspend\t= genphy_suspend,\n\t.resume\t\t= genphy_resume,\n}, {\n\tPHY_ID_MATCH_MODEL(IP1001_PHY_ID),\n\t.name\t\t= \"ICPlus IP1001\",\n\t \n\t.config_init\t= ip1001_config_init,\n\t.soft_reset\t= genphy_soft_reset,\n\t.suspend\t= genphy_suspend,\n\t.resume\t\t= genphy_resume,\n}, {\n\t.name\t\t= \"ICPlus IP101A\",\n\t.match_phy_device = ip101a_match_phy_device,\n\t.probe\t\t= ip101a_g_probe,\n\t.read_page\t= ip101a_read_page,\n\t.write_page\t= ip101a_write_page,\n\t.config_intr\t= ip101a_g_config_intr,\n\t.handle_interrupt = ip101a_g_handle_interrupt,\n\t.config_init\t= ip101a_config_init,\n\t.config_aneg\t= ip101a_g_config_aneg,\n\t.read_status\t= ip101a_g_read_status,\n\t.soft_reset\t= genphy_soft_reset,\n\t.suspend\t= genphy_suspend,\n\t.resume\t\t= genphy_resume,\n}, {\n\t.name\t\t= \"ICPlus IP101G\",\n\t.match_phy_device = ip101g_match_phy_device,\n\t.probe\t\t= ip101a_g_probe,\n\t.read_page\t= ip101g_read_page,\n\t.write_page\t= ip101g_write_page,\n\t.config_intr\t= ip101a_g_config_intr,\n\t.handle_interrupt = ip101a_g_handle_interrupt,\n\t.config_init\t= ip101g_config_init,\n\t.config_aneg\t= ip101a_g_config_aneg,\n\t.read_status\t= ip101a_g_read_status,\n\t.soft_reset\t= genphy_soft_reset,\n\t.get_sset_count = ip101g_get_sset_count,\n\t.get_strings\t= ip101g_get_strings,\n\t.get_stats\t= ip101g_get_stats,\n\t.suspend\t= genphy_suspend,\n\t.resume\t\t= genphy_resume,\n} };\n\nmodule_phy_driver(icplus_driver);\n\nstatic struct mdio_device_id __maybe_unused icplus_tbl[] = {\n\t{ PHY_ID_MATCH_MODEL(IP175C_PHY_ID) },\n\t{ PHY_ID_MATCH_MODEL(IP1001_PHY_ID) },\n\t{ PHY_ID_MATCH_EXACT(IP101A_PHY_ID) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(mdio, icplus_tbl);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}