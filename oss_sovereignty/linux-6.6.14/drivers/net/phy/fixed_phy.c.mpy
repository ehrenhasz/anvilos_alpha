{
  "module_name": "fixed_phy.c",
  "hash_id": "47591e6795dce1214a2d5ddc09db29797f559602d5f8734eb2509828cbe7ec62",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/fixed_phy.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/list.h>\n#include <linux/mii.h>\n#include <linux/phy.h>\n#include <linux/phy_fixed.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/gpio/consumer.h>\n#include <linux/idr.h>\n#include <linux/netdevice.h>\n#include <linux/linkmode.h>\n\n#include \"swphy.h\"\n\nstruct fixed_mdio_bus {\n\tstruct mii_bus *mii_bus;\n\tstruct list_head phys;\n};\n\nstruct fixed_phy {\n\tint addr;\n\tstruct phy_device *phydev;\n\tstruct fixed_phy_status status;\n\tbool no_carrier;\n\tint (*link_update)(struct net_device *, struct fixed_phy_status *);\n\tstruct list_head node;\n\tstruct gpio_desc *link_gpiod;\n};\n\nstatic struct platform_device *pdev;\nstatic struct fixed_mdio_bus platform_fmb = {\n\t.phys = LIST_HEAD_INIT(platform_fmb.phys),\n};\n\nint fixed_phy_change_carrier(struct net_device *dev, bool new_carrier)\n{\n\tstruct fixed_mdio_bus *fmb = &platform_fmb;\n\tstruct phy_device *phydev = dev->phydev;\n\tstruct fixed_phy *fp;\n\n\tif (!phydev || !phydev->mdio.bus)\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(fp, &fmb->phys, node) {\n\t\tif (fp->addr == phydev->mdio.addr) {\n\t\t\tfp->no_carrier = !new_carrier;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(fixed_phy_change_carrier);\n\nstatic void fixed_phy_update(struct fixed_phy *fp)\n{\n\tif (!fp->no_carrier && fp->link_gpiod)\n\t\tfp->status.link = !!gpiod_get_value_cansleep(fp->link_gpiod);\n}\n\nstatic int fixed_mdio_read(struct mii_bus *bus, int phy_addr, int reg_num)\n{\n\tstruct fixed_mdio_bus *fmb = bus->priv;\n\tstruct fixed_phy *fp;\n\n\tlist_for_each_entry(fp, &fmb->phys, node) {\n\t\tif (fp->addr == phy_addr) {\n\t\t\tstruct fixed_phy_status state;\n\n\t\t\tfp->status.link = !fp->no_carrier;\n\n\t\t\t \n\t\t\tif (fp->link_update)\n\t\t\t\tfp->link_update(fp->phydev->attached_dev,\n\t\t\t\t\t\t&fp->status);\n\n\t\t\t \n\t\t\tfixed_phy_update(fp);\n\t\t\tstate = fp->status;\n\n\t\t\treturn swphy_read_reg(reg_num, &state);\n\t\t}\n\t}\n\n\treturn 0xFFFF;\n}\n\nstatic int fixed_mdio_write(struct mii_bus *bus, int phy_addr, int reg_num,\n\t\t\t    u16 val)\n{\n\treturn 0;\n}\n\n \nint fixed_phy_set_link_update(struct phy_device *phydev,\n\t\t\t      int (*link_update)(struct net_device *,\n\t\t\t\t\t\t struct fixed_phy_status *))\n{\n\tstruct fixed_mdio_bus *fmb = &platform_fmb;\n\tstruct fixed_phy *fp;\n\n\tif (!phydev || !phydev->mdio.bus)\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(fp, &fmb->phys, node) {\n\t\tif (fp->addr == phydev->mdio.addr) {\n\t\t\tfp->link_update = link_update;\n\t\t\tfp->phydev = phydev;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\nEXPORT_SYMBOL_GPL(fixed_phy_set_link_update);\n\nstatic int fixed_phy_add_gpiod(unsigned int irq, int phy_addr,\n\t\t\t       struct fixed_phy_status *status,\n\t\t\t       struct gpio_desc *gpiod)\n{\n\tint ret;\n\tstruct fixed_mdio_bus *fmb = &platform_fmb;\n\tstruct fixed_phy *fp;\n\n\tret = swphy_validate_state(status);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfp = kzalloc(sizeof(*fp), GFP_KERNEL);\n\tif (!fp)\n\t\treturn -ENOMEM;\n\n\tif (irq != PHY_POLL)\n\t\tfmb->mii_bus->irq[phy_addr] = irq;\n\n\tfp->addr = phy_addr;\n\tfp->status = *status;\n\tfp->link_gpiod = gpiod;\n\n\tfixed_phy_update(fp);\n\n\tlist_add_tail(&fp->node, &fmb->phys);\n\n\treturn 0;\n}\n\nint fixed_phy_add(unsigned int irq, int phy_addr,\n\t\t  struct fixed_phy_status *status)\n{\n\treturn fixed_phy_add_gpiod(irq, phy_addr, status, NULL);\n}\nEXPORT_SYMBOL_GPL(fixed_phy_add);\n\nstatic DEFINE_IDA(phy_fixed_ida);\n\nstatic void fixed_phy_del(int phy_addr)\n{\n\tstruct fixed_mdio_bus *fmb = &platform_fmb;\n\tstruct fixed_phy *fp, *tmp;\n\n\tlist_for_each_entry_safe(fp, tmp, &fmb->phys, node) {\n\t\tif (fp->addr == phy_addr) {\n\t\t\tlist_del(&fp->node);\n\t\t\tif (fp->link_gpiod)\n\t\t\t\tgpiod_put(fp->link_gpiod);\n\t\t\tkfree(fp);\n\t\t\tida_free(&phy_fixed_ida, phy_addr);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_OF_GPIO\nstatic struct gpio_desc *fixed_phy_get_gpiod(struct device_node *np)\n{\n\tstruct device_node *fixed_link_node;\n\tstruct gpio_desc *gpiod;\n\n\tif (!np)\n\t\treturn NULL;\n\n\tfixed_link_node = of_get_child_by_name(np, \"fixed-link\");\n\tif (!fixed_link_node)\n\t\treturn NULL;\n\n\t \n\tgpiod = fwnode_gpiod_get_index(of_fwnode_handle(fixed_link_node),\n\t\t\t\t       \"link\", 0, GPIOD_IN, \"mdio\");\n\tif (IS_ERR(gpiod) && PTR_ERR(gpiod) != -EPROBE_DEFER) {\n\t\tif (PTR_ERR(gpiod) != -ENOENT)\n\t\t\tpr_err(\"error getting GPIO for fixed link %pOF, proceed without\\n\",\n\t\t\t       fixed_link_node);\n\t\tgpiod = NULL;\n\t}\n\tof_node_put(fixed_link_node);\n\n\treturn gpiod;\n}\n#else\nstatic struct gpio_desc *fixed_phy_get_gpiod(struct device_node *np)\n{\n\treturn NULL;\n}\n#endif\n\nstatic struct phy_device *__fixed_phy_register(unsigned int irq,\n\t\t\t\t\t       struct fixed_phy_status *status,\n\t\t\t\t\t       struct device_node *np,\n\t\t\t\t\t       struct gpio_desc *gpiod)\n{\n\tstruct fixed_mdio_bus *fmb = &platform_fmb;\n\tstruct phy_device *phy;\n\tint phy_addr;\n\tint ret;\n\n\tif (!fmb->mii_bus || fmb->mii_bus->state != MDIOBUS_REGISTERED)\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\t \n\tif (!gpiod) {\n\t\tgpiod = fixed_phy_get_gpiod(np);\n\t\tif (IS_ERR(gpiod))\n\t\t\treturn ERR_CAST(gpiod);\n\t}\n\n\t \n\tphy_addr = ida_alloc_max(&phy_fixed_ida, PHY_MAX_ADDR - 1, GFP_KERNEL);\n\tif (phy_addr < 0)\n\t\treturn ERR_PTR(phy_addr);\n\n\tret = fixed_phy_add_gpiod(irq, phy_addr, status, gpiod);\n\tif (ret < 0) {\n\t\tida_free(&phy_fixed_ida, phy_addr);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tphy = get_phy_device(fmb->mii_bus, phy_addr, false);\n\tif (IS_ERR(phy)) {\n\t\tfixed_phy_del(phy_addr);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t \n\tphy->link = status->link;\n\tif (status->link) {\n\t\tphy->speed = status->speed;\n\t\tphy->duplex = status->duplex;\n\t\tphy->pause = status->pause;\n\t\tphy->asym_pause = status->asym_pause;\n\t}\n\n\tof_node_get(np);\n\tphy->mdio.dev.of_node = np;\n\tphy->is_pseudo_fixed_link = true;\n\n\tswitch (status->speed) {\n\tcase SPEED_1000:\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT,\n\t\t\t\t phy->supported);\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,\n\t\t\t\t phy->supported);\n\t\tfallthrough;\n\tcase SPEED_100:\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT,\n\t\t\t\t phy->supported);\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT,\n\t\t\t\t phy->supported);\n\t\tfallthrough;\n\tcase SPEED_10:\n\tdefault:\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Half_BIT,\n\t\t\t\t phy->supported);\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_10baseT_Full_BIT,\n\t\t\t\t phy->supported);\n\t}\n\n\tphy_advertise_supported(phy);\n\n\tret = phy_device_register(phy);\n\tif (ret) {\n\t\tphy_device_free(phy);\n\t\tof_node_put(np);\n\t\tfixed_phy_del(phy_addr);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn phy;\n}\n\nstruct phy_device *fixed_phy_register(unsigned int irq,\n\t\t\t\t      struct fixed_phy_status *status,\n\t\t\t\t      struct device_node *np)\n{\n\treturn __fixed_phy_register(irq, status, np, NULL);\n}\nEXPORT_SYMBOL_GPL(fixed_phy_register);\n\nstruct phy_device *\nfixed_phy_register_with_gpiod(unsigned int irq,\n\t\t\t      struct fixed_phy_status *status,\n\t\t\t      struct gpio_desc *gpiod)\n{\n\treturn __fixed_phy_register(irq, status, NULL, gpiod);\n}\nEXPORT_SYMBOL_GPL(fixed_phy_register_with_gpiod);\n\nvoid fixed_phy_unregister(struct phy_device *phy)\n{\n\tphy_device_remove(phy);\n\tof_node_put(phy->mdio.dev.of_node);\n\tfixed_phy_del(phy->mdio.addr);\n}\nEXPORT_SYMBOL_GPL(fixed_phy_unregister);\n\nstatic int __init fixed_mdio_bus_init(void)\n{\n\tstruct fixed_mdio_bus *fmb = &platform_fmb;\n\tint ret;\n\n\tpdev = platform_device_register_simple(\"Fixed MDIO bus\", 0, NULL, 0);\n\tif (IS_ERR(pdev))\n\t\treturn PTR_ERR(pdev);\n\n\tfmb->mii_bus = mdiobus_alloc();\n\tif (fmb->mii_bus == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_mdiobus_reg;\n\t}\n\n\tsnprintf(fmb->mii_bus->id, MII_BUS_ID_SIZE, \"fixed-0\");\n\tfmb->mii_bus->name = \"Fixed MDIO Bus\";\n\tfmb->mii_bus->priv = fmb;\n\tfmb->mii_bus->parent = &pdev->dev;\n\tfmb->mii_bus->read = &fixed_mdio_read;\n\tfmb->mii_bus->write = &fixed_mdio_write;\n\tfmb->mii_bus->phy_mask = ~0;\n\n\tret = mdiobus_register(fmb->mii_bus);\n\tif (ret)\n\t\tgoto err_mdiobus_alloc;\n\n\treturn 0;\n\nerr_mdiobus_alloc:\n\tmdiobus_free(fmb->mii_bus);\nerr_mdiobus_reg:\n\tplatform_device_unregister(pdev);\n\treturn ret;\n}\nmodule_init(fixed_mdio_bus_init);\n\nstatic void __exit fixed_mdio_bus_exit(void)\n{\n\tstruct fixed_mdio_bus *fmb = &platform_fmb;\n\tstruct fixed_phy *fp, *tmp;\n\n\tmdiobus_unregister(fmb->mii_bus);\n\tmdiobus_free(fmb->mii_bus);\n\tplatform_device_unregister(pdev);\n\n\tlist_for_each_entry_safe(fp, tmp, &fmb->phys, node) {\n\t\tlist_del(&fp->node);\n\t\tkfree(fp);\n\t}\n\tida_destroy(&phy_fixed_ida);\n}\nmodule_exit(fixed_mdio_bus_exit);\n\nMODULE_DESCRIPTION(\"Fixed MDIO bus (MDIO bus emulation with fixed PHYs)\");\nMODULE_AUTHOR(\"Vitaly Bordug\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}