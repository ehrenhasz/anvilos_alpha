{
  "module_name": "adin.c",
  "hash_id": "36f4f3f77646ffef08a3385f87bf1deac480b404883ba2a5518dc736b2ffb6a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/adin.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/ethtool_netlink.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/mii.h>\n#include <linux/phy.h>\n#include <linux/property.h>\n\n#define PHY_ID_ADIN1200\t\t\t\t0x0283bc20\n#define PHY_ID_ADIN1300\t\t\t\t0x0283bc30\n\n#define ADIN1300_MII_EXT_REG_PTR\t\t0x0010\n#define ADIN1300_MII_EXT_REG_DATA\t\t0x0011\n\n#define ADIN1300_PHY_CTRL1\t\t\t0x0012\n#define   ADIN1300_AUTO_MDI_EN\t\t\tBIT(10)\n#define   ADIN1300_MAN_MDIX_EN\t\t\tBIT(9)\n#define   ADIN1300_DIAG_CLK_EN\t\t\tBIT(2)\n\n#define ADIN1300_RX_ERR_CNT\t\t\t0x0014\n\n#define ADIN1300_PHY_CTRL_STATUS2\t\t0x0015\n#define   ADIN1300_NRG_PD_EN\t\t\tBIT(3)\n#define   ADIN1300_NRG_PD_TX_EN\t\t\tBIT(2)\n#define   ADIN1300_NRG_PD_STATUS\t\tBIT(1)\n\n#define ADIN1300_PHY_CTRL2\t\t\t0x0016\n#define   ADIN1300_DOWNSPEED_AN_100_EN\t\tBIT(11)\n#define   ADIN1300_DOWNSPEED_AN_10_EN\t\tBIT(10)\n#define   ADIN1300_GROUP_MDIO_EN\t\tBIT(6)\n#define   ADIN1300_DOWNSPEEDS_EN\t\\\n\t(ADIN1300_DOWNSPEED_AN_100_EN | ADIN1300_DOWNSPEED_AN_10_EN)\n\n#define ADIN1300_PHY_CTRL3\t\t\t0x0017\n#define   ADIN1300_LINKING_EN\t\t\tBIT(13)\n#define   ADIN1300_DOWNSPEED_RETRIES_MSK\tGENMASK(12, 10)\n\n#define ADIN1300_INT_MASK_REG\t\t\t0x0018\n#define   ADIN1300_INT_MDIO_SYNC_EN\t\tBIT(9)\n#define   ADIN1300_INT_ANEG_STAT_CHNG_EN\tBIT(8)\n#define   ADIN1300_INT_ANEG_PAGE_RX_EN\t\tBIT(6)\n#define   ADIN1300_INT_IDLE_ERR_CNT_EN\t\tBIT(5)\n#define   ADIN1300_INT_MAC_FIFO_OU_EN\t\tBIT(4)\n#define   ADIN1300_INT_RX_STAT_CHNG_EN\t\tBIT(3)\n#define   ADIN1300_INT_LINK_STAT_CHNG_EN\tBIT(2)\n#define   ADIN1300_INT_SPEED_CHNG_EN\t\tBIT(1)\n#define   ADIN1300_INT_HW_IRQ_EN\t\tBIT(0)\n#define ADIN1300_INT_MASK_EN\t\\\n\t(ADIN1300_INT_LINK_STAT_CHNG_EN | ADIN1300_INT_HW_IRQ_EN)\n#define ADIN1300_INT_STATUS_REG\t\t\t0x0019\n\n#define ADIN1300_PHY_STATUS1\t\t\t0x001a\n#define   ADIN1300_PAIR_01_SWAP\t\t\tBIT(11)\n\n \n#define ADIN1300_EEE_CAP_REG\t\t\t0x8000\n#define ADIN1300_EEE_ADV_REG\t\t\t0x8001\n#define ADIN1300_EEE_LPABLE_REG\t\t\t0x8002\n#define ADIN1300_CLOCK_STOP_REG\t\t\t0x9400\n#define ADIN1300_LPI_WAKE_ERR_CNT_REG\t\t0xa000\n\n#define ADIN1300_CDIAG_RUN\t\t\t0xba1b\n#define   ADIN1300_CDIAG_RUN_EN\t\t\tBIT(0)\n\n \n#define ADIN1300_CDIAG_DTLD_RSLTS(x)\t\t(0xba1d + (x))\n#define   ADIN1300_CDIAG_RSLT_BUSY\t\tBIT(10)\n#define   ADIN1300_CDIAG_RSLT_XSIM3\t\tBIT(9)\n#define   ADIN1300_CDIAG_RSLT_XSIM2\t\tBIT(8)\n#define   ADIN1300_CDIAG_RSLT_XSIM1\t\tBIT(7)\n#define   ADIN1300_CDIAG_RSLT_SIM\t\tBIT(6)\n#define   ADIN1300_CDIAG_RSLT_XSHRT3\t\tBIT(5)\n#define   ADIN1300_CDIAG_RSLT_XSHRT2\t\tBIT(4)\n#define   ADIN1300_CDIAG_RSLT_XSHRT1\t\tBIT(3)\n#define   ADIN1300_CDIAG_RSLT_SHRT\t\tBIT(2)\n#define   ADIN1300_CDIAG_RSLT_OPEN\t\tBIT(1)\n#define   ADIN1300_CDIAG_RSLT_GOOD\t\tBIT(0)\n\n#define ADIN1300_CDIAG_FLT_DIST(x)\t\t(0xba21 + (x))\n\n#define ADIN1300_GE_SOFT_RESET_REG\t\t0xff0c\n#define   ADIN1300_GE_SOFT_RESET\t\tBIT(0)\n\n#define ADIN1300_GE_CLK_CFG_REG\t\t\t0xff1f\n#define   ADIN1300_GE_CLK_CFG_MASK\t\tGENMASK(5, 0)\n#define   ADIN1300_GE_CLK_CFG_RCVR_125\t\tBIT(5)\n#define   ADIN1300_GE_CLK_CFG_FREE_125\t\tBIT(4)\n#define   ADIN1300_GE_CLK_CFG_REF_EN\t\tBIT(3)\n#define   ADIN1300_GE_CLK_CFG_HRT_RCVR\t\tBIT(2)\n#define   ADIN1300_GE_CLK_CFG_HRT_FREE\t\tBIT(1)\n#define   ADIN1300_GE_CLK_CFG_25\t\tBIT(0)\n\n#define ADIN1300_GE_RGMII_CFG_REG\t\t0xff23\n#define   ADIN1300_GE_RGMII_RX_MSK\t\tGENMASK(8, 6)\n#define   ADIN1300_GE_RGMII_RX_SEL(x)\t\t\\\n\t\tFIELD_PREP(ADIN1300_GE_RGMII_RX_MSK, x)\n#define   ADIN1300_GE_RGMII_GTX_MSK\t\tGENMASK(5, 3)\n#define   ADIN1300_GE_RGMII_GTX_SEL(x)\t\t\\\n\t\tFIELD_PREP(ADIN1300_GE_RGMII_GTX_MSK, x)\n#define   ADIN1300_GE_RGMII_RXID_EN\t\tBIT(2)\n#define   ADIN1300_GE_RGMII_TXID_EN\t\tBIT(1)\n#define   ADIN1300_GE_RGMII_EN\t\t\tBIT(0)\n\n \n#define ADIN1300_RGMII_1_60_NS\t\t\t0x0001\n#define ADIN1300_RGMII_1_80_NS\t\t\t0x0002\n#define\tADIN1300_RGMII_2_00_NS\t\t\t0x0000\n#define\tADIN1300_RGMII_2_20_NS\t\t\t0x0006\n#define\tADIN1300_RGMII_2_40_NS\t\t\t0x0007\n\n#define ADIN1300_GE_RMII_CFG_REG\t\t0xff24\n#define   ADIN1300_GE_RMII_FIFO_DEPTH_MSK\tGENMASK(6, 4)\n#define   ADIN1300_GE_RMII_FIFO_DEPTH_SEL(x)\t\\\n\t\tFIELD_PREP(ADIN1300_GE_RMII_FIFO_DEPTH_MSK, x)\n#define   ADIN1300_GE_RMII_EN\t\t\tBIT(0)\n\n \n#define ADIN1300_RMII_4_BITS\t\t\t0x0000\n#define ADIN1300_RMII_8_BITS\t\t\t0x0001\n#define ADIN1300_RMII_12_BITS\t\t\t0x0002\n#define ADIN1300_RMII_16_BITS\t\t\t0x0003\n#define ADIN1300_RMII_20_BITS\t\t\t0x0004\n#define ADIN1300_RMII_24_BITS\t\t\t0x0005\n\n \nstruct adin_cfg_reg_map {\n\tint cfg;\n\tint reg;\n};\n\nstatic const struct adin_cfg_reg_map adin_rgmii_delays[] = {\n\t{ 1600, ADIN1300_RGMII_1_60_NS },\n\t{ 1800, ADIN1300_RGMII_1_80_NS },\n\t{ 2000, ADIN1300_RGMII_2_00_NS },\n\t{ 2200, ADIN1300_RGMII_2_20_NS },\n\t{ 2400, ADIN1300_RGMII_2_40_NS },\n\t{ },\n};\n\nstatic const struct adin_cfg_reg_map adin_rmii_fifo_depths[] = {\n\t{ 4,  ADIN1300_RMII_4_BITS },\n\t{ 8,  ADIN1300_RMII_8_BITS },\n\t{ 12, ADIN1300_RMII_12_BITS },\n\t{ 16, ADIN1300_RMII_16_BITS },\n\t{ 20, ADIN1300_RMII_20_BITS },\n\t{ 24, ADIN1300_RMII_24_BITS },\n\t{ },\n};\n\n \nstruct adin_clause45_mmd_map {\n\tint devad;\n\tu16 cl45_regnum;\n\tu16 adin_regnum;\n};\n\nstatic const struct adin_clause45_mmd_map adin_clause45_mmd_map[] = {\n\t{ MDIO_MMD_PCS,\tMDIO_PCS_EEE_ABLE,\tADIN1300_EEE_CAP_REG },\n\t{ MDIO_MMD_AN,\tMDIO_AN_EEE_LPABLE,\tADIN1300_EEE_LPABLE_REG },\n\t{ MDIO_MMD_AN,\tMDIO_AN_EEE_ADV,\tADIN1300_EEE_ADV_REG },\n\t{ MDIO_MMD_PCS,\tMDIO_CTRL1,\t\tADIN1300_CLOCK_STOP_REG },\n\t{ MDIO_MMD_PCS, MDIO_PCS_EEE_WK_ERR,\tADIN1300_LPI_WAKE_ERR_CNT_REG },\n};\n\nstruct adin_hw_stat {\n\tconst char *string;\n\tu16 reg1;\n\tu16 reg2;\n};\n\nstatic const struct adin_hw_stat adin_hw_stats[] = {\n\t{ \"total_frames_checked_count\",\t\t0x940A, 0x940B },  \n\t{ \"length_error_frames_count\",\t\t0x940C },\n\t{ \"alignment_error_frames_count\",\t0x940D },\n\t{ \"symbol_error_count\",\t\t\t0x940E },\n\t{ \"oversized_frames_count\",\t\t0x940F },\n\t{ \"undersized_frames_count\",\t\t0x9410 },\n\t{ \"odd_nibble_frames_count\",\t\t0x9411 },\n\t{ \"odd_preamble_packet_count\",\t\t0x9412 },\n\t{ \"dribble_bits_frames_count\",\t\t0x9413 },\n\t{ \"false_carrier_events_count\",\t\t0x9414 },\n};\n\n \nstruct adin_priv {\n\tu64\t\t\tstats[ARRAY_SIZE(adin_hw_stats)];\n};\n\nstatic int adin_lookup_reg_value(const struct adin_cfg_reg_map *tbl, int cfg)\n{\n\tsize_t i;\n\n\tfor (i = 0; tbl[i].cfg; i++) {\n\t\tif (tbl[i].cfg == cfg)\n\t\t\treturn tbl[i].reg;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic u32 adin_get_reg_value(struct phy_device *phydev,\n\t\t\t      const char *prop_name,\n\t\t\t      const struct adin_cfg_reg_map *tbl,\n\t\t\t      u32 dflt)\n{\n\tstruct device *dev = &phydev->mdio.dev;\n\tu32 val;\n\tint rc;\n\n\tif (device_property_read_u32(dev, prop_name, &val))\n\t\treturn dflt;\n\n\trc = adin_lookup_reg_value(tbl, val);\n\tif (rc < 0) {\n\t\tphydev_warn(phydev,\n\t\t\t    \"Unsupported value %u for %s using default (%u)\\n\",\n\t\t\t    val, prop_name, dflt);\n\t\treturn dflt;\n\t}\n\n\treturn rc;\n}\n\nstatic int adin_config_rgmii_mode(struct phy_device *phydev)\n{\n\tu32 val;\n\tint reg;\n\n\tif (!phy_interface_is_rgmii(phydev))\n\t\treturn phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t\t\t  ADIN1300_GE_RGMII_CFG_REG,\n\t\t\t\t\t  ADIN1300_GE_RGMII_EN);\n\n\treg = phy_read_mmd(phydev, MDIO_MMD_VEND1, ADIN1300_GE_RGMII_CFG_REG);\n\tif (reg < 0)\n\t\treturn reg;\n\n\treg |= ADIN1300_GE_RGMII_EN;\n\n\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID ||\n\t    phydev->interface == PHY_INTERFACE_MODE_RGMII_RXID) {\n\t\treg |= ADIN1300_GE_RGMII_RXID_EN;\n\n\t\tval = adin_get_reg_value(phydev, \"adi,rx-internal-delay-ps\",\n\t\t\t\t\t adin_rgmii_delays,\n\t\t\t\t\t ADIN1300_RGMII_2_00_NS);\n\t\treg &= ~ADIN1300_GE_RGMII_RX_MSK;\n\t\treg |= ADIN1300_GE_RGMII_RX_SEL(val);\n\t} else {\n\t\treg &= ~ADIN1300_GE_RGMII_RXID_EN;\n\t}\n\n\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID ||\n\t    phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID) {\n\t\treg |= ADIN1300_GE_RGMII_TXID_EN;\n\n\t\tval = adin_get_reg_value(phydev, \"adi,tx-internal-delay-ps\",\n\t\t\t\t\t adin_rgmii_delays,\n\t\t\t\t\t ADIN1300_RGMII_2_00_NS);\n\t\treg &= ~ADIN1300_GE_RGMII_GTX_MSK;\n\t\treg |= ADIN1300_GE_RGMII_GTX_SEL(val);\n\t} else {\n\t\treg &= ~ADIN1300_GE_RGMII_TXID_EN;\n\t}\n\n\treturn phy_write_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t     ADIN1300_GE_RGMII_CFG_REG, reg);\n}\n\nstatic int adin_config_rmii_mode(struct phy_device *phydev)\n{\n\tu32 val;\n\tint reg;\n\n\tif (phydev->interface != PHY_INTERFACE_MODE_RMII)\n\t\treturn phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t\t\t  ADIN1300_GE_RMII_CFG_REG,\n\t\t\t\t\t  ADIN1300_GE_RMII_EN);\n\n\treg = phy_read_mmd(phydev, MDIO_MMD_VEND1, ADIN1300_GE_RMII_CFG_REG);\n\tif (reg < 0)\n\t\treturn reg;\n\n\treg |= ADIN1300_GE_RMII_EN;\n\n\tval = adin_get_reg_value(phydev, \"adi,fifo-depth-bits\",\n\t\t\t\t adin_rmii_fifo_depths,\n\t\t\t\t ADIN1300_RMII_8_BITS);\n\n\treg &= ~ADIN1300_GE_RMII_FIFO_DEPTH_MSK;\n\treg |= ADIN1300_GE_RMII_FIFO_DEPTH_SEL(val);\n\n\treturn phy_write_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t     ADIN1300_GE_RMII_CFG_REG, reg);\n}\n\nstatic int adin_get_downshift(struct phy_device *phydev, u8 *data)\n{\n\tint val, cnt, enable;\n\n\tval = phy_read(phydev, ADIN1300_PHY_CTRL2);\n\tif (val < 0)\n\t\treturn val;\n\n\tcnt = phy_read(phydev, ADIN1300_PHY_CTRL3);\n\tif (cnt < 0)\n\t\treturn cnt;\n\n\tenable = FIELD_GET(ADIN1300_DOWNSPEEDS_EN, val);\n\tcnt = FIELD_GET(ADIN1300_DOWNSPEED_RETRIES_MSK, cnt);\n\n\t*data = (enable && cnt) ? cnt : DOWNSHIFT_DEV_DISABLE;\n\n\treturn 0;\n}\n\nstatic int adin_set_downshift(struct phy_device *phydev, u8 cnt)\n{\n\tu16 val;\n\tint rc;\n\n\tif (cnt == DOWNSHIFT_DEV_DISABLE)\n\t\treturn phy_clear_bits(phydev, ADIN1300_PHY_CTRL2,\n\t\t\t\t      ADIN1300_DOWNSPEEDS_EN);\n\n\tif (cnt > 7)\n\t\treturn -E2BIG;\n\n\tval = FIELD_PREP(ADIN1300_DOWNSPEED_RETRIES_MSK, cnt);\n\n\trc = phy_modify(phydev, ADIN1300_PHY_CTRL3,\n\t\t\tADIN1300_DOWNSPEED_RETRIES_MSK,\n\t\t\tval);\n\tif (rc < 0)\n\t\treturn rc;\n\n\treturn phy_set_bits(phydev, ADIN1300_PHY_CTRL2,\n\t\t\t    ADIN1300_DOWNSPEEDS_EN);\n}\n\nstatic int adin_get_edpd(struct phy_device *phydev, u16 *tx_interval)\n{\n\tint val;\n\n\tval = phy_read(phydev, ADIN1300_PHY_CTRL_STATUS2);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (ADIN1300_NRG_PD_EN & val) {\n\t\tif (val & ADIN1300_NRG_PD_TX_EN)\n\t\t\t \n\t\t\t*tx_interval = ETHTOOL_PHY_EDPD_DFLT_TX_MSECS;\n\t\telse\n\t\t\t*tx_interval = ETHTOOL_PHY_EDPD_NO_TX;\n\t} else {\n\t\t*tx_interval = ETHTOOL_PHY_EDPD_DISABLE;\n\t}\n\n\treturn 0;\n}\n\nstatic int adin_set_edpd(struct phy_device *phydev, u16 tx_interval)\n{\n\tu16 val;\n\n\tif (tx_interval == ETHTOOL_PHY_EDPD_DISABLE)\n\t\treturn phy_clear_bits(phydev, ADIN1300_PHY_CTRL_STATUS2,\n\t\t\t\t(ADIN1300_NRG_PD_EN | ADIN1300_NRG_PD_TX_EN));\n\n\tval = ADIN1300_NRG_PD_EN;\n\n\tswitch (tx_interval) {\n\tcase 1000:  \n\t\tfallthrough;\n\tcase ETHTOOL_PHY_EDPD_DFLT_TX_MSECS:\n\t\tval |= ADIN1300_NRG_PD_TX_EN;\n\t\tfallthrough;\n\tcase ETHTOOL_PHY_EDPD_NO_TX:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn phy_modify(phydev, ADIN1300_PHY_CTRL_STATUS2,\n\t\t\t  (ADIN1300_NRG_PD_EN | ADIN1300_NRG_PD_TX_EN),\n\t\t\t  val);\n}\n\nstatic int adin_get_tunable(struct phy_device *phydev,\n\t\t\t    struct ethtool_tunable *tuna, void *data)\n{\n\tswitch (tuna->id) {\n\tcase ETHTOOL_PHY_DOWNSHIFT:\n\t\treturn adin_get_downshift(phydev, data);\n\tcase ETHTOOL_PHY_EDPD:\n\t\treturn adin_get_edpd(phydev, data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int adin_set_tunable(struct phy_device *phydev,\n\t\t\t    struct ethtool_tunable *tuna, const void *data)\n{\n\tswitch (tuna->id) {\n\tcase ETHTOOL_PHY_DOWNSHIFT:\n\t\treturn adin_set_downshift(phydev, *(const u8 *)data);\n\tcase ETHTOOL_PHY_EDPD:\n\t\treturn adin_set_edpd(phydev, *(const u16 *)data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int adin_config_clk_out(struct phy_device *phydev)\n{\n\tstruct device *dev = &phydev->mdio.dev;\n\tconst char *val = NULL;\n\tu8 sel = 0;\n\n\tdevice_property_read_string(dev, \"adi,phy-output-clock\", &val);\n\tif (!val) {\n\t\t \n\t} else if (strcmp(val, \"25mhz-reference\") == 0) {\n\t\tsel |= ADIN1300_GE_CLK_CFG_25;\n\t} else if (strcmp(val, \"125mhz-free-running\") == 0) {\n\t\tsel |= ADIN1300_GE_CLK_CFG_FREE_125;\n\t} else if (strcmp(val, \"adaptive-free-running\") == 0) {\n\t\tsel |= ADIN1300_GE_CLK_CFG_HRT_FREE;\n\t} else {\n\t\tphydev_err(phydev, \"invalid adi,phy-output-clock\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (device_property_read_bool(dev, \"adi,phy-output-reference-clock\"))\n\t\tsel |= ADIN1300_GE_CLK_CFG_REF_EN;\n\n\treturn phy_modify_mmd(phydev, MDIO_MMD_VEND1, ADIN1300_GE_CLK_CFG_REG,\n\t\t\t      ADIN1300_GE_CLK_CFG_MASK, sel);\n}\n\nstatic int adin_config_init(struct phy_device *phydev)\n{\n\tint rc;\n\n\tphydev->mdix_ctrl = ETH_TP_MDI_AUTO;\n\n\trc = adin_config_rgmii_mode(phydev);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = adin_config_rmii_mode(phydev);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = adin_set_downshift(phydev, 4);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = adin_set_edpd(phydev, ETHTOOL_PHY_EDPD_DFLT_TX_MSECS);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = adin_config_clk_out(phydev);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tphydev_dbg(phydev, \"PHY is using mode '%s'\\n\",\n\t\t   phy_modes(phydev->interface));\n\n\treturn 0;\n}\n\nstatic int adin_phy_ack_intr(struct phy_device *phydev)\n{\n\t \n\tint rc = phy_read(phydev, ADIN1300_INT_STATUS_REG);\n\n\treturn rc < 0 ? rc : 0;\n}\n\nstatic int adin_phy_config_intr(struct phy_device *phydev)\n{\n\tint err;\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\terr = adin_phy_ack_intr(phydev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = phy_set_bits(phydev, ADIN1300_INT_MASK_REG,\n\t\t\t\t   ADIN1300_INT_MASK_EN);\n\t} else {\n\t\terr = phy_clear_bits(phydev, ADIN1300_INT_MASK_REG,\n\t\t\t\t     ADIN1300_INT_MASK_EN);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = adin_phy_ack_intr(phydev);\n\t}\n\n\treturn err;\n}\n\nstatic irqreturn_t adin_phy_handle_interrupt(struct phy_device *phydev)\n{\n\tint irq_status;\n\n\tirq_status = phy_read(phydev, ADIN1300_INT_STATUS_REG);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (!(irq_status & ADIN1300_INT_LINK_STAT_CHNG_EN))\n\t\treturn IRQ_NONE;\n\n\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int adin_cl45_to_adin_reg(struct phy_device *phydev, int devad,\n\t\t\t\t u16 cl45_regnum)\n{\n\tconst struct adin_clause45_mmd_map *m;\n\tint i;\n\n\tif (devad == MDIO_MMD_VEND1)\n\t\treturn cl45_regnum;\n\n\tfor (i = 0; i < ARRAY_SIZE(adin_clause45_mmd_map); i++) {\n\t\tm = &adin_clause45_mmd_map[i];\n\t\tif (m->devad == devad && m->cl45_regnum == cl45_regnum)\n\t\t\treturn m->adin_regnum;\n\t}\n\n\tphydev_err(phydev,\n\t\t   \"No translation available for devad: %d reg: %04x\\n\",\n\t\t   devad, cl45_regnum);\n\n\treturn -EINVAL;\n}\n\nstatic int adin_read_mmd(struct phy_device *phydev, int devad, u16 regnum)\n{\n\tstruct mii_bus *bus = phydev->mdio.bus;\n\tint phy_addr = phydev->mdio.addr;\n\tint adin_regnum;\n\tint err;\n\n\tadin_regnum = adin_cl45_to_adin_reg(phydev, devad, regnum);\n\tif (adin_regnum < 0)\n\t\treturn adin_regnum;\n\n\terr = __mdiobus_write(bus, phy_addr, ADIN1300_MII_EXT_REG_PTR,\n\t\t\t      adin_regnum);\n\tif (err)\n\t\treturn err;\n\n\treturn __mdiobus_read(bus, phy_addr, ADIN1300_MII_EXT_REG_DATA);\n}\n\nstatic int adin_write_mmd(struct phy_device *phydev, int devad, u16 regnum,\n\t\t\t  u16 val)\n{\n\tstruct mii_bus *bus = phydev->mdio.bus;\n\tint phy_addr = phydev->mdio.addr;\n\tint adin_regnum;\n\tint err;\n\n\tadin_regnum = adin_cl45_to_adin_reg(phydev, devad, regnum);\n\tif (adin_regnum < 0)\n\t\treturn adin_regnum;\n\n\terr = __mdiobus_write(bus, phy_addr, ADIN1300_MII_EXT_REG_PTR,\n\t\t\t      adin_regnum);\n\tif (err)\n\t\treturn err;\n\n\treturn __mdiobus_write(bus, phy_addr, ADIN1300_MII_EXT_REG_DATA, val);\n}\n\nstatic int adin_config_mdix(struct phy_device *phydev)\n{\n\tbool auto_en, mdix_en;\n\tint reg;\n\n\tmdix_en = false;\n\tauto_en = false;\n\tswitch (phydev->mdix_ctrl) {\n\tcase ETH_TP_MDI:\n\t\tbreak;\n\tcase ETH_TP_MDI_X:\n\t\tmdix_en = true;\n\t\tbreak;\n\tcase ETH_TP_MDI_AUTO:\n\t\tauto_en = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treg = phy_read(phydev, ADIN1300_PHY_CTRL1);\n\tif (reg < 0)\n\t\treturn reg;\n\n\tif (mdix_en)\n\t\treg |= ADIN1300_MAN_MDIX_EN;\n\telse\n\t\treg &= ~ADIN1300_MAN_MDIX_EN;\n\n\tif (auto_en)\n\t\treg |= ADIN1300_AUTO_MDI_EN;\n\telse\n\t\treg &= ~ADIN1300_AUTO_MDI_EN;\n\n\treturn phy_write(phydev, ADIN1300_PHY_CTRL1, reg);\n}\n\nstatic int adin_config_aneg(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = phy_clear_bits(phydev, ADIN1300_PHY_CTRL1, ADIN1300_DIAG_CLK_EN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = phy_set_bits(phydev, ADIN1300_PHY_CTRL3, ADIN1300_LINKING_EN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = adin_config_mdix(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn genphy_config_aneg(phydev);\n}\n\nstatic int adin_mdix_update(struct phy_device *phydev)\n{\n\tbool auto_en, mdix_en;\n\tbool swapped;\n\tint reg;\n\n\treg = phy_read(phydev, ADIN1300_PHY_CTRL1);\n\tif (reg < 0)\n\t\treturn reg;\n\n\tauto_en = !!(reg & ADIN1300_AUTO_MDI_EN);\n\tmdix_en = !!(reg & ADIN1300_MAN_MDIX_EN);\n\n\t \n\tif (!auto_en) {\n\t\tif (mdix_en)\n\t\t\tphydev->mdix = ETH_TP_MDI_X;\n\t\telse\n\t\t\tphydev->mdix = ETH_TP_MDI;\n\t\treturn 0;\n\t}\n\n\t \n\treg = phy_read(phydev, ADIN1300_PHY_STATUS1);\n\tif (reg < 0)\n\t\treturn reg;\n\n\tswapped = !!(reg & ADIN1300_PAIR_01_SWAP);\n\n\tif (mdix_en != swapped)\n\t\tphydev->mdix = ETH_TP_MDI_X;\n\telse\n\t\tphydev->mdix = ETH_TP_MDI;\n\n\treturn 0;\n}\n\nstatic int adin_read_status(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = adin_mdix_update(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn genphy_read_status(phydev);\n}\n\nstatic int adin_soft_reset(struct phy_device *phydev)\n{\n\tint rc;\n\n\t \n\trc = phy_set_bits_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t      ADIN1300_GE_SOFT_RESET_REG,\n\t\t\t      ADIN1300_GE_SOFT_RESET);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tmsleep(20);\n\n\t \n\trc = phy_read_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t  ADIN1300_GE_SOFT_RESET_REG);\n\n\treturn rc < 0 ? rc : 0;\n}\n\nstatic int adin_get_sset_count(struct phy_device *phydev)\n{\n\treturn ARRAY_SIZE(adin_hw_stats);\n}\n\nstatic void adin_get_strings(struct phy_device *phydev, u8 *data)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(adin_hw_stats); i++) {\n\t\tstrscpy(&data[i * ETH_GSTRING_LEN],\n\t\t\tadin_hw_stats[i].string, ETH_GSTRING_LEN);\n\t}\n}\n\nstatic int adin_read_mmd_stat_regs(struct phy_device *phydev,\n\t\t\t\t   const struct adin_hw_stat *stat,\n\t\t\t\t   u32 *val)\n{\n\tint ret;\n\n\tret = phy_read_mmd(phydev, MDIO_MMD_VEND1, stat->reg1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = (ret & 0xffff);\n\n\tif (stat->reg2 == 0)\n\t\treturn 0;\n\n\tret = phy_read_mmd(phydev, MDIO_MMD_VEND1, stat->reg2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val <<= 16;\n\t*val |= (ret & 0xffff);\n\n\treturn 0;\n}\n\nstatic u64 adin_get_stat(struct phy_device *phydev, int i)\n{\n\tconst struct adin_hw_stat *stat = &adin_hw_stats[i];\n\tstruct adin_priv *priv = phydev->priv;\n\tu32 val;\n\tint ret;\n\n\tif (stat->reg1 > 0x1f) {\n\t\tret = adin_read_mmd_stat_regs(phydev, stat, &val);\n\t\tif (ret < 0)\n\t\t\treturn (u64)(~0);\n\t} else {\n\t\tret = phy_read(phydev, stat->reg1);\n\t\tif (ret < 0)\n\t\t\treturn (u64)(~0);\n\t\tval = (ret & 0xffff);\n\t}\n\n\tpriv->stats[i] += val;\n\n\treturn priv->stats[i];\n}\n\nstatic void adin_get_stats(struct phy_device *phydev,\n\t\t\t   struct ethtool_stats *stats, u64 *data)\n{\n\tint i, rc;\n\n\t \n\trc = phy_read(phydev, ADIN1300_RX_ERR_CNT);\n\tif (rc < 0)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(adin_hw_stats); i++)\n\t\tdata[i] = adin_get_stat(phydev, i);\n}\n\nstatic int adin_probe(struct phy_device *phydev)\n{\n\tstruct device *dev = &phydev->mdio.dev;\n\tstruct adin_priv *priv;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tphydev->priv = priv;\n\n\treturn 0;\n}\n\nstatic int adin_cable_test_start(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = phy_clear_bits(phydev, ADIN1300_PHY_CTRL3, ADIN1300_LINKING_EN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = phy_clear_bits(phydev, ADIN1300_PHY_CTRL1, ADIN1300_DIAG_CLK_EN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tmsleep(50);\n\n\treturn phy_set_bits_mmd(phydev, MDIO_MMD_VEND1, ADIN1300_CDIAG_RUN,\n\t\t\t\tADIN1300_CDIAG_RUN_EN);\n}\n\nstatic int adin_cable_test_report_trans(int result)\n{\n\tint mask;\n\n\tif (result & ADIN1300_CDIAG_RSLT_GOOD)\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_OK;\n\tif (result & ADIN1300_CDIAG_RSLT_OPEN)\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_OPEN;\n\n\t \n\tmask = ADIN1300_CDIAG_RSLT_XSHRT3 |\n\t       ADIN1300_CDIAG_RSLT_XSHRT2 |\n\t       ADIN1300_CDIAG_RSLT_XSHRT1;\n\tif (result & mask)\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_CROSS_SHORT;\n\n\tif (result & ADIN1300_CDIAG_RSLT_SHRT)\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_SAME_SHORT;\n\n\treturn ETHTOOL_A_CABLE_RESULT_CODE_UNSPEC;\n}\n\nstatic int adin_cable_test_report_pair(struct phy_device *phydev,\n\t\t\t\t       unsigned int pair)\n{\n\tint fault_rslt;\n\tint ret;\n\n\tret = phy_read_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t   ADIN1300_CDIAG_DTLD_RSLTS(pair));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfault_rslt = adin_cable_test_report_trans(ret);\n\n\tret = ethnl_cable_test_result(phydev, pair, fault_rslt);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = phy_read_mmd(phydev, MDIO_MMD_VEND1,\n\t\t\t   ADIN1300_CDIAG_FLT_DIST(pair));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (fault_rslt) {\n\tcase ETHTOOL_A_CABLE_RESULT_CODE_OPEN:\n\tcase ETHTOOL_A_CABLE_RESULT_CODE_SAME_SHORT:\n\tcase ETHTOOL_A_CABLE_RESULT_CODE_CROSS_SHORT:\n\t\treturn ethnl_cable_test_fault_length(phydev, pair, ret * 100);\n\tdefault:\n\t\treturn  0;\n\t}\n}\n\nstatic int adin_cable_test_report(struct phy_device *phydev)\n{\n\tunsigned int pair;\n\tint ret;\n\n\tfor (pair = ETHTOOL_A_CABLE_PAIR_A; pair <= ETHTOOL_A_CABLE_PAIR_D; pair++) {\n\t\tret = adin_cable_test_report_pair(phydev, pair);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int adin_cable_test_get_status(struct phy_device *phydev,\n\t\t\t\t      bool *finished)\n{\n\tint ret;\n\n\t*finished = false;\n\n\tret = phy_read_mmd(phydev, MDIO_MMD_VEND1, ADIN1300_CDIAG_RUN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & ADIN1300_CDIAG_RUN_EN)\n\t\treturn 0;\n\n\t*finished = true;\n\n\treturn adin_cable_test_report(phydev);\n}\n\nstatic struct phy_driver adin_driver[] = {\n\t{\n\t\tPHY_ID_MATCH_MODEL(PHY_ID_ADIN1200),\n\t\t.name\t\t= \"ADIN1200\",\n\t\t.flags\t\t= PHY_POLL_CABLE_TEST,\n\t\t.probe\t\t= adin_probe,\n\t\t.config_init\t= adin_config_init,\n\t\t.soft_reset\t= adin_soft_reset,\n\t\t.config_aneg\t= adin_config_aneg,\n\t\t.read_status\t= adin_read_status,\n\t\t.get_tunable\t= adin_get_tunable,\n\t\t.set_tunable\t= adin_set_tunable,\n\t\t.config_intr\t= adin_phy_config_intr,\n\t\t.handle_interrupt = adin_phy_handle_interrupt,\n\t\t.get_sset_count\t= adin_get_sset_count,\n\t\t.get_strings\t= adin_get_strings,\n\t\t.get_stats\t= adin_get_stats,\n\t\t.resume\t\t= genphy_resume,\n\t\t.suspend\t= genphy_suspend,\n\t\t.read_mmd\t= adin_read_mmd,\n\t\t.write_mmd\t= adin_write_mmd,\n\t\t.cable_test_start\t= adin_cable_test_start,\n\t\t.cable_test_get_status\t= adin_cable_test_get_status,\n\t},\n\t{\n\t\tPHY_ID_MATCH_MODEL(PHY_ID_ADIN1300),\n\t\t.name\t\t= \"ADIN1300\",\n\t\t.flags\t\t= PHY_POLL_CABLE_TEST,\n\t\t.probe\t\t= adin_probe,\n\t\t.config_init\t= adin_config_init,\n\t\t.soft_reset\t= adin_soft_reset,\n\t\t.config_aneg\t= adin_config_aneg,\n\t\t.read_status\t= adin_read_status,\n\t\t.get_tunable\t= adin_get_tunable,\n\t\t.set_tunable\t= adin_set_tunable,\n\t\t.config_intr\t= adin_phy_config_intr,\n\t\t.handle_interrupt = adin_phy_handle_interrupt,\n\t\t.get_sset_count\t= adin_get_sset_count,\n\t\t.get_strings\t= adin_get_strings,\n\t\t.get_stats\t= adin_get_stats,\n\t\t.resume\t\t= genphy_resume,\n\t\t.suspend\t= genphy_suspend,\n\t\t.read_mmd\t= adin_read_mmd,\n\t\t.write_mmd\t= adin_write_mmd,\n\t\t.cable_test_start\t= adin_cable_test_start,\n\t\t.cable_test_get_status\t= adin_cable_test_get_status,\n\t},\n};\n\nmodule_phy_driver(adin_driver);\n\nstatic struct mdio_device_id __maybe_unused adin_tbl[] = {\n\t{ PHY_ID_MATCH_MODEL(PHY_ID_ADIN1200) },\n\t{ PHY_ID_MATCH_MODEL(PHY_ID_ADIN1300) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(mdio, adin_tbl);\nMODULE_DESCRIPTION(\"Analog Devices Industrial Ethernet PHY driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}