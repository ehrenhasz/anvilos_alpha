{
  "module_name": "micrel.c",
  "hash_id": "8ed5de7099d40d5800bee3aff7b6ca44b259895805aee44ecb9b3a2d28720dd5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/micrel.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/ethtool_netlink.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/phy.h>\n#include <linux/micrel_phy.h>\n#include <linux/of.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/ptp_clock_kernel.h>\n#include <linux/ptp_clock.h>\n#include <linux/ptp_classify.h>\n#include <linux/net_tstamp.h>\n#include <linux/gpio/consumer.h>\n\n \n#define MII_KSZPHY_OMSO\t\t\t\t0x16\n#define KSZPHY_OMSO_FACTORY_TEST\t\tBIT(15)\n#define KSZPHY_OMSO_B_CAST_OFF\t\t\tBIT(9)\n#define KSZPHY_OMSO_NAND_TREE_ON\t\tBIT(5)\n#define KSZPHY_OMSO_RMII_OVERRIDE\t\tBIT(1)\n#define KSZPHY_OMSO_MII_OVERRIDE\t\tBIT(0)\n\n \n#define MII_KSZPHY_INTCS\t\t\t0x1B\n#define KSZPHY_INTCS_JABBER\t\t\tBIT(15)\n#define KSZPHY_INTCS_RECEIVE_ERR\t\tBIT(14)\n#define KSZPHY_INTCS_PAGE_RECEIVE\t\tBIT(13)\n#define KSZPHY_INTCS_PARELLEL\t\t\tBIT(12)\n#define KSZPHY_INTCS_LINK_PARTNER_ACK\t\tBIT(11)\n#define KSZPHY_INTCS_LINK_DOWN\t\t\tBIT(10)\n#define KSZPHY_INTCS_REMOTE_FAULT\t\tBIT(9)\n#define KSZPHY_INTCS_LINK_UP\t\t\tBIT(8)\n#define KSZPHY_INTCS_ALL\t\t\t(KSZPHY_INTCS_LINK_UP |\\\n\t\t\t\t\t\tKSZPHY_INTCS_LINK_DOWN)\n#define KSZPHY_INTCS_LINK_DOWN_STATUS\t\tBIT(2)\n#define KSZPHY_INTCS_LINK_UP_STATUS\t\tBIT(0)\n#define KSZPHY_INTCS_STATUS\t\t\t(KSZPHY_INTCS_LINK_DOWN_STATUS |\\\n\t\t\t\t\t\t KSZPHY_INTCS_LINK_UP_STATUS)\n\n \n#define KSZ8081_LMD\t\t\t\t0x1d\n#define KSZ8081_LMD_ENABLE_TEST\t\t\tBIT(15)\n#define KSZ8081_LMD_STAT_NORMAL\t\t\t0\n#define KSZ8081_LMD_STAT_OPEN\t\t\t1\n#define KSZ8081_LMD_STAT_SHORT\t\t\t2\n#define KSZ8081_LMD_STAT_FAIL\t\t\t3\n#define KSZ8081_LMD_STAT_MASK\t\t\tGENMASK(14, 13)\n \n#define KSZ8081_LMD_SHORT_INDICATOR\t\tBIT(12)\n#define KSZ8081_LMD_DELTA_TIME_MASK\t\tGENMASK(8, 0)\n\n#define KSZ9x31_LMD\t\t\t\t0x12\n#define KSZ9x31_LMD_VCT_EN\t\t\tBIT(15)\n#define KSZ9x31_LMD_VCT_DIS_TX\t\t\tBIT(14)\n#define KSZ9x31_LMD_VCT_PAIR(n)\t\t\t(((n) & 0x3) << 12)\n#define KSZ9x31_LMD_VCT_SEL_RESULT\t\t0\n#define KSZ9x31_LMD_VCT_SEL_THRES_HI\t\tBIT(10)\n#define KSZ9x31_LMD_VCT_SEL_THRES_LO\t\tBIT(11)\n#define KSZ9x31_LMD_VCT_SEL_MASK\t\tGENMASK(11, 10)\n#define KSZ9x31_LMD_VCT_ST_NORMAL\t\t0\n#define KSZ9x31_LMD_VCT_ST_OPEN\t\t\t1\n#define KSZ9x31_LMD_VCT_ST_SHORT\t\t2\n#define KSZ9x31_LMD_VCT_ST_FAIL\t\t\t3\n#define KSZ9x31_LMD_VCT_ST_MASK\t\t\tGENMASK(9, 8)\n#define KSZ9x31_LMD_VCT_DATA_REFLECTED_INVALID\tBIT(7)\n#define KSZ9x31_LMD_VCT_DATA_SIG_WAIT_TOO_LONG\tBIT(6)\n#define KSZ9x31_LMD_VCT_DATA_MASK100\t\tBIT(5)\n#define KSZ9x31_LMD_VCT_DATA_NLP_FLP\t\tBIT(4)\n#define KSZ9x31_LMD_VCT_DATA_LO_PULSE_MASK\tGENMASK(3, 2)\n#define KSZ9x31_LMD_VCT_DATA_HI_PULSE_MASK\tGENMASK(1, 0)\n#define KSZ9x31_LMD_VCT_DATA_MASK\t\tGENMASK(7, 0)\n\n#define KSZPHY_WIRE_PAIR_MASK\t\t\t0x3\n\n#define LAN8814_CABLE_DIAG\t\t\t0x12\n#define LAN8814_CABLE_DIAG_STAT_MASK\t\tGENMASK(9, 8)\n#define LAN8814_CABLE_DIAG_VCT_DATA_MASK\tGENMASK(7, 0)\n#define LAN8814_PAIR_BIT_SHIFT\t\t\t12\n\n#define LAN8814_WIRE_PAIR_MASK\t\t\t0xF\n\n \n#define LAN8814_INTC\t\t\t\t0x18\n#define LAN8814_INTS\t\t\t\t0x1B\n\n#define LAN8814_INT_LINK_DOWN\t\t\tBIT(2)\n#define LAN8814_INT_LINK_UP\t\t\tBIT(0)\n#define LAN8814_INT_LINK\t\t\t(LAN8814_INT_LINK_UP |\\\n\t\t\t\t\t\t LAN8814_INT_LINK_DOWN)\n\n#define LAN8814_INTR_CTRL_REG\t\t\t0x34\n#define LAN8814_INTR_CTRL_REG_POLARITY\t\tBIT(1)\n#define LAN8814_INTR_CTRL_REG_INTR_ENABLE\tBIT(0)\n\n \n#define LAN8814_1PPM_FORMAT\t\t\t17179\n\n#define PTP_RX_MOD\t\t\t\t0x024F\n#define PTP_RX_MOD_BAD_UDPV4_CHKSUM_FORCE_FCS_DIS_ BIT(3)\n#define PTP_RX_TIMESTAMP_EN\t\t\t0x024D\n#define PTP_TX_TIMESTAMP_EN\t\t\t0x028D\n\n#define PTP_TIMESTAMP_EN_SYNC_\t\t\tBIT(0)\n#define PTP_TIMESTAMP_EN_DREQ_\t\t\tBIT(1)\n#define PTP_TIMESTAMP_EN_PDREQ_\t\t\tBIT(2)\n#define PTP_TIMESTAMP_EN_PDRES_\t\t\tBIT(3)\n\n#define PTP_TX_PARSE_L2_ADDR_EN\t\t\t0x0284\n#define PTP_RX_PARSE_L2_ADDR_EN\t\t\t0x0244\n\n#define PTP_TX_PARSE_IP_ADDR_EN\t\t\t0x0285\n#define PTP_RX_PARSE_IP_ADDR_EN\t\t\t0x0245\n#define LTC_HARD_RESET\t\t\t\t0x023F\n#define LTC_HARD_RESET_\t\t\t\tBIT(0)\n\n#define TSU_HARD_RESET\t\t\t\t0x02C1\n#define TSU_HARD_RESET_\t\t\t\tBIT(0)\n\n#define PTP_CMD_CTL\t\t\t\t0x0200\n#define PTP_CMD_CTL_PTP_DISABLE_\t\tBIT(0)\n#define PTP_CMD_CTL_PTP_ENABLE_\t\t\tBIT(1)\n#define PTP_CMD_CTL_PTP_CLOCK_READ_\t\tBIT(3)\n#define PTP_CMD_CTL_PTP_CLOCK_LOAD_\t\tBIT(4)\n#define PTP_CMD_CTL_PTP_LTC_STEP_SEC_\t\tBIT(5)\n#define PTP_CMD_CTL_PTP_LTC_STEP_NSEC_\t\tBIT(6)\n\n#define PTP_CLOCK_SET_SEC_MID\t\t\t0x0206\n#define PTP_CLOCK_SET_SEC_LO\t\t\t0x0207\n#define PTP_CLOCK_SET_NS_HI\t\t\t0x0208\n#define PTP_CLOCK_SET_NS_LO\t\t\t0x0209\n\n#define PTP_CLOCK_READ_SEC_MID\t\t\t0x022A\n#define PTP_CLOCK_READ_SEC_LO\t\t\t0x022B\n#define PTP_CLOCK_READ_NS_HI\t\t\t0x022C\n#define PTP_CLOCK_READ_NS_LO\t\t\t0x022D\n\n#define PTP_OPERATING_MODE\t\t\t0x0241\n#define PTP_OPERATING_MODE_STANDALONE_\t\tBIT(0)\n\n#define PTP_TX_MOD\t\t\t\t0x028F\n#define PTP_TX_MOD_TX_PTP_SYNC_TS_INSERT_\tBIT(12)\n#define PTP_TX_MOD_BAD_UDPV4_CHKSUM_FORCE_FCS_DIS_ BIT(3)\n\n#define PTP_RX_PARSE_CONFIG\t\t\t0x0242\n#define PTP_RX_PARSE_CONFIG_LAYER2_EN_\t\tBIT(0)\n#define PTP_RX_PARSE_CONFIG_IPV4_EN_\t\tBIT(1)\n#define PTP_RX_PARSE_CONFIG_IPV6_EN_\t\tBIT(2)\n\n#define PTP_TX_PARSE_CONFIG\t\t\t0x0282\n#define PTP_TX_PARSE_CONFIG_LAYER2_EN_\t\tBIT(0)\n#define PTP_TX_PARSE_CONFIG_IPV4_EN_\t\tBIT(1)\n#define PTP_TX_PARSE_CONFIG_IPV6_EN_\t\tBIT(2)\n\n#define PTP_CLOCK_RATE_ADJ_HI\t\t\t0x020C\n#define PTP_CLOCK_RATE_ADJ_LO\t\t\t0x020D\n#define PTP_CLOCK_RATE_ADJ_DIR_\t\t\tBIT(15)\n\n#define PTP_LTC_STEP_ADJ_HI\t\t\t0x0212\n#define PTP_LTC_STEP_ADJ_LO\t\t\t0x0213\n#define PTP_LTC_STEP_ADJ_DIR_\t\t\tBIT(15)\n\n#define LAN8814_INTR_STS_REG\t\t\t0x0033\n#define LAN8814_INTR_STS_REG_1588_TSU0_\t\tBIT(0)\n#define LAN8814_INTR_STS_REG_1588_TSU1_\t\tBIT(1)\n#define LAN8814_INTR_STS_REG_1588_TSU2_\t\tBIT(2)\n#define LAN8814_INTR_STS_REG_1588_TSU3_\t\tBIT(3)\n\n#define PTP_CAP_INFO\t\t\t\t0x022A\n#define PTP_CAP_INFO_TX_TS_CNT_GET_(reg_val)\t(((reg_val) & 0x0f00) >> 8)\n#define PTP_CAP_INFO_RX_TS_CNT_GET_(reg_val)\t((reg_val) & 0x000f)\n\n#define PTP_TX_EGRESS_SEC_HI\t\t\t0x0296\n#define PTP_TX_EGRESS_SEC_LO\t\t\t0x0297\n#define PTP_TX_EGRESS_NS_HI\t\t\t0x0294\n#define PTP_TX_EGRESS_NS_LO\t\t\t0x0295\n#define PTP_TX_MSG_HEADER2\t\t\t0x0299\n\n#define PTP_RX_INGRESS_SEC_HI\t\t\t0x0256\n#define PTP_RX_INGRESS_SEC_LO\t\t\t0x0257\n#define PTP_RX_INGRESS_NS_HI\t\t\t0x0254\n#define PTP_RX_INGRESS_NS_LO\t\t\t0x0255\n#define PTP_RX_MSG_HEADER2\t\t\t0x0259\n\n#define PTP_TSU_INT_EN\t\t\t\t0x0200\n#define PTP_TSU_INT_EN_PTP_TX_TS_OVRFL_EN_\tBIT(3)\n#define PTP_TSU_INT_EN_PTP_TX_TS_EN_\t\tBIT(2)\n#define PTP_TSU_INT_EN_PTP_RX_TS_OVRFL_EN_\tBIT(1)\n#define PTP_TSU_INT_EN_PTP_RX_TS_EN_\t\tBIT(0)\n\n#define PTP_TSU_INT_STS\t\t\t\t0x0201\n#define PTP_TSU_INT_STS_PTP_TX_TS_OVRFL_INT_\tBIT(3)\n#define PTP_TSU_INT_STS_PTP_TX_TS_EN_\t\tBIT(2)\n#define PTP_TSU_INT_STS_PTP_RX_TS_OVRFL_INT_\tBIT(1)\n#define PTP_TSU_INT_STS_PTP_RX_TS_EN_\t\tBIT(0)\n\n#define LAN8814_LED_CTRL_1\t\t\t0x0\n#define LAN8814_LED_CTRL_1_KSZ9031_LED_MODE_\tBIT(6)\n\n \n#define MII_KSZPHY_CTRL_1\t\t\t0x1e\n#define KSZ8081_CTRL1_MDIX_STAT\t\t\tBIT(4)\n\n \n#define MII_KSZPHY_CTRL_2\t\t\t0x1f\n#define MII_KSZPHY_CTRL\t\t\t\tMII_KSZPHY_CTRL_2\n \n#define KSZ8081_CTRL2_HP_MDIX\t\t\tBIT(15)\n#define KSZ8081_CTRL2_MDI_MDI_X_SELECT\t\tBIT(14)\n#define KSZ8081_CTRL2_DISABLE_AUTO_MDIX\t\tBIT(13)\n#define KSZ8081_CTRL2_FORCE_LINK\t\tBIT(11)\n#define KSZ8081_CTRL2_POWER_SAVING\t\tBIT(10)\n#define KSZPHY_CTRL_INT_ACTIVE_HIGH\t\tBIT(9)\n#define KSZPHY_RMII_REF_CLK_SEL\t\t\tBIT(7)\n\n \n#define MII_KSZPHY_EXTREG\t\t\t0x0b\n#define KSZPHY_EXTREG_WRITE\t\t\t0x8000\n\n#define MII_KSZPHY_EXTREG_WRITE\t\t\t0x0c\n#define MII_KSZPHY_EXTREG_READ\t\t\t0x0d\n\n \n#define MII_KSZPHY_CLK_CONTROL_PAD_SKEW\t\t0x104\n#define MII_KSZPHY_RX_DATA_PAD_SKEW\t\t0x105\n#define MII_KSZPHY_TX_DATA_PAD_SKEW\t\t0x106\n\n#define PS_TO_REG\t\t\t\t200\n#define FIFO_SIZE\t\t\t\t8\n\n \n#define LAN8841_GET_SEC_LTC_DELAY\t\t(500 * NSEC_PER_MSEC)\n\nstruct kszphy_hw_stat {\n\tconst char *string;\n\tu8 reg;\n\tu8 bits;\n};\n\nstatic struct kszphy_hw_stat kszphy_hw_stats[] = {\n\t{ \"phy_receive_errors\", 21, 16},\n\t{ \"phy_idle_errors\", 10, 8 },\n};\n\nstruct kszphy_type {\n\tu32 led_mode_reg;\n\tu16 interrupt_level_mask;\n\tu16 cable_diag_reg;\n\tunsigned long pair_mask;\n\tu16 disable_dll_tx_bit;\n\tu16 disable_dll_rx_bit;\n\tu16 disable_dll_mask;\n\tbool has_broadcast_disable;\n\tbool has_nand_tree_disable;\n\tbool has_rmii_ref_clk_sel;\n};\n\n \nstruct lan8814_shared_priv {\n\tstruct phy_device *phydev;\n\tstruct ptp_clock *ptp_clock;\n\tstruct ptp_clock_info ptp_clock_info;\n\n\t \n\tu8 ref;\n\n\t \n\tstruct mutex shared_lock;\n};\n\nstruct lan8814_ptp_rx_ts {\n\tstruct list_head list;\n\tu32 seconds;\n\tu32 nsec;\n\tu16 seq_id;\n};\n\nstruct kszphy_ptp_priv {\n\tstruct mii_timestamper mii_ts;\n\tstruct phy_device *phydev;\n\n\tstruct sk_buff_head tx_queue;\n\tstruct sk_buff_head rx_queue;\n\n\tstruct list_head rx_ts_list;\n\t \n\tspinlock_t rx_ts_lock;\n\n\tint hwts_tx_type;\n\tenum hwtstamp_rx_filters rx_filter;\n\tint layer;\n\tint version;\n\n\tstruct ptp_clock *ptp_clock;\n\tstruct ptp_clock_info ptp_clock_info;\n\t \n\tstruct mutex ptp_lock;\n\tstruct ptp_pin_desc *pin_config;\n\n\ts64 seconds;\n\t \n\tspinlock_t seconds_lock;\n};\n\nstruct kszphy_priv {\n\tstruct kszphy_ptp_priv ptp_priv;\n\tconst struct kszphy_type *type;\n\tint led_mode;\n\tu16 vct_ctrl1000;\n\tbool rmii_ref_clk_sel;\n\tbool rmii_ref_clk_sel_val;\n\tu64 stats[ARRAY_SIZE(kszphy_hw_stats)];\n};\n\nstatic const struct kszphy_type lan8814_type = {\n\t.led_mode_reg\t\t= ~LAN8814_LED_CTRL_1,\n\t.cable_diag_reg\t\t= LAN8814_CABLE_DIAG,\n\t.pair_mask\t\t= LAN8814_WIRE_PAIR_MASK,\n};\n\nstatic const struct kszphy_type ksz886x_type = {\n\t.cable_diag_reg\t\t= KSZ8081_LMD,\n\t.pair_mask\t\t= KSZPHY_WIRE_PAIR_MASK,\n};\n\nstatic const struct kszphy_type ksz8021_type = {\n\t.led_mode_reg\t\t= MII_KSZPHY_CTRL_2,\n\t.has_broadcast_disable\t= true,\n\t.has_nand_tree_disable\t= true,\n\t.has_rmii_ref_clk_sel\t= true,\n};\n\nstatic const struct kszphy_type ksz8041_type = {\n\t.led_mode_reg\t\t= MII_KSZPHY_CTRL_1,\n};\n\nstatic const struct kszphy_type ksz8051_type = {\n\t.led_mode_reg\t\t= MII_KSZPHY_CTRL_2,\n\t.has_nand_tree_disable\t= true,\n};\n\nstatic const struct kszphy_type ksz8081_type = {\n\t.led_mode_reg\t\t= MII_KSZPHY_CTRL_2,\n\t.has_broadcast_disable\t= true,\n\t.has_nand_tree_disable\t= true,\n\t.has_rmii_ref_clk_sel\t= true,\n};\n\nstatic const struct kszphy_type ks8737_type = {\n\t.interrupt_level_mask\t= BIT(14),\n};\n\nstatic const struct kszphy_type ksz9021_type = {\n\t.interrupt_level_mask\t= BIT(14),\n};\n\nstatic const struct kszphy_type ksz9131_type = {\n\t.interrupt_level_mask\t= BIT(14),\n\t.disable_dll_tx_bit\t= BIT(12),\n\t.disable_dll_rx_bit\t= BIT(12),\n\t.disable_dll_mask\t= BIT_MASK(12),\n};\n\nstatic const struct kszphy_type lan8841_type = {\n\t.disable_dll_tx_bit\t= BIT(14),\n\t.disable_dll_rx_bit\t= BIT(14),\n\t.disable_dll_mask\t= BIT_MASK(14),\n\t.cable_diag_reg\t\t= LAN8814_CABLE_DIAG,\n\t.pair_mask\t\t= LAN8814_WIRE_PAIR_MASK,\n};\n\nstatic int kszphy_extended_write(struct phy_device *phydev,\n\t\t\t\tu32 regnum, u16 val)\n{\n\tphy_write(phydev, MII_KSZPHY_EXTREG, KSZPHY_EXTREG_WRITE | regnum);\n\treturn phy_write(phydev, MII_KSZPHY_EXTREG_WRITE, val);\n}\n\nstatic int kszphy_extended_read(struct phy_device *phydev,\n\t\t\t\tu32 regnum)\n{\n\tphy_write(phydev, MII_KSZPHY_EXTREG, regnum);\n\treturn phy_read(phydev, MII_KSZPHY_EXTREG_READ);\n}\n\nstatic int kszphy_ack_interrupt(struct phy_device *phydev)\n{\n\t \n\tint rc;\n\n\trc = phy_read(phydev, MII_KSZPHY_INTCS);\n\n\treturn (rc < 0) ? rc : 0;\n}\n\nstatic int kszphy_config_intr(struct phy_device *phydev)\n{\n\tconst struct kszphy_type *type = phydev->drv->driver_data;\n\tint temp, err;\n\tu16 mask;\n\n\tif (type && type->interrupt_level_mask)\n\t\tmask = type->interrupt_level_mask;\n\telse\n\t\tmask = KSZPHY_CTRL_INT_ACTIVE_HIGH;\n\n\t \n\ttemp = phy_read(phydev, MII_KSZPHY_CTRL);\n\tif (temp < 0)\n\t\treturn temp;\n\ttemp &= ~mask;\n\tphy_write(phydev, MII_KSZPHY_CTRL, temp);\n\n\t \n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\terr = kszphy_ack_interrupt(phydev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = phy_write(phydev, MII_KSZPHY_INTCS, KSZPHY_INTCS_ALL);\n\t} else {\n\t\terr = phy_write(phydev, MII_KSZPHY_INTCS, 0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = kszphy_ack_interrupt(phydev);\n\t}\n\n\treturn err;\n}\n\nstatic irqreturn_t kszphy_handle_interrupt(struct phy_device *phydev)\n{\n\tint irq_status;\n\n\tirq_status = phy_read(phydev, MII_KSZPHY_INTCS);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (!(irq_status & KSZPHY_INTCS_STATUS))\n\t\treturn IRQ_NONE;\n\n\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int kszphy_rmii_clk_sel(struct phy_device *phydev, bool val)\n{\n\tint ctrl;\n\n\tctrl = phy_read(phydev, MII_KSZPHY_CTRL);\n\tif (ctrl < 0)\n\t\treturn ctrl;\n\n\tif (val)\n\t\tctrl |= KSZPHY_RMII_REF_CLK_SEL;\n\telse\n\t\tctrl &= ~KSZPHY_RMII_REF_CLK_SEL;\n\n\treturn phy_write(phydev, MII_KSZPHY_CTRL, ctrl);\n}\n\nstatic int kszphy_setup_led(struct phy_device *phydev, u32 reg, int val)\n{\n\tint rc, temp, shift;\n\n\tswitch (reg) {\n\tcase MII_KSZPHY_CTRL_1:\n\t\tshift = 14;\n\t\tbreak;\n\tcase MII_KSZPHY_CTRL_2:\n\t\tshift = 4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ttemp = phy_read(phydev, reg);\n\tif (temp < 0) {\n\t\trc = temp;\n\t\tgoto out;\n\t}\n\n\ttemp &= ~(3 << shift);\n\ttemp |= val << shift;\n\trc = phy_write(phydev, reg, temp);\nout:\n\tif (rc < 0)\n\t\tphydev_err(phydev, \"failed to set led mode\\n\");\n\n\treturn rc;\n}\n\n \nstatic int kszphy_broadcast_disable(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = phy_read(phydev, MII_KSZPHY_OMSO);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = phy_write(phydev, MII_KSZPHY_OMSO, ret | KSZPHY_OMSO_B_CAST_OFF);\nout:\n\tif (ret)\n\t\tphydev_err(phydev, \"failed to disable broadcast address\\n\");\n\n\treturn ret;\n}\n\nstatic int kszphy_nand_tree_disable(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = phy_read(phydev, MII_KSZPHY_OMSO);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (!(ret & KSZPHY_OMSO_NAND_TREE_ON))\n\t\treturn 0;\n\n\tret = phy_write(phydev, MII_KSZPHY_OMSO,\n\t\t\tret & ~KSZPHY_OMSO_NAND_TREE_ON);\nout:\n\tif (ret)\n\t\tphydev_err(phydev, \"failed to disable NAND tree mode\\n\");\n\n\treturn ret;\n}\n\n \nstatic int kszphy_config_reset(struct phy_device *phydev)\n{\n\tstruct kszphy_priv *priv = phydev->priv;\n\tint ret;\n\n\tif (priv->rmii_ref_clk_sel) {\n\t\tret = kszphy_rmii_clk_sel(phydev, priv->rmii_ref_clk_sel_val);\n\t\tif (ret) {\n\t\t\tphydev_err(phydev,\n\t\t\t\t   \"failed to set rmii reference clock\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (priv->type && priv->led_mode >= 0)\n\t\tkszphy_setup_led(phydev, priv->type->led_mode_reg, priv->led_mode);\n\n\treturn 0;\n}\n\nstatic int kszphy_config_init(struct phy_device *phydev)\n{\n\tstruct kszphy_priv *priv = phydev->priv;\n\tconst struct kszphy_type *type;\n\n\tif (!priv)\n\t\treturn 0;\n\n\ttype = priv->type;\n\n\tif (type && type->has_broadcast_disable)\n\t\tkszphy_broadcast_disable(phydev);\n\n\tif (type && type->has_nand_tree_disable)\n\t\tkszphy_nand_tree_disable(phydev);\n\n\treturn kszphy_config_reset(phydev);\n}\n\nstatic int ksz8041_fiber_mode(struct phy_device *phydev)\n{\n\tstruct device_node *of_node = phydev->mdio.dev.of_node;\n\n\treturn of_property_read_bool(of_node, \"micrel,fiber-mode\");\n}\n\nstatic int ksz8041_config_init(struct phy_device *phydev)\n{\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };\n\n\t \n\tif (ksz8041_fiber_mode(phydev)) {\n\t\tphydev->dev_flags |= MICREL_PHY_FXEN;\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Full_BIT, mask);\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_100baseT_Half_BIT, mask);\n\n\t\tlinkmode_and(phydev->supported, phydev->supported, mask);\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FIBRE_BIT,\n\t\t\t\t phydev->supported);\n\t\tlinkmode_and(phydev->advertising, phydev->advertising, mask);\n\t\tlinkmode_set_bit(ETHTOOL_LINK_MODE_FIBRE_BIT,\n\t\t\t\t phydev->advertising);\n\t\tphydev->autoneg = AUTONEG_DISABLE;\n\t}\n\n\treturn kszphy_config_init(phydev);\n}\n\nstatic int ksz8041_config_aneg(struct phy_device *phydev)\n{\n\t \n\tif (phydev->dev_flags & MICREL_PHY_FXEN) {\n\t\tphydev->speed = SPEED_100;\n\t\treturn 0;\n\t}\n\n\treturn genphy_config_aneg(phydev);\n}\n\nstatic int ksz8051_ksz8795_match_phy_device(struct phy_device *phydev,\n\t\t\t\t\t    const bool ksz_8051)\n{\n\tint ret;\n\n\tif (!phy_id_compare(phydev->phy_id, PHY_ID_KSZ8051, MICREL_PHY_ID_MASK))\n\t\treturn 0;\n\n\tret = phy_read(phydev, MII_BMSR);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret &= BMSR_ERCAP;\n\tif (ksz_8051)\n\t\treturn ret;\n\telse\n\t\treturn !ret;\n}\n\nstatic int ksz8051_match_phy_device(struct phy_device *phydev)\n{\n\treturn ksz8051_ksz8795_match_phy_device(phydev, true);\n}\n\nstatic int ksz8081_config_init(struct phy_device *phydev)\n{\n\t \n\tphy_clear_bits(phydev, MII_KSZPHY_OMSO, KSZPHY_OMSO_FACTORY_TEST);\n\n\treturn kszphy_config_init(phydev);\n}\n\nstatic int ksz8081_config_mdix(struct phy_device *phydev, u8 ctrl)\n{\n\tu16 val;\n\n\tswitch (ctrl) {\n\tcase ETH_TP_MDI:\n\t\tval = KSZ8081_CTRL2_DISABLE_AUTO_MDIX;\n\t\tbreak;\n\tcase ETH_TP_MDI_X:\n\t\tval = KSZ8081_CTRL2_DISABLE_AUTO_MDIX |\n\t\t\tKSZ8081_CTRL2_MDI_MDI_X_SELECT;\n\t\tbreak;\n\tcase ETH_TP_MDI_AUTO:\n\t\tval = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn phy_modify(phydev, MII_KSZPHY_CTRL_2,\n\t\t\t  KSZ8081_CTRL2_HP_MDIX |\n\t\t\t  KSZ8081_CTRL2_MDI_MDI_X_SELECT |\n\t\t\t  KSZ8081_CTRL2_DISABLE_AUTO_MDIX,\n\t\t\t  KSZ8081_CTRL2_HP_MDIX | val);\n}\n\nstatic int ksz8081_config_aneg(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = genphy_config_aneg(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn ksz8081_config_mdix(phydev, phydev->mdix_ctrl);\n}\n\nstatic int ksz8081_mdix_update(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = phy_read(phydev, MII_KSZPHY_CTRL_2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & KSZ8081_CTRL2_DISABLE_AUTO_MDIX) {\n\t\tif (ret & KSZ8081_CTRL2_MDI_MDI_X_SELECT)\n\t\t\tphydev->mdix_ctrl = ETH_TP_MDI_X;\n\t\telse\n\t\t\tphydev->mdix_ctrl = ETH_TP_MDI;\n\t} else {\n\t\tphydev->mdix_ctrl = ETH_TP_MDI_AUTO;\n\t}\n\n\tret = phy_read(phydev, MII_KSZPHY_CTRL_1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & KSZ8081_CTRL1_MDIX_STAT)\n\t\tphydev->mdix = ETH_TP_MDI;\n\telse\n\t\tphydev->mdix = ETH_TP_MDI_X;\n\n\treturn 0;\n}\n\nstatic int ksz8081_read_status(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = ksz8081_mdix_update(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn genphy_read_status(phydev);\n}\n\nstatic int ksz8061_config_init(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = phy_write_mmd(phydev, MDIO_MMD_PMAPMD, MDIO_DEVID1, 0xB61A);\n\tif (ret)\n\t\treturn ret;\n\n\treturn kszphy_config_init(phydev);\n}\n\nstatic int ksz8795_match_phy_device(struct phy_device *phydev)\n{\n\treturn ksz8051_ksz8795_match_phy_device(phydev, false);\n}\n\nstatic int ksz9021_load_values_from_of(struct phy_device *phydev,\n\t\t\t\t       const struct device_node *of_node,\n\t\t\t\t       u16 reg,\n\t\t\t\t       const char *field1, const char *field2,\n\t\t\t\t       const char *field3, const char *field4)\n{\n\tint val1 = -1;\n\tint val2 = -2;\n\tint val3 = -3;\n\tint val4 = -4;\n\tint newval;\n\tint matches = 0;\n\n\tif (!of_property_read_u32(of_node, field1, &val1))\n\t\tmatches++;\n\n\tif (!of_property_read_u32(of_node, field2, &val2))\n\t\tmatches++;\n\n\tif (!of_property_read_u32(of_node, field3, &val3))\n\t\tmatches++;\n\n\tif (!of_property_read_u32(of_node, field4, &val4))\n\t\tmatches++;\n\n\tif (!matches)\n\t\treturn 0;\n\n\tif (matches < 4)\n\t\tnewval = kszphy_extended_read(phydev, reg);\n\telse\n\t\tnewval = 0;\n\n\tif (val1 != -1)\n\t\tnewval = ((newval & 0xfff0) | ((val1 / PS_TO_REG) & 0xf) << 0);\n\n\tif (val2 != -2)\n\t\tnewval = ((newval & 0xff0f) | ((val2 / PS_TO_REG) & 0xf) << 4);\n\n\tif (val3 != -3)\n\t\tnewval = ((newval & 0xf0ff) | ((val3 / PS_TO_REG) & 0xf) << 8);\n\n\tif (val4 != -4)\n\t\tnewval = ((newval & 0x0fff) | ((val4 / PS_TO_REG) & 0xf) << 12);\n\n\treturn kszphy_extended_write(phydev, reg, newval);\n}\n\nstatic int ksz9021_config_init(struct phy_device *phydev)\n{\n\tconst struct device_node *of_node;\n\tconst struct device *dev_walker;\n\n\t \n\tdev_walker = &phydev->mdio.dev;\n\tdo {\n\t\tof_node = dev_walker->of_node;\n\t\tdev_walker = dev_walker->parent;\n\n\t} while (!of_node && dev_walker);\n\n\tif (of_node) {\n\t\tksz9021_load_values_from_of(phydev, of_node,\n\t\t\t\t    MII_KSZPHY_CLK_CONTROL_PAD_SKEW,\n\t\t\t\t    \"txen-skew-ps\", \"txc-skew-ps\",\n\t\t\t\t    \"rxdv-skew-ps\", \"rxc-skew-ps\");\n\t\tksz9021_load_values_from_of(phydev, of_node,\n\t\t\t\t    MII_KSZPHY_RX_DATA_PAD_SKEW,\n\t\t\t\t    \"rxd0-skew-ps\", \"rxd1-skew-ps\",\n\t\t\t\t    \"rxd2-skew-ps\", \"rxd3-skew-ps\");\n\t\tksz9021_load_values_from_of(phydev, of_node,\n\t\t\t\t    MII_KSZPHY_TX_DATA_PAD_SKEW,\n\t\t\t\t    \"txd0-skew-ps\", \"txd1-skew-ps\",\n\t\t\t\t    \"txd2-skew-ps\", \"txd3-skew-ps\");\n\t}\n\treturn 0;\n}\n\n#define KSZ9031_PS_TO_REG\t\t60\n\n \n \n#define MII_KSZ9031RN_FLP_BURST_TX_LO\t3\n#define MII_KSZ9031RN_FLP_BURST_TX_HI\t4\n\n \n#define MII_KSZ9031RN_CONTROL_PAD_SKEW\t4\n#define MII_KSZ9031RN_RX_CTL_M\t\tGENMASK(7, 4)\n#define MII_KSZ9031RN_TX_CTL_M\t\tGENMASK(3, 0)\n\n#define MII_KSZ9031RN_RX_DATA_PAD_SKEW\t5\n#define MII_KSZ9031RN_RXD3\t\tGENMASK(15, 12)\n#define MII_KSZ9031RN_RXD2\t\tGENMASK(11, 8)\n#define MII_KSZ9031RN_RXD1\t\tGENMASK(7, 4)\n#define MII_KSZ9031RN_RXD0\t\tGENMASK(3, 0)\n\n#define MII_KSZ9031RN_TX_DATA_PAD_SKEW\t6\n#define MII_KSZ9031RN_TXD3\t\tGENMASK(15, 12)\n#define MII_KSZ9031RN_TXD2\t\tGENMASK(11, 8)\n#define MII_KSZ9031RN_TXD1\t\tGENMASK(7, 4)\n#define MII_KSZ9031RN_TXD0\t\tGENMASK(3, 0)\n\n#define MII_KSZ9031RN_CLK_PAD_SKEW\t8\n#define MII_KSZ9031RN_GTX_CLK\t\tGENMASK(9, 5)\n#define MII_KSZ9031RN_RX_CLK\t\tGENMASK(4, 0)\n\n \n \n#define RX_ID\t\t\t\t0x7\n#define RX_CLK_ID\t\t\t0x19\n\n \n#define RX_ND\t\t\t\t0xc\n#define RX_CLK_ND\t\t\t0x0\n\n \n#define TX_ID\t\t\t\t0x0\n#define TX_CLK_ID\t\t\t0x1f\n\n \n#define TX_ND\t\t\t\t0x7\n#define TX_CLK_ND\t\t\t0xf\n\n \n#define MII_KSZ9031RN_EDPD\t\t0x23\n#define MII_KSZ9031RN_EDPD_ENABLE\tBIT(0)\n\nstatic int ksz9031_of_load_skew_values(struct phy_device *phydev,\n\t\t\t\t       const struct device_node *of_node,\n\t\t\t\t       u16 reg, size_t field_sz,\n\t\t\t\t       const char *field[], u8 numfields,\n\t\t\t\t       bool *update)\n{\n\tint val[4] = {-1, -2, -3, -4};\n\tint matches = 0;\n\tu16 mask;\n\tu16 maxval;\n\tu16 newval;\n\tint i;\n\n\tfor (i = 0; i < numfields; i++)\n\t\tif (!of_property_read_u32(of_node, field[i], val + i))\n\t\t\tmatches++;\n\n\tif (!matches)\n\t\treturn 0;\n\n\t*update |= true;\n\n\tif (matches < numfields)\n\t\tnewval = phy_read_mmd(phydev, 2, reg);\n\telse\n\t\tnewval = 0;\n\n\tmaxval = (field_sz == 4) ? 0xf : 0x1f;\n\tfor (i = 0; i < numfields; i++)\n\t\tif (val[i] != -(i + 1)) {\n\t\t\tmask = 0xffff;\n\t\t\tmask ^= maxval << (field_sz * i);\n\t\t\tnewval = (newval & mask) |\n\t\t\t\t(((val[i] / KSZ9031_PS_TO_REG) & maxval)\n\t\t\t\t\t<< (field_sz * i));\n\t\t}\n\n\treturn phy_write_mmd(phydev, 2, reg, newval);\n}\n\n \nstatic int ksz9031_center_flp_timing(struct phy_device *phydev)\n{\n\tint result;\n\n\tresult = phy_write_mmd(phydev, 0, MII_KSZ9031RN_FLP_BURST_TX_HI,\n\t\t\t       0x0006);\n\tif (result)\n\t\treturn result;\n\n\tresult = phy_write_mmd(phydev, 0, MII_KSZ9031RN_FLP_BURST_TX_LO,\n\t\t\t       0x1A80);\n\tif (result)\n\t\treturn result;\n\n\treturn genphy_restart_aneg(phydev);\n}\n\n \nstatic int ksz9031_enable_edpd(struct phy_device *phydev)\n{\n\tint reg;\n\n\treg = phy_read_mmd(phydev, 0x1C, MII_KSZ9031RN_EDPD);\n\tif (reg < 0)\n\t\treturn reg;\n\treturn phy_write_mmd(phydev, 0x1C, MII_KSZ9031RN_EDPD,\n\t\t\t     reg | MII_KSZ9031RN_EDPD_ENABLE);\n}\n\nstatic int ksz9031_config_rgmii_delay(struct phy_device *phydev)\n{\n\tu16 rx, tx, rx_clk, tx_clk;\n\tint ret;\n\n\tswitch (phydev->interface) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\t\ttx = TX_ND;\n\t\ttx_clk = TX_CLK_ND;\n\t\trx = RX_ND;\n\t\trx_clk = RX_CLK_ND;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\t\ttx = TX_ID;\n\t\ttx_clk = TX_CLK_ID;\n\t\trx = RX_ID;\n\t\trx_clk = RX_CLK_ID;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\ttx = TX_ND;\n\t\ttx_clk = TX_CLK_ND;\n\t\trx = RX_ID;\n\t\trx_clk = RX_CLK_ID;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\ttx = TX_ID;\n\t\ttx_clk = TX_CLK_ID;\n\t\trx = RX_ND;\n\t\trx_clk = RX_CLK_ND;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tret = phy_write_mmd(phydev, 2, MII_KSZ9031RN_CONTROL_PAD_SKEW,\n\t\t\t    FIELD_PREP(MII_KSZ9031RN_RX_CTL_M, rx) |\n\t\t\t    FIELD_PREP(MII_KSZ9031RN_TX_CTL_M, tx));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = phy_write_mmd(phydev, 2, MII_KSZ9031RN_RX_DATA_PAD_SKEW,\n\t\t\t    FIELD_PREP(MII_KSZ9031RN_RXD3, rx) |\n\t\t\t    FIELD_PREP(MII_KSZ9031RN_RXD2, rx) |\n\t\t\t    FIELD_PREP(MII_KSZ9031RN_RXD1, rx) |\n\t\t\t    FIELD_PREP(MII_KSZ9031RN_RXD0, rx));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = phy_write_mmd(phydev, 2, MII_KSZ9031RN_TX_DATA_PAD_SKEW,\n\t\t\t    FIELD_PREP(MII_KSZ9031RN_TXD3, tx) |\n\t\t\t    FIELD_PREP(MII_KSZ9031RN_TXD2, tx) |\n\t\t\t    FIELD_PREP(MII_KSZ9031RN_TXD1, tx) |\n\t\t\t    FIELD_PREP(MII_KSZ9031RN_TXD0, tx));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn phy_write_mmd(phydev, 2, MII_KSZ9031RN_CLK_PAD_SKEW,\n\t\t\t     FIELD_PREP(MII_KSZ9031RN_GTX_CLK, tx_clk) |\n\t\t\t     FIELD_PREP(MII_KSZ9031RN_RX_CLK, rx_clk));\n}\n\nstatic int ksz9031_config_init(struct phy_device *phydev)\n{\n\tconst struct device_node *of_node;\n\tstatic const char *clk_skews[2] = {\"rxc-skew-ps\", \"txc-skew-ps\"};\n\tstatic const char *rx_data_skews[4] = {\n\t\t\"rxd0-skew-ps\", \"rxd1-skew-ps\",\n\t\t\"rxd2-skew-ps\", \"rxd3-skew-ps\"\n\t};\n\tstatic const char *tx_data_skews[4] = {\n\t\t\"txd0-skew-ps\", \"txd1-skew-ps\",\n\t\t\"txd2-skew-ps\", \"txd3-skew-ps\"\n\t};\n\tstatic const char *control_skews[2] = {\"txen-skew-ps\", \"rxdv-skew-ps\"};\n\tconst struct device *dev_walker;\n\tint result;\n\n\tresult = ksz9031_enable_edpd(phydev);\n\tif (result < 0)\n\t\treturn result;\n\n\t \n\tdev_walker = &phydev->mdio.dev;\n\tdo {\n\t\tof_node = dev_walker->of_node;\n\t\tdev_walker = dev_walker->parent;\n\t} while (!of_node && dev_walker);\n\n\tif (of_node) {\n\t\tbool update = false;\n\n\t\tif (phy_interface_is_rgmii(phydev)) {\n\t\t\tresult = ksz9031_config_rgmii_delay(phydev);\n\t\t\tif (result < 0)\n\t\t\t\treturn result;\n\t\t}\n\n\t\tksz9031_of_load_skew_values(phydev, of_node,\n\t\t\t\tMII_KSZ9031RN_CLK_PAD_SKEW, 5,\n\t\t\t\tclk_skews, 2, &update);\n\n\t\tksz9031_of_load_skew_values(phydev, of_node,\n\t\t\t\tMII_KSZ9031RN_CONTROL_PAD_SKEW, 4,\n\t\t\t\tcontrol_skews, 2, &update);\n\n\t\tksz9031_of_load_skew_values(phydev, of_node,\n\t\t\t\tMII_KSZ9031RN_RX_DATA_PAD_SKEW, 4,\n\t\t\t\trx_data_skews, 4, &update);\n\n\t\tksz9031_of_load_skew_values(phydev, of_node,\n\t\t\t\tMII_KSZ9031RN_TX_DATA_PAD_SKEW, 4,\n\t\t\t\ttx_data_skews, 4, &update);\n\n\t\tif (update && !phy_interface_is_rgmii(phydev))\n\t\t\tphydev_warn(phydev,\n\t\t\t\t    \"*-skew-ps values should be used only with RGMII PHY modes\\n\");\n\n\t\t \n\t\tif (of_property_read_bool(of_node, \"micrel,force-master\")) {\n\t\t\tresult = phy_read(phydev, MII_CTRL1000);\n\t\t\tif (result < 0)\n\t\t\t\tgoto err_force_master;\n\n\t\t\t \n\t\t\tresult |= CTL1000_ENABLE_MASTER | CTL1000_AS_MASTER;\n\t\t\tresult = phy_write(phydev, MII_CTRL1000, result);\n\t\t\tif (result < 0)\n\t\t\t\tgoto err_force_master;\n\t\t}\n\t}\n\n\treturn ksz9031_center_flp_timing(phydev);\n\nerr_force_master:\n\tphydev_err(phydev, \"failed to force the phy to master mode\\n\");\n\treturn result;\n}\n\n#define KSZ9131_SKEW_5BIT_MAX\t2400\n#define KSZ9131_SKEW_4BIT_MAX\t800\n#define KSZ9131_OFFSET\t\t700\n#define KSZ9131_STEP\t\t100\n\nstatic int ksz9131_of_load_skew_values(struct phy_device *phydev,\n\t\t\t\t       struct device_node *of_node,\n\t\t\t\t       u16 reg, size_t field_sz,\n\t\t\t\t       char *field[], u8 numfields)\n{\n\tint val[4] = {-(1 + KSZ9131_OFFSET), -(2 + KSZ9131_OFFSET),\n\t\t      -(3 + KSZ9131_OFFSET), -(4 + KSZ9131_OFFSET)};\n\tint skewval, skewmax = 0;\n\tint matches = 0;\n\tu16 maxval;\n\tu16 newval;\n\tu16 mask;\n\tint i;\n\n\t \n\tif (field_sz == 5)\n\t\tskewmax = KSZ9131_SKEW_5BIT_MAX;\n\telse\n\t\tskewmax = KSZ9131_SKEW_4BIT_MAX;\n\n\tfor (i = 0; i < numfields; i++)\n\t\tif (!of_property_read_s32(of_node, field[i], &skewval)) {\n\t\t\tif (skewval < -KSZ9131_OFFSET)\n\t\t\t\tskewval = -KSZ9131_OFFSET;\n\t\t\telse if (skewval > skewmax)\n\t\t\t\tskewval = skewmax;\n\n\t\t\tval[i] = skewval + KSZ9131_OFFSET;\n\t\t\tmatches++;\n\t\t}\n\n\tif (!matches)\n\t\treturn 0;\n\n\tif (matches < numfields)\n\t\tnewval = phy_read_mmd(phydev, 2, reg);\n\telse\n\t\tnewval = 0;\n\n\tmaxval = (field_sz == 4) ? 0xf : 0x1f;\n\tfor (i = 0; i < numfields; i++)\n\t\tif (val[i] != -(i + 1 + KSZ9131_OFFSET)) {\n\t\t\tmask = 0xffff;\n\t\t\tmask ^= maxval << (field_sz * i);\n\t\t\tnewval = (newval & mask) |\n\t\t\t\t(((val[i] / KSZ9131_STEP) & maxval)\n\t\t\t\t\t<< (field_sz * i));\n\t\t}\n\n\treturn phy_write_mmd(phydev, 2, reg, newval);\n}\n\n#define KSZ9131RN_MMD_COMMON_CTRL_REG\t2\n#define KSZ9131RN_RXC_DLL_CTRL\t\t76\n#define KSZ9131RN_TXC_DLL_CTRL\t\t77\n#define KSZ9131RN_DLL_ENABLE_DELAY\t0\n\nstatic int ksz9131_config_rgmii_delay(struct phy_device *phydev)\n{\n\tconst struct kszphy_type *type = phydev->drv->driver_data;\n\tu16 rxcdll_val, txcdll_val;\n\tint ret;\n\n\tswitch (phydev->interface) {\n\tcase PHY_INTERFACE_MODE_RGMII:\n\t\trxcdll_val = type->disable_dll_rx_bit;\n\t\ttxcdll_val = type->disable_dll_tx_bit;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_ID:\n\t\trxcdll_val = KSZ9131RN_DLL_ENABLE_DELAY;\n\t\ttxcdll_val = KSZ9131RN_DLL_ENABLE_DELAY;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_RXID:\n\t\trxcdll_val = KSZ9131RN_DLL_ENABLE_DELAY;\n\t\ttxcdll_val = type->disable_dll_tx_bit;\n\t\tbreak;\n\tcase PHY_INTERFACE_MODE_RGMII_TXID:\n\t\trxcdll_val = type->disable_dll_rx_bit;\n\t\ttxcdll_val = KSZ9131RN_DLL_ENABLE_DELAY;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tret = phy_modify_mmd(phydev, KSZ9131RN_MMD_COMMON_CTRL_REG,\n\t\t\t     KSZ9131RN_RXC_DLL_CTRL, type->disable_dll_mask,\n\t\t\t     rxcdll_val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn phy_modify_mmd(phydev, KSZ9131RN_MMD_COMMON_CTRL_REG,\n\t\t\t      KSZ9131RN_TXC_DLL_CTRL, type->disable_dll_mask,\n\t\t\t      txcdll_val);\n}\n\n \nstatic int ksz9131_led_errata(struct phy_device *phydev)\n{\n\tint reg;\n\n\treg = phy_read_mmd(phydev, 2, 0);\n\tif (reg < 0)\n\t\treturn reg;\n\n\tif (!(reg & BIT(4)))\n\t\treturn 0;\n\n\treturn phy_set_bits(phydev, 0x1e, BIT(9));\n}\n\nstatic int ksz9131_config_init(struct phy_device *phydev)\n{\n\tstruct device_node *of_node;\n\tchar *clk_skews[2] = {\"rxc-skew-psec\", \"txc-skew-psec\"};\n\tchar *rx_data_skews[4] = {\n\t\t\"rxd0-skew-psec\", \"rxd1-skew-psec\",\n\t\t\"rxd2-skew-psec\", \"rxd3-skew-psec\"\n\t};\n\tchar *tx_data_skews[4] = {\n\t\t\"txd0-skew-psec\", \"txd1-skew-psec\",\n\t\t\"txd2-skew-psec\", \"txd3-skew-psec\"\n\t};\n\tchar *control_skews[2] = {\"txen-skew-psec\", \"rxdv-skew-psec\"};\n\tconst struct device *dev_walker;\n\tint ret;\n\n\tdev_walker = &phydev->mdio.dev;\n\tdo {\n\t\tof_node = dev_walker->of_node;\n\t\tdev_walker = dev_walker->parent;\n\t} while (!of_node && dev_walker);\n\n\tif (!of_node)\n\t\treturn 0;\n\n\tif (phy_interface_is_rgmii(phydev)) {\n\t\tret = ksz9131_config_rgmii_delay(phydev);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = ksz9131_of_load_skew_values(phydev, of_node,\n\t\t\t\t\t  MII_KSZ9031RN_CLK_PAD_SKEW, 5,\n\t\t\t\t\t  clk_skews, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ksz9131_of_load_skew_values(phydev, of_node,\n\t\t\t\t\t  MII_KSZ9031RN_CONTROL_PAD_SKEW, 4,\n\t\t\t\t\t  control_skews, 2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ksz9131_of_load_skew_values(phydev, of_node,\n\t\t\t\t\t  MII_KSZ9031RN_RX_DATA_PAD_SKEW, 4,\n\t\t\t\t\t  rx_data_skews, 4);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ksz9131_of_load_skew_values(phydev, of_node,\n\t\t\t\t\t  MII_KSZ9031RN_TX_DATA_PAD_SKEW, 4,\n\t\t\t\t\t  tx_data_skews, 4);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ksz9131_led_errata(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n#define MII_KSZ9131_AUTO_MDIX\t\t0x1C\n#define MII_KSZ9131_AUTO_MDI_SET\tBIT(7)\n#define MII_KSZ9131_AUTO_MDIX_SWAP_OFF\tBIT(6)\n\nstatic int ksz9131_mdix_update(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = phy_read(phydev, MII_KSZ9131_AUTO_MDIX);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & MII_KSZ9131_AUTO_MDIX_SWAP_OFF) {\n\t\tif (ret & MII_KSZ9131_AUTO_MDI_SET)\n\t\t\tphydev->mdix_ctrl = ETH_TP_MDI;\n\t\telse\n\t\t\tphydev->mdix_ctrl = ETH_TP_MDI_X;\n\t} else {\n\t\tphydev->mdix_ctrl = ETH_TP_MDI_AUTO;\n\t}\n\n\tif (ret & MII_KSZ9131_AUTO_MDI_SET)\n\t\tphydev->mdix = ETH_TP_MDI;\n\telse\n\t\tphydev->mdix = ETH_TP_MDI_X;\n\n\treturn 0;\n}\n\nstatic int ksz9131_config_mdix(struct phy_device *phydev, u8 ctrl)\n{\n\tu16 val;\n\n\tswitch (ctrl) {\n\tcase ETH_TP_MDI:\n\t\tval = MII_KSZ9131_AUTO_MDIX_SWAP_OFF |\n\t\t      MII_KSZ9131_AUTO_MDI_SET;\n\t\tbreak;\n\tcase ETH_TP_MDI_X:\n\t\tval = MII_KSZ9131_AUTO_MDIX_SWAP_OFF;\n\t\tbreak;\n\tcase ETH_TP_MDI_AUTO:\n\t\tval = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn phy_modify(phydev, MII_KSZ9131_AUTO_MDIX,\n\t\t\t  MII_KSZ9131_AUTO_MDIX_SWAP_OFF |\n\t\t\t  MII_KSZ9131_AUTO_MDI_SET, val);\n}\n\nstatic int ksz9131_read_status(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = ksz9131_mdix_update(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn genphy_read_status(phydev);\n}\n\nstatic int ksz9131_config_aneg(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = ksz9131_config_mdix(phydev, phydev->mdix_ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\treturn genphy_config_aneg(phydev);\n}\n\nstatic int ksz9477_get_features(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = genphy_read_abilities(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tlinkmode_and(phydev->supported_eee, phydev->supported,\n\t\t     PHY_EEE_CAP1_FEATURES);\n\n\treturn 0;\n}\n\n#define KSZ8873MLL_GLOBAL_CONTROL_4\t0x06\n#define KSZ8873MLL_GLOBAL_CONTROL_4_DUPLEX\tBIT(6)\n#define KSZ8873MLL_GLOBAL_CONTROL_4_SPEED\tBIT(4)\nstatic int ksz8873mll_read_status(struct phy_device *phydev)\n{\n\tint regval;\n\n\t \n\tregval = phy_read(phydev, KSZ8873MLL_GLOBAL_CONTROL_4);\n\n\tregval = phy_read(phydev, KSZ8873MLL_GLOBAL_CONTROL_4);\n\n\tif (regval & KSZ8873MLL_GLOBAL_CONTROL_4_DUPLEX)\n\t\tphydev->duplex = DUPLEX_HALF;\n\telse\n\t\tphydev->duplex = DUPLEX_FULL;\n\n\tif (regval & KSZ8873MLL_GLOBAL_CONTROL_4_SPEED)\n\t\tphydev->speed = SPEED_10;\n\telse\n\t\tphydev->speed = SPEED_100;\n\n\tphydev->link = 1;\n\tphydev->pause = phydev->asym_pause = 0;\n\n\treturn 0;\n}\n\nstatic int ksz9031_get_features(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = genphy_read_abilities(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tlinkmode_clear_bit(ETHTOOL_LINK_MODE_Asym_Pause_BIT, phydev->supported);\n\n\t \n\tlinkmode_set_bit(ETHTOOL_LINK_MODE_Pause_BIT, phydev->supported);\n\n\treturn 0;\n}\n\nstatic int ksz9031_read_status(struct phy_device *phydev)\n{\n\tint err;\n\tint regval;\n\n\terr = genphy_read_status(phydev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tregval = phy_read(phydev, MII_STAT1000);\n\tif ((regval & 0xFF) == 0xFF) {\n\t\tphy_init_hw(phydev);\n\t\tphydev->link = 0;\n\t\tif (phydev->drv->config_intr && phy_interrupt_is_valid(phydev))\n\t\t\tphydev->drv->config_intr(phydev);\n\t\treturn genphy_config_aneg(phydev);\n\t}\n\n\treturn 0;\n}\n\nstatic int ksz9x31_cable_test_start(struct phy_device *phydev)\n{\n\tstruct kszphy_priv *priv = phydev->priv;\n\tint ret;\n\n\t \n\tret = phy_modify(phydev, MII_BMCR,\n\t\t\t BMCR_SPEED1000 | BMCR_FULLDPLX |\n\t\t\t BMCR_ANENABLE | BMCR_SPEED100,\n\t\t\t BMCR_SPEED1000 | BMCR_FULLDPLX);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = phy_read(phydev, MII_CTRL1000);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tpriv->vct_ctrl1000 = ret & (CTL1000_ENABLE_MASTER | CTL1000_AS_MASTER);\n\tret &= ~(CTL1000_ENABLE_MASTER | CTL1000_AS_MASTER);\n\tret |= CTL1000_ENABLE_MASTER;\n\n\treturn phy_write(phydev, MII_CTRL1000, ret);\n}\n\nstatic int ksz9x31_cable_test_result_trans(u16 status)\n{\n\tswitch (FIELD_GET(KSZ9x31_LMD_VCT_ST_MASK, status)) {\n\tcase KSZ9x31_LMD_VCT_ST_NORMAL:\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_OK;\n\tcase KSZ9x31_LMD_VCT_ST_OPEN:\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_OPEN;\n\tcase KSZ9x31_LMD_VCT_ST_SHORT:\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_SAME_SHORT;\n\tcase KSZ9x31_LMD_VCT_ST_FAIL:\n\t\tfallthrough;\n\tdefault:\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_UNSPEC;\n\t}\n}\n\nstatic bool ksz9x31_cable_test_failed(u16 status)\n{\n\tint stat = FIELD_GET(KSZ9x31_LMD_VCT_ST_MASK, status);\n\n\treturn stat == KSZ9x31_LMD_VCT_ST_FAIL;\n}\n\nstatic bool ksz9x31_cable_test_fault_length_valid(u16 status)\n{\n\tswitch (FIELD_GET(KSZ9x31_LMD_VCT_ST_MASK, status)) {\n\tcase KSZ9x31_LMD_VCT_ST_OPEN:\n\t\tfallthrough;\n\tcase KSZ9x31_LMD_VCT_ST_SHORT:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int ksz9x31_cable_test_fault_length(struct phy_device *phydev, u16 stat)\n{\n\tint dt = FIELD_GET(KSZ9x31_LMD_VCT_DATA_MASK, stat);\n\n\t \n\tif (phydev_id_compare(phydev, PHY_ID_KSZ9131))\n\t\tdt = clamp(dt - 22, 0, 255);\n\n\treturn (dt * 400) / 10;\n}\n\nstatic int ksz9x31_cable_test_wait_for_completion(struct phy_device *phydev)\n{\n\tint val, ret;\n\n\tret = phy_read_poll_timeout(phydev, KSZ9x31_LMD, val,\n\t\t\t\t    !(val & KSZ9x31_LMD_VCT_EN),\n\t\t\t\t    30000, 100000, true);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int ksz9x31_cable_test_get_pair(int pair)\n{\n\tstatic const int ethtool_pair[] = {\n\t\tETHTOOL_A_CABLE_PAIR_A,\n\t\tETHTOOL_A_CABLE_PAIR_B,\n\t\tETHTOOL_A_CABLE_PAIR_C,\n\t\tETHTOOL_A_CABLE_PAIR_D,\n\t};\n\n\treturn ethtool_pair[pair];\n}\n\nstatic int ksz9x31_cable_test_one_pair(struct phy_device *phydev, int pair)\n{\n\tint ret, val;\n\n\t \n\tret = phy_write(phydev, KSZ9x31_LMD,\n\t\t\tKSZ9x31_LMD_VCT_EN | KSZ9x31_LMD_VCT_PAIR(pair));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ksz9x31_cable_test_wait_for_completion(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tval = phy_read(phydev, KSZ9x31_LMD);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (ksz9x31_cable_test_failed(val))\n\t\treturn -EAGAIN;\n\n\tret = ethnl_cable_test_result(phydev,\n\t\t\t\t      ksz9x31_cable_test_get_pair(pair),\n\t\t\t\t      ksz9x31_cable_test_result_trans(val));\n\tif (ret)\n\t\treturn ret;\n\n\tif (!ksz9x31_cable_test_fault_length_valid(val))\n\t\treturn 0;\n\n\treturn ethnl_cable_test_fault_length(phydev,\n\t\t\t\t\t     ksz9x31_cable_test_get_pair(pair),\n\t\t\t\t\t     ksz9x31_cable_test_fault_length(phydev, val));\n}\n\nstatic int ksz9x31_cable_test_get_status(struct phy_device *phydev,\n\t\t\t\t\t bool *finished)\n{\n\tstruct kszphy_priv *priv = phydev->priv;\n\tunsigned long pair_mask = 0xf;\n\tint retries = 20;\n\tint pair, ret, rv;\n\n\t*finished = false;\n\n\t \n\twhile (pair_mask && retries--) {\n\t\tfor_each_set_bit(pair, &pair_mask, 4) {\n\t\t\tret = ksz9x31_cable_test_one_pair(phydev, pair);\n\t\t\tif (ret == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tclear_bit(pair, &pair_mask);\n\t\t}\n\t\t \n\t\tif (pair_mask)\n\t\t\tusleep_range(2000, 3000);\n\t}\n\n\t \n\tfor_each_set_bit(pair, &pair_mask, 4) {\n\t\tret = ethnl_cable_test_result(phydev,\n\t\t\t\t\t      ksz9x31_cable_test_get_pair(pair),\n\t\t\t\t\t      ETHTOOL_A_CABLE_RESULT_CODE_UNSPEC);\n\t}\n\n\t*finished = true;\n\n\t \n\trv = phy_modify(phydev, MII_CTRL1000,\n\t\t\tCTL1000_ENABLE_MASTER | CTL1000_AS_MASTER,\n\t\t\tpriv->vct_ctrl1000);\n\tif (rv)\n\t\treturn rv;\n\n\treturn ret;\n}\n\nstatic int ksz8873mll_config_aneg(struct phy_device *phydev)\n{\n\treturn 0;\n}\n\nstatic int ksz886x_config_mdix(struct phy_device *phydev, u8 ctrl)\n{\n\tu16 val;\n\n\tswitch (ctrl) {\n\tcase ETH_TP_MDI:\n\t\tval = KSZ886X_BMCR_DISABLE_AUTO_MDIX;\n\t\tbreak;\n\tcase ETH_TP_MDI_X:\n\t\t \n\t\tval = KSZ886X_BMCR_DISABLE_AUTO_MDIX | KSZ886X_BMCR_FORCE_MDI;\n\t\tbreak;\n\tcase ETH_TP_MDI_AUTO:\n\t\tval = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn phy_modify(phydev, MII_BMCR,\n\t\t\t  KSZ886X_BMCR_HP_MDIX | KSZ886X_BMCR_FORCE_MDI |\n\t\t\t  KSZ886X_BMCR_DISABLE_AUTO_MDIX,\n\t\t\t  KSZ886X_BMCR_HP_MDIX | val);\n}\n\nstatic int ksz886x_config_aneg(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = genphy_config_aneg(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn ksz886x_config_mdix(phydev, phydev->mdix_ctrl);\n}\n\nstatic int ksz886x_mdix_update(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = phy_read(phydev, MII_BMCR);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret & KSZ886X_BMCR_DISABLE_AUTO_MDIX) {\n\t\tif (ret & KSZ886X_BMCR_FORCE_MDI)\n\t\t\tphydev->mdix_ctrl = ETH_TP_MDI_X;\n\t\telse\n\t\t\tphydev->mdix_ctrl = ETH_TP_MDI;\n\t} else {\n\t\tphydev->mdix_ctrl = ETH_TP_MDI_AUTO;\n\t}\n\n\tret = phy_read(phydev, MII_KSZPHY_CTRL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (ret & KSZ886X_CTRL_MDIX_STAT)\n\t\tphydev->mdix = ETH_TP_MDI_X;\n\telse\n\t\tphydev->mdix = ETH_TP_MDI;\n\n\treturn 0;\n}\n\nstatic int ksz886x_read_status(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = ksz886x_mdix_update(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn genphy_read_status(phydev);\n}\n\nstruct ksz9477_errata_write {\n\tu8 dev_addr;\n\tu8 reg_addr;\n\tu16 val;\n};\n\nstatic const struct ksz9477_errata_write ksz9477_errata_writes[] = {\n\t  \n\t{0x01, 0x6f, 0xdd0b},\n\t{0x01, 0x8f, 0x6032},\n\t{0x01, 0x9d, 0x248c},\n\t{0x01, 0x75, 0x0060},\n\t{0x01, 0xd3, 0x7777},\n\t{0x1c, 0x06, 0x3008},\n\t{0x1c, 0x08, 0x2000},\n\n\t \n\t{0x1c, 0x04, 0x00d0},\n\n\t \n\t{0x1c, 0x13, 0x6eff},\n\t{0x1c, 0x14, 0xe6ff},\n\t{0x1c, 0x15, 0x6eff},\n\t{0x1c, 0x16, 0xe6ff},\n\t{0x1c, 0x17, 0x00ff},\n\t{0x1c, 0x18, 0x43ff},\n\t{0x1c, 0x19, 0xc3ff},\n\t{0x1c, 0x1a, 0x6fff},\n\t{0x1c, 0x1b, 0x07ff},\n\t{0x1c, 0x1c, 0x0fff},\n\t{0x1c, 0x1d, 0xe7ff},\n\t{0x1c, 0x1e, 0xefff},\n\t{0x1c, 0x20, 0xeeee},\n};\n\nstatic int ksz9477_config_init(struct phy_device *phydev)\n{\n\tint err;\n\tint i;\n\n\t \n\terr = phy_write(phydev, MII_BMCR, BMCR_SPEED100 | BMCR_FULLDPLX);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < ARRAY_SIZE(ksz9477_errata_writes); ++i) {\n\t\tconst struct ksz9477_errata_write *errata = &ksz9477_errata_writes[i];\n\n\t\terr = phy_write_mmd(phydev, errata->dev_addr, errata->reg_addr, errata->val);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (phydev->dev_flags & MICREL_NO_EEE)\n\t\tphydev->eee_broken_modes = -1;\n\n\terr = genphy_restart_aneg(phydev);\n\tif (err)\n\t\treturn err;\n\n\treturn kszphy_config_init(phydev);\n}\n\nstatic int kszphy_get_sset_count(struct phy_device *phydev)\n{\n\treturn ARRAY_SIZE(kszphy_hw_stats);\n}\n\nstatic void kszphy_get_strings(struct phy_device *phydev, u8 *data)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(kszphy_hw_stats); i++) {\n\t\tstrscpy(data + i * ETH_GSTRING_LEN,\n\t\t\tkszphy_hw_stats[i].string, ETH_GSTRING_LEN);\n\t}\n}\n\nstatic u64 kszphy_get_stat(struct phy_device *phydev, int i)\n{\n\tstruct kszphy_hw_stat stat = kszphy_hw_stats[i];\n\tstruct kszphy_priv *priv = phydev->priv;\n\tint val;\n\tu64 ret;\n\n\tval = phy_read(phydev, stat.reg);\n\tif (val < 0) {\n\t\tret = U64_MAX;\n\t} else {\n\t\tval = val & ((1 << stat.bits) - 1);\n\t\tpriv->stats[i] += val;\n\t\tret = priv->stats[i];\n\t}\n\n\treturn ret;\n}\n\nstatic void kszphy_get_stats(struct phy_device *phydev,\n\t\t\t     struct ethtool_stats *stats, u64 *data)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(kszphy_hw_stats); i++)\n\t\tdata[i] = kszphy_get_stat(phydev, i);\n}\n\nstatic int kszphy_suspend(struct phy_device *phydev)\n{\n\t \n\tif (phy_interrupt_is_valid(phydev)) {\n\t\tphydev->interrupts = PHY_INTERRUPT_DISABLED;\n\t\tif (phydev->drv->config_intr)\n\t\t\tphydev->drv->config_intr(phydev);\n\t}\n\n\treturn genphy_suspend(phydev);\n}\n\nstatic void kszphy_parse_led_mode(struct phy_device *phydev)\n{\n\tconst struct kszphy_type *type = phydev->drv->driver_data;\n\tconst struct device_node *np = phydev->mdio.dev.of_node;\n\tstruct kszphy_priv *priv = phydev->priv;\n\tint ret;\n\n\tif (type && type->led_mode_reg) {\n\t\tret = of_property_read_u32(np, \"micrel,led-mode\",\n\t\t\t\t\t   &priv->led_mode);\n\n\t\tif (ret)\n\t\t\tpriv->led_mode = -1;\n\n\t\tif (priv->led_mode > 3) {\n\t\t\tphydev_err(phydev, \"invalid led mode: 0x%02x\\n\",\n\t\t\t\t   priv->led_mode);\n\t\t\tpriv->led_mode = -1;\n\t\t}\n\t} else {\n\t\tpriv->led_mode = -1;\n\t}\n}\n\nstatic int kszphy_resume(struct phy_device *phydev)\n{\n\tint ret;\n\n\tgenphy_resume(phydev);\n\n\t \n\tusleep_range(1000, 2000);\n\n\tret = kszphy_config_reset(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (phy_interrupt_is_valid(phydev)) {\n\t\tphydev->interrupts = PHY_INTERRUPT_ENABLED;\n\t\tif (phydev->drv->config_intr)\n\t\t\tphydev->drv->config_intr(phydev);\n\t}\n\n\treturn 0;\n}\n\nstatic int kszphy_probe(struct phy_device *phydev)\n{\n\tconst struct kszphy_type *type = phydev->drv->driver_data;\n\tconst struct device_node *np = phydev->mdio.dev.of_node;\n\tstruct kszphy_priv *priv;\n\tstruct clk *clk;\n\n\tpriv = devm_kzalloc(&phydev->mdio.dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tphydev->priv = priv;\n\n\tpriv->type = type;\n\n\tkszphy_parse_led_mode(phydev);\n\n\tclk = devm_clk_get(&phydev->mdio.dev, \"rmii-ref\");\n\t \n\tif (!IS_ERR_OR_NULL(clk)) {\n\t\tunsigned long rate = clk_get_rate(clk);\n\t\tbool rmii_ref_clk_sel_25_mhz;\n\n\t\tif (type)\n\t\t\tpriv->rmii_ref_clk_sel = type->has_rmii_ref_clk_sel;\n\t\trmii_ref_clk_sel_25_mhz = of_property_read_bool(np,\n\t\t\t\t\"micrel,rmii-reference-clock-select-25-mhz\");\n\n\t\tif (rate > 24500000 && rate < 25500000) {\n\t\t\tpriv->rmii_ref_clk_sel_val = rmii_ref_clk_sel_25_mhz;\n\t\t} else if (rate > 49500000 && rate < 50500000) {\n\t\t\tpriv->rmii_ref_clk_sel_val = !rmii_ref_clk_sel_25_mhz;\n\t\t} else {\n\t\t\tphydev_err(phydev, \"Clock rate out of range: %ld\\n\",\n\t\t\t\t   rate);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (ksz8041_fiber_mode(phydev))\n\t\tphydev->port = PORT_FIBRE;\n\n\t \n\tif (phydev->dev_flags & MICREL_PHY_50MHZ_CLK) {\n\t\tpriv->rmii_ref_clk_sel = true;\n\t\tpriv->rmii_ref_clk_sel_val = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int lan8814_cable_test_start(struct phy_device *phydev)\n{\n\t \n\treturn phy_modify(phydev, MII_BMCR, BMCR_ANENABLE | BMCR_SPEED100,\n\t\t\t  BMCR_SPEED1000 | BMCR_FULLDPLX);\n}\n\nstatic int ksz886x_cable_test_start(struct phy_device *phydev)\n{\n\tif (phydev->dev_flags & MICREL_KSZ8_P1_ERRATA)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\treturn phy_clear_bits(phydev, MII_BMCR, BMCR_ANENABLE | BMCR_SPEED100);\n}\n\nstatic __always_inline int ksz886x_cable_test_result_trans(u16 status, u16 mask)\n{\n\tswitch (FIELD_GET(mask, status)) {\n\tcase KSZ8081_LMD_STAT_NORMAL:\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_OK;\n\tcase KSZ8081_LMD_STAT_SHORT:\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_SAME_SHORT;\n\tcase KSZ8081_LMD_STAT_OPEN:\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_OPEN;\n\tcase KSZ8081_LMD_STAT_FAIL:\n\t\tfallthrough;\n\tdefault:\n\t\treturn ETHTOOL_A_CABLE_RESULT_CODE_UNSPEC;\n\t}\n}\n\nstatic __always_inline bool ksz886x_cable_test_failed(u16 status, u16 mask)\n{\n\treturn FIELD_GET(mask, status) ==\n\t\tKSZ8081_LMD_STAT_FAIL;\n}\n\nstatic __always_inline bool ksz886x_cable_test_fault_length_valid(u16 status, u16 mask)\n{\n\tswitch (FIELD_GET(mask, status)) {\n\tcase KSZ8081_LMD_STAT_OPEN:\n\t\tfallthrough;\n\tcase KSZ8081_LMD_STAT_SHORT:\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic __always_inline int ksz886x_cable_test_fault_length(struct phy_device *phydev,\n\t\t\t\t\t\t\t   u16 status, u16 data_mask)\n{\n\tint dt;\n\n\t \n\tdt = FIELD_GET(data_mask, status);\n\n\tif (phydev_id_compare(phydev, PHY_ID_LAN8814))\n\t\treturn ((dt - 22) * 800) / 10;\n\telse\n\t\treturn (dt * 400) / 10;\n}\n\nstatic int ksz886x_cable_test_wait_for_completion(struct phy_device *phydev)\n{\n\tconst struct kszphy_type *type = phydev->drv->driver_data;\n\tint val, ret;\n\n\tret = phy_read_poll_timeout(phydev, type->cable_diag_reg, val,\n\t\t\t\t    !(val & KSZ8081_LMD_ENABLE_TEST),\n\t\t\t\t    30000, 100000, true);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic int lan8814_cable_test_one_pair(struct phy_device *phydev, int pair)\n{\n\tstatic const int ethtool_pair[] = { ETHTOOL_A_CABLE_PAIR_A,\n\t\t\t\t\t    ETHTOOL_A_CABLE_PAIR_B,\n\t\t\t\t\t    ETHTOOL_A_CABLE_PAIR_C,\n\t\t\t\t\t    ETHTOOL_A_CABLE_PAIR_D,\n\t\t\t\t\t  };\n\tu32 fault_length;\n\tint ret;\n\tint val;\n\n\tval = KSZ8081_LMD_ENABLE_TEST;\n\tval = val | (pair << LAN8814_PAIR_BIT_SHIFT);\n\n\tret = phy_write(phydev, LAN8814_CABLE_DIAG, val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ksz886x_cable_test_wait_for_completion(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tval = phy_read(phydev, LAN8814_CABLE_DIAG);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (ksz886x_cable_test_failed(val, LAN8814_CABLE_DIAG_STAT_MASK))\n\t\treturn -EAGAIN;\n\n\tret = ethnl_cable_test_result(phydev, ethtool_pair[pair],\n\t\t\t\t      ksz886x_cable_test_result_trans(val,\n\t\t\t\t\t\t\t\t      LAN8814_CABLE_DIAG_STAT_MASK\n\t\t\t\t\t\t\t\t      ));\n\tif (ret)\n\t\treturn ret;\n\n\tif (!ksz886x_cable_test_fault_length_valid(val, LAN8814_CABLE_DIAG_STAT_MASK))\n\t\treturn 0;\n\n\tfault_length = ksz886x_cable_test_fault_length(phydev, val,\n\t\t\t\t\t\t       LAN8814_CABLE_DIAG_VCT_DATA_MASK);\n\n\treturn ethnl_cable_test_fault_length(phydev, ethtool_pair[pair], fault_length);\n}\n\nstatic int ksz886x_cable_test_one_pair(struct phy_device *phydev, int pair)\n{\n\tstatic const int ethtool_pair[] = {\n\t\tETHTOOL_A_CABLE_PAIR_A,\n\t\tETHTOOL_A_CABLE_PAIR_B,\n\t};\n\tint ret, val, mdix;\n\tu32 fault_length;\n\n\t \n\tif (pair == 0)\n\t\tmdix = ETH_TP_MDI;\n\telse\n\t\tmdix = ETH_TP_MDI_X;\n\n\tswitch (phydev->phy_id & MICREL_PHY_ID_MASK) {\n\tcase PHY_ID_KSZ8081:\n\t\tret = ksz8081_config_mdix(phydev, mdix);\n\t\tbreak;\n\tcase PHY_ID_KSZ886X:\n\t\tret = ksz886x_config_mdix(phydev, mdix);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODEV;\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = phy_write(phydev, KSZ8081_LMD, KSZ8081_LMD_ENABLE_TEST);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ksz886x_cable_test_wait_for_completion(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tval = phy_read(phydev, KSZ8081_LMD);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (ksz886x_cable_test_failed(val, KSZ8081_LMD_STAT_MASK))\n\t\treturn -EAGAIN;\n\n\tret = ethnl_cable_test_result(phydev, ethtool_pair[pair],\n\t\t\t\t      ksz886x_cable_test_result_trans(val, KSZ8081_LMD_STAT_MASK));\n\tif (ret)\n\t\treturn ret;\n\n\tif (!ksz886x_cable_test_fault_length_valid(val, KSZ8081_LMD_STAT_MASK))\n\t\treturn 0;\n\n\tfault_length = ksz886x_cable_test_fault_length(phydev, val, KSZ8081_LMD_DELTA_TIME_MASK);\n\n\treturn ethnl_cable_test_fault_length(phydev, ethtool_pair[pair], fault_length);\n}\n\nstatic int ksz886x_cable_test_get_status(struct phy_device *phydev,\n\t\t\t\t\t bool *finished)\n{\n\tconst struct kszphy_type *type = phydev->drv->driver_data;\n\tunsigned long pair_mask = type->pair_mask;\n\tint retries = 20;\n\tint ret = 0;\n\tint pair;\n\n\t*finished = false;\n\n\t \n\twhile (pair_mask && retries--) {\n\t\tfor_each_set_bit(pair, &pair_mask, 4) {\n\t\t\tif (type->cable_diag_reg == LAN8814_CABLE_DIAG)\n\t\t\t\tret = lan8814_cable_test_one_pair(phydev, pair);\n\t\t\telse\n\t\t\t\tret = ksz886x_cable_test_one_pair(phydev, pair);\n\t\t\tif (ret == -EAGAIN)\n\t\t\t\tcontinue;\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tclear_bit(pair, &pair_mask);\n\t\t}\n\t\t \n\t\tif (pair_mask)\n\t\t\tmsleep(2);\n\t}\n\n\t*finished = true;\n\n\treturn ret;\n}\n\n#define LAN_EXT_PAGE_ACCESS_CONTROL\t\t\t0x16\n#define LAN_EXT_PAGE_ACCESS_ADDRESS_DATA\t\t0x17\n#define LAN_EXT_PAGE_ACCESS_CTRL_EP_FUNC\t\t0x4000\n\n#define LAN8814_QSGMII_SOFT_RESET\t\t\t0x43\n#define LAN8814_QSGMII_SOFT_RESET_BIT\t\t\tBIT(0)\n#define LAN8814_QSGMII_PCS1G_ANEG_CONFIG\t\t0x13\n#define LAN8814_QSGMII_PCS1G_ANEG_CONFIG_ANEG_ENA\tBIT(3)\n#define LAN8814_ALIGN_SWAP\t\t\t\t0x4a\n#define LAN8814_ALIGN_TX_A_B_SWAP\t\t\t0x1\n#define LAN8814_ALIGN_TX_A_B_SWAP_MASK\t\t\tGENMASK(2, 0)\n\n#define LAN8804_ALIGN_SWAP\t\t\t\t0x4a\n#define LAN8804_ALIGN_TX_A_B_SWAP\t\t\t0x1\n#define LAN8804_ALIGN_TX_A_B_SWAP_MASK\t\t\tGENMASK(2, 0)\n#define LAN8814_CLOCK_MANAGEMENT\t\t\t0xd\n#define LAN8814_LINK_QUALITY\t\t\t\t0x8e\n\nstatic int lanphy_read_page_reg(struct phy_device *phydev, int page, u32 addr)\n{\n\tint data;\n\n\tphy_lock_mdio_bus(phydev);\n\t__phy_write(phydev, LAN_EXT_PAGE_ACCESS_CONTROL, page);\n\t__phy_write(phydev, LAN_EXT_PAGE_ACCESS_ADDRESS_DATA, addr);\n\t__phy_write(phydev, LAN_EXT_PAGE_ACCESS_CONTROL,\n\t\t    (page | LAN_EXT_PAGE_ACCESS_CTRL_EP_FUNC));\n\tdata = __phy_read(phydev, LAN_EXT_PAGE_ACCESS_ADDRESS_DATA);\n\tphy_unlock_mdio_bus(phydev);\n\n\treturn data;\n}\n\nstatic int lanphy_write_page_reg(struct phy_device *phydev, int page, u16 addr,\n\t\t\t\t u16 val)\n{\n\tphy_lock_mdio_bus(phydev);\n\t__phy_write(phydev, LAN_EXT_PAGE_ACCESS_CONTROL, page);\n\t__phy_write(phydev, LAN_EXT_PAGE_ACCESS_ADDRESS_DATA, addr);\n\t__phy_write(phydev, LAN_EXT_PAGE_ACCESS_CONTROL,\n\t\t    page | LAN_EXT_PAGE_ACCESS_CTRL_EP_FUNC);\n\n\tval = __phy_write(phydev, LAN_EXT_PAGE_ACCESS_ADDRESS_DATA, val);\n\tif (val != 0)\n\t\tphydev_err(phydev, \"Error: phy_write has returned error %d\\n\",\n\t\t\t   val);\n\tphy_unlock_mdio_bus(phydev);\n\treturn val;\n}\n\nstatic int lan8814_config_ts_intr(struct phy_device *phydev, bool enable)\n{\n\tu16 val = 0;\n\n\tif (enable)\n\t\tval = PTP_TSU_INT_EN_PTP_TX_TS_EN_ |\n\t\t      PTP_TSU_INT_EN_PTP_TX_TS_OVRFL_EN_ |\n\t\t      PTP_TSU_INT_EN_PTP_RX_TS_EN_ |\n\t\t      PTP_TSU_INT_EN_PTP_RX_TS_OVRFL_EN_;\n\n\treturn lanphy_write_page_reg(phydev, 5, PTP_TSU_INT_EN, val);\n}\n\nstatic void lan8814_ptp_rx_ts_get(struct phy_device *phydev,\n\t\t\t\t  u32 *seconds, u32 *nano_seconds, u16 *seq_id)\n{\n\t*seconds = lanphy_read_page_reg(phydev, 5, PTP_RX_INGRESS_SEC_HI);\n\t*seconds = (*seconds << 16) |\n\t\t   lanphy_read_page_reg(phydev, 5, PTP_RX_INGRESS_SEC_LO);\n\n\t*nano_seconds = lanphy_read_page_reg(phydev, 5, PTP_RX_INGRESS_NS_HI);\n\t*nano_seconds = ((*nano_seconds & 0x3fff) << 16) |\n\t\t\tlanphy_read_page_reg(phydev, 5, PTP_RX_INGRESS_NS_LO);\n\n\t*seq_id = lanphy_read_page_reg(phydev, 5, PTP_RX_MSG_HEADER2);\n}\n\nstatic void lan8814_ptp_tx_ts_get(struct phy_device *phydev,\n\t\t\t\t  u32 *seconds, u32 *nano_seconds, u16 *seq_id)\n{\n\t*seconds = lanphy_read_page_reg(phydev, 5, PTP_TX_EGRESS_SEC_HI);\n\t*seconds = *seconds << 16 |\n\t\t   lanphy_read_page_reg(phydev, 5, PTP_TX_EGRESS_SEC_LO);\n\n\t*nano_seconds = lanphy_read_page_reg(phydev, 5, PTP_TX_EGRESS_NS_HI);\n\t*nano_seconds = ((*nano_seconds & 0x3fff) << 16) |\n\t\t\tlanphy_read_page_reg(phydev, 5, PTP_TX_EGRESS_NS_LO);\n\n\t*seq_id = lanphy_read_page_reg(phydev, 5, PTP_TX_MSG_HEADER2);\n}\n\nstatic int lan8814_ts_info(struct mii_timestamper *mii_ts, struct ethtool_ts_info *info)\n{\n\tstruct kszphy_ptp_priv *ptp_priv = container_of(mii_ts, struct kszphy_ptp_priv, mii_ts);\n\tstruct phy_device *phydev = ptp_priv->phydev;\n\tstruct lan8814_shared_priv *shared = phydev->shared->priv;\n\n\tinfo->so_timestamping = SOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\n\tinfo->phc_index = ptp_clock_index(shared->ptp_clock);\n\n\tinfo->tx_types =\n\t\t(1 << HWTSTAMP_TX_OFF) |\n\t\t(1 << HWTSTAMP_TX_ON) |\n\t\t(1 << HWTSTAMP_TX_ONESTEP_SYNC);\n\n\tinfo->rx_filters =\n\t\t(1 << HWTSTAMP_FILTER_NONE) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V1_L4_EVENT) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_L2_EVENT) |\n\t\t(1 << HWTSTAMP_FILTER_PTP_V2_EVENT);\n\n\treturn 0;\n}\n\nstatic void lan8814_flush_fifo(struct phy_device *phydev, bool egress)\n{\n\tint i;\n\n\tfor (i = 0; i < FIFO_SIZE; ++i)\n\t\tlanphy_read_page_reg(phydev, 5,\n\t\t\t\t     egress ? PTP_TX_MSG_HEADER2 : PTP_RX_MSG_HEADER2);\n\n\t \n\tlanphy_read_page_reg(phydev, 5, PTP_TSU_INT_STS);\n}\n\nstatic int lan8814_hwtstamp(struct mii_timestamper *mii_ts, struct ifreq *ifr)\n{\n\tstruct kszphy_ptp_priv *ptp_priv =\n\t\t\t  container_of(mii_ts, struct kszphy_ptp_priv, mii_ts);\n\tstruct phy_device *phydev = ptp_priv->phydev;\n\tstruct lan8814_shared_priv *shared = phydev->shared->priv;\n\tstruct lan8814_ptp_rx_ts *rx_ts, *tmp;\n\tstruct hwtstamp_config config;\n\tint txcfg = 0, rxcfg = 0;\n\tint pkt_ts_enable;\n\n\tif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\n\t\treturn -EFAULT;\n\n\tptp_priv->hwts_tx_type = config.tx_type;\n\tptp_priv->rx_filter = config.rx_filter;\n\n\tswitch (config.rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tptp_priv->layer = 0;\n\t\tptp_priv->version = 0;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\t\tptp_priv->layer = PTP_CLASS_L4;\n\t\tptp_priv->version = PTP_CLASS_V2;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\t\tptp_priv->layer = PTP_CLASS_L2;\n\t\tptp_priv->version = PTP_CLASS_V2;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\t\tptp_priv->layer = PTP_CLASS_L4 | PTP_CLASS_L2;\n\t\tptp_priv->version = PTP_CLASS_V2;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\tif (ptp_priv->layer & PTP_CLASS_L2) {\n\t\trxcfg = PTP_RX_PARSE_CONFIG_LAYER2_EN_;\n\t\ttxcfg = PTP_TX_PARSE_CONFIG_LAYER2_EN_;\n\t} else if (ptp_priv->layer & PTP_CLASS_L4) {\n\t\trxcfg |= PTP_RX_PARSE_CONFIG_IPV4_EN_ | PTP_RX_PARSE_CONFIG_IPV6_EN_;\n\t\ttxcfg |= PTP_TX_PARSE_CONFIG_IPV4_EN_ | PTP_TX_PARSE_CONFIG_IPV6_EN_;\n\t}\n\tlanphy_write_page_reg(ptp_priv->phydev, 5, PTP_RX_PARSE_CONFIG, rxcfg);\n\tlanphy_write_page_reg(ptp_priv->phydev, 5, PTP_TX_PARSE_CONFIG, txcfg);\n\n\tpkt_ts_enable = PTP_TIMESTAMP_EN_SYNC_ | PTP_TIMESTAMP_EN_DREQ_ |\n\t\t\tPTP_TIMESTAMP_EN_PDREQ_ | PTP_TIMESTAMP_EN_PDRES_;\n\tlanphy_write_page_reg(ptp_priv->phydev, 5, PTP_RX_TIMESTAMP_EN, pkt_ts_enable);\n\tlanphy_write_page_reg(ptp_priv->phydev, 5, PTP_TX_TIMESTAMP_EN, pkt_ts_enable);\n\n\tif (ptp_priv->hwts_tx_type == HWTSTAMP_TX_ONESTEP_SYNC)\n\t\tlanphy_write_page_reg(ptp_priv->phydev, 5, PTP_TX_MOD,\n\t\t\t\t      PTP_TX_MOD_TX_PTP_SYNC_TS_INSERT_);\n\n\tif (config.rx_filter != HWTSTAMP_FILTER_NONE)\n\t\tlan8814_config_ts_intr(ptp_priv->phydev, true);\n\telse\n\t\tlan8814_config_ts_intr(ptp_priv->phydev, false);\n\n\tmutex_lock(&shared->shared_lock);\n\tif (config.rx_filter != HWTSTAMP_FILTER_NONE)\n\t\tshared->ref++;\n\telse\n\t\tshared->ref--;\n\n\tif (shared->ref)\n\t\tlanphy_write_page_reg(ptp_priv->phydev, 4, PTP_CMD_CTL,\n\t\t\t\t      PTP_CMD_CTL_PTP_ENABLE_);\n\telse\n\t\tlanphy_write_page_reg(ptp_priv->phydev, 4, PTP_CMD_CTL,\n\t\t\t\t      PTP_CMD_CTL_PTP_DISABLE_);\n\tmutex_unlock(&shared->shared_lock);\n\n\t \n\tlist_for_each_entry_safe(rx_ts, tmp, &ptp_priv->rx_ts_list, list) {\n\t\tlist_del(&rx_ts->list);\n\t\tkfree(rx_ts);\n\t}\n\tskb_queue_purge(&ptp_priv->rx_queue);\n\tskb_queue_purge(&ptp_priv->tx_queue);\n\n\tlan8814_flush_fifo(ptp_priv->phydev, false);\n\tlan8814_flush_fifo(ptp_priv->phydev, true);\n\n\treturn copy_to_user(ifr->ifr_data, &config, sizeof(config)) ? -EFAULT : 0;\n}\n\nstatic void lan8814_txtstamp(struct mii_timestamper *mii_ts,\n\t\t\t     struct sk_buff *skb, int type)\n{\n\tstruct kszphy_ptp_priv *ptp_priv = container_of(mii_ts, struct kszphy_ptp_priv, mii_ts);\n\n\tswitch (ptp_priv->hwts_tx_type) {\n\tcase HWTSTAMP_TX_ONESTEP_SYNC:\n\t\tif (ptp_msg_is_sync(skb, type)) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t\tfallthrough;\n\tcase HWTSTAMP_TX_ON:\n\t\tskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\n\t\tskb_queue_tail(&ptp_priv->tx_queue, skb);\n\t\tbreak;\n\tcase HWTSTAMP_TX_OFF:\n\tdefault:\n\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n}\n\nstatic void lan8814_get_sig_rx(struct sk_buff *skb, u16 *sig)\n{\n\tstruct ptp_header *ptp_header;\n\tu32 type;\n\n\tskb_push(skb, ETH_HLEN);\n\ttype = ptp_classify_raw(skb);\n\tptp_header = ptp_parse_header(skb, type);\n\tskb_pull_inline(skb, ETH_HLEN);\n\n\t*sig = (__force u16)(ntohs(ptp_header->sequence_id));\n}\n\nstatic bool lan8814_match_rx_skb(struct kszphy_ptp_priv *ptp_priv,\n\t\t\t\t struct sk_buff *skb)\n{\n\tstruct skb_shared_hwtstamps *shhwtstamps;\n\tstruct lan8814_ptp_rx_ts *rx_ts, *tmp;\n\tunsigned long flags;\n\tbool ret = false;\n\tu16 skb_sig;\n\n\tlan8814_get_sig_rx(skb, &skb_sig);\n\n\t \n\tspin_lock_irqsave(&ptp_priv->rx_ts_lock, flags);\n\tlist_for_each_entry_safe(rx_ts, tmp, &ptp_priv->rx_ts_list, list) {\n\t\t \n\t\tif (memcmp(&skb_sig, &rx_ts->seq_id, sizeof(rx_ts->seq_id)))\n\t\t\tcontinue;\n\n\t\tshhwtstamps = skb_hwtstamps(skb);\n\t\tmemset(shhwtstamps, 0, sizeof(*shhwtstamps));\n\t\tshhwtstamps->hwtstamp = ktime_set(rx_ts->seconds,\n\t\t\t\t\t\t  rx_ts->nsec);\n\t\tlist_del(&rx_ts->list);\n\t\tkfree(rx_ts);\n\n\t\tret = true;\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&ptp_priv->rx_ts_lock, flags);\n\n\tif (ret)\n\t\tnetif_rx(skb);\n\treturn ret;\n}\n\nstatic bool lan8814_rxtstamp(struct mii_timestamper *mii_ts, struct sk_buff *skb, int type)\n{\n\tstruct kszphy_ptp_priv *ptp_priv =\n\t\t\tcontainer_of(mii_ts, struct kszphy_ptp_priv, mii_ts);\n\n\tif (ptp_priv->rx_filter == HWTSTAMP_FILTER_NONE ||\n\t    type == PTP_CLASS_NONE)\n\t\treturn false;\n\n\tif ((type & ptp_priv->version) == 0 || (type & ptp_priv->layer) == 0)\n\t\treturn false;\n\n\t \n\tif (!lan8814_match_rx_skb(ptp_priv, skb))\n\t\tskb_queue_tail(&ptp_priv->rx_queue, skb);\n\n\treturn true;\n}\n\nstatic void lan8814_ptp_clock_set(struct phy_device *phydev,\n\t\t\t\t  u32 seconds, u32 nano_seconds)\n{\n\tu32 sec_low, sec_high, nsec_low, nsec_high;\n\n\tsec_low = seconds & 0xffff;\n\tsec_high = (seconds >> 16) & 0xffff;\n\tnsec_low = nano_seconds & 0xffff;\n\tnsec_high = (nano_seconds >> 16) & 0x3fff;\n\n\tlanphy_write_page_reg(phydev, 4, PTP_CLOCK_SET_SEC_LO, sec_low);\n\tlanphy_write_page_reg(phydev, 4, PTP_CLOCK_SET_SEC_MID, sec_high);\n\tlanphy_write_page_reg(phydev, 4, PTP_CLOCK_SET_NS_LO, nsec_low);\n\tlanphy_write_page_reg(phydev, 4, PTP_CLOCK_SET_NS_HI, nsec_high);\n\n\tlanphy_write_page_reg(phydev, 4, PTP_CMD_CTL, PTP_CMD_CTL_PTP_CLOCK_LOAD_);\n}\n\nstatic void lan8814_ptp_clock_get(struct phy_device *phydev,\n\t\t\t\t  u32 *seconds, u32 *nano_seconds)\n{\n\tlanphy_write_page_reg(phydev, 4, PTP_CMD_CTL, PTP_CMD_CTL_PTP_CLOCK_READ_);\n\n\t*seconds = lanphy_read_page_reg(phydev, 4, PTP_CLOCK_READ_SEC_MID);\n\t*seconds = (*seconds << 16) |\n\t\t   lanphy_read_page_reg(phydev, 4, PTP_CLOCK_READ_SEC_LO);\n\n\t*nano_seconds = lanphy_read_page_reg(phydev, 4, PTP_CLOCK_READ_NS_HI);\n\t*nano_seconds = ((*nano_seconds & 0x3fff) << 16) |\n\t\t\tlanphy_read_page_reg(phydev, 4, PTP_CLOCK_READ_NS_LO);\n}\n\nstatic int lan8814_ptpci_gettime64(struct ptp_clock_info *ptpci,\n\t\t\t\t   struct timespec64 *ts)\n{\n\tstruct lan8814_shared_priv *shared = container_of(ptpci, struct lan8814_shared_priv,\n\t\t\t\t\t\t\t  ptp_clock_info);\n\tstruct phy_device *phydev = shared->phydev;\n\tu32 nano_seconds;\n\tu32 seconds;\n\n\tmutex_lock(&shared->shared_lock);\n\tlan8814_ptp_clock_get(phydev, &seconds, &nano_seconds);\n\tmutex_unlock(&shared->shared_lock);\n\tts->tv_sec = seconds;\n\tts->tv_nsec = nano_seconds;\n\n\treturn 0;\n}\n\nstatic int lan8814_ptpci_settime64(struct ptp_clock_info *ptpci,\n\t\t\t\t   const struct timespec64 *ts)\n{\n\tstruct lan8814_shared_priv *shared = container_of(ptpci, struct lan8814_shared_priv,\n\t\t\t\t\t\t\t  ptp_clock_info);\n\tstruct phy_device *phydev = shared->phydev;\n\n\tmutex_lock(&shared->shared_lock);\n\tlan8814_ptp_clock_set(phydev, ts->tv_sec, ts->tv_nsec);\n\tmutex_unlock(&shared->shared_lock);\n\n\treturn 0;\n}\n\nstatic void lan8814_ptp_clock_step(struct phy_device *phydev,\n\t\t\t\t   s64 time_step_ns)\n{\n\tu32 nano_seconds_step;\n\tu64 abs_time_step_ns;\n\tu32 unsigned_seconds;\n\tu32 nano_seconds;\n\tu32 remainder;\n\ts32 seconds;\n\n\tif (time_step_ns >  15000000000LL) {\n\t\t \n\t\tlan8814_ptp_clock_get(phydev, &unsigned_seconds, &nano_seconds);\n\t\tunsigned_seconds += div_u64_rem(time_step_ns, 1000000000LL,\n\t\t\t\t\t\t&remainder);\n\t\tnano_seconds += remainder;\n\t\tif (nano_seconds >= 1000000000) {\n\t\t\tunsigned_seconds++;\n\t\t\tnano_seconds -= 1000000000;\n\t\t}\n\t\tlan8814_ptp_clock_set(phydev, unsigned_seconds, nano_seconds);\n\t\treturn;\n\t} else if (time_step_ns < -15000000000LL) {\n\t\t \n\t\ttime_step_ns = -time_step_ns;\n\n\t\tlan8814_ptp_clock_get(phydev, &unsigned_seconds, &nano_seconds);\n\t\tunsigned_seconds -= div_u64_rem(time_step_ns, 1000000000LL,\n\t\t\t\t\t\t&remainder);\n\t\tnano_seconds_step = remainder;\n\t\tif (nano_seconds < nano_seconds_step) {\n\t\t\tunsigned_seconds--;\n\t\t\tnano_seconds += 1000000000;\n\t\t}\n\t\tnano_seconds -= nano_seconds_step;\n\t\tlan8814_ptp_clock_set(phydev, unsigned_seconds,\n\t\t\t\t      nano_seconds);\n\t\treturn;\n\t}\n\n\t \n\tif (time_step_ns >= 0) {\n\t\tabs_time_step_ns = (u64)time_step_ns;\n\t\tseconds = (s32)div_u64_rem(abs_time_step_ns, 1000000000,\n\t\t\t\t\t   &remainder);\n\t\tnano_seconds = remainder;\n\t} else {\n\t\tabs_time_step_ns = (u64)(-time_step_ns);\n\t\tseconds = -((s32)div_u64_rem(abs_time_step_ns, 1000000000,\n\t\t\t    &remainder));\n\t\tnano_seconds = remainder;\n\t\tif (nano_seconds > 0) {\n\t\t\t \n\t\t\tseconds--;\n\t\t\tnano_seconds = (1000000000 - nano_seconds);\n\t\t}\n\t}\n\n\tif (nano_seconds > 0) {\n\t\t \n\t\tnano_seconds += 8;\n\t}\n\n\tif (nano_seconds >= 1000000000) {\n\t\t \n\t\tseconds++;\n\t\tnano_seconds -= 1000000000;\n\t}\n\n\twhile (seconds) {\n\t\tif (seconds > 0) {\n\t\t\tu32 adjustment_value = (u32)seconds;\n\t\t\tu16 adjustment_value_lo, adjustment_value_hi;\n\n\t\t\tif (adjustment_value > 0xF)\n\t\t\t\tadjustment_value = 0xF;\n\n\t\t\tadjustment_value_lo = adjustment_value & 0xffff;\n\t\t\tadjustment_value_hi = (adjustment_value >> 16) & 0x3fff;\n\n\t\t\tlanphy_write_page_reg(phydev, 4, PTP_LTC_STEP_ADJ_LO,\n\t\t\t\t\t      adjustment_value_lo);\n\t\t\tlanphy_write_page_reg(phydev, 4, PTP_LTC_STEP_ADJ_HI,\n\t\t\t\t\t      PTP_LTC_STEP_ADJ_DIR_ |\n\t\t\t\t\t      adjustment_value_hi);\n\t\t\tseconds -= ((s32)adjustment_value);\n\t\t} else {\n\t\t\tu32 adjustment_value = (u32)(-seconds);\n\t\t\tu16 adjustment_value_lo, adjustment_value_hi;\n\n\t\t\tif (adjustment_value > 0xF)\n\t\t\t\tadjustment_value = 0xF;\n\n\t\t\tadjustment_value_lo = adjustment_value & 0xffff;\n\t\t\tadjustment_value_hi = (adjustment_value >> 16) & 0x3fff;\n\n\t\t\tlanphy_write_page_reg(phydev, 4, PTP_LTC_STEP_ADJ_LO,\n\t\t\t\t\t      adjustment_value_lo);\n\t\t\tlanphy_write_page_reg(phydev, 4, PTP_LTC_STEP_ADJ_HI,\n\t\t\t\t\t      adjustment_value_hi);\n\t\t\tseconds += ((s32)adjustment_value);\n\t\t}\n\t\tlanphy_write_page_reg(phydev, 4, PTP_CMD_CTL,\n\t\t\t\t      PTP_CMD_CTL_PTP_LTC_STEP_SEC_);\n\t}\n\tif (nano_seconds) {\n\t\tu16 nano_seconds_lo;\n\t\tu16 nano_seconds_hi;\n\n\t\tnano_seconds_lo = nano_seconds & 0xffff;\n\t\tnano_seconds_hi = (nano_seconds >> 16) & 0x3fff;\n\n\t\tlanphy_write_page_reg(phydev, 4, PTP_LTC_STEP_ADJ_LO,\n\t\t\t\t      nano_seconds_lo);\n\t\tlanphy_write_page_reg(phydev, 4, PTP_LTC_STEP_ADJ_HI,\n\t\t\t\t      PTP_LTC_STEP_ADJ_DIR_ |\n\t\t\t\t      nano_seconds_hi);\n\t\tlanphy_write_page_reg(phydev, 4, PTP_CMD_CTL,\n\t\t\t\t      PTP_CMD_CTL_PTP_LTC_STEP_NSEC_);\n\t}\n}\n\nstatic int lan8814_ptpci_adjtime(struct ptp_clock_info *ptpci, s64 delta)\n{\n\tstruct lan8814_shared_priv *shared = container_of(ptpci, struct lan8814_shared_priv,\n\t\t\t\t\t\t\t  ptp_clock_info);\n\tstruct phy_device *phydev = shared->phydev;\n\n\tmutex_lock(&shared->shared_lock);\n\tlan8814_ptp_clock_step(phydev, delta);\n\tmutex_unlock(&shared->shared_lock);\n\n\treturn 0;\n}\n\nstatic int lan8814_ptpci_adjfine(struct ptp_clock_info *ptpci, long scaled_ppm)\n{\n\tstruct lan8814_shared_priv *shared = container_of(ptpci, struct lan8814_shared_priv,\n\t\t\t\t\t\t\t  ptp_clock_info);\n\tstruct phy_device *phydev = shared->phydev;\n\tu16 kszphy_rate_adj_lo, kszphy_rate_adj_hi;\n\tbool positive = true;\n\tu32 kszphy_rate_adj;\n\n\tif (scaled_ppm < 0) {\n\t\tscaled_ppm = -scaled_ppm;\n\t\tpositive = false;\n\t}\n\n\tkszphy_rate_adj = LAN8814_1PPM_FORMAT * (scaled_ppm >> 16);\n\tkszphy_rate_adj += (LAN8814_1PPM_FORMAT * (0xffff & scaled_ppm)) >> 16;\n\n\tkszphy_rate_adj_lo = kszphy_rate_adj & 0xffff;\n\tkszphy_rate_adj_hi = (kszphy_rate_adj >> 16) & 0x3fff;\n\n\tif (positive)\n\t\tkszphy_rate_adj_hi |= PTP_CLOCK_RATE_ADJ_DIR_;\n\n\tmutex_lock(&shared->shared_lock);\n\tlanphy_write_page_reg(phydev, 4, PTP_CLOCK_RATE_ADJ_HI, kszphy_rate_adj_hi);\n\tlanphy_write_page_reg(phydev, 4, PTP_CLOCK_RATE_ADJ_LO, kszphy_rate_adj_lo);\n\tmutex_unlock(&shared->shared_lock);\n\n\treturn 0;\n}\n\nstatic void lan8814_get_sig_tx(struct sk_buff *skb, u16 *sig)\n{\n\tstruct ptp_header *ptp_header;\n\tu32 type;\n\n\ttype = ptp_classify_raw(skb);\n\tptp_header = ptp_parse_header(skb, type);\n\n\t*sig = (__force u16)(ntohs(ptp_header->sequence_id));\n}\n\nstatic void lan8814_match_tx_skb(struct kszphy_ptp_priv *ptp_priv,\n\t\t\t\t u32 seconds, u32 nsec, u16 seq_id)\n{\n\tstruct skb_shared_hwtstamps shhwtstamps;\n\tstruct sk_buff *skb, *skb_tmp;\n\tunsigned long flags;\n\tbool ret = false;\n\tu16 skb_sig;\n\n\tspin_lock_irqsave(&ptp_priv->tx_queue.lock, flags);\n\tskb_queue_walk_safe(&ptp_priv->tx_queue, skb, skb_tmp) {\n\t\tlan8814_get_sig_tx(skb, &skb_sig);\n\n\t\tif (memcmp(&skb_sig, &seq_id, sizeof(seq_id)))\n\t\t\tcontinue;\n\n\t\t__skb_unlink(skb, &ptp_priv->tx_queue);\n\t\tret = true;\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&ptp_priv->tx_queue.lock, flags);\n\n\tif (ret) {\n\t\tmemset(&shhwtstamps, 0, sizeof(shhwtstamps));\n\t\tshhwtstamps.hwtstamp = ktime_set(seconds, nsec);\n\t\tskb_complete_tx_timestamp(skb, &shhwtstamps);\n\t}\n}\n\nstatic void lan8814_dequeue_tx_skb(struct kszphy_ptp_priv *ptp_priv)\n{\n\tstruct phy_device *phydev = ptp_priv->phydev;\n\tu32 seconds, nsec;\n\tu16 seq_id;\n\n\tlan8814_ptp_tx_ts_get(phydev, &seconds, &nsec, &seq_id);\n\tlan8814_match_tx_skb(ptp_priv, seconds, nsec, seq_id);\n}\n\nstatic void lan8814_get_tx_ts(struct kszphy_ptp_priv *ptp_priv)\n{\n\tstruct phy_device *phydev = ptp_priv->phydev;\n\tu32 reg;\n\n\tdo {\n\t\tlan8814_dequeue_tx_skb(ptp_priv);\n\n\t\t \n\t\treg = lanphy_read_page_reg(phydev, 5, PTP_CAP_INFO);\n\t} while (PTP_CAP_INFO_TX_TS_CNT_GET_(reg) > 0);\n}\n\nstatic bool lan8814_match_skb(struct kszphy_ptp_priv *ptp_priv,\n\t\t\t      struct lan8814_ptp_rx_ts *rx_ts)\n{\n\tstruct skb_shared_hwtstamps *shhwtstamps;\n\tstruct sk_buff *skb, *skb_tmp;\n\tunsigned long flags;\n\tbool ret = false;\n\tu16 skb_sig;\n\n\tspin_lock_irqsave(&ptp_priv->rx_queue.lock, flags);\n\tskb_queue_walk_safe(&ptp_priv->rx_queue, skb, skb_tmp) {\n\t\tlan8814_get_sig_rx(skb, &skb_sig);\n\n\t\tif (memcmp(&skb_sig, &rx_ts->seq_id, sizeof(rx_ts->seq_id)))\n\t\t\tcontinue;\n\n\t\t__skb_unlink(skb, &ptp_priv->rx_queue);\n\n\t\tret = true;\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&ptp_priv->rx_queue.lock, flags);\n\n\tif (ret) {\n\t\tshhwtstamps = skb_hwtstamps(skb);\n\t\tmemset(shhwtstamps, 0, sizeof(*shhwtstamps));\n\t\tshhwtstamps->hwtstamp = ktime_set(rx_ts->seconds, rx_ts->nsec);\n\t\tnetif_rx(skb);\n\t}\n\n\treturn ret;\n}\n\nstatic void lan8814_match_rx_ts(struct kszphy_ptp_priv *ptp_priv,\n\t\t\t\tstruct lan8814_ptp_rx_ts *rx_ts)\n{\n\tunsigned long flags;\n\n\t \n\tif (!lan8814_match_skb(ptp_priv, rx_ts)) {\n\t\tspin_lock_irqsave(&ptp_priv->rx_ts_lock, flags);\n\t\tlist_add(&rx_ts->list, &ptp_priv->rx_ts_list);\n\t\tspin_unlock_irqrestore(&ptp_priv->rx_ts_lock, flags);\n\t} else {\n\t\tkfree(rx_ts);\n\t}\n}\n\nstatic void lan8814_get_rx_ts(struct kszphy_ptp_priv *ptp_priv)\n{\n\tstruct phy_device *phydev = ptp_priv->phydev;\n\tstruct lan8814_ptp_rx_ts *rx_ts;\n\tu32 reg;\n\n\tdo {\n\t\trx_ts = kzalloc(sizeof(*rx_ts), GFP_KERNEL);\n\t\tif (!rx_ts)\n\t\t\treturn;\n\n\t\tlan8814_ptp_rx_ts_get(phydev, &rx_ts->seconds, &rx_ts->nsec,\n\t\t\t\t      &rx_ts->seq_id);\n\t\tlan8814_match_rx_ts(ptp_priv, rx_ts);\n\n\t\t \n\t\treg = lanphy_read_page_reg(phydev, 5, PTP_CAP_INFO);\n\t} while (PTP_CAP_INFO_RX_TS_CNT_GET_(reg) > 0);\n}\n\nstatic void lan8814_handle_ptp_interrupt(struct phy_device *phydev, u16 status)\n{\n\tstruct kszphy_priv *priv = phydev->priv;\n\tstruct kszphy_ptp_priv *ptp_priv = &priv->ptp_priv;\n\n\tif (status & PTP_TSU_INT_STS_PTP_TX_TS_EN_)\n\t\tlan8814_get_tx_ts(ptp_priv);\n\n\tif (status & PTP_TSU_INT_STS_PTP_RX_TS_EN_)\n\t\tlan8814_get_rx_ts(ptp_priv);\n\n\tif (status & PTP_TSU_INT_STS_PTP_TX_TS_OVRFL_INT_) {\n\t\tlan8814_flush_fifo(phydev, true);\n\t\tskb_queue_purge(&ptp_priv->tx_queue);\n\t}\n\n\tif (status & PTP_TSU_INT_STS_PTP_RX_TS_OVRFL_INT_) {\n\t\tlan8814_flush_fifo(phydev, false);\n\t\tskb_queue_purge(&ptp_priv->rx_queue);\n\t}\n}\n\nstatic int lan8804_config_init(struct phy_device *phydev)\n{\n\tint val;\n\n\t \n\tval = lanphy_read_page_reg(phydev, 2, LAN8804_ALIGN_SWAP);\n\tval &= ~LAN8804_ALIGN_TX_A_B_SWAP_MASK;\n\tval |= LAN8804_ALIGN_TX_A_B_SWAP;\n\tlanphy_write_page_reg(phydev, 2, LAN8804_ALIGN_SWAP, val);\n\n\t \n\tlanphy_write_page_reg(phydev, 31, LAN8814_CLOCK_MANAGEMENT, 0x27e);\n\tlanphy_read_page_reg(phydev, 1, LAN8814_LINK_QUALITY);\n\n\treturn 0;\n}\n\nstatic irqreturn_t lan8804_handle_interrupt(struct phy_device *phydev)\n{\n\tint status;\n\n\tstatus = phy_read(phydev, LAN8814_INTS);\n\tif (status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (status > 0)\n\t\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\n\n#define LAN8804_OUTPUT_CONTROL\t\t\t25\n#define LAN8804_OUTPUT_CONTROL_INTR_BUFFER\tBIT(14)\n#define LAN8804_CONTROL\t\t\t\t31\n#define LAN8804_CONTROL_INTR_POLARITY\t\tBIT(14)\n\nstatic int lan8804_config_intr(struct phy_device *phydev)\n{\n\tint err;\n\n\t \n\tphy_write(phydev, LAN8804_CONTROL, LAN8804_CONTROL_INTR_POLARITY);\n\n\t \n\tphy_write(phydev, LAN8804_OUTPUT_CONTROL,\n\t\t  LAN8804_OUTPUT_CONTROL_INTR_BUFFER);\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\terr = phy_read(phydev, LAN8814_INTS);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = phy_write(phydev, LAN8814_INTC, LAN8814_INT_LINK);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\terr = phy_write(phydev, LAN8814_INTC, 0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = phy_read(phydev, LAN8814_INTS);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t lan8814_handle_interrupt(struct phy_device *phydev)\n{\n\tint ret = IRQ_NONE;\n\tint irq_status;\n\n\tirq_status = phy_read(phydev, LAN8814_INTS);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (irq_status & LAN8814_INT_LINK) {\n\t\tphy_trigger_machine(phydev);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\twhile (true) {\n\t\tirq_status = lanphy_read_page_reg(phydev, 5, PTP_TSU_INT_STS);\n\t\tif (!irq_status)\n\t\t\tbreak;\n\n\t\tlan8814_handle_ptp_interrupt(phydev, irq_status);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\nstatic int lan8814_ack_interrupt(struct phy_device *phydev)\n{\n\t \n\tint rc;\n\n\trc = phy_read(phydev, LAN8814_INTS);\n\n\treturn (rc < 0) ? rc : 0;\n}\n\nstatic int lan8814_config_intr(struct phy_device *phydev)\n{\n\tint err;\n\n\tlanphy_write_page_reg(phydev, 4, LAN8814_INTR_CTRL_REG,\n\t\t\t      LAN8814_INTR_CTRL_REG_POLARITY |\n\t\t\t      LAN8814_INTR_CTRL_REG_INTR_ENABLE);\n\n\t \n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\terr = lan8814_ack_interrupt(phydev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = phy_write(phydev, LAN8814_INTC, LAN8814_INT_LINK);\n\t} else {\n\t\terr = phy_write(phydev, LAN8814_INTC, 0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = lan8814_ack_interrupt(phydev);\n\t}\n\n\treturn err;\n}\n\nstatic void lan8814_ptp_init(struct phy_device *phydev)\n{\n\tstruct kszphy_priv *priv = phydev->priv;\n\tstruct kszphy_ptp_priv *ptp_priv = &priv->ptp_priv;\n\tu32 temp;\n\n\tif (!IS_ENABLED(CONFIG_PTP_1588_CLOCK) ||\n\t    !IS_ENABLED(CONFIG_NETWORK_PHY_TIMESTAMPING))\n\t\treturn;\n\n\tlanphy_write_page_reg(phydev, 5, TSU_HARD_RESET, TSU_HARD_RESET_);\n\n\ttemp = lanphy_read_page_reg(phydev, 5, PTP_TX_MOD);\n\ttemp |= PTP_TX_MOD_BAD_UDPV4_CHKSUM_FORCE_FCS_DIS_;\n\tlanphy_write_page_reg(phydev, 5, PTP_TX_MOD, temp);\n\n\ttemp = lanphy_read_page_reg(phydev, 5, PTP_RX_MOD);\n\ttemp |= PTP_RX_MOD_BAD_UDPV4_CHKSUM_FORCE_FCS_DIS_;\n\tlanphy_write_page_reg(phydev, 5, PTP_RX_MOD, temp);\n\n\tlanphy_write_page_reg(phydev, 5, PTP_RX_PARSE_CONFIG, 0);\n\tlanphy_write_page_reg(phydev, 5, PTP_TX_PARSE_CONFIG, 0);\n\n\t \n\tlanphy_write_page_reg(phydev, 5, PTP_TX_PARSE_L2_ADDR_EN, 0);\n\tlanphy_write_page_reg(phydev, 5, PTP_RX_PARSE_L2_ADDR_EN, 0);\n\tlanphy_write_page_reg(phydev, 5, PTP_TX_PARSE_IP_ADDR_EN, 0);\n\tlanphy_write_page_reg(phydev, 5, PTP_RX_PARSE_IP_ADDR_EN, 0);\n\n\tskb_queue_head_init(&ptp_priv->tx_queue);\n\tskb_queue_head_init(&ptp_priv->rx_queue);\n\tINIT_LIST_HEAD(&ptp_priv->rx_ts_list);\n\tspin_lock_init(&ptp_priv->rx_ts_lock);\n\n\tptp_priv->phydev = phydev;\n\n\tptp_priv->mii_ts.rxtstamp = lan8814_rxtstamp;\n\tptp_priv->mii_ts.txtstamp = lan8814_txtstamp;\n\tptp_priv->mii_ts.hwtstamp = lan8814_hwtstamp;\n\tptp_priv->mii_ts.ts_info  = lan8814_ts_info;\n\n\tphydev->mii_ts = &ptp_priv->mii_ts;\n}\n\nstatic int lan8814_ptp_probe_once(struct phy_device *phydev)\n{\n\tstruct lan8814_shared_priv *shared = phydev->shared->priv;\n\n\t \n\tmutex_init(&shared->shared_lock);\n\n\tshared->ptp_clock_info.owner = THIS_MODULE;\n\tsnprintf(shared->ptp_clock_info.name, 30, \"%s\", phydev->drv->name);\n\tshared->ptp_clock_info.max_adj = 31249999;\n\tshared->ptp_clock_info.n_alarm = 0;\n\tshared->ptp_clock_info.n_ext_ts = 0;\n\tshared->ptp_clock_info.n_pins = 0;\n\tshared->ptp_clock_info.pps = 0;\n\tshared->ptp_clock_info.pin_config = NULL;\n\tshared->ptp_clock_info.adjfine = lan8814_ptpci_adjfine;\n\tshared->ptp_clock_info.adjtime = lan8814_ptpci_adjtime;\n\tshared->ptp_clock_info.gettime64 = lan8814_ptpci_gettime64;\n\tshared->ptp_clock_info.settime64 = lan8814_ptpci_settime64;\n\tshared->ptp_clock_info.getcrosststamp = NULL;\n\n\tshared->ptp_clock = ptp_clock_register(&shared->ptp_clock_info,\n\t\t\t\t\t       &phydev->mdio.dev);\n\tif (IS_ERR(shared->ptp_clock)) {\n\t\tphydev_err(phydev, \"ptp_clock_register failed %lu\\n\",\n\t\t\t   PTR_ERR(shared->ptp_clock));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!shared->ptp_clock)\n\t\treturn 0;\n\n\tphydev_dbg(phydev, \"successfully registered ptp clock\\n\");\n\n\tshared->phydev = phydev;\n\n\t \n\tlanphy_write_page_reg(phydev, 4, LTC_HARD_RESET, LTC_HARD_RESET_);\n\tlanphy_write_page_reg(phydev, 4, PTP_OPERATING_MODE,\n\t\t\t      PTP_OPERATING_MODE_STANDALONE_);\n\n\treturn 0;\n}\n\nstatic void lan8814_setup_led(struct phy_device *phydev, int val)\n{\n\tint temp;\n\n\ttemp = lanphy_read_page_reg(phydev, 5, LAN8814_LED_CTRL_1);\n\n\tif (val)\n\t\ttemp |= LAN8814_LED_CTRL_1_KSZ9031_LED_MODE_;\n\telse\n\t\ttemp &= ~LAN8814_LED_CTRL_1_KSZ9031_LED_MODE_;\n\n\tlanphy_write_page_reg(phydev, 5, LAN8814_LED_CTRL_1, temp);\n}\n\nstatic int lan8814_config_init(struct phy_device *phydev)\n{\n\tstruct kszphy_priv *lan8814 = phydev->priv;\n\tint val;\n\n\t \n\tval = lanphy_read_page_reg(phydev, 4, LAN8814_QSGMII_SOFT_RESET);\n\tval |= LAN8814_QSGMII_SOFT_RESET_BIT;\n\tlanphy_write_page_reg(phydev, 4, LAN8814_QSGMII_SOFT_RESET, val);\n\n\t \n\tval = lanphy_read_page_reg(phydev, 5, LAN8814_QSGMII_PCS1G_ANEG_CONFIG);\n\tval &= ~LAN8814_QSGMII_PCS1G_ANEG_CONFIG_ANEG_ENA;\n\tlanphy_write_page_reg(phydev, 5, LAN8814_QSGMII_PCS1G_ANEG_CONFIG, val);\n\n\t \n\tval = lanphy_read_page_reg(phydev, 2, LAN8814_ALIGN_SWAP);\n\tval &= ~LAN8814_ALIGN_TX_A_B_SWAP_MASK;\n\tval |= LAN8814_ALIGN_TX_A_B_SWAP;\n\tlanphy_write_page_reg(phydev, 2, LAN8814_ALIGN_SWAP, val);\n\n\tif (lan8814->led_mode >= 0)\n\t\tlan8814_setup_led(phydev, lan8814->led_mode);\n\n\treturn 0;\n}\n\n \nstatic int lan8814_release_coma_mode(struct phy_device *phydev)\n{\n\tstruct gpio_desc *gpiod;\n\n\tgpiod = devm_gpiod_get_optional(&phydev->mdio.dev, \"coma-mode\",\n\t\t\t\t\tGPIOD_OUT_HIGH_OPEN_DRAIN |\n\t\t\t\t\tGPIOD_FLAGS_BIT_NONEXCLUSIVE);\n\tif (IS_ERR(gpiod))\n\t\treturn PTR_ERR(gpiod);\n\n\tgpiod_set_consumer_name(gpiod, \"LAN8814 coma mode\");\n\tgpiod_set_value_cansleep(gpiod, 0);\n\n\treturn 0;\n}\n\nstatic int lan8814_probe(struct phy_device *phydev)\n{\n\tconst struct kszphy_type *type = phydev->drv->driver_data;\n\tstruct kszphy_priv *priv;\n\tu16 addr;\n\tint err;\n\n\tpriv = devm_kzalloc(&phydev->mdio.dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tphydev->priv = priv;\n\n\tpriv->type = type;\n\n\tkszphy_parse_led_mode(phydev);\n\n\t \n\taddr = lanphy_read_page_reg(phydev, 4, 0) & 0x1F;\n\tdevm_phy_package_join(&phydev->mdio.dev, phydev,\n\t\t\t      addr, sizeof(struct lan8814_shared_priv));\n\n\tif (phy_package_init_once(phydev)) {\n\t\terr = lan8814_release_coma_mode(phydev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = lan8814_ptp_probe_once(phydev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tlan8814_ptp_init(phydev);\n\n\treturn 0;\n}\n\n#define LAN8841_MMD_TIMER_REG\t\t\t0\n#define LAN8841_MMD0_REGISTER_17\t\t17\n#define LAN8841_MMD0_REGISTER_17_DROP_OPT(x)\t((x) & 0x3)\n#define LAN8841_MMD0_REGISTER_17_XMIT_TOG_TX_DIS\tBIT(3)\n#define LAN8841_OPERATION_MODE_STRAP_OVERRIDE_LOW_REG\t2\n#define LAN8841_OPERATION_MODE_STRAP_OVERRIDE_LOW_REG_MAGJACK\tBIT(14)\n#define LAN8841_MMD_ANALOG_REG\t\t\t28\n#define LAN8841_ANALOG_CONTROL_1\t\t1\n#define LAN8841_ANALOG_CONTROL_1_PLL_TRIM(x)\t(((x) & 0x3) << 5)\n#define LAN8841_ANALOG_CONTROL_10\t\t13\n#define LAN8841_ANALOG_CONTROL_10_PLL_DIV(x)\t((x) & 0x3)\n#define LAN8841_ANALOG_CONTROL_11\t\t14\n#define LAN8841_ANALOG_CONTROL_11_LDO_REF(x)\t(((x) & 0x7) << 12)\n#define LAN8841_TX_LOW_I_CH_C_D_POWER_MANAGMENT\t69\n#define LAN8841_TX_LOW_I_CH_C_D_POWER_MANAGMENT_VAL 0xbffc\n#define LAN8841_BTRX_POWER_DOWN\t\t\t70\n#define LAN8841_BTRX_POWER_DOWN_QBIAS_CH_A\tBIT(0)\n#define LAN8841_BTRX_POWER_DOWN_BTRX_CH_A\tBIT(1)\n#define LAN8841_BTRX_POWER_DOWN_QBIAS_CH_B\tBIT(2)\n#define LAN8841_BTRX_POWER_DOWN_BTRX_CH_B\tBIT(3)\n#define LAN8841_BTRX_POWER_DOWN_BTRX_CH_C\tBIT(5)\n#define LAN8841_BTRX_POWER_DOWN_BTRX_CH_D\tBIT(7)\n#define LAN8841_ADC_CHANNEL_MASK\t\t198\n#define LAN8841_PTP_RX_PARSE_L2_ADDR_EN\t\t370\n#define LAN8841_PTP_RX_PARSE_IP_ADDR_EN\t\t371\n#define LAN8841_PTP_RX_VERSION\t\t\t374\n#define LAN8841_PTP_TX_PARSE_L2_ADDR_EN\t\t434\n#define LAN8841_PTP_TX_PARSE_IP_ADDR_EN\t\t435\n#define LAN8841_PTP_TX_VERSION\t\t\t438\n#define LAN8841_PTP_CMD_CTL\t\t\t256\n#define LAN8841_PTP_CMD_CTL_PTP_ENABLE\t\tBIT(2)\n#define LAN8841_PTP_CMD_CTL_PTP_DISABLE\t\tBIT(1)\n#define LAN8841_PTP_CMD_CTL_PTP_RESET\t\tBIT(0)\n#define LAN8841_PTP_RX_PARSE_CONFIG\t\t368\n#define LAN8841_PTP_TX_PARSE_CONFIG\t\t432\n#define LAN8841_PTP_RX_MODE\t\t\t381\n#define LAN8841_PTP_INSERT_TS_EN\t\tBIT(0)\n#define LAN8841_PTP_INSERT_TS_32BIT\t\tBIT(1)\n\nstatic int lan8841_config_init(struct phy_device *phydev)\n{\n\tint ret;\n\n\tret = ksz9131_config_init(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tphy_modify_mmd(phydev, KSZ9131RN_MMD_COMMON_CTRL_REG,\n\t\t       LAN8841_PTP_CMD_CTL,\n\t\t       LAN8841_PTP_CMD_CTL_PTP_RESET,\n\t\t       LAN8841_PTP_CMD_CTL_PTP_RESET);\n\n\tphy_modify_mmd(phydev, KSZ9131RN_MMD_COMMON_CTRL_REG,\n\t\t       LAN8841_PTP_CMD_CTL,\n\t\t       LAN8841_PTP_CMD_CTL_PTP_ENABLE,\n\t\t       LAN8841_PTP_CMD_CTL_PTP_ENABLE);\n\n\t \n\tphy_write_mmd(phydev, KSZ9131RN_MMD_COMMON_CTRL_REG,\n\t\t      LAN8841_PTP_RX_PARSE_CONFIG, 0);\n\tphy_write_mmd(phydev, KSZ9131RN_MMD_COMMON_CTRL_REG,\n\t\t      LAN8841_PTP_TX_PARSE_CONFIG, 0);\n\tphy_write_mmd(phydev, KSZ9131RN_MMD_COMMON_CTRL_REG,\n\t\t      LAN8841_PTP_TX_PARSE_L2_ADDR_EN, 0);\n\tphy_write_mmd(phydev, KSZ9131RN_MMD_COMMON_CTRL_REG,\n\t\t      LAN8841_PTP_RX_PARSE_L2_ADDR_EN, 0);\n\tphy_write_mmd(phydev, KSZ9131RN_MMD_COMMON_CTRL_REG,\n\t\t      LAN8841_PTP_TX_PARSE_IP_ADDR_EN, 0);\n\tphy_write_mmd(phydev, KSZ9131RN_MMD_COMMON_CTRL_REG,\n\t\t      LAN8841_PTP_RX_PARSE_IP_ADDR_EN, 0);\n\n\t \n\tphy_write_mmd(phydev, KSZ9131RN_MMD_COMMON_CTRL_REG,\n\t\t      LAN8841_PTP_RX_VERSION, 0xff00);\n\tphy_write_mmd(phydev, KSZ9131RN_MMD_COMMON_CTRL_REG,\n\t\t      LAN8841_PTP_TX_VERSION, 0xff00);\n\n\t \n\tphy_write_mmd(phydev, LAN8841_MMD_ANALOG_REG,\n\t\t      LAN8841_ANALOG_CONTROL_1,\n\t\t      LAN8841_ANALOG_CONTROL_1_PLL_TRIM(0x2));\n\tphy_write_mmd(phydev, LAN8841_MMD_ANALOG_REG,\n\t\t      LAN8841_ANALOG_CONTROL_10,\n\t\t      LAN8841_ANALOG_CONTROL_10_PLL_DIV(0x1));\n\n\t \n\tret = phy_read_mmd(phydev, KSZ9131RN_MMD_COMMON_CTRL_REG,\n\t\t\t   LAN8841_OPERATION_MODE_STRAP_OVERRIDE_LOW_REG);\n\tif (ret & LAN8841_OPERATION_MODE_STRAP_OVERRIDE_LOW_REG_MAGJACK) {\n\t\tphy_write_mmd(phydev, LAN8841_MMD_ANALOG_REG,\n\t\t\t      LAN8841_TX_LOW_I_CH_C_D_POWER_MANAGMENT,\n\t\t\t      LAN8841_TX_LOW_I_CH_C_D_POWER_MANAGMENT_VAL);\n\t\tphy_write_mmd(phydev, LAN8841_MMD_ANALOG_REG,\n\t\t\t      LAN8841_BTRX_POWER_DOWN,\n\t\t\t      LAN8841_BTRX_POWER_DOWN_QBIAS_CH_A |\n\t\t\t      LAN8841_BTRX_POWER_DOWN_BTRX_CH_A |\n\t\t\t      LAN8841_BTRX_POWER_DOWN_QBIAS_CH_B |\n\t\t\t      LAN8841_BTRX_POWER_DOWN_BTRX_CH_B |\n\t\t\t      LAN8841_BTRX_POWER_DOWN_BTRX_CH_C |\n\t\t\t      LAN8841_BTRX_POWER_DOWN_BTRX_CH_D);\n\t}\n\n\t \n\tphy_write_mmd(phydev, LAN8841_MMD_ANALOG_REG,\n\t\t      LAN8841_ANALOG_CONTROL_11,\n\t\t      LAN8841_ANALOG_CONTROL_11_LDO_REF(1));\n\n\t \n\tphy_write_mmd(phydev, MDIO_MMD_PMAPMD,\n\t\t      LAN8841_ADC_CHANNEL_MASK, 0x0);\n\tphy_write_mmd(phydev, LAN8841_MMD_TIMER_REG,\n\t\t      LAN8841_MMD0_REGISTER_17,\n\t\t      LAN8841_MMD0_REGISTER_17_DROP_OPT(2) |\n\t\t      LAN8841_MMD0_REGISTER_17_XMIT_TOG_TX_DIS);\n\n\treturn 0;\n}\n\n#define LAN8841_OUTPUT_CTRL\t\t\t25\n#define LAN8841_OUTPUT_CTRL_INT_BUFFER\t\tBIT(14)\n#define LAN8841_INT_PTP\t\t\t\tBIT(9)\n\nstatic int lan8841_config_intr(struct phy_device *phydev)\n{\n\tint err;\n\n\tphy_modify(phydev, LAN8841_OUTPUT_CTRL,\n\t\t   LAN8841_OUTPUT_CTRL_INT_BUFFER, 0);\n\n\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n\t\terr = phy_read(phydev, LAN8814_INTS);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\terr = phy_write(phydev, LAN8814_INTC,\n\t\t\t\tLAN8814_INT_LINK | LAN8841_INT_PTP);\n\t} else {\n\t\terr = phy_write(phydev, LAN8814_INTC, 0);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = phy_read(phydev, LAN8814_INTS);\n\t}\n\n\treturn err;\n}\n\n#define LAN8841_PTP_TX_EGRESS_SEC_LO\t\t\t453\n#define LAN8841_PTP_TX_EGRESS_SEC_HI\t\t\t452\n#define LAN8841_PTP_TX_EGRESS_NS_LO\t\t\t451\n#define LAN8841_PTP_TX_EGRESS_NS_HI\t\t\t450\n#define LAN8841_PTP_TX_EGRESS_NSEC_HI_VALID\t\tBIT(15)\n#define LAN8841_PTP_TX_MSG_HEADER2\t\t\t455\n\nstatic bool lan8841_ptp_get_tx_ts(struct kszphy_ptp_priv *ptp_priv,\n\t\t\t\t  u32 *sec, u32 *nsec, u16 *seq)\n{\n\tstruct phy_device *phydev = ptp_priv->phydev;\n\n\t*nsec = phy_read_mmd(phydev, 2, LAN8841_PTP_TX_EGRESS_NS_HI);\n\tif (!(*nsec & LAN8841_PTP_TX_EGRESS_NSEC_HI_VALID))\n\t\treturn false;\n\n\t*nsec = ((*nsec & 0x3fff) << 16);\n\t*nsec = *nsec | phy_read_mmd(phydev, 2, LAN8841_PTP_TX_EGRESS_NS_LO);\n\n\t*sec = phy_read_mmd(phydev, 2, LAN8841_PTP_TX_EGRESS_SEC_HI);\n\t*sec = *sec << 16;\n\t*sec = *sec | phy_read_mmd(phydev, 2, LAN8841_PTP_TX_EGRESS_SEC_LO);\n\n\t*seq = phy_read_mmd(phydev, 2, LAN8841_PTP_TX_MSG_HEADER2);\n\n\treturn true;\n}\n\nstatic void lan8841_ptp_process_tx_ts(struct kszphy_ptp_priv *ptp_priv)\n{\n\tu32 sec, nsec;\n\tu16 seq;\n\n\twhile (lan8841_ptp_get_tx_ts(ptp_priv, &sec, &nsec, &seq))\n\t\tlan8814_match_tx_skb(ptp_priv, sec, nsec, seq);\n}\n\n#define LAN8841_PTP_INT_STS\t\t\t259\n#define LAN8841_PTP_INT_STS_PTP_TX_TS_OVRFL_INT\tBIT(13)\n#define LAN8841_PTP_INT_STS_PTP_TX_TS_INT\tBIT(12)\n#define LAN8841_PTP_INT_STS_PTP_GPIO_CAP_INT\tBIT(2)\n\nstatic void lan8841_ptp_flush_fifo(struct kszphy_ptp_priv *ptp_priv)\n{\n\tstruct phy_device *phydev = ptp_priv->phydev;\n\tint i;\n\n\tfor (i = 0; i < FIFO_SIZE; ++i)\n\t\tphy_read_mmd(phydev, 2, LAN8841_PTP_TX_MSG_HEADER2);\n\n\tphy_read_mmd(phydev, 2, LAN8841_PTP_INT_STS);\n}\n\n#define LAN8841_PTP_GPIO_CAP_STS\t\t\t506\n#define LAN8841_PTP_GPIO_SEL\t\t\t\t327\n#define LAN8841_PTP_GPIO_SEL_GPIO_SEL(gpio)\t\t((gpio) << 8)\n#define LAN8841_PTP_GPIO_RE_LTC_SEC_HI_CAP\t\t498\n#define LAN8841_PTP_GPIO_RE_LTC_SEC_LO_CAP\t\t499\n#define LAN8841_PTP_GPIO_RE_LTC_NS_HI_CAP\t\t500\n#define LAN8841_PTP_GPIO_RE_LTC_NS_LO_CAP\t\t501\n#define LAN8841_PTP_GPIO_FE_LTC_SEC_HI_CAP\t\t502\n#define LAN8841_PTP_GPIO_FE_LTC_SEC_LO_CAP\t\t503\n#define LAN8841_PTP_GPIO_FE_LTC_NS_HI_CAP\t\t504\n#define LAN8841_PTP_GPIO_FE_LTC_NS_LO_CAP\t\t505\n\nstatic void lan8841_gpio_process_cap(struct kszphy_ptp_priv *ptp_priv)\n{\n\tstruct phy_device *phydev = ptp_priv->phydev;\n\tstruct ptp_clock_event ptp_event = {0};\n\tint pin, ret, tmp;\n\ts32 sec, nsec;\n\n\tpin = ptp_find_pin_unlocked(ptp_priv->ptp_clock, PTP_PF_EXTTS, 0);\n\tif (pin == -1)\n\t\treturn;\n\n\ttmp = phy_read_mmd(phydev, 2, LAN8841_PTP_GPIO_CAP_STS);\n\tif (tmp < 0)\n\t\treturn;\n\n\tret = phy_write_mmd(phydev, 2, LAN8841_PTP_GPIO_SEL,\n\t\t\t    LAN8841_PTP_GPIO_SEL_GPIO_SEL(pin));\n\tif (ret)\n\t\treturn;\n\n\tmutex_lock(&ptp_priv->ptp_lock);\n\tif (tmp & BIT(pin)) {\n\t\tsec = phy_read_mmd(phydev, 2, LAN8841_PTP_GPIO_RE_LTC_SEC_HI_CAP);\n\t\tsec <<= 16;\n\t\tsec |= phy_read_mmd(phydev, 2, LAN8841_PTP_GPIO_RE_LTC_SEC_LO_CAP);\n\n\t\tnsec = phy_read_mmd(phydev, 2, LAN8841_PTP_GPIO_RE_LTC_NS_HI_CAP) & 0x3fff;\n\t\tnsec <<= 16;\n\t\tnsec |= phy_read_mmd(phydev, 2, LAN8841_PTP_GPIO_RE_LTC_NS_LO_CAP);\n\t} else {\n\t\tsec = phy_read_mmd(phydev, 2, LAN8841_PTP_GPIO_FE_LTC_SEC_HI_CAP);\n\t\tsec <<= 16;\n\t\tsec |= phy_read_mmd(phydev, 2, LAN8841_PTP_GPIO_FE_LTC_SEC_LO_CAP);\n\n\t\tnsec = phy_read_mmd(phydev, 2, LAN8841_PTP_GPIO_FE_LTC_NS_HI_CAP) & 0x3fff;\n\t\tnsec <<= 16;\n\t\tnsec |= phy_read_mmd(phydev, 2, LAN8841_PTP_GPIO_FE_LTC_NS_LO_CAP);\n\t}\n\tmutex_unlock(&ptp_priv->ptp_lock);\n\tret = phy_write_mmd(phydev, 2, LAN8841_PTP_GPIO_SEL, 0);\n\tif (ret)\n\t\treturn;\n\n\tptp_event.index = 0;\n\tptp_event.timestamp = ktime_set(sec, nsec);\n\tptp_event.type = PTP_CLOCK_EXTTS;\n\tptp_clock_event(ptp_priv->ptp_clock, &ptp_event);\n}\n\nstatic void lan8841_handle_ptp_interrupt(struct phy_device *phydev)\n{\n\tstruct kszphy_priv *priv = phydev->priv;\n\tstruct kszphy_ptp_priv *ptp_priv = &priv->ptp_priv;\n\tu16 status;\n\n\tdo {\n\t\tstatus = phy_read_mmd(phydev, 2, LAN8841_PTP_INT_STS);\n\n\t\tif (status & LAN8841_PTP_INT_STS_PTP_TX_TS_INT)\n\t\t\tlan8841_ptp_process_tx_ts(ptp_priv);\n\n\t\tif (status & LAN8841_PTP_INT_STS_PTP_GPIO_CAP_INT)\n\t\t\tlan8841_gpio_process_cap(ptp_priv);\n\n\t\tif (status & LAN8841_PTP_INT_STS_PTP_TX_TS_OVRFL_INT) {\n\t\t\tlan8841_ptp_flush_fifo(ptp_priv);\n\t\t\tskb_queue_purge(&ptp_priv->tx_queue);\n\t\t}\n\n\t} while (status & (LAN8841_PTP_INT_STS_PTP_TX_TS_INT |\n\t\t\t   LAN8841_PTP_INT_STS_PTP_GPIO_CAP_INT |\n\t\t\t   LAN8841_PTP_INT_STS_PTP_TX_TS_OVRFL_INT));\n}\n\n#define LAN8841_INTS_PTP\t\tBIT(9)\n\nstatic irqreturn_t lan8841_handle_interrupt(struct phy_device *phydev)\n{\n\tirqreturn_t ret = IRQ_NONE;\n\tint irq_status;\n\n\tirq_status = phy_read(phydev, LAN8814_INTS);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (irq_status & LAN8814_INT_LINK) {\n\t\tphy_trigger_machine(phydev);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (irq_status & LAN8841_INTS_PTP) {\n\t\tlan8841_handle_ptp_interrupt(phydev);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\nstatic int lan8841_ts_info(struct mii_timestamper *mii_ts,\n\t\t\t   struct ethtool_ts_info *info)\n{\n\tstruct kszphy_ptp_priv *ptp_priv;\n\n\tptp_priv = container_of(mii_ts, struct kszphy_ptp_priv, mii_ts);\n\n\tinfo->phc_index = ptp_priv->ptp_clock ?\n\t\t\t\tptp_clock_index(ptp_priv->ptp_clock) : -1;\n\tif (info->phc_index == -1) {\n\t\tinfo->so_timestamping |= SOF_TIMESTAMPING_TX_SOFTWARE |\n\t\t\t\t\t SOF_TIMESTAMPING_RX_SOFTWARE |\n\t\t\t\t\t SOF_TIMESTAMPING_SOFTWARE;\n\t\treturn 0;\n\t}\n\n\tinfo->so_timestamping = SOF_TIMESTAMPING_TX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RX_HARDWARE |\n\t\t\t\tSOF_TIMESTAMPING_RAW_HARDWARE;\n\n\tinfo->tx_types = (1 << HWTSTAMP_TX_OFF) |\n\t\t\t (1 << HWTSTAMP_TX_ON) |\n\t\t\t (1 << HWTSTAMP_TX_ONESTEP_SYNC);\n\n\tinfo->rx_filters = (1 << HWTSTAMP_FILTER_NONE) |\n\t\t\t   (1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |\n\t\t\t   (1 << HWTSTAMP_FILTER_PTP_V2_L2_EVENT) |\n\t\t\t   (1 << HWTSTAMP_FILTER_PTP_V2_EVENT);\n\n\treturn 0;\n}\n\n#define LAN8841_PTP_INT_EN\t\t\t260\n#define LAN8841_PTP_INT_EN_PTP_TX_TS_OVRFL_EN\tBIT(13)\n#define LAN8841_PTP_INT_EN_PTP_TX_TS_EN\t\tBIT(12)\n\nstatic void lan8841_ptp_enable_processing(struct kszphy_ptp_priv *ptp_priv,\n\t\t\t\t\t  bool enable)\n{\n\tstruct phy_device *phydev = ptp_priv->phydev;\n\n\tif (enable) {\n\t\t \n\t\tphy_modify_mmd(phydev, 2, LAN8841_PTP_INT_EN,\n\t\t\t       LAN8841_PTP_INT_EN_PTP_TX_TS_OVRFL_EN |\n\t\t\t       LAN8841_PTP_INT_EN_PTP_TX_TS_EN,\n\t\t\t       LAN8841_PTP_INT_EN_PTP_TX_TS_OVRFL_EN |\n\t\t\t       LAN8841_PTP_INT_EN_PTP_TX_TS_EN);\n\n\t\t \n\t\tphy_modify_mmd(phydev, KSZ9131RN_MMD_COMMON_CTRL_REG,\n\t\t\t       LAN8841_PTP_RX_MODE,\n\t\t\t       LAN8841_PTP_INSERT_TS_EN |\n\t\t\t       LAN8841_PTP_INSERT_TS_32BIT,\n\t\t\t       LAN8841_PTP_INSERT_TS_EN |\n\t\t\t       LAN8841_PTP_INSERT_TS_32BIT);\n\n\t\tptp_schedule_worker(ptp_priv->ptp_clock, 0);\n\t} else {\n\t\t \n\t\tphy_modify_mmd(phydev, 2, LAN8841_PTP_INT_EN,\n\t\t\t       LAN8841_PTP_INT_EN_PTP_TX_TS_OVRFL_EN |\n\t\t\t       LAN8841_PTP_INT_EN_PTP_TX_TS_EN, 0);\n\n\t\t \n\t\tphy_modify_mmd(phydev, KSZ9131RN_MMD_COMMON_CTRL_REG,\n\t\t\t       LAN8841_PTP_RX_MODE,\n\t\t\t       LAN8841_PTP_INSERT_TS_EN |\n\t\t\t       LAN8841_PTP_INSERT_TS_32BIT, 0);\n\n\t\tptp_cancel_worker_sync(ptp_priv->ptp_clock);\n\t}\n}\n\n#define LAN8841_PTP_RX_TIMESTAMP_EN\t\t379\n#define LAN8841_PTP_TX_TIMESTAMP_EN\t\t443\n#define LAN8841_PTP_TX_MOD\t\t\t445\n\nstatic int lan8841_hwtstamp(struct mii_timestamper *mii_ts, struct ifreq *ifr)\n{\n\tstruct kszphy_ptp_priv *ptp_priv = container_of(mii_ts, struct kszphy_ptp_priv, mii_ts);\n\tstruct phy_device *phydev = ptp_priv->phydev;\n\tstruct hwtstamp_config config;\n\tint txcfg = 0, rxcfg = 0;\n\tint pkt_ts_enable;\n\n\tif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\n\t\treturn -EFAULT;\n\n\tptp_priv->hwts_tx_type = config.tx_type;\n\tptp_priv->rx_filter = config.rx_filter;\n\n\tswitch (config.rx_filter) {\n\tcase HWTSTAMP_FILTER_NONE:\n\t\tptp_priv->layer = 0;\n\t\tptp_priv->version = 0;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:\n\t\tptp_priv->layer = PTP_CLASS_L4;\n\t\tptp_priv->version = PTP_CLASS_V2;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\n\t\tptp_priv->layer = PTP_CLASS_L2;\n\t\tptp_priv->version = PTP_CLASS_V2;\n\t\tbreak;\n\tcase HWTSTAMP_FILTER_PTP_V2_EVENT:\n\tcase HWTSTAMP_FILTER_PTP_V2_SYNC:\n\tcase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\n\t\tptp_priv->layer = PTP_CLASS_L4 | PTP_CLASS_L2;\n\t\tptp_priv->version = PTP_CLASS_V2;\n\t\tbreak;\n\tdefault:\n\t\treturn -ERANGE;\n\t}\n\n\t \n\tif (ptp_priv->layer & PTP_CLASS_L2) {\n\t\trxcfg |= PTP_RX_PARSE_CONFIG_LAYER2_EN_;\n\t\ttxcfg |= PTP_TX_PARSE_CONFIG_LAYER2_EN_;\n\t} else if (ptp_priv->layer & PTP_CLASS_L4) {\n\t\trxcfg |= PTP_RX_PARSE_CONFIG_IPV4_EN_ | PTP_RX_PARSE_CONFIG_IPV6_EN_;\n\t\ttxcfg |= PTP_TX_PARSE_CONFIG_IPV4_EN_ | PTP_TX_PARSE_CONFIG_IPV6_EN_;\n\t}\n\n\tphy_write_mmd(phydev, 2, LAN8841_PTP_RX_PARSE_CONFIG, rxcfg);\n\tphy_write_mmd(phydev, 2, LAN8841_PTP_TX_PARSE_CONFIG, txcfg);\n\n\tpkt_ts_enable = PTP_TIMESTAMP_EN_SYNC_ | PTP_TIMESTAMP_EN_DREQ_ |\n\t\t\tPTP_TIMESTAMP_EN_PDREQ_ | PTP_TIMESTAMP_EN_PDRES_;\n\tphy_write_mmd(phydev, 2, LAN8841_PTP_RX_TIMESTAMP_EN, pkt_ts_enable);\n\tphy_write_mmd(phydev, 2, LAN8841_PTP_TX_TIMESTAMP_EN, pkt_ts_enable);\n\n\t \n\tphy_modify_mmd(phydev, 2, LAN8841_PTP_TX_MOD,\n\t\t       PTP_TX_MOD_TX_PTP_SYNC_TS_INSERT_,\n\t\t       ptp_priv->hwts_tx_type == HWTSTAMP_TX_ONESTEP_SYNC ?\n\t\t\t\tPTP_TX_MOD_TX_PTP_SYNC_TS_INSERT_ : 0);\n\n\t \n\tlan8841_ptp_enable_processing(ptp_priv,\n\t\t\t\t      config.rx_filter != HWTSTAMP_FILTER_NONE);\n\n\tskb_queue_purge(&ptp_priv->tx_queue);\n\n\tlan8841_ptp_flush_fifo(ptp_priv);\n\n\treturn copy_to_user(ifr->ifr_data, &config, sizeof(config)) ? -EFAULT : 0;\n}\n\nstatic bool lan8841_rxtstamp(struct mii_timestamper *mii_ts,\n\t\t\t     struct sk_buff *skb, int type)\n{\n\tstruct kszphy_ptp_priv *ptp_priv =\n\t\t\tcontainer_of(mii_ts, struct kszphy_ptp_priv, mii_ts);\n\tstruct ptp_header *header = ptp_parse_header(skb, type);\n\tstruct skb_shared_hwtstamps *shhwtstamps;\n\tstruct timespec64 ts;\n\tunsigned long flags;\n\tu32 ts_header;\n\n\tif (!header)\n\t\treturn false;\n\n\tif (ptp_priv->rx_filter == HWTSTAMP_FILTER_NONE ||\n\t    type == PTP_CLASS_NONE)\n\t\treturn false;\n\n\tif ((type & ptp_priv->version) == 0 || (type & ptp_priv->layer) == 0)\n\t\treturn false;\n\n\tspin_lock_irqsave(&ptp_priv->seconds_lock, flags);\n\tts.tv_sec = ptp_priv->seconds;\n\tspin_unlock_irqrestore(&ptp_priv->seconds_lock, flags);\n\tts_header = __be32_to_cpu(header->reserved2);\n\n\tshhwtstamps = skb_hwtstamps(skb);\n\tmemset(shhwtstamps, 0, sizeof(*shhwtstamps));\n\n\t \n\tif ((ts.tv_sec & GENMASK(1, 0)) == 0 && (ts_header >> 30) == 3)\n\t\tts.tv_sec -= GENMASK(1, 0) + 1;\n\telse if ((ts.tv_sec & GENMASK(1, 0)) == 3 && (ts_header >> 30) == 0)\n\t\tts.tv_sec += 1;\n\n\tshhwtstamps->hwtstamp =\n\t\tktime_set((ts.tv_sec & ~(GENMASK(1, 0))) | ts_header >> 30,\n\t\t\t  ts_header & GENMASK(29, 0));\n\theader->reserved2 = 0;\n\n\tnetif_rx(skb);\n\n\treturn true;\n}\n\n#define LAN8841_EVENT_A\t\t0\n#define LAN8841_EVENT_B\t\t1\n#define LAN8841_PTP_LTC_TARGET_SEC_HI(event)\t((event) == LAN8841_EVENT_A ? 278 : 288)\n#define LAN8841_PTP_LTC_TARGET_SEC_LO(event)\t((event) == LAN8841_EVENT_A ? 279 : 289)\n#define LAN8841_PTP_LTC_TARGET_NS_HI(event)\t((event) == LAN8841_EVENT_A ? 280 : 290)\n#define LAN8841_PTP_LTC_TARGET_NS_LO(event)\t((event) == LAN8841_EVENT_A ? 281 : 291)\n\nstatic int lan8841_ptp_set_target(struct kszphy_ptp_priv *ptp_priv, u8 event,\n\t\t\t\t  s64 sec, u32 nsec)\n{\n\tstruct phy_device *phydev = ptp_priv->phydev;\n\tint ret;\n\n\tret = phy_write_mmd(phydev, 2, LAN8841_PTP_LTC_TARGET_SEC_HI(event),\n\t\t\t    upper_16_bits(sec));\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_write_mmd(phydev, 2, LAN8841_PTP_LTC_TARGET_SEC_LO(event),\n\t\t\t    lower_16_bits(sec));\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_write_mmd(phydev, 2, LAN8841_PTP_LTC_TARGET_NS_HI(event) & 0x3fff,\n\t\t\t    upper_16_bits(nsec));\n\tif (ret)\n\t\treturn ret;\n\n\treturn phy_write_mmd(phydev, 2, LAN8841_PTP_LTC_TARGET_NS_LO(event),\n\t\t\t    lower_16_bits(nsec));\n}\n\n#define LAN8841_BUFFER_TIME\t2\n\nstatic int lan8841_ptp_update_target(struct kszphy_ptp_priv *ptp_priv,\n\t\t\t\t     const struct timespec64 *ts)\n{\n\treturn lan8841_ptp_set_target(ptp_priv, LAN8841_EVENT_A,\n\t\t\t\t      ts->tv_sec + LAN8841_BUFFER_TIME, 0);\n}\n\n#define LAN8841_PTP_LTC_TARGET_RELOAD_SEC_HI(event)\t((event) == LAN8841_EVENT_A ? 282 : 292)\n#define LAN8841_PTP_LTC_TARGET_RELOAD_SEC_LO(event)\t((event) == LAN8841_EVENT_A ? 283 : 293)\n#define LAN8841_PTP_LTC_TARGET_RELOAD_NS_HI(event)\t((event) == LAN8841_EVENT_A ? 284 : 294)\n#define LAN8841_PTP_LTC_TARGET_RELOAD_NS_LO(event)\t((event) == LAN8841_EVENT_A ? 285 : 295)\n\nstatic int lan8841_ptp_set_reload(struct kszphy_ptp_priv *ptp_priv, u8 event,\n\t\t\t\t  s64 sec, u32 nsec)\n{\n\tstruct phy_device *phydev = ptp_priv->phydev;\n\tint ret;\n\n\tret = phy_write_mmd(phydev, 2, LAN8841_PTP_LTC_TARGET_RELOAD_SEC_HI(event),\n\t\t\t    upper_16_bits(sec));\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_write_mmd(phydev, 2, LAN8841_PTP_LTC_TARGET_RELOAD_SEC_LO(event),\n\t\t\t    lower_16_bits(sec));\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_write_mmd(phydev, 2, LAN8841_PTP_LTC_TARGET_RELOAD_NS_HI(event) & 0x3fff,\n\t\t\t    upper_16_bits(nsec));\n\tif (ret)\n\t\treturn ret;\n\n\treturn phy_write_mmd(phydev, 2, LAN8841_PTP_LTC_TARGET_RELOAD_NS_LO(event),\n\t\t\t     lower_16_bits(nsec));\n}\n\n#define LAN8841_PTP_LTC_SET_SEC_HI\t262\n#define LAN8841_PTP_LTC_SET_SEC_MID\t263\n#define LAN8841_PTP_LTC_SET_SEC_LO\t264\n#define LAN8841_PTP_LTC_SET_NS_HI\t265\n#define LAN8841_PTP_LTC_SET_NS_LO\t266\n#define LAN8841_PTP_CMD_CTL_PTP_LTC_LOAD\tBIT(4)\n\nstatic int lan8841_ptp_settime64(struct ptp_clock_info *ptp,\n\t\t\t\t const struct timespec64 *ts)\n{\n\tstruct kszphy_ptp_priv *ptp_priv = container_of(ptp, struct kszphy_ptp_priv,\n\t\t\t\t\t\t\tptp_clock_info);\n\tstruct phy_device *phydev = ptp_priv->phydev;\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tmutex_lock(&ptp_priv->ptp_lock);\n\tphy_write_mmd(phydev, 2, LAN8841_PTP_LTC_SET_SEC_LO, lower_16_bits(ts->tv_sec));\n\tphy_write_mmd(phydev, 2, LAN8841_PTP_LTC_SET_SEC_MID, upper_16_bits(ts->tv_sec));\n\tphy_write_mmd(phydev, 2, LAN8841_PTP_LTC_SET_SEC_HI, upper_32_bits(ts->tv_sec) & 0xffff);\n\tphy_write_mmd(phydev, 2, LAN8841_PTP_LTC_SET_NS_LO, lower_16_bits(ts->tv_nsec));\n\tphy_write_mmd(phydev, 2, LAN8841_PTP_LTC_SET_NS_HI, upper_16_bits(ts->tv_nsec) & 0x3fff);\n\n\t \n\tphy_write_mmd(phydev, 2, LAN8841_PTP_CMD_CTL,\n\t\t      LAN8841_PTP_CMD_CTL_PTP_LTC_LOAD);\n\tret = lan8841_ptp_update_target(ptp_priv, ts);\n\tmutex_unlock(&ptp_priv->ptp_lock);\n\n\tspin_lock_irqsave(&ptp_priv->seconds_lock, flags);\n\tptp_priv->seconds = ts->tv_sec;\n\tspin_unlock_irqrestore(&ptp_priv->seconds_lock, flags);\n\n\treturn ret;\n}\n\n#define LAN8841_PTP_LTC_RD_SEC_HI\t358\n#define LAN8841_PTP_LTC_RD_SEC_MID\t359\n#define LAN8841_PTP_LTC_RD_SEC_LO\t360\n#define LAN8841_PTP_LTC_RD_NS_HI\t361\n#define LAN8841_PTP_LTC_RD_NS_LO\t362\n#define LAN8841_PTP_CMD_CTL_PTP_LTC_READ\tBIT(3)\n\nstatic int lan8841_ptp_gettime64(struct ptp_clock_info *ptp,\n\t\t\t\t struct timespec64 *ts)\n{\n\tstruct kszphy_ptp_priv *ptp_priv = container_of(ptp, struct kszphy_ptp_priv,\n\t\t\t\t\t\t\tptp_clock_info);\n\tstruct phy_device *phydev = ptp_priv->phydev;\n\ttime64_t s;\n\ts64 ns;\n\n\tmutex_lock(&ptp_priv->ptp_lock);\n\t \n\tphy_write_mmd(phydev, 2, LAN8841_PTP_CMD_CTL,\n\t\t      LAN8841_PTP_CMD_CTL_PTP_LTC_READ);\n\n\t \n\ts = phy_read_mmd(phydev, 2, LAN8841_PTP_LTC_RD_SEC_HI);\n\ts <<= 16;\n\ts |= phy_read_mmd(phydev, 2, LAN8841_PTP_LTC_RD_SEC_MID);\n\ts <<= 16;\n\ts |= phy_read_mmd(phydev, 2, LAN8841_PTP_LTC_RD_SEC_LO);\n\n\tns = phy_read_mmd(phydev, 2, LAN8841_PTP_LTC_RD_NS_HI) & 0x3fff;\n\tns <<= 16;\n\tns |= phy_read_mmd(phydev, 2, LAN8841_PTP_LTC_RD_NS_LO);\n\tmutex_unlock(&ptp_priv->ptp_lock);\n\n\tset_normalized_timespec64(ts, s, ns);\n\treturn 0;\n}\n\nstatic void lan8841_ptp_getseconds(struct ptp_clock_info *ptp,\n\t\t\t\t   struct timespec64 *ts)\n{\n\tstruct kszphy_ptp_priv *ptp_priv = container_of(ptp, struct kszphy_ptp_priv,\n\t\t\t\t\t\t\tptp_clock_info);\n\tstruct phy_device *phydev = ptp_priv->phydev;\n\ttime64_t s;\n\n\tmutex_lock(&ptp_priv->ptp_lock);\n\t \n\tphy_write_mmd(phydev, 2, LAN8841_PTP_CMD_CTL,\n\t\t      LAN8841_PTP_CMD_CTL_PTP_LTC_READ);\n\n\t \n\ts = phy_read_mmd(phydev, 2, LAN8841_PTP_LTC_RD_SEC_HI);\n\ts <<= 16;\n\ts |= phy_read_mmd(phydev, 2, LAN8841_PTP_LTC_RD_SEC_MID);\n\ts <<= 16;\n\ts |= phy_read_mmd(phydev, 2, LAN8841_PTP_LTC_RD_SEC_LO);\n\tmutex_unlock(&ptp_priv->ptp_lock);\n\n\tset_normalized_timespec64(ts, s, 0);\n}\n\n#define LAN8841_PTP_LTC_STEP_ADJ_LO\t\t\t276\n#define LAN8841_PTP_LTC_STEP_ADJ_HI\t\t\t275\n#define LAN8841_PTP_LTC_STEP_ADJ_DIR\t\t\tBIT(15)\n#define LAN8841_PTP_CMD_CTL_PTP_LTC_STEP_SECONDS\tBIT(5)\n#define LAN8841_PTP_CMD_CTL_PTP_LTC_STEP_NANOSECONDS\tBIT(6)\n\nstatic int lan8841_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\n{\n\tstruct kszphy_ptp_priv *ptp_priv = container_of(ptp, struct kszphy_ptp_priv,\n\t\t\t\t\t\t\tptp_clock_info);\n\tstruct phy_device *phydev = ptp_priv->phydev;\n\tstruct timespec64 ts;\n\tbool add = true;\n\tu32 nsec;\n\ts32 sec;\n\tint ret;\n\n\t \n\tif (delta > 10000000000LL || delta < -10000000000LL) {\n\t\t \n\t\tu64 now;\n\n\t\tptp->gettime64(ptp, &ts);\n\n\t\tnow = ktime_to_ns(timespec64_to_ktime(ts));\n\t\tts = ns_to_timespec64(now + delta);\n\n\t\tptp->settime64(ptp, &ts);\n\t\treturn 0;\n\t}\n\n\tsec = div_u64_rem(delta < 0 ? -delta : delta, NSEC_PER_SEC, &nsec);\n\tif (delta < 0 && nsec != 0) {\n\t\t \n\t\tsec--;\n\t\tnsec = NSEC_PER_SEC - nsec;\n\t}\n\n\t \n\tif (delta < 0)\n\t\tadd = false;\n\n\tif (nsec > 0)\n\t\t \n\t\tnsec += 8;\n\n\tif (nsec >= NSEC_PER_SEC) {\n\t\t \n\t\tsec++;\n\t\tnsec -= NSEC_PER_SEC;\n\t}\n\n\tmutex_lock(&ptp_priv->ptp_lock);\n\tif (sec) {\n\t\tphy_write_mmd(phydev, 2, LAN8841_PTP_LTC_STEP_ADJ_LO, sec);\n\t\tphy_write_mmd(phydev, 2, LAN8841_PTP_LTC_STEP_ADJ_HI,\n\t\t\t      add ? LAN8841_PTP_LTC_STEP_ADJ_DIR : 0);\n\t\tphy_write_mmd(phydev, 2, LAN8841_PTP_CMD_CTL,\n\t\t\t      LAN8841_PTP_CMD_CTL_PTP_LTC_STEP_SECONDS);\n\t}\n\n\tif (nsec) {\n\t\tphy_write_mmd(phydev, 2, LAN8841_PTP_LTC_STEP_ADJ_LO,\n\t\t\t      nsec & 0xffff);\n\t\tphy_write_mmd(phydev, 2, LAN8841_PTP_LTC_STEP_ADJ_HI,\n\t\t\t      (nsec >> 16) & 0x3fff);\n\t\tphy_write_mmd(phydev, 2, LAN8841_PTP_CMD_CTL,\n\t\t\t      LAN8841_PTP_CMD_CTL_PTP_LTC_STEP_NANOSECONDS);\n\t}\n\tmutex_unlock(&ptp_priv->ptp_lock);\n\n\t \n\tptp->gettime64(ptp, &ts);\n\tmutex_lock(&ptp_priv->ptp_lock);\n\tret = lan8841_ptp_update_target(ptp_priv, &ts);\n\tmutex_unlock(&ptp_priv->ptp_lock);\n\n\treturn ret;\n}\n\n#define LAN8841_PTP_LTC_RATE_ADJ_HI\t\t269\n#define LAN8841_PTP_LTC_RATE_ADJ_HI_DIR\t\tBIT(15)\n#define LAN8841_PTP_LTC_RATE_ADJ_LO\t\t270\n\nstatic int lan8841_ptp_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\n{\n\tstruct kszphy_ptp_priv *ptp_priv = container_of(ptp, struct kszphy_ptp_priv,\n\t\t\t\t\t\t\tptp_clock_info);\n\tstruct phy_device *phydev = ptp_priv->phydev;\n\tbool faster = true;\n\tu32 rate;\n\n\tif (!scaled_ppm)\n\t\treturn 0;\n\n\tif (scaled_ppm < 0) {\n\t\tscaled_ppm = -scaled_ppm;\n\t\tfaster = false;\n\t}\n\n\trate = LAN8814_1PPM_FORMAT * (upper_16_bits(scaled_ppm));\n\trate += (LAN8814_1PPM_FORMAT * (lower_16_bits(scaled_ppm))) >> 16;\n\n\tmutex_lock(&ptp_priv->ptp_lock);\n\tphy_write_mmd(phydev, 2, LAN8841_PTP_LTC_RATE_ADJ_HI,\n\t\t      faster ? LAN8841_PTP_LTC_RATE_ADJ_HI_DIR | (upper_16_bits(rate) & 0x3fff)\n\t\t\t     : upper_16_bits(rate) & 0x3fff);\n\tphy_write_mmd(phydev, 2, LAN8841_PTP_LTC_RATE_ADJ_LO, lower_16_bits(rate));\n\tmutex_unlock(&ptp_priv->ptp_lock);\n\n\treturn 0;\n}\n\nstatic int lan8841_ptp_verify(struct ptp_clock_info *ptp, unsigned int pin,\n\t\t\t      enum ptp_pin_function func, unsigned int chan)\n{\n\tswitch (func) {\n\tcase PTP_PF_NONE:\n\tcase PTP_PF_PEROUT:\n\tcase PTP_PF_EXTTS:\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n#define LAN8841_PTP_GPIO_NUM\t10\n#define LAN8841_GPIO_EN\t\t128\n#define LAN8841_GPIO_DIR\t129\n#define LAN8841_GPIO_BUF\t130\n\nstatic int lan8841_ptp_perout_off(struct kszphy_ptp_priv *ptp_priv, int pin)\n{\n\tstruct phy_device *phydev = ptp_priv->phydev;\n\tint ret;\n\n\tret = phy_clear_bits_mmd(phydev, 2, LAN8841_GPIO_EN, BIT(pin));\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_clear_bits_mmd(phydev, 2, LAN8841_GPIO_DIR, BIT(pin));\n\tif (ret)\n\t\treturn ret;\n\n\treturn phy_clear_bits_mmd(phydev, 2, LAN8841_GPIO_BUF, BIT(pin));\n}\n\nstatic int lan8841_ptp_perout_on(struct kszphy_ptp_priv *ptp_priv, int pin)\n{\n\tstruct phy_device *phydev = ptp_priv->phydev;\n\tint ret;\n\n\tret = phy_set_bits_mmd(phydev, 2, LAN8841_GPIO_EN, BIT(pin));\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_set_bits_mmd(phydev, 2, LAN8841_GPIO_DIR, BIT(pin));\n\tif (ret)\n\t\treturn ret;\n\n\treturn phy_set_bits_mmd(phydev, 2, LAN8841_GPIO_BUF, BIT(pin));\n}\n\n#define LAN8841_GPIO_DATA_SEL1\t\t\t\t131\n#define LAN8841_GPIO_DATA_SEL2\t\t\t\t132\n#define LAN8841_GPIO_DATA_SEL_GPIO_DATA_SEL_EVENT_MASK\tGENMASK(2, 0)\n#define LAN8841_GPIO_DATA_SEL_GPIO_DATA_SEL_EVENT_A\t1\n#define LAN8841_GPIO_DATA_SEL_GPIO_DATA_SEL_EVENT_B\t2\n#define LAN8841_PTP_GENERAL_CONFIG\t\t\t257\n#define LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_POL_A\tBIT(1)\n#define LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_POL_B\tBIT(3)\n#define LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_A_MASK\tGENMASK(7, 4)\n#define LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_B_MASK\tGENMASK(11, 8)\n#define LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_A\t\t4\n#define LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_B\t\t7\n\nstatic int lan8841_ptp_remove_event(struct kszphy_ptp_priv *ptp_priv, int pin,\n\t\t\t\t    u8 event)\n{\n\tstruct phy_device *phydev = ptp_priv->phydev;\n\tu16 tmp;\n\tint ret;\n\n\t \n\tif (pin < 5) {\n\t\ttmp = LAN8841_GPIO_DATA_SEL_GPIO_DATA_SEL_EVENT_MASK << (3 * pin);\n\t\tret = phy_clear_bits_mmd(phydev, 2, LAN8841_GPIO_DATA_SEL1, tmp);\n\t} else {\n\t\ttmp = LAN8841_GPIO_DATA_SEL_GPIO_DATA_SEL_EVENT_MASK << (3 * (pin - 5));\n\t\tret = phy_clear_bits_mmd(phydev, 2, LAN8841_GPIO_DATA_SEL2, tmp);\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (event == LAN8841_EVENT_A)\n\t\ttmp = LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_POL_A |\n\t\t      LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_A_MASK;\n\telse\n\t\ttmp = LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_POL_B |\n\t\t      LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_B_MASK;\n\treturn phy_clear_bits_mmd(phydev, 2, LAN8841_GPIO_EN, tmp);\n}\n\nstatic int lan8841_ptp_enable_event(struct kszphy_ptp_priv *ptp_priv, int pin,\n\t\t\t\t    u8 event, int pulse_width)\n{\n\tstruct phy_device *phydev = ptp_priv->phydev;\n\tu16 tmp;\n\tint ret;\n\n\t \n\tif (event == LAN8841_EVENT_A)\n\t\tret = phy_modify_mmd(phydev, 2, LAN8841_PTP_GENERAL_CONFIG,\n\t\t\t\t     LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_POL_A |\n\t\t\t\t     LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_A_MASK,\n\t\t\t\t     LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_POL_A |\n\t\t\t\t     pulse_width << LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_A);\n\telse\n\t\tret = phy_modify_mmd(phydev, 2, LAN8841_PTP_GENERAL_CONFIG,\n\t\t\t\t     LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_POL_B |\n\t\t\t\t     LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_B_MASK,\n\t\t\t\t     LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_POL_B |\n\t\t\t\t     pulse_width << LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_B);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (event == LAN8841_EVENT_A)\n\t\ttmp = LAN8841_GPIO_DATA_SEL_GPIO_DATA_SEL_EVENT_A;\n\telse\n\t\ttmp = LAN8841_GPIO_DATA_SEL_GPIO_DATA_SEL_EVENT_B;\n\n\tif (pin < 5)\n\t\tret = phy_set_bits_mmd(phydev, 2, LAN8841_GPIO_DATA_SEL1,\n\t\t\t\t       tmp << (3 * pin));\n\telse\n\t\tret = phy_set_bits_mmd(phydev, 2, LAN8841_GPIO_DATA_SEL2,\n\t\t\t\t       tmp << (3 * (pin - 5)));\n\n\treturn ret;\n}\n\n#define LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_200MS\t13\n#define LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_100MS\t12\n#define LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_50MS\t11\n#define LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_10MS\t10\n#define LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_5MS\t9\n#define LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_1MS\t8\n#define LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_500US\t7\n#define LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_100US\t6\n#define LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_50US\t5\n#define LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_10US\t4\n#define LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_5US\t3\n#define LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_1US\t2\n#define LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_500NS\t1\n#define LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_100NS\t0\n\nstatic int lan8841_ptp_perout(struct ptp_clock_info *ptp,\n\t\t\t      struct ptp_clock_request *rq, int on)\n{\n\tstruct kszphy_ptp_priv *ptp_priv = container_of(ptp, struct kszphy_ptp_priv,\n\t\t\t\t\t\t\tptp_clock_info);\n\tstruct phy_device *phydev = ptp_priv->phydev;\n\tstruct timespec64 ts_on, ts_period;\n\ts64 on_nsec, period_nsec;\n\tint pulse_width;\n\tint pin;\n\tint ret;\n\n\tif (rq->perout.flags & ~PTP_PEROUT_DUTY_CYCLE)\n\t\treturn -EOPNOTSUPP;\n\n\tpin = ptp_find_pin(ptp_priv->ptp_clock, PTP_PF_PEROUT, rq->perout.index);\n\tif (pin == -1 || pin >= LAN8841_PTP_GPIO_NUM)\n\t\treturn -EINVAL;\n\n\tif (!on) {\n\t\tret = lan8841_ptp_perout_off(ptp_priv, pin);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn lan8841_ptp_remove_event(ptp_priv, LAN8841_EVENT_A, pin);\n\t}\n\n\tts_on.tv_sec = rq->perout.on.sec;\n\tts_on.tv_nsec = rq->perout.on.nsec;\n\ton_nsec = timespec64_to_ns(&ts_on);\n\n\tts_period.tv_sec = rq->perout.period.sec;\n\tts_period.tv_nsec = rq->perout.period.nsec;\n\tperiod_nsec = timespec64_to_ns(&ts_period);\n\n\tif (period_nsec < 200) {\n\t\tpr_warn_ratelimited(\"%s: perout period too small, minimum is 200 nsec\\n\",\n\t\t\t\t    phydev_name(phydev));\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (on_nsec >= period_nsec) {\n\t\tpr_warn_ratelimited(\"%s: pulse width must be smaller than period\\n\",\n\t\t\t\t    phydev_name(phydev));\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (on_nsec) {\n\tcase 200000000:\n\t\tpulse_width = LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_200MS;\n\t\tbreak;\n\tcase 100000000:\n\t\tpulse_width = LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_100MS;\n\t\tbreak;\n\tcase 50000000:\n\t\tpulse_width = LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_50MS;\n\t\tbreak;\n\tcase 10000000:\n\t\tpulse_width = LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_10MS;\n\t\tbreak;\n\tcase 5000000:\n\t\tpulse_width = LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_5MS;\n\t\tbreak;\n\tcase 1000000:\n\t\tpulse_width = LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_1MS;\n\t\tbreak;\n\tcase 500000:\n\t\tpulse_width = LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_500US;\n\t\tbreak;\n\tcase 100000:\n\t\tpulse_width = LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_100US;\n\t\tbreak;\n\tcase 50000:\n\t\tpulse_width = LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_50US;\n\t\tbreak;\n\tcase 10000:\n\t\tpulse_width = LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_10US;\n\t\tbreak;\n\tcase 5000:\n\t\tpulse_width = LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_5US;\n\t\tbreak;\n\tcase 1000:\n\t\tpulse_width = LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_1US;\n\t\tbreak;\n\tcase 500:\n\t\tpulse_width = LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_500NS;\n\t\tbreak;\n\tcase 100:\n\t\tpulse_width = LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_100NS;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn_ratelimited(\"%s: Use default duty cycle of 100ns\\n\",\n\t\t\t\t    phydev_name(phydev));\n\t\tpulse_width = LAN8841_PTP_GENERAL_CONFIG_LTC_EVENT_100NS;\n\t\tbreak;\n\t}\n\n\tmutex_lock(&ptp_priv->ptp_lock);\n\tret = lan8841_ptp_set_target(ptp_priv, LAN8841_EVENT_A, rq->perout.start.sec,\n\t\t\t\t     rq->perout.start.nsec);\n\tmutex_unlock(&ptp_priv->ptp_lock);\n\tif (ret)\n\t\treturn ret;\n\n\tret = lan8841_ptp_set_reload(ptp_priv, LAN8841_EVENT_A, rq->perout.period.sec,\n\t\t\t\t     rq->perout.period.nsec);\n\tif (ret)\n\t\treturn ret;\n\n\tret = lan8841_ptp_enable_event(ptp_priv, pin, LAN8841_EVENT_A,\n\t\t\t\t       pulse_width);\n\tif (ret)\n\t\treturn ret;\n\n\tret = lan8841_ptp_perout_on(ptp_priv, pin);\n\tif (ret)\n\t\tlan8841_ptp_remove_event(ptp_priv, pin, LAN8841_EVENT_A);\n\n\treturn ret;\n}\n\n#define LAN8841_PTP_GPIO_CAP_EN\t\t\t496\n#define LAN8841_PTP_GPIO_CAP_EN_GPIO_RE_CAPTURE_ENABLE(gpio)\t(BIT(gpio))\n#define LAN8841_PTP_GPIO_CAP_EN_GPIO_FE_CAPTURE_ENABLE(gpio)\t(BIT(gpio) << 8)\n#define LAN8841_PTP_INT_EN_PTP_GPIO_CAP_EN\tBIT(2)\n\nstatic int lan8841_ptp_extts_on(struct kszphy_ptp_priv *ptp_priv, int pin,\n\t\t\t\tu32 flags)\n{\n\tstruct phy_device *phydev = ptp_priv->phydev;\n\tu16 tmp = 0;\n\tint ret;\n\n\t \n\tret = phy_set_bits_mmd(phydev, 2, LAN8841_GPIO_EN, BIT(pin));\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_clear_bits_mmd(phydev, 2, LAN8841_GPIO_BUF, BIT(pin));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (flags & PTP_RISING_EDGE)\n\t\ttmp |= LAN8841_PTP_GPIO_CAP_EN_GPIO_RE_CAPTURE_ENABLE(pin);\n\tif (flags & PTP_FALLING_EDGE)\n\t\ttmp |= LAN8841_PTP_GPIO_CAP_EN_GPIO_FE_CAPTURE_ENABLE(pin);\n\tret = phy_write_mmd(phydev, 2, LAN8841_PTP_GPIO_CAP_EN, tmp);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn phy_modify_mmd(phydev, 2, LAN8841_PTP_INT_EN,\n\t\t\t      LAN8841_PTP_INT_EN_PTP_GPIO_CAP_EN,\n\t\t\t      LAN8841_PTP_INT_EN_PTP_GPIO_CAP_EN);\n}\n\nstatic int lan8841_ptp_extts_off(struct kszphy_ptp_priv *ptp_priv, int pin)\n{\n\tstruct phy_device *phydev = ptp_priv->phydev;\n\tint ret;\n\n\t \n\tret = phy_clear_bits_mmd(phydev, 2, LAN8841_GPIO_EN, BIT(pin));\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_clear_bits_mmd(phydev, 2, LAN8841_GPIO_BUF, BIT(pin));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = phy_modify_mmd(phydev, 2, LAN8841_PTP_GPIO_CAP_EN,\n\t\t\t     LAN8841_PTP_GPIO_CAP_EN_GPIO_RE_CAPTURE_ENABLE(pin) |\n\t\t\t     LAN8841_PTP_GPIO_CAP_EN_GPIO_FE_CAPTURE_ENABLE(pin),\n\t\t\t     0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn phy_modify_mmd(phydev, 2, LAN8841_PTP_INT_EN,\n\t\t\t      LAN8841_PTP_INT_EN_PTP_GPIO_CAP_EN,\n\t\t\t      0);\n}\n\nstatic int lan8841_ptp_extts(struct ptp_clock_info *ptp,\n\t\t\t     struct ptp_clock_request *rq, int on)\n{\n\tstruct kszphy_ptp_priv *ptp_priv = container_of(ptp, struct kszphy_ptp_priv,\n\t\t\t\t\t\t\tptp_clock_info);\n\tint pin;\n\tint ret;\n\n\t \n\tif (rq->extts.flags & ~(PTP_ENABLE_FEATURE |\n\t\t\t\tPTP_EXTTS_EDGES |\n\t\t\t\tPTP_STRICT_FLAGS))\n\t\treturn -EOPNOTSUPP;\n\n\tpin = ptp_find_pin(ptp_priv->ptp_clock, PTP_PF_EXTTS, rq->extts.index);\n\tif (pin == -1 || pin >= LAN8841_PTP_GPIO_NUM)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ptp_priv->ptp_lock);\n\tif (on)\n\t\tret = lan8841_ptp_extts_on(ptp_priv, pin, rq->extts.flags);\n\telse\n\t\tret = lan8841_ptp_extts_off(ptp_priv, pin);\n\tmutex_unlock(&ptp_priv->ptp_lock);\n\n\treturn ret;\n}\n\nstatic int lan8841_ptp_enable(struct ptp_clock_info *ptp,\n\t\t\t      struct ptp_clock_request *rq, int on)\n{\n\tswitch (rq->type) {\n\tcase PTP_CLK_REQ_EXTTS:\n\t\treturn lan8841_ptp_extts(ptp, rq, on);\n\tcase PTP_CLK_REQ_PEROUT:\n\t\treturn lan8841_ptp_perout(ptp, rq, on);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic long lan8841_ptp_do_aux_work(struct ptp_clock_info *ptp)\n{\n\tstruct kszphy_ptp_priv *ptp_priv = container_of(ptp, struct kszphy_ptp_priv,\n\t\t\t\t\t\t\tptp_clock_info);\n\tstruct timespec64 ts;\n\tunsigned long flags;\n\n\tlan8841_ptp_getseconds(&ptp_priv->ptp_clock_info, &ts);\n\n\tspin_lock_irqsave(&ptp_priv->seconds_lock, flags);\n\tptp_priv->seconds = ts.tv_sec;\n\tspin_unlock_irqrestore(&ptp_priv->seconds_lock, flags);\n\n\treturn nsecs_to_jiffies(LAN8841_GET_SEC_LTC_DELAY);\n}\n\nstatic struct ptp_clock_info lan8841_ptp_clock_info = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"lan8841 ptp\",\n\t.max_adj\t= 31249999,\n\t.gettime64\t= lan8841_ptp_gettime64,\n\t.settime64\t= lan8841_ptp_settime64,\n\t.adjtime\t= lan8841_ptp_adjtime,\n\t.adjfine\t= lan8841_ptp_adjfine,\n\t.verify         = lan8841_ptp_verify,\n\t.enable         = lan8841_ptp_enable,\n\t.do_aux_work\t= lan8841_ptp_do_aux_work,\n\t.n_per_out      = LAN8841_PTP_GPIO_NUM,\n\t.n_ext_ts       = LAN8841_PTP_GPIO_NUM,\n\t.n_pins         = LAN8841_PTP_GPIO_NUM,\n};\n\n#define LAN8841_OPERATION_MODE_STRAP_LOW_REGISTER 3\n#define LAN8841_OPERATION_MODE_STRAP_LOW_REGISTER_STRAP_RGMII_EN BIT(0)\n\nstatic int lan8841_probe(struct phy_device *phydev)\n{\n\tstruct kszphy_ptp_priv *ptp_priv;\n\tstruct kszphy_priv *priv;\n\tint err;\n\n\terr = kszphy_probe(phydev);\n\tif (err)\n\t\treturn err;\n\n\tif (phy_read_mmd(phydev, KSZ9131RN_MMD_COMMON_CTRL_REG,\n\t\t\t LAN8841_OPERATION_MODE_STRAP_LOW_REGISTER) &\n\t    LAN8841_OPERATION_MODE_STRAP_LOW_REGISTER_STRAP_RGMII_EN)\n\t\tphydev->interface = PHY_INTERFACE_MODE_RGMII_RXID;\n\n\t \n\tif (!IS_ENABLED(CONFIG_NETWORK_PHY_TIMESTAMPING))\n\t\treturn 0;\n\n\tpriv = phydev->priv;\n\tptp_priv = &priv->ptp_priv;\n\n\tptp_priv->pin_config = devm_kcalloc(&phydev->mdio.dev,\n\t\t\t\t\t    LAN8841_PTP_GPIO_NUM,\n\t\t\t\t\t    sizeof(*ptp_priv->pin_config),\n\t\t\t\t\t    GFP_KERNEL);\n\tif (!ptp_priv->pin_config)\n\t\treturn -ENOMEM;\n\n\tfor (int i = 0; i < LAN8841_PTP_GPIO_NUM; ++i) {\n\t\tstruct ptp_pin_desc *p = &ptp_priv->pin_config[i];\n\n\t\tsnprintf(p->name, sizeof(p->name), \"pin%d\", i);\n\t\tp->index = i;\n\t\tp->func = PTP_PF_NONE;\n\t}\n\n\tptp_priv->ptp_clock_info = lan8841_ptp_clock_info;\n\tptp_priv->ptp_clock_info.pin_config = ptp_priv->pin_config;\n\tptp_priv->ptp_clock = ptp_clock_register(&ptp_priv->ptp_clock_info,\n\t\t\t\t\t\t &phydev->mdio.dev);\n\tif (IS_ERR(ptp_priv->ptp_clock)) {\n\t\tphydev_err(phydev, \"ptp_clock_register failed: %lu\\n\",\n\t\t\t   PTR_ERR(ptp_priv->ptp_clock));\n\t\treturn -EINVAL;\n\t}\n\n\tif (!ptp_priv->ptp_clock)\n\t\treturn 0;\n\n\t \n\tskb_queue_head_init(&ptp_priv->tx_queue);\n\tptp_priv->phydev = phydev;\n\tmutex_init(&ptp_priv->ptp_lock);\n\tspin_lock_init(&ptp_priv->seconds_lock);\n\n\tptp_priv->mii_ts.rxtstamp = lan8841_rxtstamp;\n\tptp_priv->mii_ts.txtstamp = lan8814_txtstamp;\n\tptp_priv->mii_ts.hwtstamp = lan8841_hwtstamp;\n\tptp_priv->mii_ts.ts_info = lan8841_ts_info;\n\n\tphydev->mii_ts = &ptp_priv->mii_ts;\n\n\treturn 0;\n}\n\nstatic int lan8841_suspend(struct phy_device *phydev)\n{\n\tstruct kszphy_priv *priv = phydev->priv;\n\tstruct kszphy_ptp_priv *ptp_priv = &priv->ptp_priv;\n\n\tptp_cancel_worker_sync(ptp_priv->ptp_clock);\n\n\treturn genphy_suspend(phydev);\n}\n\nstatic struct phy_driver ksphy_driver[] = {\n{\n\t.phy_id\t\t= PHY_ID_KS8737,\n\t.phy_id_mask\t= MICREL_PHY_ID_MASK,\n\t.name\t\t= \"Micrel KS8737\",\n\t \n\t.driver_data\t= &ks8737_type,\n\t.probe\t\t= kszphy_probe,\n\t.config_init\t= kszphy_config_init,\n\t.config_intr\t= kszphy_config_intr,\n\t.handle_interrupt = kszphy_handle_interrupt,\n\t.suspend\t= kszphy_suspend,\n\t.resume\t\t= kszphy_resume,\n}, {\n\t.phy_id\t\t= PHY_ID_KSZ8021,\n\t.phy_id_mask\t= 0x00ffffff,\n\t.name\t\t= \"Micrel KSZ8021 or KSZ8031\",\n\t \n\t.driver_data\t= &ksz8021_type,\n\t.probe\t\t= kszphy_probe,\n\t.config_init\t= kszphy_config_init,\n\t.config_intr\t= kszphy_config_intr,\n\t.handle_interrupt = kszphy_handle_interrupt,\n\t.get_sset_count = kszphy_get_sset_count,\n\t.get_strings\t= kszphy_get_strings,\n\t.get_stats\t= kszphy_get_stats,\n\t.suspend\t= kszphy_suspend,\n\t.resume\t\t= kszphy_resume,\n}, {\n\t.phy_id\t\t= PHY_ID_KSZ8031,\n\t.phy_id_mask\t= 0x00ffffff,\n\t.name\t\t= \"Micrel KSZ8031\",\n\t \n\t.driver_data\t= &ksz8021_type,\n\t.probe\t\t= kszphy_probe,\n\t.config_init\t= kszphy_config_init,\n\t.config_intr\t= kszphy_config_intr,\n\t.handle_interrupt = kszphy_handle_interrupt,\n\t.get_sset_count = kszphy_get_sset_count,\n\t.get_strings\t= kszphy_get_strings,\n\t.get_stats\t= kszphy_get_stats,\n\t.suspend\t= kszphy_suspend,\n\t.resume\t\t= kszphy_resume,\n}, {\n\t.phy_id\t\t= PHY_ID_KSZ8041,\n\t.phy_id_mask\t= MICREL_PHY_ID_MASK,\n\t.name\t\t= \"Micrel KSZ8041\",\n\t \n\t.driver_data\t= &ksz8041_type,\n\t.probe\t\t= kszphy_probe,\n\t.config_init\t= ksz8041_config_init,\n\t.config_aneg\t= ksz8041_config_aneg,\n\t.config_intr\t= kszphy_config_intr,\n\t.handle_interrupt = kszphy_handle_interrupt,\n\t.get_sset_count = kszphy_get_sset_count,\n\t.get_strings\t= kszphy_get_strings,\n\t.get_stats\t= kszphy_get_stats,\n\t \n}, {\n\t.phy_id\t\t= PHY_ID_KSZ8041RNLI,\n\t.phy_id_mask\t= MICREL_PHY_ID_MASK,\n\t.name\t\t= \"Micrel KSZ8041RNLI\",\n\t \n\t.driver_data\t= &ksz8041_type,\n\t.probe\t\t= kszphy_probe,\n\t.config_init\t= kszphy_config_init,\n\t.config_intr\t= kszphy_config_intr,\n\t.handle_interrupt = kszphy_handle_interrupt,\n\t.get_sset_count = kszphy_get_sset_count,\n\t.get_strings\t= kszphy_get_strings,\n\t.get_stats\t= kszphy_get_stats,\n\t.suspend\t= kszphy_suspend,\n\t.resume\t\t= kszphy_resume,\n}, {\n\t.name\t\t= \"Micrel KSZ8051\",\n\t \n\t.driver_data\t= &ksz8051_type,\n\t.probe\t\t= kszphy_probe,\n\t.config_init\t= kszphy_config_init,\n\t.config_intr\t= kszphy_config_intr,\n\t.handle_interrupt = kszphy_handle_interrupt,\n\t.get_sset_count = kszphy_get_sset_count,\n\t.get_strings\t= kszphy_get_strings,\n\t.get_stats\t= kszphy_get_stats,\n\t.match_phy_device = ksz8051_match_phy_device,\n\t.suspend\t= kszphy_suspend,\n\t.resume\t\t= kszphy_resume,\n}, {\n\t.phy_id\t\t= PHY_ID_KSZ8001,\n\t.name\t\t= \"Micrel KSZ8001 or KS8721\",\n\t.phy_id_mask\t= 0x00fffffc,\n\t \n\t.driver_data\t= &ksz8041_type,\n\t.probe\t\t= kszphy_probe,\n\t.config_init\t= kszphy_config_init,\n\t.config_intr\t= kszphy_config_intr,\n\t.handle_interrupt = kszphy_handle_interrupt,\n\t.get_sset_count = kszphy_get_sset_count,\n\t.get_strings\t= kszphy_get_strings,\n\t.get_stats\t= kszphy_get_stats,\n\t.suspend\t= kszphy_suspend,\n\t.resume\t\t= kszphy_resume,\n}, {\n\t.phy_id\t\t= PHY_ID_KSZ8081,\n\t.name\t\t= \"Micrel KSZ8081 or KSZ8091\",\n\t.phy_id_mask\t= MICREL_PHY_ID_MASK,\n\t.flags\t\t= PHY_POLL_CABLE_TEST,\n\t \n\t.driver_data\t= &ksz8081_type,\n\t.probe\t\t= kszphy_probe,\n\t.config_init\t= ksz8081_config_init,\n\t.soft_reset\t= genphy_soft_reset,\n\t.config_aneg\t= ksz8081_config_aneg,\n\t.read_status\t= ksz8081_read_status,\n\t.config_intr\t= kszphy_config_intr,\n\t.handle_interrupt = kszphy_handle_interrupt,\n\t.get_sset_count = kszphy_get_sset_count,\n\t.get_strings\t= kszphy_get_strings,\n\t.get_stats\t= kszphy_get_stats,\n\t.suspend\t= kszphy_suspend,\n\t.resume\t\t= kszphy_resume,\n\t.cable_test_start\t= ksz886x_cable_test_start,\n\t.cable_test_get_status\t= ksz886x_cable_test_get_status,\n}, {\n\t.phy_id\t\t= PHY_ID_KSZ8061,\n\t.name\t\t= \"Micrel KSZ8061\",\n\t.phy_id_mask\t= MICREL_PHY_ID_MASK,\n\t \n\t.probe\t\t= kszphy_probe,\n\t.config_init\t= ksz8061_config_init,\n\t.config_intr\t= kszphy_config_intr,\n\t.handle_interrupt = kszphy_handle_interrupt,\n\t.suspend\t= kszphy_suspend,\n\t.resume\t\t= kszphy_resume,\n}, {\n\t.phy_id\t\t= PHY_ID_KSZ9021,\n\t.phy_id_mask\t= 0x000ffffe,\n\t.name\t\t= \"Micrel KSZ9021 Gigabit PHY\",\n\t \n\t.driver_data\t= &ksz9021_type,\n\t.probe\t\t= kszphy_probe,\n\t.get_features\t= ksz9031_get_features,\n\t.config_init\t= ksz9021_config_init,\n\t.config_intr\t= kszphy_config_intr,\n\t.handle_interrupt = kszphy_handle_interrupt,\n\t.get_sset_count = kszphy_get_sset_count,\n\t.get_strings\t= kszphy_get_strings,\n\t.get_stats\t= kszphy_get_stats,\n\t.suspend\t= kszphy_suspend,\n\t.resume\t\t= kszphy_resume,\n\t.read_mmd\t= genphy_read_mmd_unsupported,\n\t.write_mmd\t= genphy_write_mmd_unsupported,\n}, {\n\t.phy_id\t\t= PHY_ID_KSZ9031,\n\t.phy_id_mask\t= MICREL_PHY_ID_MASK,\n\t.name\t\t= \"Micrel KSZ9031 Gigabit PHY\",\n\t.flags\t\t= PHY_POLL_CABLE_TEST,\n\t.driver_data\t= &ksz9021_type,\n\t.probe\t\t= kszphy_probe,\n\t.get_features\t= ksz9031_get_features,\n\t.config_init\t= ksz9031_config_init,\n\t.soft_reset\t= genphy_soft_reset,\n\t.read_status\t= ksz9031_read_status,\n\t.config_intr\t= kszphy_config_intr,\n\t.handle_interrupt = kszphy_handle_interrupt,\n\t.get_sset_count = kszphy_get_sset_count,\n\t.get_strings\t= kszphy_get_strings,\n\t.get_stats\t= kszphy_get_stats,\n\t.suspend\t= kszphy_suspend,\n\t.resume\t\t= kszphy_resume,\n\t.cable_test_start\t= ksz9x31_cable_test_start,\n\t.cable_test_get_status\t= ksz9x31_cable_test_get_status,\n}, {\n\t.phy_id\t\t= PHY_ID_LAN8814,\n\t.phy_id_mask\t= MICREL_PHY_ID_MASK,\n\t.name\t\t= \"Microchip INDY Gigabit Quad PHY\",\n\t.flags          = PHY_POLL_CABLE_TEST,\n\t.config_init\t= lan8814_config_init,\n\t.driver_data\t= &lan8814_type,\n\t.probe\t\t= lan8814_probe,\n\t.soft_reset\t= genphy_soft_reset,\n\t.read_status\t= ksz9031_read_status,\n\t.get_sset_count\t= kszphy_get_sset_count,\n\t.get_strings\t= kszphy_get_strings,\n\t.get_stats\t= kszphy_get_stats,\n\t.suspend\t= genphy_suspend,\n\t.resume\t\t= kszphy_resume,\n\t.config_intr\t= lan8814_config_intr,\n\t.handle_interrupt = lan8814_handle_interrupt,\n\t.cable_test_start\t= lan8814_cable_test_start,\n\t.cable_test_get_status\t= ksz886x_cable_test_get_status,\n}, {\n\t.phy_id\t\t= PHY_ID_LAN8804,\n\t.phy_id_mask\t= MICREL_PHY_ID_MASK,\n\t.name\t\t= \"Microchip LAN966X Gigabit PHY\",\n\t.config_init\t= lan8804_config_init,\n\t.driver_data\t= &ksz9021_type,\n\t.probe\t\t= kszphy_probe,\n\t.soft_reset\t= genphy_soft_reset,\n\t.read_status\t= ksz9031_read_status,\n\t.get_sset_count\t= kszphy_get_sset_count,\n\t.get_strings\t= kszphy_get_strings,\n\t.get_stats\t= kszphy_get_stats,\n\t.suspend\t= genphy_suspend,\n\t.resume\t\t= kszphy_resume,\n\t.config_intr\t= lan8804_config_intr,\n\t.handle_interrupt = lan8804_handle_interrupt,\n}, {\n\t.phy_id\t\t= PHY_ID_LAN8841,\n\t.phy_id_mask\t= MICREL_PHY_ID_MASK,\n\t.name\t\t= \"Microchip LAN8841 Gigabit PHY\",\n\t.flags\t\t= PHY_POLL_CABLE_TEST,\n\t.driver_data\t= &lan8841_type,\n\t.config_init\t= lan8841_config_init,\n\t.probe\t\t= lan8841_probe,\n\t.soft_reset\t= genphy_soft_reset,\n\t.config_intr\t= lan8841_config_intr,\n\t.handle_interrupt = lan8841_handle_interrupt,\n\t.get_sset_count = kszphy_get_sset_count,\n\t.get_strings\t= kszphy_get_strings,\n\t.get_stats\t= kszphy_get_stats,\n\t.suspend\t= lan8841_suspend,\n\t.resume\t\t= genphy_resume,\n\t.cable_test_start\t= lan8814_cable_test_start,\n\t.cable_test_get_status\t= ksz886x_cable_test_get_status,\n}, {\n\t.phy_id\t\t= PHY_ID_KSZ9131,\n\t.phy_id_mask\t= MICREL_PHY_ID_MASK,\n\t.name\t\t= \"Microchip KSZ9131 Gigabit PHY\",\n\t \n\t.flags\t\t= PHY_POLL_CABLE_TEST,\n\t.driver_data\t= &ksz9131_type,\n\t.probe\t\t= kszphy_probe,\n\t.soft_reset\t= genphy_soft_reset,\n\t.config_init\t= ksz9131_config_init,\n\t.config_intr\t= kszphy_config_intr,\n\t.config_aneg\t= ksz9131_config_aneg,\n\t.read_status\t= ksz9131_read_status,\n\t.handle_interrupt = kszphy_handle_interrupt,\n\t.get_sset_count = kszphy_get_sset_count,\n\t.get_strings\t= kszphy_get_strings,\n\t.get_stats\t= kszphy_get_stats,\n\t.suspend\t= kszphy_suspend,\n\t.resume\t\t= kszphy_resume,\n\t.cable_test_start\t= ksz9x31_cable_test_start,\n\t.cable_test_get_status\t= ksz9x31_cable_test_get_status,\n\t.get_features\t= ksz9477_get_features,\n}, {\n\t.phy_id\t\t= PHY_ID_KSZ8873MLL,\n\t.phy_id_mask\t= MICREL_PHY_ID_MASK,\n\t.name\t\t= \"Micrel KSZ8873MLL Switch\",\n\t \n\t.config_init\t= kszphy_config_init,\n\t.config_aneg\t= ksz8873mll_config_aneg,\n\t.read_status\t= ksz8873mll_read_status,\n\t.suspend\t= genphy_suspend,\n\t.resume\t\t= genphy_resume,\n}, {\n\t.phy_id\t\t= PHY_ID_KSZ886X,\n\t.phy_id_mask\t= MICREL_PHY_ID_MASK,\n\t.name\t\t= \"Micrel KSZ8851 Ethernet MAC or KSZ886X Switch\",\n\t.driver_data\t= &ksz886x_type,\n\t \n\t.flags\t\t= PHY_POLL_CABLE_TEST,\n\t.config_init\t= kszphy_config_init,\n\t.config_aneg\t= ksz886x_config_aneg,\n\t.read_status\t= ksz886x_read_status,\n\t.suspend\t= genphy_suspend,\n\t.resume\t\t= genphy_resume,\n\t.cable_test_start\t= ksz886x_cable_test_start,\n\t.cable_test_get_status\t= ksz886x_cable_test_get_status,\n}, {\n\t.name\t\t= \"Micrel KSZ87XX Switch\",\n\t \n\t.config_init\t= kszphy_config_init,\n\t.match_phy_device = ksz8795_match_phy_device,\n\t.suspend\t= genphy_suspend,\n\t.resume\t\t= genphy_resume,\n}, {\n\t.phy_id\t\t= PHY_ID_KSZ9477,\n\t.phy_id_mask\t= MICREL_PHY_ID_MASK,\n\t.name\t\t= \"Microchip KSZ9477\",\n\t \n\t.config_init\t= ksz9477_config_init,\n\t.config_intr\t= kszphy_config_intr,\n\t.handle_interrupt = kszphy_handle_interrupt,\n\t.suspend\t= genphy_suspend,\n\t.resume\t\t= genphy_resume,\n\t.get_features\t= ksz9477_get_features,\n} };\n\nmodule_phy_driver(ksphy_driver);\n\nMODULE_DESCRIPTION(\"Micrel PHY driver\");\nMODULE_AUTHOR(\"David J. Choi\");\nMODULE_LICENSE(\"GPL\");\n\nstatic struct mdio_device_id __maybe_unused micrel_tbl[] = {\n\t{ PHY_ID_KSZ9021, 0x000ffffe },\n\t{ PHY_ID_KSZ9031, MICREL_PHY_ID_MASK },\n\t{ PHY_ID_KSZ9131, MICREL_PHY_ID_MASK },\n\t{ PHY_ID_KSZ8001, 0x00fffffc },\n\t{ PHY_ID_KS8737, MICREL_PHY_ID_MASK },\n\t{ PHY_ID_KSZ8021, 0x00ffffff },\n\t{ PHY_ID_KSZ8031, 0x00ffffff },\n\t{ PHY_ID_KSZ8041, MICREL_PHY_ID_MASK },\n\t{ PHY_ID_KSZ8051, MICREL_PHY_ID_MASK },\n\t{ PHY_ID_KSZ8061, MICREL_PHY_ID_MASK },\n\t{ PHY_ID_KSZ8081, MICREL_PHY_ID_MASK },\n\t{ PHY_ID_KSZ8873MLL, MICREL_PHY_ID_MASK },\n\t{ PHY_ID_KSZ886X, MICREL_PHY_ID_MASK },\n\t{ PHY_ID_LAN8814, MICREL_PHY_ID_MASK },\n\t{ PHY_ID_LAN8804, MICREL_PHY_ID_MASK },\n\t{ PHY_ID_LAN8841, MICREL_PHY_ID_MASK },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(mdio, micrel_tbl);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}