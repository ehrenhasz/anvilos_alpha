{
  "module_name": "aquantia_main.c",
  "hash_id": "4a3fe424b113d4de6890959fda1627cabc7f90a5bed0972309ea0f6442975aa8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/aquantia_main.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/bitfield.h>\n#include <linux/phy.h>\n\n#include \"aquantia.h\"\n\n#define PHY_ID_AQ1202\t0x03a1b445\n#define PHY_ID_AQ2104\t0x03a1b460\n#define PHY_ID_AQR105\t0x03a1b4a2\n#define PHY_ID_AQR106\t0x03a1b4d0\n#define PHY_ID_AQR107\t0x03a1b4e0\n#define PHY_ID_AQCS109\t0x03a1b5c2\n#define PHY_ID_AQR405\t0x03a1b4b0\n#define PHY_ID_AQR112\t0x03a1b662\n#define PHY_ID_AQR412\t0x03a1b712\n#define PHY_ID_AQR113C\t0x31c31c12\n\n#define MDIO_PHYXS_VEND_IF_STATUS\t\t0xe812\n#define MDIO_PHYXS_VEND_IF_STATUS_TYPE_MASK\tGENMASK(7, 3)\n#define MDIO_PHYXS_VEND_IF_STATUS_TYPE_KR\t0\n#define MDIO_PHYXS_VEND_IF_STATUS_TYPE_KX\t1\n#define MDIO_PHYXS_VEND_IF_STATUS_TYPE_XFI\t2\n#define MDIO_PHYXS_VEND_IF_STATUS_TYPE_USXGMII\t3\n#define MDIO_PHYXS_VEND_IF_STATUS_TYPE_XAUI\t4\n#define MDIO_PHYXS_VEND_IF_STATUS_TYPE_SGMII\t6\n#define MDIO_PHYXS_VEND_IF_STATUS_TYPE_RXAUI\t7\n#define MDIO_PHYXS_VEND_IF_STATUS_TYPE_OCSGMII\t10\n\n#define MDIO_AN_VEND_PROV\t\t\t0xc400\n#define MDIO_AN_VEND_PROV_1000BASET_FULL\tBIT(15)\n#define MDIO_AN_VEND_PROV_1000BASET_HALF\tBIT(14)\n#define MDIO_AN_VEND_PROV_5000BASET_FULL\tBIT(11)\n#define MDIO_AN_VEND_PROV_2500BASET_FULL\tBIT(10)\n#define MDIO_AN_VEND_PROV_DOWNSHIFT_EN\t\tBIT(4)\n#define MDIO_AN_VEND_PROV_DOWNSHIFT_MASK\tGENMASK(3, 0)\n#define MDIO_AN_VEND_PROV_DOWNSHIFT_DFLT\t4\n\n#define MDIO_AN_TX_VEND_STATUS1\t\t\t0xc800\n#define MDIO_AN_TX_VEND_STATUS1_RATE_MASK\tGENMASK(3, 1)\n#define MDIO_AN_TX_VEND_STATUS1_10BASET\t\t0\n#define MDIO_AN_TX_VEND_STATUS1_100BASETX\t1\n#define MDIO_AN_TX_VEND_STATUS1_1000BASET\t2\n#define MDIO_AN_TX_VEND_STATUS1_10GBASET\t3\n#define MDIO_AN_TX_VEND_STATUS1_2500BASET\t4\n#define MDIO_AN_TX_VEND_STATUS1_5000BASET\t5\n#define MDIO_AN_TX_VEND_STATUS1_FULL_DUPLEX\tBIT(0)\n\n#define MDIO_AN_TX_VEND_INT_STATUS1\t\t0xcc00\n#define MDIO_AN_TX_VEND_INT_STATUS1_DOWNSHIFT\tBIT(1)\n\n#define MDIO_AN_TX_VEND_INT_STATUS2\t\t0xcc01\n#define MDIO_AN_TX_VEND_INT_STATUS2_MASK\tBIT(0)\n\n#define MDIO_AN_TX_VEND_INT_MASK2\t\t0xd401\n#define MDIO_AN_TX_VEND_INT_MASK2_LINK\t\tBIT(0)\n\n#define MDIO_AN_RX_LP_STAT1\t\t\t0xe820\n#define MDIO_AN_RX_LP_STAT1_1000BASET_FULL\tBIT(15)\n#define MDIO_AN_RX_LP_STAT1_1000BASET_HALF\tBIT(14)\n#define MDIO_AN_RX_LP_STAT1_SHORT_REACH\t\tBIT(13)\n#define MDIO_AN_RX_LP_STAT1_AQRATE_DOWNSHIFT\tBIT(12)\n#define MDIO_AN_RX_LP_STAT1_AQ_PHY\t\tBIT(2)\n\n#define MDIO_AN_RX_LP_STAT4\t\t\t0xe823\n#define MDIO_AN_RX_LP_STAT4_FW_MAJOR\t\tGENMASK(15, 8)\n#define MDIO_AN_RX_LP_STAT4_FW_MINOR\t\tGENMASK(7, 0)\n\n#define MDIO_AN_RX_VEND_STAT3\t\t\t0xe832\n#define MDIO_AN_RX_VEND_STAT3_AFR\t\tBIT(0)\n\n \n#define MDIO_C22EXT_STAT_SGMII_RX_GOOD_FRAMES\t\t0xd292\n#define MDIO_C22EXT_STAT_SGMII_RX_BAD_FRAMES\t\t0xd294\n#define MDIO_C22EXT_STAT_SGMII_RX_FALSE_CARRIER\t\t0xd297\n#define MDIO_C22EXT_STAT_SGMII_TX_GOOD_FRAMES\t\t0xd313\n#define MDIO_C22EXT_STAT_SGMII_TX_BAD_FRAMES\t\t0xd315\n#define MDIO_C22EXT_STAT_SGMII_TX_FALSE_CARRIER\t\t0xd317\n#define MDIO_C22EXT_STAT_SGMII_TX_COLLISIONS\t\t0xd318\n#define MDIO_C22EXT_STAT_SGMII_TX_LINE_COLLISIONS\t0xd319\n#define MDIO_C22EXT_STAT_SGMII_TX_FRAME_ALIGN_ERR\t0xd31a\n#define MDIO_C22EXT_STAT_SGMII_TX_RUNT_FRAMES\t\t0xd31b\n\n \n#define VEND1_GLOBAL_FW_ID\t\t\t0x0020\n#define VEND1_GLOBAL_FW_ID_MAJOR\t\tGENMASK(15, 8)\n#define VEND1_GLOBAL_FW_ID_MINOR\t\tGENMASK(7, 0)\n\n#define VEND1_GLOBAL_GEN_STAT2\t\t\t0xc831\n#define VEND1_GLOBAL_GEN_STAT2_OP_IN_PROG\tBIT(15)\n\n \n#define VEND1_GLOBAL_CFG_10M\t\t\t0x0310\n#define VEND1_GLOBAL_CFG_100M\t\t\t0x031b\n#define VEND1_GLOBAL_CFG_1G\t\t\t0x031c\n#define VEND1_GLOBAL_CFG_2_5G\t\t\t0x031d\n#define VEND1_GLOBAL_CFG_5G\t\t\t0x031e\n#define VEND1_GLOBAL_CFG_10G\t\t\t0x031f\n \n#define VEND1_GLOBAL_CFG_RATE_ADAPT\t\tGENMASK(8, 7)\n#define VEND1_GLOBAL_CFG_RATE_ADAPT_NONE\t0\n#define VEND1_GLOBAL_CFG_RATE_ADAPT_USX\t\t1\n#define VEND1_GLOBAL_CFG_RATE_ADAPT_PAUSE\t2\n\n#define VEND1_GLOBAL_RSVD_STAT1\t\t\t0xc885\n#define VEND1_GLOBAL_RSVD_STAT1_FW_BUILD_ID\tGENMASK(7, 4)\n#define VEND1_GLOBAL_RSVD_STAT1_PROV_ID\t\tGENMASK(3, 0)\n\n#define VEND1_GLOBAL_RSVD_STAT9\t\t\t0xc88d\n#define VEND1_GLOBAL_RSVD_STAT9_MODE\t\tGENMASK(7, 0)\n#define VEND1_GLOBAL_RSVD_STAT9_1000BT2\t\t0x23\n\n#define VEND1_GLOBAL_INT_STD_STATUS\t\t0xfc00\n#define VEND1_GLOBAL_INT_VEND_STATUS\t\t0xfc01\n\n#define VEND1_GLOBAL_INT_STD_MASK\t\t0xff00\n#define VEND1_GLOBAL_INT_STD_MASK_PMA1\t\tBIT(15)\n#define VEND1_GLOBAL_INT_STD_MASK_PMA2\t\tBIT(14)\n#define VEND1_GLOBAL_INT_STD_MASK_PCS1\t\tBIT(13)\n#define VEND1_GLOBAL_INT_STD_MASK_PCS2\t\tBIT(12)\n#define VEND1_GLOBAL_INT_STD_MASK_PCS3\t\tBIT(11)\n#define VEND1_GLOBAL_INT_STD_MASK_PHY_XS1\tBIT(10)\n#define VEND1_GLOBAL_INT_STD_MASK_PHY_XS2\tBIT(9)\n#define VEND1_GLOBAL_INT_STD_MASK_AN1\t\tBIT(8)\n#define VEND1_GLOBAL_INT_STD_MASK_AN2\t\tBIT(7)\n#define VEND1_GLOBAL_INT_STD_MASK_GBE\t\tBIT(6)\n#define VEND1_GLOBAL_INT_STD_MASK_ALL\t\tBIT(0)\n\n#define VEND1_GLOBAL_INT_VEND_MASK\t\t0xff01\n#define VEND1_GLOBAL_INT_VEND_MASK_PMA\t\tBIT(15)\n#define VEND1_GLOBAL_INT_VEND_MASK_PCS\t\tBIT(14)\n#define VEND1_GLOBAL_INT_VEND_MASK_PHY_XS\tBIT(13)\n#define VEND1_GLOBAL_INT_VEND_MASK_AN\t\tBIT(12)\n#define VEND1_GLOBAL_INT_VEND_MASK_GBE\t\tBIT(11)\n#define VEND1_GLOBAL_INT_VEND_MASK_GLOBAL1\tBIT(2)\n#define VEND1_GLOBAL_INT_VEND_MASK_GLOBAL2\tBIT(1)\n#define VEND1_GLOBAL_INT_VEND_MASK_GLOBAL3\tBIT(0)\n\n \n#define AQR107_OP_IN_PROG_SLEEP\t\t1000\n#define AQR107_OP_IN_PROG_TIMEOUT\t100000\n\nstruct aqr107_hw_stat {\n\tconst char *name;\n\tint reg;\n\tint size;\n};\n\n#define SGMII_STAT(n, r, s) { n, MDIO_C22EXT_STAT_SGMII_ ## r, s }\nstatic const struct aqr107_hw_stat aqr107_hw_stats[] = {\n\tSGMII_STAT(\"sgmii_rx_good_frames\",\t    RX_GOOD_FRAMES,\t26),\n\tSGMII_STAT(\"sgmii_rx_bad_frames\",\t    RX_BAD_FRAMES,\t26),\n\tSGMII_STAT(\"sgmii_rx_false_carrier_events\", RX_FALSE_CARRIER,\t 8),\n\tSGMII_STAT(\"sgmii_tx_good_frames\",\t    TX_GOOD_FRAMES,\t26),\n\tSGMII_STAT(\"sgmii_tx_bad_frames\",\t    TX_BAD_FRAMES,\t26),\n\tSGMII_STAT(\"sgmii_tx_false_carrier_events\", TX_FALSE_CARRIER,\t 8),\n\tSGMII_STAT(\"sgmii_tx_collisions\",\t    TX_COLLISIONS,\t 8),\n\tSGMII_STAT(\"sgmii_tx_line_collisions\",\t    TX_LINE_COLLISIONS,\t 8),\n\tSGMII_STAT(\"sgmii_tx_frame_alignment_err\",  TX_FRAME_ALIGN_ERR,\t16),\n\tSGMII_STAT(\"sgmii_tx_runt_frames\",\t    TX_RUNT_FRAMES,\t22),\n};\n#define AQR107_SGMII_STAT_SZ ARRAY_SIZE(aqr107_hw_stats)\n\nstruct aqr107_priv {\n\tu64 sgmii_stats[AQR107_SGMII_STAT_SZ];\n};\n\nstatic int aqr107_get_sset_count(struct phy_device *phydev)\n{\n\treturn AQR107_SGMII_STAT_SZ;\n}\n\nstatic void aqr107_get_strings(struct phy_device *phydev, u8 *data)\n{\n\tint i;\n\n\tfor (i = 0; i < AQR107_SGMII_STAT_SZ; i++)\n\t\tstrscpy(data + i * ETH_GSTRING_LEN, aqr107_hw_stats[i].name,\n\t\t\tETH_GSTRING_LEN);\n}\n\nstatic u64 aqr107_get_stat(struct phy_device *phydev, int index)\n{\n\tconst struct aqr107_hw_stat *stat = aqr107_hw_stats + index;\n\tint len_l = min(stat->size, 16);\n\tint len_h = stat->size - len_l;\n\tu64 ret;\n\tint val;\n\n\tval = phy_read_mmd(phydev, MDIO_MMD_C22EXT, stat->reg);\n\tif (val < 0)\n\t\treturn U64_MAX;\n\n\tret = val & GENMASK(len_l - 1, 0);\n\tif (len_h) {\n\t\tval = phy_read_mmd(phydev, MDIO_MMD_C22EXT, stat->reg + 1);\n\t\tif (val < 0)\n\t\t\treturn U64_MAX;\n\n\t\tret += (val & GENMASK(len_h - 1, 0)) << 16;\n\t}\n\n\treturn ret;\n}\n\nstatic void aqr107_get_stats(struct phy_device *phydev,\n\t\t\t     struct ethtool_stats *stats, u64 *data)\n{\n\tstruct aqr107_priv *priv = phydev->priv;\n\tu64 val;\n\tint i;\n\n\tfor (i = 0; i < AQR107_SGMII_STAT_SZ; i++) {\n\t\tval = aqr107_get_stat(phydev, i);\n\t\tif (val == U64_MAX)\n\t\t\tphydev_err(phydev, \"Reading HW Statistics failed for %s\\n\",\n\t\t\t\t   aqr107_hw_stats[i].name);\n\t\telse\n\t\t\tpriv->sgmii_stats[i] += val;\n\n\t\tdata[i] = priv->sgmii_stats[i];\n\t}\n}\n\nstatic int aqr_config_aneg(struct phy_device *phydev)\n{\n\tbool changed = false;\n\tu16 reg;\n\tint ret;\n\n\tif (phydev->autoneg == AUTONEG_DISABLE)\n\t\treturn genphy_c45_pma_setup_forced(phydev);\n\n\tret = genphy_c45_an_config_aneg(phydev);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret > 0)\n\t\tchanged = true;\n\n\t \n\treg = 0;\n\tif (linkmode_test_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,\n\t\t\t      phydev->advertising))\n\t\treg |= MDIO_AN_VEND_PROV_1000BASET_FULL;\n\n\tif (linkmode_test_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT,\n\t\t\t      phydev->advertising))\n\t\treg |= MDIO_AN_VEND_PROV_1000BASET_HALF;\n\n\t \n\tif (linkmode_test_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,\n\t\t\t      phydev->advertising))\n\t\treg |= MDIO_AN_VEND_PROV_2500BASET_FULL;\n\n\tif (linkmode_test_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT,\n\t\t\t      phydev->advertising))\n\t\treg |= MDIO_AN_VEND_PROV_5000BASET_FULL;\n\n\tret = phy_modify_mmd_changed(phydev, MDIO_MMD_AN, MDIO_AN_VEND_PROV,\n\t\t\t\t     MDIO_AN_VEND_PROV_1000BASET_HALF |\n\t\t\t\t     MDIO_AN_VEND_PROV_1000BASET_FULL |\n\t\t\t\t     MDIO_AN_VEND_PROV_2500BASET_FULL |\n\t\t\t\t     MDIO_AN_VEND_PROV_5000BASET_FULL, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret > 0)\n\t\tchanged = true;\n\n\treturn genphy_c45_check_and_restart_aneg(phydev, changed);\n}\n\nstatic int aqr_config_intr(struct phy_device *phydev)\n{\n\tbool en = phydev->interrupts == PHY_INTERRUPT_ENABLED;\n\tint err;\n\n\tif (en) {\n\t\t \n\t\terr = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_TX_VEND_INT_STATUS2);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = phy_write_mmd(phydev, MDIO_MMD_AN, MDIO_AN_TX_VEND_INT_MASK2,\n\t\t\t    en ? MDIO_AN_TX_VEND_INT_MASK2_LINK : 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = phy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_GLOBAL_INT_STD_MASK,\n\t\t\t    en ? VEND1_GLOBAL_INT_STD_MASK_ALL : 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = phy_write_mmd(phydev, MDIO_MMD_VEND1, VEND1_GLOBAL_INT_VEND_MASK,\n\t\t\t    en ? VEND1_GLOBAL_INT_VEND_MASK_GLOBAL3 |\n\t\t\t    VEND1_GLOBAL_INT_VEND_MASK_AN : 0);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!en) {\n\t\t \n\t\terr = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_TX_VEND_INT_STATUS2);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t aqr_handle_interrupt(struct phy_device *phydev)\n{\n\tint irq_status;\n\n\tirq_status = phy_read_mmd(phydev, MDIO_MMD_AN,\n\t\t\t\t  MDIO_AN_TX_VEND_INT_STATUS2);\n\tif (irq_status < 0) {\n\t\tphy_error(phydev);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (!(irq_status & MDIO_AN_TX_VEND_INT_STATUS2_MASK))\n\t\treturn IRQ_NONE;\n\n\tphy_trigger_machine(phydev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int aqr_read_status(struct phy_device *phydev)\n{\n\tint val;\n\n\tif (phydev->autoneg == AUTONEG_ENABLE) {\n\t\tval = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_RX_LP_STAT1);\n\t\tif (val < 0)\n\t\t\treturn val;\n\n\t\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT,\n\t\t\t\t phydev->lp_advertising,\n\t\t\t\t val & MDIO_AN_RX_LP_STAT1_1000BASET_FULL);\n\t\tlinkmode_mod_bit(ETHTOOL_LINK_MODE_1000baseT_Half_BIT,\n\t\t\t\t phydev->lp_advertising,\n\t\t\t\t val & MDIO_AN_RX_LP_STAT1_1000BASET_HALF);\n\t}\n\n\treturn genphy_c45_read_status(phydev);\n}\n\nstatic int aqr107_read_rate(struct phy_device *phydev)\n{\n\tu32 config_reg;\n\tint val;\n\n\tval = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_TX_VEND_STATUS1);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (val & MDIO_AN_TX_VEND_STATUS1_FULL_DUPLEX)\n\t\tphydev->duplex = DUPLEX_FULL;\n\telse\n\t\tphydev->duplex = DUPLEX_HALF;\n\n\tswitch (FIELD_GET(MDIO_AN_TX_VEND_STATUS1_RATE_MASK, val)) {\n\tcase MDIO_AN_TX_VEND_STATUS1_10BASET:\n\t\tphydev->speed = SPEED_10;\n\t\tconfig_reg = VEND1_GLOBAL_CFG_10M;\n\t\tbreak;\n\tcase MDIO_AN_TX_VEND_STATUS1_100BASETX:\n\t\tphydev->speed = SPEED_100;\n\t\tconfig_reg = VEND1_GLOBAL_CFG_100M;\n\t\tbreak;\n\tcase MDIO_AN_TX_VEND_STATUS1_1000BASET:\n\t\tphydev->speed = SPEED_1000;\n\t\tconfig_reg = VEND1_GLOBAL_CFG_1G;\n\t\tbreak;\n\tcase MDIO_AN_TX_VEND_STATUS1_2500BASET:\n\t\tphydev->speed = SPEED_2500;\n\t\tconfig_reg = VEND1_GLOBAL_CFG_2_5G;\n\t\tbreak;\n\tcase MDIO_AN_TX_VEND_STATUS1_5000BASET:\n\t\tphydev->speed = SPEED_5000;\n\t\tconfig_reg = VEND1_GLOBAL_CFG_5G;\n\t\tbreak;\n\tcase MDIO_AN_TX_VEND_STATUS1_10GBASET:\n\t\tphydev->speed = SPEED_10000;\n\t\tconfig_reg = VEND1_GLOBAL_CFG_10G;\n\t\tbreak;\n\tdefault:\n\t\tphydev->speed = SPEED_UNKNOWN;\n\t\treturn 0;\n\t}\n\n\tval = phy_read_mmd(phydev, MDIO_MMD_VEND1, config_reg);\n\tif (val < 0)\n\t\treturn val;\n\n\tif (FIELD_GET(VEND1_GLOBAL_CFG_RATE_ADAPT, val) ==\n\t    VEND1_GLOBAL_CFG_RATE_ADAPT_PAUSE)\n\t\tphydev->rate_matching = RATE_MATCH_PAUSE;\n\telse\n\t\tphydev->rate_matching = RATE_MATCH_NONE;\n\n\treturn 0;\n}\n\nstatic int aqr107_read_status(struct phy_device *phydev)\n{\n\tint val, ret;\n\n\tret = aqr_read_status(phydev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!phydev->link || phydev->autoneg == AUTONEG_DISABLE)\n\t\treturn 0;\n\n\tval = phy_read_mmd(phydev, MDIO_MMD_PHYXS, MDIO_PHYXS_VEND_IF_STATUS);\n\tif (val < 0)\n\t\treturn val;\n\n\tswitch (FIELD_GET(MDIO_PHYXS_VEND_IF_STATUS_TYPE_MASK, val)) {\n\tcase MDIO_PHYXS_VEND_IF_STATUS_TYPE_KR:\n\t\tphydev->interface = PHY_INTERFACE_MODE_10GKR;\n\t\tbreak;\n\tcase MDIO_PHYXS_VEND_IF_STATUS_TYPE_KX:\n\t\tphydev->interface = PHY_INTERFACE_MODE_1000BASEKX;\n\t\tbreak;\n\tcase MDIO_PHYXS_VEND_IF_STATUS_TYPE_XFI:\n\t\tphydev->interface = PHY_INTERFACE_MODE_10GBASER;\n\t\tbreak;\n\tcase MDIO_PHYXS_VEND_IF_STATUS_TYPE_USXGMII:\n\t\tphydev->interface = PHY_INTERFACE_MODE_USXGMII;\n\t\tbreak;\n\tcase MDIO_PHYXS_VEND_IF_STATUS_TYPE_XAUI:\n\t\tphydev->interface = PHY_INTERFACE_MODE_XAUI;\n\t\tbreak;\n\tcase MDIO_PHYXS_VEND_IF_STATUS_TYPE_SGMII:\n\t\tphydev->interface = PHY_INTERFACE_MODE_SGMII;\n\t\tbreak;\n\tcase MDIO_PHYXS_VEND_IF_STATUS_TYPE_RXAUI:\n\t\tphydev->interface = PHY_INTERFACE_MODE_RXAUI;\n\t\tbreak;\n\tcase MDIO_PHYXS_VEND_IF_STATUS_TYPE_OCSGMII:\n\t\tphydev->interface = PHY_INTERFACE_MODE_2500BASEX;\n\t\tbreak;\n\tdefault:\n\t\tphydev->interface = PHY_INTERFACE_MODE_NA;\n\t\tbreak;\n\t}\n\n\t \n\treturn aqr107_read_rate(phydev);\n}\n\nstatic int aqr107_get_downshift(struct phy_device *phydev, u8 *data)\n{\n\tint val, cnt, enable;\n\n\tval = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_VEND_PROV);\n\tif (val < 0)\n\t\treturn val;\n\n\tenable = FIELD_GET(MDIO_AN_VEND_PROV_DOWNSHIFT_EN, val);\n\tcnt = FIELD_GET(MDIO_AN_VEND_PROV_DOWNSHIFT_MASK, val);\n\n\t*data = enable && cnt ? cnt : DOWNSHIFT_DEV_DISABLE;\n\n\treturn 0;\n}\n\nstatic int aqr107_set_downshift(struct phy_device *phydev, u8 cnt)\n{\n\tint val = 0;\n\n\tif (!FIELD_FIT(MDIO_AN_VEND_PROV_DOWNSHIFT_MASK, cnt))\n\t\treturn -E2BIG;\n\n\tif (cnt != DOWNSHIFT_DEV_DISABLE) {\n\t\tval = MDIO_AN_VEND_PROV_DOWNSHIFT_EN;\n\t\tval |= FIELD_PREP(MDIO_AN_VEND_PROV_DOWNSHIFT_MASK, cnt);\n\t}\n\n\treturn phy_modify_mmd(phydev, MDIO_MMD_AN, MDIO_AN_VEND_PROV,\n\t\t\t      MDIO_AN_VEND_PROV_DOWNSHIFT_EN |\n\t\t\t      MDIO_AN_VEND_PROV_DOWNSHIFT_MASK, val);\n}\n\nstatic int aqr107_get_tunable(struct phy_device *phydev,\n\t\t\t      struct ethtool_tunable *tuna, void *data)\n{\n\tswitch (tuna->id) {\n\tcase ETHTOOL_PHY_DOWNSHIFT:\n\t\treturn aqr107_get_downshift(phydev, data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int aqr107_set_tunable(struct phy_device *phydev,\n\t\t\t      struct ethtool_tunable *tuna, const void *data)\n{\n\tswitch (tuna->id) {\n\tcase ETHTOOL_PHY_DOWNSHIFT:\n\t\treturn aqr107_set_downshift(phydev, *(const u8 *)data);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\n \nstatic int aqr107_wait_reset_complete(struct phy_device *phydev)\n{\n\tint val;\n\n\treturn phy_read_mmd_poll_timeout(phydev, MDIO_MMD_VEND1,\n\t\t\t\t\t VEND1_GLOBAL_FW_ID, val, val != 0,\n\t\t\t\t\t 20000, 2000000, false);\n}\n\nstatic void aqr107_chip_info(struct phy_device *phydev)\n{\n\tu8 fw_major, fw_minor, build_id, prov_id;\n\tint val;\n\n\tval = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_GLOBAL_FW_ID);\n\tif (val < 0)\n\t\treturn;\n\n\tfw_major = FIELD_GET(VEND1_GLOBAL_FW_ID_MAJOR, val);\n\tfw_minor = FIELD_GET(VEND1_GLOBAL_FW_ID_MINOR, val);\n\n\tval = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_GLOBAL_RSVD_STAT1);\n\tif (val < 0)\n\t\treturn;\n\n\tbuild_id = FIELD_GET(VEND1_GLOBAL_RSVD_STAT1_FW_BUILD_ID, val);\n\tprov_id = FIELD_GET(VEND1_GLOBAL_RSVD_STAT1_PROV_ID, val);\n\n\tphydev_dbg(phydev, \"FW %u.%u, Build %u, Provisioning %u\\n\",\n\t\t   fw_major, fw_minor, build_id, prov_id);\n}\n\nstatic int aqr107_config_init(struct phy_device *phydev)\n{\n\tint ret;\n\n\t \n\tif (phydev->interface != PHY_INTERFACE_MODE_SGMII &&\n\t    phydev->interface != PHY_INTERFACE_MODE_1000BASEKX &&\n\t    phydev->interface != PHY_INTERFACE_MODE_2500BASEX &&\n\t    phydev->interface != PHY_INTERFACE_MODE_XGMII &&\n\t    phydev->interface != PHY_INTERFACE_MODE_USXGMII &&\n\t    phydev->interface != PHY_INTERFACE_MODE_10GKR &&\n\t    phydev->interface != PHY_INTERFACE_MODE_10GBASER &&\n\t    phydev->interface != PHY_INTERFACE_MODE_XAUI &&\n\t    phydev->interface != PHY_INTERFACE_MODE_RXAUI)\n\t\treturn -ENODEV;\n\n\tWARN(phydev->interface == PHY_INTERFACE_MODE_XGMII,\n\t     \"Your devicetree is out of date, please update it. The AQR107 family doesn't support XGMII, maybe you mean USXGMII.\\n\");\n\n\tret = aqr107_wait_reset_complete(phydev);\n\tif (!ret)\n\t\taqr107_chip_info(phydev);\n\n\treturn aqr107_set_downshift(phydev, MDIO_AN_VEND_PROV_DOWNSHIFT_DFLT);\n}\n\nstatic int aqcs109_config_init(struct phy_device *phydev)\n{\n\tint ret;\n\n\t \n\tif (phydev->interface != PHY_INTERFACE_MODE_SGMII &&\n\t    phydev->interface != PHY_INTERFACE_MODE_2500BASEX)\n\t\treturn -ENODEV;\n\n\tret = aqr107_wait_reset_complete(phydev);\n\tif (!ret)\n\t\taqr107_chip_info(phydev);\n\n\t \n\tphy_set_max_speed(phydev, SPEED_2500);\n\n\treturn aqr107_set_downshift(phydev, MDIO_AN_VEND_PROV_DOWNSHIFT_DFLT);\n}\n\nstatic void aqr107_link_change_notify(struct phy_device *phydev)\n{\n\tu8 fw_major, fw_minor;\n\tbool downshift, short_reach, afr;\n\tint mode, val;\n\n\tif (phydev->state != PHY_RUNNING || phydev->autoneg == AUTONEG_DISABLE)\n\t\treturn;\n\n\tval = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_RX_LP_STAT1);\n\t \n\tif (val < 0 || !(val & MDIO_AN_RX_LP_STAT1_AQ_PHY))\n\t\treturn;\n\n\tshort_reach = val & MDIO_AN_RX_LP_STAT1_SHORT_REACH;\n\tdownshift = val & MDIO_AN_RX_LP_STAT1_AQRATE_DOWNSHIFT;\n\n\tval = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_RX_LP_STAT4);\n\tif (val < 0)\n\t\treturn;\n\n\tfw_major = FIELD_GET(MDIO_AN_RX_LP_STAT4_FW_MAJOR, val);\n\tfw_minor = FIELD_GET(MDIO_AN_RX_LP_STAT4_FW_MINOR, val);\n\n\tval = phy_read_mmd(phydev, MDIO_MMD_AN, MDIO_AN_RX_VEND_STAT3);\n\tif (val < 0)\n\t\treturn;\n\n\tafr = val & MDIO_AN_RX_VEND_STAT3_AFR;\n\n\tphydev_dbg(phydev, \"Link partner is Aquantia PHY, FW %u.%u%s%s%s\\n\",\n\t\t   fw_major, fw_minor,\n\t\t   short_reach ? \", short reach mode\" : \"\",\n\t\t   downshift ? \", fast-retrain downshift advertised\" : \"\",\n\t\t   afr ? \", fast reframe advertised\" : \"\");\n\n\tval = phy_read_mmd(phydev, MDIO_MMD_VEND1, VEND1_GLOBAL_RSVD_STAT9);\n\tif (val < 0)\n\t\treturn;\n\n\tmode = FIELD_GET(VEND1_GLOBAL_RSVD_STAT9_MODE, val);\n\tif (mode == VEND1_GLOBAL_RSVD_STAT9_1000BT2)\n\t\tphydev_info(phydev, \"Aquantia 1000Base-T2 mode active\\n\");\n}\n\nstatic int aqr107_wait_processor_intensive_op(struct phy_device *phydev)\n{\n\tint val, err;\n\n\t \n\tusleep_range(1000, 5000);\n\n\terr = phy_read_mmd_poll_timeout(phydev, MDIO_MMD_VEND1,\n\t\t\t\t\tVEND1_GLOBAL_GEN_STAT2, val,\n\t\t\t\t\t!(val & VEND1_GLOBAL_GEN_STAT2_OP_IN_PROG),\n\t\t\t\t\tAQR107_OP_IN_PROG_SLEEP,\n\t\t\t\t\tAQR107_OP_IN_PROG_TIMEOUT, false);\n\tif (err) {\n\t\tphydev_err(phydev, \"timeout: processor-intensive MDIO operation\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int aqr107_get_rate_matching(struct phy_device *phydev,\n\t\t\t\t    phy_interface_t iface)\n{\n\tif (iface == PHY_INTERFACE_MODE_10GBASER ||\n\t    iface == PHY_INTERFACE_MODE_2500BASEX ||\n\t    iface == PHY_INTERFACE_MODE_NA)\n\t\treturn RATE_MATCH_PAUSE;\n\treturn RATE_MATCH_NONE;\n}\n\nstatic int aqr107_suspend(struct phy_device *phydev)\n{\n\tint err;\n\n\terr = phy_set_bits_mmd(phydev, MDIO_MMD_VEND1, MDIO_CTRL1,\n\t\t\t       MDIO_CTRL1_LPOWER);\n\tif (err)\n\t\treturn err;\n\n\treturn aqr107_wait_processor_intensive_op(phydev);\n}\n\nstatic int aqr107_resume(struct phy_device *phydev)\n{\n\tint err;\n\n\terr = phy_clear_bits_mmd(phydev, MDIO_MMD_VEND1, MDIO_CTRL1,\n\t\t\t\t MDIO_CTRL1_LPOWER);\n\tif (err)\n\t\treturn err;\n\n\treturn aqr107_wait_processor_intensive_op(phydev);\n}\n\nstatic int aqr107_probe(struct phy_device *phydev)\n{\n\tphydev->priv = devm_kzalloc(&phydev->mdio.dev,\n\t\t\t\t    sizeof(struct aqr107_priv), GFP_KERNEL);\n\tif (!phydev->priv)\n\t\treturn -ENOMEM;\n\n\treturn aqr_hwmon_probe(phydev);\n}\n\nstatic struct phy_driver aqr_driver[] = {\n{\n\tPHY_ID_MATCH_MODEL(PHY_ID_AQ1202),\n\t.name\t\t= \"Aquantia AQ1202\",\n\t.config_aneg    = aqr_config_aneg,\n\t.config_intr\t= aqr_config_intr,\n\t.handle_interrupt = aqr_handle_interrupt,\n\t.read_status\t= aqr_read_status,\n},\n{\n\tPHY_ID_MATCH_MODEL(PHY_ID_AQ2104),\n\t.name\t\t= \"Aquantia AQ2104\",\n\t.config_aneg    = aqr_config_aneg,\n\t.config_intr\t= aqr_config_intr,\n\t.handle_interrupt = aqr_handle_interrupt,\n\t.read_status\t= aqr_read_status,\n},\n{\n\tPHY_ID_MATCH_MODEL(PHY_ID_AQR105),\n\t.name\t\t= \"Aquantia AQR105\",\n\t.config_aneg    = aqr_config_aneg,\n\t.config_intr\t= aqr_config_intr,\n\t.handle_interrupt = aqr_handle_interrupt,\n\t.read_status\t= aqr_read_status,\n\t.suspend\t= aqr107_suspend,\n\t.resume\t\t= aqr107_resume,\n},\n{\n\tPHY_ID_MATCH_MODEL(PHY_ID_AQR106),\n\t.name\t\t= \"Aquantia AQR106\",\n\t.config_aneg    = aqr_config_aneg,\n\t.config_intr\t= aqr_config_intr,\n\t.handle_interrupt = aqr_handle_interrupt,\n\t.read_status\t= aqr_read_status,\n},\n{\n\tPHY_ID_MATCH_MODEL(PHY_ID_AQR107),\n\t.name\t\t= \"Aquantia AQR107\",\n\t.probe\t\t= aqr107_probe,\n\t.get_rate_matching = aqr107_get_rate_matching,\n\t.config_init\t= aqr107_config_init,\n\t.config_aneg    = aqr_config_aneg,\n\t.config_intr\t= aqr_config_intr,\n\t.handle_interrupt = aqr_handle_interrupt,\n\t.read_status\t= aqr107_read_status,\n\t.get_tunable    = aqr107_get_tunable,\n\t.set_tunable    = aqr107_set_tunable,\n\t.suspend\t= aqr107_suspend,\n\t.resume\t\t= aqr107_resume,\n\t.get_sset_count\t= aqr107_get_sset_count,\n\t.get_strings\t= aqr107_get_strings,\n\t.get_stats\t= aqr107_get_stats,\n\t.link_change_notify = aqr107_link_change_notify,\n},\n{\n\tPHY_ID_MATCH_MODEL(PHY_ID_AQCS109),\n\t.name\t\t= \"Aquantia AQCS109\",\n\t.probe\t\t= aqr107_probe,\n\t.get_rate_matching = aqr107_get_rate_matching,\n\t.config_init\t= aqcs109_config_init,\n\t.config_aneg    = aqr_config_aneg,\n\t.config_intr\t= aqr_config_intr,\n\t.handle_interrupt = aqr_handle_interrupt,\n\t.read_status\t= aqr107_read_status,\n\t.get_tunable    = aqr107_get_tunable,\n\t.set_tunable    = aqr107_set_tunable,\n\t.suspend\t= aqr107_suspend,\n\t.resume\t\t= aqr107_resume,\n\t.get_sset_count\t= aqr107_get_sset_count,\n\t.get_strings\t= aqr107_get_strings,\n\t.get_stats\t= aqr107_get_stats,\n\t.link_change_notify = aqr107_link_change_notify,\n},\n{\n\tPHY_ID_MATCH_MODEL(PHY_ID_AQR405),\n\t.name\t\t= \"Aquantia AQR405\",\n\t.config_aneg    = aqr_config_aneg,\n\t.config_intr\t= aqr_config_intr,\n\t.handle_interrupt = aqr_handle_interrupt,\n\t.read_status\t= aqr_read_status,\n},\n{\n\tPHY_ID_MATCH_MODEL(PHY_ID_AQR112),\n\t.name\t\t= \"Aquantia AQR112\",\n\t.probe\t\t= aqr107_probe,\n\t.config_aneg    = aqr_config_aneg,\n\t.config_intr\t= aqr_config_intr,\n\t.handle_interrupt = aqr_handle_interrupt,\n\t.get_tunable    = aqr107_get_tunable,\n\t.set_tunable    = aqr107_set_tunable,\n\t.suspend\t= aqr107_suspend,\n\t.resume\t\t= aqr107_resume,\n\t.read_status\t= aqr107_read_status,\n\t.get_rate_matching = aqr107_get_rate_matching,\n\t.get_sset_count = aqr107_get_sset_count,\n\t.get_strings\t= aqr107_get_strings,\n\t.get_stats\t= aqr107_get_stats,\n\t.link_change_notify = aqr107_link_change_notify,\n},\n{\n\tPHY_ID_MATCH_MODEL(PHY_ID_AQR412),\n\t.name\t\t= \"Aquantia AQR412\",\n\t.probe\t\t= aqr107_probe,\n\t.config_aneg    = aqr_config_aneg,\n\t.config_intr\t= aqr_config_intr,\n\t.handle_interrupt = aqr_handle_interrupt,\n\t.get_tunable    = aqr107_get_tunable,\n\t.set_tunable    = aqr107_set_tunable,\n\t.suspend\t= aqr107_suspend,\n\t.resume\t\t= aqr107_resume,\n\t.read_status\t= aqr107_read_status,\n\t.get_rate_matching = aqr107_get_rate_matching,\n\t.get_sset_count = aqr107_get_sset_count,\n\t.get_strings\t= aqr107_get_strings,\n\t.get_stats\t= aqr107_get_stats,\n\t.link_change_notify = aqr107_link_change_notify,\n},\n{\n\tPHY_ID_MATCH_MODEL(PHY_ID_AQR113C),\n\t.name           = \"Aquantia AQR113C\",\n\t.probe          = aqr107_probe,\n\t.get_rate_matching = aqr107_get_rate_matching,\n\t.config_init    = aqr107_config_init,\n\t.config_aneg    = aqr_config_aneg,\n\t.config_intr    = aqr_config_intr,\n\t.handle_interrupt       = aqr_handle_interrupt,\n\t.read_status    = aqr107_read_status,\n\t.get_tunable    = aqr107_get_tunable,\n\t.set_tunable    = aqr107_set_tunable,\n\t.suspend        = aqr107_suspend,\n\t.resume         = aqr107_resume,\n\t.get_sset_count = aqr107_get_sset_count,\n\t.get_strings    = aqr107_get_strings,\n\t.get_stats      = aqr107_get_stats,\n\t.link_change_notify = aqr107_link_change_notify,\n},\n};\n\nmodule_phy_driver(aqr_driver);\n\nstatic struct mdio_device_id __maybe_unused aqr_tbl[] = {\n\t{ PHY_ID_MATCH_MODEL(PHY_ID_AQ1202) },\n\t{ PHY_ID_MATCH_MODEL(PHY_ID_AQ2104) },\n\t{ PHY_ID_MATCH_MODEL(PHY_ID_AQR105) },\n\t{ PHY_ID_MATCH_MODEL(PHY_ID_AQR106) },\n\t{ PHY_ID_MATCH_MODEL(PHY_ID_AQR107) },\n\t{ PHY_ID_MATCH_MODEL(PHY_ID_AQCS109) },\n\t{ PHY_ID_MATCH_MODEL(PHY_ID_AQR405) },\n\t{ PHY_ID_MATCH_MODEL(PHY_ID_AQR112) },\n\t{ PHY_ID_MATCH_MODEL(PHY_ID_AQR412) },\n\t{ PHY_ID_MATCH_MODEL(PHY_ID_AQR113C) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(mdio, aqr_tbl);\n\nMODULE_DESCRIPTION(\"Aquantia PHY driver\");\nMODULE_AUTHOR(\"Shaohui Xie <Shaohui.Xie@freescale.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}