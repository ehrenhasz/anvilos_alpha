{
  "module_name": "sfp-bus.c",
  "hash_id": "8435d20b5dec9dfc99ba1dad38a935acaa9699b35552ffd4599327b0267c2620",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/phy/sfp-bus.c",
  "human_readable_source": "\n#include <linux/export.h>\n#include <linux/kref.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/phylink.h>\n#include <linux/property.h>\n#include <linux/rtnetlink.h>\n#include <linux/slab.h>\n\n#include \"sfp.h\"\n\n \nstruct sfp_bus {\n\t \n\tstruct kref kref;\n\tstruct list_head node;\n\tconst struct fwnode_handle *fwnode;\n\n\tconst struct sfp_socket_ops *socket_ops;\n\tstruct device *sfp_dev;\n\tstruct sfp *sfp;\n\tconst struct sfp_quirk *sfp_quirk;\n\n\tconst struct sfp_upstream_ops *upstream_ops;\n\tvoid *upstream;\n\tstruct phy_device *phydev;\n\n\tbool registered;\n\tbool started;\n};\n\n \nint sfp_parse_port(struct sfp_bus *bus, const struct sfp_eeprom_id *id,\n\t\t   unsigned long *support)\n{\n\tint port;\n\n\t \n\tswitch (id->base.connector) {\n\tcase SFF8024_CONNECTOR_SC:\n\tcase SFF8024_CONNECTOR_FIBERJACK:\n\tcase SFF8024_CONNECTOR_LC:\n\tcase SFF8024_CONNECTOR_MT_RJ:\n\tcase SFF8024_CONNECTOR_MU:\n\tcase SFF8024_CONNECTOR_OPTICAL_PIGTAIL:\n\tcase SFF8024_CONNECTOR_MPO_1X12:\n\tcase SFF8024_CONNECTOR_MPO_2X16:\n\t\tport = PORT_FIBRE;\n\t\tbreak;\n\n\tcase SFF8024_CONNECTOR_RJ45:\n\t\tport = PORT_TP;\n\t\tbreak;\n\n\tcase SFF8024_CONNECTOR_COPPER_PIGTAIL:\n\t\tport = PORT_DA;\n\t\tbreak;\n\n\tcase SFF8024_CONNECTOR_UNSPEC:\n\t\tif (id->base.e1000_base_t) {\n\t\t\tport = PORT_TP;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase SFF8024_CONNECTOR_SG:  \n\tcase SFF8024_CONNECTOR_HSSDC_II:\n\tcase SFF8024_CONNECTOR_NOSEPARATE:\n\tcase SFF8024_CONNECTOR_MXC_2X16:\n\t\tport = PORT_OTHER;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(bus->sfp_dev, \"SFP: unknown connector id 0x%02x\\n\",\n\t\t\t id->base.connector);\n\t\tport = PORT_OTHER;\n\t\tbreak;\n\t}\n\n\tif (support) {\n\t\tswitch (port) {\n\t\tcase PORT_FIBRE:\n\t\t\tphylink_set(support, FIBRE);\n\t\t\tbreak;\n\n\t\tcase PORT_TP:\n\t\t\tphylink_set(support, TP);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn port;\n}\nEXPORT_SYMBOL_GPL(sfp_parse_port);\n\n \nbool sfp_may_have_phy(struct sfp_bus *bus, const struct sfp_eeprom_id *id)\n{\n\tif (id->base.e1000_base_t)\n\t\treturn true;\n\n\tif (id->base.phys_id != SFF8024_ID_DWDM_SFP) {\n\t\tswitch (id->base.extended_cc) {\n\t\tcase SFF8024_ECC_10GBASE_T_SFI:\n\t\tcase SFF8024_ECC_10GBASE_T_SR:\n\t\tcase SFF8024_ECC_5GBASE_T:\n\t\tcase SFF8024_ECC_2_5GBASE_T:\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(sfp_may_have_phy);\n\n \nvoid sfp_parse_support(struct sfp_bus *bus, const struct sfp_eeprom_id *id,\n\t\t       unsigned long *support, unsigned long *interfaces)\n{\n\tunsigned int br_min, br_nom, br_max;\n\t__ETHTOOL_DECLARE_LINK_MODE_MASK(modes) = { 0, };\n\n\tphylink_set(modes, Autoneg);\n\tphylink_set(modes, Pause);\n\tphylink_set(modes, Asym_Pause);\n\n\t \n\tbr_min = br_nom = br_max = 0;\n\tif (id->base.br_nominal) {\n\t\tif (id->base.br_nominal != 255) {\n\t\t\tbr_nom = id->base.br_nominal * 100;\n\t\t\tbr_min = br_nom - id->base.br_nominal * id->ext.br_min;\n\t\t\tbr_max = br_nom + id->base.br_nominal * id->ext.br_max;\n\t\t} else if (id->ext.br_max) {\n\t\t\tbr_nom = 250 * id->ext.br_max;\n\t\t\tbr_max = br_nom + br_nom * id->ext.br_min / 100;\n\t\t\tbr_min = br_nom - br_nom * id->ext.br_min / 100;\n\t\t}\n\n\t\t \n\t\tif (br_min == br_max && id->base.sfp_ct_passive)\n\t\t\tbr_min = 0;\n\t}\n\n\t \n\tif (id->base.e10g_base_sr) {\n\t\tphylink_set(modes, 10000baseSR_Full);\n\t\t__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);\n\t}\n\tif (id->base.e10g_base_lr) {\n\t\tphylink_set(modes, 10000baseLR_Full);\n\t\t__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);\n\t}\n\tif (id->base.e10g_base_lrm) {\n\t\tphylink_set(modes, 10000baseLRM_Full);\n\t\t__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);\n\t}\n\tif (id->base.e10g_base_er) {\n\t\tphylink_set(modes, 10000baseER_Full);\n\t\t__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);\n\t}\n\tif (id->base.e1000_base_sx ||\n\t    id->base.e1000_base_lx ||\n\t    id->base.e1000_base_cx) {\n\t\tphylink_set(modes, 1000baseX_Full);\n\t\t__set_bit(PHY_INTERFACE_MODE_1000BASEX, interfaces);\n\t}\n\tif (id->base.e1000_base_t) {\n\t\tphylink_set(modes, 1000baseT_Half);\n\t\tphylink_set(modes, 1000baseT_Full);\n\t\t__set_bit(PHY_INTERFACE_MODE_1000BASEX, interfaces);\n\t\t__set_bit(PHY_INTERFACE_MODE_SGMII, interfaces);\n\t}\n\n\t \n\tif ((id->base.e_base_px || id->base.e_base_bx10) &&\n\t    br_min <= 1300 && br_max >= 1200) {\n\t\tphylink_set(modes, 1000baseX_Full);\n\t\t__set_bit(PHY_INTERFACE_MODE_1000BASEX, interfaces);\n\t}\n\n\t \n\tif (id->base.e100_base_fx || id->base.e100_base_lx) {\n\t\tphylink_set(modes, 100baseFX_Full);\n\t\t__set_bit(PHY_INTERFACE_MODE_100BASEX, interfaces);\n\t}\n\tif ((id->base.e_base_px || id->base.e_base_bx10) && br_nom == 100) {\n\t\tphylink_set(modes, 100baseFX_Full);\n\t\t__set_bit(PHY_INTERFACE_MODE_100BASEX, interfaces);\n\t}\n\n\t \n\tif ((id->base.sfp_ct_passive || id->base.sfp_ct_active) && br_nom) {\n\t\t \n\t\tif (br_min <= 12000 && br_max >= 10300) {\n\t\t\tphylink_set(modes, 10000baseCR_Full);\n\t\t\t__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);\n\t\t}\n\t\tif (br_min <= 3200 && br_max >= 3100) {\n\t\t\tphylink_set(modes, 2500baseX_Full);\n\t\t\t__set_bit(PHY_INTERFACE_MODE_2500BASEX, interfaces);\n\t\t}\n\t\tif (br_min <= 1300 && br_max >= 1200) {\n\t\t\tphylink_set(modes, 1000baseX_Full);\n\t\t\t__set_bit(PHY_INTERFACE_MODE_1000BASEX, interfaces);\n\t\t}\n\t}\n\tif (id->base.sfp_ct_passive) {\n\t\tif (id->base.passive.sff8431_app_e) {\n\t\t\tphylink_set(modes, 10000baseCR_Full);\n\t\t\t__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);\n\t\t}\n\t}\n\tif (id->base.sfp_ct_active) {\n\t\tif (id->base.active.sff8431_app_e ||\n\t\t    id->base.active.sff8431_lim) {\n\t\t\tphylink_set(modes, 10000baseCR_Full);\n\t\t\t__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);\n\t\t}\n\t}\n\n\tswitch (id->base.extended_cc) {\n\tcase SFF8024_ECC_UNSPEC:\n\t\tbreak;\n\tcase SFF8024_ECC_100G_25GAUI_C2M_AOC:\n\t\tif (br_min <= 28000 && br_max >= 25000) {\n\t\t\t \n\t\t\t__set_bit(PHY_INTERFACE_MODE_25GBASER, interfaces);\n\t\t\t \n\t\t\tphylink_set(modes, 25000baseSR_Full);\n\t\t}\n\t\tbreak;\n\tcase SFF8024_ECC_100GBASE_SR4_25GBASE_SR:\n\t\tphylink_set(modes, 100000baseSR4_Full);\n\t\tphylink_set(modes, 25000baseSR_Full);\n\t\t__set_bit(PHY_INTERFACE_MODE_25GBASER, interfaces);\n\t\tbreak;\n\tcase SFF8024_ECC_100GBASE_LR4_25GBASE_LR:\n\tcase SFF8024_ECC_100GBASE_ER4_25GBASE_ER:\n\t\tphylink_set(modes, 100000baseLR4_ER4_Full);\n\t\tbreak;\n\tcase SFF8024_ECC_100GBASE_CR4:\n\t\tphylink_set(modes, 100000baseCR4_Full);\n\t\tfallthrough;\n\tcase SFF8024_ECC_25GBASE_CR_S:\n\tcase SFF8024_ECC_25GBASE_CR_N:\n\t\tphylink_set(modes, 25000baseCR_Full);\n\t\t__set_bit(PHY_INTERFACE_MODE_25GBASER, interfaces);\n\t\tbreak;\n\tcase SFF8024_ECC_10GBASE_T_SFI:\n\tcase SFF8024_ECC_10GBASE_T_SR:\n\t\tphylink_set(modes, 10000baseT_Full);\n\t\t__set_bit(PHY_INTERFACE_MODE_10GBASER, interfaces);\n\t\tbreak;\n\tcase SFF8024_ECC_5GBASE_T:\n\t\tphylink_set(modes, 5000baseT_Full);\n\t\t__set_bit(PHY_INTERFACE_MODE_5GBASER, interfaces);\n\t\tbreak;\n\tcase SFF8024_ECC_2_5GBASE_T:\n\t\tphylink_set(modes, 2500baseT_Full);\n\t\t__set_bit(PHY_INTERFACE_MODE_2500BASEX, interfaces);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(bus->sfp_dev,\n\t\t\t \"Unknown/unsupported extended compliance code: 0x%02x\\n\",\n\t\t\t id->base.extended_cc);\n\t\tbreak;\n\t}\n\n\t \n\tif (id->base.fc_speed_100 ||\n\t    id->base.fc_speed_200 ||\n\t    id->base.fc_speed_400) {\n\t\tif (id->base.br_nominal >= 31) {\n\t\t\tphylink_set(modes, 2500baseX_Full);\n\t\t\t__set_bit(PHY_INTERFACE_MODE_2500BASEX, interfaces);\n\t\t}\n\t\tif (id->base.br_nominal >= 12) {\n\t\t\tphylink_set(modes, 1000baseX_Full);\n\t\t\t__set_bit(PHY_INTERFACE_MODE_1000BASEX, interfaces);\n\t\t}\n\t}\n\n\t \n\tif (bitmap_empty(modes, __ETHTOOL_LINK_MODE_MASK_NBITS) && br_nom) {\n\t\tif (br_min <= 1300 && br_max >= 1200) {\n\t\t\tphylink_set(modes, 1000baseX_Full);\n\t\t\t__set_bit(PHY_INTERFACE_MODE_1000BASEX, interfaces);\n\t\t}\n\t\tif (br_min <= 3200 && br_max >= 2500) {\n\t\t\tphylink_set(modes, 2500baseX_Full);\n\t\t\t__set_bit(PHY_INTERFACE_MODE_2500BASEX, interfaces);\n\t\t}\n\t}\n\n\tif (bus->sfp_quirk && bus->sfp_quirk->modes)\n\t\tbus->sfp_quirk->modes(id, modes, interfaces);\n\n\tlinkmode_or(support, support, modes);\n}\nEXPORT_SYMBOL_GPL(sfp_parse_support);\n\n \nphy_interface_t sfp_select_interface(struct sfp_bus *bus,\n\t\t\t\t     unsigned long *link_modes)\n{\n\tif (phylink_test(link_modes, 25000baseCR_Full) ||\n\t    phylink_test(link_modes, 25000baseKR_Full) ||\n\t    phylink_test(link_modes, 25000baseSR_Full))\n\t\treturn PHY_INTERFACE_MODE_25GBASER;\n\n\tif (phylink_test(link_modes, 10000baseCR_Full) ||\n\t    phylink_test(link_modes, 10000baseSR_Full) ||\n\t    phylink_test(link_modes, 10000baseLR_Full) ||\n\t    phylink_test(link_modes, 10000baseLRM_Full) ||\n\t    phylink_test(link_modes, 10000baseER_Full) ||\n\t    phylink_test(link_modes, 10000baseT_Full))\n\t\treturn PHY_INTERFACE_MODE_10GBASER;\n\n\tif (phylink_test(link_modes, 5000baseT_Full))\n\t\treturn PHY_INTERFACE_MODE_5GBASER;\n\n\tif (phylink_test(link_modes, 2500baseX_Full))\n\t\treturn PHY_INTERFACE_MODE_2500BASEX;\n\n\tif (phylink_test(link_modes, 1000baseT_Half) ||\n\t    phylink_test(link_modes, 1000baseT_Full))\n\t\treturn PHY_INTERFACE_MODE_SGMII;\n\n\tif (phylink_test(link_modes, 1000baseX_Full))\n\t\treturn PHY_INTERFACE_MODE_1000BASEX;\n\n\tif (phylink_test(link_modes, 100baseFX_Full))\n\t\treturn PHY_INTERFACE_MODE_100BASEX;\n\n\tdev_warn(bus->sfp_dev, \"Unable to ascertain link mode\\n\");\n\n\treturn PHY_INTERFACE_MODE_NA;\n}\nEXPORT_SYMBOL_GPL(sfp_select_interface);\n\nstatic LIST_HEAD(sfp_buses);\nstatic DEFINE_MUTEX(sfp_mutex);\n\nstatic const struct sfp_upstream_ops *sfp_get_upstream_ops(struct sfp_bus *bus)\n{\n\treturn bus->registered ? bus->upstream_ops : NULL;\n}\n\nstatic struct sfp_bus *sfp_bus_get(const struct fwnode_handle *fwnode)\n{\n\tstruct sfp_bus *sfp, *new, *found = NULL;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\n\tmutex_lock(&sfp_mutex);\n\n\tlist_for_each_entry(sfp, &sfp_buses, node) {\n\t\tif (sfp->fwnode == fwnode) {\n\t\t\tkref_get(&sfp->kref);\n\t\t\tfound = sfp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found && new) {\n\t\tkref_init(&new->kref);\n\t\tnew->fwnode = fwnode;\n\t\tlist_add(&new->node, &sfp_buses);\n\t\tfound = new;\n\t\tnew = NULL;\n\t}\n\n\tmutex_unlock(&sfp_mutex);\n\n\tkfree(new);\n\n\treturn found;\n}\n\nstatic void sfp_bus_release(struct kref *kref)\n{\n\tstruct sfp_bus *bus = container_of(kref, struct sfp_bus, kref);\n\n\tlist_del(&bus->node);\n\tmutex_unlock(&sfp_mutex);\n\tkfree(bus);\n}\n\n \nvoid sfp_bus_put(struct sfp_bus *bus)\n{\n\tif (bus)\n\t\tkref_put_mutex(&bus->kref, sfp_bus_release, &sfp_mutex);\n}\nEXPORT_SYMBOL_GPL(sfp_bus_put);\n\nstatic int sfp_register_bus(struct sfp_bus *bus)\n{\n\tconst struct sfp_upstream_ops *ops = bus->upstream_ops;\n\tint ret;\n\n\tif (ops) {\n\t\tif (ops->link_down)\n\t\t\tops->link_down(bus->upstream);\n\t\tif (ops->connect_phy && bus->phydev) {\n\t\t\tret = ops->connect_phy(bus->upstream, bus->phydev);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\tbus->registered = true;\n\tbus->socket_ops->attach(bus->sfp);\n\tif (bus->started)\n\t\tbus->socket_ops->start(bus->sfp);\n\tbus->upstream_ops->attach(bus->upstream, bus);\n\treturn 0;\n}\n\nstatic void sfp_unregister_bus(struct sfp_bus *bus)\n{\n\tconst struct sfp_upstream_ops *ops = bus->upstream_ops;\n\n\tif (bus->registered) {\n\t\tbus->upstream_ops->detach(bus->upstream, bus);\n\t\tif (bus->started)\n\t\t\tbus->socket_ops->stop(bus->sfp);\n\t\tbus->socket_ops->detach(bus->sfp);\n\t\tif (bus->phydev && ops && ops->disconnect_phy)\n\t\t\tops->disconnect_phy(bus->upstream);\n\t}\n\tbus->registered = false;\n}\n\n \nint sfp_get_module_info(struct sfp_bus *bus, struct ethtool_modinfo *modinfo)\n{\n\treturn bus->socket_ops->module_info(bus->sfp, modinfo);\n}\nEXPORT_SYMBOL_GPL(sfp_get_module_info);\n\n \nint sfp_get_module_eeprom(struct sfp_bus *bus, struct ethtool_eeprom *ee,\n\t\t\t  u8 *data)\n{\n\treturn bus->socket_ops->module_eeprom(bus->sfp, ee, data);\n}\nEXPORT_SYMBOL_GPL(sfp_get_module_eeprom);\n\n \nint sfp_get_module_eeprom_by_page(struct sfp_bus *bus,\n\t\t\t\t  const struct ethtool_module_eeprom *page,\n\t\t\t\t  struct netlink_ext_ack *extack)\n{\n\treturn bus->socket_ops->module_eeprom_by_page(bus->sfp, page, extack);\n}\nEXPORT_SYMBOL_GPL(sfp_get_module_eeprom_by_page);\n\n \nvoid sfp_upstream_start(struct sfp_bus *bus)\n{\n\tif (bus->registered)\n\t\tbus->socket_ops->start(bus->sfp);\n\tbus->started = true;\n}\nEXPORT_SYMBOL_GPL(sfp_upstream_start);\n\n \nvoid sfp_upstream_stop(struct sfp_bus *bus)\n{\n\tif (bus->registered)\n\t\tbus->socket_ops->stop(bus->sfp);\n\tbus->started = false;\n}\nEXPORT_SYMBOL_GPL(sfp_upstream_stop);\n\nstatic void sfp_upstream_clear(struct sfp_bus *bus)\n{\n\tbus->upstream_ops = NULL;\n\tbus->upstream = NULL;\n}\n\n \nvoid sfp_upstream_set_signal_rate(struct sfp_bus *bus, unsigned int rate_kbd)\n{\n\tif (bus->registered)\n\t\tbus->socket_ops->set_signal_rate(bus->sfp, rate_kbd);\n}\nEXPORT_SYMBOL_GPL(sfp_upstream_set_signal_rate);\n\n \nstruct sfp_bus *sfp_bus_find_fwnode(const struct fwnode_handle *fwnode)\n{\n\tstruct fwnode_reference_args ref;\n\tstruct sfp_bus *bus;\n\tint ret;\n\n\tret = fwnode_property_get_reference_args(fwnode, \"sfp\", NULL,\n\t\t\t\t\t\t 0, 0, &ref);\n\tif (ret == -ENOENT)\n\t\treturn NULL;\n\telse if (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tif (!fwnode_device_is_available(ref.fwnode)) {\n\t\tfwnode_handle_put(ref.fwnode);\n\t\treturn NULL;\n\t}\n\n\tbus = sfp_bus_get(ref.fwnode);\n\tfwnode_handle_put(ref.fwnode);\n\tif (!bus)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn bus;\n}\nEXPORT_SYMBOL_GPL(sfp_bus_find_fwnode);\n\n \nint sfp_bus_add_upstream(struct sfp_bus *bus, void *upstream,\n\t\t\t const struct sfp_upstream_ops *ops)\n{\n\tint ret;\n\n\t \n\tif (!bus)\n\t\treturn 0;\n\n\trtnl_lock();\n\tkref_get(&bus->kref);\n\tbus->upstream_ops = ops;\n\tbus->upstream = upstream;\n\n\tif (bus->sfp) {\n\t\tret = sfp_register_bus(bus);\n\t\tif (ret)\n\t\t\tsfp_upstream_clear(bus);\n\t} else {\n\t\tret = 0;\n\t}\n\trtnl_unlock();\n\n\tif (ret)\n\t\tsfp_bus_put(bus);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sfp_bus_add_upstream);\n\n \nvoid sfp_bus_del_upstream(struct sfp_bus *bus)\n{\n\tif (bus) {\n\t\trtnl_lock();\n\t\tif (bus->sfp)\n\t\t\tsfp_unregister_bus(bus);\n\t\tsfp_upstream_clear(bus);\n\t\trtnl_unlock();\n\n\t\tsfp_bus_put(bus);\n\t}\n}\nEXPORT_SYMBOL_GPL(sfp_bus_del_upstream);\n\n \nint sfp_add_phy(struct sfp_bus *bus, struct phy_device *phydev)\n{\n\tconst struct sfp_upstream_ops *ops = sfp_get_upstream_ops(bus);\n\tint ret = 0;\n\n\tif (ops && ops->connect_phy)\n\t\tret = ops->connect_phy(bus->upstream, phydev);\n\n\tif (ret == 0)\n\t\tbus->phydev = phydev;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sfp_add_phy);\n\nvoid sfp_remove_phy(struct sfp_bus *bus)\n{\n\tconst struct sfp_upstream_ops *ops = sfp_get_upstream_ops(bus);\n\n\tif (ops && ops->disconnect_phy)\n\t\tops->disconnect_phy(bus->upstream);\n\tbus->phydev = NULL;\n}\nEXPORT_SYMBOL_GPL(sfp_remove_phy);\n\nvoid sfp_link_up(struct sfp_bus *bus)\n{\n\tconst struct sfp_upstream_ops *ops = sfp_get_upstream_ops(bus);\n\n\tif (ops && ops->link_up)\n\t\tops->link_up(bus->upstream);\n}\nEXPORT_SYMBOL_GPL(sfp_link_up);\n\nvoid sfp_link_down(struct sfp_bus *bus)\n{\n\tconst struct sfp_upstream_ops *ops = sfp_get_upstream_ops(bus);\n\n\tif (ops && ops->link_down)\n\t\tops->link_down(bus->upstream);\n}\nEXPORT_SYMBOL_GPL(sfp_link_down);\n\nint sfp_module_insert(struct sfp_bus *bus, const struct sfp_eeprom_id *id,\n\t\t      const struct sfp_quirk *quirk)\n{\n\tconst struct sfp_upstream_ops *ops = sfp_get_upstream_ops(bus);\n\tint ret = 0;\n\n\tbus->sfp_quirk = quirk;\n\n\tif (ops && ops->module_insert)\n\t\tret = ops->module_insert(bus->upstream, id);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sfp_module_insert);\n\nvoid sfp_module_remove(struct sfp_bus *bus)\n{\n\tconst struct sfp_upstream_ops *ops = sfp_get_upstream_ops(bus);\n\n\tif (ops && ops->module_remove)\n\t\tops->module_remove(bus->upstream);\n\n\tbus->sfp_quirk = NULL;\n}\nEXPORT_SYMBOL_GPL(sfp_module_remove);\n\nint sfp_module_start(struct sfp_bus *bus)\n{\n\tconst struct sfp_upstream_ops *ops = sfp_get_upstream_ops(bus);\n\tint ret = 0;\n\n\tif (ops && ops->module_start)\n\t\tret = ops->module_start(bus->upstream);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sfp_module_start);\n\nvoid sfp_module_stop(struct sfp_bus *bus)\n{\n\tconst struct sfp_upstream_ops *ops = sfp_get_upstream_ops(bus);\n\n\tif (ops && ops->module_stop)\n\t\tops->module_stop(bus->upstream);\n}\nEXPORT_SYMBOL_GPL(sfp_module_stop);\n\nstatic void sfp_socket_clear(struct sfp_bus *bus)\n{\n\tbus->sfp_dev = NULL;\n\tbus->sfp = NULL;\n\tbus->socket_ops = NULL;\n}\n\nstruct sfp_bus *sfp_register_socket(struct device *dev, struct sfp *sfp,\n\t\t\t\t    const struct sfp_socket_ops *ops)\n{\n\tstruct sfp_bus *bus = sfp_bus_get(dev->fwnode);\n\tint ret = 0;\n\n\tif (bus) {\n\t\trtnl_lock();\n\t\tbus->sfp_dev = dev;\n\t\tbus->sfp = sfp;\n\t\tbus->socket_ops = ops;\n\n\t\tif (bus->upstream_ops) {\n\t\t\tret = sfp_register_bus(bus);\n\t\t\tif (ret)\n\t\t\t\tsfp_socket_clear(bus);\n\t\t}\n\t\trtnl_unlock();\n\t}\n\n\tif (ret) {\n\t\tsfp_bus_put(bus);\n\t\tbus = NULL;\n\t}\n\n\treturn bus;\n}\nEXPORT_SYMBOL_GPL(sfp_register_socket);\n\nvoid sfp_unregister_socket(struct sfp_bus *bus)\n{\n\trtnl_lock();\n\tif (bus->upstream_ops)\n\t\tsfp_unregister_bus(bus);\n\tsfp_socket_clear(bus);\n\trtnl_unlock();\n\n\tsfp_bus_put(bus);\n}\nEXPORT_SYMBOL_GPL(sfp_unregister_socket);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}