{
  "module_name": "c101.c",
  "hash_id": "08a15614b91d340af0cc011b9b9fe5427513c802da6235a59e959dd533e39825",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wan/c101.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/netdevice.h>\n#include <linux/hdlc.h>\n#include <linux/delay.h>\n#include <asm/io.h>\n\n#include \"hd64570.h\"\n\nstatic const char *version = \"Moxa C101 driver version: 1.15\";\nstatic const char *devname = \"C101\";\n\n#undef DEBUG_PKT\n#define DEBUG_RINGS\n\n#define C101_PAGE 0x1D00\n#define C101_DTR 0x1E00\n#define C101_SCA 0x1F00\n#define C101_WINDOW_SIZE 0x2000\n#define C101_MAPPED_RAM_SIZE 0x4000\n\n#define RAM_SIZE (256 * 1024)\n#define TX_RING_BUFFERS 10\n#define RX_RING_BUFFERS ((RAM_SIZE - C101_WINDOW_SIZE) /\t\t\\\n\t\t\t (sizeof(pkt_desc) + HDLC_MAX_MRU) - TX_RING_BUFFERS)\n\n#define CLOCK_BASE 9830400\t \n#define PAGE0_ALWAYS_MAPPED\n\nstatic char *hw;\t\t \n\ntypedef struct card_s {\n\tstruct net_device *dev;\n\tspinlock_t lock;\t \n\tu8 __iomem *win0base;\t \n\tu32 phy_winbase;\t \n\tsync_serial_settings settings;\n\tint rxpart;\t\t \n\tunsigned short encoding;\n\tunsigned short parity;\n\tu16 rx_ring_buffers;\t \n\tu16 tx_ring_buffers;\n\tu16 buff_offset;\t \n\tu16 rxin;\t\t \n\tu16 txin;\t\t \n\tu16 txlast;\n\tu8 rxs, txs, tmc;\t \n\tu8 irq;\t\t\t \n\tu8 page;\n\n\tstruct card_s *next_card;\n} card_t;\n\ntypedef card_t port_t;\n\nstatic card_t *first_card;\nstatic card_t **new_card = &first_card;\n\n#define sca_in(reg, card)\t   readb((card)->win0base + C101_SCA + (reg))\n#define sca_out(value, reg, card)  writeb(value, (card)->win0base + C101_SCA + (reg))\n#define sca_inw(reg, card)\t   readw((card)->win0base + C101_SCA + (reg))\n\n \n#define sca_outw(value, reg, card) do { \\\n\twriteb(value & 0xFF, (card)->win0base + C101_SCA + (reg)); \\\n\twriteb((value >> 8) & 0xFF, (card)->win0base + C101_SCA + (reg + 1));\\\n} while (0)\n\n#define port_to_card(port)\t   (port)\n#define log_node(port)\t\t   (0)\n#define phy_node(port)\t\t   (0)\n#define winsize(card)\t\t   (C101_WINDOW_SIZE)\n#define win0base(card)\t\t   ((card)->win0base)\n#define winbase(card)\t\t   ((card)->win0base + 0x2000)\n#define get_port(card, port)\t   (card)\nstatic void sca_msci_intr(port_t *port);\n\nstatic inline u8 sca_get_page(card_t *card)\n{\n\treturn card->page;\n}\n\nstatic inline void openwin(card_t *card, u8 page)\n{\n\tcard->page = page;\n\twriteb(page, card->win0base + C101_PAGE);\n}\n\n#include \"hd64570.c\"\n\nstatic inline void set_carrier(port_t *port)\n{\n\tif (!(sca_in(MSCI1_OFFSET + ST3, port) & ST3_DCD))\n\t\tnetif_carrier_on(port_to_dev(port));\n\telse\n\t\tnetif_carrier_off(port_to_dev(port));\n}\n\nstatic void sca_msci_intr(port_t *port)\n{\n\tu8 stat = sca_in(MSCI0_OFFSET + ST1, port);  \n\n\t \n\tsca_out(stat & (ST1_UDRN | ST1_CDCD), MSCI0_OFFSET + ST1, port);\n\n\tif (stat & ST1_UDRN) {\n\t\t \n\t\tport_to_dev(port)->stats.tx_errors++;\n\t\tport_to_dev(port)->stats.tx_fifo_errors++;\n\t}\n\n\tstat = sca_in(MSCI1_OFFSET + ST1, port);  \n\t \n\tsca_out(stat & ST1_CDCD, MSCI1_OFFSET + ST1, port);\n\n\tif (stat & ST1_CDCD)\n\t\tset_carrier(port);\n}\n\nstatic void c101_set_iface(port_t *port)\n{\n\tu8 rxs = port->rxs & CLK_BRG_MASK;\n\tu8 txs = port->txs & CLK_BRG_MASK;\n\n\tswitch (port->settings.clock_type) {\n\tcase CLOCK_INT:\n\t\trxs |= CLK_BRG_RX;  \n\t\ttxs |= CLK_RXCLK_TX;  \n\t\tbreak;\n\n\tcase CLOCK_TXINT:\n\t\trxs |= CLK_LINE_RX;  \n\t\ttxs |= CLK_BRG_TX;  \n\t\tbreak;\n\n\tcase CLOCK_TXFROMRX:\n\t\trxs |= CLK_LINE_RX;  \n\t\ttxs |= CLK_RXCLK_TX;  \n\t\tbreak;\n\n\tdefault:\t \n\t\trxs |= CLK_LINE_RX;  \n\t\ttxs |= CLK_LINE_TX;  \n\t}\n\n\tport->rxs = rxs;\n\tport->txs = txs;\n\tsca_out(rxs, MSCI1_OFFSET + RXS, port);\n\tsca_out(txs, MSCI1_OFFSET + TXS, port);\n\tsca_set_port(port);\n}\n\nstatic int c101_open(struct net_device *dev)\n{\n\tport_t *port = dev_to_port(dev);\n\tint result;\n\n\tresult = hdlc_open(dev);\n\tif (result)\n\t\treturn result;\n\n\twriteb(1, port->win0base + C101_DTR);\n\tsca_out(0, MSCI1_OFFSET + CTL, port);  \n\tsca_open(dev);\n\t \n\tsca_out(IE1_UDRN, MSCI0_OFFSET + IE1, port);\n\tsca_out(IE0_TXINT, MSCI0_OFFSET + IE0, port);\n\n\tset_carrier(port);\n\n\t \n\tsca_out(IE1_CDCD, MSCI1_OFFSET + IE1, port);\n\tsca_out(IE0_RXINTA, MSCI1_OFFSET + IE0, port);\n\tsca_out(0x48, IER0, port);  \n\tc101_set_iface(port);\n\treturn 0;\n}\n\nstatic int c101_close(struct net_device *dev)\n{\n\tport_t *port = dev_to_port(dev);\n\n\tsca_close(dev);\n\twriteb(0, port->win0base + C101_DTR);\n\tsca_out(CTL_NORTS, MSCI1_OFFSET + CTL, port);\n\thdlc_close(dev);\n\treturn 0;\n}\n\nstatic int c101_siocdevprivate(struct net_device *dev, struct ifreq *ifr,\n\t\t\t       void __user *data, int cmd)\n{\n#ifdef DEBUG_RINGS\n\tport_t *port = dev_to_port(dev);\n\n\tif (cmd == SIOCDEVPRIVATE) {\n\t\tsca_dump_rings(dev);\n\t\tprintk(KERN_DEBUG \"MSCI1: ST: %02x %02x %02x %02x\\n\",\n\t\t       sca_in(MSCI1_OFFSET + ST0, port),\n\t\t       sca_in(MSCI1_OFFSET + ST1, port),\n\t\t       sca_in(MSCI1_OFFSET + ST2, port),\n\t\t       sca_in(MSCI1_OFFSET + ST3, port));\n\t\treturn 0;\n\t}\n#endif\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int c101_ioctl(struct net_device *dev, struct if_settings *ifs)\n{\n\tconst size_t size = sizeof(sync_serial_settings);\n\tsync_serial_settings new_line;\n\tsync_serial_settings __user *line = ifs->ifs_ifsu.sync;\n\tport_t *port = dev_to_port(dev);\n\n\tswitch (ifs->type) {\n\tcase IF_GET_IFACE:\n\t\tifs->type = IF_IFACE_SYNC_SERIAL;\n\t\tif (ifs->size < size) {\n\t\t\tifs->size = size;  \n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tif (copy_to_user(line, &port->settings, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase IF_IFACE_SYNC_SERIAL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&new_line, line, size))\n\t\t\treturn -EFAULT;\n\n\t\tif (new_line.clock_type != CLOCK_EXT &&\n\t\t    new_line.clock_type != CLOCK_TXFROMRX &&\n\t\t    new_line.clock_type != CLOCK_INT &&\n\t\t    new_line.clock_type != CLOCK_TXINT)\n\t\t\treturn -EINVAL;\t \n\n\t\tif (new_line.loopback != 0 && new_line.loopback != 1)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(&port->settings, &new_line, size);  \n\t\tc101_set_iface(port);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn hdlc_ioctl(dev, ifs);\n\t}\n}\n\nstatic void c101_destroy_card(card_t *card)\n{\n\treadb(card->win0base + C101_PAGE);  \n\n\tif (card->irq)\n\t\tfree_irq(card->irq, card);\n\n\tif (card->win0base) {\n\t\tiounmap(card->win0base);\n\t\trelease_mem_region(card->phy_winbase, C101_MAPPED_RAM_SIZE);\n\t}\n\n\tfree_netdev(card->dev);\n\n\tkfree(card);\n}\n\nstatic const struct net_device_ops c101_ops = {\n\t.ndo_open       = c101_open,\n\t.ndo_stop       = c101_close,\n\t.ndo_start_xmit = hdlc_start_xmit,\n\t.ndo_siocwandev = c101_ioctl,\n\t.ndo_siocdevprivate = c101_siocdevprivate,\n};\n\nstatic int __init c101_run(unsigned long irq, unsigned long winbase)\n{\n\tstruct net_device *dev;\n\thdlc_device *hdlc;\n\tcard_t *card;\n\tint result;\n\n\tif (irq < 3 || irq > 15 || irq == 6)   {\n\t\tpr_err(\"invalid IRQ value\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (winbase < 0xC0000 || winbase > 0xDFFFF || (winbase & 0x3FFF) != 0) {\n\t\tpr_err(\"invalid RAM value\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tcard = kzalloc(sizeof(card_t), GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOBUFS;\n\n\tcard->dev = alloc_hdlcdev(card);\n\tif (!card->dev) {\n\t\tpr_err(\"unable to allocate memory\\n\");\n\t\tkfree(card);\n\t\treturn -ENOBUFS;\n\t}\n\n\tif (request_irq(irq, sca_intr, 0, devname, card)) {\n\t\tpr_err(\"could not allocate IRQ\\n\");\n\t\tc101_destroy_card(card);\n\t\treturn -EBUSY;\n\t}\n\tcard->irq = irq;\n\n\tif (!request_mem_region(winbase, C101_MAPPED_RAM_SIZE, devname)) {\n\t\tpr_err(\"could not request RAM window\\n\");\n\t\tc101_destroy_card(card);\n\t\treturn -EBUSY;\n\t}\n\tcard->phy_winbase = winbase;\n\tcard->win0base = ioremap(winbase, C101_MAPPED_RAM_SIZE);\n\tif (!card->win0base) {\n\t\tpr_err(\"could not map I/O address\\n\");\n\t\tc101_destroy_card(card);\n\t\treturn -EFAULT;\n\t}\n\n\tcard->tx_ring_buffers = TX_RING_BUFFERS;\n\tcard->rx_ring_buffers = RX_RING_BUFFERS;\n\tcard->buff_offset = C101_WINDOW_SIZE;  \n\n\treadb(card->win0base + C101_PAGE);  \n\tudelay(100);\n\twriteb(0, card->win0base + C101_PAGE);\n\twriteb(0, card->win0base + C101_DTR);  \n\n\tsca_init(card, 0);\n\n\tdev = port_to_dev(card);\n\thdlc = dev_to_hdlc(dev);\n\n\tspin_lock_init(&card->lock);\n\tdev->irq = irq;\n\tdev->mem_start = winbase;\n\tdev->mem_end = winbase + C101_MAPPED_RAM_SIZE - 1;\n\tdev->tx_queue_len = 50;\n\tdev->netdev_ops = &c101_ops;\n\thdlc->attach = sca_attach;\n\thdlc->xmit = sca_xmit;\n\tcard->settings.clock_type = CLOCK_EXT;\n\n\tresult = register_hdlc_device(dev);\n\tif (result) {\n\t\tpr_warn(\"unable to register hdlc device\\n\");\n\t\tc101_destroy_card(card);\n\t\treturn result;\n\t}\n\n\tsca_init_port(card);  \n\tset_carrier(card);\n\n\tnetdev_info(dev, \"Moxa C101 on IRQ%u, using %u TX + %u RX packets rings\\n\",\n\t\t    card->irq, card->tx_ring_buffers, card->rx_ring_buffers);\n\n\t*new_card = card;\n\tnew_card = &card->next_card;\n\treturn 0;\n}\n\nstatic int __init c101_init(void)\n{\n\tif (!hw) {\n#ifdef MODULE\n\t\tpr_info(\"no card initialized\\n\");\n#endif\n\t\treturn -EINVAL;\t \n\t}\n\n\tpr_info(\"%s\\n\", version);\n\n\tdo {\n\t\tunsigned long irq, ram;\n\n\t\tirq = simple_strtoul(hw, &hw, 0);\n\n\t\tif (*hw++ != ',')\n\t\t\tbreak;\n\t\tram = simple_strtoul(hw, &hw, 0);\n\n\t\tif (*hw == ':' || *hw == '\\x0')\n\t\t\tc101_run(irq, ram);\n\n\t\tif (*hw == '\\x0')\n\t\t\treturn first_card ? 0 : -EINVAL;\n\t} while (*hw++ == ':');\n\n\tpr_err(\"invalid hardware parameters\\n\");\n\treturn first_card ? 0 : -EINVAL;\n}\n\nstatic void __exit c101_cleanup(void)\n{\n\tcard_t *card = first_card;\n\n\twhile (card) {\n\t\tcard_t *ptr = card;\n\n\t\tcard = card->next_card;\n\t\tunregister_hdlc_device(port_to_dev(ptr));\n\t\tc101_destroy_card(ptr);\n\t}\n}\n\nmodule_init(c101_init);\nmodule_exit(c101_cleanup);\n\nMODULE_AUTHOR(\"Krzysztof Halasa <khc@pm.waw.pl>\");\nMODULE_DESCRIPTION(\"Moxa C101 serial port driver\");\nMODULE_LICENSE(\"GPL v2\");\nmodule_param(hw, charp, 0444);\nMODULE_PARM_DESC(hw, \"irq,ram:irq,...\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}