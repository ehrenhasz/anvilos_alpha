{
  "module_name": "hdlc_fr.c",
  "hash_id": "958c8d88249f23a95315d421adf94964994d308c6ed094bbe1a48989cc1d926c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wan/hdlc_fr.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/hdlc.h>\n#include <linux/if_arp.h>\n#include <linux/inetdevice.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pkt_sched.h>\n#include <linux/poll.h>\n#include <linux/rtnetlink.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n\n#undef DEBUG_PKT\n#undef DEBUG_ECN\n#undef DEBUG_LINK\n#undef DEBUG_PROTO\n#undef DEBUG_PVC\n\n#define FR_UI\t\t\t0x03\n#define FR_PAD\t\t\t0x00\n\n#define NLPID_IP\t\t0xCC\n#define NLPID_IPV6\t\t0x8E\n#define NLPID_SNAP\t\t0x80\n#define NLPID_PAD\t\t0x00\n#define NLPID_CCITT_ANSI_LMI\t0x08\n#define NLPID_CISCO_LMI\t\t0x09\n\n#define LMI_CCITT_ANSI_DLCI\t   0  \n#define LMI_CISCO_DLCI\t\t1023\n\n#define LMI_CALLREF\t\t0x00  \n#define LMI_ANSI_LOCKSHIFT\t0x95  \n#define LMI_ANSI_CISCO_REPTYPE\t0x01  \n#define LMI_CCITT_REPTYPE\t0x51\n#define LMI_ANSI_CISCO_ALIVE\t0x03  \n#define LMI_CCITT_ALIVE\t\t0x53\n#define LMI_ANSI_CISCO_PVCSTAT\t0x07  \n#define LMI_CCITT_PVCSTAT\t0x57\n\n#define LMI_FULLREP\t\t0x00  \n#define LMI_INTEGRITY\t\t0x01  \n#define LMI_SINGLE\t\t0x02  \n\n#define LMI_STATUS_ENQUIRY      0x75\n#define LMI_STATUS              0x7D  \n\n#define LMI_REPT_LEN               1  \n#define LMI_INTEG_LEN              2  \n\n#define LMI_CCITT_CISCO_LENGTH\t  13  \n#define LMI_ANSI_LENGTH\t\t  14\n\nstruct fr_hdr {\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n\tunsigned ea1:\t1;\n\tunsigned cr:\t1;\n\tunsigned dlcih:\t6;\n\n\tunsigned ea2:\t1;\n\tunsigned de:\t1;\n\tunsigned becn:\t1;\n\tunsigned fecn:\t1;\n\tunsigned dlcil:\t4;\n#else\n\tunsigned dlcih:\t6;\n\tunsigned cr:\t1;\n\tunsigned ea1:\t1;\n\n\tunsigned dlcil:\t4;\n\tunsigned fecn:\t1;\n\tunsigned becn:\t1;\n\tunsigned de:\t1;\n\tunsigned ea2:\t1;\n#endif\n} __packed;\n\nstruct pvc_device {\n\tstruct net_device *frad;\n\tstruct net_device *main;\n\tstruct net_device *ether;\t \n\tstruct pvc_device *next;\t \n\tint dlci;\n\tint open_count;\n\n\tstruct {\n\t\tunsigned int new: 1;\n\t\tunsigned int active: 1;\n\t\tunsigned int exist: 1;\n\t\tunsigned int deleted: 1;\n\t\tunsigned int fecn: 1;\n\t\tunsigned int becn: 1;\n\t\tunsigned int bandwidth;\t \n\t} state;\n};\n\nstruct frad_state {\n\tfr_proto settings;\n\tstruct pvc_device *first_pvc;\n\tint dce_pvc_count;\n\n\tstruct timer_list timer;\n\tstruct net_device *dev;\n\tunsigned long last_poll;\n\tint reliable;\n\tint dce_changed;\n\tint request;\n\tint fullrep_sent;\n\tu32 last_errors;  \n\tu8 n391cnt;\n\tu8 txseq;  \n\tu8 rxseq;  \n};\n\nstatic int fr_ioctl(struct net_device *dev, struct if_settings *ifs);\n\nstatic inline u16 q922_to_dlci(u8 *hdr)\n{\n\treturn ((hdr[0] & 0xFC) << 2) | ((hdr[1] & 0xF0) >> 4);\n}\n\nstatic inline void dlci_to_q922(u8 *hdr, u16 dlci)\n{\n\thdr[0] = (dlci >> 2) & 0xFC;\n\thdr[1] = ((dlci << 4) & 0xF0) | 0x01;\n}\n\nstatic inline struct frad_state *state(hdlc_device *hdlc)\n{\n\treturn (struct frad_state *)(hdlc->state);\n}\n\nstatic inline struct pvc_device *find_pvc(hdlc_device *hdlc, u16 dlci)\n{\n\tstruct pvc_device *pvc = state(hdlc)->first_pvc;\n\n\twhile (pvc) {\n\t\tif (pvc->dlci == dlci)\n\t\t\treturn pvc;\n\t\tif (pvc->dlci > dlci)\n\t\t\treturn NULL;  \n\t\tpvc = pvc->next;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct pvc_device *add_pvc(struct net_device *dev, u16 dlci)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tstruct pvc_device *pvc, **pvc_p = &state(hdlc)->first_pvc;\n\n\twhile (*pvc_p) {\n\t\tif ((*pvc_p)->dlci == dlci)\n\t\t\treturn *pvc_p;\n\t\tif ((*pvc_p)->dlci > dlci)\n\t\t\tbreak;\t \n\t\tpvc_p = &(*pvc_p)->next;\n\t}\n\n\tpvc = kzalloc(sizeof(*pvc), GFP_ATOMIC);\n#ifdef DEBUG_PVC\n\tprintk(KERN_DEBUG \"add_pvc: allocated pvc %p, frad %p\\n\", pvc, dev);\n#endif\n\tif (!pvc)\n\t\treturn NULL;\n\n\tpvc->dlci = dlci;\n\tpvc->frad = dev;\n\tpvc->next = *pvc_p;\t \n\t*pvc_p = pvc;\n\treturn pvc;\n}\n\nstatic inline int pvc_is_used(struct pvc_device *pvc)\n{\n\treturn pvc->main || pvc->ether;\n}\n\nstatic inline void pvc_carrier(int on, struct pvc_device *pvc)\n{\n\tif (on) {\n\t\tif (pvc->main)\n\t\t\tif (!netif_carrier_ok(pvc->main))\n\t\t\t\tnetif_carrier_on(pvc->main);\n\t\tif (pvc->ether)\n\t\t\tif (!netif_carrier_ok(pvc->ether))\n\t\t\t\tnetif_carrier_on(pvc->ether);\n\t} else {\n\t\tif (pvc->main)\n\t\t\tif (netif_carrier_ok(pvc->main))\n\t\t\t\tnetif_carrier_off(pvc->main);\n\t\tif (pvc->ether)\n\t\t\tif (netif_carrier_ok(pvc->ether))\n\t\t\t\tnetif_carrier_off(pvc->ether);\n\t}\n}\n\nstatic inline void delete_unused_pvcs(hdlc_device *hdlc)\n{\n\tstruct pvc_device **pvc_p = &state(hdlc)->first_pvc;\n\n\twhile (*pvc_p) {\n\t\tif (!pvc_is_used(*pvc_p)) {\n\t\t\tstruct pvc_device *pvc = *pvc_p;\n#ifdef DEBUG_PVC\n\t\t\tprintk(KERN_DEBUG \"freeing unused pvc: %p\\n\", pvc);\n#endif\n\t\t\t*pvc_p = pvc->next;\n\t\t\tkfree(pvc);\n\t\t\tcontinue;\n\t\t}\n\t\tpvc_p = &(*pvc_p)->next;\n\t}\n}\n\nstatic inline struct net_device **get_dev_p(struct pvc_device *pvc,\n\t\t\t\t\t    int type)\n{\n\tif (type == ARPHRD_ETHER)\n\t\treturn &pvc->ether;\n\telse\n\t\treturn &pvc->main;\n}\n\nstatic int fr_hard_header(struct sk_buff *skb, u16 dlci)\n{\n\tif (!skb->dev) {  \n\t\tswitch (dlci) {\n\t\tcase LMI_CCITT_ANSI_DLCI:\n\t\t\tskb_push(skb, 4);\n\t\t\tskb->data[3] = NLPID_CCITT_ANSI_LMI;\n\t\t\tbreak;\n\n\t\tcase LMI_CISCO_DLCI:\n\t\t\tskb_push(skb, 4);\n\t\t\tskb->data[3] = NLPID_CISCO_LMI;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t} else if (skb->dev->type == ARPHRD_DLCI) {\n\t\tswitch (skb->protocol) {\n\t\tcase htons(ETH_P_IP):\n\t\t\tskb_push(skb, 4);\n\t\t\tskb->data[3] = NLPID_IP;\n\t\t\tbreak;\n\n\t\tcase htons(ETH_P_IPV6):\n\t\t\tskb_push(skb, 4);\n\t\t\tskb->data[3] = NLPID_IPV6;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tskb_push(skb, 10);\n\t\t\tskb->data[3] = FR_PAD;\n\t\t\tskb->data[4] = NLPID_SNAP;\n\t\t\t \n\t\t\tskb->data[5] = 0x00;\n\t\t\tskb->data[6] = 0x00;\n\t\t\tskb->data[7] = 0x00;\n\t\t\t \n\t\t\t*(__be16 *)(skb->data + 8) = skb->protocol;\n\t\t}\n\n\t} else if (skb->dev->type == ARPHRD_ETHER) {\n\t\tskb_push(skb, 10);\n\t\tskb->data[3] = FR_PAD;\n\t\tskb->data[4] = NLPID_SNAP;\n\t\t \n\t\tskb->data[5] = 0x00;\n\t\tskb->data[6] = 0x80;\n\t\tskb->data[7] = 0xC2;\n\t\t \n\t\tskb->data[8] = 0x00;\n\t\tskb->data[9] = 0x07;\n\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tdlci_to_q922(skb->data, dlci);\n\tskb->data[2] = FR_UI;\n\treturn 0;\n}\n\nstatic int pvc_open(struct net_device *dev)\n{\n\tstruct pvc_device *pvc = dev->ml_priv;\n\n\tif ((pvc->frad->flags & IFF_UP) == 0)\n\t\treturn -EIO;   \n\n\tif (pvc->open_count++ == 0) {\n\t\thdlc_device *hdlc = dev_to_hdlc(pvc->frad);\n\n\t\tif (state(hdlc)->settings.lmi == LMI_NONE)\n\t\t\tpvc->state.active = netif_carrier_ok(pvc->frad);\n\n\t\tpvc_carrier(pvc->state.active, pvc);\n\t\tstate(hdlc)->dce_changed = 1;\n\t}\n\treturn 0;\n}\n\nstatic int pvc_close(struct net_device *dev)\n{\n\tstruct pvc_device *pvc = dev->ml_priv;\n\n\tif (--pvc->open_count == 0) {\n\t\thdlc_device *hdlc = dev_to_hdlc(pvc->frad);\n\n\t\tif (state(hdlc)->settings.lmi == LMI_NONE)\n\t\t\tpvc->state.active = 0;\n\n\t\tif (state(hdlc)->settings.dce) {\n\t\t\tstate(hdlc)->dce_changed = 1;\n\t\t\tpvc->state.active = 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int pvc_ioctl(struct net_device *dev, struct if_settings *ifs)\n{\n\tstruct pvc_device *pvc = dev->ml_priv;\n\tfr_proto_pvc_info info;\n\n\tif (ifs->type == IF_GET_PROTO) {\n\t\tif (dev->type == ARPHRD_ETHER)\n\t\t\tifs->type = IF_PROTO_FR_ETH_PVC;\n\t\telse\n\t\t\tifs->type = IF_PROTO_FR_PVC;\n\n\t\tif (ifs->size < sizeof(info)) {\n\t\t\t \n\t\t\tifs->size = sizeof(info);\n\t\t\treturn -ENOBUFS;\n\t\t}\n\n\t\tinfo.dlci = pvc->dlci;\n\t\tmemcpy(info.master, pvc->frad->name, IFNAMSIZ);\n\t\tif (copy_to_user(ifs->ifs_ifsu.fr_pvc_info,\n\t\t\t\t &info, sizeof(info)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic netdev_tx_t pvc_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct pvc_device *pvc = dev->ml_priv;\n\n\tif (!pvc->state.active)\n\t\tgoto drop;\n\n\tif (dev->type == ARPHRD_ETHER) {\n\t\tint pad = ETH_ZLEN - skb->len;\n\n\t\tif (pad > 0) {  \n\t\t\tif (__skb_pad(skb, pad, false))\n\t\t\t\tgoto drop;\n\t\t\tskb_put(skb, pad);\n\t\t}\n\t}\n\n\t \n\tif (skb_headroom(skb) < 10) {\n\t\tstruct sk_buff *skb2 = skb_realloc_headroom(skb, 10);\n\n\t\tif (!skb2)\n\t\t\tgoto drop;\n\t\tdev_kfree_skb(skb);\n\t\tskb = skb2;\n\t}\n\n\tskb->dev = dev;\n\tif (fr_hard_header(skb, pvc->dlci))\n\t\tgoto drop;\n\n\tdev->stats.tx_bytes += skb->len;\n\tdev->stats.tx_packets++;\n\tif (pvc->state.fecn)  \n\t\tdev->stats.tx_compressed++;\n\tskb->dev = pvc->frad;\n\tskb->protocol = htons(ETH_P_HDLC);\n\tskb_reset_network_header(skb);\n\tdev_queue_xmit(skb);\n\treturn NETDEV_TX_OK;\n\ndrop:\n\tdev->stats.tx_dropped++;\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic inline void fr_log_dlci_active(struct pvc_device *pvc)\n{\n\tnetdev_info(pvc->frad, \"DLCI %d [%s%s%s]%s %s\\n\",\n\t\t    pvc->dlci,\n\t\t    pvc->main ? pvc->main->name : \"\",\n\t\t    pvc->main && pvc->ether ? \" \" : \"\",\n\t\t    pvc->ether ? pvc->ether->name : \"\",\n\t\t    pvc->state.new ? \" new\" : \"\",\n\t\t    !pvc->state.exist ? \"deleted\" :\n\t\t    pvc->state.active ? \"active\" : \"inactive\");\n}\n\nstatic inline u8 fr_lmi_nextseq(u8 x)\n{\n\tx++;\n\treturn x ? x : 1;\n}\n\nstatic void fr_lmi_send(struct net_device *dev, int fullrep)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tstruct sk_buff *skb;\n\tstruct pvc_device *pvc = state(hdlc)->first_pvc;\n\tint lmi = state(hdlc)->settings.lmi;\n\tint dce = state(hdlc)->settings.dce;\n\tint len = lmi == LMI_ANSI ? LMI_ANSI_LENGTH : LMI_CCITT_CISCO_LENGTH;\n\tint stat_len = (lmi == LMI_CISCO) ? 6 : 3;\n\tu8 *data;\n\tint i = 0;\n\n\tif (dce && fullrep) {\n\t\tlen += state(hdlc)->dce_pvc_count * (2 + stat_len);\n\t\tif (len > HDLC_MAX_MRU) {\n\t\t\tnetdev_warn(dev, \"Too many PVCs while sending LMI full report\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tskb = dev_alloc_skb(len);\n\tif (!skb)\n\t\treturn;\n\n\tmemset(skb->data, 0, len);\n\tskb_reserve(skb, 4);\n\tif (lmi == LMI_CISCO)\n\t\tfr_hard_header(skb, LMI_CISCO_DLCI);\n\telse\n\t\tfr_hard_header(skb, LMI_CCITT_ANSI_DLCI);\n\n\tdata = skb_tail_pointer(skb);\n\tdata[i++] = LMI_CALLREF;\n\tdata[i++] = dce ? LMI_STATUS : LMI_STATUS_ENQUIRY;\n\tif (lmi == LMI_ANSI)\n\t\tdata[i++] = LMI_ANSI_LOCKSHIFT;\n\tdata[i++] = lmi == LMI_CCITT ? LMI_CCITT_REPTYPE :\n\t\tLMI_ANSI_CISCO_REPTYPE;\n\tdata[i++] = LMI_REPT_LEN;\n\tdata[i++] = fullrep ? LMI_FULLREP : LMI_INTEGRITY;\n\tdata[i++] = lmi == LMI_CCITT ? LMI_CCITT_ALIVE : LMI_ANSI_CISCO_ALIVE;\n\tdata[i++] = LMI_INTEG_LEN;\n\tdata[i++] = state(hdlc)->txseq =\n\t\tfr_lmi_nextseq(state(hdlc)->txseq);\n\tdata[i++] = state(hdlc)->rxseq;\n\n\tif (dce && fullrep) {\n\t\twhile (pvc) {\n\t\t\tdata[i++] = lmi == LMI_CCITT ? LMI_CCITT_PVCSTAT :\n\t\t\t\tLMI_ANSI_CISCO_PVCSTAT;\n\t\t\tdata[i++] = stat_len;\n\n\t\t\t \n\t\t\tif (state(hdlc)->reliable && !pvc->state.exist) {\n\t\t\t\tpvc->state.exist = pvc->state.new = 1;\n\t\t\t\tfr_log_dlci_active(pvc);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (pvc->open_count && !pvc->state.active &&\n\t\t\t    pvc->state.exist && !pvc->state.new) {\n\t\t\t\tpvc_carrier(1, pvc);\n\t\t\t\tpvc->state.active = 1;\n\t\t\t\tfr_log_dlci_active(pvc);\n\t\t\t}\n\n\t\t\tif (lmi == LMI_CISCO) {\n\t\t\t\tdata[i] = pvc->dlci >> 8;\n\t\t\t\tdata[i + 1] = pvc->dlci & 0xFF;\n\t\t\t} else {\n\t\t\t\tdata[i] = (pvc->dlci >> 4) & 0x3F;\n\t\t\t\tdata[i + 1] = ((pvc->dlci << 3) & 0x78) | 0x80;\n\t\t\t\tdata[i + 2] = 0x80;\n\t\t\t}\n\n\t\t\tif (pvc->state.new)\n\t\t\t\tdata[i + 2] |= 0x08;\n\t\t\telse if (pvc->state.active)\n\t\t\t\tdata[i + 2] |= 0x02;\n\n\t\t\ti += stat_len;\n\t\t\tpvc = pvc->next;\n\t\t}\n\t}\n\n\tskb_put(skb, i);\n\tskb->priority = TC_PRIO_CONTROL;\n\tskb->dev = dev;\n\tskb->protocol = htons(ETH_P_HDLC);\n\tskb_reset_network_header(skb);\n\n\tdev_queue_xmit(skb);\n}\n\nstatic void fr_set_link_state(int reliable, struct net_device *dev)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tstruct pvc_device *pvc = state(hdlc)->first_pvc;\n\n\tstate(hdlc)->reliable = reliable;\n\tif (reliable) {\n\t\tnetif_dormant_off(dev);\n\t\tstate(hdlc)->n391cnt = 0;  \n\t\tstate(hdlc)->dce_changed = 1;\n\n\t\tif (state(hdlc)->settings.lmi == LMI_NONE) {\n\t\t\twhile (pvc) {\t \n\t\t\t\tpvc_carrier(1, pvc);\n\t\t\t\tpvc->state.exist = pvc->state.active = 1;\n\t\t\t\tpvc->state.new = 0;\n\t\t\t\tpvc = pvc->next;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tnetif_dormant_on(dev);\n\t\twhile (pvc) {\t\t \n\t\t\tpvc_carrier(0, pvc);\n\t\t\tpvc->state.exist = pvc->state.active = 0;\n\t\t\tpvc->state.new = 0;\n\t\t\tif (!state(hdlc)->settings.dce)\n\t\t\t\tpvc->state.bandwidth = 0;\n\t\t\tpvc = pvc->next;\n\t\t}\n\t}\n}\n\nstatic void fr_timer(struct timer_list *t)\n{\n\tstruct frad_state *st = from_timer(st, t, timer);\n\tstruct net_device *dev = st->dev;\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tint i, cnt = 0, reliable;\n\tu32 list;\n\n\tif (state(hdlc)->settings.dce) {\n\t\treliable = state(hdlc)->request &&\n\t\t\ttime_before(jiffies, state(hdlc)->last_poll +\n\t\t\t\t    state(hdlc)->settings.t392 * HZ);\n\t\tstate(hdlc)->request = 0;\n\t} else {\n\t\tstate(hdlc)->last_errors <<= 1;  \n\t\tif (state(hdlc)->request) {\n\t\t\tif (state(hdlc)->reliable)\n\t\t\t\tnetdev_info(dev, \"No LMI status reply received\\n\");\n\t\t\tstate(hdlc)->last_errors |= 1;\n\t\t}\n\n\t\tlist = state(hdlc)->last_errors;\n\t\tfor (i = 0; i < state(hdlc)->settings.n393; i++, list >>= 1)\n\t\t\tcnt += (list & 1);\t \n\n\t\treliable = (cnt < state(hdlc)->settings.n392);\n\t}\n\n\tif (state(hdlc)->reliable != reliable) {\n\t\tnetdev_info(dev, \"Link %sreliable\\n\", reliable ? \"\" : \"un\");\n\t\tfr_set_link_state(reliable, dev);\n\t}\n\n\tif (state(hdlc)->settings.dce) {\n\t\tstate(hdlc)->timer.expires = jiffies +\n\t\t\tstate(hdlc)->settings.t392 * HZ;\n\t} else {\n\t\tif (state(hdlc)->n391cnt)\n\t\t\tstate(hdlc)->n391cnt--;\n\n\t\tfr_lmi_send(dev, state(hdlc)->n391cnt == 0);\n\n\t\tstate(hdlc)->last_poll = jiffies;\n\t\tstate(hdlc)->request = 1;\n\t\tstate(hdlc)->timer.expires = jiffies +\n\t\t\tstate(hdlc)->settings.t391 * HZ;\n\t}\n\n\tadd_timer(&state(hdlc)->timer);\n}\n\nstatic int fr_lmi_recv(struct net_device *dev, struct sk_buff *skb)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tstruct pvc_device *pvc;\n\tu8 rxseq, txseq;\n\tint lmi = state(hdlc)->settings.lmi;\n\tint dce = state(hdlc)->settings.dce;\n\tint stat_len = (lmi == LMI_CISCO) ? 6 : 3, reptype, error, no_ram, i;\n\n\tif (skb->len < (lmi == LMI_ANSI ? LMI_ANSI_LENGTH :\n\t\t\tLMI_CCITT_CISCO_LENGTH)) {\n\t\tnetdev_info(dev, \"Short LMI frame\\n\");\n\t\treturn 1;\n\t}\n\n\tif (skb->data[3] != (lmi == LMI_CISCO ? NLPID_CISCO_LMI :\n\t\t\t     NLPID_CCITT_ANSI_LMI)) {\n\t\tnetdev_info(dev, \"Received non-LMI frame with LMI DLCI\\n\");\n\t\treturn 1;\n\t}\n\n\tif (skb->data[4] != LMI_CALLREF) {\n\t\tnetdev_info(dev, \"Invalid LMI Call reference (0x%02X)\\n\",\n\t\t\t    skb->data[4]);\n\t\treturn 1;\n\t}\n\n\tif (skb->data[5] != (dce ? LMI_STATUS_ENQUIRY : LMI_STATUS)) {\n\t\tnetdev_info(dev, \"Invalid LMI Message type (0x%02X)\\n\",\n\t\t\t    skb->data[5]);\n\t\treturn 1;\n\t}\n\n\tif (lmi == LMI_ANSI) {\n\t\tif (skb->data[6] != LMI_ANSI_LOCKSHIFT) {\n\t\t\tnetdev_info(dev, \"Not ANSI locking shift in LMI message (0x%02X)\\n\",\n\t\t\t\t    skb->data[6]);\n\t\t\treturn 1;\n\t\t}\n\t\ti = 7;\n\t} else {\n\t\ti = 6;\n\t}\n\n\tif (skb->data[i] != (lmi == LMI_CCITT ? LMI_CCITT_REPTYPE :\n\t\t\t     LMI_ANSI_CISCO_REPTYPE)) {\n\t\tnetdev_info(dev, \"Not an LMI Report type IE (0x%02X)\\n\",\n\t\t\t    skb->data[i]);\n\t\treturn 1;\n\t}\n\n\tif (skb->data[++i] != LMI_REPT_LEN) {\n\t\tnetdev_info(dev, \"Invalid LMI Report type IE length (%u)\\n\",\n\t\t\t    skb->data[i]);\n\t\treturn 1;\n\t}\n\n\treptype = skb->data[++i];\n\tif (reptype != LMI_INTEGRITY && reptype != LMI_FULLREP) {\n\t\tnetdev_info(dev, \"Unsupported LMI Report type (0x%02X)\\n\",\n\t\t\t    reptype);\n\t\treturn 1;\n\t}\n\n\tif (skb->data[++i] != (lmi == LMI_CCITT ? LMI_CCITT_ALIVE :\n\t\t\t       LMI_ANSI_CISCO_ALIVE)) {\n\t\tnetdev_info(dev, \"Not an LMI Link integrity verification IE (0x%02X)\\n\",\n\t\t\t    skb->data[i]);\n\t\treturn 1;\n\t}\n\n\tif (skb->data[++i] != LMI_INTEG_LEN) {\n\t\tnetdev_info(dev, \"Invalid LMI Link integrity verification IE length (%u)\\n\",\n\t\t\t    skb->data[i]);\n\t\treturn 1;\n\t}\n\ti++;\n\n\tstate(hdlc)->rxseq = skb->data[i++];  \n\trxseq = skb->data[i++];\t \n\n\ttxseq = state(hdlc)->txseq;\n\n\tif (dce)\n\t\tstate(hdlc)->last_poll = jiffies;\n\n\terror = 0;\n\tif (!state(hdlc)->reliable)\n\t\terror = 1;\n\n\tif (rxseq == 0 || rxseq != txseq) {  \n\t\tstate(hdlc)->n391cnt = 0;\n\t\terror = 1;\n\t}\n\n\tif (dce) {\n\t\tif (state(hdlc)->fullrep_sent && !error) {\n \n\t\t\tstate(hdlc)->fullrep_sent = 0;\n\t\t\tpvc = state(hdlc)->first_pvc;\n\t\t\twhile (pvc) {\n\t\t\t\tif (pvc->state.new) {\n\t\t\t\t\tpvc->state.new = 0;\n\n \n\t\t\t\t\tstate(hdlc)->dce_changed = 1;\n\t\t\t\t}\n\t\t\t\tpvc = pvc->next;\n\t\t\t}\n\t\t}\n\n\t\tif (state(hdlc)->dce_changed) {\n\t\t\treptype = LMI_FULLREP;\n\t\t\tstate(hdlc)->fullrep_sent = 1;\n\t\t\tstate(hdlc)->dce_changed = 0;\n\t\t}\n\n\t\tstate(hdlc)->request = 1;  \n\t\tfr_lmi_send(dev, reptype == LMI_FULLREP ? 1 : 0);\n\t\treturn 0;\n\t}\n\n\t \n\n\tstate(hdlc)->request = 0;  \n\n\tif (error)\n\t\treturn 0;\n\n\tif (reptype != LMI_FULLREP)\n\t\treturn 0;\n\n\tpvc = state(hdlc)->first_pvc;\n\n\twhile (pvc) {\n\t\tpvc->state.deleted = 1;\n\t\tpvc = pvc->next;\n\t}\n\n\tno_ram = 0;\n\twhile (skb->len >= i + 2 + stat_len) {\n\t\tu16 dlci;\n\t\tu32 bw;\n\t\tunsigned int active, new;\n\n\t\tif (skb->data[i] != (lmi == LMI_CCITT ? LMI_CCITT_PVCSTAT :\n\t\t\t\t       LMI_ANSI_CISCO_PVCSTAT)) {\n\t\t\tnetdev_info(dev, \"Not an LMI PVC status IE (0x%02X)\\n\",\n\t\t\t\t    skb->data[i]);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (skb->data[++i] != stat_len) {\n\t\t\tnetdev_info(dev, \"Invalid LMI PVC status IE length (%u)\\n\",\n\t\t\t\t    skb->data[i]);\n\t\t\treturn 1;\n\t\t}\n\t\ti++;\n\n\t\tnew = !!(skb->data[i + 2] & 0x08);\n\t\tactive = !!(skb->data[i + 2] & 0x02);\n\t\tif (lmi == LMI_CISCO) {\n\t\t\tdlci = (skb->data[i] << 8) | skb->data[i + 1];\n\t\t\tbw = (skb->data[i + 3] << 16) |\n\t\t\t\t(skb->data[i + 4] << 8) |\n\t\t\t\t(skb->data[i + 5]);\n\t\t} else {\n\t\t\tdlci = ((skb->data[i] & 0x3F) << 4) |\n\t\t\t\t((skb->data[i + 1] & 0x78) >> 3);\n\t\t\tbw = 0;\n\t\t}\n\n\t\tpvc = add_pvc(dev, dlci);\n\n\t\tif (!pvc && !no_ram) {\n\t\t\tnetdev_warn(dev, \"Memory squeeze on fr_lmi_recv()\\n\");\n\t\t\tno_ram = 1;\n\t\t}\n\n\t\tif (pvc) {\n\t\t\tpvc->state.exist = 1;\n\t\t\tpvc->state.deleted = 0;\n\t\t\tif (active != pvc->state.active ||\n\t\t\t    new != pvc->state.new ||\n\t\t\t    bw != pvc->state.bandwidth ||\n\t\t\t    !pvc->state.exist) {\n\t\t\t\tpvc->state.new = new;\n\t\t\t\tpvc->state.active = active;\n\t\t\t\tpvc->state.bandwidth = bw;\n\t\t\t\tpvc_carrier(active, pvc);\n\t\t\t\tfr_log_dlci_active(pvc);\n\t\t\t}\n\t\t}\n\n\t\ti += stat_len;\n\t}\n\n\tpvc = state(hdlc)->first_pvc;\n\n\twhile (pvc) {\n\t\tif (pvc->state.deleted && pvc->state.exist) {\n\t\t\tpvc_carrier(0, pvc);\n\t\t\tpvc->state.active = pvc->state.new = 0;\n\t\t\tpvc->state.exist = 0;\n\t\t\tpvc->state.bandwidth = 0;\n\t\t\tfr_log_dlci_active(pvc);\n\t\t}\n\t\tpvc = pvc->next;\n\t}\n\n\t \n\tstate(hdlc)->n391cnt = state(hdlc)->settings.n391;\n\n\treturn 0;\n}\n\nstatic int fr_snap_parse(struct sk_buff *skb, struct pvc_device *pvc)\n{\n\t \n\tif (skb->data[0] == 0x00 &&\n\t    skb->data[1] == 0x00 &&\n\t    skb->data[2] == 0x00) {\n\t\tif (!pvc->main)\n\t\t\treturn -1;\n\t\tskb->dev = pvc->main;\n\t\tskb->protocol = *(__be16 *)(skb->data + 3);  \n\t\tskb_pull(skb, 5);\n\t\tskb_reset_mac_header(skb);\n\t\treturn 0;\n\n\t \n\t} else if (skb->data[0] == 0x00 &&\n\t\t   skb->data[1] == 0x80 &&\n\t\t   skb->data[2] == 0xC2) {\n\t\t \n\t\tif (skb->data[3] == 0x00 &&\n\t\t    skb->data[4] == 0x07) {\n\t\t\tif (!pvc->ether)\n\t\t\t\treturn -1;\n\t\t\tskb_pull(skb, 5);\n\t\t\tif (skb->len < ETH_HLEN)\n\t\t\t\treturn -1;\n\t\t\tskb->protocol = eth_type_trans(skb, pvc->ether);\n\t\t\treturn 0;\n\n\t\t \n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\n\t \n\t} else {\n\t\treturn -1;\n\t}\n}\n\nstatic int fr_rx(struct sk_buff *skb)\n{\n\tstruct net_device *frad = skb->dev;\n\thdlc_device *hdlc = dev_to_hdlc(frad);\n\tstruct fr_hdr *fh = (struct fr_hdr *)skb->data;\n\tu8 *data = skb->data;\n\tu16 dlci;\n\tstruct pvc_device *pvc;\n\tstruct net_device *dev;\n\n\tif (skb->len < 4 || fh->ea1 || !fh->ea2 || data[2] != FR_UI)\n\t\tgoto rx_error;\n\n\tdlci = q922_to_dlci(skb->data);\n\n\tif ((dlci == LMI_CCITT_ANSI_DLCI &&\n\t     (state(hdlc)->settings.lmi == LMI_ANSI ||\n\t      state(hdlc)->settings.lmi == LMI_CCITT)) ||\n\t    (dlci == LMI_CISCO_DLCI &&\n\t     state(hdlc)->settings.lmi == LMI_CISCO)) {\n\t\tif (fr_lmi_recv(frad, skb))\n\t\t\tgoto rx_error;\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NET_RX_SUCCESS;\n\t}\n\n\tpvc = find_pvc(hdlc, dlci);\n\tif (!pvc) {\n#ifdef DEBUG_PKT\n\t\tnetdev_info(frad, \"No PVC for received frame's DLCI %d\\n\",\n\t\t\t    dlci);\n#endif\n\t\tgoto rx_drop;\n\t}\n\n\tif (pvc->state.fecn != fh->fecn) {\n#ifdef DEBUG_ECN\n\t\tprintk(KERN_DEBUG \"%s: DLCI %d FECN O%s\\n\", frad->name,\n\t\t       dlci, fh->fecn ? \"N\" : \"FF\");\n#endif\n\t\tpvc->state.fecn ^= 1;\n\t}\n\n\tif (pvc->state.becn != fh->becn) {\n#ifdef DEBUG_ECN\n\t\tprintk(KERN_DEBUG \"%s: DLCI %d BECN O%s\\n\", frad->name,\n\t\t       dlci, fh->becn ? \"N\" : \"FF\");\n#endif\n\t\tpvc->state.becn ^= 1;\n\t}\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb) {\n\t\tfrad->stats.rx_dropped++;\n\t\treturn NET_RX_DROP;\n\t}\n\n\tif (data[3] == NLPID_IP) {\n\t\tif (!pvc->main)\n\t\t\tgoto rx_drop;\n\t\tskb_pull(skb, 4);  \n\t\tskb->dev = pvc->main;\n\t\tskb->protocol = htons(ETH_P_IP);\n\t\tskb_reset_mac_header(skb);\n\n\t} else if (data[3] == NLPID_IPV6) {\n\t\tif (!pvc->main)\n\t\t\tgoto rx_drop;\n\t\tskb_pull(skb, 4);  \n\t\tskb->dev = pvc->main;\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb_reset_mac_header(skb);\n\n\t} else if (data[3] == FR_PAD) {\n\t\tif (skb->len < 5)\n\t\t\tgoto rx_error;\n\t\tif (data[4] == NLPID_SNAP) {  \n\t\t\tskb_pull(skb, 5);\n\t\t\tif (skb->len < 5)  \n\t\t\t\tgoto rx_error;\n\t\t\tif (fr_snap_parse(skb, pvc))\n\t\t\t\tgoto rx_drop;\n\t\t} else {\n\t\t\tgoto rx_drop;\n\t\t}\n\n\t} else {\n\t\tnetdev_info(frad, \"Unsupported protocol, NLPID=%x length=%i\\n\",\n\t\t\t    data[3], skb->len);\n\t\tgoto rx_drop;\n\t}\n\n\tdev = skb->dev;\n\tdev->stats.rx_packets++;  \n\tdev->stats.rx_bytes += skb->len;\n\tif (pvc->state.becn)\n\t\tdev->stats.rx_compressed++;\n\tnetif_rx(skb);\n\treturn NET_RX_SUCCESS;\n\nrx_error:\n\tfrad->stats.rx_errors++;  \nrx_drop:\n\tdev_kfree_skb_any(skb);\n\treturn NET_RX_DROP;\n}\n\nstatic void fr_start(struct net_device *dev)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n#ifdef DEBUG_LINK\n\tprintk(KERN_DEBUG \"fr_start\\n\");\n#endif\n\tif (state(hdlc)->settings.lmi != LMI_NONE) {\n\t\tstate(hdlc)->reliable = 0;\n\t\tstate(hdlc)->dce_changed = 1;\n\t\tstate(hdlc)->request = 0;\n\t\tstate(hdlc)->fullrep_sent = 0;\n\t\tstate(hdlc)->last_errors = 0xFFFFFFFF;\n\t\tstate(hdlc)->n391cnt = 0;\n\t\tstate(hdlc)->txseq = state(hdlc)->rxseq = 0;\n\n\t\tstate(hdlc)->dev = dev;\n\t\ttimer_setup(&state(hdlc)->timer, fr_timer, 0);\n\t\t \n\t\tstate(hdlc)->timer.expires = jiffies + HZ;\n\t\tadd_timer(&state(hdlc)->timer);\n\t} else {\n\t\tfr_set_link_state(1, dev);\n\t}\n}\n\nstatic void fr_stop(struct net_device *dev)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n#ifdef DEBUG_LINK\n\tprintk(KERN_DEBUG \"fr_stop\\n\");\n#endif\n\tif (state(hdlc)->settings.lmi != LMI_NONE)\n\t\tdel_timer_sync(&state(hdlc)->timer);\n\tfr_set_link_state(0, dev);\n}\n\nstatic void fr_close(struct net_device *dev)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tstruct pvc_device *pvc = state(hdlc)->first_pvc;\n\n\twhile (pvc) {\t\t \n\t\tif (pvc->main)\n\t\t\tdev_close(pvc->main);\n\t\tif (pvc->ether)\n\t\t\tdev_close(pvc->ether);\n\t\tpvc = pvc->next;\n\t}\n}\n\nstatic void pvc_setup(struct net_device *dev)\n{\n\tdev->type = ARPHRD_DLCI;\n\tdev->flags = IFF_POINTOPOINT;\n\tdev->hard_header_len = 0;\n\tdev->addr_len = 2;\n\tnetif_keep_dst(dev);\n}\n\nstatic const struct net_device_ops pvc_ops = {\n\t.ndo_open       = pvc_open,\n\t.ndo_stop       = pvc_close,\n\t.ndo_start_xmit = pvc_xmit,\n\t.ndo_siocwandev = pvc_ioctl,\n};\n\nstatic int fr_add_pvc(struct net_device *frad, unsigned int dlci, int type)\n{\n\thdlc_device *hdlc = dev_to_hdlc(frad);\n\tstruct pvc_device *pvc;\n\tstruct net_device *dev;\n\tint used;\n\n\tpvc = add_pvc(frad, dlci);\n\tif (!pvc) {\n\t\tnetdev_warn(frad, \"Memory squeeze on fr_add_pvc()\\n\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tif (*get_dev_p(pvc, type))\n\t\treturn -EEXIST;\n\n\tused = pvc_is_used(pvc);\n\n\tif (type == ARPHRD_ETHER)\n\t\tdev = alloc_netdev(0, \"pvceth%d\", NET_NAME_UNKNOWN,\n\t\t\t\t   ether_setup);\n\telse\n\t\tdev = alloc_netdev(0, \"pvc%d\", NET_NAME_UNKNOWN, pvc_setup);\n\n\tif (!dev) {\n\t\tnetdev_warn(frad, \"Memory squeeze on fr_pvc()\\n\");\n\t\tdelete_unused_pvcs(hdlc);\n\t\treturn -ENOBUFS;\n\t}\n\n\tif (type == ARPHRD_ETHER) {\n\t\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\t\teth_hw_addr_random(dev);\n\t} else {\n\t\t__be16 addr = htons(dlci);\n\n\t\tdev_addr_set(dev, (u8 *)&addr);\n\t\tdlci_to_q922(dev->broadcast, dlci);\n\t}\n\tdev->netdev_ops = &pvc_ops;\n\tdev->mtu = HDLC_MAX_MTU;\n\tdev->min_mtu = 68;\n\tdev->max_mtu = HDLC_MAX_MTU;\n\tdev->needed_headroom = 10;\n\tdev->priv_flags |= IFF_NO_QUEUE;\n\tdev->ml_priv = pvc;\n\n\tif (register_netdevice(dev) != 0) {\n\t\tfree_netdev(dev);\n\t\tdelete_unused_pvcs(hdlc);\n\t\treturn -EIO;\n\t}\n\n\tdev->needs_free_netdev = true;\n\t*get_dev_p(pvc, type) = dev;\n\tif (!used) {\n\t\tstate(hdlc)->dce_changed = 1;\n\t\tstate(hdlc)->dce_pvc_count++;\n\t}\n\treturn 0;\n}\n\nstatic int fr_del_pvc(hdlc_device *hdlc, unsigned int dlci, int type)\n{\n\tstruct pvc_device *pvc;\n\tstruct net_device *dev;\n\n\tpvc = find_pvc(hdlc, dlci);\n\tif (!pvc)\n\t\treturn -ENOENT;\n\n\tdev = *get_dev_p(pvc, type);\n\tif (!dev)\n\t\treturn -ENOENT;\n\n\tif (dev->flags & IFF_UP)\n\t\treturn -EBUSY;\t\t \n\n\tunregister_netdevice(dev);  \n\t*get_dev_p(pvc, type) = NULL;\n\n\tif (!pvc_is_used(pvc)) {\n\t\tstate(hdlc)->dce_pvc_count--;\n\t\tstate(hdlc)->dce_changed = 1;\n\t}\n\tdelete_unused_pvcs(hdlc);\n\treturn 0;\n}\n\nstatic void fr_destroy(struct net_device *frad)\n{\n\thdlc_device *hdlc = dev_to_hdlc(frad);\n\tstruct pvc_device *pvc = state(hdlc)->first_pvc;\n\n\tstate(hdlc)->first_pvc = NULL;  \n\tstate(hdlc)->dce_pvc_count = 0;\n\tstate(hdlc)->dce_changed = 1;\n\n\twhile (pvc) {\n\t\tstruct pvc_device *next = pvc->next;\n\t\t \n\t\tif (pvc->main)\n\t\t\tunregister_netdevice(pvc->main);\n\n\t\tif (pvc->ether)\n\t\t\tunregister_netdevice(pvc->ether);\n\n\t\tkfree(pvc);\n\t\tpvc = next;\n\t}\n}\n\nstatic struct hdlc_proto proto = {\n\t.close\t\t= fr_close,\n\t.start\t\t= fr_start,\n\t.stop\t\t= fr_stop,\n\t.detach\t\t= fr_destroy,\n\t.ioctl\t\t= fr_ioctl,\n\t.netif_rx\t= fr_rx,\n\t.module\t\t= THIS_MODULE,\n};\n\nstatic int fr_ioctl(struct net_device *dev, struct if_settings *ifs)\n{\n\tfr_proto __user *fr_s = ifs->ifs_ifsu.fr;\n\tconst size_t size = sizeof(fr_proto);\n\tfr_proto new_settings;\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tfr_proto_pvc pvc;\n\tint result;\n\n\tswitch (ifs->type) {\n\tcase IF_GET_PROTO:\n\t\tif (dev_to_hdlc(dev)->proto != &proto)  \n\t\t\treturn -EINVAL;\n\t\tifs->type = IF_PROTO_FR;\n\t\tif (ifs->size < size) {\n\t\t\tifs->size = size;  \n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tif (copy_to_user(fr_s, &state(hdlc)->settings, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase IF_PROTO_FR:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (dev->flags & IFF_UP)\n\t\t\treturn -EBUSY;\n\n\t\tif (copy_from_user(&new_settings, fr_s, size))\n\t\t\treturn -EFAULT;\n\n\t\tif (new_settings.lmi == LMI_DEFAULT)\n\t\t\tnew_settings.lmi = LMI_ANSI;\n\n\t\tif ((new_settings.lmi != LMI_NONE &&\n\t\t     new_settings.lmi != LMI_ANSI &&\n\t\t     new_settings.lmi != LMI_CCITT &&\n\t\t     new_settings.lmi != LMI_CISCO) ||\n\t\t    new_settings.t391 < 1 ||\n\t\t    new_settings.t392 < 2 ||\n\t\t    new_settings.n391 < 1 ||\n\t\t    new_settings.n392 < 1 ||\n\t\t    new_settings.n393 < new_settings.n392 ||\n\t\t    new_settings.n393 > 32 ||\n\t\t    (new_settings.dce != 0 &&\n\t\t     new_settings.dce != 1))\n\t\t\treturn -EINVAL;\n\n\t\tresult = hdlc->attach(dev, ENCODING_NRZ,\n\t\t\t\t      PARITY_CRC16_PR1_CCITT);\n\t\tif (result)\n\t\t\treturn result;\n\n\t\tif (dev_to_hdlc(dev)->proto != &proto) {  \n\t\t\tresult = attach_hdlc_protocol(dev, &proto,\n\t\t\t\t\t\t      sizeof(struct frad_state));\n\t\t\tif (result)\n\t\t\t\treturn result;\n\t\t\tstate(hdlc)->first_pvc = NULL;\n\t\t\tstate(hdlc)->dce_pvc_count = 0;\n\t\t}\n\t\tmemcpy(&state(hdlc)->settings, &new_settings, size);\n\t\tdev->type = ARPHRD_FRAD;\n\t\tcall_netdevice_notifiers(NETDEV_POST_TYPE_CHANGE, dev);\n\t\treturn 0;\n\n\tcase IF_PROTO_FR_ADD_PVC:\n\tcase IF_PROTO_FR_DEL_PVC:\n\tcase IF_PROTO_FR_ADD_ETH_PVC:\n\tcase IF_PROTO_FR_DEL_ETH_PVC:\n\t\tif (dev_to_hdlc(dev)->proto != &proto)  \n\t\t\treturn -EINVAL;\n\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&pvc, ifs->ifs_ifsu.fr_pvc,\n\t\t\t\t   sizeof(fr_proto_pvc)))\n\t\t\treturn -EFAULT;\n\n\t\tif (pvc.dlci <= 0 || pvc.dlci >= 1024)\n\t\t\treturn -EINVAL;\t \n\n\t\tif (ifs->type == IF_PROTO_FR_ADD_ETH_PVC ||\n\t\t    ifs->type == IF_PROTO_FR_DEL_ETH_PVC)\n\t\t\tresult = ARPHRD_ETHER;  \n\t\telse\n\t\t\tresult = ARPHRD_DLCI;\n\n\t\tif (ifs->type == IF_PROTO_FR_ADD_PVC ||\n\t\t    ifs->type == IF_PROTO_FR_ADD_ETH_PVC)\n\t\t\treturn fr_add_pvc(dev, pvc.dlci, result);\n\t\telse\n\t\t\treturn fr_del_pvc(hdlc, pvc.dlci, result);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int __init hdlc_fr_init(void)\n{\n\tregister_hdlc_protocol(&proto);\n\treturn 0;\n}\n\nstatic void __exit hdlc_fr_exit(void)\n{\n\tunregister_hdlc_protocol(&proto);\n}\n\nmodule_init(hdlc_fr_init);\nmodule_exit(hdlc_fr_exit);\n\nMODULE_AUTHOR(\"Krzysztof Halasa <khc@pm.waw.pl>\");\nMODULE_DESCRIPTION(\"Frame-Relay protocol support for generic HDLC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}