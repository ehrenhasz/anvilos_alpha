{
  "module_name": "wanxl.c",
  "hash_id": "a372efd7f7cad97e7467e2e5beb7b116b0e9d1ada8277938a0f9b40ac39f7f79",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wan/wanxl.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/netdevice.h>\n#include <linux/hdlc.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <asm/io.h>\n\n#include \"wanxl.h\"\n\nstatic const char *version = \"wanXL serial card driver version: 0.48\";\n\n#define PLX_CTL_RESET   0x40000000  \n\n#undef DEBUG_PKT\n#undef DEBUG_PCI\n\n \n#define MBX1_CMD_ABORTJ 0x85000000  \n#ifdef __LITTLE_ENDIAN\n#define MBX1_CMD_BSWAP  0x8C000001  \n#else\n#define MBX1_CMD_BSWAP  0x8C000000  \n#endif\n\n \n#define MBX2_MEMSZ_MASK 0xFFFF0000  \n\nstruct port {\n\tstruct net_device *dev;\n\tstruct card *card;\n\tspinlock_t lock;\t \n\tint node;\t\t \n\tunsigned int clock_type;\n\tint tx_in, tx_out;\n\tstruct sk_buff *tx_skbs[TX_BUFFERS];\n};\n\nstruct card_status {\n\tdesc_t rx_descs[RX_QUEUE_LENGTH];\n\tport_status_t port_status[4];\n};\n\nstruct card {\n\tint n_ports;\t\t \n\tu8 irq;\n\n\tu8 __iomem *plx;\t \n\tstruct pci_dev *pdev;\t \n\tint rx_in;\n\tstruct sk_buff *rx_skbs[RX_QUEUE_LENGTH];\n\tstruct card_status *status;\t \n\tdma_addr_t status_address;\n\tstruct port ports[];\t \n};\n\nstatic inline struct port *dev_to_port(struct net_device *dev)\n{\n\treturn (struct port *)dev_to_hdlc(dev)->priv;\n}\n\nstatic inline port_status_t *get_status(struct port *port)\n{\n\treturn &port->card->status->port_status[port->node];\n}\n\n#ifdef DEBUG_PCI\nstatic inline dma_addr_t pci_map_single_debug(struct pci_dev *pdev, void *ptr,\n\t\t\t\t\t      size_t size, int direction)\n{\n\tdma_addr_t addr = dma_map_single(&pdev->dev, ptr, size, direction);\n\n\tif (addr + size > 0x100000000LL)\n\t\tpr_crit(\"%s: pci_map_single() returned memory at 0x%llx!\\n\",\n\t\t\tpci_name(pdev), (unsigned long long)addr);\n\treturn addr;\n}\n\n#undef pci_map_single\n#define pci_map_single pci_map_single_debug\n#endif\n\n \nstatic inline void wanxl_cable_intr(struct port *port)\n{\n\tu32 value = get_status(port)->cable;\n\tint valid = 1;\n\tconst char *cable, *pm, *dte = \"\", *dsr = \"\", *dcd = \"\";\n\n\tswitch (value & 0x7) {\n\tcase STATUS_CABLE_V35:\n\t\tcable = \"V.35\";\n\t\tbreak;\n\tcase STATUS_CABLE_X21:\n\t\tcable = \"X.21\";\n\t\tbreak;\n\tcase STATUS_CABLE_V24:\n\t\tcable = \"V.24\";\n\t\tbreak;\n\tcase STATUS_CABLE_EIA530:\n\t\tcable = \"EIA530\";\n\t\tbreak;\n\tcase STATUS_CABLE_NONE:\n\t\tcable = \"no\";\n\t\tbreak;\n\tdefault:\n\t\tcable = \"invalid\";\n\t}\n\n\tswitch ((value >> STATUS_CABLE_PM_SHIFT) & 0x7) {\n\tcase STATUS_CABLE_V35:\n\t\tpm = \"V.35\";\n\t\tbreak;\n\tcase STATUS_CABLE_X21:\n\t\tpm = \"X.21\";\n\t\tbreak;\n\tcase STATUS_CABLE_V24:\n\t\tpm = \"V.24\";\n\t\tbreak;\n\tcase STATUS_CABLE_EIA530:\n\t\tpm = \"EIA530\";\n\t\tbreak;\n\tcase STATUS_CABLE_NONE:\n\t\tpm = \"no personality\";\n\t\tvalid = 0;\n\t\tbreak;\n\tdefault:\n\t\tpm = \"invalid personality\";\n\t\tvalid = 0;\n\t}\n\n\tif (valid) {\n\t\tif ((value & 7) == ((value >> STATUS_CABLE_PM_SHIFT) & 7)) {\n\t\t\tdsr = (value & STATUS_CABLE_DSR) ? \", DSR ON\" :\n\t\t\t\t\", DSR off\";\n\t\t\tdcd = (value & STATUS_CABLE_DCD) ? \", carrier ON\" :\n\t\t\t\t\", carrier off\";\n\t\t}\n\t\tdte = (value & STATUS_CABLE_DCE) ? \" DCE\" : \" DTE\";\n\t}\n\tnetdev_info(port->dev, \"%s%s module, %s cable%s%s\\n\",\n\t\t    pm, dte, cable, dsr, dcd);\n\n\tif (value & STATUS_CABLE_DCD)\n\t\tnetif_carrier_on(port->dev);\n\telse\n\t\tnetif_carrier_off(port->dev);\n}\n\n \nstatic inline void wanxl_tx_intr(struct port *port)\n{\n\tstruct net_device *dev = port->dev;\n\n\twhile (1) {\n\t\tdesc_t *desc = &get_status(port)->tx_descs[port->tx_in];\n\t\tstruct sk_buff *skb = port->tx_skbs[port->tx_in];\n\n\t\tswitch (desc->stat) {\n\t\tcase PACKET_FULL:\n\t\tcase PACKET_EMPTY:\n\t\t\tnetif_wake_queue(dev);\n\t\t\treturn;\n\n\t\tcase PACKET_UNDERRUN:\n\t\t\tdev->stats.tx_errors++;\n\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev->stats.tx_packets++;\n\t\t\tdev->stats.tx_bytes += skb->len;\n\t\t}\n\t\tdesc->stat = PACKET_EMPTY;  \n\t\tdma_unmap_single(&port->card->pdev->dev, desc->address,\n\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\tdev_consume_skb_irq(skb);\n\t\tport->tx_in = (port->tx_in + 1) % TX_BUFFERS;\n\t}\n}\n\n \nstatic inline void wanxl_rx_intr(struct card *card)\n{\n\tdesc_t *desc;\n\n\twhile (desc = &card->status->rx_descs[card->rx_in],\n\t       desc->stat != PACKET_EMPTY) {\n\t\tif ((desc->stat & PACKET_PORT_MASK) > card->n_ports) {\n\t\t\tpr_crit(\"%s: received packet for nonexistent port\\n\",\n\t\t\t\tpci_name(card->pdev));\n\t\t} else {\n\t\t\tstruct sk_buff *skb = card->rx_skbs[card->rx_in];\n\t\t\tstruct port *port = &card->ports[desc->stat &\n\t\t\t\t\t\t    PACKET_PORT_MASK];\n\t\t\tstruct net_device *dev = port->dev;\n\n\t\t\tif (!skb) {\n\t\t\t\tdev->stats.rx_dropped++;\n\t\t\t} else {\n\t\t\t\tdma_unmap_single(&card->pdev->dev,\n\t\t\t\t\t\t desc->address, BUFFER_LENGTH,\n\t\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\t\tskb_put(skb, desc->length);\n\n#ifdef DEBUG_PKT\n\t\t\t\tprintk(KERN_DEBUG \"%s RX(%i):\", dev->name,\n\t\t\t\t       skb->len);\n\t\t\t\tdebug_frame(skb);\n#endif\n\t\t\t\tdev->stats.rx_packets++;\n\t\t\t\tdev->stats.rx_bytes += skb->len;\n\t\t\t\tskb->protocol = hdlc_type_trans(skb, dev);\n\t\t\t\tnetif_rx(skb);\n\t\t\t\tskb = NULL;\n\t\t\t}\n\n\t\t\tif (!skb) {\n\t\t\t\tskb = dev_alloc_skb(BUFFER_LENGTH);\n\t\t\t\tdesc->address = skb ?\n\t\t\t\t\tdma_map_single(&card->pdev->dev,\n\t\t\t\t\t\t       skb->data,\n\t\t\t\t\t\t       BUFFER_LENGTH,\n\t\t\t\t\t\t       DMA_FROM_DEVICE) : 0;\n\t\t\t\tcard->rx_skbs[card->rx_in] = skb;\n\t\t\t}\n\t\t}\n\t\tdesc->stat = PACKET_EMPTY;  \n\t\tcard->rx_in = (card->rx_in + 1) % RX_QUEUE_LENGTH;\n\t}\n}\n\nstatic irqreturn_t wanxl_intr(int irq, void *dev_id)\n{\n\tstruct card *card = dev_id;\n\tint i;\n\tu32 stat;\n\tint handled = 0;\n\n\twhile ((stat = readl(card->plx + PLX_DOORBELL_FROM_CARD)) != 0) {\n\t\thandled = 1;\n\t\twritel(stat, card->plx + PLX_DOORBELL_FROM_CARD);\n\n\t\tfor (i = 0; i < card->n_ports; i++) {\n\t\t\tif (stat & (1 << (DOORBELL_FROM_CARD_TX_0 + i)))\n\t\t\t\twanxl_tx_intr(&card->ports[i]);\n\t\t\tif (stat & (1 << (DOORBELL_FROM_CARD_CABLE_0 + i)))\n\t\t\t\twanxl_cable_intr(&card->ports[i]);\n\t\t}\n\t\tif (stat & (1 << DOORBELL_FROM_CARD_RX))\n\t\t\twanxl_rx_intr(card);\n\t}\n\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic netdev_tx_t wanxl_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct port *port = dev_to_port(dev);\n\tdesc_t *desc;\n\n\tspin_lock(&port->lock);\n\n\tdesc = &get_status(port)->tx_descs[port->tx_out];\n\tif (desc->stat != PACKET_EMPTY) {\n\t\t \n#ifdef DEBUG_PKT\n                printk(KERN_DEBUG \"%s: transmitter buffer full\\n\", dev->name);\n#endif\n\t\tnetif_stop_queue(dev);\n\t\tspin_unlock(&port->lock);\n\t\treturn NETDEV_TX_BUSY;        \n\t}\n\n#ifdef DEBUG_PKT\n\tprintk(KERN_DEBUG \"%s TX(%i):\", dev->name, skb->len);\n\tdebug_frame(skb);\n#endif\n\n\tport->tx_skbs[port->tx_out] = skb;\n\tdesc->address = dma_map_single(&port->card->pdev->dev, skb->data,\n\t\t\t\t       skb->len, DMA_TO_DEVICE);\n\tdesc->length = skb->len;\n\tdesc->stat = PACKET_FULL;\n\twritel(1 << (DOORBELL_TO_CARD_TX_0 + port->node),\n\t       port->card->plx + PLX_DOORBELL_TO_CARD);\n\n\tport->tx_out = (port->tx_out + 1) % TX_BUFFERS;\n\n\tif (get_status(port)->tx_descs[port->tx_out].stat != PACKET_EMPTY) {\n\t\tnetif_stop_queue(dev);\n#ifdef DEBUG_PKT\n\t\tprintk(KERN_DEBUG \"%s: transmitter buffer full\\n\", dev->name);\n#endif\n\t}\n\n\tspin_unlock(&port->lock);\n\treturn NETDEV_TX_OK;\n}\n\nstatic int wanxl_attach(struct net_device *dev, unsigned short encoding,\n\t\t\tunsigned short parity)\n{\n\tstruct port *port = dev_to_port(dev);\n\n\tif (encoding != ENCODING_NRZ &&\n\t    encoding != ENCODING_NRZI)\n\t\treturn -EINVAL;\n\n\tif (parity != PARITY_NONE &&\n\t    parity != PARITY_CRC32_PR1_CCITT &&\n\t    parity != PARITY_CRC16_PR1_CCITT &&\n\t    parity != PARITY_CRC32_PR0_CCITT &&\n\t    parity != PARITY_CRC16_PR0_CCITT)\n\t\treturn -EINVAL;\n\n\tget_status(port)->encoding = encoding;\n\tget_status(port)->parity = parity;\n\treturn 0;\n}\n\nstatic int wanxl_ioctl(struct net_device *dev, struct if_settings *ifs)\n{\n\tconst size_t size = sizeof(sync_serial_settings);\n\tsync_serial_settings line;\n\tstruct port *port = dev_to_port(dev);\n\n\tswitch (ifs->type) {\n\tcase IF_GET_IFACE:\n\t\tifs->type = IF_IFACE_SYNC_SERIAL;\n\t\tif (ifs->size < size) {\n\t\t\tifs->size = size;  \n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tmemset(&line, 0, sizeof(line));\n\t\tline.clock_type = get_status(port)->clocking;\n\t\tline.clock_rate = 0;\n\t\tline.loopback = 0;\n\n\t\tif (copy_to_user(ifs->ifs_ifsu.sync, &line, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase IF_IFACE_SYNC_SERIAL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (dev->flags & IFF_UP)\n\t\t\treturn -EBUSY;\n\n\t\tif (copy_from_user(&line, ifs->ifs_ifsu.sync,\n\t\t\t\t   size))\n\t\t\treturn -EFAULT;\n\n\t\tif (line.clock_type != CLOCK_EXT &&\n\t\t    line.clock_type != CLOCK_TXFROMRX)\n\t\t\treturn -EINVAL;  \n\n\t\tif (line.loopback != 0)\n\t\t\treturn -EINVAL;\n\n\t\tget_status(port)->clocking = line.clock_type;\n\t\treturn 0;\n\n\tdefault:\n\t\treturn hdlc_ioctl(dev, ifs);\n\t}\n}\n\nstatic int wanxl_open(struct net_device *dev)\n{\n\tstruct port *port = dev_to_port(dev);\n\tu8 __iomem *dbr = port->card->plx + PLX_DOORBELL_TO_CARD;\n\tunsigned long timeout;\n\tint i;\n\n\tif (get_status(port)->open) {\n\t\tnetdev_err(dev, \"port already open\\n\");\n\t\treturn -EIO;\n\t}\n\n\ti = hdlc_open(dev);\n\tif (i)\n\t\treturn i;\n\n\tport->tx_in = port->tx_out = 0;\n\tfor (i = 0; i < TX_BUFFERS; i++)\n\t\tget_status(port)->tx_descs[i].stat = PACKET_EMPTY;\n\t \n\twritel(1 << (DOORBELL_TO_CARD_OPEN_0 + port->node), dbr);\n\n\ttimeout = jiffies + HZ;\n\tdo {\n\t\tif (get_status(port)->open) {\n\t\t\tnetif_start_queue(dev);\n\t\t\treturn 0;\n\t\t}\n\t} while (time_after(timeout, jiffies));\n\n\tnetdev_err(dev, \"unable to open port\\n\");\n\t \n\twritel(1 << (DOORBELL_TO_CARD_CLOSE_0 + port->node), dbr);\n\treturn -EFAULT;\n}\n\nstatic int wanxl_close(struct net_device *dev)\n{\n\tstruct port *port = dev_to_port(dev);\n\tunsigned long timeout;\n\tint i;\n\n\thdlc_close(dev);\n\t \n\twritel(1 << (DOORBELL_TO_CARD_CLOSE_0 + port->node),\n\t       port->card->plx + PLX_DOORBELL_TO_CARD);\n\n\ttimeout = jiffies + HZ;\n\tdo {\n\t\tif (!get_status(port)->open)\n\t\t\tbreak;\n\t} while (time_after(timeout, jiffies));\n\n\tif (get_status(port)->open)\n\t\tnetdev_err(dev, \"unable to close port\\n\");\n\n\tnetif_stop_queue(dev);\n\n\tfor (i = 0; i < TX_BUFFERS; i++) {\n\t\tdesc_t *desc = &get_status(port)->tx_descs[i];\n\n\t\tif (desc->stat != PACKET_EMPTY) {\n\t\t\tdesc->stat = PACKET_EMPTY;\n\t\t\tdma_unmap_single(&port->card->pdev->dev,\n\t\t\t\t\t desc->address, port->tx_skbs[i]->len,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb(port->tx_skbs[i]);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic struct net_device_stats *wanxl_get_stats(struct net_device *dev)\n{\n\tstruct port *port = dev_to_port(dev);\n\n\tdev->stats.rx_over_errors = get_status(port)->rx_overruns;\n\tdev->stats.rx_frame_errors = get_status(port)->rx_frame_errors;\n\tdev->stats.rx_errors = dev->stats.rx_over_errors +\n\t\tdev->stats.rx_frame_errors;\n\treturn &dev->stats;\n}\n\nstatic int wanxl_puts_command(struct card *card, u32 cmd)\n{\n\tunsigned long timeout = jiffies + 5 * HZ;\n\n\twritel(cmd, card->plx + PLX_MAILBOX_1);\n\tdo {\n\t\tif (readl(card->plx + PLX_MAILBOX_1) == 0)\n\t\t\treturn 0;\n\n\t\tschedule();\n\t} while (time_after(timeout, jiffies));\n\n\treturn -1;\n}\n\nstatic void wanxl_reset(struct card *card)\n{\n\tu32 old_value = readl(card->plx + PLX_CONTROL) & ~PLX_CTL_RESET;\n\n\twritel(0x80, card->plx + PLX_MAILBOX_0);\n\twritel(old_value | PLX_CTL_RESET, card->plx + PLX_CONTROL);\n\treadl(card->plx + PLX_CONTROL);  \n\tudelay(1);\n\twritel(old_value, card->plx + PLX_CONTROL);\n\treadl(card->plx + PLX_CONTROL);  \n}\n\nstatic void wanxl_pci_remove_one(struct pci_dev *pdev)\n{\n\tstruct card *card = pci_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < card->n_ports; i++) {\n\t\tunregister_hdlc_device(card->ports[i].dev);\n\t\tfree_netdev(card->ports[i].dev);\n\t}\n\n\t \n\tif (card->irq)\n\t\tfree_irq(card->irq, card);\n\n\twanxl_reset(card);\n\n\tfor (i = 0; i < RX_QUEUE_LENGTH; i++)\n\t\tif (card->rx_skbs[i]) {\n\t\t\tdma_unmap_single(&card->pdev->dev,\n\t\t\t\t\t card->status->rx_descs[i].address,\n\t\t\t\t\t BUFFER_LENGTH, DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(card->rx_skbs[i]);\n\t\t}\n\n\tif (card->plx)\n\t\tiounmap(card->plx);\n\n\tif (card->status)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct card_status),\n\t\t\t\t  card->status, card->status_address);\n\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tkfree(card);\n}\n\n#include \"wanxlfw.inc\"\n\nstatic const struct net_device_ops wanxl_ops = {\n\t.ndo_open       = wanxl_open,\n\t.ndo_stop       = wanxl_close,\n\t.ndo_start_xmit = hdlc_start_xmit,\n\t.ndo_siocwandev = wanxl_ioctl,\n\t.ndo_get_stats  = wanxl_get_stats,\n};\n\nstatic int wanxl_pci_init_one(struct pci_dev *pdev,\n\t\t\t      const struct pci_device_id *ent)\n{\n\tstruct card *card;\n\tu32 ramsize, stat;\n\tunsigned long timeout;\n\tu32 plx_phy;\t\t \n\tu32 mem_phy;\t\t \n\tu8 __iomem *mem;\t \n\tint i, ports;\n\n#ifndef MODULE\n\tpr_info_once(\"%s\\n\", version);\n#endif\n\n\ti = pci_enable_device(pdev);\n\tif (i)\n\t\treturn i;\n\n\t \n\n\t \n\tif (dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(28)) ||\n\t    dma_set_mask(&pdev->dev, DMA_BIT_MASK(28))) {\n\t\tpr_err(\"No usable DMA configuration\\n\");\n\t\tpci_disable_device(pdev);\n\t\treturn -EIO;\n\t}\n\n\ti = pci_request_regions(pdev, \"wanXL\");\n\tif (i) {\n\t\tpci_disable_device(pdev);\n\t\treturn i;\n\t}\n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_SBE_WANXL100:\n\t\tports = 1;\n\t\tbreak;\n\tcase PCI_DEVICE_ID_SBE_WANXL200:\n\t\tports = 2;\n\t\tbreak;\n\tdefault:\n\t\tports = 4;\n\t}\n\n\tcard = kzalloc(struct_size(card, ports, ports), GFP_KERNEL);\n\tif (!card) {\n\t\tpci_release_regions(pdev);\n\t\tpci_disable_device(pdev);\n\t\treturn -ENOBUFS;\n\t}\n\n\tpci_set_drvdata(pdev, card);\n\tcard->pdev = pdev;\n\n\tcard->status = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t  sizeof(struct card_status),\n\t\t\t\t\t  &card->status_address, GFP_KERNEL);\n\tif (!card->status) {\n\t\twanxl_pci_remove_one(pdev);\n\t\treturn -ENOBUFS;\n\t}\n\n#ifdef DEBUG_PCI\n\tprintk(KERN_DEBUG \"wanXL %s: pci_alloc_consistent() returned memory\"\n\t       \" at 0x%LX\\n\", pci_name(pdev),\n\t       (unsigned long long)card->status_address);\n#endif\n\n\t \n\tif (dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32)) ||\n\t    dma_set_mask(&pdev->dev, DMA_BIT_MASK(32))) {\n\t\tpr_err(\"No usable DMA configuration\\n\");\n\t\twanxl_pci_remove_one(pdev);\n\t\treturn -EIO;\n\t}\n\n\t \n\tplx_phy = pci_resource_start(pdev, 0);\n\n\tcard->plx = ioremap(plx_phy, 0x70);\n\tif (!card->plx) {\n\t\tpr_err(\"ioremap() failed\\n\");\n\t\twanxl_pci_remove_one(pdev);\n\t\treturn -EFAULT;\n\t}\n\n#if RESET_WHILE_LOADING\n\twanxl_reset(card);\n#endif\n\n\ttimeout = jiffies + 20 * HZ;\n\twhile ((stat = readl(card->plx + PLX_MAILBOX_0)) != 0) {\n\t\tif (time_before(timeout, jiffies)) {\n\t\t\tpr_warn(\"%s: timeout waiting for PUTS to complete\\n\",\n\t\t\t\tpci_name(pdev));\n\t\t\twanxl_pci_remove_one(pdev);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tswitch (stat & 0xC0) {\n\t\tcase 0x00:\t \n\t\tcase 0x80:\t \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_warn(\"%s: PUTS test 0x%X failed\\n\",\n\t\t\t\tpci_name(pdev), stat & 0x30);\n\t\t\twanxl_pci_remove_one(pdev);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tschedule();\n\t}\n\n\t \n\tramsize = readl(card->plx + PLX_MAILBOX_2) & MBX2_MEMSZ_MASK;\n\n\t \n\tmem_phy = pci_resource_start(pdev, 2);\n\n\t \n\tif (ramsize < BUFFERS_ADDR +\n\t    (TX_BUFFERS + RX_BUFFERS) * BUFFER_LENGTH * ports) {\n\t\tpr_warn(\"%s: no enough on-board RAM (%u bytes detected, %u bytes required)\\n\",\n\t\t\tpci_name(pdev), ramsize,\n\t\t\tBUFFERS_ADDR +\n\t\t\t(TX_BUFFERS + RX_BUFFERS) * BUFFER_LENGTH * ports);\n\t\twanxl_pci_remove_one(pdev);\n\t\treturn -ENODEV;\n\t}\n\n\tif (wanxl_puts_command(card, MBX1_CMD_BSWAP)) {\n\t\tpr_warn(\"%s: unable to Set Byte Swap Mode\\n\", pci_name(pdev));\n\t\twanxl_pci_remove_one(pdev);\n\t\treturn -ENODEV;\n\t}\n\n\tfor (i = 0; i < RX_QUEUE_LENGTH; i++) {\n\t\tstruct sk_buff *skb = dev_alloc_skb(BUFFER_LENGTH);\n\n\t\tcard->rx_skbs[i] = skb;\n\t\tif (skb)\n\t\t\tcard->status->rx_descs[i].address =\n\t\t\t\tdma_map_single(&card->pdev->dev, skb->data,\n\t\t\t\t\t       BUFFER_LENGTH, DMA_FROM_DEVICE);\n\t}\n\n\tmem = ioremap(mem_phy, PDM_OFFSET + sizeof(firmware));\n\tif (!mem) {\n\t\tpr_err(\"ioremap() failed\\n\");\n\t\twanxl_pci_remove_one(pdev);\n\t\treturn -EFAULT;\n\t}\n\n\tfor (i = 0; i < sizeof(firmware); i += 4)\n\t\twritel(ntohl(*(__be32 *)(firmware + i)), mem + PDM_OFFSET + i);\n\n\tfor (i = 0; i < ports; i++)\n\t\twritel(card->status_address +\n\t\t       (void *)&card->status->port_status[i] -\n\t\t       (void *)card->status, mem + PDM_OFFSET + 4 + i * 4);\n\twritel(card->status_address, mem + PDM_OFFSET + 20);\n\twritel(PDM_OFFSET, mem);\n\tiounmap(mem);\n\n\twritel(0, card->plx + PLX_MAILBOX_5);\n\n\tif (wanxl_puts_command(card, MBX1_CMD_ABORTJ)) {\n\t\tpr_warn(\"%s: unable to Abort and Jump\\n\", pci_name(pdev));\n\t\twanxl_pci_remove_one(pdev);\n\t\treturn -ENODEV;\n\t}\n\n\ttimeout = jiffies + 5 * HZ;\n\tdo {\n\t\tstat = readl(card->plx + PLX_MAILBOX_5);\n\t\tif (stat)\n\t\t\tbreak;\n\t\tschedule();\n\t} while (time_after(timeout, jiffies));\n\n\tif (!stat) {\n\t\tpr_warn(\"%s: timeout while initializing card firmware\\n\",\n\t\t\tpci_name(pdev));\n\t\twanxl_pci_remove_one(pdev);\n\t\treturn -ENODEV;\n\t}\n\n#if DETECT_RAM\n\tramsize = stat;\n#endif\n\n\tpr_info(\"%s: at 0x%X, %u KB of RAM at 0x%X, irq %u\\n\",\n\t\tpci_name(pdev), plx_phy, ramsize / 1024, mem_phy, pdev->irq);\n\n\t \n\tif (request_irq(pdev->irq, wanxl_intr, IRQF_SHARED, \"wanXL\", card)) {\n\t\tpr_warn(\"%s: could not allocate IRQ%i\\n\",\n\t\t\tpci_name(pdev), pdev->irq);\n\t\twanxl_pci_remove_one(pdev);\n\t\treturn -EBUSY;\n\t}\n\tcard->irq = pdev->irq;\n\n\tfor (i = 0; i < ports; i++) {\n\t\thdlc_device *hdlc;\n\t\tstruct port *port = &card->ports[i];\n\t\tstruct net_device *dev = alloc_hdlcdev(port);\n\n\t\tif (!dev) {\n\t\t\tpr_err(\"%s: unable to allocate memory\\n\",\n\t\t\t       pci_name(pdev));\n\t\t\twanxl_pci_remove_one(pdev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tport->dev = dev;\n\t\thdlc = dev_to_hdlc(dev);\n\t\tspin_lock_init(&port->lock);\n\t\tdev->tx_queue_len = 50;\n\t\tdev->netdev_ops = &wanxl_ops;\n\t\thdlc->attach = wanxl_attach;\n\t\thdlc->xmit = wanxl_xmit;\n\t\tport->card = card;\n\t\tport->node = i;\n\t\tget_status(port)->clocking = CLOCK_EXT;\n\t\tif (register_hdlc_device(dev)) {\n\t\t\tpr_err(\"%s: unable to register hdlc device\\n\",\n\t\t\t       pci_name(pdev));\n\t\t\tfree_netdev(dev);\n\t\t\twanxl_pci_remove_one(pdev);\n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tcard->n_ports++;\n\t}\n\n\tpr_info(\"%s: port\", pci_name(pdev));\n\tfor (i = 0; i < ports; i++)\n\t\tpr_cont(\"%s #%i: %s\",\n\t\t\ti ? \",\" : \"\", i, card->ports[i].dev->name);\n\tpr_cont(\"\\n\");\n\n\tfor (i = 0; i < ports; i++)\n\t\twanxl_cable_intr(&card->ports[i]);  \n\n\treturn 0;\n}\n\nstatic const struct pci_device_id wanxl_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_SBE, PCI_DEVICE_ID_SBE_WANXL100, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_SBE, PCI_DEVICE_ID_SBE_WANXL200, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_SBE, PCI_DEVICE_ID_SBE_WANXL400, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, 0, 0 },\n\t{ 0, }\n};\n\nstatic struct pci_driver wanxl_pci_driver = {\n\t.name\t\t= \"wanXL\",\n\t.id_table\t= wanxl_pci_tbl,\n\t.probe\t\t= wanxl_pci_init_one,\n\t.remove\t\t= wanxl_pci_remove_one,\n};\n\nstatic int __init wanxl_init_module(void)\n{\n#ifdef MODULE\n\tpr_info(\"%s\\n\", version);\n#endif\n\treturn pci_register_driver(&wanxl_pci_driver);\n}\n\nstatic void __exit wanxl_cleanup_module(void)\n{\n\tpci_unregister_driver(&wanxl_pci_driver);\n}\n\nMODULE_AUTHOR(\"Krzysztof Halasa <khc@pm.waw.pl>\");\nMODULE_DESCRIPTION(\"SBE Inc. wanXL serial port driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DEVICE_TABLE(pci, wanxl_pci_tbl);\n\nmodule_init(wanxl_init_module);\nmodule_exit(wanxl_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}