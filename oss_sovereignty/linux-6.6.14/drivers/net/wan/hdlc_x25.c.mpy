{
  "module_name": "hdlc_x25.c",
  "hash_id": "cad741c46385095c584a5a2074c448f1fbe1cedf8de18f1f6e82d76a8b38ac0e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wan/hdlc_x25.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/gfp.h>\n#include <linux/hdlc.h>\n#include <linux/if_arp.h>\n#include <linux/inetdevice.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/lapb.h>\n#include <linux/module.h>\n#include <linux/pkt_sched.h>\n#include <linux/poll.h>\n#include <linux/rtnetlink.h>\n#include <linux/skbuff.h>\n#include <net/x25device.h>\n\nstruct x25_state {\n\tx25_hdlc_proto settings;\n\tbool up;\n\tspinlock_t up_lock;  \n\tstruct sk_buff_head rx_queue;\n\tstruct tasklet_struct rx_tasklet;\n};\n\nstatic int x25_ioctl(struct net_device *dev, struct if_settings *ifs);\n\nstatic struct x25_state *state(hdlc_device *hdlc)\n{\n\treturn hdlc->state;\n}\n\nstatic void x25_rx_queue_kick(struct tasklet_struct *t)\n{\n\tstruct x25_state *x25st = from_tasklet(x25st, t, rx_tasklet);\n\tstruct sk_buff *skb = skb_dequeue(&x25st->rx_queue);\n\n\twhile (skb) {\n\t\tnetif_receive_skb_core(skb);\n\t\tskb = skb_dequeue(&x25st->rx_queue);\n\t}\n}\n\n \n\nstatic void x25_connect_disconnect(struct net_device *dev, int reason, int code)\n{\n\tstruct x25_state *x25st = state(dev_to_hdlc(dev));\n\tstruct sk_buff *skb;\n\tunsigned char *ptr;\n\n\tskb = __dev_alloc_skb(1, GFP_ATOMIC | __GFP_NOMEMALLOC);\n\tif (!skb)\n\t\treturn;\n\n\tptr = skb_put(skb, 1);\n\t*ptr = code;\n\n\tskb->protocol = x25_type_trans(skb, dev);\n\n\tskb_queue_tail(&x25st->rx_queue, skb);\n\ttasklet_schedule(&x25st->rx_tasklet);\n}\n\nstatic void x25_connected(struct net_device *dev, int reason)\n{\n\tx25_connect_disconnect(dev, reason, X25_IFACE_CONNECT);\n}\n\nstatic void x25_disconnected(struct net_device *dev, int reason)\n{\n\tx25_connect_disconnect(dev, reason, X25_IFACE_DISCONNECT);\n}\n\nstatic int x25_data_indication(struct net_device *dev, struct sk_buff *skb)\n{\n\tstruct x25_state *x25st = state(dev_to_hdlc(dev));\n\tunsigned char *ptr;\n\n\tif (skb_cow(skb, 1)) {\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\tskb_push(skb, 1);\n\n\tptr  = skb->data;\n\t*ptr = X25_IFACE_DATA;\n\n\tskb->protocol = x25_type_trans(skb, dev);\n\n\tskb_queue_tail(&x25st->rx_queue, skb);\n\ttasklet_schedule(&x25st->rx_tasklet);\n\treturn NET_RX_SUCCESS;\n}\n\nstatic void x25_data_transmit(struct net_device *dev, struct sk_buff *skb)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\n\tskb_reset_network_header(skb);\n\tskb->protocol = hdlc_type_trans(skb, dev);\n\n\tif (dev_nit_active(dev))\n\t\tdev_queue_xmit_nit(skb, dev);\n\n\thdlc->xmit(skb, dev);  \n}\n\nstatic netdev_tx_t x25_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tstruct x25_state *x25st = state(hdlc);\n\tint result;\n\n\t \n\tif (skb->len < 1) {\n\t\tkfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tspin_lock_bh(&x25st->up_lock);\n\tif (!x25st->up) {\n\t\tspin_unlock_bh(&x25st->up_lock);\n\t\tkfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tswitch (skb->data[0]) {\n\tcase X25_IFACE_DATA:\t \n\t\tskb_pull(skb, 1);\n\t\tresult = lapb_data_request(dev, skb);\n\t\tif (result != LAPB_OK)\n\t\t\tdev_kfree_skb(skb);\n\t\tspin_unlock_bh(&x25st->up_lock);\n\t\treturn NETDEV_TX_OK;\n\n\tcase X25_IFACE_CONNECT:\n\t\tresult = lapb_connect_request(dev);\n\t\tif (result != LAPB_OK) {\n\t\t\tif (result == LAPB_CONNECTED)\n\t\t\t\t \n\t\t\t\tx25_connected(dev, 0);\n\t\t\telse\n\t\t\t\tnetdev_err(dev, \"LAPB connect request failed, error code = %i\\n\",\n\t\t\t\t\t   result);\n\t\t}\n\t\tbreak;\n\n\tcase X25_IFACE_DISCONNECT:\n\t\tresult = lapb_disconnect_request(dev);\n\t\tif (result != LAPB_OK) {\n\t\t\tif (result == LAPB_NOTCONNECTED)\n\t\t\t\t \n\t\t\t\tx25_disconnected(dev, 0);\n\t\t\telse\n\t\t\t\tnetdev_err(dev, \"LAPB disconnect request failed, error code = %i\\n\",\n\t\t\t\t\t   result);\n\t\t}\n\t\tbreak;\n\n\tdefault:\t\t \n\t\tbreak;\n\t}\n\n\tspin_unlock_bh(&x25st->up_lock);\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic int x25_open(struct net_device *dev)\n{\n\tstatic const struct lapb_register_struct cb = {\n\t\t.connect_confirmation = x25_connected,\n\t\t.connect_indication = x25_connected,\n\t\t.disconnect_confirmation = x25_disconnected,\n\t\t.disconnect_indication = x25_disconnected,\n\t\t.data_indication = x25_data_indication,\n\t\t.data_transmit = x25_data_transmit,\n\t};\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tstruct x25_state *x25st = state(hdlc);\n\tstruct lapb_parms_struct params;\n\tint result;\n\n\tresult = lapb_register(dev, &cb);\n\tif (result != LAPB_OK)\n\t\treturn -ENOMEM;\n\n\tresult = lapb_getparms(dev, &params);\n\tif (result != LAPB_OK)\n\t\treturn -EINVAL;\n\n\tif (state(hdlc)->settings.dce)\n\t\tparams.mode = params.mode | LAPB_DCE;\n\n\tif (state(hdlc)->settings.modulo == 128)\n\t\tparams.mode = params.mode | LAPB_EXTENDED;\n\n\tparams.window = state(hdlc)->settings.window;\n\tparams.t1 = state(hdlc)->settings.t1;\n\tparams.t2 = state(hdlc)->settings.t2;\n\tparams.n2 = state(hdlc)->settings.n2;\n\n\tresult = lapb_setparms(dev, &params);\n\tif (result != LAPB_OK)\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&x25st->up_lock);\n\tx25st->up = true;\n\tspin_unlock_bh(&x25st->up_lock);\n\n\treturn 0;\n}\n\nstatic void x25_close(struct net_device *dev)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tstruct x25_state *x25st = state(hdlc);\n\n\tspin_lock_bh(&x25st->up_lock);\n\tx25st->up = false;\n\tspin_unlock_bh(&x25st->up_lock);\n\n\tlapb_unregister(dev);\n\ttasklet_kill(&x25st->rx_tasklet);\n}\n\nstatic int x25_rx(struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev;\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tstruct x25_state *x25st = state(hdlc);\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev->stats.rx_dropped++;\n\t\treturn NET_RX_DROP;\n\t}\n\n\tspin_lock_bh(&x25st->up_lock);\n\tif (!x25st->up) {\n\t\tspin_unlock_bh(&x25st->up_lock);\n\t\tkfree_skb(skb);\n\t\tdev->stats.rx_dropped++;\n\t\treturn NET_RX_DROP;\n\t}\n\n\tif (lapb_data_received(dev, skb) == LAPB_OK) {\n\t\tspin_unlock_bh(&x25st->up_lock);\n\t\treturn NET_RX_SUCCESS;\n\t}\n\n\tspin_unlock_bh(&x25st->up_lock);\n\tdev->stats.rx_errors++;\n\tdev_kfree_skb_any(skb);\n\treturn NET_RX_DROP;\n}\n\nstatic struct hdlc_proto proto = {\n\t.open\t\t= x25_open,\n\t.close\t\t= x25_close,\n\t.ioctl\t\t= x25_ioctl,\n\t.netif_rx\t= x25_rx,\n\t.xmit\t\t= x25_xmit,\n\t.module\t\t= THIS_MODULE,\n};\n\nstatic int x25_ioctl(struct net_device *dev, struct if_settings *ifs)\n{\n\tx25_hdlc_proto __user *x25_s = ifs->ifs_ifsu.x25;\n\tconst size_t size = sizeof(x25_hdlc_proto);\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tx25_hdlc_proto new_settings;\n\tint result;\n\n\tswitch (ifs->type) {\n\tcase IF_GET_PROTO:\n\t\tif (dev_to_hdlc(dev)->proto != &proto)\n\t\t\treturn -EINVAL;\n\t\tifs->type = IF_PROTO_X25;\n\t\tif (ifs->size < size) {\n\t\t\tifs->size = size;  \n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tif (copy_to_user(x25_s, &state(hdlc)->settings, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase IF_PROTO_X25:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (dev->flags & IFF_UP)\n\t\t\treturn -EBUSY;\n\n\t\t \n\t\tif (ifs->size == 0) {\n\t\t\tnew_settings.dce = 0;\n\t\t\tnew_settings.modulo = 8;\n\t\t\tnew_settings.window = 7;\n\t\t\tnew_settings.t1 = 3;\n\t\t\tnew_settings.t2 = 1;\n\t\t\tnew_settings.n2 = 10;\n\t\t} else {\n\t\t\tif (copy_from_user(&new_settings, x25_s, size))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif ((new_settings.dce != 0 &&\n\t\t\t     new_settings.dce != 1) ||\n\t\t\t    (new_settings.modulo != 8 &&\n\t\t\t     new_settings.modulo != 128) ||\n\t\t\t    new_settings.window < 1 ||\n\t\t\t    (new_settings.modulo == 8 &&\n\t\t\t     new_settings.window > 7) ||\n\t\t\t    (new_settings.modulo == 128 &&\n\t\t\t     new_settings.window > 127) ||\n\t\t\t    new_settings.t1 < 1 ||\n\t\t\t    new_settings.t1 > 255 ||\n\t\t\t    new_settings.t2 < 1 ||\n\t\t\t    new_settings.t2 > 255 ||\n\t\t\t    new_settings.n2 < 1 ||\n\t\t\t    new_settings.n2 > 255)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tresult = hdlc->attach(dev, ENCODING_NRZ,\n\t\t\t\t      PARITY_CRC16_PR1_CCITT);\n\t\tif (result)\n\t\t\treturn result;\n\n\t\tresult = attach_hdlc_protocol(dev, &proto,\n\t\t\t\t\t      sizeof(struct x25_state));\n\t\tif (result)\n\t\t\treturn result;\n\n\t\tmemcpy(&state(hdlc)->settings, &new_settings, size);\n\t\tstate(hdlc)->up = false;\n\t\tspin_lock_init(&state(hdlc)->up_lock);\n\t\tskb_queue_head_init(&state(hdlc)->rx_queue);\n\t\ttasklet_setup(&state(hdlc)->rx_tasklet, x25_rx_queue_kick);\n\n\t\t \n\t\tdev->hard_header_len = 0;\n\t\t \n\t\tdev->needed_headroom = 3 - 1;\n\n\t\tdev->type = ARPHRD_X25;\n\t\tcall_netdevice_notifiers(NETDEV_POST_TYPE_CHANGE, dev);\n\t\tnetif_dormant_off(dev);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int __init hdlc_x25_init(void)\n{\n\tregister_hdlc_protocol(&proto);\n\treturn 0;\n}\n\nstatic void __exit hdlc_x25_exit(void)\n{\n\tunregister_hdlc_protocol(&proto);\n}\n\nmodule_init(hdlc_x25_init);\nmodule_exit(hdlc_x25_exit);\n\nMODULE_AUTHOR(\"Krzysztof Halasa <khc@pm.waw.pl>\");\nMODULE_DESCRIPTION(\"X.25 protocol support for generic HDLC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}