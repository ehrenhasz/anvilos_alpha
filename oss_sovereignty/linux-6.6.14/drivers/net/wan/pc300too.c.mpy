{
  "module_name": "pc300too.c",
  "hash_id": "e6d0423b7d653f6e7bfe493fe2a3bdbf7bd21e5f5f443c27ec4a0377b453db37",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wan/pc300too.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/moduleparam.h>\n#include <linux/netdevice.h>\n#include <linux/hdlc.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <asm/io.h>\n\n#include \"hd64572.h\"\n\n#undef DEBUG_PKT\n#define DEBUG_RINGS\n\n#define PC300_PLX_SIZE\t\t0x80     \n#define PC300_SCA_SIZE\t\t0x400    \n#define MAX_TX_BUFFERS\t\t10\n\nstatic int pci_clock_freq = 33000000;\nstatic int use_crystal_clock;\nstatic unsigned int CLOCK_BASE;\n\n \n#define PC300_CLKSEL_MASK\t (0x00000004UL)\n#define PC300_CHMEDIA_MASK(port) (0x00000020UL << ((port) * 3))\n#define PC300_CTYPE_MASK\t (0x00000800UL)\n\nenum { PC300_RSV = 1, PC300_X21, PC300_TE };  \n\n \ntypedef struct {\n\tu32 loc_addr_range[4];\t \n\tu32 loc_rom_range;\t \n\tu32 loc_addr_base[4];\t \n\tu32 loc_rom_base;\t \n\tu32 loc_bus_descr[4];\t \n\tu32 rom_bus_descr;\t \n\tu32 cs_base[4];\t\t \n\tu32 intr_ctrl_stat;\t \n\tu32 init_ctrl;\t\t \n} plx9050;\n\ntypedef struct port_s {\n\tstruct napi_struct napi;\n\tstruct net_device *netdev;\n\tstruct card_s *card;\n\tspinlock_t lock;\t \n\tsync_serial_settings settings;\n\tint rxpart;\t\t \n\tunsigned short encoding;\n\tunsigned short parity;\n\tunsigned int iface;\n\tu16 rxin;\t\t \n\tu16 txin;\t\t \n\tu16 txlast;\n\tu8 rxs, txs, tmc;\t \n\tu8 chan;\t\t \n} port_t;\n\ntypedef struct card_s {\n\tint type;\t\t \n\tint n_ports;\t\t \n\tu8 __iomem *rambase;\t \n\tu8 __iomem *scabase;\t \n\tplx9050 __iomem *plxbase;  \n\tu32 init_ctrl_value;\t \n\tu16 rx_ring_buffers;\t \n\tu16 tx_ring_buffers;\n\tu16 buff_offset;\t \n\tu8 irq;\t\t\t \n\n\tport_t ports[2];\n} card_t;\n\n#define get_port(card, port)\t     ((port) < (card)->n_ports ? \\\n\t\t\t\t\t (&(card)->ports[port]) : (NULL))\n\n#include \"hd64572.c\"\n\nstatic void pc300_set_iface(port_t *port)\n{\n\tcard_t *card = port->card;\n\tu32 __iomem *init_ctrl = &card->plxbase->init_ctrl;\n\tu16 msci = get_msci(port);\n\tu8 rxs = port->rxs & CLK_BRG_MASK;\n\tu8 txs = port->txs & CLK_BRG_MASK;\n\n\tsca_out(EXS_TES1, (port->chan ? MSCI1_OFFSET : MSCI0_OFFSET) + EXS,\n\t\tport->card);\n\tswitch (port->settings.clock_type) {\n\tcase CLOCK_INT:\n\t\trxs |= CLK_BRG;  \n\t\ttxs |= CLK_PIN_OUT | CLK_TX_RXCLK;  \n\t\tbreak;\n\n\tcase CLOCK_TXINT:\n\t\trxs |= CLK_LINE;  \n\t\ttxs |= CLK_PIN_OUT | CLK_BRG;  \n\t\tbreak;\n\n\tcase CLOCK_TXFROMRX:\n\t\trxs |= CLK_LINE;  \n\t\ttxs |= CLK_PIN_OUT | CLK_TX_RXCLK;  \n\t\tbreak;\n\n\tdefault:\t\t \n\t\trxs |= CLK_LINE;  \n\t\ttxs |= CLK_PIN_OUT | CLK_LINE;  \n\t\tbreak;\n\t}\n\n\tport->rxs = rxs;\n\tport->txs = txs;\n\tsca_out(rxs, msci + RXS, card);\n\tsca_out(txs, msci + TXS, card);\n\tsca_set_port(port);\n\n\tif (port->card->type == PC300_RSV) {\n\t\tif (port->iface == IF_IFACE_V35)\n\t\t\twritel(card->init_ctrl_value |\n\t\t\t       PC300_CHMEDIA_MASK(port->chan), init_ctrl);\n\t\telse\n\t\t\twritel(card->init_ctrl_value &\n\t\t\t       ~PC300_CHMEDIA_MASK(port->chan), init_ctrl);\n\t}\n}\n\nstatic int pc300_open(struct net_device *dev)\n{\n\tport_t *port = dev_to_port(dev);\n\tint result = hdlc_open(dev);\n\n\tif (result)\n\t\treturn result;\n\n\tsca_open(dev);\n\tpc300_set_iface(port);\n\treturn 0;\n}\n\nstatic int pc300_close(struct net_device *dev)\n{\n\tsca_close(dev);\n\thdlc_close(dev);\n\treturn 0;\n}\n\nstatic int pc300_siocdevprivate(struct net_device *dev, struct ifreq *ifr,\n\t\t\t\tvoid __user *data, int cmd)\n{\n#ifdef DEBUG_RINGS\n\tif (cmd == SIOCDEVPRIVATE) {\n\t\tsca_dump_rings(dev);\n\t\treturn 0;\n\t}\n#endif\n\treturn -EOPNOTSUPP;\n}\n\nstatic int pc300_ioctl(struct net_device *dev, struct if_settings *ifs)\n{\n\tconst size_t size = sizeof(sync_serial_settings);\n\tsync_serial_settings new_line;\n\tsync_serial_settings __user *line = ifs->ifs_ifsu.sync;\n\tint new_type;\n\tport_t *port = dev_to_port(dev);\n\n\tif (ifs->type == IF_GET_IFACE) {\n\t\tifs->type = port->iface;\n\t\tif (ifs->size < size) {\n\t\t\tifs->size = size;  \n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tif (copy_to_user(line, &port->settings, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tif (port->card->type == PC300_X21 &&\n\t    (ifs->type == IF_IFACE_SYNC_SERIAL ||\n\t     ifs->type == IF_IFACE_X21))\n\t\tnew_type = IF_IFACE_X21;\n\n\telse if (port->card->type == PC300_RSV &&\n\t\t (ifs->type == IF_IFACE_SYNC_SERIAL ||\n\t\t  ifs->type == IF_IFACE_V35))\n\t\tnew_type = IF_IFACE_V35;\n\n\telse if (port->card->type == PC300_RSV &&\n\t\t ifs->type == IF_IFACE_V24)\n\t\tnew_type = IF_IFACE_V24;\n\n\telse\n\t\treturn hdlc_ioctl(dev, ifs);\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (copy_from_user(&new_line, line, size))\n\t\treturn -EFAULT;\n\n\tif (new_line.clock_type != CLOCK_EXT &&\n\t    new_line.clock_type != CLOCK_TXFROMRX &&\n\t    new_line.clock_type != CLOCK_INT &&\n\t    new_line.clock_type != CLOCK_TXINT)\n\t\treturn -EINVAL;\t \n\n\tif (new_line.loopback != 0 && new_line.loopback != 1)\n\t\treturn -EINVAL;\n\n\tmemcpy(&port->settings, &new_line, size);  \n\tport->iface = new_type;\n\tpc300_set_iface(port);\n\treturn 0;\n}\n\nstatic void pc300_pci_remove_one(struct pci_dev *pdev)\n{\n\tint i;\n\tcard_t *card = pci_get_drvdata(pdev);\n\n\tfor (i = 0; i < 2; i++)\n\t\tif (card->ports[i].card)\n\t\t\tunregister_hdlc_device(card->ports[i].netdev);\n\n\tif (card->irq)\n\t\tfree_irq(card->irq, card);\n\n\tif (card->rambase)\n\t\tiounmap(card->rambase);\n\tif (card->scabase)\n\t\tiounmap(card->scabase);\n\tif (card->plxbase)\n\t\tiounmap(card->plxbase);\n\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tif (card->ports[0].netdev)\n\t\tfree_netdev(card->ports[0].netdev);\n\tif (card->ports[1].netdev)\n\t\tfree_netdev(card->ports[1].netdev);\n\tkfree(card);\n}\n\nstatic const struct net_device_ops pc300_ops = {\n\t.ndo_open       = pc300_open,\n\t.ndo_stop       = pc300_close,\n\t.ndo_start_xmit = hdlc_start_xmit,\n\t.ndo_siocwandev = pc300_ioctl,\n\t.ndo_siocdevprivate = pc300_siocdevprivate,\n};\n\nstatic int pc300_pci_init_one(struct pci_dev *pdev,\n\t\t\t      const struct pci_device_id *ent)\n{\n\tcard_t *card;\n\tu32 __iomem *p;\n\tint i;\n\tu32 ramsize;\n\tu32 ramphys;\t\t \n\tu32 scaphys;\t\t \n\tu32 plxphys;\t\t \n\n\ti = pci_enable_device(pdev);\n\tif (i)\n\t\treturn i;\n\n\ti = pci_request_regions(pdev, \"PC300\");\n\tif (i) {\n\t\tpci_disable_device(pdev);\n\t\treturn i;\n\t}\n\n\tcard = kzalloc(sizeof(card_t), GFP_KERNEL);\n\tif (!card) {\n\t\tpci_release_regions(pdev);\n\t\tpci_disable_device(pdev);\n\t\treturn -ENOBUFS;\n\t}\n\tpci_set_drvdata(pdev, card);\n\n\tif (pci_resource_len(pdev, 0) != PC300_PLX_SIZE ||\n\t    pci_resource_len(pdev, 2) != PC300_SCA_SIZE ||\n\t    pci_resource_len(pdev, 3) < 16384) {\n\t\tpr_err(\"invalid card EEPROM parameters\\n\");\n\t\tpc300_pci_remove_one(pdev);\n\t\treturn -EFAULT;\n\t}\n\n\tplxphys = pci_resource_start(pdev, 0) & PCI_BASE_ADDRESS_MEM_MASK;\n\tcard->plxbase = ioremap(plxphys, PC300_PLX_SIZE);\n\n\tscaphys = pci_resource_start(pdev, 2) & PCI_BASE_ADDRESS_MEM_MASK;\n\tcard->scabase = ioremap(scaphys, PC300_SCA_SIZE);\n\n\tramphys = pci_resource_start(pdev, 3) & PCI_BASE_ADDRESS_MEM_MASK;\n\tcard->rambase = pci_ioremap_bar(pdev, 3);\n\n\tif (!card->plxbase || !card->scabase || !card->rambase) {\n\t\tpr_err(\"ioremap() failed\\n\");\n\t\tpc300_pci_remove_one(pdev);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tpci_write_config_dword(pdev, PCI_BASE_ADDRESS_0, scaphys);\n\tcard->init_ctrl_value = readl(&((plx9050 __iomem *)card->scabase)->init_ctrl);\n\tpci_write_config_dword(pdev, PCI_BASE_ADDRESS_0, plxphys);\n\n\tif (pdev->device == PCI_DEVICE_ID_PC300_TE_1 ||\n\t    pdev->device == PCI_DEVICE_ID_PC300_TE_2)\n\t\tcard->type = PC300_TE;  \n\telse if (card->init_ctrl_value & PC300_CTYPE_MASK)\n\t\tcard->type = PC300_X21;\n\telse\n\t\tcard->type = PC300_RSV;\n\n\tif (pdev->device == PCI_DEVICE_ID_PC300_RX_1 ||\n\t    pdev->device == PCI_DEVICE_ID_PC300_TE_1)\n\t\tcard->n_ports = 1;\n\telse\n\t\tcard->n_ports = 2;\n\n\tfor (i = 0; i < card->n_ports; i++) {\n\t\tcard->ports[i].netdev = alloc_hdlcdev(&card->ports[i]);\n\t\tif (!card->ports[i].netdev) {\n\t\t\tpr_err(\"unable to allocate memory\\n\");\n\t\t\tpc300_pci_remove_one(pdev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\t \n\tp = &card->plxbase->init_ctrl;\n\twritel(card->init_ctrl_value | 0x40000000, p);\n\treadl(p);\t\t \n\tudelay(1);\n\n\twritel(card->init_ctrl_value, p);\n\treadl(p);\t\t \n\tudelay(1);\n\n\t \n\twritel(card->init_ctrl_value | 0x20000000, p);\n\treadl(p);\t\t \n\tudelay(1);\n\n\twritel(card->init_ctrl_value, p);\n\treadl(p);\t\t \n\tudelay(1);\n\n\tramsize = sca_detect_ram(card, card->rambase,\n\t\t\t\t pci_resource_len(pdev, 3));\n\n\tif (use_crystal_clock)\n\t\tcard->init_ctrl_value &= ~PC300_CLKSEL_MASK;\n\telse\n\t\tcard->init_ctrl_value |= PC300_CLKSEL_MASK;\n\n\twritel(card->init_ctrl_value, &card->plxbase->init_ctrl);\n\t \n\ti = ramsize / (card->n_ports * (sizeof(pkt_desc) + HDLC_MAX_MRU));\n\tcard->tx_ring_buffers = min(i / 2, MAX_TX_BUFFERS);\n\tcard->rx_ring_buffers = i - card->tx_ring_buffers;\n\n\tcard->buff_offset = card->n_ports * sizeof(pkt_desc) *\n\t\t(card->tx_ring_buffers + card->rx_ring_buffers);\n\n\tpr_info(\"PC300/%s, %u KB RAM at 0x%x, IRQ%u, using %u TX + %u RX packets rings\\n\",\n\t\tcard->type == PC300_X21 ? \"X21\" :\n\t\tcard->type == PC300_TE ? \"TE\" : \"RSV\",\n\t\tramsize / 1024, ramphys, pdev->irq,\n\t\tcard->tx_ring_buffers, card->rx_ring_buffers);\n\n\tif (card->tx_ring_buffers < 1) {\n\t\tpr_err(\"RAM test failed\\n\");\n\t\tpc300_pci_remove_one(pdev);\n\t\treturn -EFAULT;\n\t}\n\n\t \n\twritew(0x0041, &card->plxbase->intr_ctrl_stat);\n\n\t \n\tif (request_irq(pdev->irq, sca_intr, IRQF_SHARED, \"pc300\", card)) {\n\t\tpr_warn(\"could not allocate IRQ%d\\n\", pdev->irq);\n\t\tpc300_pci_remove_one(pdev);\n\t\treturn -EBUSY;\n\t}\n\tcard->irq = pdev->irq;\n\n\tsca_init(card, 0);\n\n\t\n\t\n\n\tsca_out(0x10, BTCR, card);\n\n\tfor (i = 0; i < card->n_ports; i++) {\n\t\tport_t *port = &card->ports[i];\n\t\tstruct net_device *dev = port->netdev;\n\t\thdlc_device *hdlc = dev_to_hdlc(dev);\n\n\t\tport->chan = i;\n\n\t\tspin_lock_init(&port->lock);\n\t\tdev->irq = card->irq;\n\t\tdev->mem_start = ramphys;\n\t\tdev->mem_end = ramphys + ramsize - 1;\n\t\tdev->tx_queue_len = 50;\n\t\tdev->netdev_ops = &pc300_ops;\n\t\thdlc->attach = sca_attach;\n\t\thdlc->xmit = sca_xmit;\n\t\tport->settings.clock_type = CLOCK_EXT;\n\t\tport->card = card;\n\t\tif (card->type == PC300_X21)\n\t\t\tport->iface = IF_IFACE_X21;\n\t\telse\n\t\t\tport->iface = IF_IFACE_V35;\n\n\t\tsca_init_port(port);\n\t\tif (register_hdlc_device(dev)) {\n\t\t\tpr_err(\"unable to register hdlc device\\n\");\n\t\t\tport->card = NULL;\n\t\t\tpc300_pci_remove_one(pdev);\n\t\t\treturn -ENOBUFS;\n\t\t}\n\n\t\tnetdev_info(dev, \"PC300 channel %d\\n\", port->chan);\n\t}\n\treturn 0;\n}\n\nstatic const struct pci_device_id pc300_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_PC300_RX_1, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_PC300_RX_2, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_PC300_TE_1, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, 0, 0 },\n\t{ PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_PC300_TE_2, PCI_ANY_ID,\n\t  PCI_ANY_ID, 0, 0, 0 },\n\t{ 0, }\n};\n\nstatic struct pci_driver pc300_pci_driver = {\n\t.name =          \"PC300\",\n\t.id_table =      pc300_pci_tbl,\n\t.probe =         pc300_pci_init_one,\n\t.remove =        pc300_pci_remove_one,\n};\n\nstatic int __init pc300_init_module(void)\n{\n\tif (pci_clock_freq < 1000000 || pci_clock_freq > 80000000) {\n\t\tpr_err(\"Invalid PCI clock frequency\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (use_crystal_clock != 0 && use_crystal_clock != 1) {\n\t\tpr_err(\"Invalid 'use_crystal_clock' value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tCLOCK_BASE = use_crystal_clock ? 24576000 : pci_clock_freq;\n\n\treturn pci_register_driver(&pc300_pci_driver);\n}\n\nstatic void __exit pc300_cleanup_module(void)\n{\n\tpci_unregister_driver(&pc300_pci_driver);\n}\n\nMODULE_AUTHOR(\"Krzysztof Halasa <khc@pm.waw.pl>\");\nMODULE_DESCRIPTION(\"Cyclades PC300 serial port driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DEVICE_TABLE(pci, pc300_pci_tbl);\nmodule_param(pci_clock_freq, int, 0444);\nMODULE_PARM_DESC(pci_clock_freq, \"System PCI clock frequency in Hz\");\nmodule_param(use_crystal_clock, int, 0444);\nMODULE_PARM_DESC(use_crystal_clock,\n\t\t \"Use 24.576 MHz clock instead of PCI clock\");\nmodule_init(pc300_init_module);\nmodule_exit(pc300_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}