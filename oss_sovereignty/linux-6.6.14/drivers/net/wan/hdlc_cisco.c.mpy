{
  "module_name": "hdlc_cisco.c",
  "hash_id": "61db3e94b43efb0ca99c46634097f9d2ce378ce9b9c406d68b35ea1d51d7a0f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wan/hdlc_cisco.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/hdlc.h>\n#include <linux/if_arp.h>\n#include <linux/inetdevice.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pkt_sched.h>\n#include <linux/poll.h>\n#include <linux/rtnetlink.h>\n#include <linux/skbuff.h>\n\n#undef DEBUG_HARD_HEADER\n\n#define CISCO_MULTICAST\t\t0x8F\t \n#define CISCO_UNICAST\t\t0x0F\t \n#define CISCO_KEEPALIVE\t\t0x8035\t \n#define CISCO_SYS_INFO\t\t0x2000\t \n#define CISCO_ADDR_REQ\t\t0\t \n#define CISCO_ADDR_REPLY\t1\t \n#define CISCO_KEEPALIVE_REQ\t2\t \n\nstruct hdlc_header {\n\tu8 address;\n\tu8 control;\n\t__be16 protocol;\n} __packed;\n\nstruct cisco_packet {\n\t__be32 type;\t\t \n\t__be32 par1;\n\t__be32 par2;\n\t__be16 rel;\t\t \n\t__be32 time;\n} __packed;\n#define\tCISCO_PACKET_LEN\t18\n#define\tCISCO_BIG_PACKET_LEN\t20\n\nstruct cisco_state {\n\tcisco_proto settings;\n\n\tstruct timer_list timer;\n\tstruct net_device *dev;\n\tspinlock_t lock;\n\tunsigned long last_poll;\n\tint up;\n\tu32 txseq;  \n\tu32 rxseq;  \n};\n\nstatic int cisco_ioctl(struct net_device *dev, struct if_settings *ifs);\n\nstatic inline struct cisco_state *state(hdlc_device *hdlc)\n{\n\treturn (struct cisco_state *)hdlc->state;\n}\n\nstatic int cisco_hard_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\t     u16 type, const void *daddr, const void *saddr,\n\t\t\t     unsigned int len)\n{\n\tstruct hdlc_header *data;\n#ifdef DEBUG_HARD_HEADER\n\tnetdev_dbg(dev, \"%s called\\n\", __func__);\n#endif\n\n\tskb_push(skb, sizeof(struct hdlc_header));\n\tdata = (struct hdlc_header *)skb->data;\n\tif (type == CISCO_KEEPALIVE)\n\t\tdata->address = CISCO_MULTICAST;\n\telse\n\t\tdata->address = CISCO_UNICAST;\n\tdata->control = 0;\n\tdata->protocol = htons(type);\n\n\treturn sizeof(struct hdlc_header);\n}\n\nstatic void cisco_keepalive_send(struct net_device *dev, u32 type,\n\t\t\t\t __be32 par1, __be32 par2)\n{\n\tstruct sk_buff *skb;\n\tstruct cisco_packet *data;\n\n\tskb = dev_alloc_skb(sizeof(struct hdlc_header) +\n\t\t\t    sizeof(struct cisco_packet));\n\tif (!skb)\n\t\treturn;\n\n\tskb_reserve(skb, 4);\n\tcisco_hard_header(skb, dev, CISCO_KEEPALIVE, NULL, NULL, 0);\n\tdata = (struct cisco_packet *)(skb->data + 4);\n\n\tdata->type = htonl(type);\n\tdata->par1 = par1;\n\tdata->par2 = par2;\n\tdata->rel = cpu_to_be16(0xFFFF);\n\t \n\tdata->time = htonl((jiffies - INITIAL_JIFFIES) * (1000 / HZ));\n\n\tskb_put(skb, sizeof(struct cisco_packet));\n\tskb->priority = TC_PRIO_CONTROL;\n\tskb->dev = dev;\n\tskb->protocol = htons(ETH_P_HDLC);\n\tskb_reset_network_header(skb);\n\n\tdev_queue_xmit(skb);\n}\n\nstatic __be16 cisco_type_trans(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct hdlc_header *data = (struct hdlc_header *)skb->data;\n\n\tif (skb->len < sizeof(struct hdlc_header))\n\t\treturn cpu_to_be16(ETH_P_HDLC);\n\n\tif (data->address != CISCO_MULTICAST &&\n\t    data->address != CISCO_UNICAST)\n\t\treturn cpu_to_be16(ETH_P_HDLC);\n\n\tswitch (data->protocol) {\n\tcase cpu_to_be16(ETH_P_IP):\n\tcase cpu_to_be16(ETH_P_IPX):\n\tcase cpu_to_be16(ETH_P_IPV6):\n\t\tskb_pull(skb, sizeof(struct hdlc_header));\n\t\treturn data->protocol;\n\tdefault:\n\t\treturn cpu_to_be16(ETH_P_HDLC);\n\t}\n}\n\nstatic int cisco_rx(struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev;\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tstruct cisco_state *st = state(hdlc);\n\tstruct hdlc_header *data = (struct hdlc_header *)skb->data;\n\tstruct cisco_packet *cisco_data;\n\tstruct in_device *in_dev;\n\t__be32 addr, mask;\n\tu32 ack;\n\n\tif (skb->len < sizeof(struct hdlc_header))\n\t\tgoto rx_error;\n\n\tif (data->address != CISCO_MULTICAST &&\n\t    data->address != CISCO_UNICAST)\n\t\tgoto rx_error;\n\n\tswitch (ntohs(data->protocol)) {\n\tcase CISCO_SYS_INFO:\n\t\t \n\t\tdev_kfree_skb_any(skb);\n\t\treturn NET_RX_SUCCESS;\n\n\tcase CISCO_KEEPALIVE:\n\t\tif ((skb->len != sizeof(struct hdlc_header) +\n\t\t     CISCO_PACKET_LEN) &&\n\t\t    (skb->len != sizeof(struct hdlc_header) +\n\t\t     CISCO_BIG_PACKET_LEN)) {\n\t\t\tnetdev_info(dev, \"Invalid length of Cisco control packet (%d bytes)\\n\",\n\t\t\t\t    skb->len);\n\t\t\tgoto rx_error;\n\t\t}\n\n\t\tcisco_data = (struct cisco_packet *)(skb->data + sizeof\n\t\t\t\t\t\t    (struct hdlc_header));\n\n\t\tswitch (ntohl(cisco_data->type)) {\n\t\tcase CISCO_ADDR_REQ:  \n\t\t\trcu_read_lock();\n\t\t\tin_dev = __in_dev_get_rcu(dev);\n\t\t\taddr = 0;\n\t\t\tmask = ~cpu_to_be32(0);  \n\n\t\t\tif (in_dev != NULL) {\n\t\t\t\tconst struct in_ifaddr *ifa;\n\n\t\t\t\tin_dev_for_each_ifa_rcu(ifa, in_dev) {\n\t\t\t\t\tif (strcmp(dev->name,\n\t\t\t\t\t\t   ifa->ifa_label) == 0) {\n\t\t\t\t\t\taddr = ifa->ifa_local;\n\t\t\t\t\t\tmask = ifa->ifa_mask;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcisco_keepalive_send(dev, CISCO_ADDR_REPLY,\n\t\t\t\t\t\t     addr, mask);\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn NET_RX_SUCCESS;\n\n\t\tcase CISCO_ADDR_REPLY:\n\t\t\tnetdev_info(dev, \"Unexpected Cisco IP address reply\\n\");\n\t\t\tgoto rx_error;\n\n\t\tcase CISCO_KEEPALIVE_REQ:\n\t\t\tspin_lock(&st->lock);\n\t\t\tst->rxseq = ntohl(cisco_data->par1);\n\t\t\tack = ntohl(cisco_data->par2);\n\t\t\tif (ack && (ack == st->txseq ||\n\t\t\t\t     \n\t\t\t\t    ack == st->txseq - 1)) {\n\t\t\t\tst->last_poll = jiffies;\n\t\t\t\tif (!st->up) {\n\t\t\t\t\tu32 sec, min, hrs, days;\n\n\t\t\t\t\tsec = ntohl(cisco_data->time) / 1000;\n\t\t\t\t\tmin = sec / 60; sec -= min * 60;\n\t\t\t\t\thrs = min / 60; min -= hrs * 60;\n\t\t\t\t\tdays = hrs / 24; hrs -= days * 24;\n\t\t\t\t\tnetdev_info(dev, \"Link up (peer uptime %ud%uh%um%us)\\n\",\n\t\t\t\t\t\t    days, hrs, min, sec);\n\t\t\t\t\tnetif_dormant_off(dev);\n\t\t\t\t\tst->up = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock(&st->lock);\n\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn NET_RX_SUCCESS;\n\t\t}  \n\t}  \n\n\tnetdev_info(dev, \"Unsupported protocol %x\\n\", ntohs(data->protocol));\n\tdev_kfree_skb_any(skb);\n\treturn NET_RX_DROP;\n\nrx_error:\n\tdev->stats.rx_errors++;  \n\tdev_kfree_skb_any(skb);\n\treturn NET_RX_DROP;\n}\n\nstatic void cisco_timer(struct timer_list *t)\n{\n\tstruct cisco_state *st = from_timer(st, t, timer);\n\tstruct net_device *dev = st->dev;\n\n\tspin_lock(&st->lock);\n\tif (st->up &&\n\t    time_after(jiffies, st->last_poll + st->settings.timeout * HZ)) {\n\t\tst->up = 0;\n\t\tnetdev_info(dev, \"Link down\\n\");\n\t\tnetif_dormant_on(dev);\n\t}\n\n\tcisco_keepalive_send(dev, CISCO_KEEPALIVE_REQ, htonl(++st->txseq),\n\t\t\t     htonl(st->rxseq));\n\tspin_unlock(&st->lock);\n\n\tst->timer.expires = jiffies + st->settings.interval * HZ;\n\tadd_timer(&st->timer);\n}\n\nstatic void cisco_start(struct net_device *dev)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tstruct cisco_state *st = state(hdlc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&st->lock, flags);\n\tst->up = st->txseq = st->rxseq = 0;\n\tspin_unlock_irqrestore(&st->lock, flags);\n\n\tst->dev = dev;\n\ttimer_setup(&st->timer, cisco_timer, 0);\n\tst->timer.expires = jiffies + HZ;  \n\tadd_timer(&st->timer);\n}\n\nstatic void cisco_stop(struct net_device *dev)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tstruct cisco_state *st = state(hdlc);\n\tunsigned long flags;\n\n\tdel_timer_sync(&st->timer);\n\n\tspin_lock_irqsave(&st->lock, flags);\n\tnetif_dormant_on(dev);\n\tst->up = st->txseq = 0;\n\tspin_unlock_irqrestore(&st->lock, flags);\n}\n\nstatic struct hdlc_proto proto = {\n\t.start\t\t= cisco_start,\n\t.stop\t\t= cisco_stop,\n\t.type_trans\t= cisco_type_trans,\n\t.ioctl\t\t= cisco_ioctl,\n\t.netif_rx\t= cisco_rx,\n\t.module\t\t= THIS_MODULE,\n};\n\nstatic const struct header_ops cisco_header_ops = {\n\t.create = cisco_hard_header,\n};\n\nstatic int cisco_ioctl(struct net_device *dev, struct if_settings *ifs)\n{\n\tcisco_proto __user *cisco_s = ifs->ifs_ifsu.cisco;\n\tconst size_t size = sizeof(cisco_proto);\n\tcisco_proto new_settings;\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tint result;\n\n\tswitch (ifs->type) {\n\tcase IF_GET_PROTO:\n\t\tif (dev_to_hdlc(dev)->proto != &proto)\n\t\t\treturn -EINVAL;\n\t\tifs->type = IF_PROTO_CISCO;\n\t\tif (ifs->size < size) {\n\t\t\tifs->size = size;  \n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tif (copy_to_user(cisco_s, &state(hdlc)->settings, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase IF_PROTO_CISCO:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (dev->flags & IFF_UP)\n\t\t\treturn -EBUSY;\n\n\t\tif (copy_from_user(&new_settings, cisco_s, size))\n\t\t\treturn -EFAULT;\n\n\t\tif (new_settings.interval < 1 ||\n\t\t    new_settings.timeout < 2)\n\t\t\treturn -EINVAL;\n\n\t\tresult = hdlc->attach(dev, ENCODING_NRZ,\n\t\t\t\t      PARITY_CRC16_PR1_CCITT);\n\t\tif (result)\n\t\t\treturn result;\n\n\t\tresult = attach_hdlc_protocol(dev, &proto,\n\t\t\t\t\t      sizeof(struct cisco_state));\n\t\tif (result)\n\t\t\treturn result;\n\n\t\tmemcpy(&state(hdlc)->settings, &new_settings, size);\n\t\tspin_lock_init(&state(hdlc)->lock);\n\t\tdev->header_ops = &cisco_header_ops;\n\t\tdev->hard_header_len = sizeof(struct hdlc_header);\n\t\tdev->type = ARPHRD_CISCO;\n\t\tcall_netdevice_notifiers(NETDEV_POST_TYPE_CHANGE, dev);\n\t\tnetif_dormant_on(dev);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int __init hdlc_cisco_init(void)\n{\n\tregister_hdlc_protocol(&proto);\n\treturn 0;\n}\n\nstatic void __exit hdlc_cisco_exit(void)\n{\n\tunregister_hdlc_protocol(&proto);\n}\n\nmodule_init(hdlc_cisco_init);\nmodule_exit(hdlc_cisco_exit);\n\nMODULE_AUTHOR(\"Krzysztof Halasa <khc@pm.waw.pl>\");\nMODULE_DESCRIPTION(\"Cisco HDLC protocol support for generic HDLC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}