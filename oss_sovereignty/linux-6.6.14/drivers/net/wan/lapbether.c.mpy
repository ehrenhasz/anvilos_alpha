{
  "module_name": "lapbether.c",
  "hash_id": "0fa749cd8baf518db35738e296c617ea6a117b1e2ee034b7bc1d4acb61a3d8d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wan/lapbether.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/socket.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/uaccess.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/lapb.h>\n#include <linux/init.h>\n\n#include <net/x25device.h>\n\nstatic const u8 bcast_addr[6] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };\n\n \n#define MAXLAPBDEV 100\n\nstruct lapbethdev {\n\tstruct list_head\tnode;\n\tstruct net_device\t*ethdev;\t \n\tstruct net_device\t*axdev;\t\t \n\tbool\t\t\tup;\n\tspinlock_t\t\tup_lock;\t \n\tstruct sk_buff_head\trx_queue;\n\tstruct napi_struct\tnapi;\n};\n\nstatic LIST_HEAD(lapbeth_devices);\n\nstatic void lapbeth_connected(struct net_device *dev, int reason);\nstatic void lapbeth_disconnected(struct net_device *dev, int reason);\n\n \n\n \nstatic struct lapbethdev *lapbeth_get_x25_dev(struct net_device *dev)\n{\n\tstruct lapbethdev *lapbeth;\n\n\tlist_for_each_entry_rcu(lapbeth, &lapbeth_devices, node, lockdep_rtnl_is_held()) {\n\t\tif (lapbeth->ethdev == dev)\n\t\t\treturn lapbeth;\n\t}\n\treturn NULL;\n}\n\nstatic __inline__ int dev_is_ethdev(struct net_device *dev)\n{\n\treturn dev->type == ARPHRD_ETHER && strncmp(dev->name, \"dummy\", 5);\n}\n\n \n\nstatic int lapbeth_napi_poll(struct napi_struct *napi, int budget)\n{\n\tstruct lapbethdev *lapbeth = container_of(napi, struct lapbethdev,\n\t\t\t\t\t\t  napi);\n\tstruct sk_buff *skb;\n\tint processed = 0;\n\n\tfor (; processed < budget; ++processed) {\n\t\tskb = skb_dequeue(&lapbeth->rx_queue);\n\t\tif (!skb)\n\t\t\tbreak;\n\t\tnetif_receive_skb_core(skb);\n\t}\n\n\tif (processed < budget)\n\t\tnapi_complete(napi);\n\n\treturn processed;\n}\n\n \nstatic int lapbeth_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t       struct packet_type *ptype, struct net_device *orig_dev)\n{\n\tint len, err;\n\tstruct lapbethdev *lapbeth;\n\n\tif (dev_net(dev) != &init_net)\n\t\tgoto drop;\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn NET_RX_DROP;\n\n\tif (!pskb_may_pull(skb, 2))\n\t\tgoto drop;\n\n\trcu_read_lock();\n\tlapbeth = lapbeth_get_x25_dev(dev);\n\tif (!lapbeth)\n\t\tgoto drop_unlock_rcu;\n\tspin_lock_bh(&lapbeth->up_lock);\n\tif (!lapbeth->up)\n\t\tgoto drop_unlock;\n\n\tlen = skb->data[0] + skb->data[1] * 256;\n\tdev->stats.rx_packets++;\n\tdev->stats.rx_bytes += len;\n\n\tskb_pull(skb, 2);\t \n\tskb_trim(skb, len);\t \n\n\terr = lapb_data_received(lapbeth->axdev, skb);\n\tif (err != LAPB_OK) {\n\t\tprintk(KERN_DEBUG \"lapbether: lapb_data_received err - %d\\n\", err);\n\t\tgoto drop_unlock;\n\t}\nout:\n\tspin_unlock_bh(&lapbeth->up_lock);\n\trcu_read_unlock();\n\treturn 0;\ndrop_unlock:\n\tkfree_skb(skb);\n\tgoto out;\ndrop_unlock_rcu:\n\trcu_read_unlock();\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int lapbeth_data_indication(struct net_device *dev, struct sk_buff *skb)\n{\n\tstruct lapbethdev *lapbeth = netdev_priv(dev);\n\tunsigned char *ptr;\n\n\tif (skb_cow(skb, 1)) {\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\tskb_push(skb, 1);\n\n\tptr  = skb->data;\n\t*ptr = X25_IFACE_DATA;\n\n\tskb->protocol = x25_type_trans(skb, dev);\n\n\tskb_queue_tail(&lapbeth->rx_queue, skb);\n\tnapi_schedule(&lapbeth->napi);\n\treturn NET_RX_SUCCESS;\n}\n\n \nstatic netdev_tx_t lapbeth_xmit(struct sk_buff *skb,\n\t\t\t\tstruct net_device *dev)\n{\n\tstruct lapbethdev *lapbeth = netdev_priv(dev);\n\tint err;\n\n\tspin_lock_bh(&lapbeth->up_lock);\n\tif (!lapbeth->up)\n\t\tgoto drop;\n\n\t \n\tif (skb->len < 1)\n\t\tgoto drop;\n\n\tswitch (skb->data[0]) {\n\tcase X25_IFACE_DATA:\n\t\tbreak;\n\tcase X25_IFACE_CONNECT:\n\t\terr = lapb_connect_request(dev);\n\t\tif (err == LAPB_CONNECTED)\n\t\t\tlapbeth_connected(dev, LAPB_OK);\n\t\telse if (err != LAPB_OK)\n\t\t\tpr_err(\"lapb_connect_request error: %d\\n\", err);\n\t\tgoto drop;\n\tcase X25_IFACE_DISCONNECT:\n\t\terr = lapb_disconnect_request(dev);\n\t\tif (err == LAPB_NOTCONNECTED)\n\t\t\tlapbeth_disconnected(dev, LAPB_OK);\n\t\telse if (err != LAPB_OK)\n\t\t\tpr_err(\"lapb_disconnect_request err: %d\\n\", err);\n\t\tfallthrough;\n\tdefault:\n\t\tgoto drop;\n\t}\n\n\tskb_pull(skb, 1);\n\n\terr = lapb_data_request(dev, skb);\n\tif (err != LAPB_OK) {\n\t\tpr_err(\"lapb_data_request error - %d\\n\", err);\n\t\tgoto drop;\n\t}\nout:\n\tspin_unlock_bh(&lapbeth->up_lock);\n\treturn NETDEV_TX_OK;\ndrop:\n\tkfree_skb(skb);\n\tgoto out;\n}\n\nstatic void lapbeth_data_transmit(struct net_device *ndev, struct sk_buff *skb)\n{\n\tstruct lapbethdev *lapbeth = netdev_priv(ndev);\n\tunsigned char *ptr;\n\tstruct net_device *dev;\n\tint size = skb->len;\n\n\tptr = skb_push(skb, 2);\n\n\t*ptr++ = size % 256;\n\t*ptr++ = size / 256;\n\n\tndev->stats.tx_packets++;\n\tndev->stats.tx_bytes += size;\n\n\tskb->dev = dev = lapbeth->ethdev;\n\n\tskb->protocol = htons(ETH_P_DEC);\n\n\tskb_reset_network_header(skb);\n\n\tdev_hard_header(skb, dev, ETH_P_DEC, bcast_addr, NULL, 0);\n\n\tdev_queue_xmit(skb);\n}\n\nstatic void lapbeth_connected(struct net_device *dev, int reason)\n{\n\tstruct lapbethdev *lapbeth = netdev_priv(dev);\n\tunsigned char *ptr;\n\tstruct sk_buff *skb = __dev_alloc_skb(1, GFP_ATOMIC | __GFP_NOMEMALLOC);\n\n\tif (!skb)\n\t\treturn;\n\n\tptr  = skb_put(skb, 1);\n\t*ptr = X25_IFACE_CONNECT;\n\n\tskb->protocol = x25_type_trans(skb, dev);\n\n\tskb_queue_tail(&lapbeth->rx_queue, skb);\n\tnapi_schedule(&lapbeth->napi);\n}\n\nstatic void lapbeth_disconnected(struct net_device *dev, int reason)\n{\n\tstruct lapbethdev *lapbeth = netdev_priv(dev);\n\tunsigned char *ptr;\n\tstruct sk_buff *skb = __dev_alloc_skb(1, GFP_ATOMIC | __GFP_NOMEMALLOC);\n\n\tif (!skb)\n\t\treturn;\n\n\tptr  = skb_put(skb, 1);\n\t*ptr = X25_IFACE_DISCONNECT;\n\n\tskb->protocol = x25_type_trans(skb, dev);\n\n\tskb_queue_tail(&lapbeth->rx_queue, skb);\n\tnapi_schedule(&lapbeth->napi);\n}\n\n \nstatic int lapbeth_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct sockaddr *sa = addr;\n\n\tdev_addr_set(dev, sa->sa_data);\n\treturn 0;\n}\n\nstatic const struct lapb_register_struct lapbeth_callbacks = {\n\t.connect_confirmation    = lapbeth_connected,\n\t.connect_indication      = lapbeth_connected,\n\t.disconnect_confirmation = lapbeth_disconnected,\n\t.disconnect_indication   = lapbeth_disconnected,\n\t.data_indication         = lapbeth_data_indication,\n\t.data_transmit           = lapbeth_data_transmit,\n};\n\n \nstatic int lapbeth_open(struct net_device *dev)\n{\n\tstruct lapbethdev *lapbeth = netdev_priv(dev);\n\tint err;\n\n\tnapi_enable(&lapbeth->napi);\n\n\terr = lapb_register(dev, &lapbeth_callbacks);\n\tif (err != LAPB_OK) {\n\t\tnapi_disable(&lapbeth->napi);\n\t\tpr_err(\"lapb_register error: %d\\n\", err);\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_bh(&lapbeth->up_lock);\n\tlapbeth->up = true;\n\tspin_unlock_bh(&lapbeth->up_lock);\n\n\treturn 0;\n}\n\nstatic int lapbeth_close(struct net_device *dev)\n{\n\tstruct lapbethdev *lapbeth = netdev_priv(dev);\n\tint err;\n\n\tspin_lock_bh(&lapbeth->up_lock);\n\tlapbeth->up = false;\n\tspin_unlock_bh(&lapbeth->up_lock);\n\n\terr = lapb_unregister(dev);\n\tif (err != LAPB_OK)\n\t\tpr_err(\"lapb_unregister error: %d\\n\", err);\n\n\tnapi_disable(&lapbeth->napi);\n\n\treturn 0;\n}\n\n \n\nstatic const struct net_device_ops lapbeth_netdev_ops = {\n\t.ndo_open\t     = lapbeth_open,\n\t.ndo_stop\t     = lapbeth_close,\n\t.ndo_start_xmit\t     = lapbeth_xmit,\n\t.ndo_set_mac_address = lapbeth_set_mac_address,\n};\n\nstatic void lapbeth_setup(struct net_device *dev)\n{\n\tdev->netdev_ops\t     = &lapbeth_netdev_ops;\n\tdev->needs_free_netdev = true;\n\tdev->type            = ARPHRD_X25;\n\tdev->hard_header_len = 0;\n\tdev->mtu             = 1000;\n\tdev->addr_len        = 0;\n}\n\n \nstatic int lapbeth_new_device(struct net_device *dev)\n{\n\tstruct net_device *ndev;\n\tstruct lapbethdev *lapbeth;\n\tint rc = -ENOMEM;\n\n\tASSERT_RTNL();\n\n\tif (dev->type != ARPHRD_ETHER)\n\t\treturn -EINVAL;\n\n\tndev = alloc_netdev(sizeof(*lapbeth), \"lapb%d\", NET_NAME_UNKNOWN,\n\t\t\t    lapbeth_setup);\n\tif (!ndev)\n\t\tgoto out;\n\n\t \n\tndev->needed_headroom = -1 + 3 + 2 + dev->hard_header_len\n\t\t\t\t\t   + dev->needed_headroom;\n\tndev->needed_tailroom = dev->needed_tailroom;\n\n\tlapbeth = netdev_priv(ndev);\n\tlapbeth->axdev = ndev;\n\n\tdev_hold(dev);\n\tlapbeth->ethdev = dev;\n\n\tlapbeth->up = false;\n\tspin_lock_init(&lapbeth->up_lock);\n\n\tskb_queue_head_init(&lapbeth->rx_queue);\n\tnetif_napi_add_weight(ndev, &lapbeth->napi, lapbeth_napi_poll, 16);\n\n\trc = -EIO;\n\tif (register_netdevice(ndev))\n\t\tgoto fail;\n\n\tlist_add_rcu(&lapbeth->node, &lapbeth_devices);\n\trc = 0;\nout:\n\treturn rc;\nfail:\n\tdev_put(dev);\n\tfree_netdev(ndev);\n\tgoto out;\n}\n\n \nstatic void lapbeth_free_device(struct lapbethdev *lapbeth)\n{\n\tdev_put(lapbeth->ethdev);\n\tlist_del_rcu(&lapbeth->node);\n\tunregister_netdevice(lapbeth->axdev);\n}\n\n \nstatic int lapbeth_device_event(struct notifier_block *this,\n\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct lapbethdev *lapbeth;\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tif (dev_net(dev) != &init_net)\n\t\treturn NOTIFY_DONE;\n\n\tif (!dev_is_ethdev(dev) && !lapbeth_get_x25_dev(dev))\n\t\treturn NOTIFY_DONE;\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\t \n\t\tif (!lapbeth_get_x25_dev(dev))\n\t\t\tlapbeth_new_device(dev);\n\t\tbreak;\n\tcase NETDEV_GOING_DOWN:\n\t\t \n\t\tlapbeth = lapbeth_get_x25_dev(dev);\n\t\tif (lapbeth)\n\t\t\tdev_close(lapbeth->axdev);\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\t\t \n\t\tlapbeth = lapbeth_get_x25_dev(dev);\n\t\tif (lapbeth)\n\t\t\tlapbeth_free_device(lapbeth);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\n \n\nstatic struct packet_type lapbeth_packet_type __read_mostly = {\n\t.type = cpu_to_be16(ETH_P_DEC),\n\t.func = lapbeth_rcv,\n};\n\nstatic struct notifier_block lapbeth_dev_notifier = {\n\t.notifier_call = lapbeth_device_event,\n};\n\nstatic const char banner[] __initconst =\n\tKERN_INFO \"LAPB Ethernet driver version 0.02\\n\";\n\nstatic int __init lapbeth_init_driver(void)\n{\n\tdev_add_pack(&lapbeth_packet_type);\n\n\tregister_netdevice_notifier(&lapbeth_dev_notifier);\n\n\tprintk(banner);\n\n\treturn 0;\n}\nmodule_init(lapbeth_init_driver);\n\nstatic void __exit lapbeth_cleanup_driver(void)\n{\n\tstruct lapbethdev *lapbeth;\n\tstruct list_head *entry, *tmp;\n\n\tdev_remove_pack(&lapbeth_packet_type);\n\tunregister_netdevice_notifier(&lapbeth_dev_notifier);\n\n\trtnl_lock();\n\tlist_for_each_safe(entry, tmp, &lapbeth_devices) {\n\t\tlapbeth = list_entry(entry, struct lapbethdev, node);\n\n\t\tdev_put(lapbeth->ethdev);\n\t\tunregister_netdevice(lapbeth->axdev);\n\t}\n\trtnl_unlock();\n}\nmodule_exit(lapbeth_cleanup_driver);\n\nMODULE_AUTHOR(\"Jonathan Naylor <g4klx@g4klx.demon.co.uk>\");\nMODULE_DESCRIPTION(\"The unofficial LAPB over Ethernet driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}