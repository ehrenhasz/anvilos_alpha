{
  "module_name": "farsync.c",
  "hash_id": "41ad54c5cd3c38129de02c28f68324ef7bb1ac3c69447e237b33df1dad16c997",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wan/farsync.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/pci.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/ioport.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/if.h>\n#include <linux/hdlc.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n\n#include \"farsync.h\"\n\n \nMODULE_AUTHOR(\"R.J.Dunlop <bob.dunlop@farsite.co.uk>\");\nMODULE_DESCRIPTION(\"FarSync T-Series WAN driver. FarSite Communications Ltd.\");\nMODULE_LICENSE(\"GPL\");\n\n \n\n \n#define FST_MAX_PORTS           4\n#define FST_MAX_CARDS           32\n\n \n#define FST_TX_QUEUE_LEN        100\t \n#define FST_TXQ_DEPTH           16\t \n#define FST_HIGH_WATER_MARK     12\t \n#define FST_LOW_WATER_MARK      8\t \n#define FST_MAX_MTU             8000\t \n#define FST_DEF_MTU             1500\t \n\n#define FST_TX_TIMEOUT          (2 * HZ)\n\n#ifdef ARPHRD_RAWHDLC\n#define ARPHRD_MYTYPE   ARPHRD_RAWHDLC\t \n#else\n#define ARPHRD_MYTYPE   ARPHRD_HDLC\t \n#endif\n\n \nstatic int fst_txq_low = FST_LOW_WATER_MARK;\nstatic int fst_txq_high = FST_HIGH_WATER_MARK;\nstatic int fst_max_reads = 7;\nstatic int fst_excluded_cards;\nstatic int fst_excluded_list[FST_MAX_CARDS];\n\nmodule_param(fst_txq_low, int, 0);\nmodule_param(fst_txq_high, int, 0);\nmodule_param(fst_max_reads, int, 0);\nmodule_param(fst_excluded_cards, int, 0);\nmodule_param_array(fst_excluded_list, int, NULL, 0);\n\n \n#pragma pack(1)\n\n \n#define SMC_VERSION 24\n\n#define FST_MEMSIZE 0x100000\t \n\n#define SMC_BASE 0x00002000L\t \n#define BFM_BASE 0x00010000L\t \n\n#define LEN_TX_BUFFER 8192\t \n#define LEN_RX_BUFFER 8192\n\n#define LEN_SMALL_TX_BUFFER 256\t \n#define LEN_SMALL_RX_BUFFER 256\n\n#define NUM_TX_BUFFER 2\t\t \n#define NUM_RX_BUFFER 8\n\n \n#define INT_RETRY_TIME 2\n\n \nstruct txdesc {\t\t\t \n\tvolatile u16 ladr;\t \n\tvolatile u8 hadr;\t \n\tvolatile u8 bits;\t \n\tvolatile u16 bcnt;\t \n\tu16 unused;\t\t \n};\n\nstruct rxdesc {\t\t\t \n\tvolatile u16 ladr;\t \n\tvolatile u8 hadr;\t \n\tvolatile u8 bits;\t \n\tvolatile u16 bcnt;\t \n\tvolatile u16 mcnt;\t \n};\n\n \n \n \n#define cnv_bcnt(len)   (-(len))\n\n \n#define DMA_OWN         0x80\t \n#define TX_STP          0x02\t \n#define TX_ENP          0x01\t \n#define RX_ERR          0x40\t \n#define RX_FRAM         0x20\t \n#define RX_OFLO         0x10\t \n#define RX_CRC          0x08\t \n#define RX_HBUF         0x04\t \n#define RX_STP          0x02\t \n#define RX_ENP          0x01\t \n\n \n#define MAX_CIRBUFF     32\n\nstruct cirbuff {\n\tu8 rdindex;\t\t \n\tu8 wrindex;\t\t \n\tu8 evntbuff[MAX_CIRBUFF];\n};\n\n \n#define CTLA_CHG        0x18\t \n#define CTLB_CHG        0x19\n#define CTLC_CHG        0x1A\n#define CTLD_CHG        0x1B\n\n#define INIT_CPLT       0x20\t \n#define INIT_FAIL       0x21\t \n\n#define ABTA_SENT       0x24\t \n#define ABTB_SENT       0x25\n#define ABTC_SENT       0x26\n#define ABTD_SENT       0x27\n\n#define TXA_UNDF        0x28\t \n#define TXB_UNDF        0x29\n#define TXC_UNDF        0x2A\n#define TXD_UNDF        0x2B\n\n#define F56_INT         0x2C\n#define M32_INT         0x2D\n\n#define TE1_ALMA        0x30\n\n \nstruct port_cfg {\n\tu16 lineInterface;\t \n\tu8 x25op;\t\t \n\tu8 internalClock;\t \n\tu8 transparentMode;\t \n\tu8 invertClock;\t\t \n\tu8 padBytes[6];\t\t \n\tu32 lineSpeed;\t\t \n};\n\n \nstruct su_config {\n\tu32 dataRate;\n\tu8 clocking;\n\tu8 framing;\n\tu8 structure;\n\tu8 interface;\n\tu8 coding;\n\tu8 lineBuildOut;\n\tu8 equalizer;\n\tu8 transparentMode;\n\tu8 loopMode;\n\tu8 range;\n\tu8 txBufferMode;\n\tu8 rxBufferMode;\n\tu8 startingSlot;\n\tu8 losThreshold;\n\tu8 enableIdleCode;\n\tu8 idleCode;\n\tu8 spare[44];\n};\n\n \nstruct su_status {\n\tu32 receiveBufferDelay;\n\tu32 framingErrorCount;\n\tu32 codeViolationCount;\n\tu32 crcErrorCount;\n\tu32 lineAttenuation;\n\tu8 portStarted;\n\tu8 lossOfSignal;\n\tu8 receiveRemoteAlarm;\n\tu8 alarmIndicationSignal;\n\tu8 spare[40];\n};\n\n \nstruct fst_shared {\n\t \n\tstruct rxdesc rxDescrRing[FST_MAX_PORTS][NUM_RX_BUFFER];\n\tstruct txdesc txDescrRing[FST_MAX_PORTS][NUM_TX_BUFFER];\n\n\t \n\tu8 smallRxBuffer[FST_MAX_PORTS][NUM_RX_BUFFER][LEN_SMALL_RX_BUFFER];\n\tu8 smallTxBuffer[FST_MAX_PORTS][NUM_TX_BUFFER][LEN_SMALL_TX_BUFFER];\n\n\tu8 taskStatus;\t\t \n\n\tu8 interruptHandshake;\t \n\n\tu16 smcVersion;\t\t \n\n\tu32 smcFirmwareVersion;\t \n\n\tu16 txa_done;\t\t \n\tu16 rxa_done;\n\tu16 txb_done;\n\tu16 rxb_done;\n\tu16 txc_done;\n\tu16 rxc_done;\n\tu16 txd_done;\n\tu16 rxd_done;\n\n\tu16 mailbox[4];\t\t \n\n\tstruct cirbuff interruptEvent;\t \n\n\tu32 v24IpSts[FST_MAX_PORTS];\t \n\tu32 v24OpSts[FST_MAX_PORTS];\t \n\n\tstruct port_cfg portConfig[FST_MAX_PORTS];\n\n\tu16 clockStatus[FST_MAX_PORTS];\t \n\n\tu16 cableStatus;\t \n\n\tu16 txDescrIndex[FST_MAX_PORTS];\t \n\tu16 rxDescrIndex[FST_MAX_PORTS];\t \n\n\tu16 portMailbox[FST_MAX_PORTS][2];\t \n\tu16 cardMailbox[4];\t \n\n\t \n\tu32 interruptRetryCount;\n\n\t \n\tu32 portHandle[FST_MAX_PORTS];\n\n\t \n\tu32 transmitBufferUnderflow[FST_MAX_PORTS];\n\n\t \n\tu32 v24DebouncedSts[FST_MAX_PORTS];\n\n\t \n\tu32 ctsTimer[FST_MAX_PORTS];\n\tu32 ctsTimerRun[FST_MAX_PORTS];\n\tu32 dcdTimer[FST_MAX_PORTS];\n\tu32 dcdTimerRun[FST_MAX_PORTS];\n\n\tu32 numberOfPorts;\t \n\n\tu16 _reserved[64];\n\n\tu16 cardMode;\t\t \n\n\tu16 portScheduleOffset;\n\n\tstruct su_config suConfig;\t \n\tstruct su_status suStatus;\n\n\tu32 endOfSmcSignature;\t \n};\n\n \n#define END_SIG                 0x12345678\n\n \n#define NOP             0\t \n#define ACK             1\t \n#define NAK             2\t \n#define STARTPORT       3\t \n#define STOPPORT        4\t \n#define ABORTTX         5\t \n#define SETV24O         6\t \n\n \n#define CNTRL_9052      0x50\t \n#define CNTRL_9054      0x6c\t \n\n#define INTCSR_9052     0x4c\t \n#define INTCSR_9054     0x68\t \n\n \n \n#define DMAMODE0        0x80\n#define DMAPADR0        0x84\n#define DMALADR0        0x88\n#define DMASIZ0         0x8c\n#define DMADPR0         0x90\n#define DMAMODE1        0x94\n#define DMAPADR1        0x98\n#define DMALADR1        0x9c\n#define DMASIZ1         0xa0\n#define DMADPR1         0xa4\n#define DMACSR0         0xa8\n#define DMACSR1         0xa9\n#define DMAARB          0xac\n#define DMATHR          0xb0\n#define DMADAC0         0xb4\n#define DMADAC1         0xb8\n#define DMAMARBR        0xac\n\n#define FST_MIN_DMA_LEN 64\n#define FST_RX_DMA_INT  0x01\n#define FST_TX_DMA_INT  0x02\n#define FST_CARD_INT    0x04\n\n \nstruct buf_window {\n\tu8 txBuffer[FST_MAX_PORTS][NUM_TX_BUFFER][LEN_TX_BUFFER];\n\tu8 rxBuffer[FST_MAX_PORTS][NUM_RX_BUFFER][LEN_RX_BUFFER];\n};\n\n \n#define BUF_OFFSET(X)   (BFM_BASE + offsetof(struct buf_window, X))\n\n#pragma pack()\n\n \n \nstruct fst_port_info {\n\tstruct net_device *dev;  \n\tstruct fst_card_info *card;\t \n\tint index;\t\t \n\tint hwif;\t\t \n\tint run;\t\t \n\tint mode;\t\t \n\tint rxpos;\t\t \n\tint txpos;\t\t \n\tint txipos;\t\t \n\tint start;\t\t \n\t \n\tint txqs;\t\t \n\tint txqe;\t\t \n\tstruct sk_buff *txq[FST_TXQ_DEPTH];\t \n\tint rxqdepth;\n};\n\n \nstruct fst_card_info {\n\tchar __iomem *mem;\t \n\tchar __iomem *ctlmem;\t \n\tunsigned int phys_mem;\t \n\tunsigned int phys_ctlmem;\t \n\tunsigned int irq;\t \n\tunsigned int nports;\t \n\tunsigned int type;\t \n\tunsigned int state;\t \n\tspinlock_t card_lock;\t \n\tunsigned short pci_conf;\t \n\t \n\tstruct fst_port_info ports[FST_MAX_PORTS];\n\tstruct pci_dev *device;\t \n\tint card_no;\t\t \n\tint family;\t\t \n\tint dmarx_in_progress;\n\tint dmatx_in_progress;\n\tunsigned long int_count;\n\tunsigned long int_time_ave;\n\tvoid *rx_dma_handle_host;\n\tdma_addr_t rx_dma_handle_card;\n\tvoid *tx_dma_handle_host;\n\tdma_addr_t tx_dma_handle_card;\n\tstruct sk_buff *dma_skb_rx;\n\tstruct fst_port_info *dma_port_rx;\n\tstruct fst_port_info *dma_port_tx;\n\tint dma_len_rx;\n\tint dma_len_tx;\n\tint dma_txpos;\n\tint dma_rxpos;\n};\n\n \n#define dev_to_port(D)  (dev_to_hdlc(D)->priv)\n#define port_to_dev(P)  ((P)->dev)\n\n \n#define WIN_OFFSET(X)   ((long)&(((struct fst_shared *)SMC_BASE)->X))\n\n#define FST_RDB(C, E)    (readb((C)->mem + WIN_OFFSET(E)))\n#define FST_RDW(C, E)    (readw((C)->mem + WIN_OFFSET(E)))\n#define FST_RDL(C, E)    (readl((C)->mem + WIN_OFFSET(E)))\n\n#define FST_WRB(C, E, B)  (writeb((B), (C)->mem + WIN_OFFSET(E)))\n#define FST_WRW(C, E, W)  (writew((W), (C)->mem + WIN_OFFSET(E)))\n#define FST_WRL(C, E, L)  (writel((L), (C)->mem + WIN_OFFSET(E)))\n\n \n#if FST_DEBUG\n\nstatic int fst_debug_mask = { FST_DEBUG };\n\n \n#define dbg(F, fmt, args...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (fst_debug_mask & (F))\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(fmt), ##args);\t\t\\\n} while (0)\n#else\n#define dbg(F, fmt, args...)\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\t\\\n\t\tprintk(KERN_DEBUG pr_fmt(fmt), ##args);\t\t\\\n} while (0)\n#endif\n\n \nstatic const struct pci_device_id fst_pci_dev_id[] = {\n\t{PCI_VENDOR_ID_FARSITE, PCI_DEVICE_ID_FARSITE_T2P, PCI_ANY_ID,\n\t PCI_ANY_ID, 0, 0, FST_TYPE_T2P},\n\n\t{PCI_VENDOR_ID_FARSITE, PCI_DEVICE_ID_FARSITE_T4P, PCI_ANY_ID,\n\t PCI_ANY_ID, 0, 0, FST_TYPE_T4P},\n\n\t{PCI_VENDOR_ID_FARSITE, PCI_DEVICE_ID_FARSITE_T1U, PCI_ANY_ID,\n\t PCI_ANY_ID, 0, 0, FST_TYPE_T1U},\n\n\t{PCI_VENDOR_ID_FARSITE, PCI_DEVICE_ID_FARSITE_T2U, PCI_ANY_ID,\n\t PCI_ANY_ID, 0, 0, FST_TYPE_T2U},\n\n\t{PCI_VENDOR_ID_FARSITE, PCI_DEVICE_ID_FARSITE_T4U, PCI_ANY_ID,\n\t PCI_ANY_ID, 0, 0, FST_TYPE_T4U},\n\n\t{PCI_VENDOR_ID_FARSITE, PCI_DEVICE_ID_FARSITE_TE1, PCI_ANY_ID,\n\t PCI_ANY_ID, 0, 0, FST_TYPE_TE1},\n\n\t{PCI_VENDOR_ID_FARSITE, PCI_DEVICE_ID_FARSITE_TE1C, PCI_ANY_ID,\n\t PCI_ANY_ID, 0, 0, FST_TYPE_TE1},\n\t{0,}\t\t\t \n};\n\nMODULE_DEVICE_TABLE(pci, fst_pci_dev_id);\n\n \n\nstatic void do_bottom_half_tx(struct fst_card_info *card);\nstatic void do_bottom_half_rx(struct fst_card_info *card);\nstatic void fst_process_tx_work_q(struct tasklet_struct *unused);\nstatic void fst_process_int_work_q(struct tasklet_struct *unused);\n\nstatic DECLARE_TASKLET(fst_tx_task, fst_process_tx_work_q);\nstatic DECLARE_TASKLET(fst_int_task, fst_process_int_work_q);\n\nstatic struct fst_card_info *fst_card_array[FST_MAX_CARDS];\nstatic DEFINE_SPINLOCK(fst_work_q_lock);\nstatic u64 fst_work_txq;\nstatic u64 fst_work_intq;\n\nstatic void\nfst_q_work_item(u64 *queue, int card_index)\n{\n\tunsigned long flags;\n\tu64 mask;\n\n\t \n\tspin_lock_irqsave(&fst_work_q_lock, flags);\n\n\t \n\tmask = (u64)1 << card_index;\n\t*queue |= mask;\n\tspin_unlock_irqrestore(&fst_work_q_lock, flags);\n}\n\nstatic void\nfst_process_tx_work_q(struct tasklet_struct *unused)\n{\n\tunsigned long flags;\n\tu64 work_txq;\n\tint i;\n\n\t \n\tdbg(DBG_TX, \"fst_process_tx_work_q\\n\");\n\tspin_lock_irqsave(&fst_work_q_lock, flags);\n\twork_txq = fst_work_txq;\n\tfst_work_txq = 0;\n\tspin_unlock_irqrestore(&fst_work_q_lock, flags);\n\n\t \n\tfor (i = 0; i < FST_MAX_CARDS; i++) {\n\t\tif (work_txq & 0x01) {\n\t\t\tif (fst_card_array[i]) {\n\t\t\t\tdbg(DBG_TX, \"Calling tx bh for card %d\\n\", i);\n\t\t\t\tdo_bottom_half_tx(fst_card_array[i]);\n\t\t\t}\n\t\t}\n\t\twork_txq = work_txq >> 1;\n\t}\n}\n\nstatic void\nfst_process_int_work_q(struct tasklet_struct *unused)\n{\n\tunsigned long flags;\n\tu64 work_intq;\n\tint i;\n\n\t \n\tdbg(DBG_INTR, \"fst_process_int_work_q\\n\");\n\tspin_lock_irqsave(&fst_work_q_lock, flags);\n\twork_intq = fst_work_intq;\n\tfst_work_intq = 0;\n\tspin_unlock_irqrestore(&fst_work_q_lock, flags);\n\n\t \n\tfor (i = 0; i < FST_MAX_CARDS; i++) {\n\t\tif (work_intq & 0x01) {\n\t\t\tif (fst_card_array[i]) {\n\t\t\t\tdbg(DBG_INTR,\n\t\t\t\t    \"Calling rx & tx bh for card %d\\n\", i);\n\t\t\t\tdo_bottom_half_rx(fst_card_array[i]);\n\t\t\t\tdo_bottom_half_tx(fst_card_array[i]);\n\t\t\t}\n\t\t}\n\t\twork_intq = work_intq >> 1;\n\t}\n}\n\n \n \nstatic inline void\nfst_cpureset(struct fst_card_info *card)\n{\n\tunsigned char interrupt_line_register;\n\tunsigned int regval;\n\n\tif (card->family == FST_FAMILY_TXU) {\n\t\tif (pci_read_config_byte\n\t\t    (card->device, PCI_INTERRUPT_LINE, &interrupt_line_register)) {\n\t\t\tdbg(DBG_ASS,\n\t\t\t    \"Error in reading interrupt line register\\n\");\n\t\t}\n\t\t \n\t\toutw(0x440f, card->pci_conf + CNTRL_9054 + 2);\n\t\toutw(0x040f, card->pci_conf + CNTRL_9054 + 2);\n\t\t \n\t\tusleep_range(10, 20);\n\t\toutw(0x240f, card->pci_conf + CNTRL_9054 + 2);\n\t\t \n\t\tusleep_range(10, 20);\n\t\toutw(0x040f, card->pci_conf + CNTRL_9054 + 2);\n\n\t\tif (pci_write_config_byte\n\t\t    (card->device, PCI_INTERRUPT_LINE, interrupt_line_register)) {\n\t\t\tdbg(DBG_ASS,\n\t\t\t    \"Error in writing interrupt line register\\n\");\n\t\t}\n\n\t} else {\n\t\tregval = inl(card->pci_conf + CNTRL_9052);\n\n\t\toutl(regval | 0x40000000, card->pci_conf + CNTRL_9052);\n\t\toutl(regval & ~0x40000000, card->pci_conf + CNTRL_9052);\n\t}\n}\n\n \nstatic inline void\nfst_cpurelease(struct fst_card_info *card)\n{\n\tif (card->family == FST_FAMILY_TXU) {\n\t\t \n\t\t(void)readb(card->mem);\n\n\t\t \n\t\toutw(0x040e, card->pci_conf + CNTRL_9054 + 2);\n\t\toutw(0x040f, card->pci_conf + CNTRL_9054 + 2);\n\t} else {\n\t\t(void)readb(card->ctlmem);\n\t}\n}\n\n \nstatic inline void\nfst_clear_intr(struct fst_card_info *card)\n{\n\tif (card->family == FST_FAMILY_TXU) {\n\t\t(void)readb(card->ctlmem);\n\t} else {\n\t\t \n\t\toutw(0x0543, card->pci_conf + INTCSR_9052);\n\t}\n}\n\n \nstatic inline void\nfst_enable_intr(struct fst_card_info *card)\n{\n\tif (card->family == FST_FAMILY_TXU)\n\t\toutl(0x0f0c0900, card->pci_conf + INTCSR_9054);\n\telse\n\t\toutw(0x0543, card->pci_conf + INTCSR_9052);\n}\n\n \nstatic inline void\nfst_disable_intr(struct fst_card_info *card)\n{\n\tif (card->family == FST_FAMILY_TXU)\n\t\toutl(0x00000000, card->pci_conf + INTCSR_9054);\n\telse\n\t\toutw(0x0000, card->pci_conf + INTCSR_9052);\n}\n\n \nstatic void\nfst_process_rx_status(int rx_status, char *name)\n{\n\tswitch (rx_status) {\n\tcase NET_RX_SUCCESS:\n\t\t{\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\tcase NET_RX_DROP:\n\t\t{\n\t\t\tdbg(DBG_ASS, \"%s: Received packet dropped\\n\", name);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic inline void\nfst_init_dma(struct fst_card_info *card)\n{\n\t \n\tif (card->family == FST_FAMILY_TXU) {\n\t\tpci_set_master(card->device);\n\t\toutl(0x00020441, card->pci_conf + DMAMODE0);\n\t\toutl(0x00020441, card->pci_conf + DMAMODE1);\n\t\toutl(0x0, card->pci_conf + DMATHR);\n\t}\n}\n\n \nstatic void\nfst_tx_dma_complete(struct fst_card_info *card, struct fst_port_info *port,\n\t\t    int len, int txpos)\n{\n\tstruct net_device *dev = port_to_dev(port);\n\n\t \n\tdbg(DBG_TX, \"fst_tx_dma_complete\\n\");\n\tFST_WRB(card, txDescrRing[port->index][txpos].bits,\n\t\tDMA_OWN | TX_STP | TX_ENP);\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += len;\n\tnetif_trans_update(dev);\n}\n\n \nstatic __be16 farsync_type_trans(struct sk_buff *skb, struct net_device *dev)\n{\n\tskb->dev = dev;\n\tskb_reset_mac_header(skb);\n\tskb->pkt_type = PACKET_HOST;\n\treturn htons(ETH_P_CUST);\n}\n\n \nstatic void\nfst_rx_dma_complete(struct fst_card_info *card, struct fst_port_info *port,\n\t\t    int len, struct sk_buff *skb, int rxp)\n{\n\tstruct net_device *dev = port_to_dev(port);\n\tint pi;\n\tint rx_status;\n\n\tdbg(DBG_TX, \"fst_rx_dma_complete\\n\");\n\tpi = port->index;\n\tskb_put_data(skb, card->rx_dma_handle_host, len);\n\n\t \n\tFST_WRB(card, rxDescrRing[pi][rxp].bits, DMA_OWN);\n\n\t \n\tdev->stats.rx_packets++;\n\tdev->stats.rx_bytes += len;\n\n\t \n\tdbg(DBG_RX, \"Pushing the frame up the stack\\n\");\n\tif (port->mode == FST_RAW)\n\t\tskb->protocol = farsync_type_trans(skb, dev);\n\telse\n\t\tskb->protocol = hdlc_type_trans(skb, dev);\n\trx_status = netif_rx(skb);\n\tfst_process_rx_status(rx_status, port_to_dev(port)->name);\n\tif (rx_status == NET_RX_DROP)\n\t\tdev->stats.rx_dropped++;\n}\n\n \nstatic inline void\nfst_rx_dma(struct fst_card_info *card, dma_addr_t dma, u32 mem, int len)\n{\n\t \n\n\tdbg(DBG_RX, \"In fst_rx_dma %x %x %d\\n\", (u32)dma, mem, len);\n\tif (card->dmarx_in_progress)\n\t\tdbg(DBG_ASS, \"In fst_rx_dma while dma in progress\\n\");\n\n\toutl(dma, card->pci_conf + DMAPADR0);\t \n\toutl(mem, card->pci_conf + DMALADR0);\t \n\toutl(len, card->pci_conf + DMASIZ0);\t \n\toutl(0x00000000c, card->pci_conf + DMADPR0);\t \n\n\t \n\tcard->dmarx_in_progress = 1;\n\toutb(0x03, card->pci_conf + DMACSR0);\t \n}\n\n \nstatic inline void\nfst_tx_dma(struct fst_card_info *card, dma_addr_t dma, u32 mem, int len)\n{\n\t \n\n\tdbg(DBG_TX, \"In fst_tx_dma %x %x %d\\n\", (u32)dma, mem, len);\n\tif (card->dmatx_in_progress)\n\t\tdbg(DBG_ASS, \"In fst_tx_dma while dma in progress\\n\");\n\n\toutl(dma, card->pci_conf + DMAPADR1);\t \n\toutl(mem, card->pci_conf + DMALADR1);\t \n\toutl(len, card->pci_conf + DMASIZ1);\t \n\toutl(0x000000004, card->pci_conf + DMADPR1);\t \n\n\t \n\tcard->dmatx_in_progress = 1;\n\toutb(0x03, card->pci_conf + DMACSR1);\t \n}\n\n \nstatic void\nfst_issue_cmd(struct fst_port_info *port, unsigned short cmd)\n{\n\tstruct fst_card_info *card;\n\tunsigned short mbval;\n\tunsigned long flags;\n\tint safety;\n\n\tcard = port->card;\n\tspin_lock_irqsave(&card->card_lock, flags);\n\tmbval = FST_RDW(card, portMailbox[port->index][0]);\n\n\tsafety = 0;\n\t \n\twhile (mbval > NAK) {\n\t\tspin_unlock_irqrestore(&card->card_lock, flags);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tspin_lock_irqsave(&card->card_lock, flags);\n\n\t\tif (++safety > 2000) {\n\t\t\tpr_err(\"Mailbox safety timeout\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tmbval = FST_RDW(card, portMailbox[port->index][0]);\n\t}\n\tif (safety > 0)\n\t\tdbg(DBG_CMD, \"Mailbox clear after %d jiffies\\n\", safety);\n\n\tif (mbval == NAK)\n\t\tdbg(DBG_CMD, \"issue_cmd: previous command was NAK'd\\n\");\n\n\tFST_WRW(card, portMailbox[port->index][0], cmd);\n\n\tif (cmd == ABORTTX || cmd == STARTPORT) {\n\t\tport->txpos = 0;\n\t\tport->txipos = 0;\n\t\tport->start = 0;\n\t}\n\n\tspin_unlock_irqrestore(&card->card_lock, flags);\n}\n\n \nstatic inline void\nfst_op_raise(struct fst_port_info *port, unsigned int outputs)\n{\n\toutputs |= FST_RDL(port->card, v24OpSts[port->index]);\n\tFST_WRL(port->card, v24OpSts[port->index], outputs);\n\n\tif (port->run)\n\t\tfst_issue_cmd(port, SETV24O);\n}\n\nstatic inline void\nfst_op_lower(struct fst_port_info *port, unsigned int outputs)\n{\n\toutputs = ~outputs & FST_RDL(port->card, v24OpSts[port->index]);\n\tFST_WRL(port->card, v24OpSts[port->index], outputs);\n\n\tif (port->run)\n\t\tfst_issue_cmd(port, SETV24O);\n}\n\n \nstatic void\nfst_rx_config(struct fst_port_info *port)\n{\n\tint i;\n\tint pi;\n\tunsigned int offset;\n\tunsigned long flags;\n\tstruct fst_card_info *card;\n\n\tpi = port->index;\n\tcard = port->card;\n\tspin_lock_irqsave(&card->card_lock, flags);\n\tfor (i = 0; i < NUM_RX_BUFFER; i++) {\n\t\toffset = BUF_OFFSET(rxBuffer[pi][i][0]);\n\n\t\tFST_WRW(card, rxDescrRing[pi][i].ladr, (u16)offset);\n\t\tFST_WRB(card, rxDescrRing[pi][i].hadr, (u8)(offset >> 16));\n\t\tFST_WRW(card, rxDescrRing[pi][i].bcnt, cnv_bcnt(LEN_RX_BUFFER));\n\t\tFST_WRW(card, rxDescrRing[pi][i].mcnt, LEN_RX_BUFFER);\n\t\tFST_WRB(card, rxDescrRing[pi][i].bits, DMA_OWN);\n\t}\n\tport->rxpos = 0;\n\tspin_unlock_irqrestore(&card->card_lock, flags);\n}\n\n \nstatic void\nfst_tx_config(struct fst_port_info *port)\n{\n\tint i;\n\tint pi;\n\tunsigned int offset;\n\tunsigned long flags;\n\tstruct fst_card_info *card;\n\n\tpi = port->index;\n\tcard = port->card;\n\tspin_lock_irqsave(&card->card_lock, flags);\n\tfor (i = 0; i < NUM_TX_BUFFER; i++) {\n\t\toffset = BUF_OFFSET(txBuffer[pi][i][0]);\n\n\t\tFST_WRW(card, txDescrRing[pi][i].ladr, (u16)offset);\n\t\tFST_WRB(card, txDescrRing[pi][i].hadr, (u8)(offset >> 16));\n\t\tFST_WRW(card, txDescrRing[pi][i].bcnt, 0);\n\t\tFST_WRB(card, txDescrRing[pi][i].bits, 0);\n\t}\n\tport->txpos = 0;\n\tport->txipos = 0;\n\tport->start = 0;\n\tspin_unlock_irqrestore(&card->card_lock, flags);\n}\n\n \nstatic void\nfst_intr_te1_alarm(struct fst_card_info *card, struct fst_port_info *port)\n{\n\tu8 los;\n\tu8 rra;\n\tu8 ais;\n\n\tlos = FST_RDB(card, suStatus.lossOfSignal);\n\trra = FST_RDB(card, suStatus.receiveRemoteAlarm);\n\tais = FST_RDB(card, suStatus.alarmIndicationSignal);\n\n\tif (los) {\n\t\t \n\t\tif (netif_carrier_ok(port_to_dev(port))) {\n\t\t\tdbg(DBG_INTR, \"Net carrier off\\n\");\n\t\t\tnetif_carrier_off(port_to_dev(port));\n\t\t}\n\t} else {\n\t\t \n\t\tif (!netif_carrier_ok(port_to_dev(port))) {\n\t\t\tdbg(DBG_INTR, \"Net carrier on\\n\");\n\t\t\tnetif_carrier_on(port_to_dev(port));\n\t\t}\n\t}\n\n\tif (los)\n\t\tdbg(DBG_INTR, \"Assert LOS Alarm\\n\");\n\telse\n\t\tdbg(DBG_INTR, \"De-assert LOS Alarm\\n\");\n\tif (rra)\n\t\tdbg(DBG_INTR, \"Assert RRA Alarm\\n\");\n\telse\n\t\tdbg(DBG_INTR, \"De-assert RRA Alarm\\n\");\n\n\tif (ais)\n\t\tdbg(DBG_INTR, \"Assert AIS Alarm\\n\");\n\telse\n\t\tdbg(DBG_INTR, \"De-assert AIS Alarm\\n\");\n}\n\n \nstatic void\nfst_intr_ctlchg(struct fst_card_info *card, struct fst_port_info *port)\n{\n\tint signals;\n\n\tsignals = FST_RDL(card, v24DebouncedSts[port->index]);\n\n\tif (signals & ((port->hwif == X21 || port->hwif == X21D)\n\t\t       ? IPSTS_INDICATE : IPSTS_DCD)) {\n\t\tif (!netif_carrier_ok(port_to_dev(port))) {\n\t\t\tdbg(DBG_INTR, \"DCD active\\n\");\n\t\t\tnetif_carrier_on(port_to_dev(port));\n\t\t}\n\t} else {\n\t\tif (netif_carrier_ok(port_to_dev(port))) {\n\t\t\tdbg(DBG_INTR, \"DCD lost\\n\");\n\t\t\tnetif_carrier_off(port_to_dev(port));\n\t\t}\n\t}\n}\n\n \nstatic void\nfst_log_rx_error(struct fst_card_info *card, struct fst_port_info *port,\n\t\t unsigned char dmabits, int rxp, unsigned short len)\n{\n\tstruct net_device *dev = port_to_dev(port);\n\n\t \n\tdev->stats.rx_errors++;\n\tif (dmabits & RX_OFLO) {\n\t\tdev->stats.rx_fifo_errors++;\n\t\tdbg(DBG_ASS, \"Rx fifo error on card %d port %d buffer %d\\n\",\n\t\t    card->card_no, port->index, rxp);\n\t}\n\tif (dmabits & RX_CRC) {\n\t\tdev->stats.rx_crc_errors++;\n\t\tdbg(DBG_ASS, \"Rx crc error on card %d port %d\\n\",\n\t\t    card->card_no, port->index);\n\t}\n\tif (dmabits & RX_FRAM) {\n\t\tdev->stats.rx_frame_errors++;\n\t\tdbg(DBG_ASS, \"Rx frame error on card %d port %d\\n\",\n\t\t    card->card_no, port->index);\n\t}\n\tif (dmabits == (RX_STP | RX_ENP)) {\n\t\tdev->stats.rx_length_errors++;\n\t\tdbg(DBG_ASS, \"Rx length error (%d) on card %d port %d\\n\",\n\t\t    len, card->card_no, port->index);\n\t}\n}\n\n \nstatic void\nfst_recover_rx_error(struct fst_card_info *card, struct fst_port_info *port,\n\t\t     unsigned char dmabits, int rxp, unsigned short len)\n{\n\tint i;\n\tint pi;\n\n\tpi = port->index;\n\t \n\ti = 0;\n\twhile ((dmabits & (DMA_OWN | RX_STP)) == 0) {\n\t\tFST_WRB(card, rxDescrRing[pi][rxp].bits, DMA_OWN);\n\t\trxp = (rxp + 1) % NUM_RX_BUFFER;\n\t\tif (++i > NUM_RX_BUFFER) {\n\t\t\tdbg(DBG_ASS, \"intr_rx: Discarding more bufs\"\n\t\t\t    \" than we have\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tdmabits = FST_RDB(card, rxDescrRing[pi][rxp].bits);\n\t\tdbg(DBG_ASS, \"DMA Bits of next buffer was %x\\n\", dmabits);\n\t}\n\tdbg(DBG_ASS, \"There were %d subsequent buffers in error\\n\", i);\n\n\t \n\tif (!(dmabits & DMA_OWN)) {\n\t\tFST_WRB(card, rxDescrRing[pi][rxp].bits, DMA_OWN);\n\t\trxp = (rxp + 1) % NUM_RX_BUFFER;\n\t}\n\tport->rxpos = rxp;\n}\n\n \nstatic void\nfst_intr_rx(struct fst_card_info *card, struct fst_port_info *port)\n{\n\tunsigned char dmabits;\n\tint pi;\n\tint rxp;\n\tint rx_status;\n\tunsigned short len;\n\tstruct sk_buff *skb;\n\tstruct net_device *dev = port_to_dev(port);\n\n\t \n\tpi = port->index;\n\trxp = port->rxpos;\n\tdmabits = FST_RDB(card, rxDescrRing[pi][rxp].bits);\n\tif (dmabits & DMA_OWN) {\n\t\tdbg(DBG_RX | DBG_INTR, \"intr_rx: No buffer port %d pos %d\\n\",\n\t\t    pi, rxp);\n\t\treturn;\n\t}\n\tif (card->dmarx_in_progress)\n\t\treturn;\n\n\t \n\tlen = FST_RDW(card, rxDescrRing[pi][rxp].mcnt);\n\t \n\tlen -= 2;\n\tif (len == 0) {\n\t\t \n\t\tpr_err(\"Frame received with 0 length. Card %d Port %d\\n\",\n\t\t       card->card_no, port->index);\n\t\t \n\t\tFST_WRB(card, rxDescrRing[pi][rxp].bits, DMA_OWN);\n\n\t\trxp = (rxp + 1) % NUM_RX_BUFFER;\n\t\tport->rxpos = rxp;\n\t\treturn;\n\t}\n\n\t \n\tdbg(DBG_RX, \"intr_rx: %d,%d: flags %x len %d\\n\", pi, rxp, dmabits, len);\n\tif (dmabits != (RX_STP | RX_ENP) || len > LEN_RX_BUFFER - 2) {\n\t\tfst_log_rx_error(card, port, dmabits, rxp, len);\n\t\tfst_recover_rx_error(card, port, dmabits, rxp, len);\n\t\treturn;\n\t}\n\n\t \n\tskb = dev_alloc_skb(len);\n\tif (!skb) {\n\t\tdbg(DBG_RX, \"intr_rx: can't allocate buffer\\n\");\n\n\t\tdev->stats.rx_dropped++;\n\n\t\t \n\t\tFST_WRB(card, rxDescrRing[pi][rxp].bits, DMA_OWN);\n\n\t\trxp = (rxp + 1) % NUM_RX_BUFFER;\n\t\tport->rxpos = rxp;\n\t\treturn;\n\t}\n\n\t \n\n\tif (len < FST_MIN_DMA_LEN || card->family == FST_FAMILY_TXP) {\n\t\tmemcpy_fromio(skb_put(skb, len),\n\t\t\t      card->mem + BUF_OFFSET(rxBuffer[pi][rxp][0]),\n\t\t\t      len);\n\n\t\t \n\t\tFST_WRB(card, rxDescrRing[pi][rxp].bits, DMA_OWN);\n\n\t\t \n\t\tdev->stats.rx_packets++;\n\t\tdev->stats.rx_bytes += len;\n\n\t\t \n\t\tdbg(DBG_RX, \"Pushing frame up the stack\\n\");\n\t\tif (port->mode == FST_RAW)\n\t\t\tskb->protocol = farsync_type_trans(skb, dev);\n\t\telse\n\t\t\tskb->protocol = hdlc_type_trans(skb, dev);\n\t\trx_status = netif_rx(skb);\n\t\tfst_process_rx_status(rx_status, port_to_dev(port)->name);\n\t\tif (rx_status == NET_RX_DROP)\n\t\t\tdev->stats.rx_dropped++;\n\t} else {\n\t\tcard->dma_skb_rx = skb;\n\t\tcard->dma_port_rx = port;\n\t\tcard->dma_len_rx = len;\n\t\tcard->dma_rxpos = rxp;\n\t\tfst_rx_dma(card, card->rx_dma_handle_card,\n\t\t\t   BUF_OFFSET(rxBuffer[pi][rxp][0]), len);\n\t}\n\tif (rxp != port->rxpos) {\n\t\tdbg(DBG_ASS, \"About to increment rxpos by more than 1\\n\");\n\t\tdbg(DBG_ASS, \"rxp = %d rxpos = %d\\n\", rxp, port->rxpos);\n\t}\n\trxp = (rxp + 1) % NUM_RX_BUFFER;\n\tport->rxpos = rxp;\n}\n\n \n\nstatic void\ndo_bottom_half_tx(struct fst_card_info *card)\n{\n\tstruct fst_port_info *port;\n\tint pi;\n\tint txq_length;\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\tstruct net_device *dev;\n\n\t \n\n\tdbg(DBG_TX, \"do_bottom_half_tx\\n\");\n\tfor (pi = 0, port = card->ports; pi < card->nports; pi++, port++) {\n\t\tif (!port->run)\n\t\t\tcontinue;\n\n\t\tdev = port_to_dev(port);\n\t\twhile (!(FST_RDB(card, txDescrRing[pi][port->txpos].bits) &\n\t\t\t DMA_OWN) &&\n\t\t       !(card->dmatx_in_progress)) {\n\t\t\t \n\t\t\tspin_lock_irqsave(&card->card_lock, flags);\n\t\t\ttxq_length = port->txqe - port->txqs;\n\t\t\tif (txq_length < 0) {\n\t\t\t\t \n\t\t\t\ttxq_length = txq_length + FST_TXQ_DEPTH;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&card->card_lock, flags);\n\t\t\tif (txq_length > 0) {\n\t\t\t\t \n\t\t\t\tspin_lock_irqsave(&card->card_lock, flags);\n\t\t\t\tskb = port->txq[port->txqs];\n\t\t\t\tport->txqs++;\n\t\t\t\tif (port->txqs == FST_TXQ_DEPTH)\n\t\t\t\t\tport->txqs = 0;\n\n\t\t\t\tspin_unlock_irqrestore(&card->card_lock, flags);\n\t\t\t\t \n\t\t\t\tFST_WRW(card, txDescrRing[pi][port->txpos].bcnt,\n\t\t\t\t\tcnv_bcnt(skb->len));\n\t\t\t\tif (skb->len < FST_MIN_DMA_LEN ||\n\t\t\t\t    card->family == FST_FAMILY_TXP) {\n\t\t\t\t\t \n\t\t\t\t\tmemcpy_toio(card->mem +\n\t\t\t\t\t\t    BUF_OFFSET(txBuffer[pi]\n\t\t\t\t\t\t\t       [port->\n\t\t\t\t\t\t\t\ttxpos][0]),\n\t\t\t\t\t\t    skb->data, skb->len);\n\t\t\t\t\tFST_WRB(card,\n\t\t\t\t\t\ttxDescrRing[pi][port->txpos].\n\t\t\t\t\t\tbits,\n\t\t\t\t\t\tDMA_OWN | TX_STP | TX_ENP);\n\t\t\t\t\tdev->stats.tx_packets++;\n\t\t\t\t\tdev->stats.tx_bytes += skb->len;\n\t\t\t\t\tnetif_trans_update(dev);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tmemcpy(card->tx_dma_handle_host,\n\t\t\t\t\t       skb->data, skb->len);\n\t\t\t\t\tcard->dma_port_tx = port;\n\t\t\t\t\tcard->dma_len_tx = skb->len;\n\t\t\t\t\tcard->dma_txpos = port->txpos;\n\t\t\t\t\tfst_tx_dma(card,\n\t\t\t\t\t\t   card->tx_dma_handle_card,\n\t\t\t\t\t\t   BUF_OFFSET(txBuffer[pi]\n\t\t\t\t\t\t\t      [port->txpos][0]),\n\t\t\t\t\t\t   skb->len);\n\t\t\t\t}\n\t\t\t\tif (++port->txpos >= NUM_TX_BUFFER)\n\t\t\t\t\tport->txpos = 0;\n\t\t\t\t \n\t\t\t\tif (port->start) {\n\t\t\t\t\tif (txq_length < fst_txq_low) {\n\t\t\t\t\t\tnetif_wake_queue(port_to_dev\n\t\t\t\t\t\t\t\t (port));\n\t\t\t\t\t\tport->start = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void\ndo_bottom_half_rx(struct fst_card_info *card)\n{\n\tstruct fst_port_info *port;\n\tint pi;\n\tint rx_count = 0;\n\n\t \n\tdbg(DBG_RX, \"do_bottom_half_rx\\n\");\n\tfor (pi = 0, port = card->ports; pi < card->nports; pi++, port++) {\n\t\tif (!port->run)\n\t\t\tcontinue;\n\n\t\twhile (!(FST_RDB(card, rxDescrRing[pi][port->rxpos].bits)\n\t\t\t & DMA_OWN) && !(card->dmarx_in_progress)) {\n\t\t\tif (rx_count > fst_max_reads) {\n\t\t\t\t \n\t\t\t\tfst_q_work_item(&fst_work_intq, card->card_no);\n\t\t\t\ttasklet_schedule(&fst_int_task);\n\t\t\t\tbreak;\t \n\t\t\t}\n\t\t\tfst_intr_rx(card, port);\n\t\t\trx_count++;\n\t\t}\n\t}\n}\n\n \nstatic irqreturn_t\nfst_intr(int dummy, void *dev_id)\n{\n\tstruct fst_card_info *card = dev_id;\n\tstruct fst_port_info *port;\n\tint rdidx;\t\t \n\tint wridx;\n\tint event;\t\t \n\tunsigned int dma_intcsr = 0;\n\tunsigned int do_card_interrupt;\n\tunsigned int int_retry_count;\n\n\t \n\tdbg(DBG_INTR, \"intr: %d %p\\n\", card->irq, card);\n\tif (card->state != FST_RUNNING) {\n\t\tpr_err(\"Interrupt received for card %d in a non running state (%d)\\n\",\n\t\t       card->card_no, card->state);\n\n\t\t \n\t\tfst_clear_intr(card);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tfst_clear_intr(card);\n\n\t \n\tdo_card_interrupt = 0;\n\tif (FST_RDB(card, interruptHandshake) == 1) {\n\t\tdo_card_interrupt += FST_CARD_INT;\n\t\t \n\t\tFST_WRB(card, interruptHandshake, 0xEE);\n\t}\n\tif (card->family == FST_FAMILY_TXU) {\n\t\t \n\t\tdma_intcsr = inl(card->pci_conf + INTCSR_9054);\n\t\tif (dma_intcsr & 0x00200000) {\n\t\t\t \n\t\t\tdbg(DBG_RX, \"DMA Rx xfer complete\\n\");\n\t\t\toutb(0x8, card->pci_conf + DMACSR0);\n\t\t\tfst_rx_dma_complete(card, card->dma_port_rx,\n\t\t\t\t\t    card->dma_len_rx, card->dma_skb_rx,\n\t\t\t\t\t    card->dma_rxpos);\n\t\t\tcard->dmarx_in_progress = 0;\n\t\t\tdo_card_interrupt += FST_RX_DMA_INT;\n\t\t}\n\t\tif (dma_intcsr & 0x00400000) {\n\t\t\t \n\t\t\tdbg(DBG_TX, \"DMA Tx xfer complete\\n\");\n\t\t\toutb(0x8, card->pci_conf + DMACSR1);\n\t\t\tfst_tx_dma_complete(card, card->dma_port_tx,\n\t\t\t\t\t    card->dma_len_tx, card->dma_txpos);\n\t\t\tcard->dmatx_in_progress = 0;\n\t\t\tdo_card_interrupt += FST_TX_DMA_INT;\n\t\t}\n\t}\n\n\t \n\tint_retry_count = FST_RDL(card, interruptRetryCount);\n\tif (int_retry_count) {\n\t\tdbg(DBG_ASS, \"Card %d int_retry_count is  %d\\n\",\n\t\t    card->card_no, int_retry_count);\n\t\tFST_WRL(card, interruptRetryCount, 0);\n\t}\n\n\tif (!do_card_interrupt)\n\t\treturn IRQ_HANDLED;\n\n\t \n\tfst_q_work_item(&fst_work_intq, card->card_no);\n\ttasklet_schedule(&fst_int_task);\n\n\t \n\trdidx = FST_RDB(card, interruptEvent.rdindex) & 0x1f;\n\twridx = FST_RDB(card, interruptEvent.wrindex) & 0x1f;\n\twhile (rdidx != wridx) {\n\t\tevent = FST_RDB(card, interruptEvent.evntbuff[rdidx]);\n\t\tport = &card->ports[event & 0x03];\n\n\t\tdbg(DBG_INTR, \"Processing Interrupt event: %x\\n\", event);\n\n\t\tswitch (event) {\n\t\tcase TE1_ALMA:\n\t\t\tdbg(DBG_INTR, \"TE1 Alarm intr\\n\");\n\t\t\tif (port->run)\n\t\t\t\tfst_intr_te1_alarm(card, port);\n\t\t\tbreak;\n\n\t\tcase CTLA_CHG:\n\t\tcase CTLB_CHG:\n\t\tcase CTLC_CHG:\n\t\tcase CTLD_CHG:\n\t\t\tif (port->run)\n\t\t\t\tfst_intr_ctlchg(card, port);\n\t\t\tbreak;\n\n\t\tcase ABTA_SENT:\n\t\tcase ABTB_SENT:\n\t\tcase ABTC_SENT:\n\t\tcase ABTD_SENT:\n\t\t\tdbg(DBG_TX, \"Abort complete port %d\\n\", port->index);\n\t\t\tbreak;\n\n\t\tcase TXA_UNDF:\n\t\tcase TXB_UNDF:\n\t\tcase TXC_UNDF:\n\t\tcase TXD_UNDF:\n\t\t\t \n\t\t\tdbg(DBG_TX, \"Tx underflow port %d\\n\", port->index);\n\t\t\tport_to_dev(port)->stats.tx_errors++;\n\t\t\tport_to_dev(port)->stats.tx_fifo_errors++;\n\t\t\tdbg(DBG_ASS, \"Tx underflow on card %d port %d\\n\",\n\t\t\t    card->card_no, port->index);\n\t\t\tbreak;\n\n\t\tcase INIT_CPLT:\n\t\t\tdbg(DBG_INIT, \"Card init OK intr\\n\");\n\t\t\tbreak;\n\n\t\tcase INIT_FAIL:\n\t\t\tdbg(DBG_INIT, \"Card init FAILED intr\\n\");\n\t\t\tcard->state = FST_IFAILED;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err(\"intr: unknown card event %d. ignored\\n\", event);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (++rdidx >= MAX_CIRBUFF)\n\t\t\trdidx = 0;\n\t}\n\tFST_WRB(card, interruptEvent.rdindex, rdidx);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void\ncheck_started_ok(struct fst_card_info *card)\n{\n\tint i;\n\n\t \n\tif (FST_RDW(card, smcVersion) != SMC_VERSION) {\n\t\tpr_err(\"Bad shared memory version %d expected %d\\n\",\n\t\t       FST_RDW(card, smcVersion), SMC_VERSION);\n\t\tcard->state = FST_BADVERSION;\n\t\treturn;\n\t}\n\tif (FST_RDL(card, endOfSmcSignature) != END_SIG) {\n\t\tpr_err(\"Missing shared memory signature\\n\");\n\t\tcard->state = FST_BADVERSION;\n\t\treturn;\n\t}\n\t \n\ti = FST_RDB(card, taskStatus);\n\tif (i == 0x01) {\n\t\tcard->state = FST_RUNNING;\n\t} else if (i == 0xFF) {\n\t\tpr_err(\"Firmware initialisation failed. Card halted\\n\");\n\t\tcard->state = FST_HALTED;\n\t\treturn;\n\t} else if (i != 0x00) {\n\t\tpr_err(\"Unknown firmware status 0x%x\\n\", i);\n\t\tcard->state = FST_HALTED;\n\t\treturn;\n\t}\n\n\t \n\tif (FST_RDL(card, numberOfPorts) != card->nports) {\n\t\tpr_warn(\"Port count mismatch on card %d.  Firmware thinks %d we say %d\\n\",\n\t\t\tcard->card_no,\n\t\t\tFST_RDL(card, numberOfPorts), card->nports);\n\t}\n}\n\nstatic int\nset_conf_from_info(struct fst_card_info *card, struct fst_port_info *port,\n\t\t   struct fstioc_info *info)\n{\n\tint err;\n\tunsigned char my_framing;\n\n\t \n\terr = 0;\n\tif (info->valid & FSTVAL_PROTO) {\n\t\tif (info->proto == FST_RAW)\n\t\t\tport->mode = FST_RAW;\n\t\telse\n\t\t\tport->mode = FST_GEN_HDLC;\n\t}\n\n\tif (info->valid & FSTVAL_CABLE)\n\t\terr = -EINVAL;\n\n\tif (info->valid & FSTVAL_SPEED)\n\t\terr = -EINVAL;\n\n\tif (info->valid & FSTVAL_PHASE)\n\t\tFST_WRB(card, portConfig[port->index].invertClock,\n\t\t\tinfo->invertClock);\n\tif (info->valid & FSTVAL_MODE)\n\t\tFST_WRW(card, cardMode, info->cardMode);\n\tif (info->valid & FSTVAL_TE1) {\n\t\tFST_WRL(card, suConfig.dataRate, info->lineSpeed);\n\t\tFST_WRB(card, suConfig.clocking, info->clockSource);\n\t\tmy_framing = FRAMING_E1;\n\t\tif (info->framing == E1)\n\t\t\tmy_framing = FRAMING_E1;\n\t\tif (info->framing == T1)\n\t\t\tmy_framing = FRAMING_T1;\n\t\tif (info->framing == J1)\n\t\t\tmy_framing = FRAMING_J1;\n\t\tFST_WRB(card, suConfig.framing, my_framing);\n\t\tFST_WRB(card, suConfig.structure, info->structure);\n\t\tFST_WRB(card, suConfig.interface, info->interface);\n\t\tFST_WRB(card, suConfig.coding, info->coding);\n\t\tFST_WRB(card, suConfig.lineBuildOut, info->lineBuildOut);\n\t\tFST_WRB(card, suConfig.equalizer, info->equalizer);\n\t\tFST_WRB(card, suConfig.transparentMode, info->transparentMode);\n\t\tFST_WRB(card, suConfig.loopMode, info->loopMode);\n\t\tFST_WRB(card, suConfig.range, info->range);\n\t\tFST_WRB(card, suConfig.txBufferMode, info->txBufferMode);\n\t\tFST_WRB(card, suConfig.rxBufferMode, info->rxBufferMode);\n\t\tFST_WRB(card, suConfig.startingSlot, info->startingSlot);\n\t\tFST_WRB(card, suConfig.losThreshold, info->losThreshold);\n\t\tif (info->idleCode)\n\t\t\tFST_WRB(card, suConfig.enableIdleCode, 1);\n\t\telse\n\t\t\tFST_WRB(card, suConfig.enableIdleCode, 0);\n\t\tFST_WRB(card, suConfig.idleCode, info->idleCode);\n#if FST_DEBUG\n\t\tif (info->valid & FSTVAL_TE1) {\n\t\t\tprintk(\"Setting TE1 data\\n\");\n\t\t\tprintk(\"Line Speed = %d\\n\", info->lineSpeed);\n\t\t\tprintk(\"Start slot = %d\\n\", info->startingSlot);\n\t\t\tprintk(\"Clock source = %d\\n\", info->clockSource);\n\t\t\tprintk(\"Framing = %d\\n\", my_framing);\n\t\t\tprintk(\"Structure = %d\\n\", info->structure);\n\t\t\tprintk(\"interface = %d\\n\", info->interface);\n\t\t\tprintk(\"Coding = %d\\n\", info->coding);\n\t\t\tprintk(\"Line build out = %d\\n\", info->lineBuildOut);\n\t\t\tprintk(\"Equaliser = %d\\n\", info->equalizer);\n\t\t\tprintk(\"Transparent mode = %d\\n\",\n\t\t\t       info->transparentMode);\n\t\t\tprintk(\"Loop mode = %d\\n\", info->loopMode);\n\t\t\tprintk(\"Range = %d\\n\", info->range);\n\t\t\tprintk(\"Tx Buffer mode = %d\\n\", info->txBufferMode);\n\t\t\tprintk(\"Rx Buffer mode = %d\\n\", info->rxBufferMode);\n\t\t\tprintk(\"LOS Threshold = %d\\n\", info->losThreshold);\n\t\t\tprintk(\"Idle Code = %d\\n\", info->idleCode);\n\t\t}\n#endif\n\t}\n#if FST_DEBUG\n\tif (info->valid & FSTVAL_DEBUG)\n\t\tfst_debug_mask = info->debug;\n#endif\n\n\treturn err;\n}\n\nstatic void\ngather_conf_info(struct fst_card_info *card, struct fst_port_info *port,\n\t\t struct fstioc_info *info)\n{\n\tint i;\n\n\tmemset(info, 0, sizeof(struct fstioc_info));\n\n\ti = port->index;\n\tinfo->kernelVersion = LINUX_VERSION_CODE;\n\tinfo->nports = card->nports;\n\tinfo->type = card->type;\n\tinfo->state = card->state;\n\tinfo->proto = FST_GEN_HDLC;\n\tinfo->index = i;\n#if FST_DEBUG\n\tinfo->debug = fst_debug_mask;\n#endif\n\n\t \n\tinfo->valid = ((card->state == FST_RUNNING) ? FSTVAL_ALL : FSTVAL_CARD)\n#if FST_DEBUG\n\t    | FSTVAL_DEBUG\n#endif\n\t    ;\n\n\tinfo->lineInterface = FST_RDW(card, portConfig[i].lineInterface);\n\tinfo->internalClock = FST_RDB(card, portConfig[i].internalClock);\n\tinfo->lineSpeed = FST_RDL(card, portConfig[i].lineSpeed);\n\tinfo->invertClock = FST_RDB(card, portConfig[i].invertClock);\n\tinfo->v24IpSts = FST_RDL(card, v24IpSts[i]);\n\tinfo->v24OpSts = FST_RDL(card, v24OpSts[i]);\n\tinfo->clockStatus = FST_RDW(card, clockStatus[i]);\n\tinfo->cableStatus = FST_RDW(card, cableStatus);\n\tinfo->cardMode = FST_RDW(card, cardMode);\n\tinfo->smcFirmwareVersion = FST_RDL(card, smcFirmwareVersion);\n\n\t \n\tif (card->family == FST_FAMILY_TXU) {\n\t\tif (port->index == 0) {\n\t\t\t \n\t\t\tinfo->cableStatus = info->cableStatus & 1;\n\t\t} else {\n\t\t\t \n\t\t\tinfo->cableStatus = info->cableStatus >> 1;\n\t\t\tinfo->cableStatus = info->cableStatus & 1;\n\t\t}\n\t}\n\t \n\tif (card->type == FST_TYPE_TE1) {\n\t\tinfo->lineSpeed = FST_RDL(card, suConfig.dataRate);\n\t\tinfo->clockSource = FST_RDB(card, suConfig.clocking);\n\t\tinfo->framing = FST_RDB(card, suConfig.framing);\n\t\tinfo->structure = FST_RDB(card, suConfig.structure);\n\t\tinfo->interface = FST_RDB(card, suConfig.interface);\n\t\tinfo->coding = FST_RDB(card, suConfig.coding);\n\t\tinfo->lineBuildOut = FST_RDB(card, suConfig.lineBuildOut);\n\t\tinfo->equalizer = FST_RDB(card, suConfig.equalizer);\n\t\tinfo->loopMode = FST_RDB(card, suConfig.loopMode);\n\t\tinfo->range = FST_RDB(card, suConfig.range);\n\t\tinfo->txBufferMode = FST_RDB(card, suConfig.txBufferMode);\n\t\tinfo->rxBufferMode = FST_RDB(card, suConfig.rxBufferMode);\n\t\tinfo->startingSlot = FST_RDB(card, suConfig.startingSlot);\n\t\tinfo->losThreshold = FST_RDB(card, suConfig.losThreshold);\n\t\tif (FST_RDB(card, suConfig.enableIdleCode))\n\t\t\tinfo->idleCode = FST_RDB(card, suConfig.idleCode);\n\t\telse\n\t\t\tinfo->idleCode = 0;\n\t\tinfo->receiveBufferDelay =\n\t\t    FST_RDL(card, suStatus.receiveBufferDelay);\n\t\tinfo->framingErrorCount =\n\t\t    FST_RDL(card, suStatus.framingErrorCount);\n\t\tinfo->codeViolationCount =\n\t\t    FST_RDL(card, suStatus.codeViolationCount);\n\t\tinfo->crcErrorCount = FST_RDL(card, suStatus.crcErrorCount);\n\t\tinfo->lineAttenuation = FST_RDL(card, suStatus.lineAttenuation);\n\t\tinfo->lossOfSignal = FST_RDB(card, suStatus.lossOfSignal);\n\t\tinfo->receiveRemoteAlarm =\n\t\t    FST_RDB(card, suStatus.receiveRemoteAlarm);\n\t\tinfo->alarmIndicationSignal =\n\t\t    FST_RDB(card, suStatus.alarmIndicationSignal);\n\t}\n}\n\nstatic int\nfst_set_iface(struct fst_card_info *card, struct fst_port_info *port,\n\t      struct if_settings *ifs)\n{\n\tsync_serial_settings sync;\n\tint i;\n\n\tif (ifs->size != sizeof(sync))\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(&sync, ifs->ifs_ifsu.sync, sizeof(sync)))\n\t\treturn -EFAULT;\n\n\tif (sync.loopback)\n\t\treturn -EINVAL;\n\n\ti = port->index;\n\n\tswitch (ifs->type) {\n\tcase IF_IFACE_V35:\n\t\tFST_WRW(card, portConfig[i].lineInterface, V35);\n\t\tport->hwif = V35;\n\t\tbreak;\n\n\tcase IF_IFACE_V24:\n\t\tFST_WRW(card, portConfig[i].lineInterface, V24);\n\t\tport->hwif = V24;\n\t\tbreak;\n\n\tcase IF_IFACE_X21:\n\t\tFST_WRW(card, portConfig[i].lineInterface, X21);\n\t\tport->hwif = X21;\n\t\tbreak;\n\n\tcase IF_IFACE_X21D:\n\t\tFST_WRW(card, portConfig[i].lineInterface, X21D);\n\t\tport->hwif = X21D;\n\t\tbreak;\n\n\tcase IF_IFACE_T1:\n\t\tFST_WRW(card, portConfig[i].lineInterface, T1);\n\t\tport->hwif = T1;\n\t\tbreak;\n\n\tcase IF_IFACE_E1:\n\t\tFST_WRW(card, portConfig[i].lineInterface, E1);\n\t\tport->hwif = E1;\n\t\tbreak;\n\n\tcase IF_IFACE_SYNC_SERIAL:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (sync.clock_type) {\n\tcase CLOCK_EXT:\n\t\tFST_WRB(card, portConfig[i].internalClock, EXTCLK);\n\t\tbreak;\n\n\tcase CLOCK_INT:\n\t\tFST_WRB(card, portConfig[i].internalClock, INTCLK);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tFST_WRL(card, portConfig[i].lineSpeed, sync.clock_rate);\n\treturn 0;\n}\n\nstatic int\nfst_get_iface(struct fst_card_info *card, struct fst_port_info *port,\n\t      struct if_settings *ifs)\n{\n\tsync_serial_settings sync;\n\tint i;\n\n\t \n\tswitch (port->hwif) {\n\tcase E1:\n\t\tifs->type = IF_IFACE_E1;\n\t\tbreak;\n\tcase T1:\n\t\tifs->type = IF_IFACE_T1;\n\t\tbreak;\n\tcase V35:\n\t\tifs->type = IF_IFACE_V35;\n\t\tbreak;\n\tcase V24:\n\t\tifs->type = IF_IFACE_V24;\n\t\tbreak;\n\tcase X21D:\n\t\tifs->type = IF_IFACE_X21D;\n\t\tbreak;\n\tcase X21:\n\tdefault:\n\t\tifs->type = IF_IFACE_X21;\n\t\tbreak;\n\t}\n\tif (!ifs->size)\n\t\treturn 0;\t \n\n\tif (ifs->size < sizeof(sync))\n\t\treturn -ENOMEM;\n\n\ti = port->index;\n\tmemset(&sync, 0, sizeof(sync));\n\tsync.clock_rate = FST_RDL(card, portConfig[i].lineSpeed);\n\t \n\tsync.clock_type = FST_RDB(card, portConfig[i].internalClock) ==\n\t    INTCLK ? CLOCK_INT : CLOCK_EXT;\n\tsync.loopback = 0;\n\n\tif (copy_to_user(ifs->ifs_ifsu.sync, &sync, sizeof(sync)))\n\t\treturn -EFAULT;\n\n\tifs->size = sizeof(sync);\n\treturn 0;\n}\n\nstatic int\nfst_siocdevprivate(struct net_device *dev, struct ifreq *ifr, void __user *data, int cmd)\n{\n\tstruct fst_card_info *card;\n\tstruct fst_port_info *port;\n\tstruct fstioc_write wrthdr;\n\tstruct fstioc_info info;\n\tunsigned long flags;\n\tvoid *buf;\n\n\tdbg(DBG_IOCTL, \"ioctl: %x, %p\\n\", cmd, data);\n\n\tport = dev_to_port(dev);\n\tcard = port->card;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (cmd) {\n\tcase FSTCPURESET:\n\t\tfst_cpureset(card);\n\t\tcard->state = FST_RESET;\n\t\treturn 0;\n\n\tcase FSTCPURELEASE:\n\t\tfst_cpurelease(card);\n\t\tcard->state = FST_STARTING;\n\t\treturn 0;\n\n\tcase FSTWRITE:\t\t \n\n\t\t \n\t\tif (!data)\n\t\t\treturn -EINVAL;\n\n\t\tif (copy_from_user(&wrthdr, data, sizeof(struct fstioc_write)))\n\t\t\treturn -EFAULT;\n\n\t\t \n\t\tif (wrthdr.size > FST_MEMSIZE || wrthdr.offset > FST_MEMSIZE ||\n\t\t    wrthdr.size + wrthdr.offset > FST_MEMSIZE)\n\t\t\treturn -ENXIO;\n\n\t\t \n\n\t\tbuf = memdup_user(data + sizeof(struct fstioc_write),\n\t\t\t\t  wrthdr.size);\n\t\tif (IS_ERR(buf))\n\t\t\treturn PTR_ERR(buf);\n\n\t\tmemcpy_toio(card->mem + wrthdr.offset, buf, wrthdr.size);\n\t\tkfree(buf);\n\n\t\t \n\t\tif (card->state == FST_RESET)\n\t\t\tcard->state = FST_DOWNLOAD;\n\n\t\treturn 0;\n\n\tcase FSTGETCONF:\n\n\t\t \n\t\tif (card->state == FST_STARTING) {\n\t\t\tcheck_started_ok(card);\n\n\t\t\t \n\t\t\tif (card->state == FST_RUNNING) {\n\t\t\t\tspin_lock_irqsave(&card->card_lock, flags);\n\t\t\t\tfst_enable_intr(card);\n\t\t\t\tFST_WRB(card, interruptHandshake, 0xEE);\n\t\t\t\tspin_unlock_irqrestore(&card->card_lock, flags);\n\t\t\t}\n\t\t}\n\n\t\tif (!data)\n\t\t\treturn -EINVAL;\n\n\t\tgather_conf_info(card, port, &info);\n\n\t\tif (copy_to_user(data, &info, sizeof(info)))\n\t\t\treturn -EFAULT;\n\n\t\treturn 0;\n\n\tcase FSTSETCONF:\n\t\t \n\n\t\tif (card->state != FST_RUNNING) {\n\t\t\tpr_err(\"Attempt to configure card %d in non-running state (%d)\\n\",\n\t\t\t       card->card_no, card->state);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (copy_from_user(&info, data, sizeof(info)))\n\t\t\treturn -EFAULT;\n\n\t\treturn set_conf_from_info(card, port, &info);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int\nfst_ioctl(struct net_device *dev, struct if_settings *ifs)\n{\n\tstruct fst_card_info *card;\n\tstruct fst_port_info *port;\n\n\tdbg(DBG_IOCTL, \"SIOCDEVPRIVATE, %x\\n\", ifs->type);\n\n\tport = dev_to_port(dev);\n\tcard = port->card;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch (ifs->type) {\n\tcase IF_GET_IFACE:\n\t\treturn fst_get_iface(card, port, ifs);\n\n\tcase IF_IFACE_SYNC_SERIAL:\n\tcase IF_IFACE_V35:\n\tcase IF_IFACE_V24:\n\tcase IF_IFACE_X21:\n\tcase IF_IFACE_X21D:\n\tcase IF_IFACE_T1:\n\tcase IF_IFACE_E1:\n\t\treturn fst_set_iface(card, port, ifs);\n\n\tcase IF_PROTO_RAW:\n\t\tport->mode = FST_RAW;\n\t\treturn 0;\n\n\tcase IF_GET_PROTO:\n\t\tif (port->mode == FST_RAW) {\n\t\t\tifs->type = IF_PROTO_RAW;\n\t\t\treturn 0;\n\t\t}\n\t\treturn hdlc_ioctl(dev, ifs);\n\n\tdefault:\n\t\tport->mode = FST_GEN_HDLC;\n\t\tdbg(DBG_IOCTL, \"Passing this type to hdlc %x\\n\",\n\t\t    ifs->type);\n\t\treturn hdlc_ioctl(dev, ifs);\n\t}\n}\n\nstatic void\nfst_openport(struct fst_port_info *port)\n{\n\tint signals;\n\n\t \n\tif (port->card->state == FST_RUNNING) {\n\t\tif (port->run) {\n\t\t\tdbg(DBG_OPEN, \"open: found port already running\\n\");\n\n\t\t\tfst_issue_cmd(port, STOPPORT);\n\t\t\tport->run = 0;\n\t\t}\n\n\t\tfst_rx_config(port);\n\t\tfst_tx_config(port);\n\t\tfst_op_raise(port, OPSTS_RTS | OPSTS_DTR);\n\n\t\tfst_issue_cmd(port, STARTPORT);\n\t\tport->run = 1;\n\n\t\tsignals = FST_RDL(port->card, v24DebouncedSts[port->index]);\n\t\tif (signals & ((port->hwif == X21 || port->hwif == X21D)\n\t\t\t       ? IPSTS_INDICATE : IPSTS_DCD))\n\t\t\tnetif_carrier_on(port_to_dev(port));\n\t\telse\n\t\t\tnetif_carrier_off(port_to_dev(port));\n\n\t\tport->txqe = 0;\n\t\tport->txqs = 0;\n\t}\n}\n\nstatic void\nfst_closeport(struct fst_port_info *port)\n{\n\tif (port->card->state == FST_RUNNING) {\n\t\tif (port->run) {\n\t\t\tport->run = 0;\n\t\t\tfst_op_lower(port, OPSTS_RTS | OPSTS_DTR);\n\n\t\t\tfst_issue_cmd(port, STOPPORT);\n\t\t} else {\n\t\t\tdbg(DBG_OPEN, \"close: port not running\\n\");\n\t\t}\n\t}\n}\n\nstatic int\nfst_open(struct net_device *dev)\n{\n\tint err;\n\tstruct fst_port_info *port;\n\n\tport = dev_to_port(dev);\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn -EBUSY;\n\n\tif (port->mode != FST_RAW) {\n\t\terr = hdlc_open(dev);\n\t\tif (err) {\n\t\t\tmodule_put(THIS_MODULE);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tfst_openport(port);\n\tnetif_wake_queue(dev);\n\treturn 0;\n}\n\nstatic int\nfst_close(struct net_device *dev)\n{\n\tstruct fst_port_info *port;\n\tstruct fst_card_info *card;\n\tunsigned char tx_dma_done;\n\tunsigned char rx_dma_done;\n\n\tport = dev_to_port(dev);\n\tcard = port->card;\n\n\ttx_dma_done = inb(card->pci_conf + DMACSR1);\n\trx_dma_done = inb(card->pci_conf + DMACSR0);\n\tdbg(DBG_OPEN,\n\t    \"Port Close: tx_dma_in_progress = %d (%x) rx_dma_in_progress = %d (%x)\\n\",\n\t    card->dmatx_in_progress, tx_dma_done, card->dmarx_in_progress,\n\t    rx_dma_done);\n\n\tnetif_stop_queue(dev);\n\tfst_closeport(dev_to_port(dev));\n\tif (port->mode != FST_RAW)\n\t\thdlc_close(dev);\n\n\tmodule_put(THIS_MODULE);\n\treturn 0;\n}\n\nstatic int\nfst_attach(struct net_device *dev, unsigned short encoding, unsigned short parity)\n{\n\t \n\tif (encoding != ENCODING_NRZ || parity != PARITY_CRC16_PR1_CCITT)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic void\nfst_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct fst_port_info *port;\n\tstruct fst_card_info *card;\n\n\tport = dev_to_port(dev);\n\tcard = port->card;\n\tdev->stats.tx_errors++;\n\tdev->stats.tx_aborted_errors++;\n\tdbg(DBG_ASS, \"Tx timeout card %d port %d\\n\",\n\t    card->card_no, port->index);\n\tfst_issue_cmd(port, ABORTTX);\n\n\tnetif_trans_update(dev);\n\tnetif_wake_queue(dev);\n\tport->start = 0;\n}\n\nstatic netdev_tx_t\nfst_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct fst_card_info *card;\n\tstruct fst_port_info *port;\n\tunsigned long flags;\n\tint txq_length;\n\n\tport = dev_to_port(dev);\n\tcard = port->card;\n\tdbg(DBG_TX, \"fst_start_xmit: length = %d\\n\", skb->len);\n\n\t \n\tif (!netif_carrier_ok(dev)) {\n\t\tdev_kfree_skb(skb);\n\t\tdev->stats.tx_errors++;\n\t\tdev->stats.tx_carrier_errors++;\n\t\tdbg(DBG_ASS,\n\t\t    \"Tried to transmit but no carrier on card %d port %d\\n\",\n\t\t    card->card_no, port->index);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t \n\tif (skb->len > LEN_TX_BUFFER) {\n\t\tdbg(DBG_ASS, \"Packet too large %d vs %d\\n\", skb->len,\n\t\t    LEN_TX_BUFFER);\n\t\tdev_kfree_skb(skb);\n\t\tdev->stats.tx_errors++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t \n\tspin_lock_irqsave(&card->card_lock, flags);\n\ttxq_length = port->txqe - port->txqs;\n\tif (txq_length < 0) {\n\t\t \n\t\ttxq_length = txq_length + FST_TXQ_DEPTH;\n\t}\n\tspin_unlock_irqrestore(&card->card_lock, flags);\n\tif (txq_length > fst_txq_high) {\n\t\t \n\t\tnetif_stop_queue(dev);\n\t\tport->start = 1;\t \n\t}\n\n\tif (txq_length == FST_TXQ_DEPTH - 1) {\n\t\t \n\t\tdev_kfree_skb(skb);\n\t\tdev->stats.tx_errors++;\n\t\tdbg(DBG_ASS, \"Tx queue overflow card %d port %d\\n\",\n\t\t    card->card_no, port->index);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t \n\tspin_lock_irqsave(&card->card_lock, flags);\n\tport->txq[port->txqe] = skb;\n\tport->txqe++;\n\tif (port->txqe == FST_TXQ_DEPTH)\n\t\tport->txqe = 0;\n\tspin_unlock_irqrestore(&card->card_lock, flags);\n\n\t \n\tfst_q_work_item(&fst_work_txq, card->card_no);\n\ttasklet_schedule(&fst_tx_task);\n\n\treturn NETDEV_TX_OK;\n}\n\n \nstatic char *type_strings[] = {\n\t\"no hardware\",\t\t \n\t\"FarSync T2P\",\n\t\"FarSync T4P\",\n\t\"FarSync T1U\",\n\t\"FarSync T2U\",\n\t\"FarSync T4U\",\n\t\"FarSync TE1\"\n};\n\nstatic int\nfst_init_card(struct fst_card_info *card)\n{\n\tint i;\n\tint err;\n\n\t \n\tfor (i = 0; i < card->nports; i++) {\n\t\terr = register_hdlc_device(card->ports[i].dev);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"Cannot register HDLC device for port %d (errno %d)\\n\",\n\t\t\t       i, -err);\n\t\t\twhile (i--)\n\t\t\t\tunregister_hdlc_device(card->ports[i].dev);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tpr_info(\"%s-%s: %s IRQ%d, %d ports\\n\",\n\t\tport_to_dev(&card->ports[0])->name,\n\t\tport_to_dev(&card->ports[card->nports - 1])->name,\n\t\ttype_strings[card->type], card->irq, card->nports);\n\treturn 0;\n}\n\nstatic const struct net_device_ops fst_ops = {\n\t.ndo_open       = fst_open,\n\t.ndo_stop       = fst_close,\n\t.ndo_start_xmit = hdlc_start_xmit,\n\t.ndo_siocwandev\t= fst_ioctl,\n\t.ndo_siocdevprivate = fst_siocdevprivate,\n\t.ndo_tx_timeout = fst_tx_timeout,\n};\n\n \nstatic int\nfst_add_one(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tstatic int no_of_cards_added;\n\tstruct fst_card_info *card;\n\tint err = 0;\n\tint i;\n\n\tprintk_once(KERN_INFO\n\t\t    pr_fmt(\"FarSync WAN driver \" FST_USER_VERSION\n\t\t\t   \" (c) 2001-2004 FarSite Communications Ltd.\\n\"));\n#if FST_DEBUG\n\tdbg(DBG_ASS, \"The value of debug mask is %x\\n\", fst_debug_mask);\n#endif\n\t \n\tif (fst_excluded_cards != 0) {\n\t\t \n\t\tfor (i = 0; i < fst_excluded_cards; i++) {\n\t\t\tif (pdev->devfn >> 3 == fst_excluded_list[i]) {\n\t\t\t\tpr_info(\"FarSync PCI device %d not assigned\\n\",\n\t\t\t\t\t(pdev->devfn) >> 3);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tcard = kzalloc(sizeof(struct fst_card_info), GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\n\t \n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tpr_err(\"Failed to enable card. Err %d\\n\", -err);\n\t\tgoto enable_fail;\n\t}\n\n\terr = pci_request_regions(pdev, \"FarSync\");\n\tif (err) {\n\t\tpr_err(\"Failed to allocate regions. Err %d\\n\", -err);\n\t\tgoto regions_fail;\n\t}\n\n\t \n\tcard->pci_conf = pci_resource_start(pdev, 1);\n\tcard->phys_mem = pci_resource_start(pdev, 2);\n\tcard->phys_ctlmem = pci_resource_start(pdev, 3);\n\tcard->mem = ioremap(card->phys_mem, FST_MEMSIZE);\n\tif (!card->mem) {\n\t\tpr_err(\"Physical memory remap failed\\n\");\n\t\terr = -ENODEV;\n\t\tgoto ioremap_physmem_fail;\n\t}\n\tcard->ctlmem = ioremap(card->phys_ctlmem, 0x10);\n\tif (!card->ctlmem) {\n\t\tpr_err(\"Control memory remap failed\\n\");\n\t\terr = -ENODEV;\n\t\tgoto ioremap_ctlmem_fail;\n\t}\n\tdbg(DBG_PCI, \"kernel mem %p, ctlmem %p\\n\", card->mem, card->ctlmem);\n\n\t \n\tif (request_irq(pdev->irq, fst_intr, IRQF_SHARED, FST_DEV_NAME, card)) {\n\t\tpr_err(\"Unable to register interrupt %d\\n\", card->irq);\n\t\terr = -ENODEV;\n\t\tgoto irq_fail;\n\t}\n\n\t \n\tcard->irq = pdev->irq;\n\tcard->type = ent->driver_data;\n\tcard->family = ((ent->driver_data == FST_TYPE_T2P) ||\n\t\t\t(ent->driver_data == FST_TYPE_T4P))\n\t    ? FST_FAMILY_TXP : FST_FAMILY_TXU;\n\tif (ent->driver_data == FST_TYPE_T1U ||\n\t    ent->driver_data == FST_TYPE_TE1)\n\t\tcard->nports = 1;\n\telse\n\t\tcard->nports = ((ent->driver_data == FST_TYPE_T2P) ||\n\t\t\t\t(ent->driver_data == FST_TYPE_T2U)) ? 2 : 4;\n\n\tcard->state = FST_UNINIT;\n\tspin_lock_init(&card->card_lock);\n\n\tfor (i = 0; i < card->nports; i++) {\n\t\tstruct net_device *dev = alloc_hdlcdev(&card->ports[i]);\n\t\thdlc_device *hdlc;\n\n\t\tif (!dev) {\n\t\t\twhile (i--)\n\t\t\t\tfree_netdev(card->ports[i].dev);\n\t\t\tpr_err(\"FarSync: out of memory\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto hdlcdev_fail;\n\t\t}\n\t\tcard->ports[i].dev    = dev;\n\t\tcard->ports[i].card   = card;\n\t\tcard->ports[i].index  = i;\n\t\tcard->ports[i].run    = 0;\n\n\t\thdlc = dev_to_hdlc(dev);\n\n\t\t \n\t\t \n\t\tdev->mem_start   = card->phys_mem\n\t\t\t\t+ BUF_OFFSET(txBuffer[i][0][0]);\n\t\tdev->mem_end     = card->phys_mem\n\t\t\t\t+ BUF_OFFSET(txBuffer[i][NUM_TX_BUFFER - 1][LEN_RX_BUFFER - 1]);\n\t\tdev->base_addr   = card->pci_conf;\n\t\tdev->irq         = card->irq;\n\n\t\tdev->netdev_ops = &fst_ops;\n\t\tdev->tx_queue_len = FST_TX_QUEUE_LEN;\n\t\tdev->watchdog_timeo = FST_TX_TIMEOUT;\n\t\thdlc->attach = fst_attach;\n\t\thdlc->xmit   = fst_start_xmit;\n\t}\n\n\tcard->device = pdev;\n\n\tdbg(DBG_PCI, \"type %d nports %d irq %d\\n\", card->type,\n\t    card->nports, card->irq);\n\tdbg(DBG_PCI, \"conf %04x mem %08x ctlmem %08x\\n\",\n\t    card->pci_conf, card->phys_mem, card->phys_ctlmem);\n\n\t \n\tfst_cpureset(card);\n\tcard->state = FST_RESET;\n\n\t \n\tfst_init_dma(card);\n\n\t \n\tpci_set_drvdata(pdev, card);\n\n\t \n\tif (no_of_cards_added >= FST_MAX_CARDS) {\n\t\tpr_err(\"FarSync: too many cards\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto card_array_fail;\n\t}\n\tfst_card_array[no_of_cards_added] = card;\n\tcard->card_no = no_of_cards_added++;\t \n\terr = fst_init_card(card);\n\tif (err)\n\t\tgoto init_card_fail;\n\tif (card->family == FST_FAMILY_TXU) {\n\t\t \n\t\tcard->rx_dma_handle_host =\n\t\t    dma_alloc_coherent(&card->device->dev, FST_MAX_MTU,\n\t\t\t\t       &card->rx_dma_handle_card, GFP_KERNEL);\n\t\tif (!card->rx_dma_handle_host) {\n\t\t\tpr_err(\"Could not allocate rx dma buffer\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto rx_dma_fail;\n\t\t}\n\t\tcard->tx_dma_handle_host =\n\t\t    dma_alloc_coherent(&card->device->dev, FST_MAX_MTU,\n\t\t\t\t       &card->tx_dma_handle_card, GFP_KERNEL);\n\t\tif (!card->tx_dma_handle_host) {\n\t\t\tpr_err(\"Could not allocate tx dma buffer\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto tx_dma_fail;\n\t\t}\n\t}\n\treturn 0;\t\t \n\ntx_dma_fail:\n\tdma_free_coherent(&card->device->dev, FST_MAX_MTU,\n\t\t\t  card->rx_dma_handle_host, card->rx_dma_handle_card);\nrx_dma_fail:\n\tfst_disable_intr(card);\n\tfor (i = 0 ; i < card->nports ; i++)\n\t\tunregister_hdlc_device(card->ports[i].dev);\ninit_card_fail:\n\tfst_card_array[card->card_no] = NULL;\ncard_array_fail:\n\tfor (i = 0 ; i < card->nports ; i++)\n\t\tfree_netdev(card->ports[i].dev);\nhdlcdev_fail:\n\tfree_irq(card->irq, card);\nirq_fail:\n\tiounmap(card->ctlmem);\nioremap_ctlmem_fail:\n\tiounmap(card->mem);\nioremap_physmem_fail:\n\tpci_release_regions(pdev);\nregions_fail:\n\tpci_disable_device(pdev);\nenable_fail:\n\tkfree(card);\n\treturn err;\n}\n\n \nstatic void\nfst_remove_one(struct pci_dev *pdev)\n{\n\tstruct fst_card_info *card;\n\tint i;\n\n\tcard = pci_get_drvdata(pdev);\n\n\tfor (i = 0; i < card->nports; i++) {\n\t\tstruct net_device *dev = port_to_dev(&card->ports[i]);\n\n\t\tunregister_hdlc_device(dev);\n\t\tfree_netdev(dev);\n\t}\n\n\tfst_disable_intr(card);\n\tfree_irq(card->irq, card);\n\n\tiounmap(card->ctlmem);\n\tiounmap(card->mem);\n\tpci_release_regions(pdev);\n\tif (card->family == FST_FAMILY_TXU) {\n\t\t \n\t\tdma_free_coherent(&card->device->dev, FST_MAX_MTU,\n\t\t\t\t  card->rx_dma_handle_host,\n\t\t\t\t  card->rx_dma_handle_card);\n\t\tdma_free_coherent(&card->device->dev, FST_MAX_MTU,\n\t\t\t\t  card->tx_dma_handle_host,\n\t\t\t\t  card->tx_dma_handle_card);\n\t}\n\tfst_card_array[card->card_no] = NULL;\n\tkfree(card);\n}\n\nstatic struct pci_driver fst_driver = {\n\t.name\t\t= FST_NAME,\n\t.id_table\t= fst_pci_dev_id,\n\t.probe\t\t= fst_add_one,\n\t.remove\t\t= fst_remove_one,\n};\n\nstatic int __init\nfst_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < FST_MAX_CARDS; i++)\n\t\tfst_card_array[i] = NULL;\n\treturn pci_register_driver(&fst_driver);\n}\n\nstatic void __exit\nfst_cleanup_module(void)\n{\n\tpr_info(\"FarSync WAN driver unloading\\n\");\n\tpci_unregister_driver(&fst_driver);\n}\n\nmodule_init(fst_init);\nmodule_exit(fst_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}