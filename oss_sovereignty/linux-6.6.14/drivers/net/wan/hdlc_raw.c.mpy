{
  "module_name": "hdlc_raw.c",
  "hash_id": "7f14981c9b78157f242f06273ff1a676e72b77b77fa03657b8bc3ca6ca8517a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wan/hdlc_raw.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/hdlc.h>\n#include <linux/if_arp.h>\n#include <linux/inetdevice.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pkt_sched.h>\n#include <linux/poll.h>\n#include <linux/rtnetlink.h>\n#include <linux/skbuff.h>\n\n\nstatic int raw_ioctl(struct net_device *dev, struct if_settings *ifs);\n\nstatic __be16 raw_type_trans(struct sk_buff *skb, struct net_device *dev)\n{\n\treturn cpu_to_be16(ETH_P_IP);\n}\n\nstatic struct hdlc_proto proto = {\n\t.type_trans\t= raw_type_trans,\n\t.ioctl\t\t= raw_ioctl,\n\t.module\t\t= THIS_MODULE,\n};\n\n\nstatic int raw_ioctl(struct net_device *dev, struct if_settings *ifs)\n{\n\traw_hdlc_proto __user *raw_s = ifs->ifs_ifsu.raw_hdlc;\n\tconst size_t size = sizeof(raw_hdlc_proto);\n\traw_hdlc_proto new_settings;\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tint result;\n\n\tswitch (ifs->type) {\n\tcase IF_GET_PROTO:\n\t\tif (dev_to_hdlc(dev)->proto != &proto)\n\t\t\treturn -EINVAL;\n\t\tifs->type = IF_PROTO_HDLC;\n\t\tif (ifs->size < size) {\n\t\t\tifs->size = size;  \n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tif (copy_to_user(raw_s, hdlc->state, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase IF_PROTO_HDLC:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (dev->flags & IFF_UP)\n\t\t\treturn -EBUSY;\n\n\t\tif (copy_from_user(&new_settings, raw_s, size))\n\t\t\treturn -EFAULT;\n\n\t\tif (new_settings.encoding == ENCODING_DEFAULT)\n\t\t\tnew_settings.encoding = ENCODING_NRZ;\n\n\t\tif (new_settings.parity == PARITY_DEFAULT)\n\t\t\tnew_settings.parity = PARITY_CRC16_PR1_CCITT;\n\n\t\tresult = hdlc->attach(dev, new_settings.encoding,\n\t\t\t\t      new_settings.parity);\n\t\tif (result)\n\t\t\treturn result;\n\n\t\tresult = attach_hdlc_protocol(dev, &proto,\n\t\t\t\t\t      sizeof(raw_hdlc_proto));\n\t\tif (result)\n\t\t\treturn result;\n\t\tmemcpy(hdlc->state, &new_settings, size);\n\t\tdev->type = ARPHRD_RAWHDLC;\n\t\tcall_netdevice_notifiers(NETDEV_POST_TYPE_CHANGE, dev);\n\t\tnetif_dormant_off(dev);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\n\nstatic int __init hdlc_raw_init(void)\n{\n\tregister_hdlc_protocol(&proto);\n\treturn 0;\n}\n\n\n\nstatic void __exit hdlc_raw_exit(void)\n{\n\tunregister_hdlc_protocol(&proto);\n}\n\n\nmodule_init(hdlc_raw_init);\nmodule_exit(hdlc_raw_exit);\n\nMODULE_AUTHOR(\"Krzysztof Halasa <khc@pm.waw.pl>\");\nMODULE_DESCRIPTION(\"Raw HDLC protocol support for generic HDLC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}