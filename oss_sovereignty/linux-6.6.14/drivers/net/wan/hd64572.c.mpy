{
  "module_name": "hd64572.c",
  "hash_id": "3df0d5effe9db42c9e2cc0bc03c58d98c79a7b858ff7786aa2679c0cb11be214",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wan/hd64572.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/errno.h>\n#include <linux/fcntl.h>\n#include <linux/hdlc.h>\n#include <linux/in.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include \"hd64572.h\"\n\n#define NAPI_WEIGHT\t\t16\n\n#define get_msci(port)\t  ((port)->chan ?   MSCI1_OFFSET :   MSCI0_OFFSET)\n#define get_dmac_rx(port) ((port)->chan ? DMAC1RX_OFFSET : DMAC0RX_OFFSET)\n#define get_dmac_tx(port) ((port)->chan ? DMAC1TX_OFFSET : DMAC0TX_OFFSET)\n\n#define sca_in(reg, card)\t     readb((card)->scabase + (reg))\n#define sca_out(value, reg, card)    writeb(value, (card)->scabase + (reg))\n#define sca_inw(reg, card)\t     readw((card)->scabase + (reg))\n#define sca_outw(value, reg, card)   writew(value, (card)->scabase + (reg))\n#define sca_inl(reg, card)\t     readl((card)->scabase + (reg))\n#define sca_outl(value, reg, card)   writel(value, (card)->scabase + (reg))\n\nstatic int sca_poll(struct napi_struct *napi, int budget);\n\nstatic inline port_t *dev_to_port(struct net_device *dev)\n{\n\treturn dev_to_hdlc(dev)->priv;\n}\n\nstatic inline void enable_intr(port_t *port)\n{\n\t \n\tsca_outl(sca_inl(IER0, port->card) |\n\t\t (port->chan ? 0x08002200 : 0x00080022), IER0, port->card);\n}\n\nstatic inline void disable_intr(port_t *port)\n{\n\tsca_outl(sca_inl(IER0, port->card) &\n\t\t (port->chan ? 0x00FF00FF : 0xFF00FF00), IER0, port->card);\n}\n\nstatic inline u16 desc_abs_number(port_t *port, u16 desc, int transmit)\n{\n\tu16 rx_buffs = port->card->rx_ring_buffers;\n\tu16 tx_buffs = port->card->tx_ring_buffers;\n\n\tdesc %= (transmit ? tx_buffs : rx_buffs);  \n\treturn port->chan * (rx_buffs + tx_buffs) + transmit * rx_buffs + desc;\n}\n\nstatic inline u16 desc_offset(port_t *port, u16 desc, int transmit)\n{\n\t \n\treturn desc_abs_number(port, desc, transmit) * sizeof(pkt_desc);\n}\n\nstatic inline pkt_desc __iomem *desc_address(port_t *port, u16 desc,\n\t\t\t\t\t     int transmit)\n{\n\treturn (pkt_desc __iomem *)(port->card->rambase +\n\t\t\t\t    desc_offset(port, desc, transmit));\n}\n\nstatic inline u32 buffer_offset(port_t *port, u16 desc, int transmit)\n{\n\treturn port->card->buff_offset +\n\t\tdesc_abs_number(port, desc, transmit) * (u32)HDLC_MAX_MRU;\n}\n\nstatic inline void sca_set_carrier(port_t *port)\n{\n\tif (!(sca_in(get_msci(port) + ST3, port->card) & ST3_DCD)) {\n#ifdef DEBUG_LINK\n\t\tprintk(KERN_DEBUG \"%s: sca_set_carrier on\\n\",\n\t\t       port->netdev.name);\n#endif\n\t\tnetif_carrier_on(port->netdev);\n\t} else {\n#ifdef DEBUG_LINK\n\t\tprintk(KERN_DEBUG \"%s: sca_set_carrier off\\n\",\n\t\t       port->netdev.name);\n#endif\n\t\tnetif_carrier_off(port->netdev);\n\t}\n}\n\nstatic void sca_init_port(port_t *port)\n{\n\tcard_t *card = port->card;\n\tu16 dmac_rx = get_dmac_rx(port), dmac_tx = get_dmac_tx(port);\n\tint transmit, i;\n\n\tport->rxin = 0;\n\tport->txin = 0;\n\tport->txlast = 0;\n\n\tfor (transmit = 0; transmit < 2; transmit++) {\n\t\tu16 buffs = transmit ? card->tx_ring_buffers\n\t\t\t: card->rx_ring_buffers;\n\n\t\tfor (i = 0; i < buffs; i++) {\n\t\t\tpkt_desc __iomem *desc = desc_address(port, i, transmit);\n\t\t\tu16 chain_off = desc_offset(port, i + 1, transmit);\n\t\t\tu32 buff_off = buffer_offset(port, i, transmit);\n\n\t\t\twritel(chain_off, &desc->cp);\n\t\t\twritel(buff_off, &desc->bp);\n\t\t\twritew(0, &desc->len);\n\t\t\twriteb(0, &desc->stat);\n\t\t}\n\t}\n\n\t \n\tsca_out(0, DSR_RX(port->chan), card);\n\tsca_out(0, DSR_TX(port->chan), card);\n\n\t \n\tsca_out(DCR_ABORT, DCR_RX(port->chan), card);\n\tsca_out(DCR_ABORT, DCR_TX(port->chan), card);\n\n\t \n\tsca_outl(desc_offset(port, 0, 0), dmac_rx + CDAL, card);\n\tsca_outl(desc_offset(port, card->tx_ring_buffers - 1, 0),\n\t\t dmac_rx + EDAL, card);\n\tsca_outl(desc_offset(port, 0, 1), dmac_tx + CDAL, card);\n\tsca_outl(desc_offset(port, 0, 1), dmac_tx + EDAL, card);\n\n\t \n\tsca_out(DCR_CLEAR_EOF, DCR_RX(port->chan), card);\n\tsca_out(DCR_CLEAR_EOF, DCR_TX(port->chan), card);\n\n\t \n\tsca_outw(HDLC_MAX_MRU, dmac_rx + BFLL, card);  \n\tsca_out(0x14, DMR_RX(port->chan), card);  \n\tsca_out(DIR_EOME, DIR_RX(port->chan), card);  \n\tsca_out(DSR_DE, DSR_RX(port->chan), card);  \n\n\t \n\tsca_out(0x14, DMR_TX(port->chan), card);  \n\tsca_out(DIR_EOME, DIR_TX(port->chan), card);  \n\n\tsca_set_carrier(port);\n\tnetif_napi_add_weight(port->netdev, &port->napi, sca_poll,\n\t\t\t      NAPI_WEIGHT);\n}\n\n \nstatic inline void sca_msci_intr(port_t *port)\n{\n\tu16 msci = get_msci(port);\n\tcard_t *card = port->card;\n\n\tif (sca_in(msci + ST1, card) & ST1_CDCD) {\n\t\t \n\t\tsca_out(ST1_CDCD, msci + ST1, card);\n\t\tsca_set_carrier(port);\n\t}\n}\n\nstatic inline void sca_rx(card_t *card, port_t *port, pkt_desc __iomem *desc,\n\t\t\t  u16 rxin)\n{\n\tstruct net_device *dev = port->netdev;\n\tstruct sk_buff *skb;\n\tu16 len;\n\tu32 buff;\n\n\tlen = readw(&desc->len);\n\tskb = dev_alloc_skb(len);\n\tif (!skb) {\n\t\tdev->stats.rx_dropped++;\n\t\treturn;\n\t}\n\n\tbuff = buffer_offset(port, rxin, 0);\n\tmemcpy_fromio(skb->data, card->rambase + buff, len);\n\n\tskb_put(skb, len);\n#ifdef DEBUG_PKT\n\tprintk(KERN_DEBUG \"%s RX(%i):\", dev->name, skb->len);\n\tdebug_frame(skb);\n#endif\n\tdev->stats.rx_packets++;\n\tdev->stats.rx_bytes += skb->len;\n\tskb->protocol = hdlc_type_trans(skb, dev);\n\tnetif_receive_skb(skb);\n}\n\n \nstatic inline int sca_rx_done(port_t *port, int budget)\n{\n\tstruct net_device *dev = port->netdev;\n\tu16 dmac = get_dmac_rx(port);\n\tcard_t *card = port->card;\n\tu8 stat = sca_in(DSR_RX(port->chan), card);  \n\tint received = 0;\n\n\t \n\tsca_out((stat & (DSR_EOT | DSR_EOM | DSR_BOF | DSR_COF)) | DSR_DWE,\n\t\tDSR_RX(port->chan), card);\n\n\tif (stat & DSR_BOF)\n\t\t \n\t\tdev->stats.rx_over_errors++;\n\n\twhile (received < budget) {\n\t\tu32 desc_off = desc_offset(port, port->rxin, 0);\n\t\tpkt_desc __iomem *desc;\n\t\tu32 cda = sca_inl(dmac + CDAL, card);\n\n\t\tif ((cda >= desc_off) && (cda < desc_off + sizeof(pkt_desc)))\n\t\t\tbreak;\t \n\n\t\tdesc = desc_address(port, port->rxin, 0);\n\t\tstat = readb(&desc->stat);\n\t\tif (!(stat & ST_RX_EOM))\n\t\t\tport->rxpart = 1;  \n\t\telse if ((stat & ST_ERROR_MASK) || port->rxpart) {\n\t\t\tdev->stats.rx_errors++;\n\t\t\tif (stat & ST_RX_OVERRUN)\n\t\t\t\tdev->stats.rx_fifo_errors++;\n\t\t\telse if ((stat & (ST_RX_SHORT | ST_RX_ABORT |\n\t\t\t\t\t  ST_RX_RESBIT)) || port->rxpart)\n\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t\telse if (stat & ST_RX_CRC)\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\tif (stat & ST_RX_EOM)\n\t\t\t\tport->rxpart = 0;  \n\t\t} else {\n\t\t\tsca_rx(card, port, desc, port->rxin);\n\t\t\treceived++;\n\t\t}\n\n\t\t \n\t\tsca_outl(desc_off, dmac + EDAL, card);\n\t\tport->rxin = (port->rxin + 1) % card->rx_ring_buffers;\n\t}\n\n\t \n\tsca_out(DSR_DE, DSR_RX(port->chan), card);\n\treturn received;\n}\n\n \nstatic inline void sca_tx_done(port_t *port)\n{\n\tstruct net_device *dev = port->netdev;\n\tcard_t *card = port->card;\n\tu8 stat;\n\tunsigned count = 0;\n\n\tspin_lock(&port->lock);\n\n\tstat = sca_in(DSR_TX(port->chan), card);  \n\n\t \n\tsca_out((stat & (DSR_EOT | DSR_EOM | DSR_BOF | DSR_COF)) | DSR_DWE,\n\t\tDSR_TX(port->chan), card);\n\n\twhile (1) {\n\t\tpkt_desc __iomem *desc = desc_address(port, port->txlast, 1);\n\t\tu8 stat = readb(&desc->stat);\n\n\t\tif (!(stat & ST_TX_OWNRSHP))\n\t\t\tbreak;  \n\t\tif (stat & ST_TX_UNDRRUN) {\n\t\t\tdev->stats.tx_errors++;\n\t\t\tdev->stats.tx_fifo_errors++;\n\t\t} else {\n\t\t\tdev->stats.tx_packets++;\n\t\t\tdev->stats.tx_bytes += readw(&desc->len);\n\t\t}\n\t\twriteb(0, &desc->stat);\t \n\t\tcount++;\n\t\tport->txlast = (port->txlast + 1) % card->tx_ring_buffers;\n\t}\n\n\tif (count)\n\t\tnetif_wake_queue(dev);\n\tspin_unlock(&port->lock);\n}\n\nstatic int sca_poll(struct napi_struct *napi, int budget)\n{\n\tport_t *port = container_of(napi, port_t, napi);\n\tu32 isr0 = sca_inl(ISR0, port->card);\n\tint received = 0;\n\n\tif (isr0 & (port->chan ? 0x08000000 : 0x00080000))\n\t\tsca_msci_intr(port);\n\n\tif (isr0 & (port->chan ? 0x00002000 : 0x00000020))\n\t\tsca_tx_done(port);\n\n\tif (isr0 & (port->chan ? 0x00000200 : 0x00000002))\n\t\treceived = sca_rx_done(port, budget);\n\n\tif (received < budget) {\n\t\tnapi_complete_done(napi, received);\n\t\tenable_intr(port);\n\t}\n\n\treturn received;\n}\n\nstatic irqreturn_t sca_intr(int irq, void *dev_id)\n{\n\tcard_t *card = dev_id;\n\tu32 isr0 = sca_inl(ISR0, card);\n\tint i, handled = 0;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tport_t *port = get_port(card, i);\n\t\tif (port && (isr0 & (i ? 0x08002200 : 0x00080022))) {\n\t\t\thandled = 1;\n\t\t\tdisable_intr(port);\n\t\t\tnapi_schedule(&port->napi);\n\t\t}\n\t}\n\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void sca_set_port(port_t *port)\n{\n\tcard_t *card = port->card;\n\tu16 msci = get_msci(port);\n\tu8 md2 = sca_in(msci + MD2, card);\n\tunsigned int tmc, br = 10, brv = 1024;\n\n\tif (port->settings.clock_rate > 0) {\n\t\t \n\t\tdo {\n\t\t\tbr--;\n\t\t\tbrv >>= 1;  \n\n\t\t\t \n\t\t\ttmc = CLOCK_BASE / brv / port->settings.clock_rate;\n\t\t} while (br > 1 && tmc <= 128);\n\n\t\tif (tmc < 1) {\n\t\t\ttmc = 1;\n\t\t\tbr = 0;\t \n\t\t\tbrv = 1;\n\t\t} else if (tmc > 255) {\n\t\t\ttmc = 256;  \n\t\t}\n\n\t\tport->settings.clock_rate = CLOCK_BASE / brv / tmc;\n\t} else {\n\t\tbr = 9;  \n\t\ttmc = 256;\t \n\t\tport->settings.clock_rate = CLOCK_BASE / (256 * 512);\n\t}\n\n\tport->rxs = (port->rxs & ~CLK_BRG_MASK) | br;\n\tport->txs = (port->txs & ~CLK_BRG_MASK) | br;\n\tport->tmc = tmc;\n\n\t \n\tsca_out(port->tmc, msci + TMCR, card);\n\tsca_out(port->tmc, msci + TMCT, card);\n\n\t \n\tsca_out(port->rxs, msci + RXS, card);\n\tsca_out(port->txs, msci + TXS, card);\n\n\tif (port->settings.loopback)\n\t\tmd2 |= MD2_LOOPBACK;\n\telse\n\t\tmd2 &= ~MD2_LOOPBACK;\n\n\tsca_out(md2, msci + MD2, card);\n}\n\nstatic void sca_open(struct net_device *dev)\n{\n\tport_t *port = dev_to_port(dev);\n\tcard_t *card = port->card;\n\tu16 msci = get_msci(port);\n\tu8 md0, md2;\n\n\tswitch (port->encoding) {\n\tcase ENCODING_NRZ:\n\t\tmd2 = MD2_NRZ;\n\t\tbreak;\n\tcase ENCODING_NRZI:\n\t\tmd2 = MD2_NRZI;\n\t\tbreak;\n\tcase ENCODING_FM_MARK:\n\t\tmd2 = MD2_FM_MARK;\n\t\tbreak;\n\tcase ENCODING_FM_SPACE:\n\t\tmd2 = MD2_FM_SPACE;\n\t\tbreak;\n\tdefault:\n\t\tmd2 = MD2_MANCHESTER;\n\t}\n\n\tif (port->settings.loopback)\n\t\tmd2 |= MD2_LOOPBACK;\n\n\tswitch (port->parity) {\n\tcase PARITY_CRC16_PR0:\n\t\tmd0 = MD0_HDLC | MD0_CRC_16_0;\n\t\tbreak;\n\tcase PARITY_CRC16_PR1:\n\t\tmd0 = MD0_HDLC | MD0_CRC_16;\n\t\tbreak;\n\tcase PARITY_CRC32_PR1_CCITT:\n\t\tmd0 = MD0_HDLC | MD0_CRC_ITU32;\n\t\tbreak;\n\tcase PARITY_CRC16_PR1_CCITT:\n\t\tmd0 = MD0_HDLC | MD0_CRC_ITU;\n\t\tbreak;\n\tdefault:\n\t\tmd0 = MD0_HDLC | MD0_CRC_NONE;\n\t}\n\n\tsca_out(CMD_RESET, msci + CMD, card);\n\tsca_out(md0, msci + MD0, card);\n\tsca_out(0x00, msci + MD1, card);  \n\tsca_out(md2, msci + MD2, card);\n\tsca_out(0x7E, msci + IDL, card);  \n\t \n\tsca_out(CTL_IDLE | CTL_URCT | CTL_URSKP, msci + CTL, card);\n\tsca_out(0x0F, msci + RNR, card);  \n\tsca_out(0x3C, msci + TFS, card);  \n\tsca_out(0x38, msci + TCR, card);  \n\tsca_out(0x38, msci + TNR0, card);  \n\tsca_out(0x3F, msci + TNR1, card);  \n\n \n\tsca_outl(IE0_RXINTA | IE0_CDCD, msci + IE0, card);\n\n\tsca_out(port->tmc, msci + TMCR, card);\n\tsca_out(port->tmc, msci + TMCT, card);\n\tsca_out(port->rxs, msci + RXS, card);\n\tsca_out(port->txs, msci + TXS, card);\n\tsca_out(CMD_TX_ENABLE, msci + CMD, card);\n\tsca_out(CMD_RX_ENABLE, msci + CMD, card);\n\n\tsca_set_carrier(port);\n\tenable_intr(port);\n\tnapi_enable(&port->napi);\n\tnetif_start_queue(dev);\n}\n\nstatic void sca_close(struct net_device *dev)\n{\n\tport_t *port = dev_to_port(dev);\n\n\t \n\tsca_out(CMD_RESET, get_msci(port) + CMD, port->card);\n\tdisable_intr(port);\n\tnapi_disable(&port->napi);\n\tnetif_stop_queue(dev);\n}\n\nstatic int sca_attach(struct net_device *dev, unsigned short encoding,\n\t\t      unsigned short parity)\n{\n\tif (encoding != ENCODING_NRZ &&\n\t    encoding != ENCODING_NRZI &&\n\t    encoding != ENCODING_FM_MARK &&\n\t    encoding != ENCODING_FM_SPACE &&\n\t    encoding != ENCODING_MANCHESTER)\n\t\treturn -EINVAL;\n\n\tif (parity != PARITY_NONE &&\n\t    parity != PARITY_CRC16_PR0 &&\n\t    parity != PARITY_CRC16_PR1 &&\n\t    parity != PARITY_CRC32_PR1_CCITT &&\n\t    parity != PARITY_CRC16_PR1_CCITT)\n\t\treturn -EINVAL;\n\n\tdev_to_port(dev)->encoding = encoding;\n\tdev_to_port(dev)->parity = parity;\n\treturn 0;\n}\n\n#ifdef DEBUG_RINGS\nstatic void sca_dump_rings(struct net_device *dev)\n{\n\tport_t *port = dev_to_port(dev);\n\tcard_t *card = port->card;\n\tu16 cnt;\n\n\tprintk(KERN_DEBUG \"RX ring: CDA=%u EDA=%u DSR=%02X in=%u %sactive\",\n\t       sca_inl(get_dmac_rx(port) + CDAL, card),\n\t       sca_inl(get_dmac_rx(port) + EDAL, card),\n\t       sca_in(DSR_RX(port->chan), card), port->rxin,\n\t       sca_in(DSR_RX(port->chan), card) & DSR_DE ? \"\" : \"in\");\n\tfor (cnt = 0; cnt < port->card->rx_ring_buffers; cnt++)\n\t\tpr_cont(\" %02X\", readb(&(desc_address(port, cnt, 0)->stat)));\n\tpr_cont(\"\\n\");\n\n\tprintk(KERN_DEBUG \"TX ring: CDA=%u EDA=%u DSR=%02X in=%u \"\n\t       \"last=%u %sactive\",\n\t       sca_inl(get_dmac_tx(port) + CDAL, card),\n\t       sca_inl(get_dmac_tx(port) + EDAL, card),\n\t       sca_in(DSR_TX(port->chan), card), port->txin, port->txlast,\n\t       sca_in(DSR_TX(port->chan), card) & DSR_DE ? \"\" : \"in\");\n\n\tfor (cnt = 0; cnt < port->card->tx_ring_buffers; cnt++)\n\t\tpr_cont(\" %02X\", readb(&(desc_address(port, cnt, 1)->stat)));\n\tpr_cont(\"\\n\");\n\n\tprintk(KERN_DEBUG \"MSCI: MD: %02x %02x %02x,\"\n\t       \" ST: %02x %02x %02x %02x %02x, FST: %02x CST: %02x %02x\\n\",\n\t       sca_in(get_msci(port) + MD0, card),\n\t       sca_in(get_msci(port) + MD1, card),\n\t       sca_in(get_msci(port) + MD2, card),\n\t       sca_in(get_msci(port) + ST0, card),\n\t       sca_in(get_msci(port) + ST1, card),\n\t       sca_in(get_msci(port) + ST2, card),\n\t       sca_in(get_msci(port) + ST3, card),\n\t       sca_in(get_msci(port) + ST4, card),\n\t       sca_in(get_msci(port) + FST, card),\n\t       sca_in(get_msci(port) + CST0, card),\n\t       sca_in(get_msci(port) + CST1, card));\n\n\tprintk(KERN_DEBUG \"ILAR: %02x ISR: %08x %08x\\n\", sca_in(ILAR, card),\n\t       sca_inl(ISR0, card), sca_inl(ISR1, card));\n}\n#endif  \n\nstatic netdev_tx_t sca_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tport_t *port = dev_to_port(dev);\n\tcard_t *card = port->card;\n\tpkt_desc __iomem *desc;\n\tu32 buff, len;\n\n\tspin_lock_irq(&port->lock);\n\n\tdesc = desc_address(port, port->txin + 1, 1);\n\tBUG_ON(readb(&desc->stat));  \n\n#ifdef DEBUG_PKT\n\tprintk(KERN_DEBUG \"%s TX(%i):\", dev->name, skb->len);\n\tdebug_frame(skb);\n#endif\n\n\tdesc = desc_address(port, port->txin, 1);\n\tbuff = buffer_offset(port, port->txin, 1);\n\tlen = skb->len;\n\tmemcpy_toio(card->rambase + buff, skb->data, len);\n\n\twritew(len, &desc->len);\n\twriteb(ST_TX_EOM, &desc->stat);\n\n\tport->txin = (port->txin + 1) % card->tx_ring_buffers;\n\tsca_outl(desc_offset(port, port->txin, 1),\n\t\t get_dmac_tx(port) + EDAL, card);\n\n\tsca_out(DSR_DE, DSR_TX(port->chan), card);  \n\n\tdesc = desc_address(port, port->txin + 1, 1);\n\tif (readb(&desc->stat))  \n\t\tnetif_stop_queue(dev);\n\n\tspin_unlock_irq(&port->lock);\n\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic u32 sca_detect_ram(card_t *card, u8 __iomem *rambase, u32 ramsize)\n{\n\t \n\tu32 i = ramsize &= ~3;\n\n\tdo {\n\t\ti -= 4;\n\t\twritel(i ^ 0x12345678, rambase + i);\n\t} while (i > 0);\n\n\tfor (i = 0; i < ramsize ; i += 4) {\n\t\tif (readl(rambase + i) != (i ^ 0x12345678))\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}\n\nstatic void sca_init(card_t *card, int wait_states)\n{\n\tsca_out(wait_states, WCRL, card);  \n\tsca_out(wait_states, WCRM, card);\n\tsca_out(wait_states, WCRH, card);\n\n\tsca_out(0, DMER, card);\t \n\tsca_out(0x03, PCR, card);  \n\tsca_out(0, DSR_RX(0), card);  \n\tsca_out(0, DSR_TX(0), card);\n\tsca_out(0, DSR_RX(1), card);\n\tsca_out(0, DSR_TX(1), card);\n\tsca_out(DMER_DME, DMER, card);  \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}