{
  "module_name": "n2.c",
  "hash_id": "cbc9974665e9f879f7b0b2243dd53cc5c3b2d83c0455409e2eb2b620a15f8d9a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wan/n2.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/moduleparam.h>\n#include <linux/netdevice.h>\n#include <linux/hdlc.h>\n#include <asm/io.h>\n#include \"hd64570.h\"\n\nstatic const char *version = \"SDL RISCom/N2 driver version: 1.15\";\nstatic const char *devname = \"RISCom/N2\";\n\n#undef DEBUG_PKT\n#define DEBUG_RINGS\n\n#define USE_WINDOWSIZE 16384\n#define USE_BUS16BITS 1\n#define CLOCK_BASE 9830400\t \n#define MAX_PAGES      16\t \n#define MAX_RAM_SIZE 0x80000\t \n#if MAX_RAM_SIZE > MAX_PAGES * USE_WINDOWSIZE\n#undef MAX_RAM_SIZE\n#define MAX_RAM_SIZE (MAX_PAGES * USE_WINDOWSIZE)\n#endif\n#define N2_IOPORTS 0x10\n#define NEED_DETECT_RAM\n#define NEED_SCA_MSCI_INTR\n#define MAX_TX_BUFFERS 10\n\nstatic char *hw;\t \n\n \n\n \n#define N2_PCR 0\n#define PCR_RUNSCA 1      \n#define PCR_VPM    2      \n#define PCR_ENWIN  4      \n#define PCR_BUS16  8      \n\n \n#define N2_BAR 2\n\n \n#define N2_PSR 4\n#define WIN16K       0x00\n#define WIN32K       0x20\n#define WIN64K       0x40\n#define PSR_WINBITS  0x60\n#define PSR_DMAEN    0x80\n#define PSR_PAGEBITS 0x0F\n\n \n#define N2_MCR 6\n#define CLOCK_OUT_PORT1 0x80\n#define CLOCK_OUT_PORT0 0x40\n#define TX422_PORT1     0x20\n#define TX422_PORT0     0x10\n#define DSR_PORT1       0x08\n#define DSR_PORT0       0x04\n#define DTR_PORT1       0x02\n#define DTR_PORT0       0x01\n\ntypedef struct port_s {\n\tstruct net_device *dev;\n\tstruct card_s *card;\n\tspinlock_t lock;\t \n\tsync_serial_settings settings;\n\tint valid;\t\t \n\tint rxpart;\t\t \n\tunsigned short encoding;\n\tunsigned short parity;\n\tu16 rxin;\t\t \n\tu16 txin;\t\t \n\tu16 txlast;\n\tu8 rxs, txs, tmc;\t \n\tu8 phy_node;\t\t \n\tu8 log_node;\t\t \n} port_t;\n\ntypedef struct card_s {\n\tu8 __iomem *winbase;\t\t \n\tu32 phy_winbase;\t \n\tu32 ram_size;\t\t \n\tu16 io;\t\t\t \n\tu16 buff_offset;\t \n\tu16 rx_ring_buffers;\t \n\tu16 tx_ring_buffers;\n\tu8 irq;\t\t\t \n\n\tport_t ports[2];\n\tstruct card_s *next_card;\n} card_t;\n\nstatic card_t *first_card;\nstatic card_t **new_card = &first_card;\n\n#define sca_reg(reg, card) (0x8000 | (card)->io | \\\n\t\t\t    ((reg) & 0x0F) | (((reg) & 0xF0) << 6))\n#define sca_in(reg, card)\t\tinb(sca_reg(reg, card))\n#define sca_out(value, reg, card)\toutb(value, sca_reg(reg, card))\n#define sca_inw(reg, card)\t\tinw(sca_reg(reg, card))\n#define sca_outw(value, reg, card)\toutw(value, sca_reg(reg, card))\n\n#define port_to_card(port)\t\t((port)->card)\n#define log_node(port)\t\t\t((port)->log_node)\n#define phy_node(port)\t\t\t((port)->phy_node)\n#define winsize(card)\t\t\t(USE_WINDOWSIZE)\n#define winbase(card)      \t     \t((card)->winbase)\n#define get_port(card, port)\t\t((card)->ports[port].valid ? \\\n\t\t\t\t\t &(card)->ports[port] : NULL)\n\nstatic __inline__ u8 sca_get_page(card_t *card)\n{\n\treturn inb(card->io + N2_PSR) & PSR_PAGEBITS;\n}\n\nstatic __inline__ void openwin(card_t *card, u8 page)\n{\n\tu8 psr = inb(card->io + N2_PSR);\n\n\toutb((psr & ~PSR_PAGEBITS) | page, card->io + N2_PSR);\n}\n\n#include \"hd64570.c\"\n\nstatic void n2_set_iface(port_t *port)\n{\n\tcard_t *card = port->card;\n\tint io = card->io;\n\tu8 mcr = inb(io + N2_MCR);\n\tu8 msci = get_msci(port);\n\tu8 rxs = port->rxs & CLK_BRG_MASK;\n\tu8 txs = port->txs & CLK_BRG_MASK;\n\n\tswitch (port->settings.clock_type) {\n\tcase CLOCK_INT:\n\t\tmcr |= port->phy_node ? CLOCK_OUT_PORT1 : CLOCK_OUT_PORT0;\n\t\trxs |= CLK_BRG_RX;  \n\t\ttxs |= CLK_RXCLK_TX;  \n\t\tbreak;\n\n\tcase CLOCK_TXINT:\n\t\tmcr |= port->phy_node ? CLOCK_OUT_PORT1 : CLOCK_OUT_PORT0;\n\t\trxs |= CLK_LINE_RX;  \n\t\ttxs |= CLK_BRG_TX;  \n\t\tbreak;\n\n\tcase CLOCK_TXFROMRX:\n\t\tmcr |= port->phy_node ? CLOCK_OUT_PORT1 : CLOCK_OUT_PORT0;\n\t\trxs |= CLK_LINE_RX;  \n\t\ttxs |= CLK_RXCLK_TX;  \n\t\tbreak;\n\n\tdefault:\t\t \n\t\tmcr &= port->phy_node ? ~CLOCK_OUT_PORT1 : ~CLOCK_OUT_PORT0;\n\t\trxs |= CLK_LINE_RX;  \n\t\ttxs |= CLK_LINE_TX;  \n\t}\n\n\toutb(mcr, io + N2_MCR);\n\tport->rxs = rxs;\n\tport->txs = txs;\n\tsca_out(rxs, msci + RXS, card);\n\tsca_out(txs, msci + TXS, card);\n\tsca_set_port(port);\n}\n\nstatic int n2_open(struct net_device *dev)\n{\n\tport_t *port = dev_to_port(dev);\n\tint io = port->card->io;\n\tu8 mcr = inb(io + N2_MCR) |\n\t\t(port->phy_node ? TX422_PORT1 : TX422_PORT0);\n\tint result;\n\n\tresult = hdlc_open(dev);\n\tif (result)\n\t\treturn result;\n\n\tmcr &= port->phy_node ? ~DTR_PORT1 : ~DTR_PORT0;  \n\toutb(mcr, io + N2_MCR);\n\n\toutb(inb(io + N2_PCR) | PCR_ENWIN, io + N2_PCR);  \n\toutb(inb(io + N2_PSR) | PSR_DMAEN, io + N2_PSR);  \n\tsca_open(dev);\n\tn2_set_iface(port);\n\treturn 0;\n}\n\nstatic int n2_close(struct net_device *dev)\n{\n\tport_t *port = dev_to_port(dev);\n\tint io = port->card->io;\n\tu8 mcr = inb(io + N2_MCR) |\n\t\t(port->phy_node ? TX422_PORT1 : TX422_PORT0);\n\n\tsca_close(dev);\n\tmcr |= port->phy_node ? DTR_PORT1 : DTR_PORT0;  \n\toutb(mcr, io + N2_MCR);\n\thdlc_close(dev);\n\treturn 0;\n}\n\nstatic int n2_siocdevprivate(struct net_device *dev, struct ifreq *ifr,\n\t\t\t     void __user *data, int cmd)\n{\n#ifdef DEBUG_RINGS\n\tif (cmd == SIOCDEVPRIVATE) {\n\t\tsca_dump_rings(dev);\n\t\treturn 0;\n\t}\n#endif\n\treturn -EOPNOTSUPP;\n}\n\nstatic int n2_ioctl(struct net_device *dev, struct if_settings *ifs)\n{\n\tconst size_t size = sizeof(sync_serial_settings);\n\tsync_serial_settings new_line;\n\tsync_serial_settings __user *line = ifs->ifs_ifsu.sync;\n\tport_t *port = dev_to_port(dev);\n\n\tswitch (ifs->type) {\n\tcase IF_GET_IFACE:\n\t\tifs->type = IF_IFACE_SYNC_SERIAL;\n\t\tif (ifs->size < size) {\n\t\t\tifs->size = size;  \n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tif (copy_to_user(line, &port->settings, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase IF_IFACE_SYNC_SERIAL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&new_line, line, size))\n\t\t\treturn -EFAULT;\n\n\t\tif (new_line.clock_type != CLOCK_EXT &&\n\t\t    new_line.clock_type != CLOCK_TXFROMRX &&\n\t\t    new_line.clock_type != CLOCK_INT &&\n\t\t    new_line.clock_type != CLOCK_TXINT)\n\t\t\treturn -EINVAL;\t \n\n\t\tif (new_line.loopback != 0 && new_line.loopback != 1)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(&port->settings, &new_line, size);  \n\t\tn2_set_iface(port);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn hdlc_ioctl(dev, ifs);\n\t}\n}\n\nstatic void n2_destroy_card(card_t *card)\n{\n\tint cnt;\n\n\tfor (cnt = 0; cnt < 2; cnt++)\n\t\tif (card->ports[cnt].card) {\n\t\t\tstruct net_device *dev = port_to_dev(&card->ports[cnt]);\n\n\t\t\tunregister_hdlc_device(dev);\n\t\t}\n\n\tif (card->irq)\n\t\tfree_irq(card->irq, card);\n\n\tif (card->winbase) {\n\t\tiounmap(card->winbase);\n\t\trelease_mem_region(card->phy_winbase, USE_WINDOWSIZE);\n\t}\n\n\tif (card->io)\n\t\trelease_region(card->io, N2_IOPORTS);\n\tif (card->ports[0].dev)\n\t\tfree_netdev(card->ports[0].dev);\n\tif (card->ports[1].dev)\n\t\tfree_netdev(card->ports[1].dev);\n\tkfree(card);\n}\n\nstatic const struct net_device_ops n2_ops = {\n\t.ndo_open       = n2_open,\n\t.ndo_stop       = n2_close,\n\t.ndo_start_xmit = hdlc_start_xmit,\n\t.ndo_siocwandev = n2_ioctl,\n\t.ndo_siocdevprivate = n2_siocdevprivate,\n};\n\nstatic int __init n2_run(unsigned long io, unsigned long irq,\n\t\t\t unsigned long winbase, long valid0, long valid1)\n{\n\tcard_t *card;\n\tu8 cnt, pcr;\n\tint i;\n\n\tif (io < 0x200 || io > 0x3FF || (io % N2_IOPORTS) != 0) {\n\t\tpr_err(\"invalid I/O port value\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (irq < 3 || irq > 15 || irq == 6)   {\n\t\tpr_err(\"invalid IRQ value\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (winbase < 0xA0000 || winbase > 0xFFFFF || (winbase & 0xFFF) != 0) {\n\t\tpr_err(\"invalid RAM value\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tcard = kzalloc(sizeof(card_t), GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOBUFS;\n\n\tcard->ports[0].dev = alloc_hdlcdev(&card->ports[0]);\n\tcard->ports[1].dev = alloc_hdlcdev(&card->ports[1]);\n\tif (!card->ports[0].dev || !card->ports[1].dev) {\n\t\tpr_err(\"unable to allocate memory\\n\");\n\t\tn2_destroy_card(card);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!request_region(io, N2_IOPORTS, devname)) {\n\t\tpr_err(\"I/O port region in use\\n\");\n\t\tn2_destroy_card(card);\n\t\treturn -EBUSY;\n\t}\n\tcard->io = io;\n\n\tif (request_irq(irq, sca_intr, 0, devname, card)) {\n\t\tpr_err(\"could not allocate IRQ\\n\");\n\t\tn2_destroy_card(card);\n\t\treturn -EBUSY;\n\t}\n\tcard->irq = irq;\n\n\tif (!request_mem_region(winbase, USE_WINDOWSIZE, devname)) {\n\t\tpr_err(\"could not request RAM window\\n\");\n\t\tn2_destroy_card(card);\n\t\treturn -EBUSY;\n\t}\n\tcard->phy_winbase = winbase;\n\tcard->winbase = ioremap(winbase, USE_WINDOWSIZE);\n\tif (!card->winbase) {\n\t\tpr_err(\"ioremap() failed\\n\");\n\t\tn2_destroy_card(card);\n\t\treturn -EFAULT;\n\t}\n\n\toutb(0, io + N2_PCR);\n\toutb(winbase >> 12, io + N2_BAR);\n\n\tswitch (USE_WINDOWSIZE) {\n\tcase 16384:\n\t\toutb(WIN16K, io + N2_PSR);\n\t\tbreak;\n\n\tcase 32768:\n\t\toutb(WIN32K, io + N2_PSR);\n\t\tbreak;\n\n\tcase 65536:\n\t\toutb(WIN64K, io + N2_PSR);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"invalid window size\\n\");\n\t\tn2_destroy_card(card);\n\t\treturn -ENODEV;\n\t}\n\n\tpcr = PCR_ENWIN | PCR_VPM | (USE_BUS16BITS ? PCR_BUS16 : 0);\n\toutb(pcr, io + N2_PCR);\n\n\tcard->ram_size = sca_detect_ram(card, card->winbase, MAX_RAM_SIZE);\n\n\t \n\ti = card->ram_size / ((valid0 + valid1) * (sizeof(pkt_desc) +\n\t\t\t\t\t\t   HDLC_MAX_MRU));\n\n\tcard->tx_ring_buffers = min(i / 2, MAX_TX_BUFFERS);\n\tcard->rx_ring_buffers = i - card->tx_ring_buffers;\n\n\tcard->buff_offset = (valid0 + valid1) * sizeof(pkt_desc) *\n\t\t(card->tx_ring_buffers + card->rx_ring_buffers);\n\n\tpr_info(\"RISCom/N2 %u KB RAM, IRQ%u, using %u TX + %u RX packets rings\\n\",\n\t\tcard->ram_size / 1024, card->irq,\n\t\tcard->tx_ring_buffers, card->rx_ring_buffers);\n\n\tif (card->tx_ring_buffers < 1) {\n\t\tpr_err(\"RAM test failed\\n\");\n\t\tn2_destroy_card(card);\n\t\treturn -EIO;\n\t}\n\n\tpcr |= PCR_RUNSCA;\t\t \n\toutb(pcr, io + N2_PCR);\n\toutb(0, io + N2_MCR);\n\n\tsca_init(card, 0);\n\tfor (cnt = 0; cnt < 2; cnt++) {\n\t\tport_t *port = &card->ports[cnt];\n\t\tstruct net_device *dev = port_to_dev(port);\n\t\thdlc_device *hdlc = dev_to_hdlc(dev);\n\n\t\tif ((cnt == 0 && !valid0) || (cnt == 1 && !valid1))\n\t\t\tcontinue;\n\n\t\tport->phy_node = cnt;\n\t\tport->valid = 1;\n\n\t\tif ((cnt == 1) && valid0)\n\t\t\tport->log_node = 1;\n\n\t\tspin_lock_init(&port->lock);\n\t\tdev->irq = irq;\n\t\tdev->mem_start = winbase;\n\t\tdev->mem_end = winbase + USE_WINDOWSIZE - 1;\n\t\tdev->tx_queue_len = 50;\n\t\tdev->netdev_ops = &n2_ops;\n\t\thdlc->attach = sca_attach;\n\t\thdlc->xmit = sca_xmit;\n\t\tport->settings.clock_type = CLOCK_EXT;\n\t\tport->card = card;\n\n\t\tif (register_hdlc_device(dev)) {\n\t\t\tpr_warn(\"unable to register hdlc device\\n\");\n\t\t\tport->card = NULL;\n\t\t\tn2_destroy_card(card);\n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tsca_init_port(port);  \n\n\t\tnetdev_info(dev, \"RISCom/N2 node %d\\n\", port->phy_node);\n\t}\n\n\t*new_card = card;\n\tnew_card = &card->next_card;\n\n\treturn 0;\n}\n\nstatic int __init n2_init(void)\n{\n\tif (!hw) {\n#ifdef MODULE\n\t\tpr_info(\"no card initialized\\n\");\n#endif\n\t\treturn -EINVAL;\t \n\t}\n\n\tpr_info(\"%s\\n\", version);\n\n\tdo {\n\t\tunsigned long io, irq, ram;\n\t\tlong valid[2] = { 0, 0 };  \n\n\t\tio = simple_strtoul(hw, &hw, 0);\n\n\t\tif (*hw++ != ',')\n\t\t\tbreak;\n\t\tirq = simple_strtoul(hw, &hw, 0);\n\n\t\tif (*hw++ != ',')\n\t\t\tbreak;\n\t\tram = simple_strtoul(hw, &hw, 0);\n\n\t\tif (*hw++ != ',')\n\t\t\tbreak;\n\t\twhile (1) {\n\t\t\tif (*hw == '0' && !valid[0])\n\t\t\t\tvalid[0] = 1;  \n\t\t\telse if (*hw == '1' && !valid[1])\n\t\t\t\tvalid[1] = 1;  \n\t\t\telse\n\t\t\t\tbreak;\n\t\t\thw++;\n\t\t}\n\n\t\tif (!valid[0] && !valid[1])\n\t\t\tbreak;\t \n\n\t\tif (*hw == ':' || *hw == '\\x0')\n\t\t\tn2_run(io, irq, ram, valid[0], valid[1]);\n\n\t\tif (*hw == '\\x0')\n\t\t\treturn first_card ? 0 : -EINVAL;\n\t} while (*hw++ == ':');\n\n\tpr_err(\"invalid hardware parameters\\n\");\n\treturn first_card ? 0 : -EINVAL;\n}\n\nstatic void __exit n2_cleanup(void)\n{\n\tcard_t *card = first_card;\n\n\twhile (card) {\n\t\tcard_t *ptr = card;\n\n\t\tcard = card->next_card;\n\t\tn2_destroy_card(ptr);\n\t}\n}\n\nmodule_init(n2_init);\nmodule_exit(n2_cleanup);\n\nMODULE_AUTHOR(\"Krzysztof Halasa <khc@pm.waw.pl>\");\nMODULE_DESCRIPTION(\"RISCom/N2 serial port driver\");\nMODULE_LICENSE(\"GPL v2\");\nmodule_param(hw, charp, 0444);\nMODULE_PARM_DESC(hw, \"io,irq,ram,ports:io,irq,...\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}