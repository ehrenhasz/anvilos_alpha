{
  "module_name": "hd64570.c",
  "hash_id": "8f3e0a39130d90e1a90c6a205e4880b33bc94549b1072d6d02adcc273bbbd019",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wan/hd64570.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/errno.h>\n#include <linux/fcntl.h>\n#include <linux/hdlc.h>\n#include <linux/in.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include \"hd64570.h\"\n\n#define get_msci(port)\t  (phy_node(port) ?   MSCI1_OFFSET :   MSCI0_OFFSET)\n#define get_dmac_rx(port) (phy_node(port) ? DMAC1RX_OFFSET : DMAC0RX_OFFSET)\n#define get_dmac_tx(port) (phy_node(port) ? DMAC1TX_OFFSET : DMAC0TX_OFFSET)\n\n#define SCA_INTR_MSCI(node)    (node ? 0x10 : 0x01)\n#define SCA_INTR_DMAC_RX(node) (node ? 0x20 : 0x02)\n#define SCA_INTR_DMAC_TX(node) (node ? 0x40 : 0x04)\n\nstatic inline struct net_device *port_to_dev(port_t *port)\n{\n\treturn port->dev;\n}\n\nstatic inline int sca_intr_status(card_t *card)\n{\n\tu8 result = 0;\n\tu8 isr0 = sca_in(ISR0, card);\n\tu8 isr1 = sca_in(ISR1, card);\n\n\tif (isr1 & 0x03)\n\t\tresult |= SCA_INTR_DMAC_RX(0);\n\tif (isr1 & 0x0C)\n\t\tresult |= SCA_INTR_DMAC_TX(0);\n\tif (isr1 & 0x30)\n\t\tresult |= SCA_INTR_DMAC_RX(1);\n\tif (isr1 & 0xC0)\n\t\tresult |= SCA_INTR_DMAC_TX(1);\n\tif (isr0 & 0x0F)\n\t\tresult |= SCA_INTR_MSCI(0);\n\tif (isr0 & 0xF0)\n\t\tresult |= SCA_INTR_MSCI(1);\n\n\tif (!(result & SCA_INTR_DMAC_TX(0)))\n\t\tif (sca_in(DSR_TX(0), card) & DSR_EOM)\n\t\t\tresult |= SCA_INTR_DMAC_TX(0);\n\tif (!(result & SCA_INTR_DMAC_TX(1)))\n\t\tif (sca_in(DSR_TX(1), card) & DSR_EOM)\n\t\t\tresult |= SCA_INTR_DMAC_TX(1);\n\n\treturn result;\n}\n\nstatic inline port_t *dev_to_port(struct net_device *dev)\n{\n\treturn dev_to_hdlc(dev)->priv;\n}\n\nstatic inline u16 next_desc(port_t *port, u16 desc, int transmit)\n{\n\treturn (desc + 1) % (transmit ? port_to_card(port)->tx_ring_buffers\n\t\t\t     : port_to_card(port)->rx_ring_buffers);\n}\n\nstatic inline u16 desc_abs_number(port_t *port, u16 desc, int transmit)\n{\n\tu16 rx_buffs = port_to_card(port)->rx_ring_buffers;\n\tu16 tx_buffs = port_to_card(port)->tx_ring_buffers;\n\n\tdesc %= (transmit ? tx_buffs : rx_buffs);  \n\treturn log_node(port) * (rx_buffs + tx_buffs) +\n\t\ttransmit * rx_buffs + desc;\n}\n\nstatic inline u16 desc_offset(port_t *port, u16 desc, int transmit)\n{\n\t \n\treturn desc_abs_number(port, desc, transmit) * sizeof(pkt_desc);\n}\n\nstatic inline pkt_desc __iomem *desc_address(port_t *port, u16 desc,\n\t\t\t\t\t     int transmit)\n{\n#ifdef PAGE0_ALWAYS_MAPPED\n\treturn (pkt_desc __iomem *)(win0base(port_to_card(port))\n\t\t\t\t    + desc_offset(port, desc, transmit));\n#else\n\treturn (pkt_desc __iomem *)(winbase(port_to_card(port))\n\t\t\t\t    + desc_offset(port, desc, transmit));\n#endif\n}\n\nstatic inline u32 buffer_offset(port_t *port, u16 desc, int transmit)\n{\n\treturn port_to_card(port)->buff_offset +\n\t\tdesc_abs_number(port, desc, transmit) * (u32)HDLC_MAX_MRU;\n}\n\nstatic inline void sca_set_carrier(port_t *port)\n{\n\tif (!(sca_in(get_msci(port) + ST3, port_to_card(port)) & ST3_DCD)) {\n#ifdef DEBUG_LINK\n\t\tprintk(KERN_DEBUG \"%s: sca_set_carrier on\\n\",\n\t\t       port_to_dev(port)->name);\n#endif\n\t\tnetif_carrier_on(port_to_dev(port));\n\t} else {\n#ifdef DEBUG_LINK\n\t\tprintk(KERN_DEBUG \"%s: sca_set_carrier off\\n\",\n\t\t       port_to_dev(port)->name);\n#endif\n\t\tnetif_carrier_off(port_to_dev(port));\n\t}\n}\n\nstatic void sca_init_port(port_t *port)\n{\n\tcard_t *card = port_to_card(port);\n\tint transmit, i;\n\n\tport->rxin = 0;\n\tport->txin = 0;\n\tport->txlast = 0;\n\n#ifndef PAGE0_ALWAYS_MAPPED\n\topenwin(card, 0);\n#endif\n\n\tfor (transmit = 0; transmit < 2; transmit++) {\n\t\tu16 dmac = transmit ? get_dmac_tx(port) : get_dmac_rx(port);\n\t\tu16 buffs = transmit ? card->tx_ring_buffers\n\t\t\t: card->rx_ring_buffers;\n\n\t\tfor (i = 0; i < buffs; i++) {\n\t\t\tpkt_desc __iomem *desc = desc_address(port, i, transmit);\n\t\t\tu16 chain_off = desc_offset(port, i + 1, transmit);\n\t\t\tu32 buff_off = buffer_offset(port, i, transmit);\n\n\t\t\twritew(chain_off, &desc->cp);\n\t\t\twritel(buff_off, &desc->bp);\n\t\t\twritew(0, &desc->len);\n\t\t\twriteb(0, &desc->stat);\n\t\t}\n\n\t\t \n\t\tsca_out(0, transmit ? DSR_TX(phy_node(port)) :\n\t\t\tDSR_RX(phy_node(port)), card);\n\t\t \n\t\tsca_out(DCR_ABORT, transmit ? DCR_TX(phy_node(port)) :\n\t\t\tDCR_RX(phy_node(port)), card);\n\n\t\t \n\t\tsca_out(0, dmac + CPB, card);  \n\t\tsca_outw(desc_offset(port, 0, transmit), dmac + CDAL, card);\n\t\tif (!transmit)\n\t\t\tsca_outw(desc_offset(port, buffs - 1, transmit),\n\t\t\t\t dmac + EDAL, card);\n\t\telse\n\t\t\tsca_outw(desc_offset(port, 0, transmit), dmac + EDAL,\n\t\t\t\t card);\n\n\t\t \n\t\tsca_out(DCR_CLEAR_EOF, transmit ? DCR_TX(phy_node(port)) :\n\t\t\tDCR_RX(phy_node(port)), card);\n\n\t\tif (!transmit) {  \n\t\t\t \n\t\t\tsca_outw(HDLC_MAX_MRU, dmac + BFLL, card);\n\t\t\t \n\t\t\tsca_out(0x14, DMR_RX(phy_node(port)), card);\n\t\t\tsca_out(DIR_EOME | DIR_BOFE, DIR_RX(phy_node(port)),\n\t\t\t\tcard);\n\t\t\t \n\t\t\tsca_out(DSR_DE, DSR_RX(phy_node(port)), card);\n\t\t} else {\t \n\t\t\t \n\t\t\tsca_out(0x14, DMR_TX(phy_node(port)), card);\n\t\t\t \n\t\t\tsca_out(DIR_BOFE, DIR_TX(phy_node(port)), card);\n\t\t}\n\t}\n\tsca_set_carrier(port);\n}\n\n#ifdef NEED_SCA_MSCI_INTR\n \nstatic inline void sca_msci_intr(port_t *port)\n{\n\tu16 msci = get_msci(port);\n\tcard_t *card = port_to_card(port);\n\tu8 stat = sca_in(msci + ST1, card);  \n\n\t \n\tsca_out(stat & (ST1_UDRN | ST1_CDCD), msci + ST1, card);\n\n\tif (stat & ST1_UDRN) {\n\t\t \n\t\tport_to_dev(port)->stats.tx_errors++;\n\t\tport_to_dev(port)->stats.tx_fifo_errors++;\n\t}\n\n\tif (stat & ST1_CDCD)\n\t\tsca_set_carrier(port);\n}\n#endif\n\nstatic inline void sca_rx(card_t *card, port_t *port, pkt_desc __iomem *desc,\n\t\t\t  u16 rxin)\n{\n\tstruct net_device *dev = port_to_dev(port);\n\tstruct sk_buff *skb;\n\tu16 len;\n\tu32 buff;\n\tu32 maxlen;\n\tu8 page;\n\n\tlen = readw(&desc->len);\n\tskb = dev_alloc_skb(len);\n\tif (!skb) {\n\t\tdev->stats.rx_dropped++;\n\t\treturn;\n\t}\n\n\tbuff = buffer_offset(port, rxin, 0);\n\tpage = buff / winsize(card);\n\tbuff = buff % winsize(card);\n\tmaxlen = winsize(card) - buff;\n\n\topenwin(card, page);\n\n\tif (len > maxlen) {\n\t\tmemcpy_fromio(skb->data, winbase(card) + buff, maxlen);\n\t\topenwin(card, page + 1);\n\t\tmemcpy_fromio(skb->data + maxlen, winbase(card), len - maxlen);\n\t} else {\n\t\tmemcpy_fromio(skb->data, winbase(card) + buff, len);\n\t}\n\n#ifndef PAGE0_ALWAYS_MAPPED\n\topenwin(card, 0);\t \n#endif\n\tskb_put(skb, len);\n#ifdef DEBUG_PKT\n\tprintk(KERN_DEBUG \"%s RX(%i):\", dev->name, skb->len);\n\tdebug_frame(skb);\n#endif\n\tdev->stats.rx_packets++;\n\tdev->stats.rx_bytes += skb->len;\n\tskb->protocol = hdlc_type_trans(skb, dev);\n\tnetif_rx(skb);\n}\n\n \nstatic inline void sca_rx_intr(port_t *port)\n{\n\tstruct net_device *dev = port_to_dev(port);\n\tu16 dmac = get_dmac_rx(port);\n\tcard_t *card = port_to_card(port);\n\tu8 stat = sca_in(DSR_RX(phy_node(port)), card);  \n\n\t \n\tsca_out((stat & (DSR_EOT | DSR_EOM | DSR_BOF | DSR_COF)) | DSR_DWE,\n\t\tDSR_RX(phy_node(port)), card);\n\n\tif (stat & DSR_BOF)\n\t\t \n\t\tdev->stats.rx_over_errors++;\n\n\twhile (1) {\n\t\tu32 desc_off = desc_offset(port, port->rxin, 0);\n\t\tpkt_desc __iomem *desc;\n\t\tu32 cda = sca_inw(dmac + CDAL, card);\n\n\t\tif (cda >= desc_off && (cda < desc_off + sizeof(pkt_desc)))\n\t\t\tbreak;\t \n\n\t\tdesc = desc_address(port, port->rxin, 0);\n\t\tstat = readb(&desc->stat);\n\t\tif (!(stat & ST_RX_EOM))\n\t\t\tport->rxpart = 1;  \n\t\telse if ((stat & ST_ERROR_MASK) || port->rxpart) {\n\t\t\tdev->stats.rx_errors++;\n\t\t\tif (stat & ST_RX_OVERRUN)\n\t\t\t\tdev->stats.rx_fifo_errors++;\n\t\t\telse if ((stat & (ST_RX_SHORT | ST_RX_ABORT |\n\t\t\t\t\t  ST_RX_RESBIT)) || port->rxpart)\n\t\t\t\tdev->stats.rx_frame_errors++;\n\t\t\telse if (stat & ST_RX_CRC)\n\t\t\t\tdev->stats.rx_crc_errors++;\n\t\t\tif (stat & ST_RX_EOM)\n\t\t\t\tport->rxpart = 0;  \n\t\t} else {\n\t\t\tsca_rx(card, port, desc, port->rxin);\n\t\t}\n\n\t\t \n\t\tsca_outw(desc_off, dmac + EDAL, card);\n\t\tport->rxin = next_desc(port, port->rxin, 0);\n\t}\n\n\t \n\tsca_out(DSR_DE, DSR_RX(phy_node(port)), card);\n}\n\n \nstatic inline void sca_tx_intr(port_t *port)\n{\n\tstruct net_device *dev = port_to_dev(port);\n\tu16 dmac = get_dmac_tx(port);\n\tcard_t *card = port_to_card(port);\n\tu8 stat;\n\n\tspin_lock(&port->lock);\n\n\tstat = sca_in(DSR_TX(phy_node(port)), card);  \n\n\t \n\tsca_out((stat & (DSR_EOT | DSR_EOM | DSR_BOF | DSR_COF)) | DSR_DWE,\n\t\tDSR_TX(phy_node(port)), card);\n\n\twhile (1) {\n\t\tpkt_desc __iomem *desc;\n\n\t\tu32 desc_off = desc_offset(port, port->txlast, 1);\n\t\tu32 cda = sca_inw(dmac + CDAL, card);\n\n\t\tif (cda >= desc_off && (cda < desc_off + sizeof(pkt_desc)))\n\t\t\tbreak;\t \n\n\t\tdesc = desc_address(port, port->txlast, 1);\n\t\tdev->stats.tx_packets++;\n\t\tdev->stats.tx_bytes += readw(&desc->len);\n\t\twriteb(0, &desc->stat);\t \n\t\tport->txlast = next_desc(port, port->txlast, 1);\n\t}\n\n\tnetif_wake_queue(dev);\n\tspin_unlock(&port->lock);\n}\n\nstatic irqreturn_t sca_intr(int irq, void *dev_id)\n{\n\tcard_t *card = dev_id;\n\tint i;\n\tu8 stat;\n\tint handled = 0;\n\tu8 page = sca_get_page(card);\n\n\twhile ((stat = sca_intr_status(card)) != 0) {\n\t\thandled = 1;\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tport_t *port = get_port(card, i);\n\n\t\t\tif (port) {\n\t\t\t\tif (stat & SCA_INTR_MSCI(i))\n\t\t\t\t\tsca_msci_intr(port);\n\n\t\t\t\tif (stat & SCA_INTR_DMAC_RX(i))\n\t\t\t\t\tsca_rx_intr(port);\n\n\t\t\t\tif (stat & SCA_INTR_DMAC_TX(i))\n\t\t\t\t\tsca_tx_intr(port);\n\t\t\t}\n\t\t}\n\t}\n\n\topenwin(card, page);\t\t \n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void sca_set_port(port_t *port)\n{\n\tcard_t *card = port_to_card(port);\n\tu16 msci = get_msci(port);\n\tu8 md2 = sca_in(msci + MD2, card);\n\tunsigned int tmc, br = 10, brv = 1024;\n\n\tif (port->settings.clock_rate > 0) {\n\t\t \n\t\tdo {\n\t\t\tbr--;\n\t\t\tbrv >>= 1;  \n\n\t\t\t \n\t\t\ttmc = CLOCK_BASE / brv / port->settings.clock_rate;\n\t\t} while (br > 1 && tmc <= 128);\n\n\t\tif (tmc < 1) {\n\t\t\ttmc = 1;\n\t\t\tbr = 0;\t \n\t\t\tbrv = 1;\n\t\t} else if (tmc > 255) {\n\t\t\ttmc = 256;  \n\t\t}\n\n\t\tport->settings.clock_rate = CLOCK_BASE / brv / tmc;\n\t} else {\n\t\tbr = 9;  \n\t\ttmc = 256;\t \n\t\tport->settings.clock_rate = CLOCK_BASE / (256 * 512);\n\t}\n\n\tport->rxs = (port->rxs & ~CLK_BRG_MASK) | br;\n\tport->txs = (port->txs & ~CLK_BRG_MASK) | br;\n\tport->tmc = tmc;\n\n\t \n\tsca_out(port->tmc, msci + TMC, card);\n\n\t \n\tsca_out(port->rxs, msci + RXS, card);\n\tsca_out(port->txs, msci + TXS, card);\n\n\tif (port->settings.loopback)\n\t\tmd2 |= MD2_LOOPBACK;\n\telse\n\t\tmd2 &= ~MD2_LOOPBACK;\n\n\tsca_out(md2, msci + MD2, card);\n}\n\nstatic void sca_open(struct net_device *dev)\n{\n\tport_t *port = dev_to_port(dev);\n\tcard_t *card = port_to_card(port);\n\tu16 msci = get_msci(port);\n\tu8 md0, md2;\n\n\tswitch (port->encoding) {\n\tcase ENCODING_NRZ:\n\t\tmd2 = MD2_NRZ;\n\t\tbreak;\n\tcase ENCODING_NRZI:\n\t\tmd2 = MD2_NRZI;\n\t\tbreak;\n\tcase ENCODING_FM_MARK:\n\t\tmd2 = MD2_FM_MARK;\n\t\tbreak;\n\tcase ENCODING_FM_SPACE:\n\t\tmd2 = MD2_FM_SPACE;\n\t\tbreak;\n\tdefault:\n\t\tmd2 = MD2_MANCHESTER;\n\t}\n\n\tif (port->settings.loopback)\n\t\tmd2 |= MD2_LOOPBACK;\n\n\tswitch (port->parity) {\n\tcase PARITY_CRC16_PR0:\n\t\tmd0 = MD0_HDLC | MD0_CRC_16_0;\n\t\tbreak;\n\tcase PARITY_CRC16_PR1:\n\t\tmd0 = MD0_HDLC | MD0_CRC_16;\n\t\tbreak;\n\tcase PARITY_CRC16_PR0_CCITT:\n\t\tmd0 = MD0_HDLC | MD0_CRC_ITU_0;\n\t\tbreak;\n\tcase PARITY_CRC16_PR1_CCITT:\n\t\tmd0 = MD0_HDLC | MD0_CRC_ITU;\n\t\tbreak;\n\tdefault:\n\t\tmd0 = MD0_HDLC | MD0_CRC_NONE;\n\t}\n\n\tsca_out(CMD_RESET, msci + CMD, card);\n\tsca_out(md0, msci + MD0, card);\n\tsca_out(0x00, msci + MD1, card);  \n\tsca_out(md2, msci + MD2, card);\n\tsca_out(0x7E, msci + IDL, card);  \n\tsca_out(CTL_IDLE, msci + CTL, card);\n\n\t \n\t \n\tsca_out(0x07, msci + RRC, card);  \n\tsca_out(0x10, msci + TRC0, card);  \n\tsca_out(0x14, msci + TRC1, card);  \n\n \n\tsca_set_carrier(port);\n\n\t \n\tsca_out(IE0_TXINT | IE0_RXINTA, msci + IE0, card);\n\tsca_out(IE1_UDRN | IE1_CDCD, msci + IE1, card);\n\tsca_out(sca_in(IER0, card) | (phy_node(port) ? 0xC0 : 0x0C),\n\t\tIER0, card);  \n\t \n\tsca_out(sca_in(IER1, card) | (phy_node(port) ? 0xF0 : 0x0F),\n\t\tIER1, card);\n\n\tsca_out(port->tmc, msci + TMC, card);  \n\tsca_out(port->rxs, msci + RXS, card);\n\tsca_out(port->txs, msci + TXS, card);\n\tsca_out(CMD_TX_ENABLE, msci + CMD, card);\n\tsca_out(CMD_RX_ENABLE, msci + CMD, card);\n\n\tnetif_start_queue(dev);\n}\n\nstatic void sca_close(struct net_device *dev)\n{\n\tport_t *port = dev_to_port(dev);\n\tcard_t *card = port_to_card(port);\n\n\t \n\tsca_out(CMD_RESET, get_msci(port) + CMD, port_to_card(port));\n\t \n\tsca_out(sca_in(IER0, card) & (phy_node(port) ? 0x0F : 0xF0),\n\t\tIER0, card);\n\t \n\tsca_out(sca_in(IER1, card) & (phy_node(port) ? 0x0F : 0xF0),\n\t\tIER1, card);\n\n\tnetif_stop_queue(dev);\n}\n\nstatic int sca_attach(struct net_device *dev, unsigned short encoding,\n\t\t      unsigned short parity)\n{\n\tif (encoding != ENCODING_NRZ &&\n\t    encoding != ENCODING_NRZI &&\n\t    encoding != ENCODING_FM_MARK &&\n\t    encoding != ENCODING_FM_SPACE &&\n\t    encoding != ENCODING_MANCHESTER)\n\t\treturn -EINVAL;\n\n\tif (parity != PARITY_NONE &&\n\t    parity != PARITY_CRC16_PR0 &&\n\t    parity != PARITY_CRC16_PR1 &&\n\t    parity != PARITY_CRC16_PR0_CCITT &&\n\t    parity != PARITY_CRC16_PR1_CCITT)\n\t\treturn -EINVAL;\n\n\tdev_to_port(dev)->encoding = encoding;\n\tdev_to_port(dev)->parity = parity;\n\treturn 0;\n}\n\n#ifdef DEBUG_RINGS\nstatic void sca_dump_rings(struct net_device *dev)\n{\n\tport_t *port = dev_to_port(dev);\n\tcard_t *card = port_to_card(port);\n\tu16 cnt;\n#ifndef PAGE0_ALWAYS_MAPPED\n\tu8 page = sca_get_page(card);\n\n\topenwin(card, 0);\n#endif\n\n\tprintk(KERN_DEBUG \"RX ring: CDA=%u EDA=%u DSR=%02X in=%u %sactive\",\n\t       sca_inw(get_dmac_rx(port) + CDAL, card),\n\t       sca_inw(get_dmac_rx(port) + EDAL, card),\n\t       sca_in(DSR_RX(phy_node(port)), card), port->rxin,\n\t       sca_in(DSR_RX(phy_node(port)), card) & DSR_DE ? \"\" : \"in\");\n\tfor (cnt = 0; cnt < port_to_card(port)->rx_ring_buffers; cnt++)\n\t\tpr_cont(\" %02X\", readb(&(desc_address(port, cnt, 0)->stat)));\n\tpr_cont(\"\\n\");\n\n\tprintk(KERN_DEBUG \"TX ring: CDA=%u EDA=%u DSR=%02X in=%u \"\n\t       \"last=%u %sactive\",\n\t       sca_inw(get_dmac_tx(port) + CDAL, card),\n\t       sca_inw(get_dmac_tx(port) + EDAL, card),\n\t       sca_in(DSR_TX(phy_node(port)), card), port->txin, port->txlast,\n\t       sca_in(DSR_TX(phy_node(port)), card) & DSR_DE ? \"\" : \"in\");\n\n\tfor (cnt = 0; cnt < port_to_card(port)->tx_ring_buffers; cnt++)\n\t\tpr_cont(\" %02X\", readb(&(desc_address(port, cnt, 1)->stat)));\n\tpr_cont(\"\\n\");\n\n\tprintk(KERN_DEBUG \"MSCI: MD: %02x %02x %02x, ST: %02x %02x %02x %02x,\"\n\t       \" FST: %02x CST: %02x %02x\\n\",\n\t       sca_in(get_msci(port) + MD0, card),\n\t       sca_in(get_msci(port) + MD1, card),\n\t       sca_in(get_msci(port) + MD2, card),\n\t       sca_in(get_msci(port) + ST0, card),\n\t       sca_in(get_msci(port) + ST1, card),\n\t       sca_in(get_msci(port) + ST2, card),\n\t       sca_in(get_msci(port) + ST3, card),\n\t       sca_in(get_msci(port) + FST, card),\n\t       sca_in(get_msci(port) + CST0, card),\n\t       sca_in(get_msci(port) + CST1, card));\n\n\tprintk(KERN_DEBUG \"ISR: %02x %02x %02x\\n\", sca_in(ISR0, card),\n\t       sca_in(ISR1, card), sca_in(ISR2, card));\n\n#ifndef PAGE0_ALWAYS_MAPPED\n\topenwin(card, page);  \n#endif\n}\n#endif  \n\nstatic netdev_tx_t sca_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tport_t *port = dev_to_port(dev);\n\tcard_t *card = port_to_card(port);\n\tpkt_desc __iomem *desc;\n\tu32 buff, len;\n\tu8 page;\n\tu32 maxlen;\n\n\tspin_lock_irq(&port->lock);\n\n\tdesc = desc_address(port, port->txin + 1, 1);\n\tBUG_ON(readb(&desc->stat));  \n\n#ifdef DEBUG_PKT\n\tprintk(KERN_DEBUG \"%s TX(%i):\", dev->name, skb->len);\n\tdebug_frame(skb);\n#endif\n\n\tdesc = desc_address(port, port->txin, 1);\n\tbuff = buffer_offset(port, port->txin, 1);\n\tlen = skb->len;\n\tpage = buff / winsize(card);\n\tbuff = buff % winsize(card);\n\tmaxlen = winsize(card) - buff;\n\n\topenwin(card, page);\n\tif (len > maxlen) {\n\t\tmemcpy_toio(winbase(card) + buff, skb->data, maxlen);\n\t\topenwin(card, page + 1);\n\t\tmemcpy_toio(winbase(card), skb->data + maxlen, len - maxlen);\n\t} else {\n\t\tmemcpy_toio(winbase(card) + buff, skb->data, len);\n\t}\n\n#ifndef PAGE0_ALWAYS_MAPPED\n\topenwin(card, 0);\t \n#endif\n\twritew(len, &desc->len);\n\twriteb(ST_TX_EOM, &desc->stat);\n\n\tport->txin = next_desc(port, port->txin, 1);\n\tsca_outw(desc_offset(port, port->txin, 1),\n\t\t get_dmac_tx(port) + EDAL, card);\n\n\tsca_out(DSR_DE, DSR_TX(phy_node(port)), card);  \n\n\tdesc = desc_address(port, port->txin + 1, 1);\n\tif (readb(&desc->stat))  \n\t\tnetif_stop_queue(dev);\n\n\tspin_unlock_irq(&port->lock);\n\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\n#ifdef NEED_DETECT_RAM\nstatic u32 sca_detect_ram(card_t *card, u8 __iomem *rambase, u32 ramsize)\n{\n\t \n\tu32 i = ramsize &= ~3;\n\tu32 size = winsize(card);\n\n\topenwin(card, (i - 4) / size);  \n\n\tdo {\n\t\ti -= 4;\n\t\tif ((i + 4) % size == 0)\n\t\t\topenwin(card, i / size);\n\t\twritel(i ^ 0x12345678, rambase + i % size);\n\t} while (i > 0);\n\n\tfor (i = 0; i < ramsize ; i += 4) {\n\t\tif (i % size == 0)\n\t\t\topenwin(card, i / size);\n\n\t\tif (readl(rambase + i % size) != (i ^ 0x12345678))\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}\n#endif  \n\nstatic void sca_init(card_t *card, int wait_states)\n{\n\tsca_out(wait_states, WCRL, card);  \n\tsca_out(wait_states, WCRM, card);\n\tsca_out(wait_states, WCRH, card);\n\n\tsca_out(0, DMER, card);\t \n\tsca_out(0x03, PCR, card);  \n\tsca_out(0, DSR_RX(0), card);  \n\tsca_out(0, DSR_TX(0), card);\n\tsca_out(0, DSR_RX(1), card);\n\tsca_out(0, DSR_TX(1), card);\n\tsca_out(DMER_DME, DMER, card);  \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}