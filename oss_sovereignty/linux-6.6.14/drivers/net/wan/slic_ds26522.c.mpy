{
  "module_name": "slic_ds26522.c",
  "hash_id": "cc37ae83bb0adff66f4a23414f38c9ae5637decc2bd546344a841d3e45afcc8c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wan/slic_ds26522.c",
  "human_readable_source": "\n \n\n#include <linux/bitrev.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/kthread.h>\n#include <linux/spi/spi.h>\n#include <linux/wait.h>\n#include <linux/param.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/io.h>\n#include \"slic_ds26522.h\"\n\n#define SLIC_TRANS_LEN 1\n#define SLIC_TWO_LEN 2\n#define SLIC_THREE_LEN 3\n\nstatic struct spi_device *g_spi;\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Zhao Qiang<B45475@freescale.com>\");\n\n \nstatic void slic_write(struct spi_device *spi, u16 addr,\n\t\t       u8 data)\n{\n\tu8 temp[3];\n\n\taddr = bitrev16(addr) >> 1;\n\tdata = bitrev8(data);\n\ttemp[0] = (u8)((addr >> 8) & 0x7f);\n\ttemp[1] = (u8)(addr & 0xfe);\n\ttemp[2] = data;\n\n\t \n\tspi_write(spi, &temp[0], SLIC_THREE_LEN);\n}\n\nstatic u8 slic_read(struct spi_device *spi, u16 addr)\n{\n\tu8 temp[2];\n\tu8 data;\n\n\taddr = bitrev16(addr) >> 1;\n\ttemp[0] = (u8)(((addr >> 8) & 0x7f) | 0x80);\n\ttemp[1] = (u8)(addr & 0xfe);\n\n\tspi_write_then_read(spi, &temp[0], SLIC_TWO_LEN, &data,\n\t\t\t    SLIC_TRANS_LEN);\n\n\tdata = bitrev8(data);\n\treturn data;\n}\n\nstatic bool get_slic_product_code(struct spi_device *spi)\n{\n\tu8 device_id;\n\n\tdevice_id = slic_read(spi, DS26522_IDR_ADDR);\n\tif ((device_id & 0xf8) == 0x68)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic void ds26522_e1_spec_config(struct spi_device *spi)\n{\n\t \n\tslic_write(spi, DS26522_RMMR_ADDR, DS26522_RMMR_E1);\n\n\t \n\tslic_write(spi, DS26522_TMMR_ADDR, DS26522_TMMR_E1);\n\n\t \n\tslic_write(spi, DS26522_RMMR_ADDR,\n\t\t   slic_read(spi, DS26522_RMMR_ADDR) | DS26522_RMMR_FRM_EN);\n\n\t \n\tslic_write(spi, DS26522_TMMR_ADDR,\n\t\t   slic_read(spi, DS26522_TMMR_ADDR) | DS26522_TMMR_FRM_EN);\n\n\t \n\tslic_write(spi, DS26522_RCR1_ADDR,\n\t\t   DS26522_RCR1_E1_HDB3 | DS26522_RCR1_E1_CCS);\n\n\t \n\tslic_write(spi, DS26522_RIOCR_ADDR,\n\t\t   DS26522_RIOCR_2048KHZ | DS26522_RIOCR_RSIO_OUT);\n\n\t \n\tslic_write(spi, DS26522_TCR1_ADDR, DS26522_TCR1_TB8ZS);\n\n\t \n\tslic_write(spi, DS26522_TIOCR_ADDR,\n\t\t   DS26522_TIOCR_2048KHZ | DS26522_TIOCR_TSIO_OUT);\n\n\t \n\tslic_write(spi, DS26522_E1TAF_ADDR, DS26522_E1TAF_DEFAULT);\n\n\t \n\tslic_write(spi, DS26522_E1TNAF_ADDR, DS26522_E1TNAF_DEFAULT);\n\n\t \n\tslic_write(spi, DS26522_RMMR_ADDR, slic_read(spi, DS26522_RMMR_ADDR) |\n\t\t   DS26522_RMMR_INIT_DONE);\n\n\t \n\tslic_write(spi, DS26522_TMMR_ADDR, slic_read(spi, DS26522_TMMR_ADDR) |\n\t\t   DS26522_TMMR_INIT_DONE);\n\n\t \n\tslic_write(spi, DS26522_LTRCR_ADDR, DS26522_LTRCR_E1);\n\n\t \n\tslic_write(spi, DS26522_LTITSR_ADDR,\n\t\t   DS26522_LTITSR_TLIS_75OHM | DS26522_LTITSR_LBOS_75OHM);\n\n\t \n\tslic_write(spi, DS26522_LRISMR_ADDR,\n\t\t   DS26522_LRISMR_75OHM | DS26522_LRISMR_MAX);\n\n\t \n\tslic_write(spi, DS26522_LMCR_ADDR, DS26522_LMCR_TE);\n}\n\nstatic int slic_ds26522_init_configure(struct spi_device *spi)\n{\n\tu16 addr;\n\n\t \n\tslic_write(spi, DS26522_GTCCR_ADDR, DS26522_GTCCR_BPREFSEL_REFCLKIN |\n\t\t\tDS26522_GTCCR_BFREQSEL_2048KHZ |\n\t\t\tDS26522_GTCCR_FREQSEL_2048KHZ);\n\tslic_write(spi, DS26522_GTCR2_ADDR, DS26522_GTCR2_TSSYNCOUT);\n\tslic_write(spi, DS26522_GFCR_ADDR, DS26522_GFCR_BPCLK_2048KHZ);\n\n\t \n\tslic_write(spi, DS26522_GTCR1_ADDR, DS26522_GTCR1);\n\n\t \n\tslic_write(spi, DS26522_GLSRR_ADDR, DS26522_GLSRR_RESET);\n\n\t \n\tslic_write(spi, DS26522_GFSRR_ADDR, DS26522_GFSRR_RESET);\n\n\tusleep_range(100, 120);\n\n\tslic_write(spi, DS26522_GLSRR_ADDR, DS26522_GLSRR_NORMAL);\n\tslic_write(spi, DS26522_GFSRR_ADDR, DS26522_GFSRR_NORMAL);\n\n\t \n\tslic_write(spi, DS26522_RMMR_ADDR, DS26522_RMMR_SFTRST);\n\n\t \n\tslic_write(spi, DS26522_TMMR_ADDR, DS26522_TMMR_SFTRST);\n\n\tusleep_range(100, 120);\n\n\t \n\tfor (addr = DS26522_RF_ADDR_START; addr <= DS26522_RF_ADDR_END;\n\t     addr++)\n\t\tslic_write(spi, addr, 0);\n\n\tfor (addr = DS26522_TF_ADDR_START; addr <= DS26522_TF_ADDR_END;\n\t     addr++)\n\t\tslic_write(spi, addr, 0);\n\n\tfor (addr = DS26522_LIU_ADDR_START; addr <= DS26522_LIU_ADDR_END;\n\t     addr++)\n\t\tslic_write(spi, addr, 0);\n\n\tfor (addr = DS26522_BERT_ADDR_START; addr <= DS26522_BERT_ADDR_END;\n\t     addr++)\n\t\tslic_write(spi, addr, 0);\n\n\t \n\tds26522_e1_spec_config(spi);\n\n\tslic_write(spi, DS26522_GTCR1_ADDR, 0x00);\n\n\treturn 0;\n}\n\nstatic void slic_ds26522_remove(struct spi_device *spi)\n{\n\tpr_info(\"DS26522 module uninstalled\\n\");\n}\n\nstatic int slic_ds26522_probe(struct spi_device *spi)\n{\n\tint ret = 0;\n\n\tg_spi = spi;\n\tspi->bits_per_word = 8;\n\n\tif (!get_slic_product_code(spi))\n\t\treturn ret;\n\n\tret = slic_ds26522_init_configure(spi);\n\tif (ret == 0)\n\t\tpr_info(\"DS26522 cs%d configured\\n\", spi_get_chipselect(spi, 0));\n\n\treturn ret;\n}\n\nstatic const struct spi_device_id slic_ds26522_id[] = {\n\t{ .name = \"ds26522\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(spi, slic_ds26522_id);\n\nstatic const struct of_device_id slic_ds26522_match[] = {\n\t{\n\t .compatible = \"maxim,ds26522\",\n\t },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, slic_ds26522_match);\n\nstatic struct spi_driver slic_ds26522_driver = {\n\t.driver = {\n\t\t   .name = \"ds26522\",\n\t\t   .bus = &spi_bus_type,\n\t\t   .of_match_table = slic_ds26522_match,\n\t\t   },\n\t.probe = slic_ds26522_probe,\n\t.remove = slic_ds26522_remove,\n\t.id_table = slic_ds26522_id,\n};\n\nmodule_spi_driver(slic_ds26522_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}