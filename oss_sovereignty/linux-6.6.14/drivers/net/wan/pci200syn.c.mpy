{
  "module_name": "pci200syn.c",
  "hash_id": "26b1b468f00802d1d2f0ae6a2080dc73927716149d32e9c52b81c0a25df71154",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wan/pci200syn.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/in.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/netdevice.h>\n#include <linux/hdlc.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <asm/io.h>\n\n#include \"hd64572.h\"\n\n#undef DEBUG_PKT\n#define DEBUG_RINGS\n\n#define PCI200SYN_PLX_SIZE\t0x80\t \n#define PCI200SYN_SCA_SIZE\t0x400\t \n#define MAX_TX_BUFFERS\t\t10\n\nstatic int pci_clock_freq = 33000000;\n#define CLOCK_BASE pci_clock_freq\n\n \ntypedef struct {\n\tu32 loc_addr_range[4];\t \n\tu32 loc_rom_range;\t \n\tu32 loc_addr_base[4];\t \n\tu32 loc_rom_base;\t \n\tu32 loc_bus_descr[4];\t \n\tu32 rom_bus_descr;\t \n\tu32 cs_base[4];\t\t \n\tu32 intr_ctrl_stat;\t \n\tu32 init_ctrl;\t\t \n} plx9052;\n\ntypedef struct port_s {\n\tstruct napi_struct napi;\n\tstruct net_device *netdev;\n\tstruct card_s *card;\n\tspinlock_t lock;\t \n\tsync_serial_settings settings;\n\tint rxpart;\t\t \n\tunsigned short encoding;\n\tunsigned short parity;\n\tu16 rxin;\t\t \n\tu16 txin;\t\t \n\tu16 txlast;\n\tu8 rxs, txs, tmc;\t \n\tu8 chan;\t\t \n} port_t;\n\ntypedef struct card_s {\n\tu8 __iomem *rambase;\t \n\tu8 __iomem *scabase;\t \n\tplx9052 __iomem *plxbase; \n\tu16 rx_ring_buffers;\t \n\tu16 tx_ring_buffers;\n\tu16 buff_offset;\t \n\tu8 irq;\t\t\t \n\n\tport_t ports[2];\n} card_t;\n\n#define get_port(card, port)\t     (&(card)->ports[port])\n#define sca_flush(card)\t\t     (sca_in(IER0, card))\n\nstatic inline void new_memcpy_toio(char __iomem *dest, char *src, int length)\n{\n\tint len;\n\n\tdo {\n\t\tlen = length > 256 ? 256 : length;\n\t\tmemcpy_toio(dest, src, len);\n\t\tdest += len;\n\t\tsrc += len;\n\t\tlength -= len;\n\t\treadb(dest);\n\t} while (len);\n}\n\n#undef memcpy_toio\n#define memcpy_toio new_memcpy_toio\n\n#include \"hd64572.c\"\n\nstatic void pci200_set_iface(port_t *port)\n{\n\tcard_t *card = port->card;\n\tu16 msci = get_msci(port);\n\tu8 rxs = port->rxs & CLK_BRG_MASK;\n\tu8 txs = port->txs & CLK_BRG_MASK;\n\n\tsca_out(EXS_TES1, (port->chan ? MSCI1_OFFSET : MSCI0_OFFSET) + EXS,\n\t\tport->card);\n\tswitch (port->settings.clock_type) {\n\tcase CLOCK_INT:\n\t\trxs |= CLK_BRG;  \n\t\ttxs |= CLK_PIN_OUT | CLK_TX_RXCLK;  \n\t\tbreak;\n\n\tcase CLOCK_TXINT:\n\t\trxs |= CLK_LINE;  \n\t\ttxs |= CLK_PIN_OUT | CLK_BRG;  \n\t\tbreak;\n\n\tcase CLOCK_TXFROMRX:\n\t\trxs |= CLK_LINE;  \n\t\ttxs |= CLK_PIN_OUT | CLK_TX_RXCLK;  \n\t\tbreak;\n\n\tdefault:\t\t \n\t\trxs |= CLK_LINE;  \n\t\ttxs |= CLK_PIN_OUT | CLK_LINE;  \n\t\tbreak;\n\t}\n\n\tport->rxs = rxs;\n\tport->txs = txs;\n\tsca_out(rxs, msci + RXS, card);\n\tsca_out(txs, msci + TXS, card);\n\tsca_set_port(port);\n}\n\nstatic int pci200_open(struct net_device *dev)\n{\n\tport_t *port = dev_to_port(dev);\n\tint result = hdlc_open(dev);\n\n\tif (result)\n\t\treturn result;\n\n\tsca_open(dev);\n\tpci200_set_iface(port);\n\tsca_flush(port->card);\n\treturn 0;\n}\n\nstatic int pci200_close(struct net_device *dev)\n{\n\tsca_close(dev);\n\tsca_flush(dev_to_port(dev)->card);\n\thdlc_close(dev);\n\treturn 0;\n}\n\nstatic int pci200_siocdevprivate(struct net_device *dev, struct ifreq *ifr,\n\t\t\t\t void __user *data, int cmd)\n{\n#ifdef DEBUG_RINGS\n\tif (cmd == SIOCDEVPRIVATE) {\n\t\tsca_dump_rings(dev);\n\t\treturn 0;\n\t}\n#endif\n\treturn -EOPNOTSUPP;\n}\n\nstatic int pci200_ioctl(struct net_device *dev, struct if_settings *ifs)\n{\n\tconst size_t size = sizeof(sync_serial_settings);\n\tsync_serial_settings new_line;\n\tsync_serial_settings __user *line = ifs->ifs_ifsu.sync;\n\tport_t *port = dev_to_port(dev);\n\n\tswitch (ifs->type) {\n\tcase IF_GET_IFACE:\n\t\tifs->type = IF_IFACE_V35;\n\t\tif (ifs->size < size) {\n\t\t\tifs->size = size;  \n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tif (copy_to_user(line, &port->settings, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase IF_IFACE_V35:\n\tcase IF_IFACE_SYNC_SERIAL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&new_line, line, size))\n\t\t\treturn -EFAULT;\n\n\t\tif (new_line.clock_type != CLOCK_EXT &&\n\t\t    new_line.clock_type != CLOCK_TXFROMRX &&\n\t\t    new_line.clock_type != CLOCK_INT &&\n\t\t    new_line.clock_type != CLOCK_TXINT)\n\t\t\treturn -EINVAL;\t \n\n\t\tif (new_line.loopback != 0 && new_line.loopback != 1)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(&port->settings, &new_line, size);  \n\t\tpci200_set_iface(port);\n\t\tsca_flush(port->card);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn hdlc_ioctl(dev, ifs);\n\t}\n}\n\nstatic void pci200_pci_remove_one(struct pci_dev *pdev)\n{\n\tint i;\n\tcard_t *card = pci_get_drvdata(pdev);\n\n\tfor (i = 0; i < 2; i++)\n\t\tif (card->ports[i].card)\n\t\t\tunregister_hdlc_device(card->ports[i].netdev);\n\n\tif (card->irq)\n\t\tfree_irq(card->irq, card);\n\n\tif (card->rambase)\n\t\tiounmap(card->rambase);\n\tif (card->scabase)\n\t\tiounmap(card->scabase);\n\tif (card->plxbase)\n\t\tiounmap(card->plxbase);\n\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tif (card->ports[0].netdev)\n\t\tfree_netdev(card->ports[0].netdev);\n\tif (card->ports[1].netdev)\n\t\tfree_netdev(card->ports[1].netdev);\n\tkfree(card);\n}\n\nstatic const struct net_device_ops pci200_ops = {\n\t.ndo_open       = pci200_open,\n\t.ndo_stop       = pci200_close,\n\t.ndo_start_xmit = hdlc_start_xmit,\n\t.ndo_siocwandev = pci200_ioctl,\n\t.ndo_siocdevprivate = pci200_siocdevprivate,\n};\n\nstatic int pci200_pci_init_one(struct pci_dev *pdev,\n\t\t\t       const struct pci_device_id *ent)\n{\n\tcard_t *card;\n\tu32 __iomem *p;\n\tint i;\n\tu32 ramsize;\n\tu32 ramphys;\t\t \n\tu32 scaphys;\t\t \n\tu32 plxphys;\t\t \n\n\ti = pci_enable_device(pdev);\n\tif (i)\n\t\treturn i;\n\n\ti = pci_request_regions(pdev, \"PCI200SYN\");\n\tif (i) {\n\t\tpci_disable_device(pdev);\n\t\treturn i;\n\t}\n\n\tcard = kzalloc(sizeof(card_t), GFP_KERNEL);\n\tif (!card) {\n\t\tpci_release_regions(pdev);\n\t\tpci_disable_device(pdev);\n\t\treturn -ENOBUFS;\n\t}\n\tpci_set_drvdata(pdev, card);\n\tcard->ports[0].netdev = alloc_hdlcdev(&card->ports[0]);\n\tcard->ports[1].netdev = alloc_hdlcdev(&card->ports[1]);\n\tif (!card->ports[0].netdev || !card->ports[1].netdev) {\n\t\tpr_err(\"unable to allocate memory\\n\");\n\t\tpci200_pci_remove_one(pdev);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (pci_resource_len(pdev, 0) != PCI200SYN_PLX_SIZE ||\n\t    pci_resource_len(pdev, 2) != PCI200SYN_SCA_SIZE ||\n\t    pci_resource_len(pdev, 3) < 16384) {\n\t\tpr_err(\"invalid card EEPROM parameters\\n\");\n\t\tpci200_pci_remove_one(pdev);\n\t\treturn -EFAULT;\n\t}\n\n\tplxphys = pci_resource_start(pdev, 0) & PCI_BASE_ADDRESS_MEM_MASK;\n\tcard->plxbase = ioremap(plxphys, PCI200SYN_PLX_SIZE);\n\n\tscaphys = pci_resource_start(pdev, 2) & PCI_BASE_ADDRESS_MEM_MASK;\n\tcard->scabase = ioremap(scaphys, PCI200SYN_SCA_SIZE);\n\n\tramphys = pci_resource_start(pdev, 3) & PCI_BASE_ADDRESS_MEM_MASK;\n\tcard->rambase = pci_ioremap_bar(pdev, 3);\n\n\tif (!card->plxbase || !card->scabase || !card->rambase) {\n\t\tpr_err(\"ioremap() failed\\n\");\n\t\tpci200_pci_remove_one(pdev);\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tp = &card->plxbase->init_ctrl;\n\twritel(readl(p) | 0x40000000, p);\n\treadl(p);\t\t \n\tudelay(1);\n\n\twritel(readl(p) & ~0x40000000, p);\n\treadl(p);\t\t \n\tudelay(1);\n\n\tramsize = sca_detect_ram(card, card->rambase,\n\t\t\t\t pci_resource_len(pdev, 3));\n\n\t \n\ti = ramsize / (2 * (sizeof(pkt_desc) + HDLC_MAX_MRU));\n\tcard->tx_ring_buffers = min(i / 2, MAX_TX_BUFFERS);\n\tcard->rx_ring_buffers = i - card->tx_ring_buffers;\n\n\tcard->buff_offset = 2 * sizeof(pkt_desc) * (card->tx_ring_buffers +\n\t\t\t\t\t\t    card->rx_ring_buffers);\n\n\tpr_info(\"%u KB RAM at 0x%x, IRQ%u, using %u TX + %u RX packets rings\\n\",\n\t\tramsize / 1024, ramphys,\n\t\tpdev->irq, card->tx_ring_buffers, card->rx_ring_buffers);\n\n\tif (card->tx_ring_buffers < 1) {\n\t\tpr_err(\"RAM test failed\\n\");\n\t\tpci200_pci_remove_one(pdev);\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tp = &card->plxbase->intr_ctrl_stat;\n\twritew(readw(p) | 0x0040, p);\n\n\t \n\tif (request_irq(pdev->irq, sca_intr, IRQF_SHARED, \"pci200syn\", card)) {\n\t\tpr_warn(\"could not allocate IRQ%d\\n\", pdev->irq);\n\t\tpci200_pci_remove_one(pdev);\n\t\treturn -EBUSY;\n\t}\n\tcard->irq = pdev->irq;\n\n\tsca_init(card, 0);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tport_t *port = &card->ports[i];\n\t\tstruct net_device *dev = port->netdev;\n\t\thdlc_device *hdlc = dev_to_hdlc(dev);\n\n\t\tport->chan = i;\n\n\t\tspin_lock_init(&port->lock);\n\t\tdev->irq = card->irq;\n\t\tdev->mem_start = ramphys;\n\t\tdev->mem_end = ramphys + ramsize - 1;\n\t\tdev->tx_queue_len = 50;\n\t\tdev->netdev_ops = &pci200_ops;\n\t\thdlc->attach = sca_attach;\n\t\thdlc->xmit = sca_xmit;\n\t\tport->settings.clock_type = CLOCK_EXT;\n\t\tport->card = card;\n\t\tsca_init_port(port);\n\t\tif (register_hdlc_device(dev)) {\n\t\t\tpr_err(\"unable to register hdlc device\\n\");\n\t\t\tport->card = NULL;\n\t\t\tpci200_pci_remove_one(pdev);\n\t\t\treturn -ENOBUFS;\n\t\t}\n\n\t\tnetdev_info(dev, \"PCI200SYN channel %d\\n\", port->chan);\n\t}\n\n\tsca_flush(card);\n\treturn 0;\n}\n\nstatic const struct pci_device_id pci200_pci_tbl[] = {\n\t{ PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9050, PCI_VENDOR_ID_PLX,\n\t  PCI_DEVICE_ID_PLX_PCI200SYN, 0, 0, 0 },\n\t{ 0, }\n};\n\nstatic struct pci_driver pci200_pci_driver = {\n\t.name\t\t= \"PCI200SYN\",\n\t.id_table\t= pci200_pci_tbl,\n\t.probe\t\t= pci200_pci_init_one,\n\t.remove\t\t= pci200_pci_remove_one,\n};\n\nstatic int __init pci200_init_module(void)\n{\n\tif (pci_clock_freq < 1000000 || pci_clock_freq > 80000000) {\n\t\tpr_err(\"Invalid PCI clock frequency\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn pci_register_driver(&pci200_pci_driver);\n}\n\nstatic void __exit pci200_cleanup_module(void)\n{\n\tpci_unregister_driver(&pci200_pci_driver);\n}\n\nMODULE_AUTHOR(\"Krzysztof Halasa <khc@pm.waw.pl>\");\nMODULE_DESCRIPTION(\"Goramo PCI200SYN serial port driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DEVICE_TABLE(pci, pci200_pci_tbl);\nmodule_param(pci_clock_freq, int, 0444);\nMODULE_PARM_DESC(pci_clock_freq, \"System PCI clock frequency in Hz\");\nmodule_init(pci200_init_module);\nmodule_exit(pci200_cleanup_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}