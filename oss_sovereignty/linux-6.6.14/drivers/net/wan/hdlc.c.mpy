{
  "module_name": "hdlc.c",
  "hash_id": "0a5b59af47d606c292274046be24d1c55cd6ff99cbb443ded7ff430622e224e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wan/hdlc.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/errno.h>\n#include <linux/hdlc.h>\n#include <linux/if_arp.h>\n#include <linux/inetdevice.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/pkt_sched.h>\n#include <linux/poll.h>\n#include <linux/rtnetlink.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <net/net_namespace.h>\n\nstatic const char *version = \"HDLC support module revision 1.22\";\n\n#undef DEBUG_LINK\n\nstatic struct hdlc_proto *first_proto;\n\nstatic int hdlc_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t    struct packet_type *p, struct net_device *orig_dev)\n{\n\tstruct hdlc_device *hdlc;\n\n\t \n\tif (!(dev->priv_flags & IFF_WAN_HDLC)) {\n\t\tkfree_skb(skb);\n\t\treturn NET_RX_SUCCESS;\n\t}\n\n\thdlc = dev_to_hdlc(dev);\n\n\tif (!net_eq(dev_net(dev), &init_net)) {\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\tBUG_ON(!hdlc->proto->netif_rx);\n\treturn hdlc->proto->netif_rx(skb);\n}\n\nnetdev_tx_t hdlc_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\n\tif (hdlc->proto->xmit)\n\t\treturn hdlc->proto->xmit(skb, dev);\n\n\treturn hdlc->xmit(skb, dev);  \n}\nEXPORT_SYMBOL(hdlc_start_xmit);\n\nstatic inline void hdlc_proto_start(struct net_device *dev)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\n\tif (hdlc->proto->start)\n\t\thdlc->proto->start(dev);\n}\n\nstatic inline void hdlc_proto_stop(struct net_device *dev)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\n\tif (hdlc->proto->stop)\n\t\thdlc->proto->stop(dev);\n}\n\nstatic int hdlc_device_event(struct notifier_block *this, unsigned long event,\n\t\t\t     void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\thdlc_device *hdlc;\n\tunsigned long flags;\n\tint on;\n\n\tif (!net_eq(dev_net(dev), &init_net))\n\t\treturn NOTIFY_DONE;\n\n\tif (!(dev->priv_flags & IFF_WAN_HDLC))\n\t\treturn NOTIFY_DONE;  \n\n\tif (event != NETDEV_CHANGE)\n\t\treturn NOTIFY_DONE;  \n\n\ton = netif_carrier_ok(dev);\n\n#ifdef DEBUG_LINK\n\tprintk(KERN_DEBUG \"%s: hdlc_device_event NETDEV_CHANGE, carrier %i\\n\",\n\t       dev->name, on);\n#endif\n\n\thdlc = dev_to_hdlc(dev);\n\tspin_lock_irqsave(&hdlc->state_lock, flags);\n\n\tif (hdlc->carrier == on)\n\t\tgoto carrier_exit;  \n\n\thdlc->carrier = on;\n\n\tif (!hdlc->open)\n\t\tgoto carrier_exit;\n\n\tif (hdlc->carrier) {\n\t\tnetdev_info(dev, \"Carrier detected\\n\");\n\t\thdlc_proto_start(dev);\n\t} else {\n\t\tnetdev_info(dev, \"Carrier lost\\n\");\n\t\thdlc_proto_stop(dev);\n\t}\n\ncarrier_exit:\n\tspin_unlock_irqrestore(&hdlc->state_lock, flags);\n\treturn NOTIFY_DONE;\n}\n\n \nint hdlc_open(struct net_device *dev)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n#ifdef DEBUG_LINK\n\tprintk(KERN_DEBUG \"%s: hdlc_open() carrier %i open %i\\n\", dev->name,\n\t       hdlc->carrier, hdlc->open);\n#endif\n\n\tif (!hdlc->proto)\n\t\treturn -ENOSYS;\t \n\n\tif (hdlc->proto->open) {\n\t\tint result = hdlc->proto->open(dev);\n\n\t\tif (result)\n\t\t\treturn result;\n\t}\n\n\tspin_lock_irq(&hdlc->state_lock);\n\n\tif (hdlc->carrier) {\n\t\tnetdev_info(dev, \"Carrier detected\\n\");\n\t\thdlc_proto_start(dev);\n\t} else {\n\t\tnetdev_info(dev, \"No carrier\\n\");\n\t}\n\n\thdlc->open = 1;\n\n\tspin_unlock_irq(&hdlc->state_lock);\n\treturn 0;\n}\nEXPORT_SYMBOL(hdlc_open);\n\n \nvoid hdlc_close(struct net_device *dev)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n#ifdef DEBUG_LINK\n\tprintk(KERN_DEBUG \"%s: hdlc_close() carrier %i open %i\\n\", dev->name,\n\t       hdlc->carrier, hdlc->open);\n#endif\n\n\tspin_lock_irq(&hdlc->state_lock);\n\n\thdlc->open = 0;\n\tif (hdlc->carrier)\n\t\thdlc_proto_stop(dev);\n\n\tspin_unlock_irq(&hdlc->state_lock);\n\n\tif (hdlc->proto->close)\n\t\thdlc->proto->close(dev);\n}\nEXPORT_SYMBOL(hdlc_close);\n\nint hdlc_ioctl(struct net_device *dev, struct if_settings *ifs)\n{\n\tstruct hdlc_proto *proto = first_proto;\n\tint result;\n\n\tif (dev_to_hdlc(dev)->proto) {\n\t\tresult = dev_to_hdlc(dev)->proto->ioctl(dev, ifs);\n\t\tif (result != -EINVAL)\n\t\t\treturn result;\n\t}\n\n\t \n\n\twhile (proto) {\n\t\tresult = proto->ioctl(dev, ifs);\n\t\tif (result != -EINVAL)\n\t\t\treturn result;\n\t\tproto = proto->next;\n\t}\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(hdlc_ioctl);\n\nstatic const struct header_ops hdlc_null_ops;\n\nstatic void hdlc_setup_dev(struct net_device *dev)\n{\n\t \n\tdev->flags\t\t = IFF_POINTOPOINT | IFF_NOARP;\n\tdev->priv_flags\t\t = IFF_WAN_HDLC;\n\tdev->mtu\t\t = HDLC_MAX_MTU;\n\tdev->min_mtu\t\t = 68;\n\tdev->max_mtu\t\t = HDLC_MAX_MTU;\n\tdev->type\t\t = ARPHRD_RAWHDLC;\n\tdev->hard_header_len\t = 0;\n\tdev->needed_headroom\t = 0;\n\tdev->addr_len\t\t = 0;\n\tdev->header_ops\t\t = &hdlc_null_ops;\n}\n\nstatic void hdlc_setup(struct net_device *dev)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\n\thdlc_setup_dev(dev);\n\thdlc->carrier = 1;\n\thdlc->open = 0;\n\tspin_lock_init(&hdlc->state_lock);\n}\n\nstruct net_device *alloc_hdlcdev(void *priv)\n{\n\tstruct net_device *dev;\n\n\tdev = alloc_netdev(sizeof(struct hdlc_device), \"hdlc%d\",\n\t\t\t   NET_NAME_UNKNOWN, hdlc_setup);\n\tif (dev)\n\t\tdev_to_hdlc(dev)->priv = priv;\n\treturn dev;\n}\nEXPORT_SYMBOL(alloc_hdlcdev);\n\nvoid unregister_hdlc_device(struct net_device *dev)\n{\n\trtnl_lock();\n\tdetach_hdlc_protocol(dev);\n\tunregister_netdevice(dev);\n\trtnl_unlock();\n}\nEXPORT_SYMBOL(unregister_hdlc_device);\n\nint attach_hdlc_protocol(struct net_device *dev, struct hdlc_proto *proto,\n\t\t\t size_t size)\n{\n\tint err;\n\n\terr = detach_hdlc_protocol(dev);\n\tif (err)\n\t\treturn err;\n\n\tif (!try_module_get(proto->module))\n\t\treturn -ENOSYS;\n\n\tif (size) {\n\t\tdev_to_hdlc(dev)->state = kmalloc(size, GFP_KERNEL);\n\t\tif (!dev_to_hdlc(dev)->state) {\n\t\t\tmodule_put(proto->module);\n\t\t\treturn -ENOBUFS;\n\t\t}\n\t}\n\tdev_to_hdlc(dev)->proto = proto;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(attach_hdlc_protocol);\n\nint detach_hdlc_protocol(struct net_device *dev)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tint err;\n\n\tif (hdlc->proto) {\n\t\terr = call_netdevice_notifiers(NETDEV_PRE_TYPE_CHANGE, dev);\n\t\terr = notifier_to_errno(err);\n\t\tif (err) {\n\t\t\tnetdev_err(dev, \"Refused to change device type\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\tif (hdlc->proto->detach)\n\t\t\thdlc->proto->detach(dev);\n\t\tmodule_put(hdlc->proto->module);\n\t\thdlc->proto = NULL;\n\t}\n\tkfree(hdlc->state);\n\thdlc->state = NULL;\n\thdlc_setup_dev(dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(detach_hdlc_protocol);\n\nvoid register_hdlc_protocol(struct hdlc_proto *proto)\n{\n\trtnl_lock();\n\tproto->next = first_proto;\n\tfirst_proto = proto;\n\trtnl_unlock();\n}\nEXPORT_SYMBOL(register_hdlc_protocol);\n\nvoid unregister_hdlc_protocol(struct hdlc_proto *proto)\n{\n\tstruct hdlc_proto **p;\n\n\trtnl_lock();\n\tp = &first_proto;\n\twhile (*p != proto) {\n\t\tBUG_ON(!*p);\n\t\tp = &((*p)->next);\n\t}\n\t*p = proto->next;\n\trtnl_unlock();\n}\nEXPORT_SYMBOL(unregister_hdlc_protocol);\n\nMODULE_AUTHOR(\"Krzysztof Halasa <khc@pm.waw.pl>\");\nMODULE_DESCRIPTION(\"HDLC support module\");\nMODULE_LICENSE(\"GPL v2\");\n\nstatic struct packet_type hdlc_packet_type __read_mostly = {\n\t.type = cpu_to_be16(ETH_P_HDLC),\n\t.func = hdlc_rcv,\n};\n\nstatic struct notifier_block hdlc_notifier = {\n\t.notifier_call = hdlc_device_event,\n};\n\nstatic int __init hdlc_module_init(void)\n{\n\tint result;\n\n\tpr_info(\"%s\\n\", version);\n\tresult = register_netdevice_notifier(&hdlc_notifier);\n\tif (result)\n\t\treturn result;\n\tdev_add_pack(&hdlc_packet_type);\n\treturn 0;\n}\n\nstatic void __exit hdlc_module_exit(void)\n{\n\tdev_remove_pack(&hdlc_packet_type);\n\tunregister_netdevice_notifier(&hdlc_notifier);\n}\n\nmodule_init(hdlc_module_init);\nmodule_exit(hdlc_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}