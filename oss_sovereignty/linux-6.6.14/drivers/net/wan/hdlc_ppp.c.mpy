{
  "module_name": "hdlc_ppp.c",
  "hash_id": "ff64315cd1f5b43f0ae5175a470a2403936e5494749aac501d5d16914915894f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wan/hdlc_ppp.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/hdlc.h>\n#include <linux/if_arp.h>\n#include <linux/inetdevice.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pkt_sched.h>\n#include <linux/poll.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#define DEBUG_CP\t\t0  \n#define DEBUG_STATE\t\t0\n#define DEBUG_HARD_HEADER\t0\n\n#define HDLC_ADDR_ALLSTATIONS\t0xFF\n#define HDLC_CTRL_UI\t\t0x03\n\n#define PID_LCP\t\t\t0xC021\n#define PID_IP\t\t\t0x0021\n#define PID_IPCP\t\t0x8021\n#define PID_IPV6\t\t0x0057\n#define PID_IPV6CP\t\t0x8057\n\nenum {IDX_LCP = 0, IDX_IPCP, IDX_IPV6CP, IDX_COUNT};\nenum {CP_CONF_REQ = 1, CP_CONF_ACK, CP_CONF_NAK, CP_CONF_REJ, CP_TERM_REQ,\n      CP_TERM_ACK, CP_CODE_REJ, LCP_PROTO_REJ, LCP_ECHO_REQ, LCP_ECHO_REPLY,\n      LCP_DISC_REQ, CP_CODES};\n#if DEBUG_CP\nstatic const char *const code_names[CP_CODES] = {\n\t\"0\", \"ConfReq\", \"ConfAck\", \"ConfNak\", \"ConfRej\", \"TermReq\",\n\t\"TermAck\", \"CodeRej\", \"ProtoRej\", \"EchoReq\", \"EchoReply\", \"Discard\"\n};\n\nstatic char debug_buffer[64 + 3 * DEBUG_CP];\n#endif\n\nenum {LCP_OPTION_MRU = 1, LCP_OPTION_ACCM, LCP_OPTION_MAGIC = 5};\n\nstruct hdlc_header {\n\tu8 address;\n\tu8 control;\n\t__be16 protocol;\n};\n\nstruct cp_header {\n\tu8 code;\n\tu8 id;\n\t__be16 len;\n};\n\nstruct proto {\n\tstruct net_device *dev;\n\tstruct timer_list timer;\n\tunsigned long timeout;\n\tu16 pid;\t\t \n\tu8 state;\n\tu8 cr_id;\t\t \n\tu8 restart_counter;\n};\n\nstruct ppp {\n\tstruct proto protos[IDX_COUNT];\n\tspinlock_t lock;\n\tunsigned long last_pong;\n\tunsigned int req_timeout, cr_retries, term_retries;\n\tunsigned int keepalive_interval, keepalive_timeout;\n\tu8 seq;\t\t\t \n\tu8 echo_id;\t\t \n};\n\nenum {CLOSED = 0, STOPPED, STOPPING, REQ_SENT, ACK_RECV, ACK_SENT, OPENED,\n      STATES, STATE_MASK = 0xF};\nenum {START = 0, STOP, TO_GOOD, TO_BAD, RCR_GOOD, RCR_BAD, RCA, RCN, RTR, RTA,\n      RUC, RXJ_GOOD, RXJ_BAD, EVENTS};\nenum {INV = 0x10, IRC = 0x20, ZRC = 0x40, SCR = 0x80, SCA = 0x100,\n      SCN = 0x200, STR = 0x400, STA = 0x800, SCJ = 0x1000};\n\n#if DEBUG_STATE\nstatic const char *const state_names[STATES] = {\n\t\"Closed\", \"Stopped\", \"Stopping\", \"ReqSent\", \"AckRecv\", \"AckSent\",\n\t\"Opened\"\n};\n\nstatic const char *const event_names[EVENTS] = {\n\t\"Start\", \"Stop\", \"TO+\", \"TO-\", \"RCR+\", \"RCR-\", \"RCA\", \"RCN\",\n\t\"RTR\", \"RTA\", \"RUC\", \"RXJ+\", \"RXJ-\"\n};\n#endif\n\nstatic struct sk_buff_head tx_queue;  \n\nstatic int ppp_ioctl(struct net_device *dev, struct if_settings *ifs);\n\nstatic inline struct ppp *get_ppp(struct net_device *dev)\n{\n\treturn (struct ppp *)dev_to_hdlc(dev)->state;\n}\n\nstatic inline struct proto *get_proto(struct net_device *dev, u16 pid)\n{\n\tstruct ppp *ppp = get_ppp(dev);\n\n\tswitch (pid) {\n\tcase PID_LCP:\n\t\treturn &ppp->protos[IDX_LCP];\n\tcase PID_IPCP:\n\t\treturn &ppp->protos[IDX_IPCP];\n\tcase PID_IPV6CP:\n\t\treturn &ppp->protos[IDX_IPV6CP];\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic inline const char *proto_name(u16 pid)\n{\n\tswitch (pid) {\n\tcase PID_LCP:\n\t\treturn \"LCP\";\n\tcase PID_IPCP:\n\t\treturn \"IPCP\";\n\tcase PID_IPV6CP:\n\t\treturn \"IPV6CP\";\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nstatic __be16 ppp_type_trans(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct hdlc_header *data = (struct hdlc_header *)skb->data;\n\n\tif (skb->len < sizeof(struct hdlc_header))\n\t\treturn htons(ETH_P_HDLC);\n\tif (data->address != HDLC_ADDR_ALLSTATIONS ||\n\t    data->control != HDLC_CTRL_UI)\n\t\treturn htons(ETH_P_HDLC);\n\n\tswitch (data->protocol) {\n\tcase cpu_to_be16(PID_IP):\n\t\tskb_pull(skb, sizeof(struct hdlc_header));\n\t\treturn htons(ETH_P_IP);\n\n\tcase cpu_to_be16(PID_IPV6):\n\t\tskb_pull(skb, sizeof(struct hdlc_header));\n\t\treturn htons(ETH_P_IPV6);\n\n\tdefault:\n\t\treturn htons(ETH_P_HDLC);\n\t}\n}\n\nstatic int ppp_hard_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\t   u16 type, const void *daddr, const void *saddr,\n\t\t\t   unsigned int len)\n{\n\tstruct hdlc_header *data;\n#if DEBUG_HARD_HEADER\n\tprintk(KERN_DEBUG \"%s: ppp_hard_header() called\\n\", dev->name);\n#endif\n\n\tskb_push(skb, sizeof(struct hdlc_header));\n\tdata = (struct hdlc_header *)skb->data;\n\n\tdata->address = HDLC_ADDR_ALLSTATIONS;\n\tdata->control = HDLC_CTRL_UI;\n\tswitch (type) {\n\tcase ETH_P_IP:\n\t\tdata->protocol = htons(PID_IP);\n\t\tbreak;\n\tcase ETH_P_IPV6:\n\t\tdata->protocol = htons(PID_IPV6);\n\t\tbreak;\n\tcase PID_LCP:\n\tcase PID_IPCP:\n\tcase PID_IPV6CP:\n\t\tdata->protocol = htons(type);\n\t\tbreak;\n\tdefault:\t\t \n\t\tdata->protocol = 0;\n\t}\n\treturn sizeof(struct hdlc_header);\n}\n\nstatic void ppp_tx_flush(void)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(&tx_queue)) != NULL)\n\t\tdev_queue_xmit(skb);\n}\n\nstatic void ppp_tx_cp(struct net_device *dev, u16 pid, u8 code,\n\t\t      u8 id, unsigned int len, const void *data)\n{\n\tstruct sk_buff *skb;\n\tstruct cp_header *cp;\n\tunsigned int magic_len = 0;\n\tstatic u32 magic;\n\n#if DEBUG_CP\n\tint i;\n\tchar *ptr;\n#endif\n\n\tif (pid == PID_LCP && (code == LCP_ECHO_REQ || code == LCP_ECHO_REPLY))\n\t\tmagic_len = sizeof(magic);\n\n\tskb = dev_alloc_skb(sizeof(struct hdlc_header) +\n\t\t\t    sizeof(struct cp_header) + magic_len + len);\n\tif (!skb)\n\t\treturn;\n\n\tskb_reserve(skb, sizeof(struct hdlc_header));\n\n\tcp = skb_put(skb, sizeof(struct cp_header));\n\tcp->code = code;\n\tcp->id = id;\n\tcp->len = htons(sizeof(struct cp_header) + magic_len + len);\n\n\tif (magic_len)\n\t\tskb_put_data(skb, &magic, magic_len);\n\tif (len)\n\t\tskb_put_data(skb, data, len);\n\n#if DEBUG_CP\n\tBUG_ON(code >= CP_CODES);\n\tptr = debug_buffer;\n\t*ptr = '\\x0';\n\tfor (i = 0; i < min_t(unsigned int, magic_len + len, DEBUG_CP); i++) {\n\t\tsprintf(ptr, \" %02X\", skb->data[sizeof(struct cp_header) + i]);\n\t\tptr += strlen(ptr);\n\t}\n\tprintk(KERN_DEBUG \"%s: TX %s [%s id 0x%X]%s\\n\", dev->name,\n\t       proto_name(pid), code_names[code], id, debug_buffer);\n#endif\n\n\tppp_hard_header(skb, dev, pid, NULL, NULL, 0);\n\n\tskb->priority = TC_PRIO_CONTROL;\n\tskb->dev = dev;\n\tskb->protocol = htons(ETH_P_HDLC);\n\tskb_reset_network_header(skb);\n\tskb_queue_tail(&tx_queue, skb);\n}\n\n \nstatic int cp_table[EVENTS][STATES] = {\n\t \n\t{IRC|SCR|3,     INV     , INV ,   INV   , INV ,  INV    ,   INV   },  \n\t{   INV   ,      0      ,  0  ,    0    ,  0  ,   0     ,    0    },  \n\t{   INV   ,     INV     ,STR|2,  SCR|3  ,SCR|3,  SCR|5  ,   INV   },  \n\t{   INV   ,     INV     ,  1  ,    1    ,  1  ,    1    ,   INV   },  \n\t{  STA|0  ,IRC|SCR|SCA|5,  2  ,  SCA|5  ,SCA|6,  SCA|5  ,SCR|SCA|5},  \n\t{  STA|0  ,IRC|SCR|SCN|3,  2  ,  SCN|3  ,SCN|4,  SCN|3  ,SCR|SCN|3},  \n\t{  STA|0  ,    STA|1    ,  2  ,  IRC|4  ,SCR|3,    6    , SCR|3   },  \n\t{  STA|0  ,    STA|1    ,  2  ,IRC|SCR|3,SCR|3,IRC|SCR|5, SCR|3   },  \n\t{  STA|0  ,    STA|1    ,STA|2,  STA|3  ,STA|3,  STA|3  ,ZRC|STA|2},  \n\t{    0    ,      1      ,  1  ,    3    ,  3  ,    5    ,  SCR|3  },  \n\t{  SCJ|0  ,    SCJ|1    ,SCJ|2,  SCJ|3  ,SCJ|4,  SCJ|5  ,  SCJ|6  },  \n\t{    0    ,      1      ,  2  ,    3    ,  3  ,    5    ,    6    },  \n\t{    0    ,      1      ,  1  ,    1    ,  1  ,    1    ,IRC|STR|2},  \n};\n\n \nstatic void ppp_cp_event(struct net_device *dev, u16 pid, u16 event, u8 code,\n\t\t\t u8 id, unsigned int len, const void *data)\n{\n\tint old_state, action;\n\tstruct ppp *ppp = get_ppp(dev);\n\tstruct proto *proto = get_proto(dev, pid);\n\n\told_state = proto->state;\n\tBUG_ON(old_state >= STATES);\n\tBUG_ON(event >= EVENTS);\n\n#if DEBUG_STATE\n\tprintk(KERN_DEBUG \"%s: %s ppp_cp_event(%s) %s ...\\n\", dev->name,\n\t       proto_name(pid), event_names[event], state_names[proto->state]);\n#endif\n\n\taction = cp_table[event][old_state];\n\n\tproto->state = action & STATE_MASK;\n\tif (action & (SCR | STR))  \n\t\tmod_timer(&proto->timer, proto->timeout =\n\t\t\t  jiffies + ppp->req_timeout * HZ);\n\tif (action & ZRC)\n\t\tproto->restart_counter = 0;\n\tif (action & IRC)\n\t\tproto->restart_counter = (proto->state == STOPPING) ?\n\t\t\tppp->term_retries : ppp->cr_retries;\n\n\tif (action & SCR)\t \n\t\tppp_tx_cp(dev, pid, CP_CONF_REQ, proto->cr_id = ++ppp->seq,\n\t\t\t  0, NULL);\n\tif (action & SCA)\t \n\t\tppp_tx_cp(dev, pid, CP_CONF_ACK, id, len, data);\n\tif (action & SCN)\t \n\t\tppp_tx_cp(dev, pid, code, id, len, data);\n\tif (action & STR)\t \n\t\tppp_tx_cp(dev, pid, CP_TERM_REQ, ++ppp->seq, 0, NULL);\n\tif (action & STA)\t \n\t\tppp_tx_cp(dev, pid, CP_TERM_ACK, id, 0, NULL);\n\tif (action & SCJ)\t \n\t\tppp_tx_cp(dev, pid, CP_CODE_REJ, ++ppp->seq, len, data);\n\n\tif (old_state != OPENED && proto->state == OPENED) {\n\t\tnetdev_info(dev, \"%s up\\n\", proto_name(pid));\n\t\tif (pid == PID_LCP) {\n\t\t\tnetif_dormant_off(dev);\n\t\t\tppp_cp_event(dev, PID_IPCP, START, 0, 0, 0, NULL);\n\t\t\tppp_cp_event(dev, PID_IPV6CP, START, 0, 0, 0, NULL);\n\t\t\tppp->last_pong = jiffies;\n\t\t\tmod_timer(&proto->timer, proto->timeout =\n\t\t\t\t  jiffies + ppp->keepalive_interval * HZ);\n\t\t}\n\t}\n\tif (old_state == OPENED && proto->state != OPENED) {\n\t\tnetdev_info(dev, \"%s down\\n\", proto_name(pid));\n\t\tif (pid == PID_LCP) {\n\t\t\tnetif_dormant_on(dev);\n\t\t\tppp_cp_event(dev, PID_IPCP, STOP, 0, 0, 0, NULL);\n\t\t\tppp_cp_event(dev, PID_IPV6CP, STOP, 0, 0, 0, NULL);\n\t\t}\n\t}\n\tif (old_state != CLOSED && proto->state == CLOSED)\n\t\tdel_timer(&proto->timer);\n\n#if DEBUG_STATE\n\tprintk(KERN_DEBUG \"%s: %s ppp_cp_event(%s) ... %s\\n\", dev->name,\n\t       proto_name(pid), event_names[event], state_names[proto->state]);\n#endif\n}\n\nstatic void ppp_cp_parse_cr(struct net_device *dev, u16 pid, u8 id,\n\t\t\t    unsigned int req_len, const u8 *data)\n{\n\tstatic u8 const valid_accm[6] = { LCP_OPTION_ACCM, 6, 0, 0, 0, 0 };\n\tconst u8 *opt;\n\tu8 *out;\n\tunsigned int len = req_len, nak_len = 0, rej_len = 0;\n\n\tout = kmalloc(len, GFP_ATOMIC);\n\tif (!out) {\n\t\tdev->stats.rx_dropped++;\n\t\treturn;\t \n\t}\n\n\tfor (opt = data; len; len -= opt[1], opt += opt[1]) {\n\t\tif (len < 2 || opt[1] < 2 || len < opt[1])\n\t\t\tgoto err_out;\n\n\t\tif (pid == PID_LCP)\n\t\t\tswitch (opt[0]) {\n\t\t\tcase LCP_OPTION_MRU:\n\t\t\t\tcontinue;  \n\n\t\t\tcase LCP_OPTION_ACCM:  \n\t\t\t\tif (opt[1] < sizeof(valid_accm))\n\t\t\t\t\tgoto err_out;\n\t\t\t\tif (!memcmp(opt, valid_accm,\n\t\t\t\t\t    sizeof(valid_accm)))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!rej_len) {  \n\t\t\t\t\tmemcpy(out + nak_len, valid_accm,\n\t\t\t\t\t       sizeof(valid_accm));\n\t\t\t\t\tnak_len += sizeof(valid_accm);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LCP_OPTION_MAGIC:\n\t\t\t\tif (len < 6)\n\t\t\t\t\tgoto err_out;\n\t\t\t\tif (opt[1] != 6 || (!opt[2] && !opt[3] &&\n\t\t\t\t\t\t    !opt[4] && !opt[5]))\n\t\t\t\t\tbreak;  \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t \n\t\tmemcpy(out + rej_len, opt, opt[1]);\n\t\trej_len += opt[1];\n\t}\n\n\tif (rej_len)\n\t\tppp_cp_event(dev, pid, RCR_BAD, CP_CONF_REJ, id, rej_len, out);\n\telse if (nak_len)\n\t\tppp_cp_event(dev, pid, RCR_BAD, CP_CONF_NAK, id, nak_len, out);\n\telse\n\t\tppp_cp_event(dev, pid, RCR_GOOD, CP_CONF_ACK, id, req_len, data);\n\n\tkfree(out);\n\treturn;\n\nerr_out:\n\tdev->stats.rx_errors++;\n\tkfree(out);\n}\n\nstatic int ppp_rx(struct sk_buff *skb)\n{\n\tstruct hdlc_header *hdr = (struct hdlc_header *)skb->data;\n\tstruct net_device *dev = skb->dev;\n\tstruct ppp *ppp = get_ppp(dev);\n\tstruct proto *proto;\n\tstruct cp_header *cp;\n\tunsigned long flags;\n\tunsigned int len;\n\tu16 pid;\n#if DEBUG_CP\n\tint i;\n\tchar *ptr;\n#endif\n\n\tspin_lock_irqsave(&ppp->lock, flags);\n\t \n\tif (skb->len < sizeof(struct hdlc_header))\n\t\tgoto rx_error;\n\tcp = skb_pull(skb, sizeof(struct hdlc_header));\n\tif (hdr->address != HDLC_ADDR_ALLSTATIONS ||\n\t    hdr->control != HDLC_CTRL_UI)\n\t\tgoto rx_error;\n\n\tpid = ntohs(hdr->protocol);\n\tproto = get_proto(dev, pid);\n\tif (!proto) {\n\t\tif (ppp->protos[IDX_LCP].state == OPENED)\n\t\t\tppp_tx_cp(dev, PID_LCP, LCP_PROTO_REJ,\n\t\t\t\t  ++ppp->seq, skb->len + 2, &hdr->protocol);\n\t\tgoto rx_error;\n\t}\n\n\tlen = ntohs(cp->len);\n\tif (len < sizeof(struct cp_header)   ||\n\t    skb->len < len  )\n\t\tgoto rx_error;\n\tskb_pull(skb, sizeof(struct cp_header));\n\tlen -= sizeof(struct cp_header);\n\n\t \n#if DEBUG_CP\n\tif (cp->code < CP_CODES)\n\t\tsprintf(debug_buffer, \"[%s id 0x%X]\", code_names[cp->code],\n\t\t\tcp->id);\n\telse\n\t\tsprintf(debug_buffer, \"[code %u id 0x%X]\", cp->code, cp->id);\n\tptr = debug_buffer + strlen(debug_buffer);\n\tfor (i = 0; i < min_t(unsigned int, len, DEBUG_CP); i++) {\n\t\tsprintf(ptr, \" %02X\", skb->data[i]);\n\t\tptr += strlen(ptr);\n\t}\n\tprintk(KERN_DEBUG \"%s: RX %s %s\\n\", dev->name, proto_name(pid),\n\t       debug_buffer);\n#endif\n\n\t \n\tif (pid == PID_LCP)\n\t\tswitch (cp->code) {\n\t\tcase LCP_PROTO_REJ:\n\t\t\tpid = ntohs(*(__be16 *)skb->data);\n\t\t\tif (pid == PID_LCP || pid == PID_IPCP ||\n\t\t\t    pid == PID_IPV6CP)\n\t\t\t\tppp_cp_event(dev, pid, RXJ_BAD, 0, 0,\n\t\t\t\t\t     0, NULL);\n\t\t\tgoto out;\n\n\t\tcase LCP_ECHO_REQ:  \n\t\t\tif (len >= 4 && proto->state == OPENED)\n\t\t\t\tppp_tx_cp(dev, PID_LCP, LCP_ECHO_REPLY,\n\t\t\t\t\t  cp->id, len - 4, skb->data + 4);\n\t\t\tgoto out;\n\n\t\tcase LCP_ECHO_REPLY:\n\t\t\tif (cp->id == ppp->echo_id)\n\t\t\t\tppp->last_pong = jiffies;\n\t\t\tgoto out;\n\n\t\tcase LCP_DISC_REQ:  \n\t\t\tgoto out;\n\t\t}\n\n\t \n\tswitch (cp->code) {\n\tcase CP_CONF_REQ:\n\t\tppp_cp_parse_cr(dev, pid, cp->id, len, skb->data);\n\t\tbreak;\n\n\tcase CP_CONF_ACK:\n\t\tif (cp->id == proto->cr_id)\n\t\t\tppp_cp_event(dev, pid, RCA, 0, 0, 0, NULL);\n\t\tbreak;\n\n\tcase CP_CONF_REJ:\n\tcase CP_CONF_NAK:\n\t\tif (cp->id == proto->cr_id)\n\t\t\tppp_cp_event(dev, pid, RCN, 0, 0, 0, NULL);\n\t\tbreak;\n\n\tcase CP_TERM_REQ:\n\t\tppp_cp_event(dev, pid, RTR, 0, cp->id, 0, NULL);\n\t\tbreak;\n\n\tcase CP_TERM_ACK:\n\t\tppp_cp_event(dev, pid, RTA, 0, 0, 0, NULL);\n\t\tbreak;\n\n\tcase CP_CODE_REJ:\n\t\tppp_cp_event(dev, pid, RXJ_BAD, 0, 0, 0, NULL);\n\t\tbreak;\n\n\tdefault:\n\t\tlen += sizeof(struct cp_header);\n\t\tif (len > dev->mtu)\n\t\t\tlen = dev->mtu;\n\t\tppp_cp_event(dev, pid, RUC, 0, 0, len, cp);\n\t\tbreak;\n\t}\n\tgoto out;\n\nrx_error:\n\tdev->stats.rx_errors++;\nout:\n\tspin_unlock_irqrestore(&ppp->lock, flags);\n\tdev_kfree_skb_any(skb);\n\tppp_tx_flush();\n\treturn NET_RX_DROP;\n}\n\nstatic void ppp_timer(struct timer_list *t)\n{\n\tstruct proto *proto = from_timer(proto, t, timer);\n\tstruct ppp *ppp = get_ppp(proto->dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ppp->lock, flags);\n\t \n\tif (timer_pending(&proto->timer)) {\n\t\tspin_unlock_irqrestore(&ppp->lock, flags);\n\t\treturn;\n\t}\n\tswitch (proto->state) {\n\tcase STOPPING:\n\tcase REQ_SENT:\n\tcase ACK_RECV:\n\tcase ACK_SENT:\n\t\tif (proto->restart_counter) {\n\t\t\tppp_cp_event(proto->dev, proto->pid, TO_GOOD, 0, 0,\n\t\t\t\t     0, NULL);\n\t\t\tproto->restart_counter--;\n\t\t} else if (netif_carrier_ok(proto->dev))\n\t\t\tppp_cp_event(proto->dev, proto->pid, TO_GOOD, 0, 0,\n\t\t\t\t     0, NULL);\n\t\telse\n\t\t\tppp_cp_event(proto->dev, proto->pid, TO_BAD, 0, 0,\n\t\t\t\t     0, NULL);\n\t\tbreak;\n\n\tcase OPENED:\n\t\tif (proto->pid != PID_LCP)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, ppp->last_pong +\n\t\t\t       ppp->keepalive_timeout * HZ)) {\n\t\t\tnetdev_info(proto->dev, \"Link down\\n\");\n\t\t\tppp_cp_event(proto->dev, PID_LCP, STOP, 0, 0, 0, NULL);\n\t\t\tppp_cp_event(proto->dev, PID_LCP, START, 0, 0, 0, NULL);\n\t\t} else {\t \n\t\t\tppp->echo_id = ++ppp->seq;\n\t\t\tppp_tx_cp(proto->dev, PID_LCP, LCP_ECHO_REQ,\n\t\t\t\t  ppp->echo_id, 0, NULL);\n\t\t\tproto->timer.expires = jiffies +\n\t\t\t\tppp->keepalive_interval * HZ;\n\t\t\tadd_timer(&proto->timer);\n\t\t}\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&ppp->lock, flags);\n\tppp_tx_flush();\n}\n\nstatic void ppp_start(struct net_device *dev)\n{\n\tstruct ppp *ppp = get_ppp(dev);\n\tint i;\n\n\tfor (i = 0; i < IDX_COUNT; i++) {\n\t\tstruct proto *proto = &ppp->protos[i];\n\n\t\tproto->dev = dev;\n\t\ttimer_setup(&proto->timer, ppp_timer, 0);\n\t\tproto->state = CLOSED;\n\t}\n\tppp->protos[IDX_LCP].pid = PID_LCP;\n\tppp->protos[IDX_IPCP].pid = PID_IPCP;\n\tppp->protos[IDX_IPV6CP].pid = PID_IPV6CP;\n\n\tppp_cp_event(dev, PID_LCP, START, 0, 0, 0, NULL);\n}\n\nstatic void ppp_stop(struct net_device *dev)\n{\n\tppp_cp_event(dev, PID_LCP, STOP, 0, 0, 0, NULL);\n}\n\nstatic void ppp_close(struct net_device *dev)\n{\n\tppp_tx_flush();\n}\n\nstatic struct hdlc_proto proto = {\n\t.start\t\t= ppp_start,\n\t.stop\t\t= ppp_stop,\n\t.close\t\t= ppp_close,\n\t.type_trans\t= ppp_type_trans,\n\t.ioctl\t\t= ppp_ioctl,\n\t.netif_rx\t= ppp_rx,\n\t.module\t\t= THIS_MODULE,\n};\n\nstatic const struct header_ops ppp_header_ops = {\n\t.create = ppp_hard_header,\n};\n\nstatic int ppp_ioctl(struct net_device *dev, struct if_settings *ifs)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tstruct ppp *ppp;\n\tint result;\n\n\tswitch (ifs->type) {\n\tcase IF_GET_PROTO:\n\t\tif (dev_to_hdlc(dev)->proto != &proto)\n\t\t\treturn -EINVAL;\n\t\tifs->type = IF_PROTO_PPP;\n\t\treturn 0;  \n\n\tcase IF_PROTO_PPP:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (dev->flags & IFF_UP)\n\t\t\treturn -EBUSY;\n\n\t\t \n\n\t\tresult = hdlc->attach(dev, ENCODING_NRZ,\n\t\t\t\t      PARITY_CRC16_PR1_CCITT);\n\t\tif (result)\n\t\t\treturn result;\n\n\t\tresult = attach_hdlc_protocol(dev, &proto, sizeof(struct ppp));\n\t\tif (result)\n\t\t\treturn result;\n\n\t\tppp = get_ppp(dev);\n\t\tspin_lock_init(&ppp->lock);\n\t\tppp->req_timeout = 2;\n\t\tppp->cr_retries = 10;\n\t\tppp->term_retries = 2;\n\t\tppp->keepalive_interval = 10;\n\t\tppp->keepalive_timeout = 60;\n\n\t\tdev->hard_header_len = sizeof(struct hdlc_header);\n\t\tdev->header_ops = &ppp_header_ops;\n\t\tdev->type = ARPHRD_PPP;\n\t\tcall_netdevice_notifiers(NETDEV_POST_TYPE_CHANGE, dev);\n\t\tnetif_dormant_on(dev);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int __init hdlc_ppp_init(void)\n{\n\tskb_queue_head_init(&tx_queue);\n\tregister_hdlc_protocol(&proto);\n\treturn 0;\n}\n\nstatic void __exit hdlc_ppp_exit(void)\n{\n\tunregister_hdlc_protocol(&proto);\n}\n\nmodule_init(hdlc_ppp_init);\nmodule_exit(hdlc_ppp_exit);\n\nMODULE_AUTHOR(\"Krzysztof Halasa <khc@pm.waw.pl>\");\nMODULE_DESCRIPTION(\"PPP protocol support for generic HDLC\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}