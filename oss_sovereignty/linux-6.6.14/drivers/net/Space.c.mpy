{
  "module_name": "Space.c",
  "hash_id": "accb6bccdeccfba66d6f4c27b7194a4049eeeaa1fecd4c3e30b27802fcdd9e36",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/Space.c",
  "human_readable_source": "\n \n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/netlink.h>\n#include <net/Space.h>\n\n \nstruct netdev_boot_setup {\n\tchar name[IFNAMSIZ];\n\tstruct ifmap map;\n};\n#define NETDEV_BOOT_SETUP_MAX 8\n\n\n \n\n \nstatic struct netdev_boot_setup dev_boot_setup[NETDEV_BOOT_SETUP_MAX];\n\n \nstatic int netdev_boot_setup_add(char *name, struct ifmap *map)\n{\n\tstruct netdev_boot_setup *s;\n\tint i;\n\n\ts = dev_boot_setup;\n\tfor (i = 0; i < NETDEV_BOOT_SETUP_MAX; i++) {\n\t\tif (s[i].name[0] == '\\0' || s[i].name[0] == ' ') {\n\t\t\tmemset(s[i].name, 0, sizeof(s[i].name));\n\t\t\tstrscpy(s[i].name, name, IFNAMSIZ);\n\t\t\tmemcpy(&s[i].map, map, sizeof(s[i].map));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn i >= NETDEV_BOOT_SETUP_MAX ? 0 : 1;\n}\n\n \nint netdev_boot_setup_check(struct net_device *dev)\n{\n\tstruct netdev_boot_setup *s = dev_boot_setup;\n\tint i;\n\n\tfor (i = 0; i < NETDEV_BOOT_SETUP_MAX; i++) {\n\t\tif (s[i].name[0] != '\\0' && s[i].name[0] != ' ' &&\n\t\t    !strcmp(dev->name, s[i].name)) {\n\t\t\tdev->irq = s[i].map.irq;\n\t\t\tdev->base_addr = s[i].map.base_addr;\n\t\t\tdev->mem_start = s[i].map.mem_start;\n\t\t\tdev->mem_end = s[i].map.mem_end;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL(netdev_boot_setup_check);\n\n \nstatic unsigned long netdev_boot_base(const char *prefix, int unit)\n{\n\tconst struct netdev_boot_setup *s = dev_boot_setup;\n\tchar name[IFNAMSIZ];\n\tint i;\n\n\tsprintf(name, \"%s%d\", prefix, unit);\n\n\t \n\tif (__dev_get_by_name(&init_net, name))\n\t\treturn 1;\n\n\tfor (i = 0; i < NETDEV_BOOT_SETUP_MAX; i++)\n\t\tif (!strcmp(name, s[i].name))\n\t\t\treturn s[i].map.base_addr;\n\treturn 0;\n}\n\n \nstatic int __init netdev_boot_setup(char *str)\n{\n\tint ints[5];\n\tstruct ifmap map;\n\n\tstr = get_options(str, ARRAY_SIZE(ints), ints);\n\tif (!str || !*str)\n\t\treturn 0;\n\n\t \n\tmemset(&map, 0, sizeof(map));\n\tif (ints[0] > 0)\n\t\tmap.irq = ints[1];\n\tif (ints[0] > 1)\n\t\tmap.base_addr = ints[2];\n\tif (ints[0] > 2)\n\t\tmap.mem_start = ints[3];\n\tif (ints[0] > 3)\n\t\tmap.mem_end = ints[4];\n\n\t \n\treturn netdev_boot_setup_add(str, &map);\n}\n\n__setup(\"netdev=\", netdev_boot_setup);\n\nstatic int __init ether_boot_setup(char *str)\n{\n\treturn netdev_boot_setup(str);\n}\n__setup(\"ether=\", ether_boot_setup);\n\n\n \n\nstruct devprobe2 {\n\tstruct net_device *(*probe)(int unit);\n\tint status;\t \n};\n\nstatic int __init probe_list2(int unit, struct devprobe2 *p, int autoprobe)\n{\n\tstruct net_device *dev;\n\n\tfor (; p->probe; p++) {\n\t\tif (autoprobe && p->status)\n\t\t\tcontinue;\n\t\tdev = p->probe(unit);\n\t\tif (!IS_ERR(dev))\n\t\t\treturn 0;\n\t\tif (autoprobe)\n\t\t\tp->status = PTR_ERR(dev);\n\t}\n\treturn -ENODEV;\n}\n\n \nstatic struct devprobe2 isa_probes[] __initdata = {\n#ifdef CONFIG_3C515\n\t{tc515_probe, 0},\n#endif\n#ifdef CONFIG_ULTRA\n\t{ultra_probe, 0},\n#endif\n#ifdef CONFIG_WD80x3\n\t{wd_probe, 0},\n#endif\n#if defined(CONFIG_NE2000)  \n\t{ne_probe, 0},\n#endif\n#ifdef CONFIG_LANCE\t\t \n\t{lance_probe, 0},\n#endif\n#ifdef CONFIG_SMC9194\n\t{smc_init, 0},\n#endif\n#ifdef CONFIG_CS89x0_ISA\n\t{cs89x0_probe, 0},\n#endif\n\t{NULL, 0},\n};\n\n \n\nstatic void __init ethif_probe2(int unit)\n{\n\tunsigned long base_addr = netdev_boot_base(\"eth\", unit);\n\n\tif (base_addr == 1)\n\t\treturn;\n\n\tprobe_list2(unit, isa_probes, base_addr == 0);\n}\n\n \nstatic int __init net_olddevs_init(void)\n{\n\tint num;\n\n\tfor (num = 0; num < 8; ++num)\n\t\tethif_probe2(num);\n\n#ifdef CONFIG_COPS\n\tcops_probe(0);\n\tcops_probe(1);\n\tcops_probe(2);\n#endif\n\n\treturn 0;\n}\n\ndevice_initcall(net_olddevs_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}