{
  "module_name": "libipw_wx.c",
  "hash_id": "8225dc5b416c077c058841bb898134c992c69ee54686a9cf67f416bcc00d19ec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/ipw2x00/libipw_wx.c",
  "human_readable_source": "\n \n\n#include <linux/hardirq.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n\n#include <net/lib80211.h>\n#include <linux/wireless.h>\n\n#include \"libipw.h\"\n\nstatic const char *libipw_modes[] = {\n\t\"?\", \"a\", \"b\", \"ab\", \"g\", \"ag\", \"bg\", \"abg\"\n};\n\nstatic inline unsigned int elapsed_jiffies_msecs(unsigned long start)\n{\n\tunsigned long end = jiffies;\n\n\tif (end >= start)\n\t\treturn jiffies_to_msecs(end - start);\n\n\treturn jiffies_to_msecs(end + (MAX_JIFFY_OFFSET - start) + 1);\n}\n\n#define MAX_CUSTOM_LEN 64\nstatic char *libipw_translate_scan(struct libipw_device *ieee,\n\t\t\t\t      char *start, char *stop,\n\t\t\t\t      struct libipw_network *network,\n\t\t\t\t      struct iw_request_info *info)\n{\n\tchar custom[MAX_CUSTOM_LEN];\n\tchar *p;\n\tstruct iw_event iwe;\n\tint i, j;\n\tchar *current_val;\t \n\tu8 rate;\n\n\t \n\tiwe.cmd = SIOCGIWAP;\n\tiwe.u.ap_addr.sa_family = ARPHRD_ETHER;\n\tmemcpy(iwe.u.ap_addr.sa_data, network->bssid, ETH_ALEN);\n\tstart = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_ADDR_LEN);\n\n\t \n\n\t \n\tiwe.cmd = SIOCGIWESSID;\n\tiwe.u.data.flags = 1;\n\tiwe.u.data.length = min(network->ssid_len, (u8) 32);\n\tstart = iwe_stream_add_point(info, start, stop,\n\t\t\t\t     &iwe, network->ssid);\n\n\t \n\tiwe.cmd = SIOCGIWNAME;\n\tsnprintf(iwe.u.name, IFNAMSIZ, \"IEEE 802.11%s\",\n\t\t libipw_modes[network->mode]);\n\tstart = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_CHAR_LEN);\n\n\t \n\tiwe.cmd = SIOCGIWMODE;\n\tif (network->capability & (WLAN_CAPABILITY_ESS | WLAN_CAPABILITY_IBSS)) {\n\t\tif (network->capability & WLAN_CAPABILITY_ESS)\n\t\t\tiwe.u.mode = IW_MODE_MASTER;\n\t\telse\n\t\t\tiwe.u.mode = IW_MODE_ADHOC;\n\n\t\tstart = iwe_stream_add_event(info, start, stop,\n\t\t\t\t\t     &iwe, IW_EV_UINT_LEN);\n\t}\n\n\t \n\t \n\tiwe.cmd = SIOCGIWFREQ;\n\tiwe.u.freq.m = libipw_channel_to_freq(ieee, network->channel);\n\tiwe.u.freq.e = 6;\n\tiwe.u.freq.i = 0;\n\tstart = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_FREQ_LEN);\n\n\t \n\tiwe.cmd = SIOCGIWENCODE;\n\tif (network->capability & WLAN_CAPABILITY_PRIVACY)\n\t\tiwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;\n\telse\n\t\tiwe.u.data.flags = IW_ENCODE_DISABLED;\n\tiwe.u.data.length = 0;\n\tstart = iwe_stream_add_point(info, start, stop,\n\t\t\t\t     &iwe, network->ssid);\n\n\t \n\t \n\tcurrent_val = start + iwe_stream_lcp_len(info);\n\tiwe.cmd = SIOCGIWRATE;\n\t \n\tiwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;\n\n\tfor (i = 0, j = 0; i < network->rates_len;) {\n\t\tif (j < network->rates_ex_len &&\n\t\t    ((network->rates_ex[j] & 0x7F) <\n\t\t     (network->rates[i] & 0x7F)))\n\t\t\trate = network->rates_ex[j++] & 0x7F;\n\t\telse\n\t\t\trate = network->rates[i++] & 0x7F;\n\t\t \n\t\tiwe.u.bitrate.value = ((rate & 0x7f) * 500000);\n\t\t \n\t\tcurrent_val = iwe_stream_add_value(info, start, current_val,\n\t\t\t\t\t\t   stop, &iwe, IW_EV_PARAM_LEN);\n\t}\n\tfor (; j < network->rates_ex_len; j++) {\n\t\trate = network->rates_ex[j] & 0x7F;\n\t\t \n\t\tiwe.u.bitrate.value = ((rate & 0x7f) * 500000);\n\t\t \n\t\tcurrent_val = iwe_stream_add_value(info, start, current_val,\n\t\t\t\t\t\t   stop, &iwe, IW_EV_PARAM_LEN);\n\t}\n\t \n\tif ((current_val - start) > iwe_stream_lcp_len(info))\n\t\tstart = current_val;\n\n\t \n\tiwe.cmd = IWEVQUAL;\n\tiwe.u.qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED |\n\t    IW_QUAL_NOISE_UPDATED;\n\n\tif (!(network->stats.mask & LIBIPW_STATMASK_RSSI)) {\n\t\tiwe.u.qual.updated |= IW_QUAL_QUAL_INVALID |\n\t\t    IW_QUAL_LEVEL_INVALID;\n\t\tiwe.u.qual.qual = 0;\n\t} else {\n\t\tif (ieee->perfect_rssi == ieee->worst_rssi)\n\t\t\tiwe.u.qual.qual = 100;\n\t\telse\n\t\t\tiwe.u.qual.qual =\n\t\t\t    (100 *\n\t\t\t     (ieee->perfect_rssi - ieee->worst_rssi) *\n\t\t\t     (ieee->perfect_rssi - ieee->worst_rssi) -\n\t\t\t     (ieee->perfect_rssi - network->stats.rssi) *\n\t\t\t     (15 * (ieee->perfect_rssi - ieee->worst_rssi) +\n\t\t\t      62 * (ieee->perfect_rssi -\n\t\t\t\t    network->stats.rssi))) /\n\t\t\t    ((ieee->perfect_rssi -\n\t\t\t      ieee->worst_rssi) * (ieee->perfect_rssi -\n\t\t\t\t\t\t   ieee->worst_rssi));\n\t\tif (iwe.u.qual.qual > 100)\n\t\t\tiwe.u.qual.qual = 100;\n\t\telse if (iwe.u.qual.qual < 1)\n\t\t\tiwe.u.qual.qual = 0;\n\t}\n\n\tif (!(network->stats.mask & LIBIPW_STATMASK_NOISE)) {\n\t\tiwe.u.qual.updated |= IW_QUAL_NOISE_INVALID;\n\t\tiwe.u.qual.noise = 0;\n\t} else {\n\t\tiwe.u.qual.noise = network->stats.noise;\n\t}\n\n\tif (!(network->stats.mask & LIBIPW_STATMASK_SIGNAL)) {\n\t\tiwe.u.qual.updated |= IW_QUAL_LEVEL_INVALID;\n\t\tiwe.u.qual.level = 0;\n\t} else {\n\t\tiwe.u.qual.level = network->stats.signal;\n\t}\n\n\tstart = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_QUAL_LEN);\n\n\tiwe.cmd = IWEVCUSTOM;\n\tp = custom;\n\n\tiwe.u.data.length = p - custom;\n\tif (iwe.u.data.length)\n\t\tstart = iwe_stream_add_point(info, start, stop, &iwe, custom);\n\n\tmemset(&iwe, 0, sizeof(iwe));\n\tif (network->wpa_ie_len) {\n\t\tchar buf[MAX_WPA_IE_LEN];\n\t\tmemcpy(buf, network->wpa_ie, network->wpa_ie_len);\n\t\tiwe.cmd = IWEVGENIE;\n\t\tiwe.u.data.length = network->wpa_ie_len;\n\t\tstart = iwe_stream_add_point(info, start, stop, &iwe, buf);\n\t}\n\n\tmemset(&iwe, 0, sizeof(iwe));\n\tif (network->rsn_ie_len) {\n\t\tchar buf[MAX_WPA_IE_LEN];\n\t\tmemcpy(buf, network->rsn_ie, network->rsn_ie_len);\n\t\tiwe.cmd = IWEVGENIE;\n\t\tiwe.u.data.length = network->rsn_ie_len;\n\t\tstart = iwe_stream_add_point(info, start, stop, &iwe, buf);\n\t}\n\n\t \n\tiwe.cmd = IWEVCUSTOM;\n\tp = custom;\n\tp += scnprintf(p, MAX_CUSTOM_LEN - (p - custom),\n\t\t      \" Last beacon: %ums ago\",\n\t\t      elapsed_jiffies_msecs(network->last_scanned));\n\tiwe.u.data.length = p - custom;\n\tif (iwe.u.data.length)\n\t\tstart = iwe_stream_add_point(info, start, stop, &iwe, custom);\n\n\t \n\tiwe.cmd = -1;\n\tp = custom;\n\tp += scnprintf(p, MAX_CUSTOM_LEN - (p - custom), \" Channel flags: \");\n\n\tif (libipw_get_channel_flags(ieee, network->channel) &\n\t    LIBIPW_CH_INVALID) {\n\t\tiwe.cmd = IWEVCUSTOM;\n\t\tp += scnprintf(p, MAX_CUSTOM_LEN - (p - custom), \"INVALID \");\n\t}\n\n\tif (libipw_get_channel_flags(ieee, network->channel) &\n\t    LIBIPW_CH_RADAR_DETECT) {\n\t\tiwe.cmd = IWEVCUSTOM;\n\t\tp += scnprintf(p, MAX_CUSTOM_LEN - (p - custom), \"DFS \");\n\t}\n\n\tif (iwe.cmd == IWEVCUSTOM) {\n\t\tiwe.u.data.length = p - custom;\n\t\tstart = iwe_stream_add_point(info, start, stop, &iwe, custom);\n\t}\n\n\treturn start;\n}\n\n#define SCAN_ITEM_SIZE 128\n\nint libipw_wx_get_scan(struct libipw_device *ieee,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct libipw_network *network;\n\tunsigned long flags;\n\tint err = 0;\n\n\tchar *ev = extra;\n\tchar *stop = ev + wrqu->data.length;\n\tint i = 0;\n\n\tLIBIPW_DEBUG_WX(\"Getting scan\\n\");\n\n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\tlist_for_each_entry(network, &ieee->network_list, list) {\n\t\ti++;\n\t\tif (stop - ev < SCAN_ITEM_SIZE) {\n\t\t\terr = -E2BIG;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ieee->scan_age == 0 ||\n\t\t    time_after(network->last_scanned + ieee->scan_age, jiffies))\n\t\t\tev = libipw_translate_scan(ieee, ev, stop, network,\n\t\t\t\t\t\t      info);\n\t\telse {\n\t\t\tLIBIPW_DEBUG_SCAN(\"Not showing network '%*pE (%pM)' due to age (%ums).\\n\",\n\t\t\t\t\t  network->ssid_len, network->ssid,\n\t\t\t\t\t  network->bssid,\n\t\t\t\t\t  elapsed_jiffies_msecs(\n\t\t\t\t\t               network->last_scanned));\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n\n\twrqu->data.length = ev - extra;\n\twrqu->data.flags = 0;\n\n\tLIBIPW_DEBUG_WX(\"exit: %d networks returned.\\n\", i);\n\n\treturn err;\n}\n\nint libipw_wx_set_encode(struct libipw_device *ieee,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *keybuf)\n{\n\tstruct iw_point *erq = &(wrqu->encoding);\n\tstruct net_device *dev = ieee->dev;\n\tstruct libipw_security sec = {\n\t\t.flags = 0\n\t};\n\tint i, key, key_provided, len;\n\tstruct lib80211_crypt_data **crypt;\n\tint host_crypto = ieee->host_encrypt || ieee->host_decrypt;\n\n\tLIBIPW_DEBUG_WX(\"SET_ENCODE\\n\");\n\n\tkey = erq->flags & IW_ENCODE_INDEX;\n\tif (key) {\n\t\tif (key > WEP_KEYS)\n\t\t\treturn -EINVAL;\n\t\tkey--;\n\t\tkey_provided = 1;\n\t} else {\n\t\tkey_provided = 0;\n\t\tkey = ieee->crypt_info.tx_keyidx;\n\t}\n\n\tLIBIPW_DEBUG_WX(\"Key: %d [%s]\\n\", key, key_provided ?\n\t\t\t   \"provided\" : \"default\");\n\n\tcrypt = &ieee->crypt_info.crypt[key];\n\n\tif (erq->flags & IW_ENCODE_DISABLED) {\n\t\tif (key_provided && *crypt) {\n\t\t\tLIBIPW_DEBUG_WX(\"Disabling encryption on key %d.\\n\",\n\t\t\t\t\t   key);\n\t\t\tlib80211_crypt_delayed_deinit(&ieee->crypt_info, crypt);\n\t\t} else\n\t\t\tLIBIPW_DEBUG_WX(\"Disabling encryption.\\n\");\n\n\t\t \n\t\tfor (i = 0; i < WEP_KEYS; i++) {\n\t\t\tif (ieee->crypt_info.crypt[i] != NULL) {\n\t\t\t\tif (key_provided)\n\t\t\t\t\tbreak;\n\t\t\t\tlib80211_crypt_delayed_deinit(&ieee->crypt_info,\n\t\t\t\t\t\t\t       &ieee->crypt_info.crypt[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (i == WEP_KEYS) {\n\t\t\tsec.enabled = 0;\n\t\t\tsec.encrypt = 0;\n\t\t\tsec.level = SEC_LEVEL_0;\n\t\t\tsec.flags |= SEC_ENABLED | SEC_LEVEL | SEC_ENCRYPT;\n\t\t}\n\n\t\tgoto done;\n\t}\n\n\tsec.enabled = 1;\n\tsec.encrypt = 1;\n\tsec.flags |= SEC_ENABLED | SEC_ENCRYPT;\n\n\tif (*crypt != NULL && (*crypt)->ops != NULL &&\n\t    strcmp((*crypt)->ops->name, \"WEP\") != 0) {\n\t\t \n\t\tlib80211_crypt_delayed_deinit(&ieee->crypt_info, crypt);\n\t}\n\n\tif (*crypt == NULL && host_crypto) {\n\t\tstruct lib80211_crypt_data *new_crypt;\n\n\t\t \n\t\tnew_crypt = kzalloc(sizeof(struct lib80211_crypt_data),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (new_crypt == NULL)\n\t\t\treturn -ENOMEM;\n\t\tnew_crypt->ops = lib80211_get_crypto_ops(\"WEP\");\n\t\tif (!new_crypt->ops) {\n\t\t\trequest_module(\"lib80211_crypt_wep\");\n\t\t\tnew_crypt->ops = lib80211_get_crypto_ops(\"WEP\");\n\t\t}\n\n\t\tif (new_crypt->ops && try_module_get(new_crypt->ops->owner))\n\t\t\tnew_crypt->priv = new_crypt->ops->init(key);\n\n\t\tif (!new_crypt->ops || !new_crypt->priv) {\n\t\t\tkfree(new_crypt);\n\t\t\tnew_crypt = NULL;\n\n\t\t\tprintk(KERN_WARNING \"%s: could not initialize WEP: \"\n\t\t\t       \"load module lib80211_crypt_wep\\n\", dev->name);\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\t*crypt = new_crypt;\n\t}\n\n\t \n\tif (erq->length > 0) {\n\t\tlen = erq->length <= 5 ? 5 : 13;\n\t\tmemcpy(sec.keys[key], keybuf, erq->length);\n\t\tif (len > erq->length)\n\t\t\tmemset(sec.keys[key] + erq->length, 0,\n\t\t\t       len - erq->length);\n\t\tLIBIPW_DEBUG_WX(\"Setting key %d to '%*pE' (%d:%d bytes)\\n\",\n\t\t\t\t   key, len, sec.keys[key],\n\t\t\t\t   erq->length, len);\n\t\tsec.key_sizes[key] = len;\n\t\tif (*crypt)\n\t\t\t(*crypt)->ops->set_key(sec.keys[key], len, NULL,\n\t\t\t\t\t       (*crypt)->priv);\n\t\tsec.flags |= (1 << key);\n\t\t \n\t\tif (key == sec.active_key)\n\t\t\tsec.flags |= SEC_ACTIVE_KEY;\n\n\t} else {\n\t\tif (host_crypto) {\n\t\t\tlen = (*crypt)->ops->get_key(sec.keys[key], WEP_KEY_LEN,\n\t\t\t\t\t\t     NULL, (*crypt)->priv);\n\t\t\tif (len == 0) {\n\t\t\t\t \n\t\t\t\tLIBIPW_DEBUG_WX(\"Setting key %d to all \"\n\t\t\t\t\t\t   \"zero.\\n\", key);\n\t\t\t\tmemset(sec.keys[key], 0, 13);\n\t\t\t\t(*crypt)->ops->set_key(sec.keys[key], 13, NULL,\n\t\t\t\t\t\t       (*crypt)->priv);\n\t\t\t\tsec.key_sizes[key] = 13;\n\t\t\t\tsec.flags |= (1 << key);\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (key_provided) {\n\t\t\tLIBIPW_DEBUG_WX(\"Setting key %d to default Tx \"\n\t\t\t\t\t   \"key.\\n\", key);\n\t\t\tieee->crypt_info.tx_keyidx = key;\n\t\t\tsec.active_key = key;\n\t\t\tsec.flags |= SEC_ACTIVE_KEY;\n\t\t}\n\t}\n\tif (erq->flags & (IW_ENCODE_OPEN | IW_ENCODE_RESTRICTED)) {\n\t\tieee->open_wep = !(erq->flags & IW_ENCODE_RESTRICTED);\n\t\tsec.auth_mode = ieee->open_wep ? WLAN_AUTH_OPEN :\n\t\t    WLAN_AUTH_SHARED_KEY;\n\t\tsec.flags |= SEC_AUTH_MODE;\n\t\tLIBIPW_DEBUG_WX(\"Auth: %s\\n\",\n\t\t\t\t   sec.auth_mode == WLAN_AUTH_OPEN ?\n\t\t\t\t   \"OPEN\" : \"SHARED KEY\");\n\t}\n\n\t \n\tsec.flags |= SEC_LEVEL;\n\tsec.level = SEC_LEVEL_1;\t \n\tsec.encode_alg[key] = SEC_ALG_WEP;\n\n      done:\n\tif (ieee->set_security)\n\t\tieee->set_security(dev, &sec);\n\n\treturn 0;\n}\n\nint libipw_wx_get_encode(struct libipw_device *ieee,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *keybuf)\n{\n\tstruct iw_point *erq = &(wrqu->encoding);\n\tint len, key;\n\tstruct libipw_security *sec = &ieee->sec;\n\n\tLIBIPW_DEBUG_WX(\"GET_ENCODE\\n\");\n\n\tkey = erq->flags & IW_ENCODE_INDEX;\n\tif (key) {\n\t\tif (key > WEP_KEYS)\n\t\t\treturn -EINVAL;\n\t\tkey--;\n\t} else\n\t\tkey = ieee->crypt_info.tx_keyidx;\n\n\terq->flags = key + 1;\n\n\tif (!sec->enabled) {\n\t\terq->length = 0;\n\t\terq->flags |= IW_ENCODE_DISABLED;\n\t\treturn 0;\n\t}\n\n\tlen = sec->key_sizes[key];\n\tmemcpy(keybuf, sec->keys[key], len);\n\n\terq->length = len;\n\terq->flags |= IW_ENCODE_ENABLED;\n\n\tif (ieee->open_wep)\n\t\terq->flags |= IW_ENCODE_OPEN;\n\telse\n\t\terq->flags |= IW_ENCODE_RESTRICTED;\n\n\treturn 0;\n}\n\nint libipw_wx_set_encodeext(struct libipw_device *ieee,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct net_device *dev = ieee->dev;\n\tstruct iw_point *encoding = &wrqu->encoding;\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\n\tint i, idx, ret = 0;\n\tint group_key = 0;\n\tconst char *alg, *module;\n\tstruct lib80211_crypto_ops *ops;\n\tstruct lib80211_crypt_data **crypt;\n\n\tstruct libipw_security sec = {\n\t\t.flags = 0,\n\t};\n\n\tidx = encoding->flags & IW_ENCODE_INDEX;\n\tif (idx) {\n\t\tif (idx < 1 || idx > WEP_KEYS)\n\t\t\treturn -EINVAL;\n\t\tidx--;\n\t} else\n\t\tidx = ieee->crypt_info.tx_keyidx;\n\n\tif (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) {\n\t\tcrypt = &ieee->crypt_info.crypt[idx];\n\t\tgroup_key = 1;\n\t} else {\n\t\t \n\t\tif (idx != 0 && ext->alg != IW_ENCODE_ALG_WEP)\n\t\t\treturn -EINVAL;\n\t\tif (ieee->iw_mode == IW_MODE_INFRA)\n\t\t\tcrypt = &ieee->crypt_info.crypt[idx];\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tsec.flags |= SEC_ENABLED | SEC_ENCRYPT;\n\tif ((encoding->flags & IW_ENCODE_DISABLED) ||\n\t    ext->alg == IW_ENCODE_ALG_NONE) {\n\t\tif (*crypt)\n\t\t\tlib80211_crypt_delayed_deinit(&ieee->crypt_info, crypt);\n\n\t\tfor (i = 0; i < WEP_KEYS; i++)\n\t\t\tif (ieee->crypt_info.crypt[i] != NULL)\n\t\t\t\tbreak;\n\n\t\tif (i == WEP_KEYS) {\n\t\t\tsec.enabled = 0;\n\t\t\tsec.encrypt = 0;\n\t\t\tsec.level = SEC_LEVEL_0;\n\t\t\tsec.flags |= SEC_LEVEL;\n\t\t}\n\t\tgoto done;\n\t}\n\n\tsec.enabled = 1;\n\tsec.encrypt = 1;\n\n\tif (group_key ? !ieee->host_mc_decrypt :\n\t    !(ieee->host_encrypt || ieee->host_decrypt ||\n\t      ieee->host_encrypt_msdu))\n\t\tgoto skip_host_crypt;\n\n\tswitch (ext->alg) {\n\tcase IW_ENCODE_ALG_WEP:\n\t\talg = \"WEP\";\n\t\tmodule = \"lib80211_crypt_wep\";\n\t\tbreak;\n\tcase IW_ENCODE_ALG_TKIP:\n\t\talg = \"TKIP\";\n\t\tmodule = \"lib80211_crypt_tkip\";\n\t\tbreak;\n\tcase IW_ENCODE_ALG_CCMP:\n\t\talg = \"CCMP\";\n\t\tmodule = \"lib80211_crypt_ccmp\";\n\t\tbreak;\n\tdefault:\n\t\tLIBIPW_DEBUG_WX(\"%s: unknown crypto alg %d\\n\",\n\t\t\t\t   dev->name, ext->alg);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tops = lib80211_get_crypto_ops(alg);\n\tif (ops == NULL) {\n\t\trequest_module(module);\n\t\tops = lib80211_get_crypto_ops(alg);\n\t}\n\tif (ops == NULL) {\n\t\tLIBIPW_DEBUG_WX(\"%s: unknown crypto alg %d\\n\",\n\t\t\t\t   dev->name, ext->alg);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (*crypt == NULL || (*crypt)->ops != ops) {\n\t\tstruct lib80211_crypt_data *new_crypt;\n\n\t\tlib80211_crypt_delayed_deinit(&ieee->crypt_info, crypt);\n\n\t\tnew_crypt = kzalloc(sizeof(*new_crypt), GFP_KERNEL);\n\t\tif (new_crypt == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t\tnew_crypt->ops = ops;\n\t\tif (new_crypt->ops && try_module_get(new_crypt->ops->owner))\n\t\t\tnew_crypt->priv = new_crypt->ops->init(idx);\n\t\tif (new_crypt->priv == NULL) {\n\t\t\tkfree(new_crypt);\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\t*crypt = new_crypt;\n\t}\n\n\tif (ext->key_len > 0 && (*crypt)->ops->set_key &&\n\t    (*crypt)->ops->set_key(ext->key, ext->key_len, ext->rx_seq,\n\t\t\t\t   (*crypt)->priv) < 0) {\n\t\tLIBIPW_DEBUG_WX(\"%s: key setting failed\\n\", dev->name);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n      skip_host_crypt:\n\tif (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {\n\t\tieee->crypt_info.tx_keyidx = idx;\n\t\tsec.active_key = idx;\n\t\tsec.flags |= SEC_ACTIVE_KEY;\n\t}\n\n\tif (ext->alg != IW_ENCODE_ALG_NONE) {\n\t\tint key_len = clamp_val(ext->key_len, 0, SCM_KEY_LEN);\n\n\t\tmemcpy(sec.keys[idx], ext->key, key_len);\n\t\tsec.key_sizes[idx] = key_len;\n\t\tsec.flags |= (1 << idx);\n\t\tif (ext->alg == IW_ENCODE_ALG_WEP) {\n\t\t\tsec.encode_alg[idx] = SEC_ALG_WEP;\n\t\t\tsec.flags |= SEC_LEVEL;\n\t\t\tsec.level = SEC_LEVEL_1;\n\t\t} else if (ext->alg == IW_ENCODE_ALG_TKIP) {\n\t\t\tsec.encode_alg[idx] = SEC_ALG_TKIP;\n\t\t\tsec.flags |= SEC_LEVEL;\n\t\t\tsec.level = SEC_LEVEL_2;\n\t\t} else if (ext->alg == IW_ENCODE_ALG_CCMP) {\n\t\t\tsec.encode_alg[idx] = SEC_ALG_CCMP;\n\t\t\tsec.flags |= SEC_LEVEL;\n\t\t\tsec.level = SEC_LEVEL_3;\n\t\t}\n\t\t \n\t\tif (group_key)\n\t\t\tsec.flags &= ~SEC_LEVEL;\n\t}\n      done:\n\tif (ieee->set_security)\n\t\tieee->set_security(dev, &sec);\n\n\treturn ret;\n}\n\nint libipw_wx_get_encodeext(struct libipw_device *ieee,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct iw_point *encoding = &wrqu->encoding;\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\n\tstruct libipw_security *sec = &ieee->sec;\n\tint idx, max_key_len;\n\n\tmax_key_len = encoding->length - sizeof(*ext);\n\tif (max_key_len < 0)\n\t\treturn -EINVAL;\n\n\tidx = encoding->flags & IW_ENCODE_INDEX;\n\tif (idx) {\n\t\tif (idx < 1 || idx > WEP_KEYS)\n\t\t\treturn -EINVAL;\n\t\tidx--;\n\t} else\n\t\tidx = ieee->crypt_info.tx_keyidx;\n\n\tif (!(ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) &&\n\t    ext->alg != IW_ENCODE_ALG_WEP)\n\t\tif (idx != 0 || ieee->iw_mode != IW_MODE_INFRA)\n\t\t\treturn -EINVAL;\n\n\tencoding->flags = idx + 1;\n\tmemset(ext, 0, sizeof(*ext));\n\n\tif (!sec->enabled) {\n\t\text->alg = IW_ENCODE_ALG_NONE;\n\t\text->key_len = 0;\n\t\tencoding->flags |= IW_ENCODE_DISABLED;\n\t} else {\n\t\tif (sec->encode_alg[idx] == SEC_ALG_WEP)\n\t\t\text->alg = IW_ENCODE_ALG_WEP;\n\t\telse if (sec->encode_alg[idx] == SEC_ALG_TKIP)\n\t\t\text->alg = IW_ENCODE_ALG_TKIP;\n\t\telse if (sec->encode_alg[idx] == SEC_ALG_CCMP)\n\t\t\text->alg = IW_ENCODE_ALG_CCMP;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\text->key_len = sec->key_sizes[idx];\n\t\tmemcpy(ext->key, sec->keys[idx], ext->key_len);\n\t\tencoding->flags |= IW_ENCODE_ENABLED;\n\t\tif (ext->key_len &&\n\t\t    (ext->alg == IW_ENCODE_ALG_TKIP ||\n\t\t     ext->alg == IW_ENCODE_ALG_CCMP))\n\t\t\text->ext_flags |= IW_ENCODE_EXT_TX_SEQ_VALID;\n\n\t}\n\n\treturn 0;\n}\n\nEXPORT_SYMBOL(libipw_wx_set_encodeext);\nEXPORT_SYMBOL(libipw_wx_get_encodeext);\n\nEXPORT_SYMBOL(libipw_wx_get_scan);\nEXPORT_SYMBOL(libipw_wx_set_encode);\nEXPORT_SYMBOL(libipw_wx_get_encode);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}