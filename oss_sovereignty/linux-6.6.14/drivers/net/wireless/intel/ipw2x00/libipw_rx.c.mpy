{
  "module_name": "libipw_rx.c",
  "hash_id": "5b54788b41093a8819d3aa8961b76d8b05a3112b8577891d4b5e3f1ded1d568c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/ipw2x00/libipw_rx.c",
  "human_readable_source": "\n \n\n#include <linux/compiler.h>\n#include <linux/errno.h>\n#include <linux/if_arp.h>\n#include <linux/in6.h>\n#include <linux/gfp.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/proc_fs.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/types.h>\n#include <linux/wireless.h>\n#include <linux/etherdevice.h>\n#include <linux/uaccess.h>\n#include <linux/ctype.h>\n\n#include <net/lib80211.h>\n\n#include \"libipw.h\"\n\nstatic void libipw_monitor_rx(struct libipw_device *ieee,\n\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\tstruct libipw_rx_stats *rx_stats)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tu16 fc = le16_to_cpu(hdr->frame_control);\n\n\tskb->dev = ieee->dev;\n\tskb_reset_mac_header(skb);\n\tskb_pull(skb, libipw_get_hdrlen(fc));\n\tskb->pkt_type = PACKET_OTHERHOST;\n\tskb->protocol = htons(ETH_P_80211_RAW);\n\tmemset(skb->cb, 0, sizeof(skb->cb));\n\tnetif_rx(skb);\n}\n\n \nstatic struct libipw_frag_entry *libipw_frag_cache_find(struct\n\t\t\t\t\t\t\t      libipw_device\n\t\t\t\t\t\t\t      *ieee,\n\t\t\t\t\t\t\t      unsigned int seq,\n\t\t\t\t\t\t\t      unsigned int frag,\n\t\t\t\t\t\t\t      u8 * src,\n\t\t\t\t\t\t\t      u8 * dst)\n{\n\tstruct libipw_frag_entry *entry;\n\tint i;\n\n\tfor (i = 0; i < LIBIPW_FRAG_CACHE_LEN; i++) {\n\t\tentry = &ieee->frag_cache[i];\n\t\tif (entry->skb != NULL &&\n\t\t    time_after(jiffies, entry->first_frag_time + 2 * HZ)) {\n\t\t\tLIBIPW_DEBUG_FRAG(\"expiring fragment cache entry \"\n\t\t\t\t\t     \"seq=%u last_frag=%u\\n\",\n\t\t\t\t\t     entry->seq, entry->last_frag);\n\t\t\tdev_kfree_skb_any(entry->skb);\n\t\t\tentry->skb = NULL;\n\t\t}\n\n\t\tif (entry->skb != NULL && entry->seq == seq &&\n\t\t    (entry->last_frag + 1 == frag || frag == -1) &&\n\t\t    ether_addr_equal(entry->src_addr, src) &&\n\t\t    ether_addr_equal(entry->dst_addr, dst))\n\t\t\treturn entry;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct sk_buff *libipw_frag_cache_get(struct libipw_device *ieee,\n\t\t\t\t\t\tstruct libipw_hdr_4addr *hdr)\n{\n\tstruct sk_buff *skb = NULL;\n\tu16 sc;\n\tunsigned int frag, seq;\n\tstruct libipw_frag_entry *entry;\n\n\tsc = le16_to_cpu(hdr->seq_ctl);\n\tfrag = WLAN_GET_SEQ_FRAG(sc);\n\tseq = WLAN_GET_SEQ_SEQ(sc);\n\n\tif (frag == 0) {\n\t\t \n\t\tskb = dev_alloc_skb(ieee->dev->mtu +\n\t\t\t\t    sizeof(struct libipw_hdr_4addr) +\n\t\t\t\t    8    +\n\t\t\t\t    2    +\n\t\t\t\t    8    + ETH_ALEN   );\n\t\tif (skb == NULL)\n\t\t\treturn NULL;\n\n\t\tentry = &ieee->frag_cache[ieee->frag_next_idx];\n\t\tieee->frag_next_idx++;\n\t\tif (ieee->frag_next_idx >= LIBIPW_FRAG_CACHE_LEN)\n\t\t\tieee->frag_next_idx = 0;\n\n\t\tif (entry->skb != NULL)\n\t\t\tdev_kfree_skb_any(entry->skb);\n\n\t\tentry->first_frag_time = jiffies;\n\t\tentry->seq = seq;\n\t\tentry->last_frag = frag;\n\t\tentry->skb = skb;\n\t\tmemcpy(entry->src_addr, hdr->addr2, ETH_ALEN);\n\t\tmemcpy(entry->dst_addr, hdr->addr1, ETH_ALEN);\n\t} else {\n\t\t \n\t\tentry = libipw_frag_cache_find(ieee, seq, frag, hdr->addr2,\n\t\t\t\t\t\t  hdr->addr1);\n\t\tif (entry != NULL) {\n\t\t\tentry->last_frag = frag;\n\t\t\tskb = entry->skb;\n\t\t}\n\t}\n\n\treturn skb;\n}\n\n \nstatic int libipw_frag_cache_invalidate(struct libipw_device *ieee,\n\t\t\t\t\t   struct libipw_hdr_4addr *hdr)\n{\n\tu16 sc;\n\tunsigned int seq;\n\tstruct libipw_frag_entry *entry;\n\n\tsc = le16_to_cpu(hdr->seq_ctl);\n\tseq = WLAN_GET_SEQ_SEQ(sc);\n\n\tentry = libipw_frag_cache_find(ieee, seq, -1, hdr->addr2,\n\t\t\t\t\t  hdr->addr1);\n\n\tif (entry == NULL) {\n\t\tLIBIPW_DEBUG_FRAG(\"could not invalidate fragment cache \"\n\t\t\t\t     \"entry (seq=%u)\\n\", seq);\n\t\treturn -1;\n\t}\n\n\tentry->skb = NULL;\n\treturn 0;\n}\n\n#ifdef NOT_YET\n \nstatic int\nlibipw_rx_frame_mgmt(struct libipw_device *ieee, struct sk_buff *skb,\n\t\t\tstruct libipw_rx_stats *rx_stats, u16 type,\n\t\t\tu16 stype)\n{\n\tif (ieee->iw_mode == IW_MODE_MASTER) {\n\t\tprintk(KERN_DEBUG \"%s: Master mode not yet supported.\\n\",\n\t\t       ieee->dev->name);\n\t\treturn 0;\n \n\t}\n\n\tif (ieee->hostapd && type == WLAN_FC_TYPE_MGMT) {\n\t\tif (stype == WLAN_FC_STYPE_BEACON &&\n\t\t    ieee->iw_mode == IW_MODE_MASTER) {\n\t\t\tstruct sk_buff *skb2;\n\t\t\t \n\t\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (skb2)\n\t\t\t\thostap_rx(skb2->dev, skb2, rx_stats);\n\t\t}\n\n\t\t \n\t\tieee->apdevstats.rx_packets++;\n\t\tieee->apdevstats.rx_bytes += skb->len;\n\t\tprism2_rx_80211(ieee->apdev, skb, rx_stats, PRISM2_RX_MGMT);\n\t\treturn 0;\n\t}\n\n\tif (ieee->iw_mode == IW_MODE_MASTER) {\n\t\tif (type != WLAN_FC_TYPE_MGMT && type != WLAN_FC_TYPE_CTRL) {\n\t\t\tprintk(KERN_DEBUG \"%s: unknown management frame \"\n\t\t\t       \"(type=0x%02x, stype=0x%02x) dropped\\n\",\n\t\t\t       skb->dev->name, type, stype);\n\t\t\treturn -1;\n\t\t}\n\n\t\thostap_rx(skb->dev, skb, rx_stats);\n\t\treturn 0;\n\t}\n\n\tprintk(KERN_DEBUG \"%s: hostap_rx_frame_mgmt: management frame \"\n\t       \"received in non-Host AP mode\\n\", skb->dev->name);\n\treturn -1;\n}\n#endif\n\n \n \nstatic unsigned char libipw_rfc1042_header[] =\n    { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };\n\n \nstatic unsigned char libipw_bridge_tunnel_header[] =\n    { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0xf8 };\n \n\n \nstatic int libipw_is_eapol_frame(struct libipw_device *ieee,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct net_device *dev = ieee->dev;\n\tu16 fc, ethertype;\n\tstruct libipw_hdr_3addr *hdr;\n\tu8 *pos;\n\n\tif (skb->len < 24)\n\t\treturn 0;\n\n\thdr = (struct libipw_hdr_3addr *)skb->data;\n\tfc = le16_to_cpu(hdr->frame_ctl);\n\n\t \n\tif ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\n\t    IEEE80211_FCTL_TODS &&\n\t    ether_addr_equal(hdr->addr1, dev->dev_addr) &&\n\t    ether_addr_equal(hdr->addr3, dev->dev_addr)) {\n\t\t \n\t} else if ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\n\t\t   IEEE80211_FCTL_FROMDS &&\n\t\t   ether_addr_equal(hdr->addr1, dev->dev_addr)) {\n\t\t \n\t} else\n\t\treturn 0;\n\n\tif (skb->len < 24 + 8)\n\t\treturn 0;\n\n\t \n\tpos = skb->data + 24;\n\tethertype = (pos[6] << 8) | pos[7];\n\tif (ethertype == ETH_P_PAE)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic int\nlibipw_rx_frame_decrypt(struct libipw_device *ieee, struct sk_buff *skb,\n\t\t\t   struct lib80211_crypt_data *crypt)\n{\n\tstruct libipw_hdr_3addr *hdr;\n\tint res, hdrlen;\n\n\tif (crypt == NULL || crypt->ops->decrypt_mpdu == NULL)\n\t\treturn 0;\n\n\thdr = (struct libipw_hdr_3addr *)skb->data;\n\thdrlen = libipw_get_hdrlen(le16_to_cpu(hdr->frame_ctl));\n\n\tatomic_inc(&crypt->refcnt);\n\tres = crypt->ops->decrypt_mpdu(skb, hdrlen, crypt->priv);\n\tatomic_dec(&crypt->refcnt);\n\tif (res < 0) {\n\t\tLIBIPW_DEBUG_DROP(\"decryption failed (SA=%pM) res=%d\\n\",\n\t\t\t\t     hdr->addr2, res);\n\t\tif (res == -2)\n\t\t\tLIBIPW_DEBUG_DROP(\"Decryption failed ICV \"\n\t\t\t\t\t     \"mismatch (key %d)\\n\",\n\t\t\t\t\t     skb->data[hdrlen + 3] >> 6);\n\t\tieee->ieee_stats.rx_discards_undecryptable++;\n\t\treturn -1;\n\t}\n\n\treturn res;\n}\n\n \nstatic int\nlibipw_rx_frame_decrypt_msdu(struct libipw_device *ieee,\n\t\t\t\tstruct sk_buff *skb, int keyidx,\n\t\t\t\tstruct lib80211_crypt_data *crypt)\n{\n\tstruct libipw_hdr_3addr *hdr;\n\tint res, hdrlen;\n\n\tif (crypt == NULL || crypt->ops->decrypt_msdu == NULL)\n\t\treturn 0;\n\n\thdr = (struct libipw_hdr_3addr *)skb->data;\n\thdrlen = libipw_get_hdrlen(le16_to_cpu(hdr->frame_ctl));\n\n\tatomic_inc(&crypt->refcnt);\n\tres = crypt->ops->decrypt_msdu(skb, keyidx, hdrlen, crypt->priv);\n\tatomic_dec(&crypt->refcnt);\n\tif (res < 0) {\n\t\tprintk(KERN_DEBUG \"%s: MSDU decryption/MIC verification failed\"\n\t\t       \" (SA=%pM keyidx=%d)\\n\", ieee->dev->name, hdr->addr2,\n\t\t       keyidx);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nint libipw_rx(struct libipw_device *ieee, struct sk_buff *skb,\n\t\t struct libipw_rx_stats *rx_stats)\n{\n\tstruct net_device *dev = ieee->dev;\n\tstruct libipw_hdr_4addr *hdr;\n\tsize_t hdrlen;\n\tu16 fc, type, stype, sc;\n\tunsigned int frag;\n\tu8 *payload;\n\tu16 ethertype;\n#ifdef NOT_YET\n\tstruct net_device *wds = NULL;\n\tstruct sk_buff *skb2 = NULL;\n\tstruct net_device *wds = NULL;\n\tint frame_authorized = 0;\n\tint from_assoc_ap = 0;\n\tvoid *sta = NULL;\n#endif\n\tu8 dst[ETH_ALEN];\n\tu8 src[ETH_ALEN];\n\tstruct lib80211_crypt_data *crypt = NULL;\n\tint keyidx = 0;\n\tint can_be_decrypted = 0;\n\n\thdr = (struct libipw_hdr_4addr *)skb->data;\n\tif (skb->len < 10) {\n\t\tprintk(KERN_INFO \"%s: SKB length < 10\\n\", dev->name);\n\t\tgoto rx_dropped;\n\t}\n\n\tfc = le16_to_cpu(hdr->frame_ctl);\n\ttype = WLAN_FC_GET_TYPE(fc);\n\tstype = WLAN_FC_GET_STYPE(fc);\n\tsc = le16_to_cpu(hdr->seq_ctl);\n\tfrag = WLAN_GET_SEQ_FRAG(sc);\n\thdrlen = libipw_get_hdrlen(fc);\n\n\tif (skb->len < hdrlen) {\n\t\tprintk(KERN_INFO \"%s: invalid SKB length %d\\n\",\n\t\t\tdev->name, skb->len);\n\t\tgoto rx_dropped;\n\t}\n\n\t \n#ifdef CONFIG_WIRELESS_EXT\n#ifdef IW_WIRELESS_SPY\t\t \n\t \n\tif (ieee->spy_data.spy_number > 0) {\n\t\tstruct iw_quality wstats;\n\n\t\twstats.updated = 0;\n\t\tif (rx_stats->mask & LIBIPW_STATMASK_RSSI) {\n\t\t\twstats.level = rx_stats->signal;\n\t\t\twstats.updated |= IW_QUAL_LEVEL_UPDATED;\n\t\t} else\n\t\t\twstats.updated |= IW_QUAL_LEVEL_INVALID;\n\n\t\tif (rx_stats->mask & LIBIPW_STATMASK_NOISE) {\n\t\t\twstats.noise = rx_stats->noise;\n\t\t\twstats.updated |= IW_QUAL_NOISE_UPDATED;\n\t\t} else\n\t\t\twstats.updated |= IW_QUAL_NOISE_INVALID;\n\n\t\tif (rx_stats->mask & LIBIPW_STATMASK_SIGNAL) {\n\t\t\twstats.qual = rx_stats->signal;\n\t\t\twstats.updated |= IW_QUAL_QUAL_UPDATED;\n\t\t} else\n\t\t\twstats.updated |= IW_QUAL_QUAL_INVALID;\n\n\t\t \n\t\twireless_spy_update(ieee->dev, hdr->addr2, &wstats);\n\t}\n#endif\t\t\t\t \n#endif\t\t\t\t \n\n#ifdef NOT_YET\n\thostap_update_rx_stats(local->ap, hdr, rx_stats);\n#endif\n\n\tif (ieee->iw_mode == IW_MODE_MONITOR) {\n\t\tdev->stats.rx_packets++;\n\t\tdev->stats.rx_bytes += skb->len;\n\t\tlibipw_monitor_rx(ieee, skb, rx_stats);\n\t\treturn 1;\n\t}\n\n\tcan_be_decrypted = (is_multicast_ether_addr(hdr->addr1) ||\n\t\t\t    is_broadcast_ether_addr(hdr->addr2)) ?\n\t    ieee->host_mc_decrypt : ieee->host_decrypt;\n\n\tif (can_be_decrypted) {\n\t\tif (skb->len >= hdrlen + 3) {\n\t\t\t \n\t\t\tkeyidx = skb->data[hdrlen + 3] >> 6;\n\t\t}\n\n\t\t \n\t\tcrypt = ieee->crypt_info.crypt[keyidx];\n\n#ifdef NOT_YET\n\t\tsta = NULL;\n\n\t\t \n\n\t\tif (is_unicast_ether_addr(hdr->addr1) || local->bcrx_sta_key)\n\t\t\t(void)hostap_handle_sta_crypto(local, hdr, &crypt,\n\t\t\t\t\t\t       &sta);\n#endif\n\n\t\t \n\t\tif (crypt && (crypt->ops == NULL ||\n\t\t\t      crypt->ops->decrypt_mpdu == NULL))\n\t\t\tcrypt = NULL;\n\n\t\tif (!crypt && (fc & IEEE80211_FCTL_PROTECTED)) {\n\t\t\t \n\t\t\tLIBIPW_DEBUG_DROP(\"Decryption failed (not set)\"\n\t\t\t\t\t     \" (SA=%pM)\\n\", hdr->addr2);\n\t\t\tieee->ieee_stats.rx_discards_undecryptable++;\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n#ifdef NOT_YET\n\tif (type != WLAN_FC_TYPE_DATA) {\n\t\tif (type == WLAN_FC_TYPE_MGMT && stype == WLAN_FC_STYPE_AUTH &&\n\t\t    fc & IEEE80211_FCTL_PROTECTED && ieee->host_decrypt &&\n\t\t    (keyidx = hostap_rx_frame_decrypt(ieee, skb, crypt)) < 0) {\n\t\t\tprintk(KERN_DEBUG \"%s: failed to decrypt mgmt::auth \"\n\t\t\t       \"from %pM\\n\", dev->name, hdr->addr2);\n\t\t\t \n\t\t\tgoto rx_dropped;\n\t\t}\n\n\t\tif (libipw_rx_frame_mgmt(ieee, skb, rx_stats, type, stype))\n\t\t\tgoto rx_dropped;\n\t\telse\n\t\t\tgoto rx_exit;\n\t}\n#endif\n\t \n\tif (sc == ieee->prev_seq_ctl)\n\t\tgoto rx_dropped;\n\telse\n\t\tieee->prev_seq_ctl = sc;\n\n\t \n\tif (skb->len < LIBIPW_3ADDR_LEN)\n\t\tgoto rx_dropped;\n\n\tswitch (fc & (IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS)) {\n\tcase IEEE80211_FCTL_FROMDS:\n\t\tmemcpy(dst, hdr->addr1, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr3, ETH_ALEN);\n\t\tbreak;\n\tcase IEEE80211_FCTL_TODS:\n\t\tmemcpy(dst, hdr->addr3, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr2, ETH_ALEN);\n\t\tbreak;\n\tcase IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS:\n\t\tif (skb->len < LIBIPW_4ADDR_LEN)\n\t\t\tgoto rx_dropped;\n\t\tmemcpy(dst, hdr->addr3, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr4, ETH_ALEN);\n\t\tbreak;\n\tdefault:\n\t\tmemcpy(dst, hdr->addr1, ETH_ALEN);\n\t\tmemcpy(src, hdr->addr2, ETH_ALEN);\n\t\tbreak;\n\t}\n\n#ifdef NOT_YET\n\tif (hostap_rx_frame_wds(ieee, hdr, fc, &wds))\n\t\tgoto rx_dropped;\n\tif (wds) {\n\t\tskb->dev = dev = wds;\n\t\tstats = hostap_get_stats(dev);\n\t}\n\n\tif (ieee->iw_mode == IW_MODE_MASTER && !wds &&\n\t    (fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\n\t    IEEE80211_FCTL_FROMDS && ieee->stadev &&\n\t    ether_addr_equal(hdr->addr2, ieee->assoc_ap_addr)) {\n\t\t \n\t\tskb->dev = dev = ieee->stadev;\n\t\tstats = hostap_get_stats(dev);\n\t\tfrom_assoc_ap = 1;\n\t}\n#endif\n\n#ifdef NOT_YET\n\tif ((ieee->iw_mode == IW_MODE_MASTER ||\n\t     ieee->iw_mode == IW_MODE_REPEAT) && !from_assoc_ap) {\n\t\tswitch (hostap_handle_sta_rx(ieee, dev, skb, rx_stats,\n\t\t\t\t\t     wds != NULL)) {\n\t\tcase AP_RX_CONTINUE_NOT_AUTHORIZED:\n\t\t\tframe_authorized = 0;\n\t\t\tbreak;\n\t\tcase AP_RX_CONTINUE:\n\t\t\tframe_authorized = 1;\n\t\t\tbreak;\n\t\tcase AP_RX_DROP:\n\t\t\tgoto rx_dropped;\n\t\tcase AP_RX_EXIT:\n\t\t\tgoto rx_exit;\n\t\t}\n\t}\n#endif\n\n\t \n\n\tstype &= ~IEEE80211_STYPE_QOS_DATA;\n\n\tif (stype != IEEE80211_STYPE_DATA &&\n\t    stype != IEEE80211_STYPE_DATA_CFACK &&\n\t    stype != IEEE80211_STYPE_DATA_CFPOLL &&\n\t    stype != IEEE80211_STYPE_DATA_CFACKPOLL) {\n\t\tif (stype != IEEE80211_STYPE_NULLFUNC)\n\t\t\tLIBIPW_DEBUG_DROP(\"RX: dropped data frame \"\n\t\t\t\t\t     \"with no data (type=0x%02x, \"\n\t\t\t\t\t     \"subtype=0x%02x, len=%d)\\n\",\n\t\t\t\t\t     type, stype, skb->len);\n\t\tgoto rx_dropped;\n\t}\n\n\t \n\n\tif ((fc & IEEE80211_FCTL_PROTECTED) && can_be_decrypted &&\n\t    (keyidx = libipw_rx_frame_decrypt(ieee, skb, crypt)) < 0)\n\t\tgoto rx_dropped;\n\n\thdr = (struct libipw_hdr_4addr *)skb->data;\n\n\t \n\t\n\t\n\tif ((frag != 0) || (fc & IEEE80211_FCTL_MOREFRAGS)) {\n\t\tint flen;\n\t\tstruct sk_buff *frag_skb = libipw_frag_cache_get(ieee, hdr);\n\t\tLIBIPW_DEBUG_FRAG(\"Rx Fragment received (%u)\\n\", frag);\n\n\t\tif (!frag_skb) {\n\t\t\tLIBIPW_DEBUG(LIBIPW_DL_RX | LIBIPW_DL_FRAG,\n\t\t\t\t\t\"Rx cannot get skb from fragment \"\n\t\t\t\t\t\"cache (morefrag=%d seq=%u frag=%u)\\n\",\n\t\t\t\t\t(fc & IEEE80211_FCTL_MOREFRAGS) != 0,\n\t\t\t\t\tWLAN_GET_SEQ_SEQ(sc), frag);\n\t\t\tgoto rx_dropped;\n\t\t}\n\n\t\tflen = skb->len;\n\t\tif (frag != 0)\n\t\t\tflen -= hdrlen;\n\n\t\tif (frag_skb->tail + flen > frag_skb->end) {\n\t\t\tprintk(KERN_WARNING \"%s: host decrypted and \"\n\t\t\t       \"reassembled frame did not fit skb\\n\",\n\t\t\t       dev->name);\n\t\t\tlibipw_frag_cache_invalidate(ieee, hdr);\n\t\t\tgoto rx_dropped;\n\t\t}\n\n\t\tif (frag == 0) {\n\t\t\t \n\t\t\tskb_copy_from_linear_data(skb, skb_put(frag_skb, flen), flen);\n\t\t} else {\n\t\t\t \n\t\t\tskb_copy_from_linear_data_offset(skb, hdrlen,\n\t\t\t\t      skb_put(frag_skb, flen), flen);\n\t\t}\n\t\tdev_kfree_skb_any(skb);\n\t\tskb = NULL;\n\n\t\tif (fc & IEEE80211_FCTL_MOREFRAGS) {\n\t\t\t \n\t\t\tgoto rx_exit;\n\t\t}\n\n\t\t \n\t\tskb = frag_skb;\n\t\thdr = (struct libipw_hdr_4addr *)skb->data;\n\t\tlibipw_frag_cache_invalidate(ieee, hdr);\n\t}\n\n\t \n\tif ((fc & IEEE80211_FCTL_PROTECTED) && can_be_decrypted &&\n\t    libipw_rx_frame_decrypt_msdu(ieee, skb, keyidx, crypt))\n\t\tgoto rx_dropped;\n\n\thdr = (struct libipw_hdr_4addr *)skb->data;\n\tif (crypt && !(fc & IEEE80211_FCTL_PROTECTED) && !ieee->open_wep) {\n\t\tif (\t\t \n\t\t\t   libipw_is_eapol_frame(ieee, skb)) {\n\t\t\t \n\t\t} else {\n\t\t\tLIBIPW_DEBUG_DROP(\"encryption configured, but RX \"\n\t\t\t\t\t     \"frame not encrypted (SA=%pM)\\n\",\n\t\t\t\t\t     hdr->addr2);\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n\n\tif (crypt && !(fc & IEEE80211_FCTL_PROTECTED) && !ieee->open_wep &&\n\t    !libipw_is_eapol_frame(ieee, skb)) {\n\t\tLIBIPW_DEBUG_DROP(\"dropped unencrypted RX data \"\n\t\t\t\t     \"frame from %pM (drop_unencrypted=1)\\n\",\n\t\t\t\t     hdr->addr2);\n\t\tgoto rx_dropped;\n\t}\n\n\t \n\tif (!can_be_decrypted && (fc & IEEE80211_FCTL_PROTECTED) &&\n\t    ieee->host_strip_iv_icv) {\n\t\tint trimlen = 0;\n\n\t\t \n\t\tif (skb->len >= hdrlen + 3)\n\t\t\tkeyidx = skb->data[hdrlen + 3] >> 6;\n\n\t\t \n\n\t\tswitch (ieee->sec.encode_alg[keyidx]) {\n\t\tcase SEC_ALG_WEP:\n\t\t\t \n\t\t\thdrlen += 4;\n\t\t\t \n\t\t\ttrimlen = 4;\n\t\t\tbreak;\n\t\tcase SEC_ALG_TKIP:\n\t\t\t \n\t\t\thdrlen += 8;\n\t\t\t \n\t\t\ttrimlen = 12;\n\t\t\tbreak;\n\t\tcase SEC_ALG_CCMP:\n\t\t\t \n\t\t\thdrlen += 8;\n\t\t\t \n\t\t\ttrimlen = 8;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (skb->len < trimlen)\n\t\t\tgoto rx_dropped;\n\n\t\t__skb_trim(skb, skb->len - trimlen);\n\n\t\tif (skb->len < hdrlen)\n\t\t\tgoto rx_dropped;\n\t}\n\n\t \n\n\tpayload = skb->data + hdrlen;\n\tethertype = (payload[6] << 8) | payload[7];\n\n#ifdef NOT_YET\n\t \n\tif (ieee->ieee802_1x && ieee->iw_mode == IW_MODE_MASTER) {\n\t\tif (ethertype == ETH_P_PAE) {\n\t\t\tprintk(KERN_DEBUG \"%s: RX: IEEE 802.1X frame\\n\",\n\t\t\t       dev->name);\n\t\t\tif (ieee->hostapd && ieee->apdev) {\n\t\t\t\t \n\t\t\t\tprism2_rx_80211(ieee->apdev, skb, rx_stats,\n\t\t\t\t\t\tPRISM2_RX_MGMT);\n\t\t\t\tieee->apdevstats.rx_packets++;\n\t\t\t\tieee->apdevstats.rx_bytes += skb->len;\n\t\t\t\tgoto rx_exit;\n\t\t\t}\n\t\t} else if (!frame_authorized) {\n\t\t\tprintk(KERN_DEBUG \"%s: dropped frame from \"\n\t\t\t       \"unauthorized port (IEEE 802.1X): \"\n\t\t\t       \"ethertype=0x%04x\\n\", dev->name, ethertype);\n\t\t\tgoto rx_dropped;\n\t\t}\n\t}\n#endif\n\n\t \n\tif (skb->len - hdrlen >= 8 &&\n\t    ((memcmp(payload, libipw_rfc1042_header, SNAP_SIZE) == 0 &&\n\t      ethertype != ETH_P_AARP && ethertype != ETH_P_IPX) ||\n\t     memcmp(payload, libipw_bridge_tunnel_header, SNAP_SIZE) == 0)) {\n\t\t \n\t\tskb_pull(skb, hdrlen + SNAP_SIZE);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);\n\t} else {\n\t\t__be16 len;\n\t\t \n\t\tskb_pull(skb, hdrlen);\n\t\tlen = htons(skb->len);\n\t\tmemcpy(skb_push(skb, 2), &len, 2);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), src, ETH_ALEN);\n\t\tmemcpy(skb_push(skb, ETH_ALEN), dst, ETH_ALEN);\n\t}\n\n#ifdef NOT_YET\n\tif (wds && ((fc & (IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) ==\n\t\t    IEEE80211_FCTL_TODS) && skb->len >= ETH_HLEN + ETH_ALEN) {\n\t\t \n\t\tskb_copy_to_linear_data_offset(skb, ETH_ALEN,\n\t\t\t\t\t       skb->data + skb->len - ETH_ALEN,\n\t\t\t\t\t       ETH_ALEN);\n\t\tskb_trim(skb, skb->len - ETH_ALEN);\n\t}\n#endif\n\n\tdev->stats.rx_packets++;\n\tdev->stats.rx_bytes += skb->len;\n\n#ifdef NOT_YET\n\tif (ieee->iw_mode == IW_MODE_MASTER && !wds && ieee->ap->bridge_packets) {\n\t\tif (is_multicast_ether_addr(dst)) {\n\t\t\t \n\t\t\tieee->ap->bridged_multicast++;\n\t\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (skb2 == NULL)\n\t\t\t\tprintk(KERN_DEBUG \"%s: skb_clone failed for \"\n\t\t\t\t       \"multicast frame\\n\", dev->name);\n\t\t} else if (hostap_is_sta_assoc(ieee->ap, dst)) {\n\t\t\t \n\t\t\tieee->ap->bridged_unicast++;\n\t\t\tskb2 = skb;\n\t\t\tskb = NULL;\n\t\t}\n\t}\n\n\tif (skb2 != NULL) {\n\t\t \n\t\tskb2->dev = dev;\n\t\tskb2->protocol = htons(ETH_P_802_3);\n\t\tskb_reset_mac_header(skb2);\n\t\tskb_reset_network_header(skb2);\n\t\t \n\t\tdev_queue_xmit(skb2);\n\t}\n#endif\n\n\tif (skb) {\n\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\tmemset(skb->cb, 0, sizeof(skb->cb));\n\t\tskb->ip_summed = CHECKSUM_NONE;\t \n\t\tif (netif_rx(skb) == NET_RX_DROP) {\n\t\t\t \n\t\t\tLIBIPW_DEBUG_DROP\n\t\t\t    (\"RX: netif_rx dropped the packet\\n\");\n\t\t\tdev->stats.rx_dropped++;\n\t\t}\n\t}\n\n      rx_exit:\n#ifdef NOT_YET\n\tif (sta)\n\t\thostap_handle_sta_release(sta);\n#endif\n\treturn 1;\n\n      rx_dropped:\n\tdev->stats.rx_dropped++;\n\n\t \n\treturn 0;\n}\n\n \nvoid libipw_rx_any(struct libipw_device *ieee,\n\t\t     struct sk_buff *skb, struct libipw_rx_stats *stats)\n{\n\tstruct libipw_hdr_4addr *hdr;\n\tint is_packet_for_us;\n\tu16 fc;\n\n\tif (ieee->iw_mode == IW_MODE_MONITOR) {\n\t\tif (!libipw_rx(ieee, skb, stats))\n\t\t\tdev_kfree_skb_irq(skb);\n\t\treturn;\n\t}\n\n\tif (skb->len < sizeof(struct ieee80211_hdr))\n\t\tgoto drop_free;\n\n\thdr = (struct libipw_hdr_4addr *)skb->data;\n\tfc = le16_to_cpu(hdr->frame_ctl);\n\n\tif ((fc & IEEE80211_FCTL_VERS) != 0)\n\t\tgoto drop_free;\n\n\tswitch (fc & IEEE80211_FCTL_FTYPE) {\n\tcase IEEE80211_FTYPE_MGMT:\n\t\tif (skb->len < sizeof(struct libipw_hdr_3addr))\n\t\t\tgoto drop_free;\n\t\tlibipw_rx_mgt(ieee, hdr, stats);\n\t\tdev_kfree_skb_irq(skb);\n\t\treturn;\n\tcase IEEE80211_FTYPE_DATA:\n\t\tbreak;\n\tcase IEEE80211_FTYPE_CTL:\n\t\treturn;\n\tdefault:\n\t\treturn;\n\t}\n\n\tis_packet_for_us = 0;\n\tswitch (ieee->iw_mode) {\n\tcase IW_MODE_ADHOC:\n\t\t \n\t\tif (ether_addr_equal(hdr->addr3, ieee->bssid))\n\t\tif ((fc & (IEEE80211_FCTL_TODS+IEEE80211_FCTL_FROMDS)) == 0) {\n\t\t\t \n\t\t\tif (ieee->dev->flags & IFF_PROMISC)\n\t\t\t\tis_packet_for_us = 1;\n\t\t\t \n\t\t\telse if (ether_addr_equal(hdr->addr1, ieee->dev->dev_addr))\n\t\t\t\tis_packet_for_us = 1;\n\t\t\t \n\t\t\telse if (is_multicast_ether_addr(hdr->addr1))\n\t\t\t\tis_packet_for_us = 1;\n\t\t}\n\t\tbreak;\n\tcase IW_MODE_INFRA:\n\t\t \n\t\tif (ether_addr_equal(hdr->addr2, ieee->bssid))\n\t\tif ((fc & (IEEE80211_FCTL_TODS+IEEE80211_FCTL_FROMDS)) == IEEE80211_FCTL_FROMDS) {\n\t\t\t \n\t\t\tif (ieee->dev->flags & IFF_PROMISC)\n\t\t\t\tis_packet_for_us = 1;\n\t\t\t \n\t\t\telse if (ether_addr_equal(hdr->addr1, ieee->dev->dev_addr))\n\t\t\t\tis_packet_for_us = 1;\n\t\t\t \n\t\t\telse if (is_multicast_ether_addr(hdr->addr1)) {\n\t\t\t\t \n\t\t\t\tif (!ether_addr_equal(hdr->addr3, ieee->dev->dev_addr))\n\t\t\t\t\tis_packet_for_us = 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tif (is_packet_for_us)\n\t\tif (!libipw_rx(ieee, skb, stats))\n\t\t\tdev_kfree_skb_irq(skb);\n\treturn;\n\ndrop_free:\n\tdev_kfree_skb_irq(skb);\n\tieee->dev->stats.rx_dropped++;\n}\n\n#define MGMT_FRAME_FIXED_PART_LENGTH\t\t0x24\n\nstatic u8 qos_oui[QOS_OUI_LEN] = { 0x00, 0x50, 0xF2 };\n\n \nstatic int libipw_verify_qos_info(struct libipw_qos_information_element\n\t\t\t\t     *info_element, int sub_type)\n{\n\tif (info_element->elementID != QOS_ELEMENT_ID)\n\t\treturn -1;\n\tif (info_element->qui_subtype != sub_type)\n\t\treturn -1;\n\tif (memcmp(info_element->qui, qos_oui, QOS_OUI_LEN))\n\t\treturn -1;\n\tif (info_element->qui_type != QOS_OUI_TYPE)\n\t\treturn -1;\n\tif (info_element->version != QOS_VERSION_1)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nstatic int libipw_read_qos_param_element(\n\t\t\tstruct libipw_qos_parameter_info *element_param,\n\t\t\tstruct libipw_info_element *info_element)\n{\n\tsize_t size = sizeof(*element_param);\n\n\tif (!element_param || !info_element || info_element->len != size - 2)\n\t\treturn -1;\n\n\tmemcpy(element_param, info_element, size);\n\treturn libipw_verify_qos_info(&element_param->info_element,\n\t\t\t\t      QOS_OUI_PARAM_SUB_TYPE);\n}\n\n \nstatic int libipw_read_qos_info_element(\n\t\t\tstruct libipw_qos_information_element *element_info,\n\t\t\tstruct libipw_info_element *info_element)\n{\n\tsize_t size = sizeof(struct libipw_qos_information_element) - 2;\n\n\tif (!element_info || !info_element || info_element->len != size - 2)\n\t\treturn -1;\n\n\tmemcpy(element_info, info_element, size);\n\treturn libipw_verify_qos_info(element_info, QOS_OUI_INFO_SUB_TYPE);\n}\n\n \nstatic void libipw_qos_convert_ac_to_parameters(struct\n\t\t\t\t\t\t  libipw_qos_parameter_info\n\t\t\t\t\t\t  *param_elm, struct\n\t\t\t\t\t\t  libipw_qos_parameters\n\t\t\t\t\t\t  *qos_param)\n{\n\tint i;\n\tstruct libipw_qos_ac_parameter *ac_params;\n\tu32 txop;\n\tu8 cw_min;\n\tu8 cw_max;\n\n\tfor (i = 0; i < QOS_QUEUE_NUM; i++) {\n\t\tac_params = &(param_elm->ac_params_record[i]);\n\n\t\tqos_param->aifs[i] = (ac_params->aci_aifsn) & 0x0F;\n\t\tqos_param->aifs[i] -= (qos_param->aifs[i] < 2) ? 0 : 2;\n\n\t\tcw_min = ac_params->ecw_min_max & 0x0F;\n\t\tqos_param->cw_min[i] = cpu_to_le16((1 << cw_min) - 1);\n\n\t\tcw_max = (ac_params->ecw_min_max & 0xF0) >> 4;\n\t\tqos_param->cw_max[i] = cpu_to_le16((1 << cw_max) - 1);\n\n\t\tqos_param->flag[i] =\n\t\t    (ac_params->aci_aifsn & 0x10) ? 0x01 : 0x00;\n\n\t\ttxop = le16_to_cpu(ac_params->tx_op_limit) * 32;\n\t\tqos_param->tx_op_limit[i] = cpu_to_le16(txop);\n\t}\n}\n\n \nstatic int libipw_parse_qos_info_param_IE(struct libipw_info_element\n\t\t\t\t\t     *info_element,\n\t\t\t\t\t     struct libipw_network *network)\n{\n\tint rc = 0;\n\tstruct libipw_qos_parameters *qos_param = NULL;\n\tstruct libipw_qos_information_element qos_info_element;\n\n\trc = libipw_read_qos_info_element(&qos_info_element, info_element);\n\n\tif (rc == 0) {\n\t\tnetwork->qos_data.param_count = qos_info_element.ac_info & 0x0F;\n\t\tnetwork->flags |= NETWORK_HAS_QOS_INFORMATION;\n\t} else {\n\t\tstruct libipw_qos_parameter_info param_element;\n\n\t\trc = libipw_read_qos_param_element(&param_element,\n\t\t\t\t\t\t      info_element);\n\t\tif (rc == 0) {\n\t\t\tqos_param = &(network->qos_data.parameters);\n\t\t\tlibipw_qos_convert_ac_to_parameters(&param_element,\n\t\t\t\t\t\t\t       qos_param);\n\t\t\tnetwork->flags |= NETWORK_HAS_QOS_PARAMETERS;\n\t\t\tnetwork->qos_data.param_count =\n\t\t\t    param_element.info_element.ac_info & 0x0F;\n\t\t}\n\t}\n\n\tif (rc == 0) {\n\t\tLIBIPW_DEBUG_QOS(\"QoS is supported\\n\");\n\t\tnetwork->qos_data.supported = 1;\n\t}\n\treturn rc;\n}\n\n#ifdef CONFIG_LIBIPW_DEBUG\n#define MFIE_STRING(x) case WLAN_EID_ ##x: return #x\n\nstatic const char *get_info_element_string(u16 id)\n{\n\tswitch (id) {\n\t\tMFIE_STRING(SSID);\n\t\tMFIE_STRING(SUPP_RATES);\n\t\tMFIE_STRING(FH_PARAMS);\n\t\tMFIE_STRING(DS_PARAMS);\n\t\tMFIE_STRING(CF_PARAMS);\n\t\tMFIE_STRING(TIM);\n\t\tMFIE_STRING(IBSS_PARAMS);\n\t\tMFIE_STRING(COUNTRY);\n\t\tMFIE_STRING(REQUEST);\n\t\tMFIE_STRING(CHALLENGE);\n\t\tMFIE_STRING(PWR_CONSTRAINT);\n\t\tMFIE_STRING(PWR_CAPABILITY);\n\t\tMFIE_STRING(TPC_REQUEST);\n\t\tMFIE_STRING(TPC_REPORT);\n\t\tMFIE_STRING(SUPPORTED_CHANNELS);\n\t\tMFIE_STRING(CHANNEL_SWITCH);\n\t\tMFIE_STRING(MEASURE_REQUEST);\n\t\tMFIE_STRING(MEASURE_REPORT);\n\t\tMFIE_STRING(QUIET);\n\t\tMFIE_STRING(IBSS_DFS);\n\t\tMFIE_STRING(ERP_INFO);\n\t\tMFIE_STRING(RSN);\n\t\tMFIE_STRING(EXT_SUPP_RATES);\n\t\tMFIE_STRING(VENDOR_SPECIFIC);\n\t\tMFIE_STRING(QOS_PARAMETER);\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n}\n#endif\n\nstatic int libipw_parse_info_param(struct libipw_info_element\n\t\t\t\t      *info_element, u16 length,\n\t\t\t\t      struct libipw_network *network)\n{\n\tu8 i;\n#ifdef CONFIG_LIBIPW_DEBUG\n\tchar rates_str[64];\n\tchar *p;\n#endif\n\n\twhile (length >= sizeof(*info_element)) {\n\t\tif (sizeof(*info_element) + info_element->len > length) {\n\t\t\tLIBIPW_DEBUG_MGMT(\"Info elem: parse failed: \"\n\t\t\t\t\t     \"info_element->len + 2 > left : \"\n\t\t\t\t\t     \"info_element->len+2=%zd left=%d, id=%d.\\n\",\n\t\t\t\t\t     info_element->len +\n\t\t\t\t\t     sizeof(*info_element),\n\t\t\t\t\t     length, info_element->id);\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (info_element->id) {\n\t\tcase WLAN_EID_SSID:\n\t\t\tnetwork->ssid_len = min(info_element->len,\n\t\t\t\t\t\t(u8) IW_ESSID_MAX_SIZE);\n\t\t\tmemcpy(network->ssid, info_element->data,\n\t\t\t       network->ssid_len);\n\t\t\tif (network->ssid_len < IW_ESSID_MAX_SIZE)\n\t\t\t\tmemset(network->ssid + network->ssid_len, 0,\n\t\t\t\t       IW_ESSID_MAX_SIZE - network->ssid_len);\n\n\t\t\tLIBIPW_DEBUG_MGMT(\"WLAN_EID_SSID: '%*pE' len=%d.\\n\",\n\t\t\t\t\t  network->ssid_len, network->ssid,\n\t\t\t\t\t  network->ssid_len);\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_SUPP_RATES:\n#ifdef CONFIG_LIBIPW_DEBUG\n\t\t\tp = rates_str;\n#endif\n\t\t\tnetwork->rates_len = min(info_element->len,\n\t\t\t\t\t\t MAX_RATES_LENGTH);\n\t\t\tfor (i = 0; i < network->rates_len; i++) {\n\t\t\t\tnetwork->rates[i] = info_element->data[i];\n#ifdef CONFIG_LIBIPW_DEBUG\n\t\t\t\tp += scnprintf(p, sizeof(rates_str) -\n\t\t\t\t\t      (p - rates_str), \"%02X \",\n\t\t\t\t\t      network->rates[i]);\n#endif\n\t\t\t\tif (libipw_is_ofdm_rate\n\t\t\t\t    (info_element->data[i])) {\n\t\t\t\t\tnetwork->flags |= NETWORK_HAS_OFDM;\n\t\t\t\t\tif (info_element->data[i] &\n\t\t\t\t\t    LIBIPW_BASIC_RATE_MASK)\n\t\t\t\t\t\tnetwork->flags &=\n\t\t\t\t\t\t    ~NETWORK_HAS_CCK;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLIBIPW_DEBUG_MGMT(\"WLAN_EID_SUPP_RATES: '%s' (%d)\\n\",\n\t\t\t\t\t     rates_str, network->rates_len);\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_EXT_SUPP_RATES:\n#ifdef CONFIG_LIBIPW_DEBUG\n\t\t\tp = rates_str;\n#endif\n\t\t\tnetwork->rates_ex_len = min(info_element->len,\n\t\t\t\t\t\t    MAX_RATES_EX_LENGTH);\n\t\t\tfor (i = 0; i < network->rates_ex_len; i++) {\n\t\t\t\tnetwork->rates_ex[i] = info_element->data[i];\n#ifdef CONFIG_LIBIPW_DEBUG\n\t\t\t\tp += scnprintf(p, sizeof(rates_str) -\n\t\t\t\t\t      (p - rates_str), \"%02X \",\n\t\t\t\t\t      network->rates_ex[i]);\n#endif\n\t\t\t\tif (libipw_is_ofdm_rate\n\t\t\t\t    (info_element->data[i])) {\n\t\t\t\t\tnetwork->flags |= NETWORK_HAS_OFDM;\n\t\t\t\t\tif (info_element->data[i] &\n\t\t\t\t\t    LIBIPW_BASIC_RATE_MASK)\n\t\t\t\t\t\tnetwork->flags &=\n\t\t\t\t\t\t    ~NETWORK_HAS_CCK;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLIBIPW_DEBUG_MGMT(\"WLAN_EID_EXT_SUPP_RATES: '%s' (%d)\\n\",\n\t\t\t\t\t     rates_str, network->rates_ex_len);\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_DS_PARAMS:\n\t\t\tLIBIPW_DEBUG_MGMT(\"WLAN_EID_DS_PARAMS: %d\\n\",\n\t\t\t\t\t     info_element->data[0]);\n\t\t\tnetwork->channel = info_element->data[0];\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_FH_PARAMS:\n\t\t\tLIBIPW_DEBUG_MGMT(\"WLAN_EID_FH_PARAMS: ignored\\n\");\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_CF_PARAMS:\n\t\t\tLIBIPW_DEBUG_MGMT(\"WLAN_EID_CF_PARAMS: ignored\\n\");\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_TIM:\n\t\t\tnetwork->tim.tim_count = info_element->data[0];\n\t\t\tnetwork->tim.tim_period = info_element->data[1];\n\t\t\tLIBIPW_DEBUG_MGMT(\"WLAN_EID_TIM: partially ignored\\n\");\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_ERP_INFO:\n\t\t\tnetwork->erp_value = info_element->data[0];\n\t\t\tnetwork->flags |= NETWORK_HAS_ERP_VALUE;\n\t\t\tLIBIPW_DEBUG_MGMT(\"MFIE_TYPE_ERP_SET: %d\\n\",\n\t\t\t\t\t     network->erp_value);\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_IBSS_PARAMS:\n\t\t\tnetwork->atim_window = info_element->data[0];\n\t\t\tLIBIPW_DEBUG_MGMT(\"WLAN_EID_IBSS_PARAMS: %d\\n\",\n\t\t\t\t\t     network->atim_window);\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_CHALLENGE:\n\t\t\tLIBIPW_DEBUG_MGMT(\"WLAN_EID_CHALLENGE: ignored\\n\");\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\tLIBIPW_DEBUG_MGMT(\"WLAN_EID_VENDOR_SPECIFIC: %d bytes\\n\",\n\t\t\t\t\t     info_element->len);\n\t\t\tif (!libipw_parse_qos_info_param_IE(info_element,\n\t\t\t\t\t\t\t       network))\n\t\t\t\tbreak;\n\n\t\t\tif (info_element->len >= 4 &&\n\t\t\t    info_element->data[0] == 0x00 &&\n\t\t\t    info_element->data[1] == 0x50 &&\n\t\t\t    info_element->data[2] == 0xf2 &&\n\t\t\t    info_element->data[3] == 0x01) {\n\t\t\t\tnetwork->wpa_ie_len = min(info_element->len + 2,\n\t\t\t\t\t\t\t  MAX_WPA_IE_LEN);\n\t\t\t\tmemcpy(network->wpa_ie, info_element,\n\t\t\t\t       network->wpa_ie_len);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_RSN:\n\t\t\tLIBIPW_DEBUG_MGMT(\"WLAN_EID_RSN: %d bytes\\n\",\n\t\t\t\t\t     info_element->len);\n\t\t\tnetwork->rsn_ie_len = min(info_element->len + 2,\n\t\t\t\t\t\t  MAX_WPA_IE_LEN);\n\t\t\tmemcpy(network->rsn_ie, info_element,\n\t\t\t       network->rsn_ie_len);\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_QOS_PARAMETER:\n\t\t\tprintk(KERN_ERR\n\t\t\t       \"QoS Error need to parse QOS_PARAMETER IE\\n\");\n\t\t\tbreak;\n\t\t\t \n\t\tcase WLAN_EID_PWR_CONSTRAINT:\n\t\t\tnetwork->power_constraint = info_element->data[0];\n\t\t\tnetwork->flags |= NETWORK_HAS_POWER_CONSTRAINT;\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_CHANNEL_SWITCH:\n\t\t\tnetwork->power_constraint = info_element->data[0];\n\t\t\tnetwork->flags |= NETWORK_HAS_CSA;\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_QUIET:\n\t\t\tnetwork->quiet.count = info_element->data[0];\n\t\t\tnetwork->quiet.period = info_element->data[1];\n\t\t\tnetwork->quiet.duration = info_element->data[2];\n\t\t\tnetwork->quiet.offset = info_element->data[3];\n\t\t\tnetwork->flags |= NETWORK_HAS_QUIET;\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_IBSS_DFS:\n\t\t\tnetwork->flags |= NETWORK_HAS_IBSS_DFS;\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_TPC_REPORT:\n\t\t\tnetwork->tpc_report.transmit_power =\n\t\t\t    info_element->data[0];\n\t\t\tnetwork->tpc_report.link_margin = info_element->data[1];\n\t\t\tnetwork->flags |= NETWORK_HAS_TPC_REPORT;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tLIBIPW_DEBUG_MGMT\n\t\t\t    (\"Unsupported info element: %s (%d)\\n\",\n\t\t\t     get_info_element_string(info_element->id),\n\t\t\t     info_element->id);\n\t\t\tbreak;\n\t\t}\n\n\t\tlength -= sizeof(*info_element) + info_element->len;\n\t\tinfo_element =\n\t\t    (struct libipw_info_element *)&info_element->\n\t\t    data[info_element->len];\n\t}\n\n\treturn 0;\n}\n\nstatic int libipw_handle_assoc_resp(struct libipw_device *ieee, struct libipw_assoc_response\n\t\t\t\t       *frame, struct libipw_rx_stats *stats)\n{\n\tstruct libipw_network network_resp = { };\n\tstruct libipw_network *network = &network_resp;\n\tstruct net_device *dev = ieee->dev;\n\n\tnetwork->flags = 0;\n\tnetwork->qos_data.active = 0;\n\tnetwork->qos_data.supported = 0;\n\tnetwork->qos_data.param_count = 0;\n\tnetwork->qos_data.old_param_count = 0;\n\n\t \n\tnetwork->atim_window = le16_to_cpu(frame->aid);\n\tnetwork->listen_interval = le16_to_cpu(frame->status);\n\tmemcpy(network->bssid, frame->header.addr3, ETH_ALEN);\n\tnetwork->capability = le16_to_cpu(frame->capability);\n\tnetwork->last_scanned = jiffies;\n\tnetwork->rates_len = network->rates_ex_len = 0;\n\tnetwork->last_associate = 0;\n\tnetwork->ssid_len = 0;\n\tnetwork->erp_value =\n\t    (network->capability & WLAN_CAPABILITY_IBSS) ? 0x3 : 0x0;\n\n\tif (stats->freq == LIBIPW_52GHZ_BAND) {\n\t\t \n\t\tnetwork->channel = stats->received_channel;\n\t} else\n\t\tnetwork->flags |= NETWORK_HAS_CCK;\n\n\tnetwork->wpa_ie_len = 0;\n\tnetwork->rsn_ie_len = 0;\n\n\tif (libipw_parse_info_param((void *)frame->variable,\n\t\t\t\t    stats->len - sizeof(*frame), network))\n\t\treturn 1;\n\n\tnetwork->mode = 0;\n\tif (stats->freq == LIBIPW_52GHZ_BAND)\n\t\tnetwork->mode = IEEE_A;\n\telse {\n\t\tif (network->flags & NETWORK_HAS_OFDM)\n\t\t\tnetwork->mode |= IEEE_G;\n\t\tif (network->flags & NETWORK_HAS_CCK)\n\t\t\tnetwork->mode |= IEEE_B;\n\t}\n\n\tmemcpy(&network->stats, stats, sizeof(network->stats));\n\n\tif (ieee->handle_assoc_response != NULL)\n\t\tieee->handle_assoc_response(dev, frame, network);\n\n\treturn 0;\n}\n\n \n\nstatic int libipw_network_init(struct libipw_device *ieee, struct libipw_probe_response\n\t\t\t\t\t *beacon,\n\t\t\t\t\t struct libipw_network *network,\n\t\t\t\t\t struct libipw_rx_stats *stats)\n{\n\tnetwork->qos_data.active = 0;\n\tnetwork->qos_data.supported = 0;\n\tnetwork->qos_data.param_count = 0;\n\tnetwork->qos_data.old_param_count = 0;\n\n\t \n\tmemcpy(network->bssid, beacon->header.addr3, ETH_ALEN);\n\tnetwork->capability = le16_to_cpu(beacon->capability);\n\tnetwork->last_scanned = jiffies;\n\tnetwork->time_stamp[0] = le32_to_cpu(beacon->time_stamp[0]);\n\tnetwork->time_stamp[1] = le32_to_cpu(beacon->time_stamp[1]);\n\tnetwork->beacon_interval = le16_to_cpu(beacon->beacon_interval);\n\t \n\tnetwork->listen_interval = 0x0A;\n\tnetwork->rates_len = network->rates_ex_len = 0;\n\tnetwork->last_associate = 0;\n\tnetwork->ssid_len = 0;\n\tnetwork->flags = 0;\n\tnetwork->atim_window = 0;\n\tnetwork->erp_value = (network->capability & WLAN_CAPABILITY_IBSS) ?\n\t    0x3 : 0x0;\n\n\tif (stats->freq == LIBIPW_52GHZ_BAND) {\n\t\t \n\t\tnetwork->channel = stats->received_channel;\n\t} else\n\t\tnetwork->flags |= NETWORK_HAS_CCK;\n\n\tnetwork->wpa_ie_len = 0;\n\tnetwork->rsn_ie_len = 0;\n\n\tif (libipw_parse_info_param((void *)beacon->variable,\n\t\t\t\t    stats->len - sizeof(*beacon), network))\n\t\treturn 1;\n\n\tnetwork->mode = 0;\n\tif (stats->freq == LIBIPW_52GHZ_BAND)\n\t\tnetwork->mode = IEEE_A;\n\telse {\n\t\tif (network->flags & NETWORK_HAS_OFDM)\n\t\t\tnetwork->mode |= IEEE_G;\n\t\tif (network->flags & NETWORK_HAS_CCK)\n\t\t\tnetwork->mode |= IEEE_B;\n\t}\n\n\tif (network->mode == 0) {\n\t\tLIBIPW_DEBUG_SCAN(\"Filtered out '%*pE (%pM)' network.\\n\",\n\t\t\t\t  network->ssid_len, network->ssid,\n\t\t\t\t  network->bssid);\n\t\treturn 1;\n\t}\n\n\tmemcpy(&network->stats, stats, sizeof(network->stats));\n\n\treturn 0;\n}\n\nstatic inline int is_same_network(struct libipw_network *src,\n\t\t\t\t  struct libipw_network *dst)\n{\n\t \n\treturn ((src->ssid_len == dst->ssid_len) &&\n\t\t(src->channel == dst->channel) &&\n\t\tether_addr_equal_64bits(src->bssid, dst->bssid) &&\n\t\t!memcmp(src->ssid, dst->ssid, src->ssid_len));\n}\n\nstatic void update_network(struct libipw_network *dst,\n\t\t\t\t  struct libipw_network *src)\n{\n\tint qos_active;\n\tu8 old_param;\n\n\t \n\tif (dst->channel == src->stats.received_channel)\n\t\tmemcpy(&dst->stats, &src->stats,\n\t\t       sizeof(struct libipw_rx_stats));\n\telse\n\t\tLIBIPW_DEBUG_SCAN(\"Network %pM info received \"\n\t\t\t\"off channel (%d vs. %d)\\n\", src->bssid,\n\t\t\tdst->channel, src->stats.received_channel);\n\n\tdst->capability = src->capability;\n\tmemcpy(dst->rates, src->rates, src->rates_len);\n\tdst->rates_len = src->rates_len;\n\tmemcpy(dst->rates_ex, src->rates_ex, src->rates_ex_len);\n\tdst->rates_ex_len = src->rates_ex_len;\n\n\tdst->mode = src->mode;\n\tdst->flags = src->flags;\n\tdst->time_stamp[0] = src->time_stamp[0];\n\tdst->time_stamp[1] = src->time_stamp[1];\n\n\tdst->beacon_interval = src->beacon_interval;\n\tdst->listen_interval = src->listen_interval;\n\tdst->atim_window = src->atim_window;\n\tdst->erp_value = src->erp_value;\n\tdst->tim = src->tim;\n\n\tmemcpy(dst->wpa_ie, src->wpa_ie, src->wpa_ie_len);\n\tdst->wpa_ie_len = src->wpa_ie_len;\n\tmemcpy(dst->rsn_ie, src->rsn_ie, src->rsn_ie_len);\n\tdst->rsn_ie_len = src->rsn_ie_len;\n\n\tdst->last_scanned = jiffies;\n\tqos_active = src->qos_data.active;\n\told_param = dst->qos_data.old_param_count;\n\tif (dst->flags & NETWORK_HAS_QOS_MASK)\n\t\tmemcpy(&dst->qos_data, &src->qos_data,\n\t\t       sizeof(struct libipw_qos_data));\n\telse {\n\t\tdst->qos_data.supported = src->qos_data.supported;\n\t\tdst->qos_data.param_count = src->qos_data.param_count;\n\t}\n\n\tif (dst->qos_data.supported == 1) {\n\t\tif (dst->ssid_len)\n\t\t\tLIBIPW_DEBUG_QOS\n\t\t\t    (\"QoS the network %s is QoS supported\\n\",\n\t\t\t     dst->ssid);\n\t\telse\n\t\t\tLIBIPW_DEBUG_QOS\n\t\t\t    (\"QoS the network is QoS supported\\n\");\n\t}\n\tdst->qos_data.active = qos_active;\n\tdst->qos_data.old_param_count = old_param;\n\n\t \n}\n\nstatic inline int is_beacon(__le16 fc)\n{\n\treturn (WLAN_FC_GET_STYPE(le16_to_cpu(fc)) == IEEE80211_STYPE_BEACON);\n}\n\nstatic void libipw_process_probe_response(struct libipw_device\n\t\t\t\t\t\t    *ieee, struct\n\t\t\t\t\t\t    libipw_probe_response\n\t\t\t\t\t\t    *beacon, struct libipw_rx_stats\n\t\t\t\t\t\t    *stats)\n{\n\tstruct net_device *dev = ieee->dev;\n\tstruct libipw_network network = { };\n\tstruct libipw_network *target;\n\tstruct libipw_network *oldest = NULL;\n#ifdef CONFIG_LIBIPW_DEBUG\n\tstruct libipw_info_element *info_element = (void *)beacon->variable;\n#endif\n\tunsigned long flags;\n\n\tLIBIPW_DEBUG_SCAN(\"'%*pE' (%pM): %c%c%c%c %c%c%c%c-%c%c%c%c %c%c%c%c\\n\",\n\t\t     info_element->len, info_element->data,\n\t\t     beacon->header.addr3,\n\t\t     (beacon->capability & cpu_to_le16(1 << 0xf)) ? '1' : '0',\n\t\t     (beacon->capability & cpu_to_le16(1 << 0xe)) ? '1' : '0',\n\t\t     (beacon->capability & cpu_to_le16(1 << 0xd)) ? '1' : '0',\n\t\t     (beacon->capability & cpu_to_le16(1 << 0xc)) ? '1' : '0',\n\t\t     (beacon->capability & cpu_to_le16(1 << 0xb)) ? '1' : '0',\n\t\t     (beacon->capability & cpu_to_le16(1 << 0xa)) ? '1' : '0',\n\t\t     (beacon->capability & cpu_to_le16(1 << 0x9)) ? '1' : '0',\n\t\t     (beacon->capability & cpu_to_le16(1 << 0x8)) ? '1' : '0',\n\t\t     (beacon->capability & cpu_to_le16(1 << 0x7)) ? '1' : '0',\n\t\t     (beacon->capability & cpu_to_le16(1 << 0x6)) ? '1' : '0',\n\t\t     (beacon->capability & cpu_to_le16(1 << 0x5)) ? '1' : '0',\n\t\t     (beacon->capability & cpu_to_le16(1 << 0x4)) ? '1' : '0',\n\t\t     (beacon->capability & cpu_to_le16(1 << 0x3)) ? '1' : '0',\n\t\t     (beacon->capability & cpu_to_le16(1 << 0x2)) ? '1' : '0',\n\t\t     (beacon->capability & cpu_to_le16(1 << 0x1)) ? '1' : '0',\n\t\t     (beacon->capability & cpu_to_le16(1 << 0x0)) ? '1' : '0');\n\n\tif (libipw_network_init(ieee, beacon, &network, stats)) {\n\t\tLIBIPW_DEBUG_SCAN(\"Dropped '%*pE' (%pM) via %s.\\n\",\n\t\t\t\t  info_element->len, info_element->data,\n\t\t\t\t  beacon->header.addr3,\n\t\t\t\t  is_beacon(beacon->header.frame_ctl) ?\n\t\t\t\t  \"BEACON\" : \"PROBE RESPONSE\");\n\t\treturn;\n\t}\n\n\t \n\n\t \n\n\tspin_lock_irqsave(&ieee->lock, flags);\n\n\tlist_for_each_entry(target, &ieee->network_list, list) {\n\t\tif (is_same_network(target, &network))\n\t\t\tbreak;\n\n\t\tif ((oldest == NULL) ||\n\t\t    time_before(target->last_scanned, oldest->last_scanned))\n\t\t\toldest = target;\n\t}\n\n\t \n\tif (&target->list == &ieee->network_list) {\n\t\tif (list_empty(&ieee->network_free_list)) {\n\t\t\t \n\t\t\tlist_del(&oldest->list);\n\t\t\ttarget = oldest;\n\t\t\tLIBIPW_DEBUG_SCAN(\"Expired '%*pE' (%pM) from network list.\\n\",\n\t\t\t\t\t  target->ssid_len, target->ssid,\n\t\t\t\t\t  target->bssid);\n\t\t} else {\n\t\t\t \n\t\t\ttarget = list_entry(ieee->network_free_list.next,\n\t\t\t\t\t    struct libipw_network, list);\n\t\t\tlist_del(ieee->network_free_list.next);\n\t\t}\n\n#ifdef CONFIG_LIBIPW_DEBUG\n\t\tLIBIPW_DEBUG_SCAN(\"Adding '%*pE' (%pM) via %s.\\n\",\n\t\t\t\t  network.ssid_len, network.ssid,\n\t\t\t\t  network.bssid,\n\t\t\t\t  is_beacon(beacon->header.frame_ctl) ?\n\t\t\t\t  \"BEACON\" : \"PROBE RESPONSE\");\n#endif\n\t\tmemcpy(target, &network, sizeof(*target));\n\t\tlist_add_tail(&target->list, &ieee->network_list);\n\t} else {\n\t\tLIBIPW_DEBUG_SCAN(\"Updating '%*pE' (%pM) via %s.\\n\",\n\t\t\t\t  target->ssid_len, target->ssid,\n\t\t\t\t  target->bssid,\n\t\t\t\t  is_beacon(beacon->header.frame_ctl) ?\n\t\t\t\t  \"BEACON\" : \"PROBE RESPONSE\");\n\t\tupdate_network(target, &network);\n\t}\n\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n\n\tif (is_beacon(beacon->header.frame_ctl)) {\n\t\tif (ieee->handle_beacon != NULL)\n\t\t\tieee->handle_beacon(dev, beacon, target);\n\t} else {\n\t\tif (ieee->handle_probe_response != NULL)\n\t\t\tieee->handle_probe_response(dev, beacon, target);\n\t}\n}\n\nvoid libipw_rx_mgt(struct libipw_device *ieee,\n\t\t      struct libipw_hdr_4addr *header,\n\t\t      struct libipw_rx_stats *stats)\n{\n\tswitch (WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl))) {\n\tcase IEEE80211_STYPE_ASSOC_RESP:\n\t\tLIBIPW_DEBUG_MGMT(\"received ASSOCIATION RESPONSE (%d)\\n\",\n\t\t\t\t     WLAN_FC_GET_STYPE(le16_to_cpu\n\t\t\t\t\t\t       (header->frame_ctl)));\n\t\tlibipw_handle_assoc_resp(ieee,\n\t\t\t\t\t    (struct libipw_assoc_response *)\n\t\t\t\t\t    header, stats);\n\t\tbreak;\n\n\tcase IEEE80211_STYPE_REASSOC_RESP:\n\t\tLIBIPW_DEBUG_MGMT(\"received REASSOCIATION RESPONSE (%d)\\n\",\n\t\t\t\t     WLAN_FC_GET_STYPE(le16_to_cpu\n\t\t\t\t\t\t       (header->frame_ctl)));\n\t\tbreak;\n\n\tcase IEEE80211_STYPE_PROBE_REQ:\n\t\tLIBIPW_DEBUG_MGMT(\"received auth (%d)\\n\",\n\t\t\t\t     WLAN_FC_GET_STYPE(le16_to_cpu\n\t\t\t\t\t\t       (header->frame_ctl)));\n\n\t\tif (ieee->handle_probe_request != NULL)\n\t\t\tieee->handle_probe_request(ieee->dev,\n\t\t\t\t\t\t   (struct\n\t\t\t\t\t\t    libipw_probe_request *)\n\t\t\t\t\t\t   header, stats);\n\t\tbreak;\n\n\tcase IEEE80211_STYPE_PROBE_RESP:\n\t\tLIBIPW_DEBUG_MGMT(\"received PROBE RESPONSE (%d)\\n\",\n\t\t\t\t     WLAN_FC_GET_STYPE(le16_to_cpu\n\t\t\t\t\t\t       (header->frame_ctl)));\n\t\tLIBIPW_DEBUG_SCAN(\"Probe response\\n\");\n\t\tlibipw_process_probe_response(ieee,\n\t\t\t\t\t\t (struct\n\t\t\t\t\t\t  libipw_probe_response *)\n\t\t\t\t\t\t header, stats);\n\t\tbreak;\n\n\tcase IEEE80211_STYPE_BEACON:\n\t\tLIBIPW_DEBUG_MGMT(\"received BEACON (%d)\\n\",\n\t\t\t\t     WLAN_FC_GET_STYPE(le16_to_cpu\n\t\t\t\t\t\t       (header->frame_ctl)));\n\t\tLIBIPW_DEBUG_SCAN(\"Beacon\\n\");\n\t\tlibipw_process_probe_response(ieee,\n\t\t\t\t\t\t (struct\n\t\t\t\t\t\t  libipw_probe_response *)\n\t\t\t\t\t\t header, stats);\n\t\tbreak;\n\tcase IEEE80211_STYPE_AUTH:\n\n\t\tLIBIPW_DEBUG_MGMT(\"received auth (%d)\\n\",\n\t\t\t\t     WLAN_FC_GET_STYPE(le16_to_cpu\n\t\t\t\t\t\t       (header->frame_ctl)));\n\n\t\tif (ieee->handle_auth != NULL)\n\t\t\tieee->handle_auth(ieee->dev,\n\t\t\t\t\t  (struct libipw_auth *)header);\n\t\tbreak;\n\n\tcase IEEE80211_STYPE_DISASSOC:\n\t\tif (ieee->handle_disassoc != NULL)\n\t\t\tieee->handle_disassoc(ieee->dev,\n\t\t\t\t\t      (struct libipw_disassoc *)\n\t\t\t\t\t      header);\n\t\tbreak;\n\n\tcase IEEE80211_STYPE_ACTION:\n\t\tLIBIPW_DEBUG_MGMT(\"ACTION\\n\");\n\t\tif (ieee->handle_action)\n\t\t\tieee->handle_action(ieee->dev,\n\t\t\t\t\t    (struct libipw_action *)\n\t\t\t\t\t    header, stats);\n\t\tbreak;\n\n\tcase IEEE80211_STYPE_REASSOC_REQ:\n\t\tLIBIPW_DEBUG_MGMT(\"received reassoc (%d)\\n\",\n\t\t\t\t     WLAN_FC_GET_STYPE(le16_to_cpu\n\t\t\t\t\t\t       (header->frame_ctl)));\n\n\t\tLIBIPW_DEBUG_MGMT(\"%s: LIBIPW_REASSOC_REQ received\\n\",\n\t\t\t\t     ieee->dev->name);\n\t\tif (ieee->handle_reassoc_request != NULL)\n\t\t\tieee->handle_reassoc_request(ieee->dev,\n\t\t\t\t\t\t    (struct libipw_reassoc_request *)\n\t\t\t\t\t\t     header);\n\t\tbreak;\n\n\tcase IEEE80211_STYPE_ASSOC_REQ:\n\t\tLIBIPW_DEBUG_MGMT(\"received assoc (%d)\\n\",\n\t\t\t\t     WLAN_FC_GET_STYPE(le16_to_cpu\n\t\t\t\t\t\t       (header->frame_ctl)));\n\n\t\tLIBIPW_DEBUG_MGMT(\"%s: LIBIPW_ASSOC_REQ received\\n\",\n\t\t\t\t     ieee->dev->name);\n\t\tif (ieee->handle_assoc_request != NULL)\n\t\t\tieee->handle_assoc_request(ieee->dev);\n\t\tbreak;\n\n\tcase IEEE80211_STYPE_DEAUTH:\n\t\tLIBIPW_DEBUG_MGMT(\"DEAUTH\\n\");\n\t\tif (ieee->handle_deauth != NULL)\n\t\t\tieee->handle_deauth(ieee->dev,\n\t\t\t\t\t    (struct libipw_deauth *)\n\t\t\t\t\t    header);\n\t\tbreak;\n\tdefault:\n\t\tLIBIPW_DEBUG_MGMT(\"received UNKNOWN (%d)\\n\",\n\t\t\t\t     WLAN_FC_GET_STYPE(le16_to_cpu\n\t\t\t\t\t\t       (header->frame_ctl)));\n\t\tLIBIPW_DEBUG_MGMT(\"%s: Unknown management packet: %d\\n\",\n\t\t\t\t     ieee->dev->name,\n\t\t\t\t     WLAN_FC_GET_STYPE(le16_to_cpu\n\t\t\t\t\t\t       (header->frame_ctl)));\n\t\tbreak;\n\t}\n}\n\nEXPORT_SYMBOL_GPL(libipw_rx_any);\nEXPORT_SYMBOL(libipw_rx_mgt);\nEXPORT_SYMBOL(libipw_rx);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}