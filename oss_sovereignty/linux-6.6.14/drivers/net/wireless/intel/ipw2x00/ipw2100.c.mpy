{
  "module_name": "ipw2100.c",
  "hash_id": "68b923064452e1c303fbab256f2ac0d77e0aac52b2179e561c37481e408c75ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/ipw2x00/ipw2100.c",
  "human_readable_source": "\n \n \n\n#include <linux/compiler.h>\n#include <linux/errno.h>\n#include <linux/if_arp.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/kernel.h>\n#include <linux/kmod.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/ethtool.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/proc_fs.h>\n#include <linux/skbuff.h>\n#include <linux/uaccess.h>\n#include <asm/io.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/unistd.h>\n#include <linux/stringify.h>\n#include <linux/tcp.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/firmware.h>\n#include <linux/acpi.h>\n#include <linux/ctype.h>\n#include <linux/pm_qos.h>\n\n#include <net/lib80211.h>\n\n#include \"ipw2100.h\"\n#include \"ipw.h\"\n\n#define IPW2100_VERSION \"git-1.2.2\"\n\n#define DRV_NAME\t\"ipw2100\"\n#define DRV_VERSION\tIPW2100_VERSION\n#define DRV_DESCRIPTION\t\"Intel(R) PRO/Wireless 2100 Network Driver\"\n#define DRV_COPYRIGHT\t\"Copyright(c) 2003-2006 Intel Corporation\"\n\nstatic struct pm_qos_request ipw2100_pm_qos_req;\n\n \n#ifdef CONFIG_IPW2100_DEBUG\n#define IPW2100_RX_DEBUG\t \n#endif\n\nMODULE_DESCRIPTION(DRV_DESCRIPTION);\nMODULE_VERSION(DRV_VERSION);\nMODULE_AUTHOR(DRV_COPYRIGHT);\nMODULE_LICENSE(\"GPL\");\n\nstatic int debug = 0;\nstatic int network_mode = 0;\nstatic int channel = 0;\nstatic int associate = 0;\nstatic int disable = 0;\n#ifdef CONFIG_PM\nstatic struct ipw2100_fw ipw2100_firmware;\n#endif\n\n#include <linux/moduleparam.h>\nmodule_param(debug, int, 0444);\nmodule_param_named(mode, network_mode, int, 0444);\nmodule_param(channel, int, 0444);\nmodule_param(associate, int, 0444);\nmodule_param(disable, int, 0444);\n\nMODULE_PARM_DESC(debug, \"debug level\");\nMODULE_PARM_DESC(mode, \"network mode (0=BSS,1=IBSS,2=Monitor)\");\nMODULE_PARM_DESC(channel, \"channel\");\nMODULE_PARM_DESC(associate, \"auto associate when scanning (default off)\");\nMODULE_PARM_DESC(disable, \"manually disable the radio (default 0 [radio on])\");\n\nstatic u32 ipw2100_debug_level = IPW_DL_NONE;\n\n#ifdef CONFIG_IPW2100_DEBUG\n#define IPW_DEBUG(level, message...) \\\ndo { \\\n\tif (ipw2100_debug_level & (level)) { \\\n\t\tprintk(KERN_DEBUG \"ipw2100: %s \", __func__); \\\n\t\tprintk(message); \\\n\t} \\\n} while (0)\n#else\n#define IPW_DEBUG(level, message...) do {} while (0)\n#endif\t\t\t\t \n\n#ifdef CONFIG_IPW2100_DEBUG\nstatic const char *command_types[] = {\n\t\"undefined\",\n\t\"unused\",\t\t \n\t\"HOST_COMPLETE\",\n\t\"unused\",\t\t \n\t\"unused\",\t\t \n\t\"unused\",\n\t\"SYSTEM_CONFIG\",\n\t\"unused\",\t\t \n\t\"SSID\",\n\t\"MANDATORY_BSSID\",\n\t\"AUTHENTICATION_TYPE\",\n\t\"ADAPTER_ADDRESS\",\n\t\"PORT_TYPE\",\n\t\"INTERNATIONAL_MODE\",\n\t\"CHANNEL\",\n\t\"RTS_THRESHOLD\",\n\t\"FRAG_THRESHOLD\",\n\t\"POWER_MODE\",\n\t\"TX_RATES\",\n\t\"BASIC_TX_RATES\",\n\t\"WEP_KEY_INFO\",\n\t\"unused\",\n\t\"unused\",\n\t\"unused\",\n\t\"unused\",\n\t\"WEP_KEY_INDEX\",\n\t\"WEP_FLAGS\",\n\t\"ADD_MULTICAST\",\n\t\"CLEAR_ALL_MULTICAST\",\n\t\"BEACON_INTERVAL\",\n\t\"ATIM_WINDOW\",\n\t\"CLEAR_STATISTICS\",\n\t\"undefined\",\n\t\"undefined\",\n\t\"undefined\",\n\t\"undefined\",\n\t\"TX_POWER_INDEX\",\n\t\"undefined\",\n\t\"undefined\",\n\t\"undefined\",\n\t\"undefined\",\n\t\"undefined\",\n\t\"undefined\",\n\t\"BROADCAST_SCAN\",\n\t\"CARD_DISABLE\",\n\t\"PREFERRED_BSSID\",\n\t\"SET_SCAN_OPTIONS\",\n\t\"SCAN_DWELL_TIME\",\n\t\"SWEEP_TABLE\",\n\t\"AP_OR_STATION_TABLE\",\n\t\"GROUP_ORDINALS\",\n\t\"SHORT_RETRY_LIMIT\",\n\t\"LONG_RETRY_LIMIT\",\n\t\"unused\",\t\t \n\t\"unused\",\t\t \n\t\"undefined\",\n\t\"undefined\",\n\t\"undefined\",\n\t\"HOST_PRE_POWER_DOWN\",\n\t\"unused\",\t\t \n\t\"undefined\",\n\t\"CARD_DISABLE_PHY_OFF\",\n\t\"MSDU_TX_RATES\",\n\t\"undefined\",\n\t\"SET_STATION_STAT_BITS\",\n\t\"CLEAR_STATIONS_STAT_BITS\",\n\t\"LEAP_ROGUE_MODE\",\n\t\"SET_SECURITY_INFORMATION\",\n\t\"DISASSOCIATION_BSSID\",\n\t\"SET_WPA_ASS_IE\"\n};\n#endif\n\nstatic const long ipw2100_frequencies[] = {\n\t2412, 2417, 2422, 2427,\n\t2432, 2437, 2442, 2447,\n\t2452, 2457, 2462, 2467,\n\t2472, 2484\n};\n\n#define FREQ_COUNT\tARRAY_SIZE(ipw2100_frequencies)\n\nstatic struct ieee80211_rate ipw2100_bg_rates[] = {\n\t{ .bitrate = 10 },\n\t{ .bitrate = 20, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 55, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 110, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n};\n\n#define RATE_COUNT ARRAY_SIZE(ipw2100_bg_rates)\n\n \nstatic void ipw2100_tx_send_commands(struct ipw2100_priv *priv);\nstatic void ipw2100_tx_send_data(struct ipw2100_priv *priv);\nstatic int ipw2100_adapter_setup(struct ipw2100_priv *priv);\n\nstatic void ipw2100_queues_initialize(struct ipw2100_priv *priv);\nstatic void ipw2100_queues_free(struct ipw2100_priv *priv);\nstatic int ipw2100_queues_allocate(struct ipw2100_priv *priv);\n\nstatic int ipw2100_fw_download(struct ipw2100_priv *priv,\n\t\t\t       struct ipw2100_fw *fw);\nstatic int ipw2100_get_firmware(struct ipw2100_priv *priv,\n\t\t\t\tstruct ipw2100_fw *fw);\nstatic int ipw2100_get_fwversion(struct ipw2100_priv *priv, char *buf,\n\t\t\t\t size_t max);\nstatic int ipw2100_get_ucodeversion(struct ipw2100_priv *priv, char *buf,\n\t\t\t\t    size_t max);\nstatic void ipw2100_release_firmware(struct ipw2100_priv *priv,\n\t\t\t\t     struct ipw2100_fw *fw);\nstatic int ipw2100_ucode_download(struct ipw2100_priv *priv,\n\t\t\t\t  struct ipw2100_fw *fw);\nstatic void ipw2100_wx_event_work(struct work_struct *work);\nstatic struct iw_statistics *ipw2100_wx_wireless_stats(struct net_device *dev);\nstatic const struct iw_handler_def ipw2100_wx_handler_def;\n\nstatic inline void read_register(struct net_device *dev, u32 reg, u32 * val)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\t*val = ioread32(priv->ioaddr + reg);\n\tIPW_DEBUG_IO(\"r: 0x%08X => 0x%08X\\n\", reg, *val);\n}\n\nstatic inline void write_register(struct net_device *dev, u32 reg, u32 val)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\tiowrite32(val, priv->ioaddr + reg);\n\tIPW_DEBUG_IO(\"w: 0x%08X <= 0x%08X\\n\", reg, val);\n}\n\nstatic inline void read_register_word(struct net_device *dev, u32 reg,\n\t\t\t\t      u16 * val)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\t*val = ioread16(priv->ioaddr + reg);\n\tIPW_DEBUG_IO(\"r: 0x%08X => %04X\\n\", reg, *val);\n}\n\nstatic inline void read_register_byte(struct net_device *dev, u32 reg, u8 * val)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\t*val = ioread8(priv->ioaddr + reg);\n\tIPW_DEBUG_IO(\"r: 0x%08X => %02X\\n\", reg, *val);\n}\n\nstatic inline void write_register_word(struct net_device *dev, u32 reg, u16 val)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\tiowrite16(val, priv->ioaddr + reg);\n\tIPW_DEBUG_IO(\"w: 0x%08X <= %04X\\n\", reg, val);\n}\n\nstatic inline void write_register_byte(struct net_device *dev, u32 reg, u8 val)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\tiowrite8(val, priv->ioaddr + reg);\n\tIPW_DEBUG_IO(\"w: 0x%08X =< %02X\\n\", reg, val);\n}\n\nstatic inline void read_nic_dword(struct net_device *dev, u32 addr, u32 * val)\n{\n\twrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,\n\t\t       addr & IPW_REG_INDIRECT_ADDR_MASK);\n\tread_register(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);\n}\n\nstatic inline void write_nic_dword(struct net_device *dev, u32 addr, u32 val)\n{\n\twrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,\n\t\t       addr & IPW_REG_INDIRECT_ADDR_MASK);\n\twrite_register(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);\n}\n\nstatic inline void read_nic_word(struct net_device *dev, u32 addr, u16 * val)\n{\n\twrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,\n\t\t       addr & IPW_REG_INDIRECT_ADDR_MASK);\n\tread_register_word(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);\n}\n\nstatic inline void write_nic_word(struct net_device *dev, u32 addr, u16 val)\n{\n\twrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,\n\t\t       addr & IPW_REG_INDIRECT_ADDR_MASK);\n\twrite_register_word(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);\n}\n\nstatic inline void read_nic_byte(struct net_device *dev, u32 addr, u8 * val)\n{\n\twrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,\n\t\t       addr & IPW_REG_INDIRECT_ADDR_MASK);\n\tread_register_byte(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);\n}\n\nstatic inline void write_nic_byte(struct net_device *dev, u32 addr, u8 val)\n{\n\twrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,\n\t\t       addr & IPW_REG_INDIRECT_ADDR_MASK);\n\twrite_register_byte(dev, IPW_REG_INDIRECT_ACCESS_DATA, val);\n}\n\nstatic void write_nic_memory(struct net_device *dev, u32 addr, u32 len,\n\t\t\t\t    const u8 * buf)\n{\n\tu32 aligned_addr;\n\tu32 aligned_len;\n\tu32 dif_len;\n\tu32 i;\n\n\t \n\taligned_addr = addr & (~0x3);\n\tdif_len = addr - aligned_addr;\n\tif (dif_len) {\n\t\t \n\t\twrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,\n\t\t\t       aligned_addr);\n\t\tfor (i = dif_len; i < 4; i++, buf++)\n\t\t\twrite_register_byte(dev,\n\t\t\t\t\t    IPW_REG_INDIRECT_ACCESS_DATA + i,\n\t\t\t\t\t    *buf);\n\n\t\tlen -= dif_len;\n\t\taligned_addr += 4;\n\t}\n\n\t \n\twrite_register(dev, IPW_REG_AUTOINCREMENT_ADDRESS, aligned_addr);\n\taligned_len = len & (~0x3);\n\tfor (i = 0; i < aligned_len; i += 4, buf += 4, aligned_addr += 4)\n\t\twrite_register(dev, IPW_REG_AUTOINCREMENT_DATA, *(u32 *) buf);\n\n\t \n\tdif_len = len - aligned_len;\n\twrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS, aligned_addr);\n\tfor (i = 0; i < dif_len; i++, buf++)\n\t\twrite_register_byte(dev, IPW_REG_INDIRECT_ACCESS_DATA + i,\n\t\t\t\t    *buf);\n}\n\nstatic void read_nic_memory(struct net_device *dev, u32 addr, u32 len,\n\t\t\t\t   u8 * buf)\n{\n\tu32 aligned_addr;\n\tu32 aligned_len;\n\tu32 dif_len;\n\tu32 i;\n\n\t \n\taligned_addr = addr & (~0x3);\n\tdif_len = addr - aligned_addr;\n\tif (dif_len) {\n\t\t \n\t\twrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS,\n\t\t\t       aligned_addr);\n\t\tfor (i = dif_len; i < 4; i++, buf++)\n\t\t\tread_register_byte(dev,\n\t\t\t\t\t   IPW_REG_INDIRECT_ACCESS_DATA + i,\n\t\t\t\t\t   buf);\n\n\t\tlen -= dif_len;\n\t\taligned_addr += 4;\n\t}\n\n\t \n\twrite_register(dev, IPW_REG_AUTOINCREMENT_ADDRESS, aligned_addr);\n\taligned_len = len & (~0x3);\n\tfor (i = 0; i < aligned_len; i += 4, buf += 4, aligned_addr += 4)\n\t\tread_register(dev, IPW_REG_AUTOINCREMENT_DATA, (u32 *) buf);\n\n\t \n\tdif_len = len - aligned_len;\n\twrite_register(dev, IPW_REG_INDIRECT_ACCESS_ADDRESS, aligned_addr);\n\tfor (i = 0; i < dif_len; i++, buf++)\n\t\tread_register_byte(dev, IPW_REG_INDIRECT_ACCESS_DATA + i, buf);\n}\n\nstatic bool ipw2100_hw_is_adapter_in_system(struct net_device *dev)\n{\n\tu32 dbg;\n\n\tread_register(dev, IPW_REG_DOA_DEBUG_AREA_START, &dbg);\n\n\treturn dbg == IPW_DATA_DOA_DEBUG_VALUE;\n}\n\nstatic int ipw2100_get_ordinal(struct ipw2100_priv *priv, u32 ord,\n\t\t\t       void *val, u32 * len)\n{\n\tstruct ipw2100_ordinals *ordinals = &priv->ordinals;\n\tu32 addr;\n\tu32 field_info;\n\tu16 field_len;\n\tu16 field_count;\n\tu32 total_length;\n\n\tif (ordinals->table1_addr == 0) {\n\t\tprintk(KERN_WARNING DRV_NAME \": attempt to use fw ordinals \"\n\t\t       \"before they have been loaded.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (IS_ORDINAL_TABLE_ONE(ordinals, ord)) {\n\t\tif (*len < IPW_ORD_TAB_1_ENTRY_SIZE) {\n\t\t\t*len = IPW_ORD_TAB_1_ENTRY_SIZE;\n\n\t\t\tprintk(KERN_WARNING DRV_NAME\n\t\t\t       \": ordinal buffer length too small, need %zd\\n\",\n\t\t\t       IPW_ORD_TAB_1_ENTRY_SIZE);\n\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tread_nic_dword(priv->net_dev,\n\t\t\t       ordinals->table1_addr + (ord << 2), &addr);\n\t\tread_nic_dword(priv->net_dev, addr, val);\n\n\t\t*len = IPW_ORD_TAB_1_ENTRY_SIZE;\n\n\t\treturn 0;\n\t}\n\n\tif (IS_ORDINAL_TABLE_TWO(ordinals, ord)) {\n\n\t\tord -= IPW_START_ORD_TAB_2;\n\n\t\t \n\t\tread_nic_dword(priv->net_dev,\n\t\t\t       ordinals->table2_addr + (ord << 3), &addr);\n\n\t\t \n\t\tread_nic_dword(priv->net_dev,\n\t\t\t       ordinals->table2_addr + (ord << 3) + sizeof(u32),\n\t\t\t       &field_info);\n\n\t\t \n\t\tfield_len = *((u16 *) & field_info);\n\n\t\t \n\t\tfield_count = *(((u16 *) & field_info) + 1);\n\n\t\t \n\t\ttotal_length = field_len * field_count;\n\t\tif (total_length > *len) {\n\t\t\t*len = total_length;\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*len = total_length;\n\t\tif (!total_length)\n\t\t\treturn 0;\n\n\t\t \n\t\tread_nic_memory(priv->net_dev, addr, total_length, val);\n\n\t\treturn 0;\n\t}\n\n\tprintk(KERN_WARNING DRV_NAME \": ordinal %d neither in table 1 nor \"\n\t       \"in table 2\\n\", ord);\n\n\treturn -EINVAL;\n}\n\nstatic int ipw2100_set_ordinal(struct ipw2100_priv *priv, u32 ord, u32 * val,\n\t\t\t       u32 * len)\n{\n\tstruct ipw2100_ordinals *ordinals = &priv->ordinals;\n\tu32 addr;\n\n\tif (IS_ORDINAL_TABLE_ONE(ordinals, ord)) {\n\t\tif (*len != IPW_ORD_TAB_1_ENTRY_SIZE) {\n\t\t\t*len = IPW_ORD_TAB_1_ENTRY_SIZE;\n\t\t\tIPW_DEBUG_INFO(\"wrong size\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tread_nic_dword(priv->net_dev,\n\t\t\t       ordinals->table1_addr + (ord << 2), &addr);\n\n\t\twrite_nic_dword(priv->net_dev, addr, *val);\n\n\t\t*len = IPW_ORD_TAB_1_ENTRY_SIZE;\n\n\t\treturn 0;\n\t}\n\n\tIPW_DEBUG_INFO(\"wrong table\\n\");\n\tif (IS_ORDINAL_TABLE_TWO(ordinals, ord))\n\t\treturn -EINVAL;\n\n\treturn -EINVAL;\n}\n\nstatic char *snprint_line(char *buf, size_t count,\n\t\t\t  const u8 * data, u32 len, u32 ofs)\n{\n\tint out, i, j, l;\n\tchar c;\n\n\tout = scnprintf(buf, count, \"%08X\", ofs);\n\n\tfor (l = 0, i = 0; i < 2; i++) {\n\t\tout += scnprintf(buf + out, count - out, \" \");\n\t\tfor (j = 0; j < 8 && l < len; j++, l++)\n\t\t\tout += scnprintf(buf + out, count - out, \"%02X \",\n\t\t\t\t\tdata[(i * 8 + j)]);\n\t\tfor (; j < 8; j++)\n\t\t\tout += scnprintf(buf + out, count - out, \"   \");\n\t}\n\n\tout += scnprintf(buf + out, count - out, \" \");\n\tfor (l = 0, i = 0; i < 2; i++) {\n\t\tout += scnprintf(buf + out, count - out, \" \");\n\t\tfor (j = 0; j < 8 && l < len; j++, l++) {\n\t\t\tc = data[(i * 8 + j)];\n\t\t\tif (!isascii(c) || !isprint(c))\n\t\t\t\tc = '.';\n\n\t\t\tout += scnprintf(buf + out, count - out, \"%c\", c);\n\t\t}\n\n\t\tfor (; j < 8; j++)\n\t\t\tout += scnprintf(buf + out, count - out, \" \");\n\t}\n\n\treturn buf;\n}\n\nstatic void printk_buf(int level, const u8 * data, u32 len)\n{\n\tchar line[81];\n\tu32 ofs = 0;\n\tif (!(ipw2100_debug_level & level))\n\t\treturn;\n\n\twhile (len) {\n\t\tprintk(KERN_DEBUG \"%s\\n\",\n\t\t       snprint_line(line, sizeof(line), &data[ofs],\n\t\t\t\t    min(len, 16U), ofs));\n\t\tofs += 16;\n\t\tlen -= min(len, 16U);\n\t}\n}\n\n#define MAX_RESET_BACKOFF 10\n\nstatic void schedule_reset(struct ipw2100_priv *priv)\n{\n\ttime64_t now = ktime_get_boottime_seconds();\n\n\t \n\tif (priv->reset_backoff &&\n\t    (now - priv->last_reset > priv->reset_backoff))\n\t\tpriv->reset_backoff = 0;\n\n\tpriv->last_reset = now;\n\n\tif (!(priv->status & STATUS_RESET_PENDING)) {\n\t\tIPW_DEBUG_INFO(\"%s: Scheduling firmware restart (%llds).\\n\",\n\t\t\t       priv->net_dev->name, priv->reset_backoff);\n\t\tnetif_carrier_off(priv->net_dev);\n\t\tnetif_stop_queue(priv->net_dev);\n\t\tpriv->status |= STATUS_RESET_PENDING;\n\t\tif (priv->reset_backoff)\n\t\t\tschedule_delayed_work(&priv->reset_work,\n\t\t\t\t\t      priv->reset_backoff * HZ);\n\t\telse\n\t\t\tschedule_delayed_work(&priv->reset_work, 0);\n\n\t\tif (priv->reset_backoff < MAX_RESET_BACKOFF)\n\t\t\tpriv->reset_backoff++;\n\n\t\twake_up_interruptible(&priv->wait_command_queue);\n\t} else\n\t\tIPW_DEBUG_INFO(\"%s: Firmware restart already in progress.\\n\",\n\t\t\t       priv->net_dev->name);\n\n}\n\n#define HOST_COMPLETE_TIMEOUT (2 * HZ)\nstatic int ipw2100_hw_send_command(struct ipw2100_priv *priv,\n\t\t\t\t   struct host_command *cmd)\n{\n\tstruct list_head *element;\n\tstruct ipw2100_tx_packet *packet;\n\tunsigned long flags;\n\tint err = 0;\n\n\tIPW_DEBUG_HC(\"Sending %s command (#%d), %d bytes\\n\",\n\t\t     command_types[cmd->host_command], cmd->host_command,\n\t\t     cmd->host_command_length);\n\tprintk_buf(IPW_DL_HC, (u8 *) cmd->host_command_parameters,\n\t\t   cmd->host_command_length);\n\n\tspin_lock_irqsave(&priv->low_lock, flags);\n\n\tif (priv->fatal_error) {\n\t\tIPW_DEBUG_INFO\n\t\t    (\"Attempt to send command while hardware in fatal error condition.\\n\");\n\t\terr = -EIO;\n\t\tgoto fail_unlock;\n\t}\n\n\tif (!(priv->status & STATUS_RUNNING)) {\n\t\tIPW_DEBUG_INFO\n\t\t    (\"Attempt to send command while hardware is not running.\\n\");\n\t\terr = -EIO;\n\t\tgoto fail_unlock;\n\t}\n\n\tif (priv->status & STATUS_CMD_ACTIVE) {\n\t\tIPW_DEBUG_INFO\n\t\t    (\"Attempt to send command while another command is pending.\\n\");\n\t\terr = -EBUSY;\n\t\tgoto fail_unlock;\n\t}\n\n\tif (list_empty(&priv->msg_free_list)) {\n\t\tIPW_DEBUG_INFO(\"no available msg buffers\\n\");\n\t\tgoto fail_unlock;\n\t}\n\n\tpriv->status |= STATUS_CMD_ACTIVE;\n\tpriv->messages_sent++;\n\n\telement = priv->msg_free_list.next;\n\n\tpacket = list_entry(element, struct ipw2100_tx_packet, list);\n\tpacket->jiffy_start = jiffies;\n\n\t \n\tpacket->info.c_struct.cmd->host_command_reg = cmd->host_command;\n\tpacket->info.c_struct.cmd->host_command_reg1 = cmd->host_command1;\n\tpacket->info.c_struct.cmd->host_command_len_reg =\n\t    cmd->host_command_length;\n\tpacket->info.c_struct.cmd->sequence = cmd->host_command_sequence;\n\n\tmemcpy(packet->info.c_struct.cmd->host_command_params_reg,\n\t       cmd->host_command_parameters,\n\t       sizeof(packet->info.c_struct.cmd->host_command_params_reg));\n\n\tlist_del(element);\n\tDEC_STAT(&priv->msg_free_stat);\n\n\tlist_add_tail(element, &priv->msg_pend_list);\n\tINC_STAT(&priv->msg_pend_stat);\n\n\tipw2100_tx_send_commands(priv);\n\tipw2100_tx_send_data(priv);\n\n\tspin_unlock_irqrestore(&priv->low_lock, flags);\n\n\t \n\n\terr =\n\t    wait_event_interruptible_timeout(priv->wait_command_queue,\n\t\t\t\t\t     !(priv->\n\t\t\t\t\t       status & STATUS_CMD_ACTIVE),\n\t\t\t\t\t     HOST_COMPLETE_TIMEOUT);\n\n\tif (err == 0) {\n\t\tIPW_DEBUG_INFO(\"Command completion failed out after %dms.\\n\",\n\t\t\t       1000 * (HOST_COMPLETE_TIMEOUT / HZ));\n\t\tpriv->fatal_error = IPW2100_ERR_MSG_TIMEOUT;\n\t\tpriv->status &= ~STATUS_CMD_ACTIVE;\n\t\tschedule_reset(priv);\n\t\treturn -EIO;\n\t}\n\n\tif (priv->fatal_error) {\n\t\tprintk(KERN_WARNING DRV_NAME \": %s: firmware fatal error\\n\",\n\t\t       priv->net_dev->name);\n\t\treturn -EIO;\n\t}\n\n\t \n\tschedule_timeout_uninterruptible(msecs_to_jiffies(10));\n\n\treturn 0;\n\n      fail_unlock:\n\tspin_unlock_irqrestore(&priv->low_lock, flags);\n\n\treturn err;\n}\n\n \nstatic int ipw2100_verify(struct ipw2100_priv *priv)\n{\n\tu32 data1, data2;\n\tu32 address;\n\n\tu32 val1 = 0x76543210;\n\tu32 val2 = 0xFEDCBA98;\n\n\t \n\tfor (address = IPW_REG_DOA_DEBUG_AREA_START;\n\t     address < IPW_REG_DOA_DEBUG_AREA_END; address += sizeof(u32)) {\n\t\tread_register(priv->net_dev, address, &data1);\n\t\tif (data1 != IPW_DATA_DOA_DEBUG_VALUE)\n\t\t\treturn -EIO;\n\t}\n\n\t \n\tfor (address = 0; address < 5; address++) {\n\t\t \n\t\twrite_register(priv->net_dev, IPW_REG_DOMAIN_1_OFFSET + 0x32,\n\t\t\t       val1);\n\t\twrite_register(priv->net_dev, IPW_REG_DOMAIN_1_OFFSET + 0x36,\n\t\t\t       val2);\n\t\tread_register(priv->net_dev, IPW_REG_DOMAIN_1_OFFSET + 0x32,\n\t\t\t      &data1);\n\t\tread_register(priv->net_dev, IPW_REG_DOMAIN_1_OFFSET + 0x36,\n\t\t\t      &data2);\n\t\tif (val1 == data1 && val2 == data2)\n\t\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}\n\n \n#define IPW_CARD_DISABLE_COMPLETE_WAIT\t\t    100\t \nstatic int ipw2100_wait_for_card_state(struct ipw2100_priv *priv, int state)\n{\n\tint i;\n\tu32 card_state;\n\tu32 len = sizeof(card_state);\n\tint err;\n\n\tfor (i = 0; i <= IPW_CARD_DISABLE_COMPLETE_WAIT * 1000; i += 50) {\n\t\terr = ipw2100_get_ordinal(priv, IPW_ORD_CARD_DISABLED,\n\t\t\t\t\t  &card_state, &len);\n\t\tif (err) {\n\t\t\tIPW_DEBUG_INFO(\"Query of CARD_DISABLED ordinal \"\n\t\t\t\t       \"failed.\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif ((card_state == state) ||\n\t\t    ((priv->status & STATUS_ENABLED) ?\n\t\t     IPW_HW_STATE_ENABLED : IPW_HW_STATE_DISABLED) == state) {\n\t\t\tif (state == IPW_HW_STATE_ENABLED)\n\t\t\t\tpriv->status |= STATUS_ENABLED;\n\t\t\telse\n\t\t\t\tpriv->status &= ~STATUS_ENABLED;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tudelay(50);\n\t}\n\n\tIPW_DEBUG_INFO(\"ipw2100_wait_for_card_state to %s state timed out\\n\",\n\t\t       state ? \"DISABLED\" : \"ENABLED\");\n\treturn -EIO;\n}\n\n \nstatic int sw_reset_and_clock(struct ipw2100_priv *priv)\n{\n\tint i;\n\tu32 r;\n\n\t\n\twrite_register(priv->net_dev, IPW_REG_RESET_REG,\n\t\t       IPW_AUX_HOST_RESET_REG_SW_RESET);\n\n\t\n\tfor (i = 0; i < 1000; i++) {\n\t\tudelay(IPW_WAIT_RESET_ARC_COMPLETE_DELAY);\n\n\t\t\n\t\tread_register(priv->net_dev, IPW_REG_RESET_REG, &r);\n\t\tif (r & IPW_AUX_HOST_RESET_REG_PRINCETON_RESET)\n\t\t\tbreak;\n\t}\n\n\tif (i == 1000)\n\t\treturn -EIO;\t\n\n\t \n\twrite_register(priv->net_dev, IPW_REG_GP_CNTRL,\n\t\t       IPW_AUX_HOST_GP_CNTRL_BIT_INIT_DONE);\n\n\t \n\tfor (i = 0; i < 10000; i++) {\n\t\tudelay(IPW_WAIT_CLOCK_STABILIZATION_DELAY * 4);\n\n\t\t \n\t\tread_register(priv->net_dev, IPW_REG_GP_CNTRL, &r);\n\t\tif (r & IPW_AUX_HOST_GP_CNTRL_BIT_CLOCK_READY)\n\t\t\tbreak;\n\t}\n\n\tif (i == 10000)\n\t\treturn -EIO;\t \n\n\t \n\tread_register(priv->net_dev, IPW_REG_GP_CNTRL, &r);\n\twrite_register(priv->net_dev, IPW_REG_GP_CNTRL,\n\t\t       r | IPW_AUX_HOST_GP_CNTRL_BIT_HOST_ALLOWS_STANDBY);\n\n\treturn 0;\n}\n\n \nstatic int ipw2100_download_firmware(struct ipw2100_priv *priv)\n{\n\tu32 address;\n\tint err;\n\n#ifndef CONFIG_PM\n\t \n\tstruct ipw2100_fw ipw2100_firmware;\n#endif\n\n\tif (priv->fatal_error) {\n\t\tIPW_DEBUG_ERROR(\"%s: ipw2100_download_firmware called after \"\n\t\t\t\t\"fatal error %d.  Interface must be brought down.\\n\",\n\t\t\t\tpriv->net_dev->name, priv->fatal_error);\n\t\treturn -EINVAL;\n\t}\n#ifdef CONFIG_PM\n\tif (!ipw2100_firmware.version) {\n\t\terr = ipw2100_get_firmware(priv, &ipw2100_firmware);\n\t\tif (err) {\n\t\t\tIPW_DEBUG_ERROR(\"%s: ipw2100_get_firmware failed: %d\\n\",\n\t\t\t\t\tpriv->net_dev->name, err);\n\t\t\tpriv->fatal_error = IPW2100_ERR_FW_LOAD;\n\t\t\tgoto fail;\n\t\t}\n\t}\n#else\n\terr = ipw2100_get_firmware(priv, &ipw2100_firmware);\n\tif (err) {\n\t\tIPW_DEBUG_ERROR(\"%s: ipw2100_get_firmware failed: %d\\n\",\n\t\t\t\tpriv->net_dev->name, err);\n\t\tpriv->fatal_error = IPW2100_ERR_FW_LOAD;\n\t\tgoto fail;\n\t}\n#endif\n\tpriv->firmware_version = ipw2100_firmware.version;\n\n\t \n\terr = sw_reset_and_clock(priv);\n\tif (err) {\n\t\tIPW_DEBUG_ERROR(\"%s: sw_reset_and_clock failed: %d\\n\",\n\t\t\t\tpriv->net_dev->name, err);\n\t\tgoto fail;\n\t}\n\n\terr = ipw2100_verify(priv);\n\tif (err) {\n\t\tIPW_DEBUG_ERROR(\"%s: ipw2100_verify failed: %d\\n\",\n\t\t\t\tpriv->net_dev->name, err);\n\t\tgoto fail;\n\t}\n\n\t \n\twrite_nic_dword(priv->net_dev,\n\t\t\tIPW_INTERNAL_REGISTER_HALT_AND_RESET, 0x80000000);\n\n\t \n\twrite_register(priv->net_dev, IPW_REG_RESET_REG, 0);\n\n\t \n\terr = ipw2100_ucode_download(priv, &ipw2100_firmware);\n\tif (err) {\n\t\tprintk(KERN_ERR DRV_NAME \": %s: Error loading microcode: %d\\n\",\n\t\t       priv->net_dev->name, err);\n\t\tgoto fail;\n\t}\n\n\t \n\twrite_nic_dword(priv->net_dev,\n\t\t\tIPW_INTERNAL_REGISTER_HALT_AND_RESET, 0x00000000);\n\n\t \n\terr = sw_reset_and_clock(priv);\n\tif (err) {\n\t\tprintk(KERN_ERR DRV_NAME\n\t\t       \": %s: sw_reset_and_clock failed: %d\\n\",\n\t\t       priv->net_dev->name, err);\n\t\tgoto fail;\n\t}\n\n\t \n\terr = ipw2100_fw_download(priv, &ipw2100_firmware);\n\tif (err) {\n\t\tIPW_DEBUG_ERROR(\"%s: Error loading firmware: %d\\n\",\n\t\t\t\tpriv->net_dev->name, err);\n\t\tgoto fail;\n\t}\n#ifndef CONFIG_PM\n\t \n\n\t \n\tipw2100_release_firmware(priv, &ipw2100_firmware);\n#endif\n\n\t \n\tfor (address = IPW_HOST_FW_SHARED_AREA0;\n\t     address < IPW_HOST_FW_SHARED_AREA0_END; address += 4)\n\t\twrite_nic_dword(priv->net_dev, address, 0);\n\tfor (address = IPW_HOST_FW_SHARED_AREA1;\n\t     address < IPW_HOST_FW_SHARED_AREA1_END; address += 4)\n\t\twrite_nic_dword(priv->net_dev, address, 0);\n\tfor (address = IPW_HOST_FW_SHARED_AREA2;\n\t     address < IPW_HOST_FW_SHARED_AREA2_END; address += 4)\n\t\twrite_nic_dword(priv->net_dev, address, 0);\n\tfor (address = IPW_HOST_FW_SHARED_AREA3;\n\t     address < IPW_HOST_FW_SHARED_AREA3_END; address += 4)\n\t\twrite_nic_dword(priv->net_dev, address, 0);\n\tfor (address = IPW_HOST_FW_INTERRUPT_AREA;\n\t     address < IPW_HOST_FW_INTERRUPT_AREA_END; address += 4)\n\t\twrite_nic_dword(priv->net_dev, address, 0);\n\n\treturn 0;\n\n      fail:\n\tipw2100_release_firmware(priv, &ipw2100_firmware);\n\treturn err;\n}\n\nstatic inline void ipw2100_enable_interrupts(struct ipw2100_priv *priv)\n{\n\tif (priv->status & STATUS_INT_ENABLED)\n\t\treturn;\n\tpriv->status |= STATUS_INT_ENABLED;\n\twrite_register(priv->net_dev, IPW_REG_INTA_MASK, IPW_INTERRUPT_MASK);\n}\n\nstatic inline void ipw2100_disable_interrupts(struct ipw2100_priv *priv)\n{\n\tif (!(priv->status & STATUS_INT_ENABLED))\n\t\treturn;\n\tpriv->status &= ~STATUS_INT_ENABLED;\n\twrite_register(priv->net_dev, IPW_REG_INTA_MASK, 0x0);\n}\n\nstatic void ipw2100_initialize_ordinals(struct ipw2100_priv *priv)\n{\n\tstruct ipw2100_ordinals *ord = &priv->ordinals;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tread_register(priv->net_dev, IPW_MEM_HOST_SHARED_ORDINALS_TABLE_1,\n\t\t      &ord->table1_addr);\n\n\tread_register(priv->net_dev, IPW_MEM_HOST_SHARED_ORDINALS_TABLE_2,\n\t\t      &ord->table2_addr);\n\n\tread_nic_dword(priv->net_dev, ord->table1_addr, &ord->table1_size);\n\tread_nic_dword(priv->net_dev, ord->table2_addr, &ord->table2_size);\n\n\tord->table2_size &= 0x0000FFFF;\n\n\tIPW_DEBUG_INFO(\"table 1 size: %d\\n\", ord->table1_size);\n\tIPW_DEBUG_INFO(\"table 2 size: %d\\n\", ord->table2_size);\n\tIPW_DEBUG_INFO(\"exit\\n\");\n}\n\nstatic inline void ipw2100_hw_set_gpio(struct ipw2100_priv *priv)\n{\n\tu32 reg = 0;\n\t \n\treg = (IPW_BIT_GPIO_GPIO3_MASK | IPW_BIT_GPIO_GPIO1_ENABLE |\n\t       IPW_BIT_GPIO_LED_OFF);\n\twrite_register(priv->net_dev, IPW_REG_GPIO, reg);\n}\n\nstatic int rf_kill_active(struct ipw2100_priv *priv)\n{\n#define MAX_RF_KILL_CHECKS 5\n#define RF_KILL_CHECK_DELAY 40\n\n\tunsigned short value = 0;\n\tu32 reg = 0;\n\tint i;\n\n\tif (!(priv->hw_features & HW_FEATURE_RFKILL)) {\n\t\twiphy_rfkill_set_hw_state(priv->ieee->wdev.wiphy, false);\n\t\tpriv->status &= ~STATUS_RF_KILL_HW;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < MAX_RF_KILL_CHECKS; i++) {\n\t\tudelay(RF_KILL_CHECK_DELAY);\n\t\tread_register(priv->net_dev, IPW_REG_GPIO, &reg);\n\t\tvalue = (value << 1) | ((reg & IPW_BIT_GPIO_RF_KILL) ? 0 : 1);\n\t}\n\n\tif (value == 0) {\n\t\twiphy_rfkill_set_hw_state(priv->ieee->wdev.wiphy, true);\n\t\tpriv->status |= STATUS_RF_KILL_HW;\n\t} else {\n\t\twiphy_rfkill_set_hw_state(priv->ieee->wdev.wiphy, false);\n\t\tpriv->status &= ~STATUS_RF_KILL_HW;\n\t}\n\n\treturn (value == 0);\n}\n\nstatic int ipw2100_get_hw_features(struct ipw2100_priv *priv)\n{\n\tu32 addr, len;\n\tu32 val;\n\n\t \n\tlen = sizeof(addr);\n\tif (ipw2100_get_ordinal\n\t    (priv, IPW_ORD_EEPROM_SRAM_DB_BLOCK_START_ADDRESS, &addr, &len)) {\n\t\tIPW_DEBUG_INFO(\"failed querying ordinals at line %d\\n\",\n\t\t\t       __LINE__);\n\t\treturn -EIO;\n\t}\n\n\tIPW_DEBUG_INFO(\"EEPROM address: %08X\\n\", addr);\n\n\t \n\tread_nic_dword(priv->net_dev, addr + 0xFC, &val);\n\tpriv->eeprom_version = (val >> 24) & 0xFF;\n\tIPW_DEBUG_INFO(\"EEPROM version: %d\\n\", priv->eeprom_version);\n\n\t \n\tread_nic_dword(priv->net_dev, addr + 0x20, &val);\n\tif (!((val >> 24) & 0x01))\n\t\tpriv->hw_features |= HW_FEATURE_RFKILL;\n\n\tIPW_DEBUG_INFO(\"HW RF Kill: %ssupported.\\n\",\n\t\t       (priv->hw_features & HW_FEATURE_RFKILL) ? \"\" : \"not \");\n\n\treturn 0;\n}\n\n \nstatic int ipw2100_start_adapter(struct ipw2100_priv *priv)\n{\n\tint i;\n\tu32 inta, inta_mask, gpio;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tif (priv->status & STATUS_RUNNING)\n\t\treturn 0;\n\n\t \n\tif (ipw2100_download_firmware(priv)) {\n\t\tprintk(KERN_ERR DRV_NAME\n\t\t       \": %s: Failed to power on the adapter.\\n\",\n\t\t       priv->net_dev->name);\n\t\treturn -EIO;\n\t}\n\n\t \n\tipw2100_queues_initialize(priv);\n\n\tipw2100_hw_set_gpio(priv);\n\n\t \n\n\t \n\twrite_register(priv->net_dev, IPW_REG_RESET_REG, 0);\n\n\t \n\tIPW_DEBUG_FW(\"Waiting for f/w initialization to complete...\\n\");\n\ti = 5000;\n\tdo {\n\t\tschedule_timeout_uninterruptible(msecs_to_jiffies(40));\n\t\t \n\n\t\tread_register(priv->net_dev, IPW_REG_INTA, &inta);\n\n\t\t \n\t\tif (inta & IPW2100_INTA_FW_INIT_DONE) {\n\t\t\t \n\t\t\twrite_register(priv->net_dev, IPW_REG_INTA,\n\t\t\t\t       IPW2100_INTA_FW_INIT_DONE);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (inta &\n\t\t    (IPW2100_INTA_FATAL_ERROR | IPW2100_INTA_PARITY_ERROR)) {\n\t\t\t \n\t\t\twrite_register(priv->net_dev, IPW_REG_INTA,\n\t\t\t\t       IPW2100_INTA_FATAL_ERROR |\n\t\t\t\t       IPW2100_INTA_PARITY_ERROR);\n\t\t}\n\t} while (--i);\n\n\t \n\tread_register(priv->net_dev, IPW_REG_INTA, &inta);\n\tread_register(priv->net_dev, IPW_REG_INTA_MASK, &inta_mask);\n\tinta &= IPW_INTERRUPT_MASK;\n\t \n\tif (inta & inta_mask)\n\t\twrite_register(priv->net_dev, IPW_REG_INTA, inta);\n\n\tIPW_DEBUG_FW(\"f/w initialization complete: %s\\n\",\n\t\t     i ? \"SUCCESS\" : \"FAILED\");\n\n\tif (!i) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \": %s: Firmware did not initialize.\\n\",\n\t\t       priv->net_dev->name);\n\t\treturn -EIO;\n\t}\n\n\t \n\tread_register(priv->net_dev, IPW_REG_GPIO, &gpio);\n\n\tgpio |= (IPW_BIT_GPIO_GPIO1_MASK | IPW_BIT_GPIO_GPIO3_MASK);\n\n\twrite_register(priv->net_dev, IPW_REG_GPIO, gpio);\n\n\t \n\tpriv->status |= STATUS_RUNNING;\n\n\t \n\tpriv->status &= ~(STATUS_ASSOCIATING | STATUS_ASSOCIATED);\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n\n\treturn 0;\n}\n\nstatic inline void ipw2100_reset_fatalerror(struct ipw2100_priv *priv)\n{\n\tif (!priv->fatal_error)\n\t\treturn;\n\n\tpriv->fatal_errors[priv->fatal_index++] = priv->fatal_error;\n\tpriv->fatal_index %= IPW2100_ERROR_QUEUE;\n\tpriv->fatal_error = 0;\n}\n\n \nstatic int ipw2100_power_cycle_adapter(struct ipw2100_priv *priv)\n{\n\tu32 reg;\n\tint i;\n\n\tIPW_DEBUG_INFO(\"Power cycling the hardware.\\n\");\n\n\tipw2100_hw_set_gpio(priv);\n\n\t \n\twrite_register(priv->net_dev, IPW_REG_RESET_REG,\n\t\t       IPW_AUX_HOST_RESET_REG_STOP_MASTER);\n\n\t \n\ti = 5;\n\tdo {\n\t\tudelay(IPW_WAIT_RESET_MASTER_ASSERT_COMPLETE_DELAY);\n\t\tread_register(priv->net_dev, IPW_REG_RESET_REG, &reg);\n\n\t\tif (reg & IPW_AUX_HOST_RESET_REG_MASTER_DISABLED)\n\t\t\tbreak;\n\t} while (--i);\n\n\tpriv->status &= ~STATUS_RESET_PENDING;\n\n\tif (!i) {\n\t\tIPW_DEBUG_INFO\n\t\t    (\"exit - waited too long for master assert stop\\n\");\n\t\treturn -EIO;\n\t}\n\n\twrite_register(priv->net_dev, IPW_REG_RESET_REG,\n\t\t       IPW_AUX_HOST_RESET_REG_SW_RESET);\n\n\t \n\tipw2100_reset_fatalerror(priv);\n\n\t \n\tpriv->status &= ~(STATUS_RUNNING | STATUS_ASSOCIATING |\n\t\t\t  STATUS_ASSOCIATED | STATUS_ENABLED);\n\n\treturn 0;\n}\n\n \nstatic int ipw2100_hw_phy_off(struct ipw2100_priv *priv)\n{\n\n#define HW_PHY_OFF_LOOP_DELAY (msecs_to_jiffies(50))\n\n\tstruct host_command cmd = {\n\t\t.host_command = CARD_DISABLE_PHY_OFF,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 0,\n\t};\n\tint err, i;\n\tu32 val1, val2;\n\n\tIPW_DEBUG_HC(\"CARD_DISABLE_PHY_OFF\\n\");\n\n\t \n\terr = ipw2100_hw_send_command(priv, &cmd);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < 2500; i++) {\n\t\tread_nic_dword(priv->net_dev, IPW2100_CONTROL_REG, &val1);\n\t\tread_nic_dword(priv->net_dev, IPW2100_COMMAND, &val2);\n\n\t\tif ((val1 & IPW2100_CONTROL_PHY_OFF) &&\n\t\t    (val2 & IPW2100_COMMAND_PHY_OFF))\n\t\t\treturn 0;\n\n\t\tschedule_timeout_uninterruptible(HW_PHY_OFF_LOOP_DELAY);\n\t}\n\n\treturn -EIO;\n}\n\nstatic int ipw2100_enable_adapter(struct ipw2100_priv *priv)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = HOST_COMPLETE,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 0\n\t};\n\tint err = 0;\n\n\tIPW_DEBUG_HC(\"HOST_COMPLETE\\n\");\n\n\tif (priv->status & STATUS_ENABLED)\n\t\treturn 0;\n\n\tmutex_lock(&priv->adapter_mutex);\n\n\tif (rf_kill_active(priv)) {\n\t\tIPW_DEBUG_HC(\"Command aborted due to RF kill active.\\n\");\n\t\tgoto fail_up;\n\t}\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\tif (err) {\n\t\tIPW_DEBUG_INFO(\"Failed to send HOST_COMPLETE command\\n\");\n\t\tgoto fail_up;\n\t}\n\n\terr = ipw2100_wait_for_card_state(priv, IPW_HW_STATE_ENABLED);\n\tif (err) {\n\t\tIPW_DEBUG_INFO(\"%s: card not responding to init command.\\n\",\n\t\t\t       priv->net_dev->name);\n\t\tgoto fail_up;\n\t}\n\n\tif (priv->stop_hang_check) {\n\t\tpriv->stop_hang_check = 0;\n\t\tschedule_delayed_work(&priv->hang_check, HZ / 2);\n\t}\n\n      fail_up:\n\tmutex_unlock(&priv->adapter_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_hw_stop_adapter(struct ipw2100_priv *priv)\n{\n#define HW_POWER_DOWN_DELAY (msecs_to_jiffies(100))\n\n\tstruct host_command cmd = {\n\t\t.host_command = HOST_PRE_POWER_DOWN,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 0,\n\t};\n\tint err, i;\n\tu32 reg;\n\n\tif (!(priv->status & STATUS_RUNNING))\n\t\treturn 0;\n\n\tpriv->status |= STATUS_STOPPING;\n\n\t \n\tif (!priv->fatal_error) {\n\t\t \n\t\tipw2100_enable_adapter(priv);\n\n\t\terr = ipw2100_hw_phy_off(priv);\n\t\tif (err)\n\t\t\tprintk(KERN_WARNING DRV_NAME\n\t\t\t       \": Error disabling radio %d\\n\", err);\n\n\t\t \n\t\tIPW_DEBUG_HC(\"HOST_PRE_POWER_DOWN\\n\");\n\n\t\terr = ipw2100_hw_send_command(priv, &cmd);\n\t\tif (err)\n\t\t\tprintk(KERN_WARNING DRV_NAME \": \"\n\t\t\t       \"%s: Power down command failed: Error %d\\n\",\n\t\t\t       priv->net_dev->name, err);\n\t\telse\n\t\t\tschedule_timeout_uninterruptible(HW_POWER_DOWN_DELAY);\n\t}\n\n\tpriv->status &= ~STATUS_ENABLED;\n\n\t \n\tipw2100_hw_set_gpio(priv);\n\n\t \n\n\t \n\twrite_register(priv->net_dev, IPW_REG_RESET_REG,\n\t\t       IPW_AUX_HOST_RESET_REG_STOP_MASTER);\n\n\t \n\tfor (i = 5; i > 0; i--) {\n\t\tudelay(10);\n\n\t\t \n\t\tread_register(priv->net_dev, IPW_REG_RESET_REG, &reg);\n\n\t\tif (reg & IPW_AUX_HOST_RESET_REG_MASTER_DISABLED)\n\t\t\tbreak;\n\t}\n\n\tif (i == 0)\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \": %s: Could now power down adapter.\\n\",\n\t\t       priv->net_dev->name);\n\n\t \n\twrite_register(priv->net_dev, IPW_REG_RESET_REG,\n\t\t       IPW_AUX_HOST_RESET_REG_SW_RESET);\n\n\tpriv->status &= ~(STATUS_RUNNING | STATUS_STOPPING);\n\n\treturn 0;\n}\n\nstatic int ipw2100_disable_adapter(struct ipw2100_priv *priv)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = CARD_DISABLE,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 0\n\t};\n\tint err = 0;\n\n\tIPW_DEBUG_HC(\"CARD_DISABLE\\n\");\n\n\tif (!(priv->status & STATUS_ENABLED))\n\t\treturn 0;\n\n\t \n\tpriv->status &= ~(STATUS_ASSOCIATED | STATUS_ASSOCIATING);\n\n\tif (!priv->stop_hang_check) {\n\t\tpriv->stop_hang_check = 1;\n\t\tcancel_delayed_work(&priv->hang_check);\n\t}\n\n\tmutex_lock(&priv->adapter_mutex);\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\tif (err) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \": exit - failed to send CARD_DISABLE command\\n\");\n\t\tgoto fail_up;\n\t}\n\n\terr = ipw2100_wait_for_card_state(priv, IPW_HW_STATE_DISABLED);\n\tif (err) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \": exit - card failed to change to DISABLED\\n\");\n\t\tgoto fail_up;\n\t}\n\n\tIPW_DEBUG_INFO(\"TODO: implement scan state machine\\n\");\n\n      fail_up:\n\tmutex_unlock(&priv->adapter_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_set_scan_options(struct ipw2100_priv *priv)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = SET_SCAN_OPTIONS,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 8\n\t};\n\tint err;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tIPW_DEBUG_SCAN(\"setting scan options\\n\");\n\n\tcmd.host_command_parameters[0] = 0;\n\n\tif (!(priv->config & CFG_ASSOCIATE))\n\t\tcmd.host_command_parameters[0] |= IPW_SCAN_NOASSOCIATE;\n\tif ((priv->ieee->sec.flags & SEC_ENABLED) && priv->ieee->sec.enabled)\n\t\tcmd.host_command_parameters[0] |= IPW_SCAN_MIXED_CELL;\n\tif (priv->config & CFG_PASSIVE_SCAN)\n\t\tcmd.host_command_parameters[0] |= IPW_SCAN_PASSIVE;\n\n\tcmd.host_command_parameters[1] = priv->channel_mask;\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\n\tIPW_DEBUG_HC(\"SET_SCAN_OPTIONS 0x%04X\\n\",\n\t\t     cmd.host_command_parameters[0]);\n\n\treturn err;\n}\n\nstatic int ipw2100_start_scan(struct ipw2100_priv *priv)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = BROADCAST_SCAN,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 4\n\t};\n\tint err;\n\n\tIPW_DEBUG_HC(\"START_SCAN\\n\");\n\n\tcmd.host_command_parameters[0] = 0;\n\n\t \n\tif (priv->ieee->iw_mode == IW_MODE_MONITOR)\n\t\treturn 1;\n\n\tif (priv->status & STATUS_SCANNING) {\n\t\tIPW_DEBUG_SCAN(\"Scan requested while already in scan...\\n\");\n\t\treturn 0;\n\t}\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\t \n\tIPW_DEBUG_SCAN(\"starting scan\\n\");\n\n\tpriv->status |= STATUS_SCANNING;\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\tif (err)\n\t\tpriv->status &= ~STATUS_SCANNING;\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n\n\treturn err;\n}\n\nstatic const struct libipw_geo ipw_geos[] = {\n\t{\t\t\t \n\t \"---\",\n\t .bg_channels = 14,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11}, {2467, 12},\n\t\t{2472, 13}, {2484, 14}},\n\t },\n};\n\nstatic int ipw2100_up(struct ipw2100_priv *priv, int deferred)\n{\n\tunsigned long flags;\n\tint err = 0;\n\tu32 lock;\n\tu32 ord_len = sizeof(lock);\n\n\t \n\tif (priv->suspend_time) {\n\t\tlibipw_networks_age(priv->ieee, priv->suspend_time);\n\t\tpriv->suspend_time = 0;\n\t}\n\n\t \n\tif (priv->status & STATUS_RF_KILL_SW) {\n\t\tIPW_DEBUG_INFO(\"%s: Radio is disabled by Manual Disable \"\n\t\t\t       \"switch\\n\", priv->net_dev->name);\n\t\treturn 0;\n\t}\n\n\t \n\tcpu_latency_qos_update_request(&ipw2100_pm_qos_req, 175);\n\n\t \n\tspin_lock_irqsave(&priv->low_lock, flags);\n\tipw2100_disable_interrupts(priv);\n\n\t \n\tipw2100_reset_fatalerror(priv);\n\tspin_unlock_irqrestore(&priv->low_lock, flags);\n\n\tif (priv->status & STATUS_POWERED ||\n\t    (priv->status & STATUS_RESET_PENDING)) {\n\t\t \n\t\terr = ipw2100_power_cycle_adapter(priv);\n\t\tif (err) {\n\t\t\tprintk(KERN_WARNING DRV_NAME\n\t\t\t       \": %s: Could not cycle adapter.\\n\",\n\t\t\t       priv->net_dev->name);\n\t\t\tgoto exit;\n\t\t}\n\t} else\n\t\tpriv->status |= STATUS_POWERED;\n\n\t \n\terr = ipw2100_start_adapter(priv);\n\tif (err) {\n\t\tprintk(KERN_ERR DRV_NAME\n\t\t       \": %s: Failed to start the firmware.\\n\",\n\t\t       priv->net_dev->name);\n\t\tgoto exit;\n\t}\n\n\tipw2100_initialize_ordinals(priv);\n\n\t \n\terr = ipw2100_get_hw_features(priv);\n\tif (err) {\n\t\tprintk(KERN_ERR DRV_NAME\n\t\t       \": %s: Failed to determine HW features.\\n\",\n\t\t       priv->net_dev->name);\n\t\tgoto exit;\n\t}\n\n\t \n\tlibipw_set_geo(priv->ieee, &ipw_geos[0]);\n\tpriv->ieee->freq_band = LIBIPW_24GHZ_BAND;\n\n\tlock = LOCK_NONE;\n\terr = ipw2100_set_ordinal(priv, IPW_ORD_PERS_DB_LOCK, &lock, &ord_len);\n\tif (err) {\n\t\tprintk(KERN_ERR DRV_NAME\n\t\t       \": %s: Failed to clear ordinal lock.\\n\",\n\t\t       priv->net_dev->name);\n\t\tgoto exit;\n\t}\n\n\tpriv->status &= ~STATUS_SCANNING;\n\n\tif (rf_kill_active(priv)) {\n\t\tprintk(KERN_INFO \"%s: Radio is disabled by RF switch.\\n\",\n\t\t       priv->net_dev->name);\n\n\t\tif (priv->stop_rf_kill) {\n\t\t\tpriv->stop_rf_kill = 0;\n\t\t\tschedule_delayed_work(&priv->rf_kill,\n\t\t\t\t\t      round_jiffies_relative(HZ));\n\t\t}\n\n\t\tdeferred = 1;\n\t}\n\n\t \n\tipw2100_enable_interrupts(priv);\n\n\t \n\terr = ipw2100_adapter_setup(priv);\n\tif (err) {\n\t\tprintk(KERN_ERR DRV_NAME \": %s: Failed to start the card.\\n\",\n\t\t       priv->net_dev->name);\n\t\tgoto exit;\n\t}\n\n\tif (!deferred) {\n\t\t \n\t\terr = ipw2100_enable_adapter(priv);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR DRV_NAME \": \"\n\t\t\t       \"%s: failed in call to enable adapter.\\n\",\n\t\t\t       priv->net_dev->name);\n\t\t\tipw2100_hw_stop_adapter(priv);\n\t\t\tgoto exit;\n\t\t}\n\n\t\t \n\t\tipw2100_set_scan_options(priv);\n\t\tipw2100_start_scan(priv);\n\t}\n\n      exit:\n\treturn err;\n}\n\nstatic void ipw2100_down(struct ipw2100_priv *priv)\n{\n\tunsigned long flags;\n\tunion iwreq_data wrqu = {\n\t\t.ap_addr = {\n\t\t\t    .sa_family = ARPHRD_ETHER}\n\t};\n\tint associated = priv->status & STATUS_ASSOCIATED;\n\n\t \n\tif (!priv->stop_rf_kill) {\n\t\tpriv->stop_rf_kill = 1;\n\t\tcancel_delayed_work(&priv->rf_kill);\n\t}\n\n\t \n\tif (!priv->stop_hang_check) {\n\t\tpriv->stop_hang_check = 1;\n\t\tcancel_delayed_work(&priv->hang_check);\n\t}\n\n\t \n\tif (priv->status & STATUS_RESET_PENDING)\n\t\tcancel_delayed_work(&priv->reset_work);\n\n\t \n\tspin_lock_irqsave(&priv->low_lock, flags);\n\tipw2100_enable_interrupts(priv);\n\tspin_unlock_irqrestore(&priv->low_lock, flags);\n\n\tif (ipw2100_hw_stop_adapter(priv))\n\t\tprintk(KERN_ERR DRV_NAME \": %s: Error stopping adapter.\\n\",\n\t\t       priv->net_dev->name);\n\n\t \n\tspin_lock_irqsave(&priv->low_lock, flags);\n\tipw2100_disable_interrupts(priv);\n\tspin_unlock_irqrestore(&priv->low_lock, flags);\n\n\tcpu_latency_qos_update_request(&ipw2100_pm_qos_req,\n\t\t\t\t       PM_QOS_DEFAULT_VALUE);\n\n\t \n\tif (associated)\n\t\twireless_send_event(priv->net_dev, SIOCGIWAP, &wrqu, NULL);\n\n\tpriv->status &= ~(STATUS_ASSOCIATED | STATUS_ASSOCIATING);\n\tnetif_carrier_off(priv->net_dev);\n\tnetif_stop_queue(priv->net_dev);\n}\n\nstatic int ipw2100_wdev_init(struct net_device *dev)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tconst struct libipw_geo *geo = libipw_get_geo(priv->ieee);\n\tstruct wireless_dev *wdev = &priv->ieee->wdev;\n\tint i;\n\n\tmemcpy(wdev->wiphy->perm_addr, priv->mac_addr, ETH_ALEN);\n\n\t \n\tif (geo->bg_channels) {\n\t\tstruct ieee80211_supported_band *bg_band = &priv->ieee->bg_band;\n\n\t\tbg_band->band = NL80211_BAND_2GHZ;\n\t\tbg_band->n_channels = geo->bg_channels;\n\t\tbg_band->channels = kcalloc(geo->bg_channels,\n\t\t\t\t\t    sizeof(struct ieee80211_channel),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!bg_band->channels) {\n\t\t\tipw2100_down(priv);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\t \n\t\tfor (i = 0; i < geo->bg_channels; i++) {\n\t\t\tbg_band->channels[i].band = NL80211_BAND_2GHZ;\n\t\t\tbg_band->channels[i].center_freq = geo->bg[i].freq;\n\t\t\tbg_band->channels[i].hw_value = geo->bg[i].channel;\n\t\t\tbg_band->channels[i].max_power = geo->bg[i].max_power;\n\t\t\tif (geo->bg[i].flags & LIBIPW_CH_PASSIVE_ONLY)\n\t\t\t\tbg_band->channels[i].flags |=\n\t\t\t\t\tIEEE80211_CHAN_NO_IR;\n\t\t\tif (geo->bg[i].flags & LIBIPW_CH_NO_IBSS)\n\t\t\t\tbg_band->channels[i].flags |=\n\t\t\t\t\tIEEE80211_CHAN_NO_IR;\n\t\t\tif (geo->bg[i].flags & LIBIPW_CH_RADAR_DETECT)\n\t\t\t\tbg_band->channels[i].flags |=\n\t\t\t\t\tIEEE80211_CHAN_RADAR;\n\t\t\t \n\t\t}\n\t\t \n\t\tbg_band->bitrates = ipw2100_bg_rates;\n\t\tbg_band->n_bitrates = RATE_COUNT;\n\n\t\twdev->wiphy->bands[NL80211_BAND_2GHZ] = bg_band;\n\t}\n\n\twdev->wiphy->cipher_suites = ipw_cipher_suites;\n\twdev->wiphy->n_cipher_suites = ARRAY_SIZE(ipw_cipher_suites);\n\n\tset_wiphy_dev(wdev->wiphy, &priv->pci_dev->dev);\n\tif (wiphy_register(wdev->wiphy))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic void ipw2100_reset_adapter(struct work_struct *work)\n{\n\tstruct ipw2100_priv *priv =\n\t\tcontainer_of(work, struct ipw2100_priv, reset_work.work);\n\tunsigned long flags;\n\tunion iwreq_data wrqu = {\n\t\t.ap_addr = {\n\t\t\t    .sa_family = ARPHRD_ETHER}\n\t};\n\tint associated = priv->status & STATUS_ASSOCIATED;\n\n\tspin_lock_irqsave(&priv->low_lock, flags);\n\tIPW_DEBUG_INFO(\": %s: Restarting adapter.\\n\", priv->net_dev->name);\n\tpriv->resets++;\n\tpriv->status &= ~(STATUS_ASSOCIATED | STATUS_ASSOCIATING);\n\tpriv->status |= STATUS_SECURITY_UPDATED;\n\n\t \n\tcancel_delayed_work(&priv->reset_work);\n\tpriv->status |= STATUS_RESET_PENDING;\n\tspin_unlock_irqrestore(&priv->low_lock, flags);\n\n\tmutex_lock(&priv->action_mutex);\n\t \n\tpriv->stop_hang_check = 1;\n\tcancel_delayed_work(&priv->hang_check);\n\n\t \n\tif (associated)\n\t\twireless_send_event(priv->net_dev, SIOCGIWAP, &wrqu, NULL);\n\n\tipw2100_up(priv, 0);\n\tmutex_unlock(&priv->action_mutex);\n\n}\n\nstatic void isr_indicate_associated(struct ipw2100_priv *priv, u32 status)\n{\n\n#define MAC_ASSOCIATION_READ_DELAY (HZ)\n\tint ret;\n\tunsigned int len, essid_len;\n\tchar essid[IW_ESSID_MAX_SIZE];\n\tu32 txrate;\n\tu32 chan;\n\tchar *txratename;\n\tu8 bssid[ETH_ALEN];\n\n\t \n\n\tessid_len = IW_ESSID_MAX_SIZE;\n\tret = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_SSID,\n\t\t\t\t  essid, &essid_len);\n\tif (ret) {\n\t\tIPW_DEBUG_INFO(\"failed querying ordinals at line %d\\n\",\n\t\t\t       __LINE__);\n\t\treturn;\n\t}\n\n\tlen = sizeof(u32);\n\tret = ipw2100_get_ordinal(priv, IPW_ORD_CURRENT_TX_RATE, &txrate, &len);\n\tif (ret) {\n\t\tIPW_DEBUG_INFO(\"failed querying ordinals at line %d\\n\",\n\t\t\t       __LINE__);\n\t\treturn;\n\t}\n\n\tlen = sizeof(u32);\n\tret = ipw2100_get_ordinal(priv, IPW_ORD_OUR_FREQ, &chan, &len);\n\tif (ret) {\n\t\tIPW_DEBUG_INFO(\"failed querying ordinals at line %d\\n\",\n\t\t\t       __LINE__);\n\t\treturn;\n\t}\n\tlen = ETH_ALEN;\n\tret = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_AP_BSSID, bssid,\n\t\t\t\t  &len);\n\tif (ret) {\n\t\tIPW_DEBUG_INFO(\"failed querying ordinals at line %d\\n\",\n\t\t\t       __LINE__);\n\t\treturn;\n\t}\n\tmemcpy(priv->ieee->bssid, bssid, ETH_ALEN);\n\n\tswitch (txrate) {\n\tcase TX_RATE_1_MBIT:\n\t\ttxratename = \"1Mbps\";\n\t\tbreak;\n\tcase TX_RATE_2_MBIT:\n\t\ttxratename = \"2Mbsp\";\n\t\tbreak;\n\tcase TX_RATE_5_5_MBIT:\n\t\ttxratename = \"5.5Mbps\";\n\t\tbreak;\n\tcase TX_RATE_11_MBIT:\n\t\ttxratename = \"11Mbps\";\n\t\tbreak;\n\tdefault:\n\t\tIPW_DEBUG_INFO(\"Unknown rate: %d\\n\", txrate);\n\t\ttxratename = \"unknown rate\";\n\t\tbreak;\n\t}\n\n\tIPW_DEBUG_INFO(\"%s: Associated with '%*pE' at %s, channel %d (BSSID=%pM)\\n\",\n\t\t       priv->net_dev->name, essid_len, essid,\n\t\t       txratename, chan, bssid);\n\n\t \n\tif (!(priv->config & CFG_STATIC_ESSID)) {\n\t\tpriv->essid_len = min((u8) essid_len, (u8) IW_ESSID_MAX_SIZE);\n\t\tmemcpy(priv->essid, essid, priv->essid_len);\n\t}\n\tpriv->channel = chan;\n\tmemcpy(priv->bssid, bssid, ETH_ALEN);\n\n\tpriv->status |= STATUS_ASSOCIATING;\n\tpriv->connect_start = ktime_get_boottime_seconds();\n\n\tschedule_delayed_work(&priv->wx_event_work, HZ / 10);\n}\n\nstatic int ipw2100_set_essid(struct ipw2100_priv *priv, char *essid,\n\t\t\t     int length, int batch_mode)\n{\n\tint ssid_len = min(length, IW_ESSID_MAX_SIZE);\n\tstruct host_command cmd = {\n\t\t.host_command = SSID,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = ssid_len\n\t};\n\tint err;\n\n\tIPW_DEBUG_HC(\"SSID: '%*pE'\\n\", ssid_len, essid);\n\n\tif (ssid_len)\n\t\tmemcpy(cmd.host_command_parameters, essid, ssid_len);\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_disable_adapter(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (!ssid_len && !(priv->config & CFG_ASSOCIATE)) {\n\t\tint i;\n\t\tu8 *bogus = (u8 *) cmd.host_command_parameters;\n\t\tfor (i = 0; i < IW_ESSID_MAX_SIZE; i++)\n\t\t\tbogus[i] = 0x18 + i;\n\t\tcmd.host_command_length = IW_ESSID_MAX_SIZE;\n\t}\n\n\t \n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\tif (!err) {\n\t\tmemset(priv->essid + ssid_len, 0, IW_ESSID_MAX_SIZE - ssid_len);\n\t\tmemcpy(priv->essid, essid, ssid_len);\n\t\tpriv->essid_len = ssid_len;\n\t}\n\n\tif (!batch_mode) {\n\t\tif (ipw2100_enable_adapter(priv))\n\t\t\terr = -EIO;\n\t}\n\n\treturn err;\n}\n\nstatic void isr_indicate_association_lost(struct ipw2100_priv *priv, u32 status)\n{\n\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE | IPW_DL_ASSOC,\n\t\t  \"disassociated: '%*pE' %pM\\n\", priv->essid_len, priv->essid,\n\t\t  priv->bssid);\n\n\tpriv->status &= ~(STATUS_ASSOCIATED | STATUS_ASSOCIATING);\n\n\tif (priv->status & STATUS_STOPPING) {\n\t\tIPW_DEBUG_INFO(\"Card is stopping itself, discard ASSN_LOST.\\n\");\n\t\treturn;\n\t}\n\n\teth_zero_addr(priv->bssid);\n\teth_zero_addr(priv->ieee->bssid);\n\n\tnetif_carrier_off(priv->net_dev);\n\tnetif_stop_queue(priv->net_dev);\n\n\tif (!(priv->status & STATUS_RUNNING))\n\t\treturn;\n\n\tif (priv->status & STATUS_SECURITY_UPDATED)\n\t\tschedule_delayed_work(&priv->security_work, 0);\n\n\tschedule_delayed_work(&priv->wx_event_work, 0);\n}\n\nstatic void isr_indicate_rf_kill(struct ipw2100_priv *priv, u32 status)\n{\n\tIPW_DEBUG_INFO(\"%s: RF Kill state changed to radio OFF.\\n\",\n\t\t       priv->net_dev->name);\n\n\t \n\twiphy_rfkill_set_hw_state(priv->ieee->wdev.wiphy, true);\n\tpriv->status |= STATUS_RF_KILL_HW;\n\n\t \n\tpriv->stop_rf_kill = 0;\n\tmod_delayed_work(system_wq, &priv->rf_kill, round_jiffies_relative(HZ));\n}\n\nstatic void ipw2100_scan_event(struct work_struct *work)\n{\n\tstruct ipw2100_priv *priv = container_of(work, struct ipw2100_priv,\n\t\t\t\t\t\t scan_event.work);\n\tunion iwreq_data wrqu;\n\n\twrqu.data.length = 0;\n\twrqu.data.flags = 0;\n\twireless_send_event(priv->net_dev, SIOCGIWSCAN, &wrqu, NULL);\n}\n\nstatic void isr_scan_complete(struct ipw2100_priv *priv, u32 status)\n{\n\tIPW_DEBUG_SCAN(\"scan complete\\n\");\n\t \n\tpriv->ieee->scans++;\n\tpriv->status &= ~STATUS_SCANNING;\n\n\t \n\tif (!priv->user_requested_scan) {\n\t\tschedule_delayed_work(&priv->scan_event,\n\t\t\t\t      round_jiffies_relative(msecs_to_jiffies(4000)));\n\t} else {\n\t\tpriv->user_requested_scan = 0;\n\t\tmod_delayed_work(system_wq, &priv->scan_event, 0);\n\t}\n}\n\n#ifdef CONFIG_IPW2100_DEBUG\n#define IPW2100_HANDLER(v, f) { v, f, # v }\nstruct ipw2100_status_indicator {\n\tint status;\n\tvoid (*cb) (struct ipw2100_priv * priv, u32 status);\n\tchar *name;\n};\n#else\n#define IPW2100_HANDLER(v, f) { v, f }\nstruct ipw2100_status_indicator {\n\tint status;\n\tvoid (*cb) (struct ipw2100_priv * priv, u32 status);\n};\n#endif\t\t\t\t \n\nstatic void isr_indicate_scanning(struct ipw2100_priv *priv, u32 status)\n{\n\tIPW_DEBUG_SCAN(\"Scanning...\\n\");\n\tpriv->status |= STATUS_SCANNING;\n}\n\nstatic const struct ipw2100_status_indicator status_handlers[] = {\n\tIPW2100_HANDLER(IPW_STATE_INITIALIZED, NULL),\n\tIPW2100_HANDLER(IPW_STATE_COUNTRY_FOUND, NULL),\n\tIPW2100_HANDLER(IPW_STATE_ASSOCIATED, isr_indicate_associated),\n\tIPW2100_HANDLER(IPW_STATE_ASSN_LOST, isr_indicate_association_lost),\n\tIPW2100_HANDLER(IPW_STATE_ASSN_CHANGED, NULL),\n\tIPW2100_HANDLER(IPW_STATE_SCAN_COMPLETE, isr_scan_complete),\n\tIPW2100_HANDLER(IPW_STATE_ENTERED_PSP, NULL),\n\tIPW2100_HANDLER(IPW_STATE_LEFT_PSP, NULL),\n\tIPW2100_HANDLER(IPW_STATE_RF_KILL, isr_indicate_rf_kill),\n\tIPW2100_HANDLER(IPW_STATE_DISABLED, NULL),\n\tIPW2100_HANDLER(IPW_STATE_POWER_DOWN, NULL),\n\tIPW2100_HANDLER(IPW_STATE_SCANNING, isr_indicate_scanning),\n\tIPW2100_HANDLER(-1, NULL)\n};\n\nstatic void isr_status_change(struct ipw2100_priv *priv, int status)\n{\n\tint i;\n\n\tif (status == IPW_STATE_SCANNING &&\n\t    priv->status & STATUS_ASSOCIATED &&\n\t    !(priv->status & STATUS_SCANNING)) {\n\t\tIPW_DEBUG_INFO(\"Scan detected while associated, with \"\n\t\t\t       \"no scan request.  Restarting firmware.\\n\");\n\n\t\t \n\t\tschedule_reset(priv);\n\t}\n\n\tfor (i = 0; status_handlers[i].status != -1; i++) {\n\t\tif (status == status_handlers[i].status) {\n\t\t\tIPW_DEBUG_NOTIF(\"Status change: %s\\n\",\n\t\t\t\t\tstatus_handlers[i].name);\n\t\t\tif (status_handlers[i].cb)\n\t\t\t\tstatus_handlers[i].cb(priv, status);\n\t\t\tpriv->wstats.status = status;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tIPW_DEBUG_NOTIF(\"unknown status received: %04x\\n\", status);\n}\n\nstatic void isr_rx_complete_command(struct ipw2100_priv *priv,\n\t\t\t\t    struct ipw2100_cmd_header *cmd)\n{\n#ifdef CONFIG_IPW2100_DEBUG\n\tif (cmd->host_command_reg < ARRAY_SIZE(command_types)) {\n\t\tIPW_DEBUG_HC(\"Command completed '%s (%d)'\\n\",\n\t\t\t     command_types[cmd->host_command_reg],\n\t\t\t     cmd->host_command_reg);\n\t}\n#endif\n\tif (cmd->host_command_reg == HOST_COMPLETE)\n\t\tpriv->status |= STATUS_ENABLED;\n\n\tif (cmd->host_command_reg == CARD_DISABLE)\n\t\tpriv->status &= ~STATUS_ENABLED;\n\n\tpriv->status &= ~STATUS_CMD_ACTIVE;\n\n\twake_up_interruptible(&priv->wait_command_queue);\n}\n\n#ifdef CONFIG_IPW2100_DEBUG\nstatic const char *frame_types[] = {\n\t\"COMMAND_STATUS_VAL\",\n\t\"STATUS_CHANGE_VAL\",\n\t\"P80211_DATA_VAL\",\n\t\"P8023_DATA_VAL\",\n\t\"HOST_NOTIFICATION_VAL\"\n};\n#endif\n\nstatic int ipw2100_alloc_skb(struct ipw2100_priv *priv,\n\t\t\t\t    struct ipw2100_rx_packet *packet)\n{\n\tpacket->skb = dev_alloc_skb(sizeof(struct ipw2100_rx));\n\tif (!packet->skb)\n\t\treturn -ENOMEM;\n\n\tpacket->rxp = (struct ipw2100_rx *)packet->skb->data;\n\tpacket->dma_addr = dma_map_single(&priv->pci_dev->dev,\n\t\t\t\t\t  packet->skb->data,\n\t\t\t\t\t  sizeof(struct ipw2100_rx),\n\t\t\t\t\t  DMA_FROM_DEVICE);\n\tif (dma_mapping_error(&priv->pci_dev->dev, packet->dma_addr)) {\n\t\tdev_kfree_skb(packet->skb);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n#define SEARCH_ERROR   0xffffffff\n#define SEARCH_FAIL    0xfffffffe\n#define SEARCH_SUCCESS 0xfffffff0\n#define SEARCH_DISCARD 0\n#define SEARCH_SNAPSHOT 1\n\n#define SNAPSHOT_ADDR(ofs) (priv->snapshot[((ofs) >> 12) & 0xff] + ((ofs) & 0xfff))\nstatic void ipw2100_snapshot_free(struct ipw2100_priv *priv)\n{\n\tint i;\n\tif (!priv->snapshot[0])\n\t\treturn;\n\tfor (i = 0; i < 0x30; i++)\n\t\tkfree(priv->snapshot[i]);\n\tpriv->snapshot[0] = NULL;\n}\n\n#ifdef IPW2100_DEBUG_C3\nstatic int ipw2100_snapshot_alloc(struct ipw2100_priv *priv)\n{\n\tint i;\n\tif (priv->snapshot[0])\n\t\treturn 1;\n\tfor (i = 0; i < 0x30; i++) {\n\t\tpriv->snapshot[i] = kmalloc(0x1000, GFP_ATOMIC);\n\t\tif (!priv->snapshot[i]) {\n\t\t\tIPW_DEBUG_INFO(\"%s: Error allocating snapshot \"\n\t\t\t\t       \"buffer %d\\n\", priv->net_dev->name, i);\n\t\t\twhile (i > 0)\n\t\t\t\tkfree(priv->snapshot[--i]);\n\t\t\tpriv->snapshot[0] = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic u32 ipw2100_match_buf(struct ipw2100_priv *priv, u8 * in_buf,\n\t\t\t\t    size_t len, int mode)\n{\n\tu32 i, j;\n\tu32 tmp;\n\tu8 *s, *d;\n\tu32 ret;\n\n\ts = in_buf;\n\tif (mode == SEARCH_SNAPSHOT) {\n\t\tif (!ipw2100_snapshot_alloc(priv))\n\t\t\tmode = SEARCH_DISCARD;\n\t}\n\n\tfor (ret = SEARCH_FAIL, i = 0; i < 0x30000; i += 4) {\n\t\tread_nic_dword(priv->net_dev, i, &tmp);\n\t\tif (mode == SEARCH_SNAPSHOT)\n\t\t\t*(u32 *) SNAPSHOT_ADDR(i) = tmp;\n\t\tif (ret == SEARCH_FAIL) {\n\t\t\td = (u8 *) & tmp;\n\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\tif (*s != *d) {\n\t\t\t\t\ts = in_buf;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ts++;\n\t\t\t\td++;\n\n\t\t\t\tif ((s - in_buf) == len)\n\t\t\t\t\tret = (i + j) - len + 1;\n\t\t\t}\n\t\t} else if (mode == SEARCH_DISCARD)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n#endif\n\n \n#ifdef IPW2100_RX_DEBUG\nstatic u8 packet_data[IPW_RX_NIC_BUFFER_LENGTH];\n#endif\n\nstatic void ipw2100_corruption_detected(struct ipw2100_priv *priv, int i)\n{\n#ifdef IPW2100_DEBUG_C3\n\tstruct ipw2100_status *status = &priv->status_queue.drv[i];\n\tu32 match, reg;\n\tint j;\n#endif\n\n\tIPW_DEBUG_INFO(\": PCI latency error detected at 0x%04zX.\\n\",\n\t\t       i * sizeof(struct ipw2100_status));\n\n#ifdef IPW2100_DEBUG_C3\n\t \n\twrite_register(priv->net_dev, IPW_REG_RESET_REG,\n\t\t       IPW_AUX_HOST_RESET_REG_STOP_MASTER);\n\tj = 5;\n\tdo {\n\t\tudelay(IPW_WAIT_RESET_MASTER_ASSERT_COMPLETE_DELAY);\n\t\tread_register(priv->net_dev, IPW_REG_RESET_REG, &reg);\n\n\t\tif (reg & IPW_AUX_HOST_RESET_REG_MASTER_DISABLED)\n\t\t\tbreak;\n\t} while (j--);\n\n\tmatch = ipw2100_match_buf(priv, (u8 *) status,\n\t\t\t\t  sizeof(struct ipw2100_status),\n\t\t\t\t  SEARCH_SNAPSHOT);\n\tif (match < SEARCH_SUCCESS)\n\t\tIPW_DEBUG_INFO(\"%s: DMA status match in Firmware at \"\n\t\t\t       \"offset 0x%06X, length %d:\\n\",\n\t\t\t       priv->net_dev->name, match,\n\t\t\t       sizeof(struct ipw2100_status));\n\telse\n\t\tIPW_DEBUG_INFO(\"%s: No DMA status match in \"\n\t\t\t       \"Firmware.\\n\", priv->net_dev->name);\n\n\tprintk_buf((u8 *) priv->status_queue.drv,\n\t\t   sizeof(struct ipw2100_status) * RX_QUEUE_LENGTH);\n#endif\n\n\tpriv->fatal_error = IPW2100_ERR_C3_CORRUPTION;\n\tpriv->net_dev->stats.rx_errors++;\n\tschedule_reset(priv);\n}\n\nstatic void isr_rx(struct ipw2100_priv *priv, int i,\n\t\t\t  struct libipw_rx_stats *stats)\n{\n\tstruct net_device *dev = priv->net_dev;\n\tstruct ipw2100_status *status = &priv->status_queue.drv[i];\n\tstruct ipw2100_rx_packet *packet = &priv->rx_buffers[i];\n\n\tIPW_DEBUG_RX(\"Handler...\\n\");\n\n\tif (unlikely(status->frame_size > skb_tailroom(packet->skb))) {\n\t\tIPW_DEBUG_INFO(\"%s: frame_size (%u) > skb_tailroom (%u)!\"\n\t\t\t       \"  Dropping.\\n\",\n\t\t\t       dev->name,\n\t\t\t       status->frame_size, skb_tailroom(packet->skb));\n\t\tdev->stats.rx_errors++;\n\t\treturn;\n\t}\n\n\tif (unlikely(!netif_running(dev))) {\n\t\tdev->stats.rx_errors++;\n\t\tpriv->wstats.discard.misc++;\n\t\tIPW_DEBUG_DROP(\"Dropping packet while interface is not up.\\n\");\n\t\treturn;\n\t}\n\n\tif (unlikely(priv->ieee->iw_mode != IW_MODE_MONITOR &&\n\t\t     !(priv->status & STATUS_ASSOCIATED))) {\n\t\tIPW_DEBUG_DROP(\"Dropping packet while not associated.\\n\");\n\t\tpriv->wstats.discard.misc++;\n\t\treturn;\n\t}\n\n\tdma_unmap_single(&priv->pci_dev->dev, packet->dma_addr,\n\t\t\t sizeof(struct ipw2100_rx), DMA_FROM_DEVICE);\n\n\tskb_put(packet->skb, status->frame_size);\n\n#ifdef IPW2100_RX_DEBUG\n\t \n\tskb_copy_from_linear_data(packet->skb, packet_data,\n\t\t\t\t  min_t(u32, status->frame_size,\n\t\t\t\t\t     IPW_RX_NIC_BUFFER_LENGTH));\n#endif\n\n\tif (!libipw_rx(priv->ieee, packet->skb, stats)) {\n#ifdef IPW2100_RX_DEBUG\n\t\tIPW_DEBUG_DROP(\"%s: Non consumed packet:\\n\",\n\t\t\t       dev->name);\n\t\tprintk_buf(IPW_DL_DROP, packet_data, status->frame_size);\n#endif\n\t\tdev->stats.rx_errors++;\n\n\t\t \n\t\tdev_kfree_skb_any(packet->skb);\n\t\tpacket->skb = NULL;\n\t}\n\n\t \n\tif (unlikely(ipw2100_alloc_skb(priv, packet))) {\n\t\tprintk(KERN_WARNING DRV_NAME \": \"\n\t\t       \"%s: Unable to allocate SKB onto RBD ring - disabling \"\n\t\t       \"adapter.\\n\", dev->name);\n\t\t \n\t\tIPW_DEBUG_INFO(\"TODO: Shutdown adapter...\\n\");\n\t}\n\n\t \n\tpriv->rx_queue.drv[i].host_addr = packet->dma_addr;\n}\n\n#ifdef CONFIG_IPW2100_MONITOR\n\nstatic void isr_rx_monitor(struct ipw2100_priv *priv, int i,\n\t\t   struct libipw_rx_stats *stats)\n{\n\tstruct net_device *dev = priv->net_dev;\n\tstruct ipw2100_status *status = &priv->status_queue.drv[i];\n\tstruct ipw2100_rx_packet *packet = &priv->rx_buffers[i];\n\n\t \n\tstruct ipw_rt_hdr {\n\t\tstruct ieee80211_radiotap_header rt_hdr;\n\t\ts8 rt_dbmsignal;  \n\t} *ipw_rt;\n\n\tIPW_DEBUG_RX(\"Handler...\\n\");\n\n\tif (unlikely(status->frame_size > skb_tailroom(packet->skb) -\n\t\t\t\tsizeof(struct ipw_rt_hdr))) {\n\t\tIPW_DEBUG_INFO(\"%s: frame_size (%u) > skb_tailroom (%u)!\"\n\t\t\t       \"  Dropping.\\n\",\n\t\t\t       dev->name,\n\t\t\t       status->frame_size,\n\t\t\t       skb_tailroom(packet->skb));\n\t\tdev->stats.rx_errors++;\n\t\treturn;\n\t}\n\n\tif (unlikely(!netif_running(dev))) {\n\t\tdev->stats.rx_errors++;\n\t\tpriv->wstats.discard.misc++;\n\t\tIPW_DEBUG_DROP(\"Dropping packet while interface is not up.\\n\");\n\t\treturn;\n\t}\n\n\tif (unlikely(priv->config & CFG_CRC_CHECK &&\n\t\t     status->flags & IPW_STATUS_FLAG_CRC_ERROR)) {\n\t\tIPW_DEBUG_RX(\"CRC error in packet.  Dropping.\\n\");\n\t\tdev->stats.rx_errors++;\n\t\treturn;\n\t}\n\n\tdma_unmap_single(&priv->pci_dev->dev, packet->dma_addr,\n\t\t\t sizeof(struct ipw2100_rx), DMA_FROM_DEVICE);\n\tmemmove(packet->skb->data + sizeof(struct ipw_rt_hdr),\n\t\tpacket->skb->data, status->frame_size);\n\n\tipw_rt = (struct ipw_rt_hdr *) packet->skb->data;\n\n\tipw_rt->rt_hdr.it_version = PKTHDR_RADIOTAP_VERSION;\n\tipw_rt->rt_hdr.it_pad = 0;  \n\tipw_rt->rt_hdr.it_len = cpu_to_le16(sizeof(struct ipw_rt_hdr));  \n\n\tipw_rt->rt_hdr.it_present = cpu_to_le32(1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL);\n\n\tipw_rt->rt_dbmsignal = status->rssi + IPW2100_RSSI_TO_DBM;\n\n\tskb_put(packet->skb, status->frame_size + sizeof(struct ipw_rt_hdr));\n\n\tif (!libipw_rx(priv->ieee, packet->skb, stats)) {\n\t\tdev->stats.rx_errors++;\n\n\t\t \n\t\tdev_kfree_skb_any(packet->skb);\n\t\tpacket->skb = NULL;\n\t}\n\n\t \n\tif (unlikely(ipw2100_alloc_skb(priv, packet))) {\n\t\tIPW_DEBUG_WARNING(\n\t\t\t\"%s: Unable to allocate SKB onto RBD ring - disabling \"\n\t\t\t\"adapter.\\n\", dev->name);\n\t\t \n\t\tIPW_DEBUG_INFO(\"TODO: Shutdown adapter...\\n\");\n\t}\n\n\t \n\tpriv->rx_queue.drv[i].host_addr = packet->dma_addr;\n}\n\n#endif\n\nstatic int ipw2100_corruption_check(struct ipw2100_priv *priv, int i)\n{\n\tstruct ipw2100_status *status = &priv->status_queue.drv[i];\n\tstruct ipw2100_rx *u = priv->rx_buffers[i].rxp;\n\tu16 frame_type = status->status_fields & STATUS_TYPE_MASK;\n\n\tswitch (frame_type) {\n\tcase COMMAND_STATUS_VAL:\n\t\treturn (status->frame_size != sizeof(u->rx_data.command));\n\tcase STATUS_CHANGE_VAL:\n\t\treturn (status->frame_size != sizeof(u->rx_data.status));\n\tcase HOST_NOTIFICATION_VAL:\n\t\treturn (status->frame_size < sizeof(u->rx_data.notification));\n\tcase P80211_DATA_VAL:\n\tcase P8023_DATA_VAL:\n#ifdef CONFIG_IPW2100_MONITOR\n\t\treturn 0;\n#else\n\t\tswitch (WLAN_FC_GET_TYPE(le16_to_cpu(u->rx_data.header.frame_ctl))) {\n\t\tcase IEEE80211_FTYPE_MGMT:\n\t\tcase IEEE80211_FTYPE_CTL:\n\t\t\treturn 0;\n\t\tcase IEEE80211_FTYPE_DATA:\n\t\t\treturn (status->frame_size >\n\t\t\t\tIPW_MAX_802_11_PAYLOAD_LENGTH);\n\t\t}\n#endif\n\t}\n\n\treturn 1;\n}\n\n \nstatic void __ipw2100_rx_process(struct ipw2100_priv *priv)\n{\n\tstruct ipw2100_bd_queue *rxq = &priv->rx_queue;\n\tstruct ipw2100_status_queue *sq = &priv->status_queue;\n\tstruct ipw2100_rx_packet *packet;\n\tu16 frame_type;\n\tu32 r, w, i, s;\n\tstruct ipw2100_rx *u;\n\tstruct libipw_rx_stats stats = {\n\t\t.mac_time = jiffies,\n\t};\n\n\tread_register(priv->net_dev, IPW_MEM_HOST_SHARED_RX_READ_INDEX, &r);\n\tread_register(priv->net_dev, IPW_MEM_HOST_SHARED_RX_WRITE_INDEX, &w);\n\n\tif (r >= rxq->entries) {\n\t\tIPW_DEBUG_RX(\"exit - bad read index\\n\");\n\t\treturn;\n\t}\n\n\ti = (rxq->next + 1) % rxq->entries;\n\ts = i;\n\twhile (i != r) {\n\t\t \n\n\t\tpacket = &priv->rx_buffers[i];\n\n\t\t \n\t\tdma_sync_single_for_cpu(&priv->pci_dev->dev, packet->dma_addr,\n\t\t\t\t\tsizeof(struct ipw2100_rx),\n\t\t\t\t\tDMA_FROM_DEVICE);\n\n\t\tif (unlikely(ipw2100_corruption_check(priv, i))) {\n\t\t\tipw2100_corruption_detected(priv, i);\n\t\t\tgoto increment;\n\t\t}\n\n\t\tu = packet->rxp;\n\t\tframe_type = sq->drv[i].status_fields & STATUS_TYPE_MASK;\n\t\tstats.rssi = sq->drv[i].rssi + IPW2100_RSSI_TO_DBM;\n\t\tstats.len = sq->drv[i].frame_size;\n\n\t\tstats.mask = 0;\n\t\tif (stats.rssi != 0)\n\t\t\tstats.mask |= LIBIPW_STATMASK_RSSI;\n\t\tstats.freq = LIBIPW_24GHZ_BAND;\n\n\t\tIPW_DEBUG_RX(\"%s: '%s' frame type received (%d).\\n\",\n\t\t\t     priv->net_dev->name, frame_types[frame_type],\n\t\t\t     stats.len);\n\n\t\tswitch (frame_type) {\n\t\tcase COMMAND_STATUS_VAL:\n\t\t\t \n\t\t\tisr_rx_complete_command(priv, &u->rx_data.command);\n\t\t\tbreak;\n\n\t\tcase STATUS_CHANGE_VAL:\n\t\t\tisr_status_change(priv, u->rx_data.status);\n\t\t\tbreak;\n\n\t\tcase P80211_DATA_VAL:\n\t\tcase P8023_DATA_VAL:\n#ifdef CONFIG_IPW2100_MONITOR\n\t\t\tif (priv->ieee->iw_mode == IW_MODE_MONITOR) {\n\t\t\t\tisr_rx_monitor(priv, i, &stats);\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t\tif (stats.len < sizeof(struct libipw_hdr_3addr))\n\t\t\t\tbreak;\n\t\t\tswitch (WLAN_FC_GET_TYPE(le16_to_cpu(u->rx_data.header.frame_ctl))) {\n\t\t\tcase IEEE80211_FTYPE_MGMT:\n\t\t\t\tlibipw_rx_mgt(priv->ieee,\n\t\t\t\t\t\t &u->rx_data.header, &stats);\n\t\t\t\tbreak;\n\n\t\t\tcase IEEE80211_FTYPE_CTL:\n\t\t\t\tbreak;\n\n\t\t\tcase IEEE80211_FTYPE_DATA:\n\t\t\t\tisr_rx(priv, i, &stats);\n\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t      increment:\n\t\t \n\t\trxq->drv[i].status.info.field = 0;\n\n\t\ti = (i + 1) % rxq->entries;\n\t}\n\n\tif (i != s) {\n\t\t \n\t\trxq->next = (i ? i : rxq->entries) - 1;\n\n\t\twrite_register(priv->net_dev,\n\t\t\t       IPW_MEM_HOST_SHARED_RX_WRITE_INDEX, rxq->next);\n\t}\n}\n\n \nstatic int __ipw2100_tx_process(struct ipw2100_priv *priv)\n{\n\tstruct ipw2100_bd_queue *txq = &priv->tx_queue;\n\tstruct ipw2100_bd *tbd;\n\tstruct list_head *element;\n\tstruct ipw2100_tx_packet *packet;\n\tint descriptors_used;\n\tint e, i;\n\tu32 r, w, frag_num = 0;\n\n\tif (list_empty(&priv->fw_pend_list))\n\t\treturn 0;\n\n\telement = priv->fw_pend_list.next;\n\n\tpacket = list_entry(element, struct ipw2100_tx_packet, list);\n\ttbd = &txq->drv[packet->index];\n\n\t \n\tswitch (packet->type) {\n\tcase COMMAND:\n\t\t \n\t\tdescriptors_used = 1;\n\t\te = txq->oldest;\n\t\tbreak;\n\n\tcase DATA:\n\t\t \n\t\tdescriptors_used = tbd->num_fragments;\n\t\tfrag_num = tbd->num_fragments - 1;\n\t\te = txq->oldest + frag_num;\n\t\te %= txq->entries;\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_WARNING DRV_NAME \": %s: Bad fw_pend_list entry!\\n\",\n\t\t       priv->net_dev->name);\n\t\treturn 0;\n\t}\n\n\t \n\tread_register(priv->net_dev, IPW_MEM_HOST_SHARED_TX_QUEUE_READ_INDEX,\n\t\t      &r);\n\tread_register(priv->net_dev, IPW_MEM_HOST_SHARED_TX_QUEUE_WRITE_INDEX,\n\t\t      &w);\n\tif (w != txq->next)\n\t\tprintk(KERN_WARNING DRV_NAME \": %s: write index mismatch\\n\",\n\t\t       priv->net_dev->name);\n\n\t \n\n\t \n\tif (!((r <= w && (e < r || e >= w)) || (e < r && e >= w))) {\n\t\tIPW_DEBUG_TX(\"exit - no processed packets ready to release.\\n\");\n\t\treturn 0;\n\t}\n\n\tlist_del(element);\n\tDEC_STAT(&priv->fw_pend_stat);\n\n#ifdef CONFIG_IPW2100_DEBUG\n\t{\n\t\ti = txq->oldest;\n\t\tIPW_DEBUG_TX(\"TX%d V=%p P=%04X T=%04X L=%d\\n\", i,\n\t\t\t     &txq->drv[i],\n\t\t\t     (u32) (txq->nic + i * sizeof(struct ipw2100_bd)),\n\t\t\t     txq->drv[i].host_addr, txq->drv[i].buf_length);\n\n\t\tif (packet->type == DATA) {\n\t\t\ti = (i + 1) % txq->entries;\n\n\t\t\tIPW_DEBUG_TX(\"TX%d V=%p P=%04X T=%04X L=%d\\n\", i,\n\t\t\t\t     &txq->drv[i],\n\t\t\t\t     (u32) (txq->nic + i *\n\t\t\t\t\t    sizeof(struct ipw2100_bd)),\n\t\t\t\t     (u32) txq->drv[i].host_addr,\n\t\t\t\t     txq->drv[i].buf_length);\n\t\t}\n\t}\n#endif\n\n\tswitch (packet->type) {\n\tcase DATA:\n\t\tif (txq->drv[txq->oldest].status.info.fields.txType != 0)\n\t\t\tprintk(KERN_WARNING DRV_NAME \": %s: Queue mismatch.  \"\n\t\t\t       \"Expecting DATA TBD but pulled \"\n\t\t\t       \"something else: ids %d=%d.\\n\",\n\t\t\t       priv->net_dev->name, txq->oldest, packet->index);\n\n\t\t \n\t\tfor (i = 0; i < frag_num; i++) {\n\t\t\ttbd = &txq->drv[(packet->index + 1 + i) % txq->entries];\n\n\t\t\tIPW_DEBUG_TX(\"TX%d P=%08x L=%d\\n\",\n\t\t\t\t     (packet->index + 1 + i) % txq->entries,\n\t\t\t\t     tbd->host_addr, tbd->buf_length);\n\n\t\t\tdma_unmap_single(&priv->pci_dev->dev, tbd->host_addr,\n\t\t\t\t\t tbd->buf_length, DMA_TO_DEVICE);\n\t\t}\n\n\t\tlibipw_txb_free(packet->info.d_struct.txb);\n\t\tpacket->info.d_struct.txb = NULL;\n\n\t\tlist_add_tail(element, &priv->tx_free_list);\n\t\tINC_STAT(&priv->tx_free_stat);\n\n\t\t \n\t\tif (priv->status & STATUS_ASSOCIATED)\n\t\t\tnetif_wake_queue(priv->net_dev);\n\n\t\t \n\t\tnetif_trans_update(priv->net_dev);\n\n\t\tbreak;\n\n\tcase COMMAND:\n\t\tif (txq->drv[txq->oldest].status.info.fields.txType != 1)\n\t\t\tprintk(KERN_WARNING DRV_NAME \": %s: Queue mismatch.  \"\n\t\t\t       \"Expecting COMMAND TBD but pulled \"\n\t\t\t       \"something else: ids %d=%d.\\n\",\n\t\t\t       priv->net_dev->name, txq->oldest, packet->index);\n\n#ifdef CONFIG_IPW2100_DEBUG\n\t\tif (packet->info.c_struct.cmd->host_command_reg <\n\t\t    ARRAY_SIZE(command_types))\n\t\t\tIPW_DEBUG_TX(\"Command '%s (%d)' processed: %d.\\n\",\n\t\t\t\t     command_types[packet->info.c_struct.cmd->\n\t\t\t\t\t\t   host_command_reg],\n\t\t\t\t     packet->info.c_struct.cmd->\n\t\t\t\t     host_command_reg,\n\t\t\t\t     packet->info.c_struct.cmd->cmd_status_reg);\n#endif\n\n\t\tlist_add_tail(element, &priv->msg_free_list);\n\t\tINC_STAT(&priv->msg_free_stat);\n\t\tbreak;\n\t}\n\n\t \n\ttxq->oldest = (e + 1) % txq->entries;\n\t \n\ttxq->available += descriptors_used;\n\tSET_STAT(&priv->txq_stat, txq->available);\n\n\tIPW_DEBUG_TX(\"packet latency (send to process)  %ld jiffies\\n\",\n\t\t     jiffies - packet->jiffy_start);\n\n\treturn (!list_empty(&priv->fw_pend_list));\n}\n\nstatic inline void __ipw2100_tx_complete(struct ipw2100_priv *priv)\n{\n\tint i = 0;\n\n\twhile (__ipw2100_tx_process(priv) && i < 200)\n\t\ti++;\n\n\tif (i == 200) {\n\t\tprintk(KERN_WARNING DRV_NAME \": \"\n\t\t       \"%s: Driver is running slow (%d iters).\\n\",\n\t\t       priv->net_dev->name, i);\n\t}\n}\n\nstatic void ipw2100_tx_send_commands(struct ipw2100_priv *priv)\n{\n\tstruct list_head *element;\n\tstruct ipw2100_tx_packet *packet;\n\tstruct ipw2100_bd_queue *txq = &priv->tx_queue;\n\tstruct ipw2100_bd *tbd;\n\tint next = txq->next;\n\n\twhile (!list_empty(&priv->msg_pend_list)) {\n\t\t \n\t\tif (txq->available <= 3) {\n\t\t\tIPW_DEBUG_TX(\"no room in tx_queue\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\telement = priv->msg_pend_list.next;\n\t\tlist_del(element);\n\t\tDEC_STAT(&priv->msg_pend_stat);\n\n\t\tpacket = list_entry(element, struct ipw2100_tx_packet, list);\n\n\t\tIPW_DEBUG_TX(\"using TBD at virt=%p, phys=%04X\\n\",\n\t\t\t     &txq->drv[txq->next],\n\t\t\t     (u32) (txq->nic + txq->next *\n\t\t\t\t      sizeof(struct ipw2100_bd)));\n\n\t\tpacket->index = txq->next;\n\n\t\ttbd = &txq->drv[txq->next];\n\n\t\t \n\t\ttbd->host_addr = packet->info.c_struct.cmd_phys;\n\t\ttbd->buf_length = sizeof(struct ipw2100_cmd_header);\n\t\t \n\t\ttbd->num_fragments = 1;\n\t\ttbd->status.info.field =\n\t\t    IPW_BD_STATUS_TX_FRAME_COMMAND |\n\t\t    IPW_BD_STATUS_TX_INTERRUPT_ENABLE;\n\n\t\t \n\t\ttxq->next++;\n\t\ttxq->next %= txq->entries;\n\t\ttxq->available--;\n\t\tDEC_STAT(&priv->txq_stat);\n\n\t\tlist_add_tail(element, &priv->fw_pend_list);\n\t\tINC_STAT(&priv->fw_pend_stat);\n\t}\n\n\tif (txq->next != next) {\n\t\t \n\t\twmb();\n\t\twrite_register(priv->net_dev,\n\t\t\t       IPW_MEM_HOST_SHARED_TX_QUEUE_WRITE_INDEX,\n\t\t\t       txq->next);\n\t}\n}\n\n \nstatic void ipw2100_tx_send_data(struct ipw2100_priv *priv)\n{\n\tstruct list_head *element;\n\tstruct ipw2100_tx_packet *packet;\n\tstruct ipw2100_bd_queue *txq = &priv->tx_queue;\n\tstruct ipw2100_bd *tbd;\n\tint next = txq->next;\n\tint i = 0;\n\tstruct ipw2100_data_header *ipw_hdr;\n\tstruct libipw_hdr_3addr *hdr;\n\n\twhile (!list_empty(&priv->tx_pend_list)) {\n\t\t \n\t\telement = priv->tx_pend_list.next;\n\t\tpacket = list_entry(element, struct ipw2100_tx_packet, list);\n\n\t\tif (unlikely(1 + packet->info.d_struct.txb->nr_frags >\n\t\t\t     IPW_MAX_BDS)) {\n\t\t\t \n\t\t\tIPW_DEBUG_INFO(\"%s: Maximum BD threshold exceeded.  \"\n\t\t\t\t       \"Increase fragmentation level.\\n\",\n\t\t\t\t       priv->net_dev->name);\n\t\t}\n\n\t\tif (txq->available <= 3 + packet->info.d_struct.txb->nr_frags) {\n\t\t\tIPW_DEBUG_TX(\"no room in tx_queue\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_del(element);\n\t\tDEC_STAT(&priv->tx_pend_stat);\n\n\t\ttbd = &txq->drv[txq->next];\n\n\t\tpacket->index = txq->next;\n\n\t\tipw_hdr = packet->info.d_struct.data;\n\t\thdr = (struct libipw_hdr_3addr *)packet->info.d_struct.txb->\n\t\t    fragments[0]->data;\n\n\t\tif (priv->ieee->iw_mode == IW_MODE_INFRA) {\n\t\t\t \n\t\t\tmemcpy(ipw_hdr->src_addr, hdr->addr2, ETH_ALEN);\n\t\t\tmemcpy(ipw_hdr->dst_addr, hdr->addr3, ETH_ALEN);\n\t\t} else if (priv->ieee->iw_mode == IW_MODE_ADHOC) {\n\t\t\t \n\t\t\tmemcpy(ipw_hdr->src_addr, hdr->addr2, ETH_ALEN);\n\t\t\tmemcpy(ipw_hdr->dst_addr, hdr->addr1, ETH_ALEN);\n\t\t}\n\n\t\tipw_hdr->host_command_reg = SEND;\n\t\tipw_hdr->host_command_reg1 = 0;\n\n\t\t \n\t\tipw_hdr->needs_encryption = 0;\n\t\tipw_hdr->encrypted = packet->info.d_struct.txb->encrypted;\n\t\tif (packet->info.d_struct.txb->nr_frags > 1)\n\t\t\tipw_hdr->fragment_size =\n\t\t\t    packet->info.d_struct.txb->frag_size -\n\t\t\t    LIBIPW_3ADDR_LEN;\n\t\telse\n\t\t\tipw_hdr->fragment_size = 0;\n\n\t\ttbd->host_addr = packet->info.d_struct.data_phys;\n\t\ttbd->buf_length = sizeof(struct ipw2100_data_header);\n\t\ttbd->num_fragments = 1 + packet->info.d_struct.txb->nr_frags;\n\t\ttbd->status.info.field =\n\t\t    IPW_BD_STATUS_TX_FRAME_802_3 |\n\t\t    IPW_BD_STATUS_TX_FRAME_NOT_LAST_FRAGMENT;\n\t\ttxq->next++;\n\t\ttxq->next %= txq->entries;\n\n\t\tIPW_DEBUG_TX(\"data header tbd TX%d P=%08x L=%d\\n\",\n\t\t\t     packet->index, tbd->host_addr, tbd->buf_length);\n#ifdef CONFIG_IPW2100_DEBUG\n\t\tif (packet->info.d_struct.txb->nr_frags > 1)\n\t\t\tIPW_DEBUG_FRAG(\"fragment Tx: %d frames\\n\",\n\t\t\t\t       packet->info.d_struct.txb->nr_frags);\n#endif\n\n\t\tfor (i = 0; i < packet->info.d_struct.txb->nr_frags; i++) {\n\t\t\ttbd = &txq->drv[txq->next];\n\t\t\tif (i == packet->info.d_struct.txb->nr_frags - 1)\n\t\t\t\ttbd->status.info.field =\n\t\t\t\t    IPW_BD_STATUS_TX_FRAME_802_3 |\n\t\t\t\t    IPW_BD_STATUS_TX_INTERRUPT_ENABLE;\n\t\t\telse\n\t\t\t\ttbd->status.info.field =\n\t\t\t\t    IPW_BD_STATUS_TX_FRAME_802_3 |\n\t\t\t\t    IPW_BD_STATUS_TX_FRAME_NOT_LAST_FRAGMENT;\n\n\t\t\ttbd->buf_length = packet->info.d_struct.txb->\n\t\t\t    fragments[i]->len - LIBIPW_3ADDR_LEN;\n\n\t\t\ttbd->host_addr = dma_map_single(&priv->pci_dev->dev,\n\t\t\t\t\t\t\tpacket->info.d_struct.\n\t\t\t\t\t\t\ttxb->fragments[i]->data +\n\t\t\t\t\t\t\tLIBIPW_3ADDR_LEN,\n\t\t\t\t\t\t\ttbd->buf_length,\n\t\t\t\t\t\t\tDMA_TO_DEVICE);\n\t\t\tif (dma_mapping_error(&priv->pci_dev->dev, tbd->host_addr)) {\n\t\t\t\tIPW_DEBUG_TX(\"dma mapping error\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tIPW_DEBUG_TX(\"data frag tbd TX%d P=%08x L=%d\\n\",\n\t\t\t\t     txq->next, tbd->host_addr,\n\t\t\t\t     tbd->buf_length);\n\n\t\t\tdma_sync_single_for_device(&priv->pci_dev->dev,\n\t\t\t\t\t\t   tbd->host_addr,\n\t\t\t\t\t\t   tbd->buf_length,\n\t\t\t\t\t\t   DMA_TO_DEVICE);\n\n\t\t\ttxq->next++;\n\t\t\ttxq->next %= txq->entries;\n\t\t}\n\n\t\ttxq->available -= 1 + packet->info.d_struct.txb->nr_frags;\n\t\tSET_STAT(&priv->txq_stat, txq->available);\n\n\t\tlist_add_tail(element, &priv->fw_pend_list);\n\t\tINC_STAT(&priv->fw_pend_stat);\n\t}\n\n\tif (txq->next != next) {\n\t\t \n\t\twrite_register(priv->net_dev,\n\t\t\t       IPW_MEM_HOST_SHARED_TX_QUEUE_WRITE_INDEX,\n\t\t\t       txq->next);\n\t}\n}\n\nstatic void ipw2100_irq_tasklet(struct tasklet_struct *t)\n{\n\tstruct ipw2100_priv *priv = from_tasklet(priv, t, irq_tasklet);\n\tstruct net_device *dev = priv->net_dev;\n\tunsigned long flags;\n\tu32 inta, tmp;\n\n\tspin_lock_irqsave(&priv->low_lock, flags);\n\tipw2100_disable_interrupts(priv);\n\n\tread_register(dev, IPW_REG_INTA, &inta);\n\n\tIPW_DEBUG_ISR(\"enter - INTA: 0x%08lX\\n\",\n\t\t      (unsigned long)inta & IPW_INTERRUPT_MASK);\n\n\tpriv->in_isr++;\n\tpriv->interrupts++;\n\n\t \n\tIPW_DEBUG_ISR(\"INTA: 0x%08lX\\n\",\n\t\t      (unsigned long)inta & IPW_INTERRUPT_MASK);\n\n\tif (inta & IPW2100_INTA_FATAL_ERROR) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \": Fatal interrupt. Scheduling firmware restart.\\n\");\n\t\tpriv->inta_other++;\n\t\twrite_register(dev, IPW_REG_INTA, IPW2100_INTA_FATAL_ERROR);\n\n\t\tread_nic_dword(dev, IPW_NIC_FATAL_ERROR, &priv->fatal_error);\n\t\tIPW_DEBUG_INFO(\"%s: Fatal error value: 0x%08X\\n\",\n\t\t\t       priv->net_dev->name, priv->fatal_error);\n\n\t\tread_nic_dword(dev, IPW_ERROR_ADDR(priv->fatal_error), &tmp);\n\t\tIPW_DEBUG_INFO(\"%s: Fatal error address value: 0x%08X\\n\",\n\t\t\t       priv->net_dev->name, tmp);\n\n\t\t \n\t\tschedule_reset(priv);\n\t}\n\n\tif (inta & IPW2100_INTA_PARITY_ERROR) {\n\t\tprintk(KERN_ERR DRV_NAME\n\t\t       \": ***** PARITY ERROR INTERRUPT !!!!\\n\");\n\t\tpriv->inta_other++;\n\t\twrite_register(dev, IPW_REG_INTA, IPW2100_INTA_PARITY_ERROR);\n\t}\n\n\tif (inta & IPW2100_INTA_RX_TRANSFER) {\n\t\tIPW_DEBUG_ISR(\"RX interrupt\\n\");\n\n\t\tpriv->rx_interrupts++;\n\n\t\twrite_register(dev, IPW_REG_INTA, IPW2100_INTA_RX_TRANSFER);\n\n\t\t__ipw2100_rx_process(priv);\n\t\t__ipw2100_tx_complete(priv);\n\t}\n\n\tif (inta & IPW2100_INTA_TX_TRANSFER) {\n\t\tIPW_DEBUG_ISR(\"TX interrupt\\n\");\n\n\t\tpriv->tx_interrupts++;\n\n\t\twrite_register(dev, IPW_REG_INTA, IPW2100_INTA_TX_TRANSFER);\n\n\t\t__ipw2100_tx_complete(priv);\n\t\tipw2100_tx_send_commands(priv);\n\t\tipw2100_tx_send_data(priv);\n\t}\n\n\tif (inta & IPW2100_INTA_TX_COMPLETE) {\n\t\tIPW_DEBUG_ISR(\"TX complete\\n\");\n\t\tpriv->inta_other++;\n\t\twrite_register(dev, IPW_REG_INTA, IPW2100_INTA_TX_COMPLETE);\n\n\t\t__ipw2100_tx_complete(priv);\n\t}\n\n\tif (inta & IPW2100_INTA_EVENT_INTERRUPT) {\n\t\t \n\t\tpriv->inta_other++;\n\t\twrite_register(dev, IPW_REG_INTA, IPW2100_INTA_EVENT_INTERRUPT);\n\t}\n\n\tif (inta & IPW2100_INTA_FW_INIT_DONE) {\n\t\tIPW_DEBUG_ISR(\"FW init done interrupt\\n\");\n\t\tpriv->inta_other++;\n\n\t\tread_register(dev, IPW_REG_INTA, &tmp);\n\t\tif (tmp & (IPW2100_INTA_FATAL_ERROR |\n\t\t\t   IPW2100_INTA_PARITY_ERROR)) {\n\t\t\twrite_register(dev, IPW_REG_INTA,\n\t\t\t\t       IPW2100_INTA_FATAL_ERROR |\n\t\t\t\t       IPW2100_INTA_PARITY_ERROR);\n\t\t}\n\n\t\twrite_register(dev, IPW_REG_INTA, IPW2100_INTA_FW_INIT_DONE);\n\t}\n\n\tif (inta & IPW2100_INTA_STATUS_CHANGE) {\n\t\tIPW_DEBUG_ISR(\"Status change interrupt\\n\");\n\t\tpriv->inta_other++;\n\t\twrite_register(dev, IPW_REG_INTA, IPW2100_INTA_STATUS_CHANGE);\n\t}\n\n\tif (inta & IPW2100_INTA_SLAVE_MODE_HOST_COMMAND_DONE) {\n\t\tIPW_DEBUG_ISR(\"slave host mode interrupt\\n\");\n\t\tpriv->inta_other++;\n\t\twrite_register(dev, IPW_REG_INTA,\n\t\t\t       IPW2100_INTA_SLAVE_MODE_HOST_COMMAND_DONE);\n\t}\n\n\tpriv->in_isr--;\n\tipw2100_enable_interrupts(priv);\n\n\tspin_unlock_irqrestore(&priv->low_lock, flags);\n\n\tIPW_DEBUG_ISR(\"exit\\n\");\n}\n\nstatic irqreturn_t ipw2100_interrupt(int irq, void *data)\n{\n\tstruct ipw2100_priv *priv = data;\n\tu32 inta, inta_mask;\n\n\tif (!data)\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&priv->low_lock);\n\n\t \n\tif (!(priv->status & STATUS_INT_ENABLED)) {\n\t\t \n\t\tgoto none;\n\t}\n\n\tread_register(priv->net_dev, IPW_REG_INTA_MASK, &inta_mask);\n\tread_register(priv->net_dev, IPW_REG_INTA, &inta);\n\n\tif (inta == 0xFFFFFFFF) {\n\t\t \n\t\tprintk(KERN_WARNING DRV_NAME \": IRQ INTA == 0xFFFFFFFF\\n\");\n\t\tgoto none;\n\t}\n\n\tinta &= IPW_INTERRUPT_MASK;\n\n\tif (!(inta & inta_mask)) {\n\t\t \n\t\tgoto none;\n\t}\n\n\t \n\tipw2100_disable_interrupts(priv);\n\n\ttasklet_schedule(&priv->irq_tasklet);\n\tspin_unlock(&priv->low_lock);\n\n\treturn IRQ_HANDLED;\n      none:\n\tspin_unlock(&priv->low_lock);\n\treturn IRQ_NONE;\n}\n\nstatic netdev_tx_t ipw2100_tx(struct libipw_txb *txb,\n\t\t\t      struct net_device *dev, int pri)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tstruct list_head *element;\n\tstruct ipw2100_tx_packet *packet;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->low_lock, flags);\n\n\tif (!(priv->status & STATUS_ASSOCIATED)) {\n\t\tIPW_DEBUG_INFO(\"Can not transmit when not connected.\\n\");\n\t\tpriv->net_dev->stats.tx_carrier_errors++;\n\t\tnetif_stop_queue(dev);\n\t\tgoto fail_unlock;\n\t}\n\n\tif (list_empty(&priv->tx_free_list))\n\t\tgoto fail_unlock;\n\n\telement = priv->tx_free_list.next;\n\tpacket = list_entry(element, struct ipw2100_tx_packet, list);\n\n\tpacket->info.d_struct.txb = txb;\n\n\tIPW_DEBUG_TX(\"Sending fragment (%d bytes):\\n\", txb->fragments[0]->len);\n\tprintk_buf(IPW_DL_TX, txb->fragments[0]->data, txb->fragments[0]->len);\n\n\tpacket->jiffy_start = jiffies;\n\n\tlist_del(element);\n\tDEC_STAT(&priv->tx_free_stat);\n\n\tlist_add_tail(element, &priv->tx_pend_list);\n\tINC_STAT(&priv->tx_pend_stat);\n\n\tipw2100_tx_send_data(priv);\n\n\tspin_unlock_irqrestore(&priv->low_lock, flags);\n\treturn NETDEV_TX_OK;\n\nfail_unlock:\n\tnetif_stop_queue(dev);\n\tspin_unlock_irqrestore(&priv->low_lock, flags);\n\treturn NETDEV_TX_BUSY;\n}\n\nstatic int ipw2100_msg_allocate(struct ipw2100_priv *priv)\n{\n\tint i, j, err = -EINVAL;\n\tvoid *v;\n\tdma_addr_t p;\n\n\tpriv->msg_buffers =\n\t    kmalloc_array(IPW_COMMAND_POOL_SIZE,\n\t\t\t  sizeof(struct ipw2100_tx_packet),\n\t\t\t  GFP_KERNEL);\n\tif (!priv->msg_buffers)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < IPW_COMMAND_POOL_SIZE; i++) {\n\t\tv = dma_alloc_coherent(&priv->pci_dev->dev,\n\t\t\t\t       sizeof(struct ipw2100_cmd_header), &p,\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!v) {\n\t\t\tprintk(KERN_ERR DRV_NAME \": \"\n\t\t\t       \"%s: PCI alloc failed for msg \"\n\t\t\t       \"buffers.\\n\", priv->net_dev->name);\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tpriv->msg_buffers[i].type = COMMAND;\n\t\tpriv->msg_buffers[i].info.c_struct.cmd =\n\t\t    (struct ipw2100_cmd_header *)v;\n\t\tpriv->msg_buffers[i].info.c_struct.cmd_phys = p;\n\t}\n\n\tif (i == IPW_COMMAND_POOL_SIZE)\n\t\treturn 0;\n\n\tfor (j = 0; j < i; j++) {\n\t\tdma_free_coherent(&priv->pci_dev->dev,\n\t\t\t\t  sizeof(struct ipw2100_cmd_header),\n\t\t\t\t  priv->msg_buffers[j].info.c_struct.cmd,\n\t\t\t\t  priv->msg_buffers[j].info.c_struct.cmd_phys);\n\t}\n\n\tkfree(priv->msg_buffers);\n\tpriv->msg_buffers = NULL;\n\n\treturn err;\n}\n\nstatic int ipw2100_msg_initialize(struct ipw2100_priv *priv)\n{\n\tint i;\n\n\tINIT_LIST_HEAD(&priv->msg_free_list);\n\tINIT_LIST_HEAD(&priv->msg_pend_list);\n\n\tfor (i = 0; i < IPW_COMMAND_POOL_SIZE; i++)\n\t\tlist_add_tail(&priv->msg_buffers[i].list, &priv->msg_free_list);\n\tSET_STAT(&priv->msg_free_stat, i);\n\n\treturn 0;\n}\n\nstatic void ipw2100_msg_free(struct ipw2100_priv *priv)\n{\n\tint i;\n\n\tif (!priv->msg_buffers)\n\t\treturn;\n\n\tfor (i = 0; i < IPW_COMMAND_POOL_SIZE; i++) {\n\t\tdma_free_coherent(&priv->pci_dev->dev,\n\t\t\t\t  sizeof(struct ipw2100_cmd_header),\n\t\t\t\t  priv->msg_buffers[i].info.c_struct.cmd,\n\t\t\t\t  priv->msg_buffers[i].info.c_struct.cmd_phys);\n\t}\n\n\tkfree(priv->msg_buffers);\n\tpriv->msg_buffers = NULL;\n}\n\nstatic ssize_t pci_show(struct device *d, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(d);\n\tchar *out = buf;\n\tint i, j;\n\tu32 val;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tout += sprintf(out, \"[%08X] \", i * 16);\n\t\tfor (j = 0; j < 16; j += 4) {\n\t\t\tpci_read_config_dword(pci_dev, i * 16 + j, &val);\n\t\t\tout += sprintf(out, \"%08X \", val);\n\t\t}\n\t\tout += sprintf(out, \"\\n\");\n\t}\n\n\treturn out - buf;\n}\n\nstatic DEVICE_ATTR_RO(pci);\n\nstatic ssize_t cfg_show(struct device *d, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct ipw2100_priv *p = dev_get_drvdata(d);\n\treturn sprintf(buf, \"0x%08x\\n\", (int)p->config);\n}\n\nstatic DEVICE_ATTR_RO(cfg);\n\nstatic ssize_t status_show(struct device *d, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct ipw2100_priv *p = dev_get_drvdata(d);\n\treturn sprintf(buf, \"0x%08x\\n\", (int)p->status);\n}\n\nstatic DEVICE_ATTR_RO(status);\n\nstatic ssize_t capability_show(struct device *d, struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tstruct ipw2100_priv *p = dev_get_drvdata(d);\n\treturn sprintf(buf, \"0x%08x\\n\", (int)p->capability);\n}\n\nstatic DEVICE_ATTR_RO(capability);\n\n#define IPW2100_REG(x) { IPW_ ##x, #x }\nstatic const struct {\n\tu32 addr;\n\tconst char *name;\n} hw_data[] = {\nIPW2100_REG(REG_GP_CNTRL),\n\t    IPW2100_REG(REG_GPIO),\n\t    IPW2100_REG(REG_INTA),\n\t    IPW2100_REG(REG_INTA_MASK), IPW2100_REG(REG_RESET_REG),};\n#define IPW2100_NIC(x, s) { x, #x, s }\nstatic const struct {\n\tu32 addr;\n\tconst char *name;\n\tsize_t size;\n} nic_data[] = {\nIPW2100_NIC(IPW2100_CONTROL_REG, 2),\n\t    IPW2100_NIC(0x210014, 1), IPW2100_NIC(0x210000, 1),};\n#define IPW2100_ORD(x, d) { IPW_ORD_ ##x, #x, d }\nstatic const struct {\n\tu8 index;\n\tconst char *name;\n\tconst char *desc;\n} ord_data[] = {\nIPW2100_ORD(STAT_TX_HOST_REQUESTS, \"requested Host Tx's (MSDU)\"),\n\t    IPW2100_ORD(STAT_TX_HOST_COMPLETE,\n\t\t\t\t\"successful Host Tx's (MSDU)\"),\n\t    IPW2100_ORD(STAT_TX_DIR_DATA,\n\t\t\t\t\"successful Directed Tx's (MSDU)\"),\n\t    IPW2100_ORD(STAT_TX_DIR_DATA1,\n\t\t\t\t\"successful Directed Tx's (MSDU) @ 1MB\"),\n\t    IPW2100_ORD(STAT_TX_DIR_DATA2,\n\t\t\t\t\"successful Directed Tx's (MSDU) @ 2MB\"),\n\t    IPW2100_ORD(STAT_TX_DIR_DATA5_5,\n\t\t\t\t\"successful Directed Tx's (MSDU) @ 5_5MB\"),\n\t    IPW2100_ORD(STAT_TX_DIR_DATA11,\n\t\t\t\t\"successful Directed Tx's (MSDU) @ 11MB\"),\n\t    IPW2100_ORD(STAT_TX_NODIR_DATA1,\n\t\t\t\t\"successful Non_Directed Tx's (MSDU) @ 1MB\"),\n\t    IPW2100_ORD(STAT_TX_NODIR_DATA2,\n\t\t\t\t\"successful Non_Directed Tx's (MSDU) @ 2MB\"),\n\t    IPW2100_ORD(STAT_TX_NODIR_DATA5_5,\n\t\t\t\t\"successful Non_Directed Tx's (MSDU) @ 5.5MB\"),\n\t    IPW2100_ORD(STAT_TX_NODIR_DATA11,\n\t\t\t\t\"successful Non_Directed Tx's (MSDU) @ 11MB\"),\n\t    IPW2100_ORD(STAT_NULL_DATA, \"successful NULL data Tx's\"),\n\t    IPW2100_ORD(STAT_TX_RTS, \"successful Tx RTS\"),\n\t    IPW2100_ORD(STAT_TX_CTS, \"successful Tx CTS\"),\n\t    IPW2100_ORD(STAT_TX_ACK, \"successful Tx ACK\"),\n\t    IPW2100_ORD(STAT_TX_ASSN, \"successful Association Tx's\"),\n\t    IPW2100_ORD(STAT_TX_ASSN_RESP,\n\t\t\t\t\"successful Association response Tx's\"),\n\t    IPW2100_ORD(STAT_TX_REASSN,\n\t\t\t\t\"successful Reassociation Tx's\"),\n\t    IPW2100_ORD(STAT_TX_REASSN_RESP,\n\t\t\t\t\"successful Reassociation response Tx's\"),\n\t    IPW2100_ORD(STAT_TX_PROBE,\n\t\t\t\t\"probes successfully transmitted\"),\n\t    IPW2100_ORD(STAT_TX_PROBE_RESP,\n\t\t\t\t\"probe responses successfully transmitted\"),\n\t    IPW2100_ORD(STAT_TX_BEACON, \"tx beacon\"),\n\t    IPW2100_ORD(STAT_TX_ATIM, \"Tx ATIM\"),\n\t    IPW2100_ORD(STAT_TX_DISASSN,\n\t\t\t\t\"successful Disassociation TX\"),\n\t    IPW2100_ORD(STAT_TX_AUTH, \"successful Authentication Tx\"),\n\t    IPW2100_ORD(STAT_TX_DEAUTH,\n\t\t\t\t\"successful Deauthentication TX\"),\n\t    IPW2100_ORD(STAT_TX_TOTAL_BYTES,\n\t\t\t\t\"Total successful Tx data bytes\"),\n\t    IPW2100_ORD(STAT_TX_RETRIES, \"Tx retries\"),\n\t    IPW2100_ORD(STAT_TX_RETRY1, \"Tx retries at 1MBPS\"),\n\t    IPW2100_ORD(STAT_TX_RETRY2, \"Tx retries at 2MBPS\"),\n\t    IPW2100_ORD(STAT_TX_RETRY5_5, \"Tx retries at 5.5MBPS\"),\n\t    IPW2100_ORD(STAT_TX_RETRY11, \"Tx retries at 11MBPS\"),\n\t    IPW2100_ORD(STAT_TX_FAILURES, \"Tx Failures\"),\n\t    IPW2100_ORD(STAT_TX_MAX_TRIES_IN_HOP,\n\t\t\t\t\"times max tries in a hop failed\"),\n\t    IPW2100_ORD(STAT_TX_DISASSN_FAIL,\n\t\t\t\t\"times disassociation failed\"),\n\t    IPW2100_ORD(STAT_TX_ERR_CTS, \"missed/bad CTS frames\"),\n\t    IPW2100_ORD(STAT_TX_ERR_ACK, \"tx err due to acks\"),\n\t    IPW2100_ORD(STAT_RX_HOST, \"packets passed to host\"),\n\t    IPW2100_ORD(STAT_RX_DIR_DATA, \"directed packets\"),\n\t    IPW2100_ORD(STAT_RX_DIR_DATA1, \"directed packets at 1MB\"),\n\t    IPW2100_ORD(STAT_RX_DIR_DATA2, \"directed packets at 2MB\"),\n\t    IPW2100_ORD(STAT_RX_DIR_DATA5_5,\n\t\t\t\t\"directed packets at 5.5MB\"),\n\t    IPW2100_ORD(STAT_RX_DIR_DATA11, \"directed packets at 11MB\"),\n\t    IPW2100_ORD(STAT_RX_NODIR_DATA, \"nondirected packets\"),\n\t    IPW2100_ORD(STAT_RX_NODIR_DATA1,\n\t\t\t\t\"nondirected packets at 1MB\"),\n\t    IPW2100_ORD(STAT_RX_NODIR_DATA2,\n\t\t\t\t\"nondirected packets at 2MB\"),\n\t    IPW2100_ORD(STAT_RX_NODIR_DATA5_5,\n\t\t\t\t\"nondirected packets at 5.5MB\"),\n\t    IPW2100_ORD(STAT_RX_NODIR_DATA11,\n\t\t\t\t\"nondirected packets at 11MB\"),\n\t    IPW2100_ORD(STAT_RX_NULL_DATA, \"null data rx's\"),\n\t    IPW2100_ORD(STAT_RX_RTS, \"Rx RTS\"), IPW2100_ORD(STAT_RX_CTS,\n\t\t\t\t\t\t\t\t    \"Rx CTS\"),\n\t    IPW2100_ORD(STAT_RX_ACK, \"Rx ACK\"),\n\t    IPW2100_ORD(STAT_RX_CFEND, \"Rx CF End\"),\n\t    IPW2100_ORD(STAT_RX_CFEND_ACK, \"Rx CF End + CF Ack\"),\n\t    IPW2100_ORD(STAT_RX_ASSN, \"Association Rx's\"),\n\t    IPW2100_ORD(STAT_RX_ASSN_RESP, \"Association response Rx's\"),\n\t    IPW2100_ORD(STAT_RX_REASSN, \"Reassociation Rx's\"),\n\t    IPW2100_ORD(STAT_RX_REASSN_RESP,\n\t\t\t\t\"Reassociation response Rx's\"),\n\t    IPW2100_ORD(STAT_RX_PROBE, \"probe Rx's\"),\n\t    IPW2100_ORD(STAT_RX_PROBE_RESP, \"probe response Rx's\"),\n\t    IPW2100_ORD(STAT_RX_BEACON, \"Rx beacon\"),\n\t    IPW2100_ORD(STAT_RX_ATIM, \"Rx ATIM\"),\n\t    IPW2100_ORD(STAT_RX_DISASSN, \"disassociation Rx\"),\n\t    IPW2100_ORD(STAT_RX_AUTH, \"authentication Rx\"),\n\t    IPW2100_ORD(STAT_RX_DEAUTH, \"deauthentication Rx\"),\n\t    IPW2100_ORD(STAT_RX_TOTAL_BYTES,\n\t\t\t\t\"Total rx data bytes received\"),\n\t    IPW2100_ORD(STAT_RX_ERR_CRC, \"packets with Rx CRC error\"),\n\t    IPW2100_ORD(STAT_RX_ERR_CRC1, \"Rx CRC errors at 1MB\"),\n\t    IPW2100_ORD(STAT_RX_ERR_CRC2, \"Rx CRC errors at 2MB\"),\n\t    IPW2100_ORD(STAT_RX_ERR_CRC5_5, \"Rx CRC errors at 5.5MB\"),\n\t    IPW2100_ORD(STAT_RX_ERR_CRC11, \"Rx CRC errors at 11MB\"),\n\t    IPW2100_ORD(STAT_RX_DUPLICATE1,\n\t\t\t\t\"duplicate rx packets at 1MB\"),\n\t    IPW2100_ORD(STAT_RX_DUPLICATE2,\n\t\t\t\t\"duplicate rx packets at 2MB\"),\n\t    IPW2100_ORD(STAT_RX_DUPLICATE5_5,\n\t\t\t\t\"duplicate rx packets at 5.5MB\"),\n\t    IPW2100_ORD(STAT_RX_DUPLICATE11,\n\t\t\t\t\"duplicate rx packets at 11MB\"),\n\t    IPW2100_ORD(STAT_RX_DUPLICATE, \"duplicate rx packets\"),\n\t    IPW2100_ORD(PERS_DB_LOCK, \"locking fw permanent  db\"),\n\t    IPW2100_ORD(PERS_DB_SIZE, \"size of fw permanent  db\"),\n\t    IPW2100_ORD(PERS_DB_ADDR, \"address of fw permanent  db\"),\n\t    IPW2100_ORD(STAT_RX_INVALID_PROTOCOL,\n\t\t\t\t\"rx frames with invalid protocol\"),\n\t    IPW2100_ORD(SYS_BOOT_TIME, \"Boot time\"),\n\t    IPW2100_ORD(STAT_RX_NO_BUFFER,\n\t\t\t\t\"rx frames rejected due to no buffer\"),\n\t    IPW2100_ORD(STAT_RX_MISSING_FRAG,\n\t\t\t\t\"rx frames dropped due to missing fragment\"),\n\t    IPW2100_ORD(STAT_RX_ORPHAN_FRAG,\n\t\t\t\t\"rx frames dropped due to non-sequential fragment\"),\n\t    IPW2100_ORD(STAT_RX_ORPHAN_FRAME,\n\t\t\t\t\"rx frames dropped due to unmatched 1st frame\"),\n\t    IPW2100_ORD(STAT_RX_FRAG_AGEOUT,\n\t\t\t\t\"rx frames dropped due to uncompleted frame\"),\n\t    IPW2100_ORD(STAT_RX_ICV_ERRORS,\n\t\t\t\t\"ICV errors during decryption\"),\n\t    IPW2100_ORD(STAT_PSP_SUSPENSION, \"times adapter suspended\"),\n\t    IPW2100_ORD(STAT_PSP_BCN_TIMEOUT, \"beacon timeout\"),\n\t    IPW2100_ORD(STAT_PSP_POLL_TIMEOUT,\n\t\t\t\t\"poll response timeouts\"),\n\t    IPW2100_ORD(STAT_PSP_NONDIR_TIMEOUT,\n\t\t\t\t\"timeouts waiting for last {broad,multi}cast pkt\"),\n\t    IPW2100_ORD(STAT_PSP_RX_DTIMS, \"PSP DTIMs received\"),\n\t    IPW2100_ORD(STAT_PSP_RX_TIMS, \"PSP TIMs received\"),\n\t    IPW2100_ORD(STAT_PSP_STATION_ID, \"PSP Station ID\"),\n\t    IPW2100_ORD(LAST_ASSN_TIME, \"RTC time of last association\"),\n\t    IPW2100_ORD(STAT_PERCENT_MISSED_BCNS,\n\t\t\t\t\"current calculation of % missed beacons\"),\n\t    IPW2100_ORD(STAT_PERCENT_RETRIES,\n\t\t\t\t\"current calculation of % missed tx retries\"),\n\t    IPW2100_ORD(ASSOCIATED_AP_PTR,\n\t\t\t\t\"0 if not associated, else pointer to AP table entry\"),\n\t    IPW2100_ORD(AVAILABLE_AP_CNT,\n\t\t\t\t\"AP's described in the AP table\"),\n\t    IPW2100_ORD(AP_LIST_PTR, \"Ptr to list of available APs\"),\n\t    IPW2100_ORD(STAT_AP_ASSNS, \"associations\"),\n\t    IPW2100_ORD(STAT_ASSN_FAIL, \"association failures\"),\n\t    IPW2100_ORD(STAT_ASSN_RESP_FAIL,\n\t\t\t\t\"failures due to response fail\"),\n\t    IPW2100_ORD(STAT_FULL_SCANS, \"full scans\"),\n\t    IPW2100_ORD(CARD_DISABLED, \"Card Disabled\"),\n\t    IPW2100_ORD(STAT_ROAM_INHIBIT,\n\t\t\t\t\"times roaming was inhibited due to activity\"),\n\t    IPW2100_ORD(RSSI_AT_ASSN,\n\t\t\t\t\"RSSI of associated AP at time of association\"),\n\t    IPW2100_ORD(STAT_ASSN_CAUSE1,\n\t\t\t\t\"reassociation: no probe response or TX on hop\"),\n\t    IPW2100_ORD(STAT_ASSN_CAUSE2,\n\t\t\t\t\"reassociation: poor tx/rx quality\"),\n\t    IPW2100_ORD(STAT_ASSN_CAUSE3,\n\t\t\t\t\"reassociation: tx/rx quality (excessive AP load\"),\n\t    IPW2100_ORD(STAT_ASSN_CAUSE4,\n\t\t\t\t\"reassociation: AP RSSI level\"),\n\t    IPW2100_ORD(STAT_ASSN_CAUSE5,\n\t\t\t\t\"reassociations due to load leveling\"),\n\t    IPW2100_ORD(STAT_AUTH_FAIL, \"times authentication failed\"),\n\t    IPW2100_ORD(STAT_AUTH_RESP_FAIL,\n\t\t\t\t\"times authentication response failed\"),\n\t    IPW2100_ORD(STATION_TABLE_CNT,\n\t\t\t\t\"entries in association table\"),\n\t    IPW2100_ORD(RSSI_AVG_CURR, \"Current avg RSSI\"),\n\t    IPW2100_ORD(POWER_MGMT_MODE, \"Power mode - 0=CAM, 1=PSP\"),\n\t    IPW2100_ORD(COUNTRY_CODE,\n\t\t\t\t\"IEEE country code as recv'd from beacon\"),\n\t    IPW2100_ORD(COUNTRY_CHANNELS,\n\t\t\t\t\"channels supported by country\"),\n\t    IPW2100_ORD(RESET_CNT, \"adapter resets (warm)\"),\n\t    IPW2100_ORD(BEACON_INTERVAL, \"Beacon interval\"),\n\t    IPW2100_ORD(ANTENNA_DIVERSITY,\n\t\t\t\t\"TRUE if antenna diversity is disabled\"),\n\t    IPW2100_ORD(DTIM_PERIOD, \"beacon intervals between DTIMs\"),\n\t    IPW2100_ORD(OUR_FREQ,\n\t\t\t\t\"current radio freq lower digits - channel ID\"),\n\t    IPW2100_ORD(RTC_TIME, \"current RTC time\"),\n\t    IPW2100_ORD(PORT_TYPE, \"operating mode\"),\n\t    IPW2100_ORD(CURRENT_TX_RATE, \"current tx rate\"),\n\t    IPW2100_ORD(SUPPORTED_RATES, \"supported tx rates\"),\n\t    IPW2100_ORD(ATIM_WINDOW, \"current ATIM Window\"),\n\t    IPW2100_ORD(BASIC_RATES, \"basic tx rates\"),\n\t    IPW2100_ORD(NIC_HIGHEST_RATE, \"NIC highest tx rate\"),\n\t    IPW2100_ORD(AP_HIGHEST_RATE, \"AP highest tx rate\"),\n\t    IPW2100_ORD(CAPABILITIES,\n\t\t\t\t\"Management frame capability field\"),\n\t    IPW2100_ORD(AUTH_TYPE, \"Type of authentication\"),\n\t    IPW2100_ORD(RADIO_TYPE, \"Adapter card platform type\"),\n\t    IPW2100_ORD(RTS_THRESHOLD,\n\t\t\t\t\"Min packet length for RTS handshaking\"),\n\t    IPW2100_ORD(INT_MODE, \"International mode\"),\n\t    IPW2100_ORD(FRAGMENTATION_THRESHOLD,\n\t\t\t\t\"protocol frag threshold\"),\n\t    IPW2100_ORD(EEPROM_SRAM_DB_BLOCK_START_ADDRESS,\n\t\t\t\t\"EEPROM offset in SRAM\"),\n\t    IPW2100_ORD(EEPROM_SRAM_DB_BLOCK_SIZE,\n\t\t\t\t\"EEPROM size in SRAM\"),\n\t    IPW2100_ORD(EEPROM_SKU_CAPABILITY, \"EEPROM SKU Capability\"),\n\t    IPW2100_ORD(EEPROM_IBSS_11B_CHANNELS,\n\t\t\t\t\"EEPROM IBSS 11b channel set\"),\n\t    IPW2100_ORD(MAC_VERSION, \"MAC Version\"),\n\t    IPW2100_ORD(MAC_REVISION, \"MAC Revision\"),\n\t    IPW2100_ORD(RADIO_VERSION, \"Radio Version\"),\n\t    IPW2100_ORD(NIC_MANF_DATE_TIME, \"MANF Date/Time STAMP\"),\n\t    IPW2100_ORD(UCODE_VERSION, \"Ucode Version\"),};\n\nstatic ssize_t registers_show(struct device *d, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tint i;\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\tstruct net_device *dev = priv->net_dev;\n\tchar *out = buf;\n\tu32 val = 0;\n\n\tout += sprintf(out, \"%30s [Address ] : Hex\\n\", \"Register\");\n\n\tfor (i = 0; i < ARRAY_SIZE(hw_data); i++) {\n\t\tread_register(dev, hw_data[i].addr, &val);\n\t\tout += sprintf(out, \"%30s [%08X] : %08X\\n\",\n\t\t\t       hw_data[i].name, hw_data[i].addr, val);\n\t}\n\n\treturn out - buf;\n}\n\nstatic DEVICE_ATTR_RO(registers);\n\nstatic ssize_t hardware_show(struct device *d, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\tstruct net_device *dev = priv->net_dev;\n\tchar *out = buf;\n\tint i;\n\n\tout += sprintf(out, \"%30s [Address ] : Hex\\n\", \"NIC entry\");\n\n\tfor (i = 0; i < ARRAY_SIZE(nic_data); i++) {\n\t\tu8 tmp8;\n\t\tu16 tmp16;\n\t\tu32 tmp32;\n\n\t\tswitch (nic_data[i].size) {\n\t\tcase 1:\n\t\t\tread_nic_byte(dev, nic_data[i].addr, &tmp8);\n\t\t\tout += sprintf(out, \"%30s [%08X] : %02X\\n\",\n\t\t\t\t       nic_data[i].name, nic_data[i].addr,\n\t\t\t\t       tmp8);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tread_nic_word(dev, nic_data[i].addr, &tmp16);\n\t\t\tout += sprintf(out, \"%30s [%08X] : %04X\\n\",\n\t\t\t\t       nic_data[i].name, nic_data[i].addr,\n\t\t\t\t       tmp16);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tread_nic_dword(dev, nic_data[i].addr, &tmp32);\n\t\t\tout += sprintf(out, \"%30s [%08X] : %08X\\n\",\n\t\t\t\t       nic_data[i].name, nic_data[i].addr,\n\t\t\t\t       tmp32);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn out - buf;\n}\n\nstatic DEVICE_ATTR_RO(hardware);\n\nstatic ssize_t memory_show(struct device *d, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\tstruct net_device *dev = priv->net_dev;\n\tstatic unsigned long loop = 0;\n\tint len = 0;\n\tu32 buffer[4];\n\tint i;\n\tchar line[81];\n\n\tif (loop >= 0x30000)\n\t\tloop = 0;\n\n\t \n\twhile (len < PAGE_SIZE - 128 && loop < 0x30000) {\n\n\t\tif (priv->snapshot[0])\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\tbuffer[i] =\n\t\t\t\t    *(u32 *) SNAPSHOT_ADDR(loop + i * 4);\n\t\telse\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\tread_nic_dword(dev, loop + i * 4, &buffer[i]);\n\n\t\tif (priv->dump_raw)\n\t\t\tlen += sprintf(buf + len,\n\t\t\t\t       \"%c%c%c%c\"\n\t\t\t\t       \"%c%c%c%c\"\n\t\t\t\t       \"%c%c%c%c\"\n\t\t\t\t       \"%c%c%c%c\",\n\t\t\t\t       ((u8 *) buffer)[0x0],\n\t\t\t\t       ((u8 *) buffer)[0x1],\n\t\t\t\t       ((u8 *) buffer)[0x2],\n\t\t\t\t       ((u8 *) buffer)[0x3],\n\t\t\t\t       ((u8 *) buffer)[0x4],\n\t\t\t\t       ((u8 *) buffer)[0x5],\n\t\t\t\t       ((u8 *) buffer)[0x6],\n\t\t\t\t       ((u8 *) buffer)[0x7],\n\t\t\t\t       ((u8 *) buffer)[0x8],\n\t\t\t\t       ((u8 *) buffer)[0x9],\n\t\t\t\t       ((u8 *) buffer)[0xa],\n\t\t\t\t       ((u8 *) buffer)[0xb],\n\t\t\t\t       ((u8 *) buffer)[0xc],\n\t\t\t\t       ((u8 *) buffer)[0xd],\n\t\t\t\t       ((u8 *) buffer)[0xe],\n\t\t\t\t       ((u8 *) buffer)[0xf]);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \"%s\\n\",\n\t\t\t\t       snprint_line(line, sizeof(line),\n\t\t\t\t\t\t    (u8 *) buffer, 16, loop));\n\t\tloop += 16;\n\t}\n\n\treturn len;\n}\n\nstatic ssize_t memory_store(struct device *d, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\tstruct net_device *dev = priv->net_dev;\n\tconst char *p = buf;\n\n\t(void)dev;\t\t \n\n\tif (count < 1)\n\t\treturn count;\n\n\tif (p[0] == '1' ||\n\t    (count >= 2 && tolower(p[0]) == 'o' && tolower(p[1]) == 'n')) {\n\t\tIPW_DEBUG_INFO(\"%s: Setting memory dump to RAW mode.\\n\",\n\t\t\t       dev->name);\n\t\tpriv->dump_raw = 1;\n\n\t} else if (p[0] == '0' || (count >= 2 && tolower(p[0]) == 'o' &&\n\t\t\t\t   tolower(p[1]) == 'f')) {\n\t\tIPW_DEBUG_INFO(\"%s: Setting memory dump to HEX mode.\\n\",\n\t\t\t       dev->name);\n\t\tpriv->dump_raw = 0;\n\n\t} else if (tolower(p[0]) == 'r') {\n\t\tIPW_DEBUG_INFO(\"%s: Resetting firmware snapshot.\\n\", dev->name);\n\t\tipw2100_snapshot_free(priv);\n\n\t} else\n\t\tIPW_DEBUG_INFO(\"%s: Usage: 0|on = HEX, 1|off = RAW, \"\n\t\t\t       \"reset = clear memory snapshot\\n\", dev->name);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(memory);\n\nstatic ssize_t ordinals_show(struct device *d, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\tu32 val = 0;\n\tint len = 0;\n\tu32 val_len;\n\tstatic int loop = 0;\n\n\tif (priv->status & STATUS_RF_KILL_MASK)\n\t\treturn 0;\n\n\tif (loop >= ARRAY_SIZE(ord_data))\n\t\tloop = 0;\n\n\t \n\twhile (len < PAGE_SIZE - 128 && loop < ARRAY_SIZE(ord_data)) {\n\t\tval_len = sizeof(u32);\n\n\t\tif (ipw2100_get_ordinal(priv, ord_data[loop].index, &val,\n\t\t\t\t\t&val_len))\n\t\t\tlen += sprintf(buf + len, \"[0x%02X] = ERROR    %s\\n\",\n\t\t\t\t       ord_data[loop].index,\n\t\t\t\t       ord_data[loop].desc);\n\t\telse\n\t\t\tlen += sprintf(buf + len, \"[0x%02X] = 0x%08X %s\\n\",\n\t\t\t\t       ord_data[loop].index, val,\n\t\t\t\t       ord_data[loop].desc);\n\t\tloop++;\n\t}\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR_RO(ordinals);\n\nstatic ssize_t stats_show(struct device *d, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\tchar *out = buf;\n\n\tout += sprintf(out, \"interrupts: %d {tx: %d, rx: %d, other: %d}\\n\",\n\t\t       priv->interrupts, priv->tx_interrupts,\n\t\t       priv->rx_interrupts, priv->inta_other);\n\tout += sprintf(out, \"firmware resets: %d\\n\", priv->resets);\n\tout += sprintf(out, \"firmware hangs: %d\\n\", priv->hangs);\n#ifdef CONFIG_IPW2100_DEBUG\n\tout += sprintf(out, \"packet mismatch image: %s\\n\",\n\t\t       priv->snapshot[0] ? \"YES\" : \"NO\");\n#endif\n\n\treturn out - buf;\n}\n\nstatic DEVICE_ATTR_RO(stats);\n\nstatic int ipw2100_switch_mode(struct ipw2100_priv *priv, u32 mode)\n{\n\tint err;\n\n\tif (mode == priv->ieee->iw_mode)\n\t\treturn 0;\n\n\terr = ipw2100_disable_adapter(priv);\n\tif (err) {\n\t\tprintk(KERN_ERR DRV_NAME \": %s: Could not disable adapter %d\\n\",\n\t\t       priv->net_dev->name, err);\n\t\treturn err;\n\t}\n\n\tswitch (mode) {\n\tcase IW_MODE_INFRA:\n\t\tpriv->net_dev->type = ARPHRD_ETHER;\n\t\tbreak;\n\tcase IW_MODE_ADHOC:\n\t\tpriv->net_dev->type = ARPHRD_ETHER;\n\t\tbreak;\n#ifdef CONFIG_IPW2100_MONITOR\n\tcase IW_MODE_MONITOR:\n\t\tpriv->last_mode = priv->ieee->iw_mode;\n\t\tpriv->net_dev->type = ARPHRD_IEEE80211_RADIOTAP;\n\t\tbreak;\n#endif\t\t\t\t \n\t}\n\n\tpriv->ieee->iw_mode = mode;\n\n#ifdef CONFIG_PM\n\t \n\tipw2100_firmware.version = 0;\n#endif\n\n\tprintk(KERN_INFO \"%s: Resetting on mode change.\\n\", priv->net_dev->name);\n\tpriv->reset_backoff = 0;\n\tschedule_reset(priv);\n\n\treturn 0;\n}\n\nstatic ssize_t internals_show(struct device *d, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\tint len = 0;\n\n#define DUMP_VAR(x,y) len += sprintf(buf + len, # x \": %\" y \"\\n\", priv-> x)\n\n\tif (priv->status & STATUS_ASSOCIATED)\n\t\tlen += sprintf(buf + len, \"connected: %llu\\n\",\n\t\t\t       ktime_get_boottime_seconds() - priv->connect_start);\n\telse\n\t\tlen += sprintf(buf + len, \"not connected\\n\");\n\n\tDUMP_VAR(ieee->crypt_info.crypt[priv->ieee->crypt_info.tx_keyidx], \"p\");\n\tDUMP_VAR(status, \"08lx\");\n\tDUMP_VAR(config, \"08lx\");\n\tDUMP_VAR(capability, \"08lx\");\n\n\tlen +=\n\t    sprintf(buf + len, \"last_rtc: %lu\\n\",\n\t\t    (unsigned long)priv->last_rtc);\n\n\tDUMP_VAR(fatal_error, \"d\");\n\tDUMP_VAR(stop_hang_check, \"d\");\n\tDUMP_VAR(stop_rf_kill, \"d\");\n\tDUMP_VAR(messages_sent, \"d\");\n\n\tDUMP_VAR(tx_pend_stat.value, \"d\");\n\tDUMP_VAR(tx_pend_stat.hi, \"d\");\n\n\tDUMP_VAR(tx_free_stat.value, \"d\");\n\tDUMP_VAR(tx_free_stat.lo, \"d\");\n\n\tDUMP_VAR(msg_free_stat.value, \"d\");\n\tDUMP_VAR(msg_free_stat.lo, \"d\");\n\n\tDUMP_VAR(msg_pend_stat.value, \"d\");\n\tDUMP_VAR(msg_pend_stat.hi, \"d\");\n\n\tDUMP_VAR(fw_pend_stat.value, \"d\");\n\tDUMP_VAR(fw_pend_stat.hi, \"d\");\n\n\tDUMP_VAR(txq_stat.value, \"d\");\n\tDUMP_VAR(txq_stat.lo, \"d\");\n\n\tDUMP_VAR(ieee->scans, \"d\");\n\tDUMP_VAR(reset_backoff, \"lld\");\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR_RO(internals);\n\nstatic ssize_t bssinfo_show(struct device *d, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\tchar essid[IW_ESSID_MAX_SIZE + 1];\n\tu8 bssid[ETH_ALEN];\n\tu32 chan = 0;\n\tchar *out = buf;\n\tunsigned int length;\n\tint ret;\n\n\tif (priv->status & STATUS_RF_KILL_MASK)\n\t\treturn 0;\n\n\tmemset(essid, 0, sizeof(essid));\n\tmemset(bssid, 0, sizeof(bssid));\n\n\tlength = IW_ESSID_MAX_SIZE;\n\tret = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_SSID, essid, &length);\n\tif (ret)\n\t\tIPW_DEBUG_INFO(\"failed querying ordinals at line %d\\n\",\n\t\t\t       __LINE__);\n\n\tlength = sizeof(bssid);\n\tret = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_AP_BSSID,\n\t\t\t\t  bssid, &length);\n\tif (ret)\n\t\tIPW_DEBUG_INFO(\"failed querying ordinals at line %d\\n\",\n\t\t\t       __LINE__);\n\n\tlength = sizeof(u32);\n\tret = ipw2100_get_ordinal(priv, IPW_ORD_OUR_FREQ, &chan, &length);\n\tif (ret)\n\t\tIPW_DEBUG_INFO(\"failed querying ordinals at line %d\\n\",\n\t\t\t       __LINE__);\n\n\tout += sprintf(out, \"ESSID: %s\\n\", essid);\n\tout += sprintf(out, \"BSSID:   %pM\\n\", bssid);\n\tout += sprintf(out, \"Channel: %d\\n\", chan);\n\n\treturn out - buf;\n}\n\nstatic DEVICE_ATTR_RO(bssinfo);\n\n#ifdef CONFIG_IPW2100_DEBUG\nstatic ssize_t debug_level_show(struct device_driver *d, char *buf)\n{\n\treturn sprintf(buf, \"0x%08X\\n\", ipw2100_debug_level);\n}\n\nstatic ssize_t debug_level_store(struct device_driver *d,\n\t\t\t\t const char *buf, size_t count)\n{\n\tu32 val;\n\tint ret;\n\n\tret = kstrtou32(buf, 0, &val);\n\tif (ret)\n\t\tIPW_DEBUG_INFO(\": %s is not in hex or decimal form.\\n\", buf);\n\telse\n\t\tipw2100_debug_level = val;\n\n\treturn strnlen(buf, count);\n}\nstatic DRIVER_ATTR_RW(debug_level);\n#endif\t\t\t\t \n\nstatic ssize_t fatal_error_show(struct device *d,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\tchar *out = buf;\n\tint i;\n\n\tif (priv->fatal_error)\n\t\tout += sprintf(out, \"0x%08X\\n\", priv->fatal_error);\n\telse\n\t\tout += sprintf(out, \"0\\n\");\n\n\tfor (i = 1; i <= IPW2100_ERROR_QUEUE; i++) {\n\t\tif (!priv->fatal_errors[(priv->fatal_index - i) %\n\t\t\t\t\tIPW2100_ERROR_QUEUE])\n\t\t\tcontinue;\n\n\t\tout += sprintf(out, \"%d. 0x%08X\\n\", i,\n\t\t\t       priv->fatal_errors[(priv->fatal_index - i) %\n\t\t\t\t\t\t  IPW2100_ERROR_QUEUE]);\n\t}\n\n\treturn out - buf;\n}\n\nstatic ssize_t fatal_error_store(struct device *d,\n\t\t\t\t struct device_attribute *attr, const char *buf,\n\t\t\t\t size_t count)\n{\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\tschedule_reset(priv);\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(fatal_error);\n\nstatic ssize_t scan_age_show(struct device *d, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\treturn sprintf(buf, \"%d\\n\", priv->ieee->scan_age);\n}\n\nstatic ssize_t scan_age_store(struct device *d, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\tstruct net_device *dev = priv->net_dev;\n\tunsigned long val;\n\tint ret;\n\n\t(void)dev;\t\t \n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tret = kstrtoul(buf, 0, &val);\n\tif (ret) {\n\t\tIPW_DEBUG_INFO(\"%s: user supplied invalid value.\\n\", dev->name);\n\t} else {\n\t\tpriv->ieee->scan_age = val;\n\t\tIPW_DEBUG_INFO(\"set scan_age = %u\\n\", priv->ieee->scan_age);\n\t}\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR_RW(scan_age);\n\nstatic ssize_t rf_kill_show(struct device *d, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\t \n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\tint val = ((priv->status & STATUS_RF_KILL_SW) ? 0x1 : 0x0) |\n\t    (rf_kill_active(priv) ? 0x2 : 0x0);\n\treturn sprintf(buf, \"%i\\n\", val);\n}\n\nstatic int ipw_radio_kill_sw(struct ipw2100_priv *priv, int disable_radio)\n{\n\tif ((disable_radio ? 1 : 0) ==\n\t    (priv->status & STATUS_RF_KILL_SW ? 1 : 0))\n\t\treturn 0;\n\n\tIPW_DEBUG_RF_KILL(\"Manual SW RF Kill set to: RADIO  %s\\n\",\n\t\t\t  disable_radio ? \"OFF\" : \"ON\");\n\n\tmutex_lock(&priv->action_mutex);\n\n\tif (disable_radio) {\n\t\tpriv->status |= STATUS_RF_KILL_SW;\n\t\tipw2100_down(priv);\n\t} else {\n\t\tpriv->status &= ~STATUS_RF_KILL_SW;\n\t\tif (rf_kill_active(priv)) {\n\t\t\tIPW_DEBUG_RF_KILL(\"Can not turn radio back on - \"\n\t\t\t\t\t  \"disabled by HW switch\\n\");\n\t\t\t \n\t\t\tpriv->stop_rf_kill = 0;\n\t\t\tmod_delayed_work(system_wq, &priv->rf_kill,\n\t\t\t\t\t round_jiffies_relative(HZ));\n\t\t} else\n\t\t\tschedule_reset(priv);\n\t}\n\n\tmutex_unlock(&priv->action_mutex);\n\treturn 1;\n}\n\nstatic ssize_t rf_kill_store(struct device *d, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct ipw2100_priv *priv = dev_get_drvdata(d);\n\tipw_radio_kill_sw(priv, buf[0] == '1');\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(rf_kill);\n\nstatic struct attribute *ipw2100_sysfs_entries[] = {\n\t&dev_attr_hardware.attr,\n\t&dev_attr_registers.attr,\n\t&dev_attr_ordinals.attr,\n\t&dev_attr_pci.attr,\n\t&dev_attr_stats.attr,\n\t&dev_attr_internals.attr,\n\t&dev_attr_bssinfo.attr,\n\t&dev_attr_memory.attr,\n\t&dev_attr_scan_age.attr,\n\t&dev_attr_fatal_error.attr,\n\t&dev_attr_rf_kill.attr,\n\t&dev_attr_cfg.attr,\n\t&dev_attr_status.attr,\n\t&dev_attr_capability.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group ipw2100_attribute_group = {\n\t.attrs = ipw2100_sysfs_entries,\n};\n\nstatic int status_queue_allocate(struct ipw2100_priv *priv, int entries)\n{\n\tstruct ipw2100_status_queue *q = &priv->status_queue;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tq->size = entries * sizeof(struct ipw2100_status);\n\tq->drv = dma_alloc_coherent(&priv->pci_dev->dev, q->size, &q->nic,\n\t\t\t\t    GFP_KERNEL);\n\tif (!q->drv) {\n\t\tIPW_DEBUG_WARNING(\"Can not allocate status queue.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n\n\treturn 0;\n}\n\nstatic void status_queue_free(struct ipw2100_priv *priv)\n{\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tif (priv->status_queue.drv) {\n\t\tdma_free_coherent(&priv->pci_dev->dev,\n\t\t\t\t  priv->status_queue.size,\n\t\t\t\t  priv->status_queue.drv,\n\t\t\t\t  priv->status_queue.nic);\n\t\tpriv->status_queue.drv = NULL;\n\t}\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n}\n\nstatic int bd_queue_allocate(struct ipw2100_priv *priv,\n\t\t\t     struct ipw2100_bd_queue *q, int entries)\n{\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tmemset(q, 0, sizeof(struct ipw2100_bd_queue));\n\n\tq->entries = entries;\n\tq->size = entries * sizeof(struct ipw2100_bd);\n\tq->drv = dma_alloc_coherent(&priv->pci_dev->dev, q->size, &q->nic,\n\t\t\t\t    GFP_KERNEL);\n\tif (!q->drv) {\n\t\tIPW_DEBUG_INFO\n\t\t    (\"can't allocate shared memory for buffer descriptors\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n\n\treturn 0;\n}\n\nstatic void bd_queue_free(struct ipw2100_priv *priv, struct ipw2100_bd_queue *q)\n{\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tif (!q)\n\t\treturn;\n\n\tif (q->drv) {\n\t\tdma_free_coherent(&priv->pci_dev->dev, q->size, q->drv,\n\t\t\t\t  q->nic);\n\t\tq->drv = NULL;\n\t}\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n}\n\nstatic void bd_queue_initialize(struct ipw2100_priv *priv,\n\t\t\t\tstruct ipw2100_bd_queue *q, u32 base, u32 size,\n\t\t\t\tu32 r, u32 w)\n{\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tIPW_DEBUG_INFO(\"initializing bd queue at virt=%p, phys=%08x\\n\", q->drv,\n\t\t       (u32) q->nic);\n\n\twrite_register(priv->net_dev, base, q->nic);\n\twrite_register(priv->net_dev, size, q->entries);\n\twrite_register(priv->net_dev, r, q->oldest);\n\twrite_register(priv->net_dev, w, q->next);\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n}\n\nstatic void ipw2100_kill_works(struct ipw2100_priv *priv)\n{\n\tpriv->stop_rf_kill = 1;\n\tpriv->stop_hang_check = 1;\n\tcancel_delayed_work_sync(&priv->reset_work);\n\tcancel_delayed_work_sync(&priv->security_work);\n\tcancel_delayed_work_sync(&priv->wx_event_work);\n\tcancel_delayed_work_sync(&priv->hang_check);\n\tcancel_delayed_work_sync(&priv->rf_kill);\n\tcancel_delayed_work_sync(&priv->scan_event);\n}\n\nstatic int ipw2100_tx_allocate(struct ipw2100_priv *priv)\n{\n\tint i, j, err;\n\tvoid *v;\n\tdma_addr_t p;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\terr = bd_queue_allocate(priv, &priv->tx_queue, TX_QUEUE_LENGTH);\n\tif (err) {\n\t\tIPW_DEBUG_ERROR(\"%s: failed bd_queue_allocate\\n\",\n\t\t\t\tpriv->net_dev->name);\n\t\treturn err;\n\t}\n\n\tpriv->tx_buffers = kmalloc_array(TX_PENDED_QUEUE_LENGTH,\n\t\t\t\t\t sizeof(struct ipw2100_tx_packet),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!priv->tx_buffers) {\n\t\tbd_queue_free(priv, &priv->tx_queue);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < TX_PENDED_QUEUE_LENGTH; i++) {\n\t\tv = dma_alloc_coherent(&priv->pci_dev->dev,\n\t\t\t\t       sizeof(struct ipw2100_data_header), &p,\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!v) {\n\t\t\tprintk(KERN_ERR DRV_NAME\n\t\t\t       \": %s: PCI alloc failed for tx \" \"buffers.\\n\",\n\t\t\t       priv->net_dev->name);\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tpriv->tx_buffers[i].type = DATA;\n\t\tpriv->tx_buffers[i].info.d_struct.data =\n\t\t    (struct ipw2100_data_header *)v;\n\t\tpriv->tx_buffers[i].info.d_struct.data_phys = p;\n\t\tpriv->tx_buffers[i].info.d_struct.txb = NULL;\n\t}\n\n\tif (i == TX_PENDED_QUEUE_LENGTH)\n\t\treturn 0;\n\n\tfor (j = 0; j < i; j++) {\n\t\tdma_free_coherent(&priv->pci_dev->dev,\n\t\t\t\t  sizeof(struct ipw2100_data_header),\n\t\t\t\t  priv->tx_buffers[j].info.d_struct.data,\n\t\t\t\t  priv->tx_buffers[j].info.d_struct.data_phys);\n\t}\n\n\tkfree(priv->tx_buffers);\n\tpriv->tx_buffers = NULL;\n\n\treturn err;\n}\n\nstatic void ipw2100_tx_initialize(struct ipw2100_priv *priv)\n{\n\tint i;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\t \n\tINIT_LIST_HEAD(&priv->fw_pend_list);\n\tINIT_STAT(&priv->fw_pend_stat);\n\n\t \n\tINIT_LIST_HEAD(&priv->tx_pend_list);\n\tINIT_LIST_HEAD(&priv->tx_free_list);\n\tINIT_STAT(&priv->tx_pend_stat);\n\tINIT_STAT(&priv->tx_free_stat);\n\n\tfor (i = 0; i < TX_PENDED_QUEUE_LENGTH; i++) {\n\t\t \n\t\tif (priv->tx_buffers[i].info.d_struct.txb) {\n\t\t\tlibipw_txb_free(priv->tx_buffers[i].info.d_struct.\n\t\t\t\t\t   txb);\n\t\t\tpriv->tx_buffers[i].info.d_struct.txb = NULL;\n\t\t}\n\n\t\tlist_add_tail(&priv->tx_buffers[i].list, &priv->tx_free_list);\n\t}\n\n\tSET_STAT(&priv->tx_free_stat, i);\n\n\tpriv->tx_queue.oldest = 0;\n\tpriv->tx_queue.available = priv->tx_queue.entries;\n\tpriv->tx_queue.next = 0;\n\tINIT_STAT(&priv->txq_stat);\n\tSET_STAT(&priv->txq_stat, priv->tx_queue.available);\n\n\tbd_queue_initialize(priv, &priv->tx_queue,\n\t\t\t    IPW_MEM_HOST_SHARED_TX_QUEUE_BD_BASE,\n\t\t\t    IPW_MEM_HOST_SHARED_TX_QUEUE_BD_SIZE,\n\t\t\t    IPW_MEM_HOST_SHARED_TX_QUEUE_READ_INDEX,\n\t\t\t    IPW_MEM_HOST_SHARED_TX_QUEUE_WRITE_INDEX);\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n\n}\n\nstatic void ipw2100_tx_free(struct ipw2100_priv *priv)\n{\n\tint i;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tbd_queue_free(priv, &priv->tx_queue);\n\n\tif (!priv->tx_buffers)\n\t\treturn;\n\n\tfor (i = 0; i < TX_PENDED_QUEUE_LENGTH; i++) {\n\t\tif (priv->tx_buffers[i].info.d_struct.txb) {\n\t\t\tlibipw_txb_free(priv->tx_buffers[i].info.d_struct.\n\t\t\t\t\t   txb);\n\t\t\tpriv->tx_buffers[i].info.d_struct.txb = NULL;\n\t\t}\n\t\tif (priv->tx_buffers[i].info.d_struct.data)\n\t\t\tdma_free_coherent(&priv->pci_dev->dev,\n\t\t\t\t\t  sizeof(struct ipw2100_data_header),\n\t\t\t\t\t  priv->tx_buffers[i].info.d_struct.data,\n\t\t\t\t\t  priv->tx_buffers[i].info.d_struct.data_phys);\n\t}\n\n\tkfree(priv->tx_buffers);\n\tpriv->tx_buffers = NULL;\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n}\n\nstatic int ipw2100_rx_allocate(struct ipw2100_priv *priv)\n{\n\tint i, j, err = -EINVAL;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\terr = bd_queue_allocate(priv, &priv->rx_queue, RX_QUEUE_LENGTH);\n\tif (err) {\n\t\tIPW_DEBUG_INFO(\"failed bd_queue_allocate\\n\");\n\t\treturn err;\n\t}\n\n\terr = status_queue_allocate(priv, RX_QUEUE_LENGTH);\n\tif (err) {\n\t\tIPW_DEBUG_INFO(\"failed status_queue_allocate\\n\");\n\t\tbd_queue_free(priv, &priv->rx_queue);\n\t\treturn err;\n\t}\n\n\t \n\tpriv->rx_buffers = kmalloc_array(RX_QUEUE_LENGTH,\n\t\t\t\t\t sizeof(struct ipw2100_rx_packet),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!priv->rx_buffers) {\n\t\tIPW_DEBUG_INFO(\"can't allocate rx packet buffer table\\n\");\n\n\t\tbd_queue_free(priv, &priv->rx_queue);\n\n\t\tstatus_queue_free(priv);\n\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < RX_QUEUE_LENGTH; i++) {\n\t\tstruct ipw2100_rx_packet *packet = &priv->rx_buffers[i];\n\n\t\terr = ipw2100_alloc_skb(priv, packet);\n\t\tif (unlikely(err)) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tpriv->rx_queue.drv[i].host_addr = packet->dma_addr;\n\t\tpriv->rx_queue.drv[i].buf_length = IPW_RX_NIC_BUFFER_LENGTH;\n\t\tpriv->status_queue.drv[i].status_fields = 0;\n\t}\n\n\tif (i == RX_QUEUE_LENGTH)\n\t\treturn 0;\n\n\tfor (j = 0; j < i; j++) {\n\t\tdma_unmap_single(&priv->pci_dev->dev,\n\t\t\t\t priv->rx_buffers[j].dma_addr,\n\t\t\t\t sizeof(struct ipw2100_rx_packet),\n\t\t\t\t DMA_FROM_DEVICE);\n\t\tdev_kfree_skb(priv->rx_buffers[j].skb);\n\t}\n\n\tkfree(priv->rx_buffers);\n\tpriv->rx_buffers = NULL;\n\n\tbd_queue_free(priv, &priv->rx_queue);\n\n\tstatus_queue_free(priv);\n\n\treturn err;\n}\n\nstatic void ipw2100_rx_initialize(struct ipw2100_priv *priv)\n{\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tpriv->rx_queue.oldest = 0;\n\tpriv->rx_queue.available = priv->rx_queue.entries - 1;\n\tpriv->rx_queue.next = priv->rx_queue.entries - 1;\n\n\tINIT_STAT(&priv->rxq_stat);\n\tSET_STAT(&priv->rxq_stat, priv->rx_queue.available);\n\n\tbd_queue_initialize(priv, &priv->rx_queue,\n\t\t\t    IPW_MEM_HOST_SHARED_RX_BD_BASE,\n\t\t\t    IPW_MEM_HOST_SHARED_RX_BD_SIZE,\n\t\t\t    IPW_MEM_HOST_SHARED_RX_READ_INDEX,\n\t\t\t    IPW_MEM_HOST_SHARED_RX_WRITE_INDEX);\n\n\t \n\twrite_register(priv->net_dev, IPW_MEM_HOST_SHARED_RX_STATUS_BASE,\n\t\t       priv->status_queue.nic);\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n}\n\nstatic void ipw2100_rx_free(struct ipw2100_priv *priv)\n{\n\tint i;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tbd_queue_free(priv, &priv->rx_queue);\n\tstatus_queue_free(priv);\n\n\tif (!priv->rx_buffers)\n\t\treturn;\n\n\tfor (i = 0; i < RX_QUEUE_LENGTH; i++) {\n\t\tif (priv->rx_buffers[i].rxp) {\n\t\t\tdma_unmap_single(&priv->pci_dev->dev,\n\t\t\t\t\t priv->rx_buffers[i].dma_addr,\n\t\t\t\t\t sizeof(struct ipw2100_rx),\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(priv->rx_buffers[i].skb);\n\t\t}\n\t}\n\n\tkfree(priv->rx_buffers);\n\tpriv->rx_buffers = NULL;\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n}\n\nstatic int ipw2100_read_mac_address(struct ipw2100_priv *priv)\n{\n\tu32 length = ETH_ALEN;\n\tu8 addr[ETH_ALEN];\n\n\tint err;\n\n\terr = ipw2100_get_ordinal(priv, IPW_ORD_STAT_ADAPTER_MAC, addr, &length);\n\tif (err) {\n\t\tIPW_DEBUG_INFO(\"MAC address read failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\teth_hw_addr_set(priv->net_dev, addr);\n\tIPW_DEBUG_INFO(\"card MAC is %pM\\n\", priv->net_dev->dev_addr);\n\n\treturn 0;\n}\n\n \n\nstatic int ipw2100_set_mac_address(struct ipw2100_priv *priv, int batch_mode)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = ADAPTER_ADDRESS,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = ETH_ALEN\n\t};\n\tint err;\n\n\tIPW_DEBUG_HC(\"SET_MAC_ADDRESS\\n\");\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tif (priv->config & CFG_CUSTOM_MAC) {\n\t\tmemcpy(cmd.host_command_parameters, priv->mac_addr, ETH_ALEN);\n\t\teth_hw_addr_set(priv->net_dev, priv->mac_addr);\n\t} else\n\t\tmemcpy(cmd.host_command_parameters, priv->net_dev->dev_addr,\n\t\t       ETH_ALEN);\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n\treturn err;\n}\n\nstatic int ipw2100_set_port_type(struct ipw2100_priv *priv, u32 port_type,\n\t\t\t\t int batch_mode)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = PORT_TYPE,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = sizeof(u32)\n\t};\n\tint err;\n\n\tswitch (port_type) {\n\tcase IW_MODE_INFRA:\n\t\tcmd.host_command_parameters[0] = IPW_BSS;\n\t\tbreak;\n\tcase IW_MODE_ADHOC:\n\t\tcmd.host_command_parameters[0] = IPW_IBSS;\n\t\tbreak;\n\t}\n\n\tIPW_DEBUG_HC(\"PORT_TYPE: %s\\n\",\n\t\t     port_type == IPW_IBSS ? \"Ad-Hoc\" : \"Managed\");\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_disable_adapter(priv);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR DRV_NAME\n\t\t\t       \": %s: Could not disable adapter %d\\n\",\n\t\t\t       priv->net_dev->name, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\terr = ipw2100_hw_send_command(priv, &cmd);\n\n\tif (!batch_mode)\n\t\tipw2100_enable_adapter(priv);\n\n\treturn err;\n}\n\nstatic int ipw2100_set_channel(struct ipw2100_priv *priv, u32 channel,\n\t\t\t       int batch_mode)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = CHANNEL,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = sizeof(u32)\n\t};\n\tint err;\n\n\tcmd.host_command_parameters[0] = channel;\n\n\tIPW_DEBUG_HC(\"CHANNEL: %d\\n\", channel);\n\n\t \n\tif (priv->ieee->iw_mode == IW_MODE_INFRA)\n\t\treturn 0;\n\n\tif ((channel != 0) &&\n\t    ((channel < REG_MIN_CHANNEL) || (channel > REG_MAX_CHANNEL)))\n\t\treturn -EINVAL;\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_disable_adapter(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\tif (err) {\n\t\tIPW_DEBUG_INFO(\"Failed to set channel to %d\", channel);\n\t\treturn err;\n\t}\n\n\tif (channel)\n\t\tpriv->config |= CFG_STATIC_CHANNEL;\n\telse\n\t\tpriv->config &= ~CFG_STATIC_CHANNEL;\n\n\tpriv->channel = channel;\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_enable_adapter(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int ipw2100_system_config(struct ipw2100_priv *priv, int batch_mode)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = SYSTEM_CONFIG,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 12,\n\t};\n\tu32 ibss_mask, len = sizeof(u32);\n\tint err;\n\n\t \n\n\tif (!batch_mode) {\n\t\terr = ipw2100_disable_adapter(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (priv->ieee->iw_mode == IW_MODE_ADHOC)\n\t\tcmd.host_command_parameters[0] |= IPW_CFG_IBSS_AUTO_START;\n\n\tcmd.host_command_parameters[0] |= IPW_CFG_IBSS_MASK |\n\t    IPW_CFG_BSS_MASK | IPW_CFG_802_1x_ENABLE;\n\n\tif (!(priv->config & CFG_LONG_PREAMBLE))\n\t\tcmd.host_command_parameters[0] |= IPW_CFG_PREAMBLE_AUTO;\n\n\terr = ipw2100_get_ordinal(priv,\n\t\t\t\t  IPW_ORD_EEPROM_IBSS_11B_CHANNELS,\n\t\t\t\t  &ibss_mask, &len);\n\tif (err)\n\t\tibss_mask = IPW_IBSS_11B_DEFAULT_MASK;\n\n\tcmd.host_command_parameters[1] = REG_CHANNEL_MASK;\n\tcmd.host_command_parameters[2] = REG_CHANNEL_MASK & ibss_mask;\n\n\t \n\t \n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\tif (err)\n\t\treturn err;\n\n \n#if !defined(CONFIG_IPV6) && !defined(CONFIG_IPV6_MODULE)\n\tcmd.host_command = ADD_MULTICAST;\n\tcmd.host_command_sequence = 0;\n\tcmd.host_command_length = 0;\n\n\tipw2100_hw_send_command(priv, &cmd);\n#endif\n\tif (!batch_mode) {\n\t\terr = ipw2100_enable_adapter(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int ipw2100_set_tx_rates(struct ipw2100_priv *priv, u32 rate,\n\t\t\t\tint batch_mode)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = BASIC_TX_RATES,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 4\n\t};\n\tint err;\n\n\tcmd.host_command_parameters[0] = rate & TX_RATE_MASK;\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_disable_adapter(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tipw2100_hw_send_command(priv, &cmd);\n\n\t \n\tcmd.host_command = TX_RATES;\n\tipw2100_hw_send_command(priv, &cmd);\n\n\t \n\tcmd.host_command = MSDU_TX_RATES;\n\tipw2100_hw_send_command(priv, &cmd);\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_enable_adapter(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tpriv->tx_rates = rate;\n\n\treturn 0;\n}\n\nstatic int ipw2100_set_power_mode(struct ipw2100_priv *priv, int power_level)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = POWER_MODE,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 4\n\t};\n\tint err;\n\n\tcmd.host_command_parameters[0] = power_level;\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\tif (err)\n\t\treturn err;\n\n\tif (power_level == IPW_POWER_MODE_CAM)\n\t\tpriv->power_mode = IPW_POWER_LEVEL(priv->power_mode);\n\telse\n\t\tpriv->power_mode = IPW_POWER_ENABLED | power_level;\n\n#ifdef IPW2100_TX_POWER\n\tif (priv->port_type == IBSS && priv->adhoc_power != DFTL_IBSS_TX_POWER) {\n\t\t \n\t\tcmd.host_command = TX_POWER_INDEX;\n\t\tcmd.host_command_parameters[0] = (u32) priv->adhoc_power;\n\n\t\terr = ipw2100_hw_send_command(priv, &cmd);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n#endif\n\n\treturn 0;\n}\n\nstatic int ipw2100_set_rts_threshold(struct ipw2100_priv *priv, u32 threshold)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = RTS_THRESHOLD,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 4\n\t};\n\tint err;\n\n\tif (threshold & RTS_DISABLED)\n\t\tcmd.host_command_parameters[0] = MAX_RTS_THRESHOLD;\n\telse\n\t\tcmd.host_command_parameters[0] = threshold & ~RTS_DISABLED;\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\tif (err)\n\t\treturn err;\n\n\tpriv->rts_threshold = threshold;\n\n\treturn 0;\n}\n\n#if 0\nint ipw2100_set_fragmentation_threshold(struct ipw2100_priv *priv,\n\t\t\t\t\tu32 threshold, int batch_mode)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = FRAG_THRESHOLD,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 4,\n\t\t.host_command_parameters[0] = 0,\n\t};\n\tint err;\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_disable_adapter(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (threshold == 0)\n\t\tthreshold = DEFAULT_FRAG_THRESHOLD;\n\telse {\n\t\tthreshold = max(threshold, MIN_FRAG_THRESHOLD);\n\t\tthreshold = min(threshold, MAX_FRAG_THRESHOLD);\n\t}\n\n\tcmd.host_command_parameters[0] = threshold;\n\n\tIPW_DEBUG_HC(\"FRAG_THRESHOLD: %u\\n\", threshold);\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\n\tif (!batch_mode)\n\t\tipw2100_enable_adapter(priv);\n\n\tif (!err)\n\t\tpriv->frag_threshold = threshold;\n\n\treturn err;\n}\n#endif\n\nstatic int ipw2100_set_short_retry(struct ipw2100_priv *priv, u32 retry)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = SHORT_RETRY_LIMIT,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 4\n\t};\n\tint err;\n\n\tcmd.host_command_parameters[0] = retry;\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\tif (err)\n\t\treturn err;\n\n\tpriv->short_retry_limit = retry;\n\n\treturn 0;\n}\n\nstatic int ipw2100_set_long_retry(struct ipw2100_priv *priv, u32 retry)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = LONG_RETRY_LIMIT,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 4\n\t};\n\tint err;\n\n\tcmd.host_command_parameters[0] = retry;\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\tif (err)\n\t\treturn err;\n\n\tpriv->long_retry_limit = retry;\n\n\treturn 0;\n}\n\nstatic int ipw2100_set_mandatory_bssid(struct ipw2100_priv *priv, u8 * bssid,\n\t\t\t\t       int batch_mode)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = MANDATORY_BSSID,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = (bssid == NULL) ? 0 : ETH_ALEN\n\t};\n\tint err;\n\n#ifdef CONFIG_IPW2100_DEBUG\n\tif (bssid != NULL)\n\t\tIPW_DEBUG_HC(\"MANDATORY_BSSID: %pM\\n\", bssid);\n\telse\n\t\tIPW_DEBUG_HC(\"MANDATORY_BSSID: <clear>\\n\");\n#endif\n\t \n\tif (bssid != NULL)\n\t\tmemcpy(cmd.host_command_parameters, bssid, ETH_ALEN);\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_disable_adapter(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\n\tif (!batch_mode)\n\t\tipw2100_enable_adapter(priv);\n\n\treturn err;\n}\n\nstatic int ipw2100_disassociate_bssid(struct ipw2100_priv *priv)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = DISASSOCIATION_BSSID,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = ETH_ALEN\n\t};\n\tint err;\n\n\tIPW_DEBUG_HC(\"DISASSOCIATION_BSSID\\n\");\n\n\t \n\tmemcpy(cmd.host_command_parameters, priv->bssid, ETH_ALEN);\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\n\treturn err;\n}\n\nstatic int ipw2100_set_wpa_ie(struct ipw2100_priv *,\n\t\t\t      struct ipw2100_wpa_assoc_frame *, int)\n    __attribute__ ((unused));\n\nstatic int ipw2100_set_wpa_ie(struct ipw2100_priv *priv,\n\t\t\t      struct ipw2100_wpa_assoc_frame *wpa_frame,\n\t\t\t      int batch_mode)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = SET_WPA_IE,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = sizeof(struct ipw2100_wpa_assoc_frame),\n\t};\n\tint err;\n\n\tIPW_DEBUG_HC(\"SET_WPA_IE\\n\");\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_disable_adapter(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tmemcpy(cmd.host_command_parameters, wpa_frame,\n\t       sizeof(struct ipw2100_wpa_assoc_frame));\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\n\tif (!batch_mode) {\n\t\tif (ipw2100_enable_adapter(priv))\n\t\t\terr = -EIO;\n\t}\n\n\treturn err;\n}\n\nstruct security_info_params {\n\tu32 allowed_ciphers;\n\tu16 version;\n\tu8 auth_mode;\n\tu8 replay_counters_number;\n\tu8 unicast_using_group;\n} __packed;\n\nstatic int ipw2100_set_security_information(struct ipw2100_priv *priv,\n\t\t\t\t\t    int auth_mode,\n\t\t\t\t\t    int security_level,\n\t\t\t\t\t    int unicast_using_group,\n\t\t\t\t\t    int batch_mode)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = SET_SECURITY_INFORMATION,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = sizeof(struct security_info_params)\n\t};\n\tstruct security_info_params *security =\n\t    (struct security_info_params *)&cmd.host_command_parameters;\n\tint err;\n\tmemset(security, 0, sizeof(*security));\n\n\t \n\tsecurity->auth_mode = auth_mode;\n\tsecurity->unicast_using_group = unicast_using_group;\n\n\tswitch (security_level) {\n\tdefault:\n\tcase SEC_LEVEL_0:\n\t\tsecurity->allowed_ciphers = IPW_NONE_CIPHER;\n\t\tbreak;\n\tcase SEC_LEVEL_1:\n\t\tsecurity->allowed_ciphers = IPW_WEP40_CIPHER |\n\t\t    IPW_WEP104_CIPHER;\n\t\tbreak;\n\tcase SEC_LEVEL_2:\n\t\tsecurity->allowed_ciphers = IPW_WEP40_CIPHER |\n\t\t    IPW_WEP104_CIPHER | IPW_TKIP_CIPHER;\n\t\tbreak;\n\tcase SEC_LEVEL_2_CKIP:\n\t\tsecurity->allowed_ciphers = IPW_WEP40_CIPHER |\n\t\t    IPW_WEP104_CIPHER | IPW_CKIP_CIPHER;\n\t\tbreak;\n\tcase SEC_LEVEL_3:\n\t\tsecurity->allowed_ciphers = IPW_WEP40_CIPHER |\n\t\t    IPW_WEP104_CIPHER | IPW_TKIP_CIPHER | IPW_CCMP_CIPHER;\n\t\tbreak;\n\t}\n\n\tIPW_DEBUG_HC\n\t    (\"SET_SECURITY_INFORMATION: auth:%d cipher:0x%02X (level %d)\\n\",\n\t     security->auth_mode, security->allowed_ciphers, security_level);\n\n\tsecurity->replay_counters_number = 0;\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_disable_adapter(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = ipw2100_hw_send_command(priv, &cmd);\n\n\tif (!batch_mode)\n\t\tipw2100_enable_adapter(priv);\n\n\treturn err;\n}\n\nstatic int ipw2100_set_tx_power(struct ipw2100_priv *priv, u32 tx_power)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = TX_POWER_INDEX,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 4\n\t};\n\tint err = 0;\n\tu32 tmp = tx_power;\n\n\tif (tx_power != IPW_TX_POWER_DEFAULT)\n\t\ttmp = (tx_power - IPW_TX_POWER_MIN_DBM) * 16 /\n\t\t      (IPW_TX_POWER_MAX_DBM - IPW_TX_POWER_MIN_DBM);\n\n\tcmd.host_command_parameters[0] = tmp;\n\n\tif (priv->ieee->iw_mode == IW_MODE_ADHOC)\n\t\terr = ipw2100_hw_send_command(priv, &cmd);\n\tif (!err)\n\t\tpriv->tx_power = tx_power;\n\n\treturn 0;\n}\n\nstatic int ipw2100_set_ibss_beacon_interval(struct ipw2100_priv *priv,\n\t\t\t\t\t    u32 interval, int batch_mode)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = BEACON_INTERVAL,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 4\n\t};\n\tint err;\n\n\tcmd.host_command_parameters[0] = interval;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tif (priv->ieee->iw_mode == IW_MODE_ADHOC) {\n\t\tif (!batch_mode) {\n\t\t\terr = ipw2100_disable_adapter(priv);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tipw2100_hw_send_command(priv, &cmd);\n\n\t\tif (!batch_mode) {\n\t\t\terr = ipw2100_enable_adapter(priv);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n\n\treturn 0;\n}\n\nstatic void ipw2100_queues_initialize(struct ipw2100_priv *priv)\n{\n\tipw2100_tx_initialize(priv);\n\tipw2100_rx_initialize(priv);\n\tipw2100_msg_initialize(priv);\n}\n\nstatic void ipw2100_queues_free(struct ipw2100_priv *priv)\n{\n\tipw2100_tx_free(priv);\n\tipw2100_rx_free(priv);\n\tipw2100_msg_free(priv);\n}\n\nstatic int ipw2100_queues_allocate(struct ipw2100_priv *priv)\n{\n\tif (ipw2100_tx_allocate(priv) ||\n\t    ipw2100_rx_allocate(priv) || ipw2100_msg_allocate(priv))\n\t\tgoto fail;\n\n\treturn 0;\n\n      fail:\n\tipw2100_tx_free(priv);\n\tipw2100_rx_free(priv);\n\tipw2100_msg_free(priv);\n\treturn -ENOMEM;\n}\n\n#define IPW_PRIVACY_CAPABLE 0x0008\n\nstatic int ipw2100_set_wep_flags(struct ipw2100_priv *priv, u32 flags,\n\t\t\t\t int batch_mode)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = WEP_FLAGS,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 4\n\t};\n\tint err;\n\n\tcmd.host_command_parameters[0] = flags;\n\n\tIPW_DEBUG_HC(\"WEP_FLAGS: flags = 0x%08X\\n\", flags);\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_disable_adapter(priv);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR DRV_NAME\n\t\t\t       \": %s: Could not disable adapter %d\\n\",\n\t\t\t       priv->net_dev->name, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\terr = ipw2100_hw_send_command(priv, &cmd);\n\n\tif (!batch_mode)\n\t\tipw2100_enable_adapter(priv);\n\n\treturn err;\n}\n\nstruct ipw2100_wep_key {\n\tu8 idx;\n\tu8 len;\n\tu8 key[13];\n};\n\n \n#define WEP_FMT_64  \"%02X%02X%02X%02X-%02X\"\n#define WEP_FMT_128 \"%02X%02X%02X%02X-%02X%02X%02X%02X-%02X%02X%02X\"\n#define WEP_STR_64(x) x[0],x[1],x[2],x[3],x[4]\n#define WEP_STR_128(x) x[0],x[1],x[2],x[3],x[4],x[5],x[6],x[7],x[8],x[9],x[10]\n\n \nstatic int ipw2100_set_key(struct ipw2100_priv *priv,\n\t\t\t   int idx, char *key, int len, int batch_mode)\n{\n\tint keylen = len ? (len <= 5 ? 5 : 13) : 0;\n\tstruct host_command cmd = {\n\t\t.host_command = WEP_KEY_INFO,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = sizeof(struct ipw2100_wep_key),\n\t};\n\tstruct ipw2100_wep_key *wep_key = (void *)cmd.host_command_parameters;\n\tint err;\n\n\tIPW_DEBUG_HC(\"WEP_KEY_INFO: index = %d, len = %d/%d\\n\",\n\t\t     idx, keylen, len);\n\n\t \n\n\twep_key->idx = idx;\n\twep_key->len = keylen;\n\n\tif (keylen) {\n\t\tmemcpy(wep_key->key, key, len);\n\t\tmemset(wep_key->key + len, 0, keylen - len);\n\t}\n\n\t \n\tif (keylen == 0)\n\t\tIPW_DEBUG_WEP(\"%s: Clearing key %d\\n\",\n\t\t\t      priv->net_dev->name, wep_key->idx);\n\telse if (keylen == 5)\n\t\tIPW_DEBUG_WEP(\"%s: idx: %d, len: %d key: \" WEP_FMT_64 \"\\n\",\n\t\t\t      priv->net_dev->name, wep_key->idx, wep_key->len,\n\t\t\t      WEP_STR_64(wep_key->key));\n\telse\n\t\tIPW_DEBUG_WEP(\"%s: idx: %d, len: %d key: \" WEP_FMT_128\n\t\t\t      \"\\n\",\n\t\t\t      priv->net_dev->name, wep_key->idx, wep_key->len,\n\t\t\t      WEP_STR_128(wep_key->key));\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_disable_adapter(priv);\n\t\t \n\t\tif (err) {\n\t\t\tprintk(KERN_ERR DRV_NAME\n\t\t\t       \": %s: Could not disable adapter %d\\n\",\n\t\t\t       priv->net_dev->name, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\terr = ipw2100_hw_send_command(priv, &cmd);\n\n\tif (!batch_mode) {\n\t\tint err2 = ipw2100_enable_adapter(priv);\n\t\tif (err == 0)\n\t\t\terr = err2;\n\t}\n\treturn err;\n}\n\nstatic int ipw2100_set_key_index(struct ipw2100_priv *priv,\n\t\t\t\t int idx, int batch_mode)\n{\n\tstruct host_command cmd = {\n\t\t.host_command = WEP_KEY_INDEX,\n\t\t.host_command_sequence = 0,\n\t\t.host_command_length = 4,\n\t\t.host_command_parameters = {idx},\n\t};\n\tint err;\n\n\tIPW_DEBUG_HC(\"WEP_KEY_INDEX: index = %d\\n\", idx);\n\n\tif (idx < 0 || idx > 3)\n\t\treturn -EINVAL;\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_disable_adapter(priv);\n\t\tif (err) {\n\t\t\tprintk(KERN_ERR DRV_NAME\n\t\t\t       \": %s: Could not disable adapter %d\\n\",\n\t\t\t       priv->net_dev->name, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\terr = ipw2100_hw_send_command(priv, &cmd);\n\n\tif (!batch_mode)\n\t\tipw2100_enable_adapter(priv);\n\n\treturn err;\n}\n\nstatic int ipw2100_configure_security(struct ipw2100_priv *priv, int batch_mode)\n{\n\tint i, err, auth_mode, sec_level, use_group;\n\n\tif (!(priv->status & STATUS_RUNNING))\n\t\treturn 0;\n\n\tif (!batch_mode) {\n\t\terr = ipw2100_disable_adapter(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!priv->ieee->sec.enabled) {\n\t\terr =\n\t\t    ipw2100_set_security_information(priv, IPW_AUTH_OPEN,\n\t\t\t\t\t\t     SEC_LEVEL_0, 0, 1);\n\t} else {\n\t\tauth_mode = IPW_AUTH_OPEN;\n\t\tif (priv->ieee->sec.flags & SEC_AUTH_MODE) {\n\t\t\tif (priv->ieee->sec.auth_mode == WLAN_AUTH_SHARED_KEY)\n\t\t\t\tauth_mode = IPW_AUTH_SHARED;\n\t\t\telse if (priv->ieee->sec.auth_mode == WLAN_AUTH_LEAP)\n\t\t\t\tauth_mode = IPW_AUTH_LEAP_CISCO_ID;\n\t\t}\n\n\t\tsec_level = SEC_LEVEL_0;\n\t\tif (priv->ieee->sec.flags & SEC_LEVEL)\n\t\t\tsec_level = priv->ieee->sec.level;\n\n\t\tuse_group = 0;\n\t\tif (priv->ieee->sec.flags & SEC_UNICAST_GROUP)\n\t\t\tuse_group = priv->ieee->sec.unicast_uses_group;\n\n\t\terr =\n\t\t    ipw2100_set_security_information(priv, auth_mode, sec_level,\n\t\t\t\t\t\t     use_group, 1);\n\t}\n\n\tif (err)\n\t\tgoto exit;\n\n\tif (priv->ieee->sec.enabled) {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (!(priv->ieee->sec.flags & (1 << i))) {\n\t\t\t\tmemset(priv->ieee->sec.keys[i], 0, WEP_KEY_LEN);\n\t\t\t\tpriv->ieee->sec.key_sizes[i] = 0;\n\t\t\t} else {\n\t\t\t\terr = ipw2100_set_key(priv, i,\n\t\t\t\t\t\t      priv->ieee->sec.keys[i],\n\t\t\t\t\t\t      priv->ieee->sec.\n\t\t\t\t\t\t      key_sizes[i], 1);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tipw2100_set_key_index(priv, priv->ieee->crypt_info.tx_keyidx, 1);\n\t}\n\n\t \n\terr =\n\t    ipw2100_set_wep_flags(priv,\n\t\t\t\t  priv->ieee->sec.\n\t\t\t\t  enabled ? IPW_PRIVACY_CAPABLE : 0, 1);\n\tif (err)\n\t\tgoto exit;\n\n\tpriv->status &= ~STATUS_SECURITY_UPDATED;\n\n      exit:\n\tif (!batch_mode)\n\t\tipw2100_enable_adapter(priv);\n\n\treturn err;\n}\n\nstatic void ipw2100_security_work(struct work_struct *work)\n{\n\tstruct ipw2100_priv *priv =\n\t\tcontainer_of(work, struct ipw2100_priv, security_work.work);\n\n\t \n\tif (!(priv->status & STATUS_ASSOCIATED) &&\n\t    priv->status & STATUS_SECURITY_UPDATED)\n\t\tipw2100_configure_security(priv, 0);\n}\n\nstatic void shim__set_security(struct net_device *dev,\n\t\t\t       struct libipw_security *sec)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint i;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED))\n\t\tgoto done;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (sec->flags & (1 << i)) {\n\t\t\tpriv->ieee->sec.key_sizes[i] = sec->key_sizes[i];\n\t\t\tif (sec->key_sizes[i] == 0)\n\t\t\t\tpriv->ieee->sec.flags &= ~(1 << i);\n\t\t\telse\n\t\t\t\tmemcpy(priv->ieee->sec.keys[i], sec->keys[i],\n\t\t\t\t       sec->key_sizes[i]);\n\t\t\tif (sec->level == SEC_LEVEL_1) {\n\t\t\t\tpriv->ieee->sec.flags |= (1 << i);\n\t\t\t\tpriv->status |= STATUS_SECURITY_UPDATED;\n\t\t\t} else\n\t\t\t\tpriv->ieee->sec.flags &= ~(1 << i);\n\t\t}\n\t}\n\n\tif ((sec->flags & SEC_ACTIVE_KEY) &&\n\t    priv->ieee->sec.active_key != sec->active_key) {\n\t\tpriv->ieee->sec.active_key = sec->active_key;\n\t\tpriv->ieee->sec.flags |= SEC_ACTIVE_KEY;\n\t\tpriv->status |= STATUS_SECURITY_UPDATED;\n\t}\n\n\tif ((sec->flags & SEC_AUTH_MODE) &&\n\t    (priv->ieee->sec.auth_mode != sec->auth_mode)) {\n\t\tpriv->ieee->sec.auth_mode = sec->auth_mode;\n\t\tpriv->ieee->sec.flags |= SEC_AUTH_MODE;\n\t\tpriv->status |= STATUS_SECURITY_UPDATED;\n\t}\n\n\tif (sec->flags & SEC_ENABLED && priv->ieee->sec.enabled != sec->enabled) {\n\t\tpriv->ieee->sec.flags |= SEC_ENABLED;\n\t\tpriv->ieee->sec.enabled = sec->enabled;\n\t\tpriv->status |= STATUS_SECURITY_UPDATED;\n\t}\n\n\tif (sec->flags & SEC_ENCRYPT)\n\t\tpriv->ieee->sec.encrypt = sec->encrypt;\n\n\tif (sec->flags & SEC_LEVEL && priv->ieee->sec.level != sec->level) {\n\t\tpriv->ieee->sec.level = sec->level;\n\t\tpriv->ieee->sec.flags |= SEC_LEVEL;\n\t\tpriv->status |= STATUS_SECURITY_UPDATED;\n\t}\n\n\tIPW_DEBUG_WEP(\"Security flags: %c %c%c%c%c %c%c%c%c\\n\",\n\t\t      priv->ieee->sec.flags & (1 << 8) ? '1' : '0',\n\t\t      priv->ieee->sec.flags & (1 << 7) ? '1' : '0',\n\t\t      priv->ieee->sec.flags & (1 << 6) ? '1' : '0',\n\t\t      priv->ieee->sec.flags & (1 << 5) ? '1' : '0',\n\t\t      priv->ieee->sec.flags & (1 << 4) ? '1' : '0',\n\t\t      priv->ieee->sec.flags & (1 << 3) ? '1' : '0',\n\t\t      priv->ieee->sec.flags & (1 << 2) ? '1' : '0',\n\t\t      priv->ieee->sec.flags & (1 << 1) ? '1' : '0',\n\t\t      priv->ieee->sec.flags & (1 << 0) ? '1' : '0');\n\n \n\tif (!(priv->status & (STATUS_ASSOCIATED | STATUS_ASSOCIATING)))\n\t\tipw2100_configure_security(priv, 0);\n      done:\n\tmutex_unlock(&priv->action_mutex);\n}\n\nstatic int ipw2100_adapter_setup(struct ipw2100_priv *priv)\n{\n\tint err;\n\tint batch_mode = 1;\n\tu8 *bssid;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\terr = ipw2100_disable_adapter(priv);\n\tif (err)\n\t\treturn err;\n#ifdef CONFIG_IPW2100_MONITOR\n\tif (priv->ieee->iw_mode == IW_MODE_MONITOR) {\n\t\terr = ipw2100_set_channel(priv, priv->channel, batch_mode);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tIPW_DEBUG_INFO(\"exit\\n\");\n\n\t\treturn 0;\n\t}\n#endif\t\t\t\t \n\n\terr = ipw2100_read_mac_address(priv);\n\tif (err)\n\t\treturn -EIO;\n\n\terr = ipw2100_set_mac_address(priv, batch_mode);\n\tif (err)\n\t\treturn err;\n\n\terr = ipw2100_set_port_type(priv, priv->ieee->iw_mode, batch_mode);\n\tif (err)\n\t\treturn err;\n\n\tif (priv->ieee->iw_mode == IW_MODE_ADHOC) {\n\t\terr = ipw2100_set_channel(priv, priv->channel, batch_mode);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\terr = ipw2100_system_config(priv, batch_mode);\n\tif (err)\n\t\treturn err;\n\n\terr = ipw2100_set_tx_rates(priv, priv->tx_rates, batch_mode);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = ipw2100_set_power_mode(priv, IPW_POWER_MODE_CAM);\n\tif (err)\n\t\treturn err;\n\n\terr = ipw2100_set_rts_threshold(priv, priv->rts_threshold);\n\tif (err)\n\t\treturn err;\n\n\tif (priv->config & CFG_STATIC_BSSID)\n\t\tbssid = priv->bssid;\n\telse\n\t\tbssid = NULL;\n\terr = ipw2100_set_mandatory_bssid(priv, bssid, batch_mode);\n\tif (err)\n\t\treturn err;\n\n\tif (priv->config & CFG_STATIC_ESSID)\n\t\terr = ipw2100_set_essid(priv, priv->essid, priv->essid_len,\n\t\t\t\t\tbatch_mode);\n\telse\n\t\terr = ipw2100_set_essid(priv, NULL, 0, batch_mode);\n\tif (err)\n\t\treturn err;\n\n\terr = ipw2100_configure_security(priv, batch_mode);\n\tif (err)\n\t\treturn err;\n\n\tif (priv->ieee->iw_mode == IW_MODE_ADHOC) {\n\t\terr =\n\t\t    ipw2100_set_ibss_beacon_interval(priv,\n\t\t\t\t\t\t     priv->beacon_interval,\n\t\t\t\t\t\t     batch_mode);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = ipw2100_set_tx_power(priv, priv->tx_power);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n\n\treturn 0;\n}\n\n \n\n \nstatic int ipw2100_set_address(struct net_device *dev, void *p)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tstruct sockaddr *addr = p;\n\tint err = 0;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tmutex_lock(&priv->action_mutex);\n\n\tpriv->config |= CFG_CUSTOM_MAC;\n\tmemcpy(priv->mac_addr, addr->sa_data, ETH_ALEN);\n\n\terr = ipw2100_set_mac_address(priv, 0);\n\tif (err)\n\t\tgoto done;\n\n\tpriv->reset_backoff = 0;\n\tmutex_unlock(&priv->action_mutex);\n\tipw2100_reset_adapter(&priv->reset_work.work);\n\treturn 0;\n\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_open(struct net_device *dev)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tunsigned long flags;\n\tIPW_DEBUG_INFO(\"dev->open\\n\");\n\n\tspin_lock_irqsave(&priv->low_lock, flags);\n\tif (priv->status & STATUS_ASSOCIATED) {\n\t\tnetif_carrier_on(dev);\n\t\tnetif_start_queue(dev);\n\t}\n\tspin_unlock_irqrestore(&priv->low_lock, flags);\n\n\treturn 0;\n}\n\nstatic int ipw2100_close(struct net_device *dev)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tunsigned long flags;\n\tstruct list_head *element;\n\tstruct ipw2100_tx_packet *packet;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tspin_lock_irqsave(&priv->low_lock, flags);\n\n\tif (priv->status & STATUS_ASSOCIATED)\n\t\tnetif_carrier_off(dev);\n\tnetif_stop_queue(dev);\n\n\t \n\twhile (!list_empty(&priv->tx_pend_list)) {\n\t\telement = priv->tx_pend_list.next;\n\t\tpacket = list_entry(element, struct ipw2100_tx_packet, list);\n\n\t\tlist_del(element);\n\t\tDEC_STAT(&priv->tx_pend_stat);\n\n\t\tlibipw_txb_free(packet->info.d_struct.txb);\n\t\tpacket->info.d_struct.txb = NULL;\n\n\t\tlist_add_tail(element, &priv->tx_free_list);\n\t\tINC_STAT(&priv->tx_free_stat);\n\t}\n\tspin_unlock_irqrestore(&priv->low_lock, flags);\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n\n\treturn 0;\n}\n\n \nstatic void ipw2100_tx_timeout(struct net_device *dev, unsigned int txqueue)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\tdev->stats.tx_errors++;\n\n#ifdef CONFIG_IPW2100_MONITOR\n\tif (priv->ieee->iw_mode == IW_MODE_MONITOR)\n\t\treturn;\n#endif\n\n\tIPW_DEBUG_INFO(\"%s: TX timed out.  Scheduling firmware restart.\\n\",\n\t\t       dev->name);\n\tschedule_reset(priv);\n}\n\nstatic int ipw2100_wpa_enable(struct ipw2100_priv *priv, int value)\n{\n\t \n\tpriv->ieee->wpa_enabled = value;\n\treturn 0;\n}\n\nstatic int ipw2100_wpa_set_auth_algs(struct ipw2100_priv *priv, int value)\n{\n\n\tstruct libipw_device *ieee = priv->ieee;\n\tstruct libipw_security sec = {\n\t\t.flags = SEC_AUTH_MODE,\n\t};\n\tint ret = 0;\n\n\tif (value & IW_AUTH_ALG_SHARED_KEY) {\n\t\tsec.auth_mode = WLAN_AUTH_SHARED_KEY;\n\t\tieee->open_wep = 0;\n\t} else if (value & IW_AUTH_ALG_OPEN_SYSTEM) {\n\t\tsec.auth_mode = WLAN_AUTH_OPEN;\n\t\tieee->open_wep = 1;\n\t} else if (value & IW_AUTH_ALG_LEAP) {\n\t\tsec.auth_mode = WLAN_AUTH_LEAP;\n\t\tieee->open_wep = 1;\n\t} else\n\t\treturn -EINVAL;\n\n\tif (ieee->set_security)\n\t\tieee->set_security(ieee->dev, &sec);\n\telse\n\t\tret = -EOPNOTSUPP;\n\n\treturn ret;\n}\n\nstatic void ipw2100_wpa_assoc_frame(struct ipw2100_priv *priv,\n\t\t\t\t    char *wpa_ie, int wpa_ie_len)\n{\n\n\tstruct ipw2100_wpa_assoc_frame frame;\n\n\tframe.fixed_ie_mask = 0;\n\n\t \n\tmemcpy(frame.var_ie, wpa_ie, wpa_ie_len);\n\tframe.var_ie_len = wpa_ie_len;\n\n\t \n\tipw2100_wpa_enable(priv, 1);\n\tipw2100_set_wpa_ie(priv, &frame, 0);\n}\n\nstatic void ipw_ethtool_get_drvinfo(struct net_device *dev,\n\t\t\t\t    struct ethtool_drvinfo *info)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tchar fw_ver[64], ucode_ver[64];\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n\n\tipw2100_get_fwversion(priv, fw_ver, sizeof(fw_ver));\n\tipw2100_get_ucodeversion(priv, ucode_ver, sizeof(ucode_ver));\n\n\tsnprintf(info->fw_version, sizeof(info->fw_version), \"%s:%d:%s\",\n\t\t fw_ver, priv->eeprom_version, ucode_ver);\n\n\tstrscpy(info->bus_info, pci_name(priv->pci_dev),\n\t\tsizeof(info->bus_info));\n}\n\nstatic u32 ipw2100_ethtool_get_link(struct net_device *dev)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\treturn (priv->status & STATUS_ASSOCIATED) ? 1 : 0;\n}\n\nstatic const struct ethtool_ops ipw2100_ethtool_ops = {\n\t.get_link = ipw2100_ethtool_get_link,\n\t.get_drvinfo = ipw_ethtool_get_drvinfo,\n};\n\nstatic void ipw2100_hang_check(struct work_struct *work)\n{\n\tstruct ipw2100_priv *priv =\n\t\tcontainer_of(work, struct ipw2100_priv, hang_check.work);\n\tunsigned long flags;\n\tu32 rtc = 0xa5a5a5a5;\n\tu32 len = sizeof(rtc);\n\tint restart = 0;\n\n\tspin_lock_irqsave(&priv->low_lock, flags);\n\n\tif (priv->fatal_error != 0) {\n\t\t \n\t\tIPW_DEBUG_INFO(\"%s: Hardware fatal error detected.\\n\",\n\t\t\t       priv->net_dev->name);\n\n\t\trestart = 1;\n\t} else if (ipw2100_get_ordinal(priv, IPW_ORD_RTC_TIME, &rtc, &len) ||\n\t\t   (rtc == priv->last_rtc)) {\n\t\t \n\t\tIPW_DEBUG_INFO(\"%s: Firmware RTC stalled.\\n\",\n\t\t\t       priv->net_dev->name);\n\n\t\trestart = 1;\n\t}\n\n\tif (restart) {\n\t\t \n\t\tpriv->stop_hang_check = 1;\n\t\tpriv->hangs++;\n\n\t\t \n\t\tschedule_reset(priv);\n\t}\n\n\tpriv->last_rtc = rtc;\n\n\tif (!priv->stop_hang_check)\n\t\tschedule_delayed_work(&priv->hang_check, HZ / 2);\n\n\tspin_unlock_irqrestore(&priv->low_lock, flags);\n}\n\nstatic void ipw2100_rf_kill(struct work_struct *work)\n{\n\tstruct ipw2100_priv *priv =\n\t\tcontainer_of(work, struct ipw2100_priv, rf_kill.work);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->low_lock, flags);\n\n\tif (rf_kill_active(priv)) {\n\t\tIPW_DEBUG_RF_KILL(\"RF Kill active, rescheduling GPIO check\\n\");\n\t\tif (!priv->stop_rf_kill)\n\t\t\tschedule_delayed_work(&priv->rf_kill,\n\t\t\t\t\t      round_jiffies_relative(HZ));\n\t\tgoto exit_unlock;\n\t}\n\n\t \n\n\tif (!(priv->status & STATUS_RF_KILL_MASK)) {\n\t\tIPW_DEBUG_RF_KILL(\"HW RF Kill no longer active, restarting \"\n\t\t\t\t  \"device\\n\");\n\t\tschedule_reset(priv);\n\t} else\n\t\tIPW_DEBUG_RF_KILL(\"HW RF Kill deactivated.  SW RF Kill still \"\n\t\t\t\t  \"enabled\\n\");\n\n      exit_unlock:\n\tspin_unlock_irqrestore(&priv->low_lock, flags);\n}\n\nstatic void ipw2100_irq_tasklet(struct tasklet_struct *t);\n\nstatic const struct net_device_ops ipw2100_netdev_ops = {\n\t.ndo_open\t\t= ipw2100_open,\n\t.ndo_stop\t\t= ipw2100_close,\n\t.ndo_start_xmit\t\t= libipw_xmit,\n\t.ndo_tx_timeout\t\t= ipw2100_tx_timeout,\n\t.ndo_set_mac_address\t= ipw2100_set_address,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\n \n\nstatic struct net_device *ipw2100_alloc_device(struct pci_dev *pci_dev,\n\t\t\t\t\t       void __iomem * ioaddr)\n{\n\tstruct ipw2100_priv *priv;\n\tstruct net_device *dev;\n\n\tdev = alloc_libipw(sizeof(struct ipw2100_priv), 0);\n\tif (!dev)\n\t\treturn NULL;\n\tpriv = libipw_priv(dev);\n\tpriv->ieee = netdev_priv(dev);\n\tpriv->pci_dev = pci_dev;\n\tpriv->net_dev = dev;\n\tpriv->ioaddr = ioaddr;\n\n\tpriv->ieee->hard_start_xmit = ipw2100_tx;\n\tpriv->ieee->set_security = shim__set_security;\n\n\tpriv->ieee->perfect_rssi = -20;\n\tpriv->ieee->worst_rssi = -85;\n\n\tdev->netdev_ops = &ipw2100_netdev_ops;\n\tdev->ethtool_ops = &ipw2100_ethtool_ops;\n\tdev->wireless_handlers = &ipw2100_wx_handler_def;\n\tpriv->wireless_data.libipw = priv->ieee;\n\tdev->wireless_data = &priv->wireless_data;\n\tdev->watchdog_timeo = 3 * HZ;\n\tdev->irq = 0;\n\tdev->min_mtu = 68;\n\tdev->max_mtu = LIBIPW_DATA_LEN;\n\n\t \n\n\t \n\n\t \n\tpriv->power_mode = IPW_POWER_AUTO;\n\n#ifdef CONFIG_IPW2100_MONITOR\n\tpriv->config |= CFG_CRC_CHECK;\n#endif\n\tpriv->ieee->wpa_enabled = 0;\n\tpriv->ieee->drop_unencrypted = 0;\n\tpriv->ieee->privacy_invoked = 0;\n\tpriv->ieee->ieee802_1x = 1;\n\n\t \n\tswitch (network_mode) {\n\tcase 1:\n\t\tpriv->ieee->iw_mode = IW_MODE_ADHOC;\n\t\tbreak;\n#ifdef CONFIG_IPW2100_MONITOR\n\tcase 2:\n\t\tpriv->ieee->iw_mode = IW_MODE_MONITOR;\n\t\tbreak;\n#endif\n\tdefault:\n\tcase 0:\n\t\tpriv->ieee->iw_mode = IW_MODE_INFRA;\n\t\tbreak;\n\t}\n\n\tif (disable == 1)\n\t\tpriv->status |= STATUS_RF_KILL_SW;\n\n\tif (channel != 0 &&\n\t    ((channel >= REG_MIN_CHANNEL) && (channel <= REG_MAX_CHANNEL))) {\n\t\tpriv->config |= CFG_STATIC_CHANNEL;\n\t\tpriv->channel = channel;\n\t}\n\n\tif (associate)\n\t\tpriv->config |= CFG_ASSOCIATE;\n\n\tpriv->beacon_interval = DEFAULT_BEACON_INTERVAL;\n\tpriv->short_retry_limit = DEFAULT_SHORT_RETRY_LIMIT;\n\tpriv->long_retry_limit = DEFAULT_LONG_RETRY_LIMIT;\n\tpriv->rts_threshold = DEFAULT_RTS_THRESHOLD | RTS_DISABLED;\n\tpriv->frag_threshold = DEFAULT_FTS | FRAG_DISABLED;\n\tpriv->tx_power = IPW_TX_POWER_DEFAULT;\n\tpriv->tx_rates = DEFAULT_TX_RATES;\n\n\tstrcpy(priv->nick, \"ipw2100\");\n\n\tspin_lock_init(&priv->low_lock);\n\tmutex_init(&priv->action_mutex);\n\tmutex_init(&priv->adapter_mutex);\n\n\tinit_waitqueue_head(&priv->wait_command_queue);\n\n\tnetif_carrier_off(dev);\n\n\tINIT_LIST_HEAD(&priv->msg_free_list);\n\tINIT_LIST_HEAD(&priv->msg_pend_list);\n\tINIT_STAT(&priv->msg_free_stat);\n\tINIT_STAT(&priv->msg_pend_stat);\n\n\tINIT_LIST_HEAD(&priv->tx_free_list);\n\tINIT_LIST_HEAD(&priv->tx_pend_list);\n\tINIT_STAT(&priv->tx_free_stat);\n\tINIT_STAT(&priv->tx_pend_stat);\n\n\tINIT_LIST_HEAD(&priv->fw_pend_list);\n\tINIT_STAT(&priv->fw_pend_stat);\n\n\tINIT_DELAYED_WORK(&priv->reset_work, ipw2100_reset_adapter);\n\tINIT_DELAYED_WORK(&priv->security_work, ipw2100_security_work);\n\tINIT_DELAYED_WORK(&priv->wx_event_work, ipw2100_wx_event_work);\n\tINIT_DELAYED_WORK(&priv->hang_check, ipw2100_hang_check);\n\tINIT_DELAYED_WORK(&priv->rf_kill, ipw2100_rf_kill);\n\tINIT_DELAYED_WORK(&priv->scan_event, ipw2100_scan_event);\n\n\ttasklet_setup(&priv->irq_tasklet, ipw2100_irq_tasklet);\n\n\t \n\tpriv->stop_rf_kill = 1;\n\tpriv->stop_hang_check = 1;\n\n\treturn dev;\n}\n\nstatic int ipw2100_pci_init_one(struct pci_dev *pci_dev,\n\t\t\t\tconst struct pci_device_id *ent)\n{\n\tvoid __iomem *ioaddr;\n\tstruct net_device *dev = NULL;\n\tstruct ipw2100_priv *priv = NULL;\n\tint err = 0;\n\tint registered = 0;\n\tu32 val;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tif (!(pci_resource_flags(pci_dev, 0) & IORESOURCE_MEM)) {\n\t\tIPW_DEBUG_INFO(\"weird - resource type is not memory\\n\");\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tioaddr = pci_iomap(pci_dev, 0, 0);\n\tif (!ioaddr) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \"Error calling ioremap.\\n\");\n\t\terr = -EIO;\n\t\tgoto fail;\n\t}\n\n\t \n\tdev = ipw2100_alloc_device(pci_dev, ioaddr);\n\tif (!dev) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \"Error calling ipw2100_alloc_device.\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\t \n\terr = pci_enable_device(pci_dev);\n\tif (err) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \"Error calling pci_enable_device.\\n\");\n\t\treturn err;\n\t}\n\n\tpriv = libipw_priv(dev);\n\n\tpci_set_master(pci_dev);\n\tpci_set_drvdata(pci_dev, priv);\n\n\terr = dma_set_mask(&pci_dev->dev, DMA_BIT_MASK(32));\n\tif (err) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \"Error calling pci_set_dma_mask.\\n\");\n\t\tpci_disable_device(pci_dev);\n\t\treturn err;\n\t}\n\n\terr = pci_request_regions(pci_dev, DRV_NAME);\n\tif (err) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \"Error calling pci_request_regions.\\n\");\n\t\tpci_disable_device(pci_dev);\n\t\treturn err;\n\t}\n\n\t \n\tpci_read_config_dword(pci_dev, 0x40, &val);\n\tif ((val & 0x0000ff00) != 0)\n\t\tpci_write_config_dword(pci_dev, 0x40, val & 0xffff00ff);\n\n\tif (!ipw2100_hw_is_adapter_in_system(dev)) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \"Device not found via register read.\\n\");\n\t\terr = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tSET_NETDEV_DEV(dev, &pci_dev->dev);\n\n\t \n\tpriv->status |= STATUS_INT_ENABLED;\n\tipw2100_disable_interrupts(priv);\n\n\t \n\tif (ipw2100_queues_allocate(priv)) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \"Error calling ipw2100_queues_allocate.\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tipw2100_queues_initialize(priv);\n\n\terr = request_irq(pci_dev->irq,\n\t\t\t  ipw2100_interrupt, IRQF_SHARED, dev->name, priv);\n\tif (err) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \"Error calling request_irq: %d.\\n\", pci_dev->irq);\n\t\tgoto fail;\n\t}\n\tdev->irq = pci_dev->irq;\n\n\tIPW_DEBUG_INFO(\"Attempting to register device...\\n\");\n\n\tprintk(KERN_INFO DRV_NAME\n\t       \": Detected Intel PRO/Wireless 2100 Network Connection\\n\");\n\n\terr = ipw2100_up(priv, 1);\n\tif (err)\n\t\tgoto fail;\n\n\terr = ipw2100_wdev_init(dev);\n\tif (err)\n\t\tgoto fail;\n\tregistered = 1;\n\n\t \n\terr = register_netdev(dev);\n\tif (err) {\n\t\tprintk(KERN_WARNING DRV_NAME\n\t\t       \"Error calling register_netdev.\\n\");\n\t\tgoto fail;\n\t}\n\tregistered = 2;\n\n\tmutex_lock(&priv->action_mutex);\n\n\tIPW_DEBUG_INFO(\"%s: Bound to %s\\n\", dev->name, pci_name(pci_dev));\n\n\t \n\terr = sysfs_create_group(&pci_dev->dev.kobj, &ipw2100_attribute_group);\n\tif (err)\n\t\tgoto fail_unlock;\n\n\t \n\tif (!(priv->status & STATUS_RF_KILL_MASK)) {\n\t\t \n\t\tif (ipw2100_enable_adapter(priv)) {\n\t\t\tprintk(KERN_WARNING DRV_NAME\n\t\t\t       \": %s: failed in call to enable adapter.\\n\",\n\t\t\t       priv->net_dev->name);\n\t\t\tipw2100_hw_stop_adapter(priv);\n\t\t\terr = -EIO;\n\t\t\tgoto fail_unlock;\n\t\t}\n\n\t\t \n\t\tipw2100_set_scan_options(priv);\n\t\tipw2100_start_scan(priv);\n\t}\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n\n\tpriv->status |= STATUS_INITIALIZED;\n\n\tmutex_unlock(&priv->action_mutex);\nout:\n\treturn err;\n\n      fail_unlock:\n\tmutex_unlock(&priv->action_mutex);\n      fail:\n\tif (dev) {\n\t\tif (registered >= 2)\n\t\t\tunregister_netdev(dev);\n\n\t\tif (registered) {\n\t\t\twiphy_unregister(priv->ieee->wdev.wiphy);\n\t\t\tkfree(priv->ieee->bg_band.channels);\n\t\t}\n\n\t\tipw2100_hw_stop_adapter(priv);\n\n\t\tipw2100_disable_interrupts(priv);\n\n\t\tif (dev->irq)\n\t\t\tfree_irq(dev->irq, priv);\n\n\t\tipw2100_kill_works(priv);\n\n\t\t \n\t\tipw2100_queues_free(priv);\n\t\tsysfs_remove_group(&pci_dev->dev.kobj,\n\t\t\t\t   &ipw2100_attribute_group);\n\n\t\tfree_libipw(dev, 0);\n\t}\n\n\tpci_iounmap(pci_dev, ioaddr);\n\n\tpci_release_regions(pci_dev);\n\tpci_disable_device(pci_dev);\n\tgoto out;\n}\n\nstatic void ipw2100_pci_remove_one(struct pci_dev *pci_dev)\n{\n\tstruct ipw2100_priv *priv = pci_get_drvdata(pci_dev);\n\tstruct net_device *dev = priv->net_dev;\n\n\tmutex_lock(&priv->action_mutex);\n\n\tpriv->status &= ~STATUS_INITIALIZED;\n\n\tsysfs_remove_group(&pci_dev->dev.kobj, &ipw2100_attribute_group);\n\n#ifdef CONFIG_PM\n\tif (ipw2100_firmware.version)\n\t\tipw2100_release_firmware(priv, &ipw2100_firmware);\n#endif\n\t \n\tipw2100_down(priv);\n\n\t \n\tmutex_unlock(&priv->action_mutex);\n\n\t \n\tunregister_netdev(dev);\n\n\tipw2100_kill_works(priv);\n\n\tipw2100_queues_free(priv);\n\n\t \n\tipw2100_snapshot_free(priv);\n\n\tfree_irq(dev->irq, priv);\n\n\tpci_iounmap(pci_dev, priv->ioaddr);\n\n\t \n\twiphy_unregister(priv->ieee->wdev.wiphy);\n\tkfree(priv->ieee->bg_band.channels);\n\tfree_libipw(dev, 0);\n\n\tpci_release_regions(pci_dev);\n\tpci_disable_device(pci_dev);\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n}\n\nstatic int __maybe_unused ipw2100_suspend(struct device *dev_d)\n{\n\tstruct ipw2100_priv *priv = dev_get_drvdata(dev_d);\n\tstruct net_device *dev = priv->net_dev;\n\n\tIPW_DEBUG_INFO(\"%s: Going into suspend...\\n\", dev->name);\n\n\tmutex_lock(&priv->action_mutex);\n\tif (priv->status & STATUS_INITIALIZED) {\n\t\t \n\t\tipw2100_down(priv);\n\t}\n\n\t \n\tnetif_device_detach(dev);\n\n\tpriv->suspend_at = ktime_get_boottime_seconds();\n\n\tmutex_unlock(&priv->action_mutex);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused ipw2100_resume(struct device *dev_d)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev_d);\n\tstruct ipw2100_priv *priv = pci_get_drvdata(pci_dev);\n\tstruct net_device *dev = priv->net_dev;\n\tu32 val;\n\n\tif (IPW2100_PM_DISABLED)\n\t\treturn 0;\n\n\tmutex_lock(&priv->action_mutex);\n\n\tIPW_DEBUG_INFO(\"%s: Coming out of suspend...\\n\", dev->name);\n\n\t \n\tpci_read_config_dword(pci_dev, 0x40, &val);\n\tif ((val & 0x0000ff00) != 0)\n\t\tpci_write_config_dword(pci_dev, 0x40, val & 0xffff00ff);\n\n\t \n\tnetif_device_attach(dev);\n\n\tpriv->suspend_time = ktime_get_boottime_seconds() - priv->suspend_at;\n\n\t \n\tif (!(priv->status & STATUS_RF_KILL_SW))\n\t\tipw2100_up(priv, 0);\n\n\tmutex_unlock(&priv->action_mutex);\n\n\treturn 0;\n}\n\nstatic void ipw2100_shutdown(struct pci_dev *pci_dev)\n{\n\tstruct ipw2100_priv *priv = pci_get_drvdata(pci_dev);\n\n\t \n\tipw2100_down(priv);\n\n\tpci_disable_device(pci_dev);\n}\n\n#define IPW2100_DEV_ID(x) { PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, x }\n\nstatic const struct pci_device_id ipw2100_pci_id_table[] = {\n\tIPW2100_DEV_ID(0x2520),\t \n\tIPW2100_DEV_ID(0x2521),\t \n\tIPW2100_DEV_ID(0x2524),\t \n\tIPW2100_DEV_ID(0x2525),\t \n\tIPW2100_DEV_ID(0x2526),\t \n\tIPW2100_DEV_ID(0x2522),\t \n\tIPW2100_DEV_ID(0x2523),\t \n\tIPW2100_DEV_ID(0x2527),\t \n\tIPW2100_DEV_ID(0x2528),\t \n\tIPW2100_DEV_ID(0x2529),\t \n\tIPW2100_DEV_ID(0x252B),\t \n\tIPW2100_DEV_ID(0x252C),\t \n\tIPW2100_DEV_ID(0x252D),\t \n\n\tIPW2100_DEV_ID(0x2550),\t \n\tIPW2100_DEV_ID(0x2551),\t \n\tIPW2100_DEV_ID(0x2553),\t \n\tIPW2100_DEV_ID(0x2554),\t \n\tIPW2100_DEV_ID(0x2555),\t \n\n\tIPW2100_DEV_ID(0x2560),\t \n\tIPW2100_DEV_ID(0x2562),\t \n\tIPW2100_DEV_ID(0x2563),\t \n\tIPW2100_DEV_ID(0x2561),\t \n\tIPW2100_DEV_ID(0x2565),\t \n\tIPW2100_DEV_ID(0x2566),\t \n\tIPW2100_DEV_ID(0x2567),\t \n\n\tIPW2100_DEV_ID(0x2570),\t \n\n\tIPW2100_DEV_ID(0x2580),\t \n\tIPW2100_DEV_ID(0x2582),\t \n\tIPW2100_DEV_ID(0x2583),\t \n\tIPW2100_DEV_ID(0x2581),\t \n\tIPW2100_DEV_ID(0x2585),\t \n\tIPW2100_DEV_ID(0x2586),\t \n\tIPW2100_DEV_ID(0x2587),\t \n\n\tIPW2100_DEV_ID(0x2590),\t \n\tIPW2100_DEV_ID(0x2592),\t \n\tIPW2100_DEV_ID(0x2591),\t \n\tIPW2100_DEV_ID(0x2593),\t \n\tIPW2100_DEV_ID(0x2596),\t \n\tIPW2100_DEV_ID(0x2598),\t \n\n\tIPW2100_DEV_ID(0x25A0),\t \n\t{0,},\n};\n\nMODULE_DEVICE_TABLE(pci, ipw2100_pci_id_table);\n\nstatic SIMPLE_DEV_PM_OPS(ipw2100_pm_ops, ipw2100_suspend, ipw2100_resume);\n\nstatic struct pci_driver ipw2100_pci_driver = {\n\t.name = DRV_NAME,\n\t.id_table = ipw2100_pci_id_table,\n\t.probe = ipw2100_pci_init_one,\n\t.remove = ipw2100_pci_remove_one,\n\t.driver.pm = &ipw2100_pm_ops,\n\t.shutdown = ipw2100_shutdown,\n};\n\n \nstatic int __init ipw2100_init(void)\n{\n\tint ret;\n\n\tprintk(KERN_INFO DRV_NAME \": %s, %s\\n\", DRV_DESCRIPTION, DRV_VERSION);\n\tprintk(KERN_INFO DRV_NAME \": %s\\n\", DRV_COPYRIGHT);\n\n\tcpu_latency_qos_add_request(&ipw2100_pm_qos_req, PM_QOS_DEFAULT_VALUE);\n\n\tret = pci_register_driver(&ipw2100_pci_driver);\n\tif (ret)\n\t\tgoto out;\n\n#ifdef CONFIG_IPW2100_DEBUG\n\tipw2100_debug_level = debug;\n\tret = driver_create_file(&ipw2100_pci_driver.driver,\n\t\t\t\t &driver_attr_debug_level);\n#endif\n\nout:\n\treturn ret;\n}\n\n \nstatic void __exit ipw2100_exit(void)\n{\n\t \n#ifdef CONFIG_IPW2100_DEBUG\n\tdriver_remove_file(&ipw2100_pci_driver.driver,\n\t\t\t   &driver_attr_debug_level);\n#endif\n\tpci_unregister_driver(&ipw2100_pci_driver);\n\tcpu_latency_qos_remove_request(&ipw2100_pm_qos_req);\n}\n\nmodule_init(ipw2100_init);\nmodule_exit(ipw2100_exit);\n\nstatic int ipw2100_wx_get_name(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\t \n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tif (!(priv->status & STATUS_ASSOCIATED))\n\t\tstrcpy(wrqu->name, \"unassociated\");\n\telse\n\t\tsnprintf(wrqu->name, IFNAMSIZ, \"IEEE 802.11b\");\n\n\tIPW_DEBUG_WX(\"Name: %s\\n\", wrqu->name);\n\treturn 0;\n}\n\nstatic int ipw2100_wx_set_freq(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tstruct iw_freq *fwrq = &wrqu->freq;\n\tint err = 0;\n\n\tif (priv->ieee->iw_mode == IW_MODE_INFRA)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\t \n\tif (fwrq->e == 1) {\n\t\tif ((fwrq->m >= (int)2.412e8 && fwrq->m <= (int)2.487e8)) {\n\t\t\tint f = fwrq->m / 100000;\n\t\t\tint c = 0;\n\n\t\t\twhile ((c < REG_MAX_CHANNEL) &&\n\t\t\t       (f != ipw2100_frequencies[c]))\n\t\t\t\tc++;\n\n\t\t\t \n\t\t\tfwrq->e = 0;\n\t\t\tfwrq->m = c + 1;\n\t\t}\n\t}\n\n\tif (fwrq->e > 0 || fwrq->m > 1000) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto done;\n\t} else {\t\t \n\t\tIPW_DEBUG_WX(\"SET Freq/Channel -> %d\\n\", fwrq->m);\n\t\terr = ipw2100_set_channel(priv, fwrq->m, 0);\n\t}\n\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_wx_get_freq(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\t \n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\twrqu->freq.e = 0;\n\n\t \n\tif (priv->config & CFG_STATIC_CHANNEL ||\n\t    priv->status & STATUS_ASSOCIATED)\n\t\twrqu->freq.m = priv->channel;\n\telse\n\t\twrqu->freq.m = 0;\n\n\tIPW_DEBUG_WX(\"GET Freq/Channel -> %d\\n\", priv->channel);\n\treturn 0;\n\n}\n\nstatic int ipw2100_wx_set_mode(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint err = 0;\n\n\tIPW_DEBUG_WX(\"SET Mode -> %d\\n\", wrqu->mode);\n\n\tif (wrqu->mode == priv->ieee->iw_mode)\n\t\treturn 0;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\tswitch (wrqu->mode) {\n#ifdef CONFIG_IPW2100_MONITOR\n\tcase IW_MODE_MONITOR:\n\t\terr = ipw2100_switch_mode(priv, IW_MODE_MONITOR);\n\t\tbreak;\n#endif\t\t\t\t \n\tcase IW_MODE_ADHOC:\n\t\terr = ipw2100_switch_mode(priv, IW_MODE_ADHOC);\n\t\tbreak;\n\tcase IW_MODE_INFRA:\n\tcase IW_MODE_AUTO:\n\tdefault:\n\t\terr = ipw2100_switch_mode(priv, IW_MODE_INFRA);\n\t\tbreak;\n\t}\n\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_wx_get_mode(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\t \n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\twrqu->mode = priv->ieee->iw_mode;\n\tIPW_DEBUG_WX(\"GET Mode -> %d\\n\", wrqu->mode);\n\n\treturn 0;\n}\n\n#define POWER_MODES 5\n\n \nstatic const s32 timeout_duration[POWER_MODES] = {\n\t350000,\n\t250000,\n\t75000,\n\t37000,\n\t25000,\n};\n\nstatic const s32 period_duration[POWER_MODES] = {\n\t400000,\n\t700000,\n\t1000000,\n\t1000000,\n\t1000000\n};\n\nstatic int ipw2100_wx_get_range(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\t \n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tstruct iw_range *range = (struct iw_range *)extra;\n\tu16 val;\n\tint i, level;\n\n\twrqu->data.length = sizeof(*range);\n\tmemset(range, 0, sizeof(*range));\n\n\t \n\n\t \n\n\t \n\trange->throughput = 5 * 1000 * 1000;\n\n \n\n\trange->max_qual.qual = 100;\n\t \n\trange->max_qual.level = 0;\n\trange->max_qual.noise = 0;\n\trange->max_qual.updated = 7;\t \n\n\trange->avg_qual.qual = 70;\t \n\t \n\trange->avg_qual.level = 20 + IPW2100_RSSI_TO_DBM;\n\trange->avg_qual.noise = 0;\n\trange->avg_qual.updated = 7;\t \n\n\trange->num_bitrates = RATE_COUNT;\n\n\tfor (i = 0; i < RATE_COUNT && i < IW_MAX_BITRATES; i++) {\n\t\trange->bitrate[i] = ipw2100_bg_rates[i].bitrate * 100 * 1000;\n\t}\n\n\trange->min_rts = MIN_RTS_THRESHOLD;\n\trange->max_rts = MAX_RTS_THRESHOLD;\n\trange->min_frag = MIN_FRAG_THRESHOLD;\n\trange->max_frag = MAX_FRAG_THRESHOLD;\n\n\trange->min_pmp = period_duration[0];\t \n\trange->max_pmp = period_duration[POWER_MODES - 1];\t \n\trange->min_pmt = timeout_duration[POWER_MODES - 1];\t \n\trange->max_pmt = timeout_duration[0];\t \n\n\t \n\trange->pmp_flags = IW_POWER_PERIOD;\n\t \n\trange->pmt_flags = IW_POWER_TIMEOUT;\n\t \n\trange->pm_capa = IW_POWER_TIMEOUT | IW_POWER_PERIOD;\n\n\trange->encoding_size[0] = 5;\n\trange->encoding_size[1] = 13;\t \n\trange->num_encoding_sizes = 2;\t \n\trange->max_encoding_tokens = WEP_KEYS;\t \n \n\n\tif (priv->ieee->iw_mode == IW_MODE_ADHOC) {\n\t\trange->txpower_capa = IW_TXPOW_DBM;\n\t\trange->num_txpower = IW_MAX_TXPOWER;\n\t\tfor (i = 0, level = (IPW_TX_POWER_MAX_DBM * 16);\n\t\t     i < IW_MAX_TXPOWER;\n\t\t     i++, level -=\n\t\t     ((IPW_TX_POWER_MAX_DBM -\n\t\t       IPW_TX_POWER_MIN_DBM) * 16) / (IW_MAX_TXPOWER - 1))\n\t\t\trange->txpower[i] = level / 16;\n\t} else {\n\t\trange->txpower_capa = 0;\n\t\trange->num_txpower = 0;\n\t}\n\n\t \n\trange->we_version_compiled = WIRELESS_EXT;\n\trange->we_version_source = 18;\n\n \n \n \n \n \n \n \n\n\trange->num_channels = FREQ_COUNT;\n\n\tval = 0;\n\tfor (i = 0; i < FREQ_COUNT; i++) {\n\t\t \n \n\t\trange->freq[val].i = i + 1;\n\t\trange->freq[val].m = ipw2100_frequencies[i] * 100000;\n\t\trange->freq[val].e = 1;\n\t\tval++;\n \n\t\tif (val == IW_MAX_FREQUENCIES)\n\t\t\tbreak;\n\t}\n\trange->num_frequency = val;\n\n\t \n\trange->event_capa[0] = (IW_EVENT_CAPA_K_0 |\n\t\t\t\tIW_EVENT_CAPA_MASK(SIOCGIWAP));\n\trange->event_capa[1] = IW_EVENT_CAPA_K_1;\n\n\trange->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 |\n\t\tIW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP;\n\n\tIPW_DEBUG_WX(\"GET Range\\n\");\n\n\treturn 0;\n}\n\nstatic int ipw2100_wx_set_wap(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint err = 0;\n\n\t \n\tif (wrqu->ap_addr.sa_family != ARPHRD_ETHER)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\tif (is_broadcast_ether_addr(wrqu->ap_addr.sa_data) ||\n\t    is_zero_ether_addr(wrqu->ap_addr.sa_data)) {\n\t\t \n\t\tIPW_DEBUG_WX(\"exit - disable mandatory BSSID\\n\");\n\t\tpriv->config &= ~CFG_STATIC_BSSID;\n\t\terr = ipw2100_set_mandatory_bssid(priv, NULL, 0);\n\t\tgoto done;\n\t}\n\n\tpriv->config |= CFG_STATIC_BSSID;\n\tmemcpy(priv->mandatory_bssid_mac, wrqu->ap_addr.sa_data, ETH_ALEN);\n\n\terr = ipw2100_set_mandatory_bssid(priv, wrqu->ap_addr.sa_data, 0);\n\n\tIPW_DEBUG_WX(\"SET BSSID -> %pM\\n\", wrqu->ap_addr.sa_data);\n\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_wx_get_wap(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *wrqu, char *extra)\n{\n\t \n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\t \n\tif (priv->config & CFG_STATIC_BSSID || priv->status & STATUS_ASSOCIATED) {\n\t\twrqu->ap_addr.sa_family = ARPHRD_ETHER;\n\t\tmemcpy(wrqu->ap_addr.sa_data, priv->bssid, ETH_ALEN);\n\t} else\n\t\teth_zero_addr(wrqu->ap_addr.sa_data);\n\n\tIPW_DEBUG_WX(\"Getting WAP BSSID: %pM\\n\", wrqu->ap_addr.sa_data);\n\treturn 0;\n}\n\nstatic int ipw2100_wx_set_essid(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tchar *essid = \"\";\t \n\tint length = 0;\n\tint err = 0;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\tif (wrqu->essid.flags && wrqu->essid.length) {\n\t\tlength = wrqu->essid.length;\n\t\tessid = extra;\n\t}\n\n\tif (length == 0) {\n\t\tIPW_DEBUG_WX(\"Setting ESSID to ANY\\n\");\n\t\tpriv->config &= ~CFG_STATIC_ESSID;\n\t\terr = ipw2100_set_essid(priv, NULL, 0, 0);\n\t\tgoto done;\n\t}\n\n\tlength = min(length, IW_ESSID_MAX_SIZE);\n\n\tpriv->config |= CFG_STATIC_ESSID;\n\n\tif (priv->essid_len == length && !memcmp(priv->essid, extra, length)) {\n\t\tIPW_DEBUG_WX(\"ESSID set to current ESSID.\\n\");\n\t\terr = 0;\n\t\tgoto done;\n\t}\n\n\tIPW_DEBUG_WX(\"Setting ESSID: '%*pE' (%d)\\n\", length, essid, length);\n\n\tpriv->essid_len = length;\n\tmemcpy(priv->essid, essid, priv->essid_len);\n\n\terr = ipw2100_set_essid(priv, essid, length, 0);\n\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_wx_get_essid(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\t \n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\t \n\tif (priv->config & CFG_STATIC_ESSID || priv->status & STATUS_ASSOCIATED) {\n\t\tIPW_DEBUG_WX(\"Getting essid: '%*pE'\\n\",\n\t\t\t     priv->essid_len, priv->essid);\n\t\tmemcpy(extra, priv->essid, priv->essid_len);\n\t\twrqu->essid.length = priv->essid_len;\n\t\twrqu->essid.flags = 1;\t \n\t} else {\n\t\tIPW_DEBUG_WX(\"Getting essid: ANY\\n\");\n\t\twrqu->essid.length = 0;\n\t\twrqu->essid.flags = 0;\t \n\t}\n\n\treturn 0;\n}\n\nstatic int ipw2100_wx_set_nick(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\t \n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\tif (wrqu->data.length > IW_ESSID_MAX_SIZE)\n\t\treturn -E2BIG;\n\n\twrqu->data.length = min_t(size_t, wrqu->data.length, sizeof(priv->nick));\n\tmemset(priv->nick, 0, sizeof(priv->nick));\n\tmemcpy(priv->nick, extra, wrqu->data.length);\n\n\tIPW_DEBUG_WX(\"SET Nickname -> %s\\n\", priv->nick);\n\n\treturn 0;\n}\n\nstatic int ipw2100_wx_get_nick(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\t \n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\twrqu->data.length = strlen(priv->nick);\n\tmemcpy(extra, priv->nick, wrqu->data.length);\n\twrqu->data.flags = 1;\t \n\n\tIPW_DEBUG_WX(\"GET Nickname -> %s\\n\", extra);\n\n\treturn 0;\n}\n\nstatic int ipw2100_wx_set_rate(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tu32 target_rate = wrqu->bitrate.value;\n\tu32 rate;\n\tint err = 0;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\trate = 0;\n\n\tif (target_rate == 1000000 ||\n\t    (!wrqu->bitrate.fixed && target_rate > 1000000))\n\t\trate |= TX_RATE_1_MBIT;\n\tif (target_rate == 2000000 ||\n\t    (!wrqu->bitrate.fixed && target_rate > 2000000))\n\t\trate |= TX_RATE_2_MBIT;\n\tif (target_rate == 5500000 ||\n\t    (!wrqu->bitrate.fixed && target_rate > 5500000))\n\t\trate |= TX_RATE_5_5_MBIT;\n\tif (target_rate == 11000000 ||\n\t    (!wrqu->bitrate.fixed && target_rate > 11000000))\n\t\trate |= TX_RATE_11_MBIT;\n\tif (rate == 0)\n\t\trate = DEFAULT_TX_RATES;\n\n\terr = ipw2100_set_tx_rates(priv, rate, 0);\n\n\tIPW_DEBUG_WX(\"SET Rate -> %04X\\n\", rate);\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_wx_get_rate(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint val;\n\tunsigned int len = sizeof(val);\n\tint err = 0;\n\n\tif (!(priv->status & STATUS_ENABLED) ||\n\t    priv->status & STATUS_RF_KILL_MASK ||\n\t    !(priv->status & STATUS_ASSOCIATED)) {\n\t\twrqu->bitrate.value = 0;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\terr = ipw2100_get_ordinal(priv, IPW_ORD_CURRENT_TX_RATE, &val, &len);\n\tif (err) {\n\t\tIPW_DEBUG_WX(\"failed querying ordinals.\\n\");\n\t\tgoto done;\n\t}\n\n\tswitch (val & TX_RATE_MASK) {\n\tcase TX_RATE_1_MBIT:\n\t\twrqu->bitrate.value = 1000000;\n\t\tbreak;\n\tcase TX_RATE_2_MBIT:\n\t\twrqu->bitrate.value = 2000000;\n\t\tbreak;\n\tcase TX_RATE_5_5_MBIT:\n\t\twrqu->bitrate.value = 5500000;\n\t\tbreak;\n\tcase TX_RATE_11_MBIT:\n\t\twrqu->bitrate.value = 11000000;\n\t\tbreak;\n\tdefault:\n\t\twrqu->bitrate.value = 0;\n\t}\n\n\tIPW_DEBUG_WX(\"GET Rate -> %d\\n\", wrqu->bitrate.value);\n\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_wx_set_rts(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint value, err;\n\n\t \n\tif (wrqu->rts.fixed == 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\tif (wrqu->rts.disabled)\n\t\tvalue = priv->rts_threshold | RTS_DISABLED;\n\telse {\n\t\tif (wrqu->rts.value < 1 || wrqu->rts.value > 2304) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\tvalue = wrqu->rts.value;\n\t}\n\n\terr = ipw2100_set_rts_threshold(priv, value);\n\n\tIPW_DEBUG_WX(\"SET RTS Threshold -> 0x%08X\\n\", value);\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_wx_get_rts(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *wrqu, char *extra)\n{\n\t \n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\twrqu->rts.value = priv->rts_threshold & ~RTS_DISABLED;\n\twrqu->rts.fixed = 1;\t \n\n\t \n\twrqu->rts.disabled = (priv->rts_threshold & RTS_DISABLED) ? 1 : 0;\n\n\tIPW_DEBUG_WX(\"GET RTS Threshold -> 0x%08X\\n\", wrqu->rts.value);\n\n\treturn 0;\n}\n\nstatic int ipw2100_wx_set_txpow(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint err = 0, value;\n\t\n\tif (ipw_radio_kill_sw(priv, wrqu->txpower.disabled))\n\t\treturn -EINPROGRESS;\n\n\tif (priv->ieee->iw_mode != IW_MODE_ADHOC)\n\t\treturn 0;\n\n\tif ((wrqu->txpower.flags & IW_TXPOW_TYPE) != IW_TXPOW_DBM)\n\t\treturn -EINVAL;\n\n\tif (wrqu->txpower.fixed == 0)\n\t\tvalue = IPW_TX_POWER_DEFAULT;\n\telse {\n\t\tif (wrqu->txpower.value < IPW_TX_POWER_MIN_DBM ||\n\t\t    wrqu->txpower.value > IPW_TX_POWER_MAX_DBM)\n\t\t\treturn -EINVAL;\n\n\t\tvalue = wrqu->txpower.value;\n\t}\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\terr = ipw2100_set_tx_power(priv, value);\n\n\tIPW_DEBUG_WX(\"SET TX Power -> %d\\n\", value);\n\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_wx_get_txpow(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\t \n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\twrqu->txpower.disabled = (priv->status & STATUS_RF_KILL_MASK) ? 1 : 0;\n\n\tif (priv->tx_power == IPW_TX_POWER_DEFAULT) {\n\t\twrqu->txpower.fixed = 0;\n\t\twrqu->txpower.value = IPW_TX_POWER_MAX_DBM;\n\t} else {\n\t\twrqu->txpower.fixed = 1;\n\t\twrqu->txpower.value = priv->tx_power;\n\t}\n\n\twrqu->txpower.flags = IW_TXPOW_DBM;\n\n\tIPW_DEBUG_WX(\"GET TX Power -> %d\\n\", wrqu->txpower.value);\n\n\treturn 0;\n}\n\nstatic int ipw2100_wx_set_frag(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\t \n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\tif (!wrqu->frag.fixed)\n\t\treturn -EINVAL;\n\n\tif (wrqu->frag.disabled) {\n\t\tpriv->frag_threshold |= FRAG_DISABLED;\n\t\tpriv->ieee->fts = DEFAULT_FTS;\n\t} else {\n\t\tif (wrqu->frag.value < MIN_FRAG_THRESHOLD ||\n\t\t    wrqu->frag.value > MAX_FRAG_THRESHOLD)\n\t\t\treturn -EINVAL;\n\n\t\tpriv->ieee->fts = wrqu->frag.value & ~0x1;\n\t\tpriv->frag_threshold = priv->ieee->fts;\n\t}\n\n\tIPW_DEBUG_WX(\"SET Frag Threshold -> %d\\n\", priv->ieee->fts);\n\n\treturn 0;\n}\n\nstatic int ipw2100_wx_get_frag(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\t \n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\twrqu->frag.value = priv->frag_threshold & ~FRAG_DISABLED;\n\twrqu->frag.fixed = 0;\t \n\twrqu->frag.disabled = (priv->frag_threshold & FRAG_DISABLED) ? 1 : 0;\n\n\tIPW_DEBUG_WX(\"GET Frag Threshold -> %d\\n\", wrqu->frag.value);\n\n\treturn 0;\n}\n\nstatic int ipw2100_wx_set_retry(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint err = 0;\n\n\tif (wrqu->retry.flags & IW_RETRY_LIFETIME || wrqu->retry.disabled)\n\t\treturn -EINVAL;\n\n\tif (!(wrqu->retry.flags & IW_RETRY_LIMIT))\n\t\treturn 0;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\tif (wrqu->retry.flags & IW_RETRY_SHORT) {\n\t\terr = ipw2100_set_short_retry(priv, wrqu->retry.value);\n\t\tIPW_DEBUG_WX(\"SET Short Retry Limit -> %d\\n\",\n\t\t\t     wrqu->retry.value);\n\t\tgoto done;\n\t}\n\n\tif (wrqu->retry.flags & IW_RETRY_LONG) {\n\t\terr = ipw2100_set_long_retry(priv, wrqu->retry.value);\n\t\tIPW_DEBUG_WX(\"SET Long Retry Limit -> %d\\n\",\n\t\t\t     wrqu->retry.value);\n\t\tgoto done;\n\t}\n\n\terr = ipw2100_set_short_retry(priv, wrqu->retry.value);\n\tif (!err)\n\t\terr = ipw2100_set_long_retry(priv, wrqu->retry.value);\n\n\tIPW_DEBUG_WX(\"SET Both Retry Limits -> %d\\n\", wrqu->retry.value);\n\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_wx_get_retry(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\t \n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\twrqu->retry.disabled = 0;\t \n\n\tif ((wrqu->retry.flags & IW_RETRY_TYPE) == IW_RETRY_LIFETIME)\n\t\treturn -EINVAL;\n\n\tif (wrqu->retry.flags & IW_RETRY_LONG) {\n\t\twrqu->retry.flags = IW_RETRY_LIMIT | IW_RETRY_LONG;\n\t\twrqu->retry.value = priv->long_retry_limit;\n\t} else {\n\t\twrqu->retry.flags =\n\t\t    (priv->short_retry_limit !=\n\t\t     priv->long_retry_limit) ?\n\t\t    IW_RETRY_LIMIT | IW_RETRY_SHORT : IW_RETRY_LIMIT;\n\n\t\twrqu->retry.value = priv->short_retry_limit;\n\t}\n\n\tIPW_DEBUG_WX(\"GET Retry -> %d\\n\", wrqu->retry.value);\n\n\treturn 0;\n}\n\nstatic int ipw2100_wx_set_scan(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint err = 0;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\tIPW_DEBUG_WX(\"Initiating scan...\\n\");\n\n\tpriv->user_requested_scan = 1;\n\tif (ipw2100_set_scan_options(priv) || ipw2100_start_scan(priv)) {\n\t\tIPW_DEBUG_WX(\"Start scan failed.\\n\");\n\n\t\t \n\t}\n\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_wx_get_scan(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\t \n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\treturn libipw_wx_get_scan(priv->ieee, info, wrqu, extra);\n}\n\n \nstatic int ipw2100_wx_set_encode(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *key)\n{\n\t \n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\treturn libipw_wx_set_encode(priv->ieee, info, wrqu, key);\n}\n\nstatic int ipw2100_wx_get_encode(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t union iwreq_data *wrqu, char *key)\n{\n\t \n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\treturn libipw_wx_get_encode(priv->ieee, info, wrqu, key);\n}\n\nstatic int ipw2100_wx_set_power(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint err = 0;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\tif (wrqu->power.disabled) {\n\t\tpriv->power_mode = IPW_POWER_LEVEL(priv->power_mode);\n\t\terr = ipw2100_set_power_mode(priv, IPW_POWER_MODE_CAM);\n\t\tIPW_DEBUG_WX(\"SET Power Management Mode -> off\\n\");\n\t\tgoto done;\n\t}\n\n\tswitch (wrqu->power.flags & IW_POWER_MODE) {\n\tcase IW_POWER_ON:\t \n\tcase IW_POWER_MODE:\t \n\tcase IW_POWER_ALL_R:\t \n\t\tbreak;\n\tdefault:\t\t \n\t\tIPW_DEBUG_WX(\"SET PM Mode: %X not supported.\\n\",\n\t\t\t     wrqu->power.flags);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto done;\n\t}\n\n\t \n\tpriv->power_mode = IPW_POWER_ENABLED | priv->power_mode;\n\terr = ipw2100_set_power_mode(priv, IPW_POWER_LEVEL(priv->power_mode));\n\n\tIPW_DEBUG_WX(\"SET Power Management Mode -> 0x%02X\\n\", priv->power_mode);\n\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n\n}\n\nstatic int ipw2100_wx_get_power(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\t \n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\tif (!(priv->power_mode & IPW_POWER_ENABLED))\n\t\twrqu->power.disabled = 1;\n\telse {\n\t\twrqu->power.disabled = 0;\n\t\twrqu->power.flags = 0;\n\t}\n\n\tIPW_DEBUG_WX(\"GET Power Management Mode -> %02X\\n\", priv->power_mode);\n\n\treturn 0;\n}\n\n \n\n \nstatic int ipw2100_wx_set_genie(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tstruct libipw_device *ieee = priv->ieee;\n\tu8 *buf;\n\n\tif (!ieee->wpa_enabled)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wrqu->data.length > MAX_WPA_IE_LEN ||\n\t    (wrqu->data.length && extra == NULL))\n\t\treturn -EINVAL;\n\n\tif (wrqu->data.length) {\n\t\tbuf = kmemdup(extra, wrqu->data.length, GFP_KERNEL);\n\t\tif (buf == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tkfree(ieee->wpa_ie);\n\t\tieee->wpa_ie = buf;\n\t\tieee->wpa_ie_len = wrqu->data.length;\n\t} else {\n\t\tkfree(ieee->wpa_ie);\n\t\tieee->wpa_ie = NULL;\n\t\tieee->wpa_ie_len = 0;\n\t}\n\n\tipw2100_wpa_assoc_frame(priv, ieee->wpa_ie, ieee->wpa_ie_len);\n\n\treturn 0;\n}\n\n \nstatic int ipw2100_wx_get_genie(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tstruct libipw_device *ieee = priv->ieee;\n\n\tif (ieee->wpa_ie_len == 0 || ieee->wpa_ie == NULL) {\n\t\twrqu->data.length = 0;\n\t\treturn 0;\n\t}\n\n\tif (wrqu->data.length < ieee->wpa_ie_len)\n\t\treturn -E2BIG;\n\n\twrqu->data.length = ieee->wpa_ie_len;\n\tmemcpy(extra, ieee->wpa_ie, ieee->wpa_ie_len);\n\n\treturn 0;\n}\n\n \nstatic int ipw2100_wx_set_auth(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tstruct libipw_device *ieee = priv->ieee;\n\tstruct iw_param *param = &wrqu->param;\n\tstruct lib80211_crypt_data *crypt;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_KEY_MGMT:\n\t\t \n\t\tbreak;\n\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\tcrypt = priv->ieee->crypt_info.crypt[priv->ieee->crypt_info.tx_keyidx];\n\t\tif (!crypt || !crypt->ops->set_flags || !crypt->ops->get_flags)\n\t\t\tbreak;\n\n\t\tflags = crypt->ops->get_flags(crypt->priv);\n\n\t\tif (param->value)\n\t\t\tflags |= IEEE80211_CRYPTO_TKIP_COUNTERMEASURES;\n\t\telse\n\t\t\tflags &= ~IEEE80211_CRYPTO_TKIP_COUNTERMEASURES;\n\n\t\tcrypt->ops->set_flags(flags, crypt->priv);\n\n\t\tbreak;\n\n\tcase IW_AUTH_DROP_UNENCRYPTED:{\n\t\t\t \n\t\t\tstruct libipw_security sec = {\n\t\t\t\t.flags = SEC_ENABLED,\n\t\t\t\t.enabled = param->value,\n\t\t\t};\n\t\t\tpriv->ieee->drop_unencrypted = param->value;\n\t\t\t \n\t\t\tif (!param->value) {\n\t\t\t\tsec.flags |= SEC_LEVEL;\n\t\t\t\tsec.level = SEC_LEVEL_0;\n\t\t\t} else {\n\t\t\t\tsec.flags |= SEC_LEVEL;\n\t\t\t\tsec.level = SEC_LEVEL_1;\n\t\t\t}\n\t\t\tif (priv->ieee->set_security)\n\t\t\t\tpriv->ieee->set_security(priv->ieee->dev, &sec);\n\t\t\tbreak;\n\t\t}\n\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tret = ipw2100_wpa_set_auth_algs(priv, param->value);\n\t\tbreak;\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tret = ipw2100_wpa_enable(priv, param->value);\n\t\tbreak;\n\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\t\tieee->ieee802_1x = param->value;\n\t\tbreak;\n\n\t\t\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\t\tieee->privacy_invoked = param->value;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn ret;\n}\n\n \nstatic int ipw2100_wx_get_auth(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tstruct libipw_device *ieee = priv->ieee;\n\tstruct lib80211_crypt_data *crypt;\n\tstruct iw_param *param = &wrqu->param;\n\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_KEY_MGMT:\n\t\t \n\t\tbreak;\n\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\tcrypt = priv->ieee->crypt_info.crypt[priv->ieee->crypt_info.tx_keyidx];\n\t\tif (!crypt || !crypt->ops->get_flags) {\n\t\t\tIPW_DEBUG_WARNING(\"Can't get TKIP countermeasures: \"\n\t\t\t\t\t  \"crypt not set!\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tparam->value = (crypt->ops->get_flags(crypt->priv) &\n\t\t\t\tIEEE80211_CRYPTO_TKIP_COUNTERMEASURES) ? 1 : 0;\n\n\t\tbreak;\n\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\tparam->value = ieee->drop_unencrypted;\n\t\tbreak;\n\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tparam->value = priv->ieee->sec.auth_mode;\n\t\tbreak;\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tparam->value = ieee->wpa_enabled;\n\t\tbreak;\n\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\t\tparam->value = ieee->ieee802_1x;\n\t\tbreak;\n\n\tcase IW_AUTH_ROAMING_CONTROL:\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\t\tparam->value = ieee->privacy_invoked;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n \nstatic int ipw2100_wx_set_encodeext(struct net_device *dev,\n\t\t\t\t    struct iw_request_info *info,\n\t\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\treturn libipw_wx_set_encodeext(priv->ieee, info, wrqu, extra);\n}\n\n \nstatic int ipw2100_wx_get_encodeext(struct net_device *dev,\n\t\t\t\t    struct iw_request_info *info,\n\t\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\treturn libipw_wx_get_encodeext(priv->ieee, info, wrqu, extra);\n}\n\n \nstatic int ipw2100_wx_set_mlme(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tstruct iw_mlme *mlme = (struct iw_mlme *)extra;\n\n\tswitch (mlme->cmd) {\n\tcase IW_MLME_DEAUTH:\n\t\t\n\t\tbreak;\n\n\tcase IW_MLME_DISASSOC:\n\t\tipw2100_disassociate_bssid(priv);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n \n#ifdef CONFIG_IPW2100_MONITOR\nstatic int ipw2100_wx_set_promisc(struct net_device *dev,\n\t\t\t\t  struct iw_request_info *info,\n\t\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint *parms = (int *)extra;\n\tint enable = (parms[0] > 0);\n\tint err = 0;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\tif (enable) {\n\t\tif (priv->ieee->iw_mode == IW_MODE_MONITOR) {\n\t\t\terr = ipw2100_set_channel(priv, parms[1], 0);\n\t\t\tgoto done;\n\t\t}\n\t\tpriv->channel = parms[1];\n\t\terr = ipw2100_switch_mode(priv, IW_MODE_MONITOR);\n\t} else {\n\t\tif (priv->ieee->iw_mode == IW_MODE_MONITOR)\n\t\t\terr = ipw2100_switch_mode(priv, priv->last_mode);\n\t}\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_wx_reset(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tif (priv->status & STATUS_INITIALIZED)\n\t\tschedule_reset(priv);\n\treturn 0;\n}\n\n#endif\n\nstatic int ipw2100_wx_set_powermode(struct net_device *dev,\n\t\t\t\t    struct iw_request_info *info,\n\t\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint err = 0, mode = *(int *)extra;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\tif ((mode < 0) || (mode > POWER_MODES))\n\t\tmode = IPW_POWER_AUTO;\n\n\tif (IPW_POWER_LEVEL(priv->power_mode) != mode)\n\t\terr = ipw2100_set_power_mode(priv, mode);\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\n#define MAX_POWER_STRING 80\nstatic int ipw2100_wx_get_powermode(struct net_device *dev,\n\t\t\t\t    struct iw_request_info *info,\n\t\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\t \n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint level = IPW_POWER_LEVEL(priv->power_mode);\n\ts32 timeout, period;\n\n\tif (!(priv->power_mode & IPW_POWER_ENABLED)) {\n\t\tsnprintf(extra, MAX_POWER_STRING,\n\t\t\t \"Power save level: %d (Off)\", level);\n\t} else {\n\t\tswitch (level) {\n\t\tcase IPW_POWER_MODE_CAM:\n\t\t\tsnprintf(extra, MAX_POWER_STRING,\n\t\t\t\t \"Power save level: %d (None)\", level);\n\t\t\tbreak;\n\t\tcase IPW_POWER_AUTO:\n\t\t\tsnprintf(extra, MAX_POWER_STRING,\n\t\t\t\t \"Power save level: %d (Auto)\", level);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttimeout = timeout_duration[level - 1] / 1000;\n\t\t\tperiod = period_duration[level - 1] / 1000;\n\t\t\tsnprintf(extra, MAX_POWER_STRING,\n\t\t\t\t \"Power save level: %d \"\n\t\t\t\t \"(Timeout %dms, Period %dms)\",\n\t\t\t\t level, timeout, period);\n\t\t}\n\t}\n\n\twrqu->data.length = strlen(extra) + 1;\n\n\treturn 0;\n}\n\nstatic int ipw2100_wx_set_preamble(struct net_device *dev,\n\t\t\t\t   struct iw_request_info *info,\n\t\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint err, mode = *(int *)extra;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\tif (mode == 1)\n\t\tpriv->config |= CFG_LONG_PREAMBLE;\n\telse if (mode == 0)\n\t\tpriv->config &= ~CFG_LONG_PREAMBLE;\n\telse {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\terr = ipw2100_system_config(priv, 0);\n\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_wx_get_preamble(struct net_device *dev,\n\t\t\t\t   struct iw_request_info *info,\n\t\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\t \n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\tif (priv->config & CFG_LONG_PREAMBLE)\n\t\tsnprintf(wrqu->name, IFNAMSIZ, \"long (1)\");\n\telse\n\t\tsnprintf(wrqu->name, IFNAMSIZ, \"auto (0)\");\n\n\treturn 0;\n}\n\n#ifdef CONFIG_IPW2100_MONITOR\nstatic int ipw2100_wx_set_crc_check(struct net_device *dev,\n\t\t\t\t    struct iw_request_info *info,\n\t\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tint err, mode = *(int *)extra;\n\n\tmutex_lock(&priv->action_mutex);\n\tif (!(priv->status & STATUS_INITIALIZED)) {\n\t\terr = -EIO;\n\t\tgoto done;\n\t}\n\n\tif (mode == 1)\n\t\tpriv->config |= CFG_CRC_CHECK;\n\telse if (mode == 0)\n\t\tpriv->config &= ~CFG_CRC_CHECK;\n\telse {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\terr = 0;\n\n      done:\n\tmutex_unlock(&priv->action_mutex);\n\treturn err;\n}\n\nstatic int ipw2100_wx_get_crc_check(struct net_device *dev,\n\t\t\t\t    struct iw_request_info *info,\n\t\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\t \n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\n\tif (priv->config & CFG_CRC_CHECK)\n\t\tsnprintf(wrqu->name, IFNAMSIZ, \"CRC checked (1)\");\n\telse\n\t\tsnprintf(wrqu->name, IFNAMSIZ, \"CRC ignored (0)\");\n\n\treturn 0;\n}\n#endif\t\t\t\t \n\nstatic iw_handler ipw2100_wx_handlers[] = {\n\tIW_HANDLER(SIOCGIWNAME, ipw2100_wx_get_name),\n\tIW_HANDLER(SIOCSIWFREQ, ipw2100_wx_set_freq),\n\tIW_HANDLER(SIOCGIWFREQ, ipw2100_wx_get_freq),\n\tIW_HANDLER(SIOCSIWMODE, ipw2100_wx_set_mode),\n\tIW_HANDLER(SIOCGIWMODE, ipw2100_wx_get_mode),\n\tIW_HANDLER(SIOCGIWRANGE, ipw2100_wx_get_range),\n\tIW_HANDLER(SIOCSIWAP, ipw2100_wx_set_wap),\n\tIW_HANDLER(SIOCGIWAP, ipw2100_wx_get_wap),\n\tIW_HANDLER(SIOCSIWMLME, ipw2100_wx_set_mlme),\n\tIW_HANDLER(SIOCSIWSCAN, ipw2100_wx_set_scan),\n\tIW_HANDLER(SIOCGIWSCAN, ipw2100_wx_get_scan),\n\tIW_HANDLER(SIOCSIWESSID, ipw2100_wx_set_essid),\n\tIW_HANDLER(SIOCGIWESSID, ipw2100_wx_get_essid),\n\tIW_HANDLER(SIOCSIWNICKN, ipw2100_wx_set_nick),\n\tIW_HANDLER(SIOCGIWNICKN, ipw2100_wx_get_nick),\n\tIW_HANDLER(SIOCSIWRATE, ipw2100_wx_set_rate),\n\tIW_HANDLER(SIOCGIWRATE, ipw2100_wx_get_rate),\n\tIW_HANDLER(SIOCSIWRTS, ipw2100_wx_set_rts),\n\tIW_HANDLER(SIOCGIWRTS, ipw2100_wx_get_rts),\n\tIW_HANDLER(SIOCSIWFRAG, ipw2100_wx_set_frag),\n\tIW_HANDLER(SIOCGIWFRAG, ipw2100_wx_get_frag),\n\tIW_HANDLER(SIOCSIWTXPOW, ipw2100_wx_set_txpow),\n\tIW_HANDLER(SIOCGIWTXPOW, ipw2100_wx_get_txpow),\n\tIW_HANDLER(SIOCSIWRETRY, ipw2100_wx_set_retry),\n\tIW_HANDLER(SIOCGIWRETRY, ipw2100_wx_get_retry),\n\tIW_HANDLER(SIOCSIWENCODE, ipw2100_wx_set_encode),\n\tIW_HANDLER(SIOCGIWENCODE, ipw2100_wx_get_encode),\n\tIW_HANDLER(SIOCSIWPOWER, ipw2100_wx_set_power),\n\tIW_HANDLER(SIOCGIWPOWER, ipw2100_wx_get_power),\n\tIW_HANDLER(SIOCSIWGENIE, ipw2100_wx_set_genie),\n\tIW_HANDLER(SIOCGIWGENIE, ipw2100_wx_get_genie),\n\tIW_HANDLER(SIOCSIWAUTH, ipw2100_wx_set_auth),\n\tIW_HANDLER(SIOCGIWAUTH, ipw2100_wx_get_auth),\n\tIW_HANDLER(SIOCSIWENCODEEXT, ipw2100_wx_set_encodeext),\n\tIW_HANDLER(SIOCGIWENCODEEXT, ipw2100_wx_get_encodeext),\n};\n\n#define IPW2100_PRIV_SET_MONITOR\tSIOCIWFIRSTPRIV\n#define IPW2100_PRIV_RESET\t\tSIOCIWFIRSTPRIV+1\n#define IPW2100_PRIV_SET_POWER\t\tSIOCIWFIRSTPRIV+2\n#define IPW2100_PRIV_GET_POWER\t\tSIOCIWFIRSTPRIV+3\n#define IPW2100_PRIV_SET_LONGPREAMBLE\tSIOCIWFIRSTPRIV+4\n#define IPW2100_PRIV_GET_LONGPREAMBLE\tSIOCIWFIRSTPRIV+5\n#define IPW2100_PRIV_SET_CRC_CHECK\tSIOCIWFIRSTPRIV+6\n#define IPW2100_PRIV_GET_CRC_CHECK\tSIOCIWFIRSTPRIV+7\n\nstatic const struct iw_priv_args ipw2100_private_args[] = {\n\n#ifdef CONFIG_IPW2100_MONITOR\n\t{\n\t IPW2100_PRIV_SET_MONITOR,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0, \"monitor\"},\n\t{\n\t IPW2100_PRIV_RESET,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 0, 0, \"reset\"},\n#endif\t\t\t\t \n\n\t{\n\t IPW2100_PRIV_SET_POWER,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"set_power\"},\n\t{\n\t IPW2100_PRIV_GET_POWER,\n\t 0, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | MAX_POWER_STRING,\n\t \"get_power\"},\n\t{\n\t IPW2100_PRIV_SET_LONGPREAMBLE,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"set_preamble\"},\n\t{\n\t IPW2100_PRIV_GET_LONGPREAMBLE,\n\t 0, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | IFNAMSIZ, \"get_preamble\"},\n#ifdef CONFIG_IPW2100_MONITOR\n\t{\n\t IPW2100_PRIV_SET_CRC_CHECK,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, 0, \"set_crc_check\"},\n\t{\n\t IPW2100_PRIV_GET_CRC_CHECK,\n\t 0, IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | IFNAMSIZ, \"get_crc_check\"},\n#endif\t\t\t\t \n};\n\nstatic iw_handler ipw2100_private_handler[] = {\n#ifdef CONFIG_IPW2100_MONITOR\n\tipw2100_wx_set_promisc,\n\tipw2100_wx_reset,\n#else\t\t\t\t \n\tNULL,\n\tNULL,\n#endif\t\t\t\t \n\tipw2100_wx_set_powermode,\n\tipw2100_wx_get_powermode,\n\tipw2100_wx_set_preamble,\n\tipw2100_wx_get_preamble,\n#ifdef CONFIG_IPW2100_MONITOR\n\tipw2100_wx_set_crc_check,\n\tipw2100_wx_get_crc_check,\n#else\t\t\t\t \n\tNULL,\n\tNULL,\n#endif\t\t\t\t \n};\n\n \nstatic struct iw_statistics *ipw2100_wx_wireless_stats(struct net_device *dev)\n{\n\tenum {\n\t\tPOOR = 30,\n\t\tFAIR = 60,\n\t\tGOOD = 80,\n\t\tVERY_GOOD = 90,\n\t\tEXCELLENT = 95,\n\t\tPERFECT = 100\n\t};\n\tint rssi_qual;\n\tint tx_qual;\n\tint beacon_qual;\n\tint quality;\n\n\tstruct ipw2100_priv *priv = libipw_priv(dev);\n\tstruct iw_statistics *wstats;\n\tu32 rssi, tx_retries, missed_beacons, tx_failures;\n\tu32 ord_len = sizeof(u32);\n\n\tif (!priv)\n\t\treturn (struct iw_statistics *)NULL;\n\n\twstats = &priv->wstats;\n\n\t \n\tif (!(priv->status & STATUS_ASSOCIATED)) {\n\t\twstats->miss.beacon = 0;\n\t\twstats->discard.retries = 0;\n\t\twstats->qual.qual = 0;\n\t\twstats->qual.level = 0;\n\t\twstats->qual.noise = 0;\n\t\twstats->qual.updated = 7;\n\t\twstats->qual.updated |= IW_QUAL_NOISE_INVALID |\n\t\t    IW_QUAL_QUAL_INVALID | IW_QUAL_LEVEL_INVALID;\n\t\treturn wstats;\n\t}\n\n\tif (ipw2100_get_ordinal(priv, IPW_ORD_STAT_PERCENT_MISSED_BCNS,\n\t\t\t\t&missed_beacons, &ord_len))\n\t\tgoto fail_get_ordinal;\n\n\t \n\tif (!(priv->status & STATUS_ASSOCIATED)) {\n\t\twstats->qual.qual = 0;\n\t\twstats->qual.level = 0;\n\t} else {\n\t\tif (ipw2100_get_ordinal(priv, IPW_ORD_RSSI_AVG_CURR,\n\t\t\t\t\t&rssi, &ord_len))\n\t\t\tgoto fail_get_ordinal;\n\t\twstats->qual.level = rssi + IPW2100_RSSI_TO_DBM;\n\t\tif (rssi < 10)\n\t\t\trssi_qual = rssi * POOR / 10;\n\t\telse if (rssi < 15)\n\t\t\trssi_qual = (rssi - 10) * (FAIR - POOR) / 5 + POOR;\n\t\telse if (rssi < 20)\n\t\t\trssi_qual = (rssi - 15) * (GOOD - FAIR) / 5 + FAIR;\n\t\telse if (rssi < 30)\n\t\t\trssi_qual = (rssi - 20) * (VERY_GOOD - GOOD) /\n\t\t\t    10 + GOOD;\n\t\telse\n\t\t\trssi_qual = (rssi - 30) * (PERFECT - VERY_GOOD) /\n\t\t\t    10 + VERY_GOOD;\n\n\t\tif (ipw2100_get_ordinal(priv, IPW_ORD_STAT_PERCENT_RETRIES,\n\t\t\t\t\t&tx_retries, &ord_len))\n\t\t\tgoto fail_get_ordinal;\n\n\t\tif (tx_retries > 75)\n\t\t\ttx_qual = (90 - tx_retries) * POOR / 15;\n\t\telse if (tx_retries > 70)\n\t\t\ttx_qual = (75 - tx_retries) * (FAIR - POOR) / 5 + POOR;\n\t\telse if (tx_retries > 65)\n\t\t\ttx_qual = (70 - tx_retries) * (GOOD - FAIR) / 5 + FAIR;\n\t\telse if (tx_retries > 50)\n\t\t\ttx_qual = (65 - tx_retries) * (VERY_GOOD - GOOD) /\n\t\t\t    15 + GOOD;\n\t\telse\n\t\t\ttx_qual = (50 - tx_retries) *\n\t\t\t    (PERFECT - VERY_GOOD) / 50 + VERY_GOOD;\n\n\t\tif (missed_beacons > 50)\n\t\t\tbeacon_qual = (60 - missed_beacons) * POOR / 10;\n\t\telse if (missed_beacons > 40)\n\t\t\tbeacon_qual = (50 - missed_beacons) * (FAIR - POOR) /\n\t\t\t    10 + POOR;\n\t\telse if (missed_beacons > 32)\n\t\t\tbeacon_qual = (40 - missed_beacons) * (GOOD - FAIR) /\n\t\t\t    18 + FAIR;\n\t\telse if (missed_beacons > 20)\n\t\t\tbeacon_qual = (32 - missed_beacons) *\n\t\t\t    (VERY_GOOD - GOOD) / 20 + GOOD;\n\t\telse\n\t\t\tbeacon_qual = (20 - missed_beacons) *\n\t\t\t    (PERFECT - VERY_GOOD) / 20 + VERY_GOOD;\n\n\t\tquality = min(tx_qual, rssi_qual);\n\t\tquality = min(beacon_qual, quality);\n\n#ifdef CONFIG_IPW2100_DEBUG\n\t\tif (beacon_qual == quality)\n\t\t\tIPW_DEBUG_WX(\"Quality clamped by Missed Beacons\\n\");\n\t\telse if (tx_qual == quality)\n\t\t\tIPW_DEBUG_WX(\"Quality clamped by Tx Retries\\n\");\n\t\telse if (quality != 100)\n\t\t\tIPW_DEBUG_WX(\"Quality clamped by Signal Strength\\n\");\n\t\telse\n\t\t\tIPW_DEBUG_WX(\"Quality not clamped.\\n\");\n#endif\n\n\t\twstats->qual.qual = quality;\n\t\twstats->qual.level = rssi + IPW2100_RSSI_TO_DBM;\n\t}\n\n\twstats->qual.noise = 0;\n\twstats->qual.updated = 7;\n\twstats->qual.updated |= IW_QUAL_NOISE_INVALID;\n\n\t \n\twstats->miss.beacon = missed_beacons;\n\n\tif (ipw2100_get_ordinal(priv, IPW_ORD_STAT_TX_FAILURES,\n\t\t\t\t&tx_failures, &ord_len))\n\t\tgoto fail_get_ordinal;\n\twstats->discard.retries = tx_failures;\n\n\treturn wstats;\n\n      fail_get_ordinal:\n\tIPW_DEBUG_WX(\"failed querying ordinals.\\n\");\n\n\treturn (struct iw_statistics *)NULL;\n}\n\nstatic const struct iw_handler_def ipw2100_wx_handler_def = {\n\t.standard = ipw2100_wx_handlers,\n\t.num_standard = ARRAY_SIZE(ipw2100_wx_handlers),\n\t.num_private = ARRAY_SIZE(ipw2100_private_handler),\n\t.num_private_args = ARRAY_SIZE(ipw2100_private_args),\n\t.private = (iw_handler *) ipw2100_private_handler,\n\t.private_args = (struct iw_priv_args *)ipw2100_private_args,\n\t.get_wireless_stats = ipw2100_wx_wireless_stats,\n};\n\nstatic void ipw2100_wx_event_work(struct work_struct *work)\n{\n\tstruct ipw2100_priv *priv =\n\t\tcontainer_of(work, struct ipw2100_priv, wx_event_work.work);\n\tunion iwreq_data wrqu;\n\tunsigned int len = ETH_ALEN;\n\n\tif (priv->status & STATUS_STOPPING)\n\t\treturn;\n\n\tmutex_lock(&priv->action_mutex);\n\n\tIPW_DEBUG_WX(\"enter\\n\");\n\n\tmutex_unlock(&priv->action_mutex);\n\n\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\n\t \n\tif (!(priv->status & (STATUS_ASSOCIATING | STATUS_ASSOCIATED)) ||\n\t    priv->status & STATUS_RF_KILL_MASK ||\n\t    ipw2100_get_ordinal(priv, IPW_ORD_STAT_ASSN_AP_BSSID,\n\t\t\t\t&priv->bssid, &len)) {\n\t\teth_zero_addr(wrqu.ap_addr.sa_data);\n\t} else {\n\t\t \n\t\tmemcpy(wrqu.ap_addr.sa_data, priv->bssid, ETH_ALEN);\n\t\tmemcpy(priv->ieee->bssid, priv->bssid, ETH_ALEN);\n\t\tpriv->status &= ~STATUS_ASSOCIATING;\n\t\tpriv->status |= STATUS_ASSOCIATED;\n\t\tnetif_carrier_on(priv->net_dev);\n\t\tnetif_wake_queue(priv->net_dev);\n\t}\n\n\tif (!(priv->status & STATUS_ASSOCIATED)) {\n\t\tIPW_DEBUG_WX(\"Configuring ESSID\\n\");\n\t\tmutex_lock(&priv->action_mutex);\n\t\t \n\t\tif (priv->config & CFG_STATIC_ESSID)\n\t\t\tipw2100_set_essid(priv, priv->essid, priv->essid_len,\n\t\t\t\t\t  0);\n\t\telse\n\t\t\tipw2100_set_essid(priv, NULL, 0, 0);\n\t\tmutex_unlock(&priv->action_mutex);\n\t}\n\n\twireless_send_event(priv->net_dev, SIOCGIWAP, &wrqu, NULL);\n}\n\n#define IPW2100_FW_MAJOR_VERSION 1\n#define IPW2100_FW_MINOR_VERSION 3\n\n#define IPW2100_FW_MINOR(x) ((x & 0xff) >> 8)\n#define IPW2100_FW_MAJOR(x) (x & 0xff)\n\n#define IPW2100_FW_VERSION ((IPW2100_FW_MINOR_VERSION << 8) | \\\n                             IPW2100_FW_MAJOR_VERSION)\n\n#define IPW2100_FW_PREFIX \"ipw2100-\" __stringify(IPW2100_FW_MAJOR_VERSION) \\\n\".\" __stringify(IPW2100_FW_MINOR_VERSION)\n\n#define IPW2100_FW_NAME(x) IPW2100_FW_PREFIX \"\" x \".fw\"\n\n \n\nstruct ipw2100_fw_header {\n\tshort version;\n\tshort mode;\n\tunsigned int fw_size;\n\tunsigned int uc_size;\n} __packed;\n\nstatic int ipw2100_mod_firmware_load(struct ipw2100_fw *fw)\n{\n\tstruct ipw2100_fw_header *h =\n\t    (struct ipw2100_fw_header *)fw->fw_entry->data;\n\n\tif (IPW2100_FW_MAJOR(h->version) != IPW2100_FW_MAJOR_VERSION) {\n\t\tprintk(KERN_WARNING DRV_NAME \": Firmware image not compatible \"\n\t\t       \"(detected version id of %u). \"\n\t\t       \"See Documentation/networking/device_drivers/wifi/intel/ipw2100.rst\\n\",\n\t\t       h->version);\n\t\treturn 1;\n\t}\n\n\tfw->version = h->version;\n\tfw->fw.data = fw->fw_entry->data + sizeof(struct ipw2100_fw_header);\n\tfw->fw.size = h->fw_size;\n\tfw->uc.data = fw->fw.data + h->fw_size;\n\tfw->uc.size = h->uc_size;\n\n\treturn 0;\n}\n\nstatic int ipw2100_get_firmware(struct ipw2100_priv *priv,\n\t\t\t\tstruct ipw2100_fw *fw)\n{\n\tchar *fw_name;\n\tint rc;\n\n\tIPW_DEBUG_INFO(\"%s: Using hotplug firmware load.\\n\",\n\t\t       priv->net_dev->name);\n\n\tswitch (priv->ieee->iw_mode) {\n\tcase IW_MODE_ADHOC:\n\t\tfw_name = IPW2100_FW_NAME(\"-i\");\n\t\tbreak;\n#ifdef CONFIG_IPW2100_MONITOR\n\tcase IW_MODE_MONITOR:\n\t\tfw_name = IPW2100_FW_NAME(\"-p\");\n\t\tbreak;\n#endif\n\tcase IW_MODE_INFRA:\n\tdefault:\n\t\tfw_name = IPW2100_FW_NAME(\"\");\n\t\tbreak;\n\t}\n\n\trc = request_firmware(&fw->fw_entry, fw_name, &priv->pci_dev->dev);\n\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR DRV_NAME \": \"\n\t\t       \"%s: Firmware '%s' not available or load failed.\\n\",\n\t\t       priv->net_dev->name, fw_name);\n\t\treturn rc;\n\t}\n\tIPW_DEBUG_INFO(\"firmware data %p size %zd\\n\", fw->fw_entry->data,\n\t\t       fw->fw_entry->size);\n\n\tipw2100_mod_firmware_load(fw);\n\n\treturn 0;\n}\n\nMODULE_FIRMWARE(IPW2100_FW_NAME(\"-i\"));\n#ifdef CONFIG_IPW2100_MONITOR\nMODULE_FIRMWARE(IPW2100_FW_NAME(\"-p\"));\n#endif\nMODULE_FIRMWARE(IPW2100_FW_NAME(\"\"));\n\nstatic void ipw2100_release_firmware(struct ipw2100_priv *priv,\n\t\t\t\t     struct ipw2100_fw *fw)\n{\n\tfw->version = 0;\n\trelease_firmware(fw->fw_entry);\n\tfw->fw_entry = NULL;\n}\n\nstatic int ipw2100_get_fwversion(struct ipw2100_priv *priv, char *buf,\n\t\t\t\t size_t max)\n{\n\tchar ver[MAX_FW_VERSION_LEN];\n\tu32 len = MAX_FW_VERSION_LEN;\n\tu32 tmp;\n\tint i;\n\t \n\tif (ipw2100_get_ordinal(priv, IPW_ORD_STAT_FW_VER_NUM, ver, &len))\n\t\treturn -EIO;\n\ttmp = max;\n\tif (len >= max)\n\t\tlen = max - 1;\n\tfor (i = 0; i < len; i++)\n\t\tbuf[i] = ver[i];\n\tbuf[i] = '\\0';\n\treturn tmp;\n}\n\nstatic int ipw2100_get_ucodeversion(struct ipw2100_priv *priv, char *buf,\n\t\t\t\t    size_t max)\n{\n\tu32 ver;\n\tu32 len = sizeof(ver);\n\t \n\tif (ipw2100_get_ordinal(priv, IPW_ORD_UCODE_VERSION, &ver, &len))\n\t\treturn -EIO;\n\treturn snprintf(buf, max, \"%08X\", ver);\n}\n\n \nstatic int ipw2100_fw_download(struct ipw2100_priv *priv, struct ipw2100_fw *fw)\n{\n\t \n\tunsigned int addr;\n\tunsigned short len;\n\n\tconst unsigned char *firmware_data = fw->fw.data;\n\tunsigned int firmware_data_left = fw->fw.size;\n\n\twhile (firmware_data_left > 0) {\n\t\taddr = *(u32 *) (firmware_data);\n\t\tfirmware_data += 4;\n\t\tfirmware_data_left -= 4;\n\n\t\tlen = *(u16 *) (firmware_data);\n\t\tfirmware_data += 2;\n\t\tfirmware_data_left -= 2;\n\n\t\tif (len > 32) {\n\t\t\tprintk(KERN_ERR DRV_NAME \": \"\n\t\t\t       \"Invalid firmware run-length of %d bytes\\n\",\n\t\t\t       len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\twrite_nic_memory(priv->net_dev, addr, len, firmware_data);\n\t\tfirmware_data += len;\n\t\tfirmware_data_left -= len;\n\t}\n\n\treturn 0;\n}\n\nstruct symbol_alive_response {\n\tu8 cmd_id;\n\tu8 seq_num;\n\tu8 ucode_rev;\n\tu8 eeprom_valid;\n\tu16 valid_flags;\n\tu8 IEEE_addr[6];\n\tu16 flags;\n\tu16 pcb_rev;\n\tu16 clock_settle_time;\t\n\tu16 powerup_settle_time;\t\n\tu16 hop_settle_time;\t\n\tu8 date[3];\t\t\n\tu8 time[2];\t\t\n\tu8 ucode_valid;\n};\n\nstatic int ipw2100_ucode_download(struct ipw2100_priv *priv,\n\t\t\t\t  struct ipw2100_fw *fw)\n{\n\tstruct net_device *dev = priv->net_dev;\n\tconst unsigned char *microcode_data = fw->uc.data;\n\tunsigned int microcode_data_left = fw->uc.size;\n\tvoid __iomem *reg = priv->ioaddr;\n\n\tstruct symbol_alive_response response;\n\tint i, j;\n\tu8 data;\n\n\t \n\twrite_nic_word(dev, IPW2100_CONTROL_REG, 0x703);\n\treadl(reg);\n\twrite_nic_word(dev, IPW2100_CONTROL_REG, 0x707);\n\treadl(reg);\n\n\t \n\twrite_nic_byte(dev, 0x210014, 0x72);\t \n\treadl(reg);\n\twrite_nic_byte(dev, 0x210014, 0x72);\t \n\treadl(reg);\n\n\t \n\twrite_nic_byte(dev, 0x210000, 0x40);\n\treadl(reg);\n\twrite_nic_byte(dev, 0x210000, 0x0);\n\treadl(reg);\n\twrite_nic_byte(dev, 0x210000, 0x40);\n\treadl(reg);\n\n\t \n\n\twhile (microcode_data_left > 0) {\n\t\twrite_nic_byte(dev, 0x210010, *microcode_data++);\n\t\twrite_nic_byte(dev, 0x210010, *microcode_data++);\n\t\tmicrocode_data_left -= 2;\n\t}\n\n\t \n\twrite_nic_byte(dev, 0x210000, 0x0);\n\treadl(reg);\n\n\t \n\twrite_nic_byte(dev, 0x210000, 0x0);\n\treadl(reg);\n\twrite_nic_byte(dev, 0x210000, 0x80);\n\treadl(reg);\n\n\t \n\twrite_nic_word(dev, IPW2100_CONTROL_REG, 0x703);\n\treadl(reg);\n\twrite_nic_word(dev, IPW2100_CONTROL_REG, 0x707);\n\treadl(reg);\n\n\t \n\twrite_nic_byte(dev, 0x210014, 0x72);\t\n\treadl(reg);\n\twrite_nic_byte(dev, 0x210014, 0x72);\t\n\treadl(reg);\n\n\t \n\twrite_nic_byte(dev, 0x210000, 0x00);\t\n\treadl(reg);\n\twrite_nic_byte(dev, 0x210000, 0x80);\t\n\n\t \n\tfor (i = 0; i < 10; i++) {\n\t\tudelay(10);\n\n\t\t \n\t\tread_nic_byte(dev, 0x210000, &data);\n\t\tif (data & 0x1)\n\t\t\tbreak;\n\t}\n\n\tif (i == 10) {\n\t\tprintk(KERN_ERR DRV_NAME \": %s: Error initializing Symbol\\n\",\n\t\t       dev->name);\n\t\treturn -EIO;\n\t}\n\n\t \n\tfor (i = 0; i < 30; i++) {\n\t\t \n\t\tfor (j = 0;\n\t\t     j < (sizeof(struct symbol_alive_response) >> 1); j++)\n\t\t\tread_nic_word(dev, 0x210004, ((u16 *) & response) + j);\n\n\t\tif ((response.cmd_id == 1) && (response.ucode_valid == 0x1))\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\n\tif (i == 30) {\n\t\tprintk(KERN_ERR DRV_NAME\n\t\t       \": %s: No response from Symbol - hw not alive\\n\",\n\t\t       dev->name);\n\t\tprintk_buf(IPW_DL_ERROR, (u8 *) & response, sizeof(response));\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}