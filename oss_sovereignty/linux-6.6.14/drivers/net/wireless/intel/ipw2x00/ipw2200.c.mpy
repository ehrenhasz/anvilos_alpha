{
  "module_name": "ipw2200.c",
  "hash_id": "0604b9ea4589ff64a51039af0dc4867ad63289066f02563f39323f43402b5a33",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/ipw2x00/ipw2200.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <net/cfg80211-wext.h>\n#include \"ipw2200.h\"\n#include \"ipw.h\"\n\n\n#ifndef KBUILD_EXTMOD\n#define VK \"k\"\n#else\n#define VK\n#endif\n\n#ifdef CONFIG_IPW2200_DEBUG\n#define VD \"d\"\n#else\n#define VD\n#endif\n\n#ifdef CONFIG_IPW2200_MONITOR\n#define VM \"m\"\n#else\n#define VM\n#endif\n\n#ifdef CONFIG_IPW2200_PROMISCUOUS\n#define VP \"p\"\n#else\n#define VP\n#endif\n\n#ifdef CONFIG_IPW2200_RADIOTAP\n#define VR \"r\"\n#else\n#define VR\n#endif\n\n#ifdef CONFIG_IPW2200_QOS\n#define VQ \"q\"\n#else\n#define VQ\n#endif\n\n#define IPW2200_VERSION \"1.2.2\" VK VD VM VP VR VQ\n#define DRV_DESCRIPTION\t\"Intel(R) PRO/Wireless 2200/2915 Network Driver\"\n#define DRV_COPYRIGHT\t\"Copyright(c) 2003-2006 Intel Corporation\"\n#define DRV_VERSION     IPW2200_VERSION\n\n#define ETH_P_80211_STATS (ETH_P_80211_RAW + 1)\n\nMODULE_DESCRIPTION(DRV_DESCRIPTION);\nMODULE_VERSION(DRV_VERSION);\nMODULE_AUTHOR(DRV_COPYRIGHT);\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"ipw2200-ibss.fw\");\n#ifdef CONFIG_IPW2200_MONITOR\nMODULE_FIRMWARE(\"ipw2200-sniffer.fw\");\n#endif\nMODULE_FIRMWARE(\"ipw2200-bss.fw\");\n\nstatic int cmdlog = 0;\nstatic int debug = 0;\nstatic int default_channel = 0;\nstatic int network_mode = 0;\n\nstatic u32 ipw_debug_level;\nstatic int associate;\nstatic int auto_create = 1;\nstatic int led_support = 1;\nstatic int disable = 0;\nstatic int bt_coexist = 0;\nstatic int hwcrypto = 0;\nstatic int roaming = 1;\nstatic const char ipw_modes[] = {\n\t'a', 'b', 'g', '?'\n};\nstatic int antenna = CFG_SYS_ANTENNA_BOTH;\n\n#ifdef CONFIG_IPW2200_PROMISCUOUS\nstatic int rtap_iface = 0;      \n#endif\n\nstatic struct ieee80211_rate ipw2200_rates[] = {\n\t{ .bitrate = 10 },\n\t{ .bitrate = 20, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 55, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 110, .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 60 },\n\t{ .bitrate = 90 },\n\t{ .bitrate = 120 },\n\t{ .bitrate = 180 },\n\t{ .bitrate = 240 },\n\t{ .bitrate = 360 },\n\t{ .bitrate = 480 },\n\t{ .bitrate = 540 }\n};\n\n#define ipw2200_a_rates\t\t(ipw2200_rates + 4)\n#define ipw2200_num_a_rates\t8\n#define ipw2200_bg_rates\t(ipw2200_rates + 0)\n#define ipw2200_num_bg_rates\t12\n\n \n#define ieee80211chan2mhz(x) \\\n\t(((x) <= 14) ? \\\n\t(((x) == 14) ? 2484 : ((x) * 5) + 2407) : \\\n\t((x) + 1000) * 5)\n\n#ifdef CONFIG_IPW2200_QOS\nstatic int qos_enable = 0;\nstatic int qos_burst_enable = 0;\nstatic int qos_no_ack_mask = 0;\nstatic int burst_duration_CCK = 0;\nstatic int burst_duration_OFDM = 0;\n\nstatic struct libipw_qos_parameters def_qos_parameters_OFDM = {\n\t{QOS_TX0_CW_MIN_OFDM, QOS_TX1_CW_MIN_OFDM, QOS_TX2_CW_MIN_OFDM,\n\t QOS_TX3_CW_MIN_OFDM},\n\t{QOS_TX0_CW_MAX_OFDM, QOS_TX1_CW_MAX_OFDM, QOS_TX2_CW_MAX_OFDM,\n\t QOS_TX3_CW_MAX_OFDM},\n\t{QOS_TX0_AIFS, QOS_TX1_AIFS, QOS_TX2_AIFS, QOS_TX3_AIFS},\n\t{QOS_TX0_ACM, QOS_TX1_ACM, QOS_TX2_ACM, QOS_TX3_ACM},\n\t{QOS_TX0_TXOP_LIMIT_OFDM, QOS_TX1_TXOP_LIMIT_OFDM,\n\t QOS_TX2_TXOP_LIMIT_OFDM, QOS_TX3_TXOP_LIMIT_OFDM}\n};\n\nstatic struct libipw_qos_parameters def_qos_parameters_CCK = {\n\t{QOS_TX0_CW_MIN_CCK, QOS_TX1_CW_MIN_CCK, QOS_TX2_CW_MIN_CCK,\n\t QOS_TX3_CW_MIN_CCK},\n\t{QOS_TX0_CW_MAX_CCK, QOS_TX1_CW_MAX_CCK, QOS_TX2_CW_MAX_CCK,\n\t QOS_TX3_CW_MAX_CCK},\n\t{QOS_TX0_AIFS, QOS_TX1_AIFS, QOS_TX2_AIFS, QOS_TX3_AIFS},\n\t{QOS_TX0_ACM, QOS_TX1_ACM, QOS_TX2_ACM, QOS_TX3_ACM},\n\t{QOS_TX0_TXOP_LIMIT_CCK, QOS_TX1_TXOP_LIMIT_CCK, QOS_TX2_TXOP_LIMIT_CCK,\n\t QOS_TX3_TXOP_LIMIT_CCK}\n};\n\nstatic struct libipw_qos_parameters def_parameters_OFDM = {\n\t{DEF_TX0_CW_MIN_OFDM, DEF_TX1_CW_MIN_OFDM, DEF_TX2_CW_MIN_OFDM,\n\t DEF_TX3_CW_MIN_OFDM},\n\t{DEF_TX0_CW_MAX_OFDM, DEF_TX1_CW_MAX_OFDM, DEF_TX2_CW_MAX_OFDM,\n\t DEF_TX3_CW_MAX_OFDM},\n\t{DEF_TX0_AIFS, DEF_TX1_AIFS, DEF_TX2_AIFS, DEF_TX3_AIFS},\n\t{DEF_TX0_ACM, DEF_TX1_ACM, DEF_TX2_ACM, DEF_TX3_ACM},\n\t{DEF_TX0_TXOP_LIMIT_OFDM, DEF_TX1_TXOP_LIMIT_OFDM,\n\t DEF_TX2_TXOP_LIMIT_OFDM, DEF_TX3_TXOP_LIMIT_OFDM}\n};\n\nstatic struct libipw_qos_parameters def_parameters_CCK = {\n\t{DEF_TX0_CW_MIN_CCK, DEF_TX1_CW_MIN_CCK, DEF_TX2_CW_MIN_CCK,\n\t DEF_TX3_CW_MIN_CCK},\n\t{DEF_TX0_CW_MAX_CCK, DEF_TX1_CW_MAX_CCK, DEF_TX2_CW_MAX_CCK,\n\t DEF_TX3_CW_MAX_CCK},\n\t{DEF_TX0_AIFS, DEF_TX1_AIFS, DEF_TX2_AIFS, DEF_TX3_AIFS},\n\t{DEF_TX0_ACM, DEF_TX1_ACM, DEF_TX2_ACM, DEF_TX3_ACM},\n\t{DEF_TX0_TXOP_LIMIT_CCK, DEF_TX1_TXOP_LIMIT_CCK, DEF_TX2_TXOP_LIMIT_CCK,\n\t DEF_TX3_TXOP_LIMIT_CCK}\n};\n\nstatic u8 qos_oui[QOS_OUI_LEN] = { 0x00, 0x50, 0xF2 };\n\nstatic int from_priority_to_tx_queue[] = {\n\tIPW_TX_QUEUE_1, IPW_TX_QUEUE_2, IPW_TX_QUEUE_2, IPW_TX_QUEUE_1,\n\tIPW_TX_QUEUE_3, IPW_TX_QUEUE_3, IPW_TX_QUEUE_4, IPW_TX_QUEUE_4\n};\n\nstatic u32 ipw_qos_get_burst_duration(struct ipw_priv *priv);\n\nstatic int ipw_send_qos_params_command(struct ipw_priv *priv, struct libipw_qos_parameters\n\t\t\t\t       *qos_param);\nstatic int ipw_send_qos_info_command(struct ipw_priv *priv, struct libipw_qos_information_element\n\t\t\t\t     *qos_param);\n#endif\t\t\t\t \n\nstatic struct iw_statistics *ipw_get_wireless_stats(struct net_device *dev);\nstatic void ipw_remove_current_network(struct ipw_priv *priv);\nstatic void ipw_rx(struct ipw_priv *priv);\nstatic int ipw_queue_tx_reclaim(struct ipw_priv *priv,\n\t\t\t\tstruct clx2_tx_queue *txq, int qindex);\nstatic int ipw_queue_reset(struct ipw_priv *priv);\n\nstatic int ipw_queue_tx_hcmd(struct ipw_priv *priv, int hcmd, const void *buf,\n\t\t\t     int len, int sync);\n\nstatic void ipw_tx_queue_free(struct ipw_priv *);\n\nstatic struct ipw_rx_queue *ipw_rx_queue_alloc(struct ipw_priv *);\nstatic void ipw_rx_queue_free(struct ipw_priv *, struct ipw_rx_queue *);\nstatic void ipw_rx_queue_replenish(void *);\nstatic int ipw_up(struct ipw_priv *);\nstatic void ipw_bg_up(struct work_struct *work);\nstatic void ipw_down(struct ipw_priv *);\nstatic void ipw_bg_down(struct work_struct *work);\nstatic int ipw_config(struct ipw_priv *);\nstatic int init_supported_rates(struct ipw_priv *priv,\n\t\t\t\tstruct ipw_supported_rates *prates);\nstatic void ipw_set_hwcrypto_keys(struct ipw_priv *);\nstatic void ipw_send_wep_keys(struct ipw_priv *, int);\n\nstatic int snprint_line(char *buf, size_t count,\n\t\t\tconst u8 * data, u32 len, u32 ofs)\n{\n\tint out, i, j, l;\n\tchar c;\n\n\tout = scnprintf(buf, count, \"%08X\", ofs);\n\n\tfor (l = 0, i = 0; i < 2; i++) {\n\t\tout += scnprintf(buf + out, count - out, \" \");\n\t\tfor (j = 0; j < 8 && l < len; j++, l++)\n\t\t\tout += scnprintf(buf + out, count - out, \"%02X \",\n\t\t\t\t\tdata[(i * 8 + j)]);\n\t\tfor (; j < 8; j++)\n\t\t\tout += scnprintf(buf + out, count - out, \"   \");\n\t}\n\n\tout += scnprintf(buf + out, count - out, \" \");\n\tfor (l = 0, i = 0; i < 2; i++) {\n\t\tout += scnprintf(buf + out, count - out, \" \");\n\t\tfor (j = 0; j < 8 && l < len; j++, l++) {\n\t\t\tc = data[(i * 8 + j)];\n\t\t\tif (!isascii(c) || !isprint(c))\n\t\t\t\tc = '.';\n\n\t\t\tout += scnprintf(buf + out, count - out, \"%c\", c);\n\t\t}\n\n\t\tfor (; j < 8; j++)\n\t\t\tout += scnprintf(buf + out, count - out, \" \");\n\t}\n\n\treturn out;\n}\n\nstatic void printk_buf(int level, const u8 * data, u32 len)\n{\n\tchar line[81];\n\tu32 ofs = 0;\n\tif (!(ipw_debug_level & level))\n\t\treturn;\n\n\twhile (len) {\n\t\tsnprint_line(line, sizeof(line), &data[ofs],\n\t\t\t     min(len, 16U), ofs);\n\t\tprintk(KERN_DEBUG \"%s\\n\", line);\n\t\tofs += 16;\n\t\tlen -= min(len, 16U);\n\t}\n}\n\nstatic int snprintk_buf(u8 * output, size_t size, const u8 * data, size_t len)\n{\n\tsize_t out = size;\n\tu32 ofs = 0;\n\tint total = 0;\n\n\twhile (size && len) {\n\t\tout = snprint_line(output, size, &data[ofs],\n\t\t\t\t   min_t(size_t, len, 16U), ofs);\n\n\t\tofs += 16;\n\t\toutput += out;\n\t\tsize -= out;\n\t\tlen -= min_t(size_t, len, 16U);\n\t\ttotal += out;\n\t}\n\treturn total;\n}\n\n \nstatic u32 _ipw_read_reg32(struct ipw_priv *priv, u32 reg);\n#define ipw_read_reg32(a, b) _ipw_read_reg32(a, b)\n\n \nstatic u8 _ipw_read_reg8(struct ipw_priv *ipw, u32 reg);\n#define ipw_read_reg8(a, b) _ipw_read_reg8(a, b)\n\n \nstatic void _ipw_write_reg8(struct ipw_priv *priv, u32 reg, u8 value);\nstatic inline void ipw_write_reg8(struct ipw_priv *a, u32 b, u8 c)\n{\n\tIPW_DEBUG_IO(\"%s %d: write_indirect8(0x%08X, 0x%08X)\\n\", __FILE__,\n\t\t     __LINE__, (u32) (b), (u32) (c));\n\t_ipw_write_reg8(a, b, c);\n}\n\n \nstatic void _ipw_write_reg16(struct ipw_priv *priv, u32 reg, u16 value);\nstatic inline void ipw_write_reg16(struct ipw_priv *a, u32 b, u16 c)\n{\n\tIPW_DEBUG_IO(\"%s %d: write_indirect16(0x%08X, 0x%08X)\\n\", __FILE__,\n\t\t     __LINE__, (u32) (b), (u32) (c));\n\t_ipw_write_reg16(a, b, c);\n}\n\n \nstatic void _ipw_write_reg32(struct ipw_priv *priv, u32 reg, u32 value);\nstatic inline void ipw_write_reg32(struct ipw_priv *a, u32 b, u32 c)\n{\n\tIPW_DEBUG_IO(\"%s %d: write_indirect32(0x%08X, 0x%08X)\\n\", __FILE__,\n\t\t     __LINE__, (u32) (b), (u32) (c));\n\t_ipw_write_reg32(a, b, c);\n}\n\n \nstatic inline void _ipw_write8(struct ipw_priv *ipw, unsigned long ofs,\n\t\tu8 val)\n{\n\twriteb(val, ipw->hw_base + ofs);\n}\n\n \n#define ipw_write8(ipw, ofs, val) do { \\\n\tIPW_DEBUG_IO(\"%s %d: write_direct8(0x%08X, 0x%08X)\\n\", __FILE__, \\\n\t\t\t__LINE__, (u32)(ofs), (u32)(val)); \\\n\t_ipw_write8(ipw, ofs, val); \\\n} while (0)\n\n \nstatic inline void _ipw_write16(struct ipw_priv *ipw, unsigned long ofs,\n\t\tu16 val)\n{\n\twritew(val, ipw->hw_base + ofs);\n}\n\n \n#define ipw_write16(ipw, ofs, val) do { \\\n\tIPW_DEBUG_IO(\"%s %d: write_direct16(0x%08X, 0x%08X)\\n\", __FILE__, \\\n\t\t\t__LINE__, (u32)(ofs), (u32)(val)); \\\n\t_ipw_write16(ipw, ofs, val); \\\n} while (0)\n\n \nstatic inline void _ipw_write32(struct ipw_priv *ipw, unsigned long ofs,\n\t\tu32 val)\n{\n\twritel(val, ipw->hw_base + ofs);\n}\n\n \n#define ipw_write32(ipw, ofs, val) do { \\\n\tIPW_DEBUG_IO(\"%s %d: write_direct32(0x%08X, 0x%08X)\\n\", __FILE__, \\\n\t\t\t__LINE__, (u32)(ofs), (u32)(val)); \\\n\t_ipw_write32(ipw, ofs, val); \\\n} while (0)\n\n \nstatic inline u8 _ipw_read8(struct ipw_priv *ipw, unsigned long ofs)\n{\n\treturn readb(ipw->hw_base + ofs);\n}\n\n \n#define ipw_read8(ipw, ofs) ({ \\\n\tIPW_DEBUG_IO(\"%s %d: read_direct8(0x%08X)\\n\", __FILE__, __LINE__, \\\n\t\t\t(u32)(ofs)); \\\n\t_ipw_read8(ipw, ofs); \\\n})\n\n \nstatic inline u32 _ipw_read32(struct ipw_priv *ipw, unsigned long ofs)\n{\n\treturn readl(ipw->hw_base + ofs);\n}\n\n \n#define ipw_read32(ipw, ofs) ({ \\\n\tIPW_DEBUG_IO(\"%s %d: read_direct32(0x%08X)\\n\", __FILE__, __LINE__, \\\n\t\t\t(u32)(ofs)); \\\n\t_ipw_read32(ipw, ofs); \\\n})\n\nstatic void _ipw_read_indirect(struct ipw_priv *, u32, u8 *, int);\n \n#define ipw_read_indirect(a, b, c, d) ({ \\\n\tIPW_DEBUG_IO(\"%s %d: read_indirect(0x%08X) %u bytes\\n\", __FILE__, \\\n\t\t\t__LINE__, (u32)(b), (u32)(d)); \\\n\t_ipw_read_indirect(a, b, c, d); \\\n})\n\n \nstatic void _ipw_write_indirect(struct ipw_priv *priv, u32 addr, u8 * data,\n\t\t\t\tint num);\n#define ipw_write_indirect(a, b, c, d) do { \\\n\tIPW_DEBUG_IO(\"%s %d: write_indirect(0x%08X) %u bytes\\n\", __FILE__, \\\n\t\t\t__LINE__, (u32)(b), (u32)(d)); \\\n\t_ipw_write_indirect(a, b, c, d); \\\n} while (0)\n\n \nstatic void _ipw_write_reg32(struct ipw_priv *priv, u32 reg, u32 value)\n{\n\tIPW_DEBUG_IO(\" %p : reg = 0x%8X : value = 0x%8X\\n\", priv, reg, value);\n\t_ipw_write32(priv, IPW_INDIRECT_ADDR, reg);\n\t_ipw_write32(priv, IPW_INDIRECT_DATA, value);\n}\n\n \nstatic void _ipw_write_reg8(struct ipw_priv *priv, u32 reg, u8 value)\n{\n\tu32 aligned_addr = reg & IPW_INDIRECT_ADDR_MASK;\t \n\tu32 dif_len = reg - aligned_addr;\n\n\tIPW_DEBUG_IO(\" reg = 0x%8X : value = 0x%8X\\n\", reg, value);\n\t_ipw_write32(priv, IPW_INDIRECT_ADDR, aligned_addr);\n\t_ipw_write8(priv, IPW_INDIRECT_DATA + dif_len, value);\n}\n\n \nstatic void _ipw_write_reg16(struct ipw_priv *priv, u32 reg, u16 value)\n{\n\tu32 aligned_addr = reg & IPW_INDIRECT_ADDR_MASK;\t \n\tu32 dif_len = (reg - aligned_addr) & (~0x1ul);\n\n\tIPW_DEBUG_IO(\" reg = 0x%8X : value = 0x%8X\\n\", reg, value);\n\t_ipw_write32(priv, IPW_INDIRECT_ADDR, aligned_addr);\n\t_ipw_write16(priv, IPW_INDIRECT_DATA + dif_len, value);\n}\n\n \nstatic u8 _ipw_read_reg8(struct ipw_priv *priv, u32 reg)\n{\n\tu32 word;\n\t_ipw_write32(priv, IPW_INDIRECT_ADDR, reg & IPW_INDIRECT_ADDR_MASK);\n\tIPW_DEBUG_IO(\" reg = 0x%8X :\\n\", reg);\n\tword = _ipw_read32(priv, IPW_INDIRECT_DATA);\n\treturn (word >> ((reg & 0x3) * 8)) & 0xff;\n}\n\n \nstatic u32 _ipw_read_reg32(struct ipw_priv *priv, u32 reg)\n{\n\tu32 value;\n\n\tIPW_DEBUG_IO(\"%p : reg = 0x%08x\\n\", priv, reg);\n\n\t_ipw_write32(priv, IPW_INDIRECT_ADDR, reg);\n\tvalue = _ipw_read32(priv, IPW_INDIRECT_DATA);\n\tIPW_DEBUG_IO(\" reg = 0x%4X : value = 0x%4x\\n\", reg, value);\n\treturn value;\n}\n\n \n \nstatic void _ipw_read_indirect(struct ipw_priv *priv, u32 addr, u8 * buf,\n\t\t\t       int num)\n{\n\tu32 aligned_addr = addr & IPW_INDIRECT_ADDR_MASK;\t \n\tu32 dif_len = addr - aligned_addr;\n\tu32 i;\n\n\tIPW_DEBUG_IO(\"addr = %i, buf = %p, num = %i\\n\", addr, buf, num);\n\n\tif (num <= 0) {\n\t\treturn;\n\t}\n\n\t \n\tif (unlikely(dif_len)) {\n\t\t_ipw_write32(priv, IPW_INDIRECT_ADDR, aligned_addr);\n\t\t \n\t\tfor (i = dif_len; ((i < 4) && (num > 0)); i++, num--)\n\t\t\t*buf++ = _ipw_read8(priv, IPW_INDIRECT_DATA + i);\n\t\taligned_addr += 4;\n\t}\n\n\t \n\t_ipw_write32(priv, IPW_AUTOINC_ADDR, aligned_addr);\n\tfor (; num >= 4; buf += 4, aligned_addr += 4, num -= 4)\n\t\t*(u32 *) buf = _ipw_read32(priv, IPW_AUTOINC_DATA);\n\n\t \n\tif (unlikely(num)) {\n\t\t_ipw_write32(priv, IPW_INDIRECT_ADDR, aligned_addr);\n\t\tfor (i = 0; num > 0; i++, num--)\n\t\t\t*buf++ = ipw_read8(priv, IPW_INDIRECT_DATA + i);\n\t}\n}\n\n \n \nstatic void _ipw_write_indirect(struct ipw_priv *priv, u32 addr, u8 * buf,\n\t\t\t\tint num)\n{\n\tu32 aligned_addr = addr & IPW_INDIRECT_ADDR_MASK;\t \n\tu32 dif_len = addr - aligned_addr;\n\tu32 i;\n\n\tIPW_DEBUG_IO(\"addr = %i, buf = %p, num = %i\\n\", addr, buf, num);\n\n\tif (num <= 0) {\n\t\treturn;\n\t}\n\n\t \n\tif (unlikely(dif_len)) {\n\t\t_ipw_write32(priv, IPW_INDIRECT_ADDR, aligned_addr);\n\t\t \n\t\tfor (i = dif_len; ((i < 4) && (num > 0)); i++, num--, buf++)\n\t\t\t_ipw_write8(priv, IPW_INDIRECT_DATA + i, *buf);\n\t\taligned_addr += 4;\n\t}\n\n\t \n\t_ipw_write32(priv, IPW_AUTOINC_ADDR, aligned_addr);\n\tfor (; num >= 4; buf += 4, aligned_addr += 4, num -= 4)\n\t\t_ipw_write32(priv, IPW_AUTOINC_DATA, *(u32 *) buf);\n\n\t \n\tif (unlikely(num)) {\n\t\t_ipw_write32(priv, IPW_INDIRECT_ADDR, aligned_addr);\n\t\tfor (i = 0; num > 0; i++, num--, buf++)\n\t\t\t_ipw_write8(priv, IPW_INDIRECT_DATA + i, *buf);\n\t}\n}\n\n \n \nstatic void ipw_write_direct(struct ipw_priv *priv, u32 addr, void *buf,\n\t\t\t     int num)\n{\n\tmemcpy_toio((priv->hw_base + addr), buf, num);\n}\n\n \nstatic inline void ipw_set_bit(struct ipw_priv *priv, u32 reg, u32 mask)\n{\n\tipw_write32(priv, reg, ipw_read32(priv, reg) | mask);\n}\n\n \nstatic inline void ipw_clear_bit(struct ipw_priv *priv, u32 reg, u32 mask)\n{\n\tipw_write32(priv, reg, ipw_read32(priv, reg) & ~mask);\n}\n\nstatic inline void __ipw_enable_interrupts(struct ipw_priv *priv)\n{\n\tif (priv->status & STATUS_INT_ENABLED)\n\t\treturn;\n\tpriv->status |= STATUS_INT_ENABLED;\n\tipw_write32(priv, IPW_INTA_MASK_R, IPW_INTA_MASK_ALL);\n}\n\nstatic inline void __ipw_disable_interrupts(struct ipw_priv *priv)\n{\n\tif (!(priv->status & STATUS_INT_ENABLED))\n\t\treturn;\n\tpriv->status &= ~STATUS_INT_ENABLED;\n\tipw_write32(priv, IPW_INTA_MASK_R, ~IPW_INTA_MASK_ALL);\n}\n\nstatic inline void ipw_enable_interrupts(struct ipw_priv *priv)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->irq_lock, flags);\n\t__ipw_enable_interrupts(priv);\n\tspin_unlock_irqrestore(&priv->irq_lock, flags);\n}\n\nstatic inline void ipw_disable_interrupts(struct ipw_priv *priv)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->irq_lock, flags);\n\t__ipw_disable_interrupts(priv);\n\tspin_unlock_irqrestore(&priv->irq_lock, flags);\n}\n\nstatic char *ipw_error_desc(u32 val)\n{\n\tswitch (val) {\n\tcase IPW_FW_ERROR_OK:\n\t\treturn \"ERROR_OK\";\n\tcase IPW_FW_ERROR_FAIL:\n\t\treturn \"ERROR_FAIL\";\n\tcase IPW_FW_ERROR_MEMORY_UNDERFLOW:\n\t\treturn \"MEMORY_UNDERFLOW\";\n\tcase IPW_FW_ERROR_MEMORY_OVERFLOW:\n\t\treturn \"MEMORY_OVERFLOW\";\n\tcase IPW_FW_ERROR_BAD_PARAM:\n\t\treturn \"BAD_PARAM\";\n\tcase IPW_FW_ERROR_BAD_CHECKSUM:\n\t\treturn \"BAD_CHECKSUM\";\n\tcase IPW_FW_ERROR_NMI_INTERRUPT:\n\t\treturn \"NMI_INTERRUPT\";\n\tcase IPW_FW_ERROR_BAD_DATABASE:\n\t\treturn \"BAD_DATABASE\";\n\tcase IPW_FW_ERROR_ALLOC_FAIL:\n\t\treturn \"ALLOC_FAIL\";\n\tcase IPW_FW_ERROR_DMA_UNDERRUN:\n\t\treturn \"DMA_UNDERRUN\";\n\tcase IPW_FW_ERROR_DMA_STATUS:\n\t\treturn \"DMA_STATUS\";\n\tcase IPW_FW_ERROR_DINO_ERROR:\n\t\treturn \"DINO_ERROR\";\n\tcase IPW_FW_ERROR_EEPROM_ERROR:\n\t\treturn \"EEPROM_ERROR\";\n\tcase IPW_FW_ERROR_SYSASSERT:\n\t\treturn \"SYSASSERT\";\n\tcase IPW_FW_ERROR_FATAL_ERROR:\n\t\treturn \"FATAL_ERROR\";\n\tdefault:\n\t\treturn \"UNKNOWN_ERROR\";\n\t}\n}\n\nstatic void ipw_dump_error_log(struct ipw_priv *priv,\n\t\t\t       struct ipw_fw_error *error)\n{\n\tu32 i;\n\n\tif (!error) {\n\t\tIPW_ERROR(\"Error allocating and capturing error log.  \"\n\t\t\t  \"Nothing to dump.\\n\");\n\t\treturn;\n\t}\n\n\tIPW_ERROR(\"Start IPW Error Log Dump:\\n\");\n\tIPW_ERROR(\"Status: 0x%08X, Config: %08X\\n\",\n\t\t  error->status, error->config);\n\n\tfor (i = 0; i < error->elem_len; i++)\n\t\tIPW_ERROR(\"%s %i 0x%08x  0x%08x  0x%08x  0x%08x  0x%08x\\n\",\n\t\t\t  ipw_error_desc(error->elem[i].desc),\n\t\t\t  error->elem[i].time,\n\t\t\t  error->elem[i].blink1,\n\t\t\t  error->elem[i].blink2,\n\t\t\t  error->elem[i].link1,\n\t\t\t  error->elem[i].link2, error->elem[i].data);\n\tfor (i = 0; i < error->log_len; i++)\n\t\tIPW_ERROR(\"%i\\t0x%08x\\t%i\\n\",\n\t\t\t  error->log[i].time,\n\t\t\t  error->log[i].data, error->log[i].event);\n}\n\nstatic inline int ipw_is_init(struct ipw_priv *priv)\n{\n\treturn (priv->status & STATUS_INIT) ? 1 : 0;\n}\n\nstatic int ipw_get_ordinal(struct ipw_priv *priv, u32 ord, void *val, u32 * len)\n{\n\tu32 addr, field_info, field_len, field_count, total_len;\n\n\tIPW_DEBUG_ORD(\"ordinal = %i\\n\", ord);\n\n\tif (!priv || !val || !len) {\n\t\tIPW_DEBUG_ORD(\"Invalid argument\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!priv->table0_addr || !priv->table1_addr || !priv->table2_addr) {\n\t\tIPW_DEBUG_ORD(\"Access ordinals before initialization\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (IPW_ORD_TABLE_ID_MASK & ord) {\n\tcase IPW_ORD_TABLE_0_MASK:\n\t\t \n\n\t\t \n\t\tord &= IPW_ORD_TABLE_VALUE_MASK;\n\n\t\t \n\t\tif (ord > priv->table0_len) {\n\t\t\tIPW_DEBUG_ORD(\"ordinal value (%i) longer then \"\n\t\t\t\t      \"max (%i)\\n\", ord, priv->table0_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (*len < sizeof(u32)) {\n\t\t\tIPW_DEBUG_ORD(\"ordinal buffer length too small, \"\n\t\t\t\t      \"need %zd\\n\", sizeof(u32));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tIPW_DEBUG_ORD(\"Reading TABLE0[%i] from offset 0x%08x\\n\",\n\t\t\t      ord, priv->table0_addr + (ord << 2));\n\n\t\t*len = sizeof(u32);\n\t\tord <<= 2;\n\t\t*((u32 *) val) = ipw_read32(priv, priv->table0_addr + ord);\n\t\tbreak;\n\n\tcase IPW_ORD_TABLE_1_MASK:\n\t\t \n\n\t\t \n\t\tord &= IPW_ORD_TABLE_VALUE_MASK;\n\n\t\t \n\t\tif (ord > priv->table1_len) {\n\t\t\tIPW_DEBUG_ORD(\"ordinal value too long\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (*len < sizeof(u32)) {\n\t\t\tIPW_DEBUG_ORD(\"ordinal buffer length too small, \"\n\t\t\t\t      \"need %zd\\n\", sizeof(u32));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*((u32 *) val) =\n\t\t    ipw_read_reg32(priv, (priv->table1_addr + (ord << 2)));\n\t\t*len = sizeof(u32);\n\t\tbreak;\n\n\tcase IPW_ORD_TABLE_2_MASK:\n\t\t \n\n\t\t \n\t\tord &= IPW_ORD_TABLE_VALUE_MASK;\n\n\t\t \n\t\tif (ord > priv->table2_len) {\n\t\t\tIPW_DEBUG_ORD(\"ordinal value too long\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\taddr = ipw_read_reg32(priv, priv->table2_addr + (ord << 3));\n\n\t\t \n\t\tfield_info =\n\t\t    ipw_read_reg32(priv,\n\t\t\t\t   priv->table2_addr + (ord << 3) +\n\t\t\t\t   sizeof(u32));\n\n\t\t \n\t\tfield_len = *((u16 *) & field_info);\n\n\t\t \n\t\tfield_count = *(((u16 *) & field_info) + 1);\n\n\t\t \n\t\ttotal_len = field_len * field_count;\n\t\tif (total_len > *len) {\n\t\t\t*len = total_len;\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t*len = total_len;\n\t\tif (!total_len)\n\t\t\treturn 0;\n\n\t\tIPW_DEBUG_ORD(\"addr = 0x%08x, total_len = %i, \"\n\t\t\t      \"field_info = 0x%08x\\n\",\n\t\t\t      addr, total_len, field_info);\n\t\tipw_read_indirect(priv, addr, val, total_len);\n\t\tbreak;\n\n\tdefault:\n\t\tIPW_DEBUG_ORD(\"Invalid ordinal!\\n\");\n\t\treturn -EINVAL;\n\n\t}\n\n\treturn 0;\n}\n\nstatic void ipw_init_ordinals(struct ipw_priv *priv)\n{\n\tpriv->table0_addr = IPW_ORDINALS_TABLE_LOWER;\n\tpriv->table0_len = ipw_read32(priv, priv->table0_addr);\n\n\tIPW_DEBUG_ORD(\"table 0 offset at 0x%08x, len = %i\\n\",\n\t\t      priv->table0_addr, priv->table0_len);\n\n\tpriv->table1_addr = ipw_read32(priv, IPW_ORDINALS_TABLE_1);\n\tpriv->table1_len = ipw_read_reg32(priv, priv->table1_addr);\n\n\tIPW_DEBUG_ORD(\"table 1 offset at 0x%08x, len = %i\\n\",\n\t\t      priv->table1_addr, priv->table1_len);\n\n\tpriv->table2_addr = ipw_read32(priv, IPW_ORDINALS_TABLE_2);\n\tpriv->table2_len = ipw_read_reg32(priv, priv->table2_addr);\n\tpriv->table2_len &= 0x0000ffff;\t \n\n\tIPW_DEBUG_ORD(\"table 2 offset at 0x%08x, len = %i\\n\",\n\t\t      priv->table2_addr, priv->table2_len);\n\n}\n\nstatic u32 ipw_register_toggle(u32 reg)\n{\n\treg &= ~IPW_START_STANDBY;\n\tif (reg & IPW_GATE_ODMA)\n\t\treg &= ~IPW_GATE_ODMA;\n\tif (reg & IPW_GATE_IDMA)\n\t\treg &= ~IPW_GATE_IDMA;\n\tif (reg & IPW_GATE_ADMA)\n\t\treg &= ~IPW_GATE_ADMA;\n\treturn reg;\n}\n\n \n#define LD_TIME_LINK_ON msecs_to_jiffies(300)\n#define LD_TIME_LINK_OFF msecs_to_jiffies(2700)\n#define LD_TIME_ACT_ON msecs_to_jiffies(250)\n\nstatic void ipw_led_link_on(struct ipw_priv *priv)\n{\n\tunsigned long flags;\n\tu32 led;\n\n\t \n\tif (priv->config & CFG_NO_LED || priv->nic_type == EEPROM_NIC_TYPE_1)\n\t\treturn;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tif (!(priv->status & STATUS_RF_KILL_MASK) &&\n\t    !(priv->status & STATUS_LED_LINK_ON)) {\n\t\tIPW_DEBUG_LED(\"Link LED On\\n\");\n\t\tled = ipw_read_reg32(priv, IPW_EVENT_REG);\n\t\tled |= priv->led_association_on;\n\n\t\tled = ipw_register_toggle(led);\n\n\t\tIPW_DEBUG_LED(\"Reg: 0x%08X\\n\", led);\n\t\tipw_write_reg32(priv, IPW_EVENT_REG, led);\n\n\t\tpriv->status |= STATUS_LED_LINK_ON;\n\n\t\t \n\t\tif (!(priv->status & STATUS_ASSOCIATED))\n\t\t\tschedule_delayed_work(&priv->led_link_off,\n\t\t\t\t\t      LD_TIME_LINK_ON);\n\t}\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic void ipw_bg_led_link_on(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, led_link_on.work);\n\tmutex_lock(&priv->mutex);\n\tipw_led_link_on(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void ipw_led_link_off(struct ipw_priv *priv)\n{\n\tunsigned long flags;\n\tu32 led;\n\n\t \n\tif (priv->config & CFG_NO_LED || priv->nic_type == EEPROM_NIC_TYPE_1)\n\t\treturn;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tif (priv->status & STATUS_LED_LINK_ON) {\n\t\tled = ipw_read_reg32(priv, IPW_EVENT_REG);\n\t\tled &= priv->led_association_off;\n\t\tled = ipw_register_toggle(led);\n\n\t\tIPW_DEBUG_LED(\"Reg: 0x%08X\\n\", led);\n\t\tipw_write_reg32(priv, IPW_EVENT_REG, led);\n\n\t\tIPW_DEBUG_LED(\"Link LED Off\\n\");\n\n\t\tpriv->status &= ~STATUS_LED_LINK_ON;\n\n\t\t \n\t\tif (!(priv->status & STATUS_RF_KILL_MASK) &&\n\t\t    !(priv->status & STATUS_ASSOCIATED))\n\t\t\tschedule_delayed_work(&priv->led_link_on,\n\t\t\t\t\t      LD_TIME_LINK_OFF);\n\n\t}\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic void ipw_bg_led_link_off(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, led_link_off.work);\n\tmutex_lock(&priv->mutex);\n\tipw_led_link_off(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void __ipw_led_activity_on(struct ipw_priv *priv)\n{\n\tu32 led;\n\n\tif (priv->config & CFG_NO_LED)\n\t\treturn;\n\n\tif (priv->status & STATUS_RF_KILL_MASK)\n\t\treturn;\n\n\tif (!(priv->status & STATUS_LED_ACT_ON)) {\n\t\tled = ipw_read_reg32(priv, IPW_EVENT_REG);\n\t\tled |= priv->led_activity_on;\n\n\t\tled = ipw_register_toggle(led);\n\n\t\tIPW_DEBUG_LED(\"Reg: 0x%08X\\n\", led);\n\t\tipw_write_reg32(priv, IPW_EVENT_REG, led);\n\n\t\tIPW_DEBUG_LED(\"Activity LED On\\n\");\n\n\t\tpriv->status |= STATUS_LED_ACT_ON;\n\n\t\tcancel_delayed_work(&priv->led_act_off);\n\t\tschedule_delayed_work(&priv->led_act_off, LD_TIME_ACT_ON);\n\t} else {\n\t\t \n\t\tcancel_delayed_work(&priv->led_act_off);\n\t\tschedule_delayed_work(&priv->led_act_off, LD_TIME_ACT_ON);\n\t}\n}\n\n#if 0\nvoid ipw_led_activity_on(struct ipw_priv *priv)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&priv->lock, flags);\n\t__ipw_led_activity_on(priv);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n#endif   \n\nstatic void ipw_led_activity_off(struct ipw_priv *priv)\n{\n\tunsigned long flags;\n\tu32 led;\n\n\tif (priv->config & CFG_NO_LED)\n\t\treturn;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tif (priv->status & STATUS_LED_ACT_ON) {\n\t\tled = ipw_read_reg32(priv, IPW_EVENT_REG);\n\t\tled &= priv->led_activity_off;\n\n\t\tled = ipw_register_toggle(led);\n\n\t\tIPW_DEBUG_LED(\"Reg: 0x%08X\\n\", led);\n\t\tipw_write_reg32(priv, IPW_EVENT_REG, led);\n\n\t\tIPW_DEBUG_LED(\"Activity LED Off\\n\");\n\n\t\tpriv->status &= ~STATUS_LED_ACT_ON;\n\t}\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic void ipw_bg_led_activity_off(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, led_act_off.work);\n\tmutex_lock(&priv->mutex);\n\tipw_led_activity_off(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void ipw_led_band_on(struct ipw_priv *priv)\n{\n\tunsigned long flags;\n\tu32 led;\n\n\t \n\tif (priv->config & CFG_NO_LED ||\n\t    priv->nic_type != EEPROM_NIC_TYPE_1 || !priv->assoc_network)\n\t\treturn;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tled = ipw_read_reg32(priv, IPW_EVENT_REG);\n\tif (priv->assoc_network->mode == IEEE_A) {\n\t\tled |= priv->led_ofdm_on;\n\t\tled &= priv->led_association_off;\n\t\tIPW_DEBUG_LED(\"Mode LED On: 802.11a\\n\");\n\t} else if (priv->assoc_network->mode == IEEE_G) {\n\t\tled |= priv->led_ofdm_on;\n\t\tled |= priv->led_association_on;\n\t\tIPW_DEBUG_LED(\"Mode LED On: 802.11g\\n\");\n\t} else {\n\t\tled &= priv->led_ofdm_off;\n\t\tled |= priv->led_association_on;\n\t\tIPW_DEBUG_LED(\"Mode LED On: 802.11b\\n\");\n\t}\n\n\tled = ipw_register_toggle(led);\n\n\tIPW_DEBUG_LED(\"Reg: 0x%08X\\n\", led);\n\tipw_write_reg32(priv, IPW_EVENT_REG, led);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic void ipw_led_band_off(struct ipw_priv *priv)\n{\n\tunsigned long flags;\n\tu32 led;\n\n\t \n\tif (priv->config & CFG_NO_LED || priv->nic_type != EEPROM_NIC_TYPE_1)\n\t\treturn;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tled = ipw_read_reg32(priv, IPW_EVENT_REG);\n\tled &= priv->led_ofdm_off;\n\tled &= priv->led_association_off;\n\n\tled = ipw_register_toggle(led);\n\n\tIPW_DEBUG_LED(\"Reg: 0x%08X\\n\", led);\n\tipw_write_reg32(priv, IPW_EVENT_REG, led);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic void ipw_led_radio_on(struct ipw_priv *priv)\n{\n\tipw_led_link_on(priv);\n}\n\nstatic void ipw_led_radio_off(struct ipw_priv *priv)\n{\n\tipw_led_activity_off(priv);\n\tipw_led_link_off(priv);\n}\n\nstatic void ipw_led_link_up(struct ipw_priv *priv)\n{\n\t \n\tipw_led_link_on(priv);\n}\n\nstatic void ipw_led_link_down(struct ipw_priv *priv)\n{\n\tipw_led_activity_off(priv);\n\tipw_led_link_off(priv);\n\n\tif (priv->status & STATUS_RF_KILL_MASK)\n\t\tipw_led_radio_off(priv);\n}\n\nstatic void ipw_led_init(struct ipw_priv *priv)\n{\n\tpriv->nic_type = priv->eeprom[EEPROM_NIC_TYPE];\n\n\t \n\tpriv->led_activity_on = IPW_ACTIVITY_LED;\n\tpriv->led_activity_off = ~(IPW_ACTIVITY_LED);\n\n\tpriv->led_association_on = IPW_ASSOCIATED_LED;\n\tpriv->led_association_off = ~(IPW_ASSOCIATED_LED);\n\n\t \n\tpriv->led_ofdm_on = IPW_OFDM_LED;\n\tpriv->led_ofdm_off = ~(IPW_OFDM_LED);\n\n\tswitch (priv->nic_type) {\n\tcase EEPROM_NIC_TYPE_1:\n\t\t \n\t\tpriv->led_activity_on = IPW_ASSOCIATED_LED;\n\t\tpriv->led_activity_off = ~(IPW_ASSOCIATED_LED);\n\t\tpriv->led_association_on = IPW_ACTIVITY_LED;\n\t\tpriv->led_association_off = ~(IPW_ACTIVITY_LED);\n\n\t\tif (!(priv->config & CFG_NO_LED))\n\t\t\tipw_led_band_on(priv);\n\n\t\t \n\t\treturn;\n\n\tcase EEPROM_NIC_TYPE_3:\n\tcase EEPROM_NIC_TYPE_2:\n\tcase EEPROM_NIC_TYPE_4:\n\tcase EEPROM_NIC_TYPE_0:\n\t\tbreak;\n\n\tdefault:\n\t\tIPW_DEBUG_INFO(\"Unknown NIC type from EEPROM: %d\\n\",\n\t\t\t       priv->nic_type);\n\t\tpriv->nic_type = EEPROM_NIC_TYPE_0;\n\t\tbreak;\n\t}\n\n\tif (!(priv->config & CFG_NO_LED)) {\n\t\tif (priv->status & STATUS_ASSOCIATED)\n\t\t\tipw_led_link_on(priv);\n\t\telse\n\t\t\tipw_led_link_off(priv);\n\t}\n}\n\nstatic void ipw_led_shutdown(struct ipw_priv *priv)\n{\n\tipw_led_activity_off(priv);\n\tipw_led_link_off(priv);\n\tipw_led_band_off(priv);\n\tcancel_delayed_work(&priv->led_link_on);\n\tcancel_delayed_work(&priv->led_link_off);\n\tcancel_delayed_work(&priv->led_act_off);\n}\n\n \nstatic ssize_t debug_level_show(struct device_driver *d, char *buf)\n{\n\treturn sprintf(buf, \"0x%08X\\n\", ipw_debug_level);\n}\n\nstatic ssize_t debug_level_store(struct device_driver *d, const char *buf,\n\t\t\t\t size_t count)\n{\n\tunsigned long val;\n\n\tint result = kstrtoul(buf, 0, &val);\n\n\tif (result == -EINVAL)\n\t\tprintk(KERN_INFO DRV_NAME\n\t\t       \": %s is not in hex or decimal form.\\n\", buf);\n\telse if (result == -ERANGE)\n\t\tprintk(KERN_INFO DRV_NAME\n\t\t\t \": %s has overflowed.\\n\", buf);\n\telse\n\t\tipw_debug_level = val;\n\n\treturn count;\n}\nstatic DRIVER_ATTR_RW(debug_level);\n\nstatic inline u32 ipw_get_event_log_len(struct ipw_priv *priv)\n{\n\t \n\treturn ipw_read_reg32(priv, ipw_read32(priv, IPW_EVENT_LOG));\n}\n\nstatic void ipw_capture_event_log(struct ipw_priv *priv,\n\t\t\t\t  u32 log_len, struct ipw_event *log)\n{\n\tu32 base;\n\n\tif (log_len) {\n\t\tbase = ipw_read32(priv, IPW_EVENT_LOG);\n\t\tipw_read_indirect(priv, base + sizeof(base) + sizeof(u32),\n\t\t\t\t  (u8 *) log, sizeof(*log) * log_len);\n\t}\n}\n\nstatic struct ipw_fw_error *ipw_alloc_error_log(struct ipw_priv *priv)\n{\n\tstruct ipw_fw_error *error;\n\tu32 log_len = ipw_get_event_log_len(priv);\n\tu32 base = ipw_read32(priv, IPW_ERROR_LOG);\n\tu32 elem_len = ipw_read_reg32(priv, base);\n\n\terror = kmalloc(size_add(struct_size(error, elem, elem_len),\n\t\t\t\t array_size(sizeof(*error->log), log_len)),\n\t\t\tGFP_ATOMIC);\n\tif (!error) {\n\t\tIPW_ERROR(\"Memory allocation for firmware error log \"\n\t\t\t  \"failed.\\n\");\n\t\treturn NULL;\n\t}\n\terror->jiffies = jiffies;\n\terror->status = priv->status;\n\terror->config = priv->config;\n\terror->elem_len = elem_len;\n\terror->log_len = log_len;\n\terror->log = (struct ipw_event *)(error->elem + elem_len);\n\n\tipw_capture_event_log(priv, log_len, error->log);\n\n\tif (elem_len)\n\t\tipw_read_indirect(priv, base + sizeof(base), (u8 *) error->elem,\n\t\t\t\t  sizeof(*error->elem) * elem_len);\n\n\treturn error;\n}\n\nstatic ssize_t event_log_show(struct device *d,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\tu32 log_len = ipw_get_event_log_len(priv);\n\tu32 log_size;\n\tstruct ipw_event *log;\n\tu32 len = 0, i;\n\n\t \n\tlog_size = PAGE_SIZE / sizeof(*log) > log_len ?\n\t\t\tsizeof(*log) * log_len : PAGE_SIZE;\n\tlog = kzalloc(log_size, GFP_KERNEL);\n\tif (!log) {\n\t\tIPW_ERROR(\"Unable to allocate memory for log\\n\");\n\t\treturn 0;\n\t}\n\tlog_len = log_size / sizeof(*log);\n\tipw_capture_event_log(priv, log_len, log);\n\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"%08X\", log_len);\n\tfor (i = 0; i < log_len; i++)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\"\\n%08X%08X%08X\",\n\t\t\t\tlog[i].time, log[i].event, log[i].data);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"\\n\");\n\tkfree(log);\n\treturn len;\n}\n\nstatic DEVICE_ATTR_RO(event_log);\n\nstatic ssize_t error_show(struct device *d,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\tu32 len = 0, i;\n\tif (!priv->error)\n\t\treturn 0;\n\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\"%08lX%08X%08X%08X\",\n\t\t\tpriv->error->jiffies,\n\t\t\tpriv->error->status,\n\t\t\tpriv->error->config, priv->error->elem_len);\n\tfor (i = 0; i < priv->error->elem_len; i++)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\"\\n%08X%08X%08X%08X%08X%08X%08X\",\n\t\t\t\tpriv->error->elem[i].time,\n\t\t\t\tpriv->error->elem[i].desc,\n\t\t\t\tpriv->error->elem[i].blink1,\n\t\t\t\tpriv->error->elem[i].blink2,\n\t\t\t\tpriv->error->elem[i].link1,\n\t\t\t\tpriv->error->elem[i].link2,\n\t\t\t\tpriv->error->elem[i].data);\n\n\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\"\\n%08X\", priv->error->log_len);\n\tfor (i = 0; i < priv->error->log_len; i++)\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t\t\"\\n%08X%08X%08X\",\n\t\t\t\tpriv->error->log[i].time,\n\t\t\t\tpriv->error->log[i].event,\n\t\t\t\tpriv->error->log[i].data);\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"\\n\");\n\treturn len;\n}\n\nstatic ssize_t error_store(struct device *d,\n\t\t\t   struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\n\tkfree(priv->error);\n\tpriv->error = NULL;\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(error);\n\nstatic ssize_t cmd_log_show(struct device *d,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\tu32 len = 0, i;\n\tif (!priv->cmdlog)\n\t\treturn 0;\n\tfor (i = (priv->cmdlog_pos + 1) % priv->cmdlog_len;\n\t     (i != priv->cmdlog_pos) && (len < PAGE_SIZE);\n\t     i = (i + 1) % priv->cmdlog_len) {\n\t\tlen +=\n\t\t    scnprintf(buf + len, PAGE_SIZE - len,\n\t\t\t     \"\\n%08lX%08X%08X%08X\\n\", priv->cmdlog[i].jiffies,\n\t\t\t     priv->cmdlog[i].retcode, priv->cmdlog[i].cmd.cmd,\n\t\t\t     priv->cmdlog[i].cmd.len);\n\t\tlen +=\n\t\t    snprintk_buf(buf + len, PAGE_SIZE - len,\n\t\t\t\t (u8 *) priv->cmdlog[i].cmd.param,\n\t\t\t\t priv->cmdlog[i].cmd.len);\n\t\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"\\n\");\n\t}\n\tlen += scnprintf(buf + len, PAGE_SIZE - len, \"\\n\");\n\treturn len;\n}\n\nstatic DEVICE_ATTR_RO(cmd_log);\n\n#ifdef CONFIG_IPW2200_PROMISCUOUS\nstatic void ipw_prom_free(struct ipw_priv *priv);\nstatic int ipw_prom_alloc(struct ipw_priv *priv);\nstatic ssize_t rtap_iface_store(struct device *d,\n\t\t\t struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\tint rc = 0;\n\n\tif (count < 1)\n\t\treturn -EINVAL;\n\n\tswitch (buf[0]) {\n\tcase '0':\n\t\tif (!rtap_iface)\n\t\t\treturn count;\n\n\t\tif (netif_running(priv->prom_net_dev)) {\n\t\t\tIPW_WARNING(\"Interface is up.  Cannot unregister.\\n\");\n\t\t\treturn count;\n\t\t}\n\n\t\tipw_prom_free(priv);\n\t\trtap_iface = 0;\n\t\tbreak;\n\n\tcase '1':\n\t\tif (rtap_iface)\n\t\t\treturn count;\n\n\t\trc = ipw_prom_alloc(priv);\n\t\tif (!rc)\n\t\t\trtap_iface = 1;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (rc) {\n\t\tIPW_ERROR(\"Failed to register promiscuous network \"\n\t\t\t  \"device (error %d).\\n\", rc);\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t rtap_iface_show(struct device *d,\n\t\t\tstruct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\tif (rtap_iface)\n\t\treturn sprintf(buf, \"%s\", priv->prom_net_dev->name);\n\telse {\n\t\tbuf[0] = '-';\n\t\tbuf[1] = '1';\n\t\tbuf[2] = '\\0';\n\t\treturn 3;\n\t}\n}\n\nstatic DEVICE_ATTR_ADMIN_RW(rtap_iface);\n\nstatic ssize_t rtap_filter_store(struct device *d,\n\t\t\t struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\n\tif (!priv->prom_priv) {\n\t\tIPW_ERROR(\"Attempting to set filter without \"\n\t\t\t  \"rtap_iface enabled.\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tpriv->prom_priv->filter = simple_strtol(buf, NULL, 0);\n\n\tIPW_DEBUG_INFO(\"Setting rtap filter to \" BIT_FMT16 \"\\n\",\n\t\t       BIT_ARG16(priv->prom_priv->filter));\n\n\treturn count;\n}\n\nstatic ssize_t rtap_filter_show(struct device *d,\n\t\t\tstruct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\treturn sprintf(buf, \"0x%04X\",\n\t\t       priv->prom_priv ? priv->prom_priv->filter : 0);\n}\n\nstatic DEVICE_ATTR_ADMIN_RW(rtap_filter);\n#endif\n\nstatic ssize_t scan_age_show(struct device *d, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\treturn sprintf(buf, \"%d\\n\", priv->ieee->scan_age);\n}\n\nstatic ssize_t scan_age_store(struct device *d, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\tstruct net_device *dev = priv->net_dev;\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tunsigned long val;\n\tint result = kstrtoul(buf, 0, &val);\n\n\tif (result == -EINVAL || result == -ERANGE) {\n\t\tIPW_DEBUG_INFO(\"%s: user supplied invalid value.\\n\", dev->name);\n\t} else {\n\t\tpriv->ieee->scan_age = val;\n\t\tIPW_DEBUG_INFO(\"set scan_age = %u\\n\", priv->ieee->scan_age);\n\t}\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(scan_age);\n\nstatic ssize_t led_show(struct device *d, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\treturn sprintf(buf, \"%d\\n\", (priv->config & CFG_NO_LED) ? 0 : 1);\n}\n\nstatic ssize_t led_store(struct device *d, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\n\tIPW_DEBUG_INFO(\"enter\\n\");\n\n\tif (count == 0)\n\t\treturn 0;\n\n\tif (*buf == 0) {\n\t\tIPW_DEBUG_LED(\"Disabling LED control.\\n\");\n\t\tpriv->config |= CFG_NO_LED;\n\t\tipw_led_shutdown(priv);\n\t} else {\n\t\tIPW_DEBUG_LED(\"Enabling LED control.\\n\");\n\t\tpriv->config &= ~CFG_NO_LED;\n\t\tipw_led_init(priv);\n\t}\n\n\tIPW_DEBUG_INFO(\"exit\\n\");\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(led);\n\nstatic ssize_t status_show(struct device *d,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct ipw_priv *p = dev_get_drvdata(d);\n\treturn sprintf(buf, \"0x%08x\\n\", (int)p->status);\n}\n\nstatic DEVICE_ATTR_RO(status);\n\nstatic ssize_t cfg_show(struct device *d, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct ipw_priv *p = dev_get_drvdata(d);\n\treturn sprintf(buf, \"0x%08x\\n\", (int)p->config);\n}\n\nstatic DEVICE_ATTR_RO(cfg);\n\nstatic ssize_t nic_type_show(struct device *d,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\treturn sprintf(buf, \"TYPE: %d\\n\", priv->nic_type);\n}\n\nstatic DEVICE_ATTR_RO(nic_type);\n\nstatic ssize_t ucode_version_show(struct device *d,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tu32 len = sizeof(u32), tmp = 0;\n\tstruct ipw_priv *p = dev_get_drvdata(d);\n\n\tif (ipw_get_ordinal(p, IPW_ORD_STAT_UCODE_VERSION, &tmp, &len))\n\t\treturn 0;\n\n\treturn sprintf(buf, \"0x%08x\\n\", tmp);\n}\n\nstatic DEVICE_ATTR_RO(ucode_version);\n\nstatic ssize_t rtc_show(struct device *d, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tu32 len = sizeof(u32), tmp = 0;\n\tstruct ipw_priv *p = dev_get_drvdata(d);\n\n\tif (ipw_get_ordinal(p, IPW_ORD_STAT_RTC, &tmp, &len))\n\t\treturn 0;\n\n\treturn sprintf(buf, \"0x%08x\\n\", tmp);\n}\n\nstatic DEVICE_ATTR_RO(rtc);\n\n \nstatic ssize_t eeprom_delay_show(struct device *d,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct ipw_priv *p = dev_get_drvdata(d);\n\tint n = p->eeprom_delay;\n\treturn sprintf(buf, \"%i\\n\", n);\n}\nstatic ssize_t eeprom_delay_store(struct device *d,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct ipw_priv *p = dev_get_drvdata(d);\n\tsscanf(buf, \"%i\", &p->eeprom_delay);\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR_RW(eeprom_delay);\n\nstatic ssize_t command_event_reg_show(struct device *d,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tu32 reg = 0;\n\tstruct ipw_priv *p = dev_get_drvdata(d);\n\n\treg = ipw_read_reg32(p, IPW_INTERNAL_CMD_EVENT);\n\treturn sprintf(buf, \"0x%08x\\n\", reg);\n}\nstatic ssize_t command_event_reg_store(struct device *d,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tu32 reg;\n\tstruct ipw_priv *p = dev_get_drvdata(d);\n\n\tsscanf(buf, \"%x\", &reg);\n\tipw_write_reg32(p, IPW_INTERNAL_CMD_EVENT, reg);\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR_RW(command_event_reg);\n\nstatic ssize_t mem_gpio_reg_show(struct device *d,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tu32 reg = 0;\n\tstruct ipw_priv *p = dev_get_drvdata(d);\n\n\treg = ipw_read_reg32(p, 0x301100);\n\treturn sprintf(buf, \"0x%08x\\n\", reg);\n}\nstatic ssize_t mem_gpio_reg_store(struct device *d,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tu32 reg;\n\tstruct ipw_priv *p = dev_get_drvdata(d);\n\n\tsscanf(buf, \"%x\", &reg);\n\tipw_write_reg32(p, 0x301100, reg);\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR_RW(mem_gpio_reg);\n\nstatic ssize_t indirect_dword_show(struct device *d,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tu32 reg = 0;\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\n\tif (priv->status & STATUS_INDIRECT_DWORD)\n\t\treg = ipw_read_reg32(priv, priv->indirect_dword);\n\telse\n\t\treg = 0;\n\n\treturn sprintf(buf, \"0x%08x\\n\", reg);\n}\nstatic ssize_t indirect_dword_store(struct device *d,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\n\tsscanf(buf, \"%x\", &priv->indirect_dword);\n\tpriv->status |= STATUS_INDIRECT_DWORD;\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR_RW(indirect_dword);\n\nstatic ssize_t indirect_byte_show(struct device *d,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tu8 reg = 0;\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\n\tif (priv->status & STATUS_INDIRECT_BYTE)\n\t\treg = ipw_read_reg8(priv, priv->indirect_byte);\n\telse\n\t\treg = 0;\n\n\treturn sprintf(buf, \"0x%02x\\n\", reg);\n}\nstatic ssize_t indirect_byte_store(struct device *d,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\n\tsscanf(buf, \"%x\", &priv->indirect_byte);\n\tpriv->status |= STATUS_INDIRECT_BYTE;\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR_RW(indirect_byte);\n\nstatic ssize_t direct_dword_show(struct device *d,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tu32 reg = 0;\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\n\tif (priv->status & STATUS_DIRECT_DWORD)\n\t\treg = ipw_read32(priv, priv->direct_dword);\n\telse\n\t\treg = 0;\n\n\treturn sprintf(buf, \"0x%08x\\n\", reg);\n}\nstatic ssize_t direct_dword_store(struct device *d,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\n\tsscanf(buf, \"%x\", &priv->direct_dword);\n\tpriv->status |= STATUS_DIRECT_DWORD;\n\treturn strnlen(buf, count);\n}\n\nstatic DEVICE_ATTR_RW(direct_dword);\n\nstatic int rf_kill_active(struct ipw_priv *priv)\n{\n\tif (0 == (ipw_read32(priv, 0x30) & 0x10000)) {\n\t\tpriv->status |= STATUS_RF_KILL_HW;\n\t\twiphy_rfkill_set_hw_state(priv->ieee->wdev.wiphy, true);\n\t} else {\n\t\tpriv->status &= ~STATUS_RF_KILL_HW;\n\t\twiphy_rfkill_set_hw_state(priv->ieee->wdev.wiphy, false);\n\t}\n\n\treturn (priv->status & STATUS_RF_KILL_HW) ? 1 : 0;\n}\n\nstatic ssize_t rf_kill_show(struct device *d, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\t \n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\tint val = ((priv->status & STATUS_RF_KILL_SW) ? 0x1 : 0x0) |\n\t    (rf_kill_active(priv) ? 0x2 : 0x0);\n\treturn sprintf(buf, \"%i\\n\", val);\n}\n\nstatic int ipw_radio_kill_sw(struct ipw_priv *priv, int disable_radio)\n{\n\tif ((disable_radio ? 1 : 0) ==\n\t    ((priv->status & STATUS_RF_KILL_SW) ? 1 : 0))\n\t\treturn 0;\n\n\tIPW_DEBUG_RF_KILL(\"Manual SW RF Kill set to: RADIO  %s\\n\",\n\t\t\t  disable_radio ? \"OFF\" : \"ON\");\n\n\tif (disable_radio) {\n\t\tpriv->status |= STATUS_RF_KILL_SW;\n\n\t\tcancel_delayed_work(&priv->request_scan);\n\t\tcancel_delayed_work(&priv->request_direct_scan);\n\t\tcancel_delayed_work(&priv->request_passive_scan);\n\t\tcancel_delayed_work(&priv->scan_event);\n\t\tschedule_work(&priv->down);\n\t} else {\n\t\tpriv->status &= ~STATUS_RF_KILL_SW;\n\t\tif (rf_kill_active(priv)) {\n\t\t\tIPW_DEBUG_RF_KILL(\"Can not turn radio back on - \"\n\t\t\t\t\t  \"disabled by HW switch\\n\");\n\t\t\t \n\t\t\tcancel_delayed_work(&priv->rf_kill);\n\t\t\tschedule_delayed_work(&priv->rf_kill,\n\t\t\t\t\t      round_jiffies_relative(2 * HZ));\n\t\t} else\n\t\t\tschedule_work(&priv->up);\n\t}\n\n\treturn 1;\n}\n\nstatic ssize_t rf_kill_store(struct device *d, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\n\tipw_radio_kill_sw(priv, buf[0] == '1');\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(rf_kill);\n\nstatic ssize_t speed_scan_show(struct device *d, struct device_attribute *attr,\n\t\t\t       char *buf)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\tint pos = 0, len = 0;\n\tif (priv->config & CFG_SPEED_SCAN) {\n\t\twhile (priv->speed_scan[pos] != 0)\n\t\t\tlen += sprintf(&buf[len], \"%d \",\n\t\t\t\t       priv->speed_scan[pos++]);\n\t\treturn len + sprintf(&buf[len], \"\\n\");\n\t}\n\n\treturn sprintf(buf, \"0\\n\");\n}\n\nstatic ssize_t speed_scan_store(struct device *d, struct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\tint channel, pos = 0;\n\tconst char *p = buf;\n\n\t \n\twhile ((channel = simple_strtol(p, NULL, 0))) {\n\t\tif (pos == MAX_SPEED_SCAN - 1) {\n\t\t\tpriv->speed_scan[pos] = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (libipw_is_valid_channel(priv->ieee, channel))\n\t\t\tpriv->speed_scan[pos++] = channel;\n\t\telse\n\t\t\tIPW_WARNING(\"Skipping invalid channel request: %d\\n\",\n\t\t\t\t    channel);\n\t\tp = strchr(p, ' ');\n\t\tif (!p)\n\t\t\tbreak;\n\t\twhile (*p == ' ' || *p == '\\t')\n\t\t\tp++;\n\t}\n\n\tif (pos == 0)\n\t\tpriv->config &= ~CFG_SPEED_SCAN;\n\telse {\n\t\tpriv->speed_scan_pos = 0;\n\t\tpriv->config |= CFG_SPEED_SCAN;\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(speed_scan);\n\nstatic ssize_t net_stats_show(struct device *d, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\treturn sprintf(buf, \"%c\\n\", (priv->config & CFG_NET_STATS) ? '1' : '0');\n}\n\nstatic ssize_t net_stats_store(struct device *d, struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\tif (buf[0] == '1')\n\t\tpriv->config |= CFG_NET_STATS;\n\telse\n\t\tpriv->config &= ~CFG_NET_STATS;\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(net_stats);\n\nstatic ssize_t channels_show(struct device *d,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(d);\n\tconst struct libipw_geo *geo = libipw_get_geo(priv->ieee);\n\tint len = 0, i;\n\n\tlen = sprintf(&buf[len],\n\t\t      \"Displaying %d channels in 2.4Ghz band \"\n\t\t      \"(802.11bg):\\n\", geo->bg_channels);\n\n\tfor (i = 0; i < geo->bg_channels; i++) {\n\t\tlen += sprintf(&buf[len], \"%d: BSS%s%s, %s, Band %s.\\n\",\n\t\t\t       geo->bg[i].channel,\n\t\t\t       geo->bg[i].flags & LIBIPW_CH_RADAR_DETECT ?\n\t\t\t       \" (radar spectrum)\" : \"\",\n\t\t\t       ((geo->bg[i].flags & LIBIPW_CH_NO_IBSS) ||\n\t\t\t\t(geo->bg[i].flags & LIBIPW_CH_RADAR_DETECT))\n\t\t\t       ? \"\" : \", IBSS\",\n\t\t\t       geo->bg[i].flags & LIBIPW_CH_PASSIVE_ONLY ?\n\t\t\t       \"passive only\" : \"active/passive\",\n\t\t\t       geo->bg[i].flags & LIBIPW_CH_B_ONLY ?\n\t\t\t       \"B\" : \"B/G\");\n\t}\n\n\tlen += sprintf(&buf[len],\n\t\t       \"Displaying %d channels in 5.2Ghz band \"\n\t\t       \"(802.11a):\\n\", geo->a_channels);\n\tfor (i = 0; i < geo->a_channels; i++) {\n\t\tlen += sprintf(&buf[len], \"%d: BSS%s%s, %s.\\n\",\n\t\t\t       geo->a[i].channel,\n\t\t\t       geo->a[i].flags & LIBIPW_CH_RADAR_DETECT ?\n\t\t\t       \" (radar spectrum)\" : \"\",\n\t\t\t       ((geo->a[i].flags & LIBIPW_CH_NO_IBSS) ||\n\t\t\t\t(geo->a[i].flags & LIBIPW_CH_RADAR_DETECT))\n\t\t\t       ? \"\" : \", IBSS\",\n\t\t\t       geo->a[i].flags & LIBIPW_CH_PASSIVE_ONLY ?\n\t\t\t       \"passive only\" : \"active/passive\");\n\t}\n\n\treturn len;\n}\n\nstatic DEVICE_ATTR_ADMIN_RO(channels);\n\nstatic void notify_wx_assoc_event(struct ipw_priv *priv)\n{\n\tunion iwreq_data wrqu;\n\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\tif (priv->status & STATUS_ASSOCIATED)\n\t\tmemcpy(wrqu.ap_addr.sa_data, priv->bssid, ETH_ALEN);\n\telse\n\t\teth_zero_addr(wrqu.ap_addr.sa_data);\n\twireless_send_event(priv->net_dev, SIOCGIWAP, &wrqu, NULL);\n}\n\nstatic void ipw_irq_tasklet(struct tasklet_struct *t)\n{\n\tstruct ipw_priv *priv = from_tasklet(priv, t, irq_tasklet);\n\tu32 inta, inta_mask, handled = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->irq_lock, flags);\n\n\tinta = ipw_read32(priv, IPW_INTA_RW);\n\tinta_mask = ipw_read32(priv, IPW_INTA_MASK_R);\n\n\tif (inta == 0xFFFFFFFF) {\n\t\t \n\t\tIPW_WARNING(\"TASKLET INTA == 0xFFFFFFFF\\n\");\n\t\t \n\t\tinta = 0;\n\t}\n\tinta &= (IPW_INTA_MASK_ALL & inta_mask);\n\n\t \n\tinta |= priv->isr_inta;\n\n\tspin_unlock_irqrestore(&priv->irq_lock, flags);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\t \n\tif (inta & IPW_INTA_BIT_RX_TRANSFER) {\n\t\tipw_rx(priv);\n\t\thandled |= IPW_INTA_BIT_RX_TRANSFER;\n\t}\n\n\tif (inta & IPW_INTA_BIT_TX_CMD_QUEUE) {\n\t\tIPW_DEBUG_HC(\"Command completed.\\n\");\n\t\tipw_queue_tx_reclaim(priv, &priv->txq_cmd, -1);\n\t\tpriv->status &= ~STATUS_HCMD_ACTIVE;\n\t\twake_up_interruptible(&priv->wait_command_queue);\n\t\thandled |= IPW_INTA_BIT_TX_CMD_QUEUE;\n\t}\n\n\tif (inta & IPW_INTA_BIT_TX_QUEUE_1) {\n\t\tIPW_DEBUG_TX(\"TX_QUEUE_1\\n\");\n\t\tipw_queue_tx_reclaim(priv, &priv->txq[0], 0);\n\t\thandled |= IPW_INTA_BIT_TX_QUEUE_1;\n\t}\n\n\tif (inta & IPW_INTA_BIT_TX_QUEUE_2) {\n\t\tIPW_DEBUG_TX(\"TX_QUEUE_2\\n\");\n\t\tipw_queue_tx_reclaim(priv, &priv->txq[1], 1);\n\t\thandled |= IPW_INTA_BIT_TX_QUEUE_2;\n\t}\n\n\tif (inta & IPW_INTA_BIT_TX_QUEUE_3) {\n\t\tIPW_DEBUG_TX(\"TX_QUEUE_3\\n\");\n\t\tipw_queue_tx_reclaim(priv, &priv->txq[2], 2);\n\t\thandled |= IPW_INTA_BIT_TX_QUEUE_3;\n\t}\n\n\tif (inta & IPW_INTA_BIT_TX_QUEUE_4) {\n\t\tIPW_DEBUG_TX(\"TX_QUEUE_4\\n\");\n\t\tipw_queue_tx_reclaim(priv, &priv->txq[3], 3);\n\t\thandled |= IPW_INTA_BIT_TX_QUEUE_4;\n\t}\n\n\tif (inta & IPW_INTA_BIT_STATUS_CHANGE) {\n\t\tIPW_WARNING(\"STATUS_CHANGE\\n\");\n\t\thandled |= IPW_INTA_BIT_STATUS_CHANGE;\n\t}\n\n\tif (inta & IPW_INTA_BIT_BEACON_PERIOD_EXPIRED) {\n\t\tIPW_WARNING(\"TX_PERIOD_EXPIRED\\n\");\n\t\thandled |= IPW_INTA_BIT_BEACON_PERIOD_EXPIRED;\n\t}\n\n\tif (inta & IPW_INTA_BIT_SLAVE_MODE_HOST_CMD_DONE) {\n\t\tIPW_WARNING(\"HOST_CMD_DONE\\n\");\n\t\thandled |= IPW_INTA_BIT_SLAVE_MODE_HOST_CMD_DONE;\n\t}\n\n\tif (inta & IPW_INTA_BIT_FW_INITIALIZATION_DONE) {\n\t\tIPW_WARNING(\"FW_INITIALIZATION_DONE\\n\");\n\t\thandled |= IPW_INTA_BIT_FW_INITIALIZATION_DONE;\n\t}\n\n\tif (inta & IPW_INTA_BIT_FW_CARD_DISABLE_PHY_OFF_DONE) {\n\t\tIPW_WARNING(\"PHY_OFF_DONE\\n\");\n\t\thandled |= IPW_INTA_BIT_FW_CARD_DISABLE_PHY_OFF_DONE;\n\t}\n\n\tif (inta & IPW_INTA_BIT_RF_KILL_DONE) {\n\t\tIPW_DEBUG_RF_KILL(\"RF_KILL_DONE\\n\");\n\t\tpriv->status |= STATUS_RF_KILL_HW;\n\t\twiphy_rfkill_set_hw_state(priv->ieee->wdev.wiphy, true);\n\t\twake_up_interruptible(&priv->wait_command_queue);\n\t\tpriv->status &= ~(STATUS_ASSOCIATED | STATUS_ASSOCIATING);\n\t\tcancel_delayed_work(&priv->request_scan);\n\t\tcancel_delayed_work(&priv->request_direct_scan);\n\t\tcancel_delayed_work(&priv->request_passive_scan);\n\t\tcancel_delayed_work(&priv->scan_event);\n\t\tschedule_work(&priv->link_down);\n\t\tschedule_delayed_work(&priv->rf_kill, 2 * HZ);\n\t\thandled |= IPW_INTA_BIT_RF_KILL_DONE;\n\t}\n\n\tif (inta & IPW_INTA_BIT_FATAL_ERROR) {\n\t\tIPW_WARNING(\"Firmware error detected.  Restarting.\\n\");\n\t\tif (priv->error) {\n\t\t\tIPW_DEBUG_FW(\"Sysfs 'error' log already exists.\\n\");\n\t\t\tif (ipw_debug_level & IPW_DL_FW_ERRORS) {\n\t\t\t\tstruct ipw_fw_error *error =\n\t\t\t\t    ipw_alloc_error_log(priv);\n\t\t\t\tipw_dump_error_log(priv, error);\n\t\t\t\tkfree(error);\n\t\t\t}\n\t\t} else {\n\t\t\tpriv->error = ipw_alloc_error_log(priv);\n\t\t\tif (priv->error)\n\t\t\t\tIPW_DEBUG_FW(\"Sysfs 'error' log captured.\\n\");\n\t\t\telse\n\t\t\t\tIPW_DEBUG_FW(\"Error allocating sysfs 'error' \"\n\t\t\t\t\t     \"log.\\n\");\n\t\t\tif (ipw_debug_level & IPW_DL_FW_ERRORS)\n\t\t\t\tipw_dump_error_log(priv, priv->error);\n\t\t}\n\n\t\t \n\t\tif (priv->ieee->sec.encrypt) {\n\t\t\tpriv->status &= ~STATUS_ASSOCIATED;\n\t\t\tnotify_wx_assoc_event(priv);\n\t\t}\n\n\t\t \n\t\tpriv->status &= ~STATUS_INIT;\n\n\t\t \n\t\tpriv->status &= ~STATUS_HCMD_ACTIVE;\n\t\twake_up_interruptible(&priv->wait_command_queue);\n\n\t\tschedule_work(&priv->adapter_restart);\n\t\thandled |= IPW_INTA_BIT_FATAL_ERROR;\n\t}\n\n\tif (inta & IPW_INTA_BIT_PARITY_ERROR) {\n\t\tIPW_ERROR(\"Parity error\\n\");\n\t\thandled |= IPW_INTA_BIT_PARITY_ERROR;\n\t}\n\n\tif (handled != inta) {\n\t\tIPW_ERROR(\"Unhandled INTA bits 0x%08x\\n\", inta & ~handled);\n\t}\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\t \n\tipw_enable_interrupts(priv);\n}\n\n#define IPW_CMD(x) case IPW_CMD_ ## x : return #x\nstatic char *get_cmd_string(u8 cmd)\n{\n\tswitch (cmd) {\n\t\tIPW_CMD(HOST_COMPLETE);\n\t\tIPW_CMD(POWER_DOWN);\n\t\tIPW_CMD(SYSTEM_CONFIG);\n\t\tIPW_CMD(MULTICAST_ADDRESS);\n\t\tIPW_CMD(SSID);\n\t\tIPW_CMD(ADAPTER_ADDRESS);\n\t\tIPW_CMD(PORT_TYPE);\n\t\tIPW_CMD(RTS_THRESHOLD);\n\t\tIPW_CMD(FRAG_THRESHOLD);\n\t\tIPW_CMD(POWER_MODE);\n\t\tIPW_CMD(WEP_KEY);\n\t\tIPW_CMD(TGI_TX_KEY);\n\t\tIPW_CMD(SCAN_REQUEST);\n\t\tIPW_CMD(SCAN_REQUEST_EXT);\n\t\tIPW_CMD(ASSOCIATE);\n\t\tIPW_CMD(SUPPORTED_RATES);\n\t\tIPW_CMD(SCAN_ABORT);\n\t\tIPW_CMD(TX_FLUSH);\n\t\tIPW_CMD(QOS_PARAMETERS);\n\t\tIPW_CMD(DINO_CONFIG);\n\t\tIPW_CMD(RSN_CAPABILITIES);\n\t\tIPW_CMD(RX_KEY);\n\t\tIPW_CMD(CARD_DISABLE);\n\t\tIPW_CMD(SEED_NUMBER);\n\t\tIPW_CMD(TX_POWER);\n\t\tIPW_CMD(COUNTRY_INFO);\n\t\tIPW_CMD(AIRONET_INFO);\n\t\tIPW_CMD(AP_TX_POWER);\n\t\tIPW_CMD(CCKM_INFO);\n\t\tIPW_CMD(CCX_VER_INFO);\n\t\tIPW_CMD(SET_CALIBRATION);\n\t\tIPW_CMD(SENSITIVITY_CALIB);\n\t\tIPW_CMD(RETRY_LIMIT);\n\t\tIPW_CMD(IPW_PRE_POWER_DOWN);\n\t\tIPW_CMD(VAP_BEACON_TEMPLATE);\n\t\tIPW_CMD(VAP_DTIM_PERIOD);\n\t\tIPW_CMD(EXT_SUPPORTED_RATES);\n\t\tIPW_CMD(VAP_LOCAL_TX_PWR_CONSTRAINT);\n\t\tIPW_CMD(VAP_QUIET_INTERVALS);\n\t\tIPW_CMD(VAP_CHANNEL_SWITCH);\n\t\tIPW_CMD(VAP_MANDATORY_CHANNELS);\n\t\tIPW_CMD(VAP_CELL_PWR_LIMIT);\n\t\tIPW_CMD(VAP_CF_PARAM_SET);\n\t\tIPW_CMD(VAP_SET_BEACONING_STATE);\n\t\tIPW_CMD(MEASUREMENT);\n\t\tIPW_CMD(POWER_CAPABILITY);\n\t\tIPW_CMD(SUPPORTED_CHANNELS);\n\t\tIPW_CMD(TPC_REPORT);\n\t\tIPW_CMD(WME_INFO);\n\t\tIPW_CMD(PRODUCTION_COMMAND);\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n}\n\n#define HOST_COMPLETE_TIMEOUT HZ\n\nstatic int __ipw_send_cmd(struct ipw_priv *priv, struct host_cmd *cmd)\n{\n\tint rc = 0;\n\tunsigned long flags;\n\tunsigned long now, end;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (priv->status & STATUS_HCMD_ACTIVE) {\n\t\tIPW_ERROR(\"Failed to send %s: Already sending a command.\\n\",\n\t\t\t  get_cmd_string(cmd->cmd));\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\treturn -EAGAIN;\n\t}\n\n\tpriv->status |= STATUS_HCMD_ACTIVE;\n\n\tif (priv->cmdlog) {\n\t\tpriv->cmdlog[priv->cmdlog_pos].jiffies = jiffies;\n\t\tpriv->cmdlog[priv->cmdlog_pos].cmd.cmd = cmd->cmd;\n\t\tpriv->cmdlog[priv->cmdlog_pos].cmd.len = cmd->len;\n\t\tmemcpy(priv->cmdlog[priv->cmdlog_pos].cmd.param, cmd->param,\n\t\t       cmd->len);\n\t\tpriv->cmdlog[priv->cmdlog_pos].retcode = -1;\n\t}\n\n\tIPW_DEBUG_HC(\"%s command (#%d) %d bytes: 0x%08X\\n\",\n\t\t     get_cmd_string(cmd->cmd), cmd->cmd, cmd->len,\n\t\t     priv->status);\n\n#ifndef DEBUG_CMD_WEP_KEY\n\tif (cmd->cmd == IPW_CMD_WEP_KEY)\n\t\tIPW_DEBUG_HC(\"WEP_KEY command masked out for secure.\\n\");\n\telse\n#endif\n\t\tprintk_buf(IPW_DL_HOST_COMMAND, (u8 *) cmd->param, cmd->len);\n\n\trc = ipw_queue_tx_hcmd(priv, cmd->cmd, cmd->param, cmd->len, 0);\n\tif (rc) {\n\t\tpriv->status &= ~STATUS_HCMD_ACTIVE;\n\t\tIPW_ERROR(\"Failed to send %s: Reason %d\\n\",\n\t\t\t  get_cmd_string(cmd->cmd), rc);\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tgoto exit;\n\t}\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tnow = jiffies;\n\tend = now + HOST_COMPLETE_TIMEOUT;\nagain:\n\trc = wait_event_interruptible_timeout(priv->wait_command_queue,\n\t\t\t\t\t      !(priv->\n\t\t\t\t\t\tstatus & STATUS_HCMD_ACTIVE),\n\t\t\t\t\t      end - now);\n\tif (rc < 0) {\n\t\tnow = jiffies;\n\t\tif (time_before(now, end))\n\t\t\tgoto again;\n\t\trc = 0;\n\t}\n\n\tif (rc == 0) {\n\t\tspin_lock_irqsave(&priv->lock, flags);\n\t\tif (priv->status & STATUS_HCMD_ACTIVE) {\n\t\t\tIPW_ERROR(\"Failed to send %s: Command timed out.\\n\",\n\t\t\t\t  get_cmd_string(cmd->cmd));\n\t\t\tpriv->status &= ~STATUS_HCMD_ACTIVE;\n\t\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\t\trc = -EIO;\n\t\t\tgoto exit;\n\t\t}\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t} else\n\t\trc = 0;\n\n\tif (priv->status & STATUS_RF_KILL_HW) {\n\t\tIPW_ERROR(\"Failed to send %s: Aborted due to RF kill switch.\\n\",\n\t\t\t  get_cmd_string(cmd->cmd));\n\t\trc = -EIO;\n\t\tgoto exit;\n\t}\n\n      exit:\n\tif (priv->cmdlog) {\n\t\tpriv->cmdlog[priv->cmdlog_pos++].retcode = rc;\n\t\tpriv->cmdlog_pos %= priv->cmdlog_len;\n\t}\n\treturn rc;\n}\n\nstatic int ipw_send_cmd_simple(struct ipw_priv *priv, u8 command)\n{\n\tstruct host_cmd cmd = {\n\t\t.cmd = command,\n\t};\n\n\treturn __ipw_send_cmd(priv, &cmd);\n}\n\nstatic int ipw_send_cmd_pdu(struct ipw_priv *priv, u8 command, u8 len,\n\t\t\t    const void *data)\n{\n\tstruct host_cmd cmd = {\n\t\t.cmd = command,\n\t\t.len = len,\n\t\t.param = data,\n\t};\n\n\treturn __ipw_send_cmd(priv, &cmd);\n}\n\nstatic int ipw_send_host_complete(struct ipw_priv *priv)\n{\n\tif (!priv) {\n\t\tIPW_ERROR(\"Invalid args\\n\");\n\t\treturn -1;\n\t}\n\n\treturn ipw_send_cmd_simple(priv, IPW_CMD_HOST_COMPLETE);\n}\n\nstatic int ipw_send_system_config(struct ipw_priv *priv)\n{\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_SYSTEM_CONFIG,\n\t\t\t\tsizeof(priv->sys_config),\n\t\t\t\t&priv->sys_config);\n}\n\nstatic int ipw_send_ssid(struct ipw_priv *priv, u8 * ssid, int len)\n{\n\tif (!priv || !ssid) {\n\t\tIPW_ERROR(\"Invalid args\\n\");\n\t\treturn -1;\n\t}\n\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_SSID, min(len, IW_ESSID_MAX_SIZE),\n\t\t\t\tssid);\n}\n\nstatic int ipw_send_adapter_address(struct ipw_priv *priv, const u8 * mac)\n{\n\tif (!priv || !mac) {\n\t\tIPW_ERROR(\"Invalid args\\n\");\n\t\treturn -1;\n\t}\n\n\tIPW_DEBUG_INFO(\"%s: Setting MAC to %pM\\n\",\n\t\t       priv->net_dev->name, mac);\n\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_ADAPTER_ADDRESS, ETH_ALEN, mac);\n}\n\nstatic void ipw_adapter_restart(void *adapter)\n{\n\tstruct ipw_priv *priv = adapter;\n\n\tif (priv->status & STATUS_RF_KILL_MASK)\n\t\treturn;\n\n\tipw_down(priv);\n\n\tif (priv->assoc_network &&\n\t    (priv->assoc_network->capability & WLAN_CAPABILITY_IBSS))\n\t\tipw_remove_current_network(priv);\n\n\tif (ipw_up(priv)) {\n\t\tIPW_ERROR(\"Failed to up device\\n\");\n\t\treturn;\n\t}\n}\n\nstatic void ipw_bg_adapter_restart(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, adapter_restart);\n\tmutex_lock(&priv->mutex);\n\tipw_adapter_restart(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void ipw_abort_scan(struct ipw_priv *priv);\n\n#define IPW_SCAN_CHECK_WATCHDOG\t(5 * HZ)\n\nstatic void ipw_scan_check(void *data)\n{\n\tstruct ipw_priv *priv = data;\n\n\tif (priv->status & STATUS_SCAN_ABORTING) {\n\t\tIPW_DEBUG_SCAN(\"Scan completion watchdog resetting \"\n\t\t\t       \"adapter after (%dms).\\n\",\n\t\t\t       jiffies_to_msecs(IPW_SCAN_CHECK_WATCHDOG));\n\t\tschedule_work(&priv->adapter_restart);\n\t} else if (priv->status & STATUS_SCANNING) {\n\t\tIPW_DEBUG_SCAN(\"Scan completion watchdog aborting scan \"\n\t\t\t       \"after (%dms).\\n\",\n\t\t\t       jiffies_to_msecs(IPW_SCAN_CHECK_WATCHDOG));\n\t\tipw_abort_scan(priv);\n\t\tschedule_delayed_work(&priv->scan_check, HZ);\n\t}\n}\n\nstatic void ipw_bg_scan_check(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, scan_check.work);\n\tmutex_lock(&priv->mutex);\n\tipw_scan_check(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic int ipw_send_scan_request_ext(struct ipw_priv *priv,\n\t\t\t\t     struct ipw_scan_request_ext *request)\n{\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_SCAN_REQUEST_EXT,\n\t\t\t\tsizeof(*request), request);\n}\n\nstatic int ipw_send_scan_abort(struct ipw_priv *priv)\n{\n\tif (!priv) {\n\t\tIPW_ERROR(\"Invalid args\\n\");\n\t\treturn -1;\n\t}\n\n\treturn ipw_send_cmd_simple(priv, IPW_CMD_SCAN_ABORT);\n}\n\nstatic int ipw_set_sensitivity(struct ipw_priv *priv, u16 sens)\n{\n\tstruct ipw_sensitivity_calib calib = {\n\t\t.beacon_rssi_raw = cpu_to_le16(sens),\n\t};\n\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_SENSITIVITY_CALIB, sizeof(calib),\n\t\t\t\t&calib);\n}\n\nstatic int ipw_send_associate(struct ipw_priv *priv,\n\t\t\t      struct ipw_associate *associate)\n{\n\tif (!priv || !associate) {\n\t\tIPW_ERROR(\"Invalid args\\n\");\n\t\treturn -1;\n\t}\n\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_ASSOCIATE, sizeof(*associate),\n\t\t\t\tassociate);\n}\n\nstatic int ipw_send_supported_rates(struct ipw_priv *priv,\n\t\t\t\t    struct ipw_supported_rates *rates)\n{\n\tif (!priv || !rates) {\n\t\tIPW_ERROR(\"Invalid args\\n\");\n\t\treturn -1;\n\t}\n\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_SUPPORTED_RATES, sizeof(*rates),\n\t\t\t\trates);\n}\n\nstatic int ipw_set_random_seed(struct ipw_priv *priv)\n{\n\tu32 val;\n\n\tif (!priv) {\n\t\tIPW_ERROR(\"Invalid args\\n\");\n\t\treturn -1;\n\t}\n\n\tget_random_bytes(&val, sizeof(val));\n\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_SEED_NUMBER, sizeof(val), &val);\n}\n\nstatic int ipw_send_card_disable(struct ipw_priv *priv, u32 phy_off)\n{\n\t__le32 v = cpu_to_le32(phy_off);\n\tif (!priv) {\n\t\tIPW_ERROR(\"Invalid args\\n\");\n\t\treturn -1;\n\t}\n\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_CARD_DISABLE, sizeof(v), &v);\n}\n\nstatic int ipw_send_tx_power(struct ipw_priv *priv, struct ipw_tx_power *power)\n{\n\tif (!priv || !power) {\n\t\tIPW_ERROR(\"Invalid args\\n\");\n\t\treturn -1;\n\t}\n\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_TX_POWER, sizeof(*power), power);\n}\n\nstatic int ipw_set_tx_power(struct ipw_priv *priv)\n{\n\tconst struct libipw_geo *geo = libipw_get_geo(priv->ieee);\n\tstruct ipw_tx_power tx_power;\n\ts8 max_power;\n\tint i;\n\n\tmemset(&tx_power, 0, sizeof(tx_power));\n\n\t \n\ttx_power.ieee_mode = IPW_G_MODE;\n\ttx_power.num_channels = geo->bg_channels;\n\tfor (i = 0; i < geo->bg_channels; i++) {\n\t\tmax_power = geo->bg[i].max_power;\n\t\ttx_power.channels_tx_power[i].channel_number =\n\t\t    geo->bg[i].channel;\n\t\ttx_power.channels_tx_power[i].tx_power = max_power ?\n\t\t    min(max_power, priv->tx_power) : priv->tx_power;\n\t}\n\tif (ipw_send_tx_power(priv, &tx_power))\n\t\treturn -EIO;\n\n\t \n\ttx_power.ieee_mode = IPW_B_MODE;\n\tif (ipw_send_tx_power(priv, &tx_power))\n\t\treturn -EIO;\n\n\t \n\tif (priv->ieee->abg_true) {\n\t\ttx_power.ieee_mode = IPW_A_MODE;\n\t\ttx_power.num_channels = geo->a_channels;\n\t\tfor (i = 0; i < tx_power.num_channels; i++) {\n\t\t\tmax_power = geo->a[i].max_power;\n\t\t\ttx_power.channels_tx_power[i].channel_number =\n\t\t\t    geo->a[i].channel;\n\t\t\ttx_power.channels_tx_power[i].tx_power = max_power ?\n\t\t\t    min(max_power, priv->tx_power) : priv->tx_power;\n\t\t}\n\t\tif (ipw_send_tx_power(priv, &tx_power))\n\t\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int ipw_send_rts_threshold(struct ipw_priv *priv, u16 rts)\n{\n\tstruct ipw_rts_threshold rts_threshold = {\n\t\t.rts_threshold = cpu_to_le16(rts),\n\t};\n\n\tif (!priv) {\n\t\tIPW_ERROR(\"Invalid args\\n\");\n\t\treturn -1;\n\t}\n\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_RTS_THRESHOLD,\n\t\t\t\tsizeof(rts_threshold), &rts_threshold);\n}\n\nstatic int ipw_send_frag_threshold(struct ipw_priv *priv, u16 frag)\n{\n\tstruct ipw_frag_threshold frag_threshold = {\n\t\t.frag_threshold = cpu_to_le16(frag),\n\t};\n\n\tif (!priv) {\n\t\tIPW_ERROR(\"Invalid args\\n\");\n\t\treturn -1;\n\t}\n\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_FRAG_THRESHOLD,\n\t\t\t\tsizeof(frag_threshold), &frag_threshold);\n}\n\nstatic int ipw_send_power_mode(struct ipw_priv *priv, u32 mode)\n{\n\t__le32 param;\n\n\tif (!priv) {\n\t\tIPW_ERROR(\"Invalid args\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tswitch (mode) {\n\tcase IPW_POWER_BATTERY:\n\t\tparam = cpu_to_le32(IPW_POWER_INDEX_3);\n\t\tbreak;\n\tcase IPW_POWER_AC:\n\t\tparam = cpu_to_le32(IPW_POWER_MODE_CAM);\n\t\tbreak;\n\tdefault:\n\t\tparam = cpu_to_le32(mode);\n\t\tbreak;\n\t}\n\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_POWER_MODE, sizeof(param),\n\t\t\t\t&param);\n}\n\nstatic int ipw_send_retry_limit(struct ipw_priv *priv, u8 slimit, u8 llimit)\n{\n\tstruct ipw_retry_limit retry_limit = {\n\t\t.short_retry_limit = slimit,\n\t\t.long_retry_limit = llimit\n\t};\n\n\tif (!priv) {\n\t\tIPW_ERROR(\"Invalid args\\n\");\n\t\treturn -1;\n\t}\n\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_RETRY_LIMIT, sizeof(retry_limit),\n\t\t\t\t&retry_limit);\n}\n\n \n\n \nstatic inline void eeprom_write_reg(struct ipw_priv *p, u32 data)\n{\n\tipw_write_reg32(p, FW_MEM_REG_EEPROM_ACCESS, data);\n\n\t \n\tudelay(p->eeprom_delay);\n}\n\n \nstatic void eeprom_cs(struct ipw_priv *priv)\n{\n\teeprom_write_reg(priv, 0);\n\teeprom_write_reg(priv, EEPROM_BIT_CS);\n\teeprom_write_reg(priv, EEPROM_BIT_CS | EEPROM_BIT_SK);\n\teeprom_write_reg(priv, EEPROM_BIT_CS);\n}\n\n \nstatic void eeprom_disable_cs(struct ipw_priv *priv)\n{\n\teeprom_write_reg(priv, EEPROM_BIT_CS);\n\teeprom_write_reg(priv, 0);\n\teeprom_write_reg(priv, EEPROM_BIT_SK);\n}\n\n \nstatic inline void eeprom_write_bit(struct ipw_priv *p, u8 bit)\n{\n\tint d = (bit ? EEPROM_BIT_DI : 0);\n\teeprom_write_reg(p, EEPROM_BIT_CS | d);\n\teeprom_write_reg(p, EEPROM_BIT_CS | d | EEPROM_BIT_SK);\n}\n\n \nstatic void eeprom_op(struct ipw_priv *priv, u8 op, u8 addr)\n{\n\tint i;\n\n\teeprom_cs(priv);\n\teeprom_write_bit(priv, 1);\n\teeprom_write_bit(priv, op & 2);\n\teeprom_write_bit(priv, op & 1);\n\tfor (i = 7; i >= 0; i--) {\n\t\teeprom_write_bit(priv, addr & (1 << i));\n\t}\n}\n\n \nstatic u16 eeprom_read_u16(struct ipw_priv *priv, u8 addr)\n{\n\tint i;\n\tu16 r = 0;\n\n\t \n\teeprom_op(priv, EEPROM_CMD_READ, addr);\n\n\t \n\teeprom_write_reg(priv, EEPROM_BIT_CS);\n\n\t \n\tfor (i = 0; i < 16; i++) {\n\t\tu32 data = 0;\n\t\teeprom_write_reg(priv, EEPROM_BIT_CS | EEPROM_BIT_SK);\n\t\teeprom_write_reg(priv, EEPROM_BIT_CS);\n\t\tdata = ipw_read_reg32(priv, FW_MEM_REG_EEPROM_ACCESS);\n\t\tr = (r << 1) | ((data & EEPROM_BIT_DO) ? 1 : 0);\n\t}\n\n\t \n\teeprom_write_reg(priv, 0);\n\teeprom_disable_cs(priv);\n\n\treturn r;\n}\n\n \n \nstatic void eeprom_parse_mac(struct ipw_priv *priv, u8 * mac)\n{\n\tmemcpy(mac, &priv->eeprom[EEPROM_MAC_ADDRESS], ETH_ALEN);\n}\n\nstatic void ipw_read_eeprom(struct ipw_priv *priv)\n{\n\tint i;\n\t__le16 *eeprom = (__le16 *) priv->eeprom;\n\n\tIPW_DEBUG_TRACE(\">>\\n\");\n\n\t \n\tfor (i = 0; i < 128; i++)\n\t\teeprom[i] = cpu_to_le16(eeprom_read_u16(priv, (u8) i));\n\n\tIPW_DEBUG_TRACE(\"<<\\n\");\n}\n\n \nstatic void ipw_eeprom_init_sram(struct ipw_priv *priv)\n{\n\tint i;\n\n\tIPW_DEBUG_TRACE(\">>\\n\");\n\n\t \n\tif (priv->eeprom[EEPROM_VERSION] != 0) {\n\t\tIPW_DEBUG_INFO(\"Writing EEPROM data into SRAM\\n\");\n\n\t\t \n\t\tfor (i = 0; i < IPW_EEPROM_IMAGE_SIZE; i++)\n\t\t\tipw_write8(priv, IPW_EEPROM_DATA + i, priv->eeprom[i]);\n\n\t\t \n\t\tipw_write32(priv, IPW_EEPROM_LOAD_DISABLE, 0);\n\t} else {\n\t\tIPW_DEBUG_INFO(\"Enabling FW initialization of SRAM\\n\");\n\n\t\t \n\t\tipw_write32(priv, IPW_EEPROM_LOAD_DISABLE, 1);\n\t}\n\n\tIPW_DEBUG_TRACE(\"<<\\n\");\n}\n\nstatic void ipw_zero_memory(struct ipw_priv *priv, u32 start, u32 count)\n{\n\tcount >>= 2;\n\tif (!count)\n\t\treturn;\n\t_ipw_write32(priv, IPW_AUTOINC_ADDR, start);\n\twhile (count--)\n\t\t_ipw_write32(priv, IPW_AUTOINC_DATA, 0);\n}\n\nstatic inline void ipw_fw_dma_reset_command_blocks(struct ipw_priv *priv)\n{\n\tipw_zero_memory(priv, IPW_SHARED_SRAM_DMA_CONTROL,\n\t\t\tCB_NUMBER_OF_ELEMENTS_SMALL *\n\t\t\tsizeof(struct command_block));\n}\n\nstatic int ipw_fw_dma_enable(struct ipw_priv *priv)\n{\t\t\t\t \n\n\tIPW_DEBUG_FW(\">> :\\n\");\n\n\t \n\tipw_fw_dma_reset_command_blocks(priv);\n\n\t \n\tipw_write_reg32(priv, IPW_DMA_I_CB_BASE, IPW_SHARED_SRAM_DMA_CONTROL);\n\n\tIPW_DEBUG_FW(\"<< :\\n\");\n\treturn 0;\n}\n\nstatic void ipw_fw_dma_abort(struct ipw_priv *priv)\n{\n\tu32 control = 0;\n\n\tIPW_DEBUG_FW(\">> :\\n\");\n\n\t \n\tcontrol = DMA_CONTROL_SMALL_CB_CONST_VALUE | DMA_CB_STOP_AND_ABORT;\n\tipw_write_reg32(priv, IPW_DMA_I_DMA_CONTROL, control);\n\tpriv->sram_desc.last_cb_index = 0;\n\n\tIPW_DEBUG_FW(\"<<\\n\");\n}\n\nstatic int ipw_fw_dma_write_command_block(struct ipw_priv *priv, int index,\n\t\t\t\t\t  struct command_block *cb)\n{\n\tu32 address =\n\t    IPW_SHARED_SRAM_DMA_CONTROL +\n\t    (sizeof(struct command_block) * index);\n\tIPW_DEBUG_FW(\">> :\\n\");\n\n\tipw_write_indirect(priv, address, (u8 *) cb,\n\t\t\t   (int)sizeof(struct command_block));\n\n\tIPW_DEBUG_FW(\"<< :\\n\");\n\treturn 0;\n\n}\n\nstatic int ipw_fw_dma_kick(struct ipw_priv *priv)\n{\n\tu32 control = 0;\n\tu32 index = 0;\n\n\tIPW_DEBUG_FW(\">> :\\n\");\n\n\tfor (index = 0; index < priv->sram_desc.last_cb_index; index++)\n\t\tipw_fw_dma_write_command_block(priv, index,\n\t\t\t\t\t       &priv->sram_desc.cb_list[index]);\n\n\t \n\tipw_clear_bit(priv, IPW_RESET_REG,\n\t\t      IPW_RESET_REG_MASTER_DISABLED |\n\t\t      IPW_RESET_REG_STOP_MASTER);\n\n\t \n\tcontrol = DMA_CONTROL_SMALL_CB_CONST_VALUE | DMA_CB_START;\n\tipw_write_reg32(priv, IPW_DMA_I_DMA_CONTROL, control);\n\n\tIPW_DEBUG_FW(\"<< :\\n\");\n\treturn 0;\n}\n\nstatic void ipw_fw_dma_dump_command_block(struct ipw_priv *priv)\n{\n\tu32 address;\n\tu32 register_value = 0;\n\tu32 cb_fields_address = 0;\n\n\tIPW_DEBUG_FW(\">> :\\n\");\n\taddress = ipw_read_reg32(priv, IPW_DMA_I_CURRENT_CB);\n\tIPW_DEBUG_FW_INFO(\"Current CB is 0x%x\\n\", address);\n\n\t \n\tregister_value = ipw_read_reg32(priv, IPW_DMA_I_DMA_CONTROL);\n\tIPW_DEBUG_FW_INFO(\"IPW_DMA_I_DMA_CONTROL is 0x%x\\n\", register_value);\n\n\t \n\tcb_fields_address = address;\n\tregister_value = ipw_read_reg32(priv, cb_fields_address);\n\tIPW_DEBUG_FW_INFO(\"Current CB Control Field is 0x%x\\n\", register_value);\n\n\tcb_fields_address += sizeof(u32);\n\tregister_value = ipw_read_reg32(priv, cb_fields_address);\n\tIPW_DEBUG_FW_INFO(\"Current CB Source Field is 0x%x\\n\", register_value);\n\n\tcb_fields_address += sizeof(u32);\n\tregister_value = ipw_read_reg32(priv, cb_fields_address);\n\tIPW_DEBUG_FW_INFO(\"Current CB Destination Field is 0x%x\\n\",\n\t\t\t  register_value);\n\n\tcb_fields_address += sizeof(u32);\n\tregister_value = ipw_read_reg32(priv, cb_fields_address);\n\tIPW_DEBUG_FW_INFO(\"Current CB Status Field is 0x%x\\n\", register_value);\n\n\tIPW_DEBUG_FW(\">> :\\n\");\n}\n\nstatic int ipw_fw_dma_command_block_index(struct ipw_priv *priv)\n{\n\tu32 current_cb_address = 0;\n\tu32 current_cb_index = 0;\n\n\tIPW_DEBUG_FW(\"<< :\\n\");\n\tcurrent_cb_address = ipw_read_reg32(priv, IPW_DMA_I_CURRENT_CB);\n\n\tcurrent_cb_index = (current_cb_address - IPW_SHARED_SRAM_DMA_CONTROL) /\n\t    sizeof(struct command_block);\n\n\tIPW_DEBUG_FW_INFO(\"Current CB index 0x%x address = 0x%X\\n\",\n\t\t\t  current_cb_index, current_cb_address);\n\n\tIPW_DEBUG_FW(\">> :\\n\");\n\treturn current_cb_index;\n\n}\n\nstatic int ipw_fw_dma_add_command_block(struct ipw_priv *priv,\n\t\t\t\t\tu32 src_address,\n\t\t\t\t\tu32 dest_address,\n\t\t\t\t\tu32 length,\n\t\t\t\t\tint interrupt_enabled, int is_last)\n{\n\n\tu32 control = CB_VALID | CB_SRC_LE | CB_DEST_LE | CB_SRC_AUTOINC |\n\t    CB_SRC_IO_GATED | CB_DEST_AUTOINC | CB_SRC_SIZE_LONG |\n\t    CB_DEST_SIZE_LONG;\n\tstruct command_block *cb;\n\tu32 last_cb_element = 0;\n\n\tIPW_DEBUG_FW_INFO(\"src_address=0x%x dest_address=0x%x length=0x%x\\n\",\n\t\t\t  src_address, dest_address, length);\n\n\tif (priv->sram_desc.last_cb_index >= CB_NUMBER_OF_ELEMENTS_SMALL)\n\t\treturn -1;\n\n\tlast_cb_element = priv->sram_desc.last_cb_index;\n\tcb = &priv->sram_desc.cb_list[last_cb_element];\n\tpriv->sram_desc.last_cb_index++;\n\n\t \n\tif (interrupt_enabled)\n\t\tcontrol |= CB_INT_ENABLED;\n\n\tif (is_last)\n\t\tcontrol |= CB_LAST_VALID;\n\n\tcontrol |= length;\n\n\t \n\tcb->status = control ^ src_address ^ dest_address;\n\n\t \n\tcb->dest_addr = dest_address;\n\tcb->source_addr = src_address;\n\n\t \n\tcb->control = control;\n\n\treturn 0;\n}\n\nstatic int ipw_fw_dma_add_buffer(struct ipw_priv *priv, dma_addr_t *src_address,\n\t\t\t\t int nr, u32 dest_address, u32 len)\n{\n\tint ret, i;\n\tu32 size;\n\n\tIPW_DEBUG_FW(\">>\\n\");\n\tIPW_DEBUG_FW_INFO(\"nr=%d dest_address=0x%x len=0x%x\\n\",\n\t\t\t  nr, dest_address, len);\n\n\tfor (i = 0; i < nr; i++) {\n\t\tsize = min_t(u32, len - i * CB_MAX_LENGTH, CB_MAX_LENGTH);\n\t\tret = ipw_fw_dma_add_command_block(priv, src_address[i],\n\t\t\t\t\t\t   dest_address +\n\t\t\t\t\t\t   i * CB_MAX_LENGTH, size,\n\t\t\t\t\t\t   0, 0);\n\t\tif (ret) {\n\t\t\tIPW_DEBUG_FW_INFO(\": Failed\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tIPW_DEBUG_FW_INFO(\": Added new cb\\n\");\n\t}\n\n\tIPW_DEBUG_FW(\"<<\\n\");\n\treturn 0;\n}\n\nstatic int ipw_fw_dma_wait(struct ipw_priv *priv)\n{\n\tu32 current_index = 0, previous_index;\n\tu32 watchdog = 0;\n\n\tIPW_DEBUG_FW(\">> :\\n\");\n\n\tcurrent_index = ipw_fw_dma_command_block_index(priv);\n\tIPW_DEBUG_FW_INFO(\"sram_desc.last_cb_index:0x%08X\\n\",\n\t\t\t  (int)priv->sram_desc.last_cb_index);\n\n\twhile (current_index < priv->sram_desc.last_cb_index) {\n\t\tudelay(50);\n\t\tprevious_index = current_index;\n\t\tcurrent_index = ipw_fw_dma_command_block_index(priv);\n\n\t\tif (previous_index < current_index) {\n\t\t\twatchdog = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (++watchdog > 400) {\n\t\t\tIPW_DEBUG_FW_INFO(\"Timeout\\n\");\n\t\t\tipw_fw_dma_dump_command_block(priv);\n\t\t\tipw_fw_dma_abort(priv);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tipw_fw_dma_abort(priv);\n\n\t \n\tipw_set_bit(priv, IPW_RESET_REG,\n\t\t    IPW_RESET_REG_MASTER_DISABLED | IPW_RESET_REG_STOP_MASTER);\n\n\tIPW_DEBUG_FW(\"<< dmaWaitSync\\n\");\n\treturn 0;\n}\n\nstatic void ipw_remove_current_network(struct ipw_priv *priv)\n{\n\tstruct list_head *element, *safe;\n\tstruct libipw_network *network = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->ieee->lock, flags);\n\tlist_for_each_safe(element, safe, &priv->ieee->network_list) {\n\t\tnetwork = list_entry(element, struct libipw_network, list);\n\t\tif (ether_addr_equal(network->bssid, priv->bssid)) {\n\t\t\tlist_del(element);\n\t\t\tlist_add_tail(&network->list,\n\t\t\t\t      &priv->ieee->network_free_list);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&priv->ieee->lock, flags);\n}\n\n \nstatic int ipw_poll_bit(struct ipw_priv *priv, u32 addr, u32 mask,\n\t\t\t       int timeout)\n{\n\tint i = 0;\n\n\tdo {\n\t\tif ((ipw_read32(priv, addr) & mask) == mask)\n\t\t\treturn i;\n\t\tmdelay(10);\n\t\ti += 10;\n\t} while (i < timeout);\n\n\treturn -ETIME;\n}\n\n \n\nstatic int ipw_stop_master(struct ipw_priv *priv)\n{\n\tint rc;\n\n\tIPW_DEBUG_TRACE(\">>\\n\");\n\t \n\tipw_set_bit(priv, IPW_RESET_REG, IPW_RESET_REG_STOP_MASTER);\n\n\t \n\trc = ipw_poll_bit(priv, IPW_RESET_REG,\n\t\t\t  IPW_RESET_REG_MASTER_DISABLED, 100);\n\tif (rc < 0) {\n\t\tIPW_ERROR(\"wait for stop master failed after 100ms\\n\");\n\t\treturn -1;\n\t}\n\n\tIPW_DEBUG_INFO(\"stop master %dms\\n\", rc);\n\n\treturn rc;\n}\n\nstatic void ipw_arc_release(struct ipw_priv *priv)\n{\n\tIPW_DEBUG_TRACE(\">>\\n\");\n\tmdelay(5);\n\n\tipw_clear_bit(priv, IPW_RESET_REG, CBD_RESET_REG_PRINCETON_RESET);\n\n\t \n\tmdelay(5);\n}\n\nstruct fw_chunk {\n\t__le32 address;\n\t__le32 length;\n};\n\nstatic int ipw_load_ucode(struct ipw_priv *priv, u8 * data, size_t len)\n{\n\tint rc = 0, i, addr;\n\tu8 cr = 0;\n\t__le16 *image;\n\n\timage = (__le16 *) data;\n\n\tIPW_DEBUG_TRACE(\">>\\n\");\n\n\trc = ipw_stop_master(priv);\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\tfor (addr = IPW_SHARED_LOWER_BOUND;\n\t     addr < IPW_REGISTER_DOMAIN1_END; addr += 4) {\n\t\tipw_write32(priv, addr, 0);\n\t}\n\n\t \n\tmemset(&priv->dino_alive, 0, sizeof(priv->dino_alive));\n\t \n\t \n\n\tipw_write_reg32(priv, IPW_MEM_HALT_AND_RESET, IPW_BIT_HALT_RESET_ON);\n\tipw_arc_release(priv);\n\tipw_write_reg32(priv, IPW_MEM_HALT_AND_RESET, IPW_BIT_HALT_RESET_OFF);\n\tmdelay(1);\n\n\t \n\tipw_write_reg32(priv, IPW_INTERNAL_CMD_EVENT, IPW_BASEBAND_POWER_DOWN);\n\tmdelay(1);\n\n\tipw_write_reg32(priv, IPW_INTERNAL_CMD_EVENT, 0);\n\tmdelay(1);\n\n\t \n\tipw_write_reg8(priv, IPW_BASEBAND_CONTROL_STATUS, 0x0);\n\tipw_write_reg8(priv, IPW_BASEBAND_CONTROL_STATUS, DINO_ENABLE_CS);\n\tmdelay(1);\n\n\t \n\t \n\t \n\tfor (i = 0; i < len / 2; i++)\n\t\tipw_write_reg16(priv, IPW_BASEBAND_CONTROL_STORE,\n\t\t\t\tle16_to_cpu(image[i]));\n\n\t \n\tipw_write_reg8(priv, IPW_BASEBAND_CONTROL_STATUS, 0);\n\tipw_write_reg8(priv, IPW_BASEBAND_CONTROL_STATUS, DINO_ENABLE_SYSTEM);\n\n\t \n\n\t \n\tfor (i = 0; i < 100; i++) {\n\t\t \n\t\tcr = ipw_read_reg8(priv, IPW_BASEBAND_CONTROL_STATUS);\n\t\tif (cr & DINO_RXFIFO_DATA)\n\t\t\tbreak;\n\t\tmdelay(1);\n\t}\n\n\tif (cr & DINO_RXFIFO_DATA) {\n\t\t \n\t\t__le32 response_buffer[(sizeof(priv->dino_alive) + 3) / 4];\n\n\t\tfor (i = 0; i < ARRAY_SIZE(response_buffer); i++)\n\t\t\tresponse_buffer[i] =\n\t\t\t    cpu_to_le32(ipw_read_reg32(priv,\n\t\t\t\t\t\t       IPW_BASEBAND_RX_FIFO_READ));\n\t\tmemcpy(&priv->dino_alive, response_buffer,\n\t\t       sizeof(priv->dino_alive));\n\t\tif (priv->dino_alive.alive_command == 1\n\t\t    && priv->dino_alive.ucode_valid == 1) {\n\t\t\trc = 0;\n\t\t\tIPW_DEBUG_INFO\n\t\t\t    (\"Microcode OK, rev. %d (0x%x) dev. %d (0x%x) \"\n\t\t\t     \"of %02d/%02d/%02d %02d:%02d\\n\",\n\t\t\t     priv->dino_alive.software_revision,\n\t\t\t     priv->dino_alive.software_revision,\n\t\t\t     priv->dino_alive.device_identifier,\n\t\t\t     priv->dino_alive.device_identifier,\n\t\t\t     priv->dino_alive.time_stamp[0],\n\t\t\t     priv->dino_alive.time_stamp[1],\n\t\t\t     priv->dino_alive.time_stamp[2],\n\t\t\t     priv->dino_alive.time_stamp[3],\n\t\t\t     priv->dino_alive.time_stamp[4]);\n\t\t} else {\n\t\t\tIPW_DEBUG_INFO(\"Microcode is not alive\\n\");\n\t\t\trc = -EINVAL;\n\t\t}\n\t} else {\n\t\tIPW_DEBUG_INFO(\"No alive response from DINO\\n\");\n\t\trc = -ETIME;\n\t}\n\n\t \n\tipw_write_reg8(priv, IPW_BASEBAND_CONTROL_STATUS, 0);\n\n\treturn rc;\n}\n\nstatic int ipw_load_firmware(struct ipw_priv *priv, u8 * data, size_t len)\n{\n\tint ret = -1;\n\tint offset = 0;\n\tstruct fw_chunk *chunk;\n\tint total_nr = 0;\n\tint i;\n\tstruct dma_pool *pool;\n\tvoid **virts;\n\tdma_addr_t *phys;\n\n\tIPW_DEBUG_TRACE(\"<< :\\n\");\n\n\tvirts = kmalloc_array(CB_NUMBER_OF_ELEMENTS_SMALL, sizeof(void *),\n\t\t\t      GFP_KERNEL);\n\tif (!virts)\n\t\treturn -ENOMEM;\n\n\tphys = kmalloc_array(CB_NUMBER_OF_ELEMENTS_SMALL, sizeof(dma_addr_t),\n\t\t\t     GFP_KERNEL);\n\tif (!phys) {\n\t\tkfree(virts);\n\t\treturn -ENOMEM;\n\t}\n\tpool = dma_pool_create(\"ipw2200\", &priv->pci_dev->dev, CB_MAX_LENGTH, 0,\n\t\t\t       0);\n\tif (!pool) {\n\t\tIPW_ERROR(\"dma_pool_create failed\\n\");\n\t\tkfree(phys);\n\t\tkfree(virts);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tret = ipw_fw_dma_enable(priv);\n\n\t \n\tBUG_ON(priv->sram_desc.last_cb_index > 0);\n\n\tdo {\n\t\tu32 chunk_len;\n\t\tu8 *start;\n\t\tint size;\n\t\tint nr = 0;\n\n\t\tchunk = (struct fw_chunk *)(data + offset);\n\t\toffset += sizeof(struct fw_chunk);\n\t\tchunk_len = le32_to_cpu(chunk->length);\n\t\tstart = data + offset;\n\n\t\tnr = (chunk_len + CB_MAX_LENGTH - 1) / CB_MAX_LENGTH;\n\t\tfor (i = 0; i < nr; i++) {\n\t\t\tvirts[total_nr] = dma_pool_alloc(pool, GFP_KERNEL,\n\t\t\t\t\t\t\t &phys[total_nr]);\n\t\t\tif (!virts[total_nr]) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsize = min_t(u32, chunk_len - i * CB_MAX_LENGTH,\n\t\t\t\t     CB_MAX_LENGTH);\n\t\t\tmemcpy(virts[total_nr], start, size);\n\t\t\tstart += size;\n\t\t\ttotal_nr++;\n\t\t\t \n\t\t\tBUG_ON(total_nr > CB_NUMBER_OF_ELEMENTS_SMALL);\n\t\t}\n\n\t\t \n\t\t \n\t\t \n\t\tret = ipw_fw_dma_add_buffer(priv, &phys[total_nr - nr],\n\t\t\t\t\t    nr, le32_to_cpu(chunk->address),\n\t\t\t\t\t    chunk_len);\n\t\tif (ret) {\n\t\t\tIPW_DEBUG_INFO(\"dmaAddBuffer Failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\toffset += chunk_len;\n\t} while (offset < len);\n\n\t \n\tret = ipw_fw_dma_kick(priv);\n\tif (ret) {\n\t\tIPW_ERROR(\"dmaKick Failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = ipw_fw_dma_wait(priv);\n\tif (ret) {\n\t\tIPW_ERROR(\"dmaWaitSync Failed\\n\");\n\t\tgoto out;\n\t}\n out:\n\tfor (i = 0; i < total_nr; i++)\n\t\tdma_pool_free(pool, virts[i], phys[i]);\n\n\tdma_pool_destroy(pool);\n\tkfree(phys);\n\tkfree(virts);\n\n\treturn ret;\n}\n\n \nstatic int ipw_stop_nic(struct ipw_priv *priv)\n{\n\tint rc = 0;\n\n\t \n\tipw_write32(priv, IPW_RESET_REG, IPW_RESET_REG_STOP_MASTER);\n\n\trc = ipw_poll_bit(priv, IPW_RESET_REG,\n\t\t\t  IPW_RESET_REG_MASTER_DISABLED, 500);\n\tif (rc < 0) {\n\t\tIPW_ERROR(\"wait for reg master disabled failed after 500ms\\n\");\n\t\treturn rc;\n\t}\n\n\tipw_set_bit(priv, IPW_RESET_REG, CBD_RESET_REG_PRINCETON_RESET);\n\n\treturn rc;\n}\n\nstatic void ipw_start_nic(struct ipw_priv *priv)\n{\n\tIPW_DEBUG_TRACE(\">>\\n\");\n\n\t \n\tipw_clear_bit(priv, IPW_RESET_REG,\n\t\t      IPW_RESET_REG_MASTER_DISABLED |\n\t\t      IPW_RESET_REG_STOP_MASTER |\n\t\t      CBD_RESET_REG_PRINCETON_RESET);\n\n\t \n\tipw_set_bit(priv, IPW_GP_CNTRL_RW,\n\t\t    IPW_GP_CNTRL_BIT_HOST_ALLOWS_STANDBY);\n\n\tIPW_DEBUG_TRACE(\"<<\\n\");\n}\n\nstatic int ipw_init_nic(struct ipw_priv *priv)\n{\n\tint rc;\n\n\tIPW_DEBUG_TRACE(\">>\\n\");\n\t \n\t \n\t \n\tipw_set_bit(priv, IPW_GP_CNTRL_RW, IPW_GP_CNTRL_BIT_INIT_DONE);\n\n\t \n\tipw_write32(priv, IPW_READ_INT_REGISTER,\n\t\t    IPW_BIT_INT_HOST_SRAM_READ_INT_REGISTER);\n\n\t \n\trc = ipw_poll_bit(priv, IPW_GP_CNTRL_RW,\n\t\t\t  IPW_GP_CNTRL_BIT_CLOCK_READY, 250);\n\tif (rc < 0)\n\t\tIPW_DEBUG_INFO(\"FAILED wait for clock stablization\\n\");\n\n\t \n\tipw_set_bit(priv, IPW_RESET_REG, IPW_RESET_REG_SW_RESET);\n\n\tudelay(10);\n\n\t \n\tipw_set_bit(priv, IPW_GP_CNTRL_RW, IPW_GP_CNTRL_BIT_INIT_DONE);\n\n\tIPW_DEBUG_TRACE(\">>\\n\");\n\treturn 0;\n}\n\n \nstatic int ipw_reset_nic(struct ipw_priv *priv)\n{\n\tint rc = 0;\n\tunsigned long flags;\n\n\tIPW_DEBUG_TRACE(\">>\\n\");\n\n\trc = ipw_init_nic(priv);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\t \n\tpriv->status &= ~STATUS_HCMD_ACTIVE;\n\twake_up_interruptible(&priv->wait_command_queue);\n\tpriv->status &= ~(STATUS_SCANNING | STATUS_SCAN_ABORTING);\n\twake_up_interruptible(&priv->wait_state);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tIPW_DEBUG_TRACE(\"<<\\n\");\n\treturn rc;\n}\n\n\nstruct ipw_fw {\n\t__le32 ver;\n\t__le32 boot_size;\n\t__le32 ucode_size;\n\t__le32 fw_size;\n\tu8 data[];\n};\n\nstatic int ipw_get_fw(struct ipw_priv *priv,\n\t\t      const struct firmware **raw, const char *name)\n{\n\tstruct ipw_fw *fw;\n\tint rc;\n\n\t \n\trc = request_firmware(raw, name, &priv->pci_dev->dev);\n\tif (rc < 0) {\n\t\tIPW_ERROR(\"%s request_firmware failed: Reason %d\\n\", name, rc);\n\t\treturn rc;\n\t}\n\n\tif ((*raw)->size < sizeof(*fw)) {\n\t\tIPW_ERROR(\"%s is too small (%zd)\\n\", name, (*raw)->size);\n\t\treturn -EINVAL;\n\t}\n\n\tfw = (void *)(*raw)->data;\n\n\tif ((*raw)->size < sizeof(*fw) + le32_to_cpu(fw->boot_size) +\n\t    le32_to_cpu(fw->ucode_size) + le32_to_cpu(fw->fw_size)) {\n\t\tIPW_ERROR(\"%s is too small or corrupt (%zd)\\n\",\n\t\t\t  name, (*raw)->size);\n\t\treturn -EINVAL;\n\t}\n\n\tIPW_DEBUG_INFO(\"Read firmware '%s' image v%d.%d (%zd bytes)\\n\",\n\t\t       name,\n\t\t       le32_to_cpu(fw->ver) >> 16,\n\t\t       le32_to_cpu(fw->ver) & 0xff,\n\t\t       (*raw)->size - sizeof(*fw));\n\treturn 0;\n}\n\n#define IPW_RX_BUF_SIZE (3000)\n\nstatic void ipw_rx_queue_reset(struct ipw_priv *priv,\n\t\t\t\t      struct ipw_rx_queue *rxq)\n{\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&rxq->lock, flags);\n\n\tINIT_LIST_HEAD(&rxq->rx_free);\n\tINIT_LIST_HEAD(&rxq->rx_used);\n\n\t \n\tfor (i = 0; i < RX_FREE_BUFFERS + RX_QUEUE_SIZE; i++) {\n\t\t \n\t\tif (rxq->pool[i].skb != NULL) {\n\t\t\tdma_unmap_single(&priv->pci_dev->dev,\n\t\t\t\t\t rxq->pool[i].dma_addr,\n\t\t\t\t\t IPW_RX_BUF_SIZE, DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb_irq(rxq->pool[i].skb);\n\t\t\trxq->pool[i].skb = NULL;\n\t\t}\n\t\tlist_add_tail(&rxq->pool[i].list, &rxq->rx_used);\n\t}\n\n\t \n\trxq->read = rxq->write = 0;\n\trxq->free_count = 0;\n\tspin_unlock_irqrestore(&rxq->lock, flags);\n}\n\n#ifdef CONFIG_PM\nstatic int fw_loaded = 0;\nstatic const struct firmware *raw = NULL;\n\nstatic void free_firmware(void)\n{\n\tif (fw_loaded) {\n\t\trelease_firmware(raw);\n\t\traw = NULL;\n\t\tfw_loaded = 0;\n\t}\n}\n#else\n#define free_firmware() do {} while (0)\n#endif\n\nstatic int ipw_load(struct ipw_priv *priv)\n{\n#ifndef CONFIG_PM\n\tconst struct firmware *raw = NULL;\n#endif\n\tstruct ipw_fw *fw;\n\tu8 *boot_img, *ucode_img, *fw_img;\n\tu8 *name = NULL;\n\tint rc = 0, retries = 3;\n\n\tswitch (priv->ieee->iw_mode) {\n\tcase IW_MODE_ADHOC:\n\t\tname = \"ipw2200-ibss.fw\";\n\t\tbreak;\n#ifdef CONFIG_IPW2200_MONITOR\n\tcase IW_MODE_MONITOR:\n\t\tname = \"ipw2200-sniffer.fw\";\n\t\tbreak;\n#endif\n\tcase IW_MODE_INFRA:\n\t\tname = \"ipw2200-bss.fw\";\n\t\tbreak;\n\t}\n\n\tif (!name) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n#ifdef CONFIG_PM\n\tif (!fw_loaded) {\n#endif\n\t\trc = ipw_get_fw(priv, &raw, name);\n\t\tif (rc < 0)\n\t\t\tgoto error;\n#ifdef CONFIG_PM\n\t}\n#endif\n\n\tfw = (void *)raw->data;\n\tboot_img = &fw->data[0];\n\tucode_img = &fw->data[le32_to_cpu(fw->boot_size)];\n\tfw_img = &fw->data[le32_to_cpu(fw->boot_size) +\n\t\t\t   le32_to_cpu(fw->ucode_size)];\n\n\tif (!priv->rxq)\n\t\tpriv->rxq = ipw_rx_queue_alloc(priv);\n\telse\n\t\tipw_rx_queue_reset(priv, priv->rxq);\n\tif (!priv->rxq) {\n\t\tIPW_ERROR(\"Unable to initialize Rx queue\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto error;\n\t}\n\n      retry:\n\t \n\tipw_write32(priv, IPW_INTA_MASK_R, ~IPW_INTA_MASK_ALL);\n\tpriv->status &= ~STATUS_INT_ENABLED;\n\n\t \n\tipw_write32(priv, IPW_INTA_RW, IPW_INTA_MASK_ALL);\n\n\tipw_stop_nic(priv);\n\n\trc = ipw_reset_nic(priv);\n\tif (rc < 0) {\n\t\tIPW_ERROR(\"Unable to reset NIC\\n\");\n\t\tgoto error;\n\t}\n\n\tipw_zero_memory(priv, IPW_NIC_SRAM_LOWER_BOUND,\n\t\t\tIPW_NIC_SRAM_UPPER_BOUND - IPW_NIC_SRAM_LOWER_BOUND);\n\n\t \n\trc = ipw_load_firmware(priv, boot_img, le32_to_cpu(fw->boot_size));\n\tif (rc < 0) {\n\t\tIPW_ERROR(\"Unable to load boot firmware: %d\\n\", rc);\n\t\tgoto error;\n\t}\n\n\t \n\tipw_start_nic(priv);\n\n\t \n\trc = ipw_poll_bit(priv, IPW_INTA_RW,\n\t\t\t  IPW_INTA_BIT_FW_INITIALIZATION_DONE, 500);\n\tif (rc < 0) {\n\t\tIPW_ERROR(\"device failed to boot initial fw image\\n\");\n\t\tgoto error;\n\t}\n\tIPW_DEBUG_INFO(\"initial device response after %dms\\n\", rc);\n\n\t \n\tipw_write32(priv, IPW_INTA_RW, IPW_INTA_BIT_FW_INITIALIZATION_DONE);\n\n\t \n\trc = ipw_load_ucode(priv, ucode_img, le32_to_cpu(fw->ucode_size));\n\tif (rc < 0) {\n\t\tIPW_ERROR(\"Unable to load ucode: %d\\n\", rc);\n\t\tgoto error;\n\t}\n\n\t \n\tipw_stop_nic(priv);\n\n\t \n\trc = ipw_load_firmware(priv, fw_img, le32_to_cpu(fw->fw_size));\n\tif (rc < 0) {\n\t\tIPW_ERROR(\"Unable to load firmware: %d\\n\", rc);\n\t\tgoto error;\n\t}\n#ifdef CONFIG_PM\n\tfw_loaded = 1;\n#endif\n\n\tipw_write32(priv, IPW_EEPROM_LOAD_DISABLE, 0);\n\n\trc = ipw_queue_reset(priv);\n\tif (rc < 0) {\n\t\tIPW_ERROR(\"Unable to initialize queues\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tipw_write32(priv, IPW_INTA_MASK_R, ~IPW_INTA_MASK_ALL);\n\t \n\tipw_write32(priv, IPW_INTA_RW, IPW_INTA_MASK_ALL);\n\n\t \n\tipw_start_nic(priv);\n\n\tif (ipw_read32(priv, IPW_INTA_RW) & IPW_INTA_BIT_PARITY_ERROR) {\n\t\tif (retries > 0) {\n\t\t\tIPW_WARNING(\"Parity error.  Retrying init.\\n\");\n\t\t\tretries--;\n\t\t\tgoto retry;\n\t\t}\n\n\t\tIPW_ERROR(\"TODO: Handle parity error -- schedule restart?\\n\");\n\t\trc = -EIO;\n\t\tgoto error;\n\t}\n\n\t \n\trc = ipw_poll_bit(priv, IPW_INTA_RW,\n\t\t\t  IPW_INTA_BIT_FW_INITIALIZATION_DONE, 500);\n\tif (rc < 0) {\n\t\tIPW_ERROR(\"device failed to start within 500ms\\n\");\n\t\tgoto error;\n\t}\n\tIPW_DEBUG_INFO(\"device response after %dms\\n\", rc);\n\n\t \n\tipw_write32(priv, IPW_INTA_RW, IPW_INTA_BIT_FW_INITIALIZATION_DONE);\n\n\t \n\tpriv->eeprom_delay = 1;\n\tipw_read_eeprom(priv);\n\t \n\tipw_eeprom_init_sram(priv);\n\n\t \n\tipw_enable_interrupts(priv);\n\n\t \n\tipw_rx_queue_replenish(priv);\n\n\tipw_write32(priv, IPW_RX_READ_INDEX, priv->rxq->read);\n\n\t \n\tipw_write32(priv, IPW_INTA_RW, IPW_INTA_MASK_ALL);\n\n#ifndef CONFIG_PM\n\trelease_firmware(raw);\n#endif\n\treturn 0;\n\n      error:\n\tif (priv->rxq) {\n\t\tipw_rx_queue_free(priv, priv->rxq);\n\t\tpriv->rxq = NULL;\n\t}\n\tipw_tx_queue_free(priv);\n\trelease_firmware(raw);\n#ifdef CONFIG_PM\n\tfw_loaded = 0;\n\traw = NULL;\n#endif\n\n\treturn rc;\n}\n\n \n\n \n\n \nstatic int ipw_rx_queue_space(const struct ipw_rx_queue *q)\n{\n\tint s = q->read - q->write;\n\tif (s <= 0)\n\t\ts += RX_QUEUE_SIZE;\n\t \n\ts -= 2;\n\tif (s < 0)\n\t\ts = 0;\n\treturn s;\n}\n\nstatic inline int ipw_tx_queue_space(const struct clx2_queue *q)\n{\n\tint s = q->last_used - q->first_empty;\n\tif (s <= 0)\n\t\ts += q->n_bd;\n\ts -= 2;\t\t\t \n\tif (s < 0)\n\t\ts = 0;\n\treturn s;\n}\n\nstatic inline int ipw_queue_inc_wrap(int index, int n_bd)\n{\n\treturn (++index == n_bd) ? 0 : index;\n}\n\n \nstatic void ipw_queue_init(struct ipw_priv *priv, struct clx2_queue *q,\n\t\t\t   int count, u32 read, u32 write, u32 base, u32 size)\n{\n\tq->n_bd = count;\n\n\tq->low_mark = q->n_bd / 4;\n\tif (q->low_mark < 4)\n\t\tq->low_mark = 4;\n\n\tq->high_mark = q->n_bd / 8;\n\tif (q->high_mark < 2)\n\t\tq->high_mark = 2;\n\n\tq->first_empty = q->last_used = 0;\n\tq->reg_r = read;\n\tq->reg_w = write;\n\n\tipw_write32(priv, base, q->dma_addr);\n\tipw_write32(priv, size, count);\n\tipw_write32(priv, read, 0);\n\tipw_write32(priv, write, 0);\n\n\t_ipw_read32(priv, 0x90);\n}\n\nstatic int ipw_queue_tx_init(struct ipw_priv *priv,\n\t\t\t     struct clx2_tx_queue *q,\n\t\t\t     int count, u32 read, u32 write, u32 base, u32 size)\n{\n\tstruct pci_dev *dev = priv->pci_dev;\n\n\tq->txb = kmalloc_array(count, sizeof(q->txb[0]), GFP_KERNEL);\n\tif (!q->txb)\n\t\treturn -ENOMEM;\n\n\tq->bd =\n\t    dma_alloc_coherent(&dev->dev, sizeof(q->bd[0]) * count,\n\t\t\t       &q->q.dma_addr, GFP_KERNEL);\n\tif (!q->bd) {\n\t\tIPW_ERROR(\"dma_alloc_coherent(%zd) failed\\n\",\n\t\t\t  sizeof(q->bd[0]) * count);\n\t\tkfree(q->txb);\n\t\tq->txb = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tipw_queue_init(priv, &q->q, count, read, write, base, size);\n\treturn 0;\n}\n\n \nstatic void ipw_queue_tx_free_tfd(struct ipw_priv *priv,\n\t\t\t\t  struct clx2_tx_queue *txq)\n{\n\tstruct tfd_frame *bd = &txq->bd[txq->q.last_used];\n\tstruct pci_dev *dev = priv->pci_dev;\n\tint i;\n\n\t \n\tif (bd->control_flags.message_type == TX_HOST_COMMAND_TYPE)\n\t\t \n\t\treturn;\n\n\t \n\tif (le32_to_cpu(bd->u.data.num_chunks) > NUM_TFD_CHUNKS) {\n\t\tIPW_ERROR(\"Too many chunks: %i\\n\",\n\t\t\t  le32_to_cpu(bd->u.data.num_chunks));\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0; i < le32_to_cpu(bd->u.data.num_chunks); i++) {\n\t\tdma_unmap_single(&dev->dev,\n\t\t\t\t le32_to_cpu(bd->u.data.chunk_ptr[i]),\n\t\t\t\t le16_to_cpu(bd->u.data.chunk_len[i]),\n\t\t\t\t DMA_TO_DEVICE);\n\t\tif (txq->txb[txq->q.last_used]) {\n\t\t\tlibipw_txb_free(txq->txb[txq->q.last_used]);\n\t\t\ttxq->txb[txq->q.last_used] = NULL;\n\t\t}\n\t}\n}\n\n \nstatic void ipw_queue_tx_free(struct ipw_priv *priv, struct clx2_tx_queue *txq)\n{\n\tstruct clx2_queue *q = &txq->q;\n\tstruct pci_dev *dev = priv->pci_dev;\n\n\tif (q->n_bd == 0)\n\t\treturn;\n\n\t \n\tfor (; q->first_empty != q->last_used;\n\t     q->last_used = ipw_queue_inc_wrap(q->last_used, q->n_bd)) {\n\t\tipw_queue_tx_free_tfd(priv, txq);\n\t}\n\n\t \n\tdma_free_coherent(&dev->dev, sizeof(txq->bd[0]) * q->n_bd, txq->bd,\n\t\t\t  q->dma_addr);\n\tkfree(txq->txb);\n\n\t \n\tmemset(txq, 0, sizeof(*txq));\n}\n\n \nstatic void ipw_tx_queue_free(struct ipw_priv *priv)\n{\n\t \n\tipw_queue_tx_free(priv, &priv->txq_cmd);\n\n\t \n\tipw_queue_tx_free(priv, &priv->txq[0]);\n\tipw_queue_tx_free(priv, &priv->txq[1]);\n\tipw_queue_tx_free(priv, &priv->txq[2]);\n\tipw_queue_tx_free(priv, &priv->txq[3]);\n}\n\nstatic void ipw_create_bssid(struct ipw_priv *priv, u8 * bssid)\n{\n\t \n\tbssid[0] = priv->mac_addr[0];\n\tbssid[1] = priv->mac_addr[1];\n\tbssid[2] = priv->mac_addr[2];\n\n\t \n\tget_random_bytes(&bssid[3], ETH_ALEN - 3);\n\n\tbssid[0] &= 0xfe;\t \n\tbssid[0] |= 0x02;\t \n}\n\nstatic u8 ipw_add_station(struct ipw_priv *priv, u8 * bssid)\n{\n\tstruct ipw_station_entry entry;\n\tint i;\n\n\tfor (i = 0; i < priv->num_stations; i++) {\n\t\tif (ether_addr_equal(priv->stations[i], bssid)) {\n\t\t\t \n\t\t\tpriv->missed_adhoc_beacons = 0;\n\t\t\tif (!(priv->config & CFG_STATIC_CHANNEL))\n\t\t\t\t \n\t\t\t\tpriv->config &= ~CFG_ADHOC_PERSIST;\n\n\t\t\treturn i;\n\t\t}\n\t}\n\n\tif (i == MAX_STATIONS)\n\t\treturn IPW_INVALID_STATION;\n\n\tIPW_DEBUG_SCAN(\"Adding AdHoc station: %pM\\n\", bssid);\n\n\tentry.reserved = 0;\n\tentry.support_mode = 0;\n\tmemcpy(entry.mac_addr, bssid, ETH_ALEN);\n\tmemcpy(priv->stations[i], bssid, ETH_ALEN);\n\tipw_write_direct(priv, IPW_STATION_TABLE_LOWER + i * sizeof(entry),\n\t\t\t &entry, sizeof(entry));\n\tpriv->num_stations++;\n\n\treturn i;\n}\n\nstatic u8 ipw_find_station(struct ipw_priv *priv, u8 * bssid)\n{\n\tint i;\n\n\tfor (i = 0; i < priv->num_stations; i++)\n\t\tif (ether_addr_equal(priv->stations[i], bssid))\n\t\t\treturn i;\n\n\treturn IPW_INVALID_STATION;\n}\n\nstatic void ipw_send_disassociate(struct ipw_priv *priv, int quiet)\n{\n\tint err;\n\n\tif (priv->status & STATUS_ASSOCIATING) {\n\t\tIPW_DEBUG_ASSOC(\"Disassociating while associating.\\n\");\n\t\tschedule_work(&priv->disassociate);\n\t\treturn;\n\t}\n\n\tif (!(priv->status & STATUS_ASSOCIATED)) {\n\t\tIPW_DEBUG_ASSOC(\"Disassociating while not associated.\\n\");\n\t\treturn;\n\t}\n\n\tIPW_DEBUG_ASSOC(\"Disassociation attempt from %pM \"\n\t\t\t\"on channel %d.\\n\",\n\t\t\tpriv->assoc_request.bssid,\n\t\t\tpriv->assoc_request.channel);\n\n\tpriv->status &= ~(STATUS_ASSOCIATING | STATUS_ASSOCIATED);\n\tpriv->status |= STATUS_DISASSOCIATING;\n\n\tif (quiet)\n\t\tpriv->assoc_request.assoc_type = HC_DISASSOC_QUIET;\n\telse\n\t\tpriv->assoc_request.assoc_type = HC_DISASSOCIATE;\n\n\terr = ipw_send_associate(priv, &priv->assoc_request);\n\tif (err) {\n\t\tIPW_DEBUG_HC(\"Attempt to send [dis]associate command \"\n\t\t\t     \"failed.\\n\");\n\t\treturn;\n\t}\n\n}\n\nstatic int ipw_disassociate(void *data)\n{\n\tstruct ipw_priv *priv = data;\n\tif (!(priv->status & (STATUS_ASSOCIATED | STATUS_ASSOCIATING)))\n\t\treturn 0;\n\tipw_send_disassociate(data, 0);\n\tnetif_carrier_off(priv->net_dev);\n\treturn 1;\n}\n\nstatic void ipw_bg_disassociate(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, disassociate);\n\tmutex_lock(&priv->mutex);\n\tipw_disassociate(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void ipw_system_config(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, system_config);\n\n#ifdef CONFIG_IPW2200_PROMISCUOUS\n\tif (priv->prom_net_dev && netif_running(priv->prom_net_dev)) {\n\t\tpriv->sys_config.accept_all_data_frames = 1;\n\t\tpriv->sys_config.accept_non_directed_frames = 1;\n\t\tpriv->sys_config.accept_all_mgmt_bcpr = 1;\n\t\tpriv->sys_config.accept_all_mgmt_frames = 1;\n\t}\n#endif\n\n\tipw_send_system_config(priv);\n}\n\nstruct ipw_status_code {\n\tu16 status;\n\tconst char *reason;\n};\n\nstatic const struct ipw_status_code ipw_status_codes[] = {\n\t{0x00, \"Successful\"},\n\t{0x01, \"Unspecified failure\"},\n\t{0x0A, \"Cannot support all requested capabilities in the \"\n\t \"Capability information field\"},\n\t{0x0B, \"Reassociation denied due to inability to confirm that \"\n\t \"association exists\"},\n\t{0x0C, \"Association denied due to reason outside the scope of this \"\n\t \"standard\"},\n\t{0x0D,\n\t \"Responding station does not support the specified authentication \"\n\t \"algorithm\"},\n\t{0x0E,\n\t \"Received an Authentication frame with authentication sequence \"\n\t \"transaction sequence number out of expected sequence\"},\n\t{0x0F, \"Authentication rejected because of challenge failure\"},\n\t{0x10, \"Authentication rejected due to timeout waiting for next \"\n\t \"frame in sequence\"},\n\t{0x11, \"Association denied because AP is unable to handle additional \"\n\t \"associated stations\"},\n\t{0x12,\n\t \"Association denied due to requesting station not supporting all \"\n\t \"of the datarates in the BSSBasicServiceSet Parameter\"},\n\t{0x13,\n\t \"Association denied due to requesting station not supporting \"\n\t \"short preamble operation\"},\n\t{0x14,\n\t \"Association denied due to requesting station not supporting \"\n\t \"PBCC encoding\"},\n\t{0x15,\n\t \"Association denied due to requesting station not supporting \"\n\t \"channel agility\"},\n\t{0x19,\n\t \"Association denied due to requesting station not supporting \"\n\t \"short slot operation\"},\n\t{0x1A,\n\t \"Association denied due to requesting station not supporting \"\n\t \"DSSS-OFDM operation\"},\n\t{0x28, \"Invalid Information Element\"},\n\t{0x29, \"Group Cipher is not valid\"},\n\t{0x2A, \"Pairwise Cipher is not valid\"},\n\t{0x2B, \"AKMP is not valid\"},\n\t{0x2C, \"Unsupported RSN IE version\"},\n\t{0x2D, \"Invalid RSN IE Capabilities\"},\n\t{0x2E, \"Cipher suite is rejected per security policy\"},\n};\n\nstatic const char *ipw_get_status_code(u16 status)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(ipw_status_codes); i++)\n\t\tif (ipw_status_codes[i].status == (status & 0xff))\n\t\t\treturn ipw_status_codes[i].reason;\n\treturn \"Unknown status value.\";\n}\n\nstatic inline void average_init(struct average *avg)\n{\n\tmemset(avg, 0, sizeof(*avg));\n}\n\n#define DEPTH_RSSI 8\n#define DEPTH_NOISE 16\nstatic s16 exponential_average(s16 prev_avg, s16 val, u8 depth)\n{\n\treturn ((depth-1)*prev_avg +  val)/depth;\n}\n\nstatic void average_add(struct average *avg, s16 val)\n{\n\tavg->sum -= avg->entries[avg->pos];\n\tavg->sum += val;\n\tavg->entries[avg->pos++] = val;\n\tif (unlikely(avg->pos == AVG_ENTRIES)) {\n\t\tavg->init = 1;\n\t\tavg->pos = 0;\n\t}\n}\n\nstatic s16 average_value(struct average *avg)\n{\n\tif (!unlikely(avg->init)) {\n\t\tif (avg->pos)\n\t\t\treturn avg->sum / avg->pos;\n\t\treturn 0;\n\t}\n\n\treturn avg->sum / AVG_ENTRIES;\n}\n\nstatic void ipw_reset_stats(struct ipw_priv *priv)\n{\n\tu32 len = sizeof(u32);\n\n\tpriv->quality = 0;\n\n\taverage_init(&priv->average_missed_beacons);\n\tpriv->exp_avg_rssi = -60;\n\tpriv->exp_avg_noise = -85 + 0x100;\n\n\tpriv->last_rate = 0;\n\tpriv->last_missed_beacons = 0;\n\tpriv->last_rx_packets = 0;\n\tpriv->last_tx_packets = 0;\n\tpriv->last_tx_failures = 0;\n\n\t \n\tipw_get_ordinal(priv, IPW_ORD_STAT_RX_ERR_CRC,\n\t\t\t&priv->last_rx_err, &len);\n\tipw_get_ordinal(priv, IPW_ORD_STAT_TX_FAILURE,\n\t\t\t&priv->last_tx_failures, &len);\n\n\t \n\tpriv->missed_adhoc_beacons = 0;\n\tpriv->missed_beacons = 0;\n\tpriv->tx_packets = 0;\n\tpriv->rx_packets = 0;\n\n}\n\nstatic u32 ipw_get_max_rate(struct ipw_priv *priv)\n{\n\tu32 i = 0x80000000;\n\tu32 mask = priv->rates_mask;\n\t \n\tif (priv->assoc_request.ieee_mode == IPW_B_MODE)\n\t\tmask &= LIBIPW_CCK_RATES_MASK;\n\n\t \n\n\twhile (i && !(mask & i))\n\t\ti >>= 1;\n\tswitch (i) {\n\tcase LIBIPW_CCK_RATE_1MB_MASK:\n\t\treturn 1000000;\n\tcase LIBIPW_CCK_RATE_2MB_MASK:\n\t\treturn 2000000;\n\tcase LIBIPW_CCK_RATE_5MB_MASK:\n\t\treturn 5500000;\n\tcase LIBIPW_OFDM_RATE_6MB_MASK:\n\t\treturn 6000000;\n\tcase LIBIPW_OFDM_RATE_9MB_MASK:\n\t\treturn 9000000;\n\tcase LIBIPW_CCK_RATE_11MB_MASK:\n\t\treturn 11000000;\n\tcase LIBIPW_OFDM_RATE_12MB_MASK:\n\t\treturn 12000000;\n\tcase LIBIPW_OFDM_RATE_18MB_MASK:\n\t\treturn 18000000;\n\tcase LIBIPW_OFDM_RATE_24MB_MASK:\n\t\treturn 24000000;\n\tcase LIBIPW_OFDM_RATE_36MB_MASK:\n\t\treturn 36000000;\n\tcase LIBIPW_OFDM_RATE_48MB_MASK:\n\t\treturn 48000000;\n\tcase LIBIPW_OFDM_RATE_54MB_MASK:\n\t\treturn 54000000;\n\t}\n\n\tif (priv->ieee->mode == IEEE_B)\n\t\treturn 11000000;\n\telse\n\t\treturn 54000000;\n}\n\nstatic u32 ipw_get_current_rate(struct ipw_priv *priv)\n{\n\tu32 rate, len = sizeof(rate);\n\tint err;\n\n\tif (!(priv->status & STATUS_ASSOCIATED))\n\t\treturn 0;\n\n\tif (priv->tx_packets > IPW_REAL_RATE_RX_PACKET_THRESHOLD) {\n\t\terr = ipw_get_ordinal(priv, IPW_ORD_STAT_TX_CURR_RATE, &rate,\n\t\t\t\t      &len);\n\t\tif (err) {\n\t\t\tIPW_DEBUG_INFO(\"failed querying ordinals.\\n\");\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\treturn ipw_get_max_rate(priv);\n\n\tswitch (rate) {\n\tcase IPW_TX_RATE_1MB:\n\t\treturn 1000000;\n\tcase IPW_TX_RATE_2MB:\n\t\treturn 2000000;\n\tcase IPW_TX_RATE_5MB:\n\t\treturn 5500000;\n\tcase IPW_TX_RATE_6MB:\n\t\treturn 6000000;\n\tcase IPW_TX_RATE_9MB:\n\t\treturn 9000000;\n\tcase IPW_TX_RATE_11MB:\n\t\treturn 11000000;\n\tcase IPW_TX_RATE_12MB:\n\t\treturn 12000000;\n\tcase IPW_TX_RATE_18MB:\n\t\treturn 18000000;\n\tcase IPW_TX_RATE_24MB:\n\t\treturn 24000000;\n\tcase IPW_TX_RATE_36MB:\n\t\treturn 36000000;\n\tcase IPW_TX_RATE_48MB:\n\t\treturn 48000000;\n\tcase IPW_TX_RATE_54MB:\n\t\treturn 54000000;\n\t}\n\n\treturn 0;\n}\n\n#define IPW_STATS_INTERVAL (2 * HZ)\nstatic void ipw_gather_stats(struct ipw_priv *priv)\n{\n\tu32 rx_err, rx_err_delta, rx_packets_delta;\n\tu32 tx_failures, tx_failures_delta, tx_packets_delta;\n\tu32 missed_beacons_percent, missed_beacons_delta;\n\tu32 quality = 0;\n\tu32 len = sizeof(u32);\n\ts16 rssi;\n\tu32 beacon_quality, signal_quality, tx_quality, rx_quality,\n\t    rate_quality;\n\tu32 max_rate;\n\n\tif (!(priv->status & STATUS_ASSOCIATED)) {\n\t\tpriv->quality = 0;\n\t\treturn;\n\t}\n\n\t \n\tipw_get_ordinal(priv, IPW_ORD_STAT_MISSED_BEACONS,\n\t\t\t&priv->missed_beacons, &len);\n\tmissed_beacons_delta = priv->missed_beacons - priv->last_missed_beacons;\n\tpriv->last_missed_beacons = priv->missed_beacons;\n\tif (priv->assoc_request.beacon_interval) {\n\t\tmissed_beacons_percent = missed_beacons_delta *\n\t\t    (HZ * le16_to_cpu(priv->assoc_request.beacon_interval)) /\n\t\t    (IPW_STATS_INTERVAL * 10);\n\t} else {\n\t\tmissed_beacons_percent = 0;\n\t}\n\taverage_add(&priv->average_missed_beacons, missed_beacons_percent);\n\n\tipw_get_ordinal(priv, IPW_ORD_STAT_RX_ERR_CRC, &rx_err, &len);\n\trx_err_delta = rx_err - priv->last_rx_err;\n\tpriv->last_rx_err = rx_err;\n\n\tipw_get_ordinal(priv, IPW_ORD_STAT_TX_FAILURE, &tx_failures, &len);\n\ttx_failures_delta = tx_failures - priv->last_tx_failures;\n\tpriv->last_tx_failures = tx_failures;\n\n\trx_packets_delta = priv->rx_packets - priv->last_rx_packets;\n\tpriv->last_rx_packets = priv->rx_packets;\n\n\ttx_packets_delta = priv->tx_packets - priv->last_tx_packets;\n\tpriv->last_tx_packets = priv->tx_packets;\n\n\t \n#define BEACON_THRESHOLD 5\n\tbeacon_quality = 100 - missed_beacons_percent;\n\tif (beacon_quality < BEACON_THRESHOLD)\n\t\tbeacon_quality = 0;\n\telse\n\t\tbeacon_quality = (beacon_quality - BEACON_THRESHOLD) * 100 /\n\t\t    (100 - BEACON_THRESHOLD);\n\tIPW_DEBUG_STATS(\"Missed beacon: %3d%% (%d%%)\\n\",\n\t\t\tbeacon_quality, missed_beacons_percent);\n\n\tpriv->last_rate = ipw_get_current_rate(priv);\n\tmax_rate = ipw_get_max_rate(priv);\n\trate_quality = priv->last_rate * 40 / max_rate + 60;\n\tIPW_DEBUG_STATS(\"Rate quality : %3d%% (%dMbs)\\n\",\n\t\t\trate_quality, priv->last_rate / 1000000);\n\n\tif (rx_packets_delta > 100 && rx_packets_delta + rx_err_delta)\n\t\trx_quality = 100 - (rx_err_delta * 100) /\n\t\t    (rx_packets_delta + rx_err_delta);\n\telse\n\t\trx_quality = 100;\n\tIPW_DEBUG_STATS(\"Rx quality   : %3d%% (%u errors, %u packets)\\n\",\n\t\t\trx_quality, rx_err_delta, rx_packets_delta);\n\n\tif (tx_packets_delta > 100 && tx_packets_delta + tx_failures_delta)\n\t\ttx_quality = 100 - (tx_failures_delta * 100) /\n\t\t    (tx_packets_delta + tx_failures_delta);\n\telse\n\t\ttx_quality = 100;\n\tIPW_DEBUG_STATS(\"Tx quality   : %3d%% (%u errors, %u packets)\\n\",\n\t\t\ttx_quality, tx_failures_delta, tx_packets_delta);\n\n\trssi = priv->exp_avg_rssi;\n\tsignal_quality =\n\t    (100 *\n\t     (priv->ieee->perfect_rssi - priv->ieee->worst_rssi) *\n\t     (priv->ieee->perfect_rssi - priv->ieee->worst_rssi) -\n\t     (priv->ieee->perfect_rssi - rssi) *\n\t     (15 * (priv->ieee->perfect_rssi - priv->ieee->worst_rssi) +\n\t      62 * (priv->ieee->perfect_rssi - rssi))) /\n\t    ((priv->ieee->perfect_rssi - priv->ieee->worst_rssi) *\n\t     (priv->ieee->perfect_rssi - priv->ieee->worst_rssi));\n\tif (signal_quality > 100)\n\t\tsignal_quality = 100;\n\telse if (signal_quality < 1)\n\t\tsignal_quality = 0;\n\n\tIPW_DEBUG_STATS(\"Signal level : %3d%% (%d dBm)\\n\",\n\t\t\tsignal_quality, rssi);\n\n\tquality = min(rx_quality, signal_quality);\n\tquality = min(tx_quality, quality);\n\tquality = min(rate_quality, quality);\n\tquality = min(beacon_quality, quality);\n\tif (quality == beacon_quality)\n\t\tIPW_DEBUG_STATS(\"Quality (%d%%): Clamped to missed beacons.\\n\",\n\t\t\t\tquality);\n\tif (quality == rate_quality)\n\t\tIPW_DEBUG_STATS(\"Quality (%d%%): Clamped to rate quality.\\n\",\n\t\t\t\tquality);\n\tif (quality == tx_quality)\n\t\tIPW_DEBUG_STATS(\"Quality (%d%%): Clamped to Tx quality.\\n\",\n\t\t\t\tquality);\n\tif (quality == rx_quality)\n\t\tIPW_DEBUG_STATS(\"Quality (%d%%): Clamped to Rx quality.\\n\",\n\t\t\t\tquality);\n\tif (quality == signal_quality)\n\t\tIPW_DEBUG_STATS(\"Quality (%d%%): Clamped to signal quality.\\n\",\n\t\t\t\tquality);\n\n\tpriv->quality = quality;\n\n\tschedule_delayed_work(&priv->gather_stats, IPW_STATS_INTERVAL);\n}\n\nstatic void ipw_bg_gather_stats(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, gather_stats.work);\n\tmutex_lock(&priv->mutex);\n\tipw_gather_stats(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\n \nstatic void ipw_handle_missed_beacon(struct ipw_priv *priv,\n\t\t\t\t\t    int missed_count)\n{\n\tpriv->notif_missed_beacons = missed_count;\n\n\tif (missed_count > priv->disassociate_threshold &&\n\t    priv->status & STATUS_ASSOCIATED) {\n\t\t \n\t\tIPW_DEBUG(IPW_DL_INFO | IPW_DL_NOTIF |\n\t\t\t  IPW_DL_STATE | IPW_DL_ASSOC,\n\t\t\t  \"Missed beacon: %d - disassociate\\n\", missed_count);\n\t\tpriv->status &= ~STATUS_ROAMING;\n\t\tif (priv->status & STATUS_SCANNING) {\n\t\t\tIPW_DEBUG(IPW_DL_INFO | IPW_DL_NOTIF |\n\t\t\t\t  IPW_DL_STATE,\n\t\t\t\t  \"Aborting scan with missed beacon.\\n\");\n\t\t\tschedule_work(&priv->abort_scan);\n\t\t}\n\n\t\tschedule_work(&priv->disassociate);\n\t\treturn;\n\t}\n\n\tif (priv->status & STATUS_ROAMING) {\n\t\t \n\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE,\n\t\t\t  \"Missed beacon: %d - roam in progress\\n\",\n\t\t\t  missed_count);\n\t\treturn;\n\t}\n\n\tif (roaming &&\n\t    (missed_count > priv->roaming_threshold &&\n\t     missed_count <= priv->disassociate_threshold)) {\n\t\t \n\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE,\n\t\t\t  \"Missed beacon: %d - initiate \"\n\t\t\t  \"roaming\\n\", missed_count);\n\t\tif (!(priv->status & STATUS_ROAMING)) {\n\t\t\tpriv->status |= STATUS_ROAMING;\n\t\t\tif (!(priv->status & STATUS_SCANNING))\n\t\t\t\tschedule_delayed_work(&priv->request_scan, 0);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (priv->status & STATUS_SCANNING &&\n\t    missed_count > IPW_MB_SCAN_CANCEL_THRESHOLD) {\n\t\t \n\t\tIPW_DEBUG(IPW_DL_INFO | IPW_DL_NOTIF | IPW_DL_STATE,\n\t\t\t  \"Aborting scan with missed beacon.\\n\");\n\t\tschedule_work(&priv->abort_scan);\n\t}\n\n\tIPW_DEBUG_NOTIF(\"Missed beacon: %d\\n\", missed_count);\n}\n\nstatic void ipw_scan_event(struct work_struct *work)\n{\n\tunion iwreq_data wrqu;\n\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, scan_event.work);\n\n\twrqu.data.length = 0;\n\twrqu.data.flags = 0;\n\twireless_send_event(priv->net_dev, SIOCGIWSCAN, &wrqu, NULL);\n}\n\nstatic void handle_scan_event(struct ipw_priv *priv)\n{\n\t \n\tif (!priv->user_requested_scan) {\n\t\tschedule_delayed_work(&priv->scan_event,\n\t\t\t\t      round_jiffies_relative(msecs_to_jiffies(4000)));\n\t} else {\n\t\tpriv->user_requested_scan = 0;\n\t\tmod_delayed_work(system_wq, &priv->scan_event, 0);\n\t}\n}\n\n \nstatic void ipw_rx_notification(struct ipw_priv *priv,\n\t\t\t\t       struct ipw_rx_notification *notif)\n{\n\tu16 size = le16_to_cpu(notif->size);\n\n\tIPW_DEBUG_NOTIF(\"type = %i (%d bytes)\\n\", notif->subtype, size);\n\n\tswitch (notif->subtype) {\n\tcase HOST_NOTIFICATION_STATUS_ASSOCIATED:{\n\t\t\tstruct notif_association *assoc = &notif->u.assoc;\n\n\t\t\tswitch (assoc->state) {\n\t\t\tcase CMAS_ASSOCIATED:{\n\t\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t\t  IPW_DL_ASSOC,\n\t\t\t\t\t\t  \"associated: '%*pE' %pM\\n\",\n\t\t\t\t\t\t  priv->essid_len, priv->essid,\n\t\t\t\t\t\t  priv->bssid);\n\n\t\t\t\t\tswitch (priv->ieee->iw_mode) {\n\t\t\t\t\tcase IW_MODE_INFRA:\n\t\t\t\t\t\tmemcpy(priv->ieee->bssid,\n\t\t\t\t\t\t       priv->bssid, ETH_ALEN);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IW_MODE_ADHOC:\n\t\t\t\t\t\tmemcpy(priv->ieee->bssid,\n\t\t\t\t\t\t       priv->bssid, ETH_ALEN);\n\n\t\t\t\t\t\t \n\t\t\t\t\t\tpriv->num_stations = 0;\n\n\t\t\t\t\t\tIPW_DEBUG_ASSOC\n\t\t\t\t\t\t    (\"queueing adhoc check\\n\");\n\t\t\t\t\t\tschedule_delayed_work(\n\t\t\t\t\t\t\t&priv->adhoc_check,\n\t\t\t\t\t\t\tle16_to_cpu(priv->\n\t\t\t\t\t\t\tassoc_request.\n\t\t\t\t\t\t\tbeacon_interval));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tpriv->status &= ~STATUS_ASSOCIATING;\n\t\t\t\t\tpriv->status |= STATUS_ASSOCIATED;\n\t\t\t\t\tschedule_work(&priv->system_config);\n\n#ifdef CONFIG_IPW2200_QOS\n#define IPW_GET_PACKET_STYPE(x) WLAN_FC_GET_STYPE( \\\n\t\t\t le16_to_cpu(((struct ieee80211_hdr *)(x))->frame_control))\n\t\t\t\t\tif ((priv->status & STATUS_AUTH) &&\n\t\t\t\t\t    (IPW_GET_PACKET_STYPE(&notif->u.raw)\n\t\t\t\t\t     == IEEE80211_STYPE_ASSOC_RESP)) {\n\t\t\t\t\t\tif ((sizeof\n\t\t\t\t\t\t     (struct\n\t\t\t\t\t\t      libipw_assoc_response)\n\t\t\t\t\t\t     <= size)\n\t\t\t\t\t\t    && (size <= 2314)) {\n\t\t\t\t\t\t\tstruct\n\t\t\t\t\t\t\tlibipw_rx_stats\n\t\t\t\t\t\t\t    stats = {\n\t\t\t\t\t\t\t\t.len = size - 1,\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tIPW_DEBUG_QOS\n\t\t\t\t\t\t\t    (\"QoS Associate \"\n\t\t\t\t\t\t\t     \"size %d\\n\", size);\n\t\t\t\t\t\t\tlibipw_rx_mgt(priv->\n\t\t\t\t\t\t\t\t\t ieee,\n\t\t\t\t\t\t\t\t\t (struct\n\t\t\t\t\t\t\t\t\t  libipw_hdr_4addr\n\t\t\t\t\t\t\t\t\t  *)\n\t\t\t\t\t\t\t\t\t &notif->u.raw, &stats);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\n\t\t\t\t\tschedule_work(&priv->link_up);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase CMAS_AUTHENTICATED:{\n\t\t\t\t\tif (priv->\n\t\t\t\t\t    status & (STATUS_ASSOCIATED |\n\t\t\t\t\t\t      STATUS_AUTH)) {\n\t\t\t\t\t\tstruct notif_authenticate *auth\n\t\t\t\t\t\t    = &notif->u.auth;\n\t\t\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF |\n\t\t\t\t\t\t\t  IPW_DL_STATE |\n\t\t\t\t\t\t\t  IPW_DL_ASSOC,\n\t\t\t\t\t\t\t  \"deauthenticated: '%*pE' %pM: (0x%04X) - %s\\n\",\n\t\t\t\t\t\t\t  priv->essid_len,\n\t\t\t\t\t\t\t  priv->essid,\n\t\t\t\t\t\t\t  priv->bssid,\n\t\t\t\t\t\t\t  le16_to_cpu(auth->status),\n\t\t\t\t\t\t\t  ipw_get_status_code\n\t\t\t\t\t\t\t  (le16_to_cpu\n\t\t\t\t\t\t\t   (auth->status)));\n\n\t\t\t\t\t\tpriv->status &=\n\t\t\t\t\t\t    ~(STATUS_ASSOCIATING |\n\t\t\t\t\t\t      STATUS_AUTH |\n\t\t\t\t\t\t      STATUS_ASSOCIATED);\n\n\t\t\t\t\t\tschedule_work(&priv->link_down);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t\t  IPW_DL_ASSOC,\n\t\t\t\t\t\t  \"authenticated: '%*pE' %pM\\n\",\n\t\t\t\t\t\t  priv->essid_len, priv->essid,\n\t\t\t\t\t\t  priv->bssid);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase CMAS_INIT:{\n\t\t\t\t\tif (priv->status & STATUS_AUTH) {\n\t\t\t\t\t\tstruct\n\t\t\t\t\t\t    libipw_assoc_response\n\t\t\t\t\t\t*resp;\n\t\t\t\t\t\tresp =\n\t\t\t\t\t\t    (struct\n\t\t\t\t\t\t     libipw_assoc_response\n\t\t\t\t\t\t     *)&notif->u.raw;\n\t\t\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF |\n\t\t\t\t\t\t\t  IPW_DL_STATE |\n\t\t\t\t\t\t\t  IPW_DL_ASSOC,\n\t\t\t\t\t\t\t  \"association failed (0x%04X): %s\\n\",\n\t\t\t\t\t\t\t  le16_to_cpu(resp->status),\n\t\t\t\t\t\t\t  ipw_get_status_code\n\t\t\t\t\t\t\t  (le16_to_cpu\n\t\t\t\t\t\t\t   (resp->status)));\n\t\t\t\t\t}\n\n\t\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t\t  IPW_DL_ASSOC,\n\t\t\t\t\t\t  \"disassociated: '%*pE' %pM\\n\",\n\t\t\t\t\t\t  priv->essid_len, priv->essid,\n\t\t\t\t\t\t  priv->bssid);\n\n\t\t\t\t\tpriv->status &=\n\t\t\t\t\t    ~(STATUS_DISASSOCIATING |\n\t\t\t\t\t      STATUS_ASSOCIATING |\n\t\t\t\t\t      STATUS_ASSOCIATED | STATUS_AUTH);\n\t\t\t\t\tif (priv->assoc_network\n\t\t\t\t\t    && (priv->assoc_network->\n\t\t\t\t\t\tcapability &\n\t\t\t\t\t\tWLAN_CAPABILITY_IBSS))\n\t\t\t\t\t\tipw_remove_current_network\n\t\t\t\t\t\t    (priv);\n\n\t\t\t\t\tschedule_work(&priv->link_down);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tcase CMAS_RX_ASSOC_RESP:\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tIPW_ERROR(\"assoc: unknown (%d)\\n\",\n\t\t\t\t\t  assoc->state);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\tcase HOST_NOTIFICATION_STATUS_AUTHENTICATE:{\n\t\t\tstruct notif_authenticate *auth = &notif->u.auth;\n\t\t\tswitch (auth->state) {\n\t\t\tcase CMAS_AUTHENTICATED:\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE,\n\t\t\t\t\t  \"authenticated: '%*pE' %pM\\n\",\n\t\t\t\t\t  priv->essid_len, priv->essid,\n\t\t\t\t\t  priv->bssid);\n\t\t\t\tpriv->status |= STATUS_AUTH;\n\t\t\t\tbreak;\n\n\t\t\tcase CMAS_INIT:\n\t\t\t\tif (priv->status & STATUS_AUTH) {\n\t\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t\t  IPW_DL_ASSOC,\n\t\t\t\t\t\t  \"authentication failed (0x%04X): %s\\n\",\n\t\t\t\t\t\t  le16_to_cpu(auth->status),\n\t\t\t\t\t\t  ipw_get_status_code(le16_to_cpu\n\t\t\t\t\t\t\t\t      (auth->\n\t\t\t\t\t\t\t\t       status)));\n\t\t\t\t}\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t  IPW_DL_ASSOC,\n\t\t\t\t\t  \"deauthenticated: '%*pE' %pM\\n\",\n\t\t\t\t\t  priv->essid_len, priv->essid,\n\t\t\t\t\t  priv->bssid);\n\n\t\t\t\tpriv->status &= ~(STATUS_ASSOCIATING |\n\t\t\t\t\t\t  STATUS_AUTH |\n\t\t\t\t\t\t  STATUS_ASSOCIATED);\n\n\t\t\t\tschedule_work(&priv->link_down);\n\t\t\t\tbreak;\n\n\t\t\tcase CMAS_TX_AUTH_SEQ_1:\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t  IPW_DL_ASSOC, \"AUTH_SEQ_1\\n\");\n\t\t\t\tbreak;\n\t\t\tcase CMAS_RX_AUTH_SEQ_2:\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t  IPW_DL_ASSOC, \"AUTH_SEQ_2\\n\");\n\t\t\t\tbreak;\n\t\t\tcase CMAS_AUTH_SEQ_1_PASS:\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t  IPW_DL_ASSOC, \"AUTH_SEQ_1_PASS\\n\");\n\t\t\t\tbreak;\n\t\t\tcase CMAS_AUTH_SEQ_1_FAIL:\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t  IPW_DL_ASSOC, \"AUTH_SEQ_1_FAIL\\n\");\n\t\t\t\tbreak;\n\t\t\tcase CMAS_TX_AUTH_SEQ_3:\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t  IPW_DL_ASSOC, \"AUTH_SEQ_3\\n\");\n\t\t\t\tbreak;\n\t\t\tcase CMAS_RX_AUTH_SEQ_4:\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t  IPW_DL_ASSOC, \"RX_AUTH_SEQ_4\\n\");\n\t\t\t\tbreak;\n\t\t\tcase CMAS_AUTH_SEQ_2_PASS:\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t  IPW_DL_ASSOC, \"AUTH_SEQ_2_PASS\\n\");\n\t\t\t\tbreak;\n\t\t\tcase CMAS_AUTH_SEQ_2_FAIL:\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t  IPW_DL_ASSOC, \"AUT_SEQ_2_FAIL\\n\");\n\t\t\t\tbreak;\n\t\t\tcase CMAS_TX_ASSOC:\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t  IPW_DL_ASSOC, \"TX_ASSOC\\n\");\n\t\t\t\tbreak;\n\t\t\tcase CMAS_RX_ASSOC_RESP:\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t  IPW_DL_ASSOC, \"RX_ASSOC_RESP\\n\");\n\n\t\t\t\tbreak;\n\t\t\tcase CMAS_ASSOCIATED:\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE |\n\t\t\t\t\t  IPW_DL_ASSOC, \"ASSOCIATED\\n\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tIPW_DEBUG_NOTIF(\"auth: failure - %d\\n\",\n\t\t\t\t\t\tauth->state);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\tcase HOST_NOTIFICATION_STATUS_SCAN_CHANNEL_RESULT:{\n\t\t\tstruct notif_channel_result *x =\n\t\t\t    &notif->u.channel_result;\n\n\t\t\tif (size == sizeof(*x)) {\n\t\t\t\tIPW_DEBUG_SCAN(\"Scan result for channel %d\\n\",\n\t\t\t\t\t       x->channel_num);\n\t\t\t} else {\n\t\t\t\tIPW_DEBUG_SCAN(\"Scan result of wrong size %d \"\n\t\t\t\t\t       \"(should be %zd)\\n\",\n\t\t\t\t\t       size, sizeof(*x));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\tcase HOST_NOTIFICATION_STATUS_SCAN_COMPLETED:{\n\t\t\tstruct notif_scan_complete *x = &notif->u.scan_complete;\n\t\t\tif (size == sizeof(*x)) {\n\t\t\t\tIPW_DEBUG_SCAN\n\t\t\t\t    (\"Scan completed: type %d, %d channels, \"\n\t\t\t\t     \"%d status\\n\", x->scan_type,\n\t\t\t\t     x->num_channels, x->status);\n\t\t\t} else {\n\t\t\t\tIPW_ERROR(\"Scan completed of wrong size %d \"\n\t\t\t\t\t  \"(should be %zd)\\n\",\n\t\t\t\t\t  size, sizeof(*x));\n\t\t\t}\n\n\t\t\tpriv->status &=\n\t\t\t    ~(STATUS_SCANNING | STATUS_SCAN_ABORTING);\n\n\t\t\twake_up_interruptible(&priv->wait_state);\n\t\t\tcancel_delayed_work(&priv->scan_check);\n\n\t\t\tif (priv->status & STATUS_EXIT_PENDING)\n\t\t\t\tbreak;\n\n\t\t\tpriv->ieee->scans++;\n\n#ifdef CONFIG_IPW2200_MONITOR\n\t\t\tif (priv->ieee->iw_mode == IW_MODE_MONITOR) {\n\t\t\t\tpriv->status |= STATUS_SCAN_FORCED;\n\t\t\t\tschedule_delayed_work(&priv->request_scan, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpriv->status &= ~STATUS_SCAN_FORCED;\n#endif\t\t\t\t \n\n\t\t\t \n\t\t\tif (priv->status & STATUS_DIRECT_SCAN_PENDING)\n\t\t\t\tschedule_delayed_work(&priv->request_direct_scan, 0);\n\n\t\t\tif (!(priv->status & (STATUS_ASSOCIATED |\n\t\t\t\t\t      STATUS_ASSOCIATING |\n\t\t\t\t\t      STATUS_ROAMING |\n\t\t\t\t\t      STATUS_DISASSOCIATING)))\n\t\t\t\tschedule_work(&priv->associate);\n\t\t\telse if (priv->status & STATUS_ROAMING) {\n\t\t\t\tif (x->status == SCAN_COMPLETED_STATUS_COMPLETE)\n\t\t\t\t\t \n\t\t\t\t\tschedule_work(&priv->roam);\n\t\t\t\telse\n\t\t\t\t\t \n\t\t\t\t\tpriv->status &= ~STATUS_ROAMING;\n\t\t\t} else if (priv->status & STATUS_SCAN_PENDING)\n\t\t\t\tschedule_delayed_work(&priv->request_scan, 0);\n\t\t\telse if (priv->config & CFG_BACKGROUND_SCAN\n\t\t\t\t && priv->status & STATUS_ASSOCIATED)\n\t\t\t\tschedule_delayed_work(&priv->request_scan,\n\t\t\t\t\t\t      round_jiffies_relative(HZ));\n\n\t\t\t \n\t\t\tif (x->status == SCAN_COMPLETED_STATUS_COMPLETE)\n\t\t\t\thandle_scan_event(priv);\n\t\t\tbreak;\n\t\t}\n\n\tcase HOST_NOTIFICATION_STATUS_FRAG_LENGTH:{\n\t\t\tstruct notif_frag_length *x = &notif->u.frag_len;\n\n\t\t\tif (size == sizeof(*x))\n\t\t\t\tIPW_ERROR(\"Frag length: %d\\n\",\n\t\t\t\t\t  le16_to_cpu(x->frag_length));\n\t\t\telse\n\t\t\t\tIPW_ERROR(\"Frag length of wrong size %d \"\n\t\t\t\t\t  \"(should be %zd)\\n\",\n\t\t\t\t\t  size, sizeof(*x));\n\t\t\tbreak;\n\t\t}\n\n\tcase HOST_NOTIFICATION_STATUS_LINK_DETERIORATION:{\n\t\t\tstruct notif_link_deterioration *x =\n\t\t\t    &notif->u.link_deterioration;\n\n\t\t\tif (size == sizeof(*x)) {\n\t\t\t\tIPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE,\n\t\t\t\t\t\"link deterioration: type %d, cnt %d\\n\",\n\t\t\t\t\tx->silence_notification_type,\n\t\t\t\t\tx->silence_count);\n\t\t\t\tmemcpy(&priv->last_link_deterioration, x,\n\t\t\t\t       sizeof(*x));\n\t\t\t} else {\n\t\t\t\tIPW_ERROR(\"Link Deterioration of wrong size %d \"\n\t\t\t\t\t  \"(should be %zd)\\n\",\n\t\t\t\t\t  size, sizeof(*x));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\tcase HOST_NOTIFICATION_DINO_CONFIG_RESPONSE:{\n\t\t\tIPW_ERROR(\"Dino config\\n\");\n\t\t\tif (priv->hcmd\n\t\t\t    && priv->hcmd->cmd != HOST_CMD_DINO_CONFIG)\n\t\t\t\tIPW_ERROR(\"Unexpected DINO_CONFIG_RESPONSE\\n\");\n\n\t\t\tbreak;\n\t\t}\n\n\tcase HOST_NOTIFICATION_STATUS_BEACON_STATE:{\n\t\t\tstruct notif_beacon_state *x = &notif->u.beacon_state;\n\t\t\tif (size != sizeof(*x)) {\n\t\t\t\tIPW_ERROR\n\t\t\t\t    (\"Beacon state of wrong size %d (should \"\n\t\t\t\t     \"be %zd)\\n\", size, sizeof(*x));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (le32_to_cpu(x->state) ==\n\t\t\t    HOST_NOTIFICATION_STATUS_BEACON_MISSING)\n\t\t\t\tipw_handle_missed_beacon(priv,\n\t\t\t\t\t\t\t le32_to_cpu(x->\n\t\t\t\t\t\t\t\t     number));\n\n\t\t\tbreak;\n\t\t}\n\n\tcase HOST_NOTIFICATION_STATUS_TGI_TX_KEY:{\n\t\t\tstruct notif_tgi_tx_key *x = &notif->u.tgi_tx_key;\n\t\t\tif (size == sizeof(*x)) {\n\t\t\t\tIPW_ERROR(\"TGi Tx Key: state 0x%02x sec type \"\n\t\t\t\t\t  \"0x%02x station %d\\n\",\n\t\t\t\t\t  x->key_state, x->security_type,\n\t\t\t\t\t  x->station_index);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tIPW_ERROR\n\t\t\t    (\"TGi Tx Key of wrong size %d (should be %zd)\\n\",\n\t\t\t     size, sizeof(*x));\n\t\t\tbreak;\n\t\t}\n\n\tcase HOST_NOTIFICATION_CALIB_KEEP_RESULTS:{\n\t\t\tstruct notif_calibration *x = &notif->u.calibration;\n\n\t\t\tif (size == sizeof(*x)) {\n\t\t\t\tmemcpy(&priv->calib, x, sizeof(*x));\n\t\t\t\tIPW_DEBUG_INFO(\"TODO: Calibration\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tIPW_ERROR\n\t\t\t    (\"Calibration of wrong size %d (should be %zd)\\n\",\n\t\t\t     size, sizeof(*x));\n\t\t\tbreak;\n\t\t}\n\n\tcase HOST_NOTIFICATION_NOISE_STATS:{\n\t\t\tif (size == sizeof(u32)) {\n\t\t\t\tpriv->exp_avg_noise =\n\t\t\t\t    exponential_average(priv->exp_avg_noise,\n\t\t\t\t    (u8) (le32_to_cpu(notif->u.noise.value) & 0xff),\n\t\t\t\t    DEPTH_NOISE);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tIPW_ERROR\n\t\t\t    (\"Noise stat is wrong size %d (should be %zd)\\n\",\n\t\t\t     size, sizeof(u32));\n\t\t\tbreak;\n\t\t}\n\n\tdefault:\n\t\tIPW_DEBUG_NOTIF(\"Unknown notification: \"\n\t\t\t\t\"subtype=%d,flags=0x%2x,size=%d\\n\",\n\t\t\t\tnotif->subtype, notif->flags, size);\n\t}\n}\n\n \nstatic int ipw_queue_reset(struct ipw_priv *priv)\n{\n\tint rc = 0;\n\t \n\tint nTx = 64, nTxCmd = 8;\n\tipw_tx_queue_free(priv);\n\t \n\trc = ipw_queue_tx_init(priv, &priv->txq_cmd, nTxCmd,\n\t\t\t       IPW_TX_CMD_QUEUE_READ_INDEX,\n\t\t\t       IPW_TX_CMD_QUEUE_WRITE_INDEX,\n\t\t\t       IPW_TX_CMD_QUEUE_BD_BASE,\n\t\t\t       IPW_TX_CMD_QUEUE_BD_SIZE);\n\tif (rc) {\n\t\tIPW_ERROR(\"Tx Cmd queue init failed\\n\");\n\t\tgoto error;\n\t}\n\t \n\trc = ipw_queue_tx_init(priv, &priv->txq[0], nTx,\n\t\t\t       IPW_TX_QUEUE_0_READ_INDEX,\n\t\t\t       IPW_TX_QUEUE_0_WRITE_INDEX,\n\t\t\t       IPW_TX_QUEUE_0_BD_BASE, IPW_TX_QUEUE_0_BD_SIZE);\n\tif (rc) {\n\t\tIPW_ERROR(\"Tx 0 queue init failed\\n\");\n\t\tgoto error;\n\t}\n\trc = ipw_queue_tx_init(priv, &priv->txq[1], nTx,\n\t\t\t       IPW_TX_QUEUE_1_READ_INDEX,\n\t\t\t       IPW_TX_QUEUE_1_WRITE_INDEX,\n\t\t\t       IPW_TX_QUEUE_1_BD_BASE, IPW_TX_QUEUE_1_BD_SIZE);\n\tif (rc) {\n\t\tIPW_ERROR(\"Tx 1 queue init failed\\n\");\n\t\tgoto error;\n\t}\n\trc = ipw_queue_tx_init(priv, &priv->txq[2], nTx,\n\t\t\t       IPW_TX_QUEUE_2_READ_INDEX,\n\t\t\t       IPW_TX_QUEUE_2_WRITE_INDEX,\n\t\t\t       IPW_TX_QUEUE_2_BD_BASE, IPW_TX_QUEUE_2_BD_SIZE);\n\tif (rc) {\n\t\tIPW_ERROR(\"Tx 2 queue init failed\\n\");\n\t\tgoto error;\n\t}\n\trc = ipw_queue_tx_init(priv, &priv->txq[3], nTx,\n\t\t\t       IPW_TX_QUEUE_3_READ_INDEX,\n\t\t\t       IPW_TX_QUEUE_3_WRITE_INDEX,\n\t\t\t       IPW_TX_QUEUE_3_BD_BASE, IPW_TX_QUEUE_3_BD_SIZE);\n\tif (rc) {\n\t\tIPW_ERROR(\"Tx 3 queue init failed\\n\");\n\t\tgoto error;\n\t}\n\t \n\tpriv->rx_bufs_min = 0;\n\tpriv->rx_pend_max = 0;\n\treturn rc;\n\n      error:\n\tipw_tx_queue_free(priv);\n\treturn rc;\n}\n\n \nstatic int ipw_queue_tx_reclaim(struct ipw_priv *priv,\n\t\t\t\tstruct clx2_tx_queue *txq, int qindex)\n{\n\tu32 hw_tail;\n\tint used;\n\tstruct clx2_queue *q = &txq->q;\n\n\thw_tail = ipw_read32(priv, q->reg_r);\n\tif (hw_tail >= q->n_bd) {\n\t\tIPW_ERROR\n\t\t    (\"Read index for DMA queue (%d) is out of range [0-%d)\\n\",\n\t\t     hw_tail, q->n_bd);\n\t\tgoto done;\n\t}\n\tfor (; q->last_used != hw_tail;\n\t     q->last_used = ipw_queue_inc_wrap(q->last_used, q->n_bd)) {\n\t\tipw_queue_tx_free_tfd(priv, txq);\n\t\tpriv->tx_packets++;\n\t}\n      done:\n\tif ((ipw_tx_queue_space(q) > q->low_mark) &&\n\t    (qindex >= 0))\n\t\tnetif_wake_queue(priv->net_dev);\n\tused = q->first_empty - q->last_used;\n\tif (used < 0)\n\t\tused += q->n_bd;\n\n\treturn used;\n}\n\nstatic int ipw_queue_tx_hcmd(struct ipw_priv *priv, int hcmd, const void *buf,\n\t\t\t     int len, int sync)\n{\n\tstruct clx2_tx_queue *txq = &priv->txq_cmd;\n\tstruct clx2_queue *q = &txq->q;\n\tstruct tfd_frame *tfd;\n\n\tif (ipw_tx_queue_space(q) < (sync ? 1 : 2)) {\n\t\tIPW_ERROR(\"No space for Tx\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\ttfd = &txq->bd[q->first_empty];\n\ttxq->txb[q->first_empty] = NULL;\n\n\tmemset(tfd, 0, sizeof(*tfd));\n\ttfd->control_flags.message_type = TX_HOST_COMMAND_TYPE;\n\ttfd->control_flags.control_bits = TFD_NEED_IRQ_MASK;\n\tpriv->hcmd_seq++;\n\ttfd->u.cmd.index = hcmd;\n\ttfd->u.cmd.length = len;\n\tmemcpy(tfd->u.cmd.payload, buf, len);\n\tq->first_empty = ipw_queue_inc_wrap(q->first_empty, q->n_bd);\n\tipw_write32(priv, q->reg_w, q->first_empty);\n\t_ipw_read32(priv, 0x90);\n\n\treturn 0;\n}\n\n \n\n \nstatic void ipw_rx_queue_restock(struct ipw_priv *priv)\n{\n\tstruct ipw_rx_queue *rxq = priv->rxq;\n\tstruct list_head *element;\n\tstruct ipw_rx_mem_buffer *rxb;\n\tunsigned long flags;\n\tint write;\n\n\tspin_lock_irqsave(&rxq->lock, flags);\n\twrite = rxq->write;\n\twhile ((ipw_rx_queue_space(rxq) > 0) && (rxq->free_count)) {\n\t\telement = rxq->rx_free.next;\n\t\trxb = list_entry(element, struct ipw_rx_mem_buffer, list);\n\t\tlist_del(element);\n\n\t\tipw_write32(priv, IPW_RFDS_TABLE_LOWER + rxq->write * RFD_SIZE,\n\t\t\t    rxb->dma_addr);\n\t\trxq->queue[rxq->write] = rxb;\n\t\trxq->write = (rxq->write + 1) % RX_QUEUE_SIZE;\n\t\trxq->free_count--;\n\t}\n\tspin_unlock_irqrestore(&rxq->lock, flags);\n\n\t \n\tif (rxq->free_count <= RX_LOW_WATERMARK)\n\t\tschedule_work(&priv->rx_replenish);\n\n\t \n\tif (write != rxq->write)\n\t\tipw_write32(priv, IPW_RX_WRITE_INDEX, rxq->write);\n}\n\n \nstatic void ipw_rx_queue_replenish(void *data)\n{\n\tstruct ipw_priv *priv = data;\n\tstruct ipw_rx_queue *rxq = priv->rxq;\n\tstruct list_head *element;\n\tstruct ipw_rx_mem_buffer *rxb;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rxq->lock, flags);\n\twhile (!list_empty(&rxq->rx_used)) {\n\t\telement = rxq->rx_used.next;\n\t\trxb = list_entry(element, struct ipw_rx_mem_buffer, list);\n\t\trxb->skb = alloc_skb(IPW_RX_BUF_SIZE, GFP_ATOMIC);\n\t\tif (!rxb->skb) {\n\t\t\tprintk(KERN_CRIT \"%s: Can not allocate SKB buffers.\\n\",\n\t\t\t       priv->net_dev->name);\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tlist_del(element);\n\n\t\trxb->dma_addr =\n\t\t    dma_map_single(&priv->pci_dev->dev, rxb->skb->data,\n\t\t\t\t   IPW_RX_BUF_SIZE, DMA_FROM_DEVICE);\n\n\t\tlist_add_tail(&rxb->list, &rxq->rx_free);\n\t\trxq->free_count++;\n\t}\n\tspin_unlock_irqrestore(&rxq->lock, flags);\n\n\tipw_rx_queue_restock(priv);\n}\n\nstatic void ipw_bg_rx_queue_replenish(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, rx_replenish);\n\tmutex_lock(&priv->mutex);\n\tipw_rx_queue_replenish(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\n \nstatic void ipw_rx_queue_free(struct ipw_priv *priv, struct ipw_rx_queue *rxq)\n{\n\tint i;\n\n\tif (!rxq)\n\t\treturn;\n\n\tfor (i = 0; i < RX_QUEUE_SIZE + RX_FREE_BUFFERS; i++) {\n\t\tif (rxq->pool[i].skb != NULL) {\n\t\t\tdma_unmap_single(&priv->pci_dev->dev,\n\t\t\t\t\t rxq->pool[i].dma_addr,\n\t\t\t\t\t IPW_RX_BUF_SIZE, DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb(rxq->pool[i].skb);\n\t\t}\n\t}\n\n\tkfree(rxq);\n}\n\nstatic struct ipw_rx_queue *ipw_rx_queue_alloc(struct ipw_priv *priv)\n{\n\tstruct ipw_rx_queue *rxq;\n\tint i;\n\n\trxq = kzalloc(sizeof(*rxq), GFP_KERNEL);\n\tif (unlikely(!rxq)) {\n\t\tIPW_ERROR(\"memory allocation failed\\n\");\n\t\treturn NULL;\n\t}\n\tspin_lock_init(&rxq->lock);\n\tINIT_LIST_HEAD(&rxq->rx_free);\n\tINIT_LIST_HEAD(&rxq->rx_used);\n\n\t \n\tfor (i = 0; i < RX_FREE_BUFFERS + RX_QUEUE_SIZE; i++)\n\t\tlist_add_tail(&rxq->pool[i].list, &rxq->rx_used);\n\n\t \n\trxq->read = rxq->write = 0;\n\trxq->free_count = 0;\n\n\treturn rxq;\n}\n\nstatic int ipw_is_rate_in_mask(struct ipw_priv *priv, int ieee_mode, u8 rate)\n{\n\trate &= ~LIBIPW_BASIC_RATE_MASK;\n\tif (ieee_mode == IEEE_A) {\n\t\tswitch (rate) {\n\t\tcase LIBIPW_OFDM_RATE_6MB:\n\t\t\treturn priv->rates_mask & LIBIPW_OFDM_RATE_6MB_MASK ?\n\t\t\t    1 : 0;\n\t\tcase LIBIPW_OFDM_RATE_9MB:\n\t\t\treturn priv->rates_mask & LIBIPW_OFDM_RATE_9MB_MASK ?\n\t\t\t    1 : 0;\n\t\tcase LIBIPW_OFDM_RATE_12MB:\n\t\t\treturn priv->\n\t\t\t    rates_mask & LIBIPW_OFDM_RATE_12MB_MASK ? 1 : 0;\n\t\tcase LIBIPW_OFDM_RATE_18MB:\n\t\t\treturn priv->\n\t\t\t    rates_mask & LIBIPW_OFDM_RATE_18MB_MASK ? 1 : 0;\n\t\tcase LIBIPW_OFDM_RATE_24MB:\n\t\t\treturn priv->\n\t\t\t    rates_mask & LIBIPW_OFDM_RATE_24MB_MASK ? 1 : 0;\n\t\tcase LIBIPW_OFDM_RATE_36MB:\n\t\t\treturn priv->\n\t\t\t    rates_mask & LIBIPW_OFDM_RATE_36MB_MASK ? 1 : 0;\n\t\tcase LIBIPW_OFDM_RATE_48MB:\n\t\t\treturn priv->\n\t\t\t    rates_mask & LIBIPW_OFDM_RATE_48MB_MASK ? 1 : 0;\n\t\tcase LIBIPW_OFDM_RATE_54MB:\n\t\t\treturn priv->\n\t\t\t    rates_mask & LIBIPW_OFDM_RATE_54MB_MASK ? 1 : 0;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tswitch (rate) {\n\tcase LIBIPW_CCK_RATE_1MB:\n\t\treturn priv->rates_mask & LIBIPW_CCK_RATE_1MB_MASK ? 1 : 0;\n\tcase LIBIPW_CCK_RATE_2MB:\n\t\treturn priv->rates_mask & LIBIPW_CCK_RATE_2MB_MASK ? 1 : 0;\n\tcase LIBIPW_CCK_RATE_5MB:\n\t\treturn priv->rates_mask & LIBIPW_CCK_RATE_5MB_MASK ? 1 : 0;\n\tcase LIBIPW_CCK_RATE_11MB:\n\t\treturn priv->rates_mask & LIBIPW_CCK_RATE_11MB_MASK ? 1 : 0;\n\t}\n\n\t \n\tif (ieee_mode == IEEE_B)\n\t\treturn 0;\n\n\t \n\tswitch (rate) {\n\tcase LIBIPW_OFDM_RATE_6MB:\n\t\treturn priv->rates_mask & LIBIPW_OFDM_RATE_6MB_MASK ? 1 : 0;\n\tcase LIBIPW_OFDM_RATE_9MB:\n\t\treturn priv->rates_mask & LIBIPW_OFDM_RATE_9MB_MASK ? 1 : 0;\n\tcase LIBIPW_OFDM_RATE_12MB:\n\t\treturn priv->rates_mask & LIBIPW_OFDM_RATE_12MB_MASK ? 1 : 0;\n\tcase LIBIPW_OFDM_RATE_18MB:\n\t\treturn priv->rates_mask & LIBIPW_OFDM_RATE_18MB_MASK ? 1 : 0;\n\tcase LIBIPW_OFDM_RATE_24MB:\n\t\treturn priv->rates_mask & LIBIPW_OFDM_RATE_24MB_MASK ? 1 : 0;\n\tcase LIBIPW_OFDM_RATE_36MB:\n\t\treturn priv->rates_mask & LIBIPW_OFDM_RATE_36MB_MASK ? 1 : 0;\n\tcase LIBIPW_OFDM_RATE_48MB:\n\t\treturn priv->rates_mask & LIBIPW_OFDM_RATE_48MB_MASK ? 1 : 0;\n\tcase LIBIPW_OFDM_RATE_54MB:\n\t\treturn priv->rates_mask & LIBIPW_OFDM_RATE_54MB_MASK ? 1 : 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int ipw_compatible_rates(struct ipw_priv *priv,\n\t\t\t\tconst struct libipw_network *network,\n\t\t\t\tstruct ipw_supported_rates *rates)\n{\n\tint num_rates, i;\n\n\tmemset(rates, 0, sizeof(*rates));\n\tnum_rates = min(network->rates_len, (u8) IPW_MAX_RATES);\n\trates->num_rates = 0;\n\tfor (i = 0; i < num_rates; i++) {\n\t\tif (!ipw_is_rate_in_mask(priv, network->mode,\n\t\t\t\t\t network->rates[i])) {\n\n\t\t\tif (network->rates[i] & LIBIPW_BASIC_RATE_MASK) {\n\t\t\t\tIPW_DEBUG_SCAN(\"Adding masked mandatory \"\n\t\t\t\t\t       \"rate %02X\\n\",\n\t\t\t\t\t       network->rates[i]);\n\t\t\t\trates->supported_rates[rates->num_rates++] =\n\t\t\t\t    network->rates[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tIPW_DEBUG_SCAN(\"Rate %02X masked : 0x%08X\\n\",\n\t\t\t\t       network->rates[i], priv->rates_mask);\n\t\t\tcontinue;\n\t\t}\n\n\t\trates->supported_rates[rates->num_rates++] = network->rates[i];\n\t}\n\n\tnum_rates = min(network->rates_ex_len,\n\t\t\t(u8) (IPW_MAX_RATES - num_rates));\n\tfor (i = 0; i < num_rates; i++) {\n\t\tif (!ipw_is_rate_in_mask(priv, network->mode,\n\t\t\t\t\t network->rates_ex[i])) {\n\t\t\tif (network->rates_ex[i] & LIBIPW_BASIC_RATE_MASK) {\n\t\t\t\tIPW_DEBUG_SCAN(\"Adding masked mandatory \"\n\t\t\t\t\t       \"rate %02X\\n\",\n\t\t\t\t\t       network->rates_ex[i]);\n\t\t\t\trates->supported_rates[rates->num_rates++] =\n\t\t\t\t    network->rates[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tIPW_DEBUG_SCAN(\"Rate %02X masked : 0x%08X\\n\",\n\t\t\t\t       network->rates_ex[i], priv->rates_mask);\n\t\t\tcontinue;\n\t\t}\n\n\t\trates->supported_rates[rates->num_rates++] =\n\t\t    network->rates_ex[i];\n\t}\n\n\treturn 1;\n}\n\nstatic void ipw_copy_rates(struct ipw_supported_rates *dest,\n\t\t\t\t  const struct ipw_supported_rates *src)\n{\n\tu8 i;\n\tfor (i = 0; i < src->num_rates; i++)\n\t\tdest->supported_rates[i] = src->supported_rates[i];\n\tdest->num_rates = src->num_rates;\n}\n\n \nstatic void ipw_add_cck_scan_rates(struct ipw_supported_rates *rates,\n\t\t\t\t   u8 modulation, u32 rate_mask)\n{\n\tu8 basic_mask = (LIBIPW_OFDM_MODULATION == modulation) ?\n\t    LIBIPW_BASIC_RATE_MASK : 0;\n\n\tif (rate_mask & LIBIPW_CCK_RATE_1MB_MASK)\n\t\trates->supported_rates[rates->num_rates++] =\n\t\t    LIBIPW_BASIC_RATE_MASK | LIBIPW_CCK_RATE_1MB;\n\n\tif (rate_mask & LIBIPW_CCK_RATE_2MB_MASK)\n\t\trates->supported_rates[rates->num_rates++] =\n\t\t    LIBIPW_BASIC_RATE_MASK | LIBIPW_CCK_RATE_2MB;\n\n\tif (rate_mask & LIBIPW_CCK_RATE_5MB_MASK)\n\t\trates->supported_rates[rates->num_rates++] = basic_mask |\n\t\t    LIBIPW_CCK_RATE_5MB;\n\n\tif (rate_mask & LIBIPW_CCK_RATE_11MB_MASK)\n\t\trates->supported_rates[rates->num_rates++] = basic_mask |\n\t\t    LIBIPW_CCK_RATE_11MB;\n}\n\nstatic void ipw_add_ofdm_scan_rates(struct ipw_supported_rates *rates,\n\t\t\t\t    u8 modulation, u32 rate_mask)\n{\n\tu8 basic_mask = (LIBIPW_OFDM_MODULATION == modulation) ?\n\t    LIBIPW_BASIC_RATE_MASK : 0;\n\n\tif (rate_mask & LIBIPW_OFDM_RATE_6MB_MASK)\n\t\trates->supported_rates[rates->num_rates++] = basic_mask |\n\t\t    LIBIPW_OFDM_RATE_6MB;\n\n\tif (rate_mask & LIBIPW_OFDM_RATE_9MB_MASK)\n\t\trates->supported_rates[rates->num_rates++] =\n\t\t    LIBIPW_OFDM_RATE_9MB;\n\n\tif (rate_mask & LIBIPW_OFDM_RATE_12MB_MASK)\n\t\trates->supported_rates[rates->num_rates++] = basic_mask |\n\t\t    LIBIPW_OFDM_RATE_12MB;\n\n\tif (rate_mask & LIBIPW_OFDM_RATE_18MB_MASK)\n\t\trates->supported_rates[rates->num_rates++] =\n\t\t    LIBIPW_OFDM_RATE_18MB;\n\n\tif (rate_mask & LIBIPW_OFDM_RATE_24MB_MASK)\n\t\trates->supported_rates[rates->num_rates++] = basic_mask |\n\t\t    LIBIPW_OFDM_RATE_24MB;\n\n\tif (rate_mask & LIBIPW_OFDM_RATE_36MB_MASK)\n\t\trates->supported_rates[rates->num_rates++] =\n\t\t    LIBIPW_OFDM_RATE_36MB;\n\n\tif (rate_mask & LIBIPW_OFDM_RATE_48MB_MASK)\n\t\trates->supported_rates[rates->num_rates++] =\n\t\t    LIBIPW_OFDM_RATE_48MB;\n\n\tif (rate_mask & LIBIPW_OFDM_RATE_54MB_MASK)\n\t\trates->supported_rates[rates->num_rates++] =\n\t\t    LIBIPW_OFDM_RATE_54MB;\n}\n\nstruct ipw_network_match {\n\tstruct libipw_network *network;\n\tstruct ipw_supported_rates rates;\n};\n\nstatic int ipw_find_adhoc_network(struct ipw_priv *priv,\n\t\t\t\t  struct ipw_network_match *match,\n\t\t\t\t  struct libipw_network *network,\n\t\t\t\t  int roaming)\n{\n\tstruct ipw_supported_rates rates;\n\n\t \n\tif ((priv->ieee->iw_mode == IW_MODE_ADHOC &&\n\t     !(network->capability & WLAN_CAPABILITY_IBSS))) {\n\t\tIPW_DEBUG_MERGE(\"Network '%*pE (%pM)' excluded due to capability mismatch.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid);\n\t\treturn 0;\n\t}\n\n\tif (unlikely(roaming)) {\n\t\t \n\t\tif ((network->ssid_len != match->network->ssid_len) ||\n\t\t    memcmp(network->ssid, match->network->ssid,\n\t\t\t   network->ssid_len)) {\n\t\t\tIPW_DEBUG_MERGE(\"Network '%*pE (%pM)' excluded because of non-network ESSID.\\n\",\n\t\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\t\tnetwork->bssid);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\t \n\t\tif ((priv->config & CFG_STATIC_ESSID) &&\n\t\t    ((network->ssid_len != priv->essid_len) ||\n\t\t     memcmp(network->ssid, priv->essid,\n\t\t\t    min(network->ssid_len, priv->essid_len)))) {\n\t\t\tIPW_DEBUG_MERGE(\"Network '%*pE (%pM)' excluded because of ESSID mismatch: '%*pE'.\\n\",\n\t\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\t\tnetwork->bssid, priv->essid_len,\n\t\t\t\t\tpriv->essid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\n\tif (network->time_stamp[0] < match->network->time_stamp[0]) {\n\t\tIPW_DEBUG_MERGE(\"Network '%*pE excluded because newer than current network.\\n\",\n\t\t\t\tmatch->network->ssid_len, match->network->ssid);\n\t\treturn 0;\n\t} else if (network->time_stamp[1] < match->network->time_stamp[1]) {\n\t\tIPW_DEBUG_MERGE(\"Network '%*pE excluded because newer than current network.\\n\",\n\t\t\t\tmatch->network->ssid_len, match->network->ssid);\n\t\treturn 0;\n\t}\n\n\t \n\tif (priv->ieee->scan_age != 0 &&\n\t    time_after(jiffies, network->last_scanned + priv->ieee->scan_age)) {\n\t\tIPW_DEBUG_MERGE(\"Network '%*pE (%pM)' excluded because of age: %ums.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid,\n\t\t\t\tjiffies_to_msecs(jiffies -\n\t\t\t\t\t\t network->last_scanned));\n\t\treturn 0;\n\t}\n\n\tif ((priv->config & CFG_STATIC_CHANNEL) &&\n\t    (network->channel != priv->channel)) {\n\t\tIPW_DEBUG_MERGE(\"Network '%*pE (%pM)' excluded because of channel mismatch: %d != %d.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid,\n\t\t\t\tnetwork->channel, priv->channel);\n\t\treturn 0;\n\t}\n\n\t \n\tif (((priv->capability & CAP_PRIVACY_ON) ? 1 : 0) !=\n\t    ((network->capability & WLAN_CAPABILITY_PRIVACY) ? 1 : 0)) {\n\t\tIPW_DEBUG_MERGE(\"Network '%*pE (%pM)' excluded because of privacy mismatch: %s != %s.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid,\n\t\t\t\tpriv->\n\t\t\t\tcapability & CAP_PRIVACY_ON ? \"on\" : \"off\",\n\t\t\t\tnetwork->\n\t\t\t\tcapability & WLAN_CAPABILITY_PRIVACY ? \"on\" :\n\t\t\t\t\"off\");\n\t\treturn 0;\n\t}\n\n\tif (ether_addr_equal(network->bssid, priv->bssid)) {\n\t\tIPW_DEBUG_MERGE(\"Network '%*pE (%pM)' excluded because of the same BSSID match: %pM.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid, priv->bssid);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!libipw_is_valid_mode(priv->ieee, network->mode)) {\n\t\tIPW_DEBUG_MERGE(\"Network '%*pE (%pM)' excluded because of invalid frequency/mode combination.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!ipw_compatible_rates(priv, network, &rates)) {\n\t\tIPW_DEBUG_MERGE(\"Network '%*pE (%pM)' excluded because configured rate mask excludes AP mandatory rate.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid);\n\t\treturn 0;\n\t}\n\n\tif (rates.num_rates == 0) {\n\t\tIPW_DEBUG_MERGE(\"Network '%*pE (%pM)' excluded because of no compatible rates.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid);\n\t\treturn 0;\n\t}\n\n\t \n\n\t \n\tipw_copy_rates(&match->rates, &rates);\n\tmatch->network = network;\n\tIPW_DEBUG_MERGE(\"Network '%*pE (%pM)' is a viable match.\\n\",\n\t\t\tnetwork->ssid_len, network->ssid, network->bssid);\n\n\treturn 1;\n}\n\nstatic void ipw_merge_adhoc_network(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, merge_networks);\n\tstruct libipw_network *network = NULL;\n\tstruct ipw_network_match match = {\n\t\t.network = priv->assoc_network\n\t};\n\n\tif ((priv->status & STATUS_ASSOCIATED) &&\n\t    (priv->ieee->iw_mode == IW_MODE_ADHOC)) {\n\t\t \n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&priv->ieee->lock, flags);\n\t\tlist_for_each_entry(network, &priv->ieee->network_list, list) {\n\t\t\tif (network != priv->assoc_network)\n\t\t\t\tipw_find_adhoc_network(priv, &match, network,\n\t\t\t\t\t\t       1);\n\t\t}\n\t\tspin_unlock_irqrestore(&priv->ieee->lock, flags);\n\n\t\tif (match.network == priv->assoc_network) {\n\t\t\tIPW_DEBUG_MERGE(\"No better ADHOC in this network to \"\n\t\t\t\t\t\"merge to.\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tmutex_lock(&priv->mutex);\n\t\tif (priv->ieee->iw_mode == IW_MODE_ADHOC) {\n\t\t\tIPW_DEBUG_MERGE(\"remove network %*pE\\n\",\n\t\t\t\t\tpriv->essid_len, priv->essid);\n\t\t\tipw_remove_current_network(priv);\n\t\t}\n\n\t\tipw_disassociate(priv);\n\t\tpriv->assoc_network = match.network;\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn;\n\t}\n}\n\nstatic int ipw_best_network(struct ipw_priv *priv,\n\t\t\t    struct ipw_network_match *match,\n\t\t\t    struct libipw_network *network, int roaming)\n{\n\tstruct ipw_supported_rates rates;\n\n\t \n\tif ((priv->ieee->iw_mode == IW_MODE_INFRA &&\n\t     !(network->capability & WLAN_CAPABILITY_ESS)) ||\n\t    (priv->ieee->iw_mode == IW_MODE_ADHOC &&\n\t     !(network->capability & WLAN_CAPABILITY_IBSS))) {\n\t\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' excluded due to capability mismatch.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid);\n\t\treturn 0;\n\t}\n\n\tif (unlikely(roaming)) {\n\t\t \n\t\tif ((network->ssid_len != match->network->ssid_len) ||\n\t\t    memcmp(network->ssid, match->network->ssid,\n\t\t\t   network->ssid_len)) {\n\t\t\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' excluded because of non-network ESSID.\\n\",\n\t\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\t\tnetwork->bssid);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\t \n\t\tif ((priv->config & CFG_STATIC_ESSID) &&\n\t\t    ((network->ssid_len != priv->essid_len) ||\n\t\t     memcmp(network->ssid, priv->essid,\n\t\t\t    min(network->ssid_len, priv->essid_len)))) {\n\t\t\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' excluded because of ESSID mismatch: '%*pE'.\\n\",\n\t\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\t\tnetwork->bssid, priv->essid_len,\n\t\t\t\t\tpriv->essid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tif (match->network && match->network->stats.rssi > network->stats.rssi) {\n\t\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' excluded because '%*pE (%pM)' has a stronger signal.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid, match->network->ssid_len,\n\t\t\t\tmatch->network->ssid, match->network->bssid);\n\t\treturn 0;\n\t}\n\n\t \n\tif (network->last_associate &&\n\t    time_after(network->last_associate + (HZ * 3UL), jiffies)) {\n\t\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' excluded because of storming (%ums since last assoc attempt).\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid,\n\t\t\t\tjiffies_to_msecs(jiffies -\n\t\t\t\t\t\t network->last_associate));\n\t\treturn 0;\n\t}\n\n\t \n\tif (priv->ieee->scan_age != 0 &&\n\t    time_after(jiffies, network->last_scanned + priv->ieee->scan_age)) {\n\t\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' excluded because of age: %ums.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid,\n\t\t\t\tjiffies_to_msecs(jiffies -\n\t\t\t\t\t\t network->last_scanned));\n\t\treturn 0;\n\t}\n\n\tif ((priv->config & CFG_STATIC_CHANNEL) &&\n\t    (network->channel != priv->channel)) {\n\t\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' excluded because of channel mismatch: %d != %d.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid,\n\t\t\t\tnetwork->channel, priv->channel);\n\t\treturn 0;\n\t}\n\n\t \n\tif (((priv->capability & CAP_PRIVACY_ON) ? 1 : 0) !=\n\t    ((network->capability & WLAN_CAPABILITY_PRIVACY) ? 1 : 0)) {\n\t\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' excluded because of privacy mismatch: %s != %s.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid,\n\t\t\t\tpriv->capability & CAP_PRIVACY_ON ? \"on\" :\n\t\t\t\t\"off\",\n\t\t\t\tnetwork->capability &\n\t\t\t\tWLAN_CAPABILITY_PRIVACY ? \"on\" : \"off\");\n\t\treturn 0;\n\t}\n\n\tif ((priv->config & CFG_STATIC_BSSID) &&\n\t    !ether_addr_equal(network->bssid, priv->bssid)) {\n\t\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' excluded because of BSSID mismatch: %pM.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid, priv->bssid);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!libipw_is_valid_mode(priv->ieee, network->mode)) {\n\t\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' excluded because of invalid frequency/mode combination.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!libipw_is_valid_channel(priv->ieee, network->channel)) {\n\t\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' excluded because of invalid channel in current GEO\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!ipw_compatible_rates(priv, network, &rates)) {\n\t\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' excluded because configured rate mask excludes AP mandatory rate.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid);\n\t\treturn 0;\n\t}\n\n\tif (rates.num_rates == 0) {\n\t\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' excluded because of no compatible rates.\\n\",\n\t\t\t\tnetwork->ssid_len, network->ssid,\n\t\t\t\tnetwork->bssid);\n\t\treturn 0;\n\t}\n\n\t \n\n\t \n\tipw_copy_rates(&match->rates, &rates);\n\tmatch->network = network;\n\n\tIPW_DEBUG_ASSOC(\"Network '%*pE (%pM)' is a viable match.\\n\",\n\t\t\tnetwork->ssid_len, network->ssid, network->bssid);\n\n\treturn 1;\n}\n\nstatic void ipw_adhoc_create(struct ipw_priv *priv,\n\t\t\t     struct libipw_network *network)\n{\n\tconst struct libipw_geo *geo = libipw_get_geo(priv->ieee);\n\tint i;\n\n\t \n\tswitch (libipw_is_valid_channel(priv->ieee, priv->channel)) {\n\tcase LIBIPW_52GHZ_BAND:\n\t\tnetwork->mode = IEEE_A;\n\t\ti = libipw_channel_to_index(priv->ieee, priv->channel);\n\t\tBUG_ON(i == -1);\n\t\tif (geo->a[i].flags & LIBIPW_CH_PASSIVE_ONLY) {\n\t\t\tIPW_WARNING(\"Overriding invalid channel\\n\");\n\t\t\tpriv->channel = geo->a[0].channel;\n\t\t}\n\t\tbreak;\n\n\tcase LIBIPW_24GHZ_BAND:\n\t\tif (priv->ieee->mode & IEEE_G)\n\t\t\tnetwork->mode = IEEE_G;\n\t\telse\n\t\t\tnetwork->mode = IEEE_B;\n\t\ti = libipw_channel_to_index(priv->ieee, priv->channel);\n\t\tBUG_ON(i == -1);\n\t\tif (geo->bg[i].flags & LIBIPW_CH_PASSIVE_ONLY) {\n\t\t\tIPW_WARNING(\"Overriding invalid channel\\n\");\n\t\t\tpriv->channel = geo->bg[0].channel;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tIPW_WARNING(\"Overriding invalid channel\\n\");\n\t\tif (priv->ieee->mode & IEEE_A) {\n\t\t\tnetwork->mode = IEEE_A;\n\t\t\tpriv->channel = geo->a[0].channel;\n\t\t} else if (priv->ieee->mode & IEEE_G) {\n\t\t\tnetwork->mode = IEEE_G;\n\t\t\tpriv->channel = geo->bg[0].channel;\n\t\t} else {\n\t\t\tnetwork->mode = IEEE_B;\n\t\t\tpriv->channel = geo->bg[0].channel;\n\t\t}\n\t\tbreak;\n\t}\n\n\tnetwork->channel = priv->channel;\n\tpriv->config |= CFG_ADHOC_PERSIST;\n\tipw_create_bssid(priv, network->bssid);\n\tnetwork->ssid_len = priv->essid_len;\n\tmemcpy(network->ssid, priv->essid, priv->essid_len);\n\tmemset(&network->stats, 0, sizeof(network->stats));\n\tnetwork->capability = WLAN_CAPABILITY_IBSS;\n\tif (!(priv->config & CFG_PREAMBLE_LONG))\n\t\tnetwork->capability |= WLAN_CAPABILITY_SHORT_PREAMBLE;\n\tif (priv->capability & CAP_PRIVACY_ON)\n\t\tnetwork->capability |= WLAN_CAPABILITY_PRIVACY;\n\tnetwork->rates_len = min(priv->rates.num_rates, MAX_RATES_LENGTH);\n\tmemcpy(network->rates, priv->rates.supported_rates, network->rates_len);\n\tnetwork->rates_ex_len = priv->rates.num_rates - network->rates_len;\n\tmemcpy(network->rates_ex,\n\t       &priv->rates.supported_rates[network->rates_len],\n\t       network->rates_ex_len);\n\tnetwork->last_scanned = 0;\n\tnetwork->flags = 0;\n\tnetwork->last_associate = 0;\n\tnetwork->time_stamp[0] = 0;\n\tnetwork->time_stamp[1] = 0;\n\tnetwork->beacon_interval = 100;\t \n\tnetwork->listen_interval = 10;\t \n\tnetwork->atim_window = 0;\t \n\tnetwork->wpa_ie_len = 0;\n\tnetwork->rsn_ie_len = 0;\n}\n\nstatic void ipw_send_tgi_tx_key(struct ipw_priv *priv, int type, int index)\n{\n\tstruct ipw_tgi_tx_key key;\n\n\tif (!(priv->ieee->sec.flags & (1 << index)))\n\t\treturn;\n\n\tkey.key_id = index;\n\tmemcpy(key.key, priv->ieee->sec.keys[index], SCM_TEMPORAL_KEY_LENGTH);\n\tkey.security_type = type;\n\tkey.station_index = 0;\t \n\tkey.flags = 0;\n\t \n\tkey.tx_counter[0] = cpu_to_le32(0);\n\tkey.tx_counter[1] = cpu_to_le32(0);\n\n\tipw_send_cmd_pdu(priv, IPW_CMD_TGI_TX_KEY, sizeof(key), &key);\n}\n\nstatic void ipw_send_wep_keys(struct ipw_priv *priv, int type)\n{\n\tstruct ipw_wep_key key;\n\tint i;\n\n\tkey.cmd_id = DINO_CMD_WEP_KEY;\n\tkey.seq_num = 0;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tkey.key_index = i | type;\n\t\tif (!(priv->ieee->sec.flags & (1 << i))) {\n\t\t\tkey.key_size = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkey.key_size = priv->ieee->sec.key_sizes[i];\n\t\tmemcpy(key.key, priv->ieee->sec.keys[i], key.key_size);\n\n\t\tipw_send_cmd_pdu(priv, IPW_CMD_WEP_KEY, sizeof(key), &key);\n\t}\n}\n\nstatic void ipw_set_hw_decrypt_unicast(struct ipw_priv *priv, int level)\n{\n\tif (priv->ieee->host_encrypt)\n\t\treturn;\n\n\tswitch (level) {\n\tcase SEC_LEVEL_3:\n\t\tpriv->sys_config.disable_unicast_decryption = 0;\n\t\tpriv->ieee->host_decrypt = 0;\n\t\tbreak;\n\tcase SEC_LEVEL_2:\n\t\tpriv->sys_config.disable_unicast_decryption = 1;\n\t\tpriv->ieee->host_decrypt = 1;\n\t\tbreak;\n\tcase SEC_LEVEL_1:\n\t\tpriv->sys_config.disable_unicast_decryption = 0;\n\t\tpriv->ieee->host_decrypt = 0;\n\t\tbreak;\n\tcase SEC_LEVEL_0:\n\t\tpriv->sys_config.disable_unicast_decryption = 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ipw_set_hw_decrypt_multicast(struct ipw_priv *priv, int level)\n{\n\tif (priv->ieee->host_encrypt)\n\t\treturn;\n\n\tswitch (level) {\n\tcase SEC_LEVEL_3:\n\t\tpriv->sys_config.disable_multicast_decryption = 0;\n\t\tbreak;\n\tcase SEC_LEVEL_2:\n\t\tpriv->sys_config.disable_multicast_decryption = 1;\n\t\tbreak;\n\tcase SEC_LEVEL_1:\n\t\tpriv->sys_config.disable_multicast_decryption = 0;\n\t\tbreak;\n\tcase SEC_LEVEL_0:\n\t\tpriv->sys_config.disable_multicast_decryption = 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ipw_set_hwcrypto_keys(struct ipw_priv *priv)\n{\n\tswitch (priv->ieee->sec.level) {\n\tcase SEC_LEVEL_3:\n\t\tif (priv->ieee->sec.flags & SEC_ACTIVE_KEY)\n\t\t\tipw_send_tgi_tx_key(priv,\n\t\t\t\t\t    DCT_FLAG_EXT_SECURITY_CCM,\n\t\t\t\t\t    priv->ieee->sec.active_key);\n\n\t\tif (!priv->ieee->host_mc_decrypt)\n\t\t\tipw_send_wep_keys(priv, DCW_WEP_KEY_SEC_TYPE_CCM);\n\t\tbreak;\n\tcase SEC_LEVEL_2:\n\t\tif (priv->ieee->sec.flags & SEC_ACTIVE_KEY)\n\t\t\tipw_send_tgi_tx_key(priv,\n\t\t\t\t\t    DCT_FLAG_EXT_SECURITY_TKIP,\n\t\t\t\t\t    priv->ieee->sec.active_key);\n\t\tbreak;\n\tcase SEC_LEVEL_1:\n\t\tipw_send_wep_keys(priv, DCW_WEP_KEY_SEC_TYPE_WEP);\n\t\tipw_set_hw_decrypt_unicast(priv, priv->ieee->sec.level);\n\t\tipw_set_hw_decrypt_multicast(priv, priv->ieee->sec.level);\n\t\tbreak;\n\tcase SEC_LEVEL_0:\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ipw_adhoc_check(void *data)\n{\n\tstruct ipw_priv *priv = data;\n\n\tif (priv->missed_adhoc_beacons++ > priv->disassociate_threshold &&\n\t    !(priv->config & CFG_ADHOC_PERSIST)) {\n\t\tIPW_DEBUG(IPW_DL_INFO | IPW_DL_NOTIF |\n\t\t\t  IPW_DL_STATE | IPW_DL_ASSOC,\n\t\t\t  \"Missed beacon: %d - disassociate\\n\",\n\t\t\t  priv->missed_adhoc_beacons);\n\t\tipw_remove_current_network(priv);\n\t\tipw_disassociate(priv);\n\t\treturn;\n\t}\n\n\tschedule_delayed_work(&priv->adhoc_check,\n\t\t\t      le16_to_cpu(priv->assoc_request.beacon_interval));\n}\n\nstatic void ipw_bg_adhoc_check(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, adhoc_check.work);\n\tmutex_lock(&priv->mutex);\n\tipw_adhoc_check(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void ipw_debug_config(struct ipw_priv *priv)\n{\n\tIPW_DEBUG_INFO(\"Scan completed, no valid APs matched \"\n\t\t       \"[CFG 0x%08X]\\n\", priv->config);\n\tif (priv->config & CFG_STATIC_CHANNEL)\n\t\tIPW_DEBUG_INFO(\"Channel locked to %d\\n\", priv->channel);\n\telse\n\t\tIPW_DEBUG_INFO(\"Channel unlocked.\\n\");\n\tif (priv->config & CFG_STATIC_ESSID)\n\t\tIPW_DEBUG_INFO(\"ESSID locked to '%*pE'\\n\",\n\t\t\t       priv->essid_len, priv->essid);\n\telse\n\t\tIPW_DEBUG_INFO(\"ESSID unlocked.\\n\");\n\tif (priv->config & CFG_STATIC_BSSID)\n\t\tIPW_DEBUG_INFO(\"BSSID locked to %pM\\n\", priv->bssid);\n\telse\n\t\tIPW_DEBUG_INFO(\"BSSID unlocked.\\n\");\n\tif (priv->capability & CAP_PRIVACY_ON)\n\t\tIPW_DEBUG_INFO(\"PRIVACY on\\n\");\n\telse\n\t\tIPW_DEBUG_INFO(\"PRIVACY off\\n\");\n\tIPW_DEBUG_INFO(\"RATE MASK: 0x%08X\\n\", priv->rates_mask);\n}\n\nstatic void ipw_set_fixed_rate(struct ipw_priv *priv, int mode)\n{\n\t \n\tstruct ipw_fixed_rate fr;\n\tu32 reg;\n\tu16 mask = 0;\n\tu16 new_tx_rates = priv->rates_mask;\n\n\t \n\n\tswitch (priv->ieee->freq_band) {\n\tcase LIBIPW_52GHZ_BAND:\t \n\t\t \n\t\tif (priv->rates_mask & ~LIBIPW_OFDM_RATES_MASK) {\n\t\t\t \n\t\t\tIPW_DEBUG_WX\n\t\t\t    (\"invalid fixed rate mask in ipw_set_fixed_rate\\n\");\n\t\t\tnew_tx_rates = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tnew_tx_rates >>= LIBIPW_OFDM_SHIFT_MASK_A;\n\t\tbreak;\n\n\tdefault:\t\t \n\t\t \n\t\tif (mode == IEEE_B) {\n\t\t\tif (new_tx_rates & ~LIBIPW_CCK_RATES_MASK) {\n\t\t\t\t \n\t\t\t\tIPW_DEBUG_WX\n\t\t\t\t    (\"invalid fixed rate mask in ipw_set_fixed_rate\\n\");\n\t\t\t\tnew_tx_rates = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (new_tx_rates & ~(LIBIPW_CCK_RATES_MASK |\n\t\t\t\t    LIBIPW_OFDM_RATES_MASK)) {\n\t\t\t \n\t\t\tIPW_DEBUG_WX\n\t\t\t    (\"invalid fixed rate mask in ipw_set_fixed_rate\\n\");\n\t\t\tnew_tx_rates = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (LIBIPW_OFDM_RATE_6MB_MASK & new_tx_rates) {\n\t\t\tmask |= (LIBIPW_OFDM_RATE_6MB_MASK >> 1);\n\t\t\tnew_tx_rates &= ~LIBIPW_OFDM_RATE_6MB_MASK;\n\t\t}\n\n\t\tif (LIBIPW_OFDM_RATE_9MB_MASK & new_tx_rates) {\n\t\t\tmask |= (LIBIPW_OFDM_RATE_9MB_MASK >> 1);\n\t\t\tnew_tx_rates &= ~LIBIPW_OFDM_RATE_9MB_MASK;\n\t\t}\n\n\t\tif (LIBIPW_OFDM_RATE_12MB_MASK & new_tx_rates) {\n\t\t\tmask |= (LIBIPW_OFDM_RATE_12MB_MASK >> 1);\n\t\t\tnew_tx_rates &= ~LIBIPW_OFDM_RATE_12MB_MASK;\n\t\t}\n\n\t\tnew_tx_rates |= mask;\n\t\tbreak;\n\t}\n\n\tfr.tx_rates = cpu_to_le16(new_tx_rates);\n\n\treg = ipw_read32(priv, IPW_MEM_FIXED_OVERRIDE);\n\tipw_write_reg32(priv, reg, *(u32 *) & fr);\n}\n\nstatic void ipw_abort_scan(struct ipw_priv *priv)\n{\n\tint err;\n\n\tif (priv->status & STATUS_SCAN_ABORTING) {\n\t\tIPW_DEBUG_HC(\"Ignoring concurrent scan abort request.\\n\");\n\t\treturn;\n\t}\n\tpriv->status |= STATUS_SCAN_ABORTING;\n\n\terr = ipw_send_scan_abort(priv);\n\tif (err)\n\t\tIPW_DEBUG_HC(\"Request to abort scan failed.\\n\");\n}\n\nstatic void ipw_add_scan_channels(struct ipw_priv *priv,\n\t\t\t\t  struct ipw_scan_request_ext *scan,\n\t\t\t\t  int scan_type)\n{\n\tint channel_index = 0;\n\tconst struct libipw_geo *geo;\n\tint i;\n\n\tgeo = libipw_get_geo(priv->ieee);\n\n\tif (priv->ieee->freq_band & LIBIPW_52GHZ_BAND) {\n\t\tint start = channel_index;\n\t\tfor (i = 0; i < geo->a_channels; i++) {\n\t\t\tif ((priv->status & STATUS_ASSOCIATED) &&\n\t\t\t    geo->a[i].channel == priv->channel)\n\t\t\t\tcontinue;\n\t\t\tchannel_index++;\n\t\t\tscan->channels_list[channel_index] = geo->a[i].channel;\n\t\t\tipw_set_scan_type(scan, channel_index,\n\t\t\t\t\t  geo->a[i].\n\t\t\t\t\t  flags & LIBIPW_CH_PASSIVE_ONLY ?\n\t\t\t\t\t  IPW_SCAN_PASSIVE_FULL_DWELL_SCAN :\n\t\t\t\t\t  scan_type);\n\t\t}\n\n\t\tif (start != channel_index) {\n\t\t\tscan->channels_list[start] = (u8) (IPW_A_MODE << 6) |\n\t\t\t    (channel_index - start);\n\t\t\tchannel_index++;\n\t\t}\n\t}\n\n\tif (priv->ieee->freq_band & LIBIPW_24GHZ_BAND) {\n\t\tint start = channel_index;\n\t\tif (priv->config & CFG_SPEED_SCAN) {\n\t\t\tint index;\n\t\t\tu8 channels[LIBIPW_24GHZ_CHANNELS] = {\n\t\t\t\t \n\t\t\t\t[0] = 0\n\t\t\t};\n\n\t\t\tu8 channel;\n\t\t\twhile (channel_index < IPW_SCAN_CHANNELS - 1) {\n\t\t\t\tchannel =\n\t\t\t\t    priv->speed_scan[priv->speed_scan_pos];\n\t\t\t\tif (channel == 0) {\n\t\t\t\t\tpriv->speed_scan_pos = 0;\n\t\t\t\t\tchannel = priv->speed_scan[0];\n\t\t\t\t}\n\t\t\t\tif ((priv->status & STATUS_ASSOCIATED) &&\n\t\t\t\t    channel == priv->channel) {\n\t\t\t\t\tpriv->speed_scan_pos++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (channels[channel - 1] != 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tchannels[channel - 1] = 1;\n\t\t\t\tpriv->speed_scan_pos++;\n\t\t\t\tchannel_index++;\n\t\t\t\tscan->channels_list[channel_index] = channel;\n\t\t\t\tindex =\n\t\t\t\t    libipw_channel_to_index(priv->ieee, channel);\n\t\t\t\tipw_set_scan_type(scan, channel_index,\n\t\t\t\t\t\t  geo->bg[index].\n\t\t\t\t\t\t  flags &\n\t\t\t\t\t\t  LIBIPW_CH_PASSIVE_ONLY ?\n\t\t\t\t\t\t  IPW_SCAN_PASSIVE_FULL_DWELL_SCAN\n\t\t\t\t\t\t  : scan_type);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < geo->bg_channels; i++) {\n\t\t\t\tif ((priv->status & STATUS_ASSOCIATED) &&\n\t\t\t\t    geo->bg[i].channel == priv->channel)\n\t\t\t\t\tcontinue;\n\t\t\t\tchannel_index++;\n\t\t\t\tscan->channels_list[channel_index] =\n\t\t\t\t    geo->bg[i].channel;\n\t\t\t\tipw_set_scan_type(scan, channel_index,\n\t\t\t\t\t\t  geo->bg[i].\n\t\t\t\t\t\t  flags &\n\t\t\t\t\t\t  LIBIPW_CH_PASSIVE_ONLY ?\n\t\t\t\t\t\t  IPW_SCAN_PASSIVE_FULL_DWELL_SCAN\n\t\t\t\t\t\t  : scan_type);\n\t\t\t}\n\t\t}\n\n\t\tif (start != channel_index) {\n\t\t\tscan->channels_list[start] = (u8) (IPW_B_MODE << 6) |\n\t\t\t    (channel_index - start);\n\t\t}\n\t}\n}\n\nstatic int ipw_passive_dwell_time(struct ipw_priv *priv)\n{\n\t \n\tif (priv->status & STATUS_ASSOCIATED\n\t    && priv->assoc_network->beacon_interval > 10)\n\t\treturn priv->assoc_network->beacon_interval - 10;\n\telse\n\t\treturn 120;\n}\n\nstatic int ipw_request_scan_helper(struct ipw_priv *priv, int type, int direct)\n{\n\tstruct ipw_scan_request_ext scan;\n\tint err = 0, scan_type;\n\n\tif (!(priv->status & STATUS_INIT) ||\n\t    (priv->status & STATUS_EXIT_PENDING))\n\t\treturn 0;\n\n\tmutex_lock(&priv->mutex);\n\n\tif (direct && (priv->direct_scan_ssid_len == 0)) {\n\t\tIPW_DEBUG_HC(\"Direct scan requested but no SSID to scan for\\n\");\n\t\tpriv->status &= ~STATUS_DIRECT_SCAN_PENDING;\n\t\tgoto done;\n\t}\n\n\tif (priv->status & STATUS_SCANNING) {\n\t\tIPW_DEBUG_HC(\"Concurrent scan requested.  Queuing.\\n\");\n\t\tpriv->status |= direct ? STATUS_DIRECT_SCAN_PENDING :\n\t\t\t\t\tSTATUS_SCAN_PENDING;\n\t\tgoto done;\n\t}\n\n\tif (!(priv->status & STATUS_SCAN_FORCED) &&\n\t    priv->status & STATUS_SCAN_ABORTING) {\n\t\tIPW_DEBUG_HC(\"Scan request while abort pending.  Queuing.\\n\");\n\t\tpriv->status |= direct ? STATUS_DIRECT_SCAN_PENDING :\n\t\t\t\t\tSTATUS_SCAN_PENDING;\n\t\tgoto done;\n\t}\n\n\tif (priv->status & STATUS_RF_KILL_MASK) {\n\t\tIPW_DEBUG_HC(\"Queuing scan due to RF Kill activation\\n\");\n\t\tpriv->status |= direct ? STATUS_DIRECT_SCAN_PENDING :\n\t\t\t\t\tSTATUS_SCAN_PENDING;\n\t\tgoto done;\n\t}\n\n\tmemset(&scan, 0, sizeof(scan));\n\tscan.full_scan_index = cpu_to_le32(libipw_get_scans(priv->ieee));\n\n\tif (type == IW_SCAN_TYPE_PASSIVE) {\n\t\tIPW_DEBUG_WX(\"use passive scanning\\n\");\n\t\tscan_type = IPW_SCAN_PASSIVE_FULL_DWELL_SCAN;\n\t\tscan.dwell_time[IPW_SCAN_PASSIVE_FULL_DWELL_SCAN] =\n\t\t\tcpu_to_le16(ipw_passive_dwell_time(priv));\n\t\tipw_add_scan_channels(priv, &scan, scan_type);\n\t\tgoto send_request;\n\t}\n\n\t \n\tif (priv->config & CFG_SPEED_SCAN)\n\t\tscan.dwell_time[IPW_SCAN_ACTIVE_BROADCAST_SCAN] =\n\t\t\tcpu_to_le16(30);\n\telse\n\t\tscan.dwell_time[IPW_SCAN_ACTIVE_BROADCAST_SCAN] =\n\t\t\tcpu_to_le16(20);\n\n\tscan.dwell_time[IPW_SCAN_ACTIVE_BROADCAST_AND_DIRECT_SCAN] =\n\t\tcpu_to_le16(20);\n\n\tscan.dwell_time[IPW_SCAN_PASSIVE_FULL_DWELL_SCAN] =\n\t\tcpu_to_le16(ipw_passive_dwell_time(priv));\n\tscan.dwell_time[IPW_SCAN_ACTIVE_DIRECT_SCAN] = cpu_to_le16(20);\n\n#ifdef CONFIG_IPW2200_MONITOR\n\tif (priv->ieee->iw_mode == IW_MODE_MONITOR) {\n\t\tu8 channel;\n\t\tu8 band = 0;\n\n\t\tswitch (libipw_is_valid_channel(priv->ieee, priv->channel)) {\n\t\tcase LIBIPW_52GHZ_BAND:\n\t\t\tband = (u8) (IPW_A_MODE << 6) | 1;\n\t\t\tchannel = priv->channel;\n\t\t\tbreak;\n\n\t\tcase LIBIPW_24GHZ_BAND:\n\t\t\tband = (u8) (IPW_B_MODE << 6) | 1;\n\t\t\tchannel = priv->channel;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tband = (u8) (IPW_B_MODE << 6) | 1;\n\t\t\tchannel = 9;\n\t\t\tbreak;\n\t\t}\n\n\t\tscan.channels_list[0] = band;\n\t\tscan.channels_list[1] = channel;\n\t\tipw_set_scan_type(&scan, 1, IPW_SCAN_PASSIVE_FULL_DWELL_SCAN);\n\n\t\t \n\t\tscan.dwell_time[IPW_SCAN_PASSIVE_FULL_DWELL_SCAN] =\n\t\t\tcpu_to_le16(2000);\n\t} else {\n#endif\t\t\t\t \n\t\t \n\t\tif (direct) {\n\t\t\terr = ipw_send_ssid(priv, priv->direct_scan_ssid,\n\t\t\t                    priv->direct_scan_ssid_len);\n\t\t\tif (err) {\n\t\t\t\tIPW_DEBUG_HC(\"Attempt to send SSID command  \"\n\t\t\t\t\t     \"failed\\n\");\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tscan_type = IPW_SCAN_ACTIVE_BROADCAST_AND_DIRECT_SCAN;\n\t\t} else if ((priv->status & STATUS_ROAMING)\n\t\t\t   || (!(priv->status & STATUS_ASSOCIATED)\n\t\t\t       && (priv->config & CFG_STATIC_ESSID)\n\t\t\t       && (le32_to_cpu(scan.full_scan_index) % 2))) {\n\t\t\terr = ipw_send_ssid(priv, priv->essid, priv->essid_len);\n\t\t\tif (err) {\n\t\t\t\tIPW_DEBUG_HC(\"Attempt to send SSID command \"\n\t\t\t\t\t     \"failed.\\n\");\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tscan_type = IPW_SCAN_ACTIVE_BROADCAST_AND_DIRECT_SCAN;\n\t\t} else\n\t\t\tscan_type = IPW_SCAN_ACTIVE_BROADCAST_SCAN;\n\n\t\tipw_add_scan_channels(priv, &scan, scan_type);\n#ifdef CONFIG_IPW2200_MONITOR\n\t}\n#endif\n\nsend_request:\n\terr = ipw_send_scan_request_ext(priv, &scan);\n\tif (err) {\n\t\tIPW_DEBUG_HC(\"Sending scan command failed: %08X\\n\", err);\n\t\tgoto done;\n\t}\n\n\tpriv->status |= STATUS_SCANNING;\n\tif (direct) {\n\t\tpriv->status &= ~STATUS_DIRECT_SCAN_PENDING;\n\t\tpriv->direct_scan_ssid_len = 0;\n\t} else\n\t\tpriv->status &= ~STATUS_SCAN_PENDING;\n\n\tschedule_delayed_work(&priv->scan_check, IPW_SCAN_CHECK_WATCHDOG);\ndone:\n\tmutex_unlock(&priv->mutex);\n\treturn err;\n}\n\nstatic void ipw_request_passive_scan(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, request_passive_scan.work);\n\tipw_request_scan_helper(priv, IW_SCAN_TYPE_PASSIVE, 0);\n}\n\nstatic void ipw_request_scan(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, request_scan.work);\n\tipw_request_scan_helper(priv, IW_SCAN_TYPE_ACTIVE, 0);\n}\n\nstatic void ipw_request_direct_scan(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, request_direct_scan.work);\n\tipw_request_scan_helper(priv, IW_SCAN_TYPE_ACTIVE, 1);\n}\n\nstatic void ipw_bg_abort_scan(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, abort_scan);\n\tmutex_lock(&priv->mutex);\n\tipw_abort_scan(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic int ipw_wpa_enable(struct ipw_priv *priv, int value)\n{\n\t \n\tpriv->ieee->wpa_enabled = value;\n\treturn 0;\n}\n\nstatic int ipw_wpa_set_auth_algs(struct ipw_priv *priv, int value)\n{\n\tstruct libipw_device *ieee = priv->ieee;\n\tstruct libipw_security sec = {\n\t\t.flags = SEC_AUTH_MODE,\n\t};\n\tint ret = 0;\n\n\tif (value & IW_AUTH_ALG_SHARED_KEY) {\n\t\tsec.auth_mode = WLAN_AUTH_SHARED_KEY;\n\t\tieee->open_wep = 0;\n\t} else if (value & IW_AUTH_ALG_OPEN_SYSTEM) {\n\t\tsec.auth_mode = WLAN_AUTH_OPEN;\n\t\tieee->open_wep = 1;\n\t} else if (value & IW_AUTH_ALG_LEAP) {\n\t\tsec.auth_mode = WLAN_AUTH_LEAP;\n\t\tieee->open_wep = 1;\n\t} else\n\t\treturn -EINVAL;\n\n\tif (ieee->set_security)\n\t\tieee->set_security(ieee->dev, &sec);\n\telse\n\t\tret = -EOPNOTSUPP;\n\n\treturn ret;\n}\n\nstatic void ipw_wpa_assoc_frame(struct ipw_priv *priv, char *wpa_ie,\n\t\t\t\tint wpa_ie_len)\n{\n\t \n\tipw_wpa_enable(priv, 1);\n}\n\nstatic int ipw_set_rsn_capa(struct ipw_priv *priv,\n\t\t\t    char *capabilities, int length)\n{\n\tIPW_DEBUG_HC(\"HOST_CMD_RSN_CAPABILITIES\\n\");\n\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_RSN_CAPABILITIES, length,\n\t\t\t\tcapabilities);\n}\n\n \n\n \nstatic int ipw_wx_set_genie(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tstruct libipw_device *ieee = priv->ieee;\n\tu8 *buf;\n\tint err = 0;\n\n\tif (wrqu->data.length > MAX_WPA_IE_LEN ||\n\t    (wrqu->data.length && extra == NULL))\n\t\treturn -EINVAL;\n\n\tif (wrqu->data.length) {\n\t\tbuf = kmemdup(extra, wrqu->data.length, GFP_KERNEL);\n\t\tif (buf == NULL) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkfree(ieee->wpa_ie);\n\t\tieee->wpa_ie = buf;\n\t\tieee->wpa_ie_len = wrqu->data.length;\n\t} else {\n\t\tkfree(ieee->wpa_ie);\n\t\tieee->wpa_ie = NULL;\n\t\tieee->wpa_ie_len = 0;\n\t}\n\n\tipw_wpa_assoc_frame(priv, ieee->wpa_ie, ieee->wpa_ie_len);\n      out:\n\treturn err;\n}\n\n \nstatic int ipw_wx_get_genie(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tstruct libipw_device *ieee = priv->ieee;\n\tint err = 0;\n\n\tif (ieee->wpa_ie_len == 0 || ieee->wpa_ie == NULL) {\n\t\twrqu->data.length = 0;\n\t\tgoto out;\n\t}\n\n\tif (wrqu->data.length < ieee->wpa_ie_len) {\n\t\terr = -E2BIG;\n\t\tgoto out;\n\t}\n\n\twrqu->data.length = ieee->wpa_ie_len;\n\tmemcpy(extra, ieee->wpa_ie, ieee->wpa_ie_len);\n\n      out:\n\treturn err;\n}\n\nstatic int wext_cipher2level(int cipher)\n{\n\tswitch (cipher) {\n\tcase IW_AUTH_CIPHER_NONE:\n\t\treturn SEC_LEVEL_0;\n\tcase IW_AUTH_CIPHER_WEP40:\n\tcase IW_AUTH_CIPHER_WEP104:\n\t\treturn SEC_LEVEL_1;\n\tcase IW_AUTH_CIPHER_TKIP:\n\t\treturn SEC_LEVEL_2;\n\tcase IW_AUTH_CIPHER_CCMP:\n\t\treturn SEC_LEVEL_3;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\n \nstatic int ipw_wx_set_auth(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tstruct libipw_device *ieee = priv->ieee;\n\tstruct iw_param *param = &wrqu->param;\n\tstruct lib80211_crypt_data *crypt;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\t\tbreak;\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\t\tipw_set_hw_decrypt_unicast(priv,\n\t\t\t\t\t   wext_cipher2level(param->value));\n\t\tbreak;\n\tcase IW_AUTH_CIPHER_GROUP:\n\t\tipw_set_hw_decrypt_multicast(priv,\n\t\t\t\t\t     wext_cipher2level(param->value));\n\t\tbreak;\n\tcase IW_AUTH_KEY_MGMT:\n\t\t \n\t\tbreak;\n\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\tcrypt = priv->ieee->crypt_info.crypt[priv->ieee->crypt_info.tx_keyidx];\n\t\tif (!crypt || !crypt->ops->set_flags || !crypt->ops->get_flags)\n\t\t\tbreak;\n\n\t\tflags = crypt->ops->get_flags(crypt->priv);\n\n\t\tif (param->value)\n\t\t\tflags |= IEEE80211_CRYPTO_TKIP_COUNTERMEASURES;\n\t\telse\n\t\t\tflags &= ~IEEE80211_CRYPTO_TKIP_COUNTERMEASURES;\n\n\t\tcrypt->ops->set_flags(flags, crypt->priv);\n\n\t\tbreak;\n\n\tcase IW_AUTH_DROP_UNENCRYPTED:{\n\t\t\t \n\t\t\tstruct libipw_security sec = {\n\t\t\t\t.flags = SEC_ENABLED,\n\t\t\t\t.enabled = param->value,\n\t\t\t};\n\t\t\tpriv->ieee->drop_unencrypted = param->value;\n\t\t\t \n\t\t\tif (!param->value) {\n\t\t\t\tsec.flags |= SEC_LEVEL;\n\t\t\t\tsec.level = SEC_LEVEL_0;\n\t\t\t} else {\n\t\t\t\tsec.flags |= SEC_LEVEL;\n\t\t\t\tsec.level = SEC_LEVEL_1;\n\t\t\t}\n\t\t\tif (priv->ieee->set_security)\n\t\t\t\tpriv->ieee->set_security(priv->ieee->dev, &sec);\n\t\t\tbreak;\n\t\t}\n\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tret = ipw_wpa_set_auth_algs(priv, param->value);\n\t\tbreak;\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tret = ipw_wpa_enable(priv, param->value);\n\t\tipw_disassociate(priv);\n\t\tbreak;\n\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\t\tieee->ieee802_1x = param->value;\n\t\tbreak;\n\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\t\tieee->privacy_invoked = param->value;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn ret;\n}\n\n \nstatic int ipw_wx_get_auth(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tstruct libipw_device *ieee = priv->ieee;\n\tstruct lib80211_crypt_data *crypt;\n\tstruct iw_param *param = &wrqu->param;\n\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_KEY_MGMT:\n\t\t \n\t\treturn -EOPNOTSUPP;\n\n\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\tcrypt = priv->ieee->crypt_info.crypt[priv->ieee->crypt_info.tx_keyidx];\n\t\tif (!crypt || !crypt->ops->get_flags)\n\t\t\tbreak;\n\n\t\tparam->value = (crypt->ops->get_flags(crypt->priv) &\n\t\t\t\tIEEE80211_CRYPTO_TKIP_COUNTERMEASURES) ? 1 : 0;\n\n\t\tbreak;\n\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\tparam->value = ieee->drop_unencrypted;\n\t\tbreak;\n\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tparam->value = ieee->sec.auth_mode;\n\t\tbreak;\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tparam->value = ieee->wpa_enabled;\n\t\tbreak;\n\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\t\tparam->value = ieee->ieee802_1x;\n\t\tbreak;\n\n\tcase IW_AUTH_ROAMING_CONTROL:\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\t\tparam->value = ieee->privacy_invoked;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n \nstatic int ipw_wx_set_encodeext(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\n\n\tif (hwcrypto) {\n\t\tif (ext->alg == IW_ENCODE_ALG_TKIP) {\n\t\t\t \n\t\t\tif (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY)\n\t\t\t\tpriv->ieee->host_mc_decrypt = 1;\n\t\t\telse {\n\t\t\t\tpriv->ieee->host_encrypt = 0;\n\t\t\t\tpriv->ieee->host_encrypt_msdu = 1;\n\t\t\t\tpriv->ieee->host_decrypt = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tpriv->ieee->host_encrypt = 0;\n\t\t\tpriv->ieee->host_encrypt_msdu = 0;\n\t\t\tpriv->ieee->host_decrypt = 0;\n\t\t\tpriv->ieee->host_mc_decrypt = 0;\n\t\t}\n\t}\n\n\treturn libipw_wx_set_encodeext(priv->ieee, info, wrqu, extra);\n}\n\n \nstatic int ipw_wx_get_encodeext(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\treturn libipw_wx_get_encodeext(priv->ieee, info, wrqu, extra);\n}\n\n \nstatic int ipw_wx_set_mlme(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tstruct iw_mlme *mlme = (struct iw_mlme *)extra;\n\n\tswitch (mlme->cmd) {\n\tcase IW_MLME_DEAUTH:\n\t\t \n\t\tbreak;\n\n\tcase IW_MLME_DISASSOC:\n\t\tipw_disassociate(priv);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_IPW2200_QOS\n\n \n \nstatic u8 ipw_qos_current_mode(struct ipw_priv * priv)\n{\n\tu8 mode = 0;\n\n\tif (priv->status & STATUS_ASSOCIATED) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&priv->ieee->lock, flags);\n\t\tmode = priv->assoc_network->mode;\n\t\tspin_unlock_irqrestore(&priv->ieee->lock, flags);\n\t} else {\n\t\tmode = priv->ieee->mode;\n\t}\n\tIPW_DEBUG_QOS(\"QoS network/card mode %d\\n\", mode);\n\treturn mode;\n}\n\n \nstatic int ipw_qos_handle_probe_response(struct ipw_priv *priv,\n\t\t\t\t\t int active_network,\n\t\t\t\t\t struct libipw_network *network)\n{\n\tu32 size = sizeof(struct libipw_qos_parameters);\n\n\tif (network->capability & WLAN_CAPABILITY_IBSS)\n\t\tnetwork->qos_data.active = network->qos_data.supported;\n\n\tif (network->flags & NETWORK_HAS_QOS_MASK) {\n\t\tif (active_network &&\n\t\t    (network->flags & NETWORK_HAS_QOS_PARAMETERS))\n\t\t\tnetwork->qos_data.active = network->qos_data.supported;\n\n\t\tif ((network->qos_data.active == 1) && (active_network == 1) &&\n\t\t    (network->flags & NETWORK_HAS_QOS_PARAMETERS) &&\n\t\t    (network->qos_data.old_param_count !=\n\t\t     network->qos_data.param_count)) {\n\t\t\tnetwork->qos_data.old_param_count =\n\t\t\t    network->qos_data.param_count;\n\t\t\tschedule_work(&priv->qos_activate);\n\t\t\tIPW_DEBUG_QOS(\"QoS parameters change call \"\n\t\t\t\t      \"qos_activate\\n\");\n\t\t}\n\t} else {\n\t\tif ((priv->ieee->mode == IEEE_B) || (network->mode == IEEE_B))\n\t\t\tmemcpy(&network->qos_data.parameters,\n\t\t\t       &def_parameters_CCK, size);\n\t\telse\n\t\t\tmemcpy(&network->qos_data.parameters,\n\t\t\t       &def_parameters_OFDM, size);\n\n\t\tif ((network->qos_data.active == 1) && (active_network == 1)) {\n\t\t\tIPW_DEBUG_QOS(\"QoS was disabled call qos_activate\\n\");\n\t\t\tschedule_work(&priv->qos_activate);\n\t\t}\n\n\t\tnetwork->qos_data.active = 0;\n\t\tnetwork->qos_data.supported = 0;\n\t}\n\tif ((priv->status & STATUS_ASSOCIATED) &&\n\t    (priv->ieee->iw_mode == IW_MODE_ADHOC) && (active_network == 0)) {\n\t\tif (!ether_addr_equal(network->bssid, priv->bssid))\n\t\t\tif (network->capability & WLAN_CAPABILITY_IBSS)\n\t\t\t\tif ((network->ssid_len ==\n\t\t\t\t     priv->assoc_network->ssid_len) &&\n\t\t\t\t    !memcmp(network->ssid,\n\t\t\t\t\t    priv->assoc_network->ssid,\n\t\t\t\t\t    network->ssid_len)) {\n\t\t\t\t\tschedule_work(&priv->merge_networks);\n\t\t\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ipw_qos_activate(struct ipw_priv *priv,\n\t\t\t    struct libipw_qos_data *qos_network_data)\n{\n\tint err;\n\tstruct libipw_qos_parameters qos_parameters[QOS_QOS_SETS];\n\tstruct libipw_qos_parameters *active_one = NULL;\n\tu32 size = sizeof(struct libipw_qos_parameters);\n\tu32 burst_duration;\n\tint i;\n\tu8 type;\n\n\ttype = ipw_qos_current_mode(priv);\n\n\tactive_one = &(qos_parameters[QOS_PARAM_SET_DEF_CCK]);\n\tmemcpy(active_one, priv->qos_data.def_qos_parm_CCK, size);\n\tactive_one = &(qos_parameters[QOS_PARAM_SET_DEF_OFDM]);\n\tmemcpy(active_one, priv->qos_data.def_qos_parm_OFDM, size);\n\n\tif (qos_network_data == NULL) {\n\t\tif (type == IEEE_B) {\n\t\t\tIPW_DEBUG_QOS(\"QoS activate network mode %d\\n\", type);\n\t\t\tactive_one = &def_parameters_CCK;\n\t\t} else\n\t\t\tactive_one = &def_parameters_OFDM;\n\n\t\tmemcpy(&qos_parameters[QOS_PARAM_SET_ACTIVE], active_one, size);\n\t\tburst_duration = ipw_qos_get_burst_duration(priv);\n\t\tfor (i = 0; i < QOS_QUEUE_NUM; i++)\n\t\t\tqos_parameters[QOS_PARAM_SET_ACTIVE].tx_op_limit[i] =\n\t\t\t    cpu_to_le16(burst_duration);\n\t} else if (priv->ieee->iw_mode == IW_MODE_ADHOC) {\n\t\tif (type == IEEE_B) {\n\t\t\tIPW_DEBUG_QOS(\"QoS activate IBSS network mode %d\\n\",\n\t\t\t\t      type);\n\t\t\tif (priv->qos_data.qos_enable == 0)\n\t\t\t\tactive_one = &def_parameters_CCK;\n\t\t\telse\n\t\t\t\tactive_one = priv->qos_data.def_qos_parm_CCK;\n\t\t} else {\n\t\t\tif (priv->qos_data.qos_enable == 0)\n\t\t\t\tactive_one = &def_parameters_OFDM;\n\t\t\telse\n\t\t\t\tactive_one = priv->qos_data.def_qos_parm_OFDM;\n\t\t}\n\t\tmemcpy(&qos_parameters[QOS_PARAM_SET_ACTIVE], active_one, size);\n\t} else {\n\t\tunsigned long flags;\n\t\tint active;\n\n\t\tspin_lock_irqsave(&priv->ieee->lock, flags);\n\t\tactive_one = &(qos_network_data->parameters);\n\t\tqos_network_data->old_param_count =\n\t\t    qos_network_data->param_count;\n\t\tmemcpy(&qos_parameters[QOS_PARAM_SET_ACTIVE], active_one, size);\n\t\tactive = qos_network_data->supported;\n\t\tspin_unlock_irqrestore(&priv->ieee->lock, flags);\n\n\t\tif (active == 0) {\n\t\t\tburst_duration = ipw_qos_get_burst_duration(priv);\n\t\t\tfor (i = 0; i < QOS_QUEUE_NUM; i++)\n\t\t\t\tqos_parameters[QOS_PARAM_SET_ACTIVE].\n\t\t\t\t    tx_op_limit[i] = cpu_to_le16(burst_duration);\n\t\t}\n\t}\n\n\tIPW_DEBUG_QOS(\"QoS sending IPW_CMD_QOS_PARAMETERS\\n\");\n\terr = ipw_send_qos_params_command(priv, &qos_parameters[0]);\n\tif (err)\n\t\tIPW_DEBUG_QOS(\"QoS IPW_CMD_QOS_PARAMETERS failed\\n\");\n\n\treturn err;\n}\n\n \nstatic int ipw_qos_set_info_element(struct ipw_priv *priv)\n{\n\tint ret = 0;\n\tstruct libipw_qos_information_element qos_info;\n\n\tif (priv == NULL)\n\t\treturn -1;\n\n\tqos_info.elementID = QOS_ELEMENT_ID;\n\tqos_info.length = sizeof(struct libipw_qos_information_element) - 2;\n\n\tqos_info.version = QOS_VERSION_1;\n\tqos_info.ac_info = 0;\n\n\tmemcpy(qos_info.qui, qos_oui, QOS_OUI_LEN);\n\tqos_info.qui_type = QOS_OUI_TYPE;\n\tqos_info.qui_subtype = QOS_OUI_INFO_SUB_TYPE;\n\n\tret = ipw_send_qos_info_command(priv, &qos_info);\n\tif (ret != 0) {\n\t\tIPW_DEBUG_QOS(\"QoS error calling ipw_send_qos_info_command\\n\");\n\t}\n\treturn ret;\n}\n\n \nstatic int ipw_qos_association(struct ipw_priv *priv,\n\t\t\t       struct libipw_network *network)\n{\n\tint err = 0;\n\tstruct libipw_qos_data *qos_data = NULL;\n\tstruct libipw_qos_data ibss_data = {\n\t\t.supported = 1,\n\t\t.active = 1,\n\t};\n\n\tswitch (priv->ieee->iw_mode) {\n\tcase IW_MODE_ADHOC:\n\t\tBUG_ON(!(network->capability & WLAN_CAPABILITY_IBSS));\n\n\t\tqos_data = &ibss_data;\n\t\tbreak;\n\n\tcase IW_MODE_INFRA:\n\t\tqos_data = &network->qos_data;\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\terr = ipw_qos_activate(priv, qos_data);\n\tif (err) {\n\t\tpriv->assoc_request.policy_support &= ~HC_QOS_SUPPORT_ASSOC;\n\t\treturn err;\n\t}\n\n\tif (priv->qos_data.qos_enable && qos_data->supported) {\n\t\tIPW_DEBUG_QOS(\"QoS will be enabled for this association\\n\");\n\t\tpriv->assoc_request.policy_support |= HC_QOS_SUPPORT_ASSOC;\n\t\treturn ipw_qos_set_info_element(priv);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ipw_qos_association_resp(struct ipw_priv *priv,\n\t\t\t\t    struct libipw_network *network)\n{\n\tunsigned long flags;\n\tu32 size = sizeof(struct libipw_qos_parameters);\n\tint set_qos_param = 0;\n\n\tif ((priv == NULL) || (network == NULL) ||\n\t    (priv->assoc_network == NULL))\n\t\treturn;\n\n\tif (!(priv->status & STATUS_ASSOCIATED))\n\t\treturn;\n\n\tif ((priv->ieee->iw_mode != IW_MODE_INFRA))\n\t\treturn;\n\n\tspin_lock_irqsave(&priv->ieee->lock, flags);\n\tif (network->flags & NETWORK_HAS_QOS_PARAMETERS) {\n\t\tmemcpy(&priv->assoc_network->qos_data, &network->qos_data,\n\t\t       sizeof(struct libipw_qos_data));\n\t\tpriv->assoc_network->qos_data.active = 1;\n\t\tif ((network->qos_data.old_param_count !=\n\t\t     network->qos_data.param_count)) {\n\t\t\tset_qos_param = 1;\n\t\t\tnetwork->qos_data.old_param_count =\n\t\t\t    network->qos_data.param_count;\n\t\t}\n\n\t} else {\n\t\tif ((network->mode == IEEE_B) || (priv->ieee->mode == IEEE_B))\n\t\t\tmemcpy(&priv->assoc_network->qos_data.parameters,\n\t\t\t       &def_parameters_CCK, size);\n\t\telse\n\t\t\tmemcpy(&priv->assoc_network->qos_data.parameters,\n\t\t\t       &def_parameters_OFDM, size);\n\t\tpriv->assoc_network->qos_data.active = 0;\n\t\tpriv->assoc_network->qos_data.supported = 0;\n\t\tset_qos_param = 1;\n\t}\n\n\tspin_unlock_irqrestore(&priv->ieee->lock, flags);\n\n\tif (set_qos_param == 1)\n\t\tschedule_work(&priv->qos_activate);\n}\n\nstatic u32 ipw_qos_get_burst_duration(struct ipw_priv *priv)\n{\n\tu32 ret = 0;\n\n\tif (!priv)\n\t\treturn 0;\n\n\tif (!(priv->ieee->modulation & LIBIPW_OFDM_MODULATION))\n\t\tret = priv->qos_data.burst_duration_CCK;\n\telse\n\t\tret = priv->qos_data.burst_duration_OFDM;\n\n\treturn ret;\n}\n\n \nstatic void ipw_qos_init(struct ipw_priv *priv, int enable,\n\t\t\t int burst_enable, u32 burst_duration_CCK,\n\t\t\t u32 burst_duration_OFDM)\n{\n\tpriv->qos_data.qos_enable = enable;\n\n\tif (priv->qos_data.qos_enable) {\n\t\tpriv->qos_data.def_qos_parm_CCK = &def_qos_parameters_CCK;\n\t\tpriv->qos_data.def_qos_parm_OFDM = &def_qos_parameters_OFDM;\n\t\tIPW_DEBUG_QOS(\"QoS is enabled\\n\");\n\t} else {\n\t\tpriv->qos_data.def_qos_parm_CCK = &def_parameters_CCK;\n\t\tpriv->qos_data.def_qos_parm_OFDM = &def_parameters_OFDM;\n\t\tIPW_DEBUG_QOS(\"QoS is not enabled\\n\");\n\t}\n\n\tpriv->qos_data.burst_enable = burst_enable;\n\n\tif (burst_enable) {\n\t\tpriv->qos_data.burst_duration_CCK = burst_duration_CCK;\n\t\tpriv->qos_data.burst_duration_OFDM = burst_duration_OFDM;\n\t} else {\n\t\tpriv->qos_data.burst_duration_CCK = 0;\n\t\tpriv->qos_data.burst_duration_OFDM = 0;\n\t}\n}\n\n \nstatic int ipw_get_tx_queue_number(struct ipw_priv *priv, u16 priority)\n{\n\tif (priority > 7 || !priv->qos_data.qos_enable)\n\t\tpriority = 0;\n\n\treturn from_priority_to_tx_queue[priority] - 1;\n}\n\nstatic int ipw_is_qos_active(struct net_device *dev,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tstruct libipw_qos_data *qos_data = NULL;\n\tint active, supported;\n\tu8 *daddr = skb->data + ETH_ALEN;\n\tint unicast = !is_multicast_ether_addr(daddr);\n\n\tif (!(priv->status & STATUS_ASSOCIATED))\n\t\treturn 0;\n\n\tqos_data = &priv->assoc_network->qos_data;\n\n\tif (priv->ieee->iw_mode == IW_MODE_ADHOC) {\n\t\tif (unicast == 0)\n\t\t\tqos_data->active = 0;\n\t\telse\n\t\t\tqos_data->active = qos_data->supported;\n\t}\n\tactive = qos_data->active;\n\tsupported = qos_data->supported;\n\tIPW_DEBUG_QOS(\"QoS  %d network is QoS active %d  supported %d  \"\n\t\t      \"unicast %d\\n\",\n\t\t      priv->qos_data.qos_enable, active, supported, unicast);\n\tif (active && priv->qos_data.qos_enable)\n\t\treturn 1;\n\n\treturn 0;\n\n}\n \nstatic int ipw_qos_set_tx_queue_command(struct ipw_priv *priv,\n\t\t\t\t\tu16 priority,\n\t\t\t\t\tstruct tfd_data *tfd)\n{\n\tint tx_queue_id = 0;\n\n\n\ttx_queue_id = from_priority_to_tx_queue[priority] - 1;\n\ttfd->tx_flags_ext |= DCT_FLAG_EXT_QOS_ENABLED;\n\n\tif (priv->qos_data.qos_no_ack_mask & (1UL << tx_queue_id)) {\n\t\ttfd->tx_flags &= ~DCT_FLAG_ACK_REQD;\n\t\ttfd->tfd.tfd_26.mchdr.qos_ctrl |= cpu_to_le16(CTRL_QOS_NO_ACK);\n\t}\n\treturn 0;\n}\n\n \nstatic void ipw_bg_qos_activate(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, qos_activate);\n\n\tmutex_lock(&priv->mutex);\n\n\tif (priv->status & STATUS_ASSOCIATED)\n\t\tipw_qos_activate(priv, &(priv->assoc_network->qos_data));\n\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic int ipw_handle_probe_response(struct net_device *dev,\n\t\t\t\t     struct libipw_probe_response *resp,\n\t\t\t\t     struct libipw_network *network)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tint active_network = ((priv->status & STATUS_ASSOCIATED) &&\n\t\t\t      (network == priv->assoc_network));\n\n\tipw_qos_handle_probe_response(priv, active_network, network);\n\n\treturn 0;\n}\n\nstatic int ipw_handle_beacon(struct net_device *dev,\n\t\t\t     struct libipw_beacon *resp,\n\t\t\t     struct libipw_network *network)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tint active_network = ((priv->status & STATUS_ASSOCIATED) &&\n\t\t\t      (network == priv->assoc_network));\n\n\tipw_qos_handle_probe_response(priv, active_network, network);\n\n\treturn 0;\n}\n\nstatic int ipw_handle_assoc_response(struct net_device *dev,\n\t\t\t\t     struct libipw_assoc_response *resp,\n\t\t\t\t     struct libipw_network *network)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tipw_qos_association_resp(priv, network);\n\treturn 0;\n}\n\nstatic int ipw_send_qos_params_command(struct ipw_priv *priv, struct libipw_qos_parameters\n\t\t\t\t       *qos_param)\n{\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_QOS_PARAMETERS,\n\t\t\t\tsizeof(*qos_param) * 3, qos_param);\n}\n\nstatic int ipw_send_qos_info_command(struct ipw_priv *priv, struct libipw_qos_information_element\n\t\t\t\t     *qos_param)\n{\n\treturn ipw_send_cmd_pdu(priv, IPW_CMD_WME_INFO, sizeof(*qos_param),\n\t\t\t\tqos_param);\n}\n\n#endif\t\t\t\t \n\nstatic int ipw_associate_network(struct ipw_priv *priv,\n\t\t\t\t struct libipw_network *network,\n\t\t\t\t struct ipw_supported_rates *rates, int roaming)\n{\n\tint err;\n\n\tif (priv->config & CFG_FIXED_RATE)\n\t\tipw_set_fixed_rate(priv, network->mode);\n\n\tif (!(priv->config & CFG_STATIC_ESSID)) {\n\t\tpriv->essid_len = min(network->ssid_len,\n\t\t\t\t      (u8) IW_ESSID_MAX_SIZE);\n\t\tmemcpy(priv->essid, network->ssid, priv->essid_len);\n\t}\n\n\tnetwork->last_associate = jiffies;\n\n\tmemset(&priv->assoc_request, 0, sizeof(priv->assoc_request));\n\tpriv->assoc_request.channel = network->channel;\n\tpriv->assoc_request.auth_key = 0;\n\n\tif ((priv->capability & CAP_PRIVACY_ON) &&\n\t    (priv->ieee->sec.auth_mode == WLAN_AUTH_SHARED_KEY)) {\n\t\tpriv->assoc_request.auth_type = AUTH_SHARED_KEY;\n\t\tpriv->assoc_request.auth_key = priv->ieee->sec.active_key;\n\n\t\tif (priv->ieee->sec.level == SEC_LEVEL_1)\n\t\t\tipw_send_wep_keys(priv, DCW_WEP_KEY_SEC_TYPE_WEP);\n\n\t} else if ((priv->capability & CAP_PRIVACY_ON) &&\n\t\t   (priv->ieee->sec.auth_mode == WLAN_AUTH_LEAP))\n\t\tpriv->assoc_request.auth_type = AUTH_LEAP;\n\telse\n\t\tpriv->assoc_request.auth_type = AUTH_OPEN;\n\n\tif (priv->ieee->wpa_ie_len) {\n\t\tpriv->assoc_request.policy_support = cpu_to_le16(0x02);\t \n\t\tipw_set_rsn_capa(priv, priv->ieee->wpa_ie,\n\t\t\t\t priv->ieee->wpa_ie_len);\n\t}\n\n\t \n\tif (network->mode & priv->ieee->mode & IEEE_A)\n\t\tpriv->assoc_request.ieee_mode = IPW_A_MODE;\n\telse if (network->mode & priv->ieee->mode & IEEE_G)\n\t\tpriv->assoc_request.ieee_mode = IPW_G_MODE;\n\telse if (network->mode & priv->ieee->mode & IEEE_B)\n\t\tpriv->assoc_request.ieee_mode = IPW_B_MODE;\n\n\tpriv->assoc_request.capability = cpu_to_le16(network->capability);\n\tif ((network->capability & WLAN_CAPABILITY_SHORT_PREAMBLE)\n\t    && !(priv->config & CFG_PREAMBLE_LONG)) {\n\t\tpriv->assoc_request.preamble_length = DCT_FLAG_SHORT_PREAMBLE;\n\t} else {\n\t\tpriv->assoc_request.preamble_length = DCT_FLAG_LONG_PREAMBLE;\n\n\t\t \n\t\tpriv->assoc_request.capability &=\n\t\t    ~cpu_to_le16(WLAN_CAPABILITY_SHORT_PREAMBLE);\n\t}\n\n\t \n\tif (priv->ieee->iw_mode == IW_MODE_ADHOC)\n\t\tpriv->assoc_request.capability &=\n\t\t    ~cpu_to_le16(WLAN_CAPABILITY_SHORT_SLOT_TIME);\n\n\tIPW_DEBUG_ASSOC(\"%ssociation attempt: '%*pE', channel %d, 802.11%c [%d], %s[:%s], enc=%s%s%s%c%c\\n\",\n\t\t\troaming ? \"Rea\" : \"A\",\n\t\t\tpriv->essid_len, priv->essid,\n\t\t\tnetwork->channel,\n\t\t\tipw_modes[priv->assoc_request.ieee_mode],\n\t\t\trates->num_rates,\n\t\t\t(priv->assoc_request.preamble_length ==\n\t\t\t DCT_FLAG_LONG_PREAMBLE) ? \"long\" : \"short\",\n\t\t\tnetwork->capability &\n\t\t\tWLAN_CAPABILITY_SHORT_PREAMBLE ? \"short\" : \"long\",\n\t\t\tpriv->capability & CAP_PRIVACY_ON ? \"on \" : \"off\",\n\t\t\tpriv->capability & CAP_PRIVACY_ON ?\n\t\t\t(priv->capability & CAP_SHARED_KEY ? \"(shared)\" :\n\t\t\t \"(open)\") : \"\",\n\t\t\tpriv->capability & CAP_PRIVACY_ON ? \" key=\" : \"\",\n\t\t\tpriv->capability & CAP_PRIVACY_ON ?\n\t\t\t'1' + priv->ieee->sec.active_key : '.',\n\t\t\tpriv->capability & CAP_PRIVACY_ON ? '.' : ' ');\n\n\tpriv->assoc_request.beacon_interval = cpu_to_le16(network->beacon_interval);\n\tif ((priv->ieee->iw_mode == IW_MODE_ADHOC) &&\n\t    (network->time_stamp[0] == 0) && (network->time_stamp[1] == 0)) {\n\t\tpriv->assoc_request.assoc_type = HC_IBSS_START;\n\t\tpriv->assoc_request.assoc_tsf_msw = 0;\n\t\tpriv->assoc_request.assoc_tsf_lsw = 0;\n\t} else {\n\t\tif (unlikely(roaming))\n\t\t\tpriv->assoc_request.assoc_type = HC_REASSOCIATE;\n\t\telse\n\t\t\tpriv->assoc_request.assoc_type = HC_ASSOCIATE;\n\t\tpriv->assoc_request.assoc_tsf_msw = cpu_to_le32(network->time_stamp[1]);\n\t\tpriv->assoc_request.assoc_tsf_lsw = cpu_to_le32(network->time_stamp[0]);\n\t}\n\n\tmemcpy(priv->assoc_request.bssid, network->bssid, ETH_ALEN);\n\n\tif (priv->ieee->iw_mode == IW_MODE_ADHOC) {\n\t\teth_broadcast_addr(priv->assoc_request.dest);\n\t\tpriv->assoc_request.atim_window = cpu_to_le16(network->atim_window);\n\t} else {\n\t\tmemcpy(priv->assoc_request.dest, network->bssid, ETH_ALEN);\n\t\tpriv->assoc_request.atim_window = 0;\n\t}\n\n\tpriv->assoc_request.listen_interval = cpu_to_le16(network->listen_interval);\n\n\terr = ipw_send_ssid(priv, priv->essid, priv->essid_len);\n\tif (err) {\n\t\tIPW_DEBUG_HC(\"Attempt to send SSID command failed.\\n\");\n\t\treturn err;\n\t}\n\n\trates->ieee_mode = priv->assoc_request.ieee_mode;\n\trates->purpose = IPW_RATE_CONNECT;\n\tipw_send_supported_rates(priv, rates);\n\n\tif (priv->assoc_request.ieee_mode == IPW_G_MODE)\n\t\tpriv->sys_config.dot11g_auto_detection = 1;\n\telse\n\t\tpriv->sys_config.dot11g_auto_detection = 0;\n\n\tif (priv->ieee->iw_mode == IW_MODE_ADHOC)\n\t\tpriv->sys_config.answer_broadcast_ssid_probe = 1;\n\telse\n\t\tpriv->sys_config.answer_broadcast_ssid_probe = 0;\n\n\terr = ipw_send_system_config(priv);\n\tif (err) {\n\t\tIPW_DEBUG_HC(\"Attempt to send sys config command failed.\\n\");\n\t\treturn err;\n\t}\n\n\tIPW_DEBUG_ASSOC(\"Association sensitivity: %d\\n\", network->stats.rssi);\n\terr = ipw_set_sensitivity(priv, network->stats.rssi + IPW_RSSI_TO_DBM);\n\tif (err) {\n\t\tIPW_DEBUG_HC(\"Attempt to send associate command failed.\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tpriv->channel = network->channel;\n\tmemcpy(priv->bssid, network->bssid, ETH_ALEN);\n\tpriv->status |= STATUS_ASSOCIATING;\n\tpriv->status &= ~STATUS_SECURITY_UPDATED;\n\n\tpriv->assoc_network = network;\n\n#ifdef CONFIG_IPW2200_QOS\n\tipw_qos_association(priv, network);\n#endif\n\n\terr = ipw_send_associate(priv, &priv->assoc_request);\n\tif (err) {\n\t\tIPW_DEBUG_HC(\"Attempt to send associate command failed.\\n\");\n\t\treturn err;\n\t}\n\n\tIPW_DEBUG(IPW_DL_STATE, \"associating: '%*pE' %pM\\n\",\n\t\t  priv->essid_len, priv->essid, priv->bssid);\n\n\treturn 0;\n}\n\nstatic void ipw_roam(void *data)\n{\n\tstruct ipw_priv *priv = data;\n\tstruct libipw_network *network = NULL;\n\tstruct ipw_network_match match = {\n\t\t.network = priv->assoc_network\n\t};\n\n\t \n\n\t \n\tif (!(priv->status & (STATUS_ASSOCIATED | STATUS_ROAMING)))\n\t\treturn;\n\n\tif (priv->status & STATUS_ASSOCIATED) {\n\t\t \n\t\tunsigned long flags;\n\t\tu8 rssi = priv->assoc_network->stats.rssi;\n\t\tpriv->assoc_network->stats.rssi = -128;\n\t\tspin_lock_irqsave(&priv->ieee->lock, flags);\n\t\tlist_for_each_entry(network, &priv->ieee->network_list, list) {\n\t\t\tif (network != priv->assoc_network)\n\t\t\t\tipw_best_network(priv, &match, network, 1);\n\t\t}\n\t\tspin_unlock_irqrestore(&priv->ieee->lock, flags);\n\t\tpriv->assoc_network->stats.rssi = rssi;\n\n\t\tif (match.network == priv->assoc_network) {\n\t\t\tIPW_DEBUG_ASSOC(\"No better APs in this network to \"\n\t\t\t\t\t\"roam to.\\n\");\n\t\t\tpriv->status &= ~STATUS_ROAMING;\n\t\t\tipw_debug_config(priv);\n\t\t\treturn;\n\t\t}\n\n\t\tipw_send_disassociate(priv, 1);\n\t\tpriv->assoc_network = match.network;\n\n\t\treturn;\n\t}\n\n\t \n\tipw_compatible_rates(priv, priv->assoc_network, &match.rates);\n\tipw_associate_network(priv, priv->assoc_network, &match.rates, 1);\n\tpriv->status &= ~STATUS_ROAMING;\n}\n\nstatic void ipw_bg_roam(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, roam);\n\tmutex_lock(&priv->mutex);\n\tipw_roam(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic int ipw_associate(void *data)\n{\n\tstruct ipw_priv *priv = data;\n\n\tstruct libipw_network *network = NULL;\n\tstruct ipw_network_match match = {\n\t\t.network = NULL\n\t};\n\tstruct ipw_supported_rates *rates;\n\tstruct list_head *element;\n\tunsigned long flags;\n\n\tif (priv->ieee->iw_mode == IW_MODE_MONITOR) {\n\t\tIPW_DEBUG_ASSOC(\"Not attempting association (monitor mode)\\n\");\n\t\treturn 0;\n\t}\n\n\tif (priv->status & (STATUS_ASSOCIATED | STATUS_ASSOCIATING)) {\n\t\tIPW_DEBUG_ASSOC(\"Not attempting association (already in \"\n\t\t\t\t\"progress)\\n\");\n\t\treturn 0;\n\t}\n\n\tif (priv->status & STATUS_DISASSOCIATING) {\n\t\tIPW_DEBUG_ASSOC(\"Not attempting association (in disassociating)\\n\");\n\t\tschedule_work(&priv->associate);\n\t\treturn 0;\n\t}\n\n\tif (!ipw_is_init(priv) || (priv->status & STATUS_SCANNING)) {\n\t\tIPW_DEBUG_ASSOC(\"Not attempting association (scanning or not \"\n\t\t\t\t\"initialized)\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!(priv->config & CFG_ASSOCIATE) &&\n\t    !(priv->config & (CFG_STATIC_ESSID | CFG_STATIC_BSSID))) {\n\t\tIPW_DEBUG_ASSOC(\"Not attempting association (associate=0)\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tspin_lock_irqsave(&priv->ieee->lock, flags);\n\tlist_for_each_entry(network, &priv->ieee->network_list, list)\n\t    ipw_best_network(priv, &match, network, 0);\n\n\tnetwork = match.network;\n\trates = &match.rates;\n\n\tif (network == NULL &&\n\t    priv->ieee->iw_mode == IW_MODE_ADHOC &&\n\t    priv->config & CFG_ADHOC_CREATE &&\n\t    priv->config & CFG_STATIC_ESSID &&\n\t    priv->config & CFG_STATIC_CHANNEL) {\n\t\t \n\t\tif (list_empty(&priv->ieee->network_free_list)) {\n\t\t\tstruct libipw_network *oldest = NULL;\n\t\t\tstruct libipw_network *target;\n\n\t\t\tlist_for_each_entry(target, &priv->ieee->network_list, list) {\n\t\t\t\tif ((oldest == NULL) ||\n\t\t\t\t    (target->last_scanned < oldest->last_scanned))\n\t\t\t\t\toldest = target;\n\t\t\t}\n\n\t\t\t \n\t\t\tlist_del(&oldest->list);\n\t\t\ttarget = oldest;\n\t\t\tIPW_DEBUG_ASSOC(\"Expired '%*pE' (%pM) from network list.\\n\",\n\t\t\t\t\ttarget->ssid_len, target->ssid,\n\t\t\t\t\ttarget->bssid);\n\t\t\tlist_add_tail(&target->list,\n\t\t\t\t      &priv->ieee->network_free_list);\n\t\t}\n\n\t\telement = priv->ieee->network_free_list.next;\n\t\tnetwork = list_entry(element, struct libipw_network, list);\n\t\tipw_adhoc_create(priv, network);\n\t\trates = &priv->rates;\n\t\tlist_del(element);\n\t\tlist_add_tail(&network->list, &priv->ieee->network_list);\n\t}\n\tspin_unlock_irqrestore(&priv->ieee->lock, flags);\n\n\t \n\tif (!network) {\n\t\tipw_debug_config(priv);\n\n\t\tif (!(priv->status & STATUS_SCANNING)) {\n\t\t\tif (!(priv->config & CFG_SPEED_SCAN))\n\t\t\t\tschedule_delayed_work(&priv->request_scan,\n\t\t\t\t\t\t      SCAN_INTERVAL);\n\t\t\telse\n\t\t\t\tschedule_delayed_work(&priv->request_scan, 0);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tipw_associate_network(priv, network, rates, 0);\n\n\treturn 1;\n}\n\nstatic void ipw_bg_associate(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, associate);\n\tmutex_lock(&priv->mutex);\n\tipw_associate(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void ipw_rebuild_decrypted_skb(struct ipw_priv *priv,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr;\n\tu16 fc;\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\tfc = le16_to_cpu(hdr->frame_control);\n\tif (!(fc & IEEE80211_FCTL_PROTECTED))\n\t\treturn;\n\n\tfc &= ~IEEE80211_FCTL_PROTECTED;\n\thdr->frame_control = cpu_to_le16(fc);\n\tswitch (priv->ieee->sec.level) {\n\tcase SEC_LEVEL_3:\n\t\t \n\t\tmemmove(skb->data + LIBIPW_3ADDR_LEN,\n\t\t\tskb->data + LIBIPW_3ADDR_LEN + 8,\n\t\t\tskb->len - LIBIPW_3ADDR_LEN - 8);\n\t\tskb_trim(skb, skb->len - 16);\t \n\t\tbreak;\n\tcase SEC_LEVEL_2:\n\t\tbreak;\n\tcase SEC_LEVEL_1:\n\t\t \n\t\tmemmove(skb->data + LIBIPW_3ADDR_LEN,\n\t\t\tskb->data + LIBIPW_3ADDR_LEN + 4,\n\t\t\tskb->len - LIBIPW_3ADDR_LEN - 4);\n\t\tskb_trim(skb, skb->len - 8);\t \n\t\tbreak;\n\tcase SEC_LEVEL_0:\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Unknown security level %d\\n\",\n\t\t       priv->ieee->sec.level);\n\t\tbreak;\n\t}\n}\n\nstatic void ipw_handle_data_packet(struct ipw_priv *priv,\n\t\t\t\t   struct ipw_rx_mem_buffer *rxb,\n\t\t\t\t   struct libipw_rx_stats *stats)\n{\n\tstruct net_device *dev = priv->net_dev;\n\tstruct libipw_hdr_4addr *hdr;\n\tstruct ipw_rx_packet *pkt = (struct ipw_rx_packet *)rxb->skb->data;\n\n\t \n\tnetif_trans_update(dev);\n\n\t \n\tif (unlikely((le16_to_cpu(pkt->u.frame.length) + IPW_RX_FRAME_SIZE) >\n\t\t     skb_tailroom(rxb->skb))) {\n\t\tdev->stats.rx_errors++;\n\t\tpriv->wstats.discard.misc++;\n\t\tIPW_DEBUG_DROP(\"Corruption detected! Oh no!\\n\");\n\t\treturn;\n\t} else if (unlikely(!netif_running(priv->net_dev))) {\n\t\tdev->stats.rx_dropped++;\n\t\tpriv->wstats.discard.misc++;\n\t\tIPW_DEBUG_DROP(\"Dropping packet while interface is not up.\\n\");\n\t\treturn;\n\t}\n\n\t \n\tskb_reserve(rxb->skb, offsetof(struct ipw_rx_packet, u.frame.data));\n\n\t \n\tskb_put(rxb->skb, le16_to_cpu(pkt->u.frame.length));\n\n\tIPW_DEBUG_RX(\"Rx packet of %d bytes.\\n\", rxb->skb->len);\n\n\t \n\thdr = (struct libipw_hdr_4addr *)rxb->skb->data;\n\tif (priv->ieee->iw_mode != IW_MODE_MONITOR &&\n\t    (is_multicast_ether_addr(hdr->addr1) ?\n\t     !priv->ieee->host_mc_decrypt : !priv->ieee->host_decrypt))\n\t\tipw_rebuild_decrypted_skb(priv, rxb->skb);\n\n\tif (!libipw_rx(priv->ieee, rxb->skb, stats))\n\t\tdev->stats.rx_errors++;\n\telse {\t\t\t \n\t\trxb->skb = NULL;\n\t\t__ipw_led_activity_on(priv);\n\t}\n}\n\n#ifdef CONFIG_IPW2200_RADIOTAP\nstatic void ipw_handle_data_packet_monitor(struct ipw_priv *priv,\n\t\t\t\t\t   struct ipw_rx_mem_buffer *rxb,\n\t\t\t\t\t   struct libipw_rx_stats *stats)\n{\n\tstruct net_device *dev = priv->net_dev;\n\tstruct ipw_rx_packet *pkt = (struct ipw_rx_packet *)rxb->skb->data;\n\tstruct ipw_rx_frame *frame = &pkt->u.frame;\n\n\t \n\tu16 received_channel = frame->received_channel;\n\tu8 antennaAndPhy = frame->antennaAndPhy;\n\ts8 antsignal = frame->rssi_dbm - IPW_RSSI_TO_DBM;\t \n\tu16 pktrate = frame->rate;\n\n\t \n\tstruct ipw_rt_hdr *ipw_rt;\n\n\tunsigned short len = le16_to_cpu(pkt->u.frame.length);\n\n\t \n\tnetif_trans_update(dev);\n\n\t \n\tif (unlikely((le16_to_cpu(pkt->u.frame.length) + IPW_RX_FRAME_SIZE) >\n\t\t     skb_tailroom(rxb->skb))) {\n\t\tdev->stats.rx_errors++;\n\t\tpriv->wstats.discard.misc++;\n\t\tIPW_DEBUG_DROP(\"Corruption detected! Oh no!\\n\");\n\t\treturn;\n\t} else if (unlikely(!netif_running(priv->net_dev))) {\n\t\tdev->stats.rx_dropped++;\n\t\tpriv->wstats.discard.misc++;\n\t\tIPW_DEBUG_DROP(\"Dropping packet while interface is not up.\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (len > IPW_RX_BUF_SIZE - sizeof(struct ipw_rt_hdr)) {\n\t\t \n\t\tdev->stats.rx_dropped++;\n\t\tpriv->wstats.discard.misc++;\n\t\tIPW_DEBUG_DROP(\"Dropping too large packet in monitor\\n\");\n\t\treturn;\n\t}\n\n\t \n\tmemmove(rxb->skb->data + sizeof(struct ipw_rt_hdr),\n\t\trxb->skb->data + IPW_RX_FRAME_SIZE, len);\n\n\tipw_rt = (struct ipw_rt_hdr *)rxb->skb->data;\n\n\tipw_rt->rt_hdr.it_version = PKTHDR_RADIOTAP_VERSION;\n\tipw_rt->rt_hdr.it_pad = 0;\t \n\tipw_rt->rt_hdr.it_len = cpu_to_le16(sizeof(struct ipw_rt_hdr));\t \n\n\t \n\tipw_rt->rt_hdr.it_present = cpu_to_le32(\n\t     (1 << IEEE80211_RADIOTAP_TSFT) |\n\t     (1 << IEEE80211_RADIOTAP_FLAGS) |\n\t     (1 << IEEE80211_RADIOTAP_RATE) |\n\t     (1 << IEEE80211_RADIOTAP_CHANNEL) |\n\t     (1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL) |\n\t     (1 << IEEE80211_RADIOTAP_DBM_ANTNOISE) |\n\t     (1 << IEEE80211_RADIOTAP_ANTENNA));\n\n\t \n\tipw_rt->rt_flags = 0;\n\tipw_rt->rt_tsf = (u64)(frame->parent_tsf[3] << 24 |\n\t\t\t       frame->parent_tsf[2] << 16 |\n\t\t\t       frame->parent_tsf[1] << 8  |\n\t\t\t       frame->parent_tsf[0]);\n\n\t \n\tipw_rt->rt_dbmsignal = antsignal;\n\tipw_rt->rt_dbmnoise = (s8) le16_to_cpu(frame->noise);\n\n\t \n\tipw_rt->rt_channel = cpu_to_le16(ieee80211chan2mhz(received_channel));\n\tif (received_channel > 14) {\t \n\t\tipw_rt->rt_chbitmask =\n\t\t    cpu_to_le16((IEEE80211_CHAN_OFDM | IEEE80211_CHAN_5GHZ));\n\t} else if (antennaAndPhy & 32) {\t \n\t\tipw_rt->rt_chbitmask =\n\t\t    cpu_to_le16((IEEE80211_CHAN_CCK | IEEE80211_CHAN_2GHZ));\n\t} else {\t\t \n\t\tipw_rt->rt_chbitmask =\n\t\t    cpu_to_le16(IEEE80211_CHAN_OFDM | IEEE80211_CHAN_2GHZ);\n\t}\n\n\t \n\tswitch (pktrate) {\n\tcase IPW_TX_RATE_1MB:\n\t\tipw_rt->rt_rate = 2;\n\t\tbreak;\n\tcase IPW_TX_RATE_2MB:\n\t\tipw_rt->rt_rate = 4;\n\t\tbreak;\n\tcase IPW_TX_RATE_5MB:\n\t\tipw_rt->rt_rate = 10;\n\t\tbreak;\n\tcase IPW_TX_RATE_6MB:\n\t\tipw_rt->rt_rate = 12;\n\t\tbreak;\n\tcase IPW_TX_RATE_9MB:\n\t\tipw_rt->rt_rate = 18;\n\t\tbreak;\n\tcase IPW_TX_RATE_11MB:\n\t\tipw_rt->rt_rate = 22;\n\t\tbreak;\n\tcase IPW_TX_RATE_12MB:\n\t\tipw_rt->rt_rate = 24;\n\t\tbreak;\n\tcase IPW_TX_RATE_18MB:\n\t\tipw_rt->rt_rate = 36;\n\t\tbreak;\n\tcase IPW_TX_RATE_24MB:\n\t\tipw_rt->rt_rate = 48;\n\t\tbreak;\n\tcase IPW_TX_RATE_36MB:\n\t\tipw_rt->rt_rate = 72;\n\t\tbreak;\n\tcase IPW_TX_RATE_48MB:\n\t\tipw_rt->rt_rate = 96;\n\t\tbreak;\n\tcase IPW_TX_RATE_54MB:\n\t\tipw_rt->rt_rate = 108;\n\t\tbreak;\n\tdefault:\n\t\tipw_rt->rt_rate = 0;\n\t\tbreak;\n\t}\n\n\t \n\tipw_rt->rt_antenna = (antennaAndPhy & 3);\t \n\n\t \n\tif ((antennaAndPhy & 64))\n\t\tipw_rt->rt_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;\n\n\t \n\tskb_put(rxb->skb, len + sizeof(struct ipw_rt_hdr));\n\n\tIPW_DEBUG_RX(\"Rx packet of %d bytes.\\n\", rxb->skb->len);\n\n\tif (!libipw_rx(priv->ieee, rxb->skb, stats))\n\t\tdev->stats.rx_errors++;\n\telse {\t\t\t \n\t\trxb->skb = NULL;\n\t\t \n\t}\n}\n#endif\n\n#ifdef CONFIG_IPW2200_PROMISCUOUS\n#define libipw_is_probe_response(fc) \\\n   ((fc & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_MGMT && \\\n    (fc & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_PROBE_RESP )\n\n#define libipw_is_management(fc) \\\n   ((fc & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_MGMT)\n\n#define libipw_is_control(fc) \\\n   ((fc & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_CTL)\n\n#define libipw_is_data(fc) \\\n   ((fc & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_DATA)\n\n#define libipw_is_assoc_request(fc) \\\n   ((fc & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_ASSOC_REQ)\n\n#define libipw_is_reassoc_request(fc) \\\n   ((fc & IEEE80211_FCTL_STYPE) == IEEE80211_STYPE_REASSOC_REQ)\n\nstatic void ipw_handle_promiscuous_rx(struct ipw_priv *priv,\n\t\t\t\t      struct ipw_rx_mem_buffer *rxb,\n\t\t\t\t      struct libipw_rx_stats *stats)\n{\n\tstruct net_device *dev = priv->prom_net_dev;\n\tstruct ipw_rx_packet *pkt = (struct ipw_rx_packet *)rxb->skb->data;\n\tstruct ipw_rx_frame *frame = &pkt->u.frame;\n\tstruct ipw_rt_hdr *ipw_rt;\n\n\t \n\tstruct ieee80211_hdr *hdr;\n\tu16 channel = frame->received_channel;\n\tu8 phy_flags = frame->antennaAndPhy;\n\ts8 signal = frame->rssi_dbm - IPW_RSSI_TO_DBM;\n\ts8 noise = (s8) le16_to_cpu(frame->noise);\n\tu8 rate = frame->rate;\n\tunsigned short len = le16_to_cpu(pkt->u.frame.length);\n\tstruct sk_buff *skb;\n\tint hdr_only = 0;\n\tu16 filter = priv->prom_priv->filter;\n\n\t \n\tif (filter & IPW_PROM_NO_RX)\n\t\treturn;\n\n\t \n\tnetif_trans_update(dev);\n\n\tif (unlikely((len + IPW_RX_FRAME_SIZE) > skb_tailroom(rxb->skb))) {\n\t\tdev->stats.rx_errors++;\n\t\tIPW_DEBUG_DROP(\"Corruption detected! Oh no!\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (unlikely(!netif_running(dev))) {\n\t\tdev->stats.rx_dropped++;\n\t\tIPW_DEBUG_DROP(\"Dropping packet while interface is not up.\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (len > IPW_RX_BUF_SIZE - sizeof(struct ipw_rt_hdr)) {\n\t\t \n\t\tdev->stats.rx_dropped++;\n\t\tIPW_DEBUG_DROP(\"Dropping too large packet in monitor\\n\");\n\t\treturn;\n\t}\n\n\thdr = (void *)rxb->skb->data + IPW_RX_FRAME_SIZE;\n\tif (libipw_is_management(le16_to_cpu(hdr->frame_control))) {\n\t\tif (filter & IPW_PROM_NO_MGMT)\n\t\t\treturn;\n\t\tif (filter & IPW_PROM_MGMT_HEADER_ONLY)\n\t\t\thdr_only = 1;\n\t} else if (libipw_is_control(le16_to_cpu(hdr->frame_control))) {\n\t\tif (filter & IPW_PROM_NO_CTL)\n\t\t\treturn;\n\t\tif (filter & IPW_PROM_CTL_HEADER_ONLY)\n\t\t\thdr_only = 1;\n\t} else if (libipw_is_data(le16_to_cpu(hdr->frame_control))) {\n\t\tif (filter & IPW_PROM_NO_DATA)\n\t\t\treturn;\n\t\tif (filter & IPW_PROM_DATA_HEADER_ONLY)\n\t\t\thdr_only = 1;\n\t}\n\n\t \n\tskb = skb_copy(rxb->skb, GFP_ATOMIC);\n\tif (skb == NULL) {\n\t\tIPW_ERROR(\"skb_clone failed for promiscuous copy.\\n\");\n\t\treturn;\n\t}\n\n\t \n\tipw_rt = (void *)skb->data;\n\n\tif (hdr_only)\n\t\tlen = libipw_get_hdrlen(le16_to_cpu(hdr->frame_control));\n\n\tmemcpy(ipw_rt->payload, hdr, len);\n\n\tipw_rt->rt_hdr.it_version = PKTHDR_RADIOTAP_VERSION;\n\tipw_rt->rt_hdr.it_pad = 0;\t \n\tipw_rt->rt_hdr.it_len = cpu_to_le16(sizeof(*ipw_rt));\t \n\n\t \n\tskb_put(skb, sizeof(*ipw_rt) + len);\n\n\t \n\tipw_rt->rt_hdr.it_present = cpu_to_le32(\n\t     (1 << IEEE80211_RADIOTAP_TSFT) |\n\t     (1 << IEEE80211_RADIOTAP_FLAGS) |\n\t     (1 << IEEE80211_RADIOTAP_RATE) |\n\t     (1 << IEEE80211_RADIOTAP_CHANNEL) |\n\t     (1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL) |\n\t     (1 << IEEE80211_RADIOTAP_DBM_ANTNOISE) |\n\t     (1 << IEEE80211_RADIOTAP_ANTENNA));\n\n\t \n\tipw_rt->rt_flags = 0;\n\tipw_rt->rt_tsf = (u64)(frame->parent_tsf[3] << 24 |\n\t\t\t       frame->parent_tsf[2] << 16 |\n\t\t\t       frame->parent_tsf[1] << 8  |\n\t\t\t       frame->parent_tsf[0]);\n\n\t \n\tipw_rt->rt_dbmsignal = signal;\n\tipw_rt->rt_dbmnoise = noise;\n\n\t \n\tipw_rt->rt_channel = cpu_to_le16(ieee80211chan2mhz(channel));\n\tif (channel > 14) {\t \n\t\tipw_rt->rt_chbitmask =\n\t\t    cpu_to_le16((IEEE80211_CHAN_OFDM | IEEE80211_CHAN_5GHZ));\n\t} else if (phy_flags & (1 << 5)) {\t \n\t\tipw_rt->rt_chbitmask =\n\t\t    cpu_to_le16((IEEE80211_CHAN_CCK | IEEE80211_CHAN_2GHZ));\n\t} else {\t\t \n\t\tipw_rt->rt_chbitmask =\n\t\t    cpu_to_le16(IEEE80211_CHAN_OFDM | IEEE80211_CHAN_2GHZ);\n\t}\n\n\t \n\tswitch (rate) {\n\tcase IPW_TX_RATE_1MB:\n\t\tipw_rt->rt_rate = 2;\n\t\tbreak;\n\tcase IPW_TX_RATE_2MB:\n\t\tipw_rt->rt_rate = 4;\n\t\tbreak;\n\tcase IPW_TX_RATE_5MB:\n\t\tipw_rt->rt_rate = 10;\n\t\tbreak;\n\tcase IPW_TX_RATE_6MB:\n\t\tipw_rt->rt_rate = 12;\n\t\tbreak;\n\tcase IPW_TX_RATE_9MB:\n\t\tipw_rt->rt_rate = 18;\n\t\tbreak;\n\tcase IPW_TX_RATE_11MB:\n\t\tipw_rt->rt_rate = 22;\n\t\tbreak;\n\tcase IPW_TX_RATE_12MB:\n\t\tipw_rt->rt_rate = 24;\n\t\tbreak;\n\tcase IPW_TX_RATE_18MB:\n\t\tipw_rt->rt_rate = 36;\n\t\tbreak;\n\tcase IPW_TX_RATE_24MB:\n\t\tipw_rt->rt_rate = 48;\n\t\tbreak;\n\tcase IPW_TX_RATE_36MB:\n\t\tipw_rt->rt_rate = 72;\n\t\tbreak;\n\tcase IPW_TX_RATE_48MB:\n\t\tipw_rt->rt_rate = 96;\n\t\tbreak;\n\tcase IPW_TX_RATE_54MB:\n\t\tipw_rt->rt_rate = 108;\n\t\tbreak;\n\tdefault:\n\t\tipw_rt->rt_rate = 0;\n\t\tbreak;\n\t}\n\n\t \n\tipw_rt->rt_antenna = (phy_flags & 3);\n\n\t \n\tif (phy_flags & (1 << 6))\n\t\tipw_rt->rt_flags |= IEEE80211_RADIOTAP_F_SHORTPRE;\n\n\tIPW_DEBUG_RX(\"Rx packet of %d bytes.\\n\", skb->len);\n\n\tif (!libipw_rx(priv->prom_priv->ieee, skb, stats)) {\n\t\tdev->stats.rx_errors++;\n\t\tdev_kfree_skb_any(skb);\n\t}\n}\n#endif\n\nstatic int is_network_packet(struct ipw_priv *priv,\n\t\t\t\t    struct libipw_hdr_4addr *header)\n{\n\t \n\tswitch (priv->ieee->iw_mode) {\n\tcase IW_MODE_ADHOC:\t \n\t\t \n\t\tif (ether_addr_equal(header->addr2, priv->net_dev->dev_addr))\n\t\t\treturn 0;\n\n\t\t \n\t\tif (is_multicast_ether_addr(header->addr1))\n\t\t\treturn ether_addr_equal(header->addr3, priv->bssid);\n\n\t\t \n\t\treturn ether_addr_equal(header->addr1,\n\t\t\t\t\tpriv->net_dev->dev_addr);\n\n\tcase IW_MODE_INFRA:\t \n\t\t \n\t\tif (ether_addr_equal(header->addr3, priv->net_dev->dev_addr))\n\t\t\treturn 0;\n\n\t\t \n\t\tif (is_multicast_ether_addr(header->addr1))\n\t\t\treturn ether_addr_equal(header->addr2, priv->bssid);\n\n\t\t \n\t\treturn ether_addr_equal(header->addr1,\n\t\t\t\t\tpriv->net_dev->dev_addr);\n\t}\n\n\treturn 1;\n}\n\n#define IPW_PACKET_RETRY_TIME HZ\n\nstatic  int is_duplicate_packet(struct ipw_priv *priv,\n\t\t\t\t      struct libipw_hdr_4addr *header)\n{\n\tu16 sc = le16_to_cpu(header->seq_ctl);\n\tu16 seq = WLAN_GET_SEQ_SEQ(sc);\n\tu16 frag = WLAN_GET_SEQ_FRAG(sc);\n\tu16 *last_seq, *last_frag;\n\tunsigned long *last_time;\n\n\tswitch (priv->ieee->iw_mode) {\n\tcase IW_MODE_ADHOC:\n\t\t{\n\t\t\tstruct list_head *p;\n\t\t\tstruct ipw_ibss_seq *entry = NULL;\n\t\t\tu8 *mac = header->addr2;\n\t\t\tint index = mac[5] % IPW_IBSS_MAC_HASH_SIZE;\n\n\t\t\tlist_for_each(p, &priv->ibss_mac_hash[index]) {\n\t\t\t\tentry =\n\t\t\t\t    list_entry(p, struct ipw_ibss_seq, list);\n\t\t\t\tif (ether_addr_equal(entry->mac, mac))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p == &priv->ibss_mac_hash[index]) {\n\t\t\t\tentry = kmalloc(sizeof(*entry), GFP_ATOMIC);\n\t\t\t\tif (!entry) {\n\t\t\t\t\tIPW_ERROR\n\t\t\t\t\t    (\"Cannot malloc new mac entry\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tmemcpy(entry->mac, mac, ETH_ALEN);\n\t\t\t\tentry->seq_num = seq;\n\t\t\t\tentry->frag_num = frag;\n\t\t\t\tentry->packet_time = jiffies;\n\t\t\t\tlist_add(&entry->list,\n\t\t\t\t\t &priv->ibss_mac_hash[index]);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tlast_seq = &entry->seq_num;\n\t\t\tlast_frag = &entry->frag_num;\n\t\t\tlast_time = &entry->packet_time;\n\t\t\tbreak;\n\t\t}\n\tcase IW_MODE_INFRA:\n\t\tlast_seq = &priv->last_seq_num;\n\t\tlast_frag = &priv->last_frag_num;\n\t\tlast_time = &priv->last_packet_time;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif ((*last_seq == seq) &&\n\t    time_after(*last_time + IPW_PACKET_RETRY_TIME, jiffies)) {\n\t\tif (*last_frag == frag)\n\t\t\tgoto drop;\n\t\tif (*last_frag + 1 != frag)\n\t\t\t \n\t\t\tgoto drop;\n\t} else\n\t\t*last_seq = seq;\n\n\t*last_frag = frag;\n\t*last_time = jiffies;\n\treturn 0;\n\n      drop:\n\t \n\treturn 1;\n}\n\nstatic void ipw_handle_mgmt_packet(struct ipw_priv *priv,\n\t\t\t\t   struct ipw_rx_mem_buffer *rxb,\n\t\t\t\t   struct libipw_rx_stats *stats)\n{\n\tstruct sk_buff *skb = rxb->skb;\n\tstruct ipw_rx_packet *pkt = (struct ipw_rx_packet *)skb->data;\n\tstruct libipw_hdr_4addr *header = (struct libipw_hdr_4addr *)\n\t    (skb->data + IPW_RX_FRAME_SIZE);\n\n\tlibipw_rx_mgt(priv->ieee, header, stats);\n\n\tif (priv->ieee->iw_mode == IW_MODE_ADHOC &&\n\t    ((WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)) ==\n\t      IEEE80211_STYPE_PROBE_RESP) ||\n\t     (WLAN_FC_GET_STYPE(le16_to_cpu(header->frame_ctl)) ==\n\t      IEEE80211_STYPE_BEACON))) {\n\t\tif (ether_addr_equal(header->addr3, priv->bssid))\n\t\t\tipw_add_station(priv, header->addr2);\n\t}\n\n\tif (priv->config & CFG_NET_STATS) {\n\t\tIPW_DEBUG_HC(\"sending stat packet\\n\");\n\n\t\t \n\t\tskb_put(skb, le16_to_cpu(pkt->u.frame.length) +\n\t\t\tIPW_RX_FRAME_SIZE);\n\n\t\t \n\t\tskb_pull(skb, IPW_RX_FRAME_SIZE);\n\n\t\t \n\t\tmemcpy(skb_push(skb, sizeof(*stats)), stats, sizeof(*stats));\n\n\t\tskb->dev = priv->ieee->dev;\n\n\t\t \n\t\tskb_reset_mac_header(skb);\n\n\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\tskb->protocol = cpu_to_be16(ETH_P_80211_STATS);\n\t\tmemset(skb->cb, 0, sizeof(rxb->skb->cb));\n\t\tnetif_rx(skb);\n\t\trxb->skb = NULL;\n\t}\n}\n\n \nstatic void ipw_rx(struct ipw_priv *priv)\n{\n\tstruct ipw_rx_mem_buffer *rxb;\n\tstruct ipw_rx_packet *pkt;\n\tstruct libipw_hdr_4addr *header;\n\tu32 r, i;\n\tu8 network_packet;\n\tu8 fill_rx = 0;\n\n\tr = ipw_read32(priv, IPW_RX_READ_INDEX);\n\tipw_read32(priv, IPW_RX_WRITE_INDEX);\n\ti = priv->rxq->read;\n\n\tif (ipw_rx_queue_space (priv->rxq) > (RX_QUEUE_SIZE / 2))\n\t\tfill_rx = 1;\n\n\twhile (i != r) {\n\t\trxb = priv->rxq->queue[i];\n\t\tif (unlikely(rxb == NULL)) {\n\t\t\tprintk(KERN_CRIT \"Queue not allocated!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tpriv->rxq->queue[i] = NULL;\n\n\t\tdma_sync_single_for_cpu(&priv->pci_dev->dev, rxb->dma_addr,\n\t\t\t\t\tIPW_RX_BUF_SIZE, DMA_FROM_DEVICE);\n\n\t\tpkt = (struct ipw_rx_packet *)rxb->skb->data;\n\t\tIPW_DEBUG_RX(\"Packet: type=%02X seq=%02X bits=%02X\\n\",\n\t\t\t     pkt->header.message_type,\n\t\t\t     pkt->header.rx_seq_num, pkt->header.control_bits);\n\n\t\tswitch (pkt->header.message_type) {\n\t\tcase RX_FRAME_TYPE:\t   {\n\t\t\t\tstruct libipw_rx_stats stats = {\n\t\t\t\t\t.rssi = pkt->u.frame.rssi_dbm -\n\t\t\t\t\t    IPW_RSSI_TO_DBM,\n\t\t\t\t\t.signal =\n\t\t\t\t\t    pkt->u.frame.rssi_dbm -\n\t\t\t\t\t    IPW_RSSI_TO_DBM + 0x100,\n\t\t\t\t\t.noise =\n\t\t\t\t\t    le16_to_cpu(pkt->u.frame.noise),\n\t\t\t\t\t.rate = pkt->u.frame.rate,\n\t\t\t\t\t.mac_time = jiffies,\n\t\t\t\t\t.received_channel =\n\t\t\t\t\t    pkt->u.frame.received_channel,\n\t\t\t\t\t.freq =\n\t\t\t\t\t    (pkt->u.frame.\n\t\t\t\t\t     control & (1 << 0)) ?\n\t\t\t\t\t    LIBIPW_24GHZ_BAND :\n\t\t\t\t\t    LIBIPW_52GHZ_BAND,\n\t\t\t\t\t.len = le16_to_cpu(pkt->u.frame.length),\n\t\t\t\t};\n\n\t\t\t\tif (stats.rssi != 0)\n\t\t\t\t\tstats.mask |= LIBIPW_STATMASK_RSSI;\n\t\t\t\tif (stats.signal != 0)\n\t\t\t\t\tstats.mask |= LIBIPW_STATMASK_SIGNAL;\n\t\t\t\tif (stats.noise != 0)\n\t\t\t\t\tstats.mask |= LIBIPW_STATMASK_NOISE;\n\t\t\t\tif (stats.rate != 0)\n\t\t\t\t\tstats.mask |= LIBIPW_STATMASK_RATE;\n\n\t\t\t\tpriv->rx_packets++;\n\n#ifdef CONFIG_IPW2200_PROMISCUOUS\n\tif (priv->prom_net_dev && netif_running(priv->prom_net_dev))\n\t\tipw_handle_promiscuous_rx(priv, rxb, &stats);\n#endif\n\n#ifdef CONFIG_IPW2200_MONITOR\n\t\t\t\tif (priv->ieee->iw_mode == IW_MODE_MONITOR) {\n#ifdef CONFIG_IPW2200_RADIOTAP\n\n                ipw_handle_data_packet_monitor(priv,\n\t\t\t\t\t       rxb,\n\t\t\t\t\t       &stats);\n#else\n\t\tipw_handle_data_packet(priv, rxb,\n\t\t\t\t       &stats);\n#endif\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif\n\n\t\t\t\theader =\n\t\t\t\t    (struct libipw_hdr_4addr *)(rxb->skb->\n\t\t\t\t\t\t\t\t   data +\n\t\t\t\t\t\t\t\t   IPW_RX_FRAME_SIZE);\n\t\t\t\t \n\n\t\t\t\tnetwork_packet =\n\t\t\t\t    is_network_packet(priv, header);\n\t\t\t\tif (network_packet && priv->assoc_network) {\n\t\t\t\t\tpriv->assoc_network->stats.rssi =\n\t\t\t\t\t    stats.rssi;\n\t\t\t\t\tpriv->exp_avg_rssi =\n\t\t\t\t\t    exponential_average(priv->exp_avg_rssi,\n\t\t\t\t\t    stats.rssi, DEPTH_RSSI);\n\t\t\t\t}\n\n\t\t\t\tIPW_DEBUG_RX(\"Frame: len=%u\\n\",\n\t\t\t\t\t     le16_to_cpu(pkt->u.frame.length));\n\n\t\t\t\tif (le16_to_cpu(pkt->u.frame.length) <\n\t\t\t\t    libipw_get_hdrlen(le16_to_cpu(\n\t\t\t\t\t\t    header->frame_ctl))) {\n\t\t\t\t\tIPW_DEBUG_DROP\n\t\t\t\t\t    (\"Received packet is too small. \"\n\t\t\t\t\t     \"Dropping.\\n\");\n\t\t\t\t\tpriv->net_dev->stats.rx_errors++;\n\t\t\t\t\tpriv->wstats.discard.misc++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tswitch (WLAN_FC_GET_TYPE\n\t\t\t\t\t(le16_to_cpu(header->frame_ctl))) {\n\n\t\t\t\tcase IEEE80211_FTYPE_MGMT:\n\t\t\t\t\tipw_handle_mgmt_packet(priv, rxb,\n\t\t\t\t\t\t\t       &stats);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase IEEE80211_FTYPE_CTL:\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase IEEE80211_FTYPE_DATA:\n\t\t\t\t\tif (unlikely(!network_packet ||\n\t\t\t\t\t\t     is_duplicate_packet(priv,\n\t\t\t\t\t\t\t\t\t header)))\n\t\t\t\t\t{\n\t\t\t\t\t\tIPW_DEBUG_DROP(\"Dropping: \"\n\t\t\t\t\t\t\t       \"%pM, \"\n\t\t\t\t\t\t\t       \"%pM, \"\n\t\t\t\t\t\t\t       \"%pM\\n\",\n\t\t\t\t\t\t\t       header->addr1,\n\t\t\t\t\t\t\t       header->addr2,\n\t\t\t\t\t\t\t       header->addr3);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tipw_handle_data_packet(priv, rxb,\n\t\t\t\t\t\t\t       &stats);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase RX_HOST_NOTIFICATION_TYPE:{\n\t\t\t\tIPW_DEBUG_RX\n\t\t\t\t    (\"Notification: subtype=%02X flags=%02X size=%d\\n\",\n\t\t\t\t     pkt->u.notification.subtype,\n\t\t\t\t     pkt->u.notification.flags,\n\t\t\t\t     le16_to_cpu(pkt->u.notification.size));\n\t\t\t\tipw_rx_notification(priv, &pkt->u.notification);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tdefault:\n\t\t\tIPW_DEBUG_RX(\"Bad Rx packet of type %d\\n\",\n\t\t\t\t     pkt->header.message_type);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (rxb->skb != NULL) {\n\t\t\tdev_kfree_skb_any(rxb->skb);\n\t\t\trxb->skb = NULL;\n\t\t}\n\n\t\tdma_unmap_single(&priv->pci_dev->dev, rxb->dma_addr,\n\t\t\t\t IPW_RX_BUF_SIZE, DMA_FROM_DEVICE);\n\t\tlist_add_tail(&rxb->list, &priv->rxq->rx_used);\n\n\t\ti = (i + 1) % RX_QUEUE_SIZE;\n\n\t\t \n\t\tif (fill_rx) {\n\t\t\tpriv->rxq->read = i;\n\t\t\tipw_rx_queue_replenish(priv);\n\t\t}\n\t}\n\n\t \n\tpriv->rxq->read = i;\n\tipw_rx_queue_restock(priv);\n}\n\n#define DEFAULT_RTS_THRESHOLD     2304U\n#define MIN_RTS_THRESHOLD         1U\n#define MAX_RTS_THRESHOLD         2304U\n#define DEFAULT_BEACON_INTERVAL   100U\n#define\tDEFAULT_SHORT_RETRY_LIMIT 7U\n#define\tDEFAULT_LONG_RETRY_LIMIT  4U\n\n \nstatic int ipw_sw_reset(struct ipw_priv *priv, int option)\n{\n\tint band, modulation;\n\tint old_mode = priv->ieee->iw_mode;\n\n\t \n\tpriv->config = 0;\n\n\t \n\tif (!led_support)\n\t\tpriv->config |= CFG_NO_LED;\n\n\tif (associate)\n\t\tpriv->config |= CFG_ASSOCIATE;\n\telse\n\t\tIPW_DEBUG_INFO(\"Auto associate disabled.\\n\");\n\n\tif (auto_create)\n\t\tpriv->config |= CFG_ADHOC_CREATE;\n\telse\n\t\tIPW_DEBUG_INFO(\"Auto adhoc creation disabled.\\n\");\n\n\tpriv->config &= ~CFG_STATIC_ESSID;\n\tpriv->essid_len = 0;\n\tmemset(priv->essid, 0, IW_ESSID_MAX_SIZE);\n\n\tif (disable && option) {\n\t\tpriv->status |= STATUS_RF_KILL_SW;\n\t\tIPW_DEBUG_INFO(\"Radio disabled.\\n\");\n\t}\n\n\tif (default_channel != 0) {\n\t\tpriv->config |= CFG_STATIC_CHANNEL;\n\t\tpriv->channel = default_channel;\n\t\tIPW_DEBUG_INFO(\"Bind to static channel %d\\n\", default_channel);\n\t\t \n\t}\n#ifdef CONFIG_IPW2200_QOS\n\tipw_qos_init(priv, qos_enable, qos_burst_enable,\n\t\t     burst_duration_CCK, burst_duration_OFDM);\n#endif\t\t\t\t \n\n\tswitch (network_mode) {\n\tcase 1:\n\t\tpriv->ieee->iw_mode = IW_MODE_ADHOC;\n\t\tpriv->net_dev->type = ARPHRD_ETHER;\n\n\t\tbreak;\n#ifdef CONFIG_IPW2200_MONITOR\n\tcase 2:\n\t\tpriv->ieee->iw_mode = IW_MODE_MONITOR;\n#ifdef CONFIG_IPW2200_RADIOTAP\n\t\tpriv->net_dev->type = ARPHRD_IEEE80211_RADIOTAP;\n#else\n\t\tpriv->net_dev->type = ARPHRD_IEEE80211;\n#endif\n\t\tbreak;\n#endif\n\tdefault:\n\tcase 0:\n\t\tpriv->net_dev->type = ARPHRD_ETHER;\n\t\tpriv->ieee->iw_mode = IW_MODE_INFRA;\n\t\tbreak;\n\t}\n\n\tif (hwcrypto) {\n\t\tpriv->ieee->host_encrypt = 0;\n\t\tpriv->ieee->host_encrypt_msdu = 0;\n\t\tpriv->ieee->host_decrypt = 0;\n\t\tpriv->ieee->host_mc_decrypt = 0;\n\t}\n\tIPW_DEBUG_INFO(\"Hardware crypto [%s]\\n\", hwcrypto ? \"on\" : \"off\");\n\n\t \n\tpriv->ieee->host_open_frag = 0;\n\n\tif ((priv->pci_dev->device == 0x4223) ||\n\t    (priv->pci_dev->device == 0x4224)) {\n\t\tif (option == 1)\n\t\t\tprintk(KERN_INFO DRV_NAME\n\t\t\t       \": Detected Intel PRO/Wireless 2915ABG Network \"\n\t\t\t       \"Connection\\n\");\n\t\tpriv->ieee->abg_true = 1;\n\t\tband = LIBIPW_52GHZ_BAND | LIBIPW_24GHZ_BAND;\n\t\tmodulation = LIBIPW_OFDM_MODULATION |\n\t\t    LIBIPW_CCK_MODULATION;\n\t\tpriv->adapter = IPW_2915ABG;\n\t\tpriv->ieee->mode = IEEE_A | IEEE_G | IEEE_B;\n\t} else {\n\t\tif (option == 1)\n\t\t\tprintk(KERN_INFO DRV_NAME\n\t\t\t       \": Detected Intel PRO/Wireless 2200BG Network \"\n\t\t\t       \"Connection\\n\");\n\n\t\tpriv->ieee->abg_true = 0;\n\t\tband = LIBIPW_24GHZ_BAND;\n\t\tmodulation = LIBIPW_OFDM_MODULATION |\n\t\t    LIBIPW_CCK_MODULATION;\n\t\tpriv->adapter = IPW_2200BG;\n\t\tpriv->ieee->mode = IEEE_G | IEEE_B;\n\t}\n\n\tpriv->ieee->freq_band = band;\n\tpriv->ieee->modulation = modulation;\n\n\tpriv->rates_mask = LIBIPW_DEFAULT_RATES_MASK;\n\n\tpriv->disassociate_threshold = IPW_MB_DISASSOCIATE_THRESHOLD_DEFAULT;\n\tpriv->roaming_threshold = IPW_MB_ROAMING_THRESHOLD_DEFAULT;\n\n\tpriv->rts_threshold = DEFAULT_RTS_THRESHOLD;\n\tpriv->short_retry_limit = DEFAULT_SHORT_RETRY_LIMIT;\n\tpriv->long_retry_limit = DEFAULT_LONG_RETRY_LIMIT;\n\n\t \n\tpriv->power_mode = IPW_POWER_AC;\n\tpriv->tx_power = IPW_TX_POWER_DEFAULT;\n\n\treturn old_mode == priv->ieee->iw_mode;\n}\n\n \n\nstatic int ipw_set_channel(struct ipw_priv *priv, u8 channel)\n{\n\tif (channel == 0) {\n\t\tIPW_DEBUG_INFO(\"Setting channel to ANY (0)\\n\");\n\t\tpriv->config &= ~CFG_STATIC_CHANNEL;\n\t\tIPW_DEBUG_ASSOC(\"Attempting to associate with new \"\n\t\t\t\t\"parameters.\\n\");\n\t\tipw_associate(priv);\n\t\treturn 0;\n\t}\n\n\tpriv->config |= CFG_STATIC_CHANNEL;\n\n\tif (priv->channel == channel) {\n\t\tIPW_DEBUG_INFO(\"Request to set channel to current value (%d)\\n\",\n\t\t\t       channel);\n\t\treturn 0;\n\t}\n\n\tIPW_DEBUG_INFO(\"Setting channel to %i\\n\", (int)channel);\n\tpriv->channel = channel;\n\n#ifdef CONFIG_IPW2200_MONITOR\n\tif (priv->ieee->iw_mode == IW_MODE_MONITOR) {\n\t\tint i;\n\t\tif (priv->status & STATUS_SCANNING) {\n\t\t\tIPW_DEBUG_SCAN(\"Scan abort triggered due to \"\n\t\t\t\t       \"channel change.\\n\");\n\t\t\tipw_abort_scan(priv);\n\t\t}\n\n\t\tfor (i = 1000; i && (priv->status & STATUS_SCANNING); i--)\n\t\t\tudelay(10);\n\n\t\tif (priv->status & STATUS_SCANNING)\n\t\t\tIPW_DEBUG_SCAN(\"Still scanning...\\n\");\n\t\telse\n\t\t\tIPW_DEBUG_SCAN(\"Took %dms to abort current scan\\n\",\n\t\t\t\t       1000 - i);\n\n\t\treturn 0;\n\t}\n#endif\t\t\t\t \n\n\t \n\tIPW_DEBUG_ASSOC(\"[re]association triggered due to channel change.\\n\");\n\tif (!ipw_disassociate(priv))\n\t\tipw_associate(priv);\n\n\treturn 0;\n}\n\nstatic int ipw_wx_set_freq(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tconst struct libipw_geo *geo = libipw_get_geo(priv->ieee);\n\tstruct iw_freq *fwrq = &wrqu->freq;\n\tint ret = 0, i;\n\tu8 channel, flags;\n\tint band;\n\n\tif (fwrq->m == 0) {\n\t\tIPW_DEBUG_WX(\"SET Freq/Channel -> any\\n\");\n\t\tmutex_lock(&priv->mutex);\n\t\tret = ipw_set_channel(priv, 0);\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn ret;\n\t}\n\t \n\tif (fwrq->e == 1) {\n\t\tchannel = libipw_freq_to_channel(priv->ieee, fwrq->m);\n\t\tif (channel == 0)\n\t\t\treturn -EINVAL;\n\t} else\n\t\tchannel = fwrq->m;\n\n\tif (!(band = libipw_is_valid_channel(priv->ieee, channel)))\n\t\treturn -EINVAL;\n\n\tif (priv->ieee->iw_mode == IW_MODE_ADHOC) {\n\t\ti = libipw_channel_to_index(priv->ieee, channel);\n\t\tif (i == -1)\n\t\t\treturn -EINVAL;\n\n\t\tflags = (band == LIBIPW_24GHZ_BAND) ?\n\t\t    geo->bg[i].flags : geo->a[i].flags;\n\t\tif (flags & LIBIPW_CH_PASSIVE_ONLY) {\n\t\t\tIPW_DEBUG_WX(\"Invalid Ad-Hoc channel for 802.11a\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tIPW_DEBUG_WX(\"SET Freq/Channel -> %d\\n\", fwrq->m);\n\tmutex_lock(&priv->mutex);\n\tret = ipw_set_channel(priv, channel);\n\tmutex_unlock(&priv->mutex);\n\treturn ret;\n}\n\nstatic int ipw_wx_get_freq(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\n\twrqu->freq.e = 0;\n\n\t \n\tmutex_lock(&priv->mutex);\n\tif (priv->config & CFG_STATIC_CHANNEL ||\n\t    priv->status & (STATUS_ASSOCIATING | STATUS_ASSOCIATED)) {\n\t\tint i;\n\n\t\ti = libipw_channel_to_index(priv->ieee, priv->channel);\n\t\tBUG_ON(i == -1);\n\t\twrqu->freq.e = 1;\n\n\t\tswitch (libipw_is_valid_channel(priv->ieee, priv->channel)) {\n\t\tcase LIBIPW_52GHZ_BAND:\n\t\t\twrqu->freq.m = priv->ieee->geo.a[i].freq * 100000;\n\t\t\tbreak;\n\n\t\tcase LIBIPW_24GHZ_BAND:\n\t\t\twrqu->freq.m = priv->ieee->geo.bg[i].freq * 100000;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t} else\n\t\twrqu->freq.m = 0;\n\n\tmutex_unlock(&priv->mutex);\n\tIPW_DEBUG_WX(\"GET Freq/Channel -> %d\\n\", priv->channel);\n\treturn 0;\n}\n\nstatic int ipw_wx_set_mode(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tint err = 0;\n\n\tIPW_DEBUG_WX(\"Set MODE: %d\\n\", wrqu->mode);\n\n\tswitch (wrqu->mode) {\n#ifdef CONFIG_IPW2200_MONITOR\n\tcase IW_MODE_MONITOR:\n#endif\n\tcase IW_MODE_ADHOC:\n\tcase IW_MODE_INFRA:\n\t\tbreak;\n\tcase IW_MODE_AUTO:\n\t\twrqu->mode = IW_MODE_INFRA;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (wrqu->mode == priv->ieee->iw_mode)\n\t\treturn 0;\n\n\tmutex_lock(&priv->mutex);\n\n\tipw_sw_reset(priv, 0);\n\n#ifdef CONFIG_IPW2200_MONITOR\n\tif (priv->ieee->iw_mode == IW_MODE_MONITOR)\n\t\tpriv->net_dev->type = ARPHRD_ETHER;\n\n\tif (wrqu->mode == IW_MODE_MONITOR)\n#ifdef CONFIG_IPW2200_RADIOTAP\n\t\tpriv->net_dev->type = ARPHRD_IEEE80211_RADIOTAP;\n#else\n\t\tpriv->net_dev->type = ARPHRD_IEEE80211;\n#endif\n#endif\t\t\t\t \n\n\t \n\tfree_firmware();\n\n\tpriv->ieee->iw_mode = wrqu->mode;\n\n\tschedule_work(&priv->adapter_restart);\n\tmutex_unlock(&priv->mutex);\n\treturn err;\n}\n\nstatic int ipw_wx_get_mode(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tmutex_lock(&priv->mutex);\n\twrqu->mode = priv->ieee->iw_mode;\n\tIPW_DEBUG_WX(\"Get MODE -> %d\\n\", wrqu->mode);\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\n \nstatic const s32 timeout_duration[] = {\n\t350000,\n\t250000,\n\t75000,\n\t37000,\n\t25000,\n};\n\nstatic const s32 period_duration[] = {\n\t400000,\n\t700000,\n\t1000000,\n\t1000000,\n\t1000000\n};\n\nstatic int ipw_wx_get_range(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tstruct iw_range *range = (struct iw_range *)extra;\n\tconst struct libipw_geo *geo = libipw_get_geo(priv->ieee);\n\tint i = 0, j;\n\n\twrqu->data.length = sizeof(*range);\n\tmemset(range, 0, sizeof(*range));\n\n\t \n\trange->throughput = 27 * 1000 * 1000;\n\n\trange->max_qual.qual = 100;\n\t \n\trange->max_qual.level = 0;\n\trange->max_qual.noise = 0;\n\trange->max_qual.updated = 7;\t \n\n\trange->avg_qual.qual = 70;\n\t \n\trange->avg_qual.level = 0;\t \n\trange->avg_qual.noise = 0;\n\trange->avg_qual.updated = 7;\t \n\tmutex_lock(&priv->mutex);\n\trange->num_bitrates = min(priv->rates.num_rates, (u8) IW_MAX_BITRATES);\n\n\tfor (i = 0; i < range->num_bitrates; i++)\n\t\trange->bitrate[i] = (priv->rates.supported_rates[i] & 0x7F) *\n\t\t    500000;\n\n\trange->max_rts = DEFAULT_RTS_THRESHOLD;\n\trange->min_frag = MIN_FRAG_THRESHOLD;\n\trange->max_frag = MAX_FRAG_THRESHOLD;\n\n\trange->encoding_size[0] = 5;\n\trange->encoding_size[1] = 13;\n\trange->num_encoding_sizes = 2;\n\trange->max_encoding_tokens = WEP_KEYS;\n\n\t \n\trange->we_version_compiled = WIRELESS_EXT;\n\trange->we_version_source = 18;\n\n\ti = 0;\n\tif (priv->ieee->mode & (IEEE_B | IEEE_G)) {\n\t\tfor (j = 0; j < geo->bg_channels && i < IW_MAX_FREQUENCIES; j++) {\n\t\t\tif ((priv->ieee->iw_mode == IW_MODE_ADHOC) &&\n\t\t\t    (geo->bg[j].flags & LIBIPW_CH_PASSIVE_ONLY))\n\t\t\t\tcontinue;\n\n\t\t\trange->freq[i].i = geo->bg[j].channel;\n\t\t\trange->freq[i].m = geo->bg[j].freq * 100000;\n\t\t\trange->freq[i].e = 1;\n\t\t\ti++;\n\t\t}\n\t}\n\n\tif (priv->ieee->mode & IEEE_A) {\n\t\tfor (j = 0; j < geo->a_channels && i < IW_MAX_FREQUENCIES; j++) {\n\t\t\tif ((priv->ieee->iw_mode == IW_MODE_ADHOC) &&\n\t\t\t    (geo->a[j].flags & LIBIPW_CH_PASSIVE_ONLY))\n\t\t\t\tcontinue;\n\n\t\t\trange->freq[i].i = geo->a[j].channel;\n\t\t\trange->freq[i].m = geo->a[j].freq * 100000;\n\t\t\trange->freq[i].e = 1;\n\t\t\ti++;\n\t\t}\n\t}\n\n\trange->num_channels = i;\n\trange->num_frequency = i;\n\n\tmutex_unlock(&priv->mutex);\n\n\t \n\trange->event_capa[0] = (IW_EVENT_CAPA_K_0 |\n\t\t\t\tIW_EVENT_CAPA_MASK(SIOCGIWTHRSPY) |\n\t\t\t\tIW_EVENT_CAPA_MASK(SIOCGIWAP) |\n\t\t\t\tIW_EVENT_CAPA_MASK(SIOCGIWSCAN));\n\trange->event_capa[1] = IW_EVENT_CAPA_K_1;\n\n\trange->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 |\n\t\tIW_ENC_CAPA_CIPHER_TKIP | IW_ENC_CAPA_CIPHER_CCMP;\n\n\trange->scan_capa = IW_SCAN_CAPA_ESSID | IW_SCAN_CAPA_TYPE;\n\n\tIPW_DEBUG_WX(\"GET Range\\n\");\n\treturn 0;\n}\n\nstatic int ipw_wx_set_wap(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\n\tif (wrqu->ap_addr.sa_family != ARPHRD_ETHER)\n\t\treturn -EINVAL;\n\tmutex_lock(&priv->mutex);\n\tif (is_broadcast_ether_addr(wrqu->ap_addr.sa_data) ||\n\t    is_zero_ether_addr(wrqu->ap_addr.sa_data)) {\n\t\t \n\t\tIPW_DEBUG_WX(\"Setting AP BSSID to ANY\\n\");\n\t\tpriv->config &= ~CFG_STATIC_BSSID;\n\t\tIPW_DEBUG_ASSOC(\"Attempting to associate with new \"\n\t\t\t\t\"parameters.\\n\");\n\t\tipw_associate(priv);\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn 0;\n\t}\n\n\tpriv->config |= CFG_STATIC_BSSID;\n\tif (ether_addr_equal(priv->bssid, wrqu->ap_addr.sa_data)) {\n\t\tIPW_DEBUG_WX(\"BSSID set to current BSSID.\\n\");\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn 0;\n\t}\n\n\tIPW_DEBUG_WX(\"Setting mandatory BSSID to %pM\\n\",\n\t\t     wrqu->ap_addr.sa_data);\n\n\tmemcpy(priv->bssid, wrqu->ap_addr.sa_data, ETH_ALEN);\n\n\t \n\tIPW_DEBUG_ASSOC(\"[re]association triggered due to BSSID change.\\n\");\n\tif (!ipw_disassociate(priv))\n\t\tipw_associate(priv);\n\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\nstatic int ipw_wx_get_wap(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\n\t \n\tmutex_lock(&priv->mutex);\n\tif (priv->config & CFG_STATIC_BSSID ||\n\t    priv->status & (STATUS_ASSOCIATED | STATUS_ASSOCIATING)) {\n\t\twrqu->ap_addr.sa_family = ARPHRD_ETHER;\n\t\tmemcpy(wrqu->ap_addr.sa_data, priv->bssid, ETH_ALEN);\n\t} else\n\t\teth_zero_addr(wrqu->ap_addr.sa_data);\n\n\tIPW_DEBUG_WX(\"Getting WAP BSSID: %pM\\n\",\n\t\t     wrqu->ap_addr.sa_data);\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\nstatic int ipw_wx_set_essid(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n        int length;\n\n        mutex_lock(&priv->mutex);\n\n        if (!wrqu->essid.flags)\n        {\n                IPW_DEBUG_WX(\"Setting ESSID to ANY\\n\");\n                ipw_disassociate(priv);\n                priv->config &= ~CFG_STATIC_ESSID;\n                ipw_associate(priv);\n                mutex_unlock(&priv->mutex);\n                return 0;\n        }\n\n\tlength = min((int)wrqu->essid.length, IW_ESSID_MAX_SIZE);\n\n\tpriv->config |= CFG_STATIC_ESSID;\n\n\tif (priv->essid_len == length && !memcmp(priv->essid, extra, length)\n\t    && (priv->status & (STATUS_ASSOCIATED | STATUS_ASSOCIATING))) {\n\t\tIPW_DEBUG_WX(\"ESSID set to current ESSID.\\n\");\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn 0;\n\t}\n\n\tIPW_DEBUG_WX(\"Setting ESSID: '%*pE' (%d)\\n\", length, extra, length);\n\n\tpriv->essid_len = length;\n\tmemcpy(priv->essid, extra, priv->essid_len);\n\n\t \n\tIPW_DEBUG_ASSOC(\"[re]association triggered due to ESSID change.\\n\");\n\tif (!ipw_disassociate(priv))\n\t\tipw_associate(priv);\n\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\nstatic int ipw_wx_get_essid(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\n\t \n\tmutex_lock(&priv->mutex);\n\tif (priv->config & CFG_STATIC_ESSID ||\n\t    priv->status & (STATUS_ASSOCIATED | STATUS_ASSOCIATING)) {\n\t\tIPW_DEBUG_WX(\"Getting essid: '%*pE'\\n\",\n\t\t\t     priv->essid_len, priv->essid);\n\t\tmemcpy(extra, priv->essid, priv->essid_len);\n\t\twrqu->essid.length = priv->essid_len;\n\t\twrqu->essid.flags = 1;\t \n\t} else {\n\t\tIPW_DEBUG_WX(\"Getting essid: ANY\\n\");\n\t\twrqu->essid.length = 0;\n\t\twrqu->essid.flags = 0;\t \n\t}\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\nstatic int ipw_wx_set_nick(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\n\tIPW_DEBUG_WX(\"Setting nick to '%s'\\n\", extra);\n\tif (wrqu->data.length > IW_ESSID_MAX_SIZE)\n\t\treturn -E2BIG;\n\tmutex_lock(&priv->mutex);\n\twrqu->data.length = min_t(size_t, wrqu->data.length, sizeof(priv->nick));\n\tmemset(priv->nick, 0, sizeof(priv->nick));\n\tmemcpy(priv->nick, extra, wrqu->data.length);\n\tIPW_DEBUG_TRACE(\"<<\\n\");\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n\n}\n\nstatic int ipw_wx_get_nick(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tIPW_DEBUG_WX(\"Getting nick\\n\");\n\tmutex_lock(&priv->mutex);\n\twrqu->data.length = strlen(priv->nick);\n\tmemcpy(extra, priv->nick, wrqu->data.length);\n\twrqu->data.flags = 1;\t \n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\nstatic int ipw_wx_set_sens(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tint err = 0;\n\n\tIPW_DEBUG_WX(\"Setting roaming threshold to %d\\n\", wrqu->sens.value);\n\tIPW_DEBUG_WX(\"Setting disassociate threshold to %d\\n\", 3*wrqu->sens.value);\n\tmutex_lock(&priv->mutex);\n\n\tif (wrqu->sens.fixed == 0)\n\t{\n\t\tpriv->roaming_threshold = IPW_MB_ROAMING_THRESHOLD_DEFAULT;\n\t\tpriv->disassociate_threshold = IPW_MB_DISASSOCIATE_THRESHOLD_DEFAULT;\n\t\tgoto out;\n\t}\n\tif ((wrqu->sens.value > IPW_MB_ROAMING_THRESHOLD_MAX) ||\n\t    (wrqu->sens.value < IPW_MB_ROAMING_THRESHOLD_MIN)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpriv->roaming_threshold = wrqu->sens.value;\n\tpriv->disassociate_threshold = 3*wrqu->sens.value;\n      out:\n\tmutex_unlock(&priv->mutex);\n\treturn err;\n}\n\nstatic int ipw_wx_get_sens(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tmutex_lock(&priv->mutex);\n\twrqu->sens.fixed = 1;\n\twrqu->sens.value = priv->roaming_threshold;\n\tmutex_unlock(&priv->mutex);\n\n\tIPW_DEBUG_WX(\"GET roaming threshold -> %s %d\\n\",\n\t\t     wrqu->power.disabled ? \"OFF\" : \"ON\", wrqu->power.value);\n\n\treturn 0;\n}\n\nstatic int ipw_wx_set_rate(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\t \n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tu32 target_rate = wrqu->bitrate.value;\n\tu32 fixed, mask;\n\n\t \n\t \n\t \n\n\tif (target_rate == -1) {\n\t\tfixed = 0;\n\t\tmask = LIBIPW_DEFAULT_RATES_MASK;\n\t\t \n\t\tgoto apply;\n\t}\n\n\tmask = 0;\n\tfixed = wrqu->bitrate.fixed;\n\n\tif (target_rate == 1000000 || !fixed)\n\t\tmask |= LIBIPW_CCK_RATE_1MB_MASK;\n\tif (target_rate == 1000000)\n\t\tgoto apply;\n\n\tif (target_rate == 2000000 || !fixed)\n\t\tmask |= LIBIPW_CCK_RATE_2MB_MASK;\n\tif (target_rate == 2000000)\n\t\tgoto apply;\n\n\tif (target_rate == 5500000 || !fixed)\n\t\tmask |= LIBIPW_CCK_RATE_5MB_MASK;\n\tif (target_rate == 5500000)\n\t\tgoto apply;\n\n\tif (target_rate == 6000000 || !fixed)\n\t\tmask |= LIBIPW_OFDM_RATE_6MB_MASK;\n\tif (target_rate == 6000000)\n\t\tgoto apply;\n\n\tif (target_rate == 9000000 || !fixed)\n\t\tmask |= LIBIPW_OFDM_RATE_9MB_MASK;\n\tif (target_rate == 9000000)\n\t\tgoto apply;\n\n\tif (target_rate == 11000000 || !fixed)\n\t\tmask |= LIBIPW_CCK_RATE_11MB_MASK;\n\tif (target_rate == 11000000)\n\t\tgoto apply;\n\n\tif (target_rate == 12000000 || !fixed)\n\t\tmask |= LIBIPW_OFDM_RATE_12MB_MASK;\n\tif (target_rate == 12000000)\n\t\tgoto apply;\n\n\tif (target_rate == 18000000 || !fixed)\n\t\tmask |= LIBIPW_OFDM_RATE_18MB_MASK;\n\tif (target_rate == 18000000)\n\t\tgoto apply;\n\n\tif (target_rate == 24000000 || !fixed)\n\t\tmask |= LIBIPW_OFDM_RATE_24MB_MASK;\n\tif (target_rate == 24000000)\n\t\tgoto apply;\n\n\tif (target_rate == 36000000 || !fixed)\n\t\tmask |= LIBIPW_OFDM_RATE_36MB_MASK;\n\tif (target_rate == 36000000)\n\t\tgoto apply;\n\n\tif (target_rate == 48000000 || !fixed)\n\t\tmask |= LIBIPW_OFDM_RATE_48MB_MASK;\n\tif (target_rate == 48000000)\n\t\tgoto apply;\n\n\tif (target_rate == 54000000 || !fixed)\n\t\tmask |= LIBIPW_OFDM_RATE_54MB_MASK;\n\tif (target_rate == 54000000)\n\t\tgoto apply;\n\n\tIPW_DEBUG_WX(\"invalid rate specified, returning error\\n\");\n\treturn -EINVAL;\n\n      apply:\n\tIPW_DEBUG_WX(\"Setting rate mask to 0x%08X [%s]\\n\",\n\t\t     mask, fixed ? \"fixed\" : \"sub-rates\");\n\tmutex_lock(&priv->mutex);\n\tif (mask == LIBIPW_DEFAULT_RATES_MASK) {\n\t\tpriv->config &= ~CFG_FIXED_RATE;\n\t\tipw_set_fixed_rate(priv, priv->ieee->mode);\n\t} else\n\t\tpriv->config |= CFG_FIXED_RATE;\n\n\tif (priv->rates_mask == mask) {\n\t\tIPW_DEBUG_WX(\"Mask set to current mask.\\n\");\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn 0;\n\t}\n\n\tpriv->rates_mask = mask;\n\n\t \n\tIPW_DEBUG_ASSOC(\"[re]association triggered due to rates change.\\n\");\n\tif (!ipw_disassociate(priv))\n\t\tipw_associate(priv);\n\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\nstatic int ipw_wx_get_rate(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tmutex_lock(&priv->mutex);\n\twrqu->bitrate.value = priv->last_rate;\n\twrqu->bitrate.fixed = (priv->config & CFG_FIXED_RATE) ? 1 : 0;\n\tmutex_unlock(&priv->mutex);\n\tIPW_DEBUG_WX(\"GET Rate -> %d\\n\", wrqu->bitrate.value);\n\treturn 0;\n}\n\nstatic int ipw_wx_set_rts(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tmutex_lock(&priv->mutex);\n\tif (wrqu->rts.disabled || !wrqu->rts.fixed)\n\t\tpriv->rts_threshold = DEFAULT_RTS_THRESHOLD;\n\telse {\n\t\tif (wrqu->rts.value < MIN_RTS_THRESHOLD ||\n\t\t    wrqu->rts.value > MAX_RTS_THRESHOLD) {\n\t\t\tmutex_unlock(&priv->mutex);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpriv->rts_threshold = wrqu->rts.value;\n\t}\n\n\tipw_send_rts_threshold(priv, priv->rts_threshold);\n\tmutex_unlock(&priv->mutex);\n\tIPW_DEBUG_WX(\"SET RTS Threshold -> %d\\n\", priv->rts_threshold);\n\treturn 0;\n}\n\nstatic int ipw_wx_get_rts(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tmutex_lock(&priv->mutex);\n\twrqu->rts.value = priv->rts_threshold;\n\twrqu->rts.fixed = 0;\t \n\twrqu->rts.disabled = (wrqu->rts.value == DEFAULT_RTS_THRESHOLD);\n\tmutex_unlock(&priv->mutex);\n\tIPW_DEBUG_WX(\"GET RTS Threshold -> %d\\n\", wrqu->rts.value);\n\treturn 0;\n}\n\nstatic int ipw_wx_set_txpow(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tint err = 0;\n\n\tmutex_lock(&priv->mutex);\n\tif (ipw_radio_kill_sw(priv, wrqu->power.disabled)) {\n\t\terr = -EINPROGRESS;\n\t\tgoto out;\n\t}\n\n\tif (!wrqu->power.fixed)\n\t\twrqu->power.value = IPW_TX_POWER_DEFAULT;\n\n\tif (wrqu->power.flags != IW_TXPOW_DBM) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif ((wrqu->power.value > IPW_TX_POWER_MAX) ||\n\t    (wrqu->power.value < IPW_TX_POWER_MIN)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpriv->tx_power = wrqu->power.value;\n\terr = ipw_set_tx_power(priv);\n      out:\n\tmutex_unlock(&priv->mutex);\n\treturn err;\n}\n\nstatic int ipw_wx_get_txpow(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tmutex_lock(&priv->mutex);\n\twrqu->power.value = priv->tx_power;\n\twrqu->power.fixed = 1;\n\twrqu->power.flags = IW_TXPOW_DBM;\n\twrqu->power.disabled = (priv->status & STATUS_RF_KILL_MASK) ? 1 : 0;\n\tmutex_unlock(&priv->mutex);\n\n\tIPW_DEBUG_WX(\"GET TX Power -> %s %d\\n\",\n\t\t     wrqu->power.disabled ? \"OFF\" : \"ON\", wrqu->power.value);\n\n\treturn 0;\n}\n\nstatic int ipw_wx_set_frag(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tmutex_lock(&priv->mutex);\n\tif (wrqu->frag.disabled || !wrqu->frag.fixed)\n\t\tpriv->ieee->fts = DEFAULT_FTS;\n\telse {\n\t\tif (wrqu->frag.value < MIN_FRAG_THRESHOLD ||\n\t\t    wrqu->frag.value > MAX_FRAG_THRESHOLD) {\n\t\t\tmutex_unlock(&priv->mutex);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpriv->ieee->fts = wrqu->frag.value & ~0x1;\n\t}\n\n\tipw_send_frag_threshold(priv, wrqu->frag.value);\n\tmutex_unlock(&priv->mutex);\n\tIPW_DEBUG_WX(\"SET Frag Threshold -> %d\\n\", wrqu->frag.value);\n\treturn 0;\n}\n\nstatic int ipw_wx_get_frag(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tmutex_lock(&priv->mutex);\n\twrqu->frag.value = priv->ieee->fts;\n\twrqu->frag.fixed = 0;\t \n\twrqu->frag.disabled = (wrqu->frag.value == DEFAULT_FTS);\n\tmutex_unlock(&priv->mutex);\n\tIPW_DEBUG_WX(\"GET Frag Threshold -> %d\\n\", wrqu->frag.value);\n\n\treturn 0;\n}\n\nstatic int ipw_wx_set_retry(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\n\tif (wrqu->retry.flags & IW_RETRY_LIFETIME || wrqu->retry.disabled)\n\t\treturn -EINVAL;\n\n\tif (!(wrqu->retry.flags & IW_RETRY_LIMIT))\n\t\treturn 0;\n\n\tif (wrqu->retry.value < 0 || wrqu->retry.value >= 255)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&priv->mutex);\n\tif (wrqu->retry.flags & IW_RETRY_SHORT)\n\t\tpriv->short_retry_limit = (u8) wrqu->retry.value;\n\telse if (wrqu->retry.flags & IW_RETRY_LONG)\n\t\tpriv->long_retry_limit = (u8) wrqu->retry.value;\n\telse {\n\t\tpriv->short_retry_limit = (u8) wrqu->retry.value;\n\t\tpriv->long_retry_limit = (u8) wrqu->retry.value;\n\t}\n\n\tipw_send_retry_limit(priv, priv->short_retry_limit,\n\t\t\t     priv->long_retry_limit);\n\tmutex_unlock(&priv->mutex);\n\tIPW_DEBUG_WX(\"SET retry limit -> short:%d long:%d\\n\",\n\t\t     priv->short_retry_limit, priv->long_retry_limit);\n\treturn 0;\n}\n\nstatic int ipw_wx_get_retry(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\n\tmutex_lock(&priv->mutex);\n\twrqu->retry.disabled = 0;\n\n\tif ((wrqu->retry.flags & IW_RETRY_TYPE) == IW_RETRY_LIFETIME) {\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tif (wrqu->retry.flags & IW_RETRY_LONG) {\n\t\twrqu->retry.flags = IW_RETRY_LIMIT | IW_RETRY_LONG;\n\t\twrqu->retry.value = priv->long_retry_limit;\n\t} else if (wrqu->retry.flags & IW_RETRY_SHORT) {\n\t\twrqu->retry.flags = IW_RETRY_LIMIT | IW_RETRY_SHORT;\n\t\twrqu->retry.value = priv->short_retry_limit;\n\t} else {\n\t\twrqu->retry.flags = IW_RETRY_LIMIT;\n\t\twrqu->retry.value = priv->short_retry_limit;\n\t}\n\tmutex_unlock(&priv->mutex);\n\n\tIPW_DEBUG_WX(\"GET retry -> %d\\n\", wrqu->retry.value);\n\n\treturn 0;\n}\n\nstatic int ipw_wx_set_scan(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tstruct iw_scan_req *req = (struct iw_scan_req *)extra;\n\tstruct delayed_work *work = NULL;\n\n\tmutex_lock(&priv->mutex);\n\n\tpriv->user_requested_scan = 1;\n\n\tif (wrqu->data.length == sizeof(struct iw_scan_req)) {\n\t\tif (wrqu->data.flags & IW_SCAN_THIS_ESSID) {\n\t\t\tint len = min((int)req->essid_len,\n\t\t\t              (int)sizeof(priv->direct_scan_ssid));\n\t\t\tmemcpy(priv->direct_scan_ssid, req->essid, len);\n\t\t\tpriv->direct_scan_ssid_len = len;\n\t\t\twork = &priv->request_direct_scan;\n\t\t} else if (req->scan_type == IW_SCAN_TYPE_PASSIVE) {\n\t\t\twork = &priv->request_passive_scan;\n\t\t}\n\t} else {\n\t\t \n\t\twork = &priv->request_scan;\n\t}\n\n\tmutex_unlock(&priv->mutex);\n\n\tIPW_DEBUG_WX(\"Start scan\\n\");\n\n\tschedule_delayed_work(work, 0);\n\n\treturn 0;\n}\n\nstatic int ipw_wx_get_scan(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\treturn libipw_wx_get_scan(priv->ieee, info, wrqu, extra);\n}\n\nstatic int ipw_wx_set_encode(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *key)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tint ret;\n\tu32 cap = priv->capability;\n\n\tmutex_lock(&priv->mutex);\n\tret = libipw_wx_set_encode(priv->ieee, info, wrqu, key);\n\n\t \n\tif (cap != priv->capability &&\n\t    priv->ieee->iw_mode == IW_MODE_ADHOC &&\n\t    priv->status & STATUS_ASSOCIATED)\n\t\tipw_disassociate(priv);\n\n\tmutex_unlock(&priv->mutex);\n\treturn ret;\n}\n\nstatic int ipw_wx_get_encode(struct net_device *dev,\n\t\t\t     struct iw_request_info *info,\n\t\t\t     union iwreq_data *wrqu, char *key)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\treturn libipw_wx_get_encode(priv->ieee, info, wrqu, key);\n}\n\nstatic int ipw_wx_set_power(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tint err;\n\tmutex_lock(&priv->mutex);\n\tif (wrqu->power.disabled) {\n\t\tpriv->power_mode = IPW_POWER_LEVEL(priv->power_mode);\n\t\terr = ipw_send_power_mode(priv, IPW_POWER_MODE_CAM);\n\t\tif (err) {\n\t\t\tIPW_DEBUG_WX(\"failed setting power mode.\\n\");\n\t\t\tmutex_unlock(&priv->mutex);\n\t\t\treturn err;\n\t\t}\n\t\tIPW_DEBUG_WX(\"SET Power Management Mode -> off\\n\");\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn 0;\n\t}\n\n\tswitch (wrqu->power.flags & IW_POWER_MODE) {\n\tcase IW_POWER_ON:\t \n\tcase IW_POWER_MODE:\t \n\tcase IW_POWER_ALL_R:\t \n\t\tbreak;\n\tdefault:\t\t \n\t\tIPW_DEBUG_WX(\"SET PM Mode: %X not supported.\\n\",\n\t\t\t     wrqu->power.flags);\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (IPW_POWER_LEVEL(priv->power_mode) == IPW_POWER_AC)\n\t\tpriv->power_mode = IPW_POWER_ENABLED | IPW_POWER_BATTERY;\n\telse\n\t\tpriv->power_mode = IPW_POWER_ENABLED | priv->power_mode;\n\n\terr = ipw_send_power_mode(priv, IPW_POWER_LEVEL(priv->power_mode));\n\tif (err) {\n\t\tIPW_DEBUG_WX(\"failed setting power mode.\\n\");\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn err;\n\t}\n\n\tIPW_DEBUG_WX(\"SET Power Management Mode -> 0x%02X\\n\", priv->power_mode);\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\nstatic int ipw_wx_get_power(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tmutex_lock(&priv->mutex);\n\tif (!(priv->power_mode & IPW_POWER_ENABLED))\n\t\twrqu->power.disabled = 1;\n\telse\n\t\twrqu->power.disabled = 0;\n\n\tmutex_unlock(&priv->mutex);\n\tIPW_DEBUG_WX(\"GET Power Management Mode -> %02X\\n\", priv->power_mode);\n\n\treturn 0;\n}\n\nstatic int ipw_wx_set_powermode(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tint mode = *(int *)extra;\n\tint err;\n\n\tmutex_lock(&priv->mutex);\n\tif ((mode < 1) || (mode > IPW_POWER_LIMIT))\n\t\tmode = IPW_POWER_AC;\n\n\tif (IPW_POWER_LEVEL(priv->power_mode) != mode) {\n\t\terr = ipw_send_power_mode(priv, mode);\n\t\tif (err) {\n\t\t\tIPW_DEBUG_WX(\"failed setting power mode.\\n\");\n\t\t\tmutex_unlock(&priv->mutex);\n\t\t\treturn err;\n\t\t}\n\t\tpriv->power_mode = IPW_POWER_ENABLED | mode;\n\t}\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\n#define MAX_WX_STRING 80\nstatic int ipw_wx_get_powermode(struct net_device *dev,\n\t\t\t\tstruct iw_request_info *info,\n\t\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tint level = IPW_POWER_LEVEL(priv->power_mode);\n\tchar *p = extra;\n\n\tp += scnprintf(p, MAX_WX_STRING, \"Power save level: %d \", level);\n\n\tswitch (level) {\n\tcase IPW_POWER_AC:\n\t\tp += scnprintf(p, MAX_WX_STRING - (p - extra), \"(AC)\");\n\t\tbreak;\n\tcase IPW_POWER_BATTERY:\n\t\tp += scnprintf(p, MAX_WX_STRING - (p - extra), \"(BATTERY)\");\n\t\tbreak;\n\tdefault:\n\t\tp += scnprintf(p, MAX_WX_STRING - (p - extra),\n\t\t\t      \"(Timeout %dms, Period %dms)\",\n\t\t\t      timeout_duration[level - 1] / 1000,\n\t\t\t      period_duration[level - 1] / 1000);\n\t}\n\n\tif (!(priv->power_mode & IPW_POWER_ENABLED))\n\t\tp += scnprintf(p, MAX_WX_STRING - (p - extra), \" OFF\");\n\n\twrqu->data.length = p - extra + 1;\n\n\treturn 0;\n}\n\nstatic int ipw_wx_set_wireless_mode(struct net_device *dev,\n\t\t\t\t    struct iw_request_info *info,\n\t\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tint mode = *(int *)extra;\n\tu8 band = 0, modulation = 0;\n\n\tif (mode == 0 || mode & ~IEEE_MODE_MASK) {\n\t\tIPW_WARNING(\"Attempt to set invalid wireless mode: %d\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\tmutex_lock(&priv->mutex);\n\tif (priv->adapter == IPW_2915ABG) {\n\t\tpriv->ieee->abg_true = 1;\n\t\tif (mode & IEEE_A) {\n\t\t\tband |= LIBIPW_52GHZ_BAND;\n\t\t\tmodulation |= LIBIPW_OFDM_MODULATION;\n\t\t} else\n\t\t\tpriv->ieee->abg_true = 0;\n\t} else {\n\t\tif (mode & IEEE_A) {\n\t\t\tIPW_WARNING(\"Attempt to set 2200BG into \"\n\t\t\t\t    \"802.11a mode\\n\");\n\t\t\tmutex_unlock(&priv->mutex);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpriv->ieee->abg_true = 0;\n\t}\n\n\tif (mode & IEEE_B) {\n\t\tband |= LIBIPW_24GHZ_BAND;\n\t\tmodulation |= LIBIPW_CCK_MODULATION;\n\t} else\n\t\tpriv->ieee->abg_true = 0;\n\n\tif (mode & IEEE_G) {\n\t\tband |= LIBIPW_24GHZ_BAND;\n\t\tmodulation |= LIBIPW_OFDM_MODULATION;\n\t} else\n\t\tpriv->ieee->abg_true = 0;\n\n\tpriv->ieee->mode = mode;\n\tpriv->ieee->freq_band = band;\n\tpriv->ieee->modulation = modulation;\n\tinit_supported_rates(priv, &priv->rates);\n\n\t \n\tIPW_DEBUG_ASSOC(\"[re]association triggered due to mode change.\\n\");\n\tif (!ipw_disassociate(priv)) {\n\t\tipw_send_supported_rates(priv, &priv->rates);\n\t\tipw_associate(priv);\n\t}\n\n\t \n\tipw_led_band_on(priv);\n\n\tIPW_DEBUG_WX(\"PRIV SET MODE: %c%c%c\\n\",\n\t\t     mode & IEEE_A ? 'a' : '.',\n\t\t     mode & IEEE_B ? 'b' : '.', mode & IEEE_G ? 'g' : '.');\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\nstatic int ipw_wx_get_wireless_mode(struct net_device *dev,\n\t\t\t\t    struct iw_request_info *info,\n\t\t\t\t    union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tmutex_lock(&priv->mutex);\n\tswitch (priv->ieee->mode) {\n\tcase IEEE_A:\n\t\tstrncpy(extra, \"802.11a (1)\", MAX_WX_STRING);\n\t\tbreak;\n\tcase IEEE_B:\n\t\tstrncpy(extra, \"802.11b (2)\", MAX_WX_STRING);\n\t\tbreak;\n\tcase IEEE_A | IEEE_B:\n\t\tstrncpy(extra, \"802.11ab (3)\", MAX_WX_STRING);\n\t\tbreak;\n\tcase IEEE_G:\n\t\tstrncpy(extra, \"802.11g (4)\", MAX_WX_STRING);\n\t\tbreak;\n\tcase IEEE_A | IEEE_G:\n\t\tstrncpy(extra, \"802.11ag (5)\", MAX_WX_STRING);\n\t\tbreak;\n\tcase IEEE_B | IEEE_G:\n\t\tstrncpy(extra, \"802.11bg (6)\", MAX_WX_STRING);\n\t\tbreak;\n\tcase IEEE_A | IEEE_B | IEEE_G:\n\t\tstrncpy(extra, \"802.11abg (7)\", MAX_WX_STRING);\n\t\tbreak;\n\tdefault:\n\t\tstrncpy(extra, \"unknown\", MAX_WX_STRING);\n\t\tbreak;\n\t}\n\textra[MAX_WX_STRING - 1] = '\\0';\n\n\tIPW_DEBUG_WX(\"PRIV GET MODE: %s\\n\", extra);\n\n\twrqu->data.length = strlen(extra) + 1;\n\tmutex_unlock(&priv->mutex);\n\n\treturn 0;\n}\n\nstatic int ipw_wx_set_preamble(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tint mode = *(int *)extra;\n\tmutex_lock(&priv->mutex);\n\t \n\tif (mode == 1) {\n\t\tif (!(priv->config & CFG_PREAMBLE_LONG)) {\n\t\t\tpriv->config |= CFG_PREAMBLE_LONG;\n\n\t\t\t \n\t\t\tIPW_DEBUG_ASSOC\n\t\t\t    (\"[re]association triggered due to preamble change.\\n\");\n\t\t\tif (!ipw_disassociate(priv))\n\t\t\t\tipw_associate(priv);\n\t\t}\n\t\tgoto done;\n\t}\n\n\tif (mode == 0) {\n\t\tpriv->config &= ~CFG_PREAMBLE_LONG;\n\t\tgoto done;\n\t}\n\tmutex_unlock(&priv->mutex);\n\treturn -EINVAL;\n\n      done:\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\nstatic int ipw_wx_get_preamble(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tmutex_lock(&priv->mutex);\n\tif (priv->config & CFG_PREAMBLE_LONG)\n\t\tsnprintf(wrqu->name, IFNAMSIZ, \"long (1)\");\n\telse\n\t\tsnprintf(wrqu->name, IFNAMSIZ, \"auto (0)\");\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\n#ifdef CONFIG_IPW2200_MONITOR\nstatic int ipw_wx_set_monitor(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\n\t\t\t      union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tint *parms = (int *)extra;\n\tint enable = (parms[0] > 0);\n\tmutex_lock(&priv->mutex);\n\tIPW_DEBUG_WX(\"SET MONITOR: %d %d\\n\", enable, parms[1]);\n\tif (enable) {\n\t\tif (priv->ieee->iw_mode != IW_MODE_MONITOR) {\n#ifdef CONFIG_IPW2200_RADIOTAP\n\t\t\tpriv->net_dev->type = ARPHRD_IEEE80211_RADIOTAP;\n#else\n\t\t\tpriv->net_dev->type = ARPHRD_IEEE80211;\n#endif\n\t\t\tschedule_work(&priv->adapter_restart);\n\t\t}\n\n\t\tipw_set_channel(priv, parms[1]);\n\t} else {\n\t\tif (priv->ieee->iw_mode != IW_MODE_MONITOR) {\n\t\t\tmutex_unlock(&priv->mutex);\n\t\t\treturn 0;\n\t\t}\n\t\tpriv->net_dev->type = ARPHRD_ETHER;\n\t\tschedule_work(&priv->adapter_restart);\n\t}\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\n#endif\t\t\t\t \n\nstatic int ipw_wx_reset(struct net_device *dev,\n\t\t\tstruct iw_request_info *info,\n\t\t\tunion iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tIPW_DEBUG_WX(\"RESET\\n\");\n\tschedule_work(&priv->adapter_restart);\n\treturn 0;\n}\n\nstatic int ipw_wx_sw_reset(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   union iwreq_data *wrqu, char *extra)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tunion iwreq_data wrqu_sec = {\n\t\t.encoding = {\n\t\t\t     .flags = IW_ENCODE_DISABLED,\n\t\t\t     },\n\t};\n\tint ret;\n\n\tIPW_DEBUG_WX(\"SW_RESET\\n\");\n\n\tmutex_lock(&priv->mutex);\n\n\tret = ipw_sw_reset(priv, 2);\n\tif (!ret) {\n\t\tfree_firmware();\n\t\tipw_adapter_restart(priv);\n\t}\n\n\t \n\tipw_radio_kill_sw(priv, priv->status & STATUS_RF_KILL_SW);\n\n\tmutex_unlock(&priv->mutex);\n\tlibipw_wx_set_encode(priv->ieee, info, &wrqu_sec, NULL);\n\tmutex_lock(&priv->mutex);\n\n\tif (!(priv->status & STATUS_RF_KILL_MASK)) {\n\t\t \n\t\tIPW_DEBUG_ASSOC(\"[re]association triggered due to sw \"\n\t\t\t\t\"reset.\\n\");\n\t\tif (!ipw_disassociate(priv))\n\t\t\tipw_associate(priv);\n\t}\n\n\tmutex_unlock(&priv->mutex);\n\n\treturn 0;\n}\n\n \nstatic iw_handler ipw_wx_handlers[] = {\n\tIW_HANDLER(SIOCGIWNAME, cfg80211_wext_giwname),\n\tIW_HANDLER(SIOCSIWFREQ, ipw_wx_set_freq),\n\tIW_HANDLER(SIOCGIWFREQ, ipw_wx_get_freq),\n\tIW_HANDLER(SIOCSIWMODE, ipw_wx_set_mode),\n\tIW_HANDLER(SIOCGIWMODE, ipw_wx_get_mode),\n\tIW_HANDLER(SIOCSIWSENS, ipw_wx_set_sens),\n\tIW_HANDLER(SIOCGIWSENS, ipw_wx_get_sens),\n\tIW_HANDLER(SIOCGIWRANGE, ipw_wx_get_range),\n\tIW_HANDLER(SIOCSIWAP, ipw_wx_set_wap),\n\tIW_HANDLER(SIOCGIWAP, ipw_wx_get_wap),\n\tIW_HANDLER(SIOCSIWSCAN, ipw_wx_set_scan),\n\tIW_HANDLER(SIOCGIWSCAN, ipw_wx_get_scan),\n\tIW_HANDLER(SIOCSIWESSID, ipw_wx_set_essid),\n\tIW_HANDLER(SIOCGIWESSID, ipw_wx_get_essid),\n\tIW_HANDLER(SIOCSIWNICKN, ipw_wx_set_nick),\n\tIW_HANDLER(SIOCGIWNICKN, ipw_wx_get_nick),\n\tIW_HANDLER(SIOCSIWRATE, ipw_wx_set_rate),\n\tIW_HANDLER(SIOCGIWRATE, ipw_wx_get_rate),\n\tIW_HANDLER(SIOCSIWRTS, ipw_wx_set_rts),\n\tIW_HANDLER(SIOCGIWRTS, ipw_wx_get_rts),\n\tIW_HANDLER(SIOCSIWFRAG, ipw_wx_set_frag),\n\tIW_HANDLER(SIOCGIWFRAG, ipw_wx_get_frag),\n\tIW_HANDLER(SIOCSIWTXPOW, ipw_wx_set_txpow),\n\tIW_HANDLER(SIOCGIWTXPOW, ipw_wx_get_txpow),\n\tIW_HANDLER(SIOCSIWRETRY, ipw_wx_set_retry),\n\tIW_HANDLER(SIOCGIWRETRY, ipw_wx_get_retry),\n\tIW_HANDLER(SIOCSIWENCODE, ipw_wx_set_encode),\n\tIW_HANDLER(SIOCGIWENCODE, ipw_wx_get_encode),\n\tIW_HANDLER(SIOCSIWPOWER, ipw_wx_set_power),\n\tIW_HANDLER(SIOCGIWPOWER, ipw_wx_get_power),\n\tIW_HANDLER(SIOCSIWSPY, iw_handler_set_spy),\n\tIW_HANDLER(SIOCGIWSPY, iw_handler_get_spy),\n\tIW_HANDLER(SIOCSIWTHRSPY, iw_handler_set_thrspy),\n\tIW_HANDLER(SIOCGIWTHRSPY, iw_handler_get_thrspy),\n\tIW_HANDLER(SIOCSIWGENIE, ipw_wx_set_genie),\n\tIW_HANDLER(SIOCGIWGENIE, ipw_wx_get_genie),\n\tIW_HANDLER(SIOCSIWMLME, ipw_wx_set_mlme),\n\tIW_HANDLER(SIOCSIWAUTH, ipw_wx_set_auth),\n\tIW_HANDLER(SIOCGIWAUTH, ipw_wx_get_auth),\n\tIW_HANDLER(SIOCSIWENCODEEXT, ipw_wx_set_encodeext),\n\tIW_HANDLER(SIOCGIWENCODEEXT, ipw_wx_get_encodeext),\n};\n\nenum {\n\tIPW_PRIV_SET_POWER = SIOCIWFIRSTPRIV,\n\tIPW_PRIV_GET_POWER,\n\tIPW_PRIV_SET_MODE,\n\tIPW_PRIV_GET_MODE,\n\tIPW_PRIV_SET_PREAMBLE,\n\tIPW_PRIV_GET_PREAMBLE,\n\tIPW_PRIV_RESET,\n\tIPW_PRIV_SW_RESET,\n#ifdef CONFIG_IPW2200_MONITOR\n\tIPW_PRIV_SET_MONITOR,\n#endif\n};\n\nstatic struct iw_priv_args ipw_priv_args[] = {\n\t{\n\t .cmd = IPW_PRIV_SET_POWER,\n\t .set_args = IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t .name = \"set_power\"},\n\t{\n\t .cmd = IPW_PRIV_GET_POWER,\n\t .get_args = IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | MAX_WX_STRING,\n\t .name = \"get_power\"},\n\t{\n\t .cmd = IPW_PRIV_SET_MODE,\n\t .set_args = IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t .name = \"set_mode\"},\n\t{\n\t .cmd = IPW_PRIV_GET_MODE,\n\t .get_args = IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | MAX_WX_STRING,\n\t .name = \"get_mode\"},\n\t{\n\t .cmd = IPW_PRIV_SET_PREAMBLE,\n\t .set_args = IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,\n\t .name = \"set_preamble\"},\n\t{\n\t .cmd = IPW_PRIV_GET_PREAMBLE,\n\t .get_args = IW_PRIV_TYPE_CHAR | IW_PRIV_SIZE_FIXED | IFNAMSIZ,\n\t .name = \"get_preamble\"},\n\t{\n\t IPW_PRIV_RESET,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 0, 0, \"reset\"},\n\t{\n\t IPW_PRIV_SW_RESET,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 0, 0, \"sw_reset\"},\n#ifdef CONFIG_IPW2200_MONITOR\n\t{\n\t IPW_PRIV_SET_MONITOR,\n\t IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 2, 0, \"monitor\"},\n#endif\t\t\t\t \n};\n\nstatic iw_handler ipw_priv_handler[] = {\n\tipw_wx_set_powermode,\n\tipw_wx_get_powermode,\n\tipw_wx_set_wireless_mode,\n\tipw_wx_get_wireless_mode,\n\tipw_wx_set_preamble,\n\tipw_wx_get_preamble,\n\tipw_wx_reset,\n\tipw_wx_sw_reset,\n#ifdef CONFIG_IPW2200_MONITOR\n\tipw_wx_set_monitor,\n#endif\n};\n\nstatic const struct iw_handler_def ipw_wx_handler_def = {\n\t.standard = ipw_wx_handlers,\n\t.num_standard = ARRAY_SIZE(ipw_wx_handlers),\n\t.num_private = ARRAY_SIZE(ipw_priv_handler),\n\t.num_private_args = ARRAY_SIZE(ipw_priv_args),\n\t.private = ipw_priv_handler,\n\t.private_args = ipw_priv_args,\n\t.get_wireless_stats = ipw_get_wireless_stats,\n};\n\n \nstatic struct iw_statistics *ipw_get_wireless_stats(struct net_device *dev)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tstruct iw_statistics *wstats;\n\n\twstats = &priv->wstats;\n\n\t \n\tif (!(priv->status & STATUS_ASSOCIATED)) {\n\t\twstats->miss.beacon = 0;\n\t\twstats->discard.retries = 0;\n\t\twstats->qual.qual = 0;\n\t\twstats->qual.level = 0;\n\t\twstats->qual.noise = 0;\n\t\twstats->qual.updated = 7;\n\t\twstats->qual.updated |= IW_QUAL_NOISE_INVALID |\n\t\t    IW_QUAL_QUAL_INVALID | IW_QUAL_LEVEL_INVALID;\n\t\treturn wstats;\n\t}\n\n\twstats->qual.qual = priv->quality;\n\twstats->qual.level = priv->exp_avg_rssi;\n\twstats->qual.noise = priv->exp_avg_noise;\n\twstats->qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED |\n\t    IW_QUAL_NOISE_UPDATED | IW_QUAL_DBM;\n\n\twstats->miss.beacon = average_value(&priv->average_missed_beacons);\n\twstats->discard.retries = priv->last_tx_failures;\n\twstats->discard.code = priv->ieee->ieee_stats.rx_discards_undecryptable;\n\n \n\n\treturn wstats;\n}\n\n \n\nstatic  void init_sys_config(struct ipw_sys_config *sys_config)\n{\n\tmemset(sys_config, 0, sizeof(struct ipw_sys_config));\n\tsys_config->bt_coexistence = 0;\n\tsys_config->answer_broadcast_ssid_probe = 0;\n\tsys_config->accept_all_data_frames = 0;\n\tsys_config->accept_non_directed_frames = 1;\n\tsys_config->exclude_unicast_unencrypted = 0;\n\tsys_config->disable_unicast_decryption = 1;\n\tsys_config->exclude_multicast_unencrypted = 0;\n\tsys_config->disable_multicast_decryption = 1;\n\tif (antenna < CFG_SYS_ANTENNA_BOTH || antenna > CFG_SYS_ANTENNA_B)\n\t\tantenna = CFG_SYS_ANTENNA_BOTH;\n\tsys_config->antenna_diversity = antenna;\n\tsys_config->pass_crc_to_host = 0;\t \n\tsys_config->dot11g_auto_detection = 0;\n\tsys_config->enable_cts_to_self = 0;\n\tsys_config->bt_coexist_collision_thr = 0;\n\tsys_config->pass_noise_stats_to_host = 1;\t \n\tsys_config->silence_threshold = 0x1e;\n}\n\nstatic int ipw_net_open(struct net_device *dev)\n{\n\tIPW_DEBUG_INFO(\"dev->open\\n\");\n\tnetif_start_queue(dev);\n\treturn 0;\n}\n\nstatic int ipw_net_stop(struct net_device *dev)\n{\n\tIPW_DEBUG_INFO(\"dev->close\\n\");\n\tnetif_stop_queue(dev);\n\treturn 0;\n}\n\n \n\nstatic int ipw_tx_skb(struct ipw_priv *priv, struct libipw_txb *txb,\n\t\t\t     int pri)\n{\n\tstruct libipw_hdr_3addrqos *hdr = (struct libipw_hdr_3addrqos *)\n\t    txb->fragments[0]->data;\n\tint i = 0;\n\tstruct tfd_frame *tfd;\n#ifdef CONFIG_IPW2200_QOS\n\tint tx_id = ipw_get_tx_queue_number(priv, pri);\n\tstruct clx2_tx_queue *txq = &priv->txq[tx_id];\n#else\n\tstruct clx2_tx_queue *txq = &priv->txq[0];\n#endif\n\tstruct clx2_queue *q = &txq->q;\n\tu8 id, hdr_len, unicast;\n\tint fc;\n\n\tif (!(priv->status & STATUS_ASSOCIATED))\n\t\tgoto drop;\n\n\thdr_len = libipw_get_hdrlen(le16_to_cpu(hdr->frame_ctl));\n\tswitch (priv->ieee->iw_mode) {\n\tcase IW_MODE_ADHOC:\n\t\tunicast = !is_multicast_ether_addr(hdr->addr1);\n\t\tid = ipw_find_station(priv, hdr->addr1);\n\t\tif (id == IPW_INVALID_STATION) {\n\t\t\tid = ipw_add_station(priv, hdr->addr1);\n\t\t\tif (id == IPW_INVALID_STATION) {\n\t\t\t\tIPW_WARNING(\"Attempt to send data to \"\n\t\t\t\t\t    \"invalid cell: %pM\\n\",\n\t\t\t\t\t    hdr->addr1);\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase IW_MODE_INFRA:\n\tdefault:\n\t\tunicast = !is_multicast_ether_addr(hdr->addr3);\n\t\tid = 0;\n\t\tbreak;\n\t}\n\n\ttfd = &txq->bd[q->first_empty];\n\ttxq->txb[q->first_empty] = txb;\n\tmemset(tfd, 0, sizeof(*tfd));\n\ttfd->u.data.station_number = id;\n\n\ttfd->control_flags.message_type = TX_FRAME_TYPE;\n\ttfd->control_flags.control_bits = TFD_NEED_IRQ_MASK;\n\n\ttfd->u.data.cmd_id = DINO_CMD_TX;\n\ttfd->u.data.len = cpu_to_le16(txb->payload_size);\n\n\tif (priv->assoc_request.ieee_mode == IPW_B_MODE)\n\t\ttfd->u.data.tx_flags_ext |= DCT_FLAG_EXT_MODE_CCK;\n\telse\n\t\ttfd->u.data.tx_flags_ext |= DCT_FLAG_EXT_MODE_OFDM;\n\n\tif (priv->assoc_request.preamble_length == DCT_FLAG_SHORT_PREAMBLE)\n\t\ttfd->u.data.tx_flags |= DCT_FLAG_SHORT_PREAMBLE;\n\n\tfc = le16_to_cpu(hdr->frame_ctl);\n\thdr->frame_ctl = cpu_to_le16(fc & ~IEEE80211_FCTL_MOREFRAGS);\n\n\tmemcpy(&tfd->u.data.tfd.tfd_24.mchdr, hdr, hdr_len);\n\n\tif (likely(unicast))\n\t\ttfd->u.data.tx_flags |= DCT_FLAG_ACK_REQD;\n\n\tif (txb->encrypted && !priv->ieee->host_encrypt) {\n\t\tswitch (priv->ieee->sec.level) {\n\t\tcase SEC_LEVEL_3:\n\t\t\ttfd->u.data.tfd.tfd_24.mchdr.frame_ctl |=\n\t\t\t    cpu_to_le16(IEEE80211_FCTL_PROTECTED);\n\t\t\t \n\t\t\tif (!unicast)\n\t\t\t\ttfd->u.data.tx_flags |= DCT_FLAG_ACK_REQD;\n\n\t\t\ttfd->u.data.tx_flags &= ~DCT_FLAG_NO_WEP;\n\t\t\ttfd->u.data.tx_flags_ext |= DCT_FLAG_EXT_SECURITY_CCM;\n\t\t\ttfd->u.data.key_index = 0;\n\t\t\ttfd->u.data.key_index |= DCT_WEP_INDEX_USE_IMMEDIATE;\n\t\t\tbreak;\n\t\tcase SEC_LEVEL_2:\n\t\t\ttfd->u.data.tfd.tfd_24.mchdr.frame_ctl |=\n\t\t\t    cpu_to_le16(IEEE80211_FCTL_PROTECTED);\n\t\t\ttfd->u.data.tx_flags &= ~DCT_FLAG_NO_WEP;\n\t\t\ttfd->u.data.tx_flags_ext |= DCT_FLAG_EXT_SECURITY_TKIP;\n\t\t\ttfd->u.data.key_index = DCT_WEP_INDEX_USE_IMMEDIATE;\n\t\t\tbreak;\n\t\tcase SEC_LEVEL_1:\n\t\t\ttfd->u.data.tfd.tfd_24.mchdr.frame_ctl |=\n\t\t\t    cpu_to_le16(IEEE80211_FCTL_PROTECTED);\n\t\t\ttfd->u.data.key_index = priv->ieee->crypt_info.tx_keyidx;\n\t\t\tif (priv->ieee->sec.key_sizes[priv->ieee->crypt_info.tx_keyidx] <=\n\t\t\t    40)\n\t\t\t\ttfd->u.data.key_index |= DCT_WEP_KEY_64Bit;\n\t\t\telse\n\t\t\t\ttfd->u.data.key_index |= DCT_WEP_KEY_128Bit;\n\t\t\tbreak;\n\t\tcase SEC_LEVEL_0:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_ERR \"Unknown security level %d\\n\",\n\t\t\t       priv->ieee->sec.level);\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\t \n\t\ttfd->u.data.tx_flags |= DCT_FLAG_NO_WEP;\n\n#ifdef CONFIG_IPW2200_QOS\n\tif (fc & IEEE80211_STYPE_QOS_DATA)\n\t\tipw_qos_set_tx_queue_command(priv, pri, &(tfd->u.data));\n#endif\t\t\t\t \n\n\t \n\ttfd->u.data.num_chunks = cpu_to_le32(min((u8) (NUM_TFD_CHUNKS - 2),\n\t\t\t\t\t\t txb->nr_frags));\n\tIPW_DEBUG_FRAG(\"%i fragments being sent as %i chunks.\\n\",\n\t\t       txb->nr_frags, le32_to_cpu(tfd->u.data.num_chunks));\n\tfor (i = 0; i < le32_to_cpu(tfd->u.data.num_chunks); i++) {\n\t\tIPW_DEBUG_FRAG(\"Adding fragment %i of %i (%d bytes).\\n\",\n\t\t\t       i, le32_to_cpu(tfd->u.data.num_chunks),\n\t\t\t       txb->fragments[i]->len - hdr_len);\n\t\tIPW_DEBUG_TX(\"Dumping TX packet frag %i of %i (%d bytes):\\n\",\n\t\t\t     i, tfd->u.data.num_chunks,\n\t\t\t     txb->fragments[i]->len - hdr_len);\n\t\tprintk_buf(IPW_DL_TX, txb->fragments[i]->data + hdr_len,\n\t\t\t   txb->fragments[i]->len - hdr_len);\n\n\t\ttfd->u.data.chunk_ptr[i] =\n\t\t    cpu_to_le32(dma_map_single(&priv->pci_dev->dev,\n\t\t\t\t\t       txb->fragments[i]->data + hdr_len,\n\t\t\t\t\t       txb->fragments[i]->len - hdr_len,\n\t\t\t\t\t       DMA_TO_DEVICE));\n\t\ttfd->u.data.chunk_len[i] =\n\t\t    cpu_to_le16(txb->fragments[i]->len - hdr_len);\n\t}\n\n\tif (i != txb->nr_frags) {\n\t\tstruct sk_buff *skb;\n\t\tu16 remaining_bytes = 0;\n\t\tint j;\n\n\t\tfor (j = i; j < txb->nr_frags; j++)\n\t\t\tremaining_bytes += txb->fragments[j]->len - hdr_len;\n\n\t\tprintk(KERN_INFO \"Trying to reallocate for %d bytes\\n\",\n\t\t       remaining_bytes);\n\t\tskb = alloc_skb(remaining_bytes, GFP_ATOMIC);\n\t\tif (skb != NULL) {\n\t\t\ttfd->u.data.chunk_len[i] = cpu_to_le16(remaining_bytes);\n\t\t\tfor (j = i; j < txb->nr_frags; j++) {\n\t\t\t\tint size = txb->fragments[j]->len - hdr_len;\n\n\t\t\t\tprintk(KERN_INFO \"Adding frag %d %d...\\n\",\n\t\t\t\t       j, size);\n\t\t\t\tskb_put_data(skb,\n\t\t\t\t\t     txb->fragments[j]->data + hdr_len,\n\t\t\t\t\t     size);\n\t\t\t}\n\t\t\tdev_kfree_skb_any(txb->fragments[i]);\n\t\t\ttxb->fragments[i] = skb;\n\t\t\ttfd->u.data.chunk_ptr[i] =\n\t\t\t    cpu_to_le32(dma_map_single(&priv->pci_dev->dev,\n\t\t\t\t\t\t       skb->data,\n\t\t\t\t\t\t       remaining_bytes,\n\t\t\t\t\t\t       DMA_TO_DEVICE));\n\n\t\t\tle32_add_cpu(&tfd->u.data.num_chunks, 1);\n\t\t}\n\t}\n\n\t \n\tq->first_empty = ipw_queue_inc_wrap(q->first_empty, q->n_bd);\n\tipw_write32(priv, q->reg_w, q->first_empty);\n\n\tif (ipw_tx_queue_space(q) < q->high_mark)\n\t\tnetif_stop_queue(priv->net_dev);\n\n\treturn NETDEV_TX_OK;\n\n      drop:\n\tIPW_DEBUG_DROP(\"Silently dropping Tx packet.\\n\");\n\tlibipw_txb_free(txb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic int ipw_net_is_queue_full(struct net_device *dev, int pri)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n#ifdef CONFIG_IPW2200_QOS\n\tint tx_id = ipw_get_tx_queue_number(priv, pri);\n\tstruct clx2_tx_queue *txq = &priv->txq[tx_id];\n#else\n\tstruct clx2_tx_queue *txq = &priv->txq[0];\n#endif\t\t\t\t \n\n\tif (ipw_tx_queue_space(&txq->q) < txq->q.high_mark)\n\t\treturn 1;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_IPW2200_PROMISCUOUS\nstatic void ipw_handle_promiscuous_tx(struct ipw_priv *priv,\n\t\t\t\t      struct libipw_txb *txb)\n{\n\tstruct libipw_rx_stats dummystats;\n\tstruct ieee80211_hdr *hdr;\n\tu8 n;\n\tu16 filter = priv->prom_priv->filter;\n\tint hdr_only = 0;\n\n\tif (filter & IPW_PROM_NO_TX)\n\t\treturn;\n\n\tmemset(&dummystats, 0, sizeof(dummystats));\n\n\t \n\thdr = (void *)txb->fragments[0]->data;\n\tif (libipw_is_management(le16_to_cpu(hdr->frame_control))) {\n\t\tif (filter & IPW_PROM_NO_MGMT)\n\t\t\treturn;\n\t\tif (filter & IPW_PROM_MGMT_HEADER_ONLY)\n\t\t\thdr_only = 1;\n\t} else if (libipw_is_control(le16_to_cpu(hdr->frame_control))) {\n\t\tif (filter & IPW_PROM_NO_CTL)\n\t\t\treturn;\n\t\tif (filter & IPW_PROM_CTL_HEADER_ONLY)\n\t\t\thdr_only = 1;\n\t} else if (libipw_is_data(le16_to_cpu(hdr->frame_control))) {\n\t\tif (filter & IPW_PROM_NO_DATA)\n\t\t\treturn;\n\t\tif (filter & IPW_PROM_DATA_HEADER_ONLY)\n\t\t\thdr_only = 1;\n\t}\n\n\tfor(n=0; n<txb->nr_frags; ++n) {\n\t\tstruct sk_buff *src = txb->fragments[n];\n\t\tstruct sk_buff *dst;\n\t\tstruct ieee80211_radiotap_header *rt_hdr;\n\t\tint len;\n\n\t\tif (hdr_only) {\n\t\t\thdr = (void *)src->data;\n\t\t\tlen = libipw_get_hdrlen(le16_to_cpu(hdr->frame_control));\n\t\t} else\n\t\t\tlen = src->len;\n\n\t\tdst = alloc_skb(len + sizeof(*rt_hdr) + sizeof(u16)*2, GFP_ATOMIC);\n\t\tif (!dst)\n\t\t\tcontinue;\n\n\t\trt_hdr = skb_put(dst, sizeof(*rt_hdr));\n\n\t\trt_hdr->it_version = PKTHDR_RADIOTAP_VERSION;\n\t\trt_hdr->it_pad = 0;\n\t\trt_hdr->it_present = 0;  \n\t\trt_hdr->it_present |=  cpu_to_le32(1 << IEEE80211_RADIOTAP_CHANNEL);\n\n\t\t*(__le16*)skb_put(dst, sizeof(u16)) = cpu_to_le16(\n\t\t\tieee80211chan2mhz(priv->channel));\n\t\tif (priv->channel > 14) \t \n\t\t\t*(__le16*)skb_put(dst, sizeof(u16)) =\n\t\t\t\tcpu_to_le16(IEEE80211_CHAN_OFDM |\n\t\t\t\t\t     IEEE80211_CHAN_5GHZ);\n\t\telse if (priv->ieee->mode == IEEE_B)  \n\t\t\t*(__le16*)skb_put(dst, sizeof(u16)) =\n\t\t\t\tcpu_to_le16(IEEE80211_CHAN_CCK |\n\t\t\t\t\t     IEEE80211_CHAN_2GHZ);\n\t\telse \t\t \n\t\t\t*(__le16*)skb_put(dst, sizeof(u16)) =\n\t\t\t\tcpu_to_le16(IEEE80211_CHAN_OFDM |\n\t\t\t\t IEEE80211_CHAN_2GHZ);\n\n\t\trt_hdr->it_len = cpu_to_le16(dst->len);\n\n\t\tskb_copy_from_linear_data(src, skb_put(dst, len), len);\n\n\t\tif (!libipw_rx(priv->prom_priv->ieee, dst, &dummystats))\n\t\t\tdev_kfree_skb_any(dst);\n\t}\n}\n#endif\n\nstatic netdev_tx_t ipw_net_hard_start_xmit(struct libipw_txb *txb,\n\t\t\t\t\t   struct net_device *dev, int pri)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tunsigned long flags;\n\tnetdev_tx_t ret;\n\n\tIPW_DEBUG_TX(\"dev->xmit(%d bytes)\\n\", txb->payload_size);\n\tspin_lock_irqsave(&priv->lock, flags);\n\n#ifdef CONFIG_IPW2200_PROMISCUOUS\n\tif (rtap_iface && netif_running(priv->prom_net_dev))\n\t\tipw_handle_promiscuous_tx(priv, txb);\n#endif\n\n\tret = ipw_tx_skb(priv, txb, pri);\n\tif (ret == NETDEV_TX_OK)\n\t\t__ipw_led_activity_on(priv);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn ret;\n}\n\nstatic void ipw_net_set_multicast_list(struct net_device *dev)\n{\n\n}\n\nstatic int ipw_net_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tstruct sockaddr *addr = p;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\tmutex_lock(&priv->mutex);\n\tpriv->config |= CFG_CUSTOM_MAC;\n\tmemcpy(priv->mac_addr, addr->sa_data, ETH_ALEN);\n\tprintk(KERN_INFO \"%s: Setting MAC to %pM\\n\",\n\t       priv->net_dev->name, priv->mac_addr);\n\tschedule_work(&priv->adapter_restart);\n\tmutex_unlock(&priv->mutex);\n\treturn 0;\n}\n\nstatic void ipw_ethtool_get_drvinfo(struct net_device *dev,\n\t\t\t\t    struct ethtool_drvinfo *info)\n{\n\tstruct ipw_priv *p = libipw_priv(dev);\n\tchar vers[64];\n\tchar date[32];\n\tu32 len;\n\n\tstrscpy(info->driver, DRV_NAME, sizeof(info->driver));\n\tstrscpy(info->version, DRV_VERSION, sizeof(info->version));\n\n\tlen = sizeof(vers);\n\tipw_get_ordinal(p, IPW_ORD_STAT_FW_VERSION, vers, &len);\n\tlen = sizeof(date);\n\tipw_get_ordinal(p, IPW_ORD_STAT_FW_DATE, date, &len);\n\n\tsnprintf(info->fw_version, sizeof(info->fw_version), \"%s (%s)\",\n\t\t vers, date);\n\tstrscpy(info->bus_info, pci_name(p->pci_dev),\n\t\tsizeof(info->bus_info));\n}\n\nstatic u32 ipw_ethtool_get_link(struct net_device *dev)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\treturn (priv->status & STATUS_ASSOCIATED) != 0;\n}\n\nstatic int ipw_ethtool_get_eeprom_len(struct net_device *dev)\n{\n\treturn IPW_EEPROM_IMAGE_SIZE;\n}\n\nstatic int ipw_ethtool_get_eeprom(struct net_device *dev,\n\t\t\t\t  struct ethtool_eeprom *eeprom, u8 * bytes)\n{\n\tstruct ipw_priv *p = libipw_priv(dev);\n\n\tif (eeprom->offset + eeprom->len > IPW_EEPROM_IMAGE_SIZE)\n\t\treturn -EINVAL;\n\tmutex_lock(&p->mutex);\n\tmemcpy(bytes, &p->eeprom[eeprom->offset], eeprom->len);\n\tmutex_unlock(&p->mutex);\n\treturn 0;\n}\n\nstatic int ipw_ethtool_set_eeprom(struct net_device *dev,\n\t\t\t\t  struct ethtool_eeprom *eeprom, u8 * bytes)\n{\n\tstruct ipw_priv *p = libipw_priv(dev);\n\tint i;\n\n\tif (eeprom->offset + eeprom->len > IPW_EEPROM_IMAGE_SIZE)\n\t\treturn -EINVAL;\n\tmutex_lock(&p->mutex);\n\tmemcpy(&p->eeprom[eeprom->offset], bytes, eeprom->len);\n\tfor (i = 0; i < IPW_EEPROM_IMAGE_SIZE; i++)\n\t\tipw_write8(p, i + IPW_EEPROM_DATA, p->eeprom[i]);\n\tmutex_unlock(&p->mutex);\n\treturn 0;\n}\n\nstatic const struct ethtool_ops ipw_ethtool_ops = {\n\t.get_link = ipw_ethtool_get_link,\n\t.get_drvinfo = ipw_ethtool_get_drvinfo,\n\t.get_eeprom_len = ipw_ethtool_get_eeprom_len,\n\t.get_eeprom = ipw_ethtool_get_eeprom,\n\t.set_eeprom = ipw_ethtool_set_eeprom,\n};\n\nstatic irqreturn_t ipw_isr(int irq, void *data)\n{\n\tstruct ipw_priv *priv = data;\n\tu32 inta, inta_mask;\n\n\tif (!priv)\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&priv->irq_lock);\n\n\tif (!(priv->status & STATUS_INT_ENABLED)) {\n\t\t \n\t\tgoto none;\n\t}\n\n\tinta = ipw_read32(priv, IPW_INTA_RW);\n\tinta_mask = ipw_read32(priv, IPW_INTA_MASK_R);\n\n\tif (inta == 0xFFFFFFFF) {\n\t\t \n\t\tIPW_WARNING(\"IRQ INTA == 0xFFFFFFFF\\n\");\n\t\tgoto none;\n\t}\n\n\tif (!(inta & (IPW_INTA_MASK_ALL & inta_mask))) {\n\t\t \n\t\tgoto none;\n\t}\n\n\t \n\t__ipw_disable_interrupts(priv);\n\n\t \n\tinta &= (IPW_INTA_MASK_ALL & inta_mask);\n\tipw_write32(priv, IPW_INTA_RW, inta);\n\n\t \n\tpriv->isr_inta = inta;\n\n\ttasklet_schedule(&priv->irq_tasklet);\n\n\tspin_unlock(&priv->irq_lock);\n\n\treturn IRQ_HANDLED;\n      none:\n\tspin_unlock(&priv->irq_lock);\n\treturn IRQ_NONE;\n}\n\nstatic void ipw_rf_kill(void *adapter)\n{\n\tstruct ipw_priv *priv = adapter;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tif (rf_kill_active(priv)) {\n\t\tIPW_DEBUG_RF_KILL(\"RF Kill active, rescheduling GPIO check\\n\");\n\t\tschedule_delayed_work(&priv->rf_kill, 2 * HZ);\n\t\tgoto exit_unlock;\n\t}\n\n\t \n\n\tif (!(priv->status & STATUS_RF_KILL_MASK)) {\n\t\tIPW_DEBUG_RF_KILL(\"HW RF Kill no longer active, restarting \"\n\t\t\t\t  \"device\\n\");\n\n\t\t \n\t\tschedule_work(&priv->adapter_restart);\n\t} else\n\t\tIPW_DEBUG_RF_KILL(\"HW RF Kill deactivated.  SW RF Kill still \"\n\t\t\t\t  \"enabled\\n\");\n\n      exit_unlock:\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic void ipw_bg_rf_kill(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, rf_kill.work);\n\tmutex_lock(&priv->mutex);\n\tipw_rf_kill(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void ipw_link_up(struct ipw_priv *priv)\n{\n\tpriv->last_seq_num = -1;\n\tpriv->last_frag_num = -1;\n\tpriv->last_packet_time = 0;\n\n\tnetif_carrier_on(priv->net_dev);\n\n\tcancel_delayed_work(&priv->request_scan);\n\tcancel_delayed_work(&priv->request_direct_scan);\n\tcancel_delayed_work(&priv->request_passive_scan);\n\tcancel_delayed_work(&priv->scan_event);\n\tipw_reset_stats(priv);\n\t \n\tpriv->last_rate = ipw_get_current_rate(priv);\n\tipw_gather_stats(priv);\n\tipw_led_link_up(priv);\n\tnotify_wx_assoc_event(priv);\n\n\tif (priv->config & CFG_BACKGROUND_SCAN)\n\t\tschedule_delayed_work(&priv->request_scan, HZ);\n}\n\nstatic void ipw_bg_link_up(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, link_up);\n\tmutex_lock(&priv->mutex);\n\tipw_link_up(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void ipw_link_down(struct ipw_priv *priv)\n{\n\tipw_led_link_down(priv);\n\tnetif_carrier_off(priv->net_dev);\n\tnotify_wx_assoc_event(priv);\n\n\t \n\tcancel_delayed_work(&priv->request_scan);\n\tcancel_delayed_work(&priv->request_direct_scan);\n\tcancel_delayed_work(&priv->request_passive_scan);\n\tcancel_delayed_work(&priv->adhoc_check);\n\tcancel_delayed_work(&priv->gather_stats);\n\n\tipw_reset_stats(priv);\n\n\tif (!(priv->status & STATUS_EXIT_PENDING)) {\n\t\t \n\t\tschedule_delayed_work(&priv->request_scan, 0);\n\t} else\n\t\tcancel_delayed_work(&priv->scan_event);\n}\n\nstatic void ipw_bg_link_down(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, link_down);\n\tmutex_lock(&priv->mutex);\n\tipw_link_down(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void ipw_setup_deferred_work(struct ipw_priv *priv)\n{\n\tinit_waitqueue_head(&priv->wait_command_queue);\n\tinit_waitqueue_head(&priv->wait_state);\n\n\tINIT_DELAYED_WORK(&priv->adhoc_check, ipw_bg_adhoc_check);\n\tINIT_WORK(&priv->associate, ipw_bg_associate);\n\tINIT_WORK(&priv->disassociate, ipw_bg_disassociate);\n\tINIT_WORK(&priv->system_config, ipw_system_config);\n\tINIT_WORK(&priv->rx_replenish, ipw_bg_rx_queue_replenish);\n\tINIT_WORK(&priv->adapter_restart, ipw_bg_adapter_restart);\n\tINIT_DELAYED_WORK(&priv->rf_kill, ipw_bg_rf_kill);\n\tINIT_WORK(&priv->up, ipw_bg_up);\n\tINIT_WORK(&priv->down, ipw_bg_down);\n\tINIT_DELAYED_WORK(&priv->request_scan, ipw_request_scan);\n\tINIT_DELAYED_WORK(&priv->request_direct_scan, ipw_request_direct_scan);\n\tINIT_DELAYED_WORK(&priv->request_passive_scan, ipw_request_passive_scan);\n\tINIT_DELAYED_WORK(&priv->scan_event, ipw_scan_event);\n\tINIT_DELAYED_WORK(&priv->gather_stats, ipw_bg_gather_stats);\n\tINIT_WORK(&priv->abort_scan, ipw_bg_abort_scan);\n\tINIT_WORK(&priv->roam, ipw_bg_roam);\n\tINIT_DELAYED_WORK(&priv->scan_check, ipw_bg_scan_check);\n\tINIT_WORK(&priv->link_up, ipw_bg_link_up);\n\tINIT_WORK(&priv->link_down, ipw_bg_link_down);\n\tINIT_DELAYED_WORK(&priv->led_link_on, ipw_bg_led_link_on);\n\tINIT_DELAYED_WORK(&priv->led_link_off, ipw_bg_led_link_off);\n\tINIT_DELAYED_WORK(&priv->led_act_off, ipw_bg_led_activity_off);\n\tINIT_WORK(&priv->merge_networks, ipw_merge_adhoc_network);\n\n#ifdef CONFIG_IPW2200_QOS\n\tINIT_WORK(&priv->qos_activate, ipw_bg_qos_activate);\n#endif\t\t\t\t \n\n\ttasklet_setup(&priv->irq_tasklet, ipw_irq_tasklet);\n}\n\nstatic void shim__set_security(struct net_device *dev,\n\t\t\t       struct libipw_security *sec)\n{\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tint i;\n\tfor (i = 0; i < 4; i++) {\n\t\tif (sec->flags & (1 << i)) {\n\t\t\tpriv->ieee->sec.encode_alg[i] = sec->encode_alg[i];\n\t\t\tpriv->ieee->sec.key_sizes[i] = sec->key_sizes[i];\n\t\t\tif (sec->key_sizes[i] == 0)\n\t\t\t\tpriv->ieee->sec.flags &= ~(1 << i);\n\t\t\telse {\n\t\t\t\tmemcpy(priv->ieee->sec.keys[i], sec->keys[i],\n\t\t\t\t       sec->key_sizes[i]);\n\t\t\t\tpriv->ieee->sec.flags |= (1 << i);\n\t\t\t}\n\t\t\tpriv->status |= STATUS_SECURITY_UPDATED;\n\t\t} else if (sec->level != SEC_LEVEL_1)\n\t\t\tpriv->ieee->sec.flags &= ~(1 << i);\n\t}\n\n\tif (sec->flags & SEC_ACTIVE_KEY) {\n\t\tpriv->ieee->sec.active_key = sec->active_key;\n\t\tpriv->ieee->sec.flags |= SEC_ACTIVE_KEY;\n\t\tpriv->status |= STATUS_SECURITY_UPDATED;\n\t} else\n\t\tpriv->ieee->sec.flags &= ~SEC_ACTIVE_KEY;\n\n\tif ((sec->flags & SEC_AUTH_MODE) &&\n\t    (priv->ieee->sec.auth_mode != sec->auth_mode)) {\n\t\tpriv->ieee->sec.auth_mode = sec->auth_mode;\n\t\tpriv->ieee->sec.flags |= SEC_AUTH_MODE;\n\t\tif (sec->auth_mode == WLAN_AUTH_SHARED_KEY)\n\t\t\tpriv->capability |= CAP_SHARED_KEY;\n\t\telse\n\t\t\tpriv->capability &= ~CAP_SHARED_KEY;\n\t\tpriv->status |= STATUS_SECURITY_UPDATED;\n\t}\n\n\tif (sec->flags & SEC_ENABLED && priv->ieee->sec.enabled != sec->enabled) {\n\t\tpriv->ieee->sec.flags |= SEC_ENABLED;\n\t\tpriv->ieee->sec.enabled = sec->enabled;\n\t\tpriv->status |= STATUS_SECURITY_UPDATED;\n\t\tif (sec->enabled)\n\t\t\tpriv->capability |= CAP_PRIVACY_ON;\n\t\telse\n\t\t\tpriv->capability &= ~CAP_PRIVACY_ON;\n\t}\n\n\tif (sec->flags & SEC_ENCRYPT)\n\t\tpriv->ieee->sec.encrypt = sec->encrypt;\n\n\tif (sec->flags & SEC_LEVEL && priv->ieee->sec.level != sec->level) {\n\t\tpriv->ieee->sec.level = sec->level;\n\t\tpriv->ieee->sec.flags |= SEC_LEVEL;\n\t\tpriv->status |= STATUS_SECURITY_UPDATED;\n\t}\n\n\tif (!priv->ieee->host_encrypt && (sec->flags & SEC_ENCRYPT))\n\t\tipw_set_hwcrypto_keys(priv);\n\n\t \n#if 0\n\tif ((priv->status & (STATUS_ASSOCIATED | STATUS_ASSOCIATING)) &&\n\t    (((priv->assoc_request.capability &\n\t       cpu_to_le16(WLAN_CAPABILITY_PRIVACY)) && !sec->enabled) ||\n\t     (!(priv->assoc_request.capability &\n\t\tcpu_to_le16(WLAN_CAPABILITY_PRIVACY)) && sec->enabled))) {\n\t\tIPW_DEBUG_ASSOC(\"Disassociating due to capability \"\n\t\t\t\t\"change.\\n\");\n\t\tipw_disassociate(priv);\n\t}\n#endif\n}\n\nstatic int init_supported_rates(struct ipw_priv *priv,\n\t\t\t\tstruct ipw_supported_rates *rates)\n{\n\t \n\n\tmemset(rates, 0, sizeof(*rates));\n\t \n\tswitch (priv->ieee->freq_band) {\n\tcase LIBIPW_52GHZ_BAND:\n\t\trates->ieee_mode = IPW_A_MODE;\n\t\trates->purpose = IPW_RATE_CAPABILITIES;\n\t\tipw_add_ofdm_scan_rates(rates, LIBIPW_CCK_MODULATION,\n\t\t\t\t\tLIBIPW_OFDM_DEFAULT_RATES_MASK);\n\t\tbreak;\n\n\tdefault:\t\t \n\t\trates->ieee_mode = IPW_G_MODE;\n\t\trates->purpose = IPW_RATE_CAPABILITIES;\n\t\tipw_add_cck_scan_rates(rates, LIBIPW_CCK_MODULATION,\n\t\t\t\t       LIBIPW_CCK_DEFAULT_RATES_MASK);\n\t\tif (priv->ieee->modulation & LIBIPW_OFDM_MODULATION) {\n\t\t\tipw_add_ofdm_scan_rates(rates, LIBIPW_CCK_MODULATION,\n\t\t\t\t\t\tLIBIPW_OFDM_DEFAULT_RATES_MASK);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ipw_config(struct ipw_priv *priv)\n{\n\t \n\tif (ipw_set_tx_power(priv))\n\t\tgoto error;\n\n\t \n\tif (ipw_send_adapter_address(priv, priv->net_dev->dev_addr))\n\t\tgoto error;\n\n\t \n\tinit_sys_config(&priv->sys_config);\n\n\t \n\tif (bt_coexist) {\n\t\tunsigned char bt_caps = priv->eeprom[EEPROM_SKU_CAPABILITY];\n\n\t\tif (bt_caps & EEPROM_SKU_CAP_BT_CHANNEL_SIG)\n\t\t\tpriv->sys_config.bt_coexistence\n\t\t\t    |= CFG_BT_COEXISTENCE_SIGNAL_CHNL;\n\t\tif (bt_caps & EEPROM_SKU_CAP_BT_OOB)\n\t\t\tpriv->sys_config.bt_coexistence\n\t\t\t    |= CFG_BT_COEXISTENCE_OOB;\n\t}\n\n#ifdef CONFIG_IPW2200_PROMISCUOUS\n\tif (priv->prom_net_dev && netif_running(priv->prom_net_dev)) {\n\t\tpriv->sys_config.accept_all_data_frames = 1;\n\t\tpriv->sys_config.accept_non_directed_frames = 1;\n\t\tpriv->sys_config.accept_all_mgmt_bcpr = 1;\n\t\tpriv->sys_config.accept_all_mgmt_frames = 1;\n\t}\n#endif\n\n\tif (priv->ieee->iw_mode == IW_MODE_ADHOC)\n\t\tpriv->sys_config.answer_broadcast_ssid_probe = 1;\n\telse\n\t\tpriv->sys_config.answer_broadcast_ssid_probe = 0;\n\n\tif (ipw_send_system_config(priv))\n\t\tgoto error;\n\n\tinit_supported_rates(priv, &priv->rates);\n\tif (ipw_send_supported_rates(priv, &priv->rates))\n\t\tgoto error;\n\n\t \n\tif (priv->rts_threshold) {\n\t\tif (ipw_send_rts_threshold(priv, priv->rts_threshold))\n\t\t\tgoto error;\n\t}\n#ifdef CONFIG_IPW2200_QOS\n\tIPW_DEBUG_QOS(\"QoS: call ipw_qos_activate\\n\");\n\tipw_qos_activate(priv, NULL);\n#endif\t\t\t\t \n\n\tif (ipw_set_random_seed(priv))\n\t\tgoto error;\n\n\t \n\tif (ipw_send_host_complete(priv))\n\t\tgoto error;\n\n\tpriv->status |= STATUS_INIT;\n\n\tipw_led_init(priv);\n\tipw_led_radio_on(priv);\n\tpriv->notif_missed_beacons = 0;\n\n\t \n\tif ((priv->capability & CAP_PRIVACY_ON) &&\n\t    (priv->ieee->sec.level == SEC_LEVEL_1) &&\n\t    !(priv->ieee->host_encrypt || priv->ieee->host_decrypt))\n\t\tipw_set_hwcrypto_keys(priv);\n\n\treturn 0;\n\n      error:\n\treturn -EIO;\n}\n\n \nstatic const struct libipw_geo ipw_geos[] = {\n\t{\t\t\t \n\t \"---\",\n\t .bg_channels = 11,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11}},\n\t },\n\n\t{\t\t\t \n\t \"ZZF\",\n\t .bg_channels = 11,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11}},\n\t .a_channels = 8,\n\t .a = {{5180, 36},\n\t       {5200, 40},\n\t       {5220, 44},\n\t       {5240, 48},\n\t       {5260, 52, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5280, 56, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5300, 60, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5320, 64, LIBIPW_CH_PASSIVE_ONLY}},\n\t },\n\n\t{\t\t\t \n\t \"ZZD\",\n\t .bg_channels = 13,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11}, {2467, 12},\n\t\t{2472, 13}},\n\t },\n\n\t{\t\t\t \n\t \"ZZA\",\n\t .bg_channels = 11,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11}},\n\t .a_channels = 13,\n\t .a = {{5180, 36},\n\t       {5200, 40},\n\t       {5220, 44},\n\t       {5240, 48},\n\t       {5260, 52, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5280, 56, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5300, 60, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5320, 64, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5745, 149},\n\t       {5765, 153},\n\t       {5785, 157},\n\t       {5805, 161},\n\t       {5825, 165}},\n\t },\n\n\t{\t\t\t \n\t \"ZZB\",\n\t .bg_channels = 11,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11}},\n\t .a_channels = 13,\n\t .a = {{5180, 36},\n\t       {5200, 40},\n\t       {5220, 44},\n\t       {5240, 48},\n\t       {5260, 52, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5280, 56, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5300, 60, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5320, 64, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5745, 149, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5765, 153, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5785, 157, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5805, 161, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5825, 165, LIBIPW_CH_PASSIVE_ONLY}},\n\t },\n\n\t{\t\t\t \n\t \"ZZC\",\n\t .bg_channels = 11,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11}},\n\t .a_channels = 4,\n\t .a = {{5170, 34}, {5190, 38},\n\t       {5210, 42}, {5230, 46}},\n\t },\n\n\t{\t\t\t \n\t \"ZZM\",\n\t .bg_channels = 11,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11}},\n\t },\n\n\t{\t\t\t \n\t \"ZZE\",\n\t .bg_channels = 13,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11}, {2467, 12},\n\t\t{2472, 13}},\n\t .a_channels = 19,\n\t .a = {{5180, 36},\n\t       {5200, 40},\n\t       {5220, 44},\n\t       {5240, 48},\n\t       {5260, 52, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5280, 56, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5300, 60, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5320, 64, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5500, 100, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5520, 104, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5540, 108, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5560, 112, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5580, 116, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5600, 120, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5620, 124, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5640, 128, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5660, 132, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5680, 136, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5700, 140, LIBIPW_CH_PASSIVE_ONLY}},\n\t },\n\n\t{\t\t\t \n\t \"ZZJ\",\n\t .bg_channels = 14,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11}, {2467, 12},\n\t\t{2472, 13}, {2484, 14, LIBIPW_CH_B_ONLY}},\n\t .a_channels = 4,\n\t .a = {{5170, 34}, {5190, 38},\n\t       {5210, 42}, {5230, 46}},\n\t },\n\n\t{\t\t\t \n\t \"ZZR\",\n\t .bg_channels = 14,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11}, {2467, 12},\n\t\t{2472, 13}, {2484, 14, LIBIPW_CH_B_ONLY |\n\t\t\t     LIBIPW_CH_PASSIVE_ONLY}},\n\t },\n\n\t{\t\t\t \n\t \"ZZH\",\n\t .bg_channels = 13,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11},\n\t\t{2467, 12, LIBIPW_CH_PASSIVE_ONLY},\n\t\t{2472, 13, LIBIPW_CH_PASSIVE_ONLY}},\n\t .a_channels = 4,\n\t .a = {{5745, 149}, {5765, 153},\n\t       {5785, 157}, {5805, 161}},\n\t },\n\n\t{\t\t\t \n\t \"ZZG\",\n\t .bg_channels = 13,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11},\n\t\t{2467, 12}, {2472, 13}},\n\t .a_channels = 4,\n\t .a = {{5180, 36}, {5200, 40},\n\t       {5220, 44}, {5240, 48}},\n\t },\n\n\t{\t\t\t \n\t \"ZZK\",\n\t .bg_channels = 13,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11},\n\t\t{2467, 12, LIBIPW_CH_PASSIVE_ONLY},\n\t\t{2472, 13, LIBIPW_CH_PASSIVE_ONLY}},\n\t .a_channels = 24,\n\t .a = {{5180, 36, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5200, 40, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5220, 44, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5240, 48, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5260, 52, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5280, 56, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5300, 60, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5320, 64, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5500, 100, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5520, 104, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5540, 108, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5560, 112, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5580, 116, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5600, 120, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5620, 124, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5640, 128, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5660, 132, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5680, 136, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5700, 140, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5745, 149, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5765, 153, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5785, 157, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5805, 161, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5825, 165, LIBIPW_CH_PASSIVE_ONLY}},\n\t },\n\n\t{\t\t\t \n\t \"ZZL\",\n\t .bg_channels = 11,\n\t .bg = {{2412, 1}, {2417, 2}, {2422, 3},\n\t\t{2427, 4}, {2432, 5}, {2437, 6},\n\t\t{2442, 7}, {2447, 8}, {2452, 9},\n\t\t{2457, 10}, {2462, 11}},\n\t .a_channels = 13,\n\t .a = {{5180, 36, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5200, 40, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5220, 44, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5240, 48, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5260, 52, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5280, 56, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5300, 60, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5320, 64, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5745, 149, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5765, 153, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5785, 157, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5805, 161, LIBIPW_CH_PASSIVE_ONLY},\n\t       {5825, 165, LIBIPW_CH_PASSIVE_ONLY}},\n\t }\n};\n\nstatic void ipw_set_geo(struct ipw_priv *priv)\n{\n\tint j;\n\n\tfor (j = 0; j < ARRAY_SIZE(ipw_geos); j++) {\n\t\tif (!memcmp(&priv->eeprom[EEPROM_COUNTRY_CODE],\n\t\t\t    ipw_geos[j].name, 3))\n\t\t\tbreak;\n\t}\n\n\tif (j == ARRAY_SIZE(ipw_geos)) {\n\t\tIPW_WARNING(\"SKU [%c%c%c] not recognized.\\n\",\n\t\t\t    priv->eeprom[EEPROM_COUNTRY_CODE + 0],\n\t\t\t    priv->eeprom[EEPROM_COUNTRY_CODE + 1],\n\t\t\t    priv->eeprom[EEPROM_COUNTRY_CODE + 2]);\n\t\tj = 0;\n\t}\n\n\tlibipw_set_geo(priv->ieee, &ipw_geos[j]);\n}\n\n#define MAX_HW_RESTARTS 5\nstatic int ipw_up(struct ipw_priv *priv)\n{\n\tint rc, i;\n\n\t \n\tif (priv->suspend_time) {\n\t\tlibipw_networks_age(priv->ieee, priv->suspend_time);\n\t\tpriv->suspend_time = 0;\n\t}\n\n\tif (priv->status & STATUS_EXIT_PENDING)\n\t\treturn -EIO;\n\n\tif (cmdlog && !priv->cmdlog) {\n\t\tpriv->cmdlog = kcalloc(cmdlog, sizeof(*priv->cmdlog),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (priv->cmdlog == NULL) {\n\t\t\tIPW_ERROR(\"Error allocating %d command log entries.\\n\",\n\t\t\t\t  cmdlog);\n\t\t\treturn -ENOMEM;\n\t\t} else {\n\t\t\tpriv->cmdlog_len = cmdlog;\n\t\t}\n\t}\n\n\tfor (i = 0; i < MAX_HW_RESTARTS; i++) {\n\t\t \n\t\trc = ipw_load(priv);\n\t\tif (rc) {\n\t\t\tIPW_ERROR(\"Unable to load firmware: %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\tipw_init_ordinals(priv);\n\t\tif (!(priv->config & CFG_CUSTOM_MAC))\n\t\t\teeprom_parse_mac(priv, priv->mac_addr);\n\t\teth_hw_addr_set(priv->net_dev, priv->mac_addr);\n\n\t\tipw_set_geo(priv);\n\n\t\tif (priv->status & STATUS_RF_KILL_SW) {\n\t\t\tIPW_WARNING(\"Radio disabled by module parameter.\\n\");\n\t\t\treturn 0;\n\t\t} else if (rf_kill_active(priv)) {\n\t\t\tIPW_WARNING(\"Radio Frequency Kill Switch is On:\\n\"\n\t\t\t\t    \"Kill switch must be turned off for \"\n\t\t\t\t    \"wireless networking to work.\\n\");\n\t\t\tschedule_delayed_work(&priv->rf_kill, 2 * HZ);\n\t\t\treturn 0;\n\t\t}\n\n\t\trc = ipw_config(priv);\n\t\tif (!rc) {\n\t\t\tIPW_DEBUG_INFO(\"Configured device on count %i\\n\", i);\n\n\t\t\t \n\t\t\tschedule_delayed_work(&priv->request_scan, 0);\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tIPW_DEBUG_INFO(\"Device configuration failed: 0x%08X\\n\", rc);\n\t\tIPW_DEBUG_INFO(\"Failed to config device on retry %d of %d\\n\",\n\t\t\t       i, MAX_HW_RESTARTS);\n\n\t\t \n\t\tipw_down(priv);\n\t}\n\n\t \n\tIPW_ERROR(\"Unable to initialize device after %d attempts.\\n\", i);\n\n\treturn -EIO;\n}\n\nstatic void ipw_bg_up(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, up);\n\tmutex_lock(&priv->mutex);\n\tipw_up(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void ipw_deinit(struct ipw_priv *priv)\n{\n\tint i;\n\n\tif (priv->status & STATUS_SCANNING) {\n\t\tIPW_DEBUG_INFO(\"Aborting scan during shutdown.\\n\");\n\t\tipw_abort_scan(priv);\n\t}\n\n\tif (priv->status & STATUS_ASSOCIATED) {\n\t\tIPW_DEBUG_INFO(\"Disassociating during shutdown.\\n\");\n\t\tipw_disassociate(priv);\n\t}\n\n\tipw_led_shutdown(priv);\n\n\t \n\tfor (i = 1000; i && (priv->status &\n\t\t\t     (STATUS_DISASSOCIATING |\n\t\t\t      STATUS_ASSOCIATED | STATUS_SCANNING)); i--)\n\t\tudelay(10);\n\n\tif (priv->status & (STATUS_DISASSOCIATING |\n\t\t\t    STATUS_ASSOCIATED | STATUS_SCANNING))\n\t\tIPW_DEBUG_INFO(\"Still associated or scanning...\\n\");\n\telse\n\t\tIPW_DEBUG_INFO(\"Took %dms to de-init\\n\", 1000 - i);\n\n\t \n\tipw_send_card_disable(priv, 0);\n\n\tpriv->status &= ~STATUS_INIT;\n}\n\nstatic void ipw_down(struct ipw_priv *priv)\n{\n\tint exit_pending = priv->status & STATUS_EXIT_PENDING;\n\n\tpriv->status |= STATUS_EXIT_PENDING;\n\n\tif (ipw_is_init(priv))\n\t\tipw_deinit(priv);\n\n\t \n\tif (!exit_pending)\n\t\tpriv->status &= ~STATUS_EXIT_PENDING;\n\n\t \n\tipw_disable_interrupts(priv);\n\n\t \n\tpriv->status &= STATUS_RF_KILL_MASK | STATUS_EXIT_PENDING;\n\tnetif_carrier_off(priv->net_dev);\n\n\tipw_stop_nic(priv);\n\n\tipw_led_radio_off(priv);\n}\n\nstatic void ipw_bg_down(struct work_struct *work)\n{\n\tstruct ipw_priv *priv =\n\t\tcontainer_of(work, struct ipw_priv, down);\n\tmutex_lock(&priv->mutex);\n\tipw_down(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic int ipw_wdev_init(struct net_device *dev)\n{\n\tint i, rc = 0;\n\tstruct ipw_priv *priv = libipw_priv(dev);\n\tconst struct libipw_geo *geo = libipw_get_geo(priv->ieee);\n\tstruct wireless_dev *wdev = &priv->ieee->wdev;\n\n\tmemcpy(wdev->wiphy->perm_addr, priv->mac_addr, ETH_ALEN);\n\n\t \n\tif (geo->bg_channels) {\n\t\tstruct ieee80211_supported_band *bg_band = &priv->ieee->bg_band;\n\n\t\tbg_band->band = NL80211_BAND_2GHZ;\n\t\tbg_band->n_channels = geo->bg_channels;\n\t\tbg_band->channels = kcalloc(geo->bg_channels,\n\t\t\t\t\t    sizeof(struct ieee80211_channel),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!bg_band->channels) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tfor (i = 0; i < geo->bg_channels; i++) {\n\t\t\tbg_band->channels[i].band = NL80211_BAND_2GHZ;\n\t\t\tbg_band->channels[i].center_freq = geo->bg[i].freq;\n\t\t\tbg_band->channels[i].hw_value = geo->bg[i].channel;\n\t\t\tbg_band->channels[i].max_power = geo->bg[i].max_power;\n\t\t\tif (geo->bg[i].flags & LIBIPW_CH_PASSIVE_ONLY)\n\t\t\t\tbg_band->channels[i].flags |=\n\t\t\t\t\tIEEE80211_CHAN_NO_IR;\n\t\t\tif (geo->bg[i].flags & LIBIPW_CH_NO_IBSS)\n\t\t\t\tbg_band->channels[i].flags |=\n\t\t\t\t\tIEEE80211_CHAN_NO_IR;\n\t\t\tif (geo->bg[i].flags & LIBIPW_CH_RADAR_DETECT)\n\t\t\t\tbg_band->channels[i].flags |=\n\t\t\t\t\tIEEE80211_CHAN_RADAR;\n\t\t\t \n\t\t}\n\t\t \n\t\tbg_band->bitrates = ipw2200_bg_rates;\n\t\tbg_band->n_bitrates = ipw2200_num_bg_rates;\n\n\t\twdev->wiphy->bands[NL80211_BAND_2GHZ] = bg_band;\n\t}\n\n\t \n\tif (geo->a_channels) {\n\t\tstruct ieee80211_supported_band *a_band = &priv->ieee->a_band;\n\n\t\ta_band->band = NL80211_BAND_5GHZ;\n\t\ta_band->n_channels = geo->a_channels;\n\t\ta_band->channels = kcalloc(geo->a_channels,\n\t\t\t\t\t   sizeof(struct ieee80211_channel),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!a_band->channels) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tfor (i = 0; i < geo->a_channels; i++) {\n\t\t\ta_band->channels[i].band = NL80211_BAND_5GHZ;\n\t\t\ta_band->channels[i].center_freq = geo->a[i].freq;\n\t\t\ta_band->channels[i].hw_value = geo->a[i].channel;\n\t\t\ta_band->channels[i].max_power = geo->a[i].max_power;\n\t\t\tif (geo->a[i].flags & LIBIPW_CH_PASSIVE_ONLY)\n\t\t\t\ta_band->channels[i].flags |=\n\t\t\t\t\tIEEE80211_CHAN_NO_IR;\n\t\t\tif (geo->a[i].flags & LIBIPW_CH_NO_IBSS)\n\t\t\t\ta_band->channels[i].flags |=\n\t\t\t\t\tIEEE80211_CHAN_NO_IR;\n\t\t\tif (geo->a[i].flags & LIBIPW_CH_RADAR_DETECT)\n\t\t\t\ta_band->channels[i].flags |=\n\t\t\t\t\tIEEE80211_CHAN_RADAR;\n\t\t\t \n\t\t}\n\t\t \n\t\ta_band->bitrates = ipw2200_a_rates;\n\t\ta_band->n_bitrates = ipw2200_num_a_rates;\n\n\t\twdev->wiphy->bands[NL80211_BAND_5GHZ] = a_band;\n\t}\n\n\twdev->wiphy->cipher_suites = ipw_cipher_suites;\n\twdev->wiphy->n_cipher_suites = ARRAY_SIZE(ipw_cipher_suites);\n\n\tset_wiphy_dev(wdev->wiphy, &priv->pci_dev->dev);\n\n\t \n\trc = wiphy_register(wdev->wiphy);\n\tif (rc)\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tkfree(priv->ieee->a_band.channels);\n\tkfree(priv->ieee->bg_band.channels);\n\treturn rc;\n}\n\n \nstatic const struct pci_device_id card_ids[] = {\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2701, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2702, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2711, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2712, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2721, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2722, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2731, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2732, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2741, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x103c, 0x2741, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2742, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2751, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2752, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2753, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2754, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2761, 0, 0, 0},\n\t{PCI_VENDOR_ID_INTEL, 0x1043, 0x8086, 0x2762, 0, 0, 0},\n\t{PCI_VDEVICE(INTEL, 0x104f), 0},\n\t{PCI_VDEVICE(INTEL, 0x4220), 0},\t \n\t{PCI_VDEVICE(INTEL, 0x4221), 0},\t \n\t{PCI_VDEVICE(INTEL, 0x4223), 0},\t \n\t{PCI_VDEVICE(INTEL, 0x4224), 0},\t \n\n\t \n\t{0,}\n};\n\nMODULE_DEVICE_TABLE(pci, card_ids);\n\nstatic struct attribute *ipw_sysfs_entries[] = {\n\t&dev_attr_rf_kill.attr,\n\t&dev_attr_direct_dword.attr,\n\t&dev_attr_indirect_byte.attr,\n\t&dev_attr_indirect_dword.attr,\n\t&dev_attr_mem_gpio_reg.attr,\n\t&dev_attr_command_event_reg.attr,\n\t&dev_attr_nic_type.attr,\n\t&dev_attr_status.attr,\n\t&dev_attr_cfg.attr,\n\t&dev_attr_error.attr,\n\t&dev_attr_event_log.attr,\n\t&dev_attr_cmd_log.attr,\n\t&dev_attr_eeprom_delay.attr,\n\t&dev_attr_ucode_version.attr,\n\t&dev_attr_rtc.attr,\n\t&dev_attr_scan_age.attr,\n\t&dev_attr_led.attr,\n\t&dev_attr_speed_scan.attr,\n\t&dev_attr_net_stats.attr,\n\t&dev_attr_channels.attr,\n#ifdef CONFIG_IPW2200_PROMISCUOUS\n\t&dev_attr_rtap_iface.attr,\n\t&dev_attr_rtap_filter.attr,\n#endif\n\tNULL\n};\n\nstatic const struct attribute_group ipw_attribute_group = {\n\t.name = NULL,\t\t \n\t.attrs = ipw_sysfs_entries,\n};\n\n#ifdef CONFIG_IPW2200_PROMISCUOUS\nstatic int ipw_prom_open(struct net_device *dev)\n{\n\tstruct ipw_prom_priv *prom_priv = libipw_priv(dev);\n\tstruct ipw_priv *priv = prom_priv->priv;\n\n\tIPW_DEBUG_INFO(\"prom dev->open\\n\");\n\tnetif_carrier_off(dev);\n\n\tif (priv->ieee->iw_mode != IW_MODE_MONITOR) {\n\t\tpriv->sys_config.accept_all_data_frames = 1;\n\t\tpriv->sys_config.accept_non_directed_frames = 1;\n\t\tpriv->sys_config.accept_all_mgmt_bcpr = 1;\n\t\tpriv->sys_config.accept_all_mgmt_frames = 1;\n\n\t\tipw_send_system_config(priv);\n\t}\n\n\treturn 0;\n}\n\nstatic int ipw_prom_stop(struct net_device *dev)\n{\n\tstruct ipw_prom_priv *prom_priv = libipw_priv(dev);\n\tstruct ipw_priv *priv = prom_priv->priv;\n\n\tIPW_DEBUG_INFO(\"prom dev->stop\\n\");\n\n\tif (priv->ieee->iw_mode != IW_MODE_MONITOR) {\n\t\tpriv->sys_config.accept_all_data_frames = 0;\n\t\tpriv->sys_config.accept_non_directed_frames = 0;\n\t\tpriv->sys_config.accept_all_mgmt_bcpr = 0;\n\t\tpriv->sys_config.accept_all_mgmt_frames = 0;\n\n\t\tipw_send_system_config(priv);\n\t}\n\n\treturn 0;\n}\n\nstatic netdev_tx_t ipw_prom_hard_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *dev)\n{\n\tIPW_DEBUG_INFO(\"prom dev->xmit\\n\");\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic const struct net_device_ops ipw_prom_netdev_ops = {\n\t.ndo_open \t\t= ipw_prom_open,\n\t.ndo_stop\t\t= ipw_prom_stop,\n\t.ndo_start_xmit\t\t= ipw_prom_hard_start_xmit,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int ipw_prom_alloc(struct ipw_priv *priv)\n{\n\tint rc = 0;\n\n\tif (priv->prom_net_dev)\n\t\treturn -EPERM;\n\n\tpriv->prom_net_dev = alloc_libipw(sizeof(struct ipw_prom_priv), 1);\n\tif (priv->prom_net_dev == NULL)\n\t\treturn -ENOMEM;\n\n\tpriv->prom_priv = libipw_priv(priv->prom_net_dev);\n\tpriv->prom_priv->ieee = netdev_priv(priv->prom_net_dev);\n\tpriv->prom_priv->priv = priv;\n\n\tstrcpy(priv->prom_net_dev->name, \"rtap%d\");\n\teth_hw_addr_set(priv->prom_net_dev, priv->mac_addr);\n\n\tpriv->prom_net_dev->type = ARPHRD_IEEE80211_RADIOTAP;\n\tpriv->prom_net_dev->netdev_ops = &ipw_prom_netdev_ops;\n\n\tpriv->prom_net_dev->min_mtu = 68;\n\tpriv->prom_net_dev->max_mtu = LIBIPW_DATA_LEN;\n\n\tpriv->prom_priv->ieee->iw_mode = IW_MODE_MONITOR;\n\tSET_NETDEV_DEV(priv->prom_net_dev, &priv->pci_dev->dev);\n\n\trc = register_netdev(priv->prom_net_dev);\n\tif (rc) {\n\t\tfree_libipw(priv->prom_net_dev, 1);\n\t\tpriv->prom_net_dev = NULL;\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic void ipw_prom_free(struct ipw_priv *priv)\n{\n\tif (!priv->prom_net_dev)\n\t\treturn;\n\n\tunregister_netdev(priv->prom_net_dev);\n\tfree_libipw(priv->prom_net_dev, 1);\n\n\tpriv->prom_net_dev = NULL;\n}\n\n#endif\n\nstatic const struct net_device_ops ipw_netdev_ops = {\n\t.ndo_open\t\t= ipw_net_open,\n\t.ndo_stop\t\t= ipw_net_stop,\n\t.ndo_set_rx_mode\t= ipw_net_set_multicast_list,\n\t.ndo_set_mac_address\t= ipw_net_set_mac_address,\n\t.ndo_start_xmit\t\t= libipw_xmit,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int ipw_pci_probe(struct pci_dev *pdev,\n\t\t\t\t   const struct pci_device_id *ent)\n{\n\tint err = 0;\n\tstruct net_device *net_dev;\n\tvoid __iomem *base;\n\tu32 length, val;\n\tstruct ipw_priv *priv;\n\tint i;\n\n\tnet_dev = alloc_libipw(sizeof(struct ipw_priv), 0);\n\tif (net_dev == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tpriv = libipw_priv(net_dev);\n\tpriv->ieee = netdev_priv(net_dev);\n\n\tpriv->net_dev = net_dev;\n\tpriv->pci_dev = pdev;\n\tipw_debug_level = debug;\n\tspin_lock_init(&priv->irq_lock);\n\tspin_lock_init(&priv->lock);\n\tfor (i = 0; i < IPW_IBSS_MAC_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&priv->ibss_mac_hash[i]);\n\n\tmutex_init(&priv->mutex);\n\tif (pci_enable_device(pdev)) {\n\t\terr = -ENODEV;\n\t\tgoto out_free_libipw;\n\t}\n\n\tpci_set_master(pdev);\n\n\terr = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (!err)\n\t\terr = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (err) {\n\t\tprintk(KERN_WARNING DRV_NAME \": No suitable DMA available.\\n\");\n\t\tgoto out_pci_disable_device;\n\t}\n\n\tpci_set_drvdata(pdev, priv);\n\n\terr = pci_request_regions(pdev, DRV_NAME);\n\tif (err)\n\t\tgoto out_pci_disable_device;\n\n\t \n\tpci_read_config_dword(pdev, 0x40, &val);\n\tif ((val & 0x0000ff00) != 0)\n\t\tpci_write_config_dword(pdev, 0x40, val & 0xffff00ff);\n\n\tlength = pci_resource_len(pdev, 0);\n\tpriv->hw_len = length;\n\n\tbase = pci_ioremap_bar(pdev, 0);\n\tif (!base) {\n\t\terr = -ENODEV;\n\t\tgoto out_pci_release_regions;\n\t}\n\n\tpriv->hw_base = base;\n\tIPW_DEBUG_INFO(\"pci_resource_len = 0x%08x\\n\", length);\n\tIPW_DEBUG_INFO(\"pci_resource_base = %p\\n\", base);\n\n\tipw_setup_deferred_work(priv);\n\n\tipw_sw_reset(priv, 1);\n\n\terr = request_irq(pdev->irq, ipw_isr, IRQF_SHARED, DRV_NAME, priv);\n\tif (err) {\n\t\tIPW_ERROR(\"Error allocating IRQ %d\\n\", pdev->irq);\n\t\tgoto out_iounmap;\n\t}\n\n\tSET_NETDEV_DEV(net_dev, &pdev->dev);\n\n\tmutex_lock(&priv->mutex);\n\n\tpriv->ieee->hard_start_xmit = ipw_net_hard_start_xmit;\n\tpriv->ieee->set_security = shim__set_security;\n\tpriv->ieee->is_queue_full = ipw_net_is_queue_full;\n\n#ifdef CONFIG_IPW2200_QOS\n\tpriv->ieee->is_qos_active = ipw_is_qos_active;\n\tpriv->ieee->handle_probe_response = ipw_handle_beacon;\n\tpriv->ieee->handle_beacon = ipw_handle_probe_response;\n\tpriv->ieee->handle_assoc_response = ipw_handle_assoc_response;\n#endif\t\t\t\t \n\n\tpriv->ieee->perfect_rssi = -20;\n\tpriv->ieee->worst_rssi = -85;\n\n\tnet_dev->netdev_ops = &ipw_netdev_ops;\n\tpriv->wireless_data.spy_data = &priv->ieee->spy_data;\n\tnet_dev->wireless_data = &priv->wireless_data;\n\tnet_dev->wireless_handlers = &ipw_wx_handler_def;\n\tnet_dev->ethtool_ops = &ipw_ethtool_ops;\n\n\tnet_dev->min_mtu = 68;\n\tnet_dev->max_mtu = LIBIPW_DATA_LEN;\n\n\terr = sysfs_create_group(&pdev->dev.kobj, &ipw_attribute_group);\n\tif (err) {\n\t\tIPW_ERROR(\"failed to create sysfs device attributes\\n\");\n\t\tmutex_unlock(&priv->mutex);\n\t\tgoto out_release_irq;\n\t}\n\n\tif (ipw_up(priv)) {\n\t\tmutex_unlock(&priv->mutex);\n\t\terr = -EIO;\n\t\tgoto out_remove_sysfs;\n\t}\n\n\tmutex_unlock(&priv->mutex);\n\n\terr = ipw_wdev_init(net_dev);\n\tif (err) {\n\t\tIPW_ERROR(\"failed to register wireless device\\n\");\n\t\tgoto out_remove_sysfs;\n\t}\n\n\terr = register_netdev(net_dev);\n\tif (err) {\n\t\tIPW_ERROR(\"failed to register network device\\n\");\n\t\tgoto out_unregister_wiphy;\n\t}\n\n#ifdef CONFIG_IPW2200_PROMISCUOUS\n\tif (rtap_iface) {\n\t        err = ipw_prom_alloc(priv);\n\t\tif (err) {\n\t\t\tIPW_ERROR(\"Failed to register promiscuous network \"\n\t\t\t\t  \"device (error %d).\\n\", err);\n\t\t\tunregister_netdev(priv->net_dev);\n\t\t\tgoto out_unregister_wiphy;\n\t\t}\n\t}\n#endif\n\n\tprintk(KERN_INFO DRV_NAME \": Detected geography %s (%d 802.11bg \"\n\t       \"channels, %d 802.11a channels)\\n\",\n\t       priv->ieee->geo.name, priv->ieee->geo.bg_channels,\n\t       priv->ieee->geo.a_channels);\n\n\treturn 0;\n\n      out_unregister_wiphy:\n\twiphy_unregister(priv->ieee->wdev.wiphy);\n\tkfree(priv->ieee->a_band.channels);\n\tkfree(priv->ieee->bg_band.channels);\n      out_remove_sysfs:\n\tsysfs_remove_group(&pdev->dev.kobj, &ipw_attribute_group);\n      out_release_irq:\n\tfree_irq(pdev->irq, priv);\n      out_iounmap:\n\tiounmap(priv->hw_base);\n      out_pci_release_regions:\n\tpci_release_regions(pdev);\n      out_pci_disable_device:\n\tpci_disable_device(pdev);\n      out_free_libipw:\n\tfree_libipw(priv->net_dev, 0);\n      out:\n\treturn err;\n}\n\nstatic void ipw_pci_remove(struct pci_dev *pdev)\n{\n\tstruct ipw_priv *priv = pci_get_drvdata(pdev);\n\tstruct list_head *p, *q;\n\tint i;\n\n\tif (!priv)\n\t\treturn;\n\n\tmutex_lock(&priv->mutex);\n\n\tpriv->status |= STATUS_EXIT_PENDING;\n\tipw_down(priv);\n\tsysfs_remove_group(&pdev->dev.kobj, &ipw_attribute_group);\n\n\tmutex_unlock(&priv->mutex);\n\n\tunregister_netdev(priv->net_dev);\n\n\tif (priv->rxq) {\n\t\tipw_rx_queue_free(priv, priv->rxq);\n\t\tpriv->rxq = NULL;\n\t}\n\tipw_tx_queue_free(priv);\n\n\tif (priv->cmdlog) {\n\t\tkfree(priv->cmdlog);\n\t\tpriv->cmdlog = NULL;\n\t}\n\n\t \n\tcancel_delayed_work_sync(&priv->adhoc_check);\n\tcancel_work_sync(&priv->associate);\n\tcancel_work_sync(&priv->disassociate);\n\tcancel_work_sync(&priv->system_config);\n\tcancel_work_sync(&priv->rx_replenish);\n\tcancel_work_sync(&priv->adapter_restart);\n\tcancel_delayed_work_sync(&priv->rf_kill);\n\tcancel_work_sync(&priv->up);\n\tcancel_work_sync(&priv->down);\n\tcancel_delayed_work_sync(&priv->request_scan);\n\tcancel_delayed_work_sync(&priv->request_direct_scan);\n\tcancel_delayed_work_sync(&priv->request_passive_scan);\n\tcancel_delayed_work_sync(&priv->scan_event);\n\tcancel_delayed_work_sync(&priv->gather_stats);\n\tcancel_work_sync(&priv->abort_scan);\n\tcancel_work_sync(&priv->roam);\n\tcancel_delayed_work_sync(&priv->scan_check);\n\tcancel_work_sync(&priv->link_up);\n\tcancel_work_sync(&priv->link_down);\n\tcancel_delayed_work_sync(&priv->led_link_on);\n\tcancel_delayed_work_sync(&priv->led_link_off);\n\tcancel_delayed_work_sync(&priv->led_act_off);\n\tcancel_work_sync(&priv->merge_networks);\n\n\t \n\tfor (i = 0; i < IPW_IBSS_MAC_HASH_SIZE; i++) {\n\t\tlist_for_each_safe(p, q, &priv->ibss_mac_hash[i]) {\n\t\t\tlist_del(p);\n\t\t\tkfree(list_entry(p, struct ipw_ibss_seq, list));\n\t\t}\n\t}\n\n\tkfree(priv->error);\n\tpriv->error = NULL;\n\n#ifdef CONFIG_IPW2200_PROMISCUOUS\n\tipw_prom_free(priv);\n#endif\n\n\tfree_irq(pdev->irq, priv);\n\tiounmap(priv->hw_base);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\t \n\twiphy_unregister(priv->ieee->wdev.wiphy);\n\tkfree(priv->ieee->a_band.channels);\n\tkfree(priv->ieee->bg_band.channels);\n\tfree_libipw(priv->net_dev, 0);\n\tfree_firmware();\n}\n\nstatic int __maybe_unused ipw_pci_suspend(struct device *dev_d)\n{\n\tstruct ipw_priv *priv = dev_get_drvdata(dev_d);\n\tstruct net_device *dev = priv->net_dev;\n\n\tprintk(KERN_INFO \"%s: Going into suspend...\\n\", dev->name);\n\n\t \n\tipw_down(priv);\n\n\t \n\tnetif_device_detach(dev);\n\n\tpriv->suspend_at = ktime_get_boottime_seconds();\n\n\treturn 0;\n}\n\nstatic int __maybe_unused ipw_pci_resume(struct device *dev_d)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev_d);\n\tstruct ipw_priv *priv = pci_get_drvdata(pdev);\n\tstruct net_device *dev = priv->net_dev;\n\tu32 val;\n\n\tprintk(KERN_INFO \"%s: Coming out of suspend...\\n\", dev->name);\n\n\t \n\tpci_read_config_dword(pdev, 0x40, &val);\n\tif ((val & 0x0000ff00) != 0)\n\t\tpci_write_config_dword(pdev, 0x40, val & 0xffff00ff);\n\n\t \n\tnetif_device_attach(dev);\n\n\tpriv->suspend_time = ktime_get_boottime_seconds() - priv->suspend_at;\n\n\t \n\tschedule_work(&priv->up);\n\n\treturn 0;\n}\n\nstatic void ipw_pci_shutdown(struct pci_dev *pdev)\n{\n\tstruct ipw_priv *priv = pci_get_drvdata(pdev);\n\n\t \n\tipw_down(priv);\n\n\tpci_disable_device(pdev);\n}\n\nstatic SIMPLE_DEV_PM_OPS(ipw_pci_pm_ops, ipw_pci_suspend, ipw_pci_resume);\n\n \nstatic struct pci_driver ipw_driver = {\n\t.name = DRV_NAME,\n\t.id_table = card_ids,\n\t.probe = ipw_pci_probe,\n\t.remove = ipw_pci_remove,\n\t.driver.pm = &ipw_pci_pm_ops,\n\t.shutdown = ipw_pci_shutdown,\n};\n\nstatic int __init ipw_init(void)\n{\n\tint ret;\n\n\tprintk(KERN_INFO DRV_NAME \": \" DRV_DESCRIPTION \", \" DRV_VERSION \"\\n\");\n\tprintk(KERN_INFO DRV_NAME \": \" DRV_COPYRIGHT \"\\n\");\n\n\tret = pci_register_driver(&ipw_driver);\n\tif (ret) {\n\t\tIPW_ERROR(\"Unable to initialize PCI module\\n\");\n\t\treturn ret;\n\t}\n\n\tret = driver_create_file(&ipw_driver.driver, &driver_attr_debug_level);\n\tif (ret) {\n\t\tIPW_ERROR(\"Unable to create driver sysfs file\\n\");\n\t\tpci_unregister_driver(&ipw_driver);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void __exit ipw_exit(void)\n{\n\tdriver_remove_file(&ipw_driver.driver, &driver_attr_debug_level);\n\tpci_unregister_driver(&ipw_driver);\n}\n\nmodule_param(disable, int, 0444);\nMODULE_PARM_DESC(disable, \"manually disable the radio (default 0 [radio on])\");\n\nmodule_param(associate, int, 0444);\nMODULE_PARM_DESC(associate, \"auto associate when scanning (default off)\");\n\nmodule_param(auto_create, int, 0444);\nMODULE_PARM_DESC(auto_create, \"auto create adhoc network (default on)\");\n\nmodule_param_named(led, led_support, int, 0444);\nMODULE_PARM_DESC(led, \"enable led control on some systems (default 1 on)\");\n\nmodule_param(debug, int, 0444);\nMODULE_PARM_DESC(debug, \"debug output mask\");\n\nmodule_param_named(channel, default_channel, int, 0444);\nMODULE_PARM_DESC(channel, \"channel to limit associate to (default 0 [ANY])\");\n\n#ifdef CONFIG_IPW2200_PROMISCUOUS\nmodule_param(rtap_iface, int, 0444);\nMODULE_PARM_DESC(rtap_iface, \"create the rtap interface (1 - create, default 0)\");\n#endif\n\n#ifdef CONFIG_IPW2200_QOS\nmodule_param(qos_enable, int, 0444);\nMODULE_PARM_DESC(qos_enable, \"enable all QoS functionalities\");\n\nmodule_param(qos_burst_enable, int, 0444);\nMODULE_PARM_DESC(qos_burst_enable, \"enable QoS burst mode\");\n\nmodule_param(qos_no_ack_mask, int, 0444);\nMODULE_PARM_DESC(qos_no_ack_mask, \"mask Tx_Queue to no ack\");\n\nmodule_param(burst_duration_CCK, int, 0444);\nMODULE_PARM_DESC(burst_duration_CCK, \"set CCK burst value\");\n\nmodule_param(burst_duration_OFDM, int, 0444);\nMODULE_PARM_DESC(burst_duration_OFDM, \"set OFDM burst value\");\n#endif\t\t\t\t \n\n#ifdef CONFIG_IPW2200_MONITOR\nmodule_param_named(mode, network_mode, int, 0444);\nMODULE_PARM_DESC(mode, \"network mode (0=BSS,1=IBSS,2=Monitor)\");\n#else\nmodule_param_named(mode, network_mode, int, 0444);\nMODULE_PARM_DESC(mode, \"network mode (0=BSS,1=IBSS)\");\n#endif\n\nmodule_param(bt_coexist, int, 0444);\nMODULE_PARM_DESC(bt_coexist, \"enable bluetooth coexistence (default off)\");\n\nmodule_param(hwcrypto, int, 0444);\nMODULE_PARM_DESC(hwcrypto, \"enable hardware crypto (default off)\");\n\nmodule_param(cmdlog, int, 0444);\nMODULE_PARM_DESC(cmdlog,\n\t\t \"allocate a ring buffer for logging firmware commands\");\n\nmodule_param(roaming, int, 0444);\nMODULE_PARM_DESC(roaming, \"enable roaming support (default on)\");\n\nmodule_param(antenna, int, 0444);\nMODULE_PARM_DESC(antenna, \"select antenna 1=Main, 3=Aux, default 0 [both], 2=slow_diversity (choose the one with lower background noise)\");\n\nmodule_exit(ipw_exit);\nmodule_init(ipw_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}