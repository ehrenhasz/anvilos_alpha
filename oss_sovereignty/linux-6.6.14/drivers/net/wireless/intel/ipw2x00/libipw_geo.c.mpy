{
  "module_name": "libipw_geo.c",
  "hash_id": "26aef08b551065c420b95f8fc866dfa58714732d122abd178fe8abc83afc877c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/ipw2x00/libipw_geo.c",
  "human_readable_source": "\n \n#include <linux/compiler.h>\n#include <linux/errno.h>\n#include <linux/if_arp.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/proc_fs.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/types.h>\n#include <linux/wireless.h>\n#include <linux/etherdevice.h>\n#include <linux/uaccess.h>\n\n#include \"libipw.h\"\n\nint libipw_is_valid_channel(struct libipw_device *ieee, u8 channel)\n{\n\tint i;\n\n\t \n\tif (ieee->geo.bg_channels == 0 && ieee->geo.a_channels == 0)\n\t\treturn 0;\n\n\tif (ieee->freq_band & LIBIPW_24GHZ_BAND)\n\t\tfor (i = 0; i < ieee->geo.bg_channels; i++)\n\t\t\t \n\t\t\tif ((ieee->geo.bg[i].channel == channel) &&\n\t\t\t    !(ieee->geo.bg[i].flags & LIBIPW_CH_INVALID) &&\n\t\t\t    (!(ieee->mode & IEEE_G) ||\n\t\t\t     !(ieee->geo.bg[i].flags & LIBIPW_CH_B_ONLY)))\n\t\t\t\treturn LIBIPW_24GHZ_BAND;\n\n\tif (ieee->freq_band & LIBIPW_52GHZ_BAND)\n\t\tfor (i = 0; i < ieee->geo.a_channels; i++)\n\t\t\tif ((ieee->geo.a[i].channel == channel) &&\n\t\t\t    !(ieee->geo.a[i].flags & LIBIPW_CH_INVALID))\n\t\t\t\treturn LIBIPW_52GHZ_BAND;\n\n\treturn 0;\n}\n\nint libipw_channel_to_index(struct libipw_device *ieee, u8 channel)\n{\n\tint i;\n\n\t \n\tif (ieee->geo.bg_channels == 0 && ieee->geo.a_channels == 0)\n\t\treturn -1;\n\n\tif (ieee->freq_band & LIBIPW_24GHZ_BAND)\n\t\tfor (i = 0; i < ieee->geo.bg_channels; i++)\n\t\t\tif (ieee->geo.bg[i].channel == channel)\n\t\t\t\treturn i;\n\n\tif (ieee->freq_band & LIBIPW_52GHZ_BAND)\n\t\tfor (i = 0; i < ieee->geo.a_channels; i++)\n\t\t\tif (ieee->geo.a[i].channel == channel)\n\t\t\t\treturn i;\n\n\treturn -1;\n}\n\nu32 libipw_channel_to_freq(struct libipw_device * ieee, u8 channel)\n{\n\tconst struct libipw_channel * ch;\n\n\t \n\tif (ieee->geo.bg_channels == 0 && ieee->geo.a_channels == 0)\n\t\treturn 0;\n\n\tch = libipw_get_channel(ieee, channel);\n\tif (!ch->channel)\n\t\treturn 0;\n\treturn ch->freq;\n}\n\nu8 libipw_freq_to_channel(struct libipw_device * ieee, u32 freq)\n{\n\tint i;\n\n\t \n\tif (ieee->geo.bg_channels == 0 && ieee->geo.a_channels == 0)\n\t\treturn 0;\n\n\tfreq /= 100000;\n\n\tif (ieee->freq_band & LIBIPW_24GHZ_BAND)\n\t\tfor (i = 0; i < ieee->geo.bg_channels; i++)\n\t\t\tif (ieee->geo.bg[i].freq == freq)\n\t\t\t\treturn ieee->geo.bg[i].channel;\n\n\tif (ieee->freq_band & LIBIPW_52GHZ_BAND)\n\t\tfor (i = 0; i < ieee->geo.a_channels; i++)\n\t\t\tif (ieee->geo.a[i].freq == freq)\n\t\t\t\treturn ieee->geo.a[i].channel;\n\n\treturn 0;\n}\n\nvoid libipw_set_geo(struct libipw_device *ieee,\n\t\t      const struct libipw_geo *geo)\n{\n\tmemcpy(ieee->geo.name, geo->name, 3);\n\tieee->geo.name[3] = '\\0';\n\tieee->geo.bg_channels = geo->bg_channels;\n\tieee->geo.a_channels = geo->a_channels;\n\tmemcpy(ieee->geo.bg, geo->bg, geo->bg_channels *\n\t       sizeof(struct libipw_channel));\n\tmemcpy(ieee->geo.a, geo->a, ieee->geo.a_channels *\n\t       sizeof(struct libipw_channel));\n}\n\nconst struct libipw_geo *libipw_get_geo(struct libipw_device *ieee)\n{\n\treturn &ieee->geo;\n}\n\nu8 libipw_get_channel_flags(struct libipw_device * ieee, u8 channel)\n{\n\tint index = libipw_channel_to_index(ieee, channel);\n\n\tif (index == -1)\n\t\treturn LIBIPW_CH_INVALID;\n\n\tif (channel <= LIBIPW_24GHZ_CHANNELS)\n\t\treturn ieee->geo.bg[index].flags;\n\n\treturn ieee->geo.a[index].flags;\n}\n\nstatic const struct libipw_channel bad_channel = {\n\t.channel = 0,\n\t.flags = LIBIPW_CH_INVALID,\n\t.max_power = 0,\n};\n\nconst struct libipw_channel *libipw_get_channel(struct libipw_device\n\t\t\t\t\t\t      *ieee, u8 channel)\n{\n\tint index = libipw_channel_to_index(ieee, channel);\n\n\tif (index == -1)\n\t\treturn &bad_channel;\n\n\tif (channel <= LIBIPW_24GHZ_CHANNELS)\n\t\treturn &ieee->geo.bg[index];\n\n\treturn &ieee->geo.a[index];\n}\n\nEXPORT_SYMBOL(libipw_get_channel);\nEXPORT_SYMBOL(libipw_get_channel_flags);\nEXPORT_SYMBOL(libipw_is_valid_channel);\nEXPORT_SYMBOL(libipw_freq_to_channel);\nEXPORT_SYMBOL(libipw_channel_to_freq);\nEXPORT_SYMBOL(libipw_channel_to_index);\nEXPORT_SYMBOL(libipw_set_geo);\nEXPORT_SYMBOL(libipw_get_geo);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}