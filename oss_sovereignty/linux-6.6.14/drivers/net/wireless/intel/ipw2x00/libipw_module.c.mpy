{
  "module_name": "libipw_module.c",
  "hash_id": "598580c6b6f9d1af48a71b22323e9c32b169386da9f9f967623cd96afbe222fd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/ipw2x00/libipw_module.c",
  "human_readable_source": "\n \n\n#include <linux/compiler.h>\n#include <linux/errno.h>\n#include <linux/if_arp.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n#include <linux/proc_fs.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/tcp.h>\n#include <linux/types.h>\n#include <linux/wireless.h>\n#include <linux/etherdevice.h>\n#include <linux/uaccess.h>\n#include <net/net_namespace.h>\n#include <net/arp.h>\n\n#include \"libipw.h\"\n\n#define DRV_DESCRIPTION \"802.11 data/management/control stack\"\n#define DRV_NAME        \"libipw\"\n#define DRV_PROCNAME\t\"ieee80211\"\n#define DRV_VERSION\tLIBIPW_VERSION\n#define DRV_COPYRIGHT   \"Copyright (C) 2004-2005 Intel Corporation <jketreno@linux.intel.com>\"\n\nMODULE_VERSION(DRV_VERSION);\nMODULE_DESCRIPTION(DRV_DESCRIPTION);\nMODULE_AUTHOR(DRV_COPYRIGHT);\nMODULE_LICENSE(\"GPL\");\n\nstatic struct cfg80211_ops libipw_config_ops = { };\nstatic void *libipw_wiphy_privid = &libipw_wiphy_privid;\n\nstatic int libipw_networks_allocate(struct libipw_device *ieee)\n{\n\tint i, j;\n\n\tfor (i = 0; i < MAX_NETWORK_COUNT; i++) {\n\t\tieee->networks[i] = kzalloc(sizeof(struct libipw_network),\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!ieee->networks[i]) {\n\t\t\tLIBIPW_ERROR(\"Out of memory allocating beacons\\n\");\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tkfree(ieee->networks[j]);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline void libipw_networks_free(struct libipw_device *ieee)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_NETWORK_COUNT; i++)\n\t\tkfree(ieee->networks[i]);\n}\n\nvoid libipw_networks_age(struct libipw_device *ieee,\n                            unsigned long age_secs)\n{\n\tstruct libipw_network *network = NULL;\n\tunsigned long flags;\n\tunsigned long age_jiffies = msecs_to_jiffies(age_secs * MSEC_PER_SEC);\n\n\tspin_lock_irqsave(&ieee->lock, flags);\n\tlist_for_each_entry(network, &ieee->network_list, list) {\n\t\tnetwork->last_scanned -= age_jiffies;\n\t}\n\tspin_unlock_irqrestore(&ieee->lock, flags);\n}\nEXPORT_SYMBOL(libipw_networks_age);\n\nstatic void libipw_networks_initialize(struct libipw_device *ieee)\n{\n\tint i;\n\n\tINIT_LIST_HEAD(&ieee->network_free_list);\n\tINIT_LIST_HEAD(&ieee->network_list);\n\tfor (i = 0; i < MAX_NETWORK_COUNT; i++)\n\t\tlist_add_tail(&ieee->networks[i]->list,\n\t\t\t      &ieee->network_free_list);\n}\n\nstruct net_device *alloc_libipw(int sizeof_priv, int monitor)\n{\n\tstruct libipw_device *ieee;\n\tstruct net_device *dev;\n\tint err;\n\n\tLIBIPW_DEBUG_INFO(\"Initializing...\\n\");\n\n\tdev = alloc_etherdev(sizeof(struct libipw_device) + sizeof_priv);\n\tif (!dev)\n\t\tgoto failed;\n\n\tieee = netdev_priv(dev);\n\n\tieee->dev = dev;\n\n\tif (!monitor) {\n\t\tieee->wdev.wiphy = wiphy_new(&libipw_config_ops, 0);\n\t\tif (!ieee->wdev.wiphy) {\n\t\t\tLIBIPW_ERROR(\"Unable to allocate wiphy.\\n\");\n\t\t\tgoto failed_free_netdev;\n\t\t}\n\n\t\tieee->dev->ieee80211_ptr = &ieee->wdev;\n\t\tieee->wdev.iftype = NL80211_IFTYPE_STATION;\n\n\t\t \n\t\tieee->wdev.wiphy->privid = libipw_wiphy_privid;\n\n\t\tieee->wdev.wiphy->max_scan_ssids = 1;\n\t\tieee->wdev.wiphy->max_scan_ie_len = 0;\n\t\tieee->wdev.wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION)\n\t\t\t\t\t\t| BIT(NL80211_IFTYPE_ADHOC);\n\t}\n\n\terr = libipw_networks_allocate(ieee);\n\tif (err) {\n\t\tLIBIPW_ERROR(\"Unable to allocate beacon storage: %d\\n\", err);\n\t\tgoto failed_free_wiphy;\n\t}\n\tlibipw_networks_initialize(ieee);\n\n\t \n\tieee->fts = DEFAULT_FTS;\n\tieee->rts = DEFAULT_FTS;\n\tieee->scan_age = DEFAULT_MAX_SCAN_AGE;\n\tieee->open_wep = 1;\n\n\t \n\tieee->host_encrypt = 1;\n\tieee->host_decrypt = 1;\n\tieee->host_mc_decrypt = 1;\n\n\t \n\tieee->host_open_frag = 1;\n\tieee->ieee802_1x = 1;\t \n\n\tspin_lock_init(&ieee->lock);\n\n\tlib80211_crypt_info_init(&ieee->crypt_info, dev->name, &ieee->lock);\n\n\tieee->wpa_enabled = 0;\n\tieee->drop_unencrypted = 0;\n\tieee->privacy_invoked = 0;\n\n\treturn dev;\n\nfailed_free_wiphy:\n\tif (!monitor)\n\t\twiphy_free(ieee->wdev.wiphy);\nfailed_free_netdev:\n\tfree_netdev(dev);\nfailed:\n\treturn NULL;\n}\nEXPORT_SYMBOL(alloc_libipw);\n\nvoid free_libipw(struct net_device *dev, int monitor)\n{\n\tstruct libipw_device *ieee = netdev_priv(dev);\n\n\tlib80211_crypt_info_free(&ieee->crypt_info);\n\n\tlibipw_networks_free(ieee);\n\n\t \n\tif (!monitor)\n\t\twiphy_free(ieee->wdev.wiphy);\n\n\tfree_netdev(dev);\n}\nEXPORT_SYMBOL(free_libipw);\n\n#ifdef CONFIG_LIBIPW_DEBUG\n\nstatic int debug = 0;\nu32 libipw_debug_level = 0;\nEXPORT_SYMBOL_GPL(libipw_debug_level);\nstatic struct proc_dir_entry *libipw_proc = NULL;\n\nstatic int debug_level_proc_show(struct seq_file *m, void *v)\n{\n\tseq_printf(m, \"0x%08X\\n\", libipw_debug_level);\n\treturn 0;\n}\n\nstatic int debug_level_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, debug_level_proc_show, NULL);\n}\n\nstatic ssize_t debug_level_proc_write(struct file *file,\n\t\tconst char __user *buffer, size_t count, loff_t *pos)\n{\n\tchar buf[] = \"0x00000000\\n\";\n\tsize_t len = min(sizeof(buf) - 1, count);\n\tunsigned long val;\n\n\tif (copy_from_user(buf, buffer, len))\n\t\treturn count;\n\tbuf[len] = 0;\n\tif (sscanf(buf, \"%li\", &val) != 1)\n\t\tprintk(KERN_INFO DRV_NAME\n\t\t       \": %s is not in hex or decimal form.\\n\", buf);\n\telse\n\t\tlibipw_debug_level = val;\n\n\treturn strnlen(buf, len);\n}\n\nstatic const struct proc_ops debug_level_proc_ops = {\n\t.proc_open\t= debug_level_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= debug_level_proc_write,\n};\n#endif\t\t\t\t \n\nstatic int __init libipw_init(void)\n{\n#ifdef CONFIG_LIBIPW_DEBUG\n\tstruct proc_dir_entry *e;\n\n\tlibipw_debug_level = debug;\n\tlibipw_proc = proc_mkdir(DRV_PROCNAME, init_net.proc_net);\n\tif (libipw_proc == NULL) {\n\t\tLIBIPW_ERROR(\"Unable to create \" DRV_PROCNAME\n\t\t\t\t\" proc directory\\n\");\n\t\treturn -EIO;\n\t}\n\te = proc_create(\"debug_level\", 0644, libipw_proc,\n\t\t\t&debug_level_proc_ops);\n\tif (!e) {\n\t\tremove_proc_entry(DRV_PROCNAME, init_net.proc_net);\n\t\tlibipw_proc = NULL;\n\t\treturn -EIO;\n\t}\n#endif\t\t\t\t \n\n\tprintk(KERN_INFO DRV_NAME \": \" DRV_DESCRIPTION \", \" DRV_VERSION \"\\n\");\n\tprintk(KERN_INFO DRV_NAME \": \" DRV_COPYRIGHT \"\\n\");\n\n\treturn 0;\n}\n\nstatic void __exit libipw_exit(void)\n{\n#ifdef CONFIG_LIBIPW_DEBUG\n\tif (libipw_proc) {\n\t\tremove_proc_entry(\"debug_level\", libipw_proc);\n\t\tremove_proc_entry(DRV_PROCNAME, init_net.proc_net);\n\t\tlibipw_proc = NULL;\n\t}\n#endif\t\t\t\t \n}\n\n#ifdef CONFIG_LIBIPW_DEBUG\n#include <linux/moduleparam.h>\nmodule_param(debug, int, 0444);\nMODULE_PARM_DESC(debug, \"debug output mask\");\n#endif\t\t\t\t \n\nmodule_exit(libipw_exit);\nmodule_init(libipw_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}