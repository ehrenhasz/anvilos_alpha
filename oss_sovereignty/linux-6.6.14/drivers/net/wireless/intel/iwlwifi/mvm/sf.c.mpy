{
  "module_name": "sf.c",
  "hash_id": "b7c59b475cc832328bdadd287d5dfc155a01aec77c88a62f5dbe2ae4e41902e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/sf.c",
  "human_readable_source": "\n \n#include \"mvm.h\"\n\n \nstruct iwl_mvm_active_iface_iterator_data {\n\tstruct ieee80211_vif *ignore_vif;\n\tstruct ieee80211_sta *sta_vif_ap_sta;\n\tenum iwl_sf_state sta_vif_state;\n\tu32 num_active_macs;\n};\n\n \nstatic void iwl_mvm_bound_iface_iterator(void *_data, u8 *mac,\n\t\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_active_iface_iterator_data *data = _data;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tif (vif == data->ignore_vif || !mvmvif->deflink.phy_ctxt ||\n\t    vif->type == NL80211_IFTYPE_P2P_DEVICE)\n\t\treturn;\n\n\tdata->num_active_macs++;\n\n\tif (vif->type == NL80211_IFTYPE_STATION) {\n\t\tdata->sta_vif_ap_sta = mvmvif->ap_sta;\n\t\tif (vif->cfg.assoc)\n\t\t\tdata->sta_vif_state = SF_FULL_ON;\n\t\telse\n\t\t\tdata->sta_vif_state = SF_INIT_OFF;\n\t}\n}\n\n \nstatic const\n__le32 sf_full_timeout_def[SF_NUM_SCENARIO][SF_NUM_TIMEOUT_TYPES] = {\n\t{\n\t\tcpu_to_le32(SF_SINGLE_UNICAST_AGING_TIMER_DEF),\n\t\tcpu_to_le32(SF_SINGLE_UNICAST_IDLE_TIMER_DEF)\n\t},\n\t{\n\t\tcpu_to_le32(SF_AGG_UNICAST_AGING_TIMER_DEF),\n\t\tcpu_to_le32(SF_AGG_UNICAST_IDLE_TIMER_DEF)\n\t},\n\t{\n\t\tcpu_to_le32(SF_MCAST_AGING_TIMER_DEF),\n\t\tcpu_to_le32(SF_MCAST_IDLE_TIMER_DEF)\n\t},\n\t{\n\t\tcpu_to_le32(SF_BA_AGING_TIMER_DEF),\n\t\tcpu_to_le32(SF_BA_IDLE_TIMER_DEF)\n\t},\n\t{\n\t\tcpu_to_le32(SF_TX_RE_AGING_TIMER_DEF),\n\t\tcpu_to_le32(SF_TX_RE_IDLE_TIMER_DEF)\n\t},\n};\n\n \nstatic const __le32 sf_full_timeout[SF_NUM_SCENARIO][SF_NUM_TIMEOUT_TYPES] = {\n\t{\n\t\tcpu_to_le32(SF_SINGLE_UNICAST_AGING_TIMER),\n\t\tcpu_to_le32(SF_SINGLE_UNICAST_IDLE_TIMER)\n\t},\n\t{\n\t\tcpu_to_le32(SF_AGG_UNICAST_AGING_TIMER),\n\t\tcpu_to_le32(SF_AGG_UNICAST_IDLE_TIMER)\n\t},\n\t{\n\t\tcpu_to_le32(SF_MCAST_AGING_TIMER),\n\t\tcpu_to_le32(SF_MCAST_IDLE_TIMER)\n\t},\n\t{\n\t\tcpu_to_le32(SF_BA_AGING_TIMER),\n\t\tcpu_to_le32(SF_BA_IDLE_TIMER)\n\t},\n\t{\n\t\tcpu_to_le32(SF_TX_RE_AGING_TIMER),\n\t\tcpu_to_le32(SF_TX_RE_IDLE_TIMER)\n\t},\n};\n\nstatic void iwl_mvm_fill_sf_command(struct iwl_mvm *mvm,\n\t\t\t\t    struct iwl_sf_cfg_cmd *sf_cmd,\n\t\t\t\t    struct ieee80211_sta *sta)\n{\n\tint i, j, watermark;\n\tu8 max_rx_nss = 0;\n\tbool is_legacy = true;\n\tstruct ieee80211_link_sta *link_sta;\n\tunsigned int link_id;\n\n\tsf_cmd->watermark[SF_LONG_DELAY_ON] = cpu_to_le32(SF_W_MARK_SCAN);\n\n\t \n\tif (sta) {\n\t\t \n\t\trcu_read_lock();\n\t\tfor (link_id = 0; link_id < ARRAY_SIZE(sta->link); link_id++) {\n\t\t\tlink_sta = rcu_dereference(sta->link[link_id]);\n\t\t\tif (!link_sta)\n\t\t\t\tcontinue;\n\n\t\t\tif (link_sta->ht_cap.ht_supported ||\n\t\t\t    link_sta->vht_cap.vht_supported ||\n\t\t\t    link_sta->eht_cap.has_eht ||\n\t\t\t    link_sta->he_cap.has_he) {\n\t\t\t\tis_legacy = false;\n\t\t\t\tmax_rx_nss = max(max_rx_nss, link_sta->rx_nss);\n\t\t\t}\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (!is_legacy) {\n\t\t\tswitch (max_rx_nss) {\n\t\t\tcase 1:\n\t\t\t\twatermark = SF_W_MARK_SISO;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\twatermark = SF_W_MARK_MIMO2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\twatermark = SF_W_MARK_MIMO3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\twatermark = SF_W_MARK_LEGACY;\n\t\t}\n\t \n\t} else {\n\t\twatermark = SF_W_MARK_MIMO2;\n\t}\n\tsf_cmd->watermark[SF_FULL_ON] = cpu_to_le32(watermark);\n\n\tfor (i = 0; i < SF_NUM_SCENARIO; i++) {\n\t\tfor (j = 0; j < SF_NUM_TIMEOUT_TYPES; j++) {\n\t\t\tsf_cmd->long_delay_timeouts[i][j] =\n\t\t\t\t\tcpu_to_le32(SF_LONG_DELAY_AGING_TIMER);\n\t\t}\n\t}\n\n\tif (sta) {\n\t\tBUILD_BUG_ON(sizeof(sf_full_timeout) !=\n\t\t\t     sizeof(__le32) * SF_NUM_SCENARIO *\n\t\t\t     SF_NUM_TIMEOUT_TYPES);\n\n\t\tmemcpy(sf_cmd->full_on_timeouts, sf_full_timeout,\n\t\t       sizeof(sf_full_timeout));\n\t} else {\n\t\tBUILD_BUG_ON(sizeof(sf_full_timeout_def) !=\n\t\t\t     sizeof(__le32) * SF_NUM_SCENARIO *\n\t\t\t     SF_NUM_TIMEOUT_TYPES);\n\n\t\tmemcpy(sf_cmd->full_on_timeouts, sf_full_timeout_def,\n\t\t       sizeof(sf_full_timeout_def));\n\t}\n}\n\nstatic int iwl_mvm_sf_config(struct iwl_mvm *mvm, struct ieee80211_sta *sta,\n\t\t\t     enum iwl_sf_state new_state)\n{\n\tstruct iwl_sf_cfg_cmd sf_cmd = {\n\t\t.state = cpu_to_le32(new_state),\n\t};\n\tint ret = 0;\n\n\t \n\tif (new_state != SF_FULL_ON && mvm->sf_state == new_state)\n\t\treturn 0;\n\n\tswitch (new_state) {\n\tcase SF_UNINIT:\n\t\tiwl_mvm_fill_sf_command(mvm, &sf_cmd, NULL);\n\t\tbreak;\n\tcase SF_FULL_ON:\n\t\tif (!sta) {\n\t\t\tIWL_ERR(mvm,\n\t\t\t\t\"No station: Cannot switch SF to FULL_ON\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tiwl_mvm_fill_sf_command(mvm, &sf_cmd, sta);\n\t\tbreak;\n\tcase SF_INIT_OFF:\n\t\tiwl_mvm_fill_sf_command(mvm, &sf_cmd, NULL);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(1, \"Invalid state: %d. not sending Smart Fifo cmd\\n\",\n\t\t\t  new_state);\n\t\treturn -EINVAL;\n\t}\n\n\tret = iwl_mvm_send_cmd_pdu(mvm, REPLY_SF_CFG_CMD, CMD_ASYNC,\n\t\t\t\t   sizeof(sf_cmd), &sf_cmd);\n\tif (!ret)\n\t\tmvm->sf_state = new_state;\n\n\treturn ret;\n}\n\n \nint iwl_mvm_sf_update(struct iwl_mvm *mvm, struct ieee80211_vif *changed_vif,\n\t\t      bool remove_vif)\n{\n\tenum iwl_sf_state new_state;\n\tstruct iwl_mvm_vif *mvmvif = NULL;\n\tstruct iwl_mvm_active_iface_iterator_data data = {\n\t\t.ignore_vif = changed_vif,\n\t\t.sta_vif_state = SF_UNINIT,\n\t};\n\tstruct ieee80211_sta *sta = NULL;\n\n\t \n\tif (test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status) ||\n\t    (changed_vif && changed_vif->type == NL80211_IFTYPE_P2P_DEVICE))\n\t\treturn 0;\n\n\tieee80211_iterate_active_interfaces_atomic(mvm->hw,\n\t\t\t\t\t\t   IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\t\t   iwl_mvm_bound_iface_iterator,\n\t\t\t\t\t\t   &data);\n\n\t \n\tif (changed_vif && !remove_vif)\n\t\tdata.num_active_macs++;\n\n\tswitch (data.num_active_macs) {\n\tcase 0:\n\t\t \n\t\tnew_state = SF_INIT_OFF;\n\t\tbreak;\n\tcase 1:\n\t\tif (remove_vif) {\n\t\t\t \n\t\t\tnew_state = data.sta_vif_state;\n\t\t\tsta = data.sta_vif_ap_sta;\n\t\t} else {\n\t\t\tif (WARN_ON(!changed_vif))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (changed_vif->type != NL80211_IFTYPE_STATION) {\n\t\t\t\tnew_state = SF_UNINIT;\n\t\t\t} else if (changed_vif->cfg.assoc &&\n\t\t\t\t   changed_vif->bss_conf.dtim_period) {\n\t\t\t\tmvmvif = iwl_mvm_vif_from_mac80211(changed_vif);\n\t\t\t\tsta = mvmvif->ap_sta;\n\t\t\t\tnew_state = SF_FULL_ON;\n\t\t\t} else {\n\t\t\t\tnew_state = SF_INIT_OFF;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tnew_state = SF_UNINIT;\n\t}\n\n\treturn iwl_mvm_sf_config(mvm, sta, new_state);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}