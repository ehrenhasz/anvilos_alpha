{
  "module_name": "offloading.c",
  "hash_id": "532ef7a57ee69d5d44650cda14c587b4831e2f12aa7c1d4827e1547f6b155fc0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/offloading.c",
  "human_readable_source": "\n \n#include <net/ipv6.h>\n#include <net/addrconf.h>\n#include <linux/bitops.h>\n#include \"mvm.h\"\n\nvoid iwl_mvm_set_wowlan_qos_seq(struct iwl_mvm_sta *mvm_ap_sta,\n\t\t\t\tstruct iwl_wowlan_config_cmd *cmd)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < IWL_MAX_TID_COUNT; i++) {\n\t\tu16 seq = mvm_ap_sta->tid_data[i].seq_number;\n\t\tseq -= 0x10;\n\t\tcmd->qos_seq[i] = cpu_to_le16(seq);\n\t}\n}\n\nint iwl_mvm_send_proto_offload(struct iwl_mvm *mvm,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       bool disable_offloading,\n\t\t\t       bool offload_ns,\n\t\t\t       u32 cmd_flags)\n{\n\tunion {\n\t\tstruct iwl_proto_offload_cmd_v1 v1;\n\t\tstruct iwl_proto_offload_cmd_v2 v2;\n\t\tstruct iwl_proto_offload_cmd_v3_small v3s;\n\t\tstruct iwl_proto_offload_cmd_v4 v4;\n\t} cmd = {};\n\tstruct iwl_host_cmd hcmd = {\n\t\t.id = PROT_OFFLOAD_CONFIG_CMD,\n\t\t.flags = cmd_flags,\n\t\t.data[0] = &cmd,\n\t\t.dataflags[0] = IWL_HCMD_DFL_DUP,\n\t};\n\tstruct iwl_proto_offload_cmd_common *common;\n\tu32 enabled = 0, size;\n\tu32 capa_flags = mvm->fw->ucode_capa.flags;\n\tint ver = iwl_fw_lookup_cmd_ver(mvm->fw, hcmd.id, 0);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tint i;\n\t \n\tbool skip_tentative = offload_ns;\n\n\tif (capa_flags & IWL_UCODE_TLV_FLAGS_NEW_NSOFFL_SMALL ||\n\t    capa_flags & IWL_UCODE_TLV_FLAGS_NEW_NSOFFL_LARGE) {\n\t\tstruct iwl_ns_config *nsc;\n\t\tstruct iwl_targ_addr *addrs;\n\t\tint n_nsc, n_addrs;\n\t\tint c;\n\t\tint num_skipped = 0;\n\n\t\tif (capa_flags & IWL_UCODE_TLV_FLAGS_NEW_NSOFFL_SMALL) {\n\t\t\tnsc = cmd.v3s.ns_config;\n\t\t\tn_nsc = IWL_PROTO_OFFLOAD_NUM_NS_CONFIG_V3S;\n\t\t\taddrs = cmd.v3s.targ_addrs;\n\t\t\tn_addrs = IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS_V3S;\n\t\t} else {\n\t\t\tnsc = cmd.v4.ns_config;\n\t\t\tn_nsc = IWL_PROTO_OFFLOAD_NUM_NS_CONFIG_V3L;\n\t\t\taddrs = cmd.v4.targ_addrs;\n\t\t\tn_addrs = IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS_V3L;\n\t\t}\n\n\t\t \n\t\tfor (i = 0, c = 0;\n\t\t     i < mvmvif->num_target_ipv6_addrs &&\n\t\t     i < n_addrs && c < n_nsc; i++) {\n\t\t\tstruct in6_addr solicited_addr;\n\t\t\tint j;\n\n\t\t\tif (skip_tentative &&\n\t\t\t    test_bit(i, mvmvif->tentative_addrs)) {\n\t\t\t\tnum_skipped++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\taddrconf_addr_solict_mult(&mvmvif->target_ipv6_addrs[i],\n\t\t\t\t\t\t  &solicited_addr);\n\t\t\tfor (j = 0; j < c; j++)\n\t\t\t\tif (ipv6_addr_cmp(&nsc[j].dest_ipv6_addr,\n\t\t\t\t\t\t  &solicited_addr) == 0)\n\t\t\t\t\tbreak;\n\t\t\tif (j == c)\n\t\t\t\tc++;\n\t\t\taddrs[i].addr = mvmvif->target_ipv6_addrs[i];\n\t\t\taddrs[i].config_num = cpu_to_le32(j);\n\t\t\tnsc[j].dest_ipv6_addr = solicited_addr;\n\t\t\tmemcpy(nsc[j].target_mac_addr, vif->addr, ETH_ALEN);\n\t\t}\n\n\t\tif (mvmvif->num_target_ipv6_addrs - num_skipped)\n\t\t\tenabled |= IWL_D3_PROTO_IPV6_VALID;\n\n\t\tif (capa_flags & IWL_UCODE_TLV_FLAGS_NEW_NSOFFL_SMALL)\n\t\t\tcmd.v3s.num_valid_ipv6_addrs =\n\t\t\t\tcpu_to_le32(i - num_skipped);\n\t\telse\n\t\t\tcmd.v4.num_valid_ipv6_addrs =\n\t\t\t\tcpu_to_le32(i - num_skipped);\n\t} else if (capa_flags & IWL_UCODE_TLV_FLAGS_D3_6_IPV6_ADDRS) {\n\t\tbool found = false;\n\n\t\tBUILD_BUG_ON(sizeof(cmd.v2.target_ipv6_addr[0]) !=\n\t\t\t     sizeof(mvmvif->target_ipv6_addrs[0]));\n\n\t\tfor (i = 0; i < min(mvmvif->num_target_ipv6_addrs,\n\t\t\t\t    IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS_V2); i++) {\n\t\t\tif (skip_tentative &&\n\t\t\t    test_bit(i, mvmvif->tentative_addrs))\n\t\t\t\tcontinue;\n\n\t\t\tmemcpy(cmd.v2.target_ipv6_addr[i],\n\t\t\t       &mvmvif->target_ipv6_addrs[i],\n\t\t\t       sizeof(cmd.v2.target_ipv6_addr[i]));\n\n\t\t\tfound = true;\n\t\t}\n\t\tif (found) {\n\t\t\tenabled |= IWL_D3_PROTO_IPV6_VALID;\n\t\t\tmemcpy(cmd.v2.ndp_mac_addr, vif->addr, ETH_ALEN);\n\t\t}\n\t} else {\n\t\tbool found = false;\n\t\tBUILD_BUG_ON(sizeof(cmd.v1.target_ipv6_addr[0]) !=\n\t\t\t     sizeof(mvmvif->target_ipv6_addrs[0]));\n\n\t\tfor (i = 0; i < min(mvmvif->num_target_ipv6_addrs,\n\t\t\t\t    IWL_PROTO_OFFLOAD_NUM_IPV6_ADDRS_V1); i++) {\n\t\t\tif (skip_tentative &&\n\t\t\t    test_bit(i, mvmvif->tentative_addrs))\n\t\t\t\tcontinue;\n\n\t\t\tmemcpy(cmd.v1.target_ipv6_addr[i],\n\t\t\t       &mvmvif->target_ipv6_addrs[i],\n\t\t\t       sizeof(cmd.v1.target_ipv6_addr[i]));\n\n\t\t\tfound = true;\n\t\t}\n\n\t\tif (found) {\n\t\t\tenabled |= IWL_D3_PROTO_IPV6_VALID;\n\t\t\tmemcpy(cmd.v1.ndp_mac_addr, vif->addr, ETH_ALEN);\n\t\t}\n\t}\n\n\tif (offload_ns && (enabled & IWL_D3_PROTO_IPV6_VALID))\n\t\tenabled |= IWL_D3_PROTO_OFFLOAD_NS;\n#endif\n\tif (capa_flags & IWL_UCODE_TLV_FLAGS_NEW_NSOFFL_SMALL) {\n\t\tcommon = &cmd.v3s.common;\n\t\tsize = sizeof(cmd.v3s);\n\t} else if (capa_flags & IWL_UCODE_TLV_FLAGS_NEW_NSOFFL_LARGE) {\n\t\tcommon = &cmd.v4.common;\n\t\tsize = sizeof(cmd.v4);\n\t\tif (ver < 4) {\n\t\t\t \n\t\t\tsize -= sizeof(cmd.v4.sta_id);\n\t\t\thcmd.data[0] = common;\n\t\t}\n\t} else if (capa_flags & IWL_UCODE_TLV_FLAGS_D3_6_IPV6_ADDRS) {\n\t\tcommon = &cmd.v2.common;\n\t\tsize = sizeof(cmd.v2);\n\t} else {\n\t\tcommon = &cmd.v1.common;\n\t\tsize = sizeof(cmd.v1);\n\t}\n\n\tif (vif->cfg.arp_addr_cnt) {\n\t\tenabled |= IWL_D3_PROTO_OFFLOAD_ARP | IWL_D3_PROTO_IPV4_VALID;\n\t\tcommon->host_ipv4_addr = vif->cfg.arp_addr_list[0];\n\t\tmemcpy(common->arp_mac_addr, vif->addr, ETH_ALEN);\n\t}\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_OFFLOAD_BTM_SUPPORT))\n\t\tenabled |= IWL_D3_PROTO_OFFLOAD_BTM;\n\n\tif (!disable_offloading)\n\t\tcommon->enabled = cpu_to_le32(enabled);\n\n\thcmd.len[0] = size;\n\treturn iwl_mvm_send_cmd(mvm, &hcmd);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}