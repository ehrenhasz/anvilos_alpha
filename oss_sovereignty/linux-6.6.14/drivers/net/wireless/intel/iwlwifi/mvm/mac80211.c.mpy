{
  "module_name": "mac80211.c",
  "hash_id": "999ee8dc31535c86c5c9f2bf9a2ba75d88c8c89dc3464816ea089ff759ec3d9a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/mac80211.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ip.h>\n#include <linux/if_arp.h>\n#include <linux/time.h>\n#include <net/mac80211.h>\n#include <net/ieee80211_radiotap.h>\n#include <net/tcp.h>\n\n#include \"iwl-drv.h\"\n#include \"iwl-op-mode.h\"\n#include \"iwl-io.h\"\n#include \"mvm.h\"\n#include \"sta.h\"\n#include \"time-event.h\"\n#include \"iwl-eeprom-parse.h\"\n#include \"iwl-phy-db.h\"\n#include \"testmode.h\"\n#include \"fw/error-dump.h\"\n#include \"iwl-prph.h\"\n#include \"iwl-nvm-parse.h\"\n#include \"time-sync.h\"\n\nstatic const struct ieee80211_iface_limit iwl_mvm_limits[] = {\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_STATION),\n\t},\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_AP) |\n\t\t\tBIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\t\tBIT(NL80211_IFTYPE_P2P_GO),\n\t},\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_P2P_DEVICE),\n\t},\n};\n\nstatic const struct ieee80211_iface_combination iwl_mvm_iface_combinations[] = {\n\t{\n\t\t.num_different_channels = 2,\n\t\t.max_interfaces = 3,\n\t\t.limits = iwl_mvm_limits,\n\t\t.n_limits = ARRAY_SIZE(iwl_mvm_limits),\n\t},\n};\n\nstatic const struct cfg80211_pmsr_capabilities iwl_mvm_pmsr_capa = {\n\t.max_peers = IWL_MVM_TOF_MAX_APS,\n\t.report_ap_tsf = 1,\n\t.randomize_mac_addr = 1,\n\n\t.ftm = {\n\t\t.supported = 1,\n\t\t.asap = 1,\n\t\t.non_asap = 1,\n\t\t.request_lci = 1,\n\t\t.request_civicloc = 1,\n\t\t.trigger_based = 1,\n\t\t.non_trigger_based = 1,\n\t\t.max_bursts_exponent = -1,  \n\t\t.max_ftms_per_burst = 0,  \n\t\t.bandwidths = BIT(NL80211_CHAN_WIDTH_20_NOHT) |\n\t\t\t      BIT(NL80211_CHAN_WIDTH_20) |\n\t\t\t      BIT(NL80211_CHAN_WIDTH_40) |\n\t\t\t      BIT(NL80211_CHAN_WIDTH_80) |\n\t\t\t      BIT(NL80211_CHAN_WIDTH_160),\n\t\t.preambles = BIT(NL80211_PREAMBLE_LEGACY) |\n\t\t\t     BIT(NL80211_PREAMBLE_HT) |\n\t\t\t     BIT(NL80211_PREAMBLE_VHT) |\n\t\t\t     BIT(NL80211_PREAMBLE_HE),\n\t},\n};\n\nstatic int __iwl_mvm_mac_set_key(struct ieee80211_hw *hw,\n\t\t\t\t enum set_key_cmd cmd,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t struct ieee80211_key_conf *key);\n\nstatic void iwl_mvm_reset_phy_ctxts(struct iwl_mvm *mvm)\n{\n\tint i;\n\n\tmemset(mvm->phy_ctxts, 0, sizeof(mvm->phy_ctxts));\n\tfor (i = 0; i < NUM_PHY_CTX; i++) {\n\t\tmvm->phy_ctxts[i].id = i;\n\t\tmvm->phy_ctxts[i].ref = 0;\n\t}\n}\n\nstruct ieee80211_regdomain *iwl_mvm_get_regdomain(struct wiphy *wiphy,\n\t\t\t\t\t\t  const char *alpha2,\n\t\t\t\t\t\t  enum iwl_mcc_source src_id,\n\t\t\t\t\t\t  bool *changed)\n{\n\tstruct ieee80211_regdomain *regd = NULL;\n\tstruct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mcc_update_resp_v8 *resp;\n\tu8 resp_ver;\n\n\tIWL_DEBUG_LAR(mvm, \"Getting regdomain data for %s from FW\\n\", alpha2);\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tresp = iwl_mvm_update_mcc(mvm, alpha2, src_id);\n\tif (IS_ERR_OR_NULL(resp)) {\n\t\tIWL_DEBUG_LAR(mvm, \"Could not get update from FW %d\\n\",\n\t\t\t      PTR_ERR_OR_ZERO(resp));\n\t\tresp = NULL;\n\t\tgoto out;\n\t}\n\n\tif (changed) {\n\t\tu32 status = le32_to_cpu(resp->status);\n\n\t\t*changed = (status == MCC_RESP_NEW_CHAN_PROFILE ||\n\t\t\t    status == MCC_RESP_ILLEGAL);\n\t}\n\tresp_ver = iwl_fw_lookup_notif_ver(mvm->fw, IWL_ALWAYS_LONG_GROUP,\n\t\t\t\t\t   MCC_UPDATE_CMD, 0);\n\tIWL_DEBUG_LAR(mvm, \"MCC update response version: %d\\n\", resp_ver);\n\n\tregd = iwl_parse_nvm_mcc_info(mvm->trans->dev, mvm->cfg,\n\t\t\t\t      __le32_to_cpu(resp->n_channels),\n\t\t\t\t      resp->channels,\n\t\t\t\t      __le16_to_cpu(resp->mcc),\n\t\t\t\t      __le16_to_cpu(resp->geo_info),\n\t\t\t\t      le32_to_cpu(resp->cap), resp_ver);\n\t \n\tsrc_id = resp->source_id;\n\tif (IS_ERR_OR_NULL(regd)) {\n\t\tIWL_DEBUG_LAR(mvm, \"Could not get parse update from FW %d\\n\",\n\t\t\t      PTR_ERR_OR_ZERO(regd));\n\t\tgoto out;\n\t}\n\n\tIWL_DEBUG_LAR(mvm, \"setting alpha2 from FW to %s (0x%x, 0x%x) src=%d\\n\",\n\t\t      regd->alpha2, regd->alpha2[0], regd->alpha2[1], src_id);\n\tmvm->lar_regdom_set = true;\n\tmvm->mcc_src = src_id;\n\n\tiwl_mei_set_country_code(__le16_to_cpu(resp->mcc));\n\nout:\n\tkfree(resp);\n\treturn regd;\n}\n\nvoid iwl_mvm_update_changed_regdom(struct iwl_mvm *mvm)\n{\n\tbool changed;\n\tstruct ieee80211_regdomain *regd;\n\n\tif (!iwl_mvm_is_lar_supported(mvm))\n\t\treturn;\n\n\tregd = iwl_mvm_get_current_regdomain(mvm, &changed);\n\tif (!IS_ERR_OR_NULL(regd)) {\n\t\t \n\t\tif (changed)\n\t\t\tregulatory_set_wiphy_regd(mvm->hw->wiphy, regd);\n\n\t\tkfree(regd);\n\t}\n}\n\nstruct ieee80211_regdomain *iwl_mvm_get_current_regdomain(struct iwl_mvm *mvm,\n\t\t\t\t\t\t\t  bool *changed)\n{\n\treturn iwl_mvm_get_regdomain(mvm->hw->wiphy, \"ZZ\",\n\t\t\t\t     iwl_mvm_is_wifi_mcc_supported(mvm) ?\n\t\t\t\t     MCC_SOURCE_GET_CURRENT :\n\t\t\t\t     MCC_SOURCE_OLD_FW, changed);\n}\n\nint iwl_mvm_init_fw_regd(struct iwl_mvm *mvm)\n{\n\tenum iwl_mcc_source used_src;\n\tstruct ieee80211_regdomain *regd;\n\tint ret;\n\tbool changed;\n\tconst struct ieee80211_regdomain *r =\n\t\t\twiphy_dereference(mvm->hw->wiphy, mvm->hw->wiphy->regd);\n\n\tif (!r)\n\t\treturn -ENOENT;\n\n\t \n\tused_src = mvm->mcc_src;\n\tif (iwl_mvm_is_wifi_mcc_supported(mvm)) {\n\t\t \n\t\tregd = iwl_mvm_get_current_regdomain(mvm, NULL);\n\t\tif (!IS_ERR_OR_NULL(regd))\n\t\t\tkfree(regd);\n\t}\n\n\t \n\tregd = iwl_mvm_get_regdomain(mvm->hw->wiphy, r->alpha2, used_src,\n\t\t\t\t     &changed);\n\tif (IS_ERR_OR_NULL(regd))\n\t\treturn -EIO;\n\n\t \n\tif (changed)\n\t\tret = regulatory_set_wiphy_regd_sync(mvm->hw->wiphy, regd);\n\telse\n\t\tret = 0;\n\n\tkfree(regd);\n\treturn ret;\n}\n\n \nstatic const u8 he_if_types_ext_capa_sta[] = {\n\t [0] = WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING,\n\t [2] = WLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT,\n\t [7] = WLAN_EXT_CAPA8_OPMODE_NOTIF |\n\t       WLAN_EXT_CAPA8_MAX_MSDU_IN_AMSDU_LSB,\n\t [8] = WLAN_EXT_CAPA9_MAX_MSDU_IN_AMSDU_MSB,\n};\n\nstatic const u8 tm_if_types_ext_capa_sta[] = {\n\t [0] = WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING,\n\t [2] = WLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT |\n\t       WLAN_EXT_CAPA3_TIMING_MEASUREMENT_SUPPORT,\n\t [7] = WLAN_EXT_CAPA8_OPMODE_NOTIF |\n\t       WLAN_EXT_CAPA8_MAX_MSDU_IN_AMSDU_LSB,\n\t [8] = WLAN_EXT_CAPA9_MAX_MSDU_IN_AMSDU_MSB,\n\t [9] = WLAN_EXT_CAPA10_TWT_REQUESTER_SUPPORT,\n};\n\n \n\n#define IWL_MVM_EMLSR_CAPA\t(IEEE80211_EML_CAP_EMLSR_SUPP | \\\n\t\t\t\t IEEE80211_EML_CAP_EMLSR_PADDING_DELAY_32US << \\\n\t\t\t\t\t__bf_shf(IEEE80211_EML_CAP_EMLSR_PADDING_DELAY) | \\\n\t\t\t\t IEEE80211_EML_CAP_EMLSR_TRANSITION_DELAY_64US << \\\n\t\t\t\t\t__bf_shf(IEEE80211_EML_CAP_EMLSR_TRANSITION_DELAY))\n\nstatic const struct wiphy_iftype_ext_capab add_iftypes_ext_capa[] = {\n\t{\n\t\t.iftype = NL80211_IFTYPE_STATION,\n\t\t.extended_capabilities = he_if_types_ext_capa_sta,\n\t\t.extended_capabilities_mask = he_if_types_ext_capa_sta,\n\t\t.extended_capabilities_len = sizeof(he_if_types_ext_capa_sta),\n\t\t \n\t\t.eml_capabilities = IWL_MVM_EMLSR_CAPA,\n\t},\n\t{\n\t\t.iftype = NL80211_IFTYPE_STATION,\n\t\t.extended_capabilities = tm_if_types_ext_capa_sta,\n\t\t.extended_capabilities_mask = tm_if_types_ext_capa_sta,\n\t\t.extended_capabilities_len = sizeof(tm_if_types_ext_capa_sta),\n\t\t \n\t\t.eml_capabilities = IWL_MVM_EMLSR_CAPA,\n\t},\n};\n\nint iwl_mvm_op_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\t*tx_ant = iwl_mvm_get_valid_tx_ant(mvm);\n\t*rx_ant = iwl_mvm_get_valid_rx_ant(mvm);\n\treturn 0;\n}\n\nint iwl_mvm_mac_setup_register(struct iwl_mvm *mvm)\n{\n\tstruct ieee80211_hw *hw = mvm->hw;\n\tint num_mac, ret, i;\n\tstatic const u32 mvm_ciphers[] = {\n\t\tWLAN_CIPHER_SUITE_WEP40,\n\t\tWLAN_CIPHER_SUITE_WEP104,\n\t\tWLAN_CIPHER_SUITE_TKIP,\n\t\tWLAN_CIPHER_SUITE_CCMP,\n\t};\n#ifdef CONFIG_PM_SLEEP\n\tbool unified = fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t\t   IWL_UCODE_TLV_CAPA_CNSLDTD_D3_D0_IMG);\n#endif\n\tu32 sec_key_id = WIDE_ID(DATA_PATH_GROUP, SEC_KEY_CMD);\n\tu8 sec_key_ver = iwl_fw_lookup_cmd_ver(mvm->fw, sec_key_id, 0);\n\n\t \n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\tieee80211_hw_set(hw, SPECTRUM_MGMT);\n\tieee80211_hw_set(hw, REPORTS_TX_ACK_STATUS);\n\tieee80211_hw_set(hw, WANT_MONITOR_VIF);\n\tieee80211_hw_set(hw, SUPPORTS_PS);\n\tieee80211_hw_set(hw, SUPPORTS_DYNAMIC_PS);\n\tieee80211_hw_set(hw, AMPDU_AGGREGATION);\n\tieee80211_hw_set(hw, CONNECTION_MONITOR);\n\tieee80211_hw_set(hw, CHANCTX_STA_CSA);\n\tieee80211_hw_set(hw, SUPPORT_FAST_XMIT);\n\tieee80211_hw_set(hw, SUPPORTS_CLONED_SKBS);\n\tieee80211_hw_set(hw, SUPPORTS_AMSDU_IN_AMPDU);\n\tieee80211_hw_set(hw, NEEDS_UNIQUE_STA_ADDR);\n\tieee80211_hw_set(hw, SUPPORTS_VHT_EXT_NSS_BW);\n\tieee80211_hw_set(hw, BUFF_MMPDU_TXQ);\n\tieee80211_hw_set(hw, STA_MMPDU_TXQ);\n\n\t \n\tif (mvm->mld_api_is_used && mvm->nvm_data->sku_cap_11be_enable &&\n\t    !iwlwifi_mod_params.disable_11ax &&\n\t    !iwlwifi_mod_params.disable_11be)\n\t\thw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_MLO;\n\n\t \n\tif (!mvm->mld_api_is_used)\n\t\tieee80211_hw_set(hw, TIMING_BEACON_ONLY);\n\n\t \n\tif (!(hw->wiphy->flags & WIPHY_FLAG_SUPPORTS_MLO))\n\t\tieee80211_hw_set(hw, DEAUTH_NEED_MGD_TX_PREP);\n\n\t \n\tif (mvm->trans->trans_cfg->device_family >= IWL_DEVICE_FAMILY_9000)\n\t\tieee80211_hw_set(hw, TX_AMSDU);\n\tieee80211_hw_set(hw, TX_FRAG_LIST);\n\n\tif (iwl_mvm_has_tlc_offload(mvm)) {\n\t\tieee80211_hw_set(hw, TX_AMPDU_SETUP_IN_HW);\n\t\tieee80211_hw_set(hw, HAS_RATE_CONTROL);\n\t}\n\n\tif (iwl_mvm_has_new_rx_api(mvm))\n\t\tieee80211_hw_set(hw, SUPPORTS_REORDERING_BUFFER);\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_STA_PM_NOTIF)) {\n\t\tieee80211_hw_set(hw, AP_LINK_PS);\n\t} else if (WARN_ON(iwl_mvm_has_new_tx_api(mvm))) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tif (mvm->trans->num_rx_queues > 1)\n\t\tieee80211_hw_set(hw, USES_RSS);\n\n\tif (mvm->trans->max_skb_frags)\n\t\thw->netdev_features = NETIF_F_HIGHDMA | NETIF_F_SG;\n\n\thw->queues = IEEE80211_NUM_ACS;\n\thw->offchannel_tx_hw_queue = IWL_MVM_OFFCHANNEL_QUEUE;\n\thw->radiotap_mcs_details |= IEEE80211_RADIOTAP_MCS_HAVE_FEC |\n\t\t\t\t    IEEE80211_RADIOTAP_MCS_HAVE_STBC;\n\thw->radiotap_vht_details |= IEEE80211_RADIOTAP_VHT_KNOWN_STBC |\n\t\tIEEE80211_RADIOTAP_VHT_KNOWN_BEAMFORMED;\n\n\thw->radiotap_timestamp.units_pos =\n\t\tIEEE80211_RADIOTAP_TIMESTAMP_UNIT_US |\n\t\tIEEE80211_RADIOTAP_TIMESTAMP_SPOS_PLCP_SIG_ACQ;\n\t \n\thw->radiotap_timestamp.accuracy = 22;\n\n\tif (!iwl_mvm_has_tlc_offload(mvm))\n\t\thw->rate_control_algorithm = RS_NAME;\n\n\thw->uapsd_queues = IWL_MVM_UAPSD_QUEUES;\n\thw->uapsd_max_sp_len = IWL_UAPSD_MAX_SP;\n\thw->max_tx_fragments = mvm->trans->max_skb_frags;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(mvm->ciphers) < ARRAY_SIZE(mvm_ciphers) + 6);\n\tmemcpy(mvm->ciphers, mvm_ciphers, sizeof(mvm_ciphers));\n\thw->wiphy->n_cipher_suites = ARRAY_SIZE(mvm_ciphers);\n\thw->wiphy->cipher_suites = mvm->ciphers;\n\n\tif (iwl_mvm_has_new_rx_api(mvm)) {\n\t\tmvm->ciphers[hw->wiphy->n_cipher_suites] =\n\t\t\tWLAN_CIPHER_SUITE_GCMP;\n\t\thw->wiphy->n_cipher_suites++;\n\t\tmvm->ciphers[hw->wiphy->n_cipher_suites] =\n\t\t\tWLAN_CIPHER_SUITE_GCMP_256;\n\t\thw->wiphy->n_cipher_suites++;\n\t}\n\n\tif (iwlwifi_mod_params.swcrypto)\n\t\tIWL_ERR(mvm,\n\t\t\t\"iwlmvm doesn't allow to disable HW crypto, check swcrypto module parameter\\n\");\n\tif (!iwlwifi_mod_params.bt_coex_active)\n\t\tIWL_ERR(mvm,\n\t\t\t\"iwlmvm doesn't allow to disable BT Coex, check bt_coex_active module parameter\\n\");\n\n\tieee80211_hw_set(hw, MFP_CAPABLE);\n\tmvm->ciphers[hw->wiphy->n_cipher_suites] = WLAN_CIPHER_SUITE_AES_CMAC;\n\thw->wiphy->n_cipher_suites++;\n\tif (iwl_mvm_has_new_rx_api(mvm)) {\n\t\tmvm->ciphers[hw->wiphy->n_cipher_suites] =\n\t\t\tWLAN_CIPHER_SUITE_BIP_GMAC_128;\n\t\thw->wiphy->n_cipher_suites++;\n\t\tmvm->ciphers[hw->wiphy->n_cipher_suites] =\n\t\t\tWLAN_CIPHER_SUITE_BIP_GMAC_256;\n\t\thw->wiphy->n_cipher_suites++;\n\t}\n\n\twiphy_ext_feature_set(hw->wiphy,\n\t\t\t      NL80211_EXT_FEATURE_BEACON_RATE_LEGACY);\n\twiphy_ext_feature_set(hw->wiphy,\n\t\t\t      NL80211_EXT_FEATURE_SCAN_MIN_PREQ_CONTENT);\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_FTM_CALIBRATED)) {\n\t\twiphy_ext_feature_set(hw->wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER);\n\t\thw->wiphy->pmsr_capa = &iwl_mvm_pmsr_capa;\n\t}\n\n\tif (sec_key_ver &&\n\t    fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_BIGTK_TX_SUPPORT))\n\t\twiphy_ext_feature_set(hw->wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_BEACON_PROTECTION);\n\telse if (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t     IWL_UCODE_TLV_CAPA_BIGTK_SUPPORT))\n\t\twiphy_ext_feature_set(hw->wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_BEACON_PROTECTION_CLIENT);\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_TIME_SYNC_BOTH_FTM_TM))\n\t\thw->wiphy->hw_timestamp_max_peers = 1;\n\n\tieee80211_hw_set(hw, SINGLE_SCAN_ON_ALL_BANDS);\n\thw->wiphy->features |=\n\t\tNL80211_FEATURE_SCHED_SCAN_RANDOM_MAC_ADDR |\n\t\tNL80211_FEATURE_SCAN_RANDOM_MAC_ADDR |\n\t\tNL80211_FEATURE_ND_RANDOM_MAC_ADDR;\n\n\thw->sta_data_size = sizeof(struct iwl_mvm_sta);\n\thw->vif_data_size = sizeof(struct iwl_mvm_vif);\n\thw->chanctx_data_size = sizeof(u16);\n\thw->txq_data_size = sizeof(struct iwl_mvm_txq);\n\n\thw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\tBIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\tBIT(NL80211_IFTYPE_AP) |\n\t\tBIT(NL80211_IFTYPE_P2P_GO) |\n\t\tBIT(NL80211_IFTYPE_P2P_DEVICE) |\n\t\tBIT(NL80211_IFTYPE_ADHOC);\n\n\thw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_VHT_IBSS);\n\n\t \n\tif (!iwl_mvm_has_new_tx_api(mvm))\n\t\twiphy_ext_feature_set(hw->wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_EXT_KEY_ID);\n\thw->wiphy->features |= NL80211_FEATURE_HT_IBSS;\n\n\thw->wiphy->regulatory_flags |= REGULATORY_ENABLE_RELAX_NO_IR;\n\tif (iwl_mvm_is_lar_supported(mvm))\n\t\thw->wiphy->regulatory_flags |= REGULATORY_WIPHY_SELF_MANAGED;\n\telse\n\t\thw->wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG |\n\t\t\t\t\t       REGULATORY_DISABLE_BEACON_HINTS;\n\n\thw->wiphy->flags |= WIPHY_FLAG_AP_UAPSD;\n\thw->wiphy->flags |= WIPHY_FLAG_HAS_CHANNEL_SWITCH;\n\thw->wiphy->flags |= WIPHY_FLAG_SPLIT_SCAN_6GHZ;\n\n\thw->wiphy->iface_combinations = iwl_mvm_iface_combinations;\n\thw->wiphy->n_iface_combinations =\n\t\tARRAY_SIZE(iwl_mvm_iface_combinations);\n\n\thw->wiphy->max_remain_on_channel_duration = 10000;\n\thw->max_listen_interval = IWL_CONN_MAX_LISTEN_INTERVAL;\n\n\t \n\tmemcpy(mvm->addresses[0].addr, mvm->nvm_data->hw_addr, ETH_ALEN);\n\thw->wiphy->addresses = mvm->addresses;\n\thw->wiphy->n_addresses = 1;\n\n\t \n\tnum_mac = (mvm->nvm_data->n_hw_addrs > 1) ?\n\t\tmin(IWL_MVM_MAX_ADDRESSES, mvm->nvm_data->n_hw_addrs) : 1;\n\n\tfor (i = 1; i < num_mac; i++) {\n\t\tmemcpy(mvm->addresses[i].addr, mvm->addresses[i-1].addr,\n\t\t       ETH_ALEN);\n\t\tmvm->addresses[i].addr[5]++;\n\t\thw->wiphy->n_addresses++;\n\t}\n\n\tiwl_mvm_reset_phy_ctxts(mvm);\n\n\thw->wiphy->max_scan_ie_len = iwl_mvm_max_scan_ie_len(mvm);\n\n\thw->wiphy->max_scan_ssids = PROBE_OPTION_MAX;\n\n\tBUILD_BUG_ON(IWL_MVM_SCAN_STOPPING_MASK & IWL_MVM_SCAN_MASK);\n\tBUILD_BUG_ON(IWL_MVM_MAX_UMAC_SCANS > HWEIGHT32(IWL_MVM_SCAN_MASK) ||\n\t\t     IWL_MVM_MAX_LMAC_SCANS > HWEIGHT32(IWL_MVM_SCAN_MASK));\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa, IWL_UCODE_TLV_CAPA_UMAC_SCAN))\n\t\tmvm->max_scans = IWL_MVM_MAX_UMAC_SCANS;\n\telse\n\t\tmvm->max_scans = IWL_MVM_MAX_LMAC_SCANS;\n\n\tif (mvm->nvm_data->bands[NL80211_BAND_2GHZ].n_channels)\n\t\thw->wiphy->bands[NL80211_BAND_2GHZ] =\n\t\t\t&mvm->nvm_data->bands[NL80211_BAND_2GHZ];\n\tif (mvm->nvm_data->bands[NL80211_BAND_5GHZ].n_channels) {\n\t\thw->wiphy->bands[NL80211_BAND_5GHZ] =\n\t\t\t&mvm->nvm_data->bands[NL80211_BAND_5GHZ];\n\n\t\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t\tIWL_UCODE_TLV_CAPA_BEAMFORMER) &&\n\t\t    fw_has_api(&mvm->fw->ucode_capa,\n\t\t\t       IWL_UCODE_TLV_API_LQ_SS_PARAMS))\n\t\t\thw->wiphy->bands[NL80211_BAND_5GHZ]->vht_cap.cap |=\n\t\t\t\tIEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE;\n\t}\n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_PSC_CHAN_SUPPORT) &&\n\t    mvm->nvm_data->bands[NL80211_BAND_6GHZ].n_channels)\n\t\thw->wiphy->bands[NL80211_BAND_6GHZ] =\n\t\t\t&mvm->nvm_data->bands[NL80211_BAND_6GHZ];\n\n\thw->wiphy->hw_version = mvm->trans->hw_id;\n\n\tif (iwlmvm_mod_params.power_scheme != IWL_POWER_SCHEME_CAM)\n\t\thw->wiphy->flags |= WIPHY_FLAG_PS_ON_BY_DEFAULT;\n\telse\n\t\thw->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;\n\n\thw->wiphy->max_sched_scan_reqs = 1;\n\thw->wiphy->max_sched_scan_ssids = PROBE_OPTION_MAX;\n\thw->wiphy->max_match_sets = iwl_umac_scan_get_max_profiles(mvm->fw);\n\t \n\thw->wiphy->max_sched_scan_ie_len =\n\t\tSCAN_OFFLOAD_PROBE_REQ_SIZE - 24 - 2;\n\thw->wiphy->max_sched_scan_plans = IWL_MAX_SCHED_SCAN_PLANS;\n\thw->wiphy->max_sched_scan_plan_interval = U16_MAX;\n\n\t \n\thw->wiphy->max_sched_scan_plan_iterations = 254;\n\n\thw->wiphy->features |= NL80211_FEATURE_P2P_GO_CTWIN |\n\t\t\t       NL80211_FEATURE_LOW_PRIORITY_SCAN |\n\t\t\t       NL80211_FEATURE_P2P_GO_OPPPS |\n\t\t\t       NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE |\n\t\t\t       NL80211_FEATURE_DYNAMIC_SMPS |\n\t\t\t       NL80211_FEATURE_STATIC_SMPS |\n\t\t\t       NL80211_FEATURE_SUPPORTS_WMM_ADMISSION;\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_TXPOWER_INSERTION_SUPPORT))\n\t\thw->wiphy->features |= NL80211_FEATURE_TX_POWER_INSERTION;\n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_QUIET_PERIOD_SUPPORT))\n\t\thw->wiphy->features |= NL80211_FEATURE_QUIET;\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_DS_PARAM_SET_IE_SUPPORT))\n\t\thw->wiphy->features |=\n\t\t\tNL80211_FEATURE_DS_PARAM_SET_IE_IN_PROBES;\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_WFA_TPC_REP_IE_SUPPORT))\n\t\thw->wiphy->features |= NL80211_FEATURE_WFA_TPC_IE_IN_PROBES;\n\n\tif (iwl_fw_lookup_cmd_ver(mvm->fw, WOWLAN_KEK_KCK_MATERIAL,\n\t\t\t\t  IWL_FW_CMD_VER_UNKNOWN) == 3)\n\t\thw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_EXT_KEK_KCK;\n\n\tif (fw_has_api(&mvm->fw->ucode_capa,\n\t\t       IWL_UCODE_TLV_API_SCAN_TSF_REPORT)) {\n\t\twiphy_ext_feature_set(hw->wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_SCAN_START_TIME);\n\t\twiphy_ext_feature_set(hw->wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_BSS_PARENT_TSF);\n\t}\n\n\tif (iwl_mvm_is_oce_supported(mvm)) {\n\t\tu8 scan_ver = iwl_fw_lookup_cmd_ver(mvm->fw, SCAN_REQ_UMAC, 0);\n\n\t\twiphy_ext_feature_set(hw->wiphy,\n\t\t\tNL80211_EXT_FEATURE_ACCEPT_BCAST_PROBE_RESP);\n\t\twiphy_ext_feature_set(hw->wiphy,\n\t\t\tNL80211_EXT_FEATURE_FILS_MAX_CHANNEL_TIME);\n\t\twiphy_ext_feature_set(hw->wiphy,\n\t\t\tNL80211_EXT_FEATURE_OCE_PROBE_REQ_HIGH_TX_RATE);\n\n\t\t \n\t\tif (scan_ver < 15)\n\t\t\twiphy_ext_feature_set(hw->wiphy,\n\t\t\t\t\t      NL80211_EXT_FEATURE_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION);\n\t}\n\n\thw->wiphy->iftype_ext_capab = NULL;\n\thw->wiphy->num_iftype_ext_capab = 0;\n\n\tif (mvm->nvm_data->sku_cap_11ax_enable &&\n\t    !iwlwifi_mod_params.disable_11ax) {\n\t\thw->wiphy->iftype_ext_capab = add_iftypes_ext_capa;\n\t\thw->wiphy->num_iftype_ext_capab =\n\t\t\tARRAY_SIZE(add_iftypes_ext_capa) - 1;\n\n\t\tieee80211_hw_set(hw, SUPPORTS_MULTI_BSSID);\n\t\tieee80211_hw_set(hw, SUPPORTS_ONLY_HE_MULTI_BSSID);\n\t}\n\n\tif (iwl_fw_lookup_cmd_ver(mvm->fw,\n\t\t\t\t  WIDE_ID(DATA_PATH_GROUP,\n\t\t\t\t\t  WNM_80211V_TIMING_MEASUREMENT_CONFIG_CMD),\n\t\t\t\t  IWL_FW_CMD_VER_UNKNOWN) >= 1) {\n\t\tIWL_DEBUG_INFO(mvm->trans, \"Timing measurement supported\\n\");\n\n\t\tif (!hw->wiphy->iftype_ext_capab) {\n\t\t\thw->wiphy->num_iftype_ext_capab = 1;\n\t\t\thw->wiphy->iftype_ext_capab = add_iftypes_ext_capa +\n\t\t\t\tARRAY_SIZE(add_iftypes_ext_capa) - 1;\n\t\t} else {\n\t\t\thw->wiphy->iftype_ext_capab = add_iftypes_ext_capa + 1;\n\t\t}\n\t}\n\n\tmvm->rts_threshold = IEEE80211_MAX_RTS_THRESHOLD;\n\n#ifdef CONFIG_PM_SLEEP\n\tif ((unified || mvm->fw->img[IWL_UCODE_WOWLAN].num_sec) &&\n\t    mvm->trans->ops->d3_suspend &&\n\t    mvm->trans->ops->d3_resume &&\n\t    device_can_wakeup(mvm->trans->dev)) {\n\t\tmvm->wowlan.flags |= WIPHY_WOWLAN_MAGIC_PKT |\n\t\t\t\t     WIPHY_WOWLAN_DISCONNECT |\n\t\t\t\t     WIPHY_WOWLAN_EAP_IDENTITY_REQ |\n\t\t\t\t     WIPHY_WOWLAN_RFKILL_RELEASE |\n\t\t\t\t     WIPHY_WOWLAN_NET_DETECT;\n\t\tmvm->wowlan.flags |= WIPHY_WOWLAN_SUPPORTS_GTK_REKEY |\n\t\t\t\t     WIPHY_WOWLAN_GTK_REKEY_FAILURE |\n\t\t\t\t     WIPHY_WOWLAN_4WAY_HANDSHAKE;\n\n\t\tmvm->wowlan.n_patterns = IWL_WOWLAN_MAX_PATTERNS;\n\t\tmvm->wowlan.pattern_min_len = IWL_WOWLAN_MIN_PATTERN_LEN;\n\t\tmvm->wowlan.pattern_max_len = IWL_WOWLAN_MAX_PATTERN_LEN;\n\t\tmvm->wowlan.max_nd_match_sets =\n\t\t\tiwl_umac_scan_get_max_profiles(mvm->fw);\n\t\thw->wiphy->wowlan = &mvm->wowlan;\n\t}\n#endif\n\n\tret = iwl_mvm_leds_init(mvm);\n\tif (ret)\n\t\treturn ret;\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_TDLS_SUPPORT)) {\n\t\tIWL_DEBUG_TDLS(mvm, \"TDLS supported\\n\");\n\t\thw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS;\n\t\tieee80211_hw_set(hw, TDLS_WIDER_BW);\n\t}\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_TDLS_CHANNEL_SWITCH)) {\n\t\tIWL_DEBUG_TDLS(mvm, \"TDLS channel switch supported\\n\");\n\t\thw->wiphy->features |= NL80211_FEATURE_TDLS_CHANNEL_SWITCH;\n\t}\n\n\thw->netdev_features |= mvm->cfg->features;\n\tif (!iwl_mvm_is_csum_supported(mvm))\n\t\thw->netdev_features &= ~IWL_CSUM_NETIF_FLAGS_MASK;\n\n\tif (mvm->cfg->vht_mu_mimo_supported)\n\t\twiphy_ext_feature_set(hw->wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_MU_MIMO_AIR_SNIFFER);\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa, IWL_UCODE_TLV_CAPA_PROTECTED_TWT))\n\t\twiphy_ext_feature_set(hw->wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_PROTECTED_TWT);\n\n\tiwl_mvm_vendor_cmds_register(mvm);\n\n\thw->wiphy->available_antennas_tx = iwl_mvm_get_valid_tx_ant(mvm);\n\thw->wiphy->available_antennas_rx = iwl_mvm_get_valid_rx_ant(mvm);\n\n\tret = ieee80211_register_hw(mvm->hw);\n\tif (ret) {\n\t\tiwl_mvm_leds_exit(mvm);\n\t}\n\n\treturn ret;\n}\n\nstatic void iwl_mvm_tx_skb(struct iwl_mvm *mvm, struct sk_buff *skb,\n\t\t\t   struct ieee80211_sta *sta)\n{\n\tif (likely(sta)) {\n\t\tif (likely(iwl_mvm_tx_skb_sta(mvm, skb, sta) == 0))\n\t\t\treturn;\n\t} else {\n\t\tif (likely(iwl_mvm_tx_skb_non_sta(mvm, skb) == 0))\n\t\t\treturn;\n\t}\n\n\tieee80211_free_txskb(mvm->hw, skb);\n}\n\nvoid iwl_mvm_mac_tx(struct ieee80211_hw *hw,\n\t\t    struct ieee80211_tx_control *control, struct sk_buff *skb)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct ieee80211_sta *sta = control->sta;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tbool offchannel = IEEE80211_SKB_CB(skb)->flags &\n\t\tIEEE80211_TX_CTL_TX_OFFCHAN;\n\tu32 link_id = u32_get_bits(info->control.flags,\n\t\t\t\t   IEEE80211_TX_CTRL_MLO_LINK);\n\tstruct ieee80211_sta *tmp_sta = sta;\n\n\tif (iwl_mvm_is_radio_killed(mvm)) {\n\t\tIWL_DEBUG_DROP(mvm, \"Dropping - RF/CT KILL\\n\");\n\t\tgoto drop;\n\t}\n\n\tif (offchannel &&\n\t    !test_bit(IWL_MVM_STATUS_ROC_RUNNING, &mvm->status) &&\n\t    !test_bit(IWL_MVM_STATUS_ROC_AUX_RUNNING, &mvm->status))\n\t\tgoto drop;\n\n\t \n\tif (ieee80211_is_mgmt(hdr->frame_control))\n\t\tsta = NULL;\n\n\t \n\tif (!sta && info->control.vif->type == NL80211_IFTYPE_STATION &&\n\t    !offchannel) {\n\t\tstruct iwl_mvm_vif *mvmvif =\n\t\t\tiwl_mvm_vif_from_mac80211(info->control.vif);\n\t\tu8 ap_sta_id = READ_ONCE(mvmvif->deflink.ap_sta_id);\n\n\t\tif (ap_sta_id < mvm->fw->ucode_capa.num_stations) {\n\t\t\t \n\t\t\tsta = rcu_dereference(mvm->fw_id_to_mac_id[ap_sta_id]);\n\t\t\tif (IS_ERR_OR_NULL(sta))\n\t\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif (tmp_sta && !sta && link_id != IEEE80211_LINK_UNSPECIFIED &&\n\t    !ieee80211_is_probe_resp(hdr->frame_control)) {\n\t\t \n\t\tstruct ieee80211_link_sta *link_sta =\n\t\t\trcu_dereference(tmp_sta->link[link_id]);\n\t\tstruct ieee80211_bss_conf *link_conf =\n\t\t\trcu_dereference(info->control.vif->link_conf[link_id]);\n\t\tstruct ieee80211_mgmt *mgmt;\n\n\t\tif (WARN_ON(!link_sta || !link_conf))\n\t\t\tgoto drop;\n\n\t\t \n\t\tmgmt = (void *)hdr;\n\t\tmemcpy(mgmt->da, link_sta->addr, ETH_ALEN);\n\t\tmemcpy(mgmt->sa, link_conf->addr, ETH_ALEN);\n\t\tmemcpy(mgmt->bssid, link_conf->bssid, ETH_ALEN);\n\t}\n\n\tiwl_mvm_tx_skb(mvm, skb, sta);\n\treturn;\n drop:\n\tieee80211_free_txskb(hw, skb);\n}\n\nvoid iwl_mvm_mac_itxq_xmit(struct ieee80211_hw *hw, struct ieee80211_txq *txq)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_txq *mvmtxq = iwl_mvm_txq_from_mac80211(txq);\n\tstruct sk_buff *skb = NULL;\n\n\t \n\tif (atomic_fetch_add_unless(&mvmtxq->tx_request, 1, 2))\n\t\treturn;\n\n\trcu_read_lock();\n\tdo {\n\t\twhile (likely(!test_bit(IWL_MVM_TXQ_STATE_STOP_FULL,\n\t\t\t\t\t&mvmtxq->state) &&\n\t\t\t      !test_bit(IWL_MVM_TXQ_STATE_STOP_REDIRECT,\n\t\t\t\t\t&mvmtxq->state) &&\n\t\t\t      !test_bit(IWL_MVM_STATUS_IN_D3, &mvm->status))) {\n\t\t\tskb = ieee80211_tx_dequeue(hw, txq);\n\n\t\t\tif (!skb) {\n\t\t\t\tif (txq->sta)\n\t\t\t\t\tIWL_DEBUG_TX(mvm,\n\t\t\t\t\t\t     \"TXQ of sta %pM tid %d is now empty\\n\",\n\t\t\t\t\t\t     txq->sta->addr,\n\t\t\t\t\t\t     txq->tid);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tiwl_mvm_tx_skb(mvm, skb, txq->sta);\n\t\t}\n\t} while (atomic_dec_return(&mvmtxq->tx_request));\n\trcu_read_unlock();\n}\n\nvoid iwl_mvm_mac_wake_tx_queue(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_txq *txq)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_txq *mvmtxq = iwl_mvm_txq_from_mac80211(txq);\n\n\tif (likely(test_bit(IWL_MVM_TXQ_STATE_READY, &mvmtxq->state)) ||\n\t    !txq->sta) {\n\t\tiwl_mvm_mac_itxq_xmit(hw, txq);\n\t\treturn;\n\t}\n\n\t \n\n\tspin_lock_bh(&mvm->add_stream_lock);\n\t \n\tif (list_empty(&mvmtxq->list) &&\n\t     \n\t    !test_bit(IWL_MVM_TXQ_STATE_READY, &mvmtxq->state)) {\n\t\tlist_add_tail(&mvmtxq->list, &mvm->add_stream_txqs);\n\t\tschedule_work(&mvm->add_stream_wk);\n\t}\n\tspin_unlock_bh(&mvm->add_stream_lock);\n}\n\n#define CHECK_BA_TRIGGER(_mvm, _trig, _tid_bm, _tid, _fmt...)\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (!(le16_to_cpu(_tid_bm) & BIT(_tid)))\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tiwl_fw_dbg_collect_trig(&(_mvm)->fwrt, _trig, _fmt);\t\\\n\t} while (0)\n\nstatic void\niwl_mvm_ampdu_check_trigger(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_sta *sta, u16 tid, u16 rx_ba_ssn,\n\t\t\t    enum ieee80211_ampdu_mlme_action action)\n{\n\tstruct iwl_fw_dbg_trigger_tlv *trig;\n\tstruct iwl_fw_dbg_trigger_ba *ba_trig;\n\n\ttrig = iwl_fw_dbg_trigger_on(&mvm->fwrt, ieee80211_vif_to_wdev(vif),\n\t\t\t\t     FW_DBG_TRIGGER_BA);\n\tif (!trig)\n\t\treturn;\n\n\tba_trig = (void *)trig->data;\n\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL: {\n\t\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\t\tstruct iwl_mvm_tid_data *tid_data = &mvmsta->tid_data[tid];\n\n\t\tCHECK_BA_TRIGGER(mvm, trig, ba_trig->tx_ba_start, tid,\n\t\t\t\t \"TX AGG START: MAC %pM tid %d ssn %d\\n\",\n\t\t\t\t sta->addr, tid, tid_data->ssn);\n\t\tbreak;\n\t\t}\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\t\tCHECK_BA_TRIGGER(mvm, trig, ba_trig->tx_ba_stop, tid,\n\t\t\t\t \"TX AGG STOP: MAC %pM tid %d\\n\",\n\t\t\t\t sta->addr, tid);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_START:\n\t\tCHECK_BA_TRIGGER(mvm, trig, ba_trig->rx_ba_start, tid,\n\t\t\t\t \"RX AGG START: MAC %pM tid %d ssn %d\\n\",\n\t\t\t\t sta->addr, tid, rx_ba_ssn);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\tCHECK_BA_TRIGGER(mvm, trig, ba_trig->rx_ba_stop, tid,\n\t\t\t\t \"RX AGG STOP: MAC %pM tid %d\\n\",\n\t\t\t\t sta->addr, tid);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nint iwl_mvm_mac_ampdu_action(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_ampdu_params *params)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tint ret;\n\tstruct ieee80211_sta *sta = params->sta;\n\tenum ieee80211_ampdu_mlme_action action = params->action;\n\tu16 tid = params->tid;\n\tu16 *ssn = &params->ssn;\n\tu16 buf_size = params->buf_size;\n\tbool amsdu = params->amsdu;\n\tu16 timeout = params->timeout;\n\n\tIWL_DEBUG_HT(mvm, \"A-MPDU action on addr %pM tid %d: action %d\\n\",\n\t\t     sta->addr, tid, action);\n\n\tif (!(mvm->nvm_data->sku_cap_11n_enable))\n\t\treturn -EACCES;\n\n\tmutex_lock(&mvm->mutex);\n\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_RX_START:\n\t\tif (iwl_mvm_vif_from_mac80211(vif)->deflink.ap_sta_id ==\n\t\t    iwl_mvm_sta_from_mac80211(sta)->deflink.sta_id) {\n\t\t\tstruct iwl_mvm_vif *mvmvif;\n\t\t\tu16 macid = iwl_mvm_vif_from_mac80211(vif)->id;\n\t\t\tstruct iwl_mvm_tcm_mac *mdata = &mvm->tcm.data[macid];\n\n\t\t\tmdata->opened_rx_ba_sessions = true;\n\t\t\tmvmvif = iwl_mvm_vif_from_mac80211(vif);\n\t\t\tcancel_delayed_work(&mvmvif->uapsd_nonagg_detected_wk);\n\t\t}\n\t\tif (!iwl_enable_rx_ampdu()) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = iwl_mvm_sta_rx_agg(mvm, sta, tid, *ssn, true, buf_size,\n\t\t\t\t\t timeout);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\tret = iwl_mvm_sta_rx_agg(mvm, sta, tid, 0, false, buf_size,\n\t\t\t\t\t timeout);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_START:\n\t\tif (!iwl_enable_tx_ampdu()) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = iwl_mvm_sta_tx_agg_start(mvm, vif, sta, tid, ssn);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\t\tret = iwl_mvm_sta_tx_agg_stop(mvm, vif, sta, tid);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\t\tret = iwl_mvm_sta_tx_agg_flush(mvm, vif, sta, tid);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\tret = iwl_mvm_sta_tx_agg_oper(mvm, vif, sta, tid,\n\t\t\t\t\t      buf_size, amsdu);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (!ret) {\n\t\tu16 rx_ba_ssn = 0;\n\n\t\tif (action == IEEE80211_AMPDU_RX_START)\n\t\t\trx_ba_ssn = *ssn;\n\n\t\tiwl_mvm_ampdu_check_trigger(mvm, vif, sta, tid,\n\t\t\t\t\t    rx_ba_ssn, action);\n\t}\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret;\n}\n\nstatic void iwl_mvm_cleanup_iterator(void *data, u8 *mac,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm *mvm = data;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_probe_resp_data *probe_data;\n\tunsigned int link_id;\n\n\tmvmvif->uploaded = false;\n\n\tspin_lock_bh(&mvm->time_event_lock);\n\tiwl_mvm_te_clear_data(mvm, &mvmvif->time_event_data);\n\tspin_unlock_bh(&mvm->time_event_lock);\n\n\tmemset(&mvmvif->bf_data, 0, sizeof(mvmvif->bf_data));\n\n\tfor_each_mvm_vif_valid_link(mvmvif, link_id) {\n\t\tmvmvif->link[link_id]->ap_sta_id = IWL_MVM_INVALID_STA;\n\t\tmvmvif->link[link_id]->fw_link_id = IWL_MVM_FW_LINK_ID_INVALID;\n\t\tmvmvif->link[link_id]->phy_ctxt = NULL;\n\t\tmvmvif->link[link_id]->active = 0;\n\t\tmvmvif->link[link_id]->igtk = NULL;\n\t}\n\n\tprobe_data = rcu_dereference_protected(mvmvif->deflink.probe_resp_data,\n\t\t\t\t\t       lockdep_is_held(&mvm->mutex));\n\tif (probe_data)\n\t\tkfree_rcu(probe_data, rcu_head);\n\tRCU_INIT_POINTER(mvmvif->deflink.probe_resp_data, NULL);\n}\n\nstatic void iwl_mvm_restart_cleanup(struct iwl_mvm *mvm)\n{\n\tiwl_mvm_stop_device(mvm);\n\n\tmvm->cur_aid = 0;\n\n\tmvm->scan_status = 0;\n\tmvm->ps_disabled = false;\n\tmvm->rfkill_safe_init_done = false;\n\n\t \n\tiwl_mvm_cleanup_roc_te(mvm);\n\tieee80211_remain_on_channel_expired(mvm->hw);\n\n\tiwl_mvm_ftm_restart(mvm);\n\n\t \n\tieee80211_iterate_interfaces(mvm->hw, 0, iwl_mvm_cleanup_iterator, mvm);\n\n\tmvm->p2p_device_vif = NULL;\n\n\tiwl_mvm_reset_phy_ctxts(mvm);\n\tmemset(mvm->fw_key_table, 0, sizeof(mvm->fw_key_table));\n\tmemset(&mvm->last_bt_notif, 0, sizeof(mvm->last_bt_notif));\n\tmemset(&mvm->last_bt_ci_cmd, 0, sizeof(mvm->last_bt_ci_cmd));\n\n\tieee80211_wake_queues(mvm->hw);\n\n\tmvm->rx_ba_sessions = 0;\n\tmvm->fwrt.dump.conf = FW_DBG_INVALID;\n\tmvm->monitor_on = false;\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tmvm->beacon_inject_active = false;\n#endif\n\n\t \n\tiwl_mvm_accu_radio_stats(mvm);\n}\n\nint __iwl_mvm_mac_start(struct iwl_mvm *mvm)\n{\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tret = iwl_mvm_mei_get_ownership(mvm);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mvm->mei_nvm_data) {\n\t\t \n\t\tkfree(mvm->mei_nvm_data);\n\t\tmvm->mei_nvm_data = NULL;\n\n\t\t \n\t\tmvm->temp_nvm_data = mvm->nvm_data;\n\t\tmvm->nvm_data = NULL;\n\t}\n\n\tif (test_bit(IWL_MVM_STATUS_HW_RESTART_REQUESTED, &mvm->status)) {\n\t\t \n\t\tset_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status);\n\t\tclear_bit(IWL_MVM_STATUS_HW_RESTART_REQUESTED, &mvm->status);\n\t\t \n\t\tiwl_mvm_restart_cleanup(mvm);\n\t}\n\tret = iwl_mvm_up(mvm);\n\n\tiwl_dbg_tlv_time_point(&mvm->fwrt, IWL_FW_INI_TIME_POINT_POST_INIT,\n\t\t\t       NULL);\n\tiwl_dbg_tlv_time_point(&mvm->fwrt, IWL_FW_INI_TIME_POINT_PERIODIC,\n\t\t\t       NULL);\n\n\tmvm->last_reset_or_resume_time_jiffies = jiffies;\n\n\tif (ret && test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status)) {\n\t\t \n\t\tclear_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status);\n\t}\n\n\treturn ret;\n}\n\nint iwl_mvm_mac_start(struct ieee80211_hw *hw)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tint ret;\n\tint retry, max_retry = 0;\n\n\tmutex_lock(&mvm->mutex);\n\n\t \n\tif (!test_bit(IWL_MVM_STATUS_HW_RESTART_REQUESTED, &mvm->status) &&\n\t    iwlwifi_mod_params.fw_restart) {\n\t\tmax_retry = IWL_MAX_INIT_RETRY;\n\t\t \n\t\tset_bit(IWL_MVM_STATUS_STARTING, &mvm->status);\n\t}\n\n\tfor (retry = 0; retry <= max_retry; retry++) {\n\t\tret = __iwl_mvm_mac_start(mvm);\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\t \n\t\tif (mvm->pldr_sync) {\n\t\t\tiwl_mei_alive_notif(false);\n\t\t\tiwl_trans_pcie_remove(mvm->trans, true);\n\t\t\tbreak;\n\t\t}\n\n\t\tIWL_ERR(mvm, \"mac start retry %d\\n\", retry);\n\t}\n\tclear_bit(IWL_MVM_STATUS_STARTING, &mvm->status);\n\n\tmutex_unlock(&mvm->mutex);\n\n\tiwl_mvm_mei_set_sw_rfkill_state(mvm);\n\n\treturn ret;\n}\n\nstatic void iwl_mvm_restart_complete(struct iwl_mvm *mvm)\n{\n\tint ret;\n\n\tmutex_lock(&mvm->mutex);\n\n\tclear_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status);\n\n\tret = iwl_mvm_update_quotas(mvm, true, NULL);\n\tif (ret)\n\t\tIWL_ERR(mvm, \"Failed to update quotas after restart (%d)\\n\",\n\t\t\tret);\n\n\tiwl_mvm_send_recovery_cmd(mvm, ERROR_RECOVERY_END_OF_RECOVERY);\n\n\t \n\tiwl_mvm_teardown_tdls_peers(mvm);\n\n\tmutex_unlock(&mvm->mutex);\n}\n\nvoid iwl_mvm_mac_reconfig_complete(struct ieee80211_hw *hw,\n\t\t\t\t   enum ieee80211_reconfig_type reconfig_type)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\tswitch (reconfig_type) {\n\tcase IEEE80211_RECONFIG_TYPE_RESTART:\n\t\tiwl_mvm_restart_complete(mvm);\n\t\tbreak;\n\tcase IEEE80211_RECONFIG_TYPE_SUSPEND:\n\t\tbreak;\n\t}\n}\n\nvoid __iwl_mvm_mac_stop(struct iwl_mvm *mvm)\n{\n\tlockdep_assert_held(&mvm->mutex);\n\n\tiwl_mvm_ftm_initiator_smooth_stop(mvm);\n\n\t \n\tmemset(&mvm->accu_radio_stats, 0, sizeof(mvm->accu_radio_stats));\n\n\t \n\n\tif (!iwl_mvm_has_new_station_api(mvm->fw))\n\t\tiwl_mvm_rm_aux_sta(mvm);\n\n\tiwl_mvm_stop_device(mvm);\n\n\tiwl_mvm_async_handlers_purge(mvm);\n\t \n\n\t \n\tif (test_and_clear_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status) ||\n\t    test_and_clear_bit(IWL_MVM_STATUS_HW_RESTART_REQUESTED,\n\t\t\t       &mvm->status))\n\t\tieee80211_iterate_interfaces(mvm->hw, 0,\n\t\t\t\t\t     iwl_mvm_cleanup_iterator, mvm);\n\n\t \n\tif (fw_has_capa(&mvm->fw->ucode_capa, IWL_UCODE_TLV_CAPA_UMAC_SCAN)) {\n\t\tint i;\n\n\t\tfor (i = 0; i < mvm->max_scans; i++) {\n\t\t\tif (WARN_ONCE(mvm->scan_uid_status[i],\n\t\t\t\t      \"UMAC scan UID %d status was not cleaned\\n\",\n\t\t\t\t      i))\n\t\t\t\tmvm->scan_uid_status[i] = 0;\n\t\t}\n\t}\n}\n\nvoid iwl_mvm_mac_stop(struct ieee80211_hw *hw)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\tflush_work(&mvm->async_handlers_wk);\n\tflush_work(&mvm->add_stream_wk);\n\n\t \n\tclear_bit(IWL_MVM_STATUS_FIRMWARE_RUNNING, &mvm->status);\n\n\tcancel_delayed_work_sync(&mvm->cs_tx_unblock_dwork);\n\tcancel_delayed_work_sync(&mvm->scan_timeout_dwork);\n\n\t \n\tflush_work(&mvm->roc_done_wk);\n\n\tiwl_mvm_mei_set_sw_rfkill_state(mvm);\n\n\tmutex_lock(&mvm->mutex);\n\t__iwl_mvm_mac_stop(mvm);\n\tmutex_unlock(&mvm->mutex);\n\n\t \n\tcancel_work_sync(&mvm->async_handlers_wk);\n}\n\nstruct iwl_mvm_phy_ctxt *iwl_mvm_get_free_phy_ctxt(struct iwl_mvm *mvm)\n{\n\tu16 i;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tfor (i = 0; i < NUM_PHY_CTX; i++)\n\t\tif (!mvm->phy_ctxts[i].ref)\n\t\t\treturn &mvm->phy_ctxts[i];\n\n\tIWL_ERR(mvm, \"No available PHY context\\n\");\n\treturn NULL;\n}\n\nint iwl_mvm_set_tx_power(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t s16 tx_power)\n{\n\tu32 cmd_id = REDUCE_TX_POWER_CMD;\n\tint len;\n\tstruct iwl_dev_tx_power_cmd cmd = {\n\t\t.common.set_mode = cpu_to_le32(IWL_TX_POWER_MODE_SET_MAC),\n\t\t.common.mac_context_id =\n\t\t\tcpu_to_le32(iwl_mvm_vif_from_mac80211(vif)->id),\n\t\t.common.pwr_restriction = cpu_to_le16(8 * tx_power),\n\t};\n\tu8 cmd_ver = iwl_fw_lookup_cmd_ver(mvm->fw, cmd_id,\n\t\t\t\t\t   IWL_FW_CMD_VER_UNKNOWN);\n\n\tif (tx_power == IWL_DEFAULT_MAX_TX_POWER)\n\t\tcmd.common.pwr_restriction = cpu_to_le16(IWL_DEV_MAX_TX_POWER);\n\n\tif (cmd_ver == 7)\n\t\tlen = sizeof(cmd.v7);\n\telse if (cmd_ver == 6)\n\t\tlen = sizeof(cmd.v6);\n\telse if (fw_has_api(&mvm->fw->ucode_capa,\n\t\t\t    IWL_UCODE_TLV_API_REDUCE_TX_POWER))\n\t\tlen = sizeof(cmd.v5);\n\telse if (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t     IWL_UCODE_TLV_CAPA_TX_POWER_ACK))\n\t\tlen = sizeof(cmd.v4);\n\telse\n\t\tlen = sizeof(cmd.v3);\n\n\t \n\tlen += sizeof(cmd.common);\n\n\treturn iwl_mvm_send_cmd_pdu(mvm, cmd_id, 0, len, &cmd);\n}\n\nint iwl_mvm_post_channel_switch(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tint ret;\n\n\tmutex_lock(&mvm->mutex);\n\n\tif (vif->type == NL80211_IFTYPE_STATION) {\n\t\tstruct iwl_mvm_sta *mvmsta;\n\n\t\tmvmvif->csa_bcn_pending = false;\n\t\tmvmsta = iwl_mvm_sta_from_staid_protected(mvm,\n\t\t\t\t\t\t\t  mvmvif->deflink.ap_sta_id);\n\n\t\tif (WARN_ON(!mvmsta)) {\n\t\t\tret = -EIO;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tiwl_mvm_sta_modify_disable_tx(mvm, mvmsta, false);\n\t\tif (mvm->mld_api_is_used)\n\t\t\tiwl_mvm_mld_mac_ctxt_changed(mvm, vif, false);\n\t\telse\n\t\t\tiwl_mvm_mac_ctxt_changed(mvm, vif, false, NULL);\n\n\t\tif (!fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t\t IWL_UCODE_TLV_CAPA_CHANNEL_SWITCH_CMD)) {\n\t\t\tret = iwl_mvm_enable_beacon_filter(mvm, vif, 0);\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock;\n\n\t\t\tiwl_mvm_stop_session_protection(mvm, vif);\n\t\t}\n\t}\n\n\tmvmvif->ps_disabled = false;\n\n\tret = iwl_mvm_power_update_ps(mvm);\n\nout_unlock:\n\tif (mvmvif->csa_failed)\n\t\tret = -EIO;\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret;\n}\n\nvoid iwl_mvm_abort_channel_switch(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_chan_switch_te_cmd cmd = {\n\t\t.mac_id = cpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id,\n\t\t\t\t\t\t\t  mvmvif->color)),\n\t\t.action = cpu_to_le32(FW_CTXT_ACTION_REMOVE),\n\t};\n\n\t \n\tif (iwl_fw_lookup_notif_ver(mvm->fw, MAC_CONF_GROUP,\n\t\t\t\t    CHANNEL_SWITCH_ERROR_NOTIF, 0))\n\t\treturn;\n\n\tIWL_DEBUG_MAC80211(mvm, \"Abort CSA on mac %d\\n\", mvmvif->id);\n\n\tmutex_lock(&mvm->mutex);\n\tif (!fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t IWL_UCODE_TLV_CAPA_CHANNEL_SWITCH_CMD))\n\t\tiwl_mvm_remove_csa_period(mvm, vif);\n\telse\n\t\tWARN_ON(iwl_mvm_send_cmd_pdu(mvm,\n\t\t\t\t\t     WIDE_ID(MAC_CONF_GROUP,\n\t\t\t\t\t\t     CHANNEL_SWITCH_TIME_EVENT_CMD),\n\t\t\t\t\t     0, sizeof(cmd), &cmd));\n\tmvmvif->csa_failed = true;\n\tmutex_unlock(&mvm->mutex);\n\n\tiwl_mvm_post_channel_switch(hw, vif);\n}\n\nvoid iwl_mvm_channel_switch_disconnect_wk(struct work_struct *wk)\n{\n\tstruct iwl_mvm_vif *mvmvif;\n\tstruct ieee80211_vif *vif;\n\n\tmvmvif = container_of(wk, struct iwl_mvm_vif, csa_work.work);\n\tvif = container_of((void *)mvmvif, struct ieee80211_vif, drv_priv);\n\n\t \n\tieee80211_chswitch_done(vif, false);\n}\n\nstatic u8\niwl_mvm_chandef_get_primary_80(struct cfg80211_chan_def *chandef)\n{\n\tint data_start;\n\tint control_start;\n\tint bw;\n\n\tif (chandef->width == NL80211_CHAN_WIDTH_320)\n\t\tbw = 320;\n\telse if (chandef->width == NL80211_CHAN_WIDTH_160)\n\t\tbw = 160;\n\telse\n\t\treturn 0;\n\n\t \n\tdata_start = chandef->center_freq1 - bw / 2;\n\t \n\tcontrol_start = chandef->chan->center_freq - 10;\n\n\treturn (control_start - data_start) / 80;\n}\n\nstatic int iwl_mvm_alloc_bcast_mcast_sta(struct iwl_mvm *mvm,\n\t\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tret = iwl_mvm_alloc_bcast_sta(mvm, vif);\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"Failed to allocate bcast sta\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\treturn iwl_mvm_allocate_int_sta(mvm, &mvmvif->deflink.mcast_sta, 0,\n\t\t\t\t\tvif->type,\n\t\t\t\t\tIWL_STA_MULTICAST);\n}\n\nstatic int iwl_mvm_mac_add_interface(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tint ret;\n\n\tmutex_lock(&mvm->mutex);\n\n\tmvmvif->mvm = mvm;\n\n\t \n\tmvmvif->link[0] = &mvmvif->deflink;\n\n\t \n\n\t \n\tif (test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status))\n\t\tmvmvif->deflink.beacon_stats.accu_num_beacons +=\n\t\t\tmvmvif->deflink.beacon_stats.num_beacons;\n\n\t \n\tret = iwl_mvm_mac_ctxt_init(mvm, vif);\n\tif (ret)\n\t\tgoto out;\n\n\trcu_assign_pointer(mvm->vif_id_to_mac[mvmvif->id], vif);\n\n\t \n\tif (vif->type == NL80211_IFTYPE_NAN) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tif (vif->type == NL80211_IFTYPE_AP ||\n\t    vif->type == NL80211_IFTYPE_ADHOC) {\n\t\tiwl_mvm_vif_dbgfs_register(mvm, vif);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tmvmvif->features |= hw->netdev_features;\n\n\tret = iwl_mvm_mac_ctxt_add(mvm, vif);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = iwl_mvm_power_update_mac(mvm);\n\tif (ret)\n\t\tgoto out_remove_mac;\n\n\t \n\tret = iwl_mvm_disable_beacon_filter(mvm, vif, 0);\n\tif (ret)\n\t\tgoto out_remove_mac;\n\n\tif (!mvm->bf_allowed_vif &&\n\t    vif->type == NL80211_IFTYPE_STATION && !vif->p2p) {\n\t\tmvm->bf_allowed_vif = mvmvif;\n\t\tvif->driver_flags |= IEEE80211_VIF_BEACON_FILTER |\n\t\t\t\t     IEEE80211_VIF_SUPPORTS_CQM_RSSI;\n\t}\n\n\tif (vif->type == NL80211_IFTYPE_P2P_DEVICE)\n\t\tmvm->p2p_device_vif = vif;\n\n\tiwl_mvm_tcm_add_vif(mvm, vif);\n\tINIT_DELAYED_WORK(&mvmvif->csa_work,\n\t\t\t  iwl_mvm_channel_switch_disconnect_wk);\n\n\tif (vif->type == NL80211_IFTYPE_MONITOR) {\n\t\tmvm->monitor_on = true;\n\t\tmvm->monitor_p80 =\n\t\t\tiwl_mvm_chandef_get_primary_80(&vif->bss_conf.chandef);\n\t}\n\n\tiwl_mvm_vif_dbgfs_register(mvm, vif);\n\n\tif (!test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status) &&\n\t    vif->type == NL80211_IFTYPE_STATION && !vif->p2p &&\n\t    !mvm->csme_vif && mvm->mei_registered) {\n\t\tiwl_mei_set_nic_info(vif->addr, mvm->nvm_data->hw_addr);\n\t\tiwl_mei_set_netdev(ieee80211_vif_to_wdev(vif)->netdev);\n\t\tmvm->csme_vif = vif;\n\t}\n\nout:\n\tif (!ret && (vif->type == NL80211_IFTYPE_AP ||\n\t\t     vif->type == NL80211_IFTYPE_ADHOC))\n\t\tret = iwl_mvm_alloc_bcast_mcast_sta(mvm, vif);\n\n\tgoto out_unlock;\n\n\tif (mvm->bf_allowed_vif == mvmvif) {\n\t\tmvm->bf_allowed_vif = NULL;\n\t\tvif->driver_flags &= ~(IEEE80211_VIF_BEACON_FILTER |\n\t\t\t\t       IEEE80211_VIF_SUPPORTS_CQM_RSSI);\n\t}\n out_remove_mac:\n\tmvmvif->deflink.phy_ctxt = NULL;\n\tiwl_mvm_mac_ctxt_remove(mvm, vif);\n out_unlock:\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret;\n}\n\nvoid iwl_mvm_prepare_mac_removal(struct iwl_mvm *mvm,\n\t\t\t\t struct ieee80211_vif *vif)\n{\n\tif (vif->type == NL80211_IFTYPE_P2P_DEVICE) {\n\t\t \n\t\tflush_work(&mvm->roc_done_wk);\n\t}\n}\n\n \nstatic bool iwl_mvm_mac_remove_interface_common(struct ieee80211_hw *hw,\n\t\t\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_probe_resp_data *probe_data;\n\n\tiwl_mvm_prepare_mac_removal(mvm, vif);\n\n\tif (!(vif->type == NL80211_IFTYPE_AP ||\n\t      vif->type == NL80211_IFTYPE_ADHOC))\n\t\tiwl_mvm_tcm_rm_vif(mvm, vif);\n\n\tmutex_lock(&mvm->mutex);\n\n\tif (vif == mvm->csme_vif) {\n\t\tiwl_mei_set_netdev(NULL);\n\t\tmvm->csme_vif = NULL;\n\t}\n\n\tprobe_data = rcu_dereference_protected(mvmvif->deflink.probe_resp_data,\n\t\t\t\t\t       lockdep_is_held(&mvm->mutex));\n\tRCU_INIT_POINTER(mvmvif->deflink.probe_resp_data, NULL);\n\tif (probe_data)\n\t\tkfree_rcu(probe_data, rcu_head);\n\n\tif (mvm->bf_allowed_vif == mvmvif) {\n\t\tmvm->bf_allowed_vif = NULL;\n\t\tvif->driver_flags &= ~(IEEE80211_VIF_BEACON_FILTER |\n\t\t\t\t       IEEE80211_VIF_SUPPORTS_CQM_RSSI);\n\t}\n\n\tif (vif->bss_conf.ftm_responder)\n\t\tmemset(&mvm->ftm_resp_stats, 0, sizeof(mvm->ftm_resp_stats));\n\n\tiwl_mvm_vif_dbgfs_clean(mvm, vif);\n\n\t \n\tif (vif->type == NL80211_IFTYPE_AP ||\n\t    vif->type == NL80211_IFTYPE_ADHOC) {\n#ifdef CONFIG_NL80211_TESTMODE\n\t\tif (vif == mvm->noa_vif) {\n\t\t\tmvm->noa_vif = NULL;\n\t\t\tmvm->noa_duration = 0;\n\t\t}\n#endif\n\t\treturn true;\n\t}\n\n\tiwl_mvm_power_update_mac(mvm);\n\treturn false;\n}\n\nstatic void iwl_mvm_mac_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tif (iwl_mvm_mac_remove_interface_common(hw, vif))\n\t\tgoto out;\n\n\t \n\tif (vif->type == NL80211_IFTYPE_P2P_DEVICE) {\n\t\tif (mvmvif->deflink.phy_ctxt) {\n\t\t\tiwl_mvm_phy_ctxt_unref(mvm, mvmvif->deflink.phy_ctxt);\n\t\t\tmvmvif->deflink.phy_ctxt = NULL;\n\t\t}\n\t\tmvm->p2p_device_vif = NULL;\n\t}\n\n\tiwl_mvm_mac_ctxt_remove(mvm, vif);\n\n\tRCU_INIT_POINTER(mvm->vif_id_to_mac[mvmvif->id], NULL);\n\n\tif (vif->type == NL80211_IFTYPE_MONITOR)\n\t\tmvm->monitor_on = false;\n\nout:\n\tif (vif->type == NL80211_IFTYPE_AP ||\n\t    vif->type == NL80211_IFTYPE_ADHOC) {\n\t\tiwl_mvm_dealloc_int_sta(mvm, &mvmvif->deflink.mcast_sta);\n\t\tiwl_mvm_dealloc_bcast_sta(mvm, vif);\n\t}\n\n\tmutex_unlock(&mvm->mutex);\n}\n\nstruct iwl_mvm_mc_iter_data {\n\tstruct iwl_mvm *mvm;\n\tint port_id;\n};\n\nstatic void iwl_mvm_mc_iface_iterator(void *_data, u8 *mac,\n\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_mc_iter_data *data = _data;\n\tstruct iwl_mvm *mvm = data->mvm;\n\tstruct iwl_mcast_filter_cmd *cmd = mvm->mcast_filter_cmd;\n\tstruct iwl_host_cmd hcmd = {\n\t\t.id = MCAST_FILTER_CMD,\n\t\t.flags = CMD_ASYNC,\n\t\t.dataflags[0] = IWL_HCMD_DFL_NOCOPY,\n\t};\n\tint ret, len;\n\n\t \n\tif (WARN_ON_ONCE(data->port_id >= MAX_PORT_ID_NUM))\n\t\treturn;\n\n\tif (vif->type != NL80211_IFTYPE_STATION ||\n\t    !vif->cfg.assoc)\n\t\treturn;\n\n\tcmd->port_id = data->port_id++;\n\tmemcpy(cmd->bssid, vif->bss_conf.bssid, ETH_ALEN);\n\tlen = roundup(sizeof(*cmd) + cmd->count * ETH_ALEN, 4);\n\n\thcmd.len[0] = len;\n\thcmd.data[0] = cmd;\n\n\tret = iwl_mvm_send_cmd(mvm, &hcmd);\n\tif (ret)\n\t\tIWL_ERR(mvm, \"mcast filter cmd error. ret=%d\\n\", ret);\n}\n\nstatic void iwl_mvm_recalc_multicast(struct iwl_mvm *mvm)\n{\n\tstruct iwl_mvm_mc_iter_data iter_data = {\n\t\t.mvm = mvm,\n\t};\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (WARN_ON_ONCE(!mvm->mcast_filter_cmd))\n\t\treturn;\n\n\tieee80211_iterate_active_interfaces_atomic(\n\t\tmvm->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\tiwl_mvm_mc_iface_iterator, &iter_data);\n\n\t \n\tret = iwl_mvm_send_cmd_pdu(mvm, ECHO_CMD, 0, 0, NULL);\n\tif (ret)\n\t\tIWL_ERR(mvm, \"Failed to synchronize multicast groups update\\n\");\n}\n\nu64 iwl_mvm_prepare_multicast(struct ieee80211_hw *hw,\n\t\t\t      struct netdev_hw_addr_list *mc_list)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mcast_filter_cmd *cmd;\n\tstruct netdev_hw_addr *addr;\n\tint addr_count;\n\tbool pass_all;\n\tint len;\n\n\taddr_count = netdev_hw_addr_list_count(mc_list);\n\tpass_all = addr_count > MAX_MCAST_FILTERING_ADDRESSES ||\n\t\t   IWL_MVM_FW_MCAST_FILTER_PASS_ALL;\n\tif (pass_all)\n\t\taddr_count = 0;\n\n\tlen = roundup(sizeof(*cmd) + addr_count * ETH_ALEN, 4);\n\tcmd = kzalloc(len, GFP_ATOMIC);\n\tif (!cmd)\n\t\treturn 0;\n\n\tif (pass_all) {\n\t\tcmd->pass_all = 1;\n\t\treturn (u64)(unsigned long)cmd;\n\t}\n\n\tnetdev_hw_addr_list_for_each(addr, mc_list) {\n\t\tIWL_DEBUG_MAC80211(mvm, \"mcast addr (%d): %pM\\n\",\n\t\t\t\t   cmd->count, addr->addr);\n\t\tmemcpy(&cmd->addr_list[cmd->count * ETH_ALEN],\n\t\t       addr->addr, ETH_ALEN);\n\t\tcmd->count++;\n\t}\n\n\treturn (u64)(unsigned long)cmd;\n}\n\nvoid iwl_mvm_configure_filter(struct ieee80211_hw *hw,\n\t\t\t      unsigned int changed_flags,\n\t\t\t      unsigned int *total_flags, u64 multicast)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mcast_filter_cmd *cmd = (void *)(unsigned long)multicast;\n\n\tmutex_lock(&mvm->mutex);\n\n\t \n\tkfree(mvm->mcast_filter_cmd);\n\tmvm->mcast_filter_cmd = cmd;\n\n\tif (!cmd)\n\t\tgoto out;\n\n\tif (changed_flags & FIF_ALLMULTI)\n\t\tcmd->pass_all = !!(*total_flags & FIF_ALLMULTI);\n\n\tif (cmd->pass_all)\n\t\tcmd->count = 0;\n\n\tiwl_mvm_recalc_multicast(mvm);\nout:\n\tmutex_unlock(&mvm->mutex);\n\t*total_flags = 0;\n}\n\nstatic void iwl_mvm_config_iface_filter(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tunsigned int filter_flags,\n\t\t\t\t\tunsigned int changed_flags)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\t \n\tif (!(changed_flags & FIF_PROBE_REQ))\n\t\treturn;\n\n\t \n\tif (vif->type != NL80211_IFTYPE_STATION || !vif->cfg.assoc ||\n\t    !vif->p2p)\n\t\treturn;\n\n\tmutex_lock(&mvm->mutex);\n\tiwl_mvm_mac_ctxt_changed(mvm, vif, false, NULL);\n\tmutex_unlock(&mvm->mutex);\n}\n\nint iwl_mvm_update_mu_groups(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tstruct iwl_mu_group_mgmt_cmd cmd = {};\n\n\tmemcpy(cmd.membership_status, vif->bss_conf.mu_group.membership,\n\t       WLAN_MEMBERSHIP_LEN);\n\tmemcpy(cmd.user_position, vif->bss_conf.mu_group.position,\n\t       WLAN_USER_POSITION_LEN);\n\n\treturn iwl_mvm_send_cmd_pdu(mvm,\n\t\t\t\t    WIDE_ID(DATA_PATH_GROUP,\n\t\t\t\t\t    UPDATE_MU_GROUPS_CMD),\n\t\t\t\t    0, sizeof(cmd), &cmd);\n}\n\nstatic void iwl_mvm_mu_mimo_iface_iterator(void *_data, u8 *mac,\n\t\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tif (vif->bss_conf.mu_mimo_owner) {\n\t\tstruct iwl_mu_group_mgmt_notif *notif = _data;\n\n\t\t \n\t\tieee80211_update_mu_groups(vif, 0,\n\t\t\t\t\t   (u8 *)&notif->membership_status,\n\t\t\t\t\t   (u8 *)&notif->user_position);\n\t}\n}\n\nvoid iwl_mvm_mu_mimo_grp_notif(struct iwl_mvm *mvm,\n\t\t\t       struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_mu_group_mgmt_notif *notif = (void *)pkt->data;\n\n\tieee80211_iterate_active_interfaces_atomic(\n\t\t\tmvm->hw, IEEE80211_IFACE_ITER_NORMAL,\n\t\t\tiwl_mvm_mu_mimo_iface_iterator, notif);\n}\n\nstatic u8 iwl_mvm_he_get_ppe_val(u8 *ppe, u8 ppe_pos_bit)\n{\n\tu8 byte_num = ppe_pos_bit / 8;\n\tu8 bit_num = ppe_pos_bit % 8;\n\tu8 residue_bits;\n\tu8 res;\n\n\tif (bit_num <= 5)\n\t\treturn (ppe[byte_num] >> bit_num) &\n\t\t       (BIT(IEEE80211_PPE_THRES_INFO_PPET_SIZE) - 1);\n\n\t \n\n\tresidue_bits = 8 - bit_num;\n\n\tres = (ppe[byte_num + 1] &\n\t       (BIT(IEEE80211_PPE_THRES_INFO_PPET_SIZE - residue_bits) - 1)) <<\n\t      residue_bits;\n\tres += (ppe[byte_num] >> bit_num) & (BIT(residue_bits) - 1);\n\n\treturn res;\n}\n\nstatic void iwl_mvm_parse_ppe(struct iwl_mvm *mvm,\n\t\t\t      struct iwl_he_pkt_ext_v2 *pkt_ext, u8 nss,\n\t\t\t      u8 ru_index_bitmap, u8 *ppe, u8 ppe_pos_bit,\n\t\t\t      bool inheritance)\n{\n\tint i;\n\n\t \n\tif (nss > MAX_HE_SUPP_NSS) {\n\t\tIWL_DEBUG_INFO(mvm, \"Got NSS = %d - trimming to %d\\n\", nss,\n\t\t\t       MAX_HE_SUPP_NSS);\n\t\tnss = MAX_HE_SUPP_NSS;\n\t}\n\n\tfor (i = 0; i < nss; i++) {\n\t\tu8 ru_index_tmp = ru_index_bitmap << 1;\n\t\tu8 low_th = IWL_HE_PKT_EXT_NONE, high_th = IWL_HE_PKT_EXT_NONE;\n\t\tu8 bw;\n\n\t\tfor (bw = 0;\n\t\t     bw < ARRAY_SIZE(pkt_ext->pkt_ext_qam_th[i]);\n\t\t     bw++) {\n\t\t\tru_index_tmp >>= 1;\n\n\t\t\t \n\t\t\tif (!(ru_index_tmp & 1)) {\n\t\t\t\tif (inheritance)\n\t\t\t\t\tgoto set_thresholds;\n\t\t\t\telse\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\thigh_th = iwl_mvm_he_get_ppe_val(ppe, ppe_pos_bit);\n\t\t\tppe_pos_bit += IEEE80211_PPE_THRES_INFO_PPET_SIZE;\n\t\t\tlow_th = iwl_mvm_he_get_ppe_val(ppe, ppe_pos_bit);\n\t\t\tppe_pos_bit += IEEE80211_PPE_THRES_INFO_PPET_SIZE;\n\nset_thresholds:\n\t\t\tpkt_ext->pkt_ext_qam_th[i][bw][0] = low_th;\n\t\t\tpkt_ext->pkt_ext_qam_th[i][bw][1] = high_th;\n\t\t}\n\t}\n}\n\nstatic void iwl_mvm_set_pkt_ext_from_he_ppe(struct iwl_mvm *mvm,\n\t\t\t\t\t    struct ieee80211_link_sta *link_sta,\n\t\t\t\t\t    struct iwl_he_pkt_ext_v2 *pkt_ext,\n\t\t\t\t\t    bool inheritance)\n{\n\tu8 nss = (link_sta->he_cap.ppe_thres[0] &\n\t\t  IEEE80211_PPE_THRES_NSS_MASK) + 1;\n\tu8 *ppe = &link_sta->he_cap.ppe_thres[0];\n\tu8 ru_index_bitmap =\n\t\tu8_get_bits(*ppe,\n\t\t\t    IEEE80211_PPE_THRES_RU_INDEX_BITMASK_MASK);\n\t \n\tu8 ppe_pos_bit = IEEE80211_HE_PPE_THRES_INFO_HEADER_SIZE;\n\n\tiwl_mvm_parse_ppe(mvm, pkt_ext, nss, ru_index_bitmap, ppe, ppe_pos_bit,\n\t\t\t  inheritance);\n}\n\nstatic int\niwl_mvm_set_pkt_ext_from_nominal_padding(struct iwl_he_pkt_ext_v2 *pkt_ext,\n\t\t\t\t\t u8 nominal_padding)\n{\n\tint low_th = -1;\n\tint high_th = -1;\n\tint i;\n\n\t \n\tswitch (nominal_padding) {\n\tcase IEEE80211_EHT_PHY_CAP5_COMMON_NOMINAL_PKT_PAD_0US:\n\t\tlow_th = IWL_HE_PKT_EXT_NONE;\n\t\thigh_th = IWL_HE_PKT_EXT_NONE;\n\t\tbreak;\n\tcase IEEE80211_EHT_PHY_CAP5_COMMON_NOMINAL_PKT_PAD_8US:\n\t\tlow_th = IWL_HE_PKT_EXT_BPSK;\n\t\thigh_th = IWL_HE_PKT_EXT_NONE;\n\t\tbreak;\n\tcase IEEE80211_EHT_PHY_CAP5_COMMON_NOMINAL_PKT_PAD_16US:\n\tcase IEEE80211_EHT_PHY_CAP5_COMMON_NOMINAL_PKT_PAD_20US:\n\t\tlow_th = IWL_HE_PKT_EXT_NONE;\n\t\thigh_th = IWL_HE_PKT_EXT_BPSK;\n\t\tbreak;\n\t}\n\n\tif (low_th < 0 || high_th < 0)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < MAX_HE_SUPP_NSS; i++) {\n\t\tu8 bw;\n\n\t\tfor (bw = 0;\n\t\t\tbw < ARRAY_SIZE(pkt_ext->pkt_ext_qam_th[i]);\n\t\t\tbw++) {\n\t\t\tpkt_ext->pkt_ext_qam_th[i][bw][0] = low_th;\n\t\t\tpkt_ext->pkt_ext_qam_th[i][bw][1] = high_th;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void iwl_mvm_get_optimal_ppe_info(struct iwl_he_pkt_ext_v2 *pkt_ext,\n\t\t\t\t\t u8 nominal_padding)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_HE_SUPP_NSS; i++) {\n\t\tu8 bw;\n\n\t\tfor (bw = 0; bw < ARRAY_SIZE(pkt_ext->pkt_ext_qam_th[i]);\n\t\t     bw++) {\n\t\t\tu8 *qam_th = &pkt_ext->pkt_ext_qam_th[i][bw][0];\n\n\t\t\tif (nominal_padding >\n\t\t\t    IEEE80211_EHT_PHY_CAP5_COMMON_NOMINAL_PKT_PAD_8US &&\n\t\t\t    qam_th[1] == IWL_HE_PKT_EXT_NONE)\n\t\t\t\tqam_th[1] = IWL_HE_PKT_EXT_4096QAM;\n\t\t\telse if (nominal_padding ==\n\t\t\t\t IEEE80211_EHT_PHY_CAP5_COMMON_NOMINAL_PKT_PAD_8US &&\n\t\t\t\t qam_th[0] == IWL_HE_PKT_EXT_NONE &&\n\t\t\t\t qam_th[1] == IWL_HE_PKT_EXT_NONE)\n\t\t\t\tqam_th[0] = IWL_HE_PKT_EXT_4096QAM;\n\t\t}\n\t}\n}\n\n \nint iwl_mvm_set_sta_pkt_ext(struct iwl_mvm *mvm,\n\t\t\t    struct ieee80211_link_sta *link_sta,\n\t\t\t    struct iwl_he_pkt_ext_v2 *pkt_ext)\n{\n\tu8 nominal_padding;\n\tint i, ret = 0;\n\n\tif (WARN_ON(!link_sta))\n\t\treturn -EINVAL;\n\n\t \n\tmemset(pkt_ext, IWL_HE_PKT_EXT_NONE,\n\t       sizeof(struct iwl_he_pkt_ext_v2));\n\n\tif (link_sta->eht_cap.has_eht) {\n\t\tnominal_padding =\n\t\t\tu8_get_bits(link_sta->eht_cap.eht_cap_elem.phy_cap_info[5],\n\t\t\t\t    IEEE80211_EHT_PHY_CAP5_COMMON_NOMINAL_PKT_PAD_MASK);\n\n\t\t \n\t\tif (link_sta->eht_cap.eht_cap_elem.phy_cap_info[5] &\n\t\t    IEEE80211_EHT_PHY_CAP5_PPE_THRESHOLD_PRESENT) {\n\t\t\tu8 nss = (link_sta->eht_cap.eht_ppe_thres[0] &\n\t\t\t\tIEEE80211_EHT_PPE_THRES_NSS_MASK) + 1;\n\t\t\tu8 *ppe = &link_sta->eht_cap.eht_ppe_thres[0];\n\t\t\tu8 ru_index_bitmap =\n\t\t\t\tu16_get_bits(*ppe,\n\t\t\t\t\t     IEEE80211_EHT_PPE_THRES_RU_INDEX_BITMASK_MASK);\n\t\t\t  \n\t\t\tu8 ppe_pos_bit = IEEE80211_EHT_PPE_THRES_INFO_HEADER_SIZE;\n\n\t\t\tiwl_mvm_parse_ppe(mvm, pkt_ext, nss, ru_index_bitmap,\n\t\t\t\t\t  ppe, ppe_pos_bit, true);\n\t\t \n\t\t} else if (link_sta->he_cap.he_cap_elem.phy_cap_info[6] &\n\t\t\t   IEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT) {\n\t\t\t \n\t\t\tiwl_mvm_set_pkt_ext_from_he_ppe(mvm, link_sta, pkt_ext,\n\t\t\t\t\t\t\ttrue);\n\n\t\t\t \n\t\t\tiwl_mvm_get_optimal_ppe_info(pkt_ext, nominal_padding);\n\n\t\t \n\t\t} else {\n\t\t\tret = iwl_mvm_set_pkt_ext_from_nominal_padding(pkt_ext,\n\t\t\t\t\t\t\t\t       nominal_padding);\n\t\t}\n\t} else if (link_sta->he_cap.has_he) {\n\t\t \n\t\tif (link_sta->he_cap.he_cap_elem.phy_cap_info[6] &\n\t\t\tIEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT) {\n\t\t\tiwl_mvm_set_pkt_ext_from_he_ppe(mvm, link_sta, pkt_ext,\n\t\t\t\t\t\t\tfalse);\n\t\t \n\t\t} else {\n\t\t\tnominal_padding =\n\t\t\t\tu8_get_bits(link_sta->he_cap.he_cap_elem.phy_cap_info[9],\n\t\t\t\t\t    IEEE80211_HE_PHY_CAP9_NOMINAL_PKT_PADDING_MASK);\n\t\t\tif (nominal_padding != IEEE80211_HE_PHY_CAP9_NOMINAL_PKT_PADDING_RESERVED)\n\t\t\t\tret = iwl_mvm_set_pkt_ext_from_nominal_padding(pkt_ext,\n\t\t\t\t\t\t\t\t\t       nominal_padding);\n\t\t}\n\t}\n\n\tfor (i = 0; i < MAX_HE_SUPP_NSS; i++) {\n\t\tint bw;\n\n\t\tfor (bw = 0;\n\t\t     bw < ARRAY_SIZE(*pkt_ext->pkt_ext_qam_th[i]);\n\t\t     bw++) {\n\t\t\tu8 *qam_th =\n\t\t\t\t&pkt_ext->pkt_ext_qam_th[i][bw][0];\n\n\t\t\tIWL_DEBUG_HT(mvm,\n\t\t\t\t     \"PPE table: nss[%d] bw[%d] PPET8 = %d, PPET16 = %d\\n\",\n\t\t\t\t     i, bw, qam_th[0], qam_th[1]);\n\t\t}\n\t}\n\treturn ret;\n}\n\n \nbool iwl_mvm_set_fw_mu_edca_params(struct iwl_mvm *mvm,\n\t\t\t\t   const struct iwl_mvm_vif_link_info *link_info,\n\t\t\t\t   struct iwl_he_backoff_conf *trig_based_txf)\n{\n\tint i;\n\t \n\tbool mu_edca_enabled = true;\n\n\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\tconst struct ieee80211_he_mu_edca_param_ac_rec *mu_edca =\n\t\t\t&link_info->queue_params[i].mu_edca_param_rec;\n\t\tu8 ac = iwl_mvm_mac80211_ac_to_ucode_ac(i);\n\n\t\tif (!link_info->queue_params[i].mu_edca) {\n\t\t\tmu_edca_enabled = false;\n\t\t\tbreak;\n\t\t}\n\n\t\ttrig_based_txf[ac].cwmin =\n\t\t\tcpu_to_le16(mu_edca->ecw_min_max & 0xf);\n\t\ttrig_based_txf[ac].cwmax =\n\t\t\tcpu_to_le16((mu_edca->ecw_min_max & 0xf0) >> 4);\n\t\ttrig_based_txf[ac].aifsn =\n\t\t\tcpu_to_le16(mu_edca->aifsn & 0xf);\n\t\ttrig_based_txf[ac].mu_time =\n\t\t\tcpu_to_le16(mu_edca->mu_edca_timer);\n\t}\n\n\treturn mu_edca_enabled;\n}\n\nbool iwl_mvm_is_nic_ack_enabled(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tconst struct ieee80211_supported_band *sband;\n\tconst struct ieee80211_sta_he_cap *own_he_cap = NULL;\n\n\t \n\tsband = mvm->hw->wiphy->bands[NL80211_BAND_2GHZ];\n\town_he_cap = ieee80211_get_he_iftype_cap_vif(sband, vif);\n\n\treturn (own_he_cap && (own_he_cap->he_cap_elem.mac_cap_info[2] &\n\t\t\t       IEEE80211_HE_MAC_CAP2_ACK_EN));\n}\n\n__le32 iwl_mvm_get_sta_htc_flags(struct ieee80211_sta *sta,\n\t\t\t\t struct ieee80211_link_sta *link_sta)\n{\n\tu8 *mac_cap_info =\n\t\t&link_sta->he_cap.he_cap_elem.mac_cap_info[0];\n\t__le32 htc_flags = 0;\n\n\tif (mac_cap_info[0] & IEEE80211_HE_MAC_CAP0_HTC_HE)\n\t\thtc_flags |= cpu_to_le32(IWL_HE_HTC_SUPPORT);\n\tif ((mac_cap_info[1] & IEEE80211_HE_MAC_CAP1_LINK_ADAPTATION) ||\n\t    (mac_cap_info[2] & IEEE80211_HE_MAC_CAP2_LINK_ADAPTATION)) {\n\t\tu8 link_adap =\n\t\t\t((mac_cap_info[2] &\n\t\t\t  IEEE80211_HE_MAC_CAP2_LINK_ADAPTATION) << 1) +\n\t\t\t (mac_cap_info[1] &\n\t\t\t  IEEE80211_HE_MAC_CAP1_LINK_ADAPTATION);\n\n\t\tif (link_adap == 2)\n\t\t\thtc_flags |=\n\t\t\t\tcpu_to_le32(IWL_HE_HTC_LINK_ADAP_UNSOLICITED);\n\t\telse if (link_adap == 3)\n\t\t\thtc_flags |= cpu_to_le32(IWL_HE_HTC_LINK_ADAP_BOTH);\n\t}\n\tif (mac_cap_info[2] & IEEE80211_HE_MAC_CAP2_BSR)\n\t\thtc_flags |= cpu_to_le32(IWL_HE_HTC_BSR_SUPP);\n\tif (mac_cap_info[3] & IEEE80211_HE_MAC_CAP3_OMI_CONTROL)\n\t\thtc_flags |= cpu_to_le32(IWL_HE_HTC_OMI_SUPP);\n\tif (mac_cap_info[4] & IEEE80211_HE_MAC_CAP4_BQR)\n\t\thtc_flags |= cpu_to_le32(IWL_HE_HTC_BQR_SUPP);\n\n\treturn htc_flags;\n}\n\nstatic void iwl_mvm_cfg_he_sta(struct iwl_mvm *mvm,\n\t\t\t       struct ieee80211_vif *vif, u8 sta_id)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_he_sta_context_cmd_v3 sta_ctxt_cmd = {\n\t\t.sta_id = sta_id,\n\t\t.tid_limit = IWL_MAX_TID_COUNT,\n\t\t.bss_color = vif->bss_conf.he_bss_color.color,\n\t\t.htc_trig_based_pkt_ext = vif->bss_conf.htc_trig_based_pkt_ext,\n\t\t.frame_time_rts_th =\n\t\t\tcpu_to_le16(vif->bss_conf.frame_time_rts_th),\n\t};\n\tstruct iwl_he_sta_context_cmd_v2 sta_ctxt_cmd_v2 = {};\n\tu32 cmd_id = WIDE_ID(DATA_PATH_GROUP, STA_HE_CTXT_CMD);\n\tu8 ver = iwl_fw_lookup_cmd_ver(mvm->fw, cmd_id, 2);\n\tint size;\n\tstruct ieee80211_sta *sta;\n\tu32 flags;\n\tint i;\n\tvoid *cmd;\n\n\tif (!fw_has_api(&mvm->fw->ucode_capa, IWL_UCODE_TLV_API_MBSSID_HE))\n\t\tver = 1;\n\n\tswitch (ver) {\n\tcase 1:\n\t\t \n\t\tcmd = &sta_ctxt_cmd_v2;\n\t\tsize = sizeof(struct iwl_he_sta_context_cmd_v1);\n\t\tbreak;\n\tcase 2:\n\t\tcmd = &sta_ctxt_cmd_v2;\n\t\tsize = sizeof(struct iwl_he_sta_context_cmd_v2);\n\t\tbreak;\n\tcase 3:\n\t\tcmd = &sta_ctxt_cmd;\n\t\tsize = sizeof(struct iwl_he_sta_context_cmd_v3);\n\t\tbreak;\n\tdefault:\n\t\tIWL_ERR(mvm, \"bad STA_HE_CTXT_CMD version %d\\n\", ver);\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\n\tsta = rcu_dereference(mvm->fw_id_to_mac_id[sta_ctxt_cmd.sta_id]);\n\tif (IS_ERR_OR_NULL(sta)) {\n\t\trcu_read_unlock();\n\t\tWARN(1, \"Can't find STA to configure HE\\n\");\n\t\treturn;\n\t}\n\n\tif (!sta->deflink.he_cap.has_he) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tflags = 0;\n\n\t \n\tif (mvmvif->deflink.he_ru_2mhz_block)\n\t\tflags |= STA_CTXT_HE_RU_2MHZ_BLOCK;\n\n\t \n\tsta_ctxt_cmd.htc_flags = iwl_mvm_get_sta_htc_flags(sta, &sta->deflink);\n\n\t \n\tif (!iwl_mvm_set_sta_pkt_ext(mvm, &sta->deflink, &sta_ctxt_cmd.pkt_ext))\n\t\tflags |= STA_CTXT_HE_PACKET_EXT;\n\n\tif (sta->deflink.he_cap.he_cap_elem.mac_cap_info[2] &\n\t    IEEE80211_HE_MAC_CAP2_32BIT_BA_BITMAP)\n\t\tflags |= STA_CTXT_HE_32BIT_BA_BITMAP;\n\n\tif (sta->deflink.he_cap.he_cap_elem.mac_cap_info[2] &\n\t    IEEE80211_HE_MAC_CAP2_ACK_EN)\n\t\tflags |= STA_CTXT_HE_ACK_ENABLED;\n\n\trcu_read_unlock();\n\n\tif (iwl_mvm_set_fw_mu_edca_params(mvm, &mvmvif->deflink,\n\t\t\t\t\t  &sta_ctxt_cmd.trig_based_txf[0]))\n\t\tflags |= STA_CTXT_HE_MU_EDCA_CW;\n\n\tif (vif->bss_conf.uora_exists) {\n\t\tflags |= STA_CTXT_HE_TRIG_RND_ALLOC;\n\n\t\tsta_ctxt_cmd.rand_alloc_ecwmin =\n\t\t\tvif->bss_conf.uora_ocw_range & 0x7;\n\t\tsta_ctxt_cmd.rand_alloc_ecwmax =\n\t\t\t(vif->bss_conf.uora_ocw_range >> 3) & 0x7;\n\t}\n\n\tif (!iwl_mvm_is_nic_ack_enabled(mvm, vif))\n\t\tflags |= STA_CTXT_HE_NIC_NOT_ACK_ENABLED;\n\n\tif (vif->bss_conf.nontransmitted) {\n\t\tflags |= STA_CTXT_HE_REF_BSSID_VALID;\n\t\tether_addr_copy(sta_ctxt_cmd.ref_bssid_addr,\n\t\t\t\tvif->bss_conf.transmitter_bssid);\n\t\tsta_ctxt_cmd.max_bssid_indicator =\n\t\t\tvif->bss_conf.bssid_indicator;\n\t\tsta_ctxt_cmd.bssid_index = vif->bss_conf.bssid_index;\n\t\tsta_ctxt_cmd.ema_ap = vif->bss_conf.ema_ap;\n\t\tsta_ctxt_cmd.profile_periodicity =\n\t\t\tvif->bss_conf.profile_periodicity;\n\t}\n\n\tsta_ctxt_cmd.flags = cpu_to_le32(flags);\n\n\tif (ver < 3) {\n\t\t \n\t\tBUILD_BUG_ON(offsetof(typeof(sta_ctxt_cmd), pkt_ext) !=\n\t\t\t     offsetof(typeof(sta_ctxt_cmd_v2), pkt_ext));\n\t\tmemcpy(&sta_ctxt_cmd_v2, &sta_ctxt_cmd,\n\t\t       offsetof(typeof(sta_ctxt_cmd), pkt_ext));\n\n\t\t \n\t\tfor (i = 0;\n\t\t     i < ARRAY_SIZE(sta_ctxt_cmd_v2.pkt_ext.pkt_ext_qam_th);\n\t\t     i++) {\n\t\t\tu8 bw;\n\n\t\t\tfor (bw = 0;\n\t\t\t     bw < ARRAY_SIZE(sta_ctxt_cmd_v2.pkt_ext.pkt_ext_qam_th[i]);\n\t\t\t     bw++) {\n\t\t\t\tBUILD_BUG_ON(sizeof(sta_ctxt_cmd.pkt_ext.pkt_ext_qam_th[i][bw]) !=\n\t\t\t\t\t     sizeof(sta_ctxt_cmd_v2.pkt_ext.pkt_ext_qam_th[i][bw]));\n\n\t\t\t\tmemcpy(&sta_ctxt_cmd_v2.pkt_ext.pkt_ext_qam_th[i][bw],\n\t\t\t\t       &sta_ctxt_cmd.pkt_ext.pkt_ext_qam_th[i][bw],\n\t\t\t\t       sizeof(sta_ctxt_cmd.pkt_ext.pkt_ext_qam_th[i][bw]));\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tBUILD_BUG_ON(sizeof(sta_ctxt_cmd) -\n\t\t\t     offsetofend(typeof(sta_ctxt_cmd), pkt_ext) !=\n\t\t\t     sizeof(sta_ctxt_cmd_v2) -\n\t\t\t     offsetofend(typeof(sta_ctxt_cmd_v2), pkt_ext));\n\t\tmemcpy((u8 *)&sta_ctxt_cmd_v2 +\n\t\t\t\toffsetofend(typeof(sta_ctxt_cmd_v2), pkt_ext),\n\t\t       (u8 *)&sta_ctxt_cmd +\n\t\t\t\toffsetofend(typeof(sta_ctxt_cmd), pkt_ext),\n\t\t       sizeof(sta_ctxt_cmd) -\n\t\t\t\toffsetofend(typeof(sta_ctxt_cmd), pkt_ext));\n\t\tsta_ctxt_cmd_v2.reserved3 = 0;\n\t}\n\n\tif (iwl_mvm_send_cmd_pdu(mvm, cmd_id, 0, size, cmd))\n\t\tIWL_ERR(mvm, \"Failed to config FW to work HE!\\n\");\n}\n\nvoid iwl_mvm_protect_assoc(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t   u32 duration_override)\n{\n\tu32 duration = IWL_MVM_TE_SESSION_PROTECTION_MAX_TIME_MS;\n\tu32 min_duration = IWL_MVM_TE_SESSION_PROTECTION_MIN_TIME_MS;\n\n\tif (duration_override > duration)\n\t\tduration = duration_override;\n\n\t \n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_SESSION_PROT_CMD))\n\t\tiwl_mvm_schedule_session_protection(mvm, vif, 900,\n\t\t\t\t\t\t    min_duration, false);\n\telse\n\t\tiwl_mvm_protect_session(mvm, vif, duration,\n\t\t\t\t\tmin_duration, 500, false);\n}\n\n \nvoid iwl_mvm_bss_info_changed_station_assoc(struct iwl_mvm *mvm,\n\t\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t\t    u64 changes)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tint ret;\n\n\t \n\tif (test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status) &&\n\t    (changes & BSS_CHANGED_MU_GROUPS) && vif->bss_conf.mu_mimo_owner) {\n\t\tret = iwl_mvm_update_mu_groups(mvm, vif);\n\t\tif (ret)\n\t\t\tIWL_ERR(mvm,\n\t\t\t\t\"failed to update VHT MU_MIMO groups\\n\");\n\t}\n\n\tiwl_mvm_recalc_multicast(mvm);\n\n\t \n\tmvmvif->bf_data.ave_beacon_signal = 0;\n\n\tiwl_mvm_bt_coex_vif_change(mvm);\n\tiwl_mvm_update_smps_on_active_links(mvm, vif, IWL_MVM_SMPS_REQ_TT,\n\t\t\t\t\t    IEEE80211_SMPS_AUTOMATIC);\n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_UMAC_SCAN))\n\t\tiwl_mvm_config_scan(mvm);\n}\n\n \nvoid\niwl_mvm_bss_info_changed_station_common(struct iwl_mvm *mvm,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tstruct ieee80211_bss_conf *link_conf,\n\t\t\t\t\tu64 changes)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tint ret;\n\n\tif (changes & BSS_CHANGED_BEACON_INFO) {\n\t\t \n\t\tiwl_mvm_stop_session_protection(mvm, vif);\n\n\t\tiwl_mvm_sf_update(mvm, vif, false);\n\t\tWARN_ON(iwl_mvm_enable_beacon_filter(mvm, vif, 0));\n\t}\n\n\tif (changes & (BSS_CHANGED_PS | BSS_CHANGED_P2P_PS | BSS_CHANGED_QOS |\n\t\t        \n\t\t       BSS_CHANGED_BEACON_INFO)) {\n\t\tret = iwl_mvm_power_update_mac(mvm);\n\t\tif (ret)\n\t\t\tIWL_ERR(mvm, \"failed to update power mode\\n\");\n\t}\n\n\tif (changes & BSS_CHANGED_CQM) {\n\t\tIWL_DEBUG_MAC80211(mvm, \"cqm info_changed\\n\");\n\t\t \n\t\tmvmvif->bf_data.last_cqm_event = 0;\n\t\tif (mvmvif->bf_data.bf_enabled) {\n\t\t\t \n\t\t\tret = iwl_mvm_enable_beacon_filter(mvm, vif, 0);\n\t\t\tif (ret)\n\t\t\t\tIWL_ERR(mvm,\n\t\t\t\t\t\"failed to update CQM thresholds\\n\");\n\t\t}\n\t}\n\n\tif (changes & BSS_CHANGED_BANDWIDTH)\n\t\tiwl_mvm_update_link_smps(vif, link_conf);\n}\n\nstatic void iwl_mvm_bss_info_changed_station(struct iwl_mvm *mvm,\n\t\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t\t     struct ieee80211_bss_conf *bss_conf,\n\t\t\t\t\t     u64 changes)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tint ret;\n\n\t \n\tif (changes & BSS_CHANGED_ASSOC && vif->cfg.assoc) {\n\t\tif ((vif->bss_conf.he_support &&\n\t\t     !iwlwifi_mod_params.disable_11ax) ||\n\t\t    (vif->bss_conf.eht_support &&\n\t\t     !iwlwifi_mod_params.disable_11be))\n\t\t\tiwl_mvm_cfg_he_sta(mvm, vif, mvmvif->deflink.ap_sta_id);\n\n\t\tiwl_mvm_mac_ctxt_recalc_tsf_id(mvm, vif);\n\t}\n\n\t \n\tif (changes & BSS_CHANGED_QOS && mvmvif->associated &&\n\t    vif->cfg.assoc &&\n\t    ((vif->bss_conf.he_support &&\n\t      !iwlwifi_mod_params.disable_11ax) ||\n\t     (vif->bss_conf.eht_support &&\n\t      !iwlwifi_mod_params.disable_11be)))\n\t\tiwl_mvm_cfg_he_sta(mvm, vif, mvmvif->deflink.ap_sta_id);\n\n\t \n\tif (changes & BSS_CHANGED_BSSID && !mvmvif->associated)\n\t\tmemcpy(mvmvif->deflink.bssid, bss_conf->bssid, ETH_ALEN);\n\n\tret = iwl_mvm_mac_ctxt_changed(mvm, vif, false, mvmvif->deflink.bssid);\n\tif (ret)\n\t\tIWL_ERR(mvm, \"failed to update MAC %pM\\n\", vif->addr);\n\n\t \n\tmemcpy(mvmvif->deflink.bssid, bss_conf->bssid, ETH_ALEN);\n\tmvmvif->associated = vif->cfg.assoc;\n\n\tif (changes & BSS_CHANGED_ASSOC) {\n\t\tif (vif->cfg.assoc) {\n\t\t\t \n\t\t\tiwl_mvm_request_statistics(mvm, true);\n\t\t\tmemset(&mvmvif->deflink.beacon_stats, 0,\n\t\t\t       sizeof(mvmvif->deflink.beacon_stats));\n\n\t\t\t \n\t\t\tret = iwl_mvm_update_quotas(mvm, true, NULL);\n\t\t\tif (ret) {\n\t\t\t\tIWL_ERR(mvm, \"failed to update quotas\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (test_bit(IWL_MVM_STATUS_IN_HW_RESTART,\n\t\t\t\t     &mvm->status) &&\n\t\t\t    !fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t\t\t IWL_UCODE_TLV_CAPA_SESSION_PROT_CMD)) {\n\t\t\t\t \n\t\t\t\tu32 dur = (11 * vif->bss_conf.beacon_int) / 10;\n\t\t\t\tiwl_mvm_protect_session(mvm, vif, dur, dur,\n\t\t\t\t\t\t\t5 * dur, false);\n\t\t\t} else if (!test_bit(IWL_MVM_STATUS_IN_HW_RESTART,\n\t\t\t\t\t     &mvm->status) &&\n\t\t\t\t   !vif->bss_conf.dtim_period) {\n\t\t\t\t \n\t\t\t\tiwl_mvm_protect_assoc(mvm, vif, 0);\n\t\t\t}\n\n\t\t\tiwl_mvm_sf_update(mvm, vif, false);\n\t\t\tiwl_mvm_power_vif_assoc(mvm, vif);\n\t\t\tif (vif->p2p) {\n\t\t\t\tiwl_mvm_update_smps(mvm, vif,\n\t\t\t\t\t\t    IWL_MVM_SMPS_REQ_PROT,\n\t\t\t\t\t\t    IEEE80211_SMPS_DYNAMIC, 0);\n\t\t\t}\n\t\t} else if (mvmvif->deflink.ap_sta_id != IWL_MVM_INVALID_STA) {\n\t\t\tiwl_mvm_mei_host_disassociated(mvm);\n\t\t\t \n\t\t\tret = iwl_mvm_sf_update(mvm, vif, false);\n\t\t\tWARN_ONCE(ret &&\n\t\t\t\t  !test_bit(IWL_MVM_STATUS_HW_RESTART_REQUESTED,\n\t\t\t\t\t    &mvm->status),\n\t\t\t\t  \"Failed to update SF upon disassociation\\n\");\n\n\t\t\t \n\t\t\tif (!test_bit(IWL_MVM_STATUS_IN_HW_RESTART,\n\t\t\t\t      &mvm->status)) {\n\t\t\t\t \n\t\t\t\tiwl_mvm_sec_key_remove_ap(mvm, vif,\n\t\t\t\t\t\t\t  &mvmvif->deflink, 0);\n\n\t\t\t\t \n\t\t\t\tret = iwl_mvm_rm_sta_id(mvm, vif,\n\t\t\t\t\t\t\tmvmvif->deflink.ap_sta_id);\n\t\t\t\tif (ret)\n\t\t\t\t\tIWL_ERR(mvm,\n\t\t\t\t\t\t\"failed to remove AP station\\n\");\n\n\t\t\t\tmvmvif->deflink.ap_sta_id = IWL_MVM_INVALID_STA;\n\t\t\t}\n\n\t\t\t \n\t\t\tret = iwl_mvm_update_quotas(mvm, false, NULL);\n\t\t\tif (ret)\n\t\t\t\tIWL_ERR(mvm, \"failed to update quotas\\n\");\n\n\t\t\t \n\t\t\tret = iwl_mvm_mac_ctxt_changed(mvm, vif, false, NULL);\n\t\t\tif (ret)\n\t\t\t\tIWL_ERR(mvm,\n\t\t\t\t\t\"failed to update MAC %pM (clear after unassoc)\\n\",\n\t\t\t\t\tvif->addr);\n\t\t}\n\n\t\tiwl_mvm_bss_info_changed_station_assoc(mvm, vif, changes);\n\t}\n\n\tiwl_mvm_bss_info_changed_station_common(mvm, vif, &vif->bss_conf,\n\t\t\t\t\t\tchanges);\n}\n\nbool iwl_mvm_start_ap_ibss_common(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  int *ret)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tint i;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tmvmvif->ap_assoc_sta_count = 0;\n\n\t \n\tmvmvif->ap_ibss_active = true;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(mvmvif->ap_early_keys); i++) {\n\t\tstruct ieee80211_key_conf *key = mvmvif->ap_early_keys[i];\n\n\t\tif (!key)\n\t\t\tcontinue;\n\n\t\tmvmvif->ap_early_keys[i] = NULL;\n\n\t\t*ret = __iwl_mvm_mac_set_key(hw, SET_KEY, vif, NULL, key);\n\t\tif (*ret)\n\t\t\treturn true;\n\t}\n\n\tif (vif->type == NL80211_IFTYPE_AP && !vif->p2p) {\n\t\tiwl_mvm_vif_set_low_latency(mvmvif, true,\n\t\t\t\t\t    LOW_LATENCY_VIF_TYPE);\n\t\tiwl_mvm_send_low_latency_cmd(mvm, true, mvmvif->id);\n\t}\n\n\t \n\tiwl_mvm_power_update_mac(mvm);\n\n\treturn false;\n}\n\nstatic int iwl_mvm_start_ap_ibss(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_bss_conf *link_conf)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tint ret;\n\n\tmutex_lock(&mvm->mutex);\n\n\t \n\tif (vif->type == NL80211_IFTYPE_AP)\n\t\tiwl_mvm_mac_ctxt_recalc_tsf_id(mvm, vif);\n\n\t \n\tif (mvm->trans->trans_cfg->device_family > IWL_DEVICE_FAMILY_22000) {\n\t\t \n\t\tret = iwl_mvm_mac_ctxt_add(mvm, vif);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\n\t\t \n\t\tret = iwl_mvm_mac_ctxt_beacon_changed(mvm, vif, link_conf);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t} else {\n\t\t \n\t\tret = iwl_mvm_mac_ctxt_beacon_changed(mvm, vif, link_conf);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\n\t\t \n\t\tret = iwl_mvm_mac_ctxt_add(mvm, vif);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t \n\tret = iwl_mvm_binding_add_vif(mvm, vif);\n\tif (ret)\n\t\tgoto out_remove;\n\n\t \n\tif (fw_has_api(&mvm->fw->ucode_capa, IWL_UCODE_TLV_API_STA_TYPE)) {\n\t\tret = iwl_mvm_add_mcast_sta(mvm, vif);\n\t\tif (ret)\n\t\t\tgoto out_unbind;\n\t\t \n\t\tret = iwl_mvm_send_add_bcast_sta(mvm, vif);\n\t\tif (ret) {\n\t\t\tiwl_mvm_rm_mcast_sta(mvm, vif);\n\t\t\tgoto out_unbind;\n\t\t}\n\t} else {\n\t\t \n\t\tret = iwl_mvm_send_add_bcast_sta(mvm, vif);\n\t\tif (ret)\n\t\t\tgoto out_unbind;\n\t\tret = iwl_mvm_add_mcast_sta(mvm, vif);\n\t\tif (ret) {\n\t\t\tiwl_mvm_send_rm_bcast_sta(mvm, vif);\n\t\t\tgoto out_unbind;\n\t\t}\n\t}\n\n\tif (iwl_mvm_start_ap_ibss_common(hw, vif, &ret))\n\t\tgoto out_failed;\n\n\tret = iwl_mvm_update_quotas(mvm, false, NULL);\n\tif (ret)\n\t\tgoto out_failed;\n\n\t \n\tif (vif->p2p && mvm->p2p_device_vif)\n\t\tiwl_mvm_mac_ctxt_changed(mvm, mvm->p2p_device_vif, false, NULL);\n\n\tiwl_mvm_bt_coex_vif_change(mvm);\n\n\t \n\tif (iwl_mvm_phy_ctx_count(mvm) > 1)\n\t\tiwl_mvm_teardown_tdls_peers(mvm);\n\n\tiwl_mvm_ftm_restart_responder(mvm, vif, &vif->bss_conf);\n\n\tgoto out_unlock;\n\nout_failed:\n\tiwl_mvm_power_update_mac(mvm);\n\tmvmvif->ap_ibss_active = false;\n\tiwl_mvm_send_rm_bcast_sta(mvm, vif);\n\tiwl_mvm_rm_mcast_sta(mvm, vif);\nout_unbind:\n\tiwl_mvm_binding_remove_vif(mvm, vif);\nout_remove:\n\tiwl_mvm_mac_ctxt_remove(mvm, vif);\nout_unlock:\n\tmutex_unlock(&mvm->mutex);\n\treturn ret;\n}\n\nstatic int iwl_mvm_start_ap(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_bss_conf *link_conf)\n{\n\treturn iwl_mvm_start_ap_ibss(hw, vif, link_conf);\n}\n\nstatic int iwl_mvm_start_ibss(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif)\n{\n\treturn iwl_mvm_start_ap_ibss(hw, vif, &vif->bss_conf);\n}\n\n \nvoid iwl_mvm_stop_ap_ibss_common(struct iwl_mvm *mvm,\n\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tiwl_mvm_prepare_mac_removal(mvm, vif);\n\n\t \n\tif (rcu_access_pointer(mvm->csa_vif) == vif) {\n\t\tiwl_mvm_remove_time_event(mvm, mvmvif,\n\t\t\t\t\t  &mvmvif->time_event_data);\n\t\tRCU_INIT_POINTER(mvm->csa_vif, NULL);\n\t\tmvmvif->csa_countdown = false;\n\t}\n\n\tif (rcu_access_pointer(mvm->csa_tx_blocked_vif) == vif) {\n\t\tRCU_INIT_POINTER(mvm->csa_tx_blocked_vif, NULL);\n\t\tmvm->csa_tx_block_bcn_timeout = 0;\n\t}\n\n\tmvmvif->ap_ibss_active = false;\n\tmvm->ap_last_beacon_gp2 = 0;\n\n\tif (vif->type == NL80211_IFTYPE_AP && !vif->p2p) {\n\t\tiwl_mvm_vif_set_low_latency(mvmvif, false,\n\t\t\t\t\t    LOW_LATENCY_VIF_TYPE);\n\t\tiwl_mvm_send_low_latency_cmd(mvm, false,  mvmvif->id);\n\t}\n\n\tiwl_mvm_bt_coex_vif_change(mvm);\n}\n\nstatic void iwl_mvm_stop_ap_ibss(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_bss_conf *link_conf)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\tmutex_lock(&mvm->mutex);\n\n\tiwl_mvm_stop_ap_ibss_common(mvm, vif);\n\n\t \n\tif (vif->p2p && mvm->p2p_device_vif)\n\t\tiwl_mvm_mac_ctxt_changed(mvm, mvm->p2p_device_vif, false, NULL);\n\n\tiwl_mvm_update_quotas(mvm, false, NULL);\n\n\tiwl_mvm_ftm_responder_clear(mvm, vif);\n\n\t \n\tif (!fw_has_api(&mvm->fw->ucode_capa, IWL_UCODE_TLV_API_STA_TYPE))\n\t\tiwl_mvm_rm_mcast_sta(mvm, vif);\n\tiwl_mvm_send_rm_bcast_sta(mvm, vif);\n\tif (fw_has_api(&mvm->fw->ucode_capa, IWL_UCODE_TLV_API_STA_TYPE))\n\t\tiwl_mvm_rm_mcast_sta(mvm, vif);\n\tiwl_mvm_binding_remove_vif(mvm, vif);\n\n\tiwl_mvm_power_update_mac(mvm);\n\n\tiwl_mvm_mac_ctxt_remove(mvm, vif);\n\n\tmutex_unlock(&mvm->mutex);\n}\n\nstatic void iwl_mvm_stop_ap(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_bss_conf *link_conf)\n{\n\tiwl_mvm_stop_ap_ibss(hw, vif, link_conf);\n}\n\nstatic void iwl_mvm_stop_ibss(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif)\n{\n\tiwl_mvm_stop_ap_ibss(hw, vif, &vif->bss_conf);\n}\n\nstatic void\niwl_mvm_bss_info_changed_ap_ibss(struct iwl_mvm *mvm,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_bss_conf *bss_conf,\n\t\t\t\t u64 changes)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\t \n\tif (!mvmvif->ap_ibss_active)\n\t\treturn;\n\n\tif (changes & (BSS_CHANGED_ERP_CTS_PROT | BSS_CHANGED_HT |\n\t\t       BSS_CHANGED_BANDWIDTH | BSS_CHANGED_QOS) &&\n\t    iwl_mvm_mac_ctxt_changed(mvm, vif, false, NULL))\n\t\tIWL_ERR(mvm, \"failed to update MAC %pM\\n\", vif->addr);\n\n\t \n\tif (changes & BSS_CHANGED_BEACON &&\n\t    iwl_mvm_mac_ctxt_beacon_changed(mvm, vif, &vif->bss_conf))\n\t\tIWL_WARN(mvm, \"Failed updating beacon data\\n\");\n\n\tif (changes & BSS_CHANGED_FTM_RESPONDER) {\n\t\tint ret = iwl_mvm_ftm_start_responder(mvm, vif, &vif->bss_conf);\n\n\t\tif (ret)\n\t\t\tIWL_WARN(mvm, \"Failed to enable FTM responder (%d)\\n\",\n\t\t\t\t ret);\n\t}\n\n}\n\nstatic void iwl_mvm_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_bss_conf *bss_conf,\n\t\t\t\t     u64 changes)\n{\n\tstatic const struct iwl_mvm_bss_info_changed_ops callbacks = {\n\t\t.bss_info_changed_sta = iwl_mvm_bss_info_changed_station,\n\t\t.bss_info_changed_ap_ibss = iwl_mvm_bss_info_changed_ap_ibss,\n\t};\n\n\tiwl_mvm_bss_info_changed_common(hw, vif, bss_conf, &callbacks,\n\t\t\t\t\tchanges);\n}\n\nvoid\niwl_mvm_bss_info_changed_common(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_bss_conf *bss_conf,\n\t\t\t\tconst struct iwl_mvm_bss_info_changed_ops *callbacks,\n\t\t\t\tu64 changes)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\tmutex_lock(&mvm->mutex);\n\n\tif (changes & BSS_CHANGED_IDLE && !vif->cfg.idle)\n\t\tiwl_mvm_scan_stop(mvm, IWL_MVM_SCAN_SCHED, true);\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tcallbacks->bss_info_changed_sta(mvm, vif, bss_conf, changes);\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tcallbacks->bss_info_changed_ap_ibss(mvm, vif, bss_conf,\n\t\t\t\t\t\t    changes);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (changes & BSS_CHANGED_MU_GROUPS)\n\t\t\tiwl_mvm_update_mu_groups(mvm, vif);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARN_ON_ONCE(1);\n\t}\n\n\tif (changes & BSS_CHANGED_TXPOWER) {\n\t\tIWL_DEBUG_CALIB(mvm, \"Changing TX Power to %d dBm\\n\",\n\t\t\t\tbss_conf->txpower);\n\t\tiwl_mvm_set_tx_power(mvm, vif, bss_conf->txpower);\n\t}\n\n\tmutex_unlock(&mvm->mutex);\n}\n\nint iwl_mvm_mac_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_scan_request *hw_req)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tint ret;\n\n\tif (hw_req->req.n_channels == 0 ||\n\t    hw_req->req.n_channels > mvm->fw->ucode_capa.n_scan_channels)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mvm->mutex);\n\tret = iwl_mvm_reg_scan_start(mvm, vif, &hw_req->req, &hw_req->ies);\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret;\n}\n\nvoid iwl_mvm_mac_cancel_hw_scan(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\tmutex_lock(&mvm->mutex);\n\n\t \n\tif (mvm->scan_status & IWL_MVM_SCAN_REGULAR)\n\t\tiwl_mvm_scan_stop(mvm, IWL_MVM_SCAN_REGULAR, true);\n\n\tmutex_unlock(&mvm->mutex);\n}\n\nvoid\niwl_mvm_mac_allow_buffered_frames(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_sta *sta, u16 tids,\n\t\t\t\t  int num_frames,\n\t\t\t\t  enum ieee80211_frame_release_type reason,\n\t\t\t\t  bool more_data)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\t \n\n\tiwl_mvm_sta_modify_sleep_tx_count(mvm, sta, reason, num_frames,\n\t\t\t\t\t  tids, more_data, false);\n}\n\nvoid\niwl_mvm_mac_release_buffered_frames(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_sta *sta, u16 tids,\n\t\t\t\t    int num_frames,\n\t\t\t\t    enum ieee80211_frame_release_type reason,\n\t\t\t\t    bool more_data)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\t \n\n\tiwl_mvm_sta_modify_sleep_tx_count(mvm, sta, reason, num_frames,\n\t\t\t\t\t  tids, more_data, true);\n}\n\nstatic void __iwl_mvm_mac_sta_notify(struct ieee80211_hw *hw,\n\t\t\t\t     enum sta_notify_cmd cmd,\n\t\t\t\t     struct ieee80211_sta *sta)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tunsigned long txqs = 0, tids = 0;\n\tint tid;\n\n\t \n\tif (WARN_ON(iwl_mvm_has_new_tx_api(mvm)))\n\t\treturn;\n\n\tspin_lock_bh(&mvmsta->lock);\n\tfor (tid = 0; tid < ARRAY_SIZE(mvmsta->tid_data); tid++) {\n\t\tstruct iwl_mvm_tid_data *tid_data = &mvmsta->tid_data[tid];\n\n\t\tif (tid_data->txq_id == IWL_MVM_INVALID_QUEUE)\n\t\t\tcontinue;\n\n\t\t__set_bit(tid_data->txq_id, &txqs);\n\n\t\tif (iwl_mvm_tid_queued(mvm, tid_data) == 0)\n\t\t\tcontinue;\n\n\t\t__set_bit(tid, &tids);\n\t}\n\n\tswitch (cmd) {\n\tcase STA_NOTIFY_SLEEP:\n\t\tfor_each_set_bit(tid, &tids, IWL_MAX_TID_COUNT)\n\t\t\tieee80211_sta_set_buffered(sta, tid, true);\n\n\t\tif (txqs)\n\t\t\tiwl_trans_freeze_txq_timer(mvm->trans, txqs, true);\n\t\t \n\t\tbreak;\n\tcase STA_NOTIFY_AWAKE:\n\t\tif (WARN_ON(mvmsta->deflink.sta_id == IWL_MVM_INVALID_STA))\n\t\t\tbreak;\n\n\t\tif (txqs)\n\t\t\tiwl_trans_freeze_txq_timer(mvm->trans, txqs, false);\n\t\tiwl_mvm_sta_modify_ps_wake(mvm, sta);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tspin_unlock_bh(&mvmsta->lock);\n}\n\nvoid iwl_mvm_mac_sta_notify(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t    enum sta_notify_cmd cmd, struct ieee80211_sta *sta)\n{\n\t__iwl_mvm_mac_sta_notify(hw, cmd, sta);\n}\n\nvoid iwl_mvm_sta_pm_notif(struct iwl_mvm *mvm, struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_mvm_pm_state_notification *notif = (void *)pkt->data;\n\tstruct ieee80211_sta *sta;\n\tstruct iwl_mvm_sta *mvmsta;\n\tbool sleeping = (notif->type != IWL_MVM_PM_EVENT_AWAKE);\n\n\tif (WARN_ON(notif->sta_id >= mvm->fw->ucode_capa.num_stations))\n\t\treturn;\n\n\trcu_read_lock();\n\tsta = rcu_dereference(mvm->fw_id_to_mac_id[notif->sta_id]);\n\tif (WARN_ON(IS_ERR_OR_NULL(sta))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tmvmsta = iwl_mvm_sta_from_mac80211(sta);\n\n\tif (!mvmsta->vif ||\n\t    mvmsta->vif->type != NL80211_IFTYPE_AP) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (mvmsta->sleeping != sleeping) {\n\t\tmvmsta->sleeping = sleeping;\n\t\t__iwl_mvm_mac_sta_notify(mvm->hw,\n\t\t\tsleeping ? STA_NOTIFY_SLEEP : STA_NOTIFY_AWAKE,\n\t\t\tsta);\n\t\tieee80211_sta_ps_transition(sta, sleeping);\n\t}\n\n\tif (sleeping) {\n\t\tswitch (notif->type) {\n\t\tcase IWL_MVM_PM_EVENT_AWAKE:\n\t\tcase IWL_MVM_PM_EVENT_ASLEEP:\n\t\t\tbreak;\n\t\tcase IWL_MVM_PM_EVENT_UAPSD:\n\t\t\tieee80211_sta_uapsd_trigger(sta, IEEE80211_NUM_TIDS);\n\t\t\tbreak;\n\t\tcase IWL_MVM_PM_EVENT_PS_POLL:\n\t\t\tieee80211_sta_pspoll(sta);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n}\n\nvoid iwl_mvm_sta_pre_rcu_remove(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\tunsigned int link_id;\n\n\t \n\tmutex_lock(&mvm->mutex);\n\tfor (link_id = 0; link_id < ARRAY_SIZE(mvm_sta->link); link_id++) {\n\t\tstruct iwl_mvm_link_sta *link_sta;\n\t\tu32 sta_id;\n\n\t\tif (!mvm_sta->link[link_id])\n\t\t\tcontinue;\n\n\t\tlink_sta = rcu_dereference_protected(mvm_sta->link[link_id],\n\t\t\t\t\t\t     lockdep_is_held(&mvm->mutex));\n\t\tsta_id = link_sta->sta_id;\n\t\tif (sta == rcu_access_pointer(mvm->fw_id_to_mac_id[sta_id])) {\n\t\t\tRCU_INIT_POINTER(mvm->fw_id_to_mac_id[sta_id],\n\t\t\t\t\t ERR_PTR(-ENOENT));\n\t\t\tRCU_INIT_POINTER(mvm->fw_id_to_link_sta[sta_id], NULL);\n\t\t}\n\t}\n\tmutex_unlock(&mvm->mutex);\n}\n\nstatic void iwl_mvm_check_uapsd(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t\tconst u8 *bssid)\n{\n\tint i;\n\n\tif (!test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status)) {\n\t\tstruct iwl_mvm_tcm_mac *mdata;\n\n\t\tmdata = &mvm->tcm.data[iwl_mvm_vif_from_mac80211(vif)->id];\n\t\tewma_rate_init(&mdata->uapsd_nonagg_detect.rate);\n\t\tmdata->opened_rx_ba_sessions = false;\n\t}\n\n\tif (!(mvm->fw->ucode_capa.flags & IWL_UCODE_TLV_FLAGS_UAPSD_SUPPORT))\n\t\treturn;\n\n\tif (vif->p2p && !iwl_mvm_is_p2p_scm_uapsd_supported(mvm)) {\n\t\tvif->driver_flags &= ~IEEE80211_VIF_SUPPORTS_UAPSD;\n\t\treturn;\n\t}\n\n\tif (!vif->p2p &&\n\t    (iwlwifi_mod_params.uapsd_disable & IWL_DISABLE_UAPSD_BSS)) {\n\t\tvif->driver_flags &= ~IEEE80211_VIF_SUPPORTS_UAPSD;\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < IWL_MVM_UAPSD_NOAGG_LIST_LEN; i++) {\n\t\tif (ether_addr_equal(mvm->uapsd_noagg_bssids[i].addr, bssid)) {\n\t\t\tvif->driver_flags &= ~IEEE80211_VIF_SUPPORTS_UAPSD;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvif->driver_flags |= IEEE80211_VIF_SUPPORTS_UAPSD;\n}\n\nstatic void\niwl_mvm_tdls_check_trigger(struct iwl_mvm *mvm,\n\t\t\t   struct ieee80211_vif *vif, u8 *peer_addr,\n\t\t\t   enum nl80211_tdls_operation action)\n{\n\tstruct iwl_fw_dbg_trigger_tlv *trig;\n\tstruct iwl_fw_dbg_trigger_tdls *tdls_trig;\n\n\ttrig = iwl_fw_dbg_trigger_on(&mvm->fwrt, ieee80211_vif_to_wdev(vif),\n\t\t\t\t     FW_DBG_TRIGGER_TDLS);\n\tif (!trig)\n\t\treturn;\n\n\ttdls_trig = (void *)trig->data;\n\n\tif (!(tdls_trig->action_bitmap & BIT(action)))\n\t\treturn;\n\n\tif (tdls_trig->peer_mode &&\n\t    memcmp(tdls_trig->peer, peer_addr, ETH_ALEN) != 0)\n\t\treturn;\n\n\tiwl_fw_dbg_collect_trig(&mvm->fwrt, trig,\n\t\t\t\t\"TDLS event occurred, peer %pM, action %d\",\n\t\t\t\tpeer_addr, action);\n}\n\nstruct iwl_mvm_he_obss_narrow_bw_ru_data {\n\tbool tolerated;\n};\n\nstatic void iwl_mvm_check_he_obss_narrow_bw_ru_iter(struct wiphy *wiphy,\n\t\t\t\t\t\t    struct cfg80211_bss *bss,\n\t\t\t\t\t\t    void *_data)\n{\n\tstruct iwl_mvm_he_obss_narrow_bw_ru_data *data = _data;\n\tconst struct cfg80211_bss_ies *ies;\n\tconst struct element *elem;\n\n\trcu_read_lock();\n\ties = rcu_dereference(bss->ies);\n\telem = cfg80211_find_elem(WLAN_EID_EXT_CAPABILITY, ies->data,\n\t\t\t\t  ies->len);\n\n\tif (!elem || elem->datalen < 10 ||\n\t    !(elem->data[10] &\n\t      WLAN_EXT_CAPA10_OBSS_NARROW_BW_RU_TOLERANCE_SUPPORT)) {\n\t\tdata->tolerated = false;\n\t}\n\trcu_read_unlock();\n}\n\nstatic void\niwl_mvm_check_he_obss_narrow_bw_ru(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   unsigned int link_id,\n\t\t\t\t   struct ieee80211_bss_conf *link_conf)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_he_obss_narrow_bw_ru_data iter_data = {\n\t\t.tolerated = true,\n\t};\n\n\tif (WARN_ON_ONCE(!link_conf->chandef.chan ||\n\t\t\t !mvmvif->link[link_id]))\n\t\treturn;\n\n\tif (!(link_conf->chandef.chan->flags & IEEE80211_CHAN_RADAR)) {\n\t\tmvmvif->link[link_id]->he_ru_2mhz_block = false;\n\t\treturn;\n\t}\n\n\tcfg80211_bss_iter(hw->wiphy, &link_conf->chandef,\n\t\t\t  iwl_mvm_check_he_obss_narrow_bw_ru_iter,\n\t\t\t  &iter_data);\n\n\t \n\tmvmvif->link[link_id]->he_ru_2mhz_block = !iter_data.tolerated;\n}\n\nstatic void iwl_mvm_reset_cca_40mhz_workaround(struct iwl_mvm *mvm,\n\t\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_supported_band *sband;\n\tconst struct ieee80211_sta_he_cap *he_cap;\n\n\tif (vif->type != NL80211_IFTYPE_STATION)\n\t\treturn;\n\n\tif (!mvm->cca_40mhz_workaround)\n\t\treturn;\n\n\t \n\tmvm->cca_40mhz_workaround--;\n\tif (mvm->cca_40mhz_workaround)\n\t\treturn;\n\n\tsband = mvm->hw->wiphy->bands[NL80211_BAND_2GHZ];\n\n\tsband->ht_cap.cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\n\the_cap = ieee80211_get_he_iftype_cap_vif(sband, vif);\n\n\tif (he_cap) {\n\t\t \n\t\tstruct ieee80211_sta_he_cap *he = (void *)(uintptr_t)he_cap;\n\n\t\the->he_cap_elem.phy_cap_info[0] |=\n\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G;\n\t}\n}\n\nstatic void iwl_mvm_mei_host_associated(struct iwl_mvm *mvm,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tstruct iwl_mvm_sta *mvm_sta)\n{\n#if IS_ENABLED(CONFIG_IWLMEI)\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mei_conn_info conn_info = {\n\t\t.ssid_len = vif->cfg.ssid_len,\n\t};\n\n\tif (test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status))\n\t\treturn;\n\n\tif (!mvm->mei_registered)\n\t\treturn;\n\n\t \n\tif (!vif->bss_conf.chandef.chan)\n\t\treturn;\n\n\tconn_info.channel = vif->bss_conf.chandef.chan->hw_value;\n\n\tswitch (mvm_sta->pairwise_cipher) {\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tconn_info.pairwise_cipher = IWL_MEI_CIPHER_TKIP;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tconn_info.pairwise_cipher = IWL_MEI_CIPHER_CCMP;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\t\tconn_info.pairwise_cipher = IWL_MEI_CIPHER_GCMP;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\tconn_info.pairwise_cipher = IWL_MEI_CIPHER_GCMP_256;\n\t\tbreak;\n\tcase 0:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn;\n\t}\n\n\tswitch (mvmvif->rekey_data.akm) {\n\tcase WLAN_AKM_SUITE_SAE & 0xff:\n\t\tconn_info.auth_mode = IWL_MEI_AKM_AUTH_SAE;\n\t\tbreak;\n\tcase WLAN_AKM_SUITE_PSK & 0xff:\n\t\tconn_info.auth_mode = IWL_MEI_AKM_AUTH_RSNA_PSK;\n\t\tbreak;\n\tcase WLAN_AKM_SUITE_8021X & 0xff:\n\t\tconn_info.auth_mode = IWL_MEI_AKM_AUTH_RSNA;\n\t\tbreak;\n\tcase 0:\n\t\t \n\t\tconn_info.auth_mode = IWL_MEI_AKM_AUTH_OPEN;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\t \n\t\treturn;\n\t}\n\n\tmemcpy(conn_info.ssid, vif->cfg.ssid, vif->cfg.ssid_len);\n\tmemcpy(conn_info.bssid,  vif->bss_conf.bssid, ETH_ALEN);\n\n\t \n\tiwl_mei_host_associated(&conn_info, NULL);\n#endif\n}\n\nstatic int iwl_mvm_mac_ctxt_changed_wrapper(struct iwl_mvm *mvm,\n\t\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t\t    bool force_assoc_off)\n{\n\treturn iwl_mvm_mac_ctxt_changed(mvm, vif, force_assoc_off, NULL);\n}\n\nstatic int iwl_mvm_mac_sta_state(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t enum ieee80211_sta_state old_state,\n\t\t\t\t enum ieee80211_sta_state new_state)\n{\n\tstatic const struct iwl_mvm_sta_state_ops callbacks = {\n\t\t.add_sta = iwl_mvm_add_sta,\n\t\t.update_sta = iwl_mvm_update_sta,\n\t\t.rm_sta = iwl_mvm_rm_sta,\n\t\t.mac_ctxt_changed = iwl_mvm_mac_ctxt_changed_wrapper,\n\t};\n\n\treturn iwl_mvm_mac_sta_state_common(hw, vif, sta, old_state, new_state,\n\t\t\t\t\t    &callbacks);\n}\n\n \nstatic void iwl_mvm_rs_rate_init_all_links(struct iwl_mvm *mvm,\n\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t   struct ieee80211_sta *sta)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tunsigned int link_id;\n\n\tfor_each_mvm_vif_valid_link(mvmvif, link_id) {\n\t\tstruct ieee80211_bss_conf *conf =\n\t\t\tlink_conf_dereference_check(vif, link_id);\n\t\tstruct ieee80211_link_sta *link_sta =\n\t\t\tlink_sta_dereference_check(sta, link_id);\n\n\t\tif (!conf || !link_sta || !mvmvif->link[link_id]->phy_ctxt)\n\t\t\tcontinue;\n\n\t\tiwl_mvm_rs_rate_init(mvm, vif, sta, conf, link_sta,\n\t\t\t\t     mvmvif->link[link_id]->phy_ctxt->channel->band);\n\t}\n}\n\n#define IWL_MVM_MIN_BEACON_INTERVAL_TU 16\n\nstatic bool iwl_mvm_vif_conf_from_sta(struct iwl_mvm *mvm,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta *sta)\n{\n\tstruct ieee80211_link_sta *link_sta;\n\tunsigned int link_id;\n\n\t \n\n\tfor_each_sta_active_link(vif, sta, link_sta, link_id) {\n\t\tstruct ieee80211_bss_conf *link_conf =\n\t\t\tlink_conf_dereference_protected(vif, link_id);\n\n\t\tif (!link_conf)\n\t\t\tcontinue;\n\n\t\tif (link_conf->beacon_int < IWL_MVM_MIN_BEACON_INTERVAL_TU) {\n\t\t\tIWL_ERR(mvm,\n\t\t\t\t\"Beacon interval %d for AP %pM is too small\\n\",\n\t\t\t\tlink_conf->beacon_int, link_sta->addr);\n\t\t\treturn false;\n\t\t}\n\n\t\tlink_conf->he_support = link_sta->he_cap.has_he;\n\t}\n\n\treturn true;\n}\n\nstatic void iwl_mvm_vif_set_he_support(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_sta *sta,\n\t\t\t\t       bool is_sta)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct ieee80211_link_sta *link_sta;\n\tunsigned int link_id;\n\n\tfor_each_sta_active_link(vif, sta, link_sta, link_id) {\n\t\tstruct ieee80211_bss_conf *link_conf =\n\t\t\tlink_conf_dereference_protected(vif, link_id);\n\n\t\tif (!link_conf || !mvmvif->link[link_id])\n\t\t\tcontinue;\n\n\t\tlink_conf->he_support = link_sta->he_cap.has_he;\n\n\t\tif (is_sta) {\n\t\t\tmvmvif->link[link_id]->he_ru_2mhz_block = false;\n\t\t\tif (link_sta->he_cap.has_he)\n\t\t\t\tiwl_mvm_check_he_obss_narrow_bw_ru(hw, vif,\n\t\t\t\t\t\t\t\t   link_id,\n\t\t\t\t\t\t\t\t   link_conf);\n\t\t}\n\t}\n}\n\nstatic int\niwl_mvm_sta_state_notexist_to_none(struct iwl_mvm *mvm,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   const struct iwl_mvm_sta_state_ops *callbacks)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct ieee80211_link_sta *link_sta;\n\tunsigned int i;\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (vif->type == NL80211_IFTYPE_STATION &&\n\t    !iwl_mvm_vif_conf_from_sta(mvm, vif, sta))\n\t\treturn -EINVAL;\n\n\tif (sta->tdls &&\n\t    (vif->p2p ||\n\t     iwl_mvm_tdls_sta_count(mvm, NULL) == IWL_MVM_TDLS_STA_COUNT ||\n\t     iwl_mvm_phy_ctx_count(mvm) > 1)) {\n\t\tIWL_DEBUG_MAC80211(mvm, \"refusing TDLS sta\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tret = callbacks->add_sta(mvm, vif, sta);\n\tif (sta->tdls && ret == 0) {\n\t\tiwl_mvm_recalc_tdls_state(mvm, vif, true);\n\t\tiwl_mvm_tdls_check_trigger(mvm, vif, sta->addr,\n\t\t\t\t\t   NL80211_TDLS_SETUP);\n\t}\n\n\tfor_each_sta_active_link(vif, sta, link_sta, i)\n\t\tlink_sta->agg.max_rc_amsdu_len = 1;\n\n\tieee80211_sta_recalc_aggregates(sta);\n\n\tif (vif->type == NL80211_IFTYPE_STATION && !sta->tdls)\n\t\tmvmvif->ap_sta = sta;\n\n\treturn 0;\n}\n\nstatic int\niwl_mvm_sta_state_auth_to_assoc(struct ieee80211_hw *hw,\n\t\t\t\tstruct iwl_mvm *mvm,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\tconst struct iwl_mvm_sta_state_ops *callbacks)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct ieee80211_link_sta *link_sta;\n\tunsigned int link_id;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (vif->type == NL80211_IFTYPE_AP) {\n\t\tiwl_mvm_vif_set_he_support(hw, vif, sta, false);\n\t\tmvmvif->ap_assoc_sta_count++;\n\t\tcallbacks->mac_ctxt_changed(mvm, vif, false);\n\n\t\t \n\t\tif (!mvm->mld_api_is_used &&\n\t\t    ((vif->bss_conf.he_support &&\n\t\t      !iwlwifi_mod_params.disable_11ax) ||\n\t\t    (vif->bss_conf.eht_support &&\n\t\t     !iwlwifi_mod_params.disable_11be)))\n\t\t\tiwl_mvm_cfg_he_sta(mvm, vif, mvm_sta->deflink.sta_id);\n\t} else if (vif->type == NL80211_IFTYPE_STATION) {\n\t\tiwl_mvm_vif_set_he_support(hw, vif, sta, true);\n\n\t\tcallbacks->mac_ctxt_changed(mvm, vif, false);\n\n\t\tif (!mvm->mld_api_is_used)\n\t\t\tgoto out;\n\n\t\tfor_each_sta_active_link(vif, sta, link_sta, link_id) {\n\t\t\tstruct ieee80211_bss_conf *link_conf =\n\t\t\t\tlink_conf_dereference_protected(vif, link_id);\n\n\t\t\tif (WARN_ON(!link_conf))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (!mvmvif->link[link_id])\n\t\t\t\tcontinue;\n\n\t\t\tiwl_mvm_link_changed(mvm, vif, link_conf,\n\t\t\t\t\t     LINK_CONTEXT_MODIFY_ALL &\n\t\t\t\t\t     ~LINK_CONTEXT_MODIFY_ACTIVE,\n\t\t\t\t\t     true);\n\t\t}\n\t}\n\nout:\n\tiwl_mvm_rs_rate_init_all_links(mvm, vif, sta);\n\n\treturn callbacks->update_sta(mvm, vif, sta);\n}\n\nstatic int\niwl_mvm_sta_state_assoc_to_authorized(struct iwl_mvm *mvm,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      const struct iwl_mvm_sta_state_ops *callbacks)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\t \n\tif (iwl_mvm_phy_ctx_count(mvm) > 1)\n\t\tiwl_mvm_teardown_tdls_peers(mvm);\n\n\tif (sta->tdls) {\n\t\tiwl_mvm_tdls_check_trigger(mvm, vif, sta->addr,\n\t\t\t\t\t   NL80211_TDLS_ENABLE_LINK);\n\t} else {\n\t\t \n\t\tWARN_ON(iwl_mvm_enable_beacon_filter(mvm, vif, 0));\n\n\t\tmvmvif->authorized = 1;\n\n\t\tcallbacks->mac_ctxt_changed(mvm, vif, false);\n\t\tiwl_mvm_mei_host_associated(mvm, vif, mvm_sta);\n\t}\n\n\tmvm_sta->authorized = true;\n\n\tiwl_mvm_rs_rate_init_all_links(mvm, vif, sta);\n\n\t \n\tif (!sta->mfp)\n\t\treturn callbacks->update_sta(mvm, vif, sta);\n\n\treturn 0;\n}\n\nstatic int\niwl_mvm_sta_state_authorized_to_assoc(struct iwl_mvm *mvm,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      const struct iwl_mvm_sta_state_ops *callbacks)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tmvmsta->authorized = false;\n\n\t \n\tiwl_mvm_rs_rate_init_all_links(mvm, vif, sta);\n\n\tif (!sta->tdls) {\n\t\t \n\t\tmvmvif->authorized = 0;\n\n\t\t \n\t\tiwl_mvm_disable_beacon_filter(mvm, vif, 0);\n\t}\n\n\treturn 0;\n}\n\n \nint iwl_mvm_mac_sta_state_common(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t enum ieee80211_sta_state old_state,\n\t\t\t\t enum ieee80211_sta_state new_state,\n\t\t\t\t const struct iwl_mvm_sta_state_ops *callbacks)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct ieee80211_link_sta *link_sta;\n\tunsigned int link_id;\n\tint ret;\n\n\tIWL_DEBUG_MAC80211(mvm, \"station %pM state change %d->%d\\n\",\n\t\t\t   sta->addr, old_state, new_state);\n\n\t \n\tif (old_state == IEEE80211_STA_NONE &&\n\t    new_state == IEEE80211_STA_NOTEXIST) {\n\t\tflush_work(&mvm->add_stream_wk);\n\n\t\t \n\n\t\t \n\t\tiwl_mvm_reset_cca_40mhz_workaround(mvm, vif);\n\n\t\t \n\t\tkfree(mvm_sta->dup_data);\n\t}\n\n\tmutex_lock(&mvm->mutex);\n\n\t \n\tfor_each_sta_active_link(vif, sta, link_sta, link_id) {\n\t\tif (WARN_ON_ONCE(!mvmvif->link[link_id]->phy_ctxt)) {\n\t\t\tmutex_unlock(&mvm->mutex);\n\t\t\treturn test_bit(IWL_MVM_STATUS_HW_RESTART_REQUESTED,\n\t\t\t\t\t&mvm->status) ? 0 : -EINVAL;\n\t\t}\n\t}\n\n\t \n\tmvm_sta->sta_state = new_state;\n\n\tif (old_state == IEEE80211_STA_NOTEXIST &&\n\t    new_state == IEEE80211_STA_NONE) {\n\t\tret = iwl_mvm_sta_state_notexist_to_none(mvm, vif, sta,\n\t\t\t\t\t\t\t callbacks);\n\t\tif (ret < 0)\n\t\t\tgoto out_unlock;\n\t} else if (old_state == IEEE80211_STA_NONE &&\n\t\t   new_state == IEEE80211_STA_AUTH) {\n\t\t \n\t\tmvm->last_ebs_successful = true;\n\t\tiwl_mvm_check_uapsd(mvm, vif, sta->addr);\n\t\tret = 0;\n\t} else if (old_state == IEEE80211_STA_AUTH &&\n\t\t   new_state == IEEE80211_STA_ASSOC) {\n\t\tret = iwl_mvm_sta_state_auth_to_assoc(hw, mvm, vif, sta,\n\t\t\t\t\t\t      callbacks);\n\t} else if (old_state == IEEE80211_STA_ASSOC &&\n\t\t   new_state == IEEE80211_STA_AUTHORIZED) {\n\t\tret = iwl_mvm_sta_state_assoc_to_authorized(mvm, vif, sta,\n\t\t\t\t\t\t\t    callbacks);\n\t} else if (old_state == IEEE80211_STA_AUTHORIZED &&\n\t\t   new_state == IEEE80211_STA_ASSOC) {\n\t\tret = iwl_mvm_sta_state_authorized_to_assoc(mvm, vif, sta,\n\t\t\t\t\t\t\t    callbacks);\n\t} else if (old_state == IEEE80211_STA_ASSOC &&\n\t\t   new_state == IEEE80211_STA_AUTH) {\n\t\tif (vif->type == NL80211_IFTYPE_AP) {\n\t\t\tmvmvif->ap_assoc_sta_count--;\n\t\t\tcallbacks->mac_ctxt_changed(mvm, vif, false);\n\t\t} else if (vif->type == NL80211_IFTYPE_STATION && !sta->tdls)\n\t\t\tiwl_mvm_stop_session_protection(mvm, vif);\n\t\tret = 0;\n\t} else if (old_state == IEEE80211_STA_AUTH &&\n\t\t   new_state == IEEE80211_STA_NONE) {\n\t\tret = 0;\n\t} else if (old_state == IEEE80211_STA_NONE &&\n\t\t   new_state == IEEE80211_STA_NOTEXIST) {\n\t\tif (vif->type == NL80211_IFTYPE_STATION && !sta->tdls) {\n\t\t\tiwl_mvm_stop_session_protection(mvm, vif);\n\t\t\tmvmvif->ap_sta = NULL;\n\t\t}\n\t\tret = callbacks->rm_sta(mvm, vif, sta);\n\t\tif (sta->tdls) {\n\t\t\tiwl_mvm_recalc_tdls_state(mvm, vif, false);\n\t\t\tiwl_mvm_tdls_check_trigger(mvm, vif, sta->addr,\n\t\t\t\t\t\t   NL80211_TDLS_DISABLE_LINK);\n\t\t}\n\n\t\tif (unlikely(ret &&\n\t\t\t     test_bit(IWL_MVM_STATUS_HW_RESTART_REQUESTED,\n\t\t\t\t      &mvm->status)))\n\t\t\tret = 0;\n\t} else {\n\t\tret = -EIO;\n\t}\n out_unlock:\n\tmutex_unlock(&mvm->mutex);\n\n\tif (sta->tdls && ret == 0) {\n\t\tif (old_state == IEEE80211_STA_NOTEXIST &&\n\t\t    new_state == IEEE80211_STA_NONE)\n\t\t\tieee80211_reserve_tid(sta, IWL_MVM_TDLS_FW_TID);\n\t\telse if (old_state == IEEE80211_STA_NONE &&\n\t\t\t new_state == IEEE80211_STA_NOTEXIST)\n\t\t\tieee80211_unreserve_tid(sta, IWL_MVM_TDLS_FW_TID);\n\t}\n\n\treturn ret;\n}\n\nint iwl_mvm_mac_set_rts_threshold(struct ieee80211_hw *hw, u32 value)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\tmvm->rts_threshold = value;\n\n\treturn 0;\n}\n\nvoid iwl_mvm_sta_rc_update(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_sta *sta, u32 changed)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\tif (changed & (IEEE80211_RC_BW_CHANGED |\n\t\t       IEEE80211_RC_SUPP_RATES_CHANGED |\n\t\t       IEEE80211_RC_NSS_CHANGED))\n\t\tiwl_mvm_rs_rate_init_all_links(mvm, vif, sta);\n\n\tif (vif->type == NL80211_IFTYPE_STATION &&\n\t    changed & IEEE80211_RC_NSS_CHANGED)\n\t\tiwl_mvm_sf_update(mvm, vif, false);\n}\n\nstatic int iwl_mvm_mac_conf_tx(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       unsigned int link_id, u16 ac,\n\t\t\t       const struct ieee80211_tx_queue_params *params)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tmvmvif->deflink.queue_params[ac] = *params;\n\n\t \n\tif (vif->type == NL80211_IFTYPE_P2P_DEVICE) {\n\t\tint ret;\n\n\t\tmutex_lock(&mvm->mutex);\n\t\tret = iwl_mvm_mac_ctxt_changed(mvm, vif, false, NULL);\n\t\tmutex_unlock(&mvm->mutex);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nvoid iwl_mvm_mac_mgd_prepare_tx(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_prep_tx_info *info)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\tmutex_lock(&mvm->mutex);\n\tiwl_mvm_protect_assoc(mvm, vif, info->duration);\n\tmutex_unlock(&mvm->mutex);\n}\n\nvoid iwl_mvm_mac_mgd_complete_tx(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_prep_tx_info *info)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\t \n\tif (info->success)\n\t\treturn;\n\n\tmutex_lock(&mvm->mutex);\n\tiwl_mvm_stop_session_protection(mvm, vif);\n\tmutex_unlock(&mvm->mutex);\n}\n\nint iwl_mvm_mac_sched_scan_start(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct cfg80211_sched_scan_request *req,\n\t\t\t\t struct ieee80211_scan_ies *ies)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\tint ret;\n\n\tmutex_lock(&mvm->mutex);\n\n\tif (!vif->cfg.idle) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = iwl_mvm_sched_scan_start(mvm, vif, req, ies, IWL_MVM_SCAN_SCHED);\n\nout:\n\tmutex_unlock(&mvm->mutex);\n\treturn ret;\n}\n\nint iwl_mvm_mac_sched_scan_stop(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tint ret;\n\n\tmutex_lock(&mvm->mutex);\n\n\t \n\tif (!(mvm->scan_status & IWL_MVM_SCAN_SCHED)) {\n\t\tmutex_unlock(&mvm->mutex);\n\t\treturn 0;\n\t}\n\n\tret = iwl_mvm_scan_stop(mvm, IWL_MVM_SCAN_SCHED, false);\n\tmutex_unlock(&mvm->mutex);\n\tiwl_mvm_wait_for_async_handlers(mvm);\n\n\treturn ret;\n}\n\nstatic int __iwl_mvm_mac_set_key(struct ieee80211_hw *hw,\n\t\t\t\t enum set_key_cmd cmd,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t struct ieee80211_key_conf *key)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_sta *mvmsta = NULL;\n\tstruct iwl_mvm_key_pn *ptk_pn = NULL;\n\tint keyidx = key->keyidx;\n\tu32 sec_key_id = WIDE_ID(DATA_PATH_GROUP, SEC_KEY_CMD);\n\tu8 sec_key_ver = iwl_fw_lookup_cmd_ver(mvm->fw, sec_key_id, 0);\n\tint ret, i;\n\tu8 key_offset;\n\n\tif (sta)\n\t\tmvmsta = iwl_mvm_sta_from_mac80211(sta);\n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tif (!mvm->trans->trans_cfg->gen2) {\n\t\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;\n\t\t\tkey->flags |= IEEE80211_KEY_FLAG_PUT_IV_SPACE;\n\t\t} else if (vif->type == NL80211_IFTYPE_STATION) {\n\t\t\tkey->flags |= IEEE80211_KEY_FLAG_PUT_MIC_SPACE;\n\t\t} else {\n\t\t\tIWL_DEBUG_MAC80211(mvm, \"Use SW encryption for TKIP\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\tif (!iwl_mvm_has_new_tx_api(mvm))\n\t\t\tkey->flags |= IEEE80211_KEY_FLAG_PUT_IV_SPACE;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\tWARN_ON_ONCE(!ieee80211_hw_check(hw, MFP_CAPABLE));\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\t\tbreak;\n\t\tif (iwl_mvm_has_new_tx_api(mvm))\n\t\t\treturn -EOPNOTSUPP;\n\t\t \n\t\treturn 0;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (cmd) {\n\tcase SET_KEY:\n\t\tif (vif->type == NL80211_IFTYPE_STATION &&\n\t\t    (keyidx == 6 || keyidx == 7))\n\t\t\trcu_assign_pointer(mvmvif->bcn_prot.keys[keyidx - 6],\n\t\t\t\t\t   key);\n\n\t\tif ((vif->type == NL80211_IFTYPE_ADHOC ||\n\t\t     vif->type == NL80211_IFTYPE_AP) && !sta) {\n\t\t\t \n\t\t\tif (keyidx < 6 &&\n\t\t\t    (key->cipher == WLAN_CIPHER_SUITE_AES_CMAC ||\n\t\t\t     key->cipher == WLAN_CIPHER_SUITE_BIP_GMAC_128 ||\n\t\t\t     key->cipher == WLAN_CIPHER_SUITE_BIP_GMAC_256)) {\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (key->cipher != WLAN_CIPHER_SUITE_GCMP &&\n\t\t\t    key->cipher != WLAN_CIPHER_SUITE_GCMP_256 &&\n\t\t\t    !iwl_mvm_has_new_tx_api(mvm)) {\n\t\t\t\tkey->hw_key_idx = STA_KEY_IDX_INVALID;\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!mvmvif->ap_ibss_active) {\n\t\t\t\tfor (i = 0;\n\t\t\t\t     i < ARRAY_SIZE(mvmvif->ap_early_keys);\n\t\t\t\t     i++) {\n\t\t\t\t\tif (!mvmvif->ap_early_keys[i]) {\n\t\t\t\t\t\tmvmvif->ap_early_keys[i] = key;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (i >= ARRAY_SIZE(mvmvif->ap_early_keys))\n\t\t\t\t\tret = -ENOSPC;\n\t\t\t\telse\n\t\t\t\t\tret = 0;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status) &&\n\t\t    key->hw_key_idx == STA_KEY_IDX_INVALID) {\n\t\t\tIWL_DEBUG_MAC80211(mvm,\n\t\t\t\t\t   \"skip invalid idx key programming during restart\\n\");\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status) &&\n\t\t    mvmsta && iwl_mvm_has_new_rx_api(mvm) &&\n\t\t    key->flags & IEEE80211_KEY_FLAG_PAIRWISE &&\n\t\t    (key->cipher == WLAN_CIPHER_SUITE_CCMP ||\n\t\t     key->cipher == WLAN_CIPHER_SUITE_GCMP ||\n\t\t     key->cipher == WLAN_CIPHER_SUITE_GCMP_256)) {\n\t\t\tstruct ieee80211_key_seq seq;\n\t\t\tint tid, q;\n\n\t\t\tWARN_ON(rcu_access_pointer(mvmsta->ptk_pn[keyidx]));\n\t\t\tptk_pn = kzalloc(struct_size(ptk_pn, q,\n\t\t\t\t\t\t     mvm->trans->num_rx_queues),\n\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!ptk_pn) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (tid = 0; tid < IWL_MAX_TID_COUNT; tid++) {\n\t\t\t\tieee80211_get_key_rx_seq(key, tid, &seq);\n\t\t\t\tfor (q = 0; q < mvm->trans->num_rx_queues; q++)\n\t\t\t\t\tmemcpy(ptk_pn->q[q].pn[tid],\n\t\t\t\t\t       seq.ccmp.pn,\n\t\t\t\t\t       IEEE80211_CCMP_PN_LEN);\n\t\t\t}\n\n\t\t\trcu_assign_pointer(mvmsta->ptk_pn[keyidx], ptk_pn);\n\t\t}\n\n\t\t \n\t\tif (test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status))\n\t\t\tkey_offset = key->hw_key_idx;\n\t\telse\n\t\t\tkey_offset = STA_KEY_IDX_INVALID;\n\n\t\tif (mvmsta && key->flags & IEEE80211_KEY_FLAG_PAIRWISE)\n\t\t\tmvmsta->pairwise_cipher = key->cipher;\n\n\t\tIWL_DEBUG_MAC80211(mvm, \"set hwcrypto key (sta:%pM, id:%d)\\n\",\n\t\t\t\t   sta ? sta->addr : NULL, key->keyidx);\n\n\t\tif (sec_key_ver)\n\t\t\tret = iwl_mvm_sec_key_add(mvm, vif, sta, key);\n\t\telse\n\t\t\tret = iwl_mvm_set_sta_key(mvm, vif, sta, key, key_offset);\n\n\t\tif (ret) {\n\t\t\tIWL_WARN(mvm, \"set key failed\\n\");\n\t\t\tkey->hw_key_idx = STA_KEY_IDX_INVALID;\n\t\t\tif (ptk_pn) {\n\t\t\t\tRCU_INIT_POINTER(mvmsta->ptk_pn[keyidx], NULL);\n\t\t\t\tkfree(ptk_pn);\n\t\t\t}\n\t\t\t \n\t\t\tif (iwl_mvm_has_new_tx_api(mvm))\n\t\t\t\tret = -EOPNOTSUPP;\n\t\t\telse\n\t\t\t\tret = 0;\n\t\t}\n\n\t\tbreak;\n\tcase DISABLE_KEY:\n\t\tif (vif->type == NL80211_IFTYPE_STATION &&\n\t\t    (keyidx == 6 || keyidx == 7))\n\t\t\tRCU_INIT_POINTER(mvmvif->bcn_prot.keys[keyidx - 6],\n\t\t\t\t\t NULL);\n\n\t\tret = -ENOENT;\n\t\tfor (i = 0; i < ARRAY_SIZE(mvmvif->ap_early_keys); i++) {\n\t\t\tif (mvmvif->ap_early_keys[i] == key) {\n\t\t\t\tmvmvif->ap_early_keys[i] = NULL;\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (ret == 0)\n\t\t\tbreak;\n\n\t\tif (key->hw_key_idx == STA_KEY_IDX_INVALID) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (mvmsta && iwl_mvm_has_new_rx_api(mvm) &&\n\t\t    key->flags & IEEE80211_KEY_FLAG_PAIRWISE &&\n\t\t    (key->cipher == WLAN_CIPHER_SUITE_CCMP ||\n\t\t     key->cipher == WLAN_CIPHER_SUITE_GCMP ||\n\t\t     key->cipher == WLAN_CIPHER_SUITE_GCMP_256)) {\n\t\t\tptk_pn = rcu_dereference_protected(\n\t\t\t\t\t\tmvmsta->ptk_pn[keyidx],\n\t\t\t\t\t\tlockdep_is_held(&mvm->mutex));\n\t\t\tRCU_INIT_POINTER(mvmsta->ptk_pn[keyidx], NULL);\n\t\t\tif (ptk_pn)\n\t\t\t\tkfree_rcu(ptk_pn, rcu_head);\n\t\t}\n\n\t\tIWL_DEBUG_MAC80211(mvm, \"disable hwcrypto key\\n\");\n\t\tif (sec_key_ver)\n\t\t\tret = iwl_mvm_sec_key_del(mvm, vif, sta, key);\n\t\telse\n\t\t\tret = iwl_mvm_remove_sta_key(mvm, vif, sta, key);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nint iwl_mvm_mac_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t\tstruct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t\tstruct ieee80211_key_conf *key)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tint ret;\n\n\tmutex_lock(&mvm->mutex);\n\tret = __iwl_mvm_mac_set_key(hw, cmd, vif, sta, key);\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret;\n}\n\nvoid iwl_mvm_mac_update_tkip_key(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_key_conf *keyconf,\n\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t u32 iv32, u16 *phase1key)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\tif (keyconf->hw_key_idx == STA_KEY_IDX_INVALID)\n\t\treturn;\n\n\tiwl_mvm_update_tkip_key(mvm, vif, keyconf, sta, iv32, phase1key);\n}\n\n\nstatic bool iwl_mvm_rx_aux_roc(struct iwl_notif_wait_data *notif_wait,\n\t\t\t       struct iwl_rx_packet *pkt, void *data)\n{\n\tstruct iwl_mvm *mvm =\n\t\tcontainer_of(notif_wait, struct iwl_mvm, notif_wait);\n\tstruct iwl_hs20_roc_res *resp;\n\tint resp_len = iwl_rx_packet_payload_len(pkt);\n\tstruct iwl_mvm_time_event_data *te_data = data;\n\n\tif (WARN_ON(pkt->hdr.cmd != HOT_SPOT_CMD))\n\t\treturn true;\n\n\tif (WARN_ON_ONCE(resp_len != sizeof(*resp))) {\n\t\tIWL_ERR(mvm, \"Invalid HOT_SPOT_CMD response\\n\");\n\t\treturn true;\n\t}\n\n\tresp = (void *)pkt->data;\n\n\tIWL_DEBUG_TE(mvm,\n\t\t     \"Aux ROC: Received response from ucode: status=%d uid=%d\\n\",\n\t\t     resp->status, resp->event_unique_id);\n\n\tte_data->uid = le32_to_cpu(resp->event_unique_id);\n\tIWL_DEBUG_TE(mvm, \"TIME_EVENT_CMD response - UID = 0x%x\\n\",\n\t\t     te_data->uid);\n\n\tspin_lock_bh(&mvm->time_event_lock);\n\tlist_add_tail(&te_data->list, &mvm->aux_roc_te_list);\n\tspin_unlock_bh(&mvm->time_event_lock);\n\n\treturn true;\n}\n\n#define AUX_ROC_MIN_DURATION MSEC_TO_TU(100)\n#define AUX_ROC_MIN_DELAY MSEC_TO_TU(200)\n#define AUX_ROC_MAX_DELAY MSEC_TO_TU(600)\n#define AUX_ROC_SAFETY_BUFFER MSEC_TO_TU(20)\n#define AUX_ROC_MIN_SAFETY_BUFFER MSEC_TO_TU(10)\nstatic int iwl_mvm_send_aux_roc_cmd(struct iwl_mvm *mvm,\n\t\t\t\t    struct ieee80211_channel *channel,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    int duration)\n{\n\tint res;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_time_event_data *te_data = &mvmvif->hs_time_event_data;\n\tstatic const u16 time_event_response[] = { HOT_SPOT_CMD };\n\tstruct iwl_notification_wait wait_time_event;\n\tu32 dtim_interval = vif->bss_conf.dtim_period *\n\t\tvif->bss_conf.beacon_int;\n\tu32 req_dur, delay;\n\tstruct iwl_hs20_roc_req aux_roc_req = {\n\t\t.action = cpu_to_le32(FW_CTXT_ACTION_ADD),\n\t\t.id_and_color =\n\t\t\tcpu_to_le32(FW_CMD_ID_AND_COLOR(MAC_INDEX_AUX, 0)),\n\t\t.sta_id_and_color = cpu_to_le32(mvm->aux_sta.sta_id),\n\t};\n\tstruct iwl_hs20_roc_req_tail *tail = iwl_mvm_chan_info_cmd_tail(mvm,\n\t\t&aux_roc_req.channel_info);\n\tu16 len = sizeof(aux_roc_req) - iwl_mvm_chan_info_padding(mvm);\n\n\t \n\tiwl_mvm_set_chan_info(mvm, &aux_roc_req.channel_info, channel->hw_value,\n\t\t\t      iwl_mvm_phy_band_from_nl80211(channel->band),\n\t\t\t      IWL_PHY_CHANNEL_MODE20,\n\t\t\t      0);\n\n\t \n\ttail->apply_time = cpu_to_le32(iwl_mvm_get_systime(mvm));\n\n\tdelay = AUX_ROC_MIN_DELAY;\n\treq_dur = MSEC_TO_TU(duration);\n\n\t \n\tif (vif->cfg.assoc) {\n\t\tdelay = min_t(u32, dtim_interval * 3, AUX_ROC_MAX_DELAY);\n\t\t \n\t\tif (dtim_interval <= req_dur) {\n\t\t\treq_dur = dtim_interval - AUX_ROC_SAFETY_BUFFER;\n\t\t\tif (req_dur <= AUX_ROC_MIN_DURATION)\n\t\t\t\treq_dur = dtim_interval -\n\t\t\t\t\tAUX_ROC_MIN_SAFETY_BUFFER;\n\t\t}\n\t}\n\n\ttail->duration = cpu_to_le32(req_dur);\n\ttail->apply_time_max_delay = cpu_to_le32(delay);\n\n\tIWL_DEBUG_TE(mvm,\n\t\t     \"ROC: Requesting to remain on channel %u for %ums\\n\",\n\t\t     channel->hw_value, req_dur);\n\tIWL_DEBUG_TE(mvm,\n\t\t     \"\\t(requested = %ums, max_delay = %ums, dtim_interval = %ums)\\n\",\n\t\t     duration, delay, dtim_interval);\n\n\t \n\tmemcpy(tail->node_addr, vif->addr, ETH_ALEN);\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tspin_lock_bh(&mvm->time_event_lock);\n\n\tif (WARN_ON(te_data->id == HOT_SPOT_CMD)) {\n\t\tspin_unlock_bh(&mvm->time_event_lock);\n\t\treturn -EIO;\n\t}\n\n\tte_data->vif = vif;\n\tte_data->duration = duration;\n\tte_data->id = HOT_SPOT_CMD;\n\n\tspin_unlock_bh(&mvm->time_event_lock);\n\n\t \n\tiwl_init_notification_wait(&mvm->notif_wait, &wait_time_event,\n\t\t\t\t   time_event_response,\n\t\t\t\t   ARRAY_SIZE(time_event_response),\n\t\t\t\t   iwl_mvm_rx_aux_roc, te_data);\n\n\tres = iwl_mvm_send_cmd_pdu(mvm, HOT_SPOT_CMD, 0, len,\n\t\t\t\t   &aux_roc_req);\n\n\tif (res) {\n\t\tIWL_ERR(mvm, \"Couldn't send HOT_SPOT_CMD: %d\\n\", res);\n\t\tiwl_remove_notification(&mvm->notif_wait, &wait_time_event);\n\t\tgoto out_clear_te;\n\t}\n\n\t \n\tres = iwl_wait_notification(&mvm->notif_wait, &wait_time_event, 1);\n\t \n\tWARN_ON_ONCE(res);\n\n\tif (res) {\n out_clear_te:\n\t\tspin_lock_bh(&mvm->time_event_lock);\n\t\tiwl_mvm_te_clear_data(mvm, te_data);\n\t\tspin_unlock_bh(&mvm->time_event_lock);\n\t}\n\n\treturn res;\n}\n\nstatic int iwl_mvm_add_aux_sta_for_hs20(struct iwl_mvm *mvm, u32 lmac_id)\n{\n\tint ret = 0;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (!fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t IWL_UCODE_TLV_CAPA_HOTSPOT_SUPPORT)) {\n\t\tIWL_ERR(mvm, \"hotspot not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (iwl_mvm_has_new_station_api(mvm->fw)) {\n\t\tret = iwl_mvm_add_aux_sta(mvm, lmac_id);\n\t\tWARN(ret, \"Failed to allocate aux station\");\n\t}\n\n\treturn ret;\n}\n\nstatic int iwl_mvm_roc_link(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tret = iwl_mvm_binding_add_vif(mvm, vif);\n\tif (WARN(ret, \"Failed binding P2P_DEVICE\\n\"))\n\t\treturn ret;\n\n\t \n\treturn iwl_mvm_add_p2p_bcast_sta(mvm, vif);\n}\n\nstatic int iwl_mvm_roc(struct ieee80211_hw *hw,\n\t\t       struct ieee80211_vif *vif,\n\t\t       struct ieee80211_channel *channel,\n\t\t       int duration,\n\t\t       enum ieee80211_roc_type type)\n{\n\tstatic const struct iwl_mvm_roc_ops ops = {\n\t\t.add_aux_sta_for_hs20 = iwl_mvm_add_aux_sta_for_hs20,\n\t\t.link = iwl_mvm_roc_link,\n\t};\n\n\treturn iwl_mvm_roc_common(hw, vif, channel, duration, type, &ops);\n}\n\n \nint iwl_mvm_roc_common(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_channel *channel, int duration,\n\t\t       enum ieee80211_roc_type type,\n\t\t       const struct iwl_mvm_roc_ops *ops)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct cfg80211_chan_def chandef;\n\tstruct iwl_mvm_phy_ctxt *phy_ctxt;\n\tint ret, i;\n\tu32 lmac_id;\n\n\tIWL_DEBUG_MAC80211(mvm, \"enter (%d, %d, %d)\\n\", channel->hw_value,\n\t\t\t   duration, type);\n\n\t \n\tflush_work(&mvm->roc_done_wk);\n\n\tmutex_lock(&mvm->mutex);\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tlmac_id = iwl_mvm_get_lmac_id(mvm, channel->band);\n\n\t\t \n\t\tret = ops->add_aux_sta_for_hs20(mvm, lmac_id);\n\t\tif (!ret)\n\t\t\tret = iwl_mvm_send_aux_roc_cmd(mvm, channel,\n\t\t\t\t\t\t       vif, duration);\n\t\tgoto out_unlock;\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tIWL_ERR(mvm, \"ROC: Invalid vif type=%u\\n\", vif->type);\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t \n\tfor (i = 0; i < NUM_PHY_CTX; i++) {\n\t\tphy_ctxt = &mvm->phy_ctxts[i];\n\t\tif (!phy_ctxt->ref || mvmvif->deflink.phy_ctxt == phy_ctxt)\n\t\t\tcontinue;\n\n\t\tif (channel == phy_ctxt->channel) {\n\t\t\tif (mvmvif->deflink.phy_ctxt)\n\t\t\t\tiwl_mvm_phy_ctxt_unref(mvm,\n\t\t\t\t\t\t       mvmvif->deflink.phy_ctxt);\n\n\t\t\tmvmvif->deflink.phy_ctxt = phy_ctxt;\n\t\t\tiwl_mvm_phy_ctxt_ref(mvm, mvmvif->deflink.phy_ctxt);\n\t\t\tgoto link_and_start_p2p_roc;\n\t\t}\n\t}\n\n\t \n\tif (mvmvif->deflink.phy_ctxt) {\n\t\tif (channel == mvmvif->deflink.phy_ctxt->channel)\n\t\t\tgoto link_and_start_p2p_roc;\n\t} else {\n\t\tphy_ctxt = iwl_mvm_get_free_phy_ctxt(mvm);\n\t\tif (!phy_ctxt) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tmvmvif->deflink.phy_ctxt = phy_ctxt;\n\t\tiwl_mvm_phy_ctxt_ref(mvm, mvmvif->deflink.phy_ctxt);\n\t}\n\n\t \n\tcfg80211_chandef_create(&chandef, channel, NL80211_CHAN_NO_HT);\n\n\tret = iwl_mvm_phy_ctxt_changed(mvm, phy_ctxt, &chandef,\n\t\t\t\t       1, 1);\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"Failed to change PHY context\\n\");\n\t\tgoto out_unlock;\n\t}\n\nlink_and_start_p2p_roc:\n\tret = ops->link(mvm, vif);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = iwl_mvm_start_p2p_roc(mvm, vif, duration, type);\nout_unlock:\n\tmutex_unlock(&mvm->mutex);\n\tIWL_DEBUG_MAC80211(mvm, \"leave\\n\");\n\treturn ret;\n}\n\nint iwl_mvm_cancel_roc(struct ieee80211_hw *hw,\n\t\t       struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\tIWL_DEBUG_MAC80211(mvm, \"enter\\n\");\n\n\tmutex_lock(&mvm->mutex);\n\tiwl_mvm_stop_roc(mvm, vif);\n\tmutex_unlock(&mvm->mutex);\n\n\tIWL_DEBUG_MAC80211(mvm, \"leave\\n\");\n\treturn 0;\n}\n\nstruct iwl_mvm_ftm_responder_iter_data {\n\tbool responder;\n\tstruct ieee80211_chanctx_conf *ctx;\n};\n\nstatic void iwl_mvm_ftm_responder_chanctx_iter(void *_data, u8 *mac,\n\t\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_ftm_responder_iter_data *data = _data;\n\n\tif (rcu_access_pointer(vif->bss_conf.chanctx_conf) == data->ctx &&\n\t    vif->type == NL80211_IFTYPE_AP && vif->bss_conf.ftmr_params)\n\t\tdata->responder = true;\n}\n\nstatic bool iwl_mvm_is_ftm_responder_chanctx(struct iwl_mvm *mvm,\n\t\t\t\t\t     struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct iwl_mvm_ftm_responder_iter_data data = {\n\t\t.responder = false,\n\t\t.ctx = ctx,\n\t};\n\n\tieee80211_iterate_active_interfaces_atomic(mvm->hw,\n\t\t\t\t\tIEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\tiwl_mvm_ftm_responder_chanctx_iter,\n\t\t\t\t\t&data);\n\treturn data.responder;\n}\n\nstatic int __iwl_mvm_add_chanctx(struct iwl_mvm *mvm,\n\t\t\t\t struct ieee80211_chanctx_conf *ctx)\n{\n\tu16 *phy_ctxt_id = (u16 *)ctx->drv_priv;\n\tstruct iwl_mvm_phy_ctxt *phy_ctxt;\n\tbool responder = iwl_mvm_is_ftm_responder_chanctx(mvm, ctx);\n\tstruct cfg80211_chan_def *def = responder ? &ctx->def : &ctx->min_def;\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tIWL_DEBUG_MAC80211(mvm, \"Add channel context\\n\");\n\n\tphy_ctxt = iwl_mvm_get_free_phy_ctxt(mvm);\n\tif (!phy_ctxt) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tret = iwl_mvm_phy_ctxt_changed(mvm, phy_ctxt, def,\n\t\t\t\t       ctx->rx_chains_static,\n\t\t\t\t       ctx->rx_chains_dynamic);\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"Failed to add PHY context\\n\");\n\t\tgoto out;\n\t}\n\n\tiwl_mvm_phy_ctxt_ref(mvm, phy_ctxt);\n\t*phy_ctxt_id = phy_ctxt->id;\nout:\n\treturn ret;\n}\n\nint iwl_mvm_add_chanctx(struct ieee80211_hw *hw,\n\t\t\tstruct ieee80211_chanctx_conf *ctx)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tint ret;\n\n\tmutex_lock(&mvm->mutex);\n\tret = __iwl_mvm_add_chanctx(mvm, ctx);\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret;\n}\n\nstatic void __iwl_mvm_remove_chanctx(struct iwl_mvm *mvm,\n\t\t\t\t     struct ieee80211_chanctx_conf *ctx)\n{\n\tu16 *phy_ctxt_id = (u16 *)ctx->drv_priv;\n\tstruct iwl_mvm_phy_ctxt *phy_ctxt = &mvm->phy_ctxts[*phy_ctxt_id];\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tiwl_mvm_phy_ctxt_unref(mvm, phy_ctxt);\n}\n\nvoid iwl_mvm_remove_chanctx(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\tmutex_lock(&mvm->mutex);\n\t__iwl_mvm_remove_chanctx(mvm, ctx);\n\tmutex_unlock(&mvm->mutex);\n}\n\nvoid iwl_mvm_change_chanctx(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_chanctx_conf *ctx, u32 changed)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tu16 *phy_ctxt_id = (u16 *)ctx->drv_priv;\n\tstruct iwl_mvm_phy_ctxt *phy_ctxt = &mvm->phy_ctxts[*phy_ctxt_id];\n\tbool responder = iwl_mvm_is_ftm_responder_chanctx(mvm, ctx);\n\tstruct cfg80211_chan_def *def = responder ? &ctx->def : &ctx->min_def;\n\n\tif (WARN_ONCE((phy_ctxt->ref > 1) &&\n\t\t      (changed & ~(IEEE80211_CHANCTX_CHANGE_WIDTH |\n\t\t\t\t   IEEE80211_CHANCTX_CHANGE_RX_CHAINS |\n\t\t\t\t   IEEE80211_CHANCTX_CHANGE_RADAR |\n\t\t\t\t   IEEE80211_CHANCTX_CHANGE_MIN_WIDTH)),\n\t\t      \"Cannot change PHY. Ref=%d, changed=0x%X\\n\",\n\t\t      phy_ctxt->ref, changed))\n\t\treturn;\n\n\tmutex_lock(&mvm->mutex);\n\n\t \n\tif (changed == IEEE80211_CHANCTX_CHANGE_MIN_WIDTH) {\n\t\tif (phy_ctxt->width == def->width)\n\t\t\tgoto out_unlock;\n\n\t\t \n\t\tif (phy_ctxt->width <= NL80211_CHAN_WIDTH_20 &&\n\t\t    def->width <= NL80211_CHAN_WIDTH_20)\n\t\t\tgoto out_unlock;\n\t}\n\n\tiwl_mvm_bt_coex_vif_change(mvm);\n\tiwl_mvm_phy_ctxt_changed(mvm, phy_ctxt, def,\n\t\t\t\t ctx->rx_chains_static,\n\t\t\t\t ctx->rx_chains_dynamic);\n\nout_unlock:\n\tmutex_unlock(&mvm->mutex);\n}\n\n \nstatic bool\n__iwl_mvm_assign_vif_chanctx_common(struct iwl_mvm *mvm,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_chanctx_conf *ctx,\n\t\t\t\t    bool switching_chanctx, int *ret)\n{\n\tu16 *phy_ctxt_id = (u16 *)ctx->drv_priv;\n\tstruct iwl_mvm_phy_ctxt *phy_ctxt = &mvm->phy_ctxts[*phy_ctxt_id];\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tmvmvif->deflink.phy_ctxt = phy_ctxt;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_AP:\n\t\t \n\t\tif (switching_chanctx) {\n\t\t\tmvmvif->ap_ibss_active = true;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\t \n\t\t*ret = 0;\n\t\treturn true;\n\tcase NL80211_IFTYPE_STATION:\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\t \n\t\tmvmvif->ps_disabled = true;\n\t\tbreak;\n\tdefault:\n\t\t*ret = -EINVAL;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic int __iwl_mvm_assign_vif_chanctx(struct iwl_mvm *mvm,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tstruct ieee80211_bss_conf *link_conf,\n\t\t\t\t\tstruct ieee80211_chanctx_conf *ctx,\n\t\t\t\t\tbool switching_chanctx)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tint ret;\n\n\tif (WARN_ON(!link_conf))\n\t\treturn -EINVAL;\n\n\tif (__iwl_mvm_assign_vif_chanctx_common(mvm, vif, ctx,\n\t\t\t\t\t\tswitching_chanctx, &ret))\n\t\tgoto out;\n\n\tret = iwl_mvm_binding_add_vif(mvm, vif);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tiwl_mvm_power_update_mac(mvm);\n\n\t \n\tif (vif->type == NL80211_IFTYPE_MONITOR) {\n\t\tmvmvif->monitor_active = true;\n\t\tret = iwl_mvm_update_quotas(mvm, false, NULL);\n\t\tif (ret)\n\t\t\tgoto out_remove_binding;\n\n\t\tret = iwl_mvm_add_snif_sta(mvm, vif);\n\t\tif (ret)\n\t\t\tgoto out_remove_binding;\n\n\t}\n\n\t \n\tif (vif->type == NL80211_IFTYPE_AP) {\n\t\tiwl_mvm_update_quotas(mvm, false, NULL);\n\t\tiwl_mvm_mac_ctxt_changed(mvm, vif, false, NULL);\n\t}\n\n\tif (vif->type == NL80211_IFTYPE_STATION) {\n\t\tif (!switching_chanctx) {\n\t\t\tmvmvif->csa_bcn_pending = false;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmvmvif->csa_bcn_pending = true;\n\n\t\tif (!fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t\t IWL_UCODE_TLV_CAPA_CHANNEL_SWITCH_CMD)) {\n\t\t\tu32 duration = 3 * vif->bss_conf.beacon_int;\n\n\t\t\t \n\t\t\tiwl_mvm_protect_session(mvm, vif, duration, duration,\n\t\t\t\t\t\tvif->bss_conf.beacon_int / 2,\n\t\t\t\t\t\ttrue);\n\t\t}\n\n\t\tiwl_mvm_update_quotas(mvm, false, NULL);\n\t}\n\n\tgoto out;\n\nout_remove_binding:\n\tiwl_mvm_binding_remove_vif(mvm, vif);\n\tiwl_mvm_power_update_mac(mvm);\nout:\n\tif (ret)\n\t\tmvmvif->deflink.phy_ctxt = NULL;\n\treturn ret;\n}\n\nstatic int iwl_mvm_assign_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_bss_conf *link_conf,\n\t\t\t\t      struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tint ret;\n\n\tmutex_lock(&mvm->mutex);\n\tret = __iwl_mvm_assign_vif_chanctx(mvm, vif, link_conf, ctx, false);\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret;\n}\n\n \nstatic bool __iwl_mvm_unassign_vif_chanctx_common(struct iwl_mvm *mvm,\n\t\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t\t  bool switching_chanctx)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tlockdep_assert_held(&mvm->mutex);\n\tiwl_mvm_remove_time_event(mvm, mvmvif,\n\t\t\t\t  &mvmvif->time_event_data);\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_ADHOC:\n\t\treturn true;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tmvmvif->monitor_active = false;\n\t\tmvmvif->ps_disabled = false;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\t \n\t\tif (!switching_chanctx || !mvmvif->ap_ibss_active)\n\t\t\treturn true;\n\n\t\tmvmvif->csa_countdown = false;\n\n\t\t \n\t\tiwl_mvm_modify_all_sta_disable_tx(mvm, mvmvif, true);\n\n\t\t \n\t\trcu_assign_pointer(mvm->csa_tx_blocked_vif, vif);\n\n\t\tmvmvif->ap_ibss_active = false;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}\n\nstatic void __iwl_mvm_unassign_vif_chanctx(struct iwl_mvm *mvm,\n\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t   struct ieee80211_bss_conf *link_conf,\n\t\t\t\t\t   struct ieee80211_chanctx_conf *ctx,\n\t\t\t\t\t   bool switching_chanctx)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct ieee80211_vif *disabled_vif = NULL;\n\n\tif (__iwl_mvm_unassign_vif_chanctx_common(mvm, vif, switching_chanctx))\n\t\tgoto out;\n\n\tif (vif->type == NL80211_IFTYPE_MONITOR)\n\t\tiwl_mvm_rm_snif_sta(mvm, vif);\n\n\n\tif (vif->type == NL80211_IFTYPE_STATION && switching_chanctx) {\n\t\tdisabled_vif = vif;\n\t\tif (!fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t\t IWL_UCODE_TLV_CAPA_CHANNEL_SWITCH_CMD))\n\t\t\tiwl_mvm_mac_ctxt_changed(mvm, vif, true, NULL);\n\t}\n\n\tiwl_mvm_update_quotas(mvm, false, disabled_vif);\n\tiwl_mvm_binding_remove_vif(mvm, vif);\n\nout:\n\tif (fw_has_capa(&mvm->fw->ucode_capa, IWL_UCODE_TLV_CAPA_CHANNEL_SWITCH_CMD) &&\n\t    switching_chanctx)\n\t\treturn;\n\tmvmvif->deflink.phy_ctxt = NULL;\n\tiwl_mvm_power_update_mac(mvm);\n}\n\nstatic void iwl_mvm_unassign_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t struct ieee80211_bss_conf *link_conf,\n\t\t\t\t\t struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\tmutex_lock(&mvm->mutex);\n\t__iwl_mvm_unassign_vif_chanctx(mvm, vif, link_conf, ctx, false);\n\tmutex_unlock(&mvm->mutex);\n}\n\nstatic int\niwl_mvm_switch_vif_chanctx_swap(struct iwl_mvm *mvm,\n\t\t\t\tstruct ieee80211_vif_chanctx_switch *vifs,\n\t\t\t\tconst struct iwl_mvm_switch_vif_chanctx_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&mvm->mutex);\n\tops->__unassign_vif_chanctx(mvm, vifs[0].vif, vifs[0].link_conf,\n\t\t\t\t    vifs[0].old_ctx, true);\n\t__iwl_mvm_remove_chanctx(mvm, vifs[0].old_ctx);\n\n\tret = __iwl_mvm_add_chanctx(mvm, vifs[0].new_ctx);\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"failed to add new_ctx during channel switch\\n\");\n\t\tgoto out_reassign;\n\t}\n\n\tret = ops->__assign_vif_chanctx(mvm, vifs[0].vif, vifs[0].link_conf,\n\t\t\t\t\tvifs[0].new_ctx, true);\n\tif (ret) {\n\t\tIWL_ERR(mvm,\n\t\t\t\"failed to assign new_ctx during channel switch\\n\");\n\t\tgoto out_remove;\n\t}\n\n\t \n\tif (iwl_mvm_phy_ctx_count(mvm) > 1)\n\t\tiwl_mvm_teardown_tdls_peers(mvm);\n\n\tgoto out;\n\nout_remove:\n\t__iwl_mvm_remove_chanctx(mvm, vifs[0].new_ctx);\n\nout_reassign:\n\tif (__iwl_mvm_add_chanctx(mvm, vifs[0].old_ctx)) {\n\t\tIWL_ERR(mvm, \"failed to add old_ctx back after failure.\\n\");\n\t\tgoto out_restart;\n\t}\n\n\tif (ops->__assign_vif_chanctx(mvm, vifs[0].vif, vifs[0].link_conf,\n\t\t\t\t      vifs[0].old_ctx, true)) {\n\t\tIWL_ERR(mvm, \"failed to reassign old_ctx after failure.\\n\");\n\t\tgoto out_restart;\n\t}\n\n\tgoto out;\n\nout_restart:\n\t \n\tiwl_mvm_nic_restart(mvm, false);\n\nout:\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret;\n}\n\nstatic int\niwl_mvm_switch_vif_chanctx_reassign(struct iwl_mvm *mvm,\n\t\t\t\t    struct ieee80211_vif_chanctx_switch *vifs,\n\t\t\t\t    const struct iwl_mvm_switch_vif_chanctx_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&mvm->mutex);\n\tops->__unassign_vif_chanctx(mvm, vifs[0].vif, vifs[0].link_conf,\n\t\t\t\t    vifs[0].old_ctx, true);\n\n\tret = ops->__assign_vif_chanctx(mvm, vifs[0].vif, vifs[0].link_conf,\n\t\t\t\t\tvifs[0].new_ctx, true);\n\tif (ret) {\n\t\tIWL_ERR(mvm,\n\t\t\t\"failed to assign new_ctx during channel switch\\n\");\n\t\tgoto out_reassign;\n\t}\n\n\tgoto out;\n\nout_reassign:\n\tif (ops->__assign_vif_chanctx(mvm, vifs[0].vif, vifs[0].link_conf,\n\t\t\t\t      vifs[0].old_ctx, true)) {\n\t\tIWL_ERR(mvm, \"failed to reassign old_ctx after failure.\\n\");\n\t\tgoto out_restart;\n\t}\n\n\tgoto out;\n\nout_restart:\n\t \n\tiwl_mvm_nic_restart(mvm, false);\n\nout:\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret;\n}\n\n \nint\niwl_mvm_switch_vif_chanctx_common(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif_chanctx_switch *vifs,\n\t\t\t\t  int n_vifs,\n\t\t\t\t  enum ieee80211_chanctx_switch_mode mode,\n\t\t\t\t  const struct iwl_mvm_switch_vif_chanctx_ops *ops)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tint ret;\n\n\t \n\tif (n_vifs > 1)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (mode) {\n\tcase CHANCTX_SWMODE_SWAP_CONTEXTS:\n\t\tret = iwl_mvm_switch_vif_chanctx_swap(mvm, vifs, ops);\n\t\tbreak;\n\tcase CHANCTX_SWMODE_REASSIGN_VIF:\n\t\tret = iwl_mvm_switch_vif_chanctx_reassign(mvm, vifs, ops);\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int iwl_mvm_switch_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif_chanctx_switch *vifs,\n\t\t\t\t      int n_vifs,\n\t\t\t\t      enum ieee80211_chanctx_switch_mode mode)\n{\n\tstatic const struct iwl_mvm_switch_vif_chanctx_ops ops = {\n\t\t.__assign_vif_chanctx = __iwl_mvm_assign_vif_chanctx,\n\t\t.__unassign_vif_chanctx = __iwl_mvm_unassign_vif_chanctx,\n\t};\n\n\treturn iwl_mvm_switch_vif_chanctx_common(hw, vifs, n_vifs, mode, &ops);\n}\n\nint iwl_mvm_tx_last_beacon(struct ieee80211_hw *hw)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\treturn mvm->ibss_manager;\n}\n\nint iwl_mvm_set_tim(struct ieee80211_hw *hw, struct ieee80211_sta *sta,\n\t\t    bool set)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\n\tif (!mvm_sta || !mvm_sta->vif) {\n\t\tIWL_ERR(mvm, \"Station is not associated to a vif\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn iwl_mvm_mac_ctxt_beacon_changed(mvm, mvm_sta->vif,\n\t\t\t\t\t       &mvm_sta->vif->bss_conf);\n}\n\n#ifdef CONFIG_NL80211_TESTMODE\nstatic const struct nla_policy iwl_mvm_tm_policy[IWL_MVM_TM_ATTR_MAX + 1] = {\n\t[IWL_MVM_TM_ATTR_CMD] = { .type = NLA_U32 },\n\t[IWL_MVM_TM_ATTR_NOA_DURATION] = { .type = NLA_U32 },\n\t[IWL_MVM_TM_ATTR_BEACON_FILTER_STATE] = { .type = NLA_U32 },\n};\n\nstatic int __iwl_mvm_mac_testmode_cmd(struct iwl_mvm *mvm,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      void *data, int len)\n{\n\tstruct nlattr *tb[IWL_MVM_TM_ATTR_MAX + 1];\n\tint err;\n\tu32 noa_duration;\n\n\terr = nla_parse_deprecated(tb, IWL_MVM_TM_ATTR_MAX, data, len,\n\t\t\t\t   iwl_mvm_tm_policy, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (!tb[IWL_MVM_TM_ATTR_CMD])\n\t\treturn -EINVAL;\n\n\tswitch (nla_get_u32(tb[IWL_MVM_TM_ATTR_CMD])) {\n\tcase IWL_MVM_TM_CMD_SET_NOA:\n\t\tif (!vif || vif->type != NL80211_IFTYPE_AP || !vif->p2p ||\n\t\t    !vif->bss_conf.enable_beacon ||\n\t\t    !tb[IWL_MVM_TM_ATTR_NOA_DURATION])\n\t\t\treturn -EINVAL;\n\n\t\tnoa_duration = nla_get_u32(tb[IWL_MVM_TM_ATTR_NOA_DURATION]);\n\t\tif (noa_duration >= vif->bss_conf.beacon_int)\n\t\t\treturn -EINVAL;\n\n\t\tmvm->noa_duration = noa_duration;\n\t\tmvm->noa_vif = vif;\n\n\t\treturn iwl_mvm_update_quotas(mvm, true, NULL);\n\tcase IWL_MVM_TM_CMD_SET_BEACON_FILTER:\n\t\t \n\t\tif (!vif || vif->type != NL80211_IFTYPE_STATION ||\n\t\t    !vif->cfg.assoc || !vif->bss_conf.dtim_period ||\n\t\t    !tb[IWL_MVM_TM_ATTR_BEACON_FILTER_STATE])\n\t\t\treturn -EINVAL;\n\n\t\tif (nla_get_u32(tb[IWL_MVM_TM_ATTR_BEACON_FILTER_STATE]))\n\t\t\treturn iwl_mvm_enable_beacon_filter(mvm, vif, 0);\n\t\treturn iwl_mvm_disable_beacon_filter(mvm, vif, 0);\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nint iwl_mvm_mac_testmode_cmd(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     void *data, int len)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tint err;\n\n\tmutex_lock(&mvm->mutex);\n\terr = __iwl_mvm_mac_testmode_cmd(mvm, vif, data, len);\n\tmutex_unlock(&mvm->mutex);\n\n\treturn err;\n}\n#endif\n\nvoid iwl_mvm_channel_switch(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_channel_switch *chsw)\n{\n\t \n\n\tIWL_DEBUG_MAC80211(IWL_MAC80211_GET_MVM(hw),\n\t\t\t   \"dummy channel switch op\\n\");\n}\n\nstatic int iwl_mvm_schedule_client_csa(struct iwl_mvm *mvm,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_channel_switch *chsw)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_chan_switch_te_cmd cmd = {\n\t\t.mac_id = cpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id,\n\t\t\t\t\t\t\t  mvmvif->color)),\n\t\t.action = cpu_to_le32(FW_CTXT_ACTION_ADD),\n\t\t.tsf = cpu_to_le32(chsw->timestamp),\n\t\t.cs_count = chsw->count,\n\t\t.cs_mode = chsw->block_tx,\n\t};\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (chsw->delay)\n\t\tcmd.cs_delayed_bcn_count =\n\t\t\tDIV_ROUND_UP(chsw->delay, vif->bss_conf.beacon_int);\n\n\treturn iwl_mvm_send_cmd_pdu(mvm,\n\t\t\t\t    WIDE_ID(MAC_CONF_GROUP,\n\t\t\t\t\t    CHANNEL_SWITCH_TIME_EVENT_CMD),\n\t\t\t\t    0, sizeof(cmd), &cmd);\n}\n\nstatic int iwl_mvm_old_pre_chan_sw_sta(struct iwl_mvm *mvm,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_channel_switch *chsw)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tu32 apply_time;\n\n\t \n\tif (chsw->count <= 1)\n\t\tapply_time = 0;\n\telse\n\t\tapply_time = chsw->device_timestamp +\n\t\t\t((vif->bss_conf.beacon_int * (chsw->count - 1) -\n\t\t\t  IWL_MVM_CHANNEL_SWITCH_TIME_CLIENT) * 1024);\n\n\tif (chsw->block_tx)\n\t\tiwl_mvm_csa_client_absent(mvm, vif);\n\n\tif (mvmvif->bf_data.bf_enabled) {\n\t\tint ret = iwl_mvm_disable_beacon_filter(mvm, vif, 0);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tiwl_mvm_schedule_csa_period(mvm, vif, vif->bss_conf.beacon_int,\n\t\t\t\t    apply_time);\n\n\treturn 0;\n}\n\n#define IWL_MAX_CSA_BLOCK_TX 1500\nint iwl_mvm_pre_channel_switch(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_channel_switch *chsw)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct ieee80211_vif *csa_vif;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tint ret;\n\n\tmutex_lock(&mvm->mutex);\n\n\tmvmvif->csa_failed = false;\n\n\tIWL_DEBUG_MAC80211(mvm, \"pre CSA to freq %d\\n\",\n\t\t\t   chsw->chandef.center_freq1);\n\n\tiwl_fw_dbg_trigger_simple_stop(&mvm->fwrt,\n\t\t\t\t       ieee80211_vif_to_wdev(vif),\n\t\t\t\t       FW_DBG_TRIGGER_CHANNEL_SWITCH);\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_AP:\n\t\tcsa_vif =\n\t\t\trcu_dereference_protected(mvm->csa_vif,\n\t\t\t\t\t\t  lockdep_is_held(&mvm->mutex));\n\t\tif (WARN_ONCE(csa_vif && csa_vif->bss_conf.csa_active,\n\t\t\t      \"Another CSA is already in progress\")) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t \n\t\tif (rcu_dereference_protected(mvm->csa_tx_blocked_vif,\n\t\t\t\t\t      lockdep_is_held(&mvm->mutex))) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\trcu_assign_pointer(mvm->csa_vif, vif);\n\n\t\tif (WARN_ONCE(mvmvif->csa_countdown,\n\t\t\t      \"Previous CSA countdown didn't complete\")) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tmvmvif->csa_target_freq = chsw->chandef.chan->center_freq;\n\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\t \n\t\tif (iwl_fw_lookup_notif_ver(mvm->fw, MAC_CONF_GROUP,\n\t\t\t\t\t    CHANNEL_SWITCH_ERROR_NOTIF,\n\t\t\t\t\t    0))\n\t\t\tbreak;\n\n\t\t \n\t\tif (!vif->cfg.assoc || !vif->bss_conf.dtim_period) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tif (chsw->delay > IWL_MAX_CSA_BLOCK_TX)\n\t\t\tschedule_delayed_work(&mvmvif->csa_work, 0);\n\n\t\tif (chsw->block_tx) {\n\t\t\t \n\t\t\tif (!chsw->count ||\n\t\t\t    chsw->count * vif->bss_conf.beacon_int >\n\t\t\t    IWL_MAX_CSA_BLOCK_TX)\n\t\t\t\tschedule_delayed_work(&mvmvif->csa_work,\n\t\t\t\t\t\t      msecs_to_jiffies(IWL_MAX_CSA_BLOCK_TX));\n\t\t}\n\n\t\tif (!fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t\t IWL_UCODE_TLV_CAPA_CHANNEL_SWITCH_CMD)) {\n\t\t\tret = iwl_mvm_old_pre_chan_sw_sta(mvm, vif, chsw);\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock;\n\t\t} else {\n\t\t\tiwl_mvm_schedule_client_csa(mvm, vif, chsw);\n\t\t}\n\n\t\tmvmvif->csa_count = chsw->count;\n\t\tmvmvif->csa_misbehave = false;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmvmvif->ps_disabled = true;\n\n\tret = iwl_mvm_power_update_ps(mvm);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\t \n\tiwl_mvm_teardown_tdls_peers(mvm);\n\nout_unlock:\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret;\n}\n\nvoid iwl_mvm_channel_switch_rx_beacon(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_channel_switch *chsw)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_chan_switch_te_cmd cmd = {\n\t\t.mac_id = cpu_to_le32(FW_CMD_ID_AND_COLOR(mvmvif->id,\n\t\t\t\t\t\t\t  mvmvif->color)),\n\t\t.action = cpu_to_le32(FW_CTXT_ACTION_MODIFY),\n\t\t.tsf = cpu_to_le32(chsw->timestamp),\n\t\t.cs_count = chsw->count,\n\t\t.cs_mode = chsw->block_tx,\n\t};\n\n\t \n\tif (iwl_fw_lookup_notif_ver(mvm->fw, MAC_CONF_GROUP,\n\t\t\t\t    CHANNEL_SWITCH_ERROR_NOTIF, 0))\n\t\treturn;\n\n\tif (!fw_has_capa(&mvm->fw->ucode_capa, IWL_UCODE_TLV_CAPA_CS_MODIFY))\n\t\treturn;\n\n\tIWL_DEBUG_MAC80211(mvm, \"Modify CSA on mac %d count = %d (old %d) mode = %d\\n\",\n\t\t\t   mvmvif->id, chsw->count, mvmvif->csa_count, chsw->block_tx);\n\n\tif (chsw->count >= mvmvif->csa_count && chsw->block_tx) {\n\t\tif (mvmvif->csa_misbehave) {\n\t\t\t \n\t\t\tiwl_mvm_abort_channel_switch(hw, vif);\n\t\t\tieee80211_chswitch_done(vif, false);\n\t\t\tmvmvif->csa_misbehave = false;\n\t\t\treturn;\n\t\t}\n\t\tmvmvif->csa_misbehave = true;\n\t}\n\tmvmvif->csa_count = chsw->count;\n\n\tmutex_lock(&mvm->mutex);\n\tif (mvmvif->csa_failed)\n\t\tgoto out_unlock;\n\n\tWARN_ON(iwl_mvm_send_cmd_pdu(mvm,\n\t\t\t\t     WIDE_ID(MAC_CONF_GROUP,\n\t\t\t\t\t     CHANNEL_SWITCH_TIME_EVENT_CMD),\n\t\t\t\t     0, sizeof(cmd), &cmd));\nout_unlock:\n\tmutex_unlock(&mvm->mutex);\n}\n\nstatic void iwl_mvm_flush_no_vif(struct iwl_mvm *mvm, u32 queues, bool drop)\n{\n\tint i;\n\n\tif (!iwl_mvm_has_new_tx_api(mvm)) {\n\t\tif (drop) {\n\t\t\tmutex_lock(&mvm->mutex);\n\t\t\tiwl_mvm_flush_tx_path(mvm,\n\t\t\t\tiwl_mvm_flushable_queues(mvm) & queues);\n\t\t\tmutex_unlock(&mvm->mutex);\n\t\t} else {\n\t\t\tiwl_trans_wait_tx_queues_empty(mvm->trans, queues);\n\t\t}\n\t\treturn;\n\t}\n\n\tmutex_lock(&mvm->mutex);\n\tfor (i = 0; i < mvm->fw->ucode_capa.num_stations; i++) {\n\t\tstruct ieee80211_sta *sta;\n\n\t\tsta = rcu_dereference_protected(mvm->fw_id_to_mac_id[i],\n\t\t\t\t\t\tlockdep_is_held(&mvm->mutex));\n\t\tif (IS_ERR_OR_NULL(sta))\n\t\t\tcontinue;\n\n\t\tif (drop)\n\t\t\tiwl_mvm_flush_sta_tids(mvm, i, 0xFFFF);\n\t\telse\n\t\t\tiwl_mvm_wait_sta_queues_empty(mvm,\n\t\t\t\t\tiwl_mvm_sta_from_mac80211(sta));\n\t}\n\tmutex_unlock(&mvm->mutex);\n}\n\nvoid iwl_mvm_mac_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       u32 queues, bool drop)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_vif *mvmvif;\n\tstruct iwl_mvm_sta *mvmsta;\n\tstruct ieee80211_sta *sta;\n\tbool ap_sta_done = false;\n\tint i;\n\tu32 msk = 0;\n\n\tif (!vif) {\n\t\tiwl_mvm_flush_no_vif(mvm, queues, drop);\n\t\treturn;\n\t}\n\n\t \n\tflush_work(&mvm->add_stream_wk);\n\n\tmutex_lock(&mvm->mutex);\n\tmvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\t \n\tfor (i = 0; i < mvm->fw->ucode_capa.num_stations; i++) {\n\t\tsta = rcu_dereference_protected(mvm->fw_id_to_mac_id[i],\n\t\t\t\t\t\tlockdep_is_held(&mvm->mutex));\n\t\tif (IS_ERR_OR_NULL(sta))\n\t\t\tcontinue;\n\n\t\tmvmsta = iwl_mvm_sta_from_mac80211(sta);\n\t\tif (mvmsta->vif != vif)\n\t\t\tcontinue;\n\n\t\tif (sta == mvmvif->ap_sta) {\n\t\t\tif (ap_sta_done)\n\t\t\t\tcontinue;\n\t\t\tap_sta_done = true;\n\t\t}\n\n\t\tif (drop) {\n\t\t\tif (iwl_mvm_flush_sta(mvm, mvmsta->deflink.sta_id,\n\t\t\t\t\t      mvmsta->tfd_queue_msk))\n\t\t\t\tIWL_ERR(mvm, \"flush request fail\\n\");\n\t\t} else {\n\t\t\tif (iwl_mvm_has_new_tx_api(mvm))\n\t\t\t\tiwl_mvm_wait_sta_queues_empty(mvm, mvmsta);\n\t\t\telse  \n\t\t\t\tmsk |= mvmsta->tfd_queue_msk;\n\t\t}\n\t}\n\n\tmutex_unlock(&mvm->mutex);\n\n\t \n\tif (!drop && !iwl_mvm_has_new_tx_api(mvm))\n\t\tiwl_trans_wait_tx_queues_empty(mvm->trans, msk);\n}\n\nvoid iwl_mvm_mac_flush_sta(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_sta *sta)\n{\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_link_sta *mvm_link_sta;\n\tstruct ieee80211_link_sta *link_sta;\n\tint link_id;\n\n\tmutex_lock(&mvm->mutex);\n\tfor_each_sta_active_link(vif, sta, link_sta, link_id) {\n\t\tmvm_link_sta = rcu_dereference_protected(mvmsta->link[link_id],\n\t\t\t\t\t\t\t lockdep_is_held(&mvm->mutex));\n\t\tif (!mvm_link_sta)\n\t\t\tcontinue;\n\n\t\tif (iwl_mvm_flush_sta(mvm, mvm_link_sta->sta_id,\n\t\t\t\t      mvmsta->tfd_queue_msk))\n\t\t\tIWL_ERR(mvm, \"flush request fail\\n\");\n\t}\n\tmutex_unlock(&mvm->mutex);\n}\n\nint iwl_mvm_mac_get_survey(struct ieee80211_hw *hw, int idx,\n\t\t\t   struct survey_info *survey)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tint ret;\n\n\tmemset(survey, 0, sizeof(*survey));\n\n\t \n\tif (idx != 0)\n\t\treturn -ENOENT;\n\n\tif (!fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\t IWL_UCODE_TLV_CAPA_RADIO_BEACON_STATS))\n\t\treturn -ENOENT;\n\n\tmutex_lock(&mvm->mutex);\n\n\tif (iwl_mvm_firmware_running(mvm)) {\n\t\tret = iwl_mvm_request_statistics(mvm, false);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tsurvey->filled = SURVEY_INFO_TIME |\n\t\t\t SURVEY_INFO_TIME_RX |\n\t\t\t SURVEY_INFO_TIME_TX |\n\t\t\t SURVEY_INFO_TIME_SCAN;\n\tsurvey->time = mvm->accu_radio_stats.on_time_rf +\n\t\t       mvm->radio_stats.on_time_rf;\n\tdo_div(survey->time, USEC_PER_MSEC);\n\n\tsurvey->time_rx = mvm->accu_radio_stats.rx_time +\n\t\t\t  mvm->radio_stats.rx_time;\n\tdo_div(survey->time_rx, USEC_PER_MSEC);\n\n\tsurvey->time_tx = mvm->accu_radio_stats.tx_time +\n\t\t\t  mvm->radio_stats.tx_time;\n\tdo_div(survey->time_tx, USEC_PER_MSEC);\n\n\tsurvey->time_scan = mvm->accu_radio_stats.on_time_scan +\n\t\t\t    mvm->radio_stats.on_time_scan;\n\tdo_div(survey->time_scan, USEC_PER_MSEC);\n\n\tret = 0;\n out:\n\tmutex_unlock(&mvm->mutex);\n\treturn ret;\n}\n\nstatic void iwl_mvm_set_sta_rate(u32 rate_n_flags, struct rate_info *rinfo)\n{\n\tu32 format = rate_n_flags & RATE_MCS_MOD_TYPE_MSK;\n\tu32 gi_ltf;\n\n\tswitch (rate_n_flags & RATE_MCS_CHAN_WIDTH_MSK) {\n\tcase RATE_MCS_CHAN_WIDTH_20:\n\t\trinfo->bw = RATE_INFO_BW_20;\n\t\tbreak;\n\tcase RATE_MCS_CHAN_WIDTH_40:\n\t\trinfo->bw = RATE_INFO_BW_40;\n\t\tbreak;\n\tcase RATE_MCS_CHAN_WIDTH_80:\n\t\trinfo->bw = RATE_INFO_BW_80;\n\t\tbreak;\n\tcase RATE_MCS_CHAN_WIDTH_160:\n\t\trinfo->bw = RATE_INFO_BW_160;\n\t\tbreak;\n\tcase RATE_MCS_CHAN_WIDTH_320:\n\t\trinfo->bw = RATE_INFO_BW_320;\n\t\tbreak;\n\t}\n\n\tif (format == RATE_MCS_CCK_MSK ||\n\t    format == RATE_MCS_LEGACY_OFDM_MSK) {\n\t\tint rate = u32_get_bits(rate_n_flags, RATE_LEGACY_RATE_MSK);\n\n\t\t \n\t\tif (format == RATE_MCS_LEGACY_OFDM_MSK)\n\t\t\trate += IWL_FIRST_OFDM_RATE;\n\n\t\tswitch (rate) {\n\t\tcase IWL_RATE_1M_INDEX:\n\t\t\trinfo->legacy = 10;\n\t\t\tbreak;\n\t\tcase IWL_RATE_2M_INDEX:\n\t\t\trinfo->legacy = 20;\n\t\t\tbreak;\n\t\tcase IWL_RATE_5M_INDEX:\n\t\t\trinfo->legacy = 55;\n\t\t\tbreak;\n\t\tcase IWL_RATE_11M_INDEX:\n\t\t\trinfo->legacy = 110;\n\t\t\tbreak;\n\t\tcase IWL_RATE_6M_INDEX:\n\t\t\trinfo->legacy = 60;\n\t\t\tbreak;\n\t\tcase IWL_RATE_9M_INDEX:\n\t\t\trinfo->legacy = 90;\n\t\t\tbreak;\n\t\tcase IWL_RATE_12M_INDEX:\n\t\t\trinfo->legacy = 120;\n\t\t\tbreak;\n\t\tcase IWL_RATE_18M_INDEX:\n\t\t\trinfo->legacy = 180;\n\t\t\tbreak;\n\t\tcase IWL_RATE_24M_INDEX:\n\t\t\trinfo->legacy = 240;\n\t\t\tbreak;\n\t\tcase IWL_RATE_36M_INDEX:\n\t\t\trinfo->legacy = 360;\n\t\t\tbreak;\n\t\tcase IWL_RATE_48M_INDEX:\n\t\t\trinfo->legacy = 480;\n\t\t\tbreak;\n\t\tcase IWL_RATE_54M_INDEX:\n\t\t\trinfo->legacy = 540;\n\t\t}\n\t\treturn;\n\t}\n\n\trinfo->nss = u32_get_bits(rate_n_flags,\n\t\t\t\t  RATE_MCS_NSS_MSK) + 1;\n\trinfo->mcs = format == RATE_MCS_HT_MSK ?\n\t\tRATE_HT_MCS_INDEX(rate_n_flags) :\n\t\tu32_get_bits(rate_n_flags, RATE_MCS_CODE_MSK);\n\n\tif (rate_n_flags & RATE_MCS_SGI_MSK)\n\t\trinfo->flags |= RATE_INFO_FLAGS_SHORT_GI;\n\n\tswitch (format) {\n\tcase RATE_MCS_EHT_MSK:\n\t\t \n\t\trinfo->flags |= RATE_INFO_FLAGS_EHT_MCS;\n\t\tbreak;\n\tcase RATE_MCS_HE_MSK:\n\t\tgi_ltf = u32_get_bits(rate_n_flags, RATE_MCS_HE_GI_LTF_MSK);\n\n\t\trinfo->flags |= RATE_INFO_FLAGS_HE_MCS;\n\n\t\tif (rate_n_flags & RATE_MCS_HE_106T_MSK) {\n\t\t\trinfo->bw = RATE_INFO_BW_HE_RU;\n\t\t\trinfo->he_ru_alloc = NL80211_RATE_INFO_HE_RU_ALLOC_106;\n\t\t}\n\n\t\tswitch (rate_n_flags & RATE_MCS_HE_TYPE_MSK) {\n\t\tcase RATE_MCS_HE_TYPE_SU:\n\t\tcase RATE_MCS_HE_TYPE_EXT_SU:\n\t\t\tif (gi_ltf == 0 || gi_ltf == 1)\n\t\t\t\trinfo->he_gi = NL80211_RATE_INFO_HE_GI_0_8;\n\t\t\telse if (gi_ltf == 2)\n\t\t\t\trinfo->he_gi = NL80211_RATE_INFO_HE_GI_1_6;\n\t\t\telse if (gi_ltf == 3)\n\t\t\t\trinfo->he_gi = NL80211_RATE_INFO_HE_GI_3_2;\n\t\t\telse\n\t\t\t\trinfo->he_gi = NL80211_RATE_INFO_HE_GI_0_8;\n\t\t\tbreak;\n\t\tcase RATE_MCS_HE_TYPE_MU:\n\t\t\tif (gi_ltf == 0 || gi_ltf == 1)\n\t\t\t\trinfo->he_gi = NL80211_RATE_INFO_HE_GI_0_8;\n\t\t\telse if (gi_ltf == 2)\n\t\t\t\trinfo->he_gi = NL80211_RATE_INFO_HE_GI_1_6;\n\t\t\telse\n\t\t\t\trinfo->he_gi = NL80211_RATE_INFO_HE_GI_3_2;\n\t\t\tbreak;\n\t\tcase RATE_MCS_HE_TYPE_TRIG:\n\t\t\tif (gi_ltf == 0 || gi_ltf == 1)\n\t\t\t\trinfo->he_gi = NL80211_RATE_INFO_HE_GI_1_6;\n\t\t\telse\n\t\t\t\trinfo->he_gi = NL80211_RATE_INFO_HE_GI_3_2;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rate_n_flags & RATE_HE_DUAL_CARRIER_MODE_MSK)\n\t\t\trinfo->he_dcm = 1;\n\t\tbreak;\n\tcase RATE_MCS_HT_MSK:\n\t\trinfo->flags |= RATE_INFO_FLAGS_MCS;\n\t\tbreak;\n\tcase RATE_MCS_VHT_MSK:\n\t\trinfo->flags |= RATE_INFO_FLAGS_VHT_MCS;\n\t\tbreak;\n\t}\n}\n\nvoid iwl_mvm_mac_sta_statistics(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\tstruct station_info *sinfo)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\n\tif (mvmsta->deflink.avg_energy) {\n\t\tsinfo->signal_avg = -(s8)mvmsta->deflink.avg_energy;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL_AVG);\n\t}\n\n\tif (iwl_mvm_has_tlc_offload(mvm)) {\n\t\tstruct iwl_lq_sta_rs_fw *lq_sta = &mvmsta->deflink.lq_sta.rs_fw;\n\n\t\tiwl_mvm_set_sta_rate(lq_sta->last_rate_n_flags, &sinfo->txrate);\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);\n\t}\n\n\t \n\tif (!(vif->driver_flags & IEEE80211_VIF_BEACON_FILTER))\n\t\treturn;\n\n\tif (!vif->cfg.assoc)\n\t\treturn;\n\n\tmutex_lock(&mvm->mutex);\n\n\tif (mvmvif->deflink.ap_sta_id != mvmsta->deflink.sta_id)\n\t\tgoto unlock;\n\n\tif (iwl_mvm_request_statistics(mvm, false))\n\t\tgoto unlock;\n\n\tsinfo->rx_beacon = mvmvif->deflink.beacon_stats.num_beacons +\n\t\t\t   mvmvif->deflink.beacon_stats.accu_num_beacons;\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_BEACON_RX);\n\tif (mvmvif->deflink.beacon_stats.avg_signal) {\n\t\t \n\t\tsinfo->rx_beacon_signal_avg =\n\t\t\tmvmvif->deflink.beacon_stats.avg_signal;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_BEACON_SIGNAL_AVG);\n\t}\n unlock:\n\tmutex_unlock(&mvm->mutex);\n}\n\nstatic void iwl_mvm_event_mlme_callback_ini(struct iwl_mvm *mvm,\n\t\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t\t    const  struct ieee80211_mlme_event *mlme)\n{\n\tif ((mlme->data == ASSOC_EVENT || mlme->data == AUTH_EVENT) &&\n\t    (mlme->status == MLME_DENIED || mlme->status == MLME_TIMEOUT)) {\n\t\tiwl_dbg_tlv_time_point(&mvm->fwrt,\n\t\t\t\t       IWL_FW_INI_TIME_POINT_ASSOC_FAILED,\n\t\t\t\t       NULL);\n\t\treturn;\n\t}\n\n\tif (mlme->data == DEAUTH_RX_EVENT || mlme->data == DEAUTH_TX_EVENT) {\n\t\tiwl_dbg_tlv_time_point(&mvm->fwrt,\n\t\t\t\t       IWL_FW_INI_TIME_POINT_DEASSOC,\n\t\t\t\t       NULL);\n\t\treturn;\n\t}\n}\n\nstatic void iwl_mvm_event_mlme_callback(struct iwl_mvm *mvm,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tconst struct ieee80211_event *event)\n{\n#define CHECK_MLME_TRIGGER(_cnt, _fmt...)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif ((trig_mlme->_cnt) && --(trig_mlme->_cnt))\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tiwl_fw_dbg_collect_trig(&(mvm)->fwrt, trig, _fmt);\t\\\n\t} while (0)\n\n\tstruct iwl_fw_dbg_trigger_tlv *trig;\n\tstruct iwl_fw_dbg_trigger_mlme *trig_mlme;\n\n\tif (iwl_trans_dbg_ini_valid(mvm->trans)) {\n\t\tiwl_mvm_event_mlme_callback_ini(mvm, vif, &event->u.mlme);\n\t\treturn;\n\t}\n\n\ttrig = iwl_fw_dbg_trigger_on(&mvm->fwrt, ieee80211_vif_to_wdev(vif),\n\t\t\t\t     FW_DBG_TRIGGER_MLME);\n\tif (!trig)\n\t\treturn;\n\n\ttrig_mlme = (void *)trig->data;\n\n\tif (event->u.mlme.data == ASSOC_EVENT) {\n\t\tif (event->u.mlme.status == MLME_DENIED)\n\t\t\tCHECK_MLME_TRIGGER(stop_assoc_denied,\n\t\t\t\t\t   \"DENIED ASSOC: reason %d\",\n\t\t\t\t\t    event->u.mlme.reason);\n\t\telse if (event->u.mlme.status == MLME_TIMEOUT)\n\t\t\tCHECK_MLME_TRIGGER(stop_assoc_timeout,\n\t\t\t\t\t   \"ASSOC TIMEOUT\");\n\t} else if (event->u.mlme.data == AUTH_EVENT) {\n\t\tif (event->u.mlme.status == MLME_DENIED)\n\t\t\tCHECK_MLME_TRIGGER(stop_auth_denied,\n\t\t\t\t\t   \"DENIED AUTH: reason %d\",\n\t\t\t\t\t   event->u.mlme.reason);\n\t\telse if (event->u.mlme.status == MLME_TIMEOUT)\n\t\t\tCHECK_MLME_TRIGGER(stop_auth_timeout,\n\t\t\t\t\t   \"AUTH TIMEOUT\");\n\t} else if (event->u.mlme.data == DEAUTH_RX_EVENT) {\n\t\tCHECK_MLME_TRIGGER(stop_rx_deauth,\n\t\t\t\t   \"DEAUTH RX %d\", event->u.mlme.reason);\n\t} else if (event->u.mlme.data == DEAUTH_TX_EVENT) {\n\t\tCHECK_MLME_TRIGGER(stop_tx_deauth,\n\t\t\t\t   \"DEAUTH TX %d\", event->u.mlme.reason);\n\t}\n#undef CHECK_MLME_TRIGGER\n}\n\nstatic void iwl_mvm_event_bar_rx_callback(struct iwl_mvm *mvm,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  const struct ieee80211_event *event)\n{\n\tstruct iwl_fw_dbg_trigger_tlv *trig;\n\tstruct iwl_fw_dbg_trigger_ba *ba_trig;\n\n\ttrig = iwl_fw_dbg_trigger_on(&mvm->fwrt, ieee80211_vif_to_wdev(vif),\n\t\t\t\t     FW_DBG_TRIGGER_BA);\n\tif (!trig)\n\t\treturn;\n\n\tba_trig = (void *)trig->data;\n\n\tif (!(le16_to_cpu(ba_trig->rx_bar) & BIT(event->u.ba.tid)))\n\t\treturn;\n\n\tiwl_fw_dbg_collect_trig(&mvm->fwrt, trig,\n\t\t\t\t\"BAR received from %pM, tid %d, ssn %d\",\n\t\t\t\tevent->u.ba.sta->addr, event->u.ba.tid,\n\t\t\t\tevent->u.ba.ssn);\n}\n\nvoid iwl_mvm_mac_event_callback(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tconst struct ieee80211_event *event)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\tswitch (event->type) {\n\tcase MLME_EVENT:\n\t\tiwl_mvm_event_mlme_callback(mvm, vif, event);\n\t\tbreak;\n\tcase BAR_RX_EVENT:\n\t\tiwl_mvm_event_bar_rx_callback(mvm, vif, event);\n\t\tbreak;\n\tcase BA_FRAME_TIMEOUT:\n\t\tiwl_mvm_event_frame_timeout_callback(mvm, vif, event->u.ba.sta,\n\t\t\t\t\t\t     event->u.ba.tid);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid iwl_mvm_sync_rx_queues_internal(struct iwl_mvm *mvm,\n\t\t\t\t     enum iwl_mvm_rxq_notif_type type,\n\t\t\t\t     bool sync,\n\t\t\t\t     const void *data, u32 size)\n{\n\tstruct {\n\t\tstruct iwl_rxq_sync_cmd cmd;\n\t\tstruct iwl_mvm_internal_rxq_notif notif;\n\t} __packed cmd = {\n\t\t.cmd.rxq_mask = cpu_to_le32(BIT(mvm->trans->num_rx_queues) - 1),\n\t\t.cmd.count =\n\t\t\tcpu_to_le32(sizeof(struct iwl_mvm_internal_rxq_notif) +\n\t\t\t\t    size),\n\t\t.notif.type = type,\n\t\t.notif.sync = sync,\n\t};\n\tstruct iwl_host_cmd hcmd = {\n\t\t.id = WIDE_ID(DATA_PATH_GROUP, TRIGGER_RX_QUEUES_NOTIF_CMD),\n\t\t.data[0] = &cmd,\n\t\t.len[0] = sizeof(cmd),\n\t\t.data[1] = data,\n\t\t.len[1] = size,\n\t\t.flags = sync ? 0 : CMD_ASYNC,\n\t};\n\tint ret;\n\n\t \n\tif (WARN_ON(cmd.cmd.count & cpu_to_le32(3)))\n\t\treturn;\n\n\tif (!iwl_mvm_has_new_rx_api(mvm))\n\t\treturn;\n\n\tif (sync) {\n\t\tcmd.notif.cookie = mvm->queue_sync_cookie;\n\t\tmvm->queue_sync_state = (1 << mvm->trans->num_rx_queues) - 1;\n\t}\n\n\tret = iwl_mvm_send_cmd(mvm, &hcmd);\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"Failed to trigger RX queues sync (%d)\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tif (sync) {\n\t\tlockdep_assert_held(&mvm->mutex);\n\t\tret = wait_event_timeout(mvm->rx_sync_waitq,\n\t\t\t\t\t READ_ONCE(mvm->queue_sync_state) == 0 ||\n\t\t\t\t\t iwl_mvm_is_radio_killed(mvm),\n\t\t\t\t\t HZ);\n\t\tWARN_ONCE(!ret && !iwl_mvm_is_radio_killed(mvm),\n\t\t\t  \"queue sync: failed to sync, state is 0x%lx\\n\",\n\t\t\t  mvm->queue_sync_state);\n\t}\n\nout:\n\tif (sync) {\n\t\tmvm->queue_sync_state = 0;\n\t\tmvm->queue_sync_cookie++;\n\t}\n}\n\nvoid iwl_mvm_sync_rx_queues(struct ieee80211_hw *hw)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\tmutex_lock(&mvm->mutex);\n\tiwl_mvm_sync_rx_queues_internal(mvm, IWL_MVM_RXQ_EMPTY, true, NULL, 0);\n\tmutex_unlock(&mvm->mutex);\n}\n\nint\niwl_mvm_mac_get_ftm_responder_stats(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct cfg80211_ftm_responder_stats *stats)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tif (vif->p2p || vif->type != NL80211_IFTYPE_AP ||\n\t    !mvmvif->ap_ibss_active || !vif->bss_conf.ftm_responder)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mvm->mutex);\n\t*stats = mvm->ftm_resp_stats;\n\tmutex_unlock(&mvm->mutex);\n\n\tstats->filled = BIT(NL80211_FTM_STATS_SUCCESS_NUM) |\n\t\t\tBIT(NL80211_FTM_STATS_PARTIAL_NUM) |\n\t\t\tBIT(NL80211_FTM_STATS_FAILED_NUM) |\n\t\t\tBIT(NL80211_FTM_STATS_ASAP_NUM) |\n\t\t\tBIT(NL80211_FTM_STATS_NON_ASAP_NUM) |\n\t\t\tBIT(NL80211_FTM_STATS_TOTAL_DURATION_MSEC) |\n\t\t\tBIT(NL80211_FTM_STATS_UNKNOWN_TRIGGERS_NUM) |\n\t\t\tBIT(NL80211_FTM_STATS_RESCHEDULE_REQUESTS_NUM) |\n\t\t\tBIT(NL80211_FTM_STATS_OUT_OF_WINDOW_TRIGGERS_NUM);\n\n\treturn 0;\n}\n\nint iwl_mvm_start_pmsr(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       struct cfg80211_pmsr_request *request)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tint ret;\n\n\tmutex_lock(&mvm->mutex);\n\tret = iwl_mvm_ftm_start(mvm, vif, request);\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret;\n}\n\nvoid iwl_mvm_abort_pmsr(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\tstruct cfg80211_pmsr_request *request)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\tmutex_lock(&mvm->mutex);\n\tiwl_mvm_ftm_abort(mvm, request);\n\tmutex_unlock(&mvm->mutex);\n}\n\nstatic bool iwl_mvm_can_hw_csum(struct sk_buff *skb)\n{\n\tu8 protocol = ip_hdr(skb)->protocol;\n\n\tif (!IS_ENABLED(CONFIG_INET))\n\t\treturn false;\n\n\treturn protocol == IPPROTO_TCP || protocol == IPPROTO_UDP;\n}\n\nstatic bool iwl_mvm_mac_can_aggregate(struct ieee80211_hw *hw,\n\t\t\t\t      struct sk_buff *head,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\n\t \n\tif (skb->protocol != htons(ETH_P_IP))\n\t\treturn false;\n\n\tif (!iwl_mvm_is_csum_supported(mvm))\n\t\treturn true;\n\n\treturn iwl_mvm_can_hw_csum(skb) == iwl_mvm_can_hw_csum(head);\n}\n\nint iwl_mvm_set_hw_timestamp(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct cfg80211_set_hw_timestamp *hwts)\n{\n\tstruct iwl_mvm *mvm = IWL_MAC80211_GET_MVM(hw);\n\tu32 protocols = 0;\n\tint ret;\n\n\t \n\tif (!hwts->macaddr)\n\t\treturn -EOPNOTSUPP;\n\n\tif (hwts->enable)\n\t\tprotocols =\n\t\t\tIWL_TIME_SYNC_PROTOCOL_TM | IWL_TIME_SYNC_PROTOCOL_FTM;\n\n\tmutex_lock(&mvm->mutex);\n\tret = iwl_mvm_time_sync_config(mvm, hwts->macaddr, protocols);\n\tmutex_unlock(&mvm->mutex);\n\n\treturn ret;\n}\n\nconst struct ieee80211_ops iwl_mvm_hw_ops = {\n\t.tx = iwl_mvm_mac_tx,\n\t.wake_tx_queue = iwl_mvm_mac_wake_tx_queue,\n\t.ampdu_action = iwl_mvm_mac_ampdu_action,\n\t.get_antenna = iwl_mvm_op_get_antenna,\n\t.start = iwl_mvm_mac_start,\n\t.reconfig_complete = iwl_mvm_mac_reconfig_complete,\n\t.stop = iwl_mvm_mac_stop,\n\t.add_interface = iwl_mvm_mac_add_interface,\n\t.remove_interface = iwl_mvm_mac_remove_interface,\n\t.config = iwl_mvm_mac_config,\n\t.prepare_multicast = iwl_mvm_prepare_multicast,\n\t.configure_filter = iwl_mvm_configure_filter,\n\t.config_iface_filter = iwl_mvm_config_iface_filter,\n\t.bss_info_changed = iwl_mvm_bss_info_changed,\n\t.hw_scan = iwl_mvm_mac_hw_scan,\n\t.cancel_hw_scan = iwl_mvm_mac_cancel_hw_scan,\n\t.sta_pre_rcu_remove = iwl_mvm_sta_pre_rcu_remove,\n\t.sta_state = iwl_mvm_mac_sta_state,\n\t.sta_notify = iwl_mvm_mac_sta_notify,\n\t.allow_buffered_frames = iwl_mvm_mac_allow_buffered_frames,\n\t.release_buffered_frames = iwl_mvm_mac_release_buffered_frames,\n\t.set_rts_threshold = iwl_mvm_mac_set_rts_threshold,\n\t.sta_rc_update = iwl_mvm_sta_rc_update,\n\t.conf_tx = iwl_mvm_mac_conf_tx,\n\t.mgd_prepare_tx = iwl_mvm_mac_mgd_prepare_tx,\n\t.mgd_complete_tx = iwl_mvm_mac_mgd_complete_tx,\n\t.mgd_protect_tdls_discover = iwl_mvm_mac_mgd_protect_tdls_discover,\n\t.flush = iwl_mvm_mac_flush,\n\t.flush_sta = iwl_mvm_mac_flush_sta,\n\t.sched_scan_start = iwl_mvm_mac_sched_scan_start,\n\t.sched_scan_stop = iwl_mvm_mac_sched_scan_stop,\n\t.set_key = iwl_mvm_mac_set_key,\n\t.update_tkip_key = iwl_mvm_mac_update_tkip_key,\n\t.remain_on_channel = iwl_mvm_roc,\n\t.cancel_remain_on_channel = iwl_mvm_cancel_roc,\n\t.add_chanctx = iwl_mvm_add_chanctx,\n\t.remove_chanctx = iwl_mvm_remove_chanctx,\n\t.change_chanctx = iwl_mvm_change_chanctx,\n\t.assign_vif_chanctx = iwl_mvm_assign_vif_chanctx,\n\t.unassign_vif_chanctx = iwl_mvm_unassign_vif_chanctx,\n\t.switch_vif_chanctx = iwl_mvm_switch_vif_chanctx,\n\n\t.start_ap = iwl_mvm_start_ap,\n\t.stop_ap = iwl_mvm_stop_ap,\n\t.join_ibss = iwl_mvm_start_ibss,\n\t.leave_ibss = iwl_mvm_stop_ibss,\n\n\t.tx_last_beacon = iwl_mvm_tx_last_beacon,\n\n\t.set_tim = iwl_mvm_set_tim,\n\n\t.channel_switch = iwl_mvm_channel_switch,\n\t.pre_channel_switch = iwl_mvm_pre_channel_switch,\n\t.post_channel_switch = iwl_mvm_post_channel_switch,\n\t.abort_channel_switch = iwl_mvm_abort_channel_switch,\n\t.channel_switch_rx_beacon = iwl_mvm_channel_switch_rx_beacon,\n\n\t.tdls_channel_switch = iwl_mvm_tdls_channel_switch,\n\t.tdls_cancel_channel_switch = iwl_mvm_tdls_cancel_channel_switch,\n\t.tdls_recv_channel_switch = iwl_mvm_tdls_recv_channel_switch,\n\n\t.event_callback = iwl_mvm_mac_event_callback,\n\n\t.sync_rx_queues = iwl_mvm_sync_rx_queues,\n\n\tCFG80211_TESTMODE_CMD(iwl_mvm_mac_testmode_cmd)\n\n#ifdef CONFIG_PM_SLEEP\n\t \n\t.suspend = iwl_mvm_suspend,\n\t.resume = iwl_mvm_resume,\n\t.set_wakeup = iwl_mvm_set_wakeup,\n\t.set_rekey_data = iwl_mvm_set_rekey_data,\n#if IS_ENABLED(CONFIG_IPV6)\n\t.ipv6_addr_change = iwl_mvm_ipv6_addr_change,\n#endif\n\t.set_default_unicast_key = iwl_mvm_set_default_unicast_key,\n#endif\n\t.get_survey = iwl_mvm_mac_get_survey,\n\t.sta_statistics = iwl_mvm_mac_sta_statistics,\n\t.get_ftm_responder_stats = iwl_mvm_mac_get_ftm_responder_stats,\n\t.start_pmsr = iwl_mvm_start_pmsr,\n\t.abort_pmsr = iwl_mvm_abort_pmsr,\n\n\t.can_aggregate_in_amsdu = iwl_mvm_mac_can_aggregate,\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\t.link_sta_add_debugfs = iwl_mvm_link_sta_add_debugfs,\n#endif\n\t.set_hw_timestamp = iwl_mvm_set_hw_timestamp,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}