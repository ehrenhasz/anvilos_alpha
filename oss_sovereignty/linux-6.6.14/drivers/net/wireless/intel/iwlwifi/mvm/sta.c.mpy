{
  "module_name": "sta.c",
  "hash_id": "e62b5c9ece3f88e2b5b7396b50b23264c16d8ca41025ecc398367f215d20fa81",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/sta.c",
  "human_readable_source": "\n \n#include <net/mac80211.h>\n\n#include \"mvm.h\"\n#include \"sta.h\"\n#include \"rs.h\"\n\n \nstatic inline int iwl_mvm_add_sta_cmd_size(struct iwl_mvm *mvm)\n{\n\tif (iwl_mvm_has_new_rx_api(mvm) ||\n\t    fw_has_api(&mvm->fw->ucode_capa, IWL_UCODE_TLV_API_STA_TYPE))\n\t\treturn sizeof(struct iwl_mvm_add_sta_cmd);\n\telse\n\t\treturn sizeof(struct iwl_mvm_add_sta_cmd_v7);\n}\n\nint iwl_mvm_find_free_sta_id(struct iwl_mvm *mvm, enum nl80211_iftype iftype)\n{\n\tint sta_id;\n\tu32 reserved_ids = 0;\n\n\tBUILD_BUG_ON(IWL_MVM_STATION_COUNT_MAX > 32);\n\tWARN_ON_ONCE(test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status));\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\t \n\tif (iftype != NL80211_IFTYPE_STATION)\n\t\treserved_ids = BIT(0);\n\n\t \n\tfor (sta_id = 0; sta_id < mvm->fw->ucode_capa.num_stations; sta_id++) {\n\t\tif (BIT(sta_id) & reserved_ids)\n\t\t\tcontinue;\n\n\t\tif (!rcu_dereference_protected(mvm->fw_id_to_mac_id[sta_id],\n\t\t\t\t\t       lockdep_is_held(&mvm->mutex)))\n\t\t\treturn sta_id;\n\t}\n\treturn IWL_MVM_INVALID_STA;\n}\n\n \nu32 iwl_mvm_get_sta_ampdu_dens(struct ieee80211_link_sta *link_sta,\n\t\t\t       struct ieee80211_bss_conf *link_conf,\n\t\t\t       u32 *_agg_size)\n{\n\tu32 agg_size = 0, mpdu_dens = 0;\n\n\tif (WARN_ON(!link_sta))\n\t\treturn 0;\n\n\t \n\n\tif (link_sta->ht_cap.ht_supported) {\n\t\tagg_size = link_sta->ht_cap.ampdu_factor;\n\t\tmpdu_dens = link_sta->ht_cap.ampdu_density;\n\t}\n\n\tif (link_conf->chandef.chan->band == NL80211_BAND_6GHZ) {\n\t\t \n\t\tmpdu_dens = le16_get_bits(link_sta->he_6ghz_capa.capa,\n\t\t\t\t\t  IEEE80211_HE_6GHZ_CAP_MIN_MPDU_START);\n\t\tagg_size = le16_get_bits(link_sta->he_6ghz_capa.capa,\n\t\t\t\t\t IEEE80211_HE_6GHZ_CAP_MAX_AMPDU_LEN_EXP);\n\t} else if (link_sta->vht_cap.vht_supported) {\n\t\t \n\t\tagg_size = u32_get_bits(link_sta->vht_cap.cap,\n\t\t\t\t\tIEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK);\n\t}\n\n\t \n\tif (link_sta->he_cap.has_he)\n\t\tagg_size +=\n\t\t\tu8_get_bits(link_sta->he_cap.he_cap_elem.mac_cap_info[3],\n\t\t\t\t    IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_MASK);\n\n\tif (link_sta->eht_cap.has_eht)\n\t\tagg_size += u8_get_bits(link_sta->eht_cap.eht_cap_elem.mac_cap_info[1],\n\t\t\t\t\tIEEE80211_EHT_MAC_CAP1_MAX_AMPDU_LEN_MASK);\n\n\t \n\tagg_size = min_t(u32, agg_size,\n\t\t\t STA_FLG_MAX_AGG_SIZE_4M >> STA_FLG_MAX_AGG_SIZE_SHIFT);\n\n\t*_agg_size = agg_size;\n\treturn mpdu_dens;\n}\n\nu8 iwl_mvm_get_sta_uapsd_acs(struct ieee80211_sta *sta)\n{\n\tu8 uapsd_acs = 0;\n\n\tif (sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_BK)\n\t\tuapsd_acs |= BIT(AC_BK);\n\tif (sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_BE)\n\t\tuapsd_acs |= BIT(AC_BE);\n\tif (sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VI)\n\t\tuapsd_acs |= BIT(AC_VI);\n\tif (sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VO)\n\t\tuapsd_acs |= BIT(AC_VO);\n\n\treturn uapsd_acs | uapsd_acs << 4;\n}\n\n \nint iwl_mvm_sta_send_to_fw(struct iwl_mvm *mvm, struct ieee80211_sta *sta,\n\t\t\t   bool update, unsigned int flags)\n{\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_mvm_add_sta_cmd add_sta_cmd = {\n\t\t.sta_id = mvm_sta->deflink.sta_id,\n\t\t.mac_id_n_color = cpu_to_le32(mvm_sta->mac_id_n_color),\n\t\t.add_modify = update ? 1 : 0,\n\t\t.station_flags_msk = cpu_to_le32(STA_FLG_FAT_EN_MSK |\n\t\t\t\t\t\t STA_FLG_MIMO_EN_MSK |\n\t\t\t\t\t\t STA_FLG_RTS_MIMO_PROT),\n\t\t.tid_disable_tx = cpu_to_le16(mvm_sta->tid_disable_agg),\n\t};\n\tint ret;\n\tu32 status;\n\tu32 agg_size = 0, mpdu_dens = 0;\n\n\tif (fw_has_api(&mvm->fw->ucode_capa, IWL_UCODE_TLV_API_STA_TYPE))\n\t\tadd_sta_cmd.station_type = mvm_sta->sta_type;\n\n\tif (!update || (flags & STA_MODIFY_QUEUES)) {\n\t\tmemcpy(&add_sta_cmd.addr, sta->addr, ETH_ALEN);\n\n\t\tif (!iwl_mvm_has_new_tx_api(mvm)) {\n\t\t\tadd_sta_cmd.tfd_queue_msk =\n\t\t\t\tcpu_to_le32(mvm_sta->tfd_queue_msk);\n\n\t\t\tif (flags & STA_MODIFY_QUEUES)\n\t\t\t\tadd_sta_cmd.modify_mask |= STA_MODIFY_QUEUES;\n\t\t} else {\n\t\t\tWARN_ON(flags & STA_MODIFY_QUEUES);\n\t\t}\n\t}\n\n\tswitch (sta->deflink.bandwidth) {\n\tcase IEEE80211_STA_RX_BW_320:\n\tcase IEEE80211_STA_RX_BW_160:\n\t\tadd_sta_cmd.station_flags |= cpu_to_le32(STA_FLG_FAT_EN_160MHZ);\n\t\tfallthrough;\n\tcase IEEE80211_STA_RX_BW_80:\n\t\tadd_sta_cmd.station_flags |= cpu_to_le32(STA_FLG_FAT_EN_80MHZ);\n\t\tfallthrough;\n\tcase IEEE80211_STA_RX_BW_40:\n\t\tadd_sta_cmd.station_flags |= cpu_to_le32(STA_FLG_FAT_EN_40MHZ);\n\t\tfallthrough;\n\tcase IEEE80211_STA_RX_BW_20:\n\t\tif (sta->deflink.ht_cap.ht_supported)\n\t\t\tadd_sta_cmd.station_flags |=\n\t\t\t\tcpu_to_le32(STA_FLG_FAT_EN_20MHZ);\n\t\tbreak;\n\t}\n\n\tswitch (sta->deflink.rx_nss) {\n\tcase 1:\n\t\tadd_sta_cmd.station_flags |= cpu_to_le32(STA_FLG_MIMO_EN_SISO);\n\t\tbreak;\n\tcase 2:\n\t\tadd_sta_cmd.station_flags |= cpu_to_le32(STA_FLG_MIMO_EN_MIMO2);\n\t\tbreak;\n\tcase 3 ... 8:\n\t\tadd_sta_cmd.station_flags |= cpu_to_le32(STA_FLG_MIMO_EN_MIMO3);\n\t\tbreak;\n\t}\n\n\tswitch (sta->deflink.smps_mode) {\n\tcase IEEE80211_SMPS_AUTOMATIC:\n\tcase IEEE80211_SMPS_NUM_MODES:\n\t\tWARN_ON(1);\n\t\tbreak;\n\tcase IEEE80211_SMPS_STATIC:\n\t\t \n\t\tadd_sta_cmd.station_flags &= ~cpu_to_le32(STA_FLG_MIMO_EN_MSK);\n\t\tadd_sta_cmd.station_flags |= cpu_to_le32(STA_FLG_MIMO_EN_SISO);\n\t\tbreak;\n\tcase IEEE80211_SMPS_DYNAMIC:\n\t\tadd_sta_cmd.station_flags |= cpu_to_le32(STA_FLG_RTS_MIMO_PROT);\n\t\tbreak;\n\tcase IEEE80211_SMPS_OFF:\n\t\t \n\t\tbreak;\n\t}\n\n\tif (sta->deflink.ht_cap.ht_supported ||\n\t    mvm_sta->vif->bss_conf.chandef.chan->band == NL80211_BAND_6GHZ)\n\t\tadd_sta_cmd.station_flags_msk |=\n\t\t\tcpu_to_le32(STA_FLG_MAX_AGG_SIZE_MSK |\n\t\t\t\t    STA_FLG_AGG_MPDU_DENS_MSK);\n\n\tmpdu_dens = iwl_mvm_get_sta_ampdu_dens(&sta->deflink,\n\t\t\t\t\t       &mvm_sta->vif->bss_conf,\n\t\t\t\t\t       &agg_size);\n\tadd_sta_cmd.station_flags |=\n\t\tcpu_to_le32(agg_size << STA_FLG_MAX_AGG_SIZE_SHIFT);\n\tadd_sta_cmd.station_flags |=\n\t\tcpu_to_le32(mpdu_dens << STA_FLG_AGG_MPDU_DENS_SHIFT);\n\n\tif (mvm_sta->sta_state >= IEEE80211_STA_ASSOC)\n\t\tadd_sta_cmd.assoc_id = cpu_to_le16(sta->aid);\n\n\tif (sta->wme) {\n\t\tadd_sta_cmd.modify_mask |= STA_MODIFY_UAPSD_ACS;\n\t\tadd_sta_cmd.uapsd_acs = iwl_mvm_get_sta_uapsd_acs(sta);\n\t\tadd_sta_cmd.sp_length = sta->max_sp ? sta->max_sp * 2 : 128;\n\t}\n\n\tstatus = ADD_STA_SUCCESS;\n\tret = iwl_mvm_send_cmd_pdu_status(mvm, ADD_STA,\n\t\t\t\t\t  iwl_mvm_add_sta_cmd_size(mvm),\n\t\t\t\t\t  &add_sta_cmd, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (status & IWL_ADD_STA_STATUS_MASK) {\n\tcase ADD_STA_SUCCESS:\n\t\tIWL_DEBUG_ASSOC(mvm, \"ADD_STA PASSED\\n\");\n\t\tbreak;\n\tdefault:\n\t\tret = -EIO;\n\t\tIWL_ERR(mvm, \"ADD_STA failed\\n\");\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void iwl_mvm_rx_agg_session_expired(struct timer_list *t)\n{\n\tstruct iwl_mvm_baid_data *data =\n\t\tfrom_timer(data, t, session_timer);\n\tstruct iwl_mvm_baid_data __rcu **rcu_ptr = data->rcu_ptr;\n\tstruct iwl_mvm_baid_data *ba_data;\n\tstruct ieee80211_sta *sta;\n\tstruct iwl_mvm_sta *mvm_sta;\n\tunsigned long timeout;\n\tunsigned int sta_id;\n\n\trcu_read_lock();\n\n\tba_data = rcu_dereference(*rcu_ptr);\n\n\tif (WARN_ON(!ba_data))\n\t\tgoto unlock;\n\n\tif (!ba_data->timeout)\n\t\tgoto unlock;\n\n\ttimeout = ba_data->last_rx + TU_TO_JIFFIES(ba_data->timeout * 2);\n\tif (time_is_after_jiffies(timeout)) {\n\t\tmod_timer(&ba_data->session_timer, timeout);\n\t\tgoto unlock;\n\t}\n\n\t \n\tsta_id = ffs(ba_data->sta_mask) - 1;  \n\tsta = rcu_dereference(ba_data->mvm->fw_id_to_mac_id[sta_id]);\n\n\t \n\tif (IS_ERR_OR_NULL(sta))\n\t\tgoto unlock;\n\n\tmvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\tieee80211_rx_ba_timer_expired(mvm_sta->vif,\n\t\t\t\t      sta->addr, ba_data->tid);\nunlock:\n\trcu_read_unlock();\n}\n\n \nstatic int iwl_mvm_invalidate_sta_queue(struct iwl_mvm *mvm, int queue,\n\t\t\t\t\tunsigned long disable_agg_tids,\n\t\t\t\t\tbool remove_queue)\n{\n\tstruct iwl_mvm_add_sta_cmd cmd = {};\n\tstruct ieee80211_sta *sta;\n\tstruct iwl_mvm_sta *mvmsta;\n\tu32 status;\n\tu8 sta_id;\n\n\tif (WARN_ON(iwl_mvm_has_new_tx_api(mvm)))\n\t\treturn -EINVAL;\n\n\tsta_id = mvm->queue_info[queue].ra_sta_id;\n\n\trcu_read_lock();\n\n\tsta = rcu_dereference(mvm->fw_id_to_mac_id[sta_id]);\n\n\tif (WARN_ON_ONCE(IS_ERR_OR_NULL(sta))) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\n\tmvmsta = iwl_mvm_sta_from_mac80211(sta);\n\n\tmvmsta->tid_disable_agg |= disable_agg_tids;\n\n\tcmd.mac_id_n_color = cpu_to_le32(mvmsta->mac_id_n_color);\n\tcmd.sta_id = mvmsta->deflink.sta_id;\n\tcmd.add_modify = STA_MODE_MODIFY;\n\tcmd.modify_mask = STA_MODIFY_QUEUES;\n\tif (disable_agg_tids)\n\t\tcmd.modify_mask |= STA_MODIFY_TID_DISABLE_TX;\n\tif (remove_queue)\n\t\tcmd.modify_mask |= STA_MODIFY_QUEUE_REMOVAL;\n\tcmd.tfd_queue_msk = cpu_to_le32(mvmsta->tfd_queue_msk);\n\tcmd.tid_disable_tx = cpu_to_le16(mvmsta->tid_disable_agg);\n\n\trcu_read_unlock();\n\n\t \n\tstatus = ADD_STA_SUCCESS;\n\treturn iwl_mvm_send_cmd_pdu_status(mvm, ADD_STA,\n\t\t\t\t\t   iwl_mvm_add_sta_cmd_size(mvm),\n\t\t\t\t\t   &cmd, &status);\n}\n\nstatic int iwl_mvm_disable_txq(struct iwl_mvm *mvm, struct ieee80211_sta *sta,\n\t\t\t       int sta_id, u16 *queueptr, u8 tid)\n{\n\tint queue = *queueptr;\n\tstruct iwl_scd_txq_cfg_cmd cmd = {\n\t\t.scd_queue = queue,\n\t\t.action = SCD_CFG_DISABLE_QUEUE,\n\t};\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (iwl_mvm_has_new_tx_api(mvm)) {\n\t\tif (mvm->sta_remove_requires_queue_remove) {\n\t\t\tu32 cmd_id = WIDE_ID(DATA_PATH_GROUP,\n\t\t\t\t\t     SCD_QUEUE_CONFIG_CMD);\n\t\t\tstruct iwl_scd_queue_cfg_cmd remove_cmd = {\n\t\t\t\t.operation = cpu_to_le32(IWL_SCD_QUEUE_REMOVE),\n\t\t\t\t.u.remove.sta_mask = cpu_to_le32(BIT(sta_id)),\n\t\t\t};\n\n\t\t\tif (tid == IWL_MAX_TID_COUNT)\n\t\t\t\ttid = IWL_MGMT_TID;\n\n\t\t\tremove_cmd.u.remove.tid = cpu_to_le32(tid);\n\n\t\t\tret = iwl_mvm_send_cmd_pdu(mvm, cmd_id, 0,\n\t\t\t\t\t\t   sizeof(remove_cmd),\n\t\t\t\t\t\t   &remove_cmd);\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\n\t\tiwl_trans_txq_free(mvm->trans, queue);\n\t\t*queueptr = IWL_MVM_INVALID_QUEUE;\n\n\t\treturn ret;\n\t}\n\n\tif (WARN_ON(mvm->queue_info[queue].tid_bitmap == 0))\n\t\treturn 0;\n\n\tmvm->queue_info[queue].tid_bitmap &= ~BIT(tid);\n\n\tcmd.action = mvm->queue_info[queue].tid_bitmap ?\n\t\tSCD_CFG_ENABLE_QUEUE : SCD_CFG_DISABLE_QUEUE;\n\tif (cmd.action == SCD_CFG_DISABLE_QUEUE)\n\t\tmvm->queue_info[queue].status = IWL_MVM_QUEUE_FREE;\n\n\tIWL_DEBUG_TX_QUEUES(mvm,\n\t\t\t    \"Disabling TXQ #%d tids=0x%x\\n\",\n\t\t\t    queue,\n\t\t\t    mvm->queue_info[queue].tid_bitmap);\n\n\t \n\tif (cmd.action == SCD_CFG_ENABLE_QUEUE)\n\t\treturn 0;\n\n\tcmd.sta_id = mvm->queue_info[queue].ra_sta_id;\n\tcmd.tid = mvm->queue_info[queue].txq_tid;\n\n\t \n\tWARN(mvm->queue_info[queue].tid_bitmap,\n\t     \"TXQ #%d info out-of-sync - tids=0x%x\\n\",\n\t     queue, mvm->queue_info[queue].tid_bitmap);\n\n\t \n\tmvm->queue_info[queue].tid_bitmap = 0;\n\n\tif (sta) {\n\t\tstruct iwl_mvm_txq *mvmtxq =\n\t\t\tiwl_mvm_txq_from_tid(sta, tid);\n\n\t\tspin_lock_bh(&mvm->add_stream_lock);\n\t\tlist_del_init(&mvmtxq->list);\n\t\tclear_bit(IWL_MVM_TXQ_STATE_READY, &mvmtxq->state);\n\t\tmvmtxq->txq_id = IWL_MVM_INVALID_QUEUE;\n\t\tspin_unlock_bh(&mvm->add_stream_lock);\n\t}\n\n\t \n\tmvm->queue_info[queue].reserved = false;\n\n\tiwl_trans_txq_disable(mvm->trans, queue, false);\n\tret = iwl_mvm_send_cmd_pdu(mvm, SCD_QUEUE_CFG, 0,\n\t\t\t\t   sizeof(struct iwl_scd_txq_cfg_cmd), &cmd);\n\n\tif (ret)\n\t\tIWL_ERR(mvm, \"Failed to disable queue %d (ret=%d)\\n\",\n\t\t\tqueue, ret);\n\treturn ret;\n}\n\nstatic int iwl_mvm_get_queue_agg_tids(struct iwl_mvm *mvm, int queue)\n{\n\tstruct ieee80211_sta *sta;\n\tstruct iwl_mvm_sta *mvmsta;\n\tunsigned long tid_bitmap;\n\tunsigned long agg_tids = 0;\n\tu8 sta_id;\n\tint tid;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (WARN_ON(iwl_mvm_has_new_tx_api(mvm)))\n\t\treturn -EINVAL;\n\n\tsta_id = mvm->queue_info[queue].ra_sta_id;\n\ttid_bitmap = mvm->queue_info[queue].tid_bitmap;\n\n\tsta = rcu_dereference_protected(mvm->fw_id_to_mac_id[sta_id],\n\t\t\t\t\tlockdep_is_held(&mvm->mutex));\n\n\tif (WARN_ON_ONCE(IS_ERR_OR_NULL(sta)))\n\t\treturn -EINVAL;\n\n\tmvmsta = iwl_mvm_sta_from_mac80211(sta);\n\n\tspin_lock_bh(&mvmsta->lock);\n\tfor_each_set_bit(tid, &tid_bitmap, IWL_MAX_TID_COUNT + 1) {\n\t\tif (mvmsta->tid_data[tid].state == IWL_AGG_ON)\n\t\t\tagg_tids |= BIT(tid);\n\t}\n\tspin_unlock_bh(&mvmsta->lock);\n\n\treturn agg_tids;\n}\n\n \nstatic int iwl_mvm_remove_sta_queue_marking(struct iwl_mvm *mvm, int queue)\n{\n\tstruct ieee80211_sta *sta;\n\tstruct iwl_mvm_sta *mvmsta;\n\tunsigned long tid_bitmap;\n\tunsigned long disable_agg_tids = 0;\n\tu8 sta_id;\n\tint tid;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (WARN_ON(iwl_mvm_has_new_tx_api(mvm)))\n\t\treturn -EINVAL;\n\n\tsta_id = mvm->queue_info[queue].ra_sta_id;\n\ttid_bitmap = mvm->queue_info[queue].tid_bitmap;\n\n\trcu_read_lock();\n\n\tsta = rcu_dereference(mvm->fw_id_to_mac_id[sta_id]);\n\n\tif (WARN_ON_ONCE(IS_ERR_OR_NULL(sta))) {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\n\tmvmsta = iwl_mvm_sta_from_mac80211(sta);\n\n\tspin_lock_bh(&mvmsta->lock);\n\t \n\tfor_each_set_bit(tid, &tid_bitmap, IWL_MAX_TID_COUNT + 1) {\n\t\tstruct iwl_mvm_txq *mvmtxq =\n\t\t\tiwl_mvm_txq_from_tid(sta, tid);\n\n\t\tif (mvmsta->tid_data[tid].state == IWL_AGG_ON)\n\t\t\tdisable_agg_tids |= BIT(tid);\n\t\tmvmsta->tid_data[tid].txq_id = IWL_MVM_INVALID_QUEUE;\n\n\t\tspin_lock_bh(&mvm->add_stream_lock);\n\t\tlist_del_init(&mvmtxq->list);\n\t\tclear_bit(IWL_MVM_TXQ_STATE_READY, &mvmtxq->state);\n\t\tmvmtxq->txq_id = IWL_MVM_INVALID_QUEUE;\n\t\tspin_unlock_bh(&mvm->add_stream_lock);\n\t}\n\n\tmvmsta->tfd_queue_msk &= ~BIT(queue);  \n\tspin_unlock_bh(&mvmsta->lock);\n\n\trcu_read_unlock();\n\n\t \n\tsynchronize_net();\n\n\treturn disable_agg_tids;\n}\n\nstatic int iwl_mvm_free_inactive_queue(struct iwl_mvm *mvm, int queue,\n\t\t\t\t       struct ieee80211_sta *old_sta,\n\t\t\t\t       u8 new_sta_id)\n{\n\tstruct iwl_mvm_sta *mvmsta;\n\tu8 sta_id, tid;\n\tunsigned long disable_agg_tids = 0;\n\tbool same_sta;\n\tu16 queue_tmp = queue;\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (WARN_ON(iwl_mvm_has_new_tx_api(mvm)))\n\t\treturn -EINVAL;\n\n\tsta_id = mvm->queue_info[queue].ra_sta_id;\n\ttid = mvm->queue_info[queue].txq_tid;\n\n\tsame_sta = sta_id == new_sta_id;\n\n\tmvmsta = iwl_mvm_sta_from_staid_protected(mvm, sta_id);\n\tif (WARN_ON(!mvmsta))\n\t\treturn -EINVAL;\n\n\tdisable_agg_tids = iwl_mvm_remove_sta_queue_marking(mvm, queue);\n\t \n\tif (disable_agg_tids)\n\t\tiwl_mvm_invalidate_sta_queue(mvm, queue,\n\t\t\t\t\t     disable_agg_tids, false);\n\n\tret = iwl_mvm_disable_txq(mvm, old_sta, sta_id, &queue_tmp, tid);\n\tif (ret) {\n\t\tIWL_ERR(mvm,\n\t\t\t\"Failed to free inactive queue %d (ret=%d)\\n\",\n\t\t\tqueue, ret);\n\n\t\treturn ret;\n\t}\n\n\t \n\tif (!same_sta)\n\t\tiwl_mvm_invalidate_sta_queue(mvm, queue, 0, true);\n\n\treturn 0;\n}\n\nstatic int iwl_mvm_get_shared_queue(struct iwl_mvm *mvm,\n\t\t\t\t    unsigned long tfd_queue_mask, u8 ac)\n{\n\tint queue = 0;\n\tu8 ac_to_queue[IEEE80211_NUM_ACS];\n\tint i;\n\n\t \n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (WARN_ON(iwl_mvm_has_new_tx_api(mvm)))\n\t\treturn -EINVAL;\n\n\tmemset(&ac_to_queue, IEEE80211_INVAL_HW_QUEUE, sizeof(ac_to_queue));\n\n\t \n\tfor_each_set_bit(i, &tfd_queue_mask, IWL_MVM_DQA_MAX_DATA_QUEUE) {\n\t\t \n\t\tif (i < IWL_MVM_DQA_MIN_DATA_QUEUE &&\n\t\t    i != IWL_MVM_DQA_BSS_CLIENT_QUEUE)\n\t\t\tcontinue;\n\n\t\tac_to_queue[mvm->queue_info[i].mac80211_ac] = i;\n\t}\n\n\t \n\n\t \n\tif (ac_to_queue[IEEE80211_AC_BE] != IEEE80211_INVAL_HW_QUEUE)\n\t\tqueue = ac_to_queue[IEEE80211_AC_BE];\n\t \n\telse if (ac_to_queue[ac] != IEEE80211_INVAL_HW_QUEUE)\n\t\tqueue = ac_to_queue[ac];\n\t \n\telse if (ac == IEEE80211_AC_VO &&\n\t\t ac_to_queue[IEEE80211_AC_VI] != IEEE80211_INVAL_HW_QUEUE)\n\t\tqueue = ac_to_queue[IEEE80211_AC_VI];\n\t \n\telse if (ac_to_queue[IEEE80211_AC_BK] != IEEE80211_INVAL_HW_QUEUE)\n\t\tqueue = ac_to_queue[IEEE80211_AC_BK];\n\t \n\telse if (ac_to_queue[IEEE80211_AC_VI] != IEEE80211_INVAL_HW_QUEUE)\n\t\tqueue = ac_to_queue[IEEE80211_AC_VI];\n\t \n\telse if (ac_to_queue[IEEE80211_AC_VO] != IEEE80211_INVAL_HW_QUEUE)\n\t\tqueue = ac_to_queue[IEEE80211_AC_VO];\n\n\t \n\tif (!iwl_mvm_is_dqa_data_queue(mvm, queue) &&\n\t    !iwl_mvm_is_dqa_mgmt_queue(mvm, queue) &&\n\t    (queue != IWL_MVM_DQA_BSS_CLIENT_QUEUE)) {\n\t\tIWL_ERR(mvm, \"No DATA queues available to share\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\treturn queue;\n}\n\n \nstatic int iwl_mvm_reconfig_scd(struct iwl_mvm *mvm, int queue, int fifo,\n\t\t\t\tint sta_id, int tid, int frame_limit, u16 ssn)\n{\n\tstruct iwl_scd_txq_cfg_cmd cmd = {\n\t\t.scd_queue = queue,\n\t\t.action = SCD_CFG_ENABLE_QUEUE,\n\t\t.window = frame_limit,\n\t\t.sta_id = sta_id,\n\t\t.ssn = cpu_to_le16(ssn),\n\t\t.tx_fifo = fifo,\n\t\t.aggregate = (queue >= IWL_MVM_DQA_MIN_DATA_QUEUE ||\n\t\t\t      queue == IWL_MVM_DQA_BSS_CLIENT_QUEUE),\n\t\t.tid = tid,\n\t};\n\tint ret;\n\n\tif (WARN_ON(iwl_mvm_has_new_tx_api(mvm)))\n\t\treturn -EINVAL;\n\n\tif (WARN(mvm->queue_info[queue].tid_bitmap == 0,\n\t\t \"Trying to reconfig unallocated queue %d\\n\", queue))\n\t\treturn -ENXIO;\n\n\tIWL_DEBUG_TX_QUEUES(mvm, \"Reconfig SCD for TXQ #%d\\n\", queue);\n\n\tret = iwl_mvm_send_cmd_pdu(mvm, SCD_QUEUE_CFG, 0, sizeof(cmd), &cmd);\n\tWARN_ONCE(ret, \"Failed to re-configure queue %d on FIFO %d, ret=%d\\n\",\n\t\t  queue, fifo, ret);\n\n\treturn ret;\n}\n\n \nstatic int iwl_mvm_redirect_queue(struct iwl_mvm *mvm, int queue, int tid,\n\t\t\t\t  int ac, int ssn, unsigned int wdg_timeout,\n\t\t\t\t  bool force, struct iwl_mvm_txq *txq)\n{\n\tstruct iwl_scd_txq_cfg_cmd cmd = {\n\t\t.scd_queue = queue,\n\t\t.action = SCD_CFG_DISABLE_QUEUE,\n\t};\n\tbool shared_queue;\n\tint ret;\n\n\tif (WARN_ON(iwl_mvm_has_new_tx_api(mvm)))\n\t\treturn -EINVAL;\n\n\t \n\tif (ac <= mvm->queue_info[queue].mac80211_ac && !force) {\n\t\tIWL_DEBUG_TX_QUEUES(mvm,\n\t\t\t\t    \"No redirection needed on TXQ #%d\\n\",\n\t\t\t\t    queue);\n\t\treturn 0;\n\t}\n\n\tcmd.sta_id = mvm->queue_info[queue].ra_sta_id;\n\tcmd.tx_fifo = iwl_mvm_ac_to_tx_fifo[mvm->queue_info[queue].mac80211_ac];\n\tcmd.tid = mvm->queue_info[queue].txq_tid;\n\tshared_queue = hweight16(mvm->queue_info[queue].tid_bitmap) > 1;\n\n\tIWL_DEBUG_TX_QUEUES(mvm, \"Redirecting TXQ #%d to FIFO #%d\\n\",\n\t\t\t    queue, iwl_mvm_ac_to_tx_fifo[ac]);\n\n\t \n\tset_bit(IWL_MVM_TXQ_STATE_STOP_REDIRECT, &txq->state);\n\n\tret = iwl_trans_wait_tx_queues_empty(mvm->trans, BIT(queue));\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"Error draining queue %d before reconfig\\n\",\n\t\t\tqueue);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tiwl_trans_txq_disable(mvm->trans, queue, false);\n\tret = iwl_mvm_send_cmd_pdu(mvm, SCD_QUEUE_CFG, 0, sizeof(cmd), &cmd);\n\tif (ret)\n\t\tIWL_ERR(mvm, \"Failed SCD disable TXQ %d (ret=%d)\\n\", queue,\n\t\t\tret);\n\n\t \n\tiwl_trans_txq_enable_cfg(mvm->trans, queue, ssn, NULL, wdg_timeout);\n\n\t \n\tmvm->queue_info[queue].txq_tid = tid;\n\n\t \n\n\t \n\tiwl_mvm_reconfig_scd(mvm, queue, iwl_mvm_ac_to_tx_fifo[ac],\n\t\t\t     cmd.sta_id, tid, IWL_FRAME_LIMIT, ssn);\n\n\t \n\tmvm->queue_info[queue].mac80211_ac = ac;\n\n\t \n\tif (shared_queue)\n\t\tiwl_trans_txq_set_shared_mode(mvm->trans, queue, true);\n\nout:\n\t \n\tclear_bit(IWL_MVM_TXQ_STATE_STOP_REDIRECT, &txq->state);\n\n\treturn ret;\n}\n\nstatic int iwl_mvm_find_free_queue(struct iwl_mvm *mvm, u8 sta_id,\n\t\t\t\t   u8 minq, u8 maxq)\n{\n\tint i;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (WARN(maxq >= mvm->trans->trans_cfg->base_params->num_of_queues,\n\t\t \"max queue %d >= num_of_queues (%d)\", maxq,\n\t\t mvm->trans->trans_cfg->base_params->num_of_queues))\n\t\tmaxq = mvm->trans->trans_cfg->base_params->num_of_queues - 1;\n\n\t \n\tif (WARN_ON(iwl_mvm_has_new_tx_api(mvm)))\n\t\treturn -ENOSPC;\n\n\t \n\tfor (i = minq; i <= maxq; i++)\n\t\tif (mvm->queue_info[i].tid_bitmap == 0 &&\n\t\t    mvm->queue_info[i].status == IWL_MVM_QUEUE_FREE)\n\t\t\treturn i;\n\n\treturn -ENOSPC;\n}\n\nstatic int iwl_mvm_get_queue_size(struct ieee80211_sta *sta)\n{\n\tint max_size = IWL_DEFAULT_QUEUE_SIZE;\n\tunsigned int link_id;\n\n\t \n\tif (!sta)\n\t\treturn IWL_MGMT_QUEUE_SIZE;\n\n\trcu_read_lock();\n\n\tfor (link_id = 0; link_id < ARRAY_SIZE(sta->link); link_id++) {\n\t\tstruct ieee80211_link_sta *link =\n\t\t\trcu_dereference(sta->link[link_id]);\n\n\t\tif (!link)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (link->eht_cap.has_eht &&\n\t\t    max_size < IWL_DEFAULT_QUEUE_SIZE_EHT)\n\t\t\tmax_size = IWL_DEFAULT_QUEUE_SIZE_EHT;\n\n\t\t \n\t\tif (link->he_cap.has_he &&\n\t\t    max_size < IWL_DEFAULT_QUEUE_SIZE_HE)\n\t\t\tmax_size = IWL_DEFAULT_QUEUE_SIZE_HE;\n\t}\n\n\trcu_read_unlock();\n\treturn max_size;\n}\n\nint iwl_mvm_tvqm_enable_txq(struct iwl_mvm *mvm,\n\t\t\t    struct ieee80211_sta *sta,\n\t\t\t    u8 sta_id, u8 tid, unsigned int timeout)\n{\n\tint queue, size;\n\tu32 sta_mask = 0;\n\n\tif (tid == IWL_MAX_TID_COUNT) {\n\t\ttid = IWL_MGMT_TID;\n\t\tsize = max_t(u32, IWL_MGMT_QUEUE_SIZE,\n\t\t\t     mvm->trans->cfg->min_txq_size);\n\t} else {\n\t\tsize = iwl_mvm_get_queue_size(sta);\n\t}\n\n\t \n\tsize = min_t(u32, size, mvm->trans->txqs.bc_tbl_size / sizeof(u16));\n\n\t \n\tsize = rounddown_pow_of_two(size);\n\n\tif (sta) {\n\t\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\t\tunsigned int link_id;\n\n\t\tfor (link_id = 0;\n\t\t     link_id < ARRAY_SIZE(mvmsta->link);\n\t\t     link_id++) {\n\t\t\tstruct iwl_mvm_link_sta *link =\n\t\t\t\trcu_dereference_protected(mvmsta->link[link_id],\n\t\t\t\t\t\t\t  lockdep_is_held(&mvm->mutex));\n\n\t\t\tif (!link)\n\t\t\t\tcontinue;\n\n\t\t\tsta_mask |= BIT(link->sta_id);\n\t\t}\n\t} else {\n\t\tsta_mask |= BIT(sta_id);\n\t}\n\n\tif (!sta_mask)\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tqueue = iwl_trans_txq_alloc(mvm->trans, 0, sta_mask,\n\t\t\t\t\t    tid, size, timeout);\n\n\t\tif (queue < 0)\n\t\t\tIWL_DEBUG_TX_QUEUES(mvm,\n\t\t\t\t\t    \"Failed allocating TXQ of size %d for sta mask %x tid %d, ret: %d\\n\",\n\t\t\t\t\t    size, sta_mask, tid, queue);\n\t\tsize /= 2;\n\t} while (queue < 0 && size >= 16);\n\n\tif (queue < 0)\n\t\treturn queue;\n\n\tIWL_DEBUG_TX_QUEUES(mvm, \"Enabling TXQ #%d for sta mask 0x%x tid %d\\n\",\n\t\t\t    queue, sta_mask, tid);\n\n\treturn queue;\n}\n\nstatic int iwl_mvm_sta_alloc_queue_tvqm(struct iwl_mvm *mvm,\n\t\t\t\t\tstruct ieee80211_sta *sta, u8 ac,\n\t\t\t\t\tint tid)\n{\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_mvm_txq *mvmtxq =\n\t\tiwl_mvm_txq_from_tid(sta, tid);\n\tunsigned int wdg_timeout =\n\t\tiwl_mvm_get_wd_timeout(mvm, mvmsta->vif, false, false);\n\tint queue = -1;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tIWL_DEBUG_TX_QUEUES(mvm,\n\t\t\t    \"Allocating queue for sta %d on tid %d\\n\",\n\t\t\t    mvmsta->deflink.sta_id, tid);\n\tqueue = iwl_mvm_tvqm_enable_txq(mvm, sta, mvmsta->deflink.sta_id,\n\t\t\t\t\ttid, wdg_timeout);\n\tif (queue < 0)\n\t\treturn queue;\n\n\tmvmtxq->txq_id = queue;\n\tmvm->tvqm_info[queue].txq_tid = tid;\n\tmvm->tvqm_info[queue].sta_id = mvmsta->deflink.sta_id;\n\n\tIWL_DEBUG_TX_QUEUES(mvm, \"Allocated queue is %d\\n\", queue);\n\n\tspin_lock_bh(&mvmsta->lock);\n\tmvmsta->tid_data[tid].txq_id = queue;\n\tspin_unlock_bh(&mvmsta->lock);\n\n\treturn 0;\n}\n\nstatic bool iwl_mvm_update_txq_mapping(struct iwl_mvm *mvm,\n\t\t\t\t       struct ieee80211_sta *sta,\n\t\t\t\t       int queue, u8 sta_id, u8 tid)\n{\n\tbool enable_queue = true;\n\n\t \n\tif (mvm->queue_info[queue].tid_bitmap & BIT(tid)) {\n\t\tIWL_ERR(mvm, \"Trying to enable TXQ %d with existing TID %d\\n\",\n\t\t\tqueue, tid);\n\t\treturn false;\n\t}\n\n\t \n\tif (mvm->queue_info[queue].tid_bitmap)\n\t\tenable_queue = false;\n\n\tmvm->queue_info[queue].tid_bitmap |= BIT(tid);\n\tmvm->queue_info[queue].ra_sta_id = sta_id;\n\n\tif (enable_queue) {\n\t\tif (tid != IWL_MAX_TID_COUNT)\n\t\t\tmvm->queue_info[queue].mac80211_ac =\n\t\t\t\ttid_to_mac80211_ac[tid];\n\t\telse\n\t\t\tmvm->queue_info[queue].mac80211_ac = IEEE80211_AC_VO;\n\n\t\tmvm->queue_info[queue].txq_tid = tid;\n\t}\n\n\tif (sta) {\n\t\tstruct iwl_mvm_txq *mvmtxq =\n\t\t\tiwl_mvm_txq_from_tid(sta, tid);\n\n\t\tmvmtxq->txq_id = queue;\n\t}\n\n\tIWL_DEBUG_TX_QUEUES(mvm,\n\t\t\t    \"Enabling TXQ #%d tids=0x%x\\n\",\n\t\t\t    queue, mvm->queue_info[queue].tid_bitmap);\n\n\treturn enable_queue;\n}\n\nstatic bool iwl_mvm_enable_txq(struct iwl_mvm *mvm, struct ieee80211_sta *sta,\n\t\t\t       int queue, u16 ssn,\n\t\t\t       const struct iwl_trans_txq_scd_cfg *cfg,\n\t\t\t       unsigned int wdg_timeout)\n{\n\tstruct iwl_scd_txq_cfg_cmd cmd = {\n\t\t.scd_queue = queue,\n\t\t.action = SCD_CFG_ENABLE_QUEUE,\n\t\t.window = cfg->frame_limit,\n\t\t.sta_id = cfg->sta_id,\n\t\t.ssn = cpu_to_le16(ssn),\n\t\t.tx_fifo = cfg->fifo,\n\t\t.aggregate = cfg->aggregate,\n\t\t.tid = cfg->tid,\n\t};\n\tbool inc_ssn;\n\n\tif (WARN_ON(iwl_mvm_has_new_tx_api(mvm)))\n\t\treturn false;\n\n\t \n\tif (!iwl_mvm_update_txq_mapping(mvm, sta, queue, cfg->sta_id, cfg->tid))\n\t\treturn false;\n\n\tinc_ssn = iwl_trans_txq_enable_cfg(mvm->trans, queue, ssn,\n\t\t\t\t\t   NULL, wdg_timeout);\n\tif (inc_ssn)\n\t\tle16_add_cpu(&cmd.ssn, 1);\n\n\tWARN(iwl_mvm_send_cmd_pdu(mvm, SCD_QUEUE_CFG, 0, sizeof(cmd), &cmd),\n\t     \"Failed to configure queue %d on FIFO %d\\n\", queue, cfg->fifo);\n\n\treturn inc_ssn;\n}\n\nstatic void iwl_mvm_change_queue_tid(struct iwl_mvm *mvm, int queue)\n{\n\tstruct iwl_scd_txq_cfg_cmd cmd = {\n\t\t.scd_queue = queue,\n\t\t.action = SCD_CFG_UPDATE_QUEUE_TID,\n\t};\n\tint tid;\n\tunsigned long tid_bitmap;\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (WARN_ON(iwl_mvm_has_new_tx_api(mvm)))\n\t\treturn;\n\n\ttid_bitmap = mvm->queue_info[queue].tid_bitmap;\n\n\tif (WARN(!tid_bitmap, \"TXQ %d has no tids assigned to it\\n\", queue))\n\t\treturn;\n\n\t \n\ttid = find_first_bit(&tid_bitmap, IWL_MAX_TID_COUNT + 1);\n\tcmd.tid = tid;\n\tcmd.tx_fifo = iwl_mvm_ac_to_tx_fifo[tid_to_mac80211_ac[tid]];\n\n\tret = iwl_mvm_send_cmd_pdu(mvm, SCD_QUEUE_CFG, 0, sizeof(cmd), &cmd);\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"Failed to update owner of TXQ %d (ret=%d)\\n\",\n\t\t\tqueue, ret);\n\t\treturn;\n\t}\n\n\tmvm->queue_info[queue].txq_tid = tid;\n\tIWL_DEBUG_TX_QUEUES(mvm, \"Changed TXQ %d ownership to tid %d\\n\",\n\t\t\t    queue, tid);\n}\n\nstatic void iwl_mvm_unshare_queue(struct iwl_mvm *mvm, int queue)\n{\n\tstruct ieee80211_sta *sta;\n\tstruct iwl_mvm_sta *mvmsta;\n\tu8 sta_id;\n\tint tid = -1;\n\tunsigned long tid_bitmap;\n\tunsigned int wdg_timeout;\n\tint ssn;\n\tint ret = true;\n\n\t \n\tif (WARN_ON(iwl_mvm_has_new_tx_api(mvm)))\n\t\treturn;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tsta_id = mvm->queue_info[queue].ra_sta_id;\n\ttid_bitmap = mvm->queue_info[queue].tid_bitmap;\n\n\t \n\ttid = find_first_bit(&tid_bitmap, IWL_MAX_TID_COUNT + 1);\n\tif (tid_bitmap != BIT(tid)) {\n\t\tIWL_ERR(mvm, \"Failed to unshare q %d, active tids=0x%lx\\n\",\n\t\t\tqueue, tid_bitmap);\n\t\treturn;\n\t}\n\n\tIWL_DEBUG_TX_QUEUES(mvm, \"Unsharing TXQ %d, keeping tid %d\\n\", queue,\n\t\t\t    tid);\n\n\tsta = rcu_dereference_protected(mvm->fw_id_to_mac_id[sta_id],\n\t\t\t\t\tlockdep_is_held(&mvm->mutex));\n\n\tif (WARN_ON_ONCE(IS_ERR_OR_NULL(sta)))\n\t\treturn;\n\n\tmvmsta = iwl_mvm_sta_from_mac80211(sta);\n\twdg_timeout = iwl_mvm_get_wd_timeout(mvm, mvmsta->vif, false, false);\n\n\tssn = IEEE80211_SEQ_TO_SN(mvmsta->tid_data[tid].seq_number);\n\n\tret = iwl_mvm_redirect_queue(mvm, queue, tid,\n\t\t\t\t     tid_to_mac80211_ac[tid], ssn,\n\t\t\t\t     wdg_timeout, true,\n\t\t\t\t     iwl_mvm_txq_from_tid(sta, tid));\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"Failed to redirect TXQ %d\\n\", queue);\n\t\treturn;\n\t}\n\n\t \n\tif (mvmsta->tid_data[tid].state == IWL_AGG_ON) {\n\t\tstruct iwl_mvm_add_sta_cmd cmd = {0};\n\n\t\tmvmsta->tid_disable_agg &= ~BIT(tid);\n\n\t\tcmd.mac_id_n_color = cpu_to_le32(mvmsta->mac_id_n_color);\n\t\tcmd.sta_id = mvmsta->deflink.sta_id;\n\t\tcmd.add_modify = STA_MODE_MODIFY;\n\t\tcmd.modify_mask = STA_MODIFY_TID_DISABLE_TX;\n\t\tcmd.tfd_queue_msk = cpu_to_le32(mvmsta->tfd_queue_msk);\n\t\tcmd.tid_disable_tx = cpu_to_le16(mvmsta->tid_disable_agg);\n\n\t\tret = iwl_mvm_send_cmd_pdu(mvm, ADD_STA, CMD_ASYNC,\n\t\t\t\t\t   iwl_mvm_add_sta_cmd_size(mvm), &cmd);\n\t\tif (!ret) {\n\t\t\tIWL_DEBUG_TX_QUEUES(mvm,\n\t\t\t\t\t    \"TXQ #%d is now aggregated again\\n\",\n\t\t\t\t\t    queue);\n\n\t\t\t \n\t\t\tiwl_trans_txq_set_shared_mode(mvm->trans, queue, false);\n\t\t}\n\t}\n\n\tmvm->queue_info[queue].status = IWL_MVM_QUEUE_READY;\n}\n\n \nstatic bool iwl_mvm_remove_inactive_tids(struct iwl_mvm *mvm,\n\t\t\t\t\t struct iwl_mvm_sta *mvmsta, int queue,\n\t\t\t\t\t unsigned long tid_bitmap,\n\t\t\t\t\t unsigned long *unshare_queues,\n\t\t\t\t\t unsigned long *changetid_queues)\n{\n\tunsigned int tid;\n\n\tlockdep_assert_held(&mvmsta->lock);\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (WARN_ON(iwl_mvm_has_new_tx_api(mvm)))\n\t\treturn false;\n\n\t \n\tfor_each_set_bit(tid, &tid_bitmap, IWL_MAX_TID_COUNT + 1) {\n\t\t \n\t\tif (iwl_mvm_tid_queued(mvm, &mvmsta->tid_data[tid]))\n\t\t\ttid_bitmap &= ~BIT(tid);\n\n\t\t \n\t\tif (mvmsta->tid_data[tid].state != IWL_AGG_OFF)\n\t\t\ttid_bitmap &= ~BIT(tid);\n\t}\n\n\t \n\tif (tid_bitmap == mvm->queue_info[queue].tid_bitmap) {\n\t\tIWL_DEBUG_TX_QUEUES(mvm, \"Queue %d is inactive\\n\", queue);\n\t\treturn true;\n\t}\n\n\t \n\tfor_each_set_bit(tid, &tid_bitmap, IWL_MAX_TID_COUNT + 1) {\n\t\tu16 q_tid_bitmap;\n\n\t\tmvmsta->tid_data[tid].txq_id = IWL_MVM_INVALID_QUEUE;\n\t\tmvm->queue_info[queue].tid_bitmap &= ~BIT(tid);\n\n\t\tq_tid_bitmap = mvm->queue_info[queue].tid_bitmap;\n\n\t\t \n\t\tif (!(q_tid_bitmap & BIT(mvm->queue_info[queue].txq_tid)))\n\t\t\tset_bit(queue, changetid_queues);\n\n\t\tIWL_DEBUG_TX_QUEUES(mvm,\n\t\t\t\t    \"Removing inactive TID %d from shared Q:%d\\n\",\n\t\t\t\t    tid, queue);\n\t}\n\n\tIWL_DEBUG_TX_QUEUES(mvm,\n\t\t\t    \"TXQ #%d left with tid bitmap 0x%x\\n\", queue,\n\t\t\t    mvm->queue_info[queue].tid_bitmap);\n\n\t \n\ttid_bitmap = mvm->queue_info[queue].tid_bitmap;\n\n\t \n\tif (hweight16(mvm->queue_info[queue].tid_bitmap) == 1 &&\n\t    mvm->queue_info[queue].status == IWL_MVM_QUEUE_SHARED) {\n\t\tIWL_DEBUG_TX_QUEUES(mvm, \"Marking Q:%d for reconfig\\n\",\n\t\t\t\t    queue);\n\t\tset_bit(queue, unshare_queues);\n\t}\n\n\treturn false;\n}\n\n \nstatic int iwl_mvm_inactivity_check(struct iwl_mvm *mvm, u8 alloc_for_sta)\n{\n\tunsigned long now = jiffies;\n\tunsigned long unshare_queues = 0;\n\tunsigned long changetid_queues = 0;\n\tint i, ret, free_queue = -ENOSPC;\n\tstruct ieee80211_sta *queue_owner  = NULL;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (iwl_mvm_has_new_tx_api(mvm))\n\t\treturn -ENOSPC;\n\n\trcu_read_lock();\n\n\t \n\tBUILD_BUG_ON(IWL_MVM_DQA_CMD_QUEUE != 0);\n\n\tfor (i = 1; i < IWL_MAX_HW_QUEUES; i++) {\n\t\tstruct ieee80211_sta *sta;\n\t\tstruct iwl_mvm_sta *mvmsta;\n\t\tu8 sta_id;\n\t\tint tid;\n\t\tunsigned long inactive_tid_bitmap = 0;\n\t\tunsigned long queue_tid_bitmap;\n\n\t\tqueue_tid_bitmap = mvm->queue_info[i].tid_bitmap;\n\t\tif (!queue_tid_bitmap)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (mvm->queue_info[i].status != IWL_MVM_QUEUE_READY &&\n\t\t    mvm->queue_info[i].status != IWL_MVM_QUEUE_SHARED)\n\t\t\tcontinue;\n\n\t\t \n\t\tfor_each_set_bit(tid, &queue_tid_bitmap,\n\t\t\t\t IWL_MAX_TID_COUNT + 1) {\n\t\t\tif (time_after(mvm->queue_info[i].last_frame_time[tid] +\n\t\t\t\t       IWL_MVM_DQA_QUEUE_TIMEOUT, now))\n\t\t\t\tcontinue;\n\n\t\t\tinactive_tid_bitmap |= BIT(tid);\n\t\t}\n\n\t\t \n\t\tif (!inactive_tid_bitmap)\n\t\t\tcontinue;\n\n\t\t \n\n\t\tsta_id = mvm->queue_info[i].ra_sta_id;\n\t\tsta = rcu_dereference(mvm->fw_id_to_mac_id[sta_id]);\n\n\t\t \n\t\tif (IS_ERR_OR_NULL(sta))\n\t\t\tcontinue;\n\n\t\tmvmsta = iwl_mvm_sta_from_mac80211(sta);\n\n\t\tspin_lock_bh(&mvmsta->lock);\n\t\tret = iwl_mvm_remove_inactive_tids(mvm, mvmsta, i,\n\t\t\t\t\t\t   inactive_tid_bitmap,\n\t\t\t\t\t\t   &unshare_queues,\n\t\t\t\t\t\t   &changetid_queues);\n\t\tif (ret && free_queue < 0) {\n\t\t\tqueue_owner = sta;\n\t\t\tfree_queue = i;\n\t\t}\n\t\t \n\t\tspin_unlock_bh(&mvmsta->lock);\n\t}\n\n\n\t \n\tfor_each_set_bit(i, &unshare_queues, IWL_MAX_HW_QUEUES)\n\t\tiwl_mvm_unshare_queue(mvm, i);\n\tfor_each_set_bit(i, &changetid_queues, IWL_MAX_HW_QUEUES)\n\t\tiwl_mvm_change_queue_tid(mvm, i);\n\n\trcu_read_unlock();\n\n\tif (free_queue >= 0 && alloc_for_sta != IWL_MVM_INVALID_STA) {\n\t\tret = iwl_mvm_free_inactive_queue(mvm, free_queue, queue_owner,\n\t\t\t\t\t\t  alloc_for_sta);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn free_queue;\n}\n\nstatic int iwl_mvm_sta_alloc_queue(struct iwl_mvm *mvm,\n\t\t\t\t   struct ieee80211_sta *sta, u8 ac, int tid)\n{\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_trans_txq_scd_cfg cfg = {\n\t\t.fifo = iwl_mvm_mac_ac_to_tx_fifo(mvm, ac),\n\t\t.sta_id = mvmsta->deflink.sta_id,\n\t\t.tid = tid,\n\t\t.frame_limit = IWL_FRAME_LIMIT,\n\t};\n\tunsigned int wdg_timeout =\n\t\tiwl_mvm_get_wd_timeout(mvm, mvmsta->vif, false, false);\n\tint queue = -1;\n\tu16 queue_tmp;\n\tunsigned long disable_agg_tids = 0;\n\tenum iwl_mvm_agg_state queue_state;\n\tbool shared_queue = false, inc_ssn;\n\tint ssn;\n\tunsigned long tfd_queue_mask;\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (iwl_mvm_has_new_tx_api(mvm))\n\t\treturn iwl_mvm_sta_alloc_queue_tvqm(mvm, sta, ac, tid);\n\n\tspin_lock_bh(&mvmsta->lock);\n\ttfd_queue_mask = mvmsta->tfd_queue_msk;\n\tssn = IEEE80211_SEQ_TO_SN(mvmsta->tid_data[tid].seq_number);\n\tspin_unlock_bh(&mvmsta->lock);\n\n\tif (tid == IWL_MAX_TID_COUNT) {\n\t\tqueue = iwl_mvm_find_free_queue(mvm, mvmsta->deflink.sta_id,\n\t\t\t\t\t\tIWL_MVM_DQA_MIN_MGMT_QUEUE,\n\t\t\t\t\t\tIWL_MVM_DQA_MAX_MGMT_QUEUE);\n\t\tif (queue >= IWL_MVM_DQA_MIN_MGMT_QUEUE)\n\t\t\tIWL_DEBUG_TX_QUEUES(mvm, \"Found free MGMT queue #%d\\n\",\n\t\t\t\t\t    queue);\n\n\t\t \n\t}\n\n\tif ((queue < 0 && mvmsta->reserved_queue != IEEE80211_INVAL_HW_QUEUE) &&\n\t    (mvm->queue_info[mvmsta->reserved_queue].status ==\n\t\t\tIWL_MVM_QUEUE_RESERVED)) {\n\t\tqueue = mvmsta->reserved_queue;\n\t\tmvm->queue_info[queue].reserved = true;\n\t\tIWL_DEBUG_TX_QUEUES(mvm, \"Using reserved queue #%d\\n\", queue);\n\t}\n\n\tif (queue < 0)\n\t\tqueue = iwl_mvm_find_free_queue(mvm, mvmsta->deflink.sta_id,\n\t\t\t\t\t\tIWL_MVM_DQA_MIN_DATA_QUEUE,\n\t\t\t\t\t\tIWL_MVM_DQA_MAX_DATA_QUEUE);\n\tif (queue < 0) {\n\t\t \n\t\tqueue = iwl_mvm_inactivity_check(mvm, mvmsta->deflink.sta_id);\n\t}\n\n\t \n\tif (queue <= 0) {\n\t\tqueue = iwl_mvm_get_shared_queue(mvm, tfd_queue_mask, ac);\n\t\tif (queue > 0) {\n\t\t\tshared_queue = true;\n\t\t\tmvm->queue_info[queue].status = IWL_MVM_QUEUE_SHARED;\n\t\t}\n\t}\n\n\t \n\tif (queue > 0 && !shared_queue)\n\t\tmvm->queue_info[queue].status = IWL_MVM_QUEUE_READY;\n\n\t \n\tif (WARN_ON(queue <= 0)) {\n\t\tIWL_ERR(mvm, \"No available queues for tid %d on sta_id %d\\n\",\n\t\t\ttid, cfg.sta_id);\n\t\treturn queue;\n\t}\n\n\t \n\tcfg.aggregate = (queue >= IWL_MVM_DQA_MIN_DATA_QUEUE ||\n\t\t\t queue == IWL_MVM_DQA_BSS_CLIENT_QUEUE);\n\n\tIWL_DEBUG_TX_QUEUES(mvm,\n\t\t\t    \"Allocating %squeue #%d to sta %d on tid %d\\n\",\n\t\t\t    shared_queue ? \"shared \" : \"\", queue,\n\t\t\t    mvmsta->deflink.sta_id, tid);\n\n\tif (shared_queue) {\n\t\t \n\t\tdisable_agg_tids = iwl_mvm_get_queue_agg_tids(mvm, queue);\n\n\t\tif (disable_agg_tids) {\n\t\t\tIWL_DEBUG_TX_QUEUES(mvm, \"Disabling aggs on queue %d\\n\",\n\t\t\t\t\t    queue);\n\t\t\tiwl_mvm_invalidate_sta_queue(mvm, queue,\n\t\t\t\t\t\t     disable_agg_tids, false);\n\t\t}\n\t}\n\n\tinc_ssn = iwl_mvm_enable_txq(mvm, sta, queue, ssn, &cfg, wdg_timeout);\n\n\t \n\tif (shared_queue)\n\t\tiwl_trans_txq_set_shared_mode(mvm->trans, queue, true);\n\n\tspin_lock_bh(&mvmsta->lock);\n\t \n\tif (inc_ssn) {\n\t\tmvmsta->tid_data[tid].seq_number += 0x10;\n\t\tssn = (ssn + 1) & IEEE80211_SCTL_SEQ;\n\t}\n\tmvmsta->tid_data[tid].txq_id = queue;\n\tmvmsta->tfd_queue_msk |= BIT(queue);\n\tqueue_state = mvmsta->tid_data[tid].state;\n\n\tif (mvmsta->reserved_queue == queue)\n\t\tmvmsta->reserved_queue = IEEE80211_INVAL_HW_QUEUE;\n\tspin_unlock_bh(&mvmsta->lock);\n\n\tif (!shared_queue) {\n\t\tret = iwl_mvm_sta_send_to_fw(mvm, sta, true, STA_MODIFY_QUEUES);\n\t\tif (ret)\n\t\t\tgoto out_err;\n\n\t\t \n\t\tif (queue_state == IWL_AGG_ON) {\n\t\t\tret = iwl_mvm_sta_tx_agg(mvm, sta, tid, queue, true);\n\t\t\tif (ret)\n\t\t\t\tgoto out_err;\n\t\t}\n\t} else {\n\t\t \n\t\tret = iwl_mvm_redirect_queue(mvm, queue, tid, ac, ssn,\n\t\t\t\t\t     wdg_timeout, false,\n\t\t\t\t\t     iwl_mvm_txq_from_tid(sta, tid));\n\t\tif (ret)\n\t\t\tgoto out_err;\n\t}\n\n\treturn 0;\n\nout_err:\n\tqueue_tmp = queue;\n\tiwl_mvm_disable_txq(mvm, sta, mvmsta->deflink.sta_id, &queue_tmp, tid);\n\n\treturn ret;\n}\n\nvoid iwl_mvm_add_new_dqa_stream_wk(struct work_struct *wk)\n{\n\tstruct iwl_mvm *mvm = container_of(wk, struct iwl_mvm,\n\t\t\t\t\t   add_stream_wk);\n\n\tmutex_lock(&mvm->mutex);\n\n\tiwl_mvm_inactivity_check(mvm, IWL_MVM_INVALID_STA);\n\n\twhile (!list_empty(&mvm->add_stream_txqs)) {\n\t\tstruct iwl_mvm_txq *mvmtxq;\n\t\tstruct ieee80211_txq *txq;\n\t\tu8 tid;\n\n\t\tmvmtxq = list_first_entry(&mvm->add_stream_txqs,\n\t\t\t\t\t  struct iwl_mvm_txq, list);\n\n\t\ttxq = container_of((void *)mvmtxq, struct ieee80211_txq,\n\t\t\t\t   drv_priv);\n\t\ttid = txq->tid;\n\t\tif (tid == IEEE80211_NUM_TIDS)\n\t\t\ttid = IWL_MAX_TID_COUNT;\n\n\t\t \n\t\tif (iwl_mvm_sta_alloc_queue(mvm, txq->sta, txq->ac, tid)) {\n\t\t\tspin_lock_bh(&mvm->add_stream_lock);\n\t\t\tlist_del_init(&mvmtxq->list);\n\t\t\tspin_unlock_bh(&mvm->add_stream_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tset_bit(IWL_MVM_TXQ_STATE_READY, &mvmtxq->state);\n\n\t\tlocal_bh_disable();\n\t\tspin_lock(&mvm->add_stream_lock);\n\t\tlist_del_init(&mvmtxq->list);\n\t\tspin_unlock(&mvm->add_stream_lock);\n\n\t\tiwl_mvm_mac_itxq_xmit(mvm->hw, txq);\n\t\tlocal_bh_enable();\n\t}\n\n\tmutex_unlock(&mvm->mutex);\n}\n\nstatic int iwl_mvm_reserve_sta_stream(struct iwl_mvm *mvm,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      enum nl80211_iftype vif_type)\n{\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tint queue;\n\n\t \n\tif (WARN_ON(iwl_mvm_has_new_tx_api(mvm)))\n\t\treturn 0;\n\n\t \n\tiwl_mvm_inactivity_check(mvm, IWL_MVM_INVALID_STA);\n\n\t \n\tif (vif_type == NL80211_IFTYPE_STATION && !sta->tdls &&\n\t    !mvm->queue_info[IWL_MVM_DQA_BSS_CLIENT_QUEUE].tid_bitmap &&\n\t    (mvm->queue_info[IWL_MVM_DQA_BSS_CLIENT_QUEUE].status ==\n\t     IWL_MVM_QUEUE_FREE))\n\t\tqueue = IWL_MVM_DQA_BSS_CLIENT_QUEUE;\n\telse\n\t\tqueue = iwl_mvm_find_free_queue(mvm, mvmsta->deflink.sta_id,\n\t\t\t\t\t\tIWL_MVM_DQA_MIN_DATA_QUEUE,\n\t\t\t\t\t\tIWL_MVM_DQA_MAX_DATA_QUEUE);\n\tif (queue < 0) {\n\t\t \n\t\tqueue = iwl_mvm_inactivity_check(mvm, mvmsta->deflink.sta_id);\n\t\tif (queue < 0) {\n\t\t\tIWL_ERR(mvm, \"No available queues for new station\\n\");\n\t\t\treturn -ENOSPC;\n\t\t}\n\t}\n\tmvm->queue_info[queue].status = IWL_MVM_QUEUE_RESERVED;\n\n\tmvmsta->reserved_queue = queue;\n\n\tIWL_DEBUG_TX_QUEUES(mvm, \"Reserving data queue #%d for sta_id %d\\n\",\n\t\t\t    queue, mvmsta->deflink.sta_id);\n\n\treturn 0;\n}\n\n \nvoid iwl_mvm_realloc_queues_after_restart(struct iwl_mvm *mvm,\n\t\t\t\t\t  struct ieee80211_sta *sta)\n{\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\tunsigned int wdg =\n\t\tiwl_mvm_get_wd_timeout(mvm, mvm_sta->vif, false, false);\n\tint i;\n\tstruct iwl_trans_txq_scd_cfg cfg = {\n\t\t.sta_id = mvm_sta->deflink.sta_id,\n\t\t.frame_limit = IWL_FRAME_LIMIT,\n\t};\n\n\t \n\tif (mvm_sta->reserved_queue != IEEE80211_INVAL_HW_QUEUE)\n\t\tmvm->queue_info[mvm_sta->reserved_queue].status =\n\t\t\tIWL_MVM_QUEUE_RESERVED;\n\n\tfor (i = 0; i <= IWL_MAX_TID_COUNT; i++) {\n\t\tstruct iwl_mvm_tid_data *tid_data = &mvm_sta->tid_data[i];\n\t\tint txq_id = tid_data->txq_id;\n\t\tint ac;\n\n\t\tif (txq_id == IWL_MVM_INVALID_QUEUE)\n\t\t\tcontinue;\n\n\t\tac = tid_to_mac80211_ac[i];\n\n\t\tif (iwl_mvm_has_new_tx_api(mvm)) {\n\t\t\tIWL_DEBUG_TX_QUEUES(mvm,\n\t\t\t\t\t    \"Re-mapping sta %d tid %d\\n\",\n\t\t\t\t\t    mvm_sta->deflink.sta_id, i);\n\t\t\ttxq_id = iwl_mvm_tvqm_enable_txq(mvm, sta,\n\t\t\t\t\t\t\t mvm_sta->deflink.sta_id,\n\t\t\t\t\t\t\t i, wdg);\n\t\t\t \n\t\t\tif (txq_id < 0)\n\t\t\t\ttxq_id = IWL_MVM_INVALID_QUEUE;\n\t\t\ttid_data->txq_id = txq_id;\n\n\t\t\t \n\t\t\ttid_data->seq_number = 0;\n\t\t} else {\n\t\t\tu16 seq = IEEE80211_SEQ_TO_SN(tid_data->seq_number);\n\n\t\t\tcfg.tid = i;\n\t\t\tcfg.fifo = iwl_mvm_mac_ac_to_tx_fifo(mvm, ac);\n\t\t\tcfg.aggregate = (txq_id >= IWL_MVM_DQA_MIN_DATA_QUEUE ||\n\t\t\t\t\t txq_id ==\n\t\t\t\t\t IWL_MVM_DQA_BSS_CLIENT_QUEUE);\n\n\t\t\tIWL_DEBUG_TX_QUEUES(mvm,\n\t\t\t\t\t    \"Re-mapping sta %d tid %d to queue %d\\n\",\n\t\t\t\t\t    mvm_sta->deflink.sta_id, i,\n\t\t\t\t\t    txq_id);\n\n\t\t\tiwl_mvm_enable_txq(mvm, sta, txq_id, seq, &cfg, wdg);\n\t\t\tmvm->queue_info[txq_id].status = IWL_MVM_QUEUE_READY;\n\t\t}\n\t}\n}\n\nstatic int iwl_mvm_add_int_sta_common(struct iwl_mvm *mvm,\n\t\t\t\t      struct iwl_mvm_int_sta *sta,\n\t\t\t\t      const u8 *addr,\n\t\t\t\t      u16 mac_id, u16 color)\n{\n\tstruct iwl_mvm_add_sta_cmd cmd;\n\tint ret;\n\tu32 status = ADD_STA_SUCCESS;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.sta_id = sta->sta_id;\n\n\tif (iwl_mvm_has_new_station_api(mvm->fw) &&\n\t    sta->type == IWL_STA_AUX_ACTIVITY)\n\t\tcmd.mac_id_n_color = cpu_to_le32(mac_id);\n\telse\n\t\tcmd.mac_id_n_color = cpu_to_le32(FW_CMD_ID_AND_COLOR(mac_id,\n\t\t\t\t\t\t\t\t     color));\n\n\tif (fw_has_api(&mvm->fw->ucode_capa, IWL_UCODE_TLV_API_STA_TYPE))\n\t\tcmd.station_type = sta->type;\n\n\tif (!iwl_mvm_has_new_tx_api(mvm))\n\t\tcmd.tfd_queue_msk = cpu_to_le32(sta->tfd_queue_msk);\n\tcmd.tid_disable_tx = cpu_to_le16(0xffff);\n\n\tif (addr)\n\t\tmemcpy(cmd.addr, addr, ETH_ALEN);\n\n\tret = iwl_mvm_send_cmd_pdu_status(mvm, ADD_STA,\n\t\t\t\t\t  iwl_mvm_add_sta_cmd_size(mvm),\n\t\t\t\t\t  &cmd, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (status & IWL_ADD_STA_STATUS_MASK) {\n\tcase ADD_STA_SUCCESS:\n\t\tIWL_DEBUG_INFO(mvm, \"Internal station added.\\n\");\n\t\treturn 0;\n\tdefault:\n\t\tret = -EIO;\n\t\tIWL_ERR(mvm, \"Add internal station failed, status=0x%x\\n\",\n\t\t\tstatus);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n \nint iwl_mvm_sta_init(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t     struct ieee80211_sta *sta, int sta_id, u8 sta_type)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_mvm_rxq_dup_data *dup_data;\n\tint i, ret = 0;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tmvm_sta->mac_id_n_color = FW_CMD_ID_AND_COLOR(mvmvif->id,\n\t\t\t\t\t\t      mvmvif->color);\n\tmvm_sta->vif = vif;\n\n\t \n\tif (!mvm->mld_api_is_used) {\n\t\tif (WARN_ON(sta_id == IWL_MVM_INVALID_STA))\n\t\t\treturn -EINVAL;\n\n\t\tmvm_sta->deflink.sta_id = sta_id;\n\t\trcu_assign_pointer(mvm_sta->link[0], &mvm_sta->deflink);\n\n\t\tif (!mvm->trans->trans_cfg->gen2)\n\t\t\tmvm_sta->deflink.lq_sta.rs_drv.pers.max_agg_bufsize =\n\t\t\t\tLINK_QUAL_AGG_FRAME_LIMIT_DEF;\n\t\telse\n\t\t\tmvm_sta->deflink.lq_sta.rs_drv.pers.max_agg_bufsize =\n\t\t\t\tLINK_QUAL_AGG_FRAME_LIMIT_GEN2_DEF;\n\t}\n\n\tmvm_sta->tt_tx_protection = false;\n\tmvm_sta->sta_type = sta_type;\n\n\tmvm_sta->tid_disable_agg = 0xffff;  \n\n\tfor (i = 0; i <= IWL_MAX_TID_COUNT; i++) {\n\t\t \n\t\tmvm_sta->tid_data[i].txq_id = IWL_MVM_INVALID_QUEUE;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(sta->txq); i++) {\n\t\tstruct iwl_mvm_txq *mvmtxq =\n\t\t\tiwl_mvm_txq_from_mac80211(sta->txq[i]);\n\n\t\tmvmtxq->txq_id = IWL_MVM_INVALID_QUEUE;\n\t\tINIT_LIST_HEAD(&mvmtxq->list);\n\t\tatomic_set(&mvmtxq->tx_request, 0);\n\t}\n\n\tif (iwl_mvm_has_new_rx_api(mvm)) {\n\t\tint q;\n\n\t\tdup_data = kcalloc(mvm->trans->num_rx_queues,\n\t\t\t\t   sizeof(*dup_data), GFP_KERNEL);\n\t\tif (!dup_data)\n\t\t\treturn -ENOMEM;\n\t\t \n\t\tfor (q = 0; q < mvm->trans->num_rx_queues; q++)\n\t\t\tmemset(dup_data[q].last_seq, 0xff,\n\t\t\t       sizeof(dup_data[q].last_seq));\n\t\tmvm_sta->dup_data = dup_data;\n\t}\n\n\tif (!iwl_mvm_has_new_tx_api(mvm)) {\n\t\tret = iwl_mvm_reserve_sta_stream(mvm, sta,\n\t\t\t\t\t\t ieee80211_vif_type_p2p(vif));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (iwl_mvm_has_tlc_offload(mvm))\n\t\tiwl_mvm_rs_add_sta(mvm, mvm_sta);\n\telse\n\t\tspin_lock_init(&mvm_sta->deflink.lq_sta.rs_drv.pers.lock);\n\n\tiwl_mvm_toggle_tx_ant(mvm, &mvm_sta->tx_ant);\n\n\treturn 0;\n}\n\nint iwl_mvm_add_sta(struct iwl_mvm *mvm,\n\t\t    struct ieee80211_vif *vif,\n\t\t    struct ieee80211_sta *sta)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\tint ret, sta_id;\n\tbool sta_update = false;\n\tunsigned int sta_flags = 0;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (!test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status))\n\t\tsta_id = iwl_mvm_find_free_sta_id(mvm,\n\t\t\t\t\t\t  ieee80211_vif_type_p2p(vif));\n\telse\n\t\tsta_id = mvm_sta->deflink.sta_id;\n\n\tif (sta_id == IWL_MVM_INVALID_STA)\n\t\treturn -ENOSPC;\n\n\tspin_lock_init(&mvm_sta->lock);\n\n\t \n\tif (test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status)) {\n\t\tstruct iwl_mvm_int_sta tmp_sta = {\n\t\t\t.sta_id = sta_id,\n\t\t\t.type = mvm_sta->sta_type,\n\t\t};\n\n\t\t \n\t\tret = iwl_mvm_add_int_sta_common(mvm, &tmp_sta, sta->addr,\n\t\t\t\t\t\t mvmvif->id, mvmvif->color);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tiwl_mvm_realloc_queues_after_restart(mvm, sta);\n\t\tsta_update = true;\n\t\tsta_flags = iwl_mvm_has_new_tx_api(mvm) ? 0 : STA_MODIFY_QUEUES;\n\t\tgoto update_fw;\n\t}\n\n\tret = iwl_mvm_sta_init(mvm, vif, sta, sta_id,\n\t\t\t       sta->tdls ? IWL_STA_TDLS_LINK : IWL_STA_LINK);\n\tif (ret)\n\t\tgoto err;\n\nupdate_fw:\n\tret = iwl_mvm_sta_send_to_fw(mvm, sta, sta_update, sta_flags);\n\tif (ret)\n\t\tgoto err;\n\n\tif (vif->type == NL80211_IFTYPE_STATION) {\n\t\tif (!sta->tdls) {\n\t\t\tWARN_ON(mvmvif->deflink.ap_sta_id != IWL_MVM_INVALID_STA);\n\t\t\tmvmvif->deflink.ap_sta_id = sta_id;\n\t\t} else {\n\t\t\tWARN_ON(mvmvif->deflink.ap_sta_id == IWL_MVM_INVALID_STA);\n\t\t}\n\t}\n\n\trcu_assign_pointer(mvm->fw_id_to_mac_id[sta_id], sta);\n\n\treturn 0;\n\nerr:\n\treturn ret;\n}\n\nint iwl_mvm_drain_sta(struct iwl_mvm *mvm, struct iwl_mvm_sta *mvmsta,\n\t\t      bool drain)\n{\n\tstruct iwl_mvm_add_sta_cmd cmd = {};\n\tint ret;\n\tu32 status;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tcmd.mac_id_n_color = cpu_to_le32(mvmsta->mac_id_n_color);\n\tcmd.sta_id = mvmsta->deflink.sta_id;\n\tcmd.add_modify = STA_MODE_MODIFY;\n\tcmd.station_flags = drain ? cpu_to_le32(STA_FLG_DRAIN_FLOW) : 0;\n\tcmd.station_flags_msk = cpu_to_le32(STA_FLG_DRAIN_FLOW);\n\n\tstatus = ADD_STA_SUCCESS;\n\tret = iwl_mvm_send_cmd_pdu_status(mvm, ADD_STA,\n\t\t\t\t\t  iwl_mvm_add_sta_cmd_size(mvm),\n\t\t\t\t\t  &cmd, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (status & IWL_ADD_STA_STATUS_MASK) {\n\tcase ADD_STA_SUCCESS:\n\t\tIWL_DEBUG_INFO(mvm, \"Frames for staid %d will drained in fw\\n\",\n\t\t\t       mvmsta->deflink.sta_id);\n\t\tbreak;\n\tdefault:\n\t\tret = -EIO;\n\t\tIWL_ERR(mvm, \"Couldn't drain frames for staid %d\\n\",\n\t\t\tmvmsta->deflink.sta_id);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int iwl_mvm_rm_sta_common(struct iwl_mvm *mvm, u8 sta_id)\n{\n\tstruct ieee80211_sta *sta;\n\tstruct iwl_mvm_rm_sta_cmd rm_sta_cmd = {\n\t\t.sta_id = sta_id,\n\t};\n\tint ret;\n\n\tsta = rcu_dereference_protected(mvm->fw_id_to_mac_id[sta_id],\n\t\t\t\t\tlockdep_is_held(&mvm->mutex));\n\n\t \n\tif (!sta) {\n\t\tIWL_ERR(mvm, \"Invalid station id\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = iwl_mvm_send_cmd_pdu(mvm, REMOVE_STA, 0,\n\t\t\t\t   sizeof(rm_sta_cmd), &rm_sta_cmd);\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"Failed to remove station. Id=%d\\n\", sta_id);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void iwl_mvm_disable_sta_queues(struct iwl_mvm *mvm,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_sta *sta)\n{\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\tint i;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tfor (i = 0; i < ARRAY_SIZE(mvm_sta->tid_data); i++) {\n\t\tif (mvm_sta->tid_data[i].txq_id == IWL_MVM_INVALID_QUEUE)\n\t\t\tcontinue;\n\n\t\tiwl_mvm_disable_txq(mvm, sta, mvm_sta->deflink.sta_id,\n\t\t\t\t    &mvm_sta->tid_data[i].txq_id, i);\n\t\tmvm_sta->tid_data[i].txq_id = IWL_MVM_INVALID_QUEUE;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(sta->txq); i++) {\n\t\tstruct iwl_mvm_txq *mvmtxq =\n\t\t\tiwl_mvm_txq_from_mac80211(sta->txq[i]);\n\n\t\tspin_lock_bh(&mvm->add_stream_lock);\n\t\tmvmtxq->txq_id = IWL_MVM_INVALID_QUEUE;\n\t\tlist_del_init(&mvmtxq->list);\n\t\tclear_bit(IWL_MVM_TXQ_STATE_READY, &mvmtxq->state);\n\t\tspin_unlock_bh(&mvm->add_stream_lock);\n\t}\n}\n\nint iwl_mvm_wait_sta_queues_empty(struct iwl_mvm *mvm,\n\t\t\t\t  struct iwl_mvm_sta *mvm_sta)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mvm_sta->tid_data); i++) {\n\t\tu16 txq_id;\n\t\tint ret;\n\n\t\tspin_lock_bh(&mvm_sta->lock);\n\t\ttxq_id = mvm_sta->tid_data[i].txq_id;\n\t\tspin_unlock_bh(&mvm_sta->lock);\n\n\t\tif (txq_id == IWL_MVM_INVALID_QUEUE)\n\t\t\tcontinue;\n\n\t\tret = iwl_trans_wait_txq_empty(mvm->trans, txq_id);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nbool iwl_mvm_sta_del(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t     struct ieee80211_sta *sta,\n\t\t     struct ieee80211_link_sta *link_sta, int *ret)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_vif_link_info *mvm_link =\n\t\tmvmvif->link[link_sta->link_id];\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_mvm_link_sta *mvm_link_sta;\n\tu8 sta_id;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tmvm_link_sta =\n\t\trcu_dereference_protected(mvm_sta->link[link_sta->link_id],\n\t\t\t\t\t  lockdep_is_held(&mvm->mutex));\n\tsta_id = mvm_link_sta->sta_id;\n\n\t \n\tif (mvm_sta->reserved_queue != IEEE80211_INVAL_HW_QUEUE) {\n\t\tu8 reserved_txq = mvm_sta->reserved_queue;\n\t\tenum iwl_mvm_queue_status *status;\n\n\t\t \n\t\tstatus = &mvm->queue_info[reserved_txq].status;\n\t\tif (WARN((*status != IWL_MVM_QUEUE_RESERVED) &&\n\t\t\t (*status != IWL_MVM_QUEUE_FREE),\n\t\t\t \"sta_id %d reserved txq %d status %d\",\n\t\t\t sta_id, reserved_txq, *status)) {\n\t\t\t*ret = -EINVAL;\n\t\t\treturn true;\n\t\t}\n\n\t\t*status = IWL_MVM_QUEUE_FREE;\n\t}\n\n\tif (vif->type == NL80211_IFTYPE_STATION &&\n\t    mvm_link->ap_sta_id == sta_id) {\n\t\t \n\t\tif (vif->cfg.assoc)\n\t\t\treturn true;\n\n\t\t \n\t\tiwl_mvm_sec_key_remove_ap(mvm, vif, mvm_link, 0);\n\n\t\t \n\t\tmvm_link->ap_sta_id = IWL_MVM_INVALID_STA;\n\t}\n\n\t \n\tif (WARN_ON_ONCE(mvm->tdls_cs.peer.sta_id == sta_id)) {\n\t\tmvm->tdls_cs.peer.sta_id = IWL_MVM_INVALID_STA;\n\t\tcancel_delayed_work(&mvm->tdls_cs.dwork);\n\t}\n\n\treturn false;\n}\n\nint iwl_mvm_rm_sta(struct iwl_mvm *mvm,\n\t\t   struct ieee80211_vif *vif,\n\t\t   struct ieee80211_sta *sta)\n{\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tret = iwl_mvm_drain_sta(mvm, mvm_sta, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = iwl_mvm_flush_sta(mvm, mvm_sta->deflink.sta_id,\n\t\t\t\tmvm_sta->tfd_queue_msk);\n\tif (ret)\n\t\treturn ret;\n\tif (iwl_mvm_has_new_tx_api(mvm)) {\n\t\tret = iwl_mvm_wait_sta_queues_empty(mvm, mvm_sta);\n\t} else {\n\t\tu32 q_mask = mvm_sta->tfd_queue_msk;\n\n\t\tret = iwl_trans_wait_tx_queues_empty(mvm->trans,\n\t\t\t\t\t\t     q_mask);\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\tret = iwl_mvm_drain_sta(mvm, mvm_sta, false);\n\n\tiwl_mvm_disable_sta_queues(mvm, vif, sta);\n\n\tif (iwl_mvm_sta_del(mvm, vif, sta, &sta->deflink, &ret))\n\t\treturn ret;\n\n\tret = iwl_mvm_rm_sta_common(mvm, mvm_sta->deflink.sta_id);\n\tRCU_INIT_POINTER(mvm->fw_id_to_mac_id[mvm_sta->deflink.sta_id], NULL);\n\n\treturn ret;\n}\n\nint iwl_mvm_rm_sta_id(struct iwl_mvm *mvm,\n\t\t      struct ieee80211_vif *vif,\n\t\t      u8 sta_id)\n{\n\tint ret = iwl_mvm_rm_sta_common(mvm, sta_id);\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tRCU_INIT_POINTER(mvm->fw_id_to_mac_id[sta_id], NULL);\n\treturn ret;\n}\n\nint iwl_mvm_allocate_int_sta(struct iwl_mvm *mvm,\n\t\t\t     struct iwl_mvm_int_sta *sta,\n\t\t\t     u32 qmask, enum nl80211_iftype iftype,\n\t\t\t     u8 type)\n{\n\tif (!test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status) ||\n\t    sta->sta_id == IWL_MVM_INVALID_STA) {\n\t\tsta->sta_id = iwl_mvm_find_free_sta_id(mvm, iftype);\n\t\tif (WARN_ON_ONCE(sta->sta_id == IWL_MVM_INVALID_STA))\n\t\t\treturn -ENOSPC;\n\t}\n\n\tsta->tfd_queue_msk = qmask;\n\tsta->type = type;\n\n\t \n\tRCU_INIT_POINTER(mvm->fw_id_to_mac_id[sta->sta_id], ERR_PTR(-EINVAL));\n\treturn 0;\n}\n\nvoid iwl_mvm_dealloc_int_sta(struct iwl_mvm *mvm, struct iwl_mvm_int_sta *sta)\n{\n\tRCU_INIT_POINTER(mvm->fw_id_to_mac_id[sta->sta_id], NULL);\n\tmemset(sta, 0, sizeof(struct iwl_mvm_int_sta));\n\tsta->sta_id = IWL_MVM_INVALID_STA;\n}\n\nstatic void iwl_mvm_enable_aux_snif_queue(struct iwl_mvm *mvm, u16 queue,\n\t\t\t\t\t  u8 sta_id, u8 fifo)\n{\n\tunsigned int wdg_timeout =\n\t\tmvm->trans->trans_cfg->base_params->wd_timeout;\n\tstruct iwl_trans_txq_scd_cfg cfg = {\n\t\t.fifo = fifo,\n\t\t.sta_id = sta_id,\n\t\t.tid = IWL_MAX_TID_COUNT,\n\t\t.aggregate = false,\n\t\t.frame_limit = IWL_FRAME_LIMIT,\n\t};\n\n\tWARN_ON(iwl_mvm_has_new_tx_api(mvm));\n\n\tiwl_mvm_enable_txq(mvm, NULL, queue, 0, &cfg, wdg_timeout);\n}\n\nstatic int iwl_mvm_enable_aux_snif_queue_tvqm(struct iwl_mvm *mvm, u8 sta_id)\n{\n\tunsigned int wdg_timeout =\n\t\tmvm->trans->trans_cfg->base_params->wd_timeout;\n\n\tWARN_ON(!iwl_mvm_has_new_tx_api(mvm));\n\n\treturn iwl_mvm_tvqm_enable_txq(mvm, NULL, sta_id, IWL_MAX_TID_COUNT,\n\t\t\t\t       wdg_timeout);\n}\n\nstatic int iwl_mvm_add_int_sta_with_queue(struct iwl_mvm *mvm, int macidx,\n\t\t\t\t\t  int maccolor, u8 *addr,\n\t\t\t\t\t  struct iwl_mvm_int_sta *sta,\n\t\t\t\t\t  u16 *queue, int fifo)\n{\n\tint ret;\n\n\t \n\tif (!iwl_mvm_has_new_tx_api(mvm))\n\t\tiwl_mvm_enable_aux_snif_queue(mvm, *queue, sta->sta_id, fifo);\n\n\tret = iwl_mvm_add_int_sta_common(mvm, sta, addr, macidx, maccolor);\n\tif (ret) {\n\t\tif (!iwl_mvm_has_new_tx_api(mvm))\n\t\t\tiwl_mvm_disable_txq(mvm, NULL, sta->sta_id, queue,\n\t\t\t\t\t    IWL_MAX_TID_COUNT);\n\t\treturn ret;\n\t}\n\n\t \n\tif (iwl_mvm_has_new_tx_api(mvm)) {\n\t\tint txq;\n\n\t\ttxq = iwl_mvm_enable_aux_snif_queue_tvqm(mvm, sta->sta_id);\n\t\tif (txq < 0) {\n\t\t\tiwl_mvm_rm_sta_common(mvm, sta->sta_id);\n\t\t\treturn txq;\n\t\t}\n\n\t\t*queue = txq;\n\t}\n\n\treturn 0;\n}\n\nint iwl_mvm_add_aux_sta(struct iwl_mvm *mvm, u32 lmac_id)\n{\n\tint ret;\n\tu32 qmask = mvm->aux_queue == IWL_MVM_INVALID_QUEUE ? 0 :\n\t\tBIT(mvm->aux_queue);\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\t \n\tret = iwl_mvm_allocate_int_sta(mvm, &mvm->aux_sta, qmask,\n\t\t\t\t       NL80211_IFTYPE_UNSPECIFIED,\n\t\t\t\t       IWL_STA_AUX_ACTIVITY);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = iwl_mvm_add_int_sta_with_queue(mvm, lmac_id, 0, NULL,\n\t\t\t\t\t     &mvm->aux_sta, &mvm->aux_queue,\n\t\t\t\t\t     IWL_MVM_TX_FIFO_MCAST);\n\tif (ret) {\n\t\tiwl_mvm_dealloc_int_sta(mvm, &mvm->aux_sta);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint iwl_mvm_add_snif_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\treturn iwl_mvm_add_int_sta_with_queue(mvm, mvmvif->id, mvmvif->color,\n\t\t\t\t\t      NULL, &mvm->snif_sta,\n\t\t\t\t\t      &mvm->snif_queue,\n\t\t\t\t\t      IWL_MVM_TX_FIFO_BE);\n}\n\nint iwl_mvm_rm_snif_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (WARN_ON_ONCE(mvm->snif_sta.sta_id == IWL_MVM_INVALID_STA))\n\t\treturn -EINVAL;\n\n\tiwl_mvm_disable_txq(mvm, NULL, mvm->snif_sta.sta_id,\n\t\t\t    &mvm->snif_queue, IWL_MAX_TID_COUNT);\n\tret = iwl_mvm_rm_sta_common(mvm, mvm->snif_sta.sta_id);\n\tif (ret)\n\t\tIWL_WARN(mvm, \"Failed sending remove station\\n\");\n\n\treturn ret;\n}\n\nint iwl_mvm_rm_aux_sta(struct iwl_mvm *mvm)\n{\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (WARN_ON_ONCE(mvm->aux_sta.sta_id == IWL_MVM_INVALID_STA))\n\t\treturn -EINVAL;\n\n\tiwl_mvm_disable_txq(mvm, NULL, mvm->aux_sta.sta_id,\n\t\t\t    &mvm->aux_queue, IWL_MAX_TID_COUNT);\n\tret = iwl_mvm_rm_sta_common(mvm, mvm->aux_sta.sta_id);\n\tif (ret)\n\t\tIWL_WARN(mvm, \"Failed sending remove station\\n\");\n\tiwl_mvm_dealloc_int_sta(mvm, &mvm->aux_sta);\n\n\treturn ret;\n}\n\nvoid iwl_mvm_dealloc_snif_sta(struct iwl_mvm *mvm)\n{\n\tiwl_mvm_dealloc_int_sta(mvm, &mvm->snif_sta);\n}\n\n \nint iwl_mvm_send_add_bcast_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_int_sta *bsta = &mvmvif->deflink.bcast_sta;\n\tstatic const u8 _baddr[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};\n\tconst u8 *baddr = _baddr;\n\tint queue;\n\tint ret;\n\tunsigned int wdg_timeout =\n\t\tiwl_mvm_get_wd_timeout(mvm, vif, false, false);\n\tstruct iwl_trans_txq_scd_cfg cfg = {\n\t\t.fifo = IWL_MVM_TX_FIFO_VO,\n\t\t.sta_id = mvmvif->deflink.bcast_sta.sta_id,\n\t\t.tid = IWL_MAX_TID_COUNT,\n\t\t.aggregate = false,\n\t\t.frame_limit = IWL_FRAME_LIMIT,\n\t};\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (!iwl_mvm_has_new_tx_api(mvm)) {\n\t\tif (vif->type == NL80211_IFTYPE_AP ||\n\t\t    vif->type == NL80211_IFTYPE_ADHOC) {\n\t\t\tqueue = mvm->probe_queue;\n\t\t} else if (vif->type == NL80211_IFTYPE_P2P_DEVICE) {\n\t\t\tqueue = mvm->p2p_dev_queue;\n\t\t} else {\n\t\t\tWARN(1, \"Missing required TXQ for adding bcast STA\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbsta->tfd_queue_msk |= BIT(queue);\n\n\t\tiwl_mvm_enable_txq(mvm, NULL, queue, 0, &cfg, wdg_timeout);\n\t}\n\n\tif (vif->type == NL80211_IFTYPE_ADHOC)\n\t\tbaddr = vif->bss_conf.bssid;\n\n\tif (WARN_ON_ONCE(bsta->sta_id == IWL_MVM_INVALID_STA))\n\t\treturn -ENOSPC;\n\n\tret = iwl_mvm_add_int_sta_common(mvm, bsta, baddr,\n\t\t\t\t\t mvmvif->id, mvmvif->color);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (iwl_mvm_has_new_tx_api(mvm)) {\n\t\tqueue = iwl_mvm_tvqm_enable_txq(mvm, NULL, bsta->sta_id,\n\t\t\t\t\t\tIWL_MAX_TID_COUNT,\n\t\t\t\t\t\twdg_timeout);\n\t\tif (queue < 0) {\n\t\t\tiwl_mvm_rm_sta_common(mvm, bsta->sta_id);\n\t\t\treturn queue;\n\t\t}\n\n\t\tif (vif->type == NL80211_IFTYPE_AP ||\n\t\t    vif->type == NL80211_IFTYPE_ADHOC) {\n\t\t\t \n\t\t\tmvm->probe_queue = queue;\n\t\t\t \n\t\t\tmvmvif->deflink.mgmt_queue = queue;\n\t\t} else if (vif->type == NL80211_IFTYPE_P2P_DEVICE) {\n\t\t\tmvm->p2p_dev_queue = queue;\n\t\t}\n\t} else if (vif->type == NL80211_IFTYPE_AP ||\n\t\t   vif->type == NL80211_IFTYPE_ADHOC) {\n\t\t \n\t\tmvmvif->deflink.mgmt_queue = mvm->probe_queue;\n\t}\n\n\treturn 0;\n}\n\nvoid iwl_mvm_free_bcast_sta_queues(struct iwl_mvm *mvm,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tu16 *queueptr, queue;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tiwl_mvm_flush_sta(mvm, mvmvif->deflink.bcast_sta.sta_id,\n\t\t\t  mvmvif->deflink.bcast_sta.tfd_queue_msk);\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tqueueptr = &mvm->probe_queue;\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tqueueptr = &mvm->p2p_dev_queue;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Can't free bcast queue on vif type %d\\n\",\n\t\t     vif->type);\n\t\treturn;\n\t}\n\n\tqueue = *queueptr;\n\tiwl_mvm_disable_txq(mvm, NULL, mvmvif->deflink.bcast_sta.sta_id,\n\t\t\t    queueptr, IWL_MAX_TID_COUNT);\n\n\tif (vif->type == NL80211_IFTYPE_AP || vif->type == NL80211_IFTYPE_ADHOC)\n\t\tmvmvif->deflink.mgmt_queue = mvm->probe_queue;\n\n\tif (iwl_mvm_has_new_tx_api(mvm))\n\t\treturn;\n\n\tWARN_ON(!(mvmvif->deflink.bcast_sta.tfd_queue_msk & BIT(queue)));\n\tmvmvif->deflink.bcast_sta.tfd_queue_msk &= ~BIT(queue);\n}\n\n \nint iwl_mvm_send_rm_bcast_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tiwl_mvm_free_bcast_sta_queues(mvm, vif);\n\n\tret = iwl_mvm_rm_sta_common(mvm, mvmvif->deflink.bcast_sta.sta_id);\n\tif (ret)\n\t\tIWL_WARN(mvm, \"Failed sending remove station\\n\");\n\treturn ret;\n}\n\nint iwl_mvm_alloc_bcast_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\treturn iwl_mvm_allocate_int_sta(mvm, &mvmvif->deflink.bcast_sta, 0,\n\t\t\t\t\tieee80211_vif_type_p2p(vif),\n\t\t\t\t\tIWL_STA_GENERAL_PURPOSE);\n}\n\n \nint iwl_mvm_add_p2p_bcast_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_int_sta *bsta = &mvmvif->deflink.bcast_sta;\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tret = iwl_mvm_alloc_bcast_sta(mvm, vif);\n\tif (ret)\n\t\treturn ret;\n\n\tret = iwl_mvm_send_add_bcast_sta(mvm, vif);\n\n\tif (ret)\n\t\tiwl_mvm_dealloc_int_sta(mvm, bsta);\n\n\treturn ret;\n}\n\nvoid iwl_mvm_dealloc_bcast_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tiwl_mvm_dealloc_int_sta(mvm, &mvmvif->deflink.bcast_sta);\n}\n\n \nint iwl_mvm_rm_p2p_bcast_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tret = iwl_mvm_send_rm_bcast_sta(mvm, vif);\n\n\tiwl_mvm_dealloc_bcast_sta(mvm, vif);\n\n\treturn ret;\n}\n\n \nint iwl_mvm_add_mcast_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_int_sta *msta = &mvmvif->deflink.mcast_sta;\n\tstatic const u8 _maddr[] = {0x03, 0x00, 0x00, 0x00, 0x00, 0x00};\n\tconst u8 *maddr = _maddr;\n\tstruct iwl_trans_txq_scd_cfg cfg = {\n\t\t.fifo = vif->type == NL80211_IFTYPE_AP ?\n\t\t\tIWL_MVM_TX_FIFO_MCAST : IWL_MVM_TX_FIFO_BE,\n\t\t.sta_id = msta->sta_id,\n\t\t.tid = 0,\n\t\t.aggregate = false,\n\t\t.frame_limit = IWL_FRAME_LIMIT,\n\t};\n\tunsigned int timeout = iwl_mvm_get_wd_timeout(mvm, vif, false, false);\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (WARN_ON(vif->type != NL80211_IFTYPE_AP &&\n\t\t    vif->type != NL80211_IFTYPE_ADHOC))\n\t\treturn -ENOTSUPP;\n\n\t \n\tif (vif->type == NL80211_IFTYPE_ADHOC)\n\t\tmvmvif->deflink.cab_queue = IWL_MVM_DQA_GCAST_QUEUE;\n\n\t \n\tif (!iwl_mvm_has_new_tx_api(mvm) &&\n\t    fw_has_api(&mvm->fw->ucode_capa, IWL_UCODE_TLV_API_STA_TYPE)) {\n\t\tiwl_mvm_enable_txq(mvm, NULL, mvmvif->deflink.cab_queue, 0,\n\t\t\t\t   &cfg,\n\t\t\t\t   timeout);\n\t\tmsta->tfd_queue_msk |= BIT(mvmvif->deflink.cab_queue);\n\t}\n\tret = iwl_mvm_add_int_sta_common(mvm, msta, maddr,\n\t\t\t\t\t mvmvif->id, mvmvif->color);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tif (iwl_mvm_has_new_tx_api(mvm)) {\n\t\tint queue = iwl_mvm_tvqm_enable_txq(mvm, NULL, msta->sta_id,\n\t\t\t\t\t\t    0, timeout);\n\t\tif (queue < 0) {\n\t\t\tret = queue;\n\t\t\tgoto err;\n\t\t}\n\t\tmvmvif->deflink.cab_queue = queue;\n\t} else if (!fw_has_api(&mvm->fw->ucode_capa,\n\t\t\t       IWL_UCODE_TLV_API_STA_TYPE))\n\t\tiwl_mvm_enable_txq(mvm, NULL, mvmvif->deflink.cab_queue, 0,\n\t\t\t\t   &cfg,\n\t\t\t\t   timeout);\n\n\treturn 0;\nerr:\n\tiwl_mvm_dealloc_int_sta(mvm, msta);\n\treturn ret;\n}\n\nstatic int __iwl_mvm_remove_sta_key(struct iwl_mvm *mvm, u8 sta_id,\n\t\t\t\t    struct ieee80211_key_conf *keyconf,\n\t\t\t\t    bool mcast)\n{\n\tunion {\n\t\tstruct iwl_mvm_add_sta_key_cmd_v1 cmd_v1;\n\t\tstruct iwl_mvm_add_sta_key_cmd cmd;\n\t} u = {};\n\tbool new_api = fw_has_api(&mvm->fw->ucode_capa,\n\t\t\t\t  IWL_UCODE_TLV_API_TKIP_MIC_KEYS);\n\t__le16 key_flags;\n\tint ret, size;\n\tu32 status;\n\n\t \n\tif (sta_id == IWL_MVM_INVALID_STA)\n\t\treturn 0;\n\n\tkey_flags = cpu_to_le16((keyconf->keyidx << STA_KEY_FLG_KEYID_POS) &\n\t\t\t\t STA_KEY_FLG_KEYID_MSK);\n\tkey_flags |= cpu_to_le16(STA_KEY_FLG_NO_ENC | STA_KEY_FLG_WEP_KEY_MAP);\n\tkey_flags |= cpu_to_le16(STA_KEY_NOT_VALID);\n\n\tif (mcast)\n\t\tkey_flags |= cpu_to_le16(STA_KEY_MULTICAST);\n\n\t \n\tu.cmd.common.key_flags = key_flags;\n\tu.cmd.common.key_offset = keyconf->hw_key_idx;\n\tu.cmd.common.sta_id = sta_id;\n\n\tsize = new_api ? sizeof(u.cmd) : sizeof(u.cmd_v1);\n\n\tstatus = ADD_STA_SUCCESS;\n\tret = iwl_mvm_send_cmd_pdu_status(mvm, ADD_STA_KEY, size, &u.cmd,\n\t\t\t\t\t  &status);\n\n\tswitch (status) {\n\tcase ADD_STA_SUCCESS:\n\t\tIWL_DEBUG_WEP(mvm, \"MODIFY_STA: remove sta key passed\\n\");\n\t\tbreak;\n\tdefault:\n\t\tret = -EIO;\n\t\tIWL_ERR(mvm, \"MODIFY_STA: remove sta key failed\\n\");\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nint iwl_mvm_rm_mcast_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tint ret;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tiwl_mvm_flush_sta(mvm, mvmvif->deflink.mcast_sta.sta_id,\n\t\t\t  mvmvif->deflink.mcast_sta.tfd_queue_msk);\n\n\tiwl_mvm_disable_txq(mvm, NULL, mvmvif->deflink.mcast_sta.sta_id,\n\t\t\t    &mvmvif->deflink.cab_queue, 0);\n\n\tret = iwl_mvm_rm_sta_common(mvm, mvmvif->deflink.mcast_sta.sta_id);\n\tif (ret)\n\t\tIWL_WARN(mvm, \"Failed sending remove station\\n\");\n\n\treturn ret;\n}\n\nstatic void iwl_mvm_sync_rxq_del_ba(struct iwl_mvm *mvm, u8 baid)\n{\n\tstruct iwl_mvm_delba_data notif = {\n\t\t.baid = baid,\n\t};\n\n\tiwl_mvm_sync_rx_queues_internal(mvm, IWL_MVM_RXQ_NOTIF_DEL_BA, true,\n\t\t\t\t\t&notif, sizeof(notif));\n};\n\nstatic void iwl_mvm_free_reorder(struct iwl_mvm *mvm,\n\t\t\t\t struct iwl_mvm_baid_data *data)\n{\n\tint i;\n\n\tiwl_mvm_sync_rxq_del_ba(mvm, data->baid);\n\n\tfor (i = 0; i < mvm->trans->num_rx_queues; i++) {\n\t\tint j;\n\t\tstruct iwl_mvm_reorder_buffer *reorder_buf =\n\t\t\t&data->reorder_buf[i];\n\t\tstruct iwl_mvm_reorder_buf_entry *entries =\n\t\t\t&data->entries[i * data->entries_per_queue];\n\n\t\tspin_lock_bh(&reorder_buf->lock);\n\t\tif (likely(!reorder_buf->num_stored)) {\n\t\t\tspin_unlock_bh(&reorder_buf->lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tWARN_ON(1);\n\n\t\tfor (j = 0; j < reorder_buf->buf_size; j++)\n\t\t\t__skb_queue_purge(&entries[j].e.frames);\n\t\t \n\t\treorder_buf->removed = true;\n\t\tspin_unlock_bh(&reorder_buf->lock);\n\t\tdel_timer_sync(&reorder_buf->reorder_timer);\n\t}\n}\n\nstatic void iwl_mvm_init_reorder_buffer(struct iwl_mvm *mvm,\n\t\t\t\t\tstruct iwl_mvm_baid_data *data,\n\t\t\t\t\tu16 ssn, u16 buf_size)\n{\n\tint i;\n\n\tfor (i = 0; i < mvm->trans->num_rx_queues; i++) {\n\t\tstruct iwl_mvm_reorder_buffer *reorder_buf =\n\t\t\t&data->reorder_buf[i];\n\t\tstruct iwl_mvm_reorder_buf_entry *entries =\n\t\t\t&data->entries[i * data->entries_per_queue];\n\t\tint j;\n\n\t\treorder_buf->num_stored = 0;\n\t\treorder_buf->head_sn = ssn;\n\t\treorder_buf->buf_size = buf_size;\n\t\t \n\t\ttimer_setup(&reorder_buf->reorder_timer,\n\t\t\t    iwl_mvm_reorder_timer_expired, 0);\n\t\tspin_lock_init(&reorder_buf->lock);\n\t\treorder_buf->mvm = mvm;\n\t\treorder_buf->queue = i;\n\t\treorder_buf->valid = false;\n\t\tfor (j = 0; j < reorder_buf->buf_size; j++)\n\t\t\t__skb_queue_head_init(&entries[j].e.frames);\n\t}\n}\n\nstatic int iwl_mvm_fw_baid_op_sta(struct iwl_mvm *mvm,\n\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t  bool start, int tid, u16 ssn,\n\t\t\t\t  u16 buf_size)\n{\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_mvm_add_sta_cmd cmd = {\n\t\t.mac_id_n_color = cpu_to_le32(mvm_sta->mac_id_n_color),\n\t\t.sta_id = mvm_sta->deflink.sta_id,\n\t\t.add_modify = STA_MODE_MODIFY,\n\t};\n\tu32 status;\n\tint ret;\n\n\tif (start) {\n\t\tcmd.add_immediate_ba_tid = tid;\n\t\tcmd.add_immediate_ba_ssn = cpu_to_le16(ssn);\n\t\tcmd.rx_ba_window = cpu_to_le16(buf_size);\n\t\tcmd.modify_mask = STA_MODIFY_ADD_BA_TID;\n\t} else {\n\t\tcmd.remove_immediate_ba_tid = tid;\n\t\tcmd.modify_mask = STA_MODIFY_REMOVE_BA_TID;\n\t}\n\n\tstatus = ADD_STA_SUCCESS;\n\tret = iwl_mvm_send_cmd_pdu_status(mvm, ADD_STA,\n\t\t\t\t\t  iwl_mvm_add_sta_cmd_size(mvm),\n\t\t\t\t\t  &cmd, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (status & IWL_ADD_STA_STATUS_MASK) {\n\tcase ADD_STA_SUCCESS:\n\t\tIWL_DEBUG_HT(mvm, \"RX BA Session %sed in fw\\n\",\n\t\t\t     start ? \"start\" : \"stopp\");\n\t\tif (WARN_ON(start && iwl_mvm_has_new_rx_api(mvm) &&\n\t\t\t    !(status & IWL_ADD_STA_BAID_VALID_MASK)))\n\t\t\treturn -EINVAL;\n\t\treturn u32_get_bits(status, IWL_ADD_STA_BAID_MASK);\n\tcase ADD_STA_IMMEDIATE_BA_FAILURE:\n\t\tIWL_WARN(mvm, \"RX BA Session refused by fw\\n\");\n\t\treturn -ENOSPC;\n\tdefault:\n\t\tIWL_ERR(mvm, \"RX BA Session failed %sing, status 0x%x\\n\",\n\t\t\tstart ? \"start\" : \"stopp\", status);\n\t\treturn -EIO;\n\t}\n}\n\nstatic int iwl_mvm_fw_baid_op_cmd(struct iwl_mvm *mvm,\n\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t  bool start, int tid, u16 ssn,\n\t\t\t\t  u16 buf_size, int baid)\n{\n\tstruct iwl_rx_baid_cfg_cmd cmd = {\n\t\t.action = start ? cpu_to_le32(IWL_RX_BAID_ACTION_ADD) :\n\t\t\t\t  cpu_to_le32(IWL_RX_BAID_ACTION_REMOVE),\n\t};\n\tu32 cmd_id = WIDE_ID(DATA_PATH_GROUP, RX_BAID_ALLOCATION_CONFIG_CMD);\n\tint ret;\n\n\tBUILD_BUG_ON(sizeof(struct iwl_rx_baid_cfg_resp) != sizeof(baid));\n\n\tif (start) {\n\t\tcmd.alloc.sta_id_mask =\n\t\t\tcpu_to_le32(iwl_mvm_sta_fw_id_mask(mvm, sta, -1));\n\t\tcmd.alloc.tid = tid;\n\t\tcmd.alloc.ssn = cpu_to_le16(ssn);\n\t\tcmd.alloc.win_size = cpu_to_le16(buf_size);\n\t\tbaid = -EIO;\n\t} else if (iwl_fw_lookup_cmd_ver(mvm->fw, cmd_id, 1) == 1) {\n\t\tcmd.remove_v1.baid = cpu_to_le32(baid);\n\t\tBUILD_BUG_ON(sizeof(cmd.remove_v1) > sizeof(cmd.remove));\n\t} else {\n\t\tcmd.remove.sta_id_mask =\n\t\t\tcpu_to_le32(iwl_mvm_sta_fw_id_mask(mvm, sta, -1));\n\t\tcmd.remove.tid = cpu_to_le32(tid);\n\t}\n\n\tret = iwl_mvm_send_cmd_pdu_status(mvm, cmd_id, sizeof(cmd),\n\t\t\t\t\t  &cmd, &baid);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!start) {\n\t\t \n\t\tbaid = 0;\n\t}\n\n\tIWL_DEBUG_HT(mvm, \"RX BA Session %sed in fw\\n\",\n\t\t     start ? \"start\" : \"stopp\");\n\n\tif (baid < 0 || baid >= ARRAY_SIZE(mvm->baid_map))\n\t\treturn -EINVAL;\n\n\treturn baid;\n}\n\nstatic int iwl_mvm_fw_baid_op(struct iwl_mvm *mvm, struct ieee80211_sta *sta,\n\t\t\t      bool start, int tid, u16 ssn, u16 buf_size,\n\t\t\t      int baid)\n{\n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_BAID_ML_SUPPORT))\n\t\treturn iwl_mvm_fw_baid_op_cmd(mvm, sta, start,\n\t\t\t\t\t      tid, ssn, buf_size, baid);\n\n\treturn iwl_mvm_fw_baid_op_sta(mvm, sta, start,\n\t\t\t\t      tid, ssn, buf_size);\n}\n\nint iwl_mvm_sta_rx_agg(struct iwl_mvm *mvm, struct ieee80211_sta *sta,\n\t\t       int tid, u16 ssn, bool start, u16 buf_size, u16 timeout)\n{\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_mvm_baid_data *baid_data = NULL;\n\tint ret, baid;\n\tu32 max_ba_id_sessions = iwl_mvm_has_new_tx_api(mvm) ? IWL_MAX_BAID :\n\t\t\t\t\t\t\t       IWL_MAX_BAID_OLD;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (start && mvm->rx_ba_sessions >= max_ba_id_sessions) {\n\t\tIWL_WARN(mvm, \"Not enough RX BA SESSIONS\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tif (iwl_mvm_has_new_rx_api(mvm) && start) {\n\t\tu32 reorder_buf_size = buf_size * sizeof(baid_data->entries[0]);\n\n\t\t \n#ifndef __CHECKER__\n\t\t \n\t\tBUILD_BUG_ON(SMP_CACHE_BYTES % sizeof(baid_data->entries[0]) &&\n\t\t\t     sizeof(baid_data->entries[0]) % SMP_CACHE_BYTES);\n#endif\n\n\t\t \n\t\treorder_buf_size = ALIGN(reorder_buf_size, SMP_CACHE_BYTES);\n\n\t\t \n\t\tbaid_data = kzalloc(sizeof(*baid_data) +\n\t\t\t\t    mvm->trans->num_rx_queues *\n\t\t\t\t    reorder_buf_size,\n\t\t\t\t    GFP_KERNEL);\n\t\tif (!baid_data)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tbaid_data->entries_per_queue =\n\t\t\treorder_buf_size / sizeof(baid_data->entries[0]);\n\t}\n\n\tif (iwl_mvm_has_new_rx_api(mvm) && !start) {\n\t\tbaid = mvm_sta->tid_to_baid[tid];\n\t} else {\n\t\t \n\t\tbaid = -1;\n\t}\n\n\t \n\tif (start || !test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status))\n\t\tbaid = iwl_mvm_fw_baid_op(mvm, sta, start, tid, ssn, buf_size,\n\t\t\t\t\t  baid);\n\n\tif (baid < 0) {\n\t\tret = baid;\n\t\tgoto out_free;\n\t}\n\n\tif (start) {\n\t\tmvm->rx_ba_sessions++;\n\n\t\tif (!iwl_mvm_has_new_rx_api(mvm))\n\t\t\treturn 0;\n\n\t\tbaid_data->baid = baid;\n\t\tbaid_data->timeout = timeout;\n\t\tbaid_data->last_rx = jiffies;\n\t\tbaid_data->rcu_ptr = &mvm->baid_map[baid];\n\t\ttimer_setup(&baid_data->session_timer,\n\t\t\t    iwl_mvm_rx_agg_session_expired, 0);\n\t\tbaid_data->mvm = mvm;\n\t\tbaid_data->tid = tid;\n\t\tbaid_data->sta_mask = iwl_mvm_sta_fw_id_mask(mvm, sta, -1);\n\n\t\tmvm_sta->tid_to_baid[tid] = baid;\n\t\tif (timeout)\n\t\t\tmod_timer(&baid_data->session_timer,\n\t\t\t\t  TU_TO_EXP_TIME(timeout * 2));\n\n\t\tiwl_mvm_init_reorder_buffer(mvm, baid_data, ssn, buf_size);\n\t\t \n\t\tIWL_DEBUG_HT(mvm, \"Sta %d(%d) is assigned to BAID %d\\n\",\n\t\t\t     mvm_sta->deflink.sta_id, tid, baid);\n\t\tWARN_ON(rcu_access_pointer(mvm->baid_map[baid]));\n\t\trcu_assign_pointer(mvm->baid_map[baid], baid_data);\n\t} else  {\n\t\tbaid = mvm_sta->tid_to_baid[tid];\n\n\t\tif (mvm->rx_ba_sessions > 0)\n\t\t\t \n\t\t\tmvm->rx_ba_sessions--;\n\t\tif (!iwl_mvm_has_new_rx_api(mvm))\n\t\t\treturn 0;\n\n\t\tif (WARN_ON(baid == IWL_RX_REORDER_DATA_INVALID_BAID))\n\t\t\treturn -EINVAL;\n\n\t\tbaid_data = rcu_access_pointer(mvm->baid_map[baid]);\n\t\tif (WARN_ON(!baid_data))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tiwl_mvm_free_reorder(mvm, baid_data);\n\t\ttimer_shutdown_sync(&baid_data->session_timer);\n\t\tRCU_INIT_POINTER(mvm->baid_map[baid], NULL);\n\t\tkfree_rcu(baid_data, rcu_head);\n\t\tIWL_DEBUG_HT(mvm, \"BAID %d is free\\n\", baid);\n\n\t\t \n\t\tiwl_mvm_sync_rx_queues_internal(mvm, IWL_MVM_RXQ_EMPTY,\n\t\t\t\t\t\ttrue, NULL, 0);\n\t}\n\treturn 0;\n\nout_free:\n\tkfree(baid_data);\n\treturn ret;\n}\n\nint iwl_mvm_sta_tx_agg(struct iwl_mvm *mvm, struct ieee80211_sta *sta,\n\t\t       int tid, u8 queue, bool start)\n{\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_mvm_add_sta_cmd cmd = {};\n\tint ret;\n\tu32 status;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (start) {\n\t\tmvm_sta->tfd_queue_msk |= BIT(queue);\n\t\tmvm_sta->tid_disable_agg &= ~BIT(tid);\n\t} else {\n\t\t \n\t\tmvm_sta->tid_disable_agg |= BIT(tid);\n\t}\n\n\tcmd.mac_id_n_color = cpu_to_le32(mvm_sta->mac_id_n_color);\n\tcmd.sta_id = mvm_sta->deflink.sta_id;\n\tcmd.add_modify = STA_MODE_MODIFY;\n\tif (!iwl_mvm_has_new_tx_api(mvm))\n\t\tcmd.modify_mask = STA_MODIFY_QUEUES;\n\tcmd.modify_mask |= STA_MODIFY_TID_DISABLE_TX;\n\tcmd.tfd_queue_msk = cpu_to_le32(mvm_sta->tfd_queue_msk);\n\tcmd.tid_disable_tx = cpu_to_le16(mvm_sta->tid_disable_agg);\n\n\tstatus = ADD_STA_SUCCESS;\n\tret = iwl_mvm_send_cmd_pdu_status(mvm, ADD_STA,\n\t\t\t\t\t  iwl_mvm_add_sta_cmd_size(mvm),\n\t\t\t\t\t  &cmd, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (status & IWL_ADD_STA_STATUS_MASK) {\n\tcase ADD_STA_SUCCESS:\n\t\tbreak;\n\tdefault:\n\t\tret = -EIO;\n\t\tIWL_ERR(mvm, \"TX BA Session failed %sing, status 0x%x\\n\",\n\t\t\tstart ? \"start\" : \"stopp\", status);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nconst u8 tid_to_mac80211_ac[] = {\n\tIEEE80211_AC_BE,\n\tIEEE80211_AC_BK,\n\tIEEE80211_AC_BK,\n\tIEEE80211_AC_BE,\n\tIEEE80211_AC_VI,\n\tIEEE80211_AC_VI,\n\tIEEE80211_AC_VO,\n\tIEEE80211_AC_VO,\n\tIEEE80211_AC_VO,  \n};\n\nstatic const u8 tid_to_ucode_ac[] = {\n\tAC_BE,\n\tAC_BK,\n\tAC_BK,\n\tAC_BE,\n\tAC_VI,\n\tAC_VI,\n\tAC_VO,\n\tAC_VO,\n};\n\nint iwl_mvm_sta_tx_agg_start(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_sta *sta, u16 tid, u16 *ssn)\n{\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_mvm_tid_data *tid_data;\n\tu16 normalized_ssn;\n\tu16 txq_id;\n\tint ret;\n\n\tif (WARN_ON_ONCE(tid >= IWL_MAX_TID_COUNT))\n\t\treturn -EINVAL;\n\n\tif (mvmsta->tid_data[tid].state != IWL_AGG_QUEUED &&\n\t    mvmsta->tid_data[tid].state != IWL_AGG_OFF) {\n\t\tIWL_ERR(mvm,\n\t\t\t\"Start AGG when state is not IWL_AGG_QUEUED or IWL_AGG_OFF %d!\\n\",\n\t\t\tmvmsta->tid_data[tid].state);\n\t\treturn -ENXIO;\n\t}\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (mvmsta->tid_data[tid].txq_id == IWL_MVM_INVALID_QUEUE &&\n\t    iwl_mvm_has_new_tx_api(mvm)) {\n\t\tu8 ac = tid_to_mac80211_ac[tid];\n\n\t\tret = iwl_mvm_sta_alloc_queue_tvqm(mvm, sta, ac, tid);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tspin_lock_bh(&mvmsta->lock);\n\n\t \n\ttxq_id = mvmsta->tid_data[tid].txq_id;\n\tif (txq_id == IWL_MVM_INVALID_QUEUE) {\n\t\tret = iwl_mvm_find_free_queue(mvm, mvmsta->deflink.sta_id,\n\t\t\t\t\t      IWL_MVM_DQA_MIN_DATA_QUEUE,\n\t\t\t\t\t      IWL_MVM_DQA_MAX_DATA_QUEUE);\n\t\tif (ret < 0) {\n\t\t\tIWL_ERR(mvm, \"Failed to allocate agg queue\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\ttxq_id = ret;\n\n\t\t \n\t\tmvm->queue_info[txq_id].status = IWL_MVM_QUEUE_RESERVED;\n\t} else if (WARN_ON(txq_id >= IWL_MAX_HW_QUEUES)) {\n\t\tret = -ENXIO;\n\t\tIWL_ERR(mvm, \"tid_id %d out of range (0, %d)!\\n\",\n\t\t\ttid, IWL_MAX_HW_QUEUES - 1);\n\t\tgoto out;\n\n\t} else if (unlikely(mvm->queue_info[txq_id].status ==\n\t\t\t    IWL_MVM_QUEUE_SHARED)) {\n\t\tret = -ENXIO;\n\t\tIWL_DEBUG_TX_QUEUES(mvm,\n\t\t\t\t    \"Can't start tid %d agg on shared queue!\\n\",\n\t\t\t\t    tid);\n\t\tgoto out;\n\t}\n\n\tIWL_DEBUG_TX_QUEUES(mvm,\n\t\t\t    \"AGG for tid %d will be on queue #%d\\n\",\n\t\t\t    tid, txq_id);\n\n\ttid_data = &mvmsta->tid_data[tid];\n\ttid_data->ssn = IEEE80211_SEQ_TO_SN(tid_data->seq_number);\n\ttid_data->txq_id = txq_id;\n\t*ssn = tid_data->ssn;\n\n\tIWL_DEBUG_TX_QUEUES(mvm,\n\t\t\t    \"Start AGG: sta %d tid %d queue %d - ssn = %d, next_recl = %d\\n\",\n\t\t\t    mvmsta->deflink.sta_id, tid, txq_id,\n\t\t\t    tid_data->ssn,\n\t\t\t    tid_data->next_reclaimed);\n\n\t \n\tnormalized_ssn = tid_data->ssn;\n\tif (mvm->trans->trans_cfg->gen2)\n\t\tnormalized_ssn &= 0xff;\n\n\tif (normalized_ssn == tid_data->next_reclaimed) {\n\t\ttid_data->state = IWL_AGG_STARTING;\n\t\tret = IEEE80211_AMPDU_TX_START_IMMEDIATE;\n\t} else {\n\t\ttid_data->state = IWL_EMPTYING_HW_QUEUE_ADDBA;\n\t\tret = IEEE80211_AMPDU_TX_START_DELAY_ADDBA;\n\t}\n\nout:\n\tspin_unlock_bh(&mvmsta->lock);\n\n\treturn ret;\n}\n\nint iwl_mvm_sta_tx_agg_oper(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_sta *sta, u16 tid, u16 buf_size,\n\t\t\t    bool amsdu)\n{\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_mvm_tid_data *tid_data = &mvmsta->tid_data[tid];\n\tunsigned int wdg_timeout =\n\t\tiwl_mvm_get_wd_timeout(mvm, vif, sta->tdls, false);\n\tint queue, ret;\n\tbool alloc_queue = true;\n\tenum iwl_mvm_queue_status queue_status;\n\tu16 ssn;\n\n\tstruct iwl_trans_txq_scd_cfg cfg = {\n\t\t.sta_id = mvmsta->deflink.sta_id,\n\t\t.tid = tid,\n\t\t.frame_limit = buf_size,\n\t\t.aggregate = true,\n\t};\n\n\t \n\tif (WARN_ON_ONCE(iwl_mvm_has_tlc_offload(mvm)))\n\t\treturn -EINVAL;\n\n\tBUILD_BUG_ON((sizeof(mvmsta->agg_tids) * BITS_PER_BYTE)\n\t\t     != IWL_MAX_TID_COUNT);\n\n\tspin_lock_bh(&mvmsta->lock);\n\tssn = tid_data->ssn;\n\tqueue = tid_data->txq_id;\n\ttid_data->state = IWL_AGG_ON;\n\tmvmsta->agg_tids |= BIT(tid);\n\ttid_data->ssn = 0xffff;\n\ttid_data->amsdu_in_ampdu_allowed = amsdu;\n\tspin_unlock_bh(&mvmsta->lock);\n\n\tif (iwl_mvm_has_new_tx_api(mvm)) {\n\t\t \n\t\tif (buf_size < IWL_FRAME_LIMIT)\n\t\t\treturn -ENOTSUPP;\n\n\t\tret = iwl_mvm_sta_tx_agg(mvm, sta, tid, queue, true);\n\t\tif (ret)\n\t\t\treturn -EIO;\n\t\tgoto out;\n\t}\n\n\tcfg.fifo = iwl_mvm_ac_to_tx_fifo[tid_to_mac80211_ac[tid]];\n\n\tqueue_status = mvm->queue_info[queue].status;\n\n\t \n\tif (mvm->queue_info[queue].status == IWL_MVM_QUEUE_READY)\n\t\talloc_queue = false;\n\n\t \n\tif (!alloc_queue && buf_size < IWL_FRAME_LIMIT) {\n\t\t \n\t\tret = iwl_trans_wait_tx_queues_empty(mvm->trans,\n\t\t\t\t\t\t     BIT(queue));\n\t\tif (ret) {\n\t\t\tIWL_ERR(mvm,\n\t\t\t\t\"Error draining queue before reconfig\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = iwl_mvm_reconfig_scd(mvm, queue, cfg.fifo,\n\t\t\t\t\t   mvmsta->deflink.sta_id, tid,\n\t\t\t\t\t   buf_size, ssn);\n\t\tif (ret) {\n\t\t\tIWL_ERR(mvm,\n\t\t\t\t\"Error reconfiguring TXQ #%d\\n\", queue);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (alloc_queue)\n\t\tiwl_mvm_enable_txq(mvm, sta, queue, ssn,\n\t\t\t\t   &cfg, wdg_timeout);\n\n\t \n\tif (queue_status != IWL_MVM_QUEUE_SHARED) {\n\t\tret = iwl_mvm_sta_tx_agg(mvm, sta, tid, queue, true);\n\t\tif (ret)\n\t\t\treturn -EIO;\n\t}\n\n\t \n\tmvm->queue_info[queue].status = IWL_MVM_QUEUE_READY;\n\nout:\n\t \n\tmvmsta->deflink.lq_sta.rs_drv.pers.max_agg_bufsize =\n\t\tmin(mvmsta->deflink.lq_sta.rs_drv.pers.max_agg_bufsize,\n\t\t    buf_size);\n\tmvmsta->deflink.lq_sta.rs_drv.lq.agg_frame_cnt_limit =\n\t\tmvmsta->deflink.lq_sta.rs_drv.pers.max_agg_bufsize;\n\n\tIWL_DEBUG_HT(mvm, \"Tx aggregation enabled on ra = %pM tid = %d\\n\",\n\t\t     sta->addr, tid);\n\n\treturn iwl_mvm_send_lq_cmd(mvm, &mvmsta->deflink.lq_sta.rs_drv.lq);\n}\n\nstatic void iwl_mvm_unreserve_agg_queue(struct iwl_mvm *mvm,\n\t\t\t\t\tstruct iwl_mvm_sta *mvmsta,\n\t\t\t\t\tstruct iwl_mvm_tid_data *tid_data)\n{\n\tu16 txq_id = tid_data->txq_id;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (iwl_mvm_has_new_tx_api(mvm))\n\t\treturn;\n\n\t \n\tif (mvm->queue_info[txq_id].status == IWL_MVM_QUEUE_RESERVED) {\n\t\tmvm->queue_info[txq_id].status = IWL_MVM_QUEUE_FREE;\n\t\ttid_data->txq_id = IWL_MVM_INVALID_QUEUE;\n\t}\n}\n\nint iwl_mvm_sta_tx_agg_stop(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_sta *sta, u16 tid)\n{\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_mvm_tid_data *tid_data = &mvmsta->tid_data[tid];\n\tu16 txq_id;\n\tint err;\n\n\t \n\tif (test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status)) {\n\t\tieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\t\treturn 0;\n\t}\n\n\tspin_lock_bh(&mvmsta->lock);\n\n\ttxq_id = tid_data->txq_id;\n\n\tIWL_DEBUG_TX_QUEUES(mvm, \"Stop AGG: sta %d tid %d q %d state %d\\n\",\n\t\t\t    mvmsta->deflink.sta_id, tid, txq_id,\n\t\t\t    tid_data->state);\n\n\tmvmsta->agg_tids &= ~BIT(tid);\n\n\tiwl_mvm_unreserve_agg_queue(mvm, mvmsta, tid_data);\n\n\tswitch (tid_data->state) {\n\tcase IWL_AGG_ON:\n\t\ttid_data->ssn = IEEE80211_SEQ_TO_SN(tid_data->seq_number);\n\n\t\tIWL_DEBUG_TX_QUEUES(mvm,\n\t\t\t\t    \"ssn = %d, next_recl = %d\\n\",\n\t\t\t\t    tid_data->ssn, tid_data->next_reclaimed);\n\n\t\ttid_data->ssn = 0xffff;\n\t\ttid_data->state = IWL_AGG_OFF;\n\t\tspin_unlock_bh(&mvmsta->lock);\n\n\t\tieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\n\t\tiwl_mvm_sta_tx_agg(mvm, sta, tid, txq_id, false);\n\t\treturn 0;\n\tcase IWL_AGG_STARTING:\n\tcase IWL_EMPTYING_HW_QUEUE_ADDBA:\n\t\t \n\n\t\t \n\t\tlockdep_assert_held(&mvm->mutex);\n\n\t\tieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\t\ttid_data->state = IWL_AGG_OFF;\n\t\terr = 0;\n\t\tbreak;\n\tdefault:\n\t\tIWL_ERR(mvm,\n\t\t\t\"Stopping AGG while state not ON or starting for %d on %d (%d)\\n\",\n\t\t\tmvmsta->deflink.sta_id, tid, tid_data->state);\n\t\tIWL_ERR(mvm,\n\t\t\t\"\\ttid_data->txq_id = %d\\n\", tid_data->txq_id);\n\t\terr = -EINVAL;\n\t}\n\n\tspin_unlock_bh(&mvmsta->lock);\n\n\treturn err;\n}\n\nint iwl_mvm_sta_tx_agg_flush(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_sta *sta, u16 tid)\n{\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_mvm_tid_data *tid_data = &mvmsta->tid_data[tid];\n\tu16 txq_id;\n\tenum iwl_mvm_agg_state old_state;\n\n\t \n\tspin_lock_bh(&mvmsta->lock);\n\ttxq_id = tid_data->txq_id;\n\tIWL_DEBUG_TX_QUEUES(mvm, \"Flush AGG: sta %d tid %d q %d state %d\\n\",\n\t\t\t    mvmsta->deflink.sta_id, tid, txq_id,\n\t\t\t    tid_data->state);\n\told_state = tid_data->state;\n\ttid_data->state = IWL_AGG_OFF;\n\tmvmsta->agg_tids &= ~BIT(tid);\n\tspin_unlock_bh(&mvmsta->lock);\n\n\tiwl_mvm_unreserve_agg_queue(mvm, mvmsta, tid_data);\n\n\tif (old_state >= IWL_AGG_ON) {\n\t\tiwl_mvm_drain_sta(mvm, mvmsta, true);\n\n\t\tif (iwl_mvm_has_new_tx_api(mvm)) {\n\t\t\tif (iwl_mvm_flush_sta_tids(mvm, mvmsta->deflink.sta_id,\n\t\t\t\t\t\t   BIT(tid)))\n\t\t\t\tIWL_ERR(mvm, \"Couldn't flush the AGG queue\\n\");\n\t\t\tiwl_trans_wait_txq_empty(mvm->trans, txq_id);\n\t\t} else {\n\t\t\tif (iwl_mvm_flush_tx_path(mvm, BIT(txq_id)))\n\t\t\t\tIWL_ERR(mvm, \"Couldn't flush the AGG queue\\n\");\n\t\t\tiwl_trans_wait_tx_queues_empty(mvm->trans, BIT(txq_id));\n\t\t}\n\n\t\tiwl_mvm_drain_sta(mvm, mvmsta, false);\n\n\t\tiwl_mvm_sta_tx_agg(mvm, sta, tid, txq_id, false);\n\t}\n\n\treturn 0;\n}\n\nstatic int iwl_mvm_set_fw_key_idx(struct iwl_mvm *mvm)\n{\n\tint i, max = -1, max_offs = -1;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\t \n\tfor (i = 0; i < STA_KEY_MAX_NUM; i++) {\n\t\tif (test_bit(i, mvm->fw_key_table))\n\t\t\tcontinue;\n\t\tif (mvm->fw_key_deleted[i] > max) {\n\t\t\tmax = mvm->fw_key_deleted[i];\n\t\t\tmax_offs = i;\n\t\t}\n\t}\n\n\tif (max_offs < 0)\n\t\treturn STA_KEY_IDX_INVALID;\n\n\treturn max_offs;\n}\n\nstatic struct iwl_mvm_sta *iwl_mvm_get_key_sta(struct iwl_mvm *mvm,\n\t\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t\t       struct ieee80211_sta *sta)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tif (sta)\n\t\treturn iwl_mvm_sta_from_mac80211(sta);\n\n\t \n\tif (vif->type == NL80211_IFTYPE_STATION &&\n\t    mvmvif->deflink.ap_sta_id != IWL_MVM_INVALID_STA) {\n\t\tu8 sta_id = mvmvif->deflink.ap_sta_id;\n\n\t\tsta = rcu_dereference_check(mvm->fw_id_to_mac_id[sta_id],\n\t\t\t\t\t    lockdep_is_held(&mvm->mutex));\n\n\t\t \n\t\tif (IS_ERR_OR_NULL(sta))\n\t\t\treturn NULL;\n\n\t\treturn iwl_mvm_sta_from_mac80211(sta);\n\t}\n\n\treturn NULL;\n}\n\nstatic int iwl_mvm_pn_cmp(const u8 *pn1, const u8 *pn2, int len)\n{\n\tint i;\n\n\tfor (i = len - 1; i >= 0; i--) {\n\t\tif (pn1[i] > pn2[i])\n\t\t\treturn 1;\n\t\tif (pn1[i] < pn2[i])\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int iwl_mvm_send_sta_key(struct iwl_mvm *mvm,\n\t\t\t\tu32 sta_id,\n\t\t\t\tstruct ieee80211_key_conf *key, bool mcast,\n\t\t\t\tu32 tkip_iv32, u16 *tkip_p1k, u32 cmd_flags,\n\t\t\t\tu8 key_offset, bool mfp)\n{\n\tunion {\n\t\tstruct iwl_mvm_add_sta_key_cmd_v1 cmd_v1;\n\t\tstruct iwl_mvm_add_sta_key_cmd cmd;\n\t} u = {};\n\t__le16 key_flags;\n\tint ret;\n\tu32 status;\n\tu16 keyidx;\n\tu64 pn = 0;\n\tint i, size;\n\tbool new_api = fw_has_api(&mvm->fw->ucode_capa,\n\t\t\t\t  IWL_UCODE_TLV_API_TKIP_MIC_KEYS);\n\tint api_ver = iwl_fw_lookup_cmd_ver(mvm->fw, ADD_STA_KEY,\n\t\t\t\t\t    new_api ? 2 : 1);\n\n\tif (sta_id == IWL_MVM_INVALID_STA)\n\t\treturn -EINVAL;\n\n\tkeyidx = (key->keyidx << STA_KEY_FLG_KEYID_POS) &\n\t\t STA_KEY_FLG_KEYID_MSK;\n\tkey_flags = cpu_to_le16(keyidx);\n\tkey_flags |= cpu_to_le16(STA_KEY_FLG_WEP_KEY_MAP);\n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tkey_flags |= cpu_to_le16(STA_KEY_FLG_TKIP);\n\t\tif (api_ver >= 2) {\n\t\t\tmemcpy((void *)&u.cmd.tx_mic_key,\n\t\t\t       &key->key[NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY],\n\t\t\t       IWL_MIC_KEY_SIZE);\n\n\t\t\tmemcpy((void *)&u.cmd.rx_mic_key,\n\t\t\t       &key->key[NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY],\n\t\t\t       IWL_MIC_KEY_SIZE);\n\t\t\tpn = atomic64_read(&key->tx_pn);\n\n\t\t} else {\n\t\t\tu.cmd_v1.tkip_rx_tsc_byte2 = tkip_iv32;\n\t\t\tfor (i = 0; i < 5; i++)\n\t\t\t\tu.cmd_v1.tkip_rx_ttak[i] =\n\t\t\t\t\tcpu_to_le16(tkip_p1k[i]);\n\t\t}\n\t\tmemcpy(u.cmd.common.key, key->key, key->keylen);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tkey_flags |= cpu_to_le16(STA_KEY_FLG_CCM);\n\t\tmemcpy(u.cmd.common.key, key->key, key->keylen);\n\t\tif (api_ver >= 2)\n\t\t\tpn = atomic64_read(&key->tx_pn);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tkey_flags |= cpu_to_le16(STA_KEY_FLG_WEP_13BYTES);\n\t\tfallthrough;\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tkey_flags |= cpu_to_le16(STA_KEY_FLG_WEP);\n\t\tmemcpy(u.cmd.common.key + 3, key->key, key->keylen);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\tkey_flags |= cpu_to_le16(STA_KEY_FLG_KEY_32BYTES);\n\t\tfallthrough;\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\t\tkey_flags |= cpu_to_le16(STA_KEY_FLG_GCMP);\n\t\tmemcpy(u.cmd.common.key, key->key, key->keylen);\n\t\tif (api_ver >= 2)\n\t\t\tpn = atomic64_read(&key->tx_pn);\n\t\tbreak;\n\tdefault:\n\t\tkey_flags |= cpu_to_le16(STA_KEY_FLG_EXT);\n\t\tmemcpy(u.cmd.common.key, key->key, key->keylen);\n\t}\n\n\tif (mcast)\n\t\tkey_flags |= cpu_to_le16(STA_KEY_MULTICAST);\n\tif (mfp)\n\t\tkey_flags |= cpu_to_le16(STA_KEY_MFP);\n\n\tu.cmd.common.key_offset = key_offset;\n\tu.cmd.common.key_flags = key_flags;\n\tu.cmd.common.sta_id = sta_id;\n\n\tif (key->cipher == WLAN_CIPHER_SUITE_TKIP)\n\t\ti = 0;\n\telse\n\t\ti = -1;\n\n\tfor (; i < IEEE80211_NUM_TIDS; i++) {\n\t\tstruct ieee80211_key_seq seq = {};\n\t\tu8 _rx_pn[IEEE80211_MAX_PN_LEN] = {}, *rx_pn = _rx_pn;\n\t\tint rx_pn_len = 8;\n\t\t \n\t\tint hole = api_ver >= 3 ? 0 : 2;\n\n\t\tieee80211_get_key_rx_seq(key, i, &seq);\n\n\t\tif (key->cipher == WLAN_CIPHER_SUITE_TKIP) {\n\t\t\trx_pn[0] = seq.tkip.iv16;\n\t\t\trx_pn[1] = seq.tkip.iv16 >> 8;\n\t\t\trx_pn[2 + hole] = seq.tkip.iv32;\n\t\t\trx_pn[3 + hole] = seq.tkip.iv32 >> 8;\n\t\t\trx_pn[4 + hole] = seq.tkip.iv32 >> 16;\n\t\t\trx_pn[5 + hole] = seq.tkip.iv32 >> 24;\n\t\t} else if (key_flags & cpu_to_le16(STA_KEY_FLG_EXT)) {\n\t\t\trx_pn = seq.hw.seq;\n\t\t\trx_pn_len = seq.hw.seq_len;\n\t\t} else {\n\t\t\trx_pn[0] = seq.ccmp.pn[0];\n\t\t\trx_pn[1] = seq.ccmp.pn[1];\n\t\t\trx_pn[2 + hole] = seq.ccmp.pn[2];\n\t\t\trx_pn[3 + hole] = seq.ccmp.pn[3];\n\t\t\trx_pn[4 + hole] = seq.ccmp.pn[4];\n\t\t\trx_pn[5 + hole] = seq.ccmp.pn[5];\n\t\t}\n\n\t\tif (iwl_mvm_pn_cmp(rx_pn, (u8 *)&u.cmd.common.rx_secur_seq_cnt,\n\t\t\t\t   rx_pn_len) > 0)\n\t\t\tmemcpy(&u.cmd.common.rx_secur_seq_cnt, rx_pn,\n\t\t\t       rx_pn_len);\n\t}\n\n\tif (api_ver >= 2) {\n\t\tu.cmd.transmit_seq_cnt = cpu_to_le64(pn);\n\t\tsize = sizeof(u.cmd);\n\t} else {\n\t\tsize = sizeof(u.cmd_v1);\n\t}\n\n\tstatus = ADD_STA_SUCCESS;\n\tif (cmd_flags & CMD_ASYNC)\n\t\tret = iwl_mvm_send_cmd_pdu(mvm, ADD_STA_KEY, CMD_ASYNC, size,\n\t\t\t\t\t   &u.cmd);\n\telse\n\t\tret = iwl_mvm_send_cmd_pdu_status(mvm, ADD_STA_KEY, size,\n\t\t\t\t\t\t  &u.cmd, &status);\n\n\tswitch (status) {\n\tcase ADD_STA_SUCCESS:\n\t\tIWL_DEBUG_WEP(mvm, \"MODIFY_STA: set dynamic key passed\\n\");\n\t\tbreak;\n\tdefault:\n\t\tret = -EIO;\n\t\tIWL_ERR(mvm, \"MODIFY_STA: set dynamic key failed\\n\");\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int iwl_mvm_send_sta_igtk(struct iwl_mvm *mvm,\n\t\t\t\t struct ieee80211_key_conf *keyconf,\n\t\t\t\t u8 sta_id, bool remove_key)\n{\n\tstruct iwl_mvm_mgmt_mcast_key_cmd igtk_cmd = {};\n\n\t \n\tif (WARN_ON((keyconf->flags & IEEE80211_KEY_FLAG_PAIRWISE) ||\n\t\t    (keyconf->keyidx != 4 && keyconf->keyidx != 5 &&\n\t\t     keyconf->keyidx != 6 && keyconf->keyidx != 7) ||\n\t\t    (keyconf->cipher != WLAN_CIPHER_SUITE_AES_CMAC &&\n\t\t     keyconf->cipher != WLAN_CIPHER_SUITE_BIP_GMAC_128 &&\n\t\t     keyconf->cipher != WLAN_CIPHER_SUITE_BIP_GMAC_256)))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(!iwl_mvm_has_new_rx_api(mvm) &&\n\t\t    keyconf->cipher != WLAN_CIPHER_SUITE_AES_CMAC))\n\t\treturn -EINVAL;\n\n\tigtk_cmd.key_id = cpu_to_le32(keyconf->keyidx);\n\tigtk_cmd.sta_id = cpu_to_le32(sta_id);\n\n\tif (remove_key) {\n\t\t \n\t\tif (sta_id == IWL_MVM_INVALID_STA)\n\t\t\treturn 0;\n\n\t\tigtk_cmd.ctrl_flags |= cpu_to_le32(STA_KEY_NOT_VALID);\n\t} else {\n\t\tstruct ieee80211_key_seq seq;\n\t\tconst u8 *pn;\n\n\t\tswitch (keyconf->cipher) {\n\t\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\t\tigtk_cmd.ctrl_flags |= cpu_to_le32(STA_KEY_FLG_CCM);\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\t\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\t\t\tigtk_cmd.ctrl_flags |= cpu_to_le32(STA_KEY_FLG_GCMP);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemcpy(igtk_cmd.igtk, keyconf->key, keyconf->keylen);\n\t\tif (keyconf->cipher == WLAN_CIPHER_SUITE_BIP_GMAC_256)\n\t\t\tigtk_cmd.ctrl_flags |=\n\t\t\t\tcpu_to_le32(STA_KEY_FLG_KEY_32BYTES);\n\t\tieee80211_get_key_rx_seq(keyconf, 0, &seq);\n\t\tpn = seq.aes_cmac.pn;\n\t\tigtk_cmd.receive_seq_cnt = cpu_to_le64(((u64) pn[5] << 0) |\n\t\t\t\t\t\t       ((u64) pn[4] << 8) |\n\t\t\t\t\t\t       ((u64) pn[3] << 16) |\n\t\t\t\t\t\t       ((u64) pn[2] << 24) |\n\t\t\t\t\t\t       ((u64) pn[1] << 32) |\n\t\t\t\t\t\t       ((u64) pn[0] << 40));\n\t}\n\n\tIWL_DEBUG_INFO(mvm, \"%s %sIGTK (%d) for sta %u\\n\",\n\t\t       remove_key ? \"removing\" : \"installing\",\n\t\t       keyconf->keyidx >= 6 ? \"B\" : \"\",\n\t\t       keyconf->keyidx, igtk_cmd.sta_id);\n\n\tif (!iwl_mvm_has_new_rx_api(mvm)) {\n\t\tstruct iwl_mvm_mgmt_mcast_key_cmd_v1 igtk_cmd_v1 = {\n\t\t\t.ctrl_flags = igtk_cmd.ctrl_flags,\n\t\t\t.key_id = igtk_cmd.key_id,\n\t\t\t.sta_id = igtk_cmd.sta_id,\n\t\t\t.receive_seq_cnt = igtk_cmd.receive_seq_cnt\n\t\t};\n\n\t\tmemcpy(igtk_cmd_v1.igtk, igtk_cmd.igtk,\n\t\t       ARRAY_SIZE(igtk_cmd_v1.igtk));\n\t\treturn iwl_mvm_send_cmd_pdu(mvm, MGMT_MCAST_KEY, 0,\n\t\t\t\t\t    sizeof(igtk_cmd_v1), &igtk_cmd_v1);\n\t}\n\treturn iwl_mvm_send_cmd_pdu(mvm, MGMT_MCAST_KEY, 0,\n\t\t\t\t    sizeof(igtk_cmd), &igtk_cmd);\n}\n\n\nstatic inline u8 *iwl_mvm_get_mac_addr(struct iwl_mvm *mvm,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_sta *sta)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tif (sta)\n\t\treturn sta->addr;\n\n\tif (vif->type == NL80211_IFTYPE_STATION &&\n\t    mvmvif->deflink.ap_sta_id != IWL_MVM_INVALID_STA) {\n\t\tu8 sta_id = mvmvif->deflink.ap_sta_id;\n\t\tsta = rcu_dereference_protected(mvm->fw_id_to_mac_id[sta_id],\n\t\t\t\t\t\tlockdep_is_held(&mvm->mutex));\n\t\tif (WARN_ON_ONCE(IS_ERR_OR_NULL(sta)))\n\t\t\treturn NULL;\n\n\t\treturn sta->addr;\n\t}\n\n\n\treturn NULL;\n}\n\nstatic int __iwl_mvm_set_sta_key(struct iwl_mvm *mvm,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t struct ieee80211_key_conf *keyconf,\n\t\t\t\t u8 key_offset,\n\t\t\t\t bool mcast)\n{\n\tconst u8 *addr;\n\tstruct ieee80211_key_seq seq;\n\tu16 p1k[5];\n\tu32 sta_id;\n\tbool mfp = false;\n\n\tif (sta) {\n\t\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\n\t\tsta_id = mvm_sta->deflink.sta_id;\n\t\tmfp = sta->mfp;\n\t} else if (vif->type == NL80211_IFTYPE_AP &&\n\t\t   !(keyconf->flags & IEEE80211_KEY_FLAG_PAIRWISE)) {\n\t\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\t\tsta_id = mvmvif->deflink.mcast_sta.sta_id;\n\t} else {\n\t\tIWL_ERR(mvm, \"Failed to find station id\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (keyconf->cipher == WLAN_CIPHER_SUITE_TKIP) {\n\t\taddr = iwl_mvm_get_mac_addr(mvm, vif, sta);\n\t\tif (!addr) {\n\t\t\tIWL_ERR(mvm, \"Failed to find mac address\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tieee80211_get_key_rx_seq(keyconf, 0, &seq);\n\t\tieee80211_get_tkip_rx_p1k(keyconf, addr, seq.tkip.iv32, p1k);\n\n\t\treturn iwl_mvm_send_sta_key(mvm, sta_id, keyconf, mcast,\n\t\t\t\t\t    seq.tkip.iv32, p1k, 0, key_offset,\n\t\t\t\t\t    mfp);\n\t}\n\n\treturn iwl_mvm_send_sta_key(mvm, sta_id, keyconf, mcast,\n\t\t\t\t    0, NULL, 0, key_offset, mfp);\n}\n\nint iwl_mvm_set_sta_key(struct iwl_mvm *mvm,\n\t\t\tstruct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_sta *sta,\n\t\t\tstruct ieee80211_key_conf *keyconf,\n\t\t\tu8 key_offset)\n{\n\tbool mcast = !(keyconf->flags & IEEE80211_KEY_FLAG_PAIRWISE);\n\tstruct iwl_mvm_sta *mvm_sta;\n\tu8 sta_id = IWL_MVM_INVALID_STA;\n\tint ret;\n\tstatic const u8 __maybe_unused zero_addr[ETH_ALEN] = {0};\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (vif->type != NL80211_IFTYPE_AP ||\n\t    keyconf->flags & IEEE80211_KEY_FLAG_PAIRWISE) {\n\t\t \n\t\tmvm_sta = iwl_mvm_get_key_sta(mvm, vif, sta);\n\t\tif (!mvm_sta) {\n\t\t\tIWL_ERR(mvm, \"Failed to find station\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsta_id = mvm_sta->deflink.sta_id;\n\n\t\t \n\t\tif (!sta) {\n\t\t\tsta = rcu_dereference_protected(\n\t\t\t\tmvm->fw_id_to_mac_id[sta_id],\n\t\t\t\tlockdep_is_held(&mvm->mutex));\n\t\t\tif (IS_ERR_OR_NULL(sta)) {\n\t\t\t\tIWL_ERR(mvm, \"Invalid station id\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tif (WARN_ON_ONCE(iwl_mvm_sta_from_mac80211(sta)->vif != vif))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\t\tsta_id = mvmvif->deflink.mcast_sta.sta_id;\n\t}\n\n\tif (keyconf->cipher == WLAN_CIPHER_SUITE_AES_CMAC ||\n\t    keyconf->cipher == WLAN_CIPHER_SUITE_BIP_GMAC_128 ||\n\t    keyconf->cipher == WLAN_CIPHER_SUITE_BIP_GMAC_256) {\n\t\tret = iwl_mvm_send_sta_igtk(mvm, keyconf, sta_id, false);\n\t\tgoto end;\n\t}\n\n\t \n\tif (key_offset == STA_KEY_IDX_INVALID) {\n\t\tkey_offset  = iwl_mvm_set_fw_key_idx(mvm);\n\t\tif (key_offset == STA_KEY_IDX_INVALID)\n\t\t\treturn -ENOSPC;\n\t\tkeyconf->hw_key_idx = key_offset;\n\t}\n\n\tret = __iwl_mvm_set_sta_key(mvm, vif, sta, keyconf, key_offset, mcast);\n\tif (ret)\n\t\tgoto end;\n\n\t \n\tif ((keyconf->cipher == WLAN_CIPHER_SUITE_WEP40 ||\n\t     keyconf->cipher == WLAN_CIPHER_SUITE_WEP104) &&\n\t    sta) {\n\t\tret = __iwl_mvm_set_sta_key(mvm, vif, sta, keyconf,\n\t\t\t\t\t    key_offset, !mcast);\n\t\tif (ret) {\n\t\t\t__iwl_mvm_remove_sta_key(mvm, sta_id, keyconf, mcast);\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\t__set_bit(key_offset, mvm->fw_key_table);\n\nend:\n\tIWL_DEBUG_WEP(mvm, \"key: cipher=%x len=%d idx=%d sta=%pM ret=%d\\n\",\n\t\t      keyconf->cipher, keyconf->keylen, keyconf->keyidx,\n\t\t      sta ? sta->addr : zero_addr, ret);\n\treturn ret;\n}\n\nint iwl_mvm_remove_sta_key(struct iwl_mvm *mvm,\n\t\t\t   struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_sta *sta,\n\t\t\t   struct ieee80211_key_conf *keyconf)\n{\n\tbool mcast = !(keyconf->flags & IEEE80211_KEY_FLAG_PAIRWISE);\n\tstruct iwl_mvm_sta *mvm_sta;\n\tu8 sta_id = IWL_MVM_INVALID_STA;\n\tint ret, i;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\t \n\tmvm_sta = iwl_mvm_get_key_sta(mvm, vif, sta);\n\tif (mvm_sta)\n\t\tsta_id = mvm_sta->deflink.sta_id;\n\telse if (!sta && vif->type == NL80211_IFTYPE_AP && mcast)\n\t\tsta_id = iwl_mvm_vif_from_mac80211(vif)->deflink.mcast_sta.sta_id;\n\n\n\tIWL_DEBUG_WEP(mvm, \"mvm remove dynamic key: idx=%d sta=%d\\n\",\n\t\t      keyconf->keyidx, sta_id);\n\n\tif (keyconf->cipher == WLAN_CIPHER_SUITE_AES_CMAC ||\n\t    keyconf->cipher == WLAN_CIPHER_SUITE_BIP_GMAC_128 ||\n\t    keyconf->cipher == WLAN_CIPHER_SUITE_BIP_GMAC_256)\n\t\treturn iwl_mvm_send_sta_igtk(mvm, keyconf, sta_id, true);\n\n\tif (!__test_and_clear_bit(keyconf->hw_key_idx, mvm->fw_key_table)) {\n\t\tIWL_ERR(mvm, \"offset %d not used in fw key table.\\n\",\n\t\t\tkeyconf->hw_key_idx);\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tfor (i = 0; i < STA_KEY_MAX_NUM; i++) {\n\t\tif (mvm->fw_key_deleted[i] < U8_MAX)\n\t\t\tmvm->fw_key_deleted[i]++;\n\t}\n\tmvm->fw_key_deleted[keyconf->hw_key_idx] = 0;\n\n\tif (sta && !mvm_sta) {\n\t\tIWL_DEBUG_WEP(mvm, \"station non-existent, early return.\\n\");\n\t\treturn 0;\n\t}\n\n\tret = __iwl_mvm_remove_sta_key(mvm, sta_id, keyconf, mcast);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (keyconf->cipher == WLAN_CIPHER_SUITE_WEP40 ||\n\t    keyconf->cipher == WLAN_CIPHER_SUITE_WEP104)\n\t\tret = __iwl_mvm_remove_sta_key(mvm, sta_id, keyconf, !mcast);\n\n\treturn ret;\n}\n\nvoid iwl_mvm_update_tkip_key(struct iwl_mvm *mvm,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_key_conf *keyconf,\n\t\t\t     struct ieee80211_sta *sta, u32 iv32,\n\t\t\t     u16 *phase1key)\n{\n\tstruct iwl_mvm_sta *mvm_sta;\n\tbool mcast = !(keyconf->flags & IEEE80211_KEY_FLAG_PAIRWISE);\n\tbool mfp = sta ? sta->mfp : false;\n\n\trcu_read_lock();\n\n\tmvm_sta = iwl_mvm_get_key_sta(mvm, vif, sta);\n\tif (WARN_ON_ONCE(!mvm_sta))\n\t\tgoto unlock;\n\tiwl_mvm_send_sta_key(mvm, mvm_sta->deflink.sta_id, keyconf, mcast,\n\t\t\t     iv32, phase1key, CMD_ASYNC, keyconf->hw_key_idx,\n\t\t\t     mfp);\n\n unlock:\n\trcu_read_unlock();\n}\n\nvoid iwl_mvm_sta_modify_ps_wake(struct iwl_mvm *mvm,\n\t\t\t\tstruct ieee80211_sta *sta)\n{\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_mvm_add_sta_cmd cmd = {\n\t\t.add_modify = STA_MODE_MODIFY,\n\t\t.sta_id = mvmsta->deflink.sta_id,\n\t\t.station_flags_msk = cpu_to_le32(STA_FLG_PS),\n\t\t.mac_id_n_color = cpu_to_le32(mvmsta->mac_id_n_color),\n\t};\n\tint ret;\n\n\tret = iwl_mvm_send_cmd_pdu(mvm, ADD_STA, CMD_ASYNC,\n\t\t\t\t   iwl_mvm_add_sta_cmd_size(mvm), &cmd);\n\tif (ret)\n\t\tIWL_ERR(mvm, \"Failed to send ADD_STA command (%d)\\n\", ret);\n}\n\nvoid iwl_mvm_sta_modify_sleep_tx_count(struct iwl_mvm *mvm,\n\t\t\t\t       struct ieee80211_sta *sta,\n\t\t\t\t       enum ieee80211_frame_release_type reason,\n\t\t\t\t       u16 cnt, u16 tids, bool more_data,\n\t\t\t\t       bool single_sta_queue)\n{\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_mvm_add_sta_cmd cmd = {\n\t\t.add_modify = STA_MODE_MODIFY,\n\t\t.sta_id = mvmsta->deflink.sta_id,\n\t\t.modify_mask = STA_MODIFY_SLEEPING_STA_TX_COUNT,\n\t\t.sleep_tx_count = cpu_to_le16(cnt),\n\t\t.mac_id_n_color = cpu_to_le32(mvmsta->mac_id_n_color),\n\t};\n\tint tid, ret;\n\tunsigned long _tids = tids;\n\n\t \n\tfor_each_set_bit(tid, &_tids, IWL_MAX_TID_COUNT)\n\t\tcmd.awake_acs |= BIT(tid_to_ucode_ac[tid]);\n\n\t \n\tif (single_sta_queue) {\n\t\tint remaining = cnt;\n\t\tint sleep_tx_count;\n\n\t\tspin_lock_bh(&mvmsta->lock);\n\t\tfor_each_set_bit(tid, &_tids, IWL_MAX_TID_COUNT) {\n\t\t\tstruct iwl_mvm_tid_data *tid_data;\n\t\t\tu16 n_queued;\n\n\t\t\ttid_data = &mvmsta->tid_data[tid];\n\n\t\t\tn_queued = iwl_mvm_tid_queued(mvm, tid_data);\n\t\t\tif (n_queued > remaining) {\n\t\t\t\tmore_data = true;\n\t\t\t\tremaining = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tremaining -= n_queued;\n\t\t}\n\t\tsleep_tx_count = cnt - remaining;\n\t\tif (reason == IEEE80211_FRAME_RELEASE_UAPSD)\n\t\t\tmvmsta->sleep_tx_count = sleep_tx_count;\n\t\tspin_unlock_bh(&mvmsta->lock);\n\n\t\tcmd.sleep_tx_count = cpu_to_le16(sleep_tx_count);\n\t\tif (WARN_ON(cnt - remaining == 0)) {\n\t\t\tieee80211_sta_eosp(sta);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tif (more_data)\n\t\tcmd.sleep_state_flags |= STA_SLEEP_STATE_MOREDATA;\n\n\tif (reason == IEEE80211_FRAME_RELEASE_PSPOLL) {\n\t\tmvmsta->next_status_eosp = true;\n\t\tcmd.sleep_state_flags |= STA_SLEEP_STATE_PS_POLL;\n\t} else {\n\t\tcmd.sleep_state_flags |= STA_SLEEP_STATE_UAPSD;\n\t}\n\n\t \n\tiwl_trans_block_txq_ptrs(mvm->trans, true);\n\n\tret = iwl_mvm_send_cmd_pdu(mvm, ADD_STA,\n\t\t\t\t   CMD_ASYNC | CMD_WANT_ASYNC_CALLBACK,\n\t\t\t\t   iwl_mvm_add_sta_cmd_size(mvm), &cmd);\n\tif (ret)\n\t\tIWL_ERR(mvm, \"Failed to send ADD_STA command (%d)\\n\", ret);\n}\n\nvoid iwl_mvm_rx_eosp_notif(struct iwl_mvm *mvm,\n\t\t\t   struct iwl_rx_cmd_buffer *rxb)\n{\n\tstruct iwl_rx_packet *pkt = rxb_addr(rxb);\n\tstruct iwl_mvm_eosp_notification *notif = (void *)pkt->data;\n\tstruct ieee80211_sta *sta;\n\tu32 sta_id = le32_to_cpu(notif->sta_id);\n\n\tif (WARN_ON_ONCE(sta_id >= mvm->fw->ucode_capa.num_stations))\n\t\treturn;\n\n\trcu_read_lock();\n\tsta = rcu_dereference(mvm->fw_id_to_mac_id[sta_id]);\n\tif (!IS_ERR_OR_NULL(sta))\n\t\tieee80211_sta_eosp(sta);\n\trcu_read_unlock();\n}\n\nvoid iwl_mvm_sta_modify_disable_tx(struct iwl_mvm *mvm,\n\t\t\t\t   struct iwl_mvm_sta *mvmsta,\n\t\t\t\t   bool disable)\n{\n\tstruct iwl_mvm_add_sta_cmd cmd = {\n\t\t.add_modify = STA_MODE_MODIFY,\n\t\t.sta_id = mvmsta->deflink.sta_id,\n\t\t.station_flags = disable ? cpu_to_le32(STA_FLG_DISABLE_TX) : 0,\n\t\t.station_flags_msk = cpu_to_le32(STA_FLG_DISABLE_TX),\n\t\t.mac_id_n_color = cpu_to_le32(mvmsta->mac_id_n_color),\n\t};\n\tint ret;\n\n\tif (mvm->mld_api_is_used) {\n\t\tiwl_mvm_mld_sta_modify_disable_tx(mvm, mvmsta, disable);\n\t\treturn;\n\t}\n\n\tret = iwl_mvm_send_cmd_pdu(mvm, ADD_STA, CMD_ASYNC,\n\t\t\t\t   iwl_mvm_add_sta_cmd_size(mvm), &cmd);\n\tif (ret)\n\t\tIWL_ERR(mvm, \"Failed to send ADD_STA command (%d)\\n\", ret);\n}\n\nvoid iwl_mvm_sta_modify_disable_tx_ap(struct iwl_mvm *mvm,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      bool disable)\n{\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\n\tif (mvm->mld_api_is_used) {\n\t\tiwl_mvm_mld_sta_modify_disable_tx_ap(mvm, sta, disable);\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&mvm_sta->lock);\n\n\tif (mvm_sta->disable_tx == disable) {\n\t\tspin_unlock_bh(&mvm_sta->lock);\n\t\treturn;\n\t}\n\n\tmvm_sta->disable_tx = disable;\n\n\t \n\tif (!ieee80211_hw_check(mvm->hw, AP_LINK_PS))\n\t\tieee80211_sta_block_awake(mvm->hw, sta, disable);\n\n\tiwl_mvm_sta_modify_disable_tx(mvm, mvm_sta, disable);\n\n\tspin_unlock_bh(&mvm_sta->lock);\n}\n\nstatic void iwl_mvm_int_sta_modify_disable_tx(struct iwl_mvm *mvm,\n\t\t\t\t\t      struct iwl_mvm_vif *mvmvif,\n\t\t\t\t\t      struct iwl_mvm_int_sta *sta,\n\t\t\t\t\t      bool disable)\n{\n\tu32 id = FW_CMD_ID_AND_COLOR(mvmvif->id, mvmvif->color);\n\tstruct iwl_mvm_add_sta_cmd cmd = {\n\t\t.add_modify = STA_MODE_MODIFY,\n\t\t.sta_id = sta->sta_id,\n\t\t.station_flags = disable ? cpu_to_le32(STA_FLG_DISABLE_TX) : 0,\n\t\t.station_flags_msk = cpu_to_le32(STA_FLG_DISABLE_TX),\n\t\t.mac_id_n_color = cpu_to_le32(id),\n\t};\n\tint ret;\n\n\tret = iwl_mvm_send_cmd_pdu(mvm, ADD_STA, CMD_ASYNC,\n\t\t\t\t   iwl_mvm_add_sta_cmd_size(mvm), &cmd);\n\tif (ret)\n\t\tIWL_ERR(mvm, \"Failed to send ADD_STA command (%d)\\n\", ret);\n}\n\nvoid iwl_mvm_modify_all_sta_disable_tx(struct iwl_mvm *mvm,\n\t\t\t\t       struct iwl_mvm_vif *mvmvif,\n\t\t\t\t       bool disable)\n{\n\tstruct ieee80211_sta *sta;\n\tstruct iwl_mvm_sta *mvm_sta;\n\tint i;\n\n\tif (mvm->mld_api_is_used) {\n\t\tiwl_mvm_mld_modify_all_sta_disable_tx(mvm, mvmvif, disable);\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\n\t \n\tfor (i = 0; i < mvm->fw->ucode_capa.num_stations; i++) {\n\t\tsta = rcu_dereference(mvm->fw_id_to_mac_id[i]);\n\t\tif (IS_ERR_OR_NULL(sta))\n\t\t\tcontinue;\n\n\t\tmvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\t\tif (mvm_sta->mac_id_n_color !=\n\t\t    FW_CMD_ID_AND_COLOR(mvmvif->id, mvmvif->color))\n\t\t\tcontinue;\n\n\t\tiwl_mvm_sta_modify_disable_tx_ap(mvm, sta, disable);\n\t}\n\n\trcu_read_unlock();\n\n\tif (!fw_has_api(&mvm->fw->ucode_capa, IWL_UCODE_TLV_API_STA_TYPE))\n\t\treturn;\n\n\t \n\tif (mvmvif->deflink.mcast_sta.sta_id != IWL_MVM_INVALID_STA)\n\t\tiwl_mvm_int_sta_modify_disable_tx(mvm, mvmvif,\n\t\t\t\t\t\t  &mvmvif->deflink.mcast_sta,\n\t\t\t\t\t\t  disable);\n\n\t \n\tif (!disable && mvmvif->deflink.bcast_sta.sta_id != IWL_MVM_INVALID_STA)\n\t\tiwl_mvm_int_sta_modify_disable_tx(mvm, mvmvif,\n\t\t\t\t\t\t  &mvmvif->deflink.bcast_sta,\n\t\t\t\t\t\t  disable);\n}\n\nvoid iwl_mvm_csa_client_absent(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_sta *mvmsta;\n\n\trcu_read_lock();\n\n\tmvmsta = iwl_mvm_sta_from_staid_rcu(mvm, mvmvif->deflink.ap_sta_id);\n\n\tif (mvmsta)\n\t\tiwl_mvm_sta_modify_disable_tx(mvm, mvmsta, true);\n\n\trcu_read_unlock();\n}\n\nu16 iwl_mvm_tid_queued(struct iwl_mvm *mvm, struct iwl_mvm_tid_data *tid_data)\n{\n\tu16 sn = IEEE80211_SEQ_TO_SN(tid_data->seq_number);\n\n\t \n\tif (mvm->trans->trans_cfg->gen2)\n\t\tsn &= 0xff;\n\n\treturn ieee80211_sn_sub(sn, tid_data->next_reclaimed);\n}\n\nint iwl_mvm_add_pasn_sta(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t struct iwl_mvm_int_sta *sta, u8 *addr, u32 cipher,\n\t\t\t u8 *key, u32 key_len)\n{\n\tint ret;\n\tu16 queue;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct ieee80211_key_conf *keyconf;\n\tunsigned int wdg_timeout =\n\t\tiwl_mvm_get_wd_timeout(mvm, vif, false, false);\n\tbool mld = iwl_mvm_has_mld_api(mvm->fw);\n\tu32 type = mld ? STATION_TYPE_PEER : IWL_STA_LINK;\n\n\tret = iwl_mvm_allocate_int_sta(mvm, sta, 0,\n\t\t\t\t       NL80211_IFTYPE_UNSPECIFIED, type);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mld)\n\t\tret = iwl_mvm_mld_add_int_sta_with_queue(mvm, sta, addr,\n\t\t\t\t\t\t\t mvmvif->deflink.fw_link_id,\n\t\t\t\t\t\t\t &queue,\n\t\t\t\t\t\t\t IWL_MAX_TID_COUNT,\n\t\t\t\t\t\t\t &wdg_timeout);\n\telse\n\t\tret = iwl_mvm_add_int_sta_with_queue(mvm, mvmvif->id,\n\t\t\t\t\t\t     mvmvif->color, addr, sta,\n\t\t\t\t\t\t     &queue,\n\t\t\t\t\t\t     IWL_MVM_TX_FIFO_BE);\n\tif (ret)\n\t\tgoto out;\n\n\tkeyconf = kzalloc(sizeof(*keyconf) + key_len, GFP_KERNEL);\n\tif (!keyconf) {\n\t\tret = -ENOBUFS;\n\t\tgoto out;\n\t}\n\n\tkeyconf->cipher = cipher;\n\tmemcpy(keyconf->key, key, key_len);\n\tkeyconf->keylen = key_len;\n\tkeyconf->flags = IEEE80211_KEY_FLAG_PAIRWISE;\n\n\tif (mld) {\n\t\t \n\t\tu32 key_flags =\n\t\t\tiwl_mvm_get_sec_flags(mvm, vif, NULL, keyconf) |\n\t\t\tIWL_SEC_KEY_FLAG_MFP;\n\t\tu32 sta_mask = BIT(sta->sta_id);\n\n\t\tret = iwl_mvm_mld_send_key(mvm, sta_mask, key_flags, keyconf);\n\t} else {\n\t\tret = iwl_mvm_send_sta_key(mvm, sta->sta_id, keyconf, false,\n\t\t\t\t\t   0, NULL, 0, 0, true);\n\t}\n\n\tkfree(keyconf);\n\treturn 0;\nout:\n\tiwl_mvm_dealloc_int_sta(mvm, sta);\n\treturn ret;\n}\n\nvoid iwl_mvm_cancel_channel_switch(struct iwl_mvm *mvm,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   u32 id)\n{\n\tstruct iwl_cancel_channel_switch_cmd cancel_channel_switch_cmd = {\n\t\t.id = cpu_to_le32(id),\n\t};\n\tint ret;\n\n\tret = iwl_mvm_send_cmd_pdu(mvm,\n\t\t\t\t   WIDE_ID(MAC_CONF_GROUP, CANCEL_CHANNEL_SWITCH_CMD),\n\t\t\t\t   CMD_ASYNC,\n\t\t\t\t   sizeof(cancel_channel_switch_cmd),\n\t\t\t\t   &cancel_channel_switch_cmd);\n\tif (ret)\n\t\tIWL_ERR(mvm, \"Failed to cancel the channel switch\\n\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}