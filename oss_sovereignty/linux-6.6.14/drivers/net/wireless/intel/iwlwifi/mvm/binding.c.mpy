{
  "module_name": "binding.c",
  "hash_id": "cf5b36be49f38b5cff9442c1c177bae5846a9bb21db969f64be6d2df6c58c599",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/binding.c",
  "human_readable_source": "\n \n#include <net/mac80211.h>\n#include \"fw-api.h\"\n#include \"mvm.h\"\n\nstruct iwl_mvm_iface_iterator_data {\n\tstruct ieee80211_vif *ignore_vif;\n\tint idx;\n\n\tstruct iwl_mvm_phy_ctxt *phyctxt;\n\n\tu16 ids[MAX_MACS_IN_BINDING];\n\tu16 colors[MAX_MACS_IN_BINDING];\n};\n\nstatic int iwl_mvm_binding_cmd(struct iwl_mvm *mvm, u32 action,\n\t\t\t       struct iwl_mvm_iface_iterator_data *data)\n{\n\tstruct iwl_binding_cmd cmd;\n\tstruct iwl_mvm_phy_ctxt *phyctxt = data->phyctxt;\n\tint i, ret;\n\tu32 status;\n\tint size;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa,\n\t\t\tIWL_UCODE_TLV_CAPA_BINDING_CDB_SUPPORT)) {\n\t\tsize = sizeof(cmd);\n\t\tcmd.lmac_id = cpu_to_le32(iwl_mvm_get_lmac_id(mvm,\n\t\t\t\t\t\t\t      phyctxt->channel->band));\n\t} else {\n\t\tsize = IWL_BINDING_CMD_SIZE_V1;\n\t}\n\n\tcmd.id_and_color = cpu_to_le32(FW_CMD_ID_AND_COLOR(phyctxt->id,\n\t\t\t\t\t\t\t   phyctxt->color));\n\tcmd.action = cpu_to_le32(action);\n\tcmd.phy = cpu_to_le32(FW_CMD_ID_AND_COLOR(phyctxt->id,\n\t\t\t\t\t\t  phyctxt->color));\n\n\tfor (i = 0; i < MAX_MACS_IN_BINDING; i++)\n\t\tcmd.macs[i] = cpu_to_le32(FW_CTXT_INVALID);\n\tfor (i = 0; i < data->idx; i++)\n\t\tcmd.macs[i] = cpu_to_le32(FW_CMD_ID_AND_COLOR(data->ids[i],\n\t\t\t\t\t\t\t      data->colors[i]));\n\n\tstatus = 0;\n\tret = iwl_mvm_send_cmd_pdu_status(mvm, BINDING_CONTEXT_CMD,\n\t\t\t\t\t  size, &cmd, &status);\n\tif (ret) {\n\t\tIWL_ERR(mvm, \"Failed to send binding (action:%d): %d\\n\",\n\t\t\taction, ret);\n\t\treturn ret;\n\t}\n\n\tif (status) {\n\t\tIWL_ERR(mvm, \"Binding command failed: %u\\n\", status);\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\nstatic void iwl_mvm_iface_iterator(void *_data, u8 *mac,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_iface_iterator_data *data = _data;\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tif (vif == data->ignore_vif)\n\t\treturn;\n\n\tif (mvmvif->deflink.phy_ctxt != data->phyctxt)\n\t\treturn;\n\n\tif (WARN_ON_ONCE(data->idx >= MAX_MACS_IN_BINDING))\n\t\treturn;\n\n\tdata->ids[data->idx] = mvmvif->id;\n\tdata->colors[data->idx] = mvmvif->color;\n\tdata->idx++;\n}\n\nstatic int iwl_mvm_binding_update(struct iwl_mvm *mvm,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct iwl_mvm_phy_ctxt *phyctxt,\n\t\t\t\t  bool add)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tstruct iwl_mvm_iface_iterator_data data = {\n\t\t.ignore_vif = vif,\n\t\t.phyctxt = phyctxt,\n\t};\n\tu32 action = FW_CTXT_ACTION_MODIFY;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tieee80211_iterate_active_interfaces_atomic(mvm->hw,\n\t\t\t\t\t\t   IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\t\t   iwl_mvm_iface_iterator,\n\t\t\t\t\t\t   &data);\n\n\t \n\tif (data.idx == 0) {\n\t\tif (add)\n\t\t\taction = FW_CTXT_ACTION_ADD;\n\t\telse\n\t\t\taction = FW_CTXT_ACTION_REMOVE;\n\t}\n\n\tif (add) {\n\t\tif (WARN_ON_ONCE(data.idx >= MAX_MACS_IN_BINDING))\n\t\t\treturn -EINVAL;\n\n\t\tdata.ids[data.idx] = mvmvif->id;\n\t\tdata.colors[data.idx] = mvmvif->color;\n\t\tdata.idx++;\n\t}\n\n\treturn iwl_mvm_binding_cmd(mvm, action, &data);\n}\n\nint iwl_mvm_binding_add_vif(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\n\tif (WARN_ON_ONCE(!mvmvif->deflink.phy_ctxt))\n\t\treturn -EINVAL;\n\n\t \n\tif (iwl_mvm_sf_update(mvm, vif, false))\n\t\treturn -EINVAL;\n\n\treturn iwl_mvm_binding_update(mvm, vif, mvmvif->deflink.phy_ctxt,\n\t\t\t\t      true);\n}\n\nint iwl_mvm_binding_remove_vif(struct iwl_mvm *mvm, struct ieee80211_vif *vif)\n{\n\tstruct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);\n\tint ret;\n\n\tif (WARN_ON_ONCE(!mvmvif->deflink.phy_ctxt))\n\t\treturn -EINVAL;\n\n\tret = iwl_mvm_binding_update(mvm, vif, mvmvif->deflink.phy_ctxt,\n\t\t\t\t     false);\n\n\tif (!ret)\n\t\tif (iwl_mvm_sf_update(mvm, vif, true))\n\t\t\tIWL_ERR(mvm, \"Failed to update SF state\\n\");\n\n\treturn ret;\n}\n\nu32 iwl_mvm_get_lmac_id(struct iwl_mvm *mvm, enum nl80211_band band)\n{\n\tif (!fw_has_capa(&mvm->fw->ucode_capa, IWL_UCODE_TLV_CAPA_CDB_SUPPORT) ||\n\t    band == NL80211_BAND_2GHZ)\n\t\treturn IWL_LMAC_24G_INDEX;\n\treturn IWL_LMAC_5G_INDEX;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}