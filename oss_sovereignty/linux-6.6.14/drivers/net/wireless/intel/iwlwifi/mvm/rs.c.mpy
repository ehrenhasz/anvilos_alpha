{
  "module_name": "rs.c",
  "hash_id": "7125bd75042804c126975b59d3554caec482c7eff6b7fd3a0ebb0bc0f589e0e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/intel/iwlwifi/mvm/rs.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <net/mac80211.h>\n\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/delay.h>\n\n#include <linux/workqueue.h>\n#include \"rs.h\"\n#include \"fw-api.h\"\n#include \"sta.h\"\n#include \"iwl-op-mode.h\"\n#include \"mvm.h\"\n#include \"debugfs.h\"\n\n#define IWL_RATE_MAX_WINDOW\t\t62\t \n\n \n#define RS_PERCENT(x) (128 * x)\n\nstatic u8 rs_ht_to_legacy[] = {\n\t[IWL_RATE_MCS_0_INDEX] = IWL_RATE_6M_INDEX,\n\t[IWL_RATE_MCS_1_INDEX] = IWL_RATE_9M_INDEX,\n\t[IWL_RATE_MCS_2_INDEX] = IWL_RATE_12M_INDEX,\n\t[IWL_RATE_MCS_3_INDEX] = IWL_RATE_18M_INDEX,\n\t[IWL_RATE_MCS_4_INDEX] = IWL_RATE_24M_INDEX,\n\t[IWL_RATE_MCS_5_INDEX] = IWL_RATE_36M_INDEX,\n\t[IWL_RATE_MCS_6_INDEX] = IWL_RATE_48M_INDEX,\n\t[IWL_RATE_MCS_7_INDEX] = IWL_RATE_54M_INDEX,\n\t[IWL_RATE_MCS_8_INDEX] = IWL_RATE_54M_INDEX,\n\t[IWL_RATE_MCS_9_INDEX] = IWL_RATE_54M_INDEX,\n};\n\nstatic const u8 ant_toggle_lookup[] = {\n\t[ANT_NONE] = ANT_NONE,\n\t[ANT_A] = ANT_B,\n\t[ANT_B] = ANT_A,\n\t[ANT_AB] = ANT_AB,\n};\n\n#define IWL_DECLARE_RATE_INFO(r, s, rp, rn)\t\t\t      \\\n\t[IWL_RATE_##r##M_INDEX] = { IWL_RATE_##r##M_PLCP,\t      \\\n\t\t\t\t    IWL_RATE_HT_SISO_MCS_##s##_PLCP,  \\\n\t\t\t\t    IWL_RATE_HT_MIMO2_MCS_##s##_PLCP, \\\n\t\t\t\t    IWL_RATE_VHT_SISO_MCS_##s##_PLCP, \\\n\t\t\t\t    IWL_RATE_VHT_MIMO2_MCS_##s##_PLCP,\\\n\t\t\t\t    IWL_RATE_##rp##M_INDEX,\t      \\\n\t\t\t\t    IWL_RATE_##rn##M_INDEX }\n\n#define IWL_DECLARE_MCS_RATE(s)\t\t\t\t\t\t  \\\n\t[IWL_RATE_MCS_##s##_INDEX] = { IWL_RATE_INVM_PLCP,\t\t  \\\n\t\t\t\t       IWL_RATE_HT_SISO_MCS_##s##_PLCP,\t  \\\n\t\t\t\t       IWL_RATE_HT_MIMO2_MCS_##s##_PLCP,  \\\n\t\t\t\t       IWL_RATE_VHT_SISO_MCS_##s##_PLCP,  \\\n\t\t\t\t       IWL_RATE_VHT_MIMO2_MCS_##s##_PLCP, \\\n\t\t\t\t       IWL_RATE_INVM_INDEX,\t          \\\n\t\t\t\t       IWL_RATE_INVM_INDEX }\n\n \nstatic const struct iwl_rs_rate_info iwl_rates[IWL_RATE_COUNT] = {\n\tIWL_DECLARE_RATE_INFO(1, INV, INV, 2),    \n\tIWL_DECLARE_RATE_INFO(2, INV, 1, 5),      \n\tIWL_DECLARE_RATE_INFO(5, INV, 2, 11),     \n\tIWL_DECLARE_RATE_INFO(11, INV, 9, 12),    \n\tIWL_DECLARE_RATE_INFO(6, 0, 5, 11),       \n\tIWL_DECLARE_RATE_INFO(9, INV, 6, 11),     \n\tIWL_DECLARE_RATE_INFO(12, 1, 11, 18),     \n\tIWL_DECLARE_RATE_INFO(18, 2, 12, 24),     \n\tIWL_DECLARE_RATE_INFO(24, 3, 18, 36),     \n\tIWL_DECLARE_RATE_INFO(36, 4, 24, 48),     \n\tIWL_DECLARE_RATE_INFO(48, 5, 36, 54),     \n\tIWL_DECLARE_RATE_INFO(54, 6, 48, INV),    \n\tIWL_DECLARE_MCS_RATE(7),                  \n\tIWL_DECLARE_MCS_RATE(8),                  \n\tIWL_DECLARE_MCS_RATE(9),                  \n};\n\nenum rs_action {\n\tRS_ACTION_STAY = 0,\n\tRS_ACTION_DOWNSCALE = -1,\n\tRS_ACTION_UPSCALE = 1,\n};\n\nenum rs_column_mode {\n\tRS_INVALID = 0,\n\tRS_LEGACY,\n\tRS_SISO,\n\tRS_MIMO2,\n};\n\n#define MAX_NEXT_COLUMNS 7\n#define MAX_COLUMN_CHECKS 3\n\nstruct rs_tx_column;\n\ntypedef bool (*allow_column_func_t) (struct iwl_mvm *mvm,\n\t\t\t\t     struct ieee80211_sta *sta,\n\t\t\t\t     struct rs_rate *rate,\n\t\t\t\t     const struct rs_tx_column *next_col);\n\nstruct rs_tx_column {\n\tenum rs_column_mode mode;\n\tu8 ant;\n\tbool sgi;\n\tenum rs_column next_columns[MAX_NEXT_COLUMNS];\n\tallow_column_func_t checks[MAX_COLUMN_CHECKS];\n};\n\nstatic bool rs_ant_allow(struct iwl_mvm *mvm, struct ieee80211_sta *sta,\n\t\t\t struct rs_rate *rate,\n\t\t\t const struct rs_tx_column *next_col)\n{\n\treturn iwl_mvm_bt_coex_is_ant_avail(mvm, next_col->ant);\n}\n\nstatic bool rs_mimo_allow(struct iwl_mvm *mvm, struct ieee80211_sta *sta,\n\t\t\t  struct rs_rate *rate,\n\t\t\t  const struct rs_tx_column *next_col)\n{\n\tif (!sta->deflink.ht_cap.ht_supported)\n\t\treturn false;\n\n\tif (sta->deflink.smps_mode == IEEE80211_SMPS_STATIC)\n\t\treturn false;\n\n\tif (num_of_ant(iwl_mvm_get_valid_tx_ant(mvm)) < 2)\n\t\treturn false;\n\n\tif (!iwl_mvm_bt_coex_is_mimo_allowed(mvm, sta))\n\t\treturn false;\n\n\tif (mvm->nvm_data->sku_cap_mimo_disabled)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool rs_siso_allow(struct iwl_mvm *mvm, struct ieee80211_sta *sta,\n\t\t\t  struct rs_rate *rate,\n\t\t\t  const struct rs_tx_column *next_col)\n{\n\tif (!sta->deflink.ht_cap.ht_supported)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool rs_sgi_allow(struct iwl_mvm *mvm, struct ieee80211_sta *sta,\n\t\t\t struct rs_rate *rate,\n\t\t\t const struct rs_tx_column *next_col)\n{\n\tstruct ieee80211_sta_ht_cap *ht_cap = &sta->deflink.ht_cap;\n\tstruct ieee80211_sta_vht_cap *vht_cap = &sta->deflink.vht_cap;\n\n\tif (is_ht20(rate) && (ht_cap->cap &\n\t\t\t     IEEE80211_HT_CAP_SGI_20))\n\t\treturn true;\n\tif (is_ht40(rate) && (ht_cap->cap &\n\t\t\t     IEEE80211_HT_CAP_SGI_40))\n\t\treturn true;\n\tif (is_ht80(rate) && (vht_cap->cap &\n\t\t\t     IEEE80211_VHT_CAP_SHORT_GI_80))\n\t\treturn true;\n\tif (is_ht160(rate) && (vht_cap->cap &\n\t\t\t     IEEE80211_VHT_CAP_SHORT_GI_160))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic const struct rs_tx_column rs_tx_columns[] = {\n\t[RS_COLUMN_LEGACY_ANT_A] = {\n\t\t.mode = RS_LEGACY,\n\t\t.ant = ANT_A,\n\t\t.next_columns = {\n\t\t\tRS_COLUMN_LEGACY_ANT_B,\n\t\t\tRS_COLUMN_SISO_ANT_A,\n\t\t\tRS_COLUMN_MIMO2,\n\t\t\tRS_COLUMN_INVALID,\n\t\t\tRS_COLUMN_INVALID,\n\t\t\tRS_COLUMN_INVALID,\n\t\t\tRS_COLUMN_INVALID,\n\t\t},\n\t\t.checks = {\n\t\t\trs_ant_allow,\n\t\t},\n\t},\n\t[RS_COLUMN_LEGACY_ANT_B] = {\n\t\t.mode = RS_LEGACY,\n\t\t.ant = ANT_B,\n\t\t.next_columns = {\n\t\t\tRS_COLUMN_LEGACY_ANT_A,\n\t\t\tRS_COLUMN_SISO_ANT_B,\n\t\t\tRS_COLUMN_MIMO2,\n\t\t\tRS_COLUMN_INVALID,\n\t\t\tRS_COLUMN_INVALID,\n\t\t\tRS_COLUMN_INVALID,\n\t\t\tRS_COLUMN_INVALID,\n\t\t},\n\t\t.checks = {\n\t\t\trs_ant_allow,\n\t\t},\n\t},\n\t[RS_COLUMN_SISO_ANT_A] = {\n\t\t.mode = RS_SISO,\n\t\t.ant = ANT_A,\n\t\t.next_columns = {\n\t\t\tRS_COLUMN_SISO_ANT_B,\n\t\t\tRS_COLUMN_MIMO2,\n\t\t\tRS_COLUMN_SISO_ANT_A_SGI,\n\t\t\tRS_COLUMN_LEGACY_ANT_A,\n\t\t\tRS_COLUMN_LEGACY_ANT_B,\n\t\t\tRS_COLUMN_INVALID,\n\t\t\tRS_COLUMN_INVALID,\n\t\t},\n\t\t.checks = {\n\t\t\trs_siso_allow,\n\t\t\trs_ant_allow,\n\t\t},\n\t},\n\t[RS_COLUMN_SISO_ANT_B] = {\n\t\t.mode = RS_SISO,\n\t\t.ant = ANT_B,\n\t\t.next_columns = {\n\t\t\tRS_COLUMN_SISO_ANT_A,\n\t\t\tRS_COLUMN_MIMO2,\n\t\t\tRS_COLUMN_SISO_ANT_B_SGI,\n\t\t\tRS_COLUMN_LEGACY_ANT_A,\n\t\t\tRS_COLUMN_LEGACY_ANT_B,\n\t\t\tRS_COLUMN_INVALID,\n\t\t\tRS_COLUMN_INVALID,\n\t\t},\n\t\t.checks = {\n\t\t\trs_siso_allow,\n\t\t\trs_ant_allow,\n\t\t},\n\t},\n\t[RS_COLUMN_SISO_ANT_A_SGI] = {\n\t\t.mode = RS_SISO,\n\t\t.ant = ANT_A,\n\t\t.sgi = true,\n\t\t.next_columns = {\n\t\t\tRS_COLUMN_SISO_ANT_B_SGI,\n\t\t\tRS_COLUMN_MIMO2_SGI,\n\t\t\tRS_COLUMN_SISO_ANT_A,\n\t\t\tRS_COLUMN_LEGACY_ANT_A,\n\t\t\tRS_COLUMN_LEGACY_ANT_B,\n\t\t\tRS_COLUMN_INVALID,\n\t\t\tRS_COLUMN_INVALID,\n\t\t},\n\t\t.checks = {\n\t\t\trs_siso_allow,\n\t\t\trs_ant_allow,\n\t\t\trs_sgi_allow,\n\t\t},\n\t},\n\t[RS_COLUMN_SISO_ANT_B_SGI] = {\n\t\t.mode = RS_SISO,\n\t\t.ant = ANT_B,\n\t\t.sgi = true,\n\t\t.next_columns = {\n\t\t\tRS_COLUMN_SISO_ANT_A_SGI,\n\t\t\tRS_COLUMN_MIMO2_SGI,\n\t\t\tRS_COLUMN_SISO_ANT_B,\n\t\t\tRS_COLUMN_LEGACY_ANT_A,\n\t\t\tRS_COLUMN_LEGACY_ANT_B,\n\t\t\tRS_COLUMN_INVALID,\n\t\t\tRS_COLUMN_INVALID,\n\t\t},\n\t\t.checks = {\n\t\t\trs_siso_allow,\n\t\t\trs_ant_allow,\n\t\t\trs_sgi_allow,\n\t\t},\n\t},\n\t[RS_COLUMN_MIMO2] = {\n\t\t.mode = RS_MIMO2,\n\t\t.ant = ANT_AB,\n\t\t.next_columns = {\n\t\t\tRS_COLUMN_SISO_ANT_A,\n\t\t\tRS_COLUMN_MIMO2_SGI,\n\t\t\tRS_COLUMN_LEGACY_ANT_A,\n\t\t\tRS_COLUMN_LEGACY_ANT_B,\n\t\t\tRS_COLUMN_INVALID,\n\t\t\tRS_COLUMN_INVALID,\n\t\t\tRS_COLUMN_INVALID,\n\t\t},\n\t\t.checks = {\n\t\t\trs_mimo_allow,\n\t\t},\n\t},\n\t[RS_COLUMN_MIMO2_SGI] = {\n\t\t.mode = RS_MIMO2,\n\t\t.ant = ANT_AB,\n\t\t.sgi = true,\n\t\t.next_columns = {\n\t\t\tRS_COLUMN_SISO_ANT_A_SGI,\n\t\t\tRS_COLUMN_MIMO2,\n\t\t\tRS_COLUMN_LEGACY_ANT_A,\n\t\t\tRS_COLUMN_LEGACY_ANT_B,\n\t\t\tRS_COLUMN_INVALID,\n\t\t\tRS_COLUMN_INVALID,\n\t\t\tRS_COLUMN_INVALID,\n\t\t},\n\t\t.checks = {\n\t\t\trs_mimo_allow,\n\t\t\trs_sgi_allow,\n\t\t},\n\t},\n};\n\nstatic inline u8 rs_extract_rate(u32 rate_n_flags)\n{\n\t \n\treturn (u8)(rate_n_flags & RATE_LEGACY_RATE_MSK_V1);\n}\n\nstatic int iwl_hwrate_to_plcp_idx(u32 rate_n_flags)\n{\n\tint idx = 0;\n\n\tif (rate_n_flags & RATE_MCS_HT_MSK_V1) {\n\t\tidx = rate_n_flags & RATE_HT_MCS_RATE_CODE_MSK_V1;\n\t\tidx += IWL_RATE_MCS_0_INDEX;\n\n\t\t \n\t\tif (idx >= IWL_RATE_9M_INDEX)\n\t\t\tidx += 1;\n\t\tif ((idx >= IWL_FIRST_HT_RATE) && (idx <= IWL_LAST_HT_RATE))\n\t\t\treturn idx;\n\t} else if (rate_n_flags & RATE_MCS_VHT_MSK_V1 ||\n\t\t   rate_n_flags & RATE_MCS_HE_MSK_V1) {\n\t\tidx = rate_n_flags & RATE_VHT_MCS_RATE_CODE_MSK;\n\t\tidx += IWL_RATE_MCS_0_INDEX;\n\n\t\t \n\t\tif (idx >= IWL_RATE_9M_INDEX)\n\t\t\tidx++;\n\t\tif ((idx >= IWL_FIRST_VHT_RATE) && (idx <= IWL_LAST_VHT_RATE))\n\t\t\treturn idx;\n\t\tif ((rate_n_flags & RATE_MCS_HE_MSK_V1) &&\n\t\t    idx <= IWL_LAST_HE_RATE)\n\t\t\treturn idx;\n\t} else {\n\t\t \n\n\t\tu8 legacy_rate = rs_extract_rate(rate_n_flags);\n\t\tfor (idx = 0; idx < ARRAY_SIZE(iwl_rates); idx++)\n\t\t\tif (iwl_rates[idx].plcp == legacy_rate)\n\t\t\t\treturn idx;\n\t}\n\n\treturn IWL_RATE_INVALID;\n}\n\nstatic void rs_rate_scale_perform(struct iwl_mvm *mvm,\n\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t  struct iwl_lq_sta *lq_sta,\n\t\t\t\t  int tid, bool ndp);\nstatic void rs_fill_lq_cmd(struct iwl_mvm *mvm,\n\t\t\t   struct ieee80211_sta *sta,\n\t\t\t   struct iwl_lq_sta *lq_sta,\n\t\t\t   const struct rs_rate *initial_rate);\nstatic void rs_stay_in_table(struct iwl_lq_sta *lq_sta, bool force_search);\n\n \nstatic const u16 expected_tpt_legacy[IWL_RATE_COUNT] = {\n\t7, 13, 35, 58, 40, 57, 72, 98, 121, 154, 177, 186, 0, 0, 0\n};\n\n \nstatic const u16 expected_tpt_siso_20MHz[4][IWL_RATE_COUNT] = {\n\t{0, 0, 0, 0, 42, 0,  76, 102, 124, 159, 183, 193, 202, 216, 0},\n\t{0, 0, 0, 0, 46, 0,  82, 110, 132, 168, 192, 202, 210, 225, 0},\n\t{0, 0, 0, 0, 49, 0,  97, 145, 192, 285, 375, 420, 464, 551, 0},\n\t{0, 0, 0, 0, 54, 0, 108, 160, 213, 315, 415, 465, 513, 608, 0},\n};\n\nstatic const u16 expected_tpt_siso_40MHz[4][IWL_RATE_COUNT] = {\n\t{0, 0, 0, 0,  77, 0, 127, 160, 184, 220, 242, 250,  257,  269,  275},\n\t{0, 0, 0, 0,  83, 0, 135, 169, 193, 229, 250, 257,  264,  275,  280},\n\t{0, 0, 0, 0, 101, 0, 199, 295, 389, 570, 744, 828,  911, 1070, 1173},\n\t{0, 0, 0, 0, 112, 0, 220, 326, 429, 629, 819, 912, 1000, 1173, 1284},\n};\n\nstatic const u16 expected_tpt_siso_80MHz[4][IWL_RATE_COUNT] = {\n\t{0, 0, 0, 0, 130, 0, 191, 223, 244,  273,  288,  294,  298,  305,  308},\n\t{0, 0, 0, 0, 138, 0, 200, 231, 251,  279,  293,  298,  302,  308,  312},\n\t{0, 0, 0, 0, 217, 0, 429, 634, 834, 1220, 1585, 1760, 1931, 2258, 2466},\n\t{0, 0, 0, 0, 241, 0, 475, 701, 921, 1343, 1741, 1931, 2117, 2468, 2691},\n};\n\nstatic const u16 expected_tpt_siso_160MHz[4][IWL_RATE_COUNT] = {\n\t{0, 0, 0, 0, 191, 0, 244, 288,  298,  308,  313,  318,  323,  328,  330},\n\t{0, 0, 0, 0, 200, 0, 251, 293,  302,  312,  317,  322,  327,  332,  334},\n\t{0, 0, 0, 0, 439, 0, 875, 1307, 1736, 2584, 3419, 3831, 4240, 5049, 5581},\n\t{0, 0, 0, 0, 488, 0, 972, 1451, 1925, 2864, 3785, 4240, 4691, 5581, 6165},\n};\n\nstatic const u16 expected_tpt_mimo2_20MHz[4][IWL_RATE_COUNT] = {\n\t{0, 0, 0, 0,  74, 0, 123, 155, 179, 213, 235, 243, 250,  261, 0},\n\t{0, 0, 0, 0,  81, 0, 131, 164, 187, 221, 242, 250, 256,  267, 0},\n\t{0, 0, 0, 0,  98, 0, 193, 286, 375, 550, 718, 799, 878, 1032, 0},\n\t{0, 0, 0, 0, 109, 0, 214, 316, 414, 607, 790, 879, 965, 1132, 0},\n};\n\nstatic const u16 expected_tpt_mimo2_40MHz[4][IWL_RATE_COUNT] = {\n\t{0, 0, 0, 0, 123, 0, 182, 214, 235,  264,  279,  285,  289,  296,  300},\n\t{0, 0, 0, 0, 131, 0, 191, 222, 242,  270,  284,  289,  293,  300,  303},\n\t{0, 0, 0, 0, 200, 0, 390, 571, 741, 1067, 1365, 1505, 1640, 1894, 2053},\n\t{0, 0, 0, 0, 221, 0, 430, 630, 816, 1169, 1490, 1641, 1784, 2053, 2221},\n};\n\nstatic const u16 expected_tpt_mimo2_80MHz[4][IWL_RATE_COUNT] = {\n\t{0, 0, 0, 0, 182, 0, 240,  264,  278,  299,  308,  311,  313,  317,  319},\n\t{0, 0, 0, 0, 190, 0, 247,  269,  282,  302,  310,  313,  315,  319,  320},\n\t{0, 0, 0, 0, 428, 0, 833, 1215, 1577, 2254, 2863, 3147, 3418, 3913, 4219},\n\t{0, 0, 0, 0, 474, 0, 920, 1338, 1732, 2464, 3116, 3418, 3705, 4225, 4545},\n};\n\nstatic const u16 expected_tpt_mimo2_160MHz[4][IWL_RATE_COUNT] = {\n\t{0, 0, 0, 0, 240, 0, 278,  308,  313,  319,  322,  324,  328,  330,   334},\n\t{0, 0, 0, 0, 247, 0, 282,  310,  315,  320,  323,  325,  329,  332,   338},\n\t{0, 0, 0, 0, 875, 0, 1735, 2582, 3414, 5043, 6619, 7389, 8147, 9629,  10592},\n\t{0, 0, 0, 0, 971, 0, 1925, 2861, 3779, 5574, 7304, 8147, 8976, 10592, 11640},\n};\n\nstatic const char *rs_pretty_lq_type(enum iwl_table_type type)\n{\n\tstatic const char * const lq_types[] = {\n\t\t[LQ_NONE] = \"NONE\",\n\t\t[LQ_LEGACY_A] = \"LEGACY_A\",\n\t\t[LQ_LEGACY_G] = \"LEGACY_G\",\n\t\t[LQ_HT_SISO] = \"HT SISO\",\n\t\t[LQ_HT_MIMO2] = \"HT MIMO\",\n\t\t[LQ_VHT_SISO] = \"VHT SISO\",\n\t\t[LQ_VHT_MIMO2] = \"VHT MIMO\",\n\t\t[LQ_HE_SISO] = \"HE SISO\",\n\t\t[LQ_HE_MIMO2] = \"HE MIMO\",\n\t};\n\n\tif (type < LQ_NONE || type >= LQ_MAX)\n\t\treturn \"UNKNOWN\";\n\n\treturn lq_types[type];\n}\n\nstatic char *rs_pretty_rate(const struct rs_rate *rate)\n{\n\tstatic char buf[40];\n\tstatic const char * const legacy_rates[] = {\n\t\t[IWL_RATE_1M_INDEX] = \"1M\",\n\t\t[IWL_RATE_2M_INDEX] = \"2M\",\n\t\t[IWL_RATE_5M_INDEX] = \"5.5M\",\n\t\t[IWL_RATE_11M_INDEX] = \"11M\",\n\t\t[IWL_RATE_6M_INDEX] = \"6M\",\n\t\t[IWL_RATE_9M_INDEX] = \"9M\",\n\t\t[IWL_RATE_12M_INDEX] = \"12M\",\n\t\t[IWL_RATE_18M_INDEX] = \"18M\",\n\t\t[IWL_RATE_24M_INDEX] = \"24M\",\n\t\t[IWL_RATE_36M_INDEX] = \"36M\",\n\t\t[IWL_RATE_48M_INDEX] = \"48M\",\n\t\t[IWL_RATE_54M_INDEX] = \"54M\",\n\t};\n\tstatic const char *const ht_vht_rates[] = {\n\t\t[IWL_RATE_MCS_0_INDEX] = \"MCS0\",\n\t\t[IWL_RATE_MCS_1_INDEX] = \"MCS1\",\n\t\t[IWL_RATE_MCS_2_INDEX] = \"MCS2\",\n\t\t[IWL_RATE_MCS_3_INDEX] = \"MCS3\",\n\t\t[IWL_RATE_MCS_4_INDEX] = \"MCS4\",\n\t\t[IWL_RATE_MCS_5_INDEX] = \"MCS5\",\n\t\t[IWL_RATE_MCS_6_INDEX] = \"MCS6\",\n\t\t[IWL_RATE_MCS_7_INDEX] = \"MCS7\",\n\t\t[IWL_RATE_MCS_8_INDEX] = \"MCS8\",\n\t\t[IWL_RATE_MCS_9_INDEX] = \"MCS9\",\n\t};\n\tconst char *rate_str;\n\n\tif (is_type_legacy(rate->type) && (rate->index <= IWL_RATE_54M_INDEX))\n\t\trate_str = legacy_rates[rate->index];\n\telse if ((is_type_ht(rate->type) || is_type_vht(rate->type)) &&\n\t\t (rate->index >= IWL_RATE_MCS_0_INDEX) &&\n\t\t (rate->index <= IWL_RATE_MCS_9_INDEX))\n\t\trate_str = ht_vht_rates[rate->index];\n\telse\n\t\trate_str = NULL;\n\n\tsprintf(buf, \"(%s|%s|%s)\", rs_pretty_lq_type(rate->type),\n\t\tiwl_rs_pretty_ant(rate->ant), rate_str ?: \"BAD_RATE\");\n\treturn buf;\n}\n\nstatic inline void rs_dump_rate(struct iwl_mvm *mvm, const struct rs_rate *rate,\n\t\t\t\tconst char *prefix)\n{\n\tIWL_DEBUG_RATE(mvm,\n\t\t       \"%s: %s BW: %d SGI: %d LDPC: %d STBC: %d\\n\",\n\t\t       prefix, rs_pretty_rate(rate), rate->bw,\n\t\t       rate->sgi, rate->ldpc, rate->stbc);\n}\n\nstatic void rs_rate_scale_clear_window(struct iwl_rate_scale_data *window)\n{\n\twindow->data = 0;\n\twindow->success_counter = 0;\n\twindow->success_ratio = IWL_INVALID_VALUE;\n\twindow->counter = 0;\n\twindow->average_tpt = IWL_INVALID_VALUE;\n}\n\nstatic void rs_rate_scale_clear_tbl_windows(struct iwl_mvm *mvm,\n\t\t\t\t\t    struct iwl_scale_tbl_info *tbl)\n{\n\tint i;\n\n\tIWL_DEBUG_RATE(mvm, \"Clearing up window stats\\n\");\n\tfor (i = 0; i < IWL_RATE_COUNT; i++)\n\t\trs_rate_scale_clear_window(&tbl->win[i]);\n\n\tfor (i = 0; i < ARRAY_SIZE(tbl->tpc_win); i++)\n\t\trs_rate_scale_clear_window(&tbl->tpc_win[i]);\n}\n\nstatic inline u8 rs_is_valid_ant(u8 valid_antenna, u8 ant_type)\n{\n\treturn (ant_type & valid_antenna) == ant_type;\n}\n\nstatic int rs_tl_turn_on_agg_for_tid(struct iwl_mvm *mvm,\n\t\t\t\t     struct iwl_lq_sta *lq_data, u8 tid,\n\t\t\t\t     struct ieee80211_sta *sta)\n{\n\tint ret;\n\n\tIWL_DEBUG_HT(mvm, \"Starting Tx agg: STA: %pM tid: %d\\n\",\n\t\t     sta->addr, tid);\n\n\t \n\tret = ieee80211_start_tx_ba_session(sta, tid, 0);\n\tif (ret == -EAGAIN) {\n\t\t \n\t\tIWL_ERR(mvm, \"Fail start Tx agg on tid: %d\\n\",\n\t\t\ttid);\n\t\tieee80211_stop_tx_ba_session(sta, tid);\n\t}\n\treturn ret;\n}\n\nstatic void rs_tl_turn_on_agg(struct iwl_mvm *mvm, struct iwl_mvm_sta *mvmsta,\n\t\t\t      u8 tid, struct iwl_lq_sta *lq_sta,\n\t\t\t      struct ieee80211_sta *sta)\n{\n\tstruct iwl_mvm_tid_data *tid_data;\n\n\t \n\tif (WARN_ON_ONCE(tid > IWL_MAX_TID_COUNT)) {\n\t\tIWL_ERR(mvm, \"tid exceeds max TID count: %d/%d\\n\",\n\t\t\ttid, IWL_MAX_TID_COUNT);\n\t\treturn;\n\t} else if (tid == IWL_MAX_TID_COUNT) {\n\t\treturn;\n\t}\n\n\ttid_data = &mvmsta->tid_data[tid];\n\tif (mvmsta->sta_state >= IEEE80211_STA_AUTHORIZED &&\n\t    tid_data->state == IWL_AGG_OFF &&\n\t    (lq_sta->tx_agg_tid_en & BIT(tid)) &&\n\t    tid_data->tx_count_last >= IWL_MVM_RS_AGG_START_THRESHOLD) {\n\t\tIWL_DEBUG_RATE(mvm, \"try to aggregate tid %d\\n\", tid);\n\t\tif (rs_tl_turn_on_agg_for_tid(mvm, lq_sta, tid, sta) == 0)\n\t\t\ttid_data->state = IWL_AGG_QUEUED;\n\t}\n}\n\nstatic inline int get_num_of_ant_from_rate(u32 rate_n_flags)\n{\n\treturn !!(rate_n_flags & RATE_MCS_ANT_A_MSK) +\n\t       !!(rate_n_flags & RATE_MCS_ANT_B_MSK);\n}\n\n \nstatic s32 get_expected_tpt(struct iwl_scale_tbl_info *tbl, int rs_index)\n{\n\tif (tbl->expected_tpt)\n\t\treturn tbl->expected_tpt[rs_index];\n\treturn 0;\n}\n\n \nstatic int _rs_collect_tx_data(struct iwl_mvm *mvm,\n\t\t\t       struct iwl_scale_tbl_info *tbl,\n\t\t\t       int scale_index, int attempts, int successes,\n\t\t\t       struct iwl_rate_scale_data *window)\n{\n\tstatic const u64 mask = (((u64)1) << (IWL_RATE_MAX_WINDOW - 1));\n\ts32 fail_count, tpt;\n\n\t \n\ttpt = get_expected_tpt(tbl, scale_index);\n\n\t \n\twhile (attempts > 0) {\n\t\tif (window->counter >= IWL_RATE_MAX_WINDOW) {\n\t\t\t \n\t\t\twindow->counter = IWL_RATE_MAX_WINDOW - 1;\n\n\t\t\tif (window->data & mask) {\n\t\t\t\twindow->data &= ~mask;\n\t\t\t\twindow->success_counter--;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\twindow->counter++;\n\n\t\t \n\t\twindow->data <<= 1;\n\n\t\t \n\t\tif (successes > 0) {\n\t\t\twindow->success_counter++;\n\t\t\twindow->data |= 0x1;\n\t\t\tsuccesses--;\n\t\t}\n\n\t\tattempts--;\n\t}\n\n\t \n\tif (window->counter > 0)\n\t\twindow->success_ratio = 128 * (100 * window->success_counter)\n\t\t\t\t\t/ window->counter;\n\telse\n\t\twindow->success_ratio = IWL_INVALID_VALUE;\n\n\tfail_count = window->counter - window->success_counter;\n\n\t \n\tif ((fail_count >= IWL_MVM_RS_RATE_MIN_FAILURE_TH) ||\n\t    (window->success_counter >= IWL_MVM_RS_RATE_MIN_SUCCESS_TH))\n\t\twindow->average_tpt = (window->success_ratio * tpt + 64) / 128;\n\telse\n\t\twindow->average_tpt = IWL_INVALID_VALUE;\n\n\treturn 0;\n}\n\nstatic int rs_collect_tpc_data(struct iwl_mvm *mvm,\n\t\t\t       struct iwl_lq_sta *lq_sta,\n\t\t\t       struct iwl_scale_tbl_info *tbl,\n\t\t\t       int scale_index, int attempts, int successes,\n\t\t\t       u8 reduced_txp)\n{\n\tstruct iwl_rate_scale_data *window = NULL;\n\n\tif (WARN_ON_ONCE(reduced_txp > TPC_MAX_REDUCTION))\n\t\treturn -EINVAL;\n\n\twindow = &tbl->tpc_win[reduced_txp];\n\treturn  _rs_collect_tx_data(mvm, tbl, scale_index, attempts, successes,\n\t\t\t\t    window);\n}\n\nstatic void rs_update_tid_tpt_stats(struct iwl_mvm *mvm,\n\t\t\t\t    struct iwl_mvm_sta *mvmsta,\n\t\t\t\t    u8 tid, int successes)\n{\n\tstruct iwl_mvm_tid_data *tid_data;\n\n\tif (tid >= IWL_MAX_TID_COUNT)\n\t\treturn;\n\n\ttid_data = &mvmsta->tid_data[tid];\n\n\t \n\tif (tid_data->state != IWL_AGG_OFF)\n\t\treturn;\n\n\tif (time_is_before_jiffies(tid_data->tpt_meas_start + HZ) ||\n\t    (tid_data->tx_count >= IWL_MVM_RS_AGG_START_THRESHOLD)) {\n\t\ttid_data->tx_count_last = tid_data->tx_count;\n\t\ttid_data->tx_count = 0;\n\t\ttid_data->tpt_meas_start = jiffies;\n\t} else {\n\t\ttid_data->tx_count += successes;\n\t}\n}\n\nstatic int rs_collect_tlc_data(struct iwl_mvm *mvm,\n\t\t\t       struct iwl_mvm_sta *mvmsta, u8 tid,\n\t\t\t       struct iwl_scale_tbl_info *tbl,\n\t\t\t       int scale_index, int attempts, int successes)\n{\n\tstruct iwl_rate_scale_data *window = NULL;\n\n\tif (scale_index < 0 || scale_index >= IWL_RATE_COUNT)\n\t\treturn -EINVAL;\n\n\tif (tbl->column != RS_COLUMN_INVALID) {\n\t\tstruct lq_sta_pers *pers = &mvmsta->deflink.lq_sta.rs_drv.pers;\n\n\t\tpers->tx_stats[tbl->column][scale_index].total += attempts;\n\t\tpers->tx_stats[tbl->column][scale_index].success += successes;\n\t}\n\n\trs_update_tid_tpt_stats(mvm, mvmsta, tid, successes);\n\n\t \n\twindow = &(tbl->win[scale_index]);\n\treturn _rs_collect_tx_data(mvm, tbl, scale_index, attempts, successes,\n\t\t\t\t   window);\n}\n\n \nstatic u32 ucode_rate_from_rs_rate(struct iwl_mvm *mvm,\n\t\t\t\t  struct rs_rate *rate)\n{\n\tu32 ucode_rate = 0;\n\tint index = rate->index;\n\n\tucode_rate |= ((rate->ant << RATE_MCS_ANT_POS) &\n\t\t\t RATE_MCS_ANT_AB_MSK);\n\n\tif (is_legacy(rate)) {\n\t\tucode_rate |= iwl_rates[index].plcp;\n\t\tif (index >= IWL_FIRST_CCK_RATE && index <= IWL_LAST_CCK_RATE)\n\t\t\tucode_rate |= RATE_MCS_CCK_MSK_V1;\n\t\treturn ucode_rate;\n\t}\n\n\t \n\tucode_rate |= RATE_MCS_RTS_REQUIRED_MSK;\n\n\tif (is_ht(rate)) {\n\t\tif (index < IWL_FIRST_HT_RATE || index > IWL_LAST_HT_RATE) {\n\t\t\tIWL_ERR(mvm, \"Invalid HT rate index %d\\n\", index);\n\t\t\tindex = IWL_LAST_HT_RATE;\n\t\t}\n\t\tucode_rate |= RATE_MCS_HT_MSK_V1;\n\n\t\tif (is_ht_siso(rate))\n\t\t\tucode_rate |= iwl_rates[index].plcp_ht_siso;\n\t\telse if (is_ht_mimo2(rate))\n\t\t\tucode_rate |= iwl_rates[index].plcp_ht_mimo2;\n\t\telse\n\t\t\tWARN_ON_ONCE(1);\n\t} else if (is_vht(rate)) {\n\t\tif (index < IWL_FIRST_VHT_RATE || index > IWL_LAST_VHT_RATE) {\n\t\t\tIWL_ERR(mvm, \"Invalid VHT rate index %d\\n\", index);\n\t\t\tindex = IWL_LAST_VHT_RATE;\n\t\t}\n\t\tucode_rate |= RATE_MCS_VHT_MSK_V1;\n\t\tif (is_vht_siso(rate))\n\t\t\tucode_rate |= iwl_rates[index].plcp_vht_siso;\n\t\telse if (is_vht_mimo2(rate))\n\t\t\tucode_rate |= iwl_rates[index].plcp_vht_mimo2;\n\t\telse\n\t\t\tWARN_ON_ONCE(1);\n\n\t} else {\n\t\tIWL_ERR(mvm, \"Invalid rate->type %d\\n\", rate->type);\n\t}\n\n\tif (is_siso(rate) && rate->stbc) {\n\t\t \n\t\tucode_rate |= RATE_MCS_ANT_AB_MSK;\n\t\tucode_rate |= RATE_MCS_STBC_MSK;\n\t}\n\n\tucode_rate |= rate->bw;\n\tif (rate->sgi)\n\t\tucode_rate |= RATE_MCS_SGI_MSK_V1;\n\tif (rate->ldpc)\n\t\tucode_rate |= RATE_MCS_LDPC_MSK_V1;\n\n\treturn ucode_rate;\n}\n\n \nstatic int rs_rate_from_ucode_rate(const u32 ucode_rate,\n\t\t\t\t   enum nl80211_band band,\n\t\t\t\t   struct rs_rate *rate)\n{\n\tu32 ant_msk = ucode_rate & RATE_MCS_ANT_AB_MSK;\n\tu8 num_of_ant = get_num_of_ant_from_rate(ucode_rate);\n\tu8 nss;\n\n\tmemset(rate, 0, sizeof(*rate));\n\trate->index = iwl_hwrate_to_plcp_idx(ucode_rate);\n\n\tif (rate->index == IWL_RATE_INVALID)\n\t\treturn -EINVAL;\n\n\trate->ant = (ant_msk >> RATE_MCS_ANT_POS);\n\n\t \n\tif (!(ucode_rate & RATE_MCS_HT_MSK_V1) &&\n\t    !(ucode_rate & RATE_MCS_VHT_MSK_V1) &&\n\t    !(ucode_rate & RATE_MCS_HE_MSK_V1)) {\n\t\tif (num_of_ant == 1) {\n\t\t\tif (band == NL80211_BAND_5GHZ)\n\t\t\t\trate->type = LQ_LEGACY_A;\n\t\t\telse\n\t\t\t\trate->type = LQ_LEGACY_G;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (ucode_rate & RATE_MCS_SGI_MSK_V1)\n\t\trate->sgi = true;\n\tif (ucode_rate & RATE_MCS_LDPC_MSK_V1)\n\t\trate->ldpc = true;\n\tif (ucode_rate & RATE_MCS_STBC_MSK)\n\t\trate->stbc = true;\n\tif (ucode_rate & RATE_MCS_BF_MSK)\n\t\trate->bfer = true;\n\n\trate->bw = ucode_rate & RATE_MCS_CHAN_WIDTH_MSK_V1;\n\n\tif (ucode_rate & RATE_MCS_HT_MSK_V1) {\n\t\tnss = ((ucode_rate & RATE_HT_MCS_NSS_MSK_V1) >>\n\t\t       RATE_HT_MCS_NSS_POS_V1) + 1;\n\n\t\tif (nss == 1) {\n\t\t\trate->type = LQ_HT_SISO;\n\t\t\tWARN_ONCE(!rate->stbc && !rate->bfer && num_of_ant != 1,\n\t\t\t\t  \"stbc %d bfer %d\",\n\t\t\t\t  rate->stbc, rate->bfer);\n\t\t} else if (nss == 2) {\n\t\t\trate->type = LQ_HT_MIMO2;\n\t\t\tWARN_ON_ONCE(num_of_ant != 2);\n\t\t} else {\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\t} else if (ucode_rate & RATE_MCS_VHT_MSK_V1) {\n\t\tnss = FIELD_GET(RATE_MCS_NSS_MSK, ucode_rate) + 1;\n\n\t\tif (nss == 1) {\n\t\t\trate->type = LQ_VHT_SISO;\n\t\t\tWARN_ONCE(!rate->stbc && !rate->bfer && num_of_ant != 1,\n\t\t\t\t  \"stbc %d bfer %d\",\n\t\t\t\t  rate->stbc, rate->bfer);\n\t\t} else if (nss == 2) {\n\t\t\trate->type = LQ_VHT_MIMO2;\n\t\t\tWARN_ON_ONCE(num_of_ant != 2);\n\t\t} else {\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\t} else if (ucode_rate & RATE_MCS_HE_MSK_V1) {\n\t\tnss = FIELD_GET(RATE_MCS_NSS_MSK, ucode_rate) + 1;\n\n\t\tif (nss == 1) {\n\t\t\trate->type = LQ_HE_SISO;\n\t\t\tWARN_ONCE(!rate->stbc && !rate->bfer && num_of_ant != 1,\n\t\t\t\t  \"stbc %d bfer %d\", rate->stbc, rate->bfer);\n\t\t} else if (nss == 2) {\n\t\t\trate->type = LQ_HE_MIMO2;\n\t\t\tWARN_ON_ONCE(num_of_ant != 2);\n\t\t} else {\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\t}\n\n\tWARN_ON_ONCE(rate->bw == RATE_MCS_CHAN_WIDTH_80 &&\n\t\t     !is_he(rate) && !is_vht(rate));\n\n\treturn 0;\n}\n\n \n \nstatic int rs_toggle_antenna(u32 valid_ant, struct rs_rate *rate)\n{\n\tu8 new_ant_type;\n\n\tif (!rs_is_valid_ant(valid_ant, rate->ant))\n\t\treturn 0;\n\n\tnew_ant_type = ant_toggle_lookup[rate->ant];\n\n\twhile ((new_ant_type != rate->ant) &&\n\t       !rs_is_valid_ant(valid_ant, new_ant_type))\n\t\tnew_ant_type = ant_toggle_lookup[new_ant_type];\n\n\tif (new_ant_type == rate->ant)\n\t\treturn 0;\n\n\trate->ant = new_ant_type;\n\n\treturn 1;\n}\n\nstatic u16 rs_get_supported_rates(struct iwl_lq_sta *lq_sta,\n\t\t\t\t  struct rs_rate *rate)\n{\n\tif (is_legacy(rate))\n\t\treturn lq_sta->active_legacy_rate;\n\telse if (is_siso(rate))\n\t\treturn lq_sta->active_siso_rate;\n\telse if (is_mimo2(rate))\n\t\treturn lq_sta->active_mimo2_rate;\n\n\tWARN_ON_ONCE(1);\n\treturn 0;\n}\n\nstatic u16 rs_get_adjacent_rate(struct iwl_mvm *mvm, u8 index, u16 rate_mask,\n\t\t\t\tint rate_type)\n{\n\tu8 high = IWL_RATE_INVALID;\n\tu8 low = IWL_RATE_INVALID;\n\n\t \n\tif (is_type_a_band(rate_type) || !is_type_legacy(rate_type)) {\n\t\tint i;\n\t\tu32 mask;\n\n\t\t \n\t\ti = index - 1;\n\t\tif (i >= 0)\n\t\t\tmask = BIT(i);\n\t\tfor (; i >= 0; i--, mask >>= 1) {\n\t\t\tif (rate_mask & mask) {\n\t\t\t\tlow = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\ti = index + 1;\n\t\tfor (mask = (1 << i); i < IWL_RATE_COUNT; i++, mask <<= 1) {\n\t\t\tif (rate_mask & mask) {\n\t\t\t\thigh = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn (high << 8) | low;\n\t}\n\n\tlow = index;\n\twhile (low != IWL_RATE_INVALID) {\n\t\tlow = iwl_rates[low].prev_rs;\n\t\tif (low == IWL_RATE_INVALID)\n\t\t\tbreak;\n\t\tif (rate_mask & (1 << low))\n\t\t\tbreak;\n\t}\n\n\thigh = index;\n\twhile (high != IWL_RATE_INVALID) {\n\t\thigh = iwl_rates[high].next_rs;\n\t\tif (high == IWL_RATE_INVALID)\n\t\t\tbreak;\n\t\tif (rate_mask & (1 << high))\n\t\t\tbreak;\n\t}\n\n\treturn (high << 8) | low;\n}\n\nstatic inline bool rs_rate_supported(struct iwl_lq_sta *lq_sta,\n\t\t\t\t     struct rs_rate *rate)\n{\n\treturn BIT(rate->index) & rs_get_supported_rates(lq_sta, rate);\n}\n\n \nstatic bool rs_get_lower_rate_in_column(struct iwl_lq_sta *lq_sta,\n\t\t\t\t\tstruct rs_rate *rate)\n{\n\tu8 low;\n\tu16 high_low;\n\tu16 rate_mask;\n\tstruct iwl_mvm *mvm = lq_sta->pers.drv;\n\n\trate_mask = rs_get_supported_rates(lq_sta, rate);\n\thigh_low = rs_get_adjacent_rate(mvm, rate->index, rate_mask,\n\t\t\t\t\trate->type);\n\tlow = high_low & 0xff;\n\n\t \n\tif (low == IWL_RATE_INVALID)\n\t\treturn true;\n\n\trate->index = low;\n\treturn false;\n}\n\n \nstatic void rs_get_lower_rate_down_column(struct iwl_lq_sta *lq_sta,\n\t\t\t\t\t  struct rs_rate *rate)\n{\n\tstruct iwl_mvm *mvm = lq_sta->pers.drv;\n\n\tif (is_legacy(rate)) {\n\t\t \n\t\treturn;\n\t} else if (is_siso(rate)) {\n\t\t \n\t\tif (lq_sta->band == NL80211_BAND_5GHZ)\n\t\t\trate->type = LQ_LEGACY_A;\n\t\telse\n\t\t\trate->type = LQ_LEGACY_G;\n\n\t\trate->bw = RATE_MCS_CHAN_WIDTH_20;\n\n\t\tif (WARN_ON_ONCE(rate->index < IWL_RATE_MCS_0_INDEX))\n\t\t\trate->index = rs_ht_to_legacy[IWL_RATE_MCS_0_INDEX];\n\t\telse if (WARN_ON_ONCE(rate->index > IWL_RATE_MCS_9_INDEX))\n\t\t\trate->index = rs_ht_to_legacy[IWL_RATE_MCS_9_INDEX];\n\t\telse\n\t\t\trate->index = rs_ht_to_legacy[rate->index];\n\n\t\trate->ldpc = false;\n\t} else {\n\t\t \n\t\trate->type = is_vht_mimo2(rate) ?\n\t\t\tLQ_VHT_SISO : LQ_HT_SISO;\n\t}\n\n\tif (num_of_ant(rate->ant) > 1)\n\t\trate->ant = first_antenna(iwl_mvm_get_valid_tx_ant(mvm));\n\n\t \n\trate->sgi = false;\n\n\tif (!rs_rate_supported(lq_sta, rate))\n\t\trs_get_lower_rate_in_column(lq_sta, rate);\n}\n\n \nstatic inline bool rs_rate_column_match(struct rs_rate *a,\n\t\t\t\t\tstruct rs_rate *b)\n{\n\tbool ant_match;\n\n\tif (a->stbc || a->bfer)\n\t\tant_match = (b->ant == ANT_A || b->ant == ANT_B);\n\telse\n\t\tant_match = (a->ant == b->ant);\n\n\treturn (a->type == b->type) && (a->bw == b->bw) && (a->sgi == b->sgi)\n\t\t&& ant_match;\n}\n\nstatic inline enum rs_column rs_get_column_from_rate(struct rs_rate *rate)\n{\n\tif (is_legacy(rate)) {\n\t\tif (rate->ant == ANT_A)\n\t\t\treturn RS_COLUMN_LEGACY_ANT_A;\n\n\t\tif (rate->ant == ANT_B)\n\t\t\treturn RS_COLUMN_LEGACY_ANT_B;\n\n\t\tgoto err;\n\t}\n\n\tif (is_siso(rate)) {\n\t\tif (rate->ant == ANT_A || rate->stbc || rate->bfer)\n\t\t\treturn rate->sgi ? RS_COLUMN_SISO_ANT_A_SGI :\n\t\t\t\tRS_COLUMN_SISO_ANT_A;\n\n\t\tif (rate->ant == ANT_B)\n\t\t\treturn rate->sgi ? RS_COLUMN_SISO_ANT_B_SGI :\n\t\t\t\tRS_COLUMN_SISO_ANT_B;\n\n\t\tgoto err;\n\t}\n\n\tif (is_mimo(rate))\n\t\treturn rate->sgi ? RS_COLUMN_MIMO2_SGI : RS_COLUMN_MIMO2;\n\nerr:\n\treturn RS_COLUMN_INVALID;\n}\n\nstatic u8 rs_get_tid(struct ieee80211_hdr *hdr)\n{\n\tu8 tid = IWL_MAX_TID_COUNT;\n\n\tif (ieee80211_is_data_qos(hdr->frame_control)) {\n\t\tu8 *qc = ieee80211_get_qos_ctl(hdr);\n\t\ttid = qc[0] & 0xf;\n\t}\n\n\tif (unlikely(tid > IWL_MAX_TID_COUNT))\n\t\ttid = IWL_MAX_TID_COUNT;\n\n\treturn tid;\n}\n\n \nstatic void rs_drv_mac80211_tx_status(void *mvm_r,\n\t\t\t\t      struct ieee80211_supported_band *sband,\n\t\t\t\t      struct ieee80211_sta *sta, void *priv_sta,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct iwl_op_mode *op_mode = mvm_r;\n\tstruct iwl_mvm *mvm = IWL_OP_MODE_GET_MVM(op_mode);\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\n\tif (!mvmsta->vif)\n\t\treturn;\n\n\tif (!ieee80211_is_data(hdr->frame_control) ||\n\t    info->flags & IEEE80211_TX_CTL_NO_ACK)\n\t\treturn;\n\n\tiwl_mvm_rs_tx_status(mvm, sta, rs_get_tid(hdr), info,\n\t\t\t     ieee80211_is_qos_nullfunc(hdr->frame_control));\n}\n\n \nstatic void rs_set_stay_in_table(struct iwl_mvm *mvm, u8 is_legacy,\n\t\t\t\t struct iwl_lq_sta *lq_sta)\n{\n\tIWL_DEBUG_RATE(mvm, \"Moving to RS_STATE_STAY_IN_COLUMN\\n\");\n\tlq_sta->rs_state = RS_STATE_STAY_IN_COLUMN;\n\tif (is_legacy) {\n\t\tlq_sta->table_count_limit = IWL_MVM_RS_LEGACY_TABLE_COUNT;\n\t\tlq_sta->max_failure_limit = IWL_MVM_RS_LEGACY_FAILURE_LIMIT;\n\t\tlq_sta->max_success_limit = IWL_MVM_RS_LEGACY_SUCCESS_LIMIT;\n\t} else {\n\t\tlq_sta->table_count_limit = IWL_MVM_RS_NON_LEGACY_TABLE_COUNT;\n\t\tlq_sta->max_failure_limit = IWL_MVM_RS_NON_LEGACY_FAILURE_LIMIT;\n\t\tlq_sta->max_success_limit = IWL_MVM_RS_NON_LEGACY_SUCCESS_LIMIT;\n\t}\n\tlq_sta->table_count = 0;\n\tlq_sta->total_failed = 0;\n\tlq_sta->total_success = 0;\n\tlq_sta->flush_timer = jiffies;\n\tlq_sta->visited_columns = 0;\n}\n\nstatic inline int rs_get_max_rate_from_mask(unsigned long rate_mask)\n{\n\tif (rate_mask)\n\t\treturn find_last_bit(&rate_mask, BITS_PER_LONG);\n\treturn IWL_RATE_INVALID;\n}\n\nstatic int rs_get_max_allowed_rate(struct iwl_lq_sta *lq_sta,\n\t\t\t\t   const struct rs_tx_column *column)\n{\n\tswitch (column->mode) {\n\tcase RS_LEGACY:\n\t\treturn lq_sta->max_legacy_rate_idx;\n\tcase RS_SISO:\n\t\treturn lq_sta->max_siso_rate_idx;\n\tcase RS_MIMO2:\n\t\treturn lq_sta->max_mimo2_rate_idx;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\n\treturn lq_sta->max_legacy_rate_idx;\n}\n\nstatic const u16 *rs_get_expected_tpt_table(struct iwl_lq_sta *lq_sta,\n\t\t\t\t\t    const struct rs_tx_column *column,\n\t\t\t\t\t    u32 bw)\n{\n\t \n\tconst u16 (*ht_tbl_pointer)[IWL_RATE_COUNT];\n\n\tif (WARN_ON_ONCE(column->mode != RS_LEGACY &&\n\t\t\t column->mode != RS_SISO &&\n\t\t\t column->mode != RS_MIMO2))\n\t\treturn expected_tpt_legacy;\n\n\t \n\tif (column->mode == RS_LEGACY)\n\t\treturn expected_tpt_legacy;\n\n\tht_tbl_pointer = expected_tpt_mimo2_20MHz;\n\t \n\tif (column->mode == RS_SISO) {\n\t\tswitch (bw) {\n\t\tcase RATE_MCS_CHAN_WIDTH_20:\n\t\t\tht_tbl_pointer = expected_tpt_siso_20MHz;\n\t\t\tbreak;\n\t\tcase RATE_MCS_CHAN_WIDTH_40:\n\t\t\tht_tbl_pointer = expected_tpt_siso_40MHz;\n\t\t\tbreak;\n\t\tcase RATE_MCS_CHAN_WIDTH_80:\n\t\t\tht_tbl_pointer = expected_tpt_siso_80MHz;\n\t\t\tbreak;\n\t\tcase RATE_MCS_CHAN_WIDTH_160:\n\t\t\tht_tbl_pointer = expected_tpt_siso_160MHz;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\t} else if (column->mode == RS_MIMO2) {\n\t\tswitch (bw) {\n\t\tcase RATE_MCS_CHAN_WIDTH_20:\n\t\t\tht_tbl_pointer = expected_tpt_mimo2_20MHz;\n\t\t\tbreak;\n\t\tcase RATE_MCS_CHAN_WIDTH_40:\n\t\t\tht_tbl_pointer = expected_tpt_mimo2_40MHz;\n\t\t\tbreak;\n\t\tcase RATE_MCS_CHAN_WIDTH_80:\n\t\t\tht_tbl_pointer = expected_tpt_mimo2_80MHz;\n\t\t\tbreak;\n\t\tcase RATE_MCS_CHAN_WIDTH_160:\n\t\t\tht_tbl_pointer = expected_tpt_mimo2_160MHz;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\t} else {\n\t\tWARN_ON_ONCE(1);\n\t}\n\n\tif (!column->sgi && !lq_sta->is_agg)\t\t \n\t\treturn ht_tbl_pointer[0];\n\telse if (column->sgi && !lq_sta->is_agg)         \n\t\treturn ht_tbl_pointer[1];\n\telse if (!column->sgi && lq_sta->is_agg)         \n\t\treturn ht_tbl_pointer[2];\n\telse\t\t\t\t\t\t \n\t\treturn ht_tbl_pointer[3];\n}\n\nstatic void rs_set_expected_tpt_table(struct iwl_lq_sta *lq_sta,\n\t\t\t\t      struct iwl_scale_tbl_info *tbl)\n{\n\tstruct rs_rate *rate = &tbl->rate;\n\tconst struct rs_tx_column *column = &rs_tx_columns[tbl->column];\n\n\ttbl->expected_tpt = rs_get_expected_tpt_table(lq_sta, column, rate->bw);\n}\n\n \nstatic inline u8 rs_search_tbl(u8 active_tbl)\n{\n\treturn (active_tbl ^ 1) & 1;\n}\n\nstatic s32 rs_get_best_rate(struct iwl_mvm *mvm,\n\t\t\t    struct iwl_lq_sta *lq_sta,\n\t\t\t    struct iwl_scale_tbl_info *tbl,\t \n\t\t\t    unsigned long rate_mask, s8 index)\n{\n\tstruct iwl_scale_tbl_info *active_tbl =\n\t    &(lq_sta->lq_info[lq_sta->active_tbl]);\n\ts32 success_ratio = active_tbl->win[index].success_ratio;\n\tu16 expected_current_tpt = active_tbl->expected_tpt[index];\n\tconst u16 *tpt_tbl = tbl->expected_tpt;\n\tu16 high_low;\n\tu32 target_tpt;\n\tint rate_idx;\n\n\tif (success_ratio >= RS_PERCENT(IWL_MVM_RS_SR_NO_DECREASE)) {\n\t\ttarget_tpt = 100 * expected_current_tpt;\n\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t       \"SR %d high. Find rate exceeding EXPECTED_CURRENT %d\\n\",\n\t\t\t       success_ratio, target_tpt);\n\t} else {\n\t\ttarget_tpt = lq_sta->last_tpt;\n\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t       \"SR %d not that good. Find rate exceeding ACTUAL_TPT %d\\n\",\n\t\t\t       success_ratio, target_tpt);\n\t}\n\n\trate_idx = find_first_bit(&rate_mask, BITS_PER_LONG);\n\n\twhile (rate_idx != IWL_RATE_INVALID) {\n\t\tif (target_tpt < (100 * tpt_tbl[rate_idx]))\n\t\t\tbreak;\n\n\t\thigh_low = rs_get_adjacent_rate(mvm, rate_idx, rate_mask,\n\t\t\t\t\t\ttbl->rate.type);\n\n\t\trate_idx = (high_low >> 8) & 0xff;\n\t}\n\n\tIWL_DEBUG_RATE(mvm, \"Best rate found %d target_tp %d expected_new %d\\n\",\n\t\t       rate_idx, target_tpt,\n\t\t       rate_idx != IWL_RATE_INVALID ?\n\t\t       100 * tpt_tbl[rate_idx] : IWL_INVALID_VALUE);\n\n\treturn rate_idx;\n}\n\nstatic u32 rs_bw_from_sta_bw(struct ieee80211_sta *sta)\n{\n\tstruct ieee80211_sta_vht_cap *sta_vht_cap = &sta->deflink.vht_cap;\n\tstruct ieee80211_vht_cap vht_cap = {\n\t\t.vht_cap_info = cpu_to_le32(sta_vht_cap->cap),\n\t\t.supp_mcs = sta_vht_cap->vht_mcs,\n\t};\n\n\tswitch (sta->deflink.bandwidth) {\n\tcase IEEE80211_STA_RX_BW_160:\n\t\t \n\t\tif (ieee80211_get_vht_max_nss(&vht_cap,\n\t\t\t\t\t      IEEE80211_VHT_CHANWIDTH_160MHZ,\n\t\t\t\t\t      0, true,\n\t\t\t\t\t      sta->deflink.rx_nss) < sta->deflink.rx_nss)\n\t\t\treturn RATE_MCS_CHAN_WIDTH_80;\n\t\treturn RATE_MCS_CHAN_WIDTH_160;\n\tcase IEEE80211_STA_RX_BW_80:\n\t\treturn RATE_MCS_CHAN_WIDTH_80;\n\tcase IEEE80211_STA_RX_BW_40:\n\t\treturn RATE_MCS_CHAN_WIDTH_40;\n\tcase IEEE80211_STA_RX_BW_20:\n\tdefault:\n\t\treturn RATE_MCS_CHAN_WIDTH_20;\n\t}\n}\n\n \nstatic void rs_stay_in_table(struct iwl_lq_sta *lq_sta, bool force_search)\n{\n\tstruct iwl_scale_tbl_info *tbl;\n\tint active_tbl;\n\tint flush_interval_passed = 0;\n\tstruct iwl_mvm *mvm;\n\n\tmvm = lq_sta->pers.drv;\n\tactive_tbl = lq_sta->active_tbl;\n\n\ttbl = &(lq_sta->lq_info[active_tbl]);\n\n\t \n\tif (lq_sta->rs_state == RS_STATE_STAY_IN_COLUMN) {\n\t\t \n\t\tif (lq_sta->flush_timer)\n\t\t\tflush_interval_passed =\n\t\t\t\ttime_after(jiffies,\n\t\t\t\t\t   (unsigned long)(lq_sta->flush_timer +\n\t\t\t\t\t\t\t   (IWL_MVM_RS_STAY_IN_COLUMN_TIMEOUT * HZ)));\n\n\t\t \n\t\tif (force_search ||\n\t\t    (lq_sta->total_failed > lq_sta->max_failure_limit) ||\n\t\t    (lq_sta->total_success > lq_sta->max_success_limit) ||\n\t\t    ((!lq_sta->search_better_tbl) &&\n\t\t     (lq_sta->flush_timer) && (flush_interval_passed))) {\n\t\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t\t       \"LQ: stay is expired %d %d %d\\n\",\n\t\t\t\t     lq_sta->total_failed,\n\t\t\t\t     lq_sta->total_success,\n\t\t\t\t     flush_interval_passed);\n\n\t\t\t \n\t\t\tlq_sta->rs_state = RS_STATE_SEARCH_CYCLE_STARTED;\n\t\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t\t       \"Moving to RS_STATE_SEARCH_CYCLE_STARTED\\n\");\n\t\t\tlq_sta->total_failed = 0;\n\t\t\tlq_sta->total_success = 0;\n\t\t\tlq_sta->flush_timer = 0;\n\t\t\t \n\t\t\tlq_sta->visited_columns = BIT(tbl->column);\n\t\t \n\t\t} else {\n\t\t\tlq_sta->table_count++;\n\t\t\tif (lq_sta->table_count >=\n\t\t\t    lq_sta->table_count_limit) {\n\t\t\t\tlq_sta->table_count = 0;\n\n\t\t\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t\t\t       \"LQ: stay in table clear win\\n\");\n\t\t\t\trs_rate_scale_clear_tbl_windows(mvm, tbl);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (lq_sta->rs_state == RS_STATE_SEARCH_CYCLE_STARTED) {\n\t\t\trs_rate_scale_clear_tbl_windows(mvm, tbl);\n\t\t}\n\t}\n}\n\nstatic void rs_set_amsdu_len(struct iwl_mvm *mvm, struct ieee80211_sta *sta,\n\t\t\t     struct iwl_scale_tbl_info *tbl,\n\t\t\t     enum rs_action scale_action)\n{\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct ieee80211_bss_conf *bss_conf = &mvmsta->vif->bss_conf;\n\tint i;\n\n\tsta->deflink.agg.max_amsdu_len =\n\t\trs_fw_get_max_amsdu_len(sta, bss_conf, &sta->deflink);\n\n\t \n\tif ((!is_vht(&tbl->rate) && !is_ht(&tbl->rate)) ||\n\t    tbl->rate.index < IWL_RATE_MCS_5_INDEX ||\n\t    scale_action == RS_ACTION_DOWNSCALE)\n\t\tmvmsta->amsdu_enabled = 0;\n\telse\n\t\tmvmsta->amsdu_enabled = 0xFFFF;\n\n\tif (bss_conf->he_support &&\n\t    !iwlwifi_mod_params.disable_11ax)\n\t\tmvmsta->max_amsdu_len = sta->deflink.agg.max_amsdu_len;\n\telse\n\t\tmvmsta->max_amsdu_len =\n\t\t\tmin_t(int, sta->deflink.agg.max_amsdu_len, 8500);\n\n\tsta->deflink.agg.max_rc_amsdu_len = mvmsta->max_amsdu_len;\n\n\tfor (i = 0; i < IWL_MAX_TID_COUNT; i++) {\n\t\tif (mvmsta->amsdu_enabled)\n\t\t\tsta->deflink.agg.max_tid_amsdu_len[i] =\n\t\t\t\tiwl_mvm_max_amsdu_size(mvm, sta, i);\n\t\telse\n\t\t\t \n\t\t\tsta->deflink.agg.max_tid_amsdu_len[i] = 1;\n\t}\n}\n\n \nstatic void rs_update_rate_tbl(struct iwl_mvm *mvm,\n\t\t\t       struct ieee80211_sta *sta,\n\t\t\t       struct iwl_lq_sta *lq_sta,\n\t\t\t       struct iwl_scale_tbl_info *tbl)\n{\n\trs_fill_lq_cmd(mvm, sta, lq_sta, &tbl->rate);\n\tiwl_mvm_send_lq_cmd(mvm, &lq_sta->lq);\n}\n\nstatic bool rs_tweak_rate_tbl(struct iwl_mvm *mvm,\n\t\t\t      struct ieee80211_sta *sta,\n\t\t\t      struct iwl_lq_sta *lq_sta,\n\t\t\t      struct iwl_scale_tbl_info *tbl,\n\t\t\t      enum rs_action scale_action)\n{\n\tif (rs_bw_from_sta_bw(sta) != RATE_MCS_CHAN_WIDTH_80)\n\t\treturn false;\n\n\tif (!is_vht_siso(&tbl->rate))\n\t\treturn false;\n\n\tif ((tbl->rate.bw == RATE_MCS_CHAN_WIDTH_80) &&\n\t    (tbl->rate.index == IWL_RATE_MCS_0_INDEX) &&\n\t    (scale_action == RS_ACTION_DOWNSCALE)) {\n\t\ttbl->rate.bw = RATE_MCS_CHAN_WIDTH_20;\n\t\ttbl->rate.index = IWL_RATE_MCS_4_INDEX;\n\t\tIWL_DEBUG_RATE(mvm, \"Switch 80Mhz SISO MCS0 -> 20Mhz MCS4\\n\");\n\t\tgoto tweaked;\n\t}\n\n\t \n\tif ((tbl->rate.bw == RATE_MCS_CHAN_WIDTH_20) &&\n\t    (((tbl->rate.index == IWL_RATE_MCS_5_INDEX) &&\n\t     (scale_action == RS_ACTION_STAY)) ||\n\t     ((tbl->rate.index > IWL_RATE_MCS_5_INDEX) &&\n\t      (scale_action == RS_ACTION_UPSCALE)))) {\n\t\ttbl->rate.bw = RATE_MCS_CHAN_WIDTH_80;\n\t\ttbl->rate.index = IWL_RATE_MCS_1_INDEX;\n\t\tIWL_DEBUG_RATE(mvm, \"Switch 20Mhz SISO MCS5 -> 80Mhz MCS1\\n\");\n\t\tgoto tweaked;\n\t}\n\n\treturn false;\n\ntweaked:\n\trs_set_expected_tpt_table(lq_sta, tbl);\n\trs_rate_scale_clear_tbl_windows(mvm, tbl);\n\treturn true;\n}\n\nstatic enum rs_column rs_get_next_column(struct iwl_mvm *mvm,\n\t\t\t\t\t struct iwl_lq_sta *lq_sta,\n\t\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t\t struct iwl_scale_tbl_info *tbl)\n{\n\tint i, j, max_rate;\n\tenum rs_column next_col_id;\n\tconst struct rs_tx_column *curr_col = &rs_tx_columns[tbl->column];\n\tconst struct rs_tx_column *next_col;\n\tallow_column_func_t allow_func;\n\tu8 valid_ants = iwl_mvm_get_valid_tx_ant(mvm);\n\tconst u16 *expected_tpt_tbl;\n\tu16 tpt, max_expected_tpt;\n\n\tfor (i = 0; i < MAX_NEXT_COLUMNS; i++) {\n\t\tnext_col_id = curr_col->next_columns[i];\n\n\t\tif (next_col_id == RS_COLUMN_INVALID)\n\t\t\tcontinue;\n\n\t\tif (lq_sta->visited_columns & BIT(next_col_id)) {\n\t\t\tIWL_DEBUG_RATE(mvm, \"Skip already visited column %d\\n\",\n\t\t\t\t       next_col_id);\n\t\t\tcontinue;\n\t\t}\n\n\t\tnext_col = &rs_tx_columns[next_col_id];\n\n\t\tif (!rs_is_valid_ant(valid_ants, next_col->ant)) {\n\t\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t\t       \"Skip column %d as ANT config isn't supported by chip. valid_ants 0x%x column ant 0x%x\\n\",\n\t\t\t\t       next_col_id, valid_ants, next_col->ant);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < MAX_COLUMN_CHECKS; j++) {\n\t\t\tallow_func = next_col->checks[j];\n\t\t\tif (allow_func && !allow_func(mvm, sta, &tbl->rate,\n\t\t\t\t\t\t      next_col))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (j != MAX_COLUMN_CHECKS) {\n\t\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t\t       \"Skip column %d: not allowed (check %d failed)\\n\",\n\t\t\t\t       next_col_id, j);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\ttpt = lq_sta->last_tpt / 100;\n\t\texpected_tpt_tbl = rs_get_expected_tpt_table(lq_sta, next_col,\n\t\t\t\t\t\t     rs_bw_from_sta_bw(sta));\n\t\tif (WARN_ON_ONCE(!expected_tpt_tbl))\n\t\t\tcontinue;\n\n\t\tmax_rate = rs_get_max_allowed_rate(lq_sta, next_col);\n\t\tif (max_rate == IWL_RATE_INVALID) {\n\t\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t\t       \"Skip column %d: no rate is allowed in this column\\n\",\n\t\t\t\t       next_col_id);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmax_expected_tpt = expected_tpt_tbl[max_rate];\n\t\tif (tpt >= max_expected_tpt) {\n\t\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t\t       \"Skip column %d: can't beat current TPT. Max expected %d current %d\\n\",\n\t\t\t\t       next_col_id, max_expected_tpt, tpt);\n\t\t\tcontinue;\n\t\t}\n\n\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t       \"Found potential column %d. Max expected %d current %d\\n\",\n\t\t\t       next_col_id, max_expected_tpt, tpt);\n\t\tbreak;\n\t}\n\n\tif (i == MAX_NEXT_COLUMNS)\n\t\treturn RS_COLUMN_INVALID;\n\n\treturn next_col_id;\n}\n\nstatic int rs_switch_to_column(struct iwl_mvm *mvm,\n\t\t\t       struct iwl_lq_sta *lq_sta,\n\t\t\t       struct ieee80211_sta *sta,\n\t\t\t       enum rs_column col_id)\n{\n\tstruct iwl_scale_tbl_info *tbl = &lq_sta->lq_info[lq_sta->active_tbl];\n\tstruct iwl_scale_tbl_info *search_tbl =\n\t\t&lq_sta->lq_info[rs_search_tbl(lq_sta->active_tbl)];\n\tstruct rs_rate *rate = &search_tbl->rate;\n\tconst struct rs_tx_column *column = &rs_tx_columns[col_id];\n\tconst struct rs_tx_column *curr_column = &rs_tx_columns[tbl->column];\n\tunsigned long rate_mask = 0;\n\tu32 rate_idx = 0;\n\n\tmemcpy(search_tbl, tbl, offsetof(struct iwl_scale_tbl_info, win));\n\n\trate->sgi = column->sgi;\n\trate->ant = column->ant;\n\n\tif (column->mode == RS_LEGACY) {\n\t\tif (lq_sta->band == NL80211_BAND_5GHZ)\n\t\t\trate->type = LQ_LEGACY_A;\n\t\telse\n\t\t\trate->type = LQ_LEGACY_G;\n\n\t\trate->bw = RATE_MCS_CHAN_WIDTH_20;\n\t\trate->ldpc = false;\n\t\trate_mask = lq_sta->active_legacy_rate;\n\t} else if (column->mode == RS_SISO) {\n\t\trate->type = lq_sta->is_vht ? LQ_VHT_SISO : LQ_HT_SISO;\n\t\trate_mask = lq_sta->active_siso_rate;\n\t} else if (column->mode == RS_MIMO2) {\n\t\trate->type = lq_sta->is_vht ? LQ_VHT_MIMO2 : LQ_HT_MIMO2;\n\t\trate_mask = lq_sta->active_mimo2_rate;\n\t} else {\n\t\tWARN_ONCE(1, \"Bad column mode\");\n\t}\n\n\tif (column->mode != RS_LEGACY) {\n\t\trate->bw = rs_bw_from_sta_bw(sta);\n\t\trate->ldpc = lq_sta->ldpc;\n\t}\n\n\tsearch_tbl->column = col_id;\n\trs_set_expected_tpt_table(lq_sta, search_tbl);\n\n\tlq_sta->visited_columns |= BIT(col_id);\n\n\t \n\tif (curr_column->mode != column->mode) {\n\t\trate_idx = rs_get_best_rate(mvm, lq_sta, search_tbl,\n\t\t\t\t\t    rate_mask, rate->index);\n\n\t\tif ((rate_idx == IWL_RATE_INVALID) ||\n\t\t    !(BIT(rate_idx) & rate_mask)) {\n\t\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t\t       \"can not switch with index %d\"\n\t\t\t\t       \" rate mask %lx\\n\",\n\t\t\t\t       rate_idx, rate_mask);\n\n\t\t\tgoto err;\n\t\t}\n\n\t\trate->index = rate_idx;\n\t}\n\n\tIWL_DEBUG_RATE(mvm, \"Switched to column %d: Index %d\\n\",\n\t\t       col_id, rate->index);\n\n\treturn 0;\n\nerr:\n\trate->type = LQ_NONE;\n\treturn -1;\n}\n\nstatic enum rs_action rs_get_rate_action(struct iwl_mvm *mvm,\n\t\t\t\t\t struct iwl_scale_tbl_info *tbl,\n\t\t\t\t\t s32 sr, int low, int high,\n\t\t\t\t\t int current_tpt,\n\t\t\t\t\t int low_tpt, int high_tpt)\n{\n\tenum rs_action action = RS_ACTION_STAY;\n\n\tif ((sr <= RS_PERCENT(IWL_MVM_RS_SR_FORCE_DECREASE)) ||\n\t    (current_tpt == 0)) {\n\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t       \"Decrease rate because of low SR\\n\");\n\t\treturn RS_ACTION_DOWNSCALE;\n\t}\n\n\tif ((low_tpt == IWL_INVALID_VALUE) &&\n\t    (high_tpt == IWL_INVALID_VALUE) &&\n\t    (high != IWL_RATE_INVALID)) {\n\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t       \"No data about high/low rates. Increase rate\\n\");\n\t\treturn RS_ACTION_UPSCALE;\n\t}\n\n\tif ((high_tpt == IWL_INVALID_VALUE) &&\n\t    (high != IWL_RATE_INVALID) &&\n\t    (low_tpt != IWL_INVALID_VALUE) &&\n\t    (low_tpt < current_tpt)) {\n\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t       \"No data about high rate and low rate is worse. Increase rate\\n\");\n\t\treturn RS_ACTION_UPSCALE;\n\t}\n\n\tif ((high_tpt != IWL_INVALID_VALUE) &&\n\t    (high_tpt > current_tpt)) {\n\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t       \"Higher rate is better. Increate rate\\n\");\n\t\treturn RS_ACTION_UPSCALE;\n\t}\n\n\tif ((low_tpt != IWL_INVALID_VALUE) &&\n\t    (high_tpt != IWL_INVALID_VALUE) &&\n\t    (low_tpt < current_tpt) &&\n\t    (high_tpt < current_tpt)) {\n\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t       \"Both high and low are worse. Maintain rate\\n\");\n\t\treturn RS_ACTION_STAY;\n\t}\n\n\tif ((low_tpt != IWL_INVALID_VALUE) &&\n\t    (low_tpt > current_tpt)) {\n\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t       \"Lower rate is better\\n\");\n\t\taction = RS_ACTION_DOWNSCALE;\n\t\tgoto out;\n\t}\n\n\tif ((low_tpt == IWL_INVALID_VALUE) &&\n\t    (low != IWL_RATE_INVALID)) {\n\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t       \"No data about lower rate\\n\");\n\t\taction = RS_ACTION_DOWNSCALE;\n\t\tgoto out;\n\t}\n\n\tIWL_DEBUG_RATE(mvm, \"Maintain rate\\n\");\n\nout:\n\tif ((action == RS_ACTION_DOWNSCALE) && (low != IWL_RATE_INVALID)) {\n\t\tif (sr >= RS_PERCENT(IWL_MVM_RS_SR_NO_DECREASE)) {\n\t\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t\t       \"SR is above NO DECREASE. Avoid downscale\\n\");\n\t\t\taction = RS_ACTION_STAY;\n\t\t} else if (current_tpt > (100 * tbl->expected_tpt[low])) {\n\t\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t\t       \"Current TPT is higher than max expected in low rate. Avoid downscale\\n\");\n\t\t\taction = RS_ACTION_STAY;\n\t\t} else {\n\t\t\tIWL_DEBUG_RATE(mvm, \"Decrease rate\\n\");\n\t\t}\n\t}\n\n\treturn action;\n}\n\nstatic bool rs_stbc_allow(struct iwl_mvm *mvm, struct ieee80211_sta *sta,\n\t\t\t  struct iwl_lq_sta *lq_sta)\n{\n\t \n\tif (!lq_sta->stbc_capable)\n\t\treturn false;\n\n\tif (!iwl_mvm_bt_coex_is_mimo_allowed(mvm, sta))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void rs_get_adjacent_txp(struct iwl_mvm *mvm, int index,\n\t\t\t\tint *weaker, int *stronger)\n{\n\t*weaker = index + IWL_MVM_RS_TPC_TX_POWER_STEP;\n\tif (*weaker > TPC_MAX_REDUCTION)\n\t\t*weaker = TPC_INVALID;\n\n\t*stronger = index - IWL_MVM_RS_TPC_TX_POWER_STEP;\n\tif (*stronger < 0)\n\t\t*stronger = TPC_INVALID;\n}\n\nstatic bool rs_tpc_allowed(struct iwl_mvm *mvm, struct ieee80211_vif *vif,\n\t\t\t   struct rs_rate *rate, enum nl80211_band band)\n{\n\tint index = rate->index;\n\tbool cam = (iwlmvm_mod_params.power_scheme == IWL_POWER_SCHEME_CAM);\n\tbool sta_ps_disabled = (vif->type == NL80211_IFTYPE_STATION &&\n\t\t\t\t!vif->cfg.ps);\n\n\tIWL_DEBUG_RATE(mvm, \"cam: %d sta_ps_disabled %d\\n\",\n\t\t       cam, sta_ps_disabled);\n\t \n\tif ((cam || sta_ps_disabled) &&\n\t    !iwl_mvm_bt_coex_is_tpc_allowed(mvm, band))\n\t\treturn false;\n\n\tIWL_DEBUG_RATE(mvm, \"check rate, table type: %d\\n\", rate->type);\n\tif (is_legacy(rate))\n\t\treturn index == IWL_RATE_54M_INDEX;\n\tif (is_ht(rate))\n\t\treturn index == IWL_RATE_MCS_7_INDEX;\n\tif (is_vht(rate))\n\t\treturn index == IWL_RATE_MCS_9_INDEX;\n\n\tWARN_ON_ONCE(1);\n\treturn false;\n}\n\nenum tpc_action {\n\tTPC_ACTION_STAY,\n\tTPC_ACTION_DECREASE,\n\tTPC_ACTION_INCREASE,\n\tTPC_ACTION_NO_RESTIRCTION,\n};\n\nstatic enum tpc_action rs_get_tpc_action(struct iwl_mvm *mvm,\n\t\t\t\t\t s32 sr, int weak, int strong,\n\t\t\t\t\t int current_tpt,\n\t\t\t\t\t int weak_tpt, int strong_tpt)\n{\n\t \n\tif (current_tpt == IWL_INVALID_VALUE) {\n\t\tIWL_DEBUG_RATE(mvm, \"no current tpt. stay.\\n\");\n\t\treturn TPC_ACTION_STAY;\n\t}\n\n\t \n\tif (sr <= RS_PERCENT(IWL_MVM_RS_TPC_SR_FORCE_INCREASE) ||\n\t    current_tpt == 0) {\n\t\tIWL_DEBUG_RATE(mvm, \"increase txp because of weak SR\\n\");\n\t\treturn TPC_ACTION_NO_RESTIRCTION;\n\t}\n\n\t \n\tif (sr >= RS_PERCENT(IWL_MVM_RS_TPC_SR_NO_INCREASE) &&\n\t    weak != TPC_INVALID) {\n\t\tif (weak_tpt == IWL_INVALID_VALUE &&\n\t\t    (strong_tpt == IWL_INVALID_VALUE ||\n\t\t     current_tpt >= strong_tpt)) {\n\t\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t\t       \"no weak txp measurement. decrease txp\\n\");\n\t\t\treturn TPC_ACTION_DECREASE;\n\t\t}\n\n\t\tif (weak_tpt > current_tpt) {\n\t\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t\t       \"lower txp has better tpt. decrease txp\\n\");\n\t\t\treturn TPC_ACTION_DECREASE;\n\t\t}\n\t}\n\n\t \n\tif (sr < RS_PERCENT(IWL_MVM_RS_TPC_SR_NO_INCREASE) &&\n\t    strong != TPC_INVALID) {\n\t\tif (weak_tpt == IWL_INVALID_VALUE &&\n\t\t    strong_tpt != IWL_INVALID_VALUE &&\n\t\t    current_tpt < strong_tpt) {\n\t\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t\t       \"higher txp has better tpt. increase txp\\n\");\n\t\t\treturn TPC_ACTION_INCREASE;\n\t\t}\n\n\t\tif (weak_tpt < current_tpt &&\n\t\t    (strong_tpt == IWL_INVALID_VALUE ||\n\t\t     strong_tpt > current_tpt)) {\n\t\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t\t       \"lower txp has worse tpt. increase txp\\n\");\n\t\t\treturn TPC_ACTION_INCREASE;\n\t\t}\n\t}\n\n\tIWL_DEBUG_RATE(mvm, \"no need to increase or decrease txp - stay\\n\");\n\treturn TPC_ACTION_STAY;\n}\n\nstatic bool rs_tpc_perform(struct iwl_mvm *mvm,\n\t\t\t   struct ieee80211_sta *sta,\n\t\t\t   struct iwl_lq_sta *lq_sta,\n\t\t\t   struct iwl_scale_tbl_info *tbl)\n{\n\tstruct iwl_mvm_sta *mvm_sta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct ieee80211_vif *vif = mvm_sta->vif;\n\tstruct ieee80211_chanctx_conf *chanctx_conf;\n\tenum nl80211_band band;\n\tstruct iwl_rate_scale_data *window;\n\tstruct rs_rate *rate = &tbl->rate;\n\tenum tpc_action action;\n\ts32 sr;\n\tu8 cur = lq_sta->lq.reduced_tpc;\n\tint current_tpt;\n\tint weak, strong;\n\tint weak_tpt = IWL_INVALID_VALUE, strong_tpt = IWL_INVALID_VALUE;\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tif (lq_sta->pers.dbg_fixed_txp_reduction <= TPC_MAX_REDUCTION) {\n\t\tIWL_DEBUG_RATE(mvm, \"fixed tpc: %d\\n\",\n\t\t\t       lq_sta->pers.dbg_fixed_txp_reduction);\n\t\tlq_sta->lq.reduced_tpc = lq_sta->pers.dbg_fixed_txp_reduction;\n\t\treturn cur != lq_sta->pers.dbg_fixed_txp_reduction;\n\t}\n#endif\n\n\trcu_read_lock();\n\tchanctx_conf = rcu_dereference(vif->bss_conf.chanctx_conf);\n\tif (WARN_ON(!chanctx_conf))\n\t\tband = NUM_NL80211_BANDS;\n\telse\n\t\tband = chanctx_conf->def.chan->band;\n\trcu_read_unlock();\n\n\tif (!rs_tpc_allowed(mvm, vif, rate, band)) {\n\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t       \"tpc is not allowed. remove txp restrictions\\n\");\n\t\tlq_sta->lq.reduced_tpc = TPC_NO_REDUCTION;\n\t\treturn cur != TPC_NO_REDUCTION;\n\t}\n\n\trs_get_adjacent_txp(mvm, cur, &weak, &strong);\n\n\t \n\twindow = tbl->tpc_win;\n\tsr = window[cur].success_ratio;\n\tcurrent_tpt = window[cur].average_tpt;\n\tif (weak != TPC_INVALID)\n\t\tweak_tpt = window[weak].average_tpt;\n\tif (strong != TPC_INVALID)\n\t\tstrong_tpt = window[strong].average_tpt;\n\n\tIWL_DEBUG_RATE(mvm,\n\t\t       \"(TPC: %d): cur_tpt %d SR %d weak %d strong %d weak_tpt %d strong_tpt %d\\n\",\n\t\t       cur, current_tpt, sr, weak, strong,\n\t\t       weak_tpt, strong_tpt);\n\n\taction = rs_get_tpc_action(mvm, sr, weak, strong,\n\t\t\t\t   current_tpt, weak_tpt, strong_tpt);\n\n\t \n\tif (weak == TPC_INVALID && action == TPC_ACTION_DECREASE) {\n\t\tIWL_DEBUG_RATE(mvm, \"already in lowest txp, stay\\n\");\n\t\taction = TPC_ACTION_STAY;\n\t} else if (strong == TPC_INVALID &&\n\t\t   (action == TPC_ACTION_INCREASE ||\n\t\t    action == TPC_ACTION_NO_RESTIRCTION)) {\n\t\tIWL_DEBUG_RATE(mvm, \"already in highest txp, stay\\n\");\n\t\taction = TPC_ACTION_STAY;\n\t}\n\n\tswitch (action) {\n\tcase TPC_ACTION_DECREASE:\n\t\tlq_sta->lq.reduced_tpc = weak;\n\t\treturn true;\n\tcase TPC_ACTION_INCREASE:\n\t\tlq_sta->lq.reduced_tpc = strong;\n\t\treturn true;\n\tcase TPC_ACTION_NO_RESTIRCTION:\n\t\tlq_sta->lq.reduced_tpc = TPC_NO_REDUCTION;\n\t\treturn true;\n\tcase TPC_ACTION_STAY:\n\t\t \n\t\tbreak;\n\t}\n\treturn false;\n}\n\n \nstatic void rs_rate_scale_perform(struct iwl_mvm *mvm,\n\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t  struct iwl_lq_sta *lq_sta,\n\t\t\t\t  int tid, bool ndp)\n{\n\tint low = IWL_RATE_INVALID;\n\tint high = IWL_RATE_INVALID;\n\tint index;\n\tstruct iwl_rate_scale_data *window = NULL;\n\tint current_tpt = IWL_INVALID_VALUE;\n\tint low_tpt = IWL_INVALID_VALUE;\n\tint high_tpt = IWL_INVALID_VALUE;\n\tu32 fail_count;\n\tenum rs_action scale_action = RS_ACTION_STAY;\n\tu16 rate_mask;\n\tu8 update_lq = 0;\n\tstruct iwl_scale_tbl_info *tbl, *tbl1;\n\tu8 active_tbl = 0;\n\tu8 done_search = 0;\n\tu16 high_low;\n\ts32 sr;\n\tu8 prev_agg = lq_sta->is_agg;\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct rs_rate *rate;\n\n\tlq_sta->is_agg = !!mvmsta->agg_tids;\n\n\t \n\tif (!lq_sta->search_better_tbl)\n\t\tactive_tbl = lq_sta->active_tbl;\n\telse\n\t\tactive_tbl = rs_search_tbl(lq_sta->active_tbl);\n\n\ttbl = &(lq_sta->lq_info[active_tbl]);\n\trate = &tbl->rate;\n\n\tif (prev_agg != lq_sta->is_agg) {\n\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t       \"Aggregation changed: prev %d current %d. Update expected TPT table\\n\",\n\t\t\t       prev_agg, lq_sta->is_agg);\n\t\trs_set_expected_tpt_table(lq_sta, tbl);\n\t\trs_rate_scale_clear_tbl_windows(mvm, tbl);\n\t}\n\n\t \n\tindex = rate->index;\n\n\t \n\trate_mask = rs_get_supported_rates(lq_sta, rate);\n\n\tif (!(BIT(index) & rate_mask)) {\n\t\tIWL_ERR(mvm, \"Current Rate is not valid\\n\");\n\t\tif (lq_sta->search_better_tbl) {\n\t\t\t \n\t\t\trate->type = LQ_NONE;\n\t\t\tlq_sta->search_better_tbl = 0;\n\t\t\ttbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\n\t\t\trs_update_rate_tbl(mvm, sta, lq_sta, tbl);\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tif (!tbl->expected_tpt) {\n\t\tIWL_ERR(mvm, \"tbl->expected_tpt is NULL\\n\");\n\t\treturn;\n\t}\n\n\t \n\twindow = &(tbl->win[index]);\n\n\t \n\tfail_count = window->counter - window->success_counter;\n\tif ((fail_count < IWL_MVM_RS_RATE_MIN_FAILURE_TH) &&\n\t    (window->success_counter < IWL_MVM_RS_RATE_MIN_SUCCESS_TH)) {\n\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t       \"%s: Test Window: succ %d total %d\\n\",\n\t\t\t       rs_pretty_rate(rate),\n\t\t\t       window->success_counter, window->counter);\n\n\t\t \n\t\twindow->average_tpt = IWL_INVALID_VALUE;\n\n\t\t \n\t\trs_stay_in_table(lq_sta, false);\n\n\t\treturn;\n\t}\n\n\t \n\tif (lq_sta->search_better_tbl) {\n\t\t \n\t\tif (window->average_tpt > lq_sta->last_tpt) {\n\t\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t\t       \"SWITCHING TO NEW TABLE SR: %d \"\n\t\t\t\t       \"cur-tpt %d old-tpt %d\\n\",\n\t\t\t\t       window->success_ratio,\n\t\t\t\t       window->average_tpt,\n\t\t\t\t       lq_sta->last_tpt);\n\n\t\t\t \n\t\t\tlq_sta->active_tbl = active_tbl;\n\t\t\tcurrent_tpt = window->average_tpt;\n\t\t \n\t\t} else {\n\t\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t\t       \"GOING BACK TO THE OLD TABLE: SR %d \"\n\t\t\t\t       \"cur-tpt %d old-tpt %d\\n\",\n\t\t\t\t       window->success_ratio,\n\t\t\t\t       window->average_tpt,\n\t\t\t\t       lq_sta->last_tpt);\n\n\t\t\t \n\t\t\trate->type = LQ_NONE;\n\n\t\t\t \n\t\t\tactive_tbl = lq_sta->active_tbl;\n\t\t\ttbl = &(lq_sta->lq_info[active_tbl]);\n\n\t\t\t \n\t\t\tindex = tbl->rate.index;\n\t\t\tcurrent_tpt = lq_sta->last_tpt;\n\n\t\t\t \n\t\t\tupdate_lq = 1;\n\t\t}\n\n\t\t \n\t\tlq_sta->search_better_tbl = 0;\n\t\tdone_search = 1;\t \n\t\tgoto lq_update;\n\t}\n\n\t \n\thigh_low = rs_get_adjacent_rate(mvm, index, rate_mask, rate->type);\n\tlow = high_low & 0xff;\n\thigh = (high_low >> 8) & 0xff;\n\n\t \n\n\tsr = window->success_ratio;\n\n\t \n\tcurrent_tpt = window->average_tpt;\n\tif (low != IWL_RATE_INVALID)\n\t\tlow_tpt = tbl->win[low].average_tpt;\n\tif (high != IWL_RATE_INVALID)\n\t\thigh_tpt = tbl->win[high].average_tpt;\n\n\tIWL_DEBUG_RATE(mvm,\n\t\t       \"%s: cur_tpt %d SR %d low %d high %d low_tpt %d high_tpt %d\\n\",\n\t\t       rs_pretty_rate(rate), current_tpt, sr,\n\t\t       low, high, low_tpt, high_tpt);\n\n\tscale_action = rs_get_rate_action(mvm, tbl, sr, low, high,\n\t\t\t\t\t  current_tpt, low_tpt, high_tpt);\n\n\t \n\tif (is_mimo(rate) &&\n\t    !iwl_mvm_bt_coex_is_mimo_allowed(mvm, sta)) {\n\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t       \"BT Coex forbids MIMO. Search for new config\\n\");\n\t\trs_stay_in_table(lq_sta, true);\n\t\tgoto lq_update;\n\t}\n\n\tswitch (scale_action) {\n\tcase RS_ACTION_DOWNSCALE:\n\t\t \n\t\tif (low != IWL_RATE_INVALID) {\n\t\t\tupdate_lq = 1;\n\t\t\tindex = low;\n\t\t} else {\n\t\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t\t       \"At the bottom rate. Can't decrease\\n\");\n\t\t}\n\n\t\tbreak;\n\tcase RS_ACTION_UPSCALE:\n\t\t \n\t\tif (high != IWL_RATE_INVALID) {\n\t\t\tupdate_lq = 1;\n\t\t\tindex = high;\n\t\t} else {\n\t\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t\t       \"At the top rate. Can't increase\\n\");\n\t\t}\n\n\t\tbreak;\n\tcase RS_ACTION_STAY:\n\t\t \n\t\tif (lq_sta->rs_state == RS_STATE_STAY_IN_COLUMN)\n\t\t\tupdate_lq = rs_tpc_perform(mvm, sta, lq_sta, tbl);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nlq_update:\n\t \n\tif (update_lq) {\n\t\ttbl->rate.index = index;\n\t\tif (IWL_MVM_RS_80_20_FAR_RANGE_TWEAK)\n\t\t\trs_tweak_rate_tbl(mvm, sta, lq_sta, tbl, scale_action);\n\t\trs_set_amsdu_len(mvm, sta, tbl, scale_action);\n\t\trs_update_rate_tbl(mvm, sta, lq_sta, tbl);\n\t}\n\n\trs_stay_in_table(lq_sta, false);\n\n\t \n\tif (!update_lq && !done_search &&\n\t    lq_sta->rs_state == RS_STATE_SEARCH_CYCLE_STARTED\n\t    && window->counter) {\n\t\tenum rs_column next_column;\n\n\t\t \n\t\tlq_sta->last_tpt = current_tpt;\n\n\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t       \"Start Search: update_lq %d done_search %d rs_state %d win->counter %d\\n\",\n\t\t\t       update_lq, done_search, lq_sta->rs_state,\n\t\t\t       window->counter);\n\n\t\tnext_column = rs_get_next_column(mvm, lq_sta, sta, tbl);\n\t\tif (next_column != RS_COLUMN_INVALID) {\n\t\t\tint ret = rs_switch_to_column(mvm, lq_sta, sta,\n\t\t\t\t\t\t      next_column);\n\t\t\tif (!ret)\n\t\t\t\tlq_sta->search_better_tbl = 1;\n\t\t} else {\n\t\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t\t       \"No more columns to explore in search cycle. Go to RS_STATE_SEARCH_CYCLE_ENDED\\n\");\n\t\t\tlq_sta->rs_state = RS_STATE_SEARCH_CYCLE_ENDED;\n\t\t}\n\n\t\t \n\t\tif (lq_sta->search_better_tbl) {\n\t\t\t \n\t\t\ttbl = &lq_sta->lq_info[rs_search_tbl(lq_sta->active_tbl)];\n\t\t\trs_rate_scale_clear_tbl_windows(mvm, tbl);\n\n\t\t\t \n\t\t\tindex = tbl->rate.index;\n\n\t\t\trs_dump_rate(mvm, &tbl->rate,\n\t\t\t\t     \"Switch to SEARCH TABLE:\");\n\t\t\trs_update_rate_tbl(mvm, sta, lq_sta, tbl);\n\t\t} else {\n\t\t\tdone_search = 1;\n\t\t}\n\t}\n\n\tif (!ndp)\n\t\trs_tl_turn_on_agg(mvm, mvmsta, tid, lq_sta, sta);\n\n\tif (done_search && lq_sta->rs_state == RS_STATE_SEARCH_CYCLE_ENDED) {\n\t\ttbl1 = &(lq_sta->lq_info[lq_sta->active_tbl]);\n\t\trs_set_stay_in_table(mvm, is_legacy(&tbl1->rate), lq_sta);\n\t}\n}\n\nstruct rs_init_rate_info {\n\ts8 rssi;\n\tu8 rate_idx;\n};\n\nstatic const struct rs_init_rate_info rs_optimal_rates_24ghz_legacy[] = {\n\t{ -60, IWL_RATE_54M_INDEX },\n\t{ -64, IWL_RATE_48M_INDEX },\n\t{ -68, IWL_RATE_36M_INDEX },\n\t{ -80, IWL_RATE_24M_INDEX },\n\t{ -84, IWL_RATE_18M_INDEX },\n\t{ -85, IWL_RATE_12M_INDEX },\n\t{ -86, IWL_RATE_11M_INDEX },\n\t{ -88, IWL_RATE_5M_INDEX  },\n\t{ -90, IWL_RATE_2M_INDEX  },\n\t{ S8_MIN, IWL_RATE_1M_INDEX },\n};\n\nstatic const struct rs_init_rate_info rs_optimal_rates_5ghz_legacy[] = {\n\t{ -60, IWL_RATE_54M_INDEX },\n\t{ -64, IWL_RATE_48M_INDEX },\n\t{ -72, IWL_RATE_36M_INDEX },\n\t{ -80, IWL_RATE_24M_INDEX },\n\t{ -84, IWL_RATE_18M_INDEX },\n\t{ -85, IWL_RATE_12M_INDEX },\n\t{ -87, IWL_RATE_9M_INDEX  },\n\t{ S8_MIN, IWL_RATE_6M_INDEX },\n};\n\nstatic const struct rs_init_rate_info rs_optimal_rates_ht[] = {\n\t{ -60, IWL_RATE_MCS_7_INDEX },\n\t{ -64, IWL_RATE_MCS_6_INDEX },\n\t{ -68, IWL_RATE_MCS_5_INDEX },\n\t{ -72, IWL_RATE_MCS_4_INDEX },\n\t{ -80, IWL_RATE_MCS_3_INDEX },\n\t{ -84, IWL_RATE_MCS_2_INDEX },\n\t{ -85, IWL_RATE_MCS_1_INDEX },\n\t{ S8_MIN, IWL_RATE_MCS_0_INDEX},\n};\n\n \nstatic const struct rs_init_rate_info rs_optimal_rates_vht_20mhz[] = {\n\t{ -60, IWL_RATE_MCS_8_INDEX },\n\t{ -64, IWL_RATE_MCS_7_INDEX },\n\t{ -68, IWL_RATE_MCS_6_INDEX },\n\t{ -72, IWL_RATE_MCS_5_INDEX },\n\t{ -80, IWL_RATE_MCS_4_INDEX },\n\t{ -84, IWL_RATE_MCS_3_INDEX },\n\t{ -85, IWL_RATE_MCS_2_INDEX },\n\t{ -87, IWL_RATE_MCS_1_INDEX },\n\t{ S8_MIN, IWL_RATE_MCS_0_INDEX},\n};\n\nstatic const struct rs_init_rate_info rs_optimal_rates_vht[] = {\n\t{ -60, IWL_RATE_MCS_9_INDEX },\n\t{ -64, IWL_RATE_MCS_8_INDEX },\n\t{ -68, IWL_RATE_MCS_7_INDEX },\n\t{ -72, IWL_RATE_MCS_6_INDEX },\n\t{ -80, IWL_RATE_MCS_5_INDEX },\n\t{ -84, IWL_RATE_MCS_4_INDEX },\n\t{ -85, IWL_RATE_MCS_3_INDEX },\n\t{ -87, IWL_RATE_MCS_2_INDEX },\n\t{ -88, IWL_RATE_MCS_1_INDEX },\n\t{ S8_MIN, IWL_RATE_MCS_0_INDEX },\n};\n\n#define IWL_RS_LOW_RSSI_THRESHOLD (-76)  \n\n \nstatic void rs_init_optimal_rate(struct iwl_mvm *mvm,\n\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t struct iwl_lq_sta *lq_sta)\n{\n\tstruct rs_rate *rate = &lq_sta->optimal_rate;\n\n\tif (lq_sta->max_mimo2_rate_idx != IWL_RATE_INVALID)\n\t\trate->type = lq_sta->is_vht ? LQ_VHT_MIMO2 : LQ_HT_MIMO2;\n\telse if (lq_sta->max_siso_rate_idx != IWL_RATE_INVALID)\n\t\trate->type = lq_sta->is_vht ? LQ_VHT_SISO : LQ_HT_SISO;\n\telse if (lq_sta->band == NL80211_BAND_5GHZ)\n\t\trate->type = LQ_LEGACY_A;\n\telse\n\t\trate->type = LQ_LEGACY_G;\n\n\trate->bw = rs_bw_from_sta_bw(sta);\n\trate->sgi = rs_sgi_allow(mvm, sta, rate, NULL);\n\n\t \n\n\tif (is_mimo(rate)) {\n\t\tlq_sta->optimal_rate_mask = lq_sta->active_mimo2_rate;\n\t} else if (is_siso(rate)) {\n\t\tlq_sta->optimal_rate_mask = lq_sta->active_siso_rate;\n\t} else {\n\t\tlq_sta->optimal_rate_mask = lq_sta->active_legacy_rate;\n\n\t\tif (lq_sta->band == NL80211_BAND_5GHZ) {\n\t\t\tlq_sta->optimal_rates = rs_optimal_rates_5ghz_legacy;\n\t\t\tlq_sta->optimal_nentries =\n\t\t\t\tARRAY_SIZE(rs_optimal_rates_5ghz_legacy);\n\t\t} else {\n\t\t\tlq_sta->optimal_rates = rs_optimal_rates_24ghz_legacy;\n\t\t\tlq_sta->optimal_nentries =\n\t\t\t\tARRAY_SIZE(rs_optimal_rates_24ghz_legacy);\n\t\t}\n\t}\n\n\tif (is_vht(rate)) {\n\t\tif (rate->bw == RATE_MCS_CHAN_WIDTH_20) {\n\t\t\tlq_sta->optimal_rates = rs_optimal_rates_vht_20mhz;\n\t\t\tlq_sta->optimal_nentries =\n\t\t\t\tARRAY_SIZE(rs_optimal_rates_vht_20mhz);\n\t\t} else {\n\t\t\tlq_sta->optimal_rates = rs_optimal_rates_vht;\n\t\t\tlq_sta->optimal_nentries =\n\t\t\t\tARRAY_SIZE(rs_optimal_rates_vht);\n\t\t}\n\t} else if (is_ht(rate)) {\n\t\tlq_sta->optimal_rates = rs_optimal_rates_ht;\n\t\tlq_sta->optimal_nentries = ARRAY_SIZE(rs_optimal_rates_ht);\n\t}\n}\n\n \nstatic struct rs_rate *rs_get_optimal_rate(struct iwl_mvm *mvm,\n\t\t\t\t\t   struct iwl_lq_sta *lq_sta)\n{\n\tstruct rs_rate *rate = &lq_sta->optimal_rate;\n\tint i;\n\n\trate->index = find_first_bit(&lq_sta->optimal_rate_mask,\n\t\t\t\t     BITS_PER_LONG);\n\n\tfor (i = 0; i < lq_sta->optimal_nentries; i++) {\n\t\tint rate_idx = lq_sta->optimal_rates[i].rate_idx;\n\n\t\tif ((lq_sta->pers.last_rssi >= lq_sta->optimal_rates[i].rssi) &&\n\t\t    (BIT(rate_idx) & lq_sta->optimal_rate_mask)) {\n\t\t\trate->index = rate_idx;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rate;\n}\n\n \nstatic void rs_get_initial_rate(struct iwl_mvm *mvm,\n\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\tstruct iwl_lq_sta *lq_sta,\n\t\t\t\tenum nl80211_band band,\n\t\t\t\tstruct rs_rate *rate)\n{\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tint i, nentries;\n\tunsigned long active_rate;\n\ts8 best_rssi = S8_MIN;\n\tu8 best_ant = ANT_NONE;\n\tu8 valid_tx_ant = iwl_mvm_get_valid_tx_ant(mvm);\n\tconst struct rs_init_rate_info *initial_rates;\n\n\tfor (i = 0; i < ARRAY_SIZE(lq_sta->pers.chain_signal); i++) {\n\t\tif (!(lq_sta->pers.chains & BIT(i)))\n\t\t\tcontinue;\n\n\t\tif (lq_sta->pers.chain_signal[i] > best_rssi) {\n\t\t\tbest_rssi = lq_sta->pers.chain_signal[i];\n\t\t\tbest_ant = BIT(i);\n\t\t}\n\t}\n\n\tIWL_DEBUG_RATE(mvm, \"Best ANT: %s Best RSSI: %d\\n\",\n\t\t       iwl_rs_pretty_ant(best_ant), best_rssi);\n\n\tif (best_ant != ANT_A && best_ant != ANT_B)\n\t\trate->ant = first_antenna(valid_tx_ant);\n\telse\n\t\trate->ant = best_ant;\n\n\trate->sgi = false;\n\trate->ldpc = false;\n\trate->bw = RATE_MCS_CHAN_WIDTH_20;\n\n\trate->index = find_first_bit(&lq_sta->active_legacy_rate,\n\t\t\t\t     BITS_PER_LONG);\n\n\tif (band == NL80211_BAND_5GHZ) {\n\t\trate->type = LQ_LEGACY_A;\n\t\tinitial_rates = rs_optimal_rates_5ghz_legacy;\n\t\tnentries = ARRAY_SIZE(rs_optimal_rates_5ghz_legacy);\n\t} else {\n\t\trate->type = LQ_LEGACY_G;\n\t\tinitial_rates = rs_optimal_rates_24ghz_legacy;\n\t\tnentries = ARRAY_SIZE(rs_optimal_rates_24ghz_legacy);\n\t}\n\n\tif (!IWL_MVM_RS_RSSI_BASED_INIT_RATE)\n\t\tgoto out;\n\n\t \n\tif (sta->deflink.vht_cap.vht_supported &&\n\t    best_rssi > IWL_RS_LOW_RSSI_THRESHOLD) {\n\t\t \n\t\tu32 bw = mvmsta->sta_state < IEEE80211_STA_AUTHORIZED ?\n\t\t\t\tRATE_MCS_CHAN_WIDTH_20 : rs_bw_from_sta_bw(sta);\n\n\t\tswitch (bw) {\n\t\tcase RATE_MCS_CHAN_WIDTH_40:\n\t\tcase RATE_MCS_CHAN_WIDTH_80:\n\t\tcase RATE_MCS_CHAN_WIDTH_160:\n\t\t\tinitial_rates = rs_optimal_rates_vht;\n\t\t\tnentries = ARRAY_SIZE(rs_optimal_rates_vht);\n\t\t\tbreak;\n\t\tcase RATE_MCS_CHAN_WIDTH_20:\n\t\t\tinitial_rates = rs_optimal_rates_vht_20mhz;\n\t\t\tnentries = ARRAY_SIZE(rs_optimal_rates_vht_20mhz);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tIWL_ERR(mvm, \"Invalid BW %d\\n\",\n\t\t\t\tsta->deflink.bandwidth);\n\t\t\tgoto out;\n\t\t}\n\n\t\tactive_rate = lq_sta->active_siso_rate;\n\t\trate->type = LQ_VHT_SISO;\n\t\trate->bw = bw;\n\t} else if (sta->deflink.ht_cap.ht_supported &&\n\t\t   best_rssi > IWL_RS_LOW_RSSI_THRESHOLD) {\n\t\tinitial_rates = rs_optimal_rates_ht;\n\t\tnentries = ARRAY_SIZE(rs_optimal_rates_ht);\n\t\tactive_rate = lq_sta->active_siso_rate;\n\t\trate->type = LQ_HT_SISO;\n\t} else {\n\t\tactive_rate = lq_sta->active_legacy_rate;\n\t}\n\n\tfor (i = 0; i < nentries; i++) {\n\t\tint rate_idx = initial_rates[i].rate_idx;\n\n\t\tif ((best_rssi >= initial_rates[i].rssi) &&\n\t\t    (BIT(rate_idx) & active_rate)) {\n\t\t\trate->index = rate_idx;\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\trs_dump_rate(mvm, rate, \"INITIAL\");\n}\n\n \nvoid rs_update_last_rssi(struct iwl_mvm *mvm,\n\t\t\t struct iwl_mvm_sta *mvmsta,\n\t\t\t struct ieee80211_rx_status *rx_status)\n{\n\tstruct iwl_lq_sta *lq_sta = &mvmsta->deflink.lq_sta.rs_drv;\n\tint i;\n\n\tlq_sta->pers.chains = rx_status->chains;\n\tlq_sta->pers.chain_signal[0] = rx_status->chain_signal[0];\n\tlq_sta->pers.chain_signal[1] = rx_status->chain_signal[1];\n\tlq_sta->pers.last_rssi = S8_MIN;\n\n\tfor (i = 0; i < ARRAY_SIZE(lq_sta->pers.chain_signal); i++) {\n\t\tif (!(lq_sta->pers.chains & BIT(i)))\n\t\t\tcontinue;\n\n\t\tif (lq_sta->pers.chain_signal[i] > lq_sta->pers.last_rssi)\n\t\t\tlq_sta->pers.last_rssi = lq_sta->pers.chain_signal[i];\n\t}\n}\n\n \nstatic void rs_initialize_lq(struct iwl_mvm *mvm,\n\t\t\t     struct ieee80211_sta *sta,\n\t\t\t     struct iwl_lq_sta *lq_sta,\n\t\t\t     enum nl80211_band band)\n{\n\tstruct iwl_scale_tbl_info *tbl;\n\tstruct rs_rate *rate;\n\tu8 active_tbl = 0;\n\n\tif (!sta || !lq_sta)\n\t\treturn;\n\n\tif (!lq_sta->search_better_tbl)\n\t\tactive_tbl = lq_sta->active_tbl;\n\telse\n\t\tactive_tbl = rs_search_tbl(lq_sta->active_tbl);\n\n\ttbl = &(lq_sta->lq_info[active_tbl]);\n\trate = &tbl->rate;\n\n\trs_get_initial_rate(mvm, sta, lq_sta, band, rate);\n\trs_init_optimal_rate(mvm, sta, lq_sta);\n\n\tWARN_ONCE(rate->ant != ANT_A && rate->ant != ANT_B,\n\t\t  \"ant: 0x%x, chains 0x%x, fw tx ant: 0x%x, nvm tx ant: 0x%x\\n\",\n\t\t  rate->ant, lq_sta->pers.chains, mvm->fw->valid_tx_ant,\n\t\t  mvm->nvm_data ? mvm->nvm_data->valid_tx_ant : ANT_INVALID);\n\n\ttbl->column = rs_get_column_from_rate(rate);\n\n\trs_set_expected_tpt_table(lq_sta, tbl);\n\trs_fill_lq_cmd(mvm, sta, lq_sta, rate);\n\t \n\tiwl_mvm_send_lq_cmd(mvm, &lq_sta->lq);\n}\n\nstatic void rs_drv_get_rate(void *mvm_r, struct ieee80211_sta *sta,\n\t\t\t    void *mvm_sta,\n\t\t\t    struct ieee80211_tx_rate_control *txrc)\n{\n\tstruct iwl_op_mode *op_mode = mvm_r;\n\tstruct iwl_mvm *mvm __maybe_unused = IWL_OP_MODE_GET_MVM(op_mode);\n\tstruct sk_buff *skb = txrc->skb;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct iwl_lq_sta *lq_sta;\n\tstruct rs_rate *optimal_rate;\n\tu32 last_ucode_rate;\n\n\tif (sta && !iwl_mvm_sta_from_mac80211(sta)->vif) {\n\t\t \n\t\tmvm_sta = NULL;\n\t}\n\n\tif (!mvm_sta)\n\t\treturn;\n\n\tlq_sta = mvm_sta;\n\n\tspin_lock_bh(&lq_sta->pers.lock);\n\tiwl_mvm_hwrate_to_tx_rate_v1(lq_sta->last_rate_n_flags,\n\t\t\t\t     info->band, &info->control.rates[0]);\n\tinfo->control.rates[0].count = 1;\n\n\t \n\tif (lq_sta->rs_state != RS_STATE_STAY_IN_COLUMN) {\n\t\toptimal_rate = rs_get_optimal_rate(mvm, lq_sta);\n\t\tlast_ucode_rate = ucode_rate_from_rs_rate(mvm,\n\t\t\t\t\t\t\t  optimal_rate);\n\t\tiwl_mvm_hwrate_to_tx_rate_v1(last_ucode_rate, info->band,\n\t\t\t\t\t     &txrc->reported_rate);\n\t}\n\tspin_unlock_bh(&lq_sta->pers.lock);\n}\n\nstatic void *rs_drv_alloc_sta(void *mvm_rate, struct ieee80211_sta *sta,\n\t\t\t      gfp_t gfp)\n{\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_op_mode *op_mode = (struct iwl_op_mode *)mvm_rate;\n\tstruct iwl_mvm *mvm  = IWL_OP_MODE_GET_MVM(op_mode);\n\tstruct iwl_lq_sta *lq_sta = &mvmsta->deflink.lq_sta.rs_drv;\n\n\tIWL_DEBUG_RATE(mvm, \"create station rate scale window\\n\");\n\n\tlq_sta->pers.drv = mvm;\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tlq_sta->pers.dbg_fixed_rate = 0;\n\tlq_sta->pers.dbg_fixed_txp_reduction = TPC_INVALID;\n\tlq_sta->pers.ss_force = RS_SS_FORCE_NONE;\n#endif\n\tlq_sta->pers.chains = 0;\n\tmemset(lq_sta->pers.chain_signal, 0, sizeof(lq_sta->pers.chain_signal));\n\tlq_sta->pers.last_rssi = S8_MIN;\n\n\treturn lq_sta;\n}\n\nstatic int rs_vht_highest_rx_mcs_index(struct ieee80211_sta_vht_cap *vht_cap,\n\t\t\t\t       int nss)\n{\n\tu16 rx_mcs = le16_to_cpu(vht_cap->vht_mcs.rx_mcs_map) &\n\t\t(0x3 << (2 * (nss - 1)));\n\trx_mcs >>= (2 * (nss - 1));\n\n\tif (rx_mcs == IEEE80211_VHT_MCS_SUPPORT_0_7)\n\t\treturn IWL_RATE_MCS_7_INDEX;\n\telse if (rx_mcs == IEEE80211_VHT_MCS_SUPPORT_0_8)\n\t\treturn IWL_RATE_MCS_8_INDEX;\n\telse if (rx_mcs == IEEE80211_VHT_MCS_SUPPORT_0_9)\n\t\treturn IWL_RATE_MCS_9_INDEX;\n\n\tWARN_ON_ONCE(rx_mcs != IEEE80211_VHT_MCS_NOT_SUPPORTED);\n\treturn -1;\n}\n\nstatic void rs_vht_set_enabled_rates(struct ieee80211_sta *sta,\n\t\t\t\t     struct ieee80211_sta_vht_cap *vht_cap,\n\t\t\t\t     struct iwl_lq_sta *lq_sta)\n{\n\tint i;\n\tint highest_mcs = rs_vht_highest_rx_mcs_index(vht_cap, 1);\n\n\tif (highest_mcs >= IWL_RATE_MCS_0_INDEX) {\n\t\tfor (i = IWL_RATE_MCS_0_INDEX; i <= highest_mcs; i++) {\n\t\t\tif (i == IWL_RATE_9M_INDEX)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (i == IWL_RATE_MCS_9_INDEX &&\n\t\t\t    sta->deflink.bandwidth == IEEE80211_STA_RX_BW_20)\n\t\t\t\tcontinue;\n\n\t\t\tlq_sta->active_siso_rate |= BIT(i);\n\t\t}\n\t}\n\n\tif (sta->deflink.rx_nss < 2)\n\t\treturn;\n\n\thighest_mcs = rs_vht_highest_rx_mcs_index(vht_cap, 2);\n\tif (highest_mcs >= IWL_RATE_MCS_0_INDEX) {\n\t\tfor (i = IWL_RATE_MCS_0_INDEX; i <= highest_mcs; i++) {\n\t\t\tif (i == IWL_RATE_9M_INDEX)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (i == IWL_RATE_MCS_9_INDEX &&\n\t\t\t    sta->deflink.bandwidth == IEEE80211_STA_RX_BW_20)\n\t\t\t\tcontinue;\n\n\t\t\tlq_sta->active_mimo2_rate |= BIT(i);\n\t\t}\n\t}\n}\n\nstatic void rs_ht_init(struct iwl_mvm *mvm,\n\t\t       struct ieee80211_sta *sta,\n\t\t       struct iwl_lq_sta *lq_sta,\n\t\t       struct ieee80211_sta_ht_cap *ht_cap)\n{\n\t \n\tlq_sta->active_siso_rate = ht_cap->mcs.rx_mask[0] << 1;\n\tlq_sta->active_siso_rate |= ht_cap->mcs.rx_mask[0] & 0x1;\n\tlq_sta->active_siso_rate &= ~((u16)0x2);\n\tlq_sta->active_siso_rate <<= IWL_FIRST_OFDM_RATE;\n\n\tlq_sta->active_mimo2_rate = ht_cap->mcs.rx_mask[1] << 1;\n\tlq_sta->active_mimo2_rate |= ht_cap->mcs.rx_mask[1] & 0x1;\n\tlq_sta->active_mimo2_rate &= ~((u16)0x2);\n\tlq_sta->active_mimo2_rate <<= IWL_FIRST_OFDM_RATE;\n\n\tif (mvm->cfg->ht_params->ldpc &&\n\t    (ht_cap->cap & IEEE80211_HT_CAP_LDPC_CODING))\n\t\tlq_sta->ldpc = true;\n\n\tif (mvm->cfg->ht_params->stbc &&\n\t    (num_of_ant(iwl_mvm_get_valid_tx_ant(mvm)) > 1) &&\n\t    (ht_cap->cap & IEEE80211_HT_CAP_RX_STBC))\n\t\tlq_sta->stbc_capable = true;\n\n\tlq_sta->is_vht = false;\n}\n\nstatic void rs_vht_init(struct iwl_mvm *mvm,\n\t\t\tstruct ieee80211_sta *sta,\n\t\t\tstruct iwl_lq_sta *lq_sta,\n\t\t\tstruct ieee80211_sta_vht_cap *vht_cap)\n{\n\trs_vht_set_enabled_rates(sta, vht_cap, lq_sta);\n\n\tif (mvm->cfg->ht_params->ldpc &&\n\t    (vht_cap->cap & IEEE80211_VHT_CAP_RXLDPC))\n\t\tlq_sta->ldpc = true;\n\n\tif (mvm->cfg->ht_params->stbc &&\n\t    (num_of_ant(iwl_mvm_get_valid_tx_ant(mvm)) > 1) &&\n\t    (vht_cap->cap & IEEE80211_VHT_CAP_RXSTBC_MASK))\n\t\tlq_sta->stbc_capable = true;\n\n\tif (fw_has_capa(&mvm->fw->ucode_capa, IWL_UCODE_TLV_CAPA_BEAMFORMER) &&\n\t    (num_of_ant(iwl_mvm_get_valid_tx_ant(mvm)) > 1) &&\n\t    (vht_cap->cap & IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE))\n\t\tlq_sta->bfer_capable = true;\n\n\tlq_sta->is_vht = true;\n}\n\n#ifdef CONFIG_IWLWIFI_DEBUGFS\nvoid iwl_mvm_reset_frame_stats(struct iwl_mvm *mvm)\n{\n\tspin_lock_bh(&mvm->drv_stats_lock);\n\tmemset(&mvm->drv_rx_stats, 0, sizeof(mvm->drv_rx_stats));\n\tspin_unlock_bh(&mvm->drv_stats_lock);\n}\n\nvoid iwl_mvm_update_frame_stats(struct iwl_mvm *mvm, u32 rate, bool agg)\n{\n\tu8 nss = 0;\n\n\tspin_lock(&mvm->drv_stats_lock);\n\n\tif (agg)\n\t\tmvm->drv_rx_stats.agg_frames++;\n\n\tmvm->drv_rx_stats.success_frames++;\n\n\tswitch (rate & RATE_MCS_CHAN_WIDTH_MSK_V1) {\n\tcase RATE_MCS_CHAN_WIDTH_20:\n\t\tmvm->drv_rx_stats.bw_20_frames++;\n\t\tbreak;\n\tcase RATE_MCS_CHAN_WIDTH_40:\n\t\tmvm->drv_rx_stats.bw_40_frames++;\n\t\tbreak;\n\tcase RATE_MCS_CHAN_WIDTH_80:\n\t\tmvm->drv_rx_stats.bw_80_frames++;\n\t\tbreak;\n\tcase RATE_MCS_CHAN_WIDTH_160:\n\t\tmvm->drv_rx_stats.bw_160_frames++;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(1, \"bad BW. rate 0x%x\", rate);\n\t}\n\n\tif (rate & RATE_MCS_HT_MSK_V1) {\n\t\tmvm->drv_rx_stats.ht_frames++;\n\t\tnss = ((rate & RATE_HT_MCS_NSS_MSK_V1) >> RATE_HT_MCS_NSS_POS_V1) + 1;\n\t} else if (rate & RATE_MCS_VHT_MSK_V1) {\n\t\tmvm->drv_rx_stats.vht_frames++;\n\t\tnss = FIELD_GET(RATE_MCS_NSS_MSK, rate) + 1;\n\t} else {\n\t\tmvm->drv_rx_stats.legacy_frames++;\n\t}\n\n\tif (nss == 1)\n\t\tmvm->drv_rx_stats.siso_frames++;\n\telse if (nss == 2)\n\t\tmvm->drv_rx_stats.mimo2_frames++;\n\n\tif (rate & RATE_MCS_SGI_MSK_V1)\n\t\tmvm->drv_rx_stats.sgi_frames++;\n\telse\n\t\tmvm->drv_rx_stats.ngi_frames++;\n\n\tmvm->drv_rx_stats.last_rates[mvm->drv_rx_stats.last_frame_idx] = rate;\n\tmvm->drv_rx_stats.last_frame_idx =\n\t\t(mvm->drv_rx_stats.last_frame_idx + 1) %\n\t\t\tARRAY_SIZE(mvm->drv_rx_stats.last_rates);\n\n\tspin_unlock(&mvm->drv_stats_lock);\n}\n#endif\n\n \nstatic void rs_drv_rate_init(struct iwl_mvm *mvm, struct ieee80211_sta *sta,\n\t\t\t     enum nl80211_band band)\n{\n\tint i, j;\n\tstruct ieee80211_hw *hw = mvm->hw;\n\tstruct ieee80211_sta_ht_cap *ht_cap = &sta->deflink.ht_cap;\n\tstruct ieee80211_sta_vht_cap *vht_cap = &sta->deflink.vht_cap;\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_lq_sta *lq_sta = &mvmsta->deflink.lq_sta.rs_drv;\n\tstruct ieee80211_supported_band *sband;\n\tunsigned long supp;  \n\n\tlockdep_assert_held(&mvmsta->deflink.lq_sta.rs_drv.pers.lock);\n\n\t \n\tmemset(lq_sta, 0, offsetof(typeof(*lq_sta), pers));\n\n\tsband = hw->wiphy->bands[band];\n\n\tlq_sta->lq.sta_id = mvmsta->deflink.sta_id;\n\tmvmsta->amsdu_enabled = 0;\n\tmvmsta->max_amsdu_len = sta->cur->max_amsdu_len;\n\n\tfor (j = 0; j < LQ_SIZE; j++)\n\t\trs_rate_scale_clear_tbl_windows(mvm, &lq_sta->lq_info[j]);\n\n\tlq_sta->flush_timer = 0;\n\tlq_sta->last_tx = jiffies;\n\n\tIWL_DEBUG_RATE(mvm,\n\t\t       \"LQ: *** rate scale station global init for station %d ***\\n\",\n\t\t       mvmsta->deflink.sta_id);\n\t \n\n\tlq_sta->missed_rate_counter = IWL_MVM_RS_MISSED_RATE_MAX;\n\tlq_sta->band = sband->band;\n\t \n\tsupp = sta->deflink.supp_rates[sband->band];\n\tlq_sta->active_legacy_rate = 0;\n\tfor_each_set_bit(i, &supp, BITS_PER_LONG)\n\t\tlq_sta->active_legacy_rate |= BIT(sband->bitrates[i].hw_value);\n\n\t \n\tif (!vht_cap || !vht_cap->vht_supported)\n\t\trs_ht_init(mvm, sta, lq_sta, ht_cap);\n\telse\n\t\trs_vht_init(mvm, sta, lq_sta, vht_cap);\n\n\tlq_sta->max_legacy_rate_idx =\n\t\trs_get_max_rate_from_mask(lq_sta->active_legacy_rate);\n\tlq_sta->max_siso_rate_idx =\n\t\trs_get_max_rate_from_mask(lq_sta->active_siso_rate);\n\tlq_sta->max_mimo2_rate_idx =\n\t\trs_get_max_rate_from_mask(lq_sta->active_mimo2_rate);\n\n\tIWL_DEBUG_RATE(mvm,\n\t\t       \"LEGACY=%lX SISO=%lX MIMO2=%lX VHT=%d LDPC=%d STBC=%d BFER=%d\\n\",\n\t\t       lq_sta->active_legacy_rate,\n\t\t       lq_sta->active_siso_rate,\n\t\t       lq_sta->active_mimo2_rate,\n\t\t       lq_sta->is_vht, lq_sta->ldpc, lq_sta->stbc_capable,\n\t\t       lq_sta->bfer_capable);\n\tIWL_DEBUG_RATE(mvm, \"MAX RATE: LEGACY=%d SISO=%d MIMO2=%d\\n\",\n\t\t       lq_sta->max_legacy_rate_idx,\n\t\t       lq_sta->max_siso_rate_idx,\n\t\t       lq_sta->max_mimo2_rate_idx);\n\n\t \n\tlq_sta->lq.single_stream_ant_msk =\n\t\tiwl_mvm_bt_coex_get_single_ant_msk(mvm, iwl_mvm_get_valid_tx_ant(mvm));\n\tlq_sta->lq.dual_stream_ant_msk = ANT_AB;\n\n\t \n\tlq_sta->tx_agg_tid_en = IWL_AGG_ALL_TID;\n\tlq_sta->is_agg = 0;\n#ifdef CONFIG_IWLWIFI_DEBUGFS\n\tiwl_mvm_reset_frame_stats(mvm);\n#endif\n\trs_initialize_lq(mvm, sta, lq_sta, band);\n}\n\nstatic void rs_drv_rate_update(void *mvm_r,\n\t\t\t       struct ieee80211_supported_band *sband,\n\t\t\t       struct cfg80211_chan_def *chandef,\n\t\t\t       struct ieee80211_sta *sta,\n\t\t\t       void *priv_sta, u32 changed)\n{\n\tstruct iwl_op_mode *op_mode = mvm_r;\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_mvm *mvm __maybe_unused = IWL_OP_MODE_GET_MVM(op_mode);\n\tu8 tid;\n\n\tif (!mvmsta->vif)\n\t\treturn;\n\n\t \n\tfor (tid = 0; tid < IWL_MAX_TID_COUNT; tid++)\n\t\tieee80211_stop_tx_ba_session(sta, tid);\n\n\tiwl_mvm_rs_rate_init(mvm, mvmsta->vif, sta,\n\t\t\t     &mvmsta->vif->bss_conf, &sta->deflink,\n\t\t\t     sband->band);\n}\n\nstatic void __iwl_mvm_rs_tx_status(struct iwl_mvm *mvm,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   int tid, struct ieee80211_tx_info *info,\n\t\t\t\t   bool ndp)\n{\n\tint legacy_success;\n\tint retries;\n\tint i;\n\tstruct iwl_lq_cmd *table;\n\tu32 lq_hwrate;\n\tstruct rs_rate lq_rate, tx_resp_rate;\n\tstruct iwl_scale_tbl_info *curr_tbl, *other_tbl, *tmp_tbl;\n\tu32 tlc_info = (uintptr_t)info->status.status_driver_data[0];\n\tu8 reduced_txp = tlc_info & RS_DRV_DATA_TXP_MSK;\n\tu8 lq_color = RS_DRV_DATA_LQ_COLOR_GET(tlc_info);\n\tu32 tx_resp_hwrate = (uintptr_t)info->status.status_driver_data[1];\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_lq_sta *lq_sta = &mvmsta->deflink.lq_sta.rs_drv;\n\n\tif (!lq_sta->pers.drv) {\n\t\tIWL_DEBUG_RATE(mvm, \"Rate scaling not initialized yet.\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif ((info->flags & IEEE80211_TX_CTL_AMPDU) &&\n\t    !(info->flags & IEEE80211_TX_STAT_AMPDU))\n\t\treturn;\n\n\tif (rs_rate_from_ucode_rate(tx_resp_hwrate, info->band,\n\t\t\t\t    &tx_resp_rate)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\t \n\tif (lq_sta->pers.dbg_fixed_rate) {\n\t\tint index = tx_resp_rate.index;\n\t\tenum rs_column column;\n\t\tint attempts, success;\n\n\t\tcolumn = rs_get_column_from_rate(&tx_resp_rate);\n\t\tif (WARN_ONCE(column == RS_COLUMN_INVALID,\n\t\t\t      \"Can't map rate 0x%x to column\",\n\t\t\t      tx_resp_hwrate))\n\t\t\treturn;\n\n\t\tif (info->flags & IEEE80211_TX_STAT_AMPDU) {\n\t\t\tattempts = info->status.ampdu_len;\n\t\t\tsuccess = info->status.ampdu_ack_len;\n\t\t} else {\n\t\t\tattempts = info->status.rates[0].count;\n\t\t\tsuccess = !!(info->flags & IEEE80211_TX_STAT_ACK);\n\t\t}\n\n\t\tlq_sta->pers.tx_stats[column][index].total += attempts;\n\t\tlq_sta->pers.tx_stats[column][index].success += success;\n\n\t\tIWL_DEBUG_RATE(mvm, \"Fixed rate 0x%x success %d attempts %d\\n\",\n\t\t\t       tx_resp_hwrate, success, attempts);\n\t\treturn;\n\t}\n#endif\n\n\tif (time_after(jiffies,\n\t\t       (unsigned long)(lq_sta->last_tx +\n\t\t\t\t       (IWL_MVM_RS_IDLE_TIMEOUT * HZ)))) {\n\t\tIWL_DEBUG_RATE(mvm, \"Tx idle for too long. reinit rs\\n\");\n\t\t \n\t\trs_drv_rate_init(mvm, sta, info->band);\n\t\treturn;\n\t}\n\tlq_sta->last_tx = jiffies;\n\n\t \n\ttable = &lq_sta->lq;\n\tlq_hwrate = le32_to_cpu(table->rs_table[0]);\n\tif (rs_rate_from_ucode_rate(lq_hwrate, info->band, &lq_rate)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\t \n\tif (lq_color != LQ_FLAG_COLOR_GET(table->flags)) {\n\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t       \"tx resp color 0x%x does not match 0x%x\\n\",\n\t\t\t       lq_color, LQ_FLAG_COLOR_GET(table->flags));\n\n\t\t \n\t\tlq_sta->missed_rate_counter++;\n\t\tif (lq_sta->missed_rate_counter > IWL_MVM_RS_MISSED_RATE_MAX) {\n\t\t\tlq_sta->missed_rate_counter = 0;\n\t\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t\t       \"Too many rates mismatch. Send sync LQ. rs_state %d\\n\",\n\t\t\t\t       lq_sta->rs_state);\n\t\t\tiwl_mvm_send_lq_cmd(mvm, &lq_sta->lq);\n\t\t}\n\t\t \n\t\treturn;\n\t}\n\n\t \n\tlq_sta->missed_rate_counter = 0;\n\n\tif (!lq_sta->search_better_tbl) {\n\t\tcurr_tbl = &lq_sta->lq_info[lq_sta->active_tbl];\n\t\tother_tbl = &lq_sta->lq_info[rs_search_tbl(lq_sta->active_tbl)];\n\t} else {\n\t\tcurr_tbl = &lq_sta->lq_info[rs_search_tbl(lq_sta->active_tbl)];\n\t\tother_tbl = &lq_sta->lq_info[lq_sta->active_tbl];\n\t}\n\n\tif (WARN_ON_ONCE(!rs_rate_column_match(&lq_rate, &curr_tbl->rate))) {\n\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t       \"Neither active nor search matches tx rate\\n\");\n\t\ttmp_tbl = &lq_sta->lq_info[lq_sta->active_tbl];\n\t\trs_dump_rate(mvm, &tmp_tbl->rate, \"ACTIVE\");\n\t\ttmp_tbl = &lq_sta->lq_info[rs_search_tbl(lq_sta->active_tbl)];\n\t\trs_dump_rate(mvm, &tmp_tbl->rate, \"SEARCH\");\n\t\trs_dump_rate(mvm, &lq_rate, \"ACTUAL\");\n\n\t\t \n\t\trs_stay_in_table(lq_sta, true);\n\t\tgoto done;\n\t}\n\n\t \n\tif (info->flags & IEEE80211_TX_STAT_AMPDU) {\n\t\trs_collect_tpc_data(mvm, lq_sta, curr_tbl, tx_resp_rate.index,\n\t\t\t\t    info->status.ampdu_len,\n\t\t\t\t    info->status.ampdu_ack_len,\n\t\t\t\t    reduced_txp);\n\n\t\t \n\t\tif (info->status.ampdu_ack_len == 0)\n\t\t\tinfo->status.ampdu_len = 1;\n\n\t\trs_collect_tlc_data(mvm, mvmsta, tid, curr_tbl,\n\t\t\t\t    tx_resp_rate.index,\n\t\t\t\t    info->status.ampdu_len,\n\t\t\t\t    info->status.ampdu_ack_len);\n\n\t\t \n\t\tif (lq_sta->rs_state == RS_STATE_STAY_IN_COLUMN) {\n\t\t\tlq_sta->total_success += info->status.ampdu_ack_len;\n\t\t\tlq_sta->total_failed += (info->status.ampdu_len -\n\t\t\t\t\tinfo->status.ampdu_ack_len);\n\t\t}\n\t} else {\n\t\t \n\t\tretries = info->status.rates[0].count - 1;\n\t\t \n\t\tretries = min(retries, 15);\n\n\t\t \n\t\tlegacy_success = !!(info->flags & IEEE80211_TX_STAT_ACK);\n\t\t \n\t\tfor (i = 0; i <= retries; ++i) {\n\t\t\tlq_hwrate = le32_to_cpu(table->rs_table[i]);\n\t\t\tif (rs_rate_from_ucode_rate(lq_hwrate, info->band,\n\t\t\t\t\t\t    &lq_rate)) {\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (rs_rate_column_match(&lq_rate, &curr_tbl->rate))\n\t\t\t\ttmp_tbl = curr_tbl;\n\t\t\telse if (rs_rate_column_match(&lq_rate,\n\t\t\t\t\t\t      &other_tbl->rate))\n\t\t\t\ttmp_tbl = other_tbl;\n\t\t\telse\n\t\t\t\tcontinue;\n\n\t\t\trs_collect_tpc_data(mvm, lq_sta, tmp_tbl,\n\t\t\t\t\t    tx_resp_rate.index, 1,\n\t\t\t\t\t    i < retries ? 0 : legacy_success,\n\t\t\t\t\t    reduced_txp);\n\t\t\trs_collect_tlc_data(mvm, mvmsta, tid, tmp_tbl,\n\t\t\t\t\t    tx_resp_rate.index, 1,\n\t\t\t\t\t    i < retries ? 0 : legacy_success);\n\t\t}\n\n\t\t \n\t\tif (lq_sta->rs_state == RS_STATE_STAY_IN_COLUMN) {\n\t\t\tlq_sta->total_success += legacy_success;\n\t\t\tlq_sta->total_failed += retries + (1 - legacy_success);\n\t\t}\n\t}\n\t \n\tlq_sta->last_rate_n_flags = lq_hwrate;\n\tIWL_DEBUG_RATE(mvm, \"reduced txpower: %d\\n\", reduced_txp);\ndone:\n\t \n\tif (sta->deflink.supp_rates[info->band])\n\t\trs_rate_scale_perform(mvm, sta, lq_sta, tid, ndp);\n}\n\nvoid iwl_mvm_rs_tx_status(struct iwl_mvm *mvm, struct ieee80211_sta *sta,\n\t\t\t  int tid, struct ieee80211_tx_info *info, bool ndp)\n{\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\n\t \n\tif (!spin_trylock_bh(&mvmsta->deflink.lq_sta.rs_drv.pers.lock))\n\t\treturn;\n\n\t__iwl_mvm_rs_tx_status(mvm, sta, tid, info, ndp);\n\tspin_unlock_bh(&mvmsta->deflink.lq_sta.rs_drv.pers.lock);\n}\n\n#ifdef CONFIG_MAC80211_DEBUGFS\nstatic void rs_build_rates_table_from_fixed(struct iwl_mvm *mvm,\n\t\t\t\t\t    struct iwl_lq_cmd *lq_cmd,\n\t\t\t\t\t    enum nl80211_band band,\n\t\t\t\t\t    u32 ucode_rate)\n{\n\tstruct rs_rate rate;\n\tint i;\n\tint num_rates = ARRAY_SIZE(lq_cmd->rs_table);\n\t__le32 ucode_rate_le32 = cpu_to_le32(ucode_rate);\n\tu8 ant = (ucode_rate & RATE_MCS_ANT_AB_MSK) >> RATE_MCS_ANT_POS;\n\n\tfor (i = 0; i < num_rates; i++)\n\t\tlq_cmd->rs_table[i] = ucode_rate_le32;\n\n\tif (rs_rate_from_ucode_rate(ucode_rate, band, &rate)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\tif (is_mimo(&rate))\n\t\tlq_cmd->mimo_delim = num_rates - 1;\n\telse\n\t\tlq_cmd->mimo_delim = 0;\n\n\tlq_cmd->reduced_tpc = 0;\n\n\tif (num_of_ant(ant) == 1)\n\t\tlq_cmd->single_stream_ant_msk = ant;\n\n\tif (!mvm->trans->trans_cfg->gen2)\n\t\tlq_cmd->agg_frame_cnt_limit = LINK_QUAL_AGG_FRAME_LIMIT_DEF;\n\telse\n\t\tlq_cmd->agg_frame_cnt_limit =\n\t\t\tLINK_QUAL_AGG_FRAME_LIMIT_GEN2_DEF;\n}\n#endif  \n\nstatic void rs_fill_rates_for_column(struct iwl_mvm *mvm,\n\t\t\t\t     struct iwl_lq_sta *lq_sta,\n\t\t\t\t     struct rs_rate *rate,\n\t\t\t\t     __le32 *rs_table, int *rs_table_index,\n\t\t\t\t     int num_rates, int num_retries,\n\t\t\t\t     u8 valid_tx_ant, bool toggle_ant)\n{\n\tint i, j;\n\t__le32 ucode_rate;\n\tbool bottom_reached = false;\n\tint prev_rate_idx = rate->index;\n\tint end = LINK_QUAL_MAX_RETRY_NUM;\n\tint index = *rs_table_index;\n\n\tfor (i = 0; i < num_rates && index < end; i++) {\n\t\tfor (j = 0; j < num_retries && index < end; j++, index++) {\n\t\t\tucode_rate = cpu_to_le32(ucode_rate_from_rs_rate(mvm,\n\t\t\t\t\t\t\t\t\t rate));\n\t\t\trs_table[index] = ucode_rate;\n\t\t\tif (toggle_ant)\n\t\t\t\trs_toggle_antenna(valid_tx_ant, rate);\n\t\t}\n\n\t\tprev_rate_idx = rate->index;\n\t\tbottom_reached = rs_get_lower_rate_in_column(lq_sta, rate);\n\t\tif (bottom_reached && !is_legacy(rate))\n\t\t\tbreak;\n\t}\n\n\tif (!bottom_reached && !is_legacy(rate))\n\t\trate->index = prev_rate_idx;\n\n\t*rs_table_index = index;\n}\n\n \nstatic void rs_build_rates_table(struct iwl_mvm *mvm,\n\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t struct iwl_lq_sta *lq_sta,\n\t\t\t\t const struct rs_rate *initial_rate)\n{\n\tstruct rs_rate rate;\n\tint num_rates, num_retries, index = 0;\n\tu8 valid_tx_ant = 0;\n\tstruct iwl_lq_cmd *lq_cmd = &lq_sta->lq;\n\tbool toggle_ant = false;\n\tu32 color;\n\n\tmemcpy(&rate, initial_rate, sizeof(rate));\n\n\tvalid_tx_ant = iwl_mvm_get_valid_tx_ant(mvm);\n\n\t \n\tif (!fw_has_api(&mvm->fw->ucode_capa, IWL_UCODE_TLV_API_LQ_SS_PARAMS) &&\n\t    rs_stbc_allow(mvm, sta, lq_sta))\n\t\trate.stbc = true;\n\n\tif (is_siso(&rate)) {\n\t\tnum_rates = IWL_MVM_RS_INITIAL_SISO_NUM_RATES;\n\t\tnum_retries = IWL_MVM_RS_HT_VHT_RETRIES_PER_RATE;\n\t} else if (is_mimo(&rate)) {\n\t\tnum_rates = IWL_MVM_RS_INITIAL_MIMO_NUM_RATES;\n\t\tnum_retries = IWL_MVM_RS_HT_VHT_RETRIES_PER_RATE;\n\t} else {\n\t\tnum_rates = IWL_MVM_RS_INITIAL_LEGACY_NUM_RATES;\n\t\tnum_retries = IWL_MVM_RS_INITIAL_LEGACY_RETRIES;\n\t\ttoggle_ant = true;\n\t}\n\n\trs_fill_rates_for_column(mvm, lq_sta, &rate, lq_cmd->rs_table, &index,\n\t\t\t\t num_rates, num_retries, valid_tx_ant,\n\t\t\t\t toggle_ant);\n\n\trs_get_lower_rate_down_column(lq_sta, &rate);\n\n\tif (is_siso(&rate)) {\n\t\tnum_rates = IWL_MVM_RS_SECONDARY_SISO_NUM_RATES;\n\t\tnum_retries = IWL_MVM_RS_SECONDARY_SISO_RETRIES;\n\t\tlq_cmd->mimo_delim = index;\n\t} else if (is_legacy(&rate)) {\n\t\tnum_rates = IWL_MVM_RS_SECONDARY_LEGACY_NUM_RATES;\n\t\tnum_retries = IWL_MVM_RS_SECONDARY_LEGACY_RETRIES;\n\t} else {\n\t\tWARN_ON_ONCE(1);\n\t}\n\n\ttoggle_ant = true;\n\n\trs_fill_rates_for_column(mvm, lq_sta, &rate, lq_cmd->rs_table, &index,\n\t\t\t\t num_rates, num_retries, valid_tx_ant,\n\t\t\t\t toggle_ant);\n\n\trs_get_lower_rate_down_column(lq_sta, &rate);\n\n\tnum_rates = IWL_MVM_RS_SECONDARY_LEGACY_NUM_RATES;\n\tnum_retries = IWL_MVM_RS_SECONDARY_LEGACY_RETRIES;\n\n\trs_fill_rates_for_column(mvm, lq_sta, &rate, lq_cmd->rs_table, &index,\n\t\t\t\t num_rates, num_retries, valid_tx_ant,\n\t\t\t\t toggle_ant);\n\n\t \n\tcolor = LQ_FLAGS_COLOR_INC(LQ_FLAG_COLOR_GET(lq_cmd->flags));\n\tlq_cmd->flags = LQ_FLAG_COLOR_SET(lq_cmd->flags, color);\n}\n\nstruct rs_bfer_active_iter_data {\n\tstruct ieee80211_sta *exclude_sta;\n\tstruct iwl_mvm_sta *bfer_mvmsta;\n};\n\nstatic void rs_bfer_active_iter(void *_data,\n\t\t\t\tstruct ieee80211_sta *sta)\n{\n\tstruct rs_bfer_active_iter_data *data = _data;\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct iwl_lq_cmd *lq_cmd = &mvmsta->deflink.lq_sta.rs_drv.lq;\n\tu32 ss_params = le32_to_cpu(lq_cmd->ss_params);\n\n\tif (sta == data->exclude_sta)\n\t\treturn;\n\n\t \n\tif (ss_params & LQ_SS_BFER_ALLOWED) {\n\t\tWARN_ON_ONCE(data->bfer_mvmsta != NULL);\n\n\t\tdata->bfer_mvmsta = mvmsta;\n\t}\n}\n\nstatic int rs_bfer_priority(struct iwl_mvm_sta *sta)\n{\n\tint prio = -1;\n\tenum nl80211_iftype viftype = ieee80211_vif_type_p2p(sta->vif);\n\n\tswitch (viftype) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tprio = 3;\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tprio = 2;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tprio = 1;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(true, \"viftype %d sta_id %d\", viftype,\n\t\t\t  sta->deflink.sta_id);\n\t\tprio = -1;\n\t}\n\n\treturn prio;\n}\n\n \nstatic int rs_bfer_priority_cmp(struct iwl_mvm_sta *sta1,\n\t\t\t\tstruct iwl_mvm_sta *sta2)\n{\n\tint prio1 = rs_bfer_priority(sta1);\n\tint prio2 = rs_bfer_priority(sta2);\n\n\tif (prio1 > prio2)\n\t\treturn 1;\n\tif (prio1 < prio2)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic void rs_set_lq_ss_params(struct iwl_mvm *mvm,\n\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\tstruct iwl_lq_sta *lq_sta,\n\t\t\t\tconst struct rs_rate *initial_rate)\n{\n\tstruct iwl_lq_cmd *lq_cmd = &lq_sta->lq;\n\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tstruct rs_bfer_active_iter_data data = {\n\t\t.exclude_sta = sta,\n\t\t.bfer_mvmsta = NULL,\n\t};\n\tstruct iwl_mvm_sta *bfer_mvmsta = NULL;\n\tu32 ss_params = LQ_SS_PARAMS_VALID;\n\n\tif (!iwl_mvm_bt_coex_is_mimo_allowed(mvm, sta))\n\t\tgoto out;\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\t \n\tif (lq_sta->pers.ss_force == RS_SS_FORCE_STBC)\n\t\tss_params |= (LQ_SS_STBC_1SS_ALLOWED | LQ_SS_FORCE);\n\telse if (lq_sta->pers.ss_force == RS_SS_FORCE_BFER)\n\t\tss_params |= (LQ_SS_BFER_ALLOWED | LQ_SS_FORCE);\n\n\tif (lq_sta->pers.ss_force != RS_SS_FORCE_NONE) {\n\t\tIWL_DEBUG_RATE(mvm, \"Forcing single stream Tx decision %d\\n\",\n\t\t\t       lq_sta->pers.ss_force);\n\t\tgoto out;\n\t}\n#endif\n\n\tif (lq_sta->stbc_capable)\n\t\tss_params |= LQ_SS_STBC_1SS_ALLOWED;\n\n\tif (!lq_sta->bfer_capable)\n\t\tgoto out;\n\n\tieee80211_iterate_stations_atomic(mvm->hw,\n\t\t\t\t\t  rs_bfer_active_iter,\n\t\t\t\t\t  &data);\n\tbfer_mvmsta = data.bfer_mvmsta;\n\n\t \n\tif (!bfer_mvmsta) {\n\t\tIWL_DEBUG_RATE(mvm, \"No sta with BFER allowed found. Allow\\n\");\n\n\t\tss_params |= LQ_SS_BFER_ALLOWED;\n\t\tgoto out;\n\t}\n\n\tIWL_DEBUG_RATE(mvm, \"Found existing sta %d with BFER activated\\n\",\n\t\t       bfer_mvmsta->deflink.sta_id);\n\n\t \n\tif (rs_bfer_priority_cmp(mvmsta, bfer_mvmsta) > 0) {\n\t\tstruct iwl_lq_cmd *bfersta_lq_cmd =\n\t\t\t&bfer_mvmsta->deflink.lq_sta.rs_drv.lq;\n\t\tu32 bfersta_ss_params = le32_to_cpu(bfersta_lq_cmd->ss_params);\n\n\t\tbfersta_ss_params &= ~LQ_SS_BFER_ALLOWED;\n\t\tbfersta_lq_cmd->ss_params = cpu_to_le32(bfersta_ss_params);\n\t\tiwl_mvm_send_lq_cmd(mvm, bfersta_lq_cmd);\n\n\t\tss_params |= LQ_SS_BFER_ALLOWED;\n\t\tIWL_DEBUG_RATE(mvm,\n\t\t\t       \"Lower priority BFER sta found (%d). Switch BFER\\n\",\n\t\t\t       bfer_mvmsta->deflink.sta_id);\n\t}\nout:\n\tlq_cmd->ss_params = cpu_to_le32(ss_params);\n}\n\nstatic void rs_fill_lq_cmd(struct iwl_mvm *mvm,\n\t\t\t   struct ieee80211_sta *sta,\n\t\t\t   struct iwl_lq_sta *lq_sta,\n\t\t\t   const struct rs_rate *initial_rate)\n{\n\tstruct iwl_lq_cmd *lq_cmd = &lq_sta->lq;\n\tstruct iwl_mvm_sta *mvmsta;\n\tstruct iwl_mvm_vif *mvmvif;\n\n\tlq_cmd->agg_disable_start_th = IWL_MVM_RS_AGG_DISABLE_START;\n\tlq_cmd->agg_time_limit =\n\t\tcpu_to_le16(IWL_MVM_RS_AGG_TIME_LIMIT);\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n\tif (lq_sta->pers.dbg_fixed_rate) {\n\t\trs_build_rates_table_from_fixed(mvm, lq_cmd,\n\t\t\t\t\t\tlq_sta->band,\n\t\t\t\t\t\tlq_sta->pers.dbg_fixed_rate);\n\t\treturn;\n\t}\n#endif\n\tif (WARN_ON_ONCE(!sta || !initial_rate))\n\t\treturn;\n\n\trs_build_rates_table(mvm, sta, lq_sta, initial_rate);\n\n\tif (fw_has_api(&mvm->fw->ucode_capa, IWL_UCODE_TLV_API_LQ_SS_PARAMS))\n\t\trs_set_lq_ss_params(mvm, sta, lq_sta, initial_rate);\n\n\tmvmsta = iwl_mvm_sta_from_mac80211(sta);\n\tmvmvif = iwl_mvm_vif_from_mac80211(mvmsta->vif);\n\n\tif (!fw_has_capa(&mvm->fw->ucode_capa, IWL_UCODE_TLV_CAPA_COEX_SCHEMA_2) &&\n\t    num_of_ant(initial_rate->ant) == 1)\n\t\tlq_cmd->single_stream_ant_msk = initial_rate->ant;\n\n\tlq_cmd->agg_frame_cnt_limit = lq_sta->pers.max_agg_bufsize;\n\n\t \n\tif (iwl_mvm_vif_low_latency(mvmvif))\n\t\tlq_cmd->agg_frame_cnt_limit--;\n\n\tif (mvmsta->vif->p2p)\n\t\tlq_cmd->flags |= LQ_FLAG_USE_RTS_MSK;\n\n\tlq_cmd->agg_time_limit =\n\t\t\tcpu_to_le16(iwl_mvm_coex_agg_time_limit(mvm, sta));\n}\n\nstatic void *rs_alloc(struct ieee80211_hw *hw)\n{\n\treturn hw->priv;\n}\n\n \nstatic void rs_free(void *mvm_rate)\n{\n\treturn;\n}\n\nstatic void rs_free_sta(void *mvm_r, struct ieee80211_sta *sta, void *mvm_sta)\n{\n\tstruct iwl_op_mode *op_mode __maybe_unused = mvm_r;\n\tstruct iwl_mvm *mvm __maybe_unused = IWL_OP_MODE_GET_MVM(op_mode);\n\n\tIWL_DEBUG_RATE(mvm, \"enter\\n\");\n\tIWL_DEBUG_RATE(mvm, \"leave\\n\");\n}\n\nint rs_pretty_print_rate_v1(char *buf, int bufsz, const u32 rate)\n{\n\n\tchar *type;\n\tu8 mcs = 0, nss = 0;\n\tu8 ant = (rate & RATE_MCS_ANT_AB_MSK) >> RATE_MCS_ANT_POS;\n\tu32 bw = (rate & RATE_MCS_CHAN_WIDTH_MSK_V1) >>\n\t\tRATE_MCS_CHAN_WIDTH_POS;\n\n\tif (!(rate & RATE_MCS_HT_MSK_V1) &&\n\t    !(rate & RATE_MCS_VHT_MSK_V1) &&\n\t    !(rate & RATE_MCS_HE_MSK_V1)) {\n\t\tint index = iwl_hwrate_to_plcp_idx(rate);\n\n\t\treturn scnprintf(buf, bufsz, \"Legacy | ANT: %s Rate: %s Mbps\",\n\t\t\t\t iwl_rs_pretty_ant(ant),\n\t\t\t\t index == IWL_RATE_INVALID ? \"BAD\" :\n\t\t\t\t iwl_rate_mcs(index)->mbps);\n\t}\n\n\tif (rate & RATE_MCS_VHT_MSK_V1) {\n\t\ttype = \"VHT\";\n\t\tmcs = rate & RATE_VHT_MCS_RATE_CODE_MSK;\n\t\tnss = FIELD_GET(RATE_MCS_NSS_MSK, rate) + 1;\n\t} else if (rate & RATE_MCS_HT_MSK_V1) {\n\t\ttype = \"HT\";\n\t\tmcs = rate & RATE_HT_MCS_INDEX_MSK_V1;\n\t\tnss = ((rate & RATE_HT_MCS_NSS_MSK_V1)\n\t\t       >> RATE_HT_MCS_NSS_POS_V1) + 1;\n\t} else if (rate & RATE_MCS_HE_MSK_V1) {\n\t\ttype = \"HE\";\n\t\tmcs = rate & RATE_VHT_MCS_RATE_CODE_MSK;\n\t\tnss = FIELD_GET(RATE_MCS_NSS_MSK, rate) + 1;\n\t} else {\n\t\ttype = \"Unknown\";  \n\t}\n\n\treturn scnprintf(buf, bufsz,\n\t\t\t \"0x%x: %s | ANT: %s BW: %s MCS: %d NSS: %d %s%s%s%s%s\",\n\t\t\t rate, type, iwl_rs_pretty_ant(ant), iwl_rs_pretty_bw(bw), mcs, nss,\n\t\t\t (rate & RATE_MCS_SGI_MSK_V1) ? \"SGI \" : \"NGI \",\n\t\t\t (rate & RATE_MCS_STBC_MSK) ? \"STBC \" : \"\",\n\t\t\t (rate & RATE_MCS_LDPC_MSK_V1) ? \"LDPC \" : \"\",\n\t\t\t (rate & RATE_HE_DUAL_CARRIER_MODE_MSK) ? \"DCM \" : \"\",\n\t\t\t (rate & RATE_MCS_BF_MSK) ? \"BF \" : \"\");\n}\n\n#ifdef CONFIG_MAC80211_DEBUGFS\n \nstatic void rs_program_fix_rate(struct iwl_mvm *mvm,\n\t\t\t\tstruct iwl_lq_sta *lq_sta)\n{\n\tlq_sta->active_legacy_rate = 0x0FFF;\t \n\tlq_sta->active_siso_rate   = 0x1FD0;\t \n\tlq_sta->active_mimo2_rate  = 0x1FD0;\t \n\n\tIWL_DEBUG_RATE(mvm, \"sta_id %d rate 0x%X\\n\",\n\t\t       lq_sta->lq.sta_id, lq_sta->pers.dbg_fixed_rate);\n\n\tif (lq_sta->pers.dbg_fixed_rate) {\n\t\trs_fill_lq_cmd(mvm, NULL, lq_sta, NULL);\n\t\tiwl_mvm_send_lq_cmd(lq_sta->pers.drv, &lq_sta->lq);\n\t}\n}\n\nstatic ssize_t rs_sta_dbgfs_scale_table_write(struct file *file,\n\t\t\tconst char __user *user_buf, size_t count, loff_t *ppos)\n{\n\tstruct iwl_lq_sta *lq_sta = file->private_data;\n\tstruct iwl_mvm *mvm;\n\tchar buf[64];\n\tsize_t buf_size;\n\tu32 parsed_rate;\n\n\tmvm = lq_sta->pers.drv;\n\tmemset(buf, 0, sizeof(buf));\n\tbuf_size = min(count, sizeof(buf) -  1);\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\n\tif (sscanf(buf, \"%x\", &parsed_rate) == 1)\n\t\tlq_sta->pers.dbg_fixed_rate = parsed_rate;\n\telse\n\t\tlq_sta->pers.dbg_fixed_rate = 0;\n\n\trs_program_fix_rate(mvm, lq_sta);\n\n\treturn count;\n}\n\nstatic ssize_t rs_sta_dbgfs_scale_table_read(struct file *file,\n\t\t\tchar __user *user_buf, size_t count, loff_t *ppos)\n{\n\tchar *buff;\n\tint desc = 0;\n\tint i = 0;\n\tssize_t ret;\n\tstatic const size_t bufsz = 2048;\n\n\tstruct iwl_lq_sta *lq_sta = file->private_data;\n\tstruct iwl_mvm_sta *mvmsta =\n\t\tcontainer_of(lq_sta, struct iwl_mvm_sta, deflink.lq_sta.rs_drv);\n\tstruct iwl_mvm *mvm;\n\tstruct iwl_scale_tbl_info *tbl = &(lq_sta->lq_info[lq_sta->active_tbl]);\n\tstruct rs_rate *rate = &tbl->rate;\n\tu32 ss_params;\n\n\tmvm = lq_sta->pers.drv;\n\tbuff = kmalloc(bufsz, GFP_KERNEL);\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"sta_id %d\\n\", lq_sta->lq.sta_id);\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t  \"failed=%d success=%d rate=0%lX\\n\",\n\t\t\t  lq_sta->total_failed, lq_sta->total_success,\n\t\t\t  lq_sta->active_legacy_rate);\n\tdesc += scnprintf(buff + desc, bufsz - desc, \"fixed rate 0x%X\\n\",\n\t\t\t  lq_sta->pers.dbg_fixed_rate);\n\tdesc += scnprintf(buff + desc, bufsz - desc, \"valid_tx_ant %s%s\\n\",\n\t    (iwl_mvm_get_valid_tx_ant(mvm) & ANT_A) ? \"ANT_A,\" : \"\",\n\t    (iwl_mvm_get_valid_tx_ant(mvm) & ANT_B) ? \"ANT_B,\" : \"\");\n\tdesc += scnprintf(buff + desc, bufsz - desc, \"lq type %s\\n\",\n\t\t\t  (is_legacy(rate)) ? \"legacy\" :\n\t\t\t  is_vht(rate) ? \"VHT\" : \"HT\");\n\tif (!is_legacy(rate)) {\n\t\tdesc += scnprintf(buff + desc, bufsz - desc, \" %s\",\n\t\t   (is_siso(rate)) ? \"SISO\" : \"MIMO2\");\n\t\tdesc += scnprintf(buff + desc, bufsz - desc, \" %s\",\n\t\t\t\t(is_ht20(rate)) ? \"20MHz\" :\n\t\t\t\t(is_ht40(rate)) ? \"40MHz\" :\n\t\t\t\t(is_ht80(rate)) ? \"80MHz\" :\n\t\t\t\t(is_ht160(rate)) ? \"160MHz\" : \"BAD BW\");\n\t\tdesc += scnprintf(buff + desc, bufsz - desc, \" %s %s %s %s\\n\",\n\t\t\t\t(rate->sgi) ? \"SGI\" : \"NGI\",\n\t\t\t\t(rate->ldpc) ? \"LDPC\" : \"BCC\",\n\t\t\t\t(lq_sta->is_agg) ? \"AGG on\" : \"\",\n\t\t\t\t(mvmsta->amsdu_enabled) ? \"AMSDU on\" : \"\");\n\t}\n\tdesc += scnprintf(buff + desc, bufsz - desc, \"last tx rate=0x%X\\n\",\n\t\t\tlq_sta->last_rate_n_flags);\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t\"general: flags=0x%X mimo-d=%d s-ant=0x%x d-ant=0x%x\\n\",\n\t\t\tlq_sta->lq.flags,\n\t\t\tlq_sta->lq.mimo_delim,\n\t\t\tlq_sta->lq.single_stream_ant_msk,\n\t\t\tlq_sta->lq.dual_stream_ant_msk);\n\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t\"agg: time_limit=%d dist_start_th=%d frame_cnt_limit=%d\\n\",\n\t\t\tle16_to_cpu(lq_sta->lq.agg_time_limit),\n\t\t\tlq_sta->lq.agg_disable_start_th,\n\t\t\tlq_sta->lq.agg_frame_cnt_limit);\n\n\tdesc += scnprintf(buff + desc, bufsz - desc, \"reduced tpc=%d\\n\",\n\t\t\t  lq_sta->lq.reduced_tpc);\n\tss_params = le32_to_cpu(lq_sta->lq.ss_params);\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t\"single stream params: %s%s%s%s\\n\",\n\t\t\t(ss_params & LQ_SS_PARAMS_VALID) ?\n\t\t\t\"VALID\" : \"INVALID\",\n\t\t\t(ss_params & LQ_SS_BFER_ALLOWED) ?\n\t\t\t\", BFER\" : \"\",\n\t\t\t(ss_params & LQ_SS_STBC_1SS_ALLOWED) ?\n\t\t\t\", STBC\" : \"\",\n\t\t\t(ss_params & LQ_SS_FORCE) ?\n\t\t\t\", FORCE\" : \"\");\n\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t\"Start idx [0]=0x%x [1]=0x%x [2]=0x%x [3]=0x%x\\n\",\n\t\t\tlq_sta->lq.initial_rate_index[0],\n\t\t\tlq_sta->lq.initial_rate_index[1],\n\t\t\tlq_sta->lq.initial_rate_index[2],\n\t\t\tlq_sta->lq.initial_rate_index[3]);\n\n\tfor (i = 0; i < LINK_QUAL_MAX_RETRY_NUM; i++) {\n\t\tu32 r = le32_to_cpu(lq_sta->lq.rs_table[i]);\n\n\t\tdesc += scnprintf(buff + desc, bufsz - desc,\n\t\t\t\t  \" rate[%d] 0x%X \", i, r);\n\t\tdesc += rs_pretty_print_rate_v1(buff + desc, bufsz - desc, r);\n\t\tif (desc < bufsz - 1)\n\t\t\tbuff[desc++] = '\\n';\n\t}\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buff, desc);\n\tkfree(buff);\n\treturn ret;\n}\n\nstatic const struct file_operations rs_sta_dbgfs_scale_table_ops = {\n\t.write = rs_sta_dbgfs_scale_table_write,\n\t.read = rs_sta_dbgfs_scale_table_read,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\nstatic ssize_t rs_sta_dbgfs_stats_table_read(struct file *file,\n\t\t\tchar __user *user_buf, size_t count, loff_t *ppos)\n{\n\tchar *buff;\n\tint desc = 0;\n\tint i, j;\n\tssize_t ret;\n\tstruct iwl_scale_tbl_info *tbl;\n\tstruct rs_rate *rate;\n\tstruct iwl_lq_sta *lq_sta = file->private_data;\n\n\tbuff = kmalloc(1024, GFP_KERNEL);\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < LQ_SIZE; i++) {\n\t\ttbl = &(lq_sta->lq_info[i]);\n\t\trate = &tbl->rate;\n\t\tdesc += sprintf(buff+desc,\n\t\t\t\t\"%s type=%d SGI=%d BW=%s DUP=0\\n\"\n\t\t\t\t\"index=%d\\n\",\n\t\t\t\tlq_sta->active_tbl == i ? \"*\" : \"x\",\n\t\t\t\trate->type,\n\t\t\t\trate->sgi,\n\t\t\t\tis_ht20(rate) ? \"20MHz\" :\n\t\t\t\tis_ht40(rate) ? \"40MHz\" :\n\t\t\t\tis_ht80(rate) ? \"80MHz\" :\n\t\t\t\tis_ht160(rate) ? \"160MHz\" : \"ERR\",\n\t\t\t\trate->index);\n\t\tfor (j = 0; j < IWL_RATE_COUNT; j++) {\n\t\t\tdesc += sprintf(buff+desc,\n\t\t\t\t\"counter=%d success=%d %%=%d\\n\",\n\t\t\t\ttbl->win[j].counter,\n\t\t\t\ttbl->win[j].success_counter,\n\t\t\t\ttbl->win[j].success_ratio);\n\t\t}\n\t}\n\tret = simple_read_from_buffer(user_buf, count, ppos, buff, desc);\n\tkfree(buff);\n\treturn ret;\n}\n\nstatic const struct file_operations rs_sta_dbgfs_stats_table_ops = {\n\t.read = rs_sta_dbgfs_stats_table_read,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t rs_sta_dbgfs_drv_tx_stats_read(struct file *file,\n\t\t\t\t\t      char __user *user_buf,\n\t\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstatic const char * const column_name[] = {\n\t\t[RS_COLUMN_LEGACY_ANT_A] = \"LEGACY_ANT_A\",\n\t\t[RS_COLUMN_LEGACY_ANT_B] = \"LEGACY_ANT_B\",\n\t\t[RS_COLUMN_SISO_ANT_A] = \"SISO_ANT_A\",\n\t\t[RS_COLUMN_SISO_ANT_B] = \"SISO_ANT_B\",\n\t\t[RS_COLUMN_SISO_ANT_A_SGI] = \"SISO_ANT_A_SGI\",\n\t\t[RS_COLUMN_SISO_ANT_B_SGI] = \"SISO_ANT_B_SGI\",\n\t\t[RS_COLUMN_MIMO2] = \"MIMO2\",\n\t\t[RS_COLUMN_MIMO2_SGI] = \"MIMO2_SGI\",\n\t};\n\n\tstatic const char * const rate_name[] = {\n\t\t[IWL_RATE_1M_INDEX] = \"1M\",\n\t\t[IWL_RATE_2M_INDEX] = \"2M\",\n\t\t[IWL_RATE_5M_INDEX] = \"5.5M\",\n\t\t[IWL_RATE_11M_INDEX] = \"11M\",\n\t\t[IWL_RATE_6M_INDEX] = \"6M|MCS0\",\n\t\t[IWL_RATE_9M_INDEX] = \"9M\",\n\t\t[IWL_RATE_12M_INDEX] = \"12M|MCS1\",\n\t\t[IWL_RATE_18M_INDEX] = \"18M|MCS2\",\n\t\t[IWL_RATE_24M_INDEX] = \"24M|MCS3\",\n\t\t[IWL_RATE_36M_INDEX] = \"36M|MCS4\",\n\t\t[IWL_RATE_48M_INDEX] = \"48M|MCS5\",\n\t\t[IWL_RATE_54M_INDEX] = \"54M|MCS6\",\n\t\t[IWL_RATE_MCS_7_INDEX] = \"MCS7\",\n\t\t[IWL_RATE_MCS_8_INDEX] = \"MCS8\",\n\t\t[IWL_RATE_MCS_9_INDEX] = \"MCS9\",\n\t\t[IWL_RATE_MCS_10_INDEX] = \"MCS10\",\n\t\t[IWL_RATE_MCS_11_INDEX] = \"MCS11\",\n\t};\n\n\tchar *buff, *pos, *endpos;\n\tint col, rate;\n\tssize_t ret;\n\tstruct iwl_lq_sta *lq_sta = file->private_data;\n\tstruct rs_rate_stats *stats;\n\tstatic const size_t bufsz = 1024;\n\n\tbuff = kmalloc(bufsz, GFP_KERNEL);\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\tpos = buff;\n\tendpos = pos + bufsz;\n\n\tpos += scnprintf(pos, endpos - pos, \"COLUMN,\");\n\tfor (rate = 0; rate < IWL_RATE_COUNT; rate++)\n\t\tpos += scnprintf(pos, endpos - pos, \"%s,\", rate_name[rate]);\n\tpos += scnprintf(pos, endpos - pos, \"\\n\");\n\n\tfor (col = 0; col < RS_COLUMN_COUNT; col++) {\n\t\tpos += scnprintf(pos, endpos - pos,\n\t\t\t\t \"%s,\", column_name[col]);\n\n\t\tfor (rate = 0; rate < IWL_RATE_COUNT; rate++) {\n\t\t\tstats = &(lq_sta->pers.tx_stats[col][rate]);\n\t\t\tpos += scnprintf(pos, endpos - pos,\n\t\t\t\t\t \"%llu/%llu,\",\n\t\t\t\t\t stats->success,\n\t\t\t\t\t stats->total);\n\t\t}\n\t\tpos += scnprintf(pos, endpos - pos, \"\\n\");\n\t}\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buff, pos - buff);\n\tkfree(buff);\n\treturn ret;\n}\n\nstatic ssize_t rs_sta_dbgfs_drv_tx_stats_write(struct file *file,\n\t\t\t\t\t       const char __user *user_buf,\n\t\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct iwl_lq_sta *lq_sta = file->private_data;\n\tmemset(lq_sta->pers.tx_stats, 0, sizeof(lq_sta->pers.tx_stats));\n\n\treturn count;\n}\n\nstatic const struct file_operations rs_sta_dbgfs_drv_tx_stats_ops = {\n\t.read = rs_sta_dbgfs_drv_tx_stats_read,\n\t.write = rs_sta_dbgfs_drv_tx_stats_write,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t iwl_dbgfs_ss_force_read(struct file *file,\n\t\t\t\t       char __user *user_buf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct iwl_lq_sta *lq_sta = file->private_data;\n\tchar buf[12];\n\tint bufsz = sizeof(buf);\n\tint pos = 0;\n\tstatic const char * const ss_force_name[] = {\n\t\t[RS_SS_FORCE_NONE] = \"none\",\n\t\t[RS_SS_FORCE_STBC] = \"stbc\",\n\t\t[RS_SS_FORCE_BFER] = \"bfer\",\n\t\t[RS_SS_FORCE_SISO] = \"siso\",\n\t};\n\n\tpos += scnprintf(buf+pos, bufsz-pos, \"%s\\n\",\n\t\t\t ss_force_name[lq_sta->pers.ss_force]);\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, pos);\n}\n\nstatic ssize_t iwl_dbgfs_ss_force_write(struct iwl_lq_sta *lq_sta, char *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct iwl_mvm *mvm = lq_sta->pers.drv;\n\tint ret = 0;\n\n\tif (!strncmp(\"none\", buf, 4)) {\n\t\tlq_sta->pers.ss_force = RS_SS_FORCE_NONE;\n\t} else if (!strncmp(\"siso\", buf, 4)) {\n\t\tlq_sta->pers.ss_force = RS_SS_FORCE_SISO;\n\t} else if (!strncmp(\"stbc\", buf, 4)) {\n\t\tif (lq_sta->stbc_capable) {\n\t\t\tlq_sta->pers.ss_force = RS_SS_FORCE_STBC;\n\t\t} else {\n\t\t\tIWL_ERR(mvm,\n\t\t\t\t\"can't force STBC. peer doesn't support\\n\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else if (!strncmp(\"bfer\", buf, 4)) {\n\t\tif (lq_sta->bfer_capable) {\n\t\t\tlq_sta->pers.ss_force = RS_SS_FORCE_BFER;\n\t\t} else {\n\t\t\tIWL_ERR(mvm,\n\t\t\t\t\"can't force BFER. peer doesn't support\\n\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\tIWL_ERR(mvm, \"valid values none|siso|stbc|bfer\\n\");\n\t\tret = -EINVAL;\n\t}\n\treturn ret ?: count;\n}\n\n#define MVM_DEBUGFS_READ_WRITE_FILE_OPS(name, bufsz) \\\n\t_MVM_DEBUGFS_READ_WRITE_FILE_OPS(name, bufsz, struct iwl_lq_sta)\n#define MVM_DEBUGFS_ADD_FILE_RS(name, parent, mode) do {\t\t\\\n\t\tdebugfs_create_file(#name, mode, parent, lq_sta,\t\\\n\t\t\t\t    &iwl_dbgfs_##name##_ops);\t\t\\\n\t} while (0)\n\nMVM_DEBUGFS_READ_WRITE_FILE_OPS(ss_force, 32);\n\nstatic void rs_drv_add_sta_debugfs(void *mvm, void *priv_sta,\n\t\t\t\t   struct dentry *dir)\n{\n\tstruct iwl_lq_sta *lq_sta = priv_sta;\n\tstruct iwl_mvm_sta *mvmsta;\n\n\tmvmsta = container_of(lq_sta, struct iwl_mvm_sta,\n\t\t\t      deflink.lq_sta.rs_drv);\n\n\tif (!mvmsta->vif)\n\t\treturn;\n\n\tdebugfs_create_file(\"rate_scale_table\", 0600, dir,\n\t\t\t    lq_sta, &rs_sta_dbgfs_scale_table_ops);\n\tdebugfs_create_file(\"rate_stats_table\", 0400, dir,\n\t\t\t    lq_sta, &rs_sta_dbgfs_stats_table_ops);\n\tdebugfs_create_file(\"drv_tx_stats\", 0600, dir,\n\t\t\t    lq_sta, &rs_sta_dbgfs_drv_tx_stats_ops);\n\tdebugfs_create_u8(\"tx_agg_tid_enable\", 0600, dir,\n\t\t\t  &lq_sta->tx_agg_tid_en);\n\tdebugfs_create_u8(\"reduced_tpc\", 0600, dir,\n\t\t\t  &lq_sta->pers.dbg_fixed_txp_reduction);\n\n\tMVM_DEBUGFS_ADD_FILE_RS(ss_force, dir, 0600);\n}\n#endif\n\n \nstatic void rs_rate_init_ops(void *mvm_r,\n\t\t\t     struct ieee80211_supported_band *sband,\n\t\t\t     struct cfg80211_chan_def *chandef,\n\t\t\t     struct ieee80211_sta *sta, void *mvm_sta)\n{\n}\n\n \nstatic const struct rate_control_ops rs_mvm_ops_drv = {\n\t.name = RS_NAME,\n\t.tx_status = rs_drv_mac80211_tx_status,\n\t.get_rate = rs_drv_get_rate,\n\t.rate_init = rs_rate_init_ops,\n\t.alloc = rs_alloc,\n\t.free = rs_free,\n\t.alloc_sta = rs_drv_alloc_sta,\n\t.free_sta = rs_free_sta,\n\t.rate_update = rs_drv_rate_update,\n#ifdef CONFIG_MAC80211_DEBUGFS\n\t.add_sta_debugfs = rs_drv_add_sta_debugfs,\n#endif\n\t.capa = RATE_CTRL_CAPA_VHT_EXT_NSS_BW,\n};\n\nvoid iwl_mvm_rs_rate_init(struct iwl_mvm *mvm,\n\t\t\t  struct ieee80211_vif *vif,\n\t\t\t  struct ieee80211_sta *sta,\n\t\t\t  struct ieee80211_bss_conf *link_conf,\n\t\t\t  struct ieee80211_link_sta *link_sta,\n\t\t\t  enum nl80211_band band)\n{\n\tif (iwl_mvm_has_tlc_offload(mvm)) {\n\t\tiwl_mvm_rs_fw_rate_init(mvm, vif, sta, link_conf,\n\t\t\t\t\tlink_sta, band);\n\t} else {\n\t\tstruct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);\n\n\t\tspin_lock_bh(&mvmsta->deflink.lq_sta.rs_drv.pers.lock);\n\t\trs_drv_rate_init(mvm, sta, band);\n\t\tspin_unlock_bh(&mvmsta->deflink.lq_sta.rs_drv.pers.lock);\n\t}\n}\n\nint iwl_mvm_rate_control_register(void)\n{\n\treturn ieee80211_rate_control_register(&rs_mvm_ops_drv);\n}\n\nvoid iwl_mvm_rate_control_unregister(void)\n{\n\tieee80211_rate_control_unregister(&rs_mvm_ops_drv);\n}\n\nstatic int rs_drv_tx_protection(struct iwl_mvm *mvm, struct iwl_mvm_sta *mvmsta,\n\t\t\t\tbool enable)\n{\n\tstruct iwl_lq_cmd *lq = &mvmsta->deflink.lq_sta.rs_drv.lq;\n\n\tlockdep_assert_held(&mvm->mutex);\n\n\tif (enable) {\n\t\tif (mvmsta->tx_protection == 0)\n\t\t\tlq->flags |= LQ_FLAG_USE_RTS_MSK;\n\t\tmvmsta->tx_protection++;\n\t} else {\n\t\tmvmsta->tx_protection--;\n\t\tif (mvmsta->tx_protection == 0)\n\t\t\tlq->flags &= ~LQ_FLAG_USE_RTS_MSK;\n\t}\n\n\treturn iwl_mvm_send_lq_cmd(mvm, lq);\n}\n\n \nint iwl_mvm_tx_protection(struct iwl_mvm *mvm, struct iwl_mvm_sta *mvmsta,\n\t\t\t  bool enable)\n{\n\tif (iwl_mvm_has_tlc_offload(mvm))\n\t\treturn rs_fw_tx_protection(mvm, mvmsta, enable);\n\telse\n\t\treturn rs_drv_tx_protection(mvm, mvmsta, enable);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}